:: Sequent calculus, derivability, provability. Goedel's completeness theorem.
::  by Marco B. Caminati
::
:: Received December 29, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, RELAT_1,
      RELAT_2, FINSEQ_1, FUNCT_1, ARYTM_3, XCMPLX_0, CARD_1, ARYTM_1, FUNCT_2,
      XXREAL_0, ORDINAL4, FUNCT_7, FINSEQ_2, EQREL_1, COMPLEX1, MCART_1,
      PARTFUN1, MARGREL1, XBOOLEAN, FINSET_1, FUNCT_3, SETFAM_1, FUNCT_4,
      FUNCOP_1, CARD_3, FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3, FOMODEL4;
 notations TARSKI, MARGREL1, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SETFAM_1, SUBSET_1, DOMAIN_1,
      RELAT_1, RELSET_1, FUNCT_1, PARTFUN1, FUNCT_2, MCART_1, ORDINAL1, NAT_1,
      CARD_1, NUMBERS, XCMPLX_0, RELAT_2, XXREAL_0, FUNCT_7, FINSEQ_1, LANG1,
      FINSEQ_2, EQREL_1, INT_2, FINSET_1, FUNCT_4, FUNCOP_1, CARD_3, ORDERS_4,
      FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3;
 constructors NAT_1, CARD_1, ZFMISC_1, NUMBERS, INT_1, FINSEQ_1, XCMPLX_0,
      MONOID_0, XXREAL_0, FUNCT_7, FINSEQ_2, ENUMSET1, EQREL_1, RELSET_1,
      MCART_1, MARGREL1, FINSET_1, PARTFUN1, FINSEQOP, MATRIX_2, FUNCT_3,
      RFUNCT_3, SETFAM_1, LANG1, PRE_POLY, FUNCT_1, FUNCT_4, FUNCOP_1, CARD_3,
      ORDERS_4, FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3, XTUPLE_0;
 registrations ORDINAL1, XCMPLX_0, NAT_1, RELAT_1, NUMBERS, REAL_1, FUNCT_1,
      INT_1, FINSEQ_1, XREAL_0, FUNCT_2, FINSEQ_2, SUBSET_1, RELSET_1,
      PARTFUN1, EQREL_1, FINSEQ_6, PRE_POLY, CARD_1, XBOOLE_0, XXREAL_0,
      ZFMISC_1, SETFAM_1, MARGREL1, SIMPLEX0, FINSET_1, RAMSEY_1, YELLOW12,
      REALSET1, FUNCOP_1, CARD_3, FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3,
      FUNCT_7, FUNCT_4, XTUPLE_0;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions FINSEQ_1, RELAT_1, XBOOLEAN, FUNCOP_1, FOMODEL0, FOMODEL1,
      FOMODEL2, FOMODEL3, XTUPLE_0;
 theorems TARSKI, XBOOLE_0, FUNCT_1, FINSEQ_1, RELAT_1, XBOOLE_1, ZFMISC_1,
      FUNCT_2, ENUMSET1, NAT_1, ORDINAL1, MCART_1, FUNCT_7, ABSVALUE, EQREL_1,
      RELSET_1, PARTFUN1, RELSET_2, LANG1, FRAENKEL, RFUNCT_1, FINSEQ_2,
      HENMODEL, FUNCT_4, FUNCOP_1, SUPINF_2, GRFUNC_1, RELAT_2, XREAL_1,
      FOMODEL0, FOMODEL1, FOMODEL2, FOMODEL3, CARD_1, XTUPLE_0;
 schemes NAT_1, FUNCT_2, RELSET_1, FRAENKEL;

begin
L1: (for R8 being set holds (for R9 being set holds (for R10 being set holds (R10 is (Subset of ( Funcs (R8 , R9) )) implies R10 is (Subset-Family of [: R8 , R9 :])))))
proof
let R8 being set;
let R9 being set;
let R10 being set;
L2: ( Funcs (R8 , R9) ) c= ( bool [: R8 , R9 :] ) by FRAENKEL:2;
assume L3: R10 is (Subset of ( Funcs (R8 , R9) ));
thus L4: thesis by L3 , L2 , XBOOLE_1:1;
end;
L5: (for R18 being Language holds (for R41 being  termal (string of R18) holds (for R42 being  termal (string of R18) holds ( ( <* ( TheEqSymbOf R18 ) *> ^ R41 ) ^ R42 ) is  0wff  0wff  0wff  0wff (string of R18))))
proof
let R18 being Language;
let R41 being  termal (string of R18);
let R42 being  termal (string of R18);
set D1 = ( TheEqSymbOf R18 );
set D2 = ( AllTermsOf R18 );
set D3 = ( R18 -multiCat );
set D4 = ( AllSymbolsOf R18 );
reconsider D5 = R41 , D6 = R42 as (Element of D2) by FOMODEL1:def 32;
reconsider D7 = ( <* D5 *> ^ <* D6 *> ) as 2 -element (Element of ( D2 * )) by FINSEQ_1:def 11;
reconsider D8 = D2 as (Subset of ( D4 * )) by XBOOLE_1:1;
reconsider D9 = D7 as (Element of ( D8 * ));
reconsider D10 = D9 as (Element of ( ( D4 * ) * ));
reconsider D11 = D1 as  ofAtomicFormula (Element of R18);
L6: ( abs ( - 2 ) ) = ( - ( - 2 ) ) by ABSVALUE:def 1
.= 2;
L7: ( abs ( ar D11 ) ) = 2 by L6 , FOMODEL1:def 23;
L8: ( D3 . D9 ) is (Element of ( D4 * ));
reconsider D12 = ( D3 . D7 ) as (FinSequence of D4) by L8;
reconsider D13 = D4 as non  empty set;
reconsider D14 = D11 as (Element of D13);
reconsider D15 = <* D14 *> as (FinSequence of D4);
reconsider D16 = ( D15 ^ D12 ) as non  empty (FinSequence of D4);
reconsider D17 = D16 as (string of R18) by FOMODEL1:13;
L9: D12 = ( ( D4 -multiCat ) . <* D5 , D6 *> )
.= ( D5 ^ D6 ) by FOMODEL0:15;
L10: ( <* D1 *> ^ ( R41 ^ R42 ) ) is  0wff  0wff  0wff  0wff (string of R18) by L9 , L7 , FOMODEL1:def 35;
thus L11: ( ( <* D1 *> ^ R41 ) ^ R42 ) is  0wff  0wff  0wff  0wff (string of R18) by L10 , FINSEQ_1:32;
end;
definition
let C1 being Language;
func C1 -sequents equals 
{ [ B1 , B2 ] where B1 is (Subset of ( AllFormulasOf C1 )) , B2 is  wff (string of C1) : B1 is  finite };
coherence;
end;
registration
let C2 being Language;
cluster ( C2 -sequents ) -> non  empty;
coherence
proof
set D18 = ( AllFormulasOf C2 );
set D19 = the  finite (Subset of D18);
set D20 = the  wff (string of C2);
L13: [ D19 , D20 ] in ( C2 -sequents );
thus L14: thesis by L13;
end;
end;
registration
let R18 being Language;
cluster ( R18 -sequents ) ->  Relation-like;
coherence
proof
set D21 = ( AllSymbolsOf R18 );
set D22 = ( ( D21 * ) \ { ( {} ) } );
set D23 = ( AllFormulasOf R18 );
L16:
now
let R17 being set;
assume L17: R17 in ( R18 -sequents );
consider C3 being (Subset of D23), C4 being  wff (string of R18) such that L18: (R17 = [ C3 , C4 ] & C3 is  finite) by L17;
thus L19: R17 in [: ( bool D23 ) , D22 :] by L18;
end;
L20: ( R18 -sequents ) is (Subset of [: ( bool D23 ) , D22 :]) by L16 , TARSKI:def 3;
thus L21: thesis by L20;
end;
end;
definition
let C5 being Language;
let C6 being set;
attr C6 is C5 -sequent-like
means
:L23: C6 in ( C5 -sequents );
end;
definition
let R18 being Language;
let R10 being set;
attr R10 is R18 -sequents-like
means
:L25: R10 c= ( R18 -sequents );
end;
registration
let R18 being Language;
cluster  -> R18 -sequents-like for (Subset of ( R18 -sequents ));
coherence by L25;
cluster  -> R18 -sequent-like for (Element of ( R18 -sequents ));
coherence by L23;
end;
registration
let C7 being Language;
cluster C7 -sequent-like for (Element of ( C7 -sequents ));
existence
proof
take the (Element of ( C7 -sequents ));
thus L28: thesis;
end;
cluster C7 -sequents-like for (Subset of ( C7 -sequents ));
existence
proof
take the (Subset of ( C7 -sequents ));
thus L29: thesis;
end;
end;
registration
let R18 being Language;
cluster R18 -sequent-like for set;
existence
proof
take the (Element of ( R18 -sequents ));
thus L31: thesis;
end;
cluster R18 -sequents-like for set;
existence
proof
take the (Subset of ( R18 -sequents ));
thus L32: thesis;
end;
end;
definition
let C8 being Language;
mode Rule of C8
 is (Element of ( Funcs (( bool ( C8 -sequents ) ) , ( bool ( C8 -sequents ) )) ));
end;
definition
let C9 being Language;
mode RuleSet of C9
 is (Subset of ( Funcs (( bool ( C9 -sequents ) ) , ( bool ( C9 -sequents ) )) ));
end;
registration
let R8 being set;
let R9 being set;
let C10 being (Subset of ( Funcs (R8 , R9) ));
cluster ( union C10 ) ->  Relation-like;
coherence;
end;
registration
let C11 being Language;
let C12 being (RuleSet of C11);
cluster ( union C12 ) ->  Relation-like;
coherence;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
func OneStep R53 -> (Rule of R18) means 
:L38: (for B3 being (Element of ( bool ( R18 -sequents ) )) holds ( it . B3 ) = ( union ( ( union R53 ) .: { B3 } ) ));
existence
proof
set D24 = ( R18 -sequents );
set D25 = ( Funcs (( bool D24 ) , ( bool D24 )) );
reconsider D26 = ( union R53 ) as (Relation of ( bool D24 )) by FOMODEL0:19;
deffunc H1((Element of ( bool D24 ))) = ( union ( D26 .: { $1 } ) );
consider C13 being (Function of ( bool D24 ) , ( bool D24 )) such that L39: (for B4 being (Element of ( bool D24 )) holds ( C13 . B4 ) = H1(B4)) from FUNCT_2:sch 4;
reconsider D27 = C13 as (Element of D25) by FUNCT_2:8;
take D27;
thus L40: thesis by L39;
end;
uniqueness
proof
set D28 = ( R18 -sequents );
set D29 = ( Funcs (( bool D28 ) , ( bool D28 )) );
let C14 , C15 being (Rule of R18);
reconsider D30 = C14 , D31 = C15 as (Function of ( bool D28 ) , ( bool D28 ));
deffunc H2(set) = ( union ( ( union R53 ) .: { $1 } ) );
assume L41: (for B5 being (Element of ( bool D28 )) holds ( C14 . B5 ) = H2(B5));
assume L42: (for B6 being (Element of ( bool D28 )) holds ( C15 . B6 ) = H2(B6));
L43:
now
let C16 being (Element of ( bool D28 ));
thus L44: ( D30 . C16 ) = H2(C16) by L41
.= ( D31 . C16 ) by L42;
end;
thus L45: thesis by L43 , FUNCT_2:63;
end;
end;
L47: (for R2 being Nat holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (for R57 being (Rule of R18) holds (for R58 being (Subset of ( R18 -sequents )) holds (for R64 being R18 -sequents-like set holds (( dom ( OneStep R53 ) ) = ( bool ( R18 -sequents ) ) & ( rng ( OneStep R53 ) ) c= ( dom ( OneStep R53 ) ) & ( iter (( OneStep R53 ) , R2) ) is (Function of ( bool ( R18 -sequents ) ) , ( bool ( R18 -sequents ) )) & ( dom ( iter (( OneStep R53 ) , R2) ) ) = ( bool ( R18 -sequents ) ) & ( ( dom ( OneStep R53 ) ) \/ ( rng ( OneStep R53 ) ) ) = ( bool ( R18 -sequents ) ) & R58 in ( dom R57 ) & R64 in ( dom ( iter (R57 , R2) ) ))))))))
proof
let R2 being Nat;
let R18 being Language;
let R53 being (RuleSet of R18);
let R57 being (Rule of R18);
let R58 being (Subset of ( R18 -sequents ));
let R64 being R18 -sequents-like set;
set D32 = ( OneStep R53 );
set D33 = ( R18 -sequents );
thus L48: ( dom D32 ) = ( bool D33 ) by FUNCT_2:def 1;
thus L49: ( rng D32 ) c= ( dom D32 ) by L48 , RELAT_1:def 19;
thus L50: ( iter (D32 , R2) ) is (Function of ( bool D33 ) , ( bool D33 )) by FUNCT_7:83;
thus L51: ( dom ( iter (D32 , R2) ) ) = ( bool D33 ) by L50 , FUNCT_2:def 1;
thus L52: ( ( dom D32 ) \/ ( rng D32 ) ) = ( bool D33 ) by L48 , L49 , XBOOLE_1:12;
L53: ( dom R57 ) = ( bool D33 ) by FUNCT_2:def 1;
thus L54: R58 in ( dom R57 ) by L53;
L55: ( iter (R57 , R2) ) is (Function of ( bool D33 ) , ( bool D33 )) by FUNCT_7:83;
L56: (( dom ( iter (R57 , R2) ) ) = ( bool D33 ) & R64 c= D33) by L55 , L25 , FUNCT_2:def 1;
thus L57: R64 in ( dom ( iter (R57 , R2) ) ) by L56;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let R2 being Nat;
func (R2 , R53) -derivables -> (Rule of R18) equals 
( iter (( OneStep R53 ) , R2) );
coherence
proof
set D34 = ( R18 -sequents );
set D35 = ( OneStep R53 );
set D36 = ( iter (D35 , R2) );
L58: D36 is (Function of ( bool D34 ) , ( bool D34 )) by FUNCT_7:83;
thus L59: thesis by L58 , FUNCT_2:8;
end;
end;
definition
let C17 being Language;
let C18 being (RuleSet of C17);
let C19 , C20 being set;
attr C20 is C19 , C18 -derivable
means
:L61: C20 c= ( union ( ( ( OneStep C18 ) [*] ) .: { C19 } ) );
end;
definition
let R2 being Nat;
let R18 being Language;
let R53 being (RuleSet of R18);
let C21 , C22 being set;
attr C22 is R2 , C21 , R53 -derivable
means
:L63: C22 in ( ( (R2 , R53) -derivables ) . C21 );
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
func R53 -iterators -> (Subset-Family of [: ( bool ( R18 -sequents ) ) , ( bool ( R18 -sequents ) ) :]) equals 
{ ( iter (( OneStep R53 ) , R5) ) where R5 is (Element of ( NAT )) : (not contradiction) };
coherence
proof
set D37 = ( OneStep R53 );
set D38 = ( R18 -sequents );
set D39 = { ( iter (D37 , R5) ) where R5 is (Element of ( NAT )) : (not contradiction) };
L65:
now
let R13 being set;
assume L66: R13 in D39;
consider R5 being (Element of ( NAT )) such that L67: (R13 = ( iter (D37 , R5) ) & (not contradiction)) by L66;
L68: R13 is (Relation of ( bool D38 ) , ( bool D38 )) by L47 , L67;
thus L69: R13 in ( bool [: ( bool D38 ) , ( bool D38 ) :] ) by L68;
end;
thus L70: thesis by L65 , TARSKI:def 3;
end;
end;
definition
let R18 being Language;
let R57 being (Rule of R18);
attr R57 is  isotone
means
:L72: (for R59 being (Subset of ( R18 -sequents )) holds (for R60 being (Subset of ( R18 -sequents )) holds (R59 c= R60 implies ( R57 . R59 ) c= ( R57 . R60 ))));
end;
L74: (for R18 being Language holds (for R57 being (Rule of R18) holds (( id ( bool ( R18 -sequents ) ) ) is (Rule of R18) & (R57 = ( id ( bool ( R18 -sequents ) ) ) implies R57 is  isotone))))
proof
let R18 being Language;
let R57 being (Rule of R18);
set D40 = ( R18 -sequents );
reconsider D41 = ( id ( bool D40 ) ) as (Rule of R18) by FUNCT_2:8;
L75: ( id ( bool D40 ) ) = D41;
thus L76: ( id ( bool D40 ) ) is (Rule of R18) by L75;
L77:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
L78: (( D41 . R59 ) = R59 & ( D41 . R60 ) = R60) by FUNCT_1:17;
assume L79: R59 c= R60;
thus L80: ( D41 . R59 ) c= ( D41 . R60 ) by L79 , L78;
end;
assume L81: R57 = ( id ( bool D40 ) );
thus L82: thesis by L81 , L77 , L72;
end;
registration
let R18 being Language;
cluster  isotone for (Rule of R18);
existence
proof
set D42 = ( R18 -sequents );
reconsider D43 = ( id ( bool D42 ) ) as (Rule of R18) by L74;
take D43;
thus L83: D43 is  isotone by L74;
end;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
attr R53 is  isotone
means
:L85: (for R59 being (Subset of ( R18 -sequents )) holds (for R60 being (Subset of ( R18 -sequents )) holds (for R22 being Function holds ((R59 c= R60 & R22 in R53) implies (ex R23 being Function st (R23 in R53 & ( R22 . R59 ) c= ( R23 . R60 )))))));
end;
registration
let R18 being Language;
let C23 being  isotone (Rule of R18);
cluster { C23 } ->  isotone for (RuleSet of R18);
coherence
proof
set D44 = ( R18 -sequents );
L87:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
let R22 being Function;
assume L88: (R59 c= R60 & R22 in { C23 });
reconsider D45 = R22 as  isotone (Rule of R18) by L88 , TARSKI:def 1;
take D46 = R22;
thus L89: D46 in { C23 } by L88;
L90: ( D45 . R59 ) c= ( D45 . R60 ) by L88 , L72;
thus L91: ( R22 . R59 ) c= ( D46 . R60 ) by L90;
end;
thus L92: thesis by L87 , L85;
end;
end;
registration
let R18 being Language;
cluster  isotone for (RuleSet of R18);
existence
proof
set D47 = the  isotone (Rule of R18);
take D48 = { D47 };
thus L94: thesis;
end;
end;
definition
let C24 being Language;
let C25 being (RuleSet of C24);
let C26 being set;
attr C26 is C25 -derivable
means
:L96: C26 is (( {} ) , C25)-derivable;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
cluster R53 -derivable -> (( {} ) , R53)-derivable for set;
coherence by L96;
cluster (( {} ) , R53)-derivable -> R53 -derivable for set;
coherence by L96;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let C27 being  empty set;
cluster (C27 , R53)-derivable -> R53 -derivable for set;
coherence;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let R10 being set;
let C28 being set;
attr C28 is R10 , R53 -provable
means
:L100: ({ [ R10 , C28 ] } is R53 -derivable or (ex B7 being set st (( B7 `1 ) c= R10 & ( B7 `2 ) = C28 & { B7 } is R53 -derivable)));
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let R10 being set;
let R13 being set;
redefine attr R13 is R10 , R53 -provable
means
:L102: (ex B8 being set st (( B8 `1 ) c= R10 & ( B8 `2 ) = R13 & { B8 } is R53 -derivable));
compatibility
proof
defpred S1[  ] means (ex B9 being set st (( B9 `1 ) c= R10 & ( B9 `2 ) = R13 & { B9 } is R53 -derivable));
thus L103: (R13 is (R10 , R53)-provable implies S1[  ])
proof
assume L104: R13 is (R10 , R53)-provable;
per cases ;
suppose L105: { [ R10 , R13 ] } is R53 -derivable;

take D49 = [ R10 , R13 ];
thus L106: (( D49 `1 ) c= R10 & ( D49 `2 ) = R13) by MCART_1:7;
thus L107: { D49 } is R53 -derivable by L105;
end;
suppose L108: (not { [ R10 , R13 ] } is R53 -derivable);

thus L109: thesis by L108 , L100 , L104;
end;
end;

assume L111: S1[  ];
thus L112: R13 is (R10 , R53)-provable by L111 , L100;
end;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let R57 being (Rule of R18);
attr R57 is R53 -macro
means
(for B10 being (Subset of ( R18 -sequents )) holds ( R57 . B10 ) is (B10 , R53)-derivable);
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let C29 being set;
func (C29 , R53) -termEq equals 
{ [ B11 , B12 ] where B11 , B12 is  termal (string of R18) : ( ( <* ( TheEqSymbOf R18 ) *> ^ B11 ) ^ B12 ) is (C29 , R53)-provable };
coherence;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let C30 being set;
attr C30 is R53 -expanded
means
:L116: (for R13 being set holds (R13 is (C30 , R53)-provable implies { R13 } c= C30));
end;
definition
let R18 being Language;
let R13 being set;
attr R13 is R18 -null
means
:L118: (not contradiction);
end;
L120: (for R10 being set holds (for R11 being set holds (for R13 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ((R10 c= R11 & R13 is (R10 , R53)-provable) implies R13 is (R11 , R53)-provable))))))
proof
let R10 being set;
let R11 being set;
let R13 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
assume L121: R10 c= R11;
assume L122: R13 is (R10 , R53)-provable;
consider C31 being set such that L123: (( C31 `1 ) c= R10 & ( C31 `2 ) = R13 & { C31 } is R53 -derivable) by L122 , L102;
L124: (( C31 `1 ) c= R11 & ( C31 `2 ) = R13 & { C31 } is R53 -derivable) by L123 , L121 , XBOOLE_1:1;
thus L125: thesis by L124 , L102;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let C32 being set;
redefine func (C32 , R53) -termEq -> (Relation of ( AllTermsOf R18 ));

coherence
proof
L126:
now
let C33 being set;
assume L127: C33 in ( (C32 , R53) -termEq );
consider C34 , C35 being  termal (string of R18) such that L128: (C33 = [ C34 , C35 ] & ( ( <* ( TheEqSymbOf R18 ) *> ^ C34 ) ^ C35 ) is (C32 , R53)-provable) by L127;
reconsider D50 = C34 as (Element of ( AllTermsOf R18 )) by FOMODEL1:def 32;
reconsider D51 = C35 as (Element of ( AllTermsOf R18 )) by FOMODEL1:def 32;
L129: C33 = [ D50 , D51 ] by L128;
thus L130: C33 in [: ( AllTermsOf R18 ) , ( AllTermsOf R18 ) :] by L129;
end;
thus L131: thesis by L126 , TARSKI:def 3;
end;
end;
registration
let R18 being Language;
let R31 being  wff (string of R18);
let C36 , C37 being  finite (Subset of ( AllFormulasOf R18 ));
cluster [ ( C36 \/ C37 ) , R31 ] -> R18 -sequent-like;
coherence
proof
set D52 = ( AllFormulasOf R18 );
reconsider D53 = ( C36 \/ C37 ) as  finite (Subset of D52);
L133: [ D53 , R31 ] in ( R18 -sequents );
thus L134: thesis by L133;
end;
end;
definition
let R18 being Language;
let C38 being  empty set;
let C39 being  wff (string of R18);
redefine func [C38 , C39 ] -> (Element of ( R18 -sequents ));

coherence
proof
reconsider D54 = C38 as  finite (Subset of ( ( AllSymbolsOf R18 ) * )) by XBOOLE_1:2;
L136: D54 c= ( AllFormulasOf R18 ) by XBOOLE_1:2;
L137: [ D54 , C39 ] in ( R18 -sequents ) by L136;
thus L138: thesis by L137;
end;
end;
registration
let R18 being Language;
cluster ( ( {} ) /\ R18 ) -> R18 -sequents-like for set;
coherence
proof
set D55 = ( R18 -sequents );
set D56 = ( ( {} ) /\ R18 );
reconsider D57 = D56 as (Subset of D55) by XBOOLE_1:2;
L140: D57 is R18 -sequents-like;
thus L141: thesis by L140;
end;
end;
registration
let R18 being Language;
cluster R18 -null for set;
existence by L118;
end;
registration
let R18 being Language;
cluster R18 -sequent-like -> R18 -null for set;
coherence by L118;
end;
registration
let R18 being Language;
cluster  -> R18 -null for (Element of ( R18 -sequents ));
coherence;
end;
registration
let R2 being Nat;
let R18 being Language;
let R53 being (RuleSet of R18);
let R10 being set;
cluster ( ( (R2 , R53) -derivables ) . R10 ) -> R18 -sequents-like;
coherence
proof
set D58 = ( R18 -sequents );
reconsider D59 = ( (R2 , R53) -derivables ) as (Function of ( bool D58 ) , ( bool D58 ));
per cases ;
suppose L146: (not R10 in ( bool D58 ));

L147: (not R10 in ( dom D59 )) by L146;
L148: ( D59 . R10 ) = ( {} ) by L147 , FUNCT_1:def 2;
L149: ( D59 . R10 ) c= D58 by L148 , XBOOLE_1:2;
thus L150: thesis by L149;
end;
suppose L151: R10 in ( bool D58 );

reconsider D60 = R10 as (Element of ( bool D58 )) by L151;
L152: ( D59 . D60 ) is (Element of ( bool D58 ));
thus L153: thesis by L152;
end;
end;
end;
registration
let R18 being Language;
let R11 being set;
let C40 being R18 -sequents-like set;
cluster ( C40 /\ R11 ) -> R18 -sequents-like for set;
coherence
proof
set D61 = ( R18 -sequents );
L156: C40 c= D61 by L25;
L157: ( C40 /\ R11 ) c= D61 by L156 , XBOOLE_1:1;
thus L158: thesis by L157;
end;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let R2 being Nat;
let R10 being set;
cluster (R2 , R10 , R53)-derivable -> R18 -sequent-like for set;
coherence
proof
set D62 = ( OneStep R53 );
set D63 = ( union ( ( D62 [*] ) .: { R10 } ) );
set D64 = ( R18 -sequents );
L160: ( ( (R2 , R53) -derivables ) . R10 ) c= D64 by L25;
let R13 being set;
assume L161: R13 is (R2 , R10 , R53)-derivable;
L162: R13 in ( ( (R2 , R53) -derivables ) . R10 ) by L161 , L63;
thus L163: thesis by L162 , L160;
end;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let C41 , C42 being set;
cluster (( C41 \ C42 ) , R53)-provable -> (C41 , R53)-provable for set;
coherence by L120;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let C43 , C44 being set;
cluster (( C43 \ C44 ) , R53)-provable -> (( C43 \/ C44 ) , R53)-provable for set;
coherence by L120 , XBOOLE_1:7;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let C45 , C46 being set;
cluster (( C45 /\ C46 ) , R53)-provable -> (C45 , R53)-provable for set;
coherence by L120;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let C47 being set;
let C48 being (Subset of C47);
cluster (C48 , R53)-provable -> (C47 , R53)-provable for set;
coherence
proof
let R16 being set;
assume L168: R16 is (C48 , R53)-provable;
consider C49 being set such that L169: (( C49 `1 ) c= C48 & ( C49 `2 ) = R16 & { C49 } is R53 -derivable) by L168 , L102;
L170: (( C49 `1 ) c= C47 & ( C49 `2 ) = R16 & { C49 } is R53 -derivable) by L169 , XBOOLE_1:1;
thus L171: thesis by L170 , L102;
end;
end;
registration
let R18 being Language;
let C50 being  finite (Subset of ( AllFormulasOf R18 ));
let C51 being  wff (string of R18);
cluster [ C50 , C51 ] -> R18 -sequent-like for set;
coherence
proof
set D65 = [ C50 , C51 ];
set D66 = ( R18 -sequents );
L173: D65 in D66;
thus L174: thesis by L173;
end;
end;
registration
let R18 being Language;
let C52 , C53 being  wff (string of R18);
cluster [ { C52 } , C53 ] -> R18 -sequent-like for set;
coherence
proof
set D67 = ( AllFormulasOf R18 );
reconsider D68 = C52 as (Element of D67) by FOMODEL2:16;
reconsider D69 = { D68 } as  finite (Subset of D67);
L176: [ D69 , C53 ] is R18 -sequent-like;
thus L177: thesis by L176;
end;
let C54 being  wff (string of R18);
cluster [ { C52 , C53 } , C54 ] -> R18 -sequent-like for set;
coherence
proof
set D70 = ( AllFormulasOf R18 );
reconsider D71 = C52 , D72 = C53 as (Element of D70) by FOMODEL2:16;
reconsider D73 = ( { D71 } \/ { D72 } ) as  finite (Subset of D70);
L178: ([ D73 , C53 ] is R18 -sequent-like & D73 = { D71 , D72 }) by ENUMSET1:1;
thus L179: thesis by L178;
end;
end;
registration
let R18 being Language;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
let C55 being  finite (Subset of ( AllFormulasOf R18 ));
cluster [ ( C55 \/ { R32 } ) , R33 ] -> R18 -sequent-like for set;
coherence
proof
set D74 = ( AllFormulasOf R18 );
reconsider D75 = R32 as (Element of D74) by FOMODEL2:16;
reconsider D76 = ( C55 \/ { D75 } ) as  finite (Subset of D74);
L181: [ D76 , R33 ] is R18 -sequent-like;
thus L182: thesis by L181;
end;
end;
L184: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (R10 c= ( R18 -sequents ) implies ( ( OneStep R53 ) . R10 ) = ( union ( union { ( B13 .: { R10 } ) where B13 is (Subset of [: ( bool ( R18 -sequents ) ) , ( bool ( R18 -sequents ) ) :]) : B13 in R53 } ) )))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D77 = ( R18 -sequents );
set D78 = { ( B14 .: { R10 } ) where B14 is (Subset of [: ( bool D77 ) , ( bool D77 ) :]) : B14 in R53 };
set D79 = ( OneStep R53 );
assume L185: R10 c= D77;
reconsider D80 = R10 as (Element of ( bool D77 )) by L185;
reconsider D81 = R53 as (Subset-Family of [: ( bool D77 ) , ( bool D77 ) :]) by L1;
L186: ( D79 . D80 ) = ( union ( ( union D81 ) .: { D80 } ) ) by L38
.= ( union ( union D78 ) ) by RELSET_2:34;
thus L187: thesis by L186;
end;
L188: (for R18 being Language holds (for R57 being (Rule of R18) holds R57 = ( OneStep { R57 } )))
proof
let R18 being Language;
let R57 being (Rule of R18);
set D82 = ( OneStep { R57 } );
L189: ( dom R57 ) = ( bool ( R18 -sequents ) ) by FUNCT_2:def 1
.= ( dom D82 ) by FUNCT_2:def 1;
L190:
now
let C56 being set;
assume L191: C56 in ( dom R57 );
thus L192: ( R57 . C56 ) = ( union { ( R57 . C56 ) } ) by ZFMISC_1:25
.= ( union ( Im (R57 , C56) ) ) by L191 , FUNCT_1:59
.= ( union ( ( union { R57 } ) .: { C56 } ) ) by ZFMISC_1:25
.= ( D82 . C56 ) by L38 , L191;
end;
thus L193: thesis by L190 , L189 , FUNCT_1:2;
end;
L194: (for R16 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (for R58 being (Subset of ( R18 -sequents )) holds ({ R16 } is (R58 , R53)-derivable implies (ex R5 being (Element of ( NAT )) st R16 is (R5 , R58 , R53)-derivable))))))
proof
let R16 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
let R58 being (Subset of ( R18 -sequents ));
set D83 = R58;
set D84 = ( R18 -sequents );
set D85 = ( OneStep R53 );
set D86 = ( R53 -iterators );
assume L195: { R16 } is (D83 , R53)-derivable;
L196: { R16 } c= ( union ( ( D85 [*] ) .: { D83 } ) ) by L195 , L61;
L197: R16 in ( union ( ( D85 [*] ) .: { D83 } ) ) by L196 , ZFMISC_1:31;
consider R11 being set such that L198: (R16 in R11 & R11 in ( ( D85 [*] ) .: { D83 } )) by L197 , TARSKI:def 4;
L199: ( rng D85 ) c= ( dom D85 ) by L47;
L200: ( D85 [*] ) = ( union D86 ) by L199 , FOMODEL0:17;
L201: ( ( D85 [*] ) .: { D83 } ) = ( union { ( B15 .: { D83 } ) where B15 is (Subset of [: ( bool D84 ) , ( bool D84 ) :]) : B15 in D86 } ) by L200 , RELSET_2:34;
consider R12 being set such that L202: (R11 in R12 & R12 in { ( B16 .: { D83 } ) where B16 is (Subset of [: ( bool D84 ) , ( bool D84 ) :]) : B16 in D86 }) by L201 , L198 , TARSKI:def 4;
consider C57 being (Subset of [: ( bool D84 ) , ( bool D84 ) :]) such that L203: (R12 = ( C57 .: { D83 } ) & C57 in D86) by L202;
consider C58 being (Element of ( NAT )) such that L204: (C57 = ( iter (D85 , C58) ) & (not contradiction)) by L203;
take C58;
L205: ( iter (D85 , C58) ) is (Function of ( bool D84 ) , ( bool D84 )) by FUNCT_7:83;
L206: ( dom ( iter (D85 , C58) ) ) = ( bool D84 ) by L205 , FUNCT_2:def 1;
L207: (R16 in R11 & R11 in ( Im (( iter (D85 , C58) ) , D83) )) by L198 , L202 , L204 , L203;
L208: (R16 in R11 & R11 in { ( ( iter (D85 , C58) ) . D83 ) }) by L207 , L206 , FUNCT_1:59;
L209: R16 in ( ( (C58 , R53) -derivables ) . R58 ) by L208 , TARSKI:def 1;
thus L210: R16 is (C58 , R58 , R53)-derivable by L209 , L63;
end;
L211: (for R2 being Nat holds (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (R10 c= ( R18 -sequents ) implies ( ( (R2 , R53) -derivables ) . R10 ) c= ( union ( ( ( OneStep R53 ) [*] ) .: { R10 } ) ))))))
proof
let R2 being Nat;
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D87 = ( OneStep R53 );
set D88 = ( union ( ( D87 [*] ) .: { R10 } ) );
set D89 = ( R18 -sequents );
assume L212: R10 c= D89;
L213: R10 in ( dom ( iter (D87 , R2) ) ) by L212 , L47;
reconsider D90 = ( union { ( iter (D87 , R2) ) } ) as Function by ZFMISC_1:25;
L214: ( ( iter (D87 , R2) ) . R10 ) = ( union { ( ( iter (D87 , R2) ) . R10 ) } ) by ZFMISC_1:25
.= ( union ( Im (( iter (D87 , R2) ) , R10) ) ) by L213 , FUNCT_1:59
.= ( union ( D90 .: { R10 } ) ) by ZFMISC_1:25;
reconsider D91 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
L215: ( iter (D87 , D91) ) = ( iter (D87 , R2) );
L216: ( iter (D87 , R2) ) in ( R53 -iterators ) by L215;
L217: { ( iter (D87 , R2) ) } c= ( R53 -iterators ) by L216 , ZFMISC_1:31;
L218: ( union { ( iter (D87 , R2) ) } ) c= ( union ( R53 -iterators ) ) by L217 , ZFMISC_1:77;
L219: ( D90 .: { R10 } ) c= ( ( union ( R53 -iterators ) ) .: { R10 } ) by L218 , RELAT_1:124;
L220: ( ( (R2 , R53) -derivables ) . R10 ) c= ( union ( ( union ( R53 -iterators ) ) .: { R10 } ) ) by L219 , L214 , ZFMISC_1:77;
L221: ( rng D87 ) c= ( dom D87 ) by L47;
thus L222: thesis by L221 , L220 , FOMODEL0:17;
end;
L223: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ( union ( ( ( OneStep R53 ) [*] ) .: { R10 } ) ) = ( union { ( ( (B17 , R53) -derivables ) . R10 ) where B17 is (Element of ( NAT )) : (not contradiction) } ))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D92 = { ( ( (B18 , R53) -derivables ) . R10 ) where B18 is (Element of ( NAT )) : (not contradiction) };
set D93 = ( union D92 );
set D94 = ( R18 -sequents );
set D95 = ( OneStep R53 );
set D96 = ( union ( ( D95 [*] ) .: { R10 } ) );
per cases ;
suppose L224: (not R10 in ( bool D94 ));

L225: { R10 } misses ( bool D94 ) by L224 , ZFMISC_1:50;
L226: { R10 } misses ( dom ( D95 [*] ) ) by L225 , XBOOLE_1:63;
L227: ( { R10 } /\ ( dom ( D95 [*] ) ) ) = ( {} ) by L226 , XBOOLE_0:def 7;
L228: ( ( D95 [*] ) .: { R10 } ) = ( ( D95 [*] ) .: ( {} ) ) by L227 , RELAT_1:112
.= ( {} );
reconsider D97 = ( ( D95 [*] ) .: { R10 } ) as  empty set by L228;
L229:
now
let R13 being set;
assume L230: R13 in D92;
consider R5 being (Element of ( NAT )) such that L231: R13 = ( ( (R5 , R53) -derivables ) . R10 ) by L230;
L232: (not R10 in ( dom ( (R5 , R53) -derivables ) )) by L224;
L233: R13 = ( {} ) by L232 , L231 , FUNCT_1:def 2;
thus L234: R13 in { ( {} ) } by L233 , TARSKI:def 1;
end;
L235: D92 c= { ( {} ) } by L229 , TARSKI:def 3;
L236: D93 c= ( union { ( {} ) } ) by L235 , ZFMISC_1:77;
L237: D93 c= ( {} ) by L236 , ZFMISC_1:25;
L238: (( union D97 ) = ( {} ) & D93 = ( {} )) by L237;
thus L239: thesis by L238;
end;
suppose L240: R10 in ( bool D94 );

reconsider D98 = R10 as (Element of ( bool D94 )) by L240;
L241: (for R11 being set holds (R11 in D92 implies R11 c= D96))
proof
let R11 being set;
assume L242: R11 in D92;
consider R5 being (Element of ( NAT )) such that L243: (R11 = ( ( (R5 , R53) -derivables ) . R10 ) & (not contradiction)) by L242;
thus L244: thesis by L243 , L240 , L211;
end;
L245: D93 c= D96 by L241 , ZFMISC_1:76;
L246:
now
let R16 being set;
assume L247: R16 in D96;
L248: { R16 } c= D96 by L247 , ZFMISC_1:31;
L249: { R16 } is (D98 , R53)-derivable by L248 , L61;
consider R5 being (Element of ( NAT )) such that L250: R16 is (R5 , D98 , R53)-derivable by L249 , L194;
set D99 = ( ( (R5 , R53) -derivables ) . D98 );
L251: (R16 in D99 & D99 in D92) by L63 , L250;
thus L252: R16 in D93 by L251 , TARSKI:def 4;
end;
L253: D96 c= D93 by L246 , TARSKI:def 3;
thus L254: thesis by L253 , L245 , XBOOLE_0:def 10;
end;
end;
L256: (for R2 being Nat holds (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ( ( (R2 , R53) -derivables ) . R10 ) c= ( union ( ( ( OneStep R53 ) [*] ) .: { R10 } ) )))))
proof
let R2 being Nat;
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D100 = { ( ( (B19 , R53) -derivables ) . R10 ) where B19 is (Element of ( NAT )) : (not contradiction) };
set D101 = ( union D100 );
set D102 = ( R18 -sequents );
set D103 = ( OneStep R53 );
set D104 = ( union ( ( D103 [*] ) .: { R10 } ) );
reconsider D105 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
L257: ( ( (D105 , R53) -derivables ) . R10 ) in D100;
L258: ( ( (D105 , R53) -derivables ) . R10 ) c= ( union D100 ) by L257 , ZFMISC_1:74;
thus L259: thesis by L258 , L223;
end;
L260: (for R2 being Nat holds (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (R13 is (R2 , R10 , R53)-derivable implies { R13 } is (R10 , R53)-derivable))))))
proof
let R2 being Nat;
let R10 being set;
let R13 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D106 = ( R18 -sequents );
set D107 = ( OneStep R53 );
set D108 = ( union ( ( D107 [*] ) .: { R10 } ) );
assume L261: R13 is (R2 , R10 , R53)-derivable;
L262: R13 in ( ( (R2 , R53) -derivables ) . R10 ) by L261 , L63;
L263: ( ( (R2 , R53) -derivables ) . R10 ) c= D108 by L256;
L264: { R13 } c= D108 by L263 , L262 , ZFMISC_1:31;
thus L265: thesis by L264 , L61;
end;
L266: (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds (for R59 being (Subset of ( R18 -sequents )) holds (for R60 being (Subset of ( R18 -sequents )) holds ((R59 c= R60 & R54 c= R55 & (R55 is  isotone or R54 is  isotone)) implies ( ( OneStep R54 ) . R59 ) c= ( ( OneStep R55 ) . R60 )))))))
proof
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D109 = ( R18 -sequents );
set D110 = ( union R54 );
set D111 = ( union R55 );
set D112 = ( OneStep R54 );
set D113 = ( OneStep R55 );
set D114 = { ( B20 .: { R59 } ) where B20 is (Subset of [: ( bool D109 ) , ( bool D109 ) :]) : B20 in R54 };
set D115 = { ( B21 .: { R60 } ) where B21 is (Subset of [: ( bool D109 ) , ( bool D109 ) :]) : B21 in R55 };
set D116 = R59;
set D117 = R60;
L267: (( D112 . D116 ) = ( union ( union D114 ) ) & ( D113 . D117 ) = ( union ( union D115 ) )) by L184;
assume L268: (D116 c= D117 & R54 c= R55 & (R55 is  isotone or R54 is  isotone));
L269:
now
let R17 being set;
assume L270: R17 in ( union ( union D114 ) );
consider R13 being set such that L271: (R17 in R13 & R13 in ( union D114 )) by L270 , TARSKI:def 4;
consider R10 being set such that L272: (R13 in R10 & R10 in D114) by L271 , TARSKI:def 4;
consider C59 being (Subset of [: ( bool D109 ) , ( bool D109 ) :]) such that L273: (R10 = ( C59 .: { D116 } ) & C59 in R54) by L272;
reconsider D118 = C59 as (Rule of R18) by L273;
L274: (R10 = ( Im (D118 , D116) ) & C59 in R54 & D116 in ( dom D118 )) by L273 , L47;
L275: R10 = { ( D118 . D116 ) } by L274 , FUNCT_1:59;
L276:
now
per cases ;
suppose L277: R55 is  isotone;

thus L278: (ex R23 being Function st (R23 in R55 & ( D118 . D116 ) c= ( R23 . D117 ))) by L277 , L273 , L268 , L85;
end;
suppose L279: (not R55 is  isotone);

consider R23 being Function such that L280: (R23 in R54 & ( D118 . D116 ) c= ( R23 . D117 )) by L279 , L273 , L268 , L85;
thus L281: (ex R23 being Function st (R23 in R55 & ( D118 . D116 ) c= ( R23 . D117 ))) by L280 , L268;
end;
end;
consider R23 being Function such that L283: (R23 in R55 & ( D118 . D116 ) c= ( R23 . D117 )) by L276;
reconsider D119 = R23 as (Rule of R18) by L283;
L284: D117 in ( dom D119 ) by L47;
L285: R13 c= ( R23 . D117 ) by L283 , L275 , L272 , TARSKI:def 1;
L286: ( Im (D119 , D117) ) in D115 by L283;
L287: { ( D119 . D117 ) } in D115 by L286 , L284 , FUNCT_1:59;
L288: { { ( D119 . D117 ) } } c= D115 by L287 , ZFMISC_1:31;
L289: ( union { { ( R23 . D117 ) } } ) c= ( union D115 ) by L288 , ZFMISC_1:77;
L290: { ( R23 . D117 ) } c= ( union D115 ) by L289 , ZFMISC_1:25;
L291: ( union { ( R23 . D117 ) } ) c= ( union ( union D115 ) ) by L290 , ZFMISC_1:77;
L292: ( R23 . D117 ) c= ( union ( union D115 ) ) by L291 , ZFMISC_1:25;
L293: R13 c= ( union ( union D115 ) ) by L292 , L285 , XBOOLE_1:1;
thus L294: R17 in ( union ( union D115 ) ) by L293 , L271;
end;
thus L295: thesis by L269 , L267 , TARSKI:def 3;
end;
L296: (for R2 being Nat holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds (for R59 being (Subset of ( R18 -sequents )) holds (for R60 being (Subset of ( R18 -sequents )) holds ((R59 c= R60 & R54 c= R55 & (R55 is  isotone or R54 is  isotone)) implies ( ( (R2 , R54) -derivables ) . R59 ) c= ( ( (R2 , R55) -derivables ) . R60 ))))))))
proof
let R2 being Nat;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D120 = ( OneStep R54 );
set D121 = ( OneStep R55 );
set D122 = ( R18 -sequents );
set D123 = R59;
set D124 = R60;
assume L297: (D123 c= D124 & R54 c= R55 & (R55 is  isotone or R54 is  isotone));
defpred S2[ Nat ] means ( ( ($1 , R54) -derivables ) . D123 ) c= ( ( ($1 , R55) -derivables ) . D124 );
L298: S2[ ( 0 ) ]
proof
L299: ( ( iter (D120 , ( 0 )) ) . D123 ) = ( ( id ( field D120 ) ) . D123 ) by FUNCT_7:68
.= ( ( id ( bool D122 ) ) . D123 ) by L47
.= D123 by FUNCT_1:17;
L300: ( ( iter (D121 , ( 0 )) ) . D124 ) = ( ( id ( field D121 ) ) . D124 ) by FUNCT_7:68
.= ( ( id ( bool D122 ) ) . D124 ) by L47
.= D124 by FUNCT_1:17;
thus L301: thesis by L300 , L299 , L297;
end;
L302: (for R3 being Nat holds (S2[ R3 ] implies S2[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
L303: (D123 in ( dom ( iter (D120 , R3) ) ) & D124 in ( dom ( iter (D121 , R3) ) )) by L47;
reconsider D125 = ( ( (R3 , R54) -derivables ) . D123 ) , D126 = ( ( (R3 , R55) -derivables ) . D124 ) as (Subset of D122);
assume L304: S2[ R3 ];
L305: ( ( (( R3 + 1 ) , R54) -derivables ) . D123 ) = ( ( D120 * ( iter (D120 , R3) ) ) . D123 ) by FUNCT_7:71
.= ( D120 . D125 ) by L303 , FUNCT_1:13;
L306: ( ( (( R3 + 1 ) , R55) -derivables ) . D124 ) = ( ( D121 * ( iter (D121 , R3) ) ) . D124 ) by FUNCT_7:71
.= ( D121 . D126 ) by L303 , FUNCT_1:13;
thus L307: thesis by L306 , L305 , L304 , L266 , L297;
end;
L308: (for B22 being Nat holds S2[ B22 ]) from NAT_1:sch 2(L298 , L302);
thus L309: thesis by L308;
end;
L310: (for R2 being Nat holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds (for R65 being R18 -sequents-like set holds (for R66 being R18 -sequents-like set holds ((R65 c= R66 & R54 c= R55 & (R55 is  isotone or R54 is  isotone)) implies ( ( (R2 , R54) -derivables ) . R65 ) c= ( ( (R2 , R55) -derivables ) . R66 ))))))))
proof
let R2 being Nat;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
let R65 being R18 -sequents-like set;
let R66 being R18 -sequents-like set;
reconsider D127 = R65 , D128 = R66 as (Subset of ( R18 -sequents )) by L25;
assume L311: (R65 c= R66 & R54 c= R55 & (R55 is  isotone or R54 is  isotone));
L312: ( ( (R2 , R54) -derivables ) . D127 ) c= ( ( (R2 , R55) -derivables ) . D128 ) by L311 , L296;
thus L313: thesis by L312;
end;
L314: (for R2 being Nat holds (for R10 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R55 is  isotone or R54 is  isotone)) implies ( ( (R2 , R54) -derivables ) . R10 ) c= ( ( (R2 , R55) -derivables ) . R10 )))))))
proof
let R2 being Nat;
let R10 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
set D129 = ( R18 -sequents );
set D130 = ( (R2 , R54) -derivables );
set D131 = ( (R2 , R55) -derivables );
assume L315: (R54 c= R55 & (R55 is  isotone or R54 is  isotone));
per cases ;
suppose L316: R10 in ( bool D129 );

reconsider D132 = R10 as (Element of ( bool D129 )) by L316;
L317: ( D130 . D132 ) c= ( D131 . D132 ) by L296 , L315;
thus L318: ( D130 . R10 ) c= ( D131 . R10 ) by L317;
end;
suppose L319: (not R10 in ( bool D129 ));

L320: ((not R10 in ( dom D130 )) & (not R10 in ( dom D131 ))) by L319;
L321: (( D130 . R10 ) = ( {} ) & ( D131 . R10 ) = ( {} )) by L320 , FUNCT_1:def 2;
thus L322: ( D130 . R10 ) c= ( D131 . R10 ) by L321;
end;
end;
L324: (for R10 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R55 is  isotone or R54 is  isotone)) implies ( union ( ( ( OneStep R54 ) [*] ) .: { R10 } ) ) c= ( union ( ( ( OneStep R55 ) [*] ) .: { R10 } ) ))))))
proof
let R10 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
set D133 = { ( ( (B23 , R54) -derivables ) . R10 ) where B23 is (Element of ( NAT )) : (not contradiction) };
set D134 = { ( ( (B24 , R55) -derivables ) . R10 ) where B24 is (Element of ( NAT )) : (not contradiction) };
set D135 = ( OneStep R54 );
set D136 = ( OneStep R55 );
set D137 = ( R18 -sequents );
set D138 = ( union ( ( D135 [*] ) .: { R10 } ) );
set D139 = ( union ( ( D136 [*] ) .: { R10 } ) );
L325: (D138 = ( union D133 ) & D139 = ( union D134 )) by L223;
assume L326: (R54 c= R55 & (R55 is  isotone or R54 is  isotone));
L327:
now
let R13 being set;
assume L328: R13 in D133;
consider R5 being (Element of ( NAT )) such that L329: (R13 = ( ( (R5 , R54) -derivables ) . R10 ) & (not contradiction)) by L328;
L330: R13 c= ( ( (R5 , R55) -derivables ) . R10 ) by L326 , L314 , L329;
L331: ( ( (R5 , R55) -derivables ) . R10 ) in D134;
L332: ( ( (R5 , R55) -derivables ) . R10 ) c= ( union D134 ) by L331 , ZFMISC_1:74;
thus L333: R13 c= ( union D134 ) by L332 , L330 , XBOOLE_1:1;
end;
thus L334: thesis by L327 , L325 , ZFMISC_1:76;
end;
L335: (for R10 being set holds (for R11 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R55 is  isotone or R54 is  isotone) & R11 is (R10 , R54)-derivable) implies R11 is (R10 , R55)-derivable))))))
proof
let R10 being set;
let R11 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
set D140 = ( OneStep R54 );
set D141 = ( OneStep R55 );
set D142 = ( R18 -sequents );
set D143 = ( union ( ( D140 [*] ) .: { R10 } ) );
set D144 = ( union ( ( D141 [*] ) .: { R10 } ) );
assume L336: (R54 c= R55 & (R55 is  isotone or R54 is  isotone) & R11 is (R10 , R54)-derivable);
L337: (D143 c= D144 & R11 c= D143) by L336 , L61 , L324;
L338: R11 c= D144 by L337 , XBOOLE_1:1;
thus L339: thesis by L338 , L61;
end;
L340: (for R11 being set holds (for R18 being Language holds (for R57 being (Rule of R18) holds (for R58 being (Subset of ( R18 -sequents )) holds (R11 c= ( R57 . R58 ) implies R11 is (R58 , { R57 })-derivable)))))
proof
let R11 being set;
let R18 being Language;
let R57 being (Rule of R18);
let R58 being (Subset of ( R18 -sequents ));
set D145 = { R57 };
set D146 = ( ( OneStep D145 ) [*] );
set D147 = ( R18 -sequents );
L341: (R58 in ( bool D147 ) & ( dom R57 ) = ( bool D147 )) by FUNCT_2:def 1;
L342: { ( R57 . R58 ) } = ( Im (R57 , R58) ) by L341 , FUNCT_1:59
.= ( R57 .: { R58 } );
L343: ( OneStep D145 ) c= D146 by LANG1:18;
L344: R57 c= D146 by L343 , L188;
L345: { ( R57 . R58 ) } c= ( D146 .: { R58 } ) by L342 , L344 , RELAT_1:124;
L346: ( union { ( R57 . R58 ) } ) c= ( union ( D146 .: { R58 } ) ) by L345 , ZFMISC_1:77;
L347: ( R57 . R58 ) c= ( union ( D146 .: { R58 } ) ) by L346 , ZFMISC_1:25;
assume L348: R11 c= ( R57 . R58 );
L349: R11 c= ( union ( D146 .: { R58 } ) ) by L348 , L347 , XBOOLE_1:1;
thus L350: thesis by L349 , L61;
end;
L351: (for R2 being Nat holds (for R3 being Nat holds (for R12 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds (for R65 being R18 -sequents-like set holds (for R66 being R18 -sequents-like set holds ((R54 is  isotone & ( R54 \/ R55 ) is  isotone & R66 c= ( ( iter (( OneStep R54 ) , R2) ) . R65 ) & R12 c= ( ( iter (( OneStep R55 ) , R3) ) . R66 )) implies R12 c= ( ( iter (( OneStep ( R54 \/ R55 ) ) , ( R2 + R3 )) ) . R65 ))))))))))
proof
let R2 being Nat;
let R3 being Nat;
let R12 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
let R65 being R18 -sequents-like set;
let R66 being R18 -sequents-like set;
reconsider D148 = R2 , D149 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
set D150 = ( R54 \/ R55 );
set D151 = ( OneStep R54 );
set D152 = ( OneStep R55 );
set D153 = ( OneStep D150 );
set D154 = R65;
set D155 = R66;
assume L352: (R54 is  isotone & D150 is  isotone);
assume L353: (D155 c= ( ( iter (D151 , R2) ) . D154 ) & R12 c= ( ( iter (D152 , R3) ) . D155 ));
L354: (D150 c= D150 & R54 c= D150 & R55 c= D150) by XBOOLE_1:7;
L355: ( ( (R2 , R54) -derivables ) . D154 ) c= ( ( (R2 , ( R54 \/ R55 )) -derivables ) . D154 ) by L354 , L314 , L352;
L356: D155 c= ( ( (R2 , D150) -derivables ) . D154 ) by L355 , L353 , XBOOLE_1:1;
L357: D154 in ( dom ( iter (D153 , R2) ) ) by L47;
L358: ( ( (R3 , R55) -derivables ) . D155 ) c= ( ( (R3 , D150) -derivables ) . D155 ) by L354 , L352 , L314;
L359: R12 c= ( ( (R3 , D150) -derivables ) . D155 ) by L358 , L353 , XBOOLE_1:1;
L360: ( ( (( R2 + R3 ) , ( R54 \/ R55 )) -derivables ) . D154 ) = ( ( ( iter (D153 , D149) ) * ( iter (D153 , D148) ) ) . D154 ) by FUNCT_7:77
.= ( ( (R3 , ( R54 \/ R55 )) -derivables ) . ( ( iter (D153 , R2) ) . D154 ) ) by L357 , FUNCT_1:13;
L361: ( ( (R3 , ( R54 \/ R55 )) -derivables ) . D155 ) c= ( ( (( R2 + R3 ) , ( R54 \/ R55 )) -derivables ) . D154 ) by L360 , L356 , L352 , L310;
thus L362: thesis by L361 , L359 , XBOOLE_1:1;
end;
L363: (for R2 being Nat holds (for R3 being Nat holds (for R10 being set holds (for R16 being set holds (for R17 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 is  isotone & ( R54 \/ R55 ) is  isotone & R16 is (R2 , R10 , R54)-derivable & R17 is (R3 , { R16 } , R55)-derivable) implies R17 is (( R2 + R3 ) , R10 , ( R54 \/ R55 ))-derivable)))))))))
proof
let R2 being Nat;
let R3 being Nat;
let R10 being set;
let R16 being set;
let R17 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
set D156 = ( R18 -sequents );
set D157 = ( R54 \/ R55 );
set D158 = ( OneStep R54 );
set D159 = ( OneStep R55 );
set D160 = ( OneStep D157 );
assume L364: (R54 is  isotone & D157 is  isotone);
assume L365: (R16 is (R2 , R10 , R54)-derivable & R17 is (R3 , { R16 } , R55)-derivable);
L366: (R16 in ( ( (R2 , R54) -derivables ) . R10 ) & R17 in ( ( (R3 , R55) -derivables ) . { R16 } )) by L365 , L63;
L367: R10 in ( bool D156 )
proof
assume L368: (not R10 in ( bool D156 ));
L369: (not R10 in ( dom ( (R2 , R54) -derivables ) )) by L368;
L370: ( ( (R2 , R54) -derivables ) . R10 ) = ( {} ) by L369 , FUNCT_1:def 2;
thus L371: contradiction by L370 , L365 , L63;
end;
reconsider D161 = R10 as (Subset of D156) by L367;
reconsider D162 = R16 as (Element of D156) by L23 , L365;
L372: ({ D162 } c= ( ( iter (D158 , R2) ) . D161 ) & { R17 } c= ( ( iter (D159 , R3) ) . { D162 } )) by L366 , ZFMISC_1:31;
L373: { R17 } c= ( ( iter (D160 , ( R2 + R3 )) ) . D161 ) by L372 , L351 , L364;
L374: R17 in ( ( (( R2 + R3 ) , D157) -derivables ) . R10 ) by L373 , ZFMISC_1:31;
thus L375: thesis by L374 , L63;
end;
L376: (for R10 being set holds (for R18 being Language holds (for R41 being  termal (string of R18) holds (for R42 being  termal (string of R18) holds (for R53 being (RuleSet of R18) holds ([ R41 , R42 ] in ( (R10 , R53) -termEq ) iff ( ( <* ( TheEqSymbOf R18 ) *> ^ R41 ) ^ R42 ) is (R10 , R53)-provable))))))
proof
let R10 being set;
let R18 being Language;
let R41 being  termal (string of R18);
let R42 being  termal (string of R18);
let R53 being (RuleSet of R18);
set D163 = ( TheEqSymbOf R18 );
set D164 = ( (R10 , R53) -termEq );
thus L377: ([ R41 , R42 ] in D164 implies ( ( <* D163 *> ^ R41 ) ^ R42 ) is (R10 , R53)-provable)
proof
assume L378: [ R41 , R42 ] in D164;
consider C60 , C61 being  termal (string of R18) such that L379: ([ C60 , C61 ] = [ R41 , R42 ] & ( ( <* D163 *> ^ C60 ) ^ C61 ) is (R10 , R53)-provable) by L378;
L380: (C60 = R41 & C61 = R42 & ( ( <* D163 *> ^ C60 ) ^ C61 ) is (R10 , R53)-provable) by L379 , XTUPLE_0:1;
thus L381: thesis by L380;
end;

assume L382: ( ( <* D163 *> ^ R41 ) ^ R42 ) is (R10 , R53)-provable;
thus L383: thesis by L382;
end;
L384: (for R18 being Language holds (for R67 being R18 -sequent-like set holds ( R67 `2 ) is  wff  wff  wff  wff (string of R18)))
proof
let R18 being Language;
let R67 being R18 -sequent-like set;
set D165 = ( R18 -sequents );
reconsider D166 = R67 as (Element of D165) by L23;
L385: D166 in D165;
consider C62 being (Subset of ( AllFormulasOf R18 )), C63 being  wff (string of R18) such that L386: (D166 = [ C62 , C63 ] & C62 is  finite) by L385;
thus L387: ( R67 `2 ) is  wff  wff  wff  wff (string of R18) by L386 , MCART_1:7;
end;
L388: (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (R13 is (R10 , R53)-provable implies R13 is  wff  wff  wff  wff (string of R18))))))
proof
let R10 being set;
let R13 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D167 = ( R18 -sequents );
assume L389: R13 is (R10 , R53)-provable;
consider R16 being set such that L390: (( R16 `1 ) c= R10 & ( R16 `2 ) = R13 & { R16 } is R53 -derivable) by L389 , L102;
reconsider D168 = ( {} ) as (Subset of D167) by XBOOLE_1:2;
L391: { R16 } is (( {} ) , R53)-derivable by L390;
consider R5 being (Element of ( NAT )) such that L392: R16 is (R5 , D168 , R53)-derivable by L391 , L194;
reconsider D169 = R16 as (Element of D167) by L23 , L392;
L393: ( D169 `2 ) is  wff  wff  wff  wff (string of R18) by L384;
thus L394: thesis by L393 , L390;
end;
L395: (for R18 being Language holds (for R53 being (RuleSet of R18) holds ( AllFormulasOf R18 ) is R53 -expanded))
proof
let R18 being Language;
let R53 being (RuleSet of R18);
set D170 = ( AllFormulasOf R18 );
L396:
now
let R13 being set;
assume L397: R13 is (D170 , R53)-provable;
reconsider D171 = R13 as  wff (string of R18) by L397 , L388;
consider R2 being Nat such that L398: D171 is R2 -wff by FOMODEL2:def 25;
L399: D171 in D170 by L398;
thus L400: { R13 } c= D170 by L399 , ZFMISC_1:31;
end;
thus L401: thesis by L396 , L116;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
cluster R53 -expanded for (Subset of ( AllFormulasOf R18 ));
existence
proof
set D172 = ( AllFormulasOf R18 );
reconsider D173 = D172 as (Subset of D172) by XBOOLE_0:def 10;
take D173;
thus L402: thesis by L395;
end;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
cluster R53 -expanded for set;
existence
proof
set D174 = ( AllFormulasOf R18 );
take the R53 -expanded (Subset of D174);
thus L404: thesis;
end;
end;
definition
let C64 being set;
let C65 being Language;
let C66 being C65 -null set;
pred C66 Rule0 C64
means
:L406: ( C66 `2 ) in ( C66 `1 )
;pred C66 Rule1 C64
means
:L407: (ex B25 being set st (B25 in C64 & ( B25 `1 ) c= ( C66 `1 ) & ( C66 `2 ) = ( B25 `2 )))
;pred C66 Rule2 C64
means
:L408: (( C66 `1 ) is  empty & (ex B26 being  termal (string of C65) st ( C66 `2 ) = ( ( <* ( TheEqSymbOf C65 ) *> ^ B26 ) ^ B26 )))
;pred C66 Rule3a C64
means
:L409: (ex B27 , B28 , B29 being  termal (string of C65) st (ex B30 being set st (B30 in C64 & ( C66 `1 ) = ( ( B30 `1 ) \/ { ( ( <* ( TheEqSymbOf C65 ) *> ^ B28 ) ^ B29 ) } ) & ( B30 `2 ) = ( ( <* ( TheEqSymbOf C65 ) *> ^ B27 ) ^ B28 ) & ( C66 `2 ) = ( ( <* ( TheEqSymbOf C65 ) *> ^ B27 ) ^ B29 ))))
;pred C66 Rule3b C64
means
:L410: (ex B31 , B32 being  termal (string of C65) st (( C66 `1 ) = { ( ( <* ( TheEqSymbOf C65 ) *> ^ B31 ) ^ B32 ) } & ( C66 `2 ) = ( ( <* ( TheEqSymbOf C65 ) *> ^ B32 ) ^ B31 )))
;pred C66 Rule3d C64
means
:L411: (ex B33 being  low-compounding (Element of C65) st (ex B34 , B35 being ( abs ( ar B33 ) ) -element (Element of ( ( AllTermsOf C65 ) * )) st (B33 is  operational & ( C66 `1 ) = { ( ( <* ( TheEqSymbOf C65 ) *> ^ ( B37 . B36 ) ) ^ ( B38 . B36 ) ) where B36 is (Element of ( Seg ( abs ( ar B33 ) ) )) , B37 , B38 is (Function of ( Seg ( abs ( ar B33 ) ) ) , ( ( ( AllSymbolsOf C65 ) * ) \ { ( {} ) } )) : (B37 = B34 & B38 = B35) } & ( C66 `2 ) = ( ( <* ( TheEqSymbOf C65 ) *> ^ ( B33 -compound B34 ) ) ^ ( B33 -compound B35 ) ))))
;pred C66 Rule3e C64
means
:L412: (ex B39 being  relational (Element of C65) st (ex B40 , B41 being ( abs ( ar B39 ) ) -element (Element of ( ( AllTermsOf C65 ) * )) st (( C66 `1 ) = ( { ( B39 -compound B40 ) } \/ { ( ( <* ( TheEqSymbOf C65 ) *> ^ ( B43 . B42 ) ) ^ ( B44 . B42 ) ) where B42 is (Element of ( Seg ( abs ( ar B39 ) ) )) , B43 , B44 is (Function of ( Seg ( abs ( ar B39 ) ) ) , ( ( ( AllSymbolsOf C65 ) * ) \ { ( {} ) } )) : (B43 = B40 & B44 = B41) } ) & ( C66 `2 ) = ( B39 -compound B41 ))))
;pred C66 Rule4 C64
means
:L413: (ex B45 being  literal (Element of C65) st (ex B46 being  wff (string of C65) st (ex B47 being  termal (string of C65) st (( C66 `1 ) = { ( (B45 , B47) SubstIn B46 ) } & ( C66 `2 ) = ( <* B45 *> ^ B46 )))))
;pred C66 Rule5 C64
means
:L414: (ex B48 , B49 being  literal (Element of C65) st (ex R13 being set st (ex R48 being FinSequence st (( C66 `1 ) = ( R13 \/ { ( <* B48 *> ^ R48 ) } ) & B49 is ( ( R13 \/ { R48 } ) \/ { ( C66 `2 ) } ) -absent & [ ( R13 \/ { ( ( B48 SubstWith B49 ) . R48 ) } ) , ( C66 `2 ) ] in C64))))
;pred C66 Rule6 C64
means
:L415: (ex B50 , B51 being set st (ex B52 , B53 being  wff (string of C65) st (B50 in C64 & B51 in C64 & ( B50 `1 ) = ( B51 `1 ) & ( B51 `1 ) = ( C66 `1 ) & ( B50 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B52 ) ^ B52 ) & ( B51 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B53 ) ^ B53 ) & ( C66 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B52 ) ^ B53 ))))
;pred C66 Rule7 C64
means
:L416: (ex B54 being set st (ex B55 , B56 being  wff (string of C65) st (B54 in C64 & ( B54 `1 ) = ( C66 `1 ) & ( B54 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B55 ) ^ B56 ) & ( C66 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B56 ) ^ B55 ))))
;pred C66 Rule8 C64
means
:L417: (ex B57 , B58 being set st (ex B59 , B60 , B61 being  wff (string of C65) st (B57 in C64 & B58 in C64 & ( B57 `1 ) = ( B58 `1 ) & ( B57 `2 ) = B60 & ( B58 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B60 ) ^ B61 ) & ( { B59 } \/ ( C66 `1 ) ) = ( B57 `1 ) & ( C66 `2 ) = ( ( <* ( TheNorSymbOf C65 ) *> ^ B59 ) ^ B59 ))))
;pred C66 Rule9 C64
means
:L418: (ex B62 being set st (ex B63 being  wff (string of C65) st (B62 in C64 & ( C66 `2 ) = B63 & ( B62 `1 ) = ( C66 `1 ) & ( B62 `2 ) = ( xnot ( xnot B63 ) ))))
;end;
definition
let C67 being Language;
func P#0 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L420: (for B64 being (Element of ( bool ( C67 -sequents ) )) holds (for B65 being (Element of ( C67 -sequents )) holds ([ B64 , B65 ] in it iff B65 Rule0 B64)));
existence
proof
defpred S3[ set , (Element of ( C67 -sequents )) ] means $2 Rule0 $1;
consider C68 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L421: (for B66 being (Element of ( bool ( C67 -sequents ) )) holds (for B67 being (Element of ( C67 -sequents )) holds ([ B66 , B67 ] in C68 iff S3[ B66 , B67 ]))) from RELSET_1:sch 2;
take C68;
thus L422: thesis by L421;
end;
uniqueness
proof
defpred S4[ set , (Element of ( C67 -sequents )) ] means $2 Rule0 $1;
let C69 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C70 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L423: (for B68 being (Element of ( bool ( C67 -sequents ) )) holds (for B69 being (Element of ( C67 -sequents )) holds ([ B68 , B69 ] in C69 iff S4[ B68 , B69 ])));
assume L424: (for B70 being (Element of ( bool ( C67 -sequents ) )) holds (for B71 being (Element of ( C67 -sequents )) holds ([ B70 , B71 ] in C70 iff S4[ B70 , B71 ])));
thus L425: thesis from RELSET_1:sch 4(L423 , L424);
end;
func P#1 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L426: (for B72 being (Element of ( bool ( C67 -sequents ) )) holds (for B73 being (Element of ( C67 -sequents )) holds ([ B72 , B73 ] in it iff B73 Rule1 B72)));
existence
proof
defpred S5[ set , (Element of ( C67 -sequents )) ] means $2 Rule1 $1;
consider C71 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L427: (for B74 being (Element of ( bool ( C67 -sequents ) )) holds (for B75 being (Element of ( C67 -sequents )) holds ([ B74 , B75 ] in C71 iff S5[ B74 , B75 ]))) from RELSET_1:sch 2;
take C71;
thus L428: thesis by L427;
end;
uniqueness
proof
defpred S6[ set , (Element of ( C67 -sequents )) ] means $2 Rule1 $1;
let C72 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C73 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L429: (for B76 being (Element of ( bool ( C67 -sequents ) )) holds (for B77 being (Element of ( C67 -sequents )) holds ([ B76 , B77 ] in C72 iff S6[ B76 , B77 ])));
assume L430: (for B78 being (Element of ( bool ( C67 -sequents ) )) holds (for B79 being (Element of ( C67 -sequents )) holds ([ B78 , B79 ] in C73 iff S6[ B78 , B79 ])));
thus L431: thesis from RELSET_1:sch 4(L429 , L430);
end;
func P#2 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L432: (for B80 being (Element of ( bool ( C67 -sequents ) )) holds (for B81 being (Element of ( C67 -sequents )) holds ([ B80 , B81 ] in it iff B81 Rule2 B80)));
existence
proof
defpred S7[ set , (Element of ( C67 -sequents )) ] means $2 Rule2 $1;
consider C74 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L433: (for B82 being (Element of ( bool ( C67 -sequents ) )) holds (for B83 being (Element of ( C67 -sequents )) holds ([ B82 , B83 ] in C74 iff S7[ B82 , B83 ]))) from RELSET_1:sch 2;
take C74;
thus L434: thesis by L433;
end;
uniqueness
proof
defpred S8[ set , (Element of ( C67 -sequents )) ] means $2 Rule2 $1;
let C75 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C76 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L435: (for B84 being (Element of ( bool ( C67 -sequents ) )) holds (for B85 being (Element of ( C67 -sequents )) holds ([ B84 , B85 ] in C75 iff S8[ B84 , B85 ])));
assume L436: (for B86 being (Element of ( bool ( C67 -sequents ) )) holds (for B87 being (Element of ( C67 -sequents )) holds ([ B86 , B87 ] in C76 iff S8[ B86 , B87 ])));
thus L437: thesis from RELSET_1:sch 4(L435 , L436);
end;
func P#3a C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L438: (for B88 being (Element of ( bool ( C67 -sequents ) )) holds (for B89 being (Element of ( C67 -sequents )) holds ([ B88 , B89 ] in it iff B89 Rule3a B88)));
existence
proof
defpred S9[ set , (Element of ( C67 -sequents )) ] means $2 Rule3a $1;
consider C77 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L439: (for B90 being (Element of ( bool ( C67 -sequents ) )) holds (for B91 being (Element of ( C67 -sequents )) holds ([ B90 , B91 ] in C77 iff S9[ B90 , B91 ]))) from RELSET_1:sch 2;
take C77;
thus L440: thesis by L439;
end;
uniqueness
proof
defpred S10[ set , (Element of ( C67 -sequents )) ] means $2 Rule3a $1;
let C78 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C79 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L441: (for B92 being (Element of ( bool ( C67 -sequents ) )) holds (for B93 being (Element of ( C67 -sequents )) holds ([ B92 , B93 ] in C78 iff S10[ B92 , B93 ])));
assume L442: (for B94 being (Element of ( bool ( C67 -sequents ) )) holds (for B95 being (Element of ( C67 -sequents )) holds ([ B94 , B95 ] in C79 iff S10[ B94 , B95 ])));
thus L443: thesis from RELSET_1:sch 4(L441 , L442);
end;
func P#3b C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L444: (for B96 being (Element of ( bool ( C67 -sequents ) )) holds (for B97 being (Element of ( C67 -sequents )) holds ([ B96 , B97 ] in it iff B97 Rule3b B96)));
existence
proof
defpred S11[ set , (Element of ( C67 -sequents )) ] means $2 Rule3b $1;
consider C80 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L445: (for B98 being (Element of ( bool ( C67 -sequents ) )) holds (for B99 being (Element of ( C67 -sequents )) holds ([ B98 , B99 ] in C80 iff S11[ B98 , B99 ]))) from RELSET_1:sch 2;
take C80;
thus L446: thesis by L445;
end;
uniqueness
proof
defpred S12[ set , (Element of ( C67 -sequents )) ] means $2 Rule3b $1;
let C81 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C82 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L447: (for B100 being (Element of ( bool ( C67 -sequents ) )) holds (for B101 being (Element of ( C67 -sequents )) holds ([ B100 , B101 ] in C81 iff S12[ B100 , B101 ])));
assume L448: (for B102 being (Element of ( bool ( C67 -sequents ) )) holds (for B103 being (Element of ( C67 -sequents )) holds ([ B102 , B103 ] in C82 iff S12[ B102 , B103 ])));
thus L449: thesis from RELSET_1:sch 4(L447 , L448);
end;
func P#3d C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L450: (for B104 being (Element of ( bool ( C67 -sequents ) )) holds (for B105 being (Element of ( C67 -sequents )) holds ([ B104 , B105 ] in it iff B105 Rule3d B104)));
existence
proof
defpred S13[ set , (Element of ( C67 -sequents )) ] means $2 Rule3d $1;
consider C83 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L451: (for B106 being (Element of ( bool ( C67 -sequents ) )) holds (for B107 being (Element of ( C67 -sequents )) holds ([ B106 , B107 ] in C83 iff S13[ B106 , B107 ]))) from RELSET_1:sch 2;
take C83;
thus L452: thesis by L451;
end;
uniqueness
proof
defpred S14[ set , (Element of ( C67 -sequents )) ] means $2 Rule3d $1;
let C84 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C85 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L453: (for B108 being (Element of ( bool ( C67 -sequents ) )) holds (for B109 being (Element of ( C67 -sequents )) holds ([ B108 , B109 ] in C84 iff S14[ B108 , B109 ])));
assume L454: (for B110 being (Element of ( bool ( C67 -sequents ) )) holds (for B111 being (Element of ( C67 -sequents )) holds ([ B110 , B111 ] in C85 iff S14[ B110 , B111 ])));
thus L455: thesis from RELSET_1:sch 4(L453 , L454);
end;
func P#3e C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L456: (for B112 being (Element of ( bool ( C67 -sequents ) )) holds (for B113 being (Element of ( C67 -sequents )) holds ([ B112 , B113 ] in it iff B113 Rule3e B112)));
existence
proof
defpred S15[ set , (Element of ( C67 -sequents )) ] means $2 Rule3e $1;
consider C86 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L457: (for B114 being (Element of ( bool ( C67 -sequents ) )) holds (for B115 being (Element of ( C67 -sequents )) holds ([ B114 , B115 ] in C86 iff S15[ B114 , B115 ]))) from RELSET_1:sch 2;
take C86;
thus L458: thesis by L457;
end;
uniqueness
proof
defpred S16[ set , (Element of ( C67 -sequents )) ] means $2 Rule3e $1;
let C87 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C88 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L459: (for B116 being (Element of ( bool ( C67 -sequents ) )) holds (for B117 being (Element of ( C67 -sequents )) holds ([ B116 , B117 ] in C87 iff S16[ B116 , B117 ])));
assume L460: (for B118 being (Element of ( bool ( C67 -sequents ) )) holds (for B119 being (Element of ( C67 -sequents )) holds ([ B118 , B119 ] in C88 iff S16[ B118 , B119 ])));
thus L461: thesis from RELSET_1:sch 4(L459 , L460);
end;
func P#4 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L462: (for B120 being (Element of ( bool ( C67 -sequents ) )) holds (for B121 being (Element of ( C67 -sequents )) holds ([ B120 , B121 ] in it iff B121 Rule4 B120)));
existence
proof
defpred S17[ set , (Element of ( C67 -sequents )) ] means $2 Rule4 $1;
consider C89 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L463: (for B122 being (Element of ( bool ( C67 -sequents ) )) holds (for B123 being (Element of ( C67 -sequents )) holds ([ B122 , B123 ] in C89 iff S17[ B122 , B123 ]))) from RELSET_1:sch 2;
take C89;
thus L464: thesis by L463;
end;
uniqueness
proof
defpred S18[ set , (Element of ( C67 -sequents )) ] means $2 Rule4 $1;
let C90 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C91 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L465: (for B124 being (Element of ( bool ( C67 -sequents ) )) holds (for B125 being (Element of ( C67 -sequents )) holds ([ B124 , B125 ] in C90 iff S18[ B124 , B125 ])));
assume L466: (for B126 being (Element of ( bool ( C67 -sequents ) )) holds (for B127 being (Element of ( C67 -sequents )) holds ([ B126 , B127 ] in C91 iff S18[ B126 , B127 ])));
thus L467: thesis from RELSET_1:sch 4(L465 , L466);
end;
func P#5 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L468: (for B128 being (Element of ( bool ( C67 -sequents ) )) holds (for B129 being (Element of ( C67 -sequents )) holds ([ B128 , B129 ] in it iff B129 Rule5 B128)));
existence
proof
defpred S19[ set , (Element of ( C67 -sequents )) ] means $2 Rule5 $1;
consider C92 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L469: (for B130 being (Element of ( bool ( C67 -sequents ) )) holds (for B131 being (Element of ( C67 -sequents )) holds ([ B130 , B131 ] in C92 iff S19[ B130 , B131 ]))) from RELSET_1:sch 2;
take C92;
thus L470: thesis by L469;
end;
uniqueness
proof
defpred S20[ set , (Element of ( C67 -sequents )) ] means $2 Rule5 $1;
let C93 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C94 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L471: (for B132 being (Element of ( bool ( C67 -sequents ) )) holds (for B133 being (Element of ( C67 -sequents )) holds ([ B132 , B133 ] in C93 iff S20[ B132 , B133 ])));
assume L472: (for B134 being (Element of ( bool ( C67 -sequents ) )) holds (for B135 being (Element of ( C67 -sequents )) holds ([ B134 , B135 ] in C94 iff S20[ B134 , B135 ])));
thus L473: thesis from RELSET_1:sch 4(L471 , L472);
end;
func P#6 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L474: (for B136 being (Element of ( bool ( C67 -sequents ) )) holds (for B137 being (Element of ( C67 -sequents )) holds ([ B136 , B137 ] in it iff B137 Rule6 B136)));
existence
proof
defpred S21[ set , (Element of ( C67 -sequents )) ] means $2 Rule6 $1;
consider C95 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L475: (for B138 being (Element of ( bool ( C67 -sequents ) )) holds (for B139 being (Element of ( C67 -sequents )) holds ([ B138 , B139 ] in C95 iff S21[ B138 , B139 ]))) from RELSET_1:sch 2;
take C95;
thus L476: thesis by L475;
end;
uniqueness
proof
defpred S22[ set , (Element of ( C67 -sequents )) ] means $2 Rule6 $1;
let C96 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C97 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L477: (for B140 being (Element of ( bool ( C67 -sequents ) )) holds (for B141 being (Element of ( C67 -sequents )) holds ([ B140 , B141 ] in C96 iff S22[ B140 , B141 ])));
assume L478: (for B142 being (Element of ( bool ( C67 -sequents ) )) holds (for B143 being (Element of ( C67 -sequents )) holds ([ B142 , B143 ] in C97 iff S22[ B142 , B143 ])));
thus L479: thesis from RELSET_1:sch 4(L477 , L478);
end;
func P#7 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L480: (for B144 being (Element of ( bool ( C67 -sequents ) )) holds (for B145 being (Element of ( C67 -sequents )) holds ([ B144 , B145 ] in it iff B145 Rule7 B144)));
existence
proof
defpred S23[ set , (Element of ( C67 -sequents )) ] means $2 Rule7 $1;
consider C98 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L481: (for B146 being (Element of ( bool ( C67 -sequents ) )) holds (for B147 being (Element of ( C67 -sequents )) holds ([ B146 , B147 ] in C98 iff S23[ B146 , B147 ]))) from RELSET_1:sch 2;
take C98;
thus L482: thesis by L481;
end;
uniqueness
proof
defpred S24[ set , (Element of ( C67 -sequents )) ] means $2 Rule7 $1;
let C99 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C100 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L483: (for B148 being (Element of ( bool ( C67 -sequents ) )) holds (for B149 being (Element of ( C67 -sequents )) holds ([ B148 , B149 ] in C99 iff S24[ B148 , B149 ])));
assume L484: (for B150 being (Element of ( bool ( C67 -sequents ) )) holds (for B151 being (Element of ( C67 -sequents )) holds ([ B150 , B151 ] in C100 iff S24[ B150 , B151 ])));
thus L485: thesis from RELSET_1:sch 4(L483 , L484);
end;
func P#8 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L486: (for B152 being (Element of ( bool ( C67 -sequents ) )) holds (for B153 being (Element of ( C67 -sequents )) holds ([ B152 , B153 ] in it iff B153 Rule8 B152)));
existence
proof
defpred S25[ set , (Element of ( C67 -sequents )) ] means $2 Rule8 $1;
consider C101 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L487: (for B154 being (Element of ( bool ( C67 -sequents ) )) holds (for B155 being (Element of ( C67 -sequents )) holds ([ B154 , B155 ] in C101 iff S25[ B154 , B155 ]))) from RELSET_1:sch 2;
take C101;
thus L488: thesis by L487;
end;
uniqueness
proof
defpred S26[ set , (Element of ( C67 -sequents )) ] means $2 Rule8 $1;
let C102 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C103 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L489: (for B156 being (Element of ( bool ( C67 -sequents ) )) holds (for B157 being (Element of ( C67 -sequents )) holds ([ B156 , B157 ] in C102 iff S26[ B156 , B157 ])));
assume L490: (for B158 being (Element of ( bool ( C67 -sequents ) )) holds (for B159 being (Element of ( C67 -sequents )) holds ([ B158 , B159 ] in C103 iff S26[ B158 , B159 ])));
thus L491: thesis from RELSET_1:sch 4(L489 , L490);
end;
func P#9 C67 -> (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) means 
:L492: (for B160 being (Element of ( bool ( C67 -sequents ) )) holds (for B161 being (Element of ( C67 -sequents )) holds ([ B160 , B161 ] in it iff B161 Rule9 B160)));
existence
proof
defpred S27[ set , (Element of ( C67 -sequents )) ] means $2 Rule9 $1;
consider C104 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents )) such that L493: (for B162 being (Element of ( bool ( C67 -sequents ) )) holds (for B163 being (Element of ( C67 -sequents )) holds ([ B162 , B163 ] in C104 iff S27[ B162 , B163 ]))) from RELSET_1:sch 2;
take C104;
thus L494: thesis by L493;
end;
uniqueness
proof
defpred S28[ set , (Element of ( C67 -sequents )) ] means $2 Rule9 $1;
let C105 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
let C106 being (Relation of ( bool ( C67 -sequents ) ) , ( C67 -sequents ));
assume L495: (for B164 being (Element of ( bool ( C67 -sequents ) )) holds (for B165 being (Element of ( C67 -sequents )) holds ([ B164 , B165 ] in C105 iff S28[ B164 , B165 ])));
assume L496: (for B166 being (Element of ( bool ( C67 -sequents ) )) holds (for B167 being (Element of ( C67 -sequents )) holds ([ B166 , B167 ] in C106 iff S28[ B166 , B167 ])));
thus L497: thesis from RELSET_1:sch 4(L495 , L496);
end;
end;
definition
let R18 being Language;
let C107 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents ));
func FuncRule C107 -> (Rule of R18) means 
:L499: (for B168 being set holds (B168 in ( bool ( R18 -sequents ) ) implies ( it . B168 ) = { B169 where B169 is (Element of ( R18 -sequents )) : [ B168 , B169 ] in C107 }));
existence
proof
deffunc H3(set) = { B170 where B170 is (Element of ( R18 -sequents )) : [ $1 , B170 ] in C107 };
L500: (for B171 being set holds H3(B171) in ( bool ( R18 -sequents ) ))
proof
let C108 being set;
L501:
now
let C109 being set;
assume L502: C109 in H3(C108);
consider C110 being (Element of ( R18 -sequents )) such that L503: (C110 = C109 & [ C108 , C110 ] in C107) by L502;
thus L504: C109 in ( R18 -sequents ) by L503;
end;
L505: H3(C108) c= ( R18 -sequents ) by L501 , TARSKI:def 3;
thus L506: thesis by L505;
end;
L507: (for B172 being set holds (B172 in ( bool ( R18 -sequents ) ) implies H3(B172) in ( bool ( R18 -sequents ) ))) by L500;
consider C111 being (Function of ( bool ( R18 -sequents ) ) , ( bool ( R18 -sequents ) )) such that L508: (for B173 being set holds (B173 in ( bool ( R18 -sequents ) ) implies ( C111 . B173 ) = H3(B173))) from FUNCT_2:sch 2(L507);
take C111;
thus L509: thesis by L508 , FUNCT_2:8;
end;
uniqueness
proof
set D175 = ( R18 -sequents );
let C112 , C113 being (Rule of R18);
deffunc H4(set) = { B174 where B174 is (Element of ( R18 -sequents )) : [ $1 , B174 ] in C107 };
assume L510: (for B175 being set holds (B175 in ( bool ( R18 -sequents ) ) implies ( C112 . B175 ) = H4(B175)));
assume L511: (for B176 being set holds (B176 in ( bool ( R18 -sequents ) ) implies ( C113 . B176 ) = H4(B176)));
L512: (for R13 being set holds (R13 in ( bool D175 ) implies ( C112 . R13 ) = ( C113 . R13 )))
proof
let R13 being set;
assume L513: R13 in ( bool D175 );
thus L514: ( C112 . R13 ) = H4(R13) by L513 , L510
.= ( C113 . R13 ) by L511 , L513;
end;
thus L515: thesis by L512 , FUNCT_2:12;
end;
end;
L517: (for R18 being Language holds (for R58 being (Subset of ( R18 -sequents )) holds (for R61 being (Element of ( R18 -sequents )) holds (for B177 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents )) holds ([ R58 , R61 ] in B177 implies R61 in ( ( FuncRule B177 ) . R58 ))))))
proof
let R18 being Language;
let R58 being (Subset of ( R18 -sequents ));
let R61 being (Element of ( R18 -sequents ));
let C114 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents ));
L518: ( ( FuncRule C114 ) . R58 ) = { B178 where B178 is (Element of ( R18 -sequents )) : [ R58 , B178 ] in C114 } by L499;
assume L519: [ R58 , R61 ] in C114;
thus L520: thesis by L519 , L518;
end;
L521: (for R18 being Language holds (for R64 being R18 -sequents-like set holds (for R67 being R18 -sequent-like set holds (for B179 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents )) holds ([ R64 , R67 ] in B179 implies R67 is (1 , R64 , { ( FuncRule B179 ) })-derivable)))))
proof
let R18 being Language;
let R64 being R18 -sequents-like set;
let R67 being R18 -sequent-like set;
set D176 = ( R18 -sequents );
let C115 being (Relation of ( bool D176 ) , D176);
set D177 = ( FuncRule C115 );
set D178 = ( OneStep { D177 } );
reconsider D179 = R64 as (Subset of D176) by L25;
reconsider D180 = R67 as (Element of D176) by L23;
L522: D177 = D178 by L188
.= ( (1 , { D177 }) -derivables ) by FUNCT_7:70;
assume L523: [ R64 , R67 ] in C115;
L524: D180 in ( ( (1 , { D177 }) -derivables ) . D179 ) by L523 , L522 , L517;
thus L525: thesis by L524 , L63;
end;
L526: (for R16 being set holds (for R18 being Language holds (for R64 being R18 -sequents-like set holds (for B180 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents )) holds (R16 in ( ( FuncRule B180 ) . R64 ) iff (R16 in ( R18 -sequents ) & [ R64 , R16 ] in B180))))))
proof
let R16 being set;
let R18 being Language;
let R64 being R18 -sequents-like set;
set D181 = ( R18 -sequents );
let C116 being (Relation of ( bool D181 ) , D181);
reconsider D182 = ( FuncRule C116 ) as (Function of ( bool D181 ) , ( bool D181 ));
reconsider D183 = R64 as (Element of ( bool D181 )) by L25;
set D184 = { B181 where B181 is (Element of ( R18 -sequents )) : [ D183 , B181 ] in C116 };
L527: ( D182 . D183 ) = D184 by L499;
L528: ( D182 . D183 ) c= D181;
thus L529: (R16 in ( ( FuncRule C116 ) . R64 ) implies (R16 in D181 & [ R64 , R16 ] in C116))
proof
assume L530: R16 in ( ( FuncRule C116 ) . R64 );
thus L531: R16 in D181 by L528 , L530;
consider C117 being (Element of D181) such that L532: (R16 = C117 & [ D183 , C117 ] in C116) by L530 , L527;
thus L533: thesis by L532;
end;

assume L534: (R16 in D181 & [ R64 , R16 ] in C116);
reconsider D185 = R16 as (Element of D181) by L534;
L535: D185 in ( D182 . D183 ) by L517 , L534;
thus L536: thesis by L535;
end;
L537: (for R10 being set holds (for R16 being set holds (for R18 being Language holds (for B182 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents )) holds (R16 in ( ( FuncRule B182 ) . R10 ) iff (R16 in ( R18 -sequents ) & [ R10 , R16 ] in B182))))))
proof
let R10 being set;
let R16 being set;
let R18 being Language;
set D186 = ( R18 -sequents );
let C118 being (Relation of ( bool D186 ) , D186);
reconsider D187 = ( FuncRule C118 ) as (Function of ( bool D186 ) , ( bool D186 ));
per cases ;
suppose L538: (not R10 in ( bool D186 ));

L539: (not R10 in ( dom D187 )) by L538;
thus L540: thesis by L539 , L538 , FUNCT_1:def 2 , ZFMISC_1:87;
end;
suppose L541: R10 in ( bool D186 );

reconsider D188 = R10 as (Element of ( bool D186 )) by L541;
set D189 = D188;
L542: (R16 in ( ( FuncRule C118 ) . D189 ) iff (R16 in ( R18 -sequents ) & [ D189 , R16 ] in C118)) by L526;
thus L543: thesis by L542;
end;
end;
definition
let R18 being Language;
func R#0 R18 -> (Rule of R18) equals 
( FuncRule ( P#0 R18 ) );
coherence;
func R#1 R18 -> (Rule of R18) equals 
( FuncRule ( P#1 R18 ) );
coherence;
func R#2 R18 -> (Rule of R18) equals 
( FuncRule ( P#2 R18 ) );
coherence;
func R#3a R18 -> (Rule of R18) equals 
( FuncRule ( P#3a R18 ) );
coherence;
func R#3b R18 -> (Rule of R18) equals 
( FuncRule ( P#3b R18 ) );
coherence;
func R#3d R18 -> (Rule of R18) equals 
( FuncRule ( P#3d R18 ) );
coherence;
func R#3e R18 -> (Rule of R18) equals 
( FuncRule ( P#3e R18 ) );
coherence;
func R#4 R18 -> (Rule of R18) equals 
( FuncRule ( P#4 R18 ) );
coherence;
func R#5 R18 -> (Rule of R18) equals 
( FuncRule ( P#5 R18 ) );
coherence;
func R#6 R18 -> (Rule of R18) equals 
( FuncRule ( P#6 R18 ) );
coherence;
func R#7 R18 -> (Rule of R18) equals 
( FuncRule ( P#7 R18 ) );
coherence;
func R#8 R18 -> (Rule of R18) equals 
( FuncRule ( P#8 R18 ) );
coherence;
func R#9 R18 -> (Rule of R18) equals 
( FuncRule ( P#9 R18 ) );
coherence;
end;
registration
let R18 being Language;
let C119 being  termal (string of R18);
cluster { [ ( {} ) , ( ( <* ( TheEqSymbOf R18 ) *> ^ C119 ) ^ C119 ) ] } -> { ( R#2 R18 ) } -derivable for set;
coherence
proof
set D190 = ( TheEqSymbOf R18 );
set D191 = ( AllSymbolsOf R18 );
set D192 = ( R18 -termsOfMaxDepth );
set D193 = ( R18 -multiCat );
reconsider D194 = ( ( <* D190 *> ^ C119 ) ^ C119 ) as  wff (string of R18) by L5;
reconsider D195 = ( {} ) as (Element of ( bool ( R18 -sequents ) )) by XBOOLE_1:2;
reconsider D196 = [ ( {} ) , D194 ] as (Element of ( R18 -sequents ));
L546: (( D196 `1 ) is  empty & ( D196 `2 ) = ( ( <* D190 *> ^ C119 ) ^ C119 )) by MCART_1:7;
L547: D196 Rule2 ( {} ) by L546 , L408;
L548: [ D195 , D196 ] in ( P#2 R18 ) by L547 , L432;
L549: D196 in ( ( R#2 R18 ) . D195 ) by L548 , L517;
L550: { D196 } c= ( ( R#2 R18 ) . D195 ) by L549 , ZFMISC_1:31;
L551: { D196 } is (( {} ) , { ( R#2 R18 ) })-derivable by L550 , L340;
thus L552: thesis by L551;
end;
end;
registration
let R18 being Language;
cluster ( R#2 R18 ) ->  isotone for (Rule of R18);
coherence
proof
L554:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D197 = R59;
set D198 = R60;
assume L555: D197 c= D198;
set D199 = ( R#2 R18 );
set D200 = ( R18 -sequents );
L556:
now
let R13 being set;
assume L557: R13 in ( D199 . D197 );
L558: (R13 in D200 & [ D197 , R13 ] in ( P#2 R18 )) by L557 , L537;
reconsider D201 = R13 as (Element of D200) by L557;
L559: D201 Rule2 D197 by L432 , L558;
L560: (( D201 `1 ) is  empty & (ex B183 being  termal (string of R18) st ( D201 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ B183 ) ^ B183 ))) by L559 , L408;
L561: D201 Rule2 D198 by L560 , L408;
L562: [ D198 , D201 ] in ( P#2 R18 ) by L561 , L432;
thus L563: R13 in ( D199 . D198 ) by L562 , L517;
end;
thus L564: ( D199 . D197 ) c= ( D199 . D198 ) by L556 , TARSKI:def 3;
end;
thus L565: thesis by L554 , L72;
end;
end;
L567: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ({ ( R#2 R18 ) } c= R53 implies ( (R10 , R53) -termEq ) is  total))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
assume L568: { ( R#2 R18 ) } c= R53;
set D202 = ( AllTermsOf R18 );
set D203 = ( TheEqSymbOf R18 );
set D204 = R10;
set D205 = ( (D204 , R53) -termEq );
L569:
now
let R13 being set;
assume L570: R13 in D202;
reconsider D206 = R13 as  termal (string of R18) by L570;
set D207 = ( ( <* D203 *> ^ D206 ) ^ D206 );
set D208 = [ ( {} ) , D207 ];
L571: { D208 } is (( {} ) , R53)-derivable by L568 , L335;
L572: D207 is (( ( {} ) \ ( D204 \ ( {} ) ) ) , R53)-provable by L571 , L100;
L573: D207 is (( D204 \/ ( {} ) ) , R53)-provable by L572;
L574: [ D206 , D206 ] in ( (D204 , R53) -termEq ) by L573;
thus L575: R13 in ( dom D205 ) by L574 , XTUPLE_0:def 12;
end;
L576: D202 c= ( dom D205 ) by L569 , TARSKI:def 3;
L577: D202 = ( dom D205 ) by L576 , XBOOLE_0:def 10;
thus L578: D205 is  total by L577 , PARTFUN1:def 2;
end;
registration
let R18 being Language;
cluster ( R#3b R18 ) ->  isotone for (Rule of R18);
coherence
proof
L579:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D209 = R59;
set D210 = R60;
assume L580: D209 c= D210;
set D211 = ( R#3b R18 );
set D212 = ( R18 -sequents );
L581:
now
let R13 being set;
assume L582: R13 in ( D211 . D209 );
reconsider D213 = R13 as (Element of D212) by L582;
L583: [ D209 , D213 ] in ( P#3b R18 ) by L582 , L537;
L584: D213 Rule3b D209 by L583 , L444;
L585: (ex B184 , B185 being  termal (string of R18) st (( D213 `1 ) = { ( ( <* ( TheEqSymbOf R18 ) *> ^ B184 ) ^ B185 ) } & ( D213 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ B185 ) ^ B184 ))) by L584 , L410;
L586: D213 Rule3b D210 by L585 , L410;
L587: [ D210 , D213 ] in ( P#3b R18 ) by L586 , L444;
thus L588: R13 in ( D211 . D210 ) by L587 , L517;
end;
thus L589: ( D211 . D209 ) c= ( D211 . D210 ) by L581 , TARSKI:def 3;
end;
thus L590: thesis by L579 , L72;
end;
end;
L592: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (({ ( R#3b R18 ) } c= R53 & R10 is R53 -expanded) implies ( (R10 , R53) -termEq ) is  symmetric))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D214 = ( AllTermsOf R18 );
set D215 = ( TheEqSymbOf R18 );
set D216 = ( R18 -sequents );
set D217 = ( AllFormulasOf R18 );
set D218 = R10;
set D219 = ( (R10 , R53) -termEq );
assume L593: { ( R#3b R18 ) } c= R53;
assume L594: D218 is R53 -expanded;
L595: ( field D219 ) c= ( D214 \/ D214 ) by RELSET_1:8;
L596:
now
let R13 being set;
let R16 being set;
assume L597: (R13 in ( field D219 ) & R16 in ( field D219 ));
reconsider D220 = R13 , D221 = R16 as (Element of D214) by L597 , L595;
reconsider D222 = D220 , D223 = D221 as  termal (string of R18);
reconsider D224 = ( ( <* D215 *> ^ D222 ) ^ D223 ) as  wff (string of R18) by L5;
reconsider D225 = ( ( <* D215 *> ^ D223 ) ^ D222 ) as  wff (string of R18) by L5;
reconsider D226 = [ { D224 } , D225 ] as (Element of ( R18 -sequents )) by L23;
L598: (( D226 `1 ) = { D224 } & ( D226 `2 ) = D225) by MCART_1:7;
reconsider D227 = ( {} ) as (Element of ( bool D216 )) by XBOOLE_1:2;
L599: D226 Rule3b ( {} ) by L598 , L410;
L600: [ D227 , D226 ] in ( P#3b R18 ) by L599 , L444;
L601: D226 in ( ( R#3b R18 ) . D227 ) by L600 , L517;
L602: { D226 } c= ( ( R#3b R18 ) . D227 ) by L601 , ZFMISC_1:31;
L603: { D226 } is (( {} ) , { ( R#3b R18 ) })-derivable by L602 , L340;
L604: { D226 } is (( {} ) , R53)-derivable by L603 , L593 , L335;
L605: D225 is ({ D224 } , R53)-provable by L604 , L100;
assume L606: [ R13 , R16 ] in ( (D218 , R53) -termEq );
consider C120 , C121 being  termal (string of R18) such that L607: ([ R13 , R16 ] = [ C120 , C121 ] & ( ( <* D215 *> ^ C120 ) ^ C121 ) is (D218 , R53)-provable) by L606;
L608: (D222 = C120 & D223 = C121) by L607 , XTUPLE_0:1;
L609: { D224 } c= D218 by L608 , L594 , L116 , L607;
thus L610: [ R16 , R13 ] in ( (D218 , R53) -termEq ) by L609 , L605;
end;
L611: D219 is_symmetric_in ( field D219 ) by L596 , RELAT_2:def 3;
thus L612: thesis by L611 , RELAT_2:def 11;
end;
registration
let R18 being Language;
let C122 , C123 , C124 being  termal (string of R18);
let C125 being  finite (Subset of ( AllFormulasOf R18 ));
cluster [ ( C125 \/ { ( ( <* ( TheEqSymbOf R18 ) *> ^ C123 ) ^ C124 ) } ) , ( ( <* ( TheEqSymbOf R18 ) *> ^ C122 ) ^ C124 ) ] -> (1 , { [ C125 , ( ( <* ( TheEqSymbOf R18 ) *> ^ C122 ) ^ C123 ) ] } , { ( R#3a R18 ) })-derivable for set;
coherence
proof
set D228 = ( TheEqSymbOf R18 );
set D229 = ( AllFormulasOf R18 );
reconsider D230 = ( ( <* D228 *> ^ C123 ) ^ C124 ) , D231 = ( ( <* D228 *> ^ C122 ) ^ C123 ) , D232 = ( ( <* D228 *> ^ C122 ) ^ C124 ) as  0wff (string of R18) by L5;
L613: D230 in D229;
reconsider D233 = { D230 } as  finite (Subset of D229) by L613 , ZFMISC_1:31;
reconsider D234 = ( C125 \/ D233 ) as  finite (Subset of D229);
reconsider D235 = [ D234 , D232 ] , D236 = [ C125 , D231 ] as (Element of ( R18 -sequents )) by L23;
reconsider D237 = { D236 } as (Subset of ( R18 -sequents ));
L614: D236 in D237 by TARSKI:def 1;
L615: ( D235 `1 ) = ( C125 \/ { D230 } ) by MCART_1:7
.= ( ( D236 `1 ) \/ { D230 } ) by MCART_1:7;
L616: (( D236 `2 ) = D231 & ( D235 `2 ) = D232) by MCART_1:7;
L617: D235 Rule3a D237 by L614 , L615 , L616 , L409;
L618: [ D237 , D235 ] in ( P#3a R18 ) by L617 , L438;
thus L619: thesis by L618 , L521;
end;
end;
registration
let R18 being Language;
let C126 , C127 , C128 being  termal (string of R18);
let C129 being  wff (string of R18);
cluster [ { C129 , ( ( <* ( TheEqSymbOf R18 ) *> ^ C127 ) ^ C128 ) } , ( ( <* ( TheEqSymbOf R18 ) *> ^ C126 ) ^ C128 ) ] -> (1 , { [ { C129 } , ( ( <* ( TheEqSymbOf R18 ) *> ^ C126 ) ^ C127 ) ] } , { ( R#3a R18 ) })-derivable for set;
coherence
proof
set D238 = ( AllFormulasOf R18 );
set D239 = ( TheEqSymbOf R18 );
set D240 = { C129 , ( ( <* D239 *> ^ C127 ) ^ C128 ) };
set D241 = [ { C129 , ( ( <* D239 *> ^ C127 ) ^ C128 ) } , ( ( <* D239 *> ^ C126 ) ^ C128 ) ];
reconsider D242 = C129 as (Element of D238) by FOMODEL2:16;
reconsider D243 = { D242 } as  finite (Subset of D238);
L621: [ ( D243 \/ { ( ( <* D239 *> ^ C127 ) ^ C128 ) } ) , ( ( <* D239 *> ^ C126 ) ^ C128 ) ] is (1 , { [ D243 , ( ( <* D239 *> ^ C126 ) ^ C127 ) ] } , { ( R#3a R18 ) })-derivable;
thus L622: thesis by L621 , ENUMSET1:1;
end;
end;
registration
let R18 being Language;
let C130 being  wff (string of R18);
let C131 being  finite (Subset of ( AllFormulasOf R18 ));
cluster [ ( C131 \/ { C130 } ) , C130 ] -> (1 , ( {} ) , { ( R#0 R18 ) })-derivable for set;
coherence
proof
set D244 = ( R18 -sequents );
reconsider D245 = [ ( C131 \/ { C130 } ) , C130 ] as (Element of D244) by L23;
reconsider D246 = ( {} ) as (Subset of D244) by XBOOLE_1:2;
L624: (C130 in { C130 } & { C130 } c= ( C131 \/ { C130 } )) by TARSKI:def 1 , XBOOLE_1:7;
L625: (( D245 `2 ) = C130 & ( D245 `1 ) = ( C131 \/ { C130 } )) by MCART_1:7;
L626: D245 Rule0 D246 by L625 , L406 , L624;
L627: [ D246 , D245 ] in ( P#0 R18 ) by L626 , L420;
thus L628: thesis by L627 , L521;
end;
end;
registration
let R18 being Language;
let C132 , C133 being  wff (string of R18);
cluster [ { C132 , C133 } , C132 ] -> (1 , ( {} ) , { ( R#0 R18 ) })-derivable for set;
coherence
proof
set D247 = ( AllFormulasOf R18 );
reconsider D248 = C132 , D249 = C133 as (Element of D247) by FOMODEL2:16;
reconsider D250 = { D249 } as  finite (Subset of D247);
L630: [ ( D250 \/ { C132 } ) , C132 ] is (1 , ( {} ) , { ( R#0 R18 ) })-derivable;
thus L631: thesis by L630 , ENUMSET1:1;
end;
end;
registration
let R18 being Language;
let R31 being  wff (string of R18);
cluster [ { R31 } , R31 ] -> (1 , ( {} ) , { ( R#0 R18 ) })-derivable for set;
coherence
proof
set D251 = ( AllFormulasOf R18 );
reconsider D252 = ( {} ) as  finite (Subset of D251) by XBOOLE_1:2;
L633: [ ( D252 \/ { R31 } ) , R31 ] is (1 , ( {} ) , { ( R#0 R18 ) })-derivable;
thus L634: thesis by L633;
end;
end;
registration
let R18 being Language;
let C134 being  wff (string of R18);
cluster { [ { C134 } , C134 ] } -> (( {} ) , { ( R#0 R18 ) })-derivable for set;
coherence by L260;
end;
registration
let R18 being Language;
cluster ( R#0 R18 ) ->  isotone for (Rule of R18);
coherence
proof
L637:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D253 = R59;
set D254 = R60;
assume L638: D253 c= D254;
set D255 = ( R#0 R18 );
set D256 = ( R18 -sequents );
L639:
now
let R13 being set;
assume L640: R13 in ( D255 . D253 );
reconsider D257 = R13 as (Element of D256) by L640;
L641: [ D253 , D257 ] in ( P#0 R18 ) by L640 , L537;
L642: D257 Rule0 D253 by L641 , L420;
L643: ( D257 `2 ) in ( D257 `1 ) by L642 , L406;
L644: D257 Rule0 D254 by L643 , L406;
L645: [ D254 , D257 ] in ( P#0 R18 ) by L644 , L420;
thus L646: R13 in ( D255 . D254 ) by L645 , L517;
end;
thus L647: ( D255 . D253 ) c= ( D255 . D254 ) by L639 , TARSKI:def 3;
end;
thus L648: thesis by L637 , L72;
end;
cluster ( R#3a R18 ) ->  isotone for (Rule of R18);
coherence
proof
L649:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D258 = R59;
set D259 = R60;
assume L650: D258 c= D259;
set D260 = ( R#3a R18 );
set D261 = ( R18 -sequents );
L651:
now
let R13 being set;
assume L652: R13 in ( D260 . D258 );
reconsider D262 = R13 as (Element of D261) by L652;
L653: [ D258 , D262 ] in ( P#3a R18 ) by L652 , L537;
L654: D262 Rule3a D258 by L653 , L438;
consider C135 , C136 , C137 being  termal (string of R18), C138 being set such that L655: (C138 in D258 & ( D262 `1 ) = ( ( C138 `1 ) \/ { ( ( <* ( TheEqSymbOf R18 ) *> ^ C136 ) ^ C137 ) } ) & ( C138 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ C135 ) ^ C136 ) & ( D262 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ C135 ) ^ C137 )) by L654 , L409;
L656: D262 Rule3a D259 by L409 , L655 , L650;
L657: [ D259 , D262 ] in ( P#3a R18 ) by L656 , L438;
thus L658: R13 in ( D260 . D259 ) by L657 , L517;
end;
thus L659: ( D260 . D258 ) c= ( D260 . D259 ) by L651 , TARSKI:def 3;
end;
thus L660: thesis by L649 , L72;
end;
cluster ( R#3d R18 ) ->  isotone for (Rule of R18);
coherence
proof
L661:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D263 = R59;
set D264 = R60;
assume L662: D263 c= D264;
set D265 = ( R#3d R18 );
set D266 = ( R18 -sequents );
L663:
now
let R13 being set;
assume L664: R13 in ( D265 . D263 );
reconsider D267 = R13 as (Element of D266) by L664;
L665: [ D263 , D267 ] in ( P#3d R18 ) by L664 , L537;
L666: D267 Rule3d D263 by L665 , L450;
L667: (ex B186 being  low-compounding (Element of R18) st (ex B187 , B188 being ( abs ( ar B186 ) ) -element (Element of ( ( AllTermsOf R18 ) * )) st (B186 is  operational & ( D267 `1 ) = { ( ( <* ( TheEqSymbOf R18 ) *> ^ ( B190 . B189 ) ) ^ ( B191 . B189 ) ) where B189 is (Element of ( Seg ( abs ( ar B186 ) ) )) , B190 , B191 is (Function of ( Seg ( abs ( ar B186 ) ) ) , ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } )) : (B190 = B187 & B191 = B188) } & ( D267 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ ( B186 -compound B187 ) ) ^ ( B186 -compound B188 ) )))) by L666 , L411;
L668: D267 Rule3d D264 by L667 , L411;
L669: [ D264 , D267 ] in ( P#3d R18 ) by L668 , L450;
thus L670: R13 in ( D265 . D264 ) by L669 , L517;
end;
thus L671: ( D265 . D263 ) c= ( D265 . D264 ) by L663 , TARSKI:def 3;
end;
thus L672: thesis by L661 , L72;
end;
cluster ( R#3e R18 ) ->  isotone for (Rule of R18);
coherence
proof
L673:
now
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D268 = R59;
set D269 = R60;
assume L674: D268 c= D269;
set D270 = ( R#3e R18 );
set D271 = ( R18 -sequents );
L675:
now
let R13 being set;
assume L676: R13 in ( D270 . D268 );
reconsider D272 = R13 as (Element of D271) by L676;
L677: [ D268 , D272 ] in ( P#3e R18 ) by L676 , L537;
L678: D272 Rule3e D268 by L677 , L456;
L679: (ex B192 being  relational (Element of R18) st (ex B193 , B194 being ( abs ( ar B192 ) ) -element (Element of ( ( AllTermsOf R18 ) * )) st (( D272 `1 ) = ( { ( B192 -compound B193 ) } \/ { ( ( <* ( TheEqSymbOf R18 ) *> ^ ( B196 . B195 ) ) ^ ( B197 . B195 ) ) where B195 is (Element of ( Seg ( abs ( ar B192 ) ) )) , B196 , B197 is (Function of ( Seg ( abs ( ar B192 ) ) ) , ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } )) : (B196 = B193 & B197 = B194) } ) & ( D272 `2 ) = ( B192 -compound B194 )))) by L678 , L412;
L680: D272 Rule3e D269 by L679 , L412;
L681: [ D269 , D272 ] in ( P#3e R18 ) by L680 , L456;
thus L682: R13 in ( D270 . D269 ) by L681 , L517;
end;
thus L683: ( D270 . D268 ) c= ( D270 . D269 ) by L675 , TARSKI:def 3;
end;
thus L684: thesis by L673 , L72;
end;
let R72 being  isotone (RuleSet of R18);
let R73 being  isotone (RuleSet of R18);
cluster ( R72 \/ R73 ) ->  isotone for (RuleSet of R18);
coherence
proof
set D273 = ( R72 \/ R73 );
L685: (R72 c= D273 & R73 c= D273) by XBOOLE_1:7;
L686: (for R59 being (Subset of ( R18 -sequents )) holds (for R60 being (Subset of ( R18 -sequents )) holds (for R22 being Function holds ((R59 c= R60 & R22 in D273) implies (ex R23 being Function st (R23 in D273 & ( R22 . R59 ) c= ( R23 . R60 )))))))
proof
let R59 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
let R22 being Function;
set D274 = R59;
set D275 = R60;
assume L687: (D274 c= D275 & R22 in D273);
per cases ;
suppose L688: R22 in R72;

consider R23 being Function such that L689: (R23 in R72 & ( R22 . D274 ) c= ( R23 . D275 )) by L688 , L687 , L85;
take R23;
thus L690: (R23 in D273 & ( R22 . D274 ) c= ( R23 . D275 )) by L689 , L685;
end;
suppose L691: (not R22 in R72);

L692: R22 in R73 by L691 , L687 , XBOOLE_0:def 3;
consider R23 being Function such that L693: (R23 in R73 & ( R22 . D274 ) c= ( R23 . D275 )) by L692 , L687 , L85;
take R23;
thus L694: (R23 in D273 & ( R22 . D274 ) c= ( R23 . D275 )) by L693 , L685;
end;
end;
thus L696: thesis by L686 , L85;
end;
end;
L698: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ((( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ) c= R53 & R10 is R53 -expanded) implies ( (R10 , R53) -termEq ) is  transitive))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
set D276 = ( AllTermsOf R18 );
set D277 = ( TheEqSymbOf R18 );
set D278 = ( R18 -sequents );
set D279 = ( AllFormulasOf R18 );
set D280 = R10;
set D281 = ( (R10 , R53) -termEq );
reconsider D282 = ( {} ) as (Element of ( bool D278 )) by XBOOLE_1:2;
assume L699: ( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ) c= R53;
assume L700: D280 is R53 -expanded;
L701: ( field D281 ) c= ( D276 \/ D276 ) by RELSET_1:8;
L702:
now
let R13 being set;
let R16 being set;
let R17 being set;
assume L703: (R13 in ( field D281 ) & R16 in ( field D281 ) & R17 in ( field D281 ));
reconsider D283 = R13 , D284 = R16 , D285 = R17 as (Element of D276) by L703 , L701;
reconsider D286 = D283 , D287 = D284 , D288 = D285 as  termal (string of R18);
reconsider D289 = ( ( <* D277 *> ^ D286 ) ^ D287 ) as  wff (string of R18) by L5;
reconsider D290 = ( ( <* D277 *> ^ D287 ) ^ D288 ) as  wff (string of R18) by L5;
reconsider D291 = ( ( <* D277 *> ^ D286 ) ^ D288 ) as  wff (string of R18) by L5;
L704: [ { D289 , ( ( <* D277 *> ^ D287 ) ^ D288 ) } , ( ( <* D277 *> ^ D286 ) ^ D288 ) ] is (1 , { [ { D289 } , ( ( <* D277 *> ^ D286 ) ^ D287 ) ] } , { ( R#3a R18 ) })-derivable;
L705: [ { D289 , D290 } , D291 ] is (1 , { [ { D289 } , D289 ] } , { ( R#3a R18 ) })-derivable by L704;
L706: [ { D289 , D290 } , D291 ] is (( 1 + 1 ) , ( {} ) , ( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ))-derivable by L705 , L363;
L707: { [ { D289 , D290 } , D291 ] } is (( {} ) , ( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ))-derivable by L706 , L260;
L708: { [ { D289 , D290 } , D291 ] } is (( {} ) , R53)-derivable by L707 , L335 , L699;
L709: ({ D289 , D290 } = ( { D289 } \/ { D290 } ) & D291 is ({ D289 , D290 } , R53)-provable) by L708 , L100 , ENUMSET1:1;
assume L710: ([ R13 , R16 ] in D281 & [ R16 , R17 ] in D281);
L711: (D289 is (D280 , R53)-provable & D290 is (D280 , R53)-provable) by L710 , L376;
reconsider D292 = { D289 } , D293 = { D290 } as (Subset of D280) by L711 , L700 , L116;
reconsider D294 = ( D292 \/ D293 ) as (Subset of D280);
L712: D291 is (D294 , R53)-provable by L709;
thus L713: [ R13 , R17 ] in ( (D280 , R53) -termEq ) by L712;
end;
L714: D281 is_transitive_in ( field D281 ) by L702 , RELAT_2:def 8;
thus L715: thesis by L714 , RELAT_2:def 16;
end;
L716: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (({ ( R#0 R18 ) , ( R#3a R18 ) } c= R53 & { ( R#2 R18 ) , ( R#3b R18 ) } c= R53 & R10 is R53 -expanded) implies ( (R10 , R53) -termEq ) is (Equivalence_Relation of ( AllTermsOf R18 ))))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
L717: ({ ( R#2 R18 ) } c= { ( R#2 R18 ) , ( R#3b R18 ) } & { ( R#3b R18 ) } c= { ( R#2 R18 ) , ( R#3b R18 ) }) by ZFMISC_1:7;
assume L718: { ( R#0 R18 ) , ( R#3a R18 ) } c= R53;
L719: ( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ) c= R53 by L718 , ENUMSET1:1;
assume L720: { ( R#2 R18 ) , ( R#3b R18 ) } c= R53;
L721: (( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) }) by L720 , L717 , XBOOLE_1:1 , XBOOLE_1:28;
assume L722: R10 is R53 -expanded;
set D295 = ( (R10 , R53) -termEq );
thus L723: thesis by L567 , L698 , L719 , L722 , L592 , L721;
end;
registration
let R18 being Language;
let C139 , C140 being  termal (string of R18);
cluster ( ( <* ( TheEqSymbOf R18 ) *> ^ C139 ) ^ C140 ) -> ( 0 ) -wff for (string of R18);
coherence by L5;
end;
definition
let R18 being Language;
let C141 being non  zero Nat;
let C142 , C143 being C141 -element (Element of ( ( AllTermsOf R18 ) * ));
func PairWiseEq (C142 , C143) equals 
{ ( ( <* ( TheEqSymbOf R18 ) *> ^ ( B199 . B198 ) ) ^ ( B200 . B198 ) ) where B198 is (Element of ( Seg C141 )) , B199 , B200 is (Function of ( Seg C141 ) , ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } )) : (B199 = C142 & B200 = C143) };
coherence;
end;
definition
let R18 being Language;
let C144 being non  zero Nat;
let C145 , C146 being C144 -element (Element of ( ( AllTermsOf R18 ) * ));
redefine func PairWiseEq (C145 , C146) -> (Subset of ( AllFormulasOf R18 ));

coherence
proof
set D296 = ( PairWiseEq (C145 , C146) );
set D297 = ( AllSymbolsOf R18 );
set D298 = ( TheEqSymbOf R18 );
set D299 = ( AllTermsOf R18 );
set D300 = ( AllFormulasOf R18 );
L726:
now
let R13 being set;
assume L727: R13 in D296;
consider C147 being (Element of ( Seg C144 )), C148 , C149 being (Function of ( Seg C144 ) , ( ( D297 * ) \ { ( {} ) } )) such that L728: (R13 = ( ( <* D298 *> ^ ( C148 . C147 ) ) ^ ( C149 . C147 ) ) & C148 = C145 & C149 = C146) by L727;
L729: ( C144 -tuples_on D299 ) = ( Funcs (( Seg C144 ) , D299) ) by FOMODEL0:11;
L730: (C145 is (Element of ( Funcs (( Seg C144 ) , D299) )) & C146 is (Element of ( Funcs (( Seg C144 ) , D299) ))) by L729 , FOMODEL0:16;
reconsider D301 = C145 , D302 = C146 as (Function of ( Seg C144 ) , D299) by L730;
L731: (( D301 . C147 ) is (Element of D299) & ( D302 . C147 ) is (Element of D299));
reconsider D303 = ( D301 . C147 ) , D304 = ( D302 . C147 ) as (string of R18) by L731;
reconsider D305 = ( ( <* D298 *> ^ D303 ) ^ D304 ) as ( 0 ) -wff (string of R18);
L732: D305 in D300;
thus L733: R13 in D300 by L732 , L728;
end;
thus L734: thesis by L726 , TARSKI:def 3;
end;
end;
registration
let R18 being Language;
let C150 being non  zero Nat;
let C151 , C152 being C150 -element (Element of ( ( AllTermsOf R18 ) * ));
cluster ( PairWiseEq (C151 , C152) ) ->  finite;
coherence
proof
set D306 = ( AllTermsOf R18 );
set D307 = ( TheEqSymbOf R18 );
set D308 = ( AllSymbolsOf R18 );
L736: (C151 in ( C150 -tuples_on D306 ) & C152 in ( C150 -tuples_on D306 )) by FOMODEL0:16;
L737: (C151 is (Element of ( Funcs (( Seg C150 ) , D306) )) & C152 is (Element of ( Funcs (( Seg C150 ) , D306) ))) by L736 , FOMODEL0:11;
reconsider D309 = C151 , D310 = C152 as (Function of ( Seg C150 ) , D306) by L737;
deffunc H5((Element of ( Seg C150 ))) = ( ( <* D307 *> ^ ( D309 . $1 ) ) ^ ( D310 . $1 ) );
set D311 = { H5(B201) where B201 is (Element of ( Seg C150 )) : B201 in ( Seg C150 ) };
L738: ( Seg C150 ) is  finite;
L739: D311 is  finite from FRAENKEL:sch 21(L738);
reconsider D312 = D311 as  finite set by L739;
L740:
now
let R13 being set;
assume L741: R13 in ( PairWiseEq (C151 , C152) );
consider C153 being (Element of ( Seg C150 )), C154 , C155 being (Function of ( Seg C150 ) , ( ( D308 * ) \ { ( {} ) } )) such that L742: (R13 = ( ( <* D307 *> ^ ( C154 . C153 ) ) ^ ( C155 . C153 ) ) & C154 = C151 & C155 = C152) by L741;
thus L743: R13 in D311 by L742;
end;
reconsider D313 = ( PairWiseEq (C151 , C152) ) as (Subset of D312) by L740 , TARSKI:def 3;
L744: D313 is  finite;
thus L745: thesis by L744;
end;
end;
L747: (for R18 being Language holds (for B202 being  low-compounding (Element of R18) holds (for B203 , B204 being ( abs ( ar B202 ) ) -element (Element of ( ( AllTermsOf R18 ) * )) holds (B202 is  termal implies { [ ( PairWiseEq (B203 , B204) ) , ( ( <* ( TheEqSymbOf R18 ) *> ^ ( B202 -compound B203 ) ) ^ ( B202 -compound B204 ) ) ] } is (( {} ) , { ( R#3d R18 ) })-derivable))))
proof
let R18 being Language;
let C156 being  low-compounding (Element of R18);
set D314 = ( abs ( ar C156 ) );
set D315 = ( AllTermsOf R18 );
set D316 = ( TheEqSymbOf R18 );
let C157 , C158 being D314 -element (Element of ( D315 * ));
assume L748: C156 is  termal;
reconsider D317 = C156 as  termal (Element of R18) by L748;
reconsider D318 = ( D317 -compound C157 ) , D319 = ( D317 -compound C158 ) as  termal (string of R18);
reconsider D320 = ( ( <* D316 *> ^ D318 ) ^ D319 ) as  wff (string of R18);
reconsider D321 = [ ( PairWiseEq (C157 , C158) ) , D320 ] as (Element of ( R18 -sequents )) by L23;
reconsider D322 = ( {} ) as (Subset of ( R18 -sequents )) by XBOOLE_1:2;
L749: D317 is  termal;
L750: (C156 is  operational & ( D321 `1 ) = ( PairWiseEq (C157 , C158) ) & ( D321 `2 ) = ( ( <* D316 *> ^ ( C156 -compound C157 ) ) ^ ( C156 -compound C158 ) )) by L749 , MCART_1:7;
L751: D321 Rule3d D322 by L750 , L411;
L752: [ D322 , D321 ] in ( P#3d R18 ) by L751 , L450;
L753: D321 in ( ( R#3d R18 ) . D322 ) by L752 , L517;
L754: { D321 } c= ( ( R#3d R18 ) . D322 ) by L753 , ZFMISC_1:31;
thus L755: thesis by L754 , L340;
end;
L756: (for R18 being Language holds (for B205 being  relational (Element of R18) holds (for B206 , B207 being ( abs ( ar B205 ) ) -element (Element of ( ( AllTermsOf R18 ) * )) holds { [ ( ( PairWiseEq (B206 , B207) ) \/ { ( B205 -compound B206 ) } ) , ( B205 -compound B207 ) ] } is (( {} ) , { ( R#3e R18 ) })-derivable)))
proof
let R18 being Language;
let C159 being  relational (Element of R18);
set D323 = ( abs ( ar C159 ) );
set D324 = ( AllTermsOf R18 );
set D325 = ( TheEqSymbOf R18 );
set D326 = ( AllFormulasOf R18 );
let C160 , C161 being D323 -element (Element of ( D324 * ));
reconsider D327 = ( C159 -compound C160 ) , D328 = ( C159 -compound C161 ) as ( 0 ) -wff (string of R18);
L757: D327 in D326;
reconsider D329 = D327 as (Element of D326) by L757;
reconsider D330 = ( ( PairWiseEq (C160 , C161) ) \/ { D329 } ) as (Subset of D326);
reconsider D331 = [ D330 , D328 ] as (Element of ( R18 -sequents )) by L23;
reconsider D332 = ( {} ) as (Subset of ( R18 -sequents )) by XBOOLE_1:2;
L758: (( D331 `1 ) = ( { ( C159 -compound C160 ) } \/ ( PairWiseEq (C160 , C161) ) ) & ( D331 `2 ) = ( C159 -compound C161 )) by MCART_1:7;
L759: D331 Rule3e D332 by L758 , L412;
L760: [ D332 , D331 ] in ( P#3e R18 ) by L759 , L456;
L761: D331 in ( ( R#3e R18 ) . D332 ) by L760 , L517;
L762: { D331 } c= ( ( R#3e R18 ) . D332 ) by L761 , ZFMISC_1:31;
thus L763: thesis by L762 , L340;
end;
registration
let R18 being Language;
let C162 being  relational (Element of R18);
let C163 , C164 being ( abs ( ar C162 ) ) -element (Element of ( ( AllTermsOf R18 ) * ));
cluster { [ ( ( PairWiseEq (C163 , C164) ) \/ { ( C162 -compound C163 ) } ) , ( C162 -compound C164 ) ] } -> (( {} ) , { ( R#3e R18 ) })-derivable;
coherence by L756;
end;
L765: (for R10 being set holds (for R14 being set holds (for R15 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (for B208 being  low-compounding (Element of R18) holds ((R10 is R53 -expanded & [ R14 , R15 ] in ( ( abs ( ar B208 ) ) -placesOf ( (R10 , R53) -termEq ) )) implies (ex B209 , B210 being ( abs ( ar B208 ) ) -element (Element of ( ( AllTermsOf R18 ) * )) st (B209 = R14 & B210 = R15 & ( PairWiseEq (B209 , B210) ) c= R10)))))))))
proof
let R10 being set;
let R14 being set;
let R15 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
let C165 being  low-compounding (Element of R18);
set D333 = ( abs ( ar C165 ) );
set D334 = ( AllTermsOf R18 );
set D335 = ( TheEqSymbOf R18 );
set D336 = R10;
set D337 = ( R18 -cons );
set D338 = ( AllSymbolsOf R18 );
set D339 = ( (D336 , R53) -termEq );
set D340 = ( AllSymbolsOf R18 );
assume L766: D336 is R53 -expanded;
assume L767: [ R14 , R15 ] in ( D333 -placesOf D339 );
consider C166 , C167 being (Element of ( D333 -tuples_on D334 )) such that L768: ([ R14 , R15 ] = [ C166 , C167 ] & (for B211 being set holds (B211 in ( Seg D333 ) implies [ ( C166 . B211 ) , ( C167 . B211 ) ] in D339))) by L767;
L769: (C166 = R14 & C167 = R15) by L768 , XTUPLE_0:1;
reconsider D341 = R14 , D342 = R15 as (Element of ( D333 -tuples_on D334 )) by L768 , XTUPLE_0:1;
reconsider D343 = D341 , D344 = D342 as D333 -element (Element of ( D334 * )) by FINSEQ_1:def 11;
take D345 = D343;
take D346 = D344;
thus L770: (D345 = R14 & D346 = R15);
set D347 = ( PairWiseEq (D345 , D346) );
L771: (D341 is (Element of ( Funcs (( Seg D333 ) , D334) )) & D342 is (Element of ( Funcs (( Seg D333 ) , D334) ))) by FOMODEL0:11;
reconsider D348 = D341 , D349 = D342 as (Function of ( Seg D333 ) , D334) by L771;
L772:
now
let R17 being set;
assume L773: R17 in D347;
consider C168 being (Element of ( Seg D333 )), C169 , C170 being (Function of ( Seg D333 ) , ( ( D340 * ) \ { ( {} ) } )) such that L774: (R17 = ( ( <* D335 *> ^ ( C169 . C168 ) ) ^ ( C170 . C168 ) ) & C169 = D343 & C170 = D344) by L773;
reconsider D350 = ( D348 . C168 ) , D351 = ( D349 . C168 ) as (Element of D334);
reconsider D352 = D350 , D353 = D351 as  termal (string of R18);
L775: [ ( D348 . C168 ) , ( D349 . C168 ) ] in D339 by L768 , L769;
L776: ( ( <* D335 *> ^ D352 ) ^ D353 ) is (D336 , R53)-provable by L775 , L376;
L777: { ( ( <* D335 *> ^ D352 ) ^ D353 ) } c= D336 by L776 , L766 , L116;
thus L778: R17 in D336 by L777 , L774 , ZFMISC_1:31;
end;
thus L779: D347 c= D336 by L772 , TARSKI:def 3;
end;
L780: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (for B212 being  low-compounding (Element of R18) holds (({ ( R#3d R18 ) } c= R53 & R10 is R53 -expanded & B212 is  termal) implies ( R10 -freeInterpreter B212 ) is ( (R10 , R53) -termEq ) -respecting)))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
let C171 being  low-compounding (Element of R18);
set D354 = ( abs ( ar C171 ) );
set D355 = ( AllTermsOf R18 );
set D356 = ( TheEqSymbOf R18 );
set D357 = R10;
set D358 = ( (D357 , R53) -termEq );
set D359 = ( R10 -freeInterpreter C171 );
assume L781: { ( R#3d R18 ) } c= R53;
assume L782: D357 is R53 -expanded;
assume L783: C171 is  termal;
reconsider D360 = C171 as  termal (Element of R18) by L783;
L784: (not D360 is  relational);
L785:
now
let R14 being set;
let R15 being set;
assume L786: [ R14 , R15 ] in ( D354 -placesOf D358 );
consider C172 , C173 being D354 -element (Element of ( D355 * )) such that L787: (C172 = R14 & C173 = R15 & ( PairWiseEq (C172 , C173) ) c= R10) by L786 , L765 , L782;
set D361 = ( PairWiseEq (C172 , C173) );
reconsider D362 = ( D360 -compound C172 ) , D363 = ( D360 -compound C173 ) as  termal (string of R18);
reconsider D364 = D361 as (Subset of D357) by L787;
L788: { [ D361 , ( ( <* D356 *> ^ D362 ) ^ D363 ) ] } is (( {} ) , { ( R#3d R18 ) })-derivable by L747;
L789: { [ D361 , ( ( <* D356 *> ^ D362 ) ^ D363 ) ] } is (( {} ) , R53)-derivable by L788 , L781 , L335;
L790: ( ( <* D356 *> ^ D362 ) ^ D363 ) is (D364 , R53)-provable by L789 , L100;
L791: (( D359 . C172 ) = D362 & ( D359 . C173 ) = D363) by FOMODEL3:6;
thus L792: [ ( D359 . R14 ) , ( D359 . R15 ) ] in D358 by L791 , L790 , L787;
end;
L793: D359 is (( D354 -placesOf D358 ) , D358)-respecting by L785 , FOMODEL3:def 9;
thus L794: D359 is D358 -respecting by L793 , L784 , FOMODEL3:def 10;
end;
L795: (for R10 being set holds (for R14 being set holds (for R15 being set holds (for R18 being Language holds (for R43 being  relational (Element of R18) holds (for R53 being (RuleSet of R18) holds (({ ( R#3e R18 ) } c= R53 & R10 is R53 -expanded & [ R14 , R15 ] in ( ( abs ( ar R43 ) ) -placesOf ( (R10 , R53) -termEq ) ) & ( ( R43 -compound ) . R14 ) in R10) implies ( ( R43 -compound ) . R15 ) in R10)))))))
proof
let R10 being set;
let R14 being set;
let R15 being set;
let R18 being Language;
let R43 being  relational (Element of R18);
let R53 being (RuleSet of R18);
set D365 = R43;
set D366 = ( abs ( ar D365 ) );
set D367 = ( AllTermsOf R18 );
set D368 = ( TheEqSymbOf R18 );
set D369 = R10;
set D370 = ( D365 -compound );
set D371 = ( (D369 , R53) -termEq );
assume L796: { ( R#3e R18 ) } c= R53;
assume L797: D369 is R53 -expanded;
assume L798: [ R14 , R15 ] in ( D366 -placesOf D371 );
consider C174 , C175 being D366 -element (Element of ( D367 * )) such that L799: (C174 = R14 & C175 = R15 & ( PairWiseEq (C174 , C175) ) c= R10) by L798 , L765 , L797;
set D372 = ( PairWiseEq (C174 , C175) );
reconsider D373 = ( D365 -compound C174 ) , D374 = ( D365 -compound C175 ) as ( 0 ) -wff (string of R18);
L800: (( D370 . R14 ) = D373 & ( D370 . R15 ) = D374) by L799 , FOMODEL3:def 2;
assume L801: ( D370 . R14 ) in R10;
reconsider D375 = { D373 } as (Subset of R10) by L801 , L800 , ZFMISC_1:31;
reconsider D376 = D372 as (Subset of D369) by L799;
reconsider D377 = ( D376 \/ D375 ) as (Subset of R10);
L802: { [ ( D372 \/ { ( D365 -compound C174 ) } ) , ( D365 -compound C175 ) ] } is (( {} ) , { ( R#3e R18 ) })-derivable;
L803: { [ D377 , D374 ] } is (( {} ) , R53)-derivable by L802 , L335 , L796;
L804: D374 is (D377 , R53)-provable by L803 , L100;
L805: { D374 } c= D369 by L804 , L797 , L116;
thus L806: thesis by L805 , L800 , ZFMISC_1:31;
end;
L807: (for R10 being set holds (for R14 being set holds (for R15 being set holds (for R18 being Language holds (for R43 being  relational (Element of R18) holds (for R53 being (RuleSet of R18) holds ((( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) } & R10 is R53 -expanded & [ R14 , R15 ] in ( ( abs ( ar R43 ) ) -placesOf ( (R10 , R53) -termEq ) )) implies (( ( R43 -compound ) . R14 ) in R10 iff ( ( R43 -compound ) . R15 ) in R10))))))))
proof
let R10 being set;
let R14 being set;
let R15 being set;
let R18 being Language;
let R43 being  relational (Element of R18);
let R53 being (RuleSet of R18);
set D378 = R43;
set D379 = ( abs ( ar D378 ) );
set D380 = ( AllTermsOf R18 );
set D381 = ( TheEqSymbOf R18 );
set D382 = R10;
set D383 = ( D378 -compound );
set D384 = ( (R10 , R53) -termEq );
assume L808: (( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) } & R10 is R53 -expanded & [ R14 , R15 ] in ( D379 -placesOf D384 ));
reconsider D385 = D384 as  symmetric  total (Relation of D380) by L808 , L567 , L592;
thus L809: (( D383 . R14 ) in R10 implies ( D383 . R15 ) in R10) by L808 , L795;
reconsider D386 = ( D379 -placesOf D385 ) as  symmetric  total (Relation of ( D379 -tuples_on D380 ));
L810: [ R15 , R14 ] in D386 by L808 , EQREL_1:6;
thus L811: (( D383 . R15 ) in R10 implies ( D383 . R14 ) in R10) by L810 , L808 , L795;
end;
L812: (for R7 being non  empty set holds (for R11 being set holds (for B213 , B214 being (Element of R7) holds ((B213 in R11 iff B214 in R11) implies [ ( ( chi (R11 , R7) ) . B213 ) , ( ( chi (R11 , R7) ) . B214 ) ] in ( id ( BOOLEAN ) )))))
proof
let R7 being non  empty set;
let R11 being set;
let C176 , C177 being (Element of R7);
set D387 = ( chi (R11 , R7) );
assume L813: (C176 in R11 iff C177 in R11);
per cases ;
suppose L814: C176 in R11;

L815: (( D387 . C176 ) = 1 & C177 in R11) by L814 , L813 , RFUNCT_1:63;
L816: (( D387 . C176 ) = 1 & ( D387 . C177 ) = 1 & 1 in ( BOOLEAN )) by L815 , RFUNCT_1:63;
thus L817: thesis by L816 , RELAT_1:def 10;
end;
suppose L818: (not C176 in R11);

L819: (( D387 . C176 ) = ( 0 ) & (not C177 in R11)) by L818 , L813 , RFUNCT_1:64;
L820: (( D387 . C176 ) = ( 0 ) & ( D387 . C177 ) = ( 0 ) & ( 0 ) in ( BOOLEAN )) by L819 , RFUNCT_1:64;
thus L821: thesis by L820 , RELAT_1:def 10;
end;
end;
L823: (for R10 being set holds (for R18 being Language holds (for R43 being  relational (Element of R18) holds (for R53 being (RuleSet of R18) holds ((( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) } & R10 is R53 -expanded) implies ( R10 -freeInterpreter R43 ) is ( (R10 , R53) -termEq ) -respecting)))))
proof
let R10 being set;
let R18 being Language;
let R43 being  relational (Element of R18);
let R53 being (RuleSet of R18);
assume L824: (( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) } & R10 is R53 -expanded);
set D388 = ( AllTermsOf R18 );
set D389 = ( (R10 , R53) -termEq );
set D390 = ( R10 -freeInterpreter R43 );
set D391 = ( AtomicFormulasOf R18 );
set D392 = ( chi (R10 , D391) );
set D393 = ( AllSymbolsOf R18 );
set D394 = ( R43 -compound );
set D395 = ( abs ( ar R43 ) );
L825:
now
let R14 being set;
let R15 being set;
assume L826: [ R14 , R15 ] in ( D395 -placesOf D389 );
consider C178 , C179 being D395 -element (Element of ( D388 * )) such that L827: (C178 = R14 & C179 = R15 & ( PairWiseEq (C178 , C179) ) c= R10) by L826 , L765 , L824;
reconsider D396 = ( R43 -compound C178 ) , D397 = ( R43 -compound C179 ) as ( 0 ) -wff (string of R18);
L828: (D396 in D391 & D397 in D391);
reconsider D398 = D396 , D399 = D397 as (Element of D391) by L828;
L829: (( D394 . R14 ) = D398 & ( D394 . R15 ) = D399) by L827 , FOMODEL3:def 2;
L830: (D398 in R10 iff D399 in R10) by L829 , L824 , L826 , L807;
L831: ([ ( D392 . D396 ) , ( D392 . D397 ) ] in ( id ( BOOLEAN ) ) & ( D390 . C178 ) = ( D392 . D396 ) & ( D390 . C179 ) = ( D392 . D397 )) by L830 , L812 , FOMODEL3:6;
thus L832: [ ( D390 . R14 ) , ( D390 . R15 ) ] in ( id ( BOOLEAN ) ) by L831 , L827;
end;
L833: D390 is (( D395 -placesOf D389 ) , ( id ( BOOLEAN ) ))-respecting by L825 , FOMODEL3:def 9;
thus L834: thesis by L833 , FOMODEL3:def 10;
end;
L835: (for R7 being non  empty set holds (for R10 being set holds (for R13 being set holds (for B215 being  total  reflexive (Relation of R7) holds (for B216 being (Function of R10 , R7) holds (R13 in R10 implies B216 is ({ [ R13 , R13 ] } , B215)-respecting))))))
proof
let R7 being non  empty set;
let R10 being set;
let R13 being set;
let C180 being  total  reflexive (Relation of R7);
let C181 being (Function of R10 , R7);
reconsider D400 = { [ R13 , R13 ] } as Relation;
assume L836: R13 in R10;
reconsider D401 = R10 as non  empty set by L836;
reconsider D402 = C181 as (Function of D401 , R7);
L837:
now
let C182 , C183 being set;
assume L838: [ C182 , C183 ] in D400;
L839: [ C182 , C183 ] = [ R13 , R13 ] by L838 , TARSKI:def 1;
L840: (C182 = R13 & C183 = R13) by L839 , XTUPLE_0:1;
reconsider D403 = C182 , D404 = C183 as (Element of D401) by L836 , L839 , XTUPLE_0:1;
L841: (( D402 . D403 ) in R7 & ( D402 . D404 ) in R7 & ( D402 . D403 ) = ( D402 . D404 )) by L840;
thus L842: [ ( C181 . C182 ) , ( C181 . C183 ) ] in C180 by L841 , EQREL_1:5;
end;
thus L843: thesis by L837 , FOMODEL3:def 9;
end;
L844: (for R7 being non  empty set holds (for R18 being Language holds (for R45 being  literal (Element of R18) holds (for B217 being  total  reflexive (Relation of R7) holds (for B218 being (Interpreter of R45 , R7) holds B218 is B217 -respecting)))))
proof
let R7 being non  empty set;
let R18 being Language;
let R45 being  literal (Element of R18);
let C184 being  total  reflexive (Relation of R7);
reconsider D405 = ( abs ( ar R45 ) ) as  zero Nat;
let C185 being (Interpreter of R45 , R7);
L845: ( D405 -tuples_on R7 ) = { ( {} ) } by FOMODEL0:10;
reconsider D406 = C185 as (Function of { ( {} ) } , R7) by L845 , FOMODEL2:def 2;
L846: ( {} ) in { ( {} ) } by TARSKI:def 1;
L847: D406 is ({ [ ( {} ) , ( {} ) ] } , C184)-respecting by L846 , L835;
L848: C185 is (( D405 -placesOf C184 ) , C184)-respecting by L847;
thus L849: thesis by L848 , FOMODEL3:def 10;
end;
L850: (for R10 being set holds (for R18 being Language holds (for R45 being  literal (Element of R18) holds (for R53 being (RuleSet of R18) holds (({ ( R#0 R18 ) , ( R#3a R18 ) } c= R53 & { ( R#2 R18 ) , ( R#3b R18 ) } c= R53 & R10 is R53 -expanded) implies ( R10 -freeInterpreter R45 ) is ( (R10 , R53) -termEq ) -respecting)))))
proof
let R10 being set;
let R18 being Language;
let R45 being  literal (Element of R18);
let R53 being (RuleSet of R18);
set D407 = ( AllTermsOf R18 );
set D408 = ( R10 -freeInterpreter R45 );
assume L851: ({ ( R#0 R18 ) , ( R#3a R18 ) } c= R53 & { ( R#2 R18 ) , ( R#3b R18 ) } c= R53 & R10 is R53 -expanded);
reconsider D409 = ( (R10 , R53) -termEq ) as (Equivalence_Relation of D407) by L851 , L716;
L852: D408 is D409 -respecting by L844;
thus L853: thesis by L852;
end;
L854: (for R10 being set holds (for R18 being Language holds (for R44 being  ofAtomicFormula (Element of R18) holds (for R53 being (RuleSet of R18) holds (({ ( R#0 R18 ) , ( R#3a R18 ) } c= R53 & ( R53 /\ { ( R#3d R18 ) } ) = { ( R#3d R18 ) } & ( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) } & R10 is R53 -expanded) implies ( R10 -freeInterpreter R44 ) is ( (R10 , R53) -termEq ) -respecting)))))
proof
let R10 being set;
let R18 being Language;
let R44 being  ofAtomicFormula (Element of R18);
let R53 being (RuleSet of R18);
set D410 = R44;
set D411 = ( AllTermsOf R18 );
set D412 = ( R10 -freeInterpreter D410 );
set D413 = ( AtomicFormulasOf R18 );
set D414 = ( chi (R10 , D413) );
set D415 = ( AllSymbolsOf R18 );
set D416 = ( abs ( ar D410 ) );
set D417 = ( D410 -compound );
set D418 = ( (R10 , R53) -termEq );
assume L855: ({ ( R#0 R18 ) , ( R#3a R18 ) } c= R53 & ( R53 /\ { ( R#3d R18 ) } ) = { ( R#3d R18 ) } & ( { ( R#2 R18 ) } /\ R53 ) = { ( R#2 R18 ) } & ( { ( R#3b R18 ) } /\ R53 ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) } & R10 is R53 -expanded);
reconsider D419 = { ( R#2 R18 ) } , D420 = { ( R#3b R18 ) } as (Subset of R53) by L855;
L856: ( D419 \/ D420 ) c= R53;
per cases ;
suppose L857: (not D410 is  relational);

reconsider D421 = D410 as  termal (Element of R18) by L857;
per cases ;
suppose L858: D421 is  literal;

reconsider D422 = D421 as  literal (Element of R18) by L858;
L859: { ( R#2 R18 ) , ( R#3b R18 ) } c= R53 by L856 , ENUMSET1:1;
L860: ( R10 -freeInterpreter D422 ) is D418 -respecting by L859 , L850 , L855;
thus L861: thesis by L860;
end;
suppose L862: D421 is non  literal;

reconsider D423 = D421 as  low-compounding (Element of R18) by L862;
L863: ( R10 -freeInterpreter D423 ) is D418 -respecting by L780 , L855;
thus L864: thesis by L863;
end;
end;
suppose L866: D410 is  relational;

reconsider D424 = D410 as  relational (Element of R18) by L866;
L867: ( R10 -freeInterpreter D424 ) is D418 -respecting by L823 , L855;
thus L868: thesis by L867;
end;
end;
definition
let R2 being Nat;
let R18 being Language;
let R53 being (RuleSet of R18);
attr R53 is R2 -ranked
means
:L870: (( R#0 R18 ) in R53 & ( R#2 R18 ) in R53 & ( R#3a R18 ) in R53 & ( R#3b R18 ) in R53) if R2 = ( 0 ) , (( R#0 R18 ) in R53 & ( R#2 R18 ) in R53 & ( R#3a R18 ) in R53 & ( R#3b R18 ) in R53 & ( R#3d R18 ) in R53 & ( R#3e R18 ) in R53) if R2 = 1 , (( R#0 R18 ) in R53 & ( R#1 R18 ) in R53 & ( R#2 R18 ) in R53 & ( R#3a R18 ) in R53 & ( R#3b R18 ) in R53 & ( R#3d R18 ) in R53 & ( R#3e R18 ) in R53 & ( R#4 R18 ) in R53 & ( R#5 R18 ) in R53 & ( R#6 R18 ) in R53 & ( R#7 R18 ) in R53 & ( R#8 R18 ) in R53) if R2 = 2 otherwise R53 = ( {} );
consistency;
end;
registration
let R18 being Language;
cluster 1 -ranked -> ( 0 ) -ranked for (RuleSet of R18);
coherence
proof
let C186 being (RuleSet of R18);
assume L872: C186 is 1 -ranked;
L873: (( R#0 R18 ) in C186 & ( R#2 R18 ) in C186 & ( R#3a R18 ) in C186 & ( R#3b R18 ) in C186) by L872 , L870;
thus L874: thesis by L873 , L870;
end;
cluster 2 -ranked -> 1 -ranked for (RuleSet of R18);
coherence
proof
let C187 being (RuleSet of R18);
assume L875: C187 is 2 -ranked;
L876: (( R#0 R18 ) in C187 & ( R#2 R18 ) in C187 & ( R#3a R18 ) in C187 & ( R#3b R18 ) in C187 & ( R#3d R18 ) in C187 & ( R#3e R18 ) in C187) by L875 , L870;
thus L877: thesis by L876 , L870;
end;
end;
definition
let R18 being Language;
func R18 -rules -> (RuleSet of R18) equals 
( { ( R#0 R18 ) , ( R#1 R18 ) , ( R#2 R18 ) , ( R#3a R18 ) , ( R#3b R18 ) , ( R#3d R18 ) , ( R#3e R18 ) , ( R#4 R18 ) } \/ { ( R#5 R18 ) , ( R#6 R18 ) , ( R#7 R18 ) , ( R#8 R18 ) } );
coherence;
end;
registration
let R18 being Language;
cluster ( R18 -rules ) -> 2 -ranked for (RuleSet of R18);
coherence
proof
set D425 = { ( R#0 R18 ) , ( R#1 R18 ) , ( R#2 R18 ) , ( R#3a R18 ) , ( R#3b R18 ) , ( R#3d R18 ) , ( R#3e R18 ) , ( R#4 R18 ) };
set D426 = { ( R#5 R18 ) , ( R#6 R18 ) , ( R#7 R18 ) , ( R#8 R18 ) };
set D427 = ( D425 \/ D426 );
L880: (( R#0 R18 ) in D425 & ( R#1 R18 ) in D425 & ( R#2 R18 ) in D425 & ( R#3a R18 ) in D425 & ( R#3b R18 ) in D425 & ( R#3d R18 ) in D425 & ( R#3e R18 ) in D425 & ( R#4 R18 ) in D425 & ( R#5 R18 ) in D426 & ( R#6 R18 ) in D426 & ( R#7 R18 ) in D426 & ( R#8 R18 ) in D426) by ENUMSET1:def 2 , ENUMSET1:def 6;
L881: (( R#0 R18 ) in D427 & ( R#1 R18 ) in D427 & ( R#2 R18 ) in D427 & ( R#3a R18 ) in D427 & ( R#3b R18 ) in D427 & ( R#3d R18 ) in D427 & ( R#3e R18 ) in D427 & ( R#4 R18 ) in D427 & ( R#5 R18 ) in D427 & ( R#6 R18 ) in D427 & ( R#7 R18 ) in D427 & ( R#8 R18 ) in D427) by L880 , XBOOLE_0:def 3;
thus L882: thesis by L881 , L870;
end;
end;
registration
let R18 being Language;
cluster 2 -ranked for (RuleSet of R18);
existence
proof
take ( R18 -rules );
thus L884: thesis;
end;
end;
registration
let R18 being Language;
cluster 1 -ranked for (RuleSet of R18);
existence
proof
take the 2 -ranked (RuleSet of R18);
thus L886: thesis;
end;
end;
registration
let R18 being Language;
cluster ( 0 ) -ranked for (RuleSet of R18);
existence
proof
take the 1 -ranked (RuleSet of R18);
thus L888: thesis;
end;
end;
L890: (for R10 being set holds (for R18 being Language holds (for R44 being  ofAtomicFormula (Element of R18) holds (for R53 being (RuleSet of R18) holds ((R53 is 1 -ranked & R10 is R53 -expanded) implies ( R10 -freeInterpreter R44 ) is ( (R10 , R53) -termEq ) -respecting)))))
proof
let R10 being set;
let R18 being Language;
let R44 being  ofAtomicFormula (Element of R18);
let R53 being (RuleSet of R18);
assume L891: R53 is 1 -ranked;
L892: (( R#0 R18 ) in R53 & ( R#3a R18 ) in R53) by L891 , L870;
L893: ({ ( R#0 R18 ) } c= R53 & { ( R#3a R18 ) } c= R53) by L892 , ZFMISC_1:31;
L894: ( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ) c= R53 by L893 , XBOOLE_1:8;
L895: { ( R#0 R18 ) , ( R#3a R18 ) } c= R53 by L894 , ENUMSET1:1;
L896: (( R#3d R18 ) in R53 & ( R#2 R18 ) in R53 & ( R#3b R18 ) in R53 & ( R#3e R18 ) in R53) by L891 , L870;
L897: ({ ( R#3d R18 ) } c= R53 & { ( R#2 R18 ) } c= R53 & { ( R#3b R18 ) } c= R53 & { ( R#3e R18 ) } c= R53) by L896 , ZFMISC_1:31;
L898: (( R53 /\ { ( R#3d R18 ) } ) = { ( R#3d R18 ) } & ( R53 /\ { ( R#2 R18 ) } ) = { ( R#2 R18 ) } & ( R53 /\ { ( R#3b R18 ) } ) = { ( R#3b R18 ) } & ( R53 /\ { ( R#3e R18 ) } ) = { ( R#3e R18 ) }) by L897 , XBOOLE_1:28;
assume L899: R10 is R53 -expanded;
thus L900: thesis by L899 , L854 , L895 , L898;
end;
registration
let R18 being Language;
let C188 being 1 -ranked (RuleSet of R18);
let C189 being C188 -expanded set;
let R44 being  ofAtomicFormula (Element of R18);
cluster ( C189 -freeInterpreter R44 ) -> ( (C189 , C188) -termEq ) -respecting for (Interpreter of R44 , ( AllTermsOf R18 ));
coherence by L890;
end;
L902: (for R10 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ((R53 is ( 0 ) -ranked & R10 is R53 -expanded) implies ( (R10 , R53) -termEq ) is (Equivalence_Relation of ( AllTermsOf R18 ))))))
proof
let R10 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
assume L903: R53 is ( 0 ) -ranked;
L904: (( R#0 R18 ) in R53 & ( R#3a R18 ) in R53 & ( R#2 R18 ) in R53 & ( R#3b R18 ) in R53) by L903 , L870;
L905: ({ ( R#0 R18 ) } c= R53 & { ( R#3a R18 ) } c= R53 & { ( R#2 R18 ) } c= R53 & { ( R#3b R18 ) } c= R53) by L904 , ZFMISC_1:31;
L906: (( { ( R#0 R18 ) } \/ { ( R#3a R18 ) } ) c= R53 & ( { ( R#2 R18 ) } \/ { ( R#3b R18 ) } ) c= R53) by L905 , XBOOLE_1:8;
L907: ({ ( R#0 R18 ) , ( R#3a R18 ) } c= R53 & { ( R#2 R18 ) , ( R#3b R18 ) } c= R53) by L906 , ENUMSET1:1;
assume L908: R10 is R53 -expanded;
thus L909: thesis by L908 , L907 , L716;
end;
registration
let R18 being Language;
let C190 being ( 0 ) -ranked (RuleSet of R18);
let C191 being C190 -expanded set;
cluster ( (C191 , C190) -termEq ) ->  total  symmetric  transitive for (Relation of ( AllTermsOf R18 ));
coherence by L902;
end;
registration
let R18 being Language;
cluster 1 -ranked for ( 0 ) -ranked ( 0 ) -ranked ( 0 ) -ranked ( 0 ) -ranked (RuleSet of R18);
existence
proof
set D428 = the 1 -ranked (RuleSet of R18);
reconsider D429 = D428 as ( 0 ) -ranked (RuleSet of R18);
take D429;
thus L911: thesis;
end;
end;
theorem
L913: (for R10 being set holds (for R11 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R55 is  isotone or R54 is  isotone) & R11 is (R10 , R54)-derivable) implies R11 is (R10 , R55)-derivable)))))) by L335;
registration
let R18 being Language;
let R67 being R18 -sequent-like set;
cluster { R67 } -> R18 -sequents-like;
coherence
proof
set D430 = ( R18 -sequents );
L914: R67 in D430 by L23;
L915: { R67 } c= D430 by L914 , ZFMISC_1:31;
thus L916: thesis by L915;
end;
end;
registration
let R18 being Language;
let R65 being R18 -sequents-like set;
let R66 being R18 -sequents-like set;
cluster ( R65 \/ R66 ) -> R18 -sequents-like for set;
coherence
proof
set D431 = ( R18 -sequents );
reconsider D432 = R65 , D433 = R66 as (Subset of D431) by L25;
L918: ( D432 \/ D433 ) c= D431;
thus L919: thesis by L918;
end;
end;
registration
let R18 being Language;
let C192 , C193 being R18 -sequent-like set;
cluster { C192 , C193 } -> R18 -sequents-like for set;
coherence
proof
L921: { C192 , C193 } = ( { C192 } \/ { C193 } ) by ENUMSET1:1;
thus L922: thesis by L921;
end;
end;
L924: (for R2 being Nat holds (for R3 being Nat holds (for R13 being set holds (for R16 being set holds (for R17 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds (for R56 being (RuleSet of R18) holds (for R65 being R18 -sequents-like set holds (for R66 being R18 -sequents-like set holds ((( R54 \/ R55 ) is  isotone & ( ( R54 \/ R55 ) \/ R56 ) is  isotone & R13 is (R2 , R65 , R54)-derivable & R16 is (R2 , R66 , R55)-derivable & R17 is (R3 , { R13 , R16 } , R56)-derivable) implies R17 is (( R2 + R3 ) , ( R65 \/ R66 ) , ( ( R54 \/ R55 ) \/ R56 ))-derivable))))))))))))
proof
let R2 being Nat;
let R3 being Nat;
let R13 being set;
let R16 being set;
let R17 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
let R56 being (RuleSet of R18);
let R65 being R18 -sequents-like set;
let R66 being R18 -sequents-like set;
set D434 = ( R18 -sequents );
set D435 = ( R54 \/ R55 );
set D436 = ( OneStep R54 );
set D437 = ( OneStep R55 );
set D438 = ( OneStep R56 );
set D439 = ( OneStep D435 );
set D440 = ( OneStep ( D435 \/ R56 ) );
reconsider D441 = R65 , D442 = R66 as (Subset of D434) by L25;
set D443 = ( D441 \/ D442 );
assume L925: (D435 is  isotone & ( D435 \/ R56 ) is  isotone);
assume L926: (R13 is (R2 , R65 , R54)-derivable & R16 is (R2 , R66 , R55)-derivable);
L927: (R13 in ( ( (R2 , R54) -derivables ) . D441 ) & R16 in ( ( (R2 , R55) -derivables ) . D442 )) by L926 , L63;
reconsider D444 = R13 , D445 = R16 as R18 -sequent-like set by L926;
L928: (( D441 null D442 ) c= D443 & ( D442 null D441 ) c= D443 & ( R54 null R55 ) c= D435 & ( R55 null R54 ) c= D435);
L929: (( ( (R2 , R54) -derivables ) . D441 ) c= ( ( (R2 , D435) -derivables ) . D443 ) & ( ( (R2 , R55) -derivables ) . D442 ) c= ( ( (R2 , D435) -derivables ) . D443 )) by L928 , L296 , L925;
L930: { D444 , D445 } c= ( ( iter (D439 , R2) ) . D443 ) by L929 , L927 , ZFMISC_1:32;
assume L931: R17 is (R3 , { R13 , R16 } , R56)-derivable;
L932: R17 in ( ( (R3 , R56) -derivables ) . { R13 , R16 } ) by L931 , L63;
L933: { R17 } c= ( ( iter (D438 , R3) ) . { R13 , R16 } ) by L932 , ZFMISC_1:31;
L934: { R17 } c= ( ( iter (D440 , ( R2 + R3 )) ) . D443 ) by L933 , L930 , L925 , L351;
L935: R17 in ( ( (( R2 + R3 ) , ( D435 \/ R56 )) -derivables ) . D443 ) by L934 , ZFMISC_1:31;
thus L936: thesis by L935 , L63;
end;
L937: (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R54 is  isotone or R55 is  isotone) & R13 is (R10 , R54)-provable) implies R13 is (R10 , R55)-provable))))))
proof
let R10 being set;
let R13 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
assume L938: (R54 c= R55 & (R54 is  isotone or R55 is  isotone));
assume L939: R13 is (R10 , R54)-provable;
consider C194 being set such that L940: (( C194 `1 ) c= R10 & ( C194 `2 ) = R13 & { C194 } is R54 -derivable) by L939 , L102;
L941: { C194 } is (( {} ) , R55)-derivable by L940 , L938 , L335;
thus L942: thesis by L941 , L940 , L102;
end;
L943: (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R57 being (Rule of R18) holds (R13 in ( R57 . R10 ) implies R13 is (1 , R10 , { R57 })-derivable)))))
proof
let R10 being set;
let R13 being set;
let R18 being Language;
let R57 being (Rule of R18);
set D446 = ( R18 -sequents );
set D447 = { R57 };
set D448 = ( OneStep D447 );
set D449 = ( iter (D448 , 1) );
assume L944: R13 in ( R57 . R10 );
L945: R10 in ( dom R57 ) by L944 , FUNCT_1:def 2;
reconsider D450 = R10 as (Element of ( bool D446 )) by L945;
L946: ( iter (D448 , 1) ) = D448 by FUNCT_7:70
.= R57 by L188;
L947: R13 in ( ( (1 , D447) -derivables ) . D450 ) by L946 , L944;
thus L948: thesis by L947 , L63;
end;
registration
let R18 being Language;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster [ { ( xnot R32 ) , ( xnot R33 ) } , ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) ] -> (1 , { [ { ( xnot R32 ) , ( xnot R33 ) } , ( xnot R32 ) ] , [ { ( xnot R32 ) , ( xnot R33 ) } , ( xnot R33 ) ] } , { ( R#6 R18 ) })-derivable for set;
coherence
proof
set D451 = ( R18 -sequents );
set D452 = ( xnot R32 );
set D453 = ( xnot R33 );
set D454 = ( TheNorSymbOf R18 );
set D455 = { D452 , D453 };
set D456 = [ D455 , ( ( <* D454 *> ^ R32 ) ^ R33 ) ];
set D457 = [ D455 , D452 ];
set D458 = [ D455 , D453 ];
set D459 = { D457 , D458 };
reconsider D460 = D456 as (Element of D451) by L23;
reconsider D461 = D459 as (Element of ( bool D451 )) by L25;
L949: (( { D457 } \ D461 ) = ( {} ) & ( { D458 } \ D461 ) = ( {} ) & ( ( D457 `1 ) \+\ D455 ) = ( {} ) & ( ( D458 `1 ) \+\ D455 ) = ( {} ) & ( ( D456 `1 ) \+\ D455 ) = ( {} ) & ( ( D456 `1 ) \+\ D455 ) = ( {} ) & ( ( D457 `2 ) \+\ ( xnot R32 ) ) = ( {} ) & ( ( D458 `2 ) \+\ ( xnot R33 ) ) = ( {} ) & ( ( D456 `2 ) \+\ ( ( <* D454 *> ^ R32 ) ^ R33 ) ) = ( {} ));
L950: (D457 in D461 & D458 in D461 & ( D457 `1 ) = D455 & ( D458 `1 ) = D455 & ( D456 `1 ) = D455 & ( D457 `2 ) = ( xnot R32 ) & ( D458 `2 ) = ( xnot R33 ) & ( D456 `2 ) = ( ( <* D454 *> ^ R32 ) ^ R33 )) by L949 , ZFMISC_1:60;
L951: D460 Rule6 D461 by L950 , L415;
L952: [ D461 , D460 ] in ( P#6 R18 ) by L951 , L474;
L953: D460 in ( ( R#6 R18 ) . D461 ) by L952 , L517;
thus L954: thesis by L953 , L943;
end;
end;
registration
let R18 being Language;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster [ { R32 , R33 } , R33 ] -> (1 , ( {} ) , { ( R#0 R18 ) })-derivable for set;
coherence
proof
L956: [ { R32 , R33 } , R33 ] = [ { R33 , R32 } , R33 ];
thus L957: thesis by L956;
end;
end;
theorem
L959: (for R18 being Language holds (for R64 being R18 -sequents-like set holds (for R67 being R18 -sequent-like set holds (for B219 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents )) holds ([ R64 , R67 ] in B219 implies R67 in ( ( FuncRule B219 ) . R64 ))))))
proof
let R18 being Language;
let R64 being R18 -sequents-like set;
let R67 being R18 -sequent-like set;
set D462 = ( R18 -sequents );
reconsider D463 = R67 as (Element of D462) by L23;
reconsider D464 = R64 as (Element of ( bool D462 )) by L25;
let C195 being (Relation of ( bool D462 ) , D462);
L960: ([ D464 , D463 ] in C195 implies D463 in ( ( FuncRule C195 ) . D464 )) by L517;
thus L961: thesis by L960;
end;
theorem
L962: (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R57 being (Rule of R18) holds (R13 in ( R57 . R10 ) implies R13 is (1 , R10 , { R57 })-derivable))))) by L943;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let R10 being set;
redefine attr R10 is R53 -expanded
means
:L963: (for R13 being set holds (R13 is (R10 , R53)-provable implies R13 in R10));
compatibility
proof
defpred S29[  ] means (for R13 being set holds (R13 is (R10 , R53)-provable implies R13 in R10));
thus L964: (R10 is R53 -expanded implies S29[  ])
proof
assume L965: R10 is R53 -expanded;
thus L966:now
let R13 being set;
assume L967: R13 is (R10 , R53)-provable;
L968: { R13 } c= R10 by L967 , L965 , L116;
thus L969: R13 in R10 by L968 , ZFMISC_1:31;
end;
end;

assume L967: S29[  ];
thus L968:now
let R13 being set;
assume L969: R13 is (R10 , R53)-provable;
L970: R13 in R10 by L969 , L967;
thus L971: { R13 } c= R10 by L970 , ZFMISC_1:31;
end;
end;
end;
theorem
L970: (for R10 being set holds (for R18 being Language holds (for R31 being  wff (string of R18) holds (R31 in R10 implies R31 is (R10 , { ( R#0 R18 ) })-provable))))
proof
let R10 being set;
let R18 being Language;
let R31 being  wff (string of R18);
assume L971: R31 in R10;
reconsider D465 = { R31 } as (Subset of R10) by L971 , ZFMISC_1:31;
L972: { [ { R31 } , R31 ] } is (( {} ) , { ( R#0 R18 ) })-derivable;
L973: R31 is (D465 , { ( R#0 R18 ) })-provable by L972 , L100;
thus L974: thesis by L973;
end;
theorem
L975: (for R2 being Nat holds (for R3 being Nat holds (for R13 being set holds (for R16 being set holds (for R17 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds (for R56 being (RuleSet of R18) holds (for R65 being R18 -sequents-like set holds (for R66 being R18 -sequents-like set holds ((( R54 \/ R55 ) is  isotone & ( ( R54 \/ R55 ) \/ R56 ) is  isotone & R13 is (R2 , R65 , R54)-derivable & R16 is (R2 , R66 , R55)-derivable & R17 is (R3 , { R13 , R16 } , R56)-derivable) implies R17 is (( R2 + R3 ) , ( R65 \/ R66 ) , ( ( R54 \/ R55 ) \/ R56 ))-derivable)))))))))))) by L924;
theorem
L976: (for R2 being Nat holds (for R3 being Nat holds (for R10 being set holds (for R16 being set holds (for R17 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 is  isotone & ( R54 \/ R55 ) is  isotone & R16 is (R2 , R10 , R54)-derivable & R17 is (R3 , { R16 } , R55)-derivable) implies R17 is (( R2 + R3 ) , R10 , ( R54 \/ R55 ))-derivable))))))))) by L363;
theorem
L977: (for R2 being Nat holds (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (R13 is (R2 , R10 , R53)-derivable implies { R13 } is (R10 , R53)-derivable)))))) by L260;
registration
let R18 being Language;
cluster ( R#6 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D466 = ( R#6 R18 );
set D467 = ( R18 -sequents );
L978:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D468 = R58;
set D469 = R60;
assume L979: D468 c= D469;
L980:
now
let R13 being set;
assume L981: R13 in ( D466 . D468 );
reconsider D470 = R13 as (Element of D467) by L981;
L982: [ D468 , D470 ] in ( P#6 R18 ) by L981 , L537;
L983: D470 Rule6 D468 by L982 , L474;
consider C196 , C197 being set, C198 , C199 being  wff (string of R18) such that L984: (C196 in R58 & C197 in R58 & ( C196 `1 ) = ( C197 `1 ) & ( C197 `1 ) = ( D470 `1 ) & ( C196 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C198 ) ^ C198 ) & ( C197 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C199 ) ^ C199 ) & ( D470 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C198 ) ^ C199 )) by L983 , L415;
L985: D470 Rule6 D469 by L415 , L984 , L979;
L986: [ D469 , D470 ] in ( P#6 R18 ) by L985 , L474;
thus L987: R13 in ( D466 . D469 ) by L986 , L959;
end;
thus L988: ( D466 . D468 ) c= ( D466 . D469 ) by L980 , TARSKI:def 3;
end;
thus L989: thesis by L978 , L72;
end;
end;
theorem
L991: (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R54 is  isotone or R55 is  isotone) & R13 is (R10 , R54)-provable) implies R13 is (R10 , R55)-provable)))))) by L937;
theorem
L992: (for R10 being set holds (for R11 being set holds (for R13 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds ((R10 c= R11 & R13 is (R10 , R53)-provable) implies R13 is (R11 , R53)-provable))))));
registration
let R18 being Language;
cluster ( R#8 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D471 = ( R#8 R18 );
set D472 = ( R18 -sequents );
L993:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D473 = R58;
set D474 = R60;
assume L994: D473 c= D474;
L995:
now
let R13 being set;
assume L996: R13 in ( D471 . D473 );
reconsider D475 = R13 as (Element of D472) by L996;
L997: [ D473 , D475 ] in ( P#8 R18 ) by L996 , L537;
L998: D475 Rule8 D473 by L997 , L486;
consider C200 , C201 being set, C202 , C203 , C204 being  wff (string of R18) such that L999: (C200 in R58 & C201 in R58 & ( C200 `1 ) = ( C201 `1 ) & ( C200 `2 ) = C203 & ( C201 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C203 ) ^ C204 ) & ( { C202 } \/ ( D475 `1 ) ) = ( C200 `1 ) & ( D475 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C202 ) ^ C202 )) by L998 , L417;
L1000: D475 Rule8 D474 by L417 , L999 , L994;
L1001: [ D474 , D475 ] in ( P#8 R18 ) by L1000 , L486;
thus L1002: R13 in ( D471 . D474 ) by L1001 , L959;
end;
thus L1003: ( D471 . D473 ) c= ( D471 . D474 ) by L995 , TARSKI:def 3;
end;
thus L1004: thesis by L993 , L72;
end;
end;
registration
let R18 being Language;
cluster ( R#1 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D476 = ( R#1 R18 );
set D477 = ( R18 -sequents );
L1006:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D478 = R58;
set D479 = R60;
assume L1007: D478 c= D479;
L1008:
now
let R13 being set;
assume L1009: R13 in ( D476 . D478 );
reconsider D480 = R13 as (Element of D477) by L1009;
L1010: [ D478 , D480 ] in ( P#1 R18 ) by L1009 , L537;
L1011: D480 Rule1 D478 by L1010 , L426;
consider C205 being set such that L1012: (C205 in R58 & ( C205 `1 ) c= ( D480 `1 ) & ( D480 `2 ) = ( C205 `2 )) by L1011 , L407;
L1013: D480 Rule1 D479 by L407 , L1012 , L1007;
L1014: [ D479 , D480 ] in ( P#1 R18 ) by L1013 , L426;
thus L1015: R13 in ( D476 . D479 ) by L1014 , L959;
end;
thus L1016: ( D476 . D478 ) c= ( D476 . D479 ) by L1008 , TARSKI:def 3;
end;
thus L1017: thesis by L1006 , L72;
end;
end;
theorem
L1019: (for R16 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (for R64 being R18 -sequents-like set holds ({ R16 } is (R64 , R53)-derivable implies (ex R5 being (Element of ( NAT )) st R16 is (R5 , R64 , R53)-derivable))))))
proof
let R16 being set;
let R18 being Language;
let R53 being (RuleSet of R18);
let R64 being R18 -sequents-like set;
set D481 = ( R18 -sequents );
reconsider D482 = R64 as (Element of ( bool D481 )) by L25;
L1020: ({ R16 } is (D482 , R53)-derivable implies (ex R5 being (Element of ( NAT )) st R16 is (R5 , D482 , R53)-derivable)) by L194;
thus L1021: thesis by L1020;
end;
registration
let R18 being Language;
let R53 being (RuleSet of R18);
let R10 being set;
cluster (R10 , R53)-derivable -> R18 -sequents-like for set;
coherence
proof
set D483 = ( R18 -sequents );
set D484 = ( OneStep R53 );
set D485 = { ( ( (R5 , R53) -derivables ) . R10 ) where R5 is (Element of ( NAT )) : (not contradiction) };
let C206 being set;
assume L1022: C206 is (R10 , R53)-derivable;
L1023: C206 c= ( union ( ( D484 [*] ) .: { R10 } ) ) by L1022 , L61;
L1024: C206 c= ( union D485 ) by L1023 , L223;
L1025:
now
let R13 being set;
assume L1026: R13 in C206;
consider R11 being set such that L1027: (R13 in R11 & R11 in D485) by L1026 , L1024 , TARSKI:def 4;
consider R5 being (Element of ( NAT )) such that L1028: (R11 = ( ( (R5 , R53) -derivables ) . R10 ) & (not contradiction)) by L1027;
L1029: R13 is (R5 , R10 , R53)-derivable by L63 , L1027 , L1028;
thus L1030: R13 in D483 by L1029 , L23;
end;
L1031: C206 c= D483 by L1025 , TARSKI:def 3;
thus L1032: thesis by L1031;
end;
end;
definition
let R18 being Language;
let R53 being (RuleSet of R18);
let R10 being set;
let R13 being set;
redefine attr R13 is R10 , R53 -provable
means
:L1034: (ex B220 being set st (ex R2 being Nat st (B220 c= R10 & [ B220 , R13 ] is (R2 , ( {} ) , R53)-derivable)));
compatibility
proof
set D486 = ( AllFormulasOf R18 );
set D487 = ( R18 -sequents );
defpred S30[  ] means (ex B221 being set st (ex R2 being Nat st (B221 c= R10 & [ B221 , R13 ] is (R2 , ( {} ) , R53)-derivable)));
L1035: ( ( {} ) /\ R18 ) is R18 -sequents-like;
reconsider D488 = ( {} ) as (Element of ( bool D487 )) by L1035 , L25;
thus L1036: (R13 is (R10 , R53)-provable implies S30[  ])
proof
assume L1037: R13 is (R10 , R53)-provable;
consider C207 being set such that L1038: (( C207 `1 ) c= R10 & ( C207 `2 ) = R13 & { C207 } is R53 -derivable) by L1037 , L102;
L1039: (( C207 `1 ) c= R10 & ( C207 `2 ) = R13 & { C207 } is (( {} ) , R53)-derivable) by L1038;
L1040: ({ C207 } c= D487 & C207 in { C207 }) by L1039 , L25 , TARSKI:def 1;
L1041: C207 in D487 by L1040;
consider C208 being (Subset of D486), C209 being  wff (string of R18) such that L1042: (C207 = [ C208 , C209 ] & C208 is  finite) by L1041;
consider R5 being (Element of ( NAT )) such that L1043: C207 is (R5 , D488 , R53)-derivable by L1039 , L194;
take D489 = ( C207 `1 );
take D490 = R5;
L1044: (D489 = C208 & ( C207 `2 ) = C209) by L1042 , MCART_1:7;
thus L1045: thesis by L1044 , L1038 , L1043 , L1042;
end;

assume L1046: S30[  ];
consider C210 being set, R2 being Nat such that L1047: (C210 c= R10 & [ C210 , R13 ] is (R2 , ( {} ) , R53)-derivable) by L1046;
L1048:
now
take D491 = [ C210 , R13 ];
L1049: (( D491 `1 ) c= R10 & ( D491 `2 ) = R13 & { D491 } is (( {} ) , R53)-derivable) by L1047 , L260 , MCART_1:7;
thus L1050: (( D491 `1 ) c= R10 & ( D491 `2 ) = R13 & { D491 } is R53 -derivable) by L1049;
end;
thus L1051: thesis by L1048 , L100;
end;
end;
theorem
L1053: (for R2 being Nat holds (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R54 being (RuleSet of R18) holds (for R55 being (RuleSet of R18) holds ((R54 c= R55 & (R55 is  isotone or R54 is  isotone) & R13 is (R2 , R10 , R54)-derivable) implies R13 is (R2 , R10 , R55)-derivable)))))))
proof
let R2 being Nat;
let R10 being set;
let R13 being set;
let R18 being Language;
let R54 being (RuleSet of R18);
let R55 being (RuleSet of R18);
set D492 = ( (R2 , R54) -derivables );
set D493 = ( (R2 , R55) -derivables );
assume L1054: (R54 c= R55 & (R55 is  isotone or R54 is  isotone));
L1055: ( D492 . R10 ) c= ( D493 . R10 ) by L1054 , L314;
assume L1056: R13 is (R2 , R10 , R54)-derivable;
L1057: R13 in ( D492 . R10 ) by L1056 , L63;
thus L1058: thesis by L1057 , L63 , L1055;
end;
registration
let R18 being Language;
cluster ( R#7 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D494 = ( R#7 R18 );
set D495 = ( R18 -sequents );
L1059:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D496 = R58;
set D497 = R60;
assume L1060: D496 c= D497;
L1061:
now
let R13 being set;
assume L1062: R13 in ( D494 . D496 );
reconsider D498 = R13 as (Element of D495) by L1062;
L1063: [ D496 , D498 ] in ( P#7 R18 ) by L1062 , L537;
L1064: D498 Rule7 D496 by L1063 , L480;
consider C211 being set, C212 , C213 being  wff (string of R18) such that L1065: (C211 in R58 & ( C211 `1 ) = ( D498 `1 ) & ( C211 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C212 ) ^ C213 ) & ( D498 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C213 ) ^ C212 )) by L1064 , L416;
L1066: D498 Rule7 D497 by L416 , L1065 , L1060;
L1067: [ D497 , D498 ] in ( P#7 R18 ) by L1066 , L480;
thus L1068: R13 in ( D494 . D497 ) by L1067 , L959;
end;
thus L1069: ( D494 . D496 ) c= ( D494 . D497 ) by L1061 , TARSKI:def 3;
end;
thus L1070: thesis by L1059 , L72;
end;
end;
theorem
L1072: (for R10 being set holds (for R13 being set holds (for R18 being Language holds (for R53 being (RuleSet of R18) holds (R13 is (R10 , R53)-provable implies R13 is  wff  wff  wff  wff (string of R18)))))) by L388;
registration
let R18 being Language;
let R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18);
let C214 being R77 -expanded set;
cluster ( (R18 , C214) -freeInterpreter ) -> ( (C214 , R77) -termEq ) -respecting for (R18 , ( AllTermsOf R18 ))-interpreter-like (R18 , ( AllTermsOf R18 ))-interpreter-like (R18 , ( AllTermsOf R18 ))-interpreter-like (R18 , ( AllTermsOf R18 ))-interpreter-like Function;
coherence
proof
set D499 = ( AllTermsOf R18 );
set D500 = ( (C214 , R77) -termEq );
set D501 = ( (R18 , C214) -freeInterpreter );
L1073:
now
let C215 being  own (Element of R18);
L1074: ( D501 . C215 ) = ( C214 -freeInterpreter C215 ) by FOMODEL3:def 4;
thus L1075: ( D501 . C215 ) is D500 -respecting by L1074;
end;
thus L1076: thesis by L1073 , FOMODEL3:def 16;
end;
end;
definition
let R18 being Language;
let C216 being ( 0 ) -ranked (RuleSet of R18);
let C217 being C216 -expanded set;
func C216 Henkin C217 -> Function equals 
( ( (R18 , C217) -freeInterpreter ) quotient ( (C217 , C216) -termEq ) );
coherence;
end;
registration
let R18 being Language;
let C218 being ( 0 ) -ranked (RuleSet of R18);
let C219 being C218 -expanded set;
cluster ( C218 Henkin C219 ) -> ( OwnSymbolsOf R18 ) -defined;
coherence;
end;
registration
let R18 being Language;
let R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18);
let C220 being R77 -expanded set;
cluster ( R77 Henkin C220 ) -> (R18 , ( Class ( (C220 , R77) -termEq ) ))-interpreter-like for Function;
coherence;
end;
definition
let R18 being Language;
let R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18);
let C221 being R77 -expanded set;
redefine func R77 Henkin C221 -> (Element of ( ( Class ( (C221 , R77) -termEq ) ) -InterpretersOf R18 ));

coherence
proof
set D502 = ( AllTermsOf R18 );
set D503 = ( (C221 , R77) -termEq );
set D504 = ( (R18 , C221) -freeInterpreter );
L1081: ( D504 quotient D503 ) is (Element of ( ( Class D503 ) -InterpretersOf R18 ));
thus L1082: thesis by L1081;
end;
end;
registration
let R18 being Language;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) -> ({ ( xnot R32 ) , ( xnot R33 ) } , ( { ( R#0 R18 ) } \/ { ( R#6 R18 ) } ))-provable for set;
coherence
proof
set D505 = ( TheNorSymbOf R18 );
set D506 = ( ( <* D505 *> ^ R32 ) ^ R33 );
set D507 = ( xnot R32 );
set D508 = ( xnot R33 );
set D509 = { D507 , D508 };
set D510 = [ D509 , D506 ];
set D511 = [ D509 , D507 ];
set D512 = [ D509 , D508 ];
L1084: ( ( {} ) /\ R18 ) is R18 -sequents-like;
reconsider D513 = ( {} ) as R18 -sequents-like set by L1084;
L1085: D510 is (( 1 + 1 ) , ( D513 \/ D513 ) , ( ( { ( R#0 R18 ) } \/ { ( R#0 R18 ) } ) \/ { ( R#6 R18 ) } ))-derivable by L924;
L1086: { D510 } is (( {} ) , ( { ( R#0 R18 ) } \/ { ( R#6 R18 ) } ))-derivable by L1085 , L260;
thus L1087: thesis by L1086 , L100;
end;
end;
registration
let R18 being Language;
cluster  -> non  empty for ( 0 ) -ranked ( 0 ) -ranked ( 0 ) -ranked ( 0 ) -ranked (RuleSet of R18);
coherence by L870;
end;
definition
let R18 being Language;
let R13 being set;
attr R13 is R18 -premises-like
means
:L1090: (R13 c= ( AllFormulasOf R18 ) & R13 is  finite);
end;
registration
let R18 being Language;
cluster R18 -premises-like ->  finite for set;
coherence by L1090;
end;
registration
let R18 being Language;
let R31 being  wff (string of R18);
cluster { R31 } -> R18 -premises-like for set;
coherence
proof
set D514 = ( AllFormulasOf R18 );
L1093: R31 in D514 by FOMODEL2:16;
L1094: ({ R31 } c= D514 & { R31 } is  finite) by L1093 , ZFMISC_1:31;
thus L1095: thesis by L1094 , L1090;
end;
end;
registration
let R18 being Language;
let C222 being  empty set;
cluster ( C222 null R18 ) -> R18 -premises-like for set;
coherence
proof
set D515 = ( AllFormulasOf R18 );
L1097: ( C222 /\ D515 ) = C222;
thus L1098: thesis by L1097 , L1090;
end;
end;
registration
let R10 being set;
let R18 being Language;
cluster R18 -premises-like for (Subset of R10);
existence
proof
L1100: ( ( {} ) /\ R10 ) = ( {} );
reconsider D516 = ( ( {} ) null R18 ) as (Subset of R10) by L1100;
take D516;
thus L1101: thesis;
end;
end;
registration
let R18 being Language;
cluster R18 -premises-like for set;
existence
proof
take the R18 -premises-like (Subset of R18);
thus L1103: thesis;
end;
end;
registration
let R18 being Language;
let C223 being R18 -premises-like set;
cluster  -> R18 -premises-like for (Subset of C223);
coherence
proof
set D517 = ( AllFormulasOf R18 );
reconsider D518 = C223 as  finite (Subset of D517) by L1090;
let C224 being (Subset of C223);
L1105: C224 is (Subset of D518);
L1106: C224 is  finite  finite  finite  finite (Subset of D517) by L1105 , XBOOLE_1:1;
thus L1107: thesis by L1106 , L1090;
end;
end;
definition
let R18 being Language;
let R81 being R18 -premises-like set;
let R80 being R18 -premises-like set;
redefine func R80 null R81 -> (Subset of ( AllFormulasOf R18 ));

coherence by L1090;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R13 being set;
cluster ( R79 null R13 ) -> R18 -premises-like;
coherence;
end;
registration
let R18 being Language;
let R80 being R18 -premises-like set;
let R81 being R18 -premises-like set;
cluster ( R80 \/ R81 ) -> R18 -premises-like for set;
coherence
proof
set D519 = ( AllFormulasOf R18 );
L1111: ( ( R80 null R80 ) \/ ( R81 null R81 ) ) c= D519;
thus L1112: thesis by L1111 , L1090;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R31 being  wff (string of R18);
cluster [ R79 , R31 ] -> R18 -sequent-like;
coherence
proof
set D520 = ( AllFormulasOf R18 );
reconsider D521 = R79 as  finite (Subset of D520) by L1090;
L1114: [ D521 , R31 ] is R18 -sequent-like;
thus L1115: thesis by L1114;
end;
end;
registration
let R18 being Language;
let R80 being R18 -premises-like set;
let R81 being R18 -premises-like set;
let R31 being  wff (string of R18);
cluster [ ( R80 \/ R81 ) , R31 ] -> (1 , { [ R80 , R31 ] } , { ( R#1 R18 ) })-derivable for set;
coherence
proof
set D522 = [ R80 , R31 ];
set D523 = { D522 };
set D524 = ( R80 \/ R81 );
set D525 = [ D524 , R31 ];
set D526 = ( R18 -sequents );
reconsider D527 = D525 as (Element of D526) by L23;
reconsider D528 = D523 as (Element of ( bool D526 )) by L25;
L1117: (( R80 null R81 ) c= D524 & ( { D522 } \ D523 ) = ( {} ) & ( ( D522 `1 ) \+\ R80 ) = ( {} ) & ( ( D525 `1 ) \+\ D524 ) = ( {} ) & ( ( D525 `2 ) \+\ R31 ) = ( {} ) & ( ( D522 `2 ) \+\ R31 ) = ( {} ));
L1118: (R80 c= D524 & D522 in D523 & ( D522 `1 ) = R80 & ( D525 `1 ) = D524 & ( D525 `2 ) = R31 & ( D522 `2 ) = R31) by L1117 , ZFMISC_1:60;
L1119: D527 Rule1 D528 by L1118 , L407;
L1120: [ D528 , D527 ] in ( P#1 R18 ) by L1119 , L426;
L1121: D525 in ( ( R#1 R18 ) . D523 ) by L1120 , L959;
thus L1122: thesis by L1121 , L943;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R31 being  wff (string of R18);
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster [ ( R79 null ( R32 ^ R33 ) ) , ( xnot R31 ) ] -> (1 , { [ ( R79 \/ { R31 } ) , R32 ] , [ ( R79 \/ { R31 } ) , ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) ] } , { ( R#8 R18 ) })-derivable for set;
coherence
proof
set D529 = ( TheNorSymbOf R18 );
set D530 = ( R79 \/ { R31 } );
set D531 = ( ( <* D529 *> ^ R32 ) ^ R33 );
set D532 = [ D530 , R32 ];
set D533 = [ D530 , D531 ];
set D534 = { D532 , D533 };
set D535 = [ R79 , ( xnot R31 ) ];
set D536 = ( R18 -sequents );
reconsider D537 = D535 as (Element of D536) by L23;
reconsider D538 = D534 as (Element of ( bool D536 )) by L25;
L1124: (( { D532 } \ D534 ) = ( {} ) & ( { D533 } \ D534 ) = ( {} ) & ( ( D532 `1 ) \+\ D530 ) = ( {} ) & ( ( D533 `1 ) \+\ D530 ) = ( {} ) & ( ( D532 `2 ) \+\ R32 ) = ( {} ) & ( ( D533 `2 ) \+\ D531 ) = ( {} ) & ( ( D535 `1 ) \+\ R79 ) = ( {} ) & ( ( D535 `2 ) \+\ ( xnot R31 ) ) = ( {} ));
L1125: (D532 in D534 & D533 in D534 & ( D532 `1 ) = D530 & ( D533 `1 ) = D530 & ( D532 `2 ) = R32 & ( D533 `2 ) = D531 & ( D535 `1 ) = R79 & ( D535 `2 ) = ( xnot R31 )) by L1124 , ZFMISC_1:60;
L1126: D537 Rule8 D538 by L1125 , L417;
L1127: [ D538 , D537 ] in ( P#8 R18 ) by L1126 , L486;
L1128: D535 in ( ( R#8 R18 ) . D534 ) by L1127 , L959;
thus L1129: thesis by L1128 , L943;
end;
end;
registration
let R18 being Language;
cluster ( ( {} ) null R18 ) -> R18 -sequents-like for set;
coherence
proof
L1131: ( ( {} ) null R18 ) = ( ( {} ) /\ R18 );
thus L1132: thesis by L1131;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R31 being  wff (string of R18);
cluster [ ( R79 \/ { R31 } ) , R31 ] -> (1 , ( {} ) , { ( R#0 R18 ) })-derivable for set;
coherence
proof
set D539 = ( R79 \/ { R31 } );
set D540 = [ D539 , R31 ];
set D541 = ( ( {} ) null R18 );
set D542 = ( R18 -sequents );
reconsider D543 = D540 as (Element of D542) by L23;
reconsider D544 = D541 as (Element of ( bool D542 )) by L25;
L1134: (( ( D540 `2 ) \+\ R31 ) = ( {} ) & ( ( D540 `1 ) \+\ D539 ) = ( {} ) & ( ( { R31 } null R79 ) \ D539 ) = ( {} ));
L1135: (( D540 `2 ) = R31 & ( D540 `1 ) = D539 & R31 in D539) by L1134 , ZFMISC_1:60;
L1136: D543 Rule0 D544 by L1135 , L406;
L1137: [ D544 , D543 ] in ( P#0 R18 ) by L1136 , L420;
L1138: D540 in ( ( R#0 R18 ) . D541 ) by L1137 , L959;
thus L1139: thesis by L1138 , L943;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster [ ( R79 null R33 ) , ( xnot R32 ) ] -> (2 , { [ R79 , ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) ] } , ( ( { ( R#0 R18 ) } \/ { ( R#1 R18 ) } ) \/ { ( R#8 R18 ) } ))-derivable for set;
coherence
proof
set D545 = ( TheNorSymbOf R18 );
set D546 = ( xnot R32 );
set D547 = ( ( <* D545 *> ^ R32 ) ^ R33 );
set D548 = [ R79 , D547 ];
set D549 = [ ( R79 \/ { R32 } ) , D547 ];
set D550 = [ ( R79 \/ { R32 } ) , R32 ];
set D551 = ( ( {} ) null R18 );
set D552 = [ ( R79 null ( R32 ^ R33 ) ) , ( xnot R32 ) ];
L1141: D552 is (( 1 + 1 ) , ( D551 \/ { D548 } ) , ( ( { ( R#0 R18 ) } \/ { ( R#1 R18 ) } ) \/ { ( R#8 R18 ) } ))-derivable by L924;
thus L1142: thesis by L1141;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster [ R79 , ( ( <* ( TheNorSymbOf R18 ) *> ^ R33 ) ^ R32 ) ] -> (1 , { [ R79 , ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) ] } , { ( R#7 R18 ) })-derivable for set;
coherence
proof
set D553 = ( TheNorSymbOf R18 );
set D554 = ( ( <* D553 *> ^ R32 ) ^ R33 );
set D555 = ( ( <* D553 *> ^ R33 ) ^ R32 );
set D556 = [ R79 , D555 ];
set D557 = [ R79 , D554 ];
set D558 = { D557 };
set D559 = ( R18 -sequents );
reconsider D560 = D556 as (Element of D559) by L23;
reconsider D561 = D558 as (Element of ( bool D559 )) by L25;
L1144: (( { D557 } \ D558 ) = ( {} ) & ( ( D557 `1 ) \+\ R79 ) = ( {} ) & ( ( D556 `1 ) \+\ R79 ) = ( {} ) & ( ( D557 `2 ) \+\ D554 ) = ( {} ) & ( ( D556 `2 ) \+\ D555 ) = ( {} ));
L1145: (D557 in D558 & ( D557 `1 ) = R79 & ( D556 `1 ) = R79 & ( D557 `2 ) = D554 & ( D556 `2 ) = D555) by L1144 , ZFMISC_1:60;
L1146: D560 Rule7 D561 by L1145 , L416;
L1147: [ D561 , D560 ] in ( P#7 R18 ) by L1146 , L480;
L1148: D556 in ( ( R#7 R18 ) . D558 ) by L1147 , L959;
thus L1149: thesis by L1148 , L943;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
cluster [ ( R79 null R32 ) , ( xnot R33 ) ] -> (3 , { [ R79 , ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) ] } , ( ( ( { ( R#0 R18 ) } \/ { ( R#1 R18 ) } ) \/ { ( R#8 R18 ) } ) \/ { ( R#7 R18 ) } ))-derivable for set;
coherence
proof
set D562 = ( TheNorSymbOf R18 );
set D563 = ( ( <* D562 *> ^ R33 ) ^ R32 );
set D564 = [ R79 , D563 ];
set D565 = { ( R#7 R18 ) };
set D566 = D565;
set D567 = ( ( { ( R#0 R18 ) } \/ { ( R#1 R18 ) } ) \/ { ( R#8 R18 ) } );
set D568 = [ ( R79 null R32 ) , ( xnot R33 ) ];
set D569 = { [ R79 , ( ( <* D562 *> ^ R32 ) ^ R33 ) ] };
set D570 = D569;
L1151: (( D565 \/ D566 ) is  isotone & ( ( D565 \/ D566 ) \/ D567 ) is  isotone & { D564 , D564 } = ( { D564 } \/ { D564 } )) by ENUMSET1:1;
L1152: D568 is (( 1 + 2 ) , ( D569 \/ D570 ) , ( ( D565 \/ D566 ) \/ D567 ))-derivable by L1151 , L924;
thus L1153: thesis by L1152;
end;
end;
registration
let R18 being Language;
let R67 being R18 -sequent-like set;
cluster ( R67 `1 ) -> R18 -premises-like for set;
coherence
proof
set D571 = ( AllFormulasOf R18 );
set D572 = ( R18 -sequents );
L1155: R67 in D572 by L23;
consider C225 being (Subset of D571), C226 being  wff (string of R18) such that L1156: (R67 = [ C225 , C226 ] & C225 is  finite) by L1155;
L1157: ( R67 `1 ) = C225 by L1156 , MCART_1:7;
thus L1158: thesis by L1157 , L1156 , L1090;
end;
end;
definition
let R18 being Language;
let R10 being set;
let R74 being (RuleSet of R18);
redefine func R74 null R10 -> (RuleSet of R18);

coherence;
end;
registration
let R18 being Language;
let R32 being  wff (string of R18);
let R33 being  wff (string of R18);
let R46 being  literal (Element of R18);
let R79 being R18 -premises-like set;
let C227 being ( ( R79 \/ { R32 } ) \/ { R33 } ) -absent  literal (Element of R18);
cluster [ ( ( R79 \/ { ( <* R46 *> ^ R32 ) } ) null C227 ) , R33 ] -> (1 , { [ ( R79 \/ { ( (R46 , C227) -SymbolSubstIn R32 ) } ) , R33 ] } , { ( R#5 R18 ) })-derivable for set;
coherence
proof
reconsider D573 = ( (R46 , C227) -SymbolSubstIn R32 ) as  wff (string of R18);
set D574 = ( R79 \/ { D573 } );
set D575 = [ D574 , R33 ];
set D576 = ( R79 \/ { ( <* R46 *> ^ R32 ) } );
set D577 = [ D576 , R33 ];
set D578 = ( R#5 R18 );
set D579 = ( R18 -sequents );
set D580 = R79;
set D581 = ( AllSymbolsOf R18 );
set D582 = { D575 };
set D583 = ( R46 SubstWith C227 );
reconsider D584 = R32 as D581 -valued FinSequence;
reconsider D585 = D577 as (Element of D579) by L23;
reconsider D586 = D582 as (Element of ( bool D579 )) by L25;
L1161: (( ( D585 `1 ) \+\ D576 ) = ( {} ) & ( ( D585 `2 ) \+\ R33 ) = ( {} ));
L1162: (( D585 `1 ) = D576 & ( D585 `2 ) = R33) by L1161 , FOMODEL0:29;
L1163: ( D580 \/ { ( D583 . D584 ) } ) = D574 by FOMODEL0:def 23;
L1164: [ ( D580 \/ { ( D583 . D584 ) } ) , ( D585 `2 ) ] in D586 by L1163 , L1162 , TARSKI:def 1;
L1165: D585 Rule5 D586 by L1164 , L1162 , L414;
L1166: [ D586 , D585 ] in ( P#5 R18 ) by L1165 , L468;
L1167: D585 in ( ( R#5 R18 ) . D586 ) by L1166 , L959;
thus L1168: thesis by L1167 , L943;
end;
end;
definition
let R18 being Language;
let R74 being (RuleSet of R18);
let R10 being set;
attr R10 is R74 -inconsistent
means
:L1170: (ex R32 being  wff (string of R18) st (ex R33 being  wff (string of R18) st (R32 is (R10 , R74)-provable & ( ( <* ( TheNorSymbOf R18 ) *> ^ R32 ) ^ R33 ) is (R10 , R74)-provable)));
end;
registration
let R49 being non  zero Nat;
let R18 being Language;
let R80 being R18 -premises-like set;
let R81 being R18 -premises-like set;
let R31 being  wff (string of R18);
cluster [ ( ( R80 \/ R81 ) null R49 ) , R31 ] -> (R49 , { [ R80 , R31 ] } , { ( R#1 R18 ) })-derivable for set;
coherence
proof
set D587 = ( R80 \/ R81 );
set D588 = [ R80 , R31 ];
set D589 = [ D587 , R31 ];
consider R2 being Nat such that L1172: R49 = ( R2 + 1 ) by NAT_1:6;
defpred S31[ Nat ] means D589 is (( $1 + 1 ) , { D588 } , { ( R#1 R18 ) })-derivable;
L1173: [ ( D587 \/ D587 ) , R31 ] is (1 , { D589 } , { ( R#1 R18 ) })-derivable;
L1174: S31[ ( 0 ) ];
L1175: (for R3 being Nat holds (S31[ R3 ] implies S31[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
assume L1176: S31[ R3 ];
L1177: D589 is (( ( R3 + 1 ) + 1 ) , { D588 } , ( { ( R#1 R18 ) } \/ { ( R#1 R18 ) } ))-derivable by L1176 , L363 , L1173;
thus L1178: thesis by L1177;
end;
L1179: (for R3 being Nat holds S31[ R3 ]) from NAT_1:sch 2(L1174 , L1175);
thus L1180: thesis by L1179 , L1172;
end;
end;
registration
let R18 being Language;
cluster non  empty for  isotone  isotone  isotone  isotone (RuleSet of R18);
existence
proof
take { ( R#0 R18 ) };
thus L1182: thesis;
end;
end;
theorem
L1184: (for R10 being set holds (for R18 being Language holds (for R31 being  wff (string of R18) holds (for R74 being (RuleSet of R18) holds ((R10 is R74 -inconsistent & R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74) implies ( xnot R31 ) is (R10 , R74)-provable)))))
proof
let R10 being set;
let R18 being Language;
let R31 being  wff (string of R18);
let R74 being (RuleSet of R18);
set D590 = ( TheNorSymbOf R18 );
assume L1185: R10 is R74 -inconsistent;
consider R32 being  wff (string of R18), R33 being  wff (string of R18) such that L1186: (R32 is (R10 , R74)-provable & ( ( <* D590 *> ^ R32 ) ^ R33 ) is (R10 , R74)-provable) by L1185 , L1170;
reconsider D591 = ( ( <* D590 *> ^ R32 ) ^ R33 ) as  wff (string of R18);
consider C228 being set, R2 being Nat such that L1187: (C228 c= R10 & [ C228 , R32 ] is (R2 , ( {} ) , R74)-derivable) by L1186 , L1034;
consider C229 being set, R3 being Nat such that L1188: (C229 c= R10 & [ C229 , D591 ] is (R3 , ( {} ) , R74)-derivable) by L1186 , L1034;
reconsider D592 = C228 , D593 = C229 as (Subset of R10) by L1187 , L1188;
reconsider D594 = [ C228 , R32 ] , D595 = [ C229 , D591 ] as R18 -sequent-like set by L1187 , L1188;
L1189: (C228 = ( D594 `1 ) & C229 = ( D595 `1 )) by MCART_1:7;
reconsider D596 = C228 , D597 = C229 as R18 -premises-like set by L1189;
reconsider D598 = ( ( D596 \/ D597 ) \/ { R31 } ) as R18 -premises-like set;
assume L1190: (R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74);
reconsider D599 = R74 as non  empty  isotone (RuleSet of R18) by L1190;
reconsider D600 = ( R#1 R18 ) , D601 = ( R#8 R18 ) as (Element of D599) by L1190;
L1191: (( D599 \/ { D600 } ) = ( D599 null D600 ) & ( D599 \/ { D601 } ) = ( D599 null D601 ) & ( R74 \/ R74 ) is  isotone & ( ( R74 \/ R74 ) \/ { ( R#8 R18 ) } ) is  isotone & R74 is non  empty & ( D592 \/ D593 ) c= R10) by L1190;
L1192: ([ ( ( D598 \/ D598 ) null ( R3 + 1 ) ) , R32 ] is (( R3 + 1 ) , { [ D598 , R32 ] } , { ( R#1 R18 ) })-derivable & [ ( ( D598 \/ D598 ) null ( R2 + 1 ) ) , D591 ] is (( R2 + 1 ) , { [ D598 , D591 ] } , { ( R#1 R18 ) })-derivable);
L1193: [ ( D596 \/ ( D597 \/ { R31 } ) ) , R32 ] is (( R2 + 1 ) , ( {} ) , ( R74 \/ { ( R#1 R18 ) } ))-derivable by L363 , L1187 , L1190;
L1194: [ D598 , R32 ] is (( R2 + 1 ) , ( {} ) , R74)-derivable by L1193 , L1191 , XBOOLE_1:4;
L1195: [ D598 , R32 ] is (( ( R2 + 1 ) + ( R3 + 1 ) ) , ( {} ) , R74)-derivable by L1194 , L1192 , L1191 , L363;
L1196: [ ( D597 \/ ( D596 \/ { R31 } ) ) , D591 ] is (( R3 + 1 ) , ( {} ) , ( R74 \/ { ( R#1 R18 ) } ))-derivable by L363 , L1188 , L1190;
L1197: [ D598 , D591 ] is (( R3 + 1 ) , ( {} ) , R74)-derivable by L1196 , L1191 , XBOOLE_1:4;
L1198: [ D598 , D591 ] is (( ( R3 + 1 ) + ( R2 + 1 ) ) , ( {} ) , R74)-derivable by L1197 , L1192 , L363 , L1191;
L1199: [ ( ( D597 \/ D596 ) null ( R32 ^ R33 ) ) , ( xnot R31 ) ] is (1 , { [ D598 , R32 ] , [ D598 , D591 ] } , { ( R#8 R18 ) })-derivable;
L1200: [ ( D597 \/ D596 ) , ( xnot R31 ) ] is (( ( ( R2 + R3 ) + 2 ) + 1 ) , ( ( ( {} ) null R18 ) \/ ( ( {} ) null R18 ) ) , ( ( R74 \/ R74 ) \/ { ( R#8 R18 ) } ))-derivable by L1199 , L924 , L1195 , L1198 , L1190;
thus L1201: thesis by L1200 , L1191 , L1034;
end;
registration
let R18 being Language;
cluster ( R#5 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D602 = ( R#5 R18 );
set D603 = ( R18 -sequents );
L1202:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D604 = R58;
set D605 = R60;
assume L1203: D604 c= D605;
L1204:
now
let R13 being set;
assume L1205: R13 in ( D602 . D604 );
reconsider D606 = R13 as (Element of D603) by L1205;
L1206: [ D604 , D606 ] in ( P#5 R18 ) by L1205 , L537;
L1207: D606 Rule5 D604 by L1206 , L468;
consider C230 , C231 being  literal (Element of R18), R17 being set, R48 being FinSequence such that L1208: (( D606 `1 ) = ( R17 \/ { ( <* C230 *> ^ R48 ) } ) & C231 is ( ( R17 \/ { R48 } ) \/ { ( D606 `2 ) } ) -absent & [ ( R17 \/ { ( ( C230 SubstWith C231 ) . R48 ) } ) , ( D606 `2 ) ] in D604) by L1207 , L414;
L1209: D606 Rule5 D605 by L414 , L1203 , L1208;
L1210: [ D605 , D606 ] in ( P#5 R18 ) by L1209 , L468;
thus L1211: R13 in ( D602 . D605 ) by L1210 , L959;
end;
thus L1212: ( D602 . D604 ) c= ( D602 . D605 ) by L1204 , TARSKI:def 3;
end;
thus L1213: thesis by L1202 , L72;
end;
end;
registration
let R18 being Language;
let R45 being  literal (Element of R18);
let R40 being  termal (string of R18);
let R31 being  wff (string of R18);
cluster [ { ( (R45 , R40) SubstIn R31 ) } , ( <* R45 *> ^ R31 ) ] -> (1 , ( {} ) , { ( R#4 R18 ) })-derivable for set;
coherence
proof
set D607 = ( R18 -sequents );
set D608 = ( (R45 , R40) SubstIn R31 );
reconsider D609 = [ { D608 } , ( <* R45 *> ^ R31 ) ] as R18 -sequent-like set;
reconsider D610 = ( ( {} ) null R18 ) as R18 -sequents-like set;
reconsider D611 = D609 as (Element of D607) by L23;
reconsider D612 = D610 as (Element of ( bool D607 )) by L25;
L1215: (( ( D611 `1 ) \+\ { D608 } ) = ( {} ) & ( ( D611 `2 ) \+\ ( <* R45 *> ^ R31 ) ) = ( {} ));
L1216: (D612 = ( {} ) & ( D611 `1 ) = { D608 } & ( D611 `2 ) = ( <* R45 *> ^ R31 )) by L1215 , FOMODEL0:29;
L1217: D611 Rule4 D612 by L1216 , L413;
L1218: [ D612 , D611 ] in ( P#4 R18 ) by L1217 , L462;
L1219: D609 in ( ( R#4 R18 ) . D610 ) by L1218 , L959;
thus L1220: thesis by L1219 , L943;
end;
end;
registration
let R18 being Language;
cluster ( R#4 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D613 = ( R#4 R18 );
set D614 = ( R18 -sequents );
L1222:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D615 = R58;
set D616 = R60;
assume L1223: D615 c= D616;
L1224:
now
let R13 being set;
assume L1225: R13 in ( D613 . D615 );
reconsider D617 = R13 as (Element of D614) by L1225;
L1226: [ D615 , D617 ] in ( P#4 R18 ) by L1225 , L537;
L1227: D617 Rule4 D615 by L1226 , L462;
consider C232 being  literal (Element of R18), C233 being  wff (string of R18), C234 being  termal (string of R18) such that L1228: (( D617 `1 ) = { ( (C232 , C234) SubstIn C233 ) } & ( D617 `2 ) = ( <* C232 *> ^ C233 )) by L1227 , L413;
L1229: D617 Rule4 D616 by L1228 , L413;
L1230: [ D616 , D617 ] in ( P#4 R18 ) by L1229 , L462;
thus L1231: R13 in ( D613 . D616 ) by L1230 , L959;
end;
thus L1232: ( D613 . D615 ) c= ( D613 . D616 ) by L1224 , TARSKI:def 3;
end;
thus L1233: thesis by L1222 , L72;
end;
end;
L1235: (for R18 being Language holds (for R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18) holds (for B222 being R77 -expanded set holds (for B223 being  0wff (string of R18) holds (( ( R77 Henkin B222 ) -AtomicEval B223 ) = 1 iff B223 in B222)))))
proof
let R18 being Language;
let R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18);
let C235 being R77 -expanded set;
let C236 being  0wff (string of R18);
L1236: ( R#0 R18 ) in R77 by L870;
L1237: { ( R#0 R18 ) } c= R77 by L1236 , ZFMISC_1:31;
set D618 = ( AllTermsOf R18 );
set D619 = ( TheEqSymbOf R18 );
set D620 = ( SubTerms C236 );
set D621 = ( R18 -firstChar );
set D622 = ( D621 . C236 );
set D623 = ( abs ( ar D622 ) );
set D624 = ( (C235 , R77) -termEq );
set D625 = ( Class D624 );
set D626 = ( AtomicFormulasOf R18 );
set D627 = ( D625 -deltaInterpreter );
set D628 = ( (R18 , C235) -freeInterpreter );
L1238: ( ( abs ( ar D619 ) ) - 2 ) = ( 0 );
reconsider D629 = ( R77 Henkin C235 ) as (Element of ( D625 -InterpretersOf R18 ));
set D630 = ( D629 -TermEval );
set D631 = ( D629 -AtomicEval C236 );
set D632 = ( D628 -TermEval );
set D633 = ( D628 -AtomicEval C236 );
set D634 = ( ( D629 === ) . D622 );
set D635 = ( D629 . D622 );
set D636 = ( D628 . D622 );
set D637 = ( OwnSymbolsOf R18 );
set D638 = ( AllFormulasOf R18 );
set D639 = ( R18 -multiCat );
set D640 = ( AllSymbolsOf R18 );
reconsider D641 = D620 as (Element of ( D623 -tuples_on D618 )) by FOMODEL0:16;
L1239: D641 is (Element of ( Funcs (( Seg D623 ) , D618) )) by FOMODEL0:11;
reconsider D642 = D641 as (Function of ( Seg D623 ) , D618) by L1239;
L1240: ( 2 -tuples_on ( ( D640 * ) \ { ( {} ) } ) ) = { <* B224 , B225 *> where B224 , B225 is (Element of ( ( D640 * ) \ { ( {} ) } )) : (not contradiction) } by FINSEQ_2:99;
L1241: D620 in ( D618 * );
reconsider D643 = D620 as (Element of ( ( ( D640 * ) \ { ( {} ) } ) * )) by L1241;
L1242: C236 = ( <* D622 *> ^ ( D639 . D620 ) ) by FOMODEL1:def 38;
L1243: D630 = ( ( D624 -class ) * D632 ) by FOMODEL3:3;
L1244: D632 = ( id D618 ) by FOMODEL3:4;
L1245: (( D623 -tuples_on D618 ) c= ( D618 * ) & ( D618 * ) c= ( ( ( D640 * ) \ { ( {} ) } ) * )) by FINSEQ_2:142;
L1246: ( D623 -tuples_on D618 ) c= ( ( ( D640 * ) \ { ( {} ) } ) * ) by L1245 , XBOOLE_1:1;
reconsider D644 = ( ( D622 -compound ) | ( D623 -tuples_on D618 ) ) as (Function of ( D623 -tuples_on D618 ) , ( ( D640 * ) \ { ( {} ) } )) by L1246 , FUNCT_2:32;
per cases ;
suppose L1247: D622 = D619;

reconsider D645 = D620 as ( ( ( 0 ) + 1 ) + 1 ) -element (Element of ( D618 * )) by L1247 , L1238;
L1248: D643 in ( 2 -tuples_on ( ( D640 * ) \ { ( {} ) } ) ) by L1238 , L1247 , FOMODEL0:16;
consider C237 , C238 being (Element of ( ( D640 * ) \ { ( {} ) } )) such that L1249: (D643 = <* C237 , C238 *> & (not contradiction)) by L1248 , L1240;
L1250: ( D639 . <* C237 , C238 *> ) = ( C237 ^ C238 ) by FOMODEL0:15;
reconsider D646 = D620 as ( ( 1 + 1 ) + ( 0 ) ) -element (Element of ( D618 * )) by L1247 , L1238;
L1251: (( { ( D645 . ( ( 0 ) + 1 ) ) } \ D618 ) = ( {} ) & ( { ( D646 . ( 1 + 1 ) ) } \ D618 ) = ( {} ));
reconsider D647 = ( D620 . 1 ) , D648 = ( D620 . 2 ) as (Element of D618) by L1251 , ZFMISC_1:60;
reconsider D649 = D647 , D650 = D648 as  termal (string of R18);
L1252: (( ( D624 -class ) . D647 ) = ( EqClass (D624 , D647) ) & ( ( D624 -class ) . D648 ) = ( EqClass (D624 , D648) )) by FOMODEL3:def 13;
L1253: (D647 = C237 & D648 = C238) by L1249 , FINSEQ_1:44;
L1254: (( { ( ( id D618 ) . D647 ) } \ { D647 } ) = ( {} ) & ( { ( ( id D618 ) . D648 ) } \ { D648 } ) = ( {} ));
L1255: (( ( id D618 ) . D647 ) = D647 & ( ( id D618 ) . D648 ) = D648) by L1254 , ZFMISC_1:15;
L1256: (( ( ( ( D624 -class ) * D632 ) . D647 ) \+\ ( ( D624 -class ) . ( D632 . D647 ) ) ) = ( {} ) & ( ( ( ( D624 -class ) * D632 ) . D648 ) \+\ ( ( D624 -class ) . ( D632 . D648 ) ) ) = ( {} ));
L1257: (( ( ( D624 -class ) * D632 ) . D647 ) = ( ( D624 -class ) . ( D632 . D647 ) ) & ( ( ( D624 -class ) * D632 ) . D648 ) = ( ( D624 -class ) . ( D632 . D648 ) )) by L1256 , FOMODEL0:29;
L1258: (D631 = 1 iff ( EqClass (D624 , D647) ) = ( EqClass (D624 , D648) )) by L1257 , L1252 , L1255 , L1243 , L1247 , L1244 , FOMODEL2:15;
L1259: (D631 = 1 iff [ D647 , D648 ] in D624) by L1258 , EQREL_1:35;
L1260: ( ( <* D619 *> ^ D649 ) ^ D650 ) = C236 by L1242 , L1249 , L1250 , L1253 , L1247 , FINSEQ_1:32;
thus L1261: (( ( R77 Henkin C235 ) -AtomicEval C236 ) = 1 implies C236 in C235)
proof
assume L1262: ( ( R77 Henkin C235 ) -AtomicEval C236 ) = 1;
L1263: [ D647 , D648 ] in D624 by L1262 , L1258 , EQREL_1:35;
consider C239 , C240 being  termal (string of R18) such that L1264: ([ D647 , D648 ] = [ C239 , C240 ] & ( ( <* D619 *> ^ C239 ) ^ C240 ) is (C235 , R77)-provable) by L1263;
L1265: (C239 = D647 & C240 = D648) by L1264 , XTUPLE_0:1;
L1266: ( <* D619 *> ^ ( C239 ^ C240 ) ) = C236 by L1265 , L1242 , L1249 , L1253 , L1247 , FOMODEL0:15;
L1267: C236 is (C235 , R77)-provable by L1266 , L1264 , FINSEQ_1:32;
L1268: { C236 } c= C235 by L1267 , L116;
thus L1269: thesis by L1268 , ZFMISC_1:31;
end;

assume L1270: C236 in C235;
reconsider D651 = { C236 } as (Subset of C235) by L1270 , ZFMISC_1:31;
L1271: { [ { C236 } , C236 ] } is (( {} ) , R77)-derivable by L335 , L1237;
L1272: C236 is (D651 , R77)-provable by L1271 , L100;
thus L1273: thesis by L1272 , L1259 , L1260;
end;
suppose L1274: (not D622 = D619);

reconsider D652 = D622 as (Element of D637) by L1274 , FOMODEL1:15;
set D653 = ( D628 . D652 );
L1275: (D622 <> D619 & D631 = D633 & D633 = ( D653 . ( D632 * D620 ) )) by L1274 , FOMODEL2:14 , FOMODEL3:5;
L1276: D631 = ( D653 . ( ( id D618 ) * D642 ) ) by L1275 , FOMODEL3:4
.= ( D653 . D642 ) by FUNCT_2:17
.= ( ( C235 -freeInterpreter D652 ) . D620 ) by FOMODEL3:def 4
.= ( ( ( chi (C235 , D626) ) * ( ( D652 -compound ) | ( D623 -tuples_on D618 ) ) ) . D641 ) by FOMODEL3:def 3
.= ( ( chi (C235 , D626) ) . ( D644 . D641 ) ) by FUNCT_2:15
.= ( ( chi (C235 , D626) ) . ( ( D652 -compound ) . D641 ) ) by FUNCT_1:49
.= ( ( chi (C235 , D626) ) . ( D652 -compound D643 ) ) by FOMODEL3:def 2
.= ( ( chi (C235 , D626) ) . C236 ) by FOMODEL1:def 38;
L1277: (D631 = 1 iff C236 in ( ( chi (C235 , D626) ) " { 1 } )) by L1276 , FOMODEL0:25;
L1278: (D631 = 1 iff C236 in ( C235 /\ D626 )) by L1277 , FOMODEL0:24;
L1279: (C236 in D626 & (D631 = 1 iff (C236 in C235 & C236 in D626))) by L1278 , XBOOLE_0:def 4;
thus L1280: thesis by L1279;
end;
end;
definition
let R18 being Language;
let R10 being set;
attr R10 is R18 -witnessed
means
:L1282: (for R46 being  literal (Element of R18) holds (for R32 being  wff (string of R18) holds (( <* R46 *> ^ R32 ) in R10 implies (ex R47 being  literal (Element of R18) st (( (R46 , R47) -SymbolSubstIn R32 ) in R10 & (not R47 in ( rng R32 )))))));
end;
theorem
L1284: (for R18 being Language holds (for R28 being  wff (string of R18) holds (for R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18) holds (for B226 being R77 -expanded set holds ((( R#1 R18 ) in R77 & ( R#4 R18 ) in R77 & ( R#6 R18 ) in R77 & ( R#7 R18 ) in R77 & ( R#8 R18 ) in R77 & B226 is R18 -mincover & B226 is R18 -witnessed) implies (( ( R77 Henkin B226 ) -TruthEval R28 ) = 1 iff R28 in B226))))))
proof
let R18 being Language;
let R28 being  wff (string of R18);
let R77 being 1 -ranked ( 0 ) -ranked (RuleSet of R18);
let C241 being R77 -expanded set;
set D654 = ( AllTermsOf R18 );
set D655 = ( TheEqSymbOf R18 );
set D656 = ( R18 -firstChar );
set D657 = ( TheNorSymbOf R18 );
set D658 = ( (C241 , R77) -termEq );
set D659 = ( Class D658 );
set D660 = ( LettersOf R18 );
set D661 = ( AtomicFormulasOf R18 );
set D662 = ( D659 -deltaInterpreter );
set D663 = ( (R18 , C241) -freeInterpreter );
set D664 = ( D659 -InterpretersOf R18 );
set D665 = R77;
set D666 = ( D654 -InterpretersOf R18 );
set D667 = ( R#0 R18 );
set D668 = ( R#1 R18 );
set D669 = ( R#2 R18 );
set D670 = ( R#4 R18 );
set D671 = ( R#6 R18 );
set D672 = ( R#7 R18 );
set D673 = ( R#8 R18 );
set D674 = { D667 };
set D675 = { D668 };
set D676 = { D669 };
set D677 = { D670 };
set D678 = { D671 };
set D679 = { D672 };
set D680 = { D673 };
reconsider D681 = D674 , D682 = D675 , D683 = D676 , D684 = D677 , D685 = D678 , D686 = D679 , D687 = D680 as (RuleSet of R18);
assume L1285: (D668 in D665 & D670 in D665 & D671 in D665 & D672 in D665 & D673 in D665);
L1286: (D667 in D665 & D668 in D665 & D669 in D665 & D670 in D665 & D671 in D665 & D672 in D665 & D673 in D665) by L1285 , L870;
reconsider D688 = D681 , D689 = D682 , D690 = D683 , D691 = D684 , D692 = D685 , D693 = D686 , D694 = D687 as (Subset of D665) by L1286 , ZFMISC_1:31;
L1287: (( D688 \/ ( ( D688 \/ D689 ) \/ D694 ) ) c= D665 & ( D688 \/ D692 ) c= D665 & D688 c= D665 & ( D688 \/ ( ( ( D688 \/ D689 ) \/ D694 ) \/ D693 ) ) c= D665);
reconsider D695 = ( R77 Henkin C241 ) as (Element of D664);
set D696 = ( D695 -TermEval );
set D697 = ( D663 -TermEval );
set D698 = ( OwnSymbolsOf R18 );
set D699 = ( AllFormulasOf R18 );
set D700 = ( R18 -multiCat );
set D701 = ( AllSymbolsOf R18 );
assume L1288: (C241 is R18 -mincover & C241 is R18 -witnessed);
defpred S32[ Nat ] means (for R31 being  wff (string of R18) holds (R31 is $1 -wff implies (( D695 -TruthEval R31 ) = 1 iff R31 in C241)));
L1289: S32[ ( 0 ) ]
proof
let R31 being  wff (string of R18);
assume L1290: R31 is ( 0 ) -wff;
reconsider D702 = R31 as  0wff (string of R18) by L1290;
L1291: (( D695 -AtomicEval D702 ) = 1 iff D702 in C241) by L1235;
thus L1292: thesis by L1291;
end;
L1293: (for R3 being Nat holds (S32[ R3 ] implies S32[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
set D703 = ( (D695 , R3) -TruthEval );
assume L1294: S32[ R3 ];
let R31 being  wff (string of R18);
set D704 = ( D656 . R31 );
set D705 = ( D695 -TruthEval R31 );
assume L1295: R31 is ( R3 + 1 ) -wff;
per cases ;
suppose L1296: (R31 is non  0wff & R31 is  exal);

reconsider D706 = R31 as non  0wff  exal ( R3 + 1 ) -wff (string of R18) by L1296 , L1295;
reconsider D707 = ( head D706 ) as R3 -wff (string of R18);
reconsider D708 = ( D656 . D706 ) as  literal (Element of R18);
L1297: D706 = ( ( <* D708 *> ^ D707 ) ^ ( tail D706 ) ) by FOMODEL2:23
.= ( <* D708 *> ^ D707 );
thus L1298:now
assume L1299: D705 = 1;
consider C242 being (Element of D659) such that L1300: ( ( (D708 , C242) ReassignIn D695 ) -TruthEval D707 ) = 1 by L1299 , L1297 , FOMODEL2:19;
consider R13 being set such that L1301: (R13 in D654 & C242 = ( Class (D658 , R13) )) by EQREL_1:def 3;
reconsider D709 = R13 as (Element of D654) by L1301;
reconsider D710 = ( (D708 , D709) SubstIn D707 ) as R3 -wff (string of R18);
L1302: ( ( ( id D654 ) . D709 ) \+\ D709 ) = ( {} );
L1303: (( ( id D654 ) . D709 ) = D709 & ( ( ( ( D658 -class ) * ( D663 -TermEval ) ) . D709 ) \+\ ( ( D658 -class ) . ( ( D663 -TermEval ) . D709 ) ) ) = ( {} )) by L1302 , FOMODEL0:29;
L1304: (( ( D663 -TermEval ) . D709 ) = D709 & ( ( ( D658 -class ) * ( D663 -TermEval ) ) . D709 ) = ( ( D658 -class ) . ( ( D663 -TermEval ) . D709 ) )) by L1303 , FOMODEL0:29 , FOMODEL3:4;
L1305: ( ( D695 -TermEval ) . D709 ) = ( ( ( D658 -class ) * ( D663 -TermEval ) ) . D709 ) by FOMODEL3:3
.= C242 by L1304 , L1301 , FOMODEL3:def 13;
L1306: 1 = ( D695 -TruthEval D710 ) by L1305 , L1300 , FOMODEL3:10;
L1307: D710 in C241 by L1306 , L1294;
L1308: { D710 } c= C241 by L1307 , ZFMISC_1:31;
L1309: [ { ( (D708 , D709) SubstIn D707 ) } , ( <* D708 *> ^ D707 ) ] is (1 , ( {} ) , { ( R#4 R18 ) })-derivable;
L1310: (( <* D708 *> ^ D707 ) is (C241 , D684)-provable & D691 c= D665 & D684 is  isotone) by L1309 , L1308 , L1034;
L1311: D706 is (C241 , D665)-provable by L1310 , L1297 , L937;
thus L1312: R31 in C241 by L1311 , L963;
end;
assume L1313: R31 in C241;
consider R47 being  literal (Element of R18) such that L1314: (( (D708 , R47) -SymbolSubstIn D707 ) in C241 & (not R47 in ( rng D707 ))) by L1313 , L1288 , L1282 , L1297;
reconsider D711 = ( (D708 , R47) -SymbolSubstIn D707 ) as R3 -wff (string of R18);
consider C243 being (Element of D659) such that L1315: (C243 = ( ( D695 . R47 ) . ( {} ) ) & ( (R47 , C243) ReassignIn D695 ) = D695) by FOMODEL2:26;
reconsider D712 = ( (R47 , C243) ReassignIn D695 ) , D713 = ( (D708 , C243) ReassignIn D695 ) as (Element of D664);
L1316: ( D712 -TruthEval D711 ) = 1 by L1314 , L1294 , L1315;
L1317: ( D713 -TruthEval D707 ) = 1 by L1316 , L1314 , FOMODEL3:9;
thus L1318: thesis by L1317 , L1297 , FOMODEL2:19;
end;
suppose L1319: (R31 is non  0wff & R31 is non  exal);

reconsider D714 = R31 as non  0wff non  exal ( R3 + 1 ) -wff (string of R18) by L1319 , L1295;
set D715 = ( head D714 );
set D716 = ( tail D714 );
L1320: ( ( D656 . D714 ) \+\ D657 ) = ( {} );
L1321: D704 = D657 by L1320 , FOMODEL0:29;
L1322: R31 = ( ( <* D657 *> ^ D715 ) ^ D716 ) by L1321 , FOMODEL2:23;
L1323: (D705 = 1 iff (( D695 -TruthEval D715 ) = ( 0 ) & ( D695 -TruthEval D716 ) = ( 0 ))) by L1322 , FOMODEL2:19;
L1324: (D705 = 1 iff ((not ( D695 -TruthEval D715 ) = 1) & (not ( D695 -TruthEval D716 ) = 1))) by L1323 , FOMODEL0:39;
L1325: (D705 = 1 iff ((not D715 in C241) & (not D716 in C241))) by L1324 , L1294;
L1326:
now
assume L1327: (( xnot D715 ) in C241 & ( xnot D716 ) in C241);
L1328: (( xnot D715 ) is (C241 , { ( R#0 R18 ) })-provable & ( xnot D716 ) is (C241 , { ( R#0 R18 ) })-provable) by L1327 , L970;
L1329: (( xnot D715 ) is (C241 , R77)-provable & ( xnot D716 ) is (C241 , R77)-provable) by L1328 , L1287 , L937;
L1330: (( xnot D715 ) in C241 & ( xnot D716 ) in C241) by L1329 , L963;
reconsider D717 = { ( xnot D715 ) , ( xnot D716 ) } as (Subset of C241) by L1330 , ZFMISC_1:32;
L1331: R31 is (( C241 null D717 ) , R77)-provable by L937 , L1287 , L1322;
thus L1332: R31 in C241 by L1331 , L963;
end;
L1333:
now
reconsider D718 = { R31 } as R18 -premises-like set;
assume L1334: R31 in C241;
L1335: D718 c= C241 by L1334 , ZFMISC_1:31;
L1336: [ { R31 } , R31 ] is (1 , ( {} ) , D681)-derivable;
L1337: [ ( D718 null D716 ) , ( xnot D715 ) ] is (2 , { [ { R31 } , R31 ] } , ( ( D681 \/ D682 ) \/ D687 ))-derivable by L1322;
L1338: [ ( D718 null D715 ) , ( xnot D716 ) ] is (3 , { [ D718 , R31 ] } , ( ( ( D681 \/ D682 ) \/ D687 ) \/ D686 ))-derivable by L1322;
L1339: [ D718 , ( xnot D715 ) ] is (( 1 + 2 ) , ( {} ) , ( D681 \/ ( ( D681 \/ D682 ) \/ D687 ) ))-derivable by L1337 , L363;
L1340: [ D718 , ( xnot D715 ) ] is (3 , ( {} ) , D665)-derivable by L1339 , L1287 , L1053;
L1341: ( xnot D715 ) is (C241 , D665)-provable by L1340 , L1034 , L1335;
thus L1342: ( xnot D715 ) in C241 by L1341 , L963;
L1343: [ D718 , ( xnot D716 ) ] is (( 1 + 3 ) , ( {} ) , ( D681 \/ ( ( ( D681 \/ D682 ) \/ D687 ) \/ D686 ) ))-derivable by L1336 , L1338 , L363;
L1344: [ D718 , ( xnot D716 ) ] is (4 , ( {} ) , D665)-derivable by L1287 , L1343 , L1053;
L1345: ( xnot D716 ) is (C241 , D665)-provable by L1344 , L1034 , L1335;
thus L1346: ( xnot D716 ) in C241 by L1345 , L963;
end;
thus L1347: thesis by L1333 , L1325 , L1288 , L1326 , FOMODEL2:def 34;
end;
suppose L1348: R31 is  0wff;

thus L1349: thesis by L1348 , L1289;
end;
end;
L1351: (for R3 being Nat holds S32[ R3 ]) from NAT_1:sch 2(L1289 , L1293);
L1352: R28 is ( Depth R28 ) -wff by FOMODEL2:def 31;
thus L1353: thesis by L1352 , L1351;
end;
notation
let R18 being Language;
let R74 being (RuleSet of R18);
let R10 being set;
antonym R10 is R74 -consistent for R10 is R74 -inconsistent;
end;
theorem
L1355: (for R11 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B227 being (Subset of R11) holds (B227 is R74 -inconsistent implies R11 is R74 -inconsistent)))))
proof
let R11 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C244 being (Subset of R11);
set D719 = ( TheNorSymbOf R18 );
assume L1356: C244 is R74 -inconsistent;
consider R32 being  wff (string of R18), R33 being  wff (string of R18) such that L1357: (R32 is (C244 , R74)-provable & ( ( <* D719 *> ^ R32 ) ^ R33 ) is (C244 , R74)-provable) by L1356 , L1170;
thus L1358: thesis by L1170 , L1357;
end;
definition
let R18 being Language;
let R74 being (RuleSet of R18);
let C245 being  functional set;
let C246 being (Element of ( ExFormulasOf R18 ));
func (R74 , C246) AddAsWitnessTo C245 equals 
:L1359: ( C245 \/ { ( (( ( R18 -firstChar ) . C246 ) , the (Element of ( ( LettersOf R18 ) \ ( SymbolsOf ( ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) /\ ( C245 \/ { ( head C246 ) } ) ) ) ))) -SymbolSubstIn ( head C246 ) ) } ) if (( C245 \/ { C246 } ) is R74 -consistent & ( ( LettersOf R18 ) \ ( SymbolsOf ( ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) /\ ( C245 \/ { ( head C246 ) } ) ) ) ) <> ( {} )) otherwise C245;
consistency;
coherence;
end;
registration
let R18 being Language;
let R74 being (RuleSet of R18);
let C247 being  functional set;
let C248 being (Element of ( ExFormulasOf R18 ));
cluster ( C247 \ ( (R74 , C248) AddAsWitnessTo C247 ) ) ->  empty for set;
coherence
proof
set D720 = ( R18 -firstChar );
set D721 = ( LettersOf R18 );
set D722 = ( (R74 , C248) AddAsWitnessTo C247 );
set D723 = ( D720 . C248 );
set D724 = ( head C248 );
set D725 = ( AllSymbolsOf R18 );
set D726 = ( ( D725 * ) \ { ( {} ) } );
set D727 = ( SymbolsOf ( D726 /\ ( C247 \/ { D724 } ) ) );
set D728 = the (Element of ( D721 \ D727 ));
set D729 = { ( (D723 , D728) -SymbolSubstIn D724 ) };
defpred S33[  ] means (( C247 \/ { C248 } ) is R74 -consistent & ( D721 \ D727 ) <> ( {} ));
L1361: ((S33[  ] implies (( C247 null D729 ) c= ( C247 \/ D729 ) & D722 = ( C247 \/ D729 ))) & ((not S33[  ]) implies D722 = ( C247 null D729 ))) by L1359;
thus L1362: thesis by L1361;
end;
end;
registration
let R18 being Language;
let R74 being (RuleSet of R18);
let C249 being  functional set;
let C250 being (Element of ( ExFormulasOf R18 ));
cluster ( ( (R74 , C250) AddAsWitnessTo C249 ) \ C249 ) ->  trivial for set;
coherence
proof
set D730 = ( R18 -firstChar );
set D731 = ( LettersOf R18 );
set D732 = ( AllSymbolsOf R18 );
set D733 = ( ( D732 * ) \ { ( {} ) } );
set D734 = ( D730 . C250 );
set D735 = ( (R74 , C250) AddAsWitnessTo C249 );
set D736 = ( head C250 );
set D737 = ( SymbolsOf ( D733 /\ ( C249 \/ { D736 } ) ) );
set D738 = the (Element of ( D731 \ D737 ));
set D739 = { ( (D734 , D738) -SymbolSubstIn D736 ) };
defpred S34[  ] means (( C249 \/ { C250 } ) is R74 -consistent & ( D731 \ D737 ) <> ( {} ));
L1364: ((S34[  ] implies D735 = ( C249 \/ D739 )) & ((not S34[  ]) implies D735 = C249)) by L1359;
L1365: ((S34[  ] implies ( D735 \ C249 ) = ( D739 \ C249 )) & ((not S34[  ]) implies ( D735 \ C249 ) = ( {} ))) by L1364 , XBOOLE_1:40;
thus L1366: thesis by L1365;
end;
end;
definition
let R18 being Language;
let R74 being (RuleSet of R18);
let C251 being  functional set;
let C252 being (Element of ( ExFormulasOf R18 ));
redefine func (R74 , C252) AddAsWitnessTo C251 -> (Subset of ( C251 \/ ( AllFormulasOf R18 ) ));

coherence
proof
set D740 = ( R18 -firstChar );
set D741 = ( (R74 , C252) AddAsWitnessTo C251 );
set D742 = ( LettersOf R18 );
set D743 = ( D740 . C252 );
set D744 = ( head C252 );
set D745 = ( AllSymbolsOf R18 );
set D746 = ( ( D745 * ) \ { ( {} ) } );
set D747 = ( AllFormulasOf R18 );
set D748 = ( SymbolsOf ( D746 /\ ( C251 \/ { D744 } ) ) );
set D749 = the (Element of ( D742 \ D748 ));
defpred S35[  ] means (( C251 \/ { C252 } ) is R74 -consistent & ( D742 \ D748 ) <> ( {} ));
per cases ;
suppose L1368: S35[  ];

reconsider D750 = ( D742 \ D748 ) as non  empty set by L1368;
L1369: (D749 in D750 & D750 c= D742);
reconsider D751 = D749 as  literal (Element of D745) by L1369;
reconsider D752 = ( (D743 , D751) -SymbolSubstIn D744 ) as  wff (string of R18);
reconsider D753 = D752 as (Element of D747) by FOMODEL2:16;
L1370: D741 = ( C251 \/ { D753 } ) by L1368 , L1359;
thus L1371: thesis by L1370 , XBOOLE_1:9;
end;
suppose L1372: (not S35[  ]);

L1373: D741 = ( C251 null D747 ) by L1372 , L1359;
thus L1374: thesis by L1373;
end;
end;
end;
definition
let R18 being Language;
let R74 being (RuleSet of R18);
attr R74 is  Correct
means
:L1377: (for R31 being  wff (string of R18) holds (for R10 being set holds (R31 is (R10 , R74)-provable implies (for R7 being non  empty set holds (for B228 being (Element of ( R7 -InterpretersOf R18 )) holds (R10 is B228 -satisfied implies ( B228 -TruthEval R31 ) = 1))))));
end;
L1379: (for R10 being set holds (for R18 being Language holds (for R31 being  wff (string of R18) holds (for R74 being (RuleSet of R18) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R10 \/ { R31 } ) is R74 -inconsistent) implies ( xnot R31 ) is (R10 , R74)-provable)))))
proof
let R10 being set;
let R18 being Language;
let R31 being  wff (string of R18);
let R74 being (RuleSet of R18);
set D754 = ( R10 \/ { R31 } );
set D755 = ( TheNorSymbOf R18 );
set D756 = ( R#1 R18 );
set D757 = ( R#8 R18 );
set D758 = { D756 };
set D759 = { D757 };
assume L1380: (R74 is  isotone & D756 in R74 & D757 in R74);
reconsider D760 = D758 , D761 = D759 as (Subset of R74) by L1380 , ZFMISC_1:31;
assume L1381: D754 is R74 -inconsistent;
consider R32 being  wff (string of R18), R33 being  wff (string of R18) such that L1382: (R32 is (D754 , R74)-provable & ( ( <* D755 *> ^ R32 ) ^ R33 ) is (D754 , R74)-provable) by L1381 , L1170;
set D762 = ( ( <* D755 *> ^ R32 ) ^ R33 );
consider C253 being set, C254 being Nat such that L1383: (C253 c= D754 & [ C253 , R32 ] is (C254 , ( {} ) , R74)-derivable) by L1034 , L1382;
consider C255 being set, C256 being Nat such that L1384: (C255 c= D754 & [ C255 , D762 ] is (C256 , ( {} ) , R74)-derivable) by L1034 , L1382;
reconsider D763 = [ C253 , R32 ] , D764 = [ C255 , D762 ] as R18 -sequent-like set by L1383 , L1384;
L1385: (( ( D763 `1 ) \+\ C253 ) = ( {} ) & ( ( D764 `1 ) \+\ C255 ) = ( {} ));
reconsider D765 = C253 , D766 = C255 as R18 -premises-like (Subset of D754) by L1385 , L1383 , L1384 , FOMODEL0:29;
reconsider D767 = ( D765 \ { R31 } ) , D768 = ( D766 \ { R31 } ) as R18 -premises-like (Subset of R10) by XBOOLE_1:43;
L1386: (( D765 \ D767 ) = ( D765 /\ { R31 } ) & ( D766 \ D768 ) = ( D766 /\ { R31 } )) by XBOOLE_1:48;
reconsider D769 = ( D765 \ D767 ) , D770 = ( D766 \ D768 ) as R18 -premises-like (Subset of { R31 }) by L1386;
reconsider D771 = ( D765 \/ D766 ) as R18 -premises-like (Subset of D754);
reconsider D772 = ( D771 \ { R31 } ) as R18 -premises-like (Subset of R10) by XBOOLE_1:43;
reconsider D773 = ( D771 /\ { R31 } ) as R18 -premises-like (Subset of { R31 });
reconsider D774 = { R31 } as R18 -premises-like set;
set D775 = ( ( C254 + C256 ) + 1 );
reconsider D776 = ( D772 \/ { R31 } ) as R18 -premises-like set;
reconsider D777 = ( ( {} ) null R18 ) as R18 -sequents-like set;
set D778 = [ D776 , R32 ];
set D779 = [ D776 , D762 ];
L1387: [ ( ( D765 \/ ( D766 \/ D774 ) ) null ( C256 + 1 ) ) , R32 ] is (( C256 + 1 ) , { [ D765 , R32 ] } , D758)-derivable;
L1388: [ ( D765 \/ ( D766 \/ { R31 } ) ) , R32 ] is (( C254 + ( C256 + 1 ) ) , ( {} ) , ( R74 \/ D758 ))-derivable by L1387 , L1383 , L363 , L1380;
L1389: [ ( D771 \/ { R31 } ) , R32 ] is (( ( C254 + C256 ) + 1 ) , ( {} ) , ( R74 null D760 ))-derivable by L1388 , XBOOLE_1:4;
L1390: [ ( ( D772 \/ D773 ) \/ { R31 } ) , R32 ] is (( ( C254 + C256 ) + 1 ) , ( {} ) , R74)-derivable by L1389 , FOMODEL0:48;
L1391: [ ( D772 \/ ( { R31 } null D773 ) ) , R32 ] is (( ( C254 + C256 ) + 1 ) , ( {} ) , R74)-derivable by L1390 , XBOOLE_1:4;
L1392: [ ( ( D766 \/ ( D765 \/ { R31 } ) ) null ( C254 + 1 ) ) , D762 ] is (( C254 + 1 ) , { [ D766 , D762 ] } , D758)-derivable;
L1393: [ ( D766 \/ ( D765 \/ { R31 } ) ) , D762 ] is (( C256 + ( C254 + 1 ) ) , ( {} ) , ( R74 \/ D758 ))-derivable by L1392 , L1384 , L363 , L1380;
L1394: [ ( D771 \/ { R31 } ) , D762 ] is (( ( C254 + C256 ) + 1 ) , ( {} ) , ( R74 null D760 ))-derivable by L1393 , XBOOLE_1:4;
L1395: [ ( ( D772 \/ D773 ) \/ { R31 } ) , D762 ] is (( ( C254 + C256 ) + 1 ) , ( {} ) , R74)-derivable by L1394 , FOMODEL0:48;
L1396: [ ( D772 \/ ( { R31 } null D773 ) ) , D762 ] is (( ( C254 + C256 ) + 1 ) , ( {} ) , R74)-derivable by L1395 , XBOOLE_1:4;
L1397: [ ( D772 null ( R32 ^ R33 ) ) , ( xnot R31 ) ] is (1 , { [ ( D772 \/ { R31 } ) , R32 ] , [ ( D772 \/ { R31 } ) , D762 ] } , { ( R#8 R18 ) })-derivable;
L1398: [ D772 , ( xnot R31 ) ] is (( D775 + 1 ) , ( D777 \/ D777 ) , ( ( R74 \/ R74 ) \/ { ( R#8 R18 ) } ))-derivable by L1397 , L1391 , L1396 , L924 , L1380;
L1399: [ D772 , ( xnot R31 ) ] is (( D775 + 1 ) , ( {} ) , ( R74 null D761 ))-derivable by L1398;
thus L1400: thesis by L1399 , L1034;
end;
L1401: (for R10 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (R10 is R74 -consistent iff (for B229 being  finite (Subset of R10) holds B229 is R74 -consistent)))))
proof
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
set D780 = ( TheNorSymbOf R18 );
thus L1402: (R10 is R74 -consistent implies (for B230 being  finite (Subset of R10) holds B230 is R74 -consistent)) by L1355;
assume L1403: (for B231 being  finite (Subset of R10) holds B231 is R74 -consistent);
assume L1404: R10 is R74 -inconsistent;
consider R32 being  wff (string of R18), R33 being  wff (string of R18) such that L1405: (R32 is (R10 , R74)-provable & ( ( <* D780 *> ^ R32 ) ^ R33 ) is (R10 , R74)-provable) by L1404 , L1170;
reconsider D781 = ( ( <* D780 *> ^ R32 ) ^ R33 ) as non  exal non  0wff  wff (string of R18);
consider C257 being set, C258 being Nat such that L1406: (C257 c= R10 & [ C257 , R32 ] is (C258 , ( {} ) , R74)-derivable) by L1034 , L1405;
consider C259 being set, C260 being Nat such that L1407: (C259 c= R10 & [ C259 , D781 ] is (C260 , ( {} ) , R74)-derivable) by L1034 , L1405;
reconsider D782 = [ C257 , R32 ] , D783 = [ C259 , D781 ] as R18 -sequent-like set by L1406 , L1407;
L1408: (( ( D782 `1 ) \+\ C257 ) = ( {} ) & ( ( D783 `1 ) \+\ C259 ) = ( {} ));
reconsider D784 = C257 , D785 = C259 as R18 -premises-like (Subset of R10) by L1408 , L1406 , L1407 , FOMODEL0:29;
L1409: R32 is (( C257 null C259 ) , R74)-provable by L1406 , L1034;
L1410: D781 is (( C259 null C257 ) , R74)-provable by L1407 , L1034;
L1411: ( D784 \/ D785 ) is R74 -inconsistent by L1410 , L1409 , L1170;
thus L1412: contradiction by L1411 , L1403;
end;
L1413: (for R10 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds ((( R#0 R18 ) in R74 & R10 is R18 -covering & R10 is R74 -consistent) implies (R10 is R18 -mincover & R10 is R74 -expanded)))))
proof
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
set D786 = ( R#0 R18 );
set D787 = { D786 };
assume that
L1414: D786 in R74
and
L1415: (R10 is R18 -covering & R10 is R74 -consistent);
L1416: D787 c= R74 by L1414 , ZFMISC_1:31;
L1417: (for R31 being  wff (string of R18) holds ((R31 in R10 implies (not ( xnot R31 ) in R10)) & ((not R31 in R10) implies ( xnot R31 ) in R10)))
proof
let R31 being  wff (string of R18);
thus L1418:now
assume L1419: R31 in R10;
L1420: R31 is (R10 , { ( R#0 R18 ) })-provable by L1419 , L970;
L1421: R31 is (R10 , R74)-provable by L1420 , L1416 , L937;
L1422: (not ( xnot R31 ) is (R10 , R74)-provable) by L1421 , L1415 , L1170;
L1423: (not ( xnot R31 ) is (R10 , { ( R#0 R18 ) })-provable) by L1422 , L1416 , L937;
thus L1424: (not ( xnot R31 ) in R10) by L1423 , L970;
end;
assume L1425: (not R31 in R10);
thus L1426: ( xnot R31 ) in R10 by L1425 , L1415 , FOMODEL2:def 40;
end;
L1427: (for R31 being  wff (string of R18) holds (R31 in R10 iff (not ( xnot R31 ) in R10))) by L1417;
thus L1428: R10 is R18 -mincover by L1427 , FOMODEL2:def 34;
L1429:
now
let R13 being set;
assume L1430: R13 is (R10 , R74)-provable;
reconsider D788 = R13 as  wff (string of R18) by L1430 , L388;
L1431: (not ( xnot D788 ) is (R10 , R74)-provable) by L1430 , L1415 , L1170;
L1432: (not ( xnot D788 ) is (R10 , D787)-provable) by L1431 , L1416 , L937;
L1433: (not ( xnot D788 ) in R10) by L1432 , L970;
thus L1434: R13 in R10 by L1433 , L1417;
end;
thus L1435: thesis by L1429 , L963;
end;
L1436: (for R10 being set holds (for R18 being Language holds (for R31 being  wff (string of R18) holds (for R74 being (RuleSet of R18) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & R31 is (R10 , R74)-provable & R10 is R74 -consistent) implies ( R10 \/ { R31 } ) is R74 -consistent)))))
proof
let R10 being set;
let R18 being Language;
let R31 being  wff (string of R18);
let R74 being (RuleSet of R18);
assume L1437: (R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74);
assume L1438: (R31 is (R10 , R74)-provable & R10 is R74 -consistent);
L1439: (not ( xnot R31 ) is (R10 , R74)-provable) by L1438 , L1170;
thus L1440: thesis by L1439 , L1379 , L1437;
end;
L1441: (for R7 being non  empty set holds (for R10 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B232 being (Element of ( R7 -InterpretersOf R18 )) holds ((R74 is  Correct & R10 is B232 -satisfied) implies R10 is R74 -consistent))))))
proof
let R7 being non  empty set;
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
set D789 = ( TheNorSymbOf R18 );
let C261 being (Element of ( R7 -InterpretersOf R18 ));
assume L1442: (R74 is  Correct & R10 is C261 -satisfied);
L1443:
now
given R32 being  wff (string of R18) , R33 being  wff (string of R18) such that
L1444: (R32 is (R10 , R74)-provable & ( ( <* D789 *> ^ R32 ) ^ R33 ) is (R10 , R74)-provable);

set D790 = ( ( <* D789 *> ^ R32 ) ^ R33 );
L1445: (( C261 -TruthEval R32 ) = 1 & ( C261 -TruthEval D790 ) = 1) by L1444 , L1442 , L1377;
thus L1446: contradiction by L1445 , FOMODEL2:19;
end;
thus L1447: thesis by L1443 , L1170;
end;
registration
let R18 being Language;
let R41 being  termal (string of R18);
let R42 being  termal (string of R18);
cluster ( ( SubTerms ( ( <* ( TheEqSymbOf R18 ) *> ^ R41 ) ^ R42 ) ) \+\ <* R41 , R42 *> ) ->  empty for set;
coherence
proof
set D791 = ( TheEqSymbOf R18 );
reconsider D792 = ( ( <* D791 *> ^ R41 ) ^ R42 ) as  0wff (string of R18);
set D793 = ( R18 -multiCat );
set D794 = ( R18 -firstChar );
set D795 = ( SubTerms D792 );
set D796 = ( AllSymbolsOf R18 );
set D797 = ( AllTermsOf R18 );
reconsider D798 = R41 , D799 = R42 as (Element of D797) by FOMODEL1:def 32;
L1448: ( 2 -tuples_on D797 ) = { <* R26 , R27 *> where R26 is (Element of ( AllTermsOf R18 )) , R27 is (Element of ( AllTermsOf R18 )) : (not contradiction) } by FINSEQ_2:99;
L1449: (D792 = ( <* D791 *> ^ ( R41 ^ R42 ) ) & ( ( ( <* D791 *> ^ ( R41 ^ R42 ) ) . 1 ) \+\ D791 ) = ( {} )) by FINSEQ_1:32;
L1450: D791 = ( D792 . 1 ) by L1449 , FOMODEL0:29
.= ( D794 . D792 ) by FOMODEL0:6;
L1451: ( <* D791 *> ^ ( D793 . D795 ) ) = ( <* D791 *> ^ ( R41 ^ R42 ) ) by L1450 , L1449 , FOMODEL1:def 38;
L1452: ( D793 . D795 ) = ( R41 ^ R42 ) by L1451 , FOMODEL0:41;
L1453: ( ( ( abs ( ar D791 ) ) - 2 ) + 2 ) = ( ( 0 ) + 2 );
L1454: D795 in ( 2 -tuples_on D797 ) by L1453 , L1450 , FOMODEL0:16;
consider R26 being (Element of ( AllTermsOf R18 )), R27 being (Element of ( AllTermsOf R18 )) such that L1455: D795 = <* R26 , R27 *> by L1454 , L1448;
L1456: (R26 is (Element of ( D796 * )) & R27 is (Element of ( D796 * )) & D798 is (Element of ( D796 * )) & D799 is (Element of ( D796 * ))) by TARSKI:def 3;
reconsider D800 = R26 , D801 = R27 , D802 = D798 , D803 = D799 as D796 -valued FinSequence by L1456;
L1457: ( ( D793 . <* D800 , D801 *> ) \+\ ( D800 ^ D801 ) ) = ( {} );
L1458: ( D800 ^ D801 ) = ( D802 ^ D803 ) by L1457 , L1455 , L1452 , FOMODEL0:29;
L1459: (D800 = D802 & D801 = D803) by L1458 , FOMODEL0:def 20;
thus L1460: thesis by L1459 , L1455 , FOMODEL0:29;
end;
end;
L1462: (for R7 being non  empty set holds (for R18 being Language holds (for R41 being  termal (string of R18) holds (for R42 being  termal (string of R18) holds (for B233 being (R18 , R7)-interpreter-like Function holds (( B233 -AtomicEval ( ( <* ( TheEqSymbOf R18 ) *> ^ R41 ) ^ R42 ) ) = 1 iff ( ( B233 -TermEval ) . R41 ) = ( ( B233 -TermEval ) . R42 )))))))
proof
let R7 being non  empty set;
let R18 being Language;
let R41 being  termal (string of R18);
let R42 being  termal (string of R18);
set D804 = ( TheEqSymbOf R18 );
set D805 = ( ( <* D804 *> ^ R41 ) ^ R42 );
set D806 = ( SubTerms D805 );
set D807 = ( R18 -firstChar );
L1463: (D805 = ( <* D804 *> ^ ( R41 ^ R42 ) ) & ( ( ( <* D804 *> ^ ( R41 ^ R42 ) ) . 1 ) \+\ D804 ) = ( {} )) by FINSEQ_1:32;
L1464: D804 = ( D805 . 1 ) by L1463 , FOMODEL0:29
.= ( D807 . D805 ) by FOMODEL0:6;
L1465: ( D806 \+\ <* R41 , R42 *> ) = ( {} );
L1466: D806 = <* R41 , R42 *> by L1465 , FOMODEL0:29;
L1467: (( D806 . 1 ) = R41 & ( D806 . 2 ) = R42) by L1466 , FINSEQ_1:44;
thus L1468: thesis by L1467 , L1464 , FOMODEL2:15;
end;
definition
let R18 being Language;
let C262 being (Rule of R18);
attr C262 is  Correct
means
:L1469: (for R10 being set holds (R10 is R18 -correct implies ( C262 . R10 ) is R18 -correct));
end;
registration
let R18 being Language;
cluster R18 -sequent-like -> R18 -null for set;
coherence;
end;
L1472: (for R18 being Language holds ( R#0 R18 ) is  Correct)
proof
let R18 being Language;
L1473:
now
set D808 = ( R#0 R18 );
set D809 = ( P#0 R18 );
set D810 = ( R18 -sequents );
let R10 being set;
assume L1474: R10 is R18 -correct;
L1475:
now
let R7 being non  empty set;
set D811 = ( R7 -InterpretersOf R18 );
let C263 being (Element of D811);
let C264 being C263 -satisfied set;
let R31 being  wff (string of R18);
set D812 = [ C264 , R31 ];
L1476: (( dom D809 ) c= ( bool D810 ) & ( D812 `1 ) = C264 & ( D812 `2 ) = R31);
assume L1477: [ C264 , R31 ] in ( D808 . R10 );
L1478: (D812 in D810 & [ R10 , D812 ] in D809) by L1477 , L537;
L1479: R10 in ( dom D809 ) by L1478 , XTUPLE_0:def 12;
reconsider D813 = R10 as (Subset of D810) by L1479;
reconsider D814 = D812 as (Element of D810) by L1477 , L537;
L1480: D814 Rule0 D813 by L1478 , L420;
L1481: R31 in C264 by L1480 , L1476 , L406;
thus L1482: ( C263 -TruthEval R31 ) = 1 by L1481 , FOMODEL2:def 42;
end;
thus L1483: ( D808 . R10 ) is R18 -correct by L1475 , FOMODEL2:def 44;
end;
thus L1484: thesis by L1473 , L1469;
end;
registration
let R18 being Language;
cluster ( R#0 R18 ) ->  Correct for (Rule of R18);
coherence by L1472;
end;
registration
let R18 being Language;
cluster  Correct for (Rule of R18);
existence
proof
take ( R#0 R18 );
thus L1486: thesis;
end;
end;
L1488: (for R18 being Language holds ( R#1 R18 ) is  Correct)
proof
let R18 being Language;
L1489:
now
set D815 = ( R#1 R18 );
set D816 = ( P#1 R18 );
set D817 = ( R18 -sequents );
set D818 = ( TheEqSymbOf R18 );
set D819 = ( TheNorSymbOf R18 );
set D820 = ( AllFormulasOf R18 );
set D821 = ( AllTermsOf R18 );
set D822 = ( AllSymbolsOf R18 );
set D823 = ( R18 -firstChar );
set D824 = ( R18 -multiCat );
let R10 being set;
assume L1490: R10 is R18 -correct;
L1491:
now
let R7 being non  empty set;
set D825 = ( R7 -InterpretersOf R18 );
let C265 being (Element of D825);
let C266 being C265 -satisfied set;
let R28 being  wff (string of R18);
set D826 = [ C266 , R28 ];
set D827 = ( C265 -TermEval );
set D828 = ( R7 -deltaInterpreter );
L1492: (( ( D826 `1 ) \+\ C266 ) = ( {} ) & ( ( D826 `2 ) \+\ R28 ) = ( {} ));
L1493: (( dom D816 ) c= ( bool D817 ) & ( D826 `1 ) = C266 & ( D826 `2 ) = R28);
assume L1494: D826 in ( D815 . R10 );
L1495: (D826 in D817 & [ R10 , D826 ] in D816) by L1494 , L537;
L1496: R10 in ( dom D816 ) by L1495 , XTUPLE_0:def 12;
reconsider D829 = R10 as R18 -correct (Subset of D817) by L1496 , L1490;
reconsider D830 = D826 as (Element of D817) by L1494 , L537;
L1497: D830 Rule1 D829 by L1495 , L426;
consider R16 being set such that L1498: (R16 in D829 & ( R16 `1 ) c= ( D830 `1 ) & ( D830 `2 ) = ( R16 `2 )) by L1497 , L407;
reconsider D831 = ( R16 `1 ) as (Subset of C266) by L1492 , L1498;
L1499: [ D831 , R28 ] in D829 by L1498 , L1493 , MCART_1:21;
thus L1500: ( C265 -TruthEval R28 ) = 1 by L1499 , FOMODEL2:def 44;
end;
thus L1501: ( D815 . R10 ) is R18 -correct by L1491 , FOMODEL2:def 44;
end;
thus L1502: thesis by L1489 , L1469;
end;
registration
let R18 being Language;
cluster ( R#1 R18 ) ->  Correct for (Rule of R18);
coherence by L1488;
end;
L1504: (for R18 being Language holds ( R#2 R18 ) is  Correct)
proof
let R18 being Language;
L1505:
now
set D832 = ( R#2 R18 );
set D833 = ( P#2 R18 );
set D834 = ( R18 -sequents );
set D835 = ( TheEqSymbOf R18 );
set D836 = ( TheNorSymbOf R18 );
set D837 = ( AllFormulasOf R18 );
set D838 = ( AllTermsOf R18 );
set D839 = ( AllSymbolsOf R18 );
set D840 = ( R18 -firstChar );
set D841 = ( R18 -multiCat );
let R10 being set;
assume L1506: R10 is R18 -correct;
L1507:
now
let R7 being non  empty set;
set D842 = ( R7 -InterpretersOf R18 );
let C267 being (Element of D842);
let C268 being C267 -satisfied set;
let R28 being  wff (string of R18);
set D843 = [ C268 , R28 ];
set D844 = ( C267 -TermEval );
set D845 = ( R7 -deltaInterpreter );
L1508: (( ( D843 `1 ) \+\ C268 ) = ( {} ) & ( ( D843 `2 ) \+\ R28 ) = ( {} ));
assume L1509: D843 in ( D832 . R10 );
L1510: (D843 in D834 & [ R10 , D843 ] in D833) by L1509 , L537;
L1511: R10 in ( dom D833 ) by L1510 , XTUPLE_0:def 12;
reconsider D846 = R10 as R18 -correct (Subset of D834) by L1511 , L1506;
reconsider D847 = D843 as (Element of D834) by L1509 , L537;
L1512: D847 Rule2 D846 by L1510 , L432;
consider R40 being  termal (string of R18) such that L1513: ( D847 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ R40 ) ^ R40 ) by L1512 , L408;
L1514: ( D844 . R40 ) = ( D844 . R40 );
L1515: ( C267 -AtomicEval ( ( <* D835 *> ^ R40 ) ^ R40 ) ) = 1 by L1514 , L1462;
thus L1516: ( C267 -TruthEval R28 ) = 1 by L1515 , L1508 , L1513;
end;
thus L1517: ( D832 . R10 ) is R18 -correct by L1507 , FOMODEL2:def 44;
end;
thus L1518: thesis by L1505 , L1469;
end;
registration
let R18 being Language;
cluster ( R#2 R18 ) ->  Correct for (Rule of R18);
coherence by L1504;
end;
L1520: (for R18 being Language holds ( R#3a R18 ) is  Correct)
proof
let R18 being Language;
L1521:
now
set D848 = ( R#3a R18 );
set D849 = ( P#3a R18 );
set D850 = ( R18 -sequents );
set D851 = ( TheEqSymbOf R18 );
set D852 = ( TheNorSymbOf R18 );
set D853 = ( AllFormulasOf R18 );
set D854 = ( AllTermsOf R18 );
set D855 = ( AllSymbolsOf R18 );
set D856 = ( R18 -firstChar );
set D857 = ( R18 -multiCat );
let R10 being set;
assume L1522: R10 is R18 -correct;
L1523:
now
let R7 being non  empty set;
set D858 = ( R7 -InterpretersOf R18 );
let C269 being (Element of D858);
let C270 being C269 -satisfied set;
let R28 being  wff (string of R18);
set D859 = [ C270 , R28 ];
set D860 = ( C269 -TermEval );
set D861 = ( R7 -deltaInterpreter );
L1524: (( ( D859 `1 ) \+\ C270 ) = ( {} ) & ( ( D859 `2 ) \+\ R28 ) = ( {} ));
assume L1525: D859 in ( D848 . R10 );
L1526: (D859 in D850 & [ R10 , D859 ] in D849) by L1525 , L537;
L1527: R10 in ( dom D849 ) by L1526 , XTUPLE_0:def 12;
reconsider D862 = R10 as R18 -correct (Subset of D850) by L1527 , L1522;
reconsider D863 = D859 as (Element of D850) by L1525 , L537;
L1528: D863 Rule3a D862 by L1526 , L438;
consider C271 , C272 , C273 being  termal (string of R18), C274 being set such that L1529: (C274 in D862 & ( D863 `1 ) = ( ( C274 `1 ) \/ { ( ( <* ( TheEqSymbOf R18 ) *> ^ C272 ) ^ C273 ) } ) & ( C274 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ C271 ) ^ C272 ) & ( D863 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ C271 ) ^ C273 )) by L1528 , L409;
reconsider D864 = ( ( <* D851 *> ^ C271 ) ^ C272 ) , D865 = ( ( <* D851 *> ^ C271 ) ^ C273 ) , D866 = ( ( <* D851 *> ^ C272 ) ^ C273 ) as  0wff (string of R18);
reconsider D867 = ( ( C274 `1 ) null { D866 } ) , D868 = ( { D866 } null ( C274 `1 ) ) as (Subset of C270) by L1529 , L1524;
L1530: [ D867 , D864 ] in D862 by L1529 , MCART_1:21;
L1531: ( C269 -TruthEval D864 ) = 1 by L1530 , FOMODEL2:def 44;
L1532: (D865 = R28 & ( D860 . C271 ) = ( D860 . C272 )) by L1531 , L1462 , L1524 , L1529;
L1533: D868 = { D866 };
L1534: ( C269 -TruthEval D866 ) = 1 by L1533 , FOMODEL2:27;
L1535: ( D860 . C273 ) = ( D860 . C271 ) by L1534 , L1532 , L1462;
L1536: ( C269 -AtomicEval D865 ) = 1 by L1535 , L1462;
thus L1537: ( C269 -TruthEval R28 ) = 1 by L1536 , L1524 , L1529;
end;
thus L1538: ( D848 . R10 ) is R18 -correct by L1523 , FOMODEL2:def 44;
end;
thus L1539: thesis by L1521 , L1469;
end;
registration
let R18 being Language;
cluster ( R#3a R18 ) ->  Correct for (Rule of R18);
coherence by L1520;
end;
L1541: (for R18 being Language holds ( R#3b R18 ) is  Correct)
proof
let R18 being Language;
L1542:
now
set D869 = ( R#3b R18 );
set D870 = ( P#3b R18 );
set D871 = ( R18 -sequents );
set D872 = ( TheEqSymbOf R18 );
set D873 = ( TheNorSymbOf R18 );
set D874 = ( AllFormulasOf R18 );
set D875 = ( AllTermsOf R18 );
set D876 = ( AllSymbolsOf R18 );
set D877 = ( R18 -firstChar );
set D878 = ( R18 -multiCat );
let R10 being set;
assume L1543: R10 is R18 -correct;
L1544:
now
let R7 being non  empty set;
set D879 = ( R7 -InterpretersOf R18 );
let C275 being (Element of D879);
let C276 being C275 -satisfied set;
let R28 being  wff (string of R18);
set D880 = [ C276 , R28 ];
set D881 = ( C275 -TermEval );
set D882 = ( R7 -deltaInterpreter );
L1545: (( ( D880 `1 ) \+\ C276 ) = ( {} ) & ( ( D880 `2 ) \+\ R28 ) = ( {} ));
assume L1546: D880 in ( D869 . R10 );
L1547: (D880 in D871 & [ R10 , D880 ] in D870) by L1546 , L537;
L1548: R10 in ( dom D870 ) by L1547 , XTUPLE_0:def 12;
reconsider D883 = R10 as R18 -correct (Subset of D871) by L1548 , L1543;
reconsider D884 = D880 as (Element of D871) by L1546 , L537;
L1549: D884 Rule3b D883 by L1547 , L444;
consider C277 , C278 being  termal (string of R18) such that L1550: (( D884 `1 ) = { ( ( <* ( TheEqSymbOf R18 ) *> ^ C277 ) ^ C278 ) } & ( D884 `2 ) = ( ( <* ( TheEqSymbOf R18 ) *> ^ C278 ) ^ C277 )) by L1549 , L410;
set D885 = ( ( <* D872 *> ^ C277 ) ^ C278 );
set D886 = ( ( <* D872 *> ^ C278 ) ^ C277 );
L1551: { D885 } is C275 -satisfied by L1550 , L1545;
L1552: 1 = ( C275 -AtomicEval D885 ) by L1551 , FOMODEL2:27;
L1553: ( D881 . C277 ) = ( D881 . C278 ) by L1552 , L1462;
L1554: (( C275 -AtomicEval D886 ) = 1 & D886 = R28) by L1553 , L1550 , L1545 , L1462;
thus L1555: ( C275 -TruthEval R28 ) = 1 by L1554;
end;
thus L1556: ( D869 . R10 ) is R18 -correct by L1544 , FOMODEL2:def 44;
end;
thus L1557: thesis by L1542 , L1469;
end;
registration
let R18 being Language;
cluster ( R#3b R18 ) ->  Correct for (Rule of R18);
coherence by L1541;
end;
L1559: (for R18 being Language holds ( R#3d R18 ) is  Correct)
proof
let R18 being Language;
L1560:
now
set D887 = ( R#3d R18 );
set D888 = ( P#3d R18 );
set D889 = ( R18 -sequents );
set D890 = ( TheEqSymbOf R18 );
set D891 = ( TheNorSymbOf R18 );
set D892 = ( AllFormulasOf R18 );
set D893 = ( AllTermsOf R18 );
set D894 = ( AllSymbolsOf R18 );
set D895 = ( R18 -firstChar );
set D896 = ( R18 -multiCat );
let R10 being set;
assume L1561: R10 is R18 -correct;
L1562:
now
let R7 being non  empty set;
set D897 = ( R7 -InterpretersOf R18 );
let C279 being (Element of D897);
let C280 being C279 -satisfied set;
let R28 being  wff (string of R18);
set D898 = [ C280 , R28 ];
set D899 = ( C279 -TermEval );
set D900 = ( R7 -deltaInterpreter );
L1563: (( ( D898 `1 ) \+\ C280 ) = ( {} ) & ( ( D898 `2 ) \+\ R28 ) = ( {} ));
assume L1564: D898 in ( D887 . R10 );
L1565: (D898 in D889 & [ R10 , D898 ] in D888) by L1564 , L537;
L1566: R10 in ( dom D888 ) by L1565 , XTUPLE_0:def 12;
reconsider D901 = R10 as R18 -correct (Subset of D889) by L1566 , L1561;
reconsider D902 = D898 as (Element of D889) by L1564 , L537;
L1567: D902 Rule3d D901 by L1565 , L450;
consider C281 being  low-compounding (Element of R18), C282 , C283 being ( abs ( ar C281 ) ) -element (Element of ( D893 * )) such that L1568: (C281 is  operational & ( D902 `1 ) = { ( ( <* D890 *> ^ ( B235 . B234 ) ) ^ ( B236 . B234 ) ) where B234 is (Element of ( Seg ( abs ( ar C281 ) ) )) , B235 , B236 is (Function of ( Seg ( abs ( ar C281 ) ) ) , ( ( D894 * ) \ { ( {} ) } )) : (B235 = C282 & B236 = C283) } & ( D902 `2 ) = ( ( <* D890 *> ^ ( C281 -compound C282 ) ) ^ ( C281 -compound C283 ) )) by L1567 , L411;
reconsider D903 = ( C281 -compound C282 ) , D904 = ( C281 -compound C283 ) as  termal (string of R18) by L1568;
L1569: (( ( D903 . 1 ) \+\ C281 ) = ( {} ) & ( ( D904 . 1 ) \+\ C281 ) = ( {} ));
L1570: (( D903 . 1 ) = C281 & ( D904 . 1 ) = C281) by L1569 , FOMODEL0:29;
L1571: (( D895 . D903 ) = C281 & ( D895 . D904 ) = C281) by L1570 , FOMODEL0:6;
L1572: (( SubTerms D903 ) = C282 & ( SubTerms D904 ) = C283) by L1571 , FOMODEL1:def 37;
L1573: (( D899 . D903 ) = ( ( C279 . C281 ) . ( D899 * C282 ) ) & ( D899 . D904 ) = ( ( C279 . C281 ) . ( D899 * C283 ) )) by L1572 , L1571 , FOMODEL2:21;
reconsider D905 = ( { ( ( <* D890 *> ^ ( B238 . B237 ) ) ^ ( B239 . B237 ) ) where B237 is (Element of ( Seg ( abs ( ar C281 ) ) )) , B238 , B239 is (Function of ( Seg ( abs ( ar C281 ) ) ) , ( ( D894 * ) \ { ( {} ) } )) : (B238 = C282 & B239 = C283) } null ( {} ) ) as (Subset of C280) by L1568 , L1563;
L1574:
now
set D906 = ( D899 * C282 );
set D907 = ( D899 * C283 );
L1575: ( len D906 ) = ( abs ( ar C281 ) ) by CARD_1:def 7;
thus L1576: ( len D907 ) = ( len D906 ) by L1575 , CARD_1:def 7;
let R1 being Nat;
assume L1577: (1 <= R1 & R1 <= ( len D906 ));
L1578: (1 <= R1 & R1 <= ( abs ( ar C281 ) )) by L1577 , CARD_1:def 7;
reconsider D908 = R1 as (Element of ( Seg ( abs ( ar C281 ) ) )) by L1578 , FINSEQ_1:1;
L1579: ( R1 - R1 ) <= ( ( abs ( ar C281 ) ) - R1 ) by L1578 , XREAL_1:9;
reconsider D909 = ( ( abs ( ar C281 ) ) - R1 ) as Nat by L1579;
reconsider D910 = R1 as non  zero Nat by L1577;
L1580: (( dom ( C282 null ( 0 ) ) ) = ( Seg ( ( abs ( ar C281 ) ) + ( 0 ) ) ) & ( rng C282 ) c= ( ( D894 * ) \ { ( {} ) } ) & ( dom ( C283 null ( 0 ) ) ) = ( Seg ( ( abs ( ar C281 ) ) + ( 0 ) ) ) & ( rng C283 ) c= ( ( D894 * ) \ { ( {} ) } )) by PARTFUN1:def 2 , RELAT_1:def 19;
L1581: (C282 is (Element of ( Funcs (( Seg ( abs ( ar C281 ) ) ) , ( ( D894 * ) \ { ( {} ) } )) )) & C283 is (Element of ( Funcs (( Seg ( abs ( ar C281 ) ) ) , ( ( D894 * ) \ { ( {} ) } )) ))) by L1580 , FUNCT_2:def 2;
reconsider D911 = C282 , D912 = C283 as (Function of ( Seg ( abs ( ar C281 ) ) ) , ( ( D894 * ) \ { ( {} ) } )) by L1581;
L1582: (C282 is ( D910 + D909 ) -element & C283 is ( D910 + D909 ) -element);
L1583: (( { ( C282 . D910 ) } \ D893 ) = ( {} ) & ( { ( C283 . D910 ) } \ D893 ) = ( {} )) by L1582;
L1584: (( C282 . R1 ) in D893 & ( C283 . R1 ) in D893) by L1583 , ZFMISC_1:60;
reconsider D913 = ( C282 . R1 ) , D914 = ( C283 . R1 ) as  termal (string of R18) by L1584;
reconsider D915 = ( ( <* D890 *> ^ D913 ) ^ D914 ) as  0wff (string of R18);
L1585: (( ( D899 . ( D911 . D908 ) ) \+\ ( ( D899 * D911 ) . D908 ) ) = ( {} ) & ( ( D899 . ( D912 . D908 ) ) \+\ ( ( D899 * D912 ) . D908 ) ) = ( {} ));
L1586: (( D899 . ( D911 . D908 ) ) = ( ( D899 * D911 ) . D908 ) & ( D899 . ( D912 . D908 ) ) = ( ( D899 * D912 ) . D908 )) by L1585 , FOMODEL0:29;
set D916 = <* D913 , D914 *>;
L1587: ( ( <* D890 *> ^ ( D911 . D908 ) ) ^ ( D912 . D908 ) ) in D905;
L1588: ( C279 -TruthEval D915 ) = 1 by L1587 , FOMODEL2:def 42;
thus L1589: ( D906 . R1 ) = ( D907 . R1 ) by L1588 , L1586 , L1462;
end;
L1590: ( D899 . D903 ) = ( D899 . D904 ) by L1574 , L1573 , FINSEQ_1:14;
L1591: (( C279 -AtomicEval ( ( <* D890 *> ^ D903 ) ^ D904 ) ) = 1 & R28 = ( ( <* D890 *> ^ D903 ) ^ D904 )) by L1590 , L1462 , L1563 , L1568;
thus L1592: ( C279 -TruthEval R28 ) = 1 by L1591;
end;
thus L1593: ( D887 . R10 ) is R18 -correct by L1562 , FOMODEL2:def 44;
end;
thus L1594: thesis by L1560 , L1469;
end;
registration
let R18 being Language;
cluster ( R#3d R18 ) ->  Correct for (Rule of R18);
coherence by L1559;
end;
L1596: (for R18 being Language holds ( R#3e R18 ) is  Correct)
proof
let R18 being Language;
L1597:
now
set D917 = ( R#3e R18 );
set D918 = ( P#3e R18 );
set D919 = ( R18 -sequents );
set D920 = ( TheEqSymbOf R18 );
set D921 = ( TheNorSymbOf R18 );
set D922 = ( AllFormulasOf R18 );
set D923 = ( AllTermsOf R18 );
set D924 = ( AllSymbolsOf R18 );
set D925 = ( R18 -firstChar );
set D926 = ( R18 -multiCat );
let R10 being set;
assume L1598: R10 is R18 -correct;
L1599:
now
let R7 being non  empty set;
set D927 = ( R7 -InterpretersOf R18 );
let C284 being (Element of D927);
let C285 being C284 -satisfied set;
let R28 being  wff (string of R18);
set D928 = [ C285 , R28 ];
set D929 = ( C284 -TermEval );
set D930 = ( R7 -deltaInterpreter );
L1600: (( ( D928 `1 ) \+\ C285 ) = ( {} ) & ( ( D928 `2 ) \+\ R28 ) = ( {} ));
assume L1601: D928 in ( D917 . R10 );
L1602: (D928 in D919 & [ R10 , D928 ] in D918) by L1601 , L537;
L1603: R10 in ( dom D918 ) by L1602 , XTUPLE_0:def 12;
reconsider D931 = R10 as R18 -correct (Subset of D919) by L1603 , L1598;
reconsider D932 = D928 as (Element of D919) by L1601 , L537;
L1604: D932 Rule3e D931 by L1602 , L456;
consider C286 being  relational (Element of R18), C287 , C288 being ( abs ( ar C286 ) ) -element (Element of ( D923 * )) such that L1605: (( D932 `1 ) = ( { ( C286 -compound C287 ) } \/ { ( ( <* D920 *> ^ ( B241 . B240 ) ) ^ ( B242 . B240 ) ) where B240 is (Element of ( Seg ( abs ( ar C286 ) ) )) , B241 , B242 is (Function of ( Seg ( abs ( ar C286 ) ) ) , ( ( D924 * ) \ { ( {} ) } )) : (B241 = C287 & B242 = C288) } ) & ( D932 `2 ) = ( C286 -compound C288 )) by L1604 , L412;
reconsider D933 = R28 as  0wff (string of R18) by L1600 , L1605;
reconsider D934 = ( C286 -compound C287 ) as  0wff (string of R18);
reconsider D935 = ( D925 . D933 ) as  relational (Element of R18);
reconsider D936 = ( { ( ( <* D920 *> ^ ( B244 . B243 ) ) ^ ( B245 . B243 ) ) where B243 is (Element of ( Seg ( abs ( ar C286 ) ) )) , B244 , B245 is (Function of ( Seg ( abs ( ar C286 ) ) ) , ( ( D924 * ) \ { ( {} ) } )) : (B244 = C287 & B245 = C288) } null { D934 } ) as (Subset of C285) by L1605 , L1600;
L1606: (( ( ( <* C286 *> ^ ( D926 . C287 ) ) . 1 ) \+\ C286 ) = ( {} ) & ( ( ( <* C286 *> ^ ( D926 . C288 ) ) . 1 ) \+\ C286 ) = ( {} ));
L1607: (( ( <* C286 *> ^ ( D926 . C287 ) ) . 1 ) = C286 & ( ( <* C286 *> ^ ( D926 . C288 ) ) . 1 ) = C286 & D933 = ( <* C286 *> ^ ( D926 . C288 ) )) by L1606 , L1605 , L1600 , FOMODEL0:29;
L1608: (( D925 . D934 ) = C286 & D935 = C286 & D933 = ( <* C286 *> ^ ( D926 . C288 ) )) by L1607 , FOMODEL0:6;
L1609: (C287 = ( SubTerms D934 ) & C288 = ( SubTerms D933 )) by L1608 , FOMODEL1:def 38;
reconsider D937 = ( { D934 } null D936 ) as (Subset of C285) by L1605 , L1600;
L1610: { D934 } = D937;
L1611:
now
set D938 = ( D929 * C287 );
set D939 = ( D929 * C288 );
L1612: ( len D938 ) = ( abs ( ar C286 ) ) by CARD_1:def 7;
thus L1613: ( len D939 ) = ( len D938 ) by L1612 , CARD_1:def 7;
let R1 being Nat;
assume L1614: (1 <= R1 & R1 <= ( len D938 ));
L1615: (1 <= R1 & R1 <= ( abs ( ar C286 ) )) by L1614 , CARD_1:def 7;
reconsider D940 = R1 as (Element of ( Seg ( abs ( ar C286 ) ) )) by L1615 , FINSEQ_1:1;
L1616: ( R1 - R1 ) <= ( ( abs ( ar C286 ) ) - R1 ) by L1615 , XREAL_1:9;
reconsider D941 = ( ( abs ( ar C286 ) ) - R1 ) as Nat by L1616;
reconsider D942 = R1 as non  zero Nat by L1614;
L1617: (( dom ( C287 null ( 0 ) ) ) = ( Seg ( ( abs ( ar C286 ) ) + ( 0 ) ) ) & ( rng C287 ) c= ( ( D924 * ) \ { ( {} ) } ) & ( dom ( C288 null ( 0 ) ) ) = ( Seg ( ( abs ( ar C286 ) ) + ( 0 ) ) ) & ( rng C288 ) c= ( ( D924 * ) \ { ( {} ) } )) by PARTFUN1:def 2 , RELAT_1:def 19;
L1618: (C287 is (Element of ( Funcs (( Seg ( abs ( ar C286 ) ) ) , ( ( D924 * ) \ { ( {} ) } )) )) & C288 is (Element of ( Funcs (( Seg ( abs ( ar C286 ) ) ) , ( ( D924 * ) \ { ( {} ) } )) ))) by L1617 , FUNCT_2:def 2;
reconsider D943 = C287 , D944 = C288 as (Function of ( Seg ( abs ( ar C286 ) ) ) , ( ( D924 * ) \ { ( {} ) } )) by L1618;
L1619: (C287 is ( D942 + D941 ) -element & C288 is ( D942 + D941 ) -element);
L1620: (( { ( C287 . D942 ) } \ D923 ) = ( {} ) & ( { ( C288 . D942 ) } \ D923 ) = ( {} )) by L1619;
L1621: (( C287 . R1 ) in D923 & ( C288 . R1 ) in D923) by L1620 , ZFMISC_1:60;
reconsider D945 = ( C287 . R1 ) , D946 = ( C288 . R1 ) as  termal (string of R18) by L1621;
reconsider D947 = ( ( <* D920 *> ^ D945 ) ^ D946 ) as  0wff (string of R18);
L1622: (( ( D929 . ( D943 . D940 ) ) \+\ ( ( D929 * D943 ) . D940 ) ) = ( {} ) & ( ( D929 . ( D944 . D940 ) ) \+\ ( ( D929 * D944 ) . D940 ) ) = ( {} ));
L1623: (( D929 . ( D943 . D940 ) ) = ( ( D929 * D943 ) . D940 ) & ( D929 . ( D944 . D940 ) ) = ( ( D929 * D944 ) . D940 )) by L1622 , FOMODEL0:29;
set D948 = <* D945 , D946 *>;
L1624: ( ( <* D920 *> ^ ( D943 . D940 ) ) ^ ( D944 . D940 ) ) in D936;
L1625: ( C284 -TruthEval D947 ) = 1 by L1624 , FOMODEL2:def 42;
thus L1626: ( D938 . R1 ) = ( D939 . R1 ) by L1625 , L1623 , L1462;
end;
per cases ;
suppose L1627: D935 = D920;

L1628: ( C284 -AtomicEval D933 ) = ( C284 -AtomicEval D934 ) by L1608 , L1611 , L1609 , FINSEQ_1:14;
thus L1629: ( C284 -TruthEval R28 ) = 1 by L1628 , L1610 , FOMODEL2:27;
end;
suppose L1630: D935 <> D920;

L1631: ( C284 -AtomicEval D933 ) = ( C284 -AtomicEval D934 ) by L1608 , L1611 , L1609 , FINSEQ_1:14;
thus L1632: ( C284 -TruthEval R28 ) = 1 by L1631 , L1610 , FOMODEL2:27;
end;
end;
thus L1634: ( D917 . R10 ) is R18 -correct by L1599 , FOMODEL2:def 44;
end;
thus L1635: thesis by L1597 , L1469;
end;
registration
let R18 being Language;
cluster ( R#3e R18 ) ->  Correct for (Rule of R18);
coherence by L1596;
end;
L1637: (for R18 being Language holds ( R#4 R18 ) is  Correct)
proof
let R18 being Language;
L1638:
now
set D949 = ( R#4 R18 );
set D950 = ( P#4 R18 );
set D951 = ( R18 -sequents );
set D952 = ( TheEqSymbOf R18 );
set D953 = ( TheNorSymbOf R18 );
set D954 = ( AllFormulasOf R18 );
set D955 = ( AllTermsOf R18 );
set D956 = ( AllSymbolsOf R18 );
set D957 = ( R18 -firstChar );
let R10 being set;
assume L1639: R10 is R18 -correct;
L1640:
now
let R7 being non  empty set;
set D958 = ( R7 -InterpretersOf R18 );
let C289 being (Element of D958);
let C290 being C289 -satisfied set;
let R28 being  wff (string of R18);
set D959 = [ C290 , R28 ];
L1641: (( ( D959 `1 ) \+\ C290 ) = ( {} ) & ( ( D959 `2 ) \+\ R28 ) = ( {} ));
assume L1642: D959 in ( D949 . R10 );
L1643: (D959 in D951 & [ R10 , D959 ] in D950) by L1642 , L537;
L1644: R10 in ( dom D950 ) by L1643 , XTUPLE_0:def 12;
reconsider D960 = R10 as R18 -correct (Subset of D951) by L1644 , L1639;
reconsider D961 = D959 as (Element of D951) by L1642 , L537;
L1645: D961 Rule4 D960 by L1643 , L462;
consider C291 being  literal (Element of R18), C292 being  wff (string of R18), C293 being  termal (string of R18) such that L1646: (( D961 `1 ) = { ( (C291 , C293) SubstIn C292 ) } & ( D961 `2 ) = ( <* C291 *> ^ C292 )) by L1645 , L413;
reconsider D962 = C293 as (Element of D955) by FOMODEL1:def 32;
reconsider D963 = ( (C291 , D962) SubstIn C292 ) as  wff (string of R18);
reconsider D964 = ( ( C289 -TermEval ) . D962 ) as (Element of R7);
reconsider D965 = ( (C291 , D964) ReassignIn C289 ) as (Element of D958);
L1647: (C290 = { D963 } & R28 = ( <* C291 *> ^ C292 )) by L1646 , L1641;
L1648: 1 = ( C289 -TruthEval D963 ) by L1647 , FOMODEL2:27
.= ( D965 -TruthEval C292 ) by FOMODEL3:10;
thus L1649: ( C289 -TruthEval R28 ) = 1 by L1648 , L1647 , FOMODEL2:19;
end;
thus L1650: ( D949 . R10 ) is R18 -correct by L1640 , FOMODEL2:def 44;
end;
thus L1651: thesis by L1638 , L1469;
end;
registration
let R18 being Language;
cluster ( R#4 R18 ) ->  Correct for (Rule of R18);
coherence by L1637;
end;
L1653: (for R18 being Language holds ( R#5 R18 ) is  Correct)
proof
let R18 being Language;
L1654:
now
set D966 = ( R#5 R18 );
set D967 = ( P#5 R18 );
set D968 = ( R18 -sequents );
set D969 = ( TheEqSymbOf R18 );
set D970 = ( TheNorSymbOf R18 );
set D971 = ( AllFormulasOf R18 );
set D972 = ( AllTermsOf R18 );
set D973 = ( AllSymbolsOf R18 );
set D974 = ( R18 -firstChar );
set D975 = ( OwnSymbolsOf R18 );
let R10 being set;
assume L1655: R10 is R18 -correct;
L1656:
now
let R7 being non  empty set;
set D976 = ( R7 -InterpretersOf R18 );
let C294 being (Element of D976);
let C295 being C294 -satisfied set;
let R28 being  wff (string of R18);
set D977 = [ C295 , R28 ];
L1657: (( ( D977 `1 ) \+\ C295 ) = ( {} ) & ( ( D977 `2 ) \+\ R28 ) = ( {} ));
L1658: (( dom D967 ) c= ( bool D968 ) & ( D977 `1 ) = C295 & ( D977 `2 ) = R28);
assume L1659: D977 in ( D966 . R10 );
L1660: (D977 in D968 & [ R10 , D977 ] in D967) by L1659 , L537;
L1661: R10 in ( dom D967 ) by L1660 , XTUPLE_0:def 12;
reconsider D978 = R10 as R18 -correct (Subset of D968) by L1661 , L1655;
reconsider D979 = D977 as (Element of D968) by L1659 , L537;
L1662: D979 Rule5 D978 by L1660 , L468;
consider C296 , C297 being  literal (Element of R18), R16 being set, R48 being FinSequence such that L1663: (( D979 `1 ) = ( R16 \/ { ( <* C296 *> ^ R48 ) } ) & C297 is ( ( R16 \/ { R48 } ) \/ { ( D979 `2 ) } ) -absent & [ ( R16 \/ { ( ( C296 SubstWith C297 ) . R48 ) } ) , ( D979 `2 ) ] in D978) by L1662 , L414;
L1664: ( { ( <* C296 *> ^ R48 ) } null R16 ) c= D971 by L1663 , L1090;
L1665: ( <* C296 *> ^ R48 ) in D971 by L1664 , ZFMISC_1:31;
reconsider D980 = ( <* C296 *> ^ R48 ) as  wff (string of R18) by L1665;
L1666: ( C296 \+\ ( D980 . 1 ) ) = ( {} );
L1667: C296 = ( D980 . 1 ) by L1666 , FOMODEL0:29
.= ( D974 . D980 ) by FOMODEL0:6;
reconsider D981 = D980 as non  0wff  exal  wff (string of R18) by L1667 , FOMODEL2:def 32;
reconsider D982 = ( head D981 ) as  wff (string of R18);
L1668: ( { R28 } null ( R16 \/ { D982 } ) ) = { R28 };
reconsider D983 = { R28 } as non  empty (Subset of ( ( R16 \/ { D982 } ) \/ { R28 } )) by L1668;
L1669: ( { D982 } null ( R16 \/ { R28 } ) ) is (Subset of ( ( R16 \/ { D982 } ) \/ { R28 } )) by XBOOLE_1:4;
reconsider D984 = { D982 } as non  empty (Subset of ( ( R16 \/ { D982 } ) \/ { R28 } )) by L1669;
L1670: ( R16 \/ ( { D982 } \/ { R28 } ) ) = ( ( R16 \/ { D982 } ) \/ { R28 } ) by XBOOLE_1:4;
L1671: ( R16 null ( { D982 } \/ { R28 } ) ) c= ( ( R16 \/ { D982 } ) \/ { R28 } ) by L1670;
reconsider D985 = R16 as (Subset of ( ( R16 \/ { D982 } ) \/ { R28 } )) by L1671;
L1672: D981 = ( ( <* C296 *> ^ D982 ) ^ ( tail D981 ) ) by L1667 , FOMODEL2:23
.= ( <* C296 *> ^ D982 );
L1673: D982 = R48 by L1672 , FOMODEL0:41;
L1674: (C297 is ( D983 null ( ( R16 \/ { D982 } ) \/ { R28 } ) ) -absent & C297 is ( D984 null ( ( R16 \/ { D982 } ) \/ { R28 } ) ) -absent & C297 is ( D985 null ( ( R16 \/ { D982 } ) \/ { R28 } ) ) -absent) by L1673 , L1663 , L1658;
reconsider D986 = ( (C296 , C297) -SymbolSubstIn D982 ) as  wff (string of R18);
reconsider D987 = ( R16 null { D981 } ) , D988 = ( { D981 } null R16 ) as C294 -satisfied (Subset of C295) by L1663 , L1657;
L1675: D988 = { D981 };
L1676: ( C294 -TruthEval D981 ) = 1 by L1675 , FOMODEL2:27;
consider R34 being (Element of R7) such that L1677: 1 = ( ( (C296 , R34) ReassignIn C294 ) -TruthEval D982 ) by L1676 , L1672 , FOMODEL2:19;
set D989 = ( C297 .--> ( ( {} ) .--> R34 ) );
reconsider D990 = ( (C296 , R34) ReassignIn C294 ) , D991 = ( (C297 , R34) ReassignIn C294 ) as (Element of D976);
L1678: (not C297 in ( rng D982 )) by L1674 , FOMODEL2:28;
L1679: ( D991 -TruthEval D986 ) = 1 by L1678 , L1677 , FOMODEL3:9;
reconsider D992 = { D986 } as D991 -satisfied set by L1679 , FOMODEL2:27;
L1680: (not C297 in ( rng R28 )) by L1674 , FOMODEL2:28;
L1681: { C297 } misses ( rng R28 ) by L1680 , ZFMISC_1:50;
L1682: ( dom D989 ) misses ( rng R28 ) by L1681 , FUNCOP_1:13;
L1683: ( D991 | ( rng R28 ) ) = ( ( C294 | ( rng R28 ) ) +* ( D989 | ( rng R28 ) ) ) by FUNCT_4:71
.= ( ( C294 | ( rng R28 ) ) +* ( {} ) ) by L1682 , RELAT_1:66
.= ( C294 | ( rng R28 ) );
L1684: ( C294 | ( ( rng R28 ) /\ D975 ) ) = ( ( D991 | ( rng R28 ) ) | D975 ) by L1683 , RELAT_1:71
.= ( D991 | ( ( rng R28 ) /\ D975 ) ) by RELAT_1:71;
L1685: (C297 is D985 -absent & D987 is C294 -satisfied) by L1673 , L1663 , L1658;
reconsider D993 = D985 as D991 -satisfied (Subset of C295) by L1685 , FOMODEL3:14;
reconsider D994 = ( D993 \/ D992 ) as D991 -satisfied set;
L1686: [ D994 , R28 ] in D978 by L1663 , L1673 , L1658 , FOMODEL0:def 23;
thus L1687: 1 = ( D991 -TruthEval R28 ) by L1686 , FOMODEL2:def 44
.= ( C294 -TruthEval R28 ) by L1684 , FOMODEL3:13;
end;
thus L1688: ( D966 . R10 ) is R18 -correct by L1656 , FOMODEL2:def 44;
end;
thus L1689: thesis by L1654 , L1469;
end;
registration
let R18 being Language;
cluster ( R#5 R18 ) ->  Correct for (Rule of R18);
coherence by L1653;
end;
L1691: (for R18 being Language holds ( R#6 R18 ) is  Correct)
proof
let R18 being Language;
L1692:
now
set D995 = ( R#6 R18 );
set D996 = ( P#6 R18 );
set D997 = ( R18 -sequents );
set D998 = ( TheEqSymbOf R18 );
set D999 = ( TheNorSymbOf R18 );
let R10 being set;
assume L1693: R10 is R18 -correct;
L1694:
now
let R7 being non  empty set;
set D1000 = ( R7 -InterpretersOf R18 );
let C298 being (Element of D1000);
let C299 being C298 -satisfied set;
let R28 being  wff (string of R18);
set D1001 = [ C299 , R28 ];
L1695: (( dom D996 ) c= ( bool D997 ) & ( D1001 `1 ) = C299 & ( D1001 `2 ) = R28);
assume L1696: D1001 in ( D995 . R10 );
L1697: (D1001 in D997 & [ R10 , D1001 ] in D996) by L1696 , L537;
L1698: R10 in ( dom D996 ) by L1697 , XTUPLE_0:def 12;
reconsider D1002 = R10 as R18 -correct (Subset of D997) by L1698 , L1693;
reconsider D1003 = D1001 as (Element of D997) by L1696 , L537;
L1699: D1003 Rule6 D1002 by L1697 , L474;
consider C300 , C301 being set, C302 , C303 being  wff (string of R18) such that L1700: (C300 in D1002 & C301 in D1002 & ( C300 `1 ) = ( C301 `1 ) & ( C301 `1 ) = ( D1003 `1 ) & ( C300 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C302 ) ^ C302 ) & ( C301 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C303 ) ^ C303 ) & ( D1003 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C302 ) ^ C303 )) by L1699 , L415;
L1701: ([ C299 , ( ( <* D999 *> ^ C302 ) ^ C302 ) ] in D1002 & [ C299 , ( ( <* D999 *> ^ C303 ) ^ C303 ) ] in D1002 & R28 = ( ( <* D999 *> ^ C302 ) ^ C303 )) by L1700 , L1695 , MCART_1:21;
L1702: (( C298 -TruthEval ( ( <* D999 *> ^ C302 ) ^ C302 ) ) = 1 & ( C298 -TruthEval ( ( <* D999 *> ^ C303 ) ^ C303 ) ) = 1) by L1701 , FOMODEL2:def 44;
L1703: (( C298 -TruthEval C302 ) = ( 0 ) & ( C298 -TruthEval C303 ) = ( 0 )) by L1702 , FOMODEL2:19;
thus L1704: ( C298 -TruthEval R28 ) = 1 by L1703 , L1700 , L1695 , FOMODEL2:19;
end;
thus L1705: ( D995 . R10 ) is R18 -correct by L1694 , FOMODEL2:def 44;
end;
thus L1706: thesis by L1692 , L1469;
end;
registration
let R18 being Language;
cluster ( R#6 R18 ) ->  Correct for (Rule of R18);
coherence by L1691;
end;
L1708: (for R18 being Language holds ( R#7 R18 ) is  Correct)
proof
let R18 being Language;
L1709:
now
set D1004 = ( R#7 R18 );
set D1005 = ( P#7 R18 );
set D1006 = ( R18 -sequents );
set D1007 = ( TheEqSymbOf R18 );
set D1008 = ( TheNorSymbOf R18 );
let R10 being set;
assume L1710: R10 is R18 -correct;
L1711:
now
let R7 being non  empty set;
set D1009 = ( R7 -InterpretersOf R18 );
let C304 being (Element of D1009);
let C305 being C304 -satisfied set;
let R28 being  wff (string of R18);
set D1010 = [ C305 , R28 ];
L1712: (( dom D1005 ) c= ( bool D1006 ) & ( D1010 `1 ) = C305 & ( D1010 `2 ) = R28);
assume L1713: D1010 in ( D1004 . R10 );
L1714: (D1010 in D1006 & [ R10 , D1010 ] in D1005) by L1713 , L537;
L1715: R10 in ( dom D1005 ) by L1714 , XTUPLE_0:def 12;
reconsider D1011 = R10 as R18 -correct (Subset of D1006) by L1715 , L1710;
reconsider D1012 = D1010 as (Element of D1006) by L1713 , L537;
L1716: D1012 Rule7 D1011 by L1714 , L480;
consider C306 being set, C307 , C308 being  wff (string of R18) such that L1717: (C306 in D1011 & ( C306 `1 ) = ( D1012 `1 ) & ( C306 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C307 ) ^ C308 ) & ( D1012 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C308 ) ^ C307 )) by L1716 , L416;
L1718: (R28 = ( ( <* D1008 *> ^ C308 ) ^ C307 ) & [ C305 , ( ( <* D1008 *> ^ C307 ) ^ C308 ) ] in D1011) by L1712 , L1717 , MCART_1:21;
L1719: ( C304 -TruthEval ( ( <* D1008 *> ^ C307 ) ^ C308 ) ) = 1 by L1718 , FOMODEL2:def 44;
L1720: (( C304 -TruthEval C307 ) = ( 0 ) & ( C304 -TruthEval C308 ) = ( 0 )) by L1719 , FOMODEL2:19;
thus L1721: ( C304 -TruthEval R28 ) = 1 by L1720 , L1712 , L1717 , FOMODEL2:19;
end;
thus L1722: ( D1004 . R10 ) is R18 -correct by L1711 , FOMODEL2:def 44;
end;
thus L1723: thesis by L1709 , L1469;
end;
registration
let R18 being Language;
cluster ( R#7 R18 ) ->  Correct for (Rule of R18);
coherence by L1708;
end;
L1725: (for R18 being Language holds ( R#8 R18 ) is  Correct)
proof
let R18 being Language;
L1726:
now
set D1013 = ( R#8 R18 );
set D1014 = ( P#8 R18 );
set D1015 = ( R18 -sequents );
set D1016 = ( TheEqSymbOf R18 );
set D1017 = ( TheNorSymbOf R18 );
let R10 being set;
assume L1727: R10 is R18 -correct;
L1728:
now
let R7 being non  empty set;
set D1018 = ( R7 -InterpretersOf R18 );
let C309 being (Element of D1018);
let C310 being C309 -satisfied set;
let R28 being  wff (string of R18);
set D1019 = [ C310 , R28 ];
L1729: (( ( D1019 `1 ) \+\ C310 ) = ( {} ) & ( ( D1019 `2 ) \+\ R28 ) = ( {} ));
assume L1730: D1019 in ( D1013 . R10 );
L1731: (D1019 in D1015 & [ R10 , D1019 ] in D1014) by L1730 , L537;
L1732: R10 in ( dom D1014 ) by L1731 , XTUPLE_0:def 12;
reconsider D1020 = R10 as R18 -correct (Subset of D1015) by L1732 , L1727;
reconsider D1021 = D1019 as (Element of D1015) by L1730 , L537;
L1733: D1021 Rule8 D1020 by L1731 , L486;
consider C311 , C312 being set, C313 , C314 , C315 being  wff (string of R18) such that L1734: (C311 in D1020 & C312 in D1020 & ( C311 `1 ) = ( C312 `1 ) & ( C311 `2 ) = C314 & ( C312 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C314 ) ^ C315 ) & ( { C313 } \/ ( D1021 `1 ) ) = ( C311 `1 ) & ( D1021 `2 ) = ( ( <* ( TheNorSymbOf R18 ) *> ^ C313 ) ^ C313 )) by L1733 , L417;
reconsider D1022 = D1020 as non  empty (Subset of D1015) by L1734;
reconsider D1023 = C311 , D1024 = C312 as (Element of D1022) by L1734;
reconsider D1025 = ( D1023 `1 ) as R18 -premises-like set;
L1735: (( { C313 } \/ C310 ) = D1025 & R28 = ( ( <* D1017 *> ^ C313 ) ^ C313 )) by L1734 , L1729;
L1736:
now
assume L1737: ( C309 -TruthEval C313 ) = 1;
reconsider D1026 = { C313 } as C309 -satisfied set by L1737 , FOMODEL2:27;
L1738: ( D1026 \/ C310 ) is C309 -satisfied;
reconsider D1027 = D1025 as C309 -satisfied set by L1738 , L1734 , L1729;
L1739: ([ D1027 , C314 ] in D1022 & [ D1027 , ( ( <* D1017 *> ^ C314 ) ^ C315 ) ] in D1022) by L1734 , MCART_1:21;
L1740: (( C309 -TruthEval C314 ) = 1 & ( C309 -TruthEval ( ( <* D1017 *> ^ C314 ) ^ C315 ) ) = 1) by L1739 , FOMODEL2:def 44;
thus L1741: contradiction by L1740 , FOMODEL2:19;
end;
L1742: ( C309 -TruthEval C313 ) = ( 0 ) by L1736 , FOMODEL0:39;
thus L1743: ( C309 -TruthEval R28 ) = 1 by L1742 , L1735 , FOMODEL2:19;
end;
thus L1744: ( D1013 . R10 ) is R18 -correct by L1728 , FOMODEL2:def 44;
end;
thus L1745: thesis by L1726 , L1469;
end;
registration
let R18 being Language;
cluster ( R#8 R18 ) ->  Correct for (Rule of R18);
coherence by L1725;
end;
theorem
L1747: (for R18 being Language holds (for R74 being (RuleSet of R18) holds ((for B246 being (Rule of R18) holds (B246 in R74 implies B246 is  Correct)) implies R74 is  Correct)))
proof
let R18 being Language;
let R74 being (RuleSet of R18);
set D1028 = ( R18 -sequents );
set D1029 = ( OneStep R74 );
L1748: ( ( {} ) null R18 ) is R18 -correct;
reconsider D1030 = ( ( {} ) null D1028 ) as R18 -correct (Subset of D1028) by L1748;
L1749: ( dom D1029 ) = ( bool D1028 ) by FUNCT_2:def 1;
reconsider D1031 = ( rng D1029 ) as (Subset of ( bool D1028 )) by RELAT_1:def 19;
assume L1750: (for B247 being (Rule of R18) holds (B247 in R74 implies B247 is  Correct));
defpred S36[ Nat ] means (for B248 being R18 -correct (Subset of D1028) holds ( ( ($1 , R74) -derivables ) . B248 ) is R18 -correct);
L1751: S36[ ( 0 ) ]
proof
set D1032 = ( (( 0 ) , R74) -derivables );
L1752: D1032 = ( id ( field D1029 ) ) by FUNCT_7:68
.= ( id ( ( bool D1028 ) \/ D1031 ) ) by L1749
.= ( id ( bool D1028 ) );
let C316 being R18 -correct (Subset of D1028);
L1753: ( ( ( id ( bool D1028 ) ) . C316 ) \+\ C316 ) = ( {} );
thus L1754: thesis by L1753 , L1752 , FOMODEL0:29;
end;
L1755: (for R3 being Nat holds (S36[ R3 ] implies S36[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
assume L1756: S36[ R3 ];
let C317 being R18 -correct (Subset of D1028);
set D1033 = ( (( R3 + 1 ) , R74) -derivables );
set D1034 = ( (R3 , R74) -derivables );
L1757: ( dom D1034 ) = ( bool D1028 ) by FUNCT_2:def 1;
reconsider D1035 = ( D1034 . C317 ) as R18 -correct (Subset of D1028) by L1756;
L1758: D1033 = ( D1029 * D1034 ) by FUNCT_7:71;
L1759:
now
let R7 being non  empty set;
set D1036 = ( R7 -InterpretersOf R18 );
let C318 being (Element of D1036);
let C319 being C318 -satisfied set;
let R31 being  wff (string of R18);
assume L1760: [ C319 , R31 ] in ( D1033 . C317 );
set D1037 = { ( B249 .: { D1035 } ) where B249 is (Subset of [: ( bool D1028 ) , ( bool D1028 ) :]) : B249 in R74 };
L1761: ( D1033 . C317 ) = ( D1029 . D1035 ) by L1757 , L1758 , FUNCT_1:13
.= ( union ( union D1037 ) ) by L184;
consider R13 being set such that L1762: ([ C319 , R31 ] in R13 & R13 in ( union D1037 )) by L1761 , L1760 , TARSKI:def 4;
consider R16 being set such that L1763: (R13 in R16 & R16 in D1037) by L1762 , TARSKI:def 4;
consider C320 being (Subset of [: ( bool D1028 ) , ( bool D1028 ) :]) such that L1764: (R16 = ( C320 .: { D1035 } ) & C320 in R74) by L1763;
reconsider D1038 = C320 as  Correct (Rule of R18) by L1750 , L1764;
reconsider D1039 = ( D1038 . D1035 ) as R18 -correct (Subset of D1028) by L1469;
L1765: ( dom D1038 ) = ( bool D1028 ) by FUNCT_2:def 1;
L1766: (R16 = ( Im (C320 , D1035) ) & ( Im (D1038 , D1035) ) = { ( D1038 . D1035 ) }) by L1765 , L1764 , FUNCT_1:59;
L1767: [ C319 , R31 ] in D1039 by L1766 , L1762 , L1763 , TARSKI:def 1;
thus L1768: ( C318 -TruthEval R31 ) = 1 by L1767 , FOMODEL2:def 44;
end;
thus L1769: thesis by L1759 , FOMODEL2:def 44;
end;
L1770: (for R3 being Nat holds S36[ R3 ]) from NAT_1:sch 2(L1751 , L1755);
L1771:
now
let R31 being  wff (string of R18);
let R10 being set;
assume L1772: R31 is (R10 , R74)-provable;
consider C321 being set, R2 being Nat such that L1773: (C321 c= R10 & [ C321 , R31 ] is (R2 , ( {} ) , R74)-derivable) by L1772 , L1034;
reconsider D1040 = C321 as (Subset of R10) by L1773;
reconsider D1041 = [ C321 , R31 ] as (Element of D1028) by L23 , L1773;
reconsider D1042 = ( ( (R2 , R74) -derivables ) . D1030 ) as R18 -correct (Subset of D1028) by L1770;
thus L1774:now
let R7 being non  empty set;
set D1043 = ( R7 -InterpretersOf R18 );
let C322 being (Element of D1043);
assume L1775: R10 is C322 -satisfied;
reconsider D1044 = R10 as C322 -satisfied set by L1775;
reconsider D1045 = D1040 as C322 -satisfied (Subset of D1044);
L1776: [ D1045 , R31 ] in D1042 by L1773 , L63;
thus L1777: ( C322 -TruthEval R31 ) = 1 by L1776 , FOMODEL2:def 44;
end;
end;
thus L1775: R74 is  Correct by L1771 , L1377;
end;
registration
let R18 being Language;
let C323 being  Correct (Rule of R18);
cluster { C323 } ->  Correct for (RuleSet of R18);
coherence
proof
set D1046 = { C323 };
L1776: (for B250 being (Rule of R18) holds (B250 in D1046 implies B250 is  Correct)) by TARSKI:def 1;
thus L1777: thesis by L1776 , L1747;
end;
end;
registration
let R18 being Language;
cluster ( R18 -rules ) ->  Correct for (RuleSet of R18);
coherence
proof
set D1047 = { ( R#0 R18 ) , ( R#1 R18 ) , ( R#2 R18 ) , ( R#3a R18 ) , ( R#3b R18 ) , ( R#3d R18 ) , ( R#3e R18 ) , ( R#4 R18 ) };
set D1048 = { ( R#5 R18 ) , ( R#6 R18 ) , ( R#7 R18 ) , ( R#8 R18 ) };
set D1049 = ( R18 -rules );
L1779:
now
let C324 being (Rule of R18);
assume L1780: C324 in D1049;
L1781: (C324 in D1047 or C324 in D1048) by L1780 , XBOOLE_0:def 3;
thus L1782: C324 is  Correct by L1781 , ENUMSET1:def 2 , ENUMSET1:def 6;
end;
thus L1783: thesis by L1779 , L1747;
end;
end;
registration
let R18 being Language;
cluster ( R#9 R18 ) ->  isotone for (Rule of R18);
coherence
proof
set D1050 = ( R#9 R18 );
set D1051 = ( R18 -sequents );
L1785:
now
let R58 being (Subset of ( R18 -sequents ));
let R60 being (Subset of ( R18 -sequents ));
set D1052 = R58;
set D1053 = R60;
assume L1786: D1052 c= D1053;
L1787:
now
let R13 being set;
assume L1788: R13 in ( D1050 . D1052 );
L1789: (R13 in D1051 & [ D1052 , R13 ] in ( P#9 R18 )) by L1788 , L537;
reconsider D1054 = R13 as (Element of D1051) by L1788;
L1790: D1054 Rule9 D1052 by L1789 , L492;
consider C325 being set, C326 being  wff (string of R18) such that L1791: (C325 in R58 & ( D1054 `2 ) = C326 & ( C325 `1 ) = ( D1054 `1 ) & ( C325 `2 ) = ( xnot ( xnot C326 ) )) by L1790 , L418;
L1792: D1054 Rule9 D1053 by L1791 , L418 , L1786;
L1793: [ D1053 , D1054 ] in ( P#9 R18 ) by L1792 , L492;
thus L1794: R13 in ( D1050 . D1053 ) by L1793 , L959;
end;
thus L1795: ( D1050 . D1052 ) c= ( D1050 . D1053 ) by L1787 , TARSKI:def 3;
end;
thus L1796: thesis by L1785 , L72;
end;
end;
registration
let R18 being Language;
let R79 being R18 -premises-like set;
let R31 being  wff (string of R18);
cluster ( [ R79 , R31 ] null 1 ) -> (1 , { [ R79 , ( xnot ( xnot R31 ) ) ] } , { ( R#9 R18 ) })-derivable for set;
coherence
proof
set D1055 = ( TheNorSymbOf R18 );
set D1056 = ( xnot R31 );
set D1057 = ( xnot D1056 );
set D1058 = [ R79 , D1057 ];
set D1059 = { D1058 };
set D1060 = [ R79 , R31 ];
set D1061 = ( R18 -sequents );
reconsider D1062 = D1060 as (Element of D1061) by L23;
reconsider D1063 = D1059 as (Element of ( bool D1061 )) by L25;
L1798: (( ( D1062 `2 ) \+\ R31 ) = ( {} ) & ( ( D1058 `1 ) \+\ R79 ) = ( {} ) & ( ( D1062 `1 ) \+\ R79 ) = ( {} ) & ( ( D1058 `2 ) \+\ D1057 ) = ( {} ));
L1799: (( D1062 `2 ) = R31 & ( D1058 `1 ) = R79 & ( D1062 `1 ) = R79 & ( D1058 `2 ) = D1057) by L1798 , FOMODEL0:29;
L1800: (( D1058 `1 ) = ( D1062 `1 ) & ( D1062 `2 ) = R31 & ( D1058 `2 ) = D1057 & D1058 in D1063) by L1799 , TARSKI:def 1;
L1801: D1062 Rule9 D1063 by L1800 , L418;
L1802: [ D1063 , D1062 ] in ( P#9 R18 ) by L1801 , L492;
L1803: D1060 in ( ( R#9 R18 ) . D1059 ) by L1802 , L959;
thus L1804: thesis by L1803 , L943;
end;
end;
registration
let R10 being set;
let R18 being Language;
cluster R10 -implied for ( 0 ) -wff ( 0 ) -wff ( 0 ) -wff ( 0 ) -wff (string of R18);
existence
proof
set D1064 = ( TheEqSymbOf R18 );
set D1065 = the  termal (string of R18);
set D1066 = ( ( <* D1064 *> ^ D1065 ) ^ D1065 );
take D1066;
L1806:
now
let R7 being non  empty set;
set D1067 = ( R7 -InterpretersOf R18 );
let C327 being (Element of D1067);
assume L1807: R10 is C327 -satisfied;
set D1068 = ( C327 -TermEval );
L1808: ( D1068 . D1065 ) = ( D1068 . D1065 );
thus L1809: ( C327 -TruthEval D1066 ) = 1 by L1808 , L1462;
end;
thus L1810: thesis by L1806 , FOMODEL2:def 45;
end;
end;
registration
let R10 being set;
let R18 being Language;
cluster R10 -implied for  wff  wff  wff  wff (string of R18);
existence
proof
take the R10 -implied ( 0 ) -wff (string of R18);
thus L1812: thesis;
end;
end;
registration
let R18 being Language;
let R10 being set;
let C328 being R10 -implied  wff (string of R18);
cluster ( xnot ( xnot C328 ) ) -> R10 -implied for  wff  wff  wff  wff (string of R18);
coherence
proof
L1814:
now
let R7 being non  empty set;
set D1069 = ( R7 -InterpretersOf R18 );
let C329 being (Element of D1069);
set D1070 = ( C329 -TruthEval C328 );
set D1071 = ( xnot C328 );
set D1072 = ( xnot D1071 );
set D1073 = ( C329 -TruthEval D1071 );
set D1074 = ( C329 -TruthEval D1072 );
L1815: (( ( 'not' D1070 ) \+\ D1073 ) = ( {} ) & ( ( 'not' D1073 ) \+\ D1074 ) = ( {} ));
L1816: (D1073 = ( 'not' D1070 ) & D1074 = ( 'not' D1073 )) by L1815 , FOMODEL0:29;
assume L1817: R10 is C329 -satisfied;
thus L1818: D1074 = 1 by L1817 , L1816 , FOMODEL2:def 45;
end;
thus L1819: thesis by L1814 , FOMODEL2:def 45;
end;
end;
definition
let R10 being set;
let R18 being Language;
let R31 being  wff (string of R18);
attr R31 is R10 -provable
means
:L1821: R31 is (R10 , ( { ( R#9 R18 ) } \/ ( R18 -rules ) ))-provable;
end;
begin
definition
let C330 being  functional set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C331 being (Function of ( NAT ) , ( ExFormulasOf R18 ));
set D1075 = ( AllSymbolsOf R18 );
set D1076 = ( ExFormulasOf R18 );
set D1077 = ( AllFormulasOf R18 );
set D1078 = ( C330 \/ D1077 );
set D1079 = ( bool D1078 );
func (R74 , C331) AddWitnessesTo C330 -> (Function of ( NAT ) , ( bool ( C330 \/ ( AllFormulasOf R18 ) ) )) means 
:L1823: (( it . ( 0 ) ) = C330 & (for R5 being (Element of ( NAT )) holds ( it . ( R5 + 1 ) ) = ( (R74 , ( C331 . R5 )) AddAsWitnessTo ( it . R5 ) )));
existence
proof
reconsider D1080 = ( C330 null D1077 ) as (Element of D1079);
deffunc H6(Nat , (Element of D1079)) = ( D1078 typed/\ ( (R74 , ( C331 . $1 )) AddAsWitnessTo $2 ) );
consider C332 being (Function of ( NAT ) , D1079) such that L1824: (( C332 . ( 0 ) ) = D1080 & (for R3 being Nat holds ( C332 . ( R3 + 1 ) ) = H6(R3 , (( C332 . R3 ) qua (Element of D1079))))) from NAT_1:sch 12;
take C332;
L1825:
now
let R3 being Nat;
reconsider D1081 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
L1826: (( (R74 , ( C331 . D1081 )) AddAsWitnessTo ( C332 . D1081 ) ) c= ( D1077 \/ ( C332 . D1081 ) ) & ( D1077 \/ ( C332 . D1081 ) ) c= ( D1077 \/ D1078 )) by XBOOLE_1:9;
L1827: ( D1077 \/ D1078 ) = ( ( D1077 \/ D1077 ) \/ C330 ) by XBOOLE_1:4
.= D1078;
reconsider D1082 = ( (R74 , ( C331 . D1081 )) AddAsWitnessTo ( C332 . D1081 ) ) as (Subset of D1078) by L1827 , L1826 , XBOOLE_1:1;
L1828: ( C332 . ( R3 + 1 ) ) = ( D1082 null D1078 ) by L1824;
thus L1829: ( C332 . ( R3 + 1 ) ) = ( (R74 , ( C331 . R3 )) AddAsWitnessTo ( C332 . R3 ) ) by L1828;
end;
thus L1830: thesis by L1825 , L1824;
end;
uniqueness
proof
deffunc H7(Nat , (Element of D1079)) = ( (R74 , ( C331 . $1 )) AddAsWitnessTo $2 );
let C333 , C334 being (Function of ( NAT ) , D1079);
assume that
L1831: ( C333 . ( 0 ) ) = C330
and
L1832: (for R5 being (Element of ( NAT )) holds ( C333 . ( R5 + 1 ) ) = H7(R5 , (( C333 . R5 ) qua (Element of D1079))))
and
L1833: ( C334 . ( 0 ) ) = C330
and
L1834: (for R5 being (Element of ( NAT )) holds ( C334 . ( R5 + 1 ) ) = H7(R5 , (( C334 . R5 ) qua (Element of D1079))));
L1835: (for R2 being Nat holds ( C333 . ( R2 + 1 ) ) = H7(R2 , (( C333 . R2 ) qua (Element of D1079))))
proof
let R2 being Nat;
reconsider D1083 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
L1836: ( C333 . ( D1083 + 1 ) ) = H7(D1083 , (( C333 . D1083 ) qua (Element of D1079))) by L1832;
thus L1837: thesis by L1836;
end;
L1838: (for R2 being Nat holds ( C334 . ( R2 + 1 ) ) = H7(R2 , (( C334 . R2 ) qua (Element of D1079))))
proof
let R2 being Nat;
reconsider D1084 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
L1839: ( C334 . ( D1084 + 1 ) ) = H7(D1084 , (( C334 . D1084 ) qua (Element of D1079))) by L1834;
thus L1840: thesis by L1839;
end;
L1841: ( dom C333 ) = ( NAT ) by FUNCT_2:def 1;
L1842: ( dom C334 ) = ( NAT ) by FUNCT_2:def 1;
thus L1843: C333 = C334 from NAT_1:sch 15(L1841 , L1831 , L1835 , L1842 , L1833 , L1838);
end;
end;
notation
let C335 being  functional set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C336 being (Function of ( NAT ) , ( ExFormulasOf R18 ));
synonym (R74 , C336) addw C335 for (R74 , C336) AddWitnessesTo C335;
end;
L1846: (for R10 being set holds (for R18 being Language holds (for R31 being  wff (string of R18) holds (for R46 being  literal (Element of R18) holds (for R47 being  literal (Element of R18) holds (for R74 being (RuleSet of R18) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74 & ( R10 \/ { ( (R46 , R47) -SymbolSubstIn R31 ) } ) is R74 -inconsistent & R47 is ( R10 \/ { R31 } ) -absent) implies ( R10 \/ { ( <* R46 *> ^ R31 ) } ) is R74 -inconsistent)))))))
proof
let R10 being set;
let R18 being Language;
let R31 being  wff (string of R18);
let R46 being  literal (Element of R18);
let R47 being  literal (Element of R18);
let R74 being (RuleSet of R18);
set D1085 = ( TheEqSymbOf R18 );
set D1086 = ( LettersOf R18 );
set D1087 = ( AllSymbolsOf R18 );
set D1088 = ( R18 -sequents );
set D1089 = ( (R46 , R47) -SymbolSubstIn R31 );
set D1090 = ( R#1 R18 );
set D1091 = ( R#2 R18 );
set D1092 = ( R#5 R18 );
set D1093 = the (Element of ( ( rng R31 ) /\ D1086 ));
L1847: D1093 in D1086 by TARSKI:def 3;
reconsider D1094 = D1093 as  literal (Element of R18) by L1847;
reconsider D1095 = <* D1094 *> as  termal (string of R18);
set D1096 = ( TheNorSymbOf R18 );
reconsider D1097 = ( ( <* D1085 *> ^ D1095 ) ^ D1095 ) as  0wff (string of R18);
L1848: ( rng D1097 ) = ( ( rng ( <* D1085 *> ^ D1095 ) ) \/ ( rng D1095 ) ) by FINSEQ_1:31
.= ( ( ( rng <* D1085 *> ) \/ ( rng D1095 ) ) \/ ( rng D1095 ) ) by FINSEQ_1:31
.= ( ( rng <* D1085 *> ) \/ ( ( rng D1095 ) \/ ( rng D1095 ) ) ) by XBOOLE_1:4
.= ( { D1085 } \/ ( rng D1095 ) ) by FINSEQ_1:38
.= ( { D1085 } \/ { D1094 } ) by FINSEQ_1:38;
reconsider D1098 = D1093 as (Element of ( rng R31 )) by XBOOLE_0:def 4;
L1849: ( { D1098 } \/ { D1085 , D1096 } ) c= ( ( rng R31 ) \/ { D1085 , D1096 } ) by XBOOLE_1:9;
reconsider D1099 = ( xnot D1097 ) as  wff (string of R18);
L1850: ( rng D1099 ) = ( ( rng ( <* D1096 *> ^ D1097 ) ) \/ ( rng D1097 ) ) by FINSEQ_1:31
.= ( ( ( rng <* D1096 *> ) \/ ( rng D1097 ) ) \/ ( rng D1097 ) ) by FINSEQ_1:31
.= ( ( rng <* D1096 *> ) \/ ( ( rng D1097 ) \/ ( rng D1097 ) ) ) by XBOOLE_1:4
.= ( { D1096 } \/ ( rng D1097 ) ) by FINSEQ_1:38
.= ( ( { D1085 } \/ { D1096 } ) \/ { D1094 } ) by L1848 , XBOOLE_1:4
.= ( { D1085 , D1096 } \/ { D1094 } ) by ENUMSET1:1;
assume L1851: (R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74 & ( R10 \/ { D1089 } ) is R74 -inconsistent);
L1852: D1099 is (( R10 \/ { D1089 } ) , R74)-provable by L1851 , L1184;
consider C337 being set, R2 being Nat such that L1853: (C337 c= ( R10 \/ { D1089 } ) & [ C337 , D1099 ] is (R2 , ( {} ) , R74)-derivable) by L1852 , L1034;
reconsider D1100 = [ C337 , D1099 ] as (Element of D1088) by L23 , L1853;
L1854: ( ( D1100 `1 ) \+\ C337 ) = ( {} );
reconsider D1101 = C337 as R18 -premises-like (Subset of ( R10 \/ { D1089 } )) by L1854 , L1853 , FOMODEL0:29;
reconsider D1102 = ( D1101 /\ R10 ) as R18 -premises-like (Subset of R10);
reconsider D1103 = ( D1101 /\ { D1089 } ) as R18 -premises-like (Subset of { D1089 });
L1855: (( { R31 } null R10 ) c= ( R10 \/ { R31 } ) & ( R10 null { R31 } ) c= ( R10 \/ { R31 } ));
reconsider D1104 = R10 , D1105 = { R31 } as (Subset of ( R10 \/ { R31 } )) by L1855;
reconsider D1106 = D1102 as R18 -premises-like (Subset of D1104);
reconsider D1107 = { D1099 } , D1108 = { R31 } as (Subset of ( ( D1087 * ) \ { ( {} ) } ));
assume L1856: R47 is ( R10 \/ { R31 } ) -absent;
L1857: (R47 is D1104 -absent & R47 is D1105 -absent) by L1856;
L1858: (not R47 in ( SymbolsOf ( ( ( D1087 * ) \ { ( {} ) } ) /\ D1108 ) )) by L1857 , FOMODEL2:def 38;
L1859: ((not R47 in ( rng R31 )) & (not R47 in { D1085 , D1096 })) by L1858 , FOMODEL0:45 , TARSKI:def 2;
L1860: (not R47 in ( rng D1099 )) by L1859 , L1850 , L1849 , XBOOLE_0:def 3;
L1861: (not R47 in ( SymbolsOf ( ( ( D1087 * ) \ { ( {} ) } ) /\ D1107 ) )) by L1860 , FOMODEL0:45;
reconsider D1109 = R47 as { D1099 } -absent (Element of R18) by L1861 , FOMODEL2:def 38;
reconsider D1110 = D1109 as ( { R31 } \/ { D1099 } ) -absent  literal (Element of R18) by L1857;
L1862: D1110 is D1106 -absent by L1856;
reconsider D1111 = D1110 as ( D1106 \/ ( { R31 } \/ { D1099 } ) ) -absent  literal (Element of R18) by L1862;
L1863: ( D1106 \/ ( { R31 } \/ { D1099 } ) ) = ( ( D1102 \/ { R31 } ) \/ { D1099 } ) by XBOOLE_1:4;
L1864: D1111 is ( ( D1102 \/ { R31 } ) \/ { D1099 } ) -absent by L1863;
reconsider D1112 = R47 as ( ( D1102 \/ { R31 } ) \/ { D1099 } ) -absent  literal (Element of R18) by L1864;
reconsider D1113 = { D1091 } , D1114 = { D1090 } , D1115 = { D1092 } as (Subset of R74) by L1851 , ZFMISC_1:31;
L1865: (( R74 \/ ( D1114 \/ D1115 ) ) = R74 & D1113 c= R74 & ( {} ) c= ( R10 \/ { ( <* R46 *> ^ R31 ) } ) & ( D1102 \/ { ( <* R46 *> ^ R31 ) } ) c= ( R10 \/ { ( <* R46 *> ^ R31 ) } )) by XBOOLE_1:2 , XBOOLE_1:9;
L1866: ( D1101 null ( R10 \/ { D1089 } ) ) = ( D1102 \/ D1103 ) by XBOOLE_1:23;
L1867: [ ( ( D1102 \/ { ( <* R46 *> ^ R31 ) } ) null D1112 ) , D1099 ] is (1 , { [ ( D1102 \/ { D1089 } ) , D1099 ] } , { ( R#5 R18 ) })-derivable;
L1868: [ ( ( D1102 \/ D1103 ) \/ { D1089 } ) , D1099 ] is (1 , { [ ( D1102 \/ D1103 ) , D1099 ] } , { ( R#1 R18 ) })-derivable;
L1869: [ ( D1102 \/ ( { D1089 } null D1103 ) ) , D1099 ] is (1 , { [ D1101 , D1099 ] } , { ( R#1 R18 ) })-derivable by L1868 , L1866 , XBOOLE_1:4;
L1870: [ ( D1102 \/ { ( <* R46 *> ^ R31 ) } ) , D1099 ] is (( 1 + 1 ) , { [ D1101 , D1099 ] } , ( { ( R#1 R18 ) } \/ { ( R#5 R18 ) } ))-derivable by L1869 , L1867 , L363;
L1871: [ ( D1102 \/ { ( <* R46 *> ^ R31 ) } ) , D1099 ] is (( R2 + 2 ) , ( {} ) , R74)-derivable by L1870 , L1865 , L1851 , L363 , L1853;
L1872: D1099 is (( R10 \/ { ( <* R46 *> ^ R31 ) } ) , R74)-provable by L1871 , L1865 , L1034;
set D1116 = [ ( {} ) , D1097 ];
L1873: ({ [ ( {} ) , ( ( <* D1085 *> ^ D1095 ) ^ D1095 ) ] } is { ( R#2 R18 ) } -derivable & ( ( D1116 `1 ) \+\ ( {} ) ) = ( {} ) & ( ( D1116 `2 ) \+\ D1097 ) = ( {} ));
L1874: D1097 is (( {} ) , { ( R#2 R18 ) })-provable by L1873 , L100;
L1875: D1097 is (( R10 \/ { ( <* R46 *> ^ R31 ) } ) , R74)-provable by L1874 , L1865 , L937;
thus L1876: thesis by L1875 , L1872 , L1170;
end;
theorem
L1877: (for R1 being Nat holds (for R2 being Nat holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B251 being  functional set holds (for B252 being (Function of ( NAT ) , ( ExFormulasOf R18 )) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74 & ( ( LettersOf R18 ) \ ( SymbolsOf ( B251 /\ ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) ) ) ) is  infinite & B251 is R74 -consistent) implies (( ( (R74 , B252) addw B251 ) . R1 ) c= ( ( (R74 , B252) addw B251 ) . ( R1 + R2 ) ) & ( ( LettersOf R18 ) \ ( SymbolsOf ( ( ( (R74 , B252) addw B251 ) . R2 ) /\ ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) ) ) ) is  infinite & ( ( (R74 , B252) addw B251 ) . R2 ) is R74 -consistent))))))))
proof
let R1 being Nat;
let R2 being Nat;
let R18 being Language;
let R74 being (RuleSet of R18);
let C338 being  functional set;
set D1117 = ( LettersOf R18 );
set D1118 = ( R18 -firstChar );
set D1119 = ( AllFormulasOf R18 );
set D1120 = ( AllSymbolsOf R18 );
set D1121 = ( ( D1120 * ) \ { ( {} ) } );
set D1122 = ( ExFormulasOf R18 );
let C339 being (Function of ( NAT ) , D1122);
set D1123 = ( (R74 , C339) addw C338 );
assume L1878: (R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74);
assume L1879: (( D1117 \ ( SymbolsOf ( C338 /\ D1121 ) ) ) is  infinite & C338 is R74 -consistent);
defpred S37[ Nat ] means (( D1123 . R1 ) c= ( D1123 . ( R1 + $1 ) ) & ( D1117 \ ( SymbolsOf ( ( D1123 . $1 ) /\ D1121 ) ) ) is  infinite & ( D1123 . $1 ) is R74 -consistent);
L1880: S37[ ( 0 ) ] by L1879 , L1823;
L1881: (for R2 being Nat holds (S37[ R2 ] implies S37[ ( R2 + 1 ) ]))
proof
let R2 being Nat;
reconsider D1124 = ( R1 + R2 ) , D1125 = ( R2 + 1 ) , D1126 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D1127 = ( C339 . D1126 ) as (Element of D1122);
reconsider D1128 = ( C339 . D1126 ) as  exal  wff (string of R18) by TARSKI:def 3;
reconsider D1129 = ( head D1128 ) as  wff (string of R18);
reconsider D1130 = ( D1118 . D1128 ) as  literal (Element of R18);
L1882: D1128 = ( ( <* D1130 *> ^ D1129 ) ^ ( tail D1128 ) ) by FOMODEL2:23
.= ( <* D1130 *> ^ D1129 );
reconsider D1131 = ( (R74 , ( C339 . D1124 )) AddAsWitnessTo ( D1123 . D1124 ) ) as (Subset of ( ( D1123 . D1124 ) \/ D1119 ));
reconsider D1132 = ( (R74 , ( C339 . D1126 )) AddAsWitnessTo ( D1123 . D1126 ) ) as (Subset of ( ( D1123 . D1126 ) \/ D1119 ));
L1883: ( ( D1123 . D1124 ) \ D1131 ) = ( {} );
L1884: ( D1123 . D1124 ) c= D1131 by L1883 , XBOOLE_1:37;
L1885: (( D1123 . D1124 ) c= ( D1123 . ( D1124 + 1 ) ) & ( D1123 . D1125 ) = D1132) by L1884 , L1823;
assume L1886: S37[ R2 ];
thus L1887: ( D1123 . R1 ) c= ( D1123 . ( R1 + ( R2 + 1 ) ) ) by L1886 , L1885 , XBOOLE_1:1;
L1888: ( ( D1123 . D1126 ) \ D1132 ) = ( {} );
reconsider D1133 = ( D1123 . D1126 ) as  functional (Subset of D1132) by L1888 , XBOOLE_1:37;
reconsider D1134 = ( D1133 /\ D1121 ) as (Subset of ( D1132 /\ D1121 )) by XBOOLE_1:26;
reconsider D1135 = ( D1132 \ ( D1123 . D1126 ) ) as  trivial set;
reconsider D1136 = ( D1117 \ ( SymbolsOf D1134 ) ) as  infinite set by L1886;
reconsider D1137 = ( D1135 /\ D1121 ) as  functional  finite  FinSequence-membered set;
L1889: D1132 = ( D1133 \/ D1135 ) by XBOOLE_1:45;
L1890: ( SymbolsOf ( D1132 /\ D1121 ) ) = ( SymbolsOf ( D1134 \/ D1137 ) ) by L1889 , XBOOLE_1:23
.= ( ( SymbolsOf D1134 ) \/ ( SymbolsOf D1137 ) ) by FOMODEL0:47;
L1891: ( D1117 \ ( SymbolsOf ( D1132 /\ D1121 ) ) ) = ( D1136 \ ( SymbolsOf D1137 ) ) by L1890 , XBOOLE_1:41;
thus L1892: ( D1117 \ ( SymbolsOf ( ( D1123 . ( R2 + 1 ) ) /\ D1121 ) ) ) is  infinite by L1891 , L1823;
reconsider D1138 = ( D1117 \ ( SymbolsOf ( D1121 /\ ( D1133 \/ { ( head D1127 ) } ) ) ) ) as (Subset of D1117);
per cases ;
suppose L1893: (( D1133 \/ { D1127 } ) is R74 -consistent & D1138 <> ( {} ));

reconsider D1139 = D1138 as non  empty (Subset of D1117) by L1893;
set D1140 = the (Element of D1139);
reconsider D1141 = D1140 as  literal (Element of R18) by TARSKI:def 3;
L1894: (not D1140 in ( SymbolsOf ( D1121 /\ ( D1133 \/ { ( head D1127 ) } ) ) )) by XBOOLE_0:def 5;
L1895: (( D1133 \/ { ( <* D1130 *> ^ D1129 ) } ) is R74 -consistent & D1141 is ( D1133 \/ { D1129 } ) -absent) by L1894 , L1893 , L1882 , FOMODEL2:def 38;
L1896: ( D1133 \/ { ( (D1130 , D1141) -SymbolSubstIn D1129 ) } ) is R74 -consistent by L1895 , L1846 , L1878;
thus L1897: thesis by L1893 , L1359 , L1896 , L1885;
end;
suppose L1898: (not (( D1133 \/ { D1127 } ) is R74 -consistent & D1138 <> ( {} )));

thus L1899: thesis by L1898 , L1886 , L1885 , L1359;
end;
end;
L1901: (for R3 being Nat holds S37[ R3 ]) from NAT_1:sch 2(L1880 , L1881);
thus L1902: thesis by L1901;
end;
definition
let C340 being  functional set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C341 being (Function of ( NAT ) , ( ExFormulasOf R18 ));
func C340 WithWitnessesFrom (R74 , C341) -> (Subset of ( C340 \/ ( AllFormulasOf R18 ) )) equals 
( union ( rng ( (R74 , C341) AddWitnessesTo C340 ) ) );
coherence
proof
set D1142 = ( AllFormulasOf R18 );
set D1143 = ( C340 \/ D1142 );
set D1144 = ( (R74 , C341) AddWitnessesTo C340 );
reconsider D1145 = ( rng D1144 ) as (Subset of ( bool D1143 )) by RELAT_1:def 19;
L1903: ( ( union D1145 ) \ D1143 ) = ( {} );
thus L1904: thesis by L1903;
end;
end;
notation
let C342 being  functional set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C343 being (Function of ( NAT ) , ( ExFormulasOf R18 ));
synonym C342 addw (R74 , C343) for C342 WithWitnessesFrom (R74 , C343);
end;
L1907: (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B253 being  functional set holds (for B254 being (Function of ( NAT ) , ( ExFormulasOf R18 )) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74 & ( R#8 R18 ) in R74 & ( ( LettersOf R18 ) \ ( SymbolsOf ( B253 /\ ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) ) ) ) is  infinite & B253 is R74 -consistent) implies ( B253 addw (R74 , B254) ) is R74 -consistent)))))
proof
let R18 being Language;
let R74 being (RuleSet of R18);
let C344 being  functional set;
set D1146 = ( ExFormulasOf R18 );
set D1147 = ( LettersOf R18 );
set D1148 = ( R#1 R18 );
let C345 being (Function of ( NAT ) , D1146);
set D1149 = ( C344 addw (R74 , C345) );
set D1150 = ( (R74 , C345) addw C344 );
set D1151 = ( R#2 R18 );
set D1152 = ( R#5 R18 );
set D1153 = ( R#8 R18 );
set D1154 = ( AllSymbolsOf R18 );
set D1155 = ( ( D1154 * ) \ { ( {} ) } );
assume L1908: (R74 is  isotone & D1148 in R74 & D1151 in R74 & D1152 in R74 & D1153 in R74 & ( D1147 \ ( SymbolsOf ( C344 /\ D1155 ) ) ) is  infinite & C344 is R74 -consistent);
L1909: (for R6 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds ((R5 in ( dom D1150 ) & R6 in ( dom D1150 ) & R6 < R5) implies ( D1150 . R6 ) c= ( D1150 . R5 ))))
proof
let R6 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
set D1156 = R5;
set D1157 = R6;
assume L1910: (D1156 in ( dom D1150 ) & D1157 in ( dom D1150 ) & D1157 < D1156);
L1911: ( D1157 - D1157 ) <= ( D1156 - D1157 ) by L1910 , XREAL_1:9;
L1912: ( 0 ) <= ( D1156 - D1157 ) by L1911;
reconsider D1158 = ( D1156 - D1157 ) as Nat by L1912;
L1913: ( D1150 . D1157 ) c= ( D1150 . ( D1157 + D1158 ) ) by L1877 , L1908;
thus L1914: thesis by L1913;
end;
L1915:
now
let C346 being  finite (Subset of D1149);
consider R4 being (Element of ( NAT )) such that L1916: C346 c= ( D1150 . R4 ) by L1909 , HENMODEL:3;
L1917: ( D1150 . R4 ) is R74 -consistent by L1908 , L1877;
thus L1918: C346 is R74 -consistent by L1917 , L1916 , L1355;
end;
thus L1919: thesis by L1915 , L1401;
end;
registration
let C347 being  functional set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C348 being (Function of ( NAT ) , ( ExFormulasOf R18 ));
cluster ( C347 \ ( C347 addw (R74 , C348) ) ) ->  empty for set;
coherence
proof
set D1159 = ( C347 addw (R74 , C348) );
set D1160 = ( (R74 , C348) addw C347 );
set D1161 = ( rng D1160 );
reconsider D1162 = D1160 as (Function of ( NAT ) , D1161) by FUNCT_2:6;
L1920: ( D1162 . ( 0 ) ) = C347 by L1823;
L1921: C347 c= D1159 by L1920 , ZFMISC_1:74;
thus L1922: thesis by L1921;
end;
end;
theorem
L1924: (for R12 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B255 being  functional set holds (for B256 being (Function of ( NAT ) , ( ExFormulasOf R18 )) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74 & ( ( LettersOf R18 ) \ ( SymbolsOf ( B255 /\ ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) ) ) ) is  infinite & ( B255 addw (R74 , B256) ) c= R12 & R12 is R74 -consistent & ( rng B256 ) = ( ExFormulasOf R18 )) implies R12 is R18 -witnessed))))))
proof
let R12 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C349 being  functional set;
set D1163 = ( LettersOf R18 );
set D1164 = ( R18 -firstChar );
set D1165 = ( ExFormulasOf R18 );
let C350 being (Function of ( NAT ) , D1165);
set D1166 = ( (R74 , C350) addw C349 );
set D1167 = ( C349 addw (R74 , C350) );
set D1168 = ( AllSymbolsOf R18 );
L1925: ( C349 \ D1167 ) = ( {} );
L1926: C349 c= D1167 by L1925 , XBOOLE_1:37;
assume L1927: (R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & ( R#2 R18 ) in R74 & ( R#5 R18 ) in R74 & ( ( LettersOf R18 ) \ ( SymbolsOf ( C349 /\ ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) ) ) ) is  infinite);
assume L1928: (D1167 c= R12 & R12 is R74 -consistent);
L1929: (C349 c= R12 & R12 is R74 -consistent) by L1928 , L1926 , XBOOLE_1:1;
L1930: C349 is R74 -consistent by L1929 , L1355;
assume L1931: ( rng C350 ) = D1165;
set D1169 = ( ( D1168 * ) \ { ( {} ) } );
L1932: (for R46 being  literal (Element of R18) holds (for R32 being  wff (string of R18) holds (( <* R46 *> ^ R32 ) in R12 implies (ex R47 being  literal (Element of R18) st (( (R46 , R47) -SymbolSubstIn R32 ) in R12 & (not R47 in ( rng R32 )))))))
proof
let R46 being  literal (Element of R18);
let R32 being  wff (string of R18);
set D1170 = ( <* R46 *> ^ R32 );
L1933: (D1170 = ( ( <* R46 *> ^ R32 ) ^ ( {} ) ) & (not D1170 is  0wff));
L1934: (R46 = ( D1164 . D1170 ) & R32 = ( head D1170 )) by L1933 , FOMODEL2:23;
L1935: D1170 in D1165;
reconsider D1171 = D1170 as (Element of D1165) by L1935;
consider R13 being set such that L1936: (R13 in ( dom C350 ) & ( C350 . R13 ) = D1171) by L1931 , FUNCT_1:def 3;
reconsider D1172 = R13 as (Element of ( NAT )) by L1936;
reconsider D1173 = ( D1172 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D1174 = ( D1166 . D1172 ) as  functional set;
set D1175 = ( SymbolsOf ( D1169 /\ ( ( D1166 . D1172 ) \/ { R32 } ) ) );
reconsider D1176 = ( D1169 /\ { R32 } ) as  FinSequence-membered  finite (Subset of { R32 });
reconsider D1177 = ( SymbolsOf D1176 ) as  finite set;
reconsider D1178 = ( D1163 \ ( SymbolsOf ( ( D1166 . D1172 ) /\ D1169 ) ) ) as  infinite (Subset of D1163) by L1877 , L1927 , L1930;
L1937: D1175 = ( SymbolsOf ( ( D1169 /\ ( D1166 . D1172 ) ) \/ ( D1169 /\ { R32 } ) ) ) by XBOOLE_1:23
.= ( ( SymbolsOf ( D1169 /\ ( D1166 . D1172 ) ) ) \/ ( SymbolsOf D1176 ) ) by FOMODEL0:47;
L1938: ( D1163 \ D1175 ) = ( D1178 \ D1177 ) by L1937 , XBOOLE_1:41;
reconsider D1179 = ( D1163 \ D1175 ) as non  empty (Subset of D1163) by L1938;
set D1180 = the (Element of D1179);
reconsider D1181 = D1180 as  literal (Element of R18) by TARSKI:def 3;
set D1182 = ( (R46 , D1181) -SymbolSubstIn R32 );
L1939: ( dom D1166 ) = ( NAT ) by FUNCT_2:def 1;
L1940: (( D1166 . D1172 ) in ( rng D1166 ) & ( D1166 . D1173 ) in ( rng D1166 )) by L1939 , FUNCT_1:def 3;
L1941: ( D1166 . D1172 ) c= D1167 by L1940 , ZFMISC_1:74;
L1942: ( D1166 . D1172 ) c= R12 by L1941 , L1928 , XBOOLE_1:1;
assume L1943: D1170 in R12;
L1944: { D1170 } c= R12 by L1943 , ZFMISC_1:31;
L1945: ( ( D1166 . D1172 ) \/ { D1170 } ) c= R12 by L1944 , L1942 , XBOOLE_1:8;
L1946: ( ( D1166 . D1172 ) \/ { D1170 } ) is R74 -consistent by L1945 , L1928 , L1355;
L1947: ( ( D1166 . D1172 ) \/ { ( (R46 , D1181) -SymbolSubstIn R32 ) } ) = ( (R74 , D1171) AddAsWitnessTo ( D1166 . D1172 ) ) by L1946 , L1359 , L1934
.= ( D1166 . ( D1172 + 1 ) ) by L1823 , L1936;
L1948: ( { D1182 } null ( D1166 . D1172 ) ) c= ( D1166 . D1173 ) by L1947;
L1949: D1182 in ( D1166 . D1173 ) by L1948 , ZFMISC_1:31;
L1950: D1182 in D1167 by L1949 , L1940 , TARSKI:def 4;
take D1181;
thus L1951: ( (R46 , D1181) -SymbolSubstIn R32 ) in R12 by L1928 , L1950;
L1952: (not D1181 in D1175) by XBOOLE_0:def 5;
L1953: (not D1181 in ( SymbolsOf { R32 } )) by L1952 , L1937 , XBOOLE_0:def 3;
thus L1954: thesis by L1953 , FOMODEL0:45;
end;
thus L1955: R12 is R18 -witnessed by L1932 , L1282;
end;
begin
definition
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C351 being (Element of ( AllFormulasOf R18 ));
func (R74 , C351) AddFormulaTo R10 equals 
:L1956: ( R10 \/ { C351 } ) if (not ( xnot C351 ) is (R10 , R74)-provable) otherwise ( R10 \/ { ( xnot C351 ) } );
consistency;
coherence;
end;
definition
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C352 being (Element of ( AllFormulasOf R18 ));
redefine func (R74 , C352) AddFormulaTo R10 -> (Subset of ( R10 \/ ( AllFormulasOf R18 ) ));

coherence
proof
set D1183 = ( R18 -firstChar );
set D1184 = ( (R74 , C352) AddFormulaTo R10 );
set D1185 = ( AllFormulasOf R18 );
reconsider D1186 = ( R10 \/ D1185 ) as non  empty set;
reconsider D1187 = ( R10 null D1185 ) as (Subset of D1186);
reconsider D1188 = ( D1185 null R10 ) as non  empty (Subset of D1186);
L1958: (( xnot C352 ) is (Element of D1188) & C352 is (Element of D1188)) by FOMODEL2:16;
reconsider D1189 = C352 , D1190 = ( xnot C352 ) as (Element of D1186) by L1958;
reconsider D1191 = { D1189 } , D1192 = { D1190 } as (Subset of D1186);
defpred S38[  ] means ( xnot C352 ) is (R10 , R74)-provable;
L1959: (((not S38[  ]) implies D1184 = ( D1187 \/ D1191 )) & (S38[  ] implies D1184 = ( D1187 \/ D1192 ))) by L1956;
thus L1960: thesis by L1959;
end;
end;
registration
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C353 being (Element of ( AllFormulasOf R18 ));
cluster ( R10 \ ( (R74 , C353) AddFormulaTo R10 ) ) ->  empty;
coherence
proof
set D1193 = ( (R74 , C353) AddFormulaTo R10 );
set D1194 = ( xnot C353 );
defpred S39[  ] means ( xnot C353 ) is (R10 , R74)-provable;
L1962: (((not S39[  ]) implies D1193 = ( R10 \/ { C353 } )) & (S39[  ] implies D1193 = ( R10 \/ { D1194 } ))) by L1956;
L1963: (( R10 null { C353 } ) c= D1193 or ( R10 null { D1194 } ) c= D1193) by L1962;
thus L1964: thesis by L1963;
end;
end;
definition
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C354 being (Function of ( NAT ) , ( AllFormulasOf R18 ));
set D1195 = ( AllSymbolsOf R18 );
set D1196 = ( AllFormulasOf R18 );
set D1197 = ( R10 \/ D1196 );
set D1198 = ( bool D1197 );
func (R74 , C354) AddFormulasTo R10 -> (Function of ( NAT ) , ( bool ( R10 \/ ( AllFormulasOf R18 ) ) )) means 
:L1966: (( it . ( 0 ) ) = R10 & (for R2 being Nat holds ( it . ( R2 + 1 ) ) = ( (R74 , ( C354 . R2 )) AddFormulaTo ( it . R2 ) )));
existence
proof
reconsider D1199 = ( R10 null D1196 ) as (Element of D1198);
deffunc H8(Nat , (Element of D1198)) = ( D1197 typed/\ ( (R74 , ( C354 . $1 )) AddFormulaTo $2 ) );
consider C355 being (Function of ( NAT ) , D1198) such that L1967: (( C355 . ( 0 ) ) = D1199 & (for R3 being Nat holds ( C355 . ( R3 + 1 ) ) = H8(R3 , (( C355 . R3 ) qua (Element of D1198))))) from NAT_1:sch 12;
take C355;
L1968:
now
let R3 being Nat;
reconsider D1200 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
L1969: (( (R74 , ( C354 . D1200 )) AddFormulaTo ( C355 . D1200 ) ) c= ( D1196 \/ ( C355 . D1200 ) ) & ( D1196 \/ ( C355 . D1200 ) ) c= ( D1196 \/ D1197 )) by XBOOLE_1:9;
L1970: ( D1196 \/ D1197 ) = ( ( D1196 \/ D1196 ) \/ R10 ) by XBOOLE_1:4
.= D1197;
reconsider D1201 = ( (R74 , ( C354 . D1200 )) AddFormulaTo ( C355 . D1200 ) ) as (Subset of D1197) by L1970 , L1969 , XBOOLE_1:1;
L1971: ( C355 . ( R3 + 1 ) ) = ( D1201 null D1197 ) by L1967;
thus L1972: ( C355 . ( R3 + 1 ) ) = ( (R74 , ( C354 . R3 )) AddFormulaTo ( C355 . R3 ) ) by L1971;
end;
thus L1973: thesis by L1968 , L1967;
end;
uniqueness
proof
deffunc H9(Nat , (Element of D1198)) = ( (R74 , ( C354 . $1 )) AddFormulaTo $2 );
let C356 , C357 being (Function of ( NAT ) , D1198);
assume that
L1974: ( C356 . ( 0 ) ) = R10
and
L1975: (for R2 being Nat holds ( C356 . ( R2 + 1 ) ) = H9(R2 , (( C356 . R2 ) qua (Element of D1198))))
and
L1976: ( C357 . ( 0 ) ) = R10
and
L1977: (for R2 being Nat holds ( C357 . ( R2 + 1 ) ) = H9(R2 , (( C357 . R2 ) qua (Element of D1198))));
L1978: (for R2 being Nat holds ( C356 . ( R2 + 1 ) ) = H9(R2 , (( C356 . R2 ) qua (Element of D1198)))) by L1975;
L1979: (for R2 being Nat holds ( C357 . ( R2 + 1 ) ) = H9(R2 , (( C357 . R2 ) qua (Element of D1198)))) by L1977;
L1980: ( dom C356 ) = ( NAT ) by FUNCT_2:def 1;
L1981: ( dom C357 ) = ( NAT ) by FUNCT_2:def 1;
thus L1982: C356 = C357 from NAT_1:sch 15(L1980 , L1974 , L1978 , L1981 , L1976 , L1979);
end;
end;
L1984: (for R1 being Nat holds (for R2 being Nat holds (for R10 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B257 being (Function of ( NAT ) , ( AllFormulasOf R18 )) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & R10 is R74 -consistent) implies (( ( (R74 , B257) AddFormulasTo R10 ) . R1 ) c= ( ( (R74 , B257) AddFormulasTo R10 ) . ( R1 + R2 ) ) & ( ( (R74 , B257) AddFormulasTo R10 ) . R2 ) is R74 -consistent))))))))
proof
let R1 being Nat;
let R2 being Nat;
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
set D1202 = ( AllFormulasOf R18 );
let C358 being (Function of ( NAT ) , D1202);
set D1203 = ( (R74 , C358) AddFormulasTo R10 );
assume L1985: (R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74);
assume L1986: R10 is R74 -consistent;
defpred S40[ Nat ] means (( D1203 . R1 ) c= ( D1203 . ( R1 + $1 ) ) & ( D1203 . $1 ) is R74 -consistent);
L1987: S40[ ( 0 ) ] by L1986 , L1966;
L1988: (for R3 being Nat holds (S40[ R3 ] implies S40[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
set D1204 = ( (R74 , ( C358 . ( R1 + R3 ) )) AddFormulaTo ( D1203 . ( R1 + R3 ) ) );
set D1205 = ( D1203 . ( R1 + R3 ) );
assume L1989: S40[ R3 ];
L1990: ( D1205 \ D1204 ) = ( {} );
L1991: ( D1203 . ( R1 + ( R3 + 1 ) ) ) = ( D1203 . ( ( R1 + R3 ) + 1 ) )
.= D1204 by L1966;
L1992: D1205 c= ( D1203 . ( R1 + ( R3 + 1 ) ) ) by L1991 , L1990 , XBOOLE_1:37;
thus L1993: ( D1203 . R1 ) c= ( D1203 . ( R1 + ( R3 + 1 ) ) ) by L1992 , L1989 , XBOOLE_1:1;
reconsider D1206 = ( C358 . R3 ) as (Element of D1202);
reconsider D1207 = D1206 as  wff (string of R18);
reconsider D1208 = ( xnot D1207 ) as  wff (string of R18);
reconsider D1209 = D1208 as (Element of D1202) by FOMODEL2:16;
set D1210 = ( D1203 . R3 );
set D1211 = ( (R74 , ( C358 . R3 )) AddFormulaTo D1210 );
defpred S41[  ] means ( xnot D1206 ) is (D1210 , R74)-provable;
L1994: ( D1203 . ( R3 + 1 ) ) = D1211 by L1966;
per cases ;
suppose L1995: (not S41[  ]);

L1996: ( D1210 \/ { D1206 } ) is R74 -consistent by L1995 , L1985 , L1379;
thus L1997: thesis by L1996 , L1994 , L1995 , L1956;
end;
suppose L1998: S41[  ];

L1999: ( D1210 \/ { ( xnot D1206 ) } ) is R74 -consistent by L1998 , L1436 , L1985 , L1989;
thus L2000: thesis by L1999 , L1994 , L1998 , L1956;
end;
end;
L2002: (for R3 being Nat holds S40[ R3 ]) from NAT_1:sch 2(L1987 , L1988);
thus L2003: thesis by L2002;
end;
definition
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C359 being (Function of ( NAT ) , ( AllFormulasOf R18 ));
func (R74 , C359) CompletionOf R10 -> (Subset of ( R10 \/ ( AllFormulasOf R18 ) )) equals 
( union ( rng ( (R74 , C359) AddFormulasTo R10 ) ) );
coherence
proof
set D1212 = ( AllFormulasOf R18 );
set D1213 = ( R10 \/ D1212 );
set D1214 = ( (R74 , C359) AddFormulasTo R10 );
reconsider D1215 = ( rng D1214 ) as (Subset of ( bool D1213 )) by RELAT_1:def 19;
L2004: ( ( union D1215 ) \ D1213 ) = ( {} );
thus L2005: thesis by L2004;
end;
end;
registration
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
let C360 being (Function of ( NAT ) , ( AllFormulasOf R18 ));
cluster ( R10 \ ( (R74 , C360) CompletionOf R10 ) ) ->  empty for set;
coherence
proof
set D1216 = ( (R74 , C360) AddFormulasTo R10 );
set D1217 = ( (R74 , C360) CompletionOf R10 );
reconsider D1218 = D1216 as (Function of ( NAT ) , ( rng D1216 )) by FUNCT_2:6;
L2007: ( D1218 . ( 0 ) ) in ( rng D1216 );
L2008: ( D1216 . ( 0 ) ) c= D1217 by L2007 , ZFMISC_1:74;
L2009: R10 c= D1217 by L2008 , L1966;
thus L2010: thesis by L2009;
end;
end;
L2012: (for R10 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B258 being (Function of ( NAT ) , ( AllFormulasOf R18 )) holds (( rng B258 ) = ( AllFormulasOf R18 ) implies ( (R74 , B258) CompletionOf R10 ) is R18 -covering)))))
proof
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
set D1219 = ( AllFormulasOf R18 );
let C361 being (Function of ( NAT ) , D1219);
set D1220 = ( (R74 , C361) CompletionOf R10 );
set D1221 = ( (R74 , C361) AddFormulasTo R10 );
assume L2013: ( rng C361 ) = D1219;
reconsider D1222 = D1221 as (Function of ( NAT ) , ( rng D1221 )) by FUNCT_2:6;
thus L2014:now
let R31 being  wff (string of R18);
reconsider D1223 = R31 as (Element of D1219) by FOMODEL2:16;
consider R13 being set such that L2015: (R13 in ( dom C361 ) & ( C361 . R13 ) = D1223) by L2013 , FUNCT_1:def 3;
reconsider D1224 = R13 as (Element of ( NAT )) by L2015;
reconsider D1225 = ( D1224 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L2016: ( D1221 . ( D1224 + 1 ) ) = ( (R74 , ( C361 . D1224 )) AddFormulaTo ( D1221 . D1224 ) ) by L1966;
L2017: (( D1221 . ( D1224 + 1 ) ) = ( ( D1221 . D1224 ) \/ { R31 } ) or ( D1221 . ( D1224 + 1 ) ) = ( ( D1221 . D1224 ) \/ { ( xnot R31 ) } )) by L2016 , L2015 , L1956;
L2018: (( { R31 } null ( D1221 . D1224 ) ) c= ( D1221 . D1225 ) or ( { ( xnot R31 ) } null ( D1221 . D1224 ) ) c= ( D1221 . D1225 )) by L2017;
L2019: ( D1222 . D1225 ) is (Element of ( rng D1221 ));
L2020: ( D1221 . ( D1224 + 1 ) ) c= D1220 by L2019 , ZFMISC_1:74;
L2021: ({ R31 } c= D1220 or { ( xnot R31 ) } c= D1220) by L2020 , L2018 , XBOOLE_1:1;
thus L2022: (R31 in D1220 or ( xnot R31 ) in D1220) by L2021 , ZFMISC_1:31;
end;
end;
L2015: (for R10 being set holds (for R18 being Language holds (for R74 being (RuleSet of R18) holds (for B259 being (Function of ( NAT ) , ( AllFormulasOf R18 )) holds ((R74 is  isotone & ( R#1 R18 ) in R74 & ( R#8 R18 ) in R74 & R10 is R74 -consistent) implies ( (R74 , B259) CompletionOf R10 ) is R74 -consistent)))))
proof
let R10 being set;
let R18 being Language;
let R74 being (RuleSet of R18);
set D1226 = ( ExFormulasOf R18 );
set D1227 = ( LettersOf R18 );
set D1228 = ( AllFormulasOf R18 );
let C362 being (Function of ( NAT ) , D1228);
set D1229 = ( (R74 , C362) CompletionOf R10 );
set D1230 = ( R#1 R18 );
set D1231 = ( R#8 R18 );
set D1232 = ( AllSymbolsOf R18 );
set D1233 = ( ( D1232 * ) \ { ( {} ) } );
set D1234 = ( (R74 , C362) AddFormulasTo R10 );
assume L2016: (R74 is  isotone & D1230 in R74 & D1231 in R74 & R10 is R74 -consistent);
L2017: (for R6 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds ((R5 in ( dom D1234 ) & R6 in ( dom D1234 ) & R6 < R5) implies ( D1234 . R6 ) c= ( D1234 . R5 ))))
proof
let R6 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
set D1235 = R5;
set D1236 = R6;
assume L2018: (D1235 in ( dom D1234 ) & D1236 in ( dom D1234 ) & D1236 < D1235);
L2019: ( D1236 - D1236 ) <= ( D1235 - D1236 ) by L2018 , XREAL_1:9;
L2020: ( 0 ) <= ( D1235 - D1236 ) by L2019;
reconsider D1237 = ( D1235 - D1236 ) as Nat by L2020;
L2021: ( D1234 . D1236 ) c= ( D1234 . ( D1236 + D1237 ) ) by L2016 , L1984;
thus L2022: thesis by L2021;
end;
L2023:
now
let C363 being  finite (Subset of D1229);
consider R4 being (Element of ( NAT )) such that L2024: C363 c= ( D1234 . R4 ) by L2017 , HENMODEL:3;
L2025: ( D1234 . R4 ) is R74 -consistent by L2016 , L1984;
thus L2026: C363 is R74 -consistent by L2025 , L2024 , L1355;
end;
thus L2027: D1229 is R74 -consistent by L2023 , L1401;
end;
theorem
L2028: (for R10 being set holds (for R16 being set holds (for R18 being Language holds (for B260 being (Relation of ( bool ( R18 -sequents ) ) , ( R18 -sequents )) holds (R16 in ( ( FuncRule B260 ) . R10 ) iff (R16 in ( R18 -sequents ) & [ R10 , R16 ] in B260)))))) by L537;
L2029: (for R18 being Language holds (for R83 being 2 -ranked (RuleSet of R18) holds (for B261 being  functional set holds ((( AllFormulasOf R18 ) is  countable & ( ( LettersOf R18 ) \ ( SymbolsOf ( B261 /\ ( ( ( AllSymbolsOf R18 ) * ) \ { ( {} ) } ) ) ) ) is  infinite & B261 is R83 -consistent & R83 is  isotone) implies (ex R7 being non  empty set st (ex B262 being (Element of ( R7 -InterpretersOf R18 )) st B261 is B262 -satisfied))))))
proof
let R18 being Language;
let R83 being 2 -ranked (RuleSet of R18);
let C364 being  functional set;
set D1238 = ( ExFormulasOf R18 );
set D1239 = ( AllFormulasOf R18 );
set D1240 = ( R#0 R18 );
set D1241 = ( R#2 R18 );
set D1242 = ( R#3a R18 );
set D1243 = ( R#3b R18 );
set D1244 = ( R#3d R18 );
set D1245 = ( R#3e R18 );
set D1246 = ( R#1 R18 );
set D1247 = ( R#4 R18 );
set D1248 = ( R#5 R18 );
set D1249 = ( R#6 R18 );
set D1250 = ( R#7 R18 );
set D1251 = ( R#8 R18 );
set D1252 = ( LettersOf R18 );
set D1253 = ( AllSymbolsOf R18 );
set D1254 = ( ( D1253 * ) \ { ( {} ) } );
set D1255 = ( SymbolsOf ( C364 /\ D1254 ) );
set D1256 = R83;
reconsider D1257 = R83 as 1 -ranked ( 0 ) -ranked (RuleSet of R18);
assume L2030: D1239 is  countable;
reconsider D1258 = D1239 as  countable set by L2030;
consider C365 being (Function of ( NAT ) , D1254) such that L2031: D1258 = ( rng C365 ) by SUPINF_2:def 8;
reconsider D1259 = C365 as (Function of ( NAT ) , D1239) by L2031 , FUNCT_2:6;
L2032: ( D1238 \ D1258 ) = ( {} );
reconsider D1260 = D1238 as (Subset of D1258) by L2032 , XBOOLE_1:37;
consider C366 being (Function of ( NAT ) , D1258) such that L2033: D1260 = ( rng C366 ) by SUPINF_2:def 8;
reconsider D1261 = C366 as (Function of ( NAT ) , D1238) by L2033 , FUNCT_2:6;
assume L2034: (( D1252 \ D1255 ) is  infinite & C364 is R83 -consistent);
L2035: (D1240 in D1257 & D1246 in D1256 & D1241 in D1257 & D1247 in D1256 & D1248 in D1256 & D1249 in D1256 & D1250 in D1256 & D1251 in D1256) by L870;
set D1262 = ( C364 addw (D1257 , D1261) );
set D1263 = ( (D1257 , D1259) CompletionOf D1262 );
L2036: D1263 is R18 -covering by L2012 , L2031;
assume L2037: D1256 is  isotone;
L2038: D1262 is D1256 -consistent by L2037 , L1907 , L2034 , L2035;
L2039: D1263 is D1256 -consistent by L2038 , L2015 , L2037 , L2035;
L2040: (D1263 is R18 -mincover & D1263 is D1256 -expanded) by L2039 , L2035 , L1413 , L2036;
reconsider D1264 = D1263 as D1257 -expanded set by L2035 , L1413 , L2036 , L2039;
take D1265 = ( Class ( (D1264 , D1257) -termEq ) );
reconsider D1266 = ( D1257 Henkin D1264 ) as (Element of ( D1265 -InterpretersOf R18 ));
take D1266;
L2041: (( C364 \ D1262 ) = ( {} ) & ( D1262 \ D1263 ) = ( {} ));
L2042: (C364 c= D1262 & D1262 c= D1264) by L2041 , XBOOLE_1:37;
L2043: D1264 is R18 -witnessed by L2042 , L1924 , L2034 , L2035 , L2037 , L2039 , L2033;
thus L2044:now
let R31 being  wff (string of R18);
assume L2045: R31 in C364;
L2046: R31 in D1264 by L2045 , L2042 , TARSKI:def 3;
thus L2047: ( D1266 -TruthEval R31 ) = 1 by L2046 , L2043 , L1284 , L2040 , L2035;
end;
end;
L2045: (for R18 being Language holds (for R83 being 2 -ranked (RuleSet of R18) holds (for B263 being  functional set holds ((B263 is  finite & ( AllFormulasOf R18 ) is  countable & B263 is R83 -consistent & R83 is  isotone) implies (ex R7 being non  empty set st (ex B264 being (Element of ( R7 -InterpretersOf R18 )) st B263 is B264 -satisfied))))))
proof
let R18 being Language;
let R83 being 2 -ranked (RuleSet of R18);
let C367 being  functional set;
set D1267 = ( AllSymbolsOf R18 );
set D1268 = ( LettersOf R18 );
set D1269 = ( ( D1267 * ) \ { ( {} ) } );
set D1270 = ( AllFormulasOf R18 );
set D1271 = ( SymbolsOf ( C367 /\ D1269 ) );
assume L2046: C367 is  finite;
reconsider D1272 = ( C367 /\ D1269 ) as  finite  FinSequence-membered set by L2046;
L2047: ( SymbolsOf D1272 ) is  finite;
L2048: ( D1268 \ D1271 ) is  infinite by L2047;
assume L2049: (D1270 is  countable & C367 is R83 -consistent & R83 is  isotone);
thus L2050: thesis by L2049 , L2048 , L2029;
end;
L2051: (for R7 being non  empty set holds (for R10 being set holds (for R51 being Language holds (for R52 being Language holds (for B265 being (Element of ( R7 -InterpretersOf R51 )) holds (for B266 being (Element of ( R7 -InterpretersOf R52 )) holds ((R52 is R51 -extending & R10 c= ( AllFormulasOf R51 ) & ( B265 | ( OwnSymbolsOf R51 ) ) = ( B266 | ( OwnSymbolsOf R51 ) )) implies (R10 is B265 -satisfied iff R10 is B266 -satisfied))))))))
proof
let R7 being non  empty set;
let R10 being set;
let R51 being Language;
let R52 being Language;
set D1273 = ( R7 -InterpretersOf R51 );
set D1274 = ( R7 -InterpretersOf R52 );
set D1275 = (the adicity of R51);
set D1276 = (the adicity of R52);
set D1277 = ( OwnSymbolsOf R51 );
set D1278 = ( TheEqSymbOf R51 );
set D1279 = ( TheEqSymbOf R52 );
set D1280 = ( TheNorSymbOf R51 );
set D1281 = ( TheNorSymbOf R52 );
set D1282 = ( AllFormulasOf R51 );
set D1283 = ( AtomicFormulaSymbolsOf R51 );
L2052: (( dom D1275 ) = D1283 & D1277 c= D1283) by FOMODEL1:1 , FUNCT_2:def 1;
reconsider D1284 = D1277 as (Subset of ( dom D1275 )) by L2052;
let C368 being (Element of D1273);
let C369 being (Element of D1274);
assume L2053: R52 is R51 -extending;
L2054: D1275 c= D1276 by L2053 , FOMODEL1:def 41;
L2055: ( D1275 | D1277 ) = ( ( D1276 | ( dom D1275 ) ) | D1277 ) by L2054 , GRFUNC_1:23
.= ( D1276 | ( D1284 null ( dom D1275 ) ) ) by RELAT_1:71;
L2056: (( D1275 | D1277 ) = ( D1276 | D1277 ) & D1280 = D1281 & D1278 = D1279) by L2055 , L2053 , FOMODEL1:def 41;
assume L2057: (R10 c= D1282 & ( C368 | D1277 ) = ( C369 | D1277 ));
thus L2058:now
assume L2059: R10 is C368 -satisfied;
L2060:
now
let C370 being  wff (string of R52);
assume L2061: C370 in R10;
L2062: C370 in D1282 by L2061 , L2057;
reconsider D1285 = C370 as  wff (string of R51) by L2062;
consider C371 being  wff (string of R52) such that L2063: (D1285 = C371 & ( C368 -TruthEval D1285 ) = ( C369 -TruthEval C371 )) by L2056 , L2057 , FOMODEL3:12;
thus L2064: ( C369 -TruthEval C370 ) = 1 by L2063 , L2061 , L2059 , FOMODEL2:def 42;
end;
thus L2065: R10 is C369 -satisfied by L2060 , FOMODEL2:def 42;
end;
assume L2066: R10 is C369 -satisfied;
L2067:
now
let C372 being  wff (string of R51);
assume L2068: C372 in R10;
consider C373 being  wff (string of R52) such that L2069: (C372 = C373 & ( C368 -TruthEval C372 ) = ( C369 -TruthEval C373 )) by L2056 , L2057 , FOMODEL3:12;
thus L2070: ( C368 -TruthEval C372 ) = 1 by L2069 , L2068 , L2066 , FOMODEL2:def 42;
end;
thus L2071: thesis by L2067 , FOMODEL2:def 42;
end;
registration
let R18 being Language;
let C374 , C375 being  isotone (Rule of R18);
cluster { C374 , C375 } ->  isotone for (RuleSet of R18);
coherence
proof
L2072: { C374 , C375 } = ( { C374 } \/ { C375 } ) by ENUMSET1:1;
thus L2073: thesis by L2072;
end;
end;
registration
let R18 being Language;
let C376 , C377 , C378 , C379 being  isotone (Rule of R18);
cluster { C376 , C377 , C378 , C379 } ->  isotone for (RuleSet of R18);
coherence
proof
L2075: { C376 , C377 , C378 , C379 } = ( { C376 , C377 } \/ { C378 , C379 } ) by ENUMSET1:5;
thus L2076: thesis by L2075;
end;
end;
registration
let R18 being Language;
cluster ( R18 -rules ) ->  isotone for (RuleSet of R18);
coherence
proof
set D1286 = { ( R#0 R18 ) , ( R#1 R18 ) , ( R#2 R18 ) , ( R#3a R18 ) , ( R#3b R18 ) , ( R#3d R18 ) , ( R#3e R18 ) , ( R#4 R18 ) };
set D1287 = { ( R#5 R18 ) , ( R#6 R18 ) , ( R#7 R18 ) , ( R#8 R18 ) };
set D1288 = ( R18 -rules );
L2078: D1286 = ( { ( R#0 R18 ) , ( R#1 R18 ) , ( R#2 R18 ) , ( R#3a R18 ) } \/ { ( R#3b R18 ) , ( R#3d R18 ) , ( R#3e R18 ) , ( R#4 R18 ) } ) by ENUMSET1:25;
reconsider D1289 = D1286 as  isotone (RuleSet of R18) by L2078;
L2079: ( D1289 \/ D1287 ) is  isotone;
thus L2080: thesis by L2079;
end;
end;
registration
let R18 being Language;
cluster  Correct for  isotone  isotone  isotone  isotone (RuleSet of R18);
existence
proof
take ( R18 -rules );
thus L2082: thesis;
end;
end;
registration
let R18 being Language;
cluster 2 -ranked for  Correct  isotone  Correct  isotone  Correct  isotone  Correct  isotone (RuleSet of R18);
existence
proof
take ( R18 -rules );
thus L2084: thesis;
end;
end;
registration
let C380 being  countable Language;
cluster ( AllFormulasOf C380 ) ->  countable;
coherence;
end;
theorem
L2087: (for R12 being set holds (for B267 being  countable Language holds (for B268 being (RuleSet of B267) holds ((B268 is 2 -ranked & B268 is  isotone & B268 is  Correct & R12 is B268 -consistent & R12 c= ( AllFormulasOf B267 )) implies (ex B269 being non  empty set st (ex B270 being (Element of ( B269 -InterpretersOf B267 )) st R12 is B270 -satisfied))))))
proof
let R12 being set;
let C381 being  countable Language;
set D1290 = C381;
let C382 being (RuleSet of D1290);
set D1291 = ( AllFormulasOf D1290 );
assume L2088: (C382 is 2 -ranked & C382 is  isotone & C382 is  Correct & R12 is C382 -consistent & R12 c= D1291);
reconsider D1292 = R12 as (Subset of D1291) by L2088;
set D1293 = ( D1290 addLettersNotIn D1292 );
set D1294 = ( OwnSymbolsOf D1290 );
set D1295 = ( OwnSymbolsOf D1293 );
set D1296 = ( AllFormulasOf D1293 );
set D1297 = ( AllSymbolsOf D1290 );
set D1298 = ( AllSymbolsOf D1293 );
set D1299 = ( ( D1298 * ) \ { ( {} ) } );
set D1300 = ( LettersOf D1293 );
reconsider D1301 = C382 as 2 -ranked  Correct (RuleSet of D1290) by L2088;
L2089: ( D1294 \ D1295 ) = ( {} );
reconsider D1302 = D1294 as non  empty (Subset of D1295) by L2089 , XBOOLE_1:37;
reconsider D1303 = ( D1293 -rules ) as 2 -ranked  Correct  isotone (RuleSet of D1293);
reconsider D1304 = ( D1292 /\ D1299 ) as (Subset of D1292);
reconsider D1305 = ( SymbolsOf D1304 ) as (Subset of ( SymbolsOf D1292 )) by FOMODEL0:46;
reconsider D1306 = ( D1300 \ ( SymbolsOf D1292 ) ) as (Subset of ( D1300 \ D1305 )) by XBOOLE_1:34;
L2090: ( D1300 \ ( D1305 null D1306 ) ) is  infinite;
L2091:
now
let C383 being  finite (Subset of D1292);
reconsider D1307 = C383 as  functional set;
reconsider D1308 = D1307 as  functional (Subset of D1291) by XBOOLE_1:1;
L2092: (D1307 is  finite & D1291 is  countable & D1307 is D1301 -consistent & D1301 is  isotone) by L2088 , L1355;
consider R7 being non  empty set such that L2093: (ex B271 being (Element of ( R7 -InterpretersOf D1290 )) st D1307 is B271 -satisfied) by L2092 , L2045;
set D1309 = ( R7 -InterpretersOf D1290 );
set D1310 = ( R7 -InterpretersOf D1293 );
set D1311 = the (D1293 , R7)-interpreter-like Function;
consider C384 being (Element of D1309) such that L2094: D1308 is C384 -satisfied by L2093;
reconsider D1312 = ( ( D1311 +* C384 ) | D1295 ) as (Element of D1310) by FOMODEL2:2;
L2095: ( D1312 | D1294 ) = ( ( D1311 +* C384 ) | ( D1302 null D1295 ) ) by RELAT_1:71
.= ( ( D1311 | D1294 ) +* ( C384 | D1294 ) ) by FUNCT_4:71
.= ( C384 | D1294 );
L2096: D1308 is D1312 -satisfied by L2095 , L2094 , L2051;
thus L2097: C383 is D1303 -consistent by L2096 , L1441;
end;
L2098: D1292 is D1303 -consistent by L2091 , L1401;
consider R7 being non  empty set such that L2099: (ex B272 being (Element of ( R7 -InterpretersOf D1293 )) st D1292 is B272 -satisfied) by L2098 , L2090 , L2029;
set D1313 = ( R7 -InterpretersOf D1290 );
set D1314 = ( R7 -InterpretersOf D1293 );
consider C385 being (Element of D1314) such that L2100: D1292 is C385 -satisfied by L2099;
take R7;
reconsider D1315 = ( C385 | D1294 ) as (Element of D1313) by FOMODEL2:2;
take D1315;
L2101: ( D1315 | D1294 ) = ( ( C385 | D1294 ) null D1294 );
thus L2102: thesis by L2101 , L2100 , L2051;
end;
L2103: (for R12 being set holds (for B273 being  countable Language holds (for B274 being  wff (string of B273) holds ((R12 c= ( AllFormulasOf B273 ) & ( xnot B274 ) is R12 -implied) implies ( xnot B274 ) is (R12 , ( B273 -rules ))-provable))))
proof
let R12 being set;
let C386 being  countable Language;
set D1316 = ( C386 -rules );
set D1317 = ( AllFormulasOf C386 );
let C387 being  wff (string of C386);
assume L2104: R12 c= D1317;
reconsider D1318 = R12 as (Subset of D1317) by L2104;
set D1319 = ( xnot C387 );
L2105: C387 in D1317 by FOMODEL2:16;
reconsider D1320 = { C387 } as non  empty (Subset of D1317) by L2105 , ZFMISC_1:31;
reconsider D1321 = ( D1318 \/ D1320 ) as non  empty (Subset of D1317);
reconsider D1322 = ( D1318 null D1320 ) as (Subset of D1321);
reconsider D1323 = ( D1320 null D1318 ) as non  empty (Subset of D1321);
assume L2106: D1319 is R12 -implied;
assume L2107: (not D1319 is (R12 , D1316)-provable);
L2108: (D1316 is  isotone & ( R#1 C386 ) in D1316 & ( R#8 C386 ) in D1316 & (not D1319 is (R12 , D1316)-provable)) by L2107 , L870;
consider C388 being non  empty set, C389 being (Element of ( C388 -InterpretersOf C386 )) such that L2109: D1321 is C389 -satisfied by L2108 , L2087 , L1379;
L2110: ( ( C389 -TruthEval D1319 ) \+\ ( 'not' ( C389 -TruthEval C387 ) ) ) = ( {} );
L2111: ( C389 -TruthEval D1319 ) = ( 'not' ( C389 -TruthEval C387 ) ) by L2110 , FOMODEL0:29;
L2112: ( D1321 /\ D1322 ) is C389 -satisfied by L2109;
L2113: C387 in D1323 by TARSKI:def 1;
L2114: 1 = ( 'not' ( C389 -TruthEval D1319 ) ) by L2113 , L2111 , L2109 , FOMODEL2:def 42;
thus L2115: contradiction by L2114 , L2112 , L2106 , FOMODEL2:def 45;
end;
theorem
L2116: (for R10 being set holds (for R84 being  countable Language holds (for R85 being  wff (string of R84) holds ((R10 c= ( AllFormulasOf R84 ) & R85 is R10 -implied) implies R85 is R10 -provable))))
proof
let R10 being set;
let R84 being  countable Language;
let R85 being  wff (string of R84);
reconsider D1324 = R84 as Language;
reconsider D1325 = { ( R#9 D1324 ) } as (RuleSet of D1324);
set D1326 = ( AllFormulasOf R84 );
set D1327 = ( R84 -rules );
assume L2117: R10 c= D1326;
reconsider D1328 = R10 as (Subset of D1326) by L2117;
assume L2118: R85 is R10 -implied;
reconsider D1329 = R85 as R10 -implied  wff (string of R84) by L2118;
set D1330 = ( xnot ( xnot D1329 ) );
L2119: D1330 is (D1328 , D1327)-provable by L2103;
consider C390 being set, R2 being Nat such that L2120: (C390 c= D1328 & [ C390 , D1330 ] is (R2 , ( {} ) , D1327)-derivable) by L2119 , L1034;
reconsider D1331 = [ C390 , D1330 ] as R84 -sequent-like set by L2120;
L2121: ( ( D1331 `1 ) \+\ C390 ) = ( {} );
reconsider D1332 = C390 as D1324 -premises-like set by L2121 , FOMODEL0:29;
reconsider D1333 = C390 as R84 -premises-like set by L2121 , FOMODEL0:29;
reconsider D1334 = R85 as  wff (string of D1324);
L2122: ( [ D1333 , R85 ] null 1 ) is (1 , { [ D1333 , ( xnot ( xnot R85 ) ) ] } , { ( R#9 R84 ) })-derivable;
L2123: [ D1333 , R85 ] is (( R2 + 1 ) , ( {} ) , ( D1327 \/ { ( R#9 R84 ) } ))-derivable by L2122 , L363 , L2120;
L2124: R85 is (D1328 , ( D1327 \/ { ( R#9 R84 ) } ))-provable by L2123 , L2120 , L1034;
thus L2125: thesis by L2124 , L1821;
end;
