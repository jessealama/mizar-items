:: The Composition of Functors and Transformations in Alternative
:: Categories
::  by Artur Korni{\l}owicz
::
:: Received January 21, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RELAT_2, BINOP_1, ALTCAT_1, STRUCT_0, XBOOLE_0, FUNCTOR0,
      MSUALG_6, FUNCOP_1, CAT_1, RELAT_1, FUNCT_1, ZFMISC_1, TARSKI, MEMBER_1,
      PBOOLE, NATTRA_1, PZFMISC1, REALSET1, FUNCTOR2, VALUED_1, ALTCAT_3,
      CAT_3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      STRUCT_0, BINOP_1, FUNCOP_1, PBOOLE, MSUALG_3, ALTCAT_1, ALTCAT_2,
      ALTCAT_3, FUNCTOR0, FUNCTOR2;
 constructors MSUALG_3, ALTCAT_3, FUNCTOR2, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELSET_1, FUNCT_2, FUNCOP_1,
      RELAT_1, PBOOLE, STRUCT_0, ALTCAT_1, FUNCTOR0, FUNCTOR2, ALTCAT_4,
      ALTCAT_2;
 requirements SUBSET, BOOLE;
 definitions FUNCTOR0, FUNCTOR2, PBOOLE, BINOP_1;
 theorems ALTCAT_1, ALTCAT_3, ALTCAT_4, FUNCTOR0, FUNCTOR2, ZFMISC_1, MSUALG_3,
      PBOOLE, FUNCT_1, FUNCT_2, RELAT_1, XBOOLE_0, PARTFUN1;
 schemes PBOOLE;

begin
registration
cluster  transitive  associative  with_units  strict for non  empty non  empty non  empty non  empty AltCatStr;
existence
proof
set D1 = the  transitive  associative  with_units  strict non  empty AltCatStr;
take D1;
thus L1: thesis;
end;
end;
registration
let C1 being non  empty  transitive AltCatStr;
let C2 being  with_units non  empty AltCatStr;
cluster  strict  comp-preserving  comp-reversing  Covariant  Contravariant  feasible for FunctorStr over C1 , C2;
existence
proof
set D2 = the (object of C2);
take ( C1 --> ( idm D2 ) );
thus L3: thesis;
end;
end;
registration
let C3 being  with_units  transitive non  empty AltCatStr;
let C4 being  with_units non  empty AltCatStr;
cluster  strict  comp-preserving  comp-reversing  Covariant  Contravariant  feasible  id-preserving for FunctorStr over C3 , C4;
existence
proof
set D3 = the (object of C4);
take ( C3 --> ( idm D3 ) );
thus L5: thesis;
end;
end;
registration
let C5 being  with_units  transitive non  empty AltCatStr;
let C6 being  with_units non  empty AltCatStr;
cluster  strict  feasible  covariant  contravariant for (Functor of C5 , C6);
existence
proof
set D4 = the (object of C6);
set D5 = ( C5 --> ( idm D4 ) );
reconsider D6 = D5 as (Functor of C5 , C6) by FUNCTOR0:def 25;
take D6;
thus L7: D6 is  strict  feasible;
thus L8: D6 is  covariant;
thus L9: thesis;
end;
end;
theorem
L11: (for B1 being category holds (for B2 , B3 , B4 , B5 being (object of B1) holds (for B6 being (Morphism of B2 , B3) holds (for B7 being (Morphism of B3 , B4) holds (for B8 being (Morphism of B2 , B5) holds (for B9 being (Morphism of B5 , B4) holds ((( B7 * B6 ) = ( B9 * B8 ) & ( B6 * ( B6 " ) ) = ( idm B3 ) & ( ( B9 " ) * B9 ) = ( idm B5 ) & <^ B2 , B3 ^> <> ( {} ) & <^ B3 , B2 ^> <> ( {} ) & <^ B3 , B4 ^> <> ( {} ) & <^ B4 , B5 ^> <> ( {} ) & <^ B5 , B4 ^> <> ( {} )) implies ( B8 * ( B6 " ) ) = ( ( B9 " ) * B7 ))))))))
proof
let C7 being category;
let C8 , C9 , C10 , C11 being (object of C7);
let C12 being (Morphism of C8 , C9);
let C13 being (Morphism of C9 , C10);
let C14 being (Morphism of C8 , C11);
let C15 being (Morphism of C11 , C10);
assume that
L12: ( C13 * C12 ) = ( C15 * C14 )
and
L13: ( C12 * ( C12 " ) ) = ( idm C9 )
and
L14: ( ( C15 " ) * C15 ) = ( idm C11 )
and
L15: <^ C8 , C9 ^> <> ( {} )
and
L16: <^ C9 , C8 ^> <> ( {} )
and
L17: <^ C9 , C10 ^> <> ( {} )
and
L18: <^ C10 , C11 ^> <> ( {} )
and
L19: <^ C11 , C10 ^> <> ( {} );
L20: <^ C9 , C11 ^> <> ( {} ) by L17 , L18 , ALTCAT_1:def 2;
L21: <^ C8 , C10 ^> <> ( {} ) by L15 , L17 , ALTCAT_1:def 2;
L22: <^ C8 , C11 ^> <> ( {} ) by L21 , L18 , ALTCAT_1:def 2;
L23: C13 = ( C13 * ( idm C9 ) ) by L17 , ALTCAT_1:def 17
.= ( ( C13 * C12 ) * ( C12 " ) ) by L13 , L15 , L16 , L17 , ALTCAT_1:21;
thus L24: ( ( C15 " ) * C13 ) = ( ( C15 " ) * ( C15 * ( C14 * ( C12 " ) ) ) ) by L23 , L12 , L16 , L19 , L22 , ALTCAT_1:21
.= ( ( ( C15 " ) * C15 ) * ( C14 * ( C12 " ) ) ) by L18 , L19 , L20 , ALTCAT_1:21
.= ( C14 * ( C12 " ) ) by L14 , L20 , ALTCAT_1:20;
end;
theorem
L25: (for B10 being non  empty  transitive AltCatStr holds (for B11 , B12 being  with_units non  empty AltCatStr holds (for B13 being  feasible  Covariant FunctorStr over B10 , B11 holds (for B14 being FunctorStr over B11 , B12 holds (for B15 , B16 being (object of B10) holds ( Morph-Map (( B14 * B13 ) , B15 , B16) ) = ( ( Morph-Map (B14 , ( B13 . B15 ) , ( B13 . B16 )) ) * ( Morph-Map (B13 , B15 , B16) ) ))))))
proof
let C16 being non  empty  transitive AltCatStr;
let C17 , C18 being  with_units non  empty AltCatStr;
let C19 being  feasible  Covariant FunctorStr over C16 , C17;
let C20 being FunctorStr over C17 , C18;
let C21 , C22 being (object of C16);
L26: (( dom (the MorphMap of C20) ) = [: (the carrier of C17) , (the carrier of C17) :] & ( rng (the ObjectMap of C19) ) c= [: (the carrier of C17) , (the carrier of C17) :]) by PARTFUN1:def 2;
L27: ( dom ( (the MorphMap of C20) * (the ObjectMap of C19) ) ) = ( dom (the ObjectMap of C19) ) by L26 , RELAT_1:27
.= [: (the carrier of C16) , (the carrier of C16) :] by FUNCT_2:def 1;
L28: [ C21 , C22 ] in ( dom ( (the MorphMap of C20) * (the ObjectMap of C19) ) ) by L27 , ZFMISC_1:87;
L29: ( ( (the MorphMap of C20) * (the ObjectMap of C19) ) . [ C21 , C22 ] ) = ( (the MorphMap of C20) . ( (the ObjectMap of C19) . (C21 , C22) ) ) by L28 , FUNCT_1:12
.= ( Morph-Map (C20 , ( C19 . C21 ) , ( C19 . C22 )) ) by FUNCTOR0:22;
L30: ( dom (the MorphMap of C19) ) = [: (the carrier of C16) , (the carrier of C16) :] by PARTFUN1:def 2;
L31: [ C21 , C22 ] in ( dom (the MorphMap of C19) ) by L30 , ZFMISC_1:87;
L32: [ C21 , C22 ] in ( ( dom ( (the MorphMap of C20) * (the ObjectMap of C19) ) ) /\ ( dom (the MorphMap of C19) ) ) by L31 , L28 , XBOOLE_0:def 4;
L33: [ C21 , C22 ] in ( dom ( ( (the MorphMap of C20) * (the ObjectMap of C19) ) ** (the MorphMap of C19) ) ) by L32 , PBOOLE:def 19;
thus L34: ( Morph-Map (( C20 * C19 ) , C21 , C22) ) = ( ( ( (the MorphMap of C20) * (the ObjectMap of C19) ) ** (the MorphMap of C19) ) . (C21 , C22) ) by FUNCTOR0:def 36
.= ( ( Morph-Map (C20 , ( C19 . C21 ) , ( C19 . C22 )) ) * ( Morph-Map (C19 , C21 , C22) ) ) by L33 , L29 , PBOOLE:def 19;
end;
theorem
L35: (for B17 being non  empty  transitive AltCatStr holds (for B18 , B19 being  with_units non  empty AltCatStr holds (for B20 being  feasible  Contravariant FunctorStr over B17 , B18 holds (for B21 being FunctorStr over B18 , B19 holds (for B22 , B23 being (object of B17) holds ( Morph-Map (( B21 * B20 ) , B22 , B23) ) = ( ( Morph-Map (B21 , ( B20 . B23 ) , ( B20 . B22 )) ) * ( Morph-Map (B20 , B22 , B23) ) ))))))
proof
let C23 being non  empty  transitive AltCatStr;
let C24 , C25 being  with_units non  empty AltCatStr;
let C26 being  feasible  Contravariant FunctorStr over C23 , C24;
let C27 being FunctorStr over C24 , C25;
let C28 , C29 being (object of C23);
L36: (( dom (the MorphMap of C27) ) = [: (the carrier of C24) , (the carrier of C24) :] & ( rng (the ObjectMap of C26) ) c= [: (the carrier of C24) , (the carrier of C24) :]) by PARTFUN1:def 2;
L37: ( dom ( (the MorphMap of C27) * (the ObjectMap of C26) ) ) = ( dom (the ObjectMap of C26) ) by L36 , RELAT_1:27
.= [: (the carrier of C23) , (the carrier of C23) :] by FUNCT_2:def 1;
L38: [ C28 , C29 ] in ( dom ( (the MorphMap of C27) * (the ObjectMap of C26) ) ) by L37 , ZFMISC_1:87;
L39: ( ( (the MorphMap of C27) * (the ObjectMap of C26) ) . [ C28 , C29 ] ) = ( (the MorphMap of C27) . ( (the ObjectMap of C26) . (C28 , C29) ) ) by L38 , FUNCT_1:12
.= ( Morph-Map (C27 , ( C26 . C29 ) , ( C26 . C28 )) ) by FUNCTOR0:23;
L40: ( dom (the MorphMap of C26) ) = [: (the carrier of C23) , (the carrier of C23) :] by PARTFUN1:def 2;
L41: [ C28 , C29 ] in ( dom (the MorphMap of C26) ) by L40 , ZFMISC_1:87;
L42: [ C28 , C29 ] in ( ( dom ( (the MorphMap of C27) * (the ObjectMap of C26) ) ) /\ ( dom (the MorphMap of C26) ) ) by L41 , L38 , XBOOLE_0:def 4;
L43: [ C28 , C29 ] in ( dom ( ( (the MorphMap of C27) * (the ObjectMap of C26) ) ** (the MorphMap of C26) ) ) by L42 , PBOOLE:def 19;
thus L44: ( Morph-Map (( C27 * C26 ) , C28 , C29) ) = ( ( ( (the MorphMap of C27) * (the ObjectMap of C26) ) ** (the MorphMap of C26) ) . (C28 , C29) ) by FUNCTOR0:def 36
.= ( ( Morph-Map (C27 , ( C26 . C29 ) , ( C26 . C28 )) ) * ( Morph-Map (C26 , C28 , C29) ) ) by L43 , L39 , PBOOLE:def 19;
end;
L45: (for B24 being set holds (for B25 being non  empty set holds (for B26 being (Function of B24 , B25) holds (for B27 being (ManySortedSet of B24) holds (for B28 being (ManySortedSet of B25) holds (for B29 being (ManySortedFunction of B27 , ( B28 * B26 )) holds ( ( ( id B28 ) * B26 ) ** B29 ) = B29))))))
proof
let C30 being set;
let C31 being non  empty set;
let C32 being (Function of C30 , C31);
let C33 being (ManySortedSet of C30);
let C34 being (ManySortedSet of C31);
let C35 being (ManySortedFunction of C33 , ( C34 * C32 ));
L46:
now
let C36 being set;
assume L47: C36 in C30;
thus L48: ( ( C34 * C32 ) . C36 ) = ( C34 . ( C32 . C36 ) ) by L47 , FUNCT_2:15;
L49: (( ( ( id C34 ) * C32 ) . C36 ) = ( ( id C34 ) . ( C32 . C36 ) ) & ( C32 . C36 ) in C31) by L47 , FUNCT_2:5 , FUNCT_2:15;
thus L50: ( ( ( id C34 ) * C32 ) . C36 ) = ( id ( ( C34 * C32 ) . C36 ) ) by L49 , L48 , MSUALG_3:def 1;
end;
L51:
now
L52: ( ( id C34 ) * C32 ) is (ManySortedFunction of ( C34 * C32 ) , ( C34 * C32 ))
proof
let C37 being set;
assume L53: C37 in C30;
L54: ( ( ( id C34 ) * C32 ) . C37 ) = ( id ( ( C34 * C32 ) . C37 ) ) by L53 , L46;
thus L55: thesis by L54;
end;
let C38 being set;
assume L56: C38 in C30;
L57: ( C35 . C38 ) is (Function of ( C33 . C38 ) , ( ( C34 * C32 ) . C38 )) by L56 , PBOOLE:def 15;
L58: (( ( ( id C34 ) * C32 ) . C38 ) = ( ( id C34 ) . ( C32 . C38 ) ) & ( C32 . C38 ) in C31) by L56 , FUNCT_2:5 , FUNCT_2:15;
L59: ( ( ( id C34 ) * C32 ) . C38 ) = ( id ( C34 . ( C32 . C38 ) ) ) by L58 , MSUALG_3:def 1;
L60: ( ( C34 * C32 ) . C38 ) = ( C34 . ( C32 . C38 ) ) by L46 , L56;
thus L61: ( ( ( ( id C34 ) * C32 ) ** C35 ) . C38 ) = ( ( id ( ( C34 * C32 ) . C38 ) ) * ( C35 . C38 ) ) by L60 , L56 , L52 , L59 , MSUALG_3:2
.= ( C35 . C38 ) by L57 , FUNCT_2:17;
end;
thus L62: thesis by L51 , PBOOLE:3;
end;
theorem
L63: (for B30 being non  empty  transitive AltCatStr holds (for B31 being  with_units non  empty AltCatStr holds (for B32 being  feasible FunctorStr over B30 , B31 holds ( ( id B31 ) * B32 ) = ( the FunctorStr of B32 ))))
proof
let C39 being non  empty  transitive AltCatStr;
let C40 being  with_units non  empty AltCatStr;
let C41 being  feasible FunctorStr over C39 , C40;
L64: (the ObjectMap of ( ( id C40 ) * C41 )) = ( (the ObjectMap of ( id C40 )) * (the ObjectMap of C41) ) by FUNCTOR0:def 36
.= ( ( id [: (the carrier of C40) , (the carrier of C40) :] ) * (the ObjectMap of C41) ) by FUNCTOR0:def 29
.= (the ObjectMap of C41) by FUNCT_2:17;
L65: (the MorphMap of C41) is (ManySortedFunction of (the Arrows of C39) , ( (the Arrows of C40) * (the ObjectMap of C41) )) by FUNCTOR0:def 4;
L66: (the MorphMap of ( ( id C40 ) * C41 )) = ( ( (the MorphMap of ( id C40 )) * (the ObjectMap of C41) ) ** (the MorphMap of C41) ) by FUNCTOR0:def 36
.= ( ( ( id (the Arrows of C40) ) * (the ObjectMap of C41) ) ** (the MorphMap of C41) ) by FUNCTOR0:def 29
.= (the MorphMap of C41) by L65 , L45;
thus L67: thesis by L66 , L64;
end;
theorem
L68: (for B33 being  with_units  transitive non  empty AltCatStr holds (for B34 being  with_units non  empty AltCatStr holds (for B35 being  feasible FunctorStr over B33 , B34 holds ( B35 * ( id B33 ) ) = ( the FunctorStr of B35 ))))
proof
let C42 being  with_units  transitive non  empty AltCatStr;
let C43 being  with_units non  empty AltCatStr;
let C44 being  feasible FunctorStr over C42 , C43;
L69: (the ObjectMap of ( C44 * ( id C42 ) )) = ( (the ObjectMap of C44) * (the ObjectMap of ( id C42 )) ) by FUNCTOR0:def 36
.= ( (the ObjectMap of C44) * ( id [: (the carrier of C42) , (the carrier of C42) :] ) ) by FUNCTOR0:def 29
.= (the ObjectMap of C44) by FUNCT_2:17;
L70: (the MorphMap of C44) is (ManySortedFunction of (the Arrows of C42) , ( (the Arrows of C43) * (the ObjectMap of C44) )) by FUNCTOR0:def 4;
L71: (the MorphMap of ( C44 * ( id C42 ) )) = ( ( (the MorphMap of C44) * (the ObjectMap of ( id C42 )) ) ** (the MorphMap of ( id C42 )) ) by FUNCTOR0:def 36
.= ( ( (the MorphMap of C44) * ( id [: (the carrier of C42) , (the carrier of C42) :] ) ) ** (the MorphMap of ( id C42 )) ) by FUNCTOR0:def 29
.= ( (the MorphMap of C44) ** (the MorphMap of ( id C42 )) ) by FUNCTOR0:2
.= ( (the MorphMap of C44) ** ( id (the Arrows of C42) ) ) by FUNCTOR0:def 29
.= (the MorphMap of C44) by L70 , MSUALG_3:3;
thus L72: thesis by L71 , L69;
end;
theorem
L73: (for R1 being non  empty AltCatStr holds (for R2 being non  empty  reflexive AltCatStr holds (for R3 being non  empty  reflexive AltCatStr holds (for R4 being  feasible  Covariant FunctorStr over R1 , R2 holds (for R5 being  feasible  Covariant FunctorStr over R2 , R3 holds (for R8 being (object of R1) holds (for R9 being (object of R1) holds (for R10 being (Morphism of R8 , R9) holds (<^ R8 , R9 ^> <> ( {} ) implies ( ( R5 * R4 ) . R10 ) = ( R5 . ( R4 . R10 ) ))))))))))
proof
let R1 being non  empty AltCatStr;
let R2 being non  empty  reflexive AltCatStr;
let R3 being non  empty  reflexive AltCatStr;
let R4 being  feasible  Covariant FunctorStr over R1 , R2;
let R5 being  feasible  Covariant FunctorStr over R2 , R3;
let R8 being (object of R1);
let R9 being (object of R1);
let R10 being (Morphism of R8 , R9);
set D7 = (the carrier of R1);
reconsider D8 = ( (the MorphMap of R4) . (R8 , R9) ) as Function;
reconsider D9 = ( ( ( (the MorphMap of R5) * (the ObjectMap of R4) ) ** (the MorphMap of R4) ) . (R8 , R9) ) as Function;
reconsider D10 = ( ( (the MorphMap of R5) * (the ObjectMap of R4) ) . (R8 , R9) ) as Function;
L74: ( dom ( ( (the MorphMap of R5) * (the ObjectMap of R4) ) ** (the MorphMap of R4) ) ) = ( ( dom ( (the MorphMap of R5) * (the ObjectMap of R4) ) ) /\ ( dom (the MorphMap of R4) ) ) by PBOOLE:def 19
.= ( [: D7 , D7 :] /\ ( dom (the MorphMap of R4) ) ) by PARTFUN1:def 2
.= ( [: D7 , D7 :] /\ [: D7 , D7 :] ) by PARTFUN1:def 2
.= [: D7 , D7 :];
L75: ( dom (the ObjectMap of R4) ) = [: D7 , D7 :] by FUNCT_2:def 1;
L76: [ R8 , R9 ] in [: D7 , D7 :] by ZFMISC_1:def 2;
assume L77: <^ R8 , R9 ^> <> ( {} );
L78: <^ ( R4 . R8 ) , ( R4 . R9 ) ^> <> ( {} ) by L77 , FUNCTOR0:def 18;
L79: ( dom ( Morph-Map (R4 , R8 , R9) ) ) = <^ R8 , R9 ^> by L78 , FUNCT_2:def 1;
L80: <^ ( R5 . ( R4 . R8 ) ) , ( R5 . ( R4 . R9 ) ) ^> <> ( {} ) by L78 , FUNCTOR0:def 18;
L81: (( ( R5 * R4 ) . R8 ) = ( R5 . ( R4 . R8 ) ) & ( ( R5 * R4 ) . R9 ) = ( R5 . ( R4 . R9 ) )) by FUNCTOR0:33;
thus L82: ( ( R5 * R4 ) . R10 ) = ( ( Morph-Map (( R5 * R4 ) , R8 , R9) ) . R10 ) by L81 , L77 , L80 , FUNCTOR0:def 15
.= ( D9 . R10 ) by FUNCTOR0:def 36
.= ( ( D10 * D8 ) . R10 ) by L74 , L76 , PBOOLE:def 19
.= ( D10 . ( ( Morph-Map (R4 , R8 , R9) ) . R10 ) ) by L77 , L79 , FUNCT_1:13
.= ( D10 . ( R4 . R10 ) ) by L77 , L78 , FUNCTOR0:def 15
.= ( ( (the MorphMap of R5) . ( (the ObjectMap of R4) . (R8 , R9) ) ) . ( R4 . R10 ) ) by L75 , L76 , FUNCT_1:13
.= ( ( Morph-Map (R5 , ( R4 . R8 ) , ( R4 . R9 )) ) . ( R4 . R10 ) ) by FUNCTOR0:22
.= ( R5 . ( R4 . R10 ) ) by L78 , L80 , FUNCTOR0:def 15;
end;
theorem
L83: (for R1 being non  empty AltCatStr holds (for R2 being non  empty  reflexive AltCatStr holds (for R3 being non  empty  reflexive AltCatStr holds (for R6 being  feasible  Contravariant FunctorStr over R1 , R2 holds (for R7 being  feasible  Contravariant FunctorStr over R2 , R3 holds (for R8 being (object of R1) holds (for R9 being (object of R1) holds (for R10 being (Morphism of R8 , R9) holds (<^ R8 , R9 ^> <> ( {} ) implies ( ( R7 * R6 ) . R10 ) = ( R7 . ( R6 . R10 ) ))))))))))
proof
let R1 being non  empty AltCatStr;
let R2 being non  empty  reflexive AltCatStr;
let R3 being non  empty  reflexive AltCatStr;
let R6 being  feasible  Contravariant FunctorStr over R1 , R2;
let R7 being  feasible  Contravariant FunctorStr over R2 , R3;
let R8 being (object of R1);
let R9 being (object of R1);
let R10 being (Morphism of R8 , R9);
set D11 = (the carrier of R1);
reconsider D12 = ( (the MorphMap of R6) . (R8 , R9) ) as Function;
reconsider D13 = ( ( ( (the MorphMap of R7) * (the ObjectMap of R6) ) ** (the MorphMap of R6) ) . (R8 , R9) ) as Function;
reconsider D14 = ( ( (the MorphMap of R7) * (the ObjectMap of R6) ) . (R8 , R9) ) as Function;
L84: ( dom ( ( (the MorphMap of R7) * (the ObjectMap of R6) ) ** (the MorphMap of R6) ) ) = ( ( dom ( (the MorphMap of R7) * (the ObjectMap of R6) ) ) /\ ( dom (the MorphMap of R6) ) ) by PBOOLE:def 19
.= ( [: D11 , D11 :] /\ ( dom (the MorphMap of R6) ) ) by PARTFUN1:def 2
.= ( [: D11 , D11 :] /\ [: D11 , D11 :] ) by PARTFUN1:def 2
.= [: D11 , D11 :];
L85: ( dom (the ObjectMap of R6) ) = [: D11 , D11 :] by FUNCT_2:def 1;
L86: [ R8 , R9 ] in [: D11 , D11 :] by ZFMISC_1:def 2;
assume L87: <^ R8 , R9 ^> <> ( {} );
L88: <^ ( R6 . R9 ) , ( R6 . R8 ) ^> <> ( {} ) by L87 , FUNCTOR0:def 19;
L89: ( dom ( Morph-Map (R6 , R8 , R9) ) ) = <^ R8 , R9 ^> by L88 , FUNCT_2:def 1;
L90: <^ ( R7 . ( R6 . R8 ) ) , ( R7 . ( R6 . R9 ) ) ^> <> ( {} ) by L88 , FUNCTOR0:def 19;
L91: (( ( R7 * R6 ) . R8 ) = ( R7 . ( R6 . R8 ) ) & ( ( R7 * R6 ) . R9 ) = ( R7 . ( R6 . R9 ) )) by FUNCTOR0:33;
thus L92: ( ( R7 * R6 ) . R10 ) = ( ( Morph-Map (( R7 * R6 ) , R8 , R9) ) . R10 ) by L91 , L87 , L90 , FUNCTOR0:def 15
.= ( D13 . R10 ) by FUNCTOR0:def 36
.= ( ( D14 * D12 ) . R10 ) by L84 , L86 , PBOOLE:def 19
.= ( D14 . ( ( Morph-Map (R6 , R8 , R9) ) . R10 ) ) by L87 , L89 , FUNCT_1:13
.= ( D14 . ( R6 . R10 ) ) by L87 , L88 , FUNCTOR0:def 16
.= ( ( (the MorphMap of R7) . ( (the ObjectMap of R6) . (R8 , R9) ) ) . ( R6 . R10 ) ) by L85 , L86 , FUNCT_1:13
.= ( ( Morph-Map (R7 , ( R6 . R9 ) , ( R6 . R8 )) ) . ( R6 . R10 ) ) by FUNCTOR0:23
.= ( R7 . ( R6 . R10 ) ) by L88 , L90 , FUNCTOR0:def 16;
end;
theorem
L93: (for R1 being non  empty AltCatStr holds (for R2 being non  empty  reflexive AltCatStr holds (for R3 being non  empty  reflexive AltCatStr holds (for R4 being  feasible  Covariant FunctorStr over R1 , R2 holds (for R7 being  feasible  Contravariant FunctorStr over R2 , R3 holds (for R8 being (object of R1) holds (for R9 being (object of R1) holds (for R10 being (Morphism of R8 , R9) holds (<^ R8 , R9 ^> <> ( {} ) implies ( ( R7 * R4 ) . R10 ) = ( R7 . ( R4 . R10 ) ))))))))))
proof
let R1 being non  empty AltCatStr;
let R2 being non  empty  reflexive AltCatStr;
let R3 being non  empty  reflexive AltCatStr;
let R4 being  feasible  Covariant FunctorStr over R1 , R2;
let R7 being  feasible  Contravariant FunctorStr over R2 , R3;
let R8 being (object of R1);
let R9 being (object of R1);
let R10 being (Morphism of R8 , R9);
set D15 = (the carrier of R1);
reconsider D16 = ( (the MorphMap of R4) . (R8 , R9) ) as Function;
reconsider D17 = ( ( ( (the MorphMap of R7) * (the ObjectMap of R4) ) ** (the MorphMap of R4) ) . (R8 , R9) ) as Function;
reconsider D18 = ( ( (the MorphMap of R7) * (the ObjectMap of R4) ) . (R8 , R9) ) as Function;
L94: ( dom ( ( (the MorphMap of R7) * (the ObjectMap of R4) ) ** (the MorphMap of R4) ) ) = ( ( dom ( (the MorphMap of R7) * (the ObjectMap of R4) ) ) /\ ( dom (the MorphMap of R4) ) ) by PBOOLE:def 19
.= ( [: D15 , D15 :] /\ ( dom (the MorphMap of R4) ) ) by PARTFUN1:def 2
.= ( [: D15 , D15 :] /\ [: D15 , D15 :] ) by PARTFUN1:def 2
.= [: D15 , D15 :];
L95: ( dom (the ObjectMap of R4) ) = [: D15 , D15 :] by FUNCT_2:def 1;
L96: [ R8 , R9 ] in [: D15 , D15 :] by ZFMISC_1:def 2;
assume L97: <^ R8 , R9 ^> <> ( {} );
L98: <^ ( R4 . R8 ) , ( R4 . R9 ) ^> <> ( {} ) by L97 , FUNCTOR0:def 18;
L99: ( dom ( Morph-Map (R4 , R8 , R9) ) ) = <^ R8 , R9 ^> by L98 , FUNCT_2:def 1;
L100: <^ ( R7 . ( R4 . R9 ) ) , ( R7 . ( R4 . R8 ) ) ^> <> ( {} ) by L98 , FUNCTOR0:def 19;
L101: (( ( R7 * R4 ) . R8 ) = ( R7 . ( R4 . R8 ) ) & ( ( R7 * R4 ) . R9 ) = ( R7 . ( R4 . R9 ) )) by FUNCTOR0:33;
thus L102: ( ( R7 * R4 ) . R10 ) = ( ( Morph-Map (( R7 * R4 ) , R8 , R9) ) . R10 ) by L101 , L97 , L100 , FUNCTOR0:def 16
.= ( D17 . R10 ) by FUNCTOR0:def 36
.= ( ( D18 * D16 ) . R10 ) by L94 , L96 , PBOOLE:def 19
.= ( D18 . ( ( Morph-Map (R4 , R8 , R9) ) . R10 ) ) by L97 , L99 , FUNCT_1:13
.= ( D18 . ( R4 . R10 ) ) by L97 , L98 , FUNCTOR0:def 15
.= ( ( (the MorphMap of R7) . ( (the ObjectMap of R4) . (R8 , R9) ) ) . ( R4 . R10 ) ) by L95 , L96 , FUNCT_1:13
.= ( ( Morph-Map (R7 , ( R4 . R8 ) , ( R4 . R9 )) ) . ( R4 . R10 ) ) by FUNCTOR0:22
.= ( R7 . ( R4 . R10 ) ) by L98 , L100 , FUNCTOR0:def 16;
end;
theorem
L103: (for R1 being non  empty AltCatStr holds (for R2 being non  empty  reflexive AltCatStr holds (for R3 being non  empty  reflexive AltCatStr holds (for R5 being  feasible  Covariant FunctorStr over R2 , R3 holds (for R6 being  feasible  Contravariant FunctorStr over R1 , R2 holds (for R8 being (object of R1) holds (for R9 being (object of R1) holds (for R10 being (Morphism of R8 , R9) holds (<^ R8 , R9 ^> <> ( {} ) implies ( ( R5 * R6 ) . R10 ) = ( R5 . ( R6 . R10 ) ))))))))))
proof
let R1 being non  empty AltCatStr;
let R2 being non  empty  reflexive AltCatStr;
let R3 being non  empty  reflexive AltCatStr;
let R5 being  feasible  Covariant FunctorStr over R2 , R3;
let R6 being  feasible  Contravariant FunctorStr over R1 , R2;
let R8 being (object of R1);
let R9 being (object of R1);
let R10 being (Morphism of R8 , R9);
set D19 = (the carrier of R1);
reconsider D20 = ( (the MorphMap of R6) . (R8 , R9) ) as Function;
reconsider D21 = ( ( ( (the MorphMap of R5) * (the ObjectMap of R6) ) ** (the MorphMap of R6) ) . (R8 , R9) ) as Function;
reconsider D22 = ( ( (the MorphMap of R5) * (the ObjectMap of R6) ) . (R8 , R9) ) as Function;
L104: ( dom ( ( (the MorphMap of R5) * (the ObjectMap of R6) ) ** (the MorphMap of R6) ) ) = ( ( dom ( (the MorphMap of R5) * (the ObjectMap of R6) ) ) /\ ( dom (the MorphMap of R6) ) ) by PBOOLE:def 19
.= ( [: D19 , D19 :] /\ ( dom (the MorphMap of R6) ) ) by PARTFUN1:def 2
.= ( [: D19 , D19 :] /\ [: D19 , D19 :] ) by PARTFUN1:def 2
.= [: D19 , D19 :];
L105: ( dom (the ObjectMap of R6) ) = [: D19 , D19 :] by FUNCT_2:def 1;
L106: [ R8 , R9 ] in [: D19 , D19 :] by ZFMISC_1:def 2;
assume L107: <^ R8 , R9 ^> <> ( {} );
L108: <^ ( R6 . R9 ) , ( R6 . R8 ) ^> <> ( {} ) by L107 , FUNCTOR0:def 19;
L109: ( dom ( Morph-Map (R6 , R8 , R9) ) ) = <^ R8 , R9 ^> by L108 , FUNCT_2:def 1;
L110: <^ ( R5 . ( R6 . R9 ) ) , ( R5 . ( R6 . R8 ) ) ^> <> ( {} ) by L108 , FUNCTOR0:def 18;
L111: (( ( R5 * R6 ) . R8 ) = ( R5 . ( R6 . R8 ) ) & ( ( R5 * R6 ) . R9 ) = ( R5 . ( R6 . R9 ) )) by FUNCTOR0:33;
thus L112: ( ( R5 * R6 ) . R10 ) = ( ( Morph-Map (( R5 * R6 ) , R8 , R9) ) . R10 ) by L111 , L107 , L110 , FUNCTOR0:def 16
.= ( D21 . R10 ) by FUNCTOR0:def 36
.= ( ( D22 * D20 ) . R10 ) by L104 , L106 , PBOOLE:def 19
.= ( D22 . ( ( Morph-Map (R6 , R8 , R9) ) . R10 ) ) by L107 , L109 , FUNCT_1:13
.= ( D22 . ( R6 . R10 ) ) by L107 , L108 , FUNCTOR0:def 16
.= ( ( (the MorphMap of R5) . ( (the ObjectMap of R6) . (R8 , R9) ) ) . ( R6 . R10 ) ) by L105 , L106 , FUNCT_1:13
.= ( ( Morph-Map (R5 , ( R6 . R9 ) , ( R6 . R8 )) ) . ( R6 . R10 ) ) by FUNCTOR0:23
.= ( R5 . ( R6 . R10 ) ) by L108 , L110 , FUNCTOR0:def 15;
end;
registration
let C45 being non  empty  transitive AltCatStr;
let C46 being  transitive  with_units non  empty AltCatStr;
let C47 being  with_units non  empty AltCatStr;
let C48 being  feasible  Covariant  comp-preserving FunctorStr over C45 , C46;
let C49 being  feasible  Covariant  comp-preserving FunctorStr over C46 , C47;
cluster ( C49 * C48 ) ->  comp-preserving;
coherence
proof
let C50 , C51 , C52 being (object of C45);
assume that
L113: <^ C50 , C51 ^> <> ( {} )
and
L114: <^ C51 , C52 ^> <> ( {} );
L115: (<^ ( C48 . C50 ) , ( C48 . C51 ) ^> <> ( {} ) & <^ ( C48 . C51 ) , ( C48 . C52 ) ^> <> ( {} )) by L113 , L114 , FUNCTOR0:def 18;
let C53 being (Morphism of C50 , C51);
let C54 being (Morphism of C51 , C52);
L116: (( ( C49 * C48 ) . C50 ) = ( C49 . ( C48 . C50 ) ) & ( ( C49 * C48 ) . C52 ) = ( C49 . ( C48 . C52 ) )) by FUNCTOR0:33;
L117: ( ( C49 * C48 ) . C51 ) = ( C49 . ( C48 . C51 ) ) by FUNCTOR0:33;
reconsider D23 = ( ( C49 * C48 ) . C54 ) as (Morphism of ( C49 . ( C48 . C51 ) ) , ( C49 . ( C48 . C52 ) )) by L117 , FUNCTOR0:33;
L118: <^ C50 , C52 ^> <> ( {} ) by L113 , L114 , ALTCAT_1:def 2;
thus L119: ( ( C49 * C48 ) . ( C54 * C53 ) ) = ( C49 . ( C48 . ( C54 * C53 ) ) ) by L118 , L73
.= ( C49 . ( ( C48 . C54 ) * ( C48 . C53 ) ) ) by L113 , L114 , FUNCTOR0:def 23
.= ( ( C49 . ( C48 . C54 ) ) * ( C49 . ( C48 . C53 ) ) ) by L115 , FUNCTOR0:def 23
.= ( D23 * ( C49 . ( C48 . C53 ) ) ) by L114 , L73
.= ( ( ( C49 * C48 ) . C54 ) * ( ( C49 * C48 ) . C53 ) ) by L113 , L117 , L116 , L73;
end;
end;
registration
let C55 being non  empty  transitive AltCatStr;
let C56 being  transitive  with_units non  empty AltCatStr;
let C57 being  with_units non  empty AltCatStr;
let C58 being  feasible  Contravariant  comp-reversing FunctorStr over C55 , C56;
let C59 being  feasible  Contravariant  comp-reversing FunctorStr over C56 , C57;
cluster ( C59 * C58 ) ->  comp-preserving;
coherence
proof
let C60 , C61 , C62 being (object of C55);
assume that
L121: <^ C60 , C61 ^> <> ( {} )
and
L122: <^ C61 , C62 ^> <> ( {} );
L123: (<^ ( C58 . C61 ) , ( C58 . C60 ) ^> <> ( {} ) & <^ ( C58 . C62 ) , ( C58 . C61 ) ^> <> ( {} )) by L121 , L122 , FUNCTOR0:def 19;
let C63 being (Morphism of C60 , C61);
let C64 being (Morphism of C61 , C62);
L124: (( ( C59 * C58 ) . C60 ) = ( C59 . ( C58 . C60 ) ) & ( ( C59 * C58 ) . C62 ) = ( C59 . ( C58 . C62 ) )) by FUNCTOR0:33;
L125: ( ( C59 * C58 ) . C61 ) = ( C59 . ( C58 . C61 ) ) by FUNCTOR0:33;
reconsider D24 = ( ( C59 * C58 ) . C64 ) as (Morphism of ( C59 . ( C58 . C61 ) ) , ( C59 . ( C58 . C62 ) )) by L125 , FUNCTOR0:33;
L126: <^ C60 , C62 ^> <> ( {} ) by L121 , L122 , ALTCAT_1:def 2;
thus L127: ( ( C59 * C58 ) . ( C64 * C63 ) ) = ( C59 . ( C58 . ( C64 * C63 ) ) ) by L126 , L83
.= ( C59 . ( ( C58 . C63 ) * ( C58 . C64 ) ) ) by L121 , L122 , FUNCTOR0:def 24
.= ( ( C59 . ( C58 . C64 ) ) * ( C59 . ( C58 . C63 ) ) ) by L123 , FUNCTOR0:def 24
.= ( D24 * ( C59 . ( C58 . C63 ) ) ) by L122 , L83
.= ( ( ( C59 * C58 ) . C64 ) * ( ( C59 * C58 ) . C63 ) ) by L121 , L125 , L124 , L83;
end;
end;
registration
let C65 being non  empty  transitive AltCatStr;
let C66 being  transitive  with_units non  empty AltCatStr;
let C67 being  with_units non  empty AltCatStr;
let C68 being  feasible  Covariant  comp-preserving FunctorStr over C65 , C66;
let C69 being  feasible  Contravariant  comp-reversing FunctorStr over C66 , C67;
cluster ( C69 * C68 ) ->  comp-reversing;
coherence
proof
let C70 , C71 , C72 being (object of C65);
assume that
L129: <^ C70 , C71 ^> <> ( {} )
and
L130: <^ C71 , C72 ^> <> ( {} );
L131: (<^ ( C68 . C70 ) , ( C68 . C71 ) ^> <> ( {} ) & <^ ( C68 . C71 ) , ( C68 . C72 ) ^> <> ( {} )) by L129 , L130 , FUNCTOR0:def 18;
let C73 being (Morphism of C70 , C71);
let C74 being (Morphism of C71 , C72);
L132: (( ( C69 * C68 ) . C71 ) = ( C69 . ( C68 . C71 ) ) & ( ( C69 * C68 ) . C72 ) = ( C69 . ( C68 . C72 ) )) by FUNCTOR0:33;
L133: ( ( C69 * C68 ) . C70 ) = ( C69 . ( C68 . C70 ) ) by FUNCTOR0:33;
reconsider D25 = ( ( C69 * C68 ) . C73 ) as (Morphism of ( C69 . ( C68 . C71 ) ) , ( C69 . ( C68 . C70 ) )) by L133 , FUNCTOR0:33;
L134: <^ C70 , C72 ^> <> ( {} ) by L129 , L130 , ALTCAT_1:def 2;
thus L135: ( ( C69 * C68 ) . ( C74 * C73 ) ) = ( C69 . ( C68 . ( C74 * C73 ) ) ) by L134 , L93
.= ( C69 . ( ( C68 . C74 ) * ( C68 . C73 ) ) ) by L129 , L130 , FUNCTOR0:def 23
.= ( ( C69 . ( C68 . C73 ) ) * ( C69 . ( C68 . C74 ) ) ) by L131 , FUNCTOR0:def 24
.= ( D25 * ( C69 . ( C68 . C74 ) ) ) by L129 , L93
.= ( ( ( C69 * C68 ) . C73 ) * ( ( C69 * C68 ) . C74 ) ) by L130 , L133 , L132 , L93;
end;
end;
registration
let C75 being non  empty  transitive AltCatStr;
let C76 being  transitive  with_units non  empty AltCatStr;
let C77 being  with_units non  empty AltCatStr;
let C78 being  feasible  Contravariant  comp-reversing FunctorStr over C75 , C76;
let C79 being  feasible  Covariant  comp-preserving FunctorStr over C76 , C77;
cluster ( C79 * C78 ) ->  comp-reversing;
coherence
proof
let C80 , C81 , C82 being (object of C75);
assume that
L137: <^ C80 , C81 ^> <> ( {} )
and
L138: <^ C81 , C82 ^> <> ( {} );
L139: (<^ ( C78 . C81 ) , ( C78 . C80 ) ^> <> ( {} ) & <^ ( C78 . C82 ) , ( C78 . C81 ) ^> <> ( {} )) by L137 , L138 , FUNCTOR0:def 19;
let C83 being (Morphism of C80 , C81);
let C84 being (Morphism of C81 , C82);
L140: (( ( C79 * C78 ) . C81 ) = ( C79 . ( C78 . C81 ) ) & ( ( C79 * C78 ) . C82 ) = ( C79 . ( C78 . C82 ) )) by FUNCTOR0:33;
L141: ( ( C79 * C78 ) . C80 ) = ( C79 . ( C78 . C80 ) ) by FUNCTOR0:33;
reconsider D26 = ( ( C79 * C78 ) . C83 ) as (Morphism of ( C79 . ( C78 . C81 ) ) , ( C79 . ( C78 . C80 ) )) by L141 , FUNCTOR0:33;
L142: <^ C80 , C82 ^> <> ( {} ) by L137 , L138 , ALTCAT_1:def 2;
thus L143: ( ( C79 * C78 ) . ( C84 * C83 ) ) = ( C79 . ( C78 . ( C84 * C83 ) ) ) by L142 , L103
.= ( C79 . ( ( C78 . C83 ) * ( C78 . C84 ) ) ) by L137 , L138 , FUNCTOR0:def 24
.= ( ( C79 . ( C78 . C83 ) ) * ( C79 . ( C78 . C84 ) ) ) by L139 , FUNCTOR0:def 23
.= ( D26 * ( C79 . ( C78 . C84 ) ) ) by L137 , L103
.= ( ( ( C79 * C78 ) . C83 ) * ( ( C79 * C78 ) . C84 ) ) by L138 , L141 , L140 , L103;
end;
end;
definition
let C85 , C86 being  transitive  with_units non  empty AltCatStr;
let C87 being  with_units non  empty AltCatStr;
let C88 being  covariant (Functor of C85 , C86);
let C89 being  covariant (Functor of C86 , C87);
redefine func C89 * C88 ->  strict  covariant (Functor of C85 , C87);

coherence by FUNCTOR0:def 25;
end;
definition
let C90 , C91 being  transitive  with_units non  empty AltCatStr;
let C92 being  with_units non  empty AltCatStr;
let C93 being  contravariant (Functor of C90 , C91);
let C94 being  contravariant (Functor of C91 , C92);
redefine func C94 * C93 ->  strict  covariant (Functor of C90 , C92);

coherence by FUNCTOR0:def 25;
end;
definition
let C95 , C96 being  transitive  with_units non  empty AltCatStr;
let C97 being  with_units non  empty AltCatStr;
let C98 being  covariant (Functor of C95 , C96);
let C99 being  contravariant (Functor of C96 , C97);
redefine func C99 * C98 ->  strict  contravariant (Functor of C95 , C97);

coherence by FUNCTOR0:def 25;
end;
definition
let C100 , C101 being  transitive  with_units non  empty AltCatStr;
let C102 being  with_units non  empty AltCatStr;
let C103 being  contravariant (Functor of C100 , C101);
let C104 being  covariant (Functor of C101 , C102);
redefine func C104 * C103 ->  strict  contravariant (Functor of C100 , C102);

coherence by FUNCTOR0:def 25;
end;
theorem
L149: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds ((R15 is_transformable_to R16 & R18 is_transformable_to R19) implies ( R18 * R15 ) is_transformable_to ( R19 * R16 )))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
assume L150: (for B36 being (object of R11) holds <^ ( R15 . B36 ) , ( R16 . B36 ) ^> <> ( {} ));
assume L151: (for B37 being (object of R12) holds <^ ( R18 . B37 ) , ( R19 . B37 ) ^> <> ( {} ));
let C105 being (object of R11);
L152: <^ ( R15 . C105 ) , ( R16 . C105 ) ^> <> ( {} ) by L150;
L153: <^ ( R18 . ( R15 . C105 ) ) , ( R18 . ( R16 . C105 ) ) ^> <> ( {} ) by L152 , FUNCTOR0:def 18;
L154: (( ( R18 * R15 ) . C105 ) = ( R18 . ( R15 . C105 ) ) & ( ( R19 * R16 ) . C105 ) = ( R19 . ( R16 . C105 ) )) by FUNCTOR0:33;
L155: <^ ( R18 . ( R16 . C105 ) ) , ( R19 . ( R16 . C105 ) ) ^> <> ( {} ) by L151;
thus L156: thesis by L155 , L154 , L153 , ALTCAT_1:def 2;
end;
begin
definition
let C106 , C107 , C108 being  transitive  with_units non  empty AltCatStr;
let C109 , C110 being  covariant (Functor of C106 , C107);
let C111 being (transformation of C109 , C110);
let C112 being  covariant (Functor of C107 , C108);
assume that
L157: C109 is_transformable_to C110;
func C112 * C111 -> (transformation of ( C112 * C109 ) , ( C112 * C110 )) means 
:L158: (for B38 being (object of C106) holds ( it . B38 ) = ( C112 . ( C111 ! B38 ) ));
existence
proof
defpred S1[ set , set ] means (ex B39 being (object of C106) st ($1 = B39 & $2 = ( C112 . ( C111 ! B39 ) )));
set D27 = (the carrier of C106);
L159: (for B40 being set holds (B40 in D27 implies (ex B41 being set st S1[ B40 , B41 ])))
proof
let C113 being set;
assume L160: C113 in D27;
reconsider D28 = C113 as (object of C106) by L160;
take ( C112 . ( C111 ! D28 ) );
thus L161: thesis;
end;
consider C114 being (ManySortedSet of D27) such that L162: (for B42 being set holds (B42 in D27 implies S1[ B42 , ( C114 . B42 ) ])) from PBOOLE:sch 3(L159);
L163: C114 is (transformation of ( C112 * C109 ) , ( C112 * C110 ))
proof
thus L164: ( C112 * C109 ) is_transformable_to ( C112 * C110 ) by L157 , L149;
let C115 being (object of C106);
L165: (S1[ C115 , ( C114 . C115 ) ] & ( C112 . ( C109 . C115 ) ) = ( ( C112 * C109 ) . C115 )) by L162 , FUNCTOR0:33;
thus L166: thesis by L165 , FUNCTOR0:33;
end;
reconsider D29 = C114 as (transformation of ( C112 * C109 ) , ( C112 * C110 )) by L163;
take D29;
let C116 being (object of C106);
L167: S1[ C116 , ( D29 . C116 ) ] by L162;
thus L168: thesis by L167;
end;
uniqueness
proof
let C117 , C118 being (transformation of ( C112 * C109 ) , ( C112 * C110 ));
assume that
L169: (for B43 being (object of C106) holds ( C117 . B43 ) = ( C112 . ( C111 ! B43 ) ))
and
L170: (for B44 being (object of C106) holds ( C118 . B44 ) = ( C112 . ( C111 ! B44 ) ));
L171: ( C112 * C109 ) is_transformable_to ( C112 * C110 ) by L157 , L149;
L172:
now
let C119 being (object of C106);
thus L173: ( C117 ! C119 ) = ( C117 . C119 ) by L171 , FUNCTOR2:def 4
.= ( C112 . ( C111 ! C119 ) ) by L169
.= ( C118 . C119 ) by L170
.= ( C118 ! C119 ) by L171 , FUNCTOR2:def 4;
end;
thus L174: thesis by L172 , L157 , L149 , FUNCTOR2:3;
end;
end;
theorem
L176: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R23 being (transformation of R15 , R16) holds (for B45 being (object of R11) holds (R15 is_transformable_to R16 implies ( ( R18 * R23 ) ! B45 ) = ( R18 . ( R23 ! B45 ) ))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R23 being (transformation of R15 , R16);
let C120 being (object of R11);
assume L177: R15 is_transformable_to R16;
L178: ( R18 * R15 ) is_transformable_to ( R18 * R16 ) by L177 , L149;
thus L179: ( ( R18 * R23 ) ! C120 ) = ( ( R18 * R23 ) . C120 ) by L178 , FUNCTOR2:def 4
.= ( R18 . ( R23 ! C120 ) ) by L177 , L158;
end;
definition
let C121 , C122 , C123 being  transitive  with_units non  empty AltCatStr;
let C124 , C125 being  covariant (Functor of C122 , C123);
let C126 being  covariant (Functor of C121 , C122);
let C127 being (transformation of C124 , C125);
assume that
L180: C124 is_transformable_to C125;
func C127 * C126 -> (transformation of ( C124 * C126 ) , ( C125 * C126 )) means 
:L181: (for B46 being (object of C121) holds ( it . B46 ) = ( C127 ! ( C126 . B46 ) ));
existence
proof
defpred S2[ set , set ] means (ex B47 being (object of C121) st ($1 = B47 & $2 = ( C127 ! ( C126 . B47 ) )));
set D30 = (the carrier of C121);
L182: (for B48 being set holds (B48 in D30 implies (ex B49 being set st S2[ B48 , B49 ])))
proof
let C128 being set;
assume L183: C128 in D30;
reconsider D31 = C128 as (object of C121) by L183;
take ( C127 ! ( C126 . D31 ) );
thus L184: thesis;
end;
consider C129 being (ManySortedSet of D30) such that L185: (for B50 being set holds (B50 in D30 implies S2[ B50 , ( C129 . B50 ) ])) from PBOOLE:sch 3(L182);
L186: C129 is (transformation of ( C124 * C126 ) , ( C125 * C126 ))
proof
thus L187: ( C124 * C126 ) is_transformable_to ( C125 * C126 ) by L180 , L149;
let C130 being (object of C121);
L188: (S2[ C130 , ( C129 . C130 ) ] & ( C124 . ( C126 . C130 ) ) = ( ( C124 * C126 ) . C130 )) by L185 , FUNCTOR0:33;
thus L189: thesis by L188 , FUNCTOR0:33;
end;
reconsider D32 = C129 as (transformation of ( C124 * C126 ) , ( C125 * C126 )) by L186;
take D32;
let C131 being (object of C121);
L190: S2[ C131 , ( D32 . C131 ) ] by L185;
thus L191: thesis by L190;
end;
uniqueness
proof
let C132 , C133 being (transformation of ( C124 * C126 ) , ( C125 * C126 ));
assume that
L192: (for B51 being (object of C121) holds ( C132 . B51 ) = ( C127 ! ( C126 . B51 ) ))
and
L193: (for B52 being (object of C121) holds ( C133 . B52 ) = ( C127 ! ( C126 . B52 ) ));
L194: ( C124 * C126 ) is_transformable_to ( C125 * C126 ) by L180 , L149;
L195:
now
let C134 being (object of C121);
thus L196: ( C132 ! C134 ) = ( C132 . C134 ) by L194 , FUNCTOR2:def 4
.= ( C127 ! ( C126 . C134 ) ) by L192
.= ( C133 . C134 ) by L193
.= ( C133 ! C134 ) by L194 , FUNCTOR2:def 4;
end;
thus L197: thesis by L195 , L180 , L149 , FUNCTOR2:3;
end;
end;
theorem
L199: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R25 being (transformation of R18 , R19) holds (for B53 being (object of R11) holds (R18 is_transformable_to R19 implies ( ( R25 * R15 ) ! B53 ) = ( R25 ! ( R15 . B53 ) ))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R25 being (transformation of R18 , R19);
let C135 being (object of R11);
assume L200: R18 is_transformable_to R19;
L201: ( R18 * R15 ) is_transformable_to ( R19 * R15 ) by L200 , L149;
thus L202: ( ( R25 * R15 ) ! C135 ) = ( ( R25 * R15 ) . C135 ) by L201 , FUNCTOR2:def 4
.= ( R25 ! ( R15 . C135 ) ) by L200 , L181;
end;
theorem
L203: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R17 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R23 being (transformation of R15 , R16) holds (for R24 being (transformation of R16 , R17) holds ((R15 is_transformable_to R16 & R16 is_transformable_to R17) implies ( R18 * ( R24 `*` R23 ) ) = ( ( R18 * R24 ) `*` ( R18 * R23 ) )))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R17 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R23 being (transformation of R15 , R16);
let R24 being (transformation of R16 , R17);
assume that
L204: R15 is_transformable_to R16
and
L205: R16 is_transformable_to R17;
L206: (( R18 * R15 ) is_transformable_to ( R18 * R16 ) & ( R18 * R16 ) is_transformable_to ( R18 * R17 )) by L204 , L205 , L149;
L207:
now
let C136 being (object of R11);
L208: (( R18 . ( R16 . C136 ) ) = ( ( R18 * R16 ) . C136 ) & ( R18 . ( R17 . C136 ) ) = ( ( R18 * R17 ) . C136 )) by FUNCTOR0:33;
L209: ( R18 . ( R15 . C136 ) ) = ( ( R18 * R15 ) . C136 ) by FUNCTOR0:33;
reconsider D33 = ( ( R18 * R23 ) ! C136 ) as (Morphism of ( R18 . ( R15 . C136 ) ) , ( R18 . ( R16 . C136 ) )) by L209 , FUNCTOR0:33;
L210: (<^ ( R15 . C136 ) , ( R16 . C136 ) ^> <> ( {} ) & <^ ( R16 . C136 ) , ( R17 . C136 ) ^> <> ( {} )) by L204 , L205 , FUNCTOR2:def 1;
thus L211: ( ( R18 * ( R24 `*` R23 ) ) ! C136 ) = ( R18 . ( ( R24 `*` R23 ) ! C136 ) ) by L204 , L205 , L176 , FUNCTOR2:2
.= ( R18 . ( ( R24 ! C136 ) * ( R23 ! C136 ) ) ) by L204 , L205 , FUNCTOR2:def 5
.= ( ( R18 . ( R24 ! C136 ) ) * ( R18 . ( R23 ! C136 ) ) ) by L210 , FUNCTOR0:def 23
.= ( ( R18 . ( R24 ! C136 ) ) * D33 ) by L204 , L176
.= ( ( ( R18 * R24 ) ! C136 ) * ( ( R18 * R23 ) ! C136 ) ) by L205 , L209 , L208 , L176
.= ( ( ( R18 * R24 ) `*` ( R18 * R23 ) ) ! C136 ) by L206 , FUNCTOR2:def 5;
end;
L212: R15 is_transformable_to R17 by L204 , L205 , FUNCTOR2:2;
thus L213: thesis by L212 , L207 , L149 , FUNCTOR2:3;
end;
theorem
L214: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R20 being  covariant (Functor of R12 , R13) holds (for R25 being (transformation of R18 , R19) holds (for R26 being (transformation of R19 , R20) holds ((R18 is_transformable_to R19 & R19 is_transformable_to R20) implies ( ( R26 `*` R25 ) * R15 ) = ( ( R26 * R15 ) `*` ( R25 * R15 ) )))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R20 being  covariant (Functor of R12 , R13);
let R25 being (transformation of R18 , R19);
let R26 being (transformation of R19 , R20);
assume that
L215: R18 is_transformable_to R19
and
L216: R19 is_transformable_to R20;
L217: (( R18 * R15 ) is_transformable_to ( R19 * R15 ) & ( R19 * R15 ) is_transformable_to ( R20 * R15 )) by L215 , L216 , L149;
L218:
now
let C137 being (object of R11);
L219: (( R18 . ( R15 . C137 ) ) = ( ( R18 * R15 ) . C137 ) & ( R20 . ( R15 . C137 ) ) = ( ( R20 * R15 ) . C137 )) by FUNCTOR0:33;
L220: ( R19 . ( R15 . C137 ) ) = ( ( R19 * R15 ) . C137 ) by FUNCTOR0:33;
reconsider D34 = ( ( R26 * R15 ) ! C137 ) as (Morphism of ( R19 . ( R15 . C137 ) ) , ( R20 . ( R15 . C137 ) )) by L220 , FUNCTOR0:33;
thus L221: ( ( ( R26 `*` R25 ) * R15 ) ! C137 ) = ( ( R26 `*` R25 ) ! ( R15 . C137 ) ) by L215 , L216 , L199 , FUNCTOR2:2
.= ( ( R26 ! ( R15 . C137 ) ) * ( R25 ! ( R15 . C137 ) ) ) by L215 , L216 , FUNCTOR2:def 5
.= ( D34 * ( R25 ! ( R15 . C137 ) ) ) by L216 , L199
.= ( ( ( R26 * R15 ) ! C137 ) * ( ( R25 * R15 ) ! C137 ) ) by L215 , L220 , L219 , L199
.= ( ( ( R26 * R15 ) `*` ( R25 * R15 ) ) ! C137 ) by L217 , FUNCTOR2:def 5;
end;
L222: R18 is_transformable_to R20 by L215 , L216 , FUNCTOR2:2;
thus L223: thesis by L222 , L218 , L149 , FUNCTOR2:3;
end;
theorem
L224: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R14 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R21 being  covariant (Functor of R13 , R14) holds (for R22 being  covariant (Functor of R13 , R14) holds (for R27 being (transformation of R21 , R22) holds (R21 is_transformable_to R22 implies ( ( R27 * R18 ) * R15 ) = ( R27 * ( R18 * R15 ) )))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R14 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R21 being  covariant (Functor of R13 , R14);
let R22 being  covariant (Functor of R13 , R14);
let R27 being (transformation of R21 , R22);
L225: ( ( R22 * R18 ) * R15 ) = ( R22 * ( R18 * R15 ) ) by FUNCTOR0:32;
reconsider D35 = ( R27 * ( R18 * R15 ) ) as (transformation of ( ( R21 * R18 ) * R15 ) , ( ( R22 * R18 ) * R15 )) by L225 , FUNCTOR0:32;
assume L226: R21 is_transformable_to R22;
L227:
now
let C138 being (object of R11);
thus L228: ( ( ( R27 * R18 ) * R15 ) ! C138 ) = ( ( R27 * R18 ) ! ( R15 . C138 ) ) by L226 , L149 , L199
.= ( R27 ! ( R18 . ( R15 . C138 ) ) ) by L226 , L199
.= ( R27 ! ( ( R18 * R15 ) . C138 ) ) by FUNCTOR0:33
.= ( ( R27 * ( R18 * R15 ) ) ! C138 ) by L226 , L199
.= ( D35 ! C138 ) by L225 , FUNCTOR0:32;
end;
L229: ( R21 * R18 ) is_transformable_to ( R22 * R18 ) by L226 , L149;
thus L230: thesis by L229 , L227 , L149 , FUNCTOR2:3;
end;
theorem
L231: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R14 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R21 being  covariant (Functor of R13 , R14) holds (for R25 being (transformation of R18 , R19) holds (R18 is_transformable_to R19 implies ( ( R21 * R25 ) * R15 ) = ( R21 * ( R25 * R15 ) )))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R14 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R21 being  covariant (Functor of R13 , R14);
let R25 being (transformation of R18 , R19);
L232: ( ( R21 * R19 ) * R15 ) = ( R21 * ( R19 * R15 ) ) by FUNCTOR0:32;
reconsider D36 = ( R21 * ( R25 * R15 ) ) as (transformation of ( ( R21 * R18 ) * R15 ) , ( ( R21 * R19 ) * R15 )) by L232 , FUNCTOR0:32;
assume L233: R18 is_transformable_to R19;
L234:
now
let C139 being (object of R11);
L235: (( ( R18 * R15 ) . C139 ) = ( R18 . ( R15 . C139 ) ) & ( ( R19 * R15 ) . C139 ) = ( R19 . ( R15 . C139 ) )) by FUNCTOR0:33;
thus L236: ( ( ( R21 * R25 ) * R15 ) ! C139 ) = ( ( R21 * R25 ) ! ( R15 . C139 ) ) by L233 , L149 , L199
.= ( R21 . ( R25 ! ( R15 . C139 ) ) ) by L233 , L176
.= ( R21 . ( ( R25 * R15 ) ! C139 ) ) by L233 , L235 , L199
.= ( ( R21 * ( R25 * R15 ) ) ! C139 ) by L233 , L149 , L176
.= ( D36 ! C139 ) by L232 , FUNCTOR0:32;
end;
L237: ( R21 * R18 ) is_transformable_to ( R21 * R19 ) by L233 , L149;
thus L238: thesis by L237 , L234 , L149 , FUNCTOR2:3;
end;
theorem
L239: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R14 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R21 being  covariant (Functor of R13 , R14) holds (for R23 being (transformation of R15 , R16) holds (R15 is_transformable_to R16 implies ( ( R21 * R18 ) * R23 ) = ( R21 * ( R18 * R23 ) )))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R14 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R21 being  covariant (Functor of R13 , R14);
let R23 being (transformation of R15 , R16);
L240: ( ( R21 * R18 ) * R16 ) = ( R21 * ( R18 * R16 ) ) by FUNCTOR0:32;
reconsider D37 = ( R21 * ( R18 * R23 ) ) as (transformation of ( ( R21 * R18 ) * R15 ) , ( ( R21 * R18 ) * R16 )) by L240 , FUNCTOR0:32;
assume L241: R15 is_transformable_to R16;
L242:
now
let C140 being (object of R11);
L243: (( ( R18 * R15 ) . C140 ) = ( R18 . ( R15 . C140 ) ) & ( ( R18 * R16 ) . C140 ) = ( R18 . ( R16 . C140 ) )) by FUNCTOR0:33;
L244: <^ ( R15 . C140 ) , ( R16 . C140 ) ^> <> ( {} ) by L241 , FUNCTOR2:def 1;
thus L245: ( ( ( R21 * R18 ) * R23 ) ! C140 ) = ( ( R21 * R18 ) . ( R23 ! C140 ) ) by L241 , L176
.= ( R21 . ( R18 . ( R23 ! C140 ) ) ) by L244 , L73
.= ( R21 . ( ( R18 * R23 ) ! C140 ) ) by L241 , L243 , L176
.= ( ( R21 * ( R18 * R23 ) ) ! C140 ) by L241 , L149 , L176
.= ( D37 ! C140 ) by L240 , FUNCTOR0:32;
end;
thus L246: thesis by L242 , L241 , L149 , FUNCTOR2:3;
end;
theorem
L247: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds ( ( idt R18 ) * R15 ) = ( idt ( R18 * R15 ) ))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
L248:
now
let C141 being (object of R11);
thus L249: ( ( ( idt R18 ) * R15 ) ! C141 ) = ( ( idt R18 ) ! ( R15 . C141 ) ) by L199
.= ( idm ( R18 . ( R15 . C141 ) ) ) by FUNCTOR2:4
.= ( idm ( ( R18 * R15 ) . C141 ) ) by FUNCTOR0:33
.= ( ( idt ( R18 * R15 ) ) ! C141 ) by FUNCTOR2:4;
end;
thus L250: thesis by L248 , FUNCTOR2:3;
end;
theorem
L251: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds ( R18 * ( idt R15 ) ) = ( idt ( R18 * R15 ) ))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
L252:
now
let C142 being (object of R11);
thus L253: ( ( R18 * ( idt R15 ) ) ! C142 ) = ( R18 . ( ( idt R15 ) ! C142 ) ) by L176
.= ( R18 . ( idm ( R15 . C142 ) ) ) by FUNCTOR2:4
.= ( idm ( R18 . ( R15 . C142 ) ) ) by FUNCTOR2:1
.= ( idm ( ( R18 * R15 ) . C142 ) ) by FUNCTOR0:33
.= ( ( idt ( R18 * R15 ) ) ! C142 ) by FUNCTOR2:4;
end;
thus L254: thesis by L252 , FUNCTOR2:3;
end;
theorem
L255: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R23 being (transformation of R15 , R16) holds (R15 is_transformable_to R16 implies ( ( id R12 ) * R23 ) = R23))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R23 being (transformation of R15 , R16);
assume L256: R15 is_transformable_to R16;
L257:
now
let C143 being set;
assume L258: C143 in (the carrier of R11);
reconsider D38 = C143 as (object of R11) by L258;
L259: <^ ( R15 . D38 ) , ( R16 . D38 ) ^> <> ( {} ) by L256 , FUNCTOR2:def 1;
thus L260: ( ( ( id R12 ) * R23 ) . C143 ) = ( ( id R12 ) . ( R23 ! D38 ) ) by L256 , L158
.= ( R23 ! D38 ) by L259 , FUNCTOR0:31
.= ( R23 . C143 ) by L256 , FUNCTOR2:def 4;
end;
thus L261: thesis by L257 , PBOOLE:3;
end;
theorem
L262: (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R25 being (transformation of R18 , R19) holds (R18 is_transformable_to R19 implies ( R25 * ( id R12 ) ) = R25))))))
proof
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R25 being (transformation of R18 , R19);
assume L263: R18 is_transformable_to R19;
L264:
now
let C144 being set;
assume L265: C144 in (the carrier of R12);
reconsider D39 = C144 as (object of R12) by L265;
thus L266: ( ( R25 * ( id R12 ) ) . C144 ) = ( R25 ! ( ( id R12 ) . D39 ) ) by L263 , L181
.= ( R25 ! D39 ) by FUNCTOR0:29
.= ( R25 . C144 ) by L263 , FUNCTOR2:def 4;
end;
thus L267: thesis by L264 , PBOOLE:3;
end;
begin
definition
let C145 , C146 , C147 being  transitive  with_units non  empty AltCatStr;
let C148 , C149 being  covariant (Functor of C145 , C146);
let C150 , C151 being  covariant (Functor of C146 , C147);
let C152 being (transformation of C148 , C149);
let C153 being (transformation of C150 , C151);
func C153 (#) C152 -> (transformation of ( C150 * C148 ) , ( C151 * C149 )) equals 
( ( C153 * C149 ) `*` ( C150 * C152 ) );
coherence;
end;
theorem
L269: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R23 being (transformation of R15 , R16) holds (for B54 being (natural_transformation of R18 , R19) holds ((R15 is_transformable_to R16 & R18 is_naturally_transformable_to R19) implies ( B54 (#) R23 ) = ( ( R19 * R23 ) `*` ( B54 * R15 ) )))))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R23 being (transformation of R15 , R16);
let C154 being (natural_transformation of R18 , R19);
assume that
L270: R15 is_transformable_to R16
and
L271: R18 is_naturally_transformable_to R19;
L272: ( R18 * R15 ) is_transformable_to ( R18 * R16 ) by L270 , L149;
L273: ( R19 * R15 ) is_transformable_to ( R19 * R16 ) by L270 , L149;
L274: R18 is_transformable_to R19 by L271 , FUNCTOR2:def 6;
L275: ( R18 * R15 ) is_transformable_to ( R19 * R15 ) by L274 , L149;
L276: ( R18 * R16 ) is_transformable_to ( R19 * R16 ) by L274 , L149;
L277:
now
let C155 being (object of R11);
L278: ( R18 . ( R15 . C155 ) ) = ( ( R18 * R15 ) . C155 ) by FUNCTOR0:33;
L279: ( R19 . ( R16 . C155 ) ) = ( ( R19 * R16 ) . C155 ) by FUNCTOR0:33;
reconsider D40 = ( C154 ! ( R16 . C155 ) ) as (Morphism of ( ( R18 * R16 ) . C155 ) , ( ( R19 * R16 ) . C155 )) by L279 , FUNCTOR0:33;
reconsider D41 = ( ( R19 * R23 ) ! C155 ) as (Morphism of ( R19 . ( R15 . C155 ) ) , ( R19 . ( R16 . C155 ) )) by L279 , FUNCTOR0:33;
L280: ( R18 . ( R16 . C155 ) ) = ( ( R18 * R16 ) . C155 ) by FUNCTOR0:33;
L281: <^ ( R15 . C155 ) , ( R16 . C155 ) ^> <> ( {} ) by L270 , FUNCTOR2:def 1;
L282: ( R19 . ( R15 . C155 ) ) = ( ( R19 * R15 ) . C155 ) by FUNCTOR0:33;
thus L283: ( ( ( C154 * R16 ) `*` ( R18 * R23 ) ) ! C155 ) = ( ( ( C154 * R16 ) ! C155 ) * ( ( R18 * R23 ) ! C155 ) ) by L276 , L272 , FUNCTOR2:def 5
.= ( D40 * ( ( R18 * R23 ) ! C155 ) ) by L274 , L199
.= ( ( C154 ! ( R16 . C155 ) ) * ( R18 . ( R23 ! C155 ) ) ) by L270 , L278 , L280 , L279 , L176
.= ( ( R19 . ( R23 ! C155 ) ) * ( C154 ! ( R15 . C155 ) ) ) by L271 , L281 , FUNCTOR2:def 7
.= ( D41 * ( C154 ! ( R15 . C155 ) ) ) by L270 , L176
.= ( ( ( R19 * R23 ) ! C155 ) * ( ( C154 * R15 ) ! C155 ) ) by L274 , L278 , L282 , L279 , L199
.= ( ( ( R19 * R23 ) `*` ( C154 * R15 ) ) ! C155 ) by L275 , L273 , FUNCTOR2:def 5;
end;
thus L284: thesis by L277 , L270 , L274 , L149 , FUNCTOR2:3;
end;
theorem
L285: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R23 being (transformation of R15 , R16) holds (R15 is_transformable_to R16 implies ( ( idt ( id R12 ) ) (#) R23 ) = R23))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R23 being (transformation of R15 , R16);
assume L286: R15 is_transformable_to R16;
L287: ( ( id R12 ) * R15 ) is_transformable_to ( ( id R12 ) * R16 ) by L286 , L149;
thus L288: ( ( idt ( id R12 ) ) (#) R23 ) = ( ( idt ( ( id R12 ) * R16 ) ) `*` ( ( id R12 ) * R23 ) ) by L247
.= ( ( id R12 ) * R23 ) by L287 , FUNCTOR2:5
.= R23 by L286 , L255;
end;
theorem
L289: (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R25 being (transformation of R18 , R19) holds (R18 is_transformable_to R19 implies ( R25 (#) ( idt ( id R12 ) ) ) = R25))))))
proof
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R25 being (transformation of R18 , R19);
assume L290: R18 is_transformable_to R19;
L291: ( R18 * ( id R12 ) ) is_transformable_to ( R19 * ( id R12 ) ) by L290 , L149;
thus L292: ( R25 (#) ( idt ( id R12 ) ) ) = ( ( R25 * ( id R12 ) ) `*` ( idt ( R18 * ( id R12 ) ) ) ) by L251
.= ( R25 * ( id R12 ) ) by L291 , FUNCTOR2:5
.= R25 by L290 , L262;
end;
theorem
L293: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R16 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R23 being (transformation of R15 , R16) holds (R15 is_transformable_to R16 implies ( R18 * R23 ) = ( ( idt R18 ) (#) R23 )))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R16 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R23 being (transformation of R15 , R16);
assume L294: R15 is_transformable_to R16;
L295: ( R18 * R15 ) is_transformable_to ( R18 * R16 ) by L294 , L149;
thus L296: ( R18 * R23 ) = ( ( idt ( R18 * R16 ) ) `*` ( R18 * R23 ) ) by L295 , FUNCTOR2:5
.= ( ( idt R18 ) (#) R23 ) by L247;
end;
theorem
L297: (for R11 being  transitive  with_units non  empty AltCatStr holds (for R12 being  transitive  with_units non  empty AltCatStr holds (for R13 being  transitive  with_units non  empty AltCatStr holds (for R15 being  covariant (Functor of R11 , R12) holds (for R18 being  covariant (Functor of R12 , R13) holds (for R19 being  covariant (Functor of R12 , R13) holds (for R25 being (transformation of R18 , R19) holds (R18 is_transformable_to R19 implies ( R25 * R15 ) = ( R25 (#) ( idt R15 ) )))))))))
proof
let R11 being  transitive  with_units non  empty AltCatStr;
let R12 being  transitive  with_units non  empty AltCatStr;
let R13 being  transitive  with_units non  empty AltCatStr;
let R15 being  covariant (Functor of R11 , R12);
let R18 being  covariant (Functor of R12 , R13);
let R19 being  covariant (Functor of R12 , R13);
let R25 being (transformation of R18 , R19);
assume L298: R18 is_transformable_to R19;
L299: ( R18 * R15 ) is_transformable_to ( R19 * R15 ) by L298 , L149;
thus L300: ( R25 * R15 ) = ( ( R25 * R15 ) `*` ( idt ( R18 * R15 ) ) ) by L299 , FUNCTOR2:5
.= ( R25 (#) ( idt R15 ) ) by L251;
end;
theorem
L301: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R31 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R36 being  covariant (Functor of R29 , R30) holds (for B55 , B56 being  covariant (Functor of R30 , R31) holds (for B57 being (transformation of R32 , R33) holds (for B58 being (transformation of R35 , R36) holds (for B59 being (transformation of B55 , B56) holds ((R32 is_transformable_to R33 & R35 is_transformable_to R36 & B55 is_transformable_to B56) implies ( ( B59 (#) B58 ) (#) B57 ) = ( B59 (#) ( B58 (#) B57 ) ))))))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R31 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R36 being  covariant (Functor of R29 , R30);
let C156 , C157 being  covariant (Functor of R30 , R31);
let C158 being (transformation of R32 , R33);
let C159 being (transformation of R35 , R36);
let C160 being (transformation of C156 , C157);
assume that
L302: R32 is_transformable_to R33
and
L303: R35 is_transformable_to R36
and
L304: C156 is_transformable_to C157;
L305: (( R35 * R33 ) is_transformable_to ( R36 * R33 ) & ( R35 * R32 ) is_transformable_to ( R35 * R33 )) by L302 , L303 , L149;
L306: (( ( C156 * C159 ) * R33 ) = ( C156 * ( C159 * R33 ) ) & ( ( C156 * R35 ) * C158 ) = ( C156 * ( R35 * C158 ) )) by L302 , L303 , L231 , L239;
L307: (( ( C156 * R36 ) * R33 ) = ( C156 * ( R36 * R33 ) ) & ( ( C157 * R36 ) * R33 ) = ( C157 * ( R36 * R33 ) )) by FUNCTOR0:32;
L308: (( ( C156 * R35 ) * R32 ) is_transformable_to ( ( C156 * R35 ) * R33 ) & ( ( C160 * R36 ) * R33 ) = ( C160 * ( R36 * R33 ) )) by L302 , L304 , L149 , L224;
L309: (( ( C156 * R35 ) * R32 ) = ( C156 * ( R35 * R32 ) ) & ( ( C156 * R35 ) * R33 ) = ( C156 * ( R35 * R33 ) )) by FUNCTOR0:32;
L310: ( C156 * R35 ) is_transformable_to ( C156 * R36 ) by L303 , L149;
L311: ( ( C156 * R35 ) * R33 ) is_transformable_to ( ( C156 * R36 ) * R33 ) by L310 , L149;
L312: ( C156 * R36 ) is_transformable_to ( C157 * R36 ) by L304 , L149;
L313: ( ( C156 * R36 ) * R33 ) is_transformable_to ( ( C157 * R36 ) * R33 ) by L312 , L149;
thus L314: ( ( C160 (#) C159 ) (#) C158 ) = ( ( ( ( C160 * R36 ) * R33 ) `*` ( ( C156 * C159 ) * R33 ) ) `*` ( ( C156 * R35 ) * C158 ) ) by L312 , L310 , L214
.= ( ( C160 * ( R36 * R33 ) ) `*` ( ( C156 * ( C159 * R33 ) ) `*` ( C156 * ( R35 * C158 ) ) ) ) by L313 , L311 , L308 , L306 , L309 , L307 , FUNCTOR2:6
.= ( C160 (#) ( C159 (#) C158 ) ) by L305 , L203;
end;
L315:
now
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R36 being  covariant (Functor of R29 , R30);
let R39 being (natural_transformation of R35 , R36);
let R38 being (natural_transformation of R32 , R33);
set D42 = ( R39 (#) R38 );
assume L316: R32 is_naturally_transformable_to R33;
L317: R32 is_transformable_to R33 by L316 , FUNCTOR2:def 6;
assume L318: R35 is_naturally_transformable_to R36;
L319: R35 is_transformable_to R36 by L318 , FUNCTOR2:def 6;
L320:
now
let C161 , C162 being (object of R28);
assume that
L321: <^ C161 , C162 ^> <> ( {} );
L322: <^ ( ( R35 * R32 ) . C161 ) , ( ( R35 * R32 ) . C162 ) ^> <> ( {} ) by L321 , FUNCTOR0:def 18;
L323: ( ( R36 * R33 ) . C161 ) = ( R36 . ( R33 . C161 ) ) by FUNCTOR0:33;
reconsider D43 = ( R39 ! ( R33 . C161 ) ) as (Morphism of ( ( R35 * R33 ) . C161 ) , ( ( R36 * R33 ) . C161 )) by L323 , FUNCTOR0:33;
L324: ( ( R36 * R33 ) . C162 ) = ( R36 . ( R33 . C162 ) ) by FUNCTOR0:33;
reconsider D44 = ( R39 ! ( R33 . C162 ) ) as (Morphism of ( ( R35 * R33 ) . C162 ) , ( ( R36 * R33 ) . C162 )) by L324 , FUNCTOR0:33;
L325: <^ ( R35 . ( R33 . C162 ) ) , ( R36 . ( R33 . C162 ) ) ^> <> ( {} ) by L319 , FUNCTOR2:def 1;
L326: <^ ( ( R35 * R33 ) . C162 ) , ( ( R36 * R33 ) . C162 ) ^> <> ( {} ) by L325 , L324 , FUNCTOR0:33;
let C163 being (Morphism of C161 , C162);
L327: ( ( R35 * R32 ) . C161 ) = ( R35 . ( R32 . C161 ) ) by FUNCTOR0:33;
reconsider D45 = ( R35 . ( ( R38 ! C162 ) * ( R32 . C163 ) ) ) as (Morphism of ( ( R35 * R32 ) . C161 ) , ( ( R35 * R33 ) . C162 )) by L327 , FUNCTOR0:33;
reconsider D46 = ( R35 . ( R38 ! C161 ) ) as (Morphism of ( ( R35 * R32 ) . C161 ) , ( ( R35 * R33 ) . C161 )) by L327 , FUNCTOR0:33;
L328: <^ ( R35 . ( R32 . C161 ) ) , ( R36 . ( R32 . C161 ) ) ^> <> ( {} ) by L319 , FUNCTOR2:def 1;
L329: ( ( R35 * R32 ) . C162 ) = ( R35 . ( R32 . C162 ) ) by FUNCTOR0:33;
reconsider D47 = ( R35 . ( R38 ! C162 ) ) as (Morphism of ( ( R35 * R32 ) . C162 ) , ( ( R35 * R33 ) . C162 )) by L329 , FUNCTOR0:33;
L330: <^ ( R32 . C162 ) , ( R33 . C162 ) ^> <> ( {} ) by L317 , FUNCTOR2:def 1;
L331: <^ ( R35 . ( R32 . C162 ) ) , ( R35 . ( R33 . C162 ) ) ^> <> ( {} ) by L330 , FUNCTOR0:def 18;
L332: <^ ( ( R35 * R32 ) . C162 ) , ( ( R35 * R33 ) . C162 ) ^> <> ( {} ) by L331 , L329 , FUNCTOR0:33;
L333: <^ ( R32 . C161 ) , ( R32 . C162 ) ^> <> ( {} ) by L321 , FUNCTOR0:def 18;
L334: <^ ( R32 . C161 ) , ( R33 . C162 ) ^> <> ( {} ) by L333 , L330 , ALTCAT_1:def 2;
reconsider D48 = ( R35 . ( R32 . C163 ) ) as (Morphism of ( ( R35 * R32 ) . C161 ) , ( ( R35 * R32 ) . C162 )) by L329 , FUNCTOR0:33;
L335: ( R39 ! ( R33 . C161 ) ) = ( ( R39 * R33 ) . C161 ) by L319 , L181;
L336: ( R35 . ( ( R38 ! C162 ) * ( R32 . C163 ) ) ) = ( ( R35 . ( R38 ! C162 ) ) * ( R35 . ( R32 . C163 ) ) ) by L330 , L333 , FUNCTOR0:def 23
.= ( D47 * D48 ) by L327 , L329 , FUNCTOR0:33;
reconsider D49 = ( R36 . ( R33 . C163 ) ) as (Morphism of ( ( R36 * R33 ) . C161 ) , ( ( R36 * R33 ) . C162 )) by L323 , FUNCTOR0:33;
L337: ( R39 ! ( R33 . C162 ) ) = ( ( R39 * R33 ) . C162 ) by L319 , L181;
L338: ( R35 * R33 ) is_transformable_to ( R36 * R33 ) by L319 , L149;
L339: <^ ( R33 . C161 ) , ( R33 . C162 ) ^> <> ( {} ) by L321 , FUNCTOR0:def 18;
L340: <^ ( R36 . ( R33 . C161 ) ) , ( R36 . ( R33 . C162 ) ) ^> <> ( {} ) by L339 , FUNCTOR0:def 18;
L341: <^ ( R32 . C161 ) , ( R33 . C161 ) ^> <> ( {} ) by L317 , FUNCTOR2:def 1;
L342: <^ ( R36 . ( R32 . C161 ) ) , ( R36 . ( R33 . C161 ) ) ^> <> ( {} ) by L341 , FUNCTOR0:def 18;
L343: ( R35 * R32 ) is_transformable_to ( R35 * R33 ) by L317 , L149;
thus L344: ( ( D42 ! C162 ) * ( ( R35 * R32 ) . C163 ) ) = ( ( ( ( R39 * R33 ) ! C162 ) * ( ( R35 * R38 ) ! C162 ) ) * ( ( R35 * R32 ) . C163 ) ) by L343 , L338 , FUNCTOR2:def 5
.= ( ( D44 * ( ( R35 * R38 ) ! C162 ) ) * ( ( R35 * R32 ) . C163 ) ) by L338 , L337 , FUNCTOR2:def 4
.= ( ( D44 * D47 ) * ( ( R35 * R32 ) . C163 ) ) by L317 , L176
.= ( ( D44 * D47 ) * D48 ) by L321 , L73
.= ( D44 * D45 ) by L322 , L332 , L326 , L336 , ALTCAT_1:21
.= ( ( R39 ! ( R33 . C162 ) ) * ( R35 . ( ( R38 ! C162 ) * ( R32 . C163 ) ) ) ) by L327 , L324 , FUNCTOR0:33
.= ( ( R36 . ( ( R38 ! C162 ) * ( R32 . C163 ) ) ) * ( R39 ! ( R32 . C161 ) ) ) by L318 , L334 , FUNCTOR2:def 7
.= ( ( R36 . ( ( R33 . C163 ) * ( R38 ! C161 ) ) ) * ( R39 ! ( R32 . C161 ) ) ) by L316 , L321 , FUNCTOR2:def 7
.= ( ( ( R36 . ( R33 . C163 ) ) * ( R36 . ( R38 ! C161 ) ) ) * ( R39 ! ( R32 . C161 ) ) ) by L339 , L341 , FUNCTOR0:def 23
.= ( ( R36 . ( R33 . C163 ) ) * ( ( R36 . ( R38 ! C161 ) ) * ( R39 ! ( R32 . C161 ) ) ) ) by L328 , L342 , L340 , ALTCAT_1:21
.= ( ( R36 . ( R33 . C163 ) ) * ( ( R39 ! ( R33 . C161 ) ) * ( R35 . ( R38 ! C161 ) ) ) ) by L318 , L341 , FUNCTOR2:def 7
.= ( D49 * ( D43 * D46 ) ) by L327 , L323 , L324 , FUNCTOR0:33
.= ( ( ( R36 * R33 ) . C163 ) * ( D43 * D46 ) ) by L321 , L73
.= ( ( ( R36 * R33 ) . C163 ) * ( ( ( R39 * R33 ) ! C161 ) * D46 ) ) by L338 , L335 , FUNCTOR2:def 4
.= ( ( ( R36 * R33 ) . C163 ) * ( ( ( R39 * R33 ) ! C161 ) * ( ( R35 * R38 ) ! C161 ) ) ) by L317 , L176
.= ( ( ( R36 * R33 ) . C163 ) * ( D42 ! C161 ) ) by L338 , L343 , FUNCTOR2:def 5;
end;
thus L345: ( R35 * R32 ) is_naturally_transformable_to ( R36 * R33 )
proof
thus L346: ( R35 * R32 ) is_transformable_to ( R36 * R33 ) by L317 , L319 , L149;
take D42;
thus L347: thesis by L320;
end;

thus L348: ( R39 (#) R38 ) is (natural_transformation of ( R35 * R32 ) , ( R36 * R33 )) by L345 , L320 , FUNCTOR2:def 7;
end;
theorem
L349: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R38 being (natural_transformation of R32 , R33) holds (R32 is_naturally_transformable_to R33 implies ( R35 * R38 ) is (natural_transformation of ( R35 * R32 ) , ( R35 * R33 ))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R38 being (natural_transformation of R32 , R33);
assume L350: R32 is_naturally_transformable_to R33;
L351: R32 is_transformable_to R33 by L350 , FUNCTOR2:def 6;
thus L352: ( R35 * R32 ) is_naturally_transformable_to ( R35 * R33 ) by L350 , L315;
let C164 , C165 being (object of R28);
assume that
L353: <^ C164 , C165 ^> <> ( {} );
L354: (( ( R35 * R32 ) . C165 ) = ( R35 . ( R32 . C165 ) ) & <^ ( R32 . C164 ) , ( R32 . C165 ) ^> <> ( {} )) by L353 , FUNCTOR0:33 , FUNCTOR0:def 18;
L355: <^ ( R32 . C165 ) , ( R33 . C165 ) ^> <> ( {} ) by L351 , FUNCTOR2:def 1;
L356: <^ ( R32 . C164 ) , ( R33 . C164 ) ^> <> ( {} ) by L351 , FUNCTOR2:def 1;
reconsider D50 = ( R35 . ( R38 ! C164 ) ) as (Morphism of ( R35 . ( R32 . C164 ) ) , ( ( R35 * R33 ) . C164 )) by FUNCTOR0:33;
reconsider D51 = ( R35 . ( R38 ! C165 ) ) as (Morphism of ( ( R35 * R32 ) . C165 ) , ( R35 . ( R33 . C165 ) )) by FUNCTOR0:33;
let C166 being (Morphism of C164 , C165);
L357: ( ( R35 * R33 ) . C164 ) = ( R35 . ( R33 . C164 ) ) by FUNCTOR0:33;
L358: <^ ( R33 . C164 ) , ( R33 . C165 ) ^> <> ( {} ) by L353 , FUNCTOR0:def 18;
L359: ( ( R35 * R32 ) . C164 ) = ( R35 . ( R32 . C164 ) ) by FUNCTOR0:33;
reconsider D52 = ( R35 . ( R32 . C166 ) ) as (Morphism of ( ( R35 * R32 ) . C164 ) , ( ( R35 * R32 ) . C165 )) by L359 , FUNCTOR0:33;
L360: ( ( R35 * R33 ) . C165 ) = ( R35 . ( R33 . C165 ) ) by FUNCTOR0:33;
thus L361: ( ( ( R35 * R38 ) ! C165 ) * ( ( R35 * R32 ) . C166 ) ) = ( D51 * ( ( R35 * R32 ) . C166 ) ) by L360 , L351 , L176
.= ( D51 * D52 ) by L353 , L73
.= ( R35 . ( ( R38 ! C165 ) * ( R32 . C166 ) ) ) by L359 , L354 , L355 , FUNCTOR0:def 23
.= ( R35 . ( ( R33 . C166 ) * ( R38 ! C164 ) ) ) by L350 , L353 , FUNCTOR2:def 7
.= ( ( R35 . ( R33 . C166 ) ) * ( R35 . ( R38 ! C164 ) ) ) by L356 , L358 , FUNCTOR0:def 23
.= ( ( ( R35 * R33 ) . C166 ) * D50 ) by L353 , L357 , L360 , L73
.= ( ( ( R35 * R33 ) . C166 ) * ( ( R35 * R38 ) ! C164 ) ) by L351 , L359 , L176;
end;
theorem
L362: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R36 being  covariant (Functor of R29 , R30) holds (for R39 being (natural_transformation of R35 , R36) holds (R35 is_naturally_transformable_to R36 implies ( R39 * R32 ) is (natural_transformation of ( R35 * R32 ) , ( R36 * R32 ))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R36 being  covariant (Functor of R29 , R30);
let R39 being (natural_transformation of R35 , R36);
assume L363: R35 is_naturally_transformable_to R36;
thus L364: ( R35 * R32 ) is_naturally_transformable_to ( R36 * R32 ) by L363 , L315;
let C167 , C168 being (object of R28);
assume that
L365: <^ C167 , C168 ^> <> ( {} );
L366: <^ ( R32 . C167 ) , ( R32 . C168 ) ^> <> ( {} ) by L365 , FUNCTOR0:def 18;
reconsider D53 = ( R39 ! ( R32 . C167 ) ) as (Morphism of ( R35 . ( R32 . C167 ) ) , ( ( R36 * R32 ) . C167 )) by FUNCTOR0:33;
let C169 being (Morphism of C167 , C168);
L367: ( ( R36 * R32 ) . C167 ) = ( R36 . ( R32 . C167 ) ) by FUNCTOR0:33;
L368: ( ( R36 * R32 ) . C168 ) = ( R36 . ( R32 . C168 ) ) by FUNCTOR0:33;
reconsider D54 = ( R39 ! ( R32 . C168 ) ) as (Morphism of ( ( R35 * R32 ) . C168 ) , ( ( R36 * R32 ) . C168 )) by L368 , FUNCTOR0:33;
L369: (( ( R35 * R32 ) . C168 ) = ( R35 . ( R32 . C168 ) ) & ( ( R36 * R32 ) . C168 ) = ( R36 . ( R32 . C168 ) )) by FUNCTOR0:33;
L370: ( ( R35 * R32 ) . C167 ) = ( R35 . ( R32 . C167 ) ) by FUNCTOR0:33;
reconsider D55 = ( R35 . ( R32 . C169 ) ) as (Morphism of ( ( R35 * R32 ) . C167 ) , ( ( R35 * R32 ) . C168 )) by L370 , FUNCTOR0:33;
L371: R35 is_transformable_to R36 by L363 , FUNCTOR2:def 6;
thus L372: ( ( ( R39 * R32 ) ! C168 ) * ( ( R35 * R32 ) . C169 ) ) = ( D54 * ( ( R35 * R32 ) . C169 ) ) by L371 , L199
.= ( D54 * D55 ) by L365 , L73
.= ( ( R36 . ( R32 . C169 ) ) * ( R39 ! ( R32 . C167 ) ) ) by L363 , L370 , L369 , L366 , FUNCTOR2:def 7
.= ( ( ( R36 * R32 ) . C169 ) * D53 ) by L365 , L367 , L368 , L73
.= ( ( ( R36 * R32 ) . C169 ) * ( ( R39 * R32 ) ! C167 ) ) by L371 , L370 , L199;
end;
theorem
L373: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R36 being  covariant (Functor of R29 , R30) holds (for R38 being (natural_transformation of R32 , R33) holds (for R39 being (natural_transformation of R35 , R36) holds ((R32 is_naturally_transformable_to R33 & R35 is_naturally_transformable_to R36) implies (( R35 * R32 ) is_naturally_transformable_to ( R36 * R33 ) & ( R39 (#) R38 ) is (natural_transformation of ( R35 * R32 ) , ( R36 * R33 ))))))))))))) by L315;
theorem
L374: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R34 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R36 being  covariant (Functor of R29 , R30) holds (for R37 being  covariant (Functor of R29 , R30) holds (for R39 being (natural_transformation of R35 , R36) holds (for R40 being (natural_transformation of R36 , R37) holds (for B60 being (transformation of R32 , R33) holds (for B61 being (transformation of R33 , R34) holds ((R32 is_naturally_transformable_to R33 & R33 is_naturally_transformable_to R34 & R35 is_naturally_transformable_to R36 & R36 is_naturally_transformable_to R37) implies ( ( R40 `*` R39 ) (#) ( B61 `*` B60 ) ) = ( ( R40 (#) B61 ) `*` ( R39 (#) B60 ) )))))))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R34 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R36 being  covariant (Functor of R29 , R30);
let R37 being  covariant (Functor of R29 , R30);
let R39 being (natural_transformation of R35 , R36);
let R40 being (natural_transformation of R36 , R37);
let C170 being (transformation of R32 , R33);
let C171 being (transformation of R33 , R34);
assume that
L375: R32 is_naturally_transformable_to R33
and
L376: R33 is_naturally_transformable_to R34
and
L377: R35 is_naturally_transformable_to R36
and
L378: R36 is_naturally_transformable_to R37;
L379: R32 is_transformable_to R33 by L375 , FUNCTOR2:def 6;
L380: ( R39 (#) C170 ) = ( ( R36 * C170 ) `*` ( R39 * R32 ) ) by L379 , L377 , L269;
L381: ( R36 * R32 ) is_transformable_to ( R36 * R33 ) by L379 , L149;
L382: ( R37 * R32 ) is_transformable_to ( R37 * R33 ) by L379 , L149;
L383: ( R35 * R32 ) is_naturally_transformable_to ( R36 * R33 ) by L375 , L377 , L315;
L384: ( R35 * R32 ) is_transformable_to ( R36 * R33 ) by L383 , FUNCTOR2:def 6;
L385: R35 is_transformable_to R36 by L377 , FUNCTOR2:def 6;
L386: ( R35 * R32 ) is_transformable_to ( R36 * R32 ) by L385 , L149;
L387: R33 is_transformable_to R34 by L376 , FUNCTOR2:def 6;
L388: ( R40 (#) C171 ) = ( ( R37 * C171 ) `*` ( R40 * R33 ) ) by L387 , L378 , L269;
L389: ( R37 * R33 ) is_transformable_to ( R37 * R34 ) by L387 , L149;
L390: R36 is_transformable_to R37 by L378 , FUNCTOR2:def 6;
L391: ( R36 * R32 ) is_transformable_to ( R37 * R32 ) by L390 , L149;
L392: R35 is_transformable_to R37 by L385 , L390 , FUNCTOR2:2;
L393: ( R35 * R32 ) is_transformable_to ( R37 * R32 ) by L392 , L149;
L394: ( R36 * R33 ) is_transformable_to ( R37 * R33 ) by L390 , L149;
L395: R32 is_transformable_to R34 by L379 , L387 , FUNCTOR2:2;
thus L396: ( ( R40 `*` R39 ) (#) ( C171 `*` C170 ) ) = ( ( R37 * ( C171 `*` C170 ) ) `*` ( ( R40 `*` R39 ) * R32 ) ) by L395 , L377 , L378 , L269 , FUNCTOR2:8
.= ( ( ( R37 * C171 ) `*` ( R37 * C170 ) ) `*` ( ( R40 `*` R39 ) * R32 ) ) by L379 , L387 , L203
.= ( ( ( R37 * C171 ) `*` ( R37 * C170 ) ) `*` ( ( (R40 qua (transformation of R36 , R37)) `*` R39 ) * R32 ) ) by L377 , L378 , FUNCTOR2:def 8
.= ( ( ( R37 * C171 ) `*` ( R37 * C170 ) ) `*` ( ( R40 * R32 ) `*` ( R39 * R32 ) ) ) by L385 , L390 , L214
.= ( ( R37 * C171 ) `*` ( ( R37 * C170 ) `*` ( ( R40 * R32 ) `*` ( R39 * R32 ) ) ) ) by L389 , L382 , L393 , FUNCTOR2:6
.= ( ( R37 * C171 ) `*` ( ( ( R37 * C170 ) `*` ( R40 * R32 ) ) `*` ( R39 * R32 ) ) ) by L382 , L386 , L391 , FUNCTOR2:6
.= ( ( R37 * C171 ) `*` ( ( R40 (#) C170 ) `*` ( R39 * R32 ) ) ) by L378 , L379 , L269
.= ( ( R37 * C171 ) `*` ( ( R40 * R33 ) `*` ( ( R36 * C170 ) `*` ( R39 * R32 ) ) ) ) by L386 , L394 , L381 , FUNCTOR2:6
.= ( ( R40 (#) C171 ) `*` ( R39 (#) C170 ) ) by L389 , L394 , L384 , L388 , L380 , FUNCTOR2:6;
end;
begin
theorem
L397: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R38 being (natural_transformation of R32 , R33) holds ((R32 is_naturally_transformable_to R33 & R33 is_transformable_to R32 & (for B62 being (object of R28) holds ( R38 ! B62 ) is  iso)) implies (R33 is_naturally_transformable_to R32 & (ex B63 being (natural_transformation of R33 , R32) st (for B64 being (object of R28) holds (( B63 . B64 ) = ( ( R38 ! B64 ) " ) & ( B63 ! B64 ) is  iso))))))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R38 being (natural_transformation of R32 , R33);
assume that
L398: R32 is_naturally_transformable_to R33
and
L399: R33 is_transformable_to R32
and
L400: (for B65 being (object of R28) holds ( R38 ! B65 ) is  iso);
defpred S3[ set , set ] means (ex B66 being (object of R28) st (B66 = $1 & $2 = ( ( R38 ! B66 ) " )));
set D56 = (the carrier of R28);
L401: (for B67 being set holds (B67 in D56 implies (ex B68 being set st S3[ B67 , B68 ])))
proof
let C172 being set;
assume L402: C172 in D56;
reconsider D57 = C172 as (object of R28) by L402;
take ( ( R38 ! D57 ) " );
thus L403: thesis;
end;
consider C173 being (ManySortedSet of D56) such that L404: (for B69 being set holds (B69 in D56 implies S3[ B69 , ( C173 . B69 ) ])) from PBOOLE:sch 3(L401);
L405: C173 is (transformation of R33 , R32)
proof
thus L406: R33 is_transformable_to R32 by L399;
let C174 being (object of R28);
L407: (ex B70 being (object of R28) st (B70 = C174 & ( C173 . C174 ) = ( ( R38 ! B70 ) " ))) by L404;
thus L408: thesis by L407;
end;
reconsider D58 = C173 as (transformation of R33 , R32) by L405;
L409: R32 is_transformable_to R33 by L398 , FUNCTOR2:def 6;
L410:
now
let C175 , C176 being (object of R28);
assume that
L411: <^ C175 , C176 ^> <> ( {} );
L412: <^ ( R32 . C175 ) , ( R32 . C176 ) ^> <> ( {} ) by L411 , FUNCTOR0:def 18;
let C177 being (Morphism of C175 , C176);
L413: (ex B71 being (object of R28) st (B71 = C176 & ( D58 . C176 ) = ( ( R38 ! B71 ) " ))) by L404;
L414: ( R38 ! C176 ) is  iso by L400;
L415: <^ ( R33 . C175 ) , ( R32 . C175 ) ^> <> ( {} ) by L399 , FUNCTOR2:def 1;
L416: <^ ( R32 . C175 ) , ( R33 . C175 ) ^> <> ( {} ) by L409 , FUNCTOR2:def 1;
L417: (ex B72 being (object of R28) st (B72 = C175 & ( D58 . C175 ) = ( ( R38 ! B72 ) " ))) by L404;
reconsider D59 = ( D58 . C175 ) as (Morphism of ( R33 . C175 ) , ( R32 . C175 )) by L417;
L418: ( R38 ! C175 ) is  iso by L400;
L419: <^ ( R32 . C176 ) , ( R33 . C176 ) ^> <> ( {} ) by L409 , FUNCTOR2:def 1;
L420: <^ ( R33 . C176 ) , ( R32 . C176 ) ^> <> ( {} ) by L399 , FUNCTOR2:def 1;
L421: <^ ( R33 . C175 ) , ( R33 . C176 ) ^> <> ( {} ) by L411 , FUNCTOR0:def 18;
L422: <^ ( R33 . C175 ) , ( R32 . C176 ) ^> <> ( {} ) by L421 , L420 , ALTCAT_1:def 2;
thus L423: ( ( D58 ! C176 ) * ( R33 . C177 ) ) = ( ( ( D58 ! C176 ) * ( R33 . C177 ) ) * ( idm ( R33 . C175 ) ) ) by L422 , ALTCAT_1:def 17
.= ( ( ( D58 ! C176 ) * ( R33 . C177 ) ) * ( ( R38 ! C175 ) * D59 ) ) by L417 , L418 , ALTCAT_3:def 5
.= ( ( ( D58 ! C176 ) * ( R33 . C177 ) ) * ( ( R38 ! C175 ) * ( D58 ! C175 ) ) ) by L399 , FUNCTOR2:def 4
.= ( ( ( ( D58 ! C176 ) * ( R33 . C177 ) ) * ( R38 ! C175 ) ) * ( D58 ! C175 ) ) by L416 , L415 , L422 , ALTCAT_1:21
.= ( ( ( D58 ! C176 ) * ( ( R33 . C177 ) * ( R38 ! C175 ) ) ) * ( D58 ! C175 ) ) by L416 , L420 , L421 , ALTCAT_1:21
.= ( ( ( D58 ! C176 ) * ( ( R38 ! C176 ) * ( R32 . C177 ) ) ) * ( D58 ! C175 ) ) by L398 , L411 , FUNCTOR2:def 7
.= ( ( ( ( D58 ! C176 ) * ( R38 ! C176 ) ) * ( R32 . C177 ) ) * ( D58 ! C175 ) ) by L420 , L419 , L412 , ALTCAT_1:21
.= ( ( ( ( ( R38 ! C176 ) " ) * ( R38 ! C176 ) ) * ( R32 . C177 ) ) * ( D58 ! C175 ) ) by L399 , L413 , FUNCTOR2:def 4
.= ( ( ( idm ( R32 . C176 ) ) * ( R32 . C177 ) ) * ( D58 ! C175 ) ) by L414 , ALTCAT_3:def 5
.= ( ( R32 . C177 ) * ( D58 ! C175 ) ) by L412 , ALTCAT_1:20;
end;
thus L424: R33 is_naturally_transformable_to R32 by L410 , L399 , FUNCTOR2:def 6;
L425: R33 is_naturally_transformable_to R32 by L399 , L410 , FUNCTOR2:def 6;
reconsider D60 = D58 as (natural_transformation of R33 , R32) by L425 , L410 , FUNCTOR2:def 7;
take D60;
let C178 being (object of R28);
consider C179 being (object of R28) such that L426: C179 = C178 and L427: ( D60 . C178 ) = ( ( R38 ! C179 ) " ) by L404;
thus L428: ( D60 . C178 ) = ( ( R38 ! C178 ) " ) by L426 , L427;
L429: <^ ( R32 . C178 ) , ( R33 . C178 ) ^> <> ( {} ) by L409 , FUNCTOR2:def 1;
L430: <^ ( R33 . C178 ) , ( R32 . C178 ) ^> <> ( {} ) by L399 , FUNCTOR2:def 1;
L431: ( D60 ! C178 ) = ( ( R38 ! C179 ) " ) by L399 , L427 , FUNCTOR2:def 4;
thus L432: thesis by L431 , L400 , L426 , L429 , L430 , ALTCAT_4:3;
end;
definition
let C180 , C181 being category;
let C182 , C183 being  covariant (Functor of C180 , C181);
pred C182 , C183 are_naturally_equivalent 
means
:L433: (C182 is_naturally_transformable_to C183 & C183 is_transformable_to C182 & (ex B73 being (natural_transformation of C182 , C183) st (for B74 being (object of C180) holds ( B73 ! B74 ) is  iso)))
;reflexivity
proof
let C184 being  covariant (Functor of C180 , C181);
thus L434: (C184 is_naturally_transformable_to C184 & C184 is_transformable_to C184);
take ( idt C184 );
let C185 being (object of C180);
L435: ( ( idt C184 ) ! C185 ) = ( idm ( C184 . C185 ) ) by FUNCTOR2:4;
thus L436: thesis by L435;
end;
symmetry
proof
let C186 , C187 being  covariant (Functor of C180 , C181);
assume that
L437: C186 is_naturally_transformable_to C187
and
L438: C187 is_transformable_to C186;
given C188 being (natural_transformation of C186 , C187) such that
L439: (for B75 being (object of C180) holds ( C188 ! B75 ) is  iso);

consider C189 being (natural_transformation of C187 , C186) such that L440: (for B76 being (object of C180) holds (( C189 . B76 ) = ( ( C188 ! B76 ) " ) & ( C189 ! B76 ) is  iso)) by L437 , L438 , L439 , L397;
thus L441: C187 is_naturally_transformable_to C186 by L437 , L438 , L439 , L397;
thus L442: C186 is_transformable_to C187 by L437 , FUNCTOR2:def 6;
take C189;
thus L443: thesis by L440;
end;
end;
definition
let C190 , C191 being category;
let C192 , C193 being  covariant (Functor of C190 , C191);
assume that
L445: C192 , C193 are_naturally_equivalent ;
mode natural_equivalence of C192 , C193
 -> (natural_transformation of C192 , C193)
means :L446: (for B77 being (object of C190) holds ( it ! B77 ) is  iso);
existence by L445 , L433;
end;
theorem
L448: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R34 being  covariant (Functor of R28 , R29) holds ((R32 , R33 are_naturally_equivalent  & R33 , R34 are_naturally_equivalent ) implies R32 , R34 are_naturally_equivalent ))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R34 being  covariant (Functor of R28 , R29);
assume that
L449: R32 is_naturally_transformable_to R33
and
L450: R33 is_transformable_to R32;
given C194 being (natural_transformation of R32 , R33) such that
L451: (for B78 being (object of R28) holds ( C194 ! B78 ) is  iso);

assume that
L452: R33 is_naturally_transformable_to R34
and
L453: R34 is_transformable_to R33;
given C195 being (natural_transformation of R33 , R34) such that
L454: (for B79 being (object of R28) holds ( C195 ! B79 ) is  iso);

thus L455: (R32 is_naturally_transformable_to R34 & R34 is_transformable_to R32) by L449 , L450 , L452 , L453 , FUNCTOR2:2 , FUNCTOR2:8;
take ( C195 `*` C194 );
let C196 being (object of R28);
L456: ( C195 ! C196 ) is  iso by L454;
L457: R34 is_transformable_to R32 by L450 , L453 , FUNCTOR2:2;
L458: <^ ( R34 . C196 ) , ( R32 . C196 ) ^> <> ( {} ) by L457 , FUNCTOR2:def 1;
L459: ( C194 ! C196 ) is  iso by L451;
L460: R33 is_transformable_to R34 by L452 , FUNCTOR2:def 6;
L461: <^ ( R33 . C196 ) , ( R34 . C196 ) ^> <> ( {} ) by L460 , FUNCTOR2:def 1;
L462: R32 is_transformable_to R33 by L449 , FUNCTOR2:def 6;
L463: <^ ( R32 . C196 ) , ( R33 . C196 ) ^> <> ( {} ) by L462 , FUNCTOR2:def 1;
L464: ( ( C195 `*` C194 ) ! C196 ) = ( ( (C195 qua (transformation of R33 , R34)) `*` C194 ) ! C196 ) by L449 , L452 , FUNCTOR2:def 8
.= ( ( C195 ! C196 ) * ( C194 ! C196 ) ) by L462 , L460 , FUNCTOR2:def 5;
thus L465: thesis by L464 , L463 , L461 , L458 , L456 , L459 , ALTCAT_3:7;
end;
theorem
L466: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R34 being  covariant (Functor of R28 , R29) holds (for R41 being (natural_equivalence of R32 , R33) holds (for R42 being (natural_equivalence of R33 , R34) holds ((R32 , R33 are_naturally_equivalent  & R33 , R34 are_naturally_equivalent ) implies ( R42 `*` R41 ) is (natural_equivalence of R32 , R34)))))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R34 being  covariant (Functor of R28 , R29);
let R41 being (natural_equivalence of R32 , R33);
let R42 being (natural_equivalence of R33 , R34);
assume that
L467: R32 , R33 are_naturally_equivalent 
and
L468: R33 , R34 are_naturally_equivalent ;
thus L469: R32 , R34 are_naturally_equivalent  by L467 , L468 , L448;
let C197 being (object of R28);
L470: R32 is_transformable_to R33 by L467 , L433;
L471: <^ ( R32 . C197 ) , ( R33 . C197 ) ^> <> ( {} ) by L470 , FUNCTOR2:def 1;
L472: R34 is_transformable_to R32 by L469 , L433;
L473: <^ ( R34 . C197 ) , ( R32 . C197 ) ^> <> ( {} ) by L472 , FUNCTOR2:def 1;
L474: R33 is_transformable_to R34 by L468 , L433;
L475: <^ ( R33 . C197 ) , ( R34 . C197 ) ^> <> ( {} ) by L474 , FUNCTOR2:def 1;
L476: (R32 is_naturally_transformable_to R33 & R33 is_naturally_transformable_to R34) by L467 , L468 , L433;
L477: ( ( R42 `*` R41 ) ! C197 ) = ( ( (R42 qua (transformation of R33 , R34)) `*` R41 ) ! C197 ) by L476 , FUNCTOR2:def 8
.= ( ( R42 ! C197 ) * ( R41 ! C197 ) ) by L470 , L474 , FUNCTOR2:def 5;
L478: (( R42 ! C197 ) is  iso & ( R41 ! C197 ) is  iso) by L467 , L468 , L446;
thus L479: thesis by L478 , L477 , L471 , L475 , L473 , ALTCAT_3:7;
end;
theorem
L480: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R41 being (natural_equivalence of R32 , R33) holds (R32 , R33 are_naturally_equivalent  implies (( R35 * R32 ) , ( R35 * R33 ) are_naturally_equivalent  & ( R35 * R41 ) is (natural_equivalence of ( R35 * R32 ) , ( R35 * R33 )))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R41 being (natural_equivalence of R32 , R33);
assume L481: R32 , R33 are_naturally_equivalent ;
L482: R33 is_transformable_to R32 by L481 , L433;
L483: R32 is_naturally_transformable_to R33 by L481 , L433;
reconsider D61 = ( R35 * R41 ) as (natural_transformation of ( R35 * R32 ) , ( R35 * R33 )) by L483 , L349;
L484: R32 is_transformable_to R33 by L481 , L433;
L485:
now
let C198 being (object of R28);
L486: (( ( R35 * R32 ) . C198 ) = ( R35 . ( R32 . C198 ) ) & ( ( R35 * R33 ) . C198 ) = ( R35 . ( R33 . C198 ) )) by FUNCTOR0:33;
L487: <^ ( R33 . C198 ) , ( R32 . C198 ) ^> <> ( {} ) by L482 , FUNCTOR2:def 1;
L488: (( D61 ! C198 ) = ( R35 . ( R41 ! C198 ) ) & <^ ( R32 . C198 ) , ( R33 . C198 ) ^> <> ( {} )) by L484 , L176 , FUNCTOR2:def 1;
thus L489: ( D61 ! C198 ) is  iso by L488 , L481 , L486 , L487 , L446 , ALTCAT_4:20;
end;
L490: ( R35 * R32 ) , ( R35 * R33 ) are_naturally_equivalent 
proof
thus L491: ( R35 * R32 ) is_naturally_transformable_to ( R35 * R33 ) by L483 , L315;
thus L492: ( R35 * R33 ) is_transformable_to ( R35 * R32 ) by L482 , L149;
take D61;
let C199 being (object of R28);
thus L493: thesis by L485;
end;
thus L494: thesis by L490 , L485 , L446;
end;
theorem
L495: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R36 being  covariant (Functor of R29 , R30) holds (for R43 being (natural_equivalence of R35 , R36) holds (R35 , R36 are_naturally_equivalent  implies (( R35 * R32 ) , ( R36 * R32 ) are_naturally_equivalent  & ( R43 * R32 ) is (natural_equivalence of ( R35 * R32 ) , ( R36 * R32 )))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R36 being  covariant (Functor of R29 , R30);
let R43 being (natural_equivalence of R35 , R36);
assume L496: R35 , R36 are_naturally_equivalent ;
L497: R35 is_naturally_transformable_to R36 by L496 , L433;
reconsider D62 = ( R43 * R32 ) as (natural_transformation of ( R35 * R32 ) , ( R36 * R32 )) by L497 , L362;
L498:
now
let C200 being (object of R28);
L499: R35 is_transformable_to R36 by L496 , L433;
L500: ( D62 ! C200 ) = ( R43 ! ( R32 . C200 ) ) by L499 , L199;
L501: (( ( R35 * R32 ) . C200 ) = ( R35 . ( R32 . C200 ) ) & ( ( R36 * R32 ) . C200 ) = ( R36 . ( R32 . C200 ) )) by FUNCTOR0:33;
thus L502: ( D62 ! C200 ) is  iso by L501 , L496 , L500 , L446;
end;
L503: ( R35 * R32 ) , ( R36 * R32 ) are_naturally_equivalent 
proof
thus L504: ( R35 * R32 ) is_naturally_transformable_to ( R36 * R32 ) by L497 , L315;
L505: R36 is_transformable_to R35 by L496 , L433;
thus L506: ( R36 * R32 ) is_transformable_to ( R35 * R32 ) by L505 , L149;
take D62;
let C201 being (object of R28);
thus L507: thesis by L498;
end;
thus L508: thesis by L503 , L498 , L446;
end;
theorem
L509: (for R28 being category holds (for R29 being category holds (for R30 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R35 being  covariant (Functor of R29 , R30) holds (for R36 being  covariant (Functor of R29 , R30) holds (for R41 being (natural_equivalence of R32 , R33) holds (for R43 being (natural_equivalence of R35 , R36) holds ((R32 , R33 are_naturally_equivalent  & R35 , R36 are_naturally_equivalent ) implies (( R35 * R32 ) , ( R36 * R33 ) are_naturally_equivalent  & ( R43 (#) R41 ) is (natural_equivalence of ( R35 * R32 ) , ( R36 * R33 )))))))))))))
proof
let R28 being category;
let R29 being category;
let R30 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R35 being  covariant (Functor of R29 , R30);
let R36 being  covariant (Functor of R29 , R30);
let R41 being (natural_equivalence of R32 , R33);
let R43 being (natural_equivalence of R35 , R36);
assume that
L510: R32 , R33 are_naturally_equivalent 
and
L511: R35 , R36 are_naturally_equivalent ;
L512: ( R35 * R32 ) , ( R35 * R33 ) are_naturally_equivalent  by L510 , L480;
L513: ( R35 * R32 ) is_naturally_transformable_to ( R35 * R33 ) by L512 , L433;
L514: R35 is_naturally_transformable_to R36 by L511 , L433;
reconsider D63 = ( R43 * R33 ) as (natural_transformation of ( R35 * R33 ) , ( R36 * R33 )) by L514 , L362;
L515: R32 is_naturally_transformable_to R33 by L510 , L433;
reconsider D64 = ( R35 * R41 ) as (natural_transformation of ( R35 * R32 ) , ( R35 * R33 )) by L515 , L349;
L516: ( R35 * R33 ) , ( R36 * R33 ) are_naturally_equivalent  by L511 , L495;
L517: ( R35 * R33 ) is_naturally_transformable_to ( R36 * R33 ) by L516 , L433;
L518: (( R43 * R33 ) is (natural_equivalence of ( R35 * R33 ) , ( R36 * R33 )) & ( R35 * R41 ) is (natural_equivalence of ( R35 * R32 ) , ( R35 * R33 ))) by L510 , L511 , L480 , L495;
L519: ( D63 `*` D64 ) is (natural_equivalence of ( R35 * R32 ) , ( R36 * R33 )) by L518 , L516 , L512 , L466;
thus L520: thesis by L519 , L516 , L512 , L517 , L513 , L448 , FUNCTOR2:def 8;
end;
definition
let C202 , C203 being category;
let C204 , C205 being  covariant (Functor of C202 , C203);
let C206 being (natural_equivalence of C204 , C205);
assume that
L521: C204 , C205 are_naturally_equivalent ;
func C206 " -> (natural_equivalence of C205 , C204) means 
:L522: (for B80 being (object of C202) holds ( it . B80 ) = ( ( C206 ! B80 ) " ));
existence
proof
L523: (for B81 being (object of C202) holds ( C206 ! B81 ) is  iso) by L521 , L446;
L524: (C204 is_naturally_transformable_to C205 & C205 is_transformable_to C204) by L521 , L433;
consider C207 being (natural_transformation of C205 , C204) such that L525: (for B82 being (object of C202) holds (( C207 . B82 ) = ( ( C206 ! B82 ) " ) & ( C207 ! B82 ) is  iso)) by L524 , L523 , L397;
L526: C207 is (natural_equivalence of C205 , C204)
proof
thus L527: C205 , C204 are_naturally_equivalent  by L521;
let C208 being (object of C202);
thus L528: thesis by L525;
end;
reconsider D65 = C207 as (natural_equivalence of C205 , C204) by L526;
take D65;
let C209 being (object of C202);
thus L529: thesis by L525;
end;
uniqueness
proof
let C210 , C211 being (natural_equivalence of C205 , C204);
assume that
L530: (for B83 being (object of C202) holds ( C210 . B83 ) = ( ( C206 ! B83 ) " ))
and
L531: (for B84 being (object of C202) holds ( C211 . B84 ) = ( ( C206 ! B84 ) " ));
L532: C205 is_transformable_to C204 by L521 , L433;
L533:
now
let C212 being (object of C202);
thus L534: ( C210 ! C212 ) = ( C210 . C212 ) by L532 , FUNCTOR2:def 4
.= ( ( C206 ! C212 ) " ) by L530
.= ( C211 . C212 ) by L531
.= ( C211 ! C212 ) by L532 , FUNCTOR2:def 4;
end;
thus L535: C210 = C211 by L533 , L532 , FUNCTOR2:3;
end;
end;
theorem
L537: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R41 being (natural_equivalence of R32 , R33) holds (for B85 being (object of R28) holds (R32 , R33 are_naturally_equivalent  implies ( ( R41 " ) ! B85 ) = ( ( R41 ! B85 ) " ))))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R41 being (natural_equivalence of R32 , R33);
let C213 being (object of R28);
assume L538: R32 , R33 are_naturally_equivalent ;
L539: R33 is_transformable_to R32 by L538 , L433;
thus L540: ( ( R41 " ) ! C213 ) = ( ( R41 " ) . C213 ) by L539 , FUNCTOR2:def 4
.= ( ( R41 ! C213 ) " ) by L538 , L522;
end;
theorem
L541: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R41 being (natural_equivalence of R32 , R33) holds (R32 , R33 are_naturally_equivalent  implies ( R41 `*` ( R41 " ) ) = ( idt R33 )))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R41 being (natural_equivalence of R32 , R33);
assume L542: R32 , R33 are_naturally_equivalent ;
L543: (R32 is_transformable_to R33 & R33 is_transformable_to R32) by L542 , L433;
L544: (R32 is_naturally_transformable_to R33 & R33 is_naturally_transformable_to R32) by L542 , L433;
L545:
now
let C214 being (object of R28);
L546: ( R41 ! C214 ) is  iso by L542 , L446;
thus L547: ( ( R41 `*` ( R41 " ) ) ! C214 ) = ( ( (R41 qua (transformation of R32 , R33)) `*` ( R41 " ) ) ! C214 ) by L544 , FUNCTOR2:def 8
.= ( ( R41 ! C214 ) * ( ( R41 " ) ! C214 ) ) by L543 , FUNCTOR2:def 5
.= ( ( R41 ! C214 ) * ( ( R41 ! C214 ) " ) ) by L542 , L537
.= ( idm ( R33 . C214 ) ) by L546 , ALTCAT_3:def 5
.= ( ( idt R33 ) ! C214 ) by FUNCTOR2:4;
end;
thus L548: thesis by L545 , FUNCTOR2:3;
end;
theorem
L549: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R41 being (natural_equivalence of R32 , R33) holds (R32 , R33 are_naturally_equivalent  implies ( ( R41 " ) `*` R41 ) = ( idt R32 )))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R41 being (natural_equivalence of R32 , R33);
assume L550: R32 , R33 are_naturally_equivalent ;
L551: (R32 is_transformable_to R33 & R33 is_transformable_to R32) by L550 , L433;
L552: (R32 is_naturally_transformable_to R33 & R33 is_naturally_transformable_to R32) by L550 , L433;
L553:
now
let C215 being (object of R28);
L554: ( R41 ! C215 ) is  iso by L550 , L446;
thus L555: ( ( ( R41 " ) `*` R41 ) ! C215 ) = ( ( ( R41 " ) `*` (R41 qua (transformation of R32 , R33)) ) ! C215 ) by L552 , FUNCTOR2:def 8
.= ( ( ( R41 " ) ! C215 ) * ( R41 ! C215 ) ) by L551 , FUNCTOR2:def 5
.= ( ( ( R41 ! C215 ) " ) * ( R41 ! C215 ) ) by L550 , L537
.= ( idm ( R32 . C215 ) ) by L554 , ALTCAT_3:def 5
.= ( ( idt R32 ) ! C215 ) by FUNCTOR2:4;
end;
thus L556: thesis by L553 , FUNCTOR2:3;
end;
definition
let C216 , C217 being category;
let C218 being  covariant (Functor of C216 , C217);
redefine func idt C218 -> (natural_equivalence of C218 , C218);

coherence
proof
set D66 = the (natural_equivalence of C218 , C218);
L557: ( D66 `*` ( D66 " ) ) = ( idt C218 ) by L541;
thus L558: thesis by L557 , L466;
end;
end;
theorem
L560: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R41 being (natural_equivalence of R32 , R33) holds (R32 , R33 are_naturally_equivalent  implies ( ( R41 " ) " ) = R41))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R41 being (natural_equivalence of R32 , R33);
assume L561: R32 , R33 are_naturally_equivalent ;
L562: R32 is_transformable_to R33 by L561 , L433;
L563:
now
let C219 being (object of R28);
L564: <^ ( R32 . C219 ) , ( R33 . C219 ) ^> <> ( {} ) by L562 , FUNCTOR2:def 1;
L565: R33 is_transformable_to R32 by L561 , L433;
L566: <^ ( R33 . C219 ) , ( R32 . C219 ) ^> <> ( {} ) by L565 , FUNCTOR2:def 1;
L567: ( R41 ! C219 ) is  iso by L561 , L446;
L568: ( R41 ! C219 ) is  retraction  coretraction by L567 , ALTCAT_3:5;
thus L569: ( ( ( R41 " ) " ) ! C219 ) = ( ( ( R41 " ) ! C219 ) " ) by L561 , L537
.= ( ( ( R41 ! C219 ) " ) " ) by L561 , L537
.= ( R41 ! C219 ) by L564 , L566 , L568 , ALTCAT_3:3;
end;
thus L570: thesis by L563 , L562 , FUNCTOR2:3;
end;
theorem
L571: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds (for R33 being  covariant (Functor of R28 , R29) holds (for R34 being  covariant (Functor of R28 , R29) holds (for R41 being (natural_equivalence of R32 , R33) holds (for R42 being (natural_equivalence of R33 , R34) holds (for B86 being (natural_equivalence of R32 , R34) holds ((B86 = ( R42 `*` R41 ) & R32 , R33 are_naturally_equivalent  & R33 , R34 are_naturally_equivalent ) implies ( B86 " ) = ( ( R41 " ) `*` ( R42 " ) ))))))))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
let R33 being  covariant (Functor of R28 , R29);
let R34 being  covariant (Functor of R28 , R29);
let R41 being (natural_equivalence of R32 , R33);
let R42 being (natural_equivalence of R33 , R34);
let C220 being (natural_equivalence of R32 , R34);
assume that
L572: C220 = ( R42 `*` R41 )
and
L573: R32 , R33 are_naturally_equivalent 
and
L574: R33 , R34 are_naturally_equivalent ;
L575: (R34 is_naturally_transformable_to R33 & R33 is_naturally_transformable_to R32) by L573 , L574 , L433;
L576: (R32 is_transformable_to R33 & R33 is_transformable_to R34) by L573 , L574 , L433;
L577: (R32 is_naturally_transformable_to R33 & R33 is_naturally_transformable_to R34) by L573 , L574 , L433;
L578: (R34 is_transformable_to R33 & R33 is_transformable_to R32) by L573 , L574 , L433;
L579: R34 is_transformable_to R32 by L578 , FUNCTOR2:2;
L580:
now
let C221 being (object of R28);
L581: (<^ ( R32 . C221 ) , ( R33 . C221 ) ^> <> ( {} ) & <^ ( R33 . C221 ) , ( R34 . C221 ) ^> <> ( {} )) by L576 , FUNCTOR2:def 1;
L582: <^ ( R34 . C221 ) , ( R32 . C221 ) ^> <> ( {} ) by L579 , FUNCTOR2:def 1;
L583: (( R41 ! C221 ) is  iso & ( R42 ! C221 ) is  iso) by L573 , L574 , L446;
thus L584: ( ( C220 " ) ! C221 ) = ( ( ( R42 `*` R41 ) ! C221 ) " ) by L572 , L573 , L574 , L448 , L537
.= ( ( ( (R42 qua (transformation of R33 , R34)) `*` R41 ) ! C221 ) " ) by L577 , FUNCTOR2:def 8
.= ( ( ( R42 ! C221 ) * ( R41 ! C221 ) ) " ) by L576 , FUNCTOR2:def 5
.= ( ( ( R41 ! C221 ) " ) * ( ( R42 ! C221 ) " ) ) by L583 , L581 , L582 , ALTCAT_3:7
.= ( ( ( R41 ! C221 ) " ) * ( ( R42 " ) ! C221 ) ) by L574 , L537
.= ( ( ( R41 " ) ! C221 ) * ( ( R42 " ) ! C221 ) ) by L573 , L537
.= ( ( (( R41 " ) qua (transformation of R33 , R32)) `*` ( R42 " ) ) ! C221 ) by L578 , FUNCTOR2:def 5
.= ( ( ( R41 " ) `*` ( R42 " ) ) ! C221 ) by L575 , FUNCTOR2:def 8;
end;
thus L585: thesis by L580 , L578 , FUNCTOR2:2 , FUNCTOR2:3;
end;
theorem
L586: (for R28 being category holds (for R29 being category holds (for R32 being  covariant (Functor of R28 , R29) holds ( ( idt R32 ) " ) = ( idt R32 ))))
proof
let R28 being category;
let R29 being category;
let R32 being  covariant (Functor of R28 , R29);
L587:
now
let C222 being (object of R28);
thus L588: ( ( ( idt R32 ) " ) ! C222 ) = ( ( ( idt R32 ) ! C222 ) " ) by L537
.= ( ( idm ( R32 . C222 ) ) " ) by FUNCTOR2:4
.= ( idm ( R32 . C222 ) ) by ALTCAT_3:4
.= ( ( idt R32 ) ! C222 ) by FUNCTOR2:4;
end;
thus L589: thesis by L587 , FUNCTOR2:3;
end;
