:: Introduction to Circuits, II
::  by Yatsuka Nakamura, Piotr Rudnicki, Andrzej Trybulec and Pauline N. Kawamoto
::
:: Received April 10, 1995
:: Copyright (c) 1995-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies MSAFREE2, STRUCT_0, XBOOLE_0, MSUALG_1, RELAT_1, PBOOLE, MSAFREE,
      FUNCOP_1, FUNCT_1, TREES_3, FINSEQ_1, SUBSET_1, TREES_4, MSUALG_3,
      MARGREL1, FINSEQ_4, TARSKI, DTCONSTR, NAT_1, NUMBERS, TREES_2, CARD_3,
      PARTFUN1, ZFMISC_1, TDGROUP, CIRCUIT1, FSM_1, FUNCT_4, GLIB_000,
      UNIALG_2, MSATERM, PRELAMB, REALSET1, CARD_1, XXREAL_0, ARYTM_3, FUNCT_6,
      TREES_A, FINSET_1, CIRCUIT2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, XXREAL_0, ORDINAL1, NAT_1, FINSEQ_1,
      FINSEQ_2, FINSET_1, TREES_2, TREES_3, TREES_4, CARD_3, FUNCT_6, LANG1,
      DTCONSTR, PBOOLE, FUNCOP_1, XXREAL_2, STRUCT_0, PRALG_1, MSUALG_1,
      MSUALG_2, MSUALG_3, MSAFREE, MSAFREE2, CIRCUIT1, MSATERM;
 constructors PRALG_1, MSUALG_3, MSATERM, CIRCUIT1, SEQ_4, RELSET_1, FUNCT_4;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      XREAL_0, MEMBERED, FINSEQ_1, CARD_3, TREES_3, PRE_CIRC, STRUCT_0,
      MSUALG_1, MSUALG_3, MSAFREE, MSAFREE2, CIRCUIT1, XXREAL_2, CARD_1,
      RELSET_1, PBOOLE;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions PBOOLE, MSAFREE2;
 theorems TARSKI, NAT_1, FINSEQ_1, FINSEQ_2, FINSEQ_3, RELAT_1, GRFUNC_1,
      FUNCT_1, FUNCT_2, FUNCT_4, TREES_3, TREES_4, DTCONSTR, FUNCT_6, ZFMISC_1,
      CARD_3, MSATERM, PARTFUN2, FUNCOP_1, PBOOLE, PRALG_1, MSUALG_1, MSUALG_2,
      MSUALG_3, MSAFREE, PRE_CIRC, MSAFREE2, CIRCUIT1, TREES_1, EXTENS_1,
      RELSET_1, XBOOLE_0, XBOOLE_1, ORDINAL1, XXREAL_0, PARTFUN1, XXREAL_2,
      CARD_1, XTUPLE_0;
 schemes NAT_1, FINSEQ_1, PRE_CIRC, PBOOLE;

begin
L1: (for B1 being set holds (not B1 in B1));
theorem
L2: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B2 being  non-empty (ManySortedSet of (the carrier of R1)) holds (for B3 being (ManySortedFunction of ( FreeMSA B2 ) , ( FreeMSA B2 )) holds (for B4 being  Function-yielding Function holds (for B5 being (SortSymbol of R1) holds (for B6 being  DTree-yielding FinSequence holds (for B7 being (Element of ( (the Sorts of ( FreeMSA B2 )) . B5 )) holds ((B5 in ( InnerVertices R1 ) & B7 = ( [ ( action_at B5 ) , (the carrier of R1) ] -tree B6 ) & B3 is_homomorphism ( FreeMSA B2 ) , ( FreeMSA B2 ) & B4 = ( B3 * ( the_arity_of ( action_at B5 ) ) )) implies (ex B8 being  DTree-yielding FinSequence st (B8 = ( B4 .. B6 ) & ( ( B3 . B5 ) . B7 ) = ( [ ( action_at B5 ) , (the carrier of R1) ] -tree B8 )))))))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C1 being  non-empty (ManySortedSet of (the carrier of R1));
let C2 being (ManySortedFunction of ( FreeMSA C1 ) , ( FreeMSA C1 ));
let C3 being  Function-yielding Function;
let C4 being (SortSymbol of R1);
let C5 being  DTree-yielding FinSequence;
let C6 being (Element of ( (the Sorts of ( FreeMSA C1 )) . C4 ));
assume that
L3: C4 in ( InnerVertices R1 )
and
L4: C6 = ( [ ( action_at C4 ) , (the carrier of R1) ] -tree C5 )
and
L5: C2 is_homomorphism ( FreeMSA C1 ) , ( FreeMSA C1 )
and
L6: C3 = ( C2 * ( the_arity_of ( action_at C4 ) ) );
reconsider D1 = ( action_at C4 ) as (OperSymbol of R1);
L7: ( the_result_sort_of D1 ) = C4 by L3 , MSAFREE2:def 7;
L8: ( len C5 ) = ( len ( the_arity_of D1 ) ) by L7 , L4 , MSAFREE2:10;
L9: ( dom C5 ) = ( dom ( the_arity_of D1 ) ) by L8 , FINSEQ_3:29;
L10: ( rng ( the_arity_of D1 ) ) c= (the carrier of R1) by FINSEQ_1:def 4;
L11: ( rng ( the_arity_of D1 ) ) c= ( dom C2 ) by L10 , PARTFUN1:def 2;
L12: ( dom ( the_arity_of D1 ) ) = ( dom C3 ) by L11 , L6 , RELAT_1:27;
L13: ( FreeMSA C1 ) = MSAlgebra (# ( FreeSort C1 ) , ( FreeOper C1 ) #) by MSAFREE:def 14;
L14: ( (the Sorts of ( FreeMSA C1 )) . C4 ) = ( FreeSort (C1 , C4) ) by L13 , MSAFREE:def 11;
L15: ( [ D1 , (the carrier of R1) ] -tree C5 ) in ( FreeSort (C1 , C4) ) by L14 , L4;
L16: ( [ D1 , (the carrier of R1) ] -tree C5 ) in { B9 where B9 is (Element of ( TS ( DTConMSA C1 ) )) : ((ex B10 being set st (B10 in ( C1 . C4 ) & B9 = ( root-tree [ B10 , C4 ] ))) or (ex B11 being (OperSymbol of R1) st ([ B11 , (the carrier of R1) ] = ( B9 . ( {} ) ) & ( the_result_sort_of B11 ) = C4))) } by L15 , MSAFREE:def 10;
reconsider D2 = ( C3 .. C5 ) as Function;
L17: ( dom D2 ) = ( dom C3 ) by PRALG_1:def 17;
L18: ( C2 * ( the_arity_of D1 ) ) is FinSequence by L11 , FINSEQ_1:16;
L19: (ex B12 being Nat st ( dom C3 ) = ( Seg B12 )) by L18 , L6 , FINSEQ_1:def 2;
reconsider D3 = D2 as FinSequence by L19 , L17 , FINSEQ_1:def 2;
L20:
now
reconsider D4 = C3 as FinSequence by L6 , L11 , FINSEQ_1:16;
let C7 being set;
set D5 = ( D3 . C7 );
reconsider D6 = ( C3 . C7 ) as Function;
assume L21: C7 in ( dom D3 );
reconsider D7 = C7 as (Element of ( NAT )) by L21;
L22: D5 = ( D6 . ( C5 . D7 ) ) by L17 , L21 , PRALG_1:def 17;
L23: ( len D4 ) = ( len ( the_arity_of D1 ) ) by L6 , L11 , FINSEQ_2:29;
L24: ( dom D4 ) = ( dom ( the_arity_of D1 ) ) by L23 , FINSEQ_3:29;
reconsider D8 = ( ( the_arity_of D1 ) . D7 ) as (SortSymbol of R1) by L24 , L17 , L21 , FINSEQ_2:11;
L25: D6 = ( C2 . D8 ) by L6 , L17 , L21 , L24 , FUNCT_1:13;
L26: D5 in ( (the Sorts of ( FreeMSA C1 )) . D8 ) by L25 , L4 , L17 , L7 , L21 , L24 , L22 , FUNCT_2:5 , MSAFREE2:11;
thus L27: D5 is DecoratedTree by L26;
end;
set D9 = ( (the Sorts of ( FreeMSA C1 )) * ( the_arity_of D1 ) );
L28: ( dom (the Arity of R1) ) = (the carrier' of R1) by FUNCT_2:def 1;
L29: ( ( ( (the Sorts of ( FreeMSA C1 )) # ) * (the Arity of R1) ) . D1 ) = ( ( (the Sorts of ( FreeMSA C1 )) # ) . ( (the Arity of R1) . D1 ) ) by L28 , FUNCT_1:13
.= ( ( (the Sorts of ( FreeMSA C1 )) # ) . ( the_arity_of D1 ) ) by MSUALG_1:def 1
.= ( product ( (the Sorts of ( FreeMSA C1 )) * ( the_arity_of D1 ) ) ) by FINSEQ_2:def 5;
reconsider D10 = D3 as  DTree-yielding FinSequence by L20 , TREES_3:24;
consider C8 being (Element of ( TS ( DTConMSA C1 ) )) such that L30: C8 = ( [ D1 , (the carrier of R1) ] -tree C5 ) and L31: ((ex B13 being set st (B13 in ( C1 . C4 ) & C8 = ( root-tree [ B13 , C4 ] ))) or (ex B14 being (OperSymbol of R1) st ([ B14 , (the carrier of R1) ] = ( C8 . ( {} ) ) & ( the_result_sort_of B14 ) = C4))) by L16;
consider C9 being set such that L32: ((C9 in ( C1 . C4 ) & C8 = ( root-tree [ C9 , C4 ] )) or (ex B15 being (OperSymbol of R1) st ([ B15 , (the carrier of R1) ] = ( C8 . ( {} ) ) & ( the_result_sort_of B15 ) = C4))) by L31;
L33: ( dom (the Sorts of ( FreeMSA C1 )) ) = (the carrier of R1) by PARTFUN1:def 2;
L34: ( dom D9 ) = ( dom ( the_arity_of D1 ) ) by L33 , L10 , RELAT_1:27;
L35:
now
let C10 being set;
assume L36: C10 in ( dom D9 );
reconsider D11 = C10 as (Element of ( NAT )) by L36 , L34;
L37: ( ( the_arity_of D1 ) . C10 ) in ( rng ( the_arity_of D1 ) ) by L34 , L36 , FUNCT_1:def 3;
reconsider D12 = ( ( the_arity_of D1 ) . C10 ) as (SortSymbol of R1) by L37 , L10;
L38: (D11 in ( dom ( the_arity_of D1 ) ) & ( ( (the Sorts of ( FreeMSA C1 )) * ( the_arity_of D1 ) ) . C10 ) = ( (the Sorts of ( FreeMSA C1 )) . D12 )) by L34 , L36 , FUNCT_1:13;
thus L39: ( C5 . C10 ) in ( D9 . C10 ) by L38 , L4 , L7 , MSAFREE2:11;
end;
L40: C5 in ( ( ( (the Sorts of ( FreeMSA C1 )) # ) * (the Arity of R1) ) . D1 ) by L35 , L29 , L34 , L9 , CARD_3:def 5;
reconsider D13 = C5 as (Element of ( Args (D1 , ( FreeMSA C1 )) )) by L40 , MSUALG_1:def 4;
L41: ( C8 . ( {} ) ) = [ D1 , (the carrier of R1) ] by L30 , TREES_4:def 4;
reconsider D14 = ( C2 # D13 ) as Function;
L42:
now
let C11 being set;
assume L43: C11 in ( dom C3 );
reconsider D15 = C11 as (Element of ( NAT )) by L43 , L12;
L44: ( ( the_arity_of D1 ) . D15 ) in ( rng ( the_arity_of D1 ) ) by L12 , L43 , FUNCT_1:def 3;
reconsider D16 = ( ( the_arity_of D1 ) . D15 ) as (SortSymbol of R1) by L44 , L10;
L45: ( D14 . D15 ) = ( ( C2 . ( ( the_arity_of D1 ) /. D15 ) ) . ( C5 . D15 ) ) by L12 , L9 , L43 , MSUALG_3:def 6
.= ( ( C2 . D16 ) . ( C5 . D15 ) ) by L12 , L43 , PARTFUN1:def 6;
thus L46: ( D14 . C11 ) = ( ( C3 . C11 ) . ( C5 . C11 ) ) by L45 , L6 , L12 , L43 , FUNCT_1:13;
end;
L47: ( dom D14 ) = ( dom C3 ) by L12 , MSUALG_3:6;
L48: D10 = ( C2 # D13 ) by L47 , L42 , PRALG_1:def 17;
L49:
now
assume L50: C8 = ( root-tree [ C9 , C4 ] );
L51: ( C8 . ( {} ) ) = [ C9 , C4 ] by L50 , TREES_4:3;
L52: ( C8 . ( {} ) ) = [ D1 , (the carrier of R1) ] by L30 , TREES_4:def 4;
L53: (the carrier of R1) = C4 by L52 , L51 , XTUPLE_0:1;
thus L54: contradiction by L53 , L1;
end;
consider C12 being (OperSymbol of R1) such that L55: [ C12 , (the carrier of R1) ] = ( C8 . ( {} ) ) and L56: ( the_result_sort_of C12 ) = C4 by L49 , L32;
L57: (the carrier of R1) in { (the carrier of R1) } by TARSKI:def 1;
L58: [ C12 , (the carrier of R1) ] in [: (the carrier' of R1) , { (the carrier of R1) } :] by L57 , ZFMISC_1:87;
reconsider D17 = [ C12 , (the carrier of R1) ] as (NonTerminal of ( DTConMSA C1 )) by L58 , MSAFREE:6;
consider C13 being (FinSequence of ( TS ( DTConMSA C1 ) )) such that L59: C8 = ( D17 -tree C13 ) and L60: D17 ==> ( roots C13 ) by L55 , DTCONSTR:10;
take D10;
thus L61: D10 = ( C3 .. C5 );
L62: ( Sym (D1 , C1) ) = [ D1 , (the carrier of R1) ] by MSAFREE:def 9;
L63:
now
let C14 being set;
reconsider D18 = ( C3 . C14 ) as Function;
assume L64: C14 in ( dom D9 );
L65: ( D10 . C14 ) = ( D18 . ( C5 . C14 ) ) by L64 , L34 , L12 , PRALG_1:def 17;
L66: ( ( the_arity_of D1 ) . C14 ) in ( rng ( the_arity_of D1 ) ) by L34 , L64 , FUNCT_1:def 3;
reconsider D19 = ( ( the_arity_of D1 ) . C14 ) as (SortSymbol of R1) by L66 , L10;
L67: ( the_result_sort_of D1 ) = C4 by L3 , MSAFREE2:def 7;
L68: (( ( (the Sorts of ( FreeMSA C1 )) * ( the_arity_of D1 ) ) . C14 ) = ( (the Sorts of ( FreeMSA C1 )) . D19 ) & D18 = ( C2 . D19 )) by L6 , L34 , L64 , FUNCT_1:13;
thus L69: ( D10 . C14 ) in ( D9 . C14 ) by L68 , L4 , L34 , L64 , L67 , L65 , FUNCT_2:5 , MSAFREE2:11;
end;
L70: D10 in ( ( ( ( FreeSort C1 ) # ) * (the Arity of R1) ) . D1 ) by L63 , L17 , L29 , L34 , L12 , L13 , CARD_3:def 5;
reconsider D20 = D10 as (FinSequence of ( TS ( DTConMSA C1 ) )) by L70 , MSAFREE:8;
L71: ( Sym (D1 , C1) ) ==> ( roots D20 ) by L70 , MSAFREE:10;
reconsider D21 = C5 as (FinSequence of ( TS ( DTConMSA C1 ) )) by L30 , L59 , TREES_4:15;
L72: C13 = C5 by L30 , L59 , TREES_4:15;
L73: ( ( DenOp (D1 , C1) ) . D21 ) = C6 by L72 , L4 , L55 , L41 , L60 , L62 , MSAFREE:def 12;
L74: ( Den (D1 , ( FreeMSA C1 )) ) = ( ( FreeOper C1 ) . D1 ) by L13 , MSUALG_1:def 6
.= ( DenOp (D1 , C1) ) by MSAFREE:def 13;
thus L75: ( ( C2 . C4 ) . C6 ) = ( ( DenOp (D1 , C1) ) . D10 ) by L74 , L5 , L7 , L73 , L48 , MSUALG_3:def 7
.= ( [ ( action_at C4 ) , (the carrier of R1) ] -tree D10 ) by L62 , L71 , MSAFREE:def 12;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C15 being  non-empty (Circuit of R1);
let C16 being (State of C15);
let C17 being (InputValues of C15);
redefine func C16 +* C17 -> (State of C15);

coherence
proof
L76: ( dom C17 ) = ( InputVertices R1 ) by PARTFUN1:def 2;
L77: (( dom (the Sorts of C15) ) = (the carrier of R1) & (for B16 being set holds (B16 in ( dom C17 ) implies ( C17 . B16 ) in ( (the Sorts of C15) . B16 )))) by L76 , MSAFREE2:def 5 , PARTFUN1:def 2;
thus L78: thesis by L77 , L76 , PRE_CIRC:6;
end;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C18 being  non-empty (Circuit of R1);
let C19 being (InputValues of C18);
func Fix_inp C19 -> (ManySortedFunction of ( FreeGen (the Sorts of C18) ) , (the Sorts of ( FreeEnv C18 ))) means 
:L80: (for B17 being (Vertex of R1) holds ((B17 in ( InputVertices R1 ) implies ( it . B17 ) = ( ( FreeGen (B17 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . B17 ) , B17 ] ) )) & (B17 in ( SortsWithConstants R1 ) implies ( it . B17 ) = ( ( FreeGen (B17 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at B17 ) , (the carrier of R1) ] ) )) & (B17 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) implies ( it . B17 ) = ( id ( FreeGen (B17 , (the Sorts of C18)) ) ))));
existence
proof
defpred S1[ set , set ] means (ex B18 being (Vertex of R1) st (B18 = $1 & ($1 in ( InputVertices R1 ) implies $2 = ( ( FreeGen (B18 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . B18 ) , B18 ] ) )) & ($1 in ( SortsWithConstants R1 ) implies $2 = ( ( FreeGen (B18 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at B18 ) , (the carrier of R1) ] ) )) & ($1 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) implies $2 = ( id ( FreeGen (B18 , (the Sorts of C18)) ) ))));
L81:
now
let C20 being set;
assume L82: C20 in (the carrier of R1);
reconsider D22 = C20 as (Vertex of R1) by L82;
L83: D22 in ( ( InputVertices R1 ) \/ ( InnerVertices R1 ) ) by L82 , XBOOLE_1:45;
L84: (D22 in ( InputVertices R1 ) or D22 in ( InnerVertices R1 )) by L83 , XBOOLE_0:def 3;
L85: ( ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) \/ ( SortsWithConstants R1 ) ) = ( InnerVertices R1 ) by MSAFREE2:3 , XBOOLE_1:45;
thus L86: (ex B19 being set st S1[ C20 , B19 ])
proof
per cases  by L85 , L84 , XBOOLE_0:def 3;
suppose L87: D22 in ( InputVertices R1 );

reconsider D23 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . D22 ) , D22 ] ) ) as set;
take D23;
take D22;
thus L88: D22 = C20;
thus L89: (C20 in ( InputVertices R1 ) implies D23 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . D22 ) , D22 ] ) ));
thus L90:now
L91: ( InputVertices R1 ) misses ( SortsWithConstants R1 ) by MSAFREE2:4;
assume L92: C20 in ( SortsWithConstants R1 );
thus L93: D23 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at D22 ) , (the carrier of R1) ] ) ) by L92 , L87 , L91 , XBOOLE_0:3;
end;
L94: (( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) c= ( InnerVertices R1 ) & ( InputVertices R1 ) misses ( InnerVertices R1 )) by XBOOLE_1:36 , XBOOLE_1:79;
assume L95: C20 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );
thus L96: thesis by L95 , L87 , L94 , XBOOLE_0:3;
end;
suppose L97: D22 in ( SortsWithConstants R1 );

reconsider D24 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at D22 ) , (the carrier of R1) ] ) ) as set;
take D24;
take D22;
thus L98: D22 = C20;
thus L99:now
L100: ( InputVertices R1 ) misses ( SortsWithConstants R1 ) by MSAFREE2:4;
assume L101: C20 in ( InputVertices R1 );
thus L102: D24 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . D22 ) , D22 ] ) ) by L101 , L97 , L100 , XBOOLE_0:3;
end;
thus L103: (C20 in ( SortsWithConstants R1 ) implies D24 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at D22 ) , (the carrier of R1) ] ) ));
L104: ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) misses ( SortsWithConstants R1 ) by XBOOLE_1:79;
assume L105: C20 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );
thus L106: thesis by L105 , L97 , L104 , XBOOLE_0:3;
end;
suppose L107: D22 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );

reconsider D25 = ( id ( FreeGen (D22 , (the Sorts of C18)) ) ) as set;
take D25;
take D22;
thus L108: D22 = C20;
thus L109:now
L110: (( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) c= ( InnerVertices R1 ) & ( InputVertices R1 ) misses ( InnerVertices R1 )) by XBOOLE_1:36 , XBOOLE_1:79;
assume L111: C20 in ( InputVertices R1 );
thus L112: D25 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . D22 ) , D22 ] ) ) by L111 , L107 , L110 , XBOOLE_0:3;
end;
thus L113:now
L114: ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) misses ( SortsWithConstants R1 ) by XBOOLE_1:79;
assume L115: C20 in ( SortsWithConstants R1 );
thus L116: D25 = ( ( FreeGen (D22 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at D22 ) , (the carrier of R1) ] ) ) by L115 , L107 , L114 , XBOOLE_0:3;
end;
assume L117: C20 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );
thus L118: thesis;
end;
end;

end;
consider C21 being (ManySortedSet of (the carrier of R1)) such that L87: (for B20 being set holds (B20 in (the carrier of R1) implies S1[ B20 , ( C21 . B20 ) ])) from PBOOLE:sch 3(L81);
L88:
now
let C22 being set;
L89: ( ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) \/ ( SortsWithConstants R1 ) ) = ( InnerVertices R1 ) by MSAFREE2:3 , XBOOLE_1:45;
assume L90: C22 in (the carrier of R1);
reconsider D26 = C22 as (Vertex of R1) by L90;
L91: D26 in ( ( InputVertices R1 ) \/ ( InnerVertices R1 ) ) by L90 , XBOOLE_1:45;
L92: (D26 in ( InputVertices R1 ) or D26 in ( InnerVertices R1 )) by L91 , XBOOLE_0:def 3;
L93: ( FreeGen (D26 , (the Sorts of C18)) ) = ( ( FreeGen (the Sorts of C18) ) . D26 ) by MSAFREE:def 16;
L94: ( FreeEnv C18 ) = MSAlgebra (# ( FreeSort (the Sorts of C18) ) , ( FreeOper (the Sorts of C18) ) #) by MSAFREE:def 14;
per cases  by L89 , L92 , XBOOLE_0:def 3;
suppose L95: D26 in ( InputVertices R1 );

L96: ( C19 . D26 ) in ( (the Sorts of C18) . D26 ) by L95 , MSAFREE2:def 5;
L97: ( root-tree [ ( C19 . D26 ) , D26 ] ) in ( FreeGen (D26 , (the Sorts of C18)) ) by L96 , MSAFREE:def 15;
L98: S1[ D26 , ( C21 . D26 ) ] by L87;
thus L99: ( C21 . C22 ) is (Function of ( ( FreeGen (the Sorts of C18) ) . C22 ) , ( (the Sorts of ( FreeEnv C18 )) . C22 )) by L98 , L93 , L94 , L95 , L97 , FUNCOP_1:45;
end;
suppose L100: D26 in ( SortsWithConstants R1 );

reconsider D27 = ( Sym (( action_at D26 ) , (the Sorts of C18)) ) as (NonTerminal of ( DTConMSA (the Sorts of C18) ));
set D28 = ( <*> ( TS ( DTConMSA (the Sorts of C18) ) ) );
set D29 = ( root-tree [ ( action_at D26 ) , (the carrier of R1) ] );
L101: ( SortsWithConstants R1 ) c= ( InnerVertices R1 ) by MSAFREE2:3;
L102: D26 in { B21 where B21 is (SortSymbol of R1) : B21 is  with_const_op } by L100 , MSAFREE2:def 1;
L103: (ex B22 being (SortSymbol of R1) st (D26 = B22 & B22 is  with_const_op)) by L102;
consider C23 being (OperSymbol of R1) such that L104: ( (the Arity of R1) . C23 ) = ( {} ) and L105: ( (the ResultSort of R1) . C23 ) = D26 by L103 , MSUALG_2:def 1;
L106: (for B23 being Nat holds (B23 in ( dom D28 ) implies ( D28 . B23 ) in ( FreeSort ((the Sorts of C18) , (( ( the_arity_of C23 ) /. B23 ) qua (SortSymbol of R1))) )));
L107: D28 = ( the_arity_of C23 ) by L104 , MSUALG_1:def 1;
L108: D28 in ( ( ( ( FreeSort (the Sorts of C18) ) # ) * (the Arity of R1) ) . C23 ) by L107 , L106 , MSAFREE:9;
L109: ( the_result_sort_of C23 ) = D26 by L105 , MSUALG_1:def 2;
L110: C23 = ( action_at D26 ) by L109 , L100 , L101 , MSAFREE2:def 7;
L111: D27 ==> ( roots D28 ) by L110 , L108 , MSAFREE:10;
L112: (( {} ) = ( <*> ( R1 -Terms (the Sorts of C18) ) ) & D28 is (SubtreeSeq of ( Sym (( action_at D26 ) , (the Sorts of C18)) ))) by L111 , DTCONSTR:def 6;
L113: (D29 = ( [ ( action_at D26 ) , (the carrier of R1) ] -tree ( {} ) ) & ( {} ) is (ArgumentSeq of D27)) by L112 , MSATERM:def 2 , TREES_4:20;
L114: D29 in ( R1 -Terms (the Sorts of C18) ) by L113 , MSATERM:1;
reconsider D30 = D29 as (Element of ( TS ( DTConMSA (the Sorts of C18) ) )) by L114 , MSATERM:def 1;
L115: (( D30 . ( {} ) ) = [ ( action_at D26 ) , (the carrier of R1) ] & ( the_result_sort_of ( action_at D26 ) ) = D26) by L100 , L101 , MSAFREE2:def 7 , TREES_4:3;
L116: D30 in { B24 where B24 is (Element of ( TS ( DTConMSA (the Sorts of C18) ) )) : ((ex B25 being set st (B25 in ( (the Sorts of C18) . D26 ) & B24 = ( root-tree [ B25 , D26 ] ))) or (ex B26 being (OperSymbol of R1) st ([ B26 , (the carrier of R1) ] = ( B24 . ( {} ) ) & ( the_result_sort_of B26 ) = D26))) } by L115;
L117: D30 in ( FreeSort ((the Sorts of C18) , D26) ) by L116 , MSAFREE:def 10;
L118: D30 in ( (the Sorts of ( FreeEnv C18 )) . D26 ) by L117 , L94 , MSAFREE:def 11;
L119: S1[ D26 , ( C21 . D26 ) ] by L87;
thus L120: ( C21 . C22 ) is (Function of ( ( FreeGen (the Sorts of C18) ) . C22 ) , ( (the Sorts of ( FreeEnv C18 )) . C22 )) by L119 , L93 , L100 , L118 , FUNCOP_1:45;
end;
suppose L121: D26 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );

L122: (( dom ( id ( FreeGen (D26 , (the Sorts of C18)) ) ) ) = ( FreeGen (D26 , (the Sorts of C18)) ) & ( rng ( id ( FreeGen (D26 , (the Sorts of C18)) ) ) ) = ( FreeGen (D26 , (the Sorts of C18)) ));
L123: S1[ D26 , ( C21 . D26 ) ] by L87;
thus L124: ( C21 . C22 ) is (Function of ( ( FreeGen (the Sorts of C18) ) . C22 ) , ( (the Sorts of ( FreeEnv C18 )) . C22 )) by L123 , L93 , L94 , L121 , L122 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
L126:
now
let C24 being set;
assume L127: C24 in ( dom C21 );
L128: C24 in (the carrier of R1) by L127 , PARTFUN1:def 2;
thus L129: ( C21 . C24 ) is Function by L128 , L88;
end;
reconsider D31 = C21 as (ManySortedFunction of (the carrier of R1)) by L126 , FUNCOP_1:def 6;
reconsider D32 = D31 as (ManySortedFunction of ( FreeGen (the Sorts of C18) ) , (the Sorts of ( FreeEnv C18 ))) by L88 , PBOOLE:def 15;
take D32;
let C25 being (Vertex of R1);
thus L130:now
assume L131: C25 in ( InputVertices R1 );
L132: S1[ C25 , ( D32 . C25 ) ] by L87;
thus L133: ( D32 . C25 ) = ( ( FreeGen (C25 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . C25 ) , C25 ] ) ) by L132 , L131;
end;
thus L134:now
assume L135: C25 in ( SortsWithConstants R1 );
L136: S1[ C25 , ( D32 . C25 ) ] by L87;
thus L137: ( D32 . C25 ) = ( ( FreeGen (C25 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at C25 ) , (the carrier of R1) ] ) ) by L136 , L135;
end;
assume L138: C25 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );
L139: S1[ C25 , ( D32 . C25 ) ] by L87;
thus L140: thesis by L139 , L138;
end;
uniqueness
proof
let C26 , C27 being (ManySortedFunction of ( FreeGen (the Sorts of C18) ) , (the Sorts of ( FreeEnv C18 )));
assume that
L141: (for B27 being (Vertex of R1) holds ((B27 in ( InputVertices R1 ) implies ( C26 . B27 ) = ( ( FreeGen (B27 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . B27 ) , B27 ] ) )) & (B27 in ( SortsWithConstants R1 ) implies ( C26 . B27 ) = ( ( FreeGen (B27 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at B27 ) , (the carrier of R1) ] ) )) & (B27 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) implies ( C26 . B27 ) = ( id ( FreeGen (B27 , (the Sorts of C18)) ) ))))
and
L142: (for B28 being (Vertex of R1) holds ((B28 in ( InputVertices R1 ) implies ( C27 . B28 ) = ( ( FreeGen (B28 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . B28 ) , B28 ] ) )) & (B28 in ( SortsWithConstants R1 ) implies ( C27 . B28 ) = ( ( FreeGen (B28 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at B28 ) , (the carrier of R1) ] ) )) & (B28 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) implies ( C27 . B28 ) = ( id ( FreeGen (B28 , (the Sorts of C18)) ) ))));
L143:
now
let C28 being set;
L144: ( ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) \/ ( SortsWithConstants R1 ) ) = ( InnerVertices R1 ) by MSAFREE2:3 , XBOOLE_1:45;
assume L145: C28 in (the carrier of R1);
reconsider D33 = C28 as (Vertex of R1) by L145;
L146: D33 in ( ( InputVertices R1 ) \/ ( InnerVertices R1 ) ) by L145 , XBOOLE_1:45;
L147: (D33 in ( InputVertices R1 ) or D33 in ( InnerVertices R1 )) by L146 , XBOOLE_0:def 3;
per cases  by L144 , L147 , XBOOLE_0:def 3;
suppose L148: D33 in ( InputVertices R1 );

L149: ( C26 . D33 ) = ( ( FreeGen (D33 , (the Sorts of C18)) ) --> ( root-tree [ ( C19 . D33 ) , D33 ] ) ) by L148 , L141;
thus L150: ( C26 . C28 ) = ( C27 . C28 ) by L149 , L142 , L148;
end;
suppose L151: D33 in ( SortsWithConstants R1 );

L152: ( C26 . D33 ) = ( ( FreeGen (D33 , (the Sorts of C18)) ) --> ( root-tree [ ( action_at D33 ) , (the carrier of R1) ] ) ) by L151 , L141;
thus L153: ( C26 . C28 ) = ( C27 . C28 ) by L152 , L142 , L151;
end;
suppose L154: D33 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) );

L155: ( C26 . D33 ) = ( id ( FreeGen (D33 , (the Sorts of C18)) ) ) by L154 , L141;
thus L156: ( C26 . C28 ) = ( C27 . C28 ) by L155 , L142 , L154;
end;
end;
thus L158: C26 = C27 by L143 , PBOOLE:3;
end;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C29 being  non-empty (Circuit of R1);
let C30 being (InputValues of C29);
func Fix_inp_ext C30 -> (ManySortedFunction of ( FreeEnv C29 ) , ( FreeEnv C29 )) means 
:L160: (it is_homomorphism ( FreeEnv C29 ) , ( FreeEnv C29 ) & ( Fix_inp C30 ) c= it);
existence
proof
reconsider D34 = ( FreeGen (the Sorts of C29) ) as  free (GeneratorSet of ( FreeEnv C29 )) by MSAFREE:16;
consider C31 being (ManySortedFunction of ( FreeEnv C29 ) , ( FreeEnv C29 )) such that L161: C31 is_homomorphism ( FreeEnv C29 ) , ( FreeEnv C29 ) and L162: ( C31 || D34 ) = ( Fix_inp C30 ) by MSAFREE:def 5;
take C31;
thus L163: C31 is_homomorphism ( FreeEnv C29 ) , ( FreeEnv C29 ) by L161;
let C32 being set;
assume L164: C32 in (the carrier of R1);
reconsider D35 = ( C31 . C32 ) as (Function of ( (the Sorts of ( FreeEnv C29 )) . C32 ) , ( (the Sorts of ( FreeEnv C29 )) . C32 )) by L164 , PBOOLE:def 15;
L165: ( ( Fix_inp C30 ) . C32 ) = ( D35 | ( D34 . C32 ) ) by L162 , L164 , MSAFREE:def 1;
thus L166: thesis by L165 , RELAT_1:59;
end;
uniqueness
proof
let C33 , C34 being (ManySortedFunction of ( FreeEnv C29 ) , ( FreeEnv C29 ));
assume that
L167: C33 is_homomorphism ( FreeEnv C29 ) , ( FreeEnv C29 )
and
L168: ( Fix_inp C30 ) c= C33
and
L169: C34 is_homomorphism ( FreeEnv C29 ) , ( FreeEnv C29 )
and
L170: ( Fix_inp C30 ) c= C34;
reconsider D36 = C33 , D37 = C34 as (ManySortedFunction of ( FreeMSA (the Sorts of C29) ) , ( FreeMSA (the Sorts of C29) ));
L171:
now
let C35 being set;
assume that
L172: C35 in (the carrier of R1);
reconsider D38 = ( D37 . C35 ) as (Function of ( (the Sorts of ( FreeMSA (the Sorts of C29) )) . C35 ) , ( (the Sorts of ( FreeMSA (the Sorts of C29) )) . C35 )) by L172 , PBOOLE:def 15;
L173: ( ( Fix_inp C30 ) . C35 ) c= D38 by L170 , L172 , PBOOLE:def 2;
reconsider D39 = ( ( Fix_inp C30 ) . C35 ) as Function;
L174: D39 is (Function of ( ( FreeGen (the Sorts of C29) ) . C35 ) , ( (the Sorts of ( FreeMSA (the Sorts of C29) )) . C35 )) by L172 , PBOOLE:def 15;
L175: ( dom D39 ) = ( ( FreeGen (the Sorts of C29) ) . C35 ) by L174 , L172 , FUNCT_2:def 1;
let C36 being (Function of ( (the Sorts of ( FreeMSA (the Sorts of C29) )) . C35 ) , ( (the Sorts of ( FreeMSA (the Sorts of C29) )) . C35 ));
assume L176: C36 = ( D36 . C35 );
L177: ( ( Fix_inp C30 ) . C35 ) c= C36 by L176 , L168 , L172 , PBOOLE:def 2;
thus L178: ( ( D37 || ( FreeGen (the Sorts of C29) ) ) . C35 ) = ( D38 | ( ( FreeGen (the Sorts of C29) ) . C35 ) ) by L172 , MSAFREE:def 1
.= ( ( Fix_inp C30 ) . C35 ) by L175 , L173 , GRFUNC_1:23
.= ( C36 | ( ( FreeGen (the Sorts of C29) ) . C35 ) ) by L175 , L177 , GRFUNC_1:23;
end;
L179: ( D36 || ( FreeGen (the Sorts of C29) ) ) = ( D37 || ( FreeGen (the Sorts of C29) ) ) by L171 , MSAFREE:def 1;
thus L180: C33 = C34 by L179 , L167 , L169 , EXTENS_1:14;
end;
end;
theorem
L182: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B29 being  non-empty (Circuit of R1) holds (for B30 being (InputValues of B29) holds (for B31 being (Vertex of R1) holds (for B32 being (Element of ( (the Sorts of ( FreeEnv B29 )) . B31 )) holds (for B33 being set holds ((B31 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) & B32 = ( root-tree [ B33 , B31 ] )) implies ( ( ( Fix_inp_ext B30 ) . B31 ) . B32 ) = B32)))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C37 being  non-empty (Circuit of R1);
let C38 being (InputValues of C37);
let C39 being (Vertex of R1);
let C40 being (Element of ( (the Sorts of ( FreeEnv C37 )) . C39 ));
let C41 being set;
assume that
L183: C39 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) )
and
L184: C40 = ( root-tree [ C41 , C39 ] );
L185: ( C40 . ( {} ) ) = [ C41 , C39 ] by L184 , TREES_4:3;
L186:
now
given C42 being (OperSymbol of R1) such that
L187: [ C42 , (the carrier of R1) ] = ( C40 . ( {} ) )
and
L188: ( the_result_sort_of C42 ) = C39;

L189: C39 = (the carrier of R1) by L185 , L187 , XTUPLE_0:1;
thus L190: contradiction by L189 , L1;
end;
set D40 = (the Sorts of C37);
L191: ( FreeEnv C37 ) = MSAlgebra (# ( FreeSort (the Sorts of C37) ) , ( FreeOper (the Sorts of C37) ) #) by MSAFREE:def 14;
L192: C40 in ( ( FreeSort D40 ) . C39 ) by L191;
L193: C40 in ( FreeSort (D40 , C39) ) by L192 , MSAFREE:def 11;
L194: ( Fix_inp C38 ) c= ( Fix_inp_ext C38 ) by L160;
L195: ( ( Fix_inp C38 ) . C39 ) c= ( ( Fix_inp_ext C38 ) . C39 ) by L194 , PBOOLE:def 2;
L196: ( FreeSort (D40 , C39) ) = { B34 where B34 is (Element of ( TS ( DTConMSA D40 ) )) : ((ex B35 being set st (B35 in ( D40 . C39 ) & B34 = ( root-tree [ B35 , C39 ] ))) or (ex B36 being (OperSymbol of R1) st ([ B36 , (the carrier of R1) ] = ( B34 . ( {} ) ) & ( the_result_sort_of B36 ) = C39))) } by MSAFREE:def 10;
L197: (ex B37 being (Element of ( TS ( DTConMSA D40 ) )) st (B37 = C40 & ((ex B38 being set st (B38 in ( D40 . C39 ) & B37 = ( root-tree [ B38 , C39 ] ))) or (ex B39 being (OperSymbol of R1) st ([ B39 , (the carrier of R1) ] = ( B37 . ( {} ) ) & ( the_result_sort_of B39 ) = C39))))) by L196 , L193;
L198: C40 in ( FreeGen (C39 , (the Sorts of C37)) ) by L197 , L186 , MSAFREE:def 15;
L199: C40 in ( ( FreeGen (the Sorts of C37) ) . C39 ) by L198 , MSAFREE:def 16;
L200: C40 in ( dom ( ( Fix_inp C38 ) . C39 ) ) by L199 , FUNCT_2:def 1;
thus L201: ( ( ( Fix_inp_ext C38 ) . C39 ) . C40 ) = ( ( ( Fix_inp C38 ) . C39 ) . C40 ) by L200 , L195 , GRFUNC_1:2
.= ( ( id ( FreeGen (C39 , (the Sorts of C37)) ) ) . C40 ) by L183 , L80
.= C40 by L198 , FUNCT_1:17;
end;
theorem
L202: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B40 being  non-empty (Circuit of R1) holds (for B41 being (InputValues of B40) holds (for B42 being (Vertex of R1) holds (for B43 being (Element of ( (the Sorts of B40) . B42 )) holds (B42 in ( InputVertices R1 ) implies ( ( ( Fix_inp_ext B41 ) . B42 ) . ( root-tree [ B43 , B42 ] ) ) = ( root-tree [ ( B41 . B42 ) , B42 ] )))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C43 being  non-empty (Circuit of R1);
let C44 being (InputValues of C43);
let C45 being (Vertex of R1);
let C46 being (Element of ( (the Sorts of C43) . C45 ));
set D41 = ( root-tree [ C46 , C45 ] );
assume L203: C45 in ( InputVertices R1 );
L204: D41 in ( FreeGen (C45 , (the Sorts of C43)) ) by MSAFREE:def 15;
L205: ( Fix_inp C44 ) c= ( Fix_inp_ext C44 ) by L160;
L206: ( ( Fix_inp C44 ) . C45 ) c= ( ( Fix_inp_ext C44 ) . C45 ) by L205 , PBOOLE:def 2;
L207: ( FreeEnv C43 ) = MSAlgebra (# ( FreeSort (the Sorts of C43) ) , ( FreeOper (the Sorts of C43) ) #) by MSAFREE:def 14;
reconsider D42 = D41 as (Element of ( (the Sorts of ( FreeEnv C43 )) . C45 )) by L207 , L204;
L208: D42 in ( ( FreeGen (the Sorts of C43) ) . C45 ) by L204 , MSAFREE:def 16;
L209: D42 in ( dom ( ( Fix_inp C44 ) . C45 ) ) by L208 , FUNCT_2:def 1;
thus L210: ( ( ( Fix_inp_ext C44 ) . C45 ) . ( root-tree [ C46 , C45 ] ) ) = ( ( ( Fix_inp C44 ) . C45 ) . D42 ) by L209 , L206 , GRFUNC_1:2
.= ( ( ( FreeGen (C45 , (the Sorts of C43)) ) --> ( root-tree [ ( C44 . C45 ) , C45 ] ) ) . D42 ) by L203 , L80
.= ( root-tree [ ( C44 . C45 ) , C45 ] ) by L204 , FUNCOP_1:7;
end;
theorem
L211: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B44 being  non-empty (Circuit of R1) holds (for B45 being (InputValues of B44) holds (for B46 being (Vertex of R1) holds (for B47 being (Element of ( (the Sorts of ( FreeEnv B44 )) . B46 )) holds (for B48 , B49 being  DTree-yielding FinSequence holds ((B46 in ( InnerVertices R1 ) & B47 = ( [ ( action_at B46 ) , (the carrier of R1) ] -tree B48 ) & ( dom B48 ) = ( dom B49 ) & (for B50 being (Element of ( NAT )) holds (B50 in ( dom B48 ) implies ( B49 . B50 ) = ( ( ( Fix_inp_ext B45 ) . ( ( the_arity_of ( action_at B46 ) ) /. B50 ) ) . ( B48 . B50 ) )))) implies ( ( ( Fix_inp_ext B45 ) . B46 ) . B47 ) = ( [ ( action_at B46 ) , (the carrier of R1) ] -tree B49 ))))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C47 being  non-empty (Circuit of R1);
let C48 being (InputValues of C47);
let C49 being (Vertex of R1);
let C50 being (Element of ( (the Sorts of ( FreeEnv C47 )) . C49 ));
let C51 , C52 being  DTree-yielding FinSequence;
assume that
L212: C49 in ( InnerVertices R1 )
and
L213: C50 = ( [ ( action_at C49 ) , (the carrier of R1) ] -tree C51 )
and
L214: ( dom C51 ) = ( dom C52 )
and
L215: (for B51 being (Element of ( NAT )) holds (B51 in ( dom C51 ) implies ( C52 . B51 ) = ( ( ( Fix_inp_ext C48 ) . ( ( the_arity_of ( action_at C49 ) ) /. B51 ) ) . ( C51 . B51 ) )));
set D43 = ( action_at C49 );
L216: ( the_result_sort_of D43 ) = C49 by L212 , MSAFREE2:def 7;
L217: ( len C51 ) = ( len ( the_arity_of D43 ) ) by L216 , L213 , MSAFREE2:10;
L218:
now
let C53 being Nat;
assume L219: C53 in ( dom C52 );
L220: C53 in ( dom ( the_arity_of D43 ) ) by L219 , L214 , L217 , FINSEQ_3:29;
L221: ( C51 . C53 ) in ( (the Sorts of ( FreeEnv C47 )) . ( ( the_arity_of D43 ) . C53 ) ) by L220 , L213 , L216 , MSAFREE2:11;
L222: ( C51 . C53 ) in ( (the Sorts of ( FreeEnv C47 )) . ( ( the_arity_of D43 ) /. C53 ) ) by L221 , L220 , PARTFUN1:def 6;
L223: ( C52 . C53 ) = ( ( ( Fix_inp_ext C48 ) . ( ( the_arity_of D43 ) /. C53 ) ) . ( C51 . C53 ) ) by L214 , L215 , L219;
thus L224: ( C52 . C53 ) in ( (the Sorts of ( FreeEnv C47 )) . ( ( the_arity_of D43 ) /. C53 ) ) by L223 , L222 , FUNCT_2:5;
end;
L225:
now
let C54 being Nat;
assume L226: C54 in ( dom C51 );
L227: C54 in ( dom ( the_arity_of D43 ) ) by L226 , L217 , FINSEQ_3:29;
L228: ( C51 . C54 ) in ( (the Sorts of ( FreeEnv C47 )) . ( ( the_arity_of D43 ) . C54 ) ) by L227 , L213 , L216 , MSAFREE2:11;
thus L229: ( C51 . C54 ) in ( (the Sorts of ( FreeEnv C47 )) . ( ( the_arity_of D43 ) /. C54 ) ) by L228 , L227 , PARTFUN1:def 6;
end;
reconsider D44 = C51 as (Element of ( Args (D43 , ( FreeEnv C47 )) )) by L225 , L217 , MSAFREE2:5;
L230: ( FreeEnv C47 ) = MSAlgebra (# ( FreeSort (the Sorts of C47) ) , ( FreeOper (the Sorts of C47) ) #) by MSAFREE:def 14;
L231: ( Args (D43 , ( FreeEnv C47 )) ) = ( ( ( ( FreeSort (the Sorts of C47) ) # ) * (the Arity of R1) ) . D43 ) by L230 , MSUALG_1:def 4;
reconsider D45 = C51 as (FinSequence of ( TS ( DTConMSA (the Sorts of C47) ) )) by L231 , L217 , L225 , MSAFREE:8 , MSAFREE2:5;
L232: C51 in ( Args (D43 , ( FreeEnv C47 )) ) by L217 , L225 , MSAFREE2:5;
L233: ( Sym (D43 , (the Sorts of C47)) ) ==> ( roots D45 ) by L232 , L231 , MSAFREE:10;
L234: ( len C52 ) = ( len ( the_arity_of D43 ) ) by L214 , L217 , FINSEQ_3:29;
reconsider D46 = C52 as (Element of ( Args (D43 , ( FreeEnv C47 )) )) by L234 , L218 , MSAFREE2:5;
L235: ( Fix_inp_ext C48 ) is_homomorphism ( FreeEnv C47 ) , ( FreeEnv C47 ) by L160;
reconsider D47 = C52 as (FinSequence of ( TS ( DTConMSA (the Sorts of C47) ) )) by L231 , L234 , L218 , MSAFREE:8 , MSAFREE2:5;
L236: C52 in ( Args (D43 , ( FreeEnv C47 )) ) by L234 , L218 , MSAFREE2:5;
L237: ( Sym (D43 , (the Sorts of C47)) ) ==> ( roots D47 ) by L236 , L231 , MSAFREE:10;
L238: (for B52 being Nat holds (B52 in ( dom C51 ) implies ( C52 . B52 ) = ( ( ( Fix_inp_ext C48 ) . ( ( the_arity_of ( action_at C49 ) ) /. B52 ) ) . ( C51 . B52 ) ))) by L215;
L239: D46 = ( ( Fix_inp_ext C48 ) # D44 ) by L238 , MSUALG_3:def 6;
L240: C50 = ( ( Sym (( action_at C49 ) , (the Sorts of C47)) ) -tree D45 ) by L213 , MSAFREE:def 9
.= ( ( DenOp (( action_at C49 ) , (the Sorts of C47)) ) . D44 ) by L233 , MSAFREE:def 12
.= ( ( (the Charact of ( FreeEnv C47 )) . D43 ) . D44 ) by L230 , MSAFREE:def 13
.= ( ( Den (( action_at C49 ) , ( FreeEnv C47 )) ) . D44 ) by MSUALG_1:def 6;
thus L241: ( ( ( Fix_inp_ext C48 ) . C49 ) . C50 ) = ( ( Den (( action_at C49 ) , ( FreeEnv C47 )) ) . C52 ) by L240 , L216 , L239 , L235 , MSUALG_3:def 7
.= ( ( ( FreeOper (the Sorts of C47) ) . D43 ) . C52 ) by L230 , MSUALG_1:def 6
.= ( ( DenOp (( action_at C49 ) , (the Sorts of C47)) ) . C52 ) by MSAFREE:def 13
.= ( ( Sym (( action_at C49 ) , (the Sorts of C47)) ) -tree D47 ) by L237 , MSAFREE:def 12
.= ( [ ( action_at C49 ) , (the carrier of R1) ] -tree C52 ) by MSAFREE:def 9;
end;
theorem
L242: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B53 being  non-empty (Circuit of R1) holds (for B54 being (InputValues of B53) holds (for B55 being (Vertex of R1) holds (for B56 being (Element of ( (the Sorts of ( FreeEnv B53 )) . B55 )) holds (B55 in ( SortsWithConstants R1 ) implies ( ( ( Fix_inp_ext B54 ) . B55 ) . B56 ) = ( root-tree [ ( action_at B55 ) , (the carrier of R1) ] )))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C55 being  non-empty (Circuit of R1);
let C56 being (InputValues of C55);
let C57 being (Vertex of R1);
let C58 being (Element of ( (the Sorts of ( FreeEnv C55 )) . C57 ));
set D48 = (the Sorts of C55);
assume L243: C57 in ( SortsWithConstants R1 );
L244: ( FreeEnv C55 ) = MSAlgebra (# ( FreeSort (the Sorts of C55) ) , ( FreeOper (the Sorts of C55) ) #) by MSAFREE:def 14;
L245: C58 in ( ( FreeSort (the Sorts of C55) ) . C57 ) by L244;
L246: C58 in ( FreeSort ((the Sorts of C55) , C57) ) by L245 , MSAFREE:def 11;
L247: C58 in { B57 where B57 is (Element of ( TS ( DTConMSA D48 ) )) : ((ex B58 being set st (B58 in ( D48 . C57 ) & B57 = ( root-tree [ B58 , C57 ] ))) or (ex B59 being (OperSymbol of R1) st ([ B59 , (the carrier of R1) ] = ( B57 . ( {} ) ) & ( the_result_sort_of B59 ) = C57))) } by L246 , MSAFREE:def 10;
L248: (ex B60 being (Element of ( TS ( DTConMSA D48 ) )) st (C58 = B60 & ((ex B61 being set st (B61 in ( D48 . C57 ) & B60 = ( root-tree [ B61 , C57 ] ))) or (ex B62 being (OperSymbol of R1) st ([ B62 , (the carrier of R1) ] = ( B60 . ( {} ) ) & ( the_result_sort_of B62 ) = C57))))) by L247;
per cases  by L248;
suppose L249: (ex B63 being set st (B63 in ( D48 . C57 ) & C58 = ( root-tree [ B63 , C57 ] )));

L250: ( Fix_inp C56 ) c= ( Fix_inp_ext C56 ) by L160;
L251: ( ( Fix_inp C56 ) . C57 ) c= ( ( Fix_inp_ext C56 ) . C57 ) by L250 , PBOOLE:def 2;
L252: C58 in ( FreeGen (C57 , (the Sorts of C55)) ) by L249 , MSAFREE:def 15;
L253: C58 in ( ( FreeGen (the Sorts of C55) ) . C57 ) by L252 , MSAFREE:def 16;
L254: C58 in ( dom ( ( Fix_inp C56 ) . C57 ) ) by L253 , FUNCT_2:def 1;
thus L255: ( ( ( Fix_inp_ext C56 ) . C57 ) . C58 ) = ( ( ( Fix_inp C56 ) . C57 ) . C58 ) by L254 , L251 , GRFUNC_1:2
.= ( ( ( FreeGen (C57 , (the Sorts of C55)) ) --> ( root-tree [ ( action_at C57 ) , (the carrier of R1) ] ) ) . C58 ) by L243 , L80
.= ( root-tree [ ( action_at C57 ) , (the carrier of R1) ] ) by L252 , FUNCOP_1:7;
end;
suppose L256: (ex B64 being (OperSymbol of R1) st ([ B64 , (the carrier of R1) ] = ( C58 . ( {} ) ) & ( the_result_sort_of B64 ) = C57));

consider C59 being (OperSymbol of R1) such that L257: [ C59 , (the carrier of R1) ] = ( C58 . ( {} ) ) and L258: ( the_result_sort_of C59 ) = C57 by L256;
L259: ( SortsWithConstants R1 ) c= ( InnerVertices R1 ) by MSAFREE2:3;
L260: C59 = ( action_at C57 ) by L259 , L243 , L258 , MSAFREE2:def 7;
consider C60 being  DTree-yielding FinSequence such that L261: C58 = ( [ ( action_at C57 ) , (the carrier of R1) ] -tree C60 ) by L260 , L257 , CIRCUIT1:9;
L262: C57 in { B65 where B65 is (SortSymbol of R1) : B65 is  with_const_op } by L243 , MSAFREE2:def 1;
L263: (ex B66 being (SortSymbol of R1) st (C57 = B66 & B66 is  with_const_op)) by L262;
consider C61 being (OperSymbol of R1) such that L264: ( (the Arity of R1) . C61 ) = ( {} ) and L265: ( (the ResultSort of R1) . C61 ) = C57 by L263 , MSUALG_2:def 1;
L266: ( Fix_inp_ext C56 ) is_homomorphism ( FreeEnv C55 ) , ( FreeEnv C55 ) by L160;
L267: ( the_result_sort_of C61 ) = C57 by L265 , MSUALG_1:def 2;
L268: C61 = ( action_at C57 ) by L267 , L243 , L259 , MSAFREE2:def 7;
L269: ( action_at C57 ) in (the carrier' of R1);
L270: ( action_at C57 ) in ( dom (the Arity of R1) ) by L269 , FUNCT_2:def 1;
L271: ( Args (( action_at C57 ) , ( FreeEnv C55 )) ) = ( ( ( (the Sorts of ( FreeEnv C55 )) # ) * (the Arity of R1) ) . ( action_at C57 ) ) by MSUALG_1:def 4
.= ( ( (the Sorts of ( FreeEnv C55 )) # ) . ( <*> (the carrier of R1) ) ) by L264 , L268 , L270 , FUNCT_1:13
.= { ( {} ) } by PRE_CIRC:2;
reconsider D49 = ( {} ) as (Element of ( Args (( action_at C57 ) , ( FreeEnv C55 )) )) by L271 , TARSKI:def 1;
L272: D49 = ( ( Fix_inp_ext C56 ) # D49 ) by L271 , TARSKI:def 1;
L273: ( Args (( action_at C57 ) , ( FreeEnv C55 )) ) = ( ( ( ( FreeSort (the Sorts of C55) ) # ) * (the Arity of R1) ) . C61 ) by L244 , L268 , MSUALG_1:def 4;
reconsider D50 = D49 as (FinSequence of ( TS ( DTConMSA (the Sorts of C55) ) )) by L273 , MSAFREE:8;
L274: ( Sym (( action_at C57 ) , (the Sorts of C55)) ) ==> ( roots D50 ) by L268 , L273 , MSAFREE:10;
L275: ( the_result_sort_of ( action_at C57 ) ) = C57 by L243 , L259 , MSAFREE2:def 7;
L276: ( len C60 ) = ( len ( the_arity_of ( action_at C57 ) ) ) by L275 , L261 , MSAFREE2:10
.= ( len ( {} ) ) by L264 , L268 , MSUALG_1:def 1
.= ( 0 );
L277: C60 = ( {} ) by L276;
L278: C58 = ( root-tree [ ( action_at C57 ) , (the carrier of R1) ] ) by L277 , L261 , TREES_4:20;
L279: ( ( Den (( action_at C57 ) , ( FreeEnv C55 )) ) . D49 ) = ( ( ( FreeOper (the Sorts of C55) ) . ( action_at C57 ) ) . D49 ) by L244 , MSUALG_1:def 6
.= ( ( DenOp (( action_at C57 ) , (the Sorts of C55)) ) . D49 ) by MSAFREE:def 13
.= ( ( Sym (( action_at C57 ) , (the Sorts of C55)) ) -tree D50 ) by L274 , MSAFREE:def 12
.= ( [ ( action_at C57 ) , (the carrier of R1) ] -tree D50 ) by MSAFREE:def 9
.= ( root-tree [ ( action_at C57 ) , (the carrier of R1) ] ) by TREES_4:20;
thus L280: thesis by L279 , L275 , L272 , L266 , L278 , MSUALG_3:def 7;
end;
end;
theorem
L282: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B67 being  non-empty (Circuit of R1) holds (for B68 being (InputValues of B67) holds (for B69 being (Vertex of R1) holds (for B70 , B71 being (Element of ( (the Sorts of ( FreeEnv B67 )) . B69 )) holds (for B72 , B73 being DecoratedTree holds ((B72 = B70 & B73 = B71 & B71 = ( ( ( Fix_inp_ext B68 ) . B69 ) . B70 )) implies ( dom B72 ) = ( dom B73 ))))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C62 being  non-empty (Circuit of R1);
let C63 being (InputValues of C62);
let C64 being (Vertex of R1);
let C65 , C66 being (Element of ( (the Sorts of ( FreeEnv C62 )) . C64 ));
let C67 , C68 being DecoratedTree;
set D51 = (the Sorts of C62);
set D52 = (the Sorts of ( FreeEnv C62 ));
defpred S2[ (Element of ( NAT )) ] means (for B74 being (Vertex of R1) holds (for B75 , B76 being (Element of ( D52 . B74 )) holds (for B77 , B78 being DecoratedTree holds ((B77 = B75 & B78 = B76 & ( depth (B74 , C62) ) <= $1 & B76 = ( ( ( Fix_inp_ext C63 ) . B74 ) . B75 )) implies ( dom B77 ) = ( dom B78 )))));
reconsider D53 = ( depth (C64 , C62) ) as (Element of ( NAT )) by ORDINAL1:def 12;
L283: ( depth (C64 , C62) ) <= D53;
L284: ( FreeMSA D51 ) = MSAlgebra (# ( FreeSort D51 ) , ( FreeOper D51 ) #) by MSAFREE:def 14;
L285: (for B79 being (Element of ( NAT )) holds (S2[ B79 ] implies S2[ ( B79 + 1 ) ]))
proof
L286: ( ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) \/ ( SortsWithConstants R1 ) ) = ( InnerVertices R1 ) by MSAFREE2:3 , XBOOLE_1:45;
let C69 being (Element of ( NAT ));
assume L287: S2[ C69 ];
let C70 being (Vertex of R1);
let C71 , C72 being (Element of ( D52 . C70 ));
let C73 , C74 being DecoratedTree;
assume that
L288: C73 = C71
and
L289: C74 = C72
and
L290: ( depth (C70 , C62) ) <= ( C69 + 1 )
and
L291: C72 = ( ( ( Fix_inp_ext C63 ) . C70 ) . C71 );
L292: ( FreeSort (D51 , C70) ) = { B80 where B80 is (Element of ( TS ( DTConMSA D51 ) )) : ((ex B81 being set st (B81 in ( D51 . C70 ) & B80 = ( root-tree [ B81 , C70 ] ))) or (ex B82 being (OperSymbol of R1) st ([ B82 , (the carrier of R1) ] = ( B80 . ( {} ) ) & ( the_result_sort_of B82 ) = C70))) } by MSAFREE:def 10;
L293: ( ( InputVertices R1 ) \/ ( InnerVertices R1 ) ) = (the carrier of R1) by XBOOLE_1:45;
L294: (C70 in ( InputVertices R1 ) or C70 in ( InnerVertices R1 )) by L293 , XBOOLE_0:def 3;
L295: (C71 in ( D52 . C70 ) & ( ( FreeSort D51 ) . C70 ) = ( FreeSort (D51 , C70) )) by MSAFREE:def 11;
consider C75 being (Element of ( TS ( DTConMSA D51 ) )) such that L296: C75 = C71 and L297: ((ex B83 being set st (B83 in ( D51 . C70 ) & C75 = ( root-tree [ B83 , C70 ] ))) or (ex B84 being (OperSymbol of R1) st ([ B84 , (the carrier of R1) ] = ( C75 . ( {} ) ) & ( the_result_sort_of B84 ) = C70))) by L295 , L284 , L292;
per cases  by L297 , L294 , L286 , XBOOLE_0:def 3;
suppose L298: C70 in ( InputVertices R1 );

L299: ( ( ( Fix_inp_ext C63 ) . C70 ) . C75 ) = ( root-tree [ ( C63 . C70 ) , C70 ] ) by L298 , L297 , L202 , MSAFREE2:2;
thus L300: ( dom C73 ) = { ( {} ) } by L288 , L296 , L297 , L298 , MSAFREE2:2 , TREES_1:29 , TREES_4:3
.= ( dom C74 ) by L289 , L291 , L296 , L299 , TREES_1:29 , TREES_4:3;
end;
suppose L301: (C70 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) & (ex B85 being set st (B85 in ( D51 . C70 ) & C75 = ( root-tree [ B85 , C70 ] ))));

thus L302: thesis by L301 , L288 , L289 , L291 , L296 , L182;
end;
suppose that L303: C70 in ( SortsWithConstants R1 )
and
L304: (ex B86 being set st (B86 in ( D51 . C70 ) & C75 = ( root-tree [ B86 , C70 ] )));
L305: ( ( ( Fix_inp_ext C63 ) . C70 ) . C75 ) = ( root-tree [ ( action_at C70 ) , (the carrier of R1) ] ) by L296 , L303 , L242;
thus L306: ( dom C73 ) = { ( {} ) } by L288 , L296 , L304 , TREES_1:29 , TREES_4:3
.= ( dom C74 ) by L289 , L291 , L296 , L305 , TREES_1:29 , TREES_4:3;
end;
suppose that L307: C70 in ( InnerVertices R1 )
and
L308: (ex B87 being (OperSymbol of R1) st ([ B87 , (the carrier of R1) ] = ( C75 . ( {} ) ) & ( the_result_sort_of B87 ) = C70));
consider C76 being (OperSymbol of R1) such that L309: [ C76 , (the carrier of R1) ] = ( C75 . ( {} ) ) and L310: ( the_result_sort_of C76 ) = C70 by L308;
L311: C76 = ( action_at C70 ) by L307 , L310 , MSAFREE2:def 7;
consider C77 being  DTree-yielding FinSequence such that L312: C71 = ( [ ( action_at C70 ) , (the carrier of R1) ] -tree C77 ) by L311 , L296 , L309 , CIRCUIT1:9;
deffunc H1(Nat) = ( ( ( Fix_inp_ext C63 ) . ( ( the_arity_of ( action_at C70 ) ) /. $1 ) ) . ( C77 . $1 ) );
consider C78 being FinSequence such that L313: ( len C78 ) = ( len C77 ) and L314: (for B88 being Nat holds (B88 in ( dom C78 ) implies ( C78 . B88 ) = H1(B88))) from FINSEQ_1:sch 2;
L315: ( dom C77 ) = ( dom C78 ) by L313 , FINSEQ_3:29;
L316: ( len C77 ) = ( len ( the_arity_of ( action_at C70 ) ) ) by L310 , L311 , L312 , MSAFREE2:10;
L317: ( dom C77 ) = ( dom ( the_arity_of ( action_at C70 ) ) ) by L316 , FINSEQ_3:29;
L318:
now
let C79 being set;
assume L319: C79 in ( dom C78 );
reconsider D54 = C79 as (Element of ( NAT )) by L319;
set D55 = ( ( the_arity_of ( action_at C70 ) ) /. D54 );
L320: D55 = ( ( the_arity_of C76 ) . D54 ) by L311 , L317 , L315 , L319 , PARTFUN1:def 6;
reconsider D56 = ( C77 . D54 ) as (Element of ( D52 . D55 )) by L320 , L310 , L311 , L312 , L317 , L315 , L319 , MSAFREE2:11;
reconsider D57 = ( ( Fix_inp_ext C63 ) . D55 ) as (Function of ( D52 . D55 ) , ( D52 . D55 ));
L321: ( C78 . D54 ) = ( D57 . D56 ) by L314 , L319;
thus L322: ( C78 . C79 ) is DecoratedTree by L321;
end;
L323: (for B89 being (Element of ( NAT )) holds (B89 in ( dom C78 ) implies ( C78 . B89 ) = H1(B89))) by L314;
reconsider D58 = C78 as  DTree-yielding FinSequence by L318 , TREES_3:24;
L324: ( ( ( Fix_inp_ext C63 ) . C70 ) . C71 ) = ( [ ( action_at C70 ) , (the carrier of R1) ] -tree D58 ) by L307 , L312 , L323 , L315 , L211;
L325: ( dom ( doms C77 ) ) = ( dom C77 ) by TREES_3:37;
L326:
now
let C80 being Nat;
set D59 = ( ( the_arity_of ( action_at C70 ) ) /. C80 );
reconsider D60 = ( ( Fix_inp_ext C63 ) . D59 ) as (Function of ( D52 . D59 ) , ( D52 . D59 ));
assume L327: C80 in ( dom ( doms C77 ) );
L328: D59 = ( ( the_arity_of C76 ) . C80 ) by L327 , L311 , L317 , L325 , PARTFUN1:def 6;
reconsider D61 = ( C77 . C80 ) as (Element of ( D52 . D59 )) by L328 , L310 , L311 , L312 , L317 , L325 , L327 , MSAFREE2:11;
L329: ( D58 . C80 ) = ( D60 . D61 ) by L314 , L325 , L315 , L327;
reconsider D62 = ( D58 . C80 ) as (Element of ( D52 . D59 )) by L329;
L330: D59 in ( rng ( the_arity_of ( action_at C70 ) ) ) by L317 , L325 , L327 , PARTFUN2:2;
L331: ( depth (D59 , C62) ) < ( C69 + 1 ) by L330 , L290 , L307 , CIRCUIT1:19 , XXREAL_0:2;
L332: ( depth (D59 , C62) ) <= C69 by L331 , NAT_1:13;
L333: ( D58 . C80 ) = ( ( ( Fix_inp_ext C63 ) . D59 ) . ( C77 . C80 ) ) by L314 , L325 , L315 , L327;
L334: ( dom D61 ) = ( dom D62 ) by L333 , L287 , L332;
thus L335: ( ( doms C77 ) . C80 ) = ( dom D62 ) by L334 , L325 , L327 , FUNCT_6:22
.= ( ( doms D58 ) . C80 ) by L325 , L315 , L327 , FUNCT_6:22;
end;
L336: ( dom D58 ) = ( dom ( doms D58 ) ) by TREES_3:37;
L337: ( doms C77 ) = ( doms D58 ) by L336 , L315 , L326 , FINSEQ_1:13 , TREES_3:37;
thus L338: ( dom C73 ) = ( tree ( doms D58 ) ) by L337 , L288 , L312 , TREES_4:10
.= ( dom C74 ) by L289 , L291 , L324 , TREES_4:10;
end;
end;
L340: S2[ ( 0 ) ]
proof
let C81 being (Vertex of R1);
let C82 , C83 being (Element of ( D52 . C81 ));
let C84 , C85 being DecoratedTree;
assume that
L341: C84 = C82
and
L342: C85 = C83
and
L343: ( depth (C81 , C62) ) <= ( 0 )
and
L344: C83 = ( ( ( Fix_inp_ext C63 ) . C81 ) . C82 );
L345: ( depth (C81 , C62) ) = ( 0 ) by L343 , NAT_1:3;
L346: ( FreeSort (D51 , C81) ) = { B90 where B90 is (Element of ( TS ( DTConMSA D51 ) )) : ((ex B91 being set st (B91 in ( D51 . C81 ) & B90 = ( root-tree [ B91 , C81 ] ))) or (ex B92 being (OperSymbol of R1) st ([ B92 , (the carrier of R1) ] = ( B90 . ( {} ) ) & ( the_result_sort_of B92 ) = C81))) } by MSAFREE:def 10;
L347: (C82 in ( D52 . C81 ) & ( ( FreeSort D51 ) . C81 ) = ( FreeSort (D51 , C81) )) by MSAFREE:def 11;
consider C86 being (Element of ( TS ( DTConMSA D51 ) )) such that L348: C86 = C82 and L349: ((ex B93 being set st (B93 in ( D51 . C81 ) & C86 = ( root-tree [ B93 , C81 ] ))) or (ex B94 being (OperSymbol of R1) st ([ B94 , (the carrier of R1) ] = ( C86 . ( {} ) ) & ( the_result_sort_of B94 ) = C81))) by L347 , L284 , L346;
per cases  by L345 , L349 , CIRCUIT1:18;
suppose L350: C81 in ( InputVertices R1 );

L351: ( ( ( Fix_inp_ext C63 ) . C81 ) . C86 ) = ( root-tree [ ( C63 . C81 ) , C81 ] ) by L350 , L349 , L202 , MSAFREE2:2;
thus L352: ( dom C84 ) = { ( {} ) } by L341 , L348 , L349 , L350 , MSAFREE2:2 , TREES_1:29 , TREES_4:3
.= ( dom C85 ) by L342 , L344 , L348 , L351 , TREES_1:29 , TREES_4:3;
end;
suppose that L353: C81 in ( SortsWithConstants R1 )
and
L354: (ex B95 being set st (B95 in ( D51 . C81 ) & C86 = ( root-tree [ B95 , C81 ] )));
L355: ( ( ( Fix_inp_ext C63 ) . C81 ) . C86 ) = ( root-tree [ ( action_at C81 ) , (the carrier of R1) ] ) by L348 , L353 , L242;
thus L356: ( dom C84 ) = { ( {} ) } by L341 , L348 , L354 , TREES_1:29 , TREES_4:3
.= ( dom C85 ) by L342 , L344 , L348 , L355 , TREES_1:29 , TREES_4:3;
end;
suppose that L357: C81 in ( SortsWithConstants R1 )
and
L358: (ex B96 being (OperSymbol of R1) st ([ B96 , (the carrier of R1) ] = ( C86 . ( {} ) ) & ( the_result_sort_of B96 ) = C81));
L359: ( ( ( Fix_inp_ext C63 ) . C81 ) . C86 ) = ( root-tree [ ( action_at C81 ) , (the carrier of R1) ] ) by L348 , L357 , L242;
consider C87 being (OperSymbol of R1) such that L360: [ C87 , (the carrier of R1) ] = ( C86 . ( {} ) ) and L361: ( the_result_sort_of C87 ) = C81 by L358;
L362: ( SortsWithConstants R1 ) c= ( InnerVertices R1 ) by MSAFREE2:3;
L363: C87 = ( action_at C81 ) by L362 , L357 , L361 , MSAFREE2:def 7;
consider C88 being  DTree-yielding FinSequence such that L364: C86 = ( [ ( action_at C81 ) , (the carrier of R1) ] -tree C88 ) by L363 , L348 , L360 , CIRCUIT1:9;
L365: C81 in { B97 where B97 is (SortSymbol of R1) : B97 is  with_const_op } by L357 , MSAFREE2:def 1;
L366: (ex B98 being (SortSymbol of R1) st (C81 = B98 & B98 is  with_const_op)) by L365;
consider C89 being (OperSymbol of R1) such that L367: ( (the Arity of R1) . C89 ) = ( {} ) and L368: ( (the ResultSort of R1) . C89 ) = C81 by L366 , MSUALG_2:def 1;
L369: ( the_result_sort_of C89 ) = C81 by L368 , MSUALG_1:def 2;
L370: C89 = ( action_at C81 ) by L369 , L357 , L362 , MSAFREE2:def 7;
L371: ( len C88 ) = ( len ( the_arity_of C89 ) ) by L370 , L348 , L369 , L364 , MSAFREE2:10
.= ( len ( {} ) ) by L367 , MSUALG_1:def 1
.= ( 0 );
L372: C88 = ( {} ) by L371;
L373: C86 = ( root-tree [ C89 , (the carrier of R1) ] ) by L372 , L370 , L364 , TREES_4:20;
thus L374: ( dom C84 ) = { ( {} ) } by L373 , L341 , L348 , TREES_1:29 , TREES_4:3
.= ( dom C85 ) by L342 , L344 , L348 , L359 , TREES_1:29 , TREES_4:3;
end;
end;
L376: (for B99 being (Element of ( NAT )) holds S2[ B99 ]) from NAT_1:sch 1(L340 , L285);
thus L377: thesis by L376 , L283;
end;
theorem
L378: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B100 being  non-empty (Circuit of R1) holds (for B101 being (InputValues of B100) holds (for B102 being (Vertex of R1) holds (for B103 , B104 being (Element of ( (the Sorts of ( FreeEnv B100 )) . B102 )) holds (B104 = ( ( ( Fix_inp_ext B101 ) . B102 ) . B103 ) implies ( card B103 ) = ( card B104 )))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C90 being  non-empty (Circuit of R1);
let C91 being (InputValues of C90);
let C92 being (Vertex of R1);
let C93 , C94 being (Element of ( (the Sorts of ( FreeEnv C90 )) . C92 ));
assume L379: C94 = ( ( ( Fix_inp_ext C91 ) . C92 ) . C93 );
L380: ( dom C93 ) = ( dom C94 ) by L379 , L282;
thus L381: ( card C93 ) = ( card ( dom C94 ) ) by L380 , CARD_1:62
.= ( card C94 ) by CARD_1:62;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C95 being  non-empty (Circuit of R1);
let C96 being (Vertex of R1);
let C97 being (InputValues of C95);
func IGTree (C96 , C97) -> (Element of ( (the Sorts of ( FreeEnv C95 )) . C96 )) means 
:L382: (ex B105 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C96 )) st (( card B105 ) = ( size (C96 , C95) ) & it = ( ( ( Fix_inp_ext C97 ) . C96 ) . B105 )));
existence
proof
reconsider D63 = ( (the Sorts of ( FreeEnv C95 )) . C96 ) as non  empty set;
consider C98 being  finite non  empty (Subset of ( NAT )) such that L383: C98 = { ( card B106 ) where B106 is (Element of ( (the Sorts of ( FreeEnv C95 )) . C96 )) : (not contradiction) } and L384: ( size (C96 , C95) ) = ( max C98 ) by CIRCUIT1:def 4;
L385: ( size (C96 , C95) ) in C98 by L384 , XXREAL_2:def 8;
consider C99 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C96 )) such that L386: ( size (C96 , C95) ) = ( card C99 ) by L385 , L383;
reconsider D64 = ( ( Fix_inp_ext C97 ) . C96 ) as (Function of D63 , D63);
reconsider D65 = C99 as (Element of D63);
reconsider D66 = ( D64 . D65 ) as (Element of D63);
reconsider D67 = D66 as (Element of ( (the Sorts of ( FreeEnv C95 )) . C96 ));
take D67;
take C99;
thus L387: ( card C99 ) = ( size (C96 , C95) ) by L386;
thus L388: thesis;
end;
uniqueness
proof
defpred S3[ Nat ] means (ex B107 being (Vertex of R1) st (ex B108 , B109 being (Element of ( (the Sorts of ( FreeEnv C95 )) . B107 )) st (( size (B107 , C95) ) = $1 & (ex B110 being (Element of ( (the Sorts of ( FreeEnv C95 )) . B107 )) st (( card B110 ) = ( size (B107 , C95) ) & B108 = ( ( ( Fix_inp_ext C97 ) . B107 ) . B110 ))) & (ex B111 being (Element of ( (the Sorts of ( FreeEnv C95 )) . B107 )) st (( card B111 ) = ( size (B107 , C95) ) & B109 = ( ( ( Fix_inp_ext C97 ) . B107 ) . B111 ))) & B108 <> B109)));
let C100 , C101 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C96 ));
L389:
now
assume L390: (ex B112 being Nat st S3[ B112 ]);
consider C102 being Nat such that L391: S3[ C102 ] and L392: (for B113 being Nat holds (S3[ B113 ] implies C102 <= B113)) from NAT_1:sch 5(L390);
consider C103 being (Vertex of R1), C104 , C105 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C103 )) such that L393: ( size (C103 , C95) ) = C102 and L394: (ex B114 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C103 )) st (( card B114 ) = ( size (C103 , C95) ) & C104 = ( ( ( Fix_inp_ext C97 ) . C103 ) . B114 ))) and L395: (ex B115 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C103 )) st (( card B115 ) = ( size (C103 , C95) ) & C105 = ( ( ( Fix_inp_ext C97 ) . C103 ) . B115 ))) and L396: C104 <> C105 by L391;
consider C106 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C103 )) such that L397: ( card C106 ) = ( size (C103 , C95) ) and L398: C105 = ( ( ( Fix_inp_ext C97 ) . C103 ) . C106 ) by L395;
consider C107 being (Element of ( (the Sorts of ( FreeEnv C95 )) . C103 )) such that L399: ( card C107 ) = ( size (C103 , C95) ) and L400: C104 = ( ( ( Fix_inp_ext C97 ) . C103 ) . C107 ) by L394;
per cases ;
suppose L401: C103 in ( InputVertices R1 );

L402: (ex B116 being (Element of ( (the Sorts of C95) . C103 )) st C106 = ( root-tree [ B116 , C103 ] )) by L401 , MSAFREE2:9;
L403: (ex B117 being (Element of ( (the Sorts of C95) . C103 )) st C107 = ( root-tree [ B117 , C103 ] )) by L401 , MSAFREE2:9;
L404: C104 = ( root-tree [ ( C97 . C103 ) , C103 ] ) by L403 , L400 , L401 , L202
.= C105 by L398 , L401 , L402 , L202;
thus L405: contradiction by L404 , L396;
end;
suppose L406: C103 in ( SortsWithConstants R1 );

L407: C104 = ( root-tree [ ( action_at C103 ) , (the carrier of R1) ] ) by L406 , L400 , L242
.= C105 by L398 , L406 , L242;
thus L408: contradiction by L407 , L396;
end;
suppose that L409: (not C103 in ( InputVertices R1 ))
and
L410: (not C103 in ( SortsWithConstants R1 ));
set D68 = ( ( Fix_inp_ext C97 ) * ( the_arity_of ( action_at C103 ) ) );
L411: ( ( InputVertices R1 ) \/ ( InnerVertices R1 ) ) = (the carrier of R1) by XBOOLE_1:45;
L412: C103 in ( InnerVertices R1 ) by L411 , L409 , XBOOLE_0:def 3;
L413: C103 in ( ( InnerVertices R1 ) \ ( SortsWithConstants R1 ) ) by L412 , L410 , XBOOLE_0:def 5;
consider C108 being  DTree-yielding FinSequence such that L414: C107 = ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C108 ) by L413 , L399 , CIRCUIT1:12;
consider C109 being  DTree-yielding FinSequence such that L415: C106 = ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C109 ) by L397 , L413 , CIRCUIT1:12;
L416: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C109 ) in ( (the Sorts of ( FreeEnv C95 )) . C103 ) by L415;
L417: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C109 ) in ( (the Sorts of ( FreeEnv C95 )) . ( the_result_sort_of ( action_at C103 ) ) ) by L416 , L412 , MSAFREE2:def 7;
L418: ( Fix_inp_ext C97 ) is_homomorphism ( FreeEnv C95 ) , ( FreeEnv C95 ) by L160;
consider C110 being  DTree-yielding FinSequence such that L419: C110 = ( D68 .. C108 ) and L420: C104 = ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C110 ) by L418 , L400 , L412 , L414 , L2;
consider C111 being  DTree-yielding FinSequence such that L421: C111 = ( D68 .. C109 ) and L422: C105 = ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C111 ) by L398 , L412 , L415 , L418 , L2;
L423: ( dom C110 ) = ( dom D68 ) by L419 , PRALG_1:def 17;
L424: ( dom C111 ) = ( dom D68 ) by L421 , PRALG_1:def 17;
L425: ( len C110 ) = ( len C111 ) by L424 , L423 , FINSEQ_3:29;
consider C112 being Nat such that L426: C112 in ( dom C110 ) and L427: ( C110 . C112 ) <> ( C111 . C112 ) by L425 , L396 , L420 , L422 , FINSEQ_2:9;
L428: ( rng ( the_arity_of ( action_at C103 ) ) ) c= (the carrier of R1) by FINSEQ_1:def 4;
L429: ( rng ( the_arity_of ( action_at C103 ) ) ) c= ( dom ( Fix_inp_ext C97 ) ) by L428 , PARTFUN1:def 2;
L430: ( dom ( the_arity_of ( action_at C103 ) ) ) = ( dom D68 ) by L429 , RELAT_1:27;
reconsider D69 = ( ( the_arity_of ( action_at C103 ) ) . C112 ) as (Vertex of R1) by L430 , L423 , L426 , FINSEQ_2:11;
L431: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C108 ) in ( (the Sorts of ( FreeEnv C95 )) . C103 ) by L414;
L432: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C108 ) in ( (the Sorts of ( FreeEnv C95 )) . ( the_result_sort_of ( action_at C103 ) ) ) by L431 , L412 , MSAFREE2:def 7;
reconsider D70 = ( C108 . C112 ) , D71 = ( C109 . C112 ) as (Element of ( (the Sorts of ( FreeEnv C95 )) . D69 )) by L432 , L423 , L430 , L426 , L417 , MSAFREE2:11;
L433: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C111 ) in ( (the Sorts of ( FreeEnv C95 )) . C103 ) by L422;
L434: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C111 ) in ( (the Sorts of ( FreeEnv C95 )) . ( the_result_sort_of ( action_at C103 ) ) ) by L433 , L412 , MSAFREE2:def 7;
L435: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C110 ) in ( (the Sorts of ( FreeEnv C95 )) . C103 ) by L420;
L436: ( [ ( action_at C103 ) , (the carrier of R1) ] -tree C110 ) in ( (the Sorts of ( FreeEnv C95 )) . ( the_result_sort_of ( action_at C103 ) ) ) by L435 , L412 , MSAFREE2:def 7;
reconsider D72 = ( C110 . C112 ) , D73 = ( C111 . C112 ) as (Element of ( (the Sorts of ( FreeEnv C95 )) . D69 )) by L436 , L423 , L430 , L426 , L434 , MSAFREE2:11;
reconsider D74 = ( D68 . C112 ) as Function;
L437: D74 = ( ( Fix_inp_ext C97 ) . ( ( the_arity_of ( action_at C103 ) ) . C112 ) ) by L423 , L426 , FUNCT_1:12;
L438: D73 = ( ( ( Fix_inp_ext C97 ) . D69 ) . D71 ) by L437 , L421 , L423 , L426 , PRALG_1:def 17;
L439: ( len C109 ) = ( len ( the_arity_of ( action_at C103 ) ) ) by L417 , MSAFREE2:10;
L440: C112 in ( dom C109 ) by L439 , L423 , L430 , L426 , FINSEQ_3:29;
L441: D71 in ( rng C109 ) by L440 , FUNCT_1:def 3;
L442: ( card D71 ) = ( size (D69 , C95) ) by L441 , L397 , L413 , L415 , CIRCUIT1:11;
L443: ( len C108 ) = ( len ( the_arity_of ( action_at C103 ) ) ) by L432 , MSAFREE2:10;
L444: C112 in ( dom C108 ) by L443 , L423 , L430 , L426 , FINSEQ_3:29;
L445: D70 in ( rng C108 ) by L444 , FUNCT_1:def 3;
L446: ( card D70 ) = ( size (D69 , C95) ) by L445 , L399 , L413 , L414 , CIRCUIT1:11;
L447: D69 in ( rng ( the_arity_of ( action_at C103 ) ) ) by L423 , L430 , L426 , FUNCT_1:def 3;
L448: D72 = ( ( ( Fix_inp_ext C97 ) . D69 ) . D70 ) by L419 , L423 , L426 , L437 , PRALG_1:def 17;
thus L449: contradiction by L448 , L392 , L393 , L412 , L427 , L446 , L442 , L438 , L447 , CIRCUIT1:14;
end;
end;
thus L451: thesis by L389;
end;
end;
theorem
L453: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B118 being  non-empty (Circuit of R1) holds (for B119 being (Vertex of R1) holds (for B120 being (InputValues of B118) holds ( IGTree (B119 , B120) ) = ( ( ( Fix_inp_ext B120 ) . B119 ) . ( IGTree (B119 , B120) ) )))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C113 being  non-empty (Circuit of R1);
let C114 being (Vertex of R1);
let C115 being (InputValues of C113);
reconsider D75 = ( IGTree (C114 , C115) ) as (Element of ( (the Sorts of ( FreeEnv C113 )) . C114 ));
L454: (ex B121 being (Element of ( (the Sorts of ( FreeEnv C113 )) . C114 )) st (( card B121 ) = ( size (C114 , C113) ) & ( IGTree (C114 , C115) ) = ( ( ( Fix_inp_ext C115 ) . C114 ) . B121 ))) by L382;
L455: ( card D75 ) = ( size (C114 , C113) ) by L454 , L378;
thus L456: thesis by L455 , L382;
end;
theorem
L457: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B122 being  non-empty (Circuit of R1) holds (for B123 being (Vertex of R1) holds (for B124 being (InputValues of B122) holds (for B125 being  DTree-yielding FinSequence holds ((B123 in ( InnerVertices R1 ) & ( dom B125 ) = ( dom ( the_arity_of ( action_at B123 ) ) ) & (for B126 being (Element of ( NAT )) holds (B126 in ( dom B125 ) implies ( B125 . B126 ) = ( IGTree (( ( the_arity_of ( action_at B123 ) ) /. B126 ) , B124) )))) implies ( IGTree (B123 , B124) ) = ( [ ( action_at B123 ) , (the carrier of R1) ] -tree B125 )))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C116 being  non-empty (Circuit of R1);
let C117 being (Vertex of R1);
let C118 being (InputValues of C116);
let C119 being  DTree-yielding FinSequence;
assume that
L458: C117 in ( InnerVertices R1 )
and
L459: ( dom C119 ) = ( dom ( the_arity_of ( action_at C117 ) ) )
and
L460: (for B127 being (Element of ( NAT )) holds (B127 in ( dom C119 ) implies ( C119 . B127 ) = ( IGTree (( ( the_arity_of ( action_at C117 ) ) /. B127 ) , C118) )));
set D76 = ( FreeEnv C116 );
set D77 = ( action_at C117 );
L461:
now
let C120 being Nat;
assume L462: C120 in ( dom C119 );
L463: ( C119 . C120 ) = ( IGTree (( ( the_arity_of D77 ) /. C120 ) , C118) ) by L462 , L460;
thus L464: ( C119 . C120 ) in ( (the Sorts of D76) . ( ( the_arity_of D77 ) /. C120 ) ) by L463;
end;
L465: ( len C119 ) = ( len ( the_arity_of D77 ) ) by L459 , FINSEQ_3:29;
reconsider D78 = C119 as (Element of ( Args (D77 , D76) )) by L465 , L461 , MSAFREE2:5;
set D79 = (the Sorts of C116);
L466: ( dom (the ResultSort of R1) ) = (the carrier' of R1) by FUNCT_2:def 1;
L467: ( Result (D77 , D76) ) = ( ( (the Sorts of D76) * (the ResultSort of R1) ) . D77 ) by MSUALG_1:def 5
.= ( (the Sorts of D76) . ( (the ResultSort of R1) . D77 ) ) by L466 , FUNCT_1:13;
L468: (D76 = MSAlgebra (# ( FreeSort D79 ) , ( FreeOper D79 ) #) & ( Args (D77 , D76) ) = ( ( ( (the Sorts of D76) # ) * (the Arity of R1) ) . D77 )) by MSAFREE:def 14 , MSUALG_1:def 4;
reconsider D80 = D78 as (FinSequence of ( TS ( DTConMSA D79 ) )) by L468 , MSAFREE:8;
L469: D76 = MSAlgebra (# ( FreeSort D79 ) , ( FreeOper D79 ) #) by MSAFREE:def 14;
L470: ( Den (D77 , D76) ) = ( ( FreeOper D79 ) . D77 ) by L469 , MSUALG_1:def 6
.= ( DenOp (D77 , D79) ) by MSAFREE:def 13;
L471: ( Sym (D77 , D79) ) ==> ( roots D80 ) by L468 , MSAFREE:10;
L472: ( ( Den (D77 , D76) ) . C119 ) = ( ( Sym (D77 , D79) ) -tree D80 ) by L471 , L470 , MSAFREE:def 12
.= ( [ D77 , (the carrier of R1) ] -tree D80 ) by MSAFREE:def 9;
L473: ( (the ResultSort of R1) . D77 ) = ( the_result_sort_of D77 ) by MSUALG_1:def 2
.= C117 by L458 , MSAFREE2:def 7;
reconsider D81 = ( [ ( action_at C117 ) , (the carrier of R1) ] -tree C119 ) as (Element of ( (the Sorts of ( FreeMSA D79 )) . C117 )) by L473 , L472 , L467 , FUNCT_2:5;
L474:
now
let C121 being (Element of ( NAT ));
set D82 = ( ( the_arity_of ( action_at C117 ) ) /. C121 );
assume L475: C121 in ( dom C119 );
L476: ( C119 . C121 ) = ( IGTree (D82 , C118) ) by L475 , L460;
reconsider D83 = ( C119 . C121 ) as (Element of ( (the Sorts of ( FreeEnv C116 )) . D82 )) by L476;
take D84 = D83;
thus L477: D84 = ( C119 . C121 );
L478: (ex B128 being (Element of ( (the Sorts of ( FreeMSA D79 )) . D82 )) st (( card B128 ) = ( size (D82 , C116) ) & D84 = ( ( ( Fix_inp_ext C118 ) . D82 ) . B128 ))) by L476 , L382;
thus L479: ( card D84 ) = ( size (D82 , C116) ) by L478 , L378;
end;
L480: ( card D81 ) = ( size (C117 , C116) ) by L474 , L458 , CIRCUIT1:16;
L481:
now
let C122 being (Element of ( NAT ));
assume L482: C122 in ( dom C119 );
L483: ( C119 . C122 ) = ( IGTree (( ( the_arity_of ( action_at C117 ) ) /. C122 ) , C118) ) by L482 , L460;
thus L484: ( C119 . C122 ) = ( ( ( Fix_inp_ext C118 ) . ( ( the_arity_of ( action_at C117 ) ) /. C122 ) ) . ( C119 . C122 ) ) by L483 , L453;
end;
L485: ( [ ( action_at C117 ) , (the carrier of R1) ] -tree C119 ) = ( ( ( Fix_inp_ext C118 ) . C117 ) . D81 ) by L481 , L458 , L211;
thus L486: thesis by L485 , L480 , L382;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C123 being  non-empty (Circuit of R1);
let C124 being (Vertex of R1);
let C125 being (InputValues of C123);
func IGValue (C124 , C125) -> (Element of ( (the Sorts of C123) . C124 )) equals 
( ( ( Eval C123 ) . C124 ) . ( IGTree (C124 , C125) ) );
coherence;
end;
theorem
L488: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B129 being  non-empty (Circuit of R1) holds (for B130 being (Vertex of R1) holds (for B131 being (InputValues of B129) holds (B130 in ( InputVertices R1 ) implies ( IGValue (B130 , B131) ) = ( B131 . B130 ))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C126 being  non-empty (Circuit of R1);
let C127 being (Vertex of R1);
let C128 being (InputValues of C126);
set D85 = (the Sorts of C126);
L489: (( ( FreeSort D85 ) . C127 ) = ( FreeSort (D85 , C127) ) & ( FreeSort (D85 , C127) ) = { B132 where B132 is (Element of ( TS ( DTConMSA D85 ) )) : ((ex B133 being set st (B133 in ( D85 . C127 ) & B132 = ( root-tree [ B133 , C127 ] ))) or (ex B134 being (OperSymbol of R1) st ([ B134 , (the carrier of R1) ] = ( B132 . ( {} ) ) & ( the_result_sort_of B134 ) = C127))) }) by MSAFREE:def 10 , MSAFREE:def 11;
assume L490: C127 in ( InputVertices R1 );
L491: ( C128 . C127 ) in ( (the Sorts of C126) . C127 ) by L490 , MSAFREE2:def 5;
L492: ( root-tree [ ( C128 . C127 ) , C127 ] ) in ( FreeGen (C127 , (the Sorts of C126)) ) by L491 , MSAFREE:def 15;
L493: ( root-tree [ ( C128 . C127 ) , C127 ] ) in ( ( FreeSort (the Sorts of C126) ) . C127 ) by L492;
L494: ( root-tree [ ( C128 . C127 ) , C127 ] ) in ( FreeSort ((the Sorts of C126) , C127) ) by L493 , MSAFREE:def 11;
consider C129 being (Element of ( (the Sorts of ( FreeEnv C126 )) . C127 )) such that L495: ( card C129 ) = ( size (C127 , C126) ) and L496: ( IGTree (C127 , C128) ) = ( ( ( Fix_inp_ext C128 ) . C127 ) . C129 ) by L382;
L497: (C129 in ( (the Sorts of ( FreeMSA D85 )) . C127 ) & ( FreeMSA D85 ) = MSAlgebra (# ( FreeSort D85 ) , ( FreeOper D85 ) #)) by MSAFREE:def 14;
L498: (ex B135 being (Element of ( TS ( DTConMSA D85 ) )) st (B135 = C129 & ((ex B136 being set st (B136 in ( D85 . C127 ) & B135 = ( root-tree [ B136 , C127 ] ))) or (ex B137 being (OperSymbol of R1) st ([ B137 , (the carrier of R1) ] = ( B135 . ( {} ) ) & ( the_result_sort_of B137 ) = C127))))) by L497 , L489;
L499: C129 in ( FreeGen (C127 , (the Sorts of C126)) ) by L498 , L490 , MSAFREE:def 15 , MSAFREE2:2;
L500: ( Fix_inp C128 ) c= ( Fix_inp_ext C128 ) by L160;
L501: ( ( Fix_inp C128 ) . C127 ) c= ( ( Fix_inp_ext C128 ) . C127 ) by L500 , PBOOLE:def 2;
L502: ( ( Fix_inp C128 ) . C127 ) = ( ( FreeGen (C127 , (the Sorts of C126)) ) --> ( root-tree [ ( C128 . C127 ) , C127 ] ) ) by L490 , L80;
L503: C129 in ( dom ( ( Fix_inp C128 ) . C127 ) ) by L502 , L499 , FUNCOP_1:13;
L504: ( ( ( Fix_inp C128 ) . C127 ) . C129 ) = ( ( ( Fix_inp_ext C128 ) . C127 ) . C129 ) by L503 , L501 , GRFUNC_1:2;
thus L505: ( IGValue (C127 , C128) ) = ( ( ( Eval C126 ) . C127 ) . ( root-tree [ ( C128 . C127 ) , C127 ] ) ) by L504 , L496 , L499 , L502 , FUNCOP_1:7
.= ( C128 . C127 ) by L491 , L494 , MSAFREE2:def 9;
end;
theorem
L506: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B138 being  non-empty (Circuit of R1) holds (for B139 being (Vertex of R1) holds (for B140 being (InputValues of B138) holds (B139 in ( SortsWithConstants R1 ) implies ( IGValue (B139 , B140) ) = ( ( Set-Constants B138 ) . B139 ))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
reconsider D86 = ( {} ) as  DTree-yielding FinSequence;
let C130 being  non-empty (Circuit of R1);
let C131 being (Vertex of R1);
let C132 being (InputValues of C130);
assume L507: C131 in ( SortsWithConstants R1 );
set D87 = ( ( ( Eval C130 ) . C131 ) . ( root-tree [ ( action_at C131 ) , (the carrier of R1) ] ) );
L508: ( {} ) = ( <*> (the carrier of R1) );
set D88 = (the Sorts of C130);
set D89 = ( Eval C130 );
L509: ( dom (the Arity of R1) ) = (the carrier' of R1) by FUNCT_2:def 1;
L510: ( dom (the ResultSort of R1) ) = (the carrier' of R1) by FUNCT_2:def 1;
set D90 = ( action_at C131 );
L511: ( SortsWithConstants R1 ) c= ( InnerVertices R1 ) by MSAFREE2:3;
L512: C131 = ( the_result_sort_of D90 ) by L511 , L507 , MSAFREE2:def 7;
L513: ( SortsWithConstants R1 ) = { B141 where B141 is (SortSymbol of R1) : B141 is  with_const_op } by MSAFREE2:def 1;
consider C133 being (SortSymbol of R1) such that L514: C133 = C131 and L515: C133 is  with_const_op by L513 , L507;
consider C134 being (OperSymbol of R1) such that L516: ( (the Arity of R1) . C134 ) = ( {} ) and L517: ( (the ResultSort of R1) . C134 ) = C133 by L515 , MSUALG_2:def 1;
L518: ( (the ResultSort of R1) . C134 ) = ( the_result_sort_of C134 ) by MSUALG_1:def 2;
L519: D90 = C134 by L518 , L507 , L511 , L514 , L517 , MSAFREE2:def 7;
L520: ( Args (D90 , ( FreeEnv C130 )) ) = ( ( ( (the Sorts of ( FreeEnv C130 )) # ) * (the Arity of R1) ) . D90 ) by MSUALG_1:def 4
.= ( ( (the Sorts of ( FreeEnv C130 )) # ) . ( (the Arity of R1) . D90 ) ) by L509 , FUNCT_1:13
.= { ( {} ) } by L516 , L519 , L508 , PRE_CIRC:2;
reconsider D91 = ( {} ) as (Element of ( Args (D90 , ( FreeEnv C130 )) )) by L520 , TARSKI:def 1;
reconsider D92 = ( D89 # D91 ) as (Element of ( Args (D90 , C130) ));
L521: D89 is_homomorphism ( FreeEnv C130 ) , C130 by MSAFREE2:def 9;
L522: ( ( D89 . ( the_result_sort_of D90 ) ) . ( ( Den (D90 , ( FreeEnv C130 )) ) . D91 ) ) = ( ( Den (D90 , C130) ) . D92 ) by L521 , MSUALG_3:def 7;
L523: ( FreeMSA D88 ) = MSAlgebra (# ( FreeSort D88 ) , ( FreeOper D88 ) #) by MSAFREE:def 14;
L524: ( Den (D90 , ( FreeEnv C130 )) ) = ( ( FreeOper D88 ) . D90 ) by L523 , MSUALG_1:def 6
.= ( DenOp (D90 , D88) ) by MSAFREE:def 13;
L525: ( {} ) in ( Args (D90 , ( FreeEnv C130 )) ) by L520 , TARSKI:def 1;
L526: D86 in ( ( ( ( FreeSort D88 ) # ) * (the Arity of R1) ) . D90 ) by L525 , L523 , MSUALG_1:def 4;
reconsider D93 = ( {} ) as (FinSequence of ( TS ( DTConMSA D88 ) )) by L526 , MSAFREE:8;
L527: ( Sym (D90 , D88) ) ==> ( roots D93 ) by L526 , MSAFREE:10;
L528: ( ( Den (D90 , ( FreeEnv C130 )) ) . ( {} ) ) = ( ( Sym (D90 , D88) ) -tree D86 ) by L527 , L524 , MSAFREE:def 12
.= ( [ D90 , (the carrier of R1) ] -tree ( {} ) ) by MSAFREE:def 9
.= ( root-tree [ D90 , (the carrier of R1) ] ) by TREES_4:20;
L529: ( dom ( Den (D90 , C130) ) ) = ( Args (D90 , C130) ) by FUNCT_2:def 1;
L530: D87 in ( rng ( Den (D90 , C130) ) ) by L529 , L512 , L528 , L522 , FUNCT_1:def 3;
L531: ( Result (D90 , C130) ) = ( ( (the Sorts of C130) * (the ResultSort of R1) ) . D90 ) by MSUALG_1:def 5
.= ( (the Sorts of C130) . ( (the ResultSort of R1) . D90 ) ) by L510 , FUNCT_1:13;
reconsider D94 = D87 as (Element of ( (the Sorts of C130) . C131 )) by L531 , L512 , L528 , L522 , MSUALG_1:def 2;
L532: (ex B142 being non  empty set st (B142 = ( (the Sorts of C130) . C131 ) & ( Constants (C130 , C131) ) = { B143 where B143 is (Element of B142) : (ex B144 being (OperSymbol of R1) st (( (the Arity of R1) . B144 ) = ( {} ) & ( (the ResultSort of R1) . B144 ) = C131 & B143 in ( rng ( Den (B144 , C130) ) ))) })) by MSUALG_2:def 3;
L533: D94 in ( Constants (C130 , C131) ) by L532 , L514 , L516 , L517 , L519 , L530;
L534: (ex B145 being (Element of ( (the Sorts of ( FreeEnv C130 )) . C131 )) st (( card B145 ) = ( size (C131 , C130) ) & ( IGTree (C131 , C132) ) = ( ( ( Fix_inp_ext C132 ) . C131 ) . B145 ))) by L382;
thus L535: ( IGValue (C131 , C132) ) = D94 by L534 , L507 , L242
.= ( ( Set-Constants C130 ) . C131 ) by L507 , L533 , CIRCUIT1:1;
end;
begin
definition
let C135 being  Circuit-like non  void non  empty ManySortedSign;
let C136 being  non-empty (Circuit of C135);
let C137 being (State of C136);
func Following C137 -> (State of C136) means 
:L536: (for B146 being (Vertex of C135) holds ((B146 in ( InputVertices C135 ) implies ( it . B146 ) = ( C137 . B146 )) & (B146 in ( InnerVertices C135 ) implies ( it . B146 ) = ( ( Den (( action_at B146 ) , C136) ) . ( ( action_at B146 ) depends_on_in C137 ) ))));
existence
proof
deffunc H2((Vertex of C135)) = ( ( Den (( action_at $1 ) , C136) ) . ( ( action_at $1 ) depends_on_in C137 ) );
deffunc H3(set) = ( C137 . $1 );
defpred S4[ set ] means $1 in ( InputVertices C135 );
consider C138 being (ManySortedSet of (the carrier of C135)) such that L537: (for B147 being (Vertex of C135) holds (B147 in (the carrier of C135) implies ((S4[ B147 ] implies ( C138 . B147 ) = H3(B147)) & ((not S4[ B147 ]) implies ( C138 . B147 ) = H2(B147))))) from PRE_CIRC:sch 2;
L538:
now
let C139 being set;
assume L539: C139 in ( dom (the Sorts of C136) );
reconsider D95 = C139 as (Vertex of C135) by L539 , PARTFUN1:def 2;
per cases ;
suppose L540: D95 in ( InputVertices C135 );

L541: ( C138 . D95 ) = ( C137 . D95 ) by L540 , L537;
thus L542: ( C138 . C139 ) in ( (the Sorts of C136) . C139 ) by L541 , CIRCUIT1:4;
end;
suppose L543: (not D95 in ( InputVertices C135 ));

L544: D95 in (the carrier of C135);
L545: D95 in ( ( InputVertices C135 ) \/ ( InnerVertices C135 ) ) by L544 , XBOOLE_1:45;
L546: D95 in ( InnerVertices C135 ) by L545 , L543 , XBOOLE_0:def 3;
L547: ( the_result_sort_of ( action_at D95 ) ) = D95 by L546 , MSAFREE2:def 7;
L548: ( C138 . C139 ) = ( ( Den (( action_at D95 ) , C136) ) . ( ( action_at D95 ) depends_on_in C137 ) ) by L537 , L543;
thus L549: ( C138 . C139 ) in ( (the Sorts of C136) . C139 ) by L548 , L547 , CIRCUIT1:8;
end;
end;
L551: (( dom C138 ) = (the carrier of C135) & ( dom (the Sorts of C136) ) = (the carrier of C135)) by PARTFUN1:def 2;
reconsider D96 = C138 as (State of C136) by L551 , L538 , CARD_3:def 5;
take D96;
let C140 being (Vertex of C135);
thus L552: (C140 in ( InputVertices C135 ) implies ( D96 . C140 ) = ( C137 . C140 )) by L537;
L553: ( InputVertices C135 ) misses ( InnerVertices C135 ) by XBOOLE_1:79;
assume L554: C140 in ( InnerVertices C135 );
L555: (not C140 in ( InputVertices C135 )) by L554 , L553 , XBOOLE_0:3;
thus L556: thesis by L555 , L537;
end;
uniqueness
proof
let C141 , C142 being (State of C136);
assume that
L557: (for B148 being (Vertex of C135) holds ((B148 in ( InputVertices C135 ) implies ( C141 . B148 ) = ( C137 . B148 )) & (B148 in ( InnerVertices C135 ) implies ( C141 . B148 ) = ( ( Den (( action_at B148 ) , C136) ) . ( ( action_at B148 ) depends_on_in C137 ) ))))
and
L558: (for B149 being (Vertex of C135) holds ((B149 in ( InputVertices C135 ) implies ( C142 . B149 ) = ( C137 . B149 )) & (B149 in ( InnerVertices C135 ) implies ( C142 . B149 ) = ( ( Den (( action_at B149 ) , C136) ) . ( ( action_at B149 ) depends_on_in C137 ) ))));
assume L559: C141 <> C142;
L560: ( dom C142 ) = (the carrier of C135) by CIRCUIT1:3;
consider C143 being set such that L561: C143 in ( dom C141 ) and L562: ( C141 . C143 ) <> ( C142 . C143 ) by L560 , L559 , CIRCUIT1:3 , FUNCT_1:2;
reconsider D97 = C143 as (Vertex of C135) by L561 , CIRCUIT1:3;
L563: (D97 in ( InnerVertices C135 ) implies ( C141 . D97 ) = ( ( Den (( action_at D97 ) , C136) ) . ( ( action_at D97 ) depends_on_in C137 ) )) by L557;
L564: ( dom C141 ) = (the carrier of C135) by CIRCUIT1:3;
L565: D97 in ( ( InputVertices C135 ) \/ ( InnerVertices C135 ) ) by L564 , L561 , XBOOLE_1:45;
L566: (D97 in ( InputVertices C135 ) or D97 in ( InnerVertices C135 )) by L565 , XBOOLE_0:def 3;
L567: (D97 in ( InputVertices C135 ) implies ( C141 . D97 ) = ( C137 . D97 )) by L557;
thus L568: contradiction by L567 , L558 , L562 , L566 , L563;
end;
end;
theorem
L570: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for B150 being  non-empty (Circuit of R1) holds (for B151 being (State of B150) holds (for B152 being (InputValues of B150) holds (B152 c= B151 implies B152 c= ( Following B151 ))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C144 being  non-empty (Circuit of R1);
let C145 being (State of C144);
let C146 being (InputValues of C144);
assume that
L571: C146 c= C145;
L572:
now
L573: ( dom C145 ) = (the carrier of R1) by CIRCUIT1:3
.= ( dom ( Following C145 ) ) by CIRCUIT1:3;
thus L574: ( dom C146 ) c= ( dom ( Following C145 ) ) by L573 , L571 , RELAT_1:11;
let C147 being set;
assume that
L575: C147 in ( dom C146 );
L576: ( dom C146 ) = ( InputVertices R1 ) by PARTFUN1:def 2;
reconsider D98 = C147 as (Vertex of R1) by L576 , L575;
L577: ( C146 . D98 ) = ( C145 . D98 ) by L571 , L575 , GRFUNC_1:2;
thus L578: ( C146 . C147 ) = ( ( Following C145 ) . C147 ) by L577 , L575 , L576 , L536;
end;
thus L579: thesis by L572 , GRFUNC_1:2;
end;
definition
let C148 being  Circuit-like non  void non  empty ManySortedSign;
let C149 being  non-empty (Circuit of C148);
let C150 being (State of C149);
attr C150 is  stable
means
:L580: C150 = ( Following C150 );
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C151 being  non-empty (Circuit of R1);
let C152 being (State of C151);
let C153 being (InputValues of C151);
func Following (C152 , C153) -> (State of C151) equals 
( Following ( C152 +* C153 ) );
coherence;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C154 being  non-empty (Circuit of R1);
let C155 being (InputFuncs of C154);
let C156 being (State of C154);
func InitialComp (C156 , C155) -> (State of C154) equals 
( ( C156 +* ( ( 0 ) -th_InputValues C155 ) ) +* ( Set-Constants C154 ) );
coherence
proof
set D99 = ( Set-Constants C154 );
L583: ( dom D99 ) = ( SortsWithConstants R1 ) by PARTFUN1:def 2;
L584:
now
let C157 being set;
assume L585: C157 in ( dom D99 );
reconsider D100 = C157 as (Vertex of R1) by L585 , L583;
L586: ( D99 . C157 ) in ( Constants (C154 , D100) ) by L585 , CIRCUIT1:def 1;
thus L587: ( D99 . C157 ) in ( (the Sorts of C154) . C157 ) by L586;
end;
L588: ( dom (the Sorts of C154) ) = (the carrier of R1) by PARTFUN1:def 2;
thus L589: thesis by L588 , L583 , L584 , PRE_CIRC:6;
end;
end;
definition
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let C158 being  non-empty (Circuit of R1);
let C159 being (InputFuncs of C158);
let C160 being (State of C158);
func Computation (C160 , C159) -> (Function of ( NAT ) , ( product (the Sorts of C158) )) means 
:L591: (( it . ( 0 ) ) = ( InitialComp (C160 , C159) ) & (for B153 being Nat holds ( it . ( B153 + 1 ) ) = ( Following (( it . B153 ) , ( ( B153 + 1 ) -th_InputValues C159 )) )));
correctness
proof
deffunc H4(Nat , (State of C158)) = ( Following ($2 , ( ( $1 + 1 ) -th_InputValues C159 )) );
thus L592: ((ex B154 being (Function of ( NAT ) , ( product (the Sorts of C158) )) st (( B154 . ( 0 ) ) = ( InitialComp (C160 , C159) ) & (for B155 being Nat holds ( B154 . ( B155 + 1 ) ) = H4(B155 , ( B154 . B155 ))))) & (for B156 , B157 being (Function of ( NAT ) , ( product (the Sorts of C158) )) holds ((( B156 . ( 0 ) ) = ( InitialComp (C160 , C159) ) & (for B158 being Nat holds ( B156 . ( B158 + 1 ) ) = H4(B158 , ( B156 . B158 ))) & ( B157 . ( 0 ) ) = ( InitialComp (C160 , C159) ) & (for B159 being Nat holds ( B157 . ( B159 + 1 ) ) = H4(B159 , ( B157 . B159 )))) implies B156 = B157))) from PRE_CIRC:sch 3;
end;
end;
theorem
L594: (for R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R2 being  non-empty (Circuit of R1) holds (for R3 being (State of R2) holds (for R4 being (InputValues of R2) holds (for B160 being (Element of ( NAT )) holds ((for B161 being (Vertex of R1) holds (( depth (B161 , R2) ) <= B160 implies ( R3 . B161 ) = ( IGValue (B161 , R4) ))) implies (for B162 being (Vertex of R1) holds (( depth (B162 , R2) ) <= ( B160 + 1 ) implies ( ( Following R3 ) . B162 ) = ( IGValue (B162 , R4) )))))))))
proof
let R1 being  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R2 being  non-empty (Circuit of R1);
let R3 being (State of R2);
let R4 being (InputValues of R2);
let C161 being (Element of ( NAT ));
assume that
L595: (for B163 being (Vertex of R1) holds (( depth (B163 , R2) ) <= C161 implies ( R3 . B163 ) = ( IGValue (B163 , R4) )));
let C162 being (Vertex of R1);
assume that
L596: ( depth (C162 , R2) ) <= ( C161 + 1 );
L597: C162 in (the carrier of R1);
L598: C162 in ( ( InputVertices R1 ) \/ ( InnerVertices R1 ) ) by L597 , XBOOLE_1:45;
per cases  by L598 , XBOOLE_0:def 3;
suppose L599: C162 in ( InputVertices R1 );

L600: ( depth (C162 , R2) ) = ( 0 ) by L599 , CIRCUIT1:18;
thus L601: ( ( Following R3 ) . C162 ) = ( R3 . C162 ) by L599 , L536
.= ( IGValue (C162 , R4) ) by L595 , L600 , NAT_1:2;
end;
suppose L602: C162 in ( InnerVertices R1 );

set D101 = ( Eval R2 );
set D102 = (the Sorts of R2);
set D103 = ( FreeEnv R2 );
set D104 = ( action_at C162 );
set D105 = ( the_arity_of D104 );
deffunc H5(Nat) = ( IGTree ((( D105 /. $1 ) qua (Vertex of R1)) , R4) );
consider C163 being FinSequence such that L603: ( len C163 ) = ( len ( the_arity_of D104 ) ) and L604: (for B164 being Nat holds (B164 in ( dom C163 ) implies ( C163 . B164 ) = H5(B164))) from FINSEQ_1:sch 2;
L605: (for B165 being (Element of ( NAT )) holds (B165 in ( dom C163 ) implies ( C163 . B165 ) = H5(B165))) by L604;
L606:
now
let C164 being Nat;
assume L607: C164 in ( dom C163 );
L608: ( C163 . C164 ) = ( IGTree (( D105 /. C164 ) , R4) ) by L607 , L604;
thus L609: ( C163 . C164 ) in ( (the Sorts of D103) . ( ( the_arity_of D104 ) /. C164 ) ) by L608;
end;
L610: D103 = MSAlgebra (# ( FreeSort D102 ) , ( FreeOper D102 ) #) by MSAFREE:def 14;
L611: ( Den (D104 , D103) ) = ( ( FreeOper D102 ) . D104 ) by L610 , MSUALG_1:def 6
.= ( DenOp (D104 , D102) ) by MSAFREE:def 13;
reconsider D106 = ( D104 depends_on_in R3 ) as Function;
L612: D101 is_homomorphism D103 , R2 by MSAFREE2:def 9;
L613: ( dom (the Arity of R1) ) = (the carrier' of R1) by FUNCT_2:def 1;
L614: ( ( ( (the Sorts of R2) # ) * (the Arity of R1) ) . D104 ) = ( ( (the Sorts of R2) # ) . ( (the Arity of R1) . D104 ) ) by L613 , FUNCT_1:13
.= ( ( (the Sorts of R2) # ) . ( the_arity_of D104 ) ) by MSUALG_1:def 1
.= ( product ( (the Sorts of R2) * ( the_arity_of D104 ) ) ) by FINSEQ_2:def 5;
L615: ( dom C163 ) = ( dom ( the_arity_of D104 ) ) by L603 , FINSEQ_3:29;
reconsider D107 = C163 as (Element of ( Args (D104 , D103) )) by L603 , L606 , MSAFREE2:5;
L616: (D103 = MSAlgebra (# ( FreeSort D102 ) , ( FreeOper D102 ) #) & ( Args (D104 , D103) ) = ( ( ( (the Sorts of D103) # ) * (the Arity of R1) ) . D104 )) by MSAFREE:def 14 , MSUALG_1:def 4;
reconsider D108 = D107 as (FinSequence of ( TS ( DTConMSA D102 ) )) by L616 , MSAFREE:8;
L617: ( Sym (D104 , D102) ) ==> ( roots D108 ) by L616 , MSAFREE:10;
L618: ( ( Den (D104 , D103) ) . D107 ) = ( ( Sym (D104 , D102) ) -tree D108 ) by L617 , L611 , MSAFREE:def 12
.= ( [ D104 , (the carrier of R1) ] -tree D108 ) by MSAFREE:def 9
.= ( IGTree (C162 , R4) ) by L602 , L605 , L615 , L457;
reconsider D109 = ( D101 # D107 ) as Function;
L619: ( Args (D104 , R2) ) = ( ( ( (the Sorts of R2) # ) * (the Arity of R1) ) . D104 ) by MSUALG_1:def 4;
L620:
now
L621: (( dom (the Sorts of R2) ) = (the carrier of R1) & ( rng ( the_arity_of D104 ) ) c= (the carrier of R1)) by FINSEQ_1:def 4 , PARTFUN1:def 2;
thus L622: ( dom ( the_arity_of D104 ) ) = ( dom ( (the Sorts of R2) * ( the_arity_of D104 ) ) ) by L621 , RELAT_1:27
.= ( dom D109 ) by L614 , L619 , CARD_3:9;
L623: (( dom R3 ) = (the carrier of R1) & ( rng ( the_arity_of D104 ) ) c= (the carrier of R1)) by CIRCUIT1:3 , FINSEQ_1:def 4;
thus L624: ( dom ( the_arity_of D104 ) ) = ( dom ( R3 * ( the_arity_of D104 ) ) ) by L623 , RELAT_1:27
.= ( dom D106 ) by CIRCUIT1:def 3;
let C165 being set;
reconsider D110 = ( ( the_arity_of D104 ) /. C165 ) as (Element of R1);
assume L625: C165 in ( dom ( the_arity_of D104 ) );
reconsider D111 = C165 as (Element of ( NAT )) by L625;
L626: D110 = ( ( the_arity_of D104 ) . D111 ) by L625 , PARTFUN1:def 6;
L627: D110 in ( rng ( the_arity_of D104 ) ) by L626 , L625 , FUNCT_1:def 3;
L628: ( depth (D110 , R2) ) < ( C161 + 1 ) by L627 , L596 , L602 , CIRCUIT1:19 , XXREAL_0:2;
L629: ( depth (D110 , R2) ) <= C161 by L628 , NAT_1:13;
thus L630: ( D109 . C165 ) = ( ( D101 . D110 ) . ( D108 . D111 ) ) by L615 , L625 , MSUALG_3:def 6
.= ( IGValue (D110 , R4) ) by L604 , L615 , L625
.= ( R3 . D110 ) by L595 , L629
.= ( ( R3 * ( the_arity_of D104 ) ) . C165 ) by L625 , L626 , FUNCT_1:13
.= ( D106 . C165 ) by CIRCUIT1:def 3;
end;
L631: ( D101 # D107 ) = ( D104 depends_on_in R3 ) by L620 , FUNCT_1:2;
thus L632: ( ( Following R3 ) . C162 ) = ( ( Den (D104 , R2) ) . ( D101 # D107 ) ) by L631 , L602 , L536
.= ( ( D101 . ( the_result_sort_of D104 ) ) . ( ( Den (D104 , D103) ) . D107 ) ) by L612 , MSUALG_3:def 7
.= ( IGValue (C162 , R4) ) by L602 , L618 , MSAFREE2:def 7;
end;
end;
theorem
L634: (for R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R6 being  non-empty (Circuit of R5) holds (for R7 being (InputFuncs of R6) holds ((( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty) implies (for R8 being (State of R6) holds (for R9 being (InputValues of R6) holds (R9 = ( ( commute R7 ) . ( 0 ) ) implies (for B166 being (Element of ( NAT )) holds R9 c= ( ( Computation (R8 , R7) ) . B166 )))))))))
proof
let R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R6 being  non-empty (Circuit of R5);
let R7 being (InputFuncs of R6);
assume that
L635: ( commute R7 ) is  constant
and
L636: ( InputVertices R5 ) is non  empty;
L637: ( dom ( commute R7 ) ) = ( NAT ) by L636 , PRE_CIRC:5;
let R8 being (State of R6);
let R9 being (InputValues of R6);
assume L638: R9 = ( ( commute R7 ) . ( 0 ) );
let C166 being (Element of ( NAT ));
L639: R5 is  with_input_V by L636 , MSAFREE2:def 4;
L640: ( C166 -th_InputValues R7 ) = ( ( commute R7 ) . C166 ) by L639 , CIRCUIT1:def 2
.= R9 by L635 , L638 , L637 , FUNCT_1:def 10;
set D112 = ( ( Computation (R8 , R7) ) . C166 );
L641: (( dom R9 ) = ( InputVertices R5 ) & ( dom ( Set-Constants R6 ) ) = ( SortsWithConstants R5 )) by PARTFUN1:def 2;
L642: ( dom R9 ) misses ( dom ( Set-Constants R6 ) ) by L641 , MSAFREE2:4;
per cases  by NAT_1:6;
suppose L643: C166 = ( 0 );

L644: D112 = ( InitialComp (R8 , R7) ) by L643 , L591
.= ( ( R8 +* ( ( 0 ) -th_InputValues R7 ) ) +* ( Set-Constants R6 ) );
thus L645: thesis by L644 , L640 , L642 , L643 , FUNCT_4:25 , FUNCT_4:124;
end;
suppose L646: (ex B167 being Nat st C166 = ( B167 + 1 ));

consider C167 being Nat such that L647: C166 = ( C167 + 1 ) by L646;
reconsider D113 = C167 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D114 = ( ( Computation (R8 , R7) ) . D113 ) as (State of R6);
L648: D112 = ( Following (D114 , ( C166 -th_InputValues R7 )) ) by L647 , L591
.= ( Following ( D114 +* R9 ) ) by L640;
thus L649: thesis by L648 , L570 , FUNCT_4:25;
end;
end;
theorem
L651: (for R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R6 being  non-empty (Circuit of R5) holds (for R7 being (InputFuncs of R6) holds (for R8 being (State of R6) holds (for B168 being (Element of ( NAT )) holds ((( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty & ( ( Computation (R8 , R7) ) . B168 ) is  stable) implies (for B169 being (Element of ( NAT )) holds (B168 <= B169 implies ( ( Computation (R8 , R7) ) . B168 ) = ( ( Computation (R8 , R7) ) . B169 )))))))))
proof
let R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R6 being  non-empty (Circuit of R5);
let R7 being (InputFuncs of R6);
let R8 being (State of R6);
let C168 being (Element of ( NAT ));
assume that
L652: ( commute R7 ) is  constant
and
L653: ( InputVertices R5 ) is non  empty
and
L654: ( ( Computation (R8 , R7) ) . C168 ) is  stable;
defpred S5[ (Element of ( NAT )) ] means (C168 <= $1 implies ( ( Computation (R8 , R7) ) . C168 ) = ( ( Computation (R8 , R7) ) . $1 ));
L655:
now
let C169 being (Element of ( NAT ));
assume L656: S5[ C169 ];
thus L657: S5[ ( C169 + 1 ) ]
proof
L658: R5 is  with_input_V by L653 , MSAFREE2:def 4;
reconsider D115 = ( ( commute R7 ) . ( 0 ) ) as (InputValues of R6) by L658 , CIRCUIT1:2;
reconsider D116 = ( ( Computation (R8 , R7) ) . C169 ) as (State of R6);
L659: ( dom ( commute R7 ) ) = ( NAT ) by L653 , PRE_CIRC:5;
L660: ( ( C169 + 1 ) -th_InputValues R7 ) = ( ( commute R7 ) . ( C169 + 1 ) ) by L658 , CIRCUIT1:def 2
.= D115 by L652 , L659 , FUNCT_1:def 10;
L661: ( ( C169 + 1 ) -th_InputValues R7 ) c= ( ( Computation (R8 , R7) ) . C169 ) by L660 , L652 , L653 , L634;
assume L662: C168 <= ( C169 + 1 );
per cases  by L662 , NAT_1:8;
suppose L663: C168 <= C169;

thus L664: ( ( Computation (R8 , R7) ) . C168 ) = ( Following D116 ) by L663 , L654 , L656 , L580
.= ( Following (( ( Computation (R8 , R7) ) . C169 ) , ( ( C169 + 1 ) -th_InputValues R7 )) ) by L661 , FUNCT_4:98
.= ( ( Computation (R8 , R7) ) . ( C169 + 1 ) ) by L591;
end;
suppose L665: C168 = ( C169 + 1 );

thus L666: thesis by L665;
end;
end;

end;
L658: S5[ ( 0 ) ] by NAT_1:3;
thus L659: (for B170 being (Element of ( NAT )) holds S5[ B170 ]) from NAT_1:sch 1(L658 , L655);
end;
theorem
L660: (for R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R6 being  non-empty (Circuit of R5) holds (for R7 being (InputFuncs of R6) holds ((( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty) implies (for R8 being (State of R6) holds (for R9 being (InputValues of R6) holds (R9 = ( ( commute R7 ) . ( 0 ) ) implies (for B171 being (Element of ( NAT )) holds (for B172 being (Vertex of R5) holds (( depth (B172 , R6) ) <= B171 implies ( (( ( Computation (R8 , R7) ) . B171 ) qua (Element of ( product (the Sorts of R6) ))) . B172 ) = ( IGValue (B172 , R9) )))))))))))
proof
let R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R6 being  non-empty (Circuit of R5);
let R7 being (InputFuncs of R6);
assume that
L661: ( commute R7 ) is  constant
and
L662: ( InputVertices R5 ) is non  empty;
let R8 being (State of R6);
let R9 being (InputValues of R6);
assume L663: R9 = ( ( commute R7 ) . ( 0 ) );
defpred S6[ (Element of ( NAT )) ] means (for B173 being (Vertex of R5) holds (( depth (B173 , R6) ) <= $1 implies ( (( ( Computation (R8 , R7) ) . $1 ) qua (State of R6)) . B173 ) = ( IGValue (B173 , R9) )));
L664: R5 is  with_input_V by L662 , MSAFREE2:def 4;
L665: S6[ ( 0 ) ]
proof
let C170 being (Vertex of R5);
assume L666: ( depth (C170 , R6) ) <= ( 0 );
L667: ( depth (C170 , R6) ) = ( 0 ) by L666 , NAT_1:3;
L668: ( ( Computation (R8 , R7) ) . ( 0 ) ) = ( InitialComp (R8 , R7) ) by L591
.= ( ( R8 +* ( ( 0 ) -th_InputValues R7 ) ) +* ( Set-Constants R6 ) );
per cases  by L667 , CIRCUIT1:18;
suppose L669: C170 in ( InputVertices R5 );

L670: ( dom ( ( 0 ) -th_InputValues R7 ) ) = ( InputVertices R5 ) by PARTFUN1:def 2;
L671: ( InputVertices R5 ) misses ( SortsWithConstants R5 ) by MSAFREE2:4;
L672: (not C170 in ( SortsWithConstants R5 )) by L671 , L669 , XBOOLE_0:3;
L673: (not C170 in ( dom ( Set-Constants R6 ) )) by L672 , PARTFUN1:def 2;
thus L674: ( (( ( Computation (R8 , R7) ) . ( 0 ) ) qua (Element of ( product (the Sorts of R6) ))) . C170 ) = ( ( R8 +* ( ( 0 ) -th_InputValues R7 ) ) . C170 ) by L673 , L668 , FUNCT_4:11
.= ( ( ( 0 ) -th_InputValues R7 ) . C170 ) by L669 , L670 , FUNCT_4:13
.= ( R9 . C170 ) by L664 , L663 , CIRCUIT1:def 2
.= ( IGValue (C170 , R9) ) by L669 , L488;
end;
suppose L675: C170 in ( SortsWithConstants R5 );

L676: C170 in ( dom ( Set-Constants R6 ) ) by L675 , PARTFUN1:def 2;
thus L677: ( (( ( Computation (R8 , R7) ) . ( 0 ) ) qua (Element of ( product (the Sorts of R6) ))) . C170 ) = ( ( Set-Constants R6 ) . C170 ) by L676 , L668 , FUNCT_4:13
.= ( IGValue (C170 , R9) ) by L675 , L506;
end;
end;
L679: (for B174 being (Element of ( NAT )) holds (S6[ B174 ] implies S6[ ( B174 + 1 ) ]))
proof
let C171 being (Element of ( NAT ));
reconsider D117 = ( ( Computation (R8 , R7) ) . C171 ) as (State of R6);
assume L680: S6[ C171 ];
let C172 being (Vertex of R5);
assume that
L681: ( depth (C172 , R6) ) <= ( C171 + 1 );
L682: ( dom ( commute R7 ) ) = ( NAT ) by L662 , PRE_CIRC:5;
L683: ( ( C171 + 1 ) -th_InputValues R7 ) = ( ( commute R7 ) . ( C171 + 1 ) ) by L664 , CIRCUIT1:def 2
.= ( ( commute R7 ) . ( 0 ) ) by L661 , L682 , FUNCT_1:def 10;
L684: R9 c= D117 by L661 , L662 , L663 , L634;
thus L685: ( (( ( Computation (R8 , R7) ) . ( C171 + 1 ) ) qua (State of R6)) . C172 ) = ( ( Following (D117 , ( ( C171 + 1 ) -th_InputValues R7 )) ) . C172 ) by L591
.= ( ( Following D117 ) . C172 ) by L663 , L683 , L684 , FUNCT_4:98
.= ( IGValue (C172 , R9) ) by L680 , L681 , L594;
end;
thus L686: (for B175 being (Element of ( NAT )) holds S6[ B175 ]) from NAT_1:sch 1(L665 , L679);
end;
theorem
L687: (for R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R6 being  non-empty (Circuit of R5) holds (for R7 being (InputFuncs of R6) holds (for R9 being (InputValues of R6) holds ((( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty & R9 = ( ( commute R7 ) . ( 0 ) )) implies (for B176 being (State of R6) holds (for B177 being (Vertex of R5) holds (for B178 being (Element of ( NAT )) holds (B178 = ( depth R6 ) implies ( (( ( Computation (B176 , R7) ) . B178 ) qua (State of R6)) . B177 ) = ( IGValue (B177 , R9) ))))))))))
proof
let R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R6 being  non-empty (Circuit of R5);
let R7 being (InputFuncs of R6);
let R9 being (InputValues of R6);
assume L688: (( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty & R9 = ( ( commute R7 ) . ( 0 ) ));
let C173 being (State of R6);
let C174 being (Vertex of R5);
L689: ( depth (C174 , R6) ) <= ( depth R6 ) by CIRCUIT1:17;
let C175 being (Element of ( NAT ));
assume L690: C175 = ( depth R6 );
thus L691: thesis by L690 , L688 , L689 , L660;
end;
theorem
L692: (for R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R6 being  non-empty (Circuit of R5) holds (for R7 being (InputFuncs of R6) holds ((( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty) implies (for B179 being (State of R6) holds (for B180 being (Element of ( NAT )) holds (B180 = ( depth R6 ) implies ( ( Computation (B179 , R7) ) . B180 ) is  stable)))))))
proof
let R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R6 being  non-empty (Circuit of R5);
let R7 being (InputFuncs of R6);
assume that
L693: ( commute R7 ) is  constant
and
L694: ( InputVertices R5 ) is non  empty;
L695: ( dom ( commute R7 ) ) = ( NAT ) by L694 , PRE_CIRC:5;
L696: R5 is  with_input_V by L694 , MSAFREE2:def 4;
reconsider D118 = ( ( commute R7 ) . ( 0 ) ) as (InputValues of R6) by L696 , CIRCUIT1:2;
let C176 being (State of R6);
let C177 being (Element of ( NAT ));
assume that
L697: C177 = ( depth R6 );
reconsider D119 = ( ( Computation (C176 , R7) ) . C177 ) as (State of R6);
L698: D118 c= D119 by L693 , L694 , L634;
L699: ( ( C177 + 1 ) -th_InputValues R7 ) = ( ( commute R7 ) . ( C177 + 1 ) ) by L696 , CIRCUIT1:def 2
.= ( ( commute R7 ) . ( 0 ) ) by L693 , L695 , FUNCT_1:def 10;
reconsider D120 = ( ( Computation (C176 , R7) ) . ( C177 + 1 ) ) as (State of R6);
L700:
now
thus L701: (the carrier of R5) = ( dom D119 ) by CIRCUIT1:3;
thus L702: (the carrier of R5) = ( dom D120 ) by CIRCUIT1:3;
let C178 being set;
assume L703: C178 in (the carrier of R5);
reconsider D121 = C178 as (Vertex of R5) by L703;
L704: ( depth (D121 , R6) ) <= C177 by L697 , CIRCUIT1:17;
L705: ( D119 . D121 ) = ( IGValue (D121 , D118) ) by L704 , L693 , L694 , L660;
thus L706: ( D119 . C178 ) = ( D120 . C178 ) by L705 , L693 , L694 , L704 , L660 , NAT_1:12;
end;
thus L707: ( ( Computation (C176 , R7) ) . C177 ) = ( ( Computation (C176 , R7) ) . ( C177 + 1 ) ) by L700 , FUNCT_1:2
.= ( Following (D119 , ( ( C177 + 1 ) -th_InputValues R7 )) ) by L591
.= ( Following ( ( Computation (C176 , R7) ) . C177 ) ) by L699 , L698 , FUNCT_4:98;
end;
theorem
L708: (for R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign holds (for R6 being  non-empty (Circuit of R5) holds (for R7 being (InputFuncs of R6) holds ((( commute R7 ) is  constant & ( InputVertices R5 ) is non  empty) implies (for B181 , B182 being (State of R6) holds ( ( Computation (B181 , R7) ) . ( depth R6 ) ) = ( ( Computation (B182 , R7) ) . ( depth R6 ) ))))))
proof
let R5 being  finite  monotonic  Circuit-like non  void non  empty ManySortedSign;
let R6 being  non-empty (Circuit of R5);
let R7 being (InputFuncs of R6);
assume that
L709: ( commute R7 ) is  constant
and
L710: ( InputVertices R5 ) is non  empty;
L711: R5 is  with_input_V by L710 , MSAFREE2:def 4;
reconsider D122 = ( ( commute R7 ) . ( 0 ) ) as (InputValues of R6) by L711 , CIRCUIT1:2;
reconsider D123 = ( depth R6 ) as (Element of ( NAT )) by ORDINAL1:def 12;
let C179 , C180 being (State of R6);
reconsider D124 = ( ( Computation (C179 , R7) ) . D123 ) as (State of R6);
reconsider D125 = ( ( Computation (C180 , R7) ) . D123 ) as (State of R6);
L712:
now
thus L713: (the carrier of R5) = ( dom D124 ) by CIRCUIT1:3;
thus L714: (the carrier of R5) = ( dom D125 ) by CIRCUIT1:3;
let C181 being set;
assume L715: C181 in (the carrier of R5);
reconsider D126 = C181 as (Vertex of R5) by L715;
L716: ( D124 . D126 ) = ( IGValue (D126 , D122) ) by L709 , L710 , L687;
thus L717: ( D124 . C181 ) = ( D125 . C181 ) by L716 , L709 , L710 , L687;
end;
thus L718: thesis by L712 , FUNCT_1:2;
end;
