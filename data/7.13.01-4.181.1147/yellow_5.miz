:: Miscellaneous Facts about Relation Structure
::  by Agnieszka Julia Marasik
::
:: Received November 8, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RELAT_2, LATTICE3, ORDERS_2, SUBSET_1, EQREL_1, XXREAL_0,
      LATTICES, XBOOLE_0, WAYBEL_0, XBOOLEAN;
 notations STRUCT_0, LATTICE3, WAYBEL_0, WAYBEL_1, YELLOW_0, ORDERS_2;
 constructors LATTICE3, WAYBEL_1;
 registrations LATTICE3, YELLOW_0, WAYBEL_1;
 theorems LATTICE3, YELLOW_0, WAYBEL_1;

begin
theorem
L1: (for B1 being  reflexive  antisymmetric  with_suprema RelStr holds (for B2 being (Element of B1) holds ( B2 "\/" B2 ) = B2))
proof
let C1 being  reflexive  antisymmetric  with_suprema RelStr;
let C2 being (Element of C1);
L2: C2 <= C2;
L3: (C2 <= ( C2 "\/" C2 ) & ( C2 "\/" C2 ) <= C2) by L2 , YELLOW_0:22;
thus L4: thesis by L3 , YELLOW_0:def 3;
end;
theorem
L5: (for B3 being  reflexive  antisymmetric  with_infima RelStr holds (for B4 being (Element of B3) holds ( B4 "/\" B4 ) = B4))
proof
let C3 being  reflexive  antisymmetric  with_infima RelStr;
let C4 being (Element of C3);
L6: C4 <= C4;
L7: (( C4 "/\" C4 ) <= C4 & C4 <= ( C4 "/\" C4 )) by L6 , YELLOW_0:23;
thus L8: thesis by L7 , YELLOW_0:def 3;
end;
theorem
L9: (for B5 being  transitive  antisymmetric  with_suprema RelStr holds (for B6 , B7 , B8 being (Element of B5) holds (( B6 "\/" B7 ) <= B8 implies B6 <= B8)))
proof
let C5 being  transitive  antisymmetric  with_suprema RelStr;
let C6 , C7 , C8 being (Element of C5);
L10: C6 <= ( C6 "\/" C7 ) by YELLOW_0:22;
assume L11: ( C6 "\/" C7 ) <= C8;
thus L12: thesis by L11 , L10 , YELLOW_0:def 2;
end;
theorem
L13: (for B9 being  transitive  antisymmetric  with_infima RelStr holds (for B10 , B11 , B12 being (Element of B9) holds (B12 <= ( B10 "/\" B11 ) implies B12 <= B10)))
proof
let C9 being  transitive  antisymmetric  with_infima RelStr;
let C10 , C11 , C12 being (Element of C9);
L14: ( C10 "/\" C11 ) <= C10 by YELLOW_0:23;
assume L15: C12 <= ( C10 "/\" C11 );
thus L16: thesis by L15 , L14 , YELLOW_0:def 2;
end;
theorem
L17: (for B13 being  antisymmetric  transitive  with_suprema  with_infima RelStr holds (for B14 , B15 , B16 being (Element of B13) holds ( B14 "/\" B15 ) <= ( B14 "\/" B16 )))
proof
let C13 being  antisymmetric  transitive  with_suprema  with_infima RelStr;
let C14 , C15 , C16 being (Element of C13);
L18: (( C14 "/\" C15 ) <= C14 & C14 <= ( C14 "\/" C16 )) by YELLOW_0:22 , YELLOW_0:23;
thus L19: thesis by L18 , YELLOW_0:def 2;
end;
theorem
L20: (for B17 being  antisymmetric  transitive  with_infima RelStr holds (for B18 , B19 , B20 being (Element of B17) holds (B18 <= B19 implies ( B18 "/\" B20 ) <= ( B19 "/\" B20 ))))
proof
let C17 being  antisymmetric  transitive  with_infima RelStr;
let C18 , C19 , C20 being (Element of C17);
L21: ( C18 "/\" C20 ) <= C18 by YELLOW_0:23;
L22: ( C18 "/\" C20 ) <= C20 by YELLOW_0:23;
assume L23: C18 <= C19;
L24: ( C18 "/\" C20 ) <= C19 by L23 , L21 , YELLOW_0:def 2;
thus L25: thesis by L24 , L22 , YELLOW_0:23;
end;
theorem
L26: (for B21 being  antisymmetric  transitive  with_suprema RelStr holds (for B22 , B23 , B24 being (Element of B21) holds (B22 <= B23 implies ( B22 "\/" B24 ) <= ( B23 "\/" B24 ))))
proof
let C21 being non  empty  antisymmetric  transitive  with_suprema RelStr;
let C22 , C23 , C24 being (Element of C21);
L27: C23 <= ( C23 "\/" C24 ) by YELLOW_0:22;
L28: C24 <= ( C23 "\/" C24 ) by YELLOW_0:22;
assume L29: C22 <= C23;
L30: C22 <= ( C23 "\/" C24 ) by L29 , L27 , YELLOW_0:def 2;
thus L31: thesis by L30 , L28 , YELLOW_0:22;
end;
theorem
L32: (for B25 being sup-Semilattice holds (for B26 , B27 being (Element of B25) holds (B26 <= B27 implies ( B26 "\/" B27 ) = B27)))
proof
let C25 being sup-Semilattice;
let C26 , C27 being (Element of C25);
L33: C27 <= C27;
assume L34: C26 <= C27;
L35: (C27 <= ( C26 "\/" C27 ) & ( C26 "\/" C27 ) <= C27) by L34 , L33 , YELLOW_0:22;
thus L36: thesis by L35 , YELLOW_0:def 3;
end;
theorem
L37: (for B28 being sup-Semilattice holds (for B29 , B30 , B31 being (Element of B28) holds ((B29 <= B31 & B30 <= B31) implies ( B29 "\/" B30 ) <= B31)))
proof
let C28 being sup-Semilattice;
let C29 , C30 , C31 being (Element of C28);
assume that
L38: C29 <= C31
and
L39: C30 <= C31;
L40: ( C31 "\/" C30 ) = C31 by L39 , L32;
thus L41: thesis by L40 , L38 , L26;
end;
theorem
L42: (for B32 being Semilattice holds (for B33 , B34 being (Element of B32) holds (B34 <= B33 implies ( B33 "/\" B34 ) = B34)))
proof
let C32 being Semilattice;
let C33 , C34 being (Element of C32);
assume L43: C34 <= C33;
L44: ( C34 "/\" C34 ) <= ( C33 "/\" C34 ) by L43 , L20;
L45: (( C33 "/\" C34 ) <= C34 & C34 <= ( C33 "/\" C34 )) by L44 , L5 , YELLOW_0:23;
thus L46: thesis by L45 , YELLOW_0:def 3;
end;
begin
theorem
L47: (for B35 being  Boolean LATTICE holds (for B36 , B37 being (Element of B35) holds (B37 is_a_complement_of B36 iff B37 = ( 'not' B36 ))))
proof
let C35 being  Boolean LATTICE;
let C36 , C37 being (Element of C35);
L48: (for B38 being (Element of C35) holds ( 'not' ( 'not' B38 ) ) = B38) by WAYBEL_1:87;
L49: ( 'not' C36 ) is_a_complement_of C36 by L48 , WAYBEL_1:86;
L50: ( C36 "/\" ( 'not' C36 ) ) = ( Bottom C35 ) by L49 , WAYBEL_1:def 23;
L51: ( C36 "\/" ( 'not' C36 ) ) = ( Top C35 ) by L49 , WAYBEL_1:def 23;
thus L52:now
assume L53: C37 is_a_complement_of C36;
L54: ( C36 "/\" C37 ) = ( Bottom C35 ) by L53 , WAYBEL_1:def 23;
L55: ( Top C35 ) >= ( 'not' C36 ) by YELLOW_0:45;
L56: ( Bottom C35 ) <= ( C37 "/\" ( 'not' C36 ) ) by YELLOW_0:44;
L57: ( Top C35 ) >= C37 by YELLOW_0:45;
L58: C37 = ( ( C36 "\/" ( 'not' C36 ) ) "/\" C37 ) by L57 , L51 , YELLOW_0:25
.= ( ( C36 "/\" C37 ) "\/" ( C37 "/\" ( 'not' C36 ) ) ) by WAYBEL_1:def 3
.= ( C37 "/\" ( 'not' C36 ) ) by L54 , L56 , YELLOW_0:24;
L59: ( C36 "\/" C37 ) = ( Top C35 ) by L53 , WAYBEL_1:def 23;
L60: ( 'not' C36 ) = ( ( C36 "\/" C37 ) "/\" ( 'not' C36 ) ) by L59 , L55 , YELLOW_0:25
.= ( ( C36 "/\" ( 'not' C36 ) ) "\/" ( C37 "/\" ( 'not' C36 ) ) ) by WAYBEL_1:def 3
.= ( C37 "/\" ( 'not' C36 ) ) by L50 , L56 , YELLOW_0:24;
thus L61: C37 = ( 'not' C36 ) by L60 , L58;
end;
thus L62: thesis by L48 , WAYBEL_1:86;
end;
definition
let C38 being non  empty RelStr;
let C39 , C40 being (Element of C38);
func C39 \ C40 -> (Element of C38) equals 
( C39 "/\" ( 'not' C40 ) );
correctness;
end;
definition
let C41 being non  empty RelStr;
let C42 , C43 being (Element of C41);
func C42 \+\ C43 -> (Element of C41) equals 
( ( C42 \ C43 ) "\/" ( C43 \ C42 ) );
correctness;
end;
definition
let C44 being  antisymmetric  with_infima  with_suprema RelStr;
let C45 , C46 being (Element of C44);
redefine func C45 \+\ C46;

commutativity
proof
let C47 , C48 being (Element of C44);
thus L65: ( C47 \+\ C48 ) = ( ( C47 \ C48 ) "\/" ( C48 \ C47 ) )
.= ( C48 \+\ C47 );
end;
end;
definition
let C49 being non  empty RelStr;
let C50 , C51 being (Element of C49);
pred C50 meets C51
means
:L67: ( C50 "/\" C51 ) <> ( Bottom C49 )
;end;
notation
let C52 being non  empty RelStr;
let C53 , C54 being (Element of C52);
antonym C53 misses C54 for C53 meets C54;
end;
notation
let C55 being  with_infima  antisymmetric RelStr;
let C56 , C57 being (Element of C55);
antonym C56 misses C57 for C56 meets C57;
end;
definition
let C58 being  with_infima  antisymmetric RelStr;
let C59 , C60 being (Element of C58);
redefine pred C59 meets C60
;
symmetry
proof
let C61 , C62 being (Element of C58);
L71: (( C61 "/\" C62 ) <> ( Bottom C58 ) implies ( C62 "/\" C61 ) <> ( Bottom C58 ));
thus L72: thesis by L71 , L67;
end;
end;
theorem
L74: (for B39 being  antisymmetric  transitive  with_infima  with_suprema RelStr holds (for B40 , B41 , B42 being (Element of B39) holds (B40 <= B42 implies ( B40 \ B41 ) <= B42)))
proof
let C63 being  antisymmetric  transitive  with_infima  with_suprema RelStr;
let C64 , C65 , C66 being (Element of C63);
L75: ( C64 "/\" ( 'not' C65 ) ) <= C64 by YELLOW_0:23;
assume L76: C64 <= C66;
thus L77: thesis by L76 , L75 , YELLOW_0:def 2;
end;
theorem
L78: (for B43 being  antisymmetric  transitive  with_infima  with_suprema RelStr holds (for B44 , B45 , B46 being (Element of B43) holds (B44 <= B45 implies ( B44 \ B46 ) <= ( B45 \ B46 )))) by L20;
theorem
L79: (for B47 being LATTICE holds (for B48 , B49 , B50 being (Element of B47) holds ((( B48 \ B49 ) <= B50 & ( B49 \ B48 ) <= B50) implies ( B48 \+\ B49 ) <= B50))) by L37;
theorem
L80: (for B51 being LATTICE holds (for B52 being (Element of B51) holds (B52 meets B52 iff B52 <> ( Bottom B51 ))))
proof
let C67 being LATTICE;
let C68 being (Element of C67);
thus L81: (C68 meets C68 implies C68 <> ( Bottom C67 ))
proof
assume L82: C68 meets C68;
L83: ( C68 "/\" C68 ) <> ( Bottom C67 ) by L82 , L67;
thus L84: thesis by L83 , L5;
end;

thus L85: (C68 <> ( Bottom C67 ) implies C68 meets C68)
proof
assume L86: C68 <> ( Bottom C67 );
L87: ( C68 "/\" C68 ) <> ( Bottom C67 ) by L86 , L5;
thus L88: thesis by L87 , L67;
end;

end;
theorem
L86: (for B53 being  antisymmetric  transitive  with_infima RelStr holds (B53 is  distributive implies (for B54 , B55 , B56 being (Element of B53) holds (( ( B54 "/\" B55 ) "\/" ( B54 "/\" B56 ) ) = B54 implies B54 <= ( B55 "\/" B56 )))))
proof
let C69 being  antisymmetric  transitive  with_infima RelStr;
assume that
L87: C69 is  distributive;
let C70 , C71 , C72 being (Element of C69);
assume L88: ( ( C70 "/\" C71 ) "\/" ( C70 "/\" C72 ) ) = C70;
L89: ( ( C71 "\/" C72 ) "/\" C70 ) = C70 by L88 , L87 , WAYBEL_1:def 3;
thus L90: thesis by L89 , YELLOW_0:23;
end;
theorem
L91: (for B57 being LATTICE holds (B57 is  distributive implies (for B58 , B59 , B60 being (Element of B57) holds ( B58 "\/" ( B59 "/\" B60 ) ) = ( ( B58 "\/" B59 ) "/\" ( B58 "\/" B60 ) ))))
proof
let C73 being LATTICE;
assume that
L92: C73 is  distributive;
let C74 , C75 , C76 being (Element of C73);
L93: ( ( C74 "\/" C75 ) "/\" ( C74 "\/" C76 ) ) = ( ( ( C74 "\/" C75 ) "/\" C74 ) "\/" ( ( C74 "\/" C75 ) "/\" C76 ) ) by L92 , WAYBEL_1:def 3
.= ( C74 "\/" ( ( C74 "\/" C75 ) "/\" C76 ) ) by LATTICE3:18
.= ( C74 "\/" ( ( C76 "/\" C74 ) "\/" ( C76 "/\" C75 ) ) ) by L92 , WAYBEL_1:def 3
.= ( ( C74 "\/" ( C76 "/\" C74 ) ) "\/" ( C76 "/\" C75 ) ) by LATTICE3:14
.= ( C74 "\/" ( C76 "/\" C75 ) ) by LATTICE3:17;
thus L94: thesis by L93;
end;
theorem
L95: (for B61 being LATTICE holds (B61 is  distributive implies (for B62 , B63 , B64 being (Element of B61) holds ( ( B62 "\/" B63 ) \ B64 ) = ( ( B62 \ B64 ) "\/" ( B63 \ B64 ) ))))
proof
let C77 being  with_suprema  with_infima  reflexive  transitive  antisymmetric non  empty RelStr;
assume that
L96: C77 is  distributive;
let C78 , C79 , C80 being (Element of C77);
thus L97: ( ( C78 "\/" C79 ) \ C80 ) = ( ( C78 "\/" C79 ) "/\" ( 'not' C80 ) )
.= ( ( ( 'not' C80 ) "/\" C78 ) "\/" ( ( 'not' C80 ) "/\" C79 ) ) by L96 , WAYBEL_1:def 3
.= ( ( C78 \ C80 ) "\/" ( C79 \ C80 ) );
end;
begin
theorem
L98: (for B65 being  lower-bounded non  empty  antisymmetric RelStr holds (for B66 being (Element of B65) holds (B66 <= ( Bottom B65 ) implies B66 = ( Bottom B65 ))))
proof
let C81 being  lower-bounded non  empty  antisymmetric RelStr;
let C82 being (Element of C81);
L99: ( Bottom C81 ) <= C82 by YELLOW_0:44;
assume L100: C82 <= ( Bottom C81 );
thus L101: thesis by L100 , L99 , YELLOW_0:def 3;
end;
theorem
L102: (for B67 being  lower-bounded Semilattice holds (for B68 , B69 , B70 being (Element of B67) holds ((B68 <= B69 & B68 <= B70 & ( B69 "/\" B70 ) = ( Bottom B67 )) implies B68 = ( Bottom B67 ))))
proof
let C83 being  lower-bounded Semilattice;
let C84 , C85 , C86 being (Element of C83);
assume that
L103: C84 <= C85
and
L104: C84 <= C86
and
L105: ( C85 "/\" C86 ) = ( Bottom C83 );
L106: ( C84 "/\" C86 ) <= ( C85 "/\" C86 ) by L103 , L20;
L107: C84 <= ( C85 "/\" C86 ) by L106 , L104 , L42;
thus L108: thesis by L107 , L105 , L98;
end;
theorem
L109: (for B71 being  lower-bounded  antisymmetric  with_suprema RelStr holds (for B72 , B73 being (Element of B71) holds (( B72 "\/" B73 ) = ( Bottom B71 ) implies (B72 = ( Bottom B71 ) & B73 = ( Bottom B71 )))))
proof
let C87 being  lower-bounded  antisymmetric  with_suprema RelStr;
let C88 , C89 being (Element of C87);
assume L110: ( C88 "\/" C89 ) = ( Bottom C87 );
L111: (C88 <= ( Bottom C87 ) & C89 <= ( Bottom C87 )) by L110 , YELLOW_0:22;
thus L112: thesis by L111 , L98;
end;
theorem
L113: (for B74 being  lower-bounded  antisymmetric  transitive  with_infima RelStr holds (for B75 , B76 , B77 being (Element of B74) holds ((B75 <= B76 & ( B76 "/\" B77 ) = ( Bottom B74 )) implies ( B75 "/\" B77 ) = ( Bottom B74 ))))
proof
let C90 being  lower-bounded  antisymmetric  transitive  with_infima RelStr;
let C91 , C92 , C93 being (Element of C90);
assume L114: (C91 <= C92 & ( C92 "/\" C93 ) = ( Bottom C90 ));
L115: ( C91 "/\" C93 ) <= ( Bottom C90 ) by L114 , L20;
L116: ( Bottom C90 ) <= ( C91 "/\" C93 ) by YELLOW_0:44;
thus L117: thesis by L116 , L115 , YELLOW_0:def 3;
end;
theorem
L118: (for B78 being  lower-bounded Semilattice holds (for B79 being (Element of B78) holds ( ( Bottom B78 ) \ B79 ) = ( Bottom B78 )))
proof
let C94 being  lower-bounded Semilattice;
let C95 being (Element of C94);
thus L119: ( ( Bottom C94 ) \ C95 ) = ( ( Bottom C94 ) "/\" ( 'not' C95 ) )
.= ( Bottom C94 ) by L42 , YELLOW_0:44;
end;
theorem
L120: (for B80 being  lower-bounded  antisymmetric  transitive  with_infima RelStr holds (for B81 , B82 , B83 being (Element of B80) holds ((B81 meets B82 & B82 <= B83) implies B81 meets B83)))
proof
let C96 being  lower-bounded  antisymmetric  transitive  with_infima RelStr;
let C97 , C98 , C99 being (Element of C96);
assume L121: C97 meets C98;
L122: ( Bottom C96 ) <= ( C97 "/\" C98 ) by YELLOW_0:44;
assume L123: C98 <= C99;
L124: ( C97 "/\" C98 ) <= ( C97 "/\" C99 ) by L123 , L20;
assume L125: (not C97 meets C99);
L126: (not ( C97 "/\" C99 ) <> ( Bottom C96 )) by L125 , L67;
L127: ( C97 "/\" C98 ) = ( Bottom C96 ) by L126 , L124 , L122 , YELLOW_0:def 3;
thus L128: contradiction by L127 , L121 , L67;
end;
theorem
L129: (for B84 being  lower-bounded  with_infima  antisymmetric RelStr holds (for B85 being (Element of B84) holds ( B85 "/\" ( Bottom B84 ) ) = ( Bottom B84 )))
proof
let C100 being  lower-bounded  with_infima  antisymmetric RelStr;
let C101 being (Element of C100);
L130: (( Bottom C100 ) <= ( C101 "/\" ( Bottom C100 ) ) & ( C101 "/\" ( Bottom C100 ) ) <= ( Bottom C100 )) by YELLOW_0:23 , YELLOW_0:44;
thus L131: thesis by L130 , YELLOW_0:def 3;
end;
theorem
L132: (for B86 being  lower-bounded  antisymmetric  transitive  with_infima  with_suprema RelStr holds (for B87 , B88 , B89 being (Element of B86) holds (B87 meets ( B88 "/\" B89 ) implies B87 meets B88)))
proof
let C102 being  lower-bounded  antisymmetric  transitive  with_infima  with_suprema RelStr;
let C103 , C104 , C105 being (Element of C102);
assume L133: C103 meets ( C104 "/\" C105 );
assume L134: (not C103 meets C104);
L135: ( C103 "/\" ( C104 "/\" C105 ) ) = ( ( C103 "/\" C104 ) "/\" C105 ) by LATTICE3:16
.= ( ( Bottom C102 ) "/\" C105 ) by L134 , L67
.= ( Bottom C102 ) by L129;
thus L136: contradiction by L135 , L133 , L67;
end;
theorem
L137: (for B90 being  lower-bounded  antisymmetric  transitive  with_infima  with_suprema RelStr holds (for B91 , B92 , B93 being (Element of B90) holds (B91 meets ( B92 \ B93 ) implies B91 meets B92)))
proof
let C106 being  lower-bounded  antisymmetric  transitive  with_infima  with_suprema RelStr;
let C107 , C108 , C109 being (Element of C106);
assume L138: C107 meets ( C108 \ C109 );
assume L139: (not C107 meets C108);
L140: ( C107 "/\" ( C108 \ C109 ) ) = ( ( C107 "/\" C108 ) "/\" ( 'not' C109 ) ) by LATTICE3:16
.= ( ( Bottom C106 ) "/\" ( 'not' C109 ) ) by L139 , L67
.= ( Bottom C106 ) by L129;
thus L141: contradiction by L140 , L138 , L67;
end;
theorem
L142: (for B94 being  lower-bounded  antisymmetric  transitive  with_infima RelStr holds (for B95 being (Element of B94) holds B95 misses ( Bottom B94 )))
proof
let C110 being  lower-bounded  antisymmetric  transitive  with_infima RelStr;
let C111 being (Element of C110);
L143: ( C111 "/\" ( Bottom C110 ) ) = ( Bottom C110 ) by L129;
thus L144: thesis by L143 , L67;
end;
theorem
L145: (for B96 being  lower-bounded  antisymmetric  transitive  with_infima RelStr holds (for B97 , B98 , B99 being (Element of B96) holds ((B97 misses B99 & B98 <= B99) implies B97 misses B98)))
proof
let C112 being  lower-bounded  antisymmetric  transitive  with_infima RelStr;
let C113 , C114 , C115 being (Element of C112);
assume that
L146: C113 misses C115
and
L147: C114 <= C115;
L148: ( C113 "/\" C115 ) = ( Bottom C112 ) by L146 , L67;
L149: ( C113 "/\" C114 ) <= ( Bottom C112 ) by L148 , L147 , L20;
L150: ( Bottom C112 ) <= ( C113 "/\" C114 ) by YELLOW_0:44;
L151: ( C113 "/\" C114 ) = ( Bottom C112 ) by L150 , L149 , YELLOW_0:def 3;
thus L152: thesis by L151 , L67;
end;
theorem
L153: (for B100 being  lower-bounded  antisymmetric  transitive  with_infima RelStr holds (for B101 , B102 , B103 being (Element of B100) holds ((B101 misses B102 or B101 misses B103) implies B101 misses ( B102 "/\" B103 ))))
proof
let C116 being  lower-bounded  antisymmetric  transitive  with_infima RelStr;
let C117 , C118 , C119 being (Element of C116);
assume L154: (C117 misses C118 or C117 misses C119);
per cases  by L154;
suppose L155: C117 misses C118;

L156: ( C117 "/\" ( C118 "/\" C119 ) ) = ( ( C117 "/\" C118 ) "/\" C119 ) by LATTICE3:16
.= ( ( Bottom C116 ) "/\" C119 ) by L155 , L67
.= ( Bottom C116 ) by L129;
thus L157: thesis by L156 , L67;
end;
suppose L158: C117 misses C119;

L159: ( C117 "/\" ( C118 "/\" C119 ) ) = ( ( C117 "/\" C119 ) "/\" C118 ) by LATTICE3:16
.= ( ( Bottom C116 ) "/\" C118 ) by L158 , L67
.= ( Bottom C116 ) by L129;
thus L160: thesis by L159 , L67;
end;
end;
theorem
L162: (for B104 being  lower-bounded LATTICE holds (for B105 , B106 , B107 being (Element of B104) holds ((B105 <= B106 & B105 <= B107 & B106 misses B107) implies B105 = ( Bottom B104 ))))
proof
let C120 being  lower-bounded LATTICE;
let C121 , C122 , C123 being (Element of C120);
assume that
L163: C121 <= C122
and
L164: C121 <= C123
and
L165: C122 misses C123;
L166: ( C122 "/\" C123 ) = ( Bottom C120 ) by L165 , L67;
L167: (( Bottom C120 ) <= ( C121 "/\" C123 ) & ( C121 "/\" C123 ) <= ( Bottom C120 )) by L166 , L163 , L20 , YELLOW_0:44;
L168: ( C121 "/\" C123 ) = ( Bottom C120 ) by L167 , YELLOW_0:def 3;
thus L169: thesis by L168 , L164 , L42;
end;
theorem
L170: (for B108 being  lower-bounded  antisymmetric  transitive  with_infima RelStr holds (for B109 , B110 , B111 being (Element of B108) holds (B109 misses B110 implies ( B109 "/\" B111 ) misses ( B110 "/\" B111 ))))
proof
let C124 being  lower-bounded  antisymmetric  transitive  with_infima RelStr;
let C125 , C126 , C127 being (Element of C124);
assume L171: C125 misses C126;
L172: ( ( C125 "/\" C127 ) "/\" ( C126 "/\" C127 ) ) = ( C127 "/\" ( C125 "/\" ( C126 "/\" C127 ) ) ) by LATTICE3:16
.= ( ( C127 "/\" ( C125 "/\" C126 ) ) "/\" C127 ) by LATTICE3:16
.= ( ( C127 "/\" ( Bottom C124 ) ) "/\" C127 ) by L171 , L67
.= ( ( Bottom C124 ) "/\" C127 ) by L129
.= ( Bottom C124 ) by L129;
thus L173: thesis by L172 , L67;
end;
begin
theorem
L174: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( ( R2 "/\" R3 ) "\/" ( R3 "/\" R4 ) ) "\/" ( R4 "/\" R2 ) ) = ( ( ( R2 "\/" R3 ) "/\" ( R3 "\/" R4 ) ) "/\" ( R4 "\/" R2 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
L175: ( ( ( R2 "/\" R3 ) "\/" ( R3 "/\" R4 ) ) "\/" ( R4 "/\" R2 ) ) = ( ( ( R2 "\/" ( R3 "/\" R4 ) ) "/\" ( R3 "\/" ( R3 "/\" R4 ) ) ) "\/" ( R4 "/\" R2 ) ) by WAYBEL_1:5
.= ( ( ( R2 "\/" ( R3 "/\" R4 ) ) "/\" R3 ) "\/" ( R4 "/\" R2 ) ) by LATTICE3:17
.= ( ( ( R2 "\/" ( R3 "/\" R4 ) ) "\/" ( R4 "/\" R2 ) ) "/\" ( R3 "\/" ( R4 "/\" R2 ) ) ) by WAYBEL_1:5
.= ( ( ( R2 "\/" ( R3 "/\" R4 ) ) "\/" ( R4 "/\" R2 ) ) "/\" ( ( R3 "\/" R4 ) "/\" ( R3 "\/" R2 ) ) ) by WAYBEL_1:5
.= ( ( ( R3 "/\" R4 ) "\/" ( R2 "\/" ( R4 "/\" R2 ) ) ) "/\" ( ( R3 "\/" R4 ) "/\" ( R3 "\/" R2 ) ) ) by LATTICE3:14
.= ( ( ( R3 "/\" R4 ) "\/" R2 ) "/\" ( ( R3 "\/" R4 ) "/\" ( R3 "\/" R2 ) ) ) by LATTICE3:17
.= ( ( ( R3 "\/" R2 ) "/\" ( R4 "\/" R2 ) ) "/\" ( ( R3 "\/" R4 ) "/\" ( R3 "\/" R2 ) ) ) by WAYBEL_1:5
.= ( ( R3 "\/" R2 ) "/\" ( ( ( R4 "\/" R2 ) "/\" ( R3 "\/" R2 ) ) "/\" ( R3 "\/" R4 ) ) ) by LATTICE3:16
.= ( ( R3 "\/" R2 ) "/\" ( ( R3 "\/" R2 ) "/\" ( ( R4 "\/" R2 ) "/\" ( R3 "\/" R4 ) ) ) ) by LATTICE3:16
.= ( ( ( R3 "\/" R2 ) "/\" ( R3 "\/" R2 ) ) "/\" ( ( R4 "\/" R2 ) "/\" ( R3 "\/" R4 ) ) ) by LATTICE3:16
.= ( ( R3 "\/" R2 ) "/\" ( ( R4 "\/" R2 ) "/\" ( R3 "\/" R4 ) ) ) by L5
.= ( ( ( R2 "\/" R3 ) "/\" ( R3 "\/" R4 ) ) "/\" ( R4 "\/" R2 ) ) by LATTICE3:16;
thus L176: thesis by L175;
end;
theorem
L177: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (( R2 "/\" ( 'not' R2 ) ) = ( Bottom R1 ) & ( R2 "\/" ( 'not' R2 ) ) = ( Top R1 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
L178: ( 'not' R2 ) is_a_complement_of R2 by L47;
thus L179: thesis by L178 , WAYBEL_1:def 23;
end;
theorem
L180: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds (( R2 \ R3 ) <= R4 implies R2 <= ( R3 "\/" R4 ))))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
L181: R2 <= ( R2 "\/" R3 ) by YELLOW_0:22;
assume L182: ( R2 \ R3 ) <= R4;
L183: ( ( R2 "/\" ( 'not' R3 ) ) "\/" R3 ) <= ( R4 "\/" R3 ) by L182 , L26;
L184: ( ( R2 "/\" ( 'not' R3 ) ) "\/" R3 ) = ( ( R3 "\/" R2 ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) by L91
.= ( ( R3 "\/" R2 ) "/\" ( Top R1 ) ) by L177
.= ( R2 "\/" R3 ) by WAYBEL_1:4;
thus L185: thesis by L184 , L183 , L181 , YELLOW_0:def 2;
end;
theorem
L186: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (( 'not' ( R2 "\/" R3 ) ) = ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) & ( 'not' ( R2 "/\" R3 ) ) = ( ( 'not' R2 ) "\/" ( 'not' R3 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
L187: ( ( R2 "\/" R3 ) "/\" ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) ) = ( ( ( R2 "\/" R3 ) "/\" ( 'not' R2 ) ) "/\" ( 'not' R3 ) ) by LATTICE3:16
.= ( ( ( ( 'not' R2 ) "/\" R2 ) "\/" ( ( 'not' R2 ) "/\" R3 ) ) "/\" ( 'not' R3 ) ) by WAYBEL_1:def 3
.= ( ( ( Bottom R1 ) "\/" ( ( 'not' R2 ) "/\" R3 ) ) "/\" ( 'not' R3 ) ) by L177
.= ( ( ( 'not' R2 ) "/\" R3 ) "/\" ( 'not' R3 ) ) by WAYBEL_1:3
.= ( ( 'not' R2 ) "/\" ( R3 "/\" ( 'not' R3 ) ) ) by LATTICE3:16
.= ( ( 'not' R2 ) "/\" ( Bottom R1 ) ) by L177
.= ( Bottom R1 ) by WAYBEL_1:3;
L188: ( ( R2 "\/" R3 ) "\/" ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) ) = ( R2 "\/" ( R3 "\/" ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) ) ) by LATTICE3:14
.= ( R2 "\/" ( ( R3 "\/" ( 'not' R2 ) ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) ) by L91
.= ( R2 "\/" ( ( R3 "\/" ( 'not' R2 ) ) "/\" ( Top R1 ) ) ) by L177
.= ( R2 "\/" ( R3 "\/" ( 'not' R2 ) ) ) by WAYBEL_1:4
.= ( ( R2 "\/" ( 'not' R2 ) ) "\/" R3 ) by LATTICE3:14
.= ( ( Top R1 ) "\/" R3 ) by L177
.= ( Top R1 ) by WAYBEL_1:4;
L189: ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) is_a_complement_of ( R2 "\/" R3 ) by L188 , L187 , WAYBEL_1:def 23;
thus L190: ( 'not' ( R2 "\/" R3 ) ) = ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) by L189 , L47;
L191: ( ( R2 "/\" R3 ) "/\" ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) ) = ( R2 "/\" ( R3 "/\" ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) ) ) by LATTICE3:16
.= ( R2 "/\" ( ( R3 "/\" ( 'not' R2 ) ) "\/" ( R3 "/\" ( 'not' R3 ) ) ) ) by WAYBEL_1:def 3
.= ( R2 "/\" ( ( R3 "/\" ( 'not' R2 ) ) "\/" ( Bottom R1 ) ) ) by L177
.= ( R2 "/\" ( R3 "/\" ( 'not' R2 ) ) ) by WAYBEL_1:3
.= ( ( R2 "/\" ( 'not' R2 ) ) "/\" R3 ) by LATTICE3:16
.= ( ( Bottom R1 ) "/\" R3 ) by L177
.= ( Bottom R1 ) by WAYBEL_1:3;
L192: ( ( R2 "/\" R3 ) "\/" ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) ) = ( ( ( R2 "/\" R3 ) "\/" ( 'not' R2 ) ) "\/" ( 'not' R3 ) ) by LATTICE3:14
.= ( ( ( ( 'not' R2 ) "\/" R2 ) "/\" ( ( 'not' R2 ) "\/" R3 ) ) "\/" ( 'not' R3 ) ) by L91
.= ( ( ( Top R1 ) "/\" ( ( 'not' R2 ) "\/" R3 ) ) "\/" ( 'not' R3 ) ) by L177
.= ( ( ( 'not' R2 ) "\/" R3 ) "\/" ( 'not' R3 ) ) by WAYBEL_1:4
.= ( ( 'not' R2 ) "\/" ( R3 "\/" ( 'not' R3 ) ) ) by LATTICE3:14
.= ( ( 'not' R2 ) "\/" ( Top R1 ) ) by L177
.= ( Top R1 ) by WAYBEL_1:4;
L193: ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) is_a_complement_of ( R2 "/\" R3 ) by L192 , L191 , WAYBEL_1:def 23;
thus L194: ( 'not' ( R2 "/\" R3 ) ) = ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) by L193 , L47;
end;
theorem
L195: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <= R3 implies ( 'not' R3 ) <= ( 'not' R2 )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L196: R2 <= R3;
L197: ( 'not' R2 ) = ( 'not' ( R3 "/\" R2 ) ) by L196 , L42
.= ( ( 'not' R3 ) "\/" ( 'not' R2 ) ) by L186;
thus L198: thesis by L197 , YELLOW_0:22;
end;
theorem
L199: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds (R2 <= R3 implies ( R4 \ R3 ) <= ( R4 \ R2 ))))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
assume L200: R2 <= R3;
L201: ( 'not' R3 ) <= ( 'not' R2 ) by L200 , L195;
L202: ( R4 "/\" ( 'not' R3 ) ) <= ( R4 "/\" ( 'not' R2 ) ) by L201 , L20;
thus L203: thesis by L202;
end;
theorem
L204: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds (for R5 being (Element of R1) holds ((R2 <= R3 & R4 <= R5) implies ( R2 \ R5 ) <= ( R3 \ R4 )))))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
let R5 being (Element of R1);
assume that
L205: R2 <= R3
and
L206: R4 <= R5;
L207: ( 'not' R5 ) <= ( 'not' R4 ) by L206 , L195;
L208: ( R2 "/\" ( 'not' R5 ) ) <= ( R2 "/\" ( 'not' R4 ) ) by L207 , L20;
L209: ( R2 "/\" ( 'not' R4 ) ) <= ( R3 "/\" ( 'not' R4 ) ) by L205 , L20;
thus L210: thesis by L209 , L208 , YELLOW_0:def 2;
end;
theorem
L211: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds (R2 <= ( R3 "\/" R4 ) implies (( R2 \ R3 ) <= R4 & ( R2 \ R4 ) <= R3))))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
assume L212: R2 <= ( R3 "\/" R4 );
L213: ( ( R3 "\/" R4 ) "/\" ( 'not' R3 ) ) = ( ( ( 'not' R3 ) "/\" R3 ) "\/" ( ( 'not' R3 ) "/\" R4 ) ) by WAYBEL_1:def 3
.= ( ( Bottom R1 ) "\/" ( ( 'not' R3 ) "/\" R4 ) ) by L177
.= ( R4 "/\" ( 'not' R3 ) ) by WAYBEL_1:3;
L214: (( R4 "/\" ( 'not' R3 ) ) <= R4 & ( R2 "/\" ( 'not' R3 ) ) <= ( R4 "/\" ( 'not' R3 ) )) by L213 , L212 , L20 , YELLOW_0:23;
thus L215: ( R2 \ R3 ) <= R4 by L214 , YELLOW_0:def 2;
L216: ( ( R3 "\/" R4 ) "/\" ( 'not' R4 ) ) = ( ( ( 'not' R4 ) "/\" R3 ) "\/" ( ( 'not' R4 ) "/\" R4 ) ) by WAYBEL_1:def 3
.= ( ( ( 'not' R4 ) "/\" R3 ) "\/" ( Bottom R1 ) ) by L177
.= ( ( 'not' R4 ) "/\" R3 ) by WAYBEL_1:3;
L217: (( ( 'not' R4 ) "/\" R3 ) <= R3 & ( R2 "/\" ( 'not' R4 ) ) <= ( ( 'not' R4 ) "/\" R3 )) by L216 , L212 , L20 , YELLOW_0:23;
thus L218: thesis by L217 , YELLOW_0:def 2;
end;
theorem
L219: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (( 'not' R2 ) <= ( 'not' ( R2 "/\" R3 ) ) & ( 'not' R3 ) <= ( 'not' ( R2 "/\" R3 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
L220: (( 'not' R2 ) <= ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) & ( 'not' R3 ) <= ( ( 'not' R2 ) "\/" ( 'not' R3 ) )) by YELLOW_0:22;
thus L221: thesis by L220 , L186;
end;
theorem
L222: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (( 'not' ( R2 "\/" R3 ) ) <= ( 'not' R2 ) & ( 'not' ( R2 "\/" R3 ) ) <= ( 'not' R3 )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
L223: (( ( 'not' R2 ) "/\" ( 'not' R3 ) ) <= ( 'not' R2 ) & ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) <= ( 'not' R3 )) by YELLOW_0:23;
thus L224: thesis by L223 , L186;
end;
theorem
L225: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <= ( R3 \ R2 ) implies R2 = ( Bottom R1 )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L226: R2 <= ( R3 \ R2 );
L227: ( ( R3 "/\" ( 'not' R2 ) ) "/\" R2 ) = ( R3 "/\" ( ( 'not' R2 ) "/\" R2 ) ) by LATTICE3:16
.= ( R3 "/\" ( Bottom R1 ) ) by L177
.= ( Bottom R1 ) by WAYBEL_1:3;
thus L228: thesis by L227 , L226 , L42;
end;
theorem
L229: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 <= R3 implies R3 = ( R2 "\/" ( R3 \ R2 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L230: R2 <= R3;
L231: ( R2 "\/" ( R3 \ R2 ) ) = ( ( R2 "\/" R3 ) "/\" ( R2 "\/" ( 'not' R2 ) ) ) by WAYBEL_1:5
.= ( R3 "/\" ( ( 'not' R2 ) "\/" R2 ) ) by L230 , L32
.= ( R3 "/\" ( Top R1 ) ) by L177
.= R3 by WAYBEL_1:4;
thus L232: thesis by L231;
end;
theorem
L233: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (( R2 \ R3 ) = ( Bottom R1 ) iff R2 <= R3))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L234: (( R2 \ R3 ) = ( Bottom R1 ) implies R2 <= R3)
proof
assume L235: ( R2 \ R3 ) = ( Bottom R1 );
L236: ( ( R3 "\/" R2 ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) <= ( R3 "\/" ( Bottom R1 ) ) by L235 , L91;
L237: ( ( R3 "\/" R2 ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) <= R3 by L236 , WAYBEL_1:3;
L238: ( ( R2 "\/" R3 ) "/\" ( Top R1 ) ) <= R3 by L237 , L177;
L239: ( R2 "\/" R3 ) <= R3 by L238 , WAYBEL_1:4;
L240: R2 <= ( R2 "\/" R3 ) by YELLOW_0:22;
thus L241: thesis by L240 , L239 , YELLOW_0:def 2;
end;

thus L242: (R2 <= R3 implies ( R2 \ R3 ) = ( Bottom R1 ))
proof
assume L243: R2 <= R3;
L244: ( R2 "/\" ( 'not' R3 ) ) <= ( R3 "/\" ( 'not' R3 ) ) by L243 , L20;
L245: ( R2 "/\" ( 'not' R3 ) ) <= ( Bottom R1 ) by L244 , L177;
L246: ( Bottom R1 ) <= ( R2 \ R3 ) by YELLOW_0:44;
thus L247: thesis by L246 , L245 , YELLOW_0:def 3;
end;

end;
theorem
L243: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ((R2 <= ( R3 "\/" R4 ) & ( R2 "/\" R4 ) = ( Bottom R1 )) implies R2 <= R3)))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
assume L244: (R2 <= ( R3 "\/" R4 ) & ( R2 "/\" R4 ) = ( Bottom R1 ));
L245: (( R2 "/\" ( R3 "\/" R4 ) ) = R2 & ( R2 "/\" ( R3 "\/" R4 ) ) = ( ( R2 "/\" R3 ) "\/" ( Bottom R1 ) )) by L244 , L42 , WAYBEL_1:def 3;
L246: ( R2 "/\" R3 ) = R2 by L245 , WAYBEL_1:3;
thus L247: thesis by L246 , YELLOW_0:23;
end;
theorem
L248: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 "\/" R3 ) = ( ( R2 \ R3 ) "\/" R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L249: ( ( R2 \ R3 ) "\/" R3 ) = ( ( R3 "\/" R2 ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) by L91
.= ( ( R3 "\/" R2 ) "/\" ( Top R1 ) ) by L177
.= ( R2 "\/" R3 ) by WAYBEL_1:4;
end;
theorem
L250: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 \ ( R2 "\/" R3 ) ) = ( Bottom R1 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L251: ( R2 \ ( R2 "\/" R3 ) ) = ( R2 "/\" ( ( 'not' R2 ) "/\" ( 'not' R3 ) ) ) by L186
.= ( ( R2 "/\" ( 'not' R2 ) ) "/\" ( 'not' R3 ) ) by LATTICE3:16
.= ( ( Bottom R1 ) "/\" ( 'not' R3 ) ) by L177
.= ( Bottom R1 ) by WAYBEL_1:3;
end;
theorem
L252: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 \ ( R2 "/\" R3 ) ) = ( R2 \ R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L253: ( R2 \ ( R2 "/\" R3 ) ) = ( R2 "/\" ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) ) by L186
.= ( ( R2 "/\" ( 'not' R2 ) ) "\/" ( R2 "/\" ( 'not' R3 ) ) ) by WAYBEL_1:def 3
.= ( ( Bottom R1 ) "\/" ( R2 "/\" ( 'not' R3 ) ) ) by L177
.= ( R2 \ R3 ) by WAYBEL_1:3;
end;
theorem
L254: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( ( R2 \ R3 ) "/\" R3 ) = ( Bottom R1 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L255: ( ( R2 \ R3 ) "/\" R3 ) = ( R2 "/\" ( ( 'not' R3 ) "/\" R3 ) ) by LATTICE3:16
.= ( R2 "/\" ( Bottom R1 ) ) by L177
.= ( Bottom R1 ) by WAYBEL_1:3;
end;
theorem
L256: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 "\/" ( R3 \ R2 ) ) = ( R2 "\/" R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L257: ( R2 "\/" ( R3 \ R2 ) ) = ( ( R2 "\/" R3 ) "/\" ( R2 "\/" ( 'not' R2 ) ) ) by L91
.= ( ( R2 "\/" R3 ) "/\" ( Top R1 ) ) by L177
.= ( R2 "\/" R3 ) by WAYBEL_1:4;
end;
theorem
L258: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( ( R2 "/\" R3 ) "\/" ( R2 \ R3 ) ) = R2)))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L259: ( ( R2 "/\" R3 ) "\/" ( R2 \ R3 ) ) = ( ( ( R2 "/\" R3 ) "\/" R2 ) "/\" ( ( R2 "/\" R3 ) "\/" ( 'not' R3 ) ) ) by L91
.= ( R2 "/\" ( ( R2 "/\" R3 ) "\/" ( 'not' R3 ) ) ) by LATTICE3:17
.= ( R2 "/\" ( ( ( 'not' R3 ) "\/" R2 ) "/\" ( ( 'not' R3 ) "\/" R3 ) ) ) by L91
.= ( R2 "/\" ( ( ( 'not' R3 ) "\/" R2 ) "/\" ( Top R1 ) ) ) by L177
.= ( R2 "/\" ( ( 'not' R3 ) "\/" R2 ) ) by WAYBEL_1:4
.= R2 by LATTICE3:18;
end;
theorem
L260: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 \ ( R3 \ R4 ) ) = ( ( R2 \ R3 ) "\/" ( R2 "/\" R4 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
thus L261: ( R2 \ ( R3 \ R4 ) ) = ( R2 "/\" ( ( 'not' R3 ) "\/" ( 'not' ( 'not' R4 ) ) ) ) by L186
.= ( R2 "/\" ( ( 'not' R3 ) "\/" R4 ) ) by WAYBEL_1:87
.= ( ( R2 \ R3 ) "\/" ( R2 "/\" R4 ) ) by WAYBEL_1:def 3;
end;
theorem
L262: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 \ ( R2 \ R3 ) ) = ( R2 "/\" R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L263: ( R2 \ ( R2 \ R3 ) ) = ( R2 "/\" ( ( 'not' R2 ) "\/" ( 'not' ( 'not' R3 ) ) ) ) by L186
.= ( R2 "/\" ( ( 'not' R2 ) "\/" R3 ) ) by WAYBEL_1:87
.= ( ( R2 "/\" ( 'not' R2 ) ) "\/" ( R2 "/\" R3 ) ) by WAYBEL_1:def 3
.= ( ( Bottom R1 ) "\/" ( R2 "/\" R3 ) ) by L177
.= ( R2 "/\" R3 ) by WAYBEL_1:3;
end;
theorem
L264: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( ( R2 "\/" R3 ) \ R3 ) = ( R2 \ R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L265: ( ( R2 "\/" R3 ) \ R3 ) = ( ( R2 "\/" R3 ) "/\" ( 'not' R3 ) )
.= ( ( R2 "/\" ( 'not' R3 ) ) "\/" ( R3 "/\" ( 'not' R3 ) ) ) by WAYBEL_1:def 3
.= ( ( R2 "/\" ( 'not' R3 ) ) "\/" ( Bottom R1 ) ) by L177
.= ( R2 \ R3 ) by WAYBEL_1:3;
end;
theorem
L266: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (( R2 "/\" R3 ) = ( Bottom R1 ) iff ( R2 \ R3 ) = R2))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L267: (( R2 "/\" R3 ) = ( Bottom R1 ) implies ( R2 \ R3 ) = R2)
proof
assume L268: ( R2 "/\" R3 ) = ( Bottom R1 );
L269: R2 <= ( 'not' R3 ) by L268 , WAYBEL_1:82;
L270: ( R2 "/\" R2 ) <= ( R2 "/\" ( 'not' R3 ) ) by L269 , L20;
L271: R2 <= ( R2 "/\" ( 'not' R3 ) ) by L270 , L5;
L272: ( R2 \ R3 ) <= R2 by YELLOW_0:23;
thus L273: thesis by L272 , L271 , YELLOW_0:def 3;
end;

thus L274: (( R2 \ R3 ) = R2 implies ( R2 "/\" R3 ) = ( Bottom R1 ))
proof
assume L275: ( R2 \ R3 ) = R2;
L276: ( ( 'not' R2 ) "\/" ( 'not' ( 'not' R3 ) ) ) = ( 'not' R2 ) by L275 , L186;
L277: ( R2 "/\" ( ( 'not' R2 ) "\/" R3 ) ) <= ( R2 "/\" ( 'not' R2 ) ) by L276 , WAYBEL_1:87;
L278: ( ( R2 "/\" ( 'not' R2 ) ) "\/" ( R2 "/\" R3 ) ) <= ( R2 "/\" ( 'not' R2 ) ) by L277 , WAYBEL_1:def 3;
L279: ( ( Bottom R1 ) "\/" ( R2 "/\" R3 ) ) <= ( R2 "/\" ( 'not' R2 ) ) by L278 , L177;
L280: ( ( Bottom R1 ) "\/" ( R2 "/\" R3 ) ) <= ( Bottom R1 ) by L279 , L177;
L281: ( R2 "/\" R3 ) <= ( Bottom R1 ) by L280 , WAYBEL_1:3;
L282: ( Bottom R1 ) <= ( R2 "/\" R3 ) by YELLOW_0:44;
thus L283: thesis by L282 , L281 , YELLOW_0:def 3;
end;

end;
theorem
L275: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 \ ( R3 "\/" R4 ) ) = ( ( R2 \ R3 ) "/\" ( R2 \ R4 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
thus L276: ( R2 \ ( R3 "\/" R4 ) ) = ( R2 "/\" ( ( 'not' R3 ) "/\" ( 'not' R4 ) ) ) by L186
.= ( ( R2 "/\" R2 ) "/\" ( ( 'not' R3 ) "/\" ( 'not' R4 ) ) ) by L5
.= ( ( ( R2 "/\" R2 ) "/\" ( 'not' R3 ) ) "/\" ( 'not' R4 ) ) by LATTICE3:16
.= ( ( R2 "/\" ( R2 "/\" ( 'not' R3 ) ) ) "/\" ( 'not' R4 ) ) by LATTICE3:16
.= ( ( R2 \ R3 ) "/\" ( R2 \ R4 ) ) by LATTICE3:16;
end;
theorem
L277: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 \ ( R3 "/\" R4 ) ) = ( ( R2 \ R3 ) "\/" ( R2 \ R4 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
thus L278: ( R2 \ ( R3 "/\" R4 ) ) = ( R2 "/\" ( ( 'not' R3 ) "\/" ( 'not' R4 ) ) ) by L186
.= ( ( R2 \ R3 ) "\/" ( R2 \ R4 ) ) by WAYBEL_1:def 3;
end;
theorem
L279: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( R2 "/\" ( R3 \ R4 ) ) = ( ( R2 "/\" R3 ) \ ( R2 "/\" R4 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
thus L280: ( ( R2 "/\" R3 ) \ ( R2 "/\" R4 ) ) = ( ( R2 "/\" R3 ) "/\" ( ( 'not' R2 ) "\/" ( 'not' R4 ) ) ) by L186
.= ( ( ( R2 "/\" R3 ) "/\" ( 'not' R2 ) ) "\/" ( ( R2 "/\" R3 ) "/\" ( 'not' R4 ) ) ) by WAYBEL_1:def 3
.= ( ( ( R2 "/\" ( 'not' R2 ) ) "/\" R3 ) "\/" ( ( R2 "/\" R3 ) "/\" ( 'not' R4 ) ) ) by LATTICE3:16
.= ( ( ( Bottom R1 ) "/\" R3 ) "\/" ( ( R2 "/\" R3 ) "/\" ( 'not' R4 ) ) ) by L177
.= ( ( Bottom R1 ) "\/" ( ( R2 "/\" R3 ) "/\" ( 'not' R4 ) ) ) by WAYBEL_1:3
.= ( ( R2 "/\" R3 ) "/\" ( 'not' R4 ) ) by WAYBEL_1:3
.= ( R2 "/\" ( R3 \ R4 ) ) by LATTICE3:16;
end;
theorem
L281: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( ( R2 "\/" R3 ) \ ( R2 "/\" R3 ) ) = ( ( R2 \ R3 ) "\/" ( R3 \ R2 ) ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L282: ( ( R2 "\/" R3 ) \ ( R2 "/\" R3 ) ) = ( ( R2 "\/" R3 ) "/\" ( ( 'not' R2 ) "\/" ( 'not' R3 ) ) ) by L186
.= ( ( ( R2 "\/" R3 ) "/\" ( 'not' R2 ) ) "\/" ( ( R2 "\/" R3 ) "/\" ( 'not' R3 ) ) ) by WAYBEL_1:def 3
.= ( ( ( R2 "/\" ( 'not' R2 ) ) "\/" ( R3 "/\" ( 'not' R2 ) ) ) "\/" ( ( R2 "\/" R3 ) "/\" ( 'not' R3 ) ) ) by WAYBEL_1:def 3
.= ( ( ( Bottom R1 ) "\/" ( R3 "/\" ( 'not' R2 ) ) ) "\/" ( ( R2 "\/" R3 ) "/\" ( 'not' R3 ) ) ) by L177
.= ( ( R3 \ R2 ) "\/" ( ( R2 "\/" R3 ) "/\" ( 'not' R3 ) ) ) by WAYBEL_1:3
.= ( ( R3 \ R2 ) "\/" ( ( R2 "/\" ( 'not' R3 ) ) "\/" ( R3 "/\" ( 'not' R3 ) ) ) ) by WAYBEL_1:def 3
.= ( ( R3 \ R2 ) "\/" ( ( R2 "/\" ( 'not' R3 ) ) "\/" ( Bottom R1 ) ) ) by L177
.= ( ( R2 \ R3 ) "\/" ( R3 \ R2 ) ) by WAYBEL_1:3;
end;
theorem
L283: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R4 being (Element of R1) holds ( ( R2 \ R3 ) \ R4 ) = ( R2 \ ( R3 "\/" R4 ) )))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R4 being (Element of R1);
thus L284: ( ( R2 \ R3 ) \ R4 ) = ( R2 "/\" ( ( 'not' R3 ) "/\" ( 'not' R4 ) ) ) by LATTICE3:16
.= ( R2 \ ( R3 "\/" R4 ) ) by L186;
end;
theorem
L285: (for R1 being  Boolean non  empty RelStr holds ( 'not' ( Bottom R1 ) ) = ( Top R1 ))
proof
let R1 being  Boolean non  empty RelStr;
L286: (( ( Bottom R1 ) "/\" ( Top R1 ) ) = ( Bottom R1 ) & ( ( Bottom R1 ) "\/" ( Top R1 ) ) = ( Top R1 )) by WAYBEL_1:3;
L287: ( Top R1 ) is_a_complement_of ( Bottom R1 ) by L286 , WAYBEL_1:def 23;
thus L288: thesis by L287 , L47;
end;
theorem
L289: (for R1 being  Boolean non  empty RelStr holds ( 'not' ( Top R1 ) ) = ( Bottom R1 ))
proof
let R1 being  Boolean non  empty RelStr;
L290: (( ( Bottom R1 ) "/\" ( Top R1 ) ) = ( Bottom R1 ) & ( ( Bottom R1 ) "\/" ( Top R1 ) ) = ( Top R1 )) by WAYBEL_1:3;
L291: ( Bottom R1 ) is_a_complement_of ( Top R1 ) by L290 , WAYBEL_1:def 23;
thus L292: thesis by L291 , L47;
end;
theorem
L293: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds ( R2 \ R2 ) = ( Bottom R1 ))) by L177;
theorem
L294: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds ( R2 \ ( Bottom R1 ) ) = R2))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
thus L295: ( R2 \ ( Bottom R1 ) ) = ( R2 "/\" ( Top R1 ) ) by L285
.= R2 by WAYBEL_1:4;
end;
theorem
L296: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( 'not' ( R2 \ R3 ) ) = ( ( 'not' R2 ) "\/" R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
thus L297: ( 'not' ( R2 \ R3 ) ) = ( ( 'not' R2 ) "\/" ( 'not' ( 'not' R3 ) ) ) by L186
.= ( ( 'not' R2 ) "\/" R3 ) by WAYBEL_1:87;
end;
theorem
L298: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 "/\" R3 ) misses ( R2 \ R3 ))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
L299: ( ( R2 "/\" R3 ) "/\" ( R2 \ R3 ) ) = ( ( ( R2 "/\" R3 ) "/\" ( 'not' R3 ) ) "/\" R2 ) by LATTICE3:16
.= ( ( R2 "/\" ( R3 "/\" ( 'not' R3 ) ) ) "/\" R2 ) by LATTICE3:16
.= ( ( R2 "/\" ( Bottom R1 ) ) "/\" R2 ) by L177
.= ( ( Bottom R1 ) "/\" R2 ) by WAYBEL_1:3
.= ( Bottom R1 ) by WAYBEL_1:3;
thus L300: thesis by L299 , L67;
end;
theorem
L301: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( R2 \ R3 ) misses R3)))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
L302: ( ( R2 \ R3 ) "/\" R3 ) = ( R2 "/\" ( ( 'not' R3 ) "/\" R3 ) ) by LATTICE3:16
.= ( R2 "/\" ( Bottom R1 ) ) by L177
.= ( Bottom R1 ) by WAYBEL_1:3;
thus L303: thesis by L302 , L67;
end;
theorem
L304: (for R1 being  Boolean non  empty RelStr holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (R2 misses R3 implies ( ( R2 "\/" R3 ) \ R3 ) = R2))))
proof
let R1 being  Boolean non  empty RelStr;
let R2 being (Element of R1);
let R3 being (Element of R1);
assume L305: R2 misses R3;
L306: ( R2 "/\" R3 ) = ( Bottom R1 ) by L305 , L67;
L307: ( ( R2 "\/" ( 'not' R3 ) ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) <= ( ( Bottom R1 ) "\/" ( 'not' R3 ) ) by L306 , L91;
L308: ( ( R2 "\/" ( 'not' R3 ) ) "/\" ( R3 "\/" ( 'not' R3 ) ) ) <= ( 'not' R3 ) by L307 , WAYBEL_1:3;
L309: ( ( R2 "\/" ( 'not' R3 ) ) "/\" ( Top R1 ) ) <= ( 'not' R3 ) by L308 , L177;
L310: ( R2 "\/" ( 'not' R3 ) ) <= ( 'not' R3 ) by L309 , WAYBEL_1:4;
L311: ( 'not' R3 ) <= ( R2 "\/" ( 'not' R3 ) ) by YELLOW_0:22;
L312: ( R2 "\/" ( 'not' R3 ) ) = ( 'not' R3 ) by L311 , L310 , YELLOW_0:def 3;
L313: R2 <= ( 'not' R3 ) by L312 , YELLOW_0:22;
L314: ( ( R2 "\/" R3 ) \ R3 ) = ( ( R2 "\/" R3 ) "/\" ( 'not' R3 ) )
.= ( ( R2 "/\" ( 'not' R3 ) ) "\/" ( R3 "/\" ( 'not' R3 ) ) ) by WAYBEL_1:def 3
.= ( ( R2 "/\" ( 'not' R3 ) ) "\/" ( Bottom R1 ) ) by L177
.= ( R2 "/\" ( 'not' R3 ) ) by WAYBEL_1:3
.= R2 by L313 , L42;
thus L315: thesis by L314;
end;
