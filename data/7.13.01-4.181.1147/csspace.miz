:: Complex Linear Space of Complex Sequences
::  by Noboru Endou
::
:: Received January 26, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, COMSEQ_1, FUNCT_2, TARSKI, RSSPACE, CFUNCT_1,
      BINOP_1, SUBSET_1, FUNCT_1, ARYTM_3, ZFMISC_1, VALUED_1, COMPLEX1,
      FUNCOP_1, RLVECT_1, CLVECT_1, RELAT_1, SUPINF_2, ARYTM_1, STRUCT_0,
      ALGSTR_0, RLSUB_1, REALSET1, SERIES_1, SEQ_1, CARD_1, XXREAL_0, REAL_1,
      SQUARE_1, BHSP_1, PRE_TOPC, PROB_2, XCMPLX_0, RVSUM_1, NORMSP_1,
      METRIC_1, NAT_1, CARD_3, SEQ_2, ORDINAL2, CSSPACE;
 notations TARSKI, XBOOLE_0, SUBSET_1, PRE_TOPC, RELAT_1, DOMAIN_1, FUNCT_1,
      FUNCT_2, FUNCOP_1, VALUED_1, SEQ_1, BINOP_1, REALSET1, XCMPLX_0,
      XXREAL_0, REAL_1, ORDINAL1, NAT_1, STRUCT_0, ALGSTR_0, ZFMISC_1, NUMBERS,
      SQUARE_1, COMPLEX1, COMSEQ_1, CFUNCT_1, COMSEQ_2, SERIES_1, COMSEQ_3,
      RLVECT_1, VFUNCT_1, NORMSP_1, BHSP_1, CLVECT_1;
 constructors BINOP_1, FUNCOP_1, REAL_1, SQUARE_1, SEQ_1, COMSEQ_2, COMSEQ_3,
      REALSET1, BHSP_1, CLVECT_1, RELSET_1, VFUNCT_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2,
      NUMBERS, XCMPLX_0, XXREAL_0, MEMBERED, REALSET1, STRUCT_0, CLVECT_1,
      ALGSTR_0, VALUED_1, VALUED_0, VFUNCT_1, SERIES_1;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;
 definitions TARSKI, RLVECT_1, CLVECT_1, STRUCT_0, REALSET1, SQUARE_1, BINOP_1,
      ALGSTR_0, VALUED_0;
 theorems XBOOLE_0, RELAT_1, SQUARE_1, TARSKI, ABSVALUE, ZFMISC_1, SEQ_1,
      SERIES_1, COMSEQ_3, FUNCT_1, FUNCT_2, RLVECT_1, BINOP_1, XCMPLX_0,
      COMSEQ_1, CLVECT_1, COMPLEX1, COMSEQ_2, NORMSP_1, FUNCOP_1, XREAL_1,
      XXREAL_0, BHSP_1, ALGSTR_0, VALUED_1, VALUED_0, ORDINAL1;
 schemes NAT_1, BINOP_1, XBOOLE_0, BINOP_2;

begin
definition
func the_set_of_ComplexSequences -> non  empty set means 
:L1: (for B1 being set holds (B1 in it iff B1 is Complex_Sequence));
existence
proof
defpred S1[ set ] means $1 is Complex_Sequence;
consider C1 being set such that L2: (for B2 being set holds (B2 in C1 iff (B2 in ( Funcs (( NAT ) , ( COMPLEX )) ) & S1[ B2 ]))) from XBOOLE_0:sch 1;
L3: C1 is non  empty
proof
set D1 = the Complex_Sequence;
L4: D1 in ( Funcs (( NAT ) , ( COMPLEX )) ) by FUNCT_2:8;
thus L5: thesis by L4 , L2;
end;
reconsider D2 = C1 as non  empty set by L3;
take D2;
L6: (for B3 being set holds (B3 is Complex_Sequence implies B3 in D2))
proof
let C2 being set;
assume L7: C2 is Complex_Sequence;
L8: C2 in ( Funcs (( NAT ) , ( COMPLEX )) ) by L7 , FUNCT_2:8;
thus L9: thesis by L8 , L2 , L7;
end;
thus L10: thesis by L6 , L2;
end;
uniqueness
proof
let C3 , C4 being non  empty set;
assume that
L11: (for B4 being set holds (B4 in C3 iff B4 is Complex_Sequence))
and
L12: (for B5 being set holds (B5 in C4 iff B5 is Complex_Sequence));
L13: C4 c= C3
proof
let C5 being set;
assume L14: C5 in C4;
L15: C5 is Complex_Sequence by L14 , L12;
thus L16: thesis by L15 , L11;
end;
L17: C3 c= C4
proof
let C6 being set;
assume L18: C6 in C3;
L19: C6 is Complex_Sequence by L18 , L11;
thus L20: thesis by L19 , L12;
end;
thus L21: thesis by L17 , L13 , XBOOLE_0:def 10;
end;
end;
definition
let C7 being set;
assume that
L23: C7 in ( the_set_of_ComplexSequences );
func seq_id C7 -> Complex_Sequence equals 
:L24: C7;
coherence by L23 , L1;
end;
definition
let C8 being set;
assume that
L26: C8 is Complex;
func C_id C8 -> Complex equals 
:L27: C8;
coherence by L26;
end;
definition
func l_add -> (BinOp of ( the_set_of_ComplexSequences )) means 
:L29: (for B6 , B7 being (Element of ( the_set_of_ComplexSequences )) holds ( it . (B6 , B7) ) = ( ( seq_id B6 ) + ( seq_id B7 ) ));
existence
proof
defpred S2[ (Element of ( the_set_of_ComplexSequences )) , (Element of ( the_set_of_ComplexSequences )) , (Element of ( the_set_of_ComplexSequences )) ] means $3 = ( ( seq_id $1 ) + ( seq_id $2 ) );
L30: (for B8 , B9 being (Element of ( the_set_of_ComplexSequences )) holds (ex B10 being (Element of ( the_set_of_ComplexSequences )) st S2[ B8 , B9 , B10 ]))
proof
let C9 , C10 being (Element of ( the_set_of_ComplexSequences ));
L31: ( ( seq_id C9 ) + ( seq_id C10 ) ) is (Element of ( the_set_of_ComplexSequences )) by L1;
thus L32: thesis by L31;
end;
L33: (ex B11 being (BinOp of ( the_set_of_ComplexSequences )) st (for B12 , B13 being (Element of ( the_set_of_ComplexSequences )) holds S2[ B12 , B13 , ( B11 . (B12 , B13) ) ])) from BINOP_1:sch 3(L30);
consider C11 being (BinOp of ( the_set_of_ComplexSequences )) such that L34: (for B14 , B15 being (Element of ( the_set_of_ComplexSequences )) holds ( C11 . (B14 , B15) ) = ( ( seq_id B14 ) + ( seq_id B15 ) )) by L33;
thus L35: thesis by L34;
end;
uniqueness
proof
deffunc H1((Element of ( the_set_of_ComplexSequences )) , (Element of ( the_set_of_ComplexSequences ))) = ( ( seq_id $1 ) + ( seq_id $2 ) );
L36: (for B16 , B17 being (BinOp of ( the_set_of_ComplexSequences )) holds (((for B18 , B19 being (Element of ( the_set_of_ComplexSequences )) holds ( B16 . (B18 , B19) ) = H1(B18 , B19)) & (for B20 , B21 being (Element of ( the_set_of_ComplexSequences )) holds ( B17 . (B20 , B21) ) = H1(B20 , B21))) implies B16 = B17)) from BINOP_2:sch 2;
thus L37: thesis by L36;
end;
end;
definition
func l_mult -> (Function of [: ( COMPLEX ) , ( the_set_of_ComplexSequences ) :] , ( the_set_of_ComplexSequences )) means 
:L39: (for B22 , B23 being set holds ((B22 is Complex & B23 in ( the_set_of_ComplexSequences )) implies ( it . (B22 , B23) ) = ( ( C_id B22 ) (#) ( seq_id B23 ) )));
existence
proof
deffunc H2(set , set) = ( ( C_id $1 ) (#) ( seq_id $2 ) );
L40: (for B24 , B25 being set holds ((B24 in ( COMPLEX ) & B25 in ( the_set_of_ComplexSequences )) implies H2(B24 , B25) in ( the_set_of_ComplexSequences ))) by L1;
consider C12 being (Function of [: ( COMPLEX ) , ( the_set_of_ComplexSequences ) :] , ( the_set_of_ComplexSequences )) such that L41: (for B26 , B27 being set holds ((B26 in ( COMPLEX ) & B27 in ( the_set_of_ComplexSequences )) implies ( C12 . (B26 , B27) ) = H2(B26 , B27))) from BINOP_1:sch 2(L40);
take C12;
let C13 , C14 being set;
assume L42: C13 is Complex;
L43: C13 in ( COMPLEX ) by L42 , XCMPLX_0:def 2;
thus L44: thesis by L43 , L41;
end;
uniqueness
proof
let C15 , C16 being (Function of [: ( COMPLEX ) , ( the_set_of_ComplexSequences ) :] , ( the_set_of_ComplexSequences ));
assume that
L45: (for B28 , B29 being set holds ((B28 is Complex & B29 in ( the_set_of_ComplexSequences )) implies ( C15 . (B28 , B29) ) = ( ( C_id B28 ) (#) ( seq_id B29 ) )))
and
L46: (for B30 , B31 being set holds ((B30 is Complex & B31 in ( the_set_of_ComplexSequences )) implies ( C16 . (B30 , B31) ) = ( ( C_id B30 ) (#) ( seq_id B31 ) )));
L47: (for B32 being (Element of ( COMPLEX )) holds (for B33 being (Element of ( the_set_of_ComplexSequences )) holds ( C15 . (B32 , B33) ) = ( C16 . (B32 , B33) )))
proof
let C17 being (Element of ( COMPLEX ));
let C18 being (Element of ( the_set_of_ComplexSequences ));
thus L48: ( C15 . (C17 , C18) ) = ( ( C_id C17 ) (#) ( seq_id C18 ) ) by L45
.= ( C16 . (C17 , C18) ) by L46;
end;
thus L49: thesis by L47 , BINOP_1:2;
end;
end;
definition
func CZeroseq -> (Element of ( the_set_of_ComplexSequences )) means 
:L51: (for B34 being (Element of ( NAT )) holds ( ( seq_id it ) . B34 ) = ( 0c ));
existence
proof
reconsider D3 = ( ( NAT ) --> ( 0c ) ) as Complex_Sequence;
L52: (for B35 being (Element of ( NAT )) holds ( D3 . B35 ) = ( 0c )) by FUNCOP_1:7;
L53: D3 in ( the_set_of_ComplexSequences ) by L1;
L54: ( seq_id D3 ) = D3 by L53 , L24;
thus L55: thesis by L54 , L52 , L53;
end;
uniqueness
proof
let C19 , C20 being (Element of ( the_set_of_ComplexSequences ));
assume that
L56: (for B36 being (Element of ( NAT )) holds ( ( seq_id C19 ) . B36 ) = ( 0c ))
and
L57: (for B37 being (Element of ( NAT )) holds ( ( seq_id C20 ) . B37 ) = ( 0c ));
L58: (for B38 being (Element of ( NAT )) holds ( ( seq_id C19 ) . B38 ) = ( ( seq_id C20 ) . B38 ))
proof
let C21 being (Element of ( NAT ));
L59: ( ( seq_id C20 ) . C21 ) = ( 0c ) by L57;
thus L60: thesis by L59 , L56;
end;
L61: C19 = ( seq_id C19 ) by L24
.= ( seq_id C20 ) by L58 , FUNCT_2:63;
thus L62: thesis by L61 , L24;
end;
end;
theorem
L64: (for B39 being Complex_Sequence holds ( seq_id B39 ) = B39)
proof
let C22 being Complex_Sequence;
L65: C22 in ( the_set_of_ComplexSequences ) by L1;
thus L66: thesis by L65 , L24;
end;
theorem
L67: (for B40 , B41 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( B40 + B41 ) = ( ( seq_id B40 ) + ( seq_id B41 ) )) by L29;
theorem
L68: (for B42 being Complex holds (for B43 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( B42 * B43 ) = ( B42 (#) ( seq_id B43 ) )))
proof
let C23 being Complex;
let C24 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
thus L69: ( C23 * C24 ) = ( ( l_mult ) . (C23 , C24) )
.= ( ( C_id C23 ) (#) ( seq_id C24 ) ) by L39
.= ( C23 (#) ( seq_id C24 ) ) by L27;
end;
registration
cluster CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #) ->  Abelian;
coherence
proof
let C25 , C26 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L70: ( C25 + C26 ) = ( ( seq_id C25 ) + ( seq_id C26 ) ) by L29;
thus L71: thesis by L70 , L29;
end;
end;
theorem
L73: (for B44 , B45 , B46 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( ( B44 + B45 ) + B46 ) = ( B44 + ( B45 + B46 ) ))
proof
let C27 , C28 , C29 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L74: ( ( C27 + C28 ) + C29 ) = ( ( seq_id ( C27 + C28 ) ) + ( seq_id C29 ) ) by L29
.= ( ( seq_id ( ( seq_id C27 ) + ( seq_id C28 ) ) ) + ( seq_id C29 ) ) by L29
.= ( ( ( seq_id C27 ) + ( seq_id C28 ) ) + ( seq_id C29 ) ) by L64
.= ( ( seq_id C27 ) + ( ( seq_id C28 ) + ( seq_id C29 ) ) ) by COMSEQ_1:7
.= ( ( seq_id C27 ) + ( seq_id ( ( seq_id C28 ) + ( seq_id C29 ) ) ) ) by L64
.= ( ( seq_id C27 ) + ( seq_id ( C28 + C29 ) ) ) by L29;
thus L75: thesis by L74 , L29;
end;
theorem
L76: (for B47 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( B47 + ( 0. CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #) ) ) = B47)
proof
set D4 = CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #);
let C30 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L77: (for B48 being (Element of ( NAT )) holds ( ( ( seq_id C30 ) + ( seq_id ( CZeroseq ) ) ) . B48 ) = ( ( seq_id C30 ) . B48 ))
proof
let C31 being (Element of ( NAT ));
L78: ( ( ( seq_id C30 ) + ( seq_id ( CZeroseq ) ) ) . C31 ) = ( ( ( seq_id C30 ) . C31 ) + ( ( seq_id ( CZeroseq ) ) . C31 ) ) by VALUED_1:1
.= ( ( ( seq_id C30 ) . C31 ) + ( 0c ) ) by L51;
thus L79: thesis by L78;
end;
L80: ( C30 + ( 0. D4 ) ) = ( ( seq_id C30 ) + ( seq_id ( CZeroseq ) ) ) by L29;
thus L81: ( C30 + ( 0. D4 ) ) = ( seq_id C30 ) by L80 , L77 , FUNCT_2:63
.= C30 by L24;
end;
theorem
L82: (for B49 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds (ex B50 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) st ( B49 + B50 ) = ( 0. CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #) )))
proof
set D5 = CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #);
let C32 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
reconsider D6 = ( - ( seq_id C32 ) ) as (VECTOR of D5) by L1;
L83: (for B51 being (Element of ( NAT )) holds ( ( ( seq_id C32 ) + ( - ( seq_id C32 ) ) ) . B51 ) = ( ( seq_id ( CZeroseq ) ) . B51 ))
proof
let C33 being (Element of ( NAT ));
L84: ( ( ( seq_id C32 ) + ( - ( seq_id C32 ) ) ) . C33 ) = ( ( ( seq_id C32 ) . C33 ) + ( ( - ( seq_id C32 ) ) . C33 ) ) by VALUED_1:1
.= ( ( ( seq_id C32 ) . C33 ) + ( - ( ( seq_id C32 ) . C33 ) ) ) by VALUED_1:8
.= ( ( seq_id ( CZeroseq ) ) . C33 ) by L51;
thus L85: thesis by L84;
end;
L86: ( ( seq_id C32 ) + ( - ( seq_id C32 ) ) ) = ( seq_id ( CZeroseq ) ) by L83 , FUNCT_2:63
.= ( CZeroseq ) by L24;
L87: ( C32 + D6 ) = ( ( seq_id C32 ) + ( seq_id D6 ) ) by L29
.= ( ( seq_id C32 ) + ( - ( seq_id C32 ) ) ) by L64;
thus L88: thesis by L87 , L86;
end;
theorem
L89: (for B52 being Complex holds (for B53 , B54 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( B52 * ( B53 + B54 ) ) = ( ( B52 * B53 ) + ( B52 * B54 ) )))
proof
let C34 being Complex;
let C35 , C36 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L90: C34 in ( COMPLEX ) by XCMPLX_0:def 2;
L91: ( C34 * ( C35 + C36 ) ) = ( C34 (#) ( seq_id ( C35 + C36 ) ) ) by L68
.= ( C34 (#) ( seq_id ( ( seq_id C35 ) + ( seq_id C36 ) ) ) ) by L29
.= ( C34 (#) ( ( seq_id C35 ) + ( seq_id C36 ) ) ) by L64
.= ( ( C34 (#) ( seq_id C35 ) ) + ( C34 (#) ( seq_id C36 ) ) ) by L90 , COMSEQ_1:16;
L92: ( ( C34 * C35 ) + ( C34 * C36 ) ) = ( ( seq_id ( C34 * C35 ) ) + ( seq_id ( C34 * C36 ) ) ) by L29
.= ( ( seq_id ( C34 (#) ( seq_id C35 ) ) ) + ( seq_id ( C34 * C36 ) ) ) by L68
.= ( ( seq_id ( C34 (#) ( seq_id C35 ) ) ) + ( seq_id ( C34 (#) ( seq_id C36 ) ) ) ) by L68
.= ( ( C34 (#) ( seq_id C35 ) ) + ( seq_id ( C34 (#) ( seq_id C36 ) ) ) ) by L64
.= ( ( C34 (#) ( seq_id C35 ) ) + ( C34 (#) ( seq_id C36 ) ) ) by L64;
thus L93: thesis by L92 , L91;
end;
theorem
L94: (for B55 , B56 being Complex holds (for B57 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( ( B55 + B56 ) * B57 ) = ( ( B55 * B57 ) + ( B56 * B57 ) )))
proof
let C37 , C38 being Complex;
let C39 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L95: (for B58 being (Element of ( NAT )) holds ( ( ( C37 + C38 ) (#) ( seq_id C39 ) ) . B58 ) = ( ( ( C37 (#) ( seq_id C39 ) ) + ( C38 (#) ( seq_id C39 ) ) ) . B58 ))
proof
let C40 being (Element of ( NAT ));
L96: ( ( ( C37 + C38 ) (#) ( seq_id C39 ) ) . C40 ) = ( ( C37 + C38 ) * ( ( seq_id C39 ) . C40 ) ) by VALUED_1:6
.= ( ( C37 * ( ( seq_id C39 ) . C40 ) ) + ( C38 * ( ( seq_id C39 ) . C40 ) ) )
.= ( ( ( C37 (#) ( seq_id C39 ) ) . C40 ) + ( C38 * ( ( seq_id C39 ) . C40 ) ) ) by VALUED_1:6
.= ( ( ( C37 (#) ( seq_id C39 ) ) . C40 ) + ( ( C38 (#) ( seq_id C39 ) ) . C40 ) ) by VALUED_1:6;
thus L97: thesis by L96 , VALUED_1:1;
end;
L98: ( ( C37 + C38 ) (#) ( seq_id C39 ) ) = ( ( C37 (#) ( seq_id C39 ) ) + ( C38 (#) ( seq_id C39 ) ) ) by L95 , FUNCT_2:63;
L99: ( ( C37 * C39 ) + ( C38 * C39 ) ) = ( ( seq_id ( C37 * C39 ) ) + ( seq_id ( C38 * C39 ) ) ) by L29
.= ( ( seq_id ( C37 (#) ( seq_id C39 ) ) ) + ( seq_id ( C38 * C39 ) ) ) by L68
.= ( ( seq_id ( C37 (#) ( seq_id C39 ) ) ) + ( seq_id ( C38 (#) ( seq_id C39 ) ) ) ) by L68
.= ( ( C37 (#) ( seq_id C39 ) ) + ( seq_id ( C38 (#) ( seq_id C39 ) ) ) ) by L64
.= ( ( C37 (#) ( seq_id C39 ) ) + ( C38 (#) ( seq_id C39 ) ) ) by L64;
thus L100: thesis by L99 , L98 , L68;
end;
theorem
L101: (for B59 , B60 being Complex holds (for B61 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( ( B59 * B60 ) * B61 ) = ( B59 * ( B60 * B61 ) )))
proof
let C41 , C42 being Complex;
L102: (C41 in ( COMPLEX ) & C42 in ( COMPLEX )) by XCMPLX_0:def 2;
let C43 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L103: ( ( C41 * C42 ) * C43 ) = ( ( C41 * C42 ) (#) ( seq_id C43 ) ) by L68
.= ( C41 (#) ( C42 (#) ( seq_id C43 ) ) ) by L102 , COMSEQ_1:17
.= ( C41 (#) ( seq_id ( C42 (#) ( seq_id C43 ) ) ) ) by L64
.= ( C41 (#) ( seq_id ( C42 * C43 ) ) ) by L68;
thus L104: thesis by L103 , L68;
end;
theorem
L105: (for B62 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #)) holds ( ( 1r ) * B62 ) = B62)
proof
let C44 being (VECTOR of CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #));
L106: ( ( 1r ) * C44 ) = ( ( 1r ) (#) ( seq_id C44 ) ) by L68
.= ( seq_id C44 ) by COMSEQ_1:21;
thus L107: thesis by L106 , L24;
end;
definition
func Linear_Space_of_ComplexSequences ->  strict non  empty CLSStruct equals 
CLSStruct (# ( the_set_of_ComplexSequences ) , ( CZeroseq ) , ( l_add ) , ( l_mult ) #);
coherence;
end;
registration
cluster ( Linear_Space_of_ComplexSequences ) ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
set D7 = ( Linear_Space_of_ComplexSequences );
thus L109: D7 is  Abelian;
thus L110: D7 is  add-associative
proof
let C45 being (Element of D7);
thus L111: thesis by L73;
end;

thus L112: D7 is  right_zeroed
proof
let C46 being (Element of D7);
thus L113: thesis by L76;
end;

thus L114: D7 is  right_complementable
proof
let C47 being (Element of D7);
consider C48 being (Element of D7) such that L115: ( C47 + C48 ) = ( 0. D7 ) by L82;
take C48;
thus L116: thesis by L115;
end;

thus L117: ((for B63 being Complex holds (for B64 , B65 being (VECTOR of D7) holds ( B63 * ( B64 + B65 ) ) = ( ( B63 * B64 ) + ( B63 * B65 ) ))) & (for B66 , B67 being Complex holds (for B68 being (VECTOR of D7) holds ( ( B66 + B67 ) * B68 ) = ( ( B66 * B68 ) + ( B67 * B68 ) ))) & (for B69 , B70 being Complex holds (for B71 being (VECTOR of D7) holds ( ( B69 * B70 ) * B71 ) = ( B69 * ( B70 * B71 ) ))) & (for B72 being (VECTOR of D7) holds ( ( 1r ) * B72 ) = B72)) by L89 , L94 , L101 , L105;
end;
end;
definition
let C49 being ComplexLinearSpace;
let C50 being (Subset of C49);
assume that
L119: C50 is  linearly-closed;
func Add_ (C50 , C49) -> (BinOp of C50) equals 
:L120: ( (the addF of C49) || C50 );
correctness
proof
L121: ( dom (the addF of C49) ) = [: (the carrier of C49) , (the carrier of C49) :] by FUNCT_2:def 1;
L122: (for B73 being set holds (B73 in [: C50 , C50 :] implies ( ( (the addF of C49) || C50 ) . B73 ) in C50))
proof
let C51 being set;
assume that
L123: C51 in [: C50 , C50 :];
consider C52 , C53 being set such that L124: C52 in C50 and L125: C53 in C50 and L126: C51 = [ C52 , C53 ] by L123 , ZFMISC_1:def 2;
reconsider D8 = C53 , D9 = C52 as (VECTOR of C49) by L124 , L125;
L127: [ C52 , C53 ] in ( dom ( (the addF of C49) || C50 ) ) by L121 , L123 , L126 , RELAT_1:62 , ZFMISC_1:96;
L128: ( ( (the addF of C49) || C50 ) . C51 ) = ( D9 + D8 ) by L127 , L126 , FUNCT_1:47;
thus L129: thesis by L128 , L119 , L124 , L125 , CLVECT_1:def 7;
end;
L130: ( dom ( (the addF of C49) || C50 ) ) = [: C50 , C50 :] by L121 , RELAT_1:62 , ZFMISC_1:96;
thus L131: thesis by L130 , L122 , FUNCT_2:3;
end;
end;
definition
let C54 being ComplexLinearSpace;
let C55 being (Subset of C54);
assume that
L133: C55 is  linearly-closed;
func Mult_ (C55 , C54) -> (Function of [: ( COMPLEX ) , C55 :] , C55) equals 
:L134: ( (the Mult of C54) | [: ( COMPLEX ) , C55 :] );
correctness
proof
L135: ( dom (the Mult of C54) ) = [: ( COMPLEX ) , (the carrier of C54) :] by FUNCT_2:def 1;
L136: [: ( COMPLEX ) , C55 :] c= [: ( COMPLEX ) , (the carrier of C54) :] by ZFMISC_1:95;
L137: (for B74 being set holds (B74 in [: ( COMPLEX ) , C55 :] implies ( ( (the Mult of C54) | [: ( COMPLEX ) , C55 :] ) . B74 ) in C55))
proof
let C56 being set;
assume that
L138: C56 in [: ( COMPLEX ) , C55 :];
consider C57 , C58 being set such that L139: C57 in ( COMPLEX ) and L140: C58 in C55 and L141: C56 = [ C57 , C58 ] by L138 , ZFMISC_1:def 2;
reconsider D10 = C57 as Complex by L139;
reconsider D11 = C58 as (VECTOR of C54) by L140;
L142: [ D10 , C58 ] in ( dom ( (the Mult of C54) | [: ( COMPLEX ) , C55 :] ) ) by L136 , L135 , L138 , L141 , RELAT_1:62;
L143: ( ( (the Mult of C54) | [: ( COMPLEX ) , C55 :] ) . C56 ) = ( D10 * D11 ) by L142 , L141 , FUNCT_1:47;
thus L144: thesis by L143 , L133 , L140 , CLVECT_1:def 7;
end;
L145: ( dom ( (the Mult of C54) | [: ( COMPLEX ) , C55 :] ) ) = [: ( COMPLEX ) , C55 :] by L136 , L135 , RELAT_1:62;
thus L146: thesis by L145 , L137 , FUNCT_2:3;
end;
end;
definition
let C59 being ComplexLinearSpace;
let C60 being (Subset of C59);
assume that
L148: C60 is  linearly-closed
and
L149: C60 is non  empty;
func Zero_ (C60 , C59) -> (Element of C60) equals 
:L150: ( 0. C59 );
correctness
proof
set D12 = the (Element of C60);
L151: D12 in C60 by L149;
reconsider D13 = D12 as (Element of C59) by L151;
L152: ( D13 - D13 ) = ( 0. C59 ) by RLVECT_1:15;
thus L153: thesis by L152 , L148 , L149 , CLVECT_1:22;
end;
end;
theorem
L155: (for B75 being ComplexLinearSpace holds (for B76 being (Subset of B75) holds ((B76 is  linearly-closed & B76 is non  empty) implies CLSStruct (# B76 , ( Zero_ (B76 , B75) ) , ( Add_ (B76 , B75) ) , ( Mult_ (B76 , B75) ) #) is (Subspace of B75))))
proof
let C61 being ComplexLinearSpace;
let C62 being (Subset of C61);
assume that
L156: C62 is  linearly-closed
and
L157: C62 is non  empty;
L158: ( Add_ (C62 , C61) ) = ( (the addF of C61) || C62 ) by L156 , L120;
L159: ( Mult_ (C62 , C61) ) = ( (the Mult of C61) | [: ( COMPLEX ) , C62 :] ) by L156 , L134;
L160: ( Zero_ (C62 , C61) ) = ( 0. C61 ) by L156 , L157 , L150;
thus L161: thesis by L160 , L157 , L158 , L159 , CLVECT_1:43;
end;
definition
func the_set_of_l2ComplexSequences -> (Subset of ( Linear_Space_of_ComplexSequences )) means 
:L162: (it is non  empty & (for B77 being set holds (B77 in it iff (B77 in ( the_set_of_ComplexSequences ) & ( |. ( seq_id B77 ) .| (#) |. ( seq_id B77 ) .| ) is  summable))));
existence
proof
defpred S3[ set ] means ( |. ( seq_id $1 ) .| (#) |. ( seq_id $1 ) .| ) is  summable;
consider C63 being set such that L163: (for B78 being set holds (B78 in C63 iff (B78 in ( the_set_of_ComplexSequences ) & S3[ B78 ]))) from XBOOLE_0:sch 1;
L164: (for B79 being set holds (B79 in C63 implies B79 in ( the_set_of_ComplexSequences ))) by L163;
L165: C63 is (Subset of ( the_set_of_ComplexSequences )) by L164 , TARSKI:def 3;
L166: ( |. ( seq_id ( CZeroseq ) ) .| (#) |. ( seq_id ( CZeroseq ) ) .| ) is  absolutely_summable
proof
reconsider D14 = ( |. ( seq_id ( CZeroseq ) ) .| (#) |. ( seq_id ( CZeroseq ) ) .| ) as Real_Sequence;
L167:
now
let C64 being (Element of ( NAT ));
thus L168: ( D14 . C64 ) = ( ( |. ( seq_id ( CZeroseq ) ) .| . C64 ) * ( |. ( seq_id ( CZeroseq ) ) .| . C64 ) ) by SEQ_1:8
.= ( ( |. ( seq_id ( CZeroseq ) ) .| . C64 ) * |. ( ( seq_id ( CZeroseq ) ) . C64 ) .| ) by VALUED_1:18
.= ( ( |. ( seq_id ( CZeroseq ) ) .| . C64 ) * ( 0 ) ) by L51 , COMPLEX1:44
.= ( 0 );
end;
thus L169: thesis by L167 , COMSEQ_3:3;
end;
L170: C63 is non  empty by L166 , L163;
thus L171: thesis by L170 , L163 , L165;
end;
uniqueness
proof
let C65 , C66 being (Subset of ( Linear_Space_of_ComplexSequences ));
assume that
L172: C65 is non  empty
and
L173: (for B80 being set holds (B80 in C65 iff (B80 in ( the_set_of_ComplexSequences ) & ( |. ( seq_id B80 ) .| (#) |. ( seq_id B80 ) .| ) is  summable)))
and
L174: C66 is non  empty
and
L175: (for B81 being set holds (B81 in C66 iff (B81 in ( the_set_of_ComplexSequences ) & ( |. ( seq_id B81 ) .| (#) |. ( seq_id B81 ) .| ) is  summable)));
L176: C66 c= C65
proof
let C67 being set;
assume L177: C67 in C66;
L178: ( |. ( seq_id C67 ) .| (#) |. ( seq_id C67 ) .| ) is  summable by L177 , L175;
thus L179: thesis by L178 , L173 , L177;
end;
L180: C65 c= C66
proof
let C68 being set;
assume L181: C68 in C65;
L182: ( |. ( seq_id C68 ) .| (#) |. ( seq_id C68 ) .| ) is  summable by L181 , L173;
thus L183: thesis by L182 , L175 , L181;
end;
thus L184: thesis by L180 , L176 , XBOOLE_0:def 10;
end;
end;
theorem
L186: (( the_set_of_l2ComplexSequences ) is  linearly-closed & ( the_set_of_l2ComplexSequences ) is non  empty)
proof
set D15 = ( the_set_of_l2ComplexSequences );
L187: (for B82 , B83 being (VECTOR of ( Linear_Space_of_ComplexSequences )) holds ((B82 in ( the_set_of_l2ComplexSequences ) & B83 in ( the_set_of_l2ComplexSequences )) implies ( B82 + B83 ) in ( the_set_of_l2ComplexSequences )))
proof
let C69 , C70 being (VECTOR of ( Linear_Space_of_ComplexSequences ));
assume that
L188: C69 in D15
and
L189: C70 in D15;
L190: ( |. ( seq_id ( C69 + C70 ) ) .| (#) |. ( seq_id ( C69 + C70 ) ) .| ) is  summable
proof
set D16 = ( |. ( seq_id ( C69 + C70 ) ) .| (#) |. ( seq_id ( C69 + C70 ) ) .| );
set D17 = ( |. ( seq_id C70 ) .| (#) |. ( seq_id C70 ) .| );
set D18 = ( |. ( seq_id C69 ) .| (#) |. ( seq_id C69 ) .| );
L191: (for B84 being (Element of ( NAT )) holds ( 0 ) <= ( D16 . B84 ))
proof
let C71 being (Element of ( NAT ));
L192: ( D16 . C71 ) = ( ( |. ( seq_id ( C69 + C70 ) ) .| . C71 ) * ( |. ( seq_id ( C69 + C70 ) ) .| . C71 ) ) by SEQ_1:8;
thus L193: thesis by L192 , XREAL_1:63;
end;
L194: (for B85 being (Element of ( NAT )) holds ( D16 . B85 ) <= ( ( ( 2 (#) D18 ) + ( 2 (#) D17 ) ) . B85 ))
proof
set D19 = |. ( seq_id C70 ) .|;
set D20 = |. ( seq_id C69 ) .|;
let C72 being (Element of ( NAT ));
reconsider D21 = ( D20 . C72 ) , D22 = ( D19 . C72 ) as Real;
L195: ( D16 . C72 ) = ( ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) ^2 ) by SEQ_1:8;
L196: ( ( ( 2 (#) D18 ) + ( 2 (#) D17 ) ) . C72 ) = ( ( ( 2 (#) D18 ) . C72 ) + ( ( 2 (#) D17 ) . C72 ) ) by SEQ_1:7
.= ( ( 2 * ( D18 . C72 ) ) + ( ( 2 (#) D17 ) . C72 ) ) by SEQ_1:9
.= ( ( 2 * ( D18 . C72 ) ) + ( 2 * ( D17 . C72 ) ) ) by SEQ_1:9
.= ( ( 2 * ( ( D20 . C72 ) * ( D20 . C72 ) ) ) + ( 2 * ( D17 . C72 ) ) ) by SEQ_1:8
.= ( ( 2 * ( D21 ^2 ) ) + ( 2 * ( D22 ^2 ) ) ) by SEQ_1:8;
L197: ( ( ( ( 2 (#) D18 ) + ( 2 (#) D17 ) ) . C72 ) - ( ( ( D21 ^2 ) + ( ( 2 * D21 ) * D22 ) ) + ( D22 ^2 ) ) ) = ( ( D21 - D22 ) ^2 ) by L196;
L198: ( seq_id ( C69 + C70 ) ) = ( seq_id ( ( seq_id C69 ) + ( seq_id C70 ) ) ) by L29
.= ( ( seq_id C69 ) + ( seq_id C70 ) ) by L64;
L199: ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) = |. ( ( seq_id ( C69 + C70 ) ) . C72 ) .| by VALUED_1:18
.= |. ( ( ( seq_id C69 ) . C72 ) + ( ( seq_id C70 ) . C72 ) ) .| by L198 , VALUED_1:1;
L200: ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) <= ( |. ( ( seq_id C69 ) . C72 ) .| + |. ( ( seq_id C70 ) . C72 ) .| ) by L199 , COMPLEX1:56;
L201: ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) <= ( ( D20 . C72 ) + |. ( ( seq_id C70 ) . C72 ) .| ) by L200 , VALUED_1:18;
L202: ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) <= ( ( D20 . C72 ) + ( D19 . C72 ) ) by L201 , VALUED_1:18;
L203: ( 0 ) <= ( ( D21 - D22 ) ^2 ) by XREAL_1:63;
L204: ( ( 0 ) + ( ( ( D21 ^2 ) + ( ( 2 * D21 ) * D22 ) ) + ( D22 ^2 ) ) ) <= ( ( ( 2 (#) D18 ) + ( 2 (#) D17 ) ) . C72 ) by L203 , L197 , XREAL_1:19;
L205: ( 0 ) <= |. ( ( seq_id ( C69 + C70 ) ) . C72 ) .| by COMPLEX1:46;
L206: ( 0 ) <= ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) by L205 , VALUED_1:18;
L207: ( ( |. ( seq_id ( C69 + C70 ) ) .| . C72 ) ^2 ) <= ( ( ( D20 . C72 ) + ( D19 . C72 ) ) ^2 ) by L206 , L202 , SQUARE_1:15;
thus L208: thesis by L207 , L195 , L204 , XXREAL_0:2;
end;
L209: ( |. ( seq_id C70 ) .| (#) |. ( seq_id C70 ) .| ) is  summable by L189 , L162;
L210: ( 2 (#) D17 ) is  summable by L209 , SERIES_1:10;
L211: ( |. ( seq_id C69 ) .| (#) |. ( seq_id C69 ) .| ) is  summable by L188 , L162;
L212: ( 2 (#) D18 ) is  summable by L211 , SERIES_1:10;
L213: ( ( 2 (#) D18 ) + ( 2 (#) D17 ) ) is  summable by L212 , L210 , SERIES_1:7;
thus L214: thesis by L213 , L191 , L194 , SERIES_1:20;
end;
thus L215: thesis by L190 , L162;
end;
L216: (for B86 being Complex holds (for B87 being (VECTOR of ( Linear_Space_of_ComplexSequences )) holds (B87 in D15 implies ( B86 * B87 ) in D15)))
proof
let C73 being Complex;
let C74 being (VECTOR of ( Linear_Space_of_ComplexSequences ));
assume L217: C74 in D15;
L218: ( |. ( seq_id C74 ) .| (#) |. ( seq_id C74 ) .| ) is  summable by L217 , L162;
L219: C73 in ( COMPLEX ) by XCMPLX_0:def 2;
L220: ( seq_id ( C73 * C74 ) ) = ( seq_id ( C73 (#) ( seq_id C74 ) ) ) by L68
.= ( C73 (#) ( seq_id C74 ) ) by L64;
L221: |. ( seq_id ( C73 * C74 ) ) .| = ( |. C73 .| (#) |. ( seq_id C74 ) .| ) by L220 , L219 , COMSEQ_1:50;
L222: ( |. ( seq_id ( C73 * C74 ) ) .| (#) |. ( seq_id ( C73 * C74 ) ) .| ) = ( |. C73 .| (#) ( ( |. C73 .| (#) |. ( seq_id C74 ) .| ) (#) |. ( seq_id C74 ) .| ) ) by L221 , SEQ_1:18
.= ( |. C73 .| (#) ( |. C73 .| (#) ( |. ( seq_id C74 ) .| (#) |. ( seq_id C74 ) .| ) ) ) by SEQ_1:18
.= ( ( |. C73 .| * |. C73 .| ) (#) ( |. ( seq_id C74 ) .| (#) |. ( seq_id C74 ) .| ) ) by SEQ_1:23;
L223: ( |. ( seq_id ( C73 * C74 ) ) .| (#) |. ( seq_id ( C73 * C74 ) ) .| ) is  summable by L222 , L218 , SERIES_1:10;
thus L224: thesis by L223 , L162;
end;
thus L225: thesis by L216 , L187 , L162 , CLVECT_1:def 7;
end;
theorem
L226: CLSStruct (# ( the_set_of_l2ComplexSequences ) , ( Zero_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Add_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Mult_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) #) is (Subspace of ( Linear_Space_of_ComplexSequences )) by L155 , L186;
theorem
L227: CLSStruct (# ( the_set_of_l2ComplexSequences ) , ( Zero_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Add_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Mult_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) #) is ComplexLinearSpace by L155 , L186;
theorem
L228: ((the carrier of ( Linear_Space_of_ComplexSequences )) = ( the_set_of_ComplexSequences ) & (for B88 being set holds (B88 is (Element of ( Linear_Space_of_ComplexSequences )) iff B88 is Complex_Sequence)) & (for B89 being set holds (B89 is (VECTOR of ( Linear_Space_of_ComplexSequences )) iff B89 is Complex_Sequence)) & (for B90 being (VECTOR of ( Linear_Space_of_ComplexSequences )) holds B90 = ( seq_id B90 )) & (for B91 , B92 being (VECTOR of ( Linear_Space_of_ComplexSequences )) holds ( B91 + B92 ) = ( ( seq_id B91 ) + ( seq_id B92 ) )) & (for B93 being Complex holds (for B94 being (VECTOR of ( Linear_Space_of_ComplexSequences )) holds ( B93 * B94 ) = ( B93 (#) ( seq_id B94 ) )))) by L1 , L24 , L29 , L68;
begin
definition
struct (CLSStruct) CUNITSTR(# carrier -> set , ZeroF -> (Element of the carrier) , addF -> (BinOp of the carrier) , Mult -> (Function of [: ( COMPLEX ) , the carrier :] , the carrier) , scalar -> (Function of [: the carrier , the carrier :] , ( COMPLEX )) #);
end;
registration
cluster non  empty  strict for CUNITSTR;
existence
proof
set D23 = the non  empty set;
set D24 = the (Element of D23);
set D25 = the (BinOp of D23);
set D26 = the (Function of [: ( COMPLEX ) , D23 :] , D23);
set D27 = the (Function of [: D23 , D23 :] , ( COMPLEX ));
take CUNITSTR (# D23 , D24 , D25 , D26 , D27 #);
thus L230: (the carrier of CUNITSTR (# D23 , D24 , D25 , D26 , D27 #)) is non  empty;
thus L231: thesis;
end;
end;
registration
let C75 being non  empty set;
let C76 being (Element of C75);
let C77 being (BinOp of C75);
let C78 being (Function of [: ( COMPLEX ) , C75 :] , C75);
let C79 being (Function of [: C75 , C75 :] , ( COMPLEX ));
cluster CUNITSTR (# C75 , C76 , C77 , C78 , C79 #) -> non  empty;
coherence;
end;
deffunc H3(CUNITSTR) = ( 0. $1 );
definition
let R1 being non  empty CUNITSTR;
let R4 being (Point of R1);
let R5 being (Point of R1);
func R4 .|. R5 -> Complex equals 
( (the scalar of R1) . (R4 , R5) );
correctness;
end;
set D28 = the ComplexLinearSpace;
L235: (the carrier of ( (0). D28 )) = { ( 0. D28 ) } by CLVECT_1:def 9;
reconsider D29 = ( [: (the carrier of ( (0). D28 )) , (the carrier of ( (0). D28 )) :] --> ( 0c ) ) as (Function of [: (the carrier of ( (0). D28 )) , (the carrier of ( (0). D28 )) :] , ( COMPLEX ));
L236: (for B95 , B96 being (VECTOR of ( (0). D28 )) holds ( D29 . [ B95 , B96 ] ) = ( 0c )) by FUNCOP_1:7;
L237: ( 0. D28 ) in (the carrier of ( (0). D28 )) by L235 , TARSKI:def 1;
L238: ( D29 . [ ( 0. D28 ) , ( 0. D28 ) ] ) = ( 0c ) by L237 , L236;
L239: (for B97 being (VECTOR of ( (0). D28 )) holds (( 0 ) <= ( Re ( D29 . [ B97 , B97 ] ) ) & ( Im ( D29 . [ B97 , B97 ] ) ) = ( 0 ))) by COMPLEX1:4 , FUNCOP_1:7;
L240: (for B98 , B99 being (VECTOR of ( (0). D28 )) holds ( D29 . [ B98 , B99 ] ) = ( ( D29 . [ B99 , B98 ] ) *' ))
proof
let C80 , C81 being (VECTOR of ( (0). D28 ));
L241: C81 = ( 0. D28 ) by L235 , TARSKI:def 1;
L242: C80 = ( 0. D28 ) by L235 , TARSKI:def 1;
thus L243: thesis by L242 , L241 , L238 , COMPLEX1:28;
end;
L244: (for B100 , B101 , B102 being (VECTOR of ( (0). D28 )) holds ( D29 . [ ( B100 + B101 ) , B102 ] ) = ( ( D29 . [ B100 , B102 ] ) + ( D29 . [ B101 , B102 ] ) ))
proof
let C82 , C83 , C84 being (VECTOR of ( (0). D28 ));
L245: C83 = ( 0. D28 ) by L235 , TARSKI:def 1;
L246: C84 = ( 0. D28 ) by L235 , TARSKI:def 1;
L247: C82 = ( 0. D28 ) by L235 , TARSKI:def 1;
thus L248: thesis by L247 , L245 , L246 , L235 , L238 , TARSKI:def 1;
end;
L249: (for B103 , B104 being (VECTOR of ( (0). D28 )) holds (for R2 being Complex holds ( D29 . [ ( R2 * B103 ) , B104 ] ) = ( R2 * ( D29 . [ B103 , B104 ] ) )))
proof
let C85 , C86 being (VECTOR of ( (0). D28 ));
let R2 being Complex;
L250: C86 = ( 0. D28 ) by L235 , TARSKI:def 1;
L251: C85 = ( 0. D28 ) by L235 , TARSKI:def 1;
thus L252: thesis by L251 , L250 , L235 , L238 , TARSKI:def 1;
end;
set D30 = CUNITSTR (# (the carrier of ( (0). D28 )) , ( 0. ( (0). D28 ) ) , (the addF of ( (0). D28 )) , (the Mult of ( (0). D28 )) , D29 #);
L253:
now
let C87 , C88 , C89 being (Point of D30);
let R2 being Complex;
L254: H3(D30) = ( 0. D28 ) by CLVECT_1:30;
thus L255: (( C87 .|. C87 ) = ( 0c ) iff C87 = H3(D30)) by L254 , L235 , L236 , TARSKI:def 1;
thus L256: (( 0 ) <= ( Re ( C87 .|. C87 ) ) & ( 0 ) = ( Im ( C87 .|. C87 ) )) by L239;
thus L257: ( C87 .|. C88 ) = ( ( C88 .|. C87 ) *' ) by L240;
thus L258: ( ( C87 + C88 ) .|. C89 ) = ( ( C87 .|. C89 ) + ( C88 .|. C89 ) )
proof
reconsider D31 = C87 , D32 = C88 , D33 = C89 as (VECTOR of ( (0). D28 ));
L259: ( ( C87 + C88 ) .|. C89 ) = ( D29 . [ ( D31 + D32 ) , D33 ] );
thus L260: thesis by L259 , L244;
end;

thus L261: ( ( R2 * C87 ) .|. C88 ) = ( R2 * ( C87 .|. C88 ) )
proof
reconsider D34 = C87 , D35 = C88 as (VECTOR of ( (0). D28 ));
L262: ( ( R2 * C87 ) .|. C88 ) = ( D29 . [ ( R2 * D34 ) , D35 ] );
thus L263: thesis by L262 , L249;
end;

end;
definition
let C90 being non  empty CUNITSTR;
attr C90 is  ComplexUnitarySpace-like
means
:L262: (for B105 , B106 , B107 being (Point of C90) holds (for R2 being Complex holds ((( B105 .|. B105 ) = ( 0 ) iff B105 = ( 0. C90 )) & ( 0 ) <= ( Re ( B105 .|. B105 ) ) & ( 0 ) = ( Im ( B105 .|. B105 ) ) & ( B105 .|. B106 ) = ( ( B106 .|. B105 ) *' ) & ( ( B105 + B106 ) .|. B107 ) = ( ( B105 .|. B107 ) + ( B106 .|. B107 ) ) & ( ( R2 * B105 ) .|. B106 ) = ( R2 * ( B105 .|. B106 ) ))));
end;
registration
cluster  ComplexUnitarySpace-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  Abelian  add-associative  right_zeroed  right_complementable  strict for non  empty non  empty non  empty non  empty CUNITSTR;
existence
proof
take D30;
thus L264: D30 is  ComplexUnitarySpace-like by L262 , L253;
thus L265: D30 is  vector-distributive  scalar-distributive  scalar-associative  scalar-unital
proof
thus L266: (for R2 being Complex holds (for B108 , B109 being (VECTOR of D30) holds ( R2 * ( B108 + B109 ) ) = ( ( R2 * B108 ) + ( R2 * B109 ) )))
proof
let R2 being Complex;
let C91 , C92 being (VECTOR of D30);
reconsider D36 = C91 , D37 = C92 as (VECTOR of ( (0). D28 ));
thus L267: ( R2 * ( C91 + C92 ) ) = ( R2 * ( D36 + D37 ) )
.= ( ( R2 * D36 ) + ( R2 * D37 ) ) by CLVECT_1:def 2
.= ( ( R2 * C91 ) + ( R2 * C92 ) );
end;

thus L268: (for R2 being Complex holds (for R3 being Complex holds (for B110 being (VECTOR of D30) holds ( ( R2 + R3 ) * B110 ) = ( ( R2 * B110 ) + ( R3 * B110 ) ))))
proof
let R2 being Complex;
let R3 being Complex;
let C93 being (VECTOR of D30);
reconsider D38 = C93 as (VECTOR of ( (0). D28 ));
thus L269: ( ( R2 + R3 ) * C93 ) = ( ( R2 + R3 ) * D38 )
.= ( ( R2 * D38 ) + ( R3 * D38 ) ) by CLVECT_1:def 3
.= ( ( R2 * C93 ) + ( R3 * C93 ) );
end;

thus L270: (for R2 being Complex holds (for R3 being Complex holds (for B111 being (VECTOR of D30) holds ( ( R2 * R3 ) * B111 ) = ( R2 * ( R3 * B111 ) ))))
proof
let R2 being Complex;
let R3 being Complex;
let C94 being (VECTOR of D30);
reconsider D39 = C94 as (VECTOR of ( (0). D28 ));
thus L271: ( ( R2 * R3 ) * C94 ) = ( ( R2 * R3 ) * D39 )
.= ( R2 * ( R3 * D39 ) ) by CLVECT_1:def 4
.= ( R2 * ( R3 * C94 ) );
end;

let C95 being (VECTOR of D30);
reconsider D40 = C95 as (VECTOR of ( (0). D28 ));
thus L272: ( ( 1r ) * C95 ) = ( ( 1r ) * D40 )
.= C95 by CLVECT_1:def 5;
end;

L273: (for B112 , B113 being (VECTOR of D30) holds (for B114 , B115 being (VECTOR of ( (0). D28 )) holds ((B112 = B114 & B113 = B115) implies (( B112 + B113 ) = ( B114 + B115 ) & (for R2 being Complex holds ( R2 * B112 ) = ( R2 * B114 ))))));
thus L274: (for B116 , B117 being (VECTOR of D30) holds ( B116 + B117 ) = ( B117 + B116 ))
proof
let C96 , C97 being (VECTOR of D30);
reconsider D41 = C96 , D42 = C97 as (VECTOR of ( (0). D28 ));
thus L275: ( C96 + C97 ) = ( D42 + D41 ) by L273
.= ( C97 + C96 );
end;

thus L276: (for B118 , B119 , B120 being (VECTOR of D30) holds ( ( B118 + B119 ) + B120 ) = ( B118 + ( B119 + B120 ) ))
proof
let C98 , C99 , C100 being (VECTOR of D30);
reconsider D43 = C98 , D44 = C99 , D45 = C100 as (VECTOR of ( (0). D28 ));
thus L277: ( ( C98 + C99 ) + C100 ) = ( ( D43 + D44 ) + D45 )
.= ( D43 + ( D44 + D45 ) ) by RLVECT_1:def 3
.= ( C98 + ( C99 + C100 ) );
end;

thus L278: (for B121 being (VECTOR of D30) holds ( B121 + ( 0. D30 ) ) = B121)
proof
let C101 being (VECTOR of D30);
reconsider D46 = C101 as (VECTOR of ( (0). D28 ));
thus L279: ( C101 + ( 0. D30 ) ) = ( D46 + ( 0. ( (0). D28 ) ) )
.= C101 by RLVECT_1:4;
end;

thus L280: D30 is  right_complementable
proof
let C102 being (VECTOR of D30);
reconsider D47 = C102 as (VECTOR of ( (0). D28 ));
consider C103 being (VECTOR of ( (0). D28 )) such that L281: ( D47 + C103 ) = ( 0. ( (0). D28 ) ) by ALGSTR_0:def 11;
reconsider D48 = C103 as (VECTOR of D30);
take D48;
thus L282: thesis by L281;
end;

thus L283: thesis;
end;
end;
definition
mode ComplexUnitarySpace
 is  ComplexUnitarySpace-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  Abelian  add-associative  right_zeroed  right_complementable non  empty CUNITSTR;
end;
theorem
L286: (for R6 being ComplexUnitarySpace holds ( ( 0. R6 ) .|. ( 0. R6 ) ) = ( 0 )) by L262;
theorem
L287: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( R7 .|. ( R8 + R9 ) ) = ( ( R7 .|. R8 ) + ( R7 .|. R9 ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
thus L288: ( R7 .|. ( R8 + R9 ) ) = ( ( ( R8 + R9 ) .|. R7 ) *' ) by L262
.= ( ( ( R8 .|. R7 ) + ( R9 .|. R7 ) ) *' ) by L262
.= ( ( ( R8 .|. R7 ) *' ) + ( ( R9 .|. R7 ) *' ) ) by COMPLEX1:32
.= ( ( R7 .|. R8 ) + ( ( R9 .|. R7 ) *' ) ) by L262
.= ( ( R7 .|. R8 ) + ( R7 .|. R9 ) ) by L262;
end;
theorem
L289: (for R2 being Complex holds (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( R7 .|. ( R2 * R8 ) ) = ( ( R2 *' ) * ( R7 .|. R8 ) )))))
proof
let R2 being Complex;
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
thus L290: ( R7 .|. ( R2 * R8 ) ) = ( ( ( R2 * R8 ) .|. R7 ) *' ) by L262
.= ( ( R2 * ( R8 .|. R7 ) ) *' ) by L262
.= ( ( R2 *' ) * ( ( R8 .|. R7 ) *' ) ) by COMPLEX1:35
.= ( ( R2 *' ) * ( R7 .|. R8 ) ) by L262;
end;
theorem
L291: (for R2 being Complex holds (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( R2 * R7 ) .|. R8 ) = ( R7 .|. ( ( R2 *' ) * R8 ) )))))
proof
let R2 being Complex;
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L292: ( ( R2 * R7 ) .|. R8 ) = ( R2 * ( R7 .|. R8 ) ) by L262
.= ( ( ( R2 *' ) *' ) * ( ( R8 .|. R7 ) *' ) ) by L262
.= ( ( ( R2 *' ) * ( R8 .|. R7 ) ) *' ) by COMPLEX1:35
.= ( ( ( ( R2 *' ) * R8 ) .|. R7 ) *' ) by L262;
thus L293: thesis by L292 , L262;
end;
theorem
L294: (for R2 being Complex holds (for R3 being Complex holds (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( ( ( R2 * R7 ) + ( R3 * R8 ) ) .|. R9 ) = ( ( R2 * ( R7 .|. R9 ) ) + ( R3 * ( R8 .|. R9 ) ) )))))))
proof
let R2 being Complex;
let R3 being Complex;
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
L295: ( ( ( R2 * R7 ) + ( R3 * R8 ) ) .|. R9 ) = ( ( ( R2 * R7 ) .|. R9 ) + ( ( R3 * R8 ) .|. R9 ) ) by L262
.= ( ( R2 * ( R7 .|. R9 ) ) + ( ( R3 * R8 ) .|. R9 ) ) by L262;
thus L296: thesis by L295 , L262;
end;
theorem
L297: (for R2 being Complex holds (for R3 being Complex holds (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( R7 .|. ( ( R2 * R8 ) + ( R3 * R9 ) ) ) = ( ( ( R2 *' ) * ( R7 .|. R8 ) ) + ( ( R3 *' ) * ( R7 .|. R9 ) ) )))))))
proof
let R2 being Complex;
let R3 being Complex;
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
L298: ( R7 .|. ( ( R2 * R8 ) + ( R3 * R9 ) ) ) = ( ( ( ( R2 * R8 ) + ( R3 * R9 ) ) .|. R7 ) *' ) by L262
.= ( ( ( R2 * ( R8 .|. R7 ) ) + ( R3 * ( R9 .|. R7 ) ) ) *' ) by L294
.= ( ( ( R2 * ( R8 .|. R7 ) ) *' ) + ( ( R3 * ( R9 .|. R7 ) ) *' ) ) by COMPLEX1:32
.= ( ( ( R2 *' ) * ( ( R8 .|. R7 ) *' ) ) + ( ( R3 * ( R9 .|. R7 ) ) *' ) ) by COMPLEX1:35
.= ( ( ( R2 *' ) * ( ( R8 .|. R7 ) *' ) ) + ( ( R3 *' ) * ( ( R9 .|. R7 ) *' ) ) ) by COMPLEX1:35
.= ( ( ( R2 *' ) * ( R7 .|. R8 ) ) + ( ( R3 *' ) * ( ( R9 .|. R7 ) *' ) ) ) by L262;
thus L299: thesis by L298 , L262;
end;
theorem
L300: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( - R7 ) .|. R8 ) = ( R7 .|. ( - R8 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L301: ( ( - R7 ) .|. R8 ) = ( ( ( - ( 1r ) ) * R7 ) .|. R8 ) by CLVECT_1:3
.= ( R7 .|. ( ( ( - ( 1r ) ) *' ) * R8 ) ) by L291
.= ( R7 .|. ( ( - ( 1r ) ) * R8 ) ) by COMPLEX1:30 , COMPLEX1:33;
thus L302: thesis by L301 , CLVECT_1:3;
end;
theorem
L303: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( - R7 ) .|. R8 ) = ( - ( R7 .|. R8 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L304: ( ( - R7 ) .|. R8 ) = ( ( ( - ( 1r ) ) * R7 ) .|. R8 ) by CLVECT_1:3
.= ( ( - 1 ) * ( R7 .|. R8 ) ) by L262 , COMPLEX1:def 4;
thus L305: thesis by L304;
end;
theorem
L306: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( R7 .|. ( - R8 ) ) = ( - ( R7 .|. R8 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L307: ( R7 .|. ( - R8 ) ) = ( ( - R7 ) .|. R8 ) by L300;
thus L308: thesis by L307 , L303;
end;
theorem
L309: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( - R7 ) .|. ( - R8 ) ) = ( R7 .|. R8 ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L310: ( ( - R7 ) .|. ( - R8 ) ) = ( - ( R7 .|. ( - R8 ) ) ) by L303
.= ( - ( - ( R7 .|. R8 ) ) ) by L306;
thus L311: thesis by L310;
end;
theorem
L312: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( ( R7 - R8 ) .|. R9 ) = ( ( R7 .|. R9 ) - ( R8 .|. R9 ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
L313: ( ( R7 - R8 ) .|. R9 ) = ( ( R7 .|. R9 ) + ( ( - R8 ) .|. R9 ) ) by L262
.= ( ( R7 .|. R9 ) + ( - ( R8 .|. R9 ) ) ) by L303;
thus L314: thesis by L313;
end;
theorem
L315: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( R7 .|. ( R8 - R9 ) ) = ( ( R7 .|. R8 ) - ( R7 .|. R9 ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
L316: ( R7 .|. ( R8 - R9 ) ) = ( ( R7 .|. R8 ) + ( R7 .|. ( - R9 ) ) ) by L287
.= ( ( R7 .|. R8 ) + ( - ( R7 .|. R9 ) ) ) by L306;
thus L317: thesis by L316;
end;
theorem
L318: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R10 being (Point of R6) holds (for R11 being (Point of R6) holds ( ( R7 - R8 ) .|. ( R10 - R11 ) ) = ( ( ( ( R7 .|. R10 ) - ( R7 .|. R11 ) ) - ( R8 .|. R10 ) ) + ( R8 .|. R11 ) ))))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R10 being (Point of R6);
let R11 being (Point of R6);
L319: ( ( R7 - R8 ) .|. ( R10 - R11 ) ) = ( ( R7 .|. ( R10 - R11 ) ) - ( R8 .|. ( R10 - R11 ) ) ) by L312
.= ( ( ( R7 .|. R10 ) - ( R7 .|. R11 ) ) - ( R8 .|. ( R10 - R11 ) ) ) by L315
.= ( ( ( R7 .|. R10 ) - ( R7 .|. R11 ) ) - ( ( R8 .|. R10 ) - ( R8 .|. R11 ) ) ) by L315;
thus L320: thesis by L319;
end;
theorem
L321: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds ( ( 0. R6 ) .|. R7 ) = ( 0 )))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L322: ( H3(R6) .|. R7 ) = ( ( R7 + ( - R7 ) ) .|. R7 ) by RLVECT_1:5
.= ( ( R7 .|. R7 ) + ( ( - R7 ) .|. R7 ) ) by L262
.= ( ( R7 .|. R7 ) + ( - ( R7 .|. R7 ) ) ) by L303;
thus L323: thesis by L322;
end;
theorem
L324: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds ( R7 .|. ( 0. R6 ) ) = ( 0 )))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L325: ( R7 .|. ( 0. R6 ) ) = ( ( ( 0. R6 ) .|. R7 ) *' ) by L262
.= ( 0c ) by L321 , COMPLEX1:28;
thus L326: thesis by L325;
end;
theorem
L327: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( R7 + R8 ) .|. ( R7 + R8 ) ) = ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L328: ( ( R7 + R8 ) .|. ( R7 + R8 ) ) = ( ( R7 .|. ( R7 + R8 ) ) + ( R8 .|. ( R7 + R8 ) ) ) by L262
.= ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. ( R7 + R8 ) ) ) by L287
.= ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( ( R8 .|. R7 ) + ( R8 .|. R8 ) ) ) by L287;
thus L329: thesis by L328;
end;
theorem
L330: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( R7 + R8 ) .|. ( R7 - R8 ) ) = ( ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) - ( R8 .|. R8 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L331: ( ( R7 + R8 ) .|. ( R7 - R8 ) ) = ( ( R7 .|. ( R7 - R8 ) ) + ( R8 .|. ( R7 - R8 ) ) ) by L262
.= ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) + ( R8 .|. ( R7 - R8 ) ) ) by L315
.= ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) + ( ( R8 .|. R7 ) - ( R8 .|. R8 ) ) ) by L315
.= ( ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( - ( R8 .|. R8 ) ) );
thus L332: thesis by L331;
end;
theorem
L333: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ( R7 - R8 ) .|. ( R7 - R8 ) ) = ( ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) - ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L334: ( ( R7 - R8 ) .|. ( R7 - R8 ) ) = ( ( R7 .|. ( R7 - R8 ) ) - ( R8 .|. ( R7 - R8 ) ) ) by L312
.= ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) - ( R8 .|. ( R7 - R8 ) ) ) by L315
.= ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) - ( ( R8 .|. R7 ) - ( R8 .|. R8 ) ) ) by L315;
thus L335: thesis by L334;
end;
L336: (for R6 being ComplexUnitarySpace holds (for B122 , B123 being Complex holds (for B124 , B125 being (Point of R6) holds ( ( ( B122 * B124 ) + ( B123 * B125 ) ) .|. ( ( B122 * B124 ) + ( B123 * B125 ) ) ) = ( ( ( ( ( B122 * ( B122 *' ) ) * ( B124 .|. B124 ) ) + ( ( B122 * ( B123 *' ) ) * ( B124 .|. B125 ) ) ) + ( ( ( B122 *' ) * B123 ) * ( B125 .|. B124 ) ) ) + ( ( B123 * ( B123 *' ) ) * ( B125 .|. B125 ) ) ))))
proof
let R6 being ComplexUnitarySpace;
let C104 , C105 being Complex;
let C106 , C107 being (Point of R6);
L337: ( ( ( C104 * C106 ) + ( C105 * C107 ) ) .|. ( ( C104 * C106 ) + ( C105 * C107 ) ) ) = ( ( C104 * ( C106 .|. ( ( C104 * C106 ) + ( C105 * C107 ) ) ) ) + ( C105 * ( C107 .|. ( ( C104 * C106 ) + ( C105 * C107 ) ) ) ) ) by L294
.= ( ( C104 * ( ( ( C104 *' ) * ( C106 .|. C106 ) ) + ( ( C105 *' ) * ( C106 .|. C107 ) ) ) ) + ( C105 * ( C107 .|. ( ( C104 * C106 ) + ( C105 * C107 ) ) ) ) ) by L297
.= ( ( ( ( C104 * ( C104 *' ) ) * ( C106 .|. C106 ) ) + ( ( C104 * ( C105 *' ) ) * ( C106 .|. C107 ) ) ) + ( C105 * ( ( ( C104 *' ) * ( C107 .|. C106 ) ) + ( ( C105 *' ) * ( C107 .|. C107 ) ) ) ) ) by L297
.= ( ( ( ( C104 * ( C104 *' ) ) * ( C106 .|. C106 ) ) + ( ( C104 * ( C105 *' ) ) * ( C106 .|. C107 ) ) ) + ( ( ( C105 * ( C104 *' ) ) * ( C107 .|. C106 ) ) + ( ( C105 * ( C105 *' ) ) * ( C107 .|. C107 ) ) ) );
thus L338: thesis by L337;
end;
theorem
L339: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds |. ( R7 .|. R7 ) .| = ( Re ( R7 .|. R7 ) )))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L340: ( Im ( R7 .|. R7 ) ) = ( 0 ) by L262;
L341: ( Re ( R7 .|. R7 ) ) >= ( 0 ) by L262;
L342: |. ( ( Re ( R7 .|. R7 ) ) + ( ( Im ( R7 .|. R7 ) ) * ( <i> ) ) ) .| = ( Re ( R7 .|. R7 ) ) by L341 , L340 , ABSVALUE:def 1;
thus L343: thesis by L342 , COMPLEX1:13;
end;
theorem
L344: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds |. ( R7 .|. R8 ) .| <= ( ( sqrt |. ( R7 .|. R7 ) .| ) * ( sqrt |. ( R8 .|. R8 ) .| ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L345: (R8 <> H3(R6) implies |. ( R7 .|. R8 ) .| <= ( ( sqrt |. ( R7 .|. R7 ) .| ) * ( sqrt |. ( R8 .|. R8 ) .| ) ))
proof
assume L346: R8 <> H3(R6);
L347: ( R8 .|. R8 ) <> ( 0c ) by L346 , L262;
L348: |. ( R8 .|. R8 ) .| <> ( 0 ) by L347 , COMPLEX1:45;
L349: ( ( Re ( R7 .|. R8 ) ) ^2 ) >= ( 0 ) by XREAL_1:63;
set D49 = ( - ( R7 .|. R8 ) );
reconsider D50 = ( |. ( R8 .|. R8 ) .| + ( ( 0 ) * ( <i> ) ) ) as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
L350: ( Re ( D50 * ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) ) = ( ( ( Re D50 ) * ( Re ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) ) - ( ( Im D50 ) * ( Im ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) ) ) by COMPLEX1:9
.= ( ( ( Re D50 ) * ( Re ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) ) - ( ( 0 ) * ( Im ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) ) ) by COMPLEX1:12
.= ( ( Re D50 ) * ( Re ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) );
L351: ( Re ( D49 * ( R8 .|. R7 ) ) ) = ( Re ( - ( ( R7 .|. R8 ) * ( R8 .|. R7 ) ) ) )
.= ( - ( Re ( ( R7 .|. R8 ) * ( R8 .|. R7 ) ) ) ) by COMPLEX1:17
.= ( - ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) ) by L262;
L352: ( Im ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) = ( 0 ) by COMPLEX1:40;
L353: ( Im ( R8 .|. R8 ) ) = ( 0 ) by L262;
L354: ( Re ( R8 .|. R8 ) ) >= ( 0 ) by L262;
L355: |. ( ( Re ( R8 .|. R8 ) ) + ( ( Im ( R8 .|. R8 ) ) * ( <i> ) ) ) .| = ( Re ( R8 .|. R8 ) ) by L354 , L353 , ABSVALUE:def 1;
L356: |. ( R8 .|. R8 ) .| = ( Re ( R8 .|. R8 ) ) by L355 , COMPLEX1:13;
L357: ( R8 .|. R8 ) = D50 by L356 , L353 , COMPLEX1:13;
L358: ( ( ( D50 * R7 ) + ( D49 * R8 ) ) .|. ( ( D50 * R7 ) + ( D49 * R8 ) ) ) = ( ( ( ( ( D50 * ( D50 *' ) ) * ( R7 .|. R7 ) ) + ( ( D50 * ( D49 *' ) ) * ( R7 .|. R8 ) ) ) + ( ( ( D50 *' ) * D49 ) * ( R8 .|. R7 ) ) ) + ( ( D49 * ( D49 *' ) ) * ( R8 .|. R8 ) ) ) by L336
.= ( ( ( ( D50 * ( ( D50 *' ) * ( R7 .|. R7 ) ) ) + ( D50 * ( ( D49 *' ) * ( R7 .|. R8 ) ) ) ) + ( ( D50 *' ) * ( D49 * ( R8 .|. R7 ) ) ) ) + ( D50 * ( D49 * ( D49 *' ) ) ) ) by L353 , L356 , COMPLEX1:13
.= ( ( ( D50 * ( ( ( D50 *' ) * ( R7 .|. R7 ) ) + ( ( D49 *' ) * ( R7 .|. R8 ) ) ) ) + ( D50 * ( D49 * ( R8 .|. R7 ) ) ) ) + ( D50 * ( D49 * ( D49 *' ) ) ) ) by L357 , L262
.= ( D50 * ( ( ( ( ( D50 *' ) * ( R7 .|. R7 ) ) + ( ( D49 *' ) * ( R7 .|. R8 ) ) ) + ( D49 * ( R8 .|. R7 ) ) ) + ( D49 * ( D49 *' ) ) ) )
.= ( D50 * ( ( ( ( D50 * ( R7 .|. R7 ) ) + ( ( R7 .|. R8 ) * ( D49 *' ) ) ) + ( D49 * ( R8 .|. R7 ) ) ) + ( D49 * ( D49 *' ) ) ) ) by L357 , L262
.= ( D50 * ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) );
L359: ( Re ( D50 * ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) ) >= ( 0 ) by L358 , L262;
L360: ((( Re D50 ) >= ( 0 ) & ( Re ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) >= ( 0 )) or (( Re D50 ) <= ( 0 ) & ( Re ( ( D50 * ( R7 .|. R7 ) ) + ( D49 * ( R8 .|. R7 ) ) ) ) <= ( 0 ))) by L359 , L350 , XREAL_1:132;
L361: ( ( Re ( D50 * ( R7 .|. R7 ) ) ) + ( Re ( D49 * ( R8 .|. R7 ) ) ) ) >= ( 0 ) by L360 , L354 , L353 , L356 , L348 , COMPLEX1:8 , COMPLEX1:13;
L362: ( ( Re ( D50 * ( R7 .|. R7 ) ) ) - ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) ) >= ( 0 ) by L361 , L351;
L363: ( Re ( D50 * ( R7 .|. R7 ) ) ) >= ( ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) + ( 0 ) ) by L362 , XREAL_1:19;
L364: ( Im ( R7 .|. R7 ) ) = ( 0 ) by L262;
L365: ( ( Im ( R7 .|. R8 ) ) ^2 ) >= ( 0 ) by XREAL_1:63;
L366: ( Im D50 ) = ( 0 ) by L353 , L356 , COMPLEX1:13;
L367: ( Im ( D50 * ( R7 .|. R7 ) ) ) = ( ( ( Re D50 ) * ( 0 ) ) + ( ( Re ( R7 .|. R7 ) ) * ( 0 ) ) ) by L366 , L364 , COMPLEX1:9;
L368: |. ( D50 * ( R7 .|. R7 ) ) .| = ( abs ( Re ( D50 * ( R7 .|. R7 ) ) ) ) by L367 , COMPLEX1:50;
L369: ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) = ( ( ( Re ( R7 .|. R8 ) ) ^2 ) + ( ( Im ( R7 .|. R8 ) ) ^2 ) ) by COMPLEX1:40;
L370: ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) >= ( ( 0 ) + ( 0 ) ) by L369 , L349 , L365 , XREAL_1:7;
L371: ( abs ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) ) = ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) by L370 , ABSVALUE:def 1;
L372: ( abs ( Re ( D50 * ( R7 .|. R7 ) ) ) ) >= ( abs ( Re ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) ) ) by L371 , L363 , L370 , ABSVALUE:def 1;
L373: |. ( D50 * ( R7 .|. R7 ) ) .| >= |. ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) .| by L372 , L352 , L368 , COMPLEX1:50;
L374: ( |. ( R7 .|. R7 ) .| * |. ( R8 .|. R8 ) .| ) >= |. ( ( R7 .|. R8 ) * ( ( R7 .|. R8 ) *' ) ) .| by L373 , L357 , COMPLEX1:65;
L375: ( |. ( R7 .|. R7 ) .| * |. ( R8 .|. R8 ) .| ) >= ( |. ( R7 .|. R8 ) .| * |. ( ( R7 .|. R8 ) *' ) .| ) by L374 , COMPLEX1:65;
L376: ( |. ( R7 .|. R7 ) .| * |. ( R8 .|. R8 ) .| ) >= ( |. ( R7 .|. R8 ) .| * |. ( R7 .|. R8 ) .| ) by L375 , COMPLEX1:53;
L377: ( |. ( R7 .|. R8 ) .| ^2 ) >= ( 0 ) by XREAL_1:63;
L378: ( sqrt ( |. ( R7 .|. R7 ) .| * |. ( R8 .|. R8 ) .| ) ) >= ( sqrt ( |. ( R7 .|. R8 ) .| ^2 ) ) by L377 , L376 , SQUARE_1:26;
L379: |. ( R8 .|. R8 ) .| >= ( 0 ) by COMPLEX1:46;
L380: |. ( R7 .|. R7 ) .| >= ( 0 ) by COMPLEX1:46;
L381: ( ( sqrt |. ( R7 .|. R7 ) .| ) * ( sqrt |. ( R8 .|. R8 ) .| ) ) >= ( sqrt ( |. ( R7 .|. R8 ) .| ^2 ) ) by L380 , L378 , L379 , SQUARE_1:29;
thus L382: thesis by L381 , COMPLEX1:46 , SQUARE_1:22;
end;
L383: (R8 = H3(R6) implies |. ( R7 .|. R8 ) .| <= ( ( sqrt |. ( R7 .|. R7 ) .| ) * ( sqrt |. ( R8 .|. R8 ) .| ) ))
proof
assume L384: R8 = H3(R6);
L385: ( R8 .|. R8 ) = ( 0c ) by L384 , L262;
thus L386: thesis by L385 , L384 , L324 , COMPLEX1:44 , SQUARE_1:17;
end;
thus L387: thesis by L383 , L345;
end;
definition
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
pred R7 , R8 are_orthogonal 
means
:L388: ( R7 .|. R8 ) = ( 0 )
;symmetry
 by L262 , COMPLEX1:28;
end;
theorem
L390: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 , R8 are_orthogonal  implies R7 , ( - R8 ) are_orthogonal ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
assume L391: R7 , R8 are_orthogonal ;
L392: ( - ( R7 .|. R8 ) ) = ( - ( 0 ) ) by L391 , L388;
L393: ( R7 .|. ( - R8 ) ) = ( 0 ) by L392 , L306;
thus L394: thesis by L393 , L388;
end;
theorem
L395: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 , R8 are_orthogonal  implies ( - R7 ) , R8 are_orthogonal ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
assume L396: R7 , R8 are_orthogonal ;
L397: ( - ( R7 .|. R8 ) ) = ( - ( 0 ) ) by L396 , L388;
L398: ( ( - R7 ) .|. R8 ) = ( 0 ) by L397 , L303;
thus L399: thesis by L398 , L388;
end;
theorem
L400: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 , R8 are_orthogonal  implies ( - R7 ) , ( - R8 ) are_orthogonal ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
assume L401: R7 , R8 are_orthogonal ;
L402: ( R7 .|. R8 ) = ( 0 ) by L401 , L388;
L403: ( ( - R7 ) .|. ( - R8 ) ) = ( 0 ) by L402 , L309;
thus L404: thesis by L403 , L388;
end;
theorem
L405: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds R7 , ( 0. R6 ) are_orthogonal ))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L406: ( ( 0. R6 ) .|. R7 ) = ( 0 ) by L321;
thus L407: thesis by L406 , L388;
end;
theorem
L408: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 , R8 are_orthogonal  implies ( ( R7 + R8 ) .|. ( R7 + R8 ) ) = ( ( R7 .|. R7 ) + ( R8 .|. R8 ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
assume L409: R7 , R8 are_orthogonal ;
L410: ( R8 .|. R7 ) = ( 0c ) by L409 , L388;
L411: ( R7 .|. R8 ) = ( 0c ) by L409 , L388;
L412: ( ( R7 + R8 ) .|. ( R7 + R8 ) ) = ( ( ( R7 .|. R7 ) + ( 0c ) ) + ( R8 .|. R8 ) ) by L411 , L410 , L327;
thus L413: thesis by L412;
end;
theorem
L414: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 , R8 are_orthogonal  implies ( ( R7 - R8 ) .|. ( R7 - R8 ) ) = ( ( R7 .|. R7 ) + ( R8 .|. R8 ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
assume L415: R7 , R8 are_orthogonal ;
L416: ( R7 .|. R8 ) = ( 0 ) by L415 , L388;
L417: ( ( R7 - R8 ) .|. ( R7 - R8 ) ) = ( ( ( ( R7 .|. R7 ) - ( R7 .|. R8 ) ) - ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) by L333
.= ( ( ( R7 .|. R7 ) + ( R8 .|. R8 ) ) - ( 0 ) ) by L415 , L416 , L388;
thus L418: thesis by L417;
end;
definition
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
func ||.R7 .|| -> Real equals 
( sqrt |. ( R7 .|. R7 ) .| );
correctness;
end;
theorem
L420: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (||. R7 .|| = ( 0 ) iff R7 = ( 0. R6 ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
thus L421: (||. R7 .|| = ( 0 ) implies R7 = H3(R6))
proof
L422: ( 0 ) <= ( Re ( R7 .|. R7 ) ) by L262;
L423: ( 0 ) <= |. ( R7 .|. R7 ) .| by L422 , L339;
assume L424: ||. R7 .|| = ( 0 );
L425: |. ( R7 .|. R7 ) .| = ( 0 ) by L424 , L423 , SQUARE_1:24;
L426: ( R7 .|. R7 ) = ( 0c ) by L425 , COMPLEX1:45;
thus L427: thesis by L426 , L262;
end;

assume L428: R7 = H3(R6);
thus L429: thesis by L428 , L262 , COMPLEX1:44 , SQUARE_1:17;
end;
theorem
L430: (for R2 being Complex holds (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds ||. ( R2 * R7 ) .|| = ( |. R2 .| * ||. R7 .|| ))))
proof
let R2 being Complex;
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L431: ( 0 ) <= |. ( R2 * R2 ) .| by COMPLEX1:46;
L432: ( 0 ) <= ( Re ( R7 .|. R7 ) ) by L262;
L433: ( 0 ) <= |. ( R7 .|. R7 ) .| by L432 , L339;
L434: ||. ( R2 * R7 ) .|| = ( sqrt |. ( R2 * ( R7 .|. ( R2 * R7 ) ) ) .| ) by L262
.= ( sqrt |. ( R2 * ( ( R2 *' ) * ( R7 .|. R7 ) ) ) .| ) by L289
.= ( sqrt |. ( ( R2 * ( R2 *' ) ) * ( R7 .|. R7 ) ) .| )
.= ( sqrt ( |. ( R2 * ( R2 *' ) ) .| * |. ( R7 .|. R7 ) .| ) ) by COMPLEX1:65
.= ( sqrt ( |. ( R2 * R2 ) .| * |. ( R7 .|. R7 ) .| ) ) by COMPLEX1:69
.= ( ( sqrt |. ( R2 * R2 ) .| ) * ( sqrt |. ( R7 .|. R7 ) .| ) ) by L431 , L433 , SQUARE_1:29
.= ( ( sqrt ( |. R2 .| ^2 ) ) * ( sqrt |. ( R7 .|. R7 ) .| ) ) by COMPLEX1:65
.= ( |. R2 .| * ( sqrt |. ( R7 .|. R7 ) .| ) ) by COMPLEX1:46 , SQUARE_1:22;
thus L435: thesis by L434;
end;
theorem
L436: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds ( 0 ) <= ||. R7 .||))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L437: ( 0 ) <= ( Re ( R7 .|. R7 ) ) by L262;
L438: ( 0 ) <= |. ( R7 .|. R7 ) .| by L437 , L339;
thus L439: thesis by L438 , SQUARE_1:def 2;
end;
theorem
L440: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds |. ( R7 .|. R8 ) .| <= ( ||. R7 .|| * ||. R8 .|| )))) by L344;
theorem
L441: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ||. ( R7 + R8 ) .|| <= ( ||. R7 .|| + ||. R8 .|| ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L442: ( ||. ( R7 + R8 ) .|| ^2 ) >= ( 0 ) by XREAL_1:63;
L443: ( Re ( ( R7 + R8 ) .|. ( R7 + R8 ) ) ) >= ( 0 ) by L262;
L444: |. ( ( R7 + R8 ) .|. ( R7 + R8 ) ) .| >= ( 0 ) by L443 , L339;
L445: ( sqrt ( ||. ( R7 + R8 ) .|| ^2 ) ) = ( sqrt |. ( ( R7 + R8 ) .|. ( R7 + R8 ) ) .| ) by L436 , SQUARE_1:22;
L446: ( ||. ( R7 + R8 ) .|| ^2 ) = |. ( ( R7 + R8 ) .|. ( R7 + R8 ) ) .| by L445 , L444 , L442 , SQUARE_1:28;
L447: |. ( R8 .|. R8 ) .| >= ( 0 ) by COMPLEX1:46;
L448: |. ( R8 .|. R8 ) .| = ( ||. R8 .|| ^2 ) by L447 , SQUARE_1:def 2;
L449: ( - ( Im ( R7 .|. R8 ) ) ) = ( Im ( ( R7 .|. R8 ) *' ) ) by COMPLEX1:27
.= ( Im ( R8 .|. R7 ) ) by L262;
L450: ( Im ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) ) = ( ( Im ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) ) + ( Im ( R8 .|. R8 ) ) ) by COMPLEX1:8
.= ( ( ( Im ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) ) + ( Im ( R8 .|. R7 ) ) ) + ( Im ( R8 .|. R8 ) ) ) by COMPLEX1:8
.= ( ( ( ( Im ( R7 .|. R7 ) ) + ( Im ( R7 .|. R8 ) ) ) + ( Im ( R8 .|. R7 ) ) ) + ( Im ( R8 .|. R8 ) ) ) by COMPLEX1:8
.= ( ( ( ( 0 ) + ( Im ( R7 .|. R8 ) ) ) + ( Im ( R8 .|. R7 ) ) ) + ( Im ( R8 .|. R8 ) ) ) by L262
.= ( ( ( Im ( R7 .|. R8 ) ) + ( Im ( R8 .|. R7 ) ) ) + ( 0 ) ) by L262;
L451: ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) = ( ( Re ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) ) + ( ( 0 ) * ( <i> ) ) ) by L450 , L449 , COMPLEX1:13;
L452: ( Re ( R7 .|. R8 ) ) = ( Re ( ( R7 .|. R8 ) *' ) ) by COMPLEX1:27
.= ( Re ( R8 .|. R7 ) ) by L262;
L453: ( Re ( R7 .|. R8 ) ) <= |. ( R7 .|. R8 ) .| by COMPLEX1:54;
L454: |. ( R7 .|. R8 ) .| <= ( ||. R7 .|| * ||. R8 .|| ) by L344;
L455: ( Re ( R7 .|. R8 ) ) <= ( ||. R7 .|| * ||. R8 .|| ) by L454 , L453 , XXREAL_0:2;
L456: ( 2 * ( Re ( R7 .|. R8 ) ) ) <= ( 2 * ( ||. R7 .|| * ||. R8 .|| ) ) by L455 , XREAL_1:64;
L457: ( Re ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) ) = ( Re ( ( R7 + R8 ) .|. ( R7 + R8 ) ) ) by L327;
L458: ( Re ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) ) >= ( 0 ) by L457 , L262;
L459: ( Re ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) ) = ( ( Re ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) ) + ( Re ( R8 .|. R8 ) ) ) by COMPLEX1:8
.= ( ( ( Re ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) ) + ( Re ( R8 .|. R7 ) ) ) + ( Re ( R8 .|. R8 ) ) ) by COMPLEX1:8
.= ( ( ( ( Re ( R7 .|. R7 ) ) + ( Re ( R7 .|. R8 ) ) ) + ( Re ( R8 .|. R7 ) ) ) + ( Re ( R8 .|. R8 ) ) ) by COMPLEX1:8
.= ( ( ( |. ( R7 .|. R7 ) .| + ( Re ( R7 .|. R8 ) ) ) + ( Re ( R8 .|. R7 ) ) ) + ( Re ( R8 .|. R8 ) ) ) by L339
.= ( ( ( |. ( R7 .|. R7 ) .| + ( Re ( R7 .|. R8 ) ) ) + ( Re ( R8 .|. R7 ) ) ) + |. ( R8 .|. R8 ) .| ) by L339;
L460: |. ( ( ( ( R7 .|. R7 ) + ( R7 .|. R8 ) ) + ( R8 .|. R7 ) ) + ( R8 .|. R8 ) ) .| = ( ( |. ( R7 .|. R7 ) .| + ( 2 * ( Re ( R7 .|. R8 ) ) ) ) + |. ( R8 .|. R8 ) .| ) by L459 , L452 , L458 , L451 , ABSVALUE:def 1;
L461: ( ||. ( R7 + R8 ) .|| ^2 ) = ( ( 2 * ( Re ( R7 .|. R8 ) ) ) + ( |. ( R7 .|. R7 ) .| + |. ( R8 .|. R8 ) .| ) ) by L460 , L446 , L327;
L462: ||. R8 .|| >= ( 0 ) by L436;
L463: |. ( R7 .|. R7 ) .| >= ( 0 ) by COMPLEX1:46;
L464: ( ( sqrt |. ( R7 .|. R7 ) .| ) ^2 ) = |. ( R7 .|. R7 ) .| by L463 , SQUARE_1:def 2;
L465: ( ||. ( R7 + R8 ) .|| ^2 ) <= ( ( 2 * ( ||. R7 .|| * ||. R8 .|| ) ) + ( ( ||. R7 .|| ^2 ) + |. ( R8 .|. R8 ) .| ) ) by L464 , L461 , L456 , XREAL_1:6;
L466: ( ||. ( R7 + R8 ) .|| ^2 ) <= ( ( ||. R7 .|| + ||. R8 .|| ) ^2 ) by L465 , L448;
L467: ||. R7 .|| >= ( 0 ) by L436;
L468: ( ||. R7 .|| + ||. R8 .|| ) >= ( ( 0 ) + ( 0 ) ) by L467 , L462 , XREAL_1:7;
thus L469: thesis by L468 , L466 , SQUARE_1:16;
end;
theorem
L470: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds ||. ( - R7 ) .|| = ||. R7 .||))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
L471: ||. ( - R7 ) .|| = ||. ( ( - ( 1r ) ) * R7 ) .|| by CLVECT_1:3
.= ( |. ( - ( 1r ) ) .| * ||. R7 .|| ) by L430
.= ( |. ( 1r ) .| * ||. R7 .|| ) by COMPLEX1:52;
thus L472: thesis by L471 , COMPLEX1:48;
end;
theorem
L473: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( ||. R7 .|| - ||. R8 .|| ) <= ||. ( R7 - R8 ) .||)))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L474: ( ( R7 - R8 ) + R8 ) = ( R7 - ( R8 - R8 ) ) by RLVECT_1:29
.= ( R7 - H3(R6) ) by RLVECT_1:15
.= R7 by RLVECT_1:13;
L475: ||. R7 .|| <= ( ||. ( R7 - R8 ) .|| + ||. R8 .|| ) by L474 , L441;
thus L476: thesis by L475 , XREAL_1:20;
end;
theorem
L477: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( abs ( ||. R7 .|| - ||. R8 .|| ) ) <= ||. ( R7 - R8 ) .||)))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
L478: ( ( R8 - R7 ) + R7 ) = ( R8 - ( R7 - R7 ) ) by RLVECT_1:29
.= ( R8 - H3(R6) ) by RLVECT_1:15
.= R8 by RLVECT_1:13;
L479: ||. R8 .|| <= ( ||. ( R8 - R7 ) .|| + ||. R7 .|| ) by L478 , L441;
L480: ( ||. R8 .|| - ||. R7 .|| ) <= ||. ( R8 - R7 ) .|| by L479 , XREAL_1:20;
L481: ( ||. R8 .|| - ||. R7 .|| ) <= ||. ( - ( R7 - R8 ) ) .|| by L480 , RLVECT_1:33;
L482: ( ||. R8 .|| - ||. R7 .|| ) <= ||. ( R7 - R8 ) .|| by L481 , L470;
L483: ( - ||. ( R7 - R8 ) .|| ) <= ( - ( ||. R8 .|| - ||. R7 .|| ) ) by L482 , XREAL_1:24;
L484: ( ||. R7 .|| - ||. R8 .|| ) <= ||. ( R7 - R8 ) .|| by L473;
thus L485: thesis by L484 , L483 , ABSVALUE:5;
end;
definition
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
func dist (R7 , R8) -> Real equals 
||. ( R7 - R8 ) .||;
correctness;
end;
definition
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
redefine func dist (R7 , R8);

commutativity
proof
let R7 being (Point of R6);
let R8 being (Point of R6);
thus L487: ( dist (R7 , R8) ) = ||. ( - ( R8 - R7 ) ) .|| by RLVECT_1:33
.= ( dist (R8 , R7) ) by L470;
end;
end;
theorem
L489: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds ( dist (R7 , R7) ) = ( 0 )))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
thus L490: ( dist (R7 , R7) ) = ||. H3(R6) .|| by RLVECT_1:15
.= ( 0 ) by L420;
end;
theorem
L491: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( dist (R7 , R9) ) <= ( ( dist (R7 , R8) ) + ( dist (R8 , R9) ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
L492: ( dist (R7 , R9) ) = ||. ( ( R7 - R9 ) + H3(R6) ) .|| by RLVECT_1:4
.= ||. ( ( R7 - R9 ) + ( R8 - R8 ) ) .|| by RLVECT_1:15
.= ||. ( R7 - ( R9 - ( R8 - R8 ) ) ) .|| by RLVECT_1:29
.= ||. ( R7 - ( R8 + ( R9 - R8 ) ) ) .|| by RLVECT_1:29
.= ||. ( ( R7 - R8 ) - ( R9 - R8 ) ) .|| by RLVECT_1:27
.= ||. ( ( R7 - R8 ) + ( R8 - R9 ) ) .|| by RLVECT_1:33;
thus L493: thesis by L492 , L441;
end;
theorem
L494: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 <> R8 iff ( dist (R7 , R8) ) <> ( 0 )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
thus L495: (R7 <> R8 implies ( dist (R7 , R8) ) <> ( 0 ))
proof
assume that
L496: R7 <> R8
and
L497: ( dist (R7 , R8) ) = ( 0 );
L498: ( R7 - R8 ) = H3(R6) by L497 , L420;
thus L499: contradiction by L498 , L496 , RLVECT_1:21;
end;

thus L500: thesis by L489;
end;
theorem
L501: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( dist (R7 , R8) ) >= ( 0 )))) by L436;
theorem
L502: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (R7 <> R8 iff ( dist (R7 , R8) ) > ( 0 )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
thus L503: (R7 <> R8 implies ( dist (R7 , R8) ) > ( 0 ))
proof
assume L504: R7 <> R8;
L505: ( dist (R7 , R8) ) <> ( 0 ) by L504 , L494;
thus L506: thesis by L505 , L436;
end;

thus L507: thesis by L489;
end;
theorem
L508: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds ( dist (R7 , R8) ) = ( sqrt |. ( ( R7 - R8 ) .|. ( R7 - R8 ) ) .| ))));
theorem
L509: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R10 being (Point of R6) holds (for R11 being (Point of R6) holds ( dist (( R7 + R8 ) , ( R10 + R11 )) ) <= ( ( dist (R7 , R10) ) + ( dist (R8 , R11) ) ))))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R10 being (Point of R6);
let R11 being (Point of R6);
L510: ( dist (( R7 + R8 ) , ( R10 + R11 )) ) = ||. ( ( ( - R10 ) + ( - R11 ) ) + ( R7 + R8 ) ) .|| by RLVECT_1:31
.= ||. ( ( R7 + ( ( - R10 ) + ( - R11 ) ) ) + R8 ) .|| by RLVECT_1:def 3
.= ||. ( ( ( R7 - R10 ) + ( - R11 ) ) + R8 ) .|| by RLVECT_1:def 3
.= ||. ( ( R7 - R10 ) + ( R8 - R11 ) ) .|| by RLVECT_1:def 3;
thus L511: thesis by L510 , L441;
end;
theorem
L512: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R10 being (Point of R6) holds (for R11 being (Point of R6) holds ( dist (( R7 - R8 ) , ( R10 - R11 )) ) <= ( ( dist (R7 , R10) ) + ( dist (R8 , R11) ) ))))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R10 being (Point of R6);
let R11 being (Point of R6);
L513: ( dist (( R7 - R8 ) , ( R10 - R11 )) ) = ||. ( ( ( R7 - R8 ) - R10 ) + R11 ) .|| by RLVECT_1:29
.= ||. ( ( R7 - ( R10 + R8 ) ) + R11 ) .|| by RLVECT_1:27
.= ||. ( ( ( R7 - R10 ) - R8 ) + R11 ) .|| by RLVECT_1:27
.= ||. ( ( R7 - R10 ) - ( R8 - R11 ) ) .|| by RLVECT_1:29
.= ||. ( ( R7 - R10 ) + ( - ( R8 - R11 ) ) ) .||;
L514: ( dist (( R7 - R8 ) , ( R10 - R11 )) ) <= ( ||. ( R7 - R10 ) .|| + ||. ( - ( R8 - R11 ) ) .|| ) by L513 , L441;
thus L515: thesis by L514 , L470;
end;
theorem
L516: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( dist (( R7 - R9 ) , ( R8 - R9 )) ) = ( dist (R7 , R8) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
thus L517: ( dist (( R7 - R9 ) , ( R8 - R9 )) ) = ||. ( ( ( R7 - R9 ) - R8 ) + R9 ) .|| by RLVECT_1:29
.= ||. ( ( R7 - ( R8 + R9 ) ) + R9 ) .|| by RLVECT_1:27
.= ||. ( ( ( R7 - R8 ) - R9 ) + R9 ) .|| by RLVECT_1:27
.= ||. ( ( R7 - R8 ) - ( R9 - R9 ) ) .|| by RLVECT_1:29
.= ||. ( ( R7 - R8 ) - H3(R6) ) .|| by RLVECT_1:15
.= ( dist (R7 , R8) ) by RLVECT_1:13;
end;
theorem
L518: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R8 being (Point of R6) holds (for R9 being (Point of R6) holds ( dist (( R7 - R9 ) , ( R8 - R9 )) ) <= ( ( dist (R9 , R7) ) + ( dist (R9 , R8) ) )))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R8 being (Point of R6);
let R9 being (Point of R6);
L519: ( dist (( R7 - R9 ) , ( R8 - R9 )) ) = ||. ( ( R7 - R9 ) + ( R9 - R8 ) ) .|| by RLVECT_1:33
.= ||. ( ( - ( R9 - R7 ) ) + ( R9 - R8 ) ) .|| by RLVECT_1:33;
L520: ( dist (( R7 - R9 ) , ( R8 - R9 )) ) <= ( ||. ( - ( R9 - R7 ) ) .|| + ||. ( R9 - R8 ) .|| ) by L519 , L441;
thus L521: thesis by L520 , L470;
end;
definition
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
redefine func R13 + R14;

commutativity
proof
let R13 being (sequence of R6);
let R14 being (sequence of R6);
L522:
now
let R16 being (Element of ( NAT ));
thus L523: ( ( R13 + R14 ) . R16 ) = ( ( R14 . R16 ) + ( R13 . R16 ) ) by NORMSP_1:def 2
.= ( ( R14 + R13 ) . R16 ) by NORMSP_1:def 2;
end;
thus L524: thesis by L522 , FUNCT_2:63;
end;
end;
theorem
L526: (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds (for R15 being (sequence of R6) holds ( R13 + ( R14 + R15 ) ) = ( ( R13 + R14 ) + R15 )))))
proof
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
let R15 being (sequence of R6);
L527:
now
let R16 being (Element of ( NAT ));
thus L528: ( ( R13 + ( R14 + R15 ) ) . R16 ) = ( ( R13 . R16 ) + ( ( R14 + R15 ) . R16 ) ) by NORMSP_1:def 2
.= ( ( R13 . R16 ) + ( ( R14 . R16 ) + ( R15 . R16 ) ) ) by NORMSP_1:def 2
.= ( ( ( R13 . R16 ) + ( R14 . R16 ) ) + ( R15 . R16 ) ) by RLVECT_1:def 3
.= ( ( ( R13 + R14 ) . R16 ) + ( R15 . R16 ) ) by NORMSP_1:def 2
.= ( ( ( R13 + R14 ) + R15 ) . R16 ) by NORMSP_1:def 2;
end;
thus L529: thesis by L527 , FUNCT_2:63;
end;
theorem
L530: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds ((R13 is  constant & R14 is  constant & R12 = ( R13 + R14 )) implies R12 is  constant)))))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
let R13 being (sequence of R6);
let R14 being (sequence of R6);
assume that
L531: R13 is  constant
and
L532: R14 is  constant
and
L533: R12 = ( R13 + R14 );
consider R7 being (Point of R6) such that L534: (for B126 being Nat holds ( R13 . B126 ) = R7) by L531 , VALUED_0:def 18;
consider R8 being (Point of R6) such that L535: (for B127 being Nat holds ( R14 . B127 ) = R8) by L532 , VALUED_0:def 18;
take D51 = ( R7 + R8 );
let C108 being Nat;
L536: C108 in ( NAT ) by ORDINAL1:def 12;
thus L537: ( R12 . C108 ) = ( ( R13 . C108 ) + ( R14 . C108 ) ) by L536 , L533 , NORMSP_1:def 2
.= ( R7 + ( R14 . C108 ) ) by L534
.= D51 by L535;
end;
theorem
L538: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds ((R13 is  constant & R14 is  constant & R12 = ( R13 - R14 )) implies R12 is  constant)))))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
let R13 being (sequence of R6);
let R14 being (sequence of R6);
assume that
L539: R13 is  constant
and
L540: R14 is  constant
and
L541: R12 = ( R13 - R14 );
consider R7 being (Point of R6) such that L542: (for B128 being Nat holds ( R13 . B128 ) = R7) by L539 , VALUED_0:def 18;
consider R8 being (Point of R6) such that L543: (for B129 being Nat holds ( R14 . B129 ) = R8) by L540 , VALUED_0:def 18;
take D52 = ( R7 - R8 );
let C109 being Nat;
L544: C109 in ( NAT ) by ORDINAL1:def 12;
thus L545: ( R12 . C109 ) = ( ( R13 . C109 ) - ( R14 . C109 ) ) by L544 , L541 , NORMSP_1:def 3
.= ( R7 - ( R14 . C109 ) ) by L542
.= D52 by L543;
end;
theorem
L546: (for R2 being Complex holds (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds (for R13 being (sequence of R6) holds ((R13 is  constant & R12 = ( R2 * R13 )) implies R12 is  constant)))))
proof
let R2 being Complex;
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
let R13 being (sequence of R6);
assume that
L547: R13 is  constant
and
L548: R12 = ( R2 * R13 );
consider R7 being (Point of R6) such that L549: (for B130 being Nat holds ( R13 . B130 ) = R7) by L547 , VALUED_0:def 18;
take D53 = ( R2 * R7 );
let C110 being Nat;
L550: C110 in ( NAT ) by ORDINAL1:def 12;
thus L551: ( R12 . C110 ) = ( R2 * ( R13 . C110 ) ) by L550 , L548 , CLVECT_1:def 14
.= D53 by L549;
end;
theorem
L552: (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds ( R13 - R14 ) = ( R13 + ( - R14 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
L553:
now
let R16 being (Element of ( NAT ));
thus L554: ( ( R13 - R14 ) . R16 ) = ( ( R13 . R16 ) - ( R14 . R16 ) ) by NORMSP_1:def 3
.= ( ( R13 . R16 ) + ( ( - R14 ) . R16 ) ) by BHSP_1:44
.= ( ( R13 + ( - R14 ) ) . R16 ) by NORMSP_1:def 2;
end;
thus L555: thesis by L553 , FUNCT_2:63;
end;
theorem
L556: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds R12 = ( R12 + ( 0. R6 ) )))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L557:
now
let R16 being (Element of ( NAT ));
thus L558: ( ( R12 + H3(R6) ) . R16 ) = ( ( R12 . R16 ) + H3(R6) ) by BHSP_1:def 6
.= ( R12 . R16 ) by RLVECT_1:4;
end;
thus L559: thesis by L557 , FUNCT_2:63;
end;
theorem
L560: (for R2 being Complex holds (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds ( R2 * ( R13 + R14 ) ) = ( ( R2 * R13 ) + ( R2 * R14 ) )))))
proof
let R2 being Complex;
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
L561:
now
let R16 being (Element of ( NAT ));
thus L562: ( ( R2 * ( R13 + R14 ) ) . R16 ) = ( R2 * ( ( R13 + R14 ) . R16 ) ) by CLVECT_1:def 14
.= ( R2 * ( ( R13 . R16 ) + ( R14 . R16 ) ) ) by NORMSP_1:def 2
.= ( ( R2 * ( R13 . R16 ) ) + ( R2 * ( R14 . R16 ) ) ) by CLVECT_1:def 2
.= ( ( ( R2 * R13 ) . R16 ) + ( R2 * ( R14 . R16 ) ) ) by CLVECT_1:def 14
.= ( ( ( R2 * R13 ) . R16 ) + ( ( R2 * R14 ) . R16 ) ) by CLVECT_1:def 14
.= ( ( ( R2 * R13 ) + ( R2 * R14 ) ) . R16 ) by NORMSP_1:def 2;
end;
thus L563: thesis by L561 , FUNCT_2:63;
end;
theorem
L564: (for R2 being Complex holds (for R3 being Complex holds (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds ( ( R2 + R3 ) * R12 ) = ( ( R2 * R12 ) + ( R3 * R12 ) )))))
proof
let R2 being Complex;
let R3 being Complex;
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L565:
now
let R16 being (Element of ( NAT ));
thus L566: ( ( ( R2 + R3 ) * R12 ) . R16 ) = ( ( R2 + R3 ) * ( R12 . R16 ) ) by CLVECT_1:def 14
.= ( ( R2 * ( R12 . R16 ) ) + ( R3 * ( R12 . R16 ) ) ) by CLVECT_1:def 3
.= ( ( ( R2 * R12 ) . R16 ) + ( R3 * ( R12 . R16 ) ) ) by CLVECT_1:def 14
.= ( ( ( R2 * R12 ) . R16 ) + ( ( R3 * R12 ) . R16 ) ) by CLVECT_1:def 14
.= ( ( ( R2 * R12 ) + ( R3 * R12 ) ) . R16 ) by NORMSP_1:def 2;
end;
thus L567: thesis by L565 , FUNCT_2:63;
end;
theorem
L568: (for R2 being Complex holds (for R3 being Complex holds (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds ( ( R2 * R3 ) * R12 ) = ( R2 * ( R3 * R12 ) )))))
proof
let R2 being Complex;
let R3 being Complex;
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L569:
now
let R16 being (Element of ( NAT ));
thus L570: ( ( ( R2 * R3 ) * R12 ) . R16 ) = ( ( R2 * R3 ) * ( R12 . R16 ) ) by CLVECT_1:def 14
.= ( R2 * ( R3 * ( R12 . R16 ) ) ) by CLVECT_1:def 4
.= ( R2 * ( ( R3 * R12 ) . R16 ) ) by CLVECT_1:def 14
.= ( ( R2 * ( R3 * R12 ) ) . R16 ) by CLVECT_1:def 14;
end;
thus L571: thesis by L569 , FUNCT_2:63;
end;
theorem
L572: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds ( ( 1r ) * R12 ) = R12))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L573:
now
let R16 being (Element of ( NAT ));
thus L574: ( ( ( 1r ) * R12 ) . R16 ) = ( ( 1r ) * ( R12 . R16 ) ) by CLVECT_1:def 14
.= ( R12 . R16 ) by CLVECT_1:def 5;
end;
thus L575: thesis by L573 , FUNCT_2:63;
end;
theorem
L576: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds ( ( - ( 1r ) ) * R12 ) = ( - R12 )))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L577:
now
let R16 being (Element of ( NAT ));
thus L578: ( ( ( - ( 1r ) ) * R12 ) . R16 ) = ( ( - ( 1r ) ) * ( R12 . R16 ) ) by CLVECT_1:def 14
.= ( - ( R12 . R16 ) ) by CLVECT_1:3
.= ( ( - R12 ) . R16 ) by BHSP_1:44;
end;
thus L579: thesis by L577 , FUNCT_2:63;
end;
theorem
L580: (for R6 being ComplexUnitarySpace holds (for R7 being (Point of R6) holds (for R12 being (sequence of R6) holds ( R12 - R7 ) = ( R12 + ( - R7 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R7 being (Point of R6);
let R12 being (sequence of R6);
L581:
now
let R16 being (Element of ( NAT ));
thus L582: ( ( R12 - R7 ) . R16 ) = ( ( R12 . R16 ) - R7 ) by NORMSP_1:def 4
.= ( ( R12 + ( - R7 ) ) . R16 ) by BHSP_1:def 6;
end;
thus L583: thesis by L581 , FUNCT_2:63;
end;
theorem
L584: (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds ( R13 - R14 ) = ( - ( R14 - R13 ) ))))
proof
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
L585:
now
let R16 being (Element of ( NAT ));
thus L586: ( ( R13 - R14 ) . R16 ) = ( ( R13 . R16 ) - ( R14 . R16 ) ) by NORMSP_1:def 3
.= ( - ( ( R14 . R16 ) - ( R13 . R16 ) ) ) by RLVECT_1:33
.= ( - ( ( R14 - R13 ) . R16 ) ) by NORMSP_1:def 3
.= ( ( - ( R14 - R13 ) ) . R16 ) by BHSP_1:44;
end;
thus L587: thesis by L585 , FUNCT_2:63;
end;
theorem
L588: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds R12 = ( R12 - ( 0. R6 ) )))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L589:
now
let R16 being (Element of ( NAT ));
thus L590: ( ( R12 - H3(R6) ) . R16 ) = ( ( R12 . R16 ) - H3(R6) ) by NORMSP_1:def 4
.= ( R12 . R16 ) by RLVECT_1:13;
end;
thus L591: thesis by L589 , FUNCT_2:63;
end;
theorem
L592: (for R6 being ComplexUnitarySpace holds (for R12 being (sequence of R6) holds R12 = ( - ( - R12 ) )))
proof
let R6 being ComplexUnitarySpace;
let R12 being (sequence of R6);
L593:
now
let R16 being (Element of ( NAT ));
thus L594: ( ( - ( - R12 ) ) . R16 ) = ( - ( ( - R12 ) . R16 ) ) by BHSP_1:44
.= ( - ( - ( R12 . R16 ) ) ) by BHSP_1:44
.= ( R12 . R16 ) by RLVECT_1:17;
end;
thus L595: thesis by L593 , FUNCT_2:63;
end;
theorem
L596: (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds (for R15 being (sequence of R6) holds ( R13 - ( R14 + R15 ) ) = ( ( R13 - R14 ) - R15 )))))
proof
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
let R15 being (sequence of R6);
L597:
now
let R16 being (Element of ( NAT ));
thus L598: ( ( R13 - ( R14 + R15 ) ) . R16 ) = ( ( R13 . R16 ) - ( ( R14 + R15 ) . R16 ) ) by NORMSP_1:def 3
.= ( ( R13 . R16 ) - ( ( R14 . R16 ) + ( R15 . R16 ) ) ) by NORMSP_1:def 2
.= ( ( ( R13 . R16 ) - ( R14 . R16 ) ) - ( R15 . R16 ) ) by RLVECT_1:27
.= ( ( ( R13 - R14 ) . R16 ) - ( R15 . R16 ) ) by NORMSP_1:def 3
.= ( ( ( R13 - R14 ) - R15 ) . R16 ) by NORMSP_1:def 3;
end;
thus L599: thesis by L597 , FUNCT_2:63;
end;
theorem
L600: (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds (for R15 being (sequence of R6) holds ( ( R13 + R14 ) - R15 ) = ( R13 + ( R14 - R15 ) )))))
proof
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
let R15 being (sequence of R6);
L601:
now
let R16 being (Element of ( NAT ));
thus L602: ( ( ( R13 + R14 ) - R15 ) . R16 ) = ( ( ( R13 + R14 ) . R16 ) - ( R15 . R16 ) ) by NORMSP_1:def 3
.= ( ( ( R13 . R16 ) + ( R14 . R16 ) ) - ( R15 . R16 ) ) by NORMSP_1:def 2
.= ( ( R13 . R16 ) + ( ( R14 . R16 ) - ( R15 . R16 ) ) ) by RLVECT_1:def 3
.= ( ( R13 . R16 ) + ( ( R14 - R15 ) . R16 ) ) by NORMSP_1:def 3
.= ( ( R13 + ( R14 - R15 ) ) . R16 ) by NORMSP_1:def 2;
end;
thus L603: thesis by L601 , FUNCT_2:63;
end;
theorem
L604: (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds (for R15 being (sequence of R6) holds ( R13 - ( R14 - R15 ) ) = ( ( R13 - R14 ) + R15 )))))
proof
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
let R15 being (sequence of R6);
L605:
now
let R16 being (Element of ( NAT ));
thus L606: ( ( R13 - ( R14 - R15 ) ) . R16 ) = ( ( R13 . R16 ) - ( ( R14 - R15 ) . R16 ) ) by NORMSP_1:def 3
.= ( ( R13 . R16 ) - ( ( R14 . R16 ) - ( R15 . R16 ) ) ) by NORMSP_1:def 3
.= ( ( ( R13 . R16 ) - ( R14 . R16 ) ) + ( R15 . R16 ) ) by RLVECT_1:29
.= ( ( ( R13 - R14 ) . R16 ) + ( R15 . R16 ) ) by NORMSP_1:def 3
.= ( ( ( R13 - R14 ) + R15 ) . R16 ) by NORMSP_1:def 2;
end;
thus L607: thesis by L605 , FUNCT_2:63;
end;
theorem
L608: (for R2 being Complex holds (for R6 being ComplexUnitarySpace holds (for R13 being (sequence of R6) holds (for R14 being (sequence of R6) holds ( R2 * ( R13 - R14 ) ) = ( ( R2 * R13 ) - ( R2 * R14 ) )))))
proof
let R2 being Complex;
let R6 being ComplexUnitarySpace;
let R13 being (sequence of R6);
let R14 being (sequence of R6);
L609:
now
let R16 being (Element of ( NAT ));
thus L610: ( ( R2 * ( R13 - R14 ) ) . R16 ) = ( R2 * ( ( R13 - R14 ) . R16 ) ) by CLVECT_1:def 14
.= ( R2 * ( ( R13 . R16 ) - ( R14 . R16 ) ) ) by NORMSP_1:def 3
.= ( ( R2 * ( R13 . R16 ) ) - ( R2 * ( R14 . R16 ) ) ) by CLVECT_1:9
.= ( ( ( R2 * R13 ) . R16 ) - ( R2 * ( R14 . R16 ) ) ) by CLVECT_1:def 14
.= ( ( ( R2 * R13 ) . R16 ) - ( ( R2 * R14 ) . R16 ) ) by CLVECT_1:def 14
.= ( ( ( R2 * R13 ) - ( R2 * R14 ) ) . R16 ) by NORMSP_1:def 3;
end;
thus L611: thesis by L609 , FUNCT_2:63;
end;
begin
definition
func cl_scalar -> (Function of [: ( the_set_of_l2ComplexSequences ) , ( the_set_of_l2ComplexSequences ) :] , ( COMPLEX )) means 
(for B131 , B132 being set holds ((B131 in ( the_set_of_l2ComplexSequences ) & B132 in ( the_set_of_l2ComplexSequences )) implies ( it . (B131 , B132) ) = ( Sum ( ( seq_id B131 ) (#) ( ( seq_id B132 ) *' ) ) )));
existence
proof
deffunc H4(set , set) = ( Sum ( ( seq_id $1 ) (#) ( ( seq_id $2 ) *' ) ) );
set D54 = ( the_set_of_l2ComplexSequences );
L612: (for B133 , B134 being set holds ((B133 in D54 & B134 in D54) implies H4(B133 , B134) in ( COMPLEX )));
L613: (ex B135 being (Function of [: D54 , D54 :] , ( COMPLEX )) st (for B136 , B137 being set holds ((B136 in D54 & B137 in D54) implies ( B135 . (B136 , B137) ) = H4(B136 , B137)))) from BINOP_1:sch 2(L612);
thus L614: thesis by L613;
end;
uniqueness
proof
set D55 = ( the_set_of_l2ComplexSequences );
let C111 , C112 being (Function of [: D55 , D55 :] , ( COMPLEX ));
assume that
L615: (for B138 , B139 being set holds ((B138 in D55 & B139 in D55) implies ( C111 . (B138 , B139) ) = ( Sum ( ( seq_id B138 ) (#) ( ( seq_id B139 ) *' ) ) )))
and
L616: (for B140 , B141 being set holds ((B140 in D55 & B141 in D55) implies ( C112 . (B140 , B141) ) = ( Sum ( ( seq_id B140 ) (#) ( ( seq_id B141 ) *' ) ) )));
L617: (for B142 , B143 being set holds ((B142 in D55 & B143 in D55) implies ( C111 . (B142 , B143) ) = ( C112 . (B142 , B143) )))
proof
let C113 , C114 being set;
assume that
L618: C113 in D55
and
L619: C114 in D55;
thus L620: ( C111 . (C113 , C114) ) = ( Sum ( ( seq_id C113 ) (#) ( ( seq_id C114 ) *' ) ) ) by L615 , L618 , L619
.= ( C112 . (C113 , C114) ) by L616 , L618 , L619;
end;
thus L621: thesis by L617 , BINOP_1:1;
end;
end;
registration
cluster CUNITSTR (# ( the_set_of_l2ComplexSequences ) , ( Zero_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Add_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Mult_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( cl_scalar ) #) -> non  empty;
coherence by L162;
end;
definition
func Complex_l2_Space -> non  empty CUNITSTR equals 
CUNITSTR (# ( the_set_of_l2ComplexSequences ) , ( Zero_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Add_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( Mult_ (( the_set_of_l2ComplexSequences ) , ( Linear_Space_of_ComplexSequences )) ) , ( cl_scalar ) #);
correctness;
end;
theorem
L625: (for B144 being CLSStruct holds (( the CLSStruct of B144 ) is ComplexLinearSpace implies B144 is ComplexLinearSpace))
proof
let C115 being CLSStruct;
assume that
L626: ( the CLSStruct of C115 ) is ComplexLinearSpace;
reconsider D56 = C115 as non  empty CLSStruct by L626;
reconsider D57 = CLSStruct (# (the carrier of D56) , ( 0. D56 ) , (the addF of D56) , (the Mult of D56) #) as ComplexLinearSpace by L626;
L627: D56 is  Abelian
proof
let C116 , C117 being (VECTOR of D56);
reconsider D58 = C116 as (VECTOR of D57);
reconsider D59 = C117 as (VECTOR of D57);
thus L628: ( C116 + C117 ) = ( D58 + D59 )
.= ( D59 + D58 )
.= ( C117 + C116 );
end;
L629: D56 is  add-associative
proof
let C118 , C119 , C120 being (VECTOR of D56);
reconsider D60 = C118 as (VECTOR of D57);
reconsider D61 = C119 as (VECTOR of D57);
reconsider D62 = C120 as (VECTOR of D57);
thus L630: ( ( C118 + C119 ) + C120 ) = ( ( D60 + D61 ) + D62 )
.= ( D60 + ( D61 + D62 ) ) by RLVECT_1:def 3
.= ( C118 + ( C119 + C120 ) );
end;
L631: D56 is  vector-distributive  scalar-distributive  scalar-associative  scalar-unital
proof
thus L632: (for B145 being Complex holds (for B146 , B147 being (VECTOR of D56) holds ( B145 * ( B146 + B147 ) ) = ( ( B145 * B146 ) + ( B145 * B147 ) )))
proof
let C121 being Complex;
let C122 , C123 being (VECTOR of D56);
reconsider D63 = C122 , D64 = C123 as (VECTOR of D57);
thus L633: ( C121 * ( C122 + C123 ) ) = ( C121 * ( D63 + D64 ) )
.= ( ( C121 * D63 ) + ( C121 * D64 ) ) by CLVECT_1:def 2
.= ( ( C121 * C122 ) + ( C121 * C123 ) );
end;

thus L634: (for B148 , B149 being Complex holds (for B150 being (VECTOR of D56) holds ( ( B148 + B149 ) * B150 ) = ( ( B148 * B150 ) + ( B149 * B150 ) )))
proof
let C124 , C125 being Complex;
let C126 being (VECTOR of D56);
reconsider D65 = C126 as (VECTOR of D57);
thus L635: ( ( C124 + C125 ) * C126 ) = ( ( C124 + C125 ) * D65 )
.= ( ( C124 * D65 ) + ( C125 * D65 ) ) by CLVECT_1:def 3
.= ( ( C124 * C126 ) + ( C125 * C126 ) );
end;

thus L636: (for B151 , B152 being Complex holds (for B153 being (VECTOR of D56) holds ( ( B151 * B152 ) * B153 ) = ( B151 * ( B152 * B153 ) )))
proof
let C127 , C128 being Complex;
let C129 being (VECTOR of D56);
reconsider D66 = C129 as (VECTOR of D57);
thus L637: ( ( C127 * C128 ) * C129 ) = ( ( C127 * C128 ) * D66 )
.= ( C127 * ( C128 * D66 ) ) by CLVECT_1:def 4
.= ( C127 * ( C128 * C129 ) );
end;

let C130 being (VECTOR of D56);
reconsider D67 = C130 as (VECTOR of D57);
thus L638: ( ( 1r ) * C130 ) = ( ( 1r ) * D67 )
.= C130 by CLVECT_1:def 5;
end;
L639: D56 is  right_complementable
proof
let C131 being (VECTOR of D56);
reconsider D68 = C131 as (VECTOR of D57);
consider C132 being (VECTOR of D57) such that L640: ( D68 + C132 ) = ( 0. D57 ) by ALGSTR_0:def 11;
reconsider D69 = C132 as (VECTOR of D56);
take D69;
thus L641: thesis by L640;
end;
L642: D56 is  right_zeroed
proof
let C133 being (VECTOR of D56);
reconsider D70 = C133 as (VECTOR of D57);
thus L643: ( C133 + ( 0. D56 ) ) = ( D70 + ( 0. D57 ) )
.= C133 by RLVECT_1:def 4;
end;
thus L644: thesis by L642 , L627 , L629 , L639 , L631;
end;
theorem
L645: (for B154 being Complex_Sequence holds ((for B155 being (Element of ( NAT )) holds ( B154 . B155 ) = ( 0c )) implies (B154 is  summable & ( Sum B154 ) = ( 0c ))))
proof
let C134 being Complex_Sequence;
assume that
L646: (for B156 being (Element of ( NAT )) holds ( C134 . B156 ) = ( 0c ));
L647: (for B157 being (Element of ( NAT )) holds ( ( Partial_Sums C134 ) . B157 ) = ( 0c ))
proof
defpred S4[ (Element of ( NAT )) ] means ( C134 . $1 ) = ( ( Partial_Sums C134 ) . $1 );
let C135 being (Element of ( NAT ));
L648: (for B158 being (Element of ( NAT )) holds (S4[ B158 ] implies S4[ ( B158 + 1 ) ]))
proof
let C136 being (Element of ( NAT ));
assume that
L649: ( C134 . C136 ) = ( ( Partial_Sums C134 ) . C136 );
thus L650: ( C134 . ( C136 + 1 ) ) = ( ( 0c ) + ( C134 . ( C136 + 1 ) ) )
.= ( ( C134 . C136 ) + ( C134 . ( C136 + 1 ) ) ) by L646
.= ( ( Partial_Sums C134 ) . ( C136 + 1 ) ) by L649 , SERIES_1:def 1;
end;
L651: S4[ ( 0 ) ] by SERIES_1:def 1;
L652: (for B159 being (Element of ( NAT )) holds S4[ B159 ]) from NAT_1:sch 1(L651 , L648);
thus L653: ( ( Partial_Sums C134 ) . C135 ) = ( C134 . C135 ) by L652
.= ( 0c ) by L646;
end;
L654: (for B160 being Real holds (( 0 ) < B160 implies (ex B161 being (Element of ( NAT )) st (for B162 being (Element of ( NAT )) holds (B161 <= B162 implies |. ( ( ( Partial_Sums C134 ) . B162 ) - ( 0c ) ) .| < B160)))))
proof
let C137 being Real;
assume that
L655: ( 0 ) < C137;
take ( 0 );
let C138 being (Element of ( NAT ));
assume that
L656: ( 0 ) <= C138;
thus L657: thesis by L647 , L655 , COMPLEX1:44;
end;
L658: (( Partial_Sums C134 ) qua Complex_Sequence) is  convergent by L654 , COMSEQ_2:def 5;
L659: ( lim ( Partial_Sums C134 ) ) = ( 0c ) by L658 , L654 , COMSEQ_2:def 6;
thus L660: thesis by L659 , L658 , COMSEQ_3:def 7 , COMSEQ_3:def 8;
end;
registration
cluster ( Complex_l2_Space ) ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence by L227 , L625;
end;
