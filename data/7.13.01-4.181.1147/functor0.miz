:: Functors for Alternative Categories
::  by Andrzej Trybulec
::
:: Received April 24, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, FUNCT_1, SUBSET_1, MCART_1, ZFMISC_1, TARSKI, PBOOLE,
      RELAT_1, FUNCT_2, FUNCOP_1, MEMBER_1, STRUCT_0, ALTCAT_1, RELAT_2,
      MSUALG_6, CAT_1, ALTCAT_2, FUNCT_3, MSUALG_3, ENS_1, WELLORD1, FUNCTOR0;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, RELAT_1, MCART_1, FUNCT_1,
      PBOOLE, RELSET_1, PARTFUN1, FUNCT_2, BINOP_1, FUNCOP_1, FUNCT_3, FUNCT_4,
      STRUCT_0, MSUALG_3, ALTCAT_1, ALTCAT_2;
 constructors FUNCT_3, MSUALG_3, ALTCAT_2, RELSET_1, XTUPLE_0;
 registrations SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1, PBOOLE, STRUCT_0,
      ALTCAT_1, ALTCAT_2, PARTFUN1, RELSET_1, FUNCT_3, XTUPLE_0;
 requirements SUBSET, BOOLE;
 definitions TARSKI, MSUALG_3, FUNCT_1, FUNCT_2, XBOOLE_0, PBOOLE, BINOP_1,
      XTUPLE_0;
 theorems ALTCAT_2, FUNCT_4, FUNCOP_1, ZFMISC_1, ALTCAT_1, FUNCT_2, FUNCT_1,
      PBOOLE, FUNCT_3, RELAT_1, MCART_1, DOMAIN_1, MSUALG_3, ISOCAT_1,
      RELSET_1, XBOOLE_0, XBOOLE_1, PARTFUN1, XTUPLE_0;
 schemes ALTCAT_2;

begin
scheme ValOnPair { F1() -> non  empty set , F2() -> Function , F3 , F4() -> (Element of F1()) , F5(set , set) -> set , P1[set , set] } : ( F2() . (F3() , F4()) ) = F5(F3() , F4())
provided
L1: F2() = { [ [ B1 , B2 ] , F5(B1 , B2) ] where B1 is (Element of F1()) , B2 is (Element of F1()) : P1[ B1 , B2 ] }
and
L2: P1[ F3() , F4() ]
proof
defpred S1[ set ] means P1[ ( $1 `1 ) , ( $1 `2 ) ];
deffunc H1(set) = F5(( $1 `1 ) , ( $1 `2 ));
L3: F2() = { [ B3 , H1(B3) ] where B3 is (Element of [: F1() , F1() :]) : S1[ B3 ] }
proof
thus L4: F2() c= { [ B4 , F5(( B4 `1 ) , ( B4 `2 )) ] where B4 is (Element of [: F1() , F1() :]) : P1[ ( B4 `1 ) , ( B4 `2 ) ] }
proof
let C1 being set;
assume L5: C1 in F2();
consider C2 , C3 being (Element of F1()) such that L6: C1 = [ [ C2 , C3 ] , F5(C2 , C3) ] and L7: P1[ C2 , C3 ] by L5 , L1;
reconsider D1 = [ C2 , C3 ] as (Element of [: F1() , F1() :]) by ZFMISC_1:87;
L8: ( D1 `1 ) = C2 by MCART_1:7;
L9: ( D1 `2 ) = C3 by MCART_1:7;
thus L10: thesis by L9 , L6 , L7 , L8;
end;

let C4 being set;
assume L11: C4 in { [ B5 , F5(( B5 `1 ) , ( B5 `2 )) ] where B5 is (Element of [: F1() , F1() :]) : P1[ ( B5 `1 ) , ( B5 `2 ) ] };
consider C5 being (Element of [: F1() , F1() :]) such that L12: C4 = [ C5 , F5(( C5 `1 ) , ( C5 `2 )) ] and L13: P1[ ( C5 `1 ) , ( C5 `2 ) ] by L11;
reconsider D2 = ( C5 `1 ) , D3 = ( C5 `2 ) as (Element of F1()) by MCART_1:10;
L14: C5 = [ D2 , D3 ] by MCART_1:21;
thus L15: thesis by L14 , L1 , L12 , L13;
end;
reconsider D4 = [ F3() , F4() ] as (Element of [: F1() , F1() :]) by ZFMISC_1:87;
L16: ( D4 `1 ) = F3() by MCART_1:7;
L17: S1[ D4 ] by L16 , L2 , MCART_1:7;
thus L18: ( F2() . (F3() , F4()) ) = ( F2() . D4 )
.= H1(D4) from ALTCAT_2:sch 3(L3 , L17)
.= F5(F3() , F4()) by L16 , MCART_1:7;
end;
theorem
L19: (for B6 being set holds ( {} ) is (Function of B6 , ( {} )))
proof
let C6 being set;
per cases ;
suppose L20: C6 = ( {} );

thus L21: thesis by L20 , RELSET_1:12;
end;
suppose L22: C6 <> ( {} );

thus L23: thesis by FUNCT_2:def 1 , RELSET_1:12;
end;
end;
theorem
L25: (for B7 being set holds (for B8 being (ManySortedSet of B7) holds ( B8 * ( id B7 ) ) = B8))
proof
let C7 being set;
let C8 being (ManySortedSet of C7);
L26: C7 = ( dom C8 ) by PARTFUN1:def 2;
thus L27: thesis by L26 , RELAT_1:52;
end;
registration
let C9 being  empty Function;
cluster ( ~ C9 ) ->  empty;
coherence
proof
L28: ( rng C9 ) = ( {} );
L29: ( rng ( ~ C9 ) ) = ( {} ) by L28 , FUNCT_4:41 , XBOOLE_1:3;
thus L30: thesis by L29;
end;
let C10 being Function;
cluster [: C9 , C10 :] ->  empty;
coherence
proof
L31: ( dom C9 ) = ( {} );
L32: ( dom [: C9 , C10 :] ) = [: ( {} ) , ( dom C10 ) :] by L31 , FUNCT_3:def 8;
thus L33: thesis by L32 , ZFMISC_1:90;
end;
cluster [: C10 , C9 :] ->  empty;
coherence
proof
L34: ( dom C9 ) = ( {} );
L35: ( dom [: C10 , C9 :] ) = [: ( dom C10 ) , ( {} ) :] by L34 , FUNCT_3:def 8;
thus L36: thesis by L35 , ZFMISC_1:90;
end;
end;
theorem
L38: (for B9 being set holds (for B10 being Function holds ( B10 .: ( id B9 ) ) = ( ( ~ B10 ) .: ( id B9 ) )))
proof
let C11 being set;
let C12 being Function;
thus L39: ( C12 .: ( id C11 ) ) c= ( ( ~ C12 ) .: ( id C11 ) )
proof
let C13 being set;
assume L40: C13 in ( C12 .: ( id C11 ) );
consider C14 being set such that L41: C14 in ( dom C12 ) and L42: C14 in ( id C11 ) and L43: C13 = ( C12 . C14 ) by L40 , FUNCT_1:def 6;
consider C15 , C16 being set such that L44: C14 = [ C15 , C16 ] by L42 , RELAT_1:def 1;
L45: C15 = C16 by L42 , L44 , RELAT_1:def 10;
L46: C14 in ( dom ( ~ C12 ) ) by L45 , L41 , L44 , FUNCT_4:42;
L47: ( C12 . (C15 , C16) ) = ( ( ~ C12 ) . (C15 , C16) ) by L46 , L44 , L45 , FUNCT_4:43;
thus L48: thesis by L47 , L42 , L43 , L44 , L46 , FUNCT_1:def 6;
end;

let C17 being set;
assume L49: C17 in ( ( ~ C12 ) .: ( id C11 ) );
consider C18 being set such that L50: C18 in ( dom ( ~ C12 ) ) and L51: C18 in ( id C11 ) and L52: C17 = ( ( ~ C12 ) . C18 ) by L49 , FUNCT_1:def 6;
consider C19 , C20 being set such that L53: C18 = [ C19 , C20 ] by L51 , RELAT_1:def 1;
L54: C19 = C20 by L51 , L53 , RELAT_1:def 10;
L55: C18 in ( dom C12 ) by L54 , L50 , L53 , FUNCT_4:42;
L56: ( ( ~ C12 ) . (C19 , C20) ) = ( C12 . (C19 , C20) ) by L55 , L53 , L54 , FUNCT_4:def 2;
thus L57: thesis by L56 , L51 , L52 , L53 , L55 , FUNCT_1:def 6;
end;
theorem
L58: (for B11 , B12 being set holds (for B13 being (Function of B11 , B12) holds (B13 is  onto iff [: B13 , B13 :] is  onto)))
proof
let C21 , C22 being set;
let C23 being (Function of C21 , C22);
L59: ( rng [: C23 , C23 :] ) = [: ( rng C23 ) , ( rng C23 ) :] by FUNCT_3:67;
L60: (( rng C23 ) = C22 iff ( rng [: C23 , C23 :] ) = [: C22 , C22 :]) by L59 , ZFMISC_1:92;
thus L61: thesis by L60 , FUNCT_2:def 3;
end;
registration
let C24 being  Function-yielding Function;
cluster ( ~ C24 ) ->  Function-yielding;
coherence;
end;
theorem
L63: (for B14 , B15 being set holds (for B16 being set holds ( ~ ( [: B14 , B15 :] --> B16 ) ) = ( [: B15 , B14 :] --> B16 )))
proof
let C25 , C26 being set;
let C27 being set;
L64:
now
let C28 being set;
thus L65:now
assume L66: C28 in ( dom ( [: C26 , C25 :] --> C27 ) );
consider C29 , C30 being set such that L67: C29 in C26 and L68: C30 in C25 and L69: C28 = [ C29 , C30 ] by L66 , ZFMISC_1:def 2;
take D5 = C30;
take D6 = C29;
thus L70: C28 = [ D6 , D5 ] by L69;
L71: [ D5 , D6 ] in [: C25 , C26 :] by L67 , L68 , ZFMISC_1:87;
thus L72: [ D5 , D6 ] in ( dom ( [: C25 , C26 :] --> C27 ) ) by L71 , FUNCOP_1:13;
end;
given C31 , C32 being set such that
L73: C28 = [ C32 , C31 ]
and
L74: [ C31 , C32 ] in ( dom ( [: C25 , C26 :] --> C27 ) );

L75: C31 in C25 by L74 , ZFMISC_1:87;
L76: C32 in C26 by L74 , ZFMISC_1:87;
L77: C28 in [: C26 , C25 :] by L76 , L73 , L75 , ZFMISC_1:87;
thus L78: C28 in ( dom ( [: C26 , C25 :] --> C27 ) ) by L77 , FUNCOP_1:13;
end;
L79:
now
let C33 , C34 being set;
assume L80: [ C33 , C34 ] in ( dom ( [: C25 , C26 :] --> C27 ) );
L81: C33 in C25 by L80 , ZFMISC_1:87;
L82: C34 in C26 by L80 , ZFMISC_1:87;
thus L83: ( ( [: C26 , C25 :] --> C27 ) . (C34 , C33) ) = C27 by L82 , L81 , FUNCOP_1:7 , ZFMISC_1:87
.= ( ( [: C25 , C26 :] --> C27 ) . (C33 , C34) ) by L80 , FUNCOP_1:7;
end;
thus L84: thesis by L79 , L64 , FUNCT_4:def 2;
end;
theorem
L85: (for B17 , B18 being Function holds ((B17 is  one-to-one & B18 is  one-to-one) implies ( [: B17 , B18 :] " ) = [: ( B17 " ) , ( B18 " ) :]))
proof
let C35 , C36 being Function;
assume that
L86: C35 is  one-to-one
and
L87: C36 is  one-to-one;
L88: [: C35 , C36 :] is  one-to-one by L86 , L87;
L89: ( dom ( C35 " ) ) = ( rng C35 ) by L86 , FUNCT_1:33;
L90: ( dom ( C36 " ) ) = ( rng C36 ) by L87 , FUNCT_1:33;
L91: ( dom ( [: C35 , C36 :] " ) ) = ( rng [: C35 , C36 :] ) by L88 , FUNCT_1:33
.= [: ( dom ( C35 " ) ) , ( dom ( C36 " ) ) :] by L89 , L90 , FUNCT_3:67;
L92: (for B19 , B20 being set holds ((B19 in ( dom ( C35 " ) ) & B20 in ( dom ( C36 " ) )) implies ( ( [: C35 , C36 :] " ) . (B19 , B20) ) = [ ( ( C35 " ) . B19 ) , ( ( C36 " ) . B20 ) ]))
proof
let C37 , C38 being set;
assume that
L93: C37 in ( dom ( C35 " ) )
and
L94: C38 in ( dom ( C36 " ) );
L95: ( dom [: C35 , C36 :] ) = [: ( dom C35 ) , ( dom C36 ) :] by FUNCT_3:def 8;
L96: ( ( C35 " ) . C37 ) in ( rng ( C35 " ) ) by L93 , FUNCT_1:def 3;
L97: ( ( C36 " ) . C38 ) in ( rng ( C36 " ) ) by L94 , FUNCT_1:def 3;
L98: ( ( C35 " ) . C37 ) in ( dom C35 ) by L86 , L96 , FUNCT_1:33;
L99: ( ( C36 " ) . C38 ) in ( dom C36 ) by L87 , L97 , FUNCT_1:33;
L100: [ ( ( C35 " ) . C37 ) , ( ( C36 " ) . C38 ) ] in ( dom [: C35 , C36 :] ) by L99 , L95 , L98 , ZFMISC_1:87;
L101: ( C35 . ( ( C35 " ) . C37 ) ) = ( ( C35 * ( C35 " ) ) . C37 ) by L93 , FUNCT_1:13
.= ( ( ( ( C35 " ) " ) * ( C35 " ) ) . C37 ) by L86 , FUNCT_1:43
.= ( ( id ( dom ( C35 " ) ) ) . C37 ) by L86 , FUNCT_1:39
.= C37 by L93 , FUNCT_1:18;
L102: ( C36 . ( ( C36 " ) . C38 ) ) = ( ( C36 * ( C36 " ) ) . C38 ) by L94 , FUNCT_1:13
.= ( ( ( ( C36 " ) " ) * ( C36 " ) ) . C38 ) by L87 , FUNCT_1:43
.= ( ( id ( dom ( C36 " ) ) ) . C38 ) by L87 , FUNCT_1:39
.= C38 by L94 , FUNCT_1:18;
L103: ( [: C35 , C36 :] . (( ( C35 " ) . C37 ) , ( ( C36 " ) . C38 )) ) = [ C37 , C38 ] by L102 , L95 , L100 , L101 , FUNCT_3:65;
thus L104: thesis by L103 , L86 , L87 , L100 , FUNCT_1:32;
end;
thus L105: thesis by L92 , L91 , FUNCT_3:def 8;
end;
theorem
L106: (for B21 being Function holds ([: B21 , B21 :] is  one-to-one implies B21 is  one-to-one))
proof
let C39 being Function;
assume that
L107: [: C39 , C39 :] is  one-to-one;
let C40 , C41 being set;
assume that
L108: C40 in ( dom C39 )
and
L109: C41 in ( dom C39 )
and
L110: ( C39 . C40 ) = ( C39 . C41 );
L111: ( dom [: C39 , C39 :] ) = [: ( dom C39 ) , ( dom C39 ) :] by FUNCT_3:def 8;
L112: [ C40 , C40 ] in ( dom [: C39 , C39 :] ) by L111 , L108 , ZFMISC_1:87;
L113: [ C41 , C41 ] in ( dom [: C39 , C39 :] ) by L109 , L111 , ZFMISC_1:87;
L114: ( [: C39 , C39 :] . (C40 , C40) ) = [ ( C39 . C41 ) , ( C39 . C41 ) ] by L110 , L111 , L112 , FUNCT_3:65
.= ( [: C39 , C39 :] . (C41 , C41) ) by L111 , L113 , FUNCT_3:65;
L115: [ C40 , C40 ] = [ C41 , C41 ] by L114 , L107 , L112 , L113 , FUNCT_1:def 4;
thus L116: thesis by L115 , XTUPLE_0:1;
end;
theorem
L117: (for B22 being Function holds (B22 is  one-to-one implies ( ~ B22 ) is  one-to-one))
proof
let C42 being Function;
assume that
L118: C42 is  one-to-one;
let C43 , C44 being set;
consider C45 , C46 being set such that L119: ( dom ( ~ C42 ) ) c= [: C45 , C46 :] by FUNCT_4:44;
assume L120: C43 in ( dom ( ~ C42 ) );
consider C47 , C48 being set such that L121: C47 in C45 and L122: C48 in C46 and L123: C43 = [ C47 , C48 ] by L120 , L119 , ZFMISC_1:84;
assume L124: C44 in ( dom ( ~ C42 ) );
consider C49 , C50 being set such that L125: C49 in C45 and L126: C50 in C46 and L127: C44 = [ C49 , C50 ] by L124 , L119 , ZFMISC_1:84;
assume L128: ( ( ~ C42 ) . C43 ) = ( ( ~ C42 ) . C44 );
L129: [ C48 , C47 ] in ( dom C42 ) by L120 , L123 , FUNCT_4:42;
L130: [ C50 , C49 ] in ( dom C42 ) by L124 , L127 , FUNCT_4:42;
L131: ( C42 . (C48 , C47) ) = ( ( ~ C42 ) . (C47 , C48) ) by L120 , L123 , FUNCT_4:43
.= ( ( ~ C42 ) . (C49 , C50) ) by L123 , L127 , L128
.= ( C42 . (C50 , C49) ) by L124 , L127 , FUNCT_4:43;
L132: [ C48 , C47 ] = [ C50 , C49 ] by L131 , L118 , L129 , L130 , FUNCT_1:def 4;
L133: C48 = C50 by L132 , XTUPLE_0:1;
thus L134: thesis by L133 , L123 , L127 , L132 , XTUPLE_0:1;
end;
theorem
L135: (for B23 , B24 being Function holds (( ~ [: B23 , B24 :] ) is  one-to-one implies [: B24 , B23 :] is  one-to-one))
proof
let C51 , C52 being Function;
assume that
L136: ( ~ [: C51 , C52 :] ) is  one-to-one;
let C53 , C54 being set;
L137: ( dom [: C52 , C51 :] ) = [: ( dom C52 ) , ( dom C51 ) :] by FUNCT_3:def 8;
L138: ( dom [: C51 , C52 :] ) = [: ( dom C51 ) , ( dom C52 ) :] by FUNCT_3:def 8;
assume L139: C53 in ( dom [: C52 , C51 :] );
consider C55 , C56 being set such that L140: C55 in ( dom C52 ) and L141: C56 in ( dom C51 ) and L142: C53 = [ C55 , C56 ] by L139 , L137 , ZFMISC_1:84;
assume L143: C54 in ( dom [: C52 , C51 :] );
consider C57 , C58 being set such that L144: C57 in ( dom C52 ) and L145: C58 in ( dom C51 ) and L146: C54 = [ C57 , C58 ] by L143 , L137 , ZFMISC_1:84;
L147: C53 in ( dom [: C52 , C51 :] ) by L137 , L140 , L141 , L142 , ZFMISC_1:87;
L148: C53 in ( dom ( ~ [: C51 , C52 :] ) ) by L147 , L137 , L138 , FUNCT_4:46;
L149: C54 in ( dom [: C52 , C51 :] ) by L137 , L144 , L145 , L146 , ZFMISC_1:87;
L150: C54 in ( dom ( ~ [: C51 , C52 :] ) ) by L149 , L137 , L138 , FUNCT_4:46;
assume L151: ( [: C52 , C51 :] . C53 ) = ( [: C52 , C51 :] . C54 );
L152: ( [: C52 , C51 :] . (C55 , C56) ) = [ ( C52 . C55 ) , ( C51 . C56 ) ] by L140 , L141 , FUNCT_3:def 8;
L153: ( [: C52 , C51 :] . (C57 , C58) ) = [ ( C52 . C57 ) , ( C51 . C58 ) ] by L144 , L145 , FUNCT_3:def 8;
L154: ( C51 . C58 ) = ( C51 . C56 ) by L153 , L142 , L146 , L151 , L152 , XTUPLE_0:1;
L155: ( C52 . C55 ) = ( C52 . C57 ) by L142 , L146 , L151 , L152 , L153 , XTUPLE_0:1;
L156: ( ( ~ [: C51 , C52 :] ) . [ C55 , C56 ] ) = ( ( ~ [: C51 , C52 :] ) . (C55 , C56) )
.= ( [: C51 , C52 :] . (C56 , C55) ) by L142 , L148 , FUNCT_4:43
.= [ ( C51 . C58 ) , ( C52 . C57 ) ] by L140 , L141 , L154 , L155 , FUNCT_3:def 8
.= ( [: C51 , C52 :] . (C58 , C57) ) by L144 , L145 , FUNCT_3:def 8
.= ( ( ~ [: C51 , C52 :] ) . (C57 , C58) ) by L146 , L150 , FUNCT_4:43
.= ( ( ~ [: C51 , C52 :] ) . [ C57 , C58 ] );
thus L157: thesis by L156 , L136 , L142 , L146 , L148 , L150 , FUNCT_1:def 4;
end;
theorem
L158: (for B25 , B26 being Function holds ((B25 is  one-to-one & B26 is  one-to-one) implies ( ( ~ [: B25 , B26 :] ) " ) = ( ~ ( [: B26 , B25 :] " ) )))
proof
let C59 , C60 being Function;
assume that
L159: C59 is  one-to-one
and
L160: C60 is  one-to-one;
L161: ( [: C60 , C59 :] " ) = [: ( C60 " ) , ( C59 " ) :] by L159 , L160 , L85;
L162: ( dom ( [: C60 , C59 :] " ) ) = [: ( dom ( C60 " ) ) , ( dom ( C59 " ) ) :] by L161 , FUNCT_3:def 8;
L163: ( dom [: C59 , C60 :] ) = [: ( dom C59 ) , ( dom C60 ) :] by FUNCT_3:def 8;
L164: ( dom [: C60 , C59 :] ) = [: ( dom C60 ) , ( dom C59 ) :] by FUNCT_3:def 8;
L165: [: C60 , C59 :] is  one-to-one by L159 , L160;
L166: ( ~ [: C59 , C60 :] ) is  one-to-one by L117 , L159 , L160;
L167: ( [: C59 , C60 :] " ) = [: ( C59 " ) , ( C60 " ) :] by L159 , L160 , L85;
L168: ( dom ( ~ ( [: C60 , C59 :] " ) ) ) = [: ( dom ( C59 " ) ) , ( dom ( C60 " ) ) :] by L162 , FUNCT_4:46
.= ( dom [: ( C59 " ) , ( C60 " ) :] ) by FUNCT_3:def 8
.= ( rng [: C59 , C60 :] ) by L159 , L160 , L167 , FUNCT_1:32
.= ( rng ( ~ [: C59 , C60 :] ) ) by L163 , FUNCT_4:47;
L169:
now
let C61 , C62 being set;
thus L170:now
assume that
L171: C61 in ( rng ( ~ [: C59 , C60 :] ) )
and
L172: C62 = ( ( ~ ( [: C60 , C59 :] " ) ) . C61 );
L173: C61 in ( rng [: C59 , C60 :] ) by L163 , L171 , FUNCT_4:47;
L174: C61 in [: ( rng C59 ) , ( rng C60 ) :] by L173 , FUNCT_3:67;
consider C63 , C64 being set such that L175: C63 in ( rng C59 ) and L176: C64 in ( rng C60 ) and L177: C61 = [ C63 , C64 ] by L174 , ZFMISC_1:84;
set D7 = ( ( C59 " ) . C63 );
set D8 = ( ( C60 " ) . C64 );
L178: C64 in ( dom ( C60 " ) ) by L160 , L176 , FUNCT_1:32;
L179: C63 in ( dom ( C59 " ) ) by L159 , L175 , FUNCT_1:32;
L180: [ C64 , C63 ] in ( dom ( [: C60 , C59 :] " ) ) by L179 , L162 , L178 , ZFMISC_1:87;
L181: ( ( ~ ( [: C60 , C59 :] " ) ) . (C63 , C64) ) = ( [: ( C60 " ) , ( C59 " ) :] . (C64 , C63) ) by L180 , L161 , FUNCT_4:def 2
.= [ D8 , D7 ] by L178 , L179 , FUNCT_3:def 8;
L182: C63 in ( dom ( C59 " ) ) by L159 , L175 , FUNCT_1:32;
L183: C64 in ( dom ( C60 " ) ) by L160 , L176 , FUNCT_1:32;
L184: D7 in ( rng ( C59 " ) ) by L182 , FUNCT_1:def 3;
L185: D8 in ( rng ( C60 " ) ) by L183 , FUNCT_1:def 3;
L186: D7 in ( dom C59 ) by L159 , L184 , FUNCT_1:33;
L187: D8 in ( dom C60 ) by L160 , L185 , FUNCT_1:33;
L188: [ D8 , D7 ] in ( dom [: C60 , C59 :] ) by L187 , L164 , L186 , ZFMISC_1:87;
L189: [ D8 , D7 ] in ( dom ( ~ [: C59 , C60 :] ) ) by L188 , L163 , L164 , FUNCT_4:46;
thus L190: C62 in ( dom ( ~ [: C59 , C60 :] ) ) by L163 , L164 , L172 , L177 , L181 , L188 , FUNCT_4:46;
L191: ( C59 . D7 ) = C63 by L159 , L175 , FUNCT_1:32;
L192: ( C60 . D8 ) = C64 by L160 , L176 , FUNCT_1:32;
thus L193: ( ( ~ [: C59 , C60 :] ) . C62 ) = ( ( ~ [: C59 , C60 :] ) . (D8 , D7) ) by L172 , L177 , L181
.= ( [: C59 , C60 :] . (D7 , D8) ) by L189 , FUNCT_4:43
.= C61 by L177 , L186 , L187 , L191 , L192 , FUNCT_3:def 8;
end;
assume that
L194: C62 in ( dom ( ~ [: C59 , C60 :] ) )
and
L195: ( ( ~ [: C59 , C60 :] ) . C62 ) = C61;
thus L196: C61 in ( rng ( ~ [: C59 , C60 :] ) ) by L194 , L195 , FUNCT_1:def 3;
L197: C62 in ( dom [: C60 , C59 :] ) by L163 , L164 , L194 , FUNCT_4:46;
consider C65 , C66 being set such that L198: C65 in ( dom C60 ) and L199: C66 in ( dom C59 ) and L200: C62 = [ C65 , C66 ] by L197 , L164 , ZFMISC_1:84;
L201: ( ( ~ [: C59 , C60 :] ) . (C65 , C66) ) = ( [: C59 , C60 :] . (C66 , C65) ) by L194 , L200 , FUNCT_4:43
.= [ ( C59 . C66 ) , ( C60 . C65 ) ] by L198 , L199 , FUNCT_3:def 8;
L202: ( C60 . C65 ) in ( rng C60 ) by L198 , FUNCT_1:def 3;
L203: ( C59 . C66 ) in ( rng C59 ) by L199 , FUNCT_1:def 3;
L204: [ ( C60 . C65 ) , ( C59 . C66 ) ] in [: ( rng C60 ) , ( rng C59 ) :] by L203 , L202 , ZFMISC_1:87;
L205: [ ( C60 . C65 ) , ( C59 . C66 ) ] in ( rng [: C60 , C59 :] ) by L204 , FUNCT_3:67;
L206: [ ( C60 . C65 ) , ( C59 . C66 ) ] in ( dom ( [: C60 , C59 :] " ) ) by L205 , L165 , FUNCT_1:33;
L207: [ C65 , C66 ] in ( dom [: C60 , C59 :] ) by L164 , L198 , L199 , ZFMISC_1:87;
thus L208: C62 = ( ( [: C60 , C59 :] " ) . ( [: C60 , C59 :] . (C65 , C66) ) ) by L207 , L159 , L160 , L200 , FUNCT_1:34
.= ( ( [: C60 , C59 :] " ) . (( C60 . C65 ) , ( C59 . C66 )) ) by L198 , L199 , FUNCT_3:def 8
.= ( ( ~ ( [: C60 , C59 :] " ) ) . (( C59 . C66 ) , ( C60 . C65 )) ) by L206 , FUNCT_4:def 2
.= ( ( ~ ( [: C60 , C59 :] " ) ) . C61 ) by L195 , L200 , L201;
end;
thus L209: thesis by L169 , L166 , L168 , FUNCT_1:32;
end;
theorem
L210: (for B27 , B28 being set holds (for B29 being (Function of B27 , B28) holds (B29 is  onto implies ( id B28 ) c= ( [: B29 , B29 :] .: ( id B27 ) ))))
proof
let C67 , C68 being set;
let C69 being (Function of C67 , C68);
assume L211: C69 is  onto;
L212: ( rng C69 ) = C68 by L211 , FUNCT_2:def 3;
let C70 being set;
assume L213: C70 in ( id C68 );
consider C71 , C72 being set such that L214: C70 = [ C71 , C72 ] by L213 , RELAT_1:def 1;
L215: C71 = C72 by L213 , L214 , RELAT_1:def 10;
L216: C71 in C68 by L213 , L214 , RELAT_1:def 10;
consider C73 being set such that L217: C73 in C67 and L218: ( C69 . C73 ) = C71 by L216 , L212 , FUNCT_2:11;
L219: ( dom C69 ) = C67 by L216 , FUNCT_2:def 1;
L220: [ C73 , C73 ] in ( id C67 ) by L217 , RELAT_1:def 10;
L221: ( [: C69 , C69 :] . (C73 , C73) ) = C70 by L214 , L215 , L217 , L218 , L219 , FUNCT_3:def 8;
thus L222: thesis by L221 , L213 , L220 , FUNCT_2:35;
end;
theorem
L223: (for B30 , B31 being  Function-yielding Function holds (for B32 being Function holds ( ( B31 ** B30 ) * B32 ) = ( ( B31 * B32 ) ** ( B30 * B32 ) )))
proof
let C74 , C75 being  Function-yielding Function;
let C76 being Function;
L224: ( dom ( ( C75 ** C74 ) * C76 ) ) = ( C76 " ( dom ( C75 ** C74 ) ) ) by RELAT_1:147
.= ( C76 " ( ( dom C75 ) /\ ( dom C74 ) ) ) by PBOOLE:def 19
.= ( ( C76 " ( dom C74 ) ) /\ ( C76 " ( dom C75 ) ) ) by FUNCT_1:68
.= ( ( C76 " ( dom C74 ) ) /\ ( dom ( C75 * C76 ) ) ) by RELAT_1:147
.= ( ( dom ( C74 * C76 ) ) /\ ( dom ( C75 * C76 ) ) ) by RELAT_1:147;
L225:
now
let C77 being set;
assume L226: C77 in ( dom ( ( C75 ** C74 ) * C76 ) );
L227: C77 in ( dom C76 ) by L226 , FUNCT_1:11;
L228: ( C76 . C77 ) in ( dom ( C75 ** C74 ) ) by L226 , FUNCT_1:11;
thus L229: ( ( ( C75 ** C74 ) * C76 ) . C77 ) = ( ( C75 ** C74 ) . ( C76 . C77 ) ) by L226 , FUNCT_1:12
.= ( ( C75 . ( C76 . C77 ) ) * ( C74 . ( C76 . C77 ) ) ) by L228 , PBOOLE:def 19
.= ( ( ( C75 * C76 ) . C77 ) * ( C74 . ( C76 . C77 ) ) ) by L227 , FUNCT_1:13
.= ( ( ( C75 * C76 ) . C77 ) * ( ( C74 * C76 ) . C77 ) ) by L227 , FUNCT_1:13;
end;
thus L230: thesis by L225 , L224 , PBOOLE:def 19;
end;
definition
let C78 , C79 , C80 being set;
let C81 being (Function of [: C78 , C79 :] , C80);
redefine func ~ C81 -> (Function of [: C79 , C78 :] , C80);

coherence
proof
per cases ;
suppose L231: C80 = ( {} );

reconsider D9 = C81 as  empty set by L231;
L232: ( ~ D9 ) = ( {} );
thus L233: thesis by L232 , L231 , L19;
end;
suppose L234: C80 <> ( {} );

thus L235: thesis by L234 , FUNCT_4:49;
end;
end;
end;
theorem
L238: (for B33 , B34 , B35 being set holds (for B36 being (Function of [: B33 , B34 :] , B35) holds (( ~ B36 ) is  onto implies B36 is  onto)))
proof
let C82 , C83 , C84 being set;
let C85 being (Function of [: C82 , C83 :] , C84);
L239: ( rng ( ~ C85 ) ) c= ( rng C85 ) by FUNCT_4:41;
assume L240: ( ~ C85 ) is  onto;
L241: ( rng ( ~ C85 ) ) = C84 by L240 , FUNCT_2:def 3;
thus L242: ( rng C85 ) = C84 by L241 , L239 , XBOOLE_0:def 10;
end;
theorem
L243: (for B37 being set holds (for B38 being non  empty set holds (for B39 being (Function of B37 , B38) holds ( [: B39 , B39 :] .: ( id B37 ) ) c= ( id B38 ))))
proof
let C86 being set;
let C87 being non  empty set;
let C88 being (Function of C86 , C87);
let C89 being set;
assume L244: C89 in ( [: C88 , C88 :] .: ( id C86 ) );
consider C90 being set such that L245: C90 in [: C86 , C86 :] and L246: C90 in ( id C86 ) and L247: ( [: C88 , C88 :] . C90 ) = C89 by L244 , FUNCT_2:64;
consider C91 , C92 being set such that L248: C91 in C86 and L249: C92 in C86 and L250: C90 = [ C91 , C92 ] by L245 , ZFMISC_1:84;
L251: C91 = C92 by L246 , L250 , RELAT_1:def 10;
reconsider D10 = C91 as (Element of C86) by L248;
L252: ( C88 . D10 ) in C87 by L248 , FUNCT_2:5;
L253: D10 in ( dom C88 ) by L248 , FUNCT_2:def 1;
L254: C89 = ( [: C88 , C88 :] . (D10 , C92) ) by L247 , L250
.= [ ( C88 . D10 ) , ( C88 . D10 ) ] by L251 , L253 , FUNCT_3:def 8;
thus L255: thesis by L254 , L252 , RELAT_1:def 10;
end;
begin
definition
let C93 , C94 being set;
mode bifunction of C93 , C94
 is (Function of [: C93 , C93 :] , [: C94 , C94 :]);
end;
definition
let C95 , C96 being set;
let C97 being (bifunction of C95 , C96);
attr C97 is  Covariant
means
:L257: (ex B40 being (Function of C95 , C96) st C97 = [: B40 , B40 :]);
attr C97 is  Contravariant
means
:L258: (ex B41 being (Function of C95 , C96) st C97 = ( ~ [: B41 , B41 :] ));
end;
theorem
L260: (for B42 being set holds (for B43 being non  empty set holds (for B44 being (Element of B43) holds (for B45 being (bifunction of B42 , B43) holds (B45 = ( [: B42 , B42 :] --> [ B44 , B44 ] ) implies B45 is  Covariant  Contravariant)))))
proof
let C98 being set;
let C99 being non  empty set;
let C100 being (Element of C99);
let C101 being (bifunction of C98 , C99);
assume that
L261: C101 = ( [: C98 , C98 :] --> [ C100 , C100 ] );
reconsider D11 = ( C98 --> C100 ) as (Function of C98 , C99);
thus L262: C101 is  Covariant
proof
take D11;
thus L263: thesis by L261 , ALTCAT_2:1;
end;

take D11;
L264: ( [: C98 , C98 :] --> [ C100 , C100 ] ) = ( ~ ( [: C98 , C98 :] --> [ C100 , C100 ] ) ) by L63;
thus L265: thesis by L264 , L261 , ALTCAT_2:1;
end;
registration
let C102 , C103 being set;
cluster  Covariant  Contravariant for (bifunction of C102 , C103);
existence
proof
per cases ;
suppose L266: C103 = ( {} );

L267: [: C103 , C103 :] = ( {} ) by L266 , ZFMISC_1:90;
reconsider D12 = ( {} ) as (bifunction of C102 , C103) by L267 , L19;
take D12;
reconsider D13 = ( {} ) as (Function of C102 , C103) by L266 , L19;
reconsider D14 = D13 as  empty Function;
thus L268: D12 is  Covariant
proof
take D13;
thus L269: D12 = [: D14 , D14 :]
.= [: D13 , D13 :];
end;

take D13;
thus L270: D12 = ( ~ [: D14 , D14 :] )
.= ( ~ [: D13 , D13 :] );
end;
suppose L271: C103 <> ( {} );

set D15 = the (Element of C103);
set D16 = ( [: C102 , C102 :] --> [ D15 , D15 ] );
L272: [ D15 , D15 ] in [: C103 , C103 :] by L271 , ZFMISC_1:87;
reconsider D17 = D16 as (bifunction of C102 , C103) by L272 , FUNCOP_1:45;
take D17;
thus L273: thesis by L271 , L260;
end;
end;
end;
theorem
L276: (for B46 , B47 being non  empty set holds (for B48 being  Covariant  Contravariant (bifunction of B46 , B47) holds (ex B49 being (Element of B47) st B48 = ( [: B46 , B46 :] --> [ B49 , B49 ] ))))
proof
let C104 , C105 being non  empty set;
let C106 being  Covariant  Contravariant (bifunction of C104 , C105);
consider C107 being (Function of C104 , C105) such that L277: C106 = [: C107 , C107 :] by L257;
consider C108 being (Function of C104 , C105) such that L278: C106 = ( ~ [: C108 , C108 :] ) by L258;
set D18 = the (Element of C104);
take D19 = ( C107 . D18 );
L279: ( dom C106 ) = [: C104 , C104 :] by FUNCT_2:def 1;
L280:
now
let C109 being set;
assume L281: C109 in ( dom C106 );
consider C110 , C111 being (Element of C104) such that L282: C109 = [ C110 , C111 ] by L281 , DOMAIN_1:1;
L283: ( dom C108 ) = C104 by FUNCT_2:def 1;
L284: ( dom C107 ) = C104 by FUNCT_2:def 1;
L285: ( dom [: C108 , C108 :] ) = [: ( dom C108 ) , ( dom C108 ) :] by FUNCT_3:def 8;
L286: [ C110 , D18 ] in ( dom [: C108 , C108 :] ) by L285 , L283 , ZFMISC_1:87;
L287: ( dom C108 ) = C104 by FUNCT_2:def 1;
L288: [ D19 , ( C107 . C110 ) ] = ( C106 . (D18 , C110) ) by L277 , L284 , FUNCT_3:def 8
.= ( [: C108 , C108 :] . (C110 , D18) ) by L278 , L286 , FUNCT_4:def 2
.= [ ( C108 . C110 ) , ( C108 . D18 ) ] by L287 , FUNCT_3:def 8;
L289: ( C108 . C110 ) = D19 by L288 , XTUPLE_0:1;
L290: [ C111 , D18 ] in ( dom [: C108 , C108 :] ) by L283 , L285 , ZFMISC_1:87;
L291: [ D19 , ( C107 . C111 ) ] = ( C106 . (D18 , C111) ) by L277 , L284 , FUNCT_3:def 8
.= ( [: C108 , C108 :] . (C111 , D18) ) by L278 , L290 , FUNCT_4:def 2
.= [ ( C108 . C111 ) , ( C108 . D18 ) ] by L287 , FUNCT_3:def 8;
L292: ( C108 . C111 ) = D19 by L291 , XTUPLE_0:1;
L293: [ C111 , C110 ] in ( dom [: C108 , C108 :] ) by L283 , L285 , ZFMISC_1:87;
thus L294: ( C106 . C109 ) = ( [: C107 , C107 :] . (C110 , C111) ) by L277 , L282
.= ( [: C108 , C108 :] . (C111 , C110) ) by L277 , L278 , L293 , FUNCT_4:def 2
.= [ D19 , D19 ] by L287 , L289 , L292 , FUNCT_3:def 8;
end;
thus L295: thesis by L280 , L279 , FUNCOP_1:11;
end;
begin
definition
let C112 , C113 being set;
let C114 being (Function of C112 , C113);
let C115 being (ManySortedSet of C112);
let C116 being (ManySortedSet of C113);
mode MSUnTrans of C114 , C115 , C116
 -> (ManySortedSet of C112)
means :L296: (ex B50 being non  empty set st (ex B51 being (ManySortedSet of B50) st (ex B52 being (Function of C112 , B50) st (C114 = B52 & C116 = B51 & it is (ManySortedFunction of C115 , ( B51 * B52 )))))) if C113 <> ( {} ) otherwise it = ( [[0]] C112 );
existence
proof
thus L297:now
assume L298: C113 <> ( {} );
reconsider D20 = C113 as non  empty set by L298;
reconsider D21 = C114 as (Function of C112 , D20);
reconsider D22 = C116 as (ManySortedSet of D20);
set D23 = the (ManySortedFunction of C115 , ( D22 * D21 ));
reconsider D24 = D23 as (ManySortedSet of C112);
take D25 = D24;
take D26 = D20;
reconsider D27 = C114 as (Function of C112 , D26);
reconsider D28 = C116 as (ManySortedSet of D26);
take D29 = D28;
take D30 = D27;
thus L299: (C114 = D30 & C116 = D29);
thus L300: D25 is (ManySortedFunction of C115 , ( D29 * D30 ));
end;
thus L301: thesis;
end;
consistency;
end;
definition
let C117 being set;
let C118 being non  empty set;
let C119 being (Function of C117 , C118);
let C120 being (ManySortedSet of C117);
let C121 being (ManySortedSet of C118);
redefine mode MSUnTrans of C119 , C120 , C121
means :L303: it is (ManySortedFunction of C120 , ( C121 * C119 ));
compatibility
proof
let C122 being (ManySortedSet of C117);
thus L304:now
assume L305: C122 is (MSUnTrans of C119 , C120 , C121);
L306: (ex B53 being non  empty set st (ex B54 being (ManySortedSet of B53) st (ex B55 being (Function of C117 , B53) st (C119 = B55 & C121 = B54 & C122 is (ManySortedFunction of C120 , ( B54 * B55 )))))) by L305 , L296;
thus L307: C122 is (ManySortedFunction of C120 , ( C121 * C119 )) by L306;
end;
thus L308: thesis by L296;
end;
end;
registration
let C123 , C124 being set;
let C125 being (Function of C123 , C124);
let C126 being (ManySortedSet of C123);
let C127 being (ManySortedSet of C124);
cluster  ->  Function-yielding for (MSUnTrans of C125 , C126 , C127);
coherence
proof
let C128 being (MSUnTrans of C125 , C126 , C127);
per cases ;
suppose L310: C124 <> ( {} );

L311: (ex B56 being non  empty set st (ex B57 being (ManySortedSet of B56) st (ex B58 being (Function of C123 , B56) st (C125 = B58 & C127 = B57 & C128 is (ManySortedFunction of C126 , ( B57 * B58 )))))) by L310 , L296;
thus L312: thesis by L311;
end;
suppose L313: C124 = ( {} );

L314: C128 = ( [[0]] C123 ) by L313 , L296;
thus L315: thesis by L314;
end;
end;
end;
theorem
L318: (for B59 being set holds (for B60 , B61 being non  empty set holds (for B62 being (Function of B59 , B60) holds (for B63 being (Function of B60 , B61) holds (for B64 being (ManySortedSet of B60) holds (for B65 being (ManySortedSet of B61) holds (for B66 being (MSUnTrans of B63 , B64 , B65) holds ( B66 * B62 ) is (MSUnTrans of ( B63 * B62 ) , ( B64 * B62 ) , B65))))))))
proof
let C129 being set;
let C130 , C131 being non  empty set;
let C132 being (Function of C129 , C130);
let C133 being (Function of C130 , C131);
let C134 being (ManySortedSet of C130);
let C135 being (ManySortedSet of C131);
let C136 being (MSUnTrans of C133 , C134 , C135);
L319: ( C135 * ( C133 * C132 ) ) = ( ( C135 * C133 ) * C132 ) by RELAT_1:36;
L320: C136 is (ManySortedFunction of C134 , ( C135 * C133 )) by L303;
thus L321: ( C136 * C132 ) is (ManySortedFunction of ( C134 * C132 ) , ( C135 * ( C133 * C132 ) )) by L320 , L319 , ALTCAT_2:5;
end;
definition
let C137 being set;
let C138 being non  empty set;
let C139 being (Function of C137 , C138);
let C140 being (ManySortedSet of [: C137 , C137 :]);
let C141 being (ManySortedSet of [: C138 , C138 :]);
let C142 being (MSUnTrans of [: C139 , C139 :] , C140 , C141);
redefine func ~ C142 -> (MSUnTrans of [: C139 , C139 :] , ( ~ C140 ) , ( ~ C141 ));

coherence
proof
reconsider D31 = C142 as (ManySortedFunction of C140 , ( C141 * [: C139 , C139 :] )) by L303;
L322: ( ~ D31 ) is (ManySortedFunction of ( ~ C140 ) , ( ( ~ C141 ) * [: C139 , C139 :] )) by ALTCAT_2:3;
thus L323: ( ~ C142 ) is (MSUnTrans of [: C139 , C139 :] , ( ~ C140 ) , ( ~ C141 )) by L322 , L303;
end;
end;
theorem
L325: (for B67 , B68 being non  empty set holds (for B69 being (ManySortedSet of B67) holds (for B70 being (ManySortedSet of B68) holds (for B71 being (Element of B68) holds (( B70 . B71 ) <> ( {} ) implies (for B72 being (Element of ( B70 . B71 )) holds (for B73 being (Function of B67 , B68) holds (B73 = ( B67 --> B71 ) implies { [ B74 , ( ( B69 . B74 ) --> B72 ) ] where B74 is (Element of B67) : (not contradiction) } is (MSUnTrans of B73 , B69 , B70)))))))))
proof
let C143 , C144 being non  empty set;
let C145 being (ManySortedSet of C143);
let C146 being (ManySortedSet of C144);
let C147 being (Element of C144);
assume that
L326: ( C146 . C147 ) <> ( {} );
let C148 being (Element of ( C146 . C147 ));
let C149 being (Function of C143 , C144);
assume that
L327: C149 = ( C143 --> C147 );
defpred S2[ set ] means (not contradiction);
deffunc H2(set) = ( ( C145 . $1 ) --> C148 );
reconsider D32 = { [ B75 , H2(B75) ] where B75 is (Element of C143) : S2[ B75 ] } as Function from ALTCAT_2:sch 1;
L328: D32 = { [ B76 , H2(B76) ] where B76 is (Element of C143) : S2[ B76 ] };
L329: ( dom D32 ) = { B77 where B77 is (Element of C143) : S2[ B77 ] } from ALTCAT_2:sch 2(L328)
.= C143 by DOMAIN_1:18;
reconsider D33 = D32 as (ManySortedSet of C143) by L329 , PARTFUN1:def 2 , RELAT_1:def 18;
deffunc H3(set) = ( ( C145 . $1 ) --> C148 );
L330: D33 = { [ B78 , H3(B78) ] where B78 is (Element of C143) : S2[ B78 ] };
L331:
now
let C150 being set;
assume L332: C150 in C143;
reconsider D34 = C150 as (Element of C143) by L332;
L333: S2[ D34 ];
L334: C150 in ( dom C149 ) by L327 , L332 , FUNCOP_1:13;
L335: ( C149 . C150 ) = C147 by L327 , L332 , FUNCOP_1:7;
L336: C148 in ( C146 . ( C149 . C150 ) ) by L335 , L326;
L337: C148 in ( ( C146 * C149 ) . C150 ) by L336 , L334 , FUNCT_1:13;
L338: ( D33 . D34 ) = H3(D34) from ALTCAT_2:sch 3(L330 , L333);
thus L339: ( D33 . C150 ) is (Function of ( C145 . C150 ) , ( ( C146 * C149 ) . C150 )) by L338 , L337 , FUNCOP_1:45;
end;
L340: D33 is (ManySortedFunction of C145 , ( C146 * C149 )) by L331 , PBOOLE:def 15;
thus L341: thesis by L340 , L303;
end;
theorem
L342: (for B79 being set holds (for B80 , B81 being non  empty set holds (for B82 being (Function of B79 , B80) holds (for B83 being (Function of B80 , B81) holds (for B84 being (ManySortedSet of B79) holds (for B85 being (ManySortedSet of B80) holds (for B86 being (ManySortedSet of B81) holds (for B87 being (MSUnTrans of B82 , B84 , B85) holds (for B88 being (MSUnTrans of ( B83 * B82 ) , ( B85 * B82 ) , B86) holds ((for B89 being set holds ((B89 in B79 & ( ( B85 * B82 ) . B89 ) = ( {} )) implies (( B84 . B89 ) = ( {} ) or ( ( B86 * ( B83 * B82 ) ) . B89 ) = ( {} )))) implies ( B88 ** (B87 qua  Function-yielding Function) ) is (MSUnTrans of ( B83 * B82 ) , B84 , B86)))))))))))
proof
let C151 being set;
let C152 , C153 being non  empty set;
let C154 being (Function of C151 , C152);
let C155 being (Function of C152 , C153);
let C156 being (ManySortedSet of C151);
let C157 being (ManySortedSet of C152);
let C158 being (ManySortedSet of C153);
let C159 being (MSUnTrans of C154 , C156 , C157);
let C160 being (MSUnTrans of ( C155 * C154 ) , ( C157 * C154 ) , C158);
assume that
L343: (for B90 being set holds ((B90 in C151 & ( ( C157 * C154 ) . B90 ) = ( {} )) implies (( C156 . B90 ) = ( {} ) or ( ( C158 * ( C155 * C154 ) ) . B90 ) = ( {} ))));
reconsider D35 = C160 as (ManySortedFunction of ( C157 * C154 ) , ( C158 * ( C155 * C154 ) )) by L303;
reconsider D36 = C159 as (ManySortedFunction of C156 , ( C157 * C154 )) by L303;
L344: ( dom D35 ) = C151 by PARTFUN1:def 2;
L345: ( dom D36 ) = C151 by PARTFUN1:def 2;
L346: ( dom ( D35 ** D36 ) ) = ( ( dom D35 ) /\ ( dom D36 ) ) by PBOOLE:def 19
.= C151 by L344 , L345;
reconsider D37 = ( D35 ** D36 ) as (ManySortedSet of C151);
L347: D37 is (ManySortedFunction of C156 , ( C158 * ( C155 * C154 ) ))
proof
let C161 being set;
assume L348: C161 in C151;
reconsider D38 = ( D36 . C161 ) as (Function of ( C156 . C161 ) , ( ( C157 * C154 ) . C161 )) by L348 , PBOOLE:def 15;
reconsider D39 = ( D35 . C161 ) as (Function of ( ( C157 * C154 ) . C161 ) , ( ( C158 * ( C155 * C154 ) ) . C161 )) by L348 , PBOOLE:def 15;
L349: (( ( C157 * C154 ) . C161 ) = ( {} ) implies (( C156 . C161 ) = ( {} ) or ( ( C158 * ( C155 * C154 ) ) . C161 ) = ( {} ))) by L343 , L348;
L350: ( D39 * D38 ) is (Function of ( C156 . C161 ) , ( ( C158 * ( C155 * C154 ) ) . C161 )) by L349 , FUNCT_2:13;
thus L351: thesis by L350 , L346 , L348 , PBOOLE:def 19;
end;
thus L352: thesis by L347 , L303;
end;
begin
definition
let C162 , C163 being 1-sorted;
struct BimapStr over C162 , C163(# ObjectMap -> (bifunction of (the carrier of C162) , (the carrier of C163)) #);
end;
definition
let C164 , C165 being non  empty AltGraph;
let C166 being BimapStr over C164 , C165;
let C167 being (object of C164);
func C166 . C167 -> (object of C165) equals 
( ( (the ObjectMap of C166) . (C167 , C167) ) `1 );
coherence by MCART_1:10;
end;
definition
let C168 , C169 being 1-sorted;
let C170 being BimapStr over C168 , C169;
attr C170 is  one-to-one
means
:L355: (the ObjectMap of C170) is  one-to-one;
attr C170 is  onto
means
:L356: (the ObjectMap of C170) is  onto;
attr C170 is  reflexive
means
:L357: ( (the ObjectMap of C170) .: ( id (the carrier of C168) ) ) c= ( id (the carrier of C169) );
attr C170 is  coreflexive
means
:L358: ( id (the carrier of C169) ) c= ( (the ObjectMap of C170) .: ( id (the carrier of C168) ) );
end;
definition
let C171 , C172 being non  empty AltGraph;
let C173 being BimapStr over C171 , C172;
redefine attr C173 is  reflexive
means
:L360: (for B91 being (object of C171) holds ( (the ObjectMap of C173) . (B91 , B91) ) = [ ( C173 . B91 ) , ( C173 . B91 ) ]);
compatibility
proof
thus L361:now
assume L362: C173 is  reflexive;
L363: ( (the ObjectMap of C173) .: ( id (the carrier of C171) ) ) c= ( id (the carrier of C172) ) by L362 , L357;
let C174 being (object of C171);
L364: [ C174 , C174 ] in ( id (the carrier of C171) ) by RELAT_1:def 10;
L365: ( (the ObjectMap of C173) . (C174 , C174) ) in ( (the ObjectMap of C173) .: ( id (the carrier of C171) ) ) by L364 , FUNCT_2:35;
consider C175 , C176 being set such that L366: ( (the ObjectMap of C173) . (C174 , C174) ) = [ C175 , C176 ] by RELAT_1:def 1;
L367: ( C173 . C174 ) = C175 by L366 , MCART_1:7;
thus L368: ( (the ObjectMap of C173) . (C174 , C174) ) = [ ( C173 . C174 ) , ( C173 . C174 ) ] by L367 , L363 , L365 , L366 , RELAT_1:def 10;
end;
assume L369: (for B92 being (object of C171) holds ( (the ObjectMap of C173) . (B92 , B92) ) = [ ( C173 . B92 ) , ( C173 . B92 ) ]);
let C177 being set;
assume L370: C177 in ( (the ObjectMap of C173) .: ( id (the carrier of C171) ) );
consider C178 being set such that L371: C178 in [: (the carrier of C171) , (the carrier of C171) :] and L372: C178 in ( id (the carrier of C171) ) and L373: C177 = ( (the ObjectMap of C173) . C178 ) by L370 , FUNCT_2:64;
consider C179 , C180 being (Element of C171) such that L374: C178 = [ C179 , C180 ] by L371 , DOMAIN_1:1;
reconsider D40 = C179 as (object of C171);
L375: D40 = C180 by L372 , L374 , RELAT_1:def 10;
L376: C177 = [ ( C173 . D40 ) , ( C173 . D40 ) ] by L375 , L369 , L373 , L374;
thus L377: thesis by L376 , RELAT_1:def 10;
end;
end;
theorem
L379: (for B93 , B94 being  reflexive non  empty AltGraph holds (for B95 being BimapStr over B93 , B94 holds (B95 is  coreflexive implies (for B96 being (object of B94) holds (ex B97 being (object of B93) st ( B95 . B97 ) = B96)))))
proof
let C181 , C182 being  reflexive non  empty AltGraph;
let C183 being BimapStr over C181 , C182;
assume L380: C183 is  coreflexive;
L381: ( id (the carrier of C182) ) c= ( (the ObjectMap of C183) .: ( id (the carrier of C181) ) ) by L380 , L358;
let C184 being (object of C182);
reconsider D41 = [ C184 , C184 ] as (Element of [: (the carrier of C182) , (the carrier of C182) :]) by ZFMISC_1:87;
L382: [ C184 , C184 ] in ( id (the carrier of C182) ) by RELAT_1:def 10;
consider C185 being (Element of [: (the carrier of C181) , (the carrier of C181) :]) such that L383: C185 in ( id (the carrier of C181) ) and L384: ( (the ObjectMap of C183) . C185 ) = D41 by L382 , L381 , FUNCT_2:65;
consider C186 , C187 being set such that L385: C185 = [ C186 , C187 ] by RELAT_1:def 1;
L386: C186 = C187 by L383 , L385 , RELAT_1:def 10;
reconsider D42 = C186 as (object of C181) by L383 , L385 , RELAT_1:def 10;
take D42;
thus L387: thesis by L384 , L385 , L386 , MCART_1:7;
end;
definition
let C188 , C189 being non  empty AltGraph;
let C190 being BimapStr over C188 , C189;
attr C190 is  feasible
means
:L388: (for B98 , B99 being (object of C188) holds (<^ B98 , B99 ^> <> ( {} ) implies ( (the Arrows of C189) . ( (the ObjectMap of C190) . (B98 , B99) ) ) <> ( {} )));
end;
definition
let C191 , C192 being AltGraph;
struct (BimapStr over C191 , C192) FunctorStr over C191 , C192(# ObjectMap -> (bifunction of (the carrier of C191) , (the carrier of C192)) , MorphMap -> (MSUnTrans of the ObjectMap , (the Arrows of C191) , (the Arrows of C192)) #);
end;
definition
let C193 , C194 being 1-sorted;
let C195 being BimapStr over C193 , C194;
attr C195 is  Covariant
means
:L391: (the ObjectMap of C195) is  Covariant;
attr C195 is  Contravariant
means
:L392: (the ObjectMap of C195) is  Contravariant;
end;
registration
let C196 , C197 being AltGraph;
cluster  Covariant for FunctorStr over C196 , C197;
existence
proof
set D43 = the  Covariant (bifunction of (the carrier of C196) , (the carrier of C197));
set D44 = the (MSUnTrans of D43 , (the Arrows of C196) , (the Arrows of C197));
take D45 = FunctorStr (# D43 , D44 #);
thus L394: (the ObjectMap of D45) is  Covariant;
end;
cluster  Contravariant for FunctorStr over C196 , C197;
existence
proof
set D46 = the  Contravariant (bifunction of (the carrier of C196) , (the carrier of C197));
set D47 = the (MSUnTrans of D46 , (the Arrows of C196) , (the Arrows of C197));
take D48 = FunctorStr (# D46 , D47 #);
thus L395: (the ObjectMap of D48) is  Contravariant;
end;
end;
definition
let C198 , C199 being AltGraph;
let C200 being FunctorStr over C198 , C199;
let C201 , C202 being (object of C198);
func Morph-Map (C200 , C201 , C202) equals 
( (the MorphMap of C200) . (C201 , C202) );
correctness;
end;
registration
let C203 , C204 being AltGraph;
let C205 being FunctorStr over C203 , C204;
let C206 , C207 being (object of C203);
cluster ( Morph-Map (C205 , C206 , C207) ) ->  Relation-like  Function-like;
coherence;
end;
definition
let C208 , C209 being non  empty AltGraph;
let C210 being  Covariant FunctorStr over C208 , C209;
let C211 , C212 being (object of C208);
redefine func Morph-Map (C210 , C211 , C212) -> (Function of <^ C211 , C212 ^> , <^ ( C210 . C211 ) , ( C210 . C212 ) ^>);

coherence
proof
consider C213 being non  empty set, C214 being (ManySortedSet of C213), C215 being (Function of [: (the carrier of C208) , (the carrier of C208) :] , C213) such that L399: (the ObjectMap of C210) = C215 and L400: (the Arrows of C209) = C214 and L401: (the MorphMap of C210) is (ManySortedFunction of (the Arrows of C208) , ( C214 * C215 )) by L296;
L402: ( (the Arrows of C208) . [ C211 , C212 ] ) = ( (the Arrows of C208) . (C211 , C212) )
.= <^ C211 , C212 ^> by ALTCAT_1:def 1;
L403: [ C211 , C212 ] in [: (the carrier of C208) , (the carrier of C208) :] by ZFMISC_1:87;
L404: (the ObjectMap of C210) is  Covariant by L391;
consider C216 being (Function of (the carrier of C208) , (the carrier of C209)) such that L405: (the ObjectMap of C210) = [: C216 , C216 :] by L404 , L257;
L406: ( C210 . C211 ) = ( [ ( C216 . C211 ) , ( C216 . C211 ) ] `1 ) by L405 , FUNCT_3:75
.= ( C216 . C211 );
L407: ( C210 . C212 ) = ( [ ( C216 . C212 ) , ( C216 . C212 ) ] `1 ) by L405 , FUNCT_3:75
.= ( C216 . C212 );
L408: ( dom C215 ) = [: (the carrier of C208) , (the carrier of C208) :] by FUNCT_2:def 1;
L409: ( ( C214 * C215 ) . [ C211 , C212 ] ) = ( C214 . ( C215 . (C211 , C212) ) ) by L408 , L403 , FUNCT_1:13
.= ( (the Arrows of C209) . (( C210 . C211 ) , ( C210 . C212 )) ) by L399 , L400 , L405 , L406 , L407 , FUNCT_3:75
.= <^ ( C210 . C211 ) , ( C210 . C212 ) ^> by ALTCAT_1:def 1;
thus L410: thesis by L409 , L401 , L402 , L403 , PBOOLE:def 15;
end;
end;
definition
let C217 , C218 being non  empty AltGraph;
let C219 being  Covariant FunctorStr over C217 , C218;
let C220 , C221 being (object of C217);
assume that
L412: <^ C220 , C221 ^> <> ( {} )
and
L413: <^ ( C219 . C220 ) , ( C219 . C221 ) ^> <> ( {} );
let C222 being (Morphism of C220 , C221);
func C219 . C222 -> (Morphism of ( C219 . C220 ) , ( C219 . C221 )) equals 
:L414: ( ( Morph-Map (C219 , C220 , C221) ) . C222 );
coherence
proof
reconsider D49 = <^ C220 , C221 ^> , D50 = <^ ( C219 . C220 ) , ( C219 . C221 ) ^> as non  empty set by L412 , L413;
reconsider D51 = ( Morph-Map (C219 , C220 , C221) ) as (Function of D49 , D50);
reconsider D52 = C222 as (Element of D49);
L415: ( D51 . D52 ) is (Element of D50);
thus L416: thesis by L415;
end;
end;
definition
let C223 , C224 being non  empty AltGraph;
let C225 being  Contravariant FunctorStr over C223 , C224;
let C226 , C227 being (object of C223);
redefine func Morph-Map (C225 , C226 , C227) -> (Function of <^ C226 , C227 ^> , <^ ( C225 . C227 ) , ( C225 . C226 ) ^>);

coherence
proof
consider C228 being non  empty set, C229 being (ManySortedSet of C228), C230 being (Function of [: (the carrier of C223) , (the carrier of C223) :] , C228) such that L418: (the ObjectMap of C225) = C230 and L419: (the Arrows of C224) = C229 and L420: (the MorphMap of C225) is (ManySortedFunction of (the Arrows of C223) , ( C229 * C230 )) by L296;
L421: ( (the Arrows of C223) . [ C226 , C227 ] ) = ( (the Arrows of C223) . (C226 , C227) )
.= <^ C226 , C227 ^> by ALTCAT_1:def 1;
L422: [ C226 , C227 ] in [: (the carrier of C223) , (the carrier of C223) :] by ZFMISC_1:87;
L423: (the ObjectMap of C225) is  Contravariant by L392;
consider C231 being (Function of (the carrier of C223) , (the carrier of C224)) such that L424: (the ObjectMap of C225) = ( ~ [: C231 , C231 :] ) by L423 , L258;
L425: ( dom C230 ) = [: (the carrier of C223) , (the carrier of C223) :] by FUNCT_2:def 1;
L426: [ C226 , C226 ] in ( dom ( ~ [: C231 , C231 :] ) ) by L425 , L418 , L424 , ZFMISC_1:87;
L427: [ C226 , C226 ] in ( dom [: C231 , C231 :] ) by L426 , FUNCT_4:42;
L428: ( C225 . C226 ) = ( ( [: C231 , C231 :] . (C226 , C226) ) `1 ) by L427 , L424 , FUNCT_4:def 2
.= ( [ ( C231 . C226 ) , ( C231 . C226 ) ] `1 ) by FUNCT_3:75
.= ( C231 . C226 );
L429: [ C227 , C227 ] in ( dom ( ~ [: C231 , C231 :] ) ) by L418 , L424 , L425 , ZFMISC_1:87;
L430: [ C227 , C227 ] in ( dom [: C231 , C231 :] ) by L429 , FUNCT_4:42;
L431: ( C225 . C227 ) = ( ( [: C231 , C231 :] . (C227 , C227) ) `1 ) by L430 , L424 , FUNCT_4:def 2
.= ( [ ( C231 . C227 ) , ( C231 . C227 ) ] `1 ) by FUNCT_3:75
.= ( C231 . C227 );
L432: [ C226 , C227 ] in ( dom ( ~ [: C231 , C231 :] ) ) by L418 , L424 , L425 , ZFMISC_1:87;
L433: [ C227 , C226 ] in ( dom [: C231 , C231 :] ) by L432 , FUNCT_4:42;
L434: ( ( C229 * C230 ) . [ C226 , C227 ] ) = ( C229 . ( C230 . (C226 , C227) ) ) by L422 , L425 , FUNCT_1:13
.= ( C229 . ( [: C231 , C231 :] . (C227 , C226) ) ) by L418 , L424 , L433 , FUNCT_4:def 2
.= ( (the Arrows of C224) . (( C225 . C227 ) , ( C225 . C226 )) ) by L419 , L428 , L431 , FUNCT_3:75
.= <^ ( C225 . C227 ) , ( C225 . C226 ) ^> by ALTCAT_1:def 1;
thus L435: thesis by L434 , L420 , L421 , L422 , PBOOLE:def 15;
end;
end;
definition
let C232 , C233 being non  empty AltGraph;
let C234 being  Contravariant FunctorStr over C232 , C233;
let C235 , C236 being (object of C232);
assume that
L437: <^ C235 , C236 ^> <> ( {} )
and
L438: <^ ( C234 . C236 ) , ( C234 . C235 ) ^> <> ( {} );
let C237 being (Morphism of C235 , C236);
func C234 . C237 -> (Morphism of ( C234 . C236 ) , ( C234 . C235 )) equals 
:L439: ( ( Morph-Map (C234 , C235 , C236) ) . C237 );
coherence
proof
reconsider D53 = <^ C235 , C236 ^> , D54 = <^ ( C234 . C236 ) , ( C234 . C235 ) ^> as non  empty set by L437 , L438;
reconsider D55 = ( Morph-Map (C234 , C235 , C236) ) as (Function of D53 , D54);
reconsider D56 = C237 as (Element of D53);
L440: ( D55 . D56 ) is (Element of D54);
thus L441: thesis by L440;
end;
end;
definition
let C238 , C239 being non  empty AltGraph;
let C240 being (object of C239);
assume that
L443: <^ C240 , C240 ^> <> ( {} );
let C241 being (Morphism of C240 , C240);
func C238 --> C241 ->  strict FunctorStr over C238 , C239 means 
:L444: ((the ObjectMap of it) = ( [: (the carrier of C238) , (the carrier of C238) :] --> [ C240 , C240 ] ) & (the MorphMap of it) = { [ [ B100 , B101 ] , ( <^ B100 , B101 ^> --> C241 ) ] where B100 is (object of C238) , B101 is (object of C238) : (not contradiction) });
existence
proof
set D57 = [: (the carrier of C238) , (the carrier of C238) :];
set D58 = [: (the carrier of C239) , (the carrier of C239) :];
set D59 = (the Arrows of C238);
set D60 = (the Arrows of C239);
reconsider D61 = [ C240 , C240 ] as (Element of D58) by ZFMISC_1:87;
L445: ( D60 . D61 ) = ( D60 . (C240 , C240) )
.= <^ C240 , C240 ^> by ALTCAT_1:def 1;
reconsider D62 = C241 as (Element of ( D60 . D61 )) by L445;
reconsider D63 = ( D57 --> D61 ) as (Function of D57 , D58);
reconsider D64 = D63 as (bifunction of (the carrier of C238) , (the carrier of C239));
set D65 = { [ [ B102 , B103 ] , ( <^ B102 , B103 ^> --> D62 ) ] where B102 is (object of C238) , B103 is (object of C238) : (not contradiction) };
L446: D65 = { [ B104 , ( ( D59 . B104 ) --> D62 ) ] where B104 is (Element of D57) : (not contradiction) }
proof
thus L447: D65 c= { [ B105 , ( ( D59 . B105 ) --> D62 ) ] where B105 is (Element of D57) : (not contradiction) }
proof
let C242 being set;
assume L448: C242 in D65;
consider C243 , C244 being (object of C238) such that L449: C242 = [ [ C243 , C244 ] , ( <^ C243 , C244 ^> --> D62 ) ] by L448;
reconsider D66 = [ C243 , C244 ] as (Element of D57) by ZFMISC_1:87;
L450: C242 = [ D66 , ( ( D59 . (C243 , C244) ) --> D62 ) ] by L449 , ALTCAT_1:def 1
.= [ D66 , ( ( D59 . D66 ) --> D62 ) ];
thus L451: thesis by L450;
end;

let C245 being set;
assume L452: C245 in { [ B106 , ( ( D59 . B106 ) --> D62 ) ] where B106 is (Element of D57) : (not contradiction) };
consider C246 being (Element of D57) such that L453: C245 = [ C246 , ( ( D59 . C246 ) --> D62 ) ] by L452;
reconsider D67 = ( C246 `1 ) , D68 = ( C246 `2 ) as (Element of C238) by MCART_1:10;
reconsider D69 = D67 , D70 = D68 as (object of C238);
L454: C246 = [ D69 , D70 ] by MCART_1:21;
L455: C245 = [ [ D69 , D70 ] , ( ( D59 . (D69 , D70) ) --> D62 ) ] by L454 , L453
.= [ [ D69 , D70 ] , ( <^ D69 , D70 ^> --> D62 ) ] by ALTCAT_1:def 1;
thus L456: thesis by L455;
end;
L457: ( D60 . (C240 , C240) ) <> ( {} ) by L443 , ALTCAT_1:def 1;
reconsider D71 = D65 as (MSUnTrans of D64 , D59 , D60) by L457 , L446 , L325;
take FunctorStr (# D64 , D71 #);
thus L458: thesis;
end;
uniqueness;
end;
theorem
L460: (for B107 , B108 being non  empty AltGraph holds (for B109 being (object of B108) holds (<^ B109 , B109 ^> <> ( {} ) implies (for B110 being (Morphism of B109 , B109) holds (for B111 being (object of B107) holds ( ( B107 --> B110 ) . B111 ) = B109)))))
proof
let C247 , C248 being non  empty AltGraph;
let C249 being (object of C248);
assume that
L461: <^ C249 , C249 ^> <> ( {} );
let C250 being (Morphism of C249 , C249);
let C251 being (object of C247);
L462: [ C251 , C251 ] in [: (the carrier of C247) , (the carrier of C247) :] by ZFMISC_1:87;
thus L463: ( ( C247 --> C250 ) . C251 ) = ( ( ( [: (the carrier of C247) , (the carrier of C247) :] --> [ C249 , C249 ] ) . (C251 , C251) ) `1 ) by L461 , L444
.= ( [ C249 , C249 ] `1 ) by L462 , FUNCOP_1:7
.= C249;
end;
registration
let C252 being non  empty AltGraph;
let C253 being non  empty  reflexive AltGraph;
let C254 being (object of C253);
let C255 being (Morphism of C254 , C254);
cluster ( C252 --> C255 ) ->  Covariant  Contravariant  feasible;
coherence
proof
L464: <^ C254 , C254 ^> <> ( {} ) by ALTCAT_2:def 7;
L465: (the ObjectMap of ( C252 --> C255 )) = ( [: (the carrier of C252) , (the carrier of C252) :] --> [ C254 , C254 ] ) by L464 , L444;
thus L466: (the ObjectMap of ( C252 --> C255 )) is  Covariant  Contravariant by L465 , L260;
let C256 , C257 being (object of C252);
assume that
L467: <^ C256 , C257 ^> <> ( {} );
L468: [ C256 , C257 ] in [: (the carrier of C252) , (the carrier of C252) :] by ZFMISC_1:87;
L469: ( (the Arrows of C253) . ( (the ObjectMap of ( C252 --> C255 )) . (C256 , C257) ) ) = ( (the Arrows of C253) . (C254 , C254) ) by L468 , L465 , FUNCOP_1:7;
thus L470: thesis by L469 , ALTCAT_2:def 6;
end;
end;
registration
let C258 being non  empty AltGraph;
let C259 being non  empty  reflexive AltGraph;
cluster  feasible  Covariant  Contravariant for FunctorStr over C258 , C259;
existence
proof
set D72 = the (object of C259);
set D73 = the (Morphism of D72 , D72);
take ( C258 --> D73 );
thus L472: thesis;
end;
end;
theorem
L474: (for B112 , B113 being non  empty AltGraph holds (for B114 being  Covariant FunctorStr over B112 , B113 holds (for B115 , B116 being (object of B112) holds ( (the ObjectMap of B114) . (B115 , B116) ) = [ ( B114 . B115 ) , ( B114 . B116 ) ])))
proof
let C260 , C261 being non  empty AltGraph;
let C262 being  Covariant FunctorStr over C260 , C261;
let C263 , C264 being (object of C260);
L475: (the ObjectMap of C262) is  Covariant by L391;
consider C265 being (Function of (the carrier of C260) , (the carrier of C261)) such that L476: (the ObjectMap of C262) = [: C265 , C265 :] by L475 , L257;
L477: ( C262 . C263 ) = ( [ ( C265 . C263 ) , ( C265 . C263 ) ] `1 ) by L476 , FUNCT_3:75
.= ( C265 . C263 );
L478: ( C262 . C264 ) = ( [ ( C265 . C264 ) , ( C265 . C264 ) ] `1 ) by L476 , FUNCT_3:75
.= ( C265 . C264 );
thus L479: thesis by L478 , L476 , L477 , FUNCT_3:75;
end;
definition
let C266 , C267 being non  empty AltGraph;
let C268 being  Covariant FunctorStr over C266 , C267;
redefine attr C268 is  feasible
means
:L480: (for B117 , B118 being (object of C266) holds (<^ B117 , B118 ^> <> ( {} ) implies <^ ( C268 . B117 ) , ( C268 . B118 ) ^> <> ( {} )));
compatibility
proof
thus L481:now
assume L482: C268 is  feasible;
let C269 , C270 being (object of C266);
assume L483: <^ C269 , C270 ^> <> ( {} );
L484: <^ ( C268 . C269 ) , ( C268 . C270 ) ^> = ( (the Arrows of C267) . (( C268 . C269 ) , ( C268 . C270 )) ) by ALTCAT_1:def 1
.= ( (the Arrows of C267) . ( (the ObjectMap of C268) . (C269 , C270) ) ) by L474;
thus L485: <^ ( C268 . C269 ) , ( C268 . C270 ) ^> <> ( {} ) by L484 , L482 , L483 , L388;
end;
assume L486: (for B119 , B120 being (object of C266) holds (<^ B119 , B120 ^> <> ( {} ) implies <^ ( C268 . B119 ) , ( C268 . B120 ) ^> <> ( {} )));
let C271 , C272 being (object of C266);
assume L487: <^ C271 , C272 ^> <> ( {} );
L488: <^ ( C268 . C271 ) , ( C268 . C272 ) ^> = ( (the Arrows of C267) . (( C268 . C271 ) , ( C268 . C272 )) ) by ALTCAT_1:def 1
.= ( (the Arrows of C267) . ( (the ObjectMap of C268) . (C271 , C272) ) ) by L474;
thus L489: thesis by L488 , L486 , L487;
end;
end;
theorem
L491: (for B121 , B122 being non  empty AltGraph holds (for B123 being  Contravariant FunctorStr over B121 , B122 holds (for B124 , B125 being (object of B121) holds ( (the ObjectMap of B123) . (B124 , B125) ) = [ ( B123 . B125 ) , ( B123 . B124 ) ])))
proof
let C273 , C274 being non  empty AltGraph;
let C275 being  Contravariant FunctorStr over C273 , C274;
let C276 , C277 being (object of C273);
L492: (the ObjectMap of C275) is  Contravariant by L392;
consider C278 being (Function of (the carrier of C273) , (the carrier of C274)) such that L493: (the ObjectMap of C275) = ( ~ [: C278 , C278 :] ) by L492 , L258;
L494: ( dom [: C278 , C278 :] ) = [: (the carrier of C273) , (the carrier of C273) :] by FUNCT_2:def 1;
L495: [ C276 , C276 ] in ( dom [: C278 , C278 :] ) by L494 , ZFMISC_1:87;
L496: ( C275 . C276 ) = ( ( [: C278 , C278 :] . (C276 , C276) ) `1 ) by L495 , L493 , FUNCT_4:def 2
.= ( [ ( C278 . C276 ) , ( C278 . C276 ) ] `1 ) by FUNCT_3:75
.= ( C278 . C276 );
L497: [ C277 , C277 ] in ( dom [: C278 , C278 :] ) by L494 , ZFMISC_1:87;
L498: ( C275 . C277 ) = ( ( [: C278 , C278 :] . (C277 , C277) ) `1 ) by L497 , L493 , FUNCT_4:def 2
.= ( [ ( C278 . C277 ) , ( C278 . C277 ) ] `1 ) by FUNCT_3:75
.= ( C278 . C277 );
L499: [ C277 , C276 ] in ( dom [: C278 , C278 :] ) by L494 , ZFMISC_1:87;
thus L500: ( (the ObjectMap of C275) . (C276 , C277) ) = ( [: C278 , C278 :] . (C277 , C276) ) by L499 , L493 , FUNCT_4:def 2
.= [ ( C275 . C277 ) , ( C275 . C276 ) ] by L496 , L498 , FUNCT_3:75;
end;
definition
let C279 , C280 being non  empty AltGraph;
let C281 being  Contravariant FunctorStr over C279 , C280;
redefine attr C281 is  feasible
means
:L501: (for B126 , B127 being (object of C279) holds (<^ B126 , B127 ^> <> ( {} ) implies <^ ( C281 . B127 ) , ( C281 . B126 ) ^> <> ( {} )));
compatibility
proof
thus L502:now
assume L503: C281 is  feasible;
let C282 , C283 being (object of C279);
assume L504: <^ C282 , C283 ^> <> ( {} );
L505: <^ ( C281 . C283 ) , ( C281 . C282 ) ^> = ( (the Arrows of C280) . (( C281 . C283 ) , ( C281 . C282 )) ) by ALTCAT_1:def 1
.= ( (the Arrows of C280) . ( (the ObjectMap of C281) . (C282 , C283) ) ) by L491;
thus L506: <^ ( C281 . C283 ) , ( C281 . C282 ) ^> <> ( {} ) by L505 , L503 , L504 , L388;
end;
assume L507: (for B128 , B129 being (object of C279) holds (<^ B128 , B129 ^> <> ( {} ) implies <^ ( C281 . B129 ) , ( C281 . B128 ) ^> <> ( {} )));
let C284 , C285 being (object of C279);
assume L508: <^ C284 , C285 ^> <> ( {} );
L509: <^ ( C281 . C285 ) , ( C281 . C284 ) ^> = ( (the Arrows of C280) . (( C281 . C285 ) , ( C281 . C284 )) ) by ALTCAT_1:def 1
.= ( (the Arrows of C280) . ( (the ObjectMap of C281) . (C284 , C285) ) ) by L491;
thus L510: thesis by L509 , L507 , L508;
end;
end;
registration
let C286 , C287 being AltGraph;
let C288 being FunctorStr over C286 , C287;
cluster (the MorphMap of C288) ->  Function-yielding;
coherence;
end;
registration
cluster non  empty  reflexive for AltCatStr;
existence
proof
set D74 = the category;
take D74;
thus L513: thesis;
end;
end;
definition
let C289 , C290 being  with_units non  empty AltCatStr;
let C291 being FunctorStr over C289 , C290;
attr C291 is  id-preserving
means
:L515: (for B130 being (object of C289) holds ( ( Morph-Map (C291 , B130 , B130) ) . ( idm B130 ) ) = ( idm ( C291 . B130 ) ));
end;
theorem
L517: (for B131 , B132 being non  empty AltGraph holds (for B133 being (object of B132) holds (<^ B133 , B133 ^> <> ( {} ) implies (for B134 being (Morphism of B133 , B133) holds (for B135 , B136 being (object of B131) holds (for B137 being (Morphism of B135 , B136) holds (<^ B135 , B136 ^> <> ( {} ) implies ( ( Morph-Map (( B131 --> B134 ) , B135 , B136) ) . B137 ) = B134)))))))
proof
let C292 , C293 being non  empty AltGraph;
let C294 being (object of C293);
assume that
L518: <^ C294 , C294 ^> <> ( {} );
let C295 being (Morphism of C294 , C294);
let C296 , C297 being (object of C292);
let C298 being (Morphism of C296 , C297);
assume that
L519: <^ C296 , C297 ^> <> ( {} );
set D75 = { [ [ B138 , B139 ] , ( <^ B138 , B139 ^> --> C295 ) ] where B138 is (object of C292) , B139 is (object of C292) : (not contradiction) };
set D76 = { [ [ B140 , B141 ] , ( ( (the Arrows of C292) . (B140 , B141) ) --> C295 ) ] where B140 is (Element of C292) , B141 is (Element of C292) : (not contradiction) };
L520: D75 c= D76
proof
let C299 being set;
assume L521: C299 in D75;
consider C300 , C301 being (object of C292) such that L522: C299 = [ [ C300 , C301 ] , ( <^ C300 , C301 ^> --> C295 ) ] by L521;
L523: C299 = [ [ C300 , C301 ] , ( ( (the Arrows of C292) . (C300 , C301) ) --> C295 ) ] by L522 , ALTCAT_1:def 1;
thus L524: thesis by L523;
end;
L525: D76 c= D75
proof
let C302 being set;
assume L526: C302 in D76;
consider C303 , C304 being (Element of C292) such that L527: C302 = [ [ C303 , C304 ] , ( ( (the Arrows of C292) . (C303 , C304) ) --> C295 ) ] by L526;
reconsider D77 = C303 , D78 = C304 as (object of C292);
L528: C302 = [ [ D77 , D78 ] , ( <^ D77 , D78 ^> --> C295 ) ] by L527 , ALTCAT_1:def 1;
thus L529: thesis by L528;
end;
defpred S3[ set , set ] means (not contradiction);
deffunc H4((Element of C292) , (Element of C292)) = ( ( (the Arrows of C292) . ($1 , $2) ) --> C295 );
L530: (the MorphMap of ( C292 --> C295 )) = D75 by L518 , L444;
L531: (the MorphMap of ( C292 --> C295 )) = { [ [ B142 , B143 ] , H4(B142 , B143) ] where B142 is (Element of C292) , B143 is (Element of C292) : S3[ B142 , B143 ] } by L530 , L520 , L525 , XBOOLE_0:def 10;
L532: S3[ C296 , C297 ];
L533: ( Morph-Map (( C292 --> C295 ) , C296 , C297) ) = ( (the MorphMap of ( C292 --> C295 )) . (C296 , C297) )
.= H4(C296 , C297) from ValOnPair(L531 , L532);
thus L534: ( ( Morph-Map (( C292 --> C295 ) , C296 , C297) ) . C298 ) = ( ( <^ C296 , C297 ^> --> C295 ) . C298 ) by L533 , ALTCAT_1:def 1
.= C295 by L519 , FUNCOP_1:7;
end;
registration
cluster  with_units ->  reflexive for non  empty non  empty non  empty non  empty AltCatStr;
coherence;
end;
registration
let C305 , C306 being  with_units non  empty AltCatStr;
let C307 being (object of C306);
cluster ( C305 --> ( idm C307 ) ) ->  id-preserving;
coherence
proof
let C308 being (object of C305);
L536: <^ C307 , C307 ^> <> ( {} ) by ALTCAT_2:def 7;
L537: <^ C308 , C308 ^> <> ( {} ) by ALTCAT_2:def 7;
thus L538: ( ( Morph-Map (( C305 --> ( idm C307 ) ) , C308 , C308) ) . ( idm C308 ) ) = ( idm C307 ) by L537 , L536 , L517
.= ( idm ( ( C305 --> ( idm C307 ) ) . C308 ) ) by L536 , L460;
end;
end;
registration
let C309 being non  empty AltGraph;
let C310 being non  empty  reflexive AltGraph;
let C311 being (object of C310);
let C312 being (Morphism of C311 , C311);
cluster ( C309 --> C312 ) ->  reflexive;
coherence
proof
let C313 being (object of C309);
L540: [ C313 , C313 ] in [: (the carrier of C309) , (the carrier of C309) :] by ZFMISC_1:87;
L541: <^ C311 , C311 ^> <> ( {} ) by ALTCAT_2:def 7;
L542: ( (the ObjectMap of ( C309 --> C312 )) . (C313 , C313) ) = ( ( [: (the carrier of C309) , (the carrier of C309) :] --> [ C311 , C311 ] ) . [ C313 , C313 ] ) by L541 , L444
.= [ C311 , C311 ] by L540 , FUNCOP_1:7;
L543: ( ( C309 --> C312 ) . C313 ) = C311 by L542 , MCART_1:7;
thus L544: thesis by L543 , L542;
end;
end;
registration
let C314 being non  empty AltGraph;
let C315 being non  empty  reflexive AltGraph;
cluster  feasible  reflexive for FunctorStr over C314 , C315;
existence
proof
set D79 = the (object of C315);
set D80 = the (Morphism of D79 , D79);
take ( C314 --> D80 );
thus L546: thesis;
end;
end;
registration
let C316 , C317 being  with_units non  empty AltCatStr;
cluster  id-preserving  feasible  reflexive  strict for FunctorStr over C316 , C317;
existence
proof
set D81 = the (object of C317);
take ( C316 --> ( idm D81 ) );
thus L548: thesis;
end;
end;
definition
let C318 , C319 being non  empty AltCatStr;
let C320 being FunctorStr over C318 , C319;
attr C320 is  comp-preserving
means
:L550: (for B144 , B145 , B146 being (object of C318) holds ((<^ B144 , B145 ^> <> ( {} ) & <^ B145 , B146 ^> <> ( {} )) implies (for B147 being (Morphism of B144 , B145) holds (for B148 being (Morphism of B145 , B146) holds (ex B149 being (Morphism of ( C320 . B144 ) , ( C320 . B145 )) st (ex B150 being (Morphism of ( C320 . B145 ) , ( C320 . B146 )) st (B149 = ( ( Morph-Map (C320 , B144 , B145) ) . B147 ) & B150 = ( ( Morph-Map (C320 , B145 , B146) ) . B148 ) & ( ( Morph-Map (C320 , B144 , B146) ) . ( B148 * B147 ) ) = ( B150 * B149 ))))))));
end;
definition
let C321 , C322 being non  empty AltCatStr;
let C323 being FunctorStr over C321 , C322;
attr C323 is  comp-reversing
means
:L552: (for B151 , B152 , B153 being (object of C321) holds ((<^ B151 , B152 ^> <> ( {} ) & <^ B152 , B153 ^> <> ( {} )) implies (for B154 being (Morphism of B151 , B152) holds (for B155 being (Morphism of B152 , B153) holds (ex B156 being (Morphism of ( C323 . B152 ) , ( C323 . B151 )) st (ex B157 being (Morphism of ( C323 . B153 ) , ( C323 . B152 )) st (B156 = ( ( Morph-Map (C323 , B151 , B152) ) . B154 ) & B157 = ( ( Morph-Map (C323 , B152 , B153) ) . B155 ) & ( ( Morph-Map (C323 , B151 , B153) ) . ( B155 * B154 ) ) = ( B156 * B157 ))))))));
end;
definition
let C324 being non  empty  transitive AltCatStr;
let C325 being non  empty  reflexive AltCatStr;
let C326 being  Covariant  feasible FunctorStr over C324 , C325;
redefine attr C326 is  comp-preserving
means
(for B158 , B159 , B160 being (object of C324) holds ((<^ B158 , B159 ^> <> ( {} ) & <^ B159 , B160 ^> <> ( {} )) implies (for B161 being (Morphism of B158 , B159) holds (for B162 being (Morphism of B159 , B160) holds ( C326 . ( B162 * B161 ) ) = ( ( C326 . B162 ) * ( C326 . B161 ) )))));
compatibility
proof
thus L554:now
assume L555: C326 is  comp-preserving;
let C327 , C328 , C329 being (object of C324);
assume that
L556: <^ C327 , C328 ^> <> ( {} )
and
L557: <^ C328 , C329 ^> <> ( {} );
let C330 being (Morphism of C327 , C328);
let C331 being (Morphism of C328 , C329);
consider C332 being (Morphism of ( C326 . C327 ) , ( C326 . C328 )), C333 being (Morphism of ( C326 . C328 ) , ( C326 . C329 )) such that L558: C332 = ( ( Morph-Map (C326 , C327 , C328) ) . C330 ) and L559: C333 = ( ( Morph-Map (C326 , C328 , C329) ) . C331 ) and L560: ( ( Morph-Map (C326 , C327 , C329) ) . ( C331 * C330 ) ) = ( C333 * C332 ) by L555 , L556 , L557 , L550;
L561: <^ ( C326 . C327 ) , ( C326 . C328 ) ^> <> ( {} ) by L556 , L480;
L562: <^ ( C326 . C328 ) , ( C326 . C329 ) ^> <> ( {} ) by L557 , L480;
L563: C332 = ( C326 . C330 ) by L556 , L558 , L561 , L414;
L564: C333 = ( C326 . C331 ) by L557 , L559 , L562 , L414;
L565: <^ C327 , C329 ^> <> ( {} ) by L556 , L557 , ALTCAT_1:def 2;
L566: <^ ( C326 . C327 ) , ( C326 . C329 ) ^> <> ( {} ) by L565 , L480;
thus L567: ( C326 . ( C331 * C330 ) ) = ( ( C326 . C331 ) * ( C326 . C330 ) ) by L566 , L560 , L563 , L564 , L565 , L414;
end;
assume L568: (for B163 , B164 , B165 being (object of C324) holds ((<^ B163 , B164 ^> <> ( {} ) & <^ B164 , B165 ^> <> ( {} )) implies (for B166 being (Morphism of B163 , B164) holds (for B167 being (Morphism of B164 , B165) holds ( C326 . ( B167 * B166 ) ) = ( ( C326 . B167 ) * ( C326 . B166 ) )))));
let C334 , C335 , C336 being (object of C324);
assume that
L569: <^ C334 , C335 ^> <> ( {} )
and
L570: <^ C335 , C336 ^> <> ( {} );
let C337 being (Morphism of C334 , C335);
let C338 being (Morphism of C335 , C336);
L571: <^ ( C326 . C334 ) , ( C326 . C335 ) ^> <> ( {} ) by L569 , L480;
reconsider D82 = ( ( Morph-Map (C326 , C334 , C335) ) . C337 ) as (Morphism of ( C326 . C334 ) , ( C326 . C335 )) by L571 , L569 , FUNCT_2:5;
L572: <^ ( C326 . C335 ) , ( C326 . C336 ) ^> <> ( {} ) by L570 , L480;
reconsider D83 = ( ( Morph-Map (C326 , C335 , C336) ) . C338 ) as (Morphism of ( C326 . C335 ) , ( C326 . C336 )) by L572 , L570 , FUNCT_2:5;
take D82;
take D83;
thus L573: (D82 = ( ( Morph-Map (C326 , C334 , C335) ) . C337 ) & D83 = ( ( Morph-Map (C326 , C335 , C336) ) . C338 ));
L574: D82 = ( C326 . C337 ) by L569 , L571 , L414;
L575: D83 = ( C326 . C338 ) by L570 , L572 , L414;
L576: <^ C334 , C336 ^> <> ( {} ) by L569 , L570 , ALTCAT_1:def 2;
L577: <^ ( C326 . C334 ) , ( C326 . C336 ) ^> <> ( {} ) by L576 , L480;
thus L578: ( ( Morph-Map (C326 , C334 , C336) ) . ( C338 * C337 ) ) = ( C326 . ( C338 * C337 ) ) by L577 , L576 , L414
.= ( D83 * D82 ) by L568 , L569 , L570 , L574 , L575;
end;
end;
definition
let C339 being non  empty  transitive AltCatStr;
let C340 being non  empty  reflexive AltCatStr;
let C341 being  Contravariant  feasible FunctorStr over C339 , C340;
redefine attr C341 is  comp-reversing
means
(for B168 , B169 , B170 being (object of C339) holds ((<^ B168 , B169 ^> <> ( {} ) & <^ B169 , B170 ^> <> ( {} )) implies (for B171 being (Morphism of B168 , B169) holds (for B172 being (Morphism of B169 , B170) holds ( C341 . ( B172 * B171 ) ) = ( ( C341 . B171 ) * ( C341 . B172 ) )))));
compatibility
proof
thus L580:now
assume L581: C341 is  comp-reversing;
let C342 , C343 , C344 being (object of C339);
assume that
L582: <^ C342 , C343 ^> <> ( {} )
and
L583: <^ C343 , C344 ^> <> ( {} );
let C345 being (Morphism of C342 , C343);
let C346 being (Morphism of C343 , C344);
consider C347 being (Morphism of ( C341 . C343 ) , ( C341 . C342 )), C348 being (Morphism of ( C341 . C344 ) , ( C341 . C343 )) such that L584: C347 = ( ( Morph-Map (C341 , C342 , C343) ) . C345 ) and L585: C348 = ( ( Morph-Map (C341 , C343 , C344) ) . C346 ) and L586: ( ( Morph-Map (C341 , C342 , C344) ) . ( C346 * C345 ) ) = ( C347 * C348 ) by L581 , L582 , L583 , L552;
L587: <^ ( C341 . C343 ) , ( C341 . C342 ) ^> <> ( {} ) by L582 , L501;
L588: <^ ( C341 . C344 ) , ( C341 . C343 ) ^> <> ( {} ) by L583 , L501;
L589: C347 = ( C341 . C345 ) by L582 , L584 , L587 , L439;
L590: C348 = ( C341 . C346 ) by L583 , L585 , L588 , L439;
L591: <^ C342 , C344 ^> <> ( {} ) by L582 , L583 , ALTCAT_1:def 2;
L592: <^ ( C341 . C344 ) , ( C341 . C342 ) ^> <> ( {} ) by L591 , L501;
thus L593: ( C341 . ( C346 * C345 ) ) = ( ( C341 . C345 ) * ( C341 . C346 ) ) by L592 , L586 , L589 , L590 , L591 , L439;
end;
assume L594: (for B173 , B174 , B175 being (object of C339) holds ((<^ B173 , B174 ^> <> ( {} ) & <^ B174 , B175 ^> <> ( {} )) implies (for B176 being (Morphism of B173 , B174) holds (for B177 being (Morphism of B174 , B175) holds ( C341 . ( B177 * B176 ) ) = ( ( C341 . B176 ) * ( C341 . B177 ) )))));
let C349 , C350 , C351 being (object of C339);
assume that
L595: <^ C349 , C350 ^> <> ( {} )
and
L596: <^ C350 , C351 ^> <> ( {} );
let C352 being (Morphism of C349 , C350);
let C353 being (Morphism of C350 , C351);
L597: <^ ( C341 . C350 ) , ( C341 . C349 ) ^> <> ( {} ) by L595 , L501;
reconsider D84 = ( ( Morph-Map (C341 , C349 , C350) ) . C352 ) as (Morphism of ( C341 . C350 ) , ( C341 . C349 )) by L597 , L595 , FUNCT_2:5;
L598: <^ ( C341 . C351 ) , ( C341 . C350 ) ^> <> ( {} ) by L596 , L501;
reconsider D85 = ( ( Morph-Map (C341 , C350 , C351) ) . C353 ) as (Morphism of ( C341 . C351 ) , ( C341 . C350 )) by L598 , L596 , FUNCT_2:5;
take D84;
take D85;
thus L599: (D84 = ( ( Morph-Map (C341 , C349 , C350) ) . C352 ) & D85 = ( ( Morph-Map (C341 , C350 , C351) ) . C353 ));
L600: D84 = ( C341 . C352 ) by L595 , L597 , L439;
L601: D85 = ( C341 . C353 ) by L596 , L598 , L439;
L602: <^ C349 , C351 ^> <> ( {} ) by L595 , L596 , ALTCAT_1:def 2;
L603: <^ ( C341 . C351 ) , ( C341 . C349 ) ^> <> ( {} ) by L602 , L501;
thus L604: ( ( Morph-Map (C341 , C349 , C351) ) . ( C353 * C352 ) ) = ( C341 . ( C353 * C352 ) ) by L603 , L602 , L439
.= ( D84 * D85 ) by L594 , L595 , L596 , L600 , L601;
end;
end;
theorem
L606: (for B178 being non  empty AltGraph holds (for B179 being non  empty  reflexive AltGraph holds (for B180 being (object of B179) holds (for B181 being (Morphism of B180 , B180) holds (for B182 being  Covariant  feasible FunctorStr over B178 , B179 holds (B182 = ( B178 --> B181 ) implies (for B183 , B184 being (object of B178) holds (for B185 being (Morphism of B183 , B184) holds (<^ B183 , B184 ^> <> ( {} ) implies ( B182 . B185 ) = B181)))))))))
proof
let C354 being non  empty AltGraph;
let C355 being non  empty  reflexive AltGraph;
let C356 being (object of C355);
L607: <^ C356 , C356 ^> <> ( {} ) by ALTCAT_2:def 7;
let C357 being (Morphism of C356 , C356);
let C358 being  Covariant  feasible FunctorStr over C354 , C355;
assume that
L608: C358 = ( C354 --> C357 );
let C359 , C360 being (object of C354);
let C361 being (Morphism of C359 , C360);
assume L609: <^ C359 , C360 ^> <> ( {} );
L610: <^ ( C358 . C359 ) , ( C358 . C360 ) ^> <> ( {} ) by L609 , L480;
thus L611: ( C358 . C361 ) = ( ( Morph-Map (C358 , C359 , C360) ) . C361 ) by L610 , L609 , L414
.= C357 by L607 , L608 , L609 , L517;
end;
theorem
L612: (for B186 being non  empty AltGraph holds (for B187 being non  empty  reflexive AltGraph holds (for B188 being (object of B187) holds (for B189 being (Morphism of B188 , B188) holds (for B190 , B191 being (object of B186) holds (for B192 being (Morphism of B190 , B191) holds (<^ B190 , B191 ^> <> ( {} ) implies ( ( B186 --> B189 ) . B192 ) = B189)))))))
proof
let C362 being non  empty AltGraph;
let C363 being non  empty  reflexive AltGraph;
let C364 being (object of C363);
L613: <^ C364 , C364 ^> <> ( {} ) by ALTCAT_2:def 7;
let C365 being (Morphism of C364 , C364);
set D86 = ( C362 --> C365 );
let C366 , C367 being (object of C362);
let C368 being (Morphism of C366 , C367);
assume L614: <^ C366 , C367 ^> <> ( {} );
L615: <^ ( D86 . C367 ) , ( D86 . C366 ) ^> <> ( {} ) by L614 , L501;
thus L616: ( D86 . C368 ) = ( ( Morph-Map (D86 , C366 , C367) ) . C368 ) by L615 , L614 , L439
.= C365 by L613 , L614 , L517;
end;
registration
let C369 being non  empty  transitive AltCatStr;
let C370 being  with_units non  empty AltCatStr;
let C371 being (object of C370);
cluster ( C369 --> ( idm C371 ) ) ->  comp-preserving  comp-reversing;
coherence
proof
set D87 = ( C369 --> ( idm C371 ) );
reconsider D88 = D87 as  Covariant  feasible FunctorStr over C369 , C370;
L617: <^ C371 , C371 ^> <> ( {} ) by ALTCAT_2:def 7;
L618: D88 is  comp-preserving
proof
let C372 , C373 , C374 being (object of C369);
assume that
L619: <^ C372 , C373 ^> <> ( {} )
and
L620: <^ C373 , C374 ^> <> ( {} );
L621: <^ C372 , C374 ^> <> ( {} ) by L619 , L620 , ALTCAT_1:def 2;
let C375 being (Morphism of C372 , C373);
let C376 being (Morphism of C373 , C374);
L622: ( D88 . C376 ) = ( idm C371 ) by L620 , L606;
L623: ( D88 . C375 ) = ( idm C371 ) by L619 , L606;
L624: ( D88 . C372 ) = C371 by L617 , L460;
L625: ( D88 . C373 ) = C371 by L617 , L460;
L626: ( D88 . C374 ) = C371 by L617 , L460;
thus L627: ( D88 . ( C376 * C375 ) ) = ( idm C371 ) by L621 , L606
.= ( ( D88 . C376 ) * ( D88 . C375 ) ) by L617 , L622 , L623 , L624 , L625 , L626 , ALTCAT_1:20;
end;
thus L628: D87 is  comp-preserving by L618;
let C377 , C378 , C379 being (object of C369);
assume that
L629: <^ C377 , C378 ^> <> ( {} )
and
L630: <^ C378 , C379 ^> <> ( {} );
L631: <^ C377 , C379 ^> <> ( {} ) by L629 , L630 , ALTCAT_1:def 2;
let C380 being (Morphism of C377 , C378);
let C381 being (Morphism of C378 , C379);
L632: ( D87 . C381 ) = ( idm C371 ) by L630 , L612;
L633: ( D87 . C380 ) = ( idm C371 ) by L629 , L612;
L634: ( D87 . C377 ) = C371 by L617 , L460;
L635: ( D87 . C378 ) = C371 by L617 , L460;
L636: ( D87 . C379 ) = C371 by L617 , L460;
thus L637: ( D87 . ( C381 * C380 ) ) = ( idm C371 ) by L631 , L612
.= ( ( D87 . C380 ) * ( D87 . C381 ) ) by L617 , L632 , L633 , L634 , L635 , L636 , ALTCAT_1:20;
end;
end;
definition
let C382 being  transitive  with_units non  empty AltCatStr;
let C383 being  with_units non  empty AltCatStr;
mode Functor of C382 , C383
 -> FunctorStr over C382 , C383
means :L639: (it is  feasible  id-preserving & (it is  Covariant  comp-preserving or it is  Contravariant  comp-reversing));
existence
proof
set D89 = the (object of C383);
take ( C382 --> ( idm D89 ) );
thus L640: thesis;
end;
end;
definition
let C384 being  transitive  with_units non  empty AltCatStr;
let C385 being  with_units non  empty AltCatStr;
let C386 being (Functor of C384 , C385);
attr C386 is  covariant
means
:L642: C386 is  Covariant  comp-preserving;
attr C386 is  contravariant
means
:L643: C386 is  Contravariant  comp-reversing;
end;
definition
let C387 being AltCatStr;
let C388 being (SubCatStr of C387);
func incl C388 ->  strict FunctorStr over C388 , C387 means 
:L645: ((the ObjectMap of it) = ( id [: (the carrier of C388) , (the carrier of C388) :] ) & (the MorphMap of it) = ( id (the Arrows of C388) ));
existence
proof
L646: (the carrier of C388) c= (the carrier of C387) by ALTCAT_2:def 11;
reconsider D90 = [: (the carrier of C388) , (the carrier of C388) :] as (Subset of [: (the carrier of C387) , (the carrier of C387) :]) by L646 , ZFMISC_1:96;
set D91 = ( id [: (the carrier of C388) , (the carrier of C388) :] );
L647: D91 = ( incl D90 );
reconsider D92 = D91 as (bifunction of (the carrier of C388) , (the carrier of C387)) by L647;
set D93 = ( id (the Arrows of C388) );
L648: D93 is (MSUnTrans of D92 , (the Arrows of C388) , (the Arrows of C387))
proof
per cases ;
case L649: [: (the carrier of C387) , (the carrier of C387) :] <> ( {} );
reconsider D94 = [: (the carrier of C387) , (the carrier of C387) :] as non  empty set by L649;
reconsider D95 = (the Arrows of C387) as (ManySortedSet of D94);
reconsider D96 = D92 as (Function of [: (the carrier of C388) , (the carrier of C388) :] , D94);
take D94;
take D95;
take D96;
thus L650: (D92 = D96 & (the Arrows of C387) = D95);
thus L651: D93 is (ManySortedFunction of (the Arrows of C388) , ( D95 * D96 ))
proof
let C389 being set;
assume L652: C389 in [: (the carrier of C388) , (the carrier of C388) :];
L653: ( D93 . C389 ) is (Function of ( (the Arrows of C388) . C389 ) , ( (the Arrows of C388) . C389 )) by L652 , PBOOLE:def 15;
L654: (the Arrows of C388) cc= (the Arrows of C387) by ALTCAT_2:def 11;
L655: ( ( D95 * D96 ) . C389 ) = ( D95 . ( D96 . C389 ) ) by L652 , FUNCT_2:15
.= ( (the Arrows of C387) . C389 ) by L652 , FUNCT_1:18;
L656: ( (the Arrows of C388) . C389 ) c= ( ( D95 * D96 ) . C389 ) by L655 , L652 , L654 , ALTCAT_2:def 2;
thus L657: thesis by L656 , L653 , FUNCT_2:7;
end;

end;
case L652: [: (the carrier of C387) , (the carrier of C387) :] = ( {} );
L653: D90 = ( {} ) by L652;
thus L654: thesis by L653;
end;
end;
reconsider D97 = D93 as (MSUnTrans of D92 , (the Arrows of C388) , (the Arrows of C387)) by L648;
take FunctorStr (# D92 , D97 #);
thus L656: thesis;
end;
correctness;
end;
definition
let C390 being AltGraph;
func id C390 ->  strict FunctorStr over C390 , C390 means 
:L658: ((the ObjectMap of it) = ( id [: (the carrier of C390) , (the carrier of C390) :] ) & (the MorphMap of it) = ( id (the Arrows of C390) ));
existence
proof
reconsider D98 = ( id [: (the carrier of C390) , (the carrier of C390) :] ) as (bifunction of (the carrier of C390) , (the carrier of C390));
set D99 = ( id (the Arrows of C390) );
L659: D99 is (MSUnTrans of D98 , (the Arrows of C390) , (the Arrows of C390))
proof
per cases ;
case L660: [: (the carrier of C390) , (the carrier of C390) :] <> ( {} );
reconsider D100 = [: (the carrier of C390) , (the carrier of C390) :] as non  empty set by L660;
reconsider D101 = (the Arrows of C390) as (ManySortedSet of D100);
reconsider D102 = D98 as (Function of [: (the carrier of C390) , (the carrier of C390) :] , D100);
take D100;
take D101;
take D102;
thus L661: (D98 = D102 & (the Arrows of C390) = D101);
thus L662: D99 is (ManySortedFunction of (the Arrows of C390) , ( D101 * D102 ))
proof
let C391 being set;
assume L663: C391 in [: (the carrier of C390) , (the carrier of C390) :];
L664: ( ( D101 * D102 ) . C391 ) = ( D101 . ( D102 . C391 ) ) by L663 , FUNCT_2:15
.= ( (the Arrows of C390) . C391 ) by L663 , FUNCT_1:18;
thus L665: thesis by L664 , L663 , PBOOLE:def 15;
end;

end;
case L663: [: (the carrier of C390) , (the carrier of C390) :] = ( {} );
thus L664: thesis by L663;
end;
end;
reconsider D103 = D99 as (MSUnTrans of D98 , (the Arrows of C390) , (the Arrows of C390)) by L659;
take FunctorStr (# D98 , D103 #);
thus L666: thesis;
end;
correctness;
end;
registration
let C392 being AltCatStr;
let C393 being (SubCatStr of C392);
cluster ( incl C393 ) ->  Covariant;
coherence
proof
reconsider D104 = (the carrier of C393) as (Subset of C392) by ALTCAT_2:def 11;
L668: ( incl D104 ) = ( id D104 );
reconsider D105 = ( id (the carrier of C393) ) as (Function of (the carrier of C393) , (the carrier of C392)) by L668;
take D105;
thus L669: (the ObjectMap of ( incl C393 )) = ( id [: (the carrier of C393) , (the carrier of C393) :] ) by L645
.= [: D105 , D105 :] by FUNCT_3:69;
end;
end;
theorem
L671: (for B193 being non  empty AltCatStr holds (for B194 being non  empty (SubCatStr of B193) holds (for B195 being (object of B194) holds ( ( incl B194 ) . B195 ) = B195)))
proof
let C394 being non  empty AltCatStr;
let C395 being non  empty (SubCatStr of C394);
let C396 being (object of C395);
L672: [ C396 , C396 ] in [: (the carrier of C395) , (the carrier of C395) :] by ZFMISC_1:87;
thus L673: ( ( incl C395 ) . C396 ) = ( ( ( id [: (the carrier of C395) , (the carrier of C395) :] ) . [ C396 , C396 ] ) `1 ) by L645
.= ( [ C396 , C396 ] `1 ) by L672 , FUNCT_1:18
.= C396;
end;
theorem
L674: (for B196 being non  empty AltCatStr holds (for B197 being non  empty (SubCatStr of B196) holds (for B198 , B199 being (object of B197) holds <^ B198 , B199 ^> c= <^ ( ( incl B197 ) . B198 ) , ( ( incl B197 ) . B199 ) ^>)))
proof
let C397 being non  empty AltCatStr;
let C398 being non  empty (SubCatStr of C397);
let C399 , C400 being (object of C398);
L675: [ C399 , C400 ] in [: (the carrier of C398) , (the carrier of C398) :] by ZFMISC_1:87;
L676: <^ C399 , C400 ^> = ( (the Arrows of C398) . (C399 , C400) ) by ALTCAT_1:def 1
.= ( (the Arrows of C398) . [ C399 , C400 ] );
L677: ( ( incl C398 ) . C399 ) = C399 by L671;
L678: ( ( incl C398 ) . C400 ) = C400 by L671;
L679: <^ ( ( incl C398 ) . C399 ) , ( ( incl C398 ) . C400 ) ^> = ( (the Arrows of C397) . (C399 , C400) ) by L678 , L677 , ALTCAT_1:def 1
.= ( (the Arrows of C397) . [ C399 , C400 ] );
L680: (the Arrows of C398) cc= (the Arrows of C397) by ALTCAT_2:def 11;
thus L681: thesis by L680 , L675 , L676 , L679 , ALTCAT_2:def 2;
end;
registration
let C401 being non  empty AltCatStr;
let C402 being non  empty (SubCatStr of C401);
cluster ( incl C402 ) ->  feasible;
coherence
proof
let C403 , C404 being (object of C402);
thus L682: thesis by L674 , XBOOLE_1:3;
end;
end;
definition
let C405 , C406 being AltGraph;
let C407 being FunctorStr over C405 , C406;
attr C407 is  faithful
means
:L684: (the MorphMap of C407) is  "1-1";
end;
definition
let C408 , C409 being AltGraph;
let C410 being FunctorStr over C408 , C409;
attr C410 is  full
means
:L686: (ex B200 being (ManySortedSet of [: (the carrier of C408) , (the carrier of C408) :]) st (ex B201 being (ManySortedFunction of (the Arrows of C408) , B200) st (B200 = ( (the Arrows of C409) * (the ObjectMap of C410) ) & B201 = (the MorphMap of C410) & B201 is  "onto")));
end;
definition
let C411 being AltGraph;
let C412 being non  empty AltGraph;
let C413 being FunctorStr over C411 , C412;
redefine attr C413 is  full
means
:L688: (ex B202 being (ManySortedFunction of (the Arrows of C411) , ( (the Arrows of C412) * (the ObjectMap of C413) )) st (B202 = (the MorphMap of C413) & B202 is  "onto"));
compatibility
proof
thus L689:now
assume L690: C413 is  full;
consider C414 being (ManySortedSet of [: (the carrier of C411) , (the carrier of C411) :]), C415 being (ManySortedFunction of (the Arrows of C411) , C414) such that L691: C414 = ( (the Arrows of C412) * (the ObjectMap of C413) ) and L692: C415 = (the MorphMap of C413) and L693: C415 is  "onto" by L690 , L686;
reconsider D106 = C415 as (ManySortedFunction of (the Arrows of C411) , ( (the Arrows of C412) * (the ObjectMap of C413) )) by L691;
take D107 = D106;
thus L694: D107 = (the MorphMap of C413) by L692;
thus L695: D107 is  "onto" by L691 , L693;
end;
given C416 being (ManySortedFunction of (the Arrows of C411) , ( (the Arrows of C412) * (the ObjectMap of C413) )) such that
L696: C416 = (the MorphMap of C413)
and
L697: C416 is  "onto";

take ( (the Arrows of C412) * (the ObjectMap of C413) );
thus L698: thesis by L696 , L697;
end;
end;
definition
let C417 , C418 being AltGraph;
let C419 being FunctorStr over C417 , C418;
attr C419 is  injective
means
:L700: C419 is  one-to-one  faithful;
attr C419 is  surjective
means
:L701: C419 is  full  onto;
end;
definition
let C420 , C421 being AltGraph;
let C422 being FunctorStr over C420 , C421;
attr C422 is  bijective
means
:L703: C422 is  injective  surjective;
end;
registration
let C423 , C424 being  transitive  with_units non  empty AltCatStr;
cluster  strict  covariant  contravariant  feasible for (Functor of C423 , C424);
existence
proof
set D108 = the (object of C424);
reconsider D109 = ( C423 --> ( idm D108 ) ) as (Functor of C423 , C424) by L639;
take D109;
thus L705: thesis by L642 , L643;
end;
end;
theorem
L707: (for B203 being non  empty AltGraph holds (for B204 being (object of B203) holds ( ( id B203 ) . B204 ) = B204))
proof
let C425 being non  empty AltGraph;
let C426 being (object of C425);
L708: [ C426 , C426 ] in [: (the carrier of C425) , (the carrier of C425) :] by ZFMISC_1:87;
thus L709: ( ( id C425 ) . C426 ) = ( ( ( id [: (the carrier of C425) , (the carrier of C425) :] ) . [ C426 , C426 ] ) `1 ) by L658
.= ( [ C426 , C426 ] `1 ) by L708 , FUNCT_1:18
.= C426;
end;
theorem
L710: (for B205 being non  empty AltGraph holds (for B206 , B207 being (object of B205) holds (<^ B206 , B207 ^> <> ( {} ) implies (for B208 being (Morphism of B206 , B207) holds ( ( Morph-Map (( id B205 ) , B206 , B207) ) . B208 ) = B208))))
proof
let C427 being non  empty AltGraph;
let C428 , C429 being (object of C427);
assume that
L711: <^ C428 , C429 ^> <> ( {} );
let C430 being (Morphism of C428 , C429);
L712: [ C428 , C429 ] in [: (the carrier of C427) , (the carrier of C427) :] by ZFMISC_1:87;
L713: ( Morph-Map (( id C427 ) , C428 , C429) ) = ( ( id (the Arrows of C427) ) . [ C428 , C429 ] ) by L658;
thus L714: ( ( Morph-Map (( id C427 ) , C428 , C429) ) . C430 ) = ( ( id ( (the Arrows of C427) . (C428 , C429) ) ) . C430 ) by L713 , L712 , MSUALG_3:def 1
.= ( ( id <^ C428 , C429 ^> ) . C430 ) by ALTCAT_1:def 1
.= C430 by L711 , FUNCT_1:18;
end;
registration
let C431 being non  empty AltGraph;
cluster ( id C431 ) ->  feasible  Covariant;
coherence
proof
thus L715: ( id C431 ) is  feasible
proof
let C432 , C433 being (object of C431);
L716: [ C432 , C433 ] in [: (the carrier of C431) , (the carrier of C431) :] by ZFMISC_1:87;
L717: ( (the ObjectMap of ( id C431 )) . (C432 , C433) ) = ( ( id [: (the carrier of C431) , (the carrier of C431) :] ) . [ C432 , C433 ] ) by L658
.= [ C432 , C433 ] by L716 , FUNCT_1:18;
L718: ( (the Arrows of C431) . ( (the ObjectMap of ( id C431 )) . (C432 , C433) ) ) = ( (the Arrows of C431) . (C432 , C433) ) by L717
.= <^ C432 , C433 ^> by ALTCAT_1:def 1;
thus L719: thesis by L718;
end;

thus L720: ( id C431 ) is  Covariant
proof
take D110 = ( id (the carrier of C431) );
thus L721: (the ObjectMap of ( id C431 )) = ( id [: (the carrier of C431) , (the carrier of C431) :] ) by L658
.= [: D110 , D110 :] by FUNCT_3:69;
end;

end;
end;
registration
let C434 being non  empty AltGraph;
cluster  Covariant  feasible for FunctorStr over C434 , C434;
existence
proof
take ( id C434 );
thus L722: thesis;
end;
end;
theorem
L724: (for B209 being non  empty AltGraph holds (for B210 , B211 being (object of B209) holds (<^ B210 , B211 ^> <> ( {} ) implies (for B212 being  Covariant  feasible FunctorStr over B209 , B209 holds (B212 = ( id B209 ) implies (for B213 being (Morphism of B210 , B211) holds ( B212 . B213 ) = B213))))))
proof
let C435 being non  empty AltGraph;
let C436 , C437 being (object of C435);
assume that
L725: <^ C436 , C437 ^> <> ( {} );
let C438 being  Covariant  feasible FunctorStr over C435 , C435;
assume that
L726: C438 = ( id C435 );
let C439 being (Morphism of C436 , C437);
L727: <^ ( C438 . C436 ) , ( C438 . C437 ) ^> <> ( {} ) by L725 , L480;
thus L728: ( C438 . C439 ) = ( ( Morph-Map (C438 , C436 , C437) ) . C439 ) by L727 , L725 , L414
.= C439 by L725 , L726 , L710;
end;
registration
let C440 being  transitive  with_units non  empty AltCatStr;
cluster ( id C440 ) ->  id-preserving  comp-preserving;
coherence
proof
thus L729: ( id C440 ) is  id-preserving
proof
let C441 being (object of C440);
L730: <^ C441 , C441 ^> <> ( {} ) by ALTCAT_2:def 7;
thus L731: ( ( Morph-Map (( id C440 ) , C441 , C441) ) . ( idm C441 ) ) = ( idm C441 ) by L730 , L710
.= ( idm ( ( id C440 ) . C441 ) ) by L707;
end;

set D111 = ( id C440 );
L732: D111 is  comp-preserving
proof
let C442 , C443 , C444 being (object of C440);
assume that
L733: <^ C442 , C443 ^> <> ( {} )
and
L734: <^ C443 , C444 ^> <> ( {} );
let C445 being (Morphism of C442 , C443);
let C446 being (Morphism of C443 , C444);
L735: <^ C442 , C444 ^> <> ( {} ) by L733 , L734 , ALTCAT_1:def 2;
L736: ( D111 . C442 ) = C442 by L707;
L737: ( D111 . C443 ) = C443 by L707;
L738: ( D111 . C444 ) = C444 by L707;
L739: ( D111 . C446 ) = C446 by L734 , L724;
L740: ( D111 . C445 ) = C445 by L733 , L724;
thus L741: thesis by L740 , L735 , L736 , L737 , L738 , L739 , L724;
end;
thus L742: thesis by L732;
end;
end;
definition
let C447 being  transitive  with_units non  empty AltCatStr;
redefine func id C447 ->  strict  covariant (Functor of C447 , C447);

coherence by L639 , L642;
end;
registration
let C448 being AltGraph;
cluster ( id C448 ) ->  bijective;
coherence
proof
set D112 = [: (the carrier of C448) , (the carrier of C448) :];
L745: (the ObjectMap of ( id C448 )) = ( id D112 ) by L658;
thus L746: ( id C448 ) is  one-to-one by L745 , L355;
thus L747: ( id C448 ) is  faithful
proof
per cases ;
suppose L748: (the carrier of C448) <> ( {} );

let C449 being set;
let C450 being Function;
assume that
L749: C449 in ( dom (the MorphMap of ( id C448 )) )
and
L750: ( (the MorphMap of ( id C448 )) . C449 ) = C450;
consider C451 , C452 being (Element of C448) such that L751: C449 = [ C451 , C452 ] by L748 , L749 , DOMAIN_1:1;
reconsider D113 = C451 , D114 = C452 as (object of C448);
L752: [ D113 , D114 ] in [: (the carrier of C448) , (the carrier of C448) :] by L748 , ZFMISC_1:87;
L753: C450 = ( ( id (the Arrows of C448) ) . (D113 , D114) ) by L750 , L751 , L658
.= ( id ( (the Arrows of C448) . [ D113 , D114 ] ) ) by L752 , MSUALG_3:def 1;
thus L754: thesis by L753;
end;
suppose L755: (the carrier of C448) = ( {} );

let C453 being set;
let C454 being Function;
assume that
L756: C453 in ( dom (the MorphMap of ( id C448 )) )
and
L757: ( (the MorphMap of ( id C448 )) . C453 ) = C454;
L758: ( dom (the MorphMap of ( id C448 )) ) = [: (the carrier of C448) , (the carrier of C448) :] by PARTFUN1:def 2
.= ( {} ) by L755 , ZFMISC_1:90;
thus L759: thesis by L758 , L756;
end;
end;

thus L761: ( id C448 ) is  full
proof
per cases ;
suppose L762: C448 is non  empty;

reconsider D115 = C448 as non  empty AltGraph by L762;
L763: ( id D115 ) is  full
proof
reconsider D116 = (the MorphMap of ( id D115 )) as (ManySortedFunction of (the Arrows of D115) , ( (the Arrows of D115) * (the ObjectMap of ( id D115 )) )) by L303;
take D116;
thus L764: D116 = (the MorphMap of ( id D115 ));
let C455 being set;
assume L765: C455 in [: (the carrier of D115) , (the carrier of D115) :];
consider C456 , C457 being (Element of D115) such that L766: C455 = [ C456 , C457 ] by L765 , DOMAIN_1:1;
reconsider D117 = C456 , D118 = C457 as (object of D115);
L767: [ D117 , D118 ] in [: (the carrier of D115) , (the carrier of D115) :] by ZFMISC_1:87;
L768: ( dom (the ObjectMap of ( id D115 )) ) = D112 by L745 , RELAT_1:45;
L769: ( D116 . C455 ) = ( ( id (the Arrows of D115) ) . (D117 , D118) ) by L766 , L658
.= ( id ( (the Arrows of D115) . [ D117 , D118 ] ) ) by L767 , MSUALG_3:def 1;
thus L770: ( rng ( D116 . C455 ) ) = ( (the Arrows of D115) . [ D117 , D118 ] ) by L769 , RELAT_1:45
.= ( (the Arrows of D115) . ( (the ObjectMap of ( id D115 )) . C455 ) ) by L745 , L765 , L766 , FUNCT_1:18
.= ( ( (the Arrows of D115) * (the ObjectMap of ( id D115 )) ) . C455 ) by L765 , L768 , FUNCT_1:13;
end;
thus L771: thesis by L763;
end;
suppose L772: C448 is  empty;

L773: (the carrier of C448) = ( {} ) by L772;
L774: (the ObjectMap of ( id C448 )) = ( id [: (the carrier of C448) , (the carrier of C448) :] ) by L658;
reconsider D119 = ( (the Arrows of C448) * (the ObjectMap of ( id C448 )) ) as (ManySortedSet of [: (the carrier of C448) , (the carrier of C448) :]) by L774 , L25;
reconsider D120 = (the MorphMap of ( id C448 )) as (ManySortedSet of [: (the carrier of C448) , (the carrier of C448) :]);
L775: D120 is (ManySortedFunction of (the Arrows of C448) , D119)
proof
let C458 being set;
thus L776: thesis by L773 , ZFMISC_1:90;
end;
reconsider D121 = D120 as (ManySortedFunction of (the Arrows of C448) , D119) by L775;
take D119;
take D121;
thus L777: (D119 = ( (the Arrows of C448) * (the ObjectMap of ( id C448 )) ) & D121 = (the MorphMap of ( id C448 )));
let C459 being set;
thus L778: thesis by L773 , ZFMISC_1:90;
end;
end;

L780: ( rng ( id D112 ) ) = D112;
L781: (the ObjectMap of ( id C448 )) is  onto by L780 , L745 , FUNCT_2:def 3;
thus L782: ( id C448 ) is  onto by L781 , L356;
end;
end;
begin
definition
let C460 being non  empty AltGraph;
let C461 , C462 being non  empty  reflexive AltGraph;
let C463 being  feasible FunctorStr over C460 , C461;
let C464 being FunctorStr over C461 , C462;
func C464 * C463 ->  strict FunctorStr over C460 , C462 means 
:L784: ((the ObjectMap of it) = ( (the ObjectMap of C464) * (the ObjectMap of C463) ) & (the MorphMap of it) = ( ( (the MorphMap of C464) * (the ObjectMap of C463) ) ** (the MorphMap of C463) ));
existence
proof
reconsider D122 = ( (the ObjectMap of C464) * (the ObjectMap of C463) ) as (bifunction of (the carrier of C460) , (the carrier of C462));
set D123 = [: (the carrier of C460) , (the carrier of C460) :];
reconsider D124 = ( (the MorphMap of C464) * (the ObjectMap of C463) ) as (MSUnTrans of D122 , ( (the Arrows of C461) * (the ObjectMap of C463) ) , (the Arrows of C462)) by L318;
L785: (for B214 being set holds ((B214 in D123 & ( ( (the Arrows of C461) * (the ObjectMap of C463) ) . B214 ) = ( {} )) implies (( (the Arrows of C460) . B214 ) = ( {} ) or ( ( (the Arrows of C462) * D122 ) . B214 ) = ( {} ))))
proof
let C465 being set;
assume that
L786: C465 in D123
and
L787: ( ( (the Arrows of C461) * (the ObjectMap of C463) ) . C465 ) = ( {} );
L788: ( dom (the ObjectMap of C463) ) = D123 by FUNCT_2:def 1;
reconsider D125 = ( C465 `1 ) , D126 = ( C465 `2 ) as (object of C460) by L786 , MCART_1:10;
L789: C465 = [ D125 , D126 ] by L786 , MCART_1:21;
L790: ( (the Arrows of C461) . ( (the ObjectMap of C463) . (D125 , D126) ) ) = ( {} ) by L789 , L786 , L787 , L788 , FUNCT_1:13;
L791: ( (the Arrows of C460) . C465 ) = ( (the Arrows of C460) . (D125 , D126) ) by L786 , MCART_1:21
.= <^ D125 , D126 ^> by ALTCAT_1:def 1
.= ( {} ) by L790 , L388;
thus L792: thesis by L791;
end;
reconsider D127 = ( D124 ** (the MorphMap of C463) ) as (MSUnTrans of D122 , (the Arrows of C460) , (the Arrows of C462)) by L785 , L342;
take FunctorStr (# D122 , D127 #);
thus L793: thesis;
end;
correctness;
end;
registration
let C466 being non  empty AltGraph;
let C467 , C468 being non  empty  reflexive AltGraph;
let C469 being  Covariant  feasible FunctorStr over C466 , C467;
let C470 being  Covariant FunctorStr over C467 , C468;
cluster ( C470 * C469 ) ->  Covariant;
correctness
proof
L795: (the ObjectMap of C469) is  Covariant by L391;
consider C471 being (Function of (the carrier of C466) , (the carrier of C467)) such that L796: (the ObjectMap of C469) = [: C471 , C471 :] by L795 , L257;
L797: (the ObjectMap of C470) is  Covariant by L391;
consider C472 being (Function of (the carrier of C467) , (the carrier of C468)) such that L798: (the ObjectMap of C470) = [: C472 , C472 :] by L797 , L257;
take ( C472 * C471 );
thus L799: (the ObjectMap of ( C470 * C469 )) = ( (the ObjectMap of C470) * (the ObjectMap of C469) ) by L784
.= [: ( C472 * C471 ) , ( C472 * C471 ) :] by L796 , L798 , FUNCT_3:71;
end;
end;
registration
let C473 being non  empty AltGraph;
let C474 , C475 being non  empty  reflexive AltGraph;
let C476 being  Contravariant  feasible FunctorStr over C473 , C474;
let C477 being  Covariant FunctorStr over C474 , C475;
cluster ( C477 * C476 ) ->  Contravariant;
correctness
proof
L801: (the ObjectMap of C476) is  Contravariant by L392;
consider C478 being (Function of (the carrier of C473) , (the carrier of C474)) such that L802: (the ObjectMap of C476) = ( ~ [: C478 , C478 :] ) by L801 , L258;
L803: (the ObjectMap of C477) is  Covariant by L391;
consider C479 being (Function of (the carrier of C474) , (the carrier of C475)) such that L804: (the ObjectMap of C477) = [: C479 , C479 :] by L803 , L257;
take ( C479 * C478 );
thus L805: (the ObjectMap of ( C477 * C476 )) = ( (the ObjectMap of C477) * (the ObjectMap of C476) ) by L784
.= ( ~ ( [: C479 , C479 :] * [: C478 , C478 :] ) ) by L802 , L804 , ALTCAT_2:2
.= ( ~ [: ( C479 * C478 ) , ( C479 * C478 ) :] ) by FUNCT_3:71;
end;
end;
registration
let C480 being non  empty AltGraph;
let C481 , C482 being non  empty  reflexive AltGraph;
let C483 being  Covariant  feasible FunctorStr over C480 , C481;
let C484 being  Contravariant FunctorStr over C481 , C482;
cluster ( C484 * C483 ) ->  Contravariant;
correctness
proof
L807: (the ObjectMap of C483) is  Covariant by L391;
consider C485 being (Function of (the carrier of C480) , (the carrier of C481)) such that L808: (the ObjectMap of C483) = [: C485 , C485 :] by L807 , L257;
L809: (the ObjectMap of C484) is  Contravariant by L392;
consider C486 being (Function of (the carrier of C481) , (the carrier of C482)) such that L810: (the ObjectMap of C484) = ( ~ [: C486 , C486 :] ) by L809 , L258;
take ( C486 * C485 );
thus L811: (the ObjectMap of ( C484 * C483 )) = ( (the ObjectMap of C484) * (the ObjectMap of C483) ) by L784
.= ( ~ ( [: C486 , C486 :] * [: C485 , C485 :] ) ) by L808 , L810 , ALTCAT_2:3
.= ( ~ [: ( C486 * C485 ) , ( C486 * C485 ) :] ) by FUNCT_3:71;
end;
end;
registration
let C487 being non  empty AltGraph;
let C488 , C489 being non  empty  reflexive AltGraph;
let C490 being  Contravariant  feasible FunctorStr over C487 , C488;
let C491 being  Contravariant FunctorStr over C488 , C489;
cluster ( C491 * C490 ) ->  Covariant;
correctness
proof
L813: (the ObjectMap of C490) is  Contravariant by L392;
consider C492 being (Function of (the carrier of C487) , (the carrier of C488)) such that L814: (the ObjectMap of C490) = ( ~ [: C492 , C492 :] ) by L813 , L258;
L815: (the ObjectMap of C491) is  Contravariant by L392;
consider C493 being (Function of (the carrier of C488) , (the carrier of C489)) such that L816: (the ObjectMap of C491) = ( ~ [: C493 , C493 :] ) by L815 , L258;
take ( C493 * C492 );
thus L817: (the ObjectMap of ( C491 * C490 )) = ( (the ObjectMap of C491) * (the ObjectMap of C490) ) by L784
.= ( ~ ( ( ~ [: C493 , C493 :] ) * [: C492 , C492 :] ) ) by L814 , L816 , ALTCAT_2:2
.= ( ~ ( ~ ( [: C493 , C493 :] * [: C492 , C492 :] ) ) ) by ALTCAT_2:3
.= ( [: C493 , C493 :] * [: C492 , C492 :] ) by FUNCT_4:53
.= [: ( C493 * C492 ) , ( C493 * C492 ) :] by FUNCT_3:71;
end;
end;
registration
let C494 being non  empty AltGraph;
let C495 , C496 being non  empty  reflexive AltGraph;
let C497 being  feasible FunctorStr over C494 , C495;
let C498 being  feasible FunctorStr over C495 , C496;
cluster ( C498 * C497 ) ->  feasible;
coherence
proof
let C499 , C500 being (object of C494);
assume that
L819: <^ C499 , C500 ^> <> ( {} );
reconsider D128 = ( ( (the ObjectMap of C497) . (C499 , C500) ) `1 ) , D129 = ( ( (the ObjectMap of C497) . (C499 , C500) ) `2 ) as (Element of C495) by MCART_1:10;
reconsider D130 = D128 , D131 = D129 as (object of C495);
L820: [ C499 , C500 ] in [: (the carrier of C494) , (the carrier of C494) :] by ZFMISC_1:87;
L821: [ C499 , C500 ] in ( dom (the ObjectMap of C497) ) by L820 , FUNCT_2:def 1;
L822: ( (the ObjectMap of C497) . (C499 , C500) ) = [ D130 , D131 ] by MCART_1:21;
L823: ( (the ObjectMap of ( C498 * C497 )) . (C499 , C500) ) = ( ( (the ObjectMap of C498) * (the ObjectMap of C497) ) . [ C499 , C500 ] ) by L784
.= ( (the ObjectMap of C498) . (D130 , D131) ) by L821 , L822 , FUNCT_1:13;
L824: <^ D130 , D131 ^> = ( (the Arrows of C495) . (D130 , D131) ) by ALTCAT_1:def 1
.= ( (the Arrows of C495) . ( (the ObjectMap of C497) . (C499 , C500) ) ) by MCART_1:21;
L825: <^ D130 , D131 ^> <> ( {} ) by L824 , L819 , L388;
thus L826: thesis by L825 , L823 , L388;
end;
end;
theorem
L828: (for B215 being non  empty AltGraph holds (for B216 , B217 , B218 being non  empty  reflexive AltGraph holds (for B219 being  feasible FunctorStr over B215 , B216 holds (for B220 being  feasible FunctorStr over B216 , B217 holds (for B221 being FunctorStr over B217 , B218 holds ( ( B221 * B220 ) * B219 ) = ( B221 * ( B220 * B219 ) ))))))
proof
let C501 being non  empty AltGraph;
let C502 , C503 , C504 being non  empty  reflexive AltGraph;
let C505 being  feasible FunctorStr over C501 , C502;
let C506 being  feasible FunctorStr over C502 , C503;
let C507 being FunctorStr over C503 , C504;
L829: (the ObjectMap of ( ( C507 * C506 ) * C505 )) = ( (the ObjectMap of ( C507 * C506 )) * (the ObjectMap of C505) ) by L784
.= ( ( (the ObjectMap of C507) * (the ObjectMap of C506) ) * (the ObjectMap of C505) ) by L784
.= ( (the ObjectMap of C507) * ( (the ObjectMap of C506) * (the ObjectMap of C505) ) ) by RELAT_1:36
.= ( (the ObjectMap of C507) * (the ObjectMap of ( C506 * C505 )) ) by L784
.= (the ObjectMap of ( C507 * ( C506 * C505 ) )) by L784;
L830: (the MorphMap of ( ( C507 * C506 ) * C505 )) = ( ( (the MorphMap of ( C507 * C506 )) * (the ObjectMap of C505) ) ** (the MorphMap of C505) ) by L784
.= ( ( ( ( (the MorphMap of C507) * (the ObjectMap of C506) ) ** (the MorphMap of C506) ) * (the ObjectMap of C505) ) ** (the MorphMap of C505) ) by L784
.= ( ( ( ( (the MorphMap of C507) * (the ObjectMap of C506) ) * (the ObjectMap of C505) ) ** ( (the MorphMap of C506) * (the ObjectMap of C505) ) ) ** (the MorphMap of C505) ) by L223
.= ( ( ( (the MorphMap of C507) * ( (the ObjectMap of C506) * (the ObjectMap of C505) ) ) ** ( (the MorphMap of C506) * (the ObjectMap of C505) ) ) ** (the MorphMap of C505) ) by RELAT_1:36
.= ( ( ( (the MorphMap of C507) * (the ObjectMap of ( C506 * C505 )) ) ** ( (the MorphMap of C506) * (the ObjectMap of C505) ) ) ** (the MorphMap of C505) ) by L784
.= ( ( (the MorphMap of C507) * (the ObjectMap of ( C506 * C505 )) ) ** ( ( (the MorphMap of C506) * (the ObjectMap of C505) ) ** (the MorphMap of C505) ) ) by PBOOLE:140
.= ( ( (the MorphMap of C507) * (the ObjectMap of ( C506 * C505 )) ) ** (the MorphMap of ( C506 * C505 )) ) by L784
.= (the MorphMap of ( C507 * ( C506 * C505 ) )) by L784;
thus L831: thesis by L830 , L829;
end;
theorem
L832: (for B222 being non  empty AltCatStr holds (for B223 , B224 being non  empty  reflexive AltCatStr holds (for B225 being  feasible  reflexive FunctorStr over B222 , B223 holds (for B226 being FunctorStr over B223 , B224 holds (for B227 being (object of B222) holds ( ( B226 * B225 ) . B227 ) = ( B226 . ( B225 . B227 ) ))))))
proof
let C508 being non  empty AltCatStr;
let C509 , C510 being non  empty  reflexive AltCatStr;
let C511 being  feasible  reflexive FunctorStr over C508 , C509;
let C512 being FunctorStr over C509 , C510;
let C513 being (object of C508);
L833: ( dom (the ObjectMap of C511) ) = [: (the carrier of C508) , (the carrier of C508) :] by FUNCT_2:def 1;
L834: [ C513 , C513 ] in ( dom (the ObjectMap of C511) ) by L833 , ZFMISC_1:87;
thus L835: ( ( C512 * C511 ) . C513 ) = ( ( ( (the ObjectMap of C512) * (the ObjectMap of C511) ) . (C513 , C513) ) `1 ) by L784
.= ( ( (the ObjectMap of C512) . ( (the ObjectMap of C511) . [ C513 , C513 ] ) ) `1 ) by L834 , FUNCT_1:13
.= ( C512 . ( C511 . C513 ) ) by L360;
end;
theorem
L836: (for B228 being non  empty AltGraph holds (for B229 , B230 being non  empty  reflexive AltGraph holds (for B231 being  feasible  reflexive FunctorStr over B228 , B229 holds (for B232 being FunctorStr over B229 , B230 holds (for B233 being (object of B228) holds ( Morph-Map (( B232 * B231 ) , B233 , B233) ) = ( ( Morph-Map (B232 , ( B231 . B233 ) , ( B231 . B233 )) ) * ( Morph-Map (B231 , B233 , B233) ) ))))))
proof
let C514 being non  empty AltGraph;
let C515 , C516 being non  empty  reflexive AltGraph;
let C517 being  feasible  reflexive FunctorStr over C514 , C515;
let C518 being FunctorStr over C515 , C516;
let C519 being (object of C514);
L837: ( dom (the MorphMap of C518) ) = [: (the carrier of C515) , (the carrier of C515) :] by PARTFUN1:def 2;
L838: ( rng (the ObjectMap of C517) ) c= [: (the carrier of C515) , (the carrier of C515) :];
L839: ( dom ( (the MorphMap of C518) * (the ObjectMap of C517) ) ) = ( dom (the ObjectMap of C517) ) by L838 , L837 , RELAT_1:27
.= [: (the carrier of C514) , (the carrier of C514) :] by FUNCT_2:def 1;
L840: [ C519 , C519 ] in ( dom ( (the MorphMap of C518) * (the ObjectMap of C517) ) ) by L839 , ZFMISC_1:87;
L841: ( dom (the MorphMap of C517) ) = [: (the carrier of C514) , (the carrier of C514) :] by PARTFUN1:def 2;
L842: [ C519 , C519 ] in ( dom (the MorphMap of C517) ) by L841 , ZFMISC_1:87;
L843: [ C519 , C519 ] in ( ( dom ( (the MorphMap of C518) * (the ObjectMap of C517) ) ) /\ ( dom (the MorphMap of C517) ) ) by L842 , L840 , XBOOLE_0:def 4;
L844: [ C519 , C519 ] in ( dom ( ( (the MorphMap of C518) * (the ObjectMap of C517) ) ** (the MorphMap of C517) ) ) by L843 , PBOOLE:def 19;
L845: ( ( (the MorphMap of C518) * (the ObjectMap of C517) ) . [ C519 , C519 ] ) = ( (the MorphMap of C518) . ( (the ObjectMap of C517) . (C519 , C519) ) ) by L840 , FUNCT_1:12
.= ( Morph-Map (C518 , ( C517 . C519 ) , ( C517 . C519 )) ) by L360;
thus L846: ( Morph-Map (( C518 * C517 ) , C519 , C519) ) = ( ( ( (the MorphMap of C518) * (the ObjectMap of C517) ) ** (the MorphMap of C517) ) . (C519 , C519) ) by L784
.= ( ( Morph-Map (C518 , ( C517 . C519 ) , ( C517 . C519 )) ) * ( Morph-Map (C517 , C519 , C519) ) ) by L844 , L845 , PBOOLE:def 19;
end;
registration
let C520 , C521 , C522 being  with_units non  empty AltCatStr;
let C523 being  id-preserving  feasible  reflexive FunctorStr over C520 , C521;
let C524 being  id-preserving FunctorStr over C521 , C522;
cluster ( C524 * C523 ) ->  id-preserving;
coherence
proof
let C525 being (object of C520);
L847: [ C525 , C525 ] in [: (the carrier of C520) , (the carrier of C520) :] by ZFMISC_1:87;
L848: [ C525 , C525 ] in ( dom (the ObjectMap of C523) ) by L847 , FUNCT_2:def 1;
L849: ( ( (the Arrows of C521) * (the ObjectMap of C523) ) . [ C525 , C525 ] ) = ( (the Arrows of C521) . ( (the ObjectMap of C523) . (C525 , C525) ) ) by L848 , FUNCT_1:13
.= ( (the Arrows of C521) . (( C523 . C525 ) , ( C523 . C525 )) ) by L360
.= <^ ( C523 . C525 ) , ( C523 . C525 ) ^> by ALTCAT_1:def 1;
L850: ( ( (the Arrows of C521) * (the ObjectMap of C523) ) . [ C525 , C525 ] ) <> ( {} ) by L849 , ALTCAT_2:def 7;
L851: (the MorphMap of C523) is (ManySortedFunction of (the Arrows of C520) , ( (the Arrows of C521) * (the ObjectMap of C523) )) by L303;
L852: ( Morph-Map (C523 , C525 , C525) ) is (Function of ( (the Arrows of C520) . [ C525 , C525 ] ) , ( ( (the Arrows of C521) * (the ObjectMap of C523) ) . [ C525 , C525 ] )) by L851 , L847 , PBOOLE:def 15;
L853: ( dom ( Morph-Map (C523 , C525 , C525) ) ) = ( (the Arrows of C520) . (C525 , C525) ) by L852 , L850 , FUNCT_2:def 1
.= <^ C525 , C525 ^> by ALTCAT_1:def 1;
thus L854: ( ( Morph-Map (( C524 * C523 ) , C525 , C525) ) . ( idm C525 ) ) = ( ( ( Morph-Map (C524 , ( C523 . C525 ) , ( C523 . C525 )) ) * ( Morph-Map (C523 , C525 , C525) ) ) . ( idm C525 ) ) by L836
.= ( ( Morph-Map (C524 , ( C523 . C525 ) , ( C523 . C525 )) ) . ( ( Morph-Map (C523 , C525 , C525) ) . ( idm C525 ) ) ) by L853 , ALTCAT_1:19 , FUNCT_1:13
.= ( ( Morph-Map (C524 , ( C523 . C525 ) , ( C523 . C525 )) ) . ( idm ( C523 . C525 ) ) ) by L515
.= ( idm ( C524 . ( C523 . C525 ) ) ) by L515
.= ( idm ( ( C524 * C523 ) . C525 ) ) by L832;
end;
end;
definition
let C526 , C527 being non  empty  reflexive AltCatStr;
let C528 being non  empty (SubCatStr of C526);
let C529 being FunctorStr over C526 , C527;
func C529 | C528 -> FunctorStr over C528 , C527 equals 
( C529 * ( incl C528 ) );
correctness;
end;
begin
definition
let C530 , C531 being non  empty AltGraph;
let C532 being FunctorStr over C530 , C531;
assume L857: C532 is  bijective;
func C532 " ->  strict FunctorStr over C531 , C530 means 
:L858: ((the ObjectMap of it) = ( (the ObjectMap of C532) " ) & (ex B234 being (ManySortedFunction of (the Arrows of C530) , ( (the Arrows of C531) * (the ObjectMap of C532) )) st (B234 = (the MorphMap of C532) & (the MorphMap of it) = ( ( B234 "" ) * ( (the ObjectMap of C532) " ) ))));
existence
proof
set D132 = (the ObjectMap of C532);
L859: C532 is  injective by L857 , L703;
L860: C532 is  one-to-one by L859 , L700;
L861: D132 is  one-to-one by L860 , L355;
L862: C532 is  surjective by L857 , L703;
L863: C532 is  onto by L862 , L701;
L864: D132 is  onto by L863 , L356;
L865: ( rng D132 ) = [: (the carrier of C531) , (the carrier of C531) :] by L864 , FUNCT_2:def 3;
reconsider D133 = ( (the ObjectMap of C532) " ) as (bifunction of (the carrier of C531) , (the carrier of C530)) by L865 , L861 , FUNCT_2:25;
reconsider D134 = (the MorphMap of C532) as (ManySortedFunction of (the Arrows of C530) , ( (the Arrows of C531) * D132 )) by L303;
L866: ( ( (the Arrows of C531) * D132 ) * D133 ) = ( (the Arrows of C531) * ( D132 * D133 ) ) by RELAT_1:36
.= ( (the Arrows of C531) * ( id [: (the carrier of C531) , (the carrier of C531) :] ) ) by L861 , L865 , FUNCT_2:29
.= (the Arrows of C531) by L25;
L867: ( ( D134 "" ) * D133 ) is (ManySortedFunction of (the Arrows of C531) , ( (the Arrows of C530) * D133 )) by L866 , ALTCAT_2:5;
reconsider D135 = ( ( D134 "" ) * D133 ) as (MSUnTrans of D133 , (the Arrows of C531) , (the Arrows of C530)) by L867 , L303;
take D136 = FunctorStr (# D133 , D135 #);
thus L868: (the ObjectMap of D136) = ( D132 " );
take D134;
thus L869: thesis;
end;
uniqueness;
end;
theorem
L871: (for B235 , B236 being  transitive  with_units non  empty AltCatStr holds (for B237 being  feasible FunctorStr over B235 , B236 holds (B237 is  bijective implies ( B237 " ) is  bijective  feasible)))
proof
let C533 , C534 being  transitive  with_units non  empty AltCatStr;
let C535 being  feasible FunctorStr over C533 , C534;
assume that
L872: C535 is  bijective;
set D137 = ( C535 " );
L873: (the ObjectMap of D137) = ( (the ObjectMap of C535) " ) by L872 , L858;
L874: C535 is  injective by L872 , L703;
L875: C535 is  one-to-one by L874 , L700;
L876: (the ObjectMap of C535) is  one-to-one by L875 , L355;
thus L877: (the ObjectMap of D137) is  one-to-one by L876 , L873;
L878: C535 is  faithful by L874 , L700;
L879: (the MorphMap of C535) is  "1-1" by L878 , L684;
L880: C535 is  surjective by L872 , L703;
L881: C535 is  onto by L880 , L701;
L882: (the ObjectMap of C535) is  onto by L881 , L356;
consider C536 being (ManySortedFunction of (the Arrows of C533) , ( (the Arrows of C534) * (the ObjectMap of C535) )) such that L883: C536 = (the MorphMap of C535) and L884: (the MorphMap of D137) = ( ( C536 "" ) * ( (the ObjectMap of C535) " ) ) by L872 , L858;
L885: C535 is  full by L880 , L701;
L886: (ex B238 being (ManySortedFunction of (the Arrows of C533) , ( (the Arrows of C534) * (the ObjectMap of C535) )) st (B238 = (the MorphMap of C535) & B238 is  "onto")) by L885 , L688;
set D138 = [: (the carrier of C533) , (the carrier of C533) :];
set D139 = [: (the carrier of C534) , (the carrier of C534) :];
L887: ( rng (the ObjectMap of C535) ) = D139 by L882 , FUNCT_2:def 3;
reconsider D140 = (the MorphMap of D137) as (ManySortedFunction of (the Arrows of C534) , ( (the Arrows of C533) * (the ObjectMap of D137) )) by L303;
L888: D140 is  "1-1"
proof
let C537 being set;
let C538 being Function;
assume that
L889: C537 in ( dom D140 )
and
L890: ( D140 . C537 ) = C538;
L891: C537 in D139 by L889;
L892: C537 in ( dom ( (the ObjectMap of C535) " ) ) by L891 , L876 , L887 , FUNCT_1:33;
L893: ( ( (the ObjectMap of C535) " ) . C537 ) in ( rng ( (the ObjectMap of C535) " ) ) by L892 , FUNCT_1:def 3;
L894: ( ( (the ObjectMap of C535) " ) . C537 ) in ( dom (the ObjectMap of C535) ) by L893 , L876 , FUNCT_1:33;
L895: ( ( (the ObjectMap of C535) " ) . C537 ) in D138 by L894;
L896: ( ( (the ObjectMap of C535) " ) . C537 ) in ( dom C536 ) by L895 , PARTFUN1:def 2;
L897: ( C536 . ( ( (the ObjectMap of C535) " ) . C537 ) ) is  one-to-one by L896 , L879 , L883 , MSUALG_3:def 2;
L898: C538 = ( ( C536 "" ) . ( ( (the ObjectMap of C535) " ) . C537 ) ) by L884 , L890 , L892 , FUNCT_1:13
.= ( ( C536 . ( ( (the ObjectMap of C535) " ) . C537 ) ) " ) by L879 , L883 , L886 , L894 , MSUALG_3:def 4;
thus L899: thesis by L898 , L897;
end;
thus L900: (the MorphMap of D137) is  "1-1" by L888;
thus L901: D137 is  full
proof
take D140;
thus L902: D140 = (the MorphMap of D137);
let C539 being set;
assume L903: C539 in D139;
L904: C539 in ( dom (the ObjectMap of D137) ) by L903 , FUNCT_2:def 1;
L905: C539 in ( dom ( (the ObjectMap of C535) " ) ) by L876 , L887 , L903 , FUNCT_1:33;
L906: ( ( (the ObjectMap of C535) " ) . C539 ) in ( rng ( (the ObjectMap of C535) " ) ) by L905 , FUNCT_1:def 3;
L907: ( ( (the ObjectMap of C535) " ) . C539 ) in ( dom (the ObjectMap of C535) ) by L906 , L876 , FUNCT_1:33;
L908: ( ( (the ObjectMap of C535) " ) . C539 ) in D138 by L907;
L909: ( (the ObjectMap of D137) . C539 ) in ( dom C536 ) by L908 , L873 , PARTFUN1:def 2;
L910: ( C536 . ( (the ObjectMap of D137) . C539 ) ) is  one-to-one by L909 , L879 , L883 , MSUALG_3:def 2;
set D141 = ( (the ObjectMap of D137) . C539 );
L911: ( C536 . D141 ) is (Function of ( (the Arrows of C533) . D141 ) , ( ( (the Arrows of C534) * (the ObjectMap of C535) ) . D141 )) by L873 , L907 , PBOOLE:def 15;
consider C540 , C541 being (Element of C533) such that L912: D141 = [ C540 , C541 ] by L873 , L907 , DOMAIN_1:1;
reconsider D142 = C540 , D143 = C541 as (object of C533);
L913:
now
assume L914: ( (the Arrows of C533) . D141 ) <> ( {} );
L915: ( (the Arrows of C533) . (D142 , D143) ) <> ( {} ) by L914 , L912;
L916: <^ D142 , D143 ^> <> ( {} ) by L915 , ALTCAT_1:def 1;
L917: ( (the Arrows of C534) . ( (the ObjectMap of C535) . (D142 , D143) ) ) <> ( {} ) by L916 , L388;
thus L918: ( ( (the Arrows of C534) * (the ObjectMap of C535) ) . D141 ) <> ( {} ) by L917 , L873 , L907 , L912 , FUNCT_1:13;
end;
L919: ( D140 . C539 ) = ( ( C536 "" ) . ( ( (the ObjectMap of C535) " ) . C539 ) ) by L884 , L905 , FUNCT_1:13
.= ( ( C536 . ( ( (the ObjectMap of C535) " ) . C539 ) ) " ) by L879 , L883 , L886 , L907 , MSUALG_3:def 4;
thus L920: ( rng ( D140 . C539 ) ) = ( dom ( C536 . ( (the ObjectMap of D137) . C539 ) ) ) by L919 , L873 , L910 , FUNCT_1:33
.= ( (the Arrows of C533) . ( (the ObjectMap of D137) . C539 ) ) by L911 , L913 , FUNCT_2:def 1
.= ( ( (the Arrows of C533) * (the ObjectMap of D137) ) . C539 ) by L904 , FUNCT_1:13;
end;

thus L921: ( rng (the ObjectMap of D137) ) = ( dom (the ObjectMap of C535) ) by L873 , L876 , FUNCT_1:33
.= D138 by FUNCT_2:def 1;
let C542 , C543 being (object of C534);
assume L922: <^ C542 , C543 ^> <> ( {} );
L923: ( (the Arrows of C534) . (C542 , C543) ) <> ( {} ) by L922 , ALTCAT_1:def 1;
L924: [ C542 , C543 ] in D139 by ZFMISC_1:87;
consider C544 , C545 being (Element of C533) such that L925: ( (the ObjectMap of D137) . [ C542 , C543 ] ) = [ C544 , C545 ] by L924 , DOMAIN_1:1 , FUNCT_2:5;
reconsider D144 = C544 , D145 = C545 as (object of C533);
L926: [ C542 , C543 ] in ( dom (the ObjectMap of D137) ) by L924 , FUNCT_2:def 1;
L927: ( (the ObjectMap of C535) . (D144 , D145) ) = ( ( (the ObjectMap of C535) * (the ObjectMap of D137) ) . [ C542 , C543 ] ) by L926 , L925 , FUNCT_1:13
.= ( ( id D139 ) . [ C542 , C543 ] ) by L873 , L876 , L887 , FUNCT_1:39
.= [ C542 , C543 ] by L924 , FUNCT_1:18;
assume L928: ( (the Arrows of C533) . ( (the ObjectMap of D137) . (C542 , C543) ) ) = ( {} );
L929: [ D144 , D145 ] in D138 by ZFMISC_1:87;
L930: [ D144 , D145 ] in ( dom (the ObjectMap of C535) ) by L929 , FUNCT_2:def 1;
L931: ( C536 . [ D144 , D145 ] ) is (Function of ( (the Arrows of C533) . [ D144 , D145 ] ) , ( ( (the Arrows of C534) * (the ObjectMap of C535) ) . [ D144 , D145 ] )) by L929 , PBOOLE:def 15;
L932: ( {} ) = ( rng ( C536 . [ D144 , D145 ] ) ) by L931 , L925 , L928
.= ( ( (the Arrows of C534) * (the ObjectMap of C535) ) . [ D144 , D145 ] ) by L883 , L886 , L929 , MSUALG_3:def 3
.= ( (the Arrows of C534) . [ C542 , C543 ] ) by L927 , L930 , FUNCT_1:13;
thus L933: contradiction by L932 , L923;
end;
theorem
L934: (for B239 , B240 being  transitive  with_units non  empty AltCatStr holds (for B241 being  feasible  reflexive FunctorStr over B239 , B240 holds (B241 is  bijective  coreflexive implies ( B241 " ) is  reflexive)))
proof
let C546 , C547 being  transitive  with_units non  empty AltCatStr;
let C548 being  feasible  reflexive FunctorStr over C546 , C547;
assume that
L935: C548 is  bijective
and
L936: C548 is  coreflexive;
set D146 = ( C548 " );
L937: (the ObjectMap of D146) = ( (the ObjectMap of C548) " ) by L935 , L858;
let C549 being (object of C547);
L938: ( dom (the ObjectMap of C548) ) = [: (the carrier of C546) , (the carrier of C546) :] by FUNCT_2:def 1;
consider C550 being (object of C546) such that L939: C549 = ( C548 . C550 ) by L936 , L379;
L940: C548 is  injective by L935 , L703;
L941: C548 is  one-to-one by L940 , L700;
L942: (the ObjectMap of C548) is  one-to-one by L941 , L355;
L943: [ C550 , C550 ] in ( dom (the ObjectMap of C548) ) by L938 , ZFMISC_1:87;
L944: ( D146 . ( C548 . C550 ) ) = ( ( D146 * C548 ) . C550 ) by L832
.= ( ( ( (the ObjectMap of D146) * (the ObjectMap of C548) ) . (C550 , C550) ) `1 ) by L784
.= ( ( ( id ( dom (the ObjectMap of C548) ) ) . [ C550 , C550 ] ) `1 ) by L937 , L942 , FUNCT_1:39
.= ( [ C550 , C550 ] `1 ) by L943 , FUNCT_1:18
.= C550;
thus L945: ( (the ObjectMap of D146) . (C549 , C549) ) = ( (the ObjectMap of D146) . ( (the ObjectMap of C548) . (C550 , C550) ) ) by L939 , L360
.= ( ( (the ObjectMap of D146) * (the ObjectMap of C548) ) . [ C550 , C550 ] ) by L943 , FUNCT_1:13
.= ( ( id ( dom (the ObjectMap of C548) ) ) . [ C550 , C550 ] ) by L937 , L942 , FUNCT_1:39
.= [ ( D146 . C549 ) , ( D146 . C549 ) ] by L939 , L943 , L944 , FUNCT_1:18;
end;
theorem
L946: (for B242 , B243 being  transitive  with_units non  empty AltCatStr holds (for B244 being  feasible  reflexive  id-preserving FunctorStr over B242 , B243 holds (B244 is  bijective  coreflexive implies ( B244 " ) is  id-preserving)))
proof
let C551 , C552 being  transitive  with_units non  empty AltCatStr;
let C553 being  feasible  reflexive  id-preserving FunctorStr over C551 , C552;
assume that
L947: C553 is  bijective  coreflexive;
set D147 = ( C553 " );
reconsider D148 = D147 as  feasible  reflexive FunctorStr over C552 , C551 by L947 , L871 , L934;
L948: (the ObjectMap of D147) = ( (the ObjectMap of C553) " ) by L947 , L858;
consider C554 being (ManySortedFunction of (the Arrows of C551) , ( (the Arrows of C552) * (the ObjectMap of C553) )) such that L949: C554 = (the MorphMap of C553) and L950: (the MorphMap of D147) = ( ( C554 "" ) * ( (the ObjectMap of C553) " ) ) by L947 , L858;
let C555 being (object of C552);
L951: C553 is  injective by L947 , L703;
L952: C553 is  one-to-one by L951 , L700;
L953: (the ObjectMap of C553) is  one-to-one by L952 , L355;
L954: C553 is  faithful by L951 , L700;
L955: (the MorphMap of C553) is  "1-1" by L954 , L684;
L956: C553 is  surjective by L947 , L703;
L957: C553 is  full by L956 , L701;
L958: (ex B245 being (ManySortedFunction of (the Arrows of C551) , ( (the Arrows of C552) * (the ObjectMap of C553) )) st (B245 = (the MorphMap of C553) & B245 is  "onto")) by L957 , L688;
L959: [ ( D147 . C555 ) , ( D147 . C555 ) ] in [: (the carrier of C551) , (the carrier of C551) :] by ZFMISC_1:87;
L960: [ C555 , C555 ] in [: (the carrier of C552) , (the carrier of C552) :] by ZFMISC_1:87;
L961: [ C555 , C555 ] in ( dom (the ObjectMap of D147) ) by L960 , FUNCT_2:def 1;
L962: ( (the ObjectMap of ( C553 * D148 )) . (C555 , C555) ) = ( ( (the ObjectMap of C553) * (the ObjectMap of D148) ) . [ C555 , C555 ] ) by L784
.= ( ( (the ObjectMap of C553) * ( (the ObjectMap of C553) " ) ) . [ C555 , C555 ] ) by L947 , L858
.= ( ( id ( rng (the ObjectMap of C553) ) ) . [ C555 , C555 ] ) by L953 , FUNCT_1:39
.= ( ( id ( dom (the ObjectMap of D147) ) ) . [ C555 , C555 ] ) by L948 , L953 , FUNCT_1:33
.= ( ( id [: (the carrier of C552) , (the carrier of C552) :] ) . [ C555 , C555 ] ) by FUNCT_2:def 1
.= [ C555 , C555 ] by L960 , FUNCT_1:18;
L963: ( C553 . ( D147 . C555 ) ) = ( ( C553 * D148 ) . C555 ) by L832
.= C555 by L962 , MCART_1:7;
L964: ( dom (the MorphMap of C553) ) = [: (the carrier of C551) , (the carrier of C551) :] by PARTFUN1:def 2;
L965: [ ( D147 . C555 ) , ( D147 . C555 ) ] in ( dom (the MorphMap of C553) ) by L964 , ZFMISC_1:87;
L966: ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) is  one-to-one by L965 , L955 , MSUALG_3:def 2;
L967: [ ( D147 . C555 ) , ( D147 . C555 ) ] in ( dom (the ObjectMap of C553) ) by L959 , FUNCT_2:def 1;
L968: ( ( (the Arrows of C552) * (the ObjectMap of C553) ) . [ ( D147 . C555 ) , ( D147 . C555 ) ] ) = ( (the Arrows of C552) . ( (the ObjectMap of C553) . (( D147 . C555 ) , ( D147 . C555 )) ) ) by L967 , FUNCT_1:13
.= ( (the Arrows of C552) . (( C553 . ( D147 . C555 ) ) , ( C553 . ( D147 . C555 ) )) ) by L360;
L969: ( ( (the Arrows of C552) * (the ObjectMap of C553) ) . [ ( D147 . C555 ) , ( D147 . C555 ) ] ) <> ( {} ) by L968 , ALTCAT_2:def 6;
L970: ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) is (Function of ( (the Arrows of C551) . [ ( D147 . C555 ) , ( D147 . C555 ) ] ) , ( ( (the Arrows of C552) * (the ObjectMap of C553) ) . [ ( D147 . C555 ) , ( D147 . C555 ) ] )) by L949 , L959 , PBOOLE:def 15;
L971: ( dom ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) ) = ( (the Arrows of C551) . (( D147 . C555 ) , ( D147 . C555 )) ) by L970 , L969 , FUNCT_2:def 1
.= <^ ( D147 . C555 ) , ( D147 . C555 ) ^> by ALTCAT_1:def 1;
L972: ( ( (the Arrows of C551) * (the ObjectMap of D147) ) . [ C555 , C555 ] ) = ( (the Arrows of C551) . ( (the ObjectMap of D148) . (C555 , C555) ) ) by L961 , FUNCT_1:13
.= ( (the Arrows of C551) . (( D147 . C555 ) , ( D147 . C555 )) ) by L360;
L973: ( ( (the Arrows of C551) * (the ObjectMap of D147) ) . [ C555 , C555 ] ) <> ( {} ) by L972 , ALTCAT_2:def 6;
L974: (the MorphMap of D147) is (ManySortedFunction of (the Arrows of C552) , ( (the Arrows of C551) * (the ObjectMap of D147) )) by L303;
L975: ( Morph-Map (D147 , C555 , C555) ) is (Function of ( (the Arrows of C552) . [ C555 , C555 ] ) , ( ( (the Arrows of C551) * (the ObjectMap of D147) ) . [ C555 , C555 ] )) by L974 , L960 , PBOOLE:def 15;
L976: ( dom ( Morph-Map (D147 , C555 , C555) ) ) = ( (the Arrows of C552) . (C555 , C555) ) by L975 , L973 , FUNCT_2:def 1
.= <^ C555 , C555 ^> by ALTCAT_1:def 1;
L977: ( idm C555 ) in ( dom ( Morph-Map (D147 , C555 , C555) ) ) by L976 , ALTCAT_1:19;
L978: ( Morph-Map (D147 , C555 , C555) ) = ( ( C554 "" ) . ( (the ObjectMap of D147) . (C555 , C555) ) ) by L948 , L950 , L961 , FUNCT_1:13
.= ( ( C554 "" ) . [ ( D148 . C555 ) , ( D148 . C555 ) ] ) by L360
.= ( ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) " ) by L949 , L955 , L958 , L959 , MSUALG_3:def 4;
L979: ( ( Morph-Map (D147 , C555 , C555) ) . ( idm C555 ) ) in ( rng ( Morph-Map (D147 , C555 , C555) ) ) by L977 , FUNCT_1:def 3;
L980: ( ( Morph-Map (D147 , C555 , C555) ) . ( idm C555 ) ) in ( dom ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) ) by L979 , L966 , L978 , FUNCT_1:33;
L981: ( ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) . ( ( Morph-Map (D147 , C555 , C555) ) . ( idm C555 ) ) ) = ( ( ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) * ( Morph-Map (D147 , C555 , C555) ) ) . ( idm C555 ) ) by L976 , ALTCAT_1:19 , FUNCT_1:13
.= ( ( id ( rng ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) ) ) . ( idm C555 ) ) by L966 , L978 , FUNCT_1:39
.= ( ( id ( dom ( Morph-Map (D147 , C555 , C555) ) ) ) . ( idm C555 ) ) by L966 , L978 , FUNCT_1:33
.= ( idm ( C553 . ( D147 . C555 ) ) ) by L963 , L976 , ALTCAT_1:19 , FUNCT_1:18
.= ( ( Morph-Map (C553 , ( D147 . C555 ) , ( D147 . C555 )) ) . ( idm ( D147 . C555 ) ) ) by L515;
thus L982: thesis by L981 , L966 , L971 , L980 , FUNCT_1:def 4;
end;
theorem
L983: (for B246 , B247 being  transitive  with_units non  empty AltCatStr holds (for B248 being  feasible FunctorStr over B246 , B247 holds (B248 is  bijective  Covariant implies ( B248 " ) is  Covariant)))
proof
let C556 , C557 being  transitive  with_units non  empty AltCatStr;
let C558 being  feasible FunctorStr over C556 , C557;
assume L984: C558 is  bijective  Covariant;
L985: C558 is  injective by L984 , L703;
L986: C558 is  one-to-one by L985 , L700;
L987: (the ObjectMap of C558) is  one-to-one by L986 , L355;
L988: C558 is  surjective by L984 , L703;
L989: C558 is  onto by L988 , L701;
L990: (the ObjectMap of C558) is  onto by L989 , L356;
L991: (the ObjectMap of C558) is  Covariant by L984 , L391;
consider C559 being (Function of (the carrier of C556) , (the carrier of C557)) such that L992: (the ObjectMap of C558) = [: C559 , C559 :] by L991 , L257;
L993: C559 is  one-to-one by L987 , L992 , L106;
L994: ( dom ( C559 " ) ) = ( rng C559 ) by L993 , FUNCT_1:33;
L995: ( rng ( C559 " ) ) = ( dom C559 ) by L993 , FUNCT_1:33;
L996: ( rng [: C559 , C559 :] ) = [: (the carrier of C557) , (the carrier of C557) :] by L990 , L992 , FUNCT_2:def 3;
L997: ( rng [: C559 , C559 :] ) = [: ( rng C559 ) , ( rng C559 ) :] by FUNCT_3:67;
L998: ( rng C559 ) = (the carrier of C557) by L997 , L996 , ZFMISC_1:92;
reconsider D149 = ( C559 " ) as (Function of (the carrier of C557) , (the carrier of C556)) by L998 , L994 , L995 , FUNCT_2:def 1 , RELSET_1:4;
take D149;
L999: ( [: C559 , C559 :] " ) = [: D149 , D149 :] by L993 , L85;
thus L1000: thesis by L999 , L984 , L992 , L858;
end;
theorem
L1001: (for B249 , B250 being  transitive  with_units non  empty AltCatStr holds (for B251 being  feasible FunctorStr over B249 , B250 holds (B251 is  bijective  Contravariant implies ( B251 " ) is  Contravariant)))
proof
let C560 , C561 being  transitive  with_units non  empty AltCatStr;
let C562 being  feasible FunctorStr over C560 , C561;
assume L1002: C562 is  bijective  Contravariant;
L1003: C562 is  injective by L1002 , L703;
L1004: C562 is  one-to-one by L1003 , L700;
L1005: (the ObjectMap of C562) is  one-to-one by L1004 , L355;
L1006: C562 is  surjective by L1002 , L703;
L1007: C562 is  onto by L1006 , L701;
L1008: (the ObjectMap of C562) is  onto by L1007 , L356;
L1009: (the ObjectMap of C562) is  Contravariant by L1002 , L392;
consider C563 being (Function of (the carrier of C560) , (the carrier of C561)) such that L1010: (the ObjectMap of C562) = ( ~ [: C563 , C563 :] ) by L1009 , L258;
L1011: [: C563 , C563 :] is  one-to-one by L1005 , L1010 , L135;
L1012: C563 is  one-to-one by L1011 , L106;
L1013: ( dom ( C563 " ) ) = ( rng C563 ) by L1012 , FUNCT_1:33;
L1014: ( rng ( C563 " ) ) = ( dom C563 ) by L1012 , FUNCT_1:33;
L1015: [: C563 , C563 :] is  onto by L1008 , L1010 , L238;
L1016: ( rng [: C563 , C563 :] ) = [: (the carrier of C561) , (the carrier of C561) :] by L1015 , FUNCT_2:def 3;
L1017: ( rng [: C563 , C563 :] ) = [: ( rng C563 ) , ( rng C563 ) :] by FUNCT_3:67;
L1018: ( rng C563 ) = (the carrier of C561) by L1017 , L1016 , ZFMISC_1:92;
reconsider D150 = ( C563 " ) as (Function of (the carrier of C561) , (the carrier of C560)) by L1018 , L1013 , L1014 , FUNCT_2:def 1 , RELSET_1:4;
take D150;
L1019: ( [: C563 , C563 :] " ) = [: D150 , D150 :] by L1012 , L85;
thus L1020: (the ObjectMap of ( C562 " )) = ( (the ObjectMap of C562) " ) by L1002 , L858
.= ( ~ [: D150 , D150 :] ) by L1010 , L1012 , L1019 , L158;
end;
theorem
L1021: (for B252 , B253 being  transitive  with_units non  empty AltCatStr holds (for B254 being  feasible  reflexive FunctorStr over B252 , B253 holds (B254 is  bijective  coreflexive  Covariant implies (for B255 , B256 being (object of B253) holds (for B257 being (Morphism of B255 , B256) holds (<^ B255 , B256 ^> <> ( {} ) implies ( ( Morph-Map (B254 , ( ( B254 " ) . B255 ) , ( ( B254 " ) . B256 )) ) . ( ( Morph-Map (( B254 " ) , B255 , B256) ) . B257 ) ) = B257))))))
proof
let C564 , C565 being  transitive  with_units non  empty AltCatStr;
let C566 being  feasible  reflexive FunctorStr over C564 , C565;
assume that
L1022: C566 is  bijective  coreflexive  Covariant;
set D151 = ( C566 " );
L1023: D151 is  Covariant by L1022 , L983;
reconsider D152 = D151 as  feasible  reflexive FunctorStr over C565 , C564 by L1022 , L871 , L934;
L1024: (the ObjectMap of D151) = ( (the ObjectMap of C566) " ) by L1022 , L858;
consider C567 being (ManySortedFunction of (the Arrows of C564) , ( (the Arrows of C565) * (the ObjectMap of C566) )) such that L1025: C567 = (the MorphMap of C566) and L1026: (the MorphMap of D151) = ( ( C567 "" ) * ( (the ObjectMap of C566) " ) ) by L1022 , L858;
L1027: C566 is  injective by L1022 , L703;
L1028: C566 is  faithful by L1027 , L700;
L1029: (the MorphMap of C566) is  "1-1" by L1028 , L684;
L1030: C566 is  surjective by L1022 , L703;
L1031: C566 is  full by L1030 , L701;
L1032: (ex B258 being (ManySortedFunction of (the Arrows of C564) , ( (the Arrows of C565) * (the ObjectMap of C566) )) st (B258 = (the MorphMap of C566) & B258 is  "onto")) by L1031 , L688;
let C568 , C569 being (object of C565);
let C570 being (Morphism of C568 , C569);
assume that
L1033: <^ C568 , C569 ^> <> ( {} );
L1034: [ ( D151 . C568 ) , ( D151 . C569 ) ] in [: (the carrier of C564) , (the carrier of C564) :] by ZFMISC_1:87;
L1035: [ C568 , C569 ] in [: (the carrier of C565) , (the carrier of C565) :] by ZFMISC_1:87;
L1036: [ C568 , C569 ] in ( dom (the ObjectMap of D151) ) by L1035 , FUNCT_2:def 1;
L1037: ( dom (the MorphMap of C566) ) = [: (the carrier of C564) , (the carrier of C564) :] by PARTFUN1:def 2;
L1038: [ ( D151 . C568 ) , ( D151 . C569 ) ] in ( dom (the MorphMap of C566) ) by L1037 , ZFMISC_1:87;
L1039: ( Morph-Map (C566 , ( D151 . C568 ) , ( D151 . C569 )) ) is  one-to-one by L1038 , L1029 , MSUALG_3:def 2;
L1040: ( ( (the Arrows of C564) * (the ObjectMap of D151) ) . [ C568 , C569 ] ) = ( (the Arrows of C564) . ( (the ObjectMap of D152) . (C568 , C569) ) ) by L1036 , FUNCT_1:13
.= ( (the Arrows of C564) . (( D152 . C568 ) , ( D152 . C569 )) ) by L1023 , L474
.= <^ ( D152 . C568 ) , ( D152 . C569 ) ^> by ALTCAT_1:def 1;
L1041: ( ( (the Arrows of C564) * (the ObjectMap of D151) ) . [ C568 , C569 ] ) <> ( {} ) by L1040 , L1023 , L1033 , L480;
L1042: (the MorphMap of D151) is (ManySortedFunction of (the Arrows of C565) , ( (the Arrows of C564) * (the ObjectMap of D151) )) by L303;
L1043: ( Morph-Map (D151 , C568 , C569) ) is (Function of ( (the Arrows of C565) . [ C568 , C569 ] ) , ( ( (the Arrows of C564) * (the ObjectMap of D151) ) . [ C568 , C569 ] )) by L1042 , L1035 , PBOOLE:def 15;
L1044: ( dom ( Morph-Map (D151 , C568 , C569) ) ) = ( (the Arrows of C565) . (C568 , C569) ) by L1043 , L1041 , FUNCT_2:def 1
.= <^ C568 , C569 ^> by ALTCAT_1:def 1;
L1045: ( Morph-Map (D151 , C568 , C569) ) = ( ( C567 "" ) . ( (the ObjectMap of D151) . (C568 , C569) ) ) by L1024 , L1026 , L1036 , FUNCT_1:13
.= ( ( C567 "" ) . [ ( D152 . C568 ) , ( D152 . C569 ) ] ) by L1023 , L474
.= ( ( Morph-Map (C566 , ( D151 . C568 ) , ( D151 . C569 )) ) " ) by L1025 , L1029 , L1032 , L1034 , MSUALG_3:def 4;
thus L1046: ( ( Morph-Map (C566 , ( D151 . C568 ) , ( D151 . C569 )) ) . ( ( Morph-Map (D151 , C568 , C569) ) . C570 ) ) = ( ( ( Morph-Map (C566 , ( D151 . C568 ) , ( D151 . C569 )) ) * ( Morph-Map (D151 , C568 , C569) ) ) . C570 ) by L1033 , L1044 , FUNCT_1:13
.= ( ( id ( rng ( Morph-Map (C566 , ( D151 . C568 ) , ( D151 . C569 )) ) ) ) . C570 ) by L1039 , L1045 , FUNCT_1:39
.= ( ( id ( dom ( Morph-Map (D151 , C568 , C569) ) ) ) . C570 ) by L1039 , L1045 , FUNCT_1:33
.= C570 by L1033 , L1044 , FUNCT_1:18;
end;
theorem
L1047: (for B259 , B260 being  transitive  with_units non  empty AltCatStr holds (for B261 being  feasible  reflexive FunctorStr over B259 , B260 holds (B261 is  bijective  coreflexive  Contravariant implies (for B262 , B263 being (object of B260) holds (for B264 being (Morphism of B262 , B263) holds (<^ B262 , B263 ^> <> ( {} ) implies ( ( Morph-Map (B261 , ( ( B261 " ) . B263 ) , ( ( B261 " ) . B262 )) ) . ( ( Morph-Map (( B261 " ) , B262 , B263) ) . B264 ) ) = B264))))))
proof
let C571 , C572 being  transitive  with_units non  empty AltCatStr;
let C573 being  feasible  reflexive FunctorStr over C571 , C572;
assume that
L1048: C573 is  bijective  coreflexive  Contravariant;
set D153 = ( C573 " );
L1049: D153 is  Contravariant by L1048 , L1001;
reconsider D154 = D153 as  feasible  reflexive FunctorStr over C572 , C571 by L1048 , L871 , L934;
L1050: (the ObjectMap of D153) = ( (the ObjectMap of C573) " ) by L1048 , L858;
consider C574 being (ManySortedFunction of (the Arrows of C571) , ( (the Arrows of C572) * (the ObjectMap of C573) )) such that L1051: C574 = (the MorphMap of C573) and L1052: (the MorphMap of D153) = ( ( C574 "" ) * ( (the ObjectMap of C573) " ) ) by L1048 , L858;
L1053: C573 is  injective by L1048 , L703;
L1054: C573 is  faithful by L1053 , L700;
L1055: (the MorphMap of C573) is  "1-1" by L1054 , L684;
L1056: C573 is  surjective by L1048 , L703;
L1057: C573 is  full by L1056 , L701;
L1058: (ex B265 being (ManySortedFunction of (the Arrows of C571) , ( (the Arrows of C572) * (the ObjectMap of C573) )) st (B265 = (the MorphMap of C573) & B265 is  "onto")) by L1057 , L688;
let C575 , C576 being (object of C572);
let C577 being (Morphism of C575 , C576);
assume that
L1059: <^ C575 , C576 ^> <> ( {} );
L1060: [ ( D153 . C576 ) , ( D153 . C575 ) ] in [: (the carrier of C571) , (the carrier of C571) :] by ZFMISC_1:87;
L1061: [ C575 , C576 ] in [: (the carrier of C572) , (the carrier of C572) :] by ZFMISC_1:87;
L1062: [ C575 , C576 ] in ( dom (the ObjectMap of D153) ) by L1061 , FUNCT_2:def 1;
L1063: ( dom (the MorphMap of C573) ) = [: (the carrier of C571) , (the carrier of C571) :] by PARTFUN1:def 2;
L1064: [ ( D153 . C576 ) , ( D153 . C575 ) ] in ( dom (the MorphMap of C573) ) by L1063 , ZFMISC_1:87;
L1065: ( Morph-Map (C573 , ( D153 . C576 ) , ( D153 . C575 )) ) is  one-to-one by L1064 , L1055 , MSUALG_3:def 2;
L1066: ( ( (the Arrows of C571) * (the ObjectMap of D153) ) . [ C575 , C576 ] ) = ( (the Arrows of C571) . ( (the ObjectMap of D154) . (C575 , C576) ) ) by L1062 , FUNCT_1:13
.= ( (the Arrows of C571) . (( D154 . C576 ) , ( D154 . C575 )) ) by L1049 , L491
.= <^ ( D154 . C576 ) , ( D154 . C575 ) ^> by ALTCAT_1:def 1;
L1067: ( ( (the Arrows of C571) * (the ObjectMap of D153) ) . [ C575 , C576 ] ) <> ( {} ) by L1066 , L1049 , L1059 , L501;
L1068: (the MorphMap of D153) is (ManySortedFunction of (the Arrows of C572) , ( (the Arrows of C571) * (the ObjectMap of D153) )) by L303;
L1069: ( Morph-Map (D153 , C575 , C576) ) is (Function of ( (the Arrows of C572) . [ C575 , C576 ] ) , ( ( (the Arrows of C571) * (the ObjectMap of D153) ) . [ C575 , C576 ] )) by L1068 , L1061 , PBOOLE:def 15;
L1070: ( dom ( Morph-Map (D153 , C575 , C576) ) ) = ( (the Arrows of C572) . (C575 , C576) ) by L1069 , L1067 , FUNCT_2:def 1
.= <^ C575 , C576 ^> by ALTCAT_1:def 1;
L1071: ( Morph-Map (D153 , C575 , C576) ) = ( ( C574 "" ) . ( (the ObjectMap of D153) . (C575 , C576) ) ) by L1050 , L1052 , L1062 , FUNCT_1:13
.= ( ( C574 "" ) . [ ( D154 . C576 ) , ( D154 . C575 ) ] ) by L1049 , L491
.= ( ( Morph-Map (C573 , ( D153 . C576 ) , ( D153 . C575 )) ) " ) by L1051 , L1055 , L1058 , L1060 , MSUALG_3:def 4;
thus L1072: ( ( Morph-Map (C573 , ( ( C573 " ) . C576 ) , ( ( C573 " ) . C575 )) ) . ( ( Morph-Map (( C573 " ) , C575 , C576) ) . C577 ) ) = ( ( ( Morph-Map (C573 , ( D153 . C576 ) , ( D153 . C575 )) ) * ( Morph-Map (D153 , C575 , C576) ) ) . C577 ) by L1059 , L1070 , FUNCT_1:13
.= ( ( id ( rng ( Morph-Map (C573 , ( D153 . C576 ) , ( D153 . C575 )) ) ) ) . C577 ) by L1065 , L1071 , FUNCT_1:39
.= ( ( id ( dom ( Morph-Map (D153 , C575 , C576) ) ) ) . C577 ) by L1065 , L1071 , FUNCT_1:33
.= C577 by L1059 , L1070 , FUNCT_1:18;
end;
theorem
L1073: (for B266 , B267 being  transitive  with_units non  empty AltCatStr holds (for B268 being  feasible  reflexive FunctorStr over B266 , B267 holds (B268 is  bijective  comp-preserving  Covariant  coreflexive implies ( B268 " ) is  comp-preserving)))
proof
let C578 , C579 being  transitive  with_units non  empty AltCatStr;
let C580 being  feasible  reflexive FunctorStr over C578 , C579;
assume that
L1074: C580 is  bijective  comp-preserving  Covariant  coreflexive;
set D155 = ( C580 " );
L1075: D155 is  Covariant by L1074 , L983;
reconsider D156 = D155 as  feasible  reflexive FunctorStr over C579 , C578 by L1074 , L871 , L934;
L1076: (the ObjectMap of D155) = ( (the ObjectMap of C580) " ) by L1074 , L858;
consider C581 being (ManySortedFunction of (the Arrows of C578) , ( (the Arrows of C579) * (the ObjectMap of C580) )) such that L1077: C581 = (the MorphMap of C580) and L1078: (the MorphMap of D155) = ( ( C581 "" ) * ( (the ObjectMap of C580) " ) ) by L1074 , L858;
L1079: C580 is  injective by L1074 , L703;
L1080: C580 is  one-to-one by L1079 , L700;
L1081: (the ObjectMap of C580) is  one-to-one by L1080 , L355;
L1082: C580 is  faithful by L1079 , L700;
L1083: (the MorphMap of C580) is  "1-1" by L1082 , L684;
L1084: C580 is  surjective by L1074 , L703;
L1085: C580 is  full by L1084 , L701;
L1086: (ex B269 being (ManySortedFunction of (the Arrows of C578) , ( (the Arrows of C579) * (the ObjectMap of C580) )) st (B269 = (the MorphMap of C580) & B269 is  "onto")) by L1085 , L688;
let C582 , C583 , C584 being (object of C579);
assume L1087: <^ C582 , C583 ^> <> ( {} );
L1088: <^ ( D156 . C582 ) , ( D156 . C583 ) ^> <> ( {} ) by L1087 , L1075 , L480;
assume L1089: <^ C583 , C584 ^> <> ( {} );
L1090: <^ ( D156 . C583 ) , ( D156 . C584 ) ^> <> ( {} ) by L1089 , L1075 , L480;
L1091: <^ C582 , C584 ^> <> ( {} ) by L1087 , L1089 , ALTCAT_1:def 2;
L1092: <^ ( D156 . C582 ) , ( D156 . C584 ) ^> <> ( {} ) by L1091 , L1075 , L480;
L1093: <^ ( C580 . ( D155 . C582 ) ) , ( C580 . ( D155 . C584 ) ) ^> <> ( {} ) by L1092 , L1074 , L480;
let C585 being (Morphism of C582 , C583);
let C586 being (Morphism of C583 , C584);
reconsider D157 = D155 as  Covariant FunctorStr over C579 , C578 by L1074 , L983;
L1094: ( D157 . C585 ) = ( ( Morph-Map (D157 , C582 , C583) ) . C585 ) by L1087 , L1088 , L414;
reconsider D158 = ( ( Morph-Map (D157 , C582 , C583) ) . C585 ) as (Morphism of ( D155 . C582 ) , ( D155 . C583 )) by L1094;
L1095: ( D157 . C586 ) = ( ( Morph-Map (D157 , C583 , C584) ) . C586 ) by L1089 , L1090 , L414;
reconsider D159 = ( ( Morph-Map (D157 , C583 , C584) ) . C586 ) as (Morphism of ( D155 . C583 ) , ( D155 . C584 )) by L1095;
take D158;
take D159;
thus L1096: D158 = ( ( Morph-Map (D155 , C582 , C583) ) . C585 );
thus L1097: D159 = ( ( Morph-Map (D155 , C583 , C584) ) . C586 );
consider C587 being (Morphism of ( C580 . ( D155 . C582 ) ) , ( C580 . ( D155 . C583 ) )), C588 being (Morphism of ( C580 . ( D155 . C583 ) ) , ( C580 . ( D155 . C584 ) )) such that L1098: C587 = ( ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C583 )) ) . D158 ) and L1099: C588 = ( ( Morph-Map (C580 , ( D155 . C583 ) , ( D155 . C584 )) ) . D159 ) and L1100: ( ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) . ( D159 * D158 ) ) = ( C588 * C587 ) by L1074 , L1088 , L1090 , L550;
L1101: C586 = C588 by L1074 , L1089 , L1099 , L1021;
L1102: C585 = C587 by L1074 , L1087 , L1098 , L1021;
L1103: [ ( D155 . C582 ) , ( D155 . C584 ) ] in [: (the carrier of C578) , (the carrier of C578) :] by ZFMISC_1:87;
L1104: [ C582 , C584 ] in [: (the carrier of C579) , (the carrier of C579) :] by ZFMISC_1:87;
L1105: [ C582 , C584 ] in ( dom (the ObjectMap of D155) ) by L1104 , FUNCT_2:def 1;
L1106: ( dom (the MorphMap of C580) ) = [: (the carrier of C578) , (the carrier of C578) :] by PARTFUN1:def 2;
L1107: [ ( D155 . C582 ) , ( D155 . C584 ) ] in ( dom (the MorphMap of C580) ) by L1106 , ZFMISC_1:87;
L1108: ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) is  one-to-one by L1107 , L1083 , MSUALG_3:def 2;
L1109: [ ( D155 . C582 ) , ( D155 . C584 ) ] in ( dom (the ObjectMap of C580) ) by L1103 , FUNCT_2:def 1;
L1110: ( ( (the Arrows of C579) * (the ObjectMap of C580) ) . [ ( D155 . C582 ) , ( D155 . C584 ) ] ) = ( (the Arrows of C579) . ( (the ObjectMap of C580) . (( D155 . C582 ) , ( D155 . C584 )) ) ) by L1109 , FUNCT_1:13
.= ( (the Arrows of C579) . (( C580 . ( D155 . C582 ) ) , ( C580 . ( D155 . C584 ) )) ) by L1074 , L474
.= <^ ( C580 . ( D155 . C582 ) ) , ( C580 . ( D155 . C584 ) ) ^> by ALTCAT_1:def 1;
L1111: ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) is (Function of ( (the Arrows of C578) . [ ( D155 . C582 ) , ( D155 . C584 ) ] ) , ( ( (the Arrows of C579) * (the ObjectMap of C580) ) . [ ( D155 . C582 ) , ( D155 . C584 ) ] )) by L1077 , L1103 , PBOOLE:def 15;
L1112: ( dom ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) ) = ( (the Arrows of C578) . (( D155 . C582 ) , ( D155 . C584 )) ) by L1111 , L1093 , L1110 , FUNCT_2:def 1
.= <^ ( D155 . C582 ) , ( D155 . C584 ) ^> by ALTCAT_1:def 1;
L1113: ( ( (the Arrows of C578) * (the ObjectMap of D155) ) . [ C582 , C584 ] ) = ( (the Arrows of C578) . ( (the ObjectMap of D156) . (C582 , C584) ) ) by L1105 , FUNCT_1:13
.= ( (the Arrows of C578) . (( D155 . C582 ) , ( D155 . C584 )) ) by L1075 , L474
.= <^ ( D155 . C582 ) , ( D155 . C584 ) ^> by ALTCAT_1:def 1;
L1114: (the MorphMap of D155) is (ManySortedFunction of (the Arrows of C579) , ( (the Arrows of C578) * (the ObjectMap of D155) )) by L303;
L1115: ( Morph-Map (D155 , C582 , C584) ) is (Function of ( (the Arrows of C579) . [ C582 , C584 ] ) , ( ( (the Arrows of C578) * (the ObjectMap of D155) ) . [ C582 , C584 ] )) by L1114 , L1104 , PBOOLE:def 15;
L1116: ( dom ( Morph-Map (D155 , C582 , C584) ) ) = ( (the Arrows of C579) . (C582 , C584) ) by L1115 , L1092 , L1113 , FUNCT_2:def 1
.= <^ C582 , C584 ^> by ALTCAT_1:def 1;
L1117: ( Morph-Map (D155 , C582 , C584) ) = ( ( C581 "" ) . ( (the ObjectMap of D155) . (C582 , C584) ) ) by L1076 , L1078 , L1105 , FUNCT_1:13
.= ( ( C581 "" ) . [ ( D156 . C582 ) , ( D156 . C584 ) ] ) by L1075 , L474
.= ( ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) " ) by L1077 , L1083 , L1086 , L1103 , MSUALG_3:def 4;
L1118: (the ObjectMap of ( C580 * D156 )) = ( (the ObjectMap of C580) * (the ObjectMap of D156) ) by L784
.= ( (the ObjectMap of C580) * ( (the ObjectMap of C580) " ) ) by L1074 , L858
.= ( id ( rng (the ObjectMap of C580) ) ) by L1081 , FUNCT_1:39
.= ( id ( dom (the ObjectMap of D155) ) ) by L1076 , L1081 , FUNCT_1:33
.= ( id [: (the carrier of C579) , (the carrier of C579) :] ) by FUNCT_2:def 1;
L1119: [ C582 , C582 ] in [: (the carrier of C579) , (the carrier of C579) :] by ZFMISC_1:87;
L1120: ( (the ObjectMap of ( C580 * D156 )) . (C582 , C582) ) = [ C582 , C582 ] by L1119 , L1118 , FUNCT_1:18;
L1121: ( C580 . ( D155 . C582 ) ) = ( ( C580 * D156 ) . C582 ) by L832
.= C582 by L1120 , MCART_1:7;
L1122: [ C583 , C583 ] in [: (the carrier of C579) , (the carrier of C579) :] by ZFMISC_1:87;
L1123: ( (the ObjectMap of ( C580 * D156 )) . (C583 , C583) ) = [ C583 , C583 ] by L1122 , L1118 , FUNCT_1:18;
L1124: ( C580 . ( D155 . C583 ) ) = ( ( C580 * D156 ) . C583 ) by L832
.= C583 by L1123 , MCART_1:7;
L1125: [ C584 , C584 ] in [: (the carrier of C579) , (the carrier of C579) :] by ZFMISC_1:87;
L1126: ( (the ObjectMap of ( C580 * D156 )) . (C584 , C584) ) = [ C584 , C584 ] by L1125 , L1118 , FUNCT_1:18;
L1127: ( C580 . ( D155 . C584 ) ) = ( ( C580 * D156 ) . C584 ) by L832
.= C584 by L1126 , MCART_1:7;
L1128: ( ( Morph-Map (D155 , C582 , C584) ) . ( C586 * C585 ) ) in ( rng ( Morph-Map (D155 , C582 , C584) ) ) by L1091 , L1116 , FUNCT_1:def 3;
L1129: ( ( Morph-Map (D155 , C582 , C584) ) . ( C586 * C585 ) ) in ( dom ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) ) by L1128 , L1108 , L1117 , FUNCT_1:33;
L1130: ( ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) . ( ( Morph-Map (D155 , C582 , C584) ) . ( C586 * C585 ) ) ) = ( ( Morph-Map (C580 , ( D155 . C582 ) , ( D155 . C584 )) ) . ( D159 * D158 ) ) by L1074 , L1091 , L1100 , L1101 , L1102 , L1121 , L1124 , L1127 , L1021;
thus L1131: thesis by L1130 , L1108 , L1112 , L1129 , FUNCT_1:def 4;
end;
theorem
L1132: (for B270 , B271 being  transitive  with_units non  empty AltCatStr holds (for B272 being  feasible  reflexive FunctorStr over B270 , B271 holds (B272 is  bijective  comp-reversing  Contravariant  coreflexive implies ( B272 " ) is  comp-reversing)))
proof
let C589 , C590 being  transitive  with_units non  empty AltCatStr;
let C591 being  feasible  reflexive FunctorStr over C589 , C590;
assume that
L1133: C591 is  bijective  comp-reversing  Contravariant  coreflexive;
set D160 = ( C591 " );
L1134: D160 is  Contravariant by L1133 , L1001;
reconsider D161 = D160 as  feasible  reflexive FunctorStr over C590 , C589 by L1133 , L871 , L934;
L1135: (the ObjectMap of D160) = ( (the ObjectMap of C591) " ) by L1133 , L858;
consider C592 being (ManySortedFunction of (the Arrows of C589) , ( (the Arrows of C590) * (the ObjectMap of C591) )) such that L1136: C592 = (the MorphMap of C591) and L1137: (the MorphMap of D160) = ( ( C592 "" ) * ( (the ObjectMap of C591) " ) ) by L1133 , L858;
L1138: C591 is  injective by L1133 , L703;
L1139: C591 is  one-to-one by L1138 , L700;
L1140: (the ObjectMap of C591) is  one-to-one by L1139 , L355;
L1141: C591 is  faithful by L1138 , L700;
L1142: (the MorphMap of C591) is  "1-1" by L1141 , L684;
L1143: C591 is  surjective by L1133 , L703;
L1144: C591 is  full by L1143 , L701;
L1145: (ex B273 being (ManySortedFunction of (the Arrows of C589) , ( (the Arrows of C590) * (the ObjectMap of C591) )) st (B273 = (the MorphMap of C591) & B273 is  "onto")) by L1144 , L688;
let C593 , C594 , C595 being (object of C590);
assume L1146: <^ C593 , C594 ^> <> ( {} );
L1147: <^ ( D161 . C594 ) , ( D161 . C593 ) ^> <> ( {} ) by L1146 , L1134 , L501;
assume L1148: <^ C594 , C595 ^> <> ( {} );
L1149: <^ ( D161 . C595 ) , ( D161 . C594 ) ^> <> ( {} ) by L1148 , L1134 , L501;
L1150: <^ C593 , C595 ^> <> ( {} ) by L1146 , L1148 , ALTCAT_1:def 2;
L1151: <^ ( D161 . C595 ) , ( D161 . C593 ) ^> <> ( {} ) by L1150 , L1134 , L501;
L1152: <^ ( C591 . ( D160 . C593 ) ) , ( C591 . ( D160 . C595 ) ) ^> <> ( {} ) by L1151 , L1133 , L501;
let C596 being (Morphism of C593 , C594);
let C597 being (Morphism of C594 , C595);
reconsider D162 = D160 as  Contravariant FunctorStr over C590 , C589 by L1133 , L1001;
L1153: ( D162 . C596 ) = ( ( Morph-Map (D162 , C593 , C594) ) . C596 ) by L1146 , L1147 , L439;
reconsider D163 = ( ( Morph-Map (D162 , C593 , C594) ) . C596 ) as (Morphism of ( D160 . C594 ) , ( D160 . C593 )) by L1153;
L1154: ( D162 . C597 ) = ( ( Morph-Map (D162 , C594 , C595) ) . C597 ) by L1148 , L1149 , L439;
reconsider D164 = ( ( Morph-Map (D162 , C594 , C595) ) . C597 ) as (Morphism of ( D160 . C595 ) , ( D160 . C594 )) by L1154;
take D163;
take D164;
thus L1155: D163 = ( ( Morph-Map (D160 , C593 , C594) ) . C596 );
thus L1156: D164 = ( ( Morph-Map (D160 , C594 , C595) ) . C597 );
consider C598 being (Morphism of ( C591 . ( D160 . C594 ) ) , ( C591 . ( D160 . C595 ) )), C599 being (Morphism of ( C591 . ( D160 . C593 ) ) , ( C591 . ( D160 . C594 ) )) such that L1157: C598 = ( ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C594 )) ) . D164 ) and L1158: C599 = ( ( Morph-Map (C591 , ( D160 . C594 ) , ( D160 . C593 )) ) . D163 ) and L1159: ( ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) . ( D163 * D164 ) ) = ( C598 * C599 ) by L1133 , L1147 , L1149 , L552;
L1160: C597 = C598 by L1133 , L1148 , L1157 , L1047;
L1161: C596 = C599 by L1133 , L1146 , L1158 , L1047;
L1162: [ ( D160 . C595 ) , ( D160 . C593 ) ] in [: (the carrier of C589) , (the carrier of C589) :] by ZFMISC_1:87;
L1163: [ C593 , C595 ] in [: (the carrier of C590) , (the carrier of C590) :] by ZFMISC_1:87;
L1164: [ C593 , C595 ] in ( dom (the ObjectMap of D160) ) by L1163 , FUNCT_2:def 1;
L1165: ( dom (the MorphMap of C591) ) = [: (the carrier of C589) , (the carrier of C589) :] by PARTFUN1:def 2;
L1166: [ ( D160 . C595 ) , ( D160 . C593 ) ] in ( dom (the MorphMap of C591) ) by L1165 , ZFMISC_1:87;
L1167: ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) is  one-to-one by L1166 , L1142 , MSUALG_3:def 2;
L1168: [ ( D160 . C595 ) , ( D160 . C593 ) ] in ( dom (the ObjectMap of C591) ) by L1162 , FUNCT_2:def 1;
L1169: ( ( (the Arrows of C590) * (the ObjectMap of C591) ) . [ ( D160 . C595 ) , ( D160 . C593 ) ] ) = ( (the Arrows of C590) . ( (the ObjectMap of C591) . (( D160 . C595 ) , ( D160 . C593 )) ) ) by L1168 , FUNCT_1:13
.= ( (the Arrows of C590) . (( C591 . ( D160 . C593 ) ) , ( C591 . ( D160 . C595 ) )) ) by L1133 , L491
.= <^ ( C591 . ( D160 . C593 ) ) , ( C591 . ( D160 . C595 ) ) ^> by ALTCAT_1:def 1;
L1170: ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) is (Function of ( (the Arrows of C589) . [ ( D160 . C595 ) , ( D160 . C593 ) ] ) , ( ( (the Arrows of C590) * (the ObjectMap of C591) ) . [ ( D160 . C595 ) , ( D160 . C593 ) ] )) by L1136 , L1162 , PBOOLE:def 15;
L1171: ( dom ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) ) = ( (the Arrows of C589) . (( D160 . C595 ) , ( D160 . C593 )) ) by L1170 , L1152 , L1169 , FUNCT_2:def 1
.= <^ ( D160 . C595 ) , ( D160 . C593 ) ^> by ALTCAT_1:def 1;
L1172: ( ( (the Arrows of C589) * (the ObjectMap of D160) ) . [ C593 , C595 ] ) = ( (the Arrows of C589) . ( (the ObjectMap of D161) . (C593 , C595) ) ) by L1164 , FUNCT_1:13
.= ( (the Arrows of C589) . (( D160 . C595 ) , ( D160 . C593 )) ) by L1134 , L491
.= <^ ( D160 . C595 ) , ( D160 . C593 ) ^> by ALTCAT_1:def 1;
L1173: (the MorphMap of D160) is (ManySortedFunction of (the Arrows of C590) , ( (the Arrows of C589) * (the ObjectMap of D160) )) by L303;
L1174: ( Morph-Map (D160 , C593 , C595) ) is (Function of ( (the Arrows of C590) . [ C593 , C595 ] ) , ( ( (the Arrows of C589) * (the ObjectMap of D160) ) . [ C593 , C595 ] )) by L1173 , L1163 , PBOOLE:def 15;
L1175: ( dom ( Morph-Map (D160 , C593 , C595) ) ) = ( (the Arrows of C590) . (C593 , C595) ) by L1174 , L1151 , L1172 , FUNCT_2:def 1
.= <^ C593 , C595 ^> by ALTCAT_1:def 1;
L1176: ( Morph-Map (D160 , C593 , C595) ) = ( ( C592 "" ) . ( (the ObjectMap of D160) . (C593 , C595) ) ) by L1135 , L1137 , L1164 , FUNCT_1:13
.= ( ( C592 "" ) . [ ( D161 . C595 ) , ( D161 . C593 ) ] ) by L1134 , L491
.= ( ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) " ) by L1136 , L1142 , L1145 , L1162 , MSUALG_3:def 4;
L1177: (the ObjectMap of ( C591 * D161 )) = ( (the ObjectMap of C591) * (the ObjectMap of D161) ) by L784
.= ( (the ObjectMap of C591) * ( (the ObjectMap of C591) " ) ) by L1133 , L858
.= ( id ( rng (the ObjectMap of C591) ) ) by L1140 , FUNCT_1:39
.= ( id ( dom (the ObjectMap of D160) ) ) by L1135 , L1140 , FUNCT_1:33
.= ( id [: (the carrier of C590) , (the carrier of C590) :] ) by FUNCT_2:def 1;
L1178: [ C593 , C593 ] in [: (the carrier of C590) , (the carrier of C590) :] by ZFMISC_1:87;
L1179: ( (the ObjectMap of ( C591 * D161 )) . (C593 , C593) ) = [ C593 , C593 ] by L1178 , L1177 , FUNCT_1:18;
L1180: ( C591 . ( D160 . C593 ) ) = ( ( C591 * D161 ) . C593 ) by L832
.= C593 by L1179 , MCART_1:7;
L1181: [ C594 , C594 ] in [: (the carrier of C590) , (the carrier of C590) :] by ZFMISC_1:87;
L1182: ( (the ObjectMap of ( C591 * D161 )) . (C594 , C594) ) = [ C594 , C594 ] by L1181 , L1177 , FUNCT_1:18;
L1183: ( C591 . ( D160 . C594 ) ) = ( ( C591 * D161 ) . C594 ) by L832
.= C594 by L1182 , MCART_1:7;
L1184: [ C595 , C595 ] in [: (the carrier of C590) , (the carrier of C590) :] by ZFMISC_1:87;
L1185: ( (the ObjectMap of ( C591 * D161 )) . (C595 , C595) ) = [ C595 , C595 ] by L1184 , L1177 , FUNCT_1:18;
L1186: ( C591 . ( D160 . C595 ) ) = ( ( C591 * D161 ) . C595 ) by L832
.= C595 by L1185 , MCART_1:7;
L1187: ( ( Morph-Map (D160 , C593 , C595) ) . ( C597 * C596 ) ) in ( rng ( Morph-Map (D160 , C593 , C595) ) ) by L1150 , L1175 , FUNCT_1:def 3;
L1188: ( ( Morph-Map (D160 , C593 , C595) ) . ( C597 * C596 ) ) in ( dom ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) ) by L1187 , L1167 , L1176 , FUNCT_1:33;
L1189: ( ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) . ( ( Morph-Map (D160 , C593 , C595) ) . ( C597 * C596 ) ) ) = ( ( Morph-Map (C591 , ( D160 . C595 ) , ( D160 . C593 )) ) . ( D163 * D164 ) ) by L1133 , L1150 , L1159 , L1160 , L1161 , L1180 , L1183 , L1186 , L1047;
thus L1190: thesis by L1189 , L1167 , L1171 , L1188 , FUNCT_1:def 4;
end;
registration
let C600 being 1-sorted;
let C601 being non  empty 1-sorted;
cluster  Covariant ->  reflexive for BimapStr over C600 , C601;
coherence
proof
let C602 being BimapStr over C600 , C601;
assume L1191: C602 is  Covariant;
L1192: (the ObjectMap of C602) is  Covariant by L1191 , L391;
L1193: (ex B274 being (Function of (the carrier of C600) , (the carrier of C601)) st (the ObjectMap of C602) = [: B274 , B274 :]) by L1192 , L257;
thus L1194: ( (the ObjectMap of C602) .: ( id (the carrier of C600) ) ) c= ( id (the carrier of C601) ) by L1193 , L243;
end;
end;
registration
let C603 being 1-sorted;
let C604 being non  empty 1-sorted;
cluster  Contravariant ->  reflexive for BimapStr over C603 , C604;
coherence
proof
let C605 being BimapStr over C603 , C604;
assume L1196: C605 is  Contravariant;
L1197: (the ObjectMap of C605) is  Contravariant by L1196 , L392;
consider C606 being (Function of (the carrier of C603) , (the carrier of C604)) such that L1198: (the ObjectMap of C605) = ( ~ [: C606 , C606 :] ) by L1197 , L258;
L1199: ( ( ~ [: C606 , C606 :] ) .: ( id (the carrier of C603) ) ) = ( [: C606 , C606 :] .: ( id (the carrier of C603) ) ) by L38;
thus L1200: ( (the ObjectMap of C605) .: ( id (the carrier of C603) ) ) c= ( id (the carrier of C604) ) by L1199 , L1198 , L243;
end;
end;
theorem
L1202: (for B275 , B276 being 1-sorted holds (for B277 being BimapStr over B275 , B276 holds (B277 is  Covariant  onto implies B277 is  coreflexive)))
proof
let C607 , C608 being 1-sorted;
let C609 being BimapStr over C607 , C608;
assume L1203: C609 is  Covariant  onto;
L1204: (the ObjectMap of C609) is  Covariant by L1203 , L391;
consider C610 being (Function of (the carrier of C607) , (the carrier of C608)) such that L1205: (the ObjectMap of C609) = [: C610 , C610 :] by L1204 , L257;
L1206: (the ObjectMap of C609) is  onto by L1203 , L356;
L1207: C610 is  onto by L1206 , L1205 , L58;
thus L1208: ( id (the carrier of C608) ) c= ( (the ObjectMap of C609) .: ( id (the carrier of C607) ) ) by L1207 , L1205 , L210;
end;
theorem
L1209: (for B278 , B279 being 1-sorted holds (for B280 being BimapStr over B278 , B279 holds (B280 is  Contravariant  onto implies B280 is  coreflexive)))
proof
let C611 , C612 being 1-sorted;
let C613 being BimapStr over C611 , C612;
assume L1210: C613 is  Contravariant  onto;
L1211: (the ObjectMap of C613) is  Contravariant by L1210 , L392;
consider C614 being (Function of (the carrier of C611) , (the carrier of C612)) such that L1212: (the ObjectMap of C613) = ( ~ [: C614 , C614 :] ) by L1211 , L258;
L1213: (the ObjectMap of C613) is  onto by L1210 , L356;
L1214: [: C614 , C614 :] is  onto by L1213 , L1212 , L238;
L1215: C614 is  onto by L1214 , L58;
L1216: ( (the ObjectMap of C613) .: ( id (the carrier of C611) ) ) = ( [: C614 , C614 :] .: ( id (the carrier of C611) ) ) by L1212 , L38;
thus L1217: ( id (the carrier of C612) ) c= ( (the ObjectMap of C613) .: ( id (the carrier of C611) ) ) by L1216 , L1215 , L210;
end;
registration
let C615 being  transitive  with_units non  empty AltCatStr;
let C616 being  with_units non  empty AltCatStr;
cluster  covariant ->  reflexive for (Functor of C615 , C616);
coherence
proof
let C617 being (Functor of C615 , C616);
assume L1218: C617 is  covariant;
reconsider D165 = C617 as  Covariant FunctorStr over C615 , C616 by L1218 , L642;
L1219: D165 is  reflexive;
thus L1220: thesis by L1219;
end;
end;
registration
let C618 being  transitive  with_units non  empty AltCatStr;
let C619 being  with_units non  empty AltCatStr;
cluster  contravariant ->  reflexive for (Functor of C618 , C619);
coherence
proof
let C620 being (Functor of C618 , C619);
assume L1222: C620 is  contravariant;
reconsider D166 = C620 as  Contravariant FunctorStr over C618 , C619 by L1222 , L643;
L1223: D166 is  reflexive;
thus L1224: thesis by L1223;
end;
end;
theorem
L1226: (for B281 being  transitive  with_units non  empty AltCatStr holds (for B282 being  with_units non  empty AltCatStr holds (for B283 being (Functor of B281 , B282) holds (B283 is  covariant  onto implies B283 is  coreflexive))))
proof
let C621 being  transitive  with_units non  empty AltCatStr;
let C622 being  with_units non  empty AltCatStr;
let C623 being (Functor of C621 , C622);
assume L1227: C623 is  covariant  onto;
L1228: C623 is  Covariant by L1227 , L642;
thus L1229: thesis by L1228 , L1227 , L1202;
end;
theorem
L1230: (for B284 being  transitive  with_units non  empty AltCatStr holds (for B285 being  with_units non  empty AltCatStr holds (for B286 being (Functor of B284 , B285) holds (B286 is  contravariant  onto implies B286 is  coreflexive))))
proof
let C624 being  transitive  with_units non  empty AltCatStr;
let C625 being  with_units non  empty AltCatStr;
let C626 being (Functor of C624 , C625);
assume L1231: C626 is  contravariant  onto;
L1232: C626 is  Contravariant by L1231 , L643;
thus L1233: thesis by L1232 , L1231 , L1209;
end;
theorem
L1234: (for B287 , B288 being  transitive  with_units non  empty AltCatStr holds (for B289 being  covariant (Functor of B287 , B288) holds (B289 is  bijective implies (ex B290 being (Functor of B288 , B287) st (B290 = ( B289 " ) & B290 is  bijective  covariant)))))
proof
let C627 , C628 being  transitive  with_units non  empty AltCatStr;
let C629 being  covariant (Functor of C627 , C628);
assume L1235: C629 is  bijective;
L1236: C629 is  injective by L1235 , L703;
L1237: C629 is  one-to-one by L1236 , L700;
L1238: (the ObjectMap of C629) is  one-to-one by L1237 , L355;
L1239: C629 is  feasible by L639;
L1240: ( C629 " ) is  bijective  feasible by L1239 , L1235 , L871;
L1241: C629 is  id-preserving by L639;
L1242: C629 is  comp-preserving by L642;
L1243: C629 is  surjective by L1235 , L703;
L1244: C629 is  onto by L1243 , L701;
L1245: (the ObjectMap of C629) is  onto by L1244 , L356;
L1246: C629 is  Covariant by L642;
L1247: C629 is  coreflexive by L1244 , L1226;
L1248: ( C629 " ) is  Covariant
proof
L1249: C629 is  Covariant by L642;
L1250: (the ObjectMap of C629) is  Covariant by L1249 , L391;
consider C630 being (Function of (the carrier of C627) , (the carrier of C628)) such that L1251: (the ObjectMap of C629) = [: C630 , C630 :] by L1250 , L257;
L1252: C630 is  one-to-one by L1238 , L1251 , L106;
L1253: ( dom ( C630 " ) ) = ( rng C630 ) by L1252 , FUNCT_1:33;
L1254: ( rng ( C630 " ) ) = ( dom C630 ) by L1252 , FUNCT_1:33;
L1255: ( rng [: C630 , C630 :] ) = [: (the carrier of C628) , (the carrier of C628) :] by L1245 , L1251 , FUNCT_2:def 3;
L1256: ( rng [: C630 , C630 :] ) = [: ( rng C630 ) , ( rng C630 ) :] by FUNCT_3:67;
L1257: ( rng C630 ) = (the carrier of C628) by L1256 , L1255 , ZFMISC_1:92;
reconsider D167 = ( C630 " ) as (Function of (the carrier of C628) , (the carrier of C627)) by L1257 , L1253 , L1254 , FUNCT_2:def 1 , RELSET_1:4;
take D167;
L1258: ( [: C630 , C630 :] " ) = [: D167 , D167 :] by L1252 , L85;
thus L1259: thesis by L1258 , L1235 , L1251 , L858;
end;
L1260: ( C629 " ) is  id-preserving by L1235 , L1239 , L1241 , L1247 , L946;
L1261: ( C629 " ) is  comp-preserving by L1235 , L1239 , L1242 , L1246 , L1247 , L1073;
reconsider D168 = ( C629 " ) as (Functor of C628 , C627) by L1261 , L1240 , L1248 , L1260 , L639;
take D168;
thus L1262: D168 = ( C629 " );
thus L1263: D168 is  bijective by L1235 , L1239 , L871;
thus L1264: D168 is  Covariant by L1248;
thus L1265: thesis by L1235 , L1239 , L1242 , L1246 , L1247 , L1073;
end;
theorem
L1266: (for B291 , B292 being  transitive  with_units non  empty AltCatStr holds (for B293 being  contravariant (Functor of B291 , B292) holds (B293 is  bijective implies (ex B294 being (Functor of B292 , B291) st (B294 = ( B293 " ) & B294 is  bijective  contravariant)))))
proof
let C631 , C632 being  transitive  with_units non  empty AltCatStr;
let C633 being  contravariant (Functor of C631 , C632);
assume L1267: C633 is  bijective;
L1268: C633 is  injective by L1267 , L703;
L1269: C633 is  one-to-one by L1268 , L700;
L1270: (the ObjectMap of C633) is  one-to-one by L1269 , L355;
L1271: C633 is  feasible by L639;
L1272: ( C633 " ) is  bijective  feasible by L1271 , L1267 , L871;
L1273: C633 is  id-preserving by L639;
L1274: C633 is  comp-reversing by L643;
L1275: C633 is  surjective by L1267 , L703;
L1276: C633 is  onto by L1275 , L701;
L1277: (the ObjectMap of C633) is  onto by L1276 , L356;
L1278: C633 is  Contravariant by L643;
L1279: C633 is  coreflexive by L1276 , L1230;
L1280: ( C633 " ) is  Contravariant
proof
L1281: C633 is  Contravariant by L643;
L1282: (the ObjectMap of C633) is  Contravariant by L1281 , L392;
consider C634 being (Function of (the carrier of C631) , (the carrier of C632)) such that L1283: (the ObjectMap of C633) = ( ~ [: C634 , C634 :] ) by L1282 , L258;
L1284: [: C634 , C634 :] is  one-to-one by L1270 , L1283 , L135;
L1285: C634 is  one-to-one by L1284 , L106;
L1286: ( dom ( C634 " ) ) = ( rng C634 ) by L1285 , FUNCT_1:33;
L1287: ( rng ( C634 " ) ) = ( dom C634 ) by L1285 , FUNCT_1:33;
L1288: [: C634 , C634 :] is  onto by L1277 , L1283 , L238;
L1289: ( rng [: C634 , C634 :] ) = [: (the carrier of C632) , (the carrier of C632) :] by L1288 , FUNCT_2:def 3;
L1290: ( rng [: C634 , C634 :] ) = [: ( rng C634 ) , ( rng C634 ) :] by FUNCT_3:67;
L1291: ( rng C634 ) = (the carrier of C632) by L1290 , L1289 , ZFMISC_1:92;
reconsider D169 = ( C634 " ) as (Function of (the carrier of C632) , (the carrier of C631)) by L1291 , L1286 , L1287 , FUNCT_2:def 1 , RELSET_1:4;
take D169;
L1292: ( [: C634 , C634 :] " ) = [: D169 , D169 :] by L1285 , L85;
thus L1293: (the ObjectMap of ( C633 " )) = ( (the ObjectMap of C633) " ) by L1267 , L858
.= ( ~ [: D169 , D169 :] ) by L1283 , L1285 , L1292 , L158;
end;
L1294: ( C633 " ) is  id-preserving by L1267 , L1271 , L1273 , L1279 , L946;
L1295: ( C633 " ) is  comp-reversing by L1267 , L1271 , L1274 , L1278 , L1279 , L1132;
reconsider D170 = ( C633 " ) as (Functor of C632 , C631) by L1295 , L1272 , L1280 , L1294 , L639;
take D170;
thus L1296: D170 = ( C633 " );
thus L1297: D170 is  bijective by L1267 , L1271 , L871;
thus L1298: D170 is  Contravariant by L1280;
thus L1299: thesis by L1267 , L1271 , L1274 , L1278 , L1279 , L1132;
end;
definition
let C635 , C636 being  transitive  with_units non  empty AltCatStr;
pred C635 , C636 are_isomorphic 
means
(ex B295 being (Functor of C635 , C636) st B295 is  bijective  covariant)
;reflexivity
proof
let C637 being  transitive  with_units non  empty AltCatStr;
take ( id C637 );
thus L1300: thesis;
end;
symmetry
proof
let C638 , C639 being  transitive  with_units non  empty AltCatStr;
given C640 being (Functor of C638 , C639) such that
L1301: C640 is  bijective  covariant;

consider C641 being (Functor of C639 , C638) such that L1302: C641 = ( C640 " ) and L1303: C641 is  bijective  covariant by L1301 , L1234;
take C641;
thus L1304: thesis by L1303;
end;
pred C635 , C636 are_anti-isomorphic 
means
(ex B296 being (Functor of C635 , C636) st B296 is  bijective  contravariant)
;symmetry
proof
let C642 , C643 being  transitive  with_units non  empty AltCatStr;
given C644 being (Functor of C642 , C643) such that
L1305: C644 is  bijective  contravariant;

consider C645 being (Functor of C643 , C642) such that L1306: C645 = ( C644 " ) and L1307: C645 is  bijective  contravariant by L1305 , L1266;
take C645;
thus L1308: thesis by L1307;
end;
end;
