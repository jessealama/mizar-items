:: Axiomatization of {B}oolean Algebras Based on Sheffer Stroke
::  by Violetta Kozarkiewicz and Adam Grabowski
::
:: Received May 31, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies LATTICES, ROBBINS1, XBOOLE_0, SUBSET_1, ARYTM_3, EQREL_1, PBOOLE,
      STRUCT_0, BINOP_1, FUNCT_5, RELAT_1, FUNCT_1, SHEFFER1, CARD_1;
 notations TARSKI, XBOOLE_0, FUNCT_5, CARD_1, STRUCT_0, LATTICES, BINOP_1,
      ROBBINS1;
 constructors BINOP_1, ROBBINS1, FUNCT_5;
 registrations LATTICES, LATTICE6, ROBBINS1, CARD_1, STRUCT_0;
 definitions LATTICES, ROBBINS1, STRUCT_0;
 theorems STRUCT_0, ROBBINS1, LATTICES, CARD_1;

begin
theorem
L1: (for B1 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr holds (for B2 , B3 being (Element of B1) holds ( ( B2 + B3 ) ` ) = ( ( B2 ` ) *' ( B3 ` ) )))
proof
let C1 being  join-commutative  join-associative  Huntington non  empty ComplLLattStr;
let C2 , C3 being (Element of C1);
L2: ( C2 + C3 ) = ( ( ( C2 ` ) *' ( C3 ` ) ) ` ) by ROBBINS1:17;
thus L3: thesis by L2 , ROBBINS1:3;
end;
begin
definition
let C4 being non  empty LattStr;
attr C4 is  upper-bounded'
means
:L4: (ex B4 being (Element of C4) st (for B5 being (Element of C4) holds (( B4 "/\" B5 ) = B5 & ( B5 "/\" B4 ) = B5)));
end;
definition
let C5 being non  empty LattStr;
assume L6: C5 is  upper-bounded';
func Top' C5 -> (Element of C5) means 
:L7: (for B6 being (Element of C5) holds (( it "/\" B6 ) = B6 & ( B6 "/\" it ) = B6));
existence by L6 , L4;
uniqueness
proof
let C6 , C7 being (Element of C5);
assume that
L8: (for B7 being (Element of C5) holds (( C6 "/\" B7 ) = B7 & ( B7 "/\" C6 ) = B7))
and
L9: (for B8 being (Element of C5) holds (( C7 "/\" B8 ) = B8 & ( B8 "/\" C7 ) = B8));
thus L10: C6 = ( C7 "/\" C6 ) by L9
.= C7 by L8;
end;
end;
definition
let C8 being non  empty LattStr;
attr C8 is  lower-bounded'
means
:L12: (ex B9 being (Element of C8) st (for B10 being (Element of C8) holds (( B9 "\/" B10 ) = B10 & ( B10 "\/" B9 ) = B10)));
end;
definition
let C9 being non  empty LattStr;
assume L14: C9 is  lower-bounded';
func Bot' C9 -> (Element of C9) means 
:L15: (for B11 being (Element of C9) holds (( it "\/" B11 ) = B11 & ( B11 "\/" it ) = B11));
existence by L14 , L12;
uniqueness
proof
let C10 , C11 being (Element of C9);
assume that
L16: (for B12 being (Element of C9) holds (( C10 "\/" B12 ) = B12 & ( B12 "\/" C10 ) = B12))
and
L17: (for B13 being (Element of C9) holds (( C11 "\/" B13 ) = B13 & ( B13 "\/" C11 ) = B13));
thus L18: C10 = ( C11 "\/" C10 ) by L17
.= C11 by L16;
end;
end;
definition
let C12 being non  empty LattStr;
attr C12 is  distributive'
means
:L20: (for B14 , B15 , B16 being (Element of C12) holds ( B14 "\/" ( B15 "/\" B16 ) ) = ( ( B14 "\/" B15 ) "/\" ( B14 "\/" B16 ) ));
end;
definition
let C13 being non  empty LattStr;
let C14 , C15 being (Element of C13);
pred C14 is_a_complement'_of C15
means
:L22: (( C15 "\/" C14 ) = ( Top' C13 ) & ( C14 "\/" C15 ) = ( Top' C13 ) & ( C15 "/\" C14 ) = ( Bot' C13 ) & ( C14 "/\" C15 ) = ( Bot' C13 ))
;end;
definition
let C16 being non  empty LattStr;
attr C16 is  complemented'
means
:L24: (for B17 being (Element of C16) holds (ex B18 being (Element of C16) st B18 is_a_complement'_of B17));
end;
definition
let C17 being non  empty LattStr;
let C18 being (Element of C17);
assume L26: C17 is  complemented'  distributive  upper-bounded'  meet-commutative;
func C18 `# -> (Element of C17) means 
:L27: it is_a_complement'_of C18;
existence by L26 , L24;
uniqueness
proof
let C19 , C20 being (Element of C17);
assume that
L28: C19 is_a_complement'_of C18
and
L29: C20 is_a_complement'_of C18;
L30: C20 = ( C20 "/\" ( Top' C17 ) ) by L26 , L7
.= ( C20 "/\" ( C18 "\/" C19 ) ) by L28 , L22
.= ( ( C20 "/\" C18 ) "\/" ( C20 "/\" C19 ) ) by L26 , LATTICES:def 11
.= ( ( C18 "/\" C20 ) "\/" ( C20 "/\" C19 ) ) by L26 , LATTICES:def 6
.= ( ( C18 "/\" C20 ) "\/" ( C19 "/\" C20 ) ) by L26 , LATTICES:def 6
.= ( ( Bot' C17 ) "\/" ( C19 "/\" C20 ) ) by L29 , L22
.= ( ( C19 "/\" C18 ) "\/" ( C19 "/\" C20 ) ) by L28 , L22
.= ( C19 "/\" ( C18 "\/" C20 ) ) by L26 , LATTICES:def 11
.= ( C19 "/\" ( Top' C17 ) ) by L29 , L22
.= C19 by L26 , L7;
thus L31: thesis by L30;
end;
end;
registration
cluster  Boolean  join-idempotent  upper-bounded'  complemented'  distributive'  lower-bounded'  Lattice-like for 1 -element 1 -element 1 -element 1 -element LattStr;
existence
proof
set D1 = the 1 -element Lattice;
L33: D1 is  lower-bounded
proof
set D2 = the (Element of D1);
L34: (for B19 being (Element of D1) holds (( D2 "/\" B19 ) = D2 & ( B19 "/\" D2 ) = D2)) by STRUCT_0:def 10;
thus L35: thesis by L34 , LATTICES:def 13;
end;
L36: D1 is  upper-bounded
proof
set D3 = the (Element of D1);
L37: (for B20 being (Element of D1) holds (( D3 "\/" B20 ) = D3 & ( B20 "\/" D3 ) = D3)) by STRUCT_0:def 10;
thus L38: thesis by L37 , LATTICES:def 14;
end;
L39: (for B21 being (Element of D1) holds (ex B22 being (Element of D1) st B22 is_a_complement_of B21))
proof
let C21 being (Element of D1);
take D4 = C21;
L40: (( C21 "\/" D4 ) = ( Top D1 ) & ( C21 "/\" D4 ) = ( Bottom D1 )) by STRUCT_0:def 10;
thus L41: thesis by L40 , LATTICES:def 18;
end;
L42: D1 is  complemented by L39 , LATTICES:def 19;
L43: D1 is  join-idempotent
proof
let C22 being (Element of D1);
thus L44: thesis;
end;
L45: (for B23 being (Element of D1) holds (ex B24 being (Element of D1) st B24 is_a_complement'_of B23))
proof
let C23 being (Element of D1);
take D5 = C23;
L46: (( C23 "\/" D5 ) = ( Top' D1 ) & ( C23 "/\" D5 ) = ( Bot' D1 )) by STRUCT_0:def 10;
thus L47: thesis by L46 , L22;
end;
L48: D1 is  complemented' by L45 , L24;
L49: (for B25 , B26 , B27 being (Element of D1) holds ( B25 "/\" ( B26 "\/" B27 ) ) = ( ( B25 "/\" B26 ) "\/" ( B25 "/\" B27 ) )) by STRUCT_0:def 10;
L50: D1 is  distributive by L49 , LATTICES:def 11;
L51: D1 is  lower-bounded'
proof
set D6 = the (Element of D1);
L52: (for B28 being (Element of D1) holds (( D6 "\/" B28 ) = B28 & ( B28 "\/" D6 ) = B28)) by STRUCT_0:def 10;
thus L53: thesis by L52 , L12;
end;
L54: D1 is  upper-bounded'
proof
set D7 = the (Element of D1);
L55: (for B29 being (Element of D1) holds (( D7 "/\" B29 ) = B29 & ( B29 "/\" D7 ) = B29)) by STRUCT_0:def 10;
thus L56: thesis by L55 , L4;
end;
L57: (for B30 , B31 , B32 being (Element of D1) holds ( B30 "\/" ( B31 "/\" B32 ) ) = ( ( B30 "\/" B31 ) "/\" ( B30 "\/" B32 ) )) by STRUCT_0:def 10;
L58: D1 is  distributive' by L57 , L20;
thus L59: thesis by L58 , L42 , L50 , L33 , L36 , L43 , L54 , L48 , L51;
end;
end;
theorem
L61: (for B33 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  distributive' non  empty LattStr holds (for B34 being (Element of B33) holds ( B34 "\/" ( B34 `# ) ) = ( Top' B33 )))
proof
let C24 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  distributive' non  empty LattStr;
let C25 being (Element of C24);
L62: ( C25 `# ) is_a_complement'_of C25 by L27;
thus L63: thesis by L62 , L22;
end;
theorem
L64: (for B35 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  distributive' non  empty LattStr holds (for B36 being (Element of B35) holds ( B36 "/\" ( B36 `# ) ) = ( Bot' B35 )))
proof
let C26 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  distributive' non  empty LattStr;
let C27 being (Element of C26);
L65: ( C27 `# ) is_a_complement'_of C27 by L27;
thus L66: thesis by L65 , L22;
end;
theorem
L67: (for B37 being  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  upper-bounded'  distributive' non  empty LattStr holds (for B38 being (Element of B37) holds ( B38 "\/" ( Top' B37 ) ) = ( Top' B37 )))
proof
let C28 being  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  upper-bounded'  distributive' non  empty LattStr;
let C29 being (Element of C28);
L68: ( C29 "\/" ( Top' C28 ) ) = ( ( C29 "\/" ( Top' C28 ) ) "/\" ( Top' C28 ) ) by L7
.= ( ( C29 "\/" ( Top' C28 ) ) "/\" ( C29 "\/" ( C29 `# ) ) ) by L61
.= ( C29 "\/" ( ( Top' C28 ) "/\" ( C29 `# ) ) ) by L20
.= ( C29 "\/" ( C29 `# ) ) by L7
.= ( Top' C28 ) by L61;
thus L69: thesis by L68;
end;
theorem
L70: (for B39 being  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  upper-bounded'  lower-bounded'  distributive' non  empty LattStr holds (for B40 being (Element of B39) holds ( B40 "/\" ( Bot' B39 ) ) = ( Bot' B39 )))
proof
let C30 being  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  upper-bounded'  lower-bounded'  distributive' non  empty LattStr;
let C31 being (Element of C30);
L71: ( C31 "/\" ( Bot' C30 ) ) = ( ( C31 "/\" ( Bot' C30 ) ) "\/" ( Bot' C30 ) ) by L15
.= ( ( C31 "/\" ( Bot' C30 ) ) "\/" ( C31 "/\" ( C31 `# ) ) ) by L64
.= ( C31 "/\" ( ( Bot' C30 ) "\/" ( C31 `# ) ) ) by LATTICES:def 11
.= ( C31 "/\" ( C31 `# ) ) by L15
.= ( Bot' C30 ) by L64;
thus L72: thesis by L71;
end;
theorem
L73: (for B41 being  join-commutative  meet-absorbing  meet-commutative  join-absorbing  join-idempotent  distributive non  empty LattStr holds (for B42 , B43 , B44 being (Element of B41) holds ( ( ( B42 "\/" B43 ) "\/" B44 ) "/\" B42 ) = B42))
proof
let C32 being  join-commutative  meet-absorbing  meet-commutative  join-absorbing  join-idempotent  distributive non  empty LattStr;
let C33 , C34 , C35 being (Element of C32);
L74: ( ( ( C33 "\/" C34 ) "\/" C35 ) "/\" C33 ) = ( ( C33 "/\" ( C33 "\/" C34 ) ) "\/" ( C33 "/\" C35 ) ) by LATTICES:def 11
.= ( ( ( C33 "/\" C33 ) "\/" ( C33 "/\" C34 ) ) "\/" ( C33 "/\" C35 ) ) by LATTICES:def 11
.= ( ( C33 "\/" ( C33 "/\" C34 ) ) "\/" ( C33 "/\" C35 ) )
.= ( C33 "\/" ( C33 "/\" C35 ) ) by LATTICES:def 8
.= C33 by LATTICES:def 8;
thus L75: thesis by L74;
end;
theorem
L76: (for B45 being  join-commutative  meet-absorbing  meet-commutative  join-absorbing  join-idempotent  distributive' non  empty LattStr holds (for B46 , B47 , B48 being (Element of B45) holds ( ( ( B46 "/\" B47 ) "/\" B48 ) "\/" B46 ) = B46))
proof
let C36 being  join-commutative  meet-absorbing  meet-commutative  join-absorbing  join-idempotent  distributive' non  empty LattStr;
let C37 , C38 , C39 being (Element of C36);
L77: ( ( ( C37 "/\" C38 ) "/\" C39 ) "\/" C37 ) = ( ( C37 "\/" ( C37 "/\" C38 ) ) "/\" ( C37 "\/" C39 ) ) by L20
.= ( ( ( C37 "\/" C37 ) "/\" ( C37 "\/" C38 ) ) "/\" ( C37 "\/" C39 ) ) by L20
.= ( ( C37 "/\" ( C37 "\/" C38 ) ) "/\" ( C37 "\/" C39 ) )
.= ( C37 "/\" ( C37 "\/" C39 ) ) by LATTICES:def 9
.= C37 by LATTICES:def 9;
thus L78: thesis by L77;
end;
definition
let C40 being non  empty /\-SemiLattStr;
attr C40 is  meet-idempotent
means
:L79: (for B49 being (Element of C40) holds ( B49 "/\" B49 ) = B49);
end;
theorem
L81: (for B50 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  lower-bounded'  distributive' non  empty LattStr holds B50 is  meet-idempotent)
proof
let C41 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  lower-bounded'  distributive' non  empty LattStr;
L82:
now
let C42 being (Element of C41);
thus L83: ( C42 "/\" C42 ) = ( ( C42 "/\" C42 ) "\/" ( Bot' C41 ) ) by L15
.= ( ( C42 "/\" C42 ) "\/" ( C42 "/\" ( C42 `# ) ) ) by L64
.= ( C42 "/\" ( C42 "\/" ( C42 `# ) ) ) by LATTICES:def 11
.= ( C42 "/\" ( Top' C41 ) ) by L61
.= C42 by L7;
end;
thus L84: thesis by L82 , L79;
end;
theorem
L85: (for B51 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  lower-bounded'  distributive' non  empty LattStr holds B51 is  join-idempotent)
proof
let C43 being  complemented'  join-commutative  meet-commutative  distributive  upper-bounded'  lower-bounded'  distributive' non  empty LattStr;
let C44 being (Element of C43);
thus L86: ( C44 "\/" C44 ) = ( ( C44 "\/" C44 ) "/\" ( Top' C43 ) ) by L7
.= ( ( C44 "\/" C44 ) "/\" ( C44 "\/" ( C44 `# ) ) ) by L61
.= ( C44 "\/" ( C44 "/\" ( C44 `# ) ) ) by L20
.= ( C44 "\/" ( Bot' C43 ) ) by L64
.= C44 by L15;
end;
theorem
L87: (for B52 being  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  upper-bounded'  distributive' non  empty LattStr holds B52 is  meet-absorbing)
proof
let C45 being  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  upper-bounded'  distributive' non  empty LattStr;
let C46 , C47 being (Element of C45);
L88: ( C47 "\/" ( C47 "/\" C46 ) ) = ( ( ( Top' C45 ) "/\" C47 ) "\/" ( C47 "/\" C46 ) ) by L7
.= ( C47 "/\" ( ( Top' C45 ) "\/" C46 ) ) by LATTICES:def 11
.= ( C47 "/\" ( Top' C45 ) ) by L67
.= C47 by L7;
thus L89: thesis by L88;
end;
theorem
L90: (for B53 being  complemented'  join-commutative  upper-bounded'  meet-commutative  join-idempotent  distributive  distributive'  lower-bounded' non  empty LattStr holds B53 is  join-absorbing)
proof
let C48 being  complemented'  join-commutative  upper-bounded'  meet-commutative  join-idempotent  distributive  distributive'  lower-bounded' non  empty LattStr;
let C49 , C50 being (Element of C48);
L91: C48 is  meet-idempotent by L81;
L92: C48 is  meet-absorbing by L87;
L93: ( C49 "/\" ( C49 "\/" C50 ) ) = ( ( C49 "/\" C49 ) "\/" ( C49 "/\" C50 ) ) by LATTICES:def 11
.= ( C49 "\/" ( C49 "/\" C50 ) ) by L91 , L79
.= C49 by L92 , LATTICES:def 8;
thus L94: thesis by L93;
end;
theorem
L95: (for B54 being  complemented'  join-commutative  meet-commutative  upper-bounded'  lower-bounded'  join-idempotent  distributive  distributive' non  empty LattStr holds B54 is  upper-bounded)
proof
let C51 being  complemented'  join-commutative  meet-commutative  upper-bounded'  lower-bounded'  join-idempotent  distributive  distributive' non  empty LattStr;
L96: (ex B55 being (Element of C51) st (for B56 being (Element of C51) holds (( B55 "\/" B56 ) = B55 & ( B56 "\/" B55 ) = B55)))
proof
take ( Top' C51 );
let C52 being (Element of C51);
thus L97: thesis by L67;
end;
thus L98: thesis by L96 , LATTICES:def 14;
end;
theorem
L99: (for B57 being  Boolean  Lattice-like non  empty LattStr holds B57 is  upper-bounded')
proof
let C53 being  Boolean  Lattice-like non  empty LattStr;
L100: (ex B58 being (Element of C53) st (for B59 being (Element of C53) holds (( B58 "/\" B59 ) = B59 & ( B59 "/\" B58 ) = B59)))
proof
take D8 = ( Top C53 );
let C54 being (Element of C53);
L101: C54 [= D8 by LATTICES:19;
thus L102: thesis by L101 , LATTICES:4;
end;
thus L103: thesis by L100 , L4;
end;
theorem
L104: (for B60 being  complemented'  join-commutative  meet-commutative  upper-bounded'  lower-bounded'  join-idempotent  distributive  distributive' non  empty LattStr holds B60 is  lower-bounded)
proof
let C55 being  complemented'  join-commutative  meet-commutative  upper-bounded'  lower-bounded'  join-idempotent  distributive  distributive' non  empty LattStr;
L105: (ex B61 being (Element of C55) st (for B62 being (Element of C55) holds (( B61 "/\" B62 ) = B61 & ( B62 "/\" B61 ) = B61)))
proof
take ( Bot' C55 );
let C56 being (Element of C55);
thus L106: thesis by L70;
end;
thus L107: thesis by L105 , LATTICES:def 13;
end;
theorem
L108: (for B63 being  Boolean  Lattice-like non  empty LattStr holds B63 is  lower-bounded')
proof
let C57 being  Boolean  Lattice-like non  empty LattStr;
L109: (ex B64 being (Element of C57) st (for B65 being (Element of C57) holds (( B64 "\/" B65 ) = B65 & ( B65 "\/" B64 ) = B65)))
proof
take D9 = ( Bottom C57 );
let C58 being (Element of C57);
L110: D9 [= C58 by LATTICES:16;
thus L111: thesis by L110 , LATTICES:def 3;
end;
thus L112: thesis by L109 , L12;
end;
theorem
L113: (for B66 being  join-commutative  meet-commutative  meet-absorbing  join-absorbing  join-idempotent  distributive non  empty LattStr holds B66 is  join-associative)
proof
let C59 being  join-commutative  meet-commutative  meet-absorbing  join-absorbing  join-idempotent  distributive non  empty LattStr;
let C60 , C61 , C62 being (Element of C59);
L114: ( ( ( C61 "\/" C62 ) "\/" C60 ) "/\" C61 ) = ( ( C61 "/\" ( C61 "\/" C62 ) ) "\/" ( C61 "/\" C60 ) ) by LATTICES:def 11
.= ( ( ( C61 "/\" C61 ) "\/" ( C61 "/\" C62 ) ) "\/" ( C61 "/\" C60 ) ) by LATTICES:def 11
.= ( ( C61 "\/" ( C61 "/\" C62 ) ) "\/" ( C61 "/\" C60 ) )
.= ( C61 "\/" ( C61 "/\" C60 ) ) by LATTICES:def 8
.= C61 by LATTICES:def 8;
L115: ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" C60 ) = C60 by L73;
L116: ( C60 "\/" ( C61 "\/" C62 ) ) = ( ( C60 "\/" C61 ) "\/" C62 )
proof
set D10 = ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" ( C60 "\/" ( C61 "\/" C62 ) ) );
L117: D10 = ( ( ( C60 "\/" C61 ) "/\" ( C60 "\/" ( C61 "\/" C62 ) ) ) "\/" ( C62 "/\" ( C60 "\/" ( C61 "\/" C62 ) ) ) ) by LATTICES:def 11
.= ( ( ( C60 "\/" C61 ) "/\" ( C60 "\/" ( C61 "\/" C62 ) ) ) "\/" C62 ) by L73
.= ( ( ( C60 "/\" ( C60 "\/" ( C61 "\/" C62 ) ) ) "\/" ( C61 "/\" ( C60 "\/" ( C61 "\/" C62 ) ) ) ) "\/" C62 ) by LATTICES:def 11
.= ( ( C60 "\/" C61 ) "\/" C62 ) by L114 , LATTICES:def 9;
L118: D10 = ( ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" C60 ) "\/" ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" ( C61 "\/" C62 ) ) ) by LATTICES:def 11
.= ( C60 "\/" ( ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" C61 ) "\/" ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" C62 ) ) ) by L115 , LATTICES:def 11
.= ( C60 "\/" ( C61 "\/" ( ( ( C60 "\/" C61 ) "\/" C62 ) "/\" C62 ) ) ) by L73
.= ( C60 "\/" ( C61 "\/" ( ( ( C60 "\/" C61 ) "/\" C62 ) "\/" ( C62 "/\" C62 ) ) ) ) by LATTICES:def 11
.= ( C60 "\/" ( C61 "\/" ( ( ( C60 "\/" C61 ) "/\" C62 ) "\/" C62 ) ) )
.= ( C60 "\/" ( C61 "\/" C62 ) ) by LATTICES:def 8;
thus L119: thesis by L118 , L117;
end;
thus L120: thesis by L116;
end;
theorem
L121: (for B67 being  join-commutative  meet-commutative  meet-absorbing  join-absorbing  join-idempotent  distributive' non  empty LattStr holds B67 is  meet-associative)
proof
let C63 being  join-commutative  meet-commutative  meet-absorbing  join-absorbing  join-idempotent  distributive' non  empty LattStr;
let C64 , C65 , C66 being (Element of C63);
L122: ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" C64 ) = C64 by L76;
L123: ( ( ( C65 "/\" C66 ) "/\" C64 ) "\/" C65 ) = ( ( C65 "\/" ( C65 "/\" C66 ) ) "/\" ( C65 "\/" C64 ) ) by L20
.= ( ( ( C65 "\/" C65 ) "/\" ( C65 "\/" C66 ) ) "/\" ( C65 "\/" C64 ) ) by L20
.= ( ( C65 "/\" ( C65 "\/" C66 ) ) "/\" ( C65 "\/" C64 ) )
.= ( C65 "/\" ( C65 "\/" C64 ) ) by LATTICES:def 9
.= C65 by LATTICES:def 9;
L124: ( C64 "/\" ( C65 "/\" C66 ) ) = ( ( C64 "/\" C65 ) "/\" C66 )
proof
set D11 = ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" ( C64 "/\" ( C65 "/\" C66 ) ) );
L125: D11 = ( ( ( C64 "/\" C65 ) "\/" ( C64 "/\" ( C65 "/\" C66 ) ) ) "/\" ( C66 "\/" ( C64 "/\" ( C65 "/\" C66 ) ) ) ) by L20
.= ( ( ( C64 "/\" C65 ) "\/" ( C64 "/\" ( C65 "/\" C66 ) ) ) "/\" C66 ) by L76
.= ( ( ( C64 "\/" ( C64 "/\" ( C65 "/\" C66 ) ) ) "/\" ( C65 "\/" ( C64 "/\" ( C65 "/\" C66 ) ) ) ) "/\" C66 ) by L20
.= ( ( C64 "/\" C65 ) "/\" C66 ) by L123 , LATTICES:def 8;
L126: D11 = ( ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" C64 ) "/\" ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" ( C65 "/\" C66 ) ) ) by L20
.= ( C64 "/\" ( ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" C65 ) "/\" ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" C66 ) ) ) by L122 , L20
.= ( C64 "/\" ( C65 "/\" ( ( ( C64 "/\" C65 ) "/\" C66 ) "\/" C66 ) ) ) by L76
.= ( C64 "/\" ( C65 "/\" ( ( ( C64 "/\" C65 ) "\/" C66 ) "/\" ( C66 "\/" C66 ) ) ) ) by L20
.= ( C64 "/\" ( C65 "/\" ( ( ( C64 "/\" C65 ) "\/" C66 ) "/\" C66 ) ) )
.= ( C64 "/\" ( C65 "/\" C66 ) ) by LATTICES:def 9;
thus L127: thesis by L126 , L125;
end;
thus L128: thesis by L124;
end;
theorem
L129: (for B68 being  complemented'  join-commutative  meet-commutative  lower-bounded'  upper-bounded'  join-idempotent  distributive  distributive' non  empty LattStr holds ( Top B68 ) = ( Top' B68 ))
proof
let C67 being  complemented'  join-commutative  meet-commutative  lower-bounded'  upper-bounded'  join-idempotent  distributive  distributive' non  empty LattStr;
set D12 = ( Top' C67 );
L130: (C67 is  upper-bounded & (for B69 being (Element of C67) holds (( D12 "\/" B69 ) = D12 & ( B69 "\/" D12 ) = D12))) by L67 , L95;
thus L131: thesis by L130 , LATTICES:def 17;
end;
theorem
L132: (for B70 being  complemented'  join-commutative  meet-commutative  lower-bounded'  upper-bounded'  join-idempotent  distributive  distributive' non  empty LattStr holds ( Bottom B70 ) = ( Bot' B70 ))
proof
let C68 being  complemented'  join-commutative  meet-commutative  lower-bounded'  upper-bounded'  join-idempotent  distributive  distributive' non  empty LattStr;
set D13 = ( Bot' C68 );
L133: (C68 is  lower-bounded & (for B71 being (Element of C68) holds (( D13 "/\" B71 ) = D13 & ( B71 "/\" D13 ) = D13))) by L70 , L104;
thus L134: thesis by L133 , LATTICES:def 16;
end;
theorem
L135: (for B72 being  Boolean  distributive'  Lattice-like non  empty LattStr holds ( Top B72 ) = ( Top' B72 ))
proof
let C69 being  Boolean  distributive'  Lattice-like non  empty LattStr;
set D14 = ( Top C69 );
L136: (C69 is  upper-bounded' & (for B73 being (Element of C69) holds (( D14 "/\" B73 ) = B73 & ( B73 "/\" D14 ) = B73))) by L99;
thus L137: thesis by L136 , L7;
end;
theorem
L138: (for B74 being  Boolean  complemented  lower-bounded  upper-bounded  distributive  distributive'  Lattice-like non  empty LattStr holds ( Bottom B74 ) = ( Bot' B74 ))
proof
let C70 being  Boolean  complemented  lower-bounded  upper-bounded  distributive  distributive'  Lattice-like non  empty LattStr;
set D15 = ( Bottom C70 );
L139: (C70 is  lower-bounded' & (for B75 being (Element of C70) holds (( D15 "\/" B75 ) = B75 & ( B75 "\/" D15 ) = B75))) by L108;
thus L140: thesis by L139 , L15;
end;
theorem
L141: (for B76 being  complemented'  lower-bounded'  upper-bounded'  join-commutative  meet-commutative  join-idempotent  distributive  distributive' non  empty LattStr holds (for B77 , B78 being (Element of B76) holds (B77 is_a_complement'_of B78 iff B77 is_a_complement_of B78)))
proof
let C71 being  complemented'  lower-bounded'  upper-bounded'  join-commutative  meet-commutative  join-idempotent  distributive  distributive' non  empty LattStr;
let C72 , C73 being (Element of C71);
thus L142:now
assume L143: C72 is_a_complement'_of C73;
L144: ( C72 "/\" C73 ) = ( Bot' C71 ) by L143 , L22;
L145: ( C72 "/\" C73 ) = ( Bottom C71 ) by L144 , L132;
L146: ( C72 "\/" C73 ) = ( Top' C71 ) by L143 , L22;
L147: ( C72 "\/" C73 ) = ( Top C71 ) by L146 , L129;
thus L148: C72 is_a_complement_of C73 by L147 , L145 , LATTICES:def 18;
end;
assume L149: C72 is_a_complement_of C73;
L150: ( C72 "/\" C73 ) = ( Bottom C71 ) by L149 , LATTICES:def 18;
L151: ( C72 "/\" C73 ) = ( Bot' C71 ) by L150 , L132;
L152: ( C72 "\/" C73 ) = ( Top C71 ) by L149 , LATTICES:def 18;
L153: ( C72 "\/" C73 ) = ( Top' C71 ) by L152 , L129;
thus L154: thesis by L153 , L151 , L22;
end;
theorem
L155: (for B79 being  complemented'  join-commutative  meet-commutative  lower-bounded'  upper-bounded'  join-idempotent  distributive  distributive' non  empty LattStr holds B79 is  complemented)
proof
let C74 being  complemented'  join-commutative  meet-commutative  lower-bounded'  upper-bounded'  join-idempotent  distributive  distributive' non  empty LattStr;
L156: (for B80 being (Element of C74) holds (ex B81 being (Element of C74) st B81 is_a_complement_of B80))
proof
let C75 being (Element of C74);
consider C76 being (Element of C74) such that L157: C76 is_a_complement'_of C75 by L24;
L158: ( C75 "/\" C76 ) = ( Bot' C74 ) by L157 , L22;
L159: ( C75 "/\" C76 ) = ( Bottom C74 ) by L158 , L132;
L160: ( C75 "\/" C76 ) = ( Top' C74 ) by L157 , L22;
L161: ( C75 "\/" C76 ) = ( Top C74 ) by L160 , L129;
L162: C76 is_a_complement_of C75 by L161 , L159 , LATTICES:def 18;
thus L163: thesis by L162;
end;
thus L164: thesis by L156 , LATTICES:def 19;
end;
theorem
L165: (for B82 being  Boolean  lower-bounded'  upper-bounded'  distributive'  Lattice-like non  empty LattStr holds B82 is  complemented')
proof
let C77 being  Boolean  lower-bounded'  upper-bounded'  distributive'  Lattice-like non  empty LattStr;
L166: (for B83 being (Element of C77) holds (ex B84 being (Element of C77) st B84 is_a_complement'_of B83))
proof
let C78 being (Element of C77);
consider C79 being (Element of C77) such that L167: C79 is_a_complement_of C78 by LATTICES:def 19;
L168: ( C78 "/\" C79 ) = ( Bottom C77 ) by L167 , LATTICES:def 18;
L169: ( C78 "/\" C79 ) = ( Bot' C77 ) by L168 , L138;
L170: ( C78 "\/" C79 ) = ( Top C77 ) by L167 , LATTICES:def 18;
L171: ( C78 "\/" C79 ) = ( Top' C77 ) by L170 , L135;
L172: C79 is_a_complement'_of C78 by L171 , L169 , L22;
thus L173: thesis by L172;
end;
thus L174: thesis by L166 , L24;
end;
theorem
L175: (for B85 being non  empty LattStr holds (B85 is  Boolean  Boolean  Boolean  Boolean Lattice iff B85 is  lower-bounded'  upper-bounded'  join-commutative  meet-commutative  distributive  distributive'  complemented'))
proof
let C80 being non  empty LattStr;
thus L176: (C80 is  Boolean  Boolean  Boolean  Boolean Lattice implies C80 is  lower-bounded'  upper-bounded'  join-commutative  meet-commutative  distributive  distributive'  complemented')
proof
assume L177: C80 is  Boolean  Boolean  Boolean  Boolean Lattice;
reconsider D16 = C80 as  Boolean Lattice by L177;
L178: (ex B86 being (Element of D16) st (for B87 being (Element of D16) holds (( B86 "\/" B87 ) = B87 & ( B87 "\/" B86 ) = B87)))
proof
take ( Bottom D16 );
thus L179: thesis;
end;
thus L180: C80 is  lower-bounded' by L178 , L12;
L181: (ex B88 being (Element of D16) st (for B89 being (Element of D16) holds (( B88 "/\" B89 ) = B89 & ( B89 "/\" B88 ) = B89)))
proof
take ( Top D16 );
thus L182: thesis;
end;
thus L183: C80 is  upper-bounded' by L181 , L4;
thus L184: C80 is  join-commutative  meet-commutative by L177;
L185: (for B90 , B91 , B92 being (Element of D16) holds ( B90 "/\" ( B91 "\/" B92 ) ) = ( ( B90 "/\" B91 ) "\/" ( B90 "/\" B92 ) )) by LATTICES:def 11;
L186: (for B93 , B94 , B95 being (Element of D16) holds ( B93 "\/" ( B94 "/\" B95 ) ) = ( ( B93 "\/" B94 ) "/\" ( B93 "\/" B95 ) )) by L185 , LATTICES:3;
thus L187: C80 is  distributive  distributive' by L186 , L20;
thus L188: thesis by L187 , L177 , L180 , L183 , L165;
end;

thus L189: (C80 is  lower-bounded'  upper-bounded'  join-commutative  meet-commutative  distributive  distributive'  complemented' implies C80 is  Boolean  Boolean  Boolean  Boolean Lattice)
proof
assume L190: C80 is  lower-bounded'  upper-bounded'  join-commutative  meet-commutative  distributive  distributive'  complemented';
reconsider D17 = C80 as  lower-bounded'  upper-bounded'  complemented'  join-commutative  meet-commutative  join-idempotent  distributive  distributive' non  empty LattStr by L190 , L85;
L191: D17 is  complemented by L155;
L192: (D17 is  lower-bounded & D17 is  upper-bounded) by L95 , L104;
L193: D17 is  meet-absorbing  join-absorbing by L87 , L90;
L194: (D17 is  join-associative & D17 is  meet-associative) by L193 , L113 , L121;
thus L195: thesis by L194 , L192 , L191 , L193;
end;

end;
registration
cluster  Boolean  Lattice-like ->  lower-bounded'  upper-bounded'  complemented'  join-commutative  meet-commutative  distributive  distributive' for non  empty non  empty non  empty non  empty LattStr;
coherence by L175;
cluster  lower-bounded'  upper-bounded'  complemented'  join-commutative  meet-commutative  distributive  distributive' ->  Boolean  Lattice-like for non  empty non  empty non  empty non  empty LattStr;
coherence by L175;
end;
begin
definition
struct (1-sorted) ShefferStr(# carrier -> set , stroke -> (BinOp of the carrier) #);
end;
definition
struct (ShefferStr , LattStr) ShefferLattStr(# carrier -> set , L_join -> (BinOp of the carrier) , L_meet -> (BinOp of the carrier) , stroke -> (BinOp of the carrier) #);
end;
definition
struct (ShefferStr , OrthoLattStr) ShefferOrthoLattStr(# carrier -> set , L_join -> (BinOp of the carrier) , L_meet -> (BinOp of the carrier) , Compl -> (UnOp of the carrier) , stroke -> (BinOp of the carrier) #);
end;
definition
func TrivShefferOrthoLattStr -> ShefferOrthoLattStr equals 
ShefferOrthoLattStr (# 1 , ( op2 ) , ( op2 ) , ( op1 ) , ( op2 ) #);
coherence;
end;
registration
cluster 1 -element for ShefferStr;
existence
proof
set D18 = { ( {} ) };
set D19 = the (BinOp of D18);
take ShefferStr (# D18 , D19 #);
thus L195: (the carrier of ShefferStr (# D18 , D19 #)) is 1 -element;
end;
cluster 1 -element for ShefferLattStr;
existence
proof
set D20 = { ( {} ) };
set D21 = the (BinOp of D20);
take ShefferLattStr (# D20 , D21 , D21 , D21 #);
thus L196: (the carrier of ShefferLattStr (# D20 , D21 , D21 , D21 #)) is 1 -element;
end;
cluster 1 -element for ShefferOrthoLattStr;
existence
proof
set D22 = { ( {} ) };
set D23 = the (BinOp of D22);
set D24 = the (UnOp of D22);
take ShefferOrthoLattStr (# D22 , D23 , D23 , D24 , D23 #);
thus L197: (the carrier of ShefferOrthoLattStr (# D22 , D23 , D23 , D24 , D23 #)) is 1 -element;
end;
end;
definition
let C81 being non  empty ShefferStr;
let C82 , C83 being (Element of C81);
func C82 | C83 -> (Element of C81) equals 
( (the stroke of C81) . (C82 , C83) );
coherence;
end;
definition
let C84 being non  empty ShefferOrthoLattStr;
attr C84 is  properly_defined
means
:L200: ((for B96 being (Element of C84) holds ( B96 | B96 ) = ( B96 ` )) & (for B97 , B98 being (Element of C84) holds ( B97 "\/" B98 ) = ( ( B97 | B97 ) | ( B98 | B98 ) )) & (for B99 , B100 being (Element of C84) holds ( B99 "/\" B100 ) = ( ( B99 | B100 ) | ( B99 | B100 ) )) & (for B101 , B102 being (Element of C84) holds ( B101 | B102 ) = ( ( B101 ` ) + ( B102 ` ) )));
end;
definition
let C85 being non  empty ShefferStr;
attr C85 is  satisfying_Sheffer_1
means
:L202: (for B103 being (Element of C85) holds ( ( B103 | B103 ) | ( B103 | B103 ) ) = B103);
attr C85 is  satisfying_Sheffer_2
means
:L203: (for B104 , B105 being (Element of C85) holds ( B104 | ( B105 | ( B105 | B105 ) ) ) = ( B104 | B104 ));
attr C85 is  satisfying_Sheffer_3
means
:L204: (for B106 , B107 , B108 being (Element of C85) holds ( ( B106 | ( B107 | B108 ) ) | ( B106 | ( B107 | B108 ) ) ) = ( ( ( B107 | B107 ) | B106 ) | ( ( B108 | B108 ) | B106 ) ));
end;
registration
cluster  ->  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3 for 1 -element 1 -element 1 -element 1 -element ShefferStr;
coherence
proof
let C86 being 1 -element ShefferStr;
thus L206: C86 is  satisfying_Sheffer_1
proof
let C87 being (Element of C86);
thus L207: thesis by STRUCT_0:def 10;
end;

thus L208: C86 is  satisfying_Sheffer_2
proof
let C88 , C89 being (Element of C86);
thus L209: thesis by STRUCT_0:def 10;
end;

let C90 , C91 , C92 being (Element of C86);
thus L210: thesis by STRUCT_0:def 10;
end;
end;
registration
cluster  ->  join-commutative  join-associative for 1 -element 1 -element 1 -element 1 -element \/-SemiLattStr;
coherence
proof
let C93 being 1 -element \/-SemiLattStr;
thus L212: C93 is  join-commutative
proof
let C94 , C95 being (Element of C93);
thus L213: thesis by STRUCT_0:def 10;
end;

let C96 , C97 , C98 being (Element of C93);
thus L214: thesis by STRUCT_0:def 10;
end;
cluster  ->  meet-commutative  meet-associative for 1 -element 1 -element 1 -element 1 -element /\-SemiLattStr;
coherence
proof
let C99 being 1 -element /\-SemiLattStr;
thus L215: C99 is  meet-commutative
proof
let C100 , C101 being (Element of C99);
thus L216: thesis by STRUCT_0:def 10;
end;

let C102 , C103 , C104 being (Element of C99);
thus L217: thesis by STRUCT_0:def 10;
end;
end;
registration
cluster  ->  join-absorbing  meet-absorbing  Boolean for 1 -element 1 -element 1 -element 1 -element LattStr;
coherence
proof
let C105 being 1 -element LattStr;
thus L219: C105 is  join-absorbing
proof
let C106 , C107 being (Element of C105);
thus L220: thesis by STRUCT_0:def 10;
end;

L221: C105 is  upper-bounded
proof
set D25 = the (Element of C105);
take D25;
let C108 being (Element of C105);
thus L222: thesis by STRUCT_0:def 10;
end;
thus L223: C105 is  meet-absorbing
proof
let C109 , C110 being (Element of C105);
thus L224: thesis by STRUCT_0:def 10;
end;

L225: C105 is  lower-bounded
proof
set D26 = the (Element of C105);
take D26;
let C111 being (Element of C105);
thus L226: thesis by STRUCT_0:def 10;
end;
L227: C105 is  complemented
proof
set D27 = the (Element of C105);
let C112 being (Element of C105);
take D27;
L228: (( D27 "/\" C112 ) = ( Bottom C105 ) & ( C112 "/\" D27 ) = ( Bottom C105 )) by STRUCT_0:def 10;
L229: (( D27 "\/" C112 ) = ( Top C105 ) & ( C112 "\/" D27 ) = ( Top C105 )) by STRUCT_0:def 10;
thus L230: thesis by L229 , L228 , LATTICES:def 18;
end;
L231: C105 is  distributive
proof
let C113 , C114 , C115 being (Element of C105);
thus L232: thesis by STRUCT_0:def 10;
end;
thus L233: thesis by L231 , L225 , L221 , L227;
end;
end;
registration
cluster ( TrivShefferOrthoLattStr ) -> 1 -element;
coherence by CARD_1:49 , STRUCT_0:def 19;
cluster ( TrivShefferOrthoLattStr ) ->  properly_defined  well-complemented;
coherence
proof
set D28 = ( TrivShefferOrthoLattStr );
L235: ((for B109 , B110 being (Element of D28) holds ( B109 "/\" B110 ) = ( ( B109 | B110 ) | ( B109 | B110 ) )) & (for B111 , B112 being (Element of D28) holds ( B111 | B112 ) = ( ( B111 ` ) + ( B112 ` ) ))) by STRUCT_0:def 10;
L236: ((for B113 being (Element of D28) holds ( B113 | B113 ) = ( B113 ` )) & (for B114 , B115 being (Element of D28) holds ( B114 "\/" B115 ) = ( ( B114 | B114 ) | ( B115 | B115 ) ))) by STRUCT_0:def 10;
thus L237: D28 is  properly_defined by L236 , L235 , L200;
L238: D28 is  well-complemented
proof
let C116 being (Element of D28);
L239: (( C116 "\/" ( C116 ` ) ) = ( Top D28 ) & ( C116 "/\" ( C116 ` ) ) = ( Bottom D28 )) by STRUCT_0:def 10;
thus L240: thesis by L239 , LATTICES:def 18;
end;
thus L241: thesis by L238;
end;
end;
registration
cluster  properly_defined  Boolean  well-complemented  Lattice-like  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3 for non  empty non  empty non  empty non  empty ShefferOrthoLattStr;
existence
proof
take ( TrivShefferOrthoLattStr );
thus L243: thesis;
end;
end;
theorem
L245: (for B116 being  properly_defined  Boolean  well-complemented  Lattice-like non  empty ShefferOrthoLattStr holds B116 is  satisfying_Sheffer_1)
proof
let C117 being  properly_defined  Boolean  well-complemented  Lattice-like non  empty ShefferOrthoLattStr;
let C118 being (Element of C117);
L246: ( ( C118 ` ) ` ) = C118 by ROBBINS1:3;
L247: ( ( C118 | C118 ) ` ) = C118 by L246 , L200;
thus L248: thesis by L247 , L200;
end;
theorem
L249: (for B117 being  properly_defined  Boolean  well-complemented  Lattice-like non  empty ShefferOrthoLattStr holds B117 is  satisfying_Sheffer_2)
proof
let C119 being  properly_defined  Boolean  well-complemented  Lattice-like non  empty ShefferOrthoLattStr;
let C120 , C121 being (Element of C119);
L250: ( ( C120 ` ) + ( Bot C119 ) ) = ( C120 ` ) by ROBBINS1:13;
L251: ( ( C120 ` ) + ( ( ( C121 ` ) ` ) *' ( C121 ` ) ) ) = ( C120 ` ) by L250 , ROBBINS1:15;
L252: ( ( C120 ` ) + ( ( ( C121 ` ) + C121 ) ` ) ) = ( C120 ` ) by L251 , L1;
L253: ( C120 | ( ( C121 ` ) + C121 ) ) = ( C120 ` ) by L252 , L200;
L254: ( C120 | ( ( C121 ` ) + ( ( C121 ` ) ` ) ) ) = ( C120 ` ) by L253 , ROBBINS1:3;
L255: ( C120 | ( C121 | ( C121 ` ) ) ) = ( C120 ` ) by L254 , L200;
L256: ( C120 | ( C121 | ( C121 | C121 ) ) ) = ( C120 ` ) by L255 , L200
.= ( C120 | C120 ) by L200;
thus L257: thesis by L256;
end;
theorem
L258: (for B118 being  properly_defined  Boolean  well-complemented  Lattice-like non  empty ShefferOrthoLattStr holds B118 is  satisfying_Sheffer_3)
proof
let C122 being  properly_defined  Boolean  well-complemented  Lattice-like non  empty ShefferOrthoLattStr;
let C123 , C124 , C125 being (Element of C122);
L259: ( C123 *' ( ( C124 ` ) + ( C125 ` ) ) ) = ( ( ( C124 ` ) *' C123 ) + ( ( C125 ` ) *' C123 ) ) by ROBBINS1:30;
L260: ( ( ( C123 ` ) + ( ( C124 | C125 ) ` ) ) ` ) = ( ( ( C124 ` ) *' C123 ) + ( ( C125 ` ) *' C123 ) ) by L259 , L200;
L261: ( ( C123 | ( C124 | C125 ) ) ` ) = ( ( ( C124 ` ) *' C123 ) + ( ( C125 ` ) *' C123 ) ) by L260 , L200;
L262: ( ( C123 | ( C124 | C125 ) ) | ( C123 | ( C124 | C125 ) ) ) = ( ( ( C124 ` ) *' C123 ) + ( ( C125 ` ) *' C123 ) ) by L261 , L200
.= ( ( ( C124 ` ) *' ( ( C123 ` ) ` ) ) + ( ( C125 ` ) *' C123 ) ) by ROBBINS1:3
.= ( ( ( C124 ` ) *' ( ( C123 ` ) ` ) ) + ( ( C125 ` ) *' ( ( C123 ` ) ` ) ) ) by ROBBINS1:3
.= ( ( ( C124 + ( C123 ` ) ) ` ) + ( ( C125 ` ) *' ( ( C123 ` ) ` ) ) ) by L1
.= ( ( ( C124 + ( C123 ` ) ) ` ) + ( ( C125 + ( C123 ` ) ) ` ) ) by L1
.= ( ( C124 + ( C123 ` ) ) | ( C125 + ( C123 ` ) ) ) by L200
.= ( ( ( ( C124 ` ) ` ) + ( C123 ` ) ) | ( C125 + ( C123 ` ) ) ) by ROBBINS1:3
.= ( ( ( ( C124 ` ) ` ) + ( C123 ` ) ) | ( ( ( C125 ` ) ` ) + ( C123 ` ) ) ) by ROBBINS1:3
.= ( ( ( C124 ` ) | C123 ) | ( ( ( C125 ` ) ` ) + ( C123 ` ) ) ) by L200
.= ( ( ( C124 ` ) | C123 ) | ( ( C125 ` ) | C123 ) ) by L200
.= ( ( ( C124 | C124 ) | C123 ) | ( ( C125 ` ) | C123 ) ) by L200
.= ( ( ( C124 | C124 ) | C123 ) | ( ( C125 | C125 ) | C123 ) ) by L200;
thus L263: thesis by L262;
end;
definition
let C126 being non  empty ShefferStr;
let C127 being (Element of C126);
func C127 " -> (Element of C126) equals 
( C127 | C127 );
coherence;
end;
theorem
L265: (for B119 being  satisfying_Sheffer_3 non  empty ShefferOrthoLattStr holds (for B120 , B121 , B122 being (Element of B119) holds ( ( B120 | ( B121 | B122 ) ) " ) = ( ( ( B121 " ) | B120 ) | ( ( B122 " ) | B120 ) ))) by L204;
theorem
L266: (for B123 being  satisfying_Sheffer_1 non  empty ShefferOrthoLattStr holds (for B124 being (Element of B123) holds B124 = ( ( B124 " ) " ))) by L202;
theorem
L267: (for B125 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds (for B126 , B127 being (Element of B125) holds ( B126 | B127 ) = ( B127 | B126 )))
proof
let C128 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
let C129 , C130 being (Element of C128);
L268: ( C129 | C130 ) = ( ( ( C129 | C130 ) " ) " ) by L202
.= ( ( ( C129 | ( ( C130 " ) " ) ) " ) " ) by L202
.= ( ( ( ( ( C130 " ) " ) | C129 ) " ) " ) by L204
.= ( ( ( C130 | C129 ) " ) " ) by L202
.= ( C130 | C129 ) by L202;
thus L269: thesis by L268;
end;
theorem
L270: (for B128 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds (for B129 , B130 being (Element of B128) holds ( B129 | ( B129 | B129 ) ) = ( B130 | ( B130 | B130 ) )))
proof
let C131 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
let C132 , C133 being (Element of C131);
L271: ( C132 | ( C132 | C132 ) ) = ( ( ( C132 | ( C132 " ) ) | ( C132 | ( C132 " ) ) ) " ) by L202
.= ( ( ( C132 | ( C132 " ) ) | ( C133 | ( C133 " ) ) ) " ) by L203
.= ( ( ( C133 | ( C133 " ) ) | ( C132 | ( C132 | C132 ) ) ) " ) by L267
.= ( ( ( C133 | ( C133 " ) ) " ) " ) by L203
.= ( C133 | ( C133 | C133 ) ) by L202;
thus L272: thesis by L271;
end;
theorem
L273: (for B131 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds B131 is  join-commutative)
proof
let C134 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
let C135 , C136 being (Element of C134);
L274: ( C135 "\/" C136 ) = ( ( C135 " ) | ( C136 | C136 ) ) by L200
.= ( ( C136 | C136 ) | ( C135 | C135 ) ) by L267
.= ( C136 "\/" C135 ) by L200;
thus L275: thesis by L274;
end;
theorem
L276: (for B132 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds B132 is  meet-commutative)
proof
let C137 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
let C138 , C139 being (Element of C137);
L277: ( C138 "/\" C139 ) = ( ( C138 | C139 ) | ( C138 | C139 ) ) by L200
.= ( ( C139 | C138 ) | ( C138 | C139 ) ) by L267
.= ( ( C139 | C138 ) | ( C139 | C138 ) ) by L267
.= ( C139 "/\" C138 ) by L200;
thus L278: thesis by L277;
end;
theorem
L279: (for B133 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds B133 is  distributive)
proof
let C140 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
let C141 , C142 , C143 being (Element of C140);
set D29 = ( C142 " );
set D30 = ( C143 " );
L280: ( C141 "/\" ( C142 "\/" C143 ) ) = ( C141 "/\" ( ( C142 | C142 ) | ( C143 | C143 ) ) ) by L200
.= ( ( C141 | ( D29 | D30 ) ) " ) by L200
.= ( ( ( D29 " ) | C141 ) | ( ( D30 " ) | C141 ) ) by L204
.= ( ( C142 | C141 ) | ( ( D30 " ) | C141 ) ) by L202
.= ( ( C142 | C141 ) | ( C143 | C141 ) ) by L202
.= ( ( C141 | C142 ) | ( C143 | C141 ) ) by L267
.= ( ( C141 | C142 ) | ( C141 | C143 ) ) by L267
.= ( ( ( ( C141 | C142 ) " ) " ) | ( C141 | C143 ) ) by L202
.= ( ( ( ( C141 | C142 ) | ( C141 | C142 ) ) " ) | ( ( ( C141 | C143 ) " ) " ) ) by L202
.= ( ( ( C141 "/\" C142 ) | ( ( C141 | C142 ) | ( C141 | C142 ) ) ) | ( ( ( C141 | C143 ) | ( C141 | C143 ) ) | ( ( C141 | C143 ) | ( C141 | C143 ) ) ) ) by L200
.= ( ( ( C141 "/\" C142 ) | ( C141 "/\" C142 ) ) | ( ( ( C141 | C143 ) | ( C141 | C143 ) ) | ( ( C141 | C143 ) | ( C141 | C143 ) ) ) ) by L200
.= ( ( ( C141 "/\" C142 ) | ( C141 "/\" C142 ) ) | ( ( C141 "/\" C143 ) | ( ( C141 | C143 ) | ( C141 | C143 ) ) ) ) by L200
.= ( ( ( C141 "/\" C142 ) | ( C141 "/\" C142 ) ) | ( ( C141 "/\" C143 ) | ( C141 "/\" C143 ) ) ) by L200
.= ( ( C141 "/\" C142 ) "\/" ( C141 "/\" C143 ) ) by L200;
thus L281: thesis by L280;
end;
theorem
L282: (for B134 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds B134 is  distributive')
proof
let C144 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
let C145 , C146 , C147 being (Element of C144);
set D31 = ( C145 | C145 );
L283: ( C145 "\/" ( C146 "/\" C147 ) ) = ( C145 "\/" ( ( C146 | C147 ) | ( C146 | C147 ) ) ) by L200
.= ( D31 | ( ( ( C146 | C147 ) " ) " ) ) by L200
.= ( D31 | ( C146 | C147 ) ) by L202
.= ( ( ( D31 | ( C146 | C147 ) ) " ) " ) by L202
.= ( ( ( ( C146 " ) | D31 ) | ( ( C147 " ) | D31 ) ) " ) by L204
.= ( ( ( D31 | ( C146 " ) ) | ( ( C147 " ) | D31 ) ) " ) by L267
.= ( ( ( D31 | ( C146 | C146 ) ) | ( D31 | ( C147 " ) ) ) " ) by L267
.= ( ( ( C145 "\/" C146 ) | ( D31 | ( C147 | C147 ) ) ) | ( ( D31 | ( C146 | C146 ) ) | ( D31 | ( C147 | C147 ) ) ) ) by L200
.= ( ( ( C145 "\/" C146 ) | ( C145 "\/" C147 ) ) | ( ( D31 | ( C146 | C146 ) ) | ( D31 | ( C147 | C147 ) ) ) ) by L200
.= ( ( ( C145 "\/" C146 ) | ( C145 "\/" C147 ) ) | ( ( C145 "\/" C146 ) | ( D31 | ( C147 | C147 ) ) ) ) by L200
.= ( ( ( C145 "\/" C146 ) | ( C145 "\/" C147 ) ) | ( ( C145 "\/" C146 ) | ( C145 "\/" C147 ) ) ) by L200
.= ( ( C145 "\/" C146 ) "/\" ( C145 "\/" C147 ) ) by L200;
thus L284: thesis by L283;
end;
theorem
L285: (for B135 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr holds B135 is  Boolean  Boolean  Boolean  Boolean Lattice)
proof
let C148 being  satisfying_Sheffer_1  satisfying_Sheffer_2  satisfying_Sheffer_3  properly_defined non  empty ShefferOrthoLattStr;
L286: (C148 is  distributive & C148 is  distributive') by L279 , L282;
L287: (ex B136 being (Element of C148) st (for B137 being (Element of C148) holds (( B136 "/\" B137 ) = B137 & ( B137 "/\" B136 ) = B137)))
proof
set D32 = the (Element of C148);
take D33 = ( ( D32 | D32 ) | ( ( D32 | D32 ) | ( D32 | D32 ) ) );
let C149 being (Element of C148);
thus L288: ( D33 "/\" C149 ) = C149
proof
set D34 = ( D32 " );
L289: ( D33 "/\" C149 ) = ( ( ( ( D32 | D32 ) | ( D34 | D34 ) ) | C149 ) " ) by L200
.= ( ( C149 | ( D34 | ( D34 | D34 ) ) ) " ) by L267
.= ( ( C149 | C149 ) " ) by L203
.= C149 by L202;
thus L290: thesis by L289;
end;

thus L291: ( C149 "/\" D33 ) = C149
proof
set D35 = ( D32 " );
L292: ( C149 "/\" D33 ) = ( ( C149 | ( ( D32 | D32 ) | ( D35 | D35 ) ) ) " ) by L200
.= ( ( C149 | C149 ) " ) by L203
.= C149 by L202;
thus L293: thesis by L292;
end;

end;
L292: C148 is  upper-bounded' by L287 , L4;
L293: (ex B138 being (Element of C148) st (for B139 being (Element of C148) holds (( B138 "\/" B139 ) = B139 & ( B139 "\/" B138 ) = B139)))
proof
set D36 = the (Element of C148);
take D37 = ( ( D36 | ( D36 | D36 ) ) | ( D36 | ( D36 | D36 ) ) );
let C150 being (Element of C148);
L294: ( D37 "\/" C150 ) = ( ( ( ( D36 | ( D36 | D36 ) ) " ) " ) | ( C150 | C150 ) ) by L200
.= ( ( ( ( C150 | ( C150 | C150 ) ) " ) " ) | ( C150 | C150 ) ) by L270
.= ( ( C150 | ( C150 | C150 ) ) | ( C150 | C150 ) ) by L202
.= ( ( C150 | C150 ) | ( C150 | ( C150 | C150 ) ) ) by L267
.= ( ( C150 | C150 ) | ( C150 | C150 ) ) by L203
.= C150 by L202;
thus L295: ( D37 "\/" C150 ) = C150 by L294;
L296: ( C150 "\/" D37 ) = ( ( C150 | C150 ) | ( ( ( D36 | ( D36 | D36 ) ) " ) " ) ) by L200
.= ( ( C150 | C150 ) | ( ( ( C150 | ( C150 | C150 ) ) " ) " ) ) by L270
.= ( ( C150 | C150 ) | ( C150 | ( C150 | C150 ) ) ) by L202
.= ( ( C150 | C150 ) | ( C150 | C150 ) ) by L203
.= C150 by L202;
thus L297: ( C150 "\/" D37 ) = C150 by L296;
end;
L298: C148 is  lower-bounded' by L293 , L12;
L299: (for B140 being (Element of C148) holds (ex B141 being (Element of C148) st B141 is_a_complement'_of B140))
proof
let C151 being (Element of C148);
set D38 = ( C151 | C151 );
take D38;
L300: ( Top' C148 ) = ( ( C151 | C151 ) | ( ( C151 | C151 ) | ( C151 | C151 ) ) )
proof
set D39 = ( ( C151 | C151 ) | ( ( C151 | C151 ) | ( C151 | C151 ) ) );
L301: (for B142 being (Element of C148) holds (( D39 "/\" B142 ) = B142 & ( B142 "/\" D39 ) = B142))
proof
let C152 being (Element of C148);
set D40 = ( C151 " );
thus L302: ( D39 "/\" C152 ) = ( ( ( ( C151 | C151 ) | ( D40 | D40 ) ) | C152 ) " ) by L200
.= ( ( C152 | ( D40 | ( D40 | D40 ) ) ) " ) by L267
.= ( ( C152 | C152 ) " ) by L203
.= C152 by L202;
thus L303: ( C152 "/\" D39 ) = ( ( C152 | ( ( C151 | C151 ) | ( D40 | D40 ) ) ) " ) by L200
.= ( ( C152 | C152 ) " ) by L203
.= C152 by L202;
end;
thus L304: thesis by L301 , L292 , L7;
end;
L305: ( C151 "\/" D38 ) = ( Top' C148 ) by L300 , L200;
L306: ( Bot' C148 ) = ( ( C151 | ( C151 | C151 ) ) | ( C151 | ( C151 | C151 ) ) )
proof
set D41 = ( ( C151 | ( C151 | C151 ) ) | ( C151 | ( C151 | C151 ) ) );
L307: (for B143 being (Element of C148) holds (( D41 "\/" B143 ) = B143 & ( B143 "\/" D41 ) = B143))
proof
let C153 being (Element of C148);
thus L308: ( D41 "\/" C153 ) = ( ( ( ( C151 | ( C151 | C151 ) ) " ) " ) | ( C153 | C153 ) ) by L200
.= ( ( ( ( C153 | ( C153 | C153 ) ) " ) " ) | ( C153 | C153 ) ) by L270
.= ( ( C153 | ( C153 | C153 ) ) | ( C153 | C153 ) ) by L202
.= ( ( C153 | C153 ) | ( C153 | ( C153 | C153 ) ) ) by L267
.= ( ( C153 | C153 ) | ( C153 | C153 ) ) by L203
.= C153 by L202;
thus L309: ( C153 "\/" D41 ) = ( ( C153 | C153 ) | ( ( ( C151 | ( C151 | C151 ) ) " ) " ) ) by L200
.= ( ( C153 | C153 ) | ( ( ( C153 | ( C153 | C153 ) ) " ) " ) ) by L270
.= ( ( C153 | C153 ) | ( C153 | ( C153 | C153 ) ) ) by L202
.= ( ( C153 | C153 ) | ( C153 | C153 ) ) by L203
.= C153 by L202;
end;
thus L310: thesis by L307 , L298 , L15;
end;
L311: ( C151 "/\" D38 ) = ( Bot' C148 ) by L306 , L200;
L312: ( D38 "\/" C151 ) = ( ( ( C151 | C151 ) | ( C151 | C151 ) ) | ( C151 | C151 ) ) by L200
.= ( Top' C148 ) by L300 , L267;
L313: ( D38 "/\" C151 ) = ( ( ( C151 | C151 ) | C151 ) | ( ( C151 | C151 ) | C151 ) ) by L200
.= ( ( C151 | ( C151 | C151 ) ) | ( ( C151 | C151 ) | C151 ) ) by L267
.= ( Bot' C148 ) by L306 , L267;
thus L314: thesis by L313 , L312 , L305 , L311 , L22;
end;
L315: C148 is  complemented' by L299 , L24;
L316: (C148 is  join-commutative & C148 is  meet-commutative) by L273 , L276;
thus L317: thesis by L316 , L298 , L292 , L315 , L286;
end;
