:: Ring Ideals
::  by Jonathan Backer , Piotr Rudnicki and Christoph Schwarzweller
::
:: Received November 20, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, RLVECT_1, ALGSTR_1, XBOOLE_0, ALGSTR_0, STRUCT_0,
      VECTSP_2, VECTSP_1, BINOP_1, LATTICES, ZFMISC_1, SUBSET_1, CARD_3,
      FINSEQ_1, ARYTM_3, ORDINAL4, RELAT_1, CARD_FIL, SUPINF_2, TARSKI,
      ARYTM_1, MESFUNC1, CARD_1, NEWTON, NAT_1, XXREAL_0, REALSET1, FUNCT_1,
      FUNCT_7, GROUP_1, PARTFUN1, PRELAMB, MCART_1, SETFAM_1, RLVECT_3, GCD_1,
      LATTICE3, SQUARE_1, FINSET_1, INT_3, XCMPLX_0, IDEAL_1, RECDEF_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, FINSET_1, RELAT_1, FUNCT_1,
      FINSEQ_1, ORDINAL1, REALSET1, INT_3, CARD_1, NUMBERS, XCMPLX_0, XXREAL_0,
      NAT_1, RELSET_1, PARTFUN1, FUNCT_2, ALGSTR_1, XXREAL_2, XTUPLE_0,
      MCART_1, POLYNOM1, SETFAM_1, DOMAIN_1, FINSEQ_4, STRUCT_0, ALGSTR_0,
      RLVECT_1, VECTSP_1, GROUP_1, BINOP_1, VECTSP_2, FUNCT_7, GCD_1, BINOM;
 constructors SETFAM_1, BINOP_1, REALSET2, ALGSTR_1, GCD_1, INT_3, POLYNOM1,
      BINOM, XXREAL_2, RELSET_1, FUNCT_7, FVSUM_1, FINSEQ_4, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_2, FINSET_1, XXREAL_0,
      XREAL_0, NAT_1, INT_1, MEMBERED, FINSEQ_1, REALSET1, STRUCT_0, VECTSP_1,
      ALGSTR_1, INT_3, VALUED_0, ALGSTR_0, XXREAL_2, CARD_1, ZFMISC_1,
      RELSET_1, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions CARD_1, TARSKI, XBOOLE_0, BINOP_1, REALSET1, STRUCT_0, ALGSTR_0,
      XTUPLE_0;
 theorems INT_3, TARSKI, ZFMISC_1, RLVECT_1, VECTSP_1, GCD_1, FUNCT_1, FUNCT_2,
      POLYNOM1, RELAT_1, FINSET_1, NAT_1, ALGSTR_1, MCART_1, FINSEQ_1,
      FINSEQ_2, FINSEQ_3, SETFAM_1, INT_1, FUNCT_7, FINSEQ_4, FINSEQ_5,
      POLYNOM2, BINOM, XBOOLE_0, XBOOLE_1, ORDINAL1, GROUP_1, XREAL_1,
      DOMAIN_1, XXREAL_0, PARTFUN1, XXREAL_2, SUBSET_1, CARD_1;
 schemes NAT_1, RECDEF_1, FUNCT_2, FINSEQ_2, DOMAIN_1, INT_1;

begin
registration
cluster  add-associative  left_zeroed  right_zeroed for non  empty non  empty non  empty non  empty addLoopStr;
existence
proof
set D1 = the non  degenerated comRing;
take D1;
thus L1: thesis;
end;
end;
registration
cluster  Abelian  left_zeroed  right_zeroed  add-cancelable  well-unital  add-associative  associative  commutative  distributive for non  trivial non  trivial non  trivial non  trivial doubleLoopStr;
existence
proof
set D2 = the non  degenerated comRing;
take D2;
thus L3: thesis;
end;
end;
theorem
L5: (for B1 being  add-associative  left_zeroed  right_zeroed non  empty addLoopStr holds (for B2 , B3 being (Element of B1) holds ( Sum <* B2 , B3 *> ) = ( B2 + B3 )))
proof
let C1 being  add-associative  left_zeroed  right_zeroed non  empty addLoopStr;
let C2 , C3 being (Element of C1);
L6: <* C2 , C3 *> = ( <* C2 *> ^ <* C3 *> ) by FINSEQ_1:def 9;
L7: ( Sum <* C2 , C3 *> ) = ( ( Sum <* C2 *> ) + ( Sum <* C3 *> ) ) by L6 , RLVECT_1:41
.= ( C2 + ( Sum <* C3 *> ) ) by BINOM:3
.= ( C2 + C3 ) by BINOM:3;
thus L8: thesis by L7;
end;
begin
definition
let C4 being non  empty addLoopStr;
let C5 being (Subset of C4);
attr C5 is  add-closed
means
:L9: (for B4 , B5 being (Element of C4) holds ((B4 in C5 & B5 in C5) implies ( B4 + B5 ) in C5));
end;
definition
let C6 being non  empty multMagma;
let C7 being (Subset of C6);
attr C7 is  left-ideal
means
:L11: (for B6 , B7 being (Element of C6) holds (B7 in C7 implies ( B6 * B7 ) in C7));
attr C7 is  right-ideal
means
:L12: (for B8 , B9 being (Element of C6) holds (B9 in C7 implies ( B9 * B8 ) in C7));
end;
registration
let C8 being non  empty addLoopStr;
cluster  add-closed for non  empty non  empty non  empty non  empty (Subset of C8);
existence
proof
set D3 = (the carrier of C8);
L14: (for B10 being set holds (B10 in D3 implies B10 in (the carrier of C8)));
reconsider D4 = D3 as (Subset of C8) by L14 , TARSKI:def 3;
reconsider D5 = D4 as non  empty (Subset of C8);
take D5;
L15: (for B11 , B12 being (Element of C8) holds ((B11 in D5 & B12 in D5) implies ( B11 + B12 ) in D5));
thus L16: thesis by L15 , L9;
end;
end;
registration
let C9 being non  empty multMagma;
cluster  left-ideal for non  empty non  empty non  empty non  empty (Subset of C9);
existence
proof
set D6 = (the carrier of C9);
L18: (for B13 being set holds (B13 in D6 implies B13 in (the carrier of C9)));
reconsider D7 = D6 as (Subset of C9) by L18 , TARSKI:def 3;
reconsider D8 = D7 as non  empty (Subset of C9);
take D8;
L19: (for B14 , B15 being (Element of C9) holds (B15 in D8 implies ( B14 * B15 ) in D8));
thus L20: thesis by L19 , L11;
end;
cluster  right-ideal for non  empty non  empty non  empty non  empty (Subset of C9);
existence
proof
set D9 = (the carrier of C9);
L21: (for B16 being set holds (B16 in D9 implies B16 in (the carrier of C9)));
reconsider D10 = D9 as (Subset of C9) by L21 , TARSKI:def 3;
reconsider D11 = D10 as non  empty (Subset of C9);
take D11;
L22: (for B17 , B18 being (Element of C9) holds (B18 in D11 implies ( B18 * B17 ) in D11));
thus L23: thesis by L22 , L12;
end;
end;
registration
let C10 being non  empty doubleLoopStr;
cluster  add-closed  left-ideal  right-ideal for non  empty non  empty non  empty non  empty (Subset of C10);
existence
proof
set D12 = (the carrier of C10);
L25: (for B19 being set holds (B19 in D12 implies B19 in (the carrier of C10)));
reconsider D13 = D12 as (Subset of C10) by L25 , TARSKI:def 3;
reconsider D14 = D13 as non  empty (Subset of C10);
take D14;
L26: (for B20 , B21 being (Element of C10) holds (B21 in D14 implies ( B21 * B20 ) in D14));
L27: ((for B22 , B23 being (Element of C10) holds ((B22 in D14 & B23 in D14) implies ( B22 + B23 ) in D14)) & (for B24 , B25 being (Element of C10) holds (B25 in D14 implies ( B24 * B25 ) in D14)));
thus L28: thesis by L27 , L26 , L9 , L11 , L12;
end;
cluster  add-closed  right-ideal for non  empty non  empty non  empty non  empty (Subset of C10);
existence
proof
set D15 = (the carrier of C10);
L29: (for B26 being set holds (B26 in D15 implies B26 in (the carrier of C10)));
reconsider D16 = D15 as (Subset of C10) by L29 , TARSKI:def 3;
reconsider D17 = D16 as non  empty (Subset of C10);
take D17;
L30: ((for B27 , B28 being (Element of C10) holds ((B27 in D17 & B28 in D17) implies ( B27 + B28 ) in D17)) & (for B29 , B30 being (Element of C10) holds (B30 in D17 implies ( B30 * B29 ) in D17)));
thus L31: thesis by L30 , L9 , L12;
end;
cluster  add-closed  left-ideal for non  empty non  empty non  empty non  empty (Subset of C10);
existence
proof
set D18 = (the carrier of C10);
L32: (for B31 being set holds (B31 in D18 implies B31 in (the carrier of C10)));
reconsider D19 = D18 as (Subset of C10) by L32 , TARSKI:def 3;
reconsider D20 = D19 as non  empty (Subset of C10);
take D20;
L33: ((for B32 , B33 being (Element of C10) holds ((B32 in D20 & B33 in D20) implies ( B32 + B33 ) in D20)) & (for B34 , B35 being (Element of C10) holds (B35 in D20 implies ( B34 * B35 ) in D20)));
thus L34: thesis by L33 , L9 , L11;
end;
end;
registration
let C11 being  commutative non  empty multMagma;
cluster  left-ideal ->  right-ideal for non  empty non  empty non  empty non  empty (Subset of C11);
coherence
proof
let C12 being non  empty (Subset of C11);
assume L36: C12 is  left-ideal;
L37: (for B36 , B37 being (Element of C11) holds (B37 in C12 implies ( B37 * B36 ) in C12)) by L36 , L11;
thus L38: thesis by L37 , L12;
end;
cluster  right-ideal ->  left-ideal for non  empty non  empty non  empty non  empty (Subset of C11);
coherence
proof
let C13 being non  empty (Subset of C11);
assume L39: C13 is  right-ideal;
L40: (for B38 , B39 being (Element of C11) holds (B39 in C13 implies ( B38 * B39 ) in C13)) by L39 , L12;
thus L41: thesis by L40 , L11;
end;
end;
definition
let C14 being non  empty doubleLoopStr;
mode Ideal of C14
 is  add-closed  left-ideal  right-ideal non  empty (Subset of C14);
end;
definition
let C15 being non  empty doubleLoopStr;
mode RightIdeal of C15
 is  add-closed  right-ideal non  empty (Subset of C15);
end;
definition
let C16 being non  empty doubleLoopStr;
mode LeftIdeal of C16
 is  add-closed  left-ideal non  empty (Subset of C16);
end;
theorem
L46: (for B40 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B41 being  left-ideal non  empty (Subset of B40) holds ( 0. B40 ) in B41))
proof
let C17 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C18 being  left-ideal non  empty (Subset of C17);
set D21 = the (Element of C18);
L47: ( ( 0. C17 ) * D21 ) in C18 by L11;
thus L48: thesis by L47 , BINOM:1;
end;
theorem
L49: (for B42 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B43 being  right-ideal non  empty (Subset of B42) holds ( 0. B42 ) in B43))
proof
let C19 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C20 being  right-ideal non  empty (Subset of C19);
set D22 = the (Element of C20);
L50: ( D22 * ( 0. C19 ) ) in C20 by L12;
thus L51: thesis by L50 , BINOM:2;
end;
theorem
L52: (for B44 being  right_zeroed non  empty addLoopStr holds { ( 0. B44 ) } is  add-closed)
proof
let C21 being  right_zeroed non  empty addLoopStr;
let C22 , C23 being (Element of C21);
assume L53: (C22 in { ( 0. C21 ) } & C23 in { ( 0. C21 ) });
L54: (C22 = ( 0. C21 ) & C23 = ( 0. C21 )) by L53 , TARSKI:def 1;
L55: ( C22 + C23 ) = ( 0. C21 ) by L54 , RLVECT_1:def 4;
thus L56: thesis by L55 , TARSKI:def 1;
end;
theorem
L57: (for B45 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds { ( 0. B45 ) } is  left-ideal)
proof
let C24 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C25 , C26 being (Element of C24);
reconsider D23 = C25 as (Element of C24);
assume L58: C26 in { ( 0. C24 ) };
L59: C26 = ( 0. C24 ) by L58 , TARSKI:def 1;
L60: ( D23 * C26 ) = ( 0. C24 ) by L59 , BINOM:2;
thus L61: thesis by L60 , TARSKI:def 1;
end;
theorem
L62: (for B46 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds { ( 0. B46 ) } is  right-ideal)
proof
let C27 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C28 , C29 being (Element of C27);
reconsider D24 = C28 as (Element of C27);
assume L63: C29 in { ( 0. C27 ) };
L64: C29 = ( 0. C27 ) by L63 , TARSKI:def 1;
L65: ( C29 * D24 ) = ( 0. C27 ) by L64 , BINOM:1;
thus L66: thesis by L65 , TARSKI:def 1;
end;
registration
let C30 being  right_zeroed non  empty addLoopStr;
cluster { ( 0. C30 ) } ->  add-closed for (Subset of C30);
coherence by L52;
end;
registration
let C31 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
cluster { ( 0. C31 ) } ->  left-ideal for (Subset of C31);
coherence by L57;
end;
registration
let C32 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
cluster { ( 0. C32 ) } ->  right-ideal for (Subset of C32);
coherence by L62;
end;
theorem
L70: (for B47 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds { ( 0. B47 ) } is (Ideal of B47));
theorem
L71: (for B48 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds { ( 0. B48 ) } is (LeftIdeal of B48));
theorem
L72: (for B49 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr holds { ( 0. B49 ) } is (RightIdeal of B49));
theorem
L73: (for B50 being non  empty doubleLoopStr holds (the carrier of B50) is (Ideal of B50))
proof
let C33 being non  empty doubleLoopStr;
L74: (the carrier of C33) c= (the carrier of C33);
reconsider D25 = (the carrier of C33) as (Subset of C33) by L74;
L75: D25 is  left-ideal
proof
let C34 , C35 being (Element of C33);
thus L76: thesis;
end;
L77: D25 is  right-ideal
proof
let C36 , C37 being (Element of C33);
thus L78: thesis;
end;
L79: D25 is  add-closed
proof
let C38 , C39 being (Element of C33);
thus L80: thesis;
end;
thus L81: thesis by L79 , L75 , L77;
end;
theorem
L82: (for B51 being non  empty doubleLoopStr holds (the carrier of B51) is (LeftIdeal of B51))
proof
let C40 being non  empty doubleLoopStr;
L83: (the carrier of C40) c= (the carrier of C40);
reconsider D26 = (the carrier of C40) as (Subset of C40) by L83;
L84: D26 is  left-ideal
proof
let C41 , C42 being (Element of C40);
thus L85: thesis;
end;
L86: D26 is  add-closed
proof
let C43 , C44 being (Element of C40);
thus L87: thesis;
end;
thus L88: thesis by L86 , L84;
end;
theorem
L89: (for B52 being non  empty doubleLoopStr holds (the carrier of B52) is (RightIdeal of B52))
proof
let C45 being non  empty doubleLoopStr;
L90: (the carrier of C45) c= (the carrier of C45);
reconsider D27 = (the carrier of C45) as (Subset of C45) by L90;
L91: D27 is  right-ideal
proof
let C46 , C47 being (Element of C45);
thus L92: thesis;
end;
L93: D27 is  add-closed
proof
let C48 , C49 being (Element of C45);
thus L94: thesis;
end;
thus L95: thesis by L93 , L91;
end;
definition
let C50 being  left_zeroed  right_zeroed  add-cancelable  distributive non  empty doubleLoopStr;
let C51 being (Ideal of C50);
redefine attr C51 is  trivial
means
C51 = { ( 0. C50 ) };
compatibility
proof
L96:
now
assume L97: C51 is  trivial;
consider C52 being set such that L98: C51 = { C52 } by L97 , ZFMISC_1:131;
L99: ( 0. C50 ) in { C52 } by L98 , L49;
thus L100: C51 = { ( 0. C50 ) } by L99 , L98 , TARSKI:def 1;
end;
thus L101: thesis by L96;
end;
end;
registration
let C53 being non  trivial  left_zeroed  right_zeroed  add-cancelable  distributive non  empty doubleLoopStr;
cluster  proper for (Ideal of C53);
existence
proof
reconsider D28 = { ( 0. C53 ) } as (Ideal of C53);
L103: D28 is  proper by SUBSET_1:def 6;
thus L104: thesis by L103;
end;
end;
theorem
L106: (for B53 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr holds (for B54 being  left-ideal non  empty (Subset of B53) holds (for B55 being (Element of B53) holds (B55 in B54 implies ( - B55 ) in B54))))
proof
let C54 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr;
let C55 being  left-ideal non  empty (Subset of C54);
let C56 being (Element of C54);
assume L107: C56 in C55;
L108: ( ( - ( 1. C54 ) ) * C56 ) in C55 by L107 , L11;
L109: ( 0. C54 ) = ( ( 0. C54 ) * C56 ) by VECTSP_1:7
.= ( ( ( 1. C54 ) + ( - ( 1. C54 ) ) ) * C56 ) by RLVECT_1:def 10
.= ( ( ( 1. C54 ) * C56 ) + ( ( - ( 1. C54 ) ) * C56 ) ) by VECTSP_1:def 3
.= ( C56 + ( ( - ( 1. C54 ) ) * C56 ) ) by VECTSP_1:def 8;
thus L110: thesis by L109 , L108 , RLVECT_1:def 10;
end;
theorem
L111: (for B56 being  add-associative  right_zeroed  right_complementable  right-distributive  right_unital non  empty doubleLoopStr holds (for B57 being  right-ideal non  empty (Subset of B56) holds (for B58 being (Element of B56) holds (B58 in B57 implies ( - B58 ) in B57))))
proof
let C57 being  add-associative  right_zeroed  right_complementable  right-distributive  right_unital non  empty doubleLoopStr;
let C58 being  right-ideal non  empty (Subset of C57);
let C59 being (Element of C57);
assume L112: C59 in C58;
L113: ( C59 * ( - ( 1. C57 ) ) ) in C58 by L112 , L12;
L114: ( 0. C57 ) = ( C59 * ( 0. C57 ) ) by VECTSP_1:6
.= ( C59 * ( ( 1. C57 ) + ( - ( 1. C57 ) ) ) ) by RLVECT_1:def 10
.= ( ( C59 * ( 1. C57 ) ) + ( C59 * ( - ( 1. C57 ) ) ) ) by VECTSP_1:def 2
.= ( C59 + ( C59 * ( - ( 1. C57 ) ) ) ) by VECTSP_1:def 4;
thus L115: thesis by L114 , L113 , RLVECT_1:def 10;
end;
theorem
L116: (for B59 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr holds (for B60 being (LeftIdeal of B59) holds (for B61 , B62 being (Element of B59) holds ((B61 in B60 & B62 in B60) implies ( B61 - B62 ) in B60))))
proof
let C60 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr;
let C61 being (LeftIdeal of C60);
let C62 , C63 being (Element of C60);
assume that
L117: C62 in C61
and
L118: C63 in C61;
L119: ( - C63 ) in C61 by L118 , L106;
thus L120: thesis by L119 , L117 , L9;
end;
theorem
L121: (for B63 being  add-associative  right_zeroed  right_complementable  right-distributive  right_unital non  empty doubleLoopStr holds (for B64 being (RightIdeal of B63) holds (for B65 , B66 being (Element of B63) holds ((B65 in B64 & B66 in B64) implies ( B65 - B66 ) in B64))))
proof
let C64 being  add-associative  right_zeroed  right_complementable  right-distributive  right_unital non  empty doubleLoopStr;
let C65 being (RightIdeal of C64);
let C66 , C67 being (Element of C64);
assume that
L122: C66 in C65
and
L123: C67 in C65;
L124: ( - C67 ) in C65 by L123 , L111;
thus L125: thesis by L124 , L122 , L9;
end;
theorem
L126: (for B67 being  left_zeroed  right_zeroed  add-cancelable  add-associative  distributive non  empty doubleLoopStr holds (for B68 being  add-closed  right-ideal non  empty (Subset of B67) holds (for B69 being (Element of B68) holds (for B70 being (Element of ( NAT )) holds ( B70 * B69 ) in B68))))
proof
let C68 being  left_zeroed  right_zeroed  add-cancelable  add-associative  distributive non  empty doubleLoopStr;
let C69 being  add-closed  right-ideal non  empty (Subset of C68);
let C70 being (Element of C69);
let C71 being (Element of ( NAT ));
defpred S1[ (Element of ( NAT )) ] means ( $1 * C70 ) in C69;
L127: (for B71 being (Element of ( NAT )) holds (S1[ B71 ] implies S1[ ( B71 + 1 ) ]))
proof
let C72 being (Element of ( NAT ));
L128: ( ( C72 + 1 ) * C70 ) = ( ( 1 * C70 ) + ( C72 * C70 ) ) by BINOM:15
.= ( C70 + ( C72 * C70 ) ) by BINOM:13;
assume L129: ( C72 * C70 ) in C69;
thus L130: thesis by L129 , L128 , L9;
end;
L131: ( ( 0 ) * C70 ) = ( 0. C68 ) by BINOM:12;
L132: S1[ ( 0 ) ] by L131 , L49;
L133: (for B72 being (Element of ( NAT )) holds S1[ B72 ]) from NAT_1:sch 1(L132 , L127);
thus L134: thesis by L133;
end;
theorem
L135: (for B73 being  well-unital  left_zeroed  right_zeroed  add-cancelable  associative  distributive non  empty doubleLoopStr holds (for B74 being  right-ideal non  empty (Subset of B73) holds (for B75 being (Element of B74) holds (for B76 being (Element of ( NAT )) holds (B76 <> ( 0 ) implies ( B75 |^ B76 ) in B74)))))
proof
let C73 being  well-unital  left_zeroed  right_zeroed  add-cancelable  associative  distributive non  empty doubleLoopStr;
let C74 being  right-ideal non  empty (Subset of C73);
let C75 being (Element of C74);
let C76 being (Element of ( NAT ));
defpred S2[ Nat ] means ( C75 |^ $1 ) in C74;
assume L136: C76 <> ( 0 );
L137: (for B77 being Nat holds (1 <= B77 implies (S2[ B77 ] implies S2[ ( B77 + 1 ) ])))
proof
let C77 being Nat;
assume L138: 1 <= C77;
L139: ( C75 |^ ( C77 + 1 ) ) = ( ( C75 |^ C77 ) * ( C75 |^ 1 ) ) by BINOM:10;
assume L140: ( C75 |^ C77 ) in C74;
thus L141: thesis by L140 , L139 , L12;
end;
L142: ( C75 |^ 1 ) = C75 by BINOM:8;
L143: S2[ 1 ] by L142;
L144: (for B78 being Nat holds (1 <= B78 implies S2[ B78 ])) from NAT_1:sch 8(L143 , L137);
thus L145: thesis by L144 , L136 , NAT_1:14;
end;
definition
let C78 being non  empty addLoopStr;
let C79 being  add-closed non  empty (Subset of C78);
func add| (C79 , C78) -> (BinOp of C79) equals 
( (the addF of C78) || C79 );
coherence
proof
reconsider D29 = ( (the addF of C78) || C79 ) as (Function of [: C79 , C79 :] , (the carrier of C78)) by FUNCT_2:32;
L146: ( dom D29 ) = [: C79 , C79 :] by FUNCT_2:def 1;
L147: (for B79 being set holds (B79 in [: C79 , C79 :] implies ( D29 . B79 ) in C79))
proof
let C80 being set;
assume L148: C80 in [: C79 , C79 :];
consider C81 , C82 being set such that L149: (C81 in C79 & C82 in C79) and L150: C80 = [ C81 , C82 ] by L148 , ZFMISC_1:def 2;
reconsider D30 = C81 , D31 = C82 as (Element of C78) by L149;
reconsider D32 = D30 , D33 = D31 as (Element of C78);
L151: ( D29 . C80 ) = ( D32 + D33 ) by L146 , L148 , L150 , FUNCT_1:47;
thus L152: thesis by L151 , L149 , L9;
end;
thus L153: thesis by L147 , L146 , FUNCT_2:3;
end;
end;
definition
let C83 being non  empty multMagma;
let C84 being  right-ideal non  empty (Subset of C83);
func mult| (C84 , C83) -> (BinOp of C84) equals 
( (the multF of C83) || C84 );
coherence
proof
reconsider D34 = ( (the multF of C83) || C84 ) as (Function of [: C84 , C84 :] , (the carrier of C83)) by FUNCT_2:32;
L155: ( dom D34 ) = [: C84 , C84 :] by FUNCT_2:def 1;
L156: (for B80 being set holds (B80 in [: C84 , C84 :] implies ( D34 . B80 ) in C84))
proof
let C85 being set;
assume L157: C85 in [: C84 , C84 :];
consider C86 , C87 being set such that L158: (C86 in C84 & C87 in C84) and L159: C85 = [ C86 , C87 ] by L157 , ZFMISC_1:def 2;
reconsider D35 = C86 , D36 = C87 as (Element of C84) by L158;
L160: ( D34 . C85 ) = ( (the multF of C83) . [ D35 , D36 ] ) by L155 , L159 , FUNCT_1:47
.= ( D35 * D36 );
thus L161: thesis by L160 , L12;
end;
thus L162: thesis by L156 , L155 , FUNCT_2:3;
end;
end;
definition
let C88 being non  empty addLoopStr;
let C89 being  add-closed non  empty (Subset of C88);
func Gr (C89 , C88) -> non  empty addLoopStr equals 
addLoopStr (# C89 , ( add| (C89 , C88) ) , ( In (( 0. C88 ) , C89) ) #);
coherence;
end;
registration
let C90 being  left_zeroed  right_zeroed  add-cancelable  add-associative  distributive non  empty doubleLoopStr;
let C91 being  add-closed non  empty (Subset of C90);
cluster ( Gr (C91 , C90) ) ->  add-associative;
coherence
proof
set D37 = addLoopStr (# C91 , ( add| (C91 , C90) ) , ( In (( 0. C90 ) , C91) ) #);
reconsider D38 = D37 as non  empty addLoopStr;
L165:
now
let C92 being set;
L166: ( dom (the addF of C90) ) = [: (the carrier of C90) , (the carrier of C90) :] by FUNCT_2:def 1;
assume L167: C92 in [: C91 , C91 :];
thus L168: C92 in ( dom (the addF of C90) ) by L167 , L166;
end;
L169: [: C91 , C91 :] c= ( dom (the addF of C90) ) by L165 , TARSKI:def 3;
L170: ( dom ( (the addF of C90) || C91 ) ) = [: C91 , C91 :] by L169 , RELAT_1:62;
L171: (for B81 , B82 being (Element of D38) holds (for B83 , B84 being (Element of C91) holds ((B83 = B81 & B84 = B82) implies ( B81 + B82 ) = ( B83 + B84 ))))
proof
let C93 , C94 being (Element of D38);
let C95 , C96 being (Element of C91);
assume L172: (C95 = C93 & C96 = C94);
L173: [ C95 , C96 ] in ( dom ( (the addF of C90) || C91 ) ) by L170;
thus L174: thesis by L173 , L172 , FUNCT_1:47;
end;
L175:
now
let C97 , C98 , C99 being (Element of D38);
reconsider D39 = C97 , D40 = C98 , D41 = C99 as (Element of C91);
L176: ( D39 + D40 ) in C91 by L9;
L177: [ ( D39 + D40 ) , D41 ] in ( dom ( (the addF of C90) || C91 ) ) by L176 , L170 , ZFMISC_1:def 2;
L178: ( D40 + D41 ) in C91 by L9;
L179: [ D39 , ( D40 + D41 ) ] in ( dom ( (the addF of C90) || C91 ) ) by L178 , L170 , ZFMISC_1:def 2;
thus L180: ( ( C97 + C98 ) + C99 ) = ( ( (the addF of C90) || C91 ) . [ ( D39 + D40 ) , D41 ] ) by L171
.= ( ( D39 + D40 ) + D41 ) by L177 , FUNCT_1:47
.= ( D39 + ( D40 + D41 ) ) by RLVECT_1:def 3
.= ( ( add| (C91 , C90) ) . [ D39 , ( D40 + D41 ) ] ) by L179 , FUNCT_1:47
.= ( C97 + ( C98 + C99 ) ) by L171;
end;
thus L181: thesis by L175 , RLVECT_1:def 3;
end;
end;
registration
let C100 being  left_zeroed  right_zeroed  add-cancelable  add-associative  distributive non  empty doubleLoopStr;
let C101 being  add-closed  right-ideal non  empty (Subset of C100);
cluster ( Gr (C101 , C100) ) ->  right_zeroed;
coherence
proof
set D42 = addLoopStr (# C101 , ( add| (C101 , C100) ) , ( In (( 0. C100 ) , C101) ) #);
reconsider D43 = D42 as non  empty addLoopStr;
L183:
now
let C102 being set;
L184: ( dom (the addF of C100) ) = [: (the carrier of C100) , (the carrier of C100) :] by FUNCT_2:def 1;
assume L185: C102 in [: C101 , C101 :];
thus L186: C102 in ( dom (the addF of C100) ) by L185 , L184;
end;
L187: [: C101 , C101 :] c= ( dom (the addF of C100) ) by L183 , TARSKI:def 3;
L188: ( dom ( (the addF of C100) || C101 ) ) = [: C101 , C101 :] by L187 , RELAT_1:62;
L189:
now
let C103 being (Element of D43);
reconsider D44 = C103 as (Element of C101);
L190: ( 0. C100 ) in C101 by L49;
L191: [ D44 , ( 0. C100 ) ] in ( dom ( (the addF of C100) || C101 ) ) by L190 , L188 , ZFMISC_1:def 2;
thus L192: ( C103 + ( 0. D43 ) ) = ( ( (the addF of C100) || C101 ) . [ D44 , ( 0. C100 ) ] ) by L49 , FUNCT_7:def 1
.= ( D44 + ( 0. C100 ) ) by L191 , FUNCT_1:47
.= C103 by RLVECT_1:def 4;
end;
thus L193: thesis by L189 , RLVECT_1:def 4;
end;
end;
registration
let C104 being  Abelian non  empty doubleLoopStr;
let C105 being  add-closed non  empty (Subset of C104);
cluster ( Gr (C105 , C104) ) ->  Abelian;
coherence
proof
set D45 = addLoopStr (# C105 , ( add| (C105 , C104) ) , ( In (( 0. C104 ) , C105) ) #);
reconsider D46 = D45 as non  empty addLoopStr;
L195:
now
let C106 being set;
L196: ( dom (the addF of C104) ) = [: (the carrier of C104) , (the carrier of C104) :] by FUNCT_2:def 1;
assume L197: C106 in [: C105 , C105 :];
thus L198: C106 in ( dom (the addF of C104) ) by L197 , L196;
end;
L199: [: C105 , C105 :] c= ( dom (the addF of C104) ) by L195 , TARSKI:def 3;
L200: ( dom ( (the addF of C104) || C105 ) ) = [: C105 , C105 :] by L199 , RELAT_1:62;
L201: (for B85 , B86 being (Element of D46) holds (for B87 , B88 being (Element of C105) holds ((B87 = B85 & B88 = B86) implies ( B85 + B86 ) = ( B87 + B88 ))))
proof
let C107 , C108 being (Element of D46);
let C109 , C110 being (Element of C105);
assume L202: (C109 = C107 & C110 = C108);
L203: [ C109 , C110 ] in ( dom ( (the addF of C104) || C105 ) ) by L200;
thus L204: thesis by L203 , L202 , FUNCT_1:47;
end;
L205:
now
let C111 , C112 being (Element of D46);
reconsider D47 = C111 , D48 = C112 as (Element of C105);
thus L206: ( C111 + C112 ) = ( D47 + D48 ) by L201
.= ( C112 + C111 ) by L201;
end;
thus L207: thesis by L205 , RLVECT_1:def 2;
end;
end;
registration
let C113 being  Abelian  right_unital  left_zeroed  right_zeroed  right_complementable  add-associative  distributive non  empty doubleLoopStr;
let C114 being  add-closed  right-ideal non  empty (Subset of C113);
cluster ( Gr (C114 , C113) ) ->  right_complementable;
coherence
proof
set D49 = addLoopStr (# C114 , ( add| (C114 , C113) ) , ( In (( 0. C113 ) , C114) ) #);
reconsider D50 = D49 as non  empty addLoopStr;
L209:
now
let C115 being set;
L210: ( dom (the addF of C113) ) = [: (the carrier of C113) , (the carrier of C113) :] by FUNCT_2:def 1;
assume L211: C115 in [: C114 , C114 :];
thus L212: C115 in ( dom (the addF of C113) ) by L211 , L210;
end;
L213: [: C114 , C114 :] c= ( dom (the addF of C113) ) by L209 , TARSKI:def 3;
L214: ( dom ( (the addF of C113) || C114 ) ) = [: C114 , C114 :] by L213 , RELAT_1:62;
L215: (for B89 , B90 being (Element of D50) holds (for B91 , B92 being (Element of C114) holds ((B91 = B89 & B92 = B90) implies ( B89 + B90 ) = ( B91 + B92 ))))
proof
let C116 , C117 being (Element of D50);
let C118 , C119 being (Element of C114);
assume L216: (C118 = C116 & C119 = C117);
L217: [ C118 , C119 ] in ( dom ( (the addF of C113) || C114 ) ) by L214;
thus L218: thesis by L217 , L216 , FUNCT_1:47;
end;
reconsider D51 = C114 as (RightIdeal of C113);
L219: D50 is  right_complementable
proof
let C120 being (Element of D50);
reconsider D52 = C120 as (Element of D51);
reconsider D53 = ( - D52 ) as (Element of D50) by L111;
L220: ( C120 + D53 ) = ( D52 + ( - D52 ) ) by L215
.= ( 0. C113 ) by RLVECT_1:5
.= ( 0. D50 ) by L49 , FUNCT_7:def 1;
thus L221: (ex B93 being (Element of D50) st ( C120 + B93 ) = ( 0. D50 )) by L220;
end;
thus L222: thesis by L219;
end;
end;
L224: (for B94 being comRing holds (for B95 being (Element of B94) holds { ( B95 * B96 ) where B96 is (Element of B94) : (not contradiction) } is (Ideal of B94)))
proof
let C121 being comRing;
let C122 being (Element of C121);
set D54 = { ( C122 * B97 ) where B97 is (Element of C121) : (not contradiction) };
L225:
now
let C123 being set;
assume L226: C123 in D54;
L227: (ex B98 being (Element of C121) st C123 = ( C122 * B98 )) by L226;
thus L228: C123 in (the carrier of C121) by L227;
end;
L229: ( C122 * ( 1. C121 ) ) in D54;
reconsider D55 = D54 as non  empty (Subset of C121) by L229 , L225 , TARSKI:def 3;
reconsider D56 = D55 as non  empty (Subset of C121);
L230:
now
let C124 , C125 being (Element of C121);
assume that
L231: C124 in D56
and
L232: C125 in D56;
consider C126 being (Element of C121) such that L233: ( C122 * C126 ) = C124 by L231;
consider C127 being (Element of C121) such that L234: ( C122 * C127 ) = C125 by L232;
L235: ( C124 + C125 ) = ( C122 * ( C126 + C127 ) ) by L233 , L234 , VECTSP_1:def 7;
thus L236: ( C124 + C125 ) in D56 by L235;
end;
L237:
now
let C128 , C129 being (Element of C121);
assume L238: C129 in D56;
consider C130 being (Element of C121) such that L239: ( C122 * C130 ) = C129 by L238;
L240: ( C128 * C129 ) = ( ( C128 * C130 ) * C122 ) by L239 , GROUP_1:def 3;
thus L241: ( C128 * C129 ) in D56 by L240;
end;
L242:
now
let C131 , C132 being (Element of C121);
assume L243: C132 in D56;
consider C133 being (Element of C121) such that L244: ( C122 * C133 ) = C132 by L243;
L245: ( C132 * C131 ) = ( C122 * ( C133 * C131 ) ) by L244 , GROUP_1:def 3;
thus L246: ( C132 * C131 ) in D56 by L245;
end;
thus L247: thesis by L242 , L230 , L237 , L9 , L11 , L12;
end;
theorem
L248: (for B99 being  right_unital non  empty doubleLoopStr holds (for B100 being  left-ideal non  empty (Subset of B99) holds (B100 is  proper iff (not ( 1. B99 ) in B100))))
proof
let C134 being  right_unital non  empty doubleLoopStr;
let C135 being  left-ideal non  empty (Subset of C134);
L249:
now
assume L250: C135 is  proper;
thus L251: (not ( 1. C134 ) in C135)
proof
assume L252: ( 1. C134 ) in C135;
L253:
now
let C136 being set;
assume L254: C136 in (the carrier of C134);
reconsider D57 = C136 as (Element of C134) by L254;
L255: ( D57 * ( 1. C134 ) ) = D57 by VECTSP_1:def 4;
thus L256: C136 in C135 by L255 , L252 , L11;
end;
L257: (for B101 being set holds (B101 in C135 implies B101 in (the carrier of C134)));
L258: C135 = (the carrier of C134) by L257 , L253 , TARSKI:1;
thus L259: thesis by L258 , L250 , SUBSET_1:def 6;
end;

end;
L252:
now
assume L253: (not ( 1. C134 ) in C135);
L254: C135 <> (the carrier of C134) by L253;
thus L255: C135 is  proper by L254 , SUBSET_1:def 6;
end;
thus L256: thesis by L252 , L249;
end;
theorem
L257: (for B102 being  left_unital  right_unital non  empty doubleLoopStr holds (for B103 being  right-ideal non  empty (Subset of B102) holds (B103 is  proper iff (for B104 being (Element of B102) holds (B104 is  unital implies (not B104 in B103))))))
proof
let C137 being  left_unital  right_unital non  empty doubleLoopStr;
let C138 being  right-ideal non  empty (Subset of C137);
L258:
now
assume L259: C138 is  proper;
L260: (not ( 1. C137 ) in C138)
proof
assume L261: ( 1. C137 ) in C138;
L262:
now
let C139 being set;
assume L263: C139 in (the carrier of C137);
reconsider D58 = C139 as (Element of C137) by L263;
L264: ( ( 1. C137 ) * D58 ) = D58 by VECTSP_1:def 8;
thus L265: C139 in C138 by L264 , L261 , L12;
end;
L266: (for B105 being set holds (B105 in C138 implies B105 in (the carrier of C137)));
L267: C138 = (the carrier of C137) by L266 , L262 , TARSKI:1;
thus L268: thesis by L267 , L259 , SUBSET_1:def 6;
end;
thus L269: (for B106 being (Element of C137) holds (B106 is  unital implies (not B106 in C138)))
proof
let C140 being (Element of C137);
assume L270: C140 is  unital;
L271: C140 divides ( 1. C137 ) by L270 , GCD_1:def 2;
L272: (ex B107 being (Element of C137) st ( 1. C137 ) = ( C140 * B107 )) by L271 , GCD_1:def 1;
thus L273: thesis by L272 , L260 , L12;
end;

end;
L270:
now
L271: ( 1. C137 ) divides ( 1. C137 );
L272: ( 1. C137 ) is  unital by L271 , GCD_1:def 2;
assume L273: (for B108 being (Element of C137) holds (B108 is  unital implies (not B108 in C138)));
L274: C138 <> (the carrier of C137) by L273 , L272;
thus L275: C138 is  proper by L274 , SUBSET_1:def 6;
end;
thus L276: thesis by L270 , L258;
end;
theorem
L277: (for B109 being  right_unital non  empty doubleLoopStr holds (for B110 being  left-ideal  right-ideal non  empty (Subset of B109) holds (B110 is  proper iff (for B111 being (Element of B109) holds (B111 is  unital implies (not B111 in B110))))))
proof
let C141 being  right_unital non  empty doubleLoopStr;
let C142 being  left-ideal  right-ideal non  empty (Subset of C141);
L278:
now
assume L279: C142 is  proper;
L280: (not ( 1. C141 ) in C142)
proof
assume L281: ( 1. C141 ) in C142;
L282:
now
let C143 being set;
assume L283: C143 in (the carrier of C141);
reconsider D59 = C143 as (Element of C141) by L283;
L284: ( D59 * ( 1. C141 ) ) = D59 by VECTSP_1:def 4;
thus L285: C143 in C142 by L284 , L281 , L11;
end;
L286: (for B112 being set holds (B112 in C142 implies B112 in (the carrier of C141)));
L287: C142 = (the carrier of C141) by L286 , L282 , TARSKI:1;
thus L288: thesis by L287 , L279 , SUBSET_1:def 6;
end;
thus L289: (for B113 being (Element of C141) holds (B113 is  unital implies (not B113 in C142)))
proof
let C144 being (Element of C141);
assume L290: C144 is  unital;
L291: C144 divides ( 1. C141 ) by L290 , GCD_1:def 2;
L292: (ex B114 being (Element of C141) st ( 1. C141 ) = ( C144 * B114 )) by L291 , GCD_1:def 1;
thus L293: thesis by L292 , L280 , L12;
end;

end;
L290:
now
L291: ( 1. C141 ) divides ( 1. C141 );
L292: ( 1. C141 ) is  unital by L291 , GCD_1:def 2;
assume L293: (for B115 being (Element of C141) holds (B115 is  unital implies (not B115 in C142)));
L294: C142 <> (the carrier of C141) by L293 , L292;
thus L295: C142 is  proper by L294 , SUBSET_1:def 6;
end;
thus L296: thesis by L290 , L278;
end;
theorem
L297: (for B116 being non  degenerated comRing holds (B116 is Field iff (for B117 being (Ideal of B116) holds (B117 = { ( 0. B116 ) } or B117 = (the carrier of B116)))))
proof
let C145 being non  degenerated comRing;
L298:
now
assume L299: C145 is Field;
thus L300: (for B118 being (Ideal of C145) holds (B118 = { ( 0. C145 ) } or B118 = (the carrier of C145)))
proof
let C146 being (Ideal of C145);
assume L301: C146 <> { ( 0. C145 ) };
reconsider D60 = C145 as Field by L299;
L302: (ex B119 being (Element of D60) st (B119 in C146 & B119 <> ( 0. D60 )))
proof
assume L303: (not (ex B120 being (Element of D60) st (B120 in C146 & B120 <> ( 0. D60 ))));
L304:
now
let C147 being set;
assume L305: C147 in C146;
reconsider D61 = C147 as (Element of C146) by L305;
L306: D61 = ( 0. D60 ) by L303;
thus L307: C147 in { ( 0. D60 ) } by L306 , TARSKI:def 1;
end;
L308:
now
let C148 being set;
assume L309: C148 in { ( 0. D60 ) };
reconsider D62 = C148 as (Element of D60) by L309;
L310: D62 = ( 0. D60 ) by L309 , TARSKI:def 1;
thus L311: C148 in C146 by L310 , L49;
end;
thus L312: thesis by L308 , L301 , L304 , TARSKI:1;
end;
consider C149 being (Element of D60) such that L313: C149 in C146 and L314: C149 <> ( 0. D60 ) by L302;
L315: (ex B121 being (Element of D60) st ( B121 * C149 ) = ( 1. D60 )) by L314 , VECTSP_1:def 9;
L316: ( 1. D60 ) in C146 by L315 , L313 , L12;
L317: C146 is non  proper by L316 , L248;
thus L318: thesis by L317 , SUBSET_1:def 6;
end;

end;
L301:
now
assume L302: (for B122 being (Ideal of C145) holds (B122 = { ( 0. C145 ) } or B122 = (the carrier of C145)));
L303:
now
let C150 being (Element of C145);
reconsider D63 = C150 as (Element of C145);
reconsider D64 = { ( D63 * B123 ) where B123 is (Element of C145) : (not contradiction) } as (Ideal of C145) by L224;
L304: ( C150 * ( 1. C145 ) ) = C150 by VECTSP_1:def 8;
L305: C150 in D64 by L304;
assume L306: C150 <> ( 0. C145 );
L307: D64 <> { ( 0. C145 ) } by L306 , L305 , TARSKI:def 1;
L308: D64 = (the carrier of C145) by L307 , L302;
L309: ( 1. C145 ) in D64 by L308;
L310: (ex B124 being (Element of C145) st ( C150 * B124 ) = ( 1. C145 )) by L309;
thus L311: (ex B125 being (Element of C145) st ( B125 * C150 ) = ( 1. C145 )) by L310;
end;
thus L312: C145 is Field by L303 , VECTSP_1:def 9;
end;
thus L313: thesis by L301 , L298;
end;
begin
definition
let C151 being non  empty multLoopStr;
let C152 being non  empty (Subset of C151);
mode LinearCombination of C152
 -> (FinSequence of (the carrier of C151))
means :L314: (for B126 being set holds (B126 in ( dom it ) implies (ex B127 , B128 being (Element of C151) st (ex B129 being (Element of C152) st ( it /. B126 ) = ( ( B127 * B129 ) * B128 )))));
existence
proof
set D65 = ( <*> (the carrier of C151) );
take D65;
let C153 being set;
assume L315: C153 in ( dom D65 );
thus L316: thesis by L315;
end;
mode LeftLinearCombination of C152
 -> (FinSequence of (the carrier of C151))
means :L317: (for B130 being set holds (B130 in ( dom it ) implies (ex B131 being (Element of C151) st (ex B132 being (Element of C152) st ( it /. B130 ) = ( B131 * B132 )))));
existence
proof
set D66 = the (Element of C152);
reconsider D67 = D66 as (Element of C151);
reconsider D68 = ( D66 * D66 ) as (Element of C151);
set D69 = <* D68 *>;
take D69;
let C154 being set;
assume L318: C154 in ( dom D69 );
take D67;
take D66;
L319: ( dom D69 ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L320: C154 = 1 by L319 , L318 , TARSKI:def 1;
thus L321: ( D69 /. C154 ) = ( D69 . C154 ) by L318 , PARTFUN1:def 6
.= ( D67 * D66 ) by L320 , FINSEQ_1:40;
end;
mode RightLinearCombination of C152
 -> (FinSequence of (the carrier of C151))
means :L322: (for B133 being set holds (B133 in ( dom it ) implies (ex B134 being (Element of C151) st (ex B135 being (Element of C152) st ( it /. B133 ) = ( B135 * B134 )))));
existence
proof
set D70 = the (Element of C152);
reconsider D71 = D70 as (Element of C151);
reconsider D72 = ( D70 * D70 ) as (Element of C151);
set D73 = <* D72 *>;
take D73;
let C155 being set;
assume L323: C155 in ( dom D73 );
take D71;
take D70;
L324: ( dom D73 ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L325: C155 = 1 by L324 , L323 , TARSKI:def 1;
thus L326: ( D73 /. C155 ) = ( D73 . C155 ) by L323 , PARTFUN1:def 6
.= ( D70 * D71 ) by L325 , FINSEQ_1:40;
end;
end;
registration
let C156 being non  empty multLoopStr;
let C157 being non  empty (Subset of C156);
cluster non  empty for (LinearCombination of C157);
existence
proof
set D74 = the (Element of C157);
set D75 = the (Element of C156);
set D76 = D75;
reconsider D77 = <* ( ( D75 * D74 ) * D76 ) *> as (FinSequence of (the carrier of C156));
take D77;
L328:
now
let C158 being set;
assume L329: C158 in ( dom D77 );
take D78 = D75;
take D79 = D76;
take D80 = D74;
L330: C158 in { 1 } by L329 , FINSEQ_1:2 , FINSEQ_1:38;
L331: C158 = 1 by L330 , TARSKI:def 1;
thus L332: ( D77 /. C158 ) = ( ( D78 * D80 ) * D79 ) by L331 , FINSEQ_4:16;
end;
thus L333: thesis by L328 , L314;
end;
cluster non  empty for (LeftLinearCombination of C157);
existence
proof
set D81 = the (Element of C157);
set D82 = the (Element of C156);
reconsider D83 = <* ( D82 * D81 ) *> as (FinSequence of (the carrier of C156));
take D83;
L334:
now
let C159 being set;
assume L335: C159 in ( dom D83 );
take D84 = D82;
take D85 = D81;
L336: C159 in { 1 } by L335 , FINSEQ_1:2 , FINSEQ_1:38;
L337: C159 = 1 by L336 , TARSKI:def 1;
thus L338: ( D83 /. C159 ) = ( D84 * D85 ) by L337 , FINSEQ_4:16;
end;
thus L339: thesis by L334 , L317;
end;
cluster non  empty for (RightLinearCombination of C157);
existence
proof
set D86 = the (Element of C157);
set D87 = the (Element of C156);
reconsider D88 = <* ( D86 * D87 ) *> as (FinSequence of (the carrier of C156));
take D88;
L340:
now
let C160 being set;
assume L341: C160 in ( dom D88 );
take D89 = D87;
take D90 = D86;
L342: C160 in { 1 } by L341 , FINSEQ_1:2 , FINSEQ_1:38;
L343: C160 = 1 by L342 , TARSKI:def 1;
thus L344: ( D88 /. C160 ) = ( D90 * D89 ) by L343 , FINSEQ_4:16;
end;
thus L345: thesis by L340 , L322;
end;
end;
definition
let C161 being non  empty multLoopStr;
let C162 , C163 being non  empty (Subset of C161);
let C164 being (LinearCombination of C162);
let C165 being (LinearCombination of C163);
redefine func C164 ^ C165 -> (LinearCombination of ( C162 \/ C163 ));

coherence
proof
set D91 = ( C164 ^ C165 );
thus L347: D91 is (LinearCombination of ( C162 \/ C163 ))
proof
let C166 being set;
assume L348: C166 in ( dom D91 );
reconsider D92 = C166 as (Element of ( NAT )) by L348;
per cases ;
suppose L349: D92 in ( dom C164 );

L350: (( C164 /. D92 ) = ( C164 . D92 ) & ( C164 . D92 ) = ( D91 . D92 )) by L349 , FINSEQ_1:def 7 , PARTFUN1:def 6;
consider C167 , C168 being (Element of C161), C169 being (Element of C162) such that L351: ( C164 /. D92 ) = ( ( C167 * C169 ) * C168 ) by L349 , L314;
L352: C169 in ( C162 \/ C163 ) by XBOOLE_0:def 3;
thus L353: thesis by L352 , L348 , L351 , L350 , PARTFUN1:def 6;
end;
suppose L354: (not D92 in ( dom C164 ));

consider C170 being Nat such that L355: C170 in ( dom C165 ) and L356: D92 = ( ( len C164 ) + C170 ) by L354 , L348 , FINSEQ_1:25;
L357: (( C165 /. C170 ) = ( C165 . C170 ) & ( C165 . C170 ) = ( D91 . D92 )) by L355 , L356 , FINSEQ_1:def 7 , PARTFUN1:def 6;
consider C171 , C172 being (Element of C161), C173 being (Element of C163) such that L358: ( C165 /. C170 ) = ( ( C171 * C173 ) * C172 ) by L355 , L314;
L359: C173 in ( C162 \/ C163 ) by XBOOLE_0:def 3;
thus L360: thesis by L359 , L348 , L358 , L357 , PARTFUN1:def 6;
end;
end;

end;
end;
theorem
L349: (for B136 being  associative non  empty multLoopStr holds (for B137 being non  empty (Subset of B136) holds (for B138 being (Element of B136) holds (for B139 being (LinearCombination of B137) holds ( B138 * B139 ) is (LinearCombination of B137)))))
proof
let C174 being  associative non  empty multLoopStr;
let C175 being non  empty (Subset of C174);
let C176 being (Element of C174);
let C177 being (LinearCombination of C175);
let C178 being set;
assume L350: C178 in ( dom ( C176 * C177 ) );
L351: C178 in ( dom C177 ) by L350 , POLYNOM1:def 1;
consider C179 , C180 being (Element of C174), C181 being (Element of C175) such that L352: ( C177 /. C178 ) = ( ( C179 * C181 ) * C180 ) by L351 , L314;
take D93 = ( C176 * C179 );
take C180;
take C181;
thus L353: ( ( C176 * C177 ) /. C178 ) = ( C176 * ( C177 /. C178 ) ) by L351 , POLYNOM1:def 1
.= ( ( C176 * ( C179 * C181 ) ) * C180 ) by L352 , GROUP_1:def 3
.= ( ( D93 * C181 ) * C180 ) by GROUP_1:def 3;
end;
theorem
L354: (for B140 being  associative non  empty multLoopStr holds (for B141 being non  empty (Subset of B140) holds (for B142 being (Element of B140) holds (for B143 being (LinearCombination of B141) holds ( B143 * B142 ) is (LinearCombination of B141)))))
proof
let C182 being  associative non  empty multLoopStr;
let C183 being non  empty (Subset of C182);
let C184 being (Element of C182);
let C185 being (LinearCombination of C183);
let C186 being set;
assume L355: C186 in ( dom ( C185 * C184 ) );
L356: C186 in ( dom C185 ) by L355 , POLYNOM1:def 2;
consider C187 , C188 being (Element of C182), C189 being (Element of C183) such that L357: ( C185 /. C186 ) = ( ( C187 * C189 ) * C188 ) by L356 , L314;
take C187;
take D94 = ( C188 * C184 );
take C189;
thus L358: ( ( C185 * C184 ) /. C186 ) = ( ( C185 /. C186 ) * C184 ) by L356 , POLYNOM1:def 2
.= ( ( C187 * ( C189 * C188 ) ) * C184 ) by L357 , GROUP_1:def 3
.= ( C187 * ( ( C189 * C188 ) * C184 ) ) by GROUP_1:def 3
.= ( C187 * ( C189 * ( C188 * C184 ) ) ) by GROUP_1:def 3
.= ( ( C187 * C189 ) * D94 ) by GROUP_1:def 3;
end;
theorem
L359: (for B144 being  right_unital non  empty multLoopStr holds (for B145 being non  empty (Subset of B144) holds (for B146 being (LeftLinearCombination of B145) holds B146 is (LinearCombination of B145))))
proof
let C190 being  right_unital non  empty multLoopStr;
let C191 being non  empty (Subset of C190);
let C192 being (LeftLinearCombination of C191);
let C193 being set;
assume L360: C193 in ( dom C192 );
consider C194 being (Element of C190), C195 being (Element of C191) such that L361: ( C192 /. C193 ) = ( C194 * C195 ) by L360 , L317;
L362: ( C192 /. C193 ) = ( ( C194 * C195 ) * ( 1. C190 ) ) by L361 , VECTSP_1:def 4;
thus L363: thesis by L362;
end;
definition
let C196 being non  empty multLoopStr;
let C197 , C198 being non  empty (Subset of C196);
let C199 being (LeftLinearCombination of C197);
let C200 being (LeftLinearCombination of C198);
redefine func C199 ^ C200 -> (LeftLinearCombination of ( C197 \/ C198 ));

coherence
proof
set D95 = ( C199 ^ C200 );
thus L364: D95 is (LeftLinearCombination of ( C197 \/ C198 ))
proof
let C201 being set;
assume L365: C201 in ( dom D95 );
reconsider D96 = C201 as (Element of ( NAT )) by L365;
per cases ;
suppose L366: D96 in ( dom C199 );

L367: (( C199 /. D96 ) = ( C199 . D96 ) & ( C199 . D96 ) = ( D95 . D96 )) by L366 , FINSEQ_1:def 7 , PARTFUN1:def 6;
consider C202 being (Element of C196), C203 being (Element of C197) such that L368: ( C199 /. D96 ) = ( C202 * C203 ) by L366 , L317;
L369: C203 in ( C197 \/ C198 ) by XBOOLE_0:def 3;
thus L370: thesis by L369 , L365 , L368 , L367 , PARTFUN1:def 6;
end;
suppose L371: (not D96 in ( dom C199 ));

consider C204 being Nat such that L372: C204 in ( dom C200 ) and L373: D96 = ( ( len C199 ) + C204 ) by L371 , L365 , FINSEQ_1:25;
L374: (( C200 /. C204 ) = ( C200 . C204 ) & ( C200 . C204 ) = ( D95 . D96 )) by L372 , L373 , FINSEQ_1:def 7 , PARTFUN1:def 6;
consider C205 being (Element of C196), C206 being (Element of C198) such that L375: ( C200 /. C204 ) = ( C205 * C206 ) by L372 , L317;
L376: C206 in ( C197 \/ C198 ) by XBOOLE_0:def 3;
thus L377: thesis by L376 , L365 , L375 , L374 , PARTFUN1:def 6;
end;
end;

end;
end;
theorem
L366: (for B147 being  associative non  empty multLoopStr holds (for B148 being non  empty (Subset of B147) holds (for B149 being (Element of B147) holds (for B150 being (LeftLinearCombination of B148) holds ( B149 * B150 ) is (LeftLinearCombination of B148)))))
proof
let C207 being  associative non  empty multLoopStr;
let C208 being non  empty (Subset of C207);
let C209 being (Element of C207);
let C210 being (LeftLinearCombination of C208);
let C211 being set;
assume L367: C211 in ( dom ( C209 * C210 ) );
L368: C211 in ( dom C210 ) by L367 , POLYNOM1:def 1;
consider C212 being (Element of C207), C213 being (Element of C208) such that L369: ( C210 /. C211 ) = ( C212 * C213 ) by L368 , L317;
take D97 = ( C209 * C212 );
take C213;
thus L370: ( ( C209 * C210 ) /. C211 ) = ( C209 * ( C210 /. C211 ) ) by L368 , POLYNOM1:def 1
.= ( D97 * C213 ) by L369 , GROUP_1:def 3;
end;
theorem
L371: (for B151 being non  empty multLoopStr holds (for B152 being non  empty (Subset of B151) holds (for B153 being (Element of B151) holds (for B154 being (LeftLinearCombination of B152) holds ( B154 * B153 ) is (LinearCombination of B152)))))
proof
let C214 being non  empty multLoopStr;
let C215 being non  empty (Subset of C214);
let C216 being (Element of C214);
let C217 being (LeftLinearCombination of C215);
let C218 being set;
reconsider D98 = C216 as (Element of C214);
assume L372: C218 in ( dom ( C217 * C216 ) );
L373: C218 in ( dom C217 ) by L372 , POLYNOM1:def 2;
consider C219 being (Element of C214), C220 being (Element of C215) such that L374: ( C217 /. C218 ) = ( C219 * C220 ) by L373 , L317;
take C219;
take D98;
take C220;
thus L375: thesis by L373 , L374 , POLYNOM1:def 2;
end;
theorem
L376: (for B155 being  left_unital non  empty multLoopStr holds (for B156 being non  empty (Subset of B155) holds (for B157 being (RightLinearCombination of B156) holds B157 is (LinearCombination of B156))))
proof
let C221 being  left_unital non  empty multLoopStr;
let C222 being non  empty (Subset of C221);
let C223 being (RightLinearCombination of C222);
let C224 being set;
assume L377: C224 in ( dom C223 );
consider C225 being (Element of C221), C226 being (Element of C222) such that L378: ( C223 /. C224 ) = ( C226 * C225 ) by L377 , L322;
L379: ( C223 /. C224 ) = ( ( ( 1. C221 ) * C226 ) * C225 ) by L378 , VECTSP_1:def 8;
thus L380: thesis by L379;
end;
definition
let C227 being non  empty multLoopStr;
let C228 , C229 being non  empty (Subset of C227);
let C230 being (RightLinearCombination of C228);
let C231 being (RightLinearCombination of C229);
redefine func C230 ^ C231 -> (RightLinearCombination of ( C228 \/ C229 ));

coherence
proof
set D99 = ( C230 ^ C231 );
thus L381: D99 is (RightLinearCombination of ( C228 \/ C229 ))
proof
let C232 being set;
assume L382: C232 in ( dom D99 );
reconsider D100 = C232 as (Element of ( NAT )) by L382;
per cases ;
suppose L383: D100 in ( dom C230 );

L384: (( C230 /. D100 ) = ( C230 . D100 ) & ( C230 . D100 ) = ( D99 . D100 )) by L383 , FINSEQ_1:def 7 , PARTFUN1:def 6;
consider C233 being (Element of C227), C234 being (Element of C228) such that L385: ( C230 /. D100 ) = ( C234 * C233 ) by L383 , L322;
L386: C234 in ( C228 \/ C229 ) by XBOOLE_0:def 3;
thus L387: thesis by L386 , L382 , L385 , L384 , PARTFUN1:def 6;
end;
suppose L388: (not D100 in ( dom C230 ));

consider C235 being Nat such that L389: C235 in ( dom C231 ) and L390: D100 = ( ( len C230 ) + C235 ) by L388 , L382 , FINSEQ_1:25;
L391: (( C231 /. C235 ) = ( C231 . C235 ) & ( C231 . C235 ) = ( D99 . D100 )) by L389 , L390 , FINSEQ_1:def 7 , PARTFUN1:def 6;
consider C236 being (Element of C227), C237 being (Element of C229) such that L392: ( C231 /. C235 ) = ( C237 * C236 ) by L389 , L322;
L393: C237 in ( C228 \/ C229 ) by XBOOLE_0:def 3;
thus L394: thesis by L393 , L382 , L392 , L391 , PARTFUN1:def 6;
end;
end;

end;
end;
theorem
L383: (for B158 being  associative non  empty multLoopStr holds (for B159 being non  empty (Subset of B158) holds (for B160 being (Element of B158) holds (for B161 being (RightLinearCombination of B159) holds ( B161 * B160 ) is (RightLinearCombination of B159)))))
proof
let C238 being  associative non  empty multLoopStr;
let C239 being non  empty (Subset of C238);
let C240 being (Element of C238);
let C241 being (RightLinearCombination of C239);
let C242 being set;
assume L384: C242 in ( dom ( C241 * C240 ) );
L385: C242 in ( dom C241 ) by L384 , POLYNOM1:def 2;
consider C243 being (Element of C238), C244 being (Element of C239) such that L386: ( C241 /. C242 ) = ( C244 * C243 ) by L385 , L322;
take D101 = ( C243 * C240 );
take C244;
thus L387: ( ( C241 * C240 ) /. C242 ) = ( ( C241 /. C242 ) * C240 ) by L385 , POLYNOM1:def 2
.= ( C244 * D101 ) by L386 , GROUP_1:def 3;
end;
theorem
L388: (for B162 being  associative non  empty multLoopStr holds (for B163 being non  empty (Subset of B162) holds (for B164 being (Element of B162) holds (for B165 being (RightLinearCombination of B163) holds ( B164 * B165 ) is (LinearCombination of B163)))))
proof
let C245 being  associative non  empty multLoopStr;
let C246 being non  empty (Subset of C245);
let C247 being (Element of C245);
let C248 being (RightLinearCombination of C246);
let C249 being set;
reconsider D102 = C247 as (Element of C245);
assume L389: C249 in ( dom ( C247 * C248 ) );
L390: C249 in ( dom C248 ) by L389 , POLYNOM1:def 1;
consider C250 being (Element of C245), C251 being (Element of C246) such that L391: ( C248 /. C249 ) = ( C251 * C250 ) by L390 , L322;
take D102;
take C250;
take C251;
thus L392: ( ( C247 * C248 ) /. C249 ) = ( C247 * ( C248 /. C249 ) ) by L390 , POLYNOM1:def 1
.= ( ( D102 * C251 ) * C250 ) by L391 , GROUP_1:def 3;
end;
theorem
L393: (for B166 being  commutative  associative non  empty multLoopStr holds (for B167 being non  empty (Subset of B166) holds (for B168 being (LinearCombination of B167) holds (B168 is (LeftLinearCombination of B167) & B168 is (RightLinearCombination of B167)))))
proof
let C252 being  commutative  associative non  empty multLoopStr;
let C253 being non  empty (Subset of C252);
let C254 being (LinearCombination of C253);
thus L394:now
let C255 being set;
assume L395: C255 in ( dom C254 );
consider C256 , C257 being (Element of C252), C258 being (Element of C253) such that L396: ( C254 /. C255 ) = ( ( C256 * C258 ) * C257 ) by L395 , L314;
L397: ( C254 /. C255 ) = ( ( C256 * C257 ) * C258 ) by L396 , GROUP_1:def 3;
thus L398: (ex B169 being (Element of C252) st (ex B170 being (Element of C253) st ( C254 /. C255 ) = ( B169 * B170 ))) by L397;
end;
let C259 being set;
assume L399: C259 in ( dom C254 );
consider C260 , C261 being (Element of C252), C262 being (Element of C253) such that L400: ( C254 /. C259 ) = ( ( C260 * C262 ) * C261 ) by L399 , L314;
L401: ( C254 /. C259 ) = ( C262 * ( C260 * C261 ) ) by L400 , GROUP_1:def 3;
thus L402: (ex B171 being (Element of C252) st (ex B172 being (Element of C253) st ( C254 /. C259 ) = ( B172 * B171 ))) by L401;
end;
theorem
L403: (for B173 being non  empty doubleLoopStr holds (for B174 being non  empty (Subset of B173) holds (for B175 being non  empty (LinearCombination of B174) holds (ex B176 being (LinearCombination of B174) st (ex B177 being (Element of B173) st (B175 = ( B176 ^ <* B177 *> ) & <* B177 *> is (LinearCombination of B174)))))))
proof
let C263 being non  empty doubleLoopStr;
let C264 being non  empty (Subset of C263);
let C265 being non  empty (LinearCombination of C264);
L404: ( len C265 ) <> ( 0 );
consider C266 being (FinSequence of (the carrier of C263)), C267 being (Element of C263) such that L405: C265 = ( C266 ^ <* C267 *> ) by L404 , FINSEQ_2:19;
L406:
now
let C268 being set;
assume L407: C268 in ( dom C266 );
reconsider D103 = C268 as (Element of ( NAT )) by L407;
L408: ( dom C266 ) c= ( dom C265 ) by L405 , FINSEQ_1:26;
consider C269 , C270 being (Element of C263), C271 being (Element of C264) such that L409: ( C265 /. C268 ) = ( ( C269 * C271 ) * C270 ) by L408 , L407 , L314;
take D104 = C269;
take D105 = C270;
take D106 = C271;
thus L410: ( C266 /. C268 ) = ( C266 . C268 ) by L407 , PARTFUN1:def 6
.= ( C265 . D103 ) by L405 , L407 , FINSEQ_1:def 7
.= ( ( D104 * D106 ) * D105 ) by L407 , L408 , L409 , PARTFUN1:def 6;
end;
reconsider D107 = C266 as (LinearCombination of C264) by L406 , L314;
L411: ( len C265 ) = ( ( len D107 ) + 1 ) by L405 , FINSEQ_2:16;
take D107;
take C267;
thus L412: C265 = ( D107 ^ <* C267 *> ) by L405;
let C272 being set;
assume that
L413: C272 in ( dom <* C267 *> );
L414: ( len C265 ) in ( dom C265 ) by FINSEQ_5:6;
L415: ( C265 /. ( len C265 ) ) = ( C265 . ( len C265 ) ) by L414 , PARTFUN1:def 6;
L416: ( dom <* C267 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L417: C272 = 1 by L416 , L413 , TARSKI:def 1;
consider C273 , C274 being (Element of C263), C275 being (Element of C264) such that L418: ( C265 /. ( len C265 ) ) = ( ( C273 * C275 ) * C274 ) by L414 , L314;
take C273;
take C274;
take C275;
thus L419: ( <* C267 *> /. C272 ) = ( <* C267 *> . C272 ) by L413 , PARTFUN1:def 6
.= C267 by L417 , FINSEQ_1:40
.= ( ( C273 * C275 ) * C274 ) by L405 , L411 , L418 , L415 , FINSEQ_1:42;
end;
theorem
L420: (for B178 being non  empty doubleLoopStr holds (for B179 being non  empty (Subset of B178) holds (for B180 being non  empty (LeftLinearCombination of B179) holds (ex B181 being (LeftLinearCombination of B179) st (ex B182 being (Element of B178) st (B180 = ( B181 ^ <* B182 *> ) & <* B182 *> is (LeftLinearCombination of B179)))))))
proof
let C276 being non  empty doubleLoopStr;
let C277 being non  empty (Subset of C276);
let C278 being non  empty (LeftLinearCombination of C277);
L421: ( len C278 ) <> ( 0 );
consider C279 being (FinSequence of (the carrier of C276)), C280 being (Element of C276) such that L422: C278 = ( C279 ^ <* C280 *> ) by L421 , FINSEQ_2:19;
L423:
now
let C281 being set;
assume L424: C281 in ( dom C279 );
reconsider D108 = C281 as (Element of ( NAT )) by L424;
L425: ( dom C279 ) c= ( dom C278 ) by L422 , FINSEQ_1:26;
consider C282 being (Element of C276), C283 being (Element of C277) such that L426: ( C278 /. C281 ) = ( C282 * C283 ) by L425 , L424 , L317;
take D109 = C282;
take D110 = C283;
thus L427: ( C279 /. C281 ) = ( C279 . C281 ) by L424 , PARTFUN1:def 6
.= ( C278 . D108 ) by L422 , L424 , FINSEQ_1:def 7
.= ( D109 * D110 ) by L424 , L425 , L426 , PARTFUN1:def 6;
end;
reconsider D111 = C279 as (LeftLinearCombination of C277) by L423 , L317;
L428: ( len C278 ) = ( ( len D111 ) + 1 ) by L422 , FINSEQ_2:16;
take D111;
take C280;
thus L429: C278 = ( D111 ^ <* C280 *> ) by L422;
let C284 being set;
assume that
L430: C284 in ( dom <* C280 *> );
L431: ( len C278 ) in ( dom C278 ) by FINSEQ_5:6;
L432: ( C278 /. ( len C278 ) ) = ( C278 . ( len C278 ) ) by L431 , PARTFUN1:def 6;
L433: ( dom <* C280 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L434: C284 = 1 by L433 , L430 , TARSKI:def 1;
consider C285 being (Element of C276), C286 being (Element of C277) such that L435: ( C278 /. ( len C278 ) ) = ( C285 * C286 ) by L431 , L317;
take C285;
take C286;
thus L436: ( <* C280 *> /. C284 ) = ( <* C280 *> . C284 ) by L430 , PARTFUN1:def 6
.= C280 by L434 , FINSEQ_1:40
.= ( C285 * C286 ) by L422 , L428 , L435 , L432 , FINSEQ_1:42;
end;
theorem
L437: (for B183 being non  empty doubleLoopStr holds (for B184 being non  empty (Subset of B183) holds (for B185 being non  empty (RightLinearCombination of B184) holds (ex B186 being (RightLinearCombination of B184) st (ex B187 being (Element of B183) st (B185 = ( B186 ^ <* B187 *> ) & <* B187 *> is (RightLinearCombination of B184)))))))
proof
let C287 being non  empty doubleLoopStr;
let C288 being non  empty (Subset of C287);
let C289 being non  empty (RightLinearCombination of C288);
L438: ( len C289 ) <> ( 0 );
consider C290 being (FinSequence of (the carrier of C287)), C291 being (Element of C287) such that L439: C289 = ( C290 ^ <* C291 *> ) by L438 , FINSEQ_2:19;
L440:
now
let C292 being set;
assume L441: C292 in ( dom C290 );
reconsider D112 = C292 as (Element of ( NAT )) by L441;
L442: ( dom C290 ) c= ( dom C289 ) by L439 , FINSEQ_1:26;
consider C293 being (Element of C287), C294 being (Element of C288) such that L443: ( C289 /. C292 ) = ( C294 * C293 ) by L442 , L441 , L322;
take D113 = C293;
take D114 = C294;
thus L444: ( C290 /. C292 ) = ( C290 . C292 ) by L441 , PARTFUN1:def 6
.= ( C289 . D112 ) by L439 , L441 , FINSEQ_1:def 7
.= ( D114 * D113 ) by L441 , L442 , L443 , PARTFUN1:def 6;
end;
reconsider D115 = C290 as (RightLinearCombination of C288) by L440 , L322;
L445: ( len C289 ) = ( ( len D115 ) + 1 ) by L439 , FINSEQ_2:16;
take D115;
take C291;
thus L446: C289 = ( D115 ^ <* C291 *> ) by L439;
let C295 being set;
assume that
L447: C295 in ( dom <* C291 *> );
L448: ( len C289 ) in ( dom C289 ) by FINSEQ_5:6;
L449: ( C289 /. ( len C289 ) ) = ( C289 . ( len C289 ) ) by L448 , PARTFUN1:def 6;
L450: ( dom <* C291 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L451: C295 = 1 by L450 , L447 , TARSKI:def 1;
consider C296 being (Element of C287), C297 being (Element of C288) such that L452: ( C289 /. ( len C289 ) ) = ( C297 * C296 ) by L448 , L322;
take C296;
take C297;
thus L453: ( <* C291 *> /. C295 ) = ( <* C291 *> . C295 ) by L447 , PARTFUN1:def 6
.= C291 by L451 , FINSEQ_1:40
.= ( C297 * C296 ) by L439 , L445 , L452 , L449 , FINSEQ_1:42;
end;
definition
let C298 being non  empty multLoopStr;
let C299 being non  empty (Subset of C298);
let C300 being (LinearCombination of C299);
let C301 being (FinSequence of [: (the carrier of C298) , (the carrier of C298) , (the carrier of C298) :]);
pred C301 represents C300
means
:L454: (( len C301 ) = ( len C300 ) & (for B188 being set holds (B188 in ( dom C300 ) implies (( C300 . B188 ) = ( ( ( ( C301 /. B188 ) `1_3 ) * ( ( C301 /. B188 ) `2_3 ) ) * ( ( C301 /. B188 ) `3_3 ) ) & ( ( C301 /. B188 ) `2_3 ) in C299))))
;end;
theorem
L456: (for B189 being non  empty multLoopStr holds (for B190 being non  empty (Subset of B189) holds (for B191 being (LinearCombination of B190) holds (ex B192 being (FinSequence of [: (the carrier of B189) , (the carrier of B189) , (the carrier of B189) :]) st B192 represents B191))))
proof
let C302 being non  empty multLoopStr;
let C303 being non  empty (Subset of C302);
let C304 being (LinearCombination of C303);
set D116 = [: (the carrier of C302) , (the carrier of C302) , (the carrier of C302) :];
defpred S3[ set , set ] means (ex B193 , B194 , B195 being (Element of C302) st ($2 = [ B193 , B194 , B195 ] & B194 in C303 & ( C304 /. $1 ) = ( ( B193 * B194 ) * B195 )));
L457:
now
let C305 being (Element of ( NAT ));
assume L458: C305 in ( Seg ( len C304 ) );
L459: C305 in ( dom C304 ) by L458 , FINSEQ_1:def 3;
consider C306 , C307 being (Element of C302), C308 being (Element of C303) such that L460: ( C304 /. C305 ) = ( ( C306 * C308 ) * C307 ) by L459 , L314;
reconsider D117 = C308 as (Element of C302);
reconsider D118 = [ C306 , D117 , C307 ] as (Element of D116);
take D119 = D118;
thus L461: S3[ C305 , D119 ] by L460;
end;
consider C309 being (FinSequence of D116) such that L462: ( dom C309 ) = ( Seg ( len C304 ) ) and L463: (for B196 being (Element of ( NAT )) holds (B196 in ( Seg ( len C304 ) ) implies S3[ B196 , ( C309 /. B196 ) ])) from RECDEF_1:sch 17(L457);
take C309;
thus L464: ( len C309 ) = ( len C304 ) by L462 , FINSEQ_1:def 3;
let C310 being set;
assume that
L465: C310 in ( dom C304 );
reconsider D120 = C310 as (Element of ( NAT )) by L465;
L466: ( dom C304 ) = ( Seg ( len C304 ) ) by FINSEQ_1:def 3;
consider C311 , C312 , C313 being (Element of C302) such that L467: ( C309 /. D120 ) = [ C311 , C312 , C313 ] and L468: C312 in C303 and L469: ( C304 /. D120 ) = ( ( C311 * C312 ) * C313 ) by L466 , L463 , L465;
L470: ( [ C311 , C312 , C313 ] `3_3 ) = C313;
L471: (( [ C311 , C312 , C313 ] `1_3 ) = C311 & ( [ C311 , C312 , C313 ] `2_3 ) = C312);
thus L472: ( C304 . C310 ) = ( ( ( ( C309 /. C310 ) `1_3 ) * ( ( C309 /. C310 ) `2_3 ) ) * ( ( C309 /. C310 ) `3_3 ) ) by L471 , L465 , L467 , L469 , L470 , PARTFUN1:def 6;
thus L473: thesis by L467 , L468 , MCART_1:def 6;
end;
theorem
L474: (for B197 , B198 being non  empty multLoopStr holds (for B199 being non  empty (Subset of B197) holds (for B200 being (LinearCombination of B199) holds (for B201 being non  empty (Subset of B198) holds (for B202 being (Function of (the carrier of B197) , (the carrier of B198)) holds (for B203 being (FinSequence of [: (the carrier of B197) , (the carrier of B197) , (the carrier of B197) :]) holds ((( B202 .: B199 ) c= B201 & B203 represents B200) implies (ex B204 being (LinearCombination of B201) st (( len B200 ) = ( len B204 ) & (for B205 being set holds (B205 in ( dom B204 ) implies ( B204 . B205 ) = ( ( ( B202 . ( ( B203 /. B205 ) `1_3 ) ) * ( B202 . ( ( B203 /. B205 ) `2_3 ) ) ) * ( B202 . ( ( B203 /. B205 ) `3_3 ) ) ))))))))))))
proof
let C314 , C315 being non  empty multLoopStr;
let C316 being non  empty (Subset of C314);
let C317 being (LinearCombination of C316);
let C318 being non  empty (Subset of C315);
let C319 being (Function of (the carrier of C314) , (the carrier of C315));
let C320 being (FinSequence of [: (the carrier of C314) , (the carrier of C314) , (the carrier of C314) :]);
assume L475: ( C319 .: C316 ) c= C318;
deffunc H1(Nat) = ( ( ( C319 . ( ( C320 /. $1 ) `1_3 ) ) * ( C319 . ( ( C320 /. $1 ) `2_3 ) ) ) * ( C319 . ( ( C320 /. $1 ) `3_3 ) ) );
consider C321 being (FinSequence of (the carrier of C315)) such that L476: ( len C321 ) = ( len C317 ) and L477: (for B206 being Nat holds (B206 in ( dom C321 ) implies ( C321 . B206 ) = H1(B206))) from FINSEQ_2:sch 1;
assume L478: C320 represents C317;
L479:
now
let C322 being set;
assume that
L480: C322 in ( dom C321 );
L481: ( dom C317 ) = ( dom C321 ) by L476 , FINSEQ_3:29;
L482: (( dom C319 ) = (the carrier of C314) & ( ( C320 /. C322 ) `2_3 ) in C316) by L481 , L478 , L480 , L454 , FUNCT_2:def 1;
L483: ( C319 . ( ( C320 /. C322 ) `2_3 ) ) in ( C319 .: C316 ) by L482 , FUNCT_1:def 6;
reconsider D121 = ( C319 . ( ( C320 /. C322 ) `2_3 ) ) as (Element of C318) by L483 , L475;
reconsider D122 = ( C319 . ( ( C320 /. C322 ) `1_3 ) ) , D123 = ( C319 . ( ( C320 /. C322 ) `3_3 ) ) as (Element of C315);
take D124 = D122;
take D125 = D123;
take D126 = D121;
L484: ( C321 . C322 ) = ( C321 /. C322 ) by L480 , PARTFUN1:def 6;
thus L485: ( C321 /. C322 ) = ( ( D124 * D126 ) * D125 ) by L484 , L477 , L480;
end;
reconsider D127 = C321 as (LinearCombination of C318) by L479 , L314;
take D127;
thus L486: ( len C317 ) = ( len D127 ) by L476;
let C323 being set;
assume L487: C323 in ( dom D127 );
thus L488: thesis by L487 , L477;
end;
definition
let C324 being non  empty multLoopStr;
let C325 being non  empty (Subset of C324);
let C326 being (LeftLinearCombination of C325);
let C327 being (FinSequence of [: (the carrier of C324) , (the carrier of C324) :]);
pred C327 represents C326
means
:L489: (( len C327 ) = ( len C326 ) & (for B207 being set holds (B207 in ( dom C326 ) implies (( C326 . B207 ) = ( ( ( C327 /. B207 ) `1 ) * ( ( C327 /. B207 ) `2 ) ) & ( ( C327 /. B207 ) `2 ) in C325))))
;end;
theorem
L491: (for B208 being non  empty multLoopStr holds (for B209 being non  empty (Subset of B208) holds (for B210 being (LeftLinearCombination of B209) holds (ex B211 being (FinSequence of [: (the carrier of B208) , (the carrier of B208) :]) st B211 represents B210))))
proof
let C328 being non  empty multLoopStr;
let C329 being non  empty (Subset of C328);
let C330 being (LeftLinearCombination of C329);
set D128 = [: (the carrier of C328) , (the carrier of C328) :];
defpred S4[ set , set ] means (ex B212 , B213 being (Element of C328) st ($2 = [ B212 , B213 ] & B213 in C329 & ( C330 /. $1 ) = ( B212 * B213 )));
L492:
now
let C331 being (Element of ( NAT ));
assume L493: C331 in ( Seg ( len C330 ) );
L494: C331 in ( dom C330 ) by L493 , FINSEQ_1:def 3;
consider C332 being (Element of C328), C333 being (Element of C329) such that L495: ( C330 /. C331 ) = ( C332 * C333 ) by L494 , L317;
reconsider D129 = C333 as (Element of C328);
reconsider D130 = [ C332 , D129 ] as (Element of D128);
take D131 = D130;
thus L496: S4[ C331 , D131 ] by L495;
end;
consider C334 being (FinSequence of D128) such that L497: ( dom C334 ) = ( Seg ( len C330 ) ) and L498: (for B214 being (Element of ( NAT )) holds (B214 in ( Seg ( len C330 ) ) implies S4[ B214 , ( C334 /. B214 ) ])) from RECDEF_1:sch 17(L492);
take C334;
thus L499: ( len C334 ) = ( len C330 ) by L497 , FINSEQ_1:def 3;
let C335 being set;
assume that
L500: C335 in ( dom C330 );
reconsider D132 = C335 as (Element of ( NAT )) by L500;
L501: ( dom C330 ) = ( Seg ( len C330 ) ) by FINSEQ_1:def 3;
consider C336 , C337 being (Element of C328) such that L502: ( C334 /. D132 ) = [ C336 , C337 ] and L503: C337 in C329 and L504: ( C330 /. D132 ) = ( C336 * C337 ) by L501 , L498 , L500;
L505: (( [ C336 , C337 ] `1 ) = C336 & ( [ C336 , C337 ] `2 ) = C337);
thus L506: ( C330 . C335 ) = ( ( ( C334 /. C335 ) `1 ) * ( ( C334 /. C335 ) `2 ) ) by L505 , L500 , L502 , L504 , PARTFUN1:def 6;
thus L507: thesis by L502 , L503 , L505;
end;
theorem
L508: (for B215 , B216 being non  empty multLoopStr holds (for B217 being non  empty (Subset of B215) holds (for B218 being (LeftLinearCombination of B217) holds (for B219 being non  empty (Subset of B216) holds (for B220 being (Function of (the carrier of B215) , (the carrier of B216)) holds (for B221 being (FinSequence of [: (the carrier of B215) , (the carrier of B215) :]) holds ((( B220 .: B217 ) c= B219 & B221 represents B218) implies (ex B222 being (LeftLinearCombination of B219) st (( len B218 ) = ( len B222 ) & (for B223 being set holds (B223 in ( dom B222 ) implies ( B222 . B223 ) = ( ( B220 . ( ( B221 /. B223 ) `1 ) ) * ( B220 . ( ( B221 /. B223 ) `2 ) ) ))))))))))))
proof
let C338 , C339 being non  empty multLoopStr;
let C340 being non  empty (Subset of C338);
let C341 being (LeftLinearCombination of C340);
let C342 being non  empty (Subset of C339);
let C343 being (Function of (the carrier of C338) , (the carrier of C339));
let C344 being (FinSequence of [: (the carrier of C338) , (the carrier of C338) :]);
assume L509: ( C343 .: C340 ) c= C342;
deffunc H2(Nat) = ( ( C343 . ( ( C344 /. $1 ) `1 ) ) * ( C343 . ( ( C344 /. $1 ) `2 ) ) );
consider C345 being (FinSequence of (the carrier of C339)) such that L510: ( len C345 ) = ( len C341 ) and L511: (for B224 being Nat holds (B224 in ( dom C345 ) implies ( C345 . B224 ) = H2(B224))) from FINSEQ_2:sch 1;
assume L512: C344 represents C341;
L513:
now
let C346 being set;
assume that
L514: C346 in ( dom C345 );
L515: ( dom C341 ) = ( dom C345 ) by L510 , FINSEQ_3:29;
L516: (( dom C343 ) = (the carrier of C338) & ( ( C344 /. C346 ) `2 ) in C340) by L515 , L512 , L514 , L489 , FUNCT_2:def 1;
L517: ( C343 . ( ( C344 /. C346 ) `2 ) ) in ( C343 .: C340 ) by L516 , FUNCT_1:def 6;
reconsider D133 = ( C343 . ( ( C344 /. C346 ) `2 ) ) as (Element of C342) by L517 , L509;
reconsider D134 = ( C343 . ( ( C344 /. C346 ) `1 ) ) as (Element of C339);
take D135 = D134;
take D136 = D133;
L518: ( C345 . C346 ) = ( C345 /. C346 ) by L514 , PARTFUN1:def 6;
thus L519: ( C345 /. C346 ) = ( D135 * D136 ) by L518 , L511 , L514;
end;
reconsider D137 = C345 as (LeftLinearCombination of C342) by L513 , L317;
take D137;
thus L520: ( len C341 ) = ( len D137 ) by L510;
let C347 being set;
assume L521: C347 in ( dom D137 );
thus L522: thesis by L521 , L511;
end;
definition
let C348 being non  empty multLoopStr;
let C349 being non  empty (Subset of C348);
let C350 being (RightLinearCombination of C349);
let C351 being (FinSequence of [: (the carrier of C348) , (the carrier of C348) :]);
pred C351 represents C350
means
:L523: (( len C351 ) = ( len C350 ) & (for B225 being set holds (B225 in ( dom C350 ) implies (( C350 . B225 ) = ( ( ( C351 /. B225 ) `1 ) * ( ( C351 /. B225 ) `2 ) ) & ( ( C351 /. B225 ) `1 ) in C349))))
;end;
theorem
L525: (for B226 being non  empty multLoopStr holds (for B227 being non  empty (Subset of B226) holds (for B228 being (RightLinearCombination of B227) holds (ex B229 being (FinSequence of [: (the carrier of B226) , (the carrier of B226) :]) st B229 represents B228))))
proof
let C352 being non  empty multLoopStr;
let C353 being non  empty (Subset of C352);
let C354 being (RightLinearCombination of C353);
set D138 = [: (the carrier of C352) , (the carrier of C352) :];
defpred S5[ set , set ] means (ex B230 , B231 being (Element of C352) st ($2 = [ B230 , B231 ] & B230 in C353 & ( C354 /. $1 ) = ( B230 * B231 )));
L526:
now
let C355 being (Element of ( NAT ));
assume L527: C355 in ( Seg ( len C354 ) );
L528: C355 in ( dom C354 ) by L527 , FINSEQ_1:def 3;
consider C356 being (Element of C352), C357 being (Element of C353) such that L529: ( C354 /. C355 ) = ( C357 * C356 ) by L528 , L322;
reconsider D139 = C357 as (Element of C352);
reconsider D140 = [ D139 , C356 ] as (Element of D138);
take D141 = D140;
thus L530: S5[ C355 , D141 ] by L529;
end;
consider C358 being (FinSequence of D138) such that L531: ( dom C358 ) = ( Seg ( len C354 ) ) and L532: (for B232 being (Element of ( NAT )) holds (B232 in ( Seg ( len C354 ) ) implies S5[ B232 , ( C358 /. B232 ) ])) from RECDEF_1:sch 17(L526);
take C358;
thus L533: ( len C358 ) = ( len C354 ) by L531 , FINSEQ_1:def 3;
let C359 being set;
assume that
L534: C359 in ( dom C354 );
reconsider D142 = C359 as (Element of ( NAT )) by L534;
L535: ( dom C354 ) = ( Seg ( len C354 ) ) by FINSEQ_1:def 3;
consider C360 , C361 being (Element of C352) such that L536: ( C358 /. D142 ) = [ C360 , C361 ] and L537: C360 in C353 and L538: ( C354 /. D142 ) = ( C360 * C361 ) by L535 , L532 , L534;
L539: (( [ C360 , C361 ] `1 ) = C360 & ( [ C360 , C361 ] `2 ) = C361);
thus L540: ( C354 . C359 ) = ( ( ( C358 /. C359 ) `1 ) * ( ( C358 /. C359 ) `2 ) ) by L539 , L534 , L536 , L538 , PARTFUN1:def 6;
thus L541: thesis by L536 , L537 , L539;
end;
theorem
L542: (for B233 , B234 being non  empty multLoopStr holds (for B235 being non  empty (Subset of B233) holds (for B236 being (RightLinearCombination of B235) holds (for B237 being non  empty (Subset of B234) holds (for B238 being (Function of (the carrier of B233) , (the carrier of B234)) holds (for B239 being (FinSequence of [: (the carrier of B233) , (the carrier of B233) :]) holds ((( B238 .: B235 ) c= B237 & B239 represents B236) implies (ex B240 being (RightLinearCombination of B237) st (( len B236 ) = ( len B240 ) & (for B241 being set holds (B241 in ( dom B240 ) implies ( B240 . B241 ) = ( ( B238 . ( ( B239 /. B241 ) `1 ) ) * ( B238 . ( ( B239 /. B241 ) `2 ) ) ))))))))))))
proof
let C362 , C363 being non  empty multLoopStr;
let C364 being non  empty (Subset of C362);
let C365 being (RightLinearCombination of C364);
let C366 being non  empty (Subset of C363);
let C367 being (Function of (the carrier of C362) , (the carrier of C363));
let C368 being (FinSequence of [: (the carrier of C362) , (the carrier of C362) :]);
assume L543: ( C367 .: C364 ) c= C366;
deffunc H3(Nat) = ( ( C367 . ( ( C368 /. $1 ) `1 ) ) * ( C367 . ( ( C368 /. $1 ) `2 ) ) );
consider C369 being (FinSequence of (the carrier of C363)) such that L544: ( len C369 ) = ( len C365 ) and L545: (for B242 being Nat holds (B242 in ( dom C369 ) implies ( C369 . B242 ) = H3(B242))) from FINSEQ_2:sch 1;
assume L546: C368 represents C365;
L547:
now
let C370 being set;
assume that
L548: C370 in ( dom C369 );
L549: ( dom C365 ) = ( dom C369 ) by L544 , FINSEQ_3:29;
L550: (( dom C367 ) = (the carrier of C362) & ( ( C368 /. C370 ) `1 ) in C364) by L549 , L546 , L548 , L523 , FUNCT_2:def 1;
L551: ( C367 . ( ( C368 /. C370 ) `1 ) ) in ( C367 .: C364 ) by L550 , FUNCT_1:def 6;
reconsider D143 = ( C367 . ( ( C368 /. C370 ) `1 ) ) as (Element of C366) by L551 , L543;
reconsider D144 = ( C367 . ( ( C368 /. C370 ) `2 ) ) as (Element of C363);
take D145 = D144;
take D146 = D143;
L552: ( C369 . C370 ) = ( C369 /. C370 ) by L548 , PARTFUN1:def 6;
thus L553: ( C369 /. C370 ) = ( D146 * D145 ) by L552 , L545 , L548;
end;
reconsider D147 = C369 as (RightLinearCombination of C366) by L547 , L322;
take D147;
thus L554: ( len C365 ) = ( len D147 ) by L544;
let C371 being set;
assume L555: C371 in ( dom D147 );
thus L556: thesis by L555 , L545;
end;
theorem
L557: (for B243 being non  empty multLoopStr holds (for B244 being non  empty (Subset of B243) holds (for B245 being (LinearCombination of B244) holds (for B246 being (Element of ( NAT )) holds ( B245 | ( Seg B246 ) ) is (LinearCombination of B244)))))
proof
let C372 being non  empty multLoopStr;
let C373 being non  empty (Subset of C372);
let C374 being (LinearCombination of C373);
let C375 being (Element of ( NAT ));
reconsider D148 = ( C374 | ( Seg C375 ) ) as (FinSequence of (the carrier of C372)) by FINSEQ_1:18;
L558:
now
let C376 being set;
assume that
L559: C376 in ( dom D148 );
L560: ( dom D148 ) c= ( dom C374 ) by RELAT_1:60;
consider C377 , C378 being (Element of C372), C379 being (Element of C373) such that L561: ( C374 /. C376 ) = ( ( C377 * C379 ) * C378 ) by L560 , L559 , L314;
take D149 = C377;
take D150 = C378;
take D151 = C379;
thus L562: ( D148 /. C376 ) = ( D148 . C376 ) by L559 , PARTFUN1:def 6
.= ( C374 . C376 ) by L559 , FUNCT_1:47
.= ( ( D149 * D151 ) * D150 ) by L559 , L560 , L561 , PARTFUN1:def 6;
end;
thus L563: thesis by L558 , L314;
end;
theorem
L564: (for B247 being non  empty multLoopStr holds (for B248 being non  empty (Subset of B247) holds (for B249 being (LeftLinearCombination of B248) holds (for B250 being (Element of ( NAT )) holds ( B249 | ( Seg B250 ) ) is (LeftLinearCombination of B248)))))
proof
let C380 being non  empty multLoopStr;
let C381 being non  empty (Subset of C380);
let C382 being (LeftLinearCombination of C381);
let C383 being (Element of ( NAT ));
reconsider D152 = ( C382 | ( Seg C383 ) ) as (FinSequence of (the carrier of C380)) by FINSEQ_1:18;
L565:
now
let C384 being set;
assume that
L566: C384 in ( dom D152 );
L567: ( dom D152 ) c= ( dom C382 ) by RELAT_1:60;
consider C385 being (Element of C380), C386 being (Element of C381) such that L568: ( C382 /. C384 ) = ( C385 * C386 ) by L567 , L566 , L317;
take D153 = C385;
take D154 = C386;
thus L569: ( D152 /. C384 ) = ( D152 . C384 ) by L566 , PARTFUN1:def 6
.= ( C382 . C384 ) by L566 , FUNCT_1:47
.= ( D153 * D154 ) by L566 , L567 , L568 , PARTFUN1:def 6;
end;
thus L570: thesis by L565 , L317;
end;
theorem
L571: (for B251 being non  empty multLoopStr holds (for B252 being non  empty (Subset of B251) holds (for B253 being (RightLinearCombination of B252) holds (for B254 being (Element of ( NAT )) holds ( B253 | ( Seg B254 ) ) is (RightLinearCombination of B252)))))
proof
let C387 being non  empty multLoopStr;
let C388 being non  empty (Subset of C387);
let C389 being (RightLinearCombination of C388);
let C390 being (Element of ( NAT ));
reconsider D155 = ( C389 | ( Seg C390 ) ) as (FinSequence of (the carrier of C387)) by FINSEQ_1:18;
L572:
now
let C391 being set;
assume that
L573: C391 in ( dom D155 );
L574: ( dom D155 ) c= ( dom C389 ) by RELAT_1:60;
consider C392 being (Element of C387), C393 being (Element of C388) such that L575: ( C389 /. C391 ) = ( C393 * C392 ) by L574 , L573 , L322;
take D156 = C392;
take D157 = C393;
thus L576: ( D155 /. C391 ) = ( D155 . C391 ) by L573 , PARTFUN1:def 6
.= ( C389 . C391 ) by L573 , FUNCT_1:47
.= ( D157 * D156 ) by L573 , L574 , L575 , PARTFUN1:def 6;
end;
thus L577: thesis by L572 , L322;
end;
begin
definition
let C394 being non  empty doubleLoopStr;
let C395 being (Subset of C394);
assume L578: C395 is non  empty;
func C395 -Ideal -> (Ideal of C394) means 
:L579: (C395 c= it & (for B255 being (Ideal of C394) holds (C395 c= B255 implies it c= B255)));
existence
proof
set D158 = { B256 where B256 is (Subset of C394) : (C395 c= B256 & B256 is (Ideal of C394)) };
set D159 = ( meet D158 );
L580: (the carrier of C394) is (Ideal of C394) by L73;
L581: (the carrier of C394) in D158 by L580;
L582:
now
let C396 being set;
assume L583: C396 in D158;
L584: (ex B257 being (Subset of C394) st (B257 = C396 & C395 c= B257 & B257 is (Ideal of C394))) by L583;
thus L585: C395 c= C396 by L584;
end;
L586: C395 c= D159 by L582 , L581 , SETFAM_1:5;
reconsider D160 = D159 as non  empty (Subset of C394) by L586 , L578 , L581 , SETFAM_1:3;
L587: D160 is  add-closed
proof
let C397 , C398 being (Element of C394);
assume L588: (C397 in D160 & C398 in D160);
L589:
now
let C399 being set;
assume L590: C399 in D158;
consider C400 being (Subset of C394) such that L591: C400 = C399 and L592: C395 c= C400 and L593: C400 is (Ideal of C394) by L590;
L594: (C397 in C399 & C398 in C399) by L588 , L590 , SETFAM_1:def 1;
L595: ( C397 + C398 ) in C400 by L594 , L591 , L593 , L9;
thus L596: { ( C397 + C398 ) } c= C399 by L595 , L591 , ZFMISC_1:31;
end;
L597: { ( C397 + C398 ) } c= D160 by L589 , L581 , SETFAM_1:5;
thus L598: thesis by L597 , ZFMISC_1:31;
end;
L599: D160 is  left-ideal
proof
let C401 , C402 being (Element of C394);
assume L600: C402 in D160;
L601:
now
let C403 being set;
assume L602: C403 in D158;
consider C404 being (Subset of C394) such that L603: C404 = C403 and L604: C395 c= C404 and L605: C404 is (Ideal of C394) by L602;
L606: C402 in C403 by L600 , L602 , SETFAM_1:def 1;
L607: ( C401 * C402 ) in C404 by L606 , L603 , L605 , L11;
thus L608: { ( C401 * C402 ) } c= C403 by L607 , L603 , ZFMISC_1:31;
end;
L609: { ( C401 * C402 ) } c= D160 by L601 , L581 , SETFAM_1:5;
thus L610: thesis by L609 , ZFMISC_1:31;
end;
L611: D160 is  right-ideal
proof
let C405 , C406 being (Element of C394);
assume L612: C406 in D160;
L613:
now
let C407 being set;
assume L614: C407 in D158;
consider C408 being (Subset of C394) such that L615: C408 = C407 and L616: C395 c= C408 and L617: C408 is (Ideal of C394) by L614;
L618: C406 in C407 by L612 , L614 , SETFAM_1:def 1;
L619: ( C406 * C405 ) in C408 by L618 , L615 , L617 , L12;
thus L620: { ( C406 * C405 ) } c= C407 by L619 , L615 , ZFMISC_1:31;
end;
L621: { ( C406 * C405 ) } c= D160 by L613 , L581 , SETFAM_1:5;
thus L622: thesis by L621 , ZFMISC_1:31;
end;
reconsider D161 = D160 as (Ideal of C394) by L611 , L587 , L599;
take D161;
L623:
now
let C409 being (Ideal of C394);
assume L624: C395 c= C409;
L625: C409 in D158 by L624;
thus L626: D161 c= C409 by L625 , SETFAM_1:3;
end;
thus L627: thesis by L623 , L581 , L582 , SETFAM_1:5;
end;
uniqueness
proof
let C410 , C411 being (Ideal of C394);
assume L628: (C395 c= C410 & (for B258 being (Ideal of C394) holds (C395 c= B258 implies C410 c= B258)) & C395 c= C411 & (for B259 being (Ideal of C394) holds (C395 c= B259 implies C411 c= B259)));
L629: (C410 c= C411 & C411 c= C410) by L628;
thus L630: thesis by L629 , XBOOLE_0:def 10;
end;
func C395 -LeftIdeal -> (LeftIdeal of C394) means 
:L631: (C395 c= it & (for B260 being (LeftIdeal of C394) holds (C395 c= B260 implies it c= B260)));
existence
proof
set D162 = { B261 where B261 is (Subset of C394) : (C395 c= B261 & B261 is (LeftIdeal of C394)) };
set D163 = ( meet D162 );
L632: (the carrier of C394) is (LeftIdeal of C394) by L82;
L633: (the carrier of C394) in D162 by L632;
L634:
now
let C412 being set;
assume L635: C412 in D162;
L636: (ex B262 being (Subset of C394) st (B262 = C412 & C395 c= B262 & B262 is (LeftIdeal of C394))) by L635;
thus L637: C395 c= C412 by L636;
end;
L638: C395 c= D163 by L634 , L633 , SETFAM_1:5;
reconsider D164 = D163 as non  empty (Subset of C394) by L638 , L578 , L633 , SETFAM_1:3;
L639: D164 is  add-closed
proof
let C413 , C414 being (Element of C394);
assume L640: (C413 in D164 & C414 in D164);
L641:
now
let C415 being set;
assume L642: C415 in D162;
consider C416 being (Subset of C394) such that L643: C416 = C415 and L644: C395 c= C416 and L645: C416 is (LeftIdeal of C394) by L642;
L646: (C413 in C415 & C414 in C415) by L640 , L642 , SETFAM_1:def 1;
L647: ( C413 + C414 ) in C416 by L646 , L643 , L645 , L9;
thus L648: { ( C413 + C414 ) } c= C415 by L647 , L643 , ZFMISC_1:31;
end;
L649: { ( C413 + C414 ) } c= D164 by L641 , L633 , SETFAM_1:5;
thus L650: thesis by L649 , ZFMISC_1:31;
end;
L651: D164 is  left-ideal
proof
let C417 , C418 being (Element of C394);
assume L652: C418 in D164;
L653:
now
let C419 being set;
assume L654: C419 in D162;
consider C420 being (Subset of C394) such that L655: C420 = C419 and L656: C395 c= C420 and L657: C420 is (LeftIdeal of C394) by L654;
L658: C418 in C419 by L652 , L654 , SETFAM_1:def 1;
L659: ( C417 * C418 ) in C420 by L658 , L655 , L657 , L11;
thus L660: { ( C417 * C418 ) } c= C419 by L659 , L655 , ZFMISC_1:31;
end;
L661: { ( C417 * C418 ) } c= D164 by L653 , L633 , SETFAM_1:5;
thus L662: thesis by L661 , ZFMISC_1:31;
end;
reconsider D165 = D164 as (LeftIdeal of C394) by L651 , L639;
take D165;
L663:
now
let C421 being (LeftIdeal of C394);
assume L664: C395 c= C421;
L665: C421 in D162 by L664;
thus L666: D165 c= C421 by L665 , SETFAM_1:3;
end;
thus L667: thesis by L663 , L633 , L634 , SETFAM_1:5;
end;
uniqueness
proof
let C422 , C423 being (LeftIdeal of C394);
assume L668: (C395 c= C422 & (for B263 being (LeftIdeal of C394) holds (C395 c= B263 implies C422 c= B263)) & C395 c= C423 & (for B264 being (LeftIdeal of C394) holds (C395 c= B264 implies C423 c= B264)));
L669: (C422 c= C423 & C423 c= C422) by L668;
thus L670: thesis by L669 , XBOOLE_0:def 10;
end;
func C395 -RightIdeal -> (RightIdeal of C394) means 
:L671: (C395 c= it & (for B265 being (RightIdeal of C394) holds (C395 c= B265 implies it c= B265)));
existence
proof
set D166 = { B266 where B266 is (Subset of C394) : (C395 c= B266 & B266 is (RightIdeal of C394)) };
set D167 = ( meet D166 );
L672: (the carrier of C394) is (RightIdeal of C394) by L89;
L673: (the carrier of C394) in D166 by L672;
L674:
now
let C424 being set;
assume L675: C424 in D166;
L676: (ex B267 being (Subset of C394) st (B267 = C424 & C395 c= B267 & B267 is (RightIdeal of C394))) by L675;
thus L677: C395 c= C424 by L676;
end;
L678: C395 c= D167 by L674 , L673 , SETFAM_1:5;
reconsider D168 = D167 as non  empty (Subset of C394) by L678 , L578 , L673 , SETFAM_1:3;
L679: D168 is  add-closed
proof
let C425 , C426 being (Element of C394);
assume L680: (C425 in D168 & C426 in D168);
L681:
now
let C427 being set;
assume L682: C427 in D166;
consider C428 being (Subset of C394) such that L683: C428 = C427 and L684: C395 c= C428 and L685: C428 is (RightIdeal of C394) by L682;
L686: (C425 in C427 & C426 in C427) by L680 , L682 , SETFAM_1:def 1;
L687: ( C425 + C426 ) in C428 by L686 , L683 , L685 , L9;
thus L688: { ( C425 + C426 ) } c= C427 by L687 , L683 , ZFMISC_1:31;
end;
L689: { ( C425 + C426 ) } c= D168 by L681 , L673 , SETFAM_1:5;
thus L690: thesis by L689 , ZFMISC_1:31;
end;
L691: D168 is  right-ideal
proof
let C429 , C430 being (Element of C394);
assume L692: C430 in D168;
L693:
now
let C431 being set;
assume L694: C431 in D166;
consider C432 being (Subset of C394) such that L695: C432 = C431 and L696: C395 c= C432 and L697: C432 is (RightIdeal of C394) by L694;
L698: C430 in C431 by L692 , L694 , SETFAM_1:def 1;
L699: ( C430 * C429 ) in C432 by L698 , L695 , L697 , L12;
thus L700: { ( C430 * C429 ) } c= C431 by L699 , L695 , ZFMISC_1:31;
end;
L701: { ( C430 * C429 ) } c= D168 by L693 , L673 , SETFAM_1:5;
thus L702: thesis by L701 , ZFMISC_1:31;
end;
reconsider D169 = D168 as (RightIdeal of C394) by L691 , L679;
take D169;
L703:
now
let C433 being (RightIdeal of C394);
assume L704: C395 c= C433;
L705: C433 in D166 by L704;
thus L706: D169 c= C433 by L705 , SETFAM_1:3;
end;
thus L707: thesis by L703 , L673 , L674 , SETFAM_1:5;
end;
uniqueness
proof
let C434 , C435 being (RightIdeal of C394);
assume L708: (C395 c= C434 & (for B268 being (RightIdeal of C394) holds (C395 c= B268 implies C434 c= B268)) & C395 c= C435 & (for B269 being (RightIdeal of C394) holds (C395 c= B269 implies C435 c= B269)));
L709: (C434 c= C435 & C435 c= C434) by L708;
thus L710: thesis by L709 , XBOOLE_0:def 10;
end;
end;
theorem
L712: (for B270 being non  empty doubleLoopStr holds (for B271 being (Ideal of B270) holds ( B271 -Ideal ) = B271))
proof
let C436 being non  empty doubleLoopStr;
let C437 being (Ideal of C436);
L713: (C437 c= ( C437 -Ideal ) & ( C437 -Ideal ) c= C437) by L579;
thus L714: thesis by L713 , XBOOLE_0:def 10;
end;
theorem
L715: (for B272 being non  empty doubleLoopStr holds (for B273 being (LeftIdeal of B272) holds ( B273 -LeftIdeal ) = B273))
proof
let C438 being non  empty doubleLoopStr;
let C439 being (LeftIdeal of C438);
L716: (C439 c= ( C439 -LeftIdeal ) & ( C439 -LeftIdeal ) c= C439) by L631;
thus L717: thesis by L716 , XBOOLE_0:def 10;
end;
theorem
L718: (for B274 being non  empty doubleLoopStr holds (for B275 being (RightIdeal of B274) holds ( B275 -RightIdeal ) = B275))
proof
let C440 being non  empty doubleLoopStr;
let C441 being (RightIdeal of C440);
L719: (C441 c= ( C441 -RightIdeal ) & ( C441 -RightIdeal ) c= C441) by L671;
thus L720: thesis by L719 , XBOOLE_0:def 10;
end;
definition
let C442 being non  empty doubleLoopStr;
let C443 being (Ideal of C442);
mode Basis of C443
 -> non  empty (Subset of C442)
means ( it -Ideal ) = C443;
existence
proof
take C443;
thus L721: thesis by L712;
end;
end;
theorem
L723: (for B276 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds ( { ( 0. B276 ) } -Ideal ) = { ( 0. B276 ) }) by L712;
theorem
L724: (for B277 being  left_zeroed  right_zeroed  add-cancelable  distributive non  empty doubleLoopStr holds ( { ( 0. B277 ) } -Ideal ) = { ( 0. B277 ) }) by L712;
theorem
L725: (for B278 being  left_zeroed  right_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds ( { ( 0. B278 ) } -LeftIdeal ) = { ( 0. B278 ) }) by L715;
theorem
L726: (for B279 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds ( { ( 0. B279 ) } -RightIdeal ) = { ( 0. B279 ) }) by L718;
theorem
L727: (for B280 being  well-unital non  empty doubleLoopStr holds ( { ( 1. B280 ) } -Ideal ) = (the carrier of B280))
proof
let C444 being  well-unital non  empty doubleLoopStr;
L728: (the carrier of C444) c= ( { ( 1. C444 ) } -Ideal )
proof
let C445 being set;
assume L729: C445 in (the carrier of C444);
reconsider D170 = C445 as (Element of C444) by L729;
L730: (( 1. C444 ) in { ( 1. C444 ) } & { ( 1. C444 ) } c= ( { ( 1. C444 ) } -Ideal )) by L579 , TARSKI:def 1;
L731: ( D170 * ( 1. C444 ) ) in ( { ( 1. C444 ) } -Ideal ) by L730 , L11;
thus L732: thesis by L731 , VECTSP_1:def 6;
end;
thus L733: thesis by L728 , XBOOLE_0:def 10;
end;
theorem
L734: (for B281 being  right_unital non  empty doubleLoopStr holds ( { ( 1. B281 ) } -LeftIdeal ) = (the carrier of B281))
proof
let C446 being  right_unital non  empty doubleLoopStr;
L735: (the carrier of C446) c= ( { ( 1. C446 ) } -LeftIdeal )
proof
let C447 being set;
assume L736: C447 in (the carrier of C446);
reconsider D171 = C447 as (Element of C446) by L736;
L737: (( 1. C446 ) in { ( 1. C446 ) } & { ( 1. C446 ) } c= ( { ( 1. C446 ) } -LeftIdeal )) by L631 , TARSKI:def 1;
L738: ( D171 * ( 1. C446 ) ) in ( { ( 1. C446 ) } -LeftIdeal ) by L737 , L11;
thus L739: thesis by L738 , VECTSP_1:def 4;
end;
thus L740: thesis by L735 , XBOOLE_0:def 10;
end;
theorem
L741: (for B282 being  left_unital non  empty doubleLoopStr holds ( { ( 1. B282 ) } -RightIdeal ) = (the carrier of B282))
proof
let C448 being  left_unital non  empty doubleLoopStr;
L742: (the carrier of C448) c= ( { ( 1. C448 ) } -RightIdeal )
proof
let C449 being set;
assume L743: C449 in (the carrier of C448);
reconsider D172 = C449 as (Element of C448) by L743;
L744: (( 1. C448 ) in { ( 1. C448 ) } & { ( 1. C448 ) } c= ( { ( 1. C448 ) } -RightIdeal )) by L671 , TARSKI:def 1;
L745: ( ( 1. C448 ) * D172 ) in ( { ( 1. C448 ) } -RightIdeal ) by L744 , L12;
thus L746: thesis by L745 , VECTSP_1:def 8;
end;
thus L747: thesis by L742 , XBOOLE_0:def 10;
end;
theorem
L748: (for B283 being non  empty doubleLoopStr holds ( ( [#] B283 ) -Ideal ) = (the carrier of B283))
proof
let C450 being non  empty doubleLoopStr;
L749: ( [#] C450 ) c= ( ( [#] C450 ) -Ideal ) by L579;
thus L750: thesis by L749 , XBOOLE_0:def 10;
end;
theorem
L751: (for B284 being non  empty doubleLoopStr holds ( ( [#] B284 ) -LeftIdeal ) = (the carrier of B284))
proof
let C451 being non  empty doubleLoopStr;
L752: ( [#] C451 ) c= ( ( [#] C451 ) -LeftIdeal ) by L631;
thus L753: thesis by L752 , XBOOLE_0:def 10;
end;
theorem
L754: (for B285 being non  empty doubleLoopStr holds ( ( [#] B285 ) -RightIdeal ) = (the carrier of B285))
proof
let C452 being non  empty doubleLoopStr;
L755: ( [#] C452 ) c= ( ( [#] C452 ) -RightIdeal ) by L671;
thus L756: thesis by L755 , XBOOLE_0:def 10;
end;
theorem
L757: (for B286 being non  empty doubleLoopStr holds (for B287 , B288 being non  empty (Subset of B286) holds (B287 c= B288 implies ( B287 -Ideal ) c= ( B288 -Ideal ))))
proof
let C453 being non  empty doubleLoopStr;
let C454 , C455 being non  empty (Subset of C453);
assume L758: C454 c= C455;
L759: C455 c= ( C455 -Ideal ) by L579;
L760: C454 c= ( C455 -Ideal ) by L759 , L758 , XBOOLE_1:1;
thus L761: thesis by L760 , L579;
end;
theorem
L762: (for B289 being non  empty doubleLoopStr holds (for B290 , B291 being non  empty (Subset of B289) holds (B290 c= B291 implies ( B290 -LeftIdeal ) c= ( B291 -LeftIdeal ))))
proof
let C456 being non  empty doubleLoopStr;
let C457 , C458 being non  empty (Subset of C456);
assume L763: C457 c= C458;
L764: C458 c= ( C458 -LeftIdeal ) by L631;
L765: C457 c= ( C458 -LeftIdeal ) by L764 , L763 , XBOOLE_1:1;
thus L766: thesis by L765 , L631;
end;
theorem
L767: (for B292 being non  empty doubleLoopStr holds (for B293 , B294 being non  empty (Subset of B292) holds (B293 c= B294 implies ( B293 -RightIdeal ) c= ( B294 -RightIdeal ))))
proof
let C459 being non  empty doubleLoopStr;
let C460 , C461 being non  empty (Subset of C459);
assume L768: C460 c= C461;
L769: C461 c= ( C461 -RightIdeal ) by L671;
L770: C460 c= ( C461 -RightIdeal ) by L769 , L768 , XBOOLE_1:1;
thus L771: thesis by L770 , L671;
end;
theorem
L772: (for B295 being  add-associative  left_zeroed  right_zeroed  add-cancelable  associative  distributive  well-unital non  empty doubleLoopStr holds (for B296 being non  empty (Subset of B295) holds (for B297 being set holds (B297 in ( B296 -Ideal ) iff (ex B298 being (LinearCombination of B296) st B297 = ( Sum B298 ))))))
proof
let C462 being  add-associative  right_zeroed  add-cancelable  left_zeroed  associative  distributive  well-unital non  empty doubleLoopStr;
let C463 being non  empty (Subset of C462);
set D173 = { B299 where B299 is (Element of C462) : (ex B300 being (LinearCombination of C463) st ( Sum B300 ) = B299) };
L773: D173 c= (the carrier of C462)
proof
let C464 being set;
assume L774: C464 in D173;
L775: (ex B301 being (Element of C462) st (B301 = C464 & (ex B302 being (LinearCombination of C463) st ( Sum B302 ) = B301))) by L774;
thus L776: thesis by L775;
end;
let C465 being set;
L777: C463 c= D173
proof
let C466 being set;
assume L778: C466 in C463;
reconsider D174 = C466 as (Element of C462) by L778;
set D175 = <* D174 *>;
L779:
now
let C467 being set;
assume L780: C467 in ( dom D175 );
L781: ( dom D175 ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L782: C467 = 1 by L781 , L780 , TARSKI:def 1;
L783: ( D175 . C467 ) = D174 by L782 , FINSEQ_1:40
.= ( ( 1. C462 ) * D174 ) by VECTSP_1:def 8
.= ( ( ( 1. C462 ) * D174 ) * ( 1. C462 ) ) by VECTSP_1:def 4;
thus L784: (ex B303 , B304 being (Element of C462) st (ex B305 being (Element of C463) st ( D175 /. C467 ) = ( ( B303 * B305 ) * B304 ))) by L783 , L778 , L780 , PARTFUN1:def 6;
end;
reconsider D176 = D175 as (LinearCombination of C463) by L779 , L314;
L785: ( Sum D176 ) = D174 by BINOM:3;
thus L786: thesis by L785;
end;
L787: D173 c= ( C463 -Ideal )
proof
defpred S6[ Nat ] means (for B306 being (LinearCombination of C463) holds (( len B306 ) <= $1 implies ( Sum B306 ) in ( C463 -Ideal )));
let C468 being set;
assume L788: C468 in D173;
consider C469 being (Element of C462) such that L789: C469 = C468 and L790: (ex B307 being (LinearCombination of C463) st ( Sum B307 ) = C469) by L788;
consider C470 being (LinearCombination of C463) such that L791: ( Sum C470 ) = C469 by L790;
L792: (for B308 being (Element of ( NAT )) holds (S6[ B308 ] implies S6[ ( B308 + 1 ) ]))
proof
let C471 being (Element of ( NAT ));
assume L793: S6[ C471 ];
thus L794: S6[ ( C471 + 1 ) ]
proof
let C472 being (LinearCombination of C463);
assume L795: ( len C472 ) <= ( C471 + 1 );
per cases  by L795 , NAT_1:8;
suppose L796: ( len C472 ) <= C471;

thus L797: thesis by L796 , L793;
end;
suppose L798: ( len C472 ) = ( C471 + 1 );

L799: C472 is non  empty by L798;
consider C473 being (LinearCombination of C463), C474 being (Element of C462) such that L800: C472 = ( C473 ^ <* C474 *> ) and L801: <* C474 *> is (LinearCombination of C463) by L799 , L403;
L802: ( C471 + 1 ) = ( ( len C473 ) + ( len <* C474 *> ) ) by L798 , L800 , FINSEQ_1:22
.= ( ( len C473 ) + 1 ) by FINSEQ_1:39;
L803: ( Sum C473 ) in ( C463 -Ideal ) by L802 , L793;
L804: ( dom <* C474 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L805: 1 in ( dom <* C474 *> ) by L804 , TARSKI:def 1;
consider C475 , C476 being (Element of C462), C477 being (Element of C463) such that L806: ( <* C474 *> /. 1 ) = ( ( C475 * C477 ) * C476 ) by L805 , L801 , L314;
L807: C463 c= ( C463 -Ideal ) by L579;
L808: C477 in ( C463 -Ideal ) by L807 , TARSKI:def 3;
L809: ( C475 * C477 ) in ( C463 -Ideal ) by L808 , L11;
L810: ( <* C474 *> /. 1 ) = ( <* C474 *> . 1 ) by L805 , PARTFUN1:def 6;
L811: ( Sum <* C474 *> ) = C474 by BINOM:3
.= ( ( C475 * C477 ) * C476 ) by L806 , L810 , FINSEQ_1:40;
L812: ( Sum <* C474 *> ) in ( C463 -Ideal ) by L811 , L809 , L12;
L813: ( Sum C472 ) = ( ( Sum C473 ) + ( Sum <* C474 *> ) ) by L800 , RLVECT_1:41;
thus L814: thesis by L813 , L803 , L812 , L9;
end;
end;

end;
L795: S6[ ( 0 ) ]
proof
set D177 = the (Element of C463);
let C478 being (LinearCombination of C463);
assume L796: ( len C478 ) <= ( 0 );
L797: C478 = ( <*> (the carrier of C462) ) by L796;
L798: ( Sum C478 ) = ( 0. C462 ) by L797 , RLVECT_1:43;
L799: C463 c= ( C463 -Ideal ) by L579;
L800: D177 in ( C463 -Ideal ) by L799 , TARSKI:def 3;
L801: ( ( 0. C462 ) * D177 ) = ( 0. C462 ) by BINOM:1;
thus L802: thesis by L801 , L798 , L800 , L11;
end;
L803: (for B309 being (Element of ( NAT )) holds S6[ B309 ]) from NAT_1:sch 1(L795 , L792);
L804: S6[ ( len C470 ) ] by L803;
thus L805: thesis by L804 , L789 , L791;
end;
reconsider D178 = D173 as non  empty (Subset of C462) by L777 , L773;
reconsider D179 = D178 as non  empty (Subset of C462);
L806: D179 is  add-closed
proof
let C479 , C480 being (Element of C462);
assume that
L807: C479 in D179
and
L808: C480 in D179;
consider C481 being (Element of C462) such that L809: C481 = C479 and L810: (ex B310 being (LinearCombination of C463) st ( Sum B310 ) = C481) by L807;
consider C482 being (LinearCombination of C463) such that L811: ( Sum C482 ) = C481 by L810;
consider C483 being (Element of C462) such that L812: C483 = C480 and L813: (ex B311 being (LinearCombination of C463) st ( Sum B311 ) = C483) by L808;
consider C484 being (LinearCombination of C463) such that L814: ( Sum C484 ) = C483 by L813;
L815: ( Sum ( C482 ^ C484 ) ) = ( C481 + C483 ) by L811 , L814 , RLVECT_1:41;
thus L816: thesis by L815 , L809 , L812;
end;
L817: D179 is  right-ideal
proof
let C485 , C486 being (Element of C462);
assume L818: C486 in D179;
consider C487 being (Element of C462) such that L819: C487 = C486 and L820: (ex B312 being (LinearCombination of C463) st ( Sum B312 ) = C487) by L818;
consider C488 being (LinearCombination of C463) such that L821: ( Sum C488 ) = C487 by L820;
reconsider D180 = ( C488 * C485 ) as (LinearCombination of C463) by L354;
L822: ( C486 * C485 ) = ( Sum D180 ) by L819 , L821 , BINOM:5;
thus L823: thesis by L822;
end;
L824: D179 is  left-ideal
proof
let C489 , C490 being (Element of C462);
assume L825: C490 in D179;
consider C491 being (Element of C462) such that L826: C491 = C490 and L827: (ex B313 being (LinearCombination of C463) st ( Sum B313 ) = C491) by L825;
consider C492 being (LinearCombination of C463) such that L828: ( Sum C492 ) = C491 by L827;
reconsider D181 = ( C489 * C492 ) as (LinearCombination of C463) by L349;
L829: ( C489 * C490 ) = ( Sum D181 ) by L826 , L828 , BINOM:4;
thus L830: thesis by L829;
end;
L831: ( C463 -Ideal ) c= D178 by L824 , L777 , L806 , L817 , L579;
L832: D178 = ( C463 -Ideal ) by L831 , L787 , XBOOLE_0:def 10;
thus L833:now
assume L834: C465 in ( C463 -Ideal );
L835: (ex B314 being (Element of C462) st (B314 = C465 & (ex B315 being (LinearCombination of C463) st ( Sum B315 ) = B314))) by L834 , L832;
thus L836: (ex B316 being (LinearCombination of C463) st C465 = ( Sum B316 )) by L835;
end;
assume L837: (ex B317 being (LinearCombination of C463) st C465 = ( Sum B317 ));
thus L838: thesis by L837 , L832;
end;
theorem
L839: (for B318 being  add-associative  left_zeroed  right_zeroed  add-cancelable  associative  distributive  well-unital non  empty doubleLoopStr holds (for B319 being non  empty (Subset of B318) holds (for B320 being set holds (B320 in ( B319 -LeftIdeal ) iff (ex B321 being (LeftLinearCombination of B319) st B320 = ( Sum B321 ))))))
proof
let C493 being  add-associative  right_zeroed  add-cancelable  left_zeroed  associative  distributive  well-unital non  empty doubleLoopStr;
let C494 being non  empty (Subset of C493);
set D182 = { B322 where B322 is (Element of C493) : (ex B323 being (LeftLinearCombination of C494) st ( Sum B323 ) = B322) };
L840: D182 c= (the carrier of C493)
proof
let C495 being set;
assume L841: C495 in D182;
L842: (ex B324 being (Element of C493) st (B324 = C495 & (ex B325 being (LeftLinearCombination of C494) st ( Sum B325 ) = B324))) by L841;
thus L843: thesis by L842;
end;
let C496 being set;
L844: C494 c= D182
proof
let C497 being set;
assume L845: C497 in C494;
reconsider D183 = C497 as (Element of C493) by L845;
set D184 = <* D183 *>;
L846:
now
let C498 being set;
assume L847: C498 in ( dom D184 );
L848: ( dom D184 ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L849: C498 = 1 by L848 , L847 , TARSKI:def 1;
L850: ( D184 . C498 ) = D183 by L849 , FINSEQ_1:40
.= ( ( 1. C493 ) * D183 ) by VECTSP_1:def 8;
thus L851: (ex B326 being (Element of C493) st (ex B327 being (Element of C494) st ( D184 /. C498 ) = ( B326 * B327 ))) by L850 , L845 , L847 , PARTFUN1:def 6;
end;
reconsider D185 = D184 as (LeftLinearCombination of C494) by L846 , L317;
L852: ( Sum D185 ) = D183 by BINOM:3;
thus L853: thesis by L852;
end;
L854: D182 c= ( C494 -LeftIdeal )
proof
defpred S7[ Nat ] means (for B328 being (LeftLinearCombination of C494) holds (( len B328 ) <= $1 implies ( Sum B328 ) in ( C494 -LeftIdeal )));
let C499 being set;
assume L855: C499 in D182;
consider C500 being (Element of C493) such that L856: C500 = C499 and L857: (ex B329 being (LeftLinearCombination of C494) st ( Sum B329 ) = C500) by L855;
consider C501 being (LeftLinearCombination of C494) such that L858: ( Sum C501 ) = C500 by L857;
L859: (for B330 being (Element of ( NAT )) holds (S7[ B330 ] implies S7[ ( B330 + 1 ) ]))
proof
let C502 being (Element of ( NAT ));
assume L860: S7[ C502 ];
thus L861: S7[ ( C502 + 1 ) ]
proof
let C503 being (LeftLinearCombination of C494);
assume L862: ( len C503 ) <= ( C502 + 1 );
per cases  by L862 , NAT_1:8;
suppose L863: ( len C503 ) <= C502;

thus L864: thesis by L863 , L860;
end;
suppose L865: ( len C503 ) = ( C502 + 1 );

L866: C503 is non  empty by L865;
consider C504 being (LeftLinearCombination of C494), C505 being (Element of C493) such that L867: C503 = ( C504 ^ <* C505 *> ) and L868: <* C505 *> is (LeftLinearCombination of C494) by L866 , L420;
L869: ( C502 + 1 ) = ( ( len C504 ) + ( len <* C505 *> ) ) by L865 , L867 , FINSEQ_1:22
.= ( ( len C504 ) + 1 ) by FINSEQ_1:39;
L870: ( Sum C504 ) in ( C494 -LeftIdeal ) by L869 , L860;
L871: ( dom <* C505 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L872: 1 in ( dom <* C505 *> ) by L871 , TARSKI:def 1;
consider C506 being (Element of C493), C507 being (Element of C494) such that L873: ( <* C505 *> /. 1 ) = ( C506 * C507 ) by L872 , L868 , L317;
L874: C494 c= ( C494 -LeftIdeal ) by L631;
L875: C507 in ( C494 -LeftIdeal ) by L874 , TARSKI:def 3;
L876: ( <* C505 *> /. 1 ) = ( <* C505 *> . 1 ) by L872 , PARTFUN1:def 6;
L877: ( Sum <* C505 *> ) = C505 by BINOM:3
.= ( C506 * C507 ) by L873 , L876 , FINSEQ_1:40;
L878: ( Sum <* C505 *> ) in ( C494 -LeftIdeal ) by L877 , L875 , L11;
L879: ( Sum C503 ) = ( ( Sum C504 ) + ( Sum <* C505 *> ) ) by L867 , RLVECT_1:41;
thus L880: thesis by L879 , L870 , L878 , L9;
end;
end;

end;
L862: S7[ ( 0 ) ]
proof
set D186 = the (Element of C494);
let C508 being (LeftLinearCombination of C494);
assume L863: ( len C508 ) <= ( 0 );
L864: C508 = ( <*> (the carrier of C493) ) by L863;
L865: ( Sum C508 ) = ( 0. C493 ) by L864 , RLVECT_1:43;
L866: C494 c= ( C494 -LeftIdeal ) by L631;
L867: D186 in ( C494 -LeftIdeal ) by L866 , TARSKI:def 3;
L868: ( ( 0. C493 ) * D186 ) = ( 0. C493 ) by BINOM:1;
thus L869: thesis by L868 , L865 , L867 , L11;
end;
L870: (for B331 being (Element of ( NAT )) holds S7[ B331 ]) from NAT_1:sch 1(L862 , L859);
L871: S7[ ( len C501 ) ] by L870;
thus L872: thesis by L871 , L856 , L858;
end;
reconsider D187 = D182 as non  empty (Subset of C493) by L844 , L840;
reconsider D188 = D187 as non  empty (Subset of C493);
L873: D188 is  add-closed
proof
let C509 , C510 being (Element of C493);
assume that
L874: C509 in D188
and
L875: C510 in D188;
consider C511 being (Element of C493) such that L876: C511 = C509 and L877: (ex B332 being (LeftLinearCombination of C494) st ( Sum B332 ) = C511) by L874;
consider C512 being (LeftLinearCombination of C494) such that L878: ( Sum C512 ) = C511 by L877;
consider C513 being (Element of C493) such that L879: C513 = C510 and L880: (ex B333 being (LeftLinearCombination of C494) st ( Sum B333 ) = C513) by L875;
consider C514 being (LeftLinearCombination of C494) such that L881: ( Sum C514 ) = C513 by L880;
L882: ( Sum ( C512 ^ C514 ) ) = ( C511 + C513 ) by L878 , L881 , RLVECT_1:41;
thus L883: thesis by L882 , L876 , L879;
end;
L884: D188 is  left-ideal
proof
let C515 , C516 being (Element of C493);
assume L885: C516 in D188;
consider C517 being (Element of C493) such that L886: C517 = C516 and L887: (ex B334 being (LeftLinearCombination of C494) st ( Sum B334 ) = C517) by L885;
consider C518 being (LeftLinearCombination of C494) such that L888: ( Sum C518 ) = C517 by L887;
reconsider D189 = ( C515 * C518 ) as (LeftLinearCombination of C494) by L366;
L889: ( C515 * C516 ) = ( Sum D189 ) by L886 , L888 , BINOM:4;
thus L890: thesis by L889;
end;
L891: ( C494 -LeftIdeal ) c= D187 by L884 , L844 , L873 , L631;
L892: D187 = ( C494 -LeftIdeal ) by L891 , L854 , XBOOLE_0:def 10;
thus L893:now
assume L894: C496 in ( C494 -LeftIdeal );
L895: (ex B335 being (Element of C493) st (B335 = C496 & (ex B336 being (LeftLinearCombination of C494) st ( Sum B336 ) = B335))) by L894 , L892;
thus L896: (ex B337 being (LeftLinearCombination of C494) st C496 = ( Sum B337 )) by L895;
end;
assume L897: (ex B338 being (LeftLinearCombination of C494) st C496 = ( Sum B338 ));
thus L898: thesis by L897 , L892;
end;
theorem
L899: (for B339 being  add-associative  left_zeroed  right_zeroed  add-cancelable  associative  distributive  well-unital non  empty doubleLoopStr holds (for B340 being non  empty (Subset of B339) holds (for B341 being set holds (B341 in ( B340 -RightIdeal ) iff (ex B342 being (RightLinearCombination of B340) st B341 = ( Sum B342 ))))))
proof
let C519 being  add-associative  left_zeroed  right_zeroed  add-cancelable  associative  distributive  well-unital non  empty doubleLoopStr;
let C520 being non  empty (Subset of C519);
set D190 = { B343 where B343 is (Element of C519) : (ex B344 being (RightLinearCombination of C520) st ( Sum B344 ) = B343) };
L900: D190 c= (the carrier of C519)
proof
let C521 being set;
assume L901: C521 in D190;
L902: (ex B345 being (Element of C519) st (B345 = C521 & (ex B346 being (RightLinearCombination of C520) st ( Sum B346 ) = B345))) by L901;
thus L903: thesis by L902;
end;
let C522 being set;
L904: C520 c= D190
proof
let C523 being set;
assume L905: C523 in C520;
reconsider D191 = C523 as (Element of C519) by L905;
set D192 = <* D191 *>;
L906:
now
let C524 being set;
assume L907: C524 in ( dom D192 );
L908: ( dom D192 ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L909: C524 = 1 by L908 , L907 , TARSKI:def 1;
L910: ( D192 . C524 ) = D191 by L909 , FINSEQ_1:40
.= ( D191 * ( 1. C519 ) ) by VECTSP_1:def 4;
thus L911: (ex B347 being (Element of C519) st (ex B348 being (Element of C520) st ( D192 /. C524 ) = ( B348 * B347 ))) by L910 , L905 , L907 , PARTFUN1:def 6;
end;
reconsider D193 = D192 as (RightLinearCombination of C520) by L906 , L322;
L912: ( Sum D193 ) = D191 by BINOM:3;
thus L913: thesis by L912;
end;
L914: D190 c= ( C520 -RightIdeal )
proof
defpred S8[ Nat ] means (for B349 being (RightLinearCombination of C520) holds (( len B349 ) <= $1 implies ( Sum B349 ) in ( C520 -RightIdeal )));
let C525 being set;
assume L915: C525 in D190;
consider C526 being (Element of C519) such that L916: C526 = C525 and L917: (ex B350 being (RightLinearCombination of C520) st ( Sum B350 ) = C526) by L915;
consider C527 being (RightLinearCombination of C520) such that L918: ( Sum C527 ) = C526 by L917;
L919: (for B351 being (Element of ( NAT )) holds (S8[ B351 ] implies S8[ ( B351 + 1 ) ]))
proof
let C528 being (Element of ( NAT ));
assume L920: S8[ C528 ];
thus L921: S8[ ( C528 + 1 ) ]
proof
let C529 being (RightLinearCombination of C520);
assume L922: ( len C529 ) <= ( C528 + 1 );
per cases  by L922 , NAT_1:8;
suppose L923: ( len C529 ) <= C528;

thus L924: thesis by L923 , L920;
end;
suppose L925: ( len C529 ) = ( C528 + 1 );

L926: C529 is non  empty by L925;
consider C530 being (RightLinearCombination of C520), C531 being (Element of C519) such that L927: C529 = ( C530 ^ <* C531 *> ) and L928: <* C531 *> is (RightLinearCombination of C520) by L926 , L437;
L929: ( C528 + 1 ) = ( ( len C530 ) + ( len <* C531 *> ) ) by L925 , L927 , FINSEQ_1:22
.= ( ( len C530 ) + 1 ) by FINSEQ_1:39;
L930: ( Sum C530 ) in ( C520 -RightIdeal ) by L929 , L920;
L931: ( dom <* C531 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L932: 1 in ( dom <* C531 *> ) by L931 , TARSKI:def 1;
consider C532 being (Element of C519), C533 being (Element of C520) such that L933: ( <* C531 *> /. 1 ) = ( C533 * C532 ) by L932 , L928 , L322;
L934: C520 c= ( C520 -RightIdeal ) by L671;
L935: C533 in ( C520 -RightIdeal ) by L934 , TARSKI:def 3;
L936: ( <* C531 *> /. 1 ) = ( <* C531 *> . 1 ) by L932 , PARTFUN1:def 6;
L937: ( Sum <* C531 *> ) = C531 by BINOM:3
.= ( C533 * C532 ) by L933 , L936 , FINSEQ_1:40;
L938: ( Sum <* C531 *> ) in ( C520 -RightIdeal ) by L937 , L935 , L12;
L939: ( Sum C529 ) = ( ( Sum C530 ) + ( Sum <* C531 *> ) ) by L927 , RLVECT_1:41;
thus L940: thesis by L939 , L930 , L938 , L9;
end;
end;

end;
L922: S8[ ( 0 ) ]
proof
set D194 = the (Element of C520);
let C534 being (RightLinearCombination of C520);
assume L923: ( len C534 ) <= ( 0 );
L924: C534 = ( <*> (the carrier of C519) ) by L923;
L925: ( Sum C534 ) = ( 0. C519 ) by L924 , RLVECT_1:43;
L926: C520 c= ( C520 -RightIdeal ) by L671;
L927: D194 in ( C520 -RightIdeal ) by L926 , TARSKI:def 3;
L928: ( D194 * ( 0. C519 ) ) = ( 0. C519 ) by BINOM:2;
thus L929: thesis by L928 , L925 , L927 , L12;
end;
L930: (for B352 being (Element of ( NAT )) holds S8[ B352 ]) from NAT_1:sch 1(L922 , L919);
L931: S8[ ( len C527 ) ] by L930;
thus L932: thesis by L931 , L916 , L918;
end;
reconsider D195 = D190 as non  empty (Subset of C519) by L904 , L900;
reconsider D196 = D195 as non  empty (Subset of C519);
L933: D196 is  add-closed
proof
let C535 , C536 being (Element of C519);
assume that
L934: C535 in D196
and
L935: C536 in D196;
consider C537 being (Element of C519) such that L936: C537 = C535 and L937: (ex B353 being (RightLinearCombination of C520) st ( Sum B353 ) = C537) by L934;
consider C538 being (RightLinearCombination of C520) such that L938: ( Sum C538 ) = C537 by L937;
consider C539 being (Element of C519) such that L939: C539 = C536 and L940: (ex B354 being (RightLinearCombination of C520) st ( Sum B354 ) = C539) by L935;
consider C540 being (RightLinearCombination of C520) such that L941: ( Sum C540 ) = C539 by L940;
L942: ( Sum ( C538 ^ C540 ) ) = ( C537 + C539 ) by L938 , L941 , RLVECT_1:41;
thus L943: thesis by L942 , L936 , L939;
end;
L944: D196 is  right-ideal
proof
let C541 , C542 being (Element of C519);
assume L945: C542 in D196;
consider C543 being (Element of C519) such that L946: C543 = C542 and L947: (ex B355 being (RightLinearCombination of C520) st ( Sum B355 ) = C543) by L945;
consider C544 being (RightLinearCombination of C520) such that L948: ( Sum C544 ) = C543 by L947;
reconsider D197 = ( C544 * C541 ) as (RightLinearCombination of C520) by L383;
L949: ( C542 * C541 ) = ( Sum D197 ) by L946 , L948 , BINOM:5;
thus L950: thesis by L949;
end;
L951: ( C520 -RightIdeal ) c= D195 by L944 , L904 , L933 , L671;
L952: D195 = ( C520 -RightIdeal ) by L951 , L914 , XBOOLE_0:def 10;
thus L953:now
assume L954: C522 in ( C520 -RightIdeal );
L955: (ex B356 being (Element of C519) st (B356 = C522 & (ex B357 being (RightLinearCombination of C520) st ( Sum B357 ) = B356))) by L954 , L952;
thus L956: (ex B358 being (RightLinearCombination of C520) st C522 = ( Sum B358 )) by L955;
end;
assume L957: (ex B359 being (RightLinearCombination of C520) st C522 = ( Sum B359 ));
thus L958: thesis by L957 , L952;
end;
theorem
L959: (for B360 being  add-associative  left_zeroed  right_zeroed  add-cancelable  well-unital  associative  commutative  distributive non  empty doubleLoopStr holds (for B361 being non  empty (Subset of B360) holds (( B361 -Ideal ) = ( B361 -LeftIdeal ) & ( B361 -Ideal ) = ( B361 -RightIdeal ))))
proof
let C545 being  add-associative  left_zeroed  right_zeroed  add-cancelable  well-unital  associative  commutative  distributive non  empty doubleLoopStr;
let C546 being non  empty (Subset of C545);
L960:
now
let C547 being set;
thus L961:now
assume L962: C547 in ( C546 -Ideal );
consider C548 being (LinearCombination of C546) such that L963: C547 = ( Sum C548 ) by L962 , L772;
L964: C548 is (LeftLinearCombination of C546) by L393;
thus L965: C547 in ( C546 -LeftIdeal ) by L964 , L963 , L839;
end;
assume L966: C547 in ( C546 -LeftIdeal );
consider C549 being (LeftLinearCombination of C546) such that L967: C547 = ( Sum C549 ) by L966 , L839;
L968: C549 is (LinearCombination of C546) by L359;
thus L969: C547 in ( C546 -Ideal ) by L968 , L967 , L772;
end;
thus L970: ( C546 -Ideal ) = ( C546 -LeftIdeal ) by L960 , TARSKI:1;
L971:
now
let C550 being set;
thus L972:now
assume L973: C550 in ( C546 -Ideal );
consider C551 being (LinearCombination of C546) such that L974: C550 = ( Sum C551 ) by L973 , L772;
L975: C551 is (RightLinearCombination of C546) by L393;
thus L976: C550 in ( C546 -RightIdeal ) by L975 , L974 , L899;
end;
assume L977: C550 in ( C546 -RightIdeal );
consider C552 being (RightLinearCombination of C546) such that L978: C550 = ( Sum C552 ) by L977 , L899;
L979: C552 is (LinearCombination of C546) by L376;
thus L980: C550 in ( C546 -Ideal ) by L979 , L978 , L772;
end;
thus L981: thesis by L971 , TARSKI:1;
end;
theorem
L982: (for B362 being  add-associative  left_zeroed  right_zeroed  add-cancelable  well-unital  associative  commutative  distributive non  empty doubleLoopStr holds (for B363 being (Element of B362) holds ( { B363 } -Ideal ) = { ( B363 * B364 ) where B364 is (Element of B362) : (not contradiction) }))
proof
let C553 being  add-associative  left_zeroed  right_zeroed  add-cancelable  well-unital  commutative  associative  distributive non  empty doubleLoopStr;
let C554 being (Element of C553);
set D198 = { C554 };
reconsider D199 = C554 as (Element of D198) by TARSKI:def 1;
set D200 = { ( Sum B365 ) where B365 is (LinearCombination of D198) : (not contradiction) };
set D201 = { ( C554 * B366 ) where B366 is (Element of C553) : (not contradiction) };
L983: (for B367 being set holds (B367 in D200 implies B367 in D201))
proof
let C555 being set;
assume L984: C555 in D200;
consider C556 being (LinearCombination of D198) such that L985: C555 = ( Sum C556 ) by L984;
consider C557 being (Function of ( NAT ) , (the carrier of C553)) such that L986: ( Sum C556 ) = ( C557 . ( len C556 ) ) and L987: ( C557 . ( 0 ) ) = ( 0. C553 ) and L988: (for B368 being (Element of ( NAT )) holds (for B369 being (Element of C553) holds ((B368 < ( len C556 ) & B369 = ( C556 . ( B368 + 1 ) )) implies ( C557 . ( B368 + 1 ) ) = ( ( C557 . B368 ) + B369 )))) by RLVECT_1:def 12;
defpred S9[ (Element of ( NAT )) ] means (ex B370 being (Element of C553) st ( C557 . $1 ) = ( C554 * B370 ));
L989:
now
let C558 being (Element of ( NAT ));
assume that
L990: ( 0 ) <= C558
and
L991: C558 < ( len C556 );
thus L992: (S9[ C558 ] implies S9[ ( C558 + 1 ) ])
proof
assume L993: (ex B371 being (Element of C553) st ( C557 . C558 ) = ( C554 * B371 ));
consider C559 being (Element of C553) such that L994: ( C557 . C558 ) = ( C554 * C559 ) by L993;
L995: (( ( 0 ) + 1 ) <= ( C558 + 1 ) & ( C558 + 1 ) <= ( len C556 )) by L991 , NAT_1:13;
L996: ( C558 + 1 ) in ( Seg ( len C556 ) ) by L995 , FINSEQ_1:1;
L997: ( C558 + 1 ) in ( dom C556 ) by L996 , FINSEQ_1:def 3;
consider C560 , C561 being (Element of C553), C562 being (Element of D198) such that L998: ( C556 /. ( C558 + 1 ) ) = ( ( C560 * C562 ) * C561 ) by L997 , L314;
L999: ( C556 . ( C558 + 1 ) ) = ( C556 /. ( C558 + 1 ) ) by L997 , PARTFUN1:def 6;
L1000: ( C557 . ( C558 + 1 ) ) = ( ( C557 . C558 ) + ( C556 /. ( C558 + 1 ) ) ) by L999 , L988 , L991;
L1001: ( C557 . ( C558 + 1 ) ) = ( ( C554 * C559 ) + ( ( C560 * C554 ) * C561 ) ) by L1000 , L994 , L998 , TARSKI:def 1
.= ( ( C554 * C559 ) + ( C554 * ( C560 * C561 ) ) ) by GROUP_1:def 3
.= ( C554 * ( C559 + ( C560 * C561 ) ) ) by VECTSP_1:def 7;
thus L1002: thesis by L1001;
end;

end;
L993: ( C557 . ( 0 ) ) = ( C554 * ( 0. C553 ) ) by L987 , BINOM:2;
L994: S9[ ( 0 ) ] by L993;
L995: (for B372 being (Element of ( NAT )) holds ((( 0 ) <= B372 & B372 <= ( len C556 )) implies S9[ B372 ])) from INT_1:sch 7(L994 , L989);
L996: (ex B373 being (Element of C553) st ( Sum C556 ) = ( C554 * B373 )) by L995 , L986;
thus L997: thesis by L996 , L985;
end;
L998:
now
let C563 being set;
thus L999:now
assume L1000: C563 in ( { C554 } -Ideal );
L1001: C563 in ( { C554 } -RightIdeal ) by L1000 , L959;
consider C564 being (RightLinearCombination of D198) such that L1002: C563 = ( Sum C564 ) by L1001 , L899;
L1003: C564 is (LinearCombination of D198) by L376;
thus L1004: C563 in D200 by L1003 , L1002;
end;
assume L1005: C563 in D200;
L1006: (ex B374 being (LinearCombination of D198) st C563 = ( Sum B374 )) by L1005;
thus L1007: C563 in ( { C554 } -Ideal ) by L1006 , L772;
end;
L1008: (for B375 being set holds (B375 in D201 implies B375 in D200))
proof
let C565 being set;
assume L1009: C565 in D201;
consider C566 being (Element of C553) such that L1010: C565 = ( C554 * C566 ) by L1009;
set D202 = <* ( C554 * C566 ) *>;
L1011: (for B376 being set holds (B376 in ( dom D202 ) implies (ex B377 , B378 being (Element of C553) st (ex B379 being (Element of D198) st ( D202 /. B376 ) = ( ( B377 * B379 ) * B378 )))))
proof
let C567 being set;
L1012: ( len D202 ) = 1 by FINSEQ_1:40;
assume L1013: C567 in ( dom D202 );
L1014: C567 in { 1 } by L1013 , L1012 , FINSEQ_1:2 , FINSEQ_1:def 3;
L1015: C567 = 1 by L1014 , TARSKI:def 1;
L1016: ( D202 /. C567 ) = ( C554 * C566 ) by L1015 , FINSEQ_4:16
.= ( ( C566 * D199 ) * ( 1. C553 ) ) by VECTSP_1:def 4;
thus L1017: thesis by L1016;
end;
reconsider D203 = D202 as (LinearCombination of D198) by L1011 , L314;
L1018: ( Sum D203 ) = ( C554 * C566 ) by BINOM:3;
thus L1019: thesis by L1018 , L1010;
end;
L1020: D200 = D201 by L1008 , L983 , TARSKI:1;
thus L1021: thesis by L1020 , L998 , TARSKI:1;
end;
theorem
L1022: (for B380 being  Abelian  left_zeroed  right_zeroed  add-cancelable  well-unital  add-associative  associative  commutative  distributive non  empty doubleLoopStr holds (for B381 , B382 being (Element of B380) holds ( { B381 , B382 } -Ideal ) = { ( ( B381 * B383 ) + ( B382 * B384 ) ) where B383 , B384 is (Element of B380) : (not contradiction) }))
proof
let C568 being  Abelian  left_zeroed  right_zeroed  add-cancelable  associative  well-unital  add-associative  commutative  distributive non  empty doubleLoopStr;
let C569 , C570 being (Element of C568);
set D204 = { C569 , C570 };
reconsider D205 = C569 , D206 = C570 as (Element of D204) by TARSKI:def 2;
set D207 = { ( Sum B385 ) where B385 is (LinearCombination of D204) : (not contradiction) };
set D208 = { ( ( C569 * B386 ) + ( C570 * B387 ) ) where B386 , B387 is (Element of C568) : (not contradiction) };
L1023: (for B388 being set holds (B388 in D207 implies B388 in D208))
proof
let C571 being set;
assume L1024: C571 in D207;
consider C572 being (LinearCombination of D204) such that L1025: C571 = ( Sum C572 ) by L1024;
consider C573 being (Function of ( NAT ) , (the carrier of C568)) such that L1026: ( Sum C572 ) = ( C573 . ( len C572 ) ) and L1027: ( C573 . ( 0 ) ) = ( 0. C568 ) and L1028: (for B389 being (Element of ( NAT )) holds (for B390 being (Element of C568) holds ((B389 < ( len C572 ) & B390 = ( C572 . ( B389 + 1 ) )) implies ( C573 . ( B389 + 1 ) ) = ( ( C573 . B389 ) + B390 )))) by RLVECT_1:def 12;
defpred S10[ (Element of ( NAT )) ] means (ex B391 , B392 being (Element of C568) st ( C573 . $1 ) = ( ( C569 * B391 ) + ( C570 * B392 ) ));
L1029:
now
let C574 being (Element of ( NAT ));
assume that
L1030: ( 0 ) <= C574
and
L1031: C574 < ( len C572 );
thus L1032: (S10[ C574 ] implies S10[ ( C574 + 1 ) ])
proof
L1033: (( ( 0 ) + 1 ) <= ( C574 + 1 ) & ( C574 + 1 ) <= ( len C572 )) by L1031 , NAT_1:13;
L1034: ( C574 + 1 ) in ( Seg ( len C572 ) ) by L1033 , FINSEQ_1:1;
L1035: ( C574 + 1 ) in ( dom C572 ) by L1034 , FINSEQ_1:def 3;
L1036: ( C572 /. ( C574 + 1 ) ) = ( C572 . ( C574 + 1 ) ) by L1035 , PARTFUN1:def 6;
assume L1037: (ex B393 , B394 being (Element of C568) st ( C573 . C574 ) = ( ( C569 * B393 ) + ( C570 * B394 ) ));
consider C575 , C576 being (Element of C568) such that L1038: ( C573 . C574 ) = ( ( C569 * C575 ) + ( C570 * C576 ) ) by L1037;
consider C577 , C578 being (Element of C568), C579 being (Element of D204) such that L1039: ( C572 /. ( C574 + 1 ) ) = ( ( C577 * C579 ) * C578 ) by L1035 , L314;
per cases  by TARSKI:def 2;
suppose L1040: C579 = C569;

L1041: ( C573 . ( C574 + 1 ) ) = ( ( ( C569 * C575 ) + ( C570 * C576 ) ) + ( ( C577 * C569 ) * C578 ) ) by L1040 , L1028 , L1031 , L1038 , L1039 , L1036
.= ( ( ( C569 * C575 ) + ( ( C569 * C577 ) * C578 ) ) + ( C570 * C576 ) ) by RLVECT_1:def 3
.= ( ( ( C569 * C575 ) + ( C569 * ( C577 * C578 ) ) ) + ( C570 * C576 ) ) by GROUP_1:def 3
.= ( ( C569 * ( C575 + ( C577 * C578 ) ) ) + ( C570 * C576 ) ) by VECTSP_1:def 7;
thus L1042: thesis by L1041;
end;
suppose L1043: C579 = C570;

L1044: ( C573 . ( C574 + 1 ) ) = ( ( ( C569 * C575 ) + ( C570 * C576 ) ) + ( ( C577 * C570 ) * C578 ) ) by L1043 , L1028 , L1031 , L1038 , L1039 , L1036
.= ( ( C569 * C575 ) + ( ( C570 * C576 ) + ( ( C570 * C577 ) * C578 ) ) ) by RLVECT_1:def 3
.= ( ( C569 * C575 ) + ( ( C570 * C576 ) + ( C570 * ( C577 * C578 ) ) ) ) by GROUP_1:def 3
.= ( ( C569 * C575 ) + ( C570 * ( C576 + ( C577 * C578 ) ) ) ) by VECTSP_1:def 7;
thus L1045: thesis by L1044;
end;
end;

end;
L1033: ( C573 . ( 0 ) ) = ( C569 * ( 0. C568 ) ) by L1027 , BINOM:2
.= ( ( C569 * ( 0. C568 ) ) + ( 0. C568 ) ) by RLVECT_1:def 4
.= ( ( C569 * ( 0. C568 ) ) + ( C570 * ( 0. C568 ) ) ) by BINOM:2;
L1034: S10[ ( 0 ) ] by L1033;
L1035: (for B395 being (Element of ( NAT )) holds ((( 0 ) <= B395 & B395 <= ( len C572 )) implies S10[ B395 ])) from INT_1:sch 7(L1034 , L1029);
L1036: (ex B396 , B397 being (Element of C568) st ( Sum C572 ) = ( ( C569 * B396 ) + ( C570 * B397 ) )) by L1035 , L1026;
thus L1037: thesis by L1036 , L1025;
end;
L1038:
now
let C580 being set;
thus L1039:now
assume L1040: C580 in ( { C569 , C570 } -Ideal );
L1041: C580 in ( { C569 , C570 } -RightIdeal ) by L1040 , L959;
consider C581 being (RightLinearCombination of D204) such that L1042: C580 = ( Sum C581 ) by L1041 , L899;
L1043: C581 is (LinearCombination of D204) by L376;
thus L1044: C580 in D207 by L1043 , L1042;
end;
assume L1045: C580 in D207;
L1046: (ex B398 being (LinearCombination of D204) st C580 = ( Sum B398 )) by L1045;
thus L1047: C580 in ( { C569 , C570 } -Ideal ) by L1046 , L772;
end;
L1048: (for B399 being set holds (B399 in D208 implies B399 in D207))
proof
let C582 being set;
assume L1049: C582 in D208;
consider C583 , C584 being (Element of C568) such that L1050: C582 = ( ( C569 * C583 ) + ( C570 * C584 ) ) by L1049;
set D209 = <* ( C569 * C583 ) , ( C570 * C584 ) *>;
L1051: (for B400 being set holds (B400 in ( dom D209 ) implies (ex B401 , B402 being (Element of C568) st (ex B403 being (Element of D204) st ( D209 /. B400 ) = ( ( B401 * B403 ) * B402 )))))
proof
let C585 being set;
assume L1052: C585 in ( dom D209 );
L1053: C585 in ( Seg ( len D209 ) ) by L1052 , FINSEQ_1:def 3;
L1054: C585 in { 1 , 2 } by L1053 , FINSEQ_1:2 , FINSEQ_1:44;
per cases  by L1054 , TARSKI:def 2;
suppose L1055: C585 = 1;

L1056: ( D209 /. C585 ) = ( D209 . 1 ) by L1055 , L1052 , PARTFUN1:def 6
.= ( C569 * C583 ) by FINSEQ_1:44
.= ( ( ( 1. C568 ) * D205 ) * C583 ) by VECTSP_1:def 8;
thus L1057: thesis by L1056;
end;
suppose L1058: C585 = 2;

L1059: ( D209 /. C585 ) = ( D209 . 2 ) by L1058 , L1052 , PARTFUN1:def 6
.= ( C570 * C584 ) by FINSEQ_1:44
.= ( ( ( 1. C568 ) * D206 ) * C584 ) by VECTSP_1:def 8;
thus L1060: thesis by L1059;
end;
end;
reconsider D210 = D209 as (LinearCombination of D204) by L1051 , L314;
L1062: ( Sum D210 ) = ( ( C569 * C583 ) + ( C570 * C584 ) ) by L5;
thus L1063: thesis by L1062 , L1050;
end;
L1064: D207 = D208 by L1048 , L1023 , TARSKI:1;
thus L1065: thesis by L1064 , L1038 , TARSKI:1;
end;
theorem
L1066: (for B404 being non  empty doubleLoopStr holds (for B405 being (Element of B404) holds B405 in ( { B405 } -Ideal )))
proof
let C586 being non  empty doubleLoopStr;
let C587 being (Element of C586);
L1067: (C587 in { C587 } & { C587 } c= ( { C587 } -Ideal )) by L579 , TARSKI:def 1;
thus L1068: thesis by L1067;
end;
theorem
L1069: (for B406 being  Abelian  left_zeroed  right_zeroed  right_complementable  add-associative  associative  commutative  distributive  well-unital non  empty doubleLoopStr holds (for B407 being non  empty (Subset of B406) holds (for B408 being (Element of B406) holds (B408 in ( B407 -Ideal ) implies ( { B408 } -Ideal ) c= ( B407 -Ideal )))))
proof
let C588 being  left_zeroed  right_zeroed  right_complementable  add-associative  associative  distributive  well-unital  commutative  Abelian non  empty doubleLoopStr;
let C589 being non  empty (Subset of C588);
let C590 being (Element of C588);
assume L1070: C590 in ( C589 -Ideal );
consider C591 being (LinearCombination of C589) such that L1071: C590 = ( Sum C591 ) by L1070 , L772;
L1072:
now
let C592 being set;
assume L1073: C592 in ( { C590 } -Ideal );
L1074: C592 in { ( C590 * B409 ) where B409 is (Element of C588) : (not contradiction) } by L1073 , L982;
consider C593 being (Element of C588) such that L1075: C592 = ( C590 * C593 ) by L1074;
set D211 = ( C591 * C593 );
L1076: ( dom C591 ) = ( dom D211 ) by POLYNOM1:def 2;
L1077: (for B410 being set holds (B410 in ( dom D211 ) implies (ex B411 , B412 being (Element of C588) st (ex B413 being (Element of C589) st ( D211 /. B410 ) = ( ( B411 * B413 ) * B412 )))))
proof
let C594 being set;
assume L1078: C594 in ( dom D211 );
consider C595 , C596 being (Element of C588), C597 being (Element of C589) such that L1079: ( C591 /. C594 ) = ( ( C595 * C597 ) * C596 ) by L1078 , L1076 , L314;
L1080: ( D211 /. C594 ) = ( ( ( C595 * C597 ) * C596 ) * C593 ) by L1076 , L1078 , L1079 , POLYNOM1:def 2
.= ( ( C595 * C597 ) * ( C596 * C593 ) ) by GROUP_1:def 3;
thus L1081: thesis by L1080;
end;
L1082: D211 is (LinearCombination of C589) by L1077 , L314;
L1083: ( Sum D211 ) = C592 by L1071 , L1075 , BINOM:5;
thus L1084: C592 in ( C589 -Ideal ) by L1083 , L1082 , L772;
end;
thus L1085: thesis by L1072 , TARSKI:def 3;
end;
L1086: (for B414 , B415 being set holds { B414 } c= { B414 , B415 })
proof
let C598 , C599 being set;
L1087:
now
let C600 being set;
assume L1088: C600 in { C598 };
L1089: C600 = C598 by L1088 , TARSKI:def 1;
thus L1090: C600 in { C598 , C599 } by L1089 , TARSKI:def 2;
end;
thus L1091: thesis by L1087 , TARSKI:def 3;
end;
theorem
L1092: (for B416 being non  empty doubleLoopStr holds (for B417 , B418 being (Element of B416) holds (B417 in ( { B417 , B418 } -Ideal ) & B418 in ( { B417 , B418 } -Ideal ))))
proof
let C601 being non  empty doubleLoopStr;
let C602 , C603 being (Element of C601);
L1093: (( { C602 } -Ideal ) c= ( { C602 , C603 } -Ideal ) & C602 in ( { C602 } -Ideal )) by L1086 , L757 , L1066;
thus L1094: C602 in ( { C602 , C603 } -Ideal ) by L1093;
L1095: (( { C603 } -Ideal ) c= ( { C602 , C603 } -Ideal ) & C603 in ( { C603 } -Ideal )) by L1086 , L757 , L1066;
thus L1096: thesis by L1095;
end;
theorem
L1097: (for B419 being non  empty doubleLoopStr holds (for B420 , B421 being (Element of B419) holds (( { B420 } -Ideal ) c= ( { B420 , B421 } -Ideal ) & ( { B421 } -Ideal ) c= ( { B420 , B421 } -Ideal )))) by L1086 , L757;
begin
definition
let C604 being non  empty multMagma;
let C605 being (Subset of C604);
let C606 being (Element of C604);
func C606 * C605 -> (Subset of C604) equals 
{ ( C606 * B422 ) where B422 is (Element of C604) : B422 in C605 };
coherence
proof
set D212 = { ( C606 * B423 ) where B423 is (Element of C604) : B423 in C605 };
L1098: D212 is (Subset of C604)
proof
per cases ;
suppose L1099: C605 is  empty;

L1100: D212 is  empty
proof
assume L1101: D212 is non  empty;
reconsider D213 = D212 as non  empty set by L1101;
set D214 = the (Element of D213);
L1102: D214 in { ( C606 * B424 ) where B424 is (Element of C604) : B424 in C605 };
L1103: (ex B425 being (Element of C604) st (D214 = ( C606 * B425 ) & B425 in C605)) by L1102;
thus L1104: thesis by L1103 , L1099;
end;
L1105: (for B426 being set holds (B426 in D212 implies B426 in (the carrier of C604))) by L1100;
thus L1106: thesis by L1105 , TARSKI:def 3;
end;
suppose L1107: C605 is non  empty;

reconsider D215 = C605 as non  empty set by L1107;
set D216 = the (Element of D215);
L1108: D216 in D215;
reconsider D217 = D216 as (Element of C604) by L1108;
L1109: ( C606 * D217 ) in { ( C606 * B427 ) where B427 is (Element of C604) : B427 in D215 };
reconsider D218 = D212 as non  empty set by L1109;
L1110: (for B428 being set holds (B428 in D218 implies B428 in (the carrier of C604)))
proof
let C607 being set;
assume L1111: C607 in D218;
L1112: (ex B429 being (Element of C604) st (C607 = ( C606 * B429 ) & B429 in D215)) by L1111;
thus L1113: thesis by L1112;
end;
thus L1114: thesis by L1110 , TARSKI:def 3;
end;
end;
thus L1116: thesis by L1098;
end;
end;
registration
let C608 being non  empty multLoopStr;
let C609 being non  empty (Subset of C608);
let C610 being (Element of C608);
cluster ( C610 * C609 ) -> non  empty;
coherence
proof
set D219 = the (Element of C609);
L1118: ( C610 * D219 ) in { ( C610 * B430 ) where B430 is (Element of C608) : B430 in C609 };
thus L1119: thesis by L1118;
end;
end;
registration
let C611 being  distributive non  empty doubleLoopStr;
let C612 being  add-closed (Subset of C611);
let C613 being (Element of C611);
cluster ( C613 * C612 ) ->  add-closed;
coherence
proof
set D220 = { ( C613 * B431 ) where B431 is (Element of C611) : B431 in C612 };
L1121: (for B432 , B433 being (Element of C611) holds ((B432 in D220 & B433 in D220) implies ( B432 + B433 ) in D220))
proof
let C614 , C615 being (Element of C611);
assume that
L1122: C614 in D220
and
L1123: C615 in D220;
consider C616 being (Element of C611) such that L1124: (C614 = ( C613 * C616 ) & C616 in C612) by L1122;
consider C617 being (Element of C611) such that L1125: (C615 = ( C613 * C617 ) & C617 in C612) by L1123;
reconsider D221 = ( C616 + C617 ) as (Element of C611);
L1126: (D221 in C612 & ( C614 + C615 ) = ( C613 * D221 )) by L1124 , L1125 , L9 , VECTSP_1:def 7;
thus L1127: thesis by L1126;
end;
thus L1128: thesis by L1121 , L9;
end;
end;
registration
let C618 being  associative non  empty doubleLoopStr;
let C619 being  right-ideal (Subset of C618);
let C620 being (Element of C618);
cluster ( C620 * C619 ) ->  right-ideal;
coherence
proof
set D222 = { ( C620 * B434 ) where B434 is (Element of C618) : B434 in C619 };
L1130: (for B435 , B436 being (Element of C618) holds (B436 in D222 implies ( B436 * B435 ) in D222))
proof
let C621 , C622 being (Element of C618);
assume L1131: C622 in D222;
consider C623 being (Element of C618) such that L1132: (C622 = ( C620 * C623 ) & C623 in C619) by L1131;
L1133: (( C622 * C621 ) = ( C620 * ( C623 * C621 ) ) & ( C623 * C621 ) in C619) by L1132 , L12 , GROUP_1:def 3;
thus L1134: thesis by L1133;
end;
thus L1135: thesis by L1130 , L12;
end;
end;
theorem
L1137: (for B437 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B438 being non  empty (Subset of B437) holds ( ( 0. B437 ) * B438 ) = { ( 0. B437 ) }))
proof
let C624 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C625 being non  empty (Subset of C624);
L1138:
now
set D223 = the (Element of C625);
let C626 being set;
assume L1139: C626 in { ( 0. C624 ) };
L1140: C626 = ( 0. C624 ) by L1139 , TARSKI:def 1;
L1141: ( ( 0. C624 ) * D223 ) = ( 0. C624 ) by BINOM:1;
thus L1142: C626 in ( ( 0. C624 ) * C625 ) by L1141 , L1140;
end;
L1143:
now
let C627 being set;
assume L1144: C627 in ( ( 0. C624 ) * C625 );
L1145: (ex B439 being (Element of C624) st (C627 = ( ( 0. C624 ) * B439 ) & B439 in C625)) by L1144;
L1146: C627 = ( 0. C624 ) by L1145 , BINOM:1;
thus L1147: C627 in { ( 0. C624 ) } by L1146 , TARSKI:def 1;
end;
thus L1148: thesis by L1143 , L1138 , TARSKI:1;
end;
theorem
L1149: (for B440 being  left_unital non  empty doubleLoopStr holds (for B441 being (Subset of B440) holds ( ( 1. B440 ) * B441 ) = B441))
proof
let C628 being  left_unital non  empty doubleLoopStr;
let C629 being (Subset of C628);
L1150:
now
let C630 being set;
assume L1151: C630 in C629;
reconsider D224 = C630 as (Element of C628) by L1151;
L1152: ( ( 1. C628 ) * D224 ) = D224 by VECTSP_1:def 8;
thus L1153: C630 in ( ( 1. C628 ) * C629 ) by L1152 , L1151;
end;
L1154:
now
let C631 being set;
assume L1155: C631 in ( ( 1. C628 ) * C629 );
L1156: (ex B442 being (Element of C628) st (C631 = ( ( 1. C628 ) * B442 ) & B442 in C629)) by L1155;
thus L1157: C631 in C629 by L1156 , VECTSP_1:def 8;
end;
thus L1158: thesis by L1154 , L1150 , TARSKI:1;
end;
definition
let C632 being non  empty addLoopStr;
let C633 , C634 being (Subset of C632);
func C633 + C634 -> (Subset of C632) equals 
{ ( B443 + B444 ) where B443 , B444 is (Element of C632) : (B443 in C633 & B444 in C634) };
coherence
proof
set D225 = { ( B445 + B446 ) where B445 , B446 is (Element of C632) : (B445 in C633 & B446 in C634) };
L1159: D225 is (Subset of C632)
proof
per cases ;
suppose L1160: (C633 is  empty or C634 is  empty);

L1161:
now
per cases  by L1160;
case L1162: C633 is  empty;
L1163: D225 is  empty
proof
assume L1164: D225 is non  empty;
reconsider D226 = D225 as non  empty set by L1164;
set D227 = the (Element of D226);
L1165: D227 in { ( B447 + B448 ) where B447 , B448 is (Element of C632) : (B447 in C633 & B448 in C634) };
L1166: (ex B449 , B450 being (Element of C632) st (D227 = ( B449 + B450 ) & B449 in C633 & B450 in C634)) by L1165;
thus L1167: thesis by L1166 , L1162;
end;
L1168: (for B451 being set holds (B451 in D225 implies B451 in (the carrier of C632))) by L1163;
thus L1169: thesis by L1168 , TARSKI:def 3;
end;
case L1170: C634 is  empty;
L1171: D225 is  empty
proof
assume L1172: D225 is non  empty;
reconsider D228 = D225 as non  empty set by L1172;
set D229 = the (Element of D228);
L1173: D229 in { ( B452 + B453 ) where B452 , B453 is (Element of C632) : (B452 in C633 & B453 in C634) };
L1174: (ex B454 , B455 being (Element of C632) st (D229 = ( B454 + B455 ) & B454 in C633 & B455 in C634)) by L1173;
thus L1175: thesis by L1174 , L1170;
end;
L1176: (for B456 being set holds (B456 in D225 implies B456 in (the carrier of C632))) by L1171;
thus L1177: thesis by L1176 , TARSKI:def 3;
end;
end;
thus L1179: thesis by L1161;
end;
suppose L1180: (C633 is non  empty & C634 is non  empty);

reconsider D230 = C634 as non  empty set by L1180;
reconsider D231 = C633 as non  empty set by L1180;
set D232 = the (Element of D231);
set D233 = the (Element of D230);
L1181: (D232 in D231 & D233 in D230);
reconsider D234 = D232 , D235 = D233 as (Element of C632) by L1181;
L1182: ( D234 + D235 ) in { ( B457 + B458 ) where B457 , B458 is (Element of C632) : (B457 in D231 & B458 in D230) };
reconsider D236 = D225 as non  empty set by L1182;
L1183: (for B459 being set holds (B459 in D236 implies B459 in (the carrier of C632)))
proof
let C635 being set;
assume L1184: C635 in D236;
L1185: (ex B460 , B461 being (Element of C632) st (C635 = ( B460 + B461 ) & B460 in D231 & B461 in D230)) by L1184;
thus L1186: thesis by L1185;
end;
thus L1187: thesis by L1183 , TARSKI:def 3;
end;
end;
thus L1189: thesis by L1159;
end;
end;
registration
let C636 being non  empty addLoopStr;
let C637 , C638 being non  empty (Subset of C636);
cluster ( C637 + C638 ) -> non  empty;
coherence
proof
L1191: { ( B462 + B463 ) where B462 , B463 is (Element of C636) : (B462 in C637 & B463 in C638) } is non  empty
proof
set D237 = the (Element of C638);
set D238 = the (Element of C637);
L1192: ( D238 + D237 ) in { ( B464 + B465 ) where B464 , B465 is (Element of C636) : (B464 in C637 & B465 in C638) };
thus L1193: thesis by L1192;
end;
thus L1194: thesis by L1191;
end;
end;
definition
let C639 being  Abelian non  empty addLoopStr;
let C640 , C641 being (Subset of C639);
redefine func C640 + C641;

commutativity
proof
L1196:
now
let C642 , C643 being (Subset of C639);
L1197:
now
let C644 being set;
assume L1198: C644 in ( C643 + C642 );
L1199: (ex B466 , B467 being (Element of C639) st (C644 = ( B466 + B467 ) & B466 in C643 & B467 in C642)) by L1198;
thus L1200: C644 in ( C642 + C643 ) by L1199;
end;
L1201:
now
let C645 being set;
assume L1202: C645 in ( C642 + C643 );
L1203: (ex B468 , B469 being (Element of C639) st (C645 = ( B468 + B469 ) & B468 in C642 & B469 in C643)) by L1202;
thus L1204: C645 in ( C643 + C642 ) by L1203;
end;
thus L1205: ( C642 + C643 ) = ( C643 + C642 ) by L1201 , L1197 , TARSKI:1;
end;
thus L1206: thesis by L1196;
end;
end;
registration
let C646 being  Abelian  add-associative non  empty addLoopStr;
let C647 , C648 being  add-closed (Subset of C646);
cluster ( C647 + C648 ) ->  add-closed;
coherence
proof
set D239 = { ( B470 + B471 ) where B470 , B471 is (Element of C646) : (B470 in C647 & B471 in C648) };
L1208: (for B472 , B473 being (Element of C646) holds ((B472 in D239 & B473 in D239) implies ( B472 + B473 ) in D239))
proof
let C649 , C650 being (Element of C646);
assume that
L1209: C649 in D239
and
L1210: C650 in D239;
consider C651 , C652 being (Element of C646) such that L1211: C649 = ( C651 + C652 ) and L1212: (C651 in C647 & C652 in C648) by L1209;
consider C653 , C654 being (Element of C646) such that L1213: C650 = ( C653 + C654 ) and L1214: (C653 in C647 & C654 in C648) by L1210;
L1215: ( ( C651 + C653 ) + ( C652 + C654 ) ) = ( ( ( C651 + C653 ) + C652 ) + C654 ) by RLVECT_1:def 3
.= ( ( C653 + C649 ) + C654 ) by L1211 , RLVECT_1:def 3
.= ( C649 + C650 ) by L1213 , RLVECT_1:def 3;
L1216: (( C651 + C653 ) in C647 & ( C652 + C654 ) in C648) by L1212 , L1214 , L9;
thus L1217: thesis by L1216 , L1215;
end;
thus L1218: thesis by L1208 , L9;
end;
end;
registration
let C655 being  left-distributive non  empty doubleLoopStr;
let C656 , C657 being  right-ideal (Subset of C655);
cluster ( C656 + C657 ) ->  right-ideal;
coherence
proof
set D240 = { ( B474 + B475 ) where B474 , B475 is (Element of C655) : (B474 in C656 & B475 in C657) };
L1220: (for B476 , B477 being (Element of C655) holds (B477 in D240 implies ( B477 * B476 ) in D240))
proof
let C658 , C659 being (Element of C655);
assume L1221: C659 in D240;
consider C660 , C661 being (Element of C655) such that L1222: C659 = ( C660 + C661 ) and L1223: (C660 in C656 & C661 in C657) by L1221;
L1224: ( ( C660 * C658 ) + ( C661 * C658 ) ) = ( C659 * C658 ) by L1222 , VECTSP_1:def 3;
L1225: (( C660 * C658 ) in C656 & ( C661 * C658 ) in C657) by L1223 , L12;
thus L1226: thesis by L1225 , L1224;
end;
thus L1227: thesis by L1220 , L12;
end;
end;
registration
let C662 being  right-distributive non  empty doubleLoopStr;
let C663 , C664 being  left-ideal (Subset of C662);
cluster ( C663 + C664 ) ->  left-ideal;
coherence
proof
set D241 = { ( B478 + B479 ) where B478 , B479 is (Element of C662) : (B478 in C663 & B479 in C664) };
L1229: (for B480 , B481 being (Element of C662) holds (B481 in D241 implies ( B480 * B481 ) in D241))
proof
let C665 , C666 being (Element of C662);
assume L1230: C666 in D241;
consider C667 , C668 being (Element of C662) such that L1231: C666 = ( C667 + C668 ) and L1232: (C667 in C663 & C668 in C664) by L1230;
L1233: ( ( C665 * C667 ) + ( C665 * C668 ) ) = ( C665 * C666 ) by L1231 , VECTSP_1:def 2;
L1234: (( C665 * C667 ) in C663 & ( C665 * C668 ) in C664) by L1232 , L11;
thus L1235: thesis by L1234 , L1233;
end;
thus L1236: thesis by L1229 , L11;
end;
end;
theorem
L1238: (for B482 being  add-associative non  empty addLoopStr holds (for B483 , B484 , B485 being (Subset of B482) holds ( B483 + ( B484 + B485 ) ) = ( ( B483 + B484 ) + B485 )))
proof
let C669 being  add-associative non  empty addLoopStr;
let C670 , C671 , C672 being (Subset of C669);
L1239:
now
let C673 being set;
assume L1240: C673 in ( ( C670 + C671 ) + C672 );
consider C674 , C675 being (Element of C669) such that L1241: C673 = ( C674 + C675 ) and L1242: C674 in ( C670 + C671 ) and L1243: C675 in C672 by L1240;
consider C676 , C677 being (Element of C669) such that L1244: C674 = ( C676 + C677 ) and L1245: C676 in C670 and L1246: C677 in C671 by L1242;
L1247: ( C677 + C675 ) in { ( B486 + B487 ) where B486 , B487 is (Element of C669) : (B486 in C671 & B487 in C672) } by L1243 , L1246;
L1248: ( C676 + ( C677 + C675 ) ) in { ( B488 + B489 ) where B488 , B489 is (Element of C669) : (B488 in C670 & B489 in ( C671 + C672 )) } by L1247 , L1245;
thus L1249: C673 in ( C670 + ( C671 + C672 ) ) by L1248 , L1241 , L1244 , RLVECT_1:def 3;
end;
L1250:
now
let C678 being set;
assume L1251: C678 in ( C670 + ( C671 + C672 ) );
consider C679 , C680 being (Element of C669) such that L1252: C678 = ( C679 + C680 ) and L1253: C679 in C670 and L1254: C680 in ( C671 + C672 ) by L1251;
consider C681 , C682 being (Element of C669) such that L1255: C680 = ( C681 + C682 ) and L1256: C681 in C671 and L1257: C682 in C672 by L1254;
L1258: ( C679 + C681 ) in { ( B490 + B491 ) where B490 , B491 is (Element of C669) : (B490 in C670 & B491 in C671) } by L1253 , L1256;
L1259: ( ( C679 + C681 ) + C682 ) in { ( B492 + B493 ) where B492 , B493 is (Element of C669) : (B492 in ( C670 + C671 ) & B493 in C672) } by L1258 , L1257;
thus L1260: C678 in ( ( C670 + C671 ) + C672 ) by L1259 , L1252 , L1255 , RLVECT_1:def 3;
end;
thus L1261: thesis by L1250 , L1239 , TARSKI:1;
end;
theorem
L1262: (for B494 being  left_zeroed  right_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B495 , B496 being  right-ideal non  empty (Subset of B494) holds B495 c= ( B495 + B496 )))
proof
let C683 being  left_zeroed  right_add-cancelable  right_zeroed  right-distributive non  empty doubleLoopStr;
let C684 , C685 being  right-ideal non  empty (Subset of C683);
L1263:
now
let C686 being set;
assume L1264: C686 in C684;
reconsider D242 = C686 as (Element of C684) by L1264;
L1265: ( 0. C683 ) is (Element of C685) by L49;
L1266: ( D242 + ( 0. C683 ) ) in { ( B497 + B498 ) where B497 , B498 is (Element of C683) : (B497 in C684 & B498 in C685) } by L1265;
thus L1267: C686 in ( C684 + C685 ) by L1266 , RLVECT_1:def 4;
end;
thus L1268: thesis by L1263 , TARSKI:def 3;
end;
theorem
L1269: (for B499 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B500 , B501 being  right-ideal non  empty (Subset of B499) holds B501 c= ( B500 + B501 )))
proof
let C687 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C688 , C689 being  right-ideal non  empty (Subset of C687);
L1270:
now
let C690 being set;
assume L1271: C690 in C689;
reconsider D243 = C690 as (Element of C689) by L1271;
L1272: ( 0. C687 ) is (Element of C688) by L49;
L1273: ( ( 0. C687 ) + D243 ) in { ( B502 + B503 ) where B502 , B503 is (Element of C687) : (B502 in C688 & B503 in C689) } by L1272;
thus L1274: C690 in ( C688 + C689 ) by L1273 , ALGSTR_1:def 2;
end;
thus L1275: thesis by L1270 , TARSKI:def 3;
end;
theorem
L1276: (for B504 being non  empty addLoopStr holds (for B505 , B506 being (Subset of B504) holds (for B507 being  add-closed (Subset of B504) holds ((B505 c= B507 & B506 c= B507) implies ( B505 + B506 ) c= B507))))
proof
let C691 being non  empty addLoopStr;
let C692 , C693 being (Subset of C691);
let C694 being  add-closed (Subset of C691);
assume L1277: (C692 c= C694 & C693 c= C694);
L1278:
now
let C695 being set;
assume L1279: C695 in ( C692 + C693 );
L1280: (ex B508 , B509 being (Element of C691) st (C695 = ( B508 + B509 ) & B508 in C692 & B509 in C693)) by L1279;
thus L1281: C695 in C694 by L1280 , L1277 , L9;
end;
thus L1282: thesis by L1278 , TARSKI:def 3;
end;
theorem
L1283: (for B510 being  Abelian  left_zeroed  right_zeroed  add-cancelable  well-unital  add-associative  associative  commutative  distributive non  empty doubleLoopStr holds (for B511 , B512 being (Element of B510) holds ( { B511 , B512 } -Ideal ) = ( ( { B511 } -Ideal ) + ( { B512 } -Ideal ) )))
proof
let C696 being  Abelian  left_zeroed  right_zeroed  add-cancelable  well-unital  add-associative  associative  commutative  distributive non  empty doubleLoopStr;
let C697 , C698 being (Element of C696);
L1284:
now
let C699 being set;
assume L1285: C699 in ( { C697 , C698 } -Ideal );
L1286: C699 in { ( ( C697 * B513 ) + ( C698 * B514 ) ) where B513 , B514 is (Element of C696) : (not contradiction) } by L1285 , L1022;
consider C700 , C701 being (Element of C696) such that L1287: C699 = ( ( C697 * C700 ) + ( C698 * C701 ) ) by L1286;
L1288: ( C698 * C701 ) in { ( C698 * B515 ) where B515 is (Element of C696) : (not contradiction) };
reconsider D244 = ( C698 * C701 ) as (Element of ( { C698 } -Ideal )) by L1288 , L982;
L1289: ( C697 * C700 ) in { ( C697 * B516 ) where B516 is (Element of C696) : (not contradiction) };
reconsider D245 = ( C697 * C700 ) as (Element of ( { C697 } -Ideal )) by L1289 , L982;
L1290: ( D245 + D244 ) in { ( B517 + B518 ) where B517 , B518 is (Element of C696) : (B517 in ( { C697 } -Ideal ) & B518 in ( { C698 } -Ideal )) };
thus L1291: C699 in ( ( { C697 } -Ideal ) + ( { C698 } -Ideal ) ) by L1290 , L1287;
end;
L1292:
now
let C702 being set;
assume L1293: C702 in ( ( { C697 } -Ideal ) + ( { C698 } -Ideal ) );
consider C703 , C704 being (Element of C696) such that L1294: C702 = ( C703 + C704 ) and L1295: C703 in ( { C697 } -Ideal ) and L1296: C704 in ( { C698 } -Ideal ) by L1293;
L1297: C704 in { ( C698 * B519 ) where B519 is (Element of C696) : (not contradiction) } by L1296 , L982;
L1298: (ex B520 being (Element of C696) st C704 = ( C698 * B520 )) by L1297;
L1299: C703 in { ( C697 * B521 ) where B521 is (Element of C696) : (not contradiction) } by L1295 , L982;
L1300: (ex B522 being (Element of C696) st C703 = ( C697 * B522 )) by L1299;
L1301: C702 in { ( ( C697 * B523 ) + ( C698 * B524 ) ) where B523 , B524 is (Element of C696) : (not contradiction) } by L1300 , L1294 , L1298;
thus L1302: C702 in ( { C697 , C698 } -Ideal ) by L1301 , L1022;
end;
thus L1303: thesis by L1292 , L1284 , TARSKI:1;
end;
definition
let C705 being non  empty 1-sorted;
let C706 , C707 being (Subset of C705);
redefine func C706 /\ C707 -> (Subset of C705) equals 
{ B525 where B525 is (Element of C705) : (B525 in C706 & B525 in C707) };
coherence
proof
L1304: ( C706 /\ C707 ) is (Subset of C705);
thus L1305: thesis by L1304;
end;
compatibility
proof
defpred S11[ set ] means $1 in C707;
defpred S12[ set ] means $1 in C706;
set D246 = { B526 where B526 is (Element of C705) : (S12[ B526 ] & S11[ B526 ]) };
set D247 = { B527 where B527 is (Element of C705) : S12[ B527 ] };
set D248 = { B528 where B528 is (Element of C705) : S11[ B528 ] };
L1306: D247 = C706 by DOMAIN_1:22;
L1307: D246 = ( D247 /\ D248 ) from DOMAIN_1:sch 10;
thus L1308: thesis by L1307 , L1306 , DOMAIN_1:22;
end;
end;
registration
let C708 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C709 , C710 being  left-ideal non  empty (Subset of C708);
cluster ( C709 /\ C710 ) -> non  empty;
coherence
proof
L1310: (( 0. C708 ) in C709 & ( 0. C708 ) in C710) by L46;
L1311: ( 0. C708 ) in { B529 where B529 is (Element of C708) : (B529 in C709 & B529 in C710) } by L1310;
thus L1312: thesis by L1311;
end;
end;
registration
let C711 being non  empty addLoopStr;
let C712 , C713 being  add-closed (Subset of C711);
cluster ( C712 /\ C713 ) ->  add-closed for (Subset of C711);
coherence
proof
set D249 = { B530 where B530 is (Element of C711) : (B530 in C712 & B530 in C713) };
L1314: D249 = ( C712 /\ C713 );
reconsider D250 = D249 as (Subset of C711) by L1314;
L1315: (for B531 , B532 being (Element of C711) holds ((B531 in D250 & B532 in D250) implies ( B531 + B532 ) in D250))
proof
let C714 , C715 being (Element of C711);
assume that
L1316: C714 in D250
and
L1317: C715 in D250;
consider C716 being (Element of C711) such that L1318: C716 = C715 and L1319: (C716 in C712 & C716 in C713) by L1317;
consider C717 being (Element of C711) such that L1320: C714 = C717 and L1321: (C717 in C712 & C717 in C713) by L1316;
L1322: (( C717 + C716 ) in C712 & ( C717 + C716 ) in C713) by L1321 , L1319 , L9;
thus L1323: thesis by L1322 , L1320 , L1318;
end;
thus L1324: thesis by L1315 , L9;
end;
end;
registration
let C718 being non  empty multLoopStr;
let C719 , C720 being  left-ideal (Subset of C718);
cluster ( C719 /\ C720 ) ->  left-ideal for (Subset of C718);
coherence
proof
set D251 = { B533 where B533 is (Element of C718) : (B533 in C719 & B533 in C720) };
L1326: D251 = ( C719 /\ C720 );
reconsider D252 = D251 as (Subset of C718) by L1326;
L1327: (for B534 , B535 being (Element of C718) holds (B535 in D252 implies ( B534 * B535 ) in D252))
proof
let C721 , C722 being (Element of C718);
assume L1328: C722 in D252;
consider C723 being (Element of C718) such that L1329: C722 = C723 and L1330: (C723 in C719 & C723 in C720) by L1328;
L1331: (( C721 * C723 ) in C719 & ( C721 * C723 ) in C720) by L1330 , L11;
thus L1332: thesis by L1331 , L1329;
end;
thus L1333: thesis by L1327 , L11;
end;
end;
registration
let C724 being non  empty multLoopStr;
let C725 , C726 being  right-ideal (Subset of C724);
cluster ( C725 /\ C726 ) ->  right-ideal for (Subset of C724);
coherence
proof
set D253 = { B536 where B536 is (Element of C724) : (B536 in C725 & B536 in C726) };
L1335: D253 = ( C725 /\ C726 );
reconsider D254 = D253 as (Subset of C724) by L1335;
L1336: (for B537 , B538 being (Element of C724) holds (B538 in D254 implies ( B538 * B537 ) in D254))
proof
let C727 , C728 being (Element of C724);
assume L1337: C728 in D254;
consider C729 being (Element of C724) such that L1338: C728 = C729 and L1339: (C729 in C725 & C729 in C726) by L1337;
L1340: (( C729 * C727 ) in C725 & ( C729 * C727 ) in C726) by L1339 , L12;
thus L1341: thesis by L1340 , L1338;
end;
thus L1342: thesis by L1336 , L12;
end;
end;
theorem
L1344: (for B539 being  Abelian  left_zeroed  right_zeroed  right_complementable  left_unital  add-associative  left-distributive non  empty doubleLoopStr holds (for B540 being  add-closed  left-ideal non  empty (Subset of B539) holds (for B541 being (Subset of B539) holds (for B542 being non  empty (Subset of B539) holds (B541 c= B540 implies ( B540 /\ ( B541 + B542 ) ) = ( B541 + ( B540 /\ B542 ) ))))))
proof
let C730 being  Abelian  left_zeroed  right_zeroed  right_complementable  left_unital  add-associative  left-distributive non  empty doubleLoopStr;
let C731 being  add-closed  left-ideal non  empty (Subset of C730);
let C732 being (Subset of C730);
let C733 being non  empty (Subset of C730);
assume L1345: C732 c= C731;
L1346:
now
let C734 being set;
assume L1347: C734 in ( C732 + ( C731 /\ C733 ) );
consider C735 , C736 being (Element of C730) such that L1348: C734 = ( C735 + C736 ) and L1349: C735 in C732 and L1350: C736 in ( C731 /\ C733 ) by L1347;
L1351: (ex B543 being (Element of C730) st (B543 = C736 & B543 in C731 & B543 in C733)) by L1350;
reconsider D255 = C736 as (Element of C733) by L1351;
L1352: C734 = ( C735 + D255 ) by L1348;
L1353: C734 in ( C732 + C733 ) by L1352 , L1349;
reconsider D256 = C735 as (Element of C731) by L1345 , L1349;
reconsider D257 = C736 as (Element of C731) by L1351;
L1354: C734 = ( D256 + D257 ) by L1348;
L1355: C734 in C731 by L1354 , L9;
thus L1356: C734 in ( C731 /\ ( C732 + C733 ) ) by L1355 , L1353;
end;
L1357:
now
let C737 being set;
assume L1358: C737 in ( C731 /\ ( C732 + C733 ) );
consider C738 being (Element of C730) such that L1359: C737 = C738 and L1360: C738 in C731 and L1361: C738 in ( C732 + C733 ) by L1358;
consider C739 , C740 being (Element of C730) such that L1362: C738 = ( C739 + C740 ) and L1363: C739 in C732 and L1364: C740 in C733 by L1361;
reconsider D258 = C739 as (Element of C731) by L1345 , L1363;
L1365: ( - D258 ) in C731 by L106;
L1366: ( ( D258 + C740 ) + ( - D258 ) ) in C731 by L1365 , L1360 , L1362 , L9;
L1367: ( ( D258 + ( - D258 ) ) + C740 ) in C731 by L1366 , RLVECT_1:def 3;
L1368: ( ( 0. C730 ) + C740 ) in C731 by L1367 , RLVECT_1:5;
L1369: C740 in C731 by L1368 , ALGSTR_1:def 2;
L1370: C740 in ( C731 /\ C733 ) by L1369 , L1364;
thus L1371: C737 in ( C732 + ( C731 /\ C733 ) ) by L1370 , L1359 , L1362 , L1363;
end;
thus L1372: thesis by L1357 , L1346 , TARSKI:1;
end;
definition
let C741 being non  empty doubleLoopStr;
let C742 , C743 being (Subset of C741);
func C742 *' C743 -> (Subset of C741) equals 
{ ( Sum B544 ) where B544 is (FinSequence of (the carrier of C741)) : (for B545 being (Element of ( NAT )) holds ((1 <= B545 & B545 <= ( len B544 )) implies (ex B546 , B547 being (Element of C741) st (( B544 . B545 ) = ( B546 * B547 ) & B546 in C742 & B547 in C743)))) };
coherence
proof
set D259 = { ( Sum B548 ) where B548 is (FinSequence of (the carrier of C741)) : (for B549 being (Element of ( NAT )) holds ((1 <= B549 & B549 <= ( len B548 )) implies (ex B550 , B551 being (Element of C741) st (( B548 . B549 ) = ( B550 * B551 ) & B550 in C742 & B551 in C743)))) };
L1373:
now
let C744 being set;
assume L1374: C744 in D259;
L1375: (ex B552 being (FinSequence of (the carrier of C741)) st (C744 = ( Sum B552 ) & (for B553 being (Element of ( NAT )) holds ((1 <= B553 & B553 <= ( len B552 )) implies (ex B554 , B555 being (Element of C741) st (( B552 . B553 ) = ( B554 * B555 ) & B554 in C742 & B555 in C743)))))) by L1374;
thus L1376: C744 in (the carrier of C741) by L1375;
end;
reconsider D260 = D259 as (Subset of C741) by L1373 , TARSKI:def 3;
L1377: D260 is (Subset of C741);
thus L1378: thesis by L1377;
end;
end;
registration
let C745 being non  empty doubleLoopStr;
let C746 , C747 being (Subset of C745);
cluster ( C746 *' C747 ) -> non  empty;
coherence
proof
set D261 = { ( Sum B556 ) where B556 is (FinSequence of (the carrier of C745)) : (for B557 being (Element of ( NAT )) holds ((1 <= B557 & B557 <= ( len B556 )) implies (ex B558 , B559 being (Element of C745) st (( B556 . B557 ) = ( B558 * B559 ) & B558 in C746 & B559 in C747)))) };
L1380: D261 is non  empty
proof
set D262 = ( <*> (the carrier of C745) );
L1381: (for B560 being (Element of ( NAT )) holds ((1 <= B560 & B560 <= ( len D262 )) implies (ex B561 , B562 being (Element of C745) st (( D262 . B560 ) = ( B561 * B562 ) & B561 in C746 & B562 in C747))));
L1382: ( Sum D262 ) in D261 by L1381;
thus L1383: thesis by L1382;
end;
thus L1384: thesis by L1380;
end;
end;
definition
let C748 being  commutative non  empty doubleLoopStr;
let C749 , C750 being (Subset of C748);
redefine func C749 *' C750;

commutativity
proof
L1386:
now
let C751 , C752 being (Subset of C748);
L1387:
now
let C753 being set;
assume L1388: C753 in ( C752 *' C751 );
consider C754 being (FinSequence of (the carrier of C748)) such that L1389: C753 = ( Sum C754 ) and L1390: (for B563 being (Element of ( NAT )) holds ((1 <= B563 & B563 <= ( len C754 )) implies (ex B564 , B565 being (Element of C748) st (( C754 . B563 ) = ( B564 * B565 ) & B564 in C752 & B565 in C751)))) by L1388;
L1391: (for B566 being (Element of ( NAT )) holds ((1 <= B566 & B566 <= ( len C754 )) implies (ex B567 , B568 being (Element of C748) st (( C754 . B566 ) = ( B567 * B568 ) & B567 in C751 & B568 in C752))))
proof
let C755 being (Element of ( NAT ));
assume L1392: (1 <= C755 & C755 <= ( len C754 ));
L1393: (ex B569 , B570 being (Element of C748) st (( C754 . C755 ) = ( B569 * B570 ) & B569 in C752 & B570 in C751)) by L1392 , L1390;
thus L1394: thesis by L1393;
end;
thus L1395: C753 in ( C751 *' C752 ) by L1391 , L1389;
end;
L1396:
now
let C756 being set;
assume L1397: C756 in ( C751 *' C752 );
consider C757 being (FinSequence of (the carrier of C748)) such that L1398: C756 = ( Sum C757 ) and L1399: (for B571 being (Element of ( NAT )) holds ((1 <= B571 & B571 <= ( len C757 )) implies (ex B572 , B573 being (Element of C748) st (( C757 . B571 ) = ( B572 * B573 ) & B572 in C751 & B573 in C752)))) by L1397;
L1400: (for B574 being (Element of ( NAT )) holds ((1 <= B574 & B574 <= ( len C757 )) implies (ex B575 , B576 being (Element of C748) st (( C757 . B574 ) = ( B575 * B576 ) & B575 in C752 & B576 in C751))))
proof
let C758 being (Element of ( NAT ));
assume L1401: (1 <= C758 & C758 <= ( len C757 ));
L1402: (ex B577 , B578 being (Element of C748) st (( C757 . C758 ) = ( B577 * B578 ) & B577 in C751 & B578 in C752)) by L1401 , L1399;
thus L1403: thesis by L1402;
end;
thus L1404: C756 in ( C752 *' C751 ) by L1400 , L1398;
end;
thus L1405: ( C751 *' C752 ) = ( C752 *' C751 ) by L1396 , L1387 , TARSKI:1;
end;
thus L1406: thesis by L1386;
end;
end;
registration
let C759 being  right_zeroed  add-associative non  empty doubleLoopStr;
let C760 , C761 being (Subset of C759);
cluster ( C760 *' C761 ) ->  add-closed;
coherence
proof
set D263 = { ( Sum B579 ) where B579 is (FinSequence of (the carrier of C759)) : (for B580 being (Element of ( NAT )) holds ((1 <= B580 & B580 <= ( len B579 )) implies (ex B581 , B582 being (Element of C759) st (( B579 . B580 ) = ( B581 * B582 ) & B581 in C760 & B582 in C761)))) };
L1408: D263 = ( C760 *' C761 );
reconsider D264 = D263 as non  empty (Subset of C759) by L1408;
L1409: (for B583 , B584 being (Element of C759) holds ((B583 in D264 & B584 in D264) implies ( B583 + B584 ) in D264))
proof
let C762 , C763 being (Element of C759);
assume that
L1410: C762 in D264
and
L1411: C763 in D264;
consider C764 being (FinSequence of (the carrier of C759)) such that L1412: C762 = ( Sum C764 ) and L1413: (for B585 being (Element of ( NAT )) holds ((1 <= B585 & B585 <= ( len C764 )) implies (ex B586 , B587 being (Element of C759) st (( C764 . B585 ) = ( B586 * B587 ) & B586 in C760 & B587 in C761)))) by L1410;
consider C765 being (FinSequence of (the carrier of C759)) such that L1414: C763 = ( Sum C765 ) and L1415: (for B588 being (Element of ( NAT )) holds ((1 <= B588 & B588 <= ( len C765 )) implies (ex B589 , B590 being (Element of C759) st (( C765 . B588 ) = ( B589 * B590 ) & B589 in C760 & B590 in C761)))) by L1411;
set D265 = ( C764 ^ C765 );
L1416:
now
let C766 being (Element of ( NAT ));
assume that
L1417: 1 <= C766
and
L1418: C766 <= ( len D265 );
thus L1419: (ex B591 , B592 being (Element of C759) st (( D265 . C766 ) = ( B591 * B592 ) & B591 in C760 & B592 in C761))
proof
per cases ;
suppose L1420: C766 <= ( len C764 );

L1421: C766 in ( Seg ( len C764 ) ) by L1420 , L1417 , FINSEQ_1:1;
L1422: C766 in ( dom C764 ) by L1421 , FINSEQ_1:def 3;
L1423: ( D265 . C766 ) = ( C764 . C766 ) by L1422 , FINSEQ_1:def 7;
thus L1424: thesis by L1423 , L1413 , L1417 , L1420;
end;
suppose L1425: ( len C764 ) < C766;

reconsider D266 = ( C766 - ( len C764 ) ) as (Element of ( NAT )) by L1425 , INT_1:5;
L1426: ( ( len C764 ) - ( len C764 ) ) < D266 by L1425 , XREAL_1:9;
L1427: 1 <= D266 by L1426 , NAT_1:14;
L1428: C766 <= ( ( len C764 ) + ( len C765 ) ) by L1418 , FINSEQ_1:22;
L1429: D266 <= ( ( ( len C764 ) + ( len C765 ) ) - ( len C764 ) ) by L1428 , XREAL_1:9;
L1430: ( C765 . D266 ) = ( D265 . C766 ) by L1418 , L1425 , FINSEQ_1:24;
thus L1431: thesis by L1430 , L1415 , L1427 , L1429;
end;
end;

end;
L1420: ( Sum D265 ) = ( C762 + C763 ) by L1412 , L1414 , RLVECT_1:41;
thus L1421: thesis by L1420 , L1416;
end;
thus L1422: thesis by L1409 , L9;
end;
end;
registration
let C767 being  right_zeroed  left_add-cancelable  associative  left-distributive non  empty doubleLoopStr;
let C768 , C769 being  right-ideal (Subset of C767);
cluster ( C768 *' C769 ) ->  right-ideal;
coherence
proof
set D267 = { ( Sum B593 ) where B593 is (FinSequence of (the carrier of C767)) : (for B594 being (Element of ( NAT )) holds ((1 <= B594 & B594 <= ( len B593 )) implies (ex B595 , B596 being (Element of C767) st (( B593 . B594 ) = ( B595 * B596 ) & B595 in C768 & B596 in C769)))) };
L1424: D267 = ( C768 *' C769 );
reconsider D268 = D267 as non  empty (Subset of C767) by L1424;
L1425: (for B597 , B598 being (Element of C767) holds (B598 in D268 implies ( B598 * B597 ) in D268))
proof
let C770 , C771 being (Element of C767);
assume L1426: C771 in D268;
consider C772 being (FinSequence of (the carrier of C767)) such that L1427: C771 = ( Sum C772 ) and L1428: (for B599 being (Element of ( NAT )) holds ((1 <= B599 & B599 <= ( len C772 )) implies (ex B600 , B601 being (Element of C767) st (( C772 . B599 ) = ( B600 * B601 ) & B600 in C768 & B601 in C769)))) by L1426;
set D269 = ( C772 * C770 );
L1429: ( Seg ( len D269 ) ) = ( dom D269 ) by FINSEQ_1:def 3
.= ( dom C772 ) by POLYNOM1:def 2
.= ( Seg ( len C772 ) ) by FINSEQ_1:def 3;
L1430: ( len D269 ) = ( len C772 ) by L1429 , FINSEQ_1:6;
L1431:
now
let C773 being (Element of ( NAT ));
assume L1432: (1 <= C773 & C773 <= ( len D269 ));
consider C774 , C775 being (Element of C767) such that L1433: ( C772 . C773 ) = ( C774 * C775 ) and L1434: (C774 in C768 & C775 in C769) by L1432 , L1428 , L1430;
L1435: C773 in ( Seg ( len C772 ) ) by L1429 , L1432 , FINSEQ_1:1;
L1436: C773 in ( dom C772 ) by L1435 , FINSEQ_1:def 3;
L1437: ( C772 /. C773 ) = ( C774 * C775 ) by L1436 , L1433 , PARTFUN1:def 6;
L1438: C773 in ( Seg ( len D269 ) ) by L1432 , FINSEQ_1:1;
L1439: C773 in ( dom D269 ) by L1438 , FINSEQ_1:def 3;
L1440: ( D269 . C773 ) = ( D269 /. C773 ) by L1439 , PARTFUN1:def 6
.= ( ( C774 * C775 ) * C770 ) by L1436 , L1437 , POLYNOM1:def 2
.= ( C774 * ( C775 * C770 ) ) by GROUP_1:def 3;
thus L1441: (ex B602 , B603 being (Element of C767) st (( D269 . C773 ) = ( B602 * B603 ) & B602 in C768 & B603 in C769))
proof
take C774;
take ( C775 * C770 );
thus L1442: thesis by L1434 , L1440 , L12;
end;

end;
L1442: ( Sum D269 ) = ( ( Sum C772 ) * C770 ) by BINOM:5;
thus L1443: thesis by L1442 , L1427 , L1431;
end;
thus L1444: thesis by L1425 , L12;
end;
end;
registration
let C776 being  left_zeroed  right_add-cancelable  associative  right-distributive non  empty doubleLoopStr;
let C777 , C778 being  left-ideal (Subset of C776);
cluster ( C777 *' C778 ) ->  left-ideal;
coherence
proof
set D270 = { ( Sum B604 ) where B604 is (FinSequence of (the carrier of C776)) : (for B605 being (Element of ( NAT )) holds ((1 <= B605 & B605 <= ( len B604 )) implies (ex B606 , B607 being (Element of C776) st (( B604 . B605 ) = ( B606 * B607 ) & B606 in C777 & B607 in C778)))) };
L1446: D270 = ( C777 *' C778 );
reconsider D271 = D270 as non  empty (Subset of C776) by L1446;
L1447: (for B608 , B609 being (Element of C776) holds (B609 in D271 implies ( B608 * B609 ) in D271))
proof
let C779 , C780 being (Element of C776);
assume L1448: C780 in D271;
consider C781 being (FinSequence of (the carrier of C776)) such that L1449: C780 = ( Sum C781 ) and L1450: (for B610 being (Element of ( NAT )) holds ((1 <= B610 & B610 <= ( len C781 )) implies (ex B611 , B612 being (Element of C776) st (( C781 . B610 ) = ( B611 * B612 ) & B611 in C777 & B612 in C778)))) by L1448;
set D272 = ( C779 * C781 );
L1451: ( Seg ( len D272 ) ) = ( dom D272 ) by FINSEQ_1:def 3
.= ( dom C781 ) by POLYNOM1:def 1
.= ( Seg ( len C781 ) ) by FINSEQ_1:def 3;
L1452: ( len D272 ) = ( len C781 ) by L1451 , FINSEQ_1:6;
L1453:
now
let C782 being (Element of ( NAT ));
assume L1454: (1 <= C782 & C782 <= ( len D272 ));
consider C783 , C784 being (Element of C776) such that L1455: ( C781 . C782 ) = ( C783 * C784 ) and L1456: (C783 in C777 & C784 in C778) by L1454 , L1450 , L1452;
L1457: C782 in ( Seg ( len C781 ) ) by L1451 , L1454 , FINSEQ_1:1;
L1458: C782 in ( dom C781 ) by L1457 , FINSEQ_1:def 3;
L1459: ( C781 /. C782 ) = ( C783 * C784 ) by L1458 , L1455 , PARTFUN1:def 6;
L1460: C782 in ( Seg ( len D272 ) ) by L1454 , FINSEQ_1:1;
L1461: C782 in ( dom D272 ) by L1460 , FINSEQ_1:def 3;
L1462: ( D272 . C782 ) = ( D272 /. C782 ) by L1461 , PARTFUN1:def 6
.= ( C779 * ( C783 * C784 ) ) by L1458 , L1459 , POLYNOM1:def 1
.= ( ( C779 * C783 ) * C784 ) by GROUP_1:def 3;
thus L1463: (ex B613 , B614 being (Element of C776) st (( D272 . C782 ) = ( B613 * B614 ) & B613 in C777 & B614 in C778))
proof
take ( C779 * C783 );
take C784;
thus L1464: thesis by L1456 , L1462 , L11;
end;

end;
L1464: ( Sum D272 ) = ( C779 * ( Sum C781 ) ) by BINOM:4;
thus L1465: thesis by L1464 , L1449 , L1453;
end;
thus L1466: thesis by L1447 , L11;
end;
end;
theorem
L1468: (for B615 being  left_zeroed  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B616 being non  empty (Subset of B615) holds ( { ( 0. B615 ) } *' B616 ) = { ( 0. B615 ) }))
proof
let C785 being  left_zeroed  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C786 being non  empty (Subset of C785);
L1469:
now
let C787 being set;
assume L1470: C787 in ( { ( 0. C785 ) } *' C786 );
consider C788 being (FinSequence of (the carrier of C785)) such that L1471: ( Sum C788 ) = C787 and L1472: (for B617 being (Element of ( NAT )) holds ((1 <= B617 & B617 <= ( len C788 )) implies (ex B618 , B619 being (Element of C785) st (( C788 . B617 ) = ( B618 * B619 ) & B618 in { ( 0. C785 ) } & B619 in C786)))) by L1470;
L1473:
now
per cases ;
case L1474: ( len C788 ) = ( 0 );
L1475: C788 = ( <*> (the carrier of C785) ) by L1474;
thus L1476: ( Sum C788 ) = ( 0. C785 ) by L1475 , RLVECT_1:43;
end;
case L1477: ( len C788 ) <> ( 0 );
L1478: 1 <= ( len C788 ) by L1477 , NAT_1:14;
L1479: 1 in ( Seg ( len C788 ) ) by L1478 , FINSEQ_1:1;
L1480: 1 in ( dom C788 ) by L1479 , FINSEQ_1:def 3;
L1481: (for B620 being (Element of ( NAT )) holds (B620 in ( dom C788 ) implies ( C788 /. B620 ) = ( 0. C785 )))
proof
let C789 being (Element of ( NAT ));
assume L1482: C789 in ( dom C788 );
L1483: C789 in ( Seg ( len C788 ) ) by L1482 , FINSEQ_1:def 3;
L1484: (1 <= C789 & C789 <= ( len C788 )) by L1483 , FINSEQ_1:1;
consider C790 , C791 being (Element of C785) such that L1485: ( C788 . C789 ) = ( C790 * C791 ) and L1486: C790 in { ( 0. C785 ) } and L1487: C791 in C786 by L1484 , L1472;
L1488: C790 = ( 0. C785 ) by L1486 , TARSKI:def 1;
L1489: ( C788 /. C789 ) = ( C790 * C791 ) by L1482 , L1485 , PARTFUN1:def 6;
thus L1490: thesis by L1489 , L1488 , BINOM:1;
end;
L1491: (for B621 being (Element of ( NAT )) holds ((B621 in ( dom C788 ) & B621 <> 1) implies ( C788 /. B621 ) = ( 0. C785 ))) by L1481;
thus L1492: ( Sum C788 ) = ( C788 /. 1 ) by L1491 , L1480 , POLYNOM2:3
.= ( 0. C785 ) by L1480 , L1481;
end;
end;
thus L1494: C787 in { ( 0. C785 ) } by L1473 , L1471 , TARSKI:def 1;
end;
L1495:
now
reconsider D273 = ( 0. C785 ) as (Element of { ( 0. C785 ) }) by TARSKI:def 1;
set D274 = the (Element of C786);
let C792 being set;
assume L1496: C792 in { ( 0. C785 ) };
set D275 = <* ( ( 0. C785 ) * D274 ) *>;
L1497: (( len D275 ) = 1 & ( D275 . 1 ) = ( ( 0. C785 ) * D274 )) by FINSEQ_1:40;
L1498: (for B622 being (Element of ( NAT )) holds ((1 <= B622 & B622 <= ( len D275 )) implies (ex B623 , B624 being (Element of C785) st (( D275 . B622 ) = ( B623 * B624 ) & B623 in { ( 0. C785 ) } & B624 in C786))))
proof
let C793 being (Element of ( NAT ));
assume L1499: (1 <= C793 & C793 <= ( len D275 ));
L1500: ( D275 . C793 ) = ( D273 * D274 ) by L1499 , L1497 , XXREAL_0:1;
thus L1501: thesis by L1500;
end;
L1502: ( Sum D275 ) = ( ( 0. C785 ) * D274 ) by BINOM:3
.= ( 0. C785 ) by BINOM:1
.= C792 by L1496 , TARSKI:def 1;
thus L1503: C792 in ( { ( 0. C785 ) } *' C786 ) by L1502 , L1498;
end;
thus L1504: thesis by L1495 , L1469 , TARSKI:1;
end;
theorem
L1505: (for B625 being  left_zeroed  right_zeroed  add-cancelable  distributive non  empty doubleLoopStr holds (for B626 being  add-closed  right-ideal non  empty (Subset of B625) holds (for B627 being  add-closed  left-ideal non  empty (Subset of B625) holds ( B626 *' B627 ) c= ( B626 /\ B627 ))))
proof
let C794 being  left_zeroed  right_zeroed  add-cancelable  distributive non  empty doubleLoopStr;
let C795 being  add-closed  right-ideal non  empty (Subset of C794);
let C796 being  add-closed  left-ideal non  empty (Subset of C794);
L1506:
now
let C797 being set;
assume L1507: C797 in ( C795 *' C796 );
consider C798 being (FinSequence of (the carrier of C794)) such that L1508: ( Sum C798 ) = C797 and L1509: (for B628 being (Element of ( NAT )) holds ((1 <= B628 & B628 <= ( len C798 )) implies (ex B629 , B630 being (Element of C794) st (( C798 . B628 ) = ( B629 * B630 ) & B629 in C795 & B630 in C796)))) by L1507;
consider C799 being (Function of ( NAT ) , (the carrier of C794)) such that L1510: ( Sum C798 ) = ( C799 . ( len C798 ) ) and L1511: ( C799 . ( 0 ) ) = ( 0. C794 ) and L1512: (for B631 being (Element of ( NAT )) holds (for B632 being (Element of C794) holds ((B631 < ( len C798 ) & B632 = ( C798 . ( B631 + 1 ) )) implies ( C799 . ( B631 + 1 ) ) = ( ( C799 . B631 ) + B632 )))) by RLVECT_1:def 12;
defpred S13[ (Element of ( NAT )) ] means (( C799 . $1 ) in C795 & ( C799 . $1 ) in C796);
L1513:
now
let C800 being (Element of ( NAT ));
assume that
L1514: ( 0 ) <= C800
and
L1515: C800 < ( len C798 );
thus L1516: (S13[ C800 ] implies S13[ ( C800 + 1 ) ])
proof
L1517: (( C800 + 1 ) <= ( len C798 ) & ( ( 0 ) + 1 ) <= ( C800 + 1 )) by L1515 , NAT_1:13;
L1518: ( C800 + 1 ) in ( Seg ( len C798 ) ) by L1517 , FINSEQ_1:1;
L1519: ( C800 + 1 ) in ( dom C798 ) by L1518 , FINSEQ_1:def 3;
L1520: ( C798 . ( C800 + 1 ) ) = ( C798 /. ( C800 + 1 ) ) by L1519 , PARTFUN1:def 6;
L1521: (ex B633 , B634 being (Element of C794) st (( C798 . ( C800 + 1 ) ) = ( B633 * B634 ) & B633 in C795 & B634 in C796)) by L1509 , L1517;
L1522: (( C798 /. ( C800 + 1 ) ) in C795 & ( C798 /. ( C800 + 1 ) ) in C796) by L1521 , L1520 , L11 , L12;
assume L1523: (( C799 . C800 ) in C795 & ( C799 . C800 ) in C796);
L1524: ( C799 . ( C800 + 1 ) ) = ( ( C799 . C800 ) + ( C798 /. ( C800 + 1 ) ) ) by L1512 , L1515 , L1520;
thus L1525: thesis by L1524 , L1523 , L1522 , L9;
end;

end;
L1517: S13[ ( 0 ) ] by L1511 , L46 , L49;
L1518: (for B635 being (Element of ( NAT )) holds ((( 0 ) <= B635 & B635 <= ( len C798 )) implies S13[ B635 ])) from INT_1:sch 7(L1517 , L1513);
L1519: (( Sum C798 ) in C795 & ( Sum C798 ) in C796) by L1518 , L1510;
thus L1520: C797 in ( C795 /\ C796 ) by L1519 , L1508;
end;
thus L1521: thesis by L1506 , TARSKI:def 3;
end;
theorem
L1522: (for B636 being  Abelian  left_zeroed  right_zeroed  add-cancelable  add-associative  associative  distributive non  empty doubleLoopStr holds (for B637 , B638 , B639 being  right-ideal non  empty (Subset of B636) holds ( B637 *' ( B638 + B639 ) ) = ( ( B637 *' B638 ) + ( B637 *' B639 ) )))
proof
let C801 being  Abelian  left_zeroed  right_zeroed  add-cancelable  add-associative  associative  distributive non  empty doubleLoopStr;
let C802 , C803 , C804 being  right-ideal non  empty (Subset of C801);
L1523:
now
let C805 being set;
assume L1524: C805 in ( C802 *' ( C803 + C804 ) );
consider C806 being (FinSequence of (the carrier of C801)) such that L1525: ( Sum C806 ) = C805 and L1526: (for B640 being (Element of ( NAT )) holds ((1 <= B640 & B640 <= ( len C806 )) implies (ex B641 , B642 being (Element of C801) st (( C806 . B640 ) = ( B641 * B642 ) & B641 in C802 & B642 in ( C803 + C804 ))))) by L1524;
consider C807 being (Function of ( NAT ) , (the carrier of C801)) such that L1527: ( Sum C806 ) = ( C807 . ( len C806 ) ) and L1528: ( C807 . ( 0 ) ) = ( 0. C801 ) and L1529: (for B643 being (Element of ( NAT )) holds (for B644 being (Element of C801) holds ((B643 < ( len C806 ) & B644 = ( C806 . ( B643 + 1 ) )) implies ( C807 . ( B643 + 1 ) ) = ( ( C807 . B643 ) + B644 )))) by RLVECT_1:def 12;
defpred S14[ (Element of ( NAT )) ] means (ex B645 , B646 being (Element of C801) st (( C807 . $1 ) = ( B645 + B646 ) & B645 in ( C802 *' C803 ) & B646 in ( C802 *' C804 )));
L1530:
now
let C808 being (Element of ( NAT ));
assume that
L1531: ( 0 ) <= C808
and
L1532: C808 < ( len C806 );
thus L1533: (S14[ C808 ] implies S14[ ( C808 + 1 ) ])
proof
assume L1534: (ex B647 , B648 being (Element of C801) st (( C807 . C808 ) = ( B647 + B648 ) & B647 in ( C802 *' C803 ) & B648 in ( C802 *' C804 )));
consider C809 , C810 being (Element of C801) such that L1535: ( C807 . C808 ) = ( C809 + C810 ) and L1536: C809 in ( C802 *' C803 ) and L1537: C810 in ( C802 *' C804 ) by L1534;
consider C811 being (FinSequence of (the carrier of C801)) such that L1538: ( Sum C811 ) = C810 and L1539: (for B649 being (Element of ( NAT )) holds ((1 <= B649 & B649 <= ( len C811 )) implies (ex B650 , B651 being (Element of C801) st (( C811 . B649 ) = ( B650 * B651 ) & B650 in C802 & B651 in C804)))) by L1537;
consider C812 being (FinSequence of (the carrier of C801)) such that L1540: ( Sum C812 ) = C809 and L1541: (for B652 being (Element of ( NAT )) holds ((1 <= B652 & B652 <= ( len C812 )) implies (ex B653 , B654 being (Element of C801) st (( C812 . B652 ) = ( B653 * B654 ) & B653 in C802 & B654 in C803)))) by L1536;
L1542: (( ( 0 ) + 1 ) <= ( C808 + 1 ) & ( C808 + 1 ) <= ( len C806 )) by L1532 , NAT_1:13;
consider C813 , C814 being (Element of C801) such that L1543: ( C806 . ( C808 + 1 ) ) = ( C813 * C814 ) and L1544: C813 in C802 and L1545: C814 in ( C803 + C804 ) by L1542 , L1526;
consider C815 , C816 being (Element of C801) such that L1546: C814 = ( C815 + C816 ) and L1547: C815 in C803 and L1548: C816 in C804 by L1545;
set D276 = ( C812 ^ <* ( C813 * C815 ) *> );
set D277 = ( C811 ^ <* ( C813 * C816 ) *> );
L1549: ( C808 + 1 ) in ( Seg ( len C806 ) ) by L1542 , FINSEQ_1:1;
L1550: ( C808 + 1 ) in ( dom C806 ) by L1549 , FINSEQ_1:def 3;
L1551: ( C806 . ( C808 + 1 ) ) = ( C806 /. ( C808 + 1 ) ) by L1550 , PARTFUN1:def 6;
L1552: ( len D277 ) = ( ( len C811 ) + ( len <* ( C813 * C816 ) *> ) ) by FINSEQ_1:22
.= ( ( len C811 ) + 1 ) by FINSEQ_1:40;
L1553: (for B655 being (Element of ( NAT )) holds ((1 <= B655 & B655 <= ( len D277 )) implies (ex B656 , B657 being (Element of C801) st (( D277 . B655 ) = ( B656 * B657 ) & B656 in C802 & B657 in C804))))
proof
let C817 being (Element of ( NAT ));
assume that
L1554: 1 <= C817
and
L1555: C817 <= ( len D277 );
per cases ;
suppose L1556: C817 = ( len D277 );

thus L1557: thesis by L1556 , L1544 , L1548 , L1552 , FINSEQ_1:42;
end;
suppose L1558: C817 <> ( len D277 );

L1559: C817 < ( len D277 ) by L1558 , L1555 , XXREAL_0:1;
L1560: C817 <= ( len C811 ) by L1559 , L1552 , NAT_1:13;
consider C818 , C819 being (Element of C801) such that L1561: ( C811 . C817 ) = ( C818 * C819 ) and L1562: (C818 in C802 & C819 in C804) by L1560 , L1539 , L1554;
L1563: C817 in ( Seg ( len C811 ) ) by L1554 , L1560 , FINSEQ_1:1;
L1564: C817 in ( dom C811 ) by L1563 , FINSEQ_1:def 3;
L1565: ( D277 . C817 ) = ( C818 * C819 ) by L1564 , L1561 , FINSEQ_1:def 7;
thus L1566: thesis by L1565 , L1562;
end;
end;
L1568: ( Sum D277 ) in ( C802 *' C804 ) by L1553;
L1569: ( len D276 ) = ( ( len C812 ) + ( len <* ( C813 * C815 ) *> ) ) by FINSEQ_1:22
.= ( ( len C812 ) + 1 ) by FINSEQ_1:40;
L1570: (for B658 being (Element of ( NAT )) holds ((1 <= B658 & B658 <= ( len D276 )) implies (ex B659 , B660 being (Element of C801) st (( D276 . B658 ) = ( B659 * B660 ) & B659 in C802 & B660 in C803))))
proof
let C820 being (Element of ( NAT ));
assume that
L1571: 1 <= C820
and
L1572: C820 <= ( len D276 );
per cases ;
suppose L1573: C820 = ( len D276 );

thus L1574: thesis by L1573 , L1544 , L1547 , L1569 , FINSEQ_1:42;
end;
suppose L1575: C820 <> ( len D276 );

L1576: C820 < ( len D276 ) by L1575 , L1572 , XXREAL_0:1;
L1577: C820 <= ( len C812 ) by L1576 , L1569 , NAT_1:13;
consider C821 , C822 being (Element of C801) such that L1578: ( C812 . C820 ) = ( C821 * C822 ) and L1579: (C821 in C802 & C822 in C803) by L1577 , L1541 , L1571;
L1580: C820 in ( Seg ( len C812 ) ) by L1571 , L1577 , FINSEQ_1:1;
L1581: C820 in ( dom C812 ) by L1580 , FINSEQ_1:def 3;
L1582: ( D276 . C820 ) = ( C821 * C822 ) by L1581 , L1578 , FINSEQ_1:def 7;
thus L1583: thesis by L1582 , L1579;
end;
end;
L1585: ( Sum D276 ) in { ( Sum B661 ) where B661 is (FinSequence of (the carrier of C801)) : (for B662 being (Element of ( NAT )) holds ((1 <= B662 & B662 <= ( len B661 )) implies (ex B663 , B664 being (Element of C801) st (( B661 . B662 ) = ( B663 * B664 ) & B663 in C802 & B664 in C803)))) } by L1570;
L1586: ( C806 /. ( C808 + 1 ) ) = ( C813 * ( C815 + C816 ) ) by L1550 , L1543 , L1546 , PARTFUN1:def 6
.= ( ( C813 * C815 ) + ( C813 * C816 ) ) by VECTSP_1:def 7;
L1587: ( ( Sum D276 ) + ( Sum D277 ) ) = ( ( ( Sum C812 ) + ( Sum <* ( C813 * C815 ) *> ) ) + ( Sum D277 ) ) by RLVECT_1:41
.= ( ( ( Sum C812 ) + ( C813 * C815 ) ) + ( Sum D277 ) ) by BINOM:3
.= ( ( ( Sum C812 ) + ( C813 * C815 ) ) + ( ( Sum C811 ) + ( Sum <* ( C813 * C816 ) *> ) ) ) by RLVECT_1:41
.= ( ( ( Sum C812 ) + ( C813 * C815 ) ) + ( ( Sum C811 ) + ( C813 * C816 ) ) ) by BINOM:3
.= ( ( ( ( Sum C812 ) + ( C813 * C815 ) ) + ( Sum C811 ) ) + ( C813 * C816 ) ) by RLVECT_1:def 3
.= ( ( ( C813 * C815 ) + ( ( Sum C812 ) + ( Sum C811 ) ) ) + ( C813 * C816 ) ) by RLVECT_1:def 3
.= ( ( C807 . C808 ) + ( ( C813 * C815 ) + ( C813 * C816 ) ) ) by L1535 , L1540 , L1538 , RLVECT_1:def 3
.= ( C807 . ( C808 + 1 ) ) by L1529 , L1532 , L1551 , L1586;
thus L1588: thesis by L1587 , L1585 , L1568;
end;

end;
L1534: S14[ ( 0 ) ]
proof
take ( 0. C801 );
take ( 0. C801 );
thus L1535: thesis by L1528 , L49 , RLVECT_1:def 4;
end;
L1536: (for B665 being (Element of ( NAT )) holds ((( 0 ) <= B665 & B665 <= ( len C806 )) implies S14[ B665 ])) from INT_1:sch 7(L1534 , L1530);
L1537: (ex B666 , B667 being (Element of C801) st (( Sum C806 ) = ( B666 + B667 ) & B666 in ( C802 *' C803 ) & B667 in ( C802 *' C804 ))) by L1536 , L1527;
thus L1538: C805 in ( ( C802 *' C803 ) + ( C802 *' C804 ) ) by L1537 , L1525;
end;
L1539:
now
let C823 being set;
assume L1540: C823 in ( ( C802 *' C803 ) + ( C802 *' C804 ) );
consider C824 , C825 being (Element of C801) such that L1541: C823 = ( C824 + C825 ) and L1542: C824 in ( C802 *' C803 ) and L1543: C825 in ( C802 *' C804 ) by L1540;
consider C826 being (FinSequence of (the carrier of C801)) such that L1544: C825 = ( Sum C826 ) and L1545: (for B668 being (Element of ( NAT )) holds ((1 <= B668 & B668 <= ( len C826 )) implies (ex B669 , B670 being (Element of C801) st (( C826 . B668 ) = ( B669 * B670 ) & B669 in C802 & B670 in C804)))) by L1543;
consider C827 being (FinSequence of (the carrier of C801)) such that L1546: C824 = ( Sum C827 ) and L1547: (for B671 being (Element of ( NAT )) holds ((1 <= B671 & B671 <= ( len C827 )) implies (ex B672 , B673 being (Element of C801) st (( C827 . B671 ) = ( B672 * B673 ) & B672 in C802 & B673 in C803)))) by L1542;
set D278 = ( C826 ^ C827 );
L1548: (for B674 being (Element of ( NAT )) holds ((1 <= B674 & B674 <= ( len D278 )) implies (ex B675 , B676 being (Element of C801) st (( D278 . B674 ) = ( B675 * B676 ) & B675 in C802 & B676 in ( C803 + C804 )))))
proof
let C828 being (Element of ( NAT ));
assume that
L1549: 1 <= C828
and
L1550: C828 <= ( len D278 );
L1551: C828 in ( Seg ( len D278 ) ) by L1549 , L1550 , FINSEQ_1:1;
L1552: C828 in ( dom D278 ) by L1551 , FINSEQ_1:def 3;
L1553:
now
per cases ;
case L1554: C828 <= ( len C826 );
consider C829 , C830 being (Element of C801) such that L1555: ( C826 . C828 ) = ( C829 * C830 ) and L1556: C829 in C802 and L1557: C830 in C804 by L1554 , L1545 , L1549;
L1558: C828 in ( Seg ( len C826 ) ) by L1549 , L1554 , FINSEQ_1:1;
L1559: C828 in ( dom C826 ) by L1558 , FINSEQ_1:def 3;
L1560: ( D278 . C828 ) = ( C829 * C830 ) by L1559 , L1555 , FINSEQ_1:def 7
.= ( C829 * ( ( 0. C801 ) + C830 ) ) by ALGSTR_1:def 2;
L1561: ( 0. C801 ) in C803 by L49;
L1562: ( ( 0. C801 ) + C830 ) in { ( B677 + B678 ) where B677 , B678 is (Element of C801) : (B677 in C803 & B678 in C804) } by L1561 , L1557;
thus L1563: thesis by L1562 , L1556 , L1560;
end;
case L1564: C828 > ( len C826 );
L1565: (not C828 in ( Seg ( len C826 ) )) by L1564 , FINSEQ_1:1;
L1566: (not C828 in ( dom C826 )) by L1565 , FINSEQ_1:def 3;
consider C831 being Nat such that L1567: C831 in ( dom C827 ) and L1568: C828 = ( ( len C826 ) + C831 ) by L1566 , L1552 , FINSEQ_1:25;
L1569: C831 in ( Seg ( len C827 ) ) by L1567 , FINSEQ_1:def 3;
L1570: (1 <= C831 & C831 <= ( len C827 )) by L1569 , FINSEQ_1:1;
consider C832 , C833 being (Element of C801) such that L1571: ( C827 . C831 ) = ( C832 * C833 ) and L1572: C832 in C802 and L1573: C833 in C803 by L1570 , L1547 , L1567;
L1574: ( 0. C801 ) in C804 by L49;
L1575: ( C833 + ( 0. C801 ) ) in { ( B679 + B680 ) where B679 , B680 is (Element of C801) : (B679 in C803 & B680 in C804) } by L1574 , L1573;
L1576: ( D278 . C828 ) = ( C827 . C831 ) by L1567 , L1568 , FINSEQ_1:def 7
.= ( C832 * ( C833 + ( 0. C801 ) ) ) by L1571 , RLVECT_1:def 4;
thus L1577: thesis by L1576 , L1572 , L1575;
end;
end;
thus L1579: thesis by L1553;
end;
L1580: ( Sum D278 ) = C823 by L1541 , L1546 , L1544 , RLVECT_1:41;
thus L1581: C823 in ( C802 *' ( C803 + C804 ) ) by L1580 , L1548;
end;
thus L1582: thesis by L1539 , L1523 , TARSKI:1;
end;
theorem
L1583: (for B681 being  Abelian  left_zeroed  right_zeroed  add-cancelable  add-associative  commutative  associative  distributive non  empty doubleLoopStr holds (for B682 , B683 being  right-ideal non  empty (Subset of B681) holds ( ( B682 + B683 ) *' ( B682 /\ B683 ) ) c= ( B682 *' B683 )))
proof
let C834 being  Abelian  left_zeroed  right_zeroed  add-cancelable  add-associative  commutative  associative  distributive non  empty doubleLoopStr;
let C835 , C836 being  right-ideal non  empty (Subset of C834);
L1584:
now
let C837 being set;
assume L1585: C837 in ( ( C835 *' ( C835 /\ C836 ) ) + ( C836 *' ( C835 /\ C836 ) ) );
consider C838 , C839 being (Element of C834) such that L1586: C837 = ( C838 + C839 ) and L1587: C838 in ( C835 *' ( C835 /\ C836 ) ) and L1588: C839 in ( C836 *' ( C835 /\ C836 ) ) by L1585;
consider C840 being (FinSequence of (the carrier of C834)) such that L1589: C839 = ( Sum C840 ) and L1590: (for B684 being (Element of ( NAT )) holds ((1 <= B684 & B684 <= ( len C840 )) implies (ex B685 , B686 being (Element of C834) st (( C840 . B684 ) = ( B685 * B686 ) & B685 in C836 & B686 in ( C835 /\ C836 ))))) by L1588;
L1591: (for B687 being (Element of ( NAT )) holds ((1 <= B687 & B687 <= ( len C840 )) implies (ex B688 , B689 being (Element of C834) st (( C840 . B687 ) = ( B688 * B689 ) & B688 in C835 & B689 in C836))))
proof
let C841 being (Element of ( NAT ));
assume L1592: (1 <= C841 & C841 <= ( len C840 ));
L1593: (ex B690 , B691 being (Element of C834) st (( C840 . C841 ) = ( B690 * B691 ) & B690 in C836 & B691 in ( C835 /\ C836 ))) by L1592 , L1590;
L1594: ( C835 /\ C836 ) c= C835 by XBOOLE_1:17;
thus L1595: thesis by L1594 , L1593;
end;
L1596: ( Sum C840 ) in { ( Sum B692 ) where B692 is (FinSequence of (the carrier of C834)) : (for B693 being (Element of ( NAT )) holds ((1 <= B693 & B693 <= ( len B692 )) implies (ex B694 , B695 being (Element of C834) st (( B692 . B693 ) = ( B694 * B695 ) & B694 in C835 & B695 in C836)))) } by L1591;
consider C842 being (FinSequence of (the carrier of C834)) such that L1597: C838 = ( Sum C842 ) and L1598: (for B696 being (Element of ( NAT )) holds ((1 <= B696 & B696 <= ( len C842 )) implies (ex B697 , B698 being (Element of C834) st (( C842 . B696 ) = ( B697 * B698 ) & B697 in C835 & B698 in ( C835 /\ C836 ))))) by L1587;
L1599: (for B699 being (Element of ( NAT )) holds ((1 <= B699 & B699 <= ( len C842 )) implies (ex B700 , B701 being (Element of C834) st (( C842 . B699 ) = ( B700 * B701 ) & B700 in C835 & B701 in C836))))
proof
let C843 being (Element of ( NAT ));
assume L1600: (1 <= C843 & C843 <= ( len C842 ));
L1601: (ex B702 , B703 being (Element of C834) st (( C842 . C843 ) = ( B702 * B703 ) & B702 in C835 & B703 in ( C835 /\ C836 ))) by L1600 , L1598;
L1602: ( C835 /\ C836 ) c= C836 by XBOOLE_1:17;
thus L1603: thesis by L1602 , L1601;
end;
L1604: ( Sum C842 ) in { ( Sum B704 ) where B704 is (FinSequence of (the carrier of C834)) : (for B705 being (Element of ( NAT )) holds ((1 <= B705 & B705 <= ( len B704 )) implies (ex B706 , B707 being (Element of C834) st (( B704 . B705 ) = ( B706 * B707 ) & B706 in C835 & B707 in C836)))) } by L1599;
thus L1605: C837 in ( C835 *' C836 ) by L1604 , L1586 , L1597 , L1589 , L1596 , L9;
end;
L1606: ( ( C835 + C836 ) *' ( C835 /\ C836 ) ) = ( ( C835 *' ( C835 /\ C836 ) ) + ( C836 *' ( C835 /\ C836 ) ) ) by L1522;
thus L1607: thesis by L1606 , L1584 , TARSKI:def 3;
end;
theorem
L1608: (for B708 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B709 , B710 being  add-closed  left-ideal non  empty (Subset of B708) holds ( ( B709 + B710 ) *' ( B709 /\ B710 ) ) c= ( B709 /\ B710 )))
proof
let C844 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C845 , C846 being  add-closed  left-ideal non  empty (Subset of C844);
L1609:
now
let C847 being set;
assume L1610: C847 in ( ( C845 + C846 ) *' ( C845 /\ C846 ) );
consider C848 being (FinSequence of (the carrier of C844)) such that L1611: C847 = ( Sum C848 ) and L1612: (for B711 being (Element of ( NAT )) holds ((1 <= B711 & B711 <= ( len C848 )) implies (ex B712 , B713 being (Element of C844) st (( C848 . B711 ) = ( B712 * B713 ) & B712 in ( C845 + C846 ) & B713 in ( C845 /\ C846 ))))) by L1610;
consider C849 being (Function of ( NAT ) , (the carrier of C844)) such that L1613: ( Sum C848 ) = ( C849 . ( len C848 ) ) and L1614: ( C849 . ( 0 ) ) = ( 0. C844 ) and L1615: (for B714 being (Element of ( NAT )) holds (for B715 being (Element of C844) holds ((B714 < ( len C848 ) & B715 = ( C848 . ( B714 + 1 ) )) implies ( C849 . ( B714 + 1 ) ) = ( ( C849 . B714 ) + B715 )))) by RLVECT_1:def 12;
defpred S15[ (Element of ( NAT )) ] means ( C849 . $1 ) in ( C845 /\ C846 );
L1616:
now
let C850 being (Element of ( NAT ));
assume that
L1617: ( 0 ) <= C850
and
L1618: C850 < ( len C848 );
thus L1619: (S15[ C850 ] implies S15[ ( C850 + 1 ) ])
proof
L1620: (( ( 0 ) + 1 ) <= ( C850 + 1 ) & ( C850 + 1 ) <= ( len C848 )) by L1618 , NAT_1:13;
L1621: ( C850 + 1 ) in ( Seg ( len C848 ) ) by L1620 , FINSEQ_1:1;
L1622: ( C850 + 1 ) in ( dom C848 ) by L1621 , FINSEQ_1:def 3;
L1623: ( C848 . ( C850 + 1 ) ) = ( C848 /. ( C850 + 1 ) ) by L1622 , PARTFUN1:def 6;
assume L1624: ( C849 . C850 ) in ( C845 /\ C846 );
L1625: (ex B716 , B717 being (Element of C844) st (( C848 . ( C850 + 1 ) ) = ( B716 * B717 ) & B716 in ( C845 + C846 ) & B717 in ( C845 /\ C846 ))) by L1612 , L1620;
L1626: ( C848 /. ( C850 + 1 ) ) in ( C845 /\ C846 ) by L1625 , L1623 , L11;
L1627: ( ( C849 . C850 ) + ( C848 /. ( C850 + 1 ) ) ) in ( C845 /\ C846 ) by L1626 , L1624 , L9;
thus L1628: thesis by L1627 , L1615 , L1618 , L1623;
end;

end;
L1620: S15[ ( 0 ) ] by L1614 , L46;
L1621: (for B718 being (Element of ( NAT )) holds ((( 0 ) <= B718 & B718 <= ( len C848 )) implies S15[ B718 ])) from INT_1:sch 7(L1620 , L1616);
thus L1622: C847 in ( C845 /\ C846 ) by L1621 , L1611 , L1613;
end;
thus L1623: thesis by L1609 , TARSKI:def 3;
end;
definition
let C851 being non  empty addLoopStr;
let C852 , C853 being (Subset of C851);
pred C852 , C853 are_co-prime 
means
:L1624: ( C852 + C853 ) = (the carrier of C851)
;end;
theorem
L1626: (for B719 being  left_zeroed  left_unital non  empty doubleLoopStr holds (for B720 , B721 being non  empty (Subset of B719) holds (B720 , B721 are_co-prime  implies ( B720 /\ B721 ) c= ( ( B720 + B721 ) *' ( B720 /\ B721 ) ))))
proof
let C854 being  left_zeroed  left_unital non  empty doubleLoopStr;
let C855 , C856 being non  empty (Subset of C854);
assume L1627: C855 , C856 are_co-prime ;
L1628: ( C855 + C856 ) = (the carrier of C854) by L1627 , L1624;
L1629:
now
let C857 being set;
assume L1630: C857 in ( C855 /\ C856 );
reconsider D279 = C857 as (Element of C854) by L1630;
set D280 = <* ( ( 1. C854 ) * D279 ) *>;
L1631: ( len D280 ) = 1 by FINSEQ_1:39;
L1632: (for B722 being (Element of ( NAT )) holds ((1 <= B722 & B722 <= ( len D280 )) implies (ex B723 , B724 being (Element of C854) st (( D280 . B722 ) = ( B723 * B724 ) & B723 in ( C855 + C856 ) & B724 in ( C855 /\ C856 )))))
proof
let C858 being (Element of ( NAT ));
assume L1633: (1 <= C858 & C858 <= ( len D280 ));
take ( 1. C854 );
take D279;
L1634: C858 = 1 by L1631 , L1633 , XXREAL_0:1;
thus L1635: thesis by L1634 , L1628 , L1630 , FINSEQ_1:40;
end;
L1636: ( Sum D280 ) = ( ( 1. C854 ) * D279 ) by BINOM:3
.= D279 by VECTSP_1:def 8;
thus L1637: C857 in ( ( C855 + C856 ) *' ( C855 /\ C856 ) ) by L1636 , L1632;
end;
thus L1638: thesis by L1629 , TARSKI:def 3;
end;
theorem
L1639: (for B725 being  Abelian  left_zeroed  right_zeroed  add-cancelable  add-associative  left_unital  commutative  associative  distributive non  empty doubleLoopStr holds (for B726 being  add-closed  left-ideal  right-ideal non  empty (Subset of B725) holds (for B727 being  add-closed  left-ideal non  empty (Subset of B725) holds (B726 , B727 are_co-prime  implies ( B726 *' B727 ) = ( B726 /\ B727 )))))
proof
let C859 being  left_zeroed  right_zeroed  add-cancelable  add-associative  Abelian  commutative  associative  distributive  left_unital non  empty doubleLoopStr;
let C860 being  add-closed  left-ideal  right-ideal non  empty (Subset of C859);
let C861 being  add-closed  left-ideal non  empty (Subset of C859);
L1640: ( C860 *' C861 ) c= ( C860 /\ C861 ) by L1505;
assume L1641: C860 , C861 are_co-prime ;
L1642: ( C860 /\ C861 ) c= ( ( C860 + C861 ) *' ( C860 /\ C861 ) ) by L1641 , L1626;
L1643: ( ( C860 + C861 ) *' ( C860 /\ C861 ) ) c= ( C860 *' C861 ) by L1583;
L1644: ( C860 /\ C861 ) c= ( C860 *' C861 ) by L1643 , L1642 , XBOOLE_1:1;
thus L1645: thesis by L1644 , L1640 , XBOOLE_0:def 10;
end;
definition
let C862 being non  empty multMagma;
let C863 , C864 being (Subset of C862);
func C863 % C864 -> (Subset of C862) equals 
{ B728 where B728 is (Element of C862) : ( B728 * C864 ) c= C863 };
coherence
proof
set D281 = { B729 where B729 is (Element of C862) : ( B729 * C864 ) c= C863 };
L1646: (for B730 being set holds (B730 in D281 implies B730 in (the carrier of C862)))
proof
let C865 being set;
assume L1647: C865 in D281;
L1648: (ex B731 being (Element of C862) st (C865 = B731 & ( B731 * C864 ) c= C863)) by L1647;
thus L1649: thesis by L1648;
end;
thus L1650: thesis by L1646 , TARSKI:def 3;
end;
end;
registration
let C866 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C867 , C868 being  left-ideal non  empty (Subset of C866);
cluster ( C867 % C868 ) -> non  empty;
coherence
proof
set D282 = { B732 where B732 is (Element of C866) : ( B732 * C868 ) c= C867 };
L1652: ( 0. C866 ) in C867 by L46;
L1653: (for B733 being set holds (B733 in { ( 0. C866 ) } implies B733 in C867)) by L1652 , TARSKI:def 1;
L1654: { ( 0. C866 ) } c= C867 by L1653 , TARSKI:def 3;
L1655: ( ( 0. C866 ) * C868 ) = { ( 0. C866 ) } by L1137;
L1656: ( 0. C866 ) in D282 by L1655 , L1654;
thus L1657: thesis by L1656;
end;
end;
registration
let C869 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C870 , C871 being  add-closed  left-ideal non  empty (Subset of C869);
cluster ( C870 % C871 ) ->  add-closed;
coherence
proof
set D283 = { B734 where B734 is (Element of C869) : ( B734 * C871 ) c= C870 };
L1659: D283 = ( C870 % C871 );
reconsider D284 = D283 as non  empty (Subset of C869) by L1659;
L1660: (for B735 , B736 being (Element of C869) holds ((B735 in D284 & B736 in D284) implies ( B735 + B736 ) in D284))
proof
let C872 , C873 being (Element of C869);
assume that
L1661: C872 in D284
and
L1662: C873 in D284;
consider C874 being (Element of C869) such that L1663: C873 = C874 and L1664: ( C874 * C871 ) c= C870 by L1662;
consider C875 being (Element of C869) such that L1665: C872 = C875 and L1666: ( C875 * C871 ) c= C870 by L1661;
L1667:
now
let C876 being set;
assume L1668: C876 in ( ( C875 + C874 ) * C871 );
consider C877 being (Element of C869) such that L1669: C876 = ( ( C875 + C874 ) * C877 ) and L1670: C877 in C871 by L1668;
L1671: ( C874 * C877 ) in { ( C874 * B737 ) where B737 is (Element of C869) : B737 in C871 } by L1670;
L1672: (C876 = ( ( C875 * C877 ) + ( C874 * C877 ) ) & ( C875 * C877 ) in ( C875 * C871 )) by L1669 , L1670 , VECTSP_1:def 3;
thus L1673: C876 in C870 by L1672 , L1666 , L1664 , L1671 , L9;
end;
L1674: ( ( C875 + C874 ) * C871 ) c= C870 by L1667 , TARSKI:def 3;
thus L1675: thesis by L1674 , L1665 , L1663;
end;
thus L1676: thesis by L1660 , L9;
end;
end;
registration
let C878 being  right_zeroed  left_add-cancelable  left-distributive  associative  commutative non  empty doubleLoopStr;
let C879 , C880 being  left-ideal non  empty (Subset of C878);
cluster ( C879 % C880 ) ->  left-ideal;
coherence
proof
set D285 = { B738 where B738 is (Element of C878) : ( B738 * C880 ) c= C879 };
L1678: D285 = ( C879 % C880 );
reconsider D286 = D285 as non  empty (Subset of C878) by L1678;
L1679: (for B739 , B740 being (Element of C878) holds (B740 in D286 implies ( B739 * B740 ) in D286))
proof
let C881 , C882 being (Element of C878);
assume L1680: C882 in D286;
consider C883 being (Element of C878) such that L1681: C882 = C883 and L1682: ( C883 * C880 ) c= C879 by L1680;
L1683:
now
let C884 being set;
assume L1684: C884 in ( ( C881 * C883 ) * C880 );
consider C885 being (Element of C878) such that L1685: C884 = ( ( C881 * C883 ) * C885 ) and L1686: C885 in C880 by L1684;
L1687: ( C881 * C885 ) in C880 by L1686 , L11;
L1688: ( C883 * ( C881 * C885 ) ) in { ( C883 * B741 ) where B741 is (Element of C878) : B741 in C880 } by L1687;
L1689: C884 = ( C883 * ( C881 * C885 ) ) by L1685 , GROUP_1:def 3;
thus L1690: C884 in C879 by L1689 , L1682 , L1688;
end;
L1691: ( ( C881 * C883 ) * C880 ) c= C879 by L1683 , TARSKI:def 3;
thus L1692: thesis by L1691 , L1681;
end;
thus L1693: thesis by L1679 , L11;
end;
cluster ( C879 % C880 ) ->  right-ideal;
coherence;
end;
theorem
L1695: (for B742 being non  empty multLoopStr holds (for B743 being  right-ideal non  empty (Subset of B742) holds (for B744 being (Subset of B742) holds B743 c= ( B743 % B744 ))))
proof
let C886 being non  empty multLoopStr;
let C887 being  right-ideal non  empty (Subset of C886);
let C888 being (Subset of C886);
L1696:
now
let C889 being set;
assume L1697: C889 in C887;
reconsider D287 = C889 as (Element of C886) by L1697;
L1698:
now
let C890 being set;
assume L1699: C890 in ( D287 * C888 );
L1700: (ex B745 being (Element of C886) st (C890 = ( D287 * B745 ) & B745 in C888)) by L1699;
thus L1701: C890 in C887 by L1700 , L1697 , L12;
end;
L1702: ( D287 * C888 ) c= C887 by L1698 , TARSKI:def 3;
thus L1703: C889 in ( C887 % C888 ) by L1702;
end;
thus L1704: thesis by L1696 , TARSKI:def 3;
end;
theorem
L1705: (for B746 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr holds (for B747 being  add-closed  left-ideal non  empty (Subset of B746) holds (for B748 being (Subset of B746) holds ( ( B747 % B748 ) *' B748 ) c= B747)))
proof
let C891 being  right_zeroed  left_add-cancelable  left-distributive non  empty doubleLoopStr;
let C892 being  add-closed  left-ideal non  empty (Subset of C891);
let C893 being (Subset of C891);
L1706:
now
let C894 being set;
assume L1707: C894 in ( ( C892 % C893 ) *' C893 );
consider C895 being (FinSequence of (the carrier of C891)) such that L1708: ( Sum C895 ) = C894 and L1709: (for B749 being (Element of ( NAT )) holds ((1 <= B749 & B749 <= ( len C895 )) implies (ex B750 , B751 being (Element of C891) st (( C895 . B749 ) = ( B750 * B751 ) & B750 in ( C892 % C893 ) & B751 in C893)))) by L1707;
consider C896 being (Function of ( NAT ) , (the carrier of C891)) such that L1710: ( Sum C895 ) = ( C896 . ( len C895 ) ) and L1711: ( C896 . ( 0 ) ) = ( 0. C891 ) and L1712: (for B752 being (Element of ( NAT )) holds (for B753 being (Element of C891) holds ((B752 < ( len C895 ) & B753 = ( C895 . ( B752 + 1 ) )) implies ( C896 . ( B752 + 1 ) ) = ( ( C896 . B752 ) + B753 )))) by RLVECT_1:def 12;
defpred S16[ (Element of ( NAT )) ] means ( C896 . $1 ) in C892;
L1713:
now
let C897 being (Element of ( NAT ));
assume that
L1714: ( 0 ) <= C897
and
L1715: C897 < ( len C895 );
thus L1716: (S16[ C897 ] implies S16[ ( C897 + 1 ) ])
proof
L1717: (( C897 + 1 ) <= ( len C895 ) & ( ( 0 ) + 1 ) <= ( C897 + 1 )) by L1715 , NAT_1:13;
consider C898 , C899 being (Element of C891) such that L1718: ( C895 . ( C897 + 1 ) ) = ( C898 * C899 ) and L1719: C898 in ( C892 % C893 ) and L1720: C899 in C893 by L1717 , L1709;
L1721: ( C897 + 1 ) in ( Seg ( len C895 ) ) by L1717 , FINSEQ_1:1;
L1722: ( C897 + 1 ) in ( dom C895 ) by L1721 , FINSEQ_1:def 3;
L1723: ( C895 . ( C897 + 1 ) ) = ( C895 /. ( C897 + 1 ) ) by L1722 , PARTFUN1:def 6;
L1724: ( C896 . ( C897 + 1 ) ) = ( ( C896 . C897 ) + ( C895 /. ( C897 + 1 ) ) ) by L1723 , L1712 , L1715;
assume L1725: ( C896 . C897 ) in C892;
consider C900 being (Element of C891) such that L1726: C898 = C900 and L1727: ( C900 * C893 ) c= C892 by L1719;
L1728: ( C898 * C899 ) in { ( C900 * B754 ) where B754 is (Element of C891) : B754 in C893 } by L1720 , L1726;
thus L1729: thesis by L1728 , L1725 , L1723 , L1724 , L1718 , L1727 , L9;
end;

end;
L1717: S16[ ( 0 ) ] by L1711 , L46;
L1718: (for B755 being (Element of ( NAT )) holds ((( 0 ) <= B755 & B755 <= ( len C895 )) implies S16[ B755 ])) from INT_1:sch 7(L1717 , L1713);
thus L1719: C894 in C892 by L1718 , L1708 , L1710;
end;
thus L1720: thesis by L1706 , TARSKI:def 3;
end;
theorem
L1721: (for B756 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B757 being  add-closed  right-ideal non  empty (Subset of B756) holds (for B758 being (Subset of B756) holds ( ( B757 % B758 ) *' B758 ) c= B757)))
proof
let C901 being  left_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C902 being  add-closed  right-ideal non  empty (Subset of C901);
let C903 being (Subset of C901);
L1722:
now
let C904 being set;
assume L1723: C904 in ( ( C902 % C903 ) *' C903 );
consider C905 being (FinSequence of (the carrier of C901)) such that L1724: ( Sum C905 ) = C904 and L1725: (for B759 being (Element of ( NAT )) holds ((1 <= B759 & B759 <= ( len C905 )) implies (ex B760 , B761 being (Element of C901) st (( C905 . B759 ) = ( B760 * B761 ) & B760 in ( C902 % C903 ) & B761 in C903)))) by L1723;
consider C906 being (Function of ( NAT ) , (the carrier of C901)) such that L1726: ( Sum C905 ) = ( C906 . ( len C905 ) ) and L1727: ( C906 . ( 0 ) ) = ( 0. C901 ) and L1728: (for B762 being (Element of ( NAT )) holds (for B763 being (Element of C901) holds ((B762 < ( len C905 ) & B763 = ( C905 . ( B762 + 1 ) )) implies ( C906 . ( B762 + 1 ) ) = ( ( C906 . B762 ) + B763 )))) by RLVECT_1:def 12;
defpred S17[ (Element of ( NAT )) ] means ( C906 . $1 ) in C902;
L1729:
now
let C907 being (Element of ( NAT ));
assume that
L1730: ( 0 ) <= C907
and
L1731: C907 < ( len C905 );
thus L1732: (S17[ C907 ] implies S17[ ( C907 + 1 ) ])
proof
L1733: (( C907 + 1 ) <= ( len C905 ) & ( ( 0 ) + 1 ) <= ( C907 + 1 )) by L1731 , NAT_1:13;
consider C908 , C909 being (Element of C901) such that L1734: ( C905 . ( C907 + 1 ) ) = ( C908 * C909 ) and L1735: C908 in ( C902 % C903 ) and L1736: C909 in C903 by L1733 , L1725;
L1737: ( C907 + 1 ) in ( Seg ( len C905 ) ) by L1733 , FINSEQ_1:1;
L1738: ( C907 + 1 ) in ( dom C905 ) by L1737 , FINSEQ_1:def 3;
L1739: ( C905 . ( C907 + 1 ) ) = ( C905 /. ( C907 + 1 ) ) by L1738 , PARTFUN1:def 6;
L1740: ( C906 . ( C907 + 1 ) ) = ( ( C906 . C907 ) + ( C905 /. ( C907 + 1 ) ) ) by L1739 , L1728 , L1731;
assume L1741: ( C906 . C907 ) in C902;
consider C910 being (Element of C901) such that L1742: C908 = C910 and L1743: ( C910 * C903 ) c= C902 by L1735;
L1744: ( C908 * C909 ) in { ( C910 * B764 ) where B764 is (Element of C901) : B764 in C903 } by L1736 , L1742;
thus L1745: thesis by L1744 , L1741 , L1739 , L1740 , L1734 , L1743 , L9;
end;

end;
L1733: S17[ ( 0 ) ] by L1727 , L49;
L1734: (for B765 being (Element of ( NAT )) holds ((( 0 ) <= B765 & B765 <= ( len C905 )) implies S17[ B765 ])) from INT_1:sch 7(L1733 , L1729);
thus L1735: C904 in C902 by L1734 , L1724 , L1726;
end;
thus L1736: thesis by L1722 , TARSKI:def 3;
end;
theorem
L1737: (for B766 being  left_zeroed  right_add-cancelable  right-distributive  commutative  associative non  empty doubleLoopStr holds (for B767 being  add-closed  right-ideal non  empty (Subset of B766) holds (for B768 , B769 being (Subset of B766) holds ( ( B767 % B768 ) % B769 ) = ( B767 % ( B768 *' B769 ) ))))
proof
let C911 being  left_zeroed  right_add-cancelable  right-distributive  commutative  associative non  empty doubleLoopStr;
let C912 being  add-closed  right-ideal non  empty (Subset of C911);
let C913 , C914 being (Subset of C911);
L1738:
now
let C915 being set;
assume L1739: C915 in ( ( C912 % C913 ) % C914 );
consider C916 being (Element of C911) such that L1740: C915 = C916 and L1741: ( C916 * C914 ) c= ( C912 % C913 ) by L1739;
L1742:
now
let C917 being set;
assume L1743: C917 in ( C916 * ( C913 *' C914 ) );
consider C918 being (Element of C911) such that L1744: C917 = ( C916 * C918 ) and L1745: C918 in ( C913 *' C914 ) by L1743;
consider C919 being (FinSequence of (the carrier of C911)) such that L1746: ( Sum C919 ) = C918 and L1747: (for B770 being (Element of ( NAT )) holds ((1 <= B770 & B770 <= ( len C919 )) implies (ex B771 , B772 being (Element of C911) st (( C919 . B770 ) = ( B771 * B772 ) & B771 in C913 & B772 in C914)))) by L1745;
set D288 = ( C916 * C919 );
L1748: ( dom D288 ) = ( dom C919 ) by POLYNOM1:def 1;
L1749: ( Seg ( len D288 ) ) = ( dom D288 ) by FINSEQ_1:def 3
.= ( dom C919 ) by POLYNOM1:def 1
.= ( Seg ( len C919 ) ) by FINSEQ_1:def 3;
L1750: ( len D288 ) = ( len C919 ) by L1749 , FINSEQ_1:6;
L1751: (for B773 being (Element of ( NAT )) holds ((1 <= B773 & B773 <= ( len D288 )) implies (ex B774 , B775 being (Element of C911) st (( D288 . B773 ) = ( B774 * B775 ) & B774 in ( C912 % C913 ) & B775 in C913))))
proof
let C920 being (Element of ( NAT ));
assume L1752: (1 <= C920 & C920 <= ( len D288 ));
consider C921 , C922 being (Element of C911) such that L1753: ( C919 . C920 ) = ( C921 * C922 ) and L1754: C921 in C913 and L1755: C922 in C914 by L1752 , L1747 , L1750;
L1756: ( C916 * C922 ) in { ( C916 * B776 ) where B776 is (Element of C911) : B776 in C914 } by L1755;
L1757: C920 in ( Seg ( len C919 ) ) by L1749 , L1752 , FINSEQ_1:1;
L1758: C920 in ( dom C919 ) by L1757 , FINSEQ_1:def 3;
L1759: ( C919 /. C920 ) = ( C921 * C922 ) by L1758 , L1753 , PARTFUN1:def 6;
L1760: ( D288 . C920 ) = ( D288 /. C920 ) by L1748 , L1758 , PARTFUN1:def 6
.= ( C916 * ( C921 * C922 ) ) by L1758 , L1759 , POLYNOM1:def 1
.= ( ( C916 * C922 ) * C921 ) by GROUP_1:def 3;
thus L1761: thesis by L1760 , L1741 , L1754 , L1756;
end;
L1762: ( Sum D288 ) in { ( Sum B777 ) where B777 is (FinSequence of (the carrier of C911)) : (for B778 being (Element of ( NAT )) holds ((1 <= B778 & B778 <= ( len B777 )) implies (ex B779 , B780 being (Element of C911) st (( B777 . B778 ) = ( B779 * B780 ) & B779 in ( C912 % C913 ) & B780 in C913)))) } by L1751;
L1763: ( ( C912 % C913 ) *' C913 ) c= C912 by L1721;
L1764: ( Sum D288 ) = C917 by L1744 , L1746 , BINOM:4;
thus L1765: C917 in C912 by L1764 , L1762 , L1763;
end;
L1766: ( C916 * ( C913 *' C914 ) ) c= C912 by L1742 , TARSKI:def 3;
thus L1767: C915 in ( C912 % ( C913 *' C914 ) ) by L1766 , L1740;
end;
L1768:
now
let C923 being set;
assume L1769: C923 in ( C912 % ( C913 *' C914 ) );
consider C924 being (Element of C911) such that L1770: C923 = C924 and L1771: ( C924 * ( C913 *' C914 ) ) c= C912 by L1769;
L1772:
now
let C925 being set;
assume L1773: C925 in ( C924 * C914 );
consider C926 being (Element of C911) such that L1774: C925 = ( C924 * C926 ) and L1775: C926 in C914 by L1773;
L1776:
now
let C927 being set;
assume L1777: C927 in ( ( C924 * C926 ) * C913 );
consider C928 being (Element of C911) such that L1778: C927 = ( ( C924 * C926 ) * C928 ) and L1779: C928 in C913 by L1777;
L1780: C927 = ( C924 * ( C928 * C926 ) ) by L1778 , GROUP_1:def 3;
set D289 = <* ( C928 * C926 ) *>;
L1781: ( len D289 ) = 1 by FINSEQ_1:40;
L1782: (for B781 being (Element of ( NAT )) holds ((1 <= B781 & B781 <= ( len D289 )) implies (ex B782 , B783 being (Element of C911) st (( D289 . B781 ) = ( B782 * B783 ) & B782 in C913 & B783 in C914))))
proof
let C929 being (Element of ( NAT ));
assume L1783: (1 <= C929 & C929 <= ( len D289 ));
L1784: ( D289 . C929 ) = ( D289 . 1 ) by L1783 , L1781 , XXREAL_0:1
.= ( C928 * C926 ) by FINSEQ_1:40;
thus L1785: thesis by L1784 , L1775 , L1779;
end;
L1786: ( Sum D289 ) = ( C928 * C926 ) by BINOM:3;
L1787: ( C928 * C926 ) in { ( Sum B784 ) where B784 is (FinSequence of (the carrier of C911)) : (for B785 being (Element of ( NAT )) holds ((1 <= B785 & B785 <= ( len B784 )) implies (ex B786 , B787 being (Element of C911) st (( B784 . B785 ) = ( B786 * B787 ) & B786 in C913 & B787 in C914)))) } by L1786 , L1782;
L1788: C927 in { ( C924 * B788 ) where B788 is (Element of C911) : B788 in ( C913 *' C914 ) } by L1787 , L1780;
thus L1789: C927 in C912 by L1788 , L1771;
end;
L1790: ( ( C924 * C926 ) * C913 ) c= C912 by L1776 , TARSKI:def 3;
thus L1791: C925 in ( C912 % C913 ) by L1790 , L1774;
end;
L1792: ( C924 * C914 ) c= ( C912 % C913 ) by L1772 , TARSKI:def 3;
thus L1793: C923 in ( ( C912 % C913 ) % C914 ) by L1792 , L1770;
end;
thus L1794: thesis by L1768 , L1738 , TARSKI:1;
end;
theorem
L1795: (for B789 being non  empty multLoopStr holds (for B790 , B791 , B792 being (Subset of B789) holds ( ( B791 /\ B792 ) % B790 ) = ( ( B791 % B790 ) /\ ( B792 % B790 ) )))
proof
let C930 being non  empty multLoopStr;
let C931 , C932 , C933 being (Subset of C930);
L1796:
now
let C934 being set;
assume L1797: C934 in ( ( C932 /\ C933 ) % C931 );
consider C935 being (Element of C930) such that L1798: C934 = C935 and L1799: ( C935 * C931 ) c= ( C932 /\ C933 ) by L1797;
L1800:
now
let C936 being set;
assume L1801: C936 in ( C935 * C931 );
L1802: C936 in ( C932 /\ C933 ) by L1801 , L1799;
L1803: (ex B793 being (Element of C930) st (C936 = B793 & B793 in C932 & B793 in C933)) by L1802;
thus L1804: C936 in C933 by L1803;
end;
L1805: ( C935 * C931 ) c= C933 by L1800 , TARSKI:def 3;
L1806: C934 in ( C933 % C931 ) by L1805 , L1798;
L1807:
now
let C937 being set;
assume L1808: C937 in ( C935 * C931 );
L1809: C937 in ( C932 /\ C933 ) by L1808 , L1799;
L1810: (ex B794 being (Element of C930) st (C937 = B794 & B794 in C932 & B794 in C933)) by L1809;
thus L1811: C937 in C932 by L1810;
end;
L1812: ( C935 * C931 ) c= C932 by L1807 , TARSKI:def 3;
L1813: C934 in ( C932 % C931 ) by L1812 , L1798;
thus L1814: C934 in ( ( C932 % C931 ) /\ ( C933 % C931 ) ) by L1813 , L1806;
end;
L1815:
now
let C938 being set;
assume L1816: C938 in ( ( C932 % C931 ) /\ ( C933 % C931 ) );
L1817: (ex B795 being (Element of C930) st (B795 = C938 & B795 in ( C932 % C931 ) & B795 in ( C933 % C931 ))) by L1816;
consider C939 being (Element of C930) such that L1818: C938 = C939 and L1819: ( C939 * C931 ) c= C932 by L1817;
L1820: (ex B796 being (Element of C930) st (C938 = B796 & ( B796 * C931 ) c= C933)) by L1817;
L1821: (for B797 being set holds (B797 in ( C939 * C931 ) implies B797 in ( C932 /\ C933 ))) by L1820 , L1818 , L1819;
L1822: ( C939 * C931 ) c= ( C932 /\ C933 ) by L1821 , TARSKI:def 3;
thus L1823: C938 in ( ( C932 /\ C933 ) % C931 ) by L1822 , L1818;
end;
thus L1824: thesis by L1815 , L1796 , TARSKI:1;
end;
theorem
L1825: (for B798 being  left_zeroed  right_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr holds (for B799 being  add-closed (Subset of B798) holds (for B800 , B801 being  right-ideal non  empty (Subset of B798) holds ( B799 % ( B800 + B801 ) ) = ( ( B799 % B800 ) /\ ( B799 % B801 ) ))))
proof
let C940 being  left_zeroed  right_zeroed  right_add-cancelable  right-distributive non  empty doubleLoopStr;
let C941 being  add-closed (Subset of C940);
let C942 , C943 being  right-ideal non  empty (Subset of C940);
L1826:
now
let C944 being set;
assume L1827: C944 in ( C941 % ( C942 + C943 ) );
consider C945 being (Element of C940) such that L1828: C944 = C945 and L1829: ( C945 * ( C942 + C943 ) ) c= C941 by L1827;
L1830:
now
let C946 being set;
assume L1831: C946 in ( C945 * C942 );
L1832: (ex B802 being (Element of C940) st (C946 = ( C945 * B802 ) & B802 in C942)) by L1831;
L1833: C942 c= ( C942 + C943 ) by L1262;
L1834: C946 in { ( C945 * B803 ) where B803 is (Element of C940) : B803 in ( C942 + C943 ) } by L1833 , L1832;
thus L1835: C946 in C941 by L1834 , L1829;
end;
L1836: ( C945 * C942 ) c= C941 by L1830 , TARSKI:def 3;
L1837: C944 in ( C941 % C942 ) by L1836 , L1828;
L1838:
now
let C947 being set;
assume L1839: C947 in ( C945 * C943 );
L1840: (ex B804 being (Element of C940) st (C947 = ( C945 * B804 ) & B804 in C943)) by L1839;
L1841: C943 c= ( C942 + C943 ) by L1269;
L1842: C947 in { ( C945 * B805 ) where B805 is (Element of C940) : B805 in ( C942 + C943 ) } by L1841 , L1840;
thus L1843: C947 in C941 by L1842 , L1829;
end;
L1844: ( C945 * C943 ) c= C941 by L1838 , TARSKI:def 3;
L1845: C944 in ( C941 % C943 ) by L1844 , L1828;
thus L1846: C944 in ( ( C941 % C942 ) /\ ( C941 % C943 ) ) by L1845 , L1837;
end;
L1847:
now
let C948 being set;
assume L1848: C948 in ( ( C941 % C942 ) /\ ( C941 % C943 ) );
L1849: (ex B806 being (Element of C940) st (C948 = B806 & B806 in ( C941 % C942 ) & B806 in ( C941 % C943 ))) by L1848;
consider C949 being (Element of C940) such that L1850: C948 = C949 and L1851: ( C949 * C942 ) c= C941 by L1849;
consider C950 being (Element of C940) such that L1852: C948 = C950 and L1853: ( C950 * C943 ) c= C941 by L1849;
L1854:
now
let C951 being set;
assume L1855: C951 in ( C949 * ( C942 + C943 ) );
consider C952 being (Element of C940) such that L1856: C951 = ( C949 * C952 ) and L1857: C952 in ( C942 + C943 ) by L1855;
consider C953 , C954 being (Element of C940) such that L1858: C952 = ( C953 + C954 ) and L1859: (C953 in C942 & C954 in C943) by L1857;
L1860: (( C949 * C953 ) in ( C949 * C942 ) & ( C950 * C954 ) in { ( C950 * B807 ) where B807 is (Element of C940) : B807 in C943 }) by L1859;
L1861: C951 = ( ( C949 * C953 ) + ( C950 * C954 ) ) by L1850 , L1852 , L1856 , L1858 , VECTSP_1:def 2;
thus L1862: C951 in C941 by L1861 , L1851 , L1853 , L1860 , L9;
end;
L1863: ( C949 * ( C942 + C943 ) ) c= C941 by L1854 , TARSKI:def 3;
thus L1864: C948 in ( C941 % ( C942 + C943 ) ) by L1863 , L1850;
end;
thus L1865: thesis by L1847 , L1826 , TARSKI:1;
end;
definition
let C955 being  well-unital non  empty doubleLoopStr;
let C956 being (Subset of C955);
func sqrt C956 -> (Subset of C955) equals 
{ B808 where B808 is (Element of C955) : (ex B809 being (Element of ( NAT )) st ( B808 |^ B809 ) in C956) };
coherence
proof
set D290 = { B810 where B810 is (Element of C955) : (ex B811 being (Element of ( NAT )) st ( B810 |^ B811 ) in C956) };
L1866: (for B812 being set holds (B812 in D290 implies B812 in (the carrier of C955)))
proof
let C957 being set;
assume L1867: C957 in D290;
L1868: (ex B813 being (Element of C955) st (B813 = C957 & (ex B814 being (Element of ( NAT )) st ( B813 |^ B814 ) in C956))) by L1867;
thus L1869: thesis by L1868;
end;
thus L1870: thesis by L1866 , TARSKI:def 3;
end;
end;
registration
let C958 being  well-unital non  empty doubleLoopStr;
let C959 being non  empty (Subset of C958);
cluster ( sqrt C959 ) -> non  empty;
coherence
proof
set D291 = { B815 where B815 is (Element of C958) : (ex B816 being (Element of ( NAT )) st ( B815 |^ B816 ) in C959) };
L1872: D291 is non  empty
proof
set D292 = the (Element of C959);
L1873: ( D292 |^ 1 ) = D292 by BINOM:8;
L1874: D292 in D291 by L1873;
thus L1875: thesis by L1874;
end;
thus L1876: thesis by L1872;
end;
end;
registration
let C960 being  Abelian  add-associative  left_zeroed  right_zeroed  commutative  associative  add-cancelable  distributive  well-unital non  empty doubleLoopStr;
let C961 being  add-closed  right-ideal non  empty (Subset of C960);
cluster ( sqrt C961 ) ->  add-closed;
coherence
proof
set D293 = { B817 where B817 is (Element of C960) : (ex B818 being (Element of ( NAT )) st ( B817 |^ B818 ) in C961) };
L1878: D293 = ( sqrt C961 );
reconsider D294 = D293 as non  empty (Subset of C960) by L1878;
L1879: (for B819 , B820 being (Element of C960) holds ((B819 in D294 & B820 in D294) implies ( B819 + B820 ) in D294))
proof
let C962 , C963 being (Element of C960);
assume that
L1880: C962 in D294
and
L1881: C963 in D294;
consider C964 being (Element of C960) such that L1882: C962 = C964 and L1883: (ex B821 being (Element of ( NAT )) st ( C964 |^ B821 ) in C961) by L1880;
consider C965 being (Element of ( NAT )) such that L1884: ( C964 |^ C965 ) in C961 by L1883;
consider C966 being (Element of C960) such that L1885: C963 = C966 and L1886: (ex B822 being (Element of ( NAT )) st ( C966 |^ B822 ) in C961) by L1881;
consider C967 being (Element of ( NAT )) such that L1887: ( C966 |^ C967 ) in C961 by L1886;
set D295 = ( (C964 , C966) In_Power ( C965 + C967 ) );
consider C968 being (Function of ( NAT ) , (the carrier of C960)) such that L1888: ( Sum D295 ) = ( C968 . ( len D295 ) ) and L1889: ( C968 . ( 0 ) ) = ( 0. C960 ) and L1890: (for B823 being (Element of ( NAT )) holds (for B824 being (Element of C960) holds ((B823 < ( len D295 ) & B824 = ( D295 . ( B823 + 1 ) )) implies ( C968 . ( B823 + 1 ) ) = ( ( C968 . B823 ) + B824 )))) by RLVECT_1:def 12;
defpred S18[ (Element of ( NAT )) ] means ( C968 . $1 ) in C961;
L1891: (for B825 being (Element of ( NAT )) holds ((1 <= B825 & B825 <= ( len D295 )) implies ( D295 . B825 ) in C961))
proof
let C969 being (Element of ( NAT ));
assume that
L1892: 1 <= C969
and
L1893: C969 <= ( len D295 );
set D296 = ( C969 - 1 );
set D297 = ( ( C965 + C967 ) - D296 );
L1894: ( 1 - 1 ) <= ( C969 - 1 ) by L1892 , XREAL_1:9;
reconsider D298 = D296 as (Element of ( NAT )) by L1894 , INT_1:3;
L1895: C969 <= ( ( C965 + C967 ) + 1 ) by L1893 , BINOM:def 7;
L1896: D298 <= ( ( ( C965 + C967 ) + 1 ) - 1 ) by L1895 , XREAL_1:9;
L1897: ( D298 - D298 ) <= ( ( C965 + C967 ) - D298 ) by L1896 , XREAL_1:9;
reconsider D299 = D297 as (Element of ( NAT )) by L1897 , INT_1:3;
L1898: C969 in ( Seg ( len D295 ) ) by L1892 , L1893 , FINSEQ_1:1;
L1899: C969 in ( dom D295 ) by L1898 , FINSEQ_1:def 3;
L1900: ( D295 . C969 ) = ( D295 /. C969 ) by L1899 , PARTFUN1:def 6
.= ( ( ( ( C965 + C967 ) choose D298 ) * ( C964 |^ D299 ) ) * ( C966 |^ D298 ) ) by L1899 , BINOM:def 7;
per cases ;
suppose L1901: C965 <= D299;

consider C970 being Nat such that L1902: D299 = ( C965 + C970 ) by L1901 , NAT_1:10;
reconsider D300 = C970 as (Element of ( NAT )) by ORDINAL1:def 12;
L1903: ( C964 |^ D299 ) = ( ( C964 |^ C965 ) * ( C964 |^ D300 ) ) by L1902 , BINOM:10;
L1904: ( C964 |^ D299 ) in C961 by L1903 , L1884 , L12;
L1905: ( ( ( C965 + C967 ) choose D298 ) * ( C964 |^ D299 ) ) in C961 by L1904 , L126;
thus L1906: thesis by L1905 , L1900 , L12;
end;
suppose L1907: D299 < C965;

L1908: ( ( ( C965 + C967 ) + ( - D298 ) ) + D298 ) < ( C965 + D298 ) by L1907 , XREAL_1:6;
L1909: ( ( - C965 ) + ( C965 + C967 ) ) < ( ( - C965 ) + ( C965 + D298 ) ) by L1908 , XREAL_1:6;
consider C971 being Nat such that L1910: D298 = ( C967 + C971 ) by L1909 , NAT_1:10;
reconsider D301 = C971 as (Element of ( NAT )) by ORDINAL1:def 12;
L1911: ( C966 |^ D298 ) = ( ( C966 |^ C967 ) * ( C966 |^ D301 ) ) by L1910 , BINOM:10;
L1912: ( C966 |^ D298 ) in C961 by L1911 , L1887 , L12;
thus L1913: thesis by L1912 , L1900 , L12;
end;
end;
L1915:
now
let C972 being (Element of ( NAT ));
assume that
L1916: ( 0 ) <= C972
and
L1917: C972 < ( len D295 );
thus L1918: (S18[ C972 ] implies S18[ ( C972 + 1 ) ])
proof
assume L1919: ( C968 . C972 ) in C961;
L1920: ( C972 + 1 ) <= ( len D295 ) by L1917 , NAT_1:13;
L1921: 1 <= ( C972 + 1 ) by NAT_1:11;
L1922: ( C972 + 1 ) in ( Seg ( len D295 ) ) by L1921 , L1920 , FINSEQ_1:1;
L1923: ( C972 + 1 ) in ( dom D295 ) by L1922 , FINSEQ_1:def 3;
L1924: ( D295 /. ( C972 + 1 ) ) = ( D295 . ( C972 + 1 ) ) by L1923 , PARTFUN1:def 6;
L1925: ( D295 /. ( C972 + 1 ) ) in C961 by L1924 , L1891 , L1920 , NAT_1:11;
L1926: ( C968 . ( C972 + 1 ) ) = ( ( C968 . C972 ) + ( D295 /. ( C972 + 1 ) ) ) by L1890 , L1917 , L1924;
thus L1927: thesis by L1926 , L1919 , L1925 , L9;
end;

end;
L1919: ( ( C964 + C966 ) |^ ( C965 + C967 ) ) = ( Sum ( (C964 , C966) In_Power ( C965 + C967 ) ) ) by BINOM:25;
L1920: S18[ ( 0 ) ] by L1889 , L46;
L1921: (for B826 being (Element of ( NAT )) holds ((( 0 ) <= B826 & B826 <= ( len D295 )) implies S18[ B826 ])) from INT_1:sch 7(L1920 , L1915);
L1922: ( ( C964 + C966 ) |^ ( C965 + C967 ) ) in C961 by L1921 , L1919 , L1888;
thus L1923: thesis by L1922 , L1882 , L1885;
end;
thus L1924: thesis by L1879 , L9;
end;
end;
registration
let C973 being  well-unital  commutative  associative non  empty doubleLoopStr;
let C974 being  left-ideal non  empty (Subset of C973);
cluster ( sqrt C974 ) ->  left-ideal;
coherence
proof
set D302 = { B827 where B827 is (Element of C973) : (ex B828 being (Element of ( NAT )) st ( B827 |^ B828 ) in C974) };
L1926: D302 = ( sqrt C974 );
reconsider D303 = D302 as non  empty (Subset of C973) by L1926;
L1927: (for B829 , B830 being (Element of C973) holds (B830 in D303 implies ( B829 * B830 ) in D303))
proof
let C975 , C976 being (Element of C973);
reconsider D304 = C976 , D305 = C975 as (Element of C973);
assume L1928: C976 in D303;
consider C977 being (Element of C973) such that L1929: D304 = C977 and L1930: (ex B831 being (Element of ( NAT )) st ( C977 |^ B831 ) in C974) by L1928;
consider C978 being (Element of ( NAT )) such that L1931: ( C977 |^ C978 ) in C974 by L1930;
L1932: ( ( D305 * C977 ) |^ C978 ) = ( ( D305 |^ C978 ) * ( C977 |^ C978 ) ) by BINOM:9;
L1933: ( ( D305 |^ C978 ) * ( C977 |^ C978 ) ) in C974 by L1931 , L11;
thus L1934: thesis by L1933 , L1929 , L1932;
end;
thus L1935: thesis by L1927 , L11;
end;
cluster ( sqrt C974 ) ->  right-ideal;
coherence;
end;
theorem
L1937: (for B832 being  well-unital  associative non  empty doubleLoopStr holds (for B833 being non  empty (Subset of B832) holds (for B834 being (Element of B832) holds (B834 in ( sqrt B833 ) iff (ex B835 being (Element of ( NAT )) st ( B834 |^ B835 ) in ( sqrt B833 ))))))
proof
let C979 being  well-unital  associative non  empty doubleLoopStr;
let C980 being non  empty (Subset of C979);
let C981 being (Element of C979);
L1938:
now
assume L1939: (ex B836 being (Element of ( NAT )) st ( C981 |^ B836 ) in ( sqrt C980 ));
consider C982 being (Element of ( NAT )) such that L1940: ( C981 |^ C982 ) in ( sqrt C980 ) by L1939;
consider C983 being (Element of C979) such that L1941: ( C981 |^ C982 ) = C983 and L1942: (ex B837 being (Element of ( NAT )) st ( C983 |^ B837 ) in C980) by L1940;
consider C984 being (Element of ( NAT )) such that L1943: ( C983 |^ C984 ) in C980 by L1942;
L1944: ( C981 |^ ( C982 * C984 ) ) = ( C983 |^ C984 ) by L1941 , BINOM:11;
thus L1945: C981 in ( sqrt C980 ) by L1944 , L1943;
end;
L1946:
now
L1947: ( C981 |^ 1 ) = C981 by BINOM:8;
assume L1948: C981 in ( sqrt C980 );
thus L1949: (ex B838 being (Element of ( NAT )) st ( C981 |^ B838 ) in ( sqrt C980 )) by L1948 , L1947;
end;
thus L1950: thesis by L1946 , L1938;
end;
theorem
L1951: (for B839 being  left_zeroed  right_zeroed  add-cancelable  distributive  well-unital  associative non  empty doubleLoopStr holds (for B840 being  add-closed  right-ideal non  empty (Subset of B839) holds (for B841 being  add-closed  left-ideal non  empty (Subset of B839) holds ( sqrt ( B840 *' B841 ) ) = ( sqrt ( B840 /\ B841 ) ))))
proof
let C985 being  left_zeroed  right_zeroed  associative  add-cancelable  distributive  well-unital non  empty doubleLoopStr;
let C986 being  add-closed  right-ideal non  empty (Subset of C985);
let C987 being  add-closed  left-ideal non  empty (Subset of C985);
L1952:
now
let C988 being set;
assume L1953: C988 in ( sqrt ( C986 *' C987 ) );
consider C989 being (Element of C985) such that L1954: C988 = C989 and L1955: (ex B842 being (Element of ( NAT )) st ( C989 |^ B842 ) in ( C986 *' C987 )) by L1953;
consider C990 being (Element of ( NAT )) such that L1956: ( C989 |^ C990 ) in ( C986 *' C987 ) by L1955;
consider C991 being (FinSequence of (the carrier of C985)) such that L1957: ( C989 |^ C990 ) = ( Sum C991 ) and L1958: (for B843 being (Element of ( NAT )) holds ((1 <= B843 & B843 <= ( len C991 )) implies (ex B844 , B845 being (Element of C985) st (( C991 . B843 ) = ( B844 * B845 ) & B844 in C986 & B845 in C987)))) by L1956;
consider C992 being (Function of ( NAT ) , (the carrier of C985)) such that L1959: ( Sum C991 ) = ( C992 . ( len C991 ) ) and L1960: ( C992 . ( 0 ) ) = ( 0. C985 ) and L1961: (for B846 being (Element of ( NAT )) holds (for B847 being (Element of C985) holds ((B846 < ( len C991 ) & B847 = ( C991 . ( B846 + 1 ) )) implies ( C992 . ( B846 + 1 ) ) = ( ( C992 . B846 ) + B847 )))) by RLVECT_1:def 12;
defpred S19[ (Element of ( NAT )) ] means ( C992 . $1 ) in ( C986 /\ C987 );
L1962:
now
let C993 being (Element of ( NAT ));
assume that
L1963: ( 0 ) <= C993
and
L1964: C993 < ( len C991 );
thus L1965: (S19[ C993 ] implies S19[ ( C993 + 1 ) ])
proof
assume L1966: ( C992 . C993 ) in ( C986 /\ C987 );
L1967: (ex B848 being (Element of C985) st (B848 = ( C992 . C993 ) & B848 in C986 & B848 in C987)) by L1966;
L1968: (( C993 + 1 ) <= ( len C991 ) & ( ( 0 ) + 1 ) <= ( C993 + 1 )) by L1964 , NAT_1:13;
L1969: (ex B849 , B850 being (Element of C985) st (( C991 . ( C993 + 1 ) ) = ( B849 * B850 ) & B849 in C986 & B850 in C987)) by L1968 , L1958;
L1970: ( C993 + 1 ) in ( Seg ( len C991 ) ) by L1968 , FINSEQ_1:1;
L1971: ( C993 + 1 ) in ( dom C991 ) by L1970 , FINSEQ_1:def 3;
L1972: ( C991 . ( C993 + 1 ) ) = ( C991 /. ( C993 + 1 ) ) by L1971 , PARTFUN1:def 6;
L1973: ( C992 . ( C993 + 1 ) ) = ( ( C992 . C993 ) + ( C991 /. ( C993 + 1 ) ) ) by L1972 , L1961 , L1964;
L1974: ( C991 /. ( C993 + 1 ) ) in C987 by L1972 , L1969 , L11;
L1975: ( C992 . ( C993 + 1 ) ) in C987 by L1974 , L1967 , L1973 , L9;
L1976: ( C991 /. ( C993 + 1 ) ) in C986 by L1972 , L1969 , L12;
L1977: ( C992 . ( C993 + 1 ) ) in C986 by L1976 , L1967 , L1973 , L9;
thus L1978: thesis by L1977 , L1975;
end;

end;
L1966: (( C992 . ( 0 ) ) in C986 & ( C992 . ( 0 ) ) in C987) by L1960 , L46 , L49;
L1967: S19[ ( 0 ) ] by L1966;
L1968: (for B851 being (Element of ( NAT )) holds ((( 0 ) <= B851 & B851 <= ( len C991 )) implies S19[ B851 ])) from INT_1:sch 7(L1967 , L1962);
L1969: ( Sum C991 ) in ( C986 /\ C987 ) by L1968 , L1959;
thus L1970: C988 in ( sqrt ( C986 /\ C987 ) ) by L1969 , L1954 , L1957;
end;
L1971:
now
let C994 being set;
assume L1972: C994 in ( sqrt ( C986 /\ C987 ) );
consider C995 being (Element of C985) such that L1973: C994 = C995 and L1974: (ex B852 being (Element of ( NAT )) st ( C995 |^ B852 ) in ( C986 /\ C987 )) by L1972;
consider C996 being (Element of ( NAT )) such that L1975: ( C995 |^ C996 ) in ( C986 /\ C987 ) by L1974;
set D306 = <* ( ( C995 |^ C996 ) * ( C995 |^ C996 ) ) *>;
L1976: ( len D306 ) = 1 by FINSEQ_1:40;
L1977: (ex B853 being (Element of C985) st (( C995 |^ C996 ) = B853 & B853 in C986 & B853 in C987)) by L1975;
L1978: (for B854 being (Element of ( NAT )) holds ((1 <= B854 & B854 <= ( len D306 )) implies (ex B855 , B856 being (Element of C985) st (( D306 . B854 ) = ( B855 * B856 ) & B855 in C986 & B856 in C987))))
proof
let C997 being (Element of ( NAT ));
assume L1979: (1 <= C997 & C997 <= ( len D306 ));
L1980: C997 in ( Seg ( len D306 ) ) by L1979 , FINSEQ_1:1;
L1981: C997 in ( dom D306 ) by L1980 , FINSEQ_1:def 3;
L1982: ( D306 . C997 ) = ( D306 /. C997 ) by L1981 , PARTFUN1:def 6;
L1983: ( D306 /. C997 ) = ( D306 . 1 ) by L1982 , L1976 , L1979 , XXREAL_0:1
.= ( ( C995 |^ C996 ) * ( C995 |^ C996 ) ) by FINSEQ_1:40;
thus L1984: thesis by L1983 , L1977 , L1982;
end;
L1985: ( C995 |^ ( C996 + C996 ) ) = ( ( C995 |^ C996 ) * ( C995 |^ C996 ) ) by BINOM:10
.= ( Sum D306 ) by BINOM:3;
L1986: ( C995 |^ ( C996 + C996 ) ) in ( C986 *' C987 ) by L1985 , L1978;
thus L1987: C994 in ( sqrt ( C986 *' C987 ) ) by L1986 , L1973;
end;
thus L1988: thesis by L1971 , L1952 , TARSKI:1;
end;
begin
definition
let C998 being non  empty doubleLoopStr;
let C999 being (Ideal of C998);
attr C999 is  finitely_generated
means
:L1989: (ex B857 being non  empty  finite (Subset of C998) st C999 = ( B857 -Ideal ));
end;
registration
let C1000 being non  empty doubleLoopStr;
cluster  finitely_generated for (Ideal of C1000);
existence
proof
consider C1001 being set such that L1991: C1001 in (the carrier of C1000) by XBOOLE_0:def 1;
reconsider D307 = C1001 as (Element of C1000) by L1991;
take ( { D307 } -Ideal );
thus L1992: thesis by L1989;
end;
end;
registration
let C1002 being non  empty doubleLoopStr;
let C1003 being non  empty  finite (Subset of C1002);
cluster ( C1003 -Ideal ) ->  finitely_generated;
coherence by L1989;
end;
definition
let C1004 being non  empty doubleLoopStr;
attr C1004 is  Noetherian
means
:L1995: (for B858 being (Ideal of C1004) holds B858 is  finitely_generated);
end;
registration
cluster  Euclidian  Abelian  add-associative  right_zeroed  right_complementable  well-unital  distributive  commutative  associative non  degenerated for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( INT.Ring );
thus L1997: thesis;
end;
end;
definition
let C1005 being non  empty doubleLoopStr;
let C1006 being (Ideal of C1005);
attr C1006 is  principal
means
:L1999: (ex B859 being (Element of C1005) st C1006 = ( { B859 } -Ideal ));
end;
definition
let C1007 being non  empty doubleLoopStr;
attr C1007 is  PID
means
:L2001: (for B860 being (Ideal of C1007) holds B860 is  principal);
end;
theorem
L2003: (for B861 being non  empty doubleLoopStr holds (for B862 being non  empty (Subset of B861) holds (B862 <> { ( 0. B861 ) } implies (ex B863 being (Element of B861) st (B863 <> ( 0. B861 ) & B863 in B862)))))
proof
let C1008 being non  empty doubleLoopStr;
let C1009 being non  empty (Subset of C1008);
assume L2004: C1009 <> { ( 0. C1008 ) };
L2005:
now
assume L2006: (for B864 being set holds (B864 in C1009 implies B864 = ( 0. C1008 )));
L2007: (for B865 being set holds (B865 in C1009 iff B865 = ( 0. C1008 )))
proof
let C1010 being set;
L2008: (ex B866 being set st B866 in C1009) by XBOOLE_0:def 1;
thus L2009: (C1010 in C1009 implies C1010 = ( 0. C1008 )) by L2006;
assume L2010: C1010 = ( 0. C1008 );
thus L2011: thesis by L2010 , L2006 , L2008;
end;
thus L2012: contradiction by L2007 , L2004 , TARSKI:def 1;
end;
thus L2013: thesis by L2005;
end;
theorem
L2014: (for B867 being  add-associative  left_zeroed  right_zeroed  right_complementable  distributive  well-unital  Euclidian non  empty doubleLoopStr holds B867 is  PID)
proof
let C1011 being  add-associative  left_zeroed  right_zeroed  right_complementable  distributive  well-unital  Euclidian non  empty doubleLoopStr;
let C1012 being (Ideal of C1011);
per cases ;
suppose L2015: C1012 = { ( 0. C1011 ) };

set D308 = ( 0. C1011 );
take D308;
thus L2016: thesis by L2015 , L712;
end;
suppose L2017: C1012 <> { ( 0. C1011 ) };

consider C1013 being (Element of C1011) such that L2018: (C1013 <> ( 0. C1011 ) & C1013 in C1012) by L2017 , L2003;
set D309 = { B868 where B868 is (Element of C1012) : B868 <> ( 0. C1011 ) };
L2019: D309 c= (the carrier of C1011)
proof
let C1014 being set;
assume L2020: C1014 in D309;
L2021: (ex B869 being (Element of C1012) st (C1014 = B869 & B869 <> ( 0. C1011 ))) by L2020;
thus L2022: thesis by L2021;
end;
L2023: C1013 in D309 by L2018;
reconsider D310 = D309 as non  empty (Subset of C1011) by L2023 , L2019;
consider C1015 being (Function of (the carrier of C1011) , ( NAT )) such that L2024: (for B870 , B871 being (Element of C1011) holds (B871 <> ( 0. C1011 ) implies (ex B872 , B873 being (Element of C1011) st (B870 = ( ( B872 * B871 ) + B873 ) & (B873 = ( 0. C1011 ) or (( C1015 . B873 ) qua (Element of ( NAT ))) < (( C1015 . B871 ) qua (Element of ( NAT )))))))) by INT_3:def 8;
set D311 = { ( C1015 . B874 ) where B874 is (Element of D310) : (not contradiction) };
set D312 = the (Element of D310);
L2025: ( C1015 . D312 ) in D311;
L2026: D311 c= ( NAT )
proof
let C1016 being set;
assume L2027: C1016 in D311;
L2028: (ex B875 being (Element of D310) st ( C1015 . B875 ) = C1016) by L2027;
thus L2029: thesis by L2028;
end;
reconsider D313 = D311 as non  empty (Subset of ( NAT )) by L2026 , L2025;
set D314 = ( min D313 );
L2030: D314 in D313 by XXREAL_2:def 7;
consider C1017 being (Element of D310) such that L2031: ( C1015 . C1017 ) = D314 by L2030;
L2032: C1017 in D310;
L2033: (ex B876 being (Element of C1012) st (B876 = C1017 & B876 <> ( 0. C1011 ))) by L2032;
reconsider D315 = C1017 as (Element of C1011);
take D315;
L2034:
now
let C1018 being set;
L2035: { D315 } c= C1012 by L2033 , ZFMISC_1:31;
L2036: ( { D315 } -Ideal ) c= C1012 by L2035 , L579;
thus L2037:now
assume L2038: C1018 in C1012;
reconsider D316 = C1018 as (Element of C1011) by L2038;
consider C1019 , C1020 being (Element of C1011) such that L2039: D316 = ( ( C1019 * D315 ) + C1020 ) and L2040: (C1020 = ( 0. C1011 ) or (( C1015 . C1020 ) qua (Element of ( NAT ))) < D314) by L2024 , L2031 , L2033;
L2041:
now
L2042: ( C1019 * D315 ) in C1012 by L2033 , L11;
L2043: ( - ( C1019 * D315 ) ) in C1012 by L2042 , L106;
assume L2044: C1020 <> ( 0. C1011 );
L2045: ( ( - ( C1019 * D315 ) ) + D316 ) = ( ( ( - ( C1019 * D315 ) ) + ( C1019 * D315 ) ) + C1020 ) by L2039 , RLVECT_1:def 3
.= ( ( 0. C1011 ) + C1020 ) by RLVECT_1:5
.= C1020 by ALGSTR_1:def 2;
L2046: C1020 in C1012 by L2045 , L2038 , L2043 , L9;
L2047: C1020 in D310 by L2046 , L2044;
L2048: ( C1015 . C1020 ) in D313 by L2047;
thus L2049: contradiction by L2048 , L2040 , L2044 , XXREAL_2:def 7;
end;
L2050: D316 = ( C1019 * D315 ) by L2041 , L2039 , RLVECT_1:def 4;
L2051: (D315 in { D315 } & { D315 } c= ( { D315 } -Ideal )) by L579 , TARSKI:def 1;
thus L2052: C1018 in ( { D315 } -Ideal ) by L2051 , L2050 , L11;
end;
assume L2053: C1018 in ( { D315 } -Ideal );
thus L2054: C1018 in C1012 by L2053 , L2036;
end;
thus L2055: thesis by L2034 , TARSKI:1;
end;
end;
theorem
L2057: (for B877 being non  empty doubleLoopStr holds (B877 is  PID implies B877 is  Noetherian))
proof
let C1021 being non  empty doubleLoopStr;
assume L2058: C1021 is  PID;
let C1022 being (Ideal of C1021);
L2059: C1022 is  principal by L2058 , L2001;
consider C1023 being (Element of C1021) such that L2060: C1022 = ( { C1023 } -Ideal ) by L2059 , L1999;
take { C1023 };
thus L2061: thesis by L2060;
end;
registration
cluster ( INT.Ring ) ->  Noetherian;
coherence
proof
L2062: ( INT.Ring ) is  PID by L2014;
thus L2063: thesis by L2062 , L2057;
end;
end;
registration
cluster  Noetherian  Abelian  add-associative  right_zeroed  right_complementable  well-unital  distributive  commutative  associative non  degenerated for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( INT.Ring );
thus L2065: thesis;
end;
end;
theorem
L2067: (for B878 being  Noetherian  add-associative  left_zeroed  right_zeroed  add-cancelable  associative  distributive  well-unital non  empty doubleLoopStr holds (for B879 being non  empty (Subset of B878) holds (ex B880 being non  empty  finite (Subset of B878) st (B880 c= B879 & ( B880 -Ideal ) = ( B879 -Ideal )))))
proof
let C1024 being  Noetherian  add-associative  left_zeroed  right_zeroed  add-cancelable  associative  distributive  well-unital non  empty doubleLoopStr;
let C1025 being non  empty (Subset of C1024);
defpred S20[ set , set ] means (ex B881 being non  empty (LinearCombination of C1025) st ($1 = ( Sum B881 ) & (ex B882 being (FinSequence of C1025) st (( dom B882 ) = ( dom B881 ) & $2 = ( rng B882 ) & (for B883 being (Element of ( NAT )) holds (B883 in ( dom B881 ) implies (ex B884 , B885 being (Element of C1024) st ( B881 /. B883 ) = ( ( B884 * ((( B882 /. B883 ) qua (Element of C1025)) qua (Element of C1024)) ) * B885 ))))))));
L2068: ( C1025 -Ideal ) is  finitely_generated by L1995;
consider C1026 being non  empty  finite (Subset of C1024) such that L2069: ( C1026 -Ideal ) = ( C1025 -Ideal ) by L2068 , L1989;
L2070: C1026 c= ( C1025 -Ideal ) by L2069 , L579;
L2071: (for B886 being set holds (B886 in C1026 implies (ex B887 being set st (B887 in ( bool C1025 ) & S20[ B886 , B887 ]))))
proof
let C1027 being set;
assume L2072: C1027 in C1026;
consider C1028 being (LinearCombination of C1025) such that L2073: C1027 = ( Sum C1028 ) by L2072 , L2070 , L772;
per cases ;
suppose L2074: C1028 is non  empty;

defpred S21[ set , (Element of C1025) ] means (ex B888 , B889 being (Element of C1024) st ( C1028 /. $1 ) = ( ( B888 * ($2 qua (Element of C1024)) ) * B889 ));
L2075:
now
let C1029 being (Element of ( NAT ));
assume L2076: C1029 in ( Seg ( len C1028 ) );
L2077: C1029 in ( dom C1028 ) by L2076 , FINSEQ_1:def 3;
consider C1030 , C1031 being (Element of C1024), C1032 being (Element of C1025) such that L2078: ( C1028 /. C1029 ) = ( ( C1030 * C1032 ) * C1031 ) by L2077 , L314;
take D317 = C1032;
thus L2079: S21[ C1029 , D317 ] by L2078;
end;
consider C1033 being (FinSequence of C1025) such that L2080: (( dom C1033 ) = ( Seg ( len C1028 ) ) & (for B890 being (Element of ( NAT )) holds (B890 in ( Seg ( len C1028 ) ) implies S21[ B890 , (( C1033 /. B890 ) qua (Element of C1025)) ]))) from RECDEF_1:sch 17(L2075);
take D318 = ( rng C1033 );
thus L2081: D318 in ( bool C1025 );
L2082: ( dom C1028 ) = ( Seg ( len C1028 ) ) by FINSEQ_1:def 3;
thus L2083: thesis by L2082 , L2073 , L2074 , L2080;
end;
suppose L2084: C1028 is  empty;

set D319 = the (Element of C1025);
set D320 = <* ( ( ( 0. C1024 ) * D319 ) * ( 0. C1024 ) ) *>;
L2085:
now
let C1034 being set;
assume L2086: C1034 in ( dom D320 );
take D321 = ( 0. C1024 );
take D322 = ( 0. C1024 );
take D323 = D319;
L2087: C1034 in ( Seg ( len D320 ) ) by L2086 , FINSEQ_1:def 3;
L2088: C1034 in { 1 } by L2087 , FINSEQ_1:2 , FINSEQ_1:40;
L2089: C1034 = 1 by L2088 , TARSKI:def 1;
thus L2090: ( D320 /. C1034 ) = ( ( D321 * D323 ) * D322 ) by L2089 , FINSEQ_4:16;
end;
reconsider D324 = D320 as non  empty (LinearCombination of C1025) by L2085 , L314;
L2091: C1028 = ( <*> (the carrier of C1024) ) by L2084;
L2092: C1027 = ( 0. C1024 ) by L2091 , L2073 , RLVECT_1:43
.= ( ( ( 0. C1024 ) * D319 ) * ( 0. C1024 ) ) by BINOM:2
.= ( Sum D324 ) by BINOM:3;
defpred S22[ (Element of ( NAT )) , (Element of C1025) ] means (ex B891 , B892 being (Element of C1024) st ( D324 /. $1 ) = ( ( B891 * (($2 qua (Element of C1025)) qua (Element of C1024)) ) * B892 ));
L2093:
now
let C1035 being (Element of ( NAT ));
assume L2094: C1035 in ( Seg ( len D324 ) );
take D325 = D319;
L2095: C1035 in { 1 } by L2094 , FINSEQ_1:2 , FINSEQ_1:40;
L2096: C1035 = 1 by L2095 , TARSKI:def 1;
thus L2097: S22[ C1035 , D325 ] by L2096 , FINSEQ_4:16;
end;
consider C1036 being (FinSequence of C1025) such that L2098: (( dom C1036 ) = ( Seg ( len D324 ) ) & (for B893 being (Element of ( NAT )) holds (B893 in ( Seg ( len D324 ) ) implies S22[ B893 , (( C1036 /. B893 ) qua (Element of C1025)) ]))) from RECDEF_1:sch 17(L2093);
take D326 = ( rng C1036 );
thus L2099: D326 in ( bool C1025 );
L2100: ( dom D324 ) = ( Seg ( len D324 ) ) by FINSEQ_1:def 3;
thus L2101: thesis by L2100 , L2092 , L2098;
end;
end;
consider C1037 being (Function of C1026 , ( bool C1025 )) such that L2103: (for B894 being set holds (B894 in C1026 implies S20[ B894 , ( C1037 . B894 ) ])) from FUNCT_2:sch 1(L2071);
L2104:
now
let C1038 being set;
assume L2105: C1038 in ( rng C1037 );
consider C1039 being set such that L2106: (C1039 in ( dom C1037 ) & C1038 = ( C1037 . C1039 )) by L2105 , FUNCT_1:def 3;
L2107: (ex B895 being non  empty (LinearCombination of C1025) st (C1039 = ( Sum B895 ) & (ex B896 being (FinSequence of C1025) st (( dom B896 ) = ( dom B895 ) & C1038 = ( rng B896 ) & (for B897 being (Element of ( NAT )) holds (B897 in ( dom B895 ) implies (ex B898 , B899 being (Element of C1024) st ( B895 /. B897 ) = ( ( B898 * ((( B896 /. B897 ) qua (Element of C1025)) qua (Element of C1024)) ) * B899 )))))))) by L2103 , L2106;
thus L2108: C1038 is  finite by L2107;
end;
reconsider D327 = ( rng C1037 ) as (Subset-Family of C1025);
reconsider D328 = ( union D327 ) as (Subset of C1025);
consider C1040 being set such that L2109: C1040 in ( rng C1037 ) by XBOOLE_0:def 1;
consider C1041 being set such that L2110: (C1041 in ( dom C1037 ) & C1040 = ( C1037 . C1041 )) by L2109 , FUNCT_1:def 3;
L2111: (ex B900 being non  empty (LinearCombination of C1025) st (C1041 = ( Sum B900 ) & (ex B901 being (FinSequence of C1025) st (( dom B901 ) = ( dom B900 ) & C1040 = ( rng B901 ) & (for B902 being (Element of ( NAT )) holds (B902 in ( dom B900 ) implies (ex B903 , B904 being (Element of C1024) st ( B900 /. B902 ) = ( ( B903 * ((( B901 /. B902 ) qua (Element of C1025)) qua (Element of C1024)) ) * B904 )))))))) by L2103 , L2110;
L2112: C1040 is non  empty by L2111 , RELAT_1:42;
L2113: (ex B905 being set st B905 in C1040) by L2112 , XBOOLE_0:def 1;
reconsider D329 = D328 as non  empty  finite (Subset of C1024) by L2113 , L2109 , L2104 , FINSET_1:7 , TARSKI:def 4 , XBOOLE_1:1;
L2114:
now
let C1042 being set;
assume L2115: C1042 in C1026;
consider C1043 being non  empty (LinearCombination of C1025) such that L2116: C1042 = ( Sum C1043 ) and L2117: (ex B906 being (FinSequence of C1025) st (( dom B906 ) = ( dom C1043 ) & ( C1037 . C1042 ) = ( rng B906 ) & (for B907 being (Element of ( NAT )) holds (B907 in ( dom C1043 ) implies (ex B908 , B909 being (Element of C1024) st ( C1043 /. B907 ) = ( ( B908 * ((( B906 /. B907 ) qua (Element of C1025)) qua (Element of C1024)) ) * B909 )))))) by L2115 , L2103;
L2118: C1042 in ( dom C1037 ) by L2115 , FUNCT_2:def 1;
L2119: ( C1037 . C1042 ) in ( rng C1037 ) by L2118 , FUNCT_1:def 3;
L2120: ( C1037 . C1042 ) c= D329 by L2119 , ZFMISC_1:74;
L2121:
now
let C1044 being set;
consider C1045 being (FinSequence of C1025) such that L2122: ( dom C1045 ) = ( dom C1043 ) and L2123: ( C1037 . C1042 ) = ( rng C1045 ) and L2124: (for B910 being (Element of ( NAT )) holds (B910 in ( dom C1043 ) implies (ex B911 , B912 being (Element of C1024) st ( C1043 /. B910 ) = ( ( B911 * ((( C1045 /. B910 ) qua (Element of C1025)) qua (Element of C1024)) ) * B912 )))) by L2117;
assume L2125: C1044 in ( dom C1043 );
L2126: ( C1045 /. C1044 ) = ( C1045 . C1044 ) by L2125 , L2122 , PARTFUN1:def 6;
L2127: ( C1045 /. C1044 ) in ( C1037 . C1042 ) by L2126 , L2125 , L2122 , L2123 , FUNCT_1:def 3;
L2128: (ex B913 , B914 being (Element of C1024) st ( C1043 /. C1044 ) = ( ( B913 * ((( C1045 /. C1044 ) qua (Element of C1025)) qua (Element of C1024)) ) * B914 )) by L2125 , L2124;
thus L2129: (ex B915 , B916 being (Element of C1024) st (ex B917 being (Element of D329) st ( C1043 /. C1044 ) = ( ( B915 * B917 ) * B916 ))) by L2128 , L2120 , L2127;
end;
reconsider D330 = C1043 as (LinearCombination of D329) by L2121 , L314;
L2130: C1042 = ( Sum D330 ) by L2116;
thus L2131: C1042 in ( D329 -Ideal ) by L2130 , L772;
end;
L2132: C1026 c= ( D329 -Ideal ) by L2114 , TARSKI:def 3;
L2133: ( C1026 -Ideal ) c= ( ( D329 -Ideal ) -Ideal ) by L2132 , L757;
L2134: ( C1025 -Ideal ) c= ( D329 -Ideal ) by L2133 , L2069 , L712;
take D329;
L2135: ( D329 -Ideal ) c= ( C1025 -Ideal ) by L757;
thus L2136: thesis by L2135 , L2134 , XBOOLE_0:def 10;
end;
theorem
L2137: (for B918 being non  empty doubleLoopStr holds ((for B919 being non  empty (Subset of B918) holds (ex B920 being non  empty  finite (Subset of B918) st (B920 c= B919 & ( B920 -Ideal ) = ( B919 -Ideal )))) implies (for B921 being (sequence of B918) holds (ex B922 being (Element of ( NAT )) st ( B921 . ( B922 + 1 ) ) in ( ( rng ( B921 | ( B922 + 1 ) ) ) -Ideal )))))
proof
let C1046 being non  empty doubleLoopStr;
assume L2138: (for B923 being non  empty (Subset of C1046) holds (ex B924 being non  empty  finite (Subset of C1046) st (B924 c= B923 & ( B924 -Ideal ) = ( B923 -Ideal ))));
let C1047 being (sequence of C1046);
reconsider D331 = ( rng C1047 ) as non  empty (Subset of C1046);
consider C1048 being non  empty  finite (Subset of C1046) such that L2139: C1048 c= D331 and L2140: ( C1048 -Ideal ) = ( D331 -Ideal ) by L2138;
defpred S23[ set , set ] means $1 = ( C1047 . $2 );
L2141: ( dom C1047 ) = ( NAT ) by FUNCT_2:def 1;
L2142: (for B925 being set holds (B925 in C1048 implies (ex B926 being set st (B926 in ( NAT ) & S23[ B925 , B926 ]))))
proof
let C1049 being set;
assume L2143: C1049 in C1048;
consider C1050 being set such that L2144: C1050 in ( dom C1047 ) and L2145: C1049 = ( C1047 . C1050 ) by L2143 , L2139 , FUNCT_1:def 3;
take C1050;
thus L2146: C1050 in ( NAT ) by L2144;
thus L2147: thesis by L2145;
end;
consider C1051 being (Function of C1048 , ( NAT )) such that L2148: (for B927 being set holds (B927 in C1048 implies S23[ B927 , ( C1051 . B927 ) ])) from FUNCT_2:sch 1(L2142);
set D332 = ( rng C1051 );
reconsider D333 = D332 as non  empty  finite (Subset of ( NAT ));
reconsider D334 = ( max D333 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D335 = ( rng ( C1047 | ( Segm ( D334 + 1 ) ) ) );
L2149: ( dom C1051 ) = C1048 by FUNCT_2:def 1;
L2150: C1048 c= D335
proof
let C1052 being set;
set D336 = ( C1051 . C1052 );
assume L2151: C1052 in C1048;
L2152: ( C1051 . C1052 ) in D333 by L2151 , L2149 , FUNCT_1:def 3;
L2153: D336 <= D334 by L2152 , XXREAL_2:def 8;
L2154: D336 < ( D334 + 1 ) by L2153 , NAT_1:13;
L2155: D336 in ( Segm ( D334 + 1 ) ) by L2154 , NAT_1:44;
L2156: ( C1047 . D336 ) in ( rng ( C1047 | ( Segm ( D334 + 1 ) ) ) ) by L2155 , L2141 , FUNCT_1:50;
thus L2157: thesis by L2156 , L2148 , L2151;
end;
reconsider D337 = D335 as non  empty (Subset of C1046) by L2150;
L2158: ( D337 -Ideal ) c= ( D331 -Ideal ) by L757 , RELAT_1:70;
L2159: ( D331 -Ideal ) c= ( D337 -Ideal ) by L2140 , L2150 , L757;
L2160: ( D337 -Ideal ) = ( D331 -Ideal ) by L2159 , L2158 , XBOOLE_0:def 10;
take D334;
L2161: (D331 c= ( D331 -Ideal ) & ( C1047 . ( D334 + 1 ) ) in D331) by L579 , FUNCT_2:4;
thus L2162: thesis by L2161 , L2160;
end;
registration
let C1053 , C1054 being non  empty set;
let C1055 being (Function of C1053 , C1054);
let C1056 being non  empty (Subset of C1053);
cluster ( C1055 | C1056 ) -> non  empty;
coherence
proof
L2163: ( dom C1055 ) = C1053 by FUNCT_2:def 1;
L2164: ( ( dom C1055 ) /\ C1056 ) is non  empty by L2163 , XBOOLE_1:28;
L2165: ( dom C1055 ) meets C1056 by L2164 , XBOOLE_0:def 7;
thus L2166: thesis by L2165 , RELAT_1:66;
end;
end;
theorem
L2168: (for B928 being non  empty doubleLoopStr holds ((for B929 being (sequence of B928) holds (ex B930 being (Element of ( NAT )) st ( B929 . ( B930 + 1 ) ) in ( ( rng ( B929 | ( B930 + 1 ) ) ) -Ideal ))) implies (not (ex B931 being (Function of ( NAT ) , ( bool (the carrier of B928) )) st ((for B932 being (Element of ( NAT )) holds ( B931 . B932 ) is (Ideal of B928)) & (for B933 , B934 being (Element of ( NAT )) holds (B933 < B934 implies ( B931 . B933 ) c< ( B931 . B934 ))))))))
proof
let C1057 being non  empty doubleLoopStr;
assume L2169: (for B935 being (sequence of C1057) holds (ex B936 being (Element of ( NAT )) st ( B935 . ( B936 + 1 ) ) in ( ( rng ( B935 | ( B936 + 1 ) ) ) -Ideal )));
given C1058 being (Function of ( NAT ) , ( bool (the carrier of C1057) )) such that
L2170: (for B937 being (Element of ( NAT )) holds ( C1058 . B937 ) is (Ideal of C1057))
and
L2171: (for B938 , B939 being (Element of ( NAT )) holds (B938 < B939 implies ( C1058 . B938 ) c< ( C1058 . B939 )));

defpred S24[ set , set ] means (ex B940 being (Element of ( NAT )) st (B940 = $1 & (B940 = ( 0 ) implies $2 in ( C1058 . ( 0 ) )) & (B940 > ( 0 ) implies (ex B941 being (Element of ( NAT )) st (B940 = ( B941 + 1 ) & $2 in ( ( C1058 . B940 ) \ ( C1058 . B941 ) ))))));
L2172: (for B942 being set holds (B942 in ( NAT ) implies (ex B943 being set st (B943 in (the carrier of C1057) & S24[ B942 , B943 ]))))
proof
let C1059 being set;
assume L2173: C1059 in ( NAT );
reconsider D338 = C1059 as (Element of ( NAT )) by L2173;
per cases ;
suppose L2174: D338 = ( 0 );

L2175: ( C1058 . ( 0 ) ) is (Ideal of C1057) by L2170;
consider C1060 being set such that L2176: C1060 in ( C1058 . ( 0 ) ) by L2175 , XBOOLE_0:def 1;
take C1060;
thus L2177: C1060 in (the carrier of C1057) by L2176;
take D338;
thus L2178: D338 = C1059;
thus L2179: thesis by L2174 , L2176;
end;
suppose L2180: D338 > ( 0 );

consider C1061 being Nat such that L2181: D338 = ( C1061 + 1 ) by L2180 , NAT_1:6;
reconsider D339 = C1061 as (Element of ( NAT )) by ORDINAL1:def 12;
L2182: D338 > D339 by L2181 , NAT_1:13;
L2183: (not ( C1058 . D338 ) c= ( C1058 . D339 )) by L2182 , L2171 , XBOOLE_1:60;
L2184: ( ( C1058 . D338 ) \ ( C1058 . D339 ) ) is non  empty by L2183 , XBOOLE_1:37;
consider C1062 being set such that L2185: C1062 in ( ( C1058 . D338 ) \ ( C1058 . D339 ) ) by L2184 , XBOOLE_0:def 1;
take C1062;
thus L2186: C1062 in (the carrier of C1057) by L2185;
take D338;
thus L2187: D338 = C1059;
thus L2188: thesis by L2181 , L2185;
end;
end;
consider C1063 being (Function of ( NAT ) , (the carrier of C1057)) such that L2190: (for B944 being set holds (B944 in ( NAT ) implies S24[ B944 , ( C1063 . B944 ) ])) from FUNCT_2:sch 1(L2172);
consider C1064 being (Element of ( NAT )) such that L2191: ( C1063 . ( C1064 + 1 ) ) in ( ( rng ( C1063 | ( C1064 + 1 ) ) ) -Ideal ) by L2169;
reconsider D340 = ( C1064 + 1 ) as non  zero Nat;
L2192: (ex B945 being (Element of ( NAT )) st (B945 = ( C1064 + 1 ) & (B945 = ( 0 ) implies ( C1063 . ( C1064 + 1 ) ) in ( C1058 . ( 0 ) )) & (B945 > ( 0 ) implies (ex B946 being (Element of ( NAT )) st (B945 = ( B946 + 1 ) & ( C1063 . ( C1064 + 1 ) ) in ( ( C1058 . B945 ) \ ( C1058 . B946 ) )))))) by L2190;
defpred S25[ (Element of ( NAT )) ] means ( rng ( C1063 | ( Segm ( $1 + 1 ) ) ) ) c= ( C1058 . $1 );
L2193: (for B947 being (Element of ( NAT )) holds (S25[ B947 ] implies S25[ ( B947 + 1 ) ]))
proof
let C1065 being (Element of ( NAT ));
assume that
L2194: ( rng ( C1063 | ( Segm ( C1065 + 1 ) ) ) ) c= ( C1058 . C1065 );
let C1066 being set;
assume L2195: C1066 in ( rng ( C1063 | ( Segm ( ( C1065 + 1 ) + 1 ) ) ) );
consider C1067 being set such that L2196: C1067 in ( dom ( C1063 | ( Segm ( ( C1065 + 1 ) + 1 ) ) ) ) and L2197: C1066 = ( ( C1063 | ( Segm ( ( C1065 + 1 ) + 1 ) ) ) . C1067 ) by L2195 , FUNCT_1:def 3;
L2198: C1067 in ( dom C1063 ) by L2196 , RELAT_1:57;
reconsider D341 = C1067 as (Element of ( NAT )) by L2196;
L2199: C1067 in ( Segm ( ( C1065 + 1 ) + 1 ) ) by L2196 , RELAT_1:57;
L2200: D341 < ( ( C1065 + 1 ) + 1 ) by L2199 , NAT_1:44;
L2201: D341 <= ( C1065 + 1 ) by L2200 , NAT_1:13;
per cases  by L2201 , XXREAL_0:1;
suppose L2202: D341 < ( C1065 + 1 );

L2203: D341 in ( Segm ( C1065 + 1 ) ) by L2202 , NAT_1:44;
L2204: C1065 < ( C1065 + 1 ) by NAT_1:13;
L2205: ( C1058 . C1065 ) c< ( C1058 . ( C1065 + 1 ) ) by L2204 , L2171;
L2206: ( C1058 . C1065 ) c= ( C1058 . ( C1065 + 1 ) ) by L2205 , XBOOLE_0:def 8;
L2207: C1066 = ( C1063 . D341 ) by L2196 , L2197 , FUNCT_1:47;
L2208: C1066 in ( rng ( C1063 | ( Segm ( C1065 + 1 ) ) ) ) by L2207 , L2198 , L2203 , FUNCT_1:50;
L2209: C1066 in ( C1058 . C1065 ) by L2208 , L2194;
thus L2210: thesis by L2209 , L2206;
end;
suppose L2211: D341 = ( C1065 + 1 );

L2212: (C1066 = ( C1063 . D341 ) & (ex B948 being (Element of ( NAT )) st (B948 = D341 & (B948 = ( 0 ) implies ( C1063 . D341 ) in ( C1058 . ( 0 ) )) & (B948 > ( 0 ) implies (ex B949 being (Element of ( NAT )) st (B948 = ( B949 + 1 ) & ( C1063 . D341 ) in ( ( C1058 . B948 ) \ ( C1058 . B949 ) ))))))) by L2190 , L2196 , L2197 , FUNCT_1:47;
thus L2213: thesis by L2212 , L2211 , XBOOLE_0:def 5;
end;
end;
L2215: ( C1058 . C1064 ) is (Ideal of C1057) by L2170;
L2216: ( C1058 . C1064 ) = ( ( C1058 . C1064 ) -Ideal ) by L2215 , L712;
L2217: S25[ ( 0 ) ]
proof
let C1068 being set;
assume L2218: C1068 in ( rng ( C1063 | ( Segm ( ( 0 ) + 1 ) ) ) );
consider C1069 being set such that L2219: C1069 in ( dom ( C1063 | ( Segm 1 ) ) ) and L2220: C1068 = ( ( C1063 | ( Segm 1 ) ) . C1069 ) by L2218 , FUNCT_1:def 3;
L2221: (C1069 in ( Segm 1 ) & (ex B950 being (Element of ( NAT )) st (B950 = C1069 & (B950 = ( 0 ) implies ( C1063 . C1069 ) in ( C1058 . ( 0 ) )) & (B950 > ( 0 ) implies (ex B951 being (Element of ( NAT )) st (B950 = ( B951 + 1 ) & ( C1063 . C1069 ) in ( ( C1058 . B950 ) \ ( C1058 . B951 ) ))))))) by L2190 , L2219 , RELAT_1:57;
thus L2222: thesis by L2221 , L2220 , CARD_1:49 , FUNCT_1:49 , TARSKI:def 1;
end;
L2223: (for B952 being (Element of ( NAT )) holds S25[ B952 ]) from NAT_1:sch 1(L2217 , L2193);
L2224: ( ( rng ( C1063 | ( Segm D340 ) ) ) -Ideal ) c= ( C1058 . C1064 ) by L2223 , L2216 , L757;
thus L2225: contradiction by L2224 , L2191 , L2192 , XBOOLE_0:def 5;
end;
theorem
L2226: (for B953 being non  empty doubleLoopStr holds ((not (ex B954 being (Function of ( NAT ) , ( bool (the carrier of B953) )) st ((for B955 being (Element of ( NAT )) holds ( B954 . B955 ) is (Ideal of B953)) & (for B956 , B957 being (Element of ( NAT )) holds (B956 < B957 implies ( B954 . B956 ) c< ( B954 . B957 )))))) implies B953 is  Noetherian))
proof
let C1070 being non  empty doubleLoopStr;
assume that
L2227: (not (ex B958 being (Function of ( NAT ) , ( bool (the carrier of C1070) )) st ((for B959 being (Element of ( NAT )) holds ( B958 . B959 ) is (Ideal of C1070)) & (for B960 , B961 being (Element of ( NAT )) holds (B960 < B961 implies ( B958 . B960 ) c< ( B958 . B961 ))))))
and
L2228: (not C1070 is  Noetherian);
consider C1071 being (Ideal of C1070) such that L2229: (not C1071 is  finitely_generated) by L2228 , L1995;
set D342 = { B962 where B962 is (Subset of C1070) : B962 is non  empty  finite non  empty  finite non  empty  finite non  empty  finite (Subset of C1071) };
consider C1072 being set such that L2230: C1072 in C1071 by XBOOLE_0:def 1;
reconsider D343 = C1072 as (Element of C1070) by L2230;
L2231: { D343 } c= C1071 by L2230 , ZFMISC_1:31;
L2232: { D343 } in D342 by L2231;
L2233: D342 c= ( bool (the carrier of C1070) )
proof
let C1073 being set;
assume L2234: C1073 in D342;
L2235: (ex B963 being (Subset of C1070) st (C1073 = B963 & B963 is non  empty  finite non  empty  finite non  empty  finite non  empty  finite (Subset of C1071))) by L2234;
thus L2236: thesis by L2235;
end;
reconsider D344 = D342 as non  empty (Subset-Family of C1070) by L2233 , L2232;
reconsider D345 = { D343 } as (Element of D344) by L2232;
defpred S26[ set , (Element of D344) , set ] means (ex B964 being (Element of C1070) st (B964 in ( C1071 \ ( $2 -Ideal ) ) & $3 = ( $2 \/ { B964 } )));
L2237: (for B965 being (Element of ( NAT )) holds (for B966 being (Element of D344) holds (ex B967 being (Element of D344) st S26[ B965 , B966 , B967 ])))
proof
let C1074 being (Element of ( NAT ));
let C1075 being (Element of D344);
L2238: C1075 in D344;
consider C1076 being (Subset of C1070) such that L2239: C1076 = C1075 and L2240: C1076 is non  empty  finite non  empty  finite non  empty  finite non  empty  finite (Subset of C1071) by L2238;
reconsider D346 = C1076 as non  empty  finite (Subset of C1071) by L2240;
L2241: ( C1076 -Ideal ) c= ( C1071 -Ideal ) by L2240 , L757;
L2242: ( C1076 -Ideal ) c= C1071 by L2241 , L712;
L2243: (not C1071 c= ( C1076 -Ideal )) by L2242 , L2229 , L2240 , XBOOLE_0:def 10;
consider C1077 being set such that L2244: C1077 in C1071 and L2245: (not C1077 in ( C1076 -Ideal )) by L2243 , TARSKI:def 3;
set D347 = ( D346 \/ { C1077 } );
L2246: D347 c= C1071
proof
let C1078 being set;
assume L2247: C1078 in D347;
L2248: (C1078 in D346 or C1078 in { C1077 }) by L2247 , XBOOLE_0:def 3;
thus L2249: thesis by L2248 , L2244 , TARSKI:def 1;
end;
L2250: D347 is (Subset of C1070) by L2246 , XBOOLE_1:1;
L2251: D347 in D344 by L2250 , L2246;
reconsider D348 = C1077 as (Element of C1070) by L2244;
reconsider D349 = D347 as (Element of D344) by L2251;
take D349;
take D348;
thus L2252: thesis by L2239 , L2244 , L2245 , XBOOLE_0:def 5;
end;
consider C1079 being (Function of ( NAT ) , D344) such that L2253: (( C1079 . ( 0 ) ) = D345 & (for B968 being (Element of ( NAT )) holds S26[ B968 , (( C1079 . B968 ) qua (Element of D344)) , ( C1079 . ( B968 + 1 ) ) ])) from RECDEF_1:sch 2(L2237);
defpred S27[ (Element of ( NAT )) , (Subset of C1070) ] means (ex B969 being (Subset of C1070) st (B969 = ( C1079 . $1 ) & $2 = ( B969 -Ideal )));
L2254: (for B970 being (Element of ( NAT )) holds (ex B971 being (Subset of C1070) st S27[ B970 , B971 ]))
proof
let C1080 being (Element of ( NAT ));
L2255: ( C1079 . C1080 ) in D344;
consider C1081 being (Subset of C1070) such that L2256: C1081 = ( C1079 . C1080 ) and L2257: C1081 is non  empty  finite non  empty  finite non  empty  finite non  empty  finite (Subset of C1071) by L2255;
reconsider D350 = ( C1081 -Ideal ) as (Subset of C1070);
take D350;
take C1081;
thus L2258: thesis by L2256;
end;
consider C1082 being (Function of ( NAT ) , ( bool (the carrier of C1070) )) such that L2259: (for B972 being (Element of ( NAT )) holds S27[ B972 , ( C1082 . B972 ) ]) from FUNCT_2:sch 3(L2254);
L2260: (for B973 , B974 being (Element of ( NAT )) holds (B973 < B974 implies ( C1082 . B973 ) c< ( C1082 . B974 )))
proof
let C1083 , C1084 being (Element of ( NAT ));
defpred S28[ (Element of ( NAT )) ] means ( C1082 . C1083 ) c< ( C1082 . ( ( C1083 + 1 ) + $1 ) );
assume L2261: C1083 < C1084;
L2262: ( C1083 + 1 ) <= C1084 by L2261 , NAT_1:13;
consider C1085 being Nat such that L2263: C1084 = ( ( C1083 + 1 ) + C1085 ) by L2262 , NAT_1:10;
L2264: (for B975 being (Element of ( NAT )) holds ( C1082 . B975 ) c< ( C1082 . ( B975 + 1 ) ))
proof
let C1086 being (Element of ( NAT ));
consider C1087 being (Subset of C1070) such that L2265: C1087 = ( C1079 . C1086 ) and L2266: ( C1082 . C1086 ) = ( C1087 -Ideal ) by L2259;
consider C1088 being (Subset of C1070) such that L2267: C1088 = ( C1079 . ( C1086 + 1 ) ) and L2268: ( C1082 . ( C1086 + 1 ) ) = ( C1088 -Ideal ) by L2259;
L2269: C1088 in D344 by L2267;
L2270: (ex B976 being (Subset of C1070) st (B976 = C1088 & B976 is non  empty  finite non  empty  finite non  empty  finite non  empty  finite (Subset of C1071))) by L2269;
L2271: C1088 c= ( C1088 -Ideal ) by L2270 , L579;
consider C1089 being (Element of C1070) such that L2272: C1089 in ( C1071 \ ( C1087 -Ideal ) ) and L2273: C1088 = ( C1087 \/ { C1089 } ) by L2253 , L2265 , L2267;
L2274: C1087 in D344 by L2265;
L2275: (ex B977 being (Subset of C1070) st (B977 = C1087 & B977 is non  empty  finite non  empty  finite non  empty  finite non  empty  finite (Subset of C1071))) by L2274;
thus L2276: ( C1082 . C1086 ) c= ( C1082 . ( C1086 + 1 ) ) by L2275 , L2266 , L2268 , L2273 , L757 , XBOOLE_1:7;
L2277: C1089 in { C1089 } by TARSKI:def 1;
L2278: C1089 in C1088 by L2277 , L2273 , XBOOLE_0:def 3;
thus L2279: thesis by L2278 , L2266 , L2268 , L2272 , L2271 , XBOOLE_0:def 5;
end;
L2280: (for B978 being (Element of ( NAT )) holds (S28[ B978 ] implies S28[ ( B978 + 1 ) ]))
proof
let C1090 being (Element of ( NAT ));
assume that
L2281: ( C1082 . C1083 ) c= ( C1082 . ( ( C1083 + 1 ) + C1090 ) )
and
L2282: ( C1082 . C1083 ) <> ( C1082 . ( ( C1083 + 1 ) + C1090 ) );
L2283: ( C1082 . ( ( C1083 + 1 ) + C1090 ) ) c< ( C1082 . ( ( ( C1083 + 1 ) + C1090 ) + 1 ) ) by L2264;
L2284: ( C1082 . ( ( C1083 + 1 ) + C1090 ) ) c= ( C1082 . ( ( ( C1083 + 1 ) + C1090 ) + 1 ) ) by L2283 , XBOOLE_0:def 8;
thus L2285: ( C1082 . C1083 ) c= ( C1082 . ( ( C1083 + 1 ) + ( C1090 + 1 ) ) ) by L2284 , L2281 , XBOOLE_1:1;
thus L2286: thesis by L2281 , L2283 , XBOOLE_0:def 8;
end;
L2287: S28[ ( 0 ) ] by L2264;
L2288: (for B979 being (Element of ( NAT )) holds S28[ B979 ]) from NAT_1:sch 1(L2287 , L2280);
L2289: C1085 in ( NAT ) by ORDINAL1:def 12;
thus L2290: thesis by L2289 , L2288 , L2263;
end;
L2291: (for B980 being (Element of ( NAT )) holds ( C1082 . B980 ) is (Ideal of C1070))
proof
let C1091 being (Element of ( NAT ));
L2292: (ex B981 being (Subset of C1070) st (B981 = ( C1079 . C1091 ) & ( C1082 . C1091 ) = ( B981 -Ideal ))) by L2259;
thus L2293: thesis by L2292;
end;
thus L2294: contradiction by L2291 , L2227 , L2260;
end;
