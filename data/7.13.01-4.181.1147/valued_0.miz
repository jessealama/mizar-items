:: Number-Valued Functions
::  by Library Committee
::
:: Received November 22, 2007
:: Copyright (c) 2007-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, RELAT_1, TARSKI, XBOOLE_0, FUNCT_1, MEMBERED, SUBSET_1,
      XCMPLX_0, XXREAL_0, XREAL_0, RAT_1, INT_1, ORDINAL1, FUNCOP_1, FUNCT_4,
      ZFMISC_1, ORDINAL2, ARYTM_3, NAT_1, PARTFUN1, FUNCT_2, SETFAM_1, CARD_1,
      VALUED_0, PBOOLE;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, PBOOLE,
      ORDINAL1, SETFAM_1, RELSET_1, PARTFUN1, FUNCT_2, FUNCOP_1, FUNCT_4,
      NUMBERS, MEMBERED, XCMPLX_0, XREAL_0, XXREAL_0, RAT_1, NAT_1, INT_1;
 constructors XCMPLX_0, RAT_1, MEMBERED, FUNCOP_1, FUNCT_4, XXREAL_0, PARTFUN1,
      NAT_1, SETFAM_1, RELSET_1;
 registrations MEMBERED, RELAT_1, FUNCOP_1, XREAL_0, RAT_1, ORDINAL1, INT_1,
      FUNCT_1, XBOOLE_0, ZFMISC_1, RELSET_1, FUNCT_2, SETFAM_1, SUBSET_1,
      PBOOLE;
 requirements SUBSET, BOOLE, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, FUNCOP_1, ZFMISC_1, FUNCT_1, RELAT_1, PARTFUN2,
      FUNCT_2;
 theorems NUMBERS, XBOOLE_1, RELAT_1, MEMBERED, FUNCT_1, XCMPLX_0, XXREAL_0,
      XREAL_0, RAT_1, INT_1, ORDINAL1, FUNCT_4, FUNCOP_1, XBOOLE_0, ZFMISC_1,
      FUNCT_2, NAT_1, XREAL_1, RELSET_1, SETFAM_1, PARTFUN2, PARTFUN1,
      SUBSET_1;
 schemes NAT_1;

begin
definition
let C1 being Relation;
attr C1 is  complex-valued
means
:L1: ( rng C1 ) c= ( COMPLEX );
attr C1 is  ext-real-valued
means
:L2: ( rng C1 ) c= ( ExtREAL );
attr C1 is  real-valued
means
:L3: ( rng C1 ) c= ( REAL );
canceled 2;
attr C1 is  natural-valued
means
:L4: ( rng C1 ) c= ( NAT );
end;
registration
cluster  natural-valued -> ( INT ) -valued for Relation;
coherence
proof
let C2 being Relation;
assume L6: ( rng C2 ) c= ( NAT );
thus L7: ( rng C2 ) c= ( INT ) by L6 , NUMBERS:17 , XBOOLE_1:1;
end;
cluster ( INT ) -valued -> ( RAT ) -valued for Relation;
coherence
proof
let C3 being Relation;
assume L8: ( rng C3 ) c= ( INT );
thus L9: ( rng C3 ) c= ( RAT ) by L8 , NUMBERS:14 , XBOOLE_1:1;
end;
cluster ( INT ) -valued ->  real-valued for Relation;
coherence
proof
let C4 being Relation;
assume L10: ( rng C4 ) c= ( INT );
thus L11: ( rng C4 ) c= ( REAL ) by L10 , XBOOLE_1:1 , NUMBERS:15;
end;
cluster ( RAT ) -valued ->  real-valued for Relation;
coherence
proof
let C5 being Relation;
assume L12: ( rng C5 ) c= ( RAT );
thus L13: ( rng C5 ) c= ( REAL ) by L12 , NUMBERS:12 , XBOOLE_1:1;
end;
cluster  real-valued ->  ext-real-valued for Relation;
coherence
proof
let C6 being Relation;
assume L14: ( rng C6 ) c= ( REAL );
thus L15: ( rng C6 ) c= ( ExtREAL ) by L14 , NUMBERS:31 , XBOOLE_1:1;
end;
cluster  real-valued ->  complex-valued for Relation;
coherence
proof
let C7 being Relation;
assume L16: ( rng C7 ) c= ( REAL );
thus L17: ( rng C7 ) c= ( COMPLEX ) by L16 , NUMBERS:11 , XBOOLE_1:1;
end;
cluster  natural-valued -> ( RAT ) -valued for Relation;
coherence
proof
let C8 being Relation;
assume L18: ( rng C8 ) c= ( NAT );
thus L19: ( rng C8 ) c= ( RAT ) by L18 , NUMBERS:18 , XBOOLE_1:1;
end;
cluster  natural-valued ->  real-valued for Relation;
coherence
proof
let C9 being Relation;
assume L20: ( rng C9 ) c= ( NAT );
thus L21: ( rng C9 ) c= ( REAL ) by L20 , XBOOLE_1:1;
end;
end;
registration
cluster  empty ->  natural-valued for Relation;
coherence
proof
let C10 being Relation;
assume L23: C10 is  empty;
thus L24: ( rng C10 ) c= ( NAT ) by L23 , RELAT_1:38 , XBOOLE_1:2;
end;
end;
registration
cluster  natural-valued for Function;
existence
proof
take ( {} );
thus L26: thesis;
end;
end;
registration
let C11 being  complex-valued Relation;
cluster ( rng C11 ) ->  complex-membered;
coherence
proof
L28: ( rng C11 ) c= ( COMPLEX ) by L1;
thus L29: thesis by L28;
end;
end;
registration
let C12 being  ext-real-valued Relation;
cluster ( rng C12 ) ->  ext-real-membered;
coherence
proof
L31: ( rng C12 ) c= ( ExtREAL ) by L2;
thus L32: thesis by L31;
end;
end;
registration
let C13 being  real-valued Relation;
cluster ( rng C13 ) ->  real-membered;
coherence
proof
L34: ( rng C13 ) c= ( REAL ) by L3;
thus L35: thesis by L34;
end;
end;
registration
let C14 being ( RAT ) -valued Relation;
cluster ( rng C14 ) ->  rational-membered;
coherence;
end;
registration
let C15 being ( INT ) -valued Relation;
cluster ( rng C15 ) ->  integer-membered;
coherence;
end;
registration
let C16 being  natural-valued Relation;
cluster ( rng C16 ) ->  natural-membered;
coherence
proof
L39: ( rng C16 ) c= ( NAT ) by L4;
thus L40: thesis by L39;
end;
end;
theorem
L42: (for R5 being Relation holds (for B1 being  complex-valued Relation holds (R5 c= B1 implies R5 is  complex-valued)))
proof
let R5 being Relation;
let C17 being  complex-valued Relation;
assume L43: R5 c= C17;
L44: ( rng R5 ) c= ( rng C17 ) by L43 , RELAT_1:11;
L45: ( rng C17 ) c= ( COMPLEX ) by L1;
thus L46: ( rng R5 ) c= ( COMPLEX ) by L45 , L44 , XBOOLE_1:1;
end;
theorem
L47: (for R5 being Relation holds (for B2 being  ext-real-valued Relation holds (R5 c= B2 implies R5 is  ext-real-valued)))
proof
let R5 being Relation;
let C18 being  ext-real-valued Relation;
assume L48: R5 c= C18;
L49: ( rng R5 ) c= ( rng C18 ) by L48 , RELAT_1:11;
L50: ( rng C18 ) c= ( ExtREAL ) by L2;
thus L51: ( rng R5 ) c= ( ExtREAL ) by L50 , L49 , XBOOLE_1:1;
end;
theorem
L52: (for R5 being Relation holds (for B3 being  real-valued Relation holds (R5 c= B3 implies R5 is  real-valued)))
proof
let R5 being Relation;
let C19 being  real-valued Relation;
assume L53: R5 c= C19;
L54: ( rng R5 ) c= ( rng C19 ) by L53 , RELAT_1:11;
L55: ( rng C19 ) c= ( REAL ) by L3;
thus L56: ( rng R5 ) c= ( REAL ) by L55 , L54 , XBOOLE_1:1;
end;
theorem
L57: (for R5 being Relation holds (for B4 being ( RAT ) -valued Relation holds (R5 c= B4 implies R5 is ( RAT ) -valued)));
theorem
L58: (for R5 being Relation holds (for B5 being ( INT ) -valued Relation holds (R5 c= B5 implies R5 is ( INT ) -valued)));
theorem
L59: (for R5 being Relation holds (for B6 being  natural-valued Relation holds (R5 c= B6 implies R5 is  natural-valued)))
proof
let R5 being Relation;
let C20 being  natural-valued Relation;
assume L60: R5 c= C20;
L61: ( rng R5 ) c= ( rng C20 ) by L60 , RELAT_1:11;
L62: ( rng C20 ) c= ( NAT ) by L4;
thus L63: ( rng R5 ) c= ( NAT ) by L62 , L61 , XBOOLE_1:1;
end;
registration
let C21 being  complex-valued Relation;
cluster  ->  complex-valued for (Subset of C21);
coherence by L42;
end;
registration
let C22 being  ext-real-valued Relation;
cluster  ->  ext-real-valued for (Subset of C22);
coherence by L47;
end;
registration
let C23 being  real-valued Relation;
cluster  ->  real-valued for (Subset of C23);
coherence by L52;
end;
registration
let C24 being ( RAT ) -valued Relation;
cluster  -> ( RAT ) -valued for (Subset of C24);
coherence;
end;
registration
let C25 being ( INT ) -valued Relation;
cluster  -> ( INT ) -valued for (Subset of C25);
coherence;
end;
registration
let C26 being  natural-valued Relation;
cluster  ->  natural-valued for (Subset of C26);
coherence by L59;
end;
registration
let C27 , C28 being  complex-valued Relation;
cluster ( C27 \/ C28 ) ->  complex-valued;
coherence
proof
L70: ( rng ( C27 \/ C28 ) ) = ( ( rng C27 ) \/ ( rng C28 ) ) by RELAT_1:12;
L71: (( rng C27 ) c= ( COMPLEX ) & ( rng C28 ) c= ( COMPLEX )) by L1;
thus L72: ( rng ( C27 \/ C28 ) ) c= ( COMPLEX ) by L71 , L70 , XBOOLE_1:8;
end;
end;
registration
let C29 , C30 being  ext-real-valued Relation;
cluster ( C29 \/ C30 ) ->  ext-real-valued;
coherence
proof
L74: ( rng ( C29 \/ C30 ) ) = ( ( rng C29 ) \/ ( rng C30 ) ) by RELAT_1:12;
L75: (( rng C29 ) c= ( ExtREAL ) & ( rng C30 ) c= ( ExtREAL )) by L2;
thus L76: ( rng ( C29 \/ C30 ) ) c= ( ExtREAL ) by L75 , L74 , XBOOLE_1:8;
end;
end;
registration
let C31 , C32 being  real-valued Relation;
cluster ( C31 \/ C32 ) ->  real-valued;
coherence
proof
L78: ( rng ( C31 \/ C32 ) ) = ( ( rng C31 ) \/ ( rng C32 ) ) by RELAT_1:12;
L79: (( rng C31 ) c= ( REAL ) & ( rng C32 ) c= ( REAL )) by L3;
thus L80: ( rng ( C31 \/ C32 ) ) c= ( REAL ) by L79 , L78 , XBOOLE_1:8;
end;
end;
registration
let C33 , C34 being ( RAT ) -valued Relation;
cluster ( C33 \/ C34 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C35 , C36 being ( INT ) -valued Relation;
cluster ( C35 \/ C36 ) -> ( INT ) -valued;
coherence;
end;
registration
let C37 , C38 being  natural-valued Relation;
cluster ( C37 \/ C38 ) ->  natural-valued;
coherence
proof
L84: ( rng ( C37 \/ C38 ) ) = ( ( rng C37 ) \/ ( rng C38 ) ) by RELAT_1:12;
L85: (( rng C37 ) c= ( NAT ) & ( rng C38 ) c= ( NAT )) by L4;
thus L86: ( rng ( C37 \/ C38 ) ) c= ( NAT ) by L85 , L84 , XBOOLE_1:8;
end;
end;
registration
let C39 being  complex-valued Relation;
let R6 being Relation;
cluster ( C39 /\ R6 ) ->  complex-valued;
coherence
proof
L88: ( C39 /\ R6 ) c= C39 by XBOOLE_1:17;
L89: ( rng ( C39 /\ R6 ) ) c= ( rng C39 ) by L88 , RELAT_1:11;
L90: ( rng C39 ) c= ( COMPLEX ) by L1;
thus L91: ( rng ( C39 /\ R6 ) ) c= ( COMPLEX ) by L90 , L89 , XBOOLE_1:1;
end;
cluster ( C39 \ R6 ) ->  complex-valued;
coherence;
end;
registration
let C40 being  ext-real-valued Relation;
let R6 being Relation;
cluster ( C40 /\ R6 ) ->  ext-real-valued;
coherence
proof
L93: ( C40 /\ R6 ) c= C40 by XBOOLE_1:17;
L94: ( rng ( C40 /\ R6 ) ) c= ( rng C40 ) by L93 , RELAT_1:11;
L95: ( rng C40 ) c= ( ExtREAL ) by L2;
thus L96: ( rng ( C40 /\ R6 ) ) c= ( ExtREAL ) by L95 , L94 , XBOOLE_1:1;
end;
cluster ( C40 \ R6 ) ->  ext-real-valued;
coherence;
end;
registration
let C41 being  real-valued Relation;
let R6 being Relation;
cluster ( C41 /\ R6 ) ->  real-valued;
coherence
proof
L98: ( C41 /\ R6 ) c= C41 by XBOOLE_1:17;
L99: ( rng ( C41 /\ R6 ) ) c= ( rng C41 ) by L98 , RELAT_1:11;
L100: ( rng C41 ) c= ( REAL ) by L3;
thus L101: ( rng ( C41 /\ R6 ) ) c= ( REAL ) by L100 , L99 , XBOOLE_1:1;
end;
cluster ( C41 \ R6 ) ->  real-valued;
coherence;
end;
registration
let C42 being ( RAT ) -valued Relation;
let R6 being Relation;
cluster ( C42 /\ R6 ) -> ( RAT ) -valued;
coherence;
cluster ( C42 \ R6 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C43 being ( INT ) -valued Relation;
let R6 being Relation;
cluster ( C43 /\ R6 ) -> ( INT ) -valued;
coherence;
cluster ( C43 \ R6 ) -> ( INT ) -valued;
coherence;
end;
registration
let C44 being  natural-valued Relation;
let R6 being Relation;
cluster ( C44 /\ R6 ) ->  natural-valued;
coherence
proof
L105: ( C44 /\ R6 ) c= C44 by XBOOLE_1:17;
L106: ( rng ( C44 /\ R6 ) ) c= ( rng C44 ) by L105 , RELAT_1:11;
L107: ( rng C44 ) c= ( NAT ) by L4;
thus L108: ( rng ( C44 /\ R6 ) ) c= ( NAT ) by L107 , L106 , XBOOLE_1:1;
end;
cluster ( C44 \ R6 ) ->  natural-valued;
coherence;
end;
registration
let C45 , C46 being  complex-valued Relation;
cluster ( C45 \+\ C46 ) ->  complex-valued;
coherence;
end;
registration
let C47 , C48 being  ext-real-valued Relation;
cluster ( C47 \+\ C48 ) ->  ext-real-valued;
coherence;
end;
registration
let C49 , C50 being  real-valued Relation;
cluster ( C49 \+\ C50 ) ->  real-valued;
coherence;
end;
registration
let C51 , C52 being ( RAT ) -valued Relation;
cluster ( C51 \+\ C52 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C53 , C54 being ( INT ) -valued Relation;
cluster ( C53 \+\ C54 ) -> ( INT ) -valued;
coherence;
end;
registration
let C55 , C56 being  natural-valued Relation;
cluster ( C55 \+\ C56 ) ->  natural-valued;
coherence;
end;
registration
let C57 being  complex-valued Relation;
let R3 being set;
cluster ( C57 .: R3 ) ->  complex-membered;
coherence
proof
L116: ( C57 .: R3 ) c= ( rng C57 ) by RELAT_1:111;
thus L117: thesis by L116;
end;
end;
registration
let C58 being  ext-real-valued Relation;
let R3 being set;
cluster ( C58 .: R3 ) ->  ext-real-membered;
coherence
proof
L119: ( C58 .: R3 ) c= ( rng C58 ) by RELAT_1:111;
thus L120: thesis by L119;
end;
end;
registration
let C59 being  real-valued Relation;
let R3 being set;
cluster ( C59 .: R3 ) ->  real-membered;
coherence
proof
L122: ( C59 .: R3 ) c= ( rng C59 ) by RELAT_1:111;
thus L123: thesis by L122;
end;
end;
registration
let C60 being ( RAT ) -valued Relation;
let R3 being set;
cluster ( C60 .: R3 ) ->  rational-membered;
coherence
proof
L125: ( C60 .: R3 ) c= ( rng C60 ) by RELAT_1:111;
thus L126: thesis by L125;
end;
end;
registration
let C61 being ( INT ) -valued Relation;
let R3 being set;
cluster ( C61 .: R3 ) ->  integer-membered;
coherence
proof
L128: ( C61 .: R3 ) c= ( rng C61 ) by RELAT_1:111;
thus L129: thesis by L128;
end;
end;
registration
let C62 being  natural-valued Relation;
let R3 being set;
cluster ( C62 .: R3 ) ->  natural-membered;
coherence
proof
L131: ( C62 .: R3 ) c= ( rng C62 ) by RELAT_1:111;
thus L132: thesis by L131;
end;
end;
registration
let C63 being  complex-valued Relation;
let R1 being set;
cluster ( Im (C63 , R1) ) ->  complex-membered;
coherence;
end;
registration
let C64 being  ext-real-valued Relation;
let R1 being set;
cluster ( Im (C64 , R1) ) ->  ext-real-membered;
coherence;
end;
registration
let C65 being  real-valued Relation;
let R1 being set;
cluster ( Im (C65 , R1) ) ->  real-membered;
coherence;
end;
registration
let C66 being ( RAT ) -valued Relation;
let R1 being set;
cluster ( Im (C66 , R1) ) ->  rational-membered;
coherence;
end;
registration
let C67 being ( INT ) -valued Relation;
let R1 being set;
cluster ( Im (C67 , R1) ) ->  integer-membered;
coherence;
end;
registration
let C68 being  natural-valued Relation;
let R1 being set;
cluster ( Im (C68 , R1) ) ->  natural-membered;
coherence;
end;
registration
let C69 being  complex-valued Relation;
let R3 being set;
cluster ( C69 | R3 ) ->  complex-valued;
coherence
proof
L140: (( rng C69 ) c= ( COMPLEX ) & ( rng ( C69 | R3 ) ) c= ( rng C69 )) by L1 , RELAT_1:70;
thus L141: ( rng ( C69 | R3 ) ) c= ( COMPLEX ) by L140 , XBOOLE_1:1;
end;
end;
registration
let C70 being  ext-real-valued Relation;
let R3 being set;
cluster ( C70 | R3 ) ->  ext-real-valued;
coherence
proof
L143: (( rng C70 ) c= ( ExtREAL ) & ( rng ( C70 | R3 ) ) c= ( rng C70 )) by L2 , RELAT_1:70;
thus L144: ( rng ( C70 | R3 ) ) c= ( ExtREAL ) by L143 , XBOOLE_1:1;
end;
end;
registration
let C71 being  real-valued Relation;
let R3 being set;
cluster ( C71 | R3 ) ->  real-valued;
coherence
proof
L146: (( rng C71 ) c= ( REAL ) & ( rng ( C71 | R3 ) ) c= ( rng C71 )) by L3 , RELAT_1:70;
thus L147: ( rng ( C71 | R3 ) ) c= ( REAL ) by L146 , XBOOLE_1:1;
end;
end;
registration
let C72 being ( RAT ) -valued Relation;
let R3 being set;
cluster ( C72 | R3 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C73 being ( INT ) -valued Relation;
let R3 being set;
cluster ( C73 | R3 ) -> ( INT ) -valued;
coherence;
end;
registration
let C74 being  natural-valued Relation;
let R3 being set;
cluster ( C74 | R3 ) ->  natural-valued;
coherence
proof
L151: (( rng C74 ) c= ( NAT ) & ( rng ( C74 | R3 ) ) c= ( rng C74 )) by L4 , RELAT_1:70;
thus L152: ( rng ( C74 | R3 ) ) c= ( NAT ) by L151 , XBOOLE_1:1;
end;
end;
registration
let C75 being  complex-membered set;
cluster ( id C75 ) ->  complex-valued;
coherence
proof
thus L154: ( rng ( id C75 ) ) c= ( COMPLEX ) by MEMBERED:1;
end;
end;
registration
let C76 being  ext-real-membered set;
cluster ( id C76 ) ->  ext-real-valued;
coherence
proof
thus L156: ( rng ( id C76 ) ) c= ( ExtREAL ) by MEMBERED:2;
end;
end;
registration
let C77 being  real-membered set;
cluster ( id C77 ) ->  real-valued;
coherence
proof
thus L158: ( rng ( id C77 ) ) c= ( REAL ) by MEMBERED:3;
end;
end;
registration
let C78 being  rational-membered set;
cluster ( id C78 ) -> ( RAT ) -valued;
coherence
proof
thus L160: ( rng ( id C78 ) ) c= ( RAT ) by MEMBERED:4;
end;
end;
registration
let C79 being  integer-membered set;
cluster ( id C79 ) -> ( INT ) -valued;
coherence
proof
thus L162: ( rng ( id C79 ) ) c= ( INT ) by MEMBERED:5;
end;
end;
registration
let C80 being  natural-membered set;
cluster ( id C80 ) ->  natural-valued;
coherence
proof
thus L164: ( rng ( id C80 ) ) c= ( NAT ) by MEMBERED:6;
end;
end;
registration
let R5 being Relation;
let C81 being  complex-valued Relation;
cluster ( R5 * C81 ) ->  complex-valued;
coherence
proof
L166: (( rng C81 ) c= ( COMPLEX ) & ( rng ( R5 * C81 ) ) c= ( rng C81 )) by L1 , RELAT_1:26;
thus L167: ( rng ( R5 * C81 ) ) c= ( COMPLEX ) by L166 , XBOOLE_1:1;
end;
end;
registration
let R5 being Relation;
let C82 being  ext-real-valued Relation;
cluster ( R5 * C82 ) ->  ext-real-valued;
coherence
proof
L169: (( rng C82 ) c= ( ExtREAL ) & ( rng ( R5 * C82 ) ) c= ( rng C82 )) by L2 , RELAT_1:26;
thus L170: ( rng ( R5 * C82 ) ) c= ( ExtREAL ) by L169 , XBOOLE_1:1;
end;
end;
registration
let R5 being Relation;
let C83 being  real-valued Relation;
cluster ( R5 * C83 ) ->  real-valued;
coherence
proof
L172: (( rng C83 ) c= ( REAL ) & ( rng ( R5 * C83 ) ) c= ( rng C83 )) by L3 , RELAT_1:26;
thus L173: ( rng ( R5 * C83 ) ) c= ( REAL ) by L172 , XBOOLE_1:1;
end;
end;
registration
let R5 being Relation;
let C84 being ( RAT ) -valued Relation;
cluster ( R5 * C84 ) -> ( RAT ) -valued;
coherence;
end;
registration
let R5 being Relation;
let C85 being ( INT ) -valued Relation;
cluster ( R5 * C85 ) -> ( INT ) -valued;
coherence;
end;
registration
let R5 being Relation;
let C86 being  natural-valued Relation;
cluster ( R5 * C86 ) ->  natural-valued;
coherence
proof
L177: (( rng C86 ) c= ( NAT ) & ( rng ( R5 * C86 ) ) c= ( rng C86 )) by L4 , RELAT_1:26;
thus L178: ( rng ( R5 * C86 ) ) c= ( NAT ) by L177 , XBOOLE_1:1;
end;
end;
definition
let C87 being Function;
redefine attr C87 is  complex-valued
means
:L180: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  complex));
compatibility
proof
thus L181: (C87 is  complex-valued implies (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  complex)))
proof
assume L182: C87 is  complex-valued;
let R1 being set;
assume L183: R1 in ( dom C87 );
reconsider D1 = C87 as  complex-valued Function by L182;
L184: ( D1 . R1 ) in ( rng D1 ) by L183 , FUNCT_1:3;
thus L185: thesis by L184;
end;

assume L186: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  complex));
let R2 being set;
assume L187: R2 in ( rng C87 );
L188: (ex R1 being set st (R1 in ( dom C87 ) & R2 = ( C87 . R1 ))) by L187 , FUNCT_1:def 3;
L189: R2 is  complex by L188 , L186;
thus L190: thesis by L189 , XCMPLX_0:def 2;
end;
redefine attr C87 is  ext-real-valued
means
:L191: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  ext-real));
compatibility
proof
thus L192: (C87 is  ext-real-valued implies (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  ext-real)))
proof
assume L193: C87 is  ext-real-valued;
let R1 being set;
assume L194: R1 in ( dom C87 );
reconsider D2 = C87 as  ext-real-valued Function by L193;
L195: ( D2 . R1 ) in ( rng D2 ) by L194 , FUNCT_1:3;
thus L196: thesis by L195;
end;

assume L197: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  ext-real));
let R2 being set;
assume L198: R2 in ( rng C87 );
L199: (ex R1 being set st (R1 in ( dom C87 ) & R2 = ( C87 . R1 ))) by L198 , FUNCT_1:def 3;
L200: R2 is  ext-real by L199 , L197;
thus L201: thesis by L200 , XXREAL_0:def 1;
end;
redefine attr C87 is  real-valued
means
:L202: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  real));
compatibility
proof
thus L203: (C87 is  real-valued implies (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  real)))
proof
assume L204: C87 is  real-valued;
let R1 being set;
assume L205: R1 in ( dom C87 );
reconsider D3 = C87 as  real-valued Function by L204;
L206: ( D3 . R1 ) in ( rng D3 ) by L205 , FUNCT_1:3;
thus L207: thesis by L206;
end;

assume L208: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  real));
let R2 being set;
assume L209: R2 in ( rng C87 );
L210: (ex R1 being set st (R1 in ( dom C87 ) & R2 = ( C87 . R1 ))) by L209 , FUNCT_1:def 3;
L211: R2 is  real by L210 , L208;
thus L212: thesis by L211 , XREAL_0:def 1;
end;
canceled 2;
redefine attr C87 is  natural-valued
means
:L213: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  natural));
compatibility
proof
thus L214: (C87 is  natural-valued implies (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  natural)))
proof
assume L215: C87 is  natural-valued;
let R1 being set;
assume L216: R1 in ( dom C87 );
reconsider D4 = C87 as  natural-valued Function by L215;
L217: ( D4 . R1 ) in ( rng D4 ) by L216 , FUNCT_1:3;
thus L218: thesis by L217;
end;

assume L219: (for R1 being set holds (R1 in ( dom C87 ) implies ( C87 . R1 ) is  natural));
let R2 being set;
assume L220: R2 in ( rng C87 );
L221: (ex R1 being set st (R1 in ( dom C87 ) & R2 = ( C87 . R1 ))) by L220 , FUNCT_1:def 3;
L222: R2 is  natural by L221 , L219;
thus L223: thesis by L222 , ORDINAL1:def 12;
end;
end;
theorem
L225: (for R4 being Function holds (R4 is  complex-valued iff (for R1 being set holds ( R4 . R1 ) is  complex)))
proof
let R4 being Function;
thus L226:now
assume L227: R4 is  complex-valued;
let R1 being set;
per cases ;
suppose L228: R1 in ( dom R4 );

thus L229: ( R4 . R1 ) is  complex by L228 , L227 , L180;
end;
suppose L230: (not R1 in ( dom R4 ));

thus L231: ( R4 . R1 ) is  complex by L230 , FUNCT_1:def 2;
end;
end;
assume L233: (for R1 being set holds ( R4 . R1 ) is  complex);
L234: (for R1 being set holds (R1 in ( dom R4 ) implies ( R4 . R1 ) is  complex)) by L233;
thus L235: thesis by L234 , L180;
end;
theorem
L236: (for R4 being Function holds (R4 is  ext-real-valued iff (for R1 being set holds ( R4 . R1 ) is  ext-real)))
proof
let R4 being Function;
thus L237:now
assume L238: R4 is  ext-real-valued;
let R1 being set;
per cases ;
suppose L239: R1 in ( dom R4 );

thus L240: ( R4 . R1 ) is  ext-real by L239 , L238 , L191;
end;
suppose L241: (not R1 in ( dom R4 ));

thus L242: ( R4 . R1 ) is  ext-real by L241 , FUNCT_1:def 2;
end;
end;
assume L244: (for R1 being set holds ( R4 . R1 ) is  ext-real);
L245: (for R1 being set holds (R1 in ( dom R4 ) implies ( R4 . R1 ) is  ext-real)) by L244;
thus L246: thesis by L245 , L191;
end;
theorem
L247: (for R4 being Function holds (R4 is  real-valued iff (for R1 being set holds ( R4 . R1 ) is  real)))
proof
let R4 being Function;
thus L248:now
assume L249: R4 is  real-valued;
let R1 being set;
per cases ;
suppose L250: R1 in ( dom R4 );

thus L251: ( R4 . R1 ) is  real by L250 , L249 , L202;
end;
suppose L252: (not R1 in ( dom R4 ));

thus L253: ( R4 . R1 ) is  real by L252 , FUNCT_1:def 2;
end;
end;
assume L255: (for R1 being set holds ( R4 . R1 ) is  real);
L256: (for R1 being set holds (R1 in ( dom R4 ) implies ( R4 . R1 ) is  real)) by L255;
thus L257: thesis by L256 , L202;
end;
theorem
L258: (for R4 being Function holds (R4 is ( RAT ) -valued iff (for R1 being set holds ( R4 . R1 ) is  rational)))
proof
let R4 being Function;
thus L259:now
assume L260: R4 is ( RAT ) -valued;
let R1 being set;
per cases ;
suppose L261: R1 in ( dom R4 );

L262: ( R4 . R1 ) in ( rng R4 ) by L261 , FUNCT_1:def 3;
thus L263: ( R4 . R1 ) is  rational by L262 , L260;
end;
suppose L264: (not R1 in ( dom R4 ));

thus L265: ( R4 . R1 ) is  rational by L264 , FUNCT_1:def 2;
end;
end;
assume L267: (for R1 being set holds ( R4 . R1 ) is  rational);
let C88 being set;
assume L268: C88 in ( rng R4 );
consider R1 being set such that L269: R1 in ( dom R4 ) and L270: ( R4 . R1 ) = C88 by L268 , FUNCT_1:def 3;
L271: ( R4 . R1 ) is  rational by L267;
thus L272: thesis by L271 , L270 , RAT_1:def 2;
end;
theorem
L273: (for R4 being Function holds (R4 is ( INT ) -valued iff (for R1 being set holds ( R4 . R1 ) is  integer)))
proof
let R4 being Function;
thus L274:now
assume L275: R4 is ( INT ) -valued;
let R1 being set;
per cases ;
suppose L276: R1 in ( dom R4 );

L277: ( R4 . R1 ) in ( rng R4 ) by L276 , FUNCT_1:def 3;
thus L278: ( R4 . R1 ) is  integer by L277 , L275;
end;
suppose L279: (not R1 in ( dom R4 ));

thus L280: ( R4 . R1 ) is  integer by L279 , FUNCT_1:def 2;
end;
end;
assume L282: (for R1 being set holds ( R4 . R1 ) is  integer);
let C89 being set;
assume L283: C89 in ( rng R4 );
consider R1 being set such that L284: R1 in ( dom R4 ) and L285: ( R4 . R1 ) = C89 by L283 , FUNCT_1:def 3;
L286: ( R4 . R1 ) is  integer by L282;
thus L287: thesis by L286 , L285 , INT_1:def 2;
end;
theorem
L288: (for R4 being Function holds (R4 is  natural-valued iff (for R1 being set holds ( R4 . R1 ) is  natural)))
proof
let R4 being Function;
thus L289:now
assume L290: R4 is  natural-valued;
let R1 being set;
per cases ;
suppose L291: R1 in ( dom R4 );

thus L292: ( R4 . R1 ) is  natural by L291 , L290 , L213;
end;
suppose L293: (not R1 in ( dom R4 ));

thus L294: ( R4 . R1 ) is  natural by L293 , FUNCT_1:def 2;
end;
end;
assume L296: (for R1 being set holds ( R4 . R1 ) is  natural);
L297: (for R1 being set holds (R1 in ( dom R4 ) implies ( R4 . R1 ) is  natural)) by L296;
thus L298: thesis by L297 , L213;
end;
registration
let C90 being  complex-valued Function;
let R1 being set;
cluster ( C90 . R1 ) ->  complex;
coherence by L225;
end;
registration
let C91 being  ext-real-valued Function;
let R1 being set;
cluster ( C91 . R1 ) ->  ext-real;
coherence by L236;
end;
registration
let C92 being  real-valued Function;
let R1 being set;
cluster ( C92 . R1 ) ->  real;
coherence by L247;
end;
registration
let C93 being ( RAT ) -valued Function;
let R1 being set;
cluster ( C93 . R1 ) ->  rational;
coherence by L258;
end;
registration
let C94 being ( INT ) -valued Function;
let R1 being set;
cluster ( C94 . R1 ) ->  integer;
coherence by L273;
end;
registration
let C95 being  natural-valued Function;
let R1 being set;
cluster ( C95 . R1 ) ->  natural;
coherence by L288;
end;
registration
let R3 being set;
let C96 being  complex number;
cluster ( R3 --> C96 ) ->  complex-valued;
coherence
proof
L305: ( rng ( R3 --> C96 ) ) c= ( COMPLEX ) by MEMBERED:1;
thus L306: thesis by L305 , L1;
end;
end;
registration
let R3 being set;
let C97 being  ext-real number;
cluster ( R3 --> C97 ) ->  ext-real-valued;
coherence
proof
L308: ( rng ( R3 --> C97 ) ) c= ( ExtREAL ) by MEMBERED:2;
thus L309: thesis by L308 , L2;
end;
end;
registration
let R3 being set;
let C98 being  real number;
cluster ( R3 --> C98 ) ->  real-valued;
coherence
proof
L311: ( rng ( R3 --> C98 ) ) c= ( REAL ) by MEMBERED:3;
thus L312: thesis by L311 , L3;
end;
end;
registration
let R3 being set;
let C99 being  rational number;
cluster ( R3 --> C99 ) -> ( RAT ) -valued;
coherence
proof
L314: ( rng ( R3 --> C99 ) ) c= ( RAT ) by MEMBERED:4;
thus L315: thesis by L314 , RELAT_1:def 19;
end;
end;
registration
let R3 being set;
let C100 being  integer number;
cluster ( R3 --> C100 ) -> ( INT ) -valued;
coherence
proof
L317: ( rng ( R3 --> C100 ) ) c= ( INT ) by MEMBERED:5;
thus L318: thesis by L317 , RELAT_1:def 19;
end;
end;
registration
let R3 being set;
let C101 being Nat;
cluster ( R3 --> C101 ) ->  natural-valued;
coherence
proof
L320: ( rng ( R3 --> C101 ) ) c= ( NAT ) by MEMBERED:6;
thus L321: thesis by L320 , L4;
end;
end;
registration
let C102 , C103 being  complex-valued Function;
cluster ( C102 +* C103 ) ->  complex-valued;
coherence
proof
L323: ( rng ( C102 +* C103 ) ) c= ( ( rng C102 ) \/ ( rng C103 ) ) by FUNCT_4:17;
L324: ( rng ( C102 +* C103 ) ) c= ( COMPLEX ) by L323 , MEMBERED:1;
thus L325: thesis by L324 , L1;
end;
end;
registration
let C104 , C105 being  ext-real-valued Function;
cluster ( C104 +* C105 ) ->  ext-real-valued;
coherence
proof
L327: ( rng ( C104 +* C105 ) ) c= ( ( rng C104 ) \/ ( rng C105 ) ) by FUNCT_4:17;
L328: ( rng ( C104 +* C105 ) ) c= ( ExtREAL ) by L327 , MEMBERED:2;
thus L329: thesis by L328 , L2;
end;
end;
registration
let C106 , C107 being  real-valued Function;
cluster ( C106 +* C107 ) ->  real-valued;
coherence
proof
L331: ( rng ( C106 +* C107 ) ) c= ( ( rng C106 ) \/ ( rng C107 ) ) by FUNCT_4:17;
L332: ( rng ( C106 +* C107 ) ) c= ( REAL ) by L331 , MEMBERED:3;
thus L333: thesis by L332 , L3;
end;
end;
registration
let C108 , C109 being ( RAT ) -valued Function;
cluster ( C108 +* C109 ) -> ( RAT ) -valued;
coherence
proof
L335: ( rng ( C108 +* C109 ) ) c= ( ( rng C108 ) \/ ( rng C109 ) ) by FUNCT_4:17;
L336: ( rng ( C108 +* C109 ) ) c= ( RAT ) by L335 , MEMBERED:4;
thus L337: thesis by L336 , RELAT_1:def 19;
end;
end;
registration
let C110 , C111 being ( INT ) -valued Function;
cluster ( C110 +* C111 ) -> ( INT ) -valued;
coherence
proof
L339: ( rng ( C110 +* C111 ) ) c= ( ( rng C110 ) \/ ( rng C111 ) ) by FUNCT_4:17;
L340: ( rng ( C110 +* C111 ) ) c= ( INT ) by L339 , MEMBERED:5;
thus L341: thesis by L340 , RELAT_1:def 19;
end;
end;
registration
let C112 , C113 being  natural-valued Function;
cluster ( C112 +* C113 ) ->  natural-valued;
coherence
proof
L343: ( rng ( C112 +* C113 ) ) c= ( ( rng C112 ) \/ ( rng C113 ) ) by FUNCT_4:17;
L344: ( rng ( C112 +* C113 ) ) c= ( NAT ) by L343 , MEMBERED:6;
thus L345: thesis by L344 , L4;
end;
end;
registration
let R1 being set;
let C114 being  complex number;
cluster ( R1 .--> C114 ) ->  complex-valued;
coherence;
end;
registration
let R1 being set;
let C115 being  ext-real number;
cluster ( R1 .--> C115 ) ->  ext-real-valued;
coherence;
end;
registration
let R1 being set;
let C116 being  real number;
cluster ( R1 .--> C116 ) ->  real-valued;
coherence;
end;
registration
let R1 being set;
let C117 being  rational number;
cluster ( R1 .--> C117 ) -> ( RAT ) -valued;
coherence;
end;
registration
let R1 being set;
let C118 being  integer number;
cluster ( R1 .--> C118 ) -> ( INT ) -valued;
coherence;
end;
registration
let R1 being set;
let C119 being Nat;
cluster ( R1 .--> C119 ) ->  natural-valued;
coherence;
end;
registration
let R3 being set;
let C120 being  complex-membered set;
cluster  ->  complex-valued for (Relation of R3 , C120);
coherence
proof
let C121 being (Relation of R3 , C120);
thus L353: ( rng C121 ) c= ( COMPLEX ) by MEMBERED:1;
end;
end;
registration
let R3 being set;
let C122 being  ext-real-membered set;
cluster  ->  ext-real-valued for (Relation of R3 , C122);
coherence
proof
let C123 being (Relation of R3 , C122);
thus L355: ( rng C123 ) c= ( ExtREAL ) by MEMBERED:2;
end;
end;
registration
let R3 being set;
let C124 being  real-membered set;
cluster  ->  real-valued for (Relation of R3 , C124);
coherence
proof
let C125 being (Relation of R3 , C124);
thus L357: ( rng C125 ) c= ( REAL ) by MEMBERED:3;
end;
end;
registration
let R3 being set;
let C126 being  rational-membered set;
cluster  -> ( RAT ) -valued for (Relation of R3 , C126);
coherence
proof
let C127 being (Relation of R3 , C126);
thus L359: ( rng C127 ) c= ( RAT ) by MEMBERED:4;
end;
end;
registration
let R3 being set;
let C128 being  integer-membered set;
cluster  -> ( INT ) -valued for (Relation of R3 , C128);
coherence
proof
let C129 being (Relation of R3 , C128);
thus L361: ( rng C129 ) c= ( INT ) by MEMBERED:5;
end;
end;
registration
let R3 being set;
let C130 being  natural-membered set;
cluster  ->  natural-valued for (Relation of R3 , C130);
coherence
proof
let C131 being (Relation of R3 , C130);
thus L363: ( rng C131 ) c= ( NAT ) by MEMBERED:6;
end;
end;
registration
let R3 being set;
let C132 being  complex-membered set;
cluster [: R3 , C132 :] ->  complex-valued;
coherence
proof
L365: ( rng [: R3 , C132 :] ) c= C132 by RELAT_1:159;
thus L366: ( rng [: R3 , C132 :] ) c= ( COMPLEX ) by L365 , MEMBERED:1;
end;
end;
registration
let R3 being set;
let C133 being  ext-real-membered set;
cluster [: R3 , C133 :] ->  ext-real-valued;
coherence
proof
L368: ( rng [: R3 , C133 :] ) c= C133 by RELAT_1:159;
thus L369: ( rng [: R3 , C133 :] ) c= ( ExtREAL ) by L368 , MEMBERED:2;
end;
end;
registration
let R3 being set;
let C134 being  real-membered set;
cluster [: R3 , C134 :] ->  real-valued;
coherence
proof
L371: ( rng [: R3 , C134 :] ) c= C134 by RELAT_1:159;
thus L372: ( rng [: R3 , C134 :] ) c= ( REAL ) by L371 , MEMBERED:3;
end;
end;
registration
let R3 being set;
let C135 being  rational-membered set;
cluster [: R3 , C135 :] -> ( RAT ) -valued;
coherence
proof
L374: ( rng [: R3 , C135 :] ) c= C135 by RELAT_1:159;
thus L375: ( rng [: R3 , C135 :] ) c= ( RAT ) by L374 , MEMBERED:4;
end;
end;
registration
let R3 being set;
let C136 being  integer-membered set;
cluster [: R3 , C136 :] -> ( INT ) -valued;
coherence
proof
L377: ( rng [: R3 , C136 :] ) c= C136 by RELAT_1:159;
thus L378: ( rng [: R3 , C136 :] ) c= ( INT ) by L377 , MEMBERED:5;
end;
end;
registration
let R3 being set;
let C137 being  natural-membered set;
cluster [: R3 , C137 :] ->  natural-valued;
coherence
proof
L380: ( rng [: R3 , C137 :] ) c= C137 by RELAT_1:159;
thus L381: ( rng [: R3 , C137 :] ) c= ( NAT ) by L380 , MEMBERED:6;
end;
end;
notation
let C138 being  ext-real-valued Relation;
synonym C138 is  non-zero for C138 is  non-empty;
end;
registration
cluster non  empty  constant  natural-valued ( INT ) -valued ( RAT ) -valued for Function;
existence
proof
take ( 1 .--> 1 );
thus L384: thesis;
end;
end;
theorem
L386: (for B7 being non  empty  constant  complex-valued Function holds (ex B8 being  complex number st (for R1 being set holds (R1 in ( dom B7 ) implies ( B7 . R1 ) = B8))))
proof
let C139 being non  empty  constant  complex-valued Function;
consider C140 being set such that L387: (for R1 being set holds (R1 in ( dom C139 ) implies ( C139 . R1 ) = C140)) by FUNCOP_1:78;
consider C141 being set such that L388: C141 in ( dom C139 ) by XBOOLE_0:def 1;
L389: C140 = ( C139 . C141 ) by L387 , L388;
thus L390: thesis by L389 , L387;
end;
theorem
L391: (for B9 being non  empty  constant  ext-real-valued Function holds (ex B10 being  ext-real number st (for R1 being set holds (R1 in ( dom B9 ) implies ( B9 . R1 ) = B10))))
proof
let C142 being non  empty  constant  ext-real-valued Function;
consider C143 being set such that L392: (for R1 being set holds (R1 in ( dom C142 ) implies ( C142 . R1 ) = C143)) by FUNCOP_1:78;
consider C144 being set such that L393: C144 in ( dom C142 ) by XBOOLE_0:def 1;
L394: C143 = ( C142 . C144 ) by L392 , L393;
thus L395: thesis by L394 , L392;
end;
theorem
L396: (for B11 being non  empty  constant  real-valued Function holds (ex B12 being  real number st (for R1 being set holds (R1 in ( dom B11 ) implies ( B11 . R1 ) = B12))))
proof
let C145 being non  empty  constant  real-valued Function;
consider C146 being set such that L397: (for R1 being set holds (R1 in ( dom C145 ) implies ( C145 . R1 ) = C146)) by FUNCOP_1:78;
consider C147 being set such that L398: C147 in ( dom C145 ) by XBOOLE_0:def 1;
L399: C146 = ( C145 . C147 ) by L397 , L398;
thus L400: thesis by L399 , L397;
end;
theorem
L401: (for B13 being non  empty  constant ( RAT ) -valued Function holds (ex B14 being  rational number st (for R1 being set holds (R1 in ( dom B13 ) implies ( B13 . R1 ) = B14))))
proof
let C148 being non  empty  constant ( RAT ) -valued Function;
consider C149 being set such that L402: (for R1 being set holds (R1 in ( dom C148 ) implies ( C148 . R1 ) = C149)) by FUNCOP_1:78;
consider C150 being set such that L403: C150 in ( dom C148 ) by XBOOLE_0:def 1;
L404: C149 = ( C148 . C150 ) by L402 , L403;
thus L405: thesis by L404 , L402;
end;
theorem
L406: (for B15 being non  empty  constant ( INT ) -valued Function holds (ex B16 being  integer number st (for R1 being set holds (R1 in ( dom B15 ) implies ( B15 . R1 ) = B16))))
proof
let C151 being non  empty  constant ( INT ) -valued Function;
consider C152 being set such that L407: (for R1 being set holds (R1 in ( dom C151 ) implies ( C151 . R1 ) = C152)) by FUNCOP_1:78;
consider C153 being set such that L408: C153 in ( dom C151 ) by XBOOLE_0:def 1;
L409: C152 = ( C151 . C153 ) by L407 , L408;
thus L410: thesis by L409 , L407;
end;
theorem
L411: (for B17 being non  empty  constant  natural-valued Function holds (ex B18 being Nat st (for R1 being set holds (R1 in ( dom B17 ) implies ( B17 . R1 ) = B18))))
proof
let C154 being non  empty  constant  natural-valued Function;
consider C155 being set such that L412: (for R1 being set holds (R1 in ( dom C154 ) implies ( C154 . R1 ) = C155)) by FUNCOP_1:78;
consider C156 being set such that L413: C156 in ( dom C154 ) by XBOOLE_0:def 1;
L414: C155 = ( C154 . C156 ) by L412 , L413;
thus L415: thesis by L414 , L412;
end;
begin
definition
let C157 being  ext-real-valued Function;
attr C157 is  increasing
means
:L416: (for R7 being  ext-real number holds (for R8 being  ext-real number holds ((R7 in ( dom C157 ) & R8 in ( dom C157 ) & R7 < R8) implies ( C157 . R7 ) < ( C157 . R8 ))));
attr C157 is  decreasing
means
:L417: (for R7 being  ext-real number holds (for R8 being  ext-real number holds ((R7 in ( dom C157 ) & R8 in ( dom C157 ) & R7 < R8) implies ( C157 . R7 ) > ( C157 . R8 ))));
attr C157 is  non-decreasing
means
:L418: (for R7 being  ext-real number holds (for R8 being  ext-real number holds ((R7 in ( dom C157 ) & R8 in ( dom C157 ) & R7 <= R8) implies ( C157 . R7 ) <= ( C157 . R8 ))));
attr C157 is  non-increasing
means
:L419: (for R7 being  ext-real number holds (for R8 being  ext-real number holds ((R7 in ( dom C157 ) & R8 in ( dom C157 ) & R7 <= R8) implies ( C157 . R7 ) >= ( C157 . R8 ))));
end;
registration
cluster  trivial ->  increasing  decreasing for  ext-real-valued  ext-real-valued  ext-real-valued  ext-real-valued Function;
coherence
proof
let C158 being  ext-real-valued Function;
assume L421: C158 is  trivial;
thus L422: C158 is  increasing
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume L423: (R7 in ( dom C158 ) & R8 in ( dom C158 ));
thus L424: thesis by L423 , L421 , ZFMISC_1:def 10;
end;

let R7 being  ext-real number;
let R8 being  ext-real number;
assume L425: (R7 in ( dom C158 ) & R8 in ( dom C158 ));
thus L426: thesis by L425 , L421 , ZFMISC_1:def 10;
end;
end;
registration
cluster  increasing ->  non-decreasing for  ext-real-valued  ext-real-valued  ext-real-valued  ext-real-valued Function;
coherence
proof
let C159 being  ext-real-valued Function;
assume L428: C159 is  increasing;
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L429: (R7 in ( dom C159 ) & R8 in ( dom C159 ))
and
L430: R7 <= R8;
per cases  by L430 , XXREAL_0:1;
suppose L431: R7 = R8;

thus L432: thesis by L431;
end;
suppose L433: R7 < R8;

thus L434: thesis by L433 , L428 , L429 , L416;
end;
end;
cluster  decreasing ->  non-increasing for  ext-real-valued  ext-real-valued  ext-real-valued  ext-real-valued Function;
coherence
proof
let C160 being  ext-real-valued Function;
assume L436: C160 is  decreasing;
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L437: (R7 in ( dom C160 ) & R8 in ( dom C160 ))
and
L438: R7 <= R8;
per cases  by L438 , XXREAL_0:1;
suppose L439: R7 = R8;

thus L440: thesis by L439;
end;
suppose L441: R7 < R8;

thus L442: thesis by L441 , L436 , L437 , L417;
end;
end;
end;
registration
let C161 , C162 being  increasing  ext-real-valued Function;
cluster ( C162 * C161 ) ->  increasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L445: R7 in ( dom ( C162 * C161 ) )
and
L446: R8 in ( dom ( C162 * C161 ) );
L447: R7 in ( dom C161 ) by L445 , FUNCT_1:11;
L448: ( ( C162 * C161 ) . R7 ) = ( C162 . ( C161 . R7 ) ) by L447 , FUNCT_1:13;
L449: R8 in ( dom C161 ) by L446 , FUNCT_1:11;
L450: ( ( C162 * C161 ) . R8 ) = ( C162 . ( C161 . R8 ) ) by L449 , FUNCT_1:13;
assume L451: R7 < R8;
L452: ( C161 . R7 ) < ( C161 . R8 ) by L451 , L447 , L449 , L416;
L453: (( C161 . R7 ) in ( dom C162 ) & ( C161 . R8 ) in ( dom C162 )) by L445 , L446 , FUNCT_1:11;
thus L454: thesis by L453 , L448 , L450 , L452 , L416;
end;
end;
registration
let C163 , C164 being  non-decreasing  ext-real-valued Function;
cluster ( C164 * C163 ) ->  non-decreasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L456: R7 in ( dom ( C164 * C163 ) )
and
L457: R8 in ( dom ( C164 * C163 ) );
L458: R7 in ( dom C163 ) by L456 , FUNCT_1:11;
L459: ( ( C164 * C163 ) . R7 ) = ( C164 . ( C163 . R7 ) ) by L458 , FUNCT_1:13;
L460: R8 in ( dom C163 ) by L457 , FUNCT_1:11;
L461: ( ( C164 * C163 ) . R8 ) = ( C164 . ( C163 . R8 ) ) by L460 , FUNCT_1:13;
assume L462: R7 <= R8;
L463: ( C163 . R7 ) <= ( C163 . R8 ) by L462 , L458 , L460 , L418;
L464: (( C163 . R7 ) in ( dom C164 ) & ( C163 . R8 ) in ( dom C164 )) by L456 , L457 , FUNCT_1:11;
thus L465: thesis by L464 , L459 , L461 , L463 , L418;
end;
end;
registration
let C165 , C166 being  decreasing  ext-real-valued Function;
cluster ( C166 * C165 ) ->  increasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L467: R7 in ( dom ( C166 * C165 ) )
and
L468: R8 in ( dom ( C166 * C165 ) );
L469: R7 in ( dom C165 ) by L467 , FUNCT_1:11;
L470: ( ( C166 * C165 ) . R7 ) = ( C166 . ( C165 . R7 ) ) by L469 , FUNCT_1:13;
L471: R8 in ( dom C165 ) by L468 , FUNCT_1:11;
L472: ( ( C166 * C165 ) . R8 ) = ( C166 . ( C165 . R8 ) ) by L471 , FUNCT_1:13;
assume L473: R7 < R8;
L474: ( C165 . R7 ) > ( C165 . R8 ) by L473 , L469 , L471 , L417;
L475: (( C165 . R7 ) in ( dom C166 ) & ( C165 . R8 ) in ( dom C166 )) by L467 , L468 , FUNCT_1:11;
thus L476: thesis by L475 , L470 , L472 , L474 , L417;
end;
end;
registration
let C167 , C168 being  non-increasing  ext-real-valued Function;
cluster ( C168 * C167 ) ->  non-decreasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L478: R7 in ( dom ( C168 * C167 ) )
and
L479: R8 in ( dom ( C168 * C167 ) );
L480: R7 in ( dom C167 ) by L478 , FUNCT_1:11;
L481: ( ( C168 * C167 ) . R7 ) = ( C168 . ( C167 . R7 ) ) by L480 , FUNCT_1:13;
L482: R8 in ( dom C167 ) by L479 , FUNCT_1:11;
L483: ( ( C168 * C167 ) . R8 ) = ( C168 . ( C167 . R8 ) ) by L482 , FUNCT_1:13;
assume L484: R7 <= R8;
L485: ( C167 . R7 ) >= ( C167 . R8 ) by L484 , L480 , L482 , L419;
L486: (( C167 . R7 ) in ( dom C168 ) & ( C167 . R8 ) in ( dom C168 )) by L478 , L479 , FUNCT_1:11;
thus L487: thesis by L486 , L481 , L483 , L485 , L419;
end;
end;
registration
let C169 being  decreasing  ext-real-valued Function;
let C170 being  increasing  ext-real-valued Function;
cluster ( C170 * C169 ) ->  decreasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L489: R7 in ( dom ( C170 * C169 ) )
and
L490: R8 in ( dom ( C170 * C169 ) );
L491: R7 in ( dom C169 ) by L489 , FUNCT_1:11;
L492: ( ( C170 * C169 ) . R7 ) = ( C170 . ( C169 . R7 ) ) by L491 , FUNCT_1:13;
L493: R8 in ( dom C169 ) by L490 , FUNCT_1:11;
L494: ( ( C170 * C169 ) . R8 ) = ( C170 . ( C169 . R8 ) ) by L493 , FUNCT_1:13;
assume L495: R7 < R8;
L496: ( C169 . R7 ) > ( C169 . R8 ) by L495 , L491 , L493 , L417;
L497: (( C169 . R7 ) in ( dom C170 ) & ( C169 . R8 ) in ( dom C170 )) by L489 , L490 , FUNCT_1:11;
thus L498: thesis by L497 , L492 , L494 , L496 , L416;
end;
cluster ( C169 * C170 ) ->  decreasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L499: R7 in ( dom ( C169 * C170 ) )
and
L500: R8 in ( dom ( C169 * C170 ) );
L501: R7 in ( dom C170 ) by L499 , FUNCT_1:11;
L502: ( ( C169 * C170 ) . R7 ) = ( C169 . ( C170 . R7 ) ) by L501 , FUNCT_1:13;
L503: R8 in ( dom C170 ) by L500 , FUNCT_1:11;
L504: ( ( C169 * C170 ) . R8 ) = ( C169 . ( C170 . R8 ) ) by L503 , FUNCT_1:13;
assume L505: R7 < R8;
L506: ( C170 . R7 ) < ( C170 . R8 ) by L505 , L501 , L503 , L416;
L507: (( C170 . R7 ) in ( dom C169 ) & ( C170 . R8 ) in ( dom C169 )) by L499 , L500 , FUNCT_1:11;
thus L508: thesis by L507 , L502 , L504 , L506 , L417;
end;
end;
registration
let C171 being  non-increasing  ext-real-valued Function;
let C172 being  non-decreasing  ext-real-valued Function;
cluster ( C172 * C171 ) ->  non-increasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L510: R7 in ( dom ( C172 * C171 ) )
and
L511: R8 in ( dom ( C172 * C171 ) );
L512: R7 in ( dom C171 ) by L510 , FUNCT_1:11;
L513: ( ( C172 * C171 ) . R7 ) = ( C172 . ( C171 . R7 ) ) by L512 , FUNCT_1:13;
L514: R8 in ( dom C171 ) by L511 , FUNCT_1:11;
L515: ( ( C172 * C171 ) . R8 ) = ( C172 . ( C171 . R8 ) ) by L514 , FUNCT_1:13;
assume L516: R7 <= R8;
L517: ( C171 . R7 ) >= ( C171 . R8 ) by L516 , L512 , L514 , L419;
L518: (( C171 . R7 ) in ( dom C172 ) & ( C171 . R8 ) in ( dom C172 )) by L510 , L511 , FUNCT_1:11;
thus L519: thesis by L518 , L513 , L515 , L517 , L418;
end;
cluster ( C171 * C172 ) ->  non-increasing;
coherence
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L520: R7 in ( dom ( C171 * C172 ) )
and
L521: R8 in ( dom ( C171 * C172 ) );
L522: R7 in ( dom C172 ) by L520 , FUNCT_1:11;
L523: ( ( C171 * C172 ) . R7 ) = ( C171 . ( C172 . R7 ) ) by L522 , FUNCT_1:13;
L524: R8 in ( dom C172 ) by L521 , FUNCT_1:11;
L525: ( ( C171 * C172 ) . R8 ) = ( C171 . ( C172 . R8 ) ) by L524 , FUNCT_1:13;
assume L526: R7 <= R8;
L527: ( C172 . R7 ) <= ( C172 . R8 ) by L526 , L522 , L524 , L418;
L528: (( C172 . R7 ) in ( dom C171 ) & ( C172 . R8 ) in ( dom C171 )) by L520 , L521 , FUNCT_1:11;
thus L529: thesis by L528 , L523 , L525 , L527 , L419;
end;
end;
registration
let C173 being  ext-real-membered set;
cluster ( id C173 ) ->  increasing for (Function of C173 , C173);
coherence
proof
L531: ( id C173 ) is  increasing
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume that
L532: R7 in ( dom ( id C173 ) )
and
L533: R8 in ( dom ( id C173 ) );
L534: ( ( id C173 ) . R7 ) = R7 by L532 , FUNCT_1:18;
thus L535: thesis by L534 , L533 , FUNCT_1:18;
end;
thus L536: thesis by L531;
end;
end;
registration
cluster  increasing for (sequence of ( NAT ));
existence
proof
take ( id ( NAT ) );
thus L538: thesis;
end;
end;
definition
let C174 being (ManySortedSet of ( NAT ));
mode subsequence of C174
 -> (ManySortedSet of ( NAT ))
means :L540: (ex B19 being  increasing (sequence of ( NAT )) st it = ( C174 * B19 ));
existence
proof
take C174;
take ( id ( NAT ) );
L541: ( dom C174 ) = ( NAT ) by PARTFUN1:def 2;
thus L542: thesis by L541 , RELAT_1:52;
end;
end;
L544: (for B20 being non  empty set holds (for B21 being (ManySortedSet of ( NAT )) holds (for B22 being (subsequence of B21) holds ( rng B22 ) c= ( rng B21 ))))
proof
let C175 being non  empty set;
let C176 being (ManySortedSet of ( NAT ));
let C177 being (subsequence of C176);
L545: (ex B23 being  increasing (sequence of ( NAT )) st C177 = ( C176 * B23 )) by L540;
thus L546: ( rng C177 ) c= ( rng C176 ) by L545 , RELAT_1:26;
end;
registration
let C178 being non  empty set;
let C179 being C178 -valued (ManySortedSet of ( NAT ));
cluster  -> C178 -valued for (subsequence of C179);
coherence
proof
let C180 being (subsequence of C179);
L547: ( rng C180 ) c= ( rng C179 ) by L544;
thus L548: ( rng C180 ) c= C178 by L547 , XBOOLE_1:1;
end;
end;
definition
let C181 being non  empty set;
let C182 being (sequence of C181);
redefine mode subsequence of C182
 -> (sequence of C181);
coherence
proof
let C183 being (subsequence of C182);
L550: (( rng C183 ) c= C181 & ( dom C183 ) = ( NAT )) by PARTFUN1:def 2;
thus L551: C183 is (sequence of C181) by L550 , RELSET_1:4;
end;
end;
definition
let C184 being non  empty set;
let C185 being (sequence of C184);
let C186 being Nat;
redefine func C185 ^\ C186 -> (subsequence of C185);

coherence
proof
set D5 = ( ( id ( NAT ) ) ^\ C186 );
L553: D5 is  increasing
proof
let R7 being  ext-real number;
let R8 being  ext-real number;
assume L554: (R7 in ( dom D5 ) & R8 in ( dom D5 ));
reconsider D6 = R7 , D7 = R8 as (Element of ( NAT )) by L554;
L555: ( D5 . D7 ) = ( ( id ( NAT ) ) . ( D7 + C186 ) ) by NAT_1:def 3
.= ( D7 + C186 ) by FUNCT_1:18;
assume L556: R7 < R8;
L557: ( D5 . D6 ) = ( ( id ( NAT ) ) . ( D6 + C186 ) ) by NAT_1:def 3
.= ( D6 + C186 ) by FUNCT_1:18;
thus L558: thesis by L557 , L555 , L556 , XREAL_1:6;
end;
reconsider D8 = D5 as  increasing (sequence of ( NAT )) by L553;
thus L559: ( C185 ^\ C186 ) is (subsequence of C185)
proof
take D8;
thus L560: ( C185 ^\ C186 ) = ( ( C185 * ( id ( NAT ) ) ) ^\ C186 ) by FUNCT_2:17
.= ( C185 * D8 ) by NAT_1:50;
end;

end;
end;
theorem
L561: (for R13 being non  empty set holds (for R14 being (sequence of R13) holds R14 is (subsequence of R14)))
proof
let R13 being non  empty set;
let R14 being (sequence of R13);
take ( id ( NAT ) );
thus L562: thesis by FUNCT_2:17;
end;
theorem
L563: (for R13 being non  empty set holds (for R15 being (sequence of R13) holds (for R16 being (sequence of R13) holds (for R17 being (sequence of R13) holds ((R15 is (subsequence of R16) & R16 is (subsequence of R17)) implies R15 is (subsequence of R17))))))
proof
let R13 being non  empty set;
let R15 being (sequence of R13);
let R16 being (sequence of R13);
let R17 being (sequence of R13);
given C187 being  increasing (sequence of ( NAT )) such that
L564: R15 = ( R16 * C187 );

given C188 being  increasing (sequence of ( NAT )) such that
L565: R16 = ( R17 * C188 );

take ( C188 * C187 );
thus L566: thesis by L564 , L565 , RELAT_1:36;
end;
registration
let R3 being set;
cluster  constant for (sequence of R3);
existence
proof
per cases ;
suppose L567: R3 = ( {} );

reconsider D9 = ( {} ) as (sequence of R3) by L567 , FUNCT_2:def 1 , RELSET_1:12;
take D9;
thus L568: thesis;
end;
suppose L569: R3 <> ( {} );

consider R1 being set such that L570: R1 in R3 by L569 , XBOOLE_0:def 1;
reconsider D10 = ( ( NAT ) --> R1 ) as (sequence of R3) by L570 , FUNCOP_1:45;
take D10;
thus L571: thesis;
end;
end;
end;
theorem
L574: (for R13 being non  empty set holds (for R14 being (sequence of R13) holds (for B24 being (subsequence of R14) holds ( rng B24 ) c= ( rng R14 ))))
proof
let R13 being non  empty set;
let R14 being (sequence of R13);
let C189 being (subsequence of R14);
let R1 being set;
consider C190 being  increasing (sequence of ( NAT )) such that L575: C189 = ( R14 * C190 ) by L540;
assume L576: R1 in ( rng C189 );
consider C191 being set such that L577: C191 in ( NAT ) and L578: R1 = ( C189 . C191 ) by L576 , FUNCT_2:11;
L579: ( C190 . C191 ) in ( NAT ) by L577 , FUNCT_2:5;
L580: R1 = ( R14 . ( C190 . C191 ) ) by L575 , L577 , L578 , FUNCT_2:15;
thus L581: thesis by L580 , L579 , FUNCT_2:4;
end;
registration
let C192 being non  empty set;
let C193 being  constant (sequence of C192);
cluster  ->  constant for (subsequence of C193);
coherence
proof
let C194 being (subsequence of C193);
L582: ( rng C194 ) c= ( rng C193 ) by L574;
thus L583: thesis by L582;
end;
end;
definition
let C195 being non  empty set;
let C196 being  increasing (sequence of ( NAT ));
let C197 being (sequence of C195);
redefine func C197 * C196 -> (subsequence of C197);

correctness by L540;
end;
theorem
L586: (for R18 being non  empty set holds (for R19 being non  empty set holds (for R21 being (sequence of R18) holds (for R22 being (sequence of R18) holds (for R23 being (PartFunc of R18 , R19) holds ((( rng R21 ) c= ( dom R23 ) & R22 is (subsequence of R21)) implies ( R23 /* R22 ) is (subsequence of ( R23 /* R21 ))))))))
proof
let R18 being non  empty set;
let R19 being non  empty set;
let R21 being (sequence of R18);
let R22 being (sequence of R18);
let R23 being (PartFunc of R18 , R19);
assume that
L587: ( rng R21 ) c= ( dom R23 )
and
L588: R22 is (subsequence of R21);
consider R27 being  increasing (sequence of ( NAT )) such that L589: R22 = ( R21 * R27 ) by L588 , L540;
take R27;
thus L590: thesis by L587 , L589 , FUNCT_2:110;
end;
registration
let C198 being  with_non-empty_element set;
cluster  non-empty for (sequence of C198);
existence
proof
consider C199 being non  empty set such that L591: C199 in C198 by SETFAM_1:def 10;
reconsider D11 = ( ( NAT ) --> C199 ) as (sequence of C198) by L591 , FUNCOP_1:45;
take D11;
thus L592: thesis;
end;
end;
registration
let C200 being  with_non-empty_element set;
let C201 being  non-empty (sequence of C200);
cluster  ->  non-empty for (subsequence of C201);
coherence
proof
let C202 being (subsequence of C201);
L594: ( rng C202 ) c= ( rng C201 ) by L574;
thus L595: (not ( {} ) in ( rng C202 )) by L594;
end;
end;
definition
let C203 being non  empty set;
let C204 being (sequence of C203);
redefine attr C204 is  constant
means
(ex B25 being (Element of C203) st (for B26 being Nat holds ( C204 . B26 ) = B25));
compatibility
proof
thus L597:now
assume L598: C204 is  constant;
consider C205 being (Element of C203) such that L599: (for B27 being (Element of ( NAT )) holds (B27 in ( dom C204 ) implies ( C204 . B27 ) = C205)) by L598 , PARTFUN2:def 1;
take D12 = C205;
let C206 being Nat;
L600: (( dom C204 ) = ( NAT ) & C206 in ( NAT )) by FUNCT_2:def 1 , ORDINAL1:def 12;
thus L601: ( C204 . C206 ) = D12 by L600 , L599;
end;
given C207 being (Element of C203) such that
L602: (for B28 being Nat holds ( C204 . B28 ) = C207);

take C207;
thus L603: thesis by L602;
end;
end;
theorem
L605: (for R28 being Nat holds (for R29 being Nat holds (for B29 being set holds (for B30 being  constant (sequence of B29) holds ( B30 . R28 ) = ( B30 . R29 )))))
proof
let R28 being Nat;
let R29 being Nat;
let C208 being set;
let C209 being  constant (sequence of C208);
per cases ;
suppose L606: C208 is  empty;

L607: ( C209 . R28 ) = ( {} ) by L606;
thus L608: thesis by L607 , L606;
end;
suppose L609: (not C208 is  empty);

L610: ( dom C209 ) = ( NAT ) by L609 , FUNCT_2:def 1;
L611: (R28 in ( dom C209 ) & R29 in ( dom C209 )) by L610 , ORDINAL1:def 12;
thus L612: thesis by L611 , FUNCT_1:def 10;
end;
end;
theorem
L614: (for R18 being non  empty set holds (for R21 being (sequence of R18) holds ((for R28 being Nat holds (for R29 being Nat holds ( R21 . R28 ) = ( R21 . R29 ))) implies R21 is  constant)))
proof
let R18 being non  empty set;
let R21 being (sequence of R18);
assume L615: (for R28 being Nat holds (for R29 being Nat holds ( R21 . R28 ) = ( R21 . R29 )));
L616: (for B31 , B32 being set holds ((B31 in ( dom R21 ) & B32 in ( dom R21 )) implies ( R21 . B31 ) = ( R21 . B32 ))) by L615;
thus L617: thesis by L616 , FUNCT_1:def 10;
end;
theorem
L618: (for R18 being non  empty set holds (for R21 being (sequence of R18) holds ((for R28 being Nat holds ( R21 . R28 ) = ( R21 . ( R28 + 1 ) )) implies R21 is  constant)))
proof
let R18 being non  empty set;
let R21 being (sequence of R18);
assume L619: (for R28 being Nat holds ( R21 . R28 ) = ( R21 . ( R28 + 1 ) ));
L620:
now
let R28 being Nat;
let R29 being Nat;
L621:
now
let R28 being Nat;
let R29 being Nat;
assume that
L622: R28 <= R29;
defpred S1[ Nat ] means (R28 <= $1 implies ( R21 . R28 ) = ( R21 . $1 ));
L623: (for B33 being Nat holds (S1[ B33 ] implies S1[ ( B33 + 1 ) ]))
proof
let C210 being Nat;
assume that
L624: S1[ C210 ];
assume L625: R28 <= ( C210 + 1 );
L626: (R28 < ( C210 + 1 ) or R28 = ( C210 + 1 )) by L625 , XXREAL_0:1;
thus L627: thesis by L626 , L619 , L624 , NAT_1:13;
end;
L628: S1[ ( 0 ) ] by NAT_1:3;
L629: (for B34 being Nat holds S1[ B34 ]) from NAT_1:sch 2(L628 , L623);
thus L630: ( R21 . R28 ) = ( R21 . R29 ) by L629 , L622;
end;
L631: (R28 <= R29 or R29 <= R28);
thus L632: ( R21 . R28 ) = ( R21 . R29 ) by L631 , L621;
end;
thus L633: thesis by L620 , L614;
end;
theorem
L634: (for R18 being non  empty set holds (for R21 being (sequence of R18) holds (for R22 being (sequence of R18) holds ((R21 is  constant & R22 is (subsequence of R21)) implies R21 = R22))))
proof
let R18 being non  empty set;
let R21 being (sequence of R18);
let R22 being (sequence of R18);
assume that
L635: R21 is  constant
and
L636: R22 is (subsequence of R21);
let C211 being (Element of ( NAT ));
consider R27 being  increasing (sequence of ( NAT )) such that L637: R22 = ( R21 * R27 ) by L636 , L540;
thus L638: ( R22 . C211 ) = ( R21 . ( R27 . C211 ) ) by L637 , FUNCT_2:15
.= ( R21 . C211 ) by L635 , L605;
end;
theorem
L639: (for R18 being non  empty set holds (for R19 being non  empty set holds (for R21 being (sequence of R18) holds (for R23 being (PartFunc of R18 , R19) holds (for R30 being Nat holds (( rng R21 ) c= ( dom R23 ) implies ( ( R23 /* R21 ) ^\ R30 ) = ( R23 /* ( R21 ^\ R30 ) )))))))
proof
let R18 being non  empty set;
let R19 being non  empty set;
let R21 being (sequence of R18);
let R23 being (PartFunc of R18 , R19);
let R30 being Nat;
assume L640: ( rng R21 ) c= ( dom R23 );
let C212 being (Element of ( NAT ));
L641: ( rng ( R21 ^\ R30 ) ) c= ( rng R21 ) by L574;
thus L642: ( ( ( R23 /* R21 ) ^\ R30 ) . C212 ) = ( ( R23 /* R21 ) . ( C212 + R30 ) ) by NAT_1:def 3
.= ( R23 . ( R21 . ( C212 + R30 ) ) ) by L640 , FUNCT_2:108
.= ( R23 . ( ( R21 ^\ R30 ) . C212 ) ) by NAT_1:def 3
.= ( ( R23 /* ( R21 ^\ R30 ) ) . C212 ) by L640 , L641 , FUNCT_2:108 , XBOOLE_1:1;
end;
theorem
L643: (for R18 being non  empty set holds (for R21 being (sequence of R18) holds (for R30 being Nat holds ( R21 . R30 ) in ( rng R21 ))))
proof
let R18 being non  empty set;
let R21 being (sequence of R18);
let R30 being Nat;
L644: R30 in ( NAT ) by ORDINAL1:def 12;
thus L645: thesis by L644 , FUNCT_2:112;
end;
theorem
L646: (for R18 being non  empty set holds (for R19 being non  empty set holds (for R21 being (sequence of R18) holds (for R23 being (PartFunc of R18 , R19) holds (for R30 being Nat holds (R23 is  total implies ( R23 /* ( R21 ^\ R30 ) ) = ( ( R23 /* R21 ) ^\ R30 )))))))
proof
let R18 being non  empty set;
let R19 being non  empty set;
let R21 being (sequence of R18);
let R23 being (PartFunc of R18 , R19);
let R30 being Nat;
assume L647: R23 is  total;
L648: ( dom R23 ) = R18 by L647 , PARTFUN1:def 2;
L649: ( rng R21 ) c= ( dom R23 ) by L648;
thus L650: thesis by L649 , L639;
end;
theorem
L651: (for R18 being non  empty set holds (for R19 being non  empty set holds (for R21 being (sequence of R18) holds (for R23 being (PartFunc of R18 , R19) holds (( rng R21 ) c= ( dom R23 ) implies ( R23 .: ( rng R21 ) ) = ( rng ( R23 /* R21 ) ))))))
proof
let R18 being non  empty set;
let R19 being non  empty set;
let R21 being (sequence of R18);
let R23 being (PartFunc of R18 , R19);
assume L652: ( rng R21 ) c= ( dom R23 );
L653:
now
let C213 being (Element of R19);
thus L654: (C213 in ( R23 .: ( rng R21 ) ) implies C213 in ( rng ( R23 /* R21 ) ))
proof
assume L655: C213 in ( R23 .: ( rng R21 ) );
consider C214 being (Element of R18) such that L656: C214 in ( dom R23 ) and L657: C214 in ( rng R21 ) and L658: C213 = ( R23 . C214 ) by L655 , PARTFUN2:59;
consider C215 being (Element of ( NAT )) such that L659: C214 = ( R21 . C215 ) by L657 , FUNCT_2:113;
L660: C213 = ( ( R23 /* R21 ) . C215 ) by L652 , L658 , L659 , FUNCT_2:108;
thus L661: thesis by L660 , L643;
end;

assume L662: C213 in ( rng ( R23 /* R21 ) );
consider C216 being (Element of ( NAT )) such that L663: ( ( R23 /* R21 ) . C216 ) = C213 by L662 , FUNCT_2:113;
L664: ( R21 . C216 ) in ( rng R21 ) by L643;
L665: C213 = ( R23 . ( R21 . C216 ) ) by L652 , L663 , FUNCT_2:108;
thus L666: C213 in ( R23 .: ( rng R21 ) ) by L665 , L652 , L664 , FUNCT_1:def 6;
end;
thus L667: thesis by L653 , SUBSET_1:3;
end;
theorem
L668: (for R18 being non  empty set holds (for R19 being non  empty set holds (for R20 being set holds (for R21 being (sequence of R18) holds (for R24 being (PartFunc of R18 , R19) holds (for R25 being (PartFunc of R19 , R20) holds (( rng R21 ) c= ( dom ( R25 * R24 ) ) implies ( R25 /* ( R24 /* R21 ) ) = ( ( R25 * R24 ) /* R21 ))))))))
proof
let R18 being non  empty set;
let R19 being non  empty set;
let R20 being set;
let R21 being (sequence of R18);
let R24 being (PartFunc of R18 , R19);
let R25 being (PartFunc of R19 , R20);
assume L669: ( rng R21 ) c= ( dom ( R25 * R24 ) );
L670:
now
let C217 being (Element of ( NAT ));
L671: ( rng R21 ) c= ( dom R24 ) by L669 , FUNCT_1:101;
L672: ( R24 .: ( rng R21 ) ) c= ( dom R25 ) by L669 , FUNCT_1:101;
L673: ( rng ( R24 /* R21 ) ) c= ( dom R25 ) by L672 , L671 , L651;
L674: ( R21 . C217 ) in ( rng R21 ) by L643;
L675: ( R21 . C217 ) in ( dom R24 ) by L674 , L669 , FUNCT_1:11;
thus L676: ( ( ( R25 * R24 ) /* R21 ) . C217 ) = ( ( R25 * R24 ) . ( R21 . C217 ) ) by L669 , FUNCT_2:108
.= ( R25 . ( R24 . ( R21 . C217 ) ) ) by L675 , FUNCT_1:13
.= ( R25 . ( ( R24 /* R21 ) . C217 ) ) by L671 , FUNCT_2:108
.= ( ( R25 /* ( R24 /* R21 ) ) . C217 ) by L673 , FUNCT_2:108;
end;
thus L677: thesis by L670 , FUNCT_2:63;
end;
definition
let C218 being  ext-real-valued Function;
attr C218 is  zeroed
means
( C218 . ( {} ) ) = ( 0 );
end;
registration
cluster ( COMPLEX ) -valued ->  complex-valued for Relation;
coherence
proof
let C219 being Relation;
assume L679: C219 is ( COMPLEX ) -valued;
thus L680: ( rng C219 ) c= ( COMPLEX ) by L679 , RELAT_1:def 19;
end;
cluster ( ExtREAL ) -valued ->  ext-real-valued for Relation;
coherence
proof
let C220 being Relation;
assume L681: C220 is ( ExtREAL ) -valued;
thus L682: ( rng C220 ) c= ( ExtREAL ) by L681 , RELAT_1:def 19;
end;
cluster ( REAL ) -valued ->  real-valued for Relation;
coherence
proof
let C221 being Relation;
assume L683: C221 is ( REAL ) -valued;
thus L684: ( rng C221 ) c= ( REAL ) by L683 , RELAT_1:def 19;
end;
cluster ( NAT ) -valued ->  natural-valued for Relation;
coherence
proof
let C222 being Relation;
assume L685: C222 is ( NAT ) -valued;
thus L686: ( rng C222 ) c= ( NAT ) by L685 , RELAT_1:def 19;
end;
end;
definition
let C223 being (ManySortedSet of ( NAT ));
redefine attr C223 is  constant
means
(ex B35 being set st (for B36 being Nat holds ( C223 . B36 ) = B35));
compatibility
proof
L688: ( dom C223 ) = ( NAT ) by PARTFUN1:def 2;
thus L689:now
assume L690: C223 is  constant;
take D13 = ( C223 . ( 0 ) );
let C224 being Nat;
L691: (( 0 ) in ( dom C223 ) & C224 in ( dom C223 )) by L688 , ORDINAL1:def 12;
thus L692: ( C223 . C224 ) = D13 by L691 , L690 , FUNCT_1:def 10;
end;
given C225 being set such that
L693: (for B37 being Nat holds ( C223 . B37 ) = C225);

let C226 , C227 being set;
assume L694: (C226 in ( dom C223 ) & C227 in ( dom C223 ));
thus L695: ( C223 . C226 ) = C225 by L694 , L693
.= ( C223 . C227 ) by L693 , L694;
end;
end;
theorem
L697: (for B38 being non  empty set holds (for B39 being (ManySortedSet of ( NAT )) holds (for B40 being (subsequence of B39) holds ( rng B40 ) c= ( rng B39 )))) by L544;
registration
let C228 being set;
cluster  natural-valued for (ManySortedSet of C228);
existence
proof
take ( C228 --> ( 0 ) );
thus L698: thesis;
end;
end;
