:: Abelian Groups, Fields and Vector Spaces
::  by Eugeniusz Kusak, Wojciech Leo\'nczuk and Micha{\l} Muzalewski
::
:: Received November 23, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ALGSTR_0, STRUCT_0, NUMBERS, BINOP_2, CARD_1, XREAL_0,
      SUBSET_1, ORDINAL1, ARYTM_3, RLVECT_1, SUPINF_2, ARYTM_1, RELAT_1,
      MESFUNC1, GROUP_1, LATTICES, BINOP_1, FUNCT_1, ZFMISC_1, XXREAL_0,
      VECTSP_1, MEMBERED, MSSUBFAM;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, FUNCT_2, BINOP_1,
      ORDINAL1, XCMPLX_0, XXREAL_0, XREAL_0, NAT_D, BINOP_2, MEMBERED,
      STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1;
 constructors BINOP_1, XXREAL_0, NAT_1, BINARITH, RLVECT_1, GROUP_1, BINOP_2,
      NAT_D, RELSET_1, MEMBERED;
 registrations ORDINAL1, RELSET_1, NUMBERS, XREAL_0, STRUCT_0, GROUP_1,
      ALGSTR_0, REAL_1, MEMBERED;
 requirements NUMERALS, SUBSET, ARITHM, BOOLE;
 definitions RLVECT_1, STRUCT_0, GROUP_1, ALGSTR_0;
 theorems FUNCT_2, RLVECT_1, XCMPLX_0, BINOP_2, GROUP_1, NAT_1, XREAL_1,
      XREAL_0, ALGSTR_0;
 schemes FUNCT_2;

begin
definition
func G_Real ->  strict addLoopStr equals 
addLoopStr (# ( REAL ) , ( addreal ) , ( 0 ) #);
coherence;
end;
registration
cluster ( G_Real ) -> non  empty;
coherence;
end;
registration
cluster (the carrier of ( G_Real )) ->  real-membered;
coherence;
end;
registration
let C1 , C2 being (Element of ( G_Real ));
let C3 , C4 being  real number;
identify C1 + C2 with C3 + C4 when C1 = C3 , C2 = C4;
compatibility by BINOP_2:def 9;
end;
registration
cluster ( G_Real ) ->  Abelian  add-associative  right_zeroed  right_complementable;
coherence
proof
thus L5: (for B1 , B2 being (Element of ( G_Real )) holds ( B1 + B2 ) = ( B2 + B1 ));
thus L6: (for B3 , B4 , B5 being (Element of ( G_Real )) holds ( ( B3 + B4 ) + B5 ) = ( B3 + ( B4 + B5 ) ));
thus L7: (for B6 being (Element of ( G_Real )) holds ( B6 + ( 0. ( G_Real ) ) ) = B6);
let C5 being (Element of ( G_Real ));
reconsider D1 = C5 as (Element of ( REAL ));
reconsider D2 = ( - D1 ) as (Element of ( G_Real ));
take D2;
thus L8: thesis;
end;
end;
registration
let C6 being (Element of ( G_Real ));
let C7 being  real number;
identify - C6 with - C7 when C6 = C7;
compatibility
proof
reconsider D3 = ( - C7 ) as (Element of ( G_Real ));
assume L10: C7 = C6;
L11: ( D3 + C6 ) = ( 0. ( G_Real ) ) by L10;
thus L12: thesis by L11 , RLVECT_1:6;
end;
end;
theorem
L14: (for B7 , B8 , B9 being (Element of ( G_Real )) holds (( B7 + B8 ) = ( B8 + B7 ) & ( ( B7 + B8 ) + B9 ) = ( B7 + ( B8 + B9 ) ) & ( B7 + ( 0. ( G_Real ) ) ) = B7 & ( B7 + ( - B7 ) ) = ( 0. ( G_Real ) )));
registration
cluster  strict  add-associative  right_zeroed  right_complementable  Abelian for non  empty non  empty non  empty non  empty addLoopStr;
existence
proof
take ( G_Real );
thus L15: thesis;
end;
end;
definition
mode AddGroup
 is  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
end;
definition
mode AbGroup
 is  Abelian AddGroup;
end;
definition
let C8 being non  empty doubleLoopStr;
attr C8 is  right-distributive
means
:L19: (for B10 , B11 , B12 being (Element of C8) holds ( B10 * ( B11 + B12 ) ) = ( ( B10 * B11 ) + ( B10 * B12 ) ));
attr C8 is  left-distributive
means
:L20: (for B13 , B14 , B15 being (Element of C8) holds ( ( B14 + B15 ) * B13 ) = ( ( B14 * B13 ) + ( B15 * B13 ) ));
end;
definition
let C9 being non  empty multLoopStr;
attr C9 is  right_unital
means
:L22: (for B16 being (Element of C9) holds ( B16 * ( 1. C9 ) ) = B16);
end;
definition
func F_Real ->  strict doubleLoopStr equals 
doubleLoopStr (# ( REAL ) , ( addreal ) , ( multreal ) , 1 , ( 0 ) #);
correctness;
end;
registration
cluster ( F_Real ) -> non  empty;
coherence;
end;
registration
cluster (the carrier of ( F_Real )) ->  real-membered;
coherence;
end;
registration
let C10 , C11 being (Element of ( F_Real ));
let C12 , C13 being  real number;
identify C10 + C11 with C12 + C13 when C10 = C12 , C11 = C13;
compatibility by BINOP_2:def 9;
end;
registration
let C14 , C15 being (Element of ( F_Real ));
let C16 , C17 being  real number;
identify C14 * C15 with C16 * C17 when C14 = C16 , C15 = C17;
compatibility by BINOP_2:def 11;
end;
definition
let C18 being non  empty multLoopStr;
attr C18 is  well-unital
means
:L29: (for B17 being (Element of C18) holds (( B17 * ( 1. C18 ) ) = B17 & ( ( 1. C18 ) * B17 ) = B17));
end;
L31: (for B18 being non  empty multLoopStr holds (B18 is  well-unital implies B18 is  unital))
proof
let C19 being non  empty multLoopStr;
assume that
L32: C19 is  well-unital;
take ( 1. C19 );
thus L33: thesis by L32 , L29;
end;
L34: (for B19 being non  empty multLoopStr holds (B19 is  well-unital implies ( 1. B19 ) = ( 1_ B19 )))
proof
let C20 being non  empty multLoopStr;
assume L35: C20 is  well-unital;
L36: ((for B20 being (Element of C20) holds (( B20 * ( 1. C20 ) ) = B20 & ( ( 1. C20 ) * B20 ) = B20)) & C20 is  unital) by L35 , L29 , L31;
thus L37: thesis by L36 , GROUP_1:def 4;
end;
registration
cluster ( F_Real ) ->  well-unital;
coherence
proof
let C21 being (Element of ( F_Real ));
thus L38: thesis;
end;
end;
registration
cluster  well-unital for non  empty non  empty non  empty non  empty multLoopStr_0;
existence
proof
take ( F_Real );
thus L40: thesis;
end;
end;
definition
let C22 being non  empty doubleLoopStr;
attr C22 is  distributive
means
:L42: (for B21 , B22 , B23 being (Element of C22) holds (( B21 * ( B22 + B23 ) ) = ( ( B21 * B22 ) + ( B21 * B23 ) ) & ( ( B22 + B23 ) * B21 ) = ( ( B22 * B21 ) + ( B23 * B21 ) )));
end;
definition
let C23 being non  empty multLoopStr;
attr C23 is  left_unital
means
:L44: (for B24 being (Element of C23) holds ( ( 1. C23 ) * B24 ) = B24);
end;
definition
let C24 being non  empty multLoopStr_0;
redefine attr C24 is  almost_left_invertible
means
:L46: (for B25 being (Element of C24) holds (B25 <> ( 0. C24 ) implies (ex B26 being (Element of C24) st ( B26 * B25 ) = ( 1. C24 ))));
compatibility
proof
thus L47: (C24 is  almost_left_invertible implies (for B27 being (Element of C24) holds (B27 <> ( 0. C24 ) implies (ex B28 being (Element of C24) st ( B28 * B27 ) = ( 1. C24 )))))
proof
assume L48: C24 is  almost_left_invertible;
let C25 being (Element of C24);
assume L49: C25 <> ( 0. C24 );
L50: C25 is  left_invertible by L49 , L48 , ALGSTR_0:def 39;
thus L51: thesis by L50 , ALGSTR_0:def 27;
end;

assume L52: (for B29 being (Element of C24) holds (B29 <> ( 0. C24 ) implies (ex B30 being (Element of C24) st ( B30 * B29 ) = ( 1. C24 ))));
let C26 being (Element of C24);
assume L53: C26 <> ( 0. C24 );
thus L54: (ex B31 being (Element of C24) st ( B31 * C26 ) = ( 1. C24 )) by L53 , L52;
end;
end;
set D4 = ( F_Real );
registration
cluster ( F_Real ) ->  unital;
coherence
proof
reconsider D5 = 1 as (Element of D4);
take D5;
thus L56: thesis;
end;
end;
registration
cluster ( F_Real ) ->  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  left_unital  right_unital  distributive  almost_left_invertible non  degenerated;
coherence
proof
thus L58: (for B32 , B33 , B34 being (Element of ( F_Real )) holds ( ( B32 + B33 ) + B34 ) = ( B32 + ( B33 + B34 ) ));
thus L59: (for B35 being (Element of ( F_Real )) holds ( B35 + ( 0. ( F_Real ) ) ) = B35);
thus L60: ( F_Real ) is  right_complementable
proof
let C27 being (Element of ( F_Real ));
reconsider D6 = C27 as (Element of ( REAL ));
reconsider D7 = ( - D6 ) as (Element of ( F_Real ));
take D7;
thus L61: thesis;
end;

thus L62: (for B36 , B37 being (Element of ( F_Real )) holds ( B36 + B37 ) = ( B37 + B36 ));
thus L63: (for B38 , B39 being (Element of ( F_Real )) holds ( B38 * B39 ) = ( B39 * B38 ));
thus L64: (for B40 , B41 , B42 being (Element of ( F_Real )) holds ( ( B40 * B41 ) * B42 ) = ( B40 * ( B41 * B42 ) ));
thus L65: (for B43 being (Element of ( F_Real )) holds ( ( 1. ( F_Real ) ) * B43 ) = B43);
thus L66: (for B44 being (Element of ( F_Real )) holds ( B44 * ( 1. ( F_Real ) ) ) = B44);
thus L67: (for B45 , B46 , B47 being (Element of ( F_Real )) holds (( B45 * ( B46 + B47 ) ) = ( ( B45 * B46 ) + ( B45 * B47 ) ) & ( ( B46 + B47 ) * B45 ) = ( ( B46 * B45 ) + ( B47 * B45 ) )));
thus L68:now
let C28 being (Element of ( F_Real ));
reconsider D8 = C28 as (Element of ( REAL ));
assume L69: C28 <> ( 0. ( F_Real ) );
reconsider D9 = ( D8 " ) as (Element of ( F_Real ));
take D10 = D9;
thus L70: ( D10 * C28 ) = ( 1. ( F_Real ) ) by L69 , XCMPLX_0:def 7;
end;
thus L71: ( 0. ( F_Real ) ) <> ( 1. ( F_Real ) );
end;
end;
registration
let C29 being (Element of ( F_Real ));
let C30 being  real number;
identify - C29 with - C30 when C29 = C30;
compatibility
proof
reconsider D11 = ( - C30 ) as (Element of D4);
assume L73: C30 = C29;
L74: ( D11 + C29 ) = ( 0. D4 ) by L73;
thus L75: thesis by L74 , RLVECT_1:6;
end;
end;
L77: (for B48 being non  empty doubleLoopStr holds (B48 is  distributive implies B48 is  right-distributive  left-distributive))
proof
let C31 being non  empty doubleLoopStr;
assume L78: C31 is  distributive;
L79: (for B49 , B50 , B51 being (Element of C31) holds ( B49 * ( B50 + B51 ) ) = ( ( B49 * B50 ) + ( B49 * B51 ) )) by L78 , L42;
thus L80: C31 is  right-distributive by L79 , L19;
L81: (for B52 , B53 , B54 being (Element of C31) holds ( ( B53 + B54 ) * B52 ) = ( ( B53 * B52 ) + ( B54 * B52 ) )) by L78 , L42;
thus L82: thesis by L81 , L20;
end;
registration
cluster  distributive ->  left-distributive  right-distributive for non  empty non  empty non  empty non  empty doubleLoopStr;
coherence by L77;
cluster  left-distributive  right-distributive ->  distributive for non  empty non  empty non  empty non  empty doubleLoopStr;
coherence
proof
let C32 being non  empty doubleLoopStr;
assume L83: ((for B55 , B56 , B57 being (Element of C32) holds ( ( B56 + B57 ) * B55 ) = ( ( B56 * B55 ) + ( B57 * B55 ) )) & (for B58 , B59 , B60 being (Element of C32) holds ( B58 * ( B59 + B60 ) ) = ( ( B58 * B59 ) + ( B58 * B60 ) )));
thus L84: (for B61 , B62 , B63 being (Element of C32) holds (( B61 * ( B62 + B63 ) ) = ( ( B61 * B62 ) + ( B61 * B63 ) ) & ( ( B62 + B63 ) * B61 ) = ( ( B62 * B61 ) + ( B63 * B61 ) ))) by L83;
end;
end;
registration
cluster  well-unital ->  left_unital  right_unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence
proof
let C33 being non  empty multLoopStr;
assume L86: C33 is  well-unital;
thus L87: (for B64 being (Element of C33) holds ( ( 1. C33 ) * B64 ) = B64) by L86 , L29;
thus L88: (for B65 being (Element of C33) holds ( B65 * ( 1. C33 ) ) = B65) by L86 , L29;
end;
cluster  left_unital  right_unital ->  unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence
proof
let C34 being non  empty multLoopStr;
assume that
L89: ((for B66 being (Element of C34) holds ( ( 1. C34 ) * B66 ) = B66) & (for B67 being (Element of C34) holds ( B67 * ( 1. C34 ) ) = B67));
take ( 1. C34 );
thus L90: thesis by L89;
end;
end;
registration
cluster  commutative  associative for non  empty non  empty non  empty non  empty multMagma;
existence
proof
take ( F_Real );
thus L92: thesis;
end;
end;
registration
cluster  commutative  associative  unital for non  empty non  empty non  empty non  empty multLoopStr;
existence
proof
take ( F_Real );
thus L94: thesis;
end;
end;
registration
cluster  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  left_unital  right_unital  distributive  almost_left_invertible non  degenerated  well-unital  strict for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( F_Real );
thus L96: thesis;
end;
end;
definition
mode Field
 is  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive  almost_left_invertible non  degenerated non  empty doubleLoopStr;
end;
theorem
L99: ( 1. ( F_Real ) ) = 1;
theorem
L100: (for B68 , B69 , B70 being (Element of ( F_Real )) holds (( B68 + B69 ) = ( B69 + B68 ) & ( ( B68 + B69 ) + B70 ) = ( B68 + ( B69 + B70 ) ) & ( B68 + ( 0. ( F_Real ) ) ) = B68 & ( B68 + ( - B68 ) ) = ( 0. ( F_Real ) ) & ( B68 * B69 ) = ( B69 * B68 ) & ( ( B68 * B69 ) * B70 ) = ( B68 * ( B69 * B70 ) ) & ( ( 1. ( F_Real ) ) * B68 ) = B68 & (B68 <> ( 0. ( F_Real ) ) implies (ex B71 being (Element of ( F_Real )) st ( B71 * B68 ) = ( 1. ( F_Real ) ))) & ( B68 * ( B69 + B70 ) ) = ( ( B68 * B69 ) + ( B68 * B70 ) ) & ( ( B69 + B70 ) * B68 ) = ( ( B69 * B68 ) + ( B70 * B68 ) ))) by L46;
theorem
L101: (for B72 being non  empty doubleLoopStr holds ((for B73 , B74 , B75 being (Element of B72) holds ((B73 <> ( 0. B72 ) implies (ex B76 being (Element of B72) st ( B76 * B73 ) = ( 1. B72 ))) & ( B73 * ( B74 + B75 ) ) = ( ( B73 * B74 ) + ( B73 * B75 ) ) & ( ( B74 + B75 ) * B73 ) = ( ( B74 * B73 ) + ( B75 * B73 ) ))) iff B72 is  distributive  almost_left_invertible non  empty  distributive  almost_left_invertible non  empty  distributive  almost_left_invertible non  empty  distributive  almost_left_invertible non  empty doubleLoopStr)) by L42 , L46;
registration
cluster  well-unital ->  unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence;
end;
theorem
L103: (for B77 being  associative  commutative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr holds (for B78 , B79 , B80 being (Element of B77) holds ((B78 <> ( 0. B77 ) & ( B78 * B79 ) = ( B78 * B80 )) implies B79 = B80)))
proof
let C35 being  associative  commutative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr;
let C36 , C37 , C38 being (Element of C35);
assume L104: C36 <> ( 0. C35 );
consider C39 being (Element of C35) such that L105: ( C39 * C36 ) = ( 1. C35 ) by L104 , L46;
L106: (( ( C39 * C36 ) * C37 ) = ( C39 * ( C36 * C37 ) ) & ( C39 * ( C36 * C38 ) ) = ( ( C39 * C36 ) * C38 )) by GROUP_1:def 3;
assume L107: ( C36 * C37 ) = ( C36 * C38 );
L108: ( ( C36 * C39 ) * C37 ) = C38 by L107 , L105 , L106 , L44;
thus L109: thesis by L108 , L105 , L44;
end;
definition
let C40 being  associative  commutative  well-unital  almost_left_invertible non  empty doubleLoopStr;
let C41 being (Element of C40);
assume L110: C41 <> ( 0. C40 );
redefine func C41 " means 
:L111: ( it * C41 ) = ( 1. C40 );
compatibility
proof
let C42 being (Element of C40);
L112: C41 is  left_invertible by L110 , ALGSTR_0:def 39;
consider C43 being (Element of C40) such that L113: ( C43 * C41 ) = ( 1. C40 ) by L112 , ALGSTR_0:def 27;
L114: C41 is  right_mult-cancelable
proof
let C44 , C45 being (Element of C40);
assume L115: ( C44 * C41 ) = ( C45 * C41 );
thus L116: C44 = ( C44 * ( 1. C40 ) ) by L29
.= ( ( C45 * C41 ) * C43 ) by L113 , L115 , GROUP_1:def 3
.= ( C45 * ( 1. C40 ) ) by L113 , GROUP_1:def 3
.= C45 by L29;
end;
thus L117: thesis by L114 , L112 , ALGSTR_0:def 35;
end;
end;
definition
let C46 being  associative  commutative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr;
let C47 , C48 being (Element of C46);
func C47 / C48 -> (Element of C46) equals 
( C47 * ( C48 " ) );
coherence;
end;
theorem
L120: (for B81 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B82 being (Element of B81) holds ( B82 * ( 0. B81 ) ) = ( 0. B81 )))
proof
let C49 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C50 being (Element of C49);
L121: ( ( C50 * ( 0. C49 ) ) + ( 0. C49 ) ) = ( ( C50 * ( ( 0. C49 ) + ( 0. C49 ) ) ) + ( 0. C49 ) ) by RLVECT_1:4
.= ( C50 * ( ( 0. C49 ) + ( 0. C49 ) ) ) by RLVECT_1:4
.= ( ( C50 * ( 0. C49 ) ) + ( C50 * ( 0. C49 ) ) ) by L19;
thus L122: thesis by L121 , RLVECT_1:8;
end;
theorem
L123: (for B83 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr holds (for B84 being (Element of B83) holds ( ( 0. B83 ) * B84 ) = ( 0. B83 )))
proof
let C51 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr;
let C52 being (Element of C51);
L124: ( ( ( 0. C51 ) * C52 ) + ( 0. C51 ) ) = ( ( ( ( 0. C51 ) + ( 0. C51 ) ) * C52 ) + ( 0. C51 ) ) by RLVECT_1:4
.= ( ( ( 0. C51 ) + ( 0. C51 ) ) * C52 ) by RLVECT_1:4
.= ( ( ( 0. C51 ) * C52 ) + ( ( 0. C51 ) * C52 ) ) by L20;
thus L125: thesis by L124 , RLVECT_1:8;
end;
theorem
L126: (for B85 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B86 , B87 being (Element of B85) holds ( B86 * ( - B87 ) ) = ( - ( B86 * B87 ) )))
proof
let C53 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C54 , C55 being (Element of C53);
L127: ( ( C54 * C55 ) + ( C54 * ( - C55 ) ) ) = ( C54 * ( C55 + ( - C55 ) ) ) by L19
.= ( C54 * ( 0. C53 ) ) by RLVECT_1:def 10
.= ( 0. C53 ) by L120;
thus L128: thesis by L127 , RLVECT_1:def 10;
end;
theorem
L129: (for B88 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr holds (for B89 , B90 being (Element of B88) holds ( ( - B89 ) * B90 ) = ( - ( B89 * B90 ) )))
proof
let C56 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr;
let C57 , C58 being (Element of C56);
L130: ( ( C57 * C58 ) + ( ( - C57 ) * C58 ) ) = ( ( C57 + ( - C57 ) ) * C58 ) by L20
.= ( ( 0. C56 ) * C58 ) by RLVECT_1:def 10
.= ( 0. C56 ) by L123;
thus L131: thesis by L130 , RLVECT_1:def 10;
end;
theorem
L132: (for B91 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B92 , B93 being (Element of B91) holds ( ( - B92 ) * ( - B93 ) ) = ( B92 * B93 )))
proof
let C59 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C60 , C61 being (Element of C59);
thus L133: ( ( - C60 ) * ( - C61 ) ) = ( - ( C60 * ( - C61 ) ) ) by L129
.= ( - ( - ( C60 * C61 ) ) ) by L126
.= ( C60 * C61 ) by RLVECT_1:17;
end;
theorem
L134: (for B94 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B95 , B96 , B97 being (Element of B94) holds ( B95 * ( B96 - B97 ) ) = ( ( B95 * B96 ) - ( B95 * B97 ) )))
proof
let C62 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C63 , C64 , C65 being (Element of C62);
L135: ( C63 * ( C64 - C65 ) ) = ( ( C63 * C64 ) + ( C63 * ( - C65 ) ) ) by L19
.= ( ( C63 * C64 ) - ( C63 * C65 ) ) by L126;
thus L136: thesis by L135;
end;
theorem
L137: (for B98 being  add-associative  right_zeroed  right_complementable  associative  commutative  well-unital  almost_left_invertible  distributive non  empty doubleLoopStr holds (for B99 , B100 being (Element of B98) holds (( B99 * B100 ) = ( 0. B98 ) iff (B99 = ( 0. B98 ) or B100 = ( 0. B98 )))))
proof
let C66 being  add-associative  right_zeroed  right_complementable  associative  commutative  well-unital  almost_left_invertible  distributive non  empty doubleLoopStr;
let C67 , C68 being (Element of C66);
L138: (( C67 * C68 ) = ( 0. C66 ) implies (C67 = ( 0. C66 ) or C68 = ( 0. C66 )))
proof
assume L139: ( C67 * C68 ) = ( 0. C66 );
assume L140: C67 <> ( 0. C66 );
L141: ( ( C67 " ) * ( 0. C66 ) ) = ( ( ( C67 " ) * C67 ) * C68 ) by L139 , GROUP_1:def 3
.= ( ( 1. C66 ) * C68 ) by L140 , L111
.= C68 by L44;
thus L142: thesis by L141 , L123;
end;
thus L143: thesis by L138 , L123;
end;
theorem
L144: (for B101 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr holds (for B102 , B103 , B104 being (Element of B101) holds ( ( B102 - B103 ) * B104 ) = ( ( B102 * B104 ) - ( B103 * B104 ) )))
proof
let C69 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr;
let C70 , C71 , C72 being (Element of C69);
thus L145: ( ( C70 - C71 ) * C72 ) = ( ( C70 * C72 ) + ( ( - C71 ) * C72 ) ) by L20
.= ( ( C70 * C72 ) - ( C71 * C72 ) ) by L129;
end;
definition
let C73 being 1-sorted;
struct (addLoopStr) VectSpStr over C73(# carrier -> set , addF -> (BinOp of the carrier) , ZeroF -> (Element of the carrier) , lmult -> (Function of [: (the carrier of C73) , the carrier :] , the carrier) #);
end;
registration
let C74 being 1-sorted;
cluster non  empty  strict for VectSpStr over C74;
existence
proof
set D12 = the non  empty set;
set D13 = the (BinOp of D12);
set D14 = the (Element of D12);
set D15 = the (Function of [: (the carrier of C74) , D12 :] , D12);
take VectSpStr (# D12 , D13 , D14 , D15 #);
thus L147: (the carrier of VectSpStr (# D12 , D13 , D14 , D15 #)) is non  empty;
thus L148: thesis;
end;
end;
registration
let C75 being 1-sorted;
let C76 being non  empty set;
let C77 being (BinOp of C76);
let C78 being (Element of C76);
let C79 being (Function of [: (the carrier of C75) , C76 :] , C76);
cluster VectSpStr (# C76 , C77 , C78 , C79 #) -> non  empty;
coherence;
end;
definition
let C80 being 1-sorted;
mode Scalar of C80
 is (Element of C80);
end;
definition
let C81 being 1-sorted;
let C82 being VectSpStr over C81;
mode Scalar of C82
 is (Scalar of C81);
mode Vector of C82
 is (Element of C82);
end;
definition
let C83 being non  empty 1-sorted;
let C84 being non  empty VectSpStr over C83;
let C85 being (Element of C83);
let C86 being (Element of C84);
func C85 * C86 -> (Element of C84) equals 
( (the lmult of C84) . (C85 , C86) );
coherence;
end;
definition
let C87 being non  empty addLoopStr;
func comp C87 -> (UnOp of (the carrier of C87)) means 
(for B105 being (Element of C87) holds ( it . B105 ) = ( - B105 ));
existence
proof
deffunc H1((Element of C87)) = ( - $1 );
thus L154: (ex B106 being (UnOp of (the carrier of C87)) st (for B107 being (Element of C87) holds ( B106 . B107 ) = H1(B107))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C88 , C89 being (UnOp of (the carrier of C87));
assume that
L155: (for B108 being (Element of C87) holds ( C88 . B108 ) = ( - B108 ))
and
L156: (for B109 being (Element of C87) holds ( C89 . B109 ) = ( - B109 ));
L157:
now
let C90 being set;
assume L158: C90 in (the carrier of C87);
reconsider D16 = C90 as (Element of C87) by L158;
thus L159: ( C88 . C90 ) = ( - D16 ) by L155
.= ( C89 . C90 ) by L156;
end;
thus L160: thesis by L157 , FUNCT_2:12;
end;
end;
L162:
now
let C91 being  add-associative  right_zeroed  right_complementable  Abelian  associative  left_unital  distributive non  empty doubleLoopStr;
let C92 being (Function of [: (the carrier of C91) , (the carrier of C91) :] , (the carrier of C91));
set D17 = VectSpStr (# (the carrier of C91) , (the addF of C91) , ( 0. C91 ) , C92 #);
thus L163: D17 is  Abelian
proof
let C93 , C94 being (Element of D17);
reconsider D18 = C93 , D19 = C94 as (Element of C91);
thus L164: ( C93 + C94 ) = ( D19 + D18 ) by RLVECT_1:2
.= ( C94 + C93 );
end;

thus L165: D17 is  add-associative
proof
let C95 , C96 , C97 being (Element of D17);
reconsider D20 = C95 , D21 = C96 , D22 = C97 as (Element of C91);
thus L166: ( ( C95 + C96 ) + C97 ) = ( ( D20 + D21 ) + D22 )
.= ( D20 + ( D21 + D22 ) ) by RLVECT_1:def 3
.= ( C95 + ( C96 + C97 ) );
end;

thus L167: D17 is  right_zeroed
proof
let C98 being (Element of D17);
reconsider D23 = C98 as (Element of C91);
thus L168: ( C98 + ( 0. D17 ) ) = ( D23 + ( 0. C91 ) )
.= C98 by RLVECT_1:4;
end;

thus L169: D17 is  right_complementable
proof
let C99 being (Element of D17);
reconsider D24 = C99 as (Element of C91);
consider C100 being (Element of C91) such that L170: ( D24 + C100 ) = ( 0. C91 ) by ALGSTR_0:def 11;
reconsider D25 = C100 as (Element of D17);
take D25;
thus L171: thesis by L170;
end;

end;
L170:
now
let C101 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C102 being (Function of [: (the carrier of C101) , (the carrier of C101) :] , (the carrier of C101));
assume that
L171: C102 = (the multF of C101);
let C103 , C104 being (Element of C101);
set D26 = VectSpStr (# (the carrier of C101) , (the addF of C101) , ( 0. C101 ) , C102 #);
let C105 , C106 being (Element of D26);
reconsider D27 = C105 , D28 = C106 as (Element of C101);
thus L172: ( C103 * ( C105 + C106 ) ) = ( C103 * ( D27 + D28 ) ) by L171
.= ( ( C103 * D27 ) + ( C103 * D28 ) ) by L42
.= ( ( C103 * C105 ) + ( C103 * C106 ) ) by L171;
thus L173: ( ( C103 + C104 ) * C105 ) = ( ( C103 + C104 ) * D27 ) by L171
.= ( ( C103 * D27 ) + ( C104 * D27 ) ) by L42
.= ( ( C103 * C105 ) + ( C104 * C105 ) ) by L171;
thus L174: ( ( C103 * C104 ) * C105 ) = ( ( C103 * C104 ) * D27 ) by L171
.= ( C103 * ( C104 * D27 ) ) by GROUP_1:def 3
.= ( C103 * ( C104 * C105 ) ) by L171;
thus L175: ( ( 1. C101 ) * C105 ) = ( ( 1. C101 ) * D27 ) by L171
.= C105 by L44;
end;
definition
let C107 being non  empty doubleLoopStr;
let C108 being non  empty VectSpStr over C107;
attr C108 is  vector-distributive
means
:L176: (for B110 being (Element of C107) holds (for B111 , B112 being (Element of C108) holds ( B110 * ( B111 + B112 ) ) = ( ( B110 * B111 ) + ( B110 * B112 ) )));
attr C108 is  scalar-distributive
means
:L177: (for B113 , B114 being (Element of C107) holds (for B115 being (Element of C108) holds ( ( B113 + B114 ) * B115 ) = ( ( B113 * B115 ) + ( B114 * B115 ) )));
attr C108 is  scalar-associative
means
:L178: (for B116 , B117 being (Element of C107) holds (for B118 being (Element of C108) holds ( ( B116 * B117 ) * B118 ) = ( B116 * ( B117 * B118 ) )));
attr C108 is  scalar-unital
means
:L179: (for B119 being (Element of C108) holds ( ( 1. C107 ) * B119 ) = B119);
end;
registration
let C109 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
cluster  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable  Abelian  strict for non  empty non  empty non  empty non  empty VectSpStr over C109;
existence
proof
take D29 = VectSpStr (# (the carrier of C109) , (the addF of C109) , ( 0. C109 ) , (the multF of C109) #);
thus L181: (for B120 , B121 being (Element of C109) holds (for B122 being (Element of D29) holds ( ( B120 + B121 ) * B122 ) = ( ( B120 * B122 ) + ( B121 * B122 ) ))) by L170;
thus L182: (for B123 being (Element of C109) holds (for B124 , B125 being (Element of D29) holds ( B123 * ( B124 + B125 ) ) = ( ( B123 * B124 ) + ( B123 * B125 ) ))) by L170;
thus L183: (for B126 , B127 being (Element of C109) holds (for B128 being (Element of D29) holds ( ( B126 * B127 ) * B128 ) = ( B126 * ( B127 * B128 ) ))) by L170;
thus L184: (for B129 being (Element of D29) holds ( ( 1. C109 ) * B129 ) = B129) by L170;
thus L185: thesis by L162;
end;
end;
definition
let C110 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
mode VectSp of C110
 is  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable  Abelian non  empty VectSpStr over C110;
end;
theorem
L188: (for B130 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B131 being (Element of B130) holds (for B132 being  add-associative  right_zeroed  right_complementable  scalar-distributive  vector-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B130 holds (for B133 being (Element of B132) holds (( ( 0. B130 ) * B133 ) = ( 0. B132 ) & ( ( - ( 1. B130 ) ) * B133 ) = ( - B133 ) & ( B131 * ( 0. B132 ) ) = ( 0. B132 ))))))
proof
let C111 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C112 being (Element of C111);
let C113 being  add-associative  right_zeroed  right_complementable  scalar-distributive  vector-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C111;
let C114 being (Element of C113);
L189: ( C114 + ( ( 0. C111 ) * C114 ) ) = ( ( ( 1. C111 ) * C114 ) + ( ( 0. C111 ) * C114 ) ) by L179
.= ( ( ( 1. C111 ) + ( 0. C111 ) ) * C114 ) by L177
.= ( ( 1. C111 ) * C114 ) by RLVECT_1:4
.= C114 by L179
.= ( C114 + ( 0. C113 ) ) by RLVECT_1:4;
thus L190: ( ( 0. C111 ) * C114 ) = ( 0. C113 ) by L189 , RLVECT_1:8;
L191: ( ( ( - ( 1. C111 ) ) * C114 ) + C114 ) = ( ( ( - ( 1. C111 ) ) * C114 ) + ( ( 1. C111 ) * C114 ) ) by L179
.= ( ( ( 1. C111 ) + ( - ( 1. C111 ) ) ) * C114 ) by L177
.= ( 0. C113 ) by L190 , RLVECT_1:def 10;
L192: ( ( ( - ( 1. C111 ) ) * C114 ) + ( C114 + ( - C114 ) ) ) = ( ( 0. C113 ) + ( - C114 ) ) by L191 , RLVECT_1:def 3;
L193: ( ( 0. C113 ) + ( - C114 ) ) = ( ( ( - ( 1. C111 ) ) * C114 ) + ( 0. C113 ) ) by L192 , RLVECT_1:5
.= ( ( - ( 1. C111 ) ) * C114 ) by RLVECT_1:4;
thus L194: ( ( - ( 1. C111 ) ) * C114 ) = ( - C114 ) by L193 , RLVECT_1:4;
L195: ( C112 * ( 0. C113 ) ) = ( ( C112 * ( 0. C111 ) ) * C114 ) by L190 , L178
.= ( 0. C113 ) by L190 , L120;
thus L196: thesis by L195;
end;
theorem
L197: (for R1 being Field holds (for R2 being (Element of R1) holds (for R3 being (VectSp of R1) holds (for R4 being (Element of R3) holds (( R2 * R4 ) = ( 0. R3 ) iff (R2 = ( 0. R1 ) or R4 = ( 0. R3 )))))))
proof
let R1 being Field;
let R2 being (Element of R1);
let R3 being (VectSp of R1);
let R4 being (Element of R3);
L198: (( R2 * R4 ) = ( 0. R3 ) implies (R2 = ( 0. R1 ) or R4 = ( 0. R3 )))
proof
assume L199: ( R2 * R4 ) = ( 0. R3 );
L200: ( ( ( R2 " ) * R2 ) * R4 ) = ( ( R2 " ) * ( 0. R3 ) ) by L199 , L178
.= ( 0. R3 ) by L188;
assume L201: R2 <> ( 0. R1 );
L202: ( 0. R3 ) = ( ( 1. R1 ) * R4 ) by L201 , L200 , L111;
thus L203: thesis by L202 , L179;
end;
thus L204: thesis by L198 , L188;
end;
theorem
L205: (for B134 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B135 , B136 being (Element of B134) holds (( B135 + B136 ) = ( 0. B134 ) iff ( - B135 ) = B136)))
proof
let C115 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C116 , C117 being (Element of C115);
L206: (( C116 + C117 ) = ( 0. C115 ) implies ( - C116 ) = C117)
proof
assume L207: ( C116 + C117 ) = ( 0. C115 );
thus L208: C117 = ( ( 0. C115 ) + C117 ) by RLVECT_1:4
.= ( ( ( - C116 ) + C116 ) + C117 ) by RLVECT_1:5
.= ( ( - C116 ) + ( 0. C115 ) ) by L207 , RLVECT_1:def 3
.= ( - C116 ) by RLVECT_1:4;
end;
thus L209: thesis by L206 , RLVECT_1:5;
end;
L210: (for B137 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B138 , B139 being (Element of B137) holds ( - ( B139 + ( - B138 ) ) ) = ( B138 - B139 )))
proof
let C118 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C119 , C120 being (Element of C118);
L211: ( - ( C120 + ( - C119 ) ) ) = ( ( - ( - C119 ) ) - C120 ) by RLVECT_1:30;
thus L212: thesis by L211 , RLVECT_1:17;
end;
L213: (for B140 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B141 , B142 being (Element of B140) holds ( - ( ( - B141 ) - B142 ) ) = ( B142 + B141 )))
proof
let C121 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C122 , C123 being (Element of C121);
L214: ( - ( ( - C122 ) - C123 ) ) = ( C123 + ( - ( - C122 ) ) ) by RLVECT_1:33;
thus L215: thesis by L214 , RLVECT_1:17;
end;
theorem
L216: (for B143 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B144 , B145 , B146 being (Element of B143) holds (( - ( B145 + B146 ) ) = ( ( - B146 ) - B145 ) & ( - ( B146 + ( - B145 ) ) ) = ( B145 - B146 ) & ( - ( B145 - B146 ) ) = ( B146 + ( - B145 ) ) & ( - ( ( - B145 ) - B146 ) ) = ( B146 + B145 ) & ( B144 - ( B146 + B145 ) ) = ( ( B144 - B145 ) - B146 )))) by L210 , L213 , RLVECT_1:27 , RLVECT_1:30 , RLVECT_1:33;
theorem
L217: (for B147 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B148 being (Element of B147) holds (( ( 0. B147 ) - B148 ) = ( - B148 ) & ( B148 - ( 0. B147 ) ) = B148))) by RLVECT_1:13 , RLVECT_1:14;
theorem
L218: (for B149 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B150 , B151 being (Element of B149) holds ((( B150 + ( - B151 ) ) = ( 0. B149 ) iff B150 = B151) & (( B150 - B151 ) = ( 0. B149 ) iff B150 = B151))))
proof
let C124 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C125 , C126 being (Element of C124);
L219: (( C125 + ( - C126 ) ) = ( 0. C124 ) implies C125 = C126)
proof
assume L220: ( C125 + ( - C126 ) ) = ( 0. C124 );
L221: ( C125 + ( ( - C126 ) + C126 ) ) = ( ( 0. C124 ) + C126 ) by L220 , RLVECT_1:def 3;
L222: ( C125 + ( 0. C124 ) ) = ( ( 0. C124 ) + C126 ) by L221 , RLVECT_1:5;
L223: C125 = ( ( 0. C124 ) + C126 ) by L222 , RLVECT_1:4;
thus L224: thesis by L223 , RLVECT_1:4;
end;
thus L225: thesis by L219 , RLVECT_1:5;
end;
theorem
L226: (for R1 being Field holds (for R2 being (Element of R1) holds (for R3 being (VectSp of R1) holds (for R4 being (Element of R3) holds (R2 <> ( 0. R1 ) implies ( ( R2 " ) * ( R2 * R4 ) ) = R4)))))
proof
let R1 being Field;
let R2 being (Element of R1);
let R3 being (VectSp of R1);
let R4 being (Element of R3);
assume L227: R2 <> ( 0. R1 );
L228: ( ( R2 " ) * ( R2 * R4 ) ) = ( ( ( R2 " ) * R2 ) * R4 ) by L178
.= ( ( 1. R1 ) * R4 ) by L227 , L111
.= R4 by L179;
thus L229: thesis by L228;
end;
theorem
L230: (for B152 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B153 being  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable non  empty VectSpStr over B152 holds (for B154 being (Element of B152) holds (for B155 , B156 being (Element of B153) holds (( - ( B154 * B155 ) ) = ( ( - B154 ) * B155 ) & ( B156 - ( B154 * B155 ) ) = ( B156 + ( ( - B154 ) * B155 ) ))))))
proof
let C127 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C128 being  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable non  empty VectSpStr over C127;
let C129 being (Element of C127);
let C130 , C131 being (Element of C128);
L231: ( - ( C129 * C130 ) ) = ( ( - ( 1. C127 ) ) * ( C129 * C130 ) ) by L188
.= ( ( ( - ( 1. C127 ) ) * C129 ) * C130 ) by L178
.= ( ( - ( ( 1. C127 ) * C129 ) ) * C130 ) by L129;
thus L232: ( - ( C129 * C130 ) ) = ( ( - C129 ) * C130 ) by L231 , L44;
thus L233: thesis by L231 , L44;
end;
registration
cluster  commutative  left_unital ->  right_unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence
proof
let C132 being non  empty multLoopStr;
assume L234: C132 is  commutative  left_unital;
let C133 being (Scalar of C132);
L235: (for B157 being  commutative non  empty multMagma holds (for B158 , B159 being (Element of B157) holds ( B158 * B159 ) = ( B159 * B158 )));
L236: ( C133 * ( 1. C132 ) ) = ( ( 1. C132 ) * C133 ) by L235 , L234;
thus L237: thesis by L236 , L234 , L44;
end;
end;
theorem
L239: (for B160 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  right_unital  distributive non  empty doubleLoopStr holds (for B161 being  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable non  empty VectSpStr over B160 holds (for B162 being (Element of B160) holds (for B163 being (Element of B161) holds ( B162 * ( - B163 ) ) = ( - ( B162 * B163 ) )))))
proof
let C134 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  right_unital  distributive non  empty doubleLoopStr;
let C135 being  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable non  empty VectSpStr over C134;
let C136 being (Element of C134);
let C137 being (Element of C135);
L240: ( C136 * ( - C137 ) ) = ( C136 * ( ( - ( 1. C134 ) ) * C137 ) ) by L188
.= ( ( C136 * ( - ( 1. C134 ) ) ) * C137 ) by L178
.= ( ( - ( C136 * ( 1. C134 ) ) ) * C137 ) by L126
.= ( ( - C136 ) * C137 ) by L22;
thus L241: thesis by L240 , L230;
end;
theorem
L242: (for B164 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  right_unital  distributive non  empty doubleLoopStr holds (for B165 being  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable non  empty VectSpStr over B164 holds (for B166 being (Element of B164) holds (for B167 , B168 being (Element of B165) holds ( B166 * ( B167 - B168 ) ) = ( ( B166 * B167 ) - ( B166 * B168 ) )))))
proof
let C138 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  right_unital  distributive non  empty doubleLoopStr;
let C139 being  scalar-distributive  vector-distributive  scalar-associative  scalar-unital  add-associative  right_zeroed  right_complementable non  empty VectSpStr over C138;
let C140 being (Element of C138);
let C141 , C142 being (Element of C139);
L243: ( C140 * ( C141 - C142 ) ) = ( ( C140 * C141 ) + ( C140 * ( - C142 ) ) ) by L176
.= ( ( C140 * C141 ) + ( - ( C140 * C142 ) ) ) by L239;
thus L244: thesis by L243;
end;
theorem
L245: (for B169 being  add-associative  right_zeroed  right_complementable  commutative  associative  well-unital non  degenerated  almost_left_invertible  distributive non  empty doubleLoopStr holds (for B170 being (Element of B169) holds (B170 <> ( 0. B169 ) implies ( ( B170 " ) " ) = B170)))
proof
let C143 being  add-associative  right_zeroed  right_complementable  commutative  associative  well-unital non  degenerated  almost_left_invertible  distributive non  empty doubleLoopStr;
let C144 being (Element of C143);
assume L246: C144 <> ( 0. C143 );
L247: (C144 <> ( 0. C143 ) implies ( C144 " ) <> ( 0. C143 ))
proof
assume L248: C144 <> ( 0. C143 );
assume L249: (not thesis);
L250: ( 1. C143 ) = ( C144 * ( 0. C143 ) ) by L249 , L248 , L111;
thus L251: contradiction by L250 , L123;
end;
L252: ( ( C144 " ) * ( ( C144 " ) " ) ) = ( 1. C143 ) by L247 , L246 , L111;
L253: ( ( C144 * ( C144 " ) ) * ( ( C144 " ) " ) ) = ( C144 * ( 1. C143 ) ) by L252 , GROUP_1:def 3;
L254: ( ( 1. C143 ) * ( ( C144 " ) " ) ) = ( C144 * ( 1. C143 ) ) by L253 , L246 , L111;
L255: ( ( C144 " ) " ) = ( C144 * ( 1. C143 ) ) by L254 , L29;
thus L256: thesis by L255 , L29;
end;
theorem
L257: (for B171 being Field holds (for B172 being (Element of B171) holds (B172 <> ( 0. B171 ) implies (( B172 " ) <> ( 0. B171 ) & ( - ( B172 " ) ) <> ( 0. B171 )))))
proof
let C145 being Field;
let C146 being (Element of C145);
assume L258: C146 <> ( 0. C145 );
thus L259:now
assume L260: ( C146 " ) = ( 0. C145 );
L261: ( 1. C145 ) = ( C146 * ( 0. C145 ) ) by L260 , L258 , L111;
thus L262: contradiction by L261 , L123;
end;
assume L263: ( - ( C146 " ) ) = ( 0. C145 );
L264: ( ( 1. C145 ) * ( C146 " ) ) = ( ( - ( 1. C145 ) ) * ( 0. C145 ) ) by L263 , L132;
L265: ( ( 1. C145 ) * ( C146 " ) ) = ( 0. C145 ) by L264 , L123;
L266: ( C146 * ( C146 " ) ) = ( C146 * ( 0. C145 ) ) by L265 , L44;
L267: ( 1. C145 ) = ( C146 * ( 0. C145 ) ) by L266 , L258 , L111;
thus L268: contradiction by L267 , L123;
end;
theorem
L269: ( ( 1. ( F_Real ) ) + ( 1. ( F_Real ) ) ) <> ( 0. ( F_Real ) );
definition
let C147 being non  empty addLoopStr;
attr C147 is  Fanoian
means
:L270: (for B173 being (Element of C147) holds (( B173 + B173 ) = ( 0. C147 ) implies B173 = ( 0. C147 )));
end;
registration
cluster  Fanoian for non  empty non  empty non  empty non  empty addLoopStr;
existence
proof
take D30 = ( F_Real );
let C148 being (Element of D30);
assume that
L272: ( C148 + C148 ) = ( 0. D30 );
L273: C148 = ( ( 1. D30 ) * C148 ) by L44;
L274: ( C148 + C148 ) = ( ( ( 1. D30 ) + ( 1. D30 ) ) * C148 ) by L273 , L42;
thus L275: thesis by L274 , L272 , L137 , L269;
end;
end;
definition
let C149 being  add-associative  right_zeroed  right_complementable  commutative  associative  well-unital  almost_left_invertible non  degenerated  distributive non  empty doubleLoopStr;
redefine attr C149 is  Fanoian
means
:L277: ( ( 1. C149 ) + ( 1. C149 ) ) <> ( 0. C149 );
compatibility
proof
thus L278: (C149 is  Fanoian implies ( ( 1. C149 ) + ( 1. C149 ) ) <> ( 0. C149 )) by L270;
assume L279: ( ( 1. C149 ) + ( 1. C149 ) ) <> ( 0. C149 );
let C150 being (Element of C149);
assume that
L280: ( C150 + C150 ) = ( 0. C149 );
L281: C150 = ( ( 1. C149 ) * C150 ) by L44;
L282: ( C150 + C150 ) = ( ( ( 1. C149 ) + ( 1. C149 ) ) * C150 ) by L281 , L42;
thus L283: thesis by L282 , L279 , L280 , L137;
end;
end;
registration
cluster  strict  Fanoian for Field;
existence
proof
L285: ( F_Real ) is  Fanoian by L277 , L269;
thus L286: thesis by L285;
end;
end;
theorem
L288: (for B174 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B175 , B176 being (Element of B174) holds (( B175 - B176 ) = ( 0. B174 ) implies B175 = B176))) by L218;
theorem
L289: (for B177 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B178 being (Element of B177) holds (( - B178 ) = ( 0. B177 ) implies B178 = ( 0. B177 ))))
proof
let C151 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C152 being (Element of C151);
L290: ( - ( - C152 ) ) = C152 by RLVECT_1:17;
thus L291: thesis by L290 , RLVECT_1:12;
end;
theorem
L292: (for B179 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B180 , B181 being (Element of B179) holds (( B180 - B181 ) = ( 0. B179 ) implies ( B181 - B180 ) = ( 0. B179 ))))
proof
let C153 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C154 , C155 being (Element of C153);
L293: ( C154 - C155 ) = ( - ( C155 - C154 ) ) by RLVECT_1:33;
thus L294: thesis by L293 , L289;
end;
theorem
L295: (for R1 being Field holds (for B182 , B183 , B184 being (Element of R1) holds (((B182 <> ( 0. R1 ) & ( ( B182 * B184 ) - B183 ) = ( 0. R1 )) implies B184 = ( B183 * ( B182 " ) )) & ((B182 <> ( 0. R1 ) & ( B183 - ( B184 * B182 ) ) = ( 0. R1 )) implies B184 = ( B183 * ( B182 " ) )))))
proof
let R1 being Field;
let C156 , C157 , C158 being (Element of R1);
thus L296: ((C156 <> ( 0. R1 ) & ( ( C156 * C158 ) - C157 ) = ( 0. R1 )) implies C158 = ( C157 * ( C156 " ) ))
proof
assume L297: C156 <> ( 0. R1 );
L298: ( ( C156 " ) * C156 ) = ( 1. R1 ) by L297 , L111;
assume L299: ( ( C156 * C158 ) - C157 ) = ( 0. R1 );
L300: ( ( C156 " ) * ( C156 * C158 ) ) = ( C157 * ( C156 " ) ) by L299 , RLVECT_1:21;
L301: ( ( ( C156 " ) * C156 ) * C158 ) = ( C157 * ( C156 " ) ) by L300 , GROUP_1:def 3;
thus L302: thesis by L301 , L298 , L29;
end;

assume L303: C156 <> ( 0. R1 );
assume L304: ( C157 - ( C158 * C156 ) ) = ( 0. R1 );
L305: ( - ( C157 - ( C158 * C156 ) ) ) = ( 0. R1 ) by L304 , RLVECT_1:12;
thus L306: thesis by L305 , L296 , L303 , RLVECT_1:33;
end;
theorem
L307: (for B185 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B186 , B187 being (Element of B185) holds ( B186 + B187 ) = ( - ( ( - B187 ) + ( - B186 ) ) )))
proof
let C159 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C160 , C161 being (Element of C159);
thus L308: ( C160 + C161 ) = ( - ( - ( C160 + C161 ) ) ) by RLVECT_1:17
.= ( - ( ( - C161 ) + ( - C160 ) ) ) by RLVECT_1:31;
end;
theorem
L309: (for B188 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B189 , B190 , B191 being (Element of B188) holds ( ( B190 + B189 ) - ( B191 + B189 ) ) = ( B190 - B191 )))
proof
let C162 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C163 , C164 , C165 being (Element of C162);
thus L310: ( ( C164 + C163 ) - ( C165 + C163 ) ) = ( ( C164 + C163 ) + ( ( - C163 ) + ( - C165 ) ) ) by RLVECT_1:31
.= ( ( ( C164 + C163 ) + ( - C163 ) ) + ( - C165 ) ) by RLVECT_1:def 3
.= ( ( C164 + ( C163 + ( - C163 ) ) ) + ( - C165 ) ) by RLVECT_1:def 3
.= ( ( C164 + ( 0. C162 ) ) + ( - C165 ) ) by RLVECT_1:5
.= ( C164 - C165 ) by RLVECT_1:4;
end;
theorem
L311: (for B192 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B193 , B194 being (Element of B192) holds ( - ( ( - B193 ) + B194 ) ) = ( ( - B194 ) + B193 )))
proof
let C166 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C167 , C168 being (Element of C166);
thus L312: ( - ( ( - C167 ) + C168 ) ) = ( ( - C168 ) + ( - ( - C167 ) ) ) by RLVECT_1:31
.= ( ( - C168 ) + C167 ) by RLVECT_1:17;
end;
theorem
L313: (for B195 being  Abelian  add-associative non  empty addLoopStr holds (for B196 , B197 , B198 being (Element of B195) holds ( ( B196 - B197 ) - B198 ) = ( ( B196 - B198 ) - B197 )))
proof
let C169 being  Abelian  add-associative non  empty addLoopStr;
let C170 , C171 , C172 being (Element of C169);
thus L314: ( ( C170 - C171 ) - C172 ) = ( ( C170 + ( - C171 ) ) + ( - C172 ) )
.= ( ( C170 + ( - C172 ) ) + ( - C171 ) ) by RLVECT_1:def 3
.= ( ( C170 - C172 ) - C171 );
end;
theorem
L315: (for B199 being AbGroup holds multMagma (# (the carrier of B199) , (the addF of B199) #) is  commutative  commutative  commutative  commutative Group)
proof
let C173 being AbGroup;
set D31 = multMagma (# (the carrier of C173) , (the addF of C173) #);
L316: (for B200 , B201 being (Element of D31) holds (for B202 , B203 being (Element of C173) holds ((B200 = B202 & B201 = B203) implies ( B200 * B201 ) = ( B202 + B203 ))));
L317: D31 is  associative  Group-like
proof
reconsider D32 = ( 0. C173 ) as (Element of D31);
thus L318: (for B204 , B205 , B206 being (Element of D31) holds ( ( B204 * B205 ) * B206 ) = ( B204 * ( B205 * B206 ) ))
proof
let C174 , C175 , C176 being (Element of D31);
reconsider D33 = C174 , D34 = C175 , D35 = C176 as (Element of C173);
thus L319: ( ( C174 * C175 ) * C176 ) = ( ( D33 + D34 ) + D35 )
.= ( D33 + ( D34 + D35 ) ) by RLVECT_1:def 3
.= ( C174 * ( C175 * C176 ) );
end;

take D32;
let C177 being (Element of D31);
reconsider D36 = C177 as (Element of C173);
thus L320: ( C177 * D32 ) = ( D36 + ( 0. C173 ) )
.= C177 by RLVECT_1:4;
reconsider D37 = ( - D36 ) as (Element of D31);
thus L321: ( D32 * C177 ) = ( D36 + ( 0. C173 ) ) by L316
.= C177 by RLVECT_1:4;
take D37;
thus L322: ( C177 * D37 ) = ( D36 + ( - D36 ) )
.= D32 by RLVECT_1:5;
thus L323: ( D37 * C177 ) = ( D36 + ( - D36 ) ) by L316
.= D32 by RLVECT_1:5;
end;
L324:
now
let C178 , C179 being (Element of D31);
reconsider D38 = C178 , D39 = C179 as (Element of C173);
thus L325: ( C178 * C179 ) = ( D39 + D38 ) by L316
.= ( C179 * C178 );
end;
thus L326: thesis by L324 , L317 , GROUP_1:def 12;
end;
begin
theorem
L327: (for B207 being  add-associative  right_zeroed  right_complementable  right-distributive  unital non  empty doubleLoopStr holds (for B208 being (Element of ( NAT )) holds (B208 > ( 0 ) implies ( ( power B207 ) . (( 0. B207 ) , B208) ) = ( 0. B207 ))))
proof
let C180 being  add-associative  right_zeroed  right_complementable  right-distributive  unital non  empty doubleLoopStr;
let C181 being (Element of ( NAT ));
assume L328: C181 > ( 0 );
L329: C181 >= ( ( 0 ) + 1 ) by L328 , NAT_1:13;
L330: ( C181 - 1 ) >= ( 0 ) by L329 , XREAL_1:19;
L331: C181 = ( ( C181 - 1 ) + 1 )
.= ( ( C181 -' 1 ) + 1 ) by L330 , XREAL_0:def 2;
thus L332: ( ( power C180 ) . (( 0. C180 ) , C181) ) = ( ( ( power C180 ) . (( 0. C180 ) , ( C181 -' 1 )) ) * ( 0. C180 ) ) by L331 , GROUP_1:def 7
.= ( 0. C180 ) by L120;
end;
registration
cluster  well-unital for non  empty non  empty non  empty non  empty multLoopStr;
existence
proof
take ( F_Real );
thus L333: thesis;
end;
end;
registration
let C182 being  well-unital non  empty multLoopStr;
identify 1_ C182 with 1. C182;
compatibility by L34;
end;
theorem
L336: (for B209 being non  empty multLoopStr holds (B209 is  well-unital implies ( 1. B209 ) = ( 1_ B209 ))) by L34;
definition
let C183 , C184 being non  empty addMagma;
let C185 being (Function of C183 , C184);
attr C185 is  additive
means
(for B210 , B211 being (Element of C183) holds ( C185 . ( B210 + B211 ) ) = ( ( C185 . B210 ) + ( C185 . B211 ) ));
end;
