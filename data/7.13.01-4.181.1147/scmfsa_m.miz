:: On the memory of SCM+FSA
::  by Library Committee
::
:: Received October 1, 2011
:: Copyright (c) 2011-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FUNCT_4,
      FUNCOP_1, RELAT_1, FUNCT_1, TARSKI, XBOOLE_0, CARD_1, NAT_1,
      ARYTM_3, FINSET_1, STRUCT_0, FSM_1, AMI_3, AMI_2, CARD_3,
      INT_1, PARTFUN1, FINSEQ_1, XXREAL_0, ZFMISC_1, SCMFSA9A,
      SCMFSA6A, SCMFSA6C, GOBRD13, MEMSTR_0, SF_MASTR, SFMASTR1, SCMBSORT,
      CLASSES1, VALUED_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      COMPLEX1, XXREAL_2, ENUMSET1, CARD_3, CLASSES1,
      ORDINAL1, NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1,
      INT_2, NAT_D, SEQ_4, VALUED_0, RFINSEQ,
      FINSEQ_2, FINSET_1, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1,
      STRUCT_0, MEMSTR_0, AMI_2, AMI_3,
      EXTPRO_1, FUNCT_7, SCMFSA_2, FUNCOP_1, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, INT_2, SCMFSA_2, RELSET_1,
      VALUED_1, AMI_3, PRE_POLY, AMISTD_1, FUNCT_7, MEMSTR_0, SCMFSA_1,
      XXREAL_2, SEQ_4, XXREAL_1, ENUMSET1, CLASSES1, VALUED_0, RFINSEQ;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, STRUCT_0, SCMFSA_2, FUNCT_4, RELAT_1,
      VALUED_1, SCMFSA10, COMPOS_1, EXTPRO_1, SCMFSA_4, MEMSTR_0,
      FINSEQ_1, AMI_3, COMPOS_0, SCM_INST, CARD_1, XXREAL_2, FINSUB_1,
      NAT_1, MEMBERED, AMI_5;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCT_1, FUNCOP_1, SCMFSA_2, FUNCT_7, XBOOLE_0, TARSKI,
      SUBSET_1, FUNCT_4, AFINSQ_1, MEMSTR_0, PARTFUN1;
 theorems FUNCT_2, RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      TARSKI, SCMFSA_2, MEMSTR_0, ENUMSET1, INT_1, FINSEQ_1, XBOOLE_0,
      XBOOLE_1, PARTFUN1, STRUCT_0, AMI_2, AMI_3, XXREAL_2, SCM_INST,
      GRFUNC_1, SUBSET_1, XXREAL_0, NAT_1, RFINSEQ, RELSET_1, CLASSES1,
      XTUPLE_0;
 schemes CLASSES1, DOMAIN_1, RECDEF_1, FRAENKEL, NAT_1, FUNCT_1, RELSET_1;

begin
set D1 = ( Start-At (( 0 ) , ( SCM+FSA )) );
set D2 = ( ( intloc ( 0 ) ) .--> 1 );
set D3 = ( the_Values_of ( SCM+FSA ) );
registration
let C1 being Nat;
let C2 being Integer;
cluster ( ( intloc C1 ) .--> C2 ) -> ( the_Values_of ( SCM+FSA ) ) -compatible;
coherence
proof
set D4 = ( ( intloc C1 ) .--> C2 );
L1: ( dom D4 ) = { ( intloc C1 ) } by FUNCOP_1:13;
L2: C2 in ( INT ) by INT_1:def 2;
L3: (( rng D4 ) = { C2 } & { C2 } c= ( INT )) by L2 , FUNCOP_1:8 , ZFMISC_1:31;
let C3 being set;
assume L4: C3 in ( dom D4 );
reconsider D5 = C3 as Int-Location by L1 , L4 , TARSKI:def 1;
L5: ( D3 . D5 ) = ( Values D5 )
.= ( INT ) by SCMFSA_2:11;
L6: ( D4 . C3 ) in ( rng D4 ) by L4 , FUNCT_1:def 3;
thus L7: ( D4 . C3 ) in ( D3 . C3 ) by L6 , L5 , L3;
end;
end;
definition
let C4 being (PartState of ( SCM+FSA ));
func Initialized C4 -> (PartState of ( SCM+FSA )) equals 
( C4 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
coherence;
projectivity
proof
let C5 , C6 being (PartState of ( SCM+FSA ));
assume L9: C5 = ( C6 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
L10: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L11: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L10 , TARSKI:def 1;
L12: ( C6 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( C6 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:14;
L13: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L14: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L13 , TARSKI:def 1;
L15: (not ( intloc ( 0 ) ) in ( dom D1 )) by SCMFSA_2:102;
L16: ( ( C6 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) . ( intloc ( 0 ) ) ) = ( ( Initialize ( C6 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) . ( intloc ( 0 ) ) ) by FUNCT_4:14
.= ( ( C6 +* ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by L15 , FUNCT_4:11
.= ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by L14 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L17: ( D1 . ( IC ( SCM+FSA ) ) ) = ( 0 ) by FUNCOP_1:72;
L18: ( IC C5 ) = ( 0 ) by L17 , L9 , L11 , L12 , FUNCT_4:13;
L19: ( IC ( SCM+FSA ) ) in ( dom C5 ) by L9 , MEMSTR_0:49;
L20: ( dom C5 ) = ( ( dom C6 ) \/ ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) ) by L9 , FUNCT_4:def 1;
L21: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L22: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L23: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L22 , TARSKI:def 1;
L24: ( intloc ( 0 ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L23 , L21 , XBOOLE_0:def 3;
L25: ( intloc ( 0 ) ) in ( dom C5 ) by L24 , L20 , XBOOLE_0:def 3;
thus L26: ( C5 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( Initialize ( C5 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:14
.= ( C5 +* ( ( IC ( SCM+FSA ) ) .--> ( 0 ) ) ) by L16 , L25 , L9 , FUNCT_7:109
.= C5 by L18 , L19 , FUNCT_7:109;
end;
end;
registration
let C7 being (PartState of ( SCM+FSA ));
cluster ( Initialized C7 ) -> ( 0 ) -started;
coherence;
end;
registration
let C8 being (FinPartState of ( SCM+FSA ));
cluster ( Initialized C8 ) ->  finite;
coherence;
end;
scheme SCMFSAEx { F1(set) -> Integer , F2(set) -> (FinSequence of ( INT )) , F3() -> (Element of ( NAT )) } : (ex B1 being (State of ( SCM+FSA )) st (( IC B1 ) = F3() & (for B2 being (Element of ( NAT )) holds (( B1 . ( intloc B2 ) ) = F1(B2) & ( B1 . ( fsloc B2 ) ) = F2(B2)))))
proof
defpred S1[ set , set ] means (ex R2 being (Element of ( NAT )) st (($1 = ( IC ( SCM+FSA ) ) & $2 = F3()) or ($1 = ( intloc R2 ) & $2 = F1(R2)) or ($1 = ( fsloc R2 ) & $2 = F2(R2))));
L30: (for B3 being set holds (B3 in (the carrier of ( SCM+FSA )) implies (ex B4 being set st S1[ B3 , B4 ])))
proof
let C9 being set;
assume L31: C9 in (the carrier of ( SCM+FSA ));
L32: C9 in ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) by L31 , STRUCT_0:4;
L33: (C9 in ( Data-Locations ( SCM+FSA ) ) or C9 in { ( IC ( SCM+FSA ) ) }) by L32 , XBOOLE_0:def 3;
L34:
now
per cases  by L33 , SCMFSA_2:100 , XBOOLE_0:def 3;
case L35: C9 in { ( IC ( SCM+FSA ) ) };
thus L36: C9 = ( IC ( SCM+FSA ) ) by L35 , TARSKI:def 1;
end;
case L37: C9 in ( Int-Locations );
L38: C9 is Int-Location by L37 , AMI_2:def 16;
thus L39: (ex B5 being (Element of ( NAT )) st C9 = ( intloc B5 )) by L38 , SCMFSA_2:8;
end;
case L40: C9 in ( FinSeq-Locations );
L41: C9 is FinSeq-Location by L40 , SCMFSA_2:def 5;
thus L42: (ex B6 being (Element of ( NAT )) st C9 = ( fsloc B6 )) by L41 , SCMFSA_2:9;
end;
end;
consider R2 being (Element of ( NAT )) such that L44: (C9 = ( IC ( SCM+FSA ) ) or C9 = ( intloc R2 ) or C9 = ( fsloc R2 )) by L34;
per cases  by L44;
suppose L45: C9 = ( IC ( SCM+FSA ) );

take D6 = F3();
thus L46: thesis by L45;
end;
suppose L47: C9 = ( intloc R2 );

take D7 = F1(R2);
thus L48: thesis by L47;
end;
suppose L49: C9 = ( fsloc R2 );

take D8 = F2(R2);
thus L50: thesis by L49;
end;
end;
consider C10 being Function such that L52: ( dom C10 ) = (the carrier of ( SCM+FSA )) and L53: (for B7 being set holds (B7 in (the carrier of ( SCM+FSA )) implies S1[ B7 , ( C10 . B7 ) ])) from CLASSES1:sch 1(L30);
L54: ( dom (the Object-Kind of ( SCM+FSA )) ) = (the carrier of ( SCM+FSA )) by FUNCT_2:def 1;
L55:
now
let C11 being set;
assume L56: C11 in ( dom (the Object-Kind of ( SCM+FSA )) );
consider R2 being (Element of ( NAT )) such that L57: ((C11 = ( IC ( SCM+FSA ) ) & ( C10 . C11 ) = F3()) or (C11 = ( intloc R2 ) & ( C10 . C11 ) = F1(R2)) or (C11 = ( fsloc R2 ) & ( C10 . C11 ) = F2(R2))) by L56 , L53 , L54;
L58: C11 in ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) by L56 , L54 , STRUCT_0:4;
L59: (C11 in ( Data-Locations ( SCM+FSA ) ) or C11 in { ( IC ( SCM+FSA ) ) }) by L58 , XBOOLE_0:def 3;
per cases  by L59 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L60: C11 in ( Int-Locations );

L61: C11 is Int-Location by L60 , AMI_2:def 16;
L62: ( ( the_Values_of ( SCM+FSA ) ) . C11 ) = ( Values ( intloc R2 ) ) by L61 , L57 , SCMFSA_2:56 , SCMFSA_2:58
.= ( INT ) by SCMFSA_2:11;
thus L63: ( C10 . C11 ) in ( ( the_Values_of ( SCM+FSA ) ) . C11 ) by L62 , L57 , L61 , INT_1:def 2 , SCMFSA_2:58;
end;
suppose L64: C11 in ( FinSeq-Locations );

L65: C11 is FinSeq-Location by L64 , SCMFSA_2:def 5;
L66: ( ( the_Values_of ( SCM+FSA ) ) . C11 ) = ( Values ( fsloc R2 ) ) by L65 , L57 , SCMFSA_2:57 , SCMFSA_2:58
.= ( ( INT ) * ) by SCMFSA_2:12;
thus L67: ( C10 . C11 ) in ( ( the_Values_of ( SCM+FSA ) ) . C11 ) by L66 , L57 , L65 , FINSEQ_1:def 11 , SCMFSA_2:57 , SCMFSA_2:58;
end;
suppose L68: C11 in { ( IC ( SCM+FSA ) ) };

L69: ( ( the_Values_of ( SCM+FSA ) ) . C11 ) = ( Values ( IC ( SCM+FSA ) ) ) by L68 , TARSKI:def 1
.= ( NAT ) by MEMSTR_0:def 6;
L70: C11 = ( IC ( SCM+FSA ) ) by L68 , TARSKI:def 1;
thus L71: ( C10 . C11 ) in ( ( the_Values_of ( SCM+FSA ) ) . C11 ) by L70 , L57 , L69 , SCMFSA_2:56 , SCMFSA_2:57;
end;
end;
reconsider D9 = C10 as (State of ( SCM+FSA )) by L55 , L52 , L54 , FUNCT_1:def 14 , PARTFUN1:def 2 , RELAT_1:def 18;
take D9;
L73: (ex R2 being (Element of ( NAT )) st ((( IC ( SCM+FSA ) ) = ( IC ( SCM+FSA ) ) & ( D9 . ( IC ( SCM+FSA ) ) ) = F3()) or (( IC ( SCM+FSA ) ) = ( intloc R2 ) & ( D9 . ( IC ( SCM+FSA ) ) ) = F1(R2)) or (( IC ( SCM+FSA ) ) = ( fsloc R2 ) & ( D9 . ( IC ( SCM+FSA ) ) ) = F2(R2)))) by L53;
thus L74: ( IC D9 ) = F3() by L73 , SCMFSA_2:56 , SCMFSA_2:57;
let C12 being (Element of ( NAT ));
L75: (ex R2 being (Element of ( NAT )) st ((( intloc C12 ) = ( IC ( SCM+FSA ) ) & ( D9 . ( intloc C12 ) ) = F3()) or (( intloc C12 ) = ( intloc R2 ) & ( D9 . ( intloc C12 ) ) = F1(R2)) or (( intloc C12 ) = ( fsloc R2 ) & ( D9 . ( intloc C12 ) ) = F2(R2)))) by L53;
thus L76: ( D9 . ( intloc C12 ) ) = F1(C12) by L75 , AMI_3:10 , SCMFSA_2:56 , SCMFSA_2:58;
L77: (ex R2 being (Element of ( NAT )) st ((( fsloc C12 ) = ( IC ( SCM+FSA ) ) & ( D9 . ( fsloc C12 ) ) = F3()) or (( fsloc C12 ) = ( intloc R2 ) & ( D9 . ( fsloc C12 ) ) = F1(R2)) or (( fsloc C12 ) = ( fsloc R2 ) & ( D9 . ( fsloc C12 ) ) = F2(R2)))) by L53;
thus L78: thesis by L77 , SCMFSA_2:57 , SCMFSA_2:58;
end;
theorem
L79: (for B8 being (State of ( SCM+FSA )) holds (for B9 being set holds (B9 in ( dom B8 ) implies (B9 is Int-Location or B9 is FinSeq-Location or B9 = ( IC ( SCM+FSA ) )))))
proof
let C13 being (State of ( SCM+FSA ));
let C14 being set;
assume L80: C14 in ( dom C13 );
L81: C14 in ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) by L80 , MEMSTR_0:13;
L82: (C14 in ( Data-Locations ( SCM+FSA ) ) or C14 in { ( IC ( SCM+FSA ) ) }) by L81 , XBOOLE_0:def 3;
L83: (C14 in ( Int-Locations ) or C14 in ( FinSeq-Locations ) or C14 = ( IC ( SCM+FSA ) )) by L82 , SCMFSA_2:100 , TARSKI:def 1 , XBOOLE_0:def 3;
thus L84: thesis by L83 , AMI_2:def 16 , SCMFSA_2:def 5;
end;
theorem
L85: (for B10 , B11 being (State of ( SCM+FSA )) holds (((for B12 being Int-Location holds ( B10 . B12 ) = ( B11 . B12 )) & (for B13 being FinSeq-Location holds ( B10 . B13 ) = ( B11 . B13 ))) iff ( DataPart B10 ) = ( DataPart B11 )))
proof
let C15 , C16 being (State of ( SCM+FSA ));
L86:
now
assume that
L87: (for B14 being Int-Location holds ( C15 . B14 ) = ( C16 . B14 ))
and
L88: (for B15 being FinSeq-Location holds ( C15 . B15 ) = ( C16 . B15 ));
thus L89:now
let C17 being set;
assume L90: C17 in ( Data-Locations ( SCM+FSA ) );
per cases ;
suppose L91: C17 in ( Int-Locations );

L92: C17 is Int-Location by L91 , AMI_2:def 16;
thus L93: ( C15 . C17 ) = ( C16 . C17 ) by L92 , L87;
end;
suppose L94: (not C17 in ( Int-Locations ));

L95: C17 in ( FinSeq-Locations ) by L94 , L90 , SCMFSA_2:100 , XBOOLE_0:def 3;
L96: C17 is FinSeq-Location by L95 , SCMFSA_2:def 5;
thus L97: ( C15 . C17 ) = ( C16 . C17 ) by L96 , L88;
end;
end;
end;
L90:
now
assume L91: (for B16 being set holds (B16 in ( Data-Locations ( SCM+FSA ) ) implies ( C15 . B16 ) = ( C16 . B16 )));
thus L92:now
let C18 being Int-Location;
L93: C18 in ( Int-Locations ) by AMI_2:def 16;
L94: C18 in ( Data-Locations ( SCM+FSA ) ) by L93 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L95: ( C15 . C18 ) = ( C16 . C18 ) by L94 , L91;
end;
thus L96:now
let C19 being FinSeq-Location;
L97: C19 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L98: C19 in ( Data-Locations ( SCM+FSA ) ) by L97 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L99: ( C15 . C19 ) = ( C16 . C19 ) by L98 , L91;
end;
end;
L97: ( dom C16 ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) by MEMSTR_0:13;
L98: ( Data-Locations ( SCM+FSA ) ) c= ( dom C16 ) by L97 , XBOOLE_1:7;
L99: ( dom C15 ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) by MEMSTR_0:13;
L100: ( Data-Locations ( SCM+FSA ) ) c= ( dom C15 ) by L99 , XBOOLE_1:7;
thus L101: thesis by L100 , L98 , L86 , L90 , FUNCT_1:95;
end;
theorem
L102: (for B17 being (PartState of ( SCM+FSA )) holds ( dom ( Initialized B17 ) ) = ( ( ( dom B17 ) \/ { ( intloc ( 0 ) ) } ) \/ { ( IC ( SCM+FSA ) ) } ))
proof
let C20 being (PartState of ( SCM+FSA ));
L103: (( dom D2 ) = { ( intloc ( 0 ) ) } & ( dom D1 ) = { ( IC ( SCM+FSA ) ) }) by FUNCOP_1:13;
L104: ( Initialized C20 ) = ( Initialize ( C20 +* D2 ) ) by FUNCT_4:14;
thus L105: ( dom ( Initialized C20 ) ) = ( ( dom ( C20 +* D2 ) ) \/ ( dom D1 ) ) by L104 , FUNCT_4:def 1
.= ( ( ( dom C20 ) \/ { ( intloc ( 0 ) ) } ) \/ { ( IC ( SCM+FSA ) ) } ) by L103 , FUNCT_4:def 1;
end;
registration
let C21 being (State of ( SCM+FSA ));
cluster ( Initialized C21 ) ->  total;
coherence;
end;
theorem
L107: (for B18 being (PartState of ( SCM+FSA )) holds ( intloc ( 0 ) ) in ( dom ( Initialized B18 ) ))
proof
let C22 being (PartState of ( SCM+FSA ));
L108: (( dom D2 ) = { ( intloc ( 0 ) ) } & ( dom D1 ) = { ( IC ( SCM+FSA ) ) }) by FUNCOP_1:13;
L109: ( intloc ( 0 ) ) in { ( intloc ( 0 ) ) } by TARSKI:def 1;
L110: ( intloc ( 0 ) ) in ( ( dom C22 ) \/ { ( intloc ( 0 ) ) } ) by L109 , XBOOLE_0:def 3;
L111: ( Initialized C22 ) = ( Initialize ( C22 +* D2 ) ) by FUNCT_4:14;
L112: ( dom ( Initialized C22 ) ) = ( ( dom ( C22 +* D2 ) ) \/ ( dom D1 ) ) by L111 , FUNCT_4:def 1
.= ( ( ( dom C22 ) \/ { ( intloc ( 0 ) ) } ) \/ { ( IC ( SCM+FSA ) ) } ) by L108 , FUNCT_4:def 1;
thus L113: thesis by L112 , L110 , XBOOLE_0:def 3;
end;
theorem
L114: (for B19 being (PartState of ( SCM+FSA )) holds (( ( Initialized B19 ) . ( intloc ( 0 ) ) ) = 1 & ( ( Initialized B19 ) . ( IC ( SCM+FSA ) ) ) = ( 0 )))
proof
let C23 being (PartState of ( SCM+FSA ));
L115: ( intloc ( 0 ) ) in { ( intloc ( 0 ) ) } by TARSKI:def 1;
L116: ( intloc ( 0 ) ) in ( dom D2 ) by L115 , FUNCOP_1:13;
L117: ( Initialized C23 ) = ( Initialize ( C23 +* D2 ) ) by FUNCT_4:14;
L118: ( intloc ( 0 ) ) <> ( IC ( SCM+FSA ) ) by SCMFSA_2:56;
L119: (not ( intloc ( 0 ) ) in { ( IC ( SCM+FSA ) ) }) by L118 , TARSKI:def 1;
L120: (not ( intloc ( 0 ) ) in ( dom D1 )) by L119 , FUNCOP_1:13;
thus L121: ( ( Initialized C23 ) . ( intloc ( 0 ) ) ) = ( ( C23 +* D2 ) . ( intloc ( 0 ) ) ) by L120 , L117 , FUNCT_4:11
.= ( D2 . ( intloc ( 0 ) ) ) by L116 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L122: ( IC ( SCM+FSA ) ) in { ( IC ( SCM+FSA ) ) } by TARSKI:def 1;
L123: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L122 , FUNCOP_1:13;
thus L124: ( ( Initialized C23 ) . ( IC ( SCM+FSA ) ) ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L123 , L117 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
end;
theorem
L125: (for B20 being (PartState of ( SCM+FSA )) holds (for B21 being Int-Location holds ((B21 <> ( intloc ( 0 ) ) & (not B21 in ( dom B20 ))) implies (not B21 in ( dom ( Initialized B20 ) )))))
proof
let C24 being (PartState of ( SCM+FSA ));
let C25 being Int-Location;
assume that
L126: C25 <> ( intloc ( 0 ) )
and
L127: (not C25 in ( dom C24 ));
assume L128: C25 in ( dom ( Initialized C24 ) );
L129: C25 in ( ( ( dom C24 ) \/ { ( intloc ( 0 ) ) } ) \/ { ( IC ( SCM+FSA ) ) } ) by L128 , L102;
L130: (C25 in ( ( dom C24 ) \/ { ( intloc ( 0 ) ) } ) or C25 in { ( IC ( SCM+FSA ) ) }) by L129 , XBOOLE_0:def 3;
per cases  by L130 , L127 , XBOOLE_0:def 3;
suppose L131: C25 in { ( intloc ( 0 ) ) };

thus L132: contradiction by L131 , L126 , TARSKI:def 1;
end;
suppose L133: C25 in { ( IC ( SCM+FSA ) ) };

L134: C25 = ( IC ( SCM+FSA ) ) by L133 , TARSKI:def 1;
thus L135: contradiction by L134 , SCMFSA_2:56;
end;
end;
theorem
L137: (for B22 being (PartState of ( SCM+FSA )) holds (for B23 being FinSeq-Location holds ((not B23 in ( dom B22 )) implies (not B23 in ( dom ( Initialized B22 ) )))))
proof
let C26 being (PartState of ( SCM+FSA ));
let C27 being FinSeq-Location;
assume L138: (not C27 in ( dom C26 ));
assume L139: C27 in ( dom ( Initialized C26 ) );
L140: C27 in ( ( ( dom C26 ) \/ { ( intloc ( 0 ) ) } ) \/ { ( IC ( SCM+FSA ) ) } ) by L139 , L102;
L141: (C27 in ( ( dom C26 ) \/ { ( intloc ( 0 ) ) } ) or C27 in { ( IC ( SCM+FSA ) ) }) by L140 , XBOOLE_0:def 3;
per cases  by L141 , L138 , XBOOLE_0:def 3;
suppose L142: C27 in { ( intloc ( 0 ) ) };

L143: C27 = ( intloc ( 0 ) ) by L142 , TARSKI:def 1;
thus L144: contradiction by L143 , SCMFSA_2:58;
end;
suppose L145: C27 in { ( IC ( SCM+FSA ) ) };

L146: C27 = ( IC ( SCM+FSA ) ) by L145 , TARSKI:def 1;
thus L147: contradiction by L146 , SCMFSA_2:57;
end;
end;
theorem
L149: (for B24 being (State of ( SCM+FSA )) holds ((( B24 . ( intloc ( 0 ) ) ) = 1 & ( IC B24 ) = ( 0 )) implies ( Initialized B24 ) = B24))
proof
let C28 being (State of ( SCM+FSA ));
assume L150: ( C28 . ( intloc ( 0 ) ) ) = 1;
assume L151: ( IC C28 ) = ( 0 );
L152: ( IC ( SCM+FSA ) ) in ( dom C28 ) by MEMSTR_0:2;
L153: ( intloc ( 0 ) ) in ( dom C28 ) by SCMFSA_2:42;
thus L154: ( Initialized C28 ) = ( Initialize ( C28 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:14
.= ( C28 +* ( ( IC ( SCM+FSA ) ) .--> ( 0 ) ) ) by L150 , L153 , FUNCT_7:109
.= C28 by L151 , L152 , FUNCT_7:109;
end;
theorem
L155: (for B25 being (PartState of ( SCM+FSA )) holds ( ( Initialized B25 ) . ( intloc ( 0 ) ) ) = 1)
proof
let C29 being (PartState of ( SCM+FSA ));
L156: ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) = 1 by FUNCOP_1:72;
L157: ( Initialized C29 ) = ( Initialize ( C29 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:14;
L158: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L159: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L158 , TARSKI:def 1;
L160: (not ( intloc ( 0 ) ) in ( dom D1 )) by SCMFSA_2:102;
thus L161: ( ( Initialized C29 ) . ( intloc ( 0 ) ) ) = ( ( C29 +* ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) by L160 , L157 , FUNCT_4:11
.= 1 by L159 , L156 , FUNCT_4:13;
end;
theorem
L162: ( intloc ( 0 ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )
proof
L163: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) \/ ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:def 1;
L164: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
L165: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by L164 , TARSKI:def 1;
thus L166: ( intloc ( 0 ) ) in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) by L165 , L163 , XBOOLE_0:def 3;
end;
theorem
L167: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) }
proof
thus L168: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom D1 ) ) by FUNCT_4:def 1
.= ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13
.= ( { ( intloc ( 0 ) ) } \/ { ( IC ( SCM+FSA ) ) } ) by FUNCOP_1:13
.= { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } by ENUMSET1:1;
end;
theorem
L169: ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) = 1
proof
L170: (not ( intloc ( 0 ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L171: ( ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) . ( intloc ( 0 ) ) ) = ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by L170 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
end;
theorem
L172: (for B26 being (PartState of ( SCM+FSA )) holds ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= ( Initialized B26 )) by FUNCT_4:25;
begin
registration
cluster ( Int-Locations ) -> non  empty;
coherence;
end;
definition
let C30 being Int-Location;
attr C30 is  read-only
means
:L174: C30 = ( intloc ( 0 ) );
end;
notation
let C31 being Int-Location;
antonym C31 is  read-write for C31 is  read-only;
end;
registration
cluster ( intloc ( 0 ) ) ->  read-only;
coherence by L174;
end;
registration
cluster  read-write for Int-Location;
existence
proof
take ( intloc 1 );
L178: ( intloc 1 ) <> ( intloc ( 0 ) ) by AMI_3:10;
thus L179: thesis by L178 , L174;
end;
end;
definition
let C32 being  finite (Subset of ( Int-Locations ));
func FirstNotIn C32 -> Int-Location means 
:L181: (ex B27 being non  empty (Subset of ( NAT )) st (it = ( intloc ( min B27 ) ) & B27 = { B28 where B28 is (Element of ( NAT )) : (not ( intloc B28 ) in C32) }));
existence
proof
defpred S2[ (Element of ( NAT )) ] means (not ( intloc $1 ) in C32);
set D10 = { B29 where B29 is (Element of ( NAT )) : S2[ B29 ] };
L182: D10 is (Subset of ( NAT )) from DOMAIN_1:sch 7;
L183: ( Int-Locations ) = [: { 1 } , ( NAT ) :] by SCM_INST:def 1;
L184: (not ( Int-Locations ) c= C32) by L183;
consider C33 being set such that L185: C33 in ( Int-Locations ) and L186: (not C33 in C32) by L184 , TARSKI:def 3;
reconsider D11 = C33 as Int-Location by L185 , AMI_2:def 16;
consider C34 being (Element of ( NAT )) such that L187: D11 = ( intloc C34 ) by SCMFSA_2:8;
L188: C34 in D10 by L186 , L187;
reconsider D12 = D10 as non  empty (Subset of ( NAT )) by L188 , L182;
take ( intloc ( min D12 ) );
take D12;
thus L189: thesis;
end;
uniqueness;
end;
theorem
L191: (for R10 being  finite (Subset of ( Int-Locations )) holds (not ( FirstNotIn R10 ) in R10))
proof
let R10 being  finite (Subset of ( Int-Locations ));
set D13 = ( FirstNotIn R10 );
consider C35 being non  empty (Subset of ( NAT )) such that L192: D13 = ( intloc ( min C35 ) ) and L193: C35 = { B30 where B30 is (Element of ( NAT )) : (not ( intloc B30 ) in R10) } by L181;
L194: ( min C35 ) in C35 by XXREAL_2:def 7;
L195: (ex B31 being (Element of ( NAT )) st (B31 = ( min C35 ) & (not ( intloc B31 ) in R10))) by L194 , L193;
thus L196: thesis by L195 , L192;
end;
theorem
L197: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R10 being  finite (Subset of ( Int-Locations )) holds ((( FirstNotIn R10 ) = ( intloc R2 ) & (not ( intloc R3 ) in R10)) implies R2 <= R3))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R10 being  finite (Subset of ( Int-Locations ));
consider C36 being non  empty (Subset of ( NAT )) such that L198: (( FirstNotIn R10 ) = ( intloc ( min C36 ) ) & C36 = { B32 where B32 is (Element of ( NAT )) : (not ( intloc B32 ) in R10) }) by L181;
assume L199: (( FirstNotIn R10 ) = ( intloc R2 ) & (not ( intloc R3 ) in R10));
L200: (R2 = ( min C36 ) & R3 in C36) by L199 , L198 , AMI_3:10;
thus L201: thesis by L200 , XXREAL_2:def 7;
end;
definition
let C37 being  finite (Subset of ( FinSeq-Locations ));
func First*NotIn C37 -> FinSeq-Location means 
:L202: (ex B33 being non  empty (Subset of ( NAT )) st (it = ( fsloc ( min B33 ) ) & B33 = { B34 where B34 is (Element of ( NAT )) : (not ( fsloc B34 ) in C37) }));
existence
proof
defpred S3[ (Element of ( NAT )) ] means (not ( fsloc $1 ) in C37);
set D14 = { B35 where B35 is (Element of ( NAT )) : S3[ B35 ] };
L203: D14 is (Subset of ( NAT )) from DOMAIN_1:sch 7;
L204: (not ( FinSeq-Locations ) c= C37);
consider C38 being set such that L205: C38 in ( FinSeq-Locations ) and L206: (not C38 in C37) by L204 , TARSKI:def 3;
reconsider D15 = C38 as FinSeq-Location by L205 , SCMFSA_2:def 5;
consider C39 being (Element of ( NAT )) such that L207: D15 = ( fsloc C39 ) by SCMFSA_2:9;
L208: C39 in D14 by L206 , L207;
reconsider D16 = D14 as non  empty (Subset of ( NAT )) by L208 , L203;
take ( fsloc ( min D16 ) );
take D16;
thus L209: thesis;
end;
uniqueness;
end;
theorem
L211: (for R11 being  finite (Subset of ( FinSeq-Locations )) holds (not ( First*NotIn R11 ) in R11))
proof
let R11 being  finite (Subset of ( FinSeq-Locations ));
set D17 = ( First*NotIn R11 );
consider C40 being non  empty (Subset of ( NAT )) such that L212: D17 = ( fsloc ( min C40 ) ) and L213: C40 = { B36 where B36 is (Element of ( NAT )) : (not ( fsloc B36 ) in R11) } by L202;
L214: ( min C40 ) in C40 by XXREAL_2:def 7;
L215: (ex B37 being (Element of ( NAT )) st (B37 = ( min C40 ) & (not ( fsloc B37 ) in R11))) by L214 , L213;
thus L216: thesis by L215 , L212;
end;
theorem
L217: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R11 being  finite (Subset of ( FinSeq-Locations )) holds ((( First*NotIn R11 ) = ( fsloc R2 ) & (not ( fsloc R3 ) in R11)) implies R2 <= R3))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R11 being  finite (Subset of ( FinSeq-Locations ));
assume that
L218: ( First*NotIn R11 ) = ( fsloc R2 )
and
L219: (not ( fsloc R3 ) in R11);
consider C41 being non  empty (Subset of ( NAT )) such that L220: ( First*NotIn R11 ) = ( fsloc ( min C41 ) ) and L221: C41 = { B38 where B38 is (Element of ( NAT )) : (not ( fsloc B38 ) in R11) } by L202;
L222: R3 in C41 by L219 , L221;
thus L223: thesis by L222 , L218 , L220 , XXREAL_2:def 7;
end;
registration
let C42 being (State of ( SCM+FSA ));
let C43 being Int-Location;
let C44 being Integer;
cluster ( C42 +* (C43 , C44) ) -> ( the_Values_of ( SCM+FSA ) ) -compatible;
coherence
proof
let C45 being set;
assume L224: C45 in ( dom ( C42 +* (C43 , C44) ) );
L225: C45 in ( dom C42 ) by L224 , FUNCT_7:30;
per cases ;
suppose L226: C45 = C43;

L227: ( ( the_Values_of ( SCM+FSA ) ) . C45 ) = ( Values C43 ) by L226
.= ( INT ) by SCMFSA_2:11;
L228: ( ( C42 +* (C43 , C44) ) . C45 ) = C44 by L226 , L225 , FUNCT_7:31;
thus L229: ( ( C42 +* (C43 , C44) ) . C45 ) in ( ( the_Values_of ( SCM+FSA ) ) . C45 ) by L228 , L227 , INT_1:def 2;
end;
suppose L230: C45 <> C43;

L231: ( ( C42 +* (C43 , C44) ) . C45 ) = ( C42 . C45 ) by L230 , FUNCT_7:32;
thus L232: ( ( C42 +* (C43 , C44) ) . C45 ) in ( ( the_Values_of ( SCM+FSA ) ) . C45 ) by L231 , L225 , FUNCT_1:def 14;
end;
end;
end;
begin
registration
let C46 being Int-Location;
let C47 being Nat;
cluster ( C46 .--> C47 ) ->  data-only for (PartState of ( SCM+FSA ));
coherence;
end;
theorem
L236: (for B39 being (State of ( SCM+FSA )) holds (( B39 . ( intloc ( 0 ) ) ) = 1 implies ( Initialize B39 ) = ( Initialized B39 )))
proof
let C48 being (State of ( SCM+FSA ));
L237: ( intloc ( 0 ) ) in ( dom C48 ) by SCMFSA_2:42;
assume L238: ( C48 . ( intloc ( 0 ) ) ) = 1;
L239: C48 = ( C48 +* ( ( intloc ( 0 ) ) .--> 1 ) ) by L238 , L237 , FUNCT_7:109;
thus L240: ( Initialized C48 ) = ( Initialize C48 ) by L239 , FUNCT_4:14;
end;
theorem
L241: (for B40 being (State of ( SCM+FSA )) holds (( B40 . ( intloc ( 0 ) ) ) = 1 implies ( DataPart ( Initialized B40 ) ) = ( DataPart B40 )))
proof
let C49 being (State of ( SCM+FSA ));
assume L242: ( C49 . ( intloc ( 0 ) ) ) = 1;
L243: ( intloc ( 0 ) ) in ( dom C49 ) by SCMFSA_2:42;
L244: ( Initialized C49 ) = ( Initialize ( C49 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:14;
L245: ( Initialized C49 ) = ( Initialize C49 ) by L244 , L242 , L243 , FUNCT_7:109;
thus L246: thesis by L245 , MEMSTR_0:79;
end;
theorem
L247: (for B41 , B42 being (State of ( SCM+FSA )) holds ((( B41 . ( intloc ( 0 ) ) ) = ( B42 . ( intloc ( 0 ) ) ) & (for B43 being  read-write Int-Location holds ( B41 . B43 ) = ( B42 . B43 )) & (for B44 being FinSeq-Location holds ( B41 . B44 ) = ( B42 . B44 ))) implies ( DataPart B41 ) = ( DataPart B42 )))
proof
let C50 , C51 being (State of ( SCM+FSA ));
set D18 = ( Data-Locations ( SCM+FSA ) );
assume L248: ( C50 . ( intloc ( 0 ) ) ) = ( C51 . ( intloc ( 0 ) ) );
assume L249: (for B45 being  read-write Int-Location holds ( C50 . B45 ) = ( C51 . B45 ));
L250: ( dom ( DataPart C50 ) ) = ( ( dom C50 ) /\ D18 ) by RELAT_1:61
.= ( ( ( Data-Locations ( SCM+FSA ) ) \/ { ( IC ( SCM+FSA ) ) } ) /\ D18 ) by MEMSTR_0:13
.= ( ( dom C51 ) /\ D18 ) by MEMSTR_0:13
.= ( dom ( DataPart C51 ) ) by RELAT_1:61;
assume L251: (for B46 being FinSeq-Location holds ( C50 . B46 ) = ( C51 . B46 ));
L252:
now
let C52 being set;
assume L253: C52 in ( dom ( DataPart C50 ) );
L254: C52 in ( ( dom C50 ) /\ D18 ) by L253 , RELAT_1:61;
L255: C52 in ( dom C50 ) by L254 , XBOOLE_0:def 4;
per cases  by L255 , L79;
suppose L256: C52 is Int-Location;

thus L257:now
per cases ;
suppose L258: C52 is  read-write  read-write  read-write  read-write Int-Location;

thus L259: ( ( DataPart C50 ) . C52 ) = ( C50 . C52 ) by L253 , FUNCT_1:47
.= ( C51 . C52 ) by L249 , L258
.= ( ( DataPart C51 ) . C52 ) by L250 , L253 , FUNCT_1:47;
end;
suppose L260: (not C52 is  read-write  read-write  read-write  read-write Int-Location);

reconsider D19 = C52 as Int-Location by L256;
L261: D19 = ( intloc ( 0 ) ) by L260 , L174;
thus L262: ( ( DataPart C50 ) . C52 ) = ( C51 . D19 ) by L261 , L248 , L253 , FUNCT_1:47
.= ( ( DataPart C51 ) . C52 ) by L250 , L253 , FUNCT_1:47;
end;
end;
end;
suppose L258: C52 is FinSeq-Location;

thus L259: ( ( DataPart C50 ) . C52 ) = ( C50 . C52 ) by L253 , FUNCT_1:47
.= ( C51 . C52 ) by L251 , L258
.= ( ( DataPart C51 ) . C52 ) by L250 , L253 , FUNCT_1:47;
end;
suppose L260: C52 = ( IC ( SCM+FSA ) );

L261: (not C52 in ( Data-Locations ( SCM+FSA ) )) by L260 , STRUCT_0:3;
thus L262: ( ( DataPart C50 ) . C52 ) = ( ( DataPart C51 ) . C52 ) by L261 , L254 , XBOOLE_0:def 4;
end;
end;
L264: ( DataPart C50 ) c= ( DataPart C51 ) by L252 , L250 , GRFUNC_1:2;
thus L265: thesis by L264 , L250 , GRFUNC_1:3;
end;
theorem
L266: (for B47 being (State of ( SCM+FSA )) holds (for B48 being Int-Location holds (for B49 being (Element of ( NAT )) holds ( ( B47 +* ( Start-At (B49 , ( SCM+FSA )) ) ) . B48 ) = ( B47 . B48 ))))
proof
let C53 being (State of ( SCM+FSA ));
let C54 being Int-Location;
let C55 being (Element of ( NAT ));
L267: (not C54 in ( dom ( Start-At (C55 , ( SCM+FSA )) ) )) by SCMFSA_2:102;
thus L268: thesis by L267 , FUNCT_4:11;
end;
begin
definition
let C56 being Int-Location;
redefine func {C56 } -> (Subset of ( Int-Locations ));

coherence
proof
L269: C56 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L270: thesis by L269 , SUBSET_1:33;
end;
let C57 being Int-Location;
redefine func {C56 , C57 } -> (Subset of ( Int-Locations ));

coherence
proof
L271: C57 in ( SCM-Data-Loc ) by AMI_2:def 16;
L272: C56 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L273: thesis by L272 , L271 , SUBSET_1:34;
end;
let C58 being Int-Location;
redefine func {C56 , C57 , C58 } -> (Subset of ( Int-Locations ));

coherence
proof
L274: C58 in ( SCM-Data-Loc ) by AMI_2:def 16;
L275: C57 in ( SCM-Data-Loc ) by AMI_2:def 16;
L276: C56 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L277: thesis by L276 , L275 , L274 , SUBSET_1:35;
end;
let C59 being Int-Location;
redefine func {C56 , C57 , C58 , C59 } -> (Subset of ( Int-Locations ));

coherence
proof
L278: C59 in ( SCM-Data-Loc ) by AMI_2:def 16;
L279: C58 in ( SCM-Data-Loc ) by AMI_2:def 16;
L280: C57 in ( SCM-Data-Loc ) by AMI_2:def 16;
L281: C56 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L282: thesis by L281 , L280 , L279 , L278 , SUBSET_1:36;
end;
end;
definition
let C60 being  finite (Subset of ( Int-Locations ));
func RWNotIn-seq C60 -> (Function of ( NAT ) , ( bool ( NAT ) )) means 
:L284: (( it . ( 0 ) ) = { B50 where B50 is (Element of ( NAT )) : ((not ( intloc B50 ) in C60) & B50 <> ( 0 )) } & (for B51 being (Element of ( NAT )) holds (for B52 being non  empty (Subset of ( NAT )) holds (( it . B51 ) = B52 implies ( it . ( B51 + 1 ) ) = ( B52 \ { ( min B52 ) } )))) & (for B53 being (Element of ( NAT )) holds ( it . B53 ) is  infinite));
existence
proof
set D20 = ( C60 \/ { ( intloc ( 0 ) ) } );
defpred S4[ (Element of ( NAT )) ] means ((not ( intloc $1 ) in C60) & $1 <> ( 0 ));
set D21 = { B54 where B54 is (Element of ( NAT )) : S4[ B54 ] };
L285: D21 is (Subset of ( NAT )) from DOMAIN_1:sch 7;
L286: (not ( Int-Locations ) c= D20) by AMI_3:27;
consider C61 being set such that L287: C61 in ( Int-Locations ) and L288: (not C61 in D20) by L286 , TARSKI:def 3;
reconsider D22 = C61 as Int-Location by L287 , AMI_2:def 16;
consider C62 being (Element of ( NAT )) such that L289: D22 = ( intloc C62 ) by SCMFSA_2:8;
L290: (not ( intloc C62 ) in { ( intloc ( 0 ) ) }) by L288 , L289 , XBOOLE_0:def 3;
L291: C62 <> ( 0 ) by L290 , TARSKI:def 1;
L292: (not ( intloc C62 ) in C60) by L288 , L289 , XBOOLE_0:def 3;
L293: C62 in D21 by L292 , L291;
reconsider D23 = D21 as non  empty (Subset of ( NAT )) by L293 , L285;
defpred S5[ (Element of ( NAT )) , (Subset of ( NAT )) , (Subset of ( NAT )) ] means (for B55 being non  empty (Subset of ( NAT )) holds (B55 = $2 implies $3 = ( $2 \ { ( min B55 ) } )));
L294:
now
let C63 being (Element of ( NAT ));
let C64 being (Subset of ( NAT ));
per cases ;
suppose L295: C64 is  empty;

L296: S5[ C63 , C64 , ( {} ( NAT ) ) ] by L295;
thus L297: (ex B56 being (Subset of ( NAT )) st S5[ C63 , C64 , B56 ]) by L296;
end;
suppose L298: C64 is non  empty;

reconsider D24 = C64 as non  empty (Subset of ( NAT )) by L298;
L299:
now
reconsider D25 = { ( min D24 ) } as (Subset of ( NAT ));
reconsider D26 = ( D24 \ D25 ) as (Subset of ( NAT ));
take D27 = D26;
let C65 being non  empty (Subset of ( NAT ));
assume L300: C65 = C64;
thus L301: D27 = ( C64 \ { ( min C65 ) } ) by L300;
end;
thus L302: (ex B57 being (Subset of ( NAT )) st S5[ C63 , C64 , B57 ]) by L299;
end;
end;
consider C66 being (Function of ( NAT ) , ( bool ( NAT ) )) such that L304: ( C66 . ( 0 ) ) = D23 and L305: (for B58 being (Element of ( NAT )) holds S5[ B58 , ( C66 . B58 ) , ( C66 . ( B58 + 1 ) ) ]) from RECDEF_1:sch 2(L294);
take C66;
thus L306: ( C66 . ( 0 ) ) = { B59 where B59 is (Element of ( NAT )) : ((not ( intloc B59 ) in C60) & B59 <> ( 0 )) } by L304;
thus L307: (for B60 being (Element of ( NAT )) holds (for B61 being non  empty (Subset of ( NAT )) holds (( C66 . B60 ) = B61 implies ( C66 . ( B60 + 1 ) ) = ( B61 \ { ( min B61 ) } )))) by L305;
defpred S6[ (Element of ( NAT )) ] means ( C66 . $1 ) is  infinite;
L308: S6[ ( 0 ) ]
proof
deffunc H1((Element of ( NAT ))) = ( intloc $1 );
set D28 = { H1(B62) where B62 is (Element of ( NAT )) : B62 in D23 };
assume L309: ( C66 . ( 0 ) ) is  finite;
L310: D23 is  finite by L309 , L304;
L311: D28 is  finite from FRAENKEL:sch 21(L310);
reconsider D29 = D28 as  finite set by L311;
L312:
now
let C67 being set;
thus L313:now
assume L314: C67 in ( D20 \/ D29 );
per cases  by L314 , XBOOLE_0:def 3;
suppose L315: C67 in D20;

thus L316: C67 in ( Int-Locations ) by L315;
end;
suppose L317: C67 in D29;

L318: (ex B63 being (Element of ( NAT )) st (( intloc B63 ) = C67 & B63 in D23)) by L317;
thus L319: C67 in ( Int-Locations ) by L318 , AMI_2:def 16;
end;
end;
assume L321: C67 in ( Int-Locations );
reconsider D30 = C67 as Int-Location by L321 , AMI_2:def 16;
consider C68 being (Element of ( NAT )) such that L322: D30 = ( intloc C68 ) by SCMFSA_2:8;
L323:
now
assume L324: (not C67 in D20);
L325: (not D30 in { ( intloc ( 0 ) ) }) by L324 , XBOOLE_0:def 3;
L326: C68 <> ( 0 ) by L325 , L322 , TARSKI:def 1;
L327: (not ( intloc C68 ) in C60) by L322 , L324 , XBOOLE_0:def 3;
L328: C68 in D23 by L327 , L326;
thus L329: C67 in D29 by L328 , L322;
end;
thus L330: C67 in ( D20 \/ D29 ) by L323 , XBOOLE_0:def 3;
end;
thus L331: contradiction by L312 , AMI_3:27 , TARSKI:1;
end;
L332: (for R3 being (Element of ( NAT )) holds (S6[ R3 ] implies S6[ ( R3 + 1 ) ]))
proof
let R3 being (Element of ( NAT ));
assume L333: ( C66 . R3 ) is  infinite;
reconsider D31 = ( C66 . R3 ) as non  empty (Subset of ( NAT )) by L333;
L334: ( min D31 ) in D31 by XXREAL_2:def 7;
L335: { ( min D31 ) } c= D31 by L334 , ZFMISC_1:31;
assume L336: ( C66 . ( R3 + 1 ) ) is  finite;
reconsider D32 = ( C66 . ( R3 + 1 ) ) as  finite set by L336;
L337: ( D32 \/ { ( min D31 ) } ) is  finite;
L338: ( C66 . ( R3 + 1 ) ) = ( D31 \ { ( min D31 ) } ) by L305;
thus L339: contradiction by L338 , L333 , L335 , L337 , XBOOLE_1:45;
end;
thus L340: (for B64 being (Element of ( NAT )) holds S6[ B64 ]) from NAT_1:sch 1(L308 , L332);
end;
uniqueness
proof
let C69 , C70 being (Function of ( NAT ) , ( bool ( NAT ) ));
assume that
L341: ( C69 . ( 0 ) ) = { B65 where B65 is (Element of ( NAT )) : ((not ( intloc B65 ) in C60) & B65 <> ( 0 )) }
and
L342: (for B66 being (Element of ( NAT )) holds (for B67 being non  empty (Subset of ( NAT )) holds (( C69 . B66 ) = B67 implies ( C69 . ( B66 + 1 ) ) = ( B67 \ { ( min B67 ) } ))))
and
L343: (for B68 being (Element of ( NAT )) holds ( C69 . B68 ) is  infinite)
and
L344: ( C70 . ( 0 ) ) = { B69 where B69 is (Element of ( NAT )) : ((not ( intloc B69 ) in C60) & B69 <> ( 0 )) }
and
L345: (for B70 being (Element of ( NAT )) holds (for B71 being non  empty (Subset of ( NAT )) holds (( C70 . B70 ) = B71 implies ( C70 . ( B70 + 1 ) ) = ( B71 \ { ( min B71 ) } ))))
and
L346: (for B72 being (Element of ( NAT )) holds ( C70 . B72 ) is  infinite);
L347:
now
defpred S7[ (Element of ( NAT )) ] means ( C69 . $1 ) = ( C70 . $1 );
thus L348: ( NAT ) = ( dom C69 ) by FUNCT_2:def 1;
thus L349: ( NAT ) = ( dom C70 ) by FUNCT_2:def 1;
L350: (for R3 being (Element of ( NAT )) holds (S7[ R3 ] implies S7[ ( R3 + 1 ) ]))
proof
let C71 being (Element of ( NAT ));
assume L351: ( C69 . C71 ) = ( C70 . C71 );
reconsider D33 = ( C69 . C71 ) as non  empty (Subset of ( NAT )) by L351 , L346;
thus L352: ( C69 . ( C71 + 1 ) ) = ( D33 \ { ( min D33 ) } ) by L342
.= ( C70 . ( C71 + 1 ) ) by L345 , L351;
end;
L353: S7[ ( 0 ) ] by L341 , L344;
L354: (for B73 being (Element of ( NAT )) holds S7[ B73 ]) from NAT_1:sch 1(L353 , L350);
thus L355: (for B74 being set holds (B74 in ( NAT ) implies ( C69 . B74 ) = ( C70 . B74 ))) by L354;
end;
thus L356: C69 = C70 by L347 , FUNCT_1:2;
end;
end;
registration
let C72 being  finite (Subset of ( Int-Locations ));
let C73 being (Element of ( NAT ));
cluster ( ( RWNotIn-seq C72 ) . C73 ) -> non  empty;
coherence by L284;
end;
theorem
L359: (for R3 being (Element of ( NAT )) holds (for R12 being  finite (Subset of ( Int-Locations )) holds ((not ( 0 ) in ( ( RWNotIn-seq R12 ) . R3 )) & (for R2 being (Element of ( NAT )) holds (R2 in ( ( RWNotIn-seq R12 ) . R3 ) implies (not ( intloc R2 ) in R12))))))
proof
let R3 being (Element of ( NAT ));
let R12 being  finite (Subset of ( Int-Locations ));
set D34 = ( RWNotIn-seq R12 );
defpred S8[ (Element of ( NAT )) ] means ((not ( 0 ) in ( D34 . $1 )) & (for R2 being (Element of ( NAT )) holds (R2 in ( D34 . $1 ) implies (not ( intloc R2 ) in R12))));
L360: S8[ ( 0 ) ]
proof
L361: ( D34 . ( 0 ) ) = { B75 where B75 is (Element of ( NAT )) : ((not ( intloc B75 ) in R12) & B75 <> ( 0 )) } by L284;
thus L362:now
assume L363: ( 0 ) in ( D34 . ( 0 ) );
L364: (ex B76 being (Element of ( NAT )) st (B76 = ( 0 ) & (not ( intloc B76 ) in R12) & B76 <> ( 0 ))) by L363 , L361;
thus L365: contradiction by L364;
end;
let R2 being (Element of ( NAT ));
assume L366: R2 in ( D34 . ( 0 ) );
L367: (ex B77 being (Element of ( NAT )) st (B77 = R2 & (not ( intloc B77 ) in R12) & B77 <> ( 0 ))) by L366 , L361;
thus L368: thesis by L367;
end;
L369: (for R3 being (Element of ( NAT )) holds (S8[ R3 ] implies S8[ ( R3 + 1 ) ]))
proof
let R3 being (Element of ( NAT ));
assume that
L370: (not ( 0 ) in ( D34 . R3 ))
and
L371: (for R2 being (Element of ( NAT )) holds (R2 in ( D34 . R3 ) implies (not ( intloc R2 ) in R12)));
reconsider D35 = ( D34 . R3 ) as non  empty (Subset of ( NAT ));
L372: ( D34 . ( R3 + 1 ) ) = ( D35 \ { ( min D35 ) } ) by L284;
thus L373: (not ( 0 ) in ( D34 . ( R3 + 1 ) )) by L372 , L370 , XBOOLE_0:def 5;
let R2 being (Element of ( NAT ));
assume L374: R2 in ( D34 . ( R3 + 1 ) );
L375: R2 in ( D34 . R3 ) by L374 , L372 , XBOOLE_0:def 5;
thus L376: thesis by L375 , L371;
end;
L377: (for B78 being (Element of ( NAT )) holds S8[ B78 ]) from NAT_1:sch 1(L360 , L369);
thus L378: thesis by L377;
end;
theorem
L379: (for R3 being (Element of ( NAT )) holds (for R12 being  finite (Subset of ( Int-Locations )) holds ( min ( ( RWNotIn-seq R12 ) . R3 ) ) < ( min ( ( RWNotIn-seq R12 ) . ( R3 + 1 ) ) )))
proof
let R3 being (Element of ( NAT ));
let R12 being  finite (Subset of ( Int-Locations ));
set D36 = ( RWNotIn-seq R12 );
set D37 = ( D36 . R3 );
set D38 = ( D36 . ( R3 + 1 ) );
assume L380: ( min ( ( RWNotIn-seq R12 ) . R3 ) ) >= ( min ( ( RWNotIn-seq R12 ) . ( R3 + 1 ) ) );
L381: D38 = ( D37 \ { ( min D37 ) } ) by L284;
L382: ( min D37 ) <= ( min D38 ) by L381 , XBOOLE_1:36 , XXREAL_2:60;
L383: ( min D37 ) = ( min D38 ) by L382 , L380 , XXREAL_0:1;
L384: ( min D38 ) in { ( min D37 ) } by L383 , TARSKI:def 1;
L385: ( min D38 ) in D38 by XXREAL_2:def 7;
thus L386: contradiction by L385 , L381 , L384 , XBOOLE_0:def 5;
end;
theorem
L387: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R12 being  finite (Subset of ( Int-Locations )) holds (R3 < R2 implies ( min ( ( RWNotIn-seq R12 ) . R3 ) ) < ( min ( ( RWNotIn-seq R12 ) . R2 ) )))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R12 being  finite (Subset of ( Int-Locations ));
set D39 = ( RWNotIn-seq R12 );
L388:
now
let R3 being (Element of ( NAT ));
defpred S9[ (Element of ( NAT )) ] means (R3 < $1 implies ( min ( D39 . R3 ) ) < ( min ( D39 . $1 ) ));
L389: (for R2 being (Element of ( NAT )) holds (S9[ R2 ] implies S9[ ( R2 + 1 ) ]))
proof
let R2 being (Element of ( NAT ));
assume that
L390: (R3 < R2 implies ( min ( D39 . R3 ) ) < ( min ( D39 . R2 ) ));
assume L391: R3 < ( R2 + 1 );
L392: R3 <= R2 by L391 , NAT_1:13;
per cases  by L392 , XXREAL_0:1;
suppose L393: R3 = R2;

thus L394: ( min ( D39 . R3 ) ) < ( min ( D39 . ( R2 + 1 ) ) ) by L393 , L379;
end;
suppose L395: R3 < R2;

thus L396: ( min ( D39 . R3 ) ) < ( min ( D39 . ( R2 + 1 ) ) ) by L395 , L390 , L379 , XXREAL_0:2;
end;
end;
L398: S9[ ( 0 ) ] by NAT_1:2;
thus L399: (for B79 being (Element of ( NAT )) holds S9[ B79 ]) from NAT_1:sch 1(L398 , L389);
end;
thus L400: thesis by L388;
end;
definition
let C74 being (Element of ( NAT ));
let C75 being  finite (Subset of ( Int-Locations ));
func C74 -thRWNotIn C75 -> Int-Location equals 
( intloc ( min ( ( RWNotIn-seq C75 ) . C74 ) ) );
correctness;
end;
notation
let C76 being (Element of ( NAT ));
let C77 being  finite (Subset of ( Int-Locations ));
synonym C76 -stRWNotIn C77 for C76 -thRWNotIn C77;
synonym C76 -ndRWNotIn C77 for C76 -thRWNotIn C77;
synonym C76 -rdRWNotIn C77 for C76 -thRWNotIn C77;
end;
registration
let C78 being (Element of ( NAT ));
let C79 being  finite (Subset of ( Int-Locations ));
cluster ( C78 -thRWNotIn C79 ) ->  read-write;
coherence
proof
set D40 = ( ( RWNotIn-seq C79 ) . C78 );
L403: ( min D40 ) in D40 by XXREAL_2:def 7;
assume L404: ( C78 -thRWNotIn C79 ) = ( intloc ( 0 ) );
L405: ( min ( ( RWNotIn-seq C79 ) . C78 ) ) = ( 0 ) by L404 , AMI_3:10;
thus L406: contradiction by L405 , L403 , L359;
end;
end;
theorem
L408: (for R3 being (Element of ( NAT )) holds (for R12 being  finite (Subset of ( Int-Locations )) holds (not ( R3 -thRWNotIn R12 ) in R12)))
proof
let R3 being (Element of ( NAT ));
let R12 being  finite (Subset of ( Int-Locations ));
set D41 = ( R3 -thRWNotIn R12 );
set D42 = ( ( RWNotIn-seq R12 ) . R3 );
L409: ( min D42 ) in D42 by XXREAL_2:def 7;
thus L410: thesis by L409 , L359;
end;
theorem
L411: (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for R12 being  finite (Subset of ( Int-Locations )) holds (R3 <> R2 implies ( R3 -thRWNotIn R12 ) <> ( R2 -thRWNotIn R12 )))))
proof
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let R12 being  finite (Subset of ( Int-Locations ));
assume L412: R3 <> R2;
L413: (R3 < R2 or R2 < R3) by L412 , XXREAL_0:1;
L414: ( min ( ( RWNotIn-seq R12 ) . R3 ) ) <> ( min ( ( RWNotIn-seq R12 ) . R2 ) ) by L413 , L387;
assume L415: ( R3 -thRWNotIn R12 ) = ( R2 -thRWNotIn R12 );
thus L416: contradiction by L415 , L414 , AMI_3:10;
end;
begin
theorem
L417: (for R8 being (State of ( SCM+FSA )) holds (for R9 being (State of ( SCM+FSA )) holds (for B80 being (Subset of ( Int-Locations )) holds (for B81 being (Subset of ( FinSeq-Locations )) holds (( R8 | ( B80 \/ B81 ) ) = ( R9 | ( B80 \/ B81 ) ) iff ((for B82 being Int-Location holds (B82 in B80 implies ( R8 . B82 ) = ( R9 . B82 ))) & (for B83 being FinSeq-Location holds (B83 in B81 implies ( R8 . B83 ) = ( R9 . B83 )))))))))
proof
let R8 being (State of ( SCM+FSA ));
let R9 being (State of ( SCM+FSA ));
let C80 being (Subset of ( Int-Locations ));
let C81 being (Subset of ( FinSeq-Locations ));
L418: ( FinSeq-Locations ) c= ( dom R8 ) by SCMFSA_2:46;
L419: C81 c= ( dom R8 ) by L418 , XBOOLE_1:1;
L420: ( FinSeq-Locations ) c= ( dom R9 ) by SCMFSA_2:46;
L421: C81 c= ( dom R9 ) by L420 , XBOOLE_1:1;
L422: ( Int-Locations ) c= ( dom R9 ) by SCMFSA_2:45;
L423: C80 c= ( dom R9 ) by L422 , XBOOLE_1:1;
L424: ( C80 \/ C81 ) c= ( dom R9 ) by L423 , L421 , XBOOLE_1:8;
L425: ( Int-Locations ) c= ( dom R8 ) by SCMFSA_2:45;
L426: C80 c= ( dom R8 ) by L425 , XBOOLE_1:1;
L427: ( C80 \/ C81 ) c= ( dom R8 ) by L426 , L419 , XBOOLE_1:8;
thus L428:now
assume L429: ( R8 | ( C80 \/ C81 ) ) = ( R9 | ( C80 \/ C81 ) );
thus L430:now
let C82 being Int-Location;
assume L431: C82 in C80;
L432: C82 in ( C80 \/ C81 ) by L431 , XBOOLE_0:def 3;
thus L433: ( R8 . C82 ) = ( R9 . C82 ) by L432 , L427 , L424 , L429 , FUNCT_1:95;
end;
let C83 being FinSeq-Location;
assume L434: C83 in C81;
L435: C83 in ( C80 \/ C81 ) by L434 , XBOOLE_0:def 3;
thus L436: ( R8 . C83 ) = ( R9 . C83 ) by L435 , L427 , L424 , L429 , FUNCT_1:95;
end;
assume that
L437: (for B84 being Int-Location holds (B84 in C80 implies ( R8 . B84 ) = ( R9 . B84 )))
and
L438: (for B85 being FinSeq-Location holds (B85 in C81 implies ( R8 . B85 ) = ( R9 . B85 )));
L439:
now
thus L440:now
let C84 being set;
assume L441: C84 in C80;
L442: C84 in ( Int-Locations ) by L441;
reconsider D43 = C84 as Int-Location by L442 , AMI_2:def 16;
thus L443: ( R8 . C84 ) = ( R9 . D43 ) by L437 , L441
.= ( R9 . C84 );
end;
let C85 being set;
assume L444: C85 in C81;
L445: C85 in ( FinSeq-Locations ) by L444;
reconsider D44 = C85 as FinSeq-Location by L445 , SCMFSA_2:def 5;
thus L446: ( R8 . C85 ) = ( R9 . D44 ) by L438 , L444
.= ( R9 . C85 );
end;
L447: ( R8 | C81 ) = ( R9 | C81 ) by L439 , L419 , L421 , FUNCT_1:95;
L448: ( R8 | C80 ) = ( R9 | C80 ) by L426 , L423 , L439 , FUNCT_1:95;
thus L449: thesis by L448 , L447 , RELAT_1:150;
end;
theorem
L450: (for R8 being (State of ( SCM+FSA )) holds (for R9 being (State of ( SCM+FSA )) holds (for B86 being (Subset of ( Int-Locations )) holds (( R8 | ( B86 \/ ( FinSeq-Locations ) ) ) = ( R9 | ( B86 \/ ( FinSeq-Locations ) ) ) iff ((for B87 being Int-Location holds (B87 in B86 implies ( R8 . B87 ) = ( R9 . B87 ))) & (for B88 being FinSeq-Location holds ( R8 . B88 ) = ( R9 . B88 )))))))
proof
let R8 being (State of ( SCM+FSA ));
let R9 being (State of ( SCM+FSA ));
set D45 = ( FinSeq-Locations );
let C86 being (Subset of ( Int-Locations ));
L451: ((for B89 being FinSeq-Location holds ( R8 . B89 ) = ( R9 . B89 )) implies (for B90 being FinSeq-Location holds (B90 in D45 implies ( R8 . B90 ) = ( R9 . B90 ))));
L452: ((for B91 being FinSeq-Location holds (B91 in D45 implies ( R8 . B91 ) = ( R9 . B91 ))) implies (for B92 being FinSeq-Location holds ( R8 . B92 ) = ( R9 . B92 )))
proof
assume L453: (for B93 being FinSeq-Location holds (B93 in D45 implies ( R8 . B93 ) = ( R9 . B93 )));
let C87 being FinSeq-Location;
L454: C87 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
thus L455: thesis by L454 , L453;
end;
L456: ( [#] D45 ) = D45;
thus L457: thesis by L456 , L451 , L452 , L417;
end;
begin
theorem
L458: (for B94 being set holds (for B95 , B96 , B97 being (Element of ( NAT )) holds (B94 in ( dom ( ( ( intloc B95 ) .--> B96 ) +* ( Start-At (B97 , ( SCM+FSA )) ) ) ) implies (B94 = ( intloc B95 ) or B94 = ( IC ( SCM+FSA ) )))))
proof
let C88 being set;
let C89 , C90 , C91 being (Element of ( NAT ));
set D46 = ( ( ( intloc C89 ) .--> C90 ) +* ( Start-At (C91 , ( SCM+FSA )) ) );
L459: (( dom ( ( intloc C89 ) .--> C90 ) ) = { ( intloc C89 ) } & ( dom ( Start-At (C91 , ( SCM+FSA )) ) ) = { ( IC ( SCM+FSA ) ) }) by FUNCOP_1:13;
L460: ( dom D46 ) = ( { ( intloc C89 ) } \/ { ( IC ( SCM+FSA ) ) } ) by L459 , FUNCT_4:def 1;
assume L461: C88 in ( dom D46 );
L462: (C88 in { ( intloc C89 ) } or C88 in { ( IC ( SCM+FSA ) ) }) by L461 , L460 , XBOOLE_0:def 3;
thus L463: thesis by L462 , TARSKI:def 1;
end;
theorem
L464: (for B98 being (State of ( SCM+FSA )) holds (( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) c= B98 implies ( B98 . ( intloc ( 0 ) ) ) = 1))
proof
let C92 being (State of ( SCM+FSA ));
set D47 = ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) );
L465: ( dom D47 ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom D1 ) ) by FUNCT_4:def 1;
L466: ( intloc ( 0 ) ) in ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) by FUNCOP_1:74;
L467: ( intloc ( 0 ) ) in ( dom D47 ) by L466 , L465 , XBOOLE_0:def 3;
L468: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L469: ( IC ( SCM+FSA ) ) <> ( intloc ( 0 ) ) by SCMFSA_2:56;
L470: (not ( intloc ( 0 ) ) in ( dom D1 )) by L469 , L468 , TARSKI:def 1;
L471: ( D47 . ( intloc ( 0 ) ) ) = ( ( ( intloc ( 0 ) ) .--> 1 ) . ( intloc ( 0 ) ) ) by L470 , FUNCT_4:11
.= 1 by FUNCOP_1:72;
thus L472: thesis by L471 , L467 , GRFUNC_1:2;
end;
registration
let C93 being (Element of ( NAT ));
cluster ( intloc ( C93 + 1 ) ) ->  read-write;
coherence
proof
thus L473: ( intloc ( C93 + 1 ) ) <> ( intloc ( 0 ) ) by AMI_3:10;
end;
end;
begin
registration
let C94 being FinSeq-Location;
let C95 being (FinSequence of ( INT ));
cluster ( C94 .--> C95 ) -> ( the_Values_of ( SCM+FSA ) ) -compatible;
coherence
proof
L475: C95 is (Element of ( ( INT ) * )) by FINSEQ_1:def 11;
L476: ( Values C94 ) = ( ( INT ) * ) by SCMFSA_2:12;
thus L477: thesis by L476 , L475;
end;
end;
theorem
L479: (for B99 being (FinSequence of ( INT )) holds (for B100 being FinSeq-Location holds ( dom ( Initialized ( B100 .--> B99 ) ) ) = { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) , B100 }))
proof
let C96 being (FinSequence of ( INT ));
let C97 being FinSeq-Location;
L480: ( dom ( Initialized ( C97 .--> C96 ) ) ) = ( ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) \/ ( dom ( C97 .--> C96 ) ) ) by FUNCT_4:def 1
.= ( { ( intloc ( 0 ) ) , ( IC ( SCM+FSA ) ) } \/ { C97 } ) by L167 , FUNCOP_1:13;
thus L481: thesis by L480 , ENUMSET1:3;
end;
theorem
L482: (for B101 being (FinSequence of ( INT )) holds (for B102 being FinSeq-Location holds ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) misses ( dom ( B102 .--> B101 ) )))
proof
let C98 being (FinSequence of ( INT ));
let C99 being FinSeq-Location;
set D48 = ( C99 .--> C98 );
L483: ( dom D48 ) = { C99 } by FUNCOP_1:13;
set D49 = ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
assume L484: ( D49 /\ ( dom D48 ) ) <> ( {} );
consider C100 being set such that L485: C100 in ( D49 /\ ( dom D48 ) ) by L484 , XBOOLE_0:def 1;
L486: C100 in D49 by L485 , XBOOLE_0:def 4;
L487: C100 in ( dom D48 ) by L485 , XBOOLE_0:def 4;
L488: C100 = C99 by L487 , L483 , TARSKI:def 1;
L489: (C100 = ( intloc ( 0 ) ) or C100 = ( IC ( SCM+FSA ) )) by L486 , L167 , TARSKI:def 2;
thus L490: contradiction by L489 , L488 , SCMFSA_2:57 , SCMFSA_2:58;
end;
theorem
L491: (for B103 being (FinSequence of ( INT )) holds (for B104 being FinSeq-Location holds (for B105 being (State of ( SCM+FSA )) holds (( Initialized ( B104 .--> B103 ) ) c= B105 implies (( B105 . B104 ) = B103 & ( B105 . ( intloc ( 0 ) ) ) = 1)))))
proof
let C101 being (FinSequence of ( INT ));
let C102 being FinSeq-Location;
let C103 being (State of ( SCM+FSA ));
set D50 = ( C102 .--> C101 );
set D51 = ( Initialized D50 );
assume L492: D51 c= C103;
reconsider D52 = D51 as (PartState of ( SCM+FSA ));
L493: ( dom D50 ) = { C102 } by FUNCOP_1:13;
L494: C102 in ( dom D50 ) by L493 , TARSKI:def 1;
L495: C102 in ( dom D52 ) by L494 , FUNCT_4:12;
L496: ( intloc ( 0 ) ) in ( dom D52 ) by L107;
L497: (ex B106 being (Element of ( NAT )) st C102 = ( fsloc B106 )) by SCMFSA_2:9;
L498: C102 <> ( intloc ( 0 ) ) by L497 , SCMFSA_2:99;
L499: (not C102 in { ( intloc ( 0 ) ) }) by L498 , TARSKI:def 1;
L500: (not C102 in ( dom ( ( intloc ( 0 ) ) .--> 1 ) )) by L499 , FUNCOP_1:13;
L501: ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) ) = ( ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) \/ ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by FUNCT_4:def 1;
L502: (not C102 in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
L503: (not C102 in ( dom ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) )) by L502 , L500 , L501 , XBOOLE_0:def 3;
thus L504: ( C103 . C102 ) = ( D52 . C102 ) by L492 , L495 , GRFUNC_1:2
.= ( D50 . C102 ) by L503 , FUNCT_4:11
.= C101 by FUNCOP_1:72;
thus L505: ( C103 . ( intloc ( 0 ) ) ) = ( D51 . ( intloc ( 0 ) ) ) by L492 , L496 , GRFUNC_1:2
.= 1 by L169 , L162 , FUNCT_4:13;
end;
theorem
L506: (for B107 being FinSeq-Location holds (for B108 being Int-Location holds (for B109 being (State of ( SCM+FSA )) holds { B108 , ( IC ( SCM+FSA ) ) , B107 } c= ( dom B109 ))))
proof
let C104 being FinSeq-Location;
let C105 being Int-Location;
let C106 being (State of ( SCM+FSA ));
L507: C105 in ( dom C106 ) by SCMFSA_2:42;
L508: ( IC ( SCM+FSA ) ) in ( dom C106 ) by MEMSTR_0:2;
L509: { C105 , ( IC ( SCM+FSA ) ) } c= ( dom C106 ) by L508 , L507 , ZFMISC_1:32;
L510: C104 in ( dom C106 ) by SCMFSA_2:43;
L511: { C104 } c= ( dom C106 ) by L510 , ZFMISC_1:31;
L512: ( { C105 , ( IC ( SCM+FSA ) ) } \/ { C104 } ) c= ( dom C106 ) by L511 , L509 , XBOOLE_1:8;
thus L513: thesis by L512 , ENUMSET1:3;
end;
definition
func Sorting-Function -> (PartFunc of ( FinPartSt ( SCM+FSA ) ) , ( FinPartSt ( SCM+FSA ) )) means 
:L514: (for B110 , B111 being (FinPartState of ( SCM+FSA )) holds ([ B110 , B111 ] in it iff (ex B112 being (FinSequence of ( INT )) st (ex B113 being (FinSequence of ( REAL )) st (B112 , B113 are_fiberwise_equipotent  & B113 is (FinSequence of ( INT )) & B113 is  non-increasing & B110 = ( ( fsloc ( 0 ) ) .--> B112 ) & B111 = ( ( fsloc ( 0 ) ) .--> B113 ))))));
existence
proof
defpred S10[ set , set ] means (ex B114 being (FinSequence of ( INT )) st (ex B115 being (FinSequence of ( REAL )) st (B114 , B115 are_fiberwise_equipotent  & B115 is (FinSequence of ( INT )) & B115 is  non-increasing & $1 = ( ( fsloc ( 0 ) ) .--> B114 ) & $2 = ( ( fsloc ( 0 ) ) .--> B115 ))));
L515: (for B116 , B117 , B118 being set holds ((S10[ B116 , B117 ] & S10[ B116 , B118 ]) implies B117 = B118))
proof
let C107 , C108 , C109 being set;
given C110 being (FinSequence of ( INT )) , C111 being (FinSequence of ( REAL )) such that
L516: C110 , C111 are_fiberwise_equipotent 
and
L517: C111 is (FinSequence of ( INT ))
and
L518: C111 is  non-increasing
and
L519: C107 = ( ( fsloc ( 0 ) ) .--> C110 )
and
L520: C108 = ( ( fsloc ( 0 ) ) .--> C111 );

given C112 being (FinSequence of ( INT )) , C113 being (FinSequence of ( REAL )) such that
L521: C112 , C113 are_fiberwise_equipotent 
and
L522: C113 is (FinSequence of ( INT ))
and
L523: C113 is  non-increasing
and
L524: C107 = ( ( fsloc ( 0 ) ) .--> C112 )
and
L525: C109 = ( ( fsloc ( 0 ) ) .--> C113 );

L526: C110 = ( ( ( fsloc ( 0 ) ) .--> C110 ) . ( fsloc ( 0 ) ) ) by FUNCOP_1:72
.= C112 by L519 , L524 , FUNCOP_1:72;
thus L527: thesis by L526 , L516 , L518 , L520 , L521 , L523 , L525 , CLASSES1:76 , RFINSEQ:23;
end;
consider C114 being Function such that L528: (for B119 , B120 being set holds ([ B119 , B120 ] in C114 iff (B119 in ( FinPartSt ( SCM+FSA ) ) & S10[ B119 , B120 ]))) from FUNCT_1:sch 1(L515);
L529: ( dom C114 ) c= ( FinPartSt ( SCM+FSA ) )
proof
let C115 being set;
assume L530: C115 in ( dom C114 );
L531: [ C115 , ( C114 . C115 ) ] in C114 by L530 , FUNCT_1:1;
thus L532: thesis by L531 , L528;
end;
L533: ( rng C114 ) c= ( FinPartSt ( SCM+FSA ) )
proof
let C116 being set;
assume L534: C116 in ( rng C114 );
consider C117 being set such that L535: [ C117 , C116 ] in C114 by L534 , XTUPLE_0:def 13;
consider C118 being (FinSequence of ( INT )), C119 being (FinSequence of ( REAL )) such that L536: C118 , C119 are_fiberwise_equipotent  and L537: C119 is (FinSequence of ( INT )) and L538: C119 is  non-increasing and L539: C117 = ( ( fsloc ( 0 ) ) .--> C118 ) and L540: C116 = ( ( fsloc ( 0 ) ) .--> C119 ) by L528 , L535;
reconsider D53 = C119 as (FinSequence of ( INT )) by L537;
L541: ( ( fsloc ( 0 ) ) .--> D53 ) is (FinPartState of ( SCM+FSA ));
thus L542: thesis by L541 , L540 , MEMSTR_0:75;
end;
reconsider D54 = C114 as (PartFunc of ( FinPartSt ( SCM+FSA ) ) , ( FinPartSt ( SCM+FSA ) )) by L533 , L529 , RELSET_1:4;
take D54;
let C120 , C121 being (FinPartState of ( SCM+FSA ));
thus L543: ([ C120 , C121 ] in D54 implies (ex B121 being (FinSequence of ( INT )) st (ex B122 being (FinSequence of ( REAL )) st (B121 , B122 are_fiberwise_equipotent  & B122 is (FinSequence of ( INT )) & B122 is  non-increasing & C120 = ( ( fsloc ( 0 ) ) .--> B121 ) & C121 = ( ( fsloc ( 0 ) ) .--> B122 ))))) by L528;
given C122 being (FinSequence of ( INT )) , C123 being (FinSequence of ( REAL )) such that
L544: C122 , C123 are_fiberwise_equipotent 
and
L545: C123 is (FinSequence of ( INT ))
and
L546: C123 is  non-increasing
and
L547: C120 = ( ( fsloc ( 0 ) ) .--> C122 )
and
L548: C121 = ( ( fsloc ( 0 ) ) .--> C123 );

L549: C120 in ( FinPartSt ( SCM+FSA ) ) by MEMSTR_0:75;
thus L550: thesis by L549 , L528 , L544 , L545 , L546 , L547 , L548;
end;
uniqueness
proof
let C124 , C125 being (PartFunc of ( FinPartSt ( SCM+FSA ) ) , ( FinPartSt ( SCM+FSA ) ));
assume that
L551: (for B123 , B124 being (FinPartState of ( SCM+FSA )) holds ([ B123 , B124 ] in C124 iff (ex B125 being (FinSequence of ( INT )) st (ex B126 being (FinSequence of ( REAL )) st (B125 , B126 are_fiberwise_equipotent  & B126 is (FinSequence of ( INT )) & B126 is  non-increasing & B123 = ( ( fsloc ( 0 ) ) .--> B125 ) & B124 = ( ( fsloc ( 0 ) ) .--> B126 ))))))
and
L552: (for B127 , B128 being (FinPartState of ( SCM+FSA )) holds ([ B127 , B128 ] in C125 iff (ex B129 being (FinSequence of ( INT )) st (ex B130 being (FinSequence of ( REAL )) st (B129 , B130 are_fiberwise_equipotent  & B130 is (FinSequence of ( INT )) & B130 is  non-increasing & B127 = ( ( fsloc ( 0 ) ) .--> B129 ) & B128 = ( ( fsloc ( 0 ) ) .--> B130 ))))));
defpred S11[ set , set ] means (ex B131 being (FinSequence of ( INT )) st (ex B132 being (FinSequence of ( REAL )) st (B131 , B132 are_fiberwise_equipotent  & B132 is (FinSequence of ( INT )) & B132 is  non-increasing & $1 = ( ( fsloc ( 0 ) ) .--> B131 ) & $2 = ( ( fsloc ( 0 ) ) .--> B132 ))));
L553: (for B133 , B134 being (Element of ( FinPartSt ( SCM+FSA ) )) holds ([ B133 , B134 ] in C124 iff S11[ B133 , B134 ]))
proof
let C126 , C127 being (Element of ( FinPartSt ( SCM+FSA ) ));
reconsider D55 = C126 , D56 = C127 as (FinPartState of ( SCM+FSA )) by MEMSTR_0:76;
L554: ([ D55 , D56 ] in C124 iff S11[ D55 , D56 ]) by L551;
thus L555: thesis by L554;
end;
L556: (for B135 , B136 being (Element of ( FinPartSt ( SCM+FSA ) )) holds ([ B135 , B136 ] in C125 iff S11[ B135 , B136 ]))
proof
let C128 , C129 being (Element of ( FinPartSt ( SCM+FSA ) ));
reconsider D57 = C128 , D58 = C129 as (FinPartState of ( SCM+FSA )) by MEMSTR_0:76;
L557: ([ D57 , D58 ] in C125 iff S11[ D57 , D58 ]) by L552;
thus L558: thesis by L557;
end;
thus L559: C124 = C125 from RELSET_1:sch 4(L553 , L556);
end;
end;
theorem
L561: (for B137 being set holds (B137 in ( dom ( Sorting-Function ) ) iff (ex B138 being (FinSequence of ( INT )) st B137 = ( ( fsloc ( 0 ) ) .--> B138 ))))
proof
set D59 = ( Sorting-Function );
let C130 being set;
thus L562:now
set D60 = ( D59 . C130 );
assume L563: C130 in ( dom D59 );
L564: [ C130 , ( D59 . C130 ) ] in D59 by L563 , FUNCT_1:1;
L565: ( dom D59 ) c= ( FinPartSt ( SCM+FSA ) ) by RELAT_1:def 18;
L566: C130 is (FinPartState of ( SCM+FSA )) by L565 , L563 , MEMSTR_0:76;
L567: D60 in ( FinPartSt ( SCM+FSA ) ) by L563 , PARTFUN1:4;
L568: D60 is (FinPartState of ( SCM+FSA )) by L567 , MEMSTR_0:76;
consider C131 being (FinSequence of ( INT )), C132 being (FinSequence of ( REAL )) such that L569: C131 , C132 are_fiberwise_equipotent  and L570: C132 is (FinSequence of ( INT )) and L571: C132 is  non-increasing and L572: C130 = ( ( fsloc ( 0 ) ) .--> C131 ) and L573: D60 = ( ( fsloc ( 0 ) ) .--> C132 ) by L568 , L564 , L566 , L514;
take D61 = C131;
thus L574: C130 = ( ( fsloc ( 0 ) ) .--> D61 ) by L572;
end;
given C133 being (FinSequence of ( INT )) such that
L575: C130 = ( ( fsloc ( 0 ) ) .--> C133 );

consider C134 being (FinSequence of ( REAL )) such that L576: C133 , C134 are_fiberwise_equipotent  and L577: C134 is (FinSequence of ( INT )) and L578: C134 is  non-increasing by RFINSEQ:33;
reconsider D62 = C134 as (FinSequence of ( INT )) by L577;
set D63 = ( ( fsloc ( 0 ) ) .--> D62 );
L579: [ C130 , D63 ] in D59 by L575 , L576 , L578 , L514;
thus L580: thesis by L579 , FUNCT_1:1;
end;
theorem
L581: (for B139 being (FinSequence of ( INT )) holds (ex B140 being (FinSequence of ( REAL )) st (B139 , B140 are_fiberwise_equipotent  & B140 is  non-increasing & B140 is (FinSequence of ( INT )) & ( ( Sorting-Function ) . ( ( fsloc ( 0 ) ) .--> B139 ) ) = ( ( fsloc ( 0 ) ) .--> B140 ))))
proof
let C135 being (FinSequence of ( INT ));
consider C136 being (FinSequence of ( REAL )) such that L582: C135 , C136 are_fiberwise_equipotent  and L583: C136 is (FinSequence of ( INT )) and L584: C136 is  non-increasing by RFINSEQ:33;
reconsider D64 = C136 as (FinSequence of ( INT )) by L583;
set D65 = ( ( fsloc ( 0 ) ) .--> C135 );
set D66 = ( ( fsloc ( 0 ) ) .--> D64 );
L585: [ D65 , D66 ] in ( Sorting-Function ) by L582 , L584 , L514;
L586: ( ( Sorting-Function ) . D65 ) = D66 by L585 , FUNCT_1:1;
thus L587: thesis by L586 , L582 , L584;
end;
theorem
L588: (for R7 being (State of ( SCM+FSA )) holds ((for B141 being  read-write Int-Location holds ( ( Initialized R7 ) . B141 ) = ( R7 . B141 )) & (for R6 being FinSeq-Location holds ( ( Initialized R7 ) . R6 ) = ( R7 . R6 ))))
proof
let R7 being (State of ( SCM+FSA ));
L589: ( Initialized R7 ) = ( Initialize ( R7 +* ( ( intloc ( 0 ) ) .--> 1 ) ) ) by FUNCT_4:14;
L590: ( dom ( ( intloc ( 0 ) ) .--> 1 ) ) = { ( intloc ( 0 ) ) } by FUNCOP_1:13;
thus L591:now
let C137 being  read-write Int-Location;
L592: (not C137 in ( dom ( ( intloc ( 0 ) ) .--> 1 ) )) by L590 , TARSKI:def 1;
L593: (not C137 in ( dom D1 )) by SCMFSA_2:102;
thus L594: ( ( Initialized R7 ) . C137 ) = ( ( R7 +* ( ( intloc ( 0 ) ) .--> 1 ) ) . C137 ) by L593 , L589 , FUNCT_4:11
.= ( R7 . C137 ) by L592 , FUNCT_4:11;
end;
thus L595:now
let C138 being FinSeq-Location;
L596: ( intloc ( 0 ) ) <> C138 by SCMFSA_2:58;
L597: (not C138 in ( dom ( ( intloc ( 0 ) ) .--> 1 ) )) by L596 , L590 , TARSKI:def 1;
L598: (not C138 in ( dom D1 )) by SCMFSA_2:103;
thus L599: ( ( Initialized R7 ) . C138 ) = ( ( R7 +* ( ( intloc ( 0 ) ) .--> 1 ) ) . C138 ) by L598 , L589 , FUNCT_4:11
.= ( R7 . C138 ) by L597 , FUNCT_4:11;
end;
end;
