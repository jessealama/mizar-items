:: Monoid of Multisets and Subsets
::  by Grzegorz Bancerek
::
:: Received December 29, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, ALGSTR_0, MESFUNC1, XBOOLE_0, FUNCT_1,
      ZFMISC_1, FINSEQ_4, FUNCT_2, RELAT_1, PARTFUN1, TARSKI, FUNCOP_1,
      FINSEQ_2, FINSEQ_1, BINOP_1, SETWISEO, ALGSTR_1, MONOID_0, LATTICE2,
      MCART_1, STRUCT_0, GROUP_1, VECTSP_1, BINOP_2, CARD_1, ARYTM_3, FUNCT_3,
      FINSET_1, ORDINAL4, COMPLEX1, ARYTM_1, MONOID_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, XXREAL_0,
      REAL_1, NAT_1, RELAT_1, STRUCT_0, FUNCT_1, FINSEQ_1, MONOID_0, RELSET_1,
      PARTFUN1, FUNCT_2, BINOP_1, FUNCOP_1, SETWISEO, FINSET_1, FUNCT_3,
      FINSEQ_2, LATTICE2, FUNCT_6, DOMAIN_1, ALGSTR_0;
 constructors BINOP_1, DOMAIN_1, FUNCT_3, SETWISEO, REAL_1, BINOP_2, FUNCT_5,
      FUNCT_6, LATTICE2, MONOID_0, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FINSET_1, XREAL_0, NAT_1, FINSEQ_1, STRUCT_0, MONOID_0, CARD_1,
      RELSET_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, BINOP_1, LATTICE2, SETWISEO, MONOID_0, STRUCT_0, XBOOLE_0,
      FUNCT_6, ALGSTR_0;
 theorems TARSKI, NAT_1, FINSEQ_1, BINOP_1, SETWISEO, MCART_1, FUNCOP_1,
      ZFMISC_1, FUNCT_1, FUNCT_2, FUNCT_3, CARD_1, CARD_2, FINSEQ_2, FINSEQ_3,
      FUNCT_5, MONOID_0, GRFUNC_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1,
      GROUP_1;
 schemes NAT_1, FUNCT_2, MONOID_0, PARTFUN1, FUNCT_1, BINOP_1;

begin
deffunc H1(multMagma) = (the multF of $1);
deffunc H2(multLoopStr) = ( 1. $1 );
definition
let C1 being Function;
let C2 , C3 , C4 being set;
func C1 .. (C2 , C3 , C4) equals 
( C1 .. ([ C2 , C3 ] , C4) );
correctness;
end;
definition
let C5 , C6 , C7 , C8 being non  empty set;
let C9 being (Function of [: C6 , C7 :] , ( Funcs (C5 , C8) ));
let C10 being (Element of C6);
let C11 being (Element of C7);
let C12 being (Element of C5);
redefine func C9 .. (C10 , C11 , C12) -> (Element of C8);

coherence
proof
reconsider D1 = ( C9 . (C10 , C11) ) as (Element of ( Funcs (C5 , C8) ));
L2: [ C10 , C11 ] in [: C6 , C7 :];
L3: (( dom C9 ) = [: C6 , C7 :] & ( dom D1 ) = C5) by FUNCT_2:def 1;
L4: ( C9 .. (C10 , C11 , C12) ) = ( D1 . C12 ) by L3 , L2 , FUNCT_5:38;
thus L5: thesis by L4;
end;
end;
definition
let C13 being set;
let C14 , C15 , C16 being non  empty set;
let C17 being (Function of [: C14 , C15 :] , C16);
let C18 being (Function of C13 , C14);
let C19 being (Function of C13 , C15);
redefine func C17 .: (C18 , C19) -> (Element of ( Funcs (C13 , C16) ));

coherence
proof
L7: ( C17 .: (C18 , C19) ) = ( C17 * <: C18 , C19 :> ) by FUNCOP_1:def 3;
L8: (( dom ( C17 .: (C18 , C19) ) ) = C13 & ( rng ( C17 .: (C18 , C19) ) ) c= C16) by L7 , FUNCT_2:def 1 , RELAT_1:def 19;
thus L9: thesis by L8 , FUNCT_2:def 2;
end;
end;
notation
let C20 being non  empty set;
let C21 being (Element of ( NAT ));
let C22 being (Element of C20);
synonym C21 .--> C22 for C21 |-> C22;
end;
definition
let C23 being non  empty set;
let C24 being (Element of ( NAT ));
let C25 being (Element of C23);
redefine func C24 .--> C25 -> (FinSequence of C23);

coherence by FINSEQ_2:63;
end;
definition
let C26 being non  empty set;
let C27 being set;
let C28 being (Element of C26);
redefine func C27 --> C28 -> (Element of ( Funcs (C27 , C26) ));

coherence
proof
L13: (( dom ( C27 --> C28 ) ) = C27 & ( rng ( C27 --> C28 ) ) c= { C28 }) by FUNCOP_1:13;
thus L14: thesis by L13 , FUNCT_2:def 2;
end;
end;
definition
let C29 being set;
let C30 , C31 , C32 being non  empty set;
let C33 being (Function of [: C30 , C31 :] , C32);
let C34 being (Element of C30);
let C35 being (Function of C29 , C31);
redefine func C33 [;] (C34 , C35) -> (Element of ( Funcs (C29 , C32) ));

coherence
proof
L16: ( dom C35 ) = C29 by FUNCT_2:def 1;
L17: ( C33 [;] (C34 , C35) ) = ( C33 * <: ( C29 --> C34 ) , C35 :> ) by L16 , FUNCOP_1:def 5;
L18: (( dom ( C33 [;] (C34 , C35) ) ) = C29 & ( rng ( C33 [;] (C34 , C35) ) ) c= C32) by L17 , FUNCT_2:def 1 , RELAT_1:def 19;
thus L19: thesis by L18 , FUNCT_2:def 2;
end;
end;
definition
let C36 being set;
let C37 , C38 , C39 being non  empty set;
let C40 being (Function of [: C37 , C38 :] , C39);
let C41 being (Function of C36 , C37);
let C42 being (Element of C38);
redefine func C40 [:] (C41 , C42) -> (Element of ( Funcs (C36 , C39) ));

coherence
proof
L21: ( dom C41 ) = C36 by FUNCT_2:def 1;
L22: ( C40 [:] (C41 , C42) ) = ( C40 * <: C41 , ( C36 --> C42 ) :> ) by L21 , FUNCOP_1:def 4;
L23: (( dom ( C40 [:] (C41 , C42) ) ) = C36 & ( rng ( C40 [:] (C41 , C42) ) ) c= C39) by L22 , FUNCT_2:def 1 , RELAT_1:def 19;
thus L24: thesis by L23 , FUNCT_2:def 2;
end;
end;
theorem
L26: (for B1 , B2 being Function holds (for B3 being set holds ( ( B1 | B3 ) * B2 ) = ( B1 * ( B3 |` B2 ) )))
proof
let C43 , C44 being Function;
let C45 being set;
L27: ( dom ( C43 | C45 ) ) = ( ( dom C43 ) /\ C45 ) by RELAT_1:61;
L28: ( dom ( ( C43 | C45 ) * C44 ) ) = ( dom ( C43 * ( C45 |` C44 ) ) )
proof
thus L29: ( dom ( ( C43 | C45 ) * C44 ) ) c= ( dom ( C43 * ( C45 |` C44 ) ) )
proof
let R1 being set;
assume L30: R1 in ( dom ( ( C43 | C45 ) * C44 ) );
L31: R1 in ( dom C44 ) by L30 , FUNCT_1:11;
L32: ( C44 . R1 ) in ( dom ( C43 | C45 ) ) by L30 , FUNCT_1:11;
L33: ( C44 . R1 ) in ( dom C43 ) by L32 , L27 , XBOOLE_0:def 4;
L34: ( C44 . R1 ) in C45 by L27 , L32 , XBOOLE_0:def 4;
L35: R1 in ( dom ( C45 |` C44 ) ) by L34 , L31 , FUNCT_1:53;
L36: ( C44 . R1 ) = ( ( C45 |` C44 ) . R1 ) by L35 , FUNCT_1:53;
thus L37: thesis by L36 , L33 , L35 , FUNCT_1:11;
end;

let R1 being set;
assume L38: R1 in ( dom ( C43 * ( C45 |` C44 ) ) );
L39: R1 in ( dom ( C45 |` C44 ) ) by L38 , FUNCT_1:11;
L40: R1 in ( dom C44 ) by L39 , FUNCT_1:53;
L41: ( ( C45 |` C44 ) . R1 ) in ( dom C43 ) by L38 , FUNCT_1:11;
L42: ( C44 . R1 ) in ( dom C43 ) by L41 , L39 , FUNCT_1:53;
L43: ( C44 . R1 ) in C45 by L39 , FUNCT_1:53;
L44: ( C44 . R1 ) in ( dom ( C43 | C45 ) ) by L43 , L27 , L42 , XBOOLE_0:def 4;
thus L45: thesis by L44 , L40 , FUNCT_1:11;
end;
L46:
now
let R1 being set;
assume L47: R1 in ( dom ( ( C43 | C45 ) * C44 ) );
L48: (( ( ( C43 | C45 ) * C44 ) . R1 ) = ( ( C43 | C45 ) . ( C44 . R1 ) ) & ( C44 . R1 ) in ( dom ( C43 | C45 ) )) by L47 , FUNCT_1:11 , FUNCT_1:12;
L49: ( ( ( C43 | C45 ) * C44 ) . R1 ) = ( C43 . ( C44 . R1 ) ) by L48 , FUNCT_1:47;
L50: (( ( C43 * ( C45 |` C44 ) ) . R1 ) = ( C43 . ( ( C45 |` C44 ) . R1 ) ) & R1 in ( dom ( C45 |` C44 ) )) by L28 , L47 , FUNCT_1:11 , FUNCT_1:12;
thus L51: ( ( ( C43 | C45 ) * C44 ) . R1 ) = ( ( C43 * ( C45 |` C44 ) ) . R1 ) by L50 , L49 , FUNCT_1:53;
end;
thus L52: thesis by L46 , L28 , FUNCT_1:2;
end;
scheme NonUniqFuncDEx { F1() -> set , F2() -> non  empty set , P1[set , set] } : (ex B4 being (Function of F1() , F2()) st (for R1 being set holds (R1 in F1() implies P1[ R1 , ( B4 . R1 ) ])))
provided
L53: (for R1 being set holds (R1 in F1() implies (ex B5 being (Element of F2()) st P1[ R1 , B5 ])))
proof
L54: (for R1 being set holds (R1 in F1() implies (ex R2 being set st (R2 in F2() & P1[ R1 , R2 ]))))
proof
let R1 being set;
assume L55: R1 in F1();
consider C46 being (Element of F2()) such that L56: P1[ R1 , C46 ] by L55 , L53;
take C46;
thus L57: thesis by L56;
end;
consider C47 being Function such that L58: (( dom C47 ) = F1() & ( rng C47 ) c= F2() & (for R1 being set holds (R1 in F1() implies P1[ R1 , ( C47 . R1 ) ]))) from FUNCT_1:sch 5(L54);
reconsider D2 = C47 as (Function of F1() , F2()) by L58 , FUNCT_2:def 1 , RELSET_1:4;
take D2;
thus L59: thesis by L58;
end;
begin
definition
let C48 , C49 , C50 being non  empty set;
let C51 being (Function of [: C48 , C49 :] , C50);
let C52 being set;
func (C51 , C50) .: C52 -> (Function of [: ( Funcs (C52 , C48) ) , ( Funcs (C52 , C49) ) :] , ( Funcs (C52 , C50) )) means 
:L60: (for B6 being (Element of ( Funcs (C52 , C48) )) holds (for B7 being (Element of ( Funcs (C52 , C49) )) holds ( it . (B6 , B7) ) = ( C51 .: (B6 , B7) )));
existence
proof
deffunc H3((Element of ( Funcs (C52 , C48) )) , (Element of ( Funcs (C52 , C49) ))) = ( C51 .: ($1 , $2) );
consider C53 being (Function of [: ( Funcs (C52 , C48) ) , ( Funcs (C52 , C49) ) :] , ( Funcs (C52 , C50) )) such that L61: (for B8 being (Element of ( Funcs (C52 , C48) )) holds (for B9 being (Element of ( Funcs (C52 , C49) )) holds ( C53 . (B8 , B9) ) = H3(B8 , B9))) from BINOP_1:sch 4;
take C53;
let C54 being (Element of ( Funcs (C52 , C48) ));
let C55 being (Element of ( Funcs (C52 , C49) ));
thus L62: thesis by L61;
end;
uniqueness
proof
let C56 , C57 being (Function of [: ( Funcs (C52 , C48) ) , ( Funcs (C52 , C49) ) :] , ( Funcs (C52 , C50) ));
assume that
L63: (for B10 being (Element of ( Funcs (C52 , C48) )) holds (for B11 being (Element of ( Funcs (C52 , C49) )) holds ( C56 . (B10 , B11) ) = ( C51 .: (B10 , B11) )))
and
L64: (for B12 being (Element of ( Funcs (C52 , C48) )) holds (for B13 being (Element of ( Funcs (C52 , C49) )) holds ( C57 . (B12 , B13) ) = ( C51 .: (B12 , B13) )));
L65:
now
let C58 being (Element of ( Funcs (C52 , C48) ));
let C59 being (Element of ( Funcs (C52 , C49) ));
thus L66: ( C56 . (C58 , C59) ) = ( C51 .: (C58 , C59) ) by L63
.= ( C57 . (C58 , C59) ) by L64;
end;
thus L67: thesis by L65 , BINOP_1:2;
end;
end;
theorem
L69: (for B14 , B15 , B16 being non  empty set holds (for B17 being (Function of [: B14 , B15 :] , B16) holds (for B18 being set holds (for B19 being (Function of B18 , B14) holds (for B20 being (Function of B18 , B15) holds (for R1 being set holds (R1 in B18 implies ( ( (B17 , B16) .: B18 ) .. (B19 , B20 , R1) ) = ( B17 . (( B19 . R1 ) , ( B20 . R1 )) ))))))))
proof
let C60 , C61 , C62 being non  empty set;
let C63 being (Function of [: C60 , C61 :] , C62);
let C64 being set;
let C65 being (Function of C64 , C60);
let C66 being (Function of C64 , C61);
L70: (( dom C66 ) = C64 & ( rng C66 ) c= C61) by FUNCT_2:def 1;
reconsider D3 = C66 as (Element of ( Funcs (C64 , C61) )) by L70 , FUNCT_2:def 2;
L71: (( dom C65 ) = C64 & ( rng C65 ) c= C60) by FUNCT_2:def 1;
reconsider D4 = C65 as (Element of ( Funcs (C64 , C60) )) by L71 , FUNCT_2:def 2;
L72: ( dom ( C63 .: (D4 , D3) ) ) = C64 by FUNCT_2:def 1;
L73: (( ( (C63 , C62) .: C64 ) . (D4 , D3) ) = ( C63 .: (D4 , D3) ) & [ D4 , D3 ] = [ D4 , D3 ]) by L60;
let R1 being set;
assume that
L74: R1 in C64;
L75: (( dom ( (C63 , C62) .: C64 ) ) = [: ( Funcs (C64 , C60) ) , ( Funcs (C64 , C61) ) :] & ( ( C63 .: (D4 , D3) ) . R1 ) = ( C63 . (( D4 . R1 ) , ( D3 . R1 )) )) by L74 , L72 , FUNCOP_1:22 , FUNCT_2:def 1;
thus L76: thesis by L75 , L74 , L72 , L73 , FUNCT_5:38;
end;
theorem
L77: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (for R17 being (Function of R8 , R9) holds (for R18 being (Function of R8 , R9) holds (R15 is  commutative implies ( R15 .: (R17 , R18) ) = ( R15 .: (R18 , R17) )))))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
let R17 being (Function of R8 , R9);
let R18 being (Function of R8 , R9);
L78: ( dom ( R15 .: (R17 , R18) ) ) = R8 by FUNCT_2:def 1;
L79: (( dom R17 ) = R8 & ( dom R18 ) = R8) by FUNCT_2:def 1;
L80: ( dom ( R15 .: (R18 , R17) ) ) = R8 by FUNCT_2:def 1;
assume L81: (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds ( R15 . (R10 , R11) ) = ( R15 . (R11 , R10) )));
L82:
now
let R1 being set;
assume L83: R1 in R8;
L84: (( R17 . R1 ) in ( rng R17 ) & ( R18 . R1 ) in ( rng R18 )) by L83 , L79 , FUNCT_1:def 3;
reconsider D5 = ( R17 . R1 ) , D6 = ( R18 . R1 ) as (Element of R9) by L84;
thus L85: ( ( R15 .: (R17 , R18) ) . R1 ) = ( R15 . (D5 , D6) ) by L78 , L83 , FUNCOP_1:22
.= ( R15 . (D6 , D5) ) by L81
.= ( ( R15 .: (R18 , R17) ) . R1 ) by L80 , L83 , FUNCOP_1:22;
end;
thus L86: thesis by L82 , L78 , L80 , FUNCT_1:2;
end;
theorem
L87: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (for R17 being (Function of R8 , R9) holds (for R18 being (Function of R8 , R9) holds (for R19 being (Function of R8 , R9) holds (R15 is  associative implies ( R15 .: (( R15 .: (R17 , R18) ) , R19) ) = ( R15 .: (R17 , ( R15 .: (R18 , R19) )) ))))))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
let R17 being (Function of R8 , R9);
let R18 being (Function of R8 , R9);
let R19 being (Function of R8 , R9);
L88: ( dom ( R15 .: (R17 , R18) ) ) = R8 by FUNCT_2:def 1;
L89: ( dom ( R15 .: (R18 , R19) ) ) = R8 by FUNCT_2:def 1;
L90: (( dom R17 ) = R8 & ( dom R18 ) = R8) by FUNCT_2:def 1;
L91: ( dom ( R15 .: (( R15 .: (R17 , R18) ) , R19) ) ) = R8 by FUNCT_2:def 1;
L92: ( dom R19 ) = R8 by FUNCT_2:def 1;
L93: ( dom ( R15 .: (R17 , ( R15 .: (R18 , R19) )) ) ) = R8 by FUNCT_2:def 1;
assume L94: (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds ( R15 . (( R15 . (R10 , R11) ) , R12) ) = ( R15 . (R10 , ( R15 . (R11 , R12) )) ))));
L95:
now
let R1 being set;
assume L96: R1 in R8;
L97: ( R19 . R1 ) in ( rng R19 ) by L96 , L92 , FUNCT_1:def 3;
L98: (( R17 . R1 ) in ( rng R17 ) & ( R18 . R1 ) in ( rng R18 )) by L90 , L96 , FUNCT_1:def 3;
reconsider D7 = ( R17 . R1 ) , D8 = ( R18 . R1 ) , D9 = ( R19 . R1 ) as (Element of R9) by L98 , L97;
thus L99: ( ( R15 .: (( R15 .: (R17 , R18) ) , R19) ) . R1 ) = ( R15 . (( ( R15 .: (R17 , R18) ) . R1 ) , D9) ) by L91 , L96 , FUNCOP_1:22
.= ( R15 . (( R15 . (D7 , D8) ) , D9) ) by L88 , L96 , FUNCOP_1:22
.= ( R15 . (D7 , ( R15 . (D8 , D9) )) ) by L94
.= ( R15 . (D7 , ( ( R15 .: (R18 , R19) ) . R1 )) ) by L89 , L96 , FUNCOP_1:22
.= ( ( R15 .: (R17 , ( R15 .: (R18 , R19) )) ) . R1 ) by L93 , L96 , FUNCOP_1:22;
end;
thus L100: thesis by L95 , L91 , L93 , FUNCT_1:2;
end;
theorem
L101: (for R8 being set holds (for R9 being non  empty set holds (for R10 being (Element of R9) holds (for R15 being (BinOp of R9) holds (for R17 being (Function of R8 , R9) holds (R10 is_a_unity_wrt R15 implies (( R15 [;] (R10 , R17) ) = R17 & ( R15 [:] (R17 , R10) ) = R17)))))))
proof
let R8 being set;
let R9 being non  empty set;
let R10 being (Element of R9);
let R15 being (BinOp of R9);
let R17 being (Function of R8 , R9);
assume L102: R10 is_a_unity_wrt R15;
L103: ( dom R17 ) = R8 by FUNCT_2:def 1;
L104: ( dom ( R15 [;] (R10 , R17) ) ) = R8 by FUNCT_2:def 1;
L105:
now
let R1 being set;
assume L106: R1 in R8;
L107: ( R17 . R1 ) in ( rng R17 ) by L106 , L103 , FUNCT_1:def 3;
reconsider D10 = ( R17 . R1 ) as (Element of R9) by L107;
thus L108: ( ( R15 [;] (R10 , R17) ) . R1 ) = ( R15 . (R10 , D10) ) by L104 , L106 , FUNCOP_1:32
.= ( R17 . R1 ) by L102 , BINOP_1:3;
end;
thus L109: ( R15 [;] (R10 , R17) ) = R17 by L105 , L104 , L103 , FUNCT_1:2;
L110: ( dom ( R15 [:] (R17 , R10) ) ) = R8 by FUNCT_2:def 1;
L111:
now
let R1 being set;
assume L112: R1 in R8;
L113: ( R17 . R1 ) in ( rng R17 ) by L112 , L103 , FUNCT_1:def 3;
reconsider D11 = ( R17 . R1 ) as (Element of R9) by L113;
thus L114: ( ( R15 [:] (R17 , R10) ) . R1 ) = ( R15 . (D11 , R10) ) by L110 , L112 , FUNCOP_1:27
.= ( R17 . R1 ) by L102 , BINOP_1:3;
end;
thus L115: thesis by L111 , L110 , L103 , FUNCT_1:2;
end;
theorem
L116: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (for R17 being (Function of R8 , R9) holds (R15 is  idempotent implies ( R15 .: (R17 , R17) ) = R17)))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
let R17 being (Function of R8 , R9);
L117: ( dom ( R15 .: (R17 , R17) ) ) = R8 by FUNCT_2:def 1;
assume L118: (for R10 being (Element of R9) holds ( R15 . (R10 , R10) ) = R10);
L119:
now
let R1 being set;
assume L120: R1 in R8;
reconsider D12 = ( R17 . R1 ) as (Element of R9) by L120 , FUNCT_2:5;
thus L121: ( ( R15 .: (R17 , R17) ) . R1 ) = ( R15 . (D12 , D12) ) by L117 , L120 , FUNCOP_1:22
.= ( R17 . R1 ) by L118;
end;
L122: ( dom R17 ) = R8 by FUNCT_2:def 1;
thus L123: thesis by L122 , L117 , L119 , FUNCT_1:2;
end;
theorem
L124: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  commutative implies ( (R15 , R9) .: R8 ) is  commutative))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L125: R15 is  commutative;
set D13 = ( (R15 , R9) .: R8 );
let C67 , C68 being (Element of ( Funcs (R8 , R9) ));
thus L126: ( D13 . (C67 , C68) ) = ( R15 .: (C67 , C68) ) by L60
.= ( R15 .: (C68 , C67) ) by L125 , L77
.= ( D13 . (C68 , C67) ) by L60;
end;
theorem
L127: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  associative implies ( (R15 , R9) .: R8 ) is  associative))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L128: R15 is  associative;
set D14 = ( (R15 , R9) .: R8 );
let C69 , C70 , C71 being (Element of ( Funcs (R8 , R9) ));
thus L129: ( D14 . (( D14 . (C69 , C70) ) , C71) ) = ( D14 . (( R15 .: (C69 , C70) ) , C71) ) by L60
.= ( R15 .: (( R15 .: (C69 , C70) ) , C71) ) by L60
.= ( R15 .: (C69 , ( R15 .: (C70 , C71) )) ) by L128 , L87
.= ( D14 . (C69 , ( R15 .: (C70 , C71) )) ) by L60
.= ( D14 . (C69 , ( D14 . (C70 , C71) )) ) by L60;
end;
theorem
L130: (for R8 being set holds (for R9 being non  empty set holds (for R10 being (Element of R9) holds (for R15 being (BinOp of R9) holds (R10 is_a_unity_wrt R15 implies ( R8 --> R10 ) is_a_unity_wrt ( (R15 , R9) .: R8 ))))))
proof
let R8 being set;
let R9 being non  empty set;
let R10 being (Element of R9);
let R15 being (BinOp of R9);
set D15 = ( R8 --> R10 );
set D16 = ( (R15 , R9) .: R8 );
assume L131: R10 is_a_unity_wrt R15;
L132:
now
let C72 being (Element of ( Funcs (R8 , R9) ));
L133: ( dom C72 ) = R8 by FUNCT_2:def 1;
thus L134: ( D16 . (D15 , C72) ) = ( R15 .: (D15 , C72) ) by L60
.= ( R15 [;] (R10 , C72) ) by L133 , FUNCOP_1:31
.= C72 by L131 , L101;
thus L135: ( D16 . (C72 , D15) ) = ( R15 .: (C72 , D15) ) by L60
.= ( R15 [:] (C72 , R10) ) by L133 , FUNCOP_1:26
.= C72 by L131 , L101;
end;
thus L136: thesis by L132 , BINOP_1:3;
end;
theorem
L137: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  having_a_unity implies (( the_unity_wrt ( (R15 , R9) .: R8 ) ) = ( R8 --> ( the_unity_wrt R15 ) ) & ( (R15 , R9) .: R8 ) is  having_a_unity)))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
given R10 being (Element of R9) such that
L138: R10 is_a_unity_wrt R15;

L139: (R10 = ( the_unity_wrt R15 ) & ( R8 --> R10 ) is_a_unity_wrt ( (R15 , R9) .: R8 )) by L138 , L130 , BINOP_1:def 8;
thus L140: ( the_unity_wrt ( (R15 , R9) .: R8 ) ) = ( R8 --> ( the_unity_wrt R15 ) ) by L139 , BINOP_1:def 8;
take ( R8 --> R10 );
thus L141: thesis by L138 , L130;
end;
theorem
L142: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  idempotent implies ( (R15 , R9) .: R8 ) is  idempotent))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L143: R15 is  idempotent;
let C73 being (Element of ( Funcs (R8 , R9) ));
thus L144: ( ( (R15 , R9) .: R8 ) . (C73 , C73) ) = ( R15 .: (C73 , C73) ) by L60
.= C73 by L143 , L116;
end;
theorem
L145: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  invertible implies ( (R15 , R9) .: R8 ) is  invertible))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L146: (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds (ex R14 being (Element of R9) st (ex R13 being (Element of R9) st (( R15 . (R10 , R14) ) = R11 & ( R15 . (R13 , R10) ) = R11)))));
let C74 , C75 being (Element of ( Funcs (R8 , R9) ));
defpred S1[ set , set ] means ( R15 . (( C74 . $1 ) , $2) ) = ( C75 . $1 );
L147: (for R1 being set holds (R1 in R8 implies (ex R12 being (Element of R9) st S1[ R1 , R12 ])))
proof
let R1 being set;
assume L148: R1 in R8;
reconsider D17 = ( C74 . R1 ) , D18 = ( C75 . R1 ) as (Element of R9) by L148 , FUNCT_2:5;
consider R14 being (Element of R9), R13 being (Element of R9) such that L149: ( R15 . (D17 , R14) ) = D18 and L150: ( R15 . (R13 , D17) ) = D18 by L146;
take R14;
thus L151: thesis by L149;
end;
consider C76 being (Function of R8 , R9) such that L152: (for R1 being set holds (R1 in R8 implies S1[ R1 , ( C76 . R1 ) ])) from NonUniqFuncDEx(L147);
defpred S2[ set , set ] means ( R15 . ($2 , ( C74 . $1 )) ) = ( C75 . $1 );
L153: (for R1 being set holds (R1 in R8 implies (ex R12 being (Element of R9) st S2[ R1 , R12 ])))
proof
let R1 being set;
assume L154: R1 in R8;
reconsider D19 = ( C74 . R1 ) , D20 = ( C75 . R1 ) as (Element of R9) by L154 , FUNCT_2:5;
consider R14 being (Element of R9), R13 being (Element of R9) such that L155: ( R15 . (D19 , R14) ) = D20 and L156: ( R15 . (R13 , D19) ) = D20 by L146;
take R13;
thus L157: thesis by L156;
end;
consider C77 being (Function of R8 , R9) such that L158: (for R1 being set holds (R1 in R8 implies S2[ R1 , ( C77 . R1 ) ])) from NonUniqFuncDEx(L153);
L159: (( dom C76 ) = R8 & ( dom C77 ) = R8) by FUNCT_2:def 1;
L160: (( rng C76 ) c= R9 & ( rng C77 ) c= R9);
reconsider D21 = C76 , D22 = C77 as (Element of ( Funcs (R8 , R9) )) by L160 , L159 , FUNCT_2:def 2;
take D21;
take D22;
L161: ( dom C75 ) = R8 by FUNCT_2:def 1;
L162: ( dom ( R15 .: (C74 , D21) ) ) = R8 by FUNCT_2:def 1;
L163:
now
let R1 being set;
assume L164: R1 in R8;
thus L165: ( ( R15 .: (C74 , D21) ) . R1 ) = ( R15 . (( C74 . R1 ) , ( D21 . R1 )) ) by L164 , L162 , FUNCOP_1:22
.= ( C75 . R1 ) by L152 , L164;
end;
L166: ( R15 .: (C74 , D21) ) = ( ( (R15 , R9) .: R8 ) . (C74 , D21) ) by L60;
thus L167: ( ( (R15 , R9) .: R8 ) . (C74 , D21) ) = C75 by L166 , L162 , L161 , L163 , FUNCT_1:2;
L168: ( dom ( R15 .: (D22 , C74) ) ) = R8 by FUNCT_2:def 1;
L169:
now
let R1 being set;
assume L170: R1 in R8;
thus L171: ( ( R15 .: (D22 , C74) ) . R1 ) = ( R15 . (( D22 . R1 ) , ( C74 . R1 )) ) by L170 , L168 , FUNCOP_1:22
.= ( C75 . R1 ) by L158 , L170;
end;
L172: ( R15 .: (D22 , C74) ) = ( ( (R15 , R9) .: R8 ) . (D22 , C74) ) by L60;
thus L173: thesis by L172 , L168 , L161 , L169 , FUNCT_1:2;
end;
theorem
L174: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  cancelable implies ( (R15 , R9) .: R8 ) is  cancelable))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L175: (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds (for R12 being (Element of R9) holds ((( R15 . (R10 , R11) ) = ( R15 . (R10 , R12) ) or ( R15 . (R11 , R10) ) = ( R15 . (R12 , R10) )) implies R11 = R12))));
let C78 , C79 , C80 being (Element of ( Funcs (R8 , R9) ));
assume that
L176: (( ( (R15 , R9) .: R8 ) . (C78 , C79) ) = ( ( (R15 , R9) .: R8 ) . (C78 , C80) ) or ( ( (R15 , R9) .: R8 ) . (C79 , C78) ) = ( ( (R15 , R9) .: R8 ) . (C80 , C78) ));
L177: (R8 = ( dom ( R15 .: (C79 , C78) ) ) & R8 = ( dom ( R15 .: (C80 , C78) ) )) by FUNCT_2:def 1;
L178: (( ( (R15 , R9) .: R8 ) . (C78 , C80) ) = ( R15 .: (C78 , C80) ) & ( ( (R15 , R9) .: R8 ) . (C80 , C78) ) = ( R15 .: (C80 , C78) )) by L60;
L179: (R8 = ( dom ( R15 .: (C78 , C79) ) ) & R8 = ( dom ( R15 .: (C78 , C80) ) )) by FUNCT_2:def 1;
L180: (( ( (R15 , R9) .: R8 ) . (C78 , C79) ) = ( R15 .: (C78 , C79) ) & ( ( (R15 , R9) .: R8 ) . (C79 , C78) ) = ( R15 .: (C79 , C78) )) by L60;
L181:
now
let R1 being set;
assume L182: R1 in R8;
reconsider D23 = ( C78 . R1 ) , D24 = ( C79 . R1 ) , D25 = ( C80 . R1 ) as (Element of R9) by L182 , FUNCT_2:5;
L183: (( ( R15 .: (C79 , C78) ) . R1 ) = ( R15 . (D24 , D23) ) & ( ( R15 .: (C80 , C78) ) . R1 ) = ( R15 . (D25 , D23) )) by L177 , L182 , FUNCOP_1:22;
L184: (( ( R15 .: (C78 , C79) ) . R1 ) = ( R15 . (D23 , D24) ) & ( ( R15 .: (C78 , C80) ) . R1 ) = ( R15 . (D23 , D25) )) by L179 , L182 , FUNCOP_1:22;
thus L185: ( C79 . R1 ) = ( C80 . R1 ) by L184 , L175 , L176 , L180 , L178 , L183;
end;
L186: (( dom C79 ) = R8 & ( dom C80 ) = R8) by FUNCT_2:def 1;
thus L187: thesis by L186 , L181 , FUNCT_1:2;
end;
theorem
L188: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  uniquely-decomposable implies ( (R15 , R9) .: R8 ) is  uniquely-decomposable))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume that
L189: R15 is  having_a_unity
and
L190: (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds (( R15 . (R10 , R11) ) = ( the_unity_wrt R15 ) implies (R10 = R11 & R11 = ( the_unity_wrt R15 )))));
L191: ( the_unity_wrt ( (R15 , R9) .: R8 ) ) = ( R8 --> ( the_unity_wrt R15 ) ) by L189 , L137;
thus L192: ( (R15 , R9) .: R8 ) is  having_a_unity by L189 , L137;
let C81 , C82 being (Element of ( Funcs (R8 , R9) ));
assume that
L193: ( ( (R15 , R9) .: R8 ) . (C81 , C82) ) = ( the_unity_wrt ( (R15 , R9) .: R8 ) );
L194: ( dom ( R15 .: (C81 , C82) ) ) = R8 by FUNCT_2:def 1;
L195: ( ( (R15 , R9) .: R8 ) . (C81 , C82) ) = ( R15 .: (C81 , C82) ) by L60;
L196:
now
let R1 being set;
assume L197: R1 in R8;
reconsider D26 = ( C81 . R1 ) , D27 = ( C82 . R1 ) as (Element of R9) by L197 , FUNCT_2:5;
L198: (( ( R15 .: (C81 , C82) ) . R1 ) = ( R15 . (D26 , D27) ) & ( ( R8 --> ( the_unity_wrt R15 ) ) . R1 ) = ( the_unity_wrt R15 )) by L194 , L197 , FUNCOP_1:7 , FUNCOP_1:22;
thus L199: ( C81 . R1 ) = ( C82 . R1 ) by L198 , L190 , L193 , L195 , L191;
end;
L200:
now
let R1 being set;
assume L201: R1 in R8;
reconsider D28 = ( C81 . R1 ) , D29 = ( C82 . R1 ) as (Element of R9) by L201 , FUNCT_2:5;
L202: (( ( R15 .: (C81 , C82) ) . R1 ) = ( R15 . (D28 , D29) ) & ( ( R8 --> ( the_unity_wrt R15 ) ) . R1 ) = ( the_unity_wrt R15 )) by L194 , L201 , FUNCOP_1:7 , FUNCOP_1:22;
thus L203: ( C82 . R1 ) = ( ( R8 --> ( the_unity_wrt R15 ) ) . R1 ) by L202 , L190 , L193 , L195 , L191;
end;
L204: ( dom C82 ) = R8 by FUNCT_2:def 1;
L205: ( dom C81 ) = R8 by FUNCT_2:def 1;
thus L206: C81 = C82 by L205 , L204 , L196 , FUNCT_1:2;
L207: ( dom ( R8 --> ( the_unity_wrt R15 ) ) ) = R8 by FUNCT_2:def 1;
thus L208: thesis by L207 , L191 , L204 , L200 , FUNCT_1:2;
end;
theorem
L209: (for R8 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (for R16 being (BinOp of R9) holds (R15 absorbs R16 implies ( (R15 , R9) .: R8 ) absorbs ( (R16 , R9) .: R8 ))))))
proof
let R8 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
let R16 being (BinOp of R9);
assume L210: (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds ( R15 . (R10 , ( R16 . (R10 , R11) )) ) = R10));
let C83 , C84 being (Element of ( Funcs (R8 , R9) ));
L211: ( dom ( R15 .: (C83 , ( R16 .: (C83 , C84) )) ) ) = R8 by FUNCT_2:def 1;
L212: ( dom ( R16 .: (C83 , C84) ) ) = R8 by FUNCT_2:def 1;
L213:
now
let R1 being set;
assume L214: R1 in R8;
reconsider D30 = ( C83 . R1 ) , D31 = ( C84 . R1 ) as (Element of R9) by L214 , FUNCT_2:5;
L215: (( ( R15 .: (C83 , ( R16 .: (C83 , C84) )) ) . R1 ) = ( R15 . (D30 , ( ( R16 .: (C83 , C84) ) . R1 )) ) & ( ( R16 .: (C83 , C84) ) . R1 ) = ( R16 . (D30 , D31) )) by L212 , L211 , L214 , FUNCOP_1:22;
thus L216: ( C83 . R1 ) = ( ( R15 .: (C83 , ( R16 .: (C83 , C84) )) ) . R1 ) by L215 , L210;
end;
L217: ( dom C83 ) = R8 by FUNCT_2:def 1;
L218: (( ( (R16 , R9) .: R8 ) . (C83 , C84) ) = ( R16 .: (C83 , C84) ) & ( ( (R15 , R9) .: R8 ) . (C83 , ( R16 .: (C83 , C84) )) ) = ( R15 .: (C83 , ( R16 .: (C83 , C84) )) )) by L60;
thus L219: thesis by L218 , L217 , L211 , L213 , FUNCT_1:2;
end;
theorem
L220: (for R8 being set holds (for B21 , B22 , B23 , B24 , B25 , B26 being non  empty set holds (for B27 being (Function of [: B21 , B22 :] , B23) holds (for B28 being (Function of [: B24 , B25 :] , B26) holds (B27 c= B28 implies ( (B27 , B23) .: R8 ) c= ( (B28 , B26) .: R8 ))))))
proof
let R8 being set;
let C85 , C86 , C87 , C88 , C89 , C90 being non  empty set;
let C91 being (Function of [: C85 , C86 :] , C87);
let C92 being (Function of [: C88 , C89 :] , C90);
L221: ( dom C91 ) = [: C85 , C86 :] by FUNCT_2:def 1;
assume L222: C91 c= C92;
L223: ( dom C91 ) c= ( dom C92 ) by L222 , GRFUNC_1:2;
L224: ( dom C92 ) = [: C88 , C89 :] by FUNCT_2:def 1;
L225: C86 c= C89 by L224 , L223 , L221 , ZFMISC_1:114;
L226: ( Funcs (R8 , C86) ) c= ( Funcs (R8 , C89) ) by L225 , FUNCT_5:56;
L227: C85 c= C88 by L223 , L221 , L224 , ZFMISC_1:114;
L228: ( Funcs (R8 , C85) ) c= ( Funcs (R8 , C88) ) by L227 , FUNCT_5:56;
L229:
now
let R1 being set;
assume L230: R1 in ( dom ( (C91 , C87) .: R8 ) );
reconsider D32 = R1 as (Element of [: ( Funcs (R8 , C85) ) , ( Funcs (R8 , C86) ) :]) by L230;
reconsider D33 = ( D32 `2 ) as (Element of ( Funcs (R8 , C89) )) by L226 , TARSKI:def 3;
reconsider D34 = ( D32 `2 ) as (Element of ( Funcs (R8 , C86) ));
reconsider D35 = ( D32 `1 ) as (Element of ( Funcs (R8 , C88) )) by L228 , TARSKI:def 3;
reconsider D36 = ( D32 `1 ) as (Element of ( Funcs (R8 , C85) ));
L231: (( dom ( C92 .: (D35 , D33) ) ) = R8 & ( dom ( C91 .: (D36 , D34) ) ) = R8) by FUNCT_2:def 1;
L232: (( dom D36 ) = R8 & ( dom D34 ) = R8) by FUNCT_2:def 1;
L233:
now
let C93 being set;
assume L234: C93 in R8;
L235: (( D36 . C93 ) in ( rng D36 ) & ( D34 . C93 ) in ( rng D34 )) by L234 , L232 , FUNCT_1:def 3;
L236: [ ( D36 . C93 ) , ( D34 . C93 ) ] in ( dom C91 ) by L235 , L221 , ZFMISC_1:87;
L237: (( ( C92 .: (D35 , D33) ) . C93 ) = ( C92 . (( D35 . C93 ) , ( D33 . C93 )) ) & ( ( C91 .: (D36 , D34) ) . C93 ) = ( C91 . (( D36 . C93 ) , ( D34 . C93 )) )) by L231 , L234 , FUNCOP_1:22;
thus L238: ( ( C92 .: (D35 , D33) ) . C93 ) = ( ( C91 .: (D36 , D34) ) . C93 ) by L237 , L222 , L236 , GRFUNC_1:2;
end;
L239: [ D36 , D34 ] = R1 by MCART_1:21;
L240: (( ( (C91 , C87) .: R8 ) . (D36 , D34) ) = ( C91 .: (D36 , D34) ) & ( ( (C92 , C90) .: R8 ) . (D35 , D33) ) = ( C92 .: (D35 , D33) )) by L60;
thus L241: ( ( (C91 , C87) .: R8 ) . R1 ) = ( ( (C92 , C90) .: R8 ) . R1 ) by L240 , L231 , L233 , L239 , FUNCT_1:2;
end;
L242: (( dom ( (C91 , C87) .: R8 ) ) = [: ( Funcs (R8 , C85) ) , ( Funcs (R8 , C86) ) :] & ( dom ( (C92 , C90) .: R8 ) ) = [: ( Funcs (R8 , C88) ) , ( Funcs (R8 , C89) ) :]) by FUNCT_2:def 1;
L243: ( dom ( (C91 , C87) .: R8 ) ) c= ( dom ( (C92 , C90) .: R8 ) ) by L242 , L228 , L226 , ZFMISC_1:96;
thus L244: thesis by L243 , L229 , GRFUNC_1:2;
end;
definition
let C94 being non  empty multMagma;
let C95 being set;
func .: (C94 , C95) -> multMagma equals 
:L245: multLoopStr (# ( Funcs (C95 , (the carrier of C94)) ) , ( ((the multF of C94) , (the carrier of C94)) .: C95 ) , ( C95 --> ( the_unity_wrt (the multF of C94) ) ) #) if C94 is  unital otherwise multMagma (# ( Funcs (C95 , (the carrier of C94)) ) , ( ((the multF of C94) , (the carrier of C94)) .: C95 ) #);
correctness;
end;
registration
let C96 being non  empty multMagma;
let C97 being set;
cluster ( .: (C96 , C97) ) -> non  empty;
coherence
proof
per cases ;
suppose L247: C96 is  unital;

L248: ( .: (C96 , C97) ) = multLoopStr (# ( Funcs (C97 , (the carrier of C96)) ) , ( ((the multF of C96) , (the carrier of C96)) .: C97 ) , ( C97 --> ( the_unity_wrt (the multF of C96) ) ) #) by L247 , L245;
thus L249: (the carrier of ( .: (C96 , C97) )) is non  empty by L248;
end;
suppose L250: (not C96 is  unital);

L251: ( .: (C96 , C97) ) = multMagma (# ( Funcs (C97 , (the carrier of C96)) ) , ( ((the multF of C96) , (the carrier of C96)) .: C97 ) #) by L250 , L245;
thus L252: (the carrier of ( .: (C96 , C97) )) is non  empty by L251;
end;
end;
end;
deffunc H4(non  empty multMagma) = (the carrier of $1);
theorem
L255: (for R4 being set holds (for R20 being non  empty multMagma holds ((the carrier of ( .: (R20 , R4) )) = ( Funcs (R4 , (the carrier of R20)) ) & (the multF of ( .: (R20 , R4) )) = ( ((the multF of R20) , (the carrier of R20)) .: R4 ))))
proof
let R4 being set;
let R20 being non  empty multMagma;
L256: ((not R20 is  unital) implies ( .: (R20 , R4) ) = multMagma (# ( Funcs (R4 , H4(R20)) ) , ( (H1(R20) , H4(R20)) .: R4 ) #)) by L245;
L257: (R20 is  unital implies ( .: (R20 , R4) ) = multLoopStr (# ( Funcs (R4 , H4(R20)) ) , ( (H1(R20) , H4(R20)) .: R4 ) , ( R4 --> ( the_unity_wrt H1(R20) ) ) #)) by L245;
thus L258: thesis by L257 , L256;
end;
theorem
L259: (for R1 being set holds (for R4 being set holds (for R20 being non  empty multMagma holds (R1 is (Element of ( .: (R20 , R4) )) iff R1 is (Function of R4 , (the carrier of R20))))))
proof
let R1 being set;
let R4 being set;
let R20 being non  empty multMagma;
L260: (R1 is (Element of ( .: (R20 , R4) )) implies R1 is (Element of ( Funcs (R4 , H4(R20)) ))) by L255;
thus L261: (R1 is (Element of ( .: (R20 , R4) )) implies R1 is (Function of R4 , H4(R20))) by L260;
assume L262: R1 is (Function of R4 , H4(R20));
reconsider D37 = R1 as (Function of R4 , H4(R20)) by L262;
L263: ( rng D37 ) c= H4(R20);
L264: (H4(( .: (R20 , R4) )) = ( Funcs (R4 , H4(R20)) ) & ( dom D37 ) = R4) by L255 , FUNCT_2:def 1;
thus L265: thesis by L264 , L263 , FUNCT_2:def 2;
end;
L266: (for R4 being set holds (for R20 being non  empty multMagma holds ( .: (R20 , R4) ) is  constituted-Functions))
proof
let R4 being set;
let R20 being non  empty multMagma;
let C98 being (Element of ( .: (R20 , R4) ));
L267: C98 is (Element of ( Funcs (R4 , H4(R20)) )) by L255;
thus L268: thesis by L267;
end;
registration
let C99 being non  empty multMagma;
let C100 being set;
cluster ( .: (C99 , C100) ) ->  constituted-Functions;
coherence by L266;
end;
theorem
L270: (for R4 being set holds (for R20 being non  empty multMagma holds (for B29 being (Element of ( .: (R20 , R4) )) holds (( dom B29 ) = R4 & ( rng B29 ) c= (the carrier of R20)))))
proof
let R4 being set;
let R20 being non  empty multMagma;
let C101 being (Element of ( .: (R20 , R4) ));
reconsider D38 = C101 as (Element of ( Funcs (R4 , H4(R20)) )) by L255;
L271: D38 = D38;
thus L272: thesis by L271 , FUNCT_2:def 1 , RELAT_1:def 19;
end;
theorem
L273: (for R4 being set holds (for R20 being non  empty multMagma holds (for B30 , B31 being (Element of ( .: (R20 , R4) )) holds ((for R1 being set holds (R1 in R4 implies ( B30 . R1 ) = ( B31 . R1 ))) implies B30 = B31))))
proof
let R4 being set;
let R20 being non  empty multMagma;
let C102 , C103 being (Element of ( .: (R20 , R4) ));
L274: (( dom C102 ) = R4 & ( dom C103 ) = R4) by L270;
thus L275: thesis by L274 , FUNCT_1:2;
end;
definition
let C104 being non  empty multMagma;
let C105 being non  empty set;
let C106 being (Element of ( .: (C104 , C105) ));
let C107 being (Element of C105);
redefine func C106 . C107 -> (Element of C104);

coherence
proof
L276: ( dom C106 ) = C105 by L270;
L277: ( C106 . C107 ) in ( rng C106 ) by L276 , FUNCT_1:def 3;
L278: ( rng C106 ) c= H4(C104) by L270;
thus L279: thesis by L278 , L277;
end;
end;
registration
let C108 being non  empty multMagma;
let C109 being non  empty set;
let C110 being (Element of ( .: (C108 , C109) ));
cluster ( rng C110 ) -> non  empty;
coherence
proof
set D39 = the (Element of C109);
L281: ( dom C110 ) = C109 by L270;
L282: ( C110 . D39 ) in ( rng C110 ) by L281 , FUNCT_1:def 3;
thus L283: thesis by L282;
end;
end;
theorem
L285: (for R9 being non  empty set holds (for R20 being non  empty multMagma holds (for B32 , B33 being (Element of ( .: (R20 , R9) )) holds (for B34 being (Element of R9) holds ( ( B32 * B33 ) . B34 ) = ( ( B32 . B34 ) * ( B33 . B34 ) )))))
proof
let R9 being non  empty set;
let R20 being non  empty multMagma;
let C111 , C112 being (Element of ( .: (R20 , R9) ));
let C113 being (Element of R9);
reconsider D40 = C111 , D41 = C112 as (Element of ( Funcs (R9 , H4(R20)) )) by L255;
L286: H1(( .: (R20 , R9) )) = ( (H1(R20) , H4(R20)) .: R9 ) by L255;
L287: (( dom ( H1(R20) .: (D40 , D41) ) ) = R9 & ( C111 * C112 ) = ( H1(R20) .: (D40 , D41) )) by L286 , L60 , FUNCT_2:def 1;
thus L288: thesis by L287 , FUNCOP_1:22;
end;
definition
let C114 being  unital non  empty multMagma;
let C115 being set;
redefine func .: (C114 , C115) ->  well-unital  constituted-Functions  strict non  empty multLoopStr;

coherence
proof
set D42 = multLoopStr (# ( Funcs (C115 , H4(C114)) ) , ( (H1(C114) , H4(C114)) .: C115 ) , ( C115 --> ( the_unity_wrt H1(C114) ) ) #);
L289: H1(C114) is  having_a_unity by MONOID_0:def 10;
consider C116 being (Element of C114) such that L290: C116 is_a_unity_wrt H1(C114) by L289 , SETWISEO:def 2;
L291: (( 1. D42 ) = ( C115 --> ( the_unity_wrt (the multF of C114) ) ) & ( .: (C114 , C115) ) = D42) by L245;
L292: (C116 = ( the_unity_wrt H1(C114) ) & ( C115 --> C116 ) is_a_unity_wrt ( (H1(C114) , H4(C114)) .: C115 )) by L290 , L130 , BINOP_1:def 8;
thus L293: thesis by L292 , L291 , MONOID_0:def 21;
end;
end;
theorem
L295: (for R4 being set holds (for B35 being  unital non  empty multMagma holds ( 1. ( .: (B35 , R4) ) ) = ( R4 --> ( the_unity_wrt (the multF of B35) ) )))
proof
let R4 being set;
let C117 being  unital non  empty multMagma;
L296: ( .: (C117 , R4) ) = multLoopStr (# ( Funcs (R4 , H4(C117)) ) , ( (H1(C117) , H4(C117)) .: R4 ) , ( R4 --> ( the_unity_wrt H1(C117) ) ) #) by L245;
thus L297: thesis by L296;
end;
theorem
L298: (for B36 being non  empty multMagma holds (for B37 being set holds ((B36 is  commutative implies ( .: (B36 , B37) ) is  commutative) & (B36 is  associative implies ( .: (B36 , B37) ) is  associative) & (B36 is  idempotent implies ( .: (B36 , B37) ) is  idempotent) & (B36 is  invertible implies ( .: (B36 , B37) ) is  invertible) & (B36 is  cancelable implies ( .: (B36 , B37) ) is  cancelable) & (B36 is  uniquely-decomposable implies ( .: (B36 , B37) ) is  uniquely-decomposable))))
proof
let R20 being non  empty multMagma;
let C118 being set;
L299: (H1(( .: (R20 , C118) )) = ( (H1(R20) , H4(R20)) .: C118 ) & H4(( .: (R20 , C118) )) = ( Funcs (C118 , H4(R20)) )) by L255;
thus L300: (R20 is  commutative implies ( .: (R20 , C118) ) is  commutative)
proof
assume L301: H1(R20) is  commutative;
thus L302: H1(( .: (R20 , C118) )) is  commutative by L301 , L299 , L124;
end;

thus L303: (R20 is  associative implies ( .: (R20 , C118) ) is  associative)
proof
assume L304: H1(R20) is  associative;
thus L305: H1(( .: (R20 , C118) )) is  associative by L304 , L299 , L127;
end;

thus L306: (R20 is  idempotent implies ( .: (R20 , C118) ) is  idempotent)
proof
assume L307: H1(R20) is  idempotent;
thus L308: H1(( .: (R20 , C118) )) is  idempotent by L307 , L299 , L142;
end;

thus L309: (R20 is  invertible implies ( .: (R20 , C118) ) is  invertible)
proof
assume L310: H1(R20) is  invertible;
thus L311: H1(( .: (R20 , C118) )) is  invertible by L310 , L299 , L145;
end;

thus L312: (R20 is  cancelable implies ( .: (R20 , C118) ) is  cancelable)
proof
assume L313: H1(R20) is  cancelable;
thus L314: H1(( .: (R20 , C118) )) is  cancelable by L313 , L299 , L174;
end;

assume L315: H1(R20) is  uniquely-decomposable;
thus L316: H1(( .: (R20 , C118) )) is  uniquely-decomposable by L315 , L299 , L188;
end;
theorem
L317: (for R4 being set holds (for R20 being non  empty multMagma holds (for B38 being non  empty (SubStr of R20) holds ( .: (B38 , R4) ) is (SubStr of ( .: (R20 , R4) )))))
proof
let R4 being set;
let R20 being non  empty multMagma;
let C119 being non  empty (SubStr of R20);
L318: H1(( .: (C119 , R4) )) = ( (H1(C119) , H4(C119)) .: R4 ) by L255;
L319: (H1(C119) c= H1(R20) & H1(( .: (R20 , R4) )) = ( (H1(R20) , H4(R20)) .: R4 )) by L255 , MONOID_0:def 23;
thus L320: H1(( .: (C119 , R4) )) c= H1(( .: (R20 , R4) )) by L319 , L318 , L220;
end;
theorem
L321: (for R4 being set holds (for B39 being  unital non  empty multMagma holds (for B40 being non  empty (SubStr of B39) holds (( the_unity_wrt (the multF of B39) ) in (the carrier of B40) implies ( .: (B40 , R4) ) is (MonoidalSubStr of ( .: (B39 , R4) ))))))
proof
let R4 being set;
let C120 being  unital non  empty multMagma;
let C121 being non  empty (SubStr of C120);
assume L322: ( the_unity_wrt (the multF of C120) ) in H4(C121);
reconsider D43 = C120 , D44 = C121 as  unital non  empty multMagma by L322 , MONOID_0:30;
L323: ( the_unity_wrt H1(D44) ) = ( the_unity_wrt H1(D43) ) by L322 , MONOID_0:30;
L324: H1(( .: (C121 , R4) )) = ( (H1(C121) , H4(C121)) .: R4 ) by L255;
L325: (H1(C121) c= H1(C120) & H1(( .: (C120 , R4) )) = ( (H1(C120) , H4(C120)) .: R4 )) by L255 , MONOID_0:def 23;
L326: H1(( .: (C121 , R4) )) c= H1(( .: (C120 , R4) )) by L325 , L324 , L220;
L327: (( 1. ( .: (D43 , R4) ) ) = ( R4 --> ( the_unity_wrt H1(C120) ) ) & ( 1. ( .: (D44 , R4) ) ) = ( R4 --> ( the_unity_wrt H1(C121) ) )) by L295;
thus L328: thesis by L327 , L323 , L326 , MONOID_0:def 25;
end;
definition
let C122 being  unital  associative  commutative  cancelable  uniquely-decomposable non  empty multMagma;
let C123 being set;
redefine func .: (C122 , C123) ->  commutative  cancelable  uniquely-decomposable  constituted-Functions  strict Monoid;

coherence
proof
L329: ( .: (C122 , C123) ) is  commutative  cancelable by L298;
thus L330: thesis by L329 , L298;
end;
end;
begin
definition
let C124 being set;
func MultiSet_over C124 ->  commutative  cancelable  uniquely-decomposable  constituted-Functions  strict Monoid equals 
( .: (( <NAT,+,0> ) , C124) );
correctness;
end;
theorem
L333: (for R4 being set holds ((the carrier of ( MultiSet_over R4 )) = ( Funcs (R4 , ( NAT )) ) & (the multF of ( MultiSet_over R4 )) = ( (( addnat ) , ( NAT )) .: R4 ) & ( 1. ( MultiSet_over R4 ) ) = ( R4 --> ( 0 ) )))
proof
let R4 being set;
L334: (( the multMagma of ( <NAT,+,0> ) ) = ( <NAT,+> ) & ( the_unity_wrt H1(( <NAT,+> )) ) = ( 0 )) by MONOID_0:40 , MONOID_0:def 22;
thus L335: thesis by L334 , L255 , L295 , MONOID_0:46;
end;
definition
let C125 being set;
mode Multiset of C125
 is (Element of ( MultiSet_over C125 ));
end;
theorem
L337: (for R1 being set holds (for R4 being set holds (R1 is (Multiset of R4) iff R1 is (Function of R4 , ( NAT )))))
proof
let R1 being set;
let R4 being set;
L338:
now
let C126 being (Function of R4 , ( NAT ));
L339: (( dom C126 ) = R4 & ( rng C126 ) c= ( NAT )) by FUNCT_2:def 1;
thus L340: C126 is (Element of ( Funcs (R4 , ( NAT )) )) by L339 , FUNCT_2:def 2;
end;
L341: (R1 is (Multiset of R4) iff R1 is (Element of ( Funcs (R4 , ( NAT )) ))) by L333;
thus L342: thesis by L341 , L338;
end;
theorem
L343: (for R4 being set holds (for B41 being (Multiset of R4) holds (( dom B41 ) = R4 & ( rng B41 ) c= ( NAT ))))
proof
let R4 being set;
let C127 being (Multiset of R4);
L344: C127 is (Function of R4 , ( NAT )) by L337;
thus L345: thesis by L344 , FUNCT_2:def 1 , RELAT_1:def 19;
end;
definition
let C128 being non  empty set;
let C129 being (Multiset of C128);
redefine func rng C129 -> (Subset of ( NAT ));

coherence by L270 , MONOID_0:46;
let C130 being (Element of C128);
redefine func C129 . C130 -> (Element of ( NAT ));

coherence
proof
L346: ( dom C129 ) = C128 by L270;
L347: ( C129 . C130 ) in ( rng C129 ) by L346 , FUNCT_1:def 3;
L348: ( rng C129 ) c= ( NAT ) by L270 , MONOID_0:46;
thus L349: thesis by L348 , L347;
end;
end;
theorem
L351: (for R9 being non  empty set holds (for B42 , B43 being (Multiset of R9) holds (for B44 being (Element of R9) holds ( ( B42 [*] B43 ) . B44 ) = ( ( B42 . B44 ) + ( B43 . B44 ) ))))
proof
let R9 being non  empty set;
reconsider D45 = ( <NAT,+,0> ) as non  empty multMagma;
let C131 , C132 being (Multiset of R9);
let C133 being (Element of R9);
reconsider D46 = C131 , D47 = C132 as (Element of ( .: (D45 , R9) ));
thus L352: ( ( C131 [*] C132 ) . C133 ) = ( ( D46 . C133 ) * ( D47 . C133 ) ) by L285
.= ( ( C131 . C133 ) + ( C132 . C133 ) ) by MONOID_0:45;
end;
theorem
L353: (for R4 being set holds (for R5 being set holds ( chi (R5 , R4) ) is (Multiset of R4)))
proof
let R4 being set;
let R5 being set;
L354: ( rng ( chi (R5 , R4) ) ) c= { ( 0 ) , 1 };
L355: ( rng ( chi (R5 , R4) ) ) c= ( NAT ) by L354 , XBOOLE_1:1;
L356: (( dom ( chi (R5 , R4) ) ) = R4 & H4(( MultiSet_over R4 )) = ( Funcs (R4 , ( NAT )) )) by L333 , FUNCT_3:def 3;
thus L357: thesis by L356 , L355 , FUNCT_2:def 2;
end;
definition
let R5 being set;
let R4 being set;
redefine func chi (R5 , R4) -> (Multiset of R4);

coherence by L353;
end;
definition
let R4 being set;
let C134 being (Element of ( NAT ));
redefine func R4 --> C134 -> (Multiset of R4);

coherence
proof
thus L359: ( R4 --> C134 ) is (Multiset of R4) by L337;
end;
end;
definition
let C135 being non  empty set;
let C136 being (Element of C135);
func chi C136 -> (Multiset of C135) equals 
( chi ({ C136 } , C135) );
coherence;
end;
theorem
L362: (for B45 being non  empty set holds (for B46 , B47 being (Element of B45) holds (( ( chi B46 ) . B46 ) = 1 & (B47 <> B46 implies ( ( chi B46 ) . B47 ) = ( 0 )))))
proof
let C137 being non  empty set;
let C138 , C139 being (Element of C137);
L363: (C139 <> C138 implies (not C139 in { C138 })) by TARSKI:def 1;
L364: C138 in { C138 } by TARSKI:def 1;
thus L365: thesis by L364 , L363 , FUNCT_3:def 3;
end;
theorem
L366: (for R21 being non  empty set holds (for R24 being (Multiset of R21) holds (for R25 being (Multiset of R21) holds ((for R22 being (Element of R21) holds ( R24 . R22 ) = ( R25 . R22 )) implies R24 = R25))))
proof
let R21 being non  empty set;
let R24 being (Multiset of R21);
let R25 being (Multiset of R21);
assume L367: (for R22 being (Element of R21) holds ( R24 . R22 ) = ( R25 . R22 ));
L368: (for R1 being set holds (R1 in R21 implies ( R24 . R1 ) = ( R25 . R1 ))) by L367;
thus L369: thesis by L368 , L273;
end;
definition
let C140 being set;
func finite-MultiSet_over C140 ->  strict non  empty (MonoidalSubStr of ( MultiSet_over C140 )) means 
:L370: (for B48 being (Multiset of C140) holds (B48 in (the carrier of it) iff ( B48 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite));
existence
proof
reconsider D48 = ( C140 --> ( 0 ) ) as (Function of C140 , ( NAT )) by L337;
defpred S3[ set ] means (ex B49 being (Function of C140 , ( NAT )) st ($1 = B49 & ( B49 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite));
L371: (for B50 , B51 being (Multiset of C140) holds ((S3[ B50 ] & S3[ B51 ]) implies S3[ ( B50 [*] B51 ) ]))
proof
let C141 , C142 being (Multiset of C140);
reconsider D49 = ( C141 [*] C142 ) as (Function of C140 , ( NAT )) by L337;
given C143 being (Function of C140 , ( NAT )) such that
L372: C141 = C143
and
L373: ( C143 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite;

given C144 being (Function of C140 , ( NAT )) such that
L374: C142 = C144
and
L375: ( C144 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite;

take D49;
L376: (( dom C143 ) = C140 & ( dom C144 ) = C140) by FUNCT_2:def 1;
L377: ( D49 " ( ( NAT ) \ { ( 0 ) } ) ) c= ( ( C143 " ( ( NAT ) \ { ( 0 ) } ) ) \/ ( C144 " ( ( NAT ) \ { ( 0 ) } ) ) )
proof
let R1 being set;
assume L378: R1 in ( D49 " ( ( NAT ) \ { ( 0 ) } ) );
L379: ( D49 . R1 ) in ( ( NAT ) \ { ( 0 ) } ) by L378 , FUNCT_1:def 7;
L380: (not ( D49 . R1 ) in { ( 0 ) }) by L379 , XBOOLE_0:def 5;
L381: (( C143 . R1 ) in ( rng C143 ) & ( C144 . R1 ) in ( rng C144 )) by L376 , L378 , FUNCT_1:def 3;
reconsider D50 = ( C143 . R1 ) , D51 = ( C144 . R1 ) as (Element of ( NAT )) by L381;
L382: ( D49 . R1 ) = ( D50 + D51 ) by L372 , L374 , L378 , L351;
L383: (D50 <> ( 0 ) or D51 <> ( 0 )) by L382 , L380 , TARSKI:def 1;
L384: ((not D50 in { ( 0 ) }) or (not D51 in { ( 0 ) })) by L383 , TARSKI:def 1;
L385: (D50 in ( ( NAT ) \ { ( 0 ) } ) or D51 in ( ( NAT ) \ { ( 0 ) } )) by L384 , XBOOLE_0:def 5;
L386: (R1 in ( C143 " ( ( NAT ) \ { ( 0 ) } ) ) or R1 in ( C144 " ( ( NAT ) \ { ( 0 ) } ) )) by L385 , L376 , L378 , FUNCT_1:def 7;
thus L387: thesis by L386 , XBOOLE_0:def 3;
end;
thus L388: thesis by L377 , L373 , L375;
end;
L389: ( dom D48 ) = C140 by FUNCOP_1:13;
L390:
now
set D52 = the (Element of ( D48 " ( ( NAT ) \ { ( 0 ) } ) ));
assume L391: ( D48 " ( ( NAT ) \ { ( 0 ) } ) ) <> ( {} );
L392: ( D48 . D52 ) in ( ( NAT ) \ { ( 0 ) } ) by L391 , FUNCT_1:def 7;
L393: (not ( D48 . D52 ) in { ( 0 ) }) by L392 , XBOOLE_0:def 5;
L394: D52 in C140 by L389 , L391 , FUNCT_1:def 7;
L395: ( D48 . D52 ) = ( 0 ) by L394 , FUNCOP_1:7;
thus L396: contradiction by L395 , L393 , TARSKI:def 1;
end;
L397: S3[ ( 1. ( MultiSet_over C140 ) ) ] by L390 , L333;
consider C145 being  strict non  empty (MonoidalSubStr of ( MultiSet_over C140 )) such that L398: (for B52 being (Multiset of C140) holds (B52 in (the carrier of C145) iff S3[ B52 ])) from MONOID_0:sch 2(L371 , L397);
reconsider D53 = C145 as  strict non  empty (MonoidalSubStr of ( MultiSet_over C140 ));
take D53;
let C146 being (Multiset of C140);
thus L399: (C146 in H4(D53) implies ( C146 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite)
proof
assume L400: C146 in H4(D53);
L401: (ex B53 being (Function of C140 , ( NAT )) st (C146 = B53 & ( B53 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite)) by L400 , L398;
thus L402: thesis by L401;
end;

reconsider D54 = C146 as (Function of C140 , ( NAT )) by L337;
assume L403: ( C146 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite;
L404: ( D54 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite by L403;
thus L405: thesis by L404 , L398;
end;
uniqueness
proof
set D55 = ( MultiSet_over C140 );
let C147 , C148 being  strict non  empty (MonoidalSubStr of ( MultiSet_over C140 ));
assume that
L406: (for B54 being (Multiset of C140) holds (B54 in H4(C147) iff ( B54 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite))
and
L407: (for B55 being (Multiset of C140) holds (B55 in H4(C148) iff ( B55 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite));
L408: H4(C148) c= H4(D55) by MONOID_0:23;
L409: H4(C147) c= H4(D55) by MONOID_0:23;
L410: H4(C147) = H4(C148)
proof
thus L411: H4(C147) c= H4(C148)
proof
let R1 being set;
assume L412: R1 in H4(C147);
reconsider D56 = R1 as (Multiset of C140) by L412 , L409;
L413: ( D56 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite by L406 , L412;
thus L414: thesis by L413 , L407;
end;

let R1 being set;
assume L415: R1 in H4(C148);
reconsider D57 = R1 as (Multiset of C140) by L415 , L408;
L416: ( D57 " ( ( NAT ) \ { ( 0 ) } ) ) is  finite by L407 , L415;
thus L417: thesis by L416 , L406;
end;
thus L418: thesis by L410 , MONOID_0:27;
end;
end;
theorem
L420: (for R21 being non  empty set holds (for R22 being (Element of R21) holds ( chi R22 ) is (Element of ( finite-MultiSet_over R21 ))))
proof
let R21 being non  empty set;
let R22 being (Element of R21);
L421: ( ( chi R22 ) " ( ( NAT ) \ { ( 0 ) } ) ) c= { R22 }
proof
let R1 being set;
assume L422: R1 in ( ( chi R22 ) " ( ( NAT ) \ { ( 0 ) } ) );
L423: R1 in ( dom ( chi R22 ) ) by L422 , FUNCT_1:def 7;
reconsider D58 = R1 as (Element of R21) by L423 , L343;
L424: ( ( chi R22 ) . R1 ) in ( ( NAT ) \ { ( 0 ) } ) by L422 , FUNCT_1:def 7;
L425: (not ( ( chi R22 ) . D58 ) in { ( 0 ) }) by L424 , XBOOLE_0:def 5;
L426: ( ( chi R22 ) . D58 ) <> ( 0 ) by L425 , TARSKI:def 1;
L427: D58 = R22 by L426 , L362;
thus L428: thesis by L427 , TARSKI:def 1;
end;
thus L429: thesis by L421 , L370;
end;
theorem
L430: (for R1 being set holds (for R21 being non  empty set holds (for R23 being (FinSequence of R21) holds ( dom ( { R1 } |` ( R23 ^ <* R1 *> ) ) ) = ( ( dom ( { R1 } |` R23 ) ) \/ { ( ( len R23 ) + 1 ) } ))))
proof
let R1 being set;
let R21 being non  empty set;
let R23 being (FinSequence of R21);
thus L431: ( dom ( { R1 } |` ( R23 ^ <* R1 *> ) ) ) c= ( ( dom ( { R1 } |` R23 ) ) \/ { ( ( len R23 ) + 1 ) } )
proof
let C149 being set;
L432: ( len <* R1 *> ) = 1 by FINSEQ_1:40;
L433: ( Seg ( len R23 ) ) = ( dom R23 ) by FINSEQ_1:def 3;
assume L434: C149 in ( dom ( { R1 } |` ( R23 ^ <* R1 *> ) ) );
L435: C149 in ( dom ( R23 ^ <* R1 *> ) ) by L434 , FUNCT_1:54;
L436: C149 in ( Seg ( ( len R23 ) + ( len <* R1 *> ) ) ) by L435 , FINSEQ_1:def 7;
L437: C149 in ( ( Seg ( len R23 ) ) \/ { ( ( len R23 ) + 1 ) } ) by L436 , L432 , FINSEQ_1:9;
L438: (C149 in ( dom R23 ) or C149 in { ( ( len R23 ) + 1 ) }) by L437 , L433 , XBOOLE_0:def 3;
L439: ( ( R23 ^ <* R1 *> ) . C149 ) in { R1 } by L434 , FUNCT_1:54;
reconsider D59 = C149 as (Element of ( NAT )) by L435;
L440: (D59 in ( dom R23 ) implies ( ( R23 ^ <* R1 *> ) . D59 ) = ( R23 . D59 )) by FINSEQ_1:def 7;
L441: (D59 in ( dom R23 ) implies D59 in ( dom ( { R1 } |` R23 ) )) by L440 , L439 , FUNCT_1:54;
thus L442: thesis by L441 , L438 , XBOOLE_0:def 3;
end;

let C150 being set;
L443: ( len <* R1 *> ) = 1 by FINSEQ_1:40;
L444: ( dom ( R23 ^ <* R1 *> ) ) = ( Seg ( ( len R23 ) + 1 ) ) by L443 , FINSEQ_1:def 7;
assume L445: C150 in ( ( dom ( { R1 } |` R23 ) ) \/ { ( ( len R23 ) + 1 ) } );
L446: (C150 in ( dom ( { R1 } |` R23 ) ) or C150 in { ( ( len R23 ) + 1 ) }) by L445 , XBOOLE_0:def 3;
L447: ((C150 in ( dom R23 ) & ( R23 . C150 ) in { R1 }) or (C150 in { ( ( len R23 ) + 1 ) } & C150 = ( ( len R23 ) + 1 ) & R1 in { R1 })) by L446 , FUNCT_1:54 , TARSKI:def 1;
L448: (( Seg ( len R23 ) ) = ( dom R23 ) & ( Seg ( ( len R23 ) + 1 ) ) = ( ( Seg ( len R23 ) ) \/ { ( ( len R23 ) + 1 ) } )) by FINSEQ_1:9 , FINSEQ_1:def 3;
L449: (( ( R23 ^ <* R1 *> ) . ( ( len R23 ) + 1 ) ) = R1 & C150 in ( dom ( R23 ^ <* R1 *> ) )) by L448 , L447 , L444 , FINSEQ_1:42 , XBOOLE_0:def 3;
reconsider D60 = C150 as (Element of ( NAT )) by L445;
L450: (D60 in ( dom R23 ) implies ( ( R23 ^ <* R1 *> ) . D60 ) = ( R23 . D60 )) by FINSEQ_1:def 7;
thus L451: thesis by L450 , L447 , L449 , FUNCT_1:54;
end;
theorem
L452: (for R1 being set holds (for R2 being set holds (for R21 being non  empty set holds (for R23 being (FinSequence of R21) holds (R1 <> R2 implies ( dom ( { R1 } |` ( R23 ^ <* R2 *> ) ) ) = ( dom ( { R1 } |` R23 ) ))))))
proof
let R1 being set;
let R2 being set;
let R21 being non  empty set;
let R23 being (FinSequence of R21);
assume L453: R1 <> R2;
thus L454: ( dom ( { R1 } |` ( R23 ^ <* R2 *> ) ) ) c= ( dom ( { R1 } |` R23 ) )
proof
let C151 being set;
L455: ( len <* R2 *> ) = 1 by FINSEQ_1:40;
L456: ( Seg ( len R23 ) ) = ( dom R23 ) by FINSEQ_1:def 3;
assume L457: C151 in ( dom ( { R1 } |` ( R23 ^ <* R2 *> ) ) );
L458: C151 in ( dom ( R23 ^ <* R2 *> ) ) by L457 , FUNCT_1:54;
L459: C151 in ( Seg ( ( len R23 ) + ( len <* R2 *> ) ) ) by L458 , FINSEQ_1:def 7;
L460: C151 in ( ( Seg ( len R23 ) ) \/ { ( ( len R23 ) + 1 ) } ) by L459 , L455 , FINSEQ_1:9;
L461: (C151 in ( dom R23 ) or C151 in { ( ( len R23 ) + 1 ) }) by L460 , L456 , XBOOLE_0:def 3;
L462: ( ( R23 ^ <* R2 *> ) . C151 ) in { R1 } by L457 , FUNCT_1:54;
reconsider D61 = C151 as (Element of ( NAT )) by L458;
L463: (( ( R23 ^ <* R2 *> ) . ( ( len R23 ) + 1 ) ) = R2 & (not R2 in { R1 })) by L453 , FINSEQ_1:42 , TARSKI:def 1;
L464: ( ( R23 ^ <* R2 *> ) . D61 ) = ( R23 . D61 ) by L463 , L462 , L461 , FINSEQ_1:def 7 , TARSKI:def 1;
thus L465: thesis by L464 , L462 , L461 , L463 , FUNCT_1:54 , TARSKI:def 1;
end;

let C152 being set;
assume L466: C152 in ( dom ( { R1 } |` R23 ) );
L467: C152 in ( dom R23 ) by L466 , FUNCT_1:54;
L468: ( len <* R2 *> ) = 1 by FINSEQ_1:40;
L469: ( dom ( R23 ^ <* R2 *> ) ) = ( Seg ( ( len R23 ) + 1 ) ) by L468 , FINSEQ_1:def 7;
L470: (( Seg ( len R23 ) ) = ( dom R23 ) & ( Seg ( ( len R23 ) + 1 ) ) = ( ( Seg ( len R23 ) ) \/ { ( ( len R23 ) + 1 ) } )) by FINSEQ_1:9 , FINSEQ_1:def 3;
L471: C152 in ( dom ( R23 ^ <* R2 *> ) ) by L470 , L467 , L469 , XBOOLE_0:def 3;
L472: ( R23 . C152 ) in { R1 } by L466 , FUNCT_1:54;
reconsider D62 = C152 as (Element of ( NAT )) by L466;
L473: ( ( R23 ^ <* R2 *> ) . D62 ) = ( R23 . D62 ) by L467 , FINSEQ_1:def 7;
thus L474: thesis by L473 , L472 , L471 , FUNCT_1:54;
end;
definition
let C153 being non  empty set;
let C154 being (FinSequence of C153);
func |.C154 .| -> (Multiset of C153) means 
:L475: (for B56 being (Element of C153) holds ( it . B56 ) = ( card ( dom ( { B56 } |` C154 ) ) ));
existence
proof
deffunc H5((Element of C153)) = ( card ( dom ( { $1 } |` C154 ) ) );
consider C155 being (Function of C153 , ( NAT )) such that L476: (for B57 being (Element of C153) holds ( C155 . B57 ) = H5(B57)) from FUNCT_2:sch 4;
L477: C155 is (Multiset of C153) by L337;
thus L478: thesis by L477 , L476;
end;
uniqueness
proof
let C156 , C157 being (Multiset of C153);
assume that
L479: (for B58 being (Element of C153) holds ( C156 . B58 ) = ( card ( dom ( { B58 } |` C154 ) ) ))
and
L480: (for B59 being (Element of C153) holds ( C157 . B59 ) = ( card ( dom ( { B59 } |` C154 ) ) ));
L481:
now
let C158 being (Element of C153);
thus L482: ( C156 . C158 ) = ( card ( dom ( { C158 } |` C154 ) ) ) by L479
.= ( C157 . C158 ) by L480;
end;
thus L483: thesis by L481 , L366;
end;
end;
theorem
L485: (for R21 being non  empty set holds (for R22 being (Element of R21) holds ( |. ( <*> R21 ) .| . R22 ) = ( 0 )))
proof
let R21 being non  empty set;
let R22 being (Element of R21);
L486: ( dom ( { R22 } |` ( {} ) ) ) c= ( dom ( {} ) ) by FUNCT_1:56;
L487: ( dom ( { R22 } |` ( <*> R21 ) ) ) = ( {} ) by L486;
thus L488: thesis by L487 , L475 , CARD_1:27;
end;
theorem
L489: (for R21 being non  empty set holds |. ( <*> R21 ) .| = ( R21 --> ( 0 ) ))
proof
let R21 being non  empty set;
L490:
now
let R1 being set;
assume L491: R1 in R21;
reconsider D63 = R1 as (Element of R21) by L491;
thus L492: ( |. ( <*> R21 ) .| . R1 ) = ( card ( dom ( { D63 } |` ( {} ) ) ) ) by L475
.= ( 0 ) by CARD_1:27 , RELAT_1:38 , RELAT_1:107;
end;
L493: ( dom |. ( <*> R21 ) .| ) = R21 by L343;
thus L494: thesis by L493 , L490 , FUNCOP_1:11;
end;
theorem
L495: (for R21 being non  empty set holds (for R22 being (Element of R21) holds |. <* R22 *> .| = ( chi R22 )))
proof
let R21 being non  empty set;
let R22 being (Element of R21);
L496: ( rng <* R22 *> ) = { R22 } by FINSEQ_1:39;
L497:
now
let C159 being (Element of R21);
set D64 = C159;
L498: (( dom <* R22 *> ) = ( Seg 1 ) & ( card ( Seg 1 ) ) = 1) by FINSEQ_1:38 , FINSEQ_1:57;
L499: (R22 <> D64 implies { D64 } misses { R22 }) by ZFMISC_1:11;
L500: (R22 <> D64 implies ( { D64 } /\ { R22 } ) = ( {} )) by L499 , XBOOLE_0:def 7;
L501: (( ( chi R22 ) . R22 ) = 1 & ( { R22 } |` <* R22 *> ) = <* R22 *>) by L496 , L362 , RELAT_1:94;
L502: <* R22 *> = ( ( rng <* R22 *> ) |` <* R22 *> );
L503: ( { D64 } |` <* R22 *> ) = ( ( { D64 } /\ ( rng <* R22 *> ) ) |` <* R22 *> ) by L502 , RELAT_1:96;
L504: (D64 <> R22 implies (( { D64 } |` <* R22 *> ) = ( {} ) & ( ( chi R22 ) . C159 ) = ( 0 ))) by L503 , L496 , L500 , L362;
thus L505: ( |. <* R22 *> .| . D64 ) = ( ( chi R22 ) . D64 ) by L504 , L498 , L501 , L475 , CARD_1:27 , RELAT_1:38;
end;
thus L506: thesis by L497 , L366;
end;
theorem
L507: (for R21 being non  empty set holds (for R22 being (Element of R21) holds (for R26 being (FinSequence of R21) holds |. ( R26 ^ <* R22 *> ) .| = ( |. R26 .| [*] ( chi R22 ) ))))
proof
let R21 being non  empty set;
let R22 being (Element of R21);
let R26 being (FinSequence of R21);
L508:
now
reconsider D65 = ( R26 ^ <* R22 *> ) as (FinSequence of R21);
let C160 being (Element of R21);
L509: (( len R26 ) < ( ( len R26 ) + 1 ) & ( dom ( { C160 } |` R26 ) ) c= ( dom R26 )) by FUNCT_1:56 , NAT_1:13;
L510: (not ( ( len R26 ) + 1 ) in ( dom ( { C160 } |` R26 ) )) by L509 , FINSEQ_3:25;
L511: (( |. ( R26 ^ <* R22 *> ) .| . C160 ) = ( card ( dom ( { C160 } |` D65 ) ) ) & ( |. R26 .| . C160 ) = ( card ( dom ( { C160 } |` R26 ) ) )) by L475;
L512: (R22 <> C160 implies (( dom ( { C160 } |` ( R26 ^ <* R22 *> ) ) ) = ( dom ( { C160 } |` R26 ) ) & ( ( chi R22 ) . C160 ) = ( 0 ))) by L362 , L452;
L513: ( ( |. R26 .| [*] ( chi R22 ) ) . C160 ) = ( ( |. R26 .| . C160 ) + ( ( chi R22 ) . C160 ) ) by L351;
L514: (( dom ( { R22 } |` ( R26 ^ <* R22 *> ) ) ) = ( ( dom ( { R22 } |` R26 ) ) \/ { ( ( len R26 ) + 1 ) } ) & ( ( chi R22 ) . R22 ) = 1) by L362 , L430;
thus L515: ( |. ( R26 ^ <* R22 *> ) .| . C160 ) = ( ( |. R26 .| [*] ( chi R22 ) ) . C160 ) by L514 , L510 , L511 , L512 , L513 , CARD_2:41;
end;
thus L516: thesis by L508 , L366;
end;
theorem
L517: (for R21 being non  empty set holds (for R26 being (FinSequence of R21) holds (for R27 being (FinSequence of R21) holds |. ( R26 ^ R27 ) .| = ( |. R26 .| [*] |. R27 .| ))))
proof
let R21 being non  empty set;
let R26 being (FinSequence of R21);
let R27 being (FinSequence of R21);
defpred S4[ (Element of ( NAT )) ] means (for R27 being (FinSequence of R21) holds (( len R27 ) = $1 implies |. ( R26 ^ R27 ) .| = ( |. R26 .| [*] |. R27 .| )));
L518: ( len R27 ) = ( len R27 );
L519: (for R7 being (Element of ( NAT )) holds (S4[ R7 ] implies S4[ ( R7 + 1 ) ]))
proof
let R7 being (Element of ( NAT ));
assume that
L520: (for R27 being (FinSequence of R21) holds (( len R27 ) = R7 implies |. ( R26 ^ R27 ) .| = ( |. R26 .| [*] |. R27 .| )));
let R27 being (FinSequence of R21);
assume L521: ( len R27 ) = ( R7 + 1 );
L522: R27 <> ( {} ) by L521;
consider C161 being FinSequence, C162 being set such that L523: R27 = ( C161 ^ <* C162 *> ) by L522 , FINSEQ_1:46;
L524: ( rng <* C162 *> ) = { C162 } by FINSEQ_1:39;
L525: { C162 } c= ( rng R27 ) by L524 , L523 , FINSEQ_1:30;
L526: { C162 } c= R21 by L525 , XBOOLE_1:1;
reconsider D66 = C161 as (FinSequence of R21) by L523 , FINSEQ_1:36;
L527: ( len <* C162 *> ) = 1 by FINSEQ_1:40;
L528: ( R7 + 1 ) = ( ( len D66 ) + 1 ) by L527 , L521 , L523 , FINSEQ_1:22;
reconsider D67 = C162 as (Element of R21) by L526 , ZFMISC_1:31;
thus L529: |. ( R26 ^ R27 ) .| = |. ( ( R26 ^ D66 ) ^ <* D67 *> ) .| by L523 , FINSEQ_1:32
.= ( |. ( R26 ^ D66 ) .| [*] ( chi D67 ) ) by L507
.= ( ( |. R26 .| [*] |. D66 .| ) [*] ( chi D67 ) ) by L520 , L528
.= ( |. R26 .| [*] ( |. D66 .| [*] ( chi D67 ) ) ) by GROUP_1:def 3
.= ( |. R26 .| [*] |. R27 .| ) by L523 , L507;
end;
L530: S4[ ( 0 ) ]
proof
let R27 being (FinSequence of R21);
L531: (|. ( <*> R21 ) .| = ( R21 --> ( 0 ) ) & ( R21 --> ( 0 ) ) = H2(( MultiSet_over R21 ))) by L333 , L489;
assume L532: ( len R27 ) = ( 0 );
L533: R27 = ( {} ) by L532;
L534: ( R26 ^ R27 ) = R26 by L533 , FINSEQ_1:34;
thus L535: thesis by L534 , L533 , L531 , MONOID_0:16;
end;
L536: (for R7 being (Element of ( NAT )) holds S4[ R7 ]) from NAT_1:sch 1(L530 , L519);
thus L537: thesis by L536 , L518;
end;
theorem
L538: (for R7 being (Element of ( NAT )) holds (for R21 being non  empty set holds (for R22 being (Element of R21) holds (( |. ( R7 .--> R22 ) .| . R22 ) = R7 & (for B60 being (Element of R21) holds (B60 <> R22 implies ( |. ( R7 .--> R22 ) .| . B60 ) = ( 0 )))))))
proof
let R7 being (Element of ( NAT ));
let R21 being non  empty set;
let R22 being (Element of R21);
defpred S5[ (Element of ( NAT )) ] means ( |. ( $1 .--> R22 ) .| . R22 ) = $1;
L539: (( ( 0 ) .--> R22 ) = ( {} ) & ( {} ) = ( <*> R21 )) by FINSEQ_2:58;
L540: (for R7 being (Element of ( NAT )) holds (S5[ R7 ] implies S5[ ( R7 + 1 ) ]))
proof
let R7 being (Element of ( NAT ));
assume that
L541: ( |. ( R7 .--> R22 ) .| . R22 ) = R7;
thus L542: ( |. ( ( R7 + 1 ) .--> R22 ) .| . R22 ) = ( |. ( ( R7 .--> R22 ) ^ <* R22 *> ) .| . R22 ) by FINSEQ_2:60
.= ( ( |. ( R7 .--> R22 ) .| [*] ( chi R22 ) ) . R22 ) by L507
.= ( R7 + ( ( chi R22 ) . R22 ) ) by L541 , L351
.= ( R7 + 1 ) by L362;
end;
L543: ( ( R21 --> ( 0 ) ) . R22 ) = ( 0 ) by FUNCOP_1:7;
L544: S5[ ( 0 ) ] by L543 , L539 , L489;
L545: (for R7 being (Element of ( NAT )) holds S5[ R7 ]) from NAT_1:sch 1(L544 , L540);
thus L546: ( |. ( R7 .--> R22 ) .| . R22 ) = R7 by L545;
let C163 being (Element of R21);
assume that
L547: C163 <> R22;
defpred S6[ (Element of ( NAT )) ] means ( |. ( $1 .--> R22 ) .| . C163 ) = ( 0 );
L548: (for R7 being (Element of ( NAT )) holds (S6[ R7 ] implies S6[ ( R7 + 1 ) ]))
proof
let R7 being (Element of ( NAT ));
assume that
L549: ( |. ( R7 .--> R22 ) .| . C163 ) = ( 0 );
thus L550: ( |. ( ( R7 + 1 ) .--> R22 ) .| . C163 ) = ( |. ( ( R7 .--> R22 ) ^ <* R22 *> ) .| . C163 ) by FINSEQ_2:60
.= ( ( |. ( R7 .--> R22 ) .| [*] ( chi R22 ) ) . C163 ) by L507
.= ( ( 0 ) + ( ( chi R22 ) . C163 ) ) by L549 , L351
.= ( 0 ) by L547 , L362;
end;
L551: ( ( R21 --> ( 0 ) ) . C163 ) = ( 0 ) by FUNCOP_1:7;
L552: S6[ ( 0 ) ] by L551 , L539 , L489;
L553: (for R7 being (Element of ( NAT )) holds S6[ R7 ]) from NAT_1:sch 1(L552 , L548);
thus L554: thesis by L553;
end;
theorem
L555: (for R21 being non  empty set holds (for R26 being (FinSequence of R21) holds |. R26 .| is (Element of ( finite-MultiSet_over R21 ))))
proof
let R21 being non  empty set;
let R26 being (FinSequence of R21);
defpred S7[ (FinSequence of R21) ] means |. $1 .| is (Element of ( finite-MultiSet_over R21 ));
defpred S8[ (Element of ( NAT )) ] means (for R26 being (FinSequence of R21) holds (( len R26 ) = $1 implies S7[ R26 ]));
L556: ( len R26 ) = ( len R26 );
L557: (for R7 being (Element of ( NAT )) holds (S8[ R7 ] implies S8[ ( R7 + 1 ) ]))
proof
set D68 = ( finite-MultiSet_over R21 );
let R7 being (Element of ( NAT ));
assume that
L558: (for R26 being (FinSequence of R21) holds (( len R26 ) = R7 implies S7[ R26 ]));
let R26 being (FinSequence of R21);
assume L559: ( len R26 ) = ( R7 + 1 );
L560: R26 <> ( {} ) by L559;
consider C164 being FinSequence, C165 being set such that L561: R26 = ( C164 ^ <* C165 *> ) by L560 , FINSEQ_1:46;
L562: ( rng <* C165 *> ) = { C165 } by FINSEQ_1:39;
L563: { C165 } c= ( rng R26 ) by L562 , L561 , FINSEQ_1:30;
L564: { C165 } c= R21 by L563 , XBOOLE_1:1;
reconsider D69 = C164 as (FinSequence of R21) by L561 , FINSEQ_1:36;
L565: ( len <* C165 *> ) = 1 by FINSEQ_1:40;
reconsider D70 = C165 as (Element of R21) by L564 , ZFMISC_1:31;
L566: ( R7 + 1 ) = ( ( len D69 ) + 1 ) by L559 , L561 , L565 , FINSEQ_1:22;
reconsider D71 = |. D69 .| , D72 = ( chi D70 ) as (Element of D68) by L566 , L558 , L420;
L567: D68 is (SubStr of ( MultiSet_over R21 )) by MONOID_0:21;
L568: ( D71 [*] D72 ) = ( |. D69 .| [*] ( chi D70 ) ) by L567 , MONOID_0:25
.= |. R26 .| by L561 , L507;
thus L569: thesis by L568;
end;
L570: S8[ ( 0 ) ]
proof
let R26 being (FinSequence of R21);
assume L571: ( len R26 ) = ( 0 );
L572: R26 = ( <*> R21 ) by L571;
L573: |. R26 .| = ( R21 --> ( 0 ) ) by L572 , L489
.= H2(( MultiSet_over R21 )) by L333
.= H2(( finite-MultiSet_over R21 )) by MONOID_0:def 24;
thus L574: thesis by L573;
end;
L575: (for R7 being (Element of ( NAT )) holds S8[ R7 ]) from NAT_1:sch 1(L570 , L557);
thus L576: thesis by L575 , L556;
end;
theorem
L577: (for R1 being set holds (for R21 being non  empty set holds (R1 is (Element of ( finite-MultiSet_over R21 )) implies (ex R26 being (FinSequence of R21) st R1 = |. R26 .|))))
proof
let R1 being set;
let R21 being non  empty set;
defpred S9[ (Element of ( NAT )) ] means (for R28 being (Element of ( finite-MultiSet_over R21 )) holds ((for B61 being  finite set holds (B61 = ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) implies ( card B61 ) = $1)) implies (ex R26 being (FinSequence of R21) st R28 = |. R26 .|)));
assume L578: R1 is (Element of ( finite-MultiSet_over R21 ));
reconsider D73 = R1 as (Element of ( finite-MultiSet_over R21 )) by L578;
L579: H4(( finite-MultiSet_over R21 )) c= H4(( MultiSet_over R21 )) by MONOID_0:23;
L580: D73 is (Multiset of R21) by L579 , TARSKI:def 3;
reconsider D74 = ( D73 " ( ( NAT ) \ { ( 0 ) } ) ) as  finite set by L580 , L370;
L581: (for B62 being  finite set holds (B62 = ( D73 " ( ( NAT ) \ { ( 0 ) } ) ) implies ( card B62 ) = ( card D74 )));
L582: (for R7 being (Element of ( NAT )) holds (S9[ R7 ] implies S9[ ( R7 + 1 ) ]))
proof
deffunc H6(set) = ( 0 );
let R7 being (Element of ( NAT ));
assume that
L583: (for R28 being (Element of ( finite-MultiSet_over R21 )) holds ((for B63 being  finite set holds (B63 = ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) implies ( card B63 ) = R7)) implies (ex R26 being (FinSequence of R21) st R28 = |. R26 .|)));
let R28 being (Element of ( finite-MultiSet_over R21 ));
assume that
L584: (for B64 being  finite set holds (B64 = ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) implies ( card B64 ) = ( R7 + 1 )));
deffunc H7(set) = ( R28 . $1 );
set D75 = the (Element of ( R28 " ( ( NAT ) \ { ( 0 ) } ) ));
L585: H4(( finite-MultiSet_over R21 )) c= H4(( MultiSet_over R21 )) by MONOID_0:23;
reconsider D76 = R28 as (Multiset of R21) by L585 , TARSKI:def 3;
reconsider D77 = ( D76 " ( ( NAT ) \ { ( 0 ) } ) ) as  finite set by L370;
L586: ( card D77 ) = ( R7 + 1 ) by L584;
L587: ( dom D76 ) = R21 by L343;
reconsider D78 = D75 as (Element of R21) by L587 , L586 , CARD_1:27 , FUNCT_1:def 7;
defpred S10[ set ] means D78 = $1;
consider C166 being Function such that L588: (( dom C166 ) = R21 & (for B65 being set holds (B65 in R21 implies ((S10[ B65 ] implies ( C166 . B65 ) = H6(B65)) & ((not S10[ B65 ]) implies ( C166 . B65 ) = H7(B65)))))) from PARTFUN1:sch 1;
L589: ( rng C166 ) c= ( NAT )
proof
let R2 being set;
assume L590: R2 in ( rng C166 );
consider C167 being set such that L591: C167 in ( dom C166 ) and L592: R2 = ( C166 . C167 ) by L590 , FUNCT_1:def 3;
reconsider D79 = C167 as (Element of R21) by L588 , L591;
L593: (R2 = ( 0 ) or R2 = ( D76 . D79 )) by L588 , L592;
thus L594: thesis by L593;
end;
reconsider D80 = C166 as (Function of R21 , ( NAT )) by L589 , L588 , FUNCT_2:def 1 , RELSET_1:4;
reconsider D81 = D80 as (Multiset of R21) by L337;
L595: ( D81 " ( ( NAT ) \ { ( 0 ) } ) ) = ( ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) \ { D78 } )
proof
thus L596: ( D81 " ( ( NAT ) \ { ( 0 ) } ) ) c= ( ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) \ { D78 } )
proof
let R2 being set;
assume L597: R2 in ( D81 " ( ( NAT ) \ { ( 0 ) } ) );
reconsider D82 = R2 as (Element of R21) by L597 , L588 , FUNCT_1:def 7;
L598: ( D81 . R2 ) in ( ( NAT ) \ { ( 0 ) } ) by L597 , FUNCT_1:def 7;
L599: (not ( D81 . D82 ) in { ( 0 ) }) by L598 , XBOOLE_0:def 5;
L600: ( D81 . D82 ) <> ( 0 ) by L599 , TARSKI:def 1;
L601: D82 <> D78 by L600 , L588;
L602: (not D82 in { D78 }) by L601 , TARSKI:def 1;
L603: ( D81 . D82 ) = ( R28 . D82 ) by L588 , L600;
L604: D82 in ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) by L603 , L587 , L598 , FUNCT_1:def 7;
thus L605: thesis by L604 , L602 , XBOOLE_0:def 5;
end;

let R2 being set;
assume L606: R2 in ( ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) \ { D78 } );
L607: R2 in ( dom R28 ) by L606 , FUNCT_1:def 7;
L608: ( R28 . R2 ) in ( ( NAT ) \ { ( 0 ) } ) by L606 , FUNCT_1:def 7;
L609: (not R2 in { D78 }) by L606 , XBOOLE_0:def 5;
L610: R2 <> D78 by L609 , TARSKI:def 1;
L611: ( R28 . R2 ) = ( D81 . R2 ) by L610 , L587 , L588 , L607;
thus L612: thesis by L611 , L587 , L588 , L607 , L608 , FUNCT_1:def 7;
end;
reconsider D83 = D81 as (Element of ( finite-MultiSet_over R21 )) by L595 , L586 , L370;
set D84 = |. ( ( D76 . D78 ) .--> D78 ) .|;
L613: ( card { D78 } ) = 1 by CARD_1:30;
reconsider D85 = ( D83 " ( ( NAT ) \ { ( 0 ) } ) ) as  finite set by L370;
L614: { D78 } c= ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) by L586 , CARD_1:27 , ZFMISC_1:31;
L615: ( card D85 ) = ( ( R7 + 1 ) - 1 ) by L614 , L586 , L595 , L613 , CARD_2:44
.= R7;
L616: (for B66 being  finite set holds (B66 = ( D83 " ( ( NAT ) \ { ( 0 ) } ) ) implies ( card B66 ) = R7)) by L615;
consider R26 being (FinSequence of R21) such that L617: D81 = |. R26 .| by L616 , L583;
take D86 = ( R26 ^ ( ( D76 . D78 ) .--> D78 ) );
L618:
now
let R22 being (Element of R21);
L619: ( ( 0 ) + ( D76 . R22 ) ) = ( D76 . R22 );
L620: (R22 <> D78 implies (( D81 . R22 ) = ( D76 . R22 ) & ( D84 . R22 ) = ( 0 ))) by L588 , L538;
L621: (( D81 . D78 ) = ( 0 ) & ( D84 . D78 ) = ( D76 . D78 )) by L588 , L538;
thus L622: ( ( D81 [*] D84 ) . R22 ) = ( D76 . R22 ) by L621 , L619 , L620 , L351;
end;
thus L623: R28 = ( D81 [*] D84 ) by L618 , L366
.= |. D86 .| by L617 , L517;
end;
L624: S9[ ( 0 ) ]
proof
set D87 = the (Element of R21);
let R28 being (Element of ( finite-MultiSet_over R21 ));
assume that
L625: (for B67 being  finite set holds (B67 = ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) implies ( card B67 ) = ( 0 )));
L626: H4(( finite-MultiSet_over R21 )) c= H4(( MultiSet_over R21 )) by MONOID_0:23;
reconsider D88 = R28 as (Multiset of R21) by L626 , TARSKI:def 3;
reconsider D89 = ( D88 " ( ( NAT ) \ { ( 0 ) } ) ) as  finite set by L370;
L627: ( card D89 ) = ( 0 ) by L625;
L628: ( R28 " ( ( NAT ) \ { ( 0 ) } ) ) = ( {} ) by L627;
L629: ( rng R28 ) misses ( ( NAT ) \ { ( 0 ) } ) by L628 , RELAT_1:138;
L630: ( {} ) = ( ( rng R28 ) /\ ( ( NAT ) \ { ( 0 ) } ) ) by L629 , XBOOLE_0:def 7
.= ( ( ( rng R28 ) /\ ( NAT ) ) \ { ( 0 ) } ) by XBOOLE_1:49;
take D90 = ( <*> R21 );
L631: ( rng D88 ) c= ( NAT );
L632: ( ( rng R28 ) /\ ( NAT ) ) = ( rng R28 ) by L631 , XBOOLE_1:28;
L633: ( rng R28 ) c= { ( 0 ) } by L632 , L630 , XBOOLE_1:37;
L634: ( dom D88 ) = R21 by L343;
L635: ( R28 . D87 ) in ( rng R28 ) by L634 , FUNCT_1:def 3;
L636: ( R28 . D87 ) = ( 0 ) by L635 , L633 , TARSKI:def 1;
L637: { ( 0 ) } c= ( rng R28 ) by L636 , L635 , ZFMISC_1:31;
L638: ( rng R28 ) = { ( 0 ) } by L637 , L633 , XBOOLE_0:def 10;
thus L639: R28 = ( R21 --> ( 0 ) ) by L638 , L634 , FUNCOP_1:9
.= |. D90 .| by L489;
end;
L640: (for R7 being (Element of ( NAT )) holds S9[ R7 ]) from NAT_1:sch 1(L624 , L582);
thus L641: thesis by L640 , L581;
end;
begin
definition
let C168 , C169 , C170 being non  empty set;
let C171 being (Function of [: C168 , C169 :] , C170);
func C171 .:^2 -> (Function of [: ( bool C168 ) , ( bool C169 ) :] , ( bool C170 )) means 
:L642: (for B68 being (Element of [: ( bool C168 ) , ( bool C169 ) :]) holds ( it . B68 ) = ( C171 .: [: ( B68 `1 ) , ( B68 `2 ) :] ));
existence
proof
deffunc H8((Element of [: ( bool C168 ) , ( bool C169 ) :])) = ( C171 .: [: ( $1 `1 ) , ( $1 `2 ) :] );
L643: (ex B69 being (Function of [: ( bool C168 ) , ( bool C169 ) :] , ( bool C170 )) st (for B70 being (Element of [: ( bool C168 ) , ( bool C169 ) :]) holds ( B69 . B70 ) = H8(B70))) from FUNCT_2:sch 4;
thus L644: thesis by L643;
end;
uniqueness
proof
let C172 , C173 being (Function of [: ( bool C168 ) , ( bool C169 ) :] , ( bool C170 ));
assume that
L645: (for B71 being (Element of [: ( bool C168 ) , ( bool C169 ) :]) holds ( C172 . B71 ) = ( C171 .: [: ( B71 `1 ) , ( B71 `2 ) :] ))
and
L646: (for B72 being (Element of [: ( bool C168 ) , ( bool C169 ) :]) holds ( C173 . B72 ) = ( C171 .: [: ( B72 `1 ) , ( B72 `2 ) :] ));
L647:
now
let C174 being (Element of [: ( bool C168 ) , ( bool C169 ) :]);
thus L648: ( C172 . C174 ) = ( C171 .: [: ( C174 `1 ) , ( C174 `2 ) :] ) by L645
.= ( C173 . C174 ) by L646;
end;
thus L649: thesis by L647 , FUNCT_2:63;
end;
end;
theorem
L651: (for B73 , B74 , B75 being non  empty set holds (for B76 being (Function of [: B73 , B74 :] , B75) holds (for B77 being (Subset of B73) holds (for B78 being (Subset of B74) holds ( ( B76 .:^2 ) . (B77 , B78) ) = ( B76 .: [: B77 , B78 :] )))))
proof
let C175 , C176 , C177 being non  empty set;
let C178 being (Function of [: C175 , C176 :] , C177);
let C179 being (Subset of C175);
let C180 being (Subset of C176);
L652: (( [ C179 , C180 ] `1 ) = C179 & ( [ C179 , C180 ] `2 ) = C180) by MCART_1:7;
thus L653: thesis by L652 , L642;
end;
theorem
L654: (for B79 , B80 , B81 being non  empty set holds (for B82 being (Function of [: B79 , B80 :] , B81) holds (for B83 being (Subset of B79) holds (for B84 being (Subset of B80) holds (for B85 , B86 being set holds ((B85 in B83 & B86 in B84) implies ( B82 . (B85 , B86) ) in ( ( B82 .:^2 ) . (B83 , B84) )))))))
proof
let C181 , C182 , C183 being non  empty set;
let C184 being (Function of [: C181 , C182 :] , C183);
let C185 being (Subset of C181);
let C186 being (Subset of C182);
let C187 , C188 being set;
assume that
L655: C187 in C185
and
L656: C188 in C186;
reconsider D91 = C188 as (Element of C182) by L656;
reconsider D92 = C187 as (Element of C181) by L655;
L657: (( ( C184 .:^2 ) . (C185 , C186) ) = ( C184 .: [: C185 , C186 :] ) & ( dom C184 ) = [: C181 , C182 :]) by L651 , FUNCT_2:def 1;
L658: [ D92 , D91 ] in [: C185 , C186 :] by L655 , L656 , ZFMISC_1:87;
thus L659: thesis by L658 , L657 , FUNCT_1:def 6;
end;
theorem
L660: (for B87 , B88 , B89 being non  empty set holds (for B90 being (Function of [: B87 , B88 :] , B89) holds (for B91 being (Subset of B87) holds (for B92 being (Subset of B88) holds ( ( B90 .:^2 ) . (B91 , B92) ) = { ( B90 . (B93 , B94) ) where B93 is (Element of B87) , B94 is (Element of B88) : (B93 in B91 & B94 in B92) }))))
proof
let C189 , C190 , C191 being non  empty set;
let C192 being (Function of [: C189 , C190 :] , C191);
let C193 being (Subset of C189);
let C194 being (Subset of C190);
set D93 = { ( C192 . (B95 , B96) ) where B95 is (Element of C189) , B96 is (Element of C190) : (B95 in C193 & B96 in C194) };
L661: ( ( C192 .:^2 ) . (C193 , C194) ) = ( C192 .: [: C193 , C194 :] ) by L651;
thus L662: ( ( C192 .:^2 ) . (C193 , C194) ) c= D93
proof
let R1 being set;
assume L663: R1 in ( ( C192 .:^2 ) . (C193 , C194) );
consider R2 being set such that L664: R2 in ( dom C192 ) and L665: R2 in [: C193 , C194 :] and L666: R1 = ( C192 . R2 ) by L663 , L661 , FUNCT_1:def 6;
consider C195 , C196 being set such that L667: C195 in C193 and L668: C196 in C194 and L669: R2 = [ C195 , C196 ] by L665 , ZFMISC_1:84;
reconsider D94 = C196 as (Element of C190) by L668;
reconsider D95 = C195 as (Element of C189) by L667;
L670: R1 = ( C192 . (D95 , D94) ) by L666 , L669;
thus L671: thesis by L670 , L667 , L668;
end;

let R1 being set;
assume L672: R1 in D93;
L673: (ex B97 being (Element of C189) st (ex B98 being (Element of C190) st (R1 = ( C192 . (B97 , B98) ) & B97 in C193 & B98 in C194))) by L672;
thus L674: thesis by L673 , L654;
end;
theorem
L675: (for R4 being set holds (for R5 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  commutative implies ( R15 .: [: R4 , R5 :] ) = ( R15 .: [: R5 , R4 :] ))))))
proof
let R4 being set;
let R5 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L676: (for R29 being (Element of R9) holds (for R30 being (Element of R9) holds ( R15 . (R29 , R30) ) = ( R15 . (R30 , R29) )));
L677:
now
let R4 being set;
let R5 being set;
thus L678: ( R15 .: [: R4 , R5 :] ) c= ( R15 .: [: R5 , R4 :] )
proof
let R1 being set;
assume L679: R1 in ( R15 .: [: R4 , R5 :] );
consider R2 being set such that L680: R2 in ( dom R15 ) and L681: R2 in [: R4 , R5 :] and L682: R1 = ( R15 . R2 ) by L679 , FUNCT_1:def 6;
reconsider D96 = R2 as (Element of [: R9 , R9 :]) by L680;
L683: D96 = [ ( D96 `1 ) , ( D96 `2 ) ] by MCART_1:21;
L684: (( D96 `1 ) in R4 & ( D96 `2 ) in R5) by L683 , L681 , ZFMISC_1:87;
L685: [ ( D96 `2 ) , ( D96 `1 ) ] in [: R5 , R4 :] by L684 , ZFMISC_1:87;
L686: (( dom R15 ) = [: R9 , R9 :] & ( R15 . (( D96 `1 ) , ( D96 `2 )) ) = ( R15 . (( D96 `2 ) , ( D96 `1 )) )) by L676 , FUNCT_2:def 1;
L687: R1 = ( R15 . (( D96 `1 ) , ( D96 `2 )) ) by L682 , MCART_1:21;
thus L688: thesis by L687 , L686 , L685 , FUNCT_1:def 6;
end;

end;
thus L679: (( R15 .: [: R4 , R5 :] ) c= ( R15 .: [: R5 , R4 :] ) & ( R15 .: [: R5 , R4 :] ) c= ( R15 .: [: R4 , R5 :] )) by L677;
end;
theorem
L680: (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  associative implies ( R15 .: [: ( R15 .: [: R4 , R5 :] ) , R6 :] ) = ( R15 .: [: R4 , ( R15 .: [: R5 , R6 :] ) :] )))))))
proof
let R4 being set;
let R5 being set;
let R6 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
L681: ( dom R15 ) = [: R9 , R9 :] by FUNCT_2:def 1;
assume L682: (for R29 being (Element of R9) holds (for R30 being (Element of R9) holds (for R31 being (Element of R9) holds ( R15 . (( R15 . (R29 , R30) ) , R31) ) = ( R15 . (R29 , ( R15 . (R30 , R31) )) ))));
thus L683: ( R15 .: [: ( R15 .: [: R4 , R5 :] ) , R6 :] ) c= ( R15 .: [: R4 , ( R15 .: [: R5 , R6 :] ) :] )
proof
let R1 being set;
assume L684: R1 in ( R15 .: [: ( R15 .: [: R4 , R5 :] ) , R6 :] );
consider R2 being set such that L685: R2 in ( dom R15 ) and L686: R2 in [: ( R15 .: [: R4 , R5 :] ) , R6 :] and L687: R1 = ( R15 . R2 ) by L684 , FUNCT_1:def 6;
reconsider D97 = R2 as (Element of [: R9 , R9 :]) by L685;
L688: D97 = [ ( D97 `1 ) , ( D97 `2 ) ] by MCART_1:21;
L689: ( D97 `2 ) in R6 by L688 , L686 , ZFMISC_1:87;
L690: ( D97 `1 ) in ( R15 .: [: R4 , R5 :] ) by L686 , L688 , ZFMISC_1:87;
consider R3 being set such that L691: R3 in ( dom R15 ) and L692: R3 in [: R4 , R5 :] and L693: ( D97 `1 ) = ( R15 . R3 ) by L690 , FUNCT_1:def 6;
reconsider D98 = R3 as (Element of [: R9 , R9 :]) by L691;
L694: ( D97 `1 ) = ( R15 . (( D98 `1 ) , ( D98 `2 )) ) by L693 , MCART_1:21;
L695: D98 = [ ( D98 `1 ) , ( D98 `2 ) ] by MCART_1:21;
L696: ( D98 `2 ) in R5 by L695 , L692 , ZFMISC_1:87;
L697: [ ( D98 `2 ) , ( D97 `2 ) ] in [: R5 , R6 :] by L696 , L689 , ZFMISC_1:87;
L698: ( R15 . (( D98 `2 ) , ( D97 `2 )) ) in ( R15 .: [: R5 , R6 :] ) by L697 , L681 , FUNCT_1:def 6;
L699: ( D98 `1 ) in R4 by L692 , L695 , ZFMISC_1:87;
L700: [ ( D98 `1 ) , ( R15 . (( D98 `2 ) , ( D97 `2 )) ) ] in [: R4 , ( R15 .: [: R5 , R6 :] ) :] by L699 , L698 , ZFMISC_1:87;
L701: R1 = ( R15 . (( D97 `1 ) , ( D97 `2 )) ) by L687 , MCART_1:21;
L702: R1 = ( R15 . (( D98 `1 ) , ( R15 . (( D98 `2 ) , ( D97 `2 )) )) ) by L701 , L682 , L694;
thus L703: thesis by L702 , L681 , L700 , FUNCT_1:def 6;
end;

let R1 being set;
assume L704: R1 in ( R15 .: [: R4 , ( R15 .: [: R5 , R6 :] ) :] );
consider R2 being set such that L705: R2 in ( dom R15 ) and L706: R2 in [: R4 , ( R15 .: [: R5 , R6 :] ) :] and L707: R1 = ( R15 . R2 ) by L704 , FUNCT_1:def 6;
reconsider D99 = R2 as (Element of [: R9 , R9 :]) by L705;
L708: D99 = [ ( D99 `1 ) , ( D99 `2 ) ] by MCART_1:21;
L709: ( D99 `1 ) in R4 by L708 , L706 , ZFMISC_1:87;
L710: ( D99 `2 ) in ( R15 .: [: R5 , R6 :] ) by L706 , L708 , ZFMISC_1:87;
consider R3 being set such that L711: R3 in ( dom R15 ) and L712: R3 in [: R5 , R6 :] and L713: ( D99 `2 ) = ( R15 . R3 ) by L710 , FUNCT_1:def 6;
reconsider D100 = R3 as (Element of [: R9 , R9 :]) by L711;
L714: ( D99 `2 ) = ( R15 . (( D100 `1 ) , ( D100 `2 )) ) by L713 , MCART_1:21;
L715: D100 = [ ( D100 `1 ) , ( D100 `2 ) ] by MCART_1:21;
L716: ( D100 `1 ) in R5 by L715 , L712 , ZFMISC_1:87;
L717: [ ( D99 `1 ) , ( D100 `1 ) ] in [: R4 , R5 :] by L716 , L709 , ZFMISC_1:87;
L718: ( R15 . (( D99 `1 ) , ( D100 `1 )) ) in ( R15 .: [: R4 , R5 :] ) by L717 , L681 , FUNCT_1:def 6;
L719: ( D100 `2 ) in R6 by L712 , L715 , ZFMISC_1:87;
L720: [ ( R15 . (( D99 `1 ) , ( D100 `1 )) ) , ( D100 `2 ) ] in [: ( R15 .: [: R4 , R5 :] ) , R6 :] by L719 , L718 , ZFMISC_1:87;
L721: R1 = ( R15 . (( D99 `1 ) , ( D99 `2 )) ) by L707 , MCART_1:21;
L722: R1 = ( R15 . (( R15 . (( D99 `1 ) , ( D100 `1 )) ) , ( D100 `2 )) ) by L721 , L682 , L714;
thus L723: thesis by L722 , L681 , L720 , FUNCT_1:def 6;
end;
theorem
L724: (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  commutative implies ( R15 .:^2 ) is  commutative)))
proof
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L725: R15 is  commutative;
let C197 , C198 being (Subset of R9);
thus L726: ( ( R15 .:^2 ) . (C197 , C198) ) = ( R15 .: [: C197 , C198 :] ) by L651
.= ( R15 .: [: C198 , C197 :] ) by L725 , L675
.= ( ( R15 .:^2 ) . (C198 , C197) ) by L651;
end;
theorem
L727: (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  associative implies ( R15 .:^2 ) is  associative)))
proof
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume L728: R15 is  associative;
let C199 , C200 , C201 being (Subset of R9);
thus L729: ( ( R15 .:^2 ) . (( ( R15 .:^2 ) . (C199 , C200) ) , C201) ) = ( ( R15 .:^2 ) . (( R15 .: [: C199 , C200 :] ) , C201) ) by L651
.= ( R15 .: [: ( R15 .: [: C199 , C200 :] ) , C201 :] ) by L651
.= ( R15 .: [: C199 , ( R15 .: [: C200 , C201 :] ) :] ) by L728 , L680
.= ( ( R15 .:^2 ) . (C199 , ( R15 .: [: C200 , C201 :] )) ) by L651
.= ( ( R15 .:^2 ) . (C199 , ( ( R15 .:^2 ) . (C200 , C201) )) ) by L651;
end;
theorem
L730: (for R4 being set holds (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (for R29 being (Element of R9) holds (R29 is_a_unity_wrt R15 implies (( R15 .: [: { R29 } , R4 :] ) = ( R9 /\ R4 ) & ( R15 .: [: R4 , { R29 } :] ) = ( R9 /\ R4 )))))))
proof
let R4 being set;
let R9 being non  empty set;
let R15 being (BinOp of R9);
let R29 being (Element of R9);
assume L731: R29 is_a_unity_wrt R15;
thus L732: ( R15 .: [: { R29 } , R4 :] ) c= ( R9 /\ R4 )
proof
let R1 being set;
assume L733: R1 in ( R15 .: [: { R29 } , R4 :] );
consider R2 being set such that L734: R2 in ( dom R15 ) and L735: R2 in [: { R29 } , R4 :] and L736: R1 = ( R15 . R2 ) by L733 , FUNCT_1:def 6;
reconsider D101 = R2 as (Element of [: R9 , R9 :]) by L734;
L737: R1 = ( R15 . (( D101 `1 ) , ( D101 `2 )) ) by L736 , MCART_1:21;
L738: D101 = [ ( D101 `1 ) , ( D101 `2 ) ] by MCART_1:21;
L739: ( D101 `1 ) in { R29 } by L738 , L735 , ZFMISC_1:87;
L740: ( D101 `1 ) = R29 by L739 , TARSKI:def 1;
L741: ( R15 . (R29 , ( D101 `2 )) ) = ( D101 `2 ) by L731 , BINOP_1:3;
L742: ( D101 `2 ) in R4 by L735 , L738 , ZFMISC_1:87;
thus L743: thesis by L742 , L737 , L741 , L740 , XBOOLE_0:def 4;
end;

L744: ( dom R15 ) = [: R9 , R9 :] by FUNCT_2:def 1;
thus L745: ( R9 /\ R4 ) c= ( R15 .: [: { R29 } , R4 :] )
proof
let R1 being set;
L746: R29 in { R29 } by TARSKI:def 1;
assume L747: R1 in ( R9 /\ R4 );
reconsider D102 = R1 as (Element of R9) by L747 , XBOOLE_0:def 4;
L748: R1 = ( R15 . (R29 , D102) ) by L731 , BINOP_1:3
.= ( R15 . [ R29 , R1 ] );
L749: R1 in R4 by L747 , XBOOLE_0:def 4;
L750: [ R29 , D102 ] in [: { R29 } , R4 :] by L749 , L746 , ZFMISC_1:87;
thus L751: thesis by L750 , L744 , L748 , FUNCT_1:def 6;
end;

thus L752: ( R15 .: [: R4 , { R29 } :] ) c= ( R9 /\ R4 )
proof
let R1 being set;
assume L753: R1 in ( R15 .: [: R4 , { R29 } :] );
consider R2 being set such that L754: R2 in ( dom R15 ) and L755: R2 in [: R4 , { R29 } :] and L756: R1 = ( R15 . R2 ) by L753 , FUNCT_1:def 6;
reconsider D103 = R2 as (Element of [: R9 , R9 :]) by L754;
L757: R1 = ( R15 . (( D103 `1 ) , ( D103 `2 )) ) by L756 , MCART_1:21;
L758: D103 = [ ( D103 `1 ) , ( D103 `2 ) ] by MCART_1:21;
L759: ( D103 `2 ) in { R29 } by L758 , L755 , ZFMISC_1:87;
L760: ( D103 `2 ) = R29 by L759 , TARSKI:def 1;
L761: ( R15 . (( D103 `1 ) , R29) ) = ( D103 `1 ) by L731 , BINOP_1:3;
L762: ( D103 `1 ) in R4 by L755 , L758 , ZFMISC_1:87;
thus L763: thesis by L762 , L757 , L761 , L760 , XBOOLE_0:def 4;
end;

thus L764: ( R9 /\ R4 ) c= ( R15 .: [: R4 , { R29 } :] )
proof
let R1 being set;
L765: R29 in { R29 } by TARSKI:def 1;
assume L766: R1 in ( R9 /\ R4 );
reconsider D104 = R1 as (Element of R9) by L766 , XBOOLE_0:def 4;
L767: R1 = ( R15 . (D104 , R29) ) by L731 , BINOP_1:3
.= ( R15 . [ R1 , R29 ] );
L768: R1 in R4 by L766 , XBOOLE_0:def 4;
L769: [ D104 , R29 ] in [: R4 , { R29 } :] by L768 , L765 , ZFMISC_1:87;
thus L770: thesis by L769 , L744 , L767 , FUNCT_1:def 6;
end;

end;
theorem
L765: (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (for R29 being (Element of R9) holds (R29 is_a_unity_wrt R15 implies ({ R29 } is_a_unity_wrt ( R15 .:^2 ) & ( R15 .:^2 ) is  having_a_unity & ( the_unity_wrt ( R15 .:^2 ) ) = { R29 })))))
proof
let R9 being non  empty set;
let R15 being (BinOp of R9);
let R29 being (Element of R9);
assume L766: R29 is_a_unity_wrt R15;
L767:
now
let C202 being (Subset of R9);
thus L768: ( ( R15 .:^2 ) . ({ R29 } , C202) ) = ( R15 .: [: { R29 } , C202 :] ) by L651
.= ( R9 /\ C202 ) by L766 , L730
.= C202 by XBOOLE_1:28;
thus L769: ( ( R15 .:^2 ) . (C202 , { R29 }) ) = ( R15 .: [: C202 , { R29 } :] ) by L651
.= ( R9 /\ C202 ) by L766 , L730
.= C202 by XBOOLE_1:28;
end;
thus L770: { R29 } is_a_unity_wrt ( R15 .:^2 ) by L767 , BINOP_1:3;
thus L771: (ex B99 being (Subset of R9) st B99 is_a_unity_wrt ( R15 .:^2 )) by L770;
thus L772: thesis by L770 , BINOP_1:def 8;
end;
theorem
L773: (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  having_a_unity implies (( R15 .:^2 ) is  having_a_unity & { ( the_unity_wrt R15 ) } is_a_unity_wrt ( R15 .:^2 ) & ( the_unity_wrt ( R15 .:^2 ) ) = { ( the_unity_wrt R15 ) }))))
proof
let R9 being non  empty set;
let R15 being (BinOp of R9);
given R29 being (Element of R9) such that
L774: R29 is_a_unity_wrt R15;

L775: R29 = ( the_unity_wrt R15 ) by L774 , BINOP_1:def 8;
thus L776: thesis by L775 , L774 , L765;
end;
theorem
L777: (for R9 being non  empty set holds (for R15 being (BinOp of R9) holds (R15 is  uniquely-decomposable implies ( R15 .:^2 ) is  uniquely-decomposable)))
proof
let R9 being non  empty set;
let R15 being (BinOp of R9);
assume that
L778: R15 is  having_a_unity
and
L779: (for R29 being (Element of R9) holds (for R30 being (Element of R9) holds (( R15 . (R29 , R30) ) = ( the_unity_wrt R15 ) implies (R29 = R30 & R30 = ( the_unity_wrt R15 )))));
thus L780: ( R15 .:^2 ) is  having_a_unity by L778 , L773;
let C203 , C204 being (Subset of R9);
assume that
L781: ( ( R15 .:^2 ) . (C203 , C204) ) = ( the_unity_wrt ( R15 .:^2 ) );
set D105 = ( the_unity_wrt R15 );
L782: ( the_unity_wrt ( R15 .:^2 ) ) = { D105 } by L778 , L773;
set D106 = the (Element of C203);
set D107 = the (Element of C204);
L783: ( R15 .: [: C203 , C204 :] ) = ( ( R15 .:^2 ) . (C203 , C204) ) by L651;
L784: ( dom R15 ) meets [: C203 , C204 :] by L783 , L781 , L782 , RELAT_1:118;
L785: ( ( dom R15 ) /\ [: C203 , C204 :] ) <> ( {} ) by L784 , XBOOLE_0:def 7;
L786: [: C203 , C204 :] <> ( {} ) by L785;
L787: C203 <> ( {} ) by L786 , ZFMISC_1:90;
L788: C204 <> ( {} ) by L786 , ZFMISC_1:90;
reconsider D108 = D106 , D109 = D107 as (Element of R9) by L788 , L787 , TARSKI:def 3;
L789: { D108 } c= C203 by L787 , ZFMISC_1:31;
L790: ( R15 . (D108 , D109) ) in { D105 } by L781 , L782 , L787 , L788 , L654;
L791: ( R15 . (D108 , D109) ) = D105 by L790 , TARSKI:def 1;
L792: D109 = D105 by L791 , L779;
L793: C203 c= { D105 }
proof
let R1 being set;
assume L794: R1 in C203;
reconsider D110 = R1 as (Element of R9) by L794;
L795: ( R15 . (D110 , D109) ) in { D105 } by L781 , L782 , L788 , L794 , L654;
L796: ( R15 . (D110 , D109) ) = D105 by L795 , TARSKI:def 1;
L797: D110 = D109 by L796 , L779;
thus L798: thesis by L797 , L792 , TARSKI:def 1;
end;
L799: C204 c= { D105 }
proof
let R1 being set;
assume L800: R1 in C204;
reconsider D111 = R1 as (Element of R9) by L800;
L801: ( R15 . (D108 , D111) ) in { D105 } by L781 , L782 , L787 , L800 , L654;
L802: ( R15 . (D108 , D111) ) = D105 by L801 , TARSKI:def 1;
L803: D111 = D105 by L802 , L779;
thus L804: thesis by L803 , TARSKI:def 1;
end;
L805: D108 = D109 by L779 , L791;
L806: { D109 } c= C204 by L788 , ZFMISC_1:31;
L807: C204 = { D105 } by L806 , L792 , L799 , XBOOLE_0:def 10;
thus L808: thesis by L807 , L778 , L805 , L792 , L789 , L793 , L773 , XBOOLE_0:def 10;
end;
definition
let C205 being non  empty multMagma;
func bool C205 -> multMagma equals 
:L809: multLoopStr (# ( bool (the carrier of C205) ) , ( (the multF of C205) .:^2 ) , { ( the_unity_wrt (the multF of C205) ) } #) if C205 is  unital otherwise multMagma (# ( bool (the carrier of C205) ) , ( (the multF of C205) .:^2 ) #);
correctness;
end;
registration
let C206 being non  empty multMagma;
cluster ( bool C206 ) -> non  empty;
coherence
proof
per cases ;
suppose L811: C206 is  unital;

L812: ( bool C206 ) = multLoopStr (# ( bool (the carrier of C206) ) , ( (the multF of C206) .:^2 ) , { ( the_unity_wrt (the multF of C206) ) } #) by L811 , L809;
thus L813: (the carrier of ( bool C206 )) is non  empty by L812;
end;
suppose L814: (not C206 is  unital);

L815: ( bool C206 ) = multMagma (# ( bool (the carrier of C206) ) , ( (the multF of C206) .:^2 ) #) by L814 , L809;
thus L816: (the carrier of ( bool C206 )) is non  empty by L815;
end;
end;
end;
definition
let C207 being  unital non  empty multMagma;
redefine func bool C207 ->  well-unital  strict non  empty multLoopStr;

coherence
proof
set D112 = multLoopStr (# ( bool H4(C207) ) , ( H1(C207) .:^2 ) , { ( the_unity_wrt H1(C207) ) } #);
L819: H1(C207) is  having_a_unity by MONOID_0:def 10;
L820: { ( the_unity_wrt H1(C207) ) } is_a_unity_wrt ( H1(C207) .:^2 ) by L819 , L773;
L821: (( 1. D112 ) = { ( the_unity_wrt H1(C207) ) } & ( bool C207 ) = D112) by L809;
thus L822: thesis by L821 , L820 , MONOID_0:def 21;
end;
end;
theorem
L824: (for R20 being non  empty multMagma holds ((the carrier of ( bool R20 )) = ( bool (the carrier of R20) ) & (the multF of ( bool R20 )) = ( (the multF of R20) .:^2 )))
proof
let R20 being non  empty multMagma;
L825: (( bool R20 ) = multLoopStr (# ( bool H4(R20) ) , ( H1(R20) .:^2 ) , { ( the_unity_wrt H1(R20) ) } #) or ( bool R20 ) = multMagma (# ( bool (the carrier of R20) ) , ( H1(R20) .:^2 ) #)) by L809;
thus L826: thesis by L825;
end;
theorem
L827: (for B100 being  unital non  empty multMagma holds ( 1. ( bool B100 ) ) = { ( the_unity_wrt (the multF of B100) ) })
proof
let C208 being  unital non  empty multMagma;
L828: ( bool C208 ) = multLoopStr (# ( bool H4(C208) ) , ( H1(C208) .:^2 ) , { ( the_unity_wrt H1(C208) ) } #) by L809;
thus L829: thesis by L828;
end;
theorem
L830: (for B101 being non  empty multMagma holds ((B101 is  commutative implies ( bool B101 ) is  commutative) & (B101 is  associative implies ( bool B101 ) is  associative) & (B101 is  uniquely-decomposable implies ( bool B101 ) is  uniquely-decomposable)))
proof
let C209 being non  empty multMagma;
L831: (H1(( bool C209 )) = ( H1(C209) .:^2 ) & H4(( bool C209 )) = ( bool H4(C209) )) by L824;
thus L832: (C209 is  commutative implies ( bool C209 ) is  commutative)
proof
assume L833: H1(C209) is  commutative;
thus L834: H1(( bool C209 )) is  commutative by L833 , L831 , L724;
end;

thus L835: (C209 is  associative implies ( bool C209 ) is  associative)
proof
assume L836: H1(C209) is  associative;
thus L837: H1(( bool C209 )) is  associative by L836 , L831 , L727;
end;

assume L838: H1(C209) is  uniquely-decomposable;
thus L839: H1(( bool C209 )) is  uniquely-decomposable by L838 , L831 , L777;
end;
