:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, CARD_1, FUNCOP_1,
      RELAT_1, FUNCT_1, NAT_1, ARYTM_3, XBOOLE_0, TARSKI, VALUED_1, EXTPRO_1,
      FSM_1, INT_1, FUNCT_4, GRAPHSP, AMI_3, AMI_2, STRUCT_0, COMPLEX1,
      XXREAL_0, ARYTM_1, TURING_1, AMISTD_2, SCMFSA6B, MSUALG_1, CIRCUIT2,
      SCMPDS_4, ORDINAL1, PARTFUN1, ORDINAL4, FINSET_1, COMPOS_1, GOBRD13,
      MEMSTR_0;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, CARD_1, FINSET_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, VALUED_1, FUNCT_4,
      FUNCT_7, INT_1, ORDINAL1, NAT_1, INT_2, XXREAL_0, STRUCT_0,
      MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMI_2, SCMPDS_2;
 constructors INT_2, SCMPDS_1, SCMPDS_3, DOMAIN_1, RELSET_1, PRE_POLY, AMI_3,
      FUNCT_7;
 registrations FUNCT_1, ORDINAL1, XXREAL_0, XREAL_0, NAT_1, INT_1, SCMPDS_2,
      FINSET_1, FUNCT_4, PRE_POLY, AFINSQ_1, COMPOS_1, ORDINAL5, EXTPRO_1,
      FUNCT_7, MEMSTR_0, AMI_3, COMPOS_0, CARD_3, STRUCT_0, RELSET_1,
      XTUPLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, COMPOS_1, EXTPRO_1, XBOOLE_0, SCMPDS_2, FUNCOP_1, NAT_1,
      AFINSQ_1, MEMSTR_0, XTUPLE_0;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, ZFMISC_1, INT_1, RELAT_1, SCMPDS_2,
      AMI_2, FUNCT_2, FUNCT_7, SCMPDS_3, ENUMSET1, ABSVALUE, GRFUNC_1,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, VALUED_1, AFINSQ_1,
      PARTFUN1, COMPOS_1, EXTPRO_1, PBOOLE, STRUCT_0, MEMSTR_0, RECDEF_2,
      XTUPLE_0;
 schemes NAT_1, CLASSES1;

begin
theorem
L1: (for R4 being (Instruction of ( SCMPDS )) holds (for R16 being (State of ( SCMPDS )) holds (( InsCode R4 ) in { ( 0 ) , 1 , 4 , 5 , 6 , 14 } or ( ( Exec (R4 , R16) ) . ( IC ( SCMPDS ) ) ) = ( succ ( IC R16 ) ))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R16 being (State of ( SCMPDS ));
assume L2: (not ( InsCode R4 ) in { ( 0 ) , 1 , 4 , 5 , 6 , 14 });
L3: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 1) by L2 , ENUMSET1:def 4;
L4: ( InsCode R4 ) <> 6 by L2 , ENUMSET1:def 4;
L5: (( InsCode R4 ) <> 4 & ( InsCode R4 ) <> 5) by L2 , ENUMSET1:def 4;
L6: ( InsCode R4 ) <> 14 by L2 , ENUMSET1:def 4;
per cases  by L6 , L3 , L5 , L4 , NAT_1:60 , SCMPDS_2:6;
suppose L7: ( InsCode R4 ) = 2;

L8: (ex R13 being Int_position st (ex R19 being Integer st R4 = ( R13 := R19 ))) by L7 , SCMPDS_2:28;
thus L9: thesis by L8 , SCMPDS_2:45;
end;
suppose L10: ( InsCode R4 ) = 3;

L11: (ex R13 being Int_position st (ex R19 being Integer st R4 = ( saveIC (R13 , R19) ))) by L10 , SCMPDS_2:29;
thus L12: thesis by L11 , SCMPDS_2:59;
end;
suppose L13: ( InsCode R4 ) = 7;

L14: (ex R13 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( (R13 , R19) := R20 )))) by L13 , SCMPDS_2:33;
thus L15: thesis by L14 , SCMPDS_2:46;
end;
suppose L16: ( InsCode R4 ) = 8;

L17: (ex R13 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( AddTo (R13 , R19 , R20) )))) by L16 , SCMPDS_2:34;
thus L18: thesis by L17 , SCMPDS_2:48;
end;
suppose L19: ( InsCode R4 ) = 9;

L20: (ex R13 being Int_position st (ex R14 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( AddTo (R13 , R19 , R14 , R20) ))))) by L19 , SCMPDS_2:35;
thus L21: thesis by L20 , SCMPDS_2:49;
end;
suppose L22: ( InsCode R4 ) = 10;

L23: (ex R13 being Int_position st (ex R14 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( SubFrom (R13 , R19 , R14 , R20) ))))) by L22 , SCMPDS_2:36;
thus L24: thesis by L23 , SCMPDS_2:50;
end;
suppose L25: ( InsCode R4 ) = 11;

L26: (ex R13 being Int_position st (ex R14 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( MultBy (R13 , R19 , R14 , R20) ))))) by L25 , SCMPDS_2:37;
thus L27: thesis by L26 , SCMPDS_2:51;
end;
suppose L28: ( InsCode R4 ) = 12;

L29: (ex R13 being Int_position st (ex R14 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( Divide (R13 , R19 , R14 , R20) ))))) by L28 , SCMPDS_2:38;
thus L30: thesis by L29 , SCMPDS_2:52;
end;
suppose L31: ( InsCode R4 ) = 13;

L32: (ex R13 being Int_position st (ex R14 being Int_position st (ex R19 being Integer st (ex R20 being Integer st R4 = ( (R13 , R19) := (R14 , R20) ))))) by L31 , SCMPDS_2:39;
thus L33: thesis by L32 , SCMPDS_2:47;
end;
end;
theorem
L35: (for B1 , B2 being (State of ( SCMPDS )) holds ((( IC B1 ) = ( IC B2 ) & (for B3 being Int_position holds ( B1 . B3 ) = ( B2 . B3 ))) implies B1 = B2))
proof
let C1 , C2 being (State of ( SCMPDS ));
assume that
L36: ( IC C1 ) = ( IC C2 )
and
L37: (for B4 being Int_position holds ( C1 . B4 ) = ( C2 . B4 ));
L38: (the carrier of ( SCMPDS )) = ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) ) by SCMPDS_2:84 , STRUCT_0:4;
L39: (the carrier of ( SCMPDS )) = ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) ) by L38
.= ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) );
L40: ( dom ( C2 | ( dom C2 ) ) ) = ( ( dom C2 ) /\ ( dom C2 ) ) by RELAT_1:61
.= ( dom C2 )
.= ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) ) by L39 , PARTFUN1:def 2;
L41: ( dom ( C1 | ( dom C1 ) ) ) = ( ( dom C1 ) /\ ( dom C1 ) ) by RELAT_1:61
.= ( dom C1 )
.= ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) ) by L39 , PARTFUN1:def 2;
L42: (( C1 | ( dom C1 ) ) = C1 & ( C2 | ( dom C2 ) ) = C2) by RELAT_1:69;
L43:
now
let C3 being set;
assume L44: C3 in ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) );
per cases  by L44 , XBOOLE_0:def 3;
suppose L45: C3 in { ( IC ( SCMPDS ) ) };

L46: C3 = ( IC ( SCMPDS ) ) by L45 , TARSKI:def 1;
thus L47: ( ( C1 | ( dom C1 ) ) . C3 ) = ( IC C1 ) by L46 , L41 , L44 , FUNCT_1:47
.= ( ( C2 | ( dom C2 ) ) . C3 ) by L36 , L40 , L44 , L46 , FUNCT_1:47;
end;
suppose L48: C3 in ( SCM-Data-Loc );

L49: C3 is Int_position by L48 , AMI_2:def 16;
thus L50: ( ( C1 | ( dom C1 ) ) . C3 ) = ( C1 . C3 ) by L41 , L44 , FUNCT_1:47
.= ( C2 . C3 ) by L37 , L49
.= ( ( C2 | ( dom C2 ) ) . C3 ) by L40 , L44 , FUNCT_1:47;
end;
end;
L52: ( C1 | ( dom C1 ) ) = ( C2 | ( dom C2 ) ) by L43 , L41 , L40 , FUNCT_1:2;
thus L53: C1 = C2 by L52 , L42;
end;
theorem
L54: (for B5 , B6 being (Element of ( NAT )) holds (B5 <> B6 implies ( DataLoc (B5 , ( 0 )) ) <> ( DataLoc (B6 , ( 0 )) )))
proof
let C4 , C5 being (Element of ( NAT ));
assume L55: C4 <> C5;
assume L56: ( DataLoc (C4 , ( 0 )) ) = ( DataLoc (C5 , ( 0 )) );
L57: ( abs ( C4 + ( 0 ) ) ) = ( abs ( C5 + ( 0 ) ) ) by L56 , XTUPLE_0:1;
L58: C4 = ( abs C5 ) by L57 , ABSVALUE:def 1;
thus L59: contradiction by L58 , L55 , ABSVALUE:def 1;
end;
theorem
L60: (for B7 being Int_position holds (ex B8 being (Element of ( NAT )) st B7 = ( DataLoc (B8 , ( 0 )) )))
proof
let C6 being Int_position;
L61: C6 in ( SCM-Data-Loc ) by AMI_2:def 16;
consider C7 being (Element of ( NAT )) such that L62: C6 = [ 1 , C7 ] by L61 , AMI_2:23;
take C7;
thus L63: thesis by L62 , ABSVALUE:def 1;
end;
scheme SCMPDSEx { F1(set) -> Integer , F2() -> (Element of ( NAT )) } : (ex B9 being (State of ( SCMPDS )) st (( IC B9 ) = F2() & (for B10 being (Element of ( NAT )) holds ( B9 . ( DataLoc (B10 , ( 0 )) ) ) = F1(B10))))
proof
set D1 = { ( IC ( SCMPDS ) ) };
set D2 = ( SCM-Data-Loc );
set D3 = ( NAT );
defpred S1[ set , set ] means (ex R2 being (Element of ( NAT )) st (($1 = ( IC ( SCMPDS ) ) & $2 = F2()) or ($1 = ( DataLoc (R2 , ( 0 )) ) & $2 = F1(R2))));
L64: (for B11 being set holds (B11 in (the carrier of ( SCMPDS )) implies (ex B12 being set st S1[ B11 , B12 ])))
proof
let C8 being set;
assume L65: C8 in (the carrier of ( SCMPDS ));
L66: C8 in ( D1 \/ D2 ) by L65 , SCMPDS_2:84 , STRUCT_0:4;
L67: C8 in ( D1 \/ D2 ) by L66;
L68:
now
per cases  by L67 , XBOOLE_0:def 3;
case L69: C8 in D1;
thus L70: C8 = ( IC ( SCMPDS ) ) by L69 , TARSKI:def 1;
end;
case L71: C8 in D2;
L72: C8 is Int_position by L71 , AMI_2:def 16;
thus L73: (ex R2 being (Element of ( NAT )) st C8 = ( DataLoc (R2 , ( 0 )) )) by L72 , L60;
end;
end;
consider R2 being (Element of ( NAT )) such that L75: (C8 = ( IC ( SCMPDS ) ) or C8 = ( DataLoc (R2 , ( 0 )) )) by L68;
per cases  by L75;
suppose L76: C8 = ( IC ( SCMPDS ) );

take D4 = F2();
thus L77: thesis by L76;
end;
suppose L78: C8 = ( DataLoc (R2 , ( 0 )) );

take D5 = F1(R2);
thus L79: thesis by L78;
end;
end;
consider C9 being Function such that L81: ( dom C9 ) = (the carrier of ( SCMPDS )) and L82: (for B13 being set holds (B13 in (the carrier of ( SCMPDS )) implies S1[ B13 , ( C9 . B13 ) ])) from CLASSES1:sch 1(L64);
L83: ( dom (the Object-Kind of ( SCMPDS )) ) = (the carrier of ( SCMPDS )) by FUNCT_2:def 1;
L84:
now
let C10 being set;
assume L85: C10 in ( dom (the Object-Kind of ( SCMPDS )) );
L86: C10 in ( D1 \/ D2 ) by L85 , L83 , SCMPDS_2:84 , STRUCT_0:4;
L87: C10 in ( D1 \/ D2 ) by L86;
consider R2 being (Element of ( NAT )) such that L88: ((C10 = ( IC ( SCMPDS ) ) & ( C9 . C10 ) = F2()) or (C10 = ( DataLoc (R2 , ( 0 )) ) & ( C9 . C10 ) = F1(R2))) by L82 , L83 , L85;
per cases  by L87 , XBOOLE_0:def 3;
suppose L89: C10 in D2;

L90: C10 is Int_position by L89 , AMI_2:def 16;
L91: ( ( the_Values_of ( SCMPDS ) ) . C10 ) = ( Values ( DataLoc (R2 , ( 0 )) ) ) by L90 , L88 , SCMPDS_2:43
.= ( INT ) by SCMPDS_2:5;
thus L92: ( C9 . C10 ) in ( ( the_Values_of ( SCMPDS ) ) . C10 ) by L91 , L88 , INT_1:def 2;
end;
suppose L93: C10 in D1;

L94: ( ( the_Values_of ( SCMPDS ) ) . C10 ) = ( Values ( IC ( SCMPDS ) ) ) by L93 , TARSKI:def 1
.= ( NAT ) by MEMSTR_0:def 6;
thus L95: ( C9 . C10 ) in ( ( the_Values_of ( SCMPDS ) ) . C10 ) by L94 , L88 , L93 , SCMPDS_2:2 , TARSKI:def 1;
end;
end;
reconsider D6 = C9 as (State of ( SCMPDS )) by L84 , L81 , L83 , FUNCT_1:def 14 , PARTFUN1:def 2 , RELAT_1:def 18;
consider R2 being (Element of ( NAT )) such that L97: ((( IC ( SCMPDS ) ) = ( IC ( SCMPDS ) ) & ( D6 . ( IC ( SCMPDS ) ) ) = F2()) or (( IC ( SCMPDS ) ) = ( DataLoc (R2 , ( 0 )) ) & ( D6 . ( IC ( SCMPDS ) ) ) = F1(R2))) by L82;
take D6;
thus L98: ( IC D6 ) = F2() by L97 , SCMPDS_2:43;
let C11 being (Element of ( NAT ));
L99: (ex R2 being (Element of ( NAT )) st ((( DataLoc (C11 , ( 0 )) ) = ( IC ( SCMPDS ) ) & ( D6 . ( DataLoc (C11 , ( 0 )) ) ) = F2()) or (( DataLoc (C11 , ( 0 )) ) = ( DataLoc (R2 , ( 0 )) ) & ( D6 . ( DataLoc (C11 , ( 0 )) ) ) = F1(R2)))) by L82;
thus L100: thesis by L99 , L54 , SCMPDS_2:43;
end;
theorem
L101: (for B14 being (State of ( SCMPDS )) holds ( dom B14 ) = ( { ( IC ( SCMPDS ) ) } \/ ( SCM-Data-Loc ) ))
proof
let C12 being (State of ( SCMPDS ));
L102: ( dom C12 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
thus L103: thesis by L102 , SCMPDS_2:84 , STRUCT_0:4;
end;
theorem
L104: (for B15 being (State of ( SCMPDS )) holds (for B16 being set holds (B16 in ( dom B15 ) implies (B16 is Int_position or B16 = ( IC ( SCMPDS ) )))))
proof
set D7 = { ( IC ( SCMPDS ) ) };
set D8 = ( SCM-Data-Loc );
set D9 = ( NAT );
let C13 being (State of ( SCMPDS ));
let C14 being set;
assume L105: C14 in ( dom C13 );
L106: ( dom C13 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L107: ( dom C13 ) = ( D7 \/ D8 ) by L106 , SCMPDS_2:84 , STRUCT_0:4;
L108: C14 in ( D7 \/ D8 ) by L107 , L105;
L109: (C14 in D7 or C14 in D8) by L108 , XBOOLE_0:def 3;
thus L110: thesis by L109 , AMI_2:def 16 , TARSKI:def 1;
end;
canceled 1;
theorem
L111: (for B17 , B18 being (State of ( SCMPDS )) holds ((for B19 being Int_position holds ( B17 . B19 ) = ( B18 . B19 )) iff ( DataPart B17 ) = ( DataPart B18 )))
proof
set D10 = { ( IC ( SCMPDS ) ) };
set D11 = ( SCM-Data-Loc );
set D12 = ( NAT );
let C15 , C16 being (State of ( SCMPDS ));
L112:
now
assume L113: (for B20 being Int_position holds ( C15 . B20 ) = ( C16 . B20 ));
thus L114:now
let C17 being set;
assume L115: C17 in ( SCM-Data-Loc );
L116: C17 is Int_position by L115 , AMI_2:def 16;
thus L117: ( C15 . C17 ) = ( C16 . C17 ) by L116 , L113;
end;
end;
L115:
now
assume L116: (for B21 being set holds (B21 in ( SCM-Data-Loc ) implies ( C15 . B21 ) = ( C16 . B21 )));
thus L117:now
let C18 being Int_position;
L118: C18 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L119: ( C15 . C18 ) = ( C16 . C18 ) by L118 , L116;
end;
end;
L118: ( dom C16 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L119: ( dom C16 ) = ( D10 \/ D11 ) by L118 , SCMPDS_2:84 , STRUCT_0:4;
L120: D11 c= ( dom C16 ) by L119 , XBOOLE_1:7;
L121: ( dom C15 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L122: ( dom C15 ) = ( D10 \/ D11 ) by L121 , SCMPDS_2:84 , STRUCT_0:4;
L123: D11 c= ( dom C15 ) by L122 , XBOOLE_1:7;
thus L124: thesis by L123 , L120 , L112 , L115 , FUNCT_1:95 , SCMPDS_2:84;
end;
begin
notation
let C19 , C20 being (Program of ( SCMPDS ));
synonym C19 ';' C20 for C19 ^ C20;
end;
definition
let C21 , C22 being (Program of ( SCMPDS ));
redefine func C21 ';' C22 -> (Program of ( SCMPDS )) equals 
( C21 +* ( Shift (C22 , ( card C21 )) ) );
compatibility by AFINSQ_1:77;
coherence;
end;
begin
definition
let R4 being (Instruction of ( SCMPDS ));
let R8 being (Program of ( SCMPDS ));
func R4 ';' R8 -> (Program of ( SCMPDS )) equals 
( ( Load R4 ) ';' R8 );
correctness;
end;
definition
let R7 being (Program of ( SCMPDS ));
let R5 being (Instruction of ( SCMPDS ));
func R7 ';' R5 -> (Program of ( SCMPDS )) equals 
( R7 ';' ( Load R5 ) );
correctness;
end;
definition
let R4 being (Instruction of ( SCMPDS ));
let R5 being (Instruction of ( SCMPDS ));
func R4 ';' R5 -> (Program of ( SCMPDS )) equals 
( ( Load R4 ) ';' ( Load R5 ) );
correctness;
end;
theorem
L130: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds ( R4 ';' R5 ) = ( ( Load R4 ) ';' R5 )));
theorem
L131: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds ( R4 ';' R5 ) = ( R4 ';' ( Load R5 ) )));
theorem
L132: (for R6 being (Instruction of ( SCMPDS )) holds (for R7 being (Program of ( SCMPDS )) holds (for R8 being (Program of ( SCMPDS )) holds ( ( R7 ';' R8 ) ';' R6 ) = ( R7 ';' ( R8 ';' R6 ) )))) by AFINSQ_1:27;
theorem
L133: (for R5 being (Instruction of ( SCMPDS )) holds (for R7 being (Program of ( SCMPDS )) holds (for R9 being (Program of ( SCMPDS )) holds ( ( R7 ';' R5 ) ';' R9 ) = ( R7 ';' ( R5 ';' R9 ) )))) by AFINSQ_1:27;
theorem
L134: (for R5 being (Instruction of ( SCMPDS )) holds (for R6 being (Instruction of ( SCMPDS )) holds (for R7 being (Program of ( SCMPDS )) holds ( ( R7 ';' R5 ) ';' R6 ) = ( R7 ';' ( R5 ';' R6 ) )))) by AFINSQ_1:27;
theorem
L135: (for R4 being (Instruction of ( SCMPDS )) holds (for R8 being (Program of ( SCMPDS )) holds (for R9 being (Program of ( SCMPDS )) holds ( ( R4 ';' R8 ) ';' R9 ) = ( R4 ';' ( R8 ';' R9 ) )))) by AFINSQ_1:27;
theorem
L136: (for R4 being (Instruction of ( SCMPDS )) holds (for R6 being (Instruction of ( SCMPDS )) holds (for R8 being (Program of ( SCMPDS )) holds ( ( R4 ';' R8 ) ';' R6 ) = ( R4 ';' ( R8 ';' R6 ) )))) by AFINSQ_1:27;
theorem
L137: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds (for R9 being (Program of ( SCMPDS )) holds ( ( R4 ';' R5 ) ';' R9 ) = ( R4 ';' ( R5 ';' R9 ) )))) by AFINSQ_1:27;
theorem
L138: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds (for R6 being (Instruction of ( SCMPDS )) holds ( ( R4 ';' R5 ) ';' R6 ) = ( R4 ';' ( R5 ';' R6 ) )))) by AFINSQ_1:27;
theorem
L139: (for R13 being Int_position holds (for R22 being (Element of ( NAT )) holds (not R13 in ( dom ( Start-At (R22 , ( SCMPDS )) ) ))))
proof
let R13 being Int_position;
let R22 being (Element of ( NAT ));
L140: ( dom ( Start-At (R22 , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L141: R13 in ( dom ( Start-At (R22 , ( SCMPDS )) ) );
L142: R13 = ( IC ( SCMPDS ) ) by L141 , L140 , TARSKI:def 1;
thus L143: contradiction by L142 , SCMPDS_2:43;
end;
definition
let C23 being (State of ( SCMPDS ));
let C24 being Int_position;
let C25 being Integer;
redefine func C23 +* (C24 , C25) -> (PartState of ( SCMPDS ));

coherence
proof
L144: ( dom C23 ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L145:
now
let C26 being set;
assume L146: C26 in ( dom ( C23 +* (C24 , C25) ) );
L147: C26 in ( dom C23 ) by L146 , L144 , PARTFUN1:def 2;
per cases ;
suppose L148: C26 = C24;

L149: ( ( the_Values_of ( SCMPDS ) ) . C26 ) = ( Values C24 ) by L148
.= ( INT ) by SCMPDS_2:5;
L150: ( ( C23 +* (C24 , C25) ) . C26 ) = C25 by L144 , L148 , FUNCT_7:31;
thus L151: ( ( C23 +* (C24 , C25) ) . C26 ) in ( ( the_Values_of ( SCMPDS ) ) . C26 ) by L150 , L149 , INT_1:def 2;
end;
suppose L152: C26 <> C24;

L153: ( ( C23 +* (C24 , C25) ) . C26 ) = ( C23 . C26 ) by L152 , FUNCT_7:32;
thus L154: ( ( C23 +* (C24 , C25) ) . C26 ) in ( ( the_Values_of ( SCMPDS ) ) . C26 ) by L153 , L147 , FUNCT_1:def 14;
end;
end;
thus L156: thesis by L145 , FUNCT_1:def 14;
end;
end;
begin
definition
let C27 being (Program of ( SCMPDS ));
let C28 being (State of ( SCMPDS ));
let C29 being (Instruction-Sequence of ( SCMPDS ));
func IExec (C27 , C29 , C28) -> (State of ( SCMPDS )) equals 
( Result (( C29 +* ( stop C27 ) ) , C28) );
coherence;
end;
definition
let C30 being (Program of ( SCMPDS ));
attr C30 is  paraclosed
means
:L159: (for B22 being ( 0 ) -started (State of ( SCMPDS )) holds (for B23 being (Element of ( NAT )) holds (for B24 being (Instruction-Sequence of ( SCMPDS )) holds (( stop C30 ) c= B24 implies ( IC ( Comput (B24 , B22 , B23) ) ) in ( dom ( stop C30 ) )))));
attr C30 is  parahalting
means
:L160: (for B25 being ( 0 ) -started (State of ( SCMPDS )) holds (for B26 being (Instruction-Sequence of ( SCMPDS )) holds (( stop C30 ) c= B26 implies B26 halts_on B25)));
end;
L162: ( Load ( halt ( SCMPDS ) ) ) is  parahalting
proof
let C31 being ( 0 ) -started (State of ( SCMPDS ));
let C32 being (Instruction-Sequence of ( SCMPDS ));
set D13 = ( Load ( halt ( SCMPDS ) ) );
set D14 = ( stop D13 );
assume L163: D14 c= C32;
L164: ( IC C31 ) = ( 0 ) by MEMSTR_0:def 11;
take ( 0 );
L165: ( IC ( Comput (C32 , C31 , ( 0 )) ) ) in ( NAT );
thus L166: ( IC ( Comput (C32 , C31 , ( 0 )) ) ) in ( dom C32 ) by L165 , PARTFUN1:def 2;
L167: ( D13 . ( 0 ) ) = ( halt ( SCMPDS ) ) by FUNCOP_1:72;
L168: ( dom D13 ) = { ( 0 ) } by FUNCOP_1:13;
L169: ( 0 ) in ( dom D13 ) by L168 , TARSKI:def 1;
L170: ( 0 ) in ( dom D14 ) by L169 , FUNCT_4:12;
L171: ( C32 /. ( IC C31 ) ) = ( C32 . ( IC C31 ) ) by PBOOLE:143;
L172: ( CurInstr (C32 , ( Comput (C32 , C31 , ( 0 )) )) ) = ( D14 . ( 0 ) ) by L163 , L170 , L164 , L171 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L167 , L169 , AFINSQ_1:def 3;
thus L173: thesis by L172;
end;
registration
cluster  parahalting for (Program of ( SCMPDS ));
existence by L162;
end;
canceled 1;
theorem
L175: (for R16 being (State of ( SCMPDS )) holds (for B27 , B28 being (Instruction-Sequence of ( SCMPDS )) holds (B28 = ( B27 +* ( (( IC R16 ) , ( succ ( IC R16 ) )) --> (( goto 1 ) , ( goto ( - 1 ) )) ) ) implies (not B28 halts_on R16))))
proof
let R16 being (State of ( SCMPDS ));
let C33 , C34 being (Instruction-Sequence of ( SCMPDS ));
assume that
L176: C34 = ( C33 +* ( (( IC R16 ) , ( succ ( IC R16 ) )) --> (( goto 1 ) , ( goto ( - 1 ) )) ) );
set D15 = ( (( IC R16 ) , ( succ ( IC R16 ) )) --> (( goto 1 ) , ( goto ( - 1 ) )) );
L177: ( D15 . ( succ ( IC R16 ) ) ) = ( goto ( - 1 ) ) by FUNCT_4:63;
L178: ( IC R16 ) <> ( succ ( IC R16 ) );
L179: ( D15 . ( IC R16 ) ) = ( goto 1 ) by L178 , FUNCT_4:63;
defpred S2[ Nat ] means (( IC ( Comput (C34 , R16 , $1) ) ) = ( IC R16 ) or ( IC ( Comput (C34 , R16 , $1) ) ) = ( succ ( IC R16 ) ));
L180: ( dom D15 ) = { ( IC R16 ) , ( succ ( IC R16 ) ) } by FUNCT_4:62;
L181: ( succ ( IC R16 ) ) in ( dom D15 ) by L180 , TARSKI:def 2;
L182: ( IC R16 ) in ( dom D15 ) by L180 , TARSKI:def 2;
L183:
now
let R3 being (Element of ( NAT ));
set D16 = ( Comput (C34 , R16 , R3) );
assume L184: (( IC D16 ) = ( IC R16 ) or ( IC D16 ) = ( succ ( IC R16 ) ));
L185: ( C34 /. ( IC D16 ) ) = ( C34 . ( IC D16 ) ) by PBOOLE:143;
per cases  by L184;
case L186: ( IC D16 ) = ( IC R16 );
L187: ( CurInstr (C34 , D16) ) = ( C34 . ( IC R16 ) ) by L186 , L185
.= ( goto 1 ) by L182 , L179 , L176 , FUNCT_4:13;
thus L188: ( IC ( Comput (C34 , R16 , ( R3 + 1 )) ) ) = ( IC ( Following (C34 , D16) ) ) by EXTPRO_1:3
.= ( ICplusConst (D16 , 1) ) by L187 , SCMPDS_2:54
.= ( succ ( IC R16 ) ) by L186 , SCMPDS_3:10;
end;
case L189: ( IC D16 ) = ( succ ( IC R16 ) );
reconsider D17 = ( IC R16 ) as (Element of ( NAT ));
L190: (ex B29 being (Element of ( NAT )) st (B29 = ( IC D16 ) & ( ICplusConst (D16 , ( - 1 )) ) = ( abs ( B29 + ( - 1 ) ) ))) by SCMPDS_2:def 18;
L191: ( C34 /. ( IC ( Comput (C34 , R16 , R3) ) ) ) = ( C34 . ( IC ( Comput (C34 , R16 , R3) ) ) ) by PBOOLE:143;
L192: ( CurInstr (C34 , ( Comput (C34 , R16 , R3) )) ) = ( C34 . ( succ ( IC R16 ) ) ) by L189 , L191
.= ( goto ( - 1 ) ) by L181 , L177 , L176 , FUNCT_4:13;
thus L193: ( IC ( Comput (C34 , R16 , ( R3 + 1 )) ) ) = ( IC ( Following (C34 , D16) ) ) by EXTPRO_1:3
.= ( abs ( ( D17 + 4 ) + ( - 4 ) ) ) by L189 , L192 , L190 , SCMPDS_2:54
.= ( IC R16 ) by ABSVALUE:def 1;
end;
end;
L195: (for R3 being (Element of ( NAT )) holds (S2[ R3 ] implies S2[ ( R3 + 1 ) ])) by L183;
let C35 being Nat;
reconsider D18 = C35 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L196: ( IC ( Comput (C34 , R16 , C35) ) ) in ( dom C34 );
L197: S2[ ( 0 ) ];
L198: (for R3 being (Element of ( NAT )) holds S2[ R3 ]) from NAT_1:sch 1(L197 , L195);
L199: ( C34 /. ( IC ( Comput (C34 , R16 , D18) ) ) ) = ( C34 . ( IC ( Comput (C34 , R16 , D18) ) ) ) by PBOOLE:143;
per cases  by L198;
suppose L200: ( IC ( Comput (C34 , R16 , D18) ) ) = ( IC R16 );

L201: ( CurInstr (C34 , ( Comput (C34 , R16 , D18) )) ) = ( C34 . ( IC R16 ) ) by L200 , L199
.= ( goto 1 ) by L182 , L179 , L176 , FUNCT_4:13;
thus L202: thesis by L201 , SCMPDS_2:73;
end;
suppose L203: ( IC ( Comput (C34 , R16 , D18) ) ) = ( succ ( IC R16 ) );

L204: ( CurInstr (C34 , ( Comput (C34 , R16 , D18) )) ) = ( C34 . ( succ ( IC R16 ) ) ) by L203 , L199
.= ( goto ( - 1 ) ) by L181 , L177 , L176 , FUNCT_4:13;
thus L205: thesis by L204 , SCMPDS_2:73;
end;
end;
theorem
L207: (for R3 being (Element of ( NAT )) holds (for R7 being (Program of ( SCMPDS )) holds (for R17 being (State of ( SCMPDS )) holds (for R18 being (State of ( SCMPDS )) holds (for B30 , B31 being (Instruction-Sequence of ( SCMPDS )) holds ((R17 = R18 & R7 c= B30 & R7 c= B31 & (for R2 being (Element of ( NAT )) holds (R2 < R3 implies ( IC ( Comput (B31 , R18 , R2) ) ) in ( dom R7 )))) implies (for R2 being (Element of ( NAT )) holds (R2 <= R3 implies ( Comput (B30 , R17 , R2) ) = ( Comput (B31 , R18 , R2) )))))))))
proof
let R3 being (Element of ( NAT ));
let R7 being (Program of ( SCMPDS ));
let R17 being (State of ( SCMPDS ));
let R18 being (State of ( SCMPDS ));
let C36 , C37 being (Instruction-Sequence of ( SCMPDS ));
assume that
L208: R17 = R18
and
L209: R7 c= C36
and
L210: R7 c= C37
and
L211: (for R2 being (Element of ( NAT )) holds (R2 < R3 implies ( IC ( Comput (C37 , R18 , R2) ) ) in ( dom R7 )));
defpred S3[ Nat ] means ($1 <= R3 implies ( Comput (C36 , R17 , $1) ) = ( Comput (C37 , R18 , $1) ));
L212: (for R2 being (Element of ( NAT )) holds (S3[ R2 ] implies S3[ ( R2 + 1 ) ]))
proof
let R2 being (Element of ( NAT ));
assume that
L213: (R2 <= R3 implies ( Comput (C36 , R17 , R2) ) = ( Comput (C37 , R18 , R2) ));
L214: ( Comput (C37 , R18 , ( R2 + 1 )) ) = ( Following (C37 , ( Comput (C37 , R18 , R2) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C37 , ( Comput (C37 , R18 , R2) )) ) , ( Comput (C37 , R18 , R2) )) );
L215: ( Comput (C36 , R17 , ( R2 + 1 )) ) = ( Following (C36 , ( Comput (C36 , R17 , R2) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C36 , ( Comput (C36 , R17 , R2) )) ) , ( Comput (C36 , R17 , R2) )) );
assume L216: ( R2 + 1 ) <= R3;
L217: ( IC ( Comput (C36 , R17 , R2) ) ) = ( IC ( Comput (C37 , R18 , R2) ) ) by L216 , L213 , NAT_1:13;
L218: R2 < R3 by L216 , NAT_1:13;
L219: ( IC ( Comput (C37 , R18 , R2) ) ) in ( dom R7 ) by L218 , L211;
L220: ( C36 /. ( IC ( Comput (C36 , R17 , R2) ) ) ) = ( C36 . ( IC ( Comput (C36 , R17 , R2) ) ) ) by PBOOLE:143;
L221: ( C37 /. ( IC ( Comput (C37 , R18 , R2) ) ) ) = ( C37 . ( IC ( Comput (C37 , R18 , R2) ) ) ) by PBOOLE:143;
L222: ( CurInstr (C36 , ( Comput (C36 , R17 , R2) )) ) = ( C36 . ( IC ( Comput (C36 , R17 , R2) ) ) ) by L220
.= ( R7 . ( IC ( Comput (C36 , R17 , R2) ) ) ) by L209 , L219 , L217 , GRFUNC_1:2
.= ( C37 . ( IC ( Comput (C37 , R18 , R2) ) ) ) by L210 , L219 , L217 , GRFUNC_1:2
.= ( CurInstr (C37 , ( Comput (C37 , R18 , R2) )) ) by L221;
thus L223: thesis by L222 , L213 , L215 , L214 , L216 , NAT_1:13;
end;
L224: S3[ ( 0 ) ] by L208;
thus L225: (for R2 being (Element of ( NAT )) holds S3[ R2 ]) from NAT_1:sch 1(L224 , L212);
end;
registration
cluster  parahalting ->  paraclosed for (Program of ( SCMPDS ));
coherence
proof
let C38 being (Program of ( SCMPDS ));
assume L226: C38 is  parahalting;
let C39 being ( 0 ) -started (State of ( SCMPDS ));
let C40 being (Element of ( NAT ));
let C41 being (Instruction-Sequence of ( SCMPDS ));
defpred S4[ Nat ] means (not ( IC ( Comput (C41 , C39 , $1) ) ) in ( dom ( stop C38 ) ));
assume L227: ( stop C38 ) c= C41;
assume L228: (not ( IC ( Comput (C41 , C39 , C40) ) ) in ( dom ( stop C38 ) ));
L229: (ex B32 being Nat st S4[ B32 ]) by L228;
consider C42 being Nat such that L230: S4[ C42 ] and L231: (for B33 being Nat holds (S4[ B33 ] implies C42 <= B33)) from NAT_1:sch 5(L229);
reconsider D19 = C42 as (Element of ( NAT )) by ORDINAL1:def 12;
L232: (for R2 being (Element of ( NAT )) holds (R2 < D19 implies ( IC ( Comput (C41 , C39 , R2) ) ) in ( dom ( stop C38 ) ))) by L231;
set D20 = ( Comput (C41 , C39 , D19) );
set D21 = ( (( IC D20 ) , ( succ ( IC D20 ) )) --> (( goto 1 ) , ( goto ( - 1 ) )) );
reconsider D22 = ( C41 +* D21 ) as (Instruction-Sequence of ( SCMPDS ));
reconsider D23 = ( C41 +* (( IC D20 ) , ( goto 1 )) ) as (Instruction-Sequence of ( SCMPDS ));
reconsider D24 = ( D23 +* (( succ ( IC D20 ) ) , ( goto ( - 1 ) )) ) as (Instruction-Sequence of ( SCMPDS ));
reconsider D25 = ( D23 +* (( succ ( IC D20 ) ) , ( goto ( - 1 ) )) ) as (Instruction-Sequence of ( SCMPDS ));
L233: D22 = D25 by FUNCT_7:139;
L234: (not ( succ ( IC D20 ) ) in ( dom ( stop C38 ) )) by L230 , AFINSQ_1:73;
L235: ( stop C38 ) c= D23 by L227 , L230 , FUNCT_7:89;
L236: ( stop C38 ) c= D25 by L235 , L234 , FUNCT_7:89;
L237: ( stop C38 ) c= D22 by L236 , L233;
L238: ( Comput (D22 , C39 , D19) ) = D20 by L237 , L227 , L232 , L207;
L239: ( Comput (D22 , C39 , D19) ) = D20 by L238;
L240: (not D22 halts_on D20) by L175;
L241: D22 halts_on C39 by L226 , L237 , L160;
L242: D22 halts_on ( Comput (D22 , C39 , D19) ) by L241 , EXTPRO_1:22;
L243: D22 halts_on D20 by L242 , L239;
thus L244: contradiction by L243 , L240;
end;
end;
begin
definition
let C43 being (Instruction of ( SCMPDS ));
let C44 being (Element of ( NAT ));
pred C43 valid_at C44
means
:L246: ((( InsCode C43 ) = 14 implies (ex R19 being Integer st (C43 = ( goto R19 ) & ( C44 + R19 ) >= ( 0 )))) & (( InsCode C43 ) = 4 implies (ex R13 being Int_position st (ex R19 being Integer st (ex R20 being Integer st (C43 = ( (R13 , R19) <>0_goto R20 ) & ( C44 + R20 ) >= ( 0 )))))) & (( InsCode C43 ) = 5 implies (ex R13 being Int_position st (ex R19 being Integer st (ex R20 being Integer st (C43 = ( (R13 , R19) <=0_goto R20 ) & ( C44 + R20 ) >= ( 0 )))))) & (( InsCode C43 ) = 6 implies (ex R13 being Int_position st (ex R19 being Integer st (ex R20 being Integer st (C43 = ( (R13 , R19) >=0_goto R20 ) & ( C44 + R20 ) >= ( 0 )))))))
;end;
definition
let C45 being  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
attr C45 is  shiftable
means
:L248: (for R3 being (Element of ( NAT )) holds (for R4 being (Instruction of ( SCMPDS )) holds ((R3 in ( dom C45 ) & R4 = ( C45 . R3 )) implies (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3 & R4 valid_at R3))));
end;
L250: ( Load ( halt ( SCMPDS ) ) ) is  shiftable
proof
set D26 = ( Load ( halt ( SCMPDS ) ) );
L251: ( dom D26 ) = { ( 0 ) } by FUNCOP_1:13;
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L252: R3 in ( dom D26 )
and
L253: R4 = ( D26 . R3 );
L254: R3 = ( 0 ) by L251 , L252 , TARSKI:def 1;
L255: R4 = ( halt ( SCMPDS ) ) by L253 , L254 , AFINSQ_1:34;
L256: R4 = [ ( 0 ) , ( {} ) , ( {} ) ] by L255 , SCMPDS_2:80;
L257: ( InsCode R4 ) = ( 0 ) by L256 , RECDEF_2:def 1;
thus L258: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L257;
L259: (( InsCode R4 ) <> 4 & ( InsCode R4 ) <> 5 & ( InsCode R4 ) <> 6 & ( InsCode R4 ) <> 14) by L257;
thus L260: R4 valid_at R3 by L259 , L246;
end;
theorem
L261: (for B34 being (Instruction of ( SCMPDS )) holds (for B35 , B36 being (Element of ( NAT )) holds ((B34 valid_at B35 & B35 <= B36) implies B34 valid_at B36)))
proof
let C46 being (Instruction of ( SCMPDS ));
let C47 , C48 being (Element of ( NAT ));
assume that
L262: C46 valid_at C47
and
L263: C47 <= C48;
L264:
now
assume L265: ( InsCode C46 ) = 4;
consider R13 being Int_position, R19 being Integer, R20 being Integer such that L266: C46 = ( (R13 , R19) <>0_goto R20 ) and L267: ( C47 + R20 ) >= ( 0 ) by L265 , L262 , L246;
take D27 = R13;
take D28 = R19;
take D29 = R20;
thus L268: C46 = ( (D27 , D28) <>0_goto D29 ) by L266;
thus L269: ( C48 + D29 ) >= ( 0 ) by L263 , L267 , XREAL_1:6;
end;
L270:
now
assume L271: ( InsCode C46 ) = 6;
consider R13 being Int_position, R19 being Integer, R20 being Integer such that L272: C46 = ( (R13 , R19) >=0_goto R20 ) and L273: ( C47 + R20 ) >= ( 0 ) by L271 , L262 , L246;
take D30 = R13;
take D31 = R19;
take D32 = R20;
thus L274: C46 = ( (D30 , D31) >=0_goto D32 ) by L272;
thus L275: ( C48 + D32 ) >= ( 0 ) by L263 , L273 , XREAL_1:6;
end;
L276:
now
assume L277: ( InsCode C46 ) = 5;
consider R13 being Int_position, R19 being Integer, R20 being Integer such that L278: C46 = ( (R13 , R19) <=0_goto R20 ) and L279: ( C47 + R20 ) >= ( 0 ) by L277 , L262 , L246;
take D33 = R13;
take D34 = R19;
take D35 = R20;
thus L280: C46 = ( (D33 , D34) <=0_goto D35 ) by L278;
thus L281: ( C48 + D35 ) >= ( 0 ) by L263 , L279 , XREAL_1:6;
end;
L282:
now
assume L283: ( InsCode C46 ) = 14;
consider R19 being Integer such that L284: C46 = ( goto R19 ) and L285: ( C47 + R19 ) >= ( 0 ) by L283 , L262 , L246;
take D36 = R19;
thus L286: C46 = ( goto D36 ) by L284;
thus L287: ( C48 + D36 ) >= ( 0 ) by L263 , L285 , XREAL_1:6;
end;
thus L288: thesis by L282 , L264 , L276 , L270 , L246;
end;
registration
cluster  parahalting  shiftable for (Program of ( SCMPDS ));
existence by L162 , L250;
end;
definition
let C49 being (Instruction of ( SCMPDS ));
attr C49 is  shiftable
means
:L290: (( InsCode C49 ) = 2 or (( InsCode C49 ) <> 14 & ( InsCode C49 ) > 6));
end;
registration
cluster  shiftable for (Instruction of ( SCMPDS ));
existence
proof
take D37 = ( ( DataLoc (( 0 ) , ( 0 )) ) := 1 );
L292: ( InsCode D37 ) = 2 by SCMPDS_2:14;
thus L293: thesis by L292 , L290;
end;
end;
registration
let R13 being Int_position;
let R19 being Integer;
cluster ( R13 := R19 ) ->  shiftable;
coherence
proof
L295: ( InsCode ( R13 := R19 ) ) = 2 by SCMPDS_2:14;
thus L296: thesis by L295 , L290;
end;
end;
registration
let R13 being Int_position;
let R19 being Integer;
let R20 being Integer;
cluster ( (R13 , R19) := R20 ) ->  shiftable;
coherence
proof
L298: ( InsCode ( (R13 , R19) := R20 ) ) = 7 by SCMPDS_2:19;
thus L299: thesis by L298 , L290;
end;
end;
registration
let R13 being Int_position;
let R19 being Integer;
let R20 being Integer;
cluster ( AddTo (R13 , R19 , R20) ) ->  shiftable;
coherence
proof
L301: ( InsCode ( AddTo (R13 , R19 , R20) ) ) = 8 by SCMPDS_2:20;
thus L302: thesis by L301 , L290;
end;
end;
registration
let R13 being Int_position;
let R14 being Int_position;
let R19 being Integer;
let R20 being Integer;
cluster ( AddTo (R13 , R19 , R14 , R20) ) ->  shiftable;
coherence
proof
L304: ( InsCode ( AddTo (R13 , R19 , R14 , R20) ) ) = 9 by SCMPDS_2:21;
thus L305: thesis by L304 , L290;
end;
cluster ( SubFrom (R13 , R19 , R14 , R20) ) ->  shiftable;
coherence
proof
L306: ( InsCode ( SubFrom (R13 , R19 , R14 , R20) ) ) = 10 by SCMPDS_2:22;
thus L307: thesis by L306 , L290;
end;
cluster ( MultBy (R13 , R19 , R14 , R20) ) ->  shiftable;
coherence
proof
L308: ( InsCode ( MultBy (R13 , R19 , R14 , R20) ) ) = 11 by SCMPDS_2:23;
thus L309: thesis by L308 , L290;
end;
cluster ( Divide (R13 , R19 , R14 , R20) ) ->  shiftable;
coherence
proof
L310: ( InsCode ( Divide (R13 , R19 , R14 , R20) ) ) = 12 by SCMPDS_2:24;
thus L311: thesis by L310 , L290;
end;
cluster ( (R13 , R19) := (R14 , R20) ) ->  shiftable;
coherence
proof
L312: ( InsCode ( (R13 , R19) := (R14 , R20) ) ) = 13 by SCMPDS_2:25;
thus L313: thesis by L312 , L290;
end;
end;
registration
let C50 , C51 being  shiftable (Program of ( SCMPDS ));
cluster ( C50 ';' C51 ) ->  shiftable for (Program of ( SCMPDS ));
coherence
proof
set D38 = ( C50 ';' C51 );
L315:
now
set D39 = { ( R29 + ( card C50 ) ) where R29 is (Element of ( NAT )) : R29 in ( dom C51 ) };
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L316: R3 in ( dom D38 )
and
L317: R4 = ( D38 . R3 );
L318: ( dom ( Shift (C51 , ( card C50 )) ) ) = D39 by VALUED_1:def 12;
L319: ( dom D38 ) = ( ( dom C50 ) \/ D39 ) by L318 , FUNCT_4:def 1;
per cases  by L316 , L319 , XBOOLE_0:def 3;
suppose L320: R3 in ( dom C50 );

L321: ( C50 . R3 ) = R4 by L320 , L317 , AFINSQ_1:def 3;
thus L322: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3 & R4 valid_at R3) by L321 , L320 , L248;
end;
suppose L323: R3 in D39;

consider R29 being (Element of ( NAT )) such that L324: R3 = ( R29 + ( card C50 ) ) and L325: R29 in ( dom C51 ) by L323;
L326: ( C51 . R29 ) = R4 by L317 , L324 , L325 , AFINSQ_1:def 3;
thus L327: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L326 , L325 , L248;
L328: R4 valid_at R29 by L325 , L326 , L248;
thus L329: R4 valid_at R3 by L328 , L324 , L261 , NAT_1:11;
end;
end;
thus L331: thesis by L315 , L248;
end;
end;
registration
let C52 being  shiftable (Instruction of ( SCMPDS ));
cluster ( Load C52 ) ->  shiftable for (Program of ( SCMPDS ));
coherence
proof
let C53 being (Program of ( SCMPDS ));
assume that
L333: C53 = ( Load C52 );
let R3 being (Element of ( NAT ));
let R5 being (Instruction of ( SCMPDS ));
assume that
L334: R3 in ( dom C53 )
and
L335: R5 = ( C53 . R3 );
L336: ( dom C53 ) = { ( 0 ) } by L333 , FUNCOP_1:13;
L337: R3 = ( 0 ) by L336 , L334 , TARSKI:def 1;
L338: R5 = C52 by L337 , L335 , L333 , FUNCOP_1:72;
thus L339: ( InsCode R5 ) <> 1 by L338 , L290;
thus L340: ( InsCode R5 ) <> 3 by L338 , L290;
L341: (( InsCode R5 ) <> 4 & ( InsCode R5 ) <> 5 & ( InsCode R5 ) <> 6 & ( InsCode R5 ) <> 14) by L338 , L290;
thus L342: R5 valid_at R3 by L341 , L246;
end;
end;
registration
let C54 being  shiftable (Instruction of ( SCMPDS ));
let C55 being  shiftable (Program of ( SCMPDS ));
cluster ( C54 ';' C55 ) ->  shiftable;
coherence;
end;
registration
let C56 being  shiftable (Program of ( SCMPDS ));
let C57 being  shiftable (Instruction of ( SCMPDS ));
cluster ( C56 ';' C57 ) ->  shiftable;
coherence;
end;
registration
let C58 , C59 being  shiftable (Instruction of ( SCMPDS ));
cluster ( C58 ';' C59 ) ->  shiftable;
coherence;
end;
registration
cluster ( Stop ( SCMPDS ) ) ->  parahalting  shiftable;
coherence by L162 , L250;
end;
registration
let C60 being  shiftable (Program of ( SCMPDS ));
cluster ( stop C60 ) ->  shiftable;
coherence;
end;
theorem
L349: (for B37 being  shiftable (Program of ( SCMPDS )) holds (for B38 being Integer holds (( ( card B37 ) + B38 ) >= ( 0 ) implies ( B37 ';' ( goto B38 ) ) is  shiftable)))
proof
let C61 being  shiftable (Program of ( SCMPDS ));
let C62 being Integer;
set D40 = ( Load ( goto C62 ) );
set D41 = ( C61 ';' ( goto C62 ) );
assume L350: ( ( card C61 ) + C62 ) >= ( 0 );
L351:
now
set D42 = { ( R29 + ( card C61 ) ) where R29 is (Element of ( NAT )) : R29 in ( dom D40 ) };
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L352: R3 in ( dom D41 )
and
L353: R4 = ( D41 . R3 );
L354: ( dom ( Shift (D40 , ( card C61 )) ) ) = D42 by VALUED_1:def 12;
L355: ( dom D41 ) = ( ( dom C61 ) \/ D42 ) by L354 , FUNCT_4:def 1;
per cases  by L352 , L355 , XBOOLE_0:def 3;
suppose L356: R3 in ( dom C61 );

L357: ( C61 . R3 ) = R4 by L356 , L353 , AFINSQ_1:def 3;
thus L358: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3 & R4 valid_at R3) by L357 , L356 , L248;
end;
suppose L359: R3 in D42;

consider R29 being (Element of ( NAT )) such that L360: R3 = ( R29 + ( card C61 ) ) and L361: R29 in ( dom D40 ) by L359;
L362: ( dom D40 ) = { ( 0 ) } by FUNCOP_1:13;
L363: R29 = ( 0 ) by L362 , L361 , TARSKI:def 1;
L364: ( goto C62 ) = ( D40 . R29 ) by L363 , FUNCOP_1:72
.= R4 by L353 , L360 , L361 , AFINSQ_1:def 3;
thus L365: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L364 , SCMPDS_2:12;
L366: ( InsCode R4 ) <> 6 by L364 , SCMPDS_2:12;
L367: (( InsCode R4 ) <> 4 & ( InsCode R4 ) <> 5) by L364 , SCMPDS_2:12;
thus L368: R4 valid_at R3 by L367 , L350 , L360 , L363 , L364 , L366 , L246;
end;
end;
thus L370: thesis by L351 , L248;
end;
registration
let C63 being (Element of ( NAT ));
cluster ( Load ( goto C63 ) ) ->  shiftable for (Program of ( SCMPDS ));
coherence
proof
set D43 = C63;
set D44 = ( Load ( goto D43 ) );
L371:
now
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L372: R3 in ( dom D44 )
and
L373: R4 = ( D44 . R3 );
L374: ( dom D44 ) = { ( 0 ) } by FUNCOP_1:13;
L375: R3 = ( 0 ) by L374 , L372 , TARSKI:def 1;
L376: ( goto D43 ) = R4 by L375 , L373 , FUNCOP_1:72;
thus L377: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L376 , SCMPDS_2:12;
L378: (( R3 + D43 ) >= ( 0 ) & ( InsCode R4 ) <> 6) by L376 , SCMPDS_2:12;
L379: (( InsCode R4 ) <> 4 & ( InsCode R4 ) <> 5) by L376 , SCMPDS_2:12;
thus L380: R4 valid_at R3 by L379 , L376 , L378 , L246;
end;
thus L381: thesis by L371 , L248;
end;
end;
theorem
L383: (for B39 being  shiftable (Program of ( SCMPDS )) holds (for B40 , B41 being Integer holds (for B42 being Int_position holds (( ( card B39 ) + B41 ) >= ( 0 ) implies ( B39 ';' ( (B42 , B40) <>0_goto B41 ) ) is  shiftable))))
proof
let C64 being  shiftable (Program of ( SCMPDS ));
let C65 , C66 being Integer;
let C67 being Int_position;
set D45 = ( (C67 , C65) <>0_goto C66 );
set D46 = ( Load D45 );
set D47 = ( C64 ';' D45 );
assume L384: ( ( card C64 ) + C66 ) >= ( 0 );
L385:
now
set D48 = { ( R29 + ( card C64 ) ) where R29 is (Element of ( NAT )) : R29 in ( dom D46 ) };
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L386: R3 in ( dom D47 )
and
L387: R4 = ( D47 . R3 );
L388: ( dom ( Shift (D46 , ( card C64 )) ) ) = D48 by VALUED_1:def 12;
L389: ( dom D47 ) = ( ( dom C64 ) \/ D48 ) by L388 , FUNCT_4:def 1;
per cases  by L386 , L389 , XBOOLE_0:def 3;
suppose L390: R3 in ( dom C64 );

L391: ( C64 . R3 ) = R4 by L390 , L387 , AFINSQ_1:def 3;
thus L392: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3 & R4 valid_at R3) by L391 , L390 , L248;
end;
suppose L393: R3 in D48;

consider R29 being (Element of ( NAT )) such that L394: R3 = ( R29 + ( card C64 ) ) and L395: R29 in ( dom D46 ) by L393;
L396: ( dom D46 ) = { ( 0 ) } by FUNCOP_1:13;
L397: R29 = ( 0 ) by L396 , L395 , TARSKI:def 1;
L398: D45 = ( D46 . R29 ) by L397 , FUNCOP_1:72
.= R4 by L387 , L394 , L395 , AFINSQ_1:def 3;
thus L399: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L398 , SCMPDS_2:16;
L400: (( InsCode R4 ) <> 6 & ( InsCode R4 ) <> 14) by L398 , SCMPDS_2:16;
L401: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 5) by L398 , SCMPDS_2:16;
thus L402: R4 valid_at R3 by L401 , L384 , L394 , L397 , L398 , L400 , L246;
end;
end;
thus L404: thesis by L385 , L248;
end;
registration
let C68 being Integer;
let C69 being Int_position;
let C70 being (Element of ( NAT ));
cluster ( Load ( (C69 , C68) <>0_goto C70 ) ) ->  shiftable for (Program of ( SCMPDS ));
coherence
proof
set D49 = C70;
set D50 = ( (C69 , C68) <>0_goto D49 );
set D51 = ( Load D50 );
L405:
now
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L406: R3 in ( dom D51 )
and
L407: R4 = ( D51 . R3 );
L408: ( dom D51 ) = { ( 0 ) } by FUNCOP_1:13;
L409: R3 = ( 0 ) by L408 , L406 , TARSKI:def 1;
L410: D50 = R4 by L409 , L407 , FUNCOP_1:72;
thus L411: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L410 , SCMPDS_2:16;
L412: (( R3 + D49 ) >= ( 0 ) & ( InsCode R4 ) <> 6 & ( InsCode R4 ) <> 14) by L410 , SCMPDS_2:16;
L413: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 5) by L410 , SCMPDS_2:16;
thus L414: R4 valid_at R3 by L413 , L410 , L412 , L246;
end;
thus L415: thesis by L405 , L248;
end;
end;
theorem
L417: (for B43 being  shiftable (Program of ( SCMPDS )) holds (for B44 , B45 being Integer holds (for B46 being Int_position holds (( ( card B43 ) + B45 ) >= ( 0 ) implies ( B43 ';' ( (B46 , B44) <=0_goto B45 ) ) is  shiftable))))
proof
let C71 being  shiftable (Program of ( SCMPDS ));
let C72 , C73 being Integer;
let C74 being Int_position;
set D52 = ( (C74 , C72) <=0_goto C73 );
set D53 = ( Load D52 );
set D54 = ( C71 ';' D52 );
assume L418: ( ( card C71 ) + C73 ) >= ( 0 );
L419:
now
set D55 = { ( R29 + ( card C71 ) ) where R29 is (Element of ( NAT )) : R29 in ( dom D53 ) };
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L420: R3 in ( dom D54 )
and
L421: R4 = ( D54 . R3 );
L422: ( dom ( Shift (D53 , ( card C71 )) ) ) = D55 by VALUED_1:def 12;
L423: ( dom D54 ) = ( ( dom C71 ) \/ D55 ) by L422 , FUNCT_4:def 1;
per cases  by L420 , L423 , XBOOLE_0:def 3;
suppose L424: R3 in ( dom C71 );

L425: ( C71 . R3 ) = R4 by L424 , L421 , AFINSQ_1:def 3;
thus L426: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3 & R4 valid_at R3) by L425 , L424 , L248;
end;
suppose L427: R3 in D55;

consider R29 being (Element of ( NAT )) such that L428: R3 = ( R29 + ( card C71 ) ) and L429: R29 in ( dom D53 ) by L427;
L430: ( dom D53 ) = { ( 0 ) } by FUNCOP_1:13;
L431: R29 = ( 0 ) by L430 , L429 , TARSKI:def 1;
L432: D52 = ( D53 . R29 ) by L431 , FUNCOP_1:72
.= R4 by L421 , L428 , L429 , AFINSQ_1:def 3;
thus L433: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L432 , SCMPDS_2:17;
L434: (( InsCode R4 ) <> 6 & ( InsCode R4 ) <> 14) by L432 , SCMPDS_2:17;
L435: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 4) by L432 , SCMPDS_2:17;
thus L436: R4 valid_at R3 by L435 , L418 , L428 , L431 , L432 , L434 , L246;
end;
end;
thus L438: thesis by L419 , L248;
end;
registration
let C75 being Integer;
let C76 being Int_position;
let C77 being (Element of ( NAT ));
cluster ( Load ( (C76 , C75) <=0_goto C77 ) ) ->  shiftable for (Program of ( SCMPDS ));
coherence
proof
set D56 = C77;
set D57 = ( (C76 , C75) <=0_goto D56 );
set D58 = ( Load D57 );
L439:
now
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L440: R3 in ( dom D58 )
and
L441: R4 = ( D58 . R3 );
L442: ( dom D58 ) = { ( 0 ) } by FUNCOP_1:13;
L443: R3 = ( 0 ) by L442 , L440 , TARSKI:def 1;
L444: D57 = R4 by L443 , L441 , FUNCOP_1:72;
thus L445: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L444 , SCMPDS_2:17;
L446: (( R3 + D56 ) >= ( 0 ) & ( InsCode R4 ) <> 6 & ( InsCode R4 ) <> 14) by L444 , SCMPDS_2:17;
L447: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 4) by L444 , SCMPDS_2:17;
thus L448: R4 valid_at R3 by L447 , L444 , L446 , L246;
end;
thus L449: thesis by L439 , L248;
end;
end;
theorem
L451: (for B47 being  shiftable (Program of ( SCMPDS )) holds (for B48 , B49 being Integer holds (for B50 being Int_position holds (( ( card B47 ) + B49 ) >= ( 0 ) implies ( B47 ';' ( (B50 , B48) >=0_goto B49 ) ) is  shiftable))))
proof
let C78 being  shiftable (Program of ( SCMPDS ));
let C79 , C80 being Integer;
let C81 being Int_position;
set D59 = ( (C81 , C79) >=0_goto C80 );
set D60 = ( Load D59 );
set D61 = ( C78 ';' D59 );
assume L452: ( ( card C78 ) + C80 ) >= ( 0 );
L453:
now
set D62 = { ( R29 + ( card C78 ) ) where R29 is (Element of ( NAT )) : R29 in ( dom D60 ) };
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L454: R3 in ( dom D61 )
and
L455: R4 = ( D61 . R3 );
L456: ( dom ( Shift (D60 , ( card C78 )) ) ) = D62 by VALUED_1:def 12;
L457: ( dom D61 ) = ( ( dom C78 ) \/ D62 ) by L456 , FUNCT_4:def 1;
per cases  by L454 , L457 , XBOOLE_0:def 3;
suppose L458: R3 in ( dom C78 );

L459: ( C78 . R3 ) = R4 by L458 , L455 , AFINSQ_1:def 3;
thus L460: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3 & R4 valid_at R3) by L459 , L458 , L248;
end;
suppose L461: R3 in D62;

consider R29 being (Element of ( NAT )) such that L462: R3 = ( R29 + ( card C78 ) ) and L463: R29 in ( dom D60 ) by L461;
L464: ( dom D60 ) = { ( 0 ) } by FUNCOP_1:13;
L465: R29 = ( 0 ) by L464 , L463 , TARSKI:def 1;
L466: D59 = ( D60 . R29 ) by L465 , FUNCOP_1:72
.= R4 by L455 , L462 , L463 , AFINSQ_1:def 3;
thus L467: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L466 , SCMPDS_2:18;
L468: (( InsCode R4 ) <> 5 & ( InsCode R4 ) <> 14) by L466 , SCMPDS_2:18;
L469: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 4) by L466 , SCMPDS_2:18;
thus L470: R4 valid_at R3 by L469 , L452 , L462 , L465 , L466 , L468 , L246;
end;
end;
thus L472: thesis by L453 , L248;
end;
registration
let C82 being Integer;
let C83 being Int_position;
let C84 being (Element of ( NAT ));
cluster ( Load ( (C83 , C82) >=0_goto C84 ) ) ->  shiftable for (Program of ( SCMPDS ));
coherence
proof
set D63 = C84;
set D64 = ( (C83 , C82) >=0_goto D63 );
set D65 = ( Load D64 );
L473:
now
let R3 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
assume that
L474: R3 in ( dom D65 )
and
L475: R4 = ( D65 . R3 );
L476: ( dom D65 ) = { ( 0 ) } by FUNCOP_1:13;
L477: R3 = ( 0 ) by L476 , L474 , TARSKI:def 1;
L478: D64 = R4 by L477 , L475 , FUNCOP_1:72;
thus L479: (( InsCode R4 ) <> 1 & ( InsCode R4 ) <> 3) by L478 , SCMPDS_2:18;
L480: (( R3 + D63 ) >= ( 0 ) & ( InsCode R4 ) <> 5 & ( InsCode R4 ) <> 14) by L478 , SCMPDS_2:18;
L481: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 4) by L478 , SCMPDS_2:18;
thus L482: R4 valid_at R3 by L481 , L478 , L480 , L246;
end;
thus L483: thesis by L473 , L248;
end;
end;
theorem
L485: (for B51 , B52 being (State of ( SCMPDS )) holds (for B53 , B54 being (Element of ( NAT )) holds (for B55 being Integer holds ((( IC B51 ) = B54 & ( B54 + B55 ) >= ( 0 ) & ( ( IC B51 ) + B53 ) = ( IC B52 )) implies ( ( ICplusConst (B51 , B55) ) + B53 ) = ( ICplusConst (B52 , B55) )))))
proof
let C85 , C86 being (State of ( SCMPDS ));
let C87 , C88 being (Element of ( NAT ));
let C89 being Integer;
assume that
L486: ( IC C85 ) = C88
and
L487: ( C88 + C89 ) >= ( 0 )
and
L488: ( ( IC C85 ) + C87 ) = ( IC C86 );
reconsider D66 = ( ICplusConst (C85 , C89) ) as (Element of ( NAT ));
reconsider D67 = ( C88 + C89 ) as (Element of ( NAT )) by L487 , INT_1:3;
L489: (ex B56 being (Element of ( NAT )) st (B56 = ( IC C85 ) & ( ICplusConst (C85 , C89) ) = ( abs ( B56 + C89 ) ))) by SCMPDS_2:def 18;
L490: ((ex B57 being (Element of ( NAT )) st (B57 = ( IC C86 ) & ( ICplusConst (C86 , C89) ) = ( abs ( B57 + C89 ) ))) & D66 = D67) by L489 , L486 , ABSVALUE:def 1 , SCMPDS_2:def 18;
thus L491: thesis by L490 , L486 , L488 , ABSVALUE:def 1;
end;
theorem
L492: (for B58 , B59 being (State of ( SCMPDS )) holds (for B60 , B61 being (Element of ( NAT )) holds (for B62 being (Instruction of ( SCMPDS )) holds ((( IC B58 ) = B61 & B62 valid_at B61 & ( InsCode B62 ) <> 1 & ( InsCode B62 ) <> 3 & ( ( IC B58 ) + B60 ) = ( IC B59 ) & ( DataPart B58 ) = ( DataPart B59 )) implies (( ( IC ( Exec (B62 , B58) ) ) + B60 ) = ( IC ( Exec (B62 , B59) ) ) & ( DataPart ( Exec (B62 , B58) ) ) = ( DataPart ( Exec (B62 , B59) ) ))))))
proof
let C90 , C91 being (State of ( SCMPDS ));
let C92 , C93 being (Element of ( NAT ));
let C94 being (Instruction of ( SCMPDS ));
assume that
L493: ( IC C90 ) = C93
and
L494: C94 valid_at C93
and
L495: (( InsCode C94 ) <> 1 & ( InsCode C94 ) <> 3)
and
L496: ( ( IC C90 ) + C92 ) = ( IC C91 )
and
L497: ( DataPart C90 ) = ( DataPart C91 );
L498:
now
let R13 being Int_position;
let R19 being Integer;
thus L499: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) = ( C90 . ( DataLoc (( C91 . R13 ) , R19) ) ) by L497 , L111
.= ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) by L497 , L111;
end;
reconsider D68 = ( IC C90 ) as (Element of ( NAT ));
set D69 = ( InsCode C94 );
L500: ( ( succ ( IC C90 ) ) + C92 ) = ( succ ( IC C91 ) ) by L496;
L501:
now
assume L502: (D69 <> ( 0 ) & D69 <> 14 & D69 <> 1 & D69 <> 4 & D69 <> 5 & D69 <> 6);
L503: (not D69 in { ( 0 ) , 1 , 4 , 5 , 6 , 14 }) by L502 , ENUMSET1:def 4;
L504: ( IC ( Exec (C94 , C90) ) ) = ( succ ( IC C90 ) ) by L503 , L1;
thus L505: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L504 , L500 , L503 , L1;
end;
per cases  by L495 , NAT_1:60 , SCMPDS_2:6;
suppose L506: D69 = ( 0 );

L507: (( Exec (C94 , C90) ) = C90 & ( Exec (C94 , C91) ) = C91) by L506 , SCMPDS_2:86;
thus L508: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L507 , L496;
thus L509: ( DataPart ( Exec (C94 , C90) ) ) = ( DataPart ( Exec (C94 , C91) ) ) by L497 , L507;
end;
suppose L510: D69 = 14;

consider R19 being Integer such that L511: C94 = ( goto R19 ) and L512: ( C93 + R19 ) >= ( 0 ) by L510 , L494 , L246;
L513: ( IC ( Exec (C94 , C90) ) ) = ( ICplusConst (C90 , R19) ) by L511 , SCMPDS_2:54;
thus L514: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( ICplusConst (C91 , R19) ) by L513 , L493 , L496 , L512 , L485
.= ( IC ( Exec (C94 , C91) ) ) by L511 , SCMPDS_2:54;
L515:
now
let R13 being Int_position;
thus L516: ( ( Exec (C94 , C90) ) . R13 ) = ( C90 . R13 ) by L511 , SCMPDS_2:54
.= ( C91 . R13 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R13 ) by L511 , SCMPDS_2:54;
end;
thus L517: thesis by L515 , L111;
end;
suppose L518: D69 = 2;

thus L519: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L518 , L501;
consider R13 being Int_position, R19 being Integer such that L520: C94 = ( R13 := R19 ) by L518 , SCMPDS_2:28;
L521:
now
let R14 being Int_position;
per cases ;
suppose L522: R13 = R14;

thus L523: ( ( Exec (C94 , C90) ) . R14 ) = R19 by L522 , L520 , SCMPDS_2:45
.= ( ( Exec (C94 , C91) ) . R14 ) by L520 , L522 , SCMPDS_2:45;
end;
suppose L524: R13 <> R14;

thus L525: ( ( Exec (C94 , C90) ) . R14 ) = ( C90 . R14 ) by L524 , L520 , SCMPDS_2:45
.= ( C91 . R14 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R14 ) by L520 , L524 , SCMPDS_2:45;
end;
end;
thus L527: thesis by L521 , L111;
end;
suppose L528: D69 = 4;

consider R13 being Int_position, R19 being Integer, R20 being Integer such that L529: C94 = ( (R13 , R19) <>0_goto R20 ) and L530: ( C93 + R20 ) >= ( 0 ) by L528 , L494 , L246;
thus L531:now
per cases ;
suppose L532: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) <> ( 0 );

L533: ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) <> ( 0 ) by L532 , L498;
L534: ( IC ( Exec (C94 , C90) ) ) = ( ICplusConst (C90 , R20) ) by L529 , L532 , SCMPDS_2:55;
thus L535: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( ICplusConst (C91 , R20) ) by L534 , L493 , L496 , L530 , L485
.= ( IC ( Exec (C94 , C91) ) ) by L529 , L533 , SCMPDS_2:55;
end;
suppose L536: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) = ( 0 );

L537: (( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) = ( 0 ) & ( IC ( Exec (C94 , C90) ) ) = ( succ ( IC C90 ) )) by L536 , L498 , L529 , SCMPDS_2:55;
thus L538: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L537 , L500 , L529 , SCMPDS_2:55;
end;
end;
L540:
now
let R13 being Int_position;
thus L541: ( ( Exec (C94 , C90) ) . R13 ) = ( C90 . R13 ) by L529 , SCMPDS_2:55
.= ( C91 . R13 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R13 ) by L529 , SCMPDS_2:55;
end;
thus L542: thesis by L540 , L111;
end;
suppose L543: D69 = 5;

consider R13 being Int_position, R19 being Integer, R20 being Integer such that L544: C94 = ( (R13 , R19) <=0_goto R20 ) and L545: ( C93 + R20 ) >= ( 0 ) by L543 , L494 , L246;
thus L546:now
per cases ;
suppose L547: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) <= ( 0 );

L548: ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) <= ( 0 ) by L547 , L498;
L549: ( IC ( Exec (C94 , C90) ) ) = ( ICplusConst (C90 , R20) ) by L544 , L547 , SCMPDS_2:56;
thus L550: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( ICplusConst (C91 , R20) ) by L549 , L493 , L496 , L545 , L485
.= ( IC ( Exec (C94 , C91) ) ) by L544 , L548 , SCMPDS_2:56;
end;
suppose L551: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) > ( 0 );

L552: (( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) > ( 0 ) & ( IC ( Exec (C94 , C90) ) ) = ( succ ( IC C90 ) )) by L551 , L498 , L544 , SCMPDS_2:56;
thus L553: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L552 , L500 , L544 , SCMPDS_2:56;
end;
end;
L555:
now
let R13 being Int_position;
thus L556: ( ( Exec (C94 , C90) ) . R13 ) = ( C90 . R13 ) by L544 , SCMPDS_2:56
.= ( C91 . R13 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R13 ) by L544 , SCMPDS_2:56;
end;
thus L557: thesis by L555 , L111;
end;
suppose L558: D69 = 6;

consider R13 being Int_position, R19 being Integer, R20 being Integer such that L559: C94 = ( (R13 , R19) >=0_goto R20 ) and L560: ( C93 + R20 ) >= ( 0 ) by L558 , L494 , L246;
thus L561:now
per cases ;
suppose L562: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) >= ( 0 );

L563: ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) >= ( 0 ) by L562 , L498;
L564: ( IC ( Exec (C94 , C90) ) ) = ( ICplusConst (C90 , R20) ) by L559 , L562 , SCMPDS_2:57;
thus L565: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( ICplusConst (C91 , R20) ) by L564 , L493 , L496 , L560 , L485
.= ( IC ( Exec (C94 , C91) ) ) by L559 , L563 , SCMPDS_2:57;
end;
suppose L566: ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) < ( 0 );

L567: (( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) < ( 0 ) & ( IC ( Exec (C94 , C90) ) ) = ( succ ( IC C90 ) )) by L566 , L498 , L559 , SCMPDS_2:57;
thus L568: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L567 , L500 , L559 , SCMPDS_2:57;
end;
end;
L570:
now
let R13 being Int_position;
thus L571: ( ( Exec (C94 , C90) ) . R13 ) = ( C90 . R13 ) by L559 , SCMPDS_2:57
.= ( C91 . R13 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R13 ) by L559 , SCMPDS_2:57;
end;
thus L572: thesis by L570 , L111;
end;
suppose L573: D69 = 7;

thus L574: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L573 , L501;
consider R13 being Int_position, R19 being Integer, R20 being Integer such that L575: C94 = ( (R13 , R19) := R20 ) by L573 , SCMPDS_2:33;
L576:
now
let R14 being Int_position;
per cases ;
suppose L577: ( DataLoc (( C90 . R13 ) , R19) ) = R14;

L578: ( DataLoc (( C91 . R13 ) , R19) ) = R14 by L577 , L497 , L111;
thus L579: ( ( Exec (C94 , C90) ) . R14 ) = R20 by L575 , L577 , SCMPDS_2:46
.= ( ( Exec (C94 , C91) ) . R14 ) by L575 , L578 , SCMPDS_2:46;
end;
suppose L580: ( DataLoc (( C90 . R13 ) , R19) ) <> R14;

L581: ( DataLoc (( C91 . R13 ) , R19) ) <> R14 by L580 , L497 , L111;
thus L582: ( ( Exec (C94 , C90) ) . R14 ) = ( C90 . R14 ) by L575 , L580 , SCMPDS_2:46
.= ( C91 . R14 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R14 ) by L575 , L581 , SCMPDS_2:46;
end;
end;
thus L584: thesis by L576 , L111;
end;
suppose L585: D69 = 8;

thus L586: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L585 , L501;
consider R13 being Int_position, R19 being Integer, R20 being Integer such that L587: C94 = ( AddTo (R13 , R19 , R20) ) by L585 , SCMPDS_2:34;
L588:
now
let R14 being Int_position;
per cases ;
suppose L589: ( DataLoc (( C90 . R13 ) , R19) ) = R14;

L590: ( DataLoc (( C91 . R13 ) , R19) ) = R14 by L589 , L497 , L111;
thus L591: ( ( Exec (C94 , C90) ) . R14 ) = ( ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) + R20 ) by L587 , L589 , SCMPDS_2:48
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) + R20 ) by L498
.= ( ( Exec (C94 , C91) ) . R14 ) by L587 , L590 , SCMPDS_2:48;
end;
suppose L592: ( DataLoc (( C90 . R13 ) , R19) ) <> R14;

L593: ( DataLoc (( C91 . R13 ) , R19) ) <> R14 by L592 , L497 , L111;
thus L594: ( ( Exec (C94 , C90) ) . R14 ) = ( C90 . R14 ) by L587 , L592 , SCMPDS_2:48
.= ( C91 . R14 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R14 ) by L587 , L593 , SCMPDS_2:48;
end;
end;
thus L596: thesis by L588 , L111;
end;
suppose L597: D69 = 9;

thus L598: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L597 , L501;
consider R13 being Int_position, R14 being Int_position, R19 being Integer, R20 being Integer such that L599: C94 = ( AddTo (R13 , R19 , R14 , R20) ) by L597 , SCMPDS_2:35;
L600:
now
let R15 being Int_position;
per cases ;
suppose L601: ( DataLoc (( C90 . R13 ) , R19) ) = R15;

L602: ( DataLoc (( C91 . R13 ) , R19) ) = R15 by L601 , L497 , L111;
thus L603: ( ( Exec (C94 , C90) ) . R15 ) = ( ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) + ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L599 , L601 , SCMPDS_2:49
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) + ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L498
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) + ( C91 . ( DataLoc (( C91 . R14 ) , R20) ) ) ) by L498
.= ( ( Exec (C94 , C91) ) . R15 ) by L599 , L602 , SCMPDS_2:49;
end;
suppose L604: ( DataLoc (( C90 . R13 ) , R19) ) <> R15;

L605: ( DataLoc (( C91 . R13 ) , R19) ) <> R15 by L604 , L497 , L111;
thus L606: ( ( Exec (C94 , C90) ) . R15 ) = ( C90 . R15 ) by L599 , L604 , SCMPDS_2:49
.= ( C91 . R15 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R15 ) by L599 , L605 , SCMPDS_2:49;
end;
end;
thus L608: thesis by L600 , L111;
end;
suppose L609: D69 = 10;

thus L610: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L609 , L501;
consider R13 being Int_position, R14 being Int_position, R19 being Integer, R20 being Integer such that L611: C94 = ( SubFrom (R13 , R19 , R14 , R20) ) by L609 , SCMPDS_2:36;
L612:
now
let R15 being Int_position;
per cases ;
suppose L613: ( DataLoc (( C90 . R13 ) , R19) ) = R15;

L614: ( DataLoc (( C91 . R13 ) , R19) ) = R15 by L613 , L497 , L111;
thus L615: ( ( Exec (C94 , C90) ) . R15 ) = ( ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) - ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L611 , L613 , SCMPDS_2:50
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) - ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L498
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) - ( C91 . ( DataLoc (( C91 . R14 ) , R20) ) ) ) by L498
.= ( ( Exec (C94 , C91) ) . R15 ) by L611 , L614 , SCMPDS_2:50;
end;
suppose L616: ( DataLoc (( C90 . R13 ) , R19) ) <> R15;

L617: ( DataLoc (( C91 . R13 ) , R19) ) <> R15 by L616 , L497 , L111;
thus L618: ( ( Exec (C94 , C90) ) . R15 ) = ( C90 . R15 ) by L611 , L616 , SCMPDS_2:50
.= ( C91 . R15 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R15 ) by L611 , L617 , SCMPDS_2:50;
end;
end;
thus L620: thesis by L612 , L111;
end;
suppose L621: D69 = 11;

thus L622: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L621 , L501;
consider R13 being Int_position, R14 being Int_position, R19 being Integer, R20 being Integer such that L623: C94 = ( MultBy (R13 , R19 , R14 , R20) ) by L621 , SCMPDS_2:37;
L624:
now
let R15 being Int_position;
per cases ;
suppose L625: ( DataLoc (( C90 . R13 ) , R19) ) = R15;

L626: ( DataLoc (( C91 . R13 ) , R19) ) = R15 by L625 , L497 , L111;
thus L627: ( ( Exec (C94 , C90) ) . R15 ) = ( ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) * ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L623 , L625 , SCMPDS_2:51
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) * ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L498
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) * ( C91 . ( DataLoc (( C91 . R14 ) , R20) ) ) ) by L498
.= ( ( Exec (C94 , C91) ) . R15 ) by L623 , L626 , SCMPDS_2:51;
end;
suppose L628: ( DataLoc (( C90 . R13 ) , R19) ) <> R15;

L629: ( DataLoc (( C91 . R13 ) , R19) ) <> R15 by L628 , L497 , L111;
thus L630: ( ( Exec (C94 , C90) ) . R15 ) = ( C90 . R15 ) by L623 , L628 , SCMPDS_2:51
.= ( C91 . R15 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R15 ) by L623 , L629 , SCMPDS_2:51;
end;
end;
thus L632: thesis by L624 , L111;
end;
suppose L633: D69 = 12;

thus L634: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L633 , L501;
consider R13 being Int_position, R14 being Int_position, R19 being Integer, R20 being Integer such that L635: C94 = ( Divide (R13 , R19 , R14 , R20) ) by L633 , SCMPDS_2:38;
L636:
now
let R15 being Int_position;
per cases ;
suppose L637: ( DataLoc (( C90 . R14 ) , R20) ) = R15;

L638: ( DataLoc (( C91 . R14 ) , R20) ) = R15 by L637 , L497 , L111;
thus L639: ( ( Exec (C94 , C90) ) . R15 ) = ( ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) mod ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L635 , L637 , SCMPDS_2:52
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) mod ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L498
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) mod ( C91 . ( DataLoc (( C91 . R14 ) , R20) ) ) ) by L498
.= ( ( Exec (C94 , C91) ) . R15 ) by L635 , L638 , SCMPDS_2:52;
end;
suppose L640: ( DataLoc (( C90 . R14 ) , R20) ) <> R15;

L641: ( DataLoc (( C91 . R14 ) , R20) ) <> R15 by L640 , L497 , L111;
thus L642:now
per cases ;
suppose L643: ( DataLoc (( C90 . R13 ) , R19) ) <> R15;

L644: ( DataLoc (( C91 . R13 ) , R19) ) <> R15 by L643 , L497 , L111;
thus L645: ( ( Exec (C94 , C90) ) . R15 ) = ( C90 . R15 ) by L635 , L640 , L643 , SCMPDS_2:52
.= ( C91 . R15 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R15 ) by L635 , L641 , L644 , SCMPDS_2:52;
end;
suppose L646: ( DataLoc (( C90 . R13 ) , R19) ) = R15;

L647: ( DataLoc (( C91 . R13 ) , R19) ) = R15 by L646 , L497 , L111;
thus L648: ( ( Exec (C94 , C90) ) . R15 ) = ( ( C90 . ( DataLoc (( C90 . R13 ) , R19) ) ) div ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L635 , L640 , L646 , SCMPDS_2:52
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) div ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) ) by L498
.= ( ( C91 . ( DataLoc (( C91 . R13 ) , R19) ) ) div ( C91 . ( DataLoc (( C91 . R14 ) , R20) ) ) ) by L498
.= ( ( Exec (C94 , C91) ) . R15 ) by L635 , L641 , L647 , SCMPDS_2:52;
end;
end;
end;
end;
thus L644: thesis by L636 , L111;
end;
suppose L645: D69 = 13;

thus L646: ( ( IC ( Exec (C94 , C90) ) ) + C92 ) = ( IC ( Exec (C94 , C91) ) ) by L645 , L501;
consider R13 being Int_position, R14 being Int_position, R19 being Integer, R20 being Integer such that L647: C94 = ( (R13 , R19) := (R14 , R20) ) by L645 , SCMPDS_2:39;
L648:
now
let R15 being Int_position;
per cases ;
suppose L649: ( DataLoc (( C90 . R13 ) , R19) ) = R15;

L650: ( DataLoc (( C91 . R13 ) , R19) ) = R15 by L649 , L497 , L111;
thus L651: ( ( Exec (C94 , C90) ) . R15 ) = ( C90 . ( DataLoc (( C90 . R14 ) , R20) ) ) by L647 , L649 , SCMPDS_2:47
.= ( C91 . ( DataLoc (( C91 . R14 ) , R20) ) ) by L498
.= ( ( Exec (C94 , C91) ) . R15 ) by L647 , L650 , SCMPDS_2:47;
end;
suppose L652: ( DataLoc (( C90 . R13 ) , R19) ) <> R15;

L653: ( DataLoc (( C91 . R13 ) , R19) ) <> R15 by L652 , L497 , L111;
thus L654: ( ( Exec (C94 , C90) ) . R15 ) = ( C90 . R15 ) by L647 , L652 , SCMPDS_2:47
.= ( C91 . R15 ) by L497 , L111
.= ( ( Exec (C94 , C91) ) . R15 ) by L647 , L653 , SCMPDS_2:47;
end;
end;
thus L656: thesis by L648 , L111;
end;
end;
theorem
L658: (for R18 being (State of ( SCMPDS )) holds (for B63 , B64 being (Instruction-Sequence of ( SCMPDS )) holds (for B65 being ( 0 ) -started (State of ( SCMPDS )) holds (for B66 being  parahalting  shiftable (Program of ( SCMPDS )) holds (( stop B66 ) c= B63 implies (for B67 being (Element of ( NAT )) holds ((( Shift (( stop B66 ) , B67) ) c= B64 & ( IC R18 ) = B67 & ( DataPart B65 ) = ( DataPart R18 )) implies (for B68 being (Element of ( NAT )) holds (( ( IC ( Comput (B63 , B65 , B68) ) ) + B67 ) = ( IC ( Comput (B64 , R18 , B68) ) ) & ( CurInstr (B63 , ( Comput (B63 , B65 , B68) )) ) = ( CurInstr (B64 , ( Comput (B64 , R18 , B68) )) ) & ( DataPart ( Comput (B63 , B65 , B68) ) ) = ( DataPart ( Comput (B64 , R18 , B68) ) ))))))))))
proof
let R18 being (State of ( SCMPDS ));
let C95 , C96 being (Instruction-Sequence of ( SCMPDS ));
let C97 being ( 0 ) -started (State of ( SCMPDS ));
let C98 being  parahalting  shiftable (Program of ( SCMPDS ));
set D70 = ( stop C98 );
assume L659: D70 c= C95;
let C99 being (Element of ( NAT ));
assume that
L660: ( Shift (D70 , C99) ) c= C96
and
L661: ( IC R18 ) = C99
and
L662: ( DataPart C97 ) = ( DataPart R18 );
L663: ( 0 ) in ( dom D70 ) by COMPOS_1:36;
L664: ( ( 0 ) + C99 ) in ( dom ( Shift (D70 , C99) ) ) by L663 , VALUED_1:24;
defpred S5[ Nat ] means (( ( IC ( Comput (C95 , C97 , $1) ) ) + C99 ) = ( IC ( Comput (C96 , R18 , $1) ) ) & ( CurInstr (C95 , ( Comput (C95 , C97 , $1) )) ) = ( CurInstr (C96 , ( Comput (C96 , R18 , $1) )) ) & ( DataPart ( Comput (C95 , C97 , $1) ) ) = ( DataPart ( Comput (C96 , R18 , $1) ) ));
L665: (for B69 being (Element of ( NAT )) holds (S5[ B69 ] implies S5[ ( B69 + 1 ) ]))
proof
let C100 being (Element of ( NAT ));
assume L666: S5[ C100 ];
reconsider D71 = ( IC ( Comput (C95 , C97 , C100) ) ) as (Element of ( NAT ));
set D72 = ( CurInstr (C95 , ( Comput (C95 , C97 , C100) )) );
L667: ( Comput (C95 , C97 , ( C100 + 1 )) ) = ( Following (C95 , ( Comput (C95 , C97 , C100) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C95 , ( Comput (C95 , C97 , C100) )) ) , ( Comput (C95 , C97 , C100) )) );
reconsider D73 = ( IC ( Comput (C95 , C97 , ( C100 + 1 )) ) ) as (Element of ( NAT ));
L668: ( IC ( Comput (C95 , C97 , ( C100 + 1 )) ) ) in ( dom D70 ) by L659 , L159;
L669: ( D73 + C99 ) in ( dom ( Shift (D70 , C99) ) ) by L668 , VALUED_1:24;
L670: ( Comput (C96 , R18 , ( C100 + 1 )) ) = ( Following (C96 , ( Comput (C96 , R18 , C100) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C96 , ( Comput (C96 , R18 , C100) )) ) , ( Comput (C96 , R18 , C100) )) );
L671: ( IC ( Comput (C95 , C97 , C100) ) ) in ( dom D70 ) by L659 , L159;
L672: D72 = ( C95 . ( IC ( Comput (C95 , C97 , C100) ) ) ) by PBOOLE:143
.= ( D70 . ( IC ( Comput (C95 , C97 , C100) ) ) ) by L659 , L671 , GRFUNC_1:2;
L673: (( InsCode D72 ) <> 1 & ( InsCode D72 ) <> 3) by L672 , L671 , L248;
L674: D72 valid_at D71 by L671 , L672 , L248;
thus L675: ( ( IC ( Comput (C95 , C97 , ( C100 + 1 )) ) ) + C99 ) = ( IC ( Comput (C96 , R18 , ( C100 + 1 )) ) ) by L674 , L666 , L667 , L670 , L673 , L492;
L676: ( CurInstr (C95 , ( Comput (C95 , C97 , ( C100 + 1 )) )) ) = ( C95 . D73 ) by PBOOLE:143
.= ( D70 . D73 ) by L659 , L668 , GRFUNC_1:2;
thus L677: ( CurInstr (C95 , ( Comput (C95 , C97 , ( C100 + 1 )) )) ) = ( ( Shift (D70 , C99) ) . ( IC ( Comput (C96 , R18 , ( C100 + 1 )) ) ) ) by L676 , L675 , L668 , VALUED_1:def 12
.= ( C96 . ( IC ( Comput (C96 , R18 , ( C100 + 1 )) ) ) ) by L660 , L675 , L669 , GRFUNC_1:2
.= ( CurInstr (C96 , ( Comput (C96 , R18 , ( C100 + 1 )) )) ) by PBOOLE:143;
thus L678: thesis by L666 , L667 , L670 , L673 , L674 , L492;
end;
L679: ( C95 . ( IC C97 ) ) = ( C95 . ( 0 ) ) by MEMSTR_0:def 11
.= ( D70 . ( 0 ) ) by L659 , L663 , GRFUNC_1:2;
let C101 being (Element of ( NAT ));
L680: ( DataPart ( Comput (C95 , C97 , ( 0 )) ) ) = ( DataPart R18 ) by L662
.= ( DataPart ( Comput (C96 , R18 , ( 0 )) ) );
L681: ( IC ( Comput (C95 , C97 , ( 0 )) ) ) = ( IC C97 )
.= ( 0 ) by MEMSTR_0:def 11;
L682: ( C96 /. ( IC R18 ) ) = ( C96 . ( IC R18 ) ) by PBOOLE:143;
L683: ( C95 /. ( IC C97 ) ) = ( C95 . ( IC C97 ) ) by PBOOLE:143;
L684: ( CurInstr (C95 , ( Comput (C95 , C97 , ( 0 )) )) ) = ( ( Shift (D70 , C99) ) . ( ( 0 ) + C99 ) ) by L663 , L679 , L683 , VALUED_1:def 12
.= ( CurInstr (C96 , ( Comput (C96 , R18 , ( 0 )) )) ) by L660 , L661 , L664 , L682 , GRFUNC_1:2;
L685: S5[ ( 0 ) ] by L684 , L661 , L681 , L680;
L686: (for B70 being (Element of ( NAT )) holds S5[ B70 ]) from NAT_1:sch 1(L685 , L665);
thus L687: thesis by L686;
end;
