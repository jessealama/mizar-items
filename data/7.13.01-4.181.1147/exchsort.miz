:: Sorting by Exchanging
::  by Grzegorz Bancerek
::
:: Received October 18, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ORDINAL6, EXCHSORT, ZFMISC_1, XBOOLE_0, RELAT_1, FUNCT_1,
      ORDINAL1, ORDINAL2, ORDINAL4, FINSET_1, RELAT_2, FUNCT_4, FINSEQ_1,
      AOFA_000, FUNCT_3, VALUED_0, WELLFND1, CARD_1, TARSKI, FUNCT_2, PARTFUN1,
      FUNCT_7, REARRAN1, ORDINAL3, XREAL_0, NAT_1, SUBSET_1, XXREAL_0, ARYTM_3,
      AFINSQ_1, REWRITE1, NUMBERS, MSUALG_1, MEMBERED, STRUCT_0, ORDERS_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, RELAT_1, RELAT_2, RELSET_1,
      FUNCT_1, PARTFUN1, FUNCT_2, FINSET_1, FINSEQ_1, BINOP_1, FUNCT_4,
      FUNCT_7, NUMBERS, MEMBERED, VALUED_0, ORDINAL1, CARD_1, ORDINAL2,
      ORDINAL3, ORDINAL4, AFINSQ_1, STRUCT_0, ORDERS_2, WAYBEL_0, XXREAL_0,
      XREAL_0, NAT_1, AOFA_000, ORDINAL5, FUNCT_3, ORDINAL6;
 constructors MEMBERED, VALUED_0, CATALAN2, ORDINAL3, INT_1, FUNCT_7, ORDINAL5,
      WELLORD2, RELAT_2, FACIRC_1, BINOP_1, WAYBEL_0, RELSET_1, ORDINAL6,
      XTUPLE_0;
 registrations MEMBERED, SUBSET_1, RELSET_1, NAT_1, XXREAL_0, XBOOLE_0,
      FINSET_1, RELAT_1, FUNCT_1, ORDINAL1, STIRL2_1, VALUED_0, ORDINAL5,
      AFINSQ_1, CARD_1, FUNCT_2, FUNCT_7, FUNCTOR1, STRUCT_0, WAYBEL_0,
      ORDINAL6, XTUPLE_0;
 requirements NUMERALS, SUBSET, BOOLE, REAL;
 definitions TARSKI, XBOOLE_0, RELAT_1, RELAT_2, PARTFUN1, FUNCT_2, ORDINAL1,
      ORDINAL2, WELLORD2, FUNCT_1, VALUED_0, BINOP_1, ORDINAL5, ORDINAL6,
      XTUPLE_0;
 theorems TARSKI, CARD_1, ZFMISC_1, ORDINAL1, ORDINAL2, RELAT_1, RELSET_1,
      MEMBERED, FINSET_1, CARD_2, VALUED_0, TREES_1, GRFUNC_1, FUNCT_2,
      XBOOLE_1, FINSEQ_3, NAT_1, XBOOLE_0, ORDINAL3, XXREAL_0, SETFAM_1,
      ORDINAL4, FUNCT_1, FUNCT_7, SUBSET_1, FUNCT_3, FUNCT_4, FUNCT_5,
      AFINSQ_1, WELLORD2, PARTFUN1, ORDERS_2, YELLOW_0, WAYBEL_0, ORDINAL6,
      XTUPLE_0;
 schemes NAT_1, ORDINAL2, RECDEF_1;

begin
theorem
L1: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (for R10 being set holds (R10 in ( ( R1 +^ R4 ) \ R1 ) iff (ex R5 being  ordinal number st (R10 = ( R1 +^ R5 ) & R5 in R4))))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
let R10 being set;
L2: (R10 in ( ( R1 +^ R4 ) \ R1 ) iff (R1 c= R10 & R10 in ( R1 +^ R4 ))) by ORDINAL6:5;
thus L3:now
assume L4: R10 in ( ( R1 +^ R4 ) \ R1 );
reconsider D1 = R10 as Ordinal by L4;
take D2 = ( D1 -^ R1 );
thus L5: R10 = ( R1 +^ D2 ) by L2 , L4 , ORDINAL3:def 5;
thus L6: D2 in R4 by L5 , L4 , ORDINAL3:22;
end;
given R5 being  ordinal number such that
L7: (R10 = ( R1 +^ R5 ) & R5 in R4);

L8: (R1 c= R10 & R10 in ( R1 +^ R4 )) by L7 , ORDINAL2:32 , ORDINAL3:24;
thus L9: thesis by L8 , ORDINAL6:5;
end;
defpred S1[ set , set , set , set ] means ($3 <> $1 & $3 <> $2 & $4 <> $1 & $4 <> $2);
defpred S2[ set , set , set , set ] means ($3 in $1 & $4 = $1);
defpred S3[ set , set , set , set ] means ($3 in $1 & $4 = $2);
defpred S4[ set , set , set , set ] means ($3 = $1 & $4 in $2);
defpred S5[ set , set , set , set ] means ($3 = $1 & $4 = $2);
defpred S6[ set , set , set , set ] means ($3 = $1 & $2 in $4);
defpred S7[ set , set , set , set ] means ($1 in $3 & $4 = $2);
defpred S8[ set , set , set , set ] means ($3 = $2 & $2 in $4);
theorem
L10: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (for R5 being  ordinal number holds (for R6 being  ordinal number holds ((R1 in R4 & R5 in R6) implies ((R5 <> R1 & R5 <> R4 & R6 <> R1 & R6 <> R4) or (R5 in R1 & R6 = R1) or (R5 in R1 & R6 = R4) or (R5 = R1 & R6 in R4) or (R5 = R1 & R6 = R4) or (R5 = R1 & R4 in R6) or (R1 in R5 & R6 = R4) or (R5 = R4 & R4 in R6)))))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
let R5 being  ordinal number;
let R6 being  ordinal number;
assume L11: (R1 in R4 & R5 in R6);
per cases  by ORDINAL1:14;
suppose L12: R5 in R1;

thus L13: thesis by L12 , L11;
end;
suppose L14: R5 = R1;

thus L15: thesis by L14 , ORDINAL1:14;
end;
suppose L16: (R1 in R5 & R5 in R4);

per cases  by ORDINAL1:14;
suppose L17: R6 in R4;

thus L18: thesis by L17 , L11;
end;
suppose L19: R6 = R4;

thus L20: thesis by L19 , L16;
end;
suppose L21: R4 in R6;

thus L22: thesis by L21 , L11;
end;
end;
suppose L24: R5 = R4;

thus L25: thesis by L24 , L11;
end;
suppose L26: R4 in R5;

thus L27: thesis by L26 , L11;
end;
end;
theorem
L29: (for R10 being set holds (for R11 being set holds (R10 nin R11 implies ( ( R11 \/ { R10 } ) \ R11 ) = { R10 }))) by XBOOLE_1:88 , ZFMISC_1:50;
theorem
L30: (for R10 being set holds ( ( succ R10 ) \ R10 ) = { R10 })
proof
let R10 being set;
L31: (( succ R10 ) = ( R10 \/ { R10 } ) & R10 nin R10);
thus L32: thesis by L31 , XBOOLE_1:88 , ZFMISC_1:50;
end;
theorem
L33: (for B1 being Function holds (for B2 being Relation holds (for R10 being set holds (R10 in ( B1 .: B2 ) iff (ex R11 being set st (ex R12 being set st ([ R11 , R12 ] in B2 & [ R11 , R12 ] in ( dom B1 ) & ( B1 . (R11 , R12) ) = R10)))))))
proof
let C1 being Function;
let C2 being Relation;
let R10 being set;
thus L34:now
assume L35: R10 in ( C1 .: C2 );
consider R13 being set such that L36: (R13 in ( dom C1 ) & R13 in C2 & R10 = ( C1 . R13 )) by L35 , FUNCT_1:def 6;
consider R11 being set, R12 being set such that L37: R13 = [ R11 , R12 ] by L36 , RELAT_1:def 1;
L38: ( C1 . (R11 , R12) ) = ( C1 . [ R11 , R12 ] );
thus L39: (ex R11 being set st (ex R12 being set st ([ R11 , R12 ] in C2 & [ R11 , R12 ] in ( dom C1 ) & ( C1 . (R11 , R12) ) = R10))) by L38 , L36 , L37;
end;
thus L40: thesis by FUNCT_1:def 6;
end;
theorem
L41: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (( R1 \ R4 ) <> ( {} ) implies (( inf ( R1 \ R4 ) ) = R4 & ( sup ( R1 \ R4 ) ) = R1 & ( union ( R1 \ R4 ) ) = ( union R1 )))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
assume L42: ( R1 \ R4 ) <> ( {} );
set D3 = the (Element of ( R1 \ R4 ));
L43: D3 in ( R1 \ R4 ) by L42;
L44: (D3 in R1 & D3 nin R4) by L42 , XBOOLE_0:def 5;
L45: R4 c= D3 by L44 , ORDINAL6:4;
L46: (R4 in R1 & R4 nin R4) by L45 , L44 , ORDINAL1:12;
L47: R4 in ( R1 \ R4 ) by L46 , XBOOLE_0:def 5;
thus L48: ( inf ( R1 \ R4 ) ) c= R4 by L47 , ORDINAL2:14;
L49: ( inf ( R1 \ R4 ) ) in ( R1 \ R4 ) by L43 , ORDINAL2:17;
L50: ( inf ( R1 \ R4 ) ) nin R4 by L49 , XBOOLE_0:def 5;
thus L51: R4 c= ( inf ( R1 \ R4 ) ) by L50 , ORDINAL6:4;
L52: ( On ( R1 \ R4 ) ) = ( R1 \ R4 ) by ORDINAL6:2;
thus L53: ( sup ( R1 \ R4 ) ) c= R1 by L52 , ORDINAL2:def 3;
thus L54: R1 c= ( sup ( R1 \ R4 ) )
proof
let R5 being  ordinal number;
assume L55: R5 in R1;
L56: R4 in ( sup ( R1 \ R4 ) ) by L47 , ORDINAL2:19;
per cases ;
suppose L57: R5 in R4;

thus L58: thesis by L57 , L56 , ORDINAL1:10;
end;
suppose L59: R5 nin R4;

L60: R5 in ( R1 \ R4 ) by L59 , L55 , XBOOLE_0:def 5;
thus L61: thesis by L60 , ORDINAL2:19;
end;
end;

thus L63: ( union ( R1 \ R4 ) ) c= ( union R1 ) by ZFMISC_1:77;
L64: (for B3 being set holds (B3 in ( union R1 ) implies B3 in ( union ( R1 \ R4 ) )))
proof
let C3 being set;
assume L65: C3 in ( union R1 );
consider R10 being set such that L66: (C3 in R10 & R10 in R1) by L65 , TARSKI:def 4;
reconsider D4 = R10 as Ordinal by L66;
per cases  by ORDINAL6:4;
suppose L67: D4 in R4;

L68: C3 in R4 by L67 , L66 , ORDINAL1:10;
thus L69: thesis by L68 , L47 , TARSKI:def 4;
end;
suppose L70: R4 c= D4;

L71: D4 in ( R1 \ R4 ) by L70 , L66 , ORDINAL6:5;
thus L72: thesis by L71 , L66 , TARSKI:def 4;
end;
end;
thus L74: ( union R1 ) c= ( union ( R1 \ R4 ) ) by L64 , TARSKI:def 3;
end;
theorem
L75: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (( R1 \ R4 ) is non  empty  finite implies (ex B4 being Nat st R1 = ( R4 +^ B4 )))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
assume L76: ( R1 \ R4 ) is non  empty  finite;
set D5 = the (Element of ( R1 \ R4 ));
L77: (D5 in R1 & D5 nin R4) by L76 , XBOOLE_0:def 5;
L78: R4 c= D5 by L77 , ORDINAL6:4;
consider R5 being  ordinal number such that L79: (R1 = ( R4 +^ R5 ) & R5 <> ( {} )) by L78 , L77 , ORDINAL1:12 , ORDINAL3:28;
deffunc H1(Ordinal) = ( R4 +^ $1 );
consider C4 being T-Sequence such that L80: (( dom C4 ) = ( omega ) & (for R6 being  ordinal number holds (R6 in ( omega ) implies ( C4 . R6 ) = H1(R6)))) from ORDINAL2:sch 2;
L81: C4 is  one-to-one
proof
let R10 being set;
let R11 being set;
assume L82: (R10 in ( dom C4 ) & R11 in ( dom C4 ) & ( C4 . R10 ) = ( C4 . R11 ) & R10 <> R11);
reconsider D6 = R10 , D7 = R11 as (Element of ( omega )) by L82 , L80;
L83: (( C4 . D6 ) = H1(D6) & ( C4 . D7 ) = H1(D7)) by L80;
L84: (D6 in D7 or D7 in D6) by L82 , ORDINAL1:14;
L85: (( R4 +^ D6 ) in ( R4 +^ D7 ) or ( R4 +^ D7 ) in ( R4 +^ D6 )) by L84 , ORDINAL2:32;
thus L86: contradiction by L85 , L82 , L83;
end;
L87: ( omega ) , ( rng C4 ) are_equipotent  by L81 , L80 , WELLORD2:def 4;
L88:
now
assume L89: ( omega ) c= R5;
L90: H1(( omega )) c= R1 by L89 , L79 , ORDINAL2:33;
L91: ( rng C4 ) c= ( R1 \ R4 )
proof
let R11 being set;
assume L92: R11 in ( rng C4 );
consider R10 being set such that L93: (R10 in ( dom C4 ) & R11 = ( C4 . R10 )) by L92 , FUNCT_1:def 3;
reconsider D8 = R10 as (Element of ( omega )) by L80 , L93;
L94: R11 = H1(D8) by L80 , L93;
L95: (R4 c= H1(D8) & H1(D8) in H1(( omega ))) by ORDINAL2:32 , ORDINAL3:24;
L96: (R11 nin R4 & R11 in R1) by L95 , L90 , L94 , ORDINAL6:4;
thus L97: thesis by L96 , XBOOLE_0:def 5;
end;
thus L98: contradiction by L91 , L76 , L87 , CARD_1:38;
end;
L99: R5 in ( omega ) by L88 , ORDINAL6:4;
thus L100: thesis by L99 , L79;
end;
begin
definition
let C5 being set;
attr C5 is  segmental
means
:L101: (ex R1 being  ordinal number st (ex R4 being  ordinal number st ( proj1 C5 ) = ( R1 \ R4 )));
end;
theorem
L103: (for R17 being Function holds (for R18 being Function holds ((( dom R17 ) = ( dom R18 ) & R17 is  segmental) implies R18 is  segmental)))
proof
let R17 being Function;
let R18 being Function;
assume L104: ( dom R17 ) = ( dom R18 );
given R1 being  ordinal number , R4 being  ordinal number such that
L105: ( dom R17 ) = ( R1 \ R4 );

take R1;
take R4;
thus L106: thesis by L104 , L105;
end;
theorem
L107: (for R17 being Function holds (R17 is  segmental implies (for R1 being  ordinal number holds (for R4 being  ordinal number holds (for R5 being  ordinal number holds ((R1 c= R4 & R4 c= R5 & R1 in ( dom R17 ) & R5 in ( dom R17 )) implies R4 in ( dom R17 )))))))
proof
let R17 being Function;
given C6 , C7 being Ordinal such that
L108: ( dom R17 ) = ( C6 \ C7 );

let R1 being  ordinal number;
let R4 being  ordinal number;
let R5 being  ordinal number;
assume L109: (R1 c= R4 & R4 c= R5 & R1 in ( dom R17 ) & R5 in ( dom R17 ));
L110: (C7 c= R1 & R5 in C6) by L109 , L108 , ORDINAL6:5;
L111: (C7 c= R4 & R4 in C6) by L110 , L109 , ORDINAL1:12 , XBOOLE_1:1;
thus L112: thesis by L111 , L108 , ORDINAL6:5;
end;
registration
cluster  T-Sequence-like ->  segmental for Function;
coherence
proof
let R17 being Function;
assume L113: R17 is  T-Sequence-like;
reconsider D9 = R17 as T-Sequence by L113;
take ( dom D9 );
take ( 0 );
thus L114: thesis;
end;
cluster  FinSequence-like ->  segmental for Function;
coherence
proof
let R17 being Function;
assume L115: R17 is  FinSequence-like;
reconsider D10 = R17 as FinSequence by L115;
take D11 = ( succ ( len D10 ) );
take D12 = 1;
reconsider D13 = ( len D10 ) as Nat;
thus L116: ( dom R17 ) c= ( D11 \ D12 )
proof
let R10 being set;
assume L117: R10 in ( dom R17 );
L118: R10 in ( dom D10 ) by L117;
reconsider D14 = R10 as Nat by L118;
L119: D14 <= D13 by L117 , FINSEQ_3:25;
L120: (1 <= D14 & D14 <= D13) by L119 , L117 , FINSEQ_3:25;
L121: (( succ ( 0 ) ) c= D14 & D14 c= D13) by L120 , NAT_1:39;
L122: (( 0 ) in D14 & D14 in D11) by L121 , ORDINAL1:21 , ORDINAL1:22;
L123: (not D14 in D12) by L120 , CARD_1:49 , TARSKI:def 1;
thus L124: thesis by L123 , L122 , XBOOLE_0:def 5;
end;

reconsider D15 = D11 as (Element of ( NAT )) by ORDINAL1:def 12;
let R10 being set;
assume L125: R10 in ( D11 \ D12 );
L126: (R10 in D15 & (not R10 in D12)) by L125 , XBOOLE_0:def 5;
reconsider D16 = R10 as Nat by L125;
L127: (D16 c= D13 & D12 c= D16) by L126 , ORDINAL1:16 , ORDINAL1:22;
L128: (1 <= D16 & D16 <= D13) by L127 , NAT_1:39;
thus L129: thesis by L128 , FINSEQ_3:25;
end;
end;
definition
let R1 being  ordinal number;
let C8 being set;
attr C8 is R1 -based
means
:L131: (for R4 being  ordinal number holds (R4 in ( proj1 C8 ) implies (R1 in ( proj1 C8 ) & R1 c= R4)));
attr C8 is R1 -limited
means
:L132: R1 = ( sup ( proj1 C8 ) );
end;
theorem
L134: (for R1 being  ordinal number holds (for R17 being Function holds (R17 is R1 -based  segmental iff (ex R4 being  ordinal number st (( dom R17 ) = ( R4 \ R1 ) & R1 c= R4)))))
proof
let R1 being  ordinal number;
let R17 being Function;
thus L135: (R17 is R1 -based  segmental implies (ex R4 being  ordinal number st (( dom R17 ) = ( R4 \ R1 ) & R1 c= R4)))
proof
assume L136: (for R4 being  ordinal number holds (R4 in ( dom R17 ) implies (R1 in ( dom R17 ) & R1 c= R4)));
given R5 being  ordinal number , R6 being  ordinal number such that
L137: ( dom R17 ) = ( R5 \ R6 );

set D17 = the (Element of ( R5 \ R6 ));
per cases ;
suppose L138: ( dom R17 ) = ( {} );

L139: ( R1 \ R1 ) = ( dom R17 ) by L138 , XBOOLE_1:37;
thus L140: thesis by L139;
end;
suppose L141: ( dom R17 ) <> ( {} );

L142: D17 in ( dom R17 ) by L141 , L137;
L143: R1 in ( dom R17 ) by L142 , L136;
L144: (R6 c= R1 & R1 in R5) by L143 , L137 , ORDINAL6:5;
L145: R6 in R5 by L144 , ORDINAL1:12;
L146: R6 in ( dom R17 ) by L145 , L137 , ORDINAL6:5;
L147: R1 c= R6 by L146 , L136;
L148: (R1 = R6 & R1 c= R5) by L147 , L144 , ORDINAL1:def 2 , XBOOLE_0:def 10;
thus L149: thesis by L148 , L137;
end;
end;

given R4 being  ordinal number such that
L151: (( dom R17 ) = ( R4 \ R1 ) & R1 c= R4);

thus L152: R17 is R1 -based
proof
let R5 being  ordinal number;
assume L153: R5 in ( dom R17 );
L154: (R1 c= R5 & R5 in R4) by L153 , L151 , ORDINAL6:5;
L155: R1 in R4 by L154 , ORDINAL1:12;
thus L156: thesis by L155 , L151 , L153 , ORDINAL6:5;
end;

take R4;
take R1;
thus L157: thesis by L151;
end;
theorem
L158: (for R4 being  ordinal number holds (for R17 being Function holds (R17 is R4 -limited non  empty  segmental iff (ex R1 being  ordinal number st (( dom R17 ) = ( R4 \ R1 ) & R1 in R4)))))
proof
let R4 being  ordinal number;
let R17 being Function;
thus L159: (R17 is R4 -limited non  empty  segmental implies (ex R1 being  ordinal number st (( dom R17 ) = ( R4 \ R1 ) & R1 in R4)))
proof
assume L160: R4 = ( sup ( dom R17 ) );
assume L161: R17 is non  empty;
given R5 being  ordinal number , R6 being  ordinal number such that
L162: ( dom R17 ) = ( R5 \ R6 );

set D18 = the (Element of ( R5 \ R6 ));
take D19 = R6;
L163: R4 = R5 by L161 , L160 , L162 , L41;
thus L164: ( dom R17 ) = ( R4 \ D19 ) by L161 , L160 , L162 , L41;
L165: (D19 c= D18 & D18 in R4) by L161 , L162 , L163 , ORDINAL6:5;
thus L166: D19 in R4 by L165 , ORDINAL1:12;
end;

given R1 being  ordinal number such that
L167: (( dom R17 ) = ( R4 \ R1 ) & R1 in R4);

L168: R1 in ( dom R17 ) by L167 , ORDINAL6:5;
thus L169: R4 = ( sup ( dom R17 ) ) by L168 , L167 , L41;
thus L170: R17 is non  empty by L167 , ORDINAL6:5;
take R4;
take R1;
thus L171: thesis by L167;
end;
registration
cluster  T-Sequence-like -> ( 0 ) -based for Function;
coherence
proof
let R17 being Function;
assume L172: R17 is  T-Sequence-like;
reconsider D20 = R17 as T-Sequence by L172;
let R4 being  ordinal number;
assume L173: R4 in ( dom R17 );
L174: R4 in ( dom D20 ) by L173;
thus L175: thesis by L174 , ORDINAL3:8;
end;
cluster  FinSequence-like -> 1 -based for Function;
coherence
proof
let R17 being Function;
assume L176: R17 is  FinSequence-like;
reconsider D21 = R17 as FinSequence by L176;
let R4 being  ordinal number;
assume L177: R4 in ( dom R17 );
L178: R4 in ( dom D21 ) by L177;
reconsider D22 = R4 as Nat by L178;
L179: (1 <= D22 & D22 <= ( len D21 )) by L178 , FINSEQ_3:25;
L180: 1 <= ( len D21 ) by L179 , XXREAL_0:2;
thus L181: thesis by L180 , L179 , FINSEQ_3:25 , NAT_1:39;
end;
end;
theorem
L183: (for R17 being Function holds R17 is ( inf ( dom R17 ) ) -based)
proof
let R17 being Function;
set D23 = ( inf ( dom R17 ) );
let R5 being  ordinal number;
assume L184: R5 in ( dom R17 );
thus L185: (D23 in ( dom R17 ) & D23 c= R5) by L184 , ORDINAL2:14 , ORDINAL2:17;
end;
theorem
L186: (for R17 being Function holds R17 is ( sup ( dom R17 ) ) -limited) by L132;
theorem
L187: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (for R17 being Function holds ((R17 is R4 -limited & R1 in ( dom R17 )) implies R1 in R4))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
let R17 being Function;
assume L188: R4 = ( sup ( dom R17 ) );
thus L189: thesis by L188 , ORDINAL2:19;
end;
definition
let R17 being Function;
func base- R17 ->  ordinal number means 
:L190: R17 is it -based if (ex R1 being  ordinal number st R1 in ( dom R17 )) otherwise it = ( 0 );
existence
proof
set D24 = ( inf ( dom R17 ) );
thus L191:now
given R1 being  ordinal number such that
L192: R1 in ( dom R17 );

take D25 = D24;
thus L193: R17 is D25 -based by L183;
end;
assume L194: (not (ex R1 being  ordinal number st R1 in ( dom R17 )));
take ( 0 );
thus L195: thesis;
end;
uniqueness
proof
let R4 being  ordinal number;
let R5 being  ordinal number;
thus L196:now
given R1 being  ordinal number such that
L197: R1 in ( dom R17 );

assume L198: (R17 is R4 -based & R17 is R5 -based);
thus L199: R4 = R5
proof
L200: R5 in ( dom R17 ) by L197 , L198 , L131;
thus L201: R4 c= R5 by L200 , L198 , L131;
L202: R4 in ( dom R17 ) by L197 , L198 , L131;
thus L203: R5 c= R4 by L202 , L198 , L131;
end;

end;
thus L200: thesis;
end;
consistency;
func limit- R17 ->  ordinal number means 
:L201: R17 is it -limited if (ex R1 being  ordinal number st R1 in ( dom R17 )) otherwise it = ( 0 );
existence
proof
set D26 = ( sup ( dom R17 ) );
thus L202:now
given R1 being  ordinal number such that
L203: R1 in ( dom R17 );

take D27 = D26;
thus L204: R17 is D27 -limited by L132;
end;
assume L205: (not (ex R1 being  ordinal number st R1 in ( dom R17 )));
take ( 0 );
thus L206: thesis;
end;
uniqueness
proof
let R4 being  ordinal number;
let R5 being  ordinal number;
thus L207:now
given R1 being  ordinal number such that
L208: R1 in ( dom R17 );

assume L209: (R17 is R4 -limited & R17 is R5 -limited);
thus L210: R4 = ( sup ( dom R17 ) ) by L209 , L132
.= R5 by L209 , L132;
end;
thus L211: thesis;
end;
consistency;
end;
definition
let R17 being Function;
func len- R17 ->  ordinal number equals 
( ( limit- R17 ) -^ ( base- R17 ) );
coherence;
end;
theorem
L214: (( base- ( {} ) ) = ( 0 ) & ( limit- ( {} ) ) = ( 0 ) & ( len- ( {} ) ) = ( 0 ))
proof
L215: (not (ex R1 being  ordinal number st R1 in ( dom ( {} ) )));
thus L216: (( base- ( {} ) ) = ( 0 ) & ( limit- ( {} ) ) = ( 0 )) by L215 , L190 , L201;
thus L217: thesis by L216 , ORDINAL3:56;
end;
theorem
L218: (for R17 being Function holds ( limit- R17 ) = ( sup ( dom R17 ) ))
proof
let R17 being Function;
per cases ;
suppose L219: (for R1 being  ordinal number holds R1 nin ( dom R17 ));

L220: ( On ( dom R17 ) ) c= ( 0 )
proof
let R10 being set;
assume L221: R10 in ( On ( dom R17 ) );
L222: (R10 in ( dom R17 ) & R10 is  ordinal) by L221 , ORDINAL1:def 9;
thus L223: thesis by L222 , L219;
end;
L224: ( sup ( dom R17 ) ) c= ( 0 ) by L220 , ORDINAL2:def 3;
L225: ( sup ( dom R17 ) ) = ( 0 ) by L224;
thus L226: thesis by L225 , L219 , L201;
end;
suppose L227: (ex R1 being  ordinal number st R1 in ( dom R17 ));

L228: R17 is ( sup ( dom R17 ) ) -limited by L132;
thus L229: thesis by L228 , L227 , L201;
end;
end;
theorem
L231: (for R17 being Function holds R17 is ( limit- R17 ) -limited)
proof
let R17 being Function;
L232: ( limit- R17 ) = ( sup ( dom R17 ) ) by L218;
thus L233: thesis by L232 , L132;
end;
theorem
L234: (for R1 being  ordinal number holds (for B5 being  empty set holds B5 is R1 -based))
proof
let R1 being  ordinal number;
let C9 being  empty set;
let R4 being  ordinal number;
thus L235: thesis;
end;
registration
let R1 being  ordinal number;
let R14 being set;
let R15 being set;
cluster R15 -defined R14 -valued R1 -based  segmental  finite  empty for T-Sequence;
existence
proof
take D28 = ( {} [: R15 , R14 :] );
thus L236: thesis by L234;
end;
end;
definition
mode array
 is  segmental Function;
end;
registration
let C10 being array;
cluster ( dom C10 ) ->  ordinal-membered;
coherence
proof
consider R1 being  ordinal number, R4 being  ordinal number such that L239: ( dom C10 ) = ( R1 \ R4 ) by L101;
take R1;
thus L240: thesis by L239;
end;
end;
theorem
L242: (for B6 being array holds (B6 is ( 0 ) -limited iff B6 is  empty))
proof
let C11 being array;
thus L243: (C11 is ( 0 ) -limited implies C11 is  empty)
proof
assume L244: ( sup ( dom C11 ) ) = ( 0 );
L245: ( dom C11 ) c= ( 0 ) by L244 , ORDINAL6:3;
thus L246: C11 is  empty by L245;
end;

assume L247: C11 is  empty;
thus L248: ( sup ( dom C11 ) ) = ( 0 ) by L247 , ORDINAL2:18;
end;
registration
cluster ( 0 ) -based ->  T-Sequence-like for array;
coherence
proof
let C12 being array;
assume L249: (for R4 being  ordinal number holds (R4 in ( proj1 C12 ) implies (( 0 ) in ( proj1 C12 ) & ( 0 ) c= R4)));
consider R5 being  ordinal number, R1 being  ordinal number such that L250: ( dom C12 ) = ( R5 \ R1 ) by L101;
set D29 = the (Element of ( R5 \ R1 ));
L251:
now
assume L252: ( R5 \ R1 ) <> ( {} );
L253: D29 in R5 by L252 , XBOOLE_0:def 5;
L254: ( 0 ) in ( dom C12 ) by L253 , L249 , L250 , L252;
L255: ( 0 ) nin R1 by L254 , L250 , XBOOLE_0:def 5;
L256: R1 c= ( 0 ) by L255 , ORDINAL6:4;
L257: R1 = ( 0 ) by L256;
thus L258: ( dom C12 ) = R5 by L257 , L250;
end;
thus L259: ( dom C12 ) is  ordinal by L251 , L250;
end;
end;
definition
let R14 being set;
mode array of R14
 is R14 -valued array;
end;
definition
let C13 being 1-sorted;
mode array of C13
 is (array of (the carrier of C13));
end;
definition
let R1 being  ordinal number;
let R14 being set;
mode array of R1 , R14
 is R1 -defined (array of R14);
end;
theorem
L264: (for R17 being Function holds ( base- R17 ) = ( inf ( dom R17 ) ))
proof
let R17 being Function;
set D30 = R17;
set D31 = ( inf ( dom D30 ) );
L265: D30 is D31 -based by L183;
per cases ;
suppose L266: (ex R1 being  ordinal number st R1 in ( dom D30 ));

thus L267: thesis by L266 , L265 , L190;
end;
suppose L268: (not (ex R1 being  ordinal number st R1 in ( dom D30 )));

set D32 = the (Element of ( On ( dom D30 ) ));
L269:
now
assume L270: ( On ( dom D30 ) ) <> ( {} );
L271: D32 in ( dom D30 ) by L270 , ORDINAL1:def 9;
thus L272: contradiction by L271 , L268;
end;
L273: D31 = ( 0 ) by L269 , SETFAM_1:def 1;
thus L274: thesis by L273 , L268 , L190;
end;
end;
theorem
L276: (for R17 being Function holds R17 is ( base- R17 ) -based)
proof
let R17 being Function;
L277: ( base- R17 ) = ( inf ( dom R17 ) ) by L264;
thus L278: thesis by L277 , L183;
end;
theorem
L279: (for R19 being array holds ( dom R19 ) = ( ( limit- R19 ) \ ( base- R19 ) ))
proof
let R19 being array;
consider R1 being  ordinal number, R4 being  ordinal number such that L280: ( dom R19 ) = ( R1 \ R4 ) by L101;
L281: ( limit- R19 ) = ( sup ( dom R19 ) ) by L218;
L282: ( base- R19 ) = ( inf ( dom R19 ) ) by L264;
thus L283: ( dom R19 ) c= ( ( limit- R19 ) \ ( base- R19 ) )
proof
let R10 being set;
assume L284: R10 in ( dom R19 );
L285: (( base- R19 ) c= R10 & R10 in ( limit- R19 )) by L284 , L281 , L282 , ORDINAL2:14 , ORDINAL2:19;
L286: (R10 in ( base- R19 ) implies R10 in R10) by L285;
thus L287: thesis by L286 , L285 , XBOOLE_0:def 5;
end;

let R10 being set;
assume L288: R10 in ( ( limit- R19 ) \ ( base- R19 ) );
reconsider D33 = R10 as Ordinal by L288;
L289: (ex R5 being  ordinal number st (R5 in ( dom R19 ) & D33 c= R5)) by L281 , L288 , ORDINAL2:21;
L290: (R1 = ( limit- R19 ) & R4 = ( base- R19 )) by L289 , L280 , L281 , L282 , L41;
thus L291: thesis by L290 , L280 , L288;
end;
theorem
L292: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (for R19 being array holds ((( dom R19 ) = ( R1 \ R4 ) & R19 is non  empty) implies (( base- R19 ) = R4 & ( limit- R19 ) = R1)))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
let R19 being array;
assume L293: (( dom R19 ) = ( R1 \ R4 ) & R19 is non  empty);
set D34 = the (Element of ( dom R19 ));
L294: ( dom R19 ) <> ( {} ) by L293;
L295: D34 in ( R1 \ R4 ) by L294 , L293;
L296: (R4 c= D34 & D34 in R1) by L293 , ORDINAL6:5;
L297: (R4 in R1 & R4 nin R4) by L296 , ORDINAL1:12;
L298: R4 in ( R1 \ R4 ) by L297 , XBOOLE_0:def 5;
L299: R4 in ( sup ( dom R19 ) ) by L298 , L293 , ORDINAL2:19;
L300: R19 is R4 -based
proof
let R5 being  ordinal number;
thus L301: thesis by L293 , L297 , ORDINAL6:5;
end;
thus L302: ( base- R19 ) = R4 by L300 , L190 , L293 , L295;
L303: R1 c= ( sup ( dom R19 ) )
proof
let C14 being Ordinal;
assume L304: C14 in R1;
per cases ;
suppose L305: C14 in R4;

thus L306: thesis by L305 , L299 , ORDINAL1:10;
end;
suppose L307: C14 nin R4;

L308: C14 in ( R1 \ R4 ) by L307 , L304 , XBOOLE_0:def 5;
thus L309: thesis by L308 , L293 , ORDINAL2:19;
end;
end;
L311: ( sup ( dom R19 ) ) c= ( sup R1 ) by L293 , ORDINAL2:22;
L312: ( sup ( dom R19 ) ) c= R1 by L311 , ORDINAL2:18;
L313: R1 = ( sup ( dom R19 ) ) by L312 , L303 , XBOOLE_0:def 10;
thus L314: thesis by L313 , L218;
end;
theorem
L315: (for B7 being T-Sequence holds (( base- B7 ) = ( 0 ) & ( limit- B7 ) = ( dom B7 ) & ( len- B7 ) = ( dom B7 )))
proof
let C15 being T-Sequence;
per cases ;
suppose L316: C15 = ( {} );

thus L317: thesis by L316 , L214;
end;
suppose L318: C15 <> ( {} );

L319: ( ( dom C15 ) \ ( 0 ) ) = ( dom C15 );
thus L320: (( base- C15 ) = ( 0 ) & ( limit- C15 ) = ( dom C15 )) by L319 , L318 , L292;
thus L321: ( len- C15 ) = ( dom C15 ) by L320 , ORDINAL3:56;
end;
end;
registration
let R1 being  ordinal number;
let R4 being  ordinal number;
let R14 being set;
cluster R4 -based  natural-valued ( INT ) -valued  real-valued  complex-valued  finite for (array of R1 , R14);
existence
proof
set D35 = the  empty (array of R1 , R14);
take D35;
thus L323: thesis by L234;
end;
end;
registration
let R1 being  ordinal number;
let R10 being set;
cluster { [ R1 , R10 ] } ->  segmental;
coherence
proof
take ( succ R1 );
take R1;
thus L325: ( dom { [ R1 , R10 ] } ) = { R1 } by FUNCT_5:12
.= ( ( succ R1 ) \ R1 ) by L30;
end;
end;
registration
let R1 being  ordinal number;
let C16 being Nat;
cluster { [ R1 , C16 ] } ->  natural-valued for array;
coherence
proof
let R19 being array;
assume L327: R19 = { [ R1 , C16 ] };
L328: ( rng R19 ) = { C16 } by L327 , FUNCT_5:12;
L329: ( rng R19 ) c= ( NAT ) by L328 , MEMBERED:6;
thus L330: R19 is  natural-valued by L329 , VALUED_0:def 6;
end;
end;
registration
let R1 being  ordinal number;
let C17 being  real number;
cluster { [ R1 , C17 ] } ->  real-valued for array;
coherence
proof
let R19 being array;
assume L332: R19 = { [ R1 , C17 ] };
L333: ( rng R19 ) = { C17 } by L332 , FUNCT_5:12;
L334: ( rng R19 ) c= ( REAL ) by L333 , MEMBERED:3;
thus L335: R19 is  real-valued by L334 , VALUED_0:def 3;
end;
end;
registration
let R1 being  ordinal number;
let C18 being non  empty set;
let C19 being (Element of C18);
cluster { [ R1 , C19 ] } -> C18 -valued for array;
coherence
proof
let R19 being array;
assume L337: R19 = { [ R1 , C19 ] };
L338: ( rng R19 ) = { C19 } by L337 , FUNCT_5:12;
thus L339: ( rng R19 ) c= C18 by L338 , ZFMISC_1:31;
end;
end;
registration
let R1 being  ordinal number;
let R10 being set;
cluster { [ R1 , R10 ] } -> R1 -based ( succ R1 ) -limited for array;
coherence
proof
let C20 being array;
assume that
L341: C20 = { [ R1 , R10 ] };
L342: ( dom C20 ) = { R1 } by L341 , FUNCT_5:12;
thus L343: C20 is R1 -based
proof
let R4 being  ordinal number;
assume that
L344: R4 in ( proj1 C20 );
thus L345: (R1 in ( proj1 C20 ) & R1 c= R4) by L344 , L342 , TARSKI:def 1;
end;

L346: ( sup ( dom C20 ) ) = ( succ R1 ) by L342 , ORDINAL2:23;
thus L347: thesis by L346 , L132;
end;
end;
registration
let R4 being  ordinal number;
cluster non  empty R4 -based  natural-valued ( INT ) -valued  real-valued  complex-valued  finite for array;
existence
proof
set D36 = the Nat;
reconsider D37 = { [ R4 , D36 ] } as  natural-valued array;
take D37;
thus L349: thesis;
end;
let C21 being non  empty set;
cluster non  empty R4 -based  finite C21 -valued for array;
existence
proof
set D38 = the (Element of C21);
reconsider D39 = { [ R4 , D38 ] } as (array of C21);
take D39;
thus L350: thesis;
end;
end;
notation
let C22 being T-Sequence;
synonym C22 last for last C22;
end;
definition
let C23 being array;
func last C23 equals 
( C23 . ( union ( dom C23 ) ) );
coherence;
end;
registration
let C24 being T-Sequence;
identify C24 last with last C24;
compatibility;
end;
begin
definition
let C25 being Function;
attr C25 is  descending
means
:L355: (for R1 being  ordinal number holds (for R4 being  ordinal number holds ((R1 in ( dom C25 ) & R4 in ( dom C25 ) & R1 in R4) implies ( C25 . R4 ) c< ( C25 . R1 ))));
end;
theorem
L357: (for B8 being  finite array holds ((for R1 being  ordinal number holds ((R1 in ( dom B8 ) & ( succ R1 ) in ( dom B8 )) implies ( B8 . ( succ R1 ) ) c< ( B8 . R1 ))) implies B8 is  descending))
proof
let C26 being  finite array;
assume L358: (for R1 being  ordinal number holds ((R1 in ( dom C26 ) & ( succ R1 ) in ( dom C26 )) implies ( C26 . ( succ R1 ) ) c< ( C26 . R1 )));
let R1 being  ordinal number;
let R4 being  ordinal number;
assume L359: (R1 in ( dom C26 ) & R4 in ( dom C26 ) & R1 in R4);
consider R5 being  ordinal number, R6 being  ordinal number such that L360: ( dom C26 ) = ( R5 \ R6 ) by L101;
consider C27 being Nat such that L361: R5 = ( R6 +^ C27 ) by L359 , L360 , L75;
consider C28 being Ordinal such that L362: (R1 = ( R6 +^ C28 ) & C28 in C27) by L359 , L360 , L361 , L1;
consider C29 being Ordinal such that L363: (R4 = ( R6 +^ C29 ) & C29 in C27) by L359 , L360 , L361 , L1;
reconsider D40 = C28 , D41 = C29 as Nat by L362 , L363;
reconsider D42 = ( succ D40 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L364: ( succ R1 ) = ( R6 +^ ( succ D40 ) ) by L362 , ORDINAL2:28;
L365: D40 in D41 by L359 , L362 , L363 , ORDINAL3:22;
L366: ( succ D40 ) c= D41 by L365 , ORDINAL1:21;
L367: ( succ D40 ) <= D41 by L366 , NAT_1:39;
consider C30 being Nat such that L368: D41 = ( D42 + C30 ) by L367 , NAT_1:10;
reconsider D43 = C30 as (Element of ( NAT )) by ORDINAL1:def 12;
deffunc H2(Ordinal) = ( ( succ R1 ) +^ $1 );
defpred S9[ Nat ] means (H2($1) in ( dom C26 ) implies ( C26 . H2($1) ) c< ( C26 . R1 ));
L369: H2(( 0 )) = ( succ R1 ) by ORDINAL2:27;
L370: S9[ ( 0 ) ] by L369 , L358 , L359;
L371: (for B9 being Nat holds (S9[ B9 ] implies S9[ ( B9 + 1 ) ]))
proof
let C31 being Nat;
L372: ( C31 + 1 ) = ( succ C31 ) by NAT_1:38;
L373: H2(( C31 + 1 )) = ( succ H2(C31) ) by L372 , ORDINAL2:28;
L374: (H2(C31) in H2(( C31 + 1 )) & R1 in ( succ R1 )) by L373 , ORDINAL1:6;
L375: (H2(C31) c= H2(( C31 + 1 )) & R1 c= ( succ R1 )) by L374 , ORDINAL1:def 2;
L376: ( succ R1 ) c= H2(C31) by ORDINAL3:24;
L377: R1 c= H2(C31) by L376 , L374 , ORDINAL1:def 2;
assume L378: (S9[ C31 ] & H2(( C31 + 1 )) in ( dom C26 ));
L379: H2(C31) in ( dom C26 ) by L378 , L359 , L375 , L377 , L107;
L380: (( C26 . H2(C31) ) c< ( C26 . R1 ) & ( C26 . H2(( C31 + 1 )) ) c< ( C26 . H2(C31) )) by L379 , L358 , L373 , L378;
thus L381: ( C26 . H2(( C31 + 1 )) ) c< ( C26 . R1 ) by L380 , XBOOLE_1:56;
end;
L382: (for B10 being Nat holds S9[ B10 ]) from NAT_1:sch 2(L370 , L371);
L383: R4 = ( R6 +^ ( D42 +^ D43 ) ) by L363 , L368 , CARD_2:36
.= ( ( succ R1 ) +^ D43 ) by L364 , ORDINAL3:30;
thus L384: ( C26 . R4 ) c< ( C26 . R1 ) by L383 , L359 , L382;
end;
theorem
L385: (for B11 being array holds ((( len- B11 ) = ( omega ) & (for R1 being  ordinal number holds ((R1 in ( dom B11 ) & ( succ R1 ) in ( dom B11 )) implies ( B11 . ( succ R1 ) ) c< ( B11 . R1 )))) implies B11 is  descending))
proof
let C32 being array;
assume L386: ( len- C32 ) = ( omega );
assume L387: (for R1 being  ordinal number holds ((R1 in ( dom C32 ) & ( succ R1 ) in ( dom C32 )) implies ( C32 . ( succ R1 ) ) c< ( C32 . R1 )));
let R1 being  ordinal number;
let R4 being  ordinal number;
assume L388: (R1 in ( dom C32 ) & R4 in ( dom C32 ) & R1 in R4);
consider R5 being  ordinal number, R6 being  ordinal number such that L389: ( dom C32 ) = ( R5 \ R6 ) by L101;
L390: C32 is non  empty by L388;
L391: (( base- C32 ) = R6 & ( limit- C32 ) = R5) by L390 , L389 , L292;
L392: (R6 c= R1 & R1 in R5) by L388 , L389 , ORDINAL6:5;
L393: R6 in R5 by L392 , ORDINAL1:12;
L394: R6 c= R5 by L393 , ORDINAL1:def 2;
L395: R5 = ( R6 +^ ( omega ) ) by L394 , L391 , L386 , ORDINAL3:def 5;
consider C33 being Ordinal such that L396: (R1 = ( R6 +^ C33 ) & C33 in ( omega )) by L388 , L389 , L395 , L1;
consider C34 being Ordinal such that L397: (R4 = ( R6 +^ C34 ) & C34 in ( omega )) by L388 , L389 , L395 , L1;
reconsider D44 = C33 , D45 = C34 as Nat by L396 , L397;
reconsider D46 = ( succ D44 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L398: ( succ R1 ) = ( R6 +^ ( succ D44 ) ) by L396 , ORDINAL2:28;
L399: D44 in D45 by L388 , L396 , L397 , ORDINAL3:22;
L400: ( succ D44 ) c= D45 by L399 , ORDINAL1:21;
L401: ( succ D44 ) <= D45 by L400 , NAT_1:39;
consider C35 being Nat such that L402: D45 = ( D46 + C35 ) by L401 , NAT_1:10;
reconsider D47 = C35 as (Element of ( NAT )) by ORDINAL1:def 12;
deffunc H3(Ordinal) = ( ( succ R1 ) +^ $1 );
defpred S10[ Nat ] means (H3($1) in ( dom C32 ) implies ( C32 . H3($1) ) c< ( C32 . R1 ));
L403: H3(( 0 )) = ( succ R1 ) by ORDINAL2:27;
L404: S10[ ( 0 ) ] by L403 , L387 , L388;
L405: (for B12 being Nat holds (S10[ B12 ] implies S10[ ( B12 + 1 ) ]))
proof
let C36 being Nat;
L406: ( C36 + 1 ) = ( succ C36 ) by NAT_1:38;
L407: H3(( C36 + 1 )) = ( succ H3(C36) ) by L406 , ORDINAL2:28;
L408: (H3(C36) in H3(( C36 + 1 )) & R1 in ( succ R1 )) by L407 , ORDINAL1:6;
L409: (H3(C36) c= H3(( C36 + 1 )) & R1 c= ( succ R1 )) by L408 , ORDINAL1:def 2;
L410: ( succ R1 ) c= H3(C36) by ORDINAL3:24;
L411: R1 c= H3(C36) by L410 , L408 , ORDINAL1:def 2;
assume L412: (S10[ C36 ] & H3(( C36 + 1 )) in ( dom C32 ));
L413: H3(C36) in ( dom C32 ) by L412 , L388 , L409 , L411 , L107;
L414: (( C32 . H3(C36) ) c< ( C32 . R1 ) & ( C32 . H3(( C36 + 1 )) ) c< ( C32 . H3(C36) )) by L413 , L387 , L407 , L412;
thus L415: ( C32 . H3(( C36 + 1 )) ) c< ( C32 . R1 ) by L414 , XBOOLE_1:56;
end;
L416: (for B13 being Nat holds S10[ B13 ]) from NAT_1:sch 2(L404 , L405);
L417: R4 = ( R6 +^ ( D46 +^ D47 ) ) by L397 , L402 , CARD_2:36
.= ( ( succ R1 ) +^ D47 ) by L398 , ORDINAL3:30;
thus L418: ( C32 . R4 ) c< ( C32 . R1 ) by L417 , L388 , L416;
end;
theorem
L419: (for B14 being T-Sequence holds ((B14 is  descending & ( B14 . ( 0 ) ) is  finite) implies B14 is  finite))
proof
let C37 being T-Sequence;
assume L420: C37 is  descending;
assume L421: ( C37 . ( 0 ) ) is  finite;
deffunc H4(set) = ( card ( C37 . $1 ) );
consider C38 being T-Sequence such that L422: (( dom C38 ) = ( dom C37 ) & (for R1 being  ordinal number holds (R1 in ( dom C37 ) implies ( C38 . R1 ) = H4(R1)))) from ORDINAL2:sch 2;
defpred S11[ set ] means ( C37 . $1 ) is  finite;
L423: S11[ ( {} ) ] by L421;
L424: (for R1 being  ordinal number holds (S11[ R1 ] implies S11[ ( succ R1 ) ]))
proof
let R1 being  ordinal number;
per cases ;
suppose L425: ( succ R1 ) nin ( dom C37 );

thus L426: thesis by L425 , FUNCT_1:def 2;
end;
suppose L427: ( succ R1 ) in ( dom C37 );

L428: R1 in ( succ R1 ) by ORDINAL1:6;
L429: R1 in ( dom C37 ) by L428 , L427 , ORDINAL1:10;
L430: ( C37 . ( succ R1 ) ) c< ( C37 . R1 ) by L429 , L420 , L427 , L428 , L355;
L431: ( C37 . ( succ R1 ) ) c= ( C37 . R1 ) by L430 , XBOOLE_0:def 8;
thus L432: thesis by L431;
end;
end;
L434: (for R1 being  ordinal number holds ((R1 <> ( {} ) & R1 is  limit_ordinal & (for R4 being  ordinal number holds (R4 in R1 implies S11[ R4 ]))) implies S11[ R1 ]))
proof
let R1 being  ordinal number;
assume L435: R1 <> ( {} );
L436: ( 0 ) in R1 by L435 , ORDINAL3:8;
per cases ;
suppose L437: R1 in ( dom C37 );

L438: (( 0 ) in ( dom C37 ) & R1 in ( dom C37 )) by L437 , ORDINAL3:8;
L439: ( C37 . R1 ) c< ( C37 . ( 0 ) ) by L438 , L420 , L436 , L355;
L440: ( C37 . R1 ) c= ( C37 . ( 0 ) ) by L439 , XBOOLE_0:def 8;
thus L441: thesis by L440 , L421;
end;
suppose L442: R1 nin ( dom C37 );

thus L443: thesis by L442 , FUNCT_1:def 2;
end;
end;
L445: (for R1 being  ordinal number holds S11[ R1 ]) from ORDINAL2:sch 1(L423 , L424 , L434);
L446: C38 is  decreasing
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
assume L447: (R1 in R4 & R4 in ( dom C38 ));
L448: R1 in ( dom C37 ) by L447 , L422 , ORDINAL1:10;
L449: (( C38 . R1 ) = H4(R1) & ( C37 . R1 ) is  finite & ( C37 . R4 ) c< ( C37 . R1 ) & ( C38 . R4 ) = H4(R4) & ( C37 . R4 ) is  finite) by L448 , L420 , L422 , L447 , L445 , L355;
thus L450: ( C38 . R4 ) in ( C38 . R1 ) by L449 , CARD_2:48;
end;
thus L451: C37 is  finite by L446 , L422 , FINSET_1:10;
end;
theorem
L452: (for B15 being T-Sequence holds ((B15 is  descending & ( B15 . ( 0 ) ) is  finite & (for R1 being  ordinal number holds (( B15 . R1 ) <> ( {} ) implies ( succ R1 ) in ( dom B15 )))) implies ( last B15 ) = ( {} )))
proof
let C39 being T-Sequence;
assume that
L453: (C39 is  descending & ( C39 . ( 0 ) ) is  finite)
and
L454: (for R1 being  ordinal number holds (( C39 . R1 ) <> ( {} ) implies ( succ R1 ) in ( dom C39 )));
L455: C39 is  finite by L453 , L419;
reconsider D48 = ( dom C39 ) as  finite Ordinal by L455;
set D49 = ( union D48 );
per cases ;
suppose L456: D48 = ( 0 );

thus L457: ( last C39 ) = ( {} ) by L456 , FUNCT_1:def 2;
end;
suppose L458: D48 <> ( 0 );

consider C40 being Nat such that L459: D48 = ( C40 + 1 ) by L458 , NAT_1:6;
L460: D48 = ( succ C40 ) by L459 , NAT_1:38;
L461: D49 = C40 by L460 , ORDINAL2:2;
L462: (( C39 . D49 ) <> ( 0 ) implies D48 in D48) by L454 , L460 , L461;
thus L463: ( last C39 ) = ( {} ) by L462;
end;
end;
scheme A { F1() -> T-Sequence , F2(set) -> set } : F1() is  finite
provided
L465: F2(( F1() . ( 0 ) )) is  finite
and
L466: (for R1 being  ordinal number holds ((( succ R1 ) in ( dom F1() ) & F2(( F1() . R1 )) is  finite) implies F2(( F1() . ( succ R1 ) )) c< F2(( F1() . R1 ))))
proof
deffunc H5(set) = F2(( F1() . $1 ));
consider C41 being T-Sequence such that L467: (( dom C41 ) = ( dom F1() ) & (for R1 being  ordinal number holds (R1 in ( dom F1() ) implies ( C41 . R1 ) = H5(R1)))) from ORDINAL2:sch 2;
per cases  by ORDINAL6:4;
suppose L468: ( dom C41 ) in ( omega );

thus L469: thesis by L468 , L467 , FINSET_1:10;
end;
suppose L470: ( omega ) c= ( dom C41 );

set D50 = ( C41 | ( omega ) );
L471: ( dom D50 ) = ( omega ) by L470 , RELAT_1:62;
L472: ( len- D50 ) = ( dom D50 ) by L315;
L473: ( 0 ) in ( omega ) by ORDINAL1:def 11;
L474: ( D50 . ( 0 ) ) = ( C41 . ( 0 ) ) by L473 , L471 , FUNCT_1:47
.= H5(( 0 )) by L467 , L473 , L470;
defpred S12[ Nat ] means ( D50 . $1 ) is  finite;
L475: S12[ ( 0 ) ] by L465 , L474;
L476: (for R7 being Nat holds (S12[ R7 ] implies S12[ ( R7 + 1 ) ]))
proof
let R7 being Nat;
set D51 = R7;
assume L477: S12[ R7 ];
L478: (R7 in ( omega ) & ( succ R7 ) in ( omega )) by ORDINAL1:def 12;
L479: (D51 in ( dom C41 ) & ( succ D51 ) in ( dom C41 ) & ( D50 . D51 ) = ( C41 . D51 ) & ( D50 . ( succ D51 ) ) = ( C41 . ( succ D51 ) )) by L478 , L470 , L471 , FUNCT_1:47;
L480: (( C41 . D51 ) = H5(D51) & ( C41 . ( succ D51 ) ) = H5(( succ D51 ))) by L467 , L470 , L478;
L481: ( D50 . ( succ D51 ) ) c< ( D50 . D51 ) by L480 , L466 , L467 , L477 , L479;
L482: ( D50 . ( succ D51 ) ) c= ( D50 . D51 ) by L481 , XBOOLE_0:def 8;
thus L483: thesis by L482 , L477 , NAT_1:38;
end;
L484: (for R7 being Nat holds S12[ R7 ]) from NAT_1:sch 2(L475 , L476);
L485: (for R1 being  ordinal number holds ((R1 in ( dom D50 ) & ( succ R1 ) in ( dom D50 )) implies ( D50 . ( succ R1 ) ) c< ( D50 . R1 )))
proof
let R1 being  ordinal number;
assume L486: (R1 in ( dom D50 ) & ( succ R1 ) in ( dom D50 ));
reconsider D52 = R1 as Nat by L486 , L471;
L487: (S12[ D52 ] & ( D50 . R1 ) = ( C41 . R1 ) & ( D50 . ( succ R1 ) ) = ( C41 . ( succ R1 ) )) by L486 , L484 , FUNCT_1:47;
L488: (( C41 . R1 ) = H5(R1) & ( C41 . ( succ R1 ) ) = H5(( succ R1 ))) by L467 , L486 , L470 , L471;
thus L489: ( D50 . ( succ R1 ) ) c< ( D50 . R1 ) by L488 , L466 , L467 , L487 , L486 , L470 , L471;
end;
L490: D50 is  descending by L485 , L472 , L385 , L470 , RELAT_1:62;
L491: D50 is  finite by L490 , L465 , L474 , L419;
thus L492: thesis by L491 , L471;
end;
end;
begin
registration
let R14 being set;
let C42 being R14 -defined Function;
let C43 , C44 being set;
cluster ( Swap (C42 , C43 , C44) ) -> R14 -defined;
coherence
proof
L494: ( dom ( Swap (C42 , C43 , C44) ) ) = ( dom C42 ) by FUNCT_7:99;
thus L495: ( dom ( Swap (C42 , C43 , C44) ) ) c= R14 by L494;
end;
end;
registration
let C45 being set;
let C46 being C45 -valued Function;
let C47 , C48 being set;
cluster ( Swap (C46 , C47 , C48) ) -> C45 -valued;
coherence
proof
L497: ( rng ( Swap (C46 , C47 , C48) ) ) = ( rng C46 ) by FUNCT_7:103;
thus L498: ( rng ( Swap (C46 , C47 , C48) ) ) c= C45 by L497 , RELAT_1:def 19;
end;
end;
theorem
L500: (for R10 being set holds (for R11 being set holds (for R17 being Function holds ((R10 in ( dom R17 ) & R11 in ( dom R17 )) implies ( ( Swap (R17 , R10 , R11) ) . R10 ) = ( R17 . R11 )))))
proof
let R10 being set;
let R11 being set;
let R17 being Function;
assume L501: (R10 in ( dom R17 ) & R11 in ( dom R17 ));
L502: ( Swap (R17 , R10 , R11) ) = ( ( R17 +* (R10 , ( R17 . R11 )) ) +* (R11 , ( R17 . R10 )) ) by L501 , FUNCT_7:def 12;
L503: ( dom R17 ) = ( dom ( R17 +* (R10 , ( R17 . R11 )) ) ) by FUNCT_7:30;
L504:
now
assume L505: R10 <> R11;
L506: ( ( Swap (R17 , R10 , R11) ) . R10 ) = ( ( R17 +* (R10 , ( R17 . R11 )) ) . R10 ) by L505 , L502 , FUNCT_7:32;
thus L507: thesis by L506 , L501 , FUNCT_7:31;
end;
thus L508: ( ( Swap (R17 , R10 , R11) ) . R10 ) = ( R17 . R11 ) by L504 , L503 , L501 , L502 , FUNCT_7:31;
end;
theorem
L509: (for R10 being set holds (for R11 being set holds (for R14 being set holds (for B16 being (array of R14) holds ((R10 in ( dom B16 ) & R11 in ( dom B16 )) implies ( ( Swap (B16 , R10 , R11) ) /. R10 ) = ( B16 /. R11 ))))))
proof
let R10 being set;
let R11 being set;
let R14 being set;
let C49 being (array of R14);
assume L510: (R10 in ( dom C49 ) & R11 in ( dom C49 ));
L511: ( dom ( Swap (C49 , R10 , R11) ) ) = ( dom C49 ) by FUNCT_7:99;
thus L512: ( ( Swap (C49 , R10 , R11) ) /. R10 ) = ( ( Swap (C49 , R10 , R11) ) . R10 ) by L511 , L510 , PARTFUN1:def 6
.= ( C49 . R11 ) by L510 , L500
.= ( C49 /. R11 ) by L510 , PARTFUN1:def 6;
end;
theorem
L513: (for R10 being set holds (for R11 being set holds (for R17 being Function holds ((R10 in ( dom R17 ) & R11 in ( dom R17 )) implies ( ( Swap (R17 , R10 , R11) ) . R11 ) = ( R17 . R10 )))))
proof
let R10 being set;
let R11 being set;
let R17 being Function;
assume L514: (R10 in ( dom R17 ) & R11 in ( dom R17 ));
L515: ( Swap (R17 , R10 , R11) ) = ( ( R17 +* (R10 , ( R17 . R11 )) ) +* (R11 , ( R17 . R10 )) ) by L514 , FUNCT_7:def 12;
L516: ( dom R17 ) = ( dom ( R17 +* (R10 , ( R17 . R11 )) ) ) by FUNCT_7:30;
thus L517: thesis by L516 , L514 , L515 , FUNCT_7:31;
end;
theorem
L518: (for R10 being set holds (for R11 being set holds (for R14 being set holds (for B17 being (array of R14) holds ((R10 in ( dom B17 ) & R11 in ( dom B17 )) implies ( ( Swap (B17 , R10 , R11) ) /. R11 ) = ( B17 /. R10 ))))))
proof
let R10 being set;
let R11 being set;
let R14 being set;
let C50 being (array of R14);
assume L519: (R10 in ( dom C50 ) & R11 in ( dom C50 ));
L520: ( dom ( Swap (C50 , R10 , R11) ) ) = ( dom C50 ) by FUNCT_7:99;
thus L521: ( ( Swap (C50 , R10 , R11) ) /. R11 ) = ( ( Swap (C50 , R10 , R11) ) . R11 ) by L520 , L519 , PARTFUN1:def 6
.= ( C50 . R10 ) by L519 , L513
.= ( C50 /. R10 ) by L519 , PARTFUN1:def 6;
end;
theorem
L522: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R17 being Function holds ((R12 <> R10 & R12 <> R11) implies ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( R17 . R12 ))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R17 being Function;
assume L523: (R12 <> R10 & R12 <> R11);
per cases ;
suppose L524: (R10 in ( dom R17 ) & R11 in ( dom R17 ));

L525: ( Swap (R17 , R10 , R11) ) = ( ( R17 +* (R10 , ( R17 . R11 )) ) +* (R11 , ( R17 . R10 )) ) by L524 , FUNCT_7:def 12;
thus L526: ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( ( R17 +* (R10 , ( R17 . R11 )) ) . R12 ) by L525 , L523 , FUNCT_7:32
.= ( R17 . R12 ) by L523 , FUNCT_7:32;
end;
suppose L527: (not (R10 in ( dom R17 ) & R11 in ( dom R17 )));

thus L528: ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( R17 . R12 ) by L527 , FUNCT_7:def 12;
end;
end;
theorem
L530: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R14 being set holds (for B18 being (array of R14) holds ((R12 in ( dom B18 ) & R12 <> R10 & R12 <> R11) implies ( ( Swap (B18 , R10 , R11) ) /. R12 ) = ( B18 /. R12 )))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R14 being set;
let C51 being (array of R14);
assume L531: (R12 in ( dom C51 ) & R12 <> R10 & R12 <> R11);
L532: ( dom ( Swap (C51 , R10 , R11) ) ) = ( dom C51 ) by FUNCT_7:99;
thus L533: ( ( Swap (C51 , R10 , R11) ) /. R12 ) = ( ( Swap (C51 , R10 , R11) ) . R12 ) by L532 , L531 , PARTFUN1:def 6
.= ( C51 . R12 ) by L531 , L522
.= ( C51 /. R12 ) by L531 , PARTFUN1:def 6;
end;
theorem
L534: (for R10 being set holds (for R11 being set holds (for R17 being Function holds ((R10 in ( dom R17 ) & R11 in ( dom R17 )) implies ( Swap (R17 , R10 , R11) ) = ( Swap (R17 , R11 , R10) )))))
proof
let R10 being set;
let R11 being set;
let R17 being Function;
assume L535: (R10 in ( dom R17 ) & R11 in ( dom R17 ));
L536: (( dom ( Swap (R17 , R10 , R11) ) ) = ( dom R17 ) & ( dom ( Swap (R17 , R11 , R10) ) ) = ( dom R17 )) by FUNCT_7:99;
L537:
now
let R12 being set;
assume that
L538: R12 in ( dom R17 );
per cases ;
suppose L539: (R12 = R10 & R12 = R11);

thus L540: ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( ( Swap (R17 , R11 , R10) ) . R12 ) by L539;
end;
suppose L541: (R12 = R10 & R12 <> R11);

L542: (( ( Swap (R17 , R10 , R11) ) . R12 ) = ( R17 . R11 ) & ( ( Swap (R17 , R11 , R10) ) . R12 ) = ( R17 . R11 )) by L541 , L535 , L500 , L513;
thus L543: ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( ( Swap (R17 , R11 , R10) ) . R12 ) by L542;
end;
suppose L544: (R12 <> R10 & R12 = R11);

L545: (( ( Swap (R17 , R10 , R11) ) . R12 ) = ( R17 . R10 ) & ( ( Swap (R17 , R11 , R10) ) . R12 ) = ( R17 . R10 )) by L544 , L535 , L500 , L513;
thus L546: ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( ( Swap (R17 , R11 , R10) ) . R12 ) by L545;
end;
suppose L547: (R12 <> R10 & R12 <> R11);

L548: (( ( Swap (R17 , R10 , R11) ) . R12 ) = ( R17 . R12 ) & ( ( Swap (R17 , R11 , R10) ) . R12 ) = ( R17 . R12 )) by L547 , L522;
thus L549: ( ( Swap (R17 , R10 , R11) ) . R12 ) = ( ( Swap (R17 , R11 , R10) ) . R12 ) by L548;
end;
end;
thus L551: ( Swap (R17 , R10 , R11) ) = ( Swap (R17 , R11 , R10) ) by L537 , L536 , FUNCT_1:2;
end;
registration
let C52 being non  empty set;
cluster  onto for C52 -valued non  empty C52 -valued non  empty C52 -valued non  empty C52 -valued non  empty Function;
existence
proof
take ( id C52 );
thus L552: thesis;
end;
end;
registration
let C53 being non  empty set;
let C54 being  onto C53 -valued non  empty Function;
let C55 , C56 being (Element of ( dom C54 ));
cluster ( Swap (C54 , C55 , C56) ) ->  onto;
coherence
proof
L554: ( rng ( Swap (C54 , C55 , C56) ) ) = ( rng C54 ) by FUNCT_7:103;
thus L555: ( rng ( Swap (C54 , C55 , C56) ) ) = C53 by L554 , FUNCT_2:def 3;
end;
end;
registration
let R19 being array;
let R10 being set;
let R11 being set;
cluster ( Swap (R19 , R10 , R11) ) ->  segmental;
coherence
proof
consider R2 being  ordinal number, R3 being  ordinal number such that L557: ( dom R19 ) = ( R2 \ R3 ) by L101;
take R2;
take R3;
thus L558: thesis by L557 , FUNCT_7:99;
end;
end;
theorem
L560: (for R10 being set holds (for R11 being set holds (for R19 being array holds ((R10 in ( dom R19 ) & R11 in ( dom R19 )) implies ( Swap (( Swap (R19 , R10 , R11) ) , R10 , R11) ) = R19))))
proof
let R10 being set;
let R11 being set;
let R19 being array;
assume L561: (R10 in ( dom R19 ) & R11 in ( dom R19 ));
set D53 = ( Swap (R19 , R10 , R11) );
set D54 = ( Swap (D53 , R10 , R11) );
L562: (( dom D54 ) = ( dom D53 ) & ( dom D53 ) = ( dom R19 )) by FUNCT_7:99;
L563:
now
let R12 being set;
assume L564: R12 in ( dom D53 );
per cases ;
suppose L565: (R12 <> R10 & R12 <> R11);

thus L566: ( D54 . R12 ) = ( D53 . R12 ) by L565 , L522
.= ( R19 . R12 ) by L565 , L522;
end;
suppose L567: R12 = R10;

thus L568: ( D54 . R12 ) = ( D53 . R11 ) by L567 , L561 , L562 , L500
.= ( R19 . R12 ) by L561 , L567 , L513;
end;
suppose L569: R12 = R11;

thus L570: ( D54 . R12 ) = ( D53 . R10 ) by L569 , L561 , L562 , L513
.= ( R19 . R12 ) by L561 , L569 , L500;
end;
end;
thus L572: D54 = R19 by L563 , L562 , FUNCT_1:2;
end;
registration
let C57 being  real-valued array;
let R10 being set;
let R11 being set;
cluster ( Swap (C57 , R10 , R11) ) ->  real-valued for array;
coherence
proof
let C58 being array;
assume L573: C58 = ( Swap (C57 , R10 , R11) );
let R12 being set;
assume L574: R12 in ( dom C58 );
L575: (R12 in ( dom C57 ) & (R10 = R12 or R10 <> R12) & (R11 = R12 or R11 <> R12)) by L574 , L573 , FUNCT_7:99;
L576: (((not R10 in ( dom C57 )) or (not R11 in ( dom C57 ))) implies C58 = C57) by L573 , FUNCT_7:def 12;
L577: (( C58 . R12 ) = ( C57 . R11 ) or ( C58 . R12 ) = ( C57 . R10 ) or ( C58 . R12 ) = ( C57 . R12 )) by L576 , L573 , L575 , L500 , L513 , L522;
thus L578: thesis by L577;
end;
end;
begin
definition
let C59 being array;
mode permutation of C59
 -> array
means :L580: (ex B19 being (Permutation of ( dom C59 )) st it = ( C59 * B19 ));
existence
proof
take C59;
take ( id ( dom C59 ) );
thus L581: thesis by RELAT_1:51;
end;
end;
theorem
L583: (for R19 being array holds (for B20 being (permutation of R19) holds (( dom B20 ) = ( dom R19 ) & ( rng B20 ) = ( rng R19 ))))
proof
let R19 being array;
let C60 being (permutation of R19);
consider C61 being (Permutation of ( dom R19 )) such that L584: C60 = ( R19 * C61 ) by L580;
L585: (( dom R19 ) <> ( {} ) implies ( dom R19 ) <> ( {} ));
L586: (( rng C61 ) = ( dom R19 ) & ( dom C61 ) = ( dom R19 )) by L585 , FUNCT_2:def 1 , FUNCT_2:def 3;
thus L587: thesis by L586 , L584 , RELAT_1:27 , RELAT_1:28;
end;
theorem
L588: (for R19 being array holds R19 is (permutation of R19))
proof
let R19 being array;
take ( id ( dom R19 ) );
thus L589: thesis by RELAT_1:51;
end;
theorem
L590: (for R19 being array holds (for R20 being array holds (R19 is (permutation of R20) implies R20 is (permutation of R19))))
proof
let R19 being array;
let R20 being array;
assume L591: R19 is (permutation of R20);
L592: ( dom R19 ) = ( dom R20 ) by L591 , L583;
consider C62 being (Permutation of ( dom R20 )) such that L593: R19 = ( R20 * C62 ) by L591 , L580;
reconsider D55 = ( C62 " ) as (Permutation of ( dom R19 )) by L592;
take D55;
thus L594: R20 = ( R20 * ( id ( dom R20 ) ) ) by RELAT_1:52
.= ( R20 * ( C62 * D55 ) ) by FUNCT_2:61
.= ( R19 * D55 ) by L593 , RELAT_1:36;
end;
theorem
L595: (for R19 being array holds (for R20 being array holds (for R21 being array holds ((R19 is (permutation of R20) & R20 is (permutation of R21)) implies R19 is (permutation of R21)))))
proof
let R19 being array;
let R20 being array;
let R21 being array;
assume L596: (R19 is (permutation of R20) & R20 is (permutation of R21));
L597: ( dom R21 ) = ( dom R20 ) by L596 , L583;
consider C63 being (Permutation of ( dom R20 )) such that L598: R19 = ( R20 * C63 ) by L596 , L580;
consider C64 being (Permutation of ( dom R21 )) such that L599: R20 = ( R21 * C64 ) by L596 , L580;
reconsider D56 = ( C64 * C63 ) as (Permutation of ( dom R21 )) by L597;
take D56;
thus L600: R19 = ( R21 * D56 ) by L598 , L599 , RELAT_1:36;
end;
theorem
L601: (for R10 being set holds (for R11 being set holds (for R14 being set holds ( Swap (( id R14 ) , R10 , R11) ) is  one-to-one)))
proof
let R10 being set;
let R11 being set;
let R14 being set;
L602: ( dom ( id R14 ) ) = R14;
per cases ;
suppose L603: (R10 in R14 & R11 in R14);

set D57 = ( id R14 );
set D58 = ( Swap (D57 , R10 , R11) );
let R12 being set;
let R13 being set;
assume L604: (R12 in ( dom D58 ) & R13 in ( dom D58 ) & ( D58 . R12 ) = ( D58 . R13 ));
L605: (( D57 . R12 ) = R12 & ( D57 . R13 ) = R13 & ( D57 . R10 ) = R10 & ( D57 . R11 ) = R11) by L603 , L604 , FUNCT_1:17;
L606: ((R12 = R10 implies ( D58 . R12 ) = R11) & (R12 = R11 implies ( D58 . R12 ) = R10) & ((R12 <> R10 & R12 <> R11) implies ( D58 . R12 ) = R12)) by L605 , L603 , L602 , L500 , L513 , L522;
L607: ((R13 = R10 implies ( D58 . R13 ) = R11) & (R13 = R11 implies ( D58 . R13 ) = R10) & ((R13 <> R10 & R13 <> R11) implies ( D58 . R13 ) = R13)) by L603 , L602 , L605 , L500 , L513 , L522;
thus L608: R12 = R13 by L607 , L604 , L606;
end;
suppose L609: (not (R10 in R14 & R11 in R14));

thus L610: thesis by L609 , L602 , FUNCT_7:def 12;
end;
end;
registration
let C65 being non  empty set;
let C66 , C67 being (Element of C65);
cluster ( Swap (( id C65 ) , C66 , C67) ) ->  one-to-one C65 -valued C65 -defined;
coherence by L601;
end;
registration
let C68 being non  empty set;
let C69 , C70 being (Element of C68);
cluster ( Swap (( id C68 ) , C69 , C70) ) ->  onto  total;
coherence
proof
L613: ( dom ( id C68 ) ) = C68;
reconsider D59 = C69 , D60 = C70 as (Element of ( dom ( id C68 ) ));
L614: ( Swap (( id C68 ) , D59 , D60) ) is  onto;
thus L615: ( Swap (( id C68 ) , C69 , C70) ) is  onto by L614;
thus L616: ( dom ( Swap (( id C68 ) , C69 , C70) ) ) = C68 by L613 , FUNCT_7:99;
end;
end;
definition
let C71 , C72 being non  empty set;
let C73 being (Function of C71 , C72);
let C74 , C75 being (Element of C71);
redefine func Swap (C73 , C74 , C75) -> (Function of C71 , C72);

coherence
proof
set D61 = ( Swap (C73 , C74 , C75) );
L618: ( dom C73 ) = C71 by FUNCT_2:def 1;
L619: (( dom D61 ) = ( dom C73 ) & ( rng D61 ) = ( rng C73 )) by FUNCT_7:99 , FUNCT_7:103;
L620: ( rng C73 ) c= C72 by RELAT_1:def 19;
thus L621: thesis by L620 , L618 , L619 , FUNCT_2:2;
end;
end;
theorem
L623: (for R10 being set holds (for R11 being set holds (for R14 being set holds (for R17 being Function holds (for R19 being array holds ((R10 in R14 & R11 in R14 & R17 = ( Swap (( id R14 ) , R10 , R11) ) & R14 = ( dom R19 )) implies ( Swap (R19 , R10 , R11) ) = ( R19 * R17 )))))))
proof
let R10 being set;
let R11 being set;
let R14 being set;
let R17 being Function;
let R19 being array;
assume that
L624: (R10 in R14 & R11 in R14)
and
L625: (R17 = ( Swap (( id R14 ) , R10 , R11) ) & R14 = ( dom R19 ));
set D62 = ( id R14 );
set D63 = ( Swap (R19 , R10 , R11) );
L626: (( dom D62 ) = R14 & ( rng D62 ) = R14);
L627: (( dom R17 ) = R14 & ( rng R17 ) = R14) by L626 , L625 , FUNCT_7:99 , FUNCT_7:103;
L628: ( dom D63 ) = ( dom R19 ) by FUNCT_7:99;
L629: ( dom ( R19 * R17 ) ) = ( dom R17 ) by L625 , L627 , RELAT_1:27;
L630:
now
let R12 being set;
assume L631: R12 in R14;
L632: (( D62 . R10 ) = R10 & ( D62 . R11 ) = R11 & ( D62 . R12 ) = R12) by L624 , L631 , FUNCT_1:17;
L633: (R12 = R10 or R12 = R11 or (R12 <> R10 & R12 <> R11));
L634: ((( D63 . R12 ) = ( R19 . R11 ) & ( R17 . R12 ) = ( D62 . R11 )) or (( D63 . R12 ) = ( R19 . R10 ) & ( R17 . R12 ) = ( D62 . R10 )) or (( D63 . R12 ) = ( R19 . R12 ) & ( R17 . R12 ) = ( D62 . R12 ))) by L633 , L624 , L625 , L626 , L500 , L513 , L522;
thus L635: ( D63 . R12 ) = ( ( R19 * R17 ) . R12 ) by L634 , L631 , L632 , L627 , FUNCT_1:13;
end;
thus L636: ( Swap (R19 , R10 , R11) ) = ( R19 * R17 ) by L630 , L625 , L627 , L628 , L629 , FUNCT_1:2;
end;
theorem
L637: (for R10 being set holds (for R11 being set holds (for R19 being array holds ((R10 in ( dom R19 ) & R11 in ( dom R19 )) implies (( Swap (R19 , R10 , R11) ) is (permutation of R19) & R19 is (permutation of ( Swap (R19 , R10 , R11) )))))))
proof
let R10 being set;
let R11 being set;
let R19 being array;
set D64 = ( dom R19 );
assume L638: (R10 in D64 & R11 in D64);
thus L639: ( Swap (R19 , R10 , R11) ) is (permutation of R19)
proof
reconsider D65 = D64 as non  empty set by L638;
reconsider D66 = R10 , D67 = R11 as (Element of D65) by L638;
reconsider D68 = ( Swap (( id D65 ) , D66 , D67) ) as (Permutation of ( dom R19 ));
take D68;
thus L640: thesis by L623;
end;

thus L641: R19 is (permutation of ( Swap (R19 , R10 , R11) )) by L639 , L590;
end;
theorem
L642: (for R10 being set holds (for R11 being set holds (for R19 being array holds (for R20 being array holds ((R10 in ( dom R19 ) & R11 in ( dom R19 ) & R19 is (permutation of R20)) implies (( Swap (R19 , R10 , R11) ) is (permutation of R20) & R19 is (permutation of ( Swap (R20 , R10 , R11) ))))))))
proof
let R10 being set;
let R11 being set;
let R19 being array;
let R20 being array;
set D69 = ( dom R19 );
assume L643: (R10 in D69 & R11 in D69 & R19 is (permutation of R20));
L644: D69 = ( dom R20 ) by L643 , L583;
L645: (( Swap (R19 , R10 , R11) ) is (permutation of R19) & R20 is (permutation of ( Swap (R20 , R10 , R11) ))) by L644 , L643 , L637;
thus L646: thesis by L645 , L643 , L595;
end;
begin
definition
let C76 being RelStr;
let C77 being (array of C76);
attr C77 is  ascending
means
(for R1 being  ordinal number holds (for R4 being  ordinal number holds ((R1 in ( dom C77 ) & R4 in ( dom C77 ) & R1 in R4) implies ( C77 /. R1 ) <= ( C77 /. R4 ))));
func inversions C77 equals 
{ [ B21 , B22 ] where B21 , B22 is (Element of ( dom C77 )) : (B21 in B22 & (not ( C77 /. B21 ) <= ( C77 /. B22 ))) };
coherence;
end;
registration
let C78 being RelStr;
cluster  ->  ascending for  empty  empty  empty  empty (array of C78);
coherence
proof
let C79 being  empty (array of C78);
let R1 being  ordinal number;
thus L648: thesis;
end;
let C80 being  empty (array of C78);
cluster ( inversions C80 ) ->  empty;
coherence
proof
set D70 = the (Element of ( inversions C80 ));
assume L649: ( inversions C80 ) is non  empty;
L650: D70 in ( inversions C80 ) by L649;
consider C81 , C82 being (Element of ( dom C80 )) such that L651: (D70 = [ C81 , C82 ] & C81 in C82 & (not ( C80 /. C81 ) <= ( C80 /. C82 ))) by L650;
thus L652: thesis by L651 , SUBSET_1:def 1;
end;
end;
theorem
L654: (for R22 being  connected non  empty Poset holds (for B23 , B24 being (Element of R22) holds (B23 > B24 iff (not B23 <= B24))))
proof
let R22 being  connected non  empty Poset;
let C83 , C84 being (Element of R22);
L655: ((C83 <= C84 & C84 <= C83) implies C83 = C84) by YELLOW_0:def 3;
L656: ((C83 <= C84 or C83 >= C84) & C83 <= C83) by WAYBEL_0:def 29;
thus L657: (C83 > C84 iff (not C83 <= C84)) by L656 , L655 , ORDERS_2:def 6;
end;
definition
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
redefine func inversions R23 equals 
{ [ B25 , B26 ] where B25 , B26 is (Element of ( dom R23 )) : (B25 in B26 & ( R23 /. B25 ) > ( R23 /. B26 )) };
compatibility
proof
set D71 = { [ B27 , B28 ] where B27 , B28 is (Element of ( dom R23 )) : (B27 in B28 & ( R23 /. B27 ) > ( R23 /. B28 )) };
L658: ( inversions R23 ) = D71
proof
thus L659: ( inversions R23 ) c= D71
proof
let R10 being set;
assume L660: R10 in ( inversions R23 );
consider C85 , C86 being (Element of ( dom R23 )) such that L661: (R10 = [ C85 , C86 ] & C85 in C86 & (not ( R23 /. C85 ) <= ( R23 /. C86 ))) by L660;
L662: ( R23 /. C85 ) > ( R23 /. C86 ) by L661 , L654;
thus L663: thesis by L662 , L661;
end;

let R10 being set;
assume L664: R10 in D71;
consider C87 , C88 being (Element of ( dom R23 )) such that L665: (R10 = [ C87 , C88 ] & C87 in C88 & ( R23 /. C87 ) > ( R23 /. C88 )) by L664;
L666: (not ( R23 /. C87 ) <= ( R23 /. C88 )) by L665 , L654;
thus L667: thesis by L666 , L665;
end;
thus L668: thesis by L658;
end;
end;
theorem
L670: (for R10 being set holds (for R11 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) iff (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )))))))
proof
let R10 being set;
let R11 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
thus L671:now
assume L672: [ R10 , R11 ] in ( inversions R23 );
reconsider D72 = R23 as non  empty Function by L672;
consider C89 , C90 being (Element of ( dom D72 )) such that L673: ([ R10 , R11 ] = [ C89 , C90 ] & C89 in C90 & (not ( R23 /. C89 ) <= ( R23 /. C90 ))) by L672;
L674: (R10 = C89 & R11 = C90) by L673 , XTUPLE_0:1;
thus L675: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L674 , L673 , L654;
end;
thus L676: thesis;
end;
theorem
L677: (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ( inversions R23 ) c= [: ( dom R23 ) , ( dom R23 ) :]))
proof
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let R10 being set;
assume L678: R10 in ( inversions R23 );
consider C91 , C92 being (Element of ( dom R23 )) such that L679: (R10 = [ C91 , C92 ] & C91 in C92 & ( R23 /. C91 ) > ( R23 /. C92 )) by L678;
L680: (C91 in ( dom R23 ) & C92 in ( dom R23 )) by L679 , L678 , L670;
thus L681: thesis by L680 , L679 , ZFMISC_1:def 2;
end;
registration
let R22 being  connected non  empty Poset;
let C93 being  finite (array of R22);
cluster ( inversions C93 ) ->  finite;
coherence
proof
L682: ( inversions C93 ) c= [: ( dom C93 ) , ( dom C93 ) :] by L677;
thus L683: thesis by L682;
end;
end;
theorem
L685: (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (R23 is  ascending iff ( inversions R23 ) = ( {} ))))
proof
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
thus L686: (R23 is  ascending implies ( inversions R23 ) = ( {} ))
proof
assume L687: (for R1 being  ordinal number holds (for R4 being  ordinal number holds ((R1 in ( dom R23 ) & R4 in ( dom R23 ) & R1 in R4) implies ( R23 /. R1 ) <= ( R23 /. R4 ))));
set D73 = the (Element of ( inversions R23 ));
assume L688: ( inversions R23 ) <> ( {} );
L689: D73 in ( inversions R23 ) by L688;
consider C94 , C95 being (Element of ( dom R23 )) such that L690: (D73 = [ C94 , C95 ] & C94 in C95 & ( R23 /. C94 ) > ( R23 /. C95 )) by L689;
L691: R23 <> ( {} ) by L688;
L692: ( R23 /. C94 ) <= ( R23 /. C95 ) by L691 , L687 , L690;
thus L693: thesis by L692 , L690 , L654;
end;

assume L694: ( inversions R23 ) = ( {} );
let R1 being  ordinal number;
let R4 being  ordinal number;
assume L695: (R1 in ( dom R23 ) & R4 in ( dom R23 ) & R1 in R4);
L696: (( R23 /. R1 ) > ( R23 /. R4 ) implies [ R1 , R4 ] in ( inversions R23 )) by L695;
thus L697: thesis by L696 , L694 , L654;
end;
theorem
L698: (for R10 being set holds (for R11 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) implies [ R11 , R10 ] nin ( inversions R23 ))))))
proof
let R10 being set;
let R11 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L699: [ R10 , R11 ] in ( inversions R23 );
L700: R11 nin R10 by L699 , L670;
thus L701: [ R11 , R10 ] nin ( inversions R23 ) by L700 , L670;
end;
theorem
L702: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (([ R10 , R11 ] in ( inversions R23 ) & [ R11 , R12 ] in ( inversions R23 )) implies [ R10 , R12 ] in ( inversions R23 )))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L703: ([ R10 , R11 ] in ( inversions R23 ) & [ R11 , R12 ] in ( inversions R23 ));
reconsider D74 = R10 , D75 = R11 , D76 = R12 as (Element of ( dom R23 )) by L703 , L670;
L704: (D74 in D75 & ( R23 /. D74 ) > ( R23 /. D75 ) & D75 in D76 & ( R23 /. D75 ) > ( R23 /. D76 )) by L703 , L670;
L705: (D74 in D76 & ( R23 /. D74 ) > ( R23 /. D76 )) by L704 , ORDERS_2:5 , ORDINAL1:10;
thus L706: thesis by L705;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
cluster ( inversions R23 ) ->  Relation-like;
coherence
proof
L707: ( inversions R23 ) c= [: ( dom R23 ) , ( dom R23 ) :] by L677;
thus L708: thesis by L707;
end;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
cluster ( inversions R23 ) ->  asymmetric  transitive for Relation;
coherence
proof
let C96 being Relation;
assume L710: C96 = ( inversions R23 );
thus L711: C96 is  asymmetric
proof
let R10 being set;
let R11 being set;
thus L712: thesis by L710 , L698;
end;

let R10 being set;
let R11 being set;
thus L713: thesis by L710 , L702;
end;
end;
definition
let R22 being  connected non  empty Poset;
let C97 , C98 being (Element of R22);
redefine pred C97 < C98
;
asymmetry
 by ORDERS_2:5;
end;
theorem
L716: (for R10 being set holds (for R11 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) implies [ R10 , R11 ] nin ( inversions ( Swap (R23 , R10 , R11) ) ))))))
proof
let R10 being set;
let R11 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L717: [ R10 , R11 ] in ( inversions R23 );
L718: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & ( R23 /. R10 ) > ( R23 /. R11 )) by L717 , L670;
L719: (not ( R23 /. R10 ) < ( R23 /. R11 )) by L717 , L670;
L720: (( ( Swap (R23 , R10 , R11) ) /. R10 ) = ( R23 /. R11 ) & ( ( Swap (R23 , R10 , R11) ) /. R11 ) = ( R23 /. R10 )) by L718 , L509 , L518;
thus L721: [ R10 , R11 ] nin ( inversions ( Swap (R23 , R10 , R11) ) ) by L720 , L719 , L670;
end;
theorem
L722: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R13 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ((R10 in ( dom R23 ) & R11 in ( dom R23 ) & R12 <> R10 & R12 <> R11 & R13 <> R10 & R13 <> R11) implies ([ R12 , R13 ] in ( inversions R23 ) iff [ R12 , R13 ] in ( inversions ( Swap (R23 , R10 , R11) ) )))))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R13 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
set D77 = ( Swap (R23 , R10 , R11) );
assume L723: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R12 <> R10 & R12 <> R11 & R13 <> R10 & R13 <> R11);
L724: ((R12 in ( dom R23 ) implies ( D77 /. R12 ) = ( R23 /. R12 )) & (R13 in ( dom R23 ) implies ( D77 /. R13 ) = ( R23 /. R13 )) & ( dom D77 ) = ( dom R23 )) by L723 , L530 , FUNCT_7:99;
thus L725:now
assume L726: [ R12 , R13 ] in ( inversions R23 );
L727: (R12 in ( dom R23 ) & R13 in ( dom R23 ) & R12 in R13 & ( R23 /. R12 ) > ( R23 /. R13 )) by L726 , L670;
thus L728: [ R12 , R13 ] in ( inversions ( Swap (R23 , R10 , R11) ) ) by L727 , L724;
end;
assume L729: [ R12 , R13 ] in ( inversions ( Swap (R23 , R10 , R11) ) );
L730: (R12 in ( dom R23 ) & R13 in ( dom R23 ) & R12 in R13 & ( D77 /. R12 ) > ( D77 /. R13 )) by L729 , L724 , L670;
thus L731: thesis by L730 , L724;
end;
theorem
L732: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) implies (([ R12 , R11 ] in ( inversions R23 ) & R12 in R10) iff [ R12 , R10 ] in ( inversions ( Swap (R23 , R10 , R11) ) ))))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
set D78 = ( Swap (R23 , R10 , R11) );
assume L733: [ R10 , R11 ] in ( inversions R23 );
L734: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L733 , L670;
L735: (( D78 /. R10 ) = ( R23 /. R11 ) & ( D78 /. R11 ) = ( R23 /. R10 ) & ( dom D78 ) = ( dom R23 )) by L734 , L509 , L518 , FUNCT_7:99;
thus L736:now
assume L737: ([ R12 , R11 ] in ( inversions R23 ) & R12 in R10);
L738: (R12 in ( dom R23 ) & R12 in R11 & ( R23 /. R12 ) > ( R23 /. R11 )) by L737 , L670;
L739: (R10 <> R12 & R11 <> R12) by L738 , L737;
L740: ( D78 /. R12 ) = ( R23 /. R12 ) by L739 , L738 , L530;
thus L741: [ R12 , R10 ] in ( inversions ( Swap (R23 , R10 , R11) ) ) by L740 , L737 , L734 , L735 , L738;
end;
assume L742: [ R12 , R10 ] in ( inversions ( Swap (R23 , R10 , R11) ) );
L743: (R12 in ( dom R23 ) & R12 in R10 & ( D78 /. R12 ) > ( D78 /. R10 )) by L742 , L735 , L670;
L744: R12 in R11 by L743 , L734 , ORDINAL1:10;
L745: ( D78 /. R12 ) = ( R23 /. R12 ) by L734 , L743 , L530;
thus L746: thesis by L745 , L734 , L735 , L743 , L744;
end;
theorem
L747: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) implies ([ R12 , R10 ] in ( inversions R23 ) iff (R12 in R10 & [ R12 , R11 ] in ( inversions ( Swap (R23 , R10 , R11) ) )))))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L748: [ R10 , R11 ] in ( inversions R23 );
L749: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L748 , L670;
L750: ( dom ( Swap (R23 , R10 , R11) ) ) = ( dom R23 ) by FUNCT_7:99;
thus L751:now
assume L752: [ R12 , R10 ] in ( inversions R23 );
L753: (R12 in ( dom R23 ) & R12 in R10 & ( R23 /. R12 ) > ( R23 /. R10 )) by L752 , L670;
L754: R12 in R11 by L753 , L749 , ORDINAL1:10;
L755: (( ( Swap (R23 , R10 , R11) ) /. R11 ) = ( R23 /. R10 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L749 , L753 , L518 , L530;
thus L756: (R12 in R10 & [ R12 , R11 ] in ( inversions ( Swap (R23 , R10 , R11) ) )) by L755 , L749 , L750 , L753 , L754;
end;
assume L757: (R12 in R10 & [ R12 , R11 ] in ( inversions ( Swap (R23 , R10 , R11) ) ));
L758: (R12 in ( dom R23 ) & R12 in R11 & ( ( Swap (R23 , R10 , R11) ) /. R12 ) > ( ( Swap (R23 , R10 , R11) ) /. R11 )) by L757 , L750 , L670;
L759: (R12 <> R10 & R12 <> R11) by L758 , L757;
L760: (( ( Swap (R23 , R10 , R11) ) /. R11 ) = ( R23 /. R10 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L759 , L749 , L758 , L518 , L530;
thus L761: [ R12 , R10 ] in ( inversions R23 ) by L760 , L749 , L758 , L757;
end;
theorem
L762: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (([ R10 , R11 ] in ( inversions R23 ) & R12 in R11 & [ R10 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) )) implies [ R10 , R12 ] in ( inversions R23 )))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L763: [ R10 , R11 ] in ( inversions R23 );
L764: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L763 , L670;
L765: ( dom ( Swap (R23 , R10 , R11) ) ) = ( dom R23 ) by FUNCT_7:99;
assume L766: R12 in R11;
assume L767: [ R10 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) );
L768: (R12 in ( dom R23 ) & R10 in R12 & ( ( Swap (R23 , R10 , R11) ) /. R10 ) > ( ( Swap (R23 , R10 , R11) ) /. R12 )) by L767 , L765 , L670;
L769: (R12 <> R10 & R12 <> R11) by L768 , L766;
L770: (( ( Swap (R23 , R10 , R11) ) /. R10 ) = ( R23 /. R11 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L769 , L764 , L768 , L509 , L530;
L771: ( R23 /. R10 ) > ( R23 /. R12 ) by L770 , L764 , L768 , ORDERS_2:5;
thus L772: [ R10 , R12 ] in ( inversions R23 ) by L771 , L764 , L768;
end;
theorem
L773: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (([ R10 , R11 ] in ( inversions R23 ) & R10 in R12 & [ R12 , R11 ] in ( inversions ( Swap (R23 , R10 , R11) ) )) implies [ R12 , R11 ] in ( inversions R23 )))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L774: [ R10 , R11 ] in ( inversions R23 );
L775: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L774 , L670;
L776: ( dom ( Swap (R23 , R10 , R11) ) ) = ( dom R23 ) by FUNCT_7:99;
assume L777: R10 in R12;
assume L778: [ R12 , R11 ] in ( inversions ( Swap (R23 , R10 , R11) ) );
L779: (R12 in ( dom R23 ) & R12 in R11 & ( ( Swap (R23 , R10 , R11) ) /. R12 ) > ( ( Swap (R23 , R10 , R11) ) /. R11 )) by L778 , L776 , L670;
L780: (R12 <> R10 & R12 <> R11) by L779 , L777;
L781: (( ( Swap (R23 , R10 , R11) ) /. R11 ) = ( R23 /. R10 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L780 , L775 , L779 , L518 , L530;
L782: ( R23 /. R12 ) > ( R23 /. R11 ) by L781 , L775 , L779 , ORDERS_2:5;
thus L783: [ R12 , R11 ] in ( inversions R23 ) by L782 , L775 , L779;
end;
theorem
L784: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (([ R10 , R11 ] in ( inversions R23 ) & R11 in R12 & [ R10 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) )) implies [ R11 , R12 ] in ( inversions R23 )))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L785: [ R10 , R11 ] in ( inversions R23 );
L786: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L785 , L670;
L787: ( dom ( Swap (R23 , R10 , R11) ) ) = ( dom R23 ) by FUNCT_7:99;
assume L788: R11 in R12;
assume L789: [ R10 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) );
L790: (R12 in ( dom R23 ) & R10 in R12 & ( ( Swap (R23 , R10 , R11) ) /. R10 ) > ( ( Swap (R23 , R10 , R11) ) /. R12 )) by L789 , L787 , L670;
L791: (R12 <> R10 & R12 <> R11) by L790 , L788;
L792: (( ( Swap (R23 , R10 , R11) ) /. R10 ) = ( R23 /. R11 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L791 , L786 , L790 , L509 , L530;
thus L793: [ R11 , R12 ] in ( inversions R23 ) by L792 , L786 , L790 , L788;
end;
theorem
L794: (for R10 being set holds (for R11 being set holds (for R12 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) implies ((R11 in R12 & [ R10 , R12 ] in ( inversions R23 )) iff [ R11 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) ))))))))
proof
let R10 being set;
let R11 being set;
let R12 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L795: [ R10 , R11 ] in ( inversions R23 );
L796: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L795 , L670;
L797: ( dom ( Swap (R23 , R10 , R11) ) ) = ( dom R23 ) by FUNCT_7:99;
thus L798:now
assume L799: (R11 in R12 & [ R10 , R12 ] in ( inversions R23 ));
L800: (R12 in ( dom R23 ) & R10 in R12 & ( R23 /. R12 ) < ( R23 /. R10 )) by L799 , L670;
L801: (R12 <> R10 & R12 <> R11) by L800 , L799;
L802: (( ( Swap (R23 , R10 , R11) ) /. R11 ) = ( R23 /. R10 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L801 , L796 , L800 , L518 , L530;
thus L803: [ R11 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) ) by L802 , L796 , L797 , L800 , L799;
end;
assume L804: [ R11 , R12 ] in ( inversions ( Swap (R23 , R10 , R11) ) );
L805: (R12 in ( dom R23 ) & R11 in R12 & ( ( Swap (R23 , R10 , R11) ) /. R11 ) > ( ( Swap (R23 , R10 , R11) ) /. R12 )) by L804 , L797 , L670;
L806: R10 in R12 by L805 , L796 , ORDINAL1:10;
L807: (( ( Swap (R23 , R10 , R11) ) /. R11 ) = ( R23 /. R10 ) & ( ( Swap (R23 , R10 , R11) ) /. R12 ) = ( R23 /. R12 )) by L796 , L518 , L530 , L805;
thus L808: thesis by L807 , L796 , L805 , L806;
end;
definition
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let R10 being set;
let R11 being set;
func (R23 , R10 , R11) incl -> Function equals 
( [: ( Swap (( id ( dom R23 ) ) , R10 , R11) ) , ( Swap (( id ( dom R23 ) ) , R10 , R11) ) :] +* ( id ( [: { R10 } , ( ( succ R11 ) \ R10 ) :] \/ [: ( ( succ R11 ) \ R10 ) , { R11 } :] ) ) );
coherence;
end;
theorem
L810: (for R1 being  ordinal number holds (for R4 being  ordinal number holds (for R5 being  ordinal number holds (R5 in ( ( succ R4 ) \ R1 ) iff (R1 c= R5 & R5 c= R4)))))
proof
let R1 being  ordinal number;
let R4 being  ordinal number;
let R5 being  ordinal number;
L811: (R1 c= R5 iff R5 nin R1) by ORDINAL6:4;
L812: (R5 in ( ( succ R4 ) \ R1 ) iff (R5 in ( succ R4 ) & R1 c= R5)) by L811 , XBOOLE_0:def 5;
thus L813: thesis by L812 , ORDINAL1:22;
end;
theorem
L814: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds ( ( succ R27 ) \ R26 ) c= ( dom R25 )))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R10 being set;
assume L815: R10 in ( ( succ R27 ) \ R26 );
L816: (R26 c= R10 & R10 c= R27) by L815 , L810;
consider R1 being  ordinal number, R4 being  ordinal number such that L817: ( dom R25 ) = ( R1 \ R4 ) by L101;
L818: (R27 in R1 & R26 nin R4) by L817 , XBOOLE_0:def 5;
L819: (R10 in R1 & R10 nin R4) by L818 , L815 , L816 , ORDINAL1:12;
thus L820: thesis by L819 , L817 , XBOOLE_0:def 5;
end;
theorem
L821: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (( dom ( (R25 , R26 , R27) incl ) ) = [: ( dom R25 ) , ( dom R25 ) :] & ( rng ( (R25 , R26 , R27) incl ) ) c= [: ( dom R25 ) , ( dom R25 ) :])))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
set D79 = ( dom R25 );
set D80 = ( id D79 );
set D81 = ( Swap (D80 , R26 , R27) );
set D82 = [: D81 , D81 :];
set D83 = ( ( succ R27 ) \ R26 );
set D84 = [: { R26 } , D83 :];
set D85 = [: D83 , { R27 } :];
set D86 = ( id ( D84 \/ D85 ) );
L822: ( dom D80 ) = D79;
L823: ( dom D81 ) = D79 by L822 , FUNCT_7:99;
L824: ({ R26 } c= D79 & { R27 } c= D79 & D83 c= D79) by L814 , ZFMISC_1:31;
L825: ( [: D79 , D79 :] \/ ( D84 \/ D85 ) ) = ( ( [: D79 , D79 :] \/ D84 ) \/ D85 ) by XBOOLE_1:4
.= ( [: D79 , D79 :] \/ D85 ) by L824 , XBOOLE_1:12 , ZFMISC_1:96
.= [: D79 , D79 :] by L824 , XBOOLE_1:12 , ZFMISC_1:96;
thus L826: ( dom ( (R25 , R26 , R27) incl ) ) = ( ( dom D82 ) \/ ( dom D86 ) ) by FUNCT_4:def 1
.= ( ( dom D82 ) \/ ( D84 \/ D85 ) )
.= [: D79 , D79 :] by L823 , L825 , FUNCT_3:def 8;
L827: (( rng D86 ) = ( D84 \/ D85 ) & ( rng D80 ) = D79);
L828: ( rng D81 ) = D79 by L827 , FUNCT_7:103;
L829: ( rng D82 ) = [: D79 , D79 :] by L828 , FUNCT_3:67;
thus L830: ( rng ( (R25 , R26 , R27) incl ) ) c= [: D79 , D79 :] by L829 , L825 , L827 , FUNCT_4:17;
end;
theorem
L831: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R28 being (Element of ( dom R25 )) holds ((R26 c= R28 & R28 c= R27) implies (( ( (R25 , R26 , R27) incl ) . (R26 , R28) ) = [ R26 , R28 ] & ( ( (R25 , R26 , R27) incl ) . (R28 , R27) ) = [ R28 , R27 ])))))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R28 being (Element of ( dom R25 ));
assume L832: (R26 c= R28 & R28 c= R27);
set D87 = ( ( succ R27 ) \ R26 );
set D88 = [: { R26 } , D87 :];
set D89 = [: D87 , { R27 } :];
set D90 = ( id ( D88 \/ D89 ) );
L833: (R26 in { R26 } & R27 in { R27 } & R28 in D87) by L832 , L810 , TARSKI:def 1;
L834: ([ R26 , R28 ] in D88 & [ R28 , R27 ] in D89) by L833 , ZFMISC_1:def 2;
L835: ([ R26 , R28 ] in ( D88 \/ D89 ) & [ R28 , R27 ] in ( D88 \/ D89 )) by L834 , XBOOLE_0:def 3;
L836: ( dom D90 ) = ( D88 \/ D89 );
thus L837: ( ( (R25 , R26 , R27) incl ) . (R26 , R28) ) = ( D90 . (R26 , R28) ) by L836 , L835 , FUNCT_4:13
.= [ R26 , R28 ] by L835 , FUNCT_1:17;
thus L838: ( ( (R25 , R26 , R27) incl ) . (R28 , R27) ) = ( D90 . (R28 , R27) ) by L835 , L836 , FUNCT_4:13
.= [ R28 , R27 ] by L835 , FUNCT_1:17;
end;
theorem
L839: (for R17 being Function holds (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R28 being (Element of ( dom R25 )) holds (for R29 being (Element of ( dom R25 )) holds ((R28 <> R26 & R29 <> R27 & R17 = ( Swap (( id ( dom R25 ) ) , R26 , R27) )) implies ( ( (R25 , R26 , R27) incl ) . (R28 , R29) ) = [ ( R17 . R28 ) , ( R17 . R29 ) ]))))))))
proof
let R17 being Function;
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R28 being (Element of ( dom R25 ));
let R29 being (Element of ( dom R25 ));
assume that
L840: (R28 <> R26 & R29 <> R27)
and
L841: R17 = ( Swap (( id ( dom R25 ) ) , R26 , R27) );
set D91 = ( ( succ R27 ) \ R26 );
set D92 = [: { R26 } , D91 :];
set D93 = [: D91 , { R27 } :];
set D94 = ( id ( D92 \/ D93 ) );
L842: ( dom R17 ) = ( dom ( id ( dom R25 ) ) ) by L841 , FUNCT_7:99
.= ( dom R25 );
L843: (R28 nin { R26 } & R29 nin { R27 }) by L840 , TARSKI:def 1;
L844: ([ R28 , R29 ] nin D92 & [ R28 , R29 ] nin D93) by L843 , ZFMISC_1:87;
L845: [ R28 , R29 ] nin ( dom D94 ) by L844 , XBOOLE_0:def 3;
thus L846: ( ( (R25 , R26 , R27) incl ) . (R28 , R29) ) = ( [: R17 , R17 :] . (R28 , R29) ) by L845 , L841 , FUNCT_4:11
.= [ ( R17 . R28 ) , ( R17 . R29 ) ] by L842 , FUNCT_3:def 8;
end;
theorem
L847: (for R17 being Function holds (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R28 being (Element of ( dom R25 )) holds ((R28 in R26 & R17 = ( Swap (( id ( dom R25 ) ) , R26 , R27) )) implies (( ( (R25 , R26 , R27) incl ) . (R28 , R27) ) = [ ( R17 . R28 ) , ( R17 . R27 ) ] & ( ( (R25 , R26 , R27) incl ) . (R28 , R26) ) = [ ( R17 . R28 ) , ( R17 . R26 ) ]))))))))
proof
let R17 being Function;
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R28 being (Element of ( dom R25 ));
assume that
L848: R28 in R26
and
L849: R17 = ( Swap (( id ( dom R25 ) ) , R26 , R27) );
set D95 = ( dom R25 );
set D96 = ( id D95 );
set D97 = ( Swap (D96 , R26 , R27) );
set D98 = [: D97 , D97 :];
set D99 = ( ( succ R27 ) \ R26 );
set D100 = [: { R26 } , D99 :];
set D101 = [: D99 , { R27 } :];
set D102 = ( id ( D100 \/ D101 ) );
L850: ( dom D96 ) = D95;
L851: ( dom D97 ) = D95 by L850 , FUNCT_7:99;
L852: (not R26 c= R28) by L848 , ORDINAL6:4;
L853: (R28 nin { R26 } & R28 nin D99) by L852 , L810 , TARSKI:def 1;
L854: ([ R28 , R26 ] nin D100 & [ R28 , R26 ] nin D101 & [ R28 , R27 ] nin D100 & [ R28 , R27 ] nin D101) by L853 , ZFMISC_1:87;
L855: ([ R28 , R27 ] nin ( dom D102 ) & [ R28 , R26 ] nin ( dom D102 )) by L854 , XBOOLE_0:def 3;
thus L856: ( ( (R25 , R26 , R27) incl ) . (R28 , R27) ) = ( D98 . (R28 , R27) ) by L855 , FUNCT_4:11
.= [ ( R17 . R28 ) , ( R17 . R27 ) ] by L849 , L851 , FUNCT_3:def 8;
thus L857: ( ( (R25 , R26 , R27) incl ) . (R28 , R26) ) = ( D98 . (R28 , R26) ) by L855 , FUNCT_4:11
.= [ ( R17 . R28 ) , ( R17 . R26 ) ] by L849 , L851 , FUNCT_3:def 8;
end;
theorem
L858: (for R17 being Function holds (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R28 being (Element of ( dom R25 )) holds ((R27 in R28 & R17 = ( Swap (( id ( dom R25 ) ) , R26 , R27) )) implies (( ( (R25 , R26 , R27) incl ) . (R26 , R28) ) = [ ( R17 . R26 ) , ( R17 . R28 ) ] & ( ( (R25 , R26 , R27) incl ) . (R27 , R28) ) = [ ( R17 . R27 ) , ( R17 . R28 ) ]))))))))
proof
let R17 being Function;
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R28 being (Element of ( dom R25 ));
assume that
L859: R27 in R28
and
L860: R17 = ( Swap (( id ( dom R25 ) ) , R26 , R27) );
set D103 = ( dom R25 );
set D104 = ( id D103 );
set D105 = ( Swap (D104 , R26 , R27) );
set D106 = [: D105 , D105 :];
set D107 = ( ( succ R27 ) \ R26 );
set D108 = [: { R26 } , D107 :];
set D109 = [: D107 , { R27 } :];
set D110 = ( id ( D108 \/ D109 ) );
L861: ( dom D104 ) = D103;
L862: ( dom D105 ) = D103 by L861 , FUNCT_7:99;
L863: (not R28 c= R27) by L859 , ORDINAL6:4;
L864: (R28 nin { R27 } & R28 nin D107) by L863 , L810 , TARSKI:def 1;
L865: ([ R26 , R28 ] nin D108 & [ R26 , R28 ] nin D109 & [ R27 , R28 ] nin D108 & [ R27 , R28 ] nin D109) by L864 , ZFMISC_1:87;
L866: ([ R26 , R28 ] nin ( dom D110 ) & [ R27 , R28 ] nin ( dom D110 )) by L865 , XBOOLE_0:def 3;
thus L867: ( ( (R25 , R26 , R27) incl ) . (R26 , R28) ) = ( D106 . (R26 , R28) ) by L866 , FUNCT_4:11
.= [ ( R17 . R26 ) , ( R17 . R28 ) ] by L860 , L862 , FUNCT_3:def 8;
thus L868: ( ( (R25 , R26 , R27) incl ) . (R27 , R28) ) = ( D106 . (R27 , R28) ) by L866 , FUNCT_4:11
.= [ ( R17 . R27 ) , ( R17 . R28 ) ] by L860 , L862 , FUNCT_3:def 8;
end;
theorem
L869: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (R26 in R27 implies ( ( (R25 , R26 , R27) incl ) . (R26 , R27) ) = [ R26 , R27 ])))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
assume L870: R26 in R27;
L871: R26 c= R27 by L870 , ORDINAL1:def 2;
thus L872: thesis by L871 , L831;
end;
theorem
L873: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R28 being (Element of ( dom R25 )) holds (for R29 being (Element of ( dom R25 )) holds ((R26 in R27 & R28 <> R26 & R28 <> R27 & R29 <> R26 & R29 <> R27) implies ( ( (R25 , R26 , R27) incl ) . (R28 , R29) ) = [ R28 , R29 ])))))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R28 being (Element of ( dom R25 ));
let R29 being (Element of ( dom R25 ));
assume L874: (R26 in R27 & R28 <> R26 & R28 <> R27 & R29 <> R26 & R29 <> R27);
set D111 = ( dom R25 );
set D112 = ( id D111 );
set D113 = ( Swap (D112 , R26 , R27) );
set D114 = [: D113 , D113 :];
set D115 = ( ( succ R27 ) \ R26 );
thus L875: ( ( (R25 , R26 , R27) incl ) . (R28 , R29) ) = [ ( D113 . R28 ) , ( D113 . R29 ) ] by L874 , L839
.= [ ( D112 . R28 ) , ( D113 . R29 ) ] by L874 , L522
.= [ ( D112 . R28 ) , ( D112 . R29 ) ] by L874 , L522
.= [ R28 , ( D112 . R29 ) ] by FUNCT_1:17
.= [ R28 , R29 ] by FUNCT_1:17;
end;
theorem
L876: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R28 being (Element of ( dom R25 )) holds ((R28 in R26 & R26 in R27) implies (( ( (R25 , R26 , R27) incl ) . (R28 , R26) ) = [ R28 , R27 ] & ( ( (R25 , R26 , R27) incl ) . (R28 , R27) ) = [ R28 , R26 ])))))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R28 being (Element of ( dom R25 ));
assume L877: (R28 in R26 & R26 in R27);
set D116 = ( dom R25 );
set D117 = ( id D116 );
set D118 = ( Swap (D117 , R26 , R27) );
set D119 = [: D118 , D118 :];
set D120 = ( ( succ R27 ) \ R26 );
L878: ( dom D117 ) = D116;
L879: (R28 <> R26 & R28 <> R27) by L877;
thus L880: ( ( (R25 , R26 , R27) incl ) . (R28 , R26) ) = [ ( D118 . R28 ) , ( D118 . R26 ) ] by L877 , L847
.= [ ( D117 . R28 ) , ( D118 . R26 ) ] by L879 , L522
.= [ R28 , ( D118 . R26 ) ] by FUNCT_1:17
.= [ R28 , ( D117 . R27 ) ] by L878 , L500
.= [ R28 , R27 ] by FUNCT_1:17;
thus L881: ( ( (R25 , R26 , R27) incl ) . (R28 , R27) ) = [ ( D118 . R28 ) , ( D118 . R27 ) ] by L877 , L847
.= [ ( D117 . R28 ) , ( D118 . R27 ) ] by L879 , L522
.= [ R28 , ( D118 . R27 ) ] by FUNCT_1:17
.= [ R28 , ( D117 . R26 ) ] by L878 , L513
.= [ R28 , R26 ] by FUNCT_1:17;
end;
theorem
L882: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R29 being (Element of ( dom R25 )) holds ((R26 in R29 & R29 in R27) implies (( ( (R25 , R26 , R27) incl ) . (R26 , R29) ) = [ R26 , R29 ] & ( ( (R25 , R26 , R27) incl ) . (R29 , R27) ) = [ R29 , R27 ])))))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R29 being (Element of ( dom R25 ));
assume L883: (R26 in R29 & R29 in R27);
L884: (R26 c= R29 & R29 c= R27) by L883 , ORDINAL1:def 2;
thus L885: thesis by L884 , L831;
end;
theorem
L886: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (for R29 being (Element of ( dom R25 )) holds ((R26 in R27 & R27 in R29) implies (( ( (R25 , R26 , R27) incl ) . (R26 , R29) ) = [ R27 , R29 ] & ( ( (R25 , R26 , R27) incl ) . (R27 , R29) ) = [ R26 , R29 ])))))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
let R29 being (Element of ( dom R25 ));
assume L887: (R26 in R27 & R27 in R29);
set D121 = ( dom R25 );
set D122 = ( id D121 );
set D123 = ( Swap (D122 , R26 , R27) );
set D124 = [: D123 , D123 :];
set D125 = ( ( succ R27 ) \ R26 );
L888: ( dom D122 ) = D121;
L889: (R29 <> R26 & R29 <> R27) by L887;
thus L890: ( ( (R25 , R26 , R27) incl ) . (R26 , R29) ) = [ ( D123 . R26 ) , ( D123 . R29 ) ] by L887 , L858
.= [ ( D123 . R26 ) , ( D122 . R29 ) ] by L889 , L522
.= [ ( D123 . R26 ) , R29 ] by FUNCT_1:17
.= [ ( D122 . R27 ) , R29 ] by L888 , L500
.= [ R27 , R29 ] by FUNCT_1:17;
thus L891: ( ( (R25 , R26 , R27) incl ) . (R27 , R29) ) = [ ( D123 . R27 ) , ( D123 . R29 ) ] by L887 , L858
.= [ ( D123 . R27 ) , ( D122 . R29 ) ] by L889 , L522
.= [ ( D123 . R27 ) , R29 ] by FUNCT_1:17
.= [ ( D122 . R26 ) , R29 ] by L888 , L513
.= [ R26 , R29 ] by FUNCT_1:17;
end;
L892: (for R17 being Function holds (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds ((R26 in R27 & R17 = ( (R25 , R26 , R27) incl )) implies (for B29 , B30 , B31 , B32 being (Element of ( dom R25 )) holds ((B29 in B31 & B30 in B32) implies (( R17 . (B29 , B31) ) = ( R17 . (B30 , B32) ) implies (B29 = B30 & B31 = B32))))))))))
proof
let R17 being Function;
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
assume L893: (R26 in R27 & R17 = ( (R25 , R26 , R27) incl ));
L894: R26 <> R27 by L893;
let C99 , C100 , C101 , C102 being (Element of ( dom R25 ));
assume that
L895: (C99 in C101 & C100 in C102)
and
L896: ( R17 . (C99 , C101) ) = ( R17 . (C100 , C102) );
set D126 = ( dom R25 );
set D127 = ( id D126 );
set D128 = ( Swap (D127 , R26 , R27) );
set D129 = [: D128 , D128 :];
set D130 = ( ( succ R27 ) \ R26 );
set D131 = [: { R26 } , D130 :];
set D132 = [: D130 , { R27 } :];
set D133 = ( id ( D131 \/ D132 ) );
per cases  by L893 , L895 , L10;
suppose L897: (C99 <> R26 & C99 <> R27 & C101 <> R26 & C101 <> R27);

L898: ( R17 . (C99 , C101) ) = [ C99 , C101 ] by L897 , L893 , L873;
per cases  by L893 , L895 , L10;
suppose L899: S1[ R26 , R27 , C100 , C102 ];

L900: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L899 , L893 , L873;
thus L901: (C99 = C100 & C101 = C102) by L900 , L896 , L898 , XTUPLE_0:1;
end;
suppose L902: S2[ R26 , R27 , C100 , C102 ];

L903: ( R17 . (C100 , C102) ) = [ C100 , R27 ] by L902 , L893 , L876;
thus L904: (C99 = C100 & C101 = C102) by L903 , L897 , L896 , L898 , XTUPLE_0:1;
end;
suppose L905: S3[ R26 , R27 , C100 , C102 ];

L906: ( R17 . (C100 , C102) ) = [ C100 , R26 ] by L905 , L893 , L876;
thus L907: (C99 = C100 & C101 = C102) by L906 , L897 , L896 , L898 , XTUPLE_0:1;
end;
suppose L908: S4[ R26 , R27 , C100 , C102 ];

L909: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L908 , L893 , L895 , L882;
thus L910: (C99 = C100 & C101 = C102) by L909 , L896 , L898 , XTUPLE_0:1;
end;
suppose L911: S5[ R26 , R27 , C100 , C102 ];

L912: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L911 , L893 , L869;
thus L913: (C99 = C100 & C101 = C102) by L912 , L896 , L898 , XTUPLE_0:1;
end;
suppose L914: S6[ R26 , R27 , C100 , C102 ];

L915: ( R17 . (C100 , C102) ) = [ R27 , C102 ] by L914 , L893 , L886;
thus L916: (C99 = C100 & C101 = C102) by L915 , L897 , L896 , L898 , XTUPLE_0:1;
end;
suppose L917: S7[ R26 , R27 , C100 , C102 ];

L918: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L917 , L893 , L895 , L882;
thus L919: (C99 = C100 & C101 = C102) by L918 , L896 , L898 , XTUPLE_0:1;
end;
suppose L920: S8[ R26 , R27 , C100 , C102 ];

L921: ( R17 . (C100 , C102) ) = [ R26 , C102 ] by L920 , L893 , L886;
thus L922: (C99 = C100 & C101 = C102) by L921 , L897 , L896 , L898 , XTUPLE_0:1;
end;
end;
suppose L924: (C99 = R26 & C101 in R27);

L925: ( R17 . (C99 , C101) ) = [ C99 , C101 ] by L924 , L893 , L895 , L882;
per cases  by L893 , L895 , L10;
suppose L926: S1[ R26 , R27 , C100 , C102 ];

L927: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L926 , L893 , L873;
thus L928: (C99 = C100 & C101 = C102) by L927 , L896 , L925 , XTUPLE_0:1;
end;
suppose L929: S2[ R26 , R27 , C100 , C102 ];

L930: (( R17 . (C100 , C102) ) = [ C100 , R27 ] & C100 <> R26) by L929 , L893 , L876;
thus L931: (C99 = C100 & C101 = C102) by L930 , L924 , L896 , L925 , XTUPLE_0:1;
end;
suppose L932: S3[ R26 , R27 , C100 , C102 ];

L933: (( R17 . (C100 , C102) ) = [ C100 , R26 ] & C100 <> R26) by L932 , L893 , L876;
thus L934: (C99 = C100 & C101 = C102) by L933 , L924 , L896 , L925 , XTUPLE_0:1;
end;
suppose L935: S4[ R26 , R27 , C100 , C102 ];

L936: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L935 , L893 , L895 , L882;
thus L937: (C99 = C100 & C101 = C102) by L936 , L896 , L925 , XTUPLE_0:1;
end;
suppose L938: S5[ R26 , R27 , C100 , C102 ];

L939: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L938 , L893 , L869;
thus L940: (C99 = C100 & C101 = C102) by L939 , L896 , L925 , XTUPLE_0:1;
end;
suppose L941: S6[ R26 , R27 , C100 , C102 ];

L942: ( R17 . (C100 , C102) ) = [ R27 , C102 ] by L941 , L893 , L886;
thus L943: (C99 = C100 & C101 = C102) by L942 , L894 , L924 , L896 , L925 , XTUPLE_0:1;
end;
suppose L944: S7[ R26 , R27 , C100 , C102 ];

L945: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L944 , L893 , L895 , L882;
thus L946: (C99 = C100 & C101 = C102) by L945 , L896 , L925 , XTUPLE_0:1;
end;
suppose L947: S8[ R26 , R27 , C100 , C102 ];

L948: ( R17 . (C100 , C102) ) = [ R26 , C102 ] by L947 , L893 , L886;
thus L949: (C99 = C100 & C101 = C102) by L948 , L924 , L947 , L896 , L925 , XTUPLE_0:1;
end;
end;
suppose L951: (C99 = R26 & C101 = R27);

L952: ( R17 . (C99 , C101) ) = [ C99 , C101 ] by L951 , L893 , L869;
per cases  by L893 , L895 , L10;
suppose L953: S1[ R26 , R27 , C100 , C102 ];

L954: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L953 , L893 , L873;
thus L955: (C99 = C100 & C101 = C102) by L954 , L896 , L952 , XTUPLE_0:1;
end;
suppose L956: S2[ R26 , R27 , C100 , C102 ];

L957: (( R17 . (C100 , C102) ) = [ C100 , R27 ] & C100 <> R26) by L956 , L893 , L876;
thus L958: (C99 = C100 & C101 = C102) by L957 , L951 , L896 , L952 , XTUPLE_0:1;
end;
suppose L959: S3[ R26 , R27 , C100 , C102 ];

L960: ( R17 . (C100 , C102) ) = [ C100 , R26 ] by L959 , L893 , L876;
thus L961: (C99 = C100 & C101 = C102) by L960 , L894 , L951 , L896 , L952 , XTUPLE_0:1;
end;
suppose L962: S4[ R26 , R27 , C100 , C102 ];

L963: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L962 , L893 , L895 , L882;
thus L964: (C99 = C100 & C101 = C102) by L963 , L896 , L952 , XTUPLE_0:1;
end;
suppose L965: S5[ R26 , R27 , C100 , C102 ];

L966: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L965 , L893 , L869;
thus L967: (C99 = C100 & C101 = C102) by L966 , L896 , L952 , XTUPLE_0:1;
end;
suppose L968: S6[ R26 , R27 , C100 , C102 ];

L969: ( R17 . (C100 , C102) ) = [ R27 , C102 ] by L968 , L893 , L886;
thus L970: (C99 = C100 & C101 = C102) by L969 , L894 , L951 , L896 , L952 , XTUPLE_0:1;
end;
suppose L971: S7[ R26 , R27 , C100 , C102 ];

L972: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L971 , L893 , L895 , L882;
thus L973: (C99 = C100 & C101 = C102) by L972 , L896 , L952 , XTUPLE_0:1;
end;
suppose L974: S8[ R26 , R27 , C100 , C102 ];

L975: (( R17 . (C100 , C102) ) = [ R26 , C102 ] & C102 <> R27) by L974 , L893 , L886;
thus L976: (C99 = C100 & C101 = C102) by L975 , L951 , L896 , L952 , XTUPLE_0:1;
end;
end;
suppose L978: (R26 in C99 & C101 = R27);

L979: ( R17 . (C99 , C101) ) = [ C99 , C101 ] by L978 , L893 , L895 , L882;
per cases  by L893 , L895 , L10;
suppose L980: S1[ R26 , R27 , C100 , C102 ];

L981: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L980 , L893 , L873;
thus L982: (C99 = C100 & C101 = C102) by L981 , L896 , L979 , XTUPLE_0:1;
end;
suppose L983: S2[ R26 , R27 , C100 , C102 ];

L984: ( R17 . (C100 , C102) ) = [ C100 , R27 ] by L983 , L893 , L876;
thus L985: (C99 = C100 & C101 = C102) by L984 , L983 , L978 , L896 , L979 , XTUPLE_0:1;
end;
suppose L986: S3[ R26 , R27 , C100 , C102 ];

L987: ( R17 . (C100 , C102) ) = [ C100 , R26 ] by L986 , L893 , L876;
thus L988: (C99 = C100 & C101 = C102) by L987 , L986 , L978 , L896 , L979 , XTUPLE_0:1;
end;
suppose L989: S4[ R26 , R27 , C100 , C102 ];

L990: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L989 , L893 , L895 , L882;
thus L991: (C99 = C100 & C101 = C102) by L990 , L896 , L979 , XTUPLE_0:1;
end;
suppose L992: S5[ R26 , R27 , C100 , C102 ];

L993: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L992 , L893 , L869;
thus L994: (C99 = C100 & C101 = C102) by L993 , L896 , L979 , XTUPLE_0:1;
end;
suppose L995: S6[ R26 , R27 , C100 , C102 ];

L996: (( R17 . (C100 , C102) ) = [ R27 , C102 ] & C102 <> R27) by L995 , L893 , L886;
thus L997: (C99 = C100 & C101 = C102) by L996 , L978 , L896 , L979 , XTUPLE_0:1;
end;
suppose L998: S7[ R26 , R27 , C100 , C102 ];

L999: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L998 , L893 , L895 , L882;
thus L1000: (C99 = C100 & C101 = C102) by L999 , L896 , L979 , XTUPLE_0:1;
end;
suppose L1001: S8[ R26 , R27 , C100 , C102 ];

L1002: (( R17 . (C100 , C102) ) = [ R26 , C102 ] & C102 <> R27) by L1001 , L893 , L886;
thus L1003: (C99 = C100 & C101 = C102) by L1002 , L978 , L896 , L979 , XTUPLE_0:1;
end;
end;
suppose L1005: (C99 in R26 & C101 = R26);

L1006: ( R17 . (C99 , C101) ) = [ C99 , R27 ] by L1005 , L893 , L876;
per cases  by L893 , L895 , L10;
suppose L1007: S1[ R26 , R27 , C100 , C102 ];

L1008: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1007 , L893 , L873;
thus L1009: (C99 = C100 & C101 = C102) by L1008 , L1007 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1010: S2[ R26 , R27 , C100 , C102 ];

L1011: ( R17 . (C100 , C102) ) = [ C100 , R27 ] by L1010 , L893 , L876;
thus L1012: (C99 = C100 & C101 = C102) by L1011 , L1010 , L1005 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1013: S3[ R26 , R27 , C100 , C102 ];

L1014: ( R17 . (C100 , C102) ) = [ C100 , R26 ] by L1013 , L893 , L876;
thus L1015: (C99 = C100 & C101 = C102) by L1014 , L894 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1016: S4[ R26 , R27 , C100 , C102 ];

L1017: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C100 <> C99) by L1016 , L1005 , L893 , L895 , L882;
thus L1018: (C99 = C100 & C101 = C102) by L1017 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1019: S5[ R26 , R27 , C100 , C102 ];

L1020: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C100 <> C99) by L1019 , L1005 , L893 , L869;
thus L1021: (C99 = C100 & C101 = C102) by L1020 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1022: S6[ R26 , R27 , C100 , C102 ];

L1023: (( R17 . (C100 , C102) ) = [ R27 , C102 ] & C102 <> R27) by L1022 , L893 , L886;
thus L1024: (C99 = C100 & C101 = C102) by L1023 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1025: S7[ R26 , R27 , C100 , C102 ];

L1026: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1025 , L893 , L895 , L882;
thus L1027: (C99 = C100 & C101 = C102) by L1026 , L1005 , L1025 , L896 , L1006 , XTUPLE_0:1;
end;
suppose L1028: S8[ R26 , R27 , C100 , C102 ];

L1029: (( R17 . (C100 , C102) ) = [ R26 , C102 ] & C99 <> R26) by L1028 , L1005 , L893 , L886;
thus L1030: (C99 = C100 & C101 = C102) by L1029 , L896 , L1006 , XTUPLE_0:1;
end;
end;
suppose L1032: (C99 in R26 & C101 = R27);

L1033: ( R17 . (C99 , C101) ) = [ C99 , R26 ] by L1032 , L893 , L876;
per cases  by L893 , L895 , L10;
suppose L1034: S1[ R26 , R27 , C100 , C102 ];

L1035: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1034 , L893 , L873;
thus L1036: (C99 = C100 & C101 = C102) by L1035 , L1034 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1037: S2[ R26 , R27 , C100 , C102 ];

L1038: ( R17 . (C100 , C102) ) = [ C100 , R27 ] by L1037 , L893 , L876;
thus L1039: (C99 = C100 & C101 = C102) by L1038 , L894 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1040: S3[ R26 , R27 , C100 , C102 ];

L1041: ( R17 . (C100 , C102) ) = [ C100 , R26 ] by L1040 , L893 , L876;
thus L1042: (C99 = C100 & C101 = C102) by L1041 , L1040 , L1032 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1043: S4[ R26 , R27 , C100 , C102 ];

L1044: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C99 <> R26) by L1043 , L1032 , L893 , L895 , L882;
thus L1045: (C99 = C100 & C101 = C102) by L1044 , L1043 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1046: S5[ R26 , R27 , C100 , C102 ];

L1047: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1046 , L893 , L869;
thus L1048: (C99 = C100 & C101 = C102) by L1047 , L1046 , L894 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1049: S6[ R26 , R27 , C100 , C102 ];

L1050: ( R17 . (C100 , C102) ) = [ R27 , C102 ] by L1049 , L893 , L886;
thus L1051: (C99 = C100 & C101 = C102) by L1050 , L893 , L1032 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1052: S7[ R26 , R27 , C100 , C102 ];

L1053: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1052 , L893 , L895 , L882;
thus L1054: (C99 = C100 & C101 = C102) by L1053 , L894 , L1052 , L896 , L1033 , XTUPLE_0:1;
end;
suppose L1055: S8[ R26 , R27 , C100 , C102 ];

L1056: (( R17 . (C100 , C102) ) = [ R26 , C102 ] & C99 <> R26) by L1055 , L1032 , L893 , L886;
thus L1057: (C99 = C100 & C101 = C102) by L1056 , L896 , L1033 , XTUPLE_0:1;
end;
end;
suppose L1059: (C99 = R26 & R27 in C101);

L1060: ( R17 . (C99 , C101) ) = [ R27 , C101 ] by L1059 , L893 , L886;
per cases  by L893 , L895 , L10;
suppose L1061: S1[ R26 , R27 , C100 , C102 ];

L1062: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1061 , L893 , L873;
thus L1063: (C99 = C100 & C101 = C102) by L1062 , L1061 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1064: S2[ R26 , R27 , C100 , C102 ];

L1065: ( R17 . (C100 , C102) ) = [ C100 , R27 ] by L1064 , L893 , L876;
thus L1066: (C99 = C100 & C101 = C102) by L1065 , L893 , L1064 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1067: S3[ R26 , R27 , C100 , C102 ];

L1068: ( R17 . (C100 , C102) ) = [ C100 , R26 ] by L1067 , L893 , L876;
thus L1069: (C99 = C100 & C101 = C102) by L1068 , L893 , L1059 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1070: S4[ R26 , R27 , C100 , C102 ];

L1071: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C100 <> R27) by L1070 , L893 , L895 , L882;
thus L1072: (C99 = C100 & C101 = C102) by L1071 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1073: S5[ R26 , R27 , C100 , C102 ];

L1074: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1073 , L893 , L869;
thus L1075: (C99 = C100 & C101 = C102) by L1074 , L894 , L1073 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1076: S6[ R26 , R27 , C100 , C102 ];

L1077: ( R17 . (C100 , C102) ) = [ R27 , C102 ] by L1076 , L893 , L886;
thus L1078: (C99 = C100 & C101 = C102) by L1077 , L1076 , L1059 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1079: S7[ R26 , R27 , C100 , C102 ];

L1080: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C100 <> R27) by L1079 , L893 , L895 , L882;
thus L1081: (C99 = C100 & C101 = C102) by L1080 , L896 , L1060 , XTUPLE_0:1;
end;
suppose L1082: S8[ R26 , R27 , C100 , C102 ];

L1083: ( R17 . (C100 , C102) ) = [ R26 , C102 ] by L1082 , L893 , L886;
thus L1084: (C99 = C100 & C101 = C102) by L1083 , L894 , L896 , L1060 , XTUPLE_0:1;
end;
end;
suppose L1086: (C99 = R27 & R27 in C101);

L1087: ( R17 . (C99 , C101) ) = [ R26 , C101 ] by L1086 , L893 , L886;
per cases  by L893 , L895 , L10;
suppose L1088: S1[ R26 , R27 , C100 , C102 ];

L1089: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1088 , L893 , L873;
thus L1090: (C99 = C100 & C101 = C102) by L1089 , L1088 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1091: S2[ R26 , R27 , C100 , C102 ];

L1092: (( R17 . (C100 , C102) ) = [ C100 , R27 ] & R26 <> C100) by L1091 , L893 , L876;
thus L1093: (C99 = C100 & C101 = C102) by L1092 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1094: S3[ R26 , R27 , C100 , C102 ];

L1095: (( R17 . (C100 , C102) ) = [ C100 , R26 ] & R26 <> C100) by L1094 , L893 , L876;
thus L1096: (C99 = C100 & C101 = C102) by L1095 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1097: S4[ R26 , R27 , C100 , C102 ];

L1098: ( R17 . (C100 , C102) ) = [ C100 , C102 ] by L1097 , L893 , L895 , L882;
thus L1099: (C99 = C100 & C101 = C102) by L1098 , L1086 , L1097 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1100: S5[ R26 , R27 , C100 , C102 ];

L1101: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C101 <> C102) by L1100 , L1086 , L893 , L869;
thus L1102: (C99 = C100 & C101 = C102) by L1101 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1103: S6[ R26 , R27 , C100 , C102 ];

L1104: ( R17 . (C100 , C102) ) = [ R27 , C102 ] by L1103 , L893 , L886;
thus L1105: (C99 = C100 & C101 = C102) by L1104 , L894 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1106: S7[ R26 , R27 , C100 , C102 ];

L1107: (( R17 . (C100 , C102) ) = [ C100 , C102 ] & C102 <> C101) by L1106 , L1086 , L893 , L895 , L882;
thus L1108: (C99 = C100 & C101 = C102) by L1107 , L896 , L1087 , XTUPLE_0:1;
end;
suppose L1109: S8[ R26 , R27 , C100 , C102 ];

L1110: ( R17 . (C100 , C102) ) = [ R26 , C102 ] by L1109 , L893 , L886;
thus L1111: (C99 = C100 & C101 = C102) by L1110 , L1109 , L1086 , L896 , L1087 , XTUPLE_0:1;
end;
end;
end;
theorem
L1114: (for R22 being  connected non  empty Poset holds (for R25 being non  empty (array of R22) holds (for R26 being (Element of ( dom R25 )) holds (for R27 being (Element of ( dom R25 )) holds (R26 in R27 implies ( ( (R25 , R26 , R27) incl ) | (( inversions ( Swap (R25 , R26 , R27) ) ) qua set) ) is  one-to-one)))))
proof
let R22 being  connected non  empty Poset;
let R25 being non  empty (array of R22);
let R26 being (Element of ( dom R25 ));
let R27 being (Element of ( dom R25 ));
assume L1115: R26 in R27;
set D134 = ( (R25 , R26 , R27) incl );
set D135 = ( Swap (R25 , R26 , R27) );
set D136 = ( inversions D135 );
set D137 = ( D134 | (D136 qua set) );
L1116: ( dom D135 ) = ( dom R25 ) by FUNCT_7:99;
let R10 being set;
let R11 being set;
assume L1117: (R10 in ( dom D137 ) & R11 in ( dom D137 ));
L1118: (R10 in D136 & R11 in D136) by L1117 , RELAT_1:57;
consider C103 , C104 being (Element of ( dom R25 )) such that L1119: (R10 = [ C103 , C104 ] & C103 in C104 & ( D135 /. C103 ) > ( D135 /. C104 )) by L1118 , L1116;
consider C105 , C106 being (Element of ( dom R25 )) such that L1120: (R11 = [ C105 , C106 ] & C105 in C106 & ( D135 /. C105 ) > ( D135 /. C106 )) by L1116 , L1118;
assume L1121: ( D137 . R10 ) = ( D137 . R11 );
L1122: ( D134 . (C103 , C104) ) = ( D137 . R11 ) by L1121 , L1119 , L1118 , FUNCT_1:49
.= ( D134 . (C105 , C106) ) by L1120 , L1118 , FUNCT_1:49;
L1123: (C103 = C105 & C104 = C106) by L1122 , L1115 , L1119 , L1120 , L892;
thus L1124: thesis by L1123 , L1119 , L1120;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let R10 being set;
let R11 being set;
let R12 being set;
cluster ( ( (R23 , R10 , R11) incl ) .: R12 ) ->  Relation-like;
coherence
proof
set D138 = ( dom R23 );
set D139 = ( id D138 );
set D140 = ( Swap (D139 , R10 , R11) );
set D141 = [: D140 , D140 :];
set D142 = ( ( succ R11 ) \ R10 );
set D143 = [: { R10 } , D142 :];
set D144 = [: D142 , { R11 } :];
set D145 = ( id ( D143 \/ D144 ) );
L1125: ( ( (R23 , R10 , R11) incl ) .: R12 ) c= ( rng ( (R23 , R10 , R11) incl ) ) by RELAT_1:111;
L1126: ( rng D141 ) = [: ( rng D140 ) , ( rng D140 ) :] by FUNCT_3:67;
L1127: ( rng ( (R23 , R10 , R11) incl ) ) c= ( ( rng D141 ) \/ ( rng D145 ) ) by FUNCT_4:17;
thus L1128: thesis by L1127 , L1125 , L1126;
end;
end;
begin
theorem
L1130: (for R10 being set holds (for R11 being set holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds ([ R10 , R11 ] in ( inversions R23 ) implies ( ( (R23 , R10 , R11) incl ) .: ( inversions ( Swap (R23 , R10 , R11) ) ) ) c< ( inversions R23 ))))))
proof
let R10 being set;
let R11 being set;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
assume L1131: [ R10 , R11 ] in ( inversions R23 );
L1132: (R10 in ( dom R23 ) & R11 in ( dom R23 ) & R10 in R11 & ( R23 /. R10 ) > ( R23 /. R11 )) by L1131 , L670;
reconsider D146 = R23 as non  empty (array of R22) by L1131;
reconsider D147 = R10 , D148 = R11 as (Element of ( dom D146 )) by L1131 , L670;
set D149 = ( (R23 , R10 , R11) incl );
set D150 = ( (D146 , D147 , D148) incl );
set D151 = ( Swap (R23 , R10 , R11) );
set D152 = ( Swap (D146 , D147 , D148) );
set D153 = ( inversions D151 );
set D154 = ( inversions R23 );
L1133: ( dom D152 ) = ( dom D146 ) by FUNCT_7:99;
thus L1134: ( D149 .: D153 ) c= D154
proof
let R12 being set;
let R13 being set;
assume L1135: [ R12 , R13 ] in ( D149 .: D153 );
consider C107 , C108 being set such that L1136: ([ C107 , C108 ] in D153 & [ C107 , C108 ] in ( dom D149 ) & [ R12 , R13 ] = ( D149 . (C107 , C108) )) by L1135 , L33;
L1137: (C107 in C108 & C107 in ( dom D146 ) & C108 in ( dom D146 )) by L1136 , L1133 , L670;
reconsider D155 = C107 , D156 = C108 as (Element of ( dom D146 )) by L1136 , L1133 , L670;
per cases  by L1132 , L1137 , L10;
suppose L1138: (D155 <> D147 & D155 <> D148 & D156 <> D147 & D156 <> D148);

L1139: [ R12 , R13 ] = [ D155 , D156 ] by L1138 , L1136 , L1132 , L873;
thus L1140: thesis by L1139 , L1136 , L1138 , L722;
end;
suppose L1141: (D155 in D147 & D156 = D147);

L1142: [ R12 , R13 ] = [ D155 , D148 ] by L1141 , L1136 , L1132 , L876;
thus L1143: thesis by L1142 , L1131 , L1136 , L1141 , L732;
end;
suppose L1144: (D155 in D147 & D156 = D148);

L1145: [ R12 , R13 ] = [ D155 , D147 ] by L1144 , L1136 , L1132 , L876;
thus L1146: thesis by L1145 , L1131 , L1136 , L1144 , L747;
end;
suppose L1147: (D155 = D147 & D156 in D148);

L1148: [ R12 , R13 ] = [ D155 , D156 ] by L1147 , L1137 , L1136 , L882;
thus L1149: thesis by L1148 , L1131 , L1136 , L1147 , L762;
end;
suppose L1150: (D155 = D147 & D156 = D148);

thus L1151: thesis by L1150 , L1131 , L1136 , L1132 , L869;
end;
suppose L1152: (D155 = D147 & D148 in D156);

L1153: [ R12 , R13 ] = [ D148 , D156 ] by L1152 , L1136 , L1132 , L886;
thus L1154: thesis by L1153 , L1131 , L1136 , L1152 , L784;
end;
suppose L1155: (D155 = D148 & D148 in D156);

L1156: [ R12 , R13 ] = [ D147 , D156 ] by L1155 , L1136 , L1132 , L886;
thus L1157: thesis by L1156 , L1131 , L1136 , L1155 , L794;
end;
suppose L1158: (D147 in D155 & D148 = D156);

L1159: [ R12 , R13 ] = [ D155 , D156 ] by L1158 , L1136 , L1137 , L882;
thus L1160: thesis by L1159 , L1131 , L1136 , L1158 , L773;
end;
end;

L1162:
now
assume L1163: [ R10 , R11 ] in ( D149 .: D153 );
consider C109 , C110 being set such that L1164: ([ C109 , C110 ] in D153 & [ C109 , C110 ] in ( dom D149 ) & [ R10 , R11 ] = ( D149 . (C109 , C110) )) by L1163 , L33;
L1165: ( D149 . (D147 , D148) ) = [ D147 , D148 ] by L1132 , L869;
L1166: (C109 in C110 & C109 in ( dom D146 ) & C110 in ( dom D146 )) by L1164 , L1133 , L670;
reconsider D157 = C109 , D158 = C110 as (Element of ( dom D146 )) by L1164 , L1133 , L670;
L1167: (D157 = D147 & D158 = D148) by L1132 , L1164 , L1165 , L1166 , L892;
thus L1168: [ R10 , R11 ] in D153 by L1167 , L1164;
end;
thus L1169: thesis by L1162 , L1131 , L716;
end;
registration
let C111 being  finite Function;
let R10 being set;
let R11 being set;
cluster ( Swap (C111 , R10 , R11) ) ->  finite;
coherence
proof
L1170: ( dom ( Swap (C111 , R10 , R11) ) ) = ( dom C111 ) by FUNCT_7:99;
thus L1171: thesis by L1170 , FINSET_1:10;
end;
end;
theorem
L1173: (for R10 being set holds (for R11 being set holds (for R22 being  connected non  empty Poset holds (for B33 being (array of R22) holds (([ R10 , R11 ] in ( inversions B33 ) & ( inversions B33 ) is  finite) implies ( card ( inversions ( Swap (B33 , R10 , R11) ) ) ) in ( card ( inversions B33 ) ))))))
proof
let R10 being set;
let R11 being set;
let R22 being  connected non  empty Poset;
let C112 being (array of R22);
set D159 = ( Swap (C112 , R10 , R11) );
set D160 = ( (C112 , R10 , R11) incl );
set D161 = ( inversions D159 );
assume L1174: ([ R10 , R11 ] in ( inversions C112 ) & ( inversions C112 ) is  finite);
reconsider D162 = ( inversions C112 ) as  finite set by L1174;
L1175: ( D160 .: D161 ) c< ( inversions C112 ) by L1174 , L1130;
L1176: ( D160 .: D161 ) c= D162 by L1175 , XBOOLE_0:def 8;
reconsider D163 = ( D160 .: D161 ) as  finite set by L1176;
L1177: ( card D163 ) < ( card D162 ) by L1174 , L1130 , TREES_1:6;
L1178: ( card D163 ) in ( card D162 ) by L1177 , NAT_1:44;
L1179: (R10 in ( dom C112 ) & R11 in ( dom C112 ) & R10 in R11) by L1174 , L670;
L1180: C112 is non  empty by L1174;
L1181: D161 , ( D160 .: D161 ) are_equipotent 
proof
take D164 = ( D160 | (D161 qua set) );
thus L1182: D164 is  one-to-one by L1179 , L1180 , L1114;
L1183: ( dom D159 ) = ( dom C112 ) by FUNCT_7:99;
L1184: D161 c= [: ( dom C112 ) , ( dom C112 ) :] by L1183 , L677;
L1185: D161 c= ( dom D160 ) by L1184 , L1179 , L1180 , L821;
thus L1186: ( dom D164 ) = D161 by L1185 , RELAT_1:62;
thus L1187: thesis by RELAT_1:115;
end;
thus L1188: ( card ( inversions ( Swap (C112 , R10 , R11) ) ) ) in ( card ( inversions C112 ) ) by L1181 , L1178 , CARD_1:5;
end;
theorem
L1189: (for R10 being set holds (for R11 being set holds (for R22 being  connected non  empty Poset holds (for B34 being  finite (array of R22) holds ([ R10 , R11 ] in ( inversions B34 ) implies ( card ( inversions ( Swap (B34 , R10 , R11) ) ) ) < ( card ( inversions B34 ) ))))))
proof
let R10 being set;
let R11 being set;
let R22 being  connected non  empty Poset;
let C113 being  finite (array of R22);
assume L1190: [ R10 , R11 ] in ( inversions C113 );
L1191: ( card ( inversions ( Swap (C113 , R10 , R11) ) ) ) in ( card ( inversions C113 ) ) by L1190 , L1173;
thus L1192: thesis by L1191 , NAT_1:44;
end;
definition
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
mode arr_computation of R23
 -> non  empty array
means :L1193: (( it . ( base- it ) ) = R23 & (for R1 being  ordinal number holds (R1 in ( dom it ) implies ( it . R1 ) is (array of R22))) & (for R1 being  ordinal number holds ((R1 in ( dom it ) & ( succ R1 ) in ( dom it )) implies (ex R23 being (array of R22) st (ex R10 being set st (ex R11 being set st ([ R10 , R11 ] in ( inversions R23 ) & ( it . R1 ) = R23 & ( it . ( succ R1 ) ) = ( Swap (R23 , R10 , R11) ))))))));
existence
proof
reconsider D165 = <% R23 %> as ( 0 ) -based non  empty array;
take D165;
L1194: (( dom D165 ) = 1 & ( 0 ) in 1) by AFINSQ_1:def 4 , NAT_1:44;
L1195: ( base- D165 ) = ( 0 ) by L1194 , L190;
thus L1196: ( D165 . ( base- D165 ) ) = R23 by L1195 , AFINSQ_1:def 4;
thus L1197:now
let R1 being  ordinal number;
assume L1198: R1 in ( dom D165 );
L1199: R1 = ( 0 ) by L1198 , L1194 , ORDINAL3:15 , TARSKI:def 1;
thus L1200: ( D165 . R1 ) is (array of R22) by L1199 , AFINSQ_1:def 4;
end;
let R1 being  ordinal number;
assume L1201: (R1 in ( dom D165 ) & ( succ R1 ) in ( dom D165 ));
thus L1202: thesis by L1201 , L1194 , ORDINAL3:15 , TARSKI:def 1;
end;
end;
theorem
L1204: (for R1 being  ordinal number holds (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds { [ R1 , R23 ] } is (arr_computation of R23))))
proof
let R1 being  ordinal number;
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
reconsider D166 = { [ R1 , R23 ] } as R1 -based non  empty array;
L1205: D166 is (arr_computation of R23)
proof
L1206: (( dom D166 ) = { R1 } & R1 in { R1 }) by FUNCT_5:12 , TARSKI:def 1;
L1207: ( base- D166 ) = R1 by L1206 , L190;
thus L1208: ( D166 . ( base- D166 ) ) = R23 by L1207 , GRFUNC_1:6;
thus L1209:now
let R4 being  ordinal number;
assume L1210: R4 in ( dom D166 );
L1211: R1 = R4 by L1210 , L1206 , TARSKI:def 1;
thus L1212: ( D166 . R4 ) is (array of R22) by L1211 , GRFUNC_1:6;
end;
let R4 being  ordinal number;
assume L1213: (R4 in ( dom D166 ) & ( succ R4 ) in ( dom D166 ));
L1214: (R1 = R4 & R1 = ( succ R4 )) by L1213 , L1206 , TARSKI:def 1;
L1215: R1 in R1 by L1214 , ORDINAL1:6;
thus L1216: thesis by L1215;
end;
thus L1217: thesis by L1205;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let R1 being  ordinal number;
cluster R1 -based  finite for (arr_computation of R23);
existence
proof
reconsider D167 = { [ R1 , R23 ] } as R1 -based non  empty  finite array;
L1218: D167 is (arr_computation of R23) by L1204;
thus L1219: thesis by L1218;
end;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C114 being (arr_computation of R23);
let R10 being set;
cluster ( C114 . R10 ) ->  segmental  Function-like  Relation-like;
coherence
proof
per cases ;
suppose L1221: R10 nin ( dom C114 );

thus L1222: thesis by L1221 , FUNCT_1:def 2;
end;
suppose L1223: R10 in ( dom C114 );

thus L1224: thesis by L1223 , L1193;
end;
end;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C115 being (arr_computation of R23);
let R10 being set;
cluster ( C115 . R10 ) -> (the carrier of R22) -valued;
coherence
proof
per cases ;
suppose L1227: R10 nin ( dom C115 );

L1228: ( C115 . R10 ) = ( {} ) by L1227 , FUNCT_1:def 2;
L1229: ( rng ( C115 . R10 ) ) = ( {} ) by L1228;
thus L1230: ( rng ( C115 . R10 ) ) c= (the carrier of R22) by L1229 , XBOOLE_1:2;
end;
suppose L1231: R10 in ( dom C115 );

thus L1232: thesis by L1231 , L1193;
end;
end;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C116 being (arr_computation of R23);
cluster ( last C116 ) ->  segmental  Relation-like  Function-like;
coherence;
end;
registration
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C117 being (arr_computation of R23);
cluster ( last C117 ) -> (the carrier of R22) -valued;
coherence;
end;
definition
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C118 being (arr_computation of R23);
attr C118 is  complete
means
:L1237: ( last C118 ) is  ascending;
end;
theorem
L1239: (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (for B35 being ( 0 ) -based (arr_computation of R23) holds (R23 is  finite  finite  finite  finite (array of R22) implies B35 is  finite))))
proof
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C119 being ( 0 ) -based (arr_computation of R23);
assume L1240: R23 is  finite  finite  finite  finite (array of R22);
reconsider D168 = R23 as  finite (array of R22) by L1240;
L1241: ( C119 . ( base- C119 ) ) = D168 by L1193;
deffunc H6((array of R22)) = ( card ( inversions $1 ) );
L1242: ( base- C119 ) = ( 0 ) by L315;
L1243: H6(( C119 . ( 0 ) )) is  finite by L1242 , L1241;
L1244: (for R1 being  ordinal number holds ((( succ R1 ) in ( dom C119 ) & H6(( C119 . R1 )) is  finite) implies H6(( C119 . ( succ R1 ) )) c< H6(( C119 . R1 ))))
proof
let R1 being  ordinal number;
assume L1245: (( succ R1 ) in ( dom C119 ) & H6(( C119 . R1 )) is  finite);
L1246: R1 in ( succ R1 ) by ORDINAL1:6;
L1247: R1 in ( dom C119 ) by L1246 , L1245 , ORDINAL1:10;
consider R23 being (array of R22), R10 being set, R11 being set such that L1248: ([ R10 , R11 ] in ( inversions R23 ) & ( C119 . R1 ) = R23 & ( C119 . ( succ R1 ) ) = ( Swap (R23 , R10 , R11) )) by L1247 , L1245 , L1193;
L1249: ( inversions R23 ) is  finite by L1245 , L1248;
L1250: H6(( C119 . ( succ R1 ) )) in H6(( C119 . R1 )) by L1249 , L1248 , L1173;
L1251: (H6(( C119 . ( succ R1 ) )) c= H6(( C119 . R1 )) & H6(( C119 . ( succ R1 ) )) <> H6(( C119 . R1 ))) by L1250 , ORDINAL1:def 2;
thus L1252: H6(( C119 . ( succ R1 ) )) c< H6(( C119 . R1 )) by L1251 , XBOOLE_0:def 8;
end;
thus L1253: C119 is  finite from A(L1243 , L1244);
end;
theorem
L1254: (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (for B36 being ( 0 ) -based (arr_computation of R23) holds ((R23 is  finite  finite  finite  finite (array of R22) & (for R1 being  ordinal number holds (( inversions ( B36 . R1 ) ) <> ( {} ) implies ( succ R1 ) in ( dom B36 )))) implies B36 is  complete))))
proof
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C120 being ( 0 ) -based (arr_computation of R23);
assume L1255: R23 is  finite  finite  finite  finite (array of R22);
L1256: C120 is  finite by L1255 , L1239;
reconsider D169 = ( dom C120 ) as non  empty  finite Ordinal by L1256;
assume L1257: (for R1 being  ordinal number holds (( inversions ( C120 . R1 ) ) <> ( {} ) implies ( succ R1 ) in ( dom C120 )));
set D170 = ( union D169 );
consider C121 being Nat such that L1258: D169 = ( C121 + 1 ) by NAT_1:6;
L1259: D169 = ( succ C121 ) by L1258 , NAT_1:38;
L1260: D170 = C121 by L1259 , ORDINAL2:2;
L1261: (( inversions ( C120 . D170 ) ) <> ( 0 ) implies D169 in D169) by L1257 , L1259 , L1260;
thus L1262: ( last C120 ) is  ascending by L1261 , L685;
end;
theorem
L1263: (for R22 being  connected non  empty Poset holds (for R23 being (array of R22) holds (for B37 being  finite (arr_computation of R23) holds (( last B37 ) is (permutation of R23) & (for R1 being  ordinal number holds (R1 in ( dom B37 ) implies ( B37 . R1 ) is (permutation of R23)))))))
proof
let R22 being  connected non  empty Poset;
let R23 being (array of R22);
let C122 being  finite (arr_computation of R23);
consider R1 being  ordinal number, R4 being  ordinal number such that L1264: ( dom C122 ) = ( R1 \ R4 ) by L101;
consider R7 being Nat such that L1265: R1 = ( R4 +^ R7 ) by L1264 , L75;
defpred S13[ Nat ] means (( R4 +^ $1 ) in ( dom C122 ) implies ( C122 . ( R4 +^ $1 ) ) is (permutation of R23));
L1266: ( R4 +^ (( 0 ) qua Ordinal) ) = R4 by ORDINAL2:27;
L1267: R7 <> ( 0 ) by L1266 , L1264 , L1265 , XBOOLE_1:37;
consider C123 being Nat such that L1268: R7 = ( C123 + 1 ) by L1267 , NAT_1:6;
L1269: R1 = ( R4 +^ ( succ C123 ) ) by L1265 , L1268 , NAT_1:38
.= ( succ ( R4 +^ C123 ) ) by ORDINAL2:28;
L1270: ( R4 +^ C123 ) = ( union R1 ) by L1269 , ORDINAL2:2
.= ( union ( R1 \ R4 ) ) by L1264 , L41;
L1271: ( C122 . ( base- C122 ) ) = R23 by L1193;
L1272: ( C122 . R4 ) = R23 by L1271 , L1264 , L292;
L1273: S13[ ( 0 ) ] by L1272 , L1266 , L588;
L1274: (for R9 being Nat holds (S13[ R9 ] implies S13[ ( R9 + 1 ) ]))
proof
let R9 being Nat;
assume L1275: (S13[ R9 ] & ( R4 +^ ( R9 + 1 ) ) in ( dom C122 ));
L1276: ( R9 + 1 ) = ( succ R9 ) by NAT_1:38;
L1277: ( R4 +^ ( R9 + 1 ) ) = ( succ ( R4 +^ R9 ) ) by L1276 , ORDINAL2:28;
L1278: (( R4 +^ R9 ) in ( R4 +^ ( R9 + 1 ) ) & ( R4 +^ ( R9 + 1 ) ) in R1) by L1277 , L1264 , L1275 , ORDINAL1:6;
L1279: (R4 c= ( R4 +^ R9 ) & ( R4 +^ R9 ) in R1) by L1278 , ORDINAL1:10 , ORDINAL3:24;
L1280: ( R4 +^ R9 ) in ( dom C122 ) by L1279 , L1264 , ORDINAL6:5;
consider R24 being (array of R22), R10 being set, R11 being set such that L1281: ([ R10 , R11 ] in ( inversions R24 ) & ( C122 . ( R4 +^ R9 ) ) = R24 & ( C122 . ( R4 +^ ( R9 + 1 ) ) ) = ( Swap (R24 , R10 , R11) )) by L1280 , L1275 , L1277 , L1193;
L1282: (R10 in ( dom R24 ) & R11 in ( dom R24 )) by L1281 , L670;
L1283: ( Swap (R24 , R10 , R11) ) is (permutation of R24) by L1282 , L637;
thus L1284: thesis by L1283 , L1275 , L1264 , L1279 , L1281 , L595 , ORDINAL6:5;
end;
L1285: (for R9 being Nat holds S13[ R9 ]) from NAT_1:sch 2(L1273 , L1274);
L1286: (R4 c= ( R4 +^ C123 ) & ( R4 +^ C123 ) in R1) by L1269 , ORDINAL1:6 , ORDINAL3:24;
L1287: (S13[ C123 ] & ( R4 +^ C123 ) in ( dom C122 )) by L1286 , L1264 , L1285 , ORDINAL6:5;
thus L1288: ( last C122 ) is (permutation of R23) by L1287 , L1264 , L1270;
let R5 being  ordinal number;
assume L1289: R5 in ( dom C122 );
L1290: (R4 c= R5 & R5 in R1) by L1289 , L1264 , ORDINAL6:5;
L1291: R5 = ( R4 +^ ( R5 -^ R4 ) ) by L1290 , ORDINAL3:def 5;
L1292: ( R5 -^ R4 ) in R7 by L1291 , L1265 , L1289 , L1264 , ORDINAL3:22;
reconsider D171 = ( R5 -^ R4 ) as Nat by L1292;
L1293: S13[ D171 ] by L1285;
thus L1294: thesis by L1293 , L1289 , L1290 , ORDINAL3:def 5;
end;
begin
theorem
L1295: (for R14 being set holds (for B38 being ( 0 ) -based  finite (array of R14) holds (B38 <> ( {} ) implies ( last B38 ) in R14)))
proof
let R14 being set;
let C124 being ( 0 ) -based  finite (array of R14);
assume L1296: C124 <> ( {} );
consider R7 being Nat such that L1297: ( dom C124 ) = ( R7 + 1 ) by L1296 , NAT_1:6;
L1298: ( R7 + 1 ) = ( succ R7 ) by NAT_1:38;
L1299: (R7 in ( dom C124 ) & ( union ( dom C124 ) ) = R7) by L1298 , L1297 , ORDINAL1:6 , ORDINAL2:2;
thus L1300: ( last C124 ) in R14 by L1299 , FUNCT_1:102;
end;
theorem
L1301: (for R10 being set holds ( last <% R10 %> ) = R10)
proof
let R10 being set;
L1302: ( dom <% R10 %> ) = ( succ ( 0 ) ) by AFINSQ_1:def 4;
L1303: ( union ( dom <% R10 %> ) ) = ( 0 ) by L1302 , ORDINAL2:2;
thus L1304: thesis by L1303 , AFINSQ_1:def 4;
end;
theorem
L1305: (for R10 being set holds (for B39 being ( 0 ) -based  finite array holds ( last ( B39 ^ <% R10 %> ) ) = R10))
proof
let R10 being set;
let C125 being ( 0 ) -based  finite array;
L1306: ( dom <% R10 %> ) = 1 by AFINSQ_1:def 4;
L1307: ( dom ( C125 ^ <% R10 %> ) ) = ( ( dom C125 ) +^ 1 ) by L1306 , ORDINAL4:def 1
.= ( succ ( dom C125 ) ) by ORDINAL2:31;
L1308: ( union ( dom ( C125 ^ <% R10 %> ) ) ) = ( len C125 ) by L1307 , ORDINAL2:2;
thus L1309: thesis by L1308 , AFINSQ_1:36;
end;
registration
let C126 being set;
cluster  -> C126 -valued for (Element of ( C126 ^omega ));
coherence by AFINSQ_1:42;
end;
scheme A { F3(set) -> set , F4() -> non  empty set , P1[set , set] , F5() -> set } : (ex B40 being  finite ( 0 ) -based non  empty array st (ex B41 being (Element of F4()) st (B41 = ( last B40 ) & F3(B41) = ( {} ) & ( B40 . ( 0 ) ) = F5() & (for R1 being  ordinal number holds (( succ R1 ) in ( dom B40 ) implies (ex B42 , B43 being (Element of F4()) st (B42 = ( B40 . R1 ) & B43 = ( B40 . ( succ R1 ) ) & P1[ B42 , B43 ])))))))
provided
L1311: F5() in F4()
and
L1312: F3(F5()) is  finite
and
L1313: (for B44 being (Element of F4()) holds (F3(B44) <> ( {} ) implies (ex B45 being (Element of F4()) st (P1[ B44 , B45 ] & F3(B45) c< F3(B44)))))
proof
set D172 = ( F4() ^omega );
reconsider D173 = F5() as (Element of F4()) by L1311;
reconsider D174 = <% D173 %> as (Element of D172) by AFINSQ_1:42;
defpred S14[ set , (Element of D172) , (Element of D172) ] means ((($2 = ( {} ) or F3(( last $2 )) = ( {} )) implies $2 = $3) & (($2 <> ( {} ) & F3(( last $2 )) <> ( {} )) implies (ex B46 being (Element of F4()) st (P1[ ( last $2 ) , B46 ] & F3(B46) c< F3(( last $2 )) & ( $2 ^ <% B46 %> ) = $3))));
L1314: (for B47 being (Element of ( NAT )) holds (for B48 being (Element of D172) holds (ex B49 being (Element of D172) st S14[ B47 , B48 , B49 ])))
proof
let C127 being (Element of ( NAT ));
let C128 being (Element of D172);
per cases ;
suppose L1315: (C128 = ( {} ) or F3(( last C128 )) = ( {} ));

take D175 = C128;
thus L1316: S14[ C127 , C128 , D175 ] by L1315;
end;
suppose L1317: (C128 <> ( {} ) & F3(( last C128 )) <> ( {} ));

L1318: ( last C128 ) in F4() by L1317 , L1295;
consider C129 being (Element of F4()) such that L1319: (P1[ ( last C128 ) , C129 ] & F3(C129) c< F3(( last C128 ))) by L1318 , L1313 , L1317;
reconsider D176 = ( C128 ^ <% C129 %> ) as (Element of D172) by AFINSQ_1:42;
take D176;
thus L1320: S14[ C127 , C128 , D176 ] by L1317 , L1319;
end;
end;
consider C130 being (Function of ( NAT ) , D172) such that L1322: (( C130 . ( 0 ) ) = D174 & (for B50 being (Element of ( NAT )) holds S14[ B50 , (( C130 . B50 ) qua (Element of D172)) , (( C130 . ( B50 + 1 ) ) qua (Element of D172)) ])) from RECDEF_1:sch 2(L1314);
defpred S15[ Nat ] means ( C130 . $1 ) <> ( {} );
L1323: S15[ ( 0 ) ] by L1322;
L1324: (for R8 being Nat holds (S15[ R8 ] implies S15[ ( R8 + 1 ) ]))
proof
let R8 being Nat;
assume L1325: S15[ R8 ];
reconsider D177 = ( C130 . R8 ) as non  empty T-Sequence by L1325;
L1326: R8 in ( NAT ) by ORDINAL1:def 12;
L1327: S14[ R8 , (( C130 . R8 ) qua (Element of D172)) , (( C130 . ( R8 + 1 ) ) qua (Element of D172)) ] by L1326 , L1322;
L1328: (( C130 . ( R8 + 1 ) ) = D177 or (ex R10 being set st ( C130 . ( R8 + 1 ) ) = ( D177 ^ <% R10 %> ))) by L1327;
thus L1329: thesis by L1328;
end;
L1330: (for R8 being Nat holds S15[ R8 ]) from NAT_1:sch 2(L1323 , L1324);
defpred S16[ Function ] means (( $1 . ( 0 ) ) = F5() & (for R1 being  ordinal number holds (( succ R1 ) in ( dom $1 ) implies (ex B51 , B52 being (Element of F4()) st (B51 = ( $1 . R1 ) & B52 = ( $1 . ( succ R1 ) ) & P1[ B51 , B52 ])))));
defpred S17[ Nat ] means S16[ ( C130 . $1 ) ];
L1331: S17[ ( 0 ) ]
proof
thus L1332: ( ( C130 . ( 0 ) ) . ( 0 ) ) = F5() by L1322 , AFINSQ_1:def 4;
let R1 being  ordinal number;
assume L1333: ( succ R1 ) in ( dom ( C130 . ( 0 ) ) );
L1334: ( succ R1 ) in 1 by L1333 , L1322 , AFINSQ_1:def 4;
thus L1335: thesis by L1334 , CARD_1:49 , TARSKI:def 1;
end;
L1336: (for R8 being Nat holds (S17[ R8 ] implies S17[ ( R8 + 1 ) ]))
proof
let R8 being Nat;
assume L1337: S17[ R8 ];
L1338: R8 in ( NAT ) by ORDINAL1:def 12;
L1339: S14[ R8 , (( C130 . R8 ) qua (Element of D172)) , (( C130 . ( R8 + 1 ) ) qua (Element of D172)) ] by L1338 , L1322;
per cases ;
suppose L1340: (( C130 . R8 ) = ( {} ) or F3(( last (( C130 . R8 ) qua (Element of D172)) )) = ( {} ));

thus L1341: thesis by L1340 , L1337 , L1339;
end;
suppose L1342: (( C130 . R8 ) <> ( {} ) & F3(( last (( C130 . R8 ) qua (Element of D172)) )) <> ( {} ));

reconsider D178 = ( C130 . R8 ) as non  empty  finite (T-Sequence of F4()) by L1342;
reconsider D179 = ( C130 . ( R8 + 1 ) ) as  finite (T-Sequence of F4());
consider C131 being (Element of F4()) such that L1343: (P1[ ( last D178 ) , C131 ] & F3(C131) c< F3(( last D178 )) & ( D178 ^ <% C131 %> ) = ( C130 . ( R8 + 1 ) )) by L1322 , L1338 , L1342;
L1344: ( 0 ) in ( dom D178 ) by ORDINAL3:8;
thus L1345: ( ( C130 . ( R8 + 1 ) ) . ( 0 ) ) = F5() by L1344 , L1337 , L1343 , ORDINAL4:def 1;
let R1 being  ordinal number;
assume L1346: ( succ R1 ) in ( dom ( C130 . ( R8 + 1 ) ) );
L1347: R1 in ( succ R1 ) by ORDINAL1:6;
L1348: R1 in ( dom D179 ) by L1347 , L1346 , ORDINAL1:10;
reconsider D180 = R1 as Nat by L1346 , L1347;
reconsider D181 = ( D179 . R1 ) , D182 = ( D179 . ( succ R1 ) ) as (Element of F4()) by L1346 , L1348 , FUNCT_1:102;
L1349: ( dom <% C131 %> ) = 1 by AFINSQ_1:def 4;
L1350: ( dom D179 ) = ( ( dom D178 ) +^ 1 ) by L1349 , L1343 , ORDINAL4:def 1
.= ( succ ( dom D178 ) ) by ORDINAL2:31;
L1351: R1 in ( dom D178 ) by L1350 , L1346 , ORDINAL3:3;
take D181;
take D182;
thus L1352: (D181 = ( ( C130 . ( R8 + 1 ) ) . R1 ) & D182 = ( ( C130 . ( R8 + 1 ) ) . ( succ R1 ) ));
per cases  by ORDINAL6:4;
suppose L1353: ( succ R1 ) in ( dom D178 );

L1354: R1 in ( dom D178 ) by L1353 , L1347 , ORDINAL1:10;
L1355: (D181 = ( D178 . R1 ) & D182 = ( D178 . ( succ R1 ) )) by L1354 , L1343 , L1353 , ORDINAL4:def 1;
L1356: (ex B53 , B54 being (Element of F4()) st (B53 = ( D178 . R1 ) & B54 = ( D178 . ( succ R1 ) ) & P1[ B53 , B54 ])) by L1337 , L1353;
thus L1357: P1[ D181 , D182 ] by L1356 , L1355;
end;
suppose L1358: ( dom D178 ) c= ( succ R1 );

L1359: ( succ R1 ) c= ( dom D178 ) by L1351 , ORDINAL1:21;
L1360: ( dom D178 ) = ( succ R1 ) by L1359 , L1358 , XBOOLE_0:def 10;
L1361: ( union ( dom D178 ) ) = R1 by L1360 , ORDINAL2:2;
L1362: ( last D178 ) = ( D179 . R1 ) by L1361 , L1343 , L1351 , ORDINAL4:def 1;
L1363: (( 0 ) in 1 & ( ( succ R1 ) +^ (( 0 ) qua Ordinal) ) = ( succ R1 )) by NAT_1:44 , ORDINAL2:27;
L1364: D182 = ( <% C131 %> . ( 0 ) ) by L1363 , L1349 , L1343 , L1360 , ORDINAL4:def 1;
thus L1365: P1[ D181 , D182 ] by L1364 , L1343 , L1362 , AFINSQ_1:def 4;
end;
end;
end;
L1368: (for R8 being Nat holds S17[ R8 ]) from NAT_1:sch 2(L1331 , L1336);
defpred S18[ Nat ] means (ex R7 being Nat st ( card F3(( last (( C130 . R7 ) qua (Element of D172)) )) ) = $1);
L1369: (ex R7 being Nat st S18[ R7 ])
proof
L1370: ( last D174 ) = D173 by L1301;
reconsider D183 = ( card F3(( last (( C130 . ( 0 ) ) qua (Element of D172)) )) ) as Nat by L1370 , L1312 , L1322;
take D183;
thus L1371: thesis;
end;
L1372: (for R7 being Nat holds ((R7 <> ( 0 ) & S18[ R7 ]) implies (ex R8 being Nat st (R8 < R7 & S18[ R8 ]))))
proof
let R7 being Nat;
assume L1373: R7 <> ( 0 );
given C132 being Nat such that
L1374: ( card F3(( last (( C130 . C132 ) qua (Element of D172)) )) ) = R7;

reconsider D184 = ( C130 . C132 ) , D185 = ( C130 . ( C132 + 1 ) ) as (Element of D172);
L1375: C132 in ( NAT ) by ORDINAL1:def 12;
L1376: (S14[ C132 , D184 , D185 ] & D184 <> ( {} )) by L1375 , L1330 , L1322;
consider C133 being (Element of F4()) such that L1377: (P1[ ( last D184 ) , C133 ] & F3(C133) c< F3(( last D184 )) & ( D184 ^ <% C133 %> ) = D185) by L1376 , L1373 , L1374;
L1378: (F3(( last D184 )) is  finite & F3(C133) c= F3(( last D184 ))) by L1374 , L1377 , XBOOLE_0:def 8;
L1379: ( last D185 ) = C133 by L1377 , L1305;
reconsider D186 = ( card F3(( last D185 )) ) as Nat by L1379 , L1378;
take D186;
thus L1380: D186 < R7 by L1374 , L1377 , L1378 , L1379 , TREES_1:6;
thus L1381: S18[ D186 ];
end;
L1382: S18[ ( 0 ) ] from NAT_1:sch 7(L1369 , L1372);
consider R7 being Nat such that L1383: ( card F3(( last (( C130 . R7 ) qua (Element of D172)) )) ) = ( 0 ) by L1382;
reconsider D187 = ( C130 . R7 ) as non  empty (XFinSequence of F4()) by L1330;
take D187;
reconsider D188 = ( last D187 ) as (Element of F4()) by L1295;
take D188;
thus L1384: (D188 = ( last D187 ) & F3(D188) = ( {} )) by L1383;
thus L1385: S16[ D187 ] by L1368;
end;
theorem
L1386: (for R30 being array holds (for R31 being (permutation of R30) holds R31 in ( Funcs (( dom R30 ) , ( rng R30 )) )))
proof
let R30 being array;
let R31 being (permutation of R30);
L1387: (( dom R31 ) = ( dom R30 ) & ( rng R31 ) = ( rng R30 )) by L583;
thus L1388: thesis by L1387 , FUNCT_2:def 2;
end;
registration
let C134 being  real-valued array;
cluster  ->  real-valued for (permutation of C134);
coherence
proof
let C135 being (permutation of C134);
L1389: (ex B55 being (Permutation of ( dom C134 )) st C135 = ( C134 * B55 )) by L580;
thus L1390: thesis by L1389;
end;
end;
registration
let R1 being  ordinal number;
let C136 being non  empty set;
cluster  ->  T-Sequence-like for (Element of ( Funcs (R1 , C136) ));
coherence
proof
let C137 being (Element of ( Funcs (R1 , C136) ));
L1392: ( dom C137 ) = R1 by FUNCT_2:92;
thus L1393: thesis by L1392 , ORDINAL1:def 7;
end;
end;
registration
let R14 being set;
let C138 being  real-membered non  empty set;
cluster  ->  real-valued for (Element of ( Funcs (R14 , C138) ));
coherence;
end;
registration
let R14 being set;
let C139 being (array of R14);
cluster  -> R14 -valued for (permutation of C139);
coherence
proof
let C140 being (permutation of C139);
L1396: (ex B56 being (Permutation of ( dom C139 )) st C140 = ( C139 * B56 )) by L580;
thus L1397: thesis by L1396;
end;
end;
registration
let C141 being set;
let C142 being set;
let C143 being (Subset of C142);
cluster  -> C142 -valued for (Element of ( Funcs (C141 , C143) ));
coherence
proof
let C144 being (Element of ( Funcs (C141 , C143) ));
per cases  by SUBSET_1:def 1;
suppose L1399: C144 = ( {} );

L1400: ( rng C144 ) = ( {} ) by L1399;
thus L1401: ( rng C144 ) c= C142 by L1400 , XBOOLE_1:2;
end;
suppose L1402: ( Funcs (C141 , C143) ) <> ( {} );

L1403: ( rng C144 ) c= C143 by L1402 , FUNCT_2:92;
thus L1404: ( rng C144 ) c= C142 by L1403 , XBOOLE_1:1;
end;
end;
end;
theorem
L1407: (for R14 being set holds (for R15 being set holds (for B57 being R14 -defined R15 -valued Relation holds B57 is (Relation of R14 , R15))))
proof
let R14 being set;
let R15 being set;
let C145 being R14 -defined R15 -valued Relation;
L1408: ([: ( dom C145 ) , ( rng C145 ) :] c= [: R14 , R15 :] & C145 c= [: ( dom C145 ) , ( rng C145 ) :]) by RELAT_1:7 , ZFMISC_1:96;
thus L1409: C145 is (Relation of R14 , R15) by L1408 , XBOOLE_1:1;
end;
theorem
L1410: (for B58 being  finite Ordinal holds (for R10 being set holds (R10 in B58 implies (R10 = ( 0 ) or (ex R4 being  ordinal number st R10 = ( succ R4 ))))))
proof
let C146 being  finite Ordinal;
let R10 being set;
assume L1411: (R10 in C146 & R10 <> ( 0 ));
L1412: ( {} ) in R10 by L1411 , ORDINAL3:8;
L1413:
now
assume L1414: R10 is  limit_ordinal;
L1415: (( omega ) c= R10 & R10 c= C146) by L1414 , L1411 , L1412 , ORDINAL1:def 2 , ORDINAL1:def 11;
thus L1416: contradiction by L1415;
end;
thus L1417: thesis by L1413 , L1411 , ORDINAL1:29;
end;
theorem
L1418: (for R22 being  connected non  empty Poset holds (for B59 being ( 0 ) -based  finite non  empty (array of R22) holds (ex B60 being ( 0 ) -based (arr_computation of B59) st B60 is  complete)))
proof
let R22 being  connected non  empty Poset;
let C147 being ( 0 ) -based  finite non  empty (array of R22);
reconsider D189 = ( rng C147 ) as non  empty (Subset of R22) by RELAT_1:def 19;
reconsider D190 = ( dom C147 ) as Ordinal;
set D191 = ( Funcs (D190 , D189) );
deffunc H7((array of R22)) = ( card ( inversions $1 ) );
defpred S19[ (Element of D191) , (Element of D191) ] means (ex B61 , B62 being (Element of ( dom C147 )) st ([ B61 , B62 ] in ( inversions (($1 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22)) ) & $2 = ( Swap ($1 , B61 , B62) )));
L1419: C147 is (permutation of C147) by L588;
L1420: C147 in D191 by L1419 , L1386;
L1421: H7(C147) is  finite;
L1422: (for B63 being (Element of D191) holds (H7(((B63 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22))) <> ( {} ) implies (ex B64 being (Element of D191) st (S19[ B63 , B64 ] & H7(((B64 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22))) c< H7(((B63 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22)))))))
proof
let C148 being (Element of D191);
reconsider D192 = C148 as (array of R22);
set D193 = the (Element of ( inversions D192 ));
set D194 = H7(((C148 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22)));
assume L1423: D194 <> ( {} );
L1424: ( inversions D192 ) <> ( {} ) by L1423;
L1425: (D193 in ( inversions D192 ) & ( inversions D192 ) is (Relation of ( dom C148 ) , ( dom C148 ))) by L1424 , L677;
consider C149 , C150 being set such that L1426: (D193 = [ C149 , C150 ] & C149 in ( dom C148 ) & C150 in ( dom C148 )) by L1425 , RELSET_1:2;
set D195 = ( Swap (C148 , C149 , C150) );
L1427: (( dom D195 ) = ( dom C148 ) & ( rng D195 ) = ( rng C148 )) by FUNCT_7:99 , FUNCT_7:103;
L1428: (( dom C148 ) = ( dom C147 ) & ( rng C148 ) c= ( rng C147 )) by FUNCT_2:92;
reconsider D196 = D195 as (Element of D191) by L1428 , L1427 , FUNCT_2:def 2;
reconsider D197 = D196 as (array of R22);
set D198 = H7(((D196 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22)));
take D196;
thus L1429: S19[ C148 , D196 ] by L1424 , L1426;
L1430: H7(D197) in H7(D192) by L1424 , L1426 , L1173;
thus L1431: (D198 c= D194 & D198 <> D194) by L1430 , ORDINAL1:def 2;
end;
consider C151 being  finite ( 0 ) -based non  empty array, C152 being (Element of D191) such that L1432: (C152 = ( last C151 ) & H7(((C152 qua (Element of ( Funcs (D190 , (D189 qua (Subset of R22))) ))) qua (array of R22))) = ( {} ) & ( C151 . ( 0 ) ) = C147) and L1433: (for R1 being  ordinal number holds (( succ R1 ) in ( dom C151 ) implies (ex B65 , B66 being (Element of D191) st (B65 = ( C151 . R1 ) & B66 = ( C151 . ( succ R1 ) ) & S19[ B65 , B66 ])))) from A(L1420 , L1421 , L1422);
L1434: C151 is (arr_computation of C147)
proof
thus L1435: ( C151 . ( base- C151 ) ) = C147 by L1432 , L315;
thus L1436: (for R1 being  ordinal number holds (R1 in ( dom C151 ) implies ( C151 . R1 ) is (array of R22)))
proof
let R1 being  ordinal number;
assume L1437: R1 in ( dom C151 );
per cases  by L1437 , L1410;
suppose L1438: R1 = ( 0 );

thus L1439: ( C151 . R1 ) is (array of R22) by L1438 , L1432;
end;
suppose L1440: (ex R4 being  ordinal number st R1 = ( succ R4 ));

consider R4 being  ordinal number such that L1441: R1 = ( succ R4 ) by L1440;
L1442: (ex B67 , B68 being (Element of D191) st (B67 = ( C151 . R4 ) & B68 = ( C151 . R1 ) & S19[ B67 , B68 ])) by L1433 , L1437 , L1441;
thus L1443: ( C151 . R1 ) is (array of R22) by L1442;
end;
end;

let R1 being  ordinal number;
assume L1445: (R1 in ( dom C151 ) & ( succ R1 ) in ( dom C151 ));
L1446: (ex B69 , B70 being (Element of D191) st (B69 = ( C151 . R1 ) & B70 = ( C151 . ( succ R1 ) ) & S19[ B69 , B70 ])) by L1445 , L1433;
thus L1447: thesis by L1446;
end;
reconsider D199 = C151 as ( 0 ) -based (arr_computation of C147) by L1434;
take D199;
L1448: ( inversions ( last D199 ) ) = ( {} ) by L1432;
thus L1449: ( last D199 ) is  ascending by L1448 , L685;
end;
theorem
L1450: (for R22 being  connected non  empty Poset holds (for B71 being ( 0 ) -based  finite non  empty (array of R22) holds (ex B72 being (permutation of B71) st B72 is  ascending)))
proof
let R22 being  connected non  empty Poset;
let C153 being ( 0 ) -based  finite non  empty (array of R22);
consider C154 being ( 0 ) -based (arr_computation of C153) such that L1451: C154 is  complete by L1418;
L1452: C154 is  finite by L1239;
reconsider D200 = ( last C154 ) as (permutation of C153) by L1452 , L1263;
take D200;
thus L1453: D200 is  ascending by L1451 , L1237;
end;
registration
let R22 being  connected non  empty Poset;
let C155 being ( 0 ) -based  finite (array of R22);
cluster  ascending for (permutation of C155);
existence
proof
L1454: C155 is (permutation of C155) by L588;
L1455: (C155 is  empty implies C155 is  ascending);
thus L1456: thesis by L1455 , L1454 , L1450;
end;
end;
