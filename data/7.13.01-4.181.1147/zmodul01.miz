:: $\mathbb Z$-modules
::  by Yuichi Futa , Hiroyuki Okazaki and Yasunari Shidama
::
:: Received September 5, 2011
:: Copyright (c) 2011-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ALGSTR_0, STRUCT_0, SUBSET_1, BINOP_1, FUNCT_1,
      ZFMISC_1, XBOOLE_0, ORDINAL1, RELAT_1, ARYTM_3, PARTFUN1, SUPINF_2,
      FUNCT_5, MCART_1, ARYTM_1, CARD_1, FINSEQ_1, CARD_3, TARSKI, XXREAL_0,
      RLVECT_1, REALSET1, RLSUB_1, ZMODUL01, INT_1, FINSEQ_4, LATTICES,
      EQREL_1, PBOOLE, RLSUB_2, RMOD_2, RMOD_3, BINOM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1,
      PARTFUN1, MCART_1, FUNCT_2, BINOP_1, DOMAIN_1, FUNCT_3, FUNCT_5, NUMBERS,
      XCMPLX_0, XXREAL_0, NAT_1, INT_1, REALSET1, FINSEQ_1, FINSEQ_4, STRUCT_0,
      ALGSTR_0, LATTICES, RLVECT_1, BINOM;
 constructors BINOP_1, NAT_1, FUNCT_3, FUNCT_5, REALSET1, RELSET_1, LATTICES,
      RLSUB_1, ALGSTR_1, BINOM, FINSEQ_4;
 registrations ORDINAL1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, STRUCT_0, ALGSTR_0,
      FINSEQ_1, CARD_1, SUBSET_1, INT_1, REALSET1, LATTICES, RELAT_1, ALGSTR_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, ALGSTR_0, RLVECT_1, LATTICES, XBOOLE_0,
      REALSET1, BINOP_1, BINOM;
 theorems FUNCT_1, NAT_1, TARSKI, RELAT_1, STRUCT_0, XBOOLE_0, XBOOLE_1,
      FINSEQ_1, ALGSTR_0, BINOM, CARD_1, FINSEQ_3, INT_1, RLVECT_1, BINOP_1,
      LATTICES, MCART_1, ZFMISC_1, PARTFUN1, FUNCT_2, RELSET_1, XREAL_1,
      RLSUB_2, XTUPLE_0;
 schemes NAT_1, BINOP_1, FUNCT_1, XBOOLE_0;

begin
definition
struct (addLoopStr) Z_ModuleStruct(# carrier -> set , ZeroF -> (Element of the carrier) , addF -> (BinOp of the carrier) , Mult -> (Function of [: ( INT ) , the carrier :] , the carrier) #);
end;
registration
cluster non  empty for Z_ModuleStruct;
existence
proof
set D1 = the non  empty set;
set D2 = the (Element of D1);
set D3 = the (BinOp of D1);
set D4 = the (Function of [: ( INT ) , D1 :] , D1);
take Z_ModuleStruct (# D1 , D2 , D3 , D4 #);
thus L2: (the carrier of Z_ModuleStruct (# D1 , D2 , D3 , D4 #)) is non  empty;
end;
end;
definition
let C1 being Z_ModuleStruct;
mode VECTOR of C1
 is (Element of C1);
end;
definition
let R1 being non  empty Z_ModuleStruct;
let R7 being (VECTOR of R1);
let C2 being  integer number;
func C2 * R7 -> (Element of R1) equals
( (the Mult of R1) . (C2 , R7) );
coherence
proof
reconsider D5 = C2 as (Element of ( INT )) by INT_1:def 2;
L5: ( (the Mult of R1) . (D5 , R7) ) is (Element of R1);
thus L6: thesis by L5;
end;
end;
registration
let C3 being non  empty set;
let C4 being (Element of C3);
let C5 being (BinOp of C3);
let C6 being (Function of [: ( INT ) , C3 :] , C3);
cluster Z_ModuleStruct (# C3 , C4 , C5 , C6 #) -> non  empty;
coherence;
end;
definition
let C7 being non  empty Z_ModuleStruct;
attr C7 is  vector-distributive
means
:L9: (for R5 being  integer number holds (for B1 , B2 being (VECTOR of C7) holds ( R5 * ( B1 + B2 ) ) = ( ( R5 * B1 ) + ( R5 * B2 ) )));
attr C7 is  scalar-distributive
means
:L10: (for R5 being  integer number holds (for R6 being  integer number holds (for B3 being (VECTOR of C7) holds ( ( R5 + R6 ) * B3 ) = ( ( R5 * B3 ) + ( R6 * B3 ) ))));
attr C7 is  scalar-associative
means
:L11: (for R5 being  integer number holds (for R6 being  integer number holds (for B4 being (VECTOR of C7) holds ( ( R5 * R6 ) * B4 ) = ( R5 * ( R6 * B4 ) ))));
attr C7 is  scalar-unital
means
:L12: (for B5 being (VECTOR of C7) holds ( 1 * B5 ) = B5);
end;
definition
func Trivial-Z_ModuleStruct ->  strict Z_ModuleStruct equals
Z_ModuleStruct (# 1 , ( op0 ) , ( op2 ) , ( pr2 (( INT ) , 1) ) #);
coherence;
end;
registration
cluster ( Trivial-Z_ModuleStruct ) ->  trivial non  empty;
coherence by CARD_1:49;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  scalar-distributive  vector-distributive  scalar-associative  scalar-unital for non  empty non  empty non  empty non  empty Z_ModuleStruct;
existence
proof
take D6 = ( Trivial-Z_ModuleStruct );
thus L16: D6 is  strict;
thus L17: D6 is  Abelian;
thus L18: D6 is  add-associative;
thus L19: D6 is  right_zeroed;
thus L20: D6 is  right_complementable;
thus L21: (for R5 being  integer number holds (for R6 being  integer number holds (for B6 being (VECTOR of D6) holds ( ( R5 + R6 ) * B6 ) = ( ( R5 * B6 ) + ( R6 * B6 ) )))) by STRUCT_0:def 10;
thus L22: (for R5 being  integer number holds (for B7 , B8 being (VECTOR of D6) holds ( R5 * ( B7 + B8 ) ) = ( ( R5 * B7 ) + ( R5 * B8 ) ))) by STRUCT_0:def 10;
thus L23: (for R5 being  integer number holds (for R6 being  integer number holds (for B9 being (VECTOR of D6) holds ( ( R5 * R6 ) * B9 ) = ( R5 * ( R6 * B9 ) )))) by STRUCT_0:def 10;
thus L24: (for B10 being (VECTOR of D6) holds ( 1 * B10 ) = B10) by STRUCT_0:def 10;
end;
end;
definition
mode Z_Module
 is  Abelian  add-associative  right_zeroed  right_complementable  scalar-distributive  vector-distributive  scalar-associative  scalar-unital non  empty Z_ModuleStruct;
end;
definition
let C8 being non  empty Z_ModuleStruct;
attr C8 is  Mult-cancelable
means
:L27: (for R5 being  integer number holds (for B11 being (VECTOR of C8) holds (( R5 * B11 ) = ( 0. C8 ) implies (R5 = ( 0 ) or B11 = ( 0. C8 )))));
end;
theorem
L29: (for R5 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ((R5 = ( 0 ) or R9 = ( 0. R8 )) implies ( R5 * R9 ) = ( 0. R8 )))))
proof
let R5 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
reconsider D7 = 1 , D8 = ( 0 ) as Integer;
assume L30: (R5 = ( 0 ) or R9 = ( 0. R8 ));
L31:
now
per cases  by L30;
suppose L32: R5 = ( 0 );

L33: ( R9 + ( D8 * R9 ) ) = ( ( D7 * R9 ) + ( D8 * R9 ) ) by L12
.= ( ( D7 + D8 ) * R9 ) by L10
.= R9 by L12
.= ( R9 + ( 0. R8 ) ) by RLVECT_1:4;
thus L34: thesis by L33 , L32 , RLVECT_1:8;
end;
suppose L35: R9 = ( 0. R8 );

L36: ( ( R5 * ( 0. R8 ) ) + ( R5 * ( 0. R8 ) ) ) = ( R5 * ( ( 0. R8 ) + ( 0. R8 ) ) ) by L9
.= ( R5 * ( 0. R8 ) ) by RLVECT_1:4
.= ( ( R5 * ( 0. R8 ) ) + ( 0. R8 ) ) by RLVECT_1:4;
thus L37: thesis by L36 , L35 , RLVECT_1:8;
end;
end;
thus L39: thesis by L31;
end;
theorem
L40: (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ( - R9 ) = ( ( - 1 ) * R9 )))
proof
let R8 being Z_Module;
let R9 being (VECTOR of R8);
reconsider D9 = 1 , D10 = ( 0 ) , D11 = ( - 1 ) as Integer;
L41: ( R9 + ( ( - 1 ) * R9 ) ) = ( ( 1 * R9 ) + ( ( - 1 ) * R9 ) ) by L12
.= ( ( 1 + ( - 1 ) ) * R9 ) by L10
.= ( 0. R8 ) by L29;
thus L42: ( - R9 ) = ( ( - R9 ) + ( R9 + ( ( - 1 ) * R9 ) ) ) by L41 , RLVECT_1:4
.= ( ( ( - R9 ) + R9 ) + ( ( - 1 ) * R9 ) ) by RLVECT_1:def 3
.= ( ( 0. R8 ) + ( ( - 1 ) * R9 ) ) by RLVECT_1:def 10
.= ( ( - 1 ) * R9 ) by RLVECT_1:4;
end;
theorem
L43: (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ((R8 is  Mult-cancelable & R9 = ( - R9 )) implies R9 = ( 0. R8 ))))
proof
let R8 being Z_Module;
let R9 being (VECTOR of R8);
assume L44: R8 is  Mult-cancelable;
assume L45: R9 = ( - R9 );
L46: ( 0. R8 ) = ( R9 + R9 ) by L45 , RLVECT_1:def 10
.= ( ( 1 * R9 ) + R9 ) by L12
.= ( ( 1 * R9 ) + ( 1 * R9 ) ) by L12
.= ( ( 1 + 1 ) * R9 ) by L10
.= ( 2 * R9 );
thus L47: thesis by L46 , L44 , L27;
end;
theorem
L48: (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ((R8 is  Mult-cancelable & ( R9 + R9 ) = ( 0. R8 )) implies R9 = ( 0. R8 ))))
proof
let R8 being Z_Module;
let R9 being (VECTOR of R8);
assume L49: R8 is  Mult-cancelable;
assume L50: ( R9 + R9 ) = ( 0. R8 );
L51: R9 = ( - R9 ) by L50 , RLVECT_1:def 10;
thus L52: thesis by L51 , L49 , L43;
end;
theorem
L53: (for R5 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ( R5 * ( - R9 ) ) = ( ( - R5 ) * R9 ))))
proof
let R5 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
thus L54: ( R5 * ( - R9 ) ) = ( R5 * ( ( - 1 ) * R9 ) ) by L40
.= ( ( R5 * ( - 1 ) ) * R9 ) by L11
.= ( ( - R5 ) * R9 );
end;
theorem
L55: (for R5 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ( R5 * ( - R9 ) ) = ( - ( R5 * R9 ) ))))
proof
let R5 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
thus L56: ( R5 * ( - R9 ) ) = ( ( - ( 1 * R5 ) ) * R9 ) by L53
.= ( ( ( - 1 ) * R5 ) * R9 )
.= ( ( - 1 ) * ( R5 * R9 ) ) by L11
.= ( - ( R5 * R9 ) ) by L40;
end;
theorem
L57: (for R5 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ( ( - R5 ) * ( - R9 ) ) = ( R5 * R9 ))))
proof
let R5 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
thus L58: ( ( - R5 ) * ( - R9 ) ) = ( ( - ( - R5 ) ) * R9 ) by L53
.= ( R5 * R9 );
end;
theorem
L59: (for R5 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds (for R10 being (VECTOR of R8) holds ( R5 * ( R9 - R10 ) ) = ( ( R5 * R9 ) - ( R5 * R10 ) )))))
proof
let R5 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
let R10 being (VECTOR of R8);
thus L60: ( R5 * ( R9 - R10 ) ) = ( ( R5 * R9 ) + ( R5 * ( - R10 ) ) ) by L9
.= ( ( R5 * R9 ) - ( R5 * R10 ) ) by L55;
end;
theorem
L61: (for R5 being  integer number holds (for R6 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ( ( R5 - R6 ) * R9 ) = ( ( R5 * R9 ) - ( R6 * R9 ) )))))
proof
let R5 being  integer number;
let R6 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
thus L62: ( ( R5 - R6 ) * R9 ) = ( ( R5 + ( - R6 ) ) * R9 )
.= ( ( R5 * R9 ) + ( ( - R6 ) * R9 ) ) by L10
.= ( ( R5 * R9 ) + ( R6 * ( - R9 ) ) ) by L53
.= ( ( R5 * R9 ) - ( R6 * R9 ) ) by L55;
end;
theorem
L63: (for R5 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds (for R10 being (VECTOR of R8) holds ((R8 is  Mult-cancelable & R5 <> ( 0 ) & ( R5 * R9 ) = ( R5 * R10 )) implies R9 = R10)))))
proof
let R5 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
let R10 being (VECTOR of R8);
assume L64: R8 is  Mult-cancelable;
assume that
L65: R5 <> ( 0 )
and
L66: ( R5 * R9 ) = ( R5 * R10 );
L67: ( 0. R8 ) = ( ( R5 * R9 ) - ( R5 * R10 ) ) by L66 , RLVECT_1:15
.= ( R5 * ( R9 - R10 ) ) by L59;
L68: ( R9 - R10 ) = ( 0. R8 ) by L67 , L65 , L64 , L27;
thus L69: thesis by L68 , RLVECT_1:21;
end;
theorem
L70: (for R5 being  integer number holds (for R6 being  integer number holds (for R8 being Z_Module holds (for R9 being (VECTOR of R8) holds ((R8 is  Mult-cancelable & R9 <> ( 0. R8 ) & ( R5 * R9 ) = ( R6 * R9 )) implies R5 = R6)))))
proof
let R5 being  integer number;
let R6 being  integer number;
let R8 being Z_Module;
let R9 being (VECTOR of R8);
assume L71: R8 is  Mult-cancelable;
assume that
L72: R9 <> ( 0. R8 )
and
L73: ( R5 * R9 ) = ( R6 * R9 );
L74: ( 0. R8 ) = ( ( R5 * R9 ) - ( R6 * R9 ) ) by L73 , RLVECT_1:15
.= ( ( R5 - R6 ) * R9 ) by L61;
L75: ( ( - R6 ) + R5 ) = ( 0 ) by L74 , L72 , L71 , L27;
thus L76: thesis by L75;
end;
L77: (for R11 being Z_Module holds ( Sum ( <*> (the carrier of R11) ) ) = ( 0. R11 ))
proof
let R11 being Z_Module;
set D12 = ( <*> (the carrier of R11) );
L78: (ex R22 being (Function of ( NAT ) , (the carrier of R11)) st (( Sum D12 ) = ( R22 . ( len D12 ) ) & ( R22 . ( 0 ) ) = ( 0. R11 ) & (for R19 being (Element of ( NAT )) holds (for R13 being (VECTOR of R11) holds ((R19 < ( len D12 ) & R13 = ( D12 . ( R19 + 1 ) )) implies ( R22 . ( R19 + 1 ) ) = ( ( R22 . R19 ) + R13 )))))) by RLVECT_1:def 12;
thus L79: thesis by L78;
end;
L80: (for R11 being Z_Module holds (for R15 being (FinSequence of R11) holds (( len R15 ) = ( 0 ) implies ( Sum R15 ) = ( 0. R11 ))))
proof
let R11 being Z_Module;
let R15 being (FinSequence of R11);
assume L81: ( len R15 ) = ( 0 );
L82: R15 = ( <*> (the carrier of R11) ) by L81;
thus L83: thesis by L82 , L77;
end;
theorem
L84: (for R5 being  integer number holds (for R11 being Z_Module holds (for R15 being (FinSequence of R11) holds (for R16 being (FinSequence of R11) holds ((( len R15 ) = ( len R16 ) & (for R20 being (Element of ( NAT )) holds (for R13 being (VECTOR of R11) holds ((R20 in ( dom R15 ) & R13 = ( R16 . R20 )) implies ( R15 . R20 ) = ( R5 * R13 ))))) implies ( Sum R15 ) = ( R5 * ( Sum R16 ) ))))))
proof
let R5 being  integer number;
let R11 being Z_Module;
let R15 being (FinSequence of R11);
let R16 being (FinSequence of R11);
defpred S1[ set ] means (for R17 being (FinSequence of R11) holds (for R18 being (FinSequence of R11) holds ((( len R17 ) = ( len R18 ) & ( len R17 ) = $1 & (for R20 being (Element of ( NAT )) holds (for R13 being (VECTOR of R11) holds ((R20 in ( Seg ( len R17 ) ) & R13 = ( R18 . R20 )) implies ( R17 . R20 ) = ( R5 * R13 ))))) implies ( Sum R17 ) = ( R5 * ( Sum R18 ) ))));
L85: ( dom R15 ) = ( Seg ( len R15 ) ) by FINSEQ_1:def 3;
L86:
now
let R21 being (Element of ( NAT ));
assume L87: (for R17 being (FinSequence of R11) holds (for R18 being (FinSequence of R11) holds ((( len R17 ) = ( len R18 ) & ( len R17 ) = R21 & (for R20 being (Element of ( NAT )) holds (for R13 being (VECTOR of R11) holds ((R20 in ( Seg ( len R17 ) ) & R13 = ( R18 . R20 )) implies ( R17 . R20 ) = ( R5 * R13 ))))) implies ( Sum R17 ) = ( R5 * ( Sum R18 ) ))));
let R17 being (FinSequence of R11);
let R18 being (FinSequence of R11);
assume that
L88: ( len R17 ) = ( len R18 )
and
L89: ( len R17 ) = ( R21 + 1 )
and
L90: (for R20 being (Element of ( NAT )) holds (for R13 being (VECTOR of R11) holds ((R20 in ( Seg ( len R17 ) ) & R13 = ( R18 . R20 )) implies ( R17 . R20 ) = ( R5 * R13 ))));
reconsider D13 = ( R17 | ( Seg R21 ) ) , D14 = ( R18 | ( Seg R21 ) ) as (FinSequence of (the carrier of R11)) by FINSEQ_1:18;
L91: R21 <= ( R21 + 1 ) by NAT_1:12;
L92: ( len D14 ) = R21 by L91 , L88 , L89 , FINSEQ_1:17;
L93: ( len D13 ) = R21 by L89 , L91 , FINSEQ_1:17;
L94:
now
L95: ( len D13 ) <= ( len R17 ) by L89 , L91 , FINSEQ_1:17;
L96: ( Seg ( len D13 ) ) c= ( Seg ( len R17 ) ) by L95 , FINSEQ_1:5;
L97: ( dom D13 ) = ( Seg R21 ) by L89 , L91 , FINSEQ_1:17;
let R20 being (Element of ( NAT ));
let R13 being (VECTOR of R11);
assume that
L98: R20 in ( Seg ( len D13 ) )
and
L99: R13 = ( D14 . R20 );
L100: ( dom D14 ) = ( Seg R21 ) by L88 , L89 , L91 , FINSEQ_1:17;
L101: ( R18 . R20 ) = ( D14 . R20 ) by L100 , L93 , L98 , FUNCT_1:47;
L102: ( R17 . R20 ) = ( R5 * R13 ) by L101 , L90 , L98 , L99 , L96;
thus L103: ( D13 . R20 ) = ( R5 * R13 ) by L102 , L93 , L98 , L97 , FUNCT_1:47;
end;
L104: 1 <= ( R21 + 1 ) by NAT_1:11;
L105: (( R21 + 1 ) in ( dom R17 ) & ( R21 + 1 ) in ( dom R18 )) by L104 , L88 , L89 , FINSEQ_3:25;
reconsider D15 = ( R17 . ( R21 + 1 ) ) , D16 = ( R18 . ( R21 + 1 ) ) as (VECTOR of R11) by L105 , FUNCT_1:102;
L106: D15 = ( R5 * D16 ) by L89 , L90 , FINSEQ_1:4;
L107: ( dom D14 ) = ( Seg ( len D14 ) ) by FINSEQ_1:def 3;
L108: ( dom D13 ) = ( Seg ( len D13 ) ) by FINSEQ_1:def 3;
thus L109: ( Sum R17 ) = ( ( Sum D13 ) + D15 ) by L108 , L89 , L93 , RLVECT_1:38
.= ( ( R5 * ( Sum D14 ) ) + ( R5 * D16 ) ) by L87 , L93 , L92 , L94 , L106
.= ( R5 * ( ( Sum D14 ) + D16 ) ) by L9
.= ( R5 * ( Sum R18 ) ) by L88 , L89 , L92 , L107 , RLVECT_1:38;
end;
L110: (for R21 being (Element of ( NAT )) holds (S1[ R21 ] implies S1[ ( R21 + 1 ) ])) by L86;
L111:
now
let R17 being (FinSequence of R11);
let R18 being (FinSequence of R11);
assume that
L112: ( len R17 ) = ( len R18 )
and
L113: ( len R17 ) = ( 0 )
and
L114: (for R20 being (Element of ( NAT )) holds (for R13 being (VECTOR of R11) holds ((R20 in ( Seg ( len R17 ) ) & R13 = ( R18 . R20 )) implies ( R17 . R20 ) = ( R5 * R13 ))));
L115: ( Sum R17 ) = ( 0. R11 ) by L113 , L80;
thus L116: ( Sum R17 ) = ( R5 * ( Sum R18 ) ) by L115 , L112 , L113 , L80 , L29;
end;
L117: S1[ ( 0 ) ] by L111;
L118: (for R21 being (Element of ( NAT )) holds S1[ R21 ]) from NAT_1:sch 1(L117 , L110);
thus L119: thesis by L118 , L85;
end;
theorem
L120: (for B12 being Z_Module holds (for B13 being Integer holds ( B13 * ( Sum ( <*> (the carrier of B12) ) ) ) = ( 0. B12 ))) by L77 , L29;
theorem
L121: (for B14 being Z_Module holds (for B15 being Integer holds (for B16 , B17 being (VECTOR of B14) holds ( B15 * ( Sum <* B16 , B17 *> ) ) = ( ( B15 * B16 ) + ( B15 * B17 ) ))))
proof
let C9 being Z_Module;
let C10 being Integer;
let C11 , C12 being (VECTOR of C9);
thus L122: ( C10 * ( Sum <* C11 , C12 *> ) ) = ( C10 * ( C11 + C12 ) ) by RLVECT_1:45
.= ( ( C10 * C11 ) + ( C10 * C12 ) ) by L9;
end;
theorem
L123: (for B18 being Z_Module holds (for B19 being Integer holds (for B20 , B21 , B22 being (VECTOR of B18) holds ( B19 * ( Sum <* B20 , B21 , B22 *> ) ) = ( ( ( B19 * B20 ) + ( B19 * B21 ) ) + ( B19 * B22 ) ))))
proof
let C13 being Z_Module;
let C14 being Integer;
let C15 , C16 , C17 being (VECTOR of C13);
thus L124: ( C14 * ( Sum <* C15 , C16 , C17 *> ) ) = ( C14 * ( ( C15 + C16 ) + C17 ) ) by RLVECT_1:46
.= ( ( C14 * ( C15 + C16 ) ) + ( C14 * C17 ) ) by L9
.= ( ( ( C14 * C15 ) + ( C14 * C16 ) ) + ( C14 * C17 ) ) by L9;
end;
theorem
L125: (for R5 being  integer number holds (for R11 being Z_Module holds (for R13 being (VECTOR of R11) holds ( ( - R5 ) * R13 ) = ( - ( R5 * R13 ) ))))
proof
let R5 being  integer number;
let R11 being Z_Module;
let R13 being (VECTOR of R11);
thus L126: ( ( - R5 ) * R13 ) = ( R5 * ( - R13 ) ) by L53
.= ( - ( R5 * R13 ) ) by L55;
end;
theorem
L127: (for R5 being  integer number holds (for R11 being Z_Module holds (for R15 being (FinSequence of R11) holds (for R16 being (FinSequence of R11) holds ((( len R15 ) = ( len R16 ) & (for R20 being (Element of ( NAT )) holds (R20 in ( dom R15 ) implies ( R16 . R20 ) = ( R5 * ( R15 /. R20 ) )))) implies ( Sum R16 ) = ( R5 * ( Sum R15 ) ))))))
proof
let R5 being  integer number;
let R11 being Z_Module;
let R15 being (FinSequence of R11);
let R16 being (FinSequence of R11);
assume that
L128: ( len R15 ) = ( len R16 )
and
L129: (for R20 being (Element of ( NAT )) holds (R20 in ( dom R15 ) implies ( R16 . R20 ) = ( R5 * ( R15 /. R20 ) )));
L130: (( dom R15 ) = ( Seg ( len R15 ) ) & ( dom R16 ) = ( Seg ( len R16 ) )) by FINSEQ_1:def 3;
L131:
now
let R20 being (Element of ( NAT ));
let R13 being (VECTOR of R11);
assume that
L132: R20 in ( dom R16 )
and
L133: R13 = ( R15 . R20 );
L134: R13 = ( R15 /. R20 ) by L128 , L130 , L132 , L133 , PARTFUN1:def 6;
thus L135: ( R16 . R20 ) = ( R5 * R13 ) by L134 , L128 , L129 , L130 , L132;
end;
thus L136: thesis by L131 , L128 , L84;
end;
begin
definition
let R25 being Z_Module;
let R35 being (Subset of R25);
attr R35 is  linearly-closed
means
:L137: ((for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in R35 & R28 in R35) implies ( R31 + R28 ) in R35))) & (for R34 being  integer number holds (for R31 being (VECTOR of R25) holds (R31 in R35 implies ( R34 * R31 ) in R35))));
end;
theorem
L139: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds ((R35 <> ( {} ) & R35 is  linearly-closed) implies ( 0. R25 ) in R35)))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume that
L140: R35 <> ( {} )
and
L141: R35 is  linearly-closed;
set D17 = the (Element of R35);
reconsider D18 = D17 as (Element of R25) by L140 , TARSKI:def 3;
L142: ( ( 0 ) * D18 ) in R35 by L140 , L141 , L137;
thus L143: thesis by L142 , L29;
end;
theorem
L144: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (R35 is  linearly-closed implies (for R31 being (VECTOR of R25) holds (R31 in R35 implies ( - R31 ) in R35)))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume L145: R35 is  linearly-closed;
let R31 being (VECTOR of R25);
assume L146: R31 in R35;
L147: ( ( - 1 ) * R31 ) in R35 by L146 , L145 , L137;
thus L148: thesis by L147 , L40;
end;
theorem
L149: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (R35 is  linearly-closed implies (for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in R35 & R28 in R35) implies ( R31 - R28 ) in R35))))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume L150: R35 is  linearly-closed;
let R31 being (VECTOR of R25);
let R28 being (VECTOR of R25);
assume that
L151: R31 in R35
and
L152: R28 in R35;
L153: ( - R28 ) in R35 by L150 , L152 , L144;
thus L154: thesis by L153 , L150 , L151 , L137;
end;
theorem
L155: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds ((the carrier of R25) = R35 implies R35 is  linearly-closed)))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume L156: (the carrier of R25) = R35;
thus L157: (for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in R35 & R28 in R35) implies ( R31 + R28 ) in R35))) by L156;
let R34 being  integer number;
let R31 being (VECTOR of R25);
thus L158: thesis by L156;
end;
theorem
L159: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (for R36 being (Subset of R25) holds (for R37 being (Subset of R25) holds ((R35 is  linearly-closed & R36 is  linearly-closed & R37 = { ( R31 + R28 ) where R31 is (VECTOR of R25) , R28 is (VECTOR of R25) : (R31 in R35 & R28 in R36) }) implies R37 is  linearly-closed)))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
let R36 being (Subset of R25);
let R37 being (Subset of R25);
assume that
L160: (R35 is  linearly-closed & R36 is  linearly-closed)
and
L161: R37 = { ( R31 + R28 ) where R31 is (VECTOR of R25) , R28 is (VECTOR of R25) : (R31 in R35 & R28 in R36) };
thus L162: (for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in R37 & R28 in R37) implies ( R31 + R28 ) in R37)))
proof
let R31 being (VECTOR of R25);
let R28 being (VECTOR of R25);
assume that
L163: R31 in R37
and
L164: R28 in R37;
consider R32 being (VECTOR of R25), R33 being (VECTOR of R25) such that L165: R31 = ( R32 + R33 ) and L166: (R32 in R35 & R33 in R36) by L161 , L163;
consider R29 being (VECTOR of R25), R30 being (VECTOR of R25) such that L167: R28 = ( R29 + R30 ) and L168: (R29 in R35 & R30 in R36) by L161 , L164;
L169: ( R31 + R28 ) = ( ( ( R32 + R33 ) + R29 ) + R30 ) by L165 , L167 , RLVECT_1:def 3
.= ( ( ( R32 + R29 ) + R33 ) + R30 ) by RLVECT_1:def 3
.= ( ( R32 + R29 ) + ( R33 + R30 ) ) by RLVECT_1:def 3;
L170: (( R32 + R29 ) in R35 & ( R33 + R30 ) in R36) by L160 , L166 , L168 , L137;
thus L171: thesis by L170 , L161 , L169;
end;

let R34 being  integer number;
let R31 being (VECTOR of R25);
assume L172: R31 in R37;
consider R32 being (VECTOR of R25), R33 being (VECTOR of R25) such that L173: R31 = ( R32 + R33 ) and L174: (R32 in R35 & R33 in R36) by L172 , L161;
L175: ( R34 * R31 ) = ( ( R34 * R32 ) + ( R34 * R33 ) ) by L173 , L9;
L176: (( R34 * R32 ) in R35 & ( R34 * R33 ) in R36) by L160 , L174 , L137;
thus L177: thesis by L176 , L161 , L175;
end;
registration
let R25 being Z_Module;
cluster { ( 0. R25 ) } ->  linearly-closed for (Subset of R25);
coherence
proof
let C18 being (Subset of R25);
assume that
L178: C18 = { ( 0. R25 ) };
thus L179: (for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in C18 & R28 in C18) implies ( R31 + R28 ) in C18)))
proof
let R31 being (VECTOR of R25);
let R28 being (VECTOR of R25);
assume L180: (R31 in C18 & R28 in C18);
L181: (R31 = ( 0. R25 ) & R28 = ( 0. R25 )) by L180 , L178 , TARSKI:def 1;
L182: ( R31 + R28 ) = ( 0. R25 ) by L181 , RLVECT_1:4;
thus L183: thesis by L182 , L178 , TARSKI:def 1;
end;

let R34 being  integer number;
let R31 being (VECTOR of R25);
assume L184: R31 in C18;
L185: R31 = ( 0. R25 ) by L184 , L178 , TARSKI:def 1;
thus L186: thesis by L185 , L184 , L29;
end;
end;
registration
let R25 being Z_Module;
cluster  linearly-closed for (Subset of R25);
existence
proof
take { ( 0. R25 ) };
thus L188: thesis;
end;
end;
registration
let R25 being Z_Module;
let C19 , C20 being  linearly-closed (Subset of R25);
cluster ( C19 /\ C20 ) ->  linearly-closed for (Subset of R25);
coherence
proof
let C21 being (Subset of R25);
assume that
L190: C21 = ( C19 /\ C20 );
thus L191: (for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in C21 & R28 in C21) implies ( R31 + R28 ) in C21)))
proof
let R31 being (VECTOR of R25);
let R28 being (VECTOR of R25);
assume L192: (R31 in C21 & R28 in C21);
L193: (R31 in C20 & R28 in C20) by L192 , L190 , XBOOLE_0:def 4;
L194: ( R31 + R28 ) in C20 by L193 , L137;
L195: (R31 in C19 & R28 in C19) by L192 , L190 , XBOOLE_0:def 4;
L196: ( R31 + R28 ) in C19 by L195 , L137;
thus L197: thesis by L196 , L194 , L190 , XBOOLE_0:def 4;
end;

let R34 being  integer number;
let R31 being (VECTOR of R25);
assume L198: R31 in C21;
L199: R31 in C20 by L198 , L190 , XBOOLE_0:def 4;
L200: ( R34 * R31 ) in C20 by L199 , L137;
L201: R31 in C19 by L198 , L190 , XBOOLE_0:def 4;
L202: ( R34 * R31 ) in C19 by L201 , L137;
thus L203: thesis by L202 , L200 , L190 , XBOOLE_0:def 4;
end;
end;
definition
let R25 being Z_Module;
mode Submodule of R25
 -> Z_Module
means :L205: ((the carrier of it) c= (the carrier of R25) & ( 0. it ) = ( 0. R25 ) & (the addF of it) = ( (the addF of R25) || (the carrier of it) ) & (the Mult of it) = ( (the Mult of R25) | [: ( INT ) , (the carrier of it) :] ));
existence
proof
L206: ((the addF of R25) = ( (the addF of R25) || (the carrier of R25) ) & (the Mult of R25) = ( (the Mult of R25) | [: ( INT ) , (the carrier of R25) :] )) by RELSET_1:19;
thus L207: thesis by L206;
end;
end;
theorem
L209: (for R25 being Z_Module holds (for R38 being set holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ((R38 in R40 & R40 is (Submodule of R41)) implies R38 in R41)))))
proof
let R25 being Z_Module;
let R38 being set;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
assume L210: (R38 in R40 & R40 is (Submodule of R41));
L211: (R38 in (the carrier of R40) & (the carrier of R40) c= (the carrier of R41)) by L210 , L205 , STRUCT_0:def 5;
thus L212: thesis by L211 , STRUCT_0:def 5;
end;
theorem
L213: (for R25 being Z_Module holds (for R38 being set holds (for R39 being (Submodule of R25) holds (R38 in R39 implies R38 in R25))))
proof
let R25 being Z_Module;
let R38 being set;
let R39 being (Submodule of R25);
assume L214: R38 in R39;
L215: R38 in (the carrier of R39) by L214 , STRUCT_0:def 5;
L216: (the carrier of R39) c= (the carrier of R25) by L205;
thus L217: thesis by L216 , L215 , STRUCT_0:def 5;
end;
theorem
L218: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds (for R42 being (VECTOR of R39) holds R42 is (VECTOR of R25))))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
let R42 being (VECTOR of R39);
L219: R42 in R25 by L213 , RLVECT_1:1;
thus L220: thesis by L219 , STRUCT_0:def 5;
end;
theorem
L221: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( 0. R39 ) = ( 0. R25 ))) by L205;
theorem
L222: (for R25 being Z_Module holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ( 0. R40 ) = ( 0. R41 ))))
proof
let R25 being Z_Module;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
thus L223: ( 0. R40 ) = ( 0. R25 ) by L205
.= ( 0. R41 ) by L205;
end;
theorem
L224: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R43 being (VECTOR of R39) holds (for R44 being (VECTOR of R39) holds ((R43 = R31 & R44 = R28) implies ( R43 + R44 ) = ( R31 + R28 ))))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R43 being (VECTOR of R39);
let R44 being (VECTOR of R39);
assume L225: (R31 = R43 & R28 = R44);
L226: ( R43 + R44 ) = ( ( (the addF of R25) || (the carrier of R39) ) . [ R43 , R44 ] ) by L205;
thus L227: thesis by L226 , L225 , FUNCT_1:49;
end;
theorem
L228: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R34 being  integer number holds (for R39 being (Submodule of R25) holds (for R42 being (VECTOR of R39) holds (R42 = R31 implies ( R34 * R42 ) = ( R34 * R31 )))))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R34 being  integer number;
let R39 being (Submodule of R25);
let R42 being (VECTOR of R39);
reconsider D19 = R34 as (Element of ( INT )) by INT_1:def 2;
assume L229: R42 = R31;
L230: ( D19 * R42 ) = ( ( (the Mult of R25) | [: ( INT ) , (the carrier of R39) :] ) . [ D19 , R42 ] ) by L205;
thus L231: thesis by L230 , L229 , FUNCT_1:49;
end;
theorem
L232: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R42 being (VECTOR of R39) holds (R42 = R31 implies ( - R31 ) = ( - R42 ))))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R42 being (VECTOR of R39);
L233: (( - R31 ) = ( ( - 1 ) * R31 ) & ( - R42 ) = ( ( - 1 ) * R42 )) by L40;
assume L234: R42 = R31;
thus L235: thesis by L234 , L233 , L228;
end;
theorem
L236: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R43 being (VECTOR of R39) holds (for R44 being (VECTOR of R39) holds ((R43 = R31 & R44 = R28) implies ( R43 - R44 ) = ( R31 - R28 ))))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R43 being (VECTOR of R39);
let R44 being (VECTOR of R39);
assume that
L237: R43 = R31
and
L238: R44 = R28;
L239: ( - R44 ) = ( - R28 ) by L238 , L232;
thus L240: thesis by L239 , L237 , L224;
end;
L241: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (for R39 being (Submodule of R25) holds ((the carrier of R39) = R35 implies R35 is  linearly-closed))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
let R39 being (Submodule of R25);
set D20 = (the carrier of R39);
reconsider D21 = R39 as Z_Module;
assume L242: (the carrier of R39) = R35;
thus L243: (for R31 being (VECTOR of R25) holds (for R28 being (VECTOR of R25) holds ((R31 in R35 & R28 in R35) implies ( R31 + R28 ) in R35)))
proof
let R31 being (VECTOR of R25);
let R28 being (VECTOR of R25);
assume L244: (R31 in R35 & R28 in R35);
reconsider D22 = R31 , D23 = R28 as (VECTOR of D21) by L244 , L242;
reconsider D24 = ( D22 + D23 ) as (Element of D20);
L245: D24 in R35 by L242;
thus L246: thesis by L245 , L224;
end;

let R34 being  integer number;
let R31 being (VECTOR of R25);
assume L247: R31 in R35;
reconsider D25 = R31 as (VECTOR of D21) by L247 , L242;
reconsider D26 = ( R34 * D25 ) as (Element of D20);
L248: D26 in R35 by L242;
thus L249: thesis by L248 , L228;
end;
theorem
L250: (for R25 being Z_Module holds R25 is (Submodule of R25))
proof
let R25 being Z_Module;
thus L251: ((the carrier of R25) c= (the carrier of R25) & ( 0. R25 ) = ( 0. R25 ));
thus L252: thesis by RELSET_1:19;
end;
theorem
L253: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( 0. R25 ) in R39))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
L254: ( 0. R39 ) in R39 by RLVECT_1:1;
thus L255: thesis by L254 , L205;
end;
theorem
L256: (for R25 being Z_Module holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ( 0. R40 ) in R41)))
proof
let R25 being Z_Module;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
L257: ( 0. R40 ) = ( 0. R25 ) by L205;
thus L258: thesis by L257 , L253;
end;
theorem
L259: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( 0. R39 ) in R25)) by L213 , RLVECT_1:1;
theorem
L260: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds ((R28 in R39 & R31 in R39) implies ( R28 + R31 ) in R39)))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
reconsider D27 = (the carrier of R39) as (Subset of R25) by L205;
assume L261: (R28 in R39 & R31 in R39);
L262: (R28 in (the carrier of R39) & R31 in (the carrier of R39)) by L261 , STRUCT_0:def 5;
L263: D27 is  linearly-closed by L241;
L264: ( R28 + R31 ) in (the carrier of R39) by L263 , L262 , L137;
thus L265: thesis by L264 , STRUCT_0:def 5;
end;
theorem
L266: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R34 being  integer number holds (for R39 being (Submodule of R25) holds (R31 in R39 implies ( R34 * R31 ) in R39)))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R34 being  integer number;
let R39 being (Submodule of R25);
reconsider D28 = (the carrier of R39) as (Subset of R25) by L205;
assume L267: R31 in R39;
L268: R31 in (the carrier of R39) by L267 , STRUCT_0:def 5;
L269: D28 is  linearly-closed by L241;
L270: ( R34 * R31 ) in (the carrier of R39) by L269 , L268 , L137;
thus L271: thesis by L270 , STRUCT_0:def 5;
end;
theorem
L272: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R31 in R39 implies ( - R31 ) in R39))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
assume L273: R31 in R39;
L274: ( ( - 1 ) * R31 ) in R39 by L273 , L266;
thus L275: thesis by L274 , L40;
end;
theorem
L276: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds ((R28 in R39 & R31 in R39) implies ( R28 - R31 ) in R39)))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
assume that
L277: R28 in R39
and
L278: R31 in R39;
L279: ( - R31 ) in R39 by L278 , L272;
thus L280: thesis by L279 , L277 , L260;
end;
theorem
L281: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (for R45 being non  empty set holds (for R46 being (Element of R45) holds (for R47 being (BinOp of R45) holds (for R48 being (Function of [: ( INT ) , R45 :] , R45) holds ((R35 = R45 & R46 = ( 0. R25 ) & R47 = ( (the addF of R25) || R35 ) & R48 = ( (the Mult of R25) | [: ( INT ) , R35 :] )) implies Z_ModuleStruct (# R45 , R46 , R47 , R48 #) is (Submodule of R25))))))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
let R45 being non  empty set;
let R46 being (Element of R45);
let R47 being (BinOp of R45);
let R48 being (Function of [: ( INT ) , R45 :] , R45);
assume that
L282: R35 = R45
and
L283: R46 = ( 0. R25 )
and
L284: R47 = ( (the addF of R25) || R35 )
and
L285: R48 = ( (the Mult of R25) | [: ( INT ) , R35 :] );
set D29 = Z_ModuleStruct (# R45 , R46 , R47 , R48 #);
L286: (for R34 being  integer number holds (for B23 being (VECTOR of D29) holds ( R34 * B23 ) = ( (the Mult of R25) . (R34 , B23) )))
proof
let R34 being  integer number;
let C22 being (VECTOR of D29);
reconsider D30 = R34 as (Element of ( INT )) by INT_1:def 2;
thus L287: ( R34 * C22 ) = ( (the Mult of R25) . [ D30 , C22 ] ) by L282 , L285 , FUNCT_1:49
.= ( (the Mult of R25) . (R34 , C22) );
end;
L288: (for B24 , B25 being (VECTOR of D29) holds ( B24 + B25 ) = ( (the addF of R25) . (B24 , B25) ))
proof
let C23 , C24 being (VECTOR of D29);
thus L289: ( C23 + C24 ) = ( (the addF of R25) . [ C23 , C24 ] ) by L282 , L284 , FUNCT_1:49
.= ( (the addF of R25) . (C23 , C24) );
end;
L290: D29 is  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital
proof
set D31 = (the Mult of R25);
set D32 = (the addF of R25);
thus L291: D29 is  Abelian
proof
let C25 , C26 being (VECTOR of D29);
reconsider D33 = C25 , D34 = C26 as (VECTOR of R25) by L282 , TARSKI:def 3;
thus L292: ( C25 + C26 ) = ( D33 + D34 ) by L288
.= ( D34 + D33 )
.= ( C26 + C25 ) by L288;
end;

thus L293: D29 is  add-associative
proof
let C27 , C28 , C29 being (VECTOR of D29);
reconsider D35 = C27 , D36 = C28 , D37 = C29 as (VECTOR of R25) by L282 , TARSKI:def 3;
thus L294: ( ( C27 + C28 ) + C29 ) = ( D32 . (( C27 + C28 ) , D37) ) by L288
.= ( ( D35 + D36 ) + D37 ) by L288
.= ( D35 + ( D36 + D37 ) ) by RLVECT_1:def 3
.= ( D32 . (D35 , ( C28 + C29 )) ) by L288
.= ( C27 + ( C28 + C29 ) ) by L288;
end;

thus L295: D29 is  right_zeroed
proof
let C30 being (VECTOR of D29);
reconsider D38 = C30 as (VECTOR of R25) by L282 , TARSKI:def 3;
thus L296: ( C30 + ( 0. D29 ) ) = ( D38 + ( 0. R25 ) ) by L283 , L288
.= C30 by RLVECT_1:4;
end;

thus L297: D29 is  right_complementable
proof
let C31 being (VECTOR of D29);
reconsider D39 = C31 as (VECTOR of R25) by L282 , TARSKI:def 3;
consider R31 being (VECTOR of R25) such that L298: ( D39 + R31 ) = ( 0. R25 ) by ALGSTR_0:def 11;
L299: R31 = ( - D39 ) by L298 , RLVECT_1:def 10
.= ( ( - 1 ) * D39 ) by L40
.= ( ( - 1 ) * C31 ) by L286;
reconsider D40 = R31 as (VECTOR of D29) by L299;
take D40;
thus L300: thesis by L283 , L288 , L298;
end;

thus L301: (for B26 being  integer number holds (for B27 , B28 being (VECTOR of D29) holds ( B26 * ( B27 + B28 ) ) = ( ( B26 * B27 ) + ( B26 * B28 ) )))
proof
let C32 being  integer number;
let C33 , C34 being (VECTOR of D29);
reconsider D41 = C33 , D42 = C34 as (VECTOR of R25) by L282 , TARSKI:def 3;
reconsider D43 = C32 as Integer;
L302: ( D43 * ( C33 + C34 ) ) = ( D31 . (D43 , ( C33 + C34 )) ) by L286
.= ( D43 * ( D41 + D42 ) ) by L288
.= ( ( D43 * D41 ) + ( D43 * D42 ) ) by L9
.= ( D32 . (( D31 . (D43 , D41) ) , ( D43 * C34 )) ) by L286
.= ( D32 . (( D43 * C33 ) , ( D43 * C34 )) ) by L286
.= ( ( D43 * C33 ) + ( D43 * C34 ) ) by L288;
thus L303: thesis by L302;
end;

thus L304: (for B29 , B30 being  integer number holds (for B31 being (VECTOR of D29) holds ( ( B29 + B30 ) * B31 ) = ( ( B29 * B31 ) + ( B30 * B31 ) )))
proof
let C35 , C36 being  integer number;
let C37 being (VECTOR of D29);
reconsider D44 = C37 as (VECTOR of R25) by L282 , TARSKI:def 3;
reconsider D45 = C35 , D46 = C36 as Integer;
L305: ( ( D45 + D46 ) * C37 ) = ( ( D45 + D46 ) * D44 ) by L286
.= ( ( D45 * D44 ) + ( D46 * D44 ) ) by L10
.= ( D32 . (( D31 . (D45 , D44) ) , ( D46 * C37 )) ) by L286
.= ( D32 . (( D45 * C37 ) , ( D46 * C37 )) ) by L286
.= ( ( D45 * C37 ) + ( D46 * C37 ) ) by L288;
thus L306: thesis by L305;
end;

thus L307: (for B32 , B33 being  integer number holds (for B34 being (VECTOR of D29) holds ( ( B32 * B33 ) * B34 ) = ( B32 * ( B33 * B34 ) )))
proof
let C38 , C39 being  integer number;
let C40 being (VECTOR of D29);
reconsider D47 = C40 as (VECTOR of R25) by L282 , TARSKI:def 3;
reconsider D48 = C38 , D49 = C39 as Integer;
L308: ( ( D48 * D49 ) * C40 ) = ( ( D48 * D49 ) * D47 ) by L286
.= ( D48 * ( D49 * D47 ) ) by L11
.= ( D31 . (D48 , ( D49 * C40 )) ) by L286
.= ( D48 * ( D49 * C40 ) ) by L286;
thus L309: thesis by L308;
end;

let C41 being (VECTOR of D29);
reconsider D50 = C41 as (VECTOR of R25) by L282 , TARSKI:def 3;
thus L310: ( 1 * C41 ) = ( 1 * D50 ) by L286
.= C41 by L12;
end;
L311: ( 0. D29 ) = ( 0. R25 ) by L283;
thus L312: thesis by L311 , L282 , L284 , L285 , L290 , L205;
end;
theorem
L313: (for B35 , B36 being  strict Z_Module holds ((B35 is (Submodule of B36) & B36 is (Submodule of B35)) implies B35 = B36))
proof
let C42 , C43 being  strict Z_Module;
assume that
L314: C42 is (Submodule of C43)
and
L315: C43 is (Submodule of C42);
set D51 = (the carrier of C43);
set D52 = (the carrier of C42);
L316: (D52 c= D51 & D51 c= D52) by L314 , L315 , L205;
L317: D52 = D51 by L316 , XBOOLE_0:def 10;
set D53 = (the addF of C43);
set D54 = (the addF of C42);
L318: (D54 = ( D53 || D52 ) & D53 = ( D54 || D51 )) by L314 , L315 , L205;
L319: D54 = D53 by L318 , L317 , RELAT_1:72;
set D55 = (the Mult of C43);
set D56 = (the Mult of C42);
L320: D55 = ( D56 | [: ( INT ) , D51 :] ) by L315 , L205;
L321: (( 0. C42 ) = ( 0. C43 ) & D56 = ( D55 | [: ( INT ) , D52 :] )) by L314 , L205;
thus L322: thesis by L321 , L317 , L319 , L320 , RELAT_1:72;
end;
theorem
L323: (for R25 being Z_Module holds (for R26 being Z_Module holds (for R27 being Z_Module holds ((R25 is (Submodule of R26) & R26 is (Submodule of R27)) implies R25 is (Submodule of R27)))))
proof
let R25 being Z_Module;
let R26 being Z_Module;
let R27 being Z_Module;
assume that
L324: R25 is (Submodule of R26)
and
L325: R26 is (Submodule of R27);
L326: ((the carrier of R25) c= (the carrier of R26) & (the carrier of R26) c= (the carrier of R27)) by L324 , L325 , L205;
thus L327: (the carrier of R25) c= (the carrier of R27) by L326 , XBOOLE_1:1;
L328: ( 0. R25 ) = ( 0. R26 ) by L324 , L205;
thus L329: ( 0. R25 ) = ( 0. R27 ) by L328 , L325 , L205;
thus L330: (the addF of R25) = ( (the addF of R27) || (the carrier of R25) )
proof
set D57 = (the addF of R27);
set D58 = (the carrier of R26);
set D59 = (the addF of R26);
set D60 = (the carrier of R25);
set D61 = (the addF of R25);
L331: D60 c= D58 by L324 , L205;
L332: [: D60 , D60 :] c= [: D58 , D58 :] by L331 , ZFMISC_1:96;
L333: D61 = ( D59 || D60 ) by L324 , L205;
L334: D61 = ( ( D57 || D58 ) || D60 ) by L333 , L325 , L205;
thus L335: thesis by L334 , L332 , FUNCT_1:51;
end;

set D62 = (the Mult of R27);
set D63 = (the Mult of R26);
set D64 = (the Mult of R25);
set D65 = (the carrier of R26);
set D66 = (the carrier of R25);
L336: D66 c= D65 by L324 , L205;
L337: [: ( INT ) , D66 :] c= [: ( INT ) , D65 :] by L336 , ZFMISC_1:95;
L338: D64 = ( D63 | [: ( INT ) , D66 :] ) by L324 , L205;
L339: D64 = ( ( D62 | [: ( INT ) , D65 :] ) | [: ( INT ) , D66 :] ) by L338 , L325 , L205;
thus L340: thesis by L339 , L337 , FUNCT_1:51;
end;
theorem
L341: (for R25 being Z_Module holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ((the carrier of R40) c= (the carrier of R41) implies R40 is (Submodule of R41)))))
proof
let R25 being Z_Module;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
set D67 = (the carrier of R40);
set D68 = (the carrier of R41);
set D69 = (the addF of R25);
set D70 = (the Mult of R25);
assume L342: (the carrier of R40) c= (the carrier of R41);
L343: [: D67 , D67 :] c= [: D68 , D68 :] by L342 , ZFMISC_1:96;
L344: ( 0. R40 ) = ( 0. R25 ) by L205;
thus L345: ((the carrier of R40) c= (the carrier of R41) & ( 0. R40 ) = ( 0. R41 )) by L344 , L342 , L205;
L346: ((the addF of R40) = ( D69 || D67 ) & (the addF of R41) = ( D69 || D68 )) by L205;
thus L347: (the addF of R40) = ( (the addF of R41) || (the carrier of R40) ) by L346 , L343 , FUNCT_1:51;
L348: [: ( INT ) , D67 :] c= [: ( INT ) , D68 :] by L342 , ZFMISC_1:95;
L349: ((the Mult of R40) = ( D70 | [: ( INT ) , D67 :] ) & (the Mult of R41) = ( D70 | [: ( INT ) , D68 :] )) by L205;
thus L350: thesis by L349 , L348 , FUNCT_1:51;
end;
theorem
L351: (for R25 being Z_Module holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ((for R31 being (VECTOR of R25) holds (R31 in R40 implies R31 in R41)) implies R40 is (Submodule of R41)))))
proof
let R25 being Z_Module;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
assume L352: (for R31 being (VECTOR of R25) holds (R31 in R40 implies R31 in R41));
L353: (the carrier of R40) c= (the carrier of R41)
proof
let C44 being set;
assume L354: C44 in (the carrier of R40);
L355: (the carrier of R40) c= (the carrier of R25) by L205;
reconsider D71 = C44 as (VECTOR of R25) by L355 , L354;
L356: D71 in R40 by L354 , STRUCT_0:def 5;
L357: D71 in R41 by L356 , L352;
thus L358: thesis by L357 , STRUCT_0:def 5;
end;
thus L359: thesis by L353 , L341;
end;
registration
let R25 being Z_Module;
cluster  strict for (Submodule of R25);
existence
proof
L360: ((the carrier of R25) is (Subset of R25) iff (the carrier of R25) c= (the carrier of R25));
reconsider D72 = (the carrier of R25) as (Subset of R25) by L360;
L361: ((the addF of R25) = ( (the addF of R25) || D72 ) & (the Mult of R25) = ( (the Mult of R25) | [: ( INT ) , D72 :] )) by RELSET_1:19;
L362: Z_ModuleStruct (# (the carrier of R25) , ( 0. R25 ) , (the addF of R25) , (the Mult of R25) #) is (Submodule of R25) by L361 , L281;
thus L363: thesis by L362;
end;
end;
theorem
L365: (for R25 being Z_Module holds (for B37 , B38 being  strict (Submodule of R25) holds ((the carrier of B37) = (the carrier of B38) implies B37 = B38)))
proof
let R25 being Z_Module;
let C45 , C46 being  strict (Submodule of R25);
assume L366: (the carrier of C45) = (the carrier of C46);
L367: (C45 is (Submodule of C46) & C46 is (Submodule of C45)) by L366 , L341;
thus L368: thesis by L367 , L313;
end;
theorem
L369: (for R25 being Z_Module holds (for B39 , B40 being  strict (Submodule of R25) holds ((for R31 being (VECTOR of R25) holds (R31 in B39 iff R31 in B40)) implies B39 = B40)))
proof
let R25 being Z_Module;
let C47 , C48 being  strict (Submodule of R25);
assume L370: (for R31 being (VECTOR of R25) holds (R31 in C47 iff R31 in C48));
L371: (for R38 being set holds (R38 in (the carrier of C47) iff R38 in (the carrier of C48)))
proof
let R38 being set;
thus L372: (R38 in (the carrier of C47) implies R38 in (the carrier of C48))
proof
assume L373: R38 in (the carrier of C47);
L374: (the carrier of C47) c= (the carrier of R25) by L205;
reconsider D73 = R38 as (VECTOR of R25) by L374 , L373;
L375: D73 in C47 by L373 , STRUCT_0:def 5;
L376: D73 in C48 by L375 , L370;
thus L377: thesis by L376 , STRUCT_0:def 5;
end;

assume L378: R38 in (the carrier of C48);
L379: (the carrier of C48) c= (the carrier of R25) by L205;
reconsider D74 = R38 as (VECTOR of R25) by L379 , L378;
L380: D74 in C48 by L378 , STRUCT_0:def 5;
L381: D74 in C47 by L380 , L370;
thus L382: thesis by L381 , STRUCT_0:def 5;
end;
L383: (the carrier of C47) = (the carrier of C48) by L371 , TARSKI:1;
thus L384: thesis by L383 , L365;
end;
theorem
L385: (for B41 being  strict Z_Module holds (for B42 being  strict (Submodule of B41) holds ((the carrier of B42) = (the carrier of B41) implies B42 = B41)))
proof
let C49 being  strict Z_Module;
let C50 being  strict (Submodule of C49);
assume L386: (the carrier of C50) = (the carrier of C49);
L387: C49 is (Submodule of C49) by L250;
thus L388: thesis by L387 , L386 , L365;
end;
theorem
L389: (for B43 being  strict Z_Module holds (for B44 being  strict (Submodule of B43) holds ((for B45 being (VECTOR of B43) holds (B45 in B44 iff B45 in B43)) implies B44 = B43)))
proof
let C51 being  strict Z_Module;
let C52 being  strict (Submodule of C51);
assume L390: (for B46 being (VECTOR of C51) holds (B46 in C52 iff B46 in C51));
L391: C51 is (Submodule of C51) by L250;
thus L392: thesis by L391 , L390 , L369;
end;
theorem
L393: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (for R39 being (Submodule of R25) holds ((the carrier of R39) = R35 implies R35 is  linearly-closed)))) by L241;
theorem
L394: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds ((R35 <> ( {} ) & R35 is  linearly-closed) implies (ex B47 being  strict (Submodule of R25) st R35 = (the carrier of B47)))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume that
L395: R35 <> ( {} )
and
L396: R35 is  linearly-closed;
reconsider D75 = R35 as non  empty set by L395;
set D76 = ( (the Mult of R25) | [: ( INT ) , R35 :] );
set D77 = (the carrier of R25);
L397: ( dom (the Mult of R25) ) = [: ( INT ) , D77 :] by FUNCT_2:def 1;
L398: ( dom D76 ) = ( [: ( INT ) , D77 :] /\ [: ( INT ) , R35 :] ) by L397 , RELAT_1:61;
L399: [: ( INT ) , R35 :] c= [: ( INT ) , D77 :] by ZFMISC_1:95;
L400: ( dom D76 ) = [: ( INT ) , D75 :] by L399 , L398 , XBOOLE_1:28;
L401:
now
let C53 being set;
thus L402: (C53 in D75 implies (ex B48 being set st (B48 in ( dom D76 ) & C53 = ( D76 . B48 ))))
proof
assume L403: C53 in D75;
reconsider D78 = C53 as (Element of D77) by L403;
reconsider D79 = 1 as (Element of ( INT )) by INT_1:def 2;
L404: [ D79 , C53 ] in [: ( INT ) , D75 :] by L403 , ZFMISC_1:87;
L405: ( D76 . [ 1 , C53 ] ) = ( 1 * D78 ) by L404 , FUNCT_1:49
.= C53 by L12;
thus L406: thesis by L405 , L400 , L404;
end;

given C54 being set such that
L407: C54 in ( dom D76 )
and
L408: C53 = ( D76 . C54 );

consider C55 , C56 being set such that L409: C55 in ( INT ) and L410: C56 in D75 and L411: C54 = [ C55 , C56 ] by L400 , L407 , ZFMISC_1:def 2;
reconsider D80 = C55 as Integer by L409;
reconsider D81 = C56 as (Element of D77) by L410;
L412: [ C55 , C56 ] in [: ( INT ) , R35 :] by L409 , L410 , ZFMISC_1:87;
L413: C53 = ( D80 * D81 ) by L412 , L408 , L411 , FUNCT_1:49;
thus L414: C53 in D75 by L413 , L396 , L410 , L137;
end;
L415: D75 = ( rng D76 ) by L401 , FUNCT_1:def 3;
reconsider D82 = D76 as (Function of [: ( INT ) , D75 :] , D75) by L415 , L400 , FUNCT_2:def 1 , RELSET_1:4;
set D83 = ( (the addF of R25) || R35 );
reconsider D84 = ( 0. R25 ) as (Element of D75) by L396 , L139;
L416: ( dom (the addF of R25) ) = [: D77 , D77 :] by FUNCT_2:def 1;
L417: ( dom D83 ) = ( [: D77 , D77 :] /\ [: R35 , R35 :] ) by L416 , RELAT_1:61;
L418: ( dom D83 ) = [: D75 , D75 :] by L417 , XBOOLE_1:28;
L419:
now
let C57 being set;
thus L420: (C57 in D75 implies (ex B49 being set st (B49 in ( dom D83 ) & C57 = ( D83 . B49 ))))
proof
assume L421: C57 in D75;
reconsider D85 = C57 , D86 = D84 as (Element of D77) by L421;
L422: [ D84 , C57 ] in [: D75 , D75 :] by L421 , ZFMISC_1:87;
L423: ( D83 . [ D84 , C57 ] ) = ( D86 + D85 ) by L422 , FUNCT_1:49
.= C57 by RLVECT_1:4;
thus L424: thesis by L423 , L418 , L422;
end;

given C58 being set such that
L425: C58 in ( dom D83 )
and
L426: C57 = ( D83 . C58 );

consider C59 , C60 being set such that L427: (C59 in D75 & C60 in D75) and L428: C58 = [ C59 , C60 ] by L418 , L425 , ZFMISC_1:def 2;
reconsider D87 = C59 , D88 = C60 as (Element of D77) by L427;
L429: [ C59 , C60 ] in [: R35 , R35 :] by L427 , ZFMISC_1:87;
L430: C57 = ( D87 + D88 ) by L429 , L426 , L428 , FUNCT_1:49;
thus L431: C57 in D75 by L430 , L396 , L427 , L137;
end;
L432: D75 = ( rng D83 ) by L419 , FUNCT_1:def 3;
reconsider D89 = D83 as (Function of [: D75 , D75 :] , D75) by L432 , L418 , FUNCT_2:def 1 , RELSET_1:4;
set D90 = Z_ModuleStruct (# D75 , D84 , D89 , D82 #);
L433: D90 is (Submodule of R25) by L281;
thus L434: thesis by L433;
end;
definition
let R25 being Z_Module;
func (0). R25 ->  strict (Submodule of R25) means
:L435: (the carrier of it) = { ( 0. R25 ) };
correctness by L365 , L394;
end;
definition
let R25 being Z_Module;
func (Omega). R25 ->  strict (Submodule of R25) equals
( the Z_ModuleStruct of R25 );
coherence
proof
set D91 = ( the Z_ModuleStruct of R25 );
L437: (for B50 , B51 , B52 being (VECTOR of D91) holds ( ( B50 + B51 ) + B52 ) = ( B50 + ( B51 + B52 ) ))
proof
let C61 , C62 , C63 being (VECTOR of D91);
reconsider D92 = C61 , D93 = C62 , D94 = C63 as (VECTOR of R25);
thus L438: ( ( C61 + C62 ) + C63 ) = ( ( D92 + D93 ) + D94 )
.= ( D92 + ( D93 + D94 ) ) by RLVECT_1:def 3
.= ( C61 + ( C62 + C63 ) );
end;
L439: (for B53 being (VECTOR of D91) holds ( B53 + ( 0. D91 ) ) = B53)
proof
let C64 being (VECTOR of D91);
reconsider D95 = C64 as (VECTOR of R25);
thus L440: ( C64 + ( 0. D91 ) ) = ( D95 + ( 0. R25 ) )
.= C64 by RLVECT_1:4;
end;
L441: D91 is  right_complementable
proof
let C65 being (VECTOR of D91);
reconsider D96 = C65 as (VECTOR of R25);
consider C66 being (VECTOR of R25) such that L442: ( D96 + C66 ) = ( 0. R25 ) by ALGSTR_0:def 11;
reconsider D97 = C66 as (VECTOR of D91);
take D97;
thus L443: thesis by L442;
end;
L444: (for B54 being  integer number holds (for B55 , B56 being (VECTOR of D91) holds ( B54 * ( B55 + B56 ) ) = ( ( B54 * B55 ) + ( B54 * B56 ) )))
proof
let C67 being  integer number;
let C68 , C69 being (VECTOR of D91);
reconsider D98 = C68 , D99 = C69 as (VECTOR of R25);
thus L445: ( C67 * ( C68 + C69 ) ) = ( C67 * ( D98 + D99 ) )
.= ( ( C67 * D98 ) + ( C67 * D99 ) ) by L9
.= ( ( C67 * C68 ) + ( C67 * C69 ) );
end;
L446: (for B57 , B58 being  integer number holds (for B59 being (VECTOR of D91) holds ( ( B57 * B58 ) * B59 ) = ( B57 * ( B58 * B59 ) )))
proof
let C70 , C71 being  integer number;
let C72 being (VECTOR of D91);
reconsider D100 = C72 as (VECTOR of R25);
thus L447: ( ( C70 * C71 ) * C72 ) = ( ( C70 * C71 ) * D100 )
.= ( C70 * ( C71 * D100 ) ) by L11
.= ( C70 * ( C71 * C72 ) );
end;
L448: (for B60 , B61 being  integer number holds (for B62 being (VECTOR of D91) holds ( ( B60 + B61 ) * B62 ) = ( ( B60 * B62 ) + ( B61 * B62 ) )))
proof
let C73 , C74 being  integer number;
let C75 being (VECTOR of D91);
reconsider D101 = C75 as (VECTOR of R25);
thus L449: ( ( C73 + C74 ) * C75 ) = ( ( C73 + C74 ) * D101 )
.= ( ( C73 * D101 ) + ( C74 * D101 ) ) by L10
.= ( ( C73 * C75 ) + ( C74 * C75 ) );
end;
L450: (for R34 being  integer number holds (for B63 , B64 being (VECTOR of D91) holds (for B65 , B66 being (VECTOR of R25) holds ((B63 = B65 & B64 = B66) implies (( B63 + B64 ) = ( B65 + B66 ) & ( R34 * B63 ) = ( R34 * B65 ))))));
L451: (for B67 , B68 being (VECTOR of D91) holds ( B67 + B68 ) = ( B68 + B67 ))
proof
let C76 , C77 being (VECTOR of D91);
reconsider D102 = C76 , D103 = C77 as (VECTOR of R25);
thus L452: ( C76 + C77 ) = ( D103 + D102 ) by L450
.= ( C77 + C76 );
end;
L453: (for B69 being (VECTOR of D91) holds ( 1 * B69 ) = B69)
proof
let C78 being (VECTOR of D91);
reconsider D104 = C78 as (VECTOR of R25);
thus L454: ( 1 * C78 ) = ( 1 * D104 )
.= C78 by L12;
end;
reconsider D105 = D91 as Z_Module by L453 , L451 , L437 , L439 , L441 , L444 , L448 , L446 , L9 , L10 , L11 , L12 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
L455: (the Mult of D105) = ( (the Mult of R25) | [: ( INT ) , (the carrier of D105) :] ) by RELSET_1:19;
L456: (( 0. D105 ) = ( 0. R25 ) & (the addF of D105) = ( (the addF of R25) || (the carrier of D105) )) by RELSET_1:19;
thus L457: thesis by L456 , L455 , L205;
end;
end;
theorem
L459: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( (0). R39 ) = ( (0). R25 )))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
L460: ((the carrier of ( (0). R39 )) = { ( 0. R39 ) } & (the carrier of ( (0). R25 )) = { ( 0. R25 ) }) by L435;
L461: (the carrier of ( (0). R39 )) = (the carrier of ( (0). R25 )) by L460 , L205;
L462: ( (0). R39 ) is (Submodule of R25) by L323;
thus L463: thesis by L462 , L461 , L365;
end;
theorem
L464: (for R25 being Z_Module holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ( (0). R40 ) = ( (0). R41 ))))
proof
let R25 being Z_Module;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
L465: ( (0). R40 ) = ( (0). R25 ) by L459;
thus L466: thesis by L465 , L459;
end;
theorem
L467: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( (0). R39 ) is (Submodule of R25))) by L323;
theorem
L468: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( (0). R25 ) is (Submodule of R39)))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
L469: (the carrier of ( (0). R25 )) = { ( 0. R25 ) } by L435
.= { ( 0. R39 ) } by L205;
thus L470: thesis by L469 , L341;
end;
theorem
L471: (for R25 being Z_Module holds (for R40 being (Submodule of R25) holds (for R41 being (Submodule of R25) holds ( (0). R40 ) is (Submodule of R41))))
proof
let R25 being Z_Module;
let R40 being (Submodule of R25);
let R41 being (Submodule of R25);
L472: ( (0). R40 ) = ( (0). R41 ) by L464;
thus L473: thesis by L472;
end;
theorem
L474: (for B70 being  strict Z_Module holds B70 is (Submodule of ( (Omega). B70 )));
definition
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
func R31 + R39 -> (Subset of R25) equals
{ ( R31 + R28 ) where R28 is (VECTOR of R25) : R28 in R39 };
coherence
proof
set D106 = { ( R31 + R28 ) where R28 is (VECTOR of R25) : R28 in R39 };
defpred S2[ set ] means (ex R28 being (VECTOR of R25) st ($1 = ( R31 + R28 ) & R28 in R39));
consider C79 being set such that L475: (for B71 being set holds (B71 in C79 iff (B71 in (the carrier of R25) & S2[ B71 ]))) from XBOOLE_0:sch 1;
L476: C79 c= (the carrier of R25)
proof
let C80 being set;
assume L477: C80 in C79;
thus L478: thesis by L477 , L475;
end;
reconsider D107 = C79 as (Subset of R25) by L476;
L479: D106 c= D107
proof
let C81 being set;
assume L480: C81 in D106;
L481: (ex R28 being (VECTOR of R25) st (C81 = ( R31 + R28 ) & R28 in R39)) by L480;
thus L482: thesis by L481 , L475;
end;
L483: D107 c= D106
proof
let C82 being set;
assume L484: C82 in D107;
L485: (ex R28 being (VECTOR of R25) st (C82 = ( R31 + R28 ) & R28 in R39)) by L484 , L475;
thus L486: thesis by L485;
end;
thus L487: thesis by L483 , L479 , XBOOLE_0:def 10;
end;
end;
L489: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( ( 0. R25 ) + R39 ) = (the carrier of R39)))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
set D108 = { ( ( 0. R25 ) + R28 ) where R28 is (VECTOR of R25) : R28 in R39 };
L490: (the carrier of R39) c= D108
proof
let C83 being set;
assume L491: C83 in (the carrier of R39);
L492: C83 in R39 by L491 , STRUCT_0:def 5;
L493: C83 in R25 by L492 , L213;
reconsider D109 = C83 as (Element of R25) by L493 , STRUCT_0:def 5;
L494: ( ( 0. R25 ) + D109 ) = C83 by RLVECT_1:4;
thus L495: thesis by L494 , L492;
end;
L496: D108 c= (the carrier of R39)
proof
let C84 being set;
assume L497: C84 in D108;
consider R28 being (VECTOR of R25) such that L498: C84 = ( ( 0. R25 ) + R28 ) and L499: R28 in R39 by L497;
L500: C84 = R28 by L498 , RLVECT_1:4;
thus L501: thesis by L500 , L499 , STRUCT_0:def 5;
end;
thus L502: thesis by L496 , L490 , XBOOLE_0:def 10;
end;
definition
let R25 being Z_Module;
let R39 being (Submodule of R25);
mode Coset of R39
 -> (Subset of R25)
means :L503: (ex R31 being (VECTOR of R25) st it = ( R31 + R39 ));
existence
proof
reconsider D110 = (the carrier of R39) as (Subset of R25) by L205;
take D110;
take ( 0. R25 );
thus L504: thesis by L489;
end;
end;
theorem
L506: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (( 0. R25 ) in ( R31 + R39 ) iff R31 in R39))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L507: (( 0. R25 ) in ( R31 + R39 ) implies R31 in R39)
proof
assume L508: ( 0. R25 ) in ( R31 + R39 );
consider R28 being (VECTOR of R25) such that L509: ( 0. R25 ) = ( R31 + R28 ) and L510: R28 in R39 by L508;
L511: R31 = ( - R28 ) by L509 , RLVECT_1:def 10;
thus L512: thesis by L511 , L510 , L272;
end;

assume L513: R31 in R39;
L514: ( - R31 ) in R39 by L513 , L272;
L515: ( 0. R25 ) = ( R31 - R31 ) by RLVECT_1:15
.= ( R31 + ( - R31 ) );
thus L516: thesis by L515 , L514;
end;
theorem
L517: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds R31 in ( R31 + R39 ))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
L518: (( R31 + ( 0. R25 ) ) = R31 & ( 0. R25 ) in R39) by L253 , RLVECT_1:4;
thus L519: thesis by L518;
end;
theorem
L520: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds ( ( 0. R25 ) + R39 ) = (the carrier of R39))) by L489;
theorem
L521: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds ( R31 + ( (0). R25 ) ) = { R31 }))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
thus L522: ( R31 + ( (0). R25 ) ) c= { R31 }
proof
let C85 being set;
assume L523: C85 in ( R31 + ( (0). R25 ) );
consider R28 being (VECTOR of R25) such that L524: C85 = ( R31 + R28 ) and L525: R28 in ( (0). R25 ) by L523;
L526: (the carrier of ( (0). R25 )) = { ( 0. R25 ) } by L435;
L527: R28 in (the carrier of ( (0). R25 )) by L525 , STRUCT_0:def 5;
L528: R28 = ( 0. R25 ) by L527 , L526 , TARSKI:def 1;
L529: C85 = R31 by L528 , L524 , RLVECT_1:4;
thus L530: thesis by L529 , TARSKI:def 1;
end;

let C86 being set;
assume L531: C86 in { R31 };
L532: C86 = R31 by L531 , TARSKI:def 1;
L533: (( 0. R25 ) in ( (0). R25 ) & R31 = ( R31 + ( 0. R25 ) )) by L253 , RLVECT_1:4;
thus L534: thesis by L533 , L532;
end;
L535: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R31 in R39 iff ( R31 + R39 ) = (the carrier of R39)))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
L536: (( 0. R25 ) in R39 & ( R31 + ( 0. R25 ) ) = R31) by L253 , RLVECT_1:4;
L537: R31 in { ( R31 + R28 ) where R28 is (VECTOR of R25) : R28 in R39 } by L536;
thus L538: (R31 in R39 implies ( R31 + R39 ) = (the carrier of R39))
proof
assume L539: R31 in R39;
thus L540: ( R31 + R39 ) c= (the carrier of R39)
proof
let C87 being set;
assume L541: C87 in ( R31 + R39 );
consider R28 being (VECTOR of R25) such that L542: C87 = ( R31 + R28 ) and L543: R28 in R39 by L541;
L544: ( R31 + R28 ) in R39 by L539 , L543 , L260;
thus L545: thesis by L544 , L542 , STRUCT_0:def 5;
end;

let C88 being set;
assume L546: C88 in (the carrier of R39);
reconsider D111 = C88 , D112 = R31 as (Element of R39) by L546 , L539 , STRUCT_0:def 5;
reconsider D113 = D111 , D114 = D112 as (VECTOR of R25) by L218;
L547: ( D112 + ( D111 - D112 ) ) = ( ( D111 + D112 ) - D112 ) by RLVECT_1:def 3
.= ( D111 + ( D112 - D112 ) ) by RLVECT_1:def 3
.= ( D111 + ( 0. R39 ) ) by RLVECT_1:15
.= C88 by RLVECT_1:4;
L548: ( D111 - D112 ) in R39 by STRUCT_0:def 5;
L549: ( D113 - D114 ) in R39 by L548 , L236;
L550: ( D111 - D112 ) = ( D113 - D114 ) by L236;
L551: ( D114 + ( D113 - D114 ) ) = C88 by L550 , L547 , L224;
thus L552: thesis by L551 , L549;
end;

thus L553: thesis by L537 , STRUCT_0:def 5;
end;
theorem
L554: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds ( R31 + ( (Omega). R25 ) ) = (the carrier of R25)))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
L555: R31 in ( (Omega). R25 ) by STRUCT_0:def 5;
thus L556: thesis by L555 , L535;
end;
theorem
L557: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (( 0. R25 ) in ( R31 + R39 ) iff ( R31 + R39 ) = (the carrier of R39)))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
L558: (( 0. R25 ) in ( R31 + R39 ) iff R31 in R39) by L506;
thus L559: thesis by L558 , L535;
end;
theorem
L560: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R31 in R39 iff ( R31 + R39 ) = (the carrier of R39))))) by L535;
theorem
L561: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R34 being  integer number holds (for R39 being (Submodule of R25) holds (R31 in R39 implies ( ( R34 * R31 ) + R39 ) = (the carrier of R39))))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R34 being  integer number;
let R39 being (Submodule of R25);
assume L562: R31 in R39;
thus L563: ( ( R34 * R31 ) + R39 ) c= (the carrier of R39)
proof
let C89 being set;
assume L564: C89 in ( ( R34 * R31 ) + R39 );
consider R28 being (VECTOR of R25) such that L565: C89 = ( ( R34 * R31 ) + R28 ) and L566: R28 in R39 by L564;
L567: ( R34 * R31 ) in R39 by L562 , L266;
L568: ( ( R34 * R31 ) + R28 ) in R39 by L567 , L566 , L260;
thus L569: thesis by L568 , L565 , STRUCT_0:def 5;
end;

let C90 being set;
assume L570: C90 in (the carrier of R39);
L571: C90 in R39 by L570 , STRUCT_0:def 5;
L572: (the carrier of R39) c= (the carrier of R25) by L205;
reconsider D115 = C90 as (Element of R25) by L572 , L570;
L573: ( ( R34 * R31 ) + ( D115 - ( R34 * R31 ) ) ) = ( ( D115 + ( R34 * R31 ) ) - ( R34 * R31 ) ) by RLVECT_1:def 3
.= ( D115 + ( ( R34 * R31 ) - ( R34 * R31 ) ) ) by RLVECT_1:def 3
.= ( D115 + ( 0. R25 ) ) by RLVECT_1:15
.= C90 by RLVECT_1:4;
L574: ( R34 * R31 ) in R39 by L562 , L266;
L575: ( D115 - ( R34 * R31 ) ) in R39 by L574 , L571 , L276;
thus L576: thesis by L575 , L573;
end;
theorem
L577: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R28 in R39 iff ( R31 + R39 ) = ( ( R31 + R28 ) + R39 ))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L578: (R28 in R39 implies ( R31 + R39 ) = ( ( R31 + R28 ) + R39 ))
proof
assume L579: R28 in R39;
thus L580: ( R31 + R39 ) c= ( ( R31 + R28 ) + R39 )
proof
let C91 being set;
assume L581: C91 in ( R31 + R39 );
consider R32 being (VECTOR of R25) such that L582: C91 = ( R31 + R32 ) and L583: R32 in R39 by L581;
L584: ( ( R31 + R28 ) + ( R32 - R28 ) ) = ( R31 + ( R28 + ( R32 - R28 ) ) ) by RLVECT_1:def 3
.= ( R31 + ( ( R32 + R28 ) - R28 ) ) by RLVECT_1:def 3
.= ( R31 + ( R32 + ( R28 - R28 ) ) ) by RLVECT_1:def 3
.= ( R31 + ( R32 + ( 0. R25 ) ) ) by RLVECT_1:15
.= C91 by L582 , RLVECT_1:4;
L585: ( R32 - R28 ) in R39 by L579 , L583 , L276;
thus L586: thesis by L585 , L584;
end;

let C92 being set;
assume L587: C92 in ( ( R31 + R28 ) + R39 );
consider R33 being (VECTOR of R25) such that L588: C92 = ( ( R31 + R28 ) + R33 ) and L589: R33 in R39 by L587;
L590: C92 = ( R31 + ( R28 + R33 ) ) by L588 , RLVECT_1:def 3;
L591: ( R28 + R33 ) in R39 by L579 , L589 , L260;
thus L592: thesis by L591 , L590;
end;

assume L593: ( R31 + R39 ) = ( ( R31 + R28 ) + R39 );
L594: (( 0. R25 ) in R39 & ( R31 + ( 0. R25 ) ) = R31) by L253 , RLVECT_1:4;
L595: R31 in ( ( R31 + R28 ) + R39 ) by L594 , L593;
consider R29 being (VECTOR of R25) such that L596: R31 = ( ( R31 + R28 ) + R29 ) and L597: R29 in R39 by L595;
L598: (R31 = ( R31 + ( 0. R25 ) ) & R31 = ( R31 + ( R28 + R29 ) )) by L596 , RLVECT_1:4 , RLVECT_1:def 3;
L599: ( R28 + R29 ) = ( 0. R25 ) by L598 , RLVECT_1:8;
L600: R28 = ( - R29 ) by L599 , RLVECT_1:def 10;
thus L601: thesis by L600 , L597 , L272;
end;
theorem
L602: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R28 in R39 iff ( R31 + R39 ) = ( ( R31 - R28 ) + R39 ))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
L603: (( - R28 ) in R39 implies R28 in R39)
proof
assume L604: ( - R28 ) in R39;
L605: ( - ( - R28 ) ) in R39 by L604 , L272;
thus L606: thesis by L605 , RLVECT_1:17;
end;
L607: (( - R28 ) in R39 iff ( R31 + R39 ) = ( ( R31 + ( - R28 ) ) + R39 )) by L577;
thus L608: thesis by L607 , L603 , L272;
end;
theorem
L609: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R31 in ( R28 + R39 ) iff ( R28 + R39 ) = ( R31 + R39 ))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L610: (R31 in ( R28 + R39 ) implies ( R28 + R39 ) = ( R31 + R39 ))
proof
assume L611: R31 in ( R28 + R39 );
consider C93 being (VECTOR of R25) such that L612: R31 = ( R28 + C93 ) and L613: C93 in R39 by L611;
thus L614: ( R28 + R39 ) c= ( R31 + R39 )
proof
let C94 being set;
assume L615: C94 in ( R28 + R39 );
consider R32 being (VECTOR of R25) such that L616: C94 = ( R28 + R32 ) and L617: R32 in R39 by L615;
L618: ( R31 - C93 ) = ( R28 + ( C93 - C93 ) ) by L612 , RLVECT_1:def 3
.= ( R28 + ( 0. R25 ) ) by RLVECT_1:15
.= R28 by RLVECT_1:4;
L619: C94 = ( R31 + ( R32 + ( - C93 ) ) ) by L618 , L616 , RLVECT_1:def 3
.= ( R31 + ( R32 - C93 ) );
L620: ( R32 - C93 ) in R39 by L613 , L617 , L276;
thus L621: thesis by L620 , L619;
end;

let C95 being set;
assume L622: C95 in ( R31 + R39 );
consider R33 being (VECTOR of R25) such that L623: (C95 = ( R31 + R33 ) & R33 in R39) by L622;
L624: (( C93 + R33 ) in R39 & C95 = ( R28 + ( C93 + R33 ) )) by L612 , L613 , L623 , L260 , RLVECT_1:def 3;
thus L625: thesis by L624;
end;

thus L626: thesis by L517;
end;
theorem
L627: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R32 being (VECTOR of R25) holds (for R33 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds ((R28 in ( R32 + R39 ) & R28 in ( R33 + R39 )) implies ( R32 + R39 ) = ( R33 + R39 )))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R32 being (VECTOR of R25);
let R33 being (VECTOR of R25);
let R39 being (Submodule of R25);
assume that
L628: R28 in ( R32 + R39 )
and
L629: R28 in ( R33 + R39 );
consider C96 being (VECTOR of R25) such that L630: R28 = ( R32 + C96 ) and L631: C96 in R39 by L628;
consider C97 being (VECTOR of R25) such that L632: R28 = ( R33 + C97 ) and L633: C97 in R39 by L629;
thus L634: ( R32 + R39 ) c= ( R33 + R39 )
proof
let C98 being set;
assume L635: C98 in ( R32 + R39 );
consider R29 being (VECTOR of R25) such that L636: C98 = ( R32 + R29 ) and L637: R29 in R39 by L635;
L638: ( C97 - C96 ) in R39 by L631 , L633 , L276;
L639: ( ( C97 - C96 ) + R29 ) in R39 by L638 , L637 , L260;
L640: ( R28 - C96 ) = ( R32 + ( C96 - C96 ) ) by L630 , RLVECT_1:def 3
.= ( R32 + ( 0. R25 ) ) by RLVECT_1:15
.= R32 by RLVECT_1:4;
L641: C98 = ( ( R33 + ( C97 - C96 ) ) + R29 ) by L640 , L632 , L636 , RLVECT_1:def 3
.= ( R33 + ( ( C97 - C96 ) + R29 ) ) by RLVECT_1:def 3;
thus L642: thesis by L641 , L639;
end;

let C99 being set;
assume L643: C99 in ( R33 + R39 );
consider R29 being (VECTOR of R25) such that L644: C99 = ( R33 + R29 ) and L645: R29 in R39 by L643;
L646: ( C96 - C97 ) in R39 by L631 , L633 , L276;
L647: ( ( C96 - C97 ) + R29 ) in R39 by L646 , L645 , L260;
L648: ( R28 - C97 ) = ( R33 + ( C97 - C97 ) ) by L632 , RLVECT_1:def 3
.= ( R33 + ( 0. R25 ) ) by RLVECT_1:15
.= R33 by RLVECT_1:4;
L649: C99 = ( ( R32 + ( C96 - C97 ) ) + R29 ) by L648 , L630 , L644 , RLVECT_1:def 3
.= ( R32 + ( ( C96 - C97 ) + R29 ) ) by RLVECT_1:def 3;
thus L650: thesis by L649 , L647;
end;
theorem
L651: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for R34 being  integer number holds (for R39 being (Submodule of R25) holds (R31 in R39 implies ( R34 * R31 ) in ( R31 + R39 ))))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let R34 being  integer number;
let R39 being (Submodule of R25);
assume L652: R31 in R39;
L653: ( ( R34 - 1 ) * R31 ) in R39 by L652 , L266;
L654: ( R34 * R31 ) = ( ( ( R34 - 1 ) + 1 ) * R31 )
.= ( ( ( R34 - 1 ) * R31 ) + ( 1 * R31 ) ) by L10
.= ( R31 + ( ( R34 - 1 ) * R31 ) ) by L12;
thus L655: thesis by L654 , L653;
end;
theorem
L656: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (( R28 + R31 ) in ( R31 + R39 ) iff R28 in R39)))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L657: (( R28 + R31 ) in ( R31 + R39 ) implies R28 in R39)
proof
assume L658: ( R28 + R31 ) in ( R31 + R39 );
L659: (ex R32 being (VECTOR of R25) st (( R28 + R31 ) = ( R31 + R32 ) & R32 in R39)) by L658;
thus L660: thesis by L659 , RLVECT_1:8;
end;

assume L661: R28 in R39;
thus L662: thesis by L661;
end;
theorem
L663: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (( R31 - R28 ) in ( R31 + R39 ) iff R28 in R39)))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
L664: ( R31 - R28 ) = ( ( - R28 ) + R31 );
L665: (( - R28 ) in R39 implies ( - ( - R28 ) ) in R39) by L272;
L666: (R28 in R39 implies ( - R28 ) in R39) by L272;
thus L667: thesis by L666 , L664 , L665 , L656 , RLVECT_1:17;
end;
theorem
L668: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R28 in ( R31 + R39 ) iff (ex R32 being (VECTOR of R25) st (R32 in R39 & R28 = ( R31 + R32 ))))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L669: (R28 in ( R31 + R39 ) implies (ex R32 being (VECTOR of R25) st (R32 in R39 & R28 = ( R31 + R32 ))))
proof
assume L670: R28 in ( R31 + R39 );
L671: (ex R32 being (VECTOR of R25) st (R28 = ( R31 + R32 ) & R32 in R39)) by L670;
thus L672: thesis by L671;
end;

given R32 being (VECTOR of R25) such that
L673: (R32 in R39 & R28 = ( R31 + R32 ));

thus L674: thesis by L673;
end;
theorem
L675: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (R28 in ( R31 + R39 ) iff (ex R32 being (VECTOR of R25) st (R32 in R39 & R28 = ( R31 - R32 ))))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L676: (R28 in ( R31 + R39 ) implies (ex R32 being (VECTOR of R25) st (R32 in R39 & R28 = ( R31 - R32 ))))
proof
assume L677: R28 in ( R31 + R39 );
consider R32 being (VECTOR of R25) such that L678: R28 = ( R31 + R32 ) and L679: R32 in R39 by L677;
take D116 = ( - R32 );
thus L680: D116 in R39 by L679 , L272;
thus L681: thesis by L678 , RLVECT_1:17;
end;

given R32 being (VECTOR of R25) such that
L682: R32 in R39
and
L683: R28 = ( R31 - R32 );

L684: ( - R32 ) in R39 by L682 , L272;
thus L685: thesis by L684 , L683;
end;
theorem
L686: (for R25 being Z_Module holds (for R32 being (VECTOR of R25) holds (for R33 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds ((ex R31 being (VECTOR of R25) st (R32 in ( R31 + R39 ) & R33 in ( R31 + R39 ))) iff ( R32 - R33 ) in R39)))))
proof
let R25 being Z_Module;
let R32 being (VECTOR of R25);
let R33 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L687: ((ex R31 being (VECTOR of R25) st (R32 in ( R31 + R39 ) & R33 in ( R31 + R39 ))) implies ( R32 - R33 ) in R39)
proof
given R31 being (VECTOR of R25) such that
L688: R32 in ( R31 + R39 )
and
L689: R33 in ( R31 + R39 );

consider R30 being (VECTOR of R25) such that L690: R30 in R39 and L691: R33 = ( R31 + R30 ) by L689 , L668;
consider R29 being (VECTOR of R25) such that L692: R29 in R39 and L693: R32 = ( R31 + R29 ) by L688 , L668;
L694: ( R32 - R33 ) = ( ( R29 + R31 ) + ( ( - R31 ) - R30 ) ) by L693 , L691 , RLVECT_1:30
.= ( ( ( R29 + R31 ) + ( - R31 ) ) - R30 ) by RLVECT_1:def 3
.= ( ( R29 + ( R31 + ( - R31 ) ) ) - R30 ) by RLVECT_1:def 3
.= ( ( R29 + ( 0. R25 ) ) - R30 ) by RLVECT_1:5
.= ( R29 - R30 ) by RLVECT_1:4;
thus L695: thesis by L694 , L692 , L690 , L276;
end;

assume L696: ( R32 - R33 ) in R39;
L697: ( - ( R32 - R33 ) ) in R39 by L696 , L272;
take R32;
thus L698: R32 in ( R32 + R39 ) by L517;
L699: ( R32 + ( - ( R32 - R33 ) ) ) = ( R32 + ( ( - R32 ) + R33 ) ) by RLVECT_1:33
.= ( ( R32 + ( - R32 ) ) + R33 ) by RLVECT_1:def 3
.= ( ( 0. R25 ) + R33 ) by RLVECT_1:5
.= R33 by RLVECT_1:4;
thus L700: thesis by L699 , L697;
end;
theorem
L701: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (( R31 + R39 ) = ( R28 + R39 ) implies (ex R32 being (VECTOR of R25) st (R32 in R39 & ( R31 + R32 ) = R28)))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
assume L702: ( R31 + R39 ) = ( R28 + R39 );
L703: R31 in ( R28 + R39 ) by L702 , L517;
consider R29 being (VECTOR of R25) such that L704: R31 = ( R28 + R29 ) and L705: R29 in R39 by L703;
take D117 = ( R28 - R31 );
L706: ( 0. R25 ) = ( ( R28 + R29 ) - R31 ) by L704 , RLVECT_1:15
.= ( R29 + ( R28 - R31 ) ) by RLVECT_1:def 3;
L707: D117 = ( - R29 ) by L706 , RLVECT_1:def 10;
thus L708: D117 in R39 by L707 , L705 , L272;
thus L709: ( R31 + D117 ) = ( ( R28 + R31 ) - R31 ) by RLVECT_1:def 3
.= ( R28 + ( R31 - R31 ) ) by RLVECT_1:def 3
.= ( R28 + ( 0. R25 ) ) by RLVECT_1:15
.= R28 by RLVECT_1:4;
end;
theorem
L710: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (( R31 + R39 ) = ( R28 + R39 ) implies (ex R32 being (VECTOR of R25) st (R32 in R39 & ( R31 - R32 ) = R28)))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
assume L711: ( R31 + R39 ) = ( R28 + R39 );
L712: R28 in ( R31 + R39 ) by L711 , L517;
consider R29 being (VECTOR of R25) such that L713: R28 = ( R31 + R29 ) and L714: R29 in R39 by L712;
take D118 = ( R31 - R28 );
L715: ( 0. R25 ) = ( ( R31 + R29 ) - R28 ) by L713 , RLVECT_1:15
.= ( R29 + ( R31 - R28 ) ) by RLVECT_1:def 3;
L716: D118 = ( - R29 ) by L715 , RLVECT_1:def 10;
thus L717: D118 in R39 by L716 , L714 , L272;
thus L718: ( R31 - D118 ) = ( ( R31 - R31 ) + R28 ) by RLVECT_1:29
.= ( ( 0. R25 ) + R28 ) by RLVECT_1:15
.= R28 by RLVECT_1:4;
end;
theorem
L719: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds (for B72 , B73 being  strict (Submodule of R25) holds (( R31 + B72 ) = ( R31 + B73 ) implies B72 = B73))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
let C100 , C101 being  strict (Submodule of R25);
assume L720: ( R31 + C100 ) = ( R31 + C101 );
L721: (the carrier of C100) = (the carrier of C101)
proof
L722: (the carrier of C100) c= (the carrier of R25) by L205;
thus L723: (the carrier of C100) c= (the carrier of C101)
proof
let C102 being set;
assume L724: C102 in (the carrier of C100);
reconsider D119 = C102 as (Element of R25) by L724 , L722;
set D120 = ( R31 + D119 );
L725: C102 in C100 by L724 , STRUCT_0:def 5;
L726: D120 in ( R31 + C101 ) by L725 , L720;
consider R28 being (VECTOR of R25) such that L727: D120 = ( R31 + R28 ) and L728: R28 in C101 by L726;
L729: D119 = R28 by L727 , RLVECT_1:8;
thus L730: thesis by L729 , L728 , STRUCT_0:def 5;
end;

let C103 being set;
assume L731: C103 in (the carrier of C101);
L732: (the carrier of C101) c= (the carrier of R25) by L205;
reconsider D121 = C103 as (Element of R25) by L732 , L731;
set D122 = ( R31 + D121 );
L733: C103 in C101 by L731 , STRUCT_0:def 5;
L734: D122 in ( R31 + C100 ) by L733 , L720;
consider R28 being (VECTOR of R25) such that L735: D122 = ( R31 + R28 ) and L736: R28 in C100 by L734;
L737: D121 = R28 by L735 , RLVECT_1:8;
thus L738: thesis by L737 , L736 , STRUCT_0:def 5;
end;
thus L739: thesis by L721 , L365;
end;
theorem
L740: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for B74 , B75 being  strict (Submodule of R25) holds (( R31 + B74 ) = ( R28 + B75 ) implies B74 = B75)))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let C104 , C105 being  strict (Submodule of R25);
assume L741: ( R31 + C104 ) = ( R28 + C105 );
set D123 = (the carrier of C105);
set D124 = (the carrier of C104);
assume L742: C104 <> C105;
L743:
now
set D125 = the (Element of ( D124 \ D123 ));
assume L744: ( D124 \ D123 ) <> ( {} );
L745: D125 in D124 by L744 , XBOOLE_0:def 5;
L746: D125 in C104 by L745 , STRUCT_0:def 5;
L747: D125 in R25 by L746 , L213;
reconsider D126 = D125 as (Element of R25) by L747 , STRUCT_0:def 5;
set D127 = ( R31 + D126 );
L748: D127 in ( R28 + C105 ) by L741 , L746;
consider R29 being (VECTOR of R25) such that L749: D127 = ( R28 + R29 ) and L750: R29 in C105 by L748;
L751: D126 = ( ( 0. R25 ) + D126 ) by RLVECT_1:4
.= ( ( R31 - R31 ) + D126 ) by RLVECT_1:15
.= ( ( - R31 ) + ( R28 + R29 ) ) by L749 , RLVECT_1:def 3;
L752: ( ( R31 + ( ( - R31 ) + ( R28 + R29 ) ) ) + C104 ) = ( R31 + C104 ) by L751 , L746 , L577;
L753: ( R31 + ( ( - R31 ) + ( R28 + R29 ) ) ) = ( ( R31 - R31 ) + ( R28 + R29 ) ) by RLVECT_1:def 3
.= ( ( 0. R25 ) + ( R28 + R29 ) ) by RLVECT_1:15
.= ( R28 + R29 ) by RLVECT_1:4;
L754: ( ( R28 + R29 ) + C105 ) = ( ( R28 + R29 ) + C104 ) by L753 , L741 , L750 , L752 , L577;
thus L755: thesis by L754 , L742 , L719;
end;
L756:
now
set D128 = the (Element of ( D123 \ D124 ));
assume L757: ( D123 \ D124 ) <> ( {} );
L758: D128 in D123 by L757 , XBOOLE_0:def 5;
L759: D128 in C105 by L758 , STRUCT_0:def 5;
L760: D128 in R25 by L759 , L213;
reconsider D129 = D128 as (Element of R25) by L760 , STRUCT_0:def 5;
set D130 = ( R28 + D129 );
L761: D130 in ( R31 + C104 ) by L741 , L759;
consider R29 being (VECTOR of R25) such that L762: D130 = ( R31 + R29 ) and L763: R29 in C104 by L761;
L764: D129 = ( ( 0. R25 ) + D129 ) by RLVECT_1:4
.= ( ( R28 - R28 ) + D129 ) by RLVECT_1:15
.= ( ( - R28 ) + ( R31 + R29 ) ) by L762 , RLVECT_1:def 3;
L765: ( ( R28 + ( ( - R28 ) + ( R31 + R29 ) ) ) + C105 ) = ( R28 + C105 ) by L764 , L759 , L577;
L766: ( R28 + ( ( - R28 ) + ( R31 + R29 ) ) ) = ( ( R28 - R28 ) + ( R31 + R29 ) ) by RLVECT_1:def 3
.= ( ( 0. R25 ) + ( R31 + R29 ) ) by RLVECT_1:15
.= ( R31 + R29 ) by RLVECT_1:4;
L767: ( ( R31 + R29 ) + C104 ) = ( ( R31 + R29 ) + C105 ) by L766 , L741 , L763 , L765 , L577;
thus L768: thesis by L767 , L742 , L719;
end;
L769: D124 <> D123 by L742 , L365;
L770: ((not D124 c= D123) or (not D123 c= D124)) by L769 , XBOOLE_0:def 10;
thus L771: thesis by L770 , L743 , L756 , XBOOLE_1:37;
end;
theorem
L772: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds (for R50 being (Coset of R39) holds (R50 is  linearly-closed iff R50 = (the carrier of R39)))))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
let R50 being (Coset of R39);
thus L773: (R50 is  linearly-closed implies R50 = (the carrier of R39))
proof
assume L774: R50 is  linearly-closed;
consider R31 being (VECTOR of R25) such that L775: R50 = ( R31 + R39 ) by L503;
L776: R50 <> ( {} ) by L775 , L517;
L777: ( 0. R25 ) in ( R31 + R39 ) by L776 , L774 , L775 , L139;
thus L778: thesis by L777 , L775 , L557;
end;

thus L779: thesis by L241;
end;
theorem
L780: (for R25 being Z_Module holds (for B76 , B77 being  strict (Submodule of R25) holds (for B78 being (Coset of B76) holds (for B79 being (Coset of B77) holds (B78 = B79 implies B76 = B77)))))
proof
let R25 being Z_Module;
let C106 , C107 being  strict (Submodule of R25);
let C108 being (Coset of C106);
let C109 being (Coset of C107);
L781: ((ex R32 being (VECTOR of R25) st C108 = ( R32 + C106 )) & (ex R33 being (VECTOR of R25) st C109 = ( R33 + C107 ))) by L503;
thus L782: thesis by L781 , L740;
end;
theorem
L783: (for R25 being Z_Module holds (for R31 being (VECTOR of R25) holds { R31 } is (Coset of ( (0). R25 ))))
proof
let R25 being Z_Module;
let R31 being (VECTOR of R25);
L784: ( R31 + ( (0). R25 ) ) = { R31 } by L521;
thus L785: thesis by L784 , L503;
end;
theorem
L786: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (R35 is (Coset of ( (0). R25 )) implies (ex R31 being (VECTOR of R25) st R35 = { R31 }))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume L787: R35 is (Coset of ( (0). R25 ));
consider R31 being (VECTOR of R25) such that L788: R35 = ( R31 + ( (0). R25 ) ) by L787 , L503;
take R31;
thus L789: thesis by L788 , L521;
end;
theorem
L790: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds (the carrier of R39) is (Coset of R39)))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
L791: (the carrier of R39) = ( ( 0. R25 ) + R39 ) by L489;
thus L792: thesis by L791 , L503;
end;
theorem
L793: (for R25 being Z_Module holds (the carrier of R25) is (Coset of ( (Omega). R25 )))
proof
let R25 being Z_Module;
set D131 = the (VECTOR of R25);
L794: ((the carrier of R25) is (Subset of R25) iff (the carrier of R25) c= (the carrier of R25));
reconsider D132 = (the carrier of R25) as (Subset of R25) by L794;
L795: D132 = ( D131 + ( (Omega). R25 ) ) by L554;
thus L796: thesis by L795 , L503;
end;
theorem
L797: (for R25 being Z_Module holds (for R35 being (Subset of R25) holds (R35 is (Coset of ( (Omega). R25 )) implies R35 = (the carrier of R25))))
proof
let R25 being Z_Module;
let R35 being (Subset of R25);
assume L798: R35 is (Coset of ( (Omega). R25 ));
L799: (ex R31 being (VECTOR of R25) st R35 = ( R31 + ( (Omega). R25 ) )) by L798 , L503;
thus L800: thesis by L799 , L554;
end;
theorem
L801: (for R25 being Z_Module holds (for R39 being (Submodule of R25) holds (for R50 being (Coset of R39) holds (( 0. R25 ) in R50 iff R50 = (the carrier of R39)))))
proof
let R25 being Z_Module;
let R39 being (Submodule of R25);
let R50 being (Coset of R39);
L802: (ex R31 being (VECTOR of R25) st R50 = ( R31 + R39 )) by L503;
thus L803: thesis by L802 , L557;
end;
theorem
L804: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R50 being (Coset of R39) holds (R28 in R50 iff R50 = ( R28 + R39 ))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R50 being (Coset of R39);
thus L805: (R28 in R50 implies R50 = ( R28 + R39 ))
proof
assume L806: R28 in R50;
L807: (ex R31 being (VECTOR of R25) st R50 = ( R31 + R39 )) by L503;
thus L808: thesis by L807 , L806 , L609;
end;

thus L809: thesis by L517;
end;
theorem
L810: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R50 being (Coset of R39) holds ((R28 in R50 & R31 in R50) implies (ex R32 being (VECTOR of R25) st (R32 in R39 & ( R28 + R32 ) = R31))))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R50 being (Coset of R39);
assume L811: (R28 in R50 & R31 in R50);
L812: (R50 = ( R28 + R39 ) & R50 = ( R31 + R39 )) by L811 , L804;
thus L813: thesis by L812 , L701;
end;
theorem
L814: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R31 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R50 being (Coset of R39) holds ((R28 in R50 & R31 in R50) implies (ex R32 being (VECTOR of R25) st (R32 in R39 & ( R28 - R32 ) = R31))))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R31 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R50 being (Coset of R39);
assume L815: (R28 in R50 & R31 in R50);
L816: (R50 = ( R28 + R39 ) & R50 = ( R31 + R39 )) by L815 , L804;
thus L817: thesis by L816 , L710;
end;
theorem
L818: (for R25 being Z_Module holds (for R32 being (VECTOR of R25) holds (for R33 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds ((ex R50 being (Coset of R39) st (R32 in R50 & R33 in R50)) iff ( R32 - R33 ) in R39)))))
proof
let R25 being Z_Module;
let R32 being (VECTOR of R25);
let R33 being (VECTOR of R25);
let R39 being (Submodule of R25);
thus L819: ((ex R50 being (Coset of R39) st (R32 in R50 & R33 in R50)) implies ( R32 - R33 ) in R39)
proof
given R50 being (Coset of R39) such that
L820: (R32 in R50 & R33 in R50);

L821: (ex R31 being (VECTOR of R25) st R50 = ( R31 + R39 )) by L503;
thus L822: thesis by L821 , L820 , L686;
end;

assume L823: ( R32 - R33 ) in R39;
consider R31 being (VECTOR of R25) such that L824: (R32 in ( R31 + R39 ) & R33 in ( R31 + R39 )) by L823 , L686;
reconsider D133 = ( R31 + R39 ) as (Coset of R39) by L503;
take D133;
thus L825: thesis by L824;
end;
theorem
L826: (for R25 being Z_Module holds (for R28 being (VECTOR of R25) holds (for R39 being (Submodule of R25) holds (for R49 being (Coset of R39) holds (for R50 being (Coset of R39) holds ((R28 in R49 & R28 in R50) implies R49 = R50))))))
proof
let R25 being Z_Module;
let R28 being (VECTOR of R25);
let R39 being (Submodule of R25);
let R49 being (Coset of R39);
let R50 being (Coset of R39);
assume L827: (R28 in R49 & R28 in R50);
L828: ((ex R32 being (VECTOR of R25) st R49 = ( R32 + R39 )) & (ex R33 being (VECTOR of R25) st R50 = ( R33 + R39 ))) by L503;
thus L829: thesis by L828 , L827 , L627;
end;
begin
definition
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
func R53 + R54 ->  strict (Submodule of R51) means
:L830: (the carrier of it) = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) };
existence
proof
reconsider D134 = (the carrier of R53) , D135 = (the carrier of R54) as (Subset of R51) by L205;
set D136 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) };
L831: D136 c= (the carrier of R51)
proof
let C110 being set;
assume L832: C110 in D136;
L833: (ex R60 being (VECTOR of R51) st (ex R61 being (VECTOR of R51) st (C110 = ( R60 + R61 ) & R60 in R53 & R61 in R54))) by L832;
thus L834: thesis by L833;
end;
reconsider D137 = D136 as (Subset of R51) by L831;
L835: ( 0. R51 ) = ( ( 0. R51 ) + ( 0. R51 ) ) by RLVECT_1:4;
L836: (( 0. R51 ) in R53 & ( 0. R51 ) in R54) by L253;
L837: ( 0. R51 ) in D137 by L836 , L835;
L838: D137 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in D134 & R56 in D135) }
proof
thus L839: D137 c= { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in D134 & R56 in D135) }
proof
let C111 being set;
assume L840: C111 in D137;
consider R59 being (VECTOR of R51), R56 being (VECTOR of R51) such that L841: C111 = ( R59 + R56 ) and L842: (R59 in R53 & R56 in R54) by L840;
L843: (R59 in D134 & R56 in D135) by L842 , STRUCT_0:def 5;
thus L844: thesis by L843 , L841;
end;

let C112 being set;
assume L845: C112 in { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in D134 & R56 in D135) };
consider R59 being (VECTOR of R51), R56 being (VECTOR of R51) such that L846: C112 = ( R59 + R56 ) and L847: (R59 in D134 & R56 in D135) by L845;
L848: (R59 in R53 & R56 in R54) by L847 , STRUCT_0:def 5;
thus L849: thesis by L848 , L846;
end;
L850: (D134 is  linearly-closed & D135 is  linearly-closed) by L241;
thus L851: thesis by L850 , L837 , L838 , L159 , L394;
end;
uniqueness by L365;
commutativity
proof
let C113 being  strict (Submodule of R51);
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
set D138 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) };
set D139 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R54 & R56 in R53) };
L852: D139 c= D138
proof
let C114 being set;
assume L853: C114 in D139;
L854: (ex R59 being (VECTOR of R51) st (ex R56 being (VECTOR of R51) st (C114 = ( R59 + R56 ) & R59 in R54 & R56 in R53))) by L853;
thus L855: thesis by L854;
end;
L856: D138 c= D139
proof
let C115 being set;
assume L857: C115 in D138;
L858: (ex R59 being (VECTOR of R51) st (ex R56 being (VECTOR of R51) st (C115 = ( R59 + R56 ) & R59 in R53 & R56 in R54))) by L857;
thus L859: thesis by L858;
end;
thus L860: thesis by L856 , L852 , XBOOLE_0:def 10;
end;
end;
definition
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
func R53 /\ R54 ->  strict (Submodule of R51) means
:L862: (the carrier of it) = ( (the carrier of R53) /\ (the carrier of R54) );
existence
proof
set D140 = (the carrier of R54);
set D141 = (the carrier of R53);
set D142 = (the carrier of R51);
L863: ( 0. R51 ) in R54 by L253;
L864: ( 0. R51 ) in D140 by L863 , STRUCT_0:def 5;
L865: (D141 c= D142 & D140 c= D142) by L205;
L866: ( D141 /\ D140 ) c= ( D142 /\ D142 ) by L865 , XBOOLE_1:27;
reconsider D143 = D141 , D144 = D140 , D145 = ( D141 /\ D140 ) as (Subset of R51) by L866 , L205;
L867: (D143 is  linearly-closed & D144 is  linearly-closed) by L241;
L868: D145 is  linearly-closed by L867;
L869: ( 0. R51 ) in R53 by L253;
L870: ( 0. R51 ) in D141 by L869 , STRUCT_0:def 5;
L871: ( D141 /\ D140 ) <> ( {} ) by L870 , L864 , XBOOLE_0:def 4;
thus L872: thesis by L871 , L868 , L394;
end;
uniqueness by L365;
commutativity
;
end;
theorem
L874: (for R38 being set holds (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (R38 in ( R53 + R54 ) iff (ex R60 being (VECTOR of R51) st (ex R61 being (VECTOR of R51) st (R60 in R53 & R61 in R54 & R38 = ( R60 + R61 )))))))))
proof
let R38 being set;
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
thus L875: (R38 in ( R53 + R54 ) implies (ex R60 being (VECTOR of R51) st (ex R61 being (VECTOR of R51) st (R60 in R53 & R61 in R54 & R38 = ( R60 + R61 )))))
proof
assume L876: R38 in ( R53 + R54 );
L877: R38 in (the carrier of ( R53 + R54 )) by L876 , STRUCT_0:def 5;
L878: R38 in { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) } by L877 , L830;
consider R60 being (VECTOR of R51), R61 being (VECTOR of R51) such that L879: (R38 = ( R60 + R61 ) & R60 in R53 & R61 in R54) by L878;
take R60;
take R61;
thus L880: thesis by L879;
end;

given R60 being (VECTOR of R51) , R61 being (VECTOR of R51) such that
L881: (R60 in R53 & R61 in R54 & R38 = ( R60 + R61 ));

L882: R38 in { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) } by L881;
L883: R38 in (the carrier of ( R53 + R54 )) by L882 , L830;
thus L884: thesis by L883 , STRUCT_0:def 5;
end;
theorem
L885: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R59 being (VECTOR of R51) holds ((R59 in R53 or R59 in R54) implies R59 in ( R53 + R54 ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R59 being (VECTOR of R51);
assume L886: (R59 in R53 or R59 in R54);
L887:
now
per cases  by L886;
suppose L888: R59 in R53;

L889: (R59 = ( R59 + ( 0. R51 ) ) & ( 0. R51 ) in R54) by L253 , RLVECT_1:4;
thus L890: thesis by L889 , L888 , L874;
end;
suppose L891: R59 in R54;

L892: (R59 = ( ( 0. R51 ) + R59 ) & ( 0. R51 ) in R53) by L253 , RLVECT_1:4;
thus L893: thesis by L892 , L891 , L874;
end;
end;
thus L895: thesis by L887;
end;
theorem
L896: (for R38 being set holds (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (R38 in ( R53 /\ R54 ) iff (R38 in R53 & R38 in R54))))))
proof
let R38 being set;
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
L897: (R38 in ( R53 /\ R54 ) iff R38 in (the carrier of ( R53 /\ R54 ))) by STRUCT_0:def 5;
L898: (R38 in ( R53 /\ R54 ) iff R38 in ( (the carrier of R53) /\ (the carrier of R54) )) by L897 , L862;
L899: (R38 in ( R53 /\ R54 ) iff (R38 in (the carrier of R53) & R38 in (the carrier of R54))) by L898 , XBOOLE_0:def 4;
thus L900: thesis by L899 , STRUCT_0:def 5;
end;
L901: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (the carrier of R53) c= (the carrier of ( R53 + R54 )))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let C116 being set;
set D146 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) };
assume L902: C116 in (the carrier of R53);
reconsider D147 = C116 as (Element of R53) by L902;
reconsider D148 = D147 as (VECTOR of R51) by L218;
L903: D148 = ( D148 + ( 0. R51 ) ) by RLVECT_1:4;
L904: (D148 in R53 & ( 0. R51 ) in R54) by L253 , STRUCT_0:def 5;
L905: C116 in D146 by L904 , L903;
thus L906: thesis by L905 , L830;
end;
L907: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for B80 being  strict (Submodule of R51) holds ((the carrier of R53) c= (the carrier of B80) implies ( R53 + B80 ) = B80))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let C117 being  strict (Submodule of R51);
assume L908: (the carrier of R53) c= (the carrier of C117);
L909: (the carrier of ( R53 + C117 )) c= (the carrier of C117)
proof
let C118 being set;
assume L910: C118 in (the carrier of ( R53 + C117 ));
L911: C118 in { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in C117) } by L910 , L830;
consider R59 being (VECTOR of R51), R56 being (VECTOR of R51) such that L912: C118 = ( R59 + R56 ) and L913: R59 in R53 and L914: R56 in C117 by L911;
L915: R53 is (Submodule of C117) by L908 , L341;
L916: R59 in C117 by L915 , L913 , L209;
L917: ( R59 + R56 ) in C117 by L916 , L914 , L260;
thus L918: thesis by L917 , L912 , STRUCT_0:def 5;
end;
L919: (the carrier of C117) c= (the carrier of ( R53 + C117 )) by L901;
L920: (the carrier of ( R53 + C117 )) = (the carrier of C117) by L919 , L909 , XBOOLE_0:def 10;
thus L921: thesis by L920 , L365;
end;
theorem
L922: (for R51 being Z_Module holds (for B81 being  strict (Submodule of R51) holds ( B81 + B81 ) = B81)) by L907;
theorem
L923: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds ( R53 + ( R54 + R55 ) ) = ( ( R53 + R54 ) + R55 )))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
set D149 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in R54) };
set D150 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R54 & R56 in R55) };
set D151 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in ( R53 + R54 ) & R56 in R55) };
set D152 = { ( R59 + R56 ) where R59 is (VECTOR of R51) , R56 is (VECTOR of R51) : (R59 in R53 & R56 in ( R54 + R55 )) };
L924: (the carrier of ( R53 + ( R54 + R55 ) )) = D152 by L830;
L925: D151 c= D152
proof
let C119 being set;
assume L926: C119 in D151;
consider R59 being (VECTOR of R51), R56 being (VECTOR of R51) such that L927: C119 = ( R59 + R56 ) and L928: R59 in ( R53 + R54 ) and L929: R56 in R55 by L926;
L930: R59 in (the carrier of ( R53 + R54 )) by L928 , STRUCT_0:def 5;
L931: R59 in D149 by L930 , L830;
consider R57 being (VECTOR of R51), R58 being (VECTOR of R51) such that L932: R59 = ( R57 + R58 ) and L933: R57 in R53 and L934: R58 in R54 by L931;
L935: ( R58 + R56 ) in D150 by L929 , L934;
L936: ( R58 + R56 ) in (the carrier of ( R54 + R55 )) by L935 , L830;
L937: ( R58 + R56 ) in ( R54 + R55 ) by L936 , STRUCT_0:def 5;
L938: ( R59 + R56 ) = ( R57 + ( R58 + R56 ) ) by L932 , RLVECT_1:def 3;
thus L939: thesis by L938 , L927 , L933 , L937;
end;
L940: D152 c= D151
proof
let C120 being set;
assume L941: C120 in D152;
consider R59 being (VECTOR of R51), R56 being (VECTOR of R51) such that L942: C120 = ( R59 + R56 ) and L943: R59 in R53 and L944: R56 in ( R54 + R55 ) by L941;
L945: R56 in (the carrier of ( R54 + R55 )) by L944 , STRUCT_0:def 5;
L946: R56 in D150 by L945 , L830;
consider R57 being (VECTOR of R51), R58 being (VECTOR of R51) such that L947: R56 = ( R57 + R58 ) and L948: R57 in R54 and L949: R58 in R55 by L946;
L950: ( R59 + R57 ) in D149 by L943 , L948;
L951: ( R59 + R57 ) in (the carrier of ( R53 + R54 )) by L950 , L830;
L952: ( R59 + R57 ) in ( R53 + R54 ) by L951 , STRUCT_0:def 5;
L953: ( R59 + R56 ) = ( ( R59 + R57 ) + R58 ) by L947 , RLVECT_1:def 3;
thus L954: thesis by L953 , L942 , L949 , L952;
end;
L955: D152 = D151 by L940 , L925 , XBOOLE_0:def 10;
thus L956: thesis by L955 , L924 , L830;
end;
theorem
L957: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds R53 is (Submodule of ( R53 + R54 )))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
L958: (the carrier of R53) c= (the carrier of ( R53 + R54 )) by L901;
thus L959: R53 is (Submodule of ( R53 + R54 )) by L958 , L341;
end;
theorem
L960: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for B82 being  strict (Submodule of R51) holds (R53 is (Submodule of B82) iff ( R53 + B82 ) = B82))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let C121 being  strict (Submodule of R51);
thus L961: (R53 is (Submodule of C121) implies ( R53 + C121 ) = C121)
proof
assume L962: R53 is (Submodule of C121);
L963: (the carrier of R53) c= (the carrier of C121) by L962 , L205;
thus L964: thesis by L963 , L907;
end;

thus L965: thesis by L957;
end;
theorem
L966: (for R51 being Z_Module holds (for B83 being  strict (Submodule of R51) holds ( ( (0). R51 ) + B83 ) = B83))
proof
let R51 being Z_Module;
let C122 being  strict (Submodule of R51);
L967: ( (0). R51 ) is (Submodule of C122) by L468;
L968: (the carrier of ( (0). R51 )) c= (the carrier of C122) by L967 , L205;
thus L969: thesis by L968 , L907;
end;
theorem
L970: (for R51 being Z_Module holds ( ( (0). R51 ) + ( (Omega). R51 ) ) = ( the Z_ModuleStruct of R51 )) by L966;
theorem
L971: (for R51 being Z_Module holds (for R52 being (Submodule of R51) holds ( ( (Omega). R51 ) + R52 ) = ( the Z_ModuleStruct of R51 )))
proof
let R51 being Z_Module;
let R52 being (Submodule of R51);
L972: (the carrier of R52) c= (the carrier of R51) by L205;
thus L973: thesis by L972 , L907;
end;
theorem
L974: (for B84 being  strict Z_Module holds ( ( (Omega). B84 ) + ( (Omega). B84 ) ) = B84) by L971;
theorem
L975: (for R51 being Z_Module holds (for B85 being  strict (Submodule of R51) holds ( B85 /\ B85 ) = B85))
proof
let R51 being Z_Module;
let C123 being  strict (Submodule of R51);
L976: (the carrier of C123) = ( (the carrier of C123) /\ (the carrier of C123) );
thus L977: thesis by L976 , L862;
end;
theorem
L978: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds ( R53 /\ ( R54 /\ R55 ) ) = ( ( R53 /\ R54 ) /\ R55 )))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
set D153 = (the carrier of R53);
set D154 = (the carrier of R54);
set D155 = (the carrier of R55);
L979: (the carrier of ( R53 /\ ( R54 /\ R55 ) )) = ( D153 /\ (the carrier of ( R54 /\ R55 )) ) by L862
.= ( D153 /\ ( D154 /\ D155 ) ) by L862
.= ( ( D153 /\ D154 ) /\ D155 ) by XBOOLE_1:16
.= ( (the carrier of ( R53 /\ R54 )) /\ D155 ) by L862;
thus L980: thesis by L979 , L862;
end;
L981: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (the carrier of ( R53 /\ R54 )) c= (the carrier of R53))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
L982: (the carrier of ( R53 /\ R54 )) = ( (the carrier of R53) /\ (the carrier of R54) ) by L862;
thus L983: thesis by L982 , XBOOLE_1:17;
end;
theorem
L984: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ( R53 /\ R54 ) is (Submodule of R53))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
L985: (the carrier of ( R53 /\ R54 )) c= (the carrier of R53) by L981;
thus L986: ( R53 /\ R54 ) is (Submodule of R53) by L985 , L341;
end;
theorem
L987: (for R51 being Z_Module holds (for R54 being (Submodule of R51) holds (for B86 being  strict (Submodule of R51) holds (B86 is (Submodule of R54) iff ( B86 /\ R54 ) = B86))))
proof
let R51 being Z_Module;
let R54 being (Submodule of R51);
let C124 being  strict (Submodule of R51);
thus L988: (C124 is (Submodule of R54) implies ( C124 /\ R54 ) = C124)
proof
assume L989: C124 is (Submodule of R54);
L990: (the carrier of C124) c= (the carrier of R54) by L989 , L205;
L991: (the carrier of ( C124 /\ R54 )) = ( (the carrier of C124) /\ (the carrier of R54) ) by L862;
thus L992: thesis by L991 , L990 , L365 , XBOOLE_1:28;
end;

thus L993: thesis by L984;
end;
theorem
L994: (for R51 being Z_Module holds (for R52 being (Submodule of R51) holds ( ( (0). R51 ) /\ R52 ) = ( (0). R51 )))
proof
let R51 being Z_Module;
let R52 being (Submodule of R51);
L995: ( 0. R51 ) in R52 by L253;
L996: ( 0. R51 ) in (the carrier of R52) by L995 , STRUCT_0:def 5;
L997: { ( 0. R51 ) } c= (the carrier of R52) by L996 , ZFMISC_1:31;
L998: ( { ( 0. R51 ) } /\ (the carrier of R52) ) = { ( 0. R51 ) } by L997 , XBOOLE_1:28;
L999: (the carrier of ( ( (0). R51 ) /\ R52 )) = ( (the carrier of ( (0). R51 )) /\ (the carrier of R52) ) by L862
.= ( { ( 0. R51 ) } /\ (the carrier of R52) ) by L435;
thus L1000: thesis by L999 , L998 , L435;
end;
theorem
L1001: (for R51 being Z_Module holds ( ( (0). R51 ) /\ ( (Omega). R51 ) ) = ( (0). R51 )) by L994;
theorem
L1002: (for R51 being Z_Module holds (for B87 being  strict (Submodule of R51) holds ( ( (Omega). R51 ) /\ B87 ) = B87))
proof
let R51 being Z_Module;
let C125 being  strict (Submodule of R51);
L1003: ((the carrier of ( ( (Omega). R51 ) /\ C125 )) = ( (the carrier of R51) /\ (the carrier of C125) ) & (the carrier of C125) c= (the carrier of R51)) by L862 , L205;
thus L1004: thesis by L1003 , L365 , XBOOLE_1:28;
end;
theorem
L1005: (for B88 being  strict Z_Module holds ( ( (Omega). B88 ) /\ ( (Omega). B88 ) ) = B88) by L1002;
L1006: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (the carrier of ( R53 /\ R54 )) c= (the carrier of ( R53 + R54 )))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
L1007: ((the carrier of ( R53 /\ R54 )) c= (the carrier of R53) & (the carrier of R53) c= (the carrier of ( R53 + R54 ))) by L901 , L981;
thus L1008: thesis by L1007 , XBOOLE_1:1;
end;
theorem
L1009: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ( R53 /\ R54 ) is (Submodule of ( R53 + R54 ))))) by L1006 , L341;
L1010: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (the carrier of ( ( R53 /\ R54 ) + R54 )) = (the carrier of R54))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
thus L1011: (the carrier of ( ( R53 /\ R54 ) + R54 )) c= (the carrier of R54)
proof
let C126 being set;
assume L1012: C126 in (the carrier of ( ( R53 /\ R54 ) + R54 ));
L1013: C126 in { ( R56 + R59 ) where R56 is (VECTOR of R51) , R59 is (VECTOR of R51) : (R56 in ( R53 /\ R54 ) & R59 in R54) } by L1012 , L830;
consider R56 being (VECTOR of R51), R59 being (VECTOR of R51) such that L1014: C126 = ( R56 + R59 ) and L1015: R56 in ( R53 /\ R54 ) and L1016: R59 in R54 by L1013;
L1017: R56 in R54 by L1015 , L896;
L1018: ( R56 + R59 ) in R54 by L1017 , L1016 , L260;
thus L1019: thesis by L1018 , L1014 , STRUCT_0:def 5;
end;

let C127 being set;
L1020: (the carrier of R54) c= (the carrier of ( ( R53 /\ R54 ) + R54 )) by L901;
thus L1021: thesis by L1020;
end;
theorem
L1022: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for B89 being  strict (Submodule of R51) holds ( ( R53 /\ B89 ) + B89 ) = B89))) by L1010 , L365;
L1023: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (the carrier of ( R53 /\ ( R53 + R54 ) )) = (the carrier of R53))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
thus L1024: (the carrier of ( R53 /\ ( R53 + R54 ) )) c= (the carrier of R53)
proof
let C128 being set;
assume L1025: C128 in (the carrier of ( R53 /\ ( R53 + R54 ) ));
L1026: (the carrier of ( R53 /\ ( R53 + R54 ) )) = ( (the carrier of R53) /\ (the carrier of ( R53 + R54 )) ) by L862;
thus L1027: thesis by L1026 , L1025 , XBOOLE_0:def 4;
end;

let C129 being set;
assume L1028: C129 in (the carrier of R53);
L1029: (the carrier of R53) c= (the carrier of R51) by L205;
reconsider D156 = C129 as (Element of R51) by L1029 , L1028;
L1030: (( D156 + ( 0. R51 ) ) = D156 & ( 0. R51 ) in R54) by L253 , RLVECT_1:4;
L1031: C129 in R53 by L1028 , STRUCT_0:def 5;
L1032: C129 in { ( R56 + R59 ) where R56 is (VECTOR of R51) , R59 is (VECTOR of R51) : (R56 in R53 & R59 in R54) } by L1031 , L1030;
L1033: C129 in (the carrier of ( R53 + R54 )) by L1032 , L830;
L1034: C129 in ( (the carrier of R53) /\ (the carrier of ( R53 + R54 )) ) by L1033 , L1028 , XBOOLE_0:def 4;
thus L1035: thesis by L1034 , L862;
end;
theorem
L1036: (for R51 being Z_Module holds (for R54 being (Submodule of R51) holds (for B90 being  strict (Submodule of R51) holds ( B90 /\ ( B90 + R54 ) ) = B90))) by L1023 , L365;
L1037: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (the carrier of ( ( R53 /\ R54 ) + ( R54 /\ R55 ) )) c= (the carrier of ( R54 /\ ( R53 + R55 ) ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
let C130 being set;
assume L1038: C130 in (the carrier of ( ( R53 /\ R54 ) + ( R54 /\ R55 ) ));
L1039: C130 in { ( R56 + R59 ) where R56 is (VECTOR of R51) , R59 is (VECTOR of R51) : (R56 in ( R53 /\ R54 ) & R59 in ( R54 /\ R55 )) } by L1038 , L830;
consider R56 being (VECTOR of R51), R59 being (VECTOR of R51) such that L1040: C130 = ( R56 + R59 ) and L1041: (R56 in ( R53 /\ R54 ) & R59 in ( R54 /\ R55 )) by L1039;
L1042: (R56 in R54 & R59 in R54) by L1041 , L896;
L1043: C130 in R54 by L1042 , L1040 , L260;
L1044: (R56 in R53 & R59 in R55) by L1041 , L896;
L1045: C130 in ( R53 + R55 ) by L1044 , L1040 , L874;
L1046: C130 in ( R54 /\ ( R53 + R55 ) ) by L1045 , L1043 , L896;
thus L1047: thesis by L1046 , STRUCT_0:def 5;
end;
theorem
L1048: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds ( ( R53 /\ R54 ) + ( R54 /\ R55 ) ) is (Submodule of ( R54 /\ ( R53 + R55 ) )))))) by L1037 , L341;
L1049: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (R53 is (Submodule of R54) implies (the carrier of ( R54 /\ ( R53 + R55 ) )) = (the carrier of ( ( R53 /\ R54 ) + ( R54 /\ R55 ) )))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
assume L1050: R53 is (Submodule of R54);
thus L1051: (the carrier of ( R54 /\ ( R53 + R55 ) )) c= (the carrier of ( ( R53 /\ R54 ) + ( R54 /\ R55 ) ))
proof
let C131 being set;
assume L1052: C131 in (the carrier of ( R54 /\ ( R53 + R55 ) ));
L1053: C131 in ( (the carrier of R54) /\ (the carrier of ( R53 + R55 )) ) by L1052 , L862;
L1054: C131 in (the carrier of ( R53 + R55 )) by L1053 , XBOOLE_0:def 4;
L1055: C131 in { ( R56 + R59 ) where R56 is (VECTOR of R51) , R59 is (VECTOR of R51) : (R56 in R53 & R59 in R55) } by L1054 , L830;
consider R57 being (VECTOR of R51), R60 being (VECTOR of R51) such that L1056: C131 = ( R57 + R60 ) and L1057: R57 in R53 and L1058: R60 in R55 by L1055;
L1059: R57 in R54 by L1050 , L1057 , L209;
L1060: C131 in (the carrier of R54) by L1053 , XBOOLE_0:def 4;
L1061: ( R57 + R60 ) in R54 by L1060 , L1056 , STRUCT_0:def 5;
L1062: ( ( R60 + R57 ) - R57 ) in R54 by L1061 , L1059 , L276;
L1063: ( R60 + ( R57 - R57 ) ) in R54 by L1062 , RLVECT_1:def 3;
L1064: ( R60 + ( 0. R51 ) ) in R54 by L1063 , RLVECT_1:15;
L1065: R60 in R54 by L1064 , RLVECT_1:4;
L1066: R60 in ( R54 /\ R55 ) by L1065 , L1058 , L896;
L1067: R57 in ( R53 /\ R54 ) by L1057 , L1059 , L896;
L1068: C131 in ( ( R53 /\ R54 ) + ( R54 /\ R55 ) ) by L1067 , L1056 , L1066 , L874;
thus L1069: thesis by L1068 , STRUCT_0:def 5;
end;

thus L1070: thesis by L1037;
end;
theorem
L1071: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (R53 is (Submodule of R54) implies ( R54 /\ ( R53 + R55 ) ) = ( ( R53 /\ R54 ) + ( R54 /\ R55 ) )))))) by L1049 , L365;
L1072: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (the carrier of ( R54 + ( R53 /\ R55 ) )) c= (the carrier of ( ( R53 + R54 ) /\ ( R54 + R55 ) ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
let C132 being set;
assume L1073: C132 in (the carrier of ( R54 + ( R53 /\ R55 ) ));
L1074: C132 in { ( R56 + R59 ) where R56 is (VECTOR of R51) , R59 is (VECTOR of R51) : (R56 in R54 & R59 in ( R53 /\ R55 )) } by L1073 , L830;
consider R56 being (VECTOR of R51), R59 being (VECTOR of R51) such that L1075: (C132 = ( R56 + R59 ) & R56 in R54) and L1076: R59 in ( R53 /\ R55 ) by L1074;
L1077: R59 in R55 by L1076 , L896;
L1078: C132 in { ( R57 + R58 ) where R57 is (VECTOR of R51) , R58 is (VECTOR of R51) : (R57 in R54 & R58 in R55) } by L1077 , L1075;
L1079: C132 in (the carrier of ( R54 + R55 )) by L1078 , L830;
L1080: R59 in R53 by L1076 , L896;
L1081: C132 in { ( R60 + R61 ) where R60 is (VECTOR of R51) , R61 is (VECTOR of R51) : (R60 in R53 & R61 in R54) } by L1080 , L1075;
L1082: C132 in (the carrier of ( R53 + R54 )) by L1081 , L830;
L1083: C132 in ( (the carrier of ( R53 + R54 )) /\ (the carrier of ( R54 + R55 )) ) by L1082 , L1079 , XBOOLE_0:def 4;
thus L1084: thesis by L1083 , L862;
end;
theorem
L1085: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds ( R54 + ( R53 /\ R55 ) ) is (Submodule of ( ( R53 + R54 ) /\ ( R54 + R55 ) )))))) by L1072 , L341;
L1086: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (R53 is (Submodule of R54) implies (the carrier of ( R54 + ( R53 /\ R55 ) )) = (the carrier of ( ( R53 + R54 ) /\ ( R54 + R55 ) )))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
reconsider D157 = (the carrier of R54) as (Subset of R51) by L205;
L1087: D157 is  linearly-closed by L241;
assume L1088: R53 is (Submodule of R54);
L1089: (the carrier of R53) c= (the carrier of R54) by L1088 , L205;
thus L1090: (the carrier of ( R54 + ( R53 /\ R55 ) )) c= (the carrier of ( ( R53 + R54 ) /\ ( R54 + R55 ) )) by L1072;
let C133 being set;
assume L1091: C133 in (the carrier of ( ( R53 + R54 ) /\ ( R54 + R55 ) ));
L1092: C133 in ( (the carrier of ( R53 + R54 )) /\ (the carrier of ( R54 + R55 )) ) by L1091 , L862;
L1093: C133 in (the carrier of ( R53 + R54 )) by L1092 , XBOOLE_0:def 4;
L1094: C133 in { ( R57 + R58 ) where R57 is (VECTOR of R51) , R58 is (VECTOR of R51) : (R57 in R53 & R58 in R54) } by L1093 , L830;
consider R57 being (VECTOR of R51), R58 being (VECTOR of R51) such that L1095: C133 = ( R57 + R58 ) and L1096: (R57 in R53 & R58 in R54) by L1094;
L1097: (R57 in (the carrier of R53) & R58 in (the carrier of R54)) by L1096 , STRUCT_0:def 5;
L1098: ( R57 + R58 ) in D157 by L1097 , L1089 , L1087 , L137;
L1099: ( R57 + R58 ) in R54 by L1098 , STRUCT_0:def 5;
L1100: (( 0. R51 ) in ( R53 /\ R55 ) & ( ( R57 + R58 ) + ( 0. R51 ) ) = ( R57 + R58 )) by L253 , RLVECT_1:4;
L1101: C133 in { ( R56 + R59 ) where R56 is (VECTOR of R51) , R59 is (VECTOR of R51) : (R56 in R54 & R59 in ( R53 /\ R55 )) } by L1100 , L1095 , L1099;
thus L1102: thesis by L1101 , L830;
end;
theorem
L1103: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (R53 is (Submodule of R54) implies ( R54 + ( R53 /\ R55 ) ) = ( ( R53 + R54 ) /\ ( R54 + R55 ) )))))) by L1086 , L365;
theorem
L1104: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R55 being (Submodule of R51) holds (R53 is  strict  strict  strict  strict (Submodule of R55) implies ( R53 + ( R54 /\ R55 ) ) = ( ( R53 + R54 ) /\ R55 ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R55 being (Submodule of R51);
assume L1105: R53 is  strict  strict  strict  strict (Submodule of R55);
thus L1106: ( ( R53 + R54 ) /\ R55 ) = ( ( R53 /\ R55 ) + ( R55 /\ R54 ) ) by L1105 , L1049 , L365
.= ( R53 + ( R54 /\ R55 ) ) by L1105 , L987;
end;
theorem
L1107: (for R51 being Z_Module holds (for B91 , B92 being  strict (Submodule of R51) holds (( B91 + B92 ) = B92 iff ( B91 /\ B92 ) = B91)))
proof
let R51 being Z_Module;
let C134 , C135 being  strict (Submodule of R51);
L1108: (( C134 + C135 ) = C135 iff C134 is (Submodule of C135)) by L960;
thus L1109: thesis by L1108 , L987;
end;
theorem
L1110: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for B93 , B94 being  strict (Submodule of R51) holds (R53 is (Submodule of B93) implies ( R53 + B94 ) is (Submodule of ( B93 + B94 ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let C136 , C137 being  strict (Submodule of R51);
assume L1111: R53 is (Submodule of C136);
L1112: ( ( R53 + C137 ) + ( C136 + C137 ) ) = ( ( ( R53 + C137 ) + C137 ) + C136 ) by L923
.= ( ( R53 + ( C137 + C137 ) ) + C136 ) by L923
.= ( ( R53 + C137 ) + C136 ) by L907
.= ( ( R53 + C136 ) + C137 ) by L923
.= ( C136 + C137 ) by L1111 , L960;
thus L1113: thesis by L1112 , L960;
end;
theorem
L1114: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((ex R52 being (Submodule of R51) st (the carrier of R52) = ( (the carrier of R53) \/ (the carrier of R54) )) iff (R53 is (Submodule of R54) or R54 is (Submodule of R53))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
set D158 = (the carrier of R53);
set D159 = (the carrier of R54);
thus L1115: ((ex R52 being (Submodule of R51) st (the carrier of R52) = ( (the carrier of R53) \/ (the carrier of R54) )) implies (R53 is (Submodule of R54) or R54 is (Submodule of R53)))
proof
given R52 being (Submodule of R51) such that
L1116: (the carrier of R52) = ( (the carrier of R53) \/ (the carrier of R54) );

set D160 = (the carrier of R52);
assume that
L1117: (not R53 is (Submodule of R54))
and
L1118: (not R54 is (Submodule of R53));
L1119: (not D159 c= D158) by L1118 , L341;
consider C138 being set such that L1120: C138 in D159 and L1121: (not C138 in D158) by L1119 , TARSKI:def 3;
reconsider D161 = C138 as (Element of D159) by L1120;
reconsider D162 = D161 as (VECTOR of R51) by L218;
reconsider D163 = D160 as (Subset of R51) by L205;
L1122: D163 is  linearly-closed by L241;
L1123: (not D158 c= D159) by L1117 , L341;
consider C139 being set such that L1124: C139 in D158 and L1125: (not C139 in D159) by L1123 , TARSKI:def 3;
reconsider D164 = C139 as (Element of D158) by L1124;
reconsider D165 = D164 as (VECTOR of R51) by L218;
L1126:
now
reconsider D166 = D159 as (Subset of R51) by L205;
L1127: D166 is  linearly-closed by L241;
assume L1128: ( D165 + D162 ) in D159;
L1129: ( ( D165 + D162 ) - D162 ) in D159 by L1128 , L1127 , L149;
L1130: ( D165 + ( D162 - D162 ) ) in D159 by L1129 , RLVECT_1:def 3;
L1131: ( D165 + ( 0. R51 ) ) in D159 by L1130 , RLVECT_1:15;
thus L1132: contradiction by L1131 , L1125 , RLVECT_1:4;
end;
L1133:
now
reconsider D167 = D158 as (Subset of R51) by L205;
L1134: D167 is  linearly-closed by L241;
assume L1135: ( D165 + D162 ) in D158;
L1136: ( ( D162 + D165 ) - D165 ) in D158 by L1135 , L1134 , L149;
L1137: ( D162 + ( D165 - D165 ) ) in D158 by L1136 , RLVECT_1:def 3;
L1138: ( D162 + ( 0. R51 ) ) in D158 by L1137 , RLVECT_1:15;
thus L1139: contradiction by L1138 , L1121 , RLVECT_1:4;
end;
L1140: (D165 in D160 & D162 in D160) by L1116 , XBOOLE_0:def 3;
L1141: ( D165 + D162 ) in D160 by L1140 , L1122 , L137;
thus L1142: thesis by L1141 , L1116 , L1133 , L1126 , XBOOLE_0:def 3;
end;

L1143:
now
assume L1144: R53 is (Submodule of R54);
L1145: D158 c= D159 by L1144 , L205;
L1146: ( D158 \/ D159 ) = D159 by L1145 , XBOOLE_1:12;
thus L1147: thesis by L1146;
end;
L1148:
now
assume L1149: R54 is (Submodule of R53);
L1150: D159 c= D158 by L1149 , L205;
L1151: ( D158 \/ D159 ) = D158 by L1150 , XBOOLE_1:12;
thus L1152: thesis by L1151;
end;
assume L1153: (R53 is (Submodule of R54) or R54 is (Submodule of R53));
thus L1154: thesis by L1153 , L1143 , L1148;
end;
definition
let R51 being Z_Module;
func Submodules R51 -> set means
:L1155: (for R38 being set holds (R38 in it iff R38 is  strict  strict  strict  strict (Submodule of R51)));
existence
proof
defpred S3[ set , set ] means (ex B95 being  strict (Submodule of R51) st ($2 = B95 & $1 = (the carrier of B95)));
defpred S4[ set ] means (ex B96 being  strict (Submodule of R51) st $1 = (the carrier of B96));
consider C140 being set such that L1156: (for R38 being set holds (R38 in C140 iff (R38 in ( bool (the carrier of R51) ) & S4[ R38 ]))) from XBOOLE_0:sch 1;
L1157: (for R38 being set holds (for R68 being set holds (for R69 being set holds ((S3[ R38 , R68 ] & S3[ R38 , R69 ]) implies R68 = R69)))) by L365;
consider C141 being Function such that L1158: (for R38 being set holds (for R67 being set holds ([ R38 , R67 ] in C141 iff (R38 in C140 & S3[ R38 , R67 ])))) from FUNCT_1:sch 1(L1157);
L1159: (for R38 being set holds (R38 in C140 iff (ex R67 being set st [ R38 , R67 ] in C141)))
proof
let R38 being set;
thus L1160: (R38 in C140 implies (ex R67 being set st [ R38 , R67 ] in C141))
proof
assume L1161: R38 in C140;
consider C142 being  strict (Submodule of R51) such that L1162: R38 = (the carrier of C142) by L1161 , L1156;
reconsider D168 = C142 as set;
take D168;
thus L1163: thesis by L1158 , L1161 , L1162;
end;

given R67 being set such that
L1164: [ R38 , R67 ] in C141;

thus L1165: thesis by L1158 , L1164;
end;
L1166: C140 = ( dom C141 ) by L1159 , XTUPLE_0:def 12;
L1167: (for R67 being set holds (R67 in ( rng C141 ) iff R67 is  strict  strict  strict  strict (Submodule of R51)))
proof
let R67 being set;
thus L1168: (R67 in ( rng C141 ) implies R67 is  strict  strict  strict  strict (Submodule of R51))
proof
assume L1169: R67 in ( rng C141 );
consider R38 being set such that L1170: (R38 in ( dom C141 ) & R67 = ( C141 . R38 )) by L1169 , FUNCT_1:def 3;
L1171: [ R38 , R67 ] in C141 by L1170 , FUNCT_1:def 2;
L1172: (ex B97 being  strict (Submodule of R51) st (R67 = B97 & R38 = (the carrier of B97))) by L1171 , L1158;
thus L1173: thesis by L1172;
end;

assume L1174: R67 is  strict  strict  strict  strict (Submodule of R51);
reconsider D169 = R67 as  strict (Submodule of R51) by L1174;
reconsider D170 = (the carrier of D169) as set;
L1175: (the carrier of D169) c= (the carrier of R51) by L205;
L1176: D170 in ( dom C141 ) by L1175 , L1156 , L1166;
L1177: [ D170 , R67 ] in C141 by L1176 , L1158 , L1166;
L1178: R67 = ( C141 . D170 ) by L1177 , L1176 , FUNCT_1:def 2;
thus L1179: thesis by L1178 , L1176 , FUNCT_1:def 3;
end;
thus L1180: thesis by L1167;
end;
uniqueness
proof
let C143 , C144 being set;
assume L1181: (for R38 being set holds (R38 in C143 iff R38 is  strict  strict  strict  strict (Submodule of R51)));
assume L1182: (for R38 being set holds (R38 in C144 iff R38 is  strict  strict  strict  strict (Submodule of R51)));
L1183:
now
let R38 being set;
thus L1184: (R38 in C143 implies R38 in C144)
proof
assume L1185: R38 in C143;
L1186: R38 is  strict  strict  strict  strict (Submodule of R51) by L1185 , L1181;
thus L1187: thesis by L1186 , L1182;
end;

assume L1188: R38 in C144;
L1189: R38 is  strict  strict  strict  strict (Submodule of R51) by L1188 , L1182;
thus L1190: R38 in C143 by L1189 , L1181;
end;
thus L1191: thesis by L1183 , TARSKI:1;
end;
end;
registration
let R51 being Z_Module;
cluster ( Submodules R51 ) -> non  empty;
coherence
proof
set D171 = the  strict (Submodule of R51);
L1193: D171 in ( Submodules R51 ) by L1155;
thus L1194: thesis by L1193;
end;
end;
theorem
L1196: (for B98 being  strict Z_Module holds B98 in ( Submodules B98 ))
proof
let C145 being  strict Z_Module;
L1197: ( (Omega). C145 ) in ( Submodules C145 ) by L1155;
thus L1198: thesis by L1197;
end;
definition
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
pred R51 is_the_direct_sum_of R53 , R54
means
:L1199: (( the Z_ModuleStruct of R51 ) = ( R53 + R54 ) & ( R53 /\ R54 ) = ( (0). R51 ))
;end;
L1201: (for B99 being Z_Module holds (for B100 being  strict (Submodule of B99) holds ((for B101 being (VECTOR of B99) holds B101 in B100) implies B100 = ( the Z_ModuleStruct of B99 ))))
proof
let C146 being Z_Module;
let C147 being  strict (Submodule of C146);
assume L1202: (for B102 being (VECTOR of C146) holds B102 in C147);
L1203: (for B103 being (VECTOR of C146) holds (B103 in C147 iff B103 in ( (Omega). C146 ))) by L1202 , RLVECT_1:1;
thus L1204: thesis by L1203 , L369;
end;
L1205: (for B104 being Z_Module holds (for B105 , B106 being (Submodule of B104) holds (( B105 + B106 ) = ( the Z_ModuleStruct of B104 ) iff (for B107 being (VECTOR of B104) holds (ex B108 , B109 being (VECTOR of B104) st (B108 in B105 & B109 in B106 & B107 = ( B108 + B109 )))))))
proof
let C148 being Z_Module;
let C149 , C150 being (Submodule of C148);
thus L1206: (( C149 + C150 ) = ( the Z_ModuleStruct of C148 ) implies (for B110 being (VECTOR of C148) holds (ex B111 , B112 being (VECTOR of C148) st (B111 in C149 & B112 in C150 & B110 = ( B111 + B112 )))))
proof
assume L1207: ( C149 + C150 ) = ( the Z_ModuleStruct of C148 );
let C151 being (VECTOR of C148);
L1208: C151 in ( the Z_ModuleStruct of C148 ) by RLVECT_1:1;
thus L1209: thesis by L1208 , L1207 , L874;
end;

assume L1210: (for B113 being (VECTOR of C148) holds (ex B114 , B115 being (VECTOR of C148) st (B114 in C149 & B115 in C150 & B113 = ( B114 + B115 ))));
L1211:
now
let C152 being (VECTOR of C148);
L1212: (ex B116 , B117 being (VECTOR of C148) st (B116 in C149 & B117 in C150 & C152 = ( B116 + B117 ))) by L1210;
thus L1213: C152 in ( C149 + C150 ) by L1212 , L874;
end;
thus L1214: thesis by L1211 , L1201;
end;
definition
let C153 being Z_Module;
let C154 being (Submodule of C153);
attr C154 is  with_Linear_Compl
means
:L1215: (ex B118 being (Submodule of C153) st C153 is_the_direct_sum_of B118 , C154);
end;
registration
let C155 being Z_Module;
cluster  with_Linear_Compl for (Submodule of C155);
correctness
proof
L1217: (( ( (0). C155 ) + ( (Omega). C155 ) ) = ( the Z_ModuleStruct of C155 ) & ( (0). C155 ) = ( ( (0). C155 ) /\ ( (Omega). C155 ) )) by L966 , L994;
L1218: C155 is_the_direct_sum_of ( (0). C155 ) , ( (Omega). C155 ) by L1217 , L1199;
L1219: ( (Omega). C155 ) is  with_Linear_Compl by L1218 , L1215;
thus L1220: thesis by L1219;
end;
end;
definition
let C156 being Z_Module;
let C157 being (Submodule of C156);
assume L1222: C157 is  with_Linear_Compl;
mode Linear_Compl of C157
 -> (Submodule of C156)
means :L1223: C156 is_the_direct_sum_of it , C157;
existence by L1222 , L1215;
end;
L1225: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (R51 is_the_direct_sum_of R53 , R54 implies R51 is_the_direct_sum_of R54 , R53))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
assume L1226: R51 is_the_direct_sum_of R53 , R54;
L1227: ( R54 /\ R53 ) = ( (0). R51 ) by L1226 , L1199;
L1228: ( the Z_ModuleStruct of R51 ) = ( R53 + R54 ) by L1226 , L1199;
thus L1229: thesis by L1228 , L1227 , L1199;
end;
theorem
L1230: (for B119 being Z_Module holds (for B120 , B121 being (Submodule of B119) holds (B119 is_the_direct_sum_of B120 , B121 implies B121 is (Linear_Compl of B120))))
proof
let C158 being Z_Module;
let C159 , C160 being (Submodule of C158);
assume L1231: C158 is_the_direct_sum_of C159 , C160;
L1232: C158 is_the_direct_sum_of C160 , C159 by L1231 , L1225;
L1233: C159 is  with_Linear_Compl by L1232 , L1215;
thus L1234: thesis by L1233 , L1223 , L1232;
end;
theorem
L1235: (for B122 being Z_Module holds (for B123 being  with_Linear_Compl (Submodule of B122) holds (for B124 being (Linear_Compl of B123) holds (B122 is_the_direct_sum_of B124 , B123 & B122 is_the_direct_sum_of B123 , B124))))
proof
let C161 being Z_Module;
let C162 being  with_Linear_Compl (Submodule of C161);
let C163 being (Linear_Compl of C162);
thus L1236: C161 is_the_direct_sum_of C163 , C162 by L1223;
thus L1237: thesis by L1236 , L1225;
end;
theorem
L1238: (for B125 being Z_Module holds (for B126 being  with_Linear_Compl (Submodule of B125) holds (for B127 being (Linear_Compl of B126) holds ( B126 + B127 ) = ( the Z_ModuleStruct of B125 ))))
proof
let C164 being Z_Module;
let C165 being  with_Linear_Compl (Submodule of C164);
let C166 being (Linear_Compl of C165);
L1239: C164 is_the_direct_sum_of C165 , C166 by L1235;
thus L1240: ( C165 + C166 ) = ( the Z_ModuleStruct of C164 ) by L1239 , L1199;
end;
theorem
L1241: (for B128 being Z_Module holds (for B129 being  with_Linear_Compl (Submodule of B128) holds (for B130 being (Linear_Compl of B129) holds ( B129 /\ B130 ) = ( (0). B128 ))))
proof
let C167 being Z_Module;
let C168 being  with_Linear_Compl (Submodule of C167);
let C169 being (Linear_Compl of C168);
L1242: C167 is_the_direct_sum_of C168 , C169 by L1235;
thus L1243: ( C168 /\ C169 ) = ( (0). C167 ) by L1242 , L1199;
end;
theorem
L1244: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (R51 is_the_direct_sum_of R53 , R54 implies R51 is_the_direct_sum_of R54 , R53)))) by L1225;
theorem
L1245: (for B131 being Z_Module holds (for B132 being  with_Linear_Compl (Submodule of B131) holds (for B133 being (Linear_Compl of B132) holds B132 is (Linear_Compl of B133))))
proof
let C170 being Z_Module;
let C171 being  with_Linear_Compl (Submodule of C170);
let C172 being (Linear_Compl of C171);
L1246: C170 is_the_direct_sum_of C172 , C171 by L1223;
L1247: C170 is_the_direct_sum_of C171 , C172 by L1246 , L1225;
L1248: C172 is  with_Linear_Compl by L1247 , L1215;
thus L1249: thesis by L1248 , L1223 , L1247;
end;
theorem
L1250: (for B134 being Z_Module holds (B134 is_the_direct_sum_of ( (0). B134 ) , ( (Omega). B134 ) & B134 is_the_direct_sum_of ( (Omega). B134 ) , ( (0). B134 )))
proof
let C173 being Z_Module;
L1251: (( ( (0). C173 ) + ( (Omega). C173 ) ) = ( the Z_ModuleStruct of C173 ) & ( (0). C173 ) = ( ( (0). C173 ) /\ ( (Omega). C173 ) )) by L966 , L994;
thus L1252: C173 is_the_direct_sum_of ( (0). C173 ) , ( (Omega). C173 ) by L1251 , L1199;
thus L1253: thesis by L1251 , L1199;
end;
theorem
L1254: (for B135 being Z_Module holds (( (0). B135 ) is (Linear_Compl of ( (Omega). B135 )) & ( (Omega). B135 ) is (Linear_Compl of ( (0). B135 ))))
proof
let C174 being Z_Module;
L1255: (C174 is_the_direct_sum_of ( (0). C174 ) , ( (Omega). C174 ) & C174 is_the_direct_sum_of ( (Omega). C174 ) , ( (0). C174 )) by L1250;
L1256: ( (Omega). C174 ) is  with_Linear_Compl by L1255 , L1215;
L1257: ( (0). C174 ) is  with_Linear_Compl by L1255 , L1215;
thus L1258: thesis by L1257 , L1223 , L1255 , L1256;
end;
theorem
L1259: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R71 being (Coset of R53) holds (for R72 being (Coset of R54) holds (R71 meets R72 implies ( R71 /\ R72 ) is (Coset of ( R53 /\ R54 ))))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R71 being (Coset of R53);
let R72 being (Coset of R54);
set D172 = the (Element of ( R71 /\ R72 ));
set D173 = ( R71 /\ R72 );
assume L1260: ( R71 /\ R72 ) <> ( {} );
reconsider D174 = D172 as (Element of R51) by L1260 , TARSKI:def 3;
L1261: D174 in R72 by L1260 , XBOOLE_0:def 4;
L1262: R72 = ( D174 + R54 ) by L1261 , L804;
L1263: D174 in R71 by L1260 , XBOOLE_0:def 4;
L1264: R71 = ( D174 + R53 ) by L1263 , L804;
L1265: D173 is (Coset of ( R53 /\ R54 ))
proof
take D174;
thus L1266: D173 c= ( D174 + ( R53 /\ R54 ) )
proof
let R38 being set;
assume L1267: R38 in D173;
L1268: R38 in R71 by L1267 , XBOOLE_0:def 4;
consider R57 being (VECTOR of R51) such that L1269: R57 in R53 and L1270: R38 = ( D174 + R57 ) by L1268 , L1264 , L668;
L1271: R38 in R72 by L1267 , XBOOLE_0:def 4;
consider R58 being (VECTOR of R51) such that L1272: R58 in R54 and L1273: R38 = ( D174 + R58 ) by L1271 , L1262 , L668;
L1274: R57 = R58 by L1270 , L1273 , RLVECT_1:8;
L1275: R57 in ( R53 /\ R54 ) by L1274 , L1269 , L1272 , L896;
thus L1276: thesis by L1275 , L1270;
end;

let R38 being set;
assume L1277: R38 in ( D174 + ( R53 /\ R54 ) );
consider R56 being (VECTOR of R51) such that L1278: R56 in ( R53 /\ R54 ) and L1279: R38 = ( D174 + R56 ) by L1277 , L668;
L1280: R56 in R54 by L1278 , L896;
L1281: R38 in { ( D174 + R58 ) where R58 is (VECTOR of R51) : R58 in R54 } by L1280 , L1279;
L1282: R56 in R53 by L1278 , L896;
L1283: R38 in { ( D174 + R57 ) where R57 is (VECTOR of R51) : R57 in R53 } by L1282 , L1279;
thus L1284: thesis by L1283 , L1264 , L1262 , L1281 , XBOOLE_0:def 4;
end;
thus L1285: thesis by L1265;
end;
L1286: (for R51 being Z_Module holds (for R52 being (Submodule of R51) holds (for R59 being (VECTOR of R51) holds (ex R70 being (Coset of R52) st R59 in R70))))
proof
let R51 being Z_Module;
let R52 being (Submodule of R51);
let R59 being (VECTOR of R51);
reconsider D175 = ( R59 + R52 ) as (Coset of R52) by L503;
take D175;
thus L1287: thesis by L517;
end;
theorem
L1288: (for B136 being Z_Module holds (for B137 , B138 being (Submodule of B136) holds (B136 is_the_direct_sum_of B137 , B138 iff (for B139 being (Coset of B137) holds (for B140 being (Coset of B138) holds (ex B141 being (VECTOR of B136) st ( B139 /\ B140 ) = { B141 }))))))
proof
let C175 being Z_Module;
let C176 , C177 being (Submodule of C175);
set D176 = (the carrier of C176);
set D177 = (the carrier of C177);
L1289: ( 0. C175 ) in C177 by L253;
L1290: ( 0. C175 ) in D177 by L1289 , STRUCT_0:def 5;
thus L1291: (C175 is_the_direct_sum_of C176 , C177 implies (for B142 being (Coset of C176) holds (for B143 being (Coset of C177) holds (ex B144 being (VECTOR of C175) st ( B142 /\ B143 ) = { B144 }))))
proof
assume L1292: C175 is_the_direct_sum_of C176 , C177;
L1293: ( the Z_ModuleStruct of C175 ) = ( C176 + C177 ) by L1292 , L1199;
let C178 being (Coset of C176);
let C179 being (Coset of C177);
consider C180 being (VECTOR of C175) such that L1294: C178 = ( C180 + C176 ) by L503;
L1295: C180 in ( the Z_ModuleStruct of C175 ) by RLVECT_1:1;
consider C181 , C182 being (VECTOR of C175) such that L1296: C181 in C176 and L1297: C182 in C177 and L1298: C180 = ( C181 + C182 ) by L1295 , L1293 , L874;
consider C183 being (VECTOR of C175) such that L1299: C179 = ( C183 + C177 ) by L503;
L1300: C183 in ( the Z_ModuleStruct of C175 ) by RLVECT_1:1;
consider C184 , C185 being (VECTOR of C175) such that L1301: C184 in C176 and L1302: C185 in C177 and L1303: C183 = ( C184 + C185 ) by L1300 , L1293 , L874;
take D178 = ( C182 + C184 );
L1304: { D178 } = ( C178 /\ C179 )
proof
thus L1305: { D178 } c= ( C178 /\ C179 )
proof
let R38 being set;
assume L1306: R38 in { D178 };
L1307: R38 = D178 by L1306 , TARSKI:def 1;
L1308: C184 = ( C183 - C185 ) by L1303 , RLSUB_2:61;
L1309: C184 in C179 by L1308 , L1299 , L1302 , L675;
L1310: C179 = ( C184 + C177 ) by L1309 , L804;
L1311: R38 in C179 by L1310 , L1297 , L1307;
L1312: C182 = ( C180 - C181 ) by L1298 , RLSUB_2:61;
L1313: C182 in C178 by L1312 , L1294 , L1296 , L675;
L1314: C178 = ( C182 + C176 ) by L1313 , L804;
L1315: R38 in C178 by L1314 , L1301 , L1307;
thus L1316: thesis by L1315 , L1311 , XBOOLE_0:def 4;
end;

let R38 being set;
assume L1317: R38 in ( C178 /\ C179 );
L1318: C178 meets C179 by L1317 , XBOOLE_0:4;
reconsider D179 = ( C178 /\ C179 ) as (Coset of ( C176 /\ C177 )) by L1318 , L1259;
L1319: D178 in { D178 } by TARSKI:def 1;
L1320: ( C176 /\ C177 ) = ( (0). C175 ) by L1292 , L1199;
L1321: (ex B145 being (VECTOR of C175) st D179 = { B145 }) by L1320 , L786;
thus L1322: thesis by L1321 , L1305 , L1317 , L1319 , TARSKI:def 1;
end;
thus L1323: thesis by L1304;
end;

assume L1324: (for B146 being (Coset of C176) holds (for B147 being (Coset of C177) holds (ex B148 being (VECTOR of C175) st ( B146 /\ B147 ) = { B148 })));
L1325: D177 is (Coset of C177) by L790;
L1326:
now
let C186 being (VECTOR of C175);
consider C187 being (Coset of C176) such that L1327: C186 in C187 by L1286;
consider C188 being (VECTOR of C175) such that L1328: ( C187 /\ D177 ) = { C188 } by L1325 , L1324;
L1329: C188 in { C188 } by TARSKI:def 1;
L1330: C188 in C187 by L1329 , L1328 , XBOOLE_0:def 4;
consider C189 being (VECTOR of C175) such that L1331: C189 in C176 and L1332: ( C186 - C189 ) = C188 by L1330 , L1327 , L814;
L1333: C188 in D177 by L1328 , L1329 , XBOOLE_0:def 4;
L1334: C188 in C177 by L1333 , STRUCT_0:def 5;
L1335: C186 = ( C189 + C188 ) by L1332 , RLSUB_2:61;
thus L1336: C186 in ( C176 + C177 ) by L1335 , L1334 , L1331 , L874;
end;
thus L1337: ( the Z_ModuleStruct of C175 ) = ( C176 + C177 ) by L1326 , L1201;
L1338: D176 is (Coset of C176) by L790;
consider C190 being (VECTOR of C175) such that L1339: ( D176 /\ D177 ) = { C190 } by L1338 , L1325 , L1324;
L1340: ( 0. C175 ) in C176 by L253;
L1341: ( 0. C175 ) in D176 by L1340 , STRUCT_0:def 5;
L1342: ( 0. C175 ) in { C190 } by L1341 , L1339 , L1290 , XBOOLE_0:def 4;
L1343: (the carrier of ( (0). C175 )) = { ( 0. C175 ) } by L435
.= ( D176 /\ D177 ) by L1339 , L1342 , TARSKI:def 1
.= (the carrier of ( C176 /\ C177 )) by L862;
thus L1344: thesis by L1343 , L365;
end;
theorem
L1345: (for B149 being Z_Module holds (for B150 , B151 being (Submodule of B149) holds (( B150 + B151 ) = ( the Z_ModuleStruct of B149 ) iff (for B152 being (VECTOR of B149) holds (ex B153 , B154 being (VECTOR of B149) st (B153 in B150 & B154 in B151 & B152 = ( B153 + B154 ))))))) by L1205;
theorem
L1346: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R57 being (VECTOR of R51) holds (for R58 being (VECTOR of R51) holds (for R60 being (VECTOR of R51) holds (for R61 being (VECTOR of R51) holds ((R51 is_the_direct_sum_of R53 , R54 & ( R60 + R61 ) = ( R57 + R58 ) & R60 in R53 & R57 in R53 & R61 in R54 & R58 in R54) implies (R60 = R57 & R61 = R58)))))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R57 being (VECTOR of R51);
let R58 being (VECTOR of R51);
let R60 being (VECTOR of R51);
let R61 being (VECTOR of R51);
reconsider D180 = ( R60 + R54 ) as (Coset of R54) by L503;
reconsider D181 = (the carrier of R53) as (Coset of R53) by L790;
L1347: R60 in D180 by L517;
assume L1348: R51 is_the_direct_sum_of R53 , R54;
consider C191 being (VECTOR of R51) such that L1349: ( D181 /\ D180 ) = { C191 } by L1348 , L1288;
assume that
L1350: ( R60 + R61 ) = ( R57 + R58 )
and
L1351: R60 in R53
and
L1352: R57 in R53
and
L1353: (R61 in R54 & R58 in R54);
L1354: ( R61 - R58 ) in R54 by L1353 , L276;
L1355: R60 in D181 by L1351 , STRUCT_0:def 5;
L1356: R60 in ( D181 /\ D180 ) by L1355 , L1347 , XBOOLE_0:def 4;
L1357: R60 = C191 by L1356 , L1349 , TARSKI:def 1;
L1358: R57 = ( ( R60 + R61 ) - R58 ) by L1350 , RLSUB_2:61
.= ( R60 + ( R61 - R58 ) ) by RLVECT_1:def 3;
L1359: R57 in D180 by L1358 , L1354;
L1360: R57 in D181 by L1352 , STRUCT_0:def 5;
L1361: R57 in ( D181 /\ D180 ) by L1360 , L1359 , XBOOLE_0:def 4;
thus L1362: R60 = R57 by L1361 , L1349 , L1357 , TARSKI:def 1;
L1363: R57 = C191 by L1361 , L1349 , TARSKI:def 1;
thus L1364: thesis by L1363 , L1350 , L1357 , RLVECT_1:8;
end;
theorem
L1365: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R51 = ( R53 + R54 ) & (ex R59 being (VECTOR of R51) st (for R60 being (VECTOR of R51) holds (for R61 being (VECTOR of R51) holds (for R57 being (VECTOR of R51) holds (for R58 being (VECTOR of R51) holds ((( R60 + R61 ) = ( R57 + R58 ) & R60 in R53 & R57 in R53 & R61 in R54 & R58 in R54) implies (R60 = R57 & R61 = R58)))))))) implies R51 is_the_direct_sum_of R53 , R54))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
assume L1366: R51 = ( R53 + R54 );
L1367: ((the carrier of ( (0). R51 )) = { ( 0. R51 ) } & ( (0). R51 ) is (Submodule of ( R53 /\ R54 ))) by L468 , L435;
L1368: { ( 0. R51 ) } c= (the carrier of ( R53 /\ R54 )) by L1367 , L205;
given R59 being (VECTOR of R51) such that
L1369: (for R60 being (VECTOR of R51) holds (for R61 being (VECTOR of R51) holds (for R57 being (VECTOR of R51) holds (for R58 being (VECTOR of R51) holds ((( R60 + R61 ) = ( R57 + R58 ) & R60 in R53 & R57 in R53 & R61 in R54 & R58 in R54) implies (R60 = R57 & R61 = R58))))));

assume L1370: (not thesis);
L1371: ( R53 /\ R54 ) <> ( (0). R51 ) by L1370 , L1366 , L1199;
L1372: (the carrier of ( R53 /\ R54 )) <> { ( 0. R51 ) } by L1371 , L435;
L1373: { ( 0. R51 ) } c< (the carrier of ( R53 /\ R54 )) by L1372 , L1368 , XBOOLE_0:def 8;
consider R38 being set such that L1374: R38 in (the carrier of ( R53 /\ R54 )) and L1375: (not R38 in { ( 0. R51 ) }) by L1373 , XBOOLE_0:6;
L1376: R38 <> ( 0. R51 ) by L1375 , TARSKI:def 1;
L1377: R38 in ( R53 /\ R54 ) by L1374 , STRUCT_0:def 5;
L1378: R38 in R51 by L1377 , L213;
reconsider D182 = R38 as (VECTOR of R51) by L1378 , STRUCT_0:def 5;
consider R60 being (VECTOR of R51), R61 being (VECTOR of R51) such that L1379: R60 in R53 and L1380: R61 in R54 and L1381: R59 = ( R60 + R61 ) by L1366 , L1205;
L1382: R59 = ( ( R60 + R61 ) + ( 0. R51 ) ) by L1381 , RLVECT_1:4
.= ( ( R60 + R61 ) + ( D182 - D182 ) ) by RLVECT_1:15
.= ( ( ( R60 + R61 ) + D182 ) - D182 ) by RLVECT_1:def 3
.= ( ( ( R60 + D182 ) + R61 ) - D182 ) by RLVECT_1:def 3
.= ( ( R60 + D182 ) + ( R61 - D182 ) ) by RLVECT_1:def 3;
L1383: R38 in R54 by L1377 , L896;
L1384: ( R61 - D182 ) in R54 by L1383 , L1380 , L276;
L1385: R38 in R53 by L1377 , L896;
L1386: ( R60 + D182 ) in R53 by L1385 , L1379 , L260;
L1387: ( R61 - D182 ) = R61 by L1386 , L1369 , L1379 , L1380 , L1381 , L1382 , L1384
.= ( R61 - ( 0. R51 ) ) by RLVECT_1:13;
thus L1388: thesis by L1387 , L1376 , RLVECT_1:23;
end;
definition
let R51 being Z_Module;
let R59 being (VECTOR of R51);
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
assume L1389: R51 is_the_direct_sum_of R53 , R54;
func R59 |-- (R53 , R54) -> (Element of [: (the carrier of R51) , (the carrier of R51) :]) means
:L1390: (R59 = ( ( it `1 ) + ( it `2 ) ) & ( it `1 ) in R53 & ( it `2 ) in R54);
existence
proof
L1391: ( R53 + R54 ) = ( the Z_ModuleStruct of R51 ) by L1389 , L1199;
consider R60 being (VECTOR of R51), R61 being (VECTOR of R51) such that L1392: (R60 in R53 & R61 in R54 & R59 = ( R60 + R61 )) by L1391 , L1205;
take [ R60 , R61 ];
L1393: ( [ R60 , R61 ] `1 ) = R60 by MCART_1:7;
thus L1394: thesis by L1393 , L1392 , MCART_1:7;
end;
uniqueness
proof
let C192 , C193 being (Element of [: (the carrier of R51) , (the carrier of R51) :]);
assume L1395: (R59 = ( ( C192 `1 ) + ( C192 `2 ) ) & ( C192 `1 ) in R53 & ( C192 `2 ) in R54 & R59 = ( ( C193 `1 ) + ( C193 `2 ) ) & ( C193 `1 ) in R53 & ( C193 `2 ) in R54);
L1396: (( C192 `1 ) = ( C193 `1 ) & ( C192 `2 ) = ( C193 `2 )) by L1395 , L1389 , L1346;
L1397: C192 = [ ( C192 `1 ) , ( C192 `2 ) ] by MCART_1:21;
thus L1398: thesis by L1397 , L1396 , MCART_1:21;
end;
end;
theorem
L1400: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R59 being (VECTOR of R51) holds (R51 is_the_direct_sum_of R53 , R54 implies ( ( R59 |-- (R53 , R54) ) `1 ) = ( ( R59 |-- (R54 , R53) ) `2 ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R59 being (VECTOR of R51);
assume L1401: R51 is_the_direct_sum_of R53 , R54;
L1402: ( ( R59 |-- (R53 , R54) ) `2 ) in R54 by L1401 , L1390;
L1403: R51 is_the_direct_sum_of R54 , R53 by L1401 , L1225;
L1404: (R59 = ( ( ( R59 |-- (R54 , R53) ) `2 ) + ( ( R59 |-- (R54 , R53) ) `1 ) ) & ( ( R59 |-- (R54 , R53) ) `1 ) in R54) by L1403 , L1390;
L1405: ( ( R59 |-- (R54 , R53) ) `2 ) in R53 by L1403 , L1390;
L1406: (R59 = ( ( ( R59 |-- (R53 , R54) ) `1 ) + ( ( R59 |-- (R53 , R54) ) `2 ) ) & ( ( R59 |-- (R53 , R54) ) `1 ) in R53) by L1401 , L1390;
thus L1407: thesis by L1406 , L1401 , L1402 , L1404 , L1405 , L1346;
end;
theorem
L1408: (for R51 being Z_Module holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (for R59 being (VECTOR of R51) holds (R51 is_the_direct_sum_of R53 , R54 implies ( ( R59 |-- (R53 , R54) ) `2 ) = ( ( R59 |-- (R54 , R53) ) `1 ))))))
proof
let R51 being Z_Module;
let R53 being (Submodule of R51);
let R54 being (Submodule of R51);
let R59 being (VECTOR of R51);
assume L1409: R51 is_the_direct_sum_of R53 , R54;
L1410: ( ( R59 |-- (R53 , R54) ) `2 ) in R54 by L1409 , L1390;
L1411: R51 is_the_direct_sum_of R54 , R53 by L1409 , L1225;
L1412: (R59 = ( ( ( R59 |-- (R54 , R53) ) `2 ) + ( ( R59 |-- (R54 , R53) ) `1 ) ) & ( ( R59 |-- (R54 , R53) ) `1 ) in R54) by L1411 , L1390;
L1413: ( ( R59 |-- (R54 , R53) ) `2 ) in R53 by L1411 , L1390;
L1414: (R59 = ( ( ( R59 |-- (R53 , R54) ) `1 ) + ( ( R59 |-- (R53 , R54) ) `2 ) ) & ( ( R59 |-- (R53 , R54) ) `1 ) in R53) by L1409 , L1390;
thus L1415: thesis by L1414 , L1409 , L1410 , L1412 , L1413 , L1346;
end;
theorem
L1416: (for B155 being Z_Module holds (for B156 being  with_Linear_Compl (Submodule of B155) holds (for B157 being (Linear_Compl of B156) holds (for B158 being (VECTOR of B155) holds (for B159 being (Element of [: (the carrier of B155) , (the carrier of B155) :]) holds ((( ( B159 `1 ) + ( B159 `2 ) ) = B158 & ( B159 `1 ) in B156 & ( B159 `2 ) in B157) implies B159 = ( B158 |-- (B156 , B157) )))))))
proof
let C194 being Z_Module;
let C195 being  with_Linear_Compl (Submodule of C194);
let C196 being (Linear_Compl of C195);
L1417: C194 is_the_direct_sum_of C195 , C196 by L1235;
thus L1418: thesis by L1417 , L1390;
end;
theorem
L1419: (for B160 being Z_Module holds (for B161 being  with_Linear_Compl (Submodule of B160) holds (for B162 being (Linear_Compl of B161) holds (for B163 being (VECTOR of B160) holds ( ( ( B163 |-- (B161 , B162) ) `1 ) + ( ( B163 |-- (B161 , B162) ) `2 ) ) = B163))))
proof
let C197 being Z_Module;
let C198 being  with_Linear_Compl (Submodule of C197);
let C199 being (Linear_Compl of C198);
L1420: C197 is_the_direct_sum_of C198 , C199 by L1235;
thus L1421: thesis by L1420 , L1390;
end;
theorem
L1422: (for B164 being Z_Module holds (for B165 being  with_Linear_Compl (Submodule of B164) holds (for B166 being (Linear_Compl of B165) holds (for B167 being (VECTOR of B164) holds (( ( B167 |-- (B165 , B166) ) `1 ) in B165 & ( ( B167 |-- (B165 , B166) ) `2 ) in B166)))))
proof
let C200 being Z_Module;
let C201 being  with_Linear_Compl (Submodule of C200);
let C202 being (Linear_Compl of C201);
L1423: C200 is_the_direct_sum_of C201 , C202 by L1235;
thus L1424: thesis by L1423 , L1390;
end;
theorem
L1425: (for B168 being Z_Module holds (for B169 being  with_Linear_Compl (Submodule of B168) holds (for B170 being (Linear_Compl of B169) holds (for B171 being (VECTOR of B168) holds ( ( B171 |-- (B169 , B170) ) `1 ) = ( ( B171 |-- (B170 , B169) ) `2 )))))
proof
let C203 being Z_Module;
let C204 being  with_Linear_Compl (Submodule of C203);
let C205 being (Linear_Compl of C204);
L1426: C203 is_the_direct_sum_of C204 , C205 by L1235;
thus L1427: thesis by L1426 , L1400;
end;
theorem
L1428: (for B172 being Z_Module holds (for B173 being  with_Linear_Compl (Submodule of B172) holds (for B174 being (Linear_Compl of B173) holds (for B175 being (VECTOR of B172) holds ( ( B175 |-- (B173 , B174) ) `2 ) = ( ( B175 |-- (B174 , B173) ) `1 )))))
proof
let C206 being Z_Module;
let C207 being  with_Linear_Compl (Submodule of C206);
let C208 being (Linear_Compl of C207);
L1429: C206 is_the_direct_sum_of C207 , C208 by L1235;
thus L1430: thesis by L1429 , L1408;
end;
definition
let R51 being Z_Module;
func SubJoin R51 -> (BinOp of ( Submodules R51 )) means
:L1431: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R73 = R53 & R74 = R54) implies ( it . (R73 , R74) ) = ( R53 + R54 ))))));
existence
proof
defpred S5[ (Element of ( Submodules R51 )) , (Element of ( Submodules R51 )) , (Element of ( Submodules R51 )) ] means (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (($1 = R53 & $2 = R54) implies $3 = ( R53 + R54 ))));
L1432: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (ex R75 being (Element of ( Submodules R51 )) st S5[ R73 , R74 , R75 ])))
proof
let R73 being (Element of ( Submodules R51 ));
let R74 being (Element of ( Submodules R51 ));
reconsider D183 = R73 , D184 = R74 as (Submodule of R51) by L1155;
reconsider D185 = ( D183 + D184 ) as (Element of ( Submodules R51 )) by L1155;
take D185;
thus L1433: thesis;
end;
L1434: (ex B176 being (BinOp of ( Submodules R51 )) st (for B177 , B178 being (Element of ( Submodules R51 )) holds S5[ B177 , B178 , ( B176 . (B177 , B178) ) ])) from BINOP_1:sch 3(L1432);
thus L1435: thesis by L1434;
end;
uniqueness
proof
let C209 , C210 being (BinOp of ( Submodules R51 ));
assume L1436: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R73 = R53 & R74 = R54) implies ( C209 . (R73 , R74) ) = ( R53 + R54 ))))));
assume L1437: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R73 = R53 & R74 = R54) implies ( C210 . (R73 , R74) ) = ( R53 + R54 ))))));
L1438:
now
let C211 , C212 being set;
assume L1439: (C211 in ( Submodules R51 ) & C212 in ( Submodules R51 ));
reconsider D186 = C211 , D187 = C212 as (Element of ( Submodules R51 )) by L1439;
reconsider D188 = C211 , D189 = C212 as (Submodule of R51) by L1439 , L1155;
L1440: ( C209 . (D186 , D187) ) = ( D188 + D189 ) by L1436;
thus L1441: ( C209 . (C211 , C212) ) = ( C210 . (C211 , C212) ) by L1440 , L1437;
end;
thus L1442: thesis by L1438 , BINOP_1:1;
end;
end;
definition
let R51 being Z_Module;
func SubMeet R51 -> (BinOp of ( Submodules R51 )) means
:L1444: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R73 = R53 & R74 = R54) implies ( it . (R73 , R74) ) = ( R53 /\ R54 ))))));
existence
proof
defpred S6[ (Element of ( Submodules R51 )) , (Element of ( Submodules R51 )) , (Element of ( Submodules R51 )) ] means (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds (($1 = R53 & $2 = R54) implies $3 = ( R53 /\ R54 ))));
L1445: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (ex R75 being (Element of ( Submodules R51 )) st S6[ R73 , R74 , R75 ])))
proof
let R73 being (Element of ( Submodules R51 ));
let R74 being (Element of ( Submodules R51 ));
reconsider D190 = R73 , D191 = R74 as (Submodule of R51) by L1155;
reconsider D192 = ( D190 /\ D191 ) as (Element of ( Submodules R51 )) by L1155;
take D192;
thus L1446: thesis;
end;
L1447: (ex B179 being (BinOp of ( Submodules R51 )) st (for B180 , B181 being (Element of ( Submodules R51 )) holds S6[ B180 , B181 , ( B179 . (B180 , B181) ) ])) from BINOP_1:sch 3(L1445);
thus L1448: thesis by L1447;
end;
uniqueness
proof
let C213 , C214 being (BinOp of ( Submodules R51 ));
assume L1449: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R73 = R53 & R74 = R54) implies ( C213 . (R73 , R74) ) = ( R53 /\ R54 ))))));
assume L1450: (for R73 being (Element of ( Submodules R51 )) holds (for R74 being (Element of ( Submodules R51 )) holds (for R53 being (Submodule of R51) holds (for R54 being (Submodule of R51) holds ((R73 = R53 & R74 = R54) implies ( C214 . (R73 , R74) ) = ( R53 /\ R54 ))))));
L1451:
now
let C215 , C216 being set;
assume L1452: (C215 in ( Submodules R51 ) & C216 in ( Submodules R51 ));
reconsider D193 = C215 , D194 = C216 as (Element of ( Submodules R51 )) by L1452;
reconsider D195 = C215 , D196 = C216 as (Submodule of R51) by L1452 , L1155;
L1453: ( C213 . (D193 , D194) ) = ( D195 /\ D196 ) by L1449;
thus L1454: ( C213 . (C215 , C216) ) = ( C214 . (C215 , C216) ) by L1453 , L1450;
end;
thus L1455: thesis by L1451 , BINOP_1:1;
end;
end;
theorem
L1457: (for R51 being Z_Module holds LattStr (# ( Submodules R51 ) , ( SubJoin R51 ) , ( SubMeet R51 ) #) is Lattice)
proof
let R51 being Z_Module;
set D197 = LattStr (# ( Submodules R51 ) , ( SubJoin R51 ) , ( SubMeet R51 ) #);
L1458: (for B182 , B183 being (Element of D197) holds ( B182 "/\" B183 ) = ( B183 "/\" B182 ))
proof
let C217 , C218 being (Element of D197);
reconsider D198 = C217 , D199 = C218 as (Submodule of R51) by L1155;
thus L1459: ( C217 "/\" C218 ) = ( D198 /\ D199 ) by L1444
.= ( C218 "/\" C217 ) by L1444;
end;
L1460: (for B184 , B185 being (Element of D197) holds ( ( B184 "/\" B185 ) "\/" B185 ) = B185)
proof
let C219 , C220 being (Element of D197);
reconsider D200 = C219 , D201 = C220 as  strict (Submodule of R51) by L1155;
reconsider D202 = ( D200 /\ D201 ) as (Element of D197) by L1155;
thus L1461: ( ( C219 "/\" C220 ) "\/" C220 ) = ( ( SubJoin R51 ) . (D202 , C220) ) by L1444
.= ( ( D200 /\ D201 ) + D201 ) by L1431
.= C220 by L1010 , L365;
end;
L1462: (for B186 , B187 , B188 being (Element of D197) holds ( B186 "\/" ( B187 "\/" B188 ) ) = ( ( B186 "\/" B187 ) "\/" B188 ))
proof
let C221 , C222 , C223 being (Element of D197);
reconsider D203 = C221 , D204 = C222 , D205 = C223 as (Submodule of R51) by L1155;
reconsider D206 = ( D203 + D204 ) , D207 = ( D204 + D205 ) as (Element of D197) by L1155;
thus L1463: ( C221 "\/" ( C222 "\/" C223 ) ) = ( ( SubJoin R51 ) . (C221 , D207) ) by L1431
.= ( D203 + ( D204 + D205 ) ) by L1431
.= ( ( D203 + D204 ) + D205 ) by L923
.= ( ( SubJoin R51 ) . (D206 , C223) ) by L1431
.= ( ( C221 "\/" C222 ) "\/" C223 ) by L1431;
end;
L1464: (for B189 , B190 being (Element of D197) holds ( B189 "/\" ( B189 "\/" B190 ) ) = B189)
proof
let C224 , C225 being (Element of D197);
reconsider D208 = C224 , D209 = C225 as  strict (Submodule of R51) by L1155;
reconsider D210 = ( D208 + D209 ) as (Element of D197) by L1155;
thus L1465: ( C224 "/\" ( C224 "\/" C225 ) ) = ( ( SubMeet R51 ) . (C224 , D210) ) by L1431
.= ( D208 /\ ( D208 + D209 ) ) by L1444
.= C224 by L1023 , L365;
end;
L1466: (for B191 , B192 , B193 being (Element of D197) holds ( B191 "/\" ( B192 "/\" B193 ) ) = ( ( B191 "/\" B192 ) "/\" B193 ))
proof
let C226 , C227 , C228 being (Element of D197);
reconsider D211 = C226 , D212 = C227 , D213 = C228 as (Submodule of R51) by L1155;
reconsider D214 = ( D211 /\ D212 ) , D215 = ( D212 /\ D213 ) as (Element of D197) by L1155;
thus L1467: ( C226 "/\" ( C227 "/\" C228 ) ) = ( ( SubMeet R51 ) . (C226 , D215) ) by L1444
.= ( D211 /\ ( D212 /\ D213 ) ) by L1444
.= ( ( D211 /\ D212 ) /\ D213 ) by L978
.= ( ( SubMeet R51 ) . (D214 , C228) ) by L1444
.= ( ( C226 "/\" C227 ) "/\" C228 ) by L1444;
end;
L1468: (for B194 , B195 being (Element of D197) holds ( B194 "\/" B195 ) = ( B195 "\/" B194 ))
proof
let C229 , C230 being (Element of D197);
reconsider D216 = C229 , D217 = C230 as (Submodule of R51) by L1155;
thus L1469: ( C229 "\/" C230 ) = ( D216 + D217 ) by L1431
.= ( C230 "\/" C229 ) by L1431;
end;
L1470: D197 is  join-commutative  join-associative  meet-absorbing  meet-commutative  meet-associative  join-absorbing by L1468 , L1462 , L1460 , L1458 , L1466 , L1464 , LATTICES:def 4 , LATTICES:def 5 , LATTICES:def 6 , LATTICES:def 7 , LATTICES:def 8 , LATTICES:def 9;
thus L1471: thesis by L1470;
end;
registration
let R51 being Z_Module;
cluster LattStr (# ( Submodules R51 ) , ( SubJoin R51 ) , ( SubMeet R51 ) #) ->  Lattice-like;
coherence by L1457;
end;
theorem
L1473: (for B196 being Z_Module holds LattStr (# ( Submodules B196 ) , ( SubJoin B196 ) , ( SubMeet B196 ) #) is  lower-bounded)
proof
let C231 being Z_Module;
set D218 = LattStr (# ( Submodules C231 ) , ( SubJoin C231 ) , ( SubMeet C231 ) #);
L1474: (ex B197 being (Element of D218) st (for B198 being (Element of D218) holds (( B197 "/\" B198 ) = B197 & ( B198 "/\" B197 ) = B197)))
proof
reconsider D219 = ( (0). C231 ) as (Element of D218) by L1155;
take D219;
let C232 being (Element of D218);
reconsider D220 = C232 as (Submodule of C231) by L1155;
thus L1475: ( D219 "/\" C232 ) = ( ( (0). C231 ) /\ D220 ) by L1444
.= D219 by L994;
thus L1476: thesis by L1475;
end;
thus L1477: thesis by L1474 , LATTICES:def 13;
end;
theorem
L1478: (for B199 being Z_Module holds LattStr (# ( Submodules B199 ) , ( SubJoin B199 ) , ( SubMeet B199 ) #) is  upper-bounded)
proof
let C233 being Z_Module;
set D221 = LattStr (# ( Submodules C233 ) , ( SubJoin C233 ) , ( SubMeet C233 ) #);
L1479: (ex B200 being (Element of D221) st (for B201 being (Element of D221) holds (( B200 "\/" B201 ) = B200 & ( B201 "\/" B200 ) = B200)))
proof
reconsider D222 = ( (Omega). C233 ) as (Element of D221) by L1155;
take D222;
let C234 being (Element of D221);
reconsider D223 = C234 as (Submodule of C233) by L1155;
thus L1480: ( D222 "\/" C234 ) = ( ( (Omega). C233 ) + D223 ) by L1431
.= D222 by L971;
thus L1481: thesis by L1480;
end;
thus L1482: thesis by L1479 , LATTICES:def 14;
end;
theorem
L1483: (for B202 being Z_Module holds LattStr (# ( Submodules B202 ) , ( SubJoin B202 ) , ( SubMeet B202 ) #) is 01_Lattice)
proof
let C235 being Z_Module;
L1484: LattStr (# ( Submodules C235 ) , ( SubJoin C235 ) , ( SubMeet C235 ) #) is  lower-bounded  upper-bounded  lower-bounded  upper-bounded  lower-bounded  upper-bounded  lower-bounded  upper-bounded Lattice by L1473 , L1478;
thus L1485: thesis by L1484;
end;
theorem
L1486: (for B203 being Z_Module holds LattStr (# ( Submodules B203 ) , ( SubJoin B203 ) , ( SubMeet B203 ) #) is  modular)
proof
let C236 being Z_Module;
set D224 = LattStr (# ( Submodules C236 ) , ( SubJoin C236 ) , ( SubMeet C236 ) #);
L1487: (for B204 , B205 , B206 being (Element of D224) holds (B204 [= B206 implies ( B204 "\/" ( B205 "/\" B206 ) ) = ( ( B204 "\/" B205 ) "/\" B206 )))
proof
let C237 , C238 , C239 being (Element of D224);
reconsider D225 = C237 , D226 = C238 , D227 = C239 as  strict (Submodule of C236) by L1155;
assume L1488: C237 [= C239;
reconsider D228 = ( D225 + D226 ) as (Element of D224) by L1155;
reconsider D229 = ( D226 /\ D227 ) as (Element of D224) by L1155;
L1489: ( D225 + D227 ) = ( C237 "\/" C239 ) by L1431
.= D227 by L1488 , LATTICES:def 3;
L1490: D225 is (Submodule of D227) by L1489 , L960;
thus L1491: ( C237 "\/" ( C238 "/\" C239 ) ) = ( ( SubJoin C236 ) . (C237 , D229) ) by L1444
.= ( D225 + ( D226 /\ D227 ) ) by L1431
.= ( ( D225 + D226 ) /\ D227 ) by L1490 , L1104
.= ( ( SubMeet C236 ) . (D228 , C239) ) by L1444
.= ( ( C237 "\/" C238 ) "/\" C239 ) by L1431;
end;
thus L1492: thesis by L1487 , LATTICES:def 12;
end;
theorem
L1493: (for B207 being Z_Module holds (for B208 , B209 , B210 being  strict (Submodule of B207) holds (B208 is (Submodule of B209) implies ( B208 /\ B210 ) is (Submodule of ( B209 /\ B210 )))))
proof
let C240 being Z_Module;
let C241 , C242 , C243 being  strict (Submodule of C240);
set D230 = LattStr (# ( Submodules C240 ) , ( SubJoin C240 ) , ( SubMeet C240 ) #);
reconsider D231 = C241 , D232 = C242 , D233 = C243 , D234 = ( C241 /\ C243 ) , D235 = ( C242 /\ C243 ) as (Element of D230) by L1155;
assume L1494: C241 is (Submodule of C242);
L1495: ( D231 "\/" D232 ) = ( C241 + C242 ) by L1431
.= D232 by L1494 , L960;
L1496: D231 [= D232 by L1495 , LATTICES:def 3;
L1497: ( D231 "/\" D233 ) [= ( D232 "/\" D233 ) by L1496 , LATTICES:9;
L1498: ( ( D231 "/\" D233 ) "\/" ( D232 "/\" D233 ) ) = ( D232 "/\" D233 ) by L1497 , LATTICES:def 3;
L1499: ( D232 "/\" D233 ) = ( C242 /\ C243 ) by L1444;
L1500: ( ( D231 "/\" D233 ) "\/" ( D232 "/\" D233 ) ) = ( ( SubJoin C240 ) . (( ( SubMeet C240 ) . (D231 , D233) ) , D235) ) by L1444
.= ( ( SubJoin C240 ) . (D234 , D235) ) by L1444
.= ( ( C241 /\ C243 ) + ( C242 /\ C243 ) ) by L1431;
thus L1501: thesis by L1500 , L1498 , L1499 , L960;
end;
theorem
L1502: (for B211 being Z_Module holds (for B212 being  strict (Submodule of B211) holds ((for B213 being (VECTOR of B211) holds B213 in B212) implies B212 = ( the Z_ModuleStruct of B211 )))) by L1201;
theorem
L1503: (for R51 being Z_Module holds (for R52 being (Submodule of R51) holds (for R59 being (VECTOR of R51) holds (ex R70 being (Coset of R52) st R59 in R70)))) by L1286;
begin
definition
let C244 being non  empty addLoopStr;
func Int-mult-left C244 -> (Function of [: ( INT ) , (the carrier of C244) :] , (the carrier of C244)) means
:L1504: (for B214 being (Element of ( INT )) holds (for B215 being (Element of C244) holds ((B214 >= ( 0 ) implies ( it . (B214 , B215) ) = ( ( Nat-mult-left C244 ) . (B214 , B215) )) & (B214 < ( 0 ) implies ( it . (B214 , B215) ) = ( ( Nat-mult-left C244 ) . (( - B214 ) , ( - B215 )) )))));
existence
proof
defpred S7[ (Element of ( INT )) , (Element of C244) , (Element of C244) ] means (($1 >= ( 0 ) implies $3 = ( ( Nat-mult-left C244 ) . ($1 , $2) )) & ($1 < ( 0 ) implies $3 = ( ( Nat-mult-left C244 ) . (( - $1 ) , ( - $2 )) )));
L1505: (for B216 being (Element of ( INT )) holds (for B217 being (Element of C244) holds (ex B218 being (Element of C244) st S7[ B216 , B217 , B218 ])))
proof
let C245 being (Element of ( INT ));
let C246 being (Element of C244);
per cases ;
suppose L1506: C245 >= ( 0 );

reconsider D236 = C245 as (Element of ( NAT )) by L1506 , INT_1:3;
reconsider D237 = ( ( Nat-mult-left C244 ) . (D236 , C246) ) as (Element of C244);
L1507: S7[ C245 , C246 , D237 ];
thus L1508: thesis by L1507;
end;
suppose L1509: C245 < ( 0 );

reconsider D238 = ( - C245 ) as (Element of ( NAT )) by L1509 , INT_1:3;
reconsider D239 = ( ( Nat-mult-left C244 ) . (D238 , ( - C246 )) ) as (Element of C244);
L1510: S7[ C245 , C246 , D239 ] by L1509;
thus L1511: thesis by L1510;
end;
end;
consider C247 being (Function of [: ( INT ) , (the carrier of C244) :] , (the carrier of C244)) such that L1513: (for B219 being (Element of ( INT )) holds (for B220 being (Element of (the carrier of C244)) holds S7[ B219 , B220 , ( C247 . (B219 , B220) ) ])) from BINOP_1:sch 3(L1505);
take C247;
thus L1514: thesis by L1513;
end;
uniqueness
proof
let C248 , C249 being (Function of [: ( INT ) , (the carrier of C244) :] , (the carrier of C244));
assume L1515: (for B221 being (Element of ( INT )) holds (for B222 being (Element of C244) holds ((B221 >= ( 0 ) implies ( C248 . (B221 , B222) ) = ( ( Nat-mult-left C244 ) . (B221 , B222) )) & (B221 < ( 0 ) implies ( C248 . (B221 , B222) ) = ( ( Nat-mult-left C244 ) . (( - B221 ) , ( - B222 )) )))));
assume L1516: (for B223 being (Element of ( INT )) holds (for B224 being (Element of C244) holds ((B223 >= ( 0 ) implies ( C249 . (B223 , B224) ) = ( ( Nat-mult-left C244 ) . (B223 , B224) )) & (B223 < ( 0 ) implies ( C249 . (B223 , B224) ) = ( ( Nat-mult-left C244 ) . (( - B223 ) , ( - B224 )) )))));
L1517: (for B225 , B226 being set holds ((B225 in ( INT ) & B226 in (the carrier of C244)) implies ( C248 . (B225 , B226) ) = ( C249 . (B225 , B226) )))
proof
let C250 , C251 being set;
assume L1518: (C250 in ( INT ) & C251 in (the carrier of C244));
reconsider D240 = C250 as (Element of ( INT )) by L1518;
reconsider D241 = C251 as (Element of C244) by L1518;
per cases ;
suppose L1519: ( 0 ) <= D240;

thus L1520: ( C248 . (C250 , C251) ) = ( ( Nat-mult-left C244 ) . (D240 , D241) ) by L1519 , L1515
.= ( C249 . (C250 , C251) ) by L1516 , L1519;
end;
suppose L1521: ( 0 ) > D240;

thus L1522: ( C248 . (C250 , C251) ) = ( ( Nat-mult-left C244 ) . (( - D240 ) , ( - D241 )) ) by L1521 , L1515
.= ( C249 . (C250 , C251) ) by L1516 , L1521;
end;
end;
thus L1524: C248 = C249 by L1517 , BINOP_1:def 21;
end;
end;
theorem
L1526: (for B227 being non  empty addLoopStr holds (for B228 being (Element of B227) holds (for B229 being (Element of ( INT )) holds (for B230 being (Element of ( NAT )) holds (B229 = B230 implies ( ( Int-mult-left B227 ) . (B229 , B228) ) = ( B230 * B228 )))))) by L1504;
theorem
L1527: (for B231 being non  empty addLoopStr holds (for B232 being (Element of B231) holds (for B233 being (Element of ( INT )) holds (B233 = ( 0 ) implies ( ( Int-mult-left B231 ) . (B233 , B232) ) = ( 0. B231 )))))
proof
let C252 being non  empty addLoopStr;
let C253 being (Element of C252);
let C254 being (Element of ( INT ));
assume L1528: C254 = ( 0 );
thus L1529: ( ( Int-mult-left C252 ) . (C254 , C253) ) = ( ( 0 ) * C253 ) by L1528 , L1504
.= ( 0. C252 ) by BINOM:12;
end;
theorem
L1530: (for B234 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B235 being (Element of ( NAT )) holds ( ( Nat-mult-left B234 ) . (B235 , ( 0. B234 )) ) = ( 0. B234 )))
proof
let C255 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C256 being (Element of ( NAT ));
defpred S8[ (Element of ( NAT )) ] means ( ( Nat-mult-left C255 ) . ($1 , ( 0. C255 )) ) = ( 0. C255 );
L1531: S8[ ( 0 ) ] by BINOM:def 3;
L1532: (for B236 being (Element of ( NAT )) holds (S8[ B236 ] implies S8[ ( B236 + 1 ) ]))
proof
let C257 being (Element of ( NAT ));
assume L1533: S8[ C257 ];
L1534: ( ( Nat-mult-left C255 ) . (( C257 + 1 ) , ( 0. C255 )) ) = ( ( 0. C255 ) + ( 0. C255 ) ) by L1533 , BINOM:def 3
.= ( 0. C255 ) by RLVECT_1:4;
thus L1535: S8[ ( C257 + 1 ) ] by L1534;
end;
L1536: (for B237 being (Element of ( NAT )) holds S8[ B237 ]) from NAT_1:sch 1(L1531 , L1532);
thus L1537: thesis by L1536;
end;
theorem
L1538: (for B238 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B239 being (Element of ( INT )) holds ( ( Int-mult-left B238 ) . (B239 , ( 0. B238 )) ) = ( 0. B238 )))
proof
let C258 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C259 being (Element of ( INT ));
per cases ;
suppose L1539: ( 0 ) <= C259;

reconsider D242 = C259 as (Element of ( NAT )) by L1539 , INT_1:3;
thus L1540: ( ( Int-mult-left C258 ) . (C259 , ( 0. C258 )) ) = ( ( Nat-mult-left C258 ) . (D242 , ( 0. C258 )) ) by L1504
.= ( 0. C258 ) by L1530;
end;
suppose L1541: ( 0 ) > C259;

reconsider D243 = ( - C259 ) as (Element of ( NAT )) by L1541 , INT_1:3;
thus L1542: ( ( Int-mult-left C258 ) . (C259 , ( 0. C258 )) ) = ( ( Nat-mult-left C258 ) . (D243 , ( - ( 0. C258 ) )) ) by L1504 , L1541
.= ( ( Nat-mult-left C258 ) . (D243 , ( 0. C258 )) ) by RLVECT_1:12
.= ( 0. C258 ) by L1530;
end;
end;
theorem
L1544: (for B240 being  right_zeroed non  empty addLoopStr holds (for B241 being (Element of B240) holds (for B242 being (Element of ( INT )) holds (B242 = 1 implies ( ( Int-mult-left B240 ) . (B242 , B241) ) = B241))))
proof
let C260 being  right_zeroed non  empty addLoopStr;
let C261 being (Element of C260);
let C262 being (Element of ( INT ));
assume L1545: C262 = 1;
thus L1546: ( ( Int-mult-left C260 ) . (C262 , C261) ) = ( 1 * C261 ) by L1545 , L1504
.= C261 by BINOM:13;
end;
theorem
L1547: (for B243 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B244 being (Element of B243) holds (for B245 , B246 , B247 being (Element of ( NAT )) holds ((B245 <= B246 & B247 = ( B246 - B245 )) implies ( ( Nat-mult-left B243 ) . (B247 , B244) ) = ( ( ( Nat-mult-left B243 ) . (B246 , B244) ) - ( ( Nat-mult-left B243 ) . (B245 , B244) ) )))))
proof
let C263 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C264 being (Element of C263);
let C265 , C266 , C267 being (Element of ( NAT ));
assume L1548: (C265 <= C266 & C267 = ( C266 - C265 ));
L1549: ( C266 * C264 ) = ( ( C267 + C265 ) * C264 ) by L1548
.= ( ( C267 * C264 ) + ( C265 * C264 ) ) by BINOM:15;
thus L1550: ( ( ( Nat-mult-left C263 ) . (C266 , C264) ) - ( ( Nat-mult-left C263 ) . (C265 , C264) ) ) = ( ( C267 * C264 ) + ( ( C265 * C264 ) - ( C265 * C264 ) ) ) by L1549 , RLVECT_1:28
.= ( ( C267 * C264 ) + ( 0. C263 ) ) by RLVECT_1:15
.= ( ( Nat-mult-left C263 ) . (C267 , C264) ) by RLVECT_1:4;
end;
theorem
L1551: (for B248 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B249 being (Element of B248) holds (for B250 being (Element of ( NAT )) holds ( - ( ( Nat-mult-left B248 ) . (B250 , B249) ) ) = ( ( Nat-mult-left B248 ) . (B250 , ( - B249 )) ))))
proof
let C268 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C269 being (Element of C268);
let C270 being (Element of ( NAT ));
defpred S9[ (Element of ( NAT )) ] means ( ( ( Nat-mult-left C268 ) . ($1 , C269) ) + ( ( Nat-mult-left C268 ) . ($1 , ( - C269 )) ) ) = ( 0. C268 );
L1552: S9[ ( 0 ) ]
proof
L1553: ( ( ( Nat-mult-left C268 ) . (( 0 ) , C269) ) + ( ( Nat-mult-left C268 ) . (( 0 ) , ( - C269 )) ) ) = ( ( 0. C268 ) + ( ( Nat-mult-left C268 ) . (( 0 ) , ( - C269 )) ) ) by BINOM:def 3
.= ( ( 0. C268 ) + ( 0. C268 ) ) by BINOM:def 3
.= ( 0. C268 ) by RLVECT_1:4;
thus L1554: thesis by L1553;
end;
L1555: (for B251 being (Element of ( NAT )) holds (S9[ B251 ] implies S9[ ( B251 + 1 ) ]))
proof
let C271 being (Element of ( NAT ));
assume L1556: S9[ C271 ];
L1557: ( ( ( Nat-mult-left C268 ) . (( C271 + 1 ) , C269) ) + ( ( Nat-mult-left C268 ) . (( C271 + 1 ) , ( - C269 )) ) ) = ( ( C269 + ( ( Nat-mult-left C268 ) . (C271 , C269) ) ) + ( ( Nat-mult-left C268 ) . (( C271 + 1 ) , ( - C269 )) ) ) by BINOM:def 3
.= ( ( C269 + ( ( Nat-mult-left C268 ) . (C271 , C269) ) ) + ( ( - C269 ) + ( ( Nat-mult-left C268 ) . (C271 , ( - C269 )) ) ) ) by BINOM:def 3
.= ( ( ( C269 + ( ( Nat-mult-left C268 ) . (C271 , C269) ) ) + ( ( Nat-mult-left C268 ) . (C271 , ( - C269 )) ) ) + ( - C269 ) ) by RLVECT_1:def 3
.= ( ( C269 + ( ( ( Nat-mult-left C268 ) . (C271 , C269) ) + ( ( Nat-mult-left C268 ) . (C271 , ( - C269 )) ) ) ) + ( - C269 ) ) by RLVECT_1:def 3
.= ( C269 + ( - C269 ) ) by L1556 , RLVECT_1:4
.= ( 0. C268 ) by RLVECT_1:5;
thus L1558: S9[ ( C271 + 1 ) ] by L1557;
end;
L1559: (for B252 being (Element of ( NAT )) holds S9[ B252 ]) from NAT_1:sch 1(L1552 , L1555);
L1560: ( ( ( Nat-mult-left C268 ) . (C270 , C269) ) + ( ( Nat-mult-left C268 ) . (C270 , ( - C269 )) ) ) = ( 0. C268 ) by L1559;
thus L1561: thesis by L1560 , RLVECT_1:6;
end;
theorem
L1562: (for B253 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B254 being (Element of B253) holds (for B255 , B256 being (Element of ( INT )) holds ((B255 in ( NAT ) & (not B256 in ( NAT ))) implies ( ( Int-mult-left B253 ) . (( B255 + B256 ) , B254) ) = ( ( ( Int-mult-left B253 ) . (B255 , B254) ) + ( ( Int-mult-left B253 ) . (B256 , B254) ) )))))
proof
let C272 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C273 being (Element of C272);
let C274 , C275 being (Element of ( INT ));
assume L1563: (C274 in ( NAT ) & (not C275 in ( NAT )));
reconsider D244 = C274 as (Element of ( NAT )) by L1563;
L1564: C275 < ( 0 ) by L1563 , INT_1:3;
reconsider D245 = ( - C275 ) as (Element of ( NAT )) by L1564 , INT_1:3;
L1565: ( C274 + C275 ) is (Element of ( INT )) by INT_1:def 2;
per cases ;
suppose L1566: D245 <= D244;

reconsider D246 = ( D244 - D245 ) as (Element of ( NAT )) by L1566 , INT_1:5;
thus L1567: ( ( Int-mult-left C272 ) . (( C274 + C275 ) , C273) ) = ( ( Nat-mult-left C272 ) . (D246 , C273) ) by L1565 , L1504
.= ( ( ( Nat-mult-left C272 ) . (D244 , C273) ) - ( ( Nat-mult-left C272 ) . (D245 , C273) ) ) by L1547 , L1566
.= ( ( ( Nat-mult-left C272 ) . (D244 , C273) ) + ( ( Nat-mult-left C272 ) . (D245 , ( - C273 )) ) ) by L1551
.= ( ( ( Int-mult-left C272 ) . (C274 , C273) ) + ( ( Nat-mult-left C272 ) . (D245 , ( - C273 )) ) ) by L1504
.= ( ( ( Int-mult-left C272 ) . (C274 , C273) ) + ( ( Int-mult-left C272 ) . (C275 , C273) ) ) by L1564 , L1504;
end;
suppose L1568: D245 > D244;

reconsider D247 = ( D245 - D244 ) as (Element of ( NAT )) by L1568 , INT_1:5;
L1569: ( D244 - D245 ) < ( 0 ) by L1568 , XREAL_1:49;
thus L1570: ( ( Int-mult-left C272 ) . (( C274 + C275 ) , C273) ) = ( ( Nat-mult-left C272 ) . (( - ( D244 - D245 ) ) , ( - C273 )) ) by L1565 , L1569 , L1504
.= ( ( Nat-mult-left C272 ) . (D247 , ( - C273 )) )
.= ( ( ( Nat-mult-left C272 ) . (D245 , ( - C273 )) ) - ( ( Nat-mult-left C272 ) . (D244 , ( - C273 )) ) ) by L1547 , L1568
.= ( ( ( Nat-mult-left C272 ) . (D245 , ( - C273 )) ) + ( ( Nat-mult-left C272 ) . (D244 , ( - ( - C273 ) )) ) ) by L1551
.= ( ( ( Nat-mult-left C272 ) . (D245 , ( - C273 )) ) + ( ( Nat-mult-left C272 ) . (D244 , C273) ) ) by RLVECT_1:17
.= ( ( ( Int-mult-left C272 ) . (C275 , C273) ) + ( ( Nat-mult-left C272 ) . (D244 , C273) ) ) by L1564 , L1504
.= ( ( ( Int-mult-left C272 ) . (C274 , C273) ) + ( ( Int-mult-left C272 ) . (C275 , C273) ) ) by L1504;
end;
end;
theorem
L1572: (for B257 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B258 being (Element of B257) holds (for B259 , B260 being (Element of ( INT )) holds ( ( Int-mult-left B257 ) . (( B259 + B260 ) , B258) ) = ( ( ( Int-mult-left B257 ) . (B259 , B258) ) + ( ( Int-mult-left B257 ) . (B260 , B258) ) ))))
proof
let C276 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C277 being (Element of C276);
let C278 , C279 being (Element of ( INT ));
per cases ;
suppose L1573: (C278 in ( NAT ) & C279 in ( NAT ));

reconsider D248 = C278 as (Element of ( NAT )) by L1573;
reconsider D249 = C279 as (Element of ( NAT )) by L1573;
L1574: ( C278 + C279 ) is (Element of ( INT )) by INT_1:def 2;
thus L1575: ( ( Int-mult-left C276 ) . (( C278 + C279 ) , C277) ) = ( ( D248 + D249 ) * C277 ) by L1574 , L1504
.= ( ( D248 * C277 ) + ( D249 * C277 ) ) by BINOM:15
.= ( ( ( Int-mult-left C276 ) . (C278 , C277) ) + ( ( Nat-mult-left C276 ) . (D249 , C277) ) ) by L1504
.= ( ( ( Int-mult-left C276 ) . (C278 , C277) ) + ( ( Int-mult-left C276 ) . (C279 , C277) ) ) by L1504;
end;
suppose L1576: (C278 in ( NAT ) & (not C279 in ( NAT )));

thus L1577: ( ( Int-mult-left C276 ) . (( C278 + C279 ) , C277) ) = ( ( ( Int-mult-left C276 ) . (C278 , C277) ) + ( ( Int-mult-left C276 ) . (C279 , C277) ) ) by L1576 , L1562;
end;
suppose L1578: ((not C278 in ( NAT )) & C279 in ( NAT ));

thus L1579: ( ( Int-mult-left C276 ) . (( C278 + C279 ) , C277) ) = ( ( ( Int-mult-left C276 ) . (C278 , C277) ) + ( ( Int-mult-left C276 ) . (C279 , C277) ) ) by L1578 , L1562;
end;
suppose L1580: ((not C278 in ( NAT )) & (not C279 in ( NAT )));

L1581: (C278 < ( 0 ) & C279 < ( 0 )) by L1580 , INT_1:3;
reconsider D250 = ( - C278 ) as (Element of ( NAT )) by L1581 , INT_1:3;
reconsider D251 = ( - C279 ) as (Element of ( NAT )) by L1581 , INT_1:3;
L1582: ( - ( C278 + C279 ) ) = ( D250 + D251 );
L1583: ( C278 + C279 ) is (Element of ( INT )) by INT_1:def 2;
thus L1584: ( ( Int-mult-left C276 ) . (( C278 + C279 ) , C277) ) = ( ( D250 + D251 ) * ( - C277 ) ) by L1581 , L1582 , L1583 , L1504
.= ( ( D250 * ( - C277 ) ) + ( D251 * ( - C277 ) ) ) by BINOM:15
.= ( ( ( Int-mult-left C276 ) . (C278 , C277) ) + ( ( Nat-mult-left C276 ) . (D251 , ( - C277 )) ) ) by L1581 , L1504
.= ( ( ( Int-mult-left C276 ) . (C278 , C277) ) + ( ( Int-mult-left C276 ) . (C279 , C277) ) ) by L1581 , L1504;
end;
end;
theorem
L1586: (for B261 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B262 , B263 being (Element of B261) holds (for B264 being (Element of ( NAT )) holds ( ( Nat-mult-left B261 ) . (B264 , ( B262 + B263 )) ) = ( ( ( Nat-mult-left B261 ) . (B264 , B262) ) + ( ( Nat-mult-left B261 ) . (B264 , B263) ) ))))
proof
let C280 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C281 , C282 being (Element of C280);
let C283 being (Element of ( NAT ));
defpred S10[ (Element of ( NAT )) ] means ( ( Nat-mult-left C280 ) . ($1 , ( C281 + C282 )) ) = ( ( ( Nat-mult-left C280 ) . ($1 , C281) ) + ( ( Nat-mult-left C280 ) . ($1 , C282) ) );
L1587: S10[ ( 0 ) ]
proof
L1588: ( ( Nat-mult-left C280 ) . (( 0 ) , ( C281 + C282 )) ) = ( 0. C280 ) by BINOM:def 3
.= ( ( 0. C280 ) + ( 0. C280 ) ) by RLVECT_1:4
.= ( ( ( Nat-mult-left C280 ) . (( 0 ) , C281) ) + ( 0. C280 ) ) by BINOM:def 3
.= ( ( ( Nat-mult-left C280 ) . (( 0 ) , C281) ) + ( ( Nat-mult-left C280 ) . (( 0 ) , C282) ) ) by BINOM:def 3;
thus L1589: thesis by L1588;
end;
L1590: (for B265 being (Element of ( NAT )) holds (S10[ B265 ] implies S10[ ( B265 + 1 ) ]))
proof
let C284 being (Element of ( NAT ));
assume L1591: S10[ C284 ];
L1592: ( ( Nat-mult-left C280 ) . (( C284 + 1 ) , ( C281 + C282 )) ) = ( ( C281 + C282 ) + ( ( Nat-mult-left C280 ) . (C284 , ( C281 + C282 )) ) ) by BINOM:def 3
.= ( ( ( C281 + C282 ) + ( ( Nat-mult-left C280 ) . (C284 , C281) ) ) + ( ( Nat-mult-left C280 ) . (C284 , C282) ) ) by L1591 , RLVECT_1:def 3
.= ( ( ( C281 + ( ( Nat-mult-left C280 ) . (C284 , C281) ) ) + C282 ) + ( ( Nat-mult-left C280 ) . (C284 , C282) ) ) by RLVECT_1:def 3
.= ( ( ( ( Nat-mult-left C280 ) . (( C284 + 1 ) , C281) ) + C282 ) + ( ( Nat-mult-left C280 ) . (C284 , C282) ) ) by BINOM:def 3
.= ( ( ( Nat-mult-left C280 ) . (( C284 + 1 ) , C281) ) + ( C282 + ( ( Nat-mult-left C280 ) . (C284 , C282) ) ) ) by RLVECT_1:def 3
.= ( ( ( Nat-mult-left C280 ) . (( C284 + 1 ) , C281) ) + ( ( Nat-mult-left C280 ) . (( C284 + 1 ) , C282) ) ) by BINOM:def 3;
thus L1593: S10[ ( C284 + 1 ) ] by L1592;
end;
L1594: (for B266 being (Element of ( NAT )) holds S10[ B266 ]) from NAT_1:sch 1(L1587 , L1590);
thus L1595: thesis by L1594;
end;
theorem
L1596: (for B267 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B268 , B269 being (Element of B267) holds (for B270 being (Element of ( INT )) holds ( ( Int-mult-left B267 ) . (B270 , ( B268 + B269 )) ) = ( ( ( Int-mult-left B267 ) . (B270 , B268) ) + ( ( Int-mult-left B267 ) . (B270 , B269) ) ))))
proof
let C285 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C286 , C287 being (Element of C285);
let C288 being (Element of ( INT ));
per cases ;
suppose L1597: ( 0 ) <= C288;

reconsider D252 = C288 as (Element of ( NAT )) by L1597 , INT_1:3;
thus L1598: ( ( Int-mult-left C285 ) . (C288 , ( C286 + C287 )) ) = ( ( Nat-mult-left C285 ) . (D252 , ( C286 + C287 )) ) by L1504
.= ( ( D252 * C286 ) + ( D252 * C287 ) ) by L1586
.= ( ( ( Int-mult-left C285 ) . (C288 , C286) ) + ( ( Nat-mult-left C285 ) . (D252 , C287) ) ) by L1504
.= ( ( ( Int-mult-left C285 ) . (C288 , C286) ) + ( ( Int-mult-left C285 ) . (C288 , C287) ) ) by L1504;
end;
suppose L1599: ( 0 ) > C288;

reconsider D253 = ( - C288 ) as (Element of ( NAT )) by L1599 , INT_1:3;
L1600: ( ( C286 + C287 ) + ( ( - C286 ) + ( - C287 ) ) ) = ( ( ( C287 + C286 ) + ( - C286 ) ) + ( - C287 ) ) by RLVECT_1:def 3
.= ( ( C287 + ( C286 + ( - C286 ) ) ) + ( - C287 ) ) by RLVECT_1:def 3
.= ( ( C287 + ( 0. C285 ) ) + ( - C287 ) ) by RLVECT_1:5
.= ( C287 + ( - C287 ) ) by RLVECT_1:4
.= ( 0. C285 ) by RLVECT_1:5;
L1601: ( - ( C286 + C287 ) ) = ( ( - C286 ) + ( - C287 ) ) by L1600 , RLVECT_1:6;
thus L1602: ( ( Int-mult-left C285 ) . (C288 , ( C286 + C287 )) ) = ( ( Nat-mult-left C285 ) . (D253 , ( - ( C286 + C287 ) )) ) by L1504 , L1599
.= ( ( D253 * ( - C286 ) ) + ( D253 * ( - C287 ) ) ) by L1601 , L1586
.= ( ( ( Int-mult-left C285 ) . (C288 , C286) ) + ( ( Nat-mult-left C285 ) . (D253 , ( - C287 )) ) ) by L1599 , L1504
.= ( ( ( Int-mult-left C285 ) . (C288 , C286) ) + ( ( Int-mult-left C285 ) . (C288 , C287) ) ) by L1599 , L1504;
end;
end;
theorem
L1604: (for B271 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B272 being (Element of B271) holds (for B273 , B274 being (Element of ( NAT )) holds ( ( Nat-mult-left B271 ) . (( B273 * B274 ) , B272) ) = ( ( Nat-mult-left B271 ) . (B273 , ( ( Nat-mult-left B271 ) . (B274 , B272) )) ))))
proof
let C289 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C290 being (Element of C289);
let C291 , C292 being (Element of ( NAT ));
defpred S11[ (Element of ( NAT )) ] means ( ( Nat-mult-left C289 ) . (( $1 * C292 ) , C290) ) = ( ( Nat-mult-left C289 ) . ($1 , ( ( Nat-mult-left C289 ) . (C292 , C290) )) );
L1605: S11[ ( 0 ) ]
proof
L1606: ( ( Nat-mult-left C289 ) . (( ( 0 ) * C292 ) , C290) ) = ( 0. C289 ) by BINOM:def 3
.= ( ( Nat-mult-left C289 ) . (( 0 ) , ( ( Nat-mult-left C289 ) . (C292 , C290) )) ) by BINOM:def 3;
thus L1607: thesis by L1606;
end;
L1608: (for B275 being (Element of ( NAT )) holds (S11[ B275 ] implies S11[ ( B275 + 1 ) ]))
proof
let C293 being (Element of ( NAT ));
assume L1609: S11[ C293 ];
L1610: ( ( Nat-mult-left C289 ) . (( ( C293 + 1 ) * C292 ) , C290) ) = ( ( C292 + ( C293 * C292 ) ) * C290 )
.= ( ( C292 * C290 ) + ( ( C293 * C292 ) * C290 ) ) by BINOM:15
.= ( ( Nat-mult-left C289 ) . (( C293 + 1 ) , ( C292 * C290 )) ) by L1609 , BINOM:def 3;
thus L1611: S11[ ( C293 + 1 ) ] by L1610;
end;
L1612: (for B276 being (Element of ( NAT )) holds S11[ B276 ]) from NAT_1:sch 1(L1605 , L1608);
thus L1613: thesis by L1612;
end;
L1614: (for B277 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B278 being (Element of B277) holds (for B279 , B280 being (Element of ( INT )) holds ((B279 <> ( 0 ) & B280 <> ( 0 )) implies ( ( Int-mult-left B277 ) . (( B279 * B280 ) , B278) ) = ( ( Int-mult-left B277 ) . (B279 , ( ( Int-mult-left B277 ) . (B280 , B278) )) )))))
proof
let C294 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C295 being (Element of C294);
let C296 , C297 being (Element of ( INT ));
assume L1615: (C296 <> ( 0 ) & C297 <> ( 0 ));
per cases ;
suppose L1616: (C296 in ( NAT ) & C297 in ( NAT ));

reconsider D254 = C296 as (Element of ( NAT )) by L1616;
reconsider D255 = C297 as (Element of ( NAT )) by L1616;
L1617: ( C296 * C297 ) is (Element of ( INT )) by INT_1:def 2;
thus L1618: ( ( Int-mult-left C294 ) . (( C296 * C297 ) , C295) ) = ( ( Nat-mult-left C294 ) . (( D254 * D255 ) , C295) ) by L1617 , L1504
.= ( ( Nat-mult-left C294 ) . (D254 , ( ( Nat-mult-left C294 ) . (D255 , C295) )) ) by L1604
.= ( ( Nat-mult-left C294 ) . (D254 , ( ( Int-mult-left C294 ) . (C297 , C295) )) ) by L1504
.= ( ( Int-mult-left C294 ) . (C296 , ( ( Int-mult-left C294 ) . (C297 , C295) )) ) by L1504;
end;
suppose L1619: (C296 in ( NAT ) & (not C297 in ( NAT )));

L1620: (( 0 ) < C296 & C297 < ( 0 )) by L1619 , L1615 , INT_1:3;
reconsider D256 = C296 as (Element of ( NAT )) by L1619;
reconsider D257 = ( - C297 ) as (Element of ( NAT )) by L1620 , INT_1:3;
L1621: ( - ( C296 * C297 ) ) = ( D256 * D257 );
L1622: ( C297 * C296 ) < ( ( 0 ) * C296 ) by L1620 , XREAL_1:68;
L1623: ( C296 * C297 ) is (Element of ( INT )) by INT_1:def 2;
thus L1624: ( ( Int-mult-left C294 ) . (( C296 * C297 ) , C295) ) = ( ( Nat-mult-left C294 ) . (( D256 * D257 ) , ( - C295 )) ) by L1623 , L1622 , L1621 , L1504
.= ( ( Nat-mult-left C294 ) . (D256 , ( ( Nat-mult-left C294 ) . (D257 , ( - C295 )) )) ) by L1604
.= ( ( Nat-mult-left C294 ) . (D256 , ( ( Int-mult-left C294 ) . (C297 , C295) )) ) by L1504 , L1620
.= ( ( Int-mult-left C294 ) . (C296 , ( ( Int-mult-left C294 ) . (C297 , C295) )) ) by L1504;
end;
suppose L1625: ((not C296 in ( NAT )) & C297 in ( NAT ));

L1626: (( 0 ) < C297 & C296 < ( 0 )) by L1625 , L1615 , INT_1:3;
reconsider D258 = ( - C296 ) as (Element of ( NAT )) by L1626 , INT_1:3;
reconsider D259 = C297 as (Element of ( NAT )) by L1625;
L1627: ( - ( C296 * C297 ) ) = ( D258 * D259 );
L1628: ( C296 * C297 ) < ( ( 0 ) * C297 ) by L1626 , XREAL_1:68;
L1629: ( C296 * C297 ) is (Element of ( INT )) by INT_1:def 2;
thus L1630: ( ( Int-mult-left C294 ) . (( C296 * C297 ) , C295) ) = ( ( Nat-mult-left C294 ) . (( D258 * D259 ) , ( - C295 )) ) by L1628 , L1627 , L1629 , L1504
.= ( ( Nat-mult-left C294 ) . (D258 , ( ( Nat-mult-left C294 ) . (D259 , ( - C295 )) )) ) by L1604
.= ( ( Nat-mult-left C294 ) . (D258 , ( - ( ( Nat-mult-left C294 ) . (D259 , C295) ) )) ) by L1551
.= ( ( Nat-mult-left C294 ) . (D258 , ( - ( ( Int-mult-left C294 ) . (C297 , C295) ) )) ) by L1504
.= ( ( Int-mult-left C294 ) . (C296 , ( ( Int-mult-left C294 ) . (C297 , C295) )) ) by L1626 , L1504;
end;
suppose L1631: ((not C296 in ( NAT )) & (not C297 in ( NAT )));

L1632: (C296 < ( 0 ) & C297 < ( 0 )) by L1631 , INT_1:3;
reconsider D260 = ( - C296 ) as (Element of ( NAT )) by L1632 , INT_1:3;
reconsider D261 = ( - C297 ) as (Element of ( NAT )) by L1632 , INT_1:3;
L1633: ( C296 * C297 ) is (Element of ( INT )) by INT_1:def 2;
L1634: ( - ( ( Nat-mult-left C294 ) . (D261 , C295) ) ) = ( ( Nat-mult-left C294 ) . (D261 , ( - C295 )) ) by L1551;
L1635: ( ( ( Nat-mult-left C294 ) . (D261 , ( - C295 )) ) + ( ( Nat-mult-left C294 ) . (D261 , C295) ) ) = ( 0. C294 ) by L1634 , RLVECT_1:def 10;
L1636: ( ( Nat-mult-left C294 ) . (D261 , C295) ) = ( - ( ( Nat-mult-left C294 ) . (D261 , ( - C295 )) ) ) by L1635 , RLVECT_1:def 10;
thus L1637: ( ( Int-mult-left C294 ) . (( C296 * C297 ) , C295) ) = ( ( Nat-mult-left C294 ) . (( D260 * D261 ) , C295) ) by L1633 , L1504
.= ( ( Nat-mult-left C294 ) . (D260 , ( ( Nat-mult-left C294 ) . (D261 , C295) )) ) by L1604
.= ( ( Nat-mult-left C294 ) . (D260 , ( - ( ( Int-mult-left C294 ) . (C297 , C295) ) )) ) by L1632 , L1636 , L1504
.= ( ( Int-mult-left C294 ) . (C296 , ( ( Int-mult-left C294 ) . (C297 , C295) )) ) by L1632 , L1504;
end;
end;
L1639: (for B281 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B282 being (Element of B281) holds (for B283 , B284 being (Element of ( INT )) holds ((B283 = ( 0 ) or B284 = ( 0 )) implies ( ( Int-mult-left B281 ) . (( B283 * B284 ) , B282) ) = ( ( Int-mult-left B281 ) . (B283 , ( ( Int-mult-left B281 ) . (B284 , B282) )) )))))
proof
let C298 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C299 being (Element of C298);
let C300 , C301 being (Element of ( INT ));
assume L1640: (C300 = ( 0 ) or C301 = ( 0 ));
per cases  by L1640;
suppose L1641: C300 = ( 0 );

thus L1642: ( ( Int-mult-left C298 ) . (( C300 * C301 ) , C299) ) = ( 0. C298 ) by L1641 , L1527
.= ( ( Int-mult-left C298 ) . (C300 , ( ( Int-mult-left C298 ) . (C301 , C299) )) ) by L1641 , L1527;
end;
suppose L1643: C301 = ( 0 );

thus L1644: ( ( Int-mult-left C298 ) . (( C300 * C301 ) , C299) ) = ( 0. C298 ) by L1643 , L1527
.= ( ( Int-mult-left C298 ) . (C300 , ( 0. C298 )) ) by L1538
.= ( ( Int-mult-left C298 ) . (C300 , ( ( Int-mult-left C298 ) . (C301 , C299) )) ) by L1527 , L1643;
end;
end;
theorem
L1646: (for B285 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr holds (for B286 being (Element of B285) holds (for B287 , B288 being (Element of ( INT )) holds ( ( Int-mult-left B285 ) . (( B287 * B288 ) , B286) ) = ( ( Int-mult-left B285 ) . (B287 , ( ( Int-mult-left B285 ) . (B288 , B286) )) ))))
proof
let C302 being  Abelian  right_zeroed  add-associative  right_complementable non  empty addLoopStr;
let C303 being (Element of C302);
let C304 , C305 being (Element of ( INT ));
per cases ;
suppose L1647: (C304 = ( 0 ) or C305 = ( 0 ));

thus L1648: ( ( Int-mult-left C302 ) . (( C304 * C305 ) , C303) ) = ( ( Int-mult-left C302 ) . (C304 , ( ( Int-mult-left C302 ) . (C305 , C303) )) ) by L1647 , L1639;
end;
suppose L1649: (not (C304 = ( 0 ) or C305 = ( 0 )));

thus L1650: ( ( Int-mult-left C302 ) . (( C304 * C305 ) , C303) ) = ( ( Int-mult-left C302 ) . (C304 , ( ( Int-mult-left C302 ) . (C305 , C303) )) ) by L1649 , L1614;
end;
end;
theorem
L1652: (for B289 being non  empty  Abelian  add-associative  right_zeroed  right_complementable addLoopStr holds Z_ModuleStruct (# (the carrier of B289) , (the ZeroF of B289) , (the addF of B289) , ( Int-mult-left B289 ) #) is Z_Module)
proof
let C306 being non  empty  Abelian  add-associative  right_zeroed  right_complementable addLoopStr;
reconsider D262 = Z_ModuleStruct (# (the carrier of C306) , (the ZeroF of C306) , (the addF of C306) , ( Int-mult-left C306 ) #) as non  empty Z_ModuleStruct;
set D263 = (the Mult of D262);
set D264 = (the addF of D262);
set D265 = (the carrier of D262);
set D266 = (the ZeroF of D262);
set D267 = ( Int-mult-left C306 );
L1653: (for B290 , B291 being (Element of D262) holds ( B290 + B291 ) = ( B291 + B290 ))
proof
let C307 , C308 being (Element of D262);
reconsider D268 = C307 , D269 = C308 as (Element of C306);
thus L1654: ( C307 + C308 ) = ( D268 + D269 )
.= ( D269 + D268 )
.= ( C308 + C307 );
end;
L1655: (for B292 , B293 , B294 being (Element of D262) holds ( ( B292 + B293 ) + B294 ) = ( B292 + ( B293 + B294 ) ))
proof
let C309 , C310 , C311 being (Element of D262);
reconsider D270 = C309 , D271 = C310 , D272 = C311 as (Element of C306);
thus L1656: ( ( C309 + C310 ) + C311 ) = ( ( D270 + D271 ) + D272 )
.= ( D270 + ( D271 + D272 ) ) by RLVECT_1:def 3
.= ( C309 + ( C310 + C311 ) );
end;
L1657: (for B295 being (Element of D262) holds ( B295 + ( 0. D262 ) ) = B295)
proof
let C312 being (VECTOR of D262);
reconsider D273 = C312 as (Element of C306);
thus L1658: ( C312 + ( 0. D262 ) ) = ( D273 + ( 0. C306 ) )
.= C312 by RLVECT_1:def 4;
end;
L1659:
now
let C313 being (VECTOR of D262);
reconsider D274 = C313 as (Element of C306);
consider C314 being (Element of C306) such that L1660: ( D274 + C314 ) = ( 0. C306 ) by ALGSTR_0:def 11;
reconsider D275 = C314 as (Element of D262);
L1661: ( C313 + D275 ) = ( 0. D262 ) by L1660;
thus L1662: C313 is  right_complementable by L1661 , ALGSTR_0:def 11;
end;
L1663: (for B296 , B297 being  integer number holds (for B298 being (VECTOR of D262) holds ( ( B296 + B297 ) * B298 ) = ( ( B296 * B298 ) + ( B297 * B298 ) )))
proof
let C315 , C316 being  integer number;
let C317 being (VECTOR of D262);
reconsider D276 = C315 , D277 = C316 as (Element of ( INT )) by INT_1:def 2;
reconsider D278 = C317 as (Element of C306);
thus L1664: ( ( C315 + C316 ) * C317 ) = ( ( D267 . (D276 , D278) ) + ( D267 . (D277 , D278) ) ) by L1572
.= ( ( C315 * C317 ) + ( C316 * C317 ) );
end;
L1665: (for B299 being  integer number holds (for B300 , B301 being (VECTOR of D262) holds ( B299 * ( B300 + B301 ) ) = ( ( B299 * B300 ) + ( B299 * B301 ) )))
proof
let C318 being  integer number;
let C319 , C320 being (VECTOR of D262);
reconsider D279 = C318 as (Element of ( INT )) by INT_1:def 2;
reconsider D280 = C319 , D281 = C320 as (Element of C306);
thus L1666: ( C318 * ( C319 + C320 ) ) = ( D267 . (D279 , ( D280 + D281 )) )
.= ( ( D267 . (D279 , D280) ) + ( D267 . (D279 , D281) ) ) by L1596
.= ( ( C318 * C319 ) + ( C318 * C320 ) );
end;
L1667: (for B302 , B303 being  integer number holds (for B304 being (VECTOR of D262) holds ( ( B302 * B303 ) * B304 ) = ( B302 * ( B303 * B304 ) )))
proof
let C321 , C322 being  integer number;
let C323 being (VECTOR of D262);
reconsider D282 = C321 , D283 = C322 as (Element of ( INT )) by INT_1:def 2;
reconsider D284 = C323 as (Element of C306);
thus L1668: ( ( C321 * C322 ) * C323 ) = ( D267 . (D282 , ( D267 . (D283 , D284) )) ) by L1646
.= ( C321 * ( C322 * C323 ) );
end;
L1669: (for B305 being (VECTOR of D262) holds ( 1 * B305 ) = B305)
proof
let C324 being (VECTOR of D262);
reconsider D285 = 1 as (Element of ( INT )) by INT_1:def 2;
reconsider D286 = C324 as (Element of C306);
thus L1670: ( 1 * C324 ) = ( D267 . (D285 , D286) )
.= C324 by L1544;
end;
thus L1671: thesis by L1669 , L1653 , L1655 , L1657 , L1659 , L1663 , L1665 , L1667 , L9 , L10 , L11 , L12 , ALGSTR_0:def 16 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
end;
