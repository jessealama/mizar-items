:: Preliminaries to the Lambek Calculus
::  by Wojciech Zielonka
::
:: Received February 13, 1991
:: Copyright (c) 1991-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, STRUCT_0, BINOP_1, SUBSET_1, FINSEQ_1, FUNCT_1,
      VALUED_1, RELAT_1, FINSET_1, TREES_2, ZFMISC_1, NUMBERS, CARD_1, MCART_1,
      ORDINAL4, FUNCOP_1, TARSKI, ORDINAL1, XXREAL_0, ARYTM_3, CARD_3, NAT_1,
      REAL_1, FUNCT_5, PRELAMB;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, CARD_1, NUMBERS, REAL_1,
      BINOP_1, RELSET_1, FINSEQ_1, FINSEQ_2, FINSET_1, MCART_1, STRUCT_0,
      RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1, FUNCT_5, RVSUM_1, XCMPLX_0,
      ORDINAL1, NAT_1, TREES_1, TREES_2, XXREAL_0;
 constructors BINOP_1, FUNCT_3, XXREAL_0, NAT_1, RVSUM_1, TREES_2, MIDSP_1,
      FUNCT_5, RELSET_1, BINOP_2, FUNCOP_1, REAL_1, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FINSET_1,
      NUMBERS, MEMBERED, FINSEQ_1, TREES_2, STRUCT_0, VALUED_0, RELSET_1,
      CARD_1, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, XBOOLE_0, BINOP_1, XTUPLE_0;
 theorems FINSEQ_1, ZFMISC_1, TREES_2, FUNCOP_1, FUNCT_2, TARSKI, MCART_1,
      CARD_1, TREES_1, NAT_1, CARD_2, RVSUM_1, RELAT_1, XBOOLE_1, FINSEQ_2;
 schemes FUNCT_2, FINSEQ_2;

begin
definition
struct (1-sorted) typealg(# carrier -> set , left_quotient , right_quotient , inner_product -> (BinOp of the carrier) #);
end;
registration
cluster non  empty  strict for typealg;
existence
proof
set D1 = the (BinOp of { ( {} ) });
take typealg (# { ( {} ) } , D1 , D1 , D1 #);
thus L2: (the carrier of typealg (# { ( {} ) } , D1 , D1 , D1 #)) is non  empty;
thus L3: thesis;
end;
end;
definition
let C1 being non  empty typealg;
mode type of C1
 is (Element of C1);
end;
definition
let R1 being non  empty typealg;
let R8 being (type of R1);
let R9 being (type of R1);
func R8 \ R9 -> (type of R1) equals 
( (the left_quotient of R1) . (R8 , R9) );
coherence;
func R8 /" R9 -> (type of R1) equals 
( (the right_quotient of R1) . (R8 , R9) );
coherence;
func R8 * R9 -> (type of R1) equals 
( (the inner_product of R1) . (R8 , R9) );
coherence;
end;
definition
let R1 being non  empty typealg;
mode PreProof of R1
 is  finite (DecoratedTree of [: [: ( (the carrier of R1) * ) , (the carrier of R1) :] , ( NAT ) :]);
end;
definition
let R1 being non  empty typealg;
let R13 being (PreProof of R1);
let C2 being (Element of ( dom R13 ));
attr C2 is  correct
means
:L8: (( branchdeg C2 ) = ( 0 ) & (ex R8 being (type of R1) st ( ( R13 . C2 ) `1 ) = [ <* R8 *> , R8 ])) if ( ( R13 . C2 ) `2 ) = ( 0 ) , (( branchdeg C2 ) = 1 & (ex R2 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (( ( R13 . C2 ) `1 ) = [ R2 , ( R8 /" R9 ) ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ ( R2 ^ <* R9 *> ) , R8 ]))))) if ( ( R13 . C2 ) `2 ) = 1 , (( branchdeg C2 ) = 1 & (ex R2 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (( ( R13 . C2 ) `1 ) = [ R2 , ( R9 \ R8 ) ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ ( <* R9 *> ^ R2 ) , R8 ]))))) if ( ( R13 . C2 ) `2 ) = 2 , (( branchdeg C2 ) = 2 & (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( R13 . C2 ) `1 ) = [ ( ( ( R3 ^ <* ( R8 /" R9 ) *> ) ^ R2 ) ^ R4 ) , R10 ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ R2 , R9 ] & ( ( R13 . ( C2 ^ <* 1 *> ) ) `1 ) = [ ( ( R3 ^ <* R8 *> ) ^ R4 ) , R10 ])))))))) if ( ( R13 . C2 ) `2 ) = 3 , (( branchdeg C2 ) = 2 & (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( R13 . C2 ) `1 ) = [ ( ( ( R3 ^ R2 ) ^ <* ( R9 \ R8 ) *> ) ^ R4 ) , R10 ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ R2 , R9 ] & ( ( R13 . ( C2 ^ <* 1 *> ) ) `1 ) = [ ( ( R3 ^ <* R8 *> ) ^ R4 ) , R10 ])))))))) if ( ( R13 . C2 ) `2 ) = 4 , (for R10 being (type of R1) holds (( branchdeg C2 ) = 1 & (ex R3 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R4 being (FinSequence of R1) st (( ( R13 . C2 ) `1 ) = [ ( ( R3 ^ <* ( R8 * R9 ) *> ) ^ R4 ) , R10 ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ ( ( ( R3 ^ <* R8 *> ) ^ <* R9 *> ) ^ R4 ) , R10 ]))))))) if ( ( R13 . C2 ) `2 ) = 5 , (( branchdeg C2 ) = 2 & (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (( ( R13 . C2 ) `1 ) = [ ( R3 ^ R4 ) , ( R8 * R9 ) ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ R3 , R8 ] & ( ( R13 . ( C2 ^ <* 1 *> ) ) `1 ) = [ R4 , R9 ])))))) if ( ( R13 . C2 ) `2 ) = 6 , (( branchdeg C2 ) = 2 & (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( R13 . C2 ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( R13 . ( C2 ^ <* ( 0 ) *> ) ) `1 ) = [ R2 , R9 ] & ( ( R13 . ( C2 ^ <* 1 *> ) ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ]))))))) if ( ( R13 . C2 ) `2 ) = 7 otherwise contradiction;
correctness;
end;
definition
let R1 being non  empty typealg;
let C3 being (type of R1);
attr C3 is  left
means
(ex R8 being (type of R1) st (ex R9 being (type of R1) st C3 = ( R8 \ R9 )));
attr C3 is  right
means
(ex R8 being (type of R1) st (ex R9 being (type of R1) st C3 = ( R8 /" R9 )));
attr C3 is  middle
means
(ex R8 being (type of R1) st (ex R9 being (type of R1) st C3 = ( R8 * R9 )));
end;
definition
let R1 being non  empty typealg;
let C4 being (type of R1);
attr C4 is  primitive
means
(not (C4 is  left or C4 is  right or C4 is  middle));
end;
definition
let R1 being non  empty typealg;
let C5 being  finite (DecoratedTree of (the carrier of R1));
let C6 being (Element of ( dom C5 ));
redefine func C5 . C6 -> (type of R1);

coherence
proof
reconsider D2 = C5 as (DecoratedTree of (the carrier of R1));
reconsider D3 = C6 as (Element of ( dom D2 ));
L12: ( D2 . D3 ) is (type of R1);
thus L13: thesis by L12;
end;
end;
definition
let R1 being non  empty typealg;
let C7 being  finite (DecoratedTree of (the carrier of R1));
let R8 being (type of R1);
pred C7 represents R8
means
(( dom C7 ) is  finite & (for B1 being (Element of ( dom C7 )) holds ((( branchdeg B1 ) = ( 0 ) or ( branchdeg B1 ) = 2) & (( branchdeg B1 ) = ( 0 ) implies ( C7 . B1 ) is  primitive) & (( branchdeg B1 ) = 2 implies (ex R9 being (type of R1) st (ex R10 being (type of R1) st ((( C7 . B1 ) = ( R9 /" R10 ) or ( C7 . B1 ) = ( R9 \ R10 ) or ( C7 . B1 ) = ( R9 * R10 )) & ( C7 . ( B1 ^ <* ( 0 ) *> ) ) = R9 & ( C7 . ( B1 ^ <* 1 *> ) ) = R10)))))))
;end;
notation
let R1 being non  empty typealg;
let C8 being  finite (DecoratedTree of (the carrier of R1));
let R8 being (type of R1);
antonym C8 does_not_represent R8 for C8 represents R8;
end;
definition
let C9 being non  empty typealg;
attr C9 is  free
means
:L17: ((not (ex B2 being (type of C9) st (B2 is  left  right or B2 is  left  middle or B2 is  right  middle))) & (for B3 being (type of C9) holds (ex B4 being  finite (DecoratedTree of (the carrier of C9)) st (for B5 being  finite (DecoratedTree of (the carrier of C9)) holds (B5 represents B3 iff B4 = B5)))));
end;
definition
let R1 being non  empty typealg;
let R8 being (type of R1);
assume that
L19: R1 is  free;
func repr_of R8 ->  finite (DecoratedTree of (the carrier of R1)) means 
(for B6 being  finite (DecoratedTree of (the carrier of R1)) holds (B6 represents R8 iff it = B6));
existence by L19 , L17;
uniqueness
proof
let C10 , C11 being  finite (DecoratedTree of (the carrier of R1));
assume that
L20: (for B7 being  finite (DecoratedTree of (the carrier of R1)) holds (B7 represents R8 iff C10 = B7))
and
L21: (for B8 being  finite (DecoratedTree of (the carrier of R1)) holds (B8 represents R8 iff C11 = B8));
L22: C10 represents R8 by L20;
thus L23: thesis by L22 , L21;
end;
end;
deffunc H1(typealg) = [: ( (the carrier of $1) * ) , (the carrier of $1) :];
definition
let R1 being non  empty typealg;
let C12 being (FinSequence of R1);
let C13 being (type of R1);
redefine func [C12 , C13 ] -> (Element of [: ( (the carrier of R1) * ) , (the carrier of R1) :]);

coherence
proof
L25: C12 in ( (the carrier of R1) * ) by FINSEQ_1:def 11;
thus L26: thesis by L25 , ZFMISC_1:87;
end;
end;
definition
let R1 being non  empty typealg;
mode Proof of R1
 -> (PreProof of R1)
means :L28: (( dom it ) is  finite & (for B9 being (Element of ( dom it )) holds B9 is  correct));
existence
proof
set D4 = the (type of R1);
set D5 = ( { ( {} ) } --> [ [ <* D4 *> , D4 ] , ( 0 ) ] );
L29: ( dom D5 ) = { ( {} ) } by FUNCOP_1:13;
reconsider D6 = D5 as  finite DecoratedTree by TREES_1:23;
L30: [ [ <* D4 *> , D4 ] , ( 0 ) ] in [: H1(R1) , ( NAT ) :] by ZFMISC_1:87;
L31: { [ [ <* D4 *> , D4 ] , ( 0 ) ] } = ( rng D6 ) by FUNCOP_1:8;
L32: ( rng D6 ) c= [: H1(R1) , ( NAT ) :] by L31 , L30 , ZFMISC_1:31;
reconsider D7 = D6 as (PreProof of R1) by L32 , RELAT_1:def 19;
take D7;
thus L33: ( dom D7 ) is  finite;
let C14 being (Element of ( dom D7 ));
L34: C14 = ( {} ) by L29 , TARSKI:def 1;
L35:
now
set D8 = the (Element of ( ( dom D7 ) -level 1 ));
assume L36: ( ( dom D7 ) -level 1 ) <> ( {} );
L37: D8 in ( ( dom D7 ) -level 1 ) by L36;
L38: D8 in { B10 where B10 is (Element of ( dom D7 )) : ( len B10 ) = 1 } by L37 , TREES_2:def 6;
L39: (ex B11 being (Element of ( dom D7 )) st (D8 = B11 & ( len B11 ) = 1)) by L38;
thus L40: contradiction by L39 , L29 , CARD_1:27 , TARSKI:def 1;
end;
L41: ( branchdeg C14 ) = ( card ( succ C14 ) ) by TREES_2:def 12
.= ( 0 ) by L34 , L35 , CARD_1:27 , TREES_2:13;
L42: ( D7 . C14 ) = [ [ <* D4 *> , D4 ] , ( 0 ) ] by L29 , FUNCOP_1:7;
L43: ( ( D7 . C14 ) `1 ) = [ <* D4 *> , D4 ] by L42 , MCART_1:7;
L44: ( ( D7 . C14 ) `2 ) = ( 0 ) by L42 , MCART_1:7;
thus L45: thesis by L44 , L41 , L43 , L8;
end;
end;
theorem
L47: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( branchdeg R15 ) = 1 implies ( R15 ^ <* ( 0 ) *> ) in ( dom R14 )))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
assume L48: ( branchdeg R15 ) = 1;
L49: ( succ R15 ) <> ( {} ) by L48 , CARD_1:27 , TREES_2:def 12;
set D9 = the (Element of ( succ R15 ));
L50: D9 in ( succ R15 ) by L49;
L51: D9 in { ( R15 ^ <* B12 *> ) where B12 is (Element of ( NAT )) : ( R15 ^ <* B12 *> ) in ( dom R14 ) } by L50 , TREES_2:def 5;
consider C15 being (Element of ( NAT )) such that L52: D9 = ( R15 ^ <* C15 *> ) and L53: ( R15 ^ <* C15 *> ) in ( dom R14 ) by L51;
L54: ( 0 ) <= C15 by NAT_1:2;
thus L55: thesis by L54 , L53 , TREES_1:def 3;
end;
theorem
L56: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( branchdeg R15 ) = 2 implies (( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) & ( R15 ^ <* 1 *> ) in ( dom R14 ))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L57: ( succ R15 ) = { ( R15 ^ <* B13 *> ) where B13 is (Element of ( NAT )) : ( R15 ^ <* B13 *> ) in ( dom R14 ) } by TREES_2:def 5;
assume L58: ( branchdeg R15 ) = 2;
L59: ( card ( succ R15 ) ) = 2 by L58 , TREES_2:def 12;
consider C16 , C17 being set such that L60: C16 <> C17 and L61: ( succ R15 ) = { C16 , C17 } by L59 , CARD_2:60;
L62: C16 in ( succ R15 ) by L61 , TARSKI:def 2;
consider C18 being (Element of ( NAT )) such that L63: C16 = ( R15 ^ <* C18 *> ) and L64: ( R15 ^ <* C18 *> ) in ( dom R14 ) by L62 , L57;
L65: C17 in ( succ R15 ) by L61 , TARSKI:def 2;
consider C19 being (Element of ( NAT )) such that L66: C17 = ( R15 ^ <* C19 *> ) and L67: ( R15 ^ <* C19 *> ) in ( dom R14 ) by L65 , L57;
L68: (C18 <> ( 0 ) or C19 <> ( 0 )) by L60 , L63 , L66;
L69: (C18 > ( 0 ) or C19 > ( 0 )) by L68 , NAT_1:3;
thus L70: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L69 , L64 , L67 , TREES_1:def 3;
L71: (C18 >= ( ( 0 ) + 1 ) or C19 >= ( ( 0 ) + 1 )) by L69 , NAT_1:13;
thus L72: thesis by L71 , L64 , L67 , TREES_1:def 3;
end;
theorem
L73: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = ( 0 ) implies (ex R8 being (type of R1) st ( ( R14 . R15 ) `1 ) = [ <* R8 *> , R8 ])))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L74: R15 is  correct by L28;
thus L75: thesis by L74 , L8;
end;
theorem
L76: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 1 implies (ex B14 being (Element of ( dom R14 )) st (ex R2 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (B14 = ( R15 ^ <* ( 0 ) *> ) & ( ( R14 . R15 ) `1 ) = [ R2 , ( R8 /" R9 ) ] & ( ( R14 . B14 ) `1 ) = [ ( R2 ^ <* R9 *> ) , R8 ])))))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L77: R15 is  correct by L28;
assume L78: ( ( R14 . R15 ) `2 ) = 1;
L79: (ex R2 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (( ( R14 . R15 ) `1 ) = [ R2 , ( R8 /" R9 ) ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ ( R2 ^ <* R9 *> ) , R8 ])))) by L78 , L77 , L8;
L80: ( branchdeg R15 ) = 1 by L77 , L78 , L8;
L81: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L80 , L47;
thus L82: thesis by L81 , L79;
end;
theorem
L83: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 2 implies (ex B15 being (Element of ( dom R14 )) st (ex R2 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (B15 = ( R15 ^ <* ( 0 ) *> ) & ( ( R14 . R15 ) `1 ) = [ R2 , ( R9 \ R8 ) ] & ( ( R14 . B15 ) `1 ) = [ ( <* R9 *> ^ R2 ) , R8 ])))))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L84: R15 is  correct by L28;
assume L85: ( ( R14 . R15 ) `2 ) = 2;
L86: (ex R2 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (( ( R14 . R15 ) `1 ) = [ R2 , ( R9 \ R8 ) ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ ( <* R9 *> ^ R2 ) , R8 ])))) by L85 , L84 , L8;
L87: ( branchdeg R15 ) = 1 by L84 , L85 , L8;
L88: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L87 , L47;
thus L89: thesis by L88 , L86;
end;
theorem
L90: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 3 implies (ex B16 , B17 being (Element of ( dom R14 )) st (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (B16 = ( R15 ^ <* ( 0 ) *> ) & B17 = ( R15 ^ <* 1 *> ) & ( ( R14 . R15 ) `1 ) = [ ( ( ( R3 ^ <* ( R8 /" R9 ) *> ) ^ R2 ) ^ R4 ) , R10 ] & ( ( R14 . B16 ) `1 ) = [ R2 , R9 ] & ( ( R14 . B17 ) `1 ) = [ ( ( R3 ^ <* R8 *> ) ^ R4 ) , R10 ]))))))))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L91: R15 is  correct by L28;
assume L92: ( ( R14 . R15 ) `2 ) = 3;
L93: (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( R14 . R15 ) `1 ) = [ ( ( ( R3 ^ <* ( R8 /" R9 ) *> ) ^ R2 ) ^ R4 ) , R10 ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ R2 , R9 ] & ( ( R14 . ( R15 ^ <* 1 *> ) ) `1 ) = [ ( ( R3 ^ <* R8 *> ) ^ R4 ) , R10 ]))))))) by L92 , L91 , L8;
L94: ( branchdeg R15 ) = 2 by L91 , L92 , L8;
L95: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L94 , L56;
L96: ( R15 ^ <* 1 *> ) in ( dom R14 ) by L94 , L56;
thus L97: thesis by L96 , L93 , L95;
end;
theorem
L98: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 4 implies (ex B18 , B19 being (Element of ( dom R14 )) st (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (B18 = ( R15 ^ <* ( 0 ) *> ) & B19 = ( R15 ^ <* 1 *> ) & ( ( R14 . R15 ) `1 ) = [ ( ( ( R3 ^ R2 ) ^ <* ( R9 \ R8 ) *> ) ^ R4 ) , R10 ] & ( ( R14 . B18 ) `1 ) = [ R2 , R9 ] & ( ( R14 . B19 ) `1 ) = [ ( ( R3 ^ <* R8 *> ) ^ R4 ) , R10 ]))))))))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L99: R15 is  correct by L28;
assume L100: ( ( R14 . R15 ) `2 ) = 4;
L101: (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( R14 . R15 ) `1 ) = [ ( ( ( R3 ^ R2 ) ^ <* ( R9 \ R8 ) *> ) ^ R4 ) , R10 ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ R2 , R9 ] & ( ( R14 . ( R15 ^ <* 1 *> ) ) `1 ) = [ ( ( R3 ^ <* R8 *> ) ^ R4 ) , R10 ]))))))) by L100 , L99 , L8;
L102: ( branchdeg R15 ) = 2 by L99 , L100 , L8;
L103: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L102 , L56;
L104: ( R15 ^ <* 1 *> ) in ( dom R14 ) by L102 , L56;
thus L105: thesis by L104 , L101 , L103;
end;
theorem
L106: (for R1 being non  empty typealg holds (for R10 being (type of R1) holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 5 implies (ex B20 being (Element of ( dom R14 )) st (ex R3 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R4 being (FinSequence of R1) st (B20 = ( R15 ^ <* ( 0 ) *> ) & ( ( R14 . R15 ) `1 ) = [ ( ( R3 ^ <* ( R8 * R9 ) *> ) ^ R4 ) , R10 ] & ( ( R14 . B20 ) `1 ) = [ ( ( ( R3 ^ <* R8 *> ) ^ <* R9 *> ) ^ R4 ) , R10 ])))))))))))
proof
let R1 being non  empty typealg;
let R10 being (type of R1);
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L107: R15 is  correct by L28;
assume L108: ( ( R14 . R15 ) `2 ) = 5;
L109: (ex R3 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (ex R4 being (FinSequence of R1) st (( ( R14 . R15 ) `1 ) = [ ( ( R3 ^ <* ( R8 * R9 ) *> ) ^ R4 ) , R10 ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ ( ( ( R3 ^ <* R8 *> ) ^ <* R9 *> ) ^ R4 ) , R10 ]))))) by L108 , L107 , L8;
L110: ( branchdeg R15 ) = 1 by L107 , L108 , L8;
L111: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L110 , L47;
thus L112: thesis by L111 , L109;
end;
theorem
L113: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 6 implies (ex B21 , B22 being (Element of ( dom R14 )) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (B21 = ( R15 ^ <* ( 0 ) *> ) & B22 = ( R15 ^ <* 1 *> ) & ( ( R14 . R15 ) `1 ) = [ ( R3 ^ R4 ) , ( R8 * R9 ) ] & ( ( R14 . B21 ) `1 ) = [ R3 , R8 ] & ( ( R14 . B22 ) `1 ) = [ R4 , R9 ]))))))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L114: R15 is  correct by L28;
assume L115: ( ( R14 . R15 ) `2 ) = 6;
L116: (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R8 being (type of R1) st (ex R9 being (type of R1) st (( ( R14 . R15 ) `1 ) = [ ( R3 ^ R4 ) , ( R8 * R9 ) ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ R3 , R8 ] & ( ( R14 . ( R15 ^ <* 1 *> ) ) `1 ) = [ R4 , R9 ]))))) by L115 , L114 , L8;
L117: ( branchdeg R15 ) = 2 by L114 , L115 , L8;
L118: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L117 , L56;
L119: ( R15 ^ <* 1 *> ) in ( dom R14 ) by L117 , L56;
thus L120: thesis by L119 , L116 , L118;
end;
theorem
L121: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = 7 implies (ex B23 , B24 being (Element of ( dom R14 )) st (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (B23 = ( R15 ^ <* ( 0 ) *> ) & B24 = ( R15 ^ <* 1 *> ) & ( ( R14 . R15 ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( R14 . B23 ) `1 ) = [ R2 , R9 ] & ( ( R14 . B24 ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ])))))))))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L122: R15 is  correct by L28;
assume L123: ( ( R14 . R15 ) `2 ) = 7;
L124: (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( R14 . R15 ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( R14 . ( R15 ^ <* ( 0 ) *> ) ) `1 ) = [ R2 , R9 ] & ( ( R14 . ( R15 ^ <* 1 *> ) ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ])))))) by L123 , L122 , L8;
L125: ( branchdeg R15 ) = 2 by L122 , L123 , L8;
L126: ( R15 ^ <* ( 0 ) *> ) in ( dom R14 ) by L125 , L56;
L127: ( R15 ^ <* 1 *> ) in ( dom R14 ) by L125 , L56;
thus L128: thesis by L127 , L124 , L126;
end;
theorem
L129: (for R1 being non  empty typealg holds (for R14 being (Proof of R1) holds (for R15 being (Element of ( dom R14 )) holds (( ( R14 . R15 ) `2 ) = ( 0 ) or ( ( R14 . R15 ) `2 ) = 1 or ( ( R14 . R15 ) `2 ) = 2 or ( ( R14 . R15 ) `2 ) = 3 or ( ( R14 . R15 ) `2 ) = 4 or ( ( R14 . R15 ) `2 ) = 5 or ( ( R14 . R15 ) `2 ) = 6 or ( ( R14 . R15 ) `2 ) = 7))))
proof
let R1 being non  empty typealg;
let R14 being (Proof of R1);
let R15 being (Element of ( dom R14 ));
L130: R15 is  correct by L28;
thus L131: thesis by L130 , L8;
end;
definition
let R1 being non  empty typealg;
let C20 being (PreProof of R1);
attr C20 is  cut-free
means
(for B25 being (Element of ( dom C20 )) holds ( ( C20 . B25 ) `2 ) <> 7);
end;
definition
let R1 being non  empty typealg;
func size_w.r.t. R1 -> (Function of (the carrier of R1) , ( NAT )) means 
(for R8 being (type of R1) holds ( it . R8 ) = ( card ( dom ( repr_of R8 ) ) ));
existence
proof
deffunc H2((type of R1)) = ( card ( dom ( repr_of $1 ) ) );
thus L133: (ex B26 being (Function of (the carrier of R1) , ( NAT )) st (for R8 being (type of R1) holds ( B26 . R8 ) = H2(R8))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C21 , C22 being (Function of (the carrier of R1) , ( NAT ));
deffunc H3((type of R1)) = ( card ( dom ( repr_of $1 ) ) );
assume that
L134: (for R8 being (type of R1) holds ( C21 . R8 ) = H3(R8))
and
L135: (for R8 being (type of R1) holds ( C22 . R8 ) = H3(R8));
L136:
now
let C23 being (Element of R1);
thus L137: ( C21 . C23 ) = H3(C23) by L134
.= ( C22 . C23 ) by L135;
end;
thus L138: C21 = C22 by L136 , FUNCT_2:63;
end;
end;
definition
let C24 being non  empty set;
let C25 being (FinSequence of C24);
let C26 being (Function of C24 , ( NAT ));
redefine func C26 * C25 -> (FinSequence of ( REAL ));

coherence
proof
L140: ( C26 * C25 ) is (FinSequence of ( NAT )) by FINSEQ_2:32;
L141: ( rng ( C26 * C25 ) ) c= ( REAL );
thus L142: thesis by L141 , L140 , FINSEQ_1:def 4;
end;
end;
L144: (for B27 being non  empty set holds (for B28 being (FinSequence of B27) holds (for B29 being (Function of B27 , ( NAT )) holds ( Sum ( B29 * B28 ) ) is Nat)))
proof
let C27 being non  empty set;
let C28 being (FinSequence of C27);
let C29 being (Function of C27 , ( NAT ));
defpred S1[ (FinSequence of ( REAL )) ] means ($1 is (FinSequence of ( NAT )) implies ( Sum $1 ) is Nat);
L145: S1[ ( <*> ( REAL ) ) ] by RVSUM_1:72;
L146: (for B30 being (FinSequence of ( REAL )) holds (for B31 being Real holds (S1[ B30 ] implies S1[ ( B30 ^ <* B31 *> ) ])))
proof
let C30 being (FinSequence of ( REAL ));
let C31 being Real;
assume L147: S1[ C30 ];
assume L148: ( C30 ^ <* C31 *> ) is (FinSequence of ( NAT ));
L149: ( rng ( C30 ^ <* C31 *> ) ) c= ( NAT ) by L148 , FINSEQ_1:def 4;
L150: ( rng C30 ) c= ( rng ( C30 ^ <* C31 *> ) ) by FINSEQ_1:29;
L151: ( rng C30 ) c= ( NAT ) by L150 , L149 , XBOOLE_1:1;
L152: ( rng <* C31 *> ) c= ( rng ( C30 ^ <* C31 *> ) ) by FINSEQ_1:30;
L153: ( rng <* C31 *> ) c= ( NAT ) by L152 , L149 , XBOOLE_1:1;
L154: ( rng <* C31 *> ) = { C31 } by FINSEQ_1:38;
reconsider D10 = C31 as (Element of ( NAT )) by L154 , L153 , ZFMISC_1:31;
reconsider D11 = ( Sum C30 ) as Nat by L147 , L151 , FINSEQ_1:def 4;
L155: ( Sum ( C30 ^ <* C31 *> ) ) = ( D11 + D10 ) by RVSUM_1:74;
thus L156: thesis by L155;
end;
L157: (for B32 being (FinSequence of ( REAL )) holds S1[ B32 ]) from FINSEQ_2:sch 2(L145 , L146);
L158: ( C29 * C28 ) is (FinSequence of ( NAT )) by FINSEQ_2:32;
thus L159: thesis by L158 , L157;
end;
definition
let R1 being non  empty typealg;
let C32 being (Proof of R1);
func cutdeg C32 -> Nat means 
(ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( C32 . ( {} ) ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( C32 . <* ( 0 ) *> ) `1 ) = [ R2 , R9 ] & ( ( C32 . <* 1 *> ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ] & it = ( ( ( ( size_w.r.t. R1 ) . R9 ) + ( ( size_w.r.t. R1 ) . R10 ) ) + ( Sum ( ( size_w.r.t. R1 ) * ( ( R3 ^ R2 ) ^ R4 ) ) ) ))))))) if ( ( C32 . ( {} ) ) `2 ) = 7 otherwise it = ( 0 );
existence
proof
thus L160: (( ( C32 . ( {} ) ) `2 ) = 7 implies (ex B33 being Nat st (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( C32 . ( {} ) ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( C32 . <* ( 0 ) *> ) `1 ) = [ R2 , R9 ] & ( ( C32 . <* 1 *> ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ] & B33 = ( ( ( ( size_w.r.t. R1 ) . R9 ) + ( ( size_w.r.t. R1 ) . R10 ) ) + ( Sum ( ( size_w.r.t. R1 ) * ( ( R3 ^ R2 ) ^ R4 ) ) ) )))))))))
proof
L161: ( ( {} ) ^ <* ( 0 ) *> ) = <* ( 0 ) *> by FINSEQ_1:34;
L162: ( ( {} ) ^ <* 1 *> ) = <* 1 *> by FINSEQ_1:34;
reconsider D12 = ( {} ) as (Element of ( dom C32 )) by TREES_1:22;
assume L163: ( ( C32 . ( {} ) ) `2 ) = 7;
consider C33 , C34 being (Element of ( dom C32 )), R2 being (FinSequence of R1), R3 being (FinSequence of R1), R4 being (FinSequence of R1), R9 being (type of R1), R10 being (type of R1) such that L164: C33 = ( D12 ^ <* ( 0 ) *> ) and L165: C34 = ( D12 ^ <* 1 *> ) and L166: ( ( C32 . D12 ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] and L167: ( ( C32 . C33 ) `1 ) = [ R2 , R9 ] and L168: ( ( C32 . C34 ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ] by L163 , L121;
reconsider D13 = ( Sum ( ( size_w.r.t. R1 ) * ( ( R3 ^ R2 ) ^ R4 ) ) ) as Nat by L144;
take ( ( ( ( size_w.r.t. R1 ) . R9 ) + ( ( size_w.r.t. R1 ) . R10 ) ) + D13 );
thus L169: thesis by L161 , L162 , L164 , L165 , L166 , L167 , L168;
end;

thus L170: thesis;
end;
uniqueness
proof
let C35 , C36 being Nat;
thus L171: ((( ( C32 . ( {} ) ) `2 ) = 7 & (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( C32 . ( {} ) ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( C32 . <* ( 0 ) *> ) `1 ) = [ R2 , R9 ] & ( ( C32 . <* 1 *> ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ] & C35 = ( ( ( ( size_w.r.t. R1 ) . R9 ) + ( ( size_w.r.t. R1 ) . R10 ) ) + ( Sum ( ( size_w.r.t. R1 ) * ( ( R3 ^ R2 ) ^ R4 ) ) ) ))))))) & (ex R2 being (FinSequence of R1) st (ex R3 being (FinSequence of R1) st (ex R4 being (FinSequence of R1) st (ex R9 being (type of R1) st (ex R10 being (type of R1) st (( ( C32 . ( {} ) ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] & ( ( C32 . <* ( 0 ) *> ) `1 ) = [ R2 , R9 ] & ( ( C32 . <* 1 *> ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ] & C36 = ( ( ( ( size_w.r.t. R1 ) . R9 ) + ( ( size_w.r.t. R1 ) . R10 ) ) + ( Sum ( ( size_w.r.t. R1 ) * ( ( R3 ^ R2 ) ^ R4 ) ) ) )))))))) implies C35 = C36)
proof
assume L172: ( ( C32 . ( {} ) ) `2 ) = 7;
given R2 being (FinSequence of R1) , R3 being (FinSequence of R1) , R4 being (FinSequence of R1) , R9 being (type of R1) , R10 being (type of R1) such that
L173: ( ( C32 . ( {} ) ) `1 ) = [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ]
and
L174: ( ( C32 . <* ( 0 ) *> ) `1 ) = [ R2 , R9 ]
and
L175: ( ( C32 . <* 1 *> ) `1 ) = [ ( ( R3 ^ <* R9 *> ) ^ R4 ) , R10 ]
and
L176: C35 = ( ( ( ( size_w.r.t. R1 ) . R9 ) + ( ( size_w.r.t. R1 ) . R10 ) ) + ( Sum ( ( size_w.r.t. R1 ) * ( ( R3 ^ R2 ) ^ R4 ) ) ) );

given R5 being (FinSequence of R1) , R6 being (FinSequence of R1) , R7 being (FinSequence of R1) , R11 being (type of R1) , R12 being (type of R1) such that
L177: ( ( C32 . ( {} ) ) `1 ) = [ ( ( R6 ^ R5 ) ^ R7 ) , R12 ]
and
L178: ( ( C32 . <* ( 0 ) *> ) `1 ) = [ R5 , R11 ]
and
L179: ( ( C32 . <* 1 *> ) `1 ) = [ ( ( R6 ^ <* R11 *> ) ^ R7 ) , R12 ]
and
L180: C36 = ( ( ( ( size_w.r.t. R1 ) . R11 ) + ( ( size_w.r.t. R1 ) . R12 ) ) + ( Sum ( ( size_w.r.t. R1 ) * ( ( R6 ^ R5 ) ^ R7 ) ) ) );

L181: ( ( R3 ^ R2 ) ^ R4 ) = ( [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] `1 )
.= ( ( R6 ^ R5 ) ^ R7 ) by L173 , L177 , MCART_1:7;
L182: R9 = ( [ R2 , R9 ] `2 )
.= R11 by L174 , L178 , MCART_1:7;
L183: R10 = ( [ ( ( R3 ^ R2 ) ^ R4 ) , R10 ] `2 )
.= R12 by L173 , L177 , MCART_1:7;
thus L184: thesis by L183 , L176 , L180 , L181 , L182;
end;

thus L185: thesis;
end;
consistency;
end;
definition
let R1 being non  empty typealg;
let R16 being non  empty set;
mode Model of R1 , R16
 -> (Function of (the carrier of R1) , ( bool ( R16 * ) ))
means (for R8 being (type of R1) holds (for R9 being (type of R1) holds (( it . ( R8 * R9 ) ) = { ( R17 ^ R20 ) where R17 is (Element of ( R16 * )) , R20 is (Element of ( R16 * )) : (R17 in ( it . R8 ) & R20 in ( it . R9 )) } & ( it . ( R8 /" R9 ) ) = { R18 where R18 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( it . R9 ) implies ( R18 ^ R20 ) in ( it . R8 ))) } & ( it . ( R9 \ R8 ) ) = { R19 where R19 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( it . R9 ) implies ( R20 ^ R19 ) in ( it . R8 ))) })));
existence
proof
L187: ( {} ) in ( R16 * ) by FINSEQ_1:49;
L188: { ( {} ) } c= ( R16 * ) by L187 , ZFMISC_1:31;
reconsider D14 = ( (the carrier of R1) --> { ( {} ) } ) as (Function of (the carrier of R1) , ( bool ( R16 * ) )) by L188 , FUNCOP_1:45;
L189: (for R8 being (type of R1) holds (for B34 being set holds (B34 in ( D14 . R8 ) implies B34 = ( {} ))))
proof
let R8 being (type of R1);
let C37 being set;
assume L190: C37 in ( D14 . R8 );
L191: C37 in { ( {} ) } by L190 , FUNCOP_1:7;
thus L192: thesis by L191 , TARSKI:def 1;
end;
L193: (for R8 being (type of R1) holds ( {} ) in ( D14 . R8 ))
proof
let R8 being (type of R1);
L194: ( D14 . R8 ) = { ( {} ) } by FUNCOP_1:7;
thus L195: thesis by L194 , TARSKI:def 1;
end;
L196: ( {} ) is (Element of ( R16 * )) by FINSEQ_1:49;
take D14;
let R8 being (type of R1);
let R9 being (type of R1);
thus L197: ( D14 . ( R8 * R9 ) ) = { ( R17 ^ R20 ) where R17 is (Element of ( R16 * )) , R20 is (Element of ( R16 * )) : (R17 in ( D14 . R8 ) & R20 in ( D14 . R9 )) }
proof
thus L198: ( D14 . ( R8 * R9 ) ) c= { ( R17 ^ R20 ) where R17 is (Element of ( R16 * )) , R20 is (Element of ( R16 * )) : (R17 in ( D14 . R8 ) & R20 in ( D14 . R9 )) }
proof
let C38 being set;
assume L199: C38 in ( D14 . ( R8 * R9 ) );
L200: C38 = ( {} ) by L199 , L189;
L201: ( ( {} ) ^ ( {} ) ) = ( {} ) by FINSEQ_1:34;
L202: C38 = ( ( {} ) ^ ( {} ) ) by L200 , L201;
L203: ( {} ) in ( D14 . R8 ) by L193;
L204: ( {} ) in ( D14 . R9 ) by L193;
thus L205: thesis by L204 , L202 , L203;
end;

let C39 being set;
assume L206: C39 in { ( R17 ^ R20 ) where R17 is (Element of ( R16 * )) , R20 is (Element of ( R16 * )) : (R17 in ( D14 . R8 ) & R20 in ( D14 . R9 )) };
consider R17 being (Element of ( R16 * )), R20 being (Element of ( R16 * )) such that L207: C39 = ( R17 ^ R20 ) and L208: R17 in ( D14 . R8 ) and L209: R20 in ( D14 . R9 ) by L206;
L210: R17 = ( {} ) by L189 , L208;
L211: R20 = ( {} ) by L189 , L209;
L212: ( R17 ^ R20 ) = ( {} ) by L211 , L210 , FINSEQ_1:34;
thus L213: thesis by L212 , L193 , L207;
end;

thus L214: ( D14 . ( R8 /" R9 ) ) = { R17 where R17 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R17 ^ R20 ) in ( D14 . R8 ))) }
proof
thus L215: ( D14 . ( R8 /" R9 ) ) c= { R17 where R17 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R17 ^ R20 ) in ( D14 . R8 ))) }
proof
let C40 being set;
assume L216: C40 in ( D14 . ( R8 /" R9 ) );
L217: C40 = ( {} ) by L216 , L189;
L218:
now
let R20 being (Element of ( R16 * ));
assume L219: R20 in ( D14 . R9 );
L220: R20 = ( {} ) by L219 , L189;
L221: ( ( {} ) ^ R20 ) = ( {} ) by L220 , FINSEQ_1:34;
thus L222: ( ( {} ) ^ R20 ) in ( D14 . R8 ) by L221 , L193;
end;
thus L223: thesis by L218 , L196 , L217;
end;

let C41 being set;
assume L224: C41 in { R17 where R17 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R17 ^ R20 ) in ( D14 . R8 ))) };
consider R17 being (Element of ( R16 * )) such that L225: C41 = R17 and L226: (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R17 ^ R20 ) in ( D14 . R8 ))) by L224;
L227: ( {} ) in ( D14 . R9 ) by L193;
L228: ( R17 ^ ( {} ) ) in ( D14 . R8 ) by L227 , L226;
L229: R17 = ( {} ) by L228 , L189;
thus L230: thesis by L229 , L193 , L225;
end;

thus L231: ( D14 . ( R9 \ R8 ) ) = { R17 where R17 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R20 ^ R17 ) in ( D14 . R8 ))) }
proof
thus L232: ( D14 . ( R9 \ R8 ) ) c= { R17 where R17 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R20 ^ R17 ) in ( D14 . R8 ))) }
proof
let C42 being set;
assume L233: C42 in ( D14 . ( R9 \ R8 ) );
L234: C42 = ( {} ) by L233 , L189;
L235:
now
let R20 being (Element of ( R16 * ));
assume L236: R20 in ( D14 . R9 );
L237: R20 = ( {} ) by L236 , L189;
L238: ( R20 ^ ( {} ) ) = ( {} ) by L237 , FINSEQ_1:34;
thus L239: ( R20 ^ ( {} ) ) in ( D14 . R8 ) by L238 , L193;
end;
thus L240: thesis by L235 , L196 , L234;
end;

let C43 being set;
assume L241: C43 in { R17 where R17 is (Element of ( R16 * )) : (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R20 ^ R17 ) in ( D14 . R8 ))) };
consider R17 being (Element of ( R16 * )) such that L242: C43 = R17 and L243: (for R20 being (Element of ( R16 * )) holds (R20 in ( D14 . R9 ) implies ( R20 ^ R17 ) in ( D14 . R8 ))) by L241;
L244: ( {} ) in ( D14 . R9 ) by L193;
L245: ( ( {} ) ^ R17 ) in ( D14 . R8 ) by L244 , L243;
L246: R17 = ( {} ) by L245 , L189;
thus L247: thesis by L246 , L193 , L242;
end;

end;
end;
definition
struct (typealg) typestr(# carrier -> set , left_quotient , right_quotient , inner_product -> (BinOp of the carrier) , derivability -> (Relation of ( the carrier * ) , the carrier) #);
end;
registration
cluster non  empty  strict for typestr;
existence
proof
set D15 = the (BinOp of { ( {} ) });
set D16 = the (Relation of ( { ( {} ) } * ) , { ( {} ) });
take typestr (# { ( {} ) } , D15 , D15 , D15 , D16 #);
thus L234: (the carrier of typestr (# { ( {} ) } , D15 , D15 , D15 , D16 #)) is non  empty;
thus L235: thesis;
end;
end;
definition
let R21 being non  empty typestr;
let C44 being (FinSequence of R21);
let R22 being (type of R21);
pred C44 ==>. R22
means
:L237: [ C44 , R22 ] in (the derivability of R21)
;end;
definition
let C45 being non  empty typestr;
attr C45 is  SynTypes_Calculus-like
means
:L239: ((for B35 being (type of C45) holds <* B35 *> ==>. B35) & (for B36 being (FinSequence of C45) holds (for B37 , B38 being (type of C45) holds (( B36 ^ <* B38 *> ) ==>. B37 implies B36 ==>. ( B37 /" B38 )))) & (for B39 being (FinSequence of C45) holds (for B40 , B41 being (type of C45) holds (( <* B41 *> ^ B39 ) ==>. B40 implies B39 ==>. ( B41 \ B40 )))) & (for B42 , B43 , B44 being (FinSequence of C45) holds (for B45 , B46 , B47 being (type of C45) holds ((B42 ==>. B46 & ( ( B43 ^ <* B45 *> ) ^ B44 ) ==>. B47) implies ( ( ( B43 ^ <* ( B45 /" B46 ) *> ) ^ B42 ) ^ B44 ) ==>. B47))) & (for B48 , B49 , B50 being (FinSequence of C45) holds (for B51 , B52 , B53 being (type of C45) holds ((B48 ==>. B52 & ( ( B49 ^ <* B51 *> ) ^ B50 ) ==>. B53) implies ( ( ( B49 ^ B48 ) ^ <* ( B52 \ B51 ) *> ) ^ B50 ) ==>. B53))) & (for B54 , B55 being (FinSequence of C45) holds (for B56 , B57 , B58 being (type of C45) holds (( ( ( B54 ^ <* B56 *> ) ^ <* B57 *> ) ^ B55 ) ==>. B58 implies ( ( B54 ^ <* ( B56 * B57 ) *> ) ^ B55 ) ==>. B58))) & (for B59 , B60 being (FinSequence of C45) holds (for B61 , B62 being (type of C45) holds ((B59 ==>. B61 & B60 ==>. B62) implies ( B59 ^ B60 ) ==>. ( B61 * B62 )))));
end;
registration
cluster  SynTypes_Calculus-like for non  empty non  empty non  empty non  empty typestr;
existence
proof
L241: [: ( 1 * ) , 1 :] c= [: ( 1 * ) , 1 :];
reconsider D17 = [: ( 1 * ) , 1 :] as non  empty (Relation of ( 1 * ) , 1) by L241;
reconsider D18 = typestr (# 1 , ( op2 ) , ( op2 ) , ( op2 ) , D17 #) as non  empty typestr;
take D18;
L242: (for B63 being (type of D18) holds (for B64 being (FinSequence of D18) holds B64 ==>. B63))
proof
let C46 being (type of D18);
let C47 being (FinSequence of D18);
L243: [ C47 , C46 ] in [: ( 1 * ) , 1 :];
thus L244: thesis by L243 , L237;
end;
thus L245: (for B65 being (type of D18) holds <* B65 *> ==>. B65) by L242;
thus L246: thesis by L242;
end;
end;
definition
mode SynTypes_Calculus
 is  SynTypes_Calculus-like non  empty typestr;
end;
deffunc H4(typestr) = ( <*> (the carrier of $1) );
L249: (for R23 being SynTypes_Calculus holds (for R24 being (FinSequence of R23) holds (for R25 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ((R24 ==>. R28 & ( R25 ^ <* R27 *> ) ==>. R29) implies ( ( R25 ^ <* ( R27 /" R28 ) *> ) ^ R24 ) ==>. R29)))))))
proof
let R23 being SynTypes_Calculus;
let R24 being (FinSequence of R23);
let R25 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume that
L250: R24 ==>. R28
and
L251: ( R25 ^ <* R27 *> ) ==>. R29;
L252: ( ( R25 ^ <* R27 *> ) ^ H4(R23) ) ==>. R29 by L251 , FINSEQ_1:34;
L253: ( ( ( R25 ^ <* ( R27 /" R28 ) *> ) ^ R24 ) ^ H4(R23) ) ==>. R29 by L252 , L250 , L239;
thus L254: thesis by L253 , FINSEQ_1:34;
end;
L255: (for R23 being SynTypes_Calculus holds (for R24 being (FinSequence of R23) holds (for R26 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ((R24 ==>. R28 & ( <* R27 *> ^ R26 ) ==>. R29) implies ( ( <* ( R27 /" R28 ) *> ^ R24 ) ^ R26 ) ==>. R29)))))))
proof
let R23 being SynTypes_Calculus;
let R24 being (FinSequence of R23);
let R26 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume that
L256: R24 ==>. R28
and
L257: ( <* R27 *> ^ R26 ) ==>. R29;
L258: ( ( H4(R23) ^ <* R27 *> ) ^ R26 ) ==>. R29 by L257 , FINSEQ_1:34;
L259: ( ( ( H4(R23) ^ <* ( R27 /" R28 ) *> ) ^ R24 ) ^ R26 ) ==>. R29 by L258 , L256 , L239;
thus L260: thesis by L259 , FINSEQ_1:34;
end;
L261: (for R23 being SynTypes_Calculus holds (for R24 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ((R24 ==>. R28 & <* R27 *> ==>. R29) implies ( <* ( R27 /" R28 ) *> ^ R24 ) ==>. R29))))))
proof
let R23 being SynTypes_Calculus;
let R24 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume that
L262: R24 ==>. R28
and
L263: <* R27 *> ==>. R29;
L264: ( H4(R23) ^ <* R27 *> ) ==>. R29 by L263 , FINSEQ_1:34;
L265: ( ( H4(R23) ^ <* ( R27 /" R28 ) *> ) ^ R24 ) ==>. R29 by L264 , L262 , L249;
thus L266: thesis by L265 , FINSEQ_1:34;
end;
L267: (for R23 being SynTypes_Calculus holds (for R24 being (FinSequence of R23) holds (for R25 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ((R24 ==>. R28 & ( R25 ^ <* R27 *> ) ==>. R29) implies ( ( R25 ^ R24 ) ^ <* ( R28 \ R27 ) *> ) ==>. R29)))))))
proof
let R23 being SynTypes_Calculus;
let R24 being (FinSequence of R23);
let R25 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume that
L268: R24 ==>. R28
and
L269: ( R25 ^ <* R27 *> ) ==>. R29;
L270: ( ( R25 ^ <* R27 *> ) ^ H4(R23) ) ==>. R29 by L269 , FINSEQ_1:34;
L271: ( ( ( R25 ^ R24 ) ^ <* ( R28 \ R27 ) *> ) ^ H4(R23) ) ==>. R29 by L270 , L268 , L239;
thus L272: thesis by L271 , FINSEQ_1:34;
end;
L273: (for R23 being SynTypes_Calculus holds (for R24 being (FinSequence of R23) holds (for R26 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ((R24 ==>. R28 & ( <* R27 *> ^ R26 ) ==>. R29) implies ( ( R24 ^ <* ( R28 \ R27 ) *> ) ^ R26 ) ==>. R29)))))))
proof
let R23 being SynTypes_Calculus;
let R24 being (FinSequence of R23);
let R26 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume that
L274: R24 ==>. R28
and
L275: ( <* R27 *> ^ R26 ) ==>. R29;
L276: ( ( H4(R23) ^ <* R27 *> ) ^ R26 ) ==>. R29 by L275 , FINSEQ_1:34;
L277: ( ( ( H4(R23) ^ R24 ) ^ <* ( R28 \ R27 ) *> ) ^ R26 ) ==>. R29 by L276 , L274 , L239;
thus L278: thesis by L277 , FINSEQ_1:34;
end;
L279: (for R23 being SynTypes_Calculus holds (for R24 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ((R24 ==>. R28 & <* R27 *> ==>. R29) implies ( R24 ^ <* ( R28 \ R27 ) *> ) ==>. R29))))))
proof
let R23 being SynTypes_Calculus;
let R24 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume that
L280: R24 ==>. R28
and
L281: <* R27 *> ==>. R29;
L282: ( H4(R23) ^ <* R27 *> ) ==>. R29 by L281 , FINSEQ_1:34;
L283: ( ( H4(R23) ^ R24 ) ^ <* ( R28 \ R27 ) *> ) ==>. R29 by L282 , L280 , L267;
thus L284: thesis by L283 , FINSEQ_1:34;
end;
L285: (for R23 being SynTypes_Calculus holds (for R26 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds (( ( <* R27 *> ^ <* R28 *> ) ^ R26 ) ==>. R29 implies ( <* ( R27 * R28 ) *> ^ R26 ) ==>. R29))))))
proof
let R23 being SynTypes_Calculus;
let R26 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume L286: ( ( <* R27 *> ^ <* R28 *> ) ^ R26 ) ==>. R29;
L287: ( ( ( H4(R23) ^ <* R27 *> ) ^ <* R28 *> ) ^ R26 ) ==>. R29 by L286 , FINSEQ_1:34;
L288: ( ( H4(R23) ^ <* ( R27 * R28 ) *> ) ^ R26 ) ==>. R29 by L287 , L239;
thus L289: thesis by L288 , FINSEQ_1:34;
end;
L290: (for R23 being SynTypes_Calculus holds (for R25 being (FinSequence of R23) holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds (( ( R25 ^ <* R27 *> ) ^ <* R28 *> ) ==>. R29 implies ( R25 ^ <* ( R27 * R28 ) *> ) ==>. R29))))))
proof
let R23 being SynTypes_Calculus;
let R25 being (FinSequence of R23);
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume L291: ( ( R25 ^ <* R27 *> ) ^ <* R28 *> ) ==>. R29;
L292: ( ( ( R25 ^ <* R27 *> ) ^ <* R28 *> ) ^ H4(R23) ) ==>. R29 by L291 , FINSEQ_1:34;
L293: ( ( R25 ^ <* ( R27 * R28 ) *> ) ^ H4(R23) ) ==>. R29 by L292 , L239;
thus L294: thesis by L293 , FINSEQ_1:34;
end;
L295: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds (( <* R27 *> ^ <* R28 *> ) ==>. R29 implies <* ( R27 * R28 ) *> ==>. R29)))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume L296: ( <* R27 *> ^ <* R28 *> ) ==>. R29;
L297: ( ( H4(R23) ^ <* R27 *> ) ^ <* R28 *> ) ==>. R29 by L296 , FINSEQ_1:34;
L298: ( H4(R23) ^ <* ( R27 * R28 ) *> ) ==>. R29 by L297 , L290;
thus L299: thesis by L298 , FINSEQ_1:34;
end;
theorem
L300: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (( <* ( R27 /" R28 ) *> ^ <* R28 *> ) ==>. R27 & ( <* R28 *> ^ <* ( R28 \ R27 ) *> ) ==>. R27))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L301: <* R27 *> ==>. R27 by L239;
L302: <* R28 *> ==>. R28 by L239;
thus L303: thesis by L302 , L301 , L261 , L279;
end;
theorem
L304: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (<* R27 *> ==>. ( R28 /" ( R27 \ R28 ) ) & <* R27 *> ==>. ( ( R28 /" R27 ) \ R28 )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L305: ( <* ( R28 /" R27 ) *> ^ <* R27 *> ) ==>. R28 by L300;
L306: ( <* R27 *> ^ <* ( R27 \ R28 ) *> ) ==>. R28 by L300;
thus L307: thesis by L306 , L305 , L239;
end;
theorem
L308: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds <* ( R27 /" R28 ) *> ==>. ( ( R27 /" R29 ) /" ( R28 /" R29 ) )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
L309: ( <* ( R27 /" R28 ) *> ^ <* R28 *> ) ==>. R27 by L300;
L310: <* R29 *> ==>. R29 by L239;
L311: ( ( <* ( R27 /" R28 ) *> ^ <* ( R28 /" R29 ) *> ) ^ <* R29 *> ) ==>. R27 by L310 , L309 , L249;
L312: ( <* ( R27 /" R28 ) *> ^ <* ( R28 /" R29 ) *> ) ==>. ( R27 /" R29 ) by L311 , L239;
thus L313: thesis by L312 , L239;
end;
theorem
L314: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds <* ( R28 \ R27 ) *> ==>. ( ( R29 \ R28 ) \ ( R29 \ R27 ) )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
L315: ( <* R28 *> ^ <* ( R28 \ R27 ) *> ) ==>. R27 by L300;
L316: <* R29 *> ==>. R29 by L239;
L317: ( ( <* R29 *> ^ <* ( R29 \ R28 ) *> ) ^ <* ( R28 \ R27 ) *> ) ==>. R27 by L316 , L315 , L273;
L318: ( <* R29 *> ^ ( <* ( R29 \ R28 ) *> ^ <* ( R28 \ R27 ) *> ) ) ==>. R27 by L317 , FINSEQ_1:32;
L319: ( <* ( R29 \ R28 ) *> ^ <* ( R28 \ R27 ) *> ) ==>. ( R29 \ R27 ) by L318 , L239;
thus L320: thesis by L319 , L239;
end;
theorem
L321: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds (<* R27 *> ==>. R28 implies (<* ( R27 /" R29 ) *> ==>. ( R28 /" R29 ) & <* ( R29 \ R27 ) *> ==>. ( R29 \ R28 )))))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume L322: <* R27 *> ==>. R28;
L323: <* R29 *> ==>. R29 by L239;
L324: ( <* ( R27 /" R29 ) *> ^ <* R29 *> ) ==>. R28 by L323 , L322 , L261;
L325: ( <* R29 *> ^ <* ( R29 \ R27 ) *> ) ==>. R28 by L322 , L323 , L279;
thus L326: thesis by L325 , L324 , L239;
end;
theorem
L327: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds (<* R27 *> ==>. R28 implies (<* ( R29 /" R28 ) *> ==>. ( R29 /" R27 ) & <* ( R28 \ R29 ) *> ==>. ( R27 \ R29 )))))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
assume L328: <* R27 *> ==>. R28;
L329: <* R29 *> ==>. R29 by L239;
L330: ( <* ( R29 /" R28 ) *> ^ <* R27 *> ) ==>. R29 by L329 , L328 , L261;
L331: ( <* R27 *> ^ <* ( R28 \ R29 ) *> ) ==>. R29 by L328 , L329 , L279;
thus L332: thesis by L331 , L330 , L239;
end;
theorem
L333: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds <* ( R28 /" ( ( R28 /" R27 ) \ R28 ) ) *> ==>. ( R28 /" R27 ))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L334: <* R27 *> ==>. ( ( R28 /" R27 ) \ R28 ) by L304;
thus L335: thesis by L334 , L327;
end;
theorem
L336: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (<* R27 *> ==>. R28 implies (( <*> (the carrier of R23) ) ==>. ( R28 /" R27 ) & ( <*> (the carrier of R23) ) ==>. ( R27 \ R28 ))))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
assume L337: <* R27 *> ==>. R28;
L338: ( H4(R23) ^ <* R27 *> ) = <* R27 *> by FINSEQ_1:34;
L339: ( <* R27 *> ^ H4(R23) ) = <* R27 *> by FINSEQ_1:34;
thus L340: thesis by L339 , L337 , L338 , L239;
end;
theorem
L341: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (( <*> (the carrier of R23) ) ==>. ( R27 /" R27 ) & ( <*> (the carrier of R23) ) ==>. ( R27 \ R27 ))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
L342: <* R27 *> ==>. R27 by L239;
thus L343: thesis by L342 , L336;
end;
theorem
L344: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (( <*> (the carrier of R23) ) ==>. ( ( R28 /" ( R27 \ R28 ) ) /" R27 ) & ( <*> (the carrier of R23) ) ==>. ( R27 \ ( ( R28 /" R27 ) \ R28 ) )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L345: <* R27 *> ==>. ( R28 /" ( R27 \ R28 ) ) by L304;
L346: <* R27 *> ==>. ( ( R28 /" R27 ) \ R28 ) by L304;
thus L347: thesis by L346 , L345 , L336;
end;
theorem
L348: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds (( <*> (the carrier of R23) ) ==>. ( ( ( R27 /" R29 ) /" ( R28 /" R29 ) ) /" ( R27 /" R28 ) ) & ( <*> (the carrier of R23) ) ==>. ( ( R28 \ R27 ) \ ( ( R29 \ R28 ) \ ( R29 \ R27 ) ) ))))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
L349: <* ( R27 /" R28 ) *> ==>. ( ( R27 /" R29 ) /" ( R28 /" R29 ) ) by L308;
L350: <* ( R28 \ R27 ) *> ==>. ( ( R29 \ R28 ) \ ( R29 \ R27 ) ) by L314;
thus L351: thesis by L350 , L349 , L336;
end;
theorem
L352: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (( <*> (the carrier of R23) ) ==>. R27 implies (( <*> (the carrier of R23) ) ==>. ( R28 /" ( R28 /" R27 ) ) & ( <*> (the carrier of R23) ) ==>. ( ( R27 \ R28 ) \ R28 ))))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L353: <* R28 *> ==>. R28 by L239;
L354: ( H4(R23) ^ <* R28 *> ) ==>. R28 by L353 , FINSEQ_1:34;
L355: ( <* R28 *> ^ H4(R23) ) ==>. R28 by L353 , FINSEQ_1:34;
assume L356: H4(R23) ==>. R27;
L357: ( ( H4(R23) ^ <* ( R28 /" R27 ) *> ) ^ H4(R23) ) ==>. R28 by L356 , L354 , L249;
L358: ( ( H4(R23) ^ <* ( R27 \ R28 ) *> ) ^ H4(R23) ) ==>. R28 by L355 , L356 , L273;
L359: ( H4(R23) ^ <* ( R28 /" R27 ) *> ) ==>. R28 by L357 , FINSEQ_1:34;
L360: ( <* ( R27 \ R28 ) *> ^ H4(R23) ) ==>. R28 by L358 , FINSEQ_1:34;
thus L361: thesis by L360 , L359 , L239;
end;
theorem
L362: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds <* ( R27 /" ( R28 /" R28 ) ) *> ==>. R27)))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L363: <* R27 *> ==>. R27 by L239;
L364: ( <* ( R27 /" ( R28 /" R28 ) ) *> ^ H4(R23) ) ==>. R27 by L363 , L261 , L341;
thus L365: thesis by L364 , FINSEQ_1:34;
end;
definition
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
pred R27 <==>. R28
means
:L366: (<* R27 *> ==>. R28 & <* R28 *> ==>. R27)
;reflexivity
 by L239;
symmetry
;
end;
theorem
L368: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds ( R27 /" R28 ) <==>. ( R27 /" ( ( R27 /" R28 ) \ R27 ) ))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L369: <* ( R27 /" R28 ) *> ==>. ( R27 /" ( ( R27 /" R28 ) \ R27 ) ) by L304;
L370: <* ( R27 /" ( ( R27 /" R28 ) \ R27 ) ) *> ==>. ( R27 /" R28 ) by L333;
thus L371: thesis by L370 , L369 , L366;
end;
theorem
L372: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ( R27 /" ( R29 * R28 ) ) <==>. ( ( R27 /" R28 ) /" R29 )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
L373: <* R29 *> ==>. R29 by L239;
L374: <* R28 *> ==>. R28 by L239;
L375: <* R27 *> ==>. R27 by L239;
L376: ( <* R29 *> ^ <* R28 *> ) ==>. ( R29 * R28 ) by L373 , L374 , L239;
L377: ( <* ( R27 /" ( R29 * R28 ) ) *> ^ ( <* R29 *> ^ <* R28 *> ) ) ==>. R27 by L376 , L375 , L261;
L378: ( ( <* ( R27 /" ( R29 * R28 ) ) *> ^ <* R29 *> ) ^ <* R28 *> ) ==>. R27 by L377 , FINSEQ_1:32;
L379: ( <* ( R27 /" ( R29 * R28 ) ) *> ^ <* R29 *> ) ==>. ( R27 /" R28 ) by L378 , L239;
L380: <* ( R27 /" ( R29 * R28 ) ) *> ==>. ( ( R27 /" R28 ) /" R29 ) by L379 , L239;
L381: ( <* ( R27 /" R28 ) *> ^ <* R28 *> ) ==>. R27 by L374 , L375 , L261;
L382: ( ( <* ( ( R27 /" R28 ) /" R29 ) *> ^ <* R29 *> ) ^ <* R28 *> ) ==>. R27 by L381 , L373 , L255;
L383: ( <* ( ( R27 /" R28 ) /" R29 ) *> ^ <* ( R29 * R28 ) *> ) ==>. R27 by L382 , L290;
L384: <* ( ( R27 /" R28 ) /" R29 ) *> ==>. ( R27 /" ( R29 * R28 ) ) by L383 , L239;
thus L385: thesis by L384 , L380 , L366;
end;
theorem
L386: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds <* ( R27 * ( R28 /" R29 ) ) *> ==>. ( ( R27 * R28 ) /" R29 )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
L387: <* R27 *> ==>. R27 by L239;
L388: <* R28 *> ==>. R28 by L239;
L389: ( <* R27 *> ^ <* R28 *> ) ==>. ( R27 * R28 ) by L388 , L387 , L239;
L390: <* R29 *> ==>. R29 by L239;
L391: ( ( <* R27 *> ^ <* ( R28 /" R29 ) *> ) ^ <* R29 *> ) ==>. ( R27 * R28 ) by L390 , L389 , L249;
L392: ( <* ( R27 * ( R28 /" R29 ) ) *> ^ <* R29 *> ) ==>. ( R27 * R28 ) by L391 , L285;
thus L393: thesis by L392 , L239;
end;
theorem
L394: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (<* R27 *> ==>. ( ( R27 * R28 ) /" R28 ) & <* R27 *> ==>. ( R28 \ ( R28 * R27 ) )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
L395: <* R27 *> ==>. R27 by L239;
L396: <* R28 *> ==>. R28 by L239;
L397: ( <* R27 *> ^ <* R28 *> ) ==>. ( R27 * R28 ) by L396 , L395 , L239;
L398: ( <* R28 *> ^ <* R27 *> ) ==>. ( R28 * R27 ) by L395 , L396 , L239;
thus L399: thesis by L398 , L397 , L239;
end;
theorem
L400: (for R23 being SynTypes_Calculus holds (for R27 being (type of R23) holds (for R28 being (type of R23) holds (for R29 being (type of R23) holds ( ( R27 * R28 ) * R29 ) <==>. ( R27 * ( R28 * R29 ) )))))
proof
let R23 being SynTypes_Calculus;
let R27 being (type of R23);
let R28 being (type of R23);
let R29 being (type of R23);
L401: <* R27 *> ==>. R27 by L239;
L402: <* R28 *> ==>. R28 by L239;
L403: <* R29 *> ==>. R29 by L239;
L404: ( <* R27 *> ^ <* R28 *> ) ==>. ( R27 * R28 ) by L401 , L402 , L239;
L405: ( ( <* R27 *> ^ <* R28 *> ) ^ <* R29 *> ) ==>. ( ( R27 * R28 ) * R29 ) by L404 , L403 , L239;
L406: ( <* R27 *> ^ <* ( R28 * R29 ) *> ) ==>. ( ( R27 * R28 ) * R29 ) by L405 , L290;
L407: <* ( R27 * ( R28 * R29 ) ) *> ==>. ( ( R27 * R28 ) * R29 ) by L406 , L295;
L408: ( <* R28 *> ^ <* R29 *> ) ==>. ( R28 * R29 ) by L402 , L403 , L239;
L409: ( <* R27 *> ^ ( <* R28 *> ^ <* R29 *> ) ) ==>. ( R27 * ( R28 * R29 ) ) by L408 , L401 , L239;
L410: ( ( <* R27 *> ^ <* R28 *> ) ^ <* R29 *> ) ==>. ( R27 * ( R28 * R29 ) ) by L409 , FINSEQ_1:32;
L411: ( <* ( R27 * R28 ) *> ^ <* R29 *> ) ==>. ( R27 * ( R28 * R29 ) ) by L410 , L285;
L412: <* ( ( R27 * R28 ) * R29 ) *> ==>. ( R27 * ( R28 * R29 ) ) by L411 , L295;
thus L413: thesis by L412 , L407 , L366;
end;
