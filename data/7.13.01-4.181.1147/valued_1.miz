:: Properties of Number-Valued Functions
::  by Library Committee
::
:: Received December 18, 2007
:: Copyright (c) 2007-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSEQ_1, FUNCT_1, RELAT_1, XBOOLE_0, ORDINAL1,
      XXREAL_0, VALUED_0, RAT_1, COMPLEX1, ARYTM_1, ARYTM_3, MEMBERED,
      PARTFUN1, TARSKI, SUBSET_1, CARD_1, XCMPLX_0, XREAL_0, INT_1, SQUARE_1,
      FUNCT_4, FINSET_1, NAT_1, ORDINAL2, VALUED_1, AMISTD_1, FUNCOP_1,
      AMISTD_2, AMISTD_3;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, FINSET_1, CARD_1, XCMPLX_0,
      NUMBERS, COMPLEX1, XXREAL_0, XXREAL_2, FUNCOP_1, XREAL_0, RAT_1, INT_1,
      INT_2, SQUARE_1, RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, FUNCT_4,
      FINSEQ_1, MEMBERED, NAT_1, VALUED_0;
 constructors PARTFUN1, RAT_1, VALUED_0, SQUARE_1, MEMBERED, INT_2, FINSEQ_1,
      NAT_1, FUNCT_4, NAT_D, RELSET_1, XXREAL_2, FUNCOP_1, DOMAIN_1, WELLORD2;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FUNCT_2, NUMBERS, XREAL_0,
      MEMBERED, VALUED_0, RAT_1, INT_1, NAT_1, FUNCT_1, FINSET_1, XXREAL_0,
      RELAT_1, XXREAL_2, FUNCOP_1, REALSET1, FUNCT_4, CARD_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, RELAT_1, XCMPLX_0, SQUARE_1, FUNCT_1, FUNCT_2,
      FINSEQ_1, VALUED_0, WELLORD2, FUNCOP_1;
 theorems FUNCT_1, FUNCT_2, RELSET_1, PARTFUN1, VALUED_0, COMPLEX1, FINSEQ_1,
      XBOOLE_0, TARSKI, GRFUNC_1, RELAT_1, FUNCT_4, FINSET_1, NAT_1, INT_1,
      ORDINAL1, XXREAL_0, FUNCOP_1, ZFMISC_1, XXREAL_2, XBOOLE_1, CARD_1,
      CARD_2, RAT_1, XTUPLE_0;
 schemes FUNCT_1, CLASSES1, FRAENKEL, RECDEF_1, NAT_1;

begin
L1: (for B1 being FinSequence holds (for B2 being Function holds (( dom B2 ) = ( dom B1 ) implies B2 is FinSequence)))
proof
let C1 being FinSequence;
let C2 being Function;
assume that
L2: ( dom C2 ) = ( dom C1 );
L3: C2 is  FinSequence-like
proof
take ( len C1 );
thus L4: thesis by L2 , FINSEQ_1:def 3;
end;
thus L5: thesis by L3;
end;
L6: (for B3 , B4 being FinSequence holds (for B5 being Function holds (( dom B5 ) = ( ( dom B3 ) /\ ( dom B4 ) ) implies B5 is FinSequence)))
proof
let C3 , C4 being FinSequence;
let C5 being Function;
assume that
L7: ( dom C5 ) = ( ( dom C3 ) /\ ( dom C4 ) );
consider C6 being Nat such that L8: ( dom C3 ) = ( Seg C6 ) by FINSEQ_1:def 2;
consider C7 being Nat such that L9: ( dom C4 ) = ( Seg C7 ) by FINSEQ_1:def 2;
L10: C5 is  FinSequence-like
proof
per cases ;
suppose L11: C6 <= C7;

take C6;
thus L12: thesis by L7 , L8 , L9 , L11 , FINSEQ_1:7;
end;
suppose L13: C7 <= C6;

take C7;
thus L14: thesis by L7 , L8 , L9 , L13 , FINSEQ_1:7;
end;
end;
thus L16: thesis by L10;
end;
registration
cluster  complex-valued for FinSequence;
existence
proof
take ( <*> ( COMPLEX ) );
thus L17: thesis;
end;
end;
registration
let C8 being  rational number;
cluster |. C8 .| ->  rational;
coherence
proof
L19: (|. C8 .| = ( - C8 ) or |. C8 .| = C8) by COMPLEX1:71;
thus L20: thesis by L19;
end;
end;
definition
let C9 , C10 being  complex-valued Function;
deffunc H1(set) = ( ( C9 . $1 ) + ( C10 . $1 ) );
set D1 = ( ( dom C9 ) /\ ( dom C10 ) );
func C9 + C10 -> Function means 
:L22: (( dom it ) = ( ( dom C9 ) /\ ( dom C10 ) ) & (for B6 being set holds (B6 in ( dom it ) implies ( it . B6 ) = ( ( C9 . B6 ) + ( C10 . B6 ) ))));
existence
proof
L23: (ex B7 being Function st (( dom B7 ) = D1 & (for B8 being set holds (B8 in D1 implies ( B7 . B8 ) = H1(B8))))) from FUNCT_1:sch 3;
thus L24: thesis by L23;
end;
uniqueness
proof
let C11 , C12 being Function;
assume that
L25: ( dom C11 ) = D1
and
L26: (for B9 being set holds (B9 in ( dom C11 ) implies ( C11 . B9 ) = H1(B9)))
and
L27: ( dom C12 ) = D1
and
L28: (for B10 being set holds (B10 in ( dom C12 ) implies ( C12 . B10 ) = H1(B10)));
L29:
now
let C13 being set;
assume L30: C13 in ( dom C11 );
thus L31: ( C11 . C13 ) = H1(C13) by L30 , L26
.= ( C12 . C13 ) by L25 , L27 , L28 , L30;
end;
thus L32: thesis by L29 , L25 , L27 , FUNCT_1:2;
end;
commutativity
;
end;
registration
let C14 , C15 being  complex-valued Function;
cluster ( C14 + C15 ) ->  complex-valued;
coherence
proof
let C16 being set;
assume L34: C16 in ( dom ( C14 + C15 ) );
L35: ( ( C14 + C15 ) . C16 ) = ( ( C14 . C16 ) + ( C15 . C16 ) ) by L34 , L22;
thus L36: thesis by L35;
end;
end;
registration
let C17 , C18 being  real-valued Function;
cluster ( C17 + C18 ) ->  real-valued;
coherence
proof
let C19 being set;
assume L38: C19 in ( dom ( C17 + C18 ) );
L39: ( ( C17 + C18 ) . C19 ) = ( ( C17 . C19 ) + ( C18 . C19 ) ) by L38 , L22;
thus L40: thesis by L39;
end;
end;
registration
let C20 , C21 being ( RAT ) -valued Function;
cluster ( C20 + C21 ) -> ( RAT ) -valued;
coherence
proof
let C22 being set;
assume L42: C22 in ( rng ( C20 + C21 ) );
consider C23 being set such that L43: C23 in ( dom ( C20 + C21 ) ) and L44: ( ( C20 + C21 ) . C23 ) = C22 by L42 , FUNCT_1:def 3;
L45: ( ( C20 + C21 ) . C23 ) = ( ( C20 . C23 ) + ( C21 . C23 ) ) by L43 , L22;
thus L46: thesis by L45 , L44 , RAT_1:def 2;
end;
end;
registration
let C24 , C25 being ( INT ) -valued Function;
cluster ( C24 + C25 ) -> ( INT ) -valued;
coherence
proof
let C26 being set;
assume L48: C26 in ( rng ( C24 + C25 ) );
consider C27 being set such that L49: C27 in ( dom ( C24 + C25 ) ) and L50: ( ( C24 + C25 ) . C27 ) = C26 by L48 , FUNCT_1:def 3;
L51: ( ( C24 + C25 ) . C27 ) = ( ( C24 . C27 ) + ( C25 . C27 ) ) by L49 , L22;
thus L52: thesis by L51 , L50 , INT_1:def 2;
end;
end;
registration
let C28 , C29 being  natural-valued Function;
cluster ( C28 + C29 ) ->  natural-valued;
coherence
proof
let C30 being set;
assume L54: C30 in ( dom ( C28 + C29 ) );
L55: ( ( C28 + C29 ) . C30 ) = ( ( C28 . C30 ) + ( C29 . C30 ) ) by L54 , L22;
thus L56: thesis by L55;
end;
end;
definition
let C31 being set;
let C32 , C33 being  complex-membered set;
let C34 being (PartFunc of C31 , C32);
let C35 being (PartFunc of C31 , C33);
redefine func C34 + C35 -> (PartFunc of C31 , ( COMPLEX ));

coherence
proof
L58: (( dom ( C34 + C35 ) ) = ( ( dom C34 ) /\ ( dom C35 ) ) & ( rng ( C34 + C35 ) ) c= ( COMPLEX )) by L22 , VALUED_0:def 1;
thus L59: thesis by L58 , RELSET_1:4;
end;
end;
definition
let C36 being set;
let C37 , C38 being  real-membered set;
let C39 being (PartFunc of C36 , C37);
let C40 being (PartFunc of C36 , C38);
redefine func C39 + C40 -> (PartFunc of C36 , ( REAL ));

coherence
proof
L61: (( dom ( C39 + C40 ) ) = ( ( dom C39 ) /\ ( dom C40 ) ) & ( rng ( C39 + C40 ) ) c= ( REAL )) by L22 , VALUED_0:def 3;
thus L62: thesis by L61 , RELSET_1:4;
end;
end;
definition
let C41 being set;
let C42 , C43 being  rational-membered set;
let C44 being (PartFunc of C41 , C42);
let C45 being (PartFunc of C41 , C43);
redefine func C44 + C45 -> (PartFunc of C41 , ( RAT ));

coherence
proof
L64: (( dom ( C44 + C45 ) ) = ( ( dom C44 ) /\ ( dom C45 ) ) & ( rng ( C44 + C45 ) ) c= ( RAT )) by L22 , RELAT_1:def 19;
thus L65: thesis by L64 , RELSET_1:4;
end;
end;
definition
let C46 being set;
let C47 , C48 being  integer-membered set;
let C49 being (PartFunc of C46 , C47);
let C50 being (PartFunc of C46 , C48);
redefine func C49 + C50 -> (PartFunc of C46 , ( INT ));

coherence
proof
L67: (( dom ( C49 + C50 ) ) = ( ( dom C49 ) /\ ( dom C50 ) ) & ( rng ( C49 + C50 ) ) c= ( INT )) by L22 , RELAT_1:def 19;
thus L68: thesis by L67 , RELSET_1:4;
end;
end;
definition
let C51 being set;
let C52 , C53 being  natural-membered set;
let C54 being (PartFunc of C51 , C52);
let C55 being (PartFunc of C51 , C53);
redefine func C54 + C55 -> (PartFunc of C51 , ( NAT ));

coherence
proof
L70: (( dom ( C54 + C55 ) ) = ( ( dom C54 ) /\ ( dom C55 ) ) & ( rng ( C54 + C55 ) ) c= ( NAT )) by L22 , VALUED_0:def 6;
thus L71: thesis by L70 , RELSET_1:4;
end;
end;
registration
let C56 being set;
let C57 , C58 being  complex-membered non  empty set;
let C59 being (Function of C56 , C57);
let C60 being (Function of C56 , C58);
cluster ( C59 + C60 ) ->  total for (PartFunc of C56 , ( COMPLEX ));
coherence
proof
L73: (( dom C59 ) = C56 & ( dom C60 ) = C56) by FUNCT_2:def 1;
L74: ( dom ( C59 + C60 ) ) = ( C56 /\ C56 ) by L73 , L22
.= C56;
thus L75: thesis by L74 , PARTFUN1:def 2;
end;
end;
registration
let C61 being set;
let C62 , C63 being  real-membered non  empty set;
let C64 being (Function of C61 , C62);
let C65 being (Function of C61 , C63);
cluster ( C64 + C65 ) ->  total for (PartFunc of C61 , ( REAL ));
coherence
proof
L77: (( dom C64 ) = C61 & ( dom C65 ) = C61) by FUNCT_2:def 1;
L78: ( dom ( C64 + C65 ) ) = ( C61 /\ C61 ) by L77 , L22
.= C61;
thus L79: thesis by L78 , PARTFUN1:def 2;
end;
end;
registration
let C66 being set;
let C67 , C68 being  rational-membered non  empty set;
let C69 being (Function of C66 , C67);
let C70 being (Function of C66 , C68);
cluster ( C69 + C70 ) ->  total for (PartFunc of C66 , ( RAT ));
coherence
proof
L81: (( dom C69 ) = C66 & ( dom C70 ) = C66) by FUNCT_2:def 1;
L82: ( dom ( C69 + C70 ) ) = ( C66 /\ C66 ) by L81 , L22
.= C66;
thus L83: thesis by L82 , PARTFUN1:def 2;
end;
end;
registration
let C71 being set;
let C72 , C73 being  integer-membered non  empty set;
let C74 being (Function of C71 , C72);
let C75 being (Function of C71 , C73);
cluster ( C74 + C75 ) ->  total for (PartFunc of C71 , ( INT ));
coherence
proof
L85: (( dom C74 ) = C71 & ( dom C75 ) = C71) by FUNCT_2:def 1;
L86: ( dom ( C74 + C75 ) ) = ( C71 /\ C71 ) by L85 , L22
.= C71;
thus L87: thesis by L86 , PARTFUN1:def 2;
end;
end;
registration
let C76 being set;
let C77 , C78 being  natural-membered non  empty set;
let C79 being (Function of C76 , C77);
let C80 being (Function of C76 , C78);
cluster ( C79 + C80 ) ->  total for (PartFunc of C76 , ( NAT ));
coherence
proof
L89: (( dom C79 ) = C76 & ( dom C80 ) = C76) by FUNCT_2:def 1;
L90: ( dom ( C79 + C80 ) ) = ( C76 /\ C76 ) by L89 , L22
.= C76;
thus L91: thesis by L90 , PARTFUN1:def 2;
end;
end;
theorem
L93: (for B11 being set holds (for B12 , B13 being  complex-membered non  empty set holds (for B14 being (Function of B11 , B12) holds (for B15 being (Function of B11 , B13) holds (for B16 being (Element of B11) holds ( ( B14 + B15 ) . B16 ) = ( ( B14 . B16 ) + ( B15 . B16 ) ))))))
proof
let C81 being set;
let C82 , C83 being  complex-membered non  empty set;
let C84 being (Function of C81 , C82);
let C85 being (Function of C81 , C83);
L94: ( dom ( C84 + C85 ) ) = C81 by FUNCT_2:def 1;
let C86 being (Element of C81);
per cases ;
suppose L95: C81 is non  empty;

thus L96: thesis by L95 , L94 , L22;
end;
suppose L97: C81 is  empty;

L98: ( dom C84 ) = ( {} ) by L97;
L99: ( C84 . C86 ) = ( 0 ) by L98 , FUNCT_1:def 2;
thus L100: thesis by L99 , L97;
end;
end;
registration
let C87 , C88 being  complex-valued FinSequence;
cluster ( C87 + C88 ) ->  FinSequence-like;
coherence
proof
L102: ( dom ( C87 + C88 ) ) = ( ( dom C87 ) /\ ( dom C88 ) ) by L22;
thus L103: thesis by L102 , L6;
end;
end;
begin
definition
let C89 being  complex-valued Function;
let C90 being  complex number;
deffunc H2(set) = ( C90 + ( C89 . $1 ) );
func C90 + C89 -> Function means 
:L105: (( dom it ) = ( dom C89 ) & (for B17 being set holds (B17 in ( dom it ) implies ( it . B17 ) = ( C90 + ( C89 . B17 ) ))));
existence
proof
L106: (ex B18 being Function st (( dom B18 ) = ( dom C89 ) & (for B19 being set holds (B19 in ( dom C89 ) implies ( B18 . B19 ) = H2(B19))))) from FUNCT_1:sch 3;
thus L107: thesis by L106;
end;
uniqueness
proof
let C91 , C92 being Function;
assume that
L108: ( dom C91 ) = ( dom C89 )
and
L109: (for B20 being set holds (B20 in ( dom C91 ) implies ( C91 . B20 ) = H2(B20)))
and
L110: ( dom C92 ) = ( dom C89 )
and
L111: (for B21 being set holds (B21 in ( dom C92 ) implies ( C92 . B21 ) = H2(B21)));
L112:
now
let C93 being set;
assume L113: C93 in ( dom C91 );
thus L114: ( C91 . C93 ) = H2(C93) by L113 , L109
.= ( C92 . C93 ) by L108 , L110 , L111 , L113;
end;
thus L115: thesis by L112 , L108 , L110 , FUNCT_1:2;
end;
end;
notation
let C94 being  complex-valued Function;
let C95 being  complex number;
synonym C94 + C95 for C95 + C94;
end;
registration
let C96 being  complex-valued Function;
let C97 being  complex number;
cluster ( C97 + C96 ) ->  complex-valued;
coherence
proof
let C98 being set;
assume L118: C98 in ( dom ( C97 + C96 ) );
L119: ( ( C97 + C96 ) . C98 ) = ( C97 + ( C96 . C98 ) ) by L118 , L105;
thus L120: thesis by L119;
end;
end;
registration
let C99 being  real-valued Function;
let C100 being  real number;
cluster ( C100 + C99 ) ->  real-valued;
coherence
proof
let C101 being set;
assume L122: C101 in ( dom ( C100 + C99 ) );
L123: ( ( C100 + C99 ) . C101 ) = ( C100 + ( C99 . C101 ) ) by L122 , L105;
thus L124: thesis by L123;
end;
end;
registration
let C102 being ( RAT ) -valued Function;
let C103 being  rational number;
cluster ( C103 + C102 ) -> ( RAT ) -valued;
coherence
proof
let C104 being set;
assume L126: C104 in ( rng ( C103 + C102 ) );
consider C105 being set such that L127: C105 in ( dom ( C103 + C102 ) ) and L128: ( ( C103 + C102 ) . C105 ) = C104 by L126 , FUNCT_1:def 3;
L129: ( ( C103 + C102 ) . C105 ) = ( C103 + ( C102 . C105 ) ) by L127 , L105;
thus L130: thesis by L129 , L128 , RAT_1:def 2;
end;
end;
registration
let C106 being ( INT ) -valued Function;
let C107 being  integer number;
cluster ( C107 + C106 ) -> ( INT ) -valued;
coherence
proof
let C108 being set;
assume L132: C108 in ( rng ( C107 + C106 ) );
consider C109 being set such that L133: C109 in ( dom ( C107 + C106 ) ) and L134: ( ( C107 + C106 ) . C109 ) = C108 by L132 , FUNCT_1:def 3;
L135: ( ( C107 + C106 ) . C109 ) = ( C107 + ( C106 . C109 ) ) by L133 , L105;
thus L136: thesis by L135 , L134 , INT_1:def 2;
end;
end;
registration
let C110 being  natural-valued Function;
let C111 being Nat;
cluster ( C111 + C110 ) ->  natural-valued;
coherence
proof
let C112 being set;
assume L138: C112 in ( dom ( C111 + C110 ) );
L139: ( ( C111 + C110 ) . C112 ) = ( C111 + ( C110 . C112 ) ) by L138 , L105;
thus L140: thesis by L139;
end;
end;
definition
let C113 being set;
let C114 being  complex-membered set;
let C115 being (PartFunc of C113 , C114);
let C116 being  complex number;
redefine func C116 + C115 -> (PartFunc of C113 , ( COMPLEX ));

coherence
proof
L142: (( dom ( C116 + C115 ) ) = ( dom C115 ) & ( rng ( C116 + C115 ) ) c= ( COMPLEX )) by L105 , VALUED_0:def 1;
thus L143: thesis by L142 , RELSET_1:4;
end;
end;
definition
let C117 being set;
let C118 being  real-membered set;
let C119 being (PartFunc of C117 , C118);
let C120 being  real number;
redefine func C120 + C119 -> (PartFunc of C117 , ( REAL ));

coherence
proof
L145: (( dom ( C120 + C119 ) ) = ( dom C119 ) & ( rng ( C120 + C119 ) ) c= ( REAL )) by L105 , VALUED_0:def 3;
thus L146: thesis by L145 , RELSET_1:4;
end;
end;
definition
let C121 being set;
let C122 being  rational-membered set;
let C123 being (PartFunc of C121 , C122);
let C124 being  rational number;
redefine func C124 + C123 -> (PartFunc of C121 , ( RAT ));

coherence
proof
L148: (( dom ( C124 + C123 ) ) = ( dom C123 ) & ( rng ( C124 + C123 ) ) c= ( RAT )) by L105 , RELAT_1:def 19;
thus L149: thesis by L148 , RELSET_1:4;
end;
end;
definition
let C125 being set;
let C126 being  integer-membered set;
let C127 being (PartFunc of C125 , C126);
let C128 being  integer number;
redefine func C128 + C127 -> (PartFunc of C125 , ( INT ));

coherence
proof
L151: (( dom ( C128 + C127 ) ) = ( dom C127 ) & ( rng ( C128 + C127 ) ) c= ( INT )) by L105 , RELAT_1:def 19;
thus L152: thesis by L151 , RELSET_1:4;
end;
end;
definition
let C129 being set;
let C130 being  natural-membered set;
let C131 being (PartFunc of C129 , C130);
let C132 being Nat;
redefine func C132 + C131 -> (PartFunc of C129 , ( NAT ));

coherence
proof
L154: (( dom ( C132 + C131 ) ) = ( dom C131 ) & ( rng ( C132 + C131 ) ) c= ( NAT )) by L105 , VALUED_0:def 6;
thus L155: thesis by L154 , RELSET_1:4;
end;
end;
registration
let C133 being set;
let C134 being  complex-membered non  empty set;
let C135 being (Function of C133 , C134);
let C136 being  complex number;
cluster ( C136 + C135 ) ->  total for (PartFunc of C133 , ( COMPLEX ));
coherence
proof
L157: ( dom ( C136 + C135 ) ) = ( dom C135 ) by L105
.= C133 by FUNCT_2:def 1;
thus L158: thesis by L157 , PARTFUN1:def 2;
end;
end;
registration
let C137 being set;
let C138 being  real-membered non  empty set;
let C139 being (Function of C137 , C138);
let C140 being  real number;
cluster ( C140 + C139 ) ->  total for (PartFunc of C137 , ( REAL ));
coherence
proof
L160: ( dom ( C140 + C139 ) ) = ( dom C139 ) by L105
.= C137 by FUNCT_2:def 1;
thus L161: thesis by L160 , PARTFUN1:def 2;
end;
end;
registration
let C141 being set;
let C142 being  rational-membered non  empty set;
let C143 being (Function of C141 , C142);
let C144 being  rational number;
cluster ( C144 + C143 ) ->  total for (PartFunc of C141 , ( RAT ));
coherence
proof
L163: ( dom ( C144 + C143 ) ) = ( dom C143 ) by L105
.= C141 by FUNCT_2:def 1;
thus L164: thesis by L163 , PARTFUN1:def 2;
end;
end;
registration
let C145 being set;
let C146 being  integer-membered non  empty set;
let C147 being (Function of C145 , C146);
let C148 being  integer number;
cluster ( C148 + C147 ) ->  total for (PartFunc of C145 , ( INT ));
coherence
proof
L166: ( dom ( C148 + C147 ) ) = ( dom C147 ) by L105
.= C145 by FUNCT_2:def 1;
thus L167: thesis by L166 , PARTFUN1:def 2;
end;
end;
registration
let C149 being set;
let C150 being  natural-membered non  empty set;
let C151 being (Function of C149 , C150);
let C152 being Nat;
cluster ( C152 + C151 ) ->  total for (PartFunc of C149 , ( NAT ));
coherence
proof
L169: ( dom ( C152 + C151 ) ) = ( dom C151 ) by L105
.= C149 by FUNCT_2:def 1;
thus L170: thesis by L169 , PARTFUN1:def 2;
end;
end;
theorem
L172: (for B22 being non  empty set holds (for B23 being  complex-membered non  empty set holds (for B24 being (Function of B22 , B23) holds (for B25 being  complex number holds (for B26 being (Element of B22) holds ( ( B25 + B24 ) . B26 ) = ( B25 + ( B24 . B26 ) ))))))
proof
let C153 being non  empty set;
let C154 being  complex-membered non  empty set;
let C155 being (Function of C153 , C154);
let C156 being  complex number;
L173: ( dom ( C156 + C155 ) ) = C153 by FUNCT_2:def 1;
thus L174: thesis by L173 , L105;
end;
registration
let C157 being  complex-valued FinSequence;
let C158 being  complex number;
cluster ( C158 + C157 ) ->  FinSequence-like;
coherence
proof
L175: ( dom ( C158 + C157 ) ) = ( dom C157 ) by L105;
thus L176: thesis by L175 , L1;
end;
end;
begin
definition
let C159 being  complex-valued Function;
let C160 being  complex number;
func C159 - C160 -> Function equals 
( ( - C160 ) + C159 );
coherence;
end;
theorem
L179: (for B27 being  complex-valued Function holds (for B28 being  complex number holds (( dom ( B27 - B28 ) ) = ( dom B27 ) & (for B29 being set holds (B29 in ( dom B27 ) implies ( ( B27 - B28 ) . B29 ) = ( ( B27 . B29 ) - B28 ))))))
proof
let C161 being  complex-valued Function;
let C162 being  complex number;
L180: ( dom ( C161 - C162 ) ) = ( dom C161 ) by L105;
thus L181: thesis by L180 , L105;
end;
registration
let C163 being  complex-valued Function;
let C164 being  complex number;
cluster ( C163 - C164 ) ->  complex-valued;
coherence;
end;
registration
let C165 being  real-valued Function;
let C166 being  real number;
cluster ( C165 - C166 ) ->  real-valued;
coherence;
end;
registration
let C167 being ( RAT ) -valued Function;
let C168 being  rational number;
cluster ( C167 - C168 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C169 being ( INT ) -valued Function;
let C170 being  integer number;
cluster ( C169 - C170 ) -> ( INT ) -valued;
coherence;
end;
definition
let C171 being set;
let C172 being  complex-membered set;
let C173 being (PartFunc of C171 , C172);
let C174 being  complex number;
redefine func C173 - C174 -> (PartFunc of C171 , ( COMPLEX ));

coherence
proof
L186: (( dom ( C173 - C174 ) ) = ( dom C173 ) & ( rng ( C173 - C174 ) ) c= ( COMPLEX )) by L105 , VALUED_0:def 1;
thus L187: thesis by L186 , RELSET_1:4;
end;
end;
definition
let C175 being set;
let C176 being  real-membered set;
let C177 being (PartFunc of C175 , C176);
let C178 being  real number;
redefine func C177 - C178 -> (PartFunc of C175 , ( REAL ));

coherence
proof
L189: (( dom ( C177 - C178 ) ) = ( dom C177 ) & ( rng ( C177 - C178 ) ) c= ( REAL )) by L105 , VALUED_0:def 3;
thus L190: thesis by L189 , RELSET_1:4;
end;
end;
definition
let C179 being set;
let C180 being  rational-membered set;
let C181 being (PartFunc of C179 , C180);
let C182 being  rational number;
redefine func C181 - C182 -> (PartFunc of C179 , ( RAT ));

coherence
proof
L192: (( dom ( C181 - C182 ) ) = ( dom C181 ) & ( rng ( C181 - C182 ) ) c= ( RAT )) by L105 , RELAT_1:def 19;
thus L193: thesis by L192 , RELSET_1:4;
end;
end;
definition
let C183 being set;
let C184 being  integer-membered set;
let C185 being (PartFunc of C183 , C184);
let C186 being  integer number;
redefine func C185 - C186 -> (PartFunc of C183 , ( INT ));

coherence
proof
L195: (( dom ( C185 - C186 ) ) = ( dom C185 ) & ( rng ( C185 - C186 ) ) c= ( INT )) by L105 , RELAT_1:def 19;
thus L196: thesis by L195 , RELSET_1:4;
end;
end;
registration
let C187 being set;
let C188 being  complex-membered non  empty set;
let C189 being (Function of C187 , C188);
let C190 being  complex number;
cluster ( C189 - C190 ) ->  total for (PartFunc of C187 , ( COMPLEX ));
coherence;
end;
registration
let C191 being set;
let C192 being  real-membered non  empty set;
let C193 being (Function of C191 , C192);
let C194 being  real number;
cluster ( C193 - C194 ) ->  total for (PartFunc of C191 , ( REAL ));
coherence;
end;
registration
let C195 being set;
let C196 being  rational-membered non  empty set;
let C197 being (Function of C195 , C196);
let C198 being  rational number;
cluster ( C197 - C198 ) ->  total for (PartFunc of C195 , ( RAT ));
coherence;
end;
registration
let C199 being set;
let C200 being  integer-membered non  empty set;
let C201 being (Function of C199 , C200);
let C202 being  integer number;
cluster ( C201 - C202 ) ->  total for (PartFunc of C199 , ( INT ));
coherence;
end;
theorem
L202: (for B30 being non  empty set holds (for B31 being  complex-membered non  empty set holds (for B32 being (Function of B30 , B31) holds (for B33 being  complex number holds (for B34 being (Element of B30) holds ( ( B32 - B33 ) . B34 ) = ( ( B32 . B34 ) - B33 ))))))
proof
let C203 being non  empty set;
let C204 being  complex-membered non  empty set;
let C205 being (Function of C203 , C204);
let C206 being  complex number;
L203: ( dom ( C205 - C206 ) ) = C203 by FUNCT_2:def 1;
thus L204: thesis by L203 , L105;
end;
registration
let C207 being  complex-valued FinSequence;
let C208 being  complex number;
cluster ( C207 - C208 ) ->  FinSequence-like;
coherence;
end;
begin
definition
let C209 , C210 being  complex-valued Function;
deffunc H3(set) = ( ( C209 . $1 ) * ( C210 . $1 ) );
set D2 = ( ( dom C209 ) /\ ( dom C210 ) );
func C209 (#) C210 -> Function means 
:L206: (( dom it ) = ( ( dom C209 ) /\ ( dom C210 ) ) & (for B35 being set holds (B35 in ( dom it ) implies ( it . B35 ) = ( ( C209 . B35 ) * ( C210 . B35 ) ))));
existence
proof
L207: (ex B36 being Function st (( dom B36 ) = D2 & (for B37 being set holds (B37 in D2 implies ( B36 . B37 ) = H3(B37))))) from FUNCT_1:sch 3;
thus L208: thesis by L207;
end;
uniqueness
proof
let C211 , C212 being Function;
assume that
L209: ( dom C211 ) = D2
and
L210: (for B38 being set holds (B38 in ( dom C211 ) implies ( C211 . B38 ) = H3(B38)))
and
L211: ( dom C212 ) = D2
and
L212: (for B39 being set holds (B39 in ( dom C212 ) implies ( C212 . B39 ) = H3(B39)));
L213:
now
let C213 being set;
assume L214: C213 in ( dom C211 );
thus L215: ( C211 . C213 ) = H3(C213) by L214 , L210
.= ( C212 . C213 ) by L209 , L211 , L212 , L214;
end;
thus L216: thesis by L213 , L209 , L211 , FUNCT_1:2;
end;
commutativity
;
end;
theorem
L218: (for B40 , B41 being  complex-valued Function holds (for B42 being set holds ( ( B40 (#) B41 ) . B42 ) = ( ( B40 . B42 ) * ( B41 . B42 ) )))
proof
let C214 , C215 being  complex-valued Function;
let C216 being set;
L219: ( dom ( C214 (#) C215 ) ) = ( ( dom C214 ) /\ ( dom C215 ) ) by L206;
per cases ;
suppose L220: C216 in ( dom ( C214 (#) C215 ) );

thus L221: thesis by L220 , L206;
end;
suppose L222: (not C216 in ( dom ( C214 (#) C215 ) ));

L223: ((not C216 in ( dom C214 )) or (not C216 in ( dom C215 ))) by L222 , L219 , XBOOLE_0:def 4;
L224: (( C214 . C216 ) = ( 0 ) or ( C215 . C216 ) = ( 0 )) by L223 , FUNCT_1:def 2;
thus L225: thesis by L224 , L222 , FUNCT_1:def 2;
end;
end;
registration
let C217 , C218 being  complex-valued Function;
cluster ( C217 (#) C218 ) ->  complex-valued;
coherence
proof
let C219 being set;
assume L227: C219 in ( dom ( C217 (#) C218 ) );
L228: ( ( C217 (#) C218 ) . C219 ) = ( ( C217 . C219 ) * ( C218 . C219 ) ) by L227 , L206;
thus L229: thesis by L228;
end;
end;
registration
let C220 , C221 being  real-valued Function;
cluster ( C220 (#) C221 ) ->  real-valued;
coherence
proof
let C222 being set;
assume L231: C222 in ( dom ( C220 (#) C221 ) );
L232: ( ( C220 (#) C221 ) . C222 ) = ( ( C220 . C222 ) * ( C221 . C222 ) ) by L231 , L206;
thus L233: thesis by L232;
end;
end;
registration
let C223 , C224 being ( RAT ) -valued Function;
cluster ( C223 (#) C224 ) -> ( RAT ) -valued;
coherence
proof
let C225 being set;
assume L235: C225 in ( rng ( C223 (#) C224 ) );
consider C226 being set such that L236: C226 in ( dom ( C223 (#) C224 ) ) and L237: ( ( C223 (#) C224 ) . C226 ) = C225 by L235 , FUNCT_1:def 3;
L238: ( ( C223 (#) C224 ) . C226 ) = ( ( C223 . C226 ) * ( C224 . C226 ) ) by L236 , L206;
thus L239: thesis by L238 , L237 , RAT_1:def 2;
end;
end;
registration
let C227 , C228 being ( INT ) -valued Function;
cluster ( C227 (#) C228 ) -> ( INT ) -valued;
coherence
proof
let C229 being set;
assume L241: C229 in ( rng ( C227 (#) C228 ) );
consider C230 being set such that L242: C230 in ( dom ( C227 (#) C228 ) ) and L243: ( ( C227 (#) C228 ) . C230 ) = C229 by L241 , FUNCT_1:def 3;
L244: ( ( C227 (#) C228 ) . C230 ) = ( ( C227 . C230 ) * ( C228 . C230 ) ) by L242 , L206;
thus L245: thesis by L244 , L243 , INT_1:def 2;
end;
end;
registration
let C231 , C232 being  natural-valued Function;
cluster ( C231 (#) C232 ) ->  natural-valued;
coherence
proof
let C233 being set;
assume L247: C233 in ( dom ( C231 (#) C232 ) );
L248: ( ( C231 (#) C232 ) . C233 ) = ( ( C231 . C233 ) * ( C232 . C233 ) ) by L247 , L206;
thus L249: thesis by L248;
end;
end;
definition
let C234 being set;
let C235 , C236 being  complex-membered set;
let C237 being (PartFunc of C234 , C235);
let C238 being (PartFunc of C234 , C236);
redefine func C237 (#) C238 -> (PartFunc of C234 , ( COMPLEX ));

coherence
proof
L251: (( dom ( C237 (#) C238 ) ) = ( ( dom C237 ) /\ ( dom C238 ) ) & ( rng ( C237 (#) C238 ) ) c= ( COMPLEX )) by L206 , VALUED_0:def 1;
thus L252: thesis by L251 , RELSET_1:4;
end;
end;
definition
let C239 being set;
let C240 , C241 being  real-membered set;
let C242 being (PartFunc of C239 , C240);
let C243 being (PartFunc of C239 , C241);
redefine func C242 (#) C243 -> (PartFunc of C239 , ( REAL ));

coherence
proof
L254: (( dom ( C242 (#) C243 ) ) = ( ( dom C242 ) /\ ( dom C243 ) ) & ( rng ( C242 (#) C243 ) ) c= ( REAL )) by L206 , VALUED_0:def 3;
thus L255: thesis by L254 , RELSET_1:4;
end;
end;
definition
let C244 being set;
let C245 , C246 being  rational-membered set;
let C247 being (PartFunc of C244 , C245);
let C248 being (PartFunc of C244 , C246);
redefine func C247 (#) C248 -> (PartFunc of C244 , ( RAT ));

coherence
proof
L257: (( dom ( C247 (#) C248 ) ) = ( ( dom C247 ) /\ ( dom C248 ) ) & ( rng ( C247 (#) C248 ) ) c= ( RAT )) by L206 , RELAT_1:def 19;
thus L258: thesis by L257 , RELSET_1:4;
end;
end;
definition
let C249 being set;
let C250 , C251 being  integer-membered set;
let C252 being (PartFunc of C249 , C250);
let C253 being (PartFunc of C249 , C251);
redefine func C252 (#) C253 -> (PartFunc of C249 , ( INT ));

coherence
proof
L260: (( dom ( C252 (#) C253 ) ) = ( ( dom C252 ) /\ ( dom C253 ) ) & ( rng ( C252 (#) C253 ) ) c= ( INT )) by L206 , RELAT_1:def 19;
thus L261: thesis by L260 , RELSET_1:4;
end;
end;
definition
let C254 being set;
let C255 , C256 being  natural-membered set;
let C257 being (PartFunc of C254 , C255);
let C258 being (PartFunc of C254 , C256);
redefine func C257 (#) C258 -> (PartFunc of C254 , ( NAT ));

coherence
proof
L263: (( dom ( C257 (#) C258 ) ) = ( ( dom C257 ) /\ ( dom C258 ) ) & ( rng ( C257 (#) C258 ) ) c= ( NAT )) by L206 , VALUED_0:def 6;
thus L264: thesis by L263 , RELSET_1:4;
end;
end;
registration
let C259 being set;
let C260 , C261 being  complex-membered non  empty set;
let C262 being (Function of C259 , C260);
let C263 being (Function of C259 , C261);
cluster ( C262 (#) C263 ) ->  total for (PartFunc of C259 , ( COMPLEX ));
coherence
proof
L266: (( dom C262 ) = C259 & ( dom C263 ) = C259) by FUNCT_2:def 1;
L267: ( dom ( C262 (#) C263 ) ) = ( C259 /\ C259 ) by L266 , L206
.= C259;
thus L268: thesis by L267 , PARTFUN1:def 2;
end;
end;
registration
let C264 being set;
let C265 , C266 being  real-membered non  empty set;
let C267 being (Function of C264 , C265);
let C268 being (Function of C264 , C266);
cluster ( C267 (#) C268 ) ->  total for (PartFunc of C264 , ( REAL ));
coherence
proof
L270: (( dom C267 ) = C264 & ( dom C268 ) = C264) by FUNCT_2:def 1;
L271: ( dom ( C267 (#) C268 ) ) = ( C264 /\ C264 ) by L270 , L206
.= C264;
thus L272: thesis by L271 , PARTFUN1:def 2;
end;
end;
registration
let C269 being set;
let C270 , C271 being  rational-membered non  empty set;
let C272 being (Function of C269 , C270);
let C273 being (Function of C269 , C271);
cluster ( C272 (#) C273 ) ->  total for (PartFunc of C269 , ( RAT ));
coherence
proof
L274: (( dom C272 ) = C269 & ( dom C273 ) = C269) by FUNCT_2:def 1;
L275: ( dom ( C272 (#) C273 ) ) = ( C269 /\ C269 ) by L274 , L206
.= C269;
thus L276: thesis by L275 , PARTFUN1:def 2;
end;
end;
registration
let C274 being set;
let C275 , C276 being  integer-membered non  empty set;
let C277 being (Function of C274 , C275);
let C278 being (Function of C274 , C276);
cluster ( C277 (#) C278 ) ->  total for (PartFunc of C274 , ( INT ));
coherence
proof
L278: (( dom C277 ) = C274 & ( dom C278 ) = C274) by FUNCT_2:def 1;
L279: ( dom ( C277 (#) C278 ) ) = ( C274 /\ C274 ) by L278 , L206
.= C274;
thus L280: thesis by L279 , PARTFUN1:def 2;
end;
end;
registration
let C279 being set;
let C280 , C281 being  natural-membered non  empty set;
let C282 being (Function of C279 , C280);
let C283 being (Function of C279 , C281);
cluster ( C282 (#) C283 ) ->  total for (PartFunc of C279 , ( NAT ));
coherence
proof
L282: (( dom C282 ) = C279 & ( dom C283 ) = C279) by FUNCT_2:def 1;
L283: ( dom ( C282 (#) C283 ) ) = ( C279 /\ C279 ) by L282 , L206
.= C279;
thus L284: thesis by L283 , PARTFUN1:def 2;
end;
end;
registration
let C284 , C285 being  complex-valued FinSequence;
cluster ( C284 (#) C285 ) ->  FinSequence-like;
coherence
proof
L286: ( dom ( C284 (#) C285 ) ) = ( ( dom C284 ) /\ ( dom C285 ) ) by L206;
thus L287: thesis by L286 , L6;
end;
end;
begin
definition
let C286 being  complex-valued Function;
let C287 being  complex number;
deffunc H4(set) = ( C287 * ( C286 . $1 ) );
func C287 (#) C286 -> Function means 
:L289: (( dom it ) = ( dom C286 ) & (for B43 being set holds (B43 in ( dom it ) implies ( it . B43 ) = ( C287 * ( C286 . B43 ) ))));
existence
proof
L290: (ex B44 being Function st (( dom B44 ) = ( dom C286 ) & (for B45 being set holds (B45 in ( dom C286 ) implies ( B44 . B45 ) = H4(B45))))) from FUNCT_1:sch 3;
thus L291: thesis by L290;
end;
uniqueness
proof
let C288 , C289 being Function;
assume that
L292: ( dom C288 ) = ( dom C286 )
and
L293: (for B46 being set holds (B46 in ( dom C288 ) implies ( C288 . B46 ) = H4(B46)))
and
L294: ( dom C289 ) = ( dom C286 )
and
L295: (for B47 being set holds (B47 in ( dom C289 ) implies ( C289 . B47 ) = H4(B47)));
L296:
now
let C290 being set;
assume L297: C290 in ( dom C288 );
thus L298: ( C288 . C290 ) = H4(C290) by L297 , L293
.= ( C289 . C290 ) by L292 , L294 , L295 , L297;
end;
thus L299: thesis by L296 , L292 , L294 , FUNCT_1:2;
end;
end;
notation
let C291 being  complex-valued Function;
let C292 being  complex number;
synonym C291 (#) C292 for C292 (#) C291;
end;
theorem
L302: (for B48 being  complex-valued Function holds (for B49 being  complex number holds (for B50 being set holds ( ( B49 (#) B48 ) . B50 ) = ( B49 * ( B48 . B50 ) ))))
proof
let C293 being  complex-valued Function;
let C294 being  complex number;
let C295 being set;
L303: ( dom C293 ) = ( dom ( C294 (#) C293 ) ) by L289;
per cases ;
suppose L304: C295 in ( dom C293 );

thus L305: thesis by L304 , L303 , L289;
end;
suppose L306: (not C295 in ( dom C293 ));

thus L307: ( ( C294 (#) C293 ) . C295 ) = ( C294 * ( 0 ) ) by L306 , L303 , FUNCT_1:def 2
.= ( C294 * ( C293 . C295 ) ) by L306 , FUNCT_1:def 2;
end;
end;
registration
let C296 being  complex-valued Function;
let C297 being  complex number;
cluster ( C297 (#) C296 ) ->  complex-valued;
coherence
proof
let C298 being set;
assume L309: C298 in ( dom ( C297 (#) C296 ) );
L310: ( ( C297 (#) C296 ) . C298 ) = ( C297 * ( C296 . C298 ) ) by L309 , L289;
thus L311: thesis by L310;
end;
end;
registration
let C299 being  real-valued Function;
let C300 being  real number;
cluster ( C300 (#) C299 ) ->  real-valued;
coherence
proof
let C301 being set;
assume L313: C301 in ( dom ( C300 (#) C299 ) );
L314: ( ( C300 (#) C299 ) . C301 ) = ( C300 * ( C299 . C301 ) ) by L313 , L289;
thus L315: thesis by L314;
end;
end;
registration
let C302 being ( RAT ) -valued Function;
let C303 being  rational number;
cluster ( C303 (#) C302 ) -> ( RAT ) -valued;
coherence
proof
let C304 being set;
assume L317: C304 in ( rng ( C303 (#) C302 ) );
consider C305 being set such that L318: C305 in ( dom ( C303 (#) C302 ) ) and L319: ( ( C303 (#) C302 ) . C305 ) = C304 by L317 , FUNCT_1:def 3;
L320: ( ( C303 (#) C302 ) . C305 ) = ( C303 * ( C302 . C305 ) ) by L318 , L289;
thus L321: thesis by L320 , L319 , RAT_1:def 2;
end;
end;
registration
let C306 being ( INT ) -valued Function;
let C307 being  integer number;
cluster ( C307 (#) C306 ) -> ( INT ) -valued;
coherence
proof
let C308 being set;
assume L323: C308 in ( rng ( C307 (#) C306 ) );
consider C309 being set such that L324: C309 in ( dom ( C307 (#) C306 ) ) and L325: ( ( C307 (#) C306 ) . C309 ) = C308 by L323 , FUNCT_1:def 3;
L326: ( ( C307 (#) C306 ) . C309 ) = ( C307 * ( C306 . C309 ) ) by L324 , L289;
thus L327: thesis by L326 , L325 , INT_1:def 2;
end;
end;
registration
let C310 being  natural-valued Function;
let C311 being Nat;
cluster ( C311 (#) C310 ) ->  natural-valued;
coherence
proof
let C312 being set;
assume L329: C312 in ( dom ( C311 (#) C310 ) );
L330: ( ( C311 (#) C310 ) . C312 ) = ( C311 * ( C310 . C312 ) ) by L329 , L289;
thus L331: thesis by L330;
end;
end;
definition
let C313 being set;
let C314 being  complex-membered set;
let C315 being (PartFunc of C313 , C314);
let C316 being  complex number;
redefine func C316 (#) C315 -> (PartFunc of C313 , ( COMPLEX ));

coherence
proof
L333: (( dom ( C316 (#) C315 ) ) = ( dom C315 ) & ( rng ( C316 (#) C315 ) ) c= ( COMPLEX )) by L289 , VALUED_0:def 1;
thus L334: thesis by L333 , RELSET_1:4;
end;
end;
definition
let C317 being set;
let C318 being  real-membered set;
let C319 being (PartFunc of C317 , C318);
let C320 being  real number;
redefine func C320 (#) C319 -> (PartFunc of C317 , ( REAL ));

coherence
proof
L336: (( dom ( C320 (#) C319 ) ) = ( dom C319 ) & ( rng ( C320 (#) C319 ) ) c= ( REAL )) by L289 , VALUED_0:def 3;
thus L337: thesis by L336 , RELSET_1:4;
end;
end;
definition
let C321 being set;
let C322 being  rational-membered set;
let C323 being (PartFunc of C321 , C322);
let C324 being  rational number;
redefine func C324 (#) C323 -> (PartFunc of C321 , ( RAT ));

coherence
proof
L339: (( dom ( C324 (#) C323 ) ) = ( dom C323 ) & ( rng ( C324 (#) C323 ) ) c= ( RAT )) by L289 , RELAT_1:def 19;
thus L340: thesis by L339 , RELSET_1:4;
end;
end;
definition
let C325 being set;
let C326 being  integer-membered set;
let C327 being (PartFunc of C325 , C326);
let C328 being  integer number;
redefine func C328 (#) C327 -> (PartFunc of C325 , ( INT ));

coherence
proof
L342: (( dom ( C328 (#) C327 ) ) = ( dom C327 ) & ( rng ( C328 (#) C327 ) ) c= ( INT )) by L289 , RELAT_1:def 19;
thus L343: thesis by L342 , RELSET_1:4;
end;
end;
definition
let C329 being set;
let C330 being  natural-membered set;
let C331 being (PartFunc of C329 , C330);
let C332 being Nat;
redefine func C332 (#) C331 -> (PartFunc of C329 , ( NAT ));

coherence
proof
L345: (( dom ( C332 (#) C331 ) ) = ( dom C331 ) & ( rng ( C332 (#) C331 ) ) c= ( NAT )) by L289 , VALUED_0:def 6;
thus L346: thesis by L345 , RELSET_1:4;
end;
end;
registration
let C333 being set;
let C334 being  complex-membered non  empty set;
let C335 being (Function of C333 , C334);
let C336 being  complex number;
cluster ( C336 (#) C335 ) ->  total for (PartFunc of C333 , ( COMPLEX ));
coherence
proof
L348: ( dom ( C336 (#) C335 ) ) = ( dom C335 ) by L289
.= C333 by FUNCT_2:def 1;
thus L349: thesis by L348 , PARTFUN1:def 2;
end;
end;
registration
let C337 being set;
let C338 being  real-membered non  empty set;
let C339 being (Function of C337 , C338);
let C340 being  real number;
cluster ( C340 (#) C339 ) ->  total for (PartFunc of C337 , ( REAL ));
coherence
proof
L351: ( dom ( C340 (#) C339 ) ) = ( dom C339 ) by L289
.= C337 by FUNCT_2:def 1;
thus L352: thesis by L351 , PARTFUN1:def 2;
end;
end;
registration
let C341 being set;
let C342 being  rational-membered non  empty set;
let C343 being (Function of C341 , C342);
let C344 being  rational number;
cluster ( C344 (#) C343 ) ->  total for (PartFunc of C341 , ( RAT ));
coherence
proof
L354: ( dom ( C344 (#) C343 ) ) = ( dom C343 ) by L289
.= C341 by FUNCT_2:def 1;
thus L355: thesis by L354 , PARTFUN1:def 2;
end;
end;
registration
let C345 being set;
let C346 being  integer-membered non  empty set;
let C347 being (Function of C345 , C346);
let C348 being  integer number;
cluster ( C348 (#) C347 ) ->  total for (PartFunc of C345 , ( INT ));
coherence
proof
L357: ( dom ( C348 (#) C347 ) ) = ( dom C347 ) by L289
.= C345 by FUNCT_2:def 1;
thus L358: thesis by L357 , PARTFUN1:def 2;
end;
end;
registration
let C349 being set;
let C350 being  natural-membered non  empty set;
let C351 being (Function of C349 , C350);
let C352 being Nat;
cluster ( C352 (#) C351 ) ->  total for (PartFunc of C349 , ( NAT ));
coherence
proof
L360: ( dom ( C352 (#) C351 ) ) = ( dom C351 ) by L289
.= C349 by FUNCT_2:def 1;
thus L361: thesis by L360 , PARTFUN1:def 2;
end;
end;
theorem
L363: (for B51 being non  empty set holds (for B52 being  complex-membered non  empty set holds (for B53 being (Function of B51 , B52) holds (for B54 being  complex number holds (for B55 being (Function of B51 , ( COMPLEX )) holds ((for B56 being (Element of B51) holds ( B55 . B56 ) = ( B54 * ( B53 . B56 ) )) implies B55 = ( B54 (#) B53 )))))))
proof
let C353 being non  empty set;
let C354 being  complex-membered non  empty set;
let C355 being (Function of C353 , C354);
let C356 being  complex number;
let C357 being (Function of C353 , ( COMPLEX ));
assume that
L364: (for B57 being (Element of C353) holds ( C357 . B57 ) = ( C356 * ( C355 . B57 ) ));
let C358 being (Element of C353);
thus L365: ( C357 . C358 ) = ( C356 * ( C355 . C358 ) ) by L364
.= ( ( C356 (#) C355 ) . C358 ) by L302;
end;
registration
let C359 being  complex-valued FinSequence;
let C360 being  complex number;
cluster ( C360 (#) C359 ) ->  FinSequence-like;
coherence
proof
L366: ( dom ( C360 (#) C359 ) ) = ( dom C359 ) by L289;
thus L367: thesis by L366 , L1;
end;
end;
begin
definition
let C361 being  complex-valued Function;
func - C361 ->  complex-valued Function equals 
( ( - 1 ) (#) C361 );
coherence;
involutiveness
proof
let C362 , C363 being  complex-valued Function;
assume L369: C362 = ( ( - 1 ) (#) C363 );
thus L370: ( dom ( ( - 1 ) (#) C362 ) ) = ( dom C362 ) by L289
.= ( dom C363 ) by L369 , L289;
let C364 being set;
assume L371: C364 in ( dom C363 );
reconsider D3 = ( ( - 1 ) * ( C363 . C364 ) ) as  complex number;
thus L372: ( C363 . C364 ) = ( ( - 1 ) * D3 )
.= ( ( - 1 ) * ( C362 . C364 ) ) by L369 , L302
.= ( ( ( - 1 ) (#) C362 ) . C364 ) by L302;
end;
end;
theorem
L374: (for B58 being  complex-valued Function holds (( dom ( - B58 ) ) = ( dom B58 ) & (for B59 being set holds ( ( - B58 ) . B59 ) = ( - ( B58 . B59 ) ))))
proof
let C365 being  complex-valued Function;
thus L375: ( dom ( - C365 ) ) = ( dom C365 ) by L289;
let C366 being set;
per cases ;
suppose L376: C366 in ( dom C365 );

thus L377: ( ( - C365 ) . C366 ) = ( ( - 1 ) * ( C365 . C366 ) ) by L376 , L375 , L289
.= ( - ( C365 . C366 ) );
end;
suppose L378: (not C366 in ( dom C365 ));

thus L379: ( ( - C365 ) . C366 ) = ( - (( 0 ) qua  complex number) ) by L378 , L375 , FUNCT_1:def 2
.= ( - ( C365 . C366 ) ) by L378 , FUNCT_1:def 2;
end;
end;
theorem
L381: (for B60 being  complex-valued Function holds (for B61 being Function holds ((( dom B60 ) = ( dom B61 ) & (for B62 being set holds (B62 in ( dom B60 ) implies ( B61 . B62 ) = ( - ( B60 . B62 ) )))) implies B61 = ( - B60 ))))
proof
let C367 being  complex-valued Function;
let C368 being Function;
assume that
L382: ( dom C367 ) = ( dom C368 )
and
L383: (for B63 being set holds (B63 in ( dom C367 ) implies ( C368 . B63 ) = ( - ( C367 . B63 ) )));
thus L384: ( dom ( - C367 ) ) = ( dom C368 ) by L382 , L289;
let C369 being set;
assume L385: C369 in ( dom C368 );
thus L386: ( ( - C367 ) . C369 ) = ( - ( C367 . C369 ) ) by L374
.= ( C368 . C369 ) by L382 , L383 , L385;
end;
registration
let C370 being  complex-valued Function;
cluster ( - C370 ) ->  complex-valued;
coherence;
end;
registration
let C371 being  real-valued Function;
cluster ( - C371 ) ->  real-valued;
coherence;
end;
registration
let C372 being ( RAT ) -valued Function;
cluster ( - C372 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C373 being ( INT ) -valued Function;
cluster ( - C373 ) -> ( INT ) -valued;
coherence;
end;
definition
let C374 being set;
let C375 being  complex-membered set;
let C376 being (PartFunc of C374 , C375);
redefine func - C376 -> (PartFunc of C374 , ( COMPLEX ));

coherence
proof
L391: (( dom ( - C376 ) ) = ( dom C376 ) & ( rng ( - C376 ) ) c= ( COMPLEX )) by L289 , VALUED_0:def 1;
thus L392: thesis by L391 , RELSET_1:4;
end;
end;
definition
let C377 being set;
let C378 being  real-membered set;
let C379 being (PartFunc of C377 , C378);
redefine func - C379 -> (PartFunc of C377 , ( REAL ));

coherence
proof
L394: (( dom ( - C379 ) ) = ( dom C379 ) & ( rng ( - C379 ) ) c= ( REAL )) by L289 , VALUED_0:def 3;
thus L395: thesis by L394 , RELSET_1:4;
end;
end;
definition
let C380 being set;
let C381 being  rational-membered set;
let C382 being (PartFunc of C380 , C381);
redefine func - C382 -> (PartFunc of C380 , ( RAT ));

coherence
proof
L397: (( dom ( - C382 ) ) = ( dom C382 ) & ( rng ( - C382 ) ) c= ( RAT )) by L289 , RELAT_1:def 19;
thus L398: thesis by L397 , RELSET_1:4;
end;
end;
definition
let C383 being set;
let C384 being  integer-membered set;
let C385 being (PartFunc of C383 , C384);
redefine func - C385 -> (PartFunc of C383 , ( INT ));

coherence
proof
L400: (( dom ( - C385 ) ) = ( dom C385 ) & ( rng ( - C385 ) ) c= ( INT )) by L289 , RELAT_1:def 19;
thus L401: thesis by L400 , RELSET_1:4;
end;
end;
registration
let C386 being set;
let C387 being  complex-membered non  empty set;
let C388 being (Function of C386 , C387);
cluster ( - C388 ) ->  total for (PartFunc of C386 , ( COMPLEX ));
coherence;
end;
registration
let C389 being set;
let C390 being  real-membered non  empty set;
let C391 being (Function of C389 , C390);
cluster ( - C391 ) ->  total for (PartFunc of C389 , ( REAL ));
coherence;
end;
registration
let C392 being set;
let C393 being  rational-membered non  empty set;
let C394 being (Function of C392 , C393);
cluster ( - C394 ) ->  total for (PartFunc of C392 , ( RAT ));
coherence;
end;
registration
let C395 being set;
let C396 being  integer-membered non  empty set;
let C397 being (Function of C395 , C396);
cluster ( - C397 ) ->  total for (PartFunc of C395 , ( INT ));
coherence;
end;
registration
let C398 being  complex-valued FinSequence;
cluster ( - C398 ) ->  FinSequence-like;
coherence;
end;
begin
definition
let C399 being  complex-valued Function;
deffunc H5(set) = ( ( C399 . $1 ) " );
func C399 " ->  complex-valued Function means 
:L408: (( dom it ) = ( dom C399 ) & (for B64 being set holds (B64 in ( dom it ) implies ( it . B64 ) = ( ( C399 . B64 ) " ))));
existence
proof
consider C400 being Function such that L409: (( dom C400 ) = ( dom C399 ) & (for B65 being set holds (B65 in ( dom C399 ) implies ( C400 . B65 ) = H5(B65)))) from FUNCT_1:sch 3;
L410: C400 is  complex-valued
proof
let C401 being set;
assume L411: C401 in ( dom C400 );
L412: ( C400 . C401 ) = ( ( C399 . C401 ) " ) by L411 , L409;
thus L413: thesis by L412;
end;
thus L414: thesis by L410 , L409;
end;
uniqueness
proof
let C402 , C403 being  complex-valued Function;
assume that
L415: ( dom C402 ) = ( dom C399 )
and
L416: (for B66 being set holds (B66 in ( dom C402 ) implies ( C402 . B66 ) = H5(B66)))
and
L417: ( dom C403 ) = ( dom C399 )
and
L418: (for B67 being set holds (B67 in ( dom C403 ) implies ( C403 . B67 ) = H5(B67)));
L419:
now
let C404 being set;
assume L420: C404 in ( dom C402 );
thus L421: ( C402 . C404 ) = H5(C404) by L420 , L416
.= ( C403 . C404 ) by L415 , L417 , L418 , L420;
end;
thus L422: thesis by L419 , L415 , L417 , FUNCT_1:2;
end;
involutiveness
proof
let C405 , C406 being  complex-valued Function;
assume that
L423: ( dom C405 ) = ( dom C406 )
and
L424: (for B68 being set holds (B68 in ( dom C405 ) implies ( C405 . B68 ) = ( ( C406 . B68 ) " )));
thus L425: ( dom C405 ) = ( dom C406 ) by L423;
let C407 being set;
assume L426: C407 in ( dom C406 );
thus L427: ( C406 . C407 ) = ( ( ( C406 . C407 ) " ) " )
.= ( ( C405 . C407 ) " ) by L423 , L424 , L426;
end;
end;
theorem
L429: (for B69 being  complex-valued Function holds (for B70 being set holds ( ( B69 " ) . B70 ) = ( ( B69 . B70 ) " )))
proof
let C408 being  complex-valued Function;
let C409 being set;
L430: ( dom ( C408 " ) ) = ( dom C408 ) by L408;
per cases ;
suppose L431: C409 in ( dom C408 );

thus L432: thesis by L431 , L430 , L408;
end;
suppose L433: (not C409 in ( dom C408 ));

thus L434: ( ( C408 " ) . C409 ) = ( (( 0 ) qua  complex number) " ) by L433 , L430 , FUNCT_1:def 2
.= ( ( C408 . C409 ) " ) by L433 , FUNCT_1:def 2;
end;
end;
registration
let C410 being  real-valued Function;
cluster ( C410 " ) ->  real-valued;
coherence
proof
let C411 being set;
assume L436: C411 in ( dom ( C410 " ) );
L437: ( ( C410 " ) . C411 ) = ( ( C410 . C411 ) " ) by L436 , L408;
thus L438: thesis by L437;
end;
end;
registration
let C412 being ( RAT ) -valued Function;
cluster ( C412 " ) -> ( RAT ) -valued;
coherence
proof
let C413 being set;
assume L440: C413 in ( rng ( C412 " ) );
consider C414 being set such that L441: C414 in ( dom ( C412 " ) ) and L442: ( ( C412 " ) . C414 ) = C413 by L440 , FUNCT_1:def 3;
L443: ( ( C412 " ) . C414 ) = ( ( C412 . C414 ) " ) by L441 , L408;
thus L444: thesis by L443 , L442 , RAT_1:def 2;
end;
end;
definition
let C415 being set;
let C416 being  complex-membered set;
let C417 being (PartFunc of C415 , C416);
redefine func C417 " -> (PartFunc of C415 , ( COMPLEX ));

coherence
proof
L446: (( dom ( C417 " ) ) = ( dom C417 ) & ( rng ( C417 " ) ) c= ( COMPLEX )) by L408 , VALUED_0:def 1;
thus L447: thesis by L446 , RELSET_1:4;
end;
end;
definition
let C418 being set;
let C419 being  real-membered set;
let C420 being (PartFunc of C418 , C419);
redefine func C420 " -> (PartFunc of C418 , ( REAL ));

coherence
proof
L449: (( dom ( C420 " ) ) = ( dom C420 ) & ( rng ( C420 " ) ) c= ( REAL )) by L408 , VALUED_0:def 3;
thus L450: thesis by L449 , RELSET_1:4;
end;
end;
definition
let C421 being set;
let C422 being  rational-membered set;
let C423 being (PartFunc of C421 , C422);
redefine func C423 " -> (PartFunc of C421 , ( RAT ));

coherence
proof
L452: (( dom ( C423 " ) ) = ( dom C423 ) & ( rng ( C423 " ) ) c= ( RAT )) by L408 , RELAT_1:def 19;
thus L453: thesis by L452 , RELSET_1:4;
end;
end;
registration
let C424 being set;
let C425 being  complex-membered non  empty set;
let C426 being (Function of C424 , C425);
cluster ( C426 " ) ->  total for (PartFunc of C424 , ( COMPLEX ));
coherence
proof
L455: ( dom ( C426 " ) ) = ( dom C426 ) by L408
.= C424 by FUNCT_2:def 1;
thus L456: thesis by L455 , PARTFUN1:def 2;
end;
end;
registration
let C427 being set;
let C428 being  real-membered non  empty set;
let C429 being (Function of C427 , C428);
cluster ( C429 " ) ->  total for (PartFunc of C427 , ( REAL ));
coherence
proof
L458: ( dom ( C429 " ) ) = ( dom C429 ) by L408
.= C427 by FUNCT_2:def 1;
thus L459: thesis by L458 , PARTFUN1:def 2;
end;
end;
registration
let C430 being set;
let C431 being  rational-membered non  empty set;
let C432 being (Function of C430 , C431);
cluster ( C432 " ) ->  total for (PartFunc of C430 , ( RAT ));
coherence
proof
L461: ( dom ( C432 " ) ) = ( dom C432 ) by L408
.= C430 by FUNCT_2:def 1;
thus L462: thesis by L461 , PARTFUN1:def 2;
end;
end;
registration
let C433 being  complex-valued FinSequence;
cluster ( C433 " ) ->  FinSequence-like;
coherence
proof
L464: ( dom ( C433 " ) ) = ( dom C433 ) by L408;
thus L465: thesis by L464 , L1;
end;
end;
begin
definition
let C434 being  complex-valued Function;
func C434 ^2 -> Function equals 
( C434 (#) C434 );
coherence;
end;
theorem
L468: (for B71 being  complex-valued Function holds (( dom ( B71 ^2 ) ) = ( dom B71 ) & (for B72 being set holds ( ( B71 ^2 ) . B72 ) = ( ( B71 . B72 ) ^2 ))))
proof
let C435 being  complex-valued Function;
thus L469: ( dom ( C435 ^2 ) ) = ( ( dom C435 ) /\ ( dom C435 ) ) by L206
.= ( dom C435 );
let C436 being set;
per cases ;
suppose L470: C436 in ( dom C435 );

thus L471: thesis by L470 , L469 , L206;
end;
suppose L472: (not C436 in ( dom C435 ));

thus L473: ( ( C435 ^2 ) . C436 ) = ( (( 0 ) qua  complex number) ^2 ) by L472 , L469 , FUNCT_1:def 2
.= ( ( C435 . C436 ) ^2 ) by L472 , FUNCT_1:def 2;
end;
end;
registration
let C437 being  complex-valued Function;
cluster ( C437 ^2 ) ->  complex-valued;
coherence;
end;
registration
let C438 being  real-valued Function;
cluster ( C438 ^2 ) ->  real-valued;
coherence;
end;
registration
let C439 being ( RAT ) -valued Function;
cluster ( C439 ^2 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C440 being ( INT ) -valued Function;
cluster ( C440 ^2 ) -> ( INT ) -valued;
coherence;
end;
registration
let C441 being  natural-valued Function;
cluster ( C441 ^2 ) ->  natural-valued;
coherence;
end;
definition
let C442 being set;
let C443 being  complex-membered set;
let C444 being (PartFunc of C442 , C443);
redefine func C444 ^2 -> (PartFunc of C442 , ( COMPLEX ));

coherence
proof
L480: (( dom ( C444 ^2 ) ) = ( dom C444 ) & ( rng ( C444 ^2 ) ) c= ( COMPLEX )) by L468 , VALUED_0:def 1;
thus L481: thesis by L480 , RELSET_1:4;
end;
end;
definition
let C445 being set;
let C446 being  real-membered set;
let C447 being (PartFunc of C445 , C446);
redefine func C447 ^2 -> (PartFunc of C445 , ( REAL ));

coherence
proof
L483: (( dom ( C447 ^2 ) ) = ( dom C447 ) & ( rng ( C447 ^2 ) ) c= ( REAL )) by L468 , VALUED_0:def 3;
thus L484: thesis by L483 , RELSET_1:4;
end;
end;
definition
let C448 being set;
let C449 being  rational-membered set;
let C450 being (PartFunc of C448 , C449);
redefine func C450 ^2 -> (PartFunc of C448 , ( RAT ));

coherence
proof
L486: (( dom ( C450 ^2 ) ) = ( dom C450 ) & ( rng ( C450 ^2 ) ) c= ( RAT )) by L468 , RELAT_1:def 19;
thus L487: thesis by L486 , RELSET_1:4;
end;
end;
definition
let C451 being set;
let C452 being  integer-membered set;
let C453 being (PartFunc of C451 , C452);
redefine func C453 ^2 -> (PartFunc of C451 , ( INT ));

coherence
proof
L489: (( dom ( C453 ^2 ) ) = ( dom C453 ) & ( rng ( C453 ^2 ) ) c= ( INT )) by L468 , RELAT_1:def 19;
thus L490: thesis by L489 , RELSET_1:4;
end;
end;
definition
let C454 being set;
let C455 being  natural-membered set;
let C456 being (PartFunc of C454 , C455);
redefine func C456 ^2 -> (PartFunc of C454 , ( NAT ));

coherence
proof
L492: (( dom ( C456 ^2 ) ) = ( dom C456 ) & ( rng ( C456 ^2 ) ) c= ( NAT )) by L468 , VALUED_0:def 6;
thus L493: thesis by L492 , RELSET_1:4;
end;
end;
registration
let C457 being set;
let C458 being  complex-membered non  empty set;
let C459 being (Function of C457 , C458);
cluster ( C459 ^2 ) ->  total for (PartFunc of C457 , ( COMPLEX ));
coherence;
end;
registration
let C460 being set;
let C461 being  real-membered non  empty set;
let C462 being (Function of C460 , C461);
cluster ( C462 ^2 ) ->  total for (PartFunc of C460 , ( REAL ));
coherence;
end;
registration
let C463 being set;
let C464 being  rational-membered non  empty set;
let C465 being (Function of C463 , C464);
cluster ( C465 ^2 ) ->  total for (PartFunc of C463 , ( RAT ));
coherence;
end;
registration
let C466 being set;
let C467 being  integer-membered non  empty set;
let C468 being (Function of C466 , C467);
cluster ( C468 ^2 ) ->  total for (PartFunc of C466 , ( INT ));
coherence;
end;
registration
let C469 being set;
let C470 being  natural-membered non  empty set;
let C471 being (Function of C469 , C470);
cluster ( C471 ^2 ) ->  total for (PartFunc of C469 , ( NAT ));
coherence;
end;
registration
let C472 being  complex-valued FinSequence;
cluster ( C472 ^2 ) ->  FinSequence-like;
coherence;
end;
begin
definition
let C473 , C474 being  complex-valued Function;
func C473 - C474 -> Function equals 
( C473 + ( - C474 ) );
coherence;
end;
registration
let C475 , C476 being  complex-valued Function;
cluster ( C475 - C476 ) ->  complex-valued;
coherence;
end;
registration
let C477 , C478 being  real-valued Function;
cluster ( C477 - C478 ) ->  real-valued;
coherence;
end;
registration
let C479 , C480 being ( RAT ) -valued Function;
cluster ( C479 - C480 ) -> ( RAT ) -valued;
coherence;
end;
registration
let C481 , C482 being ( INT ) -valued Function;
cluster ( C481 - C482 ) -> ( INT ) -valued;
coherence;
end;
theorem
L506: (for B73 , B74 being  complex-valued Function holds ( dom ( B73 - B74 ) ) = ( ( dom B73 ) /\ ( dom B74 ) ))
proof
let C483 , C484 being  complex-valued Function;
thus L507: ( dom ( C483 - C484 ) ) = ( ( dom C483 ) /\ ( dom ( - C484 ) ) ) by L22
.= ( ( dom C483 ) /\ ( dom C484 ) ) by L289;
end;
theorem
L508: (for B75 , B76 being  complex-valued Function holds (for B77 being set holds (B77 in ( dom ( B75 - B76 ) ) implies ( ( B75 - B76 ) . B77 ) = ( ( B75 . B77 ) - ( B76 . B77 ) ))))
proof
let C485 , C486 being  complex-valued Function;
let C487 being set;
assume L509: C487 in ( dom ( C485 - C486 ) );
thus L510: ( ( C485 - C486 ) . C487 ) = ( ( C485 . C487 ) + ( ( - C486 ) . C487 ) ) by L509 , L22
.= ( ( C485 . C487 ) - ( C486 . C487 ) ) by L374;
end;
theorem
L511: (for B78 , B79 being  complex-valued Function holds (for B80 being Function holds ((( dom B80 ) = ( dom ( B78 - B79 ) ) & (for B81 being set holds (B81 in ( dom B80 ) implies ( B80 . B81 ) = ( ( B78 . B81 ) - ( B79 . B81 ) )))) implies B80 = ( B78 - B79 ))))
proof
let C488 , C489 being  complex-valued Function;
let C490 being Function;
assume that
L512: ( dom C490 ) = ( dom ( C488 - C489 ) )
and
L513: (for B82 being set holds (B82 in ( dom C490 ) implies ( C490 . B82 ) = ( ( C488 . B82 ) - ( C489 . B82 ) )));
thus L514: ( dom C490 ) = ( dom ( C488 - C489 ) ) by L512;
let C491 being set;
assume L515: C491 in ( dom C490 );
thus L516: ( C490 . C491 ) = ( ( C488 . C491 ) - ( C489 . C491 ) ) by L515 , L513
.= ( ( C488 . C491 ) + ( ( - C489 ) . C491 ) ) by L374
.= ( ( C488 - C489 ) . C491 ) by L512 , L515 , L22;
end;
definition
let C492 being set;
let C493 , C494 being  complex-membered set;
let C495 being (PartFunc of C492 , C493);
let C496 being (PartFunc of C492 , C494);
redefine func C495 - C496 -> (PartFunc of C492 , ( COMPLEX ));

coherence
proof
L517: (( dom ( C495 - C496 ) ) = ( ( dom C495 ) /\ ( dom C496 ) ) & ( rng ( C495 - C496 ) ) c= ( COMPLEX )) by L506 , VALUED_0:def 1;
thus L518: thesis by L517 , RELSET_1:4;
end;
end;
definition
let C497 being set;
let C498 , C499 being  real-membered set;
let C500 being (PartFunc of C497 , C498);
let C501 being (PartFunc of C497 , C499);
redefine func C500 - C501 -> (PartFunc of C497 , ( REAL ));

coherence
proof
L520: (( dom ( C500 - C501 ) ) = ( ( dom C500 ) /\ ( dom C501 ) ) & ( rng ( C500 - C501 ) ) c= ( REAL )) by L506 , VALUED_0:def 3;
thus L521: thesis by L520 , RELSET_1:4;
end;
end;
definition
let C502 being set;
let C503 , C504 being  rational-membered set;
let C505 being (PartFunc of C502 , C503);
let C506 being (PartFunc of C502 , C504);
redefine func C505 - C506 -> (PartFunc of C502 , ( RAT ));

coherence
proof
L523: (( dom ( C505 - C506 ) ) = ( ( dom C505 ) /\ ( dom C506 ) ) & ( rng ( C505 - C506 ) ) c= ( RAT )) by L506 , RELAT_1:def 19;
thus L524: thesis by L523 , RELSET_1:4;
end;
end;
definition
let C507 being set;
let C508 , C509 being  integer-membered set;
let C510 being (PartFunc of C507 , C508);
let C511 being (PartFunc of C507 , C509);
redefine func C510 - C511 -> (PartFunc of C507 , ( INT ));

coherence
proof
L526: (( dom ( C510 - C511 ) ) = ( ( dom C510 ) /\ ( dom C511 ) ) & ( rng ( C510 - C511 ) ) c= ( INT )) by L506 , RELAT_1:def 19;
thus L527: thesis by L526 , RELSET_1:4;
end;
end;
L529: (for B83 being set holds (for B84 , B85 being  complex-membered non  empty set holds (for B86 being (Function of B83 , B84) holds (for B87 being (Function of B83 , B85) holds ( dom ( B86 - B87 ) ) = B83))))
proof
let C512 being set;
let C513 , C514 being  complex-membered non  empty set;
let C515 being (Function of C512 , C513);
let C516 being (Function of C512 , C514);
thus L530: ( dom ( C515 - C516 ) ) = ( ( dom C515 ) /\ ( dom ( - C516 ) ) ) by L22
.= ( C512 /\ ( dom ( - C516 ) ) ) by FUNCT_2:def 1
.= ( C512 /\ C512 ) by FUNCT_2:def 1
.= C512;
end;
registration
let C517 being set;
let C518 , C519 being  complex-membered non  empty set;
let C520 being (Function of C517 , C518);
let C521 being (Function of C517 , C519);
cluster ( C520 - C521 ) ->  total for (PartFunc of C517 , ( COMPLEX ));
coherence
proof
L531: ( dom ( C520 - C521 ) ) = C517 by L529;
thus L532: thesis by L531 , PARTFUN1:def 2;
end;
end;
registration
let C522 being set;
let C523 , C524 being  real-membered non  empty set;
let C525 being (Function of C522 , C523);
let C526 being (Function of C522 , C524);
cluster ( C525 - C526 ) ->  total for (PartFunc of C522 , ( REAL ));
coherence
proof
L534: ( dom ( C525 - C526 ) ) = C522 by L529;
thus L535: thesis by L534 , PARTFUN1:def 2;
end;
end;
registration
let C527 being set;
let C528 , C529 being  rational-membered non  empty set;
let C530 being (Function of C527 , C528);
let C531 being (Function of C527 , C529);
cluster ( C530 - C531 ) ->  total for (PartFunc of C527 , ( RAT ));
coherence
proof
L537: ( dom ( C530 - C531 ) ) = C527 by L529;
thus L538: thesis by L537 , PARTFUN1:def 2;
end;
end;
registration
let C532 being set;
let C533 , C534 being  integer-membered non  empty set;
let C535 being (Function of C532 , C533);
let C536 being (Function of C532 , C534);
cluster ( C535 - C536 ) ->  total for (PartFunc of C532 , ( INT ));
coherence
proof
L540: ( dom ( C535 - C536 ) ) = C532 by L529;
thus L541: thesis by L540 , PARTFUN1:def 2;
end;
end;
theorem
L543: (for B88 being set holds (for B89 , B90 being  complex-membered non  empty set holds (for B91 being (Function of B88 , B89) holds (for B92 being (Function of B88 , B90) holds (for B93 being (Element of B88) holds ( ( B91 - B92 ) . B93 ) = ( ( B91 . B93 ) - ( B92 . B93 ) ))))))
proof
let C537 being set;
let C538 , C539 being  complex-membered non  empty set;
let C540 being (Function of C537 , C538);
let C541 being (Function of C537 , C539);
let C542 being (Element of C537);
L544: ( dom ( C540 - C541 ) ) = C537 by FUNCT_2:def 1;
per cases ;
suppose L545: C537 is non  empty;

thus L546: ( ( C540 - C541 ) . C542 ) = ( ( C540 . C542 ) + ( ( - C541 ) . C542 ) ) by L545 , L544 , L22
.= ( ( C540 . C542 ) - ( C541 . C542 ) ) by L374;
end;
suppose L547: C537 is  empty;

L548: ( dom C541 ) = ( {} ) by L547;
L549: ( C541 . C542 ) = ( 0 ) by L548 , FUNCT_1:def 2;
thus L550: thesis by L549 , L547;
end;
end;
registration
let C543 , C544 being  complex-valued FinSequence;
cluster ( C543 - C544 ) ->  FinSequence-like;
coherence;
end;
begin
definition
let C545 , C546 being  complex-valued Function;
func C545 /" C546 -> Function equals 
( C545 (#) ( C546 " ) );
coherence;
end;
theorem
L554: (for B94 , B95 being  complex-valued Function holds ( dom ( B94 /" B95 ) ) = ( ( dom B94 ) /\ ( dom B95 ) ))
proof
let C547 , C548 being  complex-valued Function;
thus L555: ( dom ( C547 /" C548 ) ) = ( ( dom C547 ) /\ ( dom ( C548 " ) ) ) by L206
.= ( ( dom C547 ) /\ ( dom C548 ) ) by L408;
end;
theorem
L556: (for B96 , B97 being  complex-valued Function holds (for B98 being set holds ( ( B96 /" B97 ) . B98 ) = ( ( B96 . B98 ) / ( B97 . B98 ) )))
proof
let C549 , C550 being  complex-valued Function;
let C551 being set;
L557: ( dom ( C549 /" C550 ) ) = ( ( dom C549 ) /\ ( dom C550 ) ) by L554;
per cases ;
suppose L558: C551 in ( dom ( C549 /" C550 ) );

thus L559: ( ( C549 /" C550 ) . C551 ) = ( ( C549 . C551 ) * ( ( C550 " ) . C551 ) ) by L558 , L206
.= ( ( C549 . C551 ) / ( C550 . C551 ) ) by L429;
end;
suppose L560: (not C551 in ( dom ( C549 /" C550 ) ));

L561: ((not C551 in ( dom C549 )) or (not C551 in ( dom C550 ))) by L560 , L557 , XBOOLE_0:def 4;
L562: (( C549 . C551 ) = ( 0 ) or ( C550 . C551 ) = ( 0 )) by L561 , FUNCT_1:def 2;
thus L563: ( ( C549 /" C550 ) . C551 ) = ( ( 0 ) / ( 0 ) ) by L560 , FUNCT_1:def 2
.= ( ( C549 . C551 ) / ( C550 . C551 ) ) by L562;
end;
end;
registration
let C552 , C553 being  complex-valued Function;
cluster ( C552 /" C553 ) ->  complex-valued;
coherence;
end;
registration
let C554 , C555 being  real-valued Function;
cluster ( C554 /" C555 ) ->  real-valued;
coherence;
end;
registration
let C556 , C557 being ( RAT ) -valued Function;
cluster ( C556 /" C557 ) -> ( RAT ) -valued;
coherence;
end;
definition
let C558 being set;
let C559 , C560 being  complex-membered set;
let C561 being (PartFunc of C558 , C559);
let C562 being (PartFunc of C558 , C560);
redefine func C561 /" C562 -> (PartFunc of C558 , ( COMPLEX ));

coherence
proof
L568: (( dom ( C561 /" C562 ) ) = ( ( dom C561 ) /\ ( dom C562 ) ) & ( rng ( C561 /" C562 ) ) c= ( COMPLEX )) by L554 , VALUED_0:def 1;
thus L569: thesis by L568 , RELSET_1:4;
end;
end;
definition
let C563 being set;
let C564 , C565 being  real-membered set;
let C566 being (PartFunc of C563 , C564);
let C567 being (PartFunc of C563 , C565);
redefine func C566 /" C567 -> (PartFunc of C563 , ( REAL ));

coherence
proof
L571: (( dom ( C566 /" C567 ) ) = ( ( dom C566 ) /\ ( dom C567 ) ) & ( rng ( C566 /" C567 ) ) c= ( REAL )) by L554 , VALUED_0:def 3;
thus L572: thesis by L571 , RELSET_1:4;
end;
end;
definition
let C568 being set;
let C569 , C570 being  rational-membered set;
let C571 being (PartFunc of C568 , C569);
let C572 being (PartFunc of C568 , C570);
redefine func C571 /" C572 -> (PartFunc of C568 , ( RAT ));

coherence
proof
L574: (( dom ( C571 /" C572 ) ) = ( ( dom C571 ) /\ ( dom C572 ) ) & ( rng ( C571 /" C572 ) ) c= ( RAT )) by L554 , RELAT_1:def 19;
thus L575: thesis by L574 , RELSET_1:4;
end;
end;
L577: (for B99 being set holds (for B100 , B101 being  complex-membered non  empty set holds (for B102 being (Function of B99 , B100) holds (for B103 being (Function of B99 , B101) holds ( dom ( B102 /" B103 ) ) = B99))))
proof
let C573 being set;
let C574 , C575 being  complex-membered non  empty set;
let C576 being (Function of C573 , C574);
let C577 being (Function of C573 , C575);
thus L578: ( dom ( C576 /" C577 ) ) = ( ( dom C576 ) /\ ( dom C577 ) ) by L554
.= ( C573 /\ ( dom C577 ) ) by FUNCT_2:def 1
.= ( C573 /\ C573 ) by FUNCT_2:def 1
.= C573;
end;
registration
let C578 being set;
let C579 , C580 being  complex-membered non  empty set;
let C581 being (Function of C578 , C579);
let C582 being (Function of C578 , C580);
cluster ( C581 /" C582 ) ->  total for (PartFunc of C578 , ( COMPLEX ));
coherence
proof
L579: ( dom ( C581 /" C582 ) ) = C578 by L577;
thus L580: thesis by L579 , PARTFUN1:def 2;
end;
end;
registration
let C583 being set;
let C584 , C585 being  real-membered non  empty set;
let C586 being (Function of C583 , C584);
let C587 being (Function of C583 , C585);
cluster ( C586 /" C587 ) ->  total for (PartFunc of C583 , ( REAL ));
coherence
proof
L582: ( dom ( C586 /" C587 ) ) = C583 by L577;
thus L583: thesis by L582 , PARTFUN1:def 2;
end;
end;
registration
let C588 being set;
let C589 , C590 being  rational-membered non  empty set;
let C591 being (Function of C588 , C589);
let C592 being (Function of C588 , C590);
cluster ( C591 /" C592 ) ->  total for (PartFunc of C588 , ( RAT ));
coherence
proof
L585: ( dom ( C591 /" C592 ) ) = C588 by L577;
thus L586: thesis by L585 , PARTFUN1:def 2;
end;
end;
registration
let C593 , C594 being  complex-valued FinSequence;
cluster ( C593 /" C594 ) ->  FinSequence-like;
coherence;
end;
begin
definition
let C595 being  complex-valued Function;
deffunc H6(set) = |. ( C595 . $1 ) .|;
func |.C595 .| ->  real-valued Function means 
:L589: (( dom it ) = ( dom C595 ) & (for B104 being set holds (B104 in ( dom it ) implies ( it . B104 ) = |. ( C595 . B104 ) .|)));
existence
proof
consider C596 being Function such that L590: (( dom C596 ) = ( dom C595 ) & (for B105 being set holds (B105 in ( dom C595 ) implies ( C596 . B105 ) = H6(B105)))) from FUNCT_1:sch 3;
L591: C596 is  real-valued
proof
let C597 being set;
assume L592: C597 in ( dom C596 );
L593: ( C596 . C597 ) = |. ( C595 . C597 ) .| by L592 , L590;
thus L594: thesis by L593;
end;
thus L595: thesis by L591 , L590;
end;
uniqueness
proof
let C598 , C599 being  real-valued Function;
assume that
L596: ( dom C598 ) = ( dom C595 )
and
L597: (for B106 being set holds (B106 in ( dom C598 ) implies ( C598 . B106 ) = H6(B106)))
and
L598: ( dom C599 ) = ( dom C595 )
and
L599: (for B107 being set holds (B107 in ( dom C599 ) implies ( C599 . B107 ) = H6(B107)));
L600:
now
let C600 being set;
assume L601: C600 in ( dom C598 );
thus L602: ( C598 . C600 ) = H6(C600) by L601 , L597
.= ( C599 . C600 ) by L596 , L598 , L599 , L601;
end;
thus L603: thesis by L600 , L596 , L598 , FUNCT_1:2;
end;
projectivity
proof
let C601 being  real-valued Function;
let C602 being  complex-valued Function;
assume that
L604: ( dom C601 ) = ( dom C602 )
and
L605: (for B108 being set holds (B108 in ( dom C601 ) implies ( C601 . B108 ) = |. ( C602 . B108 ) .|));
thus L606: ( dom C601 ) = ( dom C601 );
let C603 being set;
assume L607: C603 in ( dom C601 );
thus L608: ( C601 . C603 ) = |. |. ( C602 . C603 ) .| .| by L607 , L605
.= |. ( C601 . C603 ) .| by L605 , L607;
end;
end;
notation
let C604 being  complex-valued Function;
synonym abs C604 for |.C604 .|;
end;
theorem
L611: (for B109 being  complex-valued Function holds (for B110 being set holds ( |. B109 .| . B110 ) = |. ( B109 . B110 ) .|))
proof
let C605 being  complex-valued Function;
let C606 being set;
L612: ( dom |. C605 .| ) = ( dom C605 ) by L589;
per cases ;
suppose L613: C606 in ( dom C605 );

thus L614: thesis by L613 , L612 , L589;
end;
suppose L615: (not C606 in ( dom C605 ));

thus L616: ( |. C605 .| . C606 ) = |. (( 0 ) qua  complex number) .| by L615 , L612 , COMPLEX1:44 , FUNCT_1:def 2
.= |. ( C605 . C606 ) .| by L615 , FUNCT_1:def 2;
end;
end;
registration
let C607 being ( RAT ) -valued Function;
cluster |. C607 .| -> ( RAT ) -valued;
coherence
proof
let C608 being set;
assume L618: C608 in ( rng |. C607 .| );
consider C609 being set such that L619: C609 in ( dom |. C607 .| ) and L620: ( |. C607 .| . C609 ) = C608 by L618 , FUNCT_1:def 3;
L621: ( |. C607 .| . C609 ) = |. ( C607 . C609 ) .| by L619 , L589;
thus L622: thesis by L621 , L620 , RAT_1:def 2;
end;
end;
registration
let C610 being ( INT ) -valued Function;
cluster |. C610 .| ->  natural-valued;
coherence
proof
let C611 being set;
L624: ( abs ( C610 . C611 ) ) is  natural;
thus L625: thesis by L624 , L589;
end;
end;
definition
let C612 being set;
let C613 being  complex-membered set;
let C614 being (PartFunc of C612 , C613);
redefine func |.C614 .| -> (PartFunc of C612 , ( REAL ));

coherence
proof
L627: (( dom |. C614 .| ) = ( dom C614 ) & ( rng |. C614 .| ) c= ( REAL )) by L589 , VALUED_0:def 3;
thus L628: thesis by L627 , RELSET_1:4;
end;
end;
definition
let C615 being set;
let C616 being  complex-membered set;
let C617 being (PartFunc of C615 , C616);
redefine func abs C617 -> (PartFunc of C615 , ( REAL ));

coherence
proof
L630: ( abs C617 ) = |. C617 .|;
thus L631: thesis by L630;
end;
end;
definition
let C618 being set;
let C619 being  rational-membered set;
let C620 being (PartFunc of C618 , C619);
redefine func |.C620 .| -> (PartFunc of C618 , ( RAT ));

coherence
proof
L633: (( dom |. C620 .| ) = ( dom C620 ) & ( rng |. C620 .| ) c= ( RAT )) by L589 , RELAT_1:def 19;
thus L634: thesis by L633 , RELSET_1:4;
end;
end;
definition
let C621 being set;
let C622 being  rational-membered set;
let C623 being (PartFunc of C621 , C622);
redefine func abs C623 -> (PartFunc of C621 , ( RAT ));

coherence
proof
L636: ( abs C623 ) = |. C623 .|;
thus L637: thesis by L636;
end;
end;
definition
let C624 being set;
let C625 being  integer-membered set;
let C626 being (PartFunc of C624 , C625);
redefine func |.C626 .| -> (PartFunc of C624 , ( NAT ));

coherence
proof
L639: (( dom |. C626 .| ) = ( dom C626 ) & ( rng |. C626 .| ) c= ( NAT )) by L589 , VALUED_0:def 6;
thus L640: thesis by L639 , RELSET_1:4;
end;
end;
definition
let C627 being set;
let C628 being  integer-membered set;
let C629 being (PartFunc of C627 , C628);
redefine func abs C629 -> (PartFunc of C627 , ( NAT ));

coherence
proof
L642: ( abs C629 ) = |. C629 .|;
thus L643: thesis by L642;
end;
end;
registration
let C630 being set;
let C631 being  complex-membered non  empty set;
let C632 being (Function of C630 , C631);
cluster |. C632 .| ->  total for (PartFunc of C630 , ( REAL ));
coherence
proof
L645: ( dom |. C632 .| ) = ( dom C632 ) by L589
.= C630 by FUNCT_2:def 1;
thus L646: thesis by L645 , PARTFUN1:def 2;
end;
end;
registration
let C633 being set;
let C634 being  rational-membered non  empty set;
let C635 being (Function of C633 , C634);
cluster |. C635 .| ->  total for (PartFunc of C633 , ( RAT ));
coherence
proof
L648: ( dom |. C635 .| ) = ( dom C635 ) by L589
.= C633 by FUNCT_2:def 1;
thus L649: thesis by L648 , PARTFUN1:def 2;
end;
end;
registration
let C636 being set;
let C637 being  integer-membered non  empty set;
let C638 being (Function of C636 , C637);
cluster |. C638 .| ->  total for (PartFunc of C636 , ( NAT ));
coherence
proof
L651: ( dom |. C638 .| ) = ( dom C638 ) by L589
.= C636 by FUNCT_2:def 1;
thus L652: thesis by L651 , PARTFUN1:def 2;
end;
end;
registration
let C639 being  complex-valued FinSequence;
cluster |. C639 .| ->  FinSequence-like;
coherence
proof
L654: ( dom ( abs C639 ) ) = ( dom C639 ) by L589;
thus L655: thesis by L654 , L1;
end;
end;
theorem
L657: (for B111 , B112 being FinSequence holds (for B113 being Function holds (( dom B113 ) = ( ( dom B111 ) /\ ( dom B112 ) ) implies B113 is FinSequence))) by L6;
begin
definition
let C640 being Function;
let C641 being Nat;
func Shift (C640 , C641) -> Function means 
:L658: (( dom it ) = { ( R1 + C641 ) where R1 is (Element of ( NAT )) : R1 in ( dom C640 ) } & (for R1 being (Element of ( NAT )) holds (R1 in ( dom C640 ) implies ( it . ( R1 + C641 ) ) = ( C640 . R1 ))));
existence
proof
defpred S1[ set , set ] means (ex R1 being (Element of ( NAT )) st ($1 = ( R1 + C641 ) & $2 = ( C640 . R1 )));
set D4 = { ( R1 + C641 ) where R1 is (Element of ( NAT )) : R1 in ( dom C640 ) };
L659: (for B114 being set holds (B114 in D4 implies (ex B115 being set st S1[ B114 , B115 ])))
proof
let C642 being set;
assume L660: C642 in D4;
consider R1 being (Element of ( NAT )) such that L661: C642 = ( R1 + C641 ) and L662: R1 in ( dom C640 ) by L660;
take ( C640 . R1 );
thus L663: thesis by L661;
end;
consider C643 being Function such that L664: ( dom C643 ) = D4 and L665: (for B116 being set holds (B116 in D4 implies S1[ B116 , ( C643 . B116 ) ])) from CLASSES1:sch 1(L659);
take C643;
thus L666: ( dom C643 ) = { ( R1 + C641 ) where R1 is (Element of ( NAT )) : R1 in ( dom C640 ) } by L664;
let R1 being (Element of ( NAT ));
assume L667: R1 in ( dom C640 );
L668: ( R1 + C641 ) in D4 by L667;
L669: (ex R2 being (Element of ( NAT )) st (( R1 + C641 ) = ( R2 + C641 ) & ( C643 . ( R1 + C641 ) ) = ( C640 . R2 ))) by L668 , L665;
thus L670: thesis by L669;
end;
uniqueness
proof
let C644 , C645 being Function;
assume that
L671: ( dom C644 ) = { ( R1 + C641 ) where R1 is (Element of ( NAT )) : R1 in ( dom C640 ) }
and
L672: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C640 ) implies ( C644 . ( R1 + C641 ) ) = ( C640 . R1 )))
and
L673: ( dom C645 ) = { ( R1 + C641 ) where R1 is (Element of ( NAT )) : R1 in ( dom C640 ) }
and
L674: (for R1 being (Element of ( NAT )) holds (R1 in ( dom C640 ) implies ( C645 . ( R1 + C641 ) ) = ( C640 . R1 )));
L675: (for B117 being set holds (B117 in ( dom C644 ) implies ( C644 . B117 ) = ( C645 . B117 )))
proof
let C646 being set;
assume L676: C646 in ( dom C644 );
consider R1 being (Element of ( NAT )) such that L677: (C646 = ( R1 + C641 ) & R1 in ( dom C640 )) by L676 , L671;
thus L678: ( C644 . C646 ) = ( C640 . R1 ) by L672 , L677
.= ( C645 . C646 ) by L674 , L677;
end;
thus L679: thesis by L675 , L671 , L673 , FUNCT_1:2;
end;
end;
registration
let C647 being Function;
let C648 being Nat;
cluster ( Shift (C647 , C648) ) -> ( NAT ) -defined;
coherence
proof
L681: ( dom ( Shift (C647 , C648) ) ) = { ( R1 + C648 ) where R1 is (Element of ( NAT )) : R1 in ( dom C647 ) } by L658;
L682: ( Shift (C647 , C648) ) is ( NAT ) -defined
proof
let C649 being set;
assume L683: C649 in ( dom ( Shift (C647 , C648) ) );
L684: (ex R1 being (Element of ( NAT )) st (C649 = ( R1 + C648 ) & R1 in ( dom C647 ))) by L683 , L681;
thus L685: thesis by L684;
end;
thus L686: thesis by L682;
end;
end;
theorem
L688: (for B118 , B119 being Function holds (for B120 being Nat holds (B118 c= B119 implies ( Shift (B118 , B120) ) c= ( Shift (B119 , B120) ))))
proof
let C650 , C651 being Function;
let C652 being Nat;
assume L689: C650 c= C651;
L690: ( dom C650 ) c= ( dom C651 ) by L689 , GRFUNC_1:2;
L691: ( dom ( Shift (C650 , C652) ) ) = { ( R1 + C652 ) where R1 is (Element of ( NAT )) : R1 in ( dom C650 ) } by L658;
L692: ( dom ( Shift (C651 , C652) ) ) = { ( R1 + C652 ) where R1 is (Element of ( NAT )) : R1 in ( dom C651 ) } by L658;
L693:
now
let C653 being set;
assume L694: C653 in ( dom ( Shift (C650 , C652) ) );
L695: (ex B121 being (Element of ( NAT )) st (C653 = ( B121 + C652 ) & B121 in ( dom C650 ))) by L694 , L691;
thus L696: C653 in ( dom ( Shift (C651 , C652) ) ) by L695 , L690 , L692;
end;
L697: ( dom ( Shift (C650 , C652) ) ) c= ( dom ( Shift (C651 , C652) ) ) by L693 , TARSKI:def 3;
L698:
now
let C654 being set;
assume L699: C654 in ( dom ( Shift (C650 , C652) ) );
consider C655 being (Element of ( NAT )) such that L700: C654 = ( C655 + C652 ) and L701: C655 in ( dom C650 ) by L699 , L691;
thus L702: ( ( Shift (C650 , C652) ) . C654 ) = ( ( Shift (C650 , C652) ) . ( C655 + C652 ) ) by L700
.= ( C650 . C655 ) by L701 , L658
.= ( C651 . C655 ) by L689 , L701 , GRFUNC_1:2
.= ( ( Shift (C651 , C652) ) . ( C655 + C652 ) ) by L690 , L701 , L658
.= ( ( Shift (C651 , C652) ) . C654 ) by L700;
end;
thus L703: thesis by L698 , L697 , GRFUNC_1:2;
end;
theorem
L704: (for B122 , B123 being Nat holds (for B124 being Function holds ( Shift (( Shift (B124 , B123) ) , B122) ) = ( Shift (B124 , ( B123 + B122 )) )))
proof
let C656 , C657 being Nat;
let C658 being Function;
set D5 = { ( R6 + C657 ) where R6 is (Element of ( NAT )) : R6 in ( dom C658 ) };
L705: ( dom ( Shift (C658 , C657) ) ) = D5 by L658;
L706:
now
let R6 being (Element of ( NAT ));
assume L707: R6 in ( dom C658 );
L708: ( R6 + C657 ) in ( dom ( Shift (C658 , C657) ) ) by L707 , L705;
thus L709: ( ( Shift (( Shift (C658 , C657) ) , C656) ) . ( R6 + ( C657 + C656 ) ) ) = ( ( Shift (( Shift (C658 , C657) ) , C656) ) . ( ( R6 + C657 ) + C656 ) )
.= ( ( Shift (C658 , C657) ) . ( R6 + C657 ) ) by L708 , L658
.= ( C658 . R6 ) by L707 , L658;
end;
L710: { ( R3 + C656 ) where R3 is (Element of ( NAT )) : R3 in D5 } = { ( R4 + ( C657 + C656 ) ) where R4 is (Element of ( NAT )) : R4 in ( dom C658 ) }
proof
thus L711: { ( R3 + C656 ) where R3 is (Element of ( NAT )) : R3 in D5 } c= { ( R4 + ( C657 + C656 ) ) where R4 is (Element of ( NAT )) : R4 in ( dom C658 ) }
proof
let C659 being set;
assume L712: C659 in { ( R3 + C656 ) where R3 is (Element of ( NAT )) : R3 in D5 };
consider R3 being (Element of ( NAT )) such that L713: C659 = ( R3 + C656 ) and L714: R3 in D5 by L712;
consider R6 being (Element of ( NAT )) such that L715: R3 = ( R6 + C657 ) and L716: R6 in ( dom C658 ) by L714;
L717: C659 = ( R6 + ( C657 + C656 ) ) by L713 , L715;
thus L718: thesis by L717 , L716;
end;

let C660 being set;
assume L719: C660 in { ( R4 + ( C657 + C656 ) ) where R4 is (Element of ( NAT )) : R4 in ( dom C658 ) };
consider R4 being (Element of ( NAT )) such that L720: (C660 = ( R4 + ( C657 + C656 ) ) & R4 in ( dom C658 )) by L719;
L721: (C660 = ( ( R4 + C657 ) + C656 ) & ( R4 + C657 ) in D5) by L720;
thus L722: thesis by L721;
end;
L723: ( dom ( Shift (( Shift (C658 , C657) ) , C656) ) ) = { ( R6 + ( C657 + C656 ) ) where R6 is (Element of ( NAT )) : R6 in ( dom C658 ) } by L710 , L705 , L658;
thus L724: thesis by L723 , L706 , L658;
end;
theorem
L725: (for B125 , B126 being Function holds (for B127 being Nat holds ( Shift (( B126 * B125 ) , B127) ) = ( B126 * ( Shift (B125 , B127) ) )))
proof
let C661 , C662 being Function;
let C663 being Nat;
L726: ( dom ( C662 * C661 ) ) c= ( dom C661 ) by RELAT_1:25;
L727: ( dom ( Shift (C661 , C663) ) ) = { ( R1 + C663 ) where R1 is (Element of ( NAT )) : R1 in ( dom C661 ) } by L658;
L728:
now
let C664 being set;
thus L729: (C664 in { ( R1 + C663 ) where R1 is (Element of ( NAT )) : R1 in ( dom ( C662 * C661 ) ) } implies (C664 in ( dom ( Shift (C661 , C663) ) ) & ( ( Shift (C661 , C663) ) . C664 ) in ( dom C662 )))
proof
assume L730: C664 in { ( R1 + C663 ) where R1 is (Element of ( NAT )) : R1 in ( dom ( C662 * C661 ) ) };
consider R1 being (Element of ( NAT )) such that L731: C664 = ( R1 + C663 ) and L732: R1 in ( dom ( C662 * C661 ) ) by L730;
thus L733: C664 in ( dom ( Shift (C661 , C663) ) ) by L727 , L726 , L731 , L732;
L734: ( ( Shift (C661 , C663) ) . C664 ) = ( C661 . R1 ) by L726 , L731 , L732 , L658;
thus L735: thesis by L734 , L732 , FUNCT_1:11;
end;

assume L736: C664 in ( dom ( Shift (C661 , C663) ) );
consider C665 being (Element of ( NAT )) such that L737: C664 = ( C665 + C663 ) and L738: C665 in ( dom C661 ) by L736 , L727;
assume L739: ( ( Shift (C661 , C663) ) . C664 ) in ( dom C662 );
L740: ( C661 . C665 ) in ( dom C662 ) by L739 , L737 , L738 , L658;
L741: C665 in ( dom ( C662 * C661 ) ) by L740 , L738 , FUNCT_1:11;
thus L742: C664 in { ( R1 + C663 ) where R1 is (Element of ( NAT )) : R1 in ( dom ( C662 * C661 ) ) } by L741 , L737;
end;
L743: ( ( Shift (C661 , C663) ) " ( dom C662 ) ) = { ( R1 + C663 ) where R1 is (Element of ( NAT )) : R1 in ( dom ( C662 * C661 ) ) } by L728 , FUNCT_1:def 7;
L744: ( dom ( C662 * ( Shift (C661 , C663) ) ) ) = { ( R1 + C663 ) where R1 is (Element of ( NAT )) : R1 in ( dom ( C662 * C661 ) ) } by L743 , RELAT_1:147;
L745:
now
let R1 being (Element of ( NAT ));
assume L746: R1 in ( dom ( C662 * C661 ) );
L747: ( R1 + C663 ) in ( dom ( Shift (C661 , C663) ) ) by L746 , L727 , L726;
thus L748: ( ( C662 * ( Shift (C661 , C663) ) ) . ( R1 + C663 ) ) = ( C662 . ( ( Shift (C661 , C663) ) . ( R1 + C663 ) ) ) by L747 , FUNCT_1:13
.= ( C662 . ( C661 . R1 ) ) by L726 , L746 , L658
.= ( ( C662 * C661 ) . R1 ) by L746 , FUNCT_1:12;
end;
thus L749: thesis by L745 , L744 , L658;
end;
theorem
L750: (for B128 , B129 being Function holds (for B130 being Nat holds ( Shift (( B128 +* B129 ) , B130) ) = ( ( Shift (B128 , B130) ) +* ( Shift (B129 , B130) ) )))
proof
let C666 , C667 being Function;
let C668 being Nat;
L751: ( dom ( Shift (C667 , C668) ) ) = { ( R1 + C668 ) where R1 is (Element of ( NAT )) : R1 in ( dom C667 ) } by L658;
L752:
now
let R1 being (Element of ( NAT ));
assume that
L753: R1 in ( dom ( C666 +* C667 ) );
per cases ;
suppose L754: R1 in ( dom C667 );

L755: ( R1 + C668 ) in ( dom ( Shift (C667 , C668) ) ) by L754 , L751;
thus L756: ( ( ( Shift (C666 , C668) ) +* ( Shift (C667 , C668) ) ) . ( R1 + C668 ) ) = ( ( Shift (C667 , C668) ) . ( R1 + C668 ) ) by L755 , FUNCT_4:13
.= ( C667 . R1 ) by L754 , L658
.= ( ( C666 +* C667 ) . R1 ) by L754 , FUNCT_4:13;
end;
suppose L757: (not R1 in ( dom C667 ));

L758: R1 in ( ( dom C666 ) \/ ( dom C667 ) ) by L753 , FUNCT_4:def 1;
L759: R1 in ( dom C666 ) by L758 , L757 , XBOOLE_0:def 3;
L760: (not (ex R6 being (Element of ( NAT )) st (( R1 + C668 ) = ( R6 + C668 ) & R6 in ( dom C667 )))) by L757;
L761: (not ( R1 + C668 ) in ( dom ( Shift (C667 , C668) ) )) by L760 , L751;
thus L762: ( ( ( Shift (C666 , C668) ) +* ( Shift (C667 , C668) ) ) . ( R1 + C668 ) ) = ( ( Shift (C666 , C668) ) . ( R1 + C668 ) ) by L761 , FUNCT_4:11
.= ( C666 . R1 ) by L759 , L658
.= ( ( C666 +* C667 ) . R1 ) by L757 , FUNCT_4:11;
end;
end;
L764: ( dom ( Shift (C666 , C668) ) ) = { ( R1 + C668 ) where R1 is (Element of ( NAT )) : R1 in ( dom C666 ) } by L658;
L765: ( ( dom ( Shift (C666 , C668) ) ) \/ ( dom ( Shift (C667 , C668) ) ) ) = { ( R1 + C668 ) where R1 is (Element of ( NAT )) : R1 in ( ( dom C666 ) \/ ( dom C667 ) ) }
proof
thus L766:now
let C669 being set;
assume L767: C669 in ( ( dom ( Shift (C666 , C668) ) ) \/ ( dom ( Shift (C667 , C668) ) ) );
L768: (C669 in ( dom ( Shift (C666 , C668) ) ) or C669 in ( dom ( Shift (C667 , C668) ) )) by L767 , XBOOLE_0:def 3;
consider R1 being (Element of ( NAT )) such that L769: ((C669 = ( R1 + C668 ) & R1 in ( dom C667 )) or (C669 = ( R1 + C668 ) & R1 in ( dom C666 ))) by L768 , L751 , L764;
L770: R1 in ( ( dom C666 ) \/ ( dom C667 ) ) by L769 , XBOOLE_0:def 3;
thus L771: C669 in { ( R6 + C668 ) where R6 is (Element of ( NAT )) : R6 in ( ( dom C666 ) \/ ( dom C667 ) ) } by L770 , L769;
end;
let C670 being set;
assume L772: C670 in { ( R1 + C668 ) where R1 is (Element of ( NAT )) : R1 in ( ( dom C666 ) \/ ( dom C667 ) ) };
consider R1 being (Element of ( NAT )) such that L773: C670 = ( R1 + C668 ) and L774: R1 in ( ( dom C666 ) \/ ( dom C667 ) ) by L772;
L775: (R1 in ( dom C666 ) or R1 in ( dom C667 )) by L774 , XBOOLE_0:def 3;
L776: (C670 in ( dom ( Shift (C666 , C668) ) ) or C670 in ( dom ( Shift (C667 , C668) ) )) by L775 , L751 , L764 , L773;
thus L777: thesis by L776 , XBOOLE_0:def 3;
end;
L778: ( dom ( C666 +* C667 ) ) = ( ( dom C666 ) \/ ( dom C667 ) ) by FUNCT_4:def 1;
L779: ( dom ( ( Shift (C666 , C668) ) +* ( Shift (C667 , C668) ) ) ) = { ( R1 + C668 ) where R1 is (Element of ( NAT )) : R1 in ( dom ( C666 +* C667 ) ) } by L778 , L765 , FUNCT_4:def 1;
thus L780: thesis by L779 , L752 , L658;
end;
theorem
L781: (for B131 being Function holds (for B132 , B133 being Nat holds (B133 in ( dom B131 ) implies ( B133 + B132 ) in ( dom ( Shift (B131 , B132) ) ))))
proof
let C671 being Function;
let C672 , C673 being Nat;
assume that
L782: C673 in ( dom C671 );
L783: ( dom ( Shift (C671 , C672) ) ) = { ( B134 + C672 ) where B134 is (Element of ( NAT )) : B134 in ( dom C671 ) } by L658;
reconsider D6 = C673 as (Element of ( NAT )) by ORDINAL1:def 12;
L784: ( D6 + C672 ) in ( dom ( Shift (C671 , C672) ) ) by L783 , L782;
thus L785: thesis by L784;
end;
theorem
L786: (for B135 being Function holds (for B136 being Nat holds ( rng ( Shift (B135 , B136) ) ) c= ( rng B135 )))
proof
let C674 being Function;
let C675 being Nat;
let C676 being set;
assume L787: C676 in ( rng ( Shift (C674 , C675) ) );
consider C677 being set such that L788: C677 in ( dom ( Shift (C674 , C675) ) ) and L789: C676 = ( ( Shift (C674 , C675) ) . C677 ) by L787 , FUNCT_1:def 3;
L790: C677 in { ( R1 + C675 ) where R1 is (Element of ( NAT )) : R1 in ( dom C674 ) } by L788 , L658;
consider R1 being (Element of ( NAT )) such that L791: C677 = ( R1 + C675 ) and L792: R1 in ( dom C674 ) by L790;
L793: ( C674 . R1 ) = ( ( Shift (C674 , C675) ) . C677 ) by L791 , L792 , L658;
thus L794: thesis by L793 , L789 , L792 , FUNCT_1:def 3;
end;
theorem
L795: (for B137 being Function holds (( dom B137 ) c= ( NAT ) implies (for B138 being Nat holds ( rng ( Shift (B137 , B138) ) ) = ( rng B137 ))))
proof
let C678 being Function;
assume that
L796: ( dom C678 ) c= ( NAT );
let C679 being Nat;
thus L797: ( rng ( Shift (C678 , C679) ) ) c= ( rng C678 ) by L786;
let C680 being set;
assume L798: C680 in ( rng C678 );
consider C681 being set such that L799: C681 in ( dom C678 ) and L800: C680 = ( C678 . C681 ) by L798 , FUNCT_1:def 3;
reconsider D7 = C681 as (Element of ( NAT )) by L796 , L799;
L801: (( D7 + C679 ) in ( dom ( Shift (C678 , C679) ) ) & ( ( Shift (C678 , C679) ) . ( D7 + C679 ) ) = C680) by L799 , L800 , L658 , L781;
thus L802: thesis by L801 , FUNCT_1:def 3;
end;
registration
let C682 being  finite Function;
let C683 being Nat;
cluster ( Shift (C682 , C683) ) ->  finite;
coherence
proof
deffunc H7((Element of ( NAT ))) = ( $1 + C683 );
L803: ( dom C682 ) is  finite;
L804: { H7(B139) where B139 is (Element of ( NAT )) : B139 in ( dom C682 ) } is  finite from FRAENKEL:sch 21(L803);
L805: ( dom ( Shift (C682 , C683) ) ) is  finite by L804 , L658;
thus L806: thesis by L805 , FINSET_1:10;
end;
end;
definition
let C684 being non  empty  ext-real-membered set;
let C685 being (sequence of C684);
redefine attr C685 is  increasing
means
(for B140 being Nat holds ( C685 . B140 ) < ( C685 . ( B140 + 1 ) ));
compatibility
proof
thus L808: (C685 is  increasing implies (for B141 being Nat holds ( C685 . B141 ) < ( C685 . ( B141 + 1 ) )))
proof
assume L809: C685 is  increasing;
let C686 being Nat;
L810: C686 < ( C686 + 1 ) by NAT_1:13;
L811: (( dom C685 ) = ( NAT ) & C686 in ( NAT )) by FUNCT_2:def 1 , ORDINAL1:def 12;
thus L812: thesis by L811 , L809 , L810 , VALUED_0:def 13;
end;

assume L813: (for B142 being Nat holds ( C685 . B142 ) < ( C685 . ( B142 + 1 ) ));
let R7 being  ext-real number;
let R8 being  ext-real number;
assume L814: (R7 in ( dom C685 ) & R8 in ( dom C685 ));
reconsider D8 = R7 , D9 = R8 as Nat by L814;
defpred S2[ Nat ] means (D8 < $1 implies ( C685 . D8 ) < ( C685 . $1 ));
L815: (for B143 being Nat holds (S2[ B143 ] implies S2[ ( B143 + 1 ) ]))
proof
let C687 being Nat;
assume that
L816: S2[ C687 ];
assume L817: D8 < ( C687 + 1 );
L818: D8 <= C687 by L817 , NAT_1:13;
L819: (( C685 . D8 ) < ( C685 . C687 ) or D8 = C687) by L818 , L816 , XXREAL_0:1;
thus L820: thesis by L819 , L813 , XXREAL_0:2;
end;
assume L821: R7 < R8;
L822: S2[ ( 0 ) ];
L823: (for B144 being Nat holds S2[ B144 ]) from NAT_1:sch 2(L822 , L815);
L824: ( C685 . D8 ) < ( C685 . D9 ) by L823 , L821;
thus L825: thesis by L824;
end;
redefine attr C685 is  decreasing
means
(for B145 being Nat holds ( C685 . B145 ) > ( C685 . ( B145 + 1 ) ));
compatibility
proof
thus L826: (C685 is  decreasing implies (for B146 being Nat holds ( C685 . B146 ) > ( C685 . ( B146 + 1 ) )))
proof
assume L827: C685 is  decreasing;
let C688 being Nat;
L828: C688 < ( C688 + 1 ) by NAT_1:13;
L829: (( dom C685 ) = ( NAT ) & C688 in ( NAT )) by FUNCT_2:def 1 , ORDINAL1:def 12;
thus L830: thesis by L829 , L827 , L828 , VALUED_0:def 14;
end;

assume L831: (for B147 being Nat holds ( C685 . B147 ) > ( C685 . ( B147 + 1 ) ));
let R7 being  ext-real number;
let R8 being  ext-real number;
assume L832: (R7 in ( dom C685 ) & R8 in ( dom C685 ));
reconsider D10 = R7 , D11 = R8 as Nat by L832;
defpred S3[ Nat ] means (D10 < $1 implies ( C685 . D10 ) > ( C685 . $1 ));
L833: (for B148 being Nat holds (S3[ B148 ] implies S3[ ( B148 + 1 ) ]))
proof
let C689 being Nat;
assume that
L834: S3[ C689 ];
assume L835: D10 < ( C689 + 1 );
L836: D10 <= C689 by L835 , NAT_1:13;
L837: (( C685 . D10 ) > ( C685 . C689 ) or D10 = C689) by L836 , L834 , XXREAL_0:1;
thus L838: thesis by L837 , L831 , XXREAL_0:2;
end;
assume L839: R7 < R8;
L840: S3[ ( 0 ) ];
L841: (for B149 being Nat holds S3[ B149 ]) from NAT_1:sch 2(L840 , L833);
L842: ( C685 . D10 ) > ( C685 . D11 ) by L841 , L839;
thus L843: thesis by L842;
end;
redefine attr C685 is  non-decreasing
means
(for B150 being Nat holds ( C685 . B150 ) <= ( C685 . ( B150 + 1 ) ));
compatibility
proof
thus L844: (C685 is  non-decreasing implies (for B151 being Nat holds ( C685 . B151 ) <= ( C685 . ( B151 + 1 ) )))
proof
assume L845: C685 is  non-decreasing;
let C690 being Nat;
L846: C690 < ( C690 + 1 ) by NAT_1:13;
L847: (( dom C685 ) = ( NAT ) & C690 in ( NAT )) by FUNCT_2:def 1 , ORDINAL1:def 12;
thus L848: thesis by L847 , L845 , L846 , VALUED_0:def 15;
end;

assume L849: (for B152 being Nat holds ( C685 . B152 ) <= ( C685 . ( B152 + 1 ) ));
let R7 being  ext-real number;
let R8 being  ext-real number;
assume L850: (R7 in ( dom C685 ) & R8 in ( dom C685 ));
reconsider D12 = R7 , D13 = R8 as Nat by L850;
defpred S4[ Nat ] means (D12 <= $1 implies ( C685 . D12 ) <= ( C685 . $1 ));
L851: (for B153 being Nat holds (S4[ B153 ] implies S4[ ( B153 + 1 ) ]))
proof
let C691 being Nat;
assume that
L852: S4[ C691 ];
assume L853: D12 <= ( C691 + 1 );
L854: (D12 < ( C691 + 1 ) or D12 = ( C691 + 1 )) by L853 , XXREAL_0:1;
L855: ( C685 . C691 ) <= ( C685 . ( C691 + 1 ) ) by L849;
thus L856: thesis by L855 , L852 , L854 , NAT_1:13 , XXREAL_0:2;
end;
assume L857: R7 <= R8;
L858: S4[ ( 0 ) ];
L859: (for B154 being Nat holds S4[ B154 ]) from NAT_1:sch 2(L858 , L851);
L860: ( C685 . D12 ) <= ( C685 . D13 ) by L859 , L857;
thus L861: thesis by L860;
end;
redefine attr C685 is  non-increasing
means
(for B155 being Nat holds ( C685 . B155 ) >= ( C685 . ( B155 + 1 ) ));
compatibility
proof
thus L862: (C685 is  non-increasing implies (for B156 being Nat holds ( C685 . B156 ) >= ( C685 . ( B156 + 1 ) )))
proof
assume L863: C685 is  non-increasing;
let C692 being Nat;
L864: C692 < ( C692 + 1 ) by NAT_1:13;
L865: (( dom C685 ) = ( NAT ) & C692 in ( NAT )) by FUNCT_2:def 1 , ORDINAL1:def 12;
thus L866: thesis by L865 , L863 , L864 , VALUED_0:def 16;
end;

assume L867: (for B157 being Nat holds ( C685 . B157 ) >= ( C685 . ( B157 + 1 ) ));
let R7 being  ext-real number;
let R8 being  ext-real number;
assume L868: (R7 in ( dom C685 ) & R8 in ( dom C685 ));
reconsider D14 = R7 , D15 = R8 as Nat by L868;
defpred S5[ Nat ] means (D14 <= $1 implies ( C685 . D14 ) >= ( C685 . $1 ));
L869: (for B158 being Nat holds (S5[ B158 ] implies S5[ ( B158 + 1 ) ]))
proof
let C693 being Nat;
assume that
L870: S5[ C693 ];
assume L871: D14 <= ( C693 + 1 );
L872: (D14 < ( C693 + 1 ) or D14 = ( C693 + 1 )) by L871 , XXREAL_0:1;
L873: ( C685 . C693 ) >= ( C685 . ( C693 + 1 ) ) by L867;
thus L874: thesis by L873 , L870 , L872 , NAT_1:13 , XXREAL_0:2;
end;
assume L875: R7 <= R8;
L876: S5[ ( 0 ) ];
L877: (for B159 being Nat holds S5[ B159 ]) from NAT_1:sch 2(L876 , L869);
L878: ( C685 . D14 ) >= ( C685 . D15 ) by L877 , L875;
thus L879: thesis by L878;
end;
end;
scheme SubSeqChoice { F1() -> non  empty set , F2() -> (sequence of F1()) , P1[set] } : (ex B160 being (subsequence of F2()) st (for B161 being (Element of ( NAT )) holds P1[ ( B160 . B161 ) ]))
provided
L881: (for B162 being (Element of ( NAT )) holds (ex B163 being (Element of ( NAT )) st (B162 <= B163 & P1[ ( F2() . B163 ) ])))
proof
defpred S6[ set , set , set ] means ($3 in ( NAT ) & (for B164 , B165 being (Element of ( NAT )) holds ((B164 = $2 & B165 = $3) implies (B164 < B165 & P1[ ( F2() . B165 ) ]))));
consider C694 being (Element of ( NAT )) such that L882: ( 0 ) <= C694 and L883: P1[ ( F2() . C694 ) ] by L881;
L884: (for B166 being (Element of ( NAT )) holds (for B167 being set holds (ex B168 being set st S6[ B166 , B167 , B168 ])))
proof
let C695 being (Element of ( NAT ));
let C696 being set;
per cases ;
suppose L885: C696 in ( NAT );

reconsider D16 = C696 as (Element of ( NAT )) by L885;
consider C697 being (Element of ( NAT )) such that L886: (( D16 + 1 ) <= C697 & P1[ ( F2() . C697 ) ]) by L881;
take C697;
thus L887: C697 in ( NAT );
thus L888: thesis by L886 , NAT_1:13;
end;
suppose L889: (not C696 in ( NAT ));

take ( 0 );
set D17 = ( 0 );
thus L890: D17 in ( NAT );
let C698 , C699 being (Element of ( NAT ));
assume that
L891: C698 = C696
and
L892: C699 = D17;
thus L893: thesis by L889 , L891;
end;
end;
consider C700 being Function such that L895: ( dom C700 ) = ( NAT ) and L896: ( C700 . ( 0 ) ) = C694 and L897: (for B169 being (Element of ( NAT )) holds S6[ B169 , ( C700 . B169 ) , ( C700 . ( B169 + 1 ) ) ]) from RECDEF_1:sch 1(L884);
L898: ( rng C700 ) c= ( NAT )
proof
defpred S7[ (Element of ( NAT )) ] means ( C700 . $1 ) in ( NAT );
let C701 being set;
assume L899: C701 in ( rng C700 );
consider C702 being set such that L900: C702 in ( dom C700 ) and L901: ( C700 . C702 ) = C701 by L899 , FUNCT_1:def 3;
reconsider D18 = C702 as (Element of ( NAT )) by L895 , L900;
L902: (for B170 being (Element of ( NAT )) holds (S7[ B170 ] implies S7[ ( B170 + 1 ) ])) by L897;
L903: S7[ ( 0 ) ] by L896;
L904: (for B171 being (Element of ( NAT )) holds S7[ B171 ]) from NAT_1:sch 1(L903 , L902);
L905: ( C700 . D18 ) in ( NAT ) by L904;
thus L906: thesis by L905 , L901;
end;
reconsider D19 = C700 as (sequence of ( NAT )) by L898 , L895 , FUNCT_2:2;
L907: D19 is  increasing
proof
let C703 being Nat;
reconsider D20 = C703 as (Element of ( NAT )) by ORDINAL1:def 12;
L908: ( D19 . D20 ) < ( D19 . ( D20 + 1 ) ) by L897;
thus L909: thesis by L908;
end;
reconsider D21 = D19 as  increasing (sequence of ( NAT )) by L907;
reconsider D22 = ( F2() * D21 ) as (sequence of F1());
L910: ( dom D22 ) = ( NAT ) by FUNCT_2:def 1;
reconsider D23 = D22 as (subsequence of F2());
take D23;
thus L911: (for B172 being (Element of ( NAT )) holds P1[ ( D23 . B172 ) ])
proof
let C704 being (Element of ( NAT ));
per cases ;
suppose L912: C704 = ( 0 );

thus L913: thesis by L912 , L883 , L896 , L910 , FUNCT_1:12;
end;
suppose L914: C704 <> ( 0 );

L915: C704 >= ( (( 0 ) qua Nat) + 1 ) by L914 , NAT_1:13;
reconsider D24 = ( C704 - 1 ) as (Element of ( NAT )) by L915 , INT_1:5;
reconsider D25 = ( D21 . ( D24 + 1 ) ) as (Element of ( NAT ));
L916: (for B173 , B174 being (Element of ( NAT )) holds ((B173 = ( D21 . D24 ) & B174 = ( D21 . ( D24 + 1 ) )) implies P1[ ( F2() . B174 ) ])) by L897;
L917: P1[ ( F2() . D25 ) ] by L916;
thus L918: thesis by L917 , L910 , FUNCT_1:12;
end;
end;

end;
theorem
L912: (for B175 being Nat holds (for B176 being ( NAT ) -defined Function holds ( dom B176 ) , ( dom ( Shift (B176 , B175) ) ) are_equipotent ))
proof
let C705 being Nat;
let C706 being ( NAT ) -defined Function;
defpred S8[ set , set ] means (ex B177 being (Element of ( NAT )) st ($1 = B177 & $2 = ( C705 + B177 )));
L913: (for B178 being set holds (B178 in ( dom C706 ) implies (ex B179 being set st S8[ B178 , B179 ])))
proof
let C707 being set;
assume L914: C707 in ( dom C706 );
reconsider D26 = C707 as (Element of ( NAT )) by L914;
take ( C705 + D26 );
take D26;
thus L915: thesis;
end;
consider C708 being Function such that L916: ( dom C708 ) = ( dom C706 ) and L917: (for B180 being set holds (B180 in ( dom C706 ) implies S8[ B180 , ( C708 . B180 ) ])) from CLASSES1:sch 1(L913);
take C708;
thus L918:now
let C709 , C710 being set;
assume that
L919: C709 in ( dom C708 )
and
L920: C710 in ( dom C708 )
and
L921: ( C708 . C709 ) = ( C708 . C710 );
consider C711 being (Element of ( NAT )) such that L922: C709 = C711 and L923: ( C708 . C709 ) = ( C705 + C711 ) by L916 , L917 , L919;
consider C712 being (Element of ( NAT )) such that L924: C710 = C712 and L925: ( C708 . C710 ) = ( C705 + C712 ) by L916 , L917 , L920;
thus L926: C709 = C710 by L922 , L921 , L923 , L925 , L924;
end;
thus L927: ( dom C708 ) = ( dom C706 ) by L916;
L928: ( dom ( Shift (C706 , C705) ) ) = { ( B181 + C705 ) where B181 is (Element of ( NAT )) : B181 in ( dom C706 ) } by L658;
thus L929:now
let C713 being set;
assume L930: C713 in ( rng C708 );
consider C714 being set such that L931: C714 in ( dom C708 ) and L932: ( C708 . C714 ) = C713 by L930 , FUNCT_1:def 3;
consider C715 being (Element of ( NAT )) such that L933: C714 = C715 and L934: ( C708 . C714 ) = ( C705 + C715 ) by L916 , L917 , L931;
thus L935: C713 in ( dom ( Shift (C706 , C705) ) ) by L916 , L928 , L931 , L932 , L933 , L934;
end;
let C716 being set;
assume L936: C716 in ( dom ( Shift (C706 , C705) ) );
consider C717 being (Element of ( NAT )) such that L937: C716 = ( C717 + C705 ) and L938: C717 in ( dom C706 ) by L936 , L928;
consider C718 being (Element of ( NAT )) such that L939: C717 = C718 and L940: ( C708 . C717 ) = ( C705 + C718 ) by L917 , L938;
thus L941: thesis by L916 , L937 , L938 , L939 , L940 , FUNCT_1:def 3;
end;
registration
let C719 being ( NAT ) -defined Function;
reduce ( Shift (C719 , ( 0 )) ) to C719;
reducibility
proof
L942: ( dom C719 ) = { ( B182 + (( 0 ) qua  complex number) ) where B182 is (Element of ( NAT )) : B182 in ( dom C719 ) }
proof
thus L943:now
let C720 being set;
assume L944: C720 in ( dom C719 );
reconsider D27 = C720 as (Element of ( NAT )) by L944;
L945: C720 = ( (D27 qua  complex number) + (( 0 ) qua  complex number) );
thus L946: C720 in { ( B183 + (( 0 ) qua  complex number) ) where B183 is (Element of ( NAT )) : B183 in ( dom C719 ) } by L945 , L944;
end;
let C721 being set;
assume L947: C721 in { ( B184 + (( 0 ) qua  complex number) ) where B184 is (Element of ( NAT )) : B184 in ( dom C719 ) };
L948: (ex B185 being (Element of ( NAT )) st (C721 = ( B185 + (( 0 ) qua  complex number) ) & B185 in ( dom C719 ))) by L947;
thus L949: thesis by L948;
end;
L950: (for B186 being (Element of ( NAT )) holds (B186 in ( dom C719 ) implies ( C719 . ( B186 + (( 0 ) qua  complex number) ) ) = ( C719 . B186 )));
thus L951: thesis by L950 , L942 , L658;
end;
end;
theorem
L953: (for B187 being ( NAT ) -defined Function holds ( Shift (B187 , ( 0 )) ) = B187);
registration
let C722 being non  empty set;
let C723 being C722 -valued Function;
let C724 being Nat;
cluster ( Shift (C723 , C724) ) -> C722 -valued;
coherence
proof
L954: ( dom ( Shift (C723 , C724) ) ) = { ( B188 + C724 ) where B188 is (Element of ( NAT )) : B188 in ( dom C723 ) } by L658;
thus L955: ( rng ( Shift (C723 , C724) ) ) c= C722
proof
let C725 being set;
assume L956: C725 in ( rng ( Shift (C723 , C724) ) );
consider C726 being set such that L957: C726 in ( dom ( Shift (C723 , C724) ) ) and L958: C725 = ( ( Shift (C723 , C724) ) . C726 ) by L956 , FUNCT_1:def 3;
consider C727 being (Element of ( NAT )) such that L959: C726 = ( C727 + C724 ) and L960: C727 in ( dom C723 ) by L957 , L954;
L961: ( ( Shift (C723 , C724) ) . ( C727 + C724 ) ) = ( C723 . C727 ) by L960 , L658
.= ( C723 /. C727 ) by L960 , PARTFUN1:def 6;
thus L962: C725 in C722 by L961 , L958 , L959;
end;

end;
end;
registration
cluster non  empty ( NAT ) -defined for Function;
existence
proof
take ( id ( NAT ) );
thus L957: thesis;
end;
end;
registration
let C728 being  empty Function;
let C729 being Nat;
cluster ( Shift (C728 , C729) ) ->  empty;
coherence
proof
L959: ( dom ( Shift (C728 , C729) ) ) = { ( B189 + C729 ) where B189 is (Element of ( NAT )) : B189 in ( dom C728 ) } by L658;
assume L960: ( Shift (C728 , C729) ) is non  empty;
reconsider D28 = ( Shift (C728 , C729) ) as non  empty Function by L960;
L961: ( dom D28 ) is non  empty;
consider C730 being set such that L962: C730 in ( dom ( Shift (C728 , C729) ) ) by L961 , XBOOLE_0:def 1;
L963: (ex B190 being (Element of ( NAT )) st (C730 = ( B190 + C729 ) & B190 in ( dom C728 ))) by L959 , L962;
thus L964: thesis by L963;
end;
end;
registration
let C731 being non  empty ( NAT ) -defined Function;
let C732 being Nat;
cluster ( Shift (C731 , C732) ) -> non  empty;
coherence
proof
L966: ( dom ( Shift (C731 , C732) ) ) = { ( B191 + C732 ) where B191 is (Element of ( NAT )) : B191 in ( dom C731 ) } by L658;
consider C733 being set such that L967: C733 in ( dom C731 ) by XBOOLE_0:def 1;
reconsider D29 = C733 as (Element of ( NAT )) by L967;
consider C734 being Nat such that L968: D29 = C734;
reconsider D30 = C734 as (Element of ( NAT )) by ORDINAL1:def 12;
L969: ( D30 + C732 ) in ( dom ( Shift (C731 , C732) ) ) by L966 , L967 , L968;
thus L970: thesis by L969;
end;
end;
theorem
L972: (for B192 being Function holds (for B193 being Nat holds (B193 > ( 0 ) implies (not ( 0 ) in ( dom ( Shift (B192 , B193) ) )))))
proof
let C735 being Function;
let C736 being Nat;
assume that
L973: C736 > ( 0 )
and
L974: ( 0 ) in ( dom ( Shift (C735 , C736) ) );
L975: ( dom ( Shift (C735 , C736) ) ) = { ( B194 + C736 ) where B194 is (Element of ( NAT )) : B194 in ( dom C735 ) } by L658;
L976: (ex B195 being (Element of ( NAT )) st (( 0 ) = ( B195 + C736 ) & B195 in ( dom C735 ))) by L975 , L974;
thus L977: contradiction by L976 , L973;
end;
registration
cluster ( NAT ) -defined  finite non  empty for Function;
existence
proof
take D31 = ( ( 0 ) .--> ( 0 ) );
L978: ( dom D31 ) = { ( 0 ) } by FUNCOP_1:13;
thus L979: ( dom D31 ) c= ( NAT ) by L978 , ZFMISC_1:31;
thus L980: thesis;
end;
end;
registration
let C737 being ( NAT ) -defined Relation;
cluster ( dom C737 ) ->  natural-membered;
coherence;
end;
definition
let C738 being non  empty ( NAT ) -defined  finite Function;
func LastLoc C738 -> (Element of ( NAT )) equals 
( max ( dom C738 ) );
coherence by ORDINAL1:def 12;
end;
definition
let C739 being non  empty ( NAT ) -defined  finite Function;
func CutLastLoc C739 -> Function equals 
( C739 \ ( ( LastLoc C739 ) .--> ( C739 . ( LastLoc C739 ) ) ) );
coherence;
end;
registration
let C740 being non  empty ( NAT ) -defined  finite Function;
cluster ( CutLastLoc C740 ) -> ( NAT ) -defined  finite;
coherence;
end;
theorem
L986: (for B196 being non  empty ( NAT ) -defined  finite Function holds ( LastLoc B196 ) in ( dom B196 )) by XXREAL_2:def 8;
theorem
L987: (for B197 , B198 being non  empty ( NAT ) -defined  finite Function holds (B197 c= B198 implies ( LastLoc B197 ) <= ( LastLoc B198 ))) by RELAT_1:11 , XXREAL_2:59;
theorem
L988: (for B199 being non  empty ( NAT ) -defined  finite Function holds (for B200 being (Element of ( NAT )) holds (B200 in ( dom B199 ) implies B200 <= ( LastLoc B199 )))) by XXREAL_2:def 8;
definition
let C741 being non  empty ( NAT ) -defined Function;
func FirstLoc C741 -> (Element of ( NAT )) equals 
( min ( dom C741 ) );
coherence by ORDINAL1:def 12;
end;
theorem
L990: (for B201 being non  empty ( NAT ) -defined  finite Function holds ( FirstLoc B201 ) in ( dom B201 )) by XXREAL_2:def 7;
theorem
L991: (for B202 , B203 being non  empty ( NAT ) -defined  finite Function holds (B202 c= B203 implies ( FirstLoc B203 ) <= ( FirstLoc B202 ))) by RELAT_1:11 , XXREAL_2:60;
theorem
L992: (for B204 being (Element of ( NAT )) holds (for B205 being non  empty ( NAT ) -defined  finite Function holds (B204 in ( dom B205 ) implies ( FirstLoc B205 ) <= B204))) by XXREAL_2:def 7;
theorem
L993: (for B206 being non  empty ( NAT ) -defined  finite Function holds ( dom ( CutLastLoc B206 ) ) = ( ( dom B206 ) \ { ( LastLoc B206 ) } ))
proof
let C742 being non  empty ( NAT ) -defined  finite Function;
L994: ( dom ( ( LastLoc C742 ) .--> ( C742 . ( LastLoc C742 ) ) ) ) = { ( LastLoc C742 ) } by FUNCOP_1:13;
reconsider D32 = { [ ( LastLoc C742 ) , ( C742 . ( LastLoc C742 ) ) ] } as Relation;
L995: D32 = ( ( LastLoc C742 ) .--> ( C742 . ( LastLoc C742 ) ) ) by FUNCT_4:82;
L996: ( dom D32 ) = { ( LastLoc C742 ) } by L995 , FUNCOP_1:13;
thus L997: ( dom ( CutLastLoc C742 ) ) c= ( ( dom C742 ) \ { ( LastLoc C742 ) } )
proof
let C743 being set;
assume L998: C743 in ( dom ( CutLastLoc C742 ) );
consider C744 being set such that L999: [ C743 , C744 ] in ( C742 \ D32 ) by L998 , L995 , XTUPLE_0:def 12;
L1000: (not [ C743 , C744 ] in D32) by L999 , XBOOLE_0:def 5;
L1001: C743 in ( dom C742 ) by L999 , XTUPLE_0:def 12;
per cases  by L1000 , TARSKI:def 1;
suppose L1002: C743 <> ( LastLoc C742 );

L1003: (not C743 in ( dom D32 )) by L1002 , L996 , TARSKI:def 1;
thus L1004: thesis by L1003 , L994 , L995 , L1001 , XBOOLE_0:def 5;
end;
suppose L1005: C744 <> ( C742 . ( LastLoc C742 ) );

L1006:
now
assume L1007: C743 in ( dom D32 );
L1008: C743 = ( LastLoc C742 ) by L1007 , L996 , TARSKI:def 1;
thus L1009: contradiction by L1008 , L999 , L1005 , FUNCT_1:1;
end;
thus L1010: thesis by L1006 , L994 , L995 , L1001 , XBOOLE_0:def 5;
end;
end;

thus L1012: thesis by L994 , RELAT_1:3;
end;
theorem
L1013: (for B207 being non  empty ( NAT ) -defined  finite Function holds ( dom B207 ) = ( ( dom ( CutLastLoc B207 ) ) \/ { ( LastLoc B207 ) } ))
proof
let C745 being non  empty ( NAT ) -defined  finite Function;
L1014: ( LastLoc C745 ) in ( dom C745 ) by L986;
L1015: { ( LastLoc C745 ) } c= ( dom C745 ) by L1014 , ZFMISC_1:31;
L1016: ( dom ( CutLastLoc C745 ) ) = ( ( dom C745 ) \ { ( LastLoc C745 ) } ) by L993;
thus L1017: thesis by L1016 , L1015 , XBOOLE_1:45;
end;
registration
cluster 1 -element ( NAT ) -defined  finite for Function;
existence
proof
take ( ( 0 ) .--> ( 0 ) );
thus L1018: thesis;
end;
end;
registration
let C746 being 1 -element ( NAT ) -defined  finite Function;
cluster ( CutLastLoc C746 ) ->  empty;
coherence
proof
L1020: ( LastLoc C746 ) in ( dom C746 ) by L986;
L1021: [ ( LastLoc C746 ) , ( C746 . ( LastLoc C746 ) ) ] in C746 by L1020 , FUNCT_1:def 2;
assume L1022: (not thesis);
consider C747 being set such that L1023: C747 in ( CutLastLoc C746 ) by L1022 , XBOOLE_0:def 1;
L1024: C747 = [ ( LastLoc C746 ) , ( C746 . ( LastLoc C746 ) ) ] by L1021 , L1023 , ZFMISC_1:def 10;
L1025: (not C747 in ( ( LastLoc C746 ) .--> ( C746 . ( LastLoc C746 ) ) )) by L1023 , XBOOLE_0:def 5;
L1026: (not C747 in { [ ( LastLoc C746 ) , ( C746 . ( LastLoc C746 ) ) ] }) by L1025 , FUNCT_4:82;
thus L1027: thesis by L1026 , L1024 , TARSKI:def 1;
end;
end;
theorem
L1029: (for B208 being non  empty ( NAT ) -defined  finite Function holds ( card ( CutLastLoc B208 ) ) = ( ( card B208 ) - 1 ))
proof
let C748 being non  empty ( NAT ) -defined  finite Function;
L1030: ( ( LastLoc C748 ) .--> ( C748 . ( LastLoc C748 ) ) ) c= C748
proof
let C749 , C750 being set;
assume L1031: [ C749 , C750 ] in ( ( LastLoc C748 ) .--> ( C748 . ( LastLoc C748 ) ) );
L1032: [ C749 , C750 ] in { [ ( LastLoc C748 ) , ( C748 . ( LastLoc C748 ) ) ] } by L1031 , FUNCT_4:82;
L1033: [ C749 , C750 ] = [ ( LastLoc C748 ) , ( C748 . ( LastLoc C748 ) ) ] by L1032 , TARSKI:def 1;
L1034: ( LastLoc C748 ) in ( dom C748 ) by L986;
thus L1035: thesis by L1034 , L1033 , FUNCT_1:def 2;
end;
thus L1036: ( card ( CutLastLoc C748 ) ) = ( ( card C748 ) - ( card ( ( LastLoc C748 ) .--> ( C748 . ( LastLoc C748 ) ) ) ) ) by L1030 , CARD_2:44
.= ( ( card C748 ) - ( card { [ ( LastLoc C748 ) , ( C748 . ( LastLoc C748 ) ) ] } ) ) by FUNCT_4:82
.= ( ( card C748 ) - 1 ) by CARD_1:30;
end;
begin
registration
let C751 being set;
let C752 being C751 -defined  complex-valued Function;
cluster ( - C752 ) -> C751 -defined;
coherence
proof
L1037: ( dom ( - C752 ) ) = ( dom C752 ) by L289;
thus L1038: ( dom ( - C752 ) ) c= C751 by L1037;
end;
cluster ( C752 " ) -> C751 -defined;
coherence
proof
L1039: ( dom ( C752 " ) ) = ( dom C752 ) by L408;
thus L1040: ( dom ( C752 " ) ) c= C751 by L1039;
end;
cluster ( C752 ^2 ) -> C751 -defined;
coherence
proof
L1041: ( dom ( C752 ^2 ) ) = ( dom C752 ) by L468;
thus L1042: ( dom ( C752 ^2 ) ) c= C751 by L1041;
end;
cluster |. C752 .| -> C751 -defined;
coherence
proof
L1043: ( dom |. C752 .| ) = ( dom C752 ) by L589;
thus L1044: ( dom |. C752 .| ) c= C751 by L1043;
end;
end;
registration
let C753 being set;
cluster  total for C753 -defined  natural-valued C753 -defined  natural-valued C753 -defined  natural-valued C753 -defined  natural-valued Function;
existence
proof
take the  total (PartFunc of C753 , ( NAT ));
thus L1046: thesis;
end;
end;
registration
let C754 being set;
let C755 being  total C754 -defined  complex-valued Function;
cluster ( - C755 ) ->  total;
coherence
proof
L1048: ( dom ( - C755 ) ) = ( dom C755 ) by L289;
L1049: ( dom C755 ) = C754 by PARTFUN1:def 2;
thus L1050: thesis by L1049 , L1048 , PARTFUN1:def 2;
end;
cluster ( C755 " ) ->  total;
coherence
proof
L1051: ( dom ( C755 " ) ) = ( dom C755 ) by L408;
L1052: ( dom C755 ) = C754 by PARTFUN1:def 2;
thus L1053: thesis by L1052 , L1051 , PARTFUN1:def 2;
end;
cluster ( C755 ^2 ) ->  total;
coherence
proof
L1054: ( dom ( C755 ^2 ) ) = ( dom C755 ) by L468;
L1055: ( dom C755 ) = C754 by PARTFUN1:def 2;
thus L1056: thesis by L1055 , L1054 , PARTFUN1:def 2;
end;
cluster |. C755 .| ->  total;
coherence
proof
L1057: ( dom |. C755 .| ) = ( dom C755 ) by L589;
L1058: ( dom C755 ) = C754 by PARTFUN1:def 2;
thus L1059: thesis by L1058 , L1057 , PARTFUN1:def 2;
end;
end;
registration
let C756 being set;
let C757 being C756 -defined  complex-valued Function;
let C758 being  complex number;
cluster ( C758 + C757 ) -> C756 -defined;
coherence
proof
L1061: ( dom ( C758 + C757 ) ) = ( dom C757 ) by L105;
thus L1062: ( dom ( C758 + C757 ) ) c= C756 by L1061;
end;
cluster ( C757 - C758 ) -> C756 -defined;
coherence;
cluster ( C758 (#) C757 ) -> C756 -defined;
coherence
proof
L1063: ( dom ( C758 (#) C757 ) ) = ( dom C757 ) by L289;
thus L1064: ( dom ( C758 (#) C757 ) ) c= C756 by L1063;
end;
end;
registration
let C759 being set;
let C760 being  total C759 -defined  complex-valued Function;
let C761 being  complex number;
cluster ( C761 + C760 ) ->  total;
coherence
proof
L1066: ( dom ( C761 + C760 ) ) = ( dom C760 ) by L105;
L1067: ( dom C760 ) = C759 by PARTFUN1:def 2;
thus L1068: thesis by L1067 , L1066 , PARTFUN1:def 2;
end;
cluster ( C760 - C761 ) ->  total;
coherence;
cluster ( C761 (#) C760 ) ->  total;
coherence
proof
L1069: ( dom ( C761 (#) C760 ) ) = ( dom C760 ) by L289;
L1070: ( dom C760 ) = C759 by PARTFUN1:def 2;
thus L1071: thesis by L1070 , L1069 , PARTFUN1:def 2;
end;
end;
registration
let C762 being set;
let C763 being  complex-valued Function;
let C764 being C762 -defined  complex-valued Function;
cluster ( C763 + C764 ) -> C762 -defined;
coherence
proof
L1073: ( dom ( C763 + C764 ) ) = ( ( dom C763 ) /\ ( dom C764 ) ) by L22;
L1074: ( dom ( C763 + C764 ) ) c= ( dom C764 ) by L1073 , XBOOLE_1:17;
thus L1075: ( dom ( C763 + C764 ) ) c= C762 by L1074 , XBOOLE_1:1;
end;
cluster ( C763 - C764 ) -> C762 -defined;
coherence;
cluster ( C763 (#) C764 ) -> C762 -defined;
coherence
proof
L1076: ( dom ( C763 (#) C764 ) ) = ( ( dom C763 ) /\ ( dom C764 ) ) by L206;
L1077: ( dom ( C763 (#) C764 ) ) c= ( dom C764 ) by L1076 , XBOOLE_1:17;
thus L1078: ( dom ( C763 (#) C764 ) ) c= C762 by L1077 , XBOOLE_1:1;
end;
cluster ( C763 /" C764 ) -> C762 -defined;
coherence;
end;
registration
let C765 being set;
let C766 , C767 being  total C765 -defined  complex-valued Function;
cluster ( C766 + C767 ) ->  total;
coherence
proof
L1080: ( dom ( C766 + C767 ) ) = ( ( dom C766 ) /\ ( dom C767 ) ) by L22;
L1081: (( dom C766 ) = C765 & ( dom C767 ) = C765) by PARTFUN1:def 2;
thus L1082: thesis by L1081 , L1080 , PARTFUN1:def 2;
end;
cluster ( C766 - C767 ) ->  total;
coherence;
cluster ( C766 (#) C767 ) ->  total;
coherence
proof
L1083: ( dom ( C766 (#) C767 ) ) = ( ( dom C766 ) /\ ( dom C767 ) ) by L206;
L1084: (( dom C766 ) = C765 & ( dom C767 ) = C765) by PARTFUN1:def 2;
thus L1085: thesis by L1084 , L1083 , PARTFUN1:def 2;
end;
cluster ( C766 /" C767 ) ->  total;
coherence;
end;
registration
let C768 being non  empty set;
let C769 being C768 -valued non  empty ( NAT ) -defined  finite Function;
cluster ( CutLastLoc C769 ) -> C768 -valued;
coherence;
end;
theorem
L1088: (for B209 being Function holds (for B210 , B211 being Nat holds (B210 in ( dom ( Shift (B209 , B211) ) ) implies (ex B212 being Nat st (B212 in ( dom B209 ) & B210 = ( B212 + B211 ))))))
proof
let C770 being Function;
let C771 , C772 being Nat;
L1089: ( dom ( Shift (C770 , C772) ) ) = { ( R1 + C772 ) where R1 is (Element of ( NAT )) : R1 in ( dom C770 ) } by L658;
assume L1090: C771 in ( dom ( Shift (C770 , C772) ) );
L1091: (ex B213 being (Element of ( NAT )) st (C771 = ( B213 + C772 ) & B213 in ( dom C770 ))) by L1090 , L1089;
thus L1092: (ex B214 being Nat st (B214 in ( dom C770 ) & C771 = ( B214 + C772 ))) by L1091;
end;
