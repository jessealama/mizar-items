:: Real Functions Spaces
::  by Henryk Oryszczyszyn and Krzysztof Pra\.zmowski
::
:: Received March 23, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, BINOP_1, FUNCT_2, SUBSET_1, FUNCT_1, ZFMISC_1, NUMBERS,
      RELAT_1, FUNCOP_1, BINOP_2, REAL_1, CARD_1, ARYTM_3, RLVECT_1, ARYTM_1,
      STRUCT_0, ALGSTR_0, XREAL_0, ORDINAL1, SUPINF_2, GROUP_1, MESFUNC1,
      VECTSP_1, LATTICES, FUNCSDOM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      FUNCT_2, BINOP_1, DOMAIN_1, FUNCOP_1, BINOP_2, ORDINAL1, XCMPLX_0,
      XREAL_0, STRUCT_0, ALGSTR_0, RLVECT_1, REAL_1, GROUP_1, VECTSP_1;
 constructors BINOP_1, DOMAIN_1, FUNCOP_1, REAL_1, BINOP_2, VECTSP_1, RLVECT_1,
      FUNCT_3, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, NUMBERS, RLVECT_1, VECTSP_1,
      ALGSTR_0, BINOP_2, FUNCOP_1, FUNCT_3, REAL_1, XREAL_0, ORDINAL1, RELAT_1,
      VALUED_0, STRUCT_0, CARD_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, STRUCT_0, GROUP_1, BINOP_1, VECTSP_1, ALGSTR_0,
      FUNCOP_1, FUNCT_2;
 theorems FUNCT_2, BINOP_1, FUNCOP_1, TARSKI, BINOP_2, STRUCT_0, XREAL_0;
 schemes BINOP_1, FUNCT_2;

begin
definition
let C1 being set;
let C2 being non  empty set;
let C3 being (BinOp of ( Funcs (C1 , C2) ));
let C4 , C5 being (Element of ( Funcs (C1 , C2) ));
redefine func C3 . (C4 , C5) -> (Element of ( Funcs (C1 , C2) ));

coherence
proof
reconsider D1 = C4 , D2 = C5 as (Element of (( Funcs (C1 , C2) ) qua non  empty set));
L1: ( C3 . (D1 , D2) ) is (Element of ( Funcs (C1 , C2) ));
thus L2: thesis by L1;
end;
end;
definition
let C6 , C7 , C8 , C9 being non  empty set;
let C10 being (Function of [: C8 , C9 :] , ( Funcs (C6 , C7) ));
let C11 being (Element of [: C8 , C9 :]);
redefine func C10 . C11 -> (Element of ( Funcs (C6 , C7) ));

coherence
proof
L4: ( C10 . C11 ) is (Element of ( Funcs (C6 , C7) ));
thus L5: thesis by L4;
end;
end;
definition
let C12 being non  empty set;
let C13 being set;
let C14 being (BinOp of C12);
let C15 , C16 being (Function of C13 , C12);
redefine func C14 .: (C15 , C16) -> (Element of ( Funcs (C13 , C12) ));

coherence
proof
L7: ( C14 .: (C15 , C16) ) in ( Funcs (C13 , C12) ) by FUNCT_2:8;
thus L8: thesis by L7;
end;
end;
definition
let C17 being non  empty set;
let C18 being set;
let C19 being (BinOp of C17);
let C20 being (Element of C17);
let C21 being (Function of C18 , C17);
redefine func C19 [;] (C20 , C21) -> (Element of ( Funcs (C18 , C17) ));

coherence
proof
L10: ( C19 [;] (C20 , C21) ) in ( Funcs (C18 , C17) ) by FUNCT_2:8;
thus L11: thesis by L10;
end;
end;
definition
let C22 being set;
func RealFuncAdd C22 -> (BinOp of ( Funcs (C22 , ( REAL )) )) means 
:L13: (for B1 , B2 being (Element of ( Funcs (C22 , ( REAL )) )) holds ( it . (B1 , B2) ) = ( ( addreal ) .: (B1 , B2) ));
existence
proof
deffunc H1((Element of ( Funcs (C22 , ( REAL )) )) , (Element of ( Funcs (C22 , ( REAL )) ))) = ( ( addreal ) .: ($1 , $2) );
consider C23 being (BinOp of ( Funcs (C22 , ( REAL )) )) such that L14: (for B3 , B4 being (Element of ( Funcs (C22 , ( REAL )) )) holds ( C23 . (B3 , B4) ) = H1(B3 , B4)) from BINOP_1:sch 4;
take C23;
let C24 , C25 being (Element of ( Funcs (C22 , ( REAL )) ));
thus L15: thesis by L14;
end;
uniqueness
proof
let C26 , C27 being (BinOp of ( Funcs (C22 , ( REAL )) ));
assume that
L16: (for B5 , B6 being (Element of ( Funcs (C22 , ( REAL )) )) holds ( C26 . (B5 , B6) ) = ( ( addreal ) .: (B5 , B6) ))
and
L17: (for B7 , B8 being (Element of ( Funcs (C22 , ( REAL )) )) holds ( C27 . (B7 , B8) ) = ( ( addreal ) .: (B7 , B8) ));
L18:
now
let C28 , C29 being (Element of ( Funcs (C22 , ( REAL )) ));
thus L19: ( C26 . (C28 , C29) ) = ( ( addreal ) .: (C28 , C29) ) by L16
.= ( C27 . (C28 , C29) ) by L17;
end;
thus L20: thesis by L18 , BINOP_1:2;
end;
end;
definition
let C30 being set;
func RealFuncMult C30 -> (BinOp of ( Funcs (C30 , ( REAL )) )) means 
:L22: (for B9 , B10 being (Element of ( Funcs (C30 , ( REAL )) )) holds ( it . (B9 , B10) ) = ( ( multreal ) .: (B9 , B10) ));
existence
proof
deffunc H2((Element of ( Funcs (C30 , ( REAL )) )) , (Element of ( Funcs (C30 , ( REAL )) ))) = ( ( multreal ) .: ($1 , $2) );
consider C31 being (BinOp of ( Funcs (C30 , ( REAL )) )) such that L23: (for B11 , B12 being (Element of ( Funcs (C30 , ( REAL )) )) holds ( C31 . (B11 , B12) ) = H2(B11 , B12)) from BINOP_1:sch 4;
take C31;
let C32 , C33 being (Element of ( Funcs (C30 , ( REAL )) ));
thus L24: thesis by L23;
end;
uniqueness
proof
let C34 , C35 being (BinOp of ( Funcs (C30 , ( REAL )) ));
assume that
L25: (for B13 , B14 being (Element of ( Funcs (C30 , ( REAL )) )) holds ( C34 . (B13 , B14) ) = ( ( multreal ) .: (B13 , B14) ))
and
L26: (for B15 , B16 being (Element of ( Funcs (C30 , ( REAL )) )) holds ( C35 . (B15 , B16) ) = ( ( multreal ) .: (B15 , B16) ));
L27:
now
let C36 , C37 being (Element of ( Funcs (C30 , ( REAL )) ));
thus L28: ( C34 . (C36 , C37) ) = ( ( multreal ) .: (C36 , C37) ) by L25
.= ( C35 . (C36 , C37) ) by L26;
end;
thus L29: thesis by L27 , BINOP_1:2;
end;
end;
definition
let C38 being set;
func RealFuncExtMult C38 -> (Function of [: ( REAL ) , ( Funcs (C38 , ( REAL )) ) :] , ( Funcs (C38 , ( REAL )) )) means 
:L31: (for B17 being Real holds (for B18 being (Element of ( Funcs (C38 , ( REAL )) )) holds ( it . (B17 , B18) ) = ( ( multreal ) [;] (B17 , B18) )));
existence
proof
deffunc H3((Element of ( REAL )) , (Element of ( Funcs (C38 , ( REAL )) ))) = ( ( multreal ) [;] ($1 , $2) );
consider C39 being (Function of [: ( REAL ) , ( Funcs (C38 , ( REAL )) ) :] , ( Funcs (C38 , ( REAL )) )) such that L32: (for B19 being (Element of ( REAL )) holds (for B20 being (Element of ( Funcs (C38 , ( REAL )) )) holds ( C39 . (B19 , B20) ) = H3(B19 , B20))) from BINOP_1:sch 4;
take C39;
let C40 being Real;
let C41 being (Element of ( Funcs (C38 , ( REAL )) ));
thus L33: thesis by L32;
end;
uniqueness
proof
let C42 , C43 being (Function of [: ( REAL ) , ( Funcs (C38 , ( REAL )) ) :] , ( Funcs (C38 , ( REAL )) ));
assume that
L34: (for B21 being Real holds (for B22 being (Element of ( Funcs (C38 , ( REAL )) )) holds ( C42 . (B21 , B22) ) = ( ( multreal ) [;] (B21 , B22) )))
and
L35: (for B23 being Real holds (for B24 being (Element of ( Funcs (C38 , ( REAL )) )) holds ( C43 . (B23 , B24) ) = ( ( multreal ) [;] (B23 , B24) )));
L36:
now
let C44 being Real;
let C45 being (Element of ( Funcs (C38 , ( REAL )) ));
thus L37: ( C42 . (C44 , C45) ) = ( ( multreal ) [;] (C44 , C45) ) by L34
.= ( C43 . (C44 , C45) ) by L35;
end;
thus L38: thesis by L36 , BINOP_1:2;
end;
end;
definition
let C46 being set;
func RealFuncZero C46 -> (Element of ( Funcs (C46 , ( REAL )) )) equals 
( C46 --> ( 0 ) );
coherence
proof
L40: ( C46 --> ( 0 ) ) is (Function of C46 , ( REAL )) by FUNCOP_1:45;
thus L41: thesis by L40 , FUNCT_2:8;
end;
end;
definition
let C47 being set;
func RealFuncUnit C47 -> (Element of ( Funcs (C47 , ( REAL )) )) equals 
( C47 --> 1 );
coherence
proof
L43: ( C47 --> 1 ) is (Function of C47 , ( REAL )) by FUNCOP_1:45;
thus L44: thesis by L43 , FUNCT_2:8;
end;
end;
L46: (for R4 being non  empty set holds (for R5 being non  empty set holds (for B25 being (Element of R4) holds (for B26 being (Function of R4 , R5) holds B25 in ( dom B26 )))))
proof
let R4 being non  empty set;
let R5 being non  empty set;
let C48 being (Element of R4);
let C49 being (Function of R4 , R5);
L47: C48 in R4;
thus L48: thesis by L47 , FUNCT_2:def 1;
end;
theorem
L49: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R7 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R8 being (Element of ( Funcs (R4 , ( REAL )) )) holds (R8 = ( ( RealFuncAdd R4 ) . (R6 , R7) ) iff (for B27 being (Element of R4) holds ( R8 . B27 ) = ( ( R6 . B27 ) + ( R7 . B27 ) )))))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( REAL )) ));
let R7 being (Element of ( Funcs (R4 , ( REAL )) ));
let R8 being (Element of ( Funcs (R4 , ( REAL )) ));
L50:
now
assume L51: (for B28 being (Element of R4) holds ( R8 . B28 ) = ( ( R6 . B28 ) + ( R7 . B28 ) ));
L52:
now
let C50 being (Element of R4);
L53: C50 in ( dom ( ( addreal ) .: (R6 , R7) ) ) by L46;
thus L54: ( ( ( RealFuncAdd R4 ) . (R6 , R7) ) . C50 ) = ( ( ( addreal ) .: (R6 , R7) ) . C50 ) by L13
.= ( ( addreal ) . (( R6 . C50 ) , ( R7 . C50 )) ) by L53 , FUNCOP_1:22
.= ( ( R6 . C50 ) + ( R7 . C50 ) ) by BINOP_2:def 9
.= ( R8 . C50 ) by L51;
end;
thus L55: R8 = ( ( RealFuncAdd R4 ) . (R6 , R7) ) by L52 , FUNCT_2:63;
end;
L56:
now
assume L57: R8 = ( ( RealFuncAdd R4 ) . (R6 , R7) );
let C51 being (Element of R4);
L58: C51 in ( dom ( ( addreal ) .: (R6 , R7) ) ) by L46;
thus L59: ( R8 . C51 ) = ( ( ( addreal ) .: (R6 , R7) ) . C51 ) by L57 , L13
.= ( ( addreal ) . (( R6 . C51 ) , ( R7 . C51 )) ) by L58 , FUNCOP_1:22
.= ( ( R6 . C51 ) + ( R7 . C51 ) ) by BINOP_2:def 9;
end;
thus L60: thesis by L56 , L50;
end;
theorem
L61: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R7 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R8 being (Element of ( Funcs (R4 , ( REAL )) )) holds (R8 = ( ( RealFuncMult R4 ) . (R6 , R7) ) iff (for B29 being (Element of R4) holds ( R8 . B29 ) = ( ( R6 . B29 ) * ( R7 . B29 ) )))))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( REAL )) ));
let R7 being (Element of ( Funcs (R4 , ( REAL )) ));
let R8 being (Element of ( Funcs (R4 , ( REAL )) ));
L62:
now
assume L63: (for B30 being (Element of R4) holds ( R8 . B30 ) = ( ( R6 . B30 ) * ( R7 . B30 ) ));
L64:
now
let C52 being (Element of R4);
L65: C52 in ( dom ( ( multreal ) .: (R6 , R7) ) ) by L46;
thus L66: ( ( ( RealFuncMult R4 ) . (R6 , R7) ) . C52 ) = ( ( ( multreal ) .: (R6 , R7) ) . C52 ) by L22
.= ( ( multreal ) . (( R6 . C52 ) , ( R7 . C52 )) ) by L65 , FUNCOP_1:22
.= ( ( R6 . C52 ) * ( R7 . C52 ) ) by BINOP_2:def 11
.= ( R8 . C52 ) by L63;
end;
thus L67: R8 = ( ( RealFuncMult R4 ) . (R6 , R7) ) by L64 , FUNCT_2:63;
end;
L68:
now
assume L69: R8 = ( ( RealFuncMult R4 ) . (R6 , R7) );
let C53 being (Element of R4);
L70: C53 in ( dom ( ( multreal ) .: (R6 , R7) ) ) by L46;
thus L71: ( R8 . C53 ) = ( ( ( multreal ) .: (R6 , R7) ) . C53 ) by L69 , L22
.= ( ( multreal ) . (( R6 . C53 ) , ( R7 . C53 )) ) by L70 , FUNCOP_1:22
.= ( ( R6 . C53 ) * ( R7 . C53 ) ) by BINOP_2:def 11;
end;
thus L72: thesis by L68 , L62;
end;
theorem
L73: (for R4 being non  empty set holds ( RealFuncZero R4 ) <> ( RealFuncUnit R4 ))
proof
let R4 being non  empty set;
set D3 = the (Element of R4);
L74: ( ( RealFuncZero R4 ) . D3 ) = ( 0 ) by FUNCOP_1:7;
thus L75: thesis by L74 , FUNCOP_1:7;
end;
theorem
L76: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R8 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R9 being Real holds (R8 = ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) iff (for B31 being (Element of R4) holds ( R8 . B31 ) = ( R9 * ( R6 . B31 ) )))))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( REAL )) ));
let R8 being (Element of ( Funcs (R4 , ( REAL )) ));
let R9 being Real;
thus L77: (R8 = ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) implies (for B32 being (Element of R4) holds ( R8 . B32 ) = ( R9 * ( R6 . B32 ) )))
proof
assume L78: R8 = ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] );
let C54 being (Element of R4);
L79: R8 = ( ( RealFuncExtMult R4 ) . (R9 , R6) ) by L78;
thus L80: ( R8 . C54 ) = ( ( ( multreal ) [;] (R9 , R6) ) . C54 ) by L79 , L31
.= ( ( multreal ) . (R9 , ( R6 . C54 )) ) by FUNCOP_1:53
.= ( R9 * ( R6 . C54 ) ) by BINOP_2:def 11;
end;

L81:
now
assume L82: (for B33 being (Element of R4) holds ( R8 . B33 ) = ( R9 * ( R6 . B33 ) ));
L83: (for B34 being (Element of R4) holds ( R8 . B34 ) = ( ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) . B34 ))
proof
let C55 being (Element of R4);
L84: ( ( multreal ) [;] (R9 , R6) ) = ( ( RealFuncExtMult R4 ) . (R9 , R6) ) by L31;
thus L85: ( R8 . C55 ) = ( R9 * ( R6 . C55 ) ) by L82
.= ( ( multreal ) . (R9 , ( R6 . C55 )) ) by BINOP_2:def 11
.= ( ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) . C55 ) by L84 , FUNCOP_1:53;
end;
thus L86: R8 = ( ( RealFuncExtMult R4 ) . (R9 , R6) ) by L83 , FUNCT_2:63;
end;
thus L87: thesis by L81;
end;
theorem
L88: (for B35 being set holds (for B36 , B37 being (Element of ( Funcs (B35 , ( REAL )) )) holds ( ( RealFuncAdd B35 ) . (B36 , B37) ) = ( ( RealFuncAdd B35 ) . (B37 , B36) )))
proof
let C56 being set;
let C57 , C58 being (Element of ( Funcs (C56 , ( REAL )) ));
thus L89: ( ( RealFuncAdd C56 ) . (C57 , C58) ) = ( ( addreal ) .: (C57 , C58) ) by L13
.= ( ( addreal ) .: (C58 , C57) ) by FUNCOP_1:65
.= ( ( RealFuncAdd C56 ) . (C58 , C57) ) by L13;
end;
theorem
L90: (for B38 being set holds (for B39 , B40 , B41 being (Element of ( Funcs (B38 , ( REAL )) )) holds ( ( RealFuncAdd B38 ) . (B39 , ( ( RealFuncAdd B38 ) . (B40 , B41) )) ) = ( ( RealFuncAdd B38 ) . (( ( RealFuncAdd B38 ) . (B39 , B40) ) , B41) )))
proof
let C59 being set;
let C60 , C61 , C62 being (Element of ( Funcs (C59 , ( REAL )) ));
thus L91: ( ( RealFuncAdd C59 ) . (C60 , ( ( RealFuncAdd C59 ) . (C61 , C62) )) ) = ( ( RealFuncAdd C59 ) . (C60 , ( ( addreal ) .: (C61 , C62) )) ) by L13
.= ( ( addreal ) .: (C60 , ( ( addreal ) .: (C61 , C62) )) ) by L13
.= ( ( addreal ) .: (( ( addreal ) .: (C60 , C61) ) , C62) ) by FUNCOP_1:61
.= ( ( RealFuncAdd C59 ) . (( ( addreal ) .: (C60 , C61) ) , C62) ) by L13
.= ( ( RealFuncAdd C59 ) . (( ( RealFuncAdd C59 ) . (C60 , C61) ) , C62) ) by L13;
end;
theorem
L92: (for B42 being set holds (for B43 , B44 being (Element of ( Funcs (B42 , ( REAL )) )) holds ( ( RealFuncMult B42 ) . (B43 , B44) ) = ( ( RealFuncMult B42 ) . (B44 , B43) )))
proof
let C63 being set;
let C64 , C65 being (Element of ( Funcs (C63 , ( REAL )) ));
thus L93: ( ( RealFuncMult C63 ) . (C64 , C65) ) = ( ( multreal ) .: (C64 , C65) ) by L22
.= ( ( multreal ) .: (C65 , C64) ) by FUNCOP_1:65
.= ( ( RealFuncMult C63 ) . (C65 , C64) ) by L22;
end;
theorem
L94: (for B45 being set holds (for B46 , B47 , B48 being (Element of ( Funcs (B45 , ( REAL )) )) holds ( ( RealFuncMult B45 ) . (B46 , ( ( RealFuncMult B45 ) . (B47 , B48) )) ) = ( ( RealFuncMult B45 ) . (( ( RealFuncMult B45 ) . (B46 , B47) ) , B48) )))
proof
let C66 being set;
let C67 , C68 , C69 being (Element of ( Funcs (C66 , ( REAL )) ));
thus L95: ( ( RealFuncMult C66 ) . (C67 , ( ( RealFuncMult C66 ) . (C68 , C69) )) ) = ( ( RealFuncMult C66 ) . (C67 , ( ( multreal ) .: (C68 , C69) )) ) by L22
.= ( ( multreal ) .: (C67 , ( ( multreal ) .: (C68 , C69) )) ) by L22
.= ( ( multreal ) .: (( ( multreal ) .: (C67 , C68) ) , C69) ) by FUNCOP_1:61
.= ( ( RealFuncMult C66 ) . (( ( multreal ) .: (C67 , C68) ) , C69) ) by L22
.= ( ( RealFuncMult C66 ) . (( ( RealFuncMult C66 ) . (C67 , C68) ) , C69) ) by L22;
end;
theorem
L96: (for B49 being set holds (for B50 being (Element of ( Funcs (B49 , ( REAL )) )) holds ( ( RealFuncMult B49 ) . (( RealFuncUnit B49 ) , B50) ) = B50))
proof
let C70 being set;
let C71 being (Element of ( Funcs (C70 , ( REAL )) ));
per cases ;
suppose L97: C70 = ( {} );

L98: C71 = ( {} ) by L97;
thus L99: ( ( RealFuncMult C70 ) . (( RealFuncUnit C70 ) , C71) ) = ( ( multreal ) .: (( RealFuncUnit C70 ) , C71) ) by L22
.= C71 by L98;
end;
suppose L100: C70 <> ( {} );

reconsider D4 = C70 as non  empty set by L100;
reconsider D5 = C71 as (Element of ( Funcs (D4 , ( REAL )) ));
L101:
now
let C72 being (Element of D4);
thus L102: ( ( ( RealFuncMult D4 ) . (( RealFuncUnit D4 ) , D5) ) . C72 ) = ( ( ( RealFuncUnit D4 ) . C72 ) * ( D5 . C72 ) ) by L61
.= ( 1 * ( D5 . C72 ) ) by FUNCOP_1:7
.= ( D5 . C72 );
end;
thus L103: thesis by L101 , FUNCT_2:63;
end;
end;
theorem
L105: (for B51 being set holds (for B52 being (Element of ( Funcs (B51 , ( REAL )) )) holds ( ( RealFuncAdd B51 ) . (( RealFuncZero B51 ) , B52) ) = B52))
proof
let C73 being set;
let C74 being (Element of ( Funcs (C73 , ( REAL )) ));
per cases ;
suppose L106: C73 = ( {} );

L107: C74 = ( {} ) by L106;
thus L108: ( ( RealFuncAdd C73 ) . (( RealFuncZero C73 ) , C74) ) = ( ( addreal ) .: (( RealFuncZero C73 ) , C74) ) by L13
.= C74 by L107;
end;
suppose L109: C73 <> ( {} );

reconsider D6 = C73 as non  empty set by L109;
reconsider D7 = C74 as (Element of ( Funcs (D6 , ( REAL )) ));
L110:
now
let C75 being (Element of D6);
thus L111: ( ( ( RealFuncAdd D6 ) . (( RealFuncZero D6 ) , D7) ) . C75 ) = ( ( ( RealFuncZero D6 ) . C75 ) + ( D7 . C75 ) ) by L49
.= ( ( 0 ) + ( D7 . C75 ) ) by FUNCOP_1:7
.= ( D7 . C75 );
end;
thus L112: thesis by L110 , FUNCT_2:63;
end;
end;
theorem
L114: (for B53 being set holds (for B54 being (Element of ( Funcs (B53 , ( REAL )) )) holds ( ( RealFuncAdd B53 ) . (B54 , ( ( RealFuncExtMult B53 ) . [ ( - 1 ) , B54 ] )) ) = ( RealFuncZero B53 )))
proof
let C76 being set;
let C77 being (Element of ( Funcs (C76 , ( REAL )) ));
per cases ;
suppose L115: C76 = ( {} );

thus L116: ( ( RealFuncAdd C76 ) . (C77 , ( ( RealFuncExtMult C76 ) . [ ( - 1 ) , C77 ] )) ) = ( {} ) by L115
.= ( RealFuncZero C76 ) by L115;
end;
suppose L117: C76 <> ( {} );

reconsider D8 = C76 as non  empty set by L117;
reconsider D9 = C77 as (Element of ( Funcs (D8 , ( REAL )) ));
L118:
now
let C78 being (Element of D8);
set D10 = ( D9 . C78 );
thus L119: ( ( ( RealFuncAdd D8 ) . (D9 , ( ( RealFuncExtMult D8 ) . [ ( - 1 ) , D9 ] )) ) . C78 ) = ( ( D9 . C78 ) + ( ( ( RealFuncExtMult D8 ) . [ ( - 1 ) , D9 ] ) . C78 ) ) by L49
.= ( ( D9 . C78 ) + ( ( - 1 ) * D10 ) ) by L76
.= ( ( RealFuncZero D8 ) . C78 ) by FUNCOP_1:7;
end;
thus L120: thesis by L118 , FUNCT_2:63;
end;
end;
theorem
L122: (for B55 being set holds (for B56 being (Element of ( Funcs (B55 , ( REAL )) )) holds ( ( RealFuncExtMult B55 ) . (1 , B56) ) = B56))
proof
let C79 being set;
let C80 being (Element of ( Funcs (C79 , ( REAL )) ));
per cases ;
suppose L123: C79 = ( {} );

L124: C80 = ( {} ) by L123;
thus L125: ( ( RealFuncExtMult C79 ) . (1 , C80) ) = ( ( multreal ) [;] (1 , C80) ) by L31
.= C80 by L124;
end;
suppose L126: C79 <> ( {} );

reconsider D11 = C79 as non  empty set by L126;
reconsider D12 = C80 as (Element of ( Funcs (D11 , ( REAL )) ));
reconsider D13 = ( ( RealFuncExtMult D11 ) . (1 , D12) ) as (Element of ( Funcs (D11 , ( REAL )) ));
L127:
now
let C81 being (Element of D11);
thus L128: ( D13 . C81 ) = ( 1 * ( D12 . C81 ) ) by L76
.= ( D12 . C81 );
end;
thus L129: thesis by L127 , FUNCT_2:63;
end;
end;
theorem
L131: (for R9 being Real holds (for R10 being Real holds (for B57 being set holds (for B58 being (Element of ( Funcs (B57 , ( REAL )) )) holds ( ( RealFuncExtMult B57 ) . (R9 , ( ( RealFuncExtMult B57 ) . (R10 , B58) )) ) = ( ( RealFuncExtMult B57 ) . (( R9 * R10 ) , B58) )))))
proof
let R9 being Real;
let R10 being Real;
let C82 being set;
let C83 being (Element of ( Funcs (C82 , ( REAL )) ));
per cases ;
suppose L132: C82 = ( {} );

L133: ( ( RealFuncExtMult C82 ) . (R10 , C83) ) = ( ( multreal ) [;] (R10 , C83) ) by L31;
thus L134: ( ( RealFuncExtMult C82 ) . (R9 , ( ( RealFuncExtMult C82 ) . (R10 , C83) )) ) = ( ( multreal ) [;] (R9 , ( ( multreal ) [;] (R10 , C83) )) ) by L133 , L31
.= ( ( multreal ) [;] (( R9 * R10 ) , C83) ) by L132
.= ( ( RealFuncExtMult C82 ) . (( R9 * R10 ) , C83) ) by L31;
end;
suppose L135: C82 <> ( {} );

reconsider D14 = C82 as non  empty set by L135;
reconsider D15 = C83 as (Element of ( Funcs (D14 , ( REAL )) ));
L136:
now
let C84 being (Element of D14);
thus L137: ( ( ( RealFuncExtMult D14 ) . [ R9 , ( ( RealFuncExtMult D14 ) . [ R10 , D15 ] ) ] ) . C84 ) = ( R9 * ( ( ( RealFuncExtMult D14 ) . [ R10 , D15 ] ) . C84 ) ) by L76
.= ( R9 * ( R10 * ( D15 . C84 ) ) ) by L76
.= ( ( R9 * R10 ) * ( D15 . C84 ) )
.= ( ( ( RealFuncExtMult D14 ) . [ ( R9 * R10 ) , D15 ] ) . C84 ) by L76;
end;
thus L138: thesis by L136 , FUNCT_2:63;
end;
end;
theorem
L140: (for R9 being Real holds (for R10 being Real holds (for B59 being set holds (for B60 being (Element of ( Funcs (B59 , ( REAL )) )) holds ( ( RealFuncAdd B59 ) . (( ( RealFuncExtMult B59 ) . (R9 , B60) ) , ( ( RealFuncExtMult B59 ) . (R10 , B60) )) ) = ( ( RealFuncExtMult B59 ) . (( R9 + R10 ) , B60) )))))
proof
let R9 being Real;
let R10 being Real;
let C85 being set;
let C86 being (Element of ( Funcs (C85 , ( REAL )) ));
per cases ;
suppose L141: C85 = ( {} );

thus L142: ( ( RealFuncAdd C85 ) . (( ( RealFuncExtMult C85 ) . (R9 , C86) ) , ( ( RealFuncExtMult C85 ) . (R10 , C86) )) ) = ( {} ) by L141
.= ( ( multreal ) [;] (( R9 + R10 ) , C86) ) by L141
.= ( ( RealFuncExtMult C85 ) . (( R9 + R10 ) , C86) ) by L31;
end;
suppose L143: C85 <> ( {} );

reconsider D16 = C85 as non  empty set by L143;
reconsider D17 = C86 as (Element of ( Funcs (D16 , ( REAL )) ));
L144:
now
let C87 being (Element of D16);
thus L145: ( ( ( RealFuncAdd D16 ) . (( ( RealFuncExtMult D16 ) . [ R9 , D17 ] ) , ( ( RealFuncExtMult D16 ) . [ R10 , D17 ] )) ) . C87 ) = ( ( ( ( RealFuncExtMult D16 ) . [ R9 , D17 ] ) . C87 ) + ( ( ( RealFuncExtMult D16 ) . [ R10 , D17 ] ) . C87 ) ) by L49
.= ( ( R9 * ( D17 . C87 ) ) + ( ( ( RealFuncExtMult D16 ) . [ R10 , D17 ] ) . C87 ) ) by L76
.= ( ( R9 * ( D17 . C87 ) ) + ( R10 * ( D17 . C87 ) ) ) by L76
.= ( ( R9 + R10 ) * ( D17 . C87 ) )
.= ( ( ( RealFuncExtMult D16 ) . [ ( R9 + R10 ) , D17 ] ) . C87 ) by L76;
end;
thus L146: thesis by L144 , FUNCT_2:63;
end;
end;
L148: (for R9 being Real holds (for B61 being set holds (for B62 , B63 being (Element of ( Funcs (B61 , ( REAL )) )) holds ( ( RealFuncAdd B61 ) . (( ( RealFuncExtMult B61 ) . (R9 , B62) ) , ( ( RealFuncExtMult B61 ) . (R9 , B63) )) ) = ( ( RealFuncExtMult B61 ) . (R9 , ( ( RealFuncAdd B61 ) . (B62 , B63) )) ))))
proof
let R9 being Real;
let C88 being set;
let C89 , C90 being (Element of ( Funcs (C88 , ( REAL )) ));
per cases ;
suppose L149: C88 = ( {} );

thus L150: ( ( RealFuncAdd C88 ) . (( ( RealFuncExtMult C88 ) . (R9 , C89) ) , ( ( RealFuncExtMult C88 ) . (R9 , C90) )) ) = ( {} ) by L149
.= ( ( multreal ) [;] (R9 , ( ( RealFuncAdd C88 ) . (C89 , C90) )) ) by L149
.= ( ( RealFuncExtMult C88 ) . (R9 , ( ( RealFuncAdd C88 ) . (C89 , C90) )) ) by L31;
end;
suppose L151: C88 <> ( {} );

reconsider D18 = C88 as non  empty set by L151;
reconsider D19 = C89 , D20 = C90 as (Element of ( Funcs (D18 , ( REAL )) ));
L152:
now
let C91 being (Element of D18);
thus L153: ( ( ( RealFuncAdd D18 ) . (( ( RealFuncExtMult D18 ) . [ R9 , D19 ] ) , ( ( RealFuncExtMult D18 ) . [ R9 , D20 ] )) ) . C91 ) = ( ( ( ( RealFuncExtMult D18 ) . [ R9 , D19 ] ) . C91 ) + ( ( ( RealFuncExtMult D18 ) . [ R9 , D20 ] ) . C91 ) ) by L49
.= ( ( R9 * ( D19 . C91 ) ) + ( ( ( RealFuncExtMult D18 ) . [ R9 , D20 ] ) . C91 ) ) by L76
.= ( ( R9 * ( D19 . C91 ) ) + ( R9 * ( D20 . C91 ) ) ) by L76
.= ( R9 * ( ( D19 . C91 ) + ( D20 . C91 ) ) )
.= ( R9 * ( ( ( RealFuncAdd D18 ) . (D19 , D20) ) . C91 ) ) by L49
.= ( ( ( RealFuncExtMult D18 ) . [ R9 , ( ( RealFuncAdd D18 ) . (D19 , D20) ) ] ) . C91 ) by L76;
end;
thus L154: thesis by L152 , FUNCT_2:63;
end;
end;
theorem
L156: (for B64 being set holds (for B65 , B66 , B67 being (Element of ( Funcs (B64 , ( REAL )) )) holds ( ( RealFuncMult B64 ) . (B65 , ( ( RealFuncAdd B64 ) . (B66 , B67) )) ) = ( ( RealFuncAdd B64 ) . (( ( RealFuncMult B64 ) . (B65 , B66) ) , ( ( RealFuncMult B64 ) . (B65 , B67) )) )))
proof
let C92 being set;
let C93 , C94 , C95 being (Element of ( Funcs (C92 , ( REAL )) ));
L157: ( ( multreal ) .: (C93 , ( ( addreal ) .: (C94 , C95) )) ) = ( ( addreal ) .: (( ( multreal ) .: (C93 , C94) ) , ( ( multreal ) .: (C93 , C95) )) )
proof
let C96 being (Element of C92);
per cases ;
suppose L158: C92 = ( {} );

L159: C93 = ( {} ) by L158;
thus L160: ( ( ( multreal ) .: (C93 , ( ( addreal ) .: (C94 , C95) )) ) . C96 ) = ( ( ( addreal ) .: (( ( multreal ) .: (C93 , C94) ) , ( ( multreal ) .: (C93 , C95) )) ) . C96 ) by L159;
end;
suppose L161: C92 <> ( {} );

reconsider D21 = C92 as non  empty set by L161;
reconsider D22 = C93 , D23 = C94 , D24 = C95 as (Element of ( Funcs (D21 , ( REAL )) ));
reconsider D25 = C96 as (Element of D21);
thus L162: ( ( ( multreal ) .: (C93 , ( ( addreal ) .: (C94 , C95) )) ) . C96 ) = ( ( multreal ) . (( C93 . D25 ) , ( ( ( addreal ) .: (C94 , C95) ) . D25 )) ) by FUNCOP_1:37
.= ( ( multreal ) . (( C93 . D25 ) , ( ( addreal ) . (( C94 . D25 ) , ( C95 . D25 )) )) ) by FUNCOP_1:37
.= ( ( D22 . D25 ) * ( ( addreal ) . (( D23 . D25 ) , ( D24 . D25 )) ) ) by BINOP_2:def 11
.= ( ( D22 . D25 ) * ( ( D23 . D25 ) + ( D24 . D25 ) ) ) by BINOP_2:def 9
.= ( ( ( D22 . D25 ) * ( D23 . D25 ) ) + ( ( D22 . D25 ) * ( D24 . D25 ) ) )
.= ( ( ( D22 . D25 ) * ( D23 . D25 ) ) + ( ( multreal ) . (( D22 . D25 ) , ( D24 . D25 )) ) ) by BINOP_2:def 11
.= ( ( ( multreal ) . (( D22 . D25 ) , ( D23 . D25 )) ) + ( ( multreal ) . (( D22 . D25 ) , ( D24 . D25 )) ) ) by BINOP_2:def 11
.= ( ( addreal ) . (( ( multreal ) . (( C93 . C96 ) , ( C94 . C96 )) ) , ( ( multreal ) . (( C93 . C96 ) , ( C95 . C96 )) )) ) by BINOP_2:def 9
.= ( ( addreal ) . (( ( multreal ) . (( C93 . C96 ) , ( C94 . C96 )) ) , ( ( ( multreal ) .: (D22 , C95) ) . C96 )) ) by FUNCOP_1:37
.= ( ( addreal ) . (( ( ( multreal ) .: (D22 , C94) ) . C96 ) , ( ( ( multreal ) .: (D22 , C95) ) . C96 )) ) by FUNCOP_1:37
.= ( ( ( addreal ) .: (( ( multreal ) .: (C93 , C94) ) , ( ( multreal ) .: (C93 , C95) )) ) . C96 ) by FUNCOP_1:37;
end;
end;
thus L164: ( ( RealFuncMult C92 ) . (C93 , ( ( RealFuncAdd C92 ) . (C94 , C95) )) ) = ( ( RealFuncMult C92 ) . (C93 , ( ( addreal ) .: (C94 , C95) )) ) by L13
.= ( ( multreal ) .: (C93 , ( ( addreal ) .: (C94 , C95) )) ) by L22
.= ( ( addreal ) .: (( ( multreal ) .: (C93 , C94) ) , ( ( multreal ) .: (C93 , C95) )) ) by L157
.= ( ( RealFuncAdd C92 ) . (( ( multreal ) .: (C93 , C94) ) , ( ( multreal ) .: (C93 , C95) )) ) by L13
.= ( ( RealFuncAdd C92 ) . (( ( RealFuncMult C92 ) . (C93 , C94) ) , ( ( multreal ) .: (C93 , C95) )) ) by L22
.= ( ( RealFuncAdd C92 ) . (( ( RealFuncMult C92 ) . (C93 , C94) ) , ( ( RealFuncMult C92 ) . (C93 , C95) )) ) by L22;
end;
theorem
L165: (for B68 being set holds (for B69 , B70 , B71 being (Element of ( Funcs (B68 , ( REAL )) )) holds (for B72 being Real holds ( ( RealFuncMult B68 ) . (( ( RealFuncExtMult B68 ) . (B72 , B69) ) , B70) ) = ( ( RealFuncExtMult B68 ) . (B72 , ( ( RealFuncMult B68 ) . (B69 , B70) )) ))))
proof
let C97 being set;
let C98 , C99 , C100 being (Element of ( Funcs (C97 , ( REAL )) ));
let C101 being Real;
thus L166: ( ( RealFuncMult C97 ) . (( ( RealFuncExtMult C97 ) . (C101 , C98) ) , C99) ) = ( ( RealFuncMult C97 ) . (( ( multreal ) [;] (C101 , C98) ) , C99) ) by L31
.= ( ( multreal ) .: (( ( multreal ) [;] (C101 , C98) ) , C99) ) by L22
.= ( ( multreal ) [;] (C101 , ( ( multreal ) .: (C98 , C99) )) ) by FUNCOP_1:85
.= ( ( RealFuncExtMult C97 ) . (C101 , ( ( multreal ) .: (C98 , C99) )) ) by L31
.= ( ( RealFuncExtMult C97 ) . (C101 , ( ( RealFuncMult C97 ) . (C98 , C99) )) ) by L22;
end;
theorem
L167: (for R1 being set holds (for R4 being non  empty set holds (ex R6 being (Element of ( Funcs (R4 , ( REAL )) )) st (ex R7 being (Element of ( Funcs (R4 , ( REAL )) )) st ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1)))))))))
proof
let R1 being set;
let R4 being non  empty set;
deffunc H4(set) = 1;
deffunc H5(set) = ( 0 );
defpred S1[ set ] means $1 = R1;
L168: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies H4(R3) in ( REAL )) & ((not S1[ R3 ]) implies H5(R3) in ( REAL )))));
consider C102 being (Function of R4 , ( REAL )) such that L169: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies ( C102 . R3 ) = H4(R3)) & ((not S1[ R3 ]) implies ( C102 . R3 ) = H5(R3))))) from FUNCT_2:sch 5(L168);
L170: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies H5(R3) in ( REAL )) & ((not S1[ R3 ]) implies H4(R3) in ( REAL )))));
consider C103 being (Function of R4 , ( REAL )) such that L171: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies ( C103 . R3 ) = H5(R3)) & ((not S1[ R3 ]) implies ( C103 . R3 ) = H4(R3))))) from FUNCT_2:sch 5(L170);
reconsider D26 = C102 , D27 = C103 as (Element of ( Funcs (R4 , ( REAL )) )) by FUNCT_2:8;
take D26;
take D27;
thus L172: thesis by L169 , L171;
end;
theorem
L173: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R7 being (Element of ( Funcs (R4 , ( REAL )) )) holds ((R1 in R4 & R2 in R4 & R1 <> R2 & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1))))) implies (for R9 being Real holds (for R10 being Real holds (( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( RealFuncZero R4 ) implies (R9 = ( 0 ) & R10 = ( 0 )))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( REAL )) ));
let R7 being (Element of ( Funcs (R4 , ( REAL )) ));
assume that
L174: R1 in R4
and
L175: R2 in R4
and
L176: R1 <> R2
and
L177: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1)))));
L178: (( R6 . R2 ) = ( 0 ) & ( R7 . R2 ) = 1) by L175 , L176 , L177;
L179: (( R6 . R1 ) = 1 & ( R7 . R1 ) = ( 0 )) by L174 , L177;
let R9 being Real;
let R10 being Real;
reconsider D28 = R1 , D29 = R2 as (Element of R4) by L174 , L175;
assume L180: ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( RealFuncZero R4 );
L181: ( 0 ) = ( ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) . D29 ) by L180 , FUNCOP_1:7
.= ( ( ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) . D29 ) + ( ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] ) . D29 ) ) by L49
.= ( ( R9 * ( R6 . D29 ) ) + ( ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] ) . D29 ) ) by L76
.= ( ( 0 ) + ( R10 * 1 ) ) by L178 , L76
.= R10;
L182: ( 0 ) = ( ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) . D28 ) by L180 , FUNCOP_1:7
.= ( ( ( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) . D28 ) + ( ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] ) . D28 ) ) by L49
.= ( ( R9 * ( R6 . D28 ) ) + ( ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] ) . D28 ) ) by L76
.= ( R9 + ( R10 * ( 0 ) ) ) by L179 , L76
.= R9;
thus L183: thesis by L182 , L181;
end;
theorem
L184: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds ((R1 in R4 & R2 in R4 & R1 <> R2) implies (ex R6 being (Element of ( Funcs (R4 , ( REAL )) )) st (ex R7 being (Element of ( Funcs (R4 , ( REAL )) )) st (for R9 being Real holds (for R10 being Real holds (( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( RealFuncZero R4 ) implies (R9 = ( 0 ) & R10 = ( 0 )))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
assume L185: (R1 in R4 & R2 in R4 & R1 <> R2);
consider R6 being (Element of ( Funcs (R4 , ( REAL )) )), R7 being (Element of ( Funcs (R4 , ( REAL )) )) such that L186: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1))))) by L167;
take R6;
take R7;
let R9 being Real;
let R10 being Real;
assume L187: ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( RealFuncZero R4 );
thus L188: thesis by L187 , L185 , L186 , L173;
end;
theorem
L189: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( REAL )) )) holds (for R7 being (Element of ( Funcs (R4 , ( REAL )) )) holds ((R4 = { R1 , R2 } & R1 <> R2 & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1))))) implies (for R8 being (Element of ( Funcs (R4 , ( REAL )) )) holds (ex R9 being Real st (ex R10 being Real st R8 = ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( REAL )) ));
let R7 being (Element of ( Funcs (R4 , ( REAL )) ));
assume that
L190: R4 = { R1 , R2 }
and
L191: R1 <> R2
and
L192: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1)))));
L193: R2 in R4 by L190 , TARSKI:def 2;
L194: (( R6 . R2 ) = ( 0 ) & ( R7 . R2 ) = 1) by L193 , L191 , L192;
L195: R1 in R4 by L190 , TARSKI:def 2;
L196: (( R6 . R1 ) = 1 & ( R7 . R1 ) = ( 0 )) by L195 , L192;
let R8 being (Element of ( Funcs (R4 , ( REAL )) ));
reconsider D30 = R1 , D31 = R2 as (Element of R4) by L190 , TARSKI:def 2;
take D32 = ( R8 . D30 );
take D33 = ( R8 . D31 );
L197:
now
let C104 being (Element of R4);
L198: (C104 = D30 or C104 = D31) by L190 , TARSKI:def 2;
L199: ( ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ D32 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] )) ) . D31 ) = ( ( ( ( RealFuncExtMult R4 ) . [ D32 , R6 ] ) . D31 ) + ( ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] ) . D31 ) ) by L49
.= ( ( D32 * ( R6 . D31 ) ) + ( ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] ) . D31 ) ) by L76
.= ( ( 0 ) + ( D33 * 1 ) ) by L194 , L76
.= ( R8 . D31 );
L200: ( ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ D32 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] )) ) . D30 ) = ( ( ( ( RealFuncExtMult R4 ) . [ D32 , R6 ] ) . D30 ) + ( ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] ) . D30 ) ) by L49
.= ( ( D32 * ( R6 . D30 ) ) + ( ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] ) . D30 ) ) by L76
.= ( D32 + ( D33 * ( 0 ) ) ) by L196 , L76
.= ( R8 . D30 );
thus L201: ( R8 . C104 ) = ( ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ D32 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ D33 , R7 ] )) ) . C104 ) by L200 , L198 , L199;
end;
thus L202: thesis by L197 , FUNCT_2:63;
end;
theorem
L203: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds ((R4 = { R1 , R2 } & R1 <> R2) implies (ex R6 being (Element of ( Funcs (R4 , ( REAL )) )) st (ex R7 being (Element of ( Funcs (R4 , ( REAL )) )) st (for R8 being (Element of ( Funcs (R4 , ( REAL )) )) holds (ex R9 being Real st (ex R10 being Real st R8 = ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
assume L204: (R4 = { R1 , R2 } & R1 <> R2);
consider R6 being (Element of ( Funcs (R4 , ( REAL )) )), R7 being (Element of ( Funcs (R4 , ( REAL )) )) such that L205: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1))))) by L167;
take R6;
take R7;
let R8 being (Element of ( Funcs (R4 , ( REAL )) ));
thus L206: thesis by L204 , L205 , L189;
end;
theorem
L207: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds ((R4 = { R1 , R2 } & R1 <> R2) implies (ex R6 being (Element of ( Funcs (R4 , ( REAL )) )) st (ex R7 being (Element of ( Funcs (R4 , ( REAL )) )) st ((for R9 being Real holds (for R10 being Real holds (( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( RealFuncZero R4 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) & (for R8 being (Element of ( Funcs (R4 , ( REAL )) )) holds (ex R9 being Real st (ex R10 being Real st R8 = ( ( RealFuncAdd R4 ) . (( ( RealFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( RealFuncExtMult R4 ) . [ R10 , R7 ] )) )))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
assume that
L208: R4 = { R1 , R2 }
and
L209: R1 <> R2;
consider R6 being (Element of ( Funcs (R4 , ( REAL )) )), R7 being (Element of ( Funcs (R4 , ( REAL )) )) such that L210: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = 1) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = 1))))) by L167;
take R6;
take R7;
L211: (R1 in R4 & R2 in R4) by L208 , TARSKI:def 2;
thus L212: thesis by L211 , L208 , L209 , L210 , L173 , L189;
end;
definition
let C105 being set;
func RealVectSpace C105 ->  strict RealLinearSpace equals 
RLSStruct (# ( Funcs (C105 , ( REAL )) ) , ( RealFuncZero C105 ) , ( RealFuncAdd C105 ) , ( RealFuncExtMult C105 ) #);
coherence
proof
set D34 = RLSStruct (# ( Funcs (C105 , ( REAL )) ) , ( RealFuncZero C105 ) , ( RealFuncAdd C105 ) , ( RealFuncExtMult C105 ) #);
L213: D34 is  add-associative
proof
let C106 , C107 , C108 being (Element of D34);
thus L214: thesis by L90;
end;
L215: D34 is  right_complementable
proof
let C109 being (Element of D34);
reconsider D35 = C109 as (Element of ( Funcs (C105 , ( REAL )) ));
reconsider D36 = ( ( RealFuncExtMult C105 ) . [ ( - 1 ) , D35 ] ) as (VECTOR of D34);
take D36;
thus L216: thesis by L114;
end;
L217: D34 is  vector-distributive  scalar-distributive  scalar-associative  scalar-unital
proof
thus L218: (for B73 being  real number holds (for B74 , B75 being (Element of D34) holds ( B73 * ( B74 + B75 ) ) = ( ( B73 * B74 ) + ( B73 * B75 ) )))
proof
let C110 being  real number;
reconsider D37 = C110 as Real by XREAL_0:def 1;
L219: (for B76 , B77 being (Element of D34) holds ( D37 * ( B76 + B77 ) ) = ( ( D37 * B76 ) + ( D37 * B77 ) )) by L148;
thus L220: thesis by L219;
end;

thus L221: (for B78 , B79 being  real number holds (for B80 being (Element of D34) holds ( ( B78 + B79 ) * B80 ) = ( ( B78 * B80 ) + ( B79 * B80 ) )))
proof
let C111 , C112 being  real number;
reconsider D38 = C111 , D39 = C112 as Real by XREAL_0:def 1;
L222: (for B81 being (Element of D34) holds ( ( D38 + D39 ) * B81 ) = ( ( D38 * B81 ) + ( D39 * B81 ) )) by L140;
thus L223: thesis by L222;
end;

thus L224: (for B82 , B83 being  real number holds (for B84 being (Element of D34) holds ( ( B82 * B83 ) * B84 ) = ( B82 * ( B83 * B84 ) )))
proof
let C113 , C114 being  real number;
reconsider D40 = C113 , D41 = C114 as Real by XREAL_0:def 1;
L225: (for B85 being (Element of D34) holds ( ( D40 * D41 ) * B85 ) = ( D40 * ( D41 * B85 ) )) by L131;
thus L226: thesis by L225;
end;

let C115 being (Element of D34);
thus L227: ( 1 * C115 ) = C115 by L122;
end;
L228: D34 is  right_zeroed
proof
let C116 being (Element of D34);
reconsider D42 = C116 as (Element of ( Funcs (C105 , ( REAL )) ));
thus L229: ( C116 + ( 0. D34 ) ) = ( ( RealFuncAdd C105 ) . (( RealFuncZero C105 ) , D42) ) by L88
.= C116 by L105;
end;
L230: D34 is  Abelian
proof
let C117 , C118 being (Element of D34);
thus L231: thesis by L88;
end;
thus L232: thesis by L230 , L213 , L228 , L215 , L217;
end;
end;
theorem
L234: (ex B86 being  strict RealLinearSpace st (ex B87 , B88 being (Element of B86) st ((for R9 being Real holds (for R10 being Real holds (( ( R9 * B87 ) + ( R10 * B88 ) ) = ( 0. B86 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) & (for B89 being (Element of B86) holds (ex R9 being Real st (ex R10 being Real st B89 = ( ( R9 * B87 ) + ( R10 * B88 ) )))))))
proof
set D43 = { ( 0 ) , 1 };
take D44 = ( RealVectSpace D43 );
consider C119 , C120 being (Element of ( Funcs (D43 , ( REAL )) )) such that L235: (for R9 being Real holds (for R10 being Real holds (( ( RealFuncAdd D43 ) . (( ( RealFuncExtMult D43 ) . [ R9 , C119 ] ) , ( ( RealFuncExtMult D43 ) . [ R10 , C120 ] )) ) = ( RealFuncZero D43 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) and L236: (for B90 being (Element of ( Funcs (D43 , ( REAL )) )) holds (ex R9 being Real st (ex R10 being Real st B90 = ( ( RealFuncAdd D43 ) . (( ( RealFuncExtMult D43 ) . [ R9 , C119 ] ) , ( ( RealFuncExtMult D43 ) . [ R10 , C120 ] )) )))) by L207;
reconsider D45 = C119 , D46 = C120 as (Element of D44);
take D45;
take D46;
thus L237: (for R9 being Real holds (for R10 being Real holds (( ( R9 * D45 ) + ( R10 * D46 ) ) = ( 0. D44 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) by L235;
thus L238: (for B91 being (Element of D44) holds (ex R9 being Real st (ex R10 being Real st B91 = ( ( R9 * D45 ) + ( R10 * D46 ) ))))
proof
let C121 being (Element of D44);
reconsider D47 = C121 as (Element of ( Funcs (D43 , ( REAL )) ));
consider R9 being Real, R10 being Real such that L239: D47 = ( ( RealFuncAdd D43 ) . (( ( RealFuncExtMult D43 ) . [ R9 , C119 ] ) , ( ( RealFuncExtMult D43 ) . [ R10 , C120 ] )) ) by L236;
L240: D47 = ( ( R9 * D45 ) + ( R10 * D46 ) ) by L239;
thus L241: thesis by L240;
end;

end;
definition
let R4 being non  empty set;
func RRing R4 ->  strict doubleLoopStr equals 
doubleLoopStr (# ( Funcs (R4 , ( REAL )) ) , ( RealFuncAdd R4 ) , ( RealFuncMult R4 ) , ( RealFuncUnit R4 ) , ( RealFuncZero R4 ) #);
correctness;
end;
registration
let R4 being non  empty set;
cluster ( RRing R4 ) -> non  empty;
coherence;
end;
L241:
now
let R4 being non  empty set;
set D48 = ( RRing R4 );
let C122 , C123 being (Element of D48);
reconsider D49 = C122 as (Element of ( Funcs (R4 , ( REAL )) ));
assume L242: C123 = ( RealFuncUnit R4 );
thus L243: ( C122 * C123 ) = ( ( RealFuncMult R4 ) . (( RealFuncUnit R4 ) , D49) ) by L242 , L92
.= C122 by L96;
thus L244: ( C123 * C122 ) = C122 by L242 , L96;
end;
registration
let R4 being non  empty set;
cluster ( RRing R4 ) ->  unital;
coherence
proof
reconsider D50 = ( RealFuncUnit R4 ) as (Element of ( RRing R4 ));
take D50;
thus L245: thesis by L241;
end;
end;
theorem
L247: (for R4 being non  empty set holds ( 1. ( RRing R4 ) ) = ( RealFuncUnit R4 ));
theorem
L248: (for R4 being non  empty set holds (for B92 , B93 , B94 being (Element of ( RRing R4 )) holds (( B92 + B93 ) = ( B93 + B92 ) & ( ( B92 + B93 ) + B94 ) = ( B92 + ( B93 + B94 ) ) & ( B92 + ( 0. ( RRing R4 ) ) ) = B92 & (ex B95 being (Element of ( RRing R4 )) st ( B92 + B95 ) = ( 0. ( RRing R4 ) )) & ( B92 * B93 ) = ( B93 * B92 ) & ( ( B92 * B93 ) * B94 ) = ( B92 * ( B93 * B94 ) ) & ( B92 * ( 1. ( RRing R4 ) ) ) = B92 & ( ( 1. ( RRing R4 ) ) * B92 ) = B92 & ( B92 * ( B93 + B94 ) ) = ( ( B92 * B93 ) + ( B92 * B94 ) ) & ( ( B93 + B94 ) * B92 ) = ( ( B93 * B92 ) + ( B94 * B92 ) ))))
proof
let R4 being non  empty set;
let C124 , C125 , C126 being (Element of ( RRing R4 ));
set D51 = ( RRing R4 );
reconsider D52 = C124 as (Element of ( Funcs (R4 , ( REAL )) ));
thus L249: ( C124 + C125 ) = ( C125 + C124 ) by L88;
thus L250: ( ( C124 + C125 ) + C126 ) = ( C124 + ( C125 + C126 ) ) by L90;
thus L251: ( C124 + ( 0. ( RRing R4 ) ) ) = ( ( RealFuncAdd R4 ) . (( RealFuncZero R4 ) , D52) ) by L88
.= C124 by L105;
thus L252: (ex B96 being (Element of ( RRing R4 )) st ( C124 + B96 ) = ( 0. ( RRing R4 ) ))
proof
set D53 = ( ( RealFuncExtMult R4 ) . [ ( - 1 ) , D52 ] );
reconsider D54 = D53 as (Element of D51);
take D54;
thus L253: thesis by L114;
end;

thus L254: ( C124 * C125 ) = ( C125 * C124 ) by L92;
thus L255: ( ( C124 * C125 ) * C126 ) = ( C124 * ( C125 * C126 ) ) by L94;
thus L256: ( C124 * ( 1. ( RRing R4 ) ) ) = ( ( RealFuncMult R4 ) . (( RealFuncUnit R4 ) , D52) ) by L92
.= C124 by L96;
thus L257: ( ( 1. ( RRing R4 ) ) * C124 ) = C124 by L256 , L92;
thus L258: ( C124 * ( C125 + C126 ) ) = ( ( C124 * C125 ) + ( C124 * C126 ) ) by L156;
thus L259: ( ( C125 + C126 ) * C124 ) = ( ( C124 * C125 ) + ( C124 * C126 ) ) by L258 , L92
.= ( ( C125 * C124 ) + ( C124 * C126 ) ) by L92
.= ( ( C125 * C124 ) + ( C126 * C124 ) ) by L92;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  associative  commutative  right_unital  right-distributive for 1 -element 1 -element 1 -element 1 -element doubleLoopStr;
existence
proof
take D55 = ( Trivial-doubleLoopStr );
thus L260: D55 is  strict;
thus L261: D55 is  Abelian
proof
let C127 being (Element of D55);
thus L262: thesis by STRUCT_0:def 10;
end;

thus L263: D55 is  add-associative
proof
let C128 being (Element of D55);
thus L264: thesis by STRUCT_0:def 10;
end;

thus L265: D55 is  right_zeroed
proof
let C129 being (Element of D55);
thus L266: thesis by STRUCT_0:def 10;
end;

thus L267: D55 is  right_complementable
proof
let C130 being (Element of D55);
take C130;
thus L268: thesis by STRUCT_0:def 10;
end;

thus L269: D55 is  associative
proof
let C131 being (Element of D55);
thus L270: thesis by STRUCT_0:def 10;
end;

thus L271: D55 is  commutative
proof
let C132 being (Element of D55);
thus L272: thesis by STRUCT_0:def 10;
end;

thus L273: D55 is  right_unital
proof
let C133 being (Element of D55);
thus L274: thesis by STRUCT_0:def 10;
end;

let C134 being (Element of D55);
thus L275: thesis by STRUCT_0:def 10;
end;
end;
definition
mode Ring
 is  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
end;
theorem
L278: (for R4 being non  empty set holds ( RRing R4 ) is  commutative  commutative  commutative  commutative Ring)
proof
let R4 being non  empty set;
L279: ( RRing R4 ) is  Abelian
proof
let C135 being (Element of ( RRing R4 ));
thus L280: thesis by L248;
end;
L281: ( RRing R4 ) is  add-associative
proof
let C136 being (Element of ( RRing R4 ));
thus L282: thesis by L248;
end;
L283: ( RRing R4 ) is  right_complementable
proof
let C137 being (Element of ( RRing R4 ));
consider C138 being (Element of ( RRing R4 )) such that L284: ( C137 + C138 ) = ( 0. ( RRing R4 ) ) by L248;
take C138;
thus L285: thesis by L284;
end;
L286: ( RRing R4 ) is  right_zeroed
proof
let C139 being (Element of ( RRing R4 ));
thus L287: thesis by L248;
end;
L288: ( RRing R4 ) is  distributive
proof
let C140 being (Element of ( RRing R4 ));
thus L289: thesis by L248;
end;
L290: ( RRing R4 ) is  well-unital
proof
let C141 being (Element of ( RRing R4 ));
thus L291: thesis by L248;
end;
L292: ( RRing R4 ) is  associative
proof
let C142 being (Element of ( RRing R4 ));
thus L293: thesis by L248;
end;
L294: ( RRing R4 ) is  commutative
proof
let C143 being (Element of ( RRing R4 ));
thus L295: thesis by L248;
end;
thus L296: thesis by L294 , L279 , L281 , L286 , L283 , L292 , L290 , L288;
end;
definition
struct (doubleLoopStr , RLSStruct) AlgebraStr(# carrier -> set , multF , addF -> (BinOp of the carrier) , Mult -> (Function of [: ( REAL ) , the carrier :] , the carrier) , OneF , ZeroF -> (Element of the carrier) #);
end;
registration
cluster non  empty for AlgebraStr;
existence
proof
set D56 = the non  empty set;
set D57 = the (BinOp of D56);
set D58 = the (Function of [: ( REAL ) , D56 :] , D56);
set D59 = the (Element of D56);
take AlgebraStr (# D56 , D57 , D57 , D58 , D59 , D59 #);
thus L298: (the carrier of AlgebraStr (# D56 , D57 , D57 , D58 , D59 , D59 #)) is non  empty;
end;
end;
definition
let C144 being set;
func RAlgebra C144 ->  strict AlgebraStr equals 
AlgebraStr (# ( Funcs (C144 , ( REAL )) ) , ( RealFuncMult C144 ) , ( RealFuncAdd C144 ) , ( RealFuncExtMult C144 ) , ( RealFuncUnit C144 ) , ( RealFuncZero C144 ) #);
correctness;
end;
registration
let R4 being non  empty set;
cluster ( RAlgebra R4 ) -> non  empty;
coherence;
end;
L302:
now
let R4 being non  empty set;
set D60 = ( RAlgebra R4 );
let C145 , C146 being (Element of D60);
reconsider D61 = C145 as (Element of ( Funcs (R4 , ( REAL )) ));
assume L303: C146 = ( RealFuncUnit R4 );
thus L304: ( C145 * C146 ) = ( ( RealFuncMult R4 ) . (( RealFuncUnit R4 ) , D61) ) by L303 , L92
.= C145 by L96;
thus L305: ( C146 * C145 ) = C145 by L303 , L96;
end;
registration
let R4 being non  empty set;
cluster ( RAlgebra R4 ) ->  unital;
coherence
proof
reconsider D62 = ( RealFuncUnit R4 ) as (Element of ( RAlgebra R4 ));
take D62;
thus L306: thesis by L302;
end;
end;
theorem
L308: (for R4 being non  empty set holds ( 1. ( RAlgebra R4 ) ) = ( RealFuncUnit R4 ));
definition
let C147 being non  empty AlgebraStr;
attr C147 is  vector-associative
means
(for B97 , B98 being (Element of C147) holds (for R9 being Real holds ( R9 * ( B97 * B98 ) ) = ( ( R9 * B97 ) * B98 )));
end;
registration
let C148 being set;
cluster ( RAlgebra C148 ) -> non  empty;
coherence;
end;
registration
let C149 being set;
cluster ( RAlgebra C149 ) ->  strict  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  right_unital  right-distributive  vector-associative  scalar-associative  vector-distributive  scalar-distributive;
coherence
proof
thus L311: ( RAlgebra C149 ) is  strict;
thus L312: ( RAlgebra C149 ) is  Abelian
proof
let C150 , C151 being (Element of ( RAlgebra C149 ));
thus L313: ( C150 + C151 ) = ( C151 + C150 ) by L88;
end;

thus L314: ( RAlgebra C149 ) is  add-associative
proof
let C152 , C153 , C154 being (Element of ( RAlgebra C149 ));
thus L315: ( ( C152 + C153 ) + C154 ) = ( C152 + ( C153 + C154 ) ) by L90;
end;

thus L316: ( RAlgebra C149 ) is  right_zeroed
proof
let C155 being (Element of ( RAlgebra C149 ));
thus L317: ( C155 + ( 0. ( RAlgebra C149 ) ) ) = ( ( RealFuncAdd C149 ) . (( RealFuncZero C149 ) , C155) ) by L88
.= C155 by L105;
end;

thus L318: ( RAlgebra C149 ) is  right_complementable
proof
let C156 being (Element of ( RAlgebra C149 ));
reconsider D63 = C156 as (Element of ( Funcs (C149 , ( REAL )) ));
reconsider D64 = ( ( RealFuncExtMult C149 ) . [ ( - 1 ) , D63 ] ) as (Element of ( RAlgebra C149 ));
take D64;
thus L319: thesis by L114;
end;

thus L320: ( RAlgebra C149 ) is  commutative
proof
let C157 , C158 being (Element of ( RAlgebra C149 ));
thus L321: ( C157 * C158 ) = ( C158 * C157 ) by L92;
end;

thus L322: ( RAlgebra C149 ) is  associative
proof
let C159 , C160 , C161 being (Element of ( RAlgebra C149 ));
thus L323: ( ( C159 * C160 ) * C161 ) = ( C159 * ( C160 * C161 ) ) by L94;
end;

thus L324: ( RAlgebra C149 ) is  right_unital
proof
let C162 being (Element of ( RAlgebra C149 ));
thus L325: ( C162 * ( 1. ( RAlgebra C149 ) ) ) = ( ( RealFuncMult C149 ) . (( RealFuncUnit C149 ) , C162) ) by L92
.= C162 by L96;
end;

thus L326: ( RAlgebra C149 ) is  right-distributive
proof
let C163 , C164 , C165 being (Element of ( RAlgebra C149 ));
thus L327: ( C163 * ( C164 + C165 ) ) = ( ( C163 * C164 ) + ( C163 * C165 ) ) by L156;
end;

thus L328: ( RAlgebra C149 ) is  vector-associative
proof
let C166 , C167 being (Element of ( RAlgebra C149 ));
let R9 being Real;
thus L329: ( ( R9 * C166 ) * C167 ) = ( R9 * ( C166 * C167 ) ) by L165;
end;

thus L330: ( RAlgebra C149 ) is  scalar-associative
proof
let C168 , C169 being  real number;
let C170 being (Element of ( RAlgebra C149 ));
reconsider D65 = C168 , D66 = C169 as (Element of ( REAL )) by XREAL_0:def 1;
L331: ( ( D65 * D66 ) * C170 ) = ( D65 * ( D66 * C170 ) ) by L131;
thus L332: thesis by L331;
end;

thus L333: ( RAlgebra C149 ) is  vector-distributive
proof
let C171 being  real number;
let C172 , C173 being (Element of ( RAlgebra C149 ));
reconsider D67 = C171 as (Element of ( REAL )) by XREAL_0:def 1;
L334: ( D67 * ( C172 + C173 ) ) = ( ( D67 * C172 ) + ( D67 * C173 ) ) by L148;
thus L335: thesis by L334;
end;

let C174 , C175 being  real number;
let C176 being (Element of ( RAlgebra C149 ));
reconsider D68 = C174 , D69 = C175 as (Element of ( REAL )) by XREAL_0:def 1;
L336: ( ( D68 + D69 ) * C176 ) = ( ( D68 * C176 ) + ( D69 * C176 ) ) by L140;
thus L337: thesis by L336;
end;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  right_unital  right-distributive  vector-associative  scalar-associative  vector-distributive  scalar-distributive for non  empty non  empty non  empty non  empty AlgebraStr;
existence
proof
take ( RAlgebra ( {} ) );
thus L339: thesis;
end;
end;
definition
mode Algebra
 is  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  right_unital  right-distributive  vector-associative  scalar-associative  vector-distributive  scalar-distributive non  empty AlgebraStr;
end;
