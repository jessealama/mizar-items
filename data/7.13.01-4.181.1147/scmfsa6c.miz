:: On the compositions of macro instructions, Part III
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies AMI_1, SCMFSA_2, FSM_1, CARD_1, SCMFSA6B, TURING_1, FUNCT_1,
      RELAT_1, ARYTM_3, FUNCT_4, SCMFSA6A, TARSKI, XBOOLE_0, CIRCUIT2, NUMBERS,
      SUBSET_1, GRAPHSP, AMI_3, XXREAL_0, SF_MASTR, FUNCOP_1, FUNCT_7,
      STRUCT_0, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      MSUALG_1, AOFA_I00, ORDINAL1, EXTPRO_1, PBOOLE, SCMFSA6C, AMISTD_1,
      AMISTD_2, COMPOS_1, NAT_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ENUMSET1, CARD_1, NUMBERS, XCMPLX_0,
      ORDINAL1, NAT_1, INT_1, COMPLEX1, RELAT_1, FUNCT_1, PARTFUN1, FINSEQ_1,
      FINSEQ_2, FUNCOP_1, FUNCT_4, PBOOLE, STRUCT_0, MEMSTR_0, COMPOS_0,
      COMPOS_1, EXTPRO_1, AMISTD_1, AMISTD_2, FUNCT_7,
      SCMFSA_M,
      SCMFSA_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, XXREAL_0;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, INT_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, RELSET_1, PRE_POLY, AMISTD_1, AMISTD_2, PBOOLE, FUNCT_4,
      MEMSTR_0, SCMFSA_1, SCMFSA_M, FUNCT_7;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      ORDINAL1, RELSET_1, COMPOS_1, STRUCT_0, EXTPRO_1, SCMFSA10, PBOOLE,
      FUNCT_4, AMISTD_2, MEMSTR_0, AMISTD_1, FINSEQ_1, AMI_3, COMPOS_0,
      SCMFSA_M;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, SCMFSA6B, SCMFSA6A, PARTFUN1,
      MEMSTR_0, AMISTD_1, SCMFSA_2, SCMFSA_M;
 theorems RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, SCMFSA_3, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_2, ENUMSET1, GRFUNC_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, XBOOLE_0, XBOOLE_1, PARTFUN1, COMPOS_1, EXTPRO_1, AMISTD_2,
      PBOOLE, STRUCT_0, MEMSTR_0, AMISTD_1, AMI_2, SCMFSA_M;

begin
set D1 = ( Start-At (( 0 ) , ( SCM+FSA )) );
theorem
L1: (for R3 being Int-Location holds (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B1 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B2 being  parahalting (Program of ( SCM+FSA )) holds ( ( IExec (( B1 ";" B2 ) , R11 , R8) ) . R3 ) = ( ( IExec (B2 , R11 , ( IExec (B1 , R11 , R8) )) ) . R3 ))))))
proof
let R3 being Int-Location;
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C1 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C2 being  parahalting (Program of ( SCM+FSA ));
L2: (not R3 in ( dom ( Start-At (( ( IC ( IExec (C2 , R11 , ( IExec (C1 , R11 , R8) )) ) ) + ( card C1 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:102;
L3: ( IExec (( C1 ";" C2 ) , R11 , R8) ) = ( IncIC (( IExec (C2 , R11 , ( IExec (C1 , R11 , R8) )) ) , ( card C1 )) ) by SCMFSA6B:20;
thus L4: thesis by L3 , L2 , FUNCT_4:11;
end;
theorem
L5: (for R5 being FinSeq-Location holds (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B3 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B4 being  parahalting (Program of ( SCM+FSA )) holds ( ( IExec (( B3 ";" B4 ) , R11 , R8) ) . R5 ) = ( ( IExec (B4 , R11 , ( IExec (B3 , R11 , R8) )) ) . R5 ))))))
proof
let R5 being FinSeq-Location;
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C3 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C4 being  parahalting (Program of ( SCM+FSA ));
L6: (not R5 in ( dom ( Start-At (( ( IC ( IExec (C4 , R11 , ( IExec (C3 , R11 , R8) )) ) ) + ( card C3 ) ) , ( SCM+FSA )) ) )) by SCMFSA_2:103;
L7: ( IExec (( C3 ";" C4 ) , R11 , R8) ) = ( IncIC (( IExec (C4 , R11 , ( IExec (C3 , R11 , R8) )) ) , ( card C3 )) ) by SCMFSA6B:20;
thus L8: thesis by L7 , L6 , FUNCT_4:11;
end;
begin
definition
let C5 being (Instruction of ( SCM+FSA ));
attr C5 is  parahalting
means
:L9: ( Macro C5 ) is  parahalting;
attr C5 is  keeping_0
means
:L10: ( Macro C5 ) is  keeping_0;
end;
L12: ( Macro ( halt ( SCM+FSA ) ) ) is  parahalting
proof
let C6 being ( 0 ) -started (State of ( SCM+FSA ));
set D2 = ( Macro ( halt ( SCM+FSA ) ) );
set D3 = D2;
L13: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C6 by MEMSTR_0:29;
let C7 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L14: D2 c= C7;
L15: ( IC ( SCM+FSA ) ) in ( dom ( Start-At (( 0 ) , ( SCM+FSA )) ) ) by MEMSTR_0:15;
take ( 0 );
L16: ( dom C7 ) = ( NAT ) by PARTFUN1:def 2;
thus L17: ( IC ( Comput (C7 , C6 , ( 0 )) ) ) in ( dom C7 ) by L16;
L18: ( dom D2 ) = { ( 0 ) , 1 } by COMPOS_1:61;
L19: ( 0 ) in ( dom D2 ) by L18 , TARSKI:def 2;
L20: ( CurInstr (C7 , ( Comput (C7 , C6 , ( 0 )) )) ) = ( CurInstr (C7 , C6) )
.= ( C7 . ( IC C6 ) ) by L16 , PARTFUN1:def 6
.= ( C7 . ( IC ( Start-At (( 0 ) , ( SCM+FSA )) ) ) ) by L13 , L15 , GRFUNC_1:2
.= ( C7 . ( 0 ) ) by FUNCOP_1:72
.= ( D2 . ( 0 ) ) by L14 , L19 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:58;
thus L21: thesis by L20;
end;
L22: ( Macro ( halt ( SCM+FSA ) ) ) is  keeping_0
proof
set D4 = ( Macro ( halt ( SCM+FSA ) ) );
let C8 being ( 0 ) -started (State of ( SCM+FSA ));
L23: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C8 by MEMSTR_0:29;
let C9 being (Instruction-Sequence of ( SCM+FSA ));
assume L24: D4 c= C9;
let C10 being (Element of ( NAT ));
L25: ( C9 /. ( IC C8 ) ) = ( C9 . ( IC C8 ) ) by PBOOLE:143;
L26: ( 0 ) in ( dom D4 ) by COMPOS_1:60;
L27: ( CurInstr (C9 , ( Comput (C9 , C8 , ( 0 )) )) ) = ( C9 . ( 0 ) ) by L23 , L25 , MEMSTR_0:39
.= ( D4 . ( 0 ) ) by L24 , L26 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:58;
thus L28: ( ( Comput (C9 , C8 , C10) ) . ( intloc ( 0 ) ) ) = ( C8 . ( intloc ( 0 ) ) ) by L27 , EXTPRO_1:5 , NAT_1:2;
end;
registration
cluster ( halt ( SCM+FSA ) ) ->  keeping_0  parahalting;
coherence
proof
thus L29: ( Macro ( halt ( SCM+FSA ) ) ) is  keeping_0  parahalting by L12 , L22;
end;
end;
registration
cluster  keeping_0  parahalting for (Instruction of ( SCM+FSA ));
existence
proof
take ( halt ( SCM+FSA ) );
thus L31: thesis;
end;
end;
registration
let C11 being  parahalting (Instruction of ( SCM+FSA ));
cluster ( Macro C11 ) ->  parahalting;
coherence by L9;
end;
registration
let C12 being  keeping_0 (Instruction of ( SCM+FSA ));
cluster ( Macro C12 ) ->  keeping_0;
coherence by L10;
end;
registration
let C13 , C14 being Int-Location;
cluster ( C13 := C14 ) ->  parahalting;
coherence
proof
set D5 = ( Macro ( C13 := C14 ) );
let C15 being ( 0 ) -started (State of ( SCM+FSA ));
L35: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C15 by MEMSTR_0:29;
let C16 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L36: D5 c= C16;
take 1;
L37: ( dom C16 ) = ( NAT ) by PARTFUN1:def 2;
thus L38: ( IC ( Comput (C16 , C15 , 1) ) ) in ( dom C16 ) by L37;
L39: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L40: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L39 , TARSKI:def 1;
L41: ( IC C15 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L40 , L35 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L42: ( IC ( Exec (( C13 := C14 ) , C15) ) ) = ( succ ( 0 ) ) by L41 , SCMFSA_2:63
.= ( ( 0 ) + 1 );
L43: 1 in ( dom D5 ) by COMPOS_1:60;
L44: ( 0 ) in ( dom D5 ) by COMPOS_1:60;
L45: ( C16 . ( 0 ) ) = ( D5 . ( 0 ) ) by L36 , L44 , GRFUNC_1:2
.= ( C13 := C14 ) by COMPOS_1:58;
L46: ( C16 . 1 ) = ( D5 . 1 ) by L36 , L43 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L47: ( Comput (C16 , C15 , ( ( 0 ) + 1 )) ) = ( Following (C16 , ( Comput (C16 , C15 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C16 , C15) )
.= ( Exec (( C13 := C14 ) , C15) ) by L41 , L37 , L45 , PARTFUN1:def 6;
thus L48: thesis by L47 , L42 , L37 , L46 , PARTFUN1:def 6;
end;
cluster ( AddTo (C13 , C14) ) ->  parahalting;
coherence
proof
set D6 = ( Macro ( AddTo (C13 , C14) ) );
let C17 being ( 0 ) -started (State of ( SCM+FSA ));
L49: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C17 by MEMSTR_0:29;
let C18 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L50: D6 c= C18;
take 1;
L51: ( dom C18 ) = ( NAT ) by PARTFUN1:def 2;
thus L52: ( IC ( Comput (C18 , C17 , 1) ) ) in ( dom C18 ) by L51;
L53: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L54: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L53 , TARSKI:def 1;
L55: ( IC C17 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L54 , L49 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L56: ( IC ( Exec (( AddTo (C13 , C14) ) , C17) ) ) = ( succ ( 0 ) ) by L55 , SCMFSA_2:64
.= ( ( 0 ) + 1 );
L57: 1 in ( dom D6 ) by COMPOS_1:60;
L58: ( 0 ) in ( dom D6 ) by COMPOS_1:60;
L59: ( C18 . ( 0 ) ) = ( D6 . ( 0 ) ) by L50 , L58 , GRFUNC_1:2
.= ( AddTo (C13 , C14) ) by COMPOS_1:58;
L60: ( C18 . 1 ) = ( D6 . 1 ) by L50 , L57 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L61: ( Comput (C18 , C17 , ( ( 0 ) + 1 )) ) = ( Following (C18 , ( Comput (C18 , C17 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C18 , C17) )
.= ( Exec (( AddTo (C13 , C14) ) , C17) ) by L55 , L51 , L59 , PARTFUN1:def 6;
thus L62: thesis by L61 , L56 , L51 , L60 , PARTFUN1:def 6;
end;
cluster ( SubFrom (C13 , C14) ) ->  parahalting;
coherence
proof
set D7 = ( Macro ( SubFrom (C13 , C14) ) );
let C19 being ( 0 ) -started (State of ( SCM+FSA ));
L63: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C19 by MEMSTR_0:29;
let C20 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L64: D7 c= C20;
take 1;
L65: ( dom C20 ) = ( NAT ) by PARTFUN1:def 2;
thus L66: ( IC ( Comput (C20 , C19 , 1) ) ) in ( dom C20 ) by L65;
L67: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L68: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L67 , TARSKI:def 1;
L69: ( IC C19 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L68 , L63 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L70: ( IC ( Exec (( SubFrom (C13 , C14) ) , C19) ) ) = ( succ ( 0 ) ) by L69 , SCMFSA_2:65
.= ( ( 0 ) + 1 );
L71: 1 in ( dom D7 ) by COMPOS_1:60;
L72: ( 0 ) in ( dom D7 ) by COMPOS_1:60;
L73: ( C20 . ( 0 ) ) = ( D7 . ( 0 ) ) by L64 , L72 , GRFUNC_1:2
.= ( SubFrom (C13 , C14) ) by COMPOS_1:58;
L74: ( C20 . 1 ) = ( D7 . 1 ) by L64 , L71 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L75: ( Comput (C20 , C19 , ( ( 0 ) + 1 )) ) = ( Following (C20 , ( Comput (C20 , C19 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C20 , C19) )
.= ( Exec (( SubFrom (C13 , C14) ) , C19) ) by L69 , L65 , L73 , PARTFUN1:def 6;
thus L76: thesis by L75 , L70 , L65 , L74 , PARTFUN1:def 6;
end;
cluster ( MultBy (C13 , C14) ) ->  parahalting;
coherence
proof
set D8 = ( Macro ( MultBy (C13 , C14) ) );
let C21 being ( 0 ) -started (State of ( SCM+FSA ));
L77: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C21 by MEMSTR_0:29;
let C22 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L78: ( Macro ( MultBy (C13 , C14) ) ) c= C22;
take 1;
L79: ( dom C22 ) = ( NAT ) by PARTFUN1:def 2;
thus L80: ( IC ( Comput (C22 , C21 , 1) ) ) in ( dom C22 ) by L79;
L81: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L82: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L81 , TARSKI:def 1;
L83: ( IC C21 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L82 , L77 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L84: ( IC ( Exec (( MultBy (C13 , C14) ) , C21) ) ) = ( succ ( 0 ) ) by L83 , SCMFSA_2:66
.= ( ( 0 ) + 1 );
L85: 1 in ( dom D8 ) by COMPOS_1:60;
L86: ( 0 ) in ( dom D8 ) by COMPOS_1:60;
L87: ( C22 . ( 0 ) ) = ( D8 . ( 0 ) ) by L78 , L86 , GRFUNC_1:2
.= ( MultBy (C13 , C14) ) by COMPOS_1:58;
L88: ( C22 . 1 ) = ( D8 . 1 ) by L78 , L85 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L89: ( Comput (C22 , C21 , ( ( 0 ) + 1 )) ) = ( Following (C22 , ( Comput (C22 , C21 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C22 , C21) )
.= ( Exec (( MultBy (C13 , C14) ) , C21) ) by L83 , L79 , L87 , PARTFUN1:def 6;
thus L90: thesis by L89 , L84 , L79 , L88 , PARTFUN1:def 6;
end;
cluster ( Divide (C13 , C14) ) ->  parahalting;
coherence
proof
set D9 = ( Macro ( Divide (C13 , C14) ) );
let C23 being ( 0 ) -started (State of ( SCM+FSA ));
L91: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C23 by MEMSTR_0:29;
let C24 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L92: ( Macro ( Divide (C13 , C14) ) ) c= C24;
take 1;
L93: ( dom C24 ) = ( NAT ) by PARTFUN1:def 2;
thus L94: ( IC ( Comput (C24 , C23 , 1) ) ) in ( dom C24 ) by L93;
L95: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L96: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L95 , TARSKI:def 1;
L97: ( IC C23 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L96 , L91 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L98: ( IC ( Exec (( Divide (C13 , C14) ) , C23) ) ) = ( succ ( 0 ) ) by L97 , SCMFSA_2:67
.= ( ( 0 ) + 1 );
L99: 1 in ( dom D9 ) by COMPOS_1:60;
L100: ( 0 ) in ( dom D9 ) by COMPOS_1:60;
L101: ( C24 . ( 0 ) ) = ( D9 . ( 0 ) ) by L92 , L100 , GRFUNC_1:2
.= ( Divide (C13 , C14) ) by COMPOS_1:58;
L102: ( C24 . 1 ) = ( D9 . 1 ) by L92 , L99 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L103: ( Comput (C24 , C23 , ( ( 0 ) + 1 )) ) = ( Following (C24 , ( Comput (C24 , C23 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C24 , C23) )
.= ( Exec (( Divide (C13 , C14) ) , C23) ) by L97 , L93 , L101 , PARTFUN1:def 6;
thus L104: thesis by L103 , L98 , L93 , L102 , PARTFUN1:def 6;
end;
let C25 being FinSeq-Location;
cluster ( C14 := (C25 , C13) ) ->  parahalting;
coherence
proof
set D10 = ( Macro ( C14 := (C25 , C13) ) );
let C26 being ( 0 ) -started (State of ( SCM+FSA ));
L105: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C26 by MEMSTR_0:29;
let C27 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L106: ( Macro ( C14 := (C25 , C13) ) ) c= C27;
take 1;
L107: ( dom C27 ) = ( NAT ) by PARTFUN1:def 2;
thus L108: ( IC ( Comput (C27 , C26 , 1) ) ) in ( dom C27 ) by L107;
L109: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L110: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L109 , TARSKI:def 1;
L111: ( IC C26 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L110 , L105 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L112: ( IC ( Exec (( C14 := (C25 , C13) ) , C26) ) ) = ( succ ( 0 ) ) by L111 , SCMFSA_2:72
.= ( ( 0 ) + 1 );
L113: 1 in ( dom D10 ) by COMPOS_1:60;
L114: ( 0 ) in ( dom D10 ) by COMPOS_1:60;
L115: ( C27 . ( 0 ) ) = ( D10 . ( 0 ) ) by L106 , L114 , GRFUNC_1:2
.= ( C14 := (C25 , C13) ) by COMPOS_1:58;
L116: ( C27 . 1 ) = ( D10 . 1 ) by L106 , L113 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L117: ( Comput (C27 , C26 , ( ( 0 ) + 1 )) ) = ( Following (C27 , ( Comput (C27 , C26 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C27 , C26) )
.= ( Exec (( C14 := (C25 , C13) ) , C26) ) by L111 , L107 , L115 , PARTFUN1:def 6;
thus L118: thesis by L117 , L112 , L107 , L116 , PARTFUN1:def 6;
end;
cluster ( (C25 , C13) := C14 ) ->  parahalting  keeping_0;
coherence
proof
thus L119: ( (C25 , C13) := C14 ) is  parahalting
proof
set D11 = ( Macro ( (C25 , C13) := C14 ) );
let C28 being ( 0 ) -started (State of ( SCM+FSA ));
L120: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C28 by MEMSTR_0:29;
let C29 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L121: ( Macro ( (C25 , C13) := C14 ) ) c= C29;
take 1;
L122: ( dom C29 ) = ( NAT ) by PARTFUN1:def 2;
thus L123: ( IC ( Comput (C29 , C28 , 1) ) ) in ( dom C29 ) by L122;
L124: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L125: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L124 , TARSKI:def 1;
L126: ( IC C28 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L125 , L120 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L127: ( IC ( Exec (( (C25 , C13) := C14 ) , C28) ) ) = ( succ ( 0 ) ) by L126 , SCMFSA_2:73
.= ( ( 0 ) + 1 );
L128: 1 in ( dom D11 ) by COMPOS_1:60;
L129: ( 0 ) in ( dom D11 ) by COMPOS_1:60;
L130: ( C29 . ( 0 ) ) = ( D11 . ( 0 ) ) by L121 , L129 , GRFUNC_1:2
.= ( (C25 , C13) := C14 ) by COMPOS_1:58;
L131: ( C29 . 1 ) = ( D11 . 1 ) by L121 , L128 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L132: ( Comput (C29 , C28 , ( ( 0 ) + 1 )) ) = ( Following (C29 , ( Comput (C29 , C28 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C29 , C28) )
.= ( Exec (( (C25 , C13) := C14 ) , C28) ) by L126 , L122 , L130 , PARTFUN1:def 6;
thus L133: thesis by L132 , L127 , L122 , L131 , PARTFUN1:def 6;
end;

thus L134: ( (C25 , C13) := C14 ) is  keeping_0
proof
set D12 = ( Macro ( (C25 , C13) := C14 ) );
let C30 being ( 0 ) -started (State of ( SCM+FSA ));
L135: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C30 by MEMSTR_0:29;
let C31 being (Instruction-Sequence of ( SCM+FSA ));
assume L136: D12 c= C31;
let C32 being (Element of ( NAT ));
L137: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L138: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L137 , TARSKI:def 1;
L139: ( IC C30 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L138 , L135 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L140: ( 0 ) in ( dom D12 ) by COMPOS_1:60;
L141: ( D12 . ( 0 ) ) = ( C31 . ( 0 ) ) by L140 , L136 , GRFUNC_1:2;
L142: ( C31 /. ( IC C30 ) ) = ( C31 . ( IC C30 ) ) by PBOOLE:143;
L143: ( Comput (C31 , C30 , ( ( 0 ) + 1 )) ) = ( Following (C31 , ( Comput (C31 , C30 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C31 , C30) )
.= ( Exec (( (C25 , C13) := C14 ) , C30) ) by L139 , L141 , L142 , COMPOS_1:58;
L144: 1 in ( dom D12 ) by COMPOS_1:60;
L145: ( D12 . 1 ) = ( C31 . 1 ) by L144 , L136 , GRFUNC_1:2;
L146: ( C31 . 1 ) = ( halt ( SCM+FSA ) ) by L145 , COMPOS_1:59;
L147: ( IC ( Exec (( (C25 , C13) := C14 ) , C30) ) ) = ( succ ( 0 ) ) by L139 , SCMFSA_2:73
.= ( ( 0 ) + 1 );
L148: ( CurInstr (C31 , ( Comput (C31 , C30 , 1) )) ) = ( halt ( SCM+FSA ) ) by L147 , L146 , L143 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L149: C32 = ( 0 );

thus L150: thesis by L149 , EXTPRO_1:2;
end;
suppose L151: 1 <= C32;

L152: ( ( Comput (C31 , C30 , 1) ) . ( intloc ( 0 ) ) ) = ( C30 . ( intloc ( 0 ) ) ) by L143 , SCMFSA_2:73;
thus L153: thesis by L152 , L148 , L151 , EXTPRO_1:5;
end;
end;

end;
end;
registration
let C33 being Int-Location;
let C34 being FinSeq-Location;
cluster ( C33 :=len C34 ) ->  parahalting;
coherence
proof
set D13 = ( Macro ( C33 :=len C34 ) );
let C35 being ( 0 ) -started (State of ( SCM+FSA ));
L136: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C35 by MEMSTR_0:29;
let C36 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L137: ( Macro ( C33 :=len C34 ) ) c= C36;
take 1;
L138: ( dom C36 ) = ( NAT ) by PARTFUN1:def 2;
thus L139: ( IC ( Comput (C36 , C35 , 1) ) ) in ( dom C36 ) by L138;
L140: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L141: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L140 , TARSKI:def 1;
L142: ( IC C35 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L141 , L136 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L143: ( IC ( Exec (( C33 :=len C34 ) , C35) ) ) = ( succ ( 0 ) ) by L142 , SCMFSA_2:74
.= ( ( 0 ) + 1 );
L144: 1 in ( dom D13 ) by COMPOS_1:60;
L145: ( 0 ) in ( dom D13 ) by COMPOS_1:60;
L146: ( C36 . ( 0 ) ) = ( D13 . ( 0 ) ) by L137 , L145 , GRFUNC_1:2
.= ( C33 :=len C34 ) by COMPOS_1:58;
L147: ( C36 . 1 ) = ( D13 . 1 ) by L137 , L144 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L148: ( Comput (C36 , C35 , ( ( 0 ) + 1 )) ) = ( Following (C36 , ( Comput (C36 , C35 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C36 , C35) )
.= ( Exec (( C33 :=len C34 ) , C35) ) by L142 , L138 , L146 , PARTFUN1:def 6;
thus L149: thesis by L148 , L143 , L138 , L147 , PARTFUN1:def 6;
end;
cluster ( C34 :=<0,...,0> C33 ) ->  parahalting  keeping_0;
coherence
proof
thus L150: ( C34 :=<0,...,0> C33 ) is  parahalting
proof
set D14 = ( Macro ( C34 :=<0,...,0> C33 ) );
let C37 being ( 0 ) -started (State of ( SCM+FSA ));
L151: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C37 by MEMSTR_0:29;
let C38 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L152: ( Macro ( C34 :=<0,...,0> C33 ) ) c= C38;
take 1;
L153: ( dom C38 ) = ( NAT ) by PARTFUN1:def 2;
thus L154: ( IC ( Comput (C38 , C37 , 1) ) ) in ( dom C38 ) by L153;
L155: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L156: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L155 , TARSKI:def 1;
L157: ( IC C37 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L156 , L151 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L158: ( IC ( Exec (( C34 :=<0,...,0> C33 ) , C37) ) ) = ( succ ( 0 ) ) by L157 , SCMFSA_2:75
.= ( ( 0 ) + 1 );
L159: 1 in ( dom D14 ) by COMPOS_1:60;
L160: ( 0 ) in ( dom D14 ) by COMPOS_1:60;
L161: ( C38 . ( 0 ) ) = ( D14 . ( 0 ) ) by L152 , L160 , GRFUNC_1:2
.= ( C34 :=<0,...,0> C33 ) by COMPOS_1:58;
L162: ( C38 . 1 ) = ( D14 . 1 ) by L152 , L159 , GRFUNC_1:2
.= ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L163: ( Comput (C38 , C37 , ( ( 0 ) + 1 )) ) = ( Following (C38 , ( Comput (C38 , C37 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C38 , C37) )
.= ( Exec (( C34 :=<0,...,0> C33 ) , C37) ) by L157 , L153 , L161 , PARTFUN1:def 6;
thus L164: thesis by L163 , L158 , L153 , L162 , PARTFUN1:def 6;
end;

thus L165: ( C34 :=<0,...,0> C33 ) is  keeping_0
proof
set D15 = ( Macro ( C34 :=<0,...,0> C33 ) );
let C39 being ( 0 ) -started (State of ( SCM+FSA ));
L166: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C39 by MEMSTR_0:29;
let C40 being (Instruction-Sequence of ( SCM+FSA ));
assume L167: D15 c= C40;
let C41 being (Element of ( NAT ));
L168: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L169: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L168 , TARSKI:def 1;
L170: ( IC C39 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L169 , L166 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L171: ( 0 ) in ( dom D15 ) by COMPOS_1:60;
L172: ( D15 . ( 0 ) ) = ( C40 . ( 0 ) ) by L171 , L167 , GRFUNC_1:2;
L173: ( C40 /. ( IC C39 ) ) = ( C40 . ( IC C39 ) ) by PBOOLE:143;
L174: ( Comput (C40 , C39 , ( ( 0 ) + 1 )) ) = ( Following (C40 , ( Comput (C40 , C39 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C40 , C39) )
.= ( Exec (( C34 :=<0,...,0> C33 ) , C39) ) by L170 , L172 , L173 , COMPOS_1:58;
L175: 1 in ( dom D15 ) by COMPOS_1:60;
L176: ( D15 . 1 ) = ( C40 . 1 ) by L175 , L167 , GRFUNC_1:2;
L177: ( C40 . 1 ) = ( halt ( SCM+FSA ) ) by L176 , COMPOS_1:59;
L178: ( IC ( Exec (( C34 :=<0,...,0> C33 ) , C39) ) ) = ( succ ( 0 ) ) by L170 , SCMFSA_2:75
.= ( ( 0 ) + 1 );
L179: ( CurInstr (C40 , ( Comput (C40 , C39 , 1) )) ) = ( halt ( SCM+FSA ) ) by L178 , L177 , L174 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L180: C41 = ( 0 );

thus L181: thesis by L180 , EXTPRO_1:2;
end;
suppose L182: 1 <= C41;

L183: ( ( Comput (C40 , C39 , 1) ) . ( intloc ( 0 ) ) ) = ( C39 . ( intloc ( 0 ) ) ) by L174 , SCMFSA_2:75;
thus L184: thesis by L183 , L179 , L182 , EXTPRO_1:5;
end;
end;

end;
end;
registration
let C42 being  read-write Int-Location;
let C43 being Int-Location;
cluster ( C42 := C43 ) ->  keeping_0;
coherence
proof
set D16 = ( Macro ( C42 := C43 ) );
let C44 being ( 0 ) -started (State of ( SCM+FSA ));
L167: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C44 by MEMSTR_0:29;
let C45 being (Instruction-Sequence of ( SCM+FSA ));
assume L168: D16 c= C45;
let C46 being (Element of ( NAT ));
L169: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L170: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L169 , TARSKI:def 1;
L171: ( IC C44 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L170 , L167 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L172: ( 0 ) in ( dom D16 ) by COMPOS_1:60;
L173: ( D16 . ( 0 ) ) = ( C45 . ( 0 ) ) by L172 , L168 , GRFUNC_1:2;
L174: ( C45 /. ( IC C44 ) ) = ( C45 . ( IC C44 ) ) by PBOOLE:143;
L175: ( Comput (C45 , C44 , ( ( 0 ) + 1 )) ) = ( Following (C45 , ( Comput (C45 , C44 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C45 , C44) )
.= ( Exec (( C42 := C43 ) , C44) ) by L171 , L173 , L174 , COMPOS_1:58;
L176: 1 in ( dom D16 ) by COMPOS_1:60;
L177: ( D16 . 1 ) = ( C45 . 1 ) by L176 , L168 , GRFUNC_1:2;
L178: ( C45 . 1 ) = ( halt ( SCM+FSA ) ) by L177 , COMPOS_1:59;
L179: ( IC ( Exec (( C42 := C43 ) , C44) ) ) = ( succ ( 0 ) ) by L171 , SCMFSA_2:63
.= ( ( 0 ) + 1 );
L180: ( CurInstr (C45 , ( Comput (C45 , C44 , 1) )) ) = ( halt ( SCM+FSA ) ) by L179 , L178 , L175 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L181: C46 = ( 0 );

thus L182: thesis by L181 , EXTPRO_1:2;
end;
suppose L183: 1 <= C46;

L184: ( ( Comput (C45 , C44 , 1) ) . ( intloc ( 0 ) ) ) = ( C44 . ( intloc ( 0 ) ) ) by L175 , SCMFSA_2:63;
thus L185: thesis by L184 , L180 , L183 , EXTPRO_1:5;
end;
end;
cluster ( AddTo (C42 , C43) ) ->  keeping_0;
coherence
proof
set D17 = ( Macro ( AddTo (C42 , C43) ) );
let C47 being ( 0 ) -started (State of ( SCM+FSA ));
L187: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C47 by MEMSTR_0:29;
let C48 being (Instruction-Sequence of ( SCM+FSA ));
assume L188: D17 c= C48;
let C49 being (Element of ( NAT ));
L189: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L190: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L189 , TARSKI:def 1;
L191: ( IC C47 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L190 , L187 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L192: ( 0 ) in ( dom D17 ) by COMPOS_1:60;
L193: ( D17 . ( 0 ) ) = ( C48 . ( 0 ) ) by L192 , L188 , GRFUNC_1:2;
L194: ( C48 /. ( IC C47 ) ) = ( C48 . ( IC C47 ) ) by PBOOLE:143;
L195: ( Comput (C48 , C47 , ( ( 0 ) + 1 )) ) = ( Following (C48 , ( Comput (C48 , C47 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C48 , C47) )
.= ( Exec (( AddTo (C42 , C43) ) , C47) ) by L191 , L193 , L194 , COMPOS_1:58;
L196: 1 in ( dom D17 ) by COMPOS_1:60;
L197: ( D17 . 1 ) = ( C48 . 1 ) by L196 , L188 , GRFUNC_1:2;
L198: ( C48 . 1 ) = ( halt ( SCM+FSA ) ) by L197 , COMPOS_1:59;
L199: ( IC ( Exec (( AddTo (C42 , C43) ) , C47) ) ) = ( succ ( 0 ) ) by L191 , SCMFSA_2:64
.= ( ( 0 ) + 1 );
L200: ( CurInstr (C48 , ( Comput (C48 , C47 , 1) )) ) = ( halt ( SCM+FSA ) ) by L199 , L198 , L195 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L201: C49 = ( 0 );

thus L202: thesis by L201 , EXTPRO_1:2;
end;
suppose L203: 1 <= C49;

L204: ( ( Comput (C48 , C47 , 1) ) . ( intloc ( 0 ) ) ) = ( C47 . ( intloc ( 0 ) ) ) by L195 , SCMFSA_2:64;
thus L205: thesis by L204 , L200 , L203 , EXTPRO_1:5;
end;
end;
cluster ( SubFrom (C42 , C43) ) ->  keeping_0;
coherence
proof
set D18 = ( Macro ( SubFrom (C42 , C43) ) );
let C50 being ( 0 ) -started (State of ( SCM+FSA ));
L207: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C50 by MEMSTR_0:29;
let C51 being (Instruction-Sequence of ( SCM+FSA ));
assume L208: D18 c= C51;
let C52 being (Element of ( NAT ));
L209: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L210: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L209 , TARSKI:def 1;
L211: ( IC C50 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L210 , L207 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L212: ( 0 ) in ( dom D18 ) by COMPOS_1:60;
L213: ( D18 . ( 0 ) ) = ( C51 . ( 0 ) ) by L212 , L208 , GRFUNC_1:2;
L214: ( C51 /. ( IC C50 ) ) = ( C51 . ( IC C50 ) ) by PBOOLE:143;
L215: ( Comput (C51 , C50 , ( ( 0 ) + 1 )) ) = ( Following (C51 , ( Comput (C51 , C50 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C51 , C50) )
.= ( Exec (( SubFrom (C42 , C43) ) , C50) ) by L211 , L213 , L214 , COMPOS_1:58;
L216: 1 in ( dom D18 ) by COMPOS_1:60;
L217: ( D18 . 1 ) = ( C51 . 1 ) by L216 , L208 , GRFUNC_1:2;
L218: ( C51 . 1 ) = ( halt ( SCM+FSA ) ) by L217 , COMPOS_1:59;
L219: ( IC ( Exec (( SubFrom (C42 , C43) ) , C50) ) ) = ( succ ( 0 ) ) by L211 , SCMFSA_2:65
.= ( ( 0 ) + 1 );
L220: ( CurInstr (C51 , ( Comput (C51 , C50 , 1) )) ) = ( halt ( SCM+FSA ) ) by L219 , L218 , L215 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L221: C52 = ( 0 );

thus L222: thesis by L221 , EXTPRO_1:2;
end;
suppose L223: 1 <= C52;

L224: ( ( Comput (C51 , C50 , 1) ) . ( intloc ( 0 ) ) ) = ( C50 . ( intloc ( 0 ) ) ) by L215 , SCMFSA_2:65;
thus L225: thesis by L224 , L220 , L223 , EXTPRO_1:5;
end;
end;
cluster ( MultBy (C42 , C43) ) ->  keeping_0;
coherence
proof
set D19 = ( Macro ( MultBy (C42 , C43) ) );
let C53 being ( 0 ) -started (State of ( SCM+FSA ));
L227: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C53 by MEMSTR_0:29;
let C54 being (Instruction-Sequence of ( SCM+FSA ));
assume L228: D19 c= C54;
let C55 being (Element of ( NAT ));
L229: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L230: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L229 , TARSKI:def 1;
L231: ( IC C53 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L230 , L227 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L232: ( 0 ) in ( dom D19 ) by COMPOS_1:60;
L233: ( D19 . ( 0 ) ) = ( C54 . ( 0 ) ) by L232 , L228 , GRFUNC_1:2;
L234: ( C54 /. ( IC C53 ) ) = ( C54 . ( IC C53 ) ) by PBOOLE:143;
L235: ( Comput (C54 , C53 , ( ( 0 ) + 1 )) ) = ( Following (C54 , ( Comput (C54 , C53 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C54 , C53) )
.= ( Exec (( MultBy (C42 , C43) ) , C53) ) by L231 , L233 , L234 , COMPOS_1:58;
L236: 1 in ( dom D19 ) by COMPOS_1:60;
L237: ( D19 . 1 ) = ( C54 . 1 ) by L236 , L228 , GRFUNC_1:2;
L238: ( C54 . 1 ) = ( halt ( SCM+FSA ) ) by L237 , COMPOS_1:59;
L239: ( IC ( Exec (( MultBy (C42 , C43) ) , C53) ) ) = ( succ ( 0 ) ) by L231 , SCMFSA_2:66
.= ( ( 0 ) + 1 );
L240: ( CurInstr (C54 , ( Comput (C54 , C53 , 1) )) ) = ( halt ( SCM+FSA ) ) by L239 , L238 , L235 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L241: C55 = ( 0 );

thus L242: thesis by L241 , EXTPRO_1:2;
end;
suppose L243: 1 <= C55;

L244: ( ( Comput (C54 , C53 , 1) ) . ( intloc ( 0 ) ) ) = ( C53 . ( intloc ( 0 ) ) ) by L235 , SCMFSA_2:66;
thus L245: thesis by L244 , L240 , L243 , EXTPRO_1:5;
end;
end;
end;
registration
let C56 , C57 being  read-write Int-Location;
cluster ( Divide (C56 , C57) ) ->  keeping_0;
coherence
proof
set D20 = ( Macro ( Divide (C56 , C57) ) );
let C58 being ( 0 ) -started (State of ( SCM+FSA ));
L248: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C58 by MEMSTR_0:29;
let C59 being (Instruction-Sequence of ( SCM+FSA ));
assume L249: D20 c= C59;
let C60 being (Element of ( NAT ));
L250: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L251: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L250 , TARSKI:def 1;
L252: ( IC C58 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L251 , L248 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L253: ( 0 ) in ( dom D20 ) by COMPOS_1:60;
L254: ( D20 . ( 0 ) ) = ( C59 . ( 0 ) ) by L253 , L249 , GRFUNC_1:2;
L255: ( C59 /. ( IC C58 ) ) = ( C59 . ( IC C58 ) ) by PBOOLE:143;
L256: ( Comput (C59 , C58 , ( ( 0 ) + 1 )) ) = ( Following (C59 , ( Comput (C59 , C58 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C59 , C58) )
.= ( Exec (( Divide (C56 , C57) ) , C58) ) by L252 , L254 , L255 , COMPOS_1:58;
L257: 1 in ( dom D20 ) by COMPOS_1:60;
L258: ( D20 . 1 ) = ( C59 . 1 ) by L257 , L249 , GRFUNC_1:2;
L259: ( C59 . 1 ) = ( halt ( SCM+FSA ) ) by L258 , COMPOS_1:59;
L260: ( IC ( Exec (( Divide (C56 , C57) ) , C58) ) ) = ( succ ( 0 ) ) by L252 , SCMFSA_2:67
.= ( ( 0 ) + 1 );
L261: ( CurInstr (C59 , ( Comput (C59 , C58 , 1) )) ) = ( halt ( SCM+FSA ) ) by L260 , L259 , L256 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L262: C60 = ( 0 );

thus L263: thesis by L262 , EXTPRO_1:2;
end;
suppose L264: 1 <= C60;

L265: ( ( Comput (C59 , C58 , 1) ) . ( intloc ( 0 ) ) ) = ( C58 . ( intloc ( 0 ) ) ) by L256 , SCMFSA_2:67;
thus L266: thesis by L265 , L261 , L264 , EXTPRO_1:5;
end;
end;
end;
registration
let C61 being Int-Location;
let C62 being FinSeq-Location;
let C63 being  read-write Int-Location;
cluster ( C63 := (C62 , C61) ) ->  keeping_0;
coherence
proof
set D21 = ( Macro ( C63 := (C62 , C61) ) );
let C64 being ( 0 ) -started (State of ( SCM+FSA ));
L269: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C64 by MEMSTR_0:29;
let C65 being (Instruction-Sequence of ( SCM+FSA ));
assume L270: D21 c= C65;
let C66 being (Element of ( NAT ));
L271: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L272: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L271 , TARSKI:def 1;
L273: ( IC C64 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L272 , L269 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L274: ( 0 ) in ( dom D21 ) by COMPOS_1:60;
L275: ( D21 . ( 0 ) ) = ( C65 . ( 0 ) ) by L274 , L270 , GRFUNC_1:2;
L276: ( C65 /. ( IC C64 ) ) = ( C65 . ( IC C64 ) ) by PBOOLE:143;
L277: ( Comput (C65 , C64 , ( ( 0 ) + 1 )) ) = ( Following (C65 , ( Comput (C65 , C64 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C65 , C64) )
.= ( Exec (( C63 := (C62 , C61) ) , C64) ) by L273 , L275 , L276 , COMPOS_1:58;
L278: 1 in ( dom D21 ) by COMPOS_1:60;
L279: ( D21 . 1 ) = ( C65 . 1 ) by L278 , L270 , GRFUNC_1:2;
L280: ( C65 . 1 ) = ( halt ( SCM+FSA ) ) by L279 , COMPOS_1:59;
L281: ( IC ( Exec (( C63 := (C62 , C61) ) , C64) ) ) = ( succ ( 0 ) ) by L273 , SCMFSA_2:72
.= ( ( 0 ) + 1 );
L282: ( CurInstr (C65 , ( Comput (C65 , C64 , 1) )) ) = ( halt ( SCM+FSA ) ) by L281 , L280 , L277 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L283: C66 = ( 0 );

thus L284: thesis by L283 , EXTPRO_1:2;
end;
suppose L285: 1 <= C66;

L286: ( ( Comput (C65 , C64 , 1) ) . ( intloc ( 0 ) ) ) = ( C64 . ( intloc ( 0 ) ) ) by L277 , SCMFSA_2:72;
thus L287: thesis by L286 , L282 , L285 , EXTPRO_1:5;
end;
end;
end;
registration
let C67 being FinSeq-Location;
let C68 being  read-write Int-Location;
cluster ( C68 :=len C67 ) ->  keeping_0;
coherence
proof
set D22 = ( Macro ( C68 :=len C67 ) );
let C69 being ( 0 ) -started (State of ( SCM+FSA ));
L290: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= C69 by MEMSTR_0:29;
let C70 being (Instruction-Sequence of ( SCM+FSA ));
assume L291: D22 c= C70;
let C71 being (Element of ( NAT ));
L292: ( dom D1 ) = { ( IC ( SCM+FSA ) ) } by FUNCOP_1:13;
L293: ( IC ( SCM+FSA ) ) in ( dom D1 ) by L292 , TARSKI:def 1;
L294: ( IC C69 ) = ( D1 . ( IC ( SCM+FSA ) ) ) by L293 , L290 , GRFUNC_1:2
.= ( 0 ) by FUNCOP_1:72;
L295: ( 0 ) in ( dom D22 ) by COMPOS_1:60;
L296: ( D22 . ( 0 ) ) = ( C70 . ( 0 ) ) by L295 , L291 , GRFUNC_1:2;
L297: ( C70 /. ( IC C69 ) ) = ( C70 . ( IC C69 ) ) by PBOOLE:143;
L298: ( Comput (C70 , C69 , ( ( 0 ) + 1 )) ) = ( Following (C70 , ( Comput (C70 , C69 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (C70 , C69) )
.= ( Exec (( C68 :=len C67 ) , C69) ) by L294 , L296 , L297 , COMPOS_1:58;
L299: 1 in ( dom D22 ) by COMPOS_1:60;
L300: ( D22 . 1 ) = ( C70 . 1 ) by L299 , L291 , GRFUNC_1:2;
L301: ( C70 . 1 ) = ( halt ( SCM+FSA ) ) by L300 , COMPOS_1:59;
L302: ( IC ( Exec (( C68 :=len C67 ) , C69) ) ) = ( succ ( 0 ) ) by L294 , SCMFSA_2:74
.= ( ( 0 ) + 1 );
L303: ( CurInstr (C70 , ( Comput (C70 , C69 , 1) )) ) = ( halt ( SCM+FSA ) ) by L302 , L301 , L298 , PBOOLE:143;
per cases  by NAT_1:14;
suppose L304: C71 = ( 0 );

thus L305: thesis by L304 , EXTPRO_1:2;
end;
suppose L306: 1 <= C71;

L307: ( ( Comput (C70 , C69 , 1) ) . ( intloc ( 0 ) ) ) = ( C69 . ( intloc ( 0 ) ) ) by L298 , SCMFSA_2:74;
thus L308: thesis by L307 , L303 , L306 , EXTPRO_1:5;
end;
end;
end;
registration
let C72 being  parahalting (Instruction of ( SCM+FSA ));
let C73 being  parahalting (Program of ( SCM+FSA ));
cluster ( C72 ";" C73 ) ->  parahalting;
coherence;
end;
registration
let C74 being  parahalting (Program of ( SCM+FSA ));
let C75 being  parahalting (Instruction of ( SCM+FSA ));
cluster ( C74 ";" C75 ) ->  parahalting;
coherence;
end;
registration
let C76 being  parahalting (Instruction of ( SCM+FSA ));
let C77 being  parahalting (Instruction of ( SCM+FSA ));
cluster ( C76 ";" C77 ) ->  parahalting;
coherence;
end;
registration
let C78 being  keeping_0 (Instruction of ( SCM+FSA ));
let C79 being  keeping_0 (Program of ( SCM+FSA ));
cluster ( C78 ";" C79 ) ->  keeping_0;
coherence;
end;
registration
let C80 being  keeping_0 (Program of ( SCM+FSA ));
let C81 being  keeping_0 (Instruction of ( SCM+FSA ));
cluster ( C80 ";" C81 ) ->  keeping_0;
coherence;
end;
registration
let C82 , C83 being  keeping_0 (Instruction of ( SCM+FSA ));
cluster ( C82 ";" C83 ) ->  keeping_0;
coherence;
end;
begin
canceled 1;
theorem
L317: (for R2 being (Instruction of ( SCM+FSA )) holds (for R9 being (State of ( SCM+FSA )) holds (for R10 being (State of ( SCM+FSA )) holds (( DataPart R9 ) = ( DataPart R10 ) implies ( DataPart ( Exec (R2 , R9) ) ) = ( DataPart ( Exec (R2 , R10) ) )))))
proof
let R2 being (Instruction of ( SCM+FSA ));
let R9 being (State of ( SCM+FSA ));
let R10 being (State of ( SCM+FSA ));
assume L318: ( DataPart R9 ) = ( DataPart R10 );
set D23 = R2;
L319: ( dom ( Exec (D23 , R9) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L320: ( dom ( Exec (D23 , R9) ) ) = ( dom ( Exec (D23 , R10) ) ) by L319 , PARTFUN1:def 2;
L321: ( dom ( ( Exec (D23 , R9) ) | ( Data-Locations ( SCM+FSA ) ) ) ) = ( Data-Locations ( SCM+FSA ) ) by L319 , RELAT_1:62;
L322: ( dom ( Exec (D23 , R10) ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L323: ( dom ( ( Exec (D23 , R10) ) | ( Data-Locations ( SCM+FSA ) ) ) ) = ( Data-Locations ( SCM+FSA ) ) by L322 , RELAT_1:62;
per cases  by NAT_1:36 , SCMFSA_2:16;
suppose L324: ( InsCode R2 ) = ( 0 );

L325: R2 = ( halt ( SCM+FSA ) ) by L324 , SCMFSA_2:95;
L326: ( Exec (R2 , R9) ) = R9 by L325 , EXTPRO_1:def 3;
thus L327: thesis by L326 , L318 , L325 , EXTPRO_1:def 3;
end;
suppose L328: ( InsCode R2 ) = 1;

consider C84 , C85 being Int-Location such that L329: D23 = ( C84 := C85 ) by L328 , SCMFSA_2:30;
L330: (for B5 being set holds (B5 in ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) . B5 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) . B5 )))
proof
let C86 being set;
assume L331: C86 in ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } );
L332: C86 in ( Data-Locations ( SCM+FSA ) ) by L331 , XBOOLE_0:def 5;
L333: (not C86 in { C84 }) by L331 , XBOOLE_0:def 5;
per cases  by L332 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L334: C86 in ( Int-Locations );

reconsider D24 = C86 as Int-Location by L334 , AMI_2:def 16;
L335: D24 <> C84 by L333 , TARSKI:def 1;
thus L336: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) . C86 ) = ( ( Exec (D23 , R9) ) . D24 ) by L331 , FUNCT_1:49
.= ( R9 . D24 ) by L329 , L335 , SCMFSA_2:63
.= ( ( DataPart R9 ) . D24 ) by L332 , FUNCT_1:49
.= ( R10 . D24 ) by L318 , L332 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D24 ) by L329 , L335 , SCMFSA_2:63
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) . C86 ) by L331 , FUNCT_1:49;
end;
suppose L337: C86 in ( FinSeq-Locations );

reconsider D25 = C86 as FinSeq-Location by L337 , SCMFSA_2:def 5;
thus L338: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) . C86 ) = ( ( Exec (D23 , R9) ) . D25 ) by L331 , FUNCT_1:49
.= ( R9 . D25 ) by L329 , SCMFSA_2:63
.= ( ( DataPart R9 ) . D25 ) by L332 , FUNCT_1:49
.= ( R10 . D25 ) by L318 , L332 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D25 ) by L329 , SCMFSA_2:63
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) . C86 ) by L331 , FUNCT_1:49;
end;
end;
L340: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) by L322 , RELAT_1:62;
L341: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) by L319 , RELAT_1:62;
L342: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) ) by L341 , L340 , L330 , FUNCT_1:2;
L343: C84 in ( Int-Locations ) by AMI_2:def 16;
L344: C84 in ( Data-Locations ( SCM+FSA ) ) by L343 , SCMFSA_2:100 , XBOOLE_0:def 3;
L345: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C84 } ) by L344 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C84 } ) \/ { C84 } ) by XBOOLE_1:39;
L346: ( ( Exec (D23 , R10) ) . C84 ) = ( R10 . C85 ) by L329 , SCMFSA_2:63;
L347: ( ( Exec (D23 , R9) ) . C84 ) = ( R9 . C85 ) by L329 , SCMFSA_2:63;
L348: C85 in ( Int-Locations ) by AMI_2:def 16;
L349: C85 in ( Data-Locations ( SCM+FSA ) ) by L348 , SCMFSA_2:100 , XBOOLE_0:def 3;
L350: ( R9 . C85 ) = ( ( DataPart R9 ) . C85 ) by L349 , FUNCT_1:49
.= ( R10 . C85 ) by L318 , L349 , FUNCT_1:49;
L351: ( ( Exec (D23 , R9) ) | { C84 } ) = ( ( Exec (D23 , R10) ) | { C84 } ) by L350 , L320 , L347 , L346 , GRFUNC_1:29;
thus L352: thesis by L351 , L345 , L342 , RELAT_1:150;
end;
suppose L353: ( InsCode R2 ) = 2;

consider C87 , C88 being Int-Location such that L354: D23 = ( AddTo (C87 , C88) ) by L353 , SCMFSA_2:31;
L355: (for B6 being set holds (B6 in ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) . B6 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) . B6 )))
proof
let C89 being set;
assume L356: C89 in ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } );
L357: C89 in ( Data-Locations ( SCM+FSA ) ) by L356 , XBOOLE_0:def 5;
L358: (not C89 in { C87 }) by L356 , XBOOLE_0:def 5;
per cases  by L357 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L359: C89 in ( Int-Locations );

reconsider D26 = C89 as Int-Location by L359 , AMI_2:def 16;
L360: D26 <> C87 by L358 , TARSKI:def 1;
thus L361: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) . C89 ) = ( ( Exec (D23 , R9) ) . D26 ) by L356 , FUNCT_1:49
.= ( R9 . D26 ) by L354 , L360 , SCMFSA_2:64
.= ( ( DataPart R9 ) . D26 ) by L357 , FUNCT_1:49
.= ( R10 . D26 ) by L318 , L357 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D26 ) by L354 , L360 , SCMFSA_2:64
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) . C89 ) by L356 , FUNCT_1:49;
end;
suppose L362: C89 in ( FinSeq-Locations );

reconsider D27 = C89 as FinSeq-Location by L362 , SCMFSA_2:def 5;
thus L363: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) . C89 ) = ( ( Exec (D23 , R9) ) . D27 ) by L356 , FUNCT_1:49
.= ( R9 . D27 ) by L354 , SCMFSA_2:64
.= ( ( DataPart R9 ) . D27 ) by L357 , FUNCT_1:49
.= ( R10 . D27 ) by L318 , L357 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D27 ) by L354 , SCMFSA_2:64
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) . C89 ) by L356 , FUNCT_1:49;
end;
end;
L365: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) by L322 , RELAT_1:62;
L366: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) by L319 , RELAT_1:62;
L367: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) ) by L366 , L365 , L355 , FUNCT_1:2;
L368: C87 in ( Int-Locations ) by AMI_2:def 16;
L369: C87 in ( Data-Locations ( SCM+FSA ) ) by L368 , SCMFSA_2:100 , XBOOLE_0:def 3;
L370: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C87 } ) by L369 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C87 } ) \/ { C87 } ) by XBOOLE_1:39;
L371: ( ( Exec (D23 , R10) ) . C87 ) = ( ( R10 . C87 ) + ( R10 . C88 ) ) by L354 , SCMFSA_2:64;
L372: ( ( Exec (D23 , R9) ) . C87 ) = ( ( R9 . C87 ) + ( R9 . C88 ) ) by L354 , SCMFSA_2:64;
L373: C87 in ( Int-Locations ) by AMI_2:def 16;
L374: C87 in ( Data-Locations ( SCM+FSA ) ) by L373 , SCMFSA_2:100 , XBOOLE_0:def 3;
L375: ( R9 . C87 ) = ( ( DataPart R9 ) . C87 ) by L374 , FUNCT_1:49
.= ( R10 . C87 ) by L318 , L374 , FUNCT_1:49;
L376: C88 in ( Int-Locations ) by AMI_2:def 16;
L377: C88 in ( Data-Locations ( SCM+FSA ) ) by L376 , SCMFSA_2:100 , XBOOLE_0:def 3;
L378: ( R9 . C88 ) = ( ( DataPart R9 ) . C88 ) by L377 , FUNCT_1:49
.= ( R10 . C88 ) by L318 , L377 , FUNCT_1:49;
L379: ( ( Exec (D23 , R9) ) | { C87 } ) = ( ( Exec (D23 , R10) ) | { C87 } ) by L378 , L320 , L372 , L371 , L375 , GRFUNC_1:29;
thus L380: thesis by L379 , L370 , L367 , RELAT_1:150;
end;
suppose L381: ( InsCode R2 ) = 3;

consider C90 , C91 being Int-Location such that L382: D23 = ( SubFrom (C90 , C91) ) by L381 , SCMFSA_2:32;
L383: (for B7 being set holds (B7 in ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) . B7 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) . B7 )))
proof
let C92 being set;
assume L384: C92 in ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } );
L385: C92 in ( Data-Locations ( SCM+FSA ) ) by L384 , XBOOLE_0:def 5;
L386: (not C92 in { C90 }) by L384 , XBOOLE_0:def 5;
per cases  by L385 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L387: C92 in ( Int-Locations );

reconsider D28 = C92 as Int-Location by L387 , AMI_2:def 16;
L388: D28 <> C90 by L386 , TARSKI:def 1;
thus L389: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) . C92 ) = ( ( Exec (D23 , R9) ) . D28 ) by L384 , FUNCT_1:49
.= ( R9 . D28 ) by L382 , L388 , SCMFSA_2:65
.= ( ( DataPart R9 ) . D28 ) by L385 , FUNCT_1:49
.= ( R10 . D28 ) by L318 , L385 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D28 ) by L382 , L388 , SCMFSA_2:65
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) . C92 ) by L384 , FUNCT_1:49;
end;
suppose L390: C92 in ( FinSeq-Locations );

reconsider D29 = C92 as FinSeq-Location by L390 , SCMFSA_2:def 5;
thus L391: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) . C92 ) = ( ( Exec (D23 , R9) ) . D29 ) by L384 , FUNCT_1:49
.= ( R9 . D29 ) by L382 , SCMFSA_2:65
.= ( ( DataPart R9 ) . D29 ) by L385 , FUNCT_1:49
.= ( R10 . D29 ) by L318 , L385 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D29 ) by L382 , SCMFSA_2:65
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) . C92 ) by L384 , FUNCT_1:49;
end;
end;
L393: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) by L322 , RELAT_1:62;
L394: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) by L319 , RELAT_1:62;
L395: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) ) by L394 , L393 , L383 , FUNCT_1:2;
L396: C90 in ( Int-Locations ) by AMI_2:def 16;
L397: C90 in ( Data-Locations ( SCM+FSA ) ) by L396 , SCMFSA_2:100 , XBOOLE_0:def 3;
L398: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C90 } ) by L397 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C90 } ) \/ { C90 } ) by XBOOLE_1:39;
L399: ( ( Exec (D23 , R10) ) . C90 ) = ( ( R10 . C90 ) - ( R10 . C91 ) ) by L382 , SCMFSA_2:65;
L400: ( ( Exec (D23 , R9) ) . C90 ) = ( ( R9 . C90 ) - ( R9 . C91 ) ) by L382 , SCMFSA_2:65;
L401: C90 in ( Int-Locations ) by AMI_2:def 16;
L402: C90 in ( Data-Locations ( SCM+FSA ) ) by L401 , SCMFSA_2:100 , XBOOLE_0:def 3;
L403: ( R9 . C90 ) = ( ( DataPart R9 ) . C90 ) by L402 , FUNCT_1:49
.= ( R10 . C90 ) by L318 , L402 , FUNCT_1:49;
L404: C91 in ( Int-Locations ) by AMI_2:def 16;
L405: C91 in ( Data-Locations ( SCM+FSA ) ) by L404 , SCMFSA_2:100 , XBOOLE_0:def 3;
L406: ( R9 . C91 ) = ( ( DataPart R9 ) . C91 ) by L405 , FUNCT_1:49
.= ( R10 . C91 ) by L318 , L405 , FUNCT_1:49;
L407: ( ( Exec (D23 , R9) ) | { C90 } ) = ( ( Exec (D23 , R10) ) | { C90 } ) by L406 , L320 , L400 , L399 , L403 , GRFUNC_1:29;
thus L408: thesis by L407 , L398 , L395 , RELAT_1:150;
end;
suppose L409: ( InsCode R2 ) = 4;

consider C93 , C94 being Int-Location such that L410: D23 = ( MultBy (C93 , C94) ) by L409 , SCMFSA_2:33;
L411: (for B8 being set holds (B8 in ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) . B8 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) . B8 )))
proof
let C95 being set;
assume L412: C95 in ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } );
L413: C95 in ( Data-Locations ( SCM+FSA ) ) by L412 , XBOOLE_0:def 5;
L414: (not C95 in { C93 }) by L412 , XBOOLE_0:def 5;
per cases  by L413 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L415: C95 in ( Int-Locations );

reconsider D30 = C95 as Int-Location by L415 , AMI_2:def 16;
L416: D30 <> C93 by L414 , TARSKI:def 1;
thus L417: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) . C95 ) = ( ( Exec (D23 , R9) ) . D30 ) by L412 , FUNCT_1:49
.= ( R9 . D30 ) by L410 , L416 , SCMFSA_2:66
.= ( ( DataPart R9 ) . D30 ) by L413 , FUNCT_1:49
.= ( R10 . D30 ) by L318 , L413 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D30 ) by L410 , L416 , SCMFSA_2:66
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) . C95 ) by L412 , FUNCT_1:49;
end;
suppose L418: C95 in ( FinSeq-Locations );

reconsider D31 = C95 as FinSeq-Location by L418 , SCMFSA_2:def 5;
thus L419: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) . C95 ) = ( ( Exec (D23 , R9) ) . D31 ) by L412 , FUNCT_1:49
.= ( R9 . D31 ) by L410 , SCMFSA_2:66
.= ( ( DataPart R9 ) . D31 ) by L413 , FUNCT_1:49
.= ( R10 . D31 ) by L318 , L413 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D31 ) by L410 , SCMFSA_2:66
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) . C95 ) by L412 , FUNCT_1:49;
end;
end;
L421: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) by L322 , RELAT_1:62;
L422: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) by L319 , RELAT_1:62;
L423: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) ) by L422 , L421 , L411 , FUNCT_1:2;
L424: C93 in ( Int-Locations ) by AMI_2:def 16;
L425: C93 in ( Data-Locations ( SCM+FSA ) ) by L424 , SCMFSA_2:100 , XBOOLE_0:def 3;
L426: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C93 } ) by L425 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C93 } ) \/ { C93 } ) by XBOOLE_1:39;
L427: ( ( Exec (D23 , R10) ) . C93 ) = ( ( R10 . C93 ) * ( R10 . C94 ) ) by L410 , SCMFSA_2:66;
L428: ( ( Exec (D23 , R9) ) . C93 ) = ( ( R9 . C93 ) * ( R9 . C94 ) ) by L410 , SCMFSA_2:66;
L429: C93 in ( Int-Locations ) by AMI_2:def 16;
L430: C93 in ( Data-Locations ( SCM+FSA ) ) by L429 , SCMFSA_2:100 , XBOOLE_0:def 3;
L431: ( R9 . C93 ) = ( ( DataPart R9 ) . C93 ) by L430 , FUNCT_1:49
.= ( R10 . C93 ) by L318 , L430 , FUNCT_1:49;
L432: C94 in ( Int-Locations ) by AMI_2:def 16;
L433: C94 in ( Data-Locations ( SCM+FSA ) ) by L432 , SCMFSA_2:100 , XBOOLE_0:def 3;
L434: ( R9 . C94 ) = ( ( DataPart R9 ) . C94 ) by L433 , FUNCT_1:49
.= ( R10 . C94 ) by L318 , L433 , FUNCT_1:49;
L435: ( ( Exec (D23 , R9) ) | { C93 } ) = ( ( Exec (D23 , R10) ) | { C93 } ) by L434 , L320 , L428 , L427 , L431 , GRFUNC_1:29;
thus L436: thesis by L435 , L426 , L423 , RELAT_1:150;
end;
suppose L437: ( InsCode R2 ) = 5;

consider C96 , C97 being Int-Location such that L438: D23 = ( Divide (C96 , C97) ) by L437 , SCMFSA_2:34;
thus L439:now
per cases ;
suppose L440: C97 <> C96;

L441: (for B9 being set holds (B9 in ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) . B9 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) . B9 )))
proof
let C98 being set;
assume L442: C98 in ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } );
L443: C98 in ( Data-Locations ( SCM+FSA ) ) by L442 , XBOOLE_0:def 5;
L444: (not C98 in { C96 , C97 }) by L442 , XBOOLE_0:def 5;
per cases  by L443 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L445: C98 in ( Int-Locations );

reconsider D32 = C98 as Int-Location by L445 , AMI_2:def 16;
L446: D32 <> C97 by L444 , TARSKI:def 2;
L447: D32 <> C96 by L444 , TARSKI:def 2;
thus L448: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) . C98 ) = ( ( Exec (D23 , R9) ) . D32 ) by L442 , FUNCT_1:49
.= ( R9 . D32 ) by L438 , L446 , L447 , SCMFSA_2:67
.= ( ( DataPart R9 ) . D32 ) by L443 , FUNCT_1:49
.= ( R10 . D32 ) by L318 , L443 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D32 ) by L438 , L446 , L447 , SCMFSA_2:67
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) . C98 ) by L442 , FUNCT_1:49;
end;
suppose L449: C98 in ( FinSeq-Locations );

reconsider D33 = C98 as FinSeq-Location by L449 , SCMFSA_2:def 5;
thus L450: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) . C98 ) = ( ( Exec (D23 , R9) ) . D33 ) by L442 , FUNCT_1:49
.= ( R9 . D33 ) by L438 , SCMFSA_2:67
.= ( ( DataPart R9 ) . D33 ) by L443 , FUNCT_1:49
.= ( R10 . D33 ) by L318 , L443 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D33 ) by L438 , SCMFSA_2:67
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) . C98 ) by L442 , FUNCT_1:49;
end;
end;
L452: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) by L322 , RELAT_1:62;
L453: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) by L319 , RELAT_1:62;
L454: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) ) by L453 , L452 , L441 , FUNCT_1:2;
L455: ( ( Exec (D23 , R10) ) . C97 ) = ( ( R10 . C96 ) mod ( R10 . C97 ) ) by L438 , SCMFSA_2:67;
L456: C96 in ( Int-Locations ) by AMI_2:def 16;
L457: C96 in ( Data-Locations ( SCM+FSA ) ) by L456 , SCMFSA_2:100 , XBOOLE_0:def 3;
L458: ( R9 . C96 ) = ( ( DataPart R9 ) . C96 ) by L457 , FUNCT_1:49
.= ( R10 . C96 ) by L318 , L457 , FUNCT_1:49;
L459: C97 in ( Int-Locations ) by AMI_2:def 16;
L460: C97 in ( Data-Locations ( SCM+FSA ) ) by L459 , SCMFSA_2:100 , XBOOLE_0:def 3;
L461: C96 in ( Int-Locations ) by AMI_2:def 16;
L462: C96 in ( Data-Locations ( SCM+FSA ) ) by L461 , SCMFSA_2:100 , XBOOLE_0:def 3;
L463: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C96 , C97 } ) by L462 , L460 , ZFMISC_1:42
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C96 , C97 } ) \/ { C96 , C97 } ) by XBOOLE_1:39;
L464: ( ( Exec (D23 , R9) ) . C97 ) = ( ( R9 . C96 ) mod ( R9 . C97 ) ) by L438 , SCMFSA_2:67;
L465: ( ( Exec (D23 , R10) ) . C96 ) = ( ( R10 . C96 ) div ( R10 . C97 ) ) by L438 , L440 , SCMFSA_2:67;
L466: ( ( Exec (D23 , R9) ) . C96 ) = ( ( R9 . C96 ) div ( R9 . C97 ) ) by L438 , L440 , SCMFSA_2:67;
L467: C97 in ( Int-Locations ) by AMI_2:def 16;
L468: C97 in ( Data-Locations ( SCM+FSA ) ) by L467 , SCMFSA_2:100 , XBOOLE_0:def 3;
L469: ( R9 . C97 ) = ( ( DataPart R9 ) . C97 ) by L468 , FUNCT_1:49
.= ( R10 . C97 ) by L318 , L468 , FUNCT_1:49;
L470: ( ( Exec (D23 , R9) ) | { C96 , C97 } ) = ( ( Exec (D23 , R10) ) | { C96 , C97 } ) by L469 , L320 , L466 , L464 , L465 , L455 , L458 , GRFUNC_1:30;
thus L471: thesis by L470 , L463 , L454 , RELAT_1:150;
end;
suppose L472: C97 = C96;

L473: (for B10 being set holds (B10 in ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) . B10 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) . B10 )))
proof
let C99 being set;
assume L474: C99 in ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } );
L475: C99 in ( Data-Locations ( SCM+FSA ) ) by L474 , XBOOLE_0:def 5;
L476: (not C99 in { C96 }) by L474 , XBOOLE_0:def 5;
per cases  by L475 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L477: C99 in ( Int-Locations );

reconsider D34 = C99 as Int-Location by L477 , AMI_2:def 16;
L478: D34 <> C96 by L476 , TARSKI:def 1;
thus L479: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) . C99 ) = ( ( Exec (D23 , R9) ) . D34 ) by L474 , FUNCT_1:49
.= ( R9 . D34 ) by L438 , L472 , L478 , SCMFSA_2:68
.= ( ( DataPart R9 ) . D34 ) by L475 , FUNCT_1:49
.= ( R10 . D34 ) by L318 , L475 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D34 ) by L438 , L472 , L478 , SCMFSA_2:68
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) . C99 ) by L474 , FUNCT_1:49;
end;
suppose L480: C99 in ( FinSeq-Locations );

reconsider D35 = C99 as FinSeq-Location by L480 , SCMFSA_2:def 5;
thus L481: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) . C99 ) = ( ( Exec (D23 , R9) ) . D35 ) by L474 , FUNCT_1:49
.= ( R9 . D35 ) by L438 , L472 , SCMFSA_2:68
.= ( ( R9 | ( Data-Locations ( SCM+FSA ) ) ) . D35 ) by L475 , FUNCT_1:49
.= ( R10 . D35 ) by L318 , L475 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D35 ) by L438 , L472 , SCMFSA_2:68
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) . C99 ) by L474 , FUNCT_1:49;
end;
end;
L483: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) by L322 , RELAT_1:62;
L484: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) by L319 , RELAT_1:62;
L485: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) ) by L484 , L483 , L473 , FUNCT_1:2;
L486: C96 in ( Int-Locations ) by AMI_2:def 16;
L487: C96 in ( Data-Locations ( SCM+FSA ) ) by L486 , SCMFSA_2:100 , XBOOLE_0:def 3;
L488: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C96 } ) by L487 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C96 } ) \/ { C96 } ) by XBOOLE_1:39;
L489: ( ( Exec (D23 , R10) ) . C96 ) = ( ( R10 . C96 ) mod ( R10 . C97 ) ) by L438 , L472 , SCMFSA_2:68;
L490: ( ( Exec (D23 , R9) ) . C96 ) = ( ( R9 . C96 ) mod ( R9 . C97 ) ) by L438 , L472 , SCMFSA_2:68;
L491: C96 in ( Int-Locations ) by AMI_2:def 16;
L492: C96 in ( Data-Locations ( SCM+FSA ) ) by L491 , SCMFSA_2:100 , XBOOLE_0:def 3;
L493: ( R9 . C96 ) = ( ( DataPart R9 ) . C96 ) by L492 , FUNCT_1:49
.= ( R10 . C96 ) by L318 , L492 , FUNCT_1:49;
L494: C97 in ( Int-Locations ) by AMI_2:def 16;
L495: C97 in ( Data-Locations ( SCM+FSA ) ) by L494 , SCMFSA_2:100 , XBOOLE_0:def 3;
L496: ( R9 . C97 ) = ( ( DataPart R9 ) . C97 ) by L495 , FUNCT_1:49
.= ( R10 . C97 ) by L318 , L495 , FUNCT_1:49;
L497: ( ( Exec (D23 , R9) ) | { C96 } ) = ( ( Exec (D23 , R10) ) | { C96 } ) by L496 , L320 , L490 , L489 , L493 , GRFUNC_1:29;
thus L498: thesis by L497 , L488 , L485 , RELAT_1:150;
end;
end;
end;
suppose L440: ( InsCode R2 ) = 6;

L441: (ex R7 being (Element of ( NAT )) st R2 = ( goto R7 )) by L440 , SCMFSA_2:35;
L442: (for B11 being set holds (B11 in ( Data-Locations ( SCM+FSA ) ) implies ( ( DataPart ( Exec (D23 , R9) ) ) . B11 ) = ( ( DataPart ( Exec (D23 , R10) ) ) . B11 )))
proof
let C100 being set;
assume L443: C100 in ( Data-Locations ( SCM+FSA ) );
per cases  by L443 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L444: C100 in ( Int-Locations );

reconsider D36 = C100 as Int-Location by L444 , AMI_2:def 16;
thus L445: ( ( DataPart ( Exec (D23 , R9) ) ) . C100 ) = ( ( Exec (D23 , R9) ) . D36 ) by L443 , FUNCT_1:49
.= ( R9 . D36 ) by L441 , SCMFSA_2:69
.= ( ( DataPart R9 ) . D36 ) by L443 , FUNCT_1:49
.= ( R10 . D36 ) by L318 , L443 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D36 ) by L441 , SCMFSA_2:69
.= ( ( DataPart ( Exec (D23 , R10) ) ) . C100 ) by L443 , FUNCT_1:49;
end;
suppose L446: C100 in ( FinSeq-Locations );

reconsider D37 = C100 as FinSeq-Location by L446 , SCMFSA_2:def 5;
thus L447: ( ( DataPart ( Exec (D23 , R9) ) ) . C100 ) = ( ( Exec (D23 , R9) ) . D37 ) by L443 , FUNCT_1:49
.= ( R9 . D37 ) by L441 , SCMFSA_2:69
.= ( ( DataPart R9 ) . D37 ) by L443 , FUNCT_1:49
.= ( R10 . D37 ) by L318 , L443 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D37 ) by L441 , SCMFSA_2:69
.= ( ( DataPart ( Exec (D23 , R10) ) ) . C100 ) by L443 , FUNCT_1:49;
end;
end;
thus L449: thesis by L442 , L321 , L323 , FUNCT_1:2;
end;
suppose L450: ( InsCode R2 ) = 7;

L451: (ex R7 being (Element of ( NAT )) st (ex R3 being Int-Location st R2 = ( R3 =0_goto R7 ))) by L450 , SCMFSA_2:36;
L452: (for B12 being set holds (B12 in ( Data-Locations ( SCM+FSA ) ) implies ( ( DataPart ( Exec (D23 , R9) ) ) . B12 ) = ( ( DataPart ( Exec (D23 , R10) ) ) . B12 )))
proof
let C101 being set;
assume L453: C101 in ( Data-Locations ( SCM+FSA ) );
per cases  by L453 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L454: C101 in ( Int-Locations );

reconsider D38 = C101 as Int-Location by L454 , AMI_2:def 16;
thus L455: ( ( DataPart ( Exec (D23 , R9) ) ) . C101 ) = ( ( Exec (D23 , R9) ) . D38 ) by L453 , FUNCT_1:49
.= ( R9 . D38 ) by L451 , SCMFSA_2:70
.= ( ( DataPart R9 ) . D38 ) by L453 , FUNCT_1:49
.= ( R10 . D38 ) by L318 , L453 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D38 ) by L451 , SCMFSA_2:70
.= ( ( DataPart ( Exec (D23 , R10) ) ) . C101 ) by L453 , FUNCT_1:49;
end;
suppose L456: C101 in ( FinSeq-Locations );

reconsider D39 = C101 as FinSeq-Location by L456 , SCMFSA_2:def 5;
thus L457: ( ( DataPart ( Exec (D23 , R9) ) ) . C101 ) = ( ( Exec (D23 , R9) ) . D39 ) by L453 , FUNCT_1:49
.= ( R9 . D39 ) by L451 , SCMFSA_2:70
.= ( ( DataPart R9 ) . D39 ) by L453 , FUNCT_1:49
.= ( R10 . D39 ) by L318 , L453 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D39 ) by L451 , SCMFSA_2:70
.= ( ( DataPart ( Exec (D23 , R10) ) ) . C101 ) by L453 , FUNCT_1:49;
end;
end;
thus L459: thesis by L452 , L321 , L323 , FUNCT_1:2;
end;
suppose L460: ( InsCode R2 ) = 8;

L461: (ex R7 being (Element of ( NAT )) st (ex R3 being Int-Location st R2 = ( R3 >0_goto R7 ))) by L460 , SCMFSA_2:37;
L462: (for B13 being set holds (B13 in ( Data-Locations ( SCM+FSA ) ) implies ( ( DataPart ( Exec (D23 , R9) ) ) . B13 ) = ( ( DataPart ( Exec (D23 , R10) ) ) . B13 )))
proof
let C102 being set;
assume L463: C102 in ( Data-Locations ( SCM+FSA ) );
per cases  by L463 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L464: C102 in ( Int-Locations );

reconsider D40 = C102 as Int-Location by L464 , AMI_2:def 16;
thus L465: ( ( DataPart ( Exec (D23 , R9) ) ) . C102 ) = ( ( Exec (D23 , R9) ) . D40 ) by L463 , FUNCT_1:49
.= ( R9 . D40 ) by L461 , SCMFSA_2:71
.= ( ( DataPart R9 ) . D40 ) by L463 , FUNCT_1:49
.= ( R10 . D40 ) by L318 , L463 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D40 ) by L461 , SCMFSA_2:71
.= ( ( DataPart ( Exec (D23 , R10) ) ) . C102 ) by L463 , FUNCT_1:49;
end;
suppose L466: C102 in ( FinSeq-Locations );

reconsider D41 = C102 as FinSeq-Location by L466 , SCMFSA_2:def 5;
thus L467: ( ( DataPart ( Exec (D23 , R9) ) ) . C102 ) = ( ( Exec (D23 , R9) ) . D41 ) by L463 , FUNCT_1:49
.= ( R9 . D41 ) by L461 , SCMFSA_2:71
.= ( ( DataPart R9 ) . D41 ) by L463 , FUNCT_1:49
.= ( R10 . D41 ) by L318 , L463 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D41 ) by L461 , SCMFSA_2:71
.= ( ( DataPart ( Exec (D23 , R10) ) ) . C102 ) by L463 , FUNCT_1:49;
end;
end;
thus L469: thesis by L462 , L321 , L323 , FUNCT_1:2;
end;
suppose L470: ( InsCode R2 ) = 9;

consider C103 , C104 being Int-Location, C105 being FinSeq-Location such that L471: D23 = ( C104 := (C105 , C103) ) by L470 , SCMFSA_2:38;
L472: (for B14 being set holds (B14 in ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) . B14 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) . B14 )))
proof
let C106 being set;
assume L473: C106 in ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } );
L474: C106 in ( Data-Locations ( SCM+FSA ) ) by L473 , XBOOLE_0:def 5;
L475: (not C106 in { C104 }) by L473 , XBOOLE_0:def 5;
per cases  by L474 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L476: C106 in ( Int-Locations );

reconsider D42 = C106 as Int-Location by L476 , AMI_2:def 16;
L477: D42 <> C104 by L475 , TARSKI:def 1;
thus L478: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) . C106 ) = ( ( Exec (D23 , R9) ) . D42 ) by L473 , FUNCT_1:49
.= ( R9 . D42 ) by L471 , L477 , SCMFSA_2:72
.= ( ( DataPart R9 ) . D42 ) by L474 , FUNCT_1:49
.= ( R10 . D42 ) by L318 , L474 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D42 ) by L471 , L477 , SCMFSA_2:72
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) . C106 ) by L473 , FUNCT_1:49;
end;
suppose L479: C106 in ( FinSeq-Locations );

reconsider D43 = C106 as FinSeq-Location by L479 , SCMFSA_2:def 5;
thus L480: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) . C106 ) = ( ( Exec (D23 , R9) ) . D43 ) by L473 , FUNCT_1:49
.= ( R9 . D43 ) by L471 , SCMFSA_2:72
.= ( ( DataPart R9 ) . D43 ) by L474 , FUNCT_1:49
.= ( R10 . D43 ) by L318 , L474 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D43 ) by L471 , SCMFSA_2:72
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) . C106 ) by L473 , FUNCT_1:49;
end;
end;
L482: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) by L322 , RELAT_1:62;
L483: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) by L319 , RELAT_1:62;
L484: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) ) by L483 , L482 , L472 , FUNCT_1:2;
L485: C104 in ( Int-Locations ) by AMI_2:def 16;
L486: C104 in ( Data-Locations ( SCM+FSA ) ) by L485 , SCMFSA_2:100 , XBOOLE_0:def 3;
L487: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C104 } ) by L486 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C104 } ) \/ { C104 } ) by XBOOLE_1:39;
L488: (ex B15 being (Element of ( NAT )) st (B15 = ( abs ( R10 . C103 ) ) & ( ( Exec (D23 , R10) ) . C104 ) = ( ( R10 . C105 ) /. B15 ))) by L471 , SCMFSA_2:72;
L489: (ex B16 being (Element of ( NAT )) st (B16 = ( abs ( R9 . C103 ) ) & ( ( Exec (D23 , R9) ) . C104 ) = ( ( R9 . C105 ) /. B16 ))) by L471 , SCMFSA_2:72;
L490: C105 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L491: C105 in ( Data-Locations ( SCM+FSA ) ) by L490 , SCMFSA_2:100 , XBOOLE_0:def 3;
L492: ( R9 . C105 ) = ( ( DataPart R9 ) . C105 ) by L491 , FUNCT_1:49
.= ( R10 . C105 ) by L318 , L491 , FUNCT_1:49;
L493: C103 in ( Int-Locations ) by AMI_2:def 16;
L494: C103 in ( Data-Locations ( SCM+FSA ) ) by L493 , SCMFSA_2:100 , XBOOLE_0:def 3;
L495: ( R9 . C103 ) = ( ( DataPart R9 ) . C103 ) by L494 , FUNCT_1:49
.= ( R10 . C103 ) by L318 , L494 , FUNCT_1:49;
L496: ( ( Exec (D23 , R9) ) | { C104 } ) = ( ( Exec (D23 , R10) ) | { C104 } ) by L495 , L320 , L489 , L488 , L492 , GRFUNC_1:29;
thus L497: thesis by L496 , L487 , L484 , RELAT_1:150;
end;
suppose L498: ( InsCode R2 ) = 10;

consider C107 , C108 being Int-Location, C109 being FinSeq-Location such that L499: D23 = ( (C109 , C107) := C108 ) by L498 , SCMFSA_2:39;
L500: (for B17 being set holds (B17 in ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) . B17 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) . B17 )))
proof
let C110 being set;
assume L501: C110 in ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } );
L502: C110 in ( Data-Locations ( SCM+FSA ) ) by L501 , XBOOLE_0:def 5;
L503: (not C110 in { C109 }) by L501 , XBOOLE_0:def 5;
per cases  by L502 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L504: C110 in ( Int-Locations );

reconsider D44 = C110 as Int-Location by L504 , AMI_2:def 16;
thus L505: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) . C110 ) = ( ( Exec (D23 , R9) ) . D44 ) by L501 , FUNCT_1:49
.= ( R9 . D44 ) by L499 , SCMFSA_2:73
.= ( ( DataPart R9 ) . D44 ) by L502 , FUNCT_1:49
.= ( R10 . D44 ) by L318 , L502 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D44 ) by L499 , SCMFSA_2:73
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) . C110 ) by L501 , FUNCT_1:49;
end;
suppose L506: C110 in ( FinSeq-Locations );

reconsider D45 = C110 as FinSeq-Location by L506 , SCMFSA_2:def 5;
L507: D45 <> C109 by L503 , TARSKI:def 1;
thus L508: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) . C110 ) = ( ( Exec (D23 , R9) ) . D45 ) by L501 , FUNCT_1:49
.= ( R9 . D45 ) by L499 , L507 , SCMFSA_2:73
.= ( ( DataPart R9 ) . D45 ) by L502 , FUNCT_1:49
.= ( R10 . D45 ) by L318 , L502 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D45 ) by L499 , L507 , SCMFSA_2:73
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) . C110 ) by L501 , FUNCT_1:49;
end;
end;
L510: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) by L322 , RELAT_1:62;
L511: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) by L319 , RELAT_1:62;
L512: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) ) by L511 , L510 , L500 , FUNCT_1:2;
L513: C109 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L514: C109 in ( Data-Locations ( SCM+FSA ) ) by L513 , SCMFSA_2:100 , XBOOLE_0:def 3;
L515: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C109 } ) by L514 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C109 } ) \/ { C109 } ) by XBOOLE_1:39;
L516: C109 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L517: C109 in ( Data-Locations ( SCM+FSA ) ) by L516 , SCMFSA_2:100 , XBOOLE_0:def 3;
L518: ( R9 . C109 ) = ( ( DataPart R9 ) . C109 ) by L517 , FUNCT_1:49
.= ( R10 . C109 ) by L318 , L517 , FUNCT_1:49;
L519: C108 in ( Int-Locations ) by AMI_2:def 16;
L520: C108 in ( Data-Locations ( SCM+FSA ) ) by L519 , SCMFSA_2:100 , XBOOLE_0:def 3;
L521: ( R9 . C108 ) = ( ( DataPart R9 ) . C108 ) by L520 , FUNCT_1:49
.= ( R10 . C108 ) by L318 , L520 , FUNCT_1:49;
L522: (ex B18 being (Element of ( NAT )) st (B18 = ( abs ( R10 . C107 ) ) & ( ( Exec (D23 , R10) ) . C109 ) = ( ( R10 . C109 ) +* (B18 , ( R10 . C108 )) ))) by L499 , SCMFSA_2:73;
L523: (ex B19 being (Element of ( NAT )) st (B19 = ( abs ( R9 . C107 ) ) & ( ( Exec (D23 , R9) ) . C109 ) = ( ( R9 . C109 ) +* (B19 , ( R9 . C108 )) ))) by L499 , SCMFSA_2:73;
L524: C107 in ( Int-Locations ) by AMI_2:def 16;
L525: C107 in ( Data-Locations ( SCM+FSA ) ) by L524 , SCMFSA_2:100 , XBOOLE_0:def 3;
L526: ( R9 . C107 ) = ( ( DataPart R9 ) . C107 ) by L525 , FUNCT_1:49
.= ( R10 . C107 ) by L318 , L525 , FUNCT_1:49;
L527: ( ( Exec (D23 , R9) ) | { C109 } ) = ( ( Exec (D23 , R10) ) | { C109 } ) by L526 , L320 , L523 , L522 , L521 , L518 , GRFUNC_1:29;
thus L528: thesis by L527 , L515 , L512 , RELAT_1:150;
end;
suppose L529: ( InsCode R2 ) = 11;

consider C111 being Int-Location, C112 being FinSeq-Location such that L530: D23 = ( C111 :=len C112 ) by L529 , SCMFSA_2:40;
L531: (for B20 being set holds (B20 in ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) implies ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) . B20 ) = ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) . B20 )))
proof
let C113 being set;
assume L532: C113 in ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } );
L533: C113 in ( Data-Locations ( SCM+FSA ) ) by L532 , XBOOLE_0:def 5;
L534: (not C113 in { C111 }) by L532 , XBOOLE_0:def 5;
per cases  by L533 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L535: C113 in ( Int-Locations );

reconsider D46 = C113 as Int-Location by L535 , AMI_2:def 16;
L536: D46 <> C111 by L534 , TARSKI:def 1;
thus L537: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) . C113 ) = ( ( Exec (D23 , R9) ) . D46 ) by L532 , FUNCT_1:49
.= ( R9 . D46 ) by L530 , L536 , SCMFSA_2:74
.= ( ( DataPart R9 ) . D46 ) by L533 , FUNCT_1:49
.= ( R10 . D46 ) by L318 , L533 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D46 ) by L530 , L536 , SCMFSA_2:74
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) . C113 ) by L532 , FUNCT_1:49;
end;
suppose L538: C113 in ( FinSeq-Locations );

reconsider D47 = C113 as FinSeq-Location by L538 , SCMFSA_2:def 5;
thus L539: ( ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) . C113 ) = ( ( Exec (D23 , R9) ) . D47 ) by L532 , FUNCT_1:49
.= ( R9 . D47 ) by L530 , SCMFSA_2:74
.= ( ( DataPart R9 ) . D47 ) by L533 , FUNCT_1:49
.= ( R10 . D47 ) by L318 , L533 , FUNCT_1:49
.= ( ( Exec (D23 , R10) ) . D47 ) by L530 , SCMFSA_2:74
.= ( ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) . C113 ) by L532 , FUNCT_1:49;
end;
end;
L541: C111 in ( Int-Locations ) by AMI_2:def 16;
L542: C111 in ( Data-Locations ( SCM+FSA ) ) by L541 , SCMFSA_2:100 , XBOOLE_0:def 3;
L543: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C111 } ) by L542 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) \/ { C111 } ) by XBOOLE_1:39;
L544: C112 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L545: C112 in ( Data-Locations ( SCM+FSA ) ) by L544 , SCMFSA_2:100 , XBOOLE_0:def 3;
L546: ( R9 . C112 ) = ( ( R9 | ( Data-Locations ( SCM+FSA ) ) ) . C112 ) by L545 , FUNCT_1:49
.= ( R10 . C112 ) by L318 , L545 , FUNCT_1:49;
L547: ( ( Exec (D23 , R9) ) . C111 ) = ( len ( R10 . C112 ) ) by L546 , L530 , SCMFSA_2:74
.= ( ( Exec (D23 , R10) ) . C111 ) by L530 , SCMFSA_2:74;
L548: ( ( Exec (D23 , R9) ) | { C111 } ) = ( ( Exec (D23 , R10) ) | { C111 } ) by L547 , L319 , L322 , GRFUNC_1:29;
L549: ( dom ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) by L322 , RELAT_1:62;
L550: ( dom ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) by L319 , RELAT_1:62;
L551: ( ( Exec (D23 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) = ( ( Exec (D23 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C111 } ) ) by L550 , L549 , L531 , FUNCT_1:2;
thus L552: thesis by L551 , L543 , L548 , RELAT_1:150;
end;
suppose L553: ( InsCode R2 ) = 12;

consider C114 being Int-Location, C115 being FinSeq-Location such that L554: R2 = ( C115 :=<0,...,0> C114 ) by L553 , SCMFSA_2:41;
set D48 = R2;
L555: ( dom ( ( Exec (D48 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) by L322 , RELAT_1:62;
L556: (ex B21 being (Element of ( NAT )) st (B21 = ( abs ( R10 . C114 ) ) & ( ( Exec (D48 , R10) ) . C115 ) = ( B21 |-> ( 0 ) ))) by L554 , SCMFSA_2:75;
L557: (ex B22 being (Element of ( NAT )) st (B22 = ( abs ( R9 . C114 ) ) & ( ( Exec (D48 , R9) ) . C115 ) = ( B22 |-> ( 0 ) ))) by L554 , SCMFSA_2:75;
L558: (for B23 being set holds (B23 in ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) implies ( ( ( Exec (D48 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) . B23 ) = ( ( ( Exec (D48 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) . B23 )))
proof
let C116 being set;
assume L559: C116 in ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } );
L560: C116 in ( Data-Locations ( SCM+FSA ) ) by L559 , XBOOLE_0:def 5;
L561: (not C116 in { C115 }) by L559 , XBOOLE_0:def 5;
per cases  by L560 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L562: C116 in ( Int-Locations );

reconsider D49 = C116 as Int-Location by L562 , AMI_2:def 16;
thus L563: ( ( ( Exec (D48 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) . C116 ) = ( ( Exec (D48 , R9) ) . D49 ) by L559 , FUNCT_1:49
.= ( R9 . D49 ) by L554 , SCMFSA_2:75
.= ( ( DataPart R9 ) . D49 ) by L560 , FUNCT_1:49
.= ( R10 . D49 ) by L318 , L560 , FUNCT_1:49
.= ( ( Exec (D48 , R10) ) . D49 ) by L554 , SCMFSA_2:75
.= ( ( ( Exec (D48 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) . C116 ) by L559 , FUNCT_1:49;
end;
suppose L564: C116 in ( FinSeq-Locations );

reconsider D50 = C116 as FinSeq-Location by L564 , SCMFSA_2:def 5;
L565: D50 <> C115 by L561 , TARSKI:def 1;
thus L566: ( ( ( Exec (D48 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) . C116 ) = ( ( Exec (D48 , R9) ) . D50 ) by L559 , FUNCT_1:49
.= ( R9 . D50 ) by L554 , L565 , SCMFSA_2:75
.= ( ( DataPart R9 ) . D50 ) by L560 , FUNCT_1:49
.= ( R10 . D50 ) by L318 , L560 , FUNCT_1:49
.= ( ( Exec (D48 , R10) ) . D50 ) by L554 , L565 , SCMFSA_2:75
.= ( ( ( Exec (D48 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) . C116 ) by L559 , FUNCT_1:49;
end;
end;
L568: ( dom ( ( Exec (D48 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) ) = ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) by L319 , RELAT_1:62;
L569: ( ( Exec (D48 , R9) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) = ( ( Exec (D48 , R10) ) | ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) ) by L568 , L555 , L558 , FUNCT_1:2;
L570: C115 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L571: C115 in ( Data-Locations ( SCM+FSA ) ) by L570 , SCMFSA_2:100 , XBOOLE_0:def 3;
L572: ( Data-Locations ( SCM+FSA ) ) = ( ( Data-Locations ( SCM+FSA ) ) \/ { C115 } ) by L571 , ZFMISC_1:40
.= ( ( ( Data-Locations ( SCM+FSA ) ) \ { C115 } ) \/ { C115 } ) by XBOOLE_1:39;
L573: C114 in ( Int-Locations ) by AMI_2:def 16;
L574: C114 in ( Data-Locations ( SCM+FSA ) ) by L573 , SCMFSA_2:100 , XBOOLE_0:def 3;
L575: ( R9 . C114 ) = ( ( DataPart R9 ) . C114 ) by L574 , FUNCT_1:49
.= ( R10 . C114 ) by L318 , L574 , FUNCT_1:49;
L576: ( ( Exec (D48 , R9) ) | { C115 } ) = ( ( Exec (D48 , R10) ) | { C115 } ) by L575 , L320 , L557 , L556 , GRFUNC_1:29;
thus L577: thesis by L576 , L572 , L569 , RELAT_1:150;
end;
end;
L579:
now
set D51 = ( Data-Locations ( SCM+FSA ) );
let C117 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C118 being (State of ( SCM+FSA ));
let C119 being (Instruction-Sequence of ( SCM+FSA ));
set D52 = ( IExec (C117 , C119 , C118) );
L580:
now
L581: ( dom ( Initialized D52 ) ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
L582: (the carrier of ( SCM+FSA )) = ( { ( IC ( SCM+FSA ) ) } \/ ( Data-Locations ( SCM+FSA ) ) ) by STRUCT_0:4;
L583: ( dom D52 ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2;
thus L584: ( dom ( DataPart ( Initialized D52 ) ) ) = ( ( dom D52 ) /\ D51 ) by L583 , L581 , RELAT_1:61;
L585: ( dom ( DataPart ( Initialized D52 ) ) ) = ( Data-Locations ( SCM+FSA ) ) by L584 , L583 , L582 , XBOOLE_1:21;
let R1 being set;
assume L586: R1 in ( dom ( DataPart ( Initialized D52 ) ) );
per cases  by L586 , L585 , SCMFSA_2:100 , XBOOLE_0:def 3;
suppose L587: R1 in ( Int-Locations );

reconsider D53 = R1 as Int-Location by L587 , AMI_2:def 16;
per cases ;
suppose L588: D53 is  read-write;

thus L589: ( ( DataPart ( Initialized D52 ) ) . R1 ) = ( ( Initialized D52 ) . R1 ) by L586 , L585 , FUNCT_1:49
.= ( D52 . R1 ) by L588 , SCMFSA_M:37;
end;
suppose L590: D53 is  read-only;

L591: D53 = ( intloc ( 0 ) ) by L590 , SCMFSA_M:def 2;
thus L592: ( ( DataPart ( Initialized D52 ) ) . R1 ) = ( ( Initialized D52 ) . D53 ) by L586 , L585 , FUNCT_1:49
.= 1 by L591 , SCMFSA_M:9
.= ( D52 . R1 ) by L591 , SCMFSA6B:11;
end;
end;
suppose L594: R1 in ( FinSeq-Locations );

reconsider D54 = R1 as FinSeq-Location by L594 , SCMFSA_2:def 5;
thus L595: ( ( DataPart ( Initialized D52 ) ) . R1 ) = ( ( Initialized D52 ) . D54 ) by L586 , L585 , FUNCT_1:49
.= ( D52 . R1 ) by SCMFSA_M:37;
end;
end;
thus L597: ( DataPart ( Initialized D52 ) ) = ( DataPart D52 ) by L580 , FUNCT_1:46;
end;
theorem
L598: (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B24 being  parahalting (Instruction of ( SCM+FSA )) holds ( Exec (B24 , ( Initialized R8 )) ) = ( IExec (( Macro B24 ) , R11 , R8) ))))
proof
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C120 being  parahalting (Instruction of ( SCM+FSA ));
set D55 = ( Macro C120 );
set D56 = ( R8 +* ( Initialize ( ( intloc ( 0 ) ) .--> 1 ) ) );
set D57 = ( R11 +* D55 );
L599: D55 c= D57 by FUNCT_4:25;
set D58 = ( Initialized R8 );
set D59 = ( IC ( Comput (( R11 +* D55 ) , D56 , 1) ) );
reconsider D60 = D55 as  parahalting (Program of ( SCM+FSA ));
L600: D59 in ( dom D60 ) by L599 , AMISTD_1:def 10;
L601: 1 in ( dom D60 ) by COMPOS_1:60;
L602: ( 0 ) in ( dom D60 ) by COMPOS_1:60;
L603: ( D60 . ( 0 ) ) = C120 by COMPOS_1:58;
L604: ( IC D56 ) = ( 0 ) by MEMSTR_0:def 11;
L605: ( Comput (( R11 +* D60 ) , D56 , ( ( 0 ) + 1 )) ) = ( Following (( R11 +* D60 ) , ( Comput (( R11 +* D60 ) , D56 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (( R11 +* D60 ) , D56) )
.= ( Exec (( D57 . ( 0 ) ) , D56) ) by L604 , PBOOLE:143
.= ( Exec (C120 , D56) ) by L603 , L599 , L602 , GRFUNC_1:2;
per cases  by L600 , COMPOS_1:60;
suppose L606: D59 = ( 0 );

L607: ( CurInstr (( R11 +* D60 ) , ( Comput (( R11 +* D60 ) , D56 , 1) )) ) = ( ( R11 +* D60 ) . ( 0 ) ) by L606 , PBOOLE:143
.= C120 by L603 , L602 , FUNCT_4:13;
L608: ( succ ( IC D56 ) ) = 1 by L604;
L609: ( InsCode C120 ) in { ( 0 ) , 6 , 7 , 8 } by L608 , L605 , L606 , SCMFSA6A:3;
thus L610:now
per cases  by L609 , ENUMSET1:def 2;
suppose L611: ( InsCode C120 ) = ( 0 );

L612: C120 = ( halt ( SCM+FSA ) ) by L611 , SCMFSA_2:95;
L613: ( R11 +* D60 ) halts_on D56 by L612 , L607 , EXTPRO_1:29;
thus L614: thesis by L613 , L605 , L607 , L612 , EXTPRO_1:def 9;
end;
suppose L615: (( InsCode C120 ) = 6 or ( InsCode C120 ) = 7 or ( InsCode C120 ) = 8);

L616:
now
let R3 being Int-Location;
per cases  by L615;
suppose L617: ( InsCode C120 ) = 6;

L618: (ex R6 being (Element of ( NAT )) st C120 = ( goto R6 )) by L617 , SCMFSA_2:35;
thus L619: ( D56 . R3 ) = ( ( Exec (C120 , D56) ) . R3 ) by L618 , SCMFSA_2:69;
end;
suppose L620: ( InsCode C120 ) = 7;

L621: (ex R6 being (Element of ( NAT )) st (ex R4 being Int-Location st C120 = ( R4 =0_goto R6 ))) by L620 , SCMFSA_2:36;
thus L622: ( D56 . R3 ) = ( ( Exec (C120 , D56) ) . R3 ) by L621 , SCMFSA_2:70;
end;
suppose L623: ( InsCode C120 ) = 8;

L624: (ex R6 being (Element of ( NAT )) st (ex R4 being Int-Location st C120 = ( R4 >0_goto R6 ))) by L623 , SCMFSA_2:37;
thus L625: ( D56 . R3 ) = ( ( Exec (C120 , D56) ) . R3 ) by L624 , SCMFSA_2:71;
end;
end;
L627:
now
let R5 being FinSeq-Location;
per cases  by L615;
suppose L628: ( InsCode C120 ) = 6;

L629: (ex R6 being (Element of ( NAT )) st C120 = ( goto R6 )) by L628 , SCMFSA_2:35;
thus L630: ( D56 . R5 ) = ( ( Exec (C120 , D56) ) . R5 ) by L629 , SCMFSA_2:69;
end;
suppose L631: ( InsCode C120 ) = 7;

L632: (ex R6 being (Element of ( NAT )) st (ex R3 being Int-Location st C120 = ( R3 =0_goto R6 ))) by L631 , SCMFSA_2:36;
thus L633: ( D56 . R5 ) = ( ( Exec (C120 , D56) ) . R5 ) by L632 , SCMFSA_2:70;
end;
suppose L634: ( InsCode C120 ) = 8;

L635: (ex R6 being (Element of ( NAT )) st (ex R3 being Int-Location st C120 = ( R3 >0_goto R6 ))) by L634 , SCMFSA_2:37;
thus L636: ( D56 . R5 ) = ( ( Exec (C120 , D56) ) . R5 ) by L635 , SCMFSA_2:71;
end;
end;
L638: ( Following (( R11 +* D60 ) , D56) ) = ( Following (( R11 +* D60 ) , ( Comput (( R11 +* D60 ) , D56 , ( 0 )) )) )
.= ( Exec (C120 , D56) ) by L605 , EXTPRO_1:3;
L639: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L640: (for B25 being (Element of ( NAT )) holds ( CurInstr (( R11 +* D60 ) , ( Comput (( R11 +* D60 ) , D56 , B25) )) ) <> ( halt ( SCM+FSA ) )) by L607 , L615 , L616 , L627 , L605 , L606 , L604 , L638 , AMISTD_2:11 , SCMFSA_2:104 , L639;
L641: (not ( R11 +* D60 ) halts_on D56) by L640 , EXTPRO_1:29;
L642: D60 c= ( R11 +* D60 ) by FUNCT_4:25;
thus L643: ( Exec (C120 , ( Initialized R8 )) ) = ( IExec (( Macro C120 ) , R11 , R8) ) by L642 , L641 , AMISTD_1:def 11;
end;
end;
end;
suppose L611: D59 = 1;

L612: ( D60 . 1 ) = ( halt ( SCM+FSA ) ) by COMPOS_1:59;
L613: ( CurInstr (( R11 +* D60 ) , ( Comput (( R11 +* D60 ) , D56 , 1) )) ) = ( ( R11 +* D60 ) . 1 ) by L611 , PBOOLE:143
.= ( halt ( SCM+FSA ) ) by L612 , L599 , L601 , GRFUNC_1:2;
L614: ( R11 +* D60 ) halts_on D56 by L613 , EXTPRO_1:29;
thus L615: thesis by L614 , L605 , L613 , EXTPRO_1:def 9;
end;
end;
theorem
L617: (for R3 being Int-Location holds (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B26 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B27 being  parahalting (Instruction of ( SCM+FSA )) holds ( ( IExec (( B26 ";" B27 ) , R11 , R8) ) . R3 ) = ( ( Exec (B27 , ( IExec (B26 , R11 , R8) )) ) . R3 ))))))
proof
let R3 being Int-Location;
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C121 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C122 being  parahalting (Instruction of ( SCM+FSA ));
set D61 = ( Macro C122 );
set D62 = ( Start-At (( ( IC ( IExec (D61 , R11 , ( IExec (C121 , R11 , R8) )) ) ) + ( card C121 ) ) , ( SCM+FSA )) );
L618: (not R3 in ( dom D62 )) by SCMFSA_2:102;
L619: ( DataPart ( Initialized ( IExec (C121 , R11 , R8) ) ) ) = ( DataPart ( IExec (C121 , R11 , R8) ) ) by L579;
L620: R3 in ( Int-Locations ) by AMI_2:def 16;
L621: R3 in ( Data-Locations ( SCM+FSA ) ) by L620 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L622: ( ( IExec (( C121 ";" C122 ) , R11 , R8) ) . R3 ) = ( ( IncIC (( IExec (D61 , R11 , ( IExec (C121 , R11 , R8) )) ) , ( card C121 )) ) . R3 ) by SCMFSA6B:20
.= ( ( IExec (D61 , R11 , ( IExec (C121 , R11 , R8) )) ) . R3 ) by L618 , FUNCT_4:11
.= ( ( Exec (C122 , ( Initialized ( IExec (C121 , R11 , R8) ) )) ) . R3 ) by L598
.= ( ( DataPart ( Exec (C122 , ( Initialized ( IExec (C121 , R11 , R8) ) )) ) ) . R3 ) by L621 , FUNCT_1:49
.= ( ( DataPart ( Exec (C122 , ( IExec (C121 , R11 , R8) )) ) ) . R3 ) by L619 , L317
.= ( ( Exec (C122 , ( IExec (C121 , R11 , R8) )) ) . R3 ) by L621 , FUNCT_1:49;
end;
theorem
L623: (for R5 being FinSeq-Location holds (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B28 being  keeping_0  parahalting (Program of ( SCM+FSA )) holds (for B29 being  parahalting (Instruction of ( SCM+FSA )) holds ( ( IExec (( B28 ";" B29 ) , R11 , R8) ) . R5 ) = ( ( Exec (B29 , ( IExec (B28 , R11 , R8) )) ) . R5 ))))))
proof
let R5 being FinSeq-Location;
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C123 being  keeping_0  parahalting (Program of ( SCM+FSA ));
let C124 being  parahalting (Instruction of ( SCM+FSA ));
set D63 = ( Macro C124 );
set D64 = ( Start-At (( ( IC ( IExec (D63 , R11 , ( IExec (C123 , R11 , R8) )) ) ) + ( card C123 ) ) , ( SCM+FSA )) );
L624: (not R5 in ( dom D64 )) by SCMFSA_2:103;
L625: ( DataPart ( Initialized ( IExec (C123 , R11 , R8) ) ) ) = ( DataPart ( IExec (C123 , R11 , R8) ) ) by L579;
L626: R5 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L627: R5 in ( Data-Locations ( SCM+FSA ) ) by L626 , SCMFSA_2:100 , XBOOLE_0:def 3;
thus L628: ( ( IExec (( C123 ";" C124 ) , R11 , R8) ) . R5 ) = ( ( IncIC (( IExec (D63 , R11 , ( IExec (C123 , R11 , R8) )) ) , ( card C123 )) ) . R5 ) by SCMFSA6B:20
.= ( ( IExec (D63 , R11 , ( IExec (C123 , R11 , R8) )) ) . R5 ) by L624 , FUNCT_4:11
.= ( ( Exec (C124 , ( Initialized ( IExec (C123 , R11 , R8) ) )) ) . R5 ) by L598
.= ( ( DataPart ( Exec (C124 , ( Initialized ( IExec (C123 , R11 , R8) ) )) ) ) . R5 ) by L627 , FUNCT_1:49
.= ( ( DataPart ( Exec (C124 , ( IExec (C123 , R11 , R8) )) ) ) . R5 ) by L625 , L317
.= ( ( Exec (C124 , ( IExec (C123 , R11 , R8) )) ) . R5 ) by L627 , FUNCT_1:49;
end;
theorem
L629: (for R3 being Int-Location holds (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B30 being  keeping_0  parahalting (Instruction of ( SCM+FSA )) holds (for B31 being  parahalting (Instruction of ( SCM+FSA )) holds ( ( IExec (( B30 ";" B31 ) , R11 , R8) ) . R3 ) = ( ( Exec (B31 , ( Exec (B30 , ( Initialized R8 )) )) ) . R3 ))))))
proof
let R3 being Int-Location;
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C125 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C126 being  parahalting (Instruction of ( SCM+FSA ));
set D65 = ( Macro C125 );
thus L630: ( ( IExec (( C125 ";" C126 ) , R11 , R8) ) . R3 ) = ( ( IExec (( D65 ";" C126 ) , R11 , R8) ) . R3 )
.= ( ( Exec (C126 , ( IExec (D65 , R11 , R8) )) ) . R3 ) by L617
.= ( ( Exec (C126 , ( Exec (C125 , ( Initialized R8 )) )) ) . R3 ) by L598;
end;
theorem
L631: (for R5 being FinSeq-Location holds (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B32 being  keeping_0  parahalting (Instruction of ( SCM+FSA )) holds (for B33 being  parahalting (Instruction of ( SCM+FSA )) holds ( ( IExec (( B32 ";" B33 ) , R11 , R8) ) . R5 ) = ( ( Exec (B33 , ( Exec (B32 , ( Initialized R8 )) )) ) . R5 ))))))
proof
let R5 being FinSeq-Location;
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C127 being  keeping_0  parahalting (Instruction of ( SCM+FSA ));
let C128 being  parahalting (Instruction of ( SCM+FSA ));
set D66 = ( Macro C127 );
thus L632: ( ( IExec (( C127 ";" C128 ) , R11 , R8) ) . R5 ) = ( ( IExec (( D66 ";" C128 ) , R11 , R8) ) . R5 )
.= ( ( Exec (C128 , ( IExec (D66 , R11 , R8) )) ) . R5 ) by L623
.= ( ( Exec (C128 , ( Exec (C127 , ( Initialized R8 )) )) ) . R5 ) by L598;
end;
begin
definition
let C129 , C130 being Int-Location;
func swap (C129 , C130) -> (Program of ( SCM+FSA )) equals 
( ( ( ( FirstNotUsed ( Macro ( C129 := C130 ) ) ) := C129 ) ";" ( C129 := C130 ) ) ";" ( C130 := ( FirstNotUsed ( Macro ( C129 := C130 ) ) ) ) );
correctness;
end;
registration
let C131 , C132 being Int-Location;
cluster ( swap (C131 , C132) ) ->  parahalting;
coherence;
end;
registration
let C133 , C134 being  read-write Int-Location;
cluster ( swap (C133 , C134) ) ->  keeping_0;
coherence;
end;
theorem
L636: (for R8 being (State of ( SCM+FSA )) holds (for R11 being (Instruction-Sequence of ( SCM+FSA )) holds (for B34 , B35 being  read-write Int-Location holds (( ( IExec (( swap (B34 , B35) ) , R11 , R8) ) . B34 ) = ( R8 . B35 ) & ( ( IExec (( swap (B34 , B35) ) , R11 , R8) ) . B35 ) = ( R8 . B34 )))))
proof
let R8 being (State of ( SCM+FSA ));
let R11 being (Instruction-Sequence of ( SCM+FSA ));
let C135 , C136 being  read-write Int-Location;
set D67 = ( ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) := C135 );
set D68 = ( C135 := C136 );
set D69 = ( C136 := ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) );
set D70 = ( D67 ";" D68 );
L637: ( UsedIntLoc ( Macro ( C135 := C136 ) ) ) = ( UsedIntLoc ( C135 := C136 ) ) by SF_MASTR:28;
L638: ( UsedIntLoc ( Macro ( C135 := C136 ) ) ) = { C135 , C136 } by L637 , SF_MASTR:14;
L639: (not ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) in { C135 , C136 }) by L638 , SF_MASTR:50;
L640: ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) <> C135 by L639 , TARSKI:def 2;
L641: ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) <> C136 by L639 , TARSKI:def 2;
thus L642:now
per cases ;
suppose L643: C135 <> C136;

thus L644: ( ( IExec (( swap (C135 , C136) ) , R11 , R8) ) . C135 ) = ( ( Exec (D69 , ( IExec (D70 , R11 , R8) )) ) . C135 ) by L617
.= ( ( IExec (D70 , R11 , R8) ) . C135 ) by L643 , SCMFSA_2:63
.= ( ( Exec (D68 , ( Exec (D67 , ( Initialized R8 )) )) ) . C135 ) by L629
.= ( ( Exec (D67 , ( Initialized R8 )) ) . C136 ) by SCMFSA_2:63
.= ( ( Initialized R8 ) . C136 ) by L641 , SCMFSA_2:63
.= ( R8 . C136 ) by SCMFSA_M:37;
end;
suppose L645: C135 = C136;

thus L646: ( ( IExec (( swap (C135 , C136) ) , R11 , R8) ) . C135 ) = ( ( Exec (D69 , ( IExec (D70 , R11 , R8) )) ) . C135 ) by L617
.= ( ( IExec (D70 , R11 , R8) ) . ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) ) by L645 , SCMFSA_2:63
.= ( ( Exec (D68 , ( Exec (D67 , ( Initialized R8 )) )) ) . ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) ) by L629
.= ( ( Exec (D67 , ( Initialized R8 )) ) . ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) ) by L640 , SCMFSA_2:63
.= ( ( Initialized R8 ) . C135 ) by SCMFSA_2:63
.= ( R8 . C136 ) by L645 , SCMFSA_M:37;
end;
end;
thus L648: ( ( IExec (( swap (C135 , C136) ) , R11 , R8) ) . C136 ) = ( ( Exec (D69 , ( IExec (D70 , R11 , R8) )) ) . C136 ) by L617
.= ( ( IExec (D70 , R11 , R8) ) . ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) ) by SCMFSA_2:63
.= ( ( Exec (D68 , ( Exec (D67 , ( Initialized R8 )) )) ) . ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) ) by L629
.= ( ( Exec (D67 , ( Initialized R8 )) ) . ( FirstNotUsed ( Macro ( C135 := C136 ) ) ) ) by L640 , SCMFSA_2:63
.= ( ( Initialized R8 ) . C135 ) by SCMFSA_2:63
.= ( R8 . C135 ) by SCMFSA_M:37;
end;
theorem
L649: (for R3 being Int-Location holds (for R4 being Int-Location holds ( UsedInt*Loc ( swap (R3 , R4) ) ) = ( {} )))
proof
let R3 being Int-Location;
let R4 being Int-Location;
set D71 = ( ( FirstNotUsed ( Macro ( R3 := R4 ) ) ) := R3 );
set D72 = ( R3 := R4 );
set D73 = ( R4 := ( FirstNotUsed ( Macro ( R3 := R4 ) ) ) );
thus L650: ( UsedInt*Loc ( swap (R3 , R4) ) ) = ( ( UsedInt*Loc ( D71 ";" D72 ) ) \/ ( UsedInt*Loc D73 ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc ( D71 ";" D72 ) ) \/ ( {} ) ) by SF_MASTR:32
.= ( ( UsedInt*Loc D71 ) \/ ( UsedInt*Loc D72 ) ) by SF_MASTR:47
.= ( ( UsedInt*Loc D71 ) \/ ( {} ) ) by SF_MASTR:32
.= ( {} ) by SF_MASTR:32;
end;
