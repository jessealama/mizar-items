:: The canonical formulae
::  by Andrzej Trybulec
::
:: Received July 4, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies INT_1, ABIAN, ARYTM_1, ZFMISC_1, FUNCT_1, RELAT_1, TARSKI,
      FUNCOP_1, FUNCT_2, FUNCT_6, XBOOLE_0, PBOOLE, SUBSET_1, NUMBERS, NAT_1,
      HILBERT1, CARD_1, FUNCT_3, CARD_3, MCART_1, PARTFUN1, FINSEQ_4, XBOOLEAN,
      QC_LANG1, HILBERT2, FUNCT_5, ARYTM_3, FUNCT_4, XXREAL_0, HILBERT3,
      XCMPLX_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, INT_1,
      RELAT_1, FUNCT_1, PBOOLE, CARD_3, ABIAN, PARTFUN1, FUNCT_2, BINOP_1,
      ORDINAL1, XXREAL_0, FUNCT_3, FUNCOP_1, FUNCT_4, FUNCT_5, FUNCT_6,
      PRALG_1, PRALG_2, MSUALG_3, HILBERT1, HILBERT2;
 constructors XXREAL_0, NAT_D, ABIAN, CAT_2, PRALG_1, PRALG_2, MSUALG_3,
      HILBERT2, RELSET_1, FUNCT_5;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, PARTFUN1,
      FUNCT_2, FUNCOP_1, FUNCT_4, NUMBERS, XREAL_0, INT_1, PBOOLE, ABIAN,
      HILBERT1, RELSET_1, ZFMISC_1, MSSUBFAM;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions PBOOLE, FUNCT_1, FUNCT_2, TARSKI, HILBERT1, ABIAN, FUNCOP_1,
      XBOOLE_0, BINOP_1, SUBSET_1;
 theorems PBOOLE, ZFMISC_1, MSUALG_3, FUNCT_2, RELAT_1, RELSET_1, FUNCT_1,
      FUNCT_3, TARSKI, FUNCOP_1, PARTFUN2, PRALG_2, CARD_3, FUNCT_6, MSSUBFAM,
      FUNCT_5, FUNCTOR0, CAT_2, HILBERT1, FUNCT_4, INT_1, TOPREAL6, PRALG_1,
      XBOOLE_0, XBOOLE_1, XCMPLX_1, ABIAN, XREAL_1, XXREAL_0, CARD_1, PARTFUN1,
      XTUPLE_0;
 schemes HILBERT2, FUNCT_2;

begin
registration
let C1 , C2 being non  zero Nat;
cluster ( (( 0 ) , C2) --> (C1 , ( 0 )) ) ->  one-to-one;
coherence
proof
set D1 = ( (( 0 ) , C2) --> (C1 , ( 0 )) );
let C3 , C4 being set;
assume that
L1: C3 in ( dom D1 )
and
L2: C4 in ( dom D1 );
L3: ( dom D1 ) = { ( 0 ) , C2 } by FUNCT_4:62;
L4: (C4 = ( 0 ) or C4 = C2) by L3 , L2 , TARSKI:def 2;
L5: ( D1 . ( 0 ) ) = C1 by FUNCT_4:63;
L6: (C3 = ( 0 ) or C3 = C2) by L3 , L1 , TARSKI:def 2;
thus L7: thesis by L6 , L4 , L5 , FUNCT_4:63;
end;
cluster ( (C2 , ( 0 )) --> (( 0 ) , C1) ) ->  one-to-one;
coherence
proof
set D2 = ( (C2 , ( 0 )) --> (( 0 ) , C1) );
let C5 , C6 being set;
assume that
L8: C5 in ( dom D2 )
and
L9: C6 in ( dom D2 );
L10: ( dom D2 ) = { ( 0 ) , C2 } by FUNCT_4:62;
L11: (C6 = ( 0 ) or C6 = C2) by L10 , L9 , TARSKI:def 2;
L12: ( D2 . ( 0 ) ) = C1 by FUNCT_4:63;
L13: (C5 = ( 0 ) or C5 = C2) by L10 , L8 , TARSKI:def 2;
thus L14: thesis by L13 , L11 , L12 , FUNCT_4:63;
end;
end;
theorem
L16: (for B1 being Integer holds (B1 is  even iff ( B1 - 1 ) is  odd));
theorem
L17: (for B2 being Integer holds (B2 is  odd iff ( B2 - 1 ) is  even));
theorem
L18: (for B3 being  trivial set holds (for B4 being set holds (B4 in B3 implies (for B5 being (Function of B3 , B3) holds B4 is_a_fixpoint_of B5))))
proof
let C7 being  trivial set;
let C8 being set;
assume L19: C8 in C7;
consider C9 being set such that L20: C7 = { C9 } by L19 , ZFMISC_1:131;
let C10 being (Function of C7 , C7);
thus L21: C8 in ( dom C10 ) by L19 , FUNCT_2:52;
L22: ( C10 . C8 ) in ( rng C10 ) by L21 , FUNCT_1:def 3;
L23: ( rng C10 ) c= C7 by RELAT_1:def 19;
thus L24: C8 = C9 by L19 , L20 , TARSKI:def 1
.= ( C10 . C8 ) by L20 , L22 , L23 , TARSKI:def 1;
end;
theorem
L25: (for B6 being  Function-yielding Function holds ( SubFuncs ( rng B6 ) ) = ( rng B6 ))
proof
let C11 being  Function-yielding Function;
L26: (for B7 being set holds (B7 in ( rng C11 ) implies B7 is Function))
proof
let C12 being set;
assume L27: C12 in ( rng C11 );
L28: (ex B8 being set st (B8 in ( dom C11 ) & C12 = ( C11 . B8 ))) by L27 , FUNCT_1:def 3;
thus L29: thesis by L28;
end;
L30: (for B9 being set holds (B9 in ( rng C11 ) iff (B9 in ( rng C11 ) & B9 is Function))) by L26;
thus L31: thesis by L30 , FUNCT_6:def 1;
end;
theorem
L32: (for B10 , B11 , B12 being set holds (for B13 being Function holds ((B12 in B10 & B13 in ( Funcs (B10 , B11) )) implies ( B13 . B12 ) in B11)))
proof
let C13 , C14 , C15 being set;
let C16 being Function;
assume that
L33: C15 in C13;
assume L34: C16 in ( Funcs (C13 , C14) );
L35: C16 is (Function of C13 , C14) by L34 , FUNCT_2:66;
L36: (C14 = ( {} ) implies C13 = ( {} )) by L34;
thus L37: thesis by L36 , L33 , L35 , FUNCT_2:5;
end;
theorem
L38: (for B14 , B15 , B16 being set holds ((B16 = ( {} ) implies (B15 = ( {} ) or B14 = ( {} ))) implies (for B17 being (Function of B14 , ( Funcs (B15 , B16) )) holds ( doms B17 ) = ( B14 --> B15 ))))
proof
let C17 , C18 , C19 being set;
assume L39: (C19 = ( {} ) implies (C18 = ( {} ) or C17 = ( {} )));
L40: (( Funcs (C18 , C19) ) = ( {} ) implies C17 = ( {} )) by L39 , FUNCT_2:8;
let C20 being (Function of C17 , ( Funcs (C18 , C19) ));
reconsider D3 = C20 as (ManySortedFunction of C17) by L40;
L41:
now
let C21 being set;
assume L42: C21 in C17;
L43: ( D3 . C21 ) in ( Funcs (C18 , C19) ) by L42 , L40 , FUNCT_2:5;
thus L44: ( ( doms D3 ) . C21 ) = ( dom ( D3 . C21 ) ) by L42 , MSSUBFAM:14
.= C18 by L43 , FUNCT_2:92
.= ( ( C17 --> C18 ) . C21 ) by L42 , FUNCOP_1:7;
end;
thus L45: thesis by L41 , PBOOLE:3;
end;
theorem
L46: (for B18 being set holds ( ( {} ) . B18 ) = ( {} ));
theorem
L47: (for B19 being set holds (for B20 being (Subset of B19) holds ( ( (( 0 ) , 1) --> (1 , ( 0 )) ) * ( chi (B20 , B19) ) ) = ( chi (( B20 ` ) , B19) )))
proof
let C22 being set;
let C23 being (Subset of C22);
set D4 = ( ( (( 0 ) , 1) --> (1 , ( 0 )) ) * ( chi (C23 , C22) ) );
L48: ( dom ( chi (C23 , C22) ) ) = C22 by FUNCT_3:def 3;
L49: (for B21 being set holds (B21 in C22 implies ((B21 in ( C23 ` ) implies ( D4 . B21 ) = 1) & ((not B21 in ( C23 ` )) implies ( D4 . B21 ) = ( 0 )))))
proof
let C24 being set;
assume that
L50: C24 in C22;
thus L51: (C24 in ( C23 ` ) implies ( D4 . C24 ) = 1)
proof
assume L52: C24 in ( C23 ` );
L53: (not C24 in C23) by L52 , XBOOLE_0:def 5;
L54: ( ( chi (C23 , C22) ) . C24 ) = ( 0 ) by L53 , L50 , FUNCT_3:def 3;
L55: ( D4 . C24 ) = ( ( (( 0 ) , 1) --> (1 , ( 0 )) ) . ( 0 ) ) by L54 , L48 , L50 , FUNCT_1:13;
thus L56: thesis by L55 , FUNCT_4:63;
end;

assume L57: (not C24 in ( C23 ` ));
L58: C24 in C23 by L57 , L50 , XBOOLE_0:def 5;
L59: ( ( chi (C23 , C22) ) . C24 ) = 1 by L58 , FUNCT_3:def 3;
L60: ( D4 . C24 ) = ( ( (( 0 ) , 1) --> (1 , ( 0 )) ) . 1 ) by L59 , L48 , L50 , FUNCT_1:13;
thus L61: thesis by L60 , FUNCT_4:63;
end;
L62: ( dom ( (( 0 ) , 1) --> (1 , ( 0 )) ) ) = { ( 0 ) , 1 } by FUNCT_4:62;
L63: ( rng ( chi (C23 , C22) ) ) c= ( dom ( (( 0 ) , 1) --> (1 , ( 0 )) ) ) by L62 , FUNCT_3:39;
L64: ( dom D4 ) = C22 by L63 , L48 , RELAT_1:27;
thus L65: thesis by L64 , L49 , FUNCT_3:def 3;
end;
theorem
L66: (for B22 being set holds (for B23 being (Subset of B22) holds ( ( (( 0 ) , 1) --> (1 , ( 0 )) ) * ( chi (( B23 ` ) , B22) ) ) = ( chi (B23 , B22) )))
proof
let C25 being set;
let C26 being (Subset of C25);
L67: ( ( C26 ` ) ` ) = C26;
thus L68: thesis by L67 , L47;
end;
theorem
L69: (for B24 , B25 , B26 , B27 , B28 , B29 being set holds ((B24 <> B25 & ( (B24 , B25) --> (B26 , B27) ) = ( (B24 , B25) --> (B28 , B29) )) implies (B26 = B28 & B27 = B29)))
proof
let C27 , C28 , C29 , C30 , C31 , C32 being set;
assume that
L70: C27 <> C28
and
L71: ( (C27 , C28) --> (C29 , C30) ) = ( (C27 , C28) --> (C31 , C32) );
thus L72: C29 = ( ( (C27 , C28) --> (C29 , C30) ) . C27 ) by L70 , FUNCT_4:63
.= C31 by L70 , L71 , FUNCT_4:63;
thus L73: C30 = ( ( (C27 , C28) --> (C29 , C30) ) . C28 ) by FUNCT_4:63
.= C32 by L71 , FUNCT_4:63;
end;
theorem
L74: (for B30 , B31 , B32 , B33 , B34 , B35 being set holds ((B30 <> B31 & B32 in B34 & B33 in B35) implies ( (B30 , B31) --> (B32 , B33) ) in ( product ( (B30 , B31) --> (B34 , B35) ) )))
proof
let C33 , C34 , C35 , C36 , C37 , C38 being set;
assume that
L75: C33 <> C34
and
L76: (C35 in C37 & C36 in C38);
L77: ({ C35 } c= C37 & { C36 } c= C38) by L76 , ZFMISC_1:31;
L78: ( product ( (C33 , C34) --> ({ C35 } , { C36 }) ) ) c= ( product ( (C33 , C34) --> (C37 , C38) ) ) by L77 , TOPREAL6:21;
L79: { ( (C33 , C34) --> (C35 , C36) ) } c= ( product ( (C33 , C34) --> (C37 , C38) ) ) by L78 , L75 , CARD_3:47;
thus L80: thesis by L79 , ZFMISC_1:31;
end;
theorem
L81: (for B36 being non  empty set holds (for B37 being (Function of 2 , B36) holds (ex B38 , B39 being (Element of B36) st B37 = ( (( 0 ) , 1) --> (B38 , B39) ))))
proof
let C39 being non  empty set;
let C40 being (Function of 2 , C39);
L82: (( 0 ) in 2 & 1 in 2) by CARD_1:50 , TARSKI:def 2;
reconsider D5 = ( C40 . ( 0 ) ) , D6 = ( C40 . 1 ) as (Element of C39) by L82 , FUNCT_2:5;
take D5;
take D6;
L83: ( dom C40 ) = { ( 0 ) , 1 } by CARD_1:50 , FUNCT_2:def 1;
thus L84: thesis by L83 , FUNCT_4:66;
end;
theorem
L85: (for B40 , B41 , B42 , B43 being set holds (B40 <> B41 implies ( ( (B40 , B41) --> (B42 , B43) ) * ( (B40 , B41) --> (B41 , B40) ) ) = ( (B40 , B41) --> (B43 , B42) )))
proof
let C41 , C42 , C43 , C44 being set;
assume that
L86: C41 <> C42;
set D7 = ( ( (C41 , C42) --> (C43 , C44) ) * ( (C41 , C42) --> (C42 , C41) ) );
L87: ( dom ( (C41 , C42) --> (C42 , C41) ) ) = { C41 , C42 } by FUNCT_4:62;
L88: C42 in { C41 , C42 } by TARSKI:def 2;
L89: ( D7 . C42 ) = ( ( (C41 , C42) --> (C43 , C44) ) . ( ( (C41 , C42) --> (C42 , C41) ) . C42 ) ) by L88 , L87 , FUNCT_1:13
.= ( ( (C41 , C42) --> (C43 , C44) ) . C41 ) by FUNCT_4:63
.= C43 by L86 , FUNCT_4:63;
L90: C41 in { C41 , C42 } by TARSKI:def 2;
L91: ( D7 . C41 ) = ( ( (C41 , C42) --> (C43 , C44) ) . ( ( (C41 , C42) --> (C42 , C41) ) . C41 ) ) by L90 , L87 , FUNCT_1:13
.= ( ( (C41 , C42) --> (C43 , C44) ) . C42 ) by L86 , FUNCT_4:63
.= C44 by FUNCT_4:63;
L92: ( rng ( (C41 , C42) --> (C42 , C41) ) ) = { C41 , C42 } by L86 , FUNCT_4:64
.= ( dom ( (C41 , C42) --> (C43 , C44) ) ) by FUNCT_4:62;
L93: ( dom D7 ) = { C41 , C42 } by L92 , L87 , RELAT_1:27;
thus L94: thesis by L93 , L91 , L89 , FUNCT_4:66;
end;
theorem
L95: (for B44 , B45 , B46 , B47 being set holds (for B48 being Function holds ((B44 <> B45 & B46 in ( dom B48 ) & B47 in ( dom B48 )) implies ( B48 * ( (B44 , B45) --> (B46 , B47) ) ) = ( (B44 , B45) --> (( B48 . B46 ) , ( B48 . B47 )) ))))
proof
let C45 , C46 , C47 , C48 being set;
let C49 being Function;
assume that
L96: C45 <> C46
and
L97: (C47 in ( dom C49 ) & C48 in ( dom C49 ));
L98: ( dom ( (C45 , C46) --> (C47 , C48) ) ) = { C45 , C46 } by FUNCT_4:62;
L99: C45 in ( dom ( (C45 , C46) --> (C47 , C48) ) ) by L98 , TARSKI:def 2;
L100: ( ( C49 * ( (C45 , C46) --> (C47 , C48) ) ) . C45 ) = ( C49 . ( ( (C45 , C46) --> (C47 , C48) ) . C45 ) ) by L99 , FUNCT_1:13
.= ( C49 . C47 ) by L96 , FUNCT_4:63;
L101: C46 in ( dom ( (C45 , C46) --> (C47 , C48) ) ) by L98 , TARSKI:def 2;
L102: ( ( C49 * ( (C45 , C46) --> (C47 , C48) ) ) . C46 ) = ( C49 . ( ( (C45 , C46) --> (C47 , C48) ) . C46 ) ) by L101 , FUNCT_1:13
.= ( C49 . C48 ) by FUNCT_4:63;
L103: ( rng ( (C45 , C46) --> (C47 , C48) ) ) c= { C47 , C48 } by FUNCT_4:62;
L104: { C47 , C48 } c= ( dom C49 ) by L97 , ZFMISC_1:32;
L105: ( dom ( C49 * ( (C45 , C46) --> (C47 , C48) ) ) ) = { C45 , C46 } by L104 , L98 , L103 , RELAT_1:27 , XBOOLE_1:1;
thus L106: thesis by L105 , L100 , L102 , FUNCT_4:66;
end;
theorem
L107: ( (( 0 ) , 1) --> (1 , ( 0 )) ) is (Permutation of 2)
proof
set D8 = ( (( 0 ) , 1) --> (1 , ( 0 )) );
L108: ( rng D8 ) = 2 by CARD_1:50 , FUNCT_4:64;
L109: ( dom D8 ) = 2 by CARD_1:50 , FUNCT_4:62;
L110: D8 is (Function of 2 , 2) by L109 , L108 , FUNCT_2:def 1 , RELSET_1:4;
thus L111: thesis by L110 , L108 , FUNCT_2:57;
end;
begin
registration
let C50 , C51 being  one-to-one Function;
cluster [: C50 , C51 :] ->  one-to-one;
coherence
proof
let C52 , C53 being set;
assume that
L112: C52 in ( dom [: C50 , C51 :] )
and
L113: C53 in ( dom [: C50 , C51 :] )
and
L114: ( [: C50 , C51 :] . C52 ) = ( [: C50 , C51 :] . C53 );
L115: ( dom [: C50 , C51 :] ) = [: ( dom C50 ) , ( dom C51 ) :] by FUNCT_3:def 8;
consider C54 , C55 being set such that L116: C54 in ( dom C50 ) and L117: C55 in ( dom C51 ) and L118: C52 = [ C54 , C55 ] by L115 , L112 , ZFMISC_1:def 2;
L119: ( [: C50 , C51 :] . (C54 , C55) ) = [ ( C50 . C54 ) , ( C51 . C55 ) ] by L116 , L117 , FUNCT_3:def 8;
consider C56 , C57 being set such that L120: C56 in ( dom C50 ) and L121: C57 in ( dom C51 ) and L122: C53 = [ C56 , C57 ] by L113 , L115 , ZFMISC_1:def 2;
L123: ( [: C50 , C51 :] . (C56 , C57) ) = [ ( C50 . C56 ) , ( C51 . C57 ) ] by L120 , L121 , FUNCT_3:def 8;
L124: ( C50 . C54 ) = ( C50 . C56 ) by L123 , L114 , L118 , L122 , L119 , XTUPLE_0:1;
L125: C54 = C56 by L124 , L116 , L120 , FUNCT_1:def 4;
L126: ( C51 . C55 ) = ( C51 . C57 ) by L114 , L118 , L122 , L119 , L123 , XTUPLE_0:1;
thus L127: thesis by L126 , L117 , L118 , L121 , L122 , L125 , FUNCT_1:def 4;
end;
end;
theorem
L129: (for B49 , B50 being non  empty set holds (for B51 , B52 being set holds (for B53 being (Function of B51 , B49) holds (for B54 being (Function of B52 , B50) holds ( ( pr1 (B49 , B50) ) * [: B53 , B54 :] ) = ( B53 * ( pr1 (B51 , B52) ) )))))
proof
let C58 , C59 being non  empty set;
let C60 , C61 being set;
let C62 being (Function of C60 , C58);
let C63 being (Function of C61 , C59);
L130: (C60 = ( {} ) implies (C58 = ( {} ) or [: C60 , C61 :] = ( {} )));
reconsider D9 = ( C62 * ( pr1 (C60 , C61) ) ) as (Function of [: C60 , C61 :] , C58) by L130;
L131: (C61 = ( {} ) implies (C58 = ( {} ) or [: C60 , C61 :] = ( {} )));
reconsider D10 = ( C63 * ( pr2 (C60 , C61) ) ) as (Function of [: C60 , C61 :] , C59) by L131;
thus L132: ( ( pr1 (C58 , C59) ) * [: C62 , C63 :] ) = ( ( pr1 (C58 , C59) ) * <: D9 , D10 :> ) by FUNCT_3:77
.= ( C62 * ( pr1 (C60 , C61) ) ) by FUNCT_3:62;
end;
theorem
L133: (for B55 , B56 being non  empty set holds (for B57 , B58 being set holds (for B59 being (Function of B57 , B55) holds (for B60 being (Function of B58 , B56) holds ( ( pr2 (B55 , B56) ) * [: B59 , B60 :] ) = ( B60 * ( pr2 (B57 , B58) ) )))))
proof
let C64 , C65 being non  empty set;
let C66 , C67 being set;
let C68 being (Function of C66 , C64);
let C69 being (Function of C67 , C65);
L134: (C66 = ( {} ) implies (C64 = ( {} ) or [: C66 , C67 :] = ( {} )));
reconsider D11 = ( C68 * ( pr1 (C66 , C67) ) ) as (Function of [: C66 , C67 :] , C64) by L134;
L135: (C67 = ( {} ) implies (C64 = ( {} ) or [: C66 , C67 :] = ( {} )));
reconsider D12 = ( C69 * ( pr2 (C66 , C67) ) ) as (Function of [: C66 , C67 :] , C65) by L135;
thus L136: ( ( pr2 (C64 , C65) ) * [: C68 , C69 :] ) = ( ( pr2 (C64 , C65) ) * <: D11 , D12 :> ) by FUNCT_3:77
.= ( C69 * ( pr2 (C66 , C67) ) ) by FUNCT_3:62;
end;
theorem
L137: (for B61 being Function holds ( ( {} ) .. B61 ) = ( {} ))
proof
let C70 being Function;
L138: ( dom ( {} ) ) = ( {} );
L139: ( dom ( ( {} ) .. C70 ) ) = ( {} ) by L138 , PRALG_1:def 17;
thus L140: thesis by L139;
end;
theorem
L141: (for B62 being  Function-yielding Function holds (for B63 , B64 being Function holds ( ( B62 .. B63 ) * B64 ) = ( ( B62 * B64 ) .. ( B63 * B64 ) )))
proof
let C71 being  Function-yielding Function;
let C72 , C73 being Function;
L142: (for B65 being set holds (B65 in ( dom ( C71 * C73 ) ) implies ( ( ( C71 .. C72 ) * C73 ) . B65 ) = ( ( ( C71 * C73 ) . B65 ) . ( ( C72 * C73 ) . B65 ) )))
proof
let C74 being set;
assume L143: C74 in ( dom ( C71 * C73 ) );
L144: C74 in ( dom C73 ) by L143 , FUNCT_1:11;
L145: ( C73 . C74 ) in ( dom C71 ) by L143 , FUNCT_1:11;
thus L146: ( ( ( C71 .. C72 ) * C73 ) . C74 ) = ( ( C71 .. C72 ) . ( C73 . C74 ) ) by L144 , FUNCT_1:13
.= ( ( C71 . ( C73 . C74 ) ) . ( C72 . ( C73 . C74 ) ) ) by L145 , PRALG_1:def 17
.= ( ( ( C71 * C73 ) . C74 ) . ( C72 . ( C73 . C74 ) ) ) by L144 , FUNCT_1:13
.= ( ( ( C71 * C73 ) . C74 ) . ( ( C72 * C73 ) . C74 ) ) by L144 , FUNCT_1:13;
end;
L147: ( dom ( C71 .. C72 ) ) = ( dom C71 ) by PRALG_1:def 17;
L148: ( dom ( ( C71 .. C72 ) * C73 ) ) = ( dom ( C71 * C73 ) ) by L147 , RELAT_1:163;
thus L149: thesis by L148 , L142 , PRALG_1:def 17;
end;
theorem
L150: (for B66 being set holds (for B67 being non  empty set holds (for B68 being (Function of B67 , ( Funcs ((( {} ) qua set) , B66) )) holds (for B69 being (Function of B67 , ( {} )) holds ( rng ( B68 .. B69 ) ) = { ( {} ) }))))
proof
let C75 being set;
let C76 being non  empty set;
let C77 being (Function of C76 , ( Funcs ((( {} ) qua set) , C75) ));
let C78 being (Function of C76 , ( {} ));
set D13 = the (Element of C76);
L151: ( Funcs ((( {} ) qua set) , C75) ) = { ( {} ) } by FUNCT_5:57;
L152: ( dom C77 ) = C76 by L151 , FUNCT_2:def 1;
L153: ( dom ( C77 .. C78 ) ) = ( dom C77 ) by PRALG_1:def 17;
L154: ( rng ( C77 .. C78 ) ) c= { ( {} ) }
proof
let C79 being set;
L155: ( rng C77 ) c= ( Funcs ((( {} ) qua set) , C75) ) by RELAT_1:def 19;
assume L156: C79 in ( rng ( C77 .. C78 ) );
consider C80 being set such that L157: C80 in ( dom ( C77 .. C78 ) ) and L158: ( ( C77 .. C78 ) . C80 ) = C79 by L156 , FUNCT_1:def 3;
L159: ( C77 . C80 ) in ( rng C77 ) by L153 , L157 , FUNCT_1:def 3;
L160: ( C77 . C80 ) = ( {} ) by L159 , L151 , L155 , TARSKI:def 1;
L161: C79 = ( ( C77 . C80 ) . ( C78 . C80 ) ) by L153 , L157 , L158 , PRALG_1:def 17;
L162: C79 = ( {} ) by L161 , L160;
thus L163: thesis by L162 , TARSKI:def 1;
end;
L164: ( C77 . D13 ) = ( {} ) by L151 , TARSKI:def 1;
L165: ( ( C77 .. C78 ) . D13 ) = ( ( {} ) . ( C78 . D13 ) ) by L164 , L152 , PRALG_1:def 17
.= ( {} );
L166: ( {} ) in ( rng ( C77 .. C78 ) ) by L165 , L153 , L152 , FUNCT_1:def 3;
thus L167: thesis by L166 , L154 , ZFMISC_1:33;
end;
theorem
L168: (for B70 , B71 , B72 being set holds ((B71 = ( {} ) implies B70 = ( {} )) implies (for B73 being (Function of B70 , ( Funcs (B71 , B72) )) holds (for B74 being (Function of B70 , B71) holds ( rng ( B73 .. B74 ) ) c= B72))))
proof
let C81 , C82 , C83 being set;
assume that
L169: (C82 = ( {} ) implies C81 = ( {} ));
let C84 being (Function of C81 , ( Funcs (C82 , C83) ));
let C85 being (Function of C81 , C82);
let C86 being set;
assume L170: C86 in ( rng ( C84 .. C85 ) );
consider C87 being set such that L171: C87 in ( dom ( C84 .. C85 ) ) and L172: ( ( C84 .. C85 ) . C87 ) = C86 by L170 , FUNCT_1:def 3;
L173: ( dom ( C84 .. C85 ) ) = ( dom C84 ) by PRALG_1:def 17;
L174: ( Funcs (C82 , C83) ) <> ( {} ) by L173 , L171;
L175: ( dom C84 ) = C81 by L174 , FUNCT_2:def 1;
reconsider D14 = ( C84 . C87 ) as (Function of C82 , C83) by L175 , L171 , L173 , L174 , FUNCT_2:5 , FUNCT_2:66;
L176: C83 <> ( {} ) by L169 , L171 , L175 , PRALG_1:def 17;
L177: ( C85 . C87 ) in C82 by L169 , L171 , L173 , L175 , FUNCT_2:5;
L178: ( D14 . ( C85 . C87 ) ) in C83 by L177 , L176 , FUNCT_2:5;
thus L179: thesis by L178 , L171 , L172 , L173 , PRALG_1:def 17;
end;
theorem
L180: (for B75 , B76 , B77 being set holds ((B77 = ( {} ) implies (B76 = ( {} ) or B75 = ( {} ))) implies (for B78 being (Function of B75 , ( Funcs (B76 , B77) )) holds ( dom ( Frege B78 ) ) = ( Funcs (B75 , B76) ))))
proof
let C88 , C89 , C90 being set;
assume that
L181: (C90 = ( {} ) implies (C89 = ( {} ) or C88 = ( {} )));
let C91 being (Function of C88 , ( Funcs (C89 , C90) ));
thus L182: ( dom ( Frege C91 ) ) = ( product ( doms C91 ) ) by PARTFUN1:def 2
.= ( product ( C88 --> C89 ) ) by L181 , L38
.= ( Funcs (C88 , C89) ) by CARD_3:11;
end;
theorem
L183: (for B79 , B80 , B81 being set holds ((B81 = ( {} ) implies (B80 = ( {} ) or B79 = ( {} ))) implies (for B82 being (Function of B79 , ( Funcs (B80 , B81) )) holds ( rng ( Frege B82 ) ) c= ( Funcs (B79 , B81) ))))
proof
let C92 , C93 , C94 being set;
assume L184: (C94 = ( {} ) implies (C93 = ( {} ) or C92 = ( {} )));
L185: (( Funcs (C93 , C94) ) = ( {} ) implies C92 = ( {} )) by L184 , FUNCT_2:8;
let C95 being (Function of C92 , ( Funcs (C93 , C94) ));
L186: ( SubFuncs ( rng C95 ) ) = ( rng C95 ) by L25;
L187: ( dom ( rngs C95 ) ) = ( C95 " ( rng C95 ) ) by L186 , FUNCT_6:def 3;
L188: ( dom ( rngs C95 ) ) = ( dom C95 ) by L187 , RELAT_1:134
.= C92 by L185 , FUNCT_2:def 1;
L189: (for B83 being set holds (B83 in ( dom ( rngs C95 ) ) implies ( ( rngs C95 ) . B83 ) c= ( ( C92 --> C94 ) . B83 )))
proof
let C96 being set;
assume that
L190: C96 in ( dom ( rngs C95 ) );
L191: ( ( rngs C95 ) . C96 ) = ( rng ( C95 . C96 ) ) by L186 , L187 , L190 , FUNCT_6:def 3;
L192: ( C95 . C96 ) in ( Funcs (C93 , C94) ) by L185 , L188 , L190 , FUNCT_2:5;
L193: ( ( rngs C95 ) . C96 ) c= C94 by L192 , L191 , FUNCT_2:92;
thus L194: thesis by L193 , L188 , L190 , FUNCOP_1:7;
end;
L195: ( dom ( rngs C95 ) ) = ( dom ( C92 --> C94 ) ) by L188 , FUNCOP_1:13;
L196: ( product ( rngs C95 ) ) c= ( product ( C92 --> C94 ) ) by L195 , L189 , CARD_3:27;
L197: ( product ( rngs C95 ) ) c= ( Funcs (C92 , C94) ) by L196 , CARD_3:11;
thus L198: thesis by L197 , FUNCT_6:38;
end;
theorem
L199: (for B84 , B85 , B86 being set holds ((B86 = ( {} ) implies (B85 = ( {} ) or B84 = ( {} ))) implies (for B87 being (Function of B84 , ( Funcs (B85 , B86) )) holds ( Frege B87 ) is (Function of ( Funcs (B84 , B85) ) , ( Funcs (B84 , B86) )))))
proof
let C97 , C98 , C99 being set;
assume L200: (C99 = ( {} ) implies (C98 = ( {} ) or C97 = ( {} )));
L201: (( Funcs (C97 , C99) ) = ( {} ) implies ( Funcs (C97 , C98) ) = ( {} )) by L200 , FUNCT_2:8;
let C100 being (Function of C97 , ( Funcs (C98 , C99) ));
L202: (( dom ( Frege C100 ) ) = ( Funcs (C97 , C98) ) & ( rng ( Frege C100 ) ) c= ( Funcs (C97 , C99) )) by L200 , L180 , L183;
thus L203: thesis by L202 , L201 , FUNCT_2:def 1 , RELSET_1:4;
end;
begin
registration
let C101 , C102 being set;
let C103 being (Permutation of C101);
let C104 being (Permutation of C102);
cluster [: C103 , C104 :] ->  bijective for (Function of [: C101 , C102 :] , [: C101 , C102 :]);
coherence
proof
L204: [: C103 , C104 :] is  bijective
proof
thus L205: [: C103 , C104 :] is  one-to-one;
L206: (( rng C103 ) = C101 & ( rng C104 ) = C102) by FUNCT_2:def 3;
thus L207: ( rng [: C103 , C104 :] ) = [: C101 , C102 :] by L206 , FUNCT_3:67;
end;
thus L208: thesis by L204;
end;
end;
theorem
L210: (for B88 , B89 being set holds (for B90 being (Permutation of B88) holds (for B91 being (Permutation of B89) holds [: B90 , B91 :] is  bijective)));
definition
let C105 , C106 being non  empty set;
let C107 being (Permutation of C105);
let C108 being (Function of C106 , C106);
func C107 => C108 -> (Function of ( Funcs (C105 , C106) ) , ( Funcs (C105 , C106) )) means 
:L211: (for B92 being (Function of C105 , C106) holds ( it . B92 ) = ( ( C108 * B92 ) * ( C107 " ) ));
existence
proof
deffunc H1((Element of ( Funcs (C105 , C106) ))) = ( ( C108 * $1 ) * ( C107 " ) );
L212: (for B93 being (Element of ( Funcs (C105 , C106) )) holds H1(B93) in ( Funcs (C105 , C106) )) by FUNCT_2:8;
consider C109 being (Function of ( Funcs (C105 , C106) ) , ( Funcs (C105 , C106) )) such that L213: (for B94 being (Element of ( Funcs (C105 , C106) )) holds ( C109 . B94 ) = H1(B94)) from FUNCT_2:sch 8(L212);
take C109;
let C110 being (Function of C105 , C106);
L214: C110 in ( Funcs (C105 , C106) ) by FUNCT_2:8;
thus L215: thesis by L214 , L213;
end;
uniqueness
proof
let C111 , C112 being (Function of ( Funcs (C105 , C106) ) , ( Funcs (C105 , C106) ));
assume that
L216: (for B95 being (Function of C105 , C106) holds ( C111 . B95 ) = ( ( C108 * B95 ) * ( C107 " ) ))
and
L217: (for B96 being (Function of C105 , C106) holds ( C112 . B96 ) = ( ( C108 * B96 ) * ( C107 " ) ));
L218:
now
let C113 being (Element of ( Funcs (C105 , C106) ));
thus L219: ( C111 . C113 ) = ( ( C108 * C113 ) * ( C107 " ) ) by L216
.= ( C112 . C113 ) by L217;
end;
thus L220: C111 = C112 by L218 , FUNCT_2:63;
end;
end;
registration
let C114 , C115 being non  empty set;
let C116 being (Permutation of C114);
let C117 being (Permutation of C115);
cluster ( C116 => C117 ) ->  bijective;
coherence
proof
thus L222: ( C116 => C117 ) is  one-to-one
proof
let C118 , C119 being set;
assume L223: (C118 in ( dom ( C116 => C117 ) ) & C119 in ( dom ( C116 => C117 ) ));
reconsider D15 = C118 , D16 = C119 as (Element of ( Funcs (C114 , C115) )) by L223 , FUNCT_2:def 1;
assume L224: ( ( C116 => C117 ) . C118 ) = ( ( C116 => C117 ) . C119 );
L225: ( ( C117 * D15 ) * ( C116 " ) ) = ( ( C116 => C117 ) . D16 ) by L224 , L211
.= ( ( C117 * D16 ) * ( C116 " ) ) by L211;
L226: ( C117 * D15 ) = ( ( C117 * D15 ) * ( id C114 ) ) by FUNCT_2:17
.= ( ( C117 * D15 ) * ( ( C116 " ) * C116 ) ) by FUNCT_2:61
.= ( ( ( C117 * D16 ) * ( C116 " ) ) * C116 ) by L225 , RELAT_1:36
.= ( ( C117 * D16 ) * ( ( C116 " ) * C116 ) ) by RELAT_1:36
.= ( ( C117 * D16 ) * ( id C114 ) ) by FUNCT_2:61
.= ( C117 * D16 ) by FUNCT_2:17;
L227: D15 = ( ( id C115 ) * D15 ) by FUNCT_2:17
.= ( ( ( C117 " ) * C117 ) * D15 ) by FUNCT_2:61
.= ( ( C117 " ) * ( C117 * D16 ) ) by L226 , RELAT_1:36
.= ( ( ( C117 " ) * C117 ) * D16 ) by RELAT_1:36
.= ( ( id C115 ) * D16 ) by FUNCT_2:61
.= D16 by FUNCT_2:17;
thus L228: thesis by L227;
end;

thus L229: ( rng ( C116 => C117 ) ) c= ( Funcs (C114 , C115) ) by RELAT_1:def 19;
let C120 being set;
assume L230: C120 in ( Funcs (C114 , C115) );
L231: C120 is (Element of ( Funcs (C114 , C115) )) by L230;
reconsider D17 = C120 as (Function of C114 , C115) by L231;
L232: ( dom ( C116 => C117 ) ) = ( Funcs (C114 , C115) ) by FUNCT_2:def 1;
L233: ( ( ( C117 " ) * D17 ) * C116 ) in ( dom ( C116 => C117 ) ) by L232 , FUNCT_2:8;
L234: ( ( C116 => C117 ) . ( ( ( C117 " ) * D17 ) * C116 ) ) = ( ( C117 * ( ( ( C117 " ) * D17 ) * C116 ) ) * ( C116 " ) ) by L211
.= ( ( ( C117 * ( ( C117 " ) * D17 ) ) * C116 ) * ( C116 " ) ) by RELAT_1:36
.= ( ( ( ( C117 * ( C117 " ) ) * D17 ) * C116 ) * ( C116 " ) ) by RELAT_1:36
.= ( ( ( ( id C115 ) * D17 ) * C116 ) * ( C116 " ) ) by FUNCT_2:61
.= ( ( D17 * C116 ) * ( C116 " ) ) by FUNCT_2:17
.= ( D17 * ( C116 * ( C116 " ) ) ) by RELAT_1:36
.= ( D17 * ( id C114 ) ) by FUNCT_2:61
.= D17 by FUNCT_2:17;
thus L235: C120 in ( rng ( C116 => C117 ) ) by L234 , L233 , FUNCT_1:def 3;
end;
end;
theorem
L237: (for B97 , B98 being non  empty set holds (for B99 being (Permutation of B97) holds (for B100 being (Permutation of B98) holds (for B101 being (Function of B97 , B98) holds ( ( ( B99 => B100 ) " ) . B101 ) = ( ( ( B100 " ) * B101 ) * B99 )))))
proof
let C121 , C122 being non  empty set;
let C123 being (Permutation of C121);
let C124 being (Permutation of C122);
let C125 being (Function of C121 , C122);
reconsider D18 = C125 as (Element of ( Funcs (C121 , C122) )) by FUNCT_2:8;
reconsider D19 = ( ( ( C124 " ) * C125 ) * C123 ) as (Function of C121 , C122);
L238: C125 in ( Funcs (C121 , C122) ) by FUNCT_2:8;
L239: ( ( ( ( C123 => C124 ) " ) " ) . ( ( ( C123 => C124 ) " ) . C125 ) ) = C125 by L238 , FUNCT_2:26
.= ( C125 * ( id C121 ) ) by FUNCT_2:17
.= ( C125 * ( C123 * ( C123 " ) ) ) by FUNCT_2:61
.= ( ( C125 * C123 ) * ( C123 " ) ) by RELAT_1:36
.= ( ( ( ( id C122 ) * C125 ) * C123 ) * ( C123 " ) ) by FUNCT_2:17
.= ( ( ( ( C124 * ( C124 " ) ) * C125 ) * C123 ) * ( C123 " ) ) by FUNCT_2:61
.= ( ( ( C124 * ( ( C124 " ) * C125 ) ) * C123 ) * ( C123 " ) ) by RELAT_1:36
.= ( ( C124 * ( ( ( C124 " ) * C125 ) * C123 ) ) * ( C123 " ) ) by RELAT_1:36
.= ( ( C123 => C124 ) . D19 ) by L211
.= ( ( ( ( C123 => C124 ) " ) " ) . ( ( ( C124 " ) * C125 ) * C123 ) ) by FUNCT_1:43;
L240: (( ( ( C123 => C124 ) " ) . D18 ) in ( Funcs (C121 , C122) ) & D19 in ( Funcs (C121 , C122) )) by FUNCT_2:8;
thus L241: thesis by L240 , L239 , FUNCT_2:19;
end;
theorem
L242: (for B102 , B103 being non  empty set holds (for B104 being (Permutation of B102) holds (for B105 being (Permutation of B103) holds ( ( B104 => B105 ) " ) = ( ( B104 " ) => ( B105 " ) ))))
proof
let C126 , C127 being non  empty set;
let C128 being (Permutation of C126);
let C129 being (Permutation of C127);
L243:
now
let C130 being (Element of ( Funcs (C126 , C127) ));
thus L244: ( ( ( C128 => C129 ) " ) . C130 ) = ( ( ( C129 " ) * C130 ) * C128 ) by L237
.= ( ( ( C129 " ) * C130 ) * ( ( C128 " ) " ) ) by FUNCT_1:43
.= ( ( ( C128 " ) => ( C129 " ) ) . C130 ) by L211;
end;
thus L245: thesis by L243 , FUNCT_2:63;
end;
theorem
L246: (for B106 , B107 , B108 being non  empty set holds (for B109 being (Function of B106 , ( Funcs (B107 , B108) )) holds (for B110 being (Function of B106 , B107) holds (for B111 being (Permutation of B107) holds (for B112 being (Permutation of B108) holds ( ( ( B111 => B112 ) * B109 ) .. ( B111 * B110 ) ) = ( B112 * ( B109 .. B110 ) ))))))
proof
let C131 , C132 , C133 being non  empty set;
let C134 being (Function of C131 , ( Funcs (C132 , C133) ));
let C135 being (Function of C131 , C132);
let C136 being (Permutation of C132);
let C137 being (Permutation of C133);
L247: ( dom ( ( C136 => C137 ) * C134 ) ) = C131 by FUNCT_2:def 1;
L248: (( dom C137 ) = C133 & ( rng ( C134 .. C135 ) ) c= C133) by L168 , FUNCT_2:def 1;
L249: ( dom C134 ) = C131 by FUNCT_2:def 1;
L250: ( dom ( C134 .. C135 ) ) = C131 by L249 , PRALG_1:def 17;
L251: ( dom ( C137 * ( C134 .. C135 ) ) ) = C131 by L250 , L248 , RELAT_1:27;
L252: (for B113 being set holds (B113 in ( dom ( ( C136 => C137 ) * C134 ) ) implies ( ( C137 * ( C134 .. C135 ) ) . B113 ) = ( ( ( ( C136 => C137 ) * C134 ) . B113 ) . ( ( C136 * C135 ) . B113 ) )))
proof
let C138 being set;
assume that
L253: C138 in ( dom ( ( C136 => C137 ) * C134 ) );
reconsider D20 = ( C134 . C138 ) as (Function of C132 , C133) by L247 , L253 , FUNCT_2:5 , FUNCT_2:66;
L254: ( C135 . C138 ) in C132 by L247 , L253 , FUNCT_2:5;
L255: ( C135 . C138 ) in ( dom D20 ) by L254 , FUNCT_2:def 1;
L256: ( ( C136 * C135 ) . C138 ) in C132 by L247 , L253 , FUNCT_2:5;
L257: ( ( C136 * C135 ) . C138 ) in ( dom ( C136 " ) ) by L256 , FUNCT_2:def 1;
thus L258: ( ( C137 * ( C134 .. C135 ) ) . C138 ) = ( C137 . ( ( C134 .. C135 ) . C138 ) ) by L251 , L247 , L253 , FUNCT_1:12
.= ( C137 . ( D20 . ( C135 . C138 ) ) ) by L249 , L247 , L253 , PRALG_1:def 17
.= ( ( C137 * D20 ) . ( C135 . C138 ) ) by L255 , FUNCT_1:13
.= ( ( C137 * D20 ) . ( ( ( id C132 ) * C135 ) . C138 ) ) by FUNCT_2:17
.= ( ( C137 * D20 ) . ( ( ( ( C136 " ) * C136 ) * C135 ) . C138 ) ) by FUNCT_2:61
.= ( ( C137 * D20 ) . ( ( ( C136 " ) * ( C136 * C135 ) ) . C138 ) ) by RELAT_1:36
.= ( ( C137 * D20 ) . ( ( C136 " ) . ( ( C136 * C135 ) . C138 ) ) ) by L247 , L253 , FUNCT_2:15
.= ( ( ( C137 * D20 ) * ( C136 " ) ) . ( ( C136 * C135 ) . C138 ) ) by L257 , FUNCT_1:13
.= ( ( ( C136 => C137 ) . D20 ) . ( ( C136 * C135 ) . C138 ) ) by L211
.= ( ( ( ( C136 => C137 ) * C134 ) . C138 ) . ( ( C136 * C135 ) . C138 ) ) by L247 , L253 , FUNCT_2:15;
end;
thus L259: thesis by L252 , L251 , L247 , PRALG_1:def 17;
end;
begin
definition
mode SetValuation
 is  non-empty (ManySortedSet of ( NAT ));
end;
definition
let R6 being SetValuation;
func SetVal R6 -> (ManySortedSet of ( HP-WFF )) means 
:L261: (( it . ( VERUM ) ) = 1 & (for R1 being (Element of ( NAT )) holds ( it . ( prop R1 ) ) = ( R6 . R1 )) & (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (( it . ( R2 '&' R3 ) ) = [: ( it . R2 ) , ( it . R3 ) :] & ( it . ( R2 => R3 ) ) = ( Funcs (( it . R2 ) , ( it . R3 )) )))));
existence
proof
deffunc H2((Element of ( NAT ))) = ( R6 . $1 );
consider C139 being (ManySortedSet of ( HP-WFF )) such that L262: (( C139 . ( VERUM ) ) = 1 & (for R1 being (Element of ( NAT )) holds ( C139 . ( prop R1 ) ) = H2(R1)) & (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (( C139 . ( R2 '&' R3 ) ) = [: ( C139 . R2 ) , ( C139 . R3 ) :] & ( C139 . ( R2 => R3 ) ) = ( Funcs (( C139 . R2 ) , ( C139 . R3 )) ))))) from HILBERT2:sch 4;
take C139;
thus L263: thesis by L262;
end;
uniqueness
proof
let C140 , C141 being (ManySortedSet of ( HP-WFF ));
assume that
L264: ( C140 . ( VERUM ) ) = 1
and
L265: (for R1 being (Element of ( NAT )) holds ( C140 . ( prop R1 ) ) = ( R6 . R1 ))
and
L266: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (( C140 . ( R2 '&' R3 ) ) = [: ( C140 . R2 ) , ( C140 . R3 ) :] & ( C140 . ( R2 => R3 ) ) = ( Funcs (( C140 . R2 ) , ( C140 . R3 )) ))))
and
L267: ( C141 . ( VERUM ) ) = 1
and
L268: (for R1 being (Element of ( NAT )) holds ( C141 . ( prop R1 ) ) = ( R6 . R1 ))
and
L269: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (( C141 . ( R2 '&' R3 ) ) = [: ( C141 . R2 ) , ( C141 . R3 ) :] & ( C141 . ( R2 => R3 ) ) = ( Funcs (( C141 . R2 ) , ( C141 . R3 )) ))));
defpred S1[ (Element of ( HP-WFF )) ] means ( C140 . $1 ) = ( C141 . $1 );
L270: (for R4 being (Element of ( HP-WFF )) holds (for R5 being (Element of ( HP-WFF )) holds ((S1[ R4 ] & S1[ R5 ]) implies (S1[ ( R4 '&' R5 ) ] & S1[ ( R4 => R5 ) ]))))
proof
let R4 being (Element of ( HP-WFF ));
let R5 being (Element of ( HP-WFF ));
assume that
L271: (( C140 . R4 ) = ( C141 . R4 ) & ( C140 . R5 ) = ( C141 . R5 ));
thus L272: ( C140 . ( R4 '&' R5 ) ) = [: ( C141 . R4 ) , ( C141 . R5 ) :] by L266 , L271
.= ( C141 . ( R4 '&' R5 ) ) by L269;
thus L273: ( C140 . ( R4 => R5 ) ) = ( Funcs (( C141 . R4 ) , ( C141 . R5 )) ) by L266 , L271
.= ( C141 . ( R4 => R5 ) ) by L269;
end;
L274: (for R1 being (Element of ( NAT )) holds S1[ ( prop R1 ) ])
proof
let R1 being (Element of ( NAT ));
thus L275: ( C140 . ( prop R1 ) ) = ( R6 . R1 ) by L265
.= ( C141 . ( prop R1 ) ) by L268;
end;
L276: S1[ ( VERUM ) ] by L264 , L267;
L277: (for R4 being (Element of ( HP-WFF )) holds S1[ R4 ]) from HILBERT2:sch 2(L276 , L274 , L270);
L278: (for B114 being set holds (B114 in ( HP-WFF ) implies ( C140 . B114 ) = ( C141 . B114 ))) by L277;
thus L279: C140 = C141 by L278 , PBOOLE:3;
end;
end;
definition
let R6 being SetValuation;
let R2 being (Element of ( HP-WFF ));
func SetVal (R6 , R2) equals 
( ( SetVal R6 ) . R2 );
correctness;
end;
registration
let R6 being SetValuation;
let R2 being (Element of ( HP-WFF ));
cluster ( SetVal (R6 , R2) ) -> non  empty;
coherence
proof
defpred S2[ (Element of ( HP-WFF )) ] means ( ( SetVal R6 ) . $1 ) is non  empty;
L282: (for R1 being (Element of ( NAT )) holds S2[ ( prop R1 ) ])
proof
let R1 being (Element of ( NAT ));
L283: ( ( SetVal R6 ) . ( prop R1 ) ) = ( R6 . R1 ) by L261;
thus L284: thesis by L283;
end;
L285: (for R4 being (Element of ( HP-WFF )) holds (for R5 being (Element of ( HP-WFF )) holds ((S2[ R4 ] & S2[ R5 ]) implies (S2[ ( R4 '&' R5 ) ] & S2[ ( R4 => R5 ) ]))))
proof
let R4 being (Element of ( HP-WFF ));
let R5 being (Element of ( HP-WFF ));
assume that
L286: ( ( SetVal R6 ) . R4 ) is non  empty
and
L287: ( ( SetVal R6 ) . R5 ) is non  empty;
L288: ( ( SetVal R6 ) . ( R4 '&' R5 ) ) = [: ( ( SetVal R6 ) . R4 ) , ( ( SetVal R6 ) . R5 ) :] by L261;
thus L289: ( ( SetVal R6 ) . ( R4 '&' R5 ) ) is non  empty by L288 , L286 , L287;
L290: ( ( SetVal R6 ) . ( R4 => R5 ) ) = ( Funcs (( ( SetVal R6 ) . R4 ) , ( ( SetVal R6 ) . R5 )) ) by L261;
thus L291: thesis by L290 , L287;
end;
L292: S2[ ( VERUM ) ] by L261;
L293: (for R4 being (Element of ( HP-WFF )) holds S2[ R4 ]) from HILBERT2:sch 2(L292 , L282 , L285);
thus L294: thesis by L293;
end;
end;
theorem
L296: (for R6 being SetValuation holds ( SetVal (R6 , ( VERUM )) ) = 1) by L261;
theorem
L297: (for R1 being (Element of ( NAT )) holds (for R6 being SetValuation holds ( SetVal (R6 , ( prop R1 )) ) = ( R6 . R1 ))) by L261;
theorem
L298: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds ( SetVal (R6 , ( R2 '&' R3 )) ) = [: ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ) :]))) by L261;
theorem
L299: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds ( SetVal (R6 , ( R2 => R3 )) ) = ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) )))) by L261;
registration
let R6 being SetValuation;
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
cluster ( SetVal (R6 , ( R2 => R3 )) ) ->  functional;
coherence
proof
let C142 being set;
assume L300: C142 in ( SetVal (R6 , ( R2 => R3 )) );
L301: C142 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L300 , L261;
thus L302: thesis by L301;
end;
end;
registration
let R6 being SetValuation;
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R4 being (Element of ( HP-WFF ));
cluster  ->  Function-yielding for (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ));
coherence
proof
let C143 being (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ));
let C144 being set;
assume that
L304: C144 in ( dom C143 );
L305: C143 in ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) );
L306: C143 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R4 )) )) ) by L305 , L261;
L307: C143 is (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R4 )) )) by L306 , FUNCT_2:66;
thus L308: thesis by L307;
end;
end;
registration
let R6 being SetValuation;
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R4 being (Element of ( HP-WFF ));
cluster  Function-yielding for (Function of ( SetVal (R6 , ( R2 => R3 )) ) , ( SetVal (R6 , ( R2 => R4 )) ));
existence
proof
set D21 = the (Function of ( SetVal (R6 , ( R2 => R3 )) ) , ( SetVal (R6 , ( R2 => R4 )) ));
L310: D21 is  Function-yielding;
thus L311: thesis by L310;
end;
cluster  Function-yielding for (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ));
existence
proof
set D22 = the (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ));
L312: D22 is  Function-yielding;
thus L313: thesis by L312;
end;
end;
begin
definition
let R6 being SetValuation;
mode Permutation of R6
 -> Function
means :L315: (( dom it ) = ( NAT ) & (for R1 being (Element of ( NAT )) holds ( it . R1 ) is (Permutation of ( R6 . R1 ))));
existence
proof
take ( id R6 );
thus L316: ( dom ( id R6 ) ) = ( NAT ) by PARTFUN1:def 2;
let R1 being (Element of ( NAT ));
L317: ( ( id R6 ) . R1 ) = ( id ( R6 . R1 ) ) by MSUALG_3:def 1;
thus L318: thesis by L317;
end;
end;
definition
let R6 being SetValuation;
let R7 being (Permutation of R6);
func Perm R7 -> (ManySortedFunction of ( SetVal R6 ) , ( SetVal R6 )) means 
:L320: (( it . ( VERUM ) ) = ( id 1 ) & (for R1 being (Element of ( NAT )) holds ( it . ( prop R1 ) ) = ( R7 . R1 )) & (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (ex B115 being (Permutation of ( SetVal (R6 , R2) )) st (ex B116 being (Permutation of ( SetVal (R6 , R3) )) st (B115 = ( it . R2 ) & B116 = ( it . R3 ) & ( it . ( R2 '&' R3 ) ) = [: B115 , B116 :] & ( it . ( R2 => R3 ) ) = ( B115 => B116 )))))));
existence
proof
deffunc H3((Element of ( NAT ))) = ( R7 . $1 );
defpred S3[ (Element of ( HP-WFF )) , (Element of ( HP-WFF )) , set , set , set ] means ((($3 is (Permutation of ( SetVal (R6 , $1) )) & $4 is (Permutation of ( SetVal (R6 , $2) ))) implies (ex B117 being (Permutation of ( SetVal (R6 , $1) )) st (ex B118 being (Permutation of ( SetVal (R6 , $2) )) st (B117 = $3 & B118 = $4 & $5 = ( B117 => B118 ))))) & (((not $3 is (Permutation of ( SetVal (R6 , $1) ))) or (not $4 is (Permutation of ( SetVal (R6 , $2) )))) implies $5 = ( {} )));
defpred S4[ (Element of ( HP-WFF )) , (Element of ( HP-WFF )) , set , set , set ] means ((($3 is (Permutation of ( SetVal (R6 , $1) )) & $4 is (Permutation of ( SetVal (R6 , $2) ))) implies (ex B119 being (Permutation of ( SetVal (R6 , $1) )) st (ex B120 being (Permutation of ( SetVal (R6 , $2) )) st (B119 = $3 & B120 = $4 & $5 = [: B119 , B120 :])))) & (((not $3 is (Permutation of ( SetVal (R6 , $1) ))) or (not $4 is (Permutation of ( SetVal (R6 , $2) )))) implies $5 = ( {} )));
L321: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for B121 , B122 being set holds (ex B123 being set st S4[ R2 , R3 , B121 , B122 , B123 ]))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let C145 , C146 being set;
per cases ;
suppose that L322: C145 is (Permutation of ( SetVal (R6 , R2) ))
and
L323: C146 is (Permutation of ( SetVal (R6 , R3) ));
reconsider D23 = C146 as (Permutation of ( SetVal (R6 , R3) )) by L323;
reconsider D24 = C145 as (Permutation of ( SetVal (R6 , R2) )) by L322;
take [: D24 , D23 :];
thus L324: thesis;
end;
suppose L325: ((not C145 is (Permutation of ( SetVal (R6 , R2) ))) or (not C146 is (Permutation of ( SetVal (R6 , R3) ))));

thus L326: thesis by L325;
end;
end;
L328: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for B124 , B125 being set holds (ex B126 being set st S3[ R2 , R3 , B124 , B125 , B126 ]))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let C147 , C148 being set;
per cases ;
suppose that L329: C147 is (Permutation of ( SetVal (R6 , R2) ))
and
L330: C148 is (Permutation of ( SetVal (R6 , R3) ));
reconsider D25 = C148 as (Permutation of ( SetVal (R6 , R3) )) by L330;
reconsider D26 = C147 as (Permutation of ( SetVal (R6 , R2) )) by L329;
take ( D26 => D25 );
thus L331: thesis;
end;
suppose L332: ((not C147 is (Permutation of ( SetVal (R6 , R2) ))) or (not C148 is (Permutation of ( SetVal (R6 , R3) ))));

thus L333: thesis by L332;
end;
end;
L335: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for B127 , B128 , B129 , B130 being set holds ((S3[ R2 , R3 , B127 , B128 , B129 ] & S3[ R2 , R3 , B127 , B128 , B130 ]) implies B129 = B130))));
L336: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for B131 , B132 , B133 , B134 being set holds ((S4[ R2 , R3 , B131 , B132 , B133 ] & S4[ R2 , R3 , B131 , B132 , B134 ]) implies B133 = B134))));
consider C149 being (ManySortedSet of ( HP-WFF )) such that L337: ( C149 . ( VERUM ) ) = ( id 1 ) and L338: (for R1 being (Element of ( NAT )) holds ( C149 . ( prop R1 ) ) = H3(R1)) and L339: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (S4[ R2 , R3 , ( C149 . R2 ) , ( C149 . R3 ) , ( C149 . ( R2 '&' R3 ) ) ] & S3[ R2 , R3 , ( C149 . R2 ) , ( C149 . R3 ) , ( C149 . ( R2 => R3 ) ) ]))) from HILBERT2:sch 3(L321 , L328 , L336 , L335);
defpred S5[ (Element of ( HP-WFF )) ] means ( C149 . $1 ) is (Permutation of ( ( SetVal R6 ) . $1 ));
L340: (for R4 being (Element of ( HP-WFF )) holds (for R5 being (Element of ( HP-WFF )) holds ((S5[ R4 ] & S5[ R5 ]) implies (S5[ ( R4 '&' R5 ) ] & S5[ ( R4 => R5 ) ]))))
proof
let R4 being (Element of ( HP-WFF ));
let R5 being (Element of ( HP-WFF ));
assume that
L341: (( C149 . R4 ) is (Permutation of ( ( SetVal R6 ) . R4 )) & ( C149 . R5 ) is (Permutation of ( ( SetVal R6 ) . R5 )));
L342: ( ( SetVal R6 ) . ( R4 '&' R5 ) ) = [: ( SetVal (R6 , R4) ) , ( SetVal (R6 , R5) ) :] by L261;
L343: (ex B135 being (Permutation of ( SetVal (R6 , R4) )) st (ex B136 being (Permutation of ( SetVal (R6 , R5) )) st (B135 = ( C149 . R4 ) & B136 = ( C149 . R5 ) & ( C149 . ( R4 '&' R5 ) ) = [: B135 , B136 :]))) by L339 , L341;
thus L344: ( C149 . ( R4 '&' R5 ) ) is (Permutation of ( ( SetVal R6 ) . ( R4 '&' R5 ) )) by L343 , L342;
L345: ( ( SetVal R6 ) . ( R4 => R5 ) ) = ( Funcs (( SetVal (R6 , R4) ) , ( SetVal (R6 , R5) )) ) by L261;
L346: (ex B137 being (Permutation of ( SetVal (R6 , R4) )) st (ex B138 being (Permutation of ( SetVal (R6 , R5) )) st (B137 = ( C149 . R4 ) & B138 = ( C149 . R5 ) & ( C149 . ( R4 => R5 ) ) = ( B137 => B138 )))) by L339 , L341;
thus L347: thesis by L346 , L345;
end;
take C149;
L348: (for R1 being (Element of ( NAT )) holds S5[ ( prop R1 ) ])
proof
let R1 being (Element of ( NAT ));
L349: (( C149 . ( prop R1 ) ) = ( R7 . R1 ) & ( ( SetVal R6 ) . ( prop R1 ) ) = ( R6 . R1 )) by L338 , L261;
thus L350: thesis by L349 , L315;
end;
L351: ( ( SetVal R6 ) . ( VERUM ) ) = 1 by L261;
L352: S5[ ( VERUM ) ] by L351 , L337;
L353: (for R2 being (Element of ( HP-WFF )) holds S5[ R2 ]) from HILBERT2:sch 2(L352 , L348 , L340);
thus L354: C149 is (ManySortedFunction of ( SetVal R6 ) , ( SetVal R6 ))
proof
let C150 being set;
thus L355: thesis by L353;
end;

thus L356: ( C149 . ( VERUM ) ) = ( id 1 ) by L337;
thus L357: (for R1 being (Element of ( NAT )) holds ( C149 . ( prop R1 ) ) = ( R7 . R1 )) by L338;
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
L358: (( C149 . R2 ) is (Permutation of ( ( SetVal R6 ) . R2 )) & ( C149 . R3 ) is (Permutation of ( ( SetVal R6 ) . R3 ))) by L353;
consider C151 being (Permutation of ( SetVal (R6 , R2) )), C152 being (Permutation of ( SetVal (R6 , R3) )) such that L359: (C151 = ( C149 . R2 ) & C152 = ( C149 . R3 )) and L360: ( C149 . ( R2 '&' R3 ) ) = [: C151 , C152 :] by L358 , L339;
take C151;
take C152;
thus L361: (C151 = ( C149 . R2 ) & C152 = ( C149 . R3 ) & ( C149 . ( R2 '&' R3 ) ) = [: C151 , C152 :]) by L359 , L360;
L362: (ex B139 being (Permutation of ( SetVal (R6 , R2) )) st (ex B140 being (Permutation of ( SetVal (R6 , R3) )) st (B139 = ( C149 . R2 ) & B140 = ( C149 . R3 ) & ( C149 . ( R2 => R3 ) ) = ( B139 => B140 )))) by L339 , L358;
thus L363: ( C149 . ( R2 => R3 ) ) = ( C151 => C152 ) by L362 , L359;
end;
uniqueness
proof
let C153 , C154 being (ManySortedFunction of ( SetVal R6 ) , ( SetVal R6 ));
assume that
L364: ( C153 . ( VERUM ) ) = ( id 1 )
and
L365: (for R1 being (Element of ( NAT )) holds ( C153 . ( prop R1 ) ) = ( R7 . R1 ))
and
L366: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (ex B141 being (Permutation of ( SetVal (R6 , R2) )) st (ex B142 being (Permutation of ( SetVal (R6 , R3) )) st (B141 = ( C153 . R2 ) & B142 = ( C153 . R3 ) & ( C153 . ( R2 '&' R3 ) ) = [: B141 , B142 :] & ( C153 . ( R2 => R3 ) ) = ( B141 => B142 ))))))
and
L367: ( C154 . ( VERUM ) ) = ( id 1 )
and
L368: (for R1 being (Element of ( NAT )) holds ( C154 . ( prop R1 ) ) = ( R7 . R1 ))
and
L369: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (ex B143 being (Permutation of ( SetVal (R6 , R2) )) st (ex B144 being (Permutation of ( SetVal (R6 , R3) )) st (B143 = ( C154 . R2 ) & B144 = ( C154 . R3 ) & ( C154 . ( R2 '&' R3 ) ) = [: B143 , B144 :] & ( C154 . ( R2 => R3 ) ) = ( B143 => B144 ))))));
defpred S6[ (Element of ( HP-WFF )) ] means ( C153 . $1 ) = ( C154 . $1 );
L370: (for R1 being (Element of ( NAT )) holds S6[ ( prop R1 ) ])
proof
let R1 being (Element of ( NAT ));
thus L371: ( C153 . ( prop R1 ) ) = ( R7 . R1 ) by L365
.= ( C154 . ( prop R1 ) ) by L368;
end;
L372: (for R4 being (Element of ( HP-WFF )) holds (for R5 being (Element of ( HP-WFF )) holds ((S6[ R4 ] & S6[ R5 ]) implies (S6[ ( R4 '&' R5 ) ] & S6[ ( R4 => R5 ) ]))))
proof
let R4 being (Element of ( HP-WFF ));
let R5 being (Element of ( HP-WFF ));
assume that
L373: (( C153 . R4 ) = ( C154 . R4 ) & ( C153 . R5 ) = ( C154 . R5 ));
L374: ((ex B145 being (Permutation of ( SetVal (R6 , R4) )) st (ex B146 being (Permutation of ( SetVal (R6 , R5) )) st (B145 = ( C153 . R4 ) & B146 = ( C153 . R5 ) & ( C153 . ( R4 '&' R5 ) ) = [: B145 , B146 :] & ( C153 . ( R4 => R5 ) ) = ( B145 => B146 )))) & (ex B147 being (Permutation of ( SetVal (R6 , R4) )) st (ex B148 being (Permutation of ( SetVal (R6 , R5) )) st (B147 = ( C154 . R4 ) & B148 = ( C154 . R5 ) & ( C154 . ( R4 '&' R5 ) ) = [: B147 , B148 :] & ( C154 . ( R4 => R5 ) ) = ( B147 => B148 ))))) by L366 , L369;
thus L375: ( C153 . ( R4 '&' R5 ) ) = ( C154 . ( R4 '&' R5 ) ) by L374 , L373;
thus L376: thesis by L373 , L374;
end;
L377: S6[ ( VERUM ) ] by L364 , L367;
L378: (for R4 being (Element of ( HP-WFF )) holds S6[ R4 ]) from HILBERT2:sch 2(L377 , L370 , L372);
L379: (for B149 being set holds (B149 in ( HP-WFF ) implies ( C153 . B149 ) = ( C154 . B149 ))) by L378;
thus L380: C153 = C154 by L379 , PBOOLE:3;
end;
end;
definition
let R6 being SetValuation;
let R7 being (Permutation of R6);
let R2 being (Element of ( HP-WFF ));
func Perm (R7 , R2) -> (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R2) )) equals 
( ( Perm R7 ) . R2 );
correctness;
end;
theorem
L383: (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds ( Perm (R7 , ( VERUM )) ) = ( id ( SetVal (R6 , ( VERUM )) ) )))
proof
let R6 being SetValuation;
let R7 being (Permutation of R6);
thus L384: ( Perm (R7 , ( VERUM )) ) = ( id 1 ) by L320
.= ( id ( SetVal (R6 , ( VERUM )) ) ) by L261;
end;
theorem
L385: (for R1 being (Element of ( NAT )) holds (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds ( Perm (R7 , ( prop R1 )) ) = ( R7 . R1 )))) by L320;
theorem
L386: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds ( Perm (R7 , ( R2 '&' R3 )) ) = [: ( Perm (R7 , R2) ) , ( Perm (R7 , R3) ) :]))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let R7 being (Permutation of R6);
L387: (ex B150 being (Permutation of ( SetVal (R6 , R2) )) st (ex B151 being (Permutation of ( SetVal (R6 , R3) )) st (B150 = ( ( Perm R7 ) . R2 ) & B151 = ( ( Perm R7 ) . R3 ) & ( ( Perm R7 ) . ( R2 '&' R3 ) ) = [: B150 , B151 :] & ( ( Perm R7 ) . ( R2 => R3 ) ) = ( B150 => B151 )))) by L320;
thus L388: thesis by L387;
end;
theorem
L389: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds (for B152 being (Permutation of ( SetVal (R6 , R2) )) holds (for B153 being (Permutation of ( SetVal (R6 , R3) )) holds ((B152 = ( Perm (R7 , R2) ) & B153 = ( Perm (R7 , R3) )) implies ( Perm (R7 , ( R2 => R3 )) ) = ( B152 => B153 ))))))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let R7 being (Permutation of R6);
L390: (ex B154 being (Permutation of ( SetVal (R6 , R2) )) st (ex B155 being (Permutation of ( SetVal (R6 , R3) )) st (B154 = ( ( Perm R7 ) . R2 ) & B155 = ( ( Perm R7 ) . R3 ) & ( ( Perm R7 ) . ( R2 '&' R3 ) ) = [: B154 , B155 :] & ( ( Perm R7 ) . ( R2 => R3 ) ) = ( B154 => B155 )))) by L320;
let C155 being (Permutation of ( SetVal (R6 , R2) ));
let C156 being (Permutation of ( SetVal (R6 , R3) ));
assume L391: (C155 = ( Perm (R7 , R2) ) & C156 = ( Perm (R7 , R3) ));
thus L392: thesis by L391 , L390;
end;
registration
let R6 being SetValuation;
let R7 being (Permutation of R6);
let R2 being (Element of ( HP-WFF ));
cluster ( Perm (R7 , R2) ) ->  bijective;
coherence
proof
defpred S7[ (Element of ( HP-WFF )) ] means ( Perm (R7 , $1) ) is  bijective;
L393: (for R1 being (Element of ( NAT )) holds S7[ ( prop R1 ) ])
proof
let R1 being (Element of ( NAT ));
L394: (( SetVal (R6 , ( prop R1 )) ) = ( R6 . R1 ) & ( Perm (R7 , ( prop R1 )) ) = ( R7 . R1 )) by L261 , L320;
thus L395: thesis by L394 , L315;
end;
L396: (for R4 being (Element of ( HP-WFF )) holds (for R5 being (Element of ( HP-WFF )) holds ((S7[ R4 ] & S7[ R5 ]) implies (S7[ ( R4 '&' R5 ) ] & S7[ ( R4 => R5 ) ]))))
proof
let R4 being (Element of ( HP-WFF ));
let R5 being (Element of ( HP-WFF ));
assume L397: ( Perm (R7 , R4) ) is  bijective;
reconsider D27 = ( Perm (R7 , R4) ) as (Permutation of ( SetVal (R6 , R4) )) by L397;
assume L398: ( Perm (R7 , R5) ) is  bijective;
reconsider D28 = ( Perm (R7 , R5) ) as (Permutation of ( SetVal (R6 , R5) )) by L398;
L399: (( SetVal (R6 , ( R4 '&' R5 )) ) = [: ( SetVal (R6 , R4) ) , ( SetVal (R6 , R5) ) :] & ( Perm (R7 , ( R4 '&' R5 )) ) = [: D27 , D28 :]) by L261 , L386;
thus L400: ( Perm (R7 , ( R4 '&' R5 )) ) is  bijective by L399;
L401: (( SetVal (R6 , ( R4 => R5 )) ) = ( Funcs (( SetVal (R6 , R4) ) , ( SetVal (R6 , R5) )) ) & ( Perm (R7 , ( R4 => R5 )) ) = ( D27 => D28 )) by L261 , L389;
thus L402: thesis by L401;
end;
L403: ( Perm (R7 , ( VERUM )) ) = ( id ( SetVal (R6 , ( VERUM )) ) ) by L383;
L404: S7[ ( VERUM ) ] by L403;
L405: (for R2 being (Element of ( HP-WFF )) holds S7[ R2 ]) from HILBERT2:sch 2(L404 , L393 , L396);
thus L406: thesis by L405;
end;
end;
theorem
L408: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds (for B156 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) holds ( ( Perm (R7 , ( R2 => R3 )) ) . B156 ) = ( ( ( Perm (R7 , R3) ) * B156 ) * ( ( Perm (R7 , R2) ) " ) ))))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let R7 being (Permutation of R6);
let C157 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ));
thus L409: ( ( Perm (R7 , ( R2 => R3 )) ) . C157 ) = ( ( ( Perm (R7 , R2) ) => ( Perm (R7 , R3) ) ) . C157 ) by L389
.= ( ( ( Perm (R7 , R3) ) * C157 ) * ( ( Perm (R7 , R2) ) " ) ) by L211;
end;
theorem
L410: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds (for B157 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) holds ( ( ( Perm (R7 , ( R2 => R3 )) ) " ) . B157 ) = ( ( ( ( Perm (R7 , R3) ) " ) * B157 ) * ( Perm (R7 , R2) ) ))))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let R7 being (Permutation of R6);
let C158 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ));
thus L411: ( ( ( Perm (R7 , ( R2 => R3 )) ) " ) . C158 ) = ( ( ( ( Perm (R7 , R2) ) => ( Perm (R7 , R3) ) ) " ) . C158 ) by L389
.= ( ( ( ( Perm (R7 , R3) ) " ) * C158 ) * ( Perm (R7 , R2) ) ) by L237;
end;
theorem
L412: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for R7 being (Permutation of R6) holds (for B158 , B159 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) holds (B158 = ( ( Perm (R7 , ( R2 => R3 )) ) . B159 ) implies ( ( Perm (R7 , R3) ) * B159 ) = ( B158 * ( Perm (R7 , R2) ) )))))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let R7 being (Permutation of R6);
let C159 , C160 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ));
assume that
L413: C159 = ( ( Perm (R7 , ( R2 => R3 )) ) . C160 );
thus L414: ( ( Perm (R7 , R3) ) * C160 ) = ( ( ( Perm (R7 , R3) ) * C160 ) * ( id ( SetVal (R6 , R2) ) ) ) by FUNCT_2:17
.= ( ( ( Perm (R7 , R3) ) * C160 ) * ( ( ( Perm (R7 , R2) ) " ) * ( Perm (R7 , R2) ) ) ) by FUNCT_2:61
.= ( ( ( ( Perm (R7 , R3) ) * C160 ) * ( ( Perm (R7 , R2) ) " ) ) * ( Perm (R7 , R2) ) ) by RELAT_1:36
.= ( C159 * ( Perm (R7 , R2) ) ) by L413 , L408;
end;
theorem
L415: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for B160 being (Permutation of R6) holds (for B161 being set holds (B161 is_a_fixpoint_of ( Perm (B160 , R2) ) implies (for B162 being Function holds (B162 is_a_fixpoint_of ( Perm (B160 , ( R2 => R3 )) ) implies ( B162 . B161 ) is_a_fixpoint_of ( Perm (B160 , R3) )))))))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let C161 being (Permutation of R6);
let C162 being set;
assume that
L416: C162 is_a_fixpoint_of ( Perm (C161 , R2) );
let C163 being Function;
assume that
L417: C163 is_a_fixpoint_of ( Perm (C161 , ( R2 => R3 )) );
L418: ( dom ( Perm (C161 , ( R2 => R3 )) ) ) = ( SetVal (R6 , ( R2 => R3 )) ) by FUNCT_2:52
.= ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L261;
L419: C163 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L418 , L417 , ABIAN:def 3;
reconsider D29 = C163 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) by L419 , FUNCT_2:66;
set D30 = ( ( Perm (C161 , ( R2 => R3 )) ) . C163 );
L420: D30 = ( ( ( Perm (C161 , R3) ) * D29 ) * ( ( Perm (C161 , R2) ) " ) ) by L408;
reconsider D31 = D30 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) by L420;
L421: D31 = C163 by L417 , ABIAN:def 3;
L422: ( dom ( Perm (C161 , R2) ) ) = ( SetVal (R6 , R2) ) by FUNCT_2:52;
L423: C162 in ( SetVal (R6 , R2) ) by L422 , L416 , ABIAN:def 3;
L424: ( dom ( Perm (C161 , ( R2 => R3 )) ) ) = ( SetVal (R6 , ( R2 => R3 )) ) by FUNCT_2:52
.= ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L261;
L425: C163 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L424 , L417 , ABIAN:def 3;
L426: ( C163 . C162 ) in ( SetVal (R6 , R3) ) by L425 , L423 , L32;
thus L427: ( C163 . C162 ) in ( dom ( Perm (C161 , R3) ) ) by L426 , FUNCT_2:52;
thus L428: ( ( Perm (C161 , R3) ) . ( C163 . C162 ) ) = ( ( ( Perm (C161 , R3) ) * D29 ) . C162 ) by L423 , FUNCT_2:15
.= ( ( C163 * ( Perm (C161 , R2) ) ) . C162 ) by L421 , L412
.= ( C163 . ( ( Perm (C161 , R2) ) . C162 ) ) by L423 , FUNCT_2:15
.= ( C163 . C162 ) by L416 , ABIAN:def 3;
end;
begin
definition
let R2 being (Element of ( HP-WFF ));
attr R2 is  canonical
means
:L429: (for R6 being SetValuation holds (ex B163 being set st (for B164 being (Permutation of R6) holds B163 is_a_fixpoint_of ( Perm (B164 , R2) ))));
end;
registration
cluster ( VERUM ) ->  canonical;
coherence
proof
let R6 being SetValuation;
take ( 0 );
let C164 being (Permutation of R6);
L431: (( SetVal (R6 , ( VERUM )) ) = 1 & ( 0 ) in 1) by L261 , CARD_1:49 , TARSKI:def 1;
thus L432: thesis by L431 , L18 , CARD_1:49;
end;
end;
registration
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
cluster ( R2 => ( R3 => R2 ) ) ->  canonical;
coherence
proof
let R6 being SetValuation;
deffunc H4(set) = ( ( SetVal (R6 , R3) ) --> $1 );
L434: (for B165 being (Element of ( SetVal (R6 , R2) )) holds H4(B165) in ( SetVal (R6 , ( R3 => R2 )) ))
proof
let C165 being (Element of ( SetVal (R6 , R2) ));
L435: ( ( SetVal (R6 , R3) ) --> C165 ) in ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , R2) )) ) by FUNCT_2:8;
thus L436: thesis by L435 , L261;
end;
consider C166 being (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R2 )) )) such that L437: (for B166 being (Element of ( SetVal (R6 , R2) )) holds ( C166 . B166 ) = H4(B166)) from FUNCT_2:sch 8(L434);
take C166;
let C167 being (Permutation of R6);
L438: C166 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R2 )) )) ) by FUNCT_2:8;
L439: C166 in ( SetVal (R6 , ( R2 => ( R3 => R2 ) )) ) by L438 , L261;
thus L440: C166 in ( dom ( Perm (C167 , ( R2 => ( R3 => R2 ) )) ) ) by L439 , FUNCT_2:def 1;
L441:
now
let C168 being (Element of ( SetVal (R6 , R2) ));
reconsider D32 = ( ( SetVal (R6 , R3) ) --> ( ( ( Perm (C167 , R2) ) " ) . C168 ) ) as (Function of ( SetVal (R6 , R3) ) , ( SetVal (R6 , R2) ));
L442: C168 in ( SetVal (R6 , R2) );
L443: C168 in ( rng ( Perm (C167 , R2) ) ) by L442 , FUNCT_2:def 3;
L444: ( ( ( Perm (C167 , R2) ) " ) . C168 ) in ( dom ( Perm (C167 , R2) ) ) by L443 , PARTFUN2:60;
thus L445: ( C166 . C168 ) = ( ( SetVal (R6 , R3) ) --> C168 ) by L437
.= ( ( SetVal (R6 , R3) ) --> ( ( id ( SetVal (R6 , R2) ) ) . C168 ) ) by FUNCT_1:17
.= ( ( SetVal (R6 , R3) ) --> ( ( ( Perm (C167 , R2) ) * ( ( Perm (C167 , R2) ) " ) ) . C168 ) ) by FUNCT_2:61
.= ( ( SetVal (R6 , R3) ) --> ( ( Perm (C167 , R2) ) . ( ( ( Perm (C167 , R2) ) " ) . C168 ) ) ) by FUNCT_2:15
.= ( ( Perm (C167 , R2) ) * ( ( SetVal (R6 , R3) ) --> ( ( ( Perm (C167 , R2) ) " ) . C168 ) ) ) by L444 , FUNCOP_1:17
.= ( ( Perm (C167 , R2) ) * ( ( ( ( Perm (C167 , R3) ) " ) " ( SetVal (R6 , R3) ) ) --> ( ( ( Perm (C167 , R2) ) " ) . C168 ) ) ) by FUNCT_2:40
.= ( ( Perm (C167 , R2) ) * ( D32 * ( ( Perm (C167 , R3) ) " ) ) ) by FUNCOP_1:19
.= ( ( ( Perm (C167 , R2) ) * D32 ) * ( ( Perm (C167 , R3) ) " ) ) by RELAT_1:36
.= ( ( Perm (C167 , ( R3 => R2 )) ) . D32 ) by L408
.= ( ( Perm (C167 , ( R3 => R2 )) ) . ( C166 . ( ( ( Perm (C167 , R2) ) " ) . C168 ) ) ) by L437
.= ( ( ( Perm (C167 , ( R3 => R2 )) ) * C166 ) . ( ( ( Perm (C167 , R2) ) " ) . C168 ) ) by FUNCT_2:15
.= ( ( ( ( Perm (C167 , ( R3 => R2 )) ) * C166 ) * ( ( Perm (C167 , R2) ) " ) ) . C168 ) by FUNCT_2:15;
end;
thus L446: C166 = ( ( ( Perm (C167 , ( R3 => R2 )) ) * C166 ) * ( ( Perm (C167 , R2) ) " ) ) by L441 , FUNCT_2:63
.= ( ( Perm (C167 , ( R2 => ( R3 => R2 ) )) ) . C166 ) by L408;
end;
cluster ( ( R2 '&' R3 ) => R2 ) ->  canonical;
coherence
proof
let R6 being SetValuation;
take D33 = ( pr1 (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) );
let C169 being (Permutation of R6);
L447: ( dom ( Perm (C169 , ( ( R2 '&' R3 ) => R2 )) ) ) = ( SetVal (R6 , ( ( R2 '&' R3 ) => R2 )) ) by FUNCT_2:def 1
.= ( Funcs (( SetVal (R6 , ( R2 '&' R3 )) ) , ( SetVal (R6 , R2) )) ) by L261
.= ( Funcs ([: ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ) :] , ( SetVal (R6 , R2) )) ) by L261;
thus L448: D33 in ( dom ( Perm (C169 , ( ( R2 '&' R3 ) => R2 )) ) ) by L447 , FUNCT_2:8;
L449: D33 in ( Funcs (( SetVal (R6 , ( R2 '&' R3 )) ) , ( SetVal (R6 , R2) )) ) by L448 , L447 , L261;
reconsider D34 = D33 as (Function of ( SetVal (R6 , ( R2 '&' R3 )) ) , ( SetVal (R6 , R2) )) by L449 , FUNCT_2:66;
thus L450: ( ( Perm (C169 , ( ( R2 '&' R3 ) => R2 )) ) . D33 ) = ( ( ( Perm (C169 , R2) ) * D34 ) * ( ( Perm (C169 , ( R2 '&' R3 )) ) " ) ) by L408
.= ( ( ( Perm (C169 , R2) ) * D34 ) * ( [: ( Perm (C169 , R2) ) , ( Perm (C169 , R3) ) :] " ) ) by L386
.= ( ( ( Perm (C169 , R2) ) * D34 ) * [: ( ( Perm (C169 , R2) ) " ) , ( ( Perm (C169 , R3) ) " ) :] ) by FUNCTOR0:6
.= ( ( Perm (C169 , R2) ) * ( D34 * [: ( ( Perm (C169 , R2) ) " ) , ( ( Perm (C169 , R3) ) " ) :] ) ) by RELAT_1:36
.= ( ( Perm (C169 , R2) ) * ( ( ( Perm (C169 , R2) ) " ) * D34 ) ) by L129
.= ( ( ( Perm (C169 , R2) ) * ( ( Perm (C169 , R2) ) " ) ) * D34 ) by RELAT_1:36
.= ( ( id ( SetVal (R6 , R2) ) ) * D34 ) by FUNCT_2:61
.= D33 by FUNCT_2:17;
end;
cluster ( ( R2 '&' R3 ) => R3 ) ->  canonical;
coherence
proof
let R6 being SetValuation;
take D35 = ( pr2 (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) );
let C170 being (Permutation of R6);
L451: ( dom ( Perm (C170 , ( ( R2 '&' R3 ) => R3 )) ) ) = ( SetVal (R6 , ( ( R2 '&' R3 ) => R3 )) ) by FUNCT_2:def 1
.= ( Funcs (( SetVal (R6 , ( R2 '&' R3 )) ) , ( SetVal (R6 , R3) )) ) by L261
.= ( Funcs ([: ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ) :] , ( SetVal (R6 , R3) )) ) by L261;
thus L452: D35 in ( dom ( Perm (C170 , ( ( R2 '&' R3 ) => R3 )) ) ) by L451 , FUNCT_2:8;
L453: D35 in ( Funcs (( SetVal (R6 , ( R2 '&' R3 )) ) , ( SetVal (R6 , R3) )) ) by L452 , L451 , L261;
reconsider D36 = D35 as (Function of ( SetVal (R6 , ( R2 '&' R3 )) ) , ( SetVal (R6 , R3) )) by L453 , FUNCT_2:66;
thus L454: ( ( Perm (C170 , ( ( R2 '&' R3 ) => R3 )) ) . D35 ) = ( ( ( Perm (C170 , R3) ) * D36 ) * ( ( Perm (C170 , ( R2 '&' R3 )) ) " ) ) by L408
.= ( ( ( Perm (C170 , R3) ) * D36 ) * ( [: ( Perm (C170 , R2) ) , ( Perm (C170 , R3) ) :] " ) ) by L386
.= ( ( ( Perm (C170 , R3) ) * D36 ) * [: ( ( Perm (C170 , R2) ) " ) , ( ( Perm (C170 , R3) ) " ) :] ) by FUNCTOR0:6
.= ( ( Perm (C170 , R3) ) * ( D36 * [: ( ( Perm (C170 , R2) ) " ) , ( ( Perm (C170 , R3) ) " ) :] ) ) by RELAT_1:36
.= ( ( Perm (C170 , R3) ) * ( ( ( Perm (C170 , R3) ) " ) * D36 ) ) by L133
.= ( ( ( Perm (C170 , R3) ) * ( ( Perm (C170 , R3) ) " ) ) * D36 ) by RELAT_1:36
.= ( ( id ( SetVal (R6 , R3) ) ) * D36 ) by FUNCT_2:61
.= D35 by FUNCT_2:17;
end;
cluster ( R2 => ( R3 => ( R2 '&' R3 ) ) ) ->  canonical;
coherence
proof
let R6 being SetValuation;
take D37 = ( curry [: ( id ( SetVal (R6 , R2) ) ) , ( id ( SetVal (R6 , R3) ) ) :] );
let C171 being (Permutation of R6);
L455: D37 in ( Funcs (( SetVal (R6 , R2) ) , ( Funcs (( SetVal (R6 , R3) ) , [: ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) ) :]) )) ) by FUNCT_2:8;
L456: D37 in ( Funcs (( SetVal (R6 , R2) ) , ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , ( R2 '&' R3 )) )) )) ) by L455 , L261;
L457: D37 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => ( R2 '&' R3 ) )) )) ) by L456 , L261;
reconsider D38 = D37 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => ( R2 '&' R3 ) )) )) by L457 , FUNCT_2:66;
L458: D37 in ( SetVal (R6 , ( R2 => ( R3 => ( R2 '&' R3 ) ) )) ) by L457 , L261;
thus L459: D37 in ( dom ( Perm (C171 , ( R2 => ( R3 => ( R2 '&' R3 ) ) )) ) ) by L458 , FUNCT_2:def 1;
L460:
now
let C172 being (Element of ( SetVal (R6 , R2) ));
set D39 = ( D37 . C172 );
L461: ( D38 . C172 ) in ( SetVal (R6 , ( R3 => ( R2 '&' R3 ) )) );
L462: D39 in ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , ( R2 '&' R3 )) )) ) by L461 , L261;
reconsider D40 = D39 as (Function of ( SetVal (R6 , R3) ) , ( SetVal (R6 , ( R2 '&' R3 )) )) by L462 , FUNCT_2:66;
set D41 = ( D38 . ( ( ( Perm (C171 , R2) ) " ) . C172 ) );
L463: D41 in ( SetVal (R6 , ( R3 => ( R2 '&' R3 ) )) );
L464: D41 in ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , ( R2 '&' R3 )) )) ) by L463 , L261;
reconsider D42 = D41 as (Function of ( SetVal (R6 , R3) ) , ( SetVal (R6 , ( R2 '&' R3 )) )) by L464 , FUNCT_2:66;
L465:
now
let C173 being (Element of ( SetVal (R6 , R3) ));
thus L466: ( D40 . C173 ) = ( [: ( id ( SetVal (R6 , R2) ) ) , ( id ( SetVal (R6 , R3) ) ) :] . (C172 , C173) ) by FUNCT_5:69
.= [ ( ( id ( SetVal (R6 , R2) ) ) . C172 ) , ( ( id ( SetVal (R6 , R3) ) ) . C173 ) ] by FUNCT_3:75
.= [ ( ( id ( SetVal (R6 , R2) ) ) . C172 ) , ( ( ( Perm (C171 , R3) ) * ( ( Perm (C171 , R3) ) " ) ) . C173 ) ] by FUNCT_2:61
.= [ ( ( id ( SetVal (R6 , R2) ) ) . C172 ) , ( ( Perm (C171 , R3) ) . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) ] by FUNCT_2:15
.= [ ( ( ( Perm (C171 , R2) ) * ( ( Perm (C171 , R2) ) " ) ) . C172 ) , ( ( Perm (C171 , R3) ) . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) ] by FUNCT_2:61
.= [ ( ( Perm (C171 , R2) ) . ( ( ( Perm (C171 , R2) ) " ) . C172 ) ) , ( ( Perm (C171 , R3) ) . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) ] by FUNCT_2:15
.= ( [: ( Perm (C171 , R2) ) , ( Perm (C171 , R3) ) :] . (( ( ( Perm (C171 , R2) ) " ) . C172 ) , ( ( ( Perm (C171 , R3) ) " ) . C173 )) ) by FUNCT_3:75
.= ( ( Perm (C171 , ( R2 '&' R3 )) ) . [ ( ( ( Perm (C171 , R2) ) " ) . C172 ) , ( ( ( Perm (C171 , R3) ) " ) . C173 ) ] ) by L386
.= ( ( Perm (C171 , ( R2 '&' R3 )) ) . [ ( ( ( Perm (C171 , R2) ) " ) . C172 ) , ( ( id ( SetVal (R6 , R3) ) ) . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) ] ) by FUNCT_1:18
.= ( ( Perm (C171 , ( R2 '&' R3 )) ) . [ ( ( id ( SetVal (R6 , R2) ) ) . ( ( ( Perm (C171 , R2) ) " ) . C172 ) ) , ( ( id ( SetVal (R6 , R3) ) ) . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) ] ) by FUNCT_1:18
.= ( ( Perm (C171 , ( R2 '&' R3 )) ) . ( [: ( id ( SetVal (R6 , R2) ) ) , ( id ( SetVal (R6 , R3) ) ) :] . (( ( ( Perm (C171 , R2) ) " ) . C172 ) , ( ( ( Perm (C171 , R3) ) " ) . C173 )) ) ) by FUNCT_3:75
.= ( ( Perm (C171 , ( R2 '&' R3 )) ) . ( D42 . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) ) by FUNCT_5:69
.= ( ( ( Perm (C171 , ( R2 '&' R3 )) ) * D42 ) . ( ( ( Perm (C171 , R3) ) " ) . C173 ) ) by FUNCT_2:15
.= ( ( ( ( Perm (C171 , ( R2 '&' R3 )) ) * D42 ) * ( ( Perm (C171 , R3) ) " ) ) . C173 ) by FUNCT_2:15;
end;
thus L467: ( D37 . C172 ) = ( ( ( Perm (C171 , ( R2 '&' R3 )) ) * D42 ) * ( ( Perm (C171 , R3) ) " ) ) by L465 , FUNCT_2:63
.= ( ( Perm (C171 , ( R3 => ( R2 '&' R3 ) )) ) . ( D38 . ( ( ( Perm (C171 , R2) ) " ) . C172 ) ) ) by L408
.= ( ( ( Perm (C171 , ( R3 => ( R2 '&' R3 ) )) ) * D38 ) . ( ( ( Perm (C171 , R2) ) " ) . C172 ) ) by FUNCT_2:15
.= ( ( ( ( Perm (C171 , ( R3 => ( R2 '&' R3 ) )) ) * D38 ) * ( ( Perm (C171 , R2) ) " ) ) . C172 ) by FUNCT_2:15;
end;
thus L468: ( ( Perm (C171 , ( R2 => ( R3 => ( R2 '&' R3 ) ) )) ) . D37 ) = ( ( ( Perm (C171 , ( R3 => ( R2 '&' R3 ) )) ) * D38 ) * ( ( Perm (C171 , R2) ) " ) ) by L408
.= D37 by L460 , FUNCT_2:63;
end;
end;
registration
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R4 being (Element of ( HP-WFF ));
cluster ( ( R2 => ( R3 => R4 ) ) => ( ( R2 => R3 ) => ( R2 => R4 ) ) ) ->  canonical;
coherence
proof
deffunc H5(Function) = ( Frege $1 );
let R6 being SetValuation;
L470: (( SetVal (R6 , ( R2 => R3 )) ) = ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) & ( SetVal (R6 , ( R2 => R4 )) ) = ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R4) )) )) by L261;
L471: (for B167 being (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) )) holds H5(B167) in ( SetVal (R6 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ))
proof
let C174 being (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ));
L472: C174 is (Element of ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R4 )) )) )) by L261;
L473: C174 is (Element of ( Funcs (( SetVal (R6 , R2) ) , ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , R4) )) )) )) by L472 , L261;
L474: ( Frege C174 ) is (Function of ( SetVal (R6 , ( R2 => R3 )) ) , ( SetVal (R6 , ( R2 => R4 )) )) by L473 , L470 , L199;
L475: ( Frege C174 ) in ( Funcs (( SetVal (R6 , ( R2 => R3 )) ) , ( SetVal (R6 , ( R2 => R4 )) )) ) by L474 , FUNCT_2:8;
thus L476: ( Frege C174 ) in ( SetVal (R6 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ) by L475 , L261;
end;
consider C175 being (Function of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ) , ( SetVal (R6 , ( ( R2 => R3 ) => ( R2 => R4 ) )) )) such that L477: (for B168 being (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) )) holds ( C175 . B168 ) = H5(B168)) from FUNCT_2:sch 8(L471);
take C175;
let C176 being (Permutation of R6);
L478: C175 in ( Funcs (( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ) , ( SetVal (R6 , ( ( R2 => R3 ) => ( R2 => R4 ) )) )) ) by FUNCT_2:8;
L479: C175 in ( SetVal (R6 , ( ( R2 => ( R3 => R4 ) ) => ( ( R2 => R3 ) => ( R2 => R4 ) ) )) ) by L478 , L261;
thus L480: C175 in ( dom ( Perm (C176 , ( ( R2 => ( R3 => R4 ) ) => ( ( R2 => R3 ) => ( R2 => R4 ) ) )) ) ) by L479 , FUNCT_2:def 1;
L481:
now
reconsider D43 = ( ( Perm (C176 , ( R3 => R4 )) ) " ) as (Function of ( SetVal (R6 , ( R3 => R4 )) ) , ( SetVal (R6 , ( R3 => R4 )) ));
let C177 being (Element of ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) ));
set D44 = ( ( ( Perm (C176 , ( R2 => ( R3 => R4 ) )) ) " ) . C177 );
L482: ( SetVal (R6 , ( R3 => R4 )) ) = ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , R4) )) ) by L261;
L483: C177 in ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) );
L484: C177 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R4 )) )) ) by L483 , L261;
reconsider D45 = C177 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R4 )) )) by L484 , FUNCT_2:66;
L485: D44 = ( ( ( ( Perm (C176 , ( R3 => R4 )) ) " ) * D45 ) * ( Perm (C176 , R2) ) ) by L410;
reconsider D46 = ( Frege D44 ) as  Function-yielding (Function of ( SetVal (R6 , ( R2 => R3 )) ) , ( SetVal (R6 , ( R2 => R4 )) )) by L485 , L470 , L482 , L199;
set D47 = ( ( ( Perm (C176 , ( R2 => R4 )) ) * D46 ) * ( ( Perm (C176 , ( R2 => R3 )) ) " ) );
L486: ( product ( doms D45 ) ) = ( product ( ( SetVal (R6 , R2) ) --> ( SetVal (R6 , R3) ) ) ) by L482 , L38
.= ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by CARD_3:11;
L487: ( product ( doms D45 ) ) = ( SetVal (R6 , ( R2 => R3 )) ) by L486 , L261;
reconsider D48 = D47 as (ManySortedFunction of ( product ( doms C177 ) )) by L487;
L488: (for B169 being Function holds (B169 in ( product ( doms C177 ) ) implies ( D48 . B169 ) = ( C177 .. B169 )))
proof
L489: D44 in ( SetVal (R6 , ( R2 => ( R3 => R4 ) )) );
L490: D44 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , ( R3 => R4 )) )) ) by L489 , L261;
L491: D44 is (Function of ( SetVal (R6 , R2) ) , ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , R4) )) )) by L490 , L482 , FUNCT_2:66;
L492: ( product ( doms D44 ) ) = ( product ( ( SetVal (R6 , R2) ) --> ( SetVal (R6 , R3) ) ) ) by L491 , L38
.= ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by CARD_3:11
.= ( SetVal (R6 , ( R2 => R3 )) ) by L261;
reconsider D49 = D45 as (Function of ( SetVal (R6 , R2) ) , ( Funcs (( SetVal (R6 , R3) ) , ( SetVal (R6 , R4) )) )) by L261;
let C178 being Function;
assume that
L493: C178 in ( product ( doms C177 ) );
reconsider D50 = C178 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) by L486 , L493 , FUNCT_2:66;
L494: ( dom D49 ) = ( SetVal (R6 , R2) ) by FUNCT_2:def 1;
L495: ( dom ( D49 .. D50 ) ) = ( SetVal (R6 , R2) ) by L494 , PRALG_1:def 17;
L496: ( rng ( D49 .. D50 ) ) c= ( SetVal (R6 , R4) ) by L168;
reconsider D51 = ( D49 .. D50 ) as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R4) )) by L496 , L495 , FUNCT_2:def 1 , RELSET_1:4;
L497: ( D49 .. D50 ) is (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R4) )) by L495 , L496 , FUNCT_2:def 1 , RELSET_1:4;
L498: ( D49 .. D50 ) in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R4) )) ) by L497 , FUNCT_2:8;
L499: ( D49 .. D50 ) in ( SetVal (R6 , ( R2 => R4 )) ) by L498 , L261;
L500: ( ( ( ( Perm (C176 , R3) ) " ) * D50 ) * ( Perm (C176 , R2) ) ) in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by FUNCT_2:8;
L501: ( ( ( ( Perm (C176 , R3) ) " ) * C178 ) * ( Perm (C176 , R2) ) ) in ( product ( doms D44 ) ) by L500 , L492 , L261;
L502: ( ( ( Perm (C176 , ( R2 => R3 )) ) " ) . D50 ) in ( SetVal (R6 , ( R2 => R3 )) ) by L501 , L492 , L410;
L503: D43 = ( ( ( Perm (C176 , R3) ) => ( Perm (C176 , R4) ) ) " ) by L389
.= ( ( ( Perm (C176 , R3) ) " ) => ( ( Perm (C176 , R4) ) " ) ) by L242;
L504: ( D46 . ( ( ( Perm (C176 , ( R2 => R3 )) ) " ) . C178 ) ) = ( D46 . ( ( ( ( Perm (C176 , R3) ) " ) * D50 ) * ( Perm (C176 , R2) ) ) ) by L410
.= ( D44 .. ( ( ( ( Perm (C176 , R3) ) " ) * C178 ) * ( Perm (C176 , R2) ) ) ) by L501 , PRALG_2:def 2
.= ( ( ( D43 * D45 ) * ( Perm (C176 , R2) ) ) .. ( ( ( ( Perm (C176 , R3) ) " ) * C178 ) * ( Perm (C176 , R2) ) ) ) by L410
.= ( ( ( D43 * D49 ) .. ( ( ( Perm (C176 , R3) ) " ) * C178 ) ) * ( Perm (C176 , R2) ) ) by L141
.= ( ( ( ( Perm (C176 , R4) ) " ) * ( D49 .. D50 ) ) * ( Perm (C176 , R2) ) ) by L503 , L246
.= ( ( ( Perm (C176 , ( R2 => R4 )) ) " ) . D51 ) by L410;
thus L505: ( D48 . C178 ) = ( ( ( Perm (C176 , ( R2 => R4 )) ) * D46 ) . ( ( ( Perm (C176 , ( R2 => R3 )) ) " ) . C178 ) ) by L487 , L493 , FUNCT_2:15
.= ( ( Perm (C176 , ( R2 => R4 )) ) . ( ( ( Perm (C176 , ( R2 => R4 )) ) " ) . D51 ) ) by L502 , L504 , FUNCT_2:15
.= ( ( ( Perm (C176 , ( R2 => R4 )) ) * ( ( Perm (C176 , ( R2 => R4 )) ) " ) ) . D51 ) by L499 , FUNCT_2:15
.= ( ( id ( SetVal (R6 , ( R2 => R4 )) ) ) . D51 ) by FUNCT_2:61
.= ( C177 .. C178 ) by L499 , FUNCT_1:18;
end;
thus L506: ( C175 . C177 ) = ( Frege C177 ) by L477
.= ( ( ( Perm (C176 , ( R2 => R4 )) ) * D46 ) * ( ( Perm (C176 , ( R2 => R3 )) ) " ) ) by L488 , PRALG_2:def 2
.= ( ( Perm (C176 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ) . D46 ) by L408
.= ( ( Perm (C176 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ) . ( C175 . ( ( ( Perm (C176 , ( R2 => ( R3 => R4 ) )) ) " ) . C177 ) ) ) by L477
.= ( ( ( Perm (C176 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ) * C175 ) . ( ( ( Perm (C176 , ( R2 => ( R3 => R4 ) )) ) " ) . C177 ) ) by FUNCT_2:15
.= ( ( ( ( Perm (C176 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ) * C175 ) * ( ( Perm (C176 , ( R2 => ( R3 => R4 ) )) ) " ) ) . C177 ) by FUNCT_2:15;
end;
thus L507: C175 = ( ( ( Perm (C176 , ( ( R2 => R3 ) => ( R2 => R4 ) )) ) * C175 ) * ( ( Perm (C176 , ( R2 => ( R3 => R4 ) )) ) " ) ) by L481 , FUNCT_2:63
.= ( ( Perm (C176 , ( ( R2 => ( R3 => R4 ) ) => ( ( R2 => R3 ) => ( R2 => R4 ) ) )) ) . C175 ) by L408;
end;
end;
theorem
L509: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds ((R2 is  canonical & ( R2 => R3 ) is  canonical) implies R3 is  canonical)))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
assume that
L510: R2 is  canonical
and
L511: ( R2 => R3 ) is  canonical;
let R6 being SetValuation;
consider C179 being set such that L512: (for B170 being (Permutation of R6) holds C179 is_a_fixpoint_of ( Perm (B170 , R2) )) by L510 , L429;
set D52 = the (Permutation of R6);
L513: ( dom ( Perm (D52 , ( R2 => R3 )) ) ) = ( SetVal (R6 , ( R2 => R3 )) ) by FUNCT_2:52
.= ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L261;
consider C180 being set such that L514: (for B171 being (Permutation of R6) holds C180 is_a_fixpoint_of ( Perm (B171 , ( R2 => R3 )) )) by L511 , L429;
L515: C180 is_a_fixpoint_of ( Perm (D52 , ( R2 => R3 )) ) by L514;
L516: C180 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L515 , L513 , ABIAN:def 3;
reconsider D53 = C180 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) by L516 , FUNCT_2:66;
take ( D53 . C179 );
let C181 being (Permutation of R6);
L517: D53 is_a_fixpoint_of ( Perm (C181 , ( R2 => R3 )) ) by L514;
L518: C179 is_a_fixpoint_of ( Perm (C181 , R2) ) by L512;
thus L519: thesis by L518 , L517 , L415;
end;
theorem
L520: (for R2 being (Element of ( HP-WFF )) holds (R2 in ( HP_TAUT ) implies R2 is  canonical))
proof
let R2 being (Element of ( HP-WFF ));
set D54 = { R3 where R3 is (Element of ( HP-WFF )) : R3 is  canonical };
L521: D54 c= ( HP-WFF )
proof
let C182 being set;
assume L522: C182 in D54;
L523: (ex R2 being (Element of ( HP-WFF )) st (R2 = C182 & R2 is  canonical)) by L522;
thus L524: thesis by L523;
end;
reconsider D55 = D54 as (Subset of ( HP-WFF )) by L521;
L525: D55 is  Hilbert_theory
proof
thus L526: ( VERUM ) in D55;
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R4 being (Element of ( HP-WFF ));
thus L527: ( R2 => ( R3 => R2 ) ) in D55;
thus L528: ( ( R2 => ( R3 => R4 ) ) => ( ( R2 => R3 ) => ( R2 => R4 ) ) ) in D55;
thus L529: ( ( R2 '&' R3 ) => R2 ) in D55;
thus L530: ( ( R2 '&' R3 ) => R3 ) in D55;
thus L531: ( R2 => ( R3 => ( R2 '&' R3 ) ) ) in D55;
assume L532: R2 in D55;
L533: (ex R5 being (Element of ( HP-WFF )) st (R5 = R2 & R5 is  canonical)) by L532;
assume L534: ( R2 => R3 ) in D55;
L535: (ex R5 being (Element of ( HP-WFF )) st (R5 = ( R2 => R3 ) & R5 is  canonical)) by L534;
L536: R3 is  canonical by L535 , L533 , L509;
thus L537: thesis by L536;
end;
L538: ( HP_TAUT ) c= D55 by L525 , HILBERT1:13;
assume L539: R2 in ( HP_TAUT );
L540: R2 in D55 by L539 , L538;
L541: (ex R3 being (Element of ( HP-WFF )) st (R2 = R3 & R3 is  canonical)) by L540;
thus L542: thesis by L541;
end;
registration
cluster  canonical for (Element of ( HP-WFF ));
existence
proof
take ( VERUM );
thus L543: thesis;
end;
end;
begin
definition
let R2 being (Element of ( HP-WFF ));
attr R2 is  pseudo-canonical
means
:L545: (for R6 being SetValuation holds (for B172 being (Permutation of R6) holds (ex B173 being set st B173 is_a_fixpoint_of ( Perm (B172 , R2) ))));
end;
registration
cluster  canonical ->  pseudo-canonical for (Element of ( HP-WFF ));
coherence
proof
let R2 being (Element of ( HP-WFF ));
assume L547: R2 is  canonical;
let R6 being SetValuation;
consider C183 being set such that L548: (for B174 being (Permutation of R6) holds C183 is_a_fixpoint_of ( Perm (B174 , R2) )) by L547 , L429;
let C184 being (Permutation of R6);
take C183;
thus L549: thesis by L548;
end;
end;
theorem
L551: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds ((R2 is  pseudo-canonical & ( R2 => R3 ) is  pseudo-canonical) implies R3 is  pseudo-canonical)))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
assume that
L552: R2 is  pseudo-canonical
and
L553: ( R2 => R3 ) is  pseudo-canonical;
let R6 being SetValuation;
let C185 being (Permutation of R6);
consider C186 being set such that L554: C186 is_a_fixpoint_of ( Perm (C185 , R2) ) by L552 , L545;
consider C187 being set such that L555: C187 is_a_fixpoint_of ( Perm (C185 , ( R2 => R3 )) ) by L553 , L545;
L556: ( dom ( Perm (C185 , ( R2 => R3 )) ) ) = ( SetVal (R6 , ( R2 => R3 )) ) by FUNCT_2:52
.= ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L261;
L557: C187 in ( Funcs (( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) ) by L556 , L555 , ABIAN:def 3;
reconsider D56 = C187 as (Function of ( SetVal (R6 , R2) ) , ( SetVal (R6 , R3) )) by L557 , FUNCT_2:66;
take ( D56 . C186 );
thus L558: thesis by L554 , L555 , L415;
end;
theorem
L559: (for R2 being (Element of ( HP-WFF )) holds (for R3 being (Element of ( HP-WFF )) holds (for R6 being SetValuation holds (for B175 being (Permutation of R6) holds (((ex B176 being set st B176 is_a_fixpoint_of ( Perm (B175 , R2) )) & (not (ex B177 being set st B177 is_a_fixpoint_of ( Perm (B175 , R3) )))) implies (not ( R2 => R3 ) is  pseudo-canonical))))))
proof
let R2 being (Element of ( HP-WFF ));
let R3 being (Element of ( HP-WFF ));
let R6 being SetValuation;
let C188 being (Permutation of R6);
given C189 being set such that
L560: C189 is_a_fixpoint_of ( Perm (C188 , R2) );

assume L561: (for B178 being set holds (not B178 is_a_fixpoint_of ( Perm (C188 , R3) )));
assume L562: ( R2 => R3 ) is  pseudo-canonical;
consider C190 being set such that L563: C190 is_a_fixpoint_of ( Perm (C188 , ( R2 => R3 )) ) by L562 , L545;
L564: C190 in ( dom ( Perm (C188 , ( R2 => R3 )) ) ) by L563 , ABIAN:def 3;
L565: C190 in ( SetVal (R6 , ( R2 => R3 )) ) by L564 , FUNCT_2:def 1;
reconsider D57 = C190 as Function by L565;
L566: ( D57 . C189 ) is_a_fixpoint_of ( Perm (C188 , R3) ) by L560 , L563 , L415;
thus L567: contradiction by L566 , L561;
end;
theorem
L568: (for B179 , B180 being (Element of ( NAT )) holds (B179 <> B180 implies ( ( ( ( prop B179 ) => ( prop B180 ) ) => ( prop B179 ) ) => ( prop B179 ) ) is non  pseudo-canonical))
proof
let C191 , C192 being (Element of ( NAT ));
assume that
L569: C191 <> C192;
set D58 = { ( (( 0 ) , 1) --> (B181 , B182) ) where B181 , B182 is (Element of ( INT )) : (B181 < B182 or (B181 is  even & B181 = B182)) };
set D59 = ( product ( (( 0 ) , 1) --> (( INT ) , ( INT )) ) );
L570: D58 c= D59
proof
let C193 being set;
assume L571: C193 in D58;
L572: (ex B183 , B184 being (Element of ( INT )) st (C193 = ( (( 0 ) , 1) --> (B183 , B184) ) & (B183 < B184 or (B183 is  even & B183 = B184)))) by L571;
thus L573: thesis by L572 , L74;
end;
reconsider D60 = D58 as (Subset of D59) by L570;
set D61 = ( (( 0 ) , 1) --> (1 , ( 0 )) );
L574: (not C192 in ( dom ( C191 .--> 2 ) )) by L569 , FUNCOP_1:75;
reconsider D62 = D61 as (Permutation of 2) by L107;
defpred S8[ set , set ] means (ex B185 being Integer st ($1 = B185 & $2 = ( B185 + 1 )));
set D63 = ( ( ( NAT ) --> ( INT ) ) +* ( C191 .--> 2 ) );
reconsider D64 = D63 as SetValuation;
L575: C191 in ( dom ( C191 .--> 2 ) ) by FUNCOP_1:74;
L576: 2 = ( ( C191 .--> 2 ) . C191 ) by FUNCOP_1:72
.= ( D64 . C191 ) by L575 , FUNCT_4:13
.= ( SetVal (D64 , ( prop C191 )) ) by L261;
L577: (for B186 being (Element of ( INT )) holds (ex B187 being (Element of ( INT )) st S8[ B186 , B187 ]))
proof
let C194 being (Element of ( INT ));
reconsider D65 = C194 as Integer;
reconsider D66 = ( D65 + 1 ) as (Element of ( INT )) by INT_1:def 2;
take D66;
thus L578: thesis;
end;
consider C195 being (Function of ( INT ) , ( INT )) such that L579: (for B188 being (Element of ( INT )) holds S8[ B188 , ( C195 . B188 ) ]) from FUNCT_2:sch 3(L577);
L580: ( dom C195 ) = ( INT ) by FUNCT_2:def 1;
L581: (for B189 being set holds (B189 in ( INT ) iff (ex B190 being set st (B190 in ( dom C195 ) & B189 = ( C195 . B190 )))))
proof
let C196 being set;
thus L582:now
assume L583: C196 in ( INT );
reconsider D67 = C196 as Integer by L583;
reconsider D68 = ( D67 - 1 ) as set;
take D69 = D68;
thus L584: D69 in ( dom C195 ) by L580 , INT_1:def 2;
L585: (ex B191 being Integer st (D69 = B191 & ( C195 . D69 ) = ( B191 + 1 ))) by L584 , L579 , L580;
thus L586: C196 = ( C195 . D69 ) by L585 , XCMPLX_1:27;
end;
given C197 being set such that
L587: C197 in ( dom C195 )
and
L588: C196 = ( C195 . C197 );

L589: (ex B192 being Integer st (C197 = B192 & ( C195 . C197 ) = ( B192 + 1 ))) by L579 , L580 , L587;
thus L590: thesis by L589 , L588 , INT_1:def 2;
end;
L591: ( rng C195 ) = ( INT ) by L581 , FUNCT_1:def 3;
L592: C195 is  one-to-one
proof
let C198 , C199 being set;
assume L593: (C198 in ( dom C195 ) & C199 in ( dom C195 ));
reconsider D70 = C198 , D71 = C199 as (Element of ( INT )) by L593 , FUNCT_2:def 1;
assume L594: ( C195 . C198 ) = ( C195 . C199 );
L595: ((ex B193 being Integer st (D70 = B193 & ( C195 . D70 ) = ( B193 + 1 ))) & (ex B194 being Integer st (D71 = B194 & ( C195 . D71 ) = ( B194 + 1 )))) by L579;
thus L596: thesis by L595 , L594 , XCMPLX_1:2;
end;
L597: ( SetVal (D64 , ( prop C192 )) ) = ( D64 . C192 ) by L261
.= ( ( ( NAT ) --> ( INT ) ) . C192 ) by L574 , FUNCT_4:11
.= ( INT ) by FUNCOP_1:7;
L598: D59 = ( product ( 2 --> ( INT ) ) ) by CARD_1:50 , FUNCT_4:65
.= ( Funcs (2 , ( INT )) ) by CARD_3:11
.= ( SetVal (D64 , ( ( prop C191 ) => ( prop C192 ) )) ) by L576 , L597 , L261;
reconsider D72 = ( chi (D60 , D59) ) as (Function of ( SetVal (D64 , ( ( prop C191 ) => ( prop C192 ) )) ) , ( SetVal (D64 , ( prop C191 )) )) by L598 , L576 , CARD_1:50;
L599: C191 in ( dom ( C191 .--> D62 ) ) by FUNCOP_1:74;
reconsider D73 = C195 as (Permutation of ( INT )) by L592 , L591 , FUNCT_2:57;
set D74 = ( ( ( NAT ) --> D73 ) +* ( C191 .--> D62 ) );
L600: ( dom D74 ) = ( ( dom ( ( NAT ) --> D73 ) ) \/ ( dom ( C191 .--> D62 ) ) ) by FUNCT_4:def 1
.= ( ( dom ( ( NAT ) --> D73 ) ) \/ { C191 } ) by FUNCOP_1:13
.= ( ( NAT ) \/ { C191 } ) by FUNCOP_1:13
.= ( NAT ) by ZFMISC_1:40;
L601: (for R1 being (Element of ( NAT )) holds ( D74 . R1 ) is (Permutation of ( D64 . R1 )))
proof
let R1 being (Element of ( NAT ));
per cases ;
suppose L602: R1 = C191;

L603: R1 in ( dom ( C191 .--> 2 ) ) by L602 , FUNCOP_1:74;
L604: ( D64 . R1 ) = ( ( C191 .--> 2 ) . C191 ) by L603 , L602 , FUNCT_4:13
.= 2 by FUNCOP_1:72;
L605: R1 in ( dom ( C191 .--> D62 ) ) by L602 , FUNCOP_1:74;
L606: ( D74 . R1 ) = ( ( C191 .--> D62 ) . C191 ) by L605 , L602 , FUNCT_4:13
.= D62 by FUNCOP_1:72;
thus L607: thesis by L606 , L604;
end;
suppose L608: R1 <> C191;

L609: (not R1 in ( dom ( C191 .--> 2 ) )) by L608 , FUNCOP_1:75;
L610: ( D64 . R1 ) = ( ( ( NAT ) --> ( INT ) ) . R1 ) by L609 , FUNCT_4:11
.= ( INT ) by FUNCOP_1:7;
L611: (not R1 in ( dom ( C191 .--> D62 ) )) by L608 , FUNCOP_1:75;
L612: ( D74 . R1 ) = ( ( ( NAT ) --> D73 ) . R1 ) by L611 , FUNCT_4:11
.= D73 by FUNCOP_1:7;
thus L613: thesis by L612 , L610;
end;
end;
reconsider D75 = D74 as (Permutation of D64) by L601 , L600 , L315;
L615: ( Perm (D75 , ( prop C191 )) ) = ( D75 . C191 ) by L320
.= ( ( C191 .--> D62 ) . C191 ) by L599 , FUNCT_4:13
.= D62 by FUNCOP_1:72;
L616: D72 is_a_fixpoint_of ( Perm (D75 , ( ( ( prop C191 ) => ( prop C192 ) ) => ( prop C191 ) )) )
proof
set D76 = ( Perm (D75 , ( ( ( prop C191 ) => ( prop C192 ) ) => ( prop C191 ) )) );
L617: D72 in ( Funcs (( SetVal (D64 , ( ( prop C191 ) => ( prop C192 ) )) ) , ( SetVal (D64 , ( prop C191 )) )) ) by FUNCT_2:8;
L618: D72 in ( SetVal (D64 , ( ( ( prop C191 ) => ( prop C192 ) ) => ( prop C191 ) )) ) by L617 , L261;
thus L619: D72 in ( dom D76 ) by L618 , FUNCT_2:def 1;
L620: ( rng ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) = ( dom ( ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) " ) ) by FUNCT_1:32
.= D59 by L598 , FUNCT_2:def 1
.= ( dom D72 ) by FUNCT_2:def 1;
L621: ( dom ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) ) = ( dom ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) by L620 , RELAT_1:27
.= ( rng ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) ) by FUNCT_1:32
.= D59 by L598 , FUNCT_2:def 3
.= ( dom ( chi (( D60 ` ) , D59) ) ) by FUNCT_3:def 3;
L622: (for B195 being set holds (B195 in ( dom ( chi (( D60 ` ) , D59) ) ) implies ( ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) . B195 ) = ( ( chi (( D60 ` ) , D59) ) . B195 )))
proof
L623: ( dom ( D73 " ) ) = ( INT ) by L591 , FUNCT_1:32;
let C200 being set;
L624: (not C192 in ( dom ( C191 .--> D62 ) )) by L569 , FUNCOP_1:75;
assume L625: C200 in ( dom ( chi (( D60 ` ) , D59) ) );
L626: C200 in D59 by L625 , FUNCT_3:def 3;
L627: C200 in ( Funcs (( SetVal (D64 , ( prop C191 )) ) , ( SetVal (D64 , ( prop C192 )) )) ) by L626 , L598 , L261;
reconsider D77 = C200 as (Function of ( SetVal (D64 , ( prop C191 )) ) , ( SetVal (D64 , ( prop C192 )) )) by L627 , FUNCT_2:66;
consider C201 , C202 being (Element of ( INT )) such that L628: D77 = ( (( 0 ) , 1) --> (C201 , C202) ) by L576 , L597 , L81;
reconsider D78 = C201 , D79 = C202 as Integer;
L629: ( D79 - 1 ) in ( dom D73 ) by L580 , INT_1:def 2;
L630: (ex B196 being Integer st (( D79 - 1 ) = B196 & ( D73 . ( D79 - 1 ) ) = ( B196 + 1 ))) by L629 , L579 , L580;
L631: ( D73 . ( D79 - 1 ) ) = D79 by L630 , XCMPLX_1:27;
L632: ( D78 - 1 ) in ( dom D73 ) by L580 , INT_1:def 2;
L633: (ex B197 being Integer st (( D78 - 1 ) = B197 & ( D73 . ( D78 - 1 ) ) = ( B197 + 1 ))) by L632 , L579 , L580;
L634: ( D73 . ( D78 - 1 ) ) = D78 by L633 , XCMPLX_1:27;
L635: ( ( D73 " ) . D78 ) = ( D78 - 1 ) by L634 , L632 , FUNCT_1:34;
L636: ( Perm (D75 , ( prop C192 )) ) = ( D75 . C192 ) by L320
.= ( ( ( NAT ) --> D73 ) . C192 ) by L624 , FUNCT_4:11
.= D73 by FUNCOP_1:7;
L637: ( ( ( Perm (D75 , ( prop C192 )) ) " ) * D77 ) = ( (( 0 ) , 1) --> (( ( D73 " ) . D78 ) , ( ( D73 " ) . D79 )) ) by L636 , L628 , L623 , L95
.= ( (( 0 ) , 1) --> (( D78 - 1 ) , ( D79 - 1 )) ) by L635 , L629 , L631 , FUNCT_1:34;
L638: ( ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) . C200 ) = ( D72 . ( ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) . C200 ) ) by L621 , L625 , FUNCT_1:12
.= ( D72 . ( ( ( ( Perm (D75 , ( prop C192 )) ) " ) * D77 ) * ( Perm (D75 , ( prop C191 )) ) ) ) by L410
.= ( D72 . ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) ) by L615 , L637 , L85;
per cases ;
suppose L639: C200 in D60;

consider C203 , C204 being (Element of ( INT )) such that L640: C200 = ( (( 0 ) , 1) --> (C203 , C204) ) and L641: (C203 < C204 or (C203 is  even & C203 = C204)) by L639;
L642: (C203 = D78 & C204 = D79) by L628 , L640 , L69;
L643:
now
assume L644: ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) in D60;
consider C205 , C206 being (Element of ( INT )) such that L645: ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) = ( (( 0 ) , 1) --> (C205 , C206) ) and L646: (C205 < C206 or (C205 is  even & C205 = C206)) by L644;
L647: (C205 = ( D79 - 1 ) & C206 = ( D78 - 1 )) by L645 , L69;
per cases  by L646;
suppose L648: C205 < C206;

thus L649: contradiction by L648 , L641 , L642 , L647 , XREAL_1:9;
end;
suppose L650: (C205 is  even & C205 = C206);

thus L651: contradiction by L650 , L641 , L642 , L647 , XCMPLX_1:19;
end;
end;
L653: C200 in ( ( D60 ` ) ` ) by L639;
L654: (( D79 - 1 ) in ( INT ) & ( D78 - 1 ) in ( INT )) by INT_1:def 2;
L655: ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) in D59 by L654 , L74;
L656: ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) in ( D59 \ D60 ) by L655 , L643 , XBOOLE_0:def 5;
thus L657: ( ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) . C200 ) = ( 0 ) by L656 , L638 , FUNCT_3:37
.= ( ( chi (( D60 ` ) , D59) ) . C200 ) by L653 , FUNCT_3:37;
end;
suppose L658: (not C200 in D60);

L659: C200 in D59 by L628 , L74;
L660: C200 in ( D59 \ D60 ) by L659 , L658 , XBOOLE_0:def 5;
L661: ( D79 - 1 ) is (Element of ( INT )) by INT_1:def 2;
L662: (D78 is  odd or D78 <> D79) by L628 , L658;
L663: ( D78 - 1 ) is (Element of ( INT )) by INT_1:def 2;
L664: D78 >= D79 by L628 , L658;
L665:
now
per cases  by L664 , L662 , XXREAL_0:1;
suppose L666: D78 > D79;

L667: ( D79 - 1 ) < ( D78 - 1 ) by L666 , XREAL_1:9;
thus L668: ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) in D60 by L667 , L661 , L663;
end;
suppose L669: (D78 = D79 & D78 is  odd);

thus L670: ( (( 0 ) , 1) --> (( D79 - 1 ) , ( D78 - 1 )) ) in D60 by L669 , L661;
end;
end;
thus L672: ( ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) . C200 ) = 1 by L665 , L638 , FUNCT_3:def 3
.= ( ( chi (( D60 ` ) , D59) ) . C200 ) by L660 , FUNCT_3:def 3;
end;
end;
L674: ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) = ( chi (( D60 ` ) , D59) ) by L622 , L621 , FUNCT_1:2;
thus L675: D72 = ( ( Perm (D75 , ( prop C191 )) ) * ( D72 * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) ) by L674 , L615 , L66
.= ( ( ( Perm (D75 , ( prop C191 )) ) * D72 ) * ( ( Perm (D75 , ( ( prop C191 ) => ( prop C192 ) )) ) " ) ) by RELAT_1:36
.= ( D76 . D72 ) by L408;
end;
L676: (for B198 being set holds (not B198 is_a_fixpoint_of ( Perm (D75 , ( prop C191 )) )))
proof
let C207 being set;
L677: C191 in ( dom ( C191 .--> 2 ) ) by FUNCOP_1:74;
L678: ( D64 . C191 ) = ( ( C191 .--> 2 ) . C191 ) by L677 , FUNCT_4:13;
L679: ( D64 . C191 ) = 2 by L678 , FUNCOP_1:72;
assume L680: C207 in ( dom ( Perm (D75 , ( prop C191 )) ) );
L681: C207 in ( SetVal (D64 , ( prop C191 )) ) by L680 , FUNCT_2:def 1;
L682: C207 in ( D64 . C191 ) by L681 , L261;
L683: (C207 = ( 0 ) or C207 = 1) by L682 , L679 , CARD_1:50 , TARSKI:def 2;
thus L684: thesis by L683 , L615 , FUNCT_4:63;
end;
thus L685: thesis by L676 , L616 , L559;
end;
