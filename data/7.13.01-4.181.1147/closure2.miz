:: On the Closure Operator and the Closure System of Many Sorted Sets
::  by Artur Korni{\l}owicz
::
:: Received February 7, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies PBOOLE, FUNCT_1, TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, ZFMISC_1,
      FUNCT_2, CARD_3, FINSET_1, COMPLEX1, SETFAM_1, FUNCT_4, MSSUBFAM,
      FUNCOP_1, RELAT_2, MSAFREE2, BINOP_1, YELLOW_6, STRUCT_0, MSUALG_1,
      PRE_TOPC, CLOSURE2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, STRUCT_0, SETFAM_1, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, FUNCOP_1, FINSET_1, FUNCT_4, PBOOLE, CARD_3,
      MSUALG_1, MBOOLEAN, MSSUBFAM;
 constructors SETFAM_1, FUNCT_4, MSSUBFAM, MSUALG_1, CARD_3, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1,
      FINSET_1, PBOOLE, MSUALG_1;
 requirements SUBSET, BOOLE;
 definitions XBOOLE_0, FUNCT_1, MSUALG_1, PBOOLE, CARD_3, TARSKI, FUNCOP_1;
 theorems FUNCOP_1, ENUMSET1, FUNCT_1, FUNCT_2, FUNCT_4, MBOOLEAN, MSUALG_1,
      PBOOLE, PZFMISC1, SETFAM_1, TARSKI, MSSUBFAM, ZFMISC_1, XBOOLE_0,
      XBOOLE_1, PARTFUN1, RELAT_1;
 schemes FRAENKEL, FUNCT_1, FUNCT_2, DOMAIN_1, XBOOLE_0;

begin
notation
let R3 being set;
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
synonym R4 in' R5 for R4 in R5;
end;
notation
let R3 being set;
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
synonym R4 c=' R5 for R4 c= R5;
end;
theorem
L3: (for B1 being non  empty set holds (for B2 , B3 being (Element of B1) holds (B2 c= B3 implies ( ( id B1 ) . B2 ) c= ( ( id B1 ) . B3 ))))
proof
let C1 being non  empty set;
let C2 , C3 being (Element of C1);
assume that
L4: C2 c= C3;
L5: ( ( id C1 ) . C2 ) = C2 by FUNCT_1:18;
thus L6: thesis by L5 , L4 , FUNCT_1:18;
end;
theorem
L7: (for B4 being non  empty set holds (for B5 being (ManySortedSet of B4) holds (for B6 being (ManySortedSubset of B5) holds ( rng B6 ) c= ( union ( rng ( bool B5 ) ) ))))
proof
let C4 being non  empty set;
let C5 being (ManySortedSet of C4);
let C6 being (ManySortedSubset of C5);
let C7 being set;
assume L8: C7 in ( rng C6 );
consider R1 being set such that L9: R1 in C4 and L10: C7 = ( C6 . R1 ) by L8 , PBOOLE:138;
L11: (R1 in ( dom ( bool C5 ) ) & ( bool ( C5 . R1 ) ) = ( ( bool C5 ) . R1 )) by L9 , MBOOLEAN:def 1 , PARTFUN1:def 2;
L12: ( bool ( C5 . R1 ) ) in ( rng ( bool C5 ) ) by L11 , FUNCT_1:def 3;
L13: C6 c= C5 by PBOOLE:def 18;
L14: C6 in ( bool C5 ) by L13 , MBOOLEAN:18;
L15: ( C6 . R1 ) in ( ( bool C5 ) . R1 ) by L14 , L9 , PBOOLE:def 1;
L16: C7 in ( bool ( C5 . R1 ) ) by L15 , L9 , L10 , MBOOLEAN:def 1;
thus L17: thesis by L16 , L12 , TARSKI:def 4;
end;
begin
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
defpred S1[ set ] means $1 is (ManySortedSubset of R6);
func Bool R6 -> set means 
:L18: (for R2 being set holds (R2 in it iff R2 is (ManySortedSubset of R6)));
existence
proof
per cases ;
suppose L19: R3 is non  empty;

consider C8 being set such that L20: (for B7 being set holds (B7 in C8 iff (B7 in ( Funcs (R3 , ( union ( rng ( bool R6 ) ) )) ) & S1[ B7 ]))) from XBOOLE_0:sch 1;
take C8;
thus L21: (for R2 being set holds (R2 in C8 iff R2 is (ManySortedSubset of R6)))
proof
let R2 being set;
thus L22: (R2 in C8 implies R2 is (ManySortedSubset of R6)) by L20;
assume L23: R2 is (ManySortedSubset of R6);
L24:
now
reconsider D1 = R2 as (ManySortedSubset of R6) by L23;
L25: (( dom D1 ) = R3 & ( rng D1 ) c= ( union ( rng ( bool R6 ) ) )) by L19 , L7 , PARTFUN1:def 2;
thus L26: R2 in ( Funcs (R3 , ( union ( rng ( bool R6 ) ) )) ) by L25 , FUNCT_2:def 2;
thus L27: S1[ R2 ] by L23;
end;
thus L28: thesis by L24 , L20;
end;

end;
suppose L22: R3 is  empty;

take { ( [[0]] ( {} ) ) };
thus L23: (for R2 being set holds (R2 in { ( [[0]] ( {} ) ) } iff R2 is (ManySortedSubset of R6)))
proof
let R2 being set;
thus L24: (R2 in { ( [[0]] ( {} ) ) } implies R2 is (ManySortedSubset of R6))
proof
reconsider D2 = R6 as (ManySortedSet of ( {} )) by L22;
assume L25: R2 in { ( [[0]] ( {} ) ) };
reconsider D3 = ( [[0]] ( {} ) ) as (ManySortedSubset of D2) by PBOOLE:def 18;
L26: D3 is (ManySortedSubset of R6) by L22;
thus L27: thesis by L26 , L25 , TARSKI:def 1;
end;

assume L28: R2 is (ManySortedSubset of R6);
consider C9 being (ManySortedSubset of R6) such that L29: C9 = R2 by L28;
L30: C9 = ( [[0]] ( {} ) ) by L22;
thus L31: thesis by L30 , L29 , TARSKI:def 1;
end;

end;
end;
uniqueness
proof
thus L25: (for B8 , B9 being set holds (((for B10 being set holds (B10 in B8 iff S1[ B10 ])) & (for B11 being set holds (B11 in B9 iff S1[ B11 ]))) implies B8 = B9)) from XBOOLE_0:sch 3;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster ( Bool R6 ) -> non  empty  functional  with_common_domain;
coherence
proof
L27: R6 is (ManySortedSubset of R6) by PBOOLE:def 18;
thus L28: ( Bool R6 ) is non  empty by L27 , L18;
thus L29: ( Bool R6 ) is  functional
proof
let R2 being set;
assume L30: R2 in ( Bool R6 );
thus L31: thesis by L30 , L18;
end;

let C10 , C11 being Function;
assume that
L32: C10 in ( Bool R6 )
and
L33: C11 in ( Bool R6 );
L34: C11 is (ManySortedSubset of R6) by L33 , L18;
L35: C10 is (ManySortedSubset of R6) by L32 , L18;
thus L36: ( dom C10 ) = R3 by L35 , PARTFUN1:def 2
.= ( dom C11 ) by L34 , PARTFUN1:def 2;
end;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
mode SubsetFamily of R6
 is (Subset of ( Bool R6 ));
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
redefine func Bool R6 -> (SubsetFamily of R6);

coherence
proof
L39: ( Bool R6 ) c= ( Bool R6 );
thus L40: thesis by L39;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster non  empty  functional  with_common_domain for (SubsetFamily of R6);
existence
proof
take ( Bool R6 );
thus L42: thesis;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  empty  finite for (SubsetFamily of R6);
existence
proof
reconsider D4 = ( {} ) as (SubsetFamily of R6) by XBOOLE_1:2;
take D4;
thus L44: thesis;
end;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let C12 being non  empty (SubsetFamily of R6);
redefine mode Element of C12
 -> (ManySortedSubset of R6);
coherence
proof
let C13 being (Element of C12);
thus L46: thesis by L18;
end;
end;
theorem
L48: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (for R10 being (SubsetFamily of R6) holds ( R9 \/ R10 ) is (SubsetFamily of R6)))));
theorem
L49: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (for R10 being (SubsetFamily of R6) holds ( R9 /\ R10 ) is (SubsetFamily of R6)))));
theorem
L50: (for R2 being set holds (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds ( R9 \ R2 ) is (SubsetFamily of R6)))));
theorem
L51: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (for R10 being (SubsetFamily of R6) holds ( R9 \+\ R10 ) is (SubsetFamily of R6)))));
theorem
L52: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds (for R6 being (ManySortedSet of R3) holds (R4 c= R6 implies { R4 } is (SubsetFamily of R6)))))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
let R6 being (ManySortedSet of R3);
assume L53: R4 c= R6;
L54: R4 is (ManySortedSubset of R6) by L53 , PBOOLE:def 18;
L55: R4 in ( Bool R6 ) by L54 , L18;
thus L56: thesis by L55 , ZFMISC_1:31;
end;
theorem
L57: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds (for R5 being (ManySortedSet of R3) holds (for R6 being (ManySortedSet of R3) holds ((R4 c= R6 & R5 c= R6) implies { R4 , R5 } is (SubsetFamily of R6))))))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
let R6 being (ManySortedSet of R3);
assume L58: (R4 c= R6 & R5 c= R6);
L59: ({ R4 } is (SubsetFamily of R6) & { R5 } is (SubsetFamily of R6)) by L58 , L52;
L60: ( { R4 } \/ { R5 } ) is (SubsetFamily of R6) by L59 , L48;
thus L61: thesis by L60 , ENUMSET1:1;
end;
theorem
L62: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds (for R12 being (Element of ( Bool R6 )) holds ( R11 /\ R12 ) in ( Bool R6 )))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
let R12 being (Element of ( Bool R6 ));
L63: (R11 c= R6 & R12 c= R6) by PBOOLE:def 18;
L64: ( R11 /\ R12 ) c= ( R6 /\ R6 ) by L63 , PBOOLE:21;
L65: ( R11 /\ R12 ) is (ManySortedSubset of R6) by L64 , PBOOLE:def 18;
thus L66: thesis by L65 , L18;
end;
theorem
L67: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds (for R12 being (Element of ( Bool R6 )) holds ( R11 \/ R12 ) in ( Bool R6 )))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
let R12 being (Element of ( Bool R6 ));
L68: (R11 c= R6 & R12 c= R6) by PBOOLE:def 18;
L69: ( R11 \/ R12 ) c= ( R6 \/ R6 ) by L68 , PBOOLE:20;
L70: ( R11 \/ R12 ) is (ManySortedSubset of R6) by L69 , PBOOLE:def 18;
thus L71: thesis by L70 , L18;
end;
theorem
L72: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds ( R11 \ R4 ) in ( Bool R6 )))))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
L73: R11 c= R6 by PBOOLE:def 18;
L74: ( R11 \ R4 ) c= R6 by L73 , MBOOLEAN:15;
L75: ( R11 \ R4 ) is (ManySortedSubset of R6) by L74 , PBOOLE:def 18;
thus L76: thesis by L75 , L18;
end;
theorem
L77: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds (for R12 being (Element of ( Bool R6 )) holds ( R11 \+\ R12 ) in ( Bool R6 )))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
let R12 being (Element of ( Bool R6 ));
L78: R12 c= R6 by PBOOLE:def 18;
L79: ( R12 \ R11 ) c= R6 by L78 , MBOOLEAN:15;
L80: R11 c= R6 by PBOOLE:def 18;
L81: ( R11 \ R12 ) c= R6 by L80 , MBOOLEAN:15;
L82: ( R11 \+\ R12 ) c= R6 by L81 , L79 , PBOOLE:91;
L83: ( R11 \+\ R12 ) is (ManySortedSubset of R6) by L82 , PBOOLE:def 18;
thus L84: thesis by L83 , L18;
end;
begin
definition
let C14 being  functional set;
func |.C14 .| -> Function means 
:L85: (ex B12 being non  empty  functional set st (B12 = C14 & ( dom it ) = ( meet { ( dom B13 ) where B13 is (Element of B12) : (not contradiction) } ) & (for R1 being set holds (R1 in ( dom it ) implies ( it . R1 ) = { ( B14 . R1 ) where B14 is (Element of B12) : (not contradiction) })))) if C14 <> ( {} ) otherwise it = ( {} );
existence
proof
thus L86: (C14 <> ( {} ) implies (ex B15 being Function st (ex B16 being non  empty  functional set st (B16 = C14 & ( dom B15 ) = ( meet { ( dom B17 ) where B17 is (Element of B16) : (not contradiction) } ) & (for R1 being set holds (R1 in ( dom B15 ) implies ( B15 . R1 ) = { ( B18 . R1 ) where B18 is (Element of B16) : (not contradiction) }))))))
proof
assume L87: C14 <> ( {} );
consider C15 being non  empty  functional set such that L88: C15 = C14 by L87;
deffunc H1(set) = { ( B19 . $1 ) where B19 is (Element of C15) : (not contradiction) };
consider C16 being Function such that L89: (( dom C16 ) = ( meet { ( dom B20 ) where B20 is (Element of C15) : (not contradiction) } ) & (for R1 being set holds (R1 in ( meet { ( dom B21 ) where B21 is (Element of C15) : (not contradiction) } ) implies ( C16 . R1 ) = H1(R1)))) from FUNCT_1:sch 3;
take C16;
take C15;
thus L90: thesis by L88 , L89;
end;

thus L91: thesis;
end;
uniqueness
proof
let C17 , C18 being Function;
defpred S2[ Function ] means (ex B22 being non  empty  functional set st (B22 = C14 & ( dom $1 ) = ( meet { ( dom B23 ) where B23 is (Element of B22) : (not contradiction) } ) & (for R1 being set holds (R1 in ( dom $1 ) implies ( $1 . R1 ) = { ( B24 . R1 ) where B24 is (Element of B22) : (not contradiction) }))));
thus L92: ((C14 <> ( {} ) & S2[ C17 ] & S2[ C18 ]) implies C17 = C18)
proof
assume that
L93: C14 <> ( {} )
and
L94: S2[ C17 ]
and
L95: S2[ C18 ];
consider C19 being non  empty  functional set such that L96: C19 = C14 and L97: ( dom C17 ) = ( meet { ( dom B25 ) where B25 is (Element of C19) : (not contradiction) } ) and L98: (for R1 being set holds (R1 in ( dom C17 ) implies ( C17 . R1 ) = { ( B26 . R1 ) where B26 is (Element of C19) : (not contradiction) })) by L94;
L99:
now
let C20 being set;
assume L100: C20 in ( meet { ( dom B27 ) where B27 is (Element of C19) : (not contradiction) } );
thus L101: ( C17 . C20 ) = { ( B28 . C20 ) where B28 is (Element of C19) : (not contradiction) } by L100 , L97 , L98
.= ( C18 . C20 ) by L95 , L96 , L100;
end;
thus L102: thesis by L99 , L95 , L96 , L97 , FUNCT_1:2;
end;

thus L103: thesis;
end;
consistency;
end;
theorem
L105: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for B29 being non  empty (SubsetFamily of R6) holds ( dom |. B29 .| ) = R3)))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let C21 being non  empty (SubsetFamily of R6);
consider C22 being non  empty  functional set such that L106: C22 = C21 and L107: ( dom |. C21 .| ) = ( meet { ( dom B30 ) where B30 is (Element of C22) : (not contradiction) } ) and L108: (for R1 being set holds (R1 in ( dom |. C21 .| ) implies ( |. C21 .| . R1 ) = { ( B31 . R1 ) where B31 is (Element of C22) : (not contradiction) })) by L85;
L109: { ( dom B32 ) where B32 is (Element of C22) : (not contradiction) } = { R3 }
proof
thus L110: { ( dom B33 ) where B33 is (Element of C22) : (not contradiction) } c= { R3 }
proof
let C23 being set;
assume L111: C23 in { ( dom B34 ) where B34 is (Element of C22) : (not contradiction) };
consider C24 being (Element of C22) such that L112: C23 = ( dom C24 ) by L111;
L113: C24 is (Element of C21) by L106;
L114: C23 = R3 by L113 , L112 , PARTFUN1:def 2;
thus L115: thesis by L114 , TARSKI:def 1;
end;

set D5 = the (Element of C22);
let C25 being set;
assume L116: C25 in { R3 };
L117: C25 = R3 by L116 , TARSKI:def 1;
L118: D5 is (Element of C21) by L106;
L119: ( dom D5 ) = R3 by L118 , PARTFUN1:def 2;
thus L120: thesis by L119 , L117;
end;
thus L121: thesis by L109 , L107 , SETFAM_1:10;
end;
registration
let C26 being  empty  functional set;
cluster |. C26 .| ->  empty;
coherence by L85;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let C27 being (SubsetFamily of R6);
func |:C27 :| -> (ManySortedSet of R3) equals 
:L123: |. C27 .| if C27 <> ( {} ) otherwise ( [[0]] R3 );
coherence
proof
thus L124: (C27 <> ( {} ) implies |. C27 .| is (ManySortedSet of R3))
proof
assume L125: C27 <> ( {} );
L126: ( dom |. C27 .| ) = R3 by L125 , L105;
thus L127: thesis by L126 , PARTFUN1:def 2 , RELAT_1:def 18;
end;

thus L128: thesis;
end;
consistency;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
let C28 being  empty (SubsetFamily of R6);
cluster |: C28 :| ->  empty-yielding;
coherence
proof
L130: |: C28 :| = ( [[0]] R3 ) by L123;
thus L131: thesis by L130;
end;
end;
theorem
L133: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (R9 is non  empty implies (for R1 being set holds (R1 in R3 implies ( |: R9 :| . R1 ) = { ( B35 . R1 ) where B35 is (Element of ( Bool R6 )) : B35 in R9 }))))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R9 being (SubsetFamily of R6);
L134: ( dom |: R9 :| ) = R3 by PARTFUN1:def 2;
assume L135: R9 is non  empty;
consider C29 being non  empty  functional set such that L136: C29 = R9 and L137: ( dom |. R9 .| ) = ( meet { ( dom B36 ) where B36 is (Element of C29) : (not contradiction) } ) and L138: (for R1 being set holds (R1 in ( dom |. R9 .| ) implies ( |. R9 .| . R1 ) = { ( B37 . R1 ) where B37 is (Element of C29) : (not contradiction) })) by L135 , L85;
let R1 being set;
assume that
L139: R1 in R3;
set D6 = { ( B38 . R1 ) where B38 is (Element of ( Bool R6 )) : B38 in R9 };
set D7 = { ( B39 . R1 ) where B39 is (Element of C29) : (not contradiction) };
L140: D6 = D7
proof
thus L141: D6 c= D7
proof
let C30 being set;
assume L142: C30 in D6;
L143: (ex B40 being (Element of ( Bool R6 )) st (C30 = ( B40 . R1 ) & B40 in R9)) by L142;
thus L144: thesis by L143 , L136;
end;

let C31 being set;
assume L145: C31 in D7;
consider C32 being (Element of C29) such that L146: C31 = ( C32 . R1 ) by L145;
L147: C32 in R9 by L136;
thus L148: thesis by L147 , L146;
end;
L149: |: R9 :| = |. R9 .| by L135 , L123;
thus L150: thesis by L149 , L138 , L139 , L134 , L140;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
let C33 being non  empty (SubsetFamily of R6);
cluster |: C33 :| ->  non-empty;
coherence
proof
let R1 being set;
assume L151: R1 in R3;
L152: ( |: C33 :| . R1 ) = { ( B41 . R1 ) where B41 is (Element of ( Bool R6 )) : B41 in C33 } by L151 , L133;
consider C34 being set such that L153: C34 in C33 by XBOOLE_0:def 1;
reconsider D8 = C34 as (Element of ( Bool R6 )) by L153;
L154: ( D8 . R1 ) in ( |: C33 :| . R1 ) by L152 , L153;
thus L155: thesis by L154;
end;
end;
theorem
L157: (for R7 being Function holds ( dom |. { R7 } .| ) = ( dom R7 ))
proof
let R7 being Function;
consider C35 being non  empty  functional set such that L158: C35 = { R7 } and L159: ( dom |. { R7 } .| ) = ( meet { ( dom B42 ) where B42 is (Element of C35) : (not contradiction) } ) and L160: (for R1 being set holds (R1 in ( dom |. { R7 } .| ) implies ( |. { R7 } .| . R1 ) = { ( B43 . R1 ) where B43 is (Element of C35) : (not contradiction) })) by L85;
set D9 = { ( dom B44 ) where B44 is (Element of C35) : (not contradiction) };
L161: D9 = { ( dom R7 ) }
proof
thus L162: D9 c= { ( dom R7 ) }
proof
let C36 being set;
assume L163: C36 in D9;
consider C37 being (Element of C35) such that L164: C36 = ( dom C37 ) by L163;
L165: C37 = R7 by L158 , TARSKI:def 1;
thus L166: thesis by L165 , L164 , TARSKI:def 1;
end;

let C38 being set;
assume L167: C38 in { ( dom R7 ) };
L168: C38 = ( dom R7 ) by L167 , TARSKI:def 1;
L169: R7 is (Element of C35) by L158 , TARSKI:def 1;
thus L170: thesis by L169 , L168;
end;
thus L171: thesis by L161 , L159 , SETFAM_1:10;
end;
theorem
L172: (for R7 being Function holds (for R8 being Function holds ( dom |. { R7 , R8 } .| ) = ( ( dom R7 ) /\ ( dom R8 ) )))
proof
let R7 being Function;
let R8 being Function;
consider C39 being non  empty  functional set such that L173: C39 = { R7 , R8 } and L174: ( dom |. { R7 , R8 } .| ) = ( meet { ( dom B45 ) where B45 is (Element of C39) : (not contradiction) } ) and L175: (for R1 being set holds (R1 in ( dom |. { R7 , R8 } .| ) implies ( |. { R7 , R8 } .| . R1 ) = { ( B46 . R1 ) where B46 is (Element of C39) : (not contradiction) })) by L85;
set D10 = { ( dom B47 ) where B47 is (Element of C39) : (not contradiction) };
L176: D10 = { ( dom R7 ) , ( dom R8 ) }
proof
thus L177: D10 c= { ( dom R7 ) , ( dom R8 ) }
proof
let C40 being set;
assume L178: C40 in D10;
consider C41 being (Element of C39) such that L179: C40 = ( dom C41 ) by L178;
L180: (C41 = R7 or C41 = R8) by L173 , TARSKI:def 2;
thus L181: thesis by L180 , L179 , TARSKI:def 2;
end;

let C42 being set;
assume L182: C42 in { ( dom R7 ) , ( dom R8 ) };
L183: (C42 = ( dom R7 ) or C42 = ( dom R8 )) by L182 , TARSKI:def 2;
L184: (R7 is (Element of C39) & R8 is (Element of C39)) by L173 , TARSKI:def 2;
thus L185: thesis by L184 , L183;
end;
thus L186: thesis by L176 , L174 , SETFAM_1:11;
end;
theorem
L187: (for R1 being set holds (for R7 being Function holds (R1 in ( dom R7 ) implies ( |. { R7 } .| . R1 ) = { ( R7 . R1 ) })))
proof
let R1 being set;
let R7 being Function;
L188: R7 in { R7 } by TARSKI:def 1;
consider C43 being non  empty  functional set such that L189: C43 = { R7 } and L190: ( dom |. { R7 } .| ) = ( meet { ( dom B48 ) where B48 is (Element of C43) : (not contradiction) } ) and L191: (for R1 being set holds (R1 in ( dom |. { R7 } .| ) implies ( |. { R7 } .| . R1 ) = { ( B49 . R1 ) where B49 is (Element of C43) : (not contradiction) })) by L85;
assume L192: R1 in ( dom R7 );
L193: R1 in ( dom |. { R7 } .| ) by L192 , L157;
L194: ( |. { R7 } .| . R1 ) = { ( B50 . R1 ) where B50 is (Element of C43) : (not contradiction) } by L193 , L191;
thus L195: ( |. { R7 } .| . R1 ) c= { ( R7 . R1 ) }
proof
let C44 being set;
assume L196: C44 in ( |. { R7 } .| . R1 );
consider C45 being (Element of C43) such that L197: C44 = ( C45 . R1 ) by L196 , L194;
L198: C45 = R7 by L189 , TARSKI:def 1;
thus L199: thesis by L198 , L197 , TARSKI:def 1;
end;

let C46 being set;
assume L200: C46 in { ( R7 . R1 ) };
L201: C46 = ( R7 . R1 ) by L200 , TARSKI:def 1;
thus L202: thesis by L201 , L189 , L194 , L188;
end;
theorem
L203: (for R1 being set holds (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R7 being Function holds (for R9 being (SubsetFamily of R6) holds ((R1 in R3 & R9 = { R7 }) implies ( |: R9 :| . R1 ) = { ( R7 . R1 ) }))))))
proof
let R1 being set;
let R3 being set;
let R6 being (ManySortedSet of R3);
let R7 being Function;
let R9 being (SubsetFamily of R6);
assume that
L204: R1 in R3
and
L205: R9 = { R7 };
L206: |: R9 :| = |. R9 .| by L205 , L123;
L207: ( dom |: R9 :| ) = R3 by PARTFUN1:def 2;
L208: R1 in ( dom R7 ) by L207 , L204 , L205 , L206 , L157;
thus L209: thesis by L208 , L205 , L206 , L187;
end;
theorem
L210: (for R1 being set holds (for R7 being Function holds (for R8 being Function holds (R1 in ( dom |. { R7 , R8 } .| ) implies ( |. { R7 , R8 } .| . R1 ) = { ( R7 . R1 ) , ( R8 . R1 ) }))))
proof
let R1 being set;
let R7 being Function;
let R8 being Function;
L211: (R7 in { R7 , R8 } & R8 in { R7 , R8 }) by TARSKI:def 2;
consider C47 being non  empty  functional set such that L212: C47 = { R7 , R8 } and L213: ( dom |. { R7 , R8 } .| ) = ( meet { ( dom B51 ) where B51 is (Element of C47) : (not contradiction) } ) and L214: (for R1 being set holds (R1 in ( dom |. { R7 , R8 } .| ) implies ( |. { R7 , R8 } .| . R1 ) = { ( B52 . R1 ) where B52 is (Element of C47) : (not contradiction) })) by L85;
assume L215: R1 in ( dom |. { R7 , R8 } .| );
L216: ( |. { R7 , R8 } .| . R1 ) = { ( B53 . R1 ) where B53 is (Element of C47) : (not contradiction) } by L215 , L214;
thus L217: ( |. { R7 , R8 } .| . R1 ) c= { ( R7 . R1 ) , ( R8 . R1 ) }
proof
let C48 being set;
assume L218: C48 in ( |. { R7 , R8 } .| . R1 );
consider C49 being (Element of C47) such that L219: C48 = ( C49 . R1 ) by L218 , L216;
per cases  by L212 , TARSKI:def 2;
suppose L220: C49 = R7;

thus L221: thesis by L220 , L219 , TARSKI:def 2;
end;
suppose L222: C49 = R8;

thus L223: thesis by L222 , L219 , TARSKI:def 2;
end;
end;

let C50 being set;
assume L225: C50 in { ( R7 . R1 ) , ( R8 . R1 ) };
L226: (C50 = ( R7 . R1 ) or C50 = ( R8 . R1 )) by L225 , TARSKI:def 2;
thus L227: thesis by L226 , L212 , L216 , L211;
end;
theorem
L228: (for R1 being set holds (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R7 being Function holds (for R8 being Function holds (for R9 being (SubsetFamily of R6) holds ((R1 in R3 & R9 = { R7 , R8 }) implies ( |: R9 :| . R1 ) = { ( R7 . R1 ) , ( R8 . R1 ) })))))))
proof
let R1 being set;
let R3 being set;
let R6 being (ManySortedSet of R3);
let R7 being Function;
let R8 being Function;
let R9 being (SubsetFamily of R6);
assume that
L229: R1 in R3
and
L230: R9 = { R7 , R8 };
L231: (( dom |: R9 :| ) = R3 & |: R9 :| = |. R9 .|) by L230 , L123 , PARTFUN1:def 2;
thus L232: thesis by L231 , L229 , L230 , L210;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let R9 being (SubsetFamily of R6);
redefine func |:R9 :| -> (MSSubsetFamily of R6);

coherence
proof
per cases ;
suppose L233: R9 is non  empty;

L234: |: R9 :| is (ManySortedSubset of ( bool R6 ))
proof
let R1 being set;
assume L235: R1 in R3;
L236: ( |: R9 :| . R1 ) = { ( B54 . R1 ) where B54 is (Element of ( Bool R6 )) : B54 in R9 } by L235 , L233 , L133;
thus L237: ( |: R9 :| . R1 ) c= ( ( bool R6 ) . R1 )
proof
let R2 being set;
assume L238: R2 in ( |: R9 :| . R1 );
consider C51 being (Element of ( Bool R6 )) such that L239: R2 = ( C51 . R1 ) and L240: C51 in R9 by L238 , L236;
L241: C51 c= R6 by PBOOLE:def 18;
L242: R2 c= ( R6 . R1 ) by L241 , L235 , L239 , PBOOLE:def 2;
L243: R2 in ( bool ( R6 . R1 ) ) by L242;
thus L244: thesis by L243 , L235 , MBOOLEAN:def 1;
end;

end;
thus L238: thesis by L234;
end;
suppose L239: R9 is  empty;

L240: |: R9 :| = ( [[0]] R3 ) by L239 , L123;
thus L241: thesis by L240 , MSSUBFAM:31;
end;
end;
end;
theorem
L244: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (R4 in R9 implies R4 in' |: R9 :|)))))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
let R6 being (ManySortedSet of R3);
let R9 being (SubsetFamily of R6);
assume L245: R4 in R9;
let R1 being set;
assume L246: R1 in R3;
L247: ( |: R9 :| . R1 ) = { ( B55 . R1 ) where B55 is (Element of ( Bool R6 )) : B55 in R9 } by L246 , L245 , L133;
thus L248: thesis by L247 , L245;
end;
theorem
L249: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds (for R5 being (ManySortedSet of R3) holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (R9 = { R4 , R5 } implies ( union |: R9 :| ) = ( R4 \/ R5 )))))))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
let R6 being (ManySortedSet of R3);
let R9 being (SubsetFamily of R6);
assume L250: R9 = { R4 , R5 };
L251:
now
let R1 being set;
assume L252: R1 in R3;
thus L253: ( ( union |: R9 :| ) . R1 ) = ( union ( |: R9 :| . R1 ) ) by L252 , MBOOLEAN:def 2
.= ( union { ( R4 . R1 ) , ( R5 . R1 ) } ) by L250 , L252 , L228
.= ( ( R4 . R1 ) \/ ( R5 . R1 ) ) by ZFMISC_1:75
.= ( ( R4 \/ R5 ) . R1 ) by L252 , PBOOLE:def 4;
end;
thus L254: thesis by L251 , PBOOLE:3;
end;
theorem
L255: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (for R11 being (Element of ( Bool R6 )) holds (for R12 being (Element of ( Bool R6 )) holds (R9 = { R11 , R12 } implies ( meet |: R9 :| ) = ( R11 /\ R12 )))))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R9 being (SubsetFamily of R6);
let R11 being (Element of ( Bool R6 ));
let R12 being (Element of ( Bool R6 ));
assume L256: R9 = { R11 , R12 };
L257:
now
reconsider D11 = R9 as non  empty (SubsetFamily of R6) by L256;
let C52 being set;
assume that
L258: C52 in R3;
L259: (ex B56 being (Subset-Family of ( R6 . C52 )) st (B56 = ( |: D11 :| . C52 ) & ( ( meet |: D11 :| ) . C52 ) = ( Intersect B56 ))) by L258 , MSSUBFAM:def 1;
thus L260: ( ( meet |: R9 :| ) . C52 ) = ( meet ( |: D11 :| . C52 ) ) by L259 , L258 , SETFAM_1:def 9
.= ( meet { ( R11 . C52 ) , ( R12 . C52 ) } ) by L256 , L258 , L228
.= ( ( R11 . C52 ) /\ ( R12 . C52 ) ) by SETFAM_1:11
.= ( ( R11 /\ R12 ) . C52 ) by L258 , PBOOLE:def 5;
end;
thus L261: thesis by L257 , PBOOLE:3;
end;
theorem
L262: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R9 being (SubsetFamily of R6) holds (for B57 being (ManySortedSubset of R6) holds ((for B58 being (ManySortedSet of R3) holds (B58 in R9 implies B57 c=' B58)) implies B57 c=' ( meet |: R9 :| ))))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R9 being (SubsetFamily of R6);
let C53 being (ManySortedSubset of R6);
assume that
L263: (for B59 being (ManySortedSet of R3) holds (B59 in R9 implies C53 c=' B59));
let R1 being set;
assume that
L264: R1 in R3;
consider C54 being (Subset-Family of ( R6 . R1 )) such that L265: C54 = ( |: R9 :| . R1 ) and L266: ( ( meet |: R9 :| ) . R1 ) = ( Intersect C54 ) by L264 , MSSUBFAM:def 1;
L267:
now
let C55 being set;
assume that
L268: C55 in C54;
per cases ;
suppose L269: R9 is non  empty;

L270: ( |: R9 :| . R1 ) = { ( B60 . R1 ) where B60 is (Element of ( Bool R6 )) : B60 in R9 } by L269 , L264 , L133;
consider C56 being (Element of ( Bool R6 )) such that L271: C55 = ( C56 . R1 ) and L272: C56 in R9 by L270 , L265 , L268;
L273: C53 c=' C56 by L263 , L272;
thus L274: ( C53 . R1 ) c= C55 by L273 , L264 , L271 , PBOOLE:def 2;
end;
suppose L275: R9 is  empty;

L276: |: R9 :| = ( [[0]] R3 ) by L275 , L123;
thus L277: ( C53 . R1 ) c= C55 by L276 , L265 , L268;
end;
end;
L279: C53 c= R6 by PBOOLE:def 18;
L280: ( C53 . R1 ) is (Subset of ( R6 . R1 )) by L279 , L264 , PBOOLE:def 2;
thus L281: thesis by L280 , L266 , L267 , MSSUBFAM:4;
end;
theorem
L282: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds |: ( Bool R6 ) :| = ( bool R6 )))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
L283:
now
let R1 being set;
assume L284: R1 in R3;
L285: ( |: ( Bool R6 ) :| . R1 ) = { ( B61 . R1 ) where B61 is (Element of ( Bool R6 )) : B61 in ( Bool R6 ) } by L284 , L133;
thus L286: ( |: ( Bool R6 ) :| . R1 ) = ( ( bool R6 ) . R1 )
proof
thus L287: ( |: ( Bool R6 ) :| . R1 ) c= ( ( bool R6 ) . R1 )
proof
let C57 being set;
assume L288: C57 in ( |: ( Bool R6 ) :| . R1 );
consider C58 being (Element of ( Bool R6 )) such that L289: C57 = ( C58 . R1 ) and L290: C58 in ( Bool R6 ) by L288 , L285;
L291: C58 c= R6 by PBOOLE:def 18;
L292: ( C58 . R1 ) c= ( R6 . R1 ) by L291 , L284 , PBOOLE:def 2;
L293: ( C58 . R1 ) in ( bool ( R6 . R1 ) ) by L292;
thus L294: thesis by L293 , L284 , L289 , MBOOLEAN:def 1;
end;

let C59 being set;
assume that
L295: C59 in ( ( bool R6 ) . R1 );
L296: ( dom ( ( [[0]] R3 ) +* ( R1 .--> C59 ) ) ) = R3 by L284 , PZFMISC1:1;
reconsider D12 = ( ( [[0]] R3 ) +* ( R1 .--> C59 ) ) as (ManySortedSet of R3) by L296 , PARTFUN1:def 2 , RELAT_1:def 18;
L297: ( dom ( R1 .--> C59 ) ) = { R1 } by FUNCOP_1:13;
L298: R1 in { R1 } by TARSKI:def 1;
L299: ( D12 . R1 ) = ( ( R1 .--> C59 ) . R1 ) by L298 , L297 , FUNCT_4:13
.= C59 by FUNCOP_1:72;
L300: D12 is (ManySortedSubset of R6)
proof
let C60 being set;
assume that
L301: C60 in R3;
per cases ;
suppose L302: C60 = R1;

L303: C59 in ( bool ( R6 . C60 ) ) by L302 , L295 , L301 , MBOOLEAN:def 1;
thus L304: thesis by L303 , L299 , L302;
end;
suppose L305: C60 <> R1;

L306: (not C60 in ( dom ( R1 .--> C59 ) )) by L305 , L297 , TARSKI:def 1;
L307: ( D12 . C60 ) = ( ( [[0]] R3 ) . C60 ) by L306 , FUNCT_4:11
.= ( {} );
thus L308: thesis by L307 , XBOOLE_1:2;
end;
end;
L310: D12 is (Element of ( Bool R6 )) by L300 , L18;
thus L311: thesis by L310 , L285 , L299;
end;

end;
thus L287: thesis by L283 , PBOOLE:3;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let C61 being (SubsetFamily of R6);
attr C61 is  additive
means
(for R4 being (ManySortedSet of R3) holds (for R5 being (ManySortedSet of R3) holds ((R4 in C61 & R5 in C61) implies ( R4 \/ R5 ) in C61)));
attr C61 is  absolutely-additive
means
:L288: (for B62 being (SubsetFamily of R6) holds (B62 c= C61 implies ( union |: B62 :| ) in C61));
attr C61 is  multiplicative
means
(for R4 being (ManySortedSet of R3) holds (for R5 being (ManySortedSet of R3) holds ((R4 in C61 & R5 in C61) implies ( R4 /\ R5 ) in C61)));
attr C61 is  absolutely-multiplicative
means
:L289: (for B63 being (SubsetFamily of R6) holds (B63 c= C61 implies ( meet |: B63 :| ) in C61));
attr C61 is  properly-upper-bound
means
:L290: R6 in C61;
attr C61 is  properly-lower-bound
means
:L291: ( [[0]] R3 ) in C61;
end;
L293: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds ( Bool R6 ) is  additive  absolutely-additive  multiplicative  absolutely-multiplicative  properly-upper-bound  properly-lower-bound))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
thus L294: ( Bool R6 ) is  additive
proof
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
assume L295: (R4 in ( Bool R6 ) & R5 in ( Bool R6 ));
thus L296: thesis by L295 , L67;
end;

thus L297: ( Bool R6 ) is  absolutely-additive
proof
let C62 being (SubsetFamily of R6);
assume that
L298: C62 c= ( Bool R6 );
L299: ( union |: C62 :| ) c= R6 by MSSUBFAM:40;
L300: ( union |: C62 :| ) is (ManySortedSubset of R6) by L299 , PBOOLE:def 18;
thus L301: thesis by L300 , L18;
end;

thus L302: ( Bool R6 ) is  multiplicative
proof
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
assume L303: (R4 in ( Bool R6 ) & R5 in ( Bool R6 ));
thus L304: thesis by L303 , L62;
end;

thus L305: ( Bool R6 ) is  absolutely-multiplicative
proof
let C63 being (SubsetFamily of R6);
assume that
L306: C63 c= ( Bool R6 );
thus L307: thesis by L18;
end;

L308: R6 is (ManySortedSubset of R6) by PBOOLE:def 18;
L309: R6 in ( Bool R6 ) by L308 , L18;
thus L310: ( Bool R6 ) is  properly-upper-bound by L309 , L290;
L311: ( [[0]] R3 ) c= R6 by PBOOLE:43;
L312: ( [[0]] R3 ) is (ManySortedSubset of R6) by L311 , PBOOLE:def 18;
thus L313: ( [[0]] R3 ) in ( Bool R6 ) by L312 , L18;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster non  empty  functional  with_common_domain  additive  absolutely-additive  multiplicative  absolutely-multiplicative  properly-upper-bound  properly-lower-bound for (SubsetFamily of R6);
existence
proof
take ( Bool R6 );
thus L314: thesis by L293;
end;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
redefine func Bool R6 ->  additive  absolutely-additive  multiplicative  absolutely-multiplicative  properly-upper-bound  properly-lower-bound (SubsetFamily of R6);

coherence by L293;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  absolutely-additive ->  additive for (SubsetFamily of R6);
coherence
proof
let C64 being (SubsetFamily of R6);
assume that
L317: C64 is  absolutely-additive;
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
assume that
L318: R4 in C64
and
L319: R5 in C64;
L320: R5 is (ManySortedSubset of R6) by L319 , L18;
L321: R5 c= R6 by L320 , PBOOLE:def 18;
L322: R4 is (ManySortedSubset of R6) by L318 , L18;
L323: R4 c= R6 by L322 , PBOOLE:def 18;
reconsider D13 = { R4 , R5 } as (SubsetFamily of R6) by L323 , L321 , L57;
L324: ({ R4 } c= C64 & { R5 } c= C64) by L318 , L319 , ZFMISC_1:31;
L325: ( { R4 } \/ { R5 } ) c= C64 by L324 , XBOOLE_1:8;
L326: { R4 , R5 } c= C64 by L325 , ENUMSET1:1;
L327: ( union |: D13 :| ) in C64 by L326 , L317 , L288;
thus L328: thesis by L327 , L249;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  absolutely-multiplicative ->  multiplicative for (SubsetFamily of R6);
coherence
proof
let C65 being (SubsetFamily of R6);
assume that
L330: C65 is  absolutely-multiplicative;
let R4 being (ManySortedSet of R3);
let R5 being (ManySortedSet of R3);
assume that
L331: R4 in C65
and
L332: R5 in C65;
L333: R5 is (ManySortedSubset of R6) by L332 , L18;
L334: R5 c= R6 by L333 , PBOOLE:def 18;
L335: R4 is (ManySortedSubset of R6) by L331 , L18;
L336: R4 c= R6 by L335 , PBOOLE:def 18;
reconsider D14 = { R4 , R5 } as (SubsetFamily of R6) by L336 , L334 , L57;
L337: ({ R4 } c= C65 & { R5 } c= C65) by L331 , L332 , ZFMISC_1:31;
L338: ( { R4 } \/ { R5 } ) c= C65 by L337 , XBOOLE_1:8;
L339: { R4 , R5 } c= C65 by L338 , ENUMSET1:1;
L340: ( meet |: D14 :| ) in C65 by L339 , L330 , L289;
thus L341: thesis by L340 , L331 , L332 , L255;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  absolutely-multiplicative ->  properly-upper-bound for (SubsetFamily of R6);
coherence
proof
reconsider D15 = ( {} ) as (SubsetFamily of R6) by XBOOLE_1:2;
let C66 being (SubsetFamily of R6);
assume that
L343: C66 is  absolutely-multiplicative;
L344: |: D15 :| = ( [[0]] R3 ) by L123;
L345: ( meet |: D15 :| ) = R6 by L344 , MSSUBFAM:41;
L346: D15 c= C66 by XBOOLE_1:2;
thus L347: R6 in C66 by L346 , L343 , L345 , L289;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  properly-upper-bound -> non  empty for (SubsetFamily of R6);
coherence by L290;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  absolutely-additive ->  properly-lower-bound for (SubsetFamily of R6);
coherence
proof
reconsider D16 = ( {} ) as (SubsetFamily of R6) by XBOOLE_1:2;
let C67 being (SubsetFamily of R6);
assume that
L350: C67 is  absolutely-additive;
L351: |: D16 :| = ( [[0]] R3 ) by L123;
L352: ( union |: D16 :| ) = ( [[0]] R3 ) by L351 , MBOOLEAN:21;
L353: D16 c= C67 by XBOOLE_1:2;
thus L354: ( [[0]] R3 ) in C67 by L353 , L350 , L352 , L288;
end;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  properly-lower-bound -> non  empty for (SubsetFamily of R6);
coherence by L291;
end;
begin
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
mode SetOp of R6
 is (Function of ( Bool R6 ) , ( Bool R6 ));
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let C68 being (SetOp of R6);
let C69 being (Element of ( Bool R6 ));
redefine func C68 . C69 -> (Element of ( Bool R6 ));

coherence
proof
L358: ( C68 . C69 ) in ( Bool R6 );
thus L359: thesis by L358;
end;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let C70 being (SetOp of R6);
attr C70 is  reflexive
means
:L361: (for B64 being (Element of ( Bool R6 )) holds B64 c=' ( C70 . B64 ));
attr C70 is  monotonic
means
:L362: (for B65 , B66 being (Element of ( Bool R6 )) holds (B65 c=' B66 implies ( C70 . B65 ) c=' ( C70 . B66 )));
attr C70 is  idempotent
means
:L363: (for B67 being (Element of ( Bool R6 )) holds ( C70 . B67 ) = ( C70 . ( C70 . B67 ) ));
attr C70 is  topological
means
:L364: (for B68 , B69 being (Element of ( Bool R6 )) holds ( C70 . ( B68 \/ B69 ) ) = ( ( C70 . B68 ) \/ ( C70 . B69 ) ));
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  reflexive  monotonic  idempotent  topological for (SetOp of R6);
existence
proof
reconsider D17 = ( id ( Bool R6 ) ) as (SetOp of R6);
take D17;
thus L366: D17 is  reflexive
proof
let C71 being (Element of ( Bool R6 ));
thus L367: thesis by FUNCT_1:18;
end;

thus L368: D17 is  monotonic
proof
let C72 , C73 being (Element of ( Bool R6 ));
assume that
L369: C72 c= C73;
L370: ( D17 . C72 ) = C72 by FUNCT_1:18;
thus L371: thesis by L370 , L369 , FUNCT_1:18;
end;

thus L372: D17 is  idempotent
proof
let C74 being (Element of ( Bool R6 ));
thus L373: ( D17 . ( D17 . C74 ) ) = ( D17 . C74 ) by FUNCT_1:18;
end;

thus L374: D17 is  topological
proof
let C75 , C76 being (Element of ( Bool R6 ));
L375: (C75 c= R6 & C76 c= R6) by PBOOLE:def 18;
L376: ( C75 \/ C76 ) c= R6 by L375 , PBOOLE:16;
L377: ( C75 \/ C76 ) is (ManySortedSubset of R6) by L376 , PBOOLE:def 18;
L378: ( C75 \/ C76 ) in ( Bool R6 ) by L377 , L18;
thus L379: ( D17 . ( C75 \/ C76 ) ) = ( C75 \/ C76 ) by L378 , FUNCT_1:18
.= ( ( D17 . C75 ) \/ C76 ) by FUNCT_1:18
.= ( ( D17 . C75 ) \/ ( D17 . C76 ) ) by FUNCT_1:18;
end;

end;
end;
theorem
L376: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds ( id ( Bool R4 ) ) is  reflexive  reflexive  reflexive  reflexive (SetOp of R4)))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
reconsider D18 = ( id ( Bool R4 ) ) as (SetOp of R4);
L377: D18 is  reflexive
proof
let C77 being (Element of ( Bool R4 ));
thus L378: thesis by FUNCT_1:18;
end;
thus L379: thesis by L377;
end;
theorem
L380: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds ( id ( Bool R4 ) ) is  monotonic  monotonic  monotonic  monotonic (SetOp of R4)))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
reconsider D19 = ( id ( Bool R4 ) ) as (SetOp of R4);
L381: D19 is  monotonic
proof
let C78 , C79 being (Element of ( Bool R4 ));
assume that
L382: C78 c= C79;
L383: ( D19 . C78 ) = C78 by FUNCT_1:18;
thus L384: thesis by L383 , L382 , FUNCT_1:18;
end;
thus L385: thesis by L381;
end;
theorem
L386: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds ( id ( Bool R4 ) ) is  idempotent  idempotent  idempotent  idempotent (SetOp of R4)))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
reconsider D20 = ( id ( Bool R4 ) ) as (SetOp of R4);
L387: D20 is  idempotent
proof
let C80 being (Element of ( Bool R4 ));
thus L388: ( D20 . ( D20 . C80 ) ) = ( D20 . C80 ) by FUNCT_1:18;
end;
thus L389: thesis by L387;
end;
theorem
L390: (for R3 being set holds (for R4 being (ManySortedSet of R3) holds ( id ( Bool R4 ) ) is  topological  topological  topological  topological (SetOp of R4)))
proof
let R3 being set;
let R4 being (ManySortedSet of R3);
reconsider D21 = ( id ( Bool R4 ) ) as (SetOp of R4);
L391: D21 is  topological
proof
let C81 , C82 being (Element of ( Bool R4 ));
L392: (C81 c= R4 & C82 c= R4) by PBOOLE:def 18;
L393: ( C81 \/ C82 ) c= R4 by L392 , PBOOLE:16;
L394: ( C81 \/ C82 ) is (ManySortedSubset of R4) by L393 , PBOOLE:def 18;
L395: ( C81 \/ C82 ) in ( Bool R4 ) by L394 , L18;
thus L396: ( D21 . ( C81 \/ C82 ) ) = ( C81 \/ C82 ) by L395 , FUNCT_1:18
.= ( ( D21 . C81 ) \/ C82 ) by FUNCT_1:18
.= ( ( D21 . C81 ) \/ ( D21 . C82 ) ) by FUNCT_1:18;
end;
thus L397: thesis by L391;
end;
theorem
L398: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds (for R13 being (SetOp of R6) holds ((R11 = R6 & R13 is  reflexive) implies R11 = ( R13 . R11 ))))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
let R13 being (SetOp of R6);
assume L399: R11 = R6;
assume L400: R13 is  reflexive;
L401: R11 c= ( R13 . R11 ) by L400 , L361;
L402: ( R13 . R11 ) c= R11 by L399 , PBOOLE:def 18;
thus L403: thesis by L402 , L401 , PBOOLE:146;
end;
theorem
L404: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R13 being (SetOp of R6) holds ((R13 is  reflexive & (for B70 being (Element of ( Bool R6 )) holds ( R13 . B70 ) c= B70)) implies R13 is  idempotent))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R13 being (SetOp of R6);
assume that
L405: R13 is  reflexive
and
L406: (for B71 being (Element of ( Bool R6 )) holds ( R13 . B71 ) c= B71);
let C83 being (Element of ( Bool R6 ));
L407: ( R13 . C83 ) c= ( R13 . ( R13 . C83 ) ) by L405 , L361;
L408: ( R13 . ( R13 . C83 ) ) c= ( R13 . C83 ) by L406;
thus L409: thesis by L408 , L407 , PBOOLE:146;
end;
theorem
L410: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds (for R12 being (Element of ( Bool R6 )) holds (for R13 being (SetOp of R6) holds (for B72 being (Element of ( Bool R6 )) holds (B72 = ( R11 /\ R12 ) implies (R13 is  monotonic implies ( R13 . B72 ) c= ( ( R13 . R11 ) /\ ( R13 . R12 ) )))))))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
let R12 being (Element of ( Bool R6 ));
let R13 being (SetOp of R6);
let C84 being (Element of ( Bool R6 ));
assume that
L411: C84 = ( R11 /\ R12 );
assume L412: R13 is  monotonic;
L413: ( R11 /\ R12 ) c= R12 by PBOOLE:15;
L414: ( R13 . C84 ) c= ( R13 . R12 ) by L413 , L411 , L412 , L362;
L415: ( R11 /\ R12 ) c= R11 by PBOOLE:15;
L416: ( R13 . C84 ) c= ( R13 . R11 ) by L415 , L411 , L412 , L362;
thus L417: thesis by L416 , L414 , PBOOLE:17;
end;
registration
let R3 being set;
let R6 being (ManySortedSet of R3);
cluster  topological ->  monotonic for (SetOp of R6);
coherence
proof
let C85 being (SetOp of R6);
assume that
L418: C85 is  topological;
let C86 , C87 being (Element of ( Bool R6 ));
assume that
L419: C86 c= C87;
L420: ( ( C85 . C86 ) \/ ( C85 . C87 ) ) = ( C85 . ( C86 \/ C87 ) ) by L418 , L364
.= ( C85 . C87 ) by L419 , PBOOLE:22;
thus L421: thesis by L420 , PBOOLE:26;
end;
end;
theorem
L423: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R11 being (Element of ( Bool R6 )) holds (for R12 being (Element of ( Bool R6 )) holds (for R13 being (SetOp of R6) holds (for B73 being (Element of ( Bool R6 )) holds (B73 = ( R11 \ R12 ) implies (R13 is  topological implies ( ( R13 . R11 ) \ ( R13 . R12 ) ) c= ( R13 . B73 )))))))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R11 being (Element of ( Bool R6 ));
let R12 being (Element of ( Bool R6 ));
let R13 being (SetOp of R6);
let C88 being (Element of ( Bool R6 ));
assume that
L424: C88 = ( R11 \ R12 );
assume L425: R13 is  topological;
L426: ( ( R13 . R11 ) \/ ( R13 . R12 ) ) = ( R13 . ( R11 \/ R12 ) ) by L425 , L364
.= ( R13 . ( ( R11 \ R12 ) \/ R12 ) ) by PBOOLE:67
.= ( ( R13 . C88 ) \/ ( R13 . R12 ) ) by L424 , L425 , L364;
L427: ( R13 . R11 ) c= ( ( R13 . C88 ) \/ ( R13 . R12 ) ) by L426 , PBOOLE:14;
L428: ( ( R13 . R11 ) \ ( R13 . R12 ) ) c= ( ( ( R13 . C88 ) \/ ( R13 . R12 ) ) \ ( R13 . R12 ) ) by L427 , PBOOLE:53;
L429: ( ( R13 . R11 ) \ ( R13 . R12 ) ) c= ( ( R13 . C88 ) \ ( R13 . R12 ) ) by L428 , PBOOLE:75;
L430: ( ( R13 . C88 ) \ ( R13 . R12 ) ) c= ( R13 . C88 ) by PBOOLE:56;
thus L431: thesis by L430 , L429 , PBOOLE:13;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
let R14 being (SetOp of R6);
let R13 being (SetOp of R6);
redefine func R13 * R14 -> (SetOp of R6);

coherence
proof
L432: ( R13 * R14 ) is (Function of ( Bool R6 ) , ( Bool R6 ));
thus L433: thesis by L432;
end;
end;
theorem
L435: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R13 being (SetOp of R6) holds (for R14 being (SetOp of R6) holds ((R13 is  reflexive & R14 is  reflexive) implies ( R13 * R14 ) is  reflexive)))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R13 being (SetOp of R6);
let R14 being (SetOp of R6);
assume L436: (R13 is  reflexive & R14 is  reflexive);
let C89 being (Element of ( Bool R6 ));
L437: (C89 c= ( R14 . C89 ) & ( R14 . C89 ) c= ( R13 . ( R14 . C89 ) )) by L436 , L361;
L438: (( dom R14 ) = ( Bool R6 ) & C89 c= ( R13 . ( R14 . C89 ) )) by L437 , FUNCT_2:def 1 , PBOOLE:13;
thus L439: thesis by L438 , FUNCT_1:13;
end;
theorem
L440: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R13 being (SetOp of R6) holds (for R14 being (SetOp of R6) holds ((R13 is  monotonic & R14 is  monotonic) implies ( R13 * R14 ) is  monotonic)))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R13 being (SetOp of R6);
let R14 being (SetOp of R6);
assume that
L441: R13 is  monotonic
and
L442: R14 is  monotonic;
L443: ( dom R14 ) = ( Bool R6 ) by FUNCT_2:def 1;
let C90 , C91 being (Element of ( Bool R6 ));
assume L444: C90 c= C91;
L445: ( R14 . C90 ) c= ( R14 . C91 ) by L444 , L442 , L362;
L446: ( R13 . ( R14 . C90 ) ) c= ( R13 . ( R14 . C91 ) ) by L445 , L441 , L362;
L447: ( R13 . ( R14 . C90 ) ) c= ( ( R13 * R14 ) . C91 ) by L446 , L443 , FUNCT_1:13;
thus L448: thesis by L447 , L443 , FUNCT_1:13;
end;
theorem
L449: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R13 being (SetOp of R6) holds (for R14 being (SetOp of R6) holds ((R13 is  idempotent & R14 is  idempotent & ( R13 * R14 ) = ( R14 * R13 )) implies ( R13 * R14 ) is  idempotent)))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R13 being (SetOp of R6);
let R14 being (SetOp of R6);
assume that
L450: R13 is  idempotent
and
L451: R14 is  idempotent
and
L452: ( R13 * R14 ) = ( R14 * R13 );
let C92 being (Element of ( Bool R6 ));
L453: ( dom R13 ) = ( Bool R6 ) by FUNCT_2:def 1;
L454: ( dom R14 ) = ( Bool R6 ) by FUNCT_2:def 1;
thus L455: ( ( R13 * R14 ) . C92 ) = ( R13 . ( R14 . C92 ) ) by L454 , FUNCT_1:13
.= ( R13 . ( R14 . ( R14 . C92 ) ) ) by L451 , L363
.= ( R13 . ( R13 . ( R14 . ( R14 . C92 ) ) ) ) by L450 , L363
.= ( R13 . ( ( R14 * R13 ) . ( R14 . C92 ) ) ) by L452 , L454 , FUNCT_1:13
.= ( R13 . ( R14 . ( R13 . ( R14 . C92 ) ) ) ) by L453 , FUNCT_1:13
.= ( R13 . ( R14 . ( ( R13 * R14 ) . C92 ) ) ) by L454 , FUNCT_1:13
.= ( ( R13 * R14 ) . ( ( R13 * R14 ) . C92 ) ) by L454 , FUNCT_1:13;
end;
theorem
L456: (for R3 being set holds (for R6 being (ManySortedSet of R3) holds (for R13 being (SetOp of R6) holds (for R14 being (SetOp of R6) holds ((R13 is  topological & R14 is  topological) implies ( R13 * R14 ) is  topological)))))
proof
let R3 being set;
let R6 being (ManySortedSet of R3);
let R13 being (SetOp of R6);
let R14 being (SetOp of R6);
assume that
L457: R13 is  topological
and
L458: R14 is  topological;
let C93 , C94 being (Element of ( Bool R6 ));
L459: ( dom R14 ) = ( Bool R6 ) by FUNCT_2:def 1;
thus L460: ( ( R13 * R14 ) . ( C93 \/ C94 ) ) = ( R13 . ( R14 . ( C93 \/ C94 ) ) ) by L459 , L67 , FUNCT_1:13
.= ( R13 . ( ( R14 . C93 ) \/ ( R14 . C94 ) ) ) by L458 , L364
.= ( ( R13 . ( R14 . C93 ) ) \/ ( R13 . ( R14 . C94 ) ) ) by L457 , L364
.= ( ( ( R13 * R14 ) . C93 ) \/ ( R13 . ( R14 . C94 ) ) ) by L459 , FUNCT_1:13
.= ( ( ( R13 * R14 ) . C93 ) \/ ( ( R13 * R14 ) . C94 ) ) by L459 , FUNCT_1:13;
end;
begin
definition
let R15 being 1-sorted;
struct (many-sorted over R15) ClosureStr over R15(# Sorts -> (ManySortedSet of (the carrier of R15)) , Family -> (SubsetFamily of the Sorts) #);
end;
definition
let R15 being 1-sorted;
let C95 being ClosureStr over R15;
attr C95 is  additive
means
:L462: (the Family of C95) is  additive;
attr C95 is  absolutely-additive
means
:L463: (the Family of C95) is  absolutely-additive;
attr C95 is  multiplicative
means
:L464: (the Family of C95) is  multiplicative;
attr C95 is  absolutely-multiplicative
means
:L465: (the Family of C95) is  absolutely-multiplicative;
attr C95 is  properly-upper-bound
means
:L466: (the Family of C95) is  properly-upper-bound;
attr C95 is  properly-lower-bound
means
:L467: (the Family of C95) is  properly-lower-bound;
end;
definition
let R15 being 1-sorted;
let R16 being many-sorted over R15;
func Full R16 -> ClosureStr over R15 equals 
ClosureStr (# (the Sorts of R16) , ( Bool (the Sorts of R16) ) #);
correctness;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
cluster ( Full R16 ) ->  strict  additive  absolutely-additive  multiplicative  absolutely-multiplicative  properly-upper-bound  properly-lower-bound;
coherence
proof
thus L470: ( Full R16 ) is  strict;
thus L471: (the Family of ( Full R16 )) is  additive  absolutely-additive  multiplicative  absolutely-multiplicative  properly-upper-bound  properly-lower-bound;
end;
end;
registration
let R15 being 1-sorted;
let C96 being  non-empty many-sorted over R15;
cluster ( Full C96 ) ->  non-empty;
coherence by MSUALG_1:def 3;
end;
registration
let R15 being 1-sorted;
cluster  strict  non-empty  additive  absolutely-additive  multiplicative  absolutely-multiplicative  properly-upper-bound  properly-lower-bound for ClosureStr over R15;
existence
proof
set D22 = the  non-empty many-sorted over R15;
take ( Full D22 );
thus L474: thesis;
end;
end;
registration
let R15 being 1-sorted;
let C97 being  additive ClosureStr over R15;
cluster (the Family of C97) ->  additive;
coherence by L462;
end;
registration
let R15 being 1-sorted;
let C98 being  absolutely-additive ClosureStr over R15;
cluster (the Family of C98) ->  absolutely-additive;
coherence by L463;
end;
registration
let R15 being 1-sorted;
let C99 being  multiplicative ClosureStr over R15;
cluster (the Family of C99) ->  multiplicative;
coherence by L464;
end;
registration
let R15 being 1-sorted;
let C100 being  absolutely-multiplicative ClosureStr over R15;
cluster (the Family of C100) ->  absolutely-multiplicative;
coherence by L465;
end;
registration
let R15 being 1-sorted;
let C101 being  properly-upper-bound ClosureStr over R15;
cluster (the Family of C101) ->  properly-upper-bound;
coherence by L466;
end;
registration
let R15 being 1-sorted;
let C102 being  properly-lower-bound ClosureStr over R15;
cluster (the Family of C102) ->  properly-lower-bound;
coherence by L467;
end;
registration
let R15 being 1-sorted;
let C103 being  non-empty (ManySortedSet of (the carrier of R15));
let C104 being (SubsetFamily of C103);
cluster ClosureStr (# C103 , C104 #) ->  non-empty;
coherence
proof
thus L482: (the Sorts of ClosureStr (# C103 , C104 #)) is  non-empty;
end;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
let C105 being  additive (SubsetFamily of (the Sorts of R16));
cluster ClosureStr (# (the Sorts of R16) , C105 #) ->  additive;
coherence by L462;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
let C106 being  absolutely-additive (SubsetFamily of (the Sorts of R16));
cluster ClosureStr (# (the Sorts of R16) , C106 #) ->  absolutely-additive;
coherence by L463;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
let C107 being  multiplicative (SubsetFamily of (the Sorts of R16));
cluster ClosureStr (# (the Sorts of R16) , C107 #) ->  multiplicative;
coherence by L464;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
let C108 being  absolutely-multiplicative (SubsetFamily of (the Sorts of R16));
cluster ClosureStr (# (the Sorts of R16) , C108 #) ->  absolutely-multiplicative;
coherence by L465;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
let C109 being  properly-upper-bound (SubsetFamily of (the Sorts of R16));
cluster ClosureStr (# (the Sorts of R16) , C109 #) ->  properly-upper-bound;
coherence by L466;
end;
registration
let R15 being 1-sorted;
let R16 being many-sorted over R15;
let C110 being  properly-lower-bound (SubsetFamily of (the Sorts of R16));
cluster ClosureStr (# (the Sorts of R16) , C110 #) ->  properly-lower-bound;
coherence by L467;
end;
registration
let R15 being 1-sorted;
cluster  absolutely-additive ->  additive for ClosureStr over R15;
coherence
proof
let C111 being ClosureStr over R15;
assume L490: C111 is  absolutely-additive;
thus L491: (the Family of C111) is  additive by L490;
end;
end;
registration
let R15 being 1-sorted;
cluster  absolutely-multiplicative ->  multiplicative for ClosureStr over R15;
coherence
proof
let C112 being ClosureStr over R15;
assume L493: C112 is  absolutely-multiplicative;
thus L494: (the Family of C112) is  multiplicative by L493;
end;
end;
registration
let R15 being 1-sorted;
cluster  absolutely-multiplicative ->  properly-upper-bound for ClosureStr over R15;
coherence
proof
let C113 being ClosureStr over R15;
assume L496: C113 is  absolutely-multiplicative;
thus L497: (the Family of C113) is  properly-upper-bound by L496;
end;
end;
registration
let R15 being 1-sorted;
cluster  absolutely-additive ->  properly-lower-bound for ClosureStr over R15;
coherence
proof
let C114 being ClosureStr over R15;
assume L499: C114 is  absolutely-additive;
thus L500: (the Family of C114) is  properly-lower-bound by L499;
end;
end;
definition
let R15 being 1-sorted;
mode ClosureSystem of R15
 is  absolutely-multiplicative ClosureStr over R15;
end;
definition
let R3 being set;
let R6 being (ManySortedSet of R3);
mode ClosureOperator of R6
 is  reflexive  monotonic  idempotent (SetOp of R6);
end;
definition
let R15 being 1-sorted;
let C115 being (ManySortedSet of (the carrier of R15));
let C116 being (ClosureOperator of C115);
func ClOp->ClSys C116 ->  strict ClosureStr over R15 means 
:L504: ((the Sorts of it) = C115 & (the Family of it) = { B74 where B74 is (Element of ( Bool C115 )) : ( C116 . B74 ) = B74 });
existence
proof
defpred S3[ set ] means ( C116 . $1 ) = $1;
set D23 = { B75 where B75 is (Element of ( Bool C115 )) : S3[ B75 ] };
L505: D23 is (Subset of ( Bool C115 )) from DOMAIN_1:sch 7;
reconsider D24 = D23 as (SubsetFamily of C115) by L505;
take ClosureStr (# C115 , D24 #);
thus L506: thesis;
end;
uniqueness;
end;
registration
let R15 being 1-sorted;
let C117 being (ManySortedSet of (the carrier of R15));
let C118 being (ClosureOperator of C117);
cluster ( ClOp->ClSys C118 ) ->  absolutely-multiplicative;
coherence
proof
L508: (the Sorts of ( ClOp->ClSys C118 )) = C117 by L504;
defpred S4[ set ] means ( C118 . $1 ) = $1;
set D25 = { B76 where B76 is (Element of ( Bool C117 )) : S4[ B76 ] };
L509: D25 = (the Family of ( ClOp->ClSys C118 )) by L504;
L510: D25 is (Subset of ( Bool C117 )) from DOMAIN_1:sch 7;
reconsider D26 = D25 as (SubsetFamily of C117) by L510;
L511: ( ClOp->ClSys C118 ) = ClosureStr (# C117 , D26 #) by L508 , L509;
L512: D26 is  absolutely-multiplicative
proof
let C119 being (SubsetFamily of C117);
assume that
L513: C119 c= D26;
reconsider D27 = ( meet |: C119 :| ) as (Element of ( Bool C117 )) by L18;
L514:
now
let C120 being (ManySortedSet of (the carrier of R15));
assume L515: C120 in C119;
reconsider D28 = C120 as (Element of ( Bool C117 )) by L515;
L516: C120 in D26 by L513 , L515;
L517: (ex B77 being (Element of ( Bool C117 )) st (C120 = B77 & ( C118 . B77 ) = B77)) by L516;
L518: D27 c=' D28 by L515 , L244 , MSSUBFAM:43;
thus L519: ( C118 . D27 ) c=' C120 by L518 , L517 , L362;
end;
L520: ( C118 . D27 ) c=' D27 by L514 , L262;
L521: D27 c=' ( C118 . D27 ) by L361;
L522: ( C118 . D27 ) = D27 by L521 , L520 , PBOOLE:146;
thus L523: thesis by L522;
end;
thus L524: ( ClOp->ClSys C118 ) is  absolutely-multiplicative by L512 , L511;
end;
end;
definition
let R15 being 1-sorted;
let C121 being (ClosureSystem of R15);
let C122 being (ManySortedSubset of (the Sorts of C121));
func Cl C122 -> (Element of ( Bool (the Sorts of C121) )) means 
:L526: (ex B78 being (SubsetFamily of (the Sorts of C121)) st (it = ( meet |: B78 :| ) & B78 = { B79 where B79 is (Element of ( Bool (the Sorts of C121) )) : (C122 c=' B79 & B79 in (the Family of C121)) }));
existence
proof
defpred S5[ (Element of ( Bool (the Sorts of C121) )) ] means (C122 c= $1 & $1 in (the Family of C121));
L527: { B80 where B80 is (Element of ( Bool (the Sorts of C121) )) : S5[ B80 ] } is (Subset of ( Bool (the Sorts of C121) )) from DOMAIN_1:sch 7;
reconsider D29 = { B81 where B81 is (Element of ( Bool (the Sorts of C121) )) : (C122 c= B81 & B81 in (the Family of C121)) } as (SubsetFamily of (the Sorts of C121)) by L527;
reconsider D30 = ( meet |: D29 :| ) as (Element of ( Bool (the Sorts of C121) )) by L18;
take D30;
take D29;
thus L528: thesis;
end;
uniqueness;
end;
theorem
L530: (for R15 being 1-sorted holds (for B82 being (ClosureSystem of R15) holds (for B83 being (Element of ( Bool (the Sorts of B82) )) holds (for B84 being (SetOp of (the Sorts of B82)) holds ((B83 in (the Family of B82) & (for B85 being (Element of ( Bool (the Sorts of B82) )) holds ( B84 . B85 ) = ( Cl B85 ))) implies ( B84 . B83 ) = B83)))))
proof
let R15 being 1-sorted;
let C123 being (ClosureSystem of R15);
let C124 being (Element of ( Bool (the Sorts of C123) ));
let C125 being (SetOp of (the Sorts of C123));
assume that
L531: C124 in (the Family of C123)
and
L532: (for B86 being (Element of ( Bool (the Sorts of C123) )) holds ( C125 . B86 ) = ( Cl B86 ));
consider C126 being (SubsetFamily of (the Sorts of C123)) such that L533: ( Cl C124 ) = ( meet |: C126 :| ) and L534: C126 = { B87 where B87 is (Element of ( Bool (the Sorts of C123) )) : (C124 c=' B87 & B87 in (the Family of C123)) } by L526;
L535: ( C125 . C124 ) = ( meet |: C126 :| ) by L532 , L533;
L536: C124 in C126 by L531 , L534;
L537: ( C125 . C124 ) c= C124 by L536 , L535 , L244 , MSSUBFAM:43;
L538: (for B88 being (ManySortedSet of (the carrier of R15)) holds (B88 in C126 implies C124 c=' B88))
proof
let C127 being (ManySortedSet of (the carrier of R15));
assume L539: C127 in C126;
L540: (ex B89 being (Element of ( Bool (the Sorts of C123) )) st (C127 = B89 & C124 c=' B89 & B89 in (the Family of C123))) by L539 , L534;
thus L541: thesis by L540;
end;
L542: C124 c= ( C125 . C124 ) by L538 , L535 , L262;
thus L543: thesis by L542 , L537 , PBOOLE:146;
end;
theorem
L544: (for R15 being 1-sorted holds (for B90 being (ClosureSystem of R15) holds (for B91 being (Element of ( Bool (the Sorts of B90) )) holds (for B92 being (SetOp of (the Sorts of B90)) holds ((( B92 . B91 ) = B91 & (for B93 being (Element of ( Bool (the Sorts of B90) )) holds ( B92 . B93 ) = ( Cl B93 ))) implies B91 in (the Family of B90))))))
proof
let R15 being 1-sorted;
deffunc H2(set) = $1;
let C128 being (ClosureSystem of R15);
let C129 being (Element of ( Bool (the Sorts of C128) ));
let C130 being (SetOp of (the Sorts of C128));
assume that
L545: (( C130 . C129 ) = C129 & (for B94 being (Element of ( Bool (the Sorts of C128) )) holds ( C130 . B94 ) = ( Cl B94 )));
set D31 = (the Family of C128);
set D32 = (the Sorts of C128);
defpred S6[ (Element of ( Bool D32 )) ] means C129 c=' $1;
defpred S7[ (Element of ( Bool D32 )) ] means (C129 c=' $1 & $1 in D31);
defpred S8[ (Element of ( Bool D32 )) ] means ($1 in D31 & C129 c=' $1);
L546: { H2(B95) where B95 is (Element of ( Bool D32 )) : (H2(B95) in D31 & S6[ B95 ]) } c= D31 from FRAENKEL:sch 17;
L547: (for B96 being (Element of ( Bool D32 )) holds (S7[ B96 ] iff S8[ B96 ]));
L548: { H2(B97) where B97 is (Element of ( Bool D32 )) : S7[ B97 ] } = { H2(B98) where B98 is (Element of ( Bool D32 )) : S8[ B98 ] } from FRAENKEL:sch 3(L547);
consider C131 being (SubsetFamily of D32) such that L549: ( Cl C129 ) = ( meet |: C131 :| ) and L550: C131 = { B99 where B99 is (Element of ( Bool D32 )) : (C129 c= B99 & B99 in D31) } by L526;
L551: C129 = ( meet |: C131 :| ) by L545 , L549;
thus L552: thesis by L551 , L550 , L546 , L548 , L289;
end;
theorem
L553: (for R15 being 1-sorted holds (for B100 being (ClosureSystem of R15) holds (for B101 being (SetOp of (the Sorts of B100)) holds ((for B102 being (Element of ( Bool (the Sorts of B100) )) holds ( B101 . B102 ) = ( Cl B102 )) implies B101 is  reflexive  monotonic  idempotent))))
proof
let R15 being 1-sorted;
let C132 being (ClosureSystem of R15);
let C133 being (SetOp of (the Sorts of C132));
assume that
L554: (for B103 being (Element of ( Bool (the Sorts of C132) )) holds ( C133 . B103 ) = ( Cl B103 ));
set D33 = (the Sorts of C132);
L555: C133 is  reflexive
proof
let C134 being (Element of ( Bool D33 ));
consider C135 being (SubsetFamily of D33) such that L556: ( Cl C134 ) = ( meet |: C135 :| ) and L557: C135 = { B104 where B104 is (Element of ( Bool (the Sorts of C132) )) : (C134 c=' B104 & B104 in (the Family of C132)) } by L526;
L558: (for B105 being (ManySortedSet of (the carrier of R15)) holds (B105 in C135 implies C134 c=' B105))
proof
let C136 being (ManySortedSet of (the carrier of R15));
assume L559: C136 in C135;
L560: (ex B106 being (Element of ( Bool D33 )) st (C136 = B106 & C134 c=' B106 & B106 in (the Family of C132))) by L559 , L557;
thus L561: thesis by L560;
end;
L562: ( C133 . C134 ) = ( meet |: C135 :| ) by L554 , L556;
thus L563: thesis by L562 , L558 , L262;
end;
L564: C133 is  monotonic
proof
let C137 , C138 being (Element of ( Bool D33 ));
assume that
L565: C137 c=' C138;
consider C139 being (SubsetFamily of D33) such that L566: ( Cl C138 ) = ( meet |: C139 :| ) and L567: C139 = { B107 where B107 is (Element of ( Bool (the Sorts of C132) )) : (C138 c=' B107 & B107 in (the Family of C132)) } by L526;
consider C140 being (SubsetFamily of D33) such that L568: ( Cl C137 ) = ( meet |: C140 :| ) and L569: C140 = { B108 where B108 is (Element of ( Bool (the Sorts of C132) )) : (C137 c=' B108 & B108 in (the Family of C132)) } by L526;
L570: |: C139 :| c=' |: C140 :|
proof
let R1 being set;
assume that
L571: R1 in (the carrier of R15);
thus L572: ( |: C139 :| . R1 ) c= ( |: C140 :| . R1 )
proof
let C141 being set;
assume that
L573: C141 in ( |: C139 :| . R1 );
per cases ;
suppose L574: C139 is  empty;

reconsider D34 = C139 as  empty (SubsetFamily of D33) by L574;
L575: ( |: D34 :| . R1 ) is  empty;
thus L576: thesis by L575 , L573;
end;
suppose L577: C139 is non  empty;

L578: ( |: C139 :| . R1 ) = { ( B109 . R1 ) where B109 is (Element of ( Bool D33 )) : B109 in C139 } by L577 , L571 , L133;
consider C142 being (Element of ( Bool D33 )) such that L579: C141 = ( C142 . R1 ) and L580: C142 in C139 by L578 , L573;
L581: (ex B110 being (Element of ( Bool D33 )) st (B110 = C142 & C138 c=' B110 & B110 in (the Family of C132))) by L567 , L580;
L582: C137 c=' C142 by L581 , L565 , PBOOLE:13;
L583: C142 in C140 by L582 , L569 , L581;
L584: ( |: C140 :| . R1 ) = { ( B111 . R1 ) where B111 is (Element of ( Bool D33 )) : B111 in C140 } by L583 , L571 , L133;
thus L585: thesis by L584 , L579 , L583;
end;
end;

end;
L573: ( meet |: C140 :| ) c=' ( meet |: C139 :| ) by L570 , MSSUBFAM:46;
L574: ( meet |: C140 :| ) c=' ( C133 . C138 ) by L573 , L554 , L566;
thus L575: thesis by L574 , L554 , L568;
end;
L576: C133 is  idempotent
proof
let C143 being (Element of ( Bool D33 ));
consider C144 being (SubsetFamily of D33) such that L577: ( Cl C143 ) = ( meet |: C144 :| ) and L578: C144 = { B112 where B112 is (Element of ( Bool (the Sorts of C132) )) : (C143 c=' B112 & B112 in (the Family of C132)) } by L526;
L579: C144 c= (the Family of C132)
proof
let C145 being set;
assume L580: C145 in C144;
L581: (ex B113 being (Element of ( Bool D33 )) st (C145 = B113 & C143 c=' B113 & B113 in (the Family of C132))) by L580 , L578;
thus L582: thesis by L581;
end;
L583: ( meet |: C144 :| ) in (the Family of C132) by L579 , L289;
thus L584: ( C133 . C143 ) = ( meet |: C144 :| ) by L554 , L577
.= ( C133 . ( meet |: C144 :| ) ) by L554 , L583 , L530
.= ( C133 . ( C133 . C143 ) ) by L554 , L577;
end;
thus L585: thesis by L576 , L555 , L564;
end;
definition
let R15 being 1-sorted;
let C146 being (ClosureSystem of R15);
func ClSys->ClOp C146 -> (ClosureOperator of (the Sorts of C146)) means 
:L586: (for B114 being (Element of ( Bool (the Sorts of C146) )) holds ( it . B114 ) = ( Cl B114 ));
existence
proof
set D35 = (the Sorts of C146);
deffunc H3((Element of ( Bool D35 ))) = ( Cl $1 );
consider C147 being (Function of ( Bool D35 ) , ( Bool D35 )) such that L587: (for B115 being (Element of ( Bool D35 )) holds ( C147 . B115 ) = H3(B115)) from FUNCT_2:sch 4;
reconsider D36 = C147 as (SetOp of D35);
reconsider D37 = D36 as (ClosureOperator of D35) by L587 , L553;
take D37;
thus L588: thesis by L587;
end;
uniqueness
proof
let C148 , C149 being (ClosureOperator of (the Sorts of C146));
assume that
L589: (for B116 being (Element of ( Bool (the Sorts of C146) )) holds ( C148 . B116 ) = ( Cl B116 ))
and
L590: (for B117 being (Element of ( Bool (the Sorts of C146) )) holds ( C149 . B117 ) = ( Cl B117 ));
L591:
now
set D38 = ( Bool (the Sorts of C146) );
thus L592: D38 = ( dom C148 ) by FUNCT_2:def 1;
thus L593: D38 = ( dom C149 ) by FUNCT_2:def 1;
let R2 being set;
assume L594: R2 in D38;
reconsider D39 = R2 as (Element of ( Bool (the Sorts of C146) )) by L594;
thus L595: ( C148 . R2 ) = ( Cl D39 ) by L589
.= ( C149 . R2 ) by L590;
end;
thus L596: C148 = C149 by L591 , FUNCT_1:2;
end;
end;
theorem
L598: (for R15 being 1-sorted holds (for B118 being (ManySortedSet of (the carrier of R15)) holds (for B119 being (ClosureOperator of B118) holds ( ClSys->ClOp ( ClOp->ClSys B119 ) ) = B119)))
proof
let R15 being 1-sorted;
let C150 being (ManySortedSet of (the carrier of R15));
let C151 being (ClosureOperator of C150);
set D40 = ( ClOp->ClSys C151 );
set D41 = (the Sorts of D40);
set D42 = ( ClSys->ClOp D40 );
L599: C150 = D41 by L504;
reconsider D43 = C151 as  reflexive  idempotent  monotonic (SetOp of D41) by L599;
L600: (for R2 being set holds (R2 in ( Bool C150 ) implies ( D42 . R2 ) = ( D43 . R2 )))
proof
let R2 being set;
assume L601: R2 in ( Bool C150 );
reconsider D44 = R2 as (Element of ( Bool D41 )) by L601 , L504;
consider C152 being (SubsetFamily of D41) such that L602: ( Cl D44 ) = ( meet |: C152 :| ) and L603: C152 = { B120 where B120 is (Element of ( Bool D41 )) : (D44 c=' B120 & B120 in (the Family of D40)) } by L526;
L604:
now
L605: D44 c=' ( D43 . D44 ) by L361;
L606: (D44 c=' D41 & D41 in (the Family of D40)) by L290 , PBOOLE:def 18;
L607: D41 in C152 by L606 , L603;
reconsider D45 = C152 as non  empty (SubsetFamily of D41) by L607;
let R1 being set;
assume L608: R1 in (the carrier of R15);
consider C153 being (Subset-Family of ( D41 . R1 )) such that L609: C153 = ( |: C152 :| . R1 ) and L610: ( ( meet |: C152 :| ) . R1 ) = ( Intersect C153 ) by L608 , MSSUBFAM:def 1;
L611: C153 = { ( B121 . R1 ) where B121 is (Element of ( Bool D41 )) : B121 in D45 } by L608 , L609 , L133;
L612: (the Family of D40) = { B122 where B122 is (Element of ( Bool D41 )) : ( D43 . B122 ) = B122 } by L599 , L504;
L613:
now
let C154 being set;
assume L614: C154 in C153;
consider C155 being (Element of ( Bool D41 )) such that L615: C154 = ( C155 . R1 ) and L616: C155 in D45 by L614 , L611;
consider C156 being (Element of ( Bool D41 )) such that L617: C155 = C156 and L618: (D44 c=' C156 & C156 in (the Family of D40)) by L603 , L616;
L619: ((ex B123 being (Element of ( Bool D41 )) st (C156 = B123 & ( D43 . B123 ) = B123)) & ( D43 . D44 ) c=' ( D43 . C156 )) by L612 , L618 , L362;
thus L620: ( ( D43 . D44 ) . R1 ) c= C154 by L619 , L608 , L615 , L617 , PBOOLE:def 2;
end;
L621: ( D43 . ( D43 . D44 ) ) = ( D43 . D44 ) by L363;
L622: ( D43 . D44 ) in (the Family of D40) by L621 , L612;
L623: ( D43 . D44 ) in D45 by L622 , L603 , L605;
L624: ( ( D43 . D44 ) . R1 ) in C153 by L623 , L611;
L625: ( ( meet |: C152 :| ) . R1 ) c= ( ( D43 . D44 ) . R1 ) by L624 , L610 , MSSUBFAM:2;
L626: C153 = ( |: D45 :| . R1 ) by L609;
L627: ( ( D43 . D44 ) . R1 ) c= ( ( meet |: C152 :| ) . R1 ) by L626 , L608 , L610 , L613 , MSSUBFAM:5;
thus L628: ( ( meet |: C152 :| ) . R1 ) = ( ( D43 . D44 ) . R1 ) by L627 , L625 , XBOOLE_0:def 10;
end;
thus L629: ( D42 . R2 ) = ( Cl D44 ) by L586
.= ( D43 . R2 ) by L602 , L604 , PBOOLE:3;
end;
thus L630: thesis by L600 , L599 , FUNCT_2:12;
end;
deffunc H4(set) = $1;
theorem
L631: (for R15 being 1-sorted holds (for B124 being (ClosureSystem of R15) holds ( ClOp->ClSys ( ClSys->ClOp B124 ) ) = ( the ClosureStr of B124 )))
proof
let R15 being 1-sorted;
let C157 being (ClosureSystem of R15);
set D46 = (the Sorts of C157);
set D47 = (the Family of C157);
set D48 = (the Family of ( ClOp->ClSys ( ClSys->ClOp C157 ) ));
set D49 = ( ClSys->ClOp C157 );
L632: D48 = { B125 where B125 is (Element of ( Bool D46 )) : ( D49 . B125 ) = B125 } by L504;
L633: D47 = D48
proof
thus L634: D47 c= D48
proof
let C158 being set;
assume L635: C158 in D47;
reconsider D50 = C158 as (Element of ( Bool D46 )) by L635;
consider C159 being (SubsetFamily of D46) such that L636: ( Cl D50 ) = ( meet |: C159 :| ) and L637: C159 = { B126 where B126 is (Element of ( Bool D46 )) : (D50 c= B126 & B126 in D47) } by L526;
L638: (D50 c=' D46 & D46 in D47) by L290 , PBOOLE:def 18;
L639: D46 in C159 by L638 , L637;
reconsider D51 = C159 as non  empty (SubsetFamily of D46) by L639;
L640:
now
let R1 being set;
assume L641: R1 in (the carrier of R15);
consider C160 being (Subset-Family of ( D46 . R1 )) such that L642: C160 = ( |: D51 :| . R1 ) and L643: ( ( meet |: D51 :| ) . R1 ) = ( Intersect C160 ) by L641 , MSSUBFAM:def 1;
L644: C160 = { ( B127 . R1 ) where B127 is (Element of ( Bool D46 )) : B127 in D51 } by L641 , L642 , L133;
L645: D50 in D51 by L635 , L637;
L646: ( D50 . R1 ) in C160 by L645 , L644;
L647: ( Intersect C160 ) c= ( D50 . R1 ) by L646 , MSSUBFAM:2;
L648:
now
let C161 being set;
assume L649: C161 in C160;
consider C162 being (Element of ( Bool D46 )) such that L650: C161 = ( C162 . R1 ) and L651: C162 in D51 by L649 , L644;
L652: (ex B128 being (Element of ( Bool D46 )) st (B128 = C162 & D50 c=' B128 & B128 in D47)) by L637 , L651;
thus L653: ( D50 . R1 ) c= C161 by L652 , L641 , L650 , PBOOLE:def 2;
end;
L654: ( D50 . R1 ) c= ( Intersect C160 ) by L648 , L646 , MSSUBFAM:5;
L655: ( Intersect C160 ) = ( D50 . R1 ) by L654 , L647 , XBOOLE_0:def 10;
thus L656: ( ( D49 . D50 ) . R1 ) = ( D50 . R1 ) by L655 , L636 , L643 , L586;
end;
L657: ( D49 . D50 ) = D50 by L640 , PBOOLE:3;
thus L658: thesis by L657 , L632;
end;

let C163 being set;
assume L659: C163 in D48;
consider C164 being (Element of ( Bool D46 )) such that L660: (C163 = C164 & ( D49 . C164 ) = C164) by L659 , L632;
defpred S9[ (Element of ( Bool D46 )) ] means ($1 in D47 & C164 c=' $1);
defpred S10[ (Element of ( Bool D46 )) ] means (C164 c=' $1 & $1 in D47);
defpred S11[ (Element of ( Bool D46 )) ] means C164 c=' $1;
L661: { H4(B129) where B129 is (Element of ( Bool D46 )) : (H4(B129) in D47 & S11[ B129 ]) } c= D47 from FRAENKEL:sch 17;
L662: (for B130 being (Element of ( Bool D46 )) holds (S10[ B130 ] iff S9[ B130 ]));
L663: { H4(B131) where B131 is (Element of ( Bool D46 )) : S10[ B131 ] } = { H4(B132) where B132 is (Element of ( Bool D46 )) : S9[ B132 ] } from FRAENKEL:sch 3(L662);
consider C165 being (SubsetFamily of D46) such that L664: ( Cl C164 ) = ( meet |: C165 :| ) and L665: C165 = { B133 where B133 is (Element of ( Bool D46 )) : (C164 c=' B133 & B133 in D47) } by L526;
L666: ( meet |: C165 :| ) = C163 by L660 , L664 , L586;
thus L667: thesis by L666 , L665 , L661 , L663 , L289;
end;
thus L668: thesis by L633 , L504;
end;
