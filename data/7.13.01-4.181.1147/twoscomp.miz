:: 2's Complement Circuit. Part I. Boolean Operators and 2's
:: Complement Circuit Properties
::  by Katsumi Wasaki and Pauline N. Kawamoto
::
:: Received October 25, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies CIRCCOMB, STRUCT_0, XBOOLE_0, MSUALG_1, LATTICES, CIRCUIT1,
      FSM_1, GLIB_000, FUNCT_1, SUBSET_1, MARGREL1, XBOOLEAN, FINSEQ_2,
      FINSEQ_1, CARD_1, FACIRC_1, MSAFREE2, FUNCT_4, RELAT_1, CIRCUIT2,
      TWOSCOMP;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, NUMBERS,
      FINSEQ_1, STRUCT_0, MARGREL1, FINSEQ_2, BINARITH, MSUALG_1, MSAFREE2,
      CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1;
 constructors BINARITH, CIRCUIT1, CIRCUIT2, FACIRC_1, RELSET_1, XTUPLE_0;
 registrations RELSET_1, XBOOLEAN, MARGREL1, CARD_3, CIRCCOMB, FACIRC_1,
      ORDINAL1, FINSEQ_1, FUNCT_1, MSAFREE2, XTUPLE_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions CIRCUIT2, XBOOLEAN, XTUPLE_0;
 theorems TARSKI, ENUMSET1, BINARITH, FUNCT_1, FINSEQ_2, CIRCUIT1, CIRCUIT2,
      CIRCCOMB, FACIRC_1, XBOOLE_0, XBOOLE_1;
 schemes FACIRC_1;

begin
definition
let C1 being  unsplit non  void non  empty ManySortedSign;
let C2 being  Boolean (Circuit of C1);
let C3 being (State of C2);
let C4 being (Vertex of C1);
redefine func C3 . C4 -> (Element of ( BOOLEAN ));

coherence
proof
L1: ( C3 . C4 ) in ( (the Sorts of C2) . C4 ) by CIRCUIT1:4;
thus L2: thesis by L1;
end;
end;
deffunc H1((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 '&' $2 );
definition
func and2 -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L4: (for B1 , B2 being (Element of ( BOOLEAN )) holds ( it . <* B1 , B2 *> ) = ( B1 '&' B2 ));
existence
proof
thus L5: (ex B3 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B4 , B5 being (Element of ( BOOLEAN )) holds ( B3 . <* B4 , B5 *> ) = H1(B4 , B5))) from FACIRC_1:sch 1;
end;
uniqueness
proof
thus L6: (for B6 , B7 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B8 , B9 being (Element of ( BOOLEAN )) holds ( B6 . <* B8 , B9 *> ) = H1(B8 , B9)) & (for B10 , B11 being (Element of ( BOOLEAN )) holds ( B7 . <* B10 , B11 *> ) = H1(B10 , B11))) implies B6 = B7)) from FACIRC_1:sch 2;
end;
func and2a -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L7: (for B12 , B13 being (Element of ( BOOLEAN )) holds ( it . <* B12 , B13 *> ) = ( ( 'not' B12 ) '&' B13 ));
existence
proof
deffunc H2((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) '&' $2 );
thus L8: (ex B14 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B15 , B16 being (Element of ( BOOLEAN )) holds ( B14 . <* B15 , B16 *> ) = H2(B15 , B16))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H3((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) '&' $2 );
thus L9: (for B17 , B18 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B19 , B20 being (Element of ( BOOLEAN )) holds ( B17 . <* B19 , B20 *> ) = H3(B19 , B20)) & (for B21 , B22 being (Element of ( BOOLEAN )) holds ( B18 . <* B21 , B22 *> ) = H3(B21 , B22))) implies B17 = B18)) from FACIRC_1:sch 2;
end;
func and2b -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L10: (for B23 , B24 being (Element of ( BOOLEAN )) holds ( it . <* B23 , B24 *> ) = ( ( 'not' B23 ) '&' ( 'not' B24 ) ));
existence
proof
deffunc H4((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) '&' ( 'not' $2 ) );
thus L11: (ex B25 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B26 , B27 being (Element of ( BOOLEAN )) holds ( B25 . <* B26 , B27 *> ) = H4(B26 , B27))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H5((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) '&' ( 'not' $2 ) );
thus L12: (for B28 , B29 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B30 , B31 being (Element of ( BOOLEAN )) holds ( B28 . <* B30 , B31 *> ) = H5(B30 , B31)) & (for B32 , B33 being (Element of ( BOOLEAN )) holds ( B29 . <* B32 , B33 *> ) = H5(B32 , B33))) implies B28 = B29)) from FACIRC_1:sch 2;
end;
end;
definition
func nand2 -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L14: (for B34 , B35 being (Element of ( BOOLEAN )) holds ( it . <* B34 , B35 *> ) = ( 'not' ( B34 '&' B35 ) ));
existence
proof
deffunc H6((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( $1 '&' $2 ) );
thus L15: (ex B36 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B37 , B38 being (Element of ( BOOLEAN )) holds ( B36 . <* B37 , B38 *> ) = H6(B37 , B38))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H7((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( $1 '&' $2 ) );
thus L16: (for B39 , B40 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B41 , B42 being (Element of ( BOOLEAN )) holds ( B39 . <* B41 , B42 *> ) = H7(B41 , B42)) & (for B43 , B44 being (Element of ( BOOLEAN )) holds ( B40 . <* B43 , B44 *> ) = H7(B43 , B44))) implies B39 = B40)) from FACIRC_1:sch 2;
end;
func nand2a -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L17: (for B45 , B46 being (Element of ( BOOLEAN )) holds ( it . <* B45 , B46 *> ) = ( 'not' ( ( 'not' B45 ) '&' B46 ) ));
existence
proof
deffunc H8((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) '&' $2 ) );
thus L18: (ex B47 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B48 , B49 being (Element of ( BOOLEAN )) holds ( B47 . <* B48 , B49 *> ) = H8(B48 , B49))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H9((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) '&' $2 ) );
thus L19: (for B50 , B51 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B52 , B53 being (Element of ( BOOLEAN )) holds ( B50 . <* B52 , B53 *> ) = H9(B52 , B53)) & (for B54 , B55 being (Element of ( BOOLEAN )) holds ( B51 . <* B54 , B55 *> ) = H9(B54 , B55))) implies B50 = B51)) from FACIRC_1:sch 2;
end;
func nand2b -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L20: (for B56 , B57 being (Element of ( BOOLEAN )) holds ( it . <* B56 , B57 *> ) = ( 'not' ( ( 'not' B56 ) '&' ( 'not' B57 ) ) ));
existence
proof
deffunc H10((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) '&' ( 'not' $2 ) ) );
thus L21: (ex B58 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B59 , B60 being (Element of ( BOOLEAN )) holds ( B58 . <* B59 , B60 *> ) = H10(B59 , B60))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H11((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) '&' ( 'not' $2 ) ) );
thus L22: (for B61 , B62 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B63 , B64 being (Element of ( BOOLEAN )) holds ( B61 . <* B63 , B64 *> ) = H11(B63 , B64)) & (for B65 , B66 being (Element of ( BOOLEAN )) holds ( B62 . <* B65 , B66 *> ) = H11(B65 , B66))) implies B61 = B62)) from FACIRC_1:sch 2;
end;
end;
definition
func or2 -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L24: (for B67 , B68 being (Element of ( BOOLEAN )) holds ( it . <* B67 , B68 *> ) = ( B67 'or' B68 ));
existence
proof
deffunc H12((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'or' $2 );
thus L25: (ex B69 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B70 , B71 being (Element of ( BOOLEAN )) holds ( B69 . <* B70 , B71 *> ) = H12(B70 , B71))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H13((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'or' $2 );
thus L26: (for B72 , B73 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B74 , B75 being (Element of ( BOOLEAN )) holds ( B72 . <* B74 , B75 *> ) = H13(B74 , B75)) & (for B76 , B77 being (Element of ( BOOLEAN )) holds ( B73 . <* B76 , B77 *> ) = H13(B76 , B77))) implies B72 = B73)) from FACIRC_1:sch 2;
end;
func or2a -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L27: (for B78 , B79 being (Element of ( BOOLEAN )) holds ( it . <* B78 , B79 *> ) = ( ( 'not' B78 ) 'or' B79 ));
existence
proof
deffunc H14((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'or' $2 );
thus L28: (ex B80 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B81 , B82 being (Element of ( BOOLEAN )) holds ( B80 . <* B81 , B82 *> ) = H14(B81 , B82))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H15((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'or' $2 );
thus L29: (for B83 , B84 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B85 , B86 being (Element of ( BOOLEAN )) holds ( B83 . <* B85 , B86 *> ) = H15(B85 , B86)) & (for B87 , B88 being (Element of ( BOOLEAN )) holds ( B84 . <* B87 , B88 *> ) = H15(B87 , B88))) implies B83 = B84)) from FACIRC_1:sch 2;
end;
func or2b -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L30: (for B89 , B90 being (Element of ( BOOLEAN )) holds ( it . <* B89 , B90 *> ) = ( ( 'not' B89 ) 'or' ( 'not' B90 ) ));
existence
proof
deffunc H16((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'or' ( 'not' $2 ) );
thus L31: (ex B91 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B92 , B93 being (Element of ( BOOLEAN )) holds ( B91 . <* B92 , B93 *> ) = H16(B92 , B93))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H17((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'or' ( 'not' $2 ) );
thus L32: (for B94 , B95 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B96 , B97 being (Element of ( BOOLEAN )) holds ( B94 . <* B96 , B97 *> ) = H17(B96 , B97)) & (for B98 , B99 being (Element of ( BOOLEAN )) holds ( B95 . <* B98 , B99 *> ) = H17(B98 , B99))) implies B94 = B95)) from FACIRC_1:sch 2;
end;
end;
definition
func nor2 -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L34: (for B100 , B101 being (Element of ( BOOLEAN )) holds ( it . <* B100 , B101 *> ) = ( 'not' ( B100 'or' B101 ) ));
existence
proof
deffunc H18((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( $1 'or' $2 ) );
thus L35: (ex B102 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B103 , B104 being (Element of ( BOOLEAN )) holds ( B102 . <* B103 , B104 *> ) = H18(B103 , B104))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H19((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( $1 'or' $2 ) );
thus L36: (for B105 , B106 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B107 , B108 being (Element of ( BOOLEAN )) holds ( B105 . <* B107 , B108 *> ) = H19(B107 , B108)) & (for B109 , B110 being (Element of ( BOOLEAN )) holds ( B106 . <* B109 , B110 *> ) = H19(B109 , B110))) implies B105 = B106)) from FACIRC_1:sch 2;
end;
func nor2a -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L37: (for B111 , B112 being (Element of ( BOOLEAN )) holds ( it . <* B111 , B112 *> ) = ( 'not' ( ( 'not' B111 ) 'or' B112 ) ));
existence
proof
deffunc H20((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) 'or' $2 ) );
thus L38: (ex B113 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B114 , B115 being (Element of ( BOOLEAN )) holds ( B113 . <* B114 , B115 *> ) = H20(B114 , B115))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H21((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) 'or' $2 ) );
thus L39: (for B116 , B117 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B118 , B119 being (Element of ( BOOLEAN )) holds ( B116 . <* B118 , B119 *> ) = H21(B118 , B119)) & (for B120 , B121 being (Element of ( BOOLEAN )) holds ( B117 . <* B120 , B121 *> ) = H21(B120 , B121))) implies B116 = B117)) from FACIRC_1:sch 2;
end;
func nor2b -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L40: (for B122 , B123 being (Element of ( BOOLEAN )) holds ( it . <* B122 , B123 *> ) = ( 'not' ( ( 'not' B122 ) 'or' ( 'not' B123 ) ) ));
existence
proof
deffunc H22((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) );
thus L41: (ex B124 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B125 , B126 being (Element of ( BOOLEAN )) holds ( B124 . <* B125 , B126 *> ) = H22(B125 , B126))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H23((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) );
thus L42: (for B127 , B128 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B129 , B130 being (Element of ( BOOLEAN )) holds ( B127 . <* B129 , B130 *> ) = H23(B129 , B130)) & (for B131 , B132 being (Element of ( BOOLEAN )) holds ( B128 . <* B131 , B132 *> ) = H23(B131 , B132))) implies B127 = B128)) from FACIRC_1:sch 2;
end;
end;
definition
func xor2 -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L44: (for B133 , B134 being (Element of ( BOOLEAN )) holds ( it . <* B133 , B134 *> ) = ( B133 'xor' B134 ));
existence
proof
deffunc H24((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'xor' $2 );
thus L45: (ex B135 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B136 , B137 being (Element of ( BOOLEAN )) holds ( B135 . <* B136 , B137 *> ) = H24(B136 , B137))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H25((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( $1 'xor' $2 );
thus L46: (for B138 , B139 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B140 , B141 being (Element of ( BOOLEAN )) holds ( B138 . <* B140 , B141 *> ) = H25(B140 , B141)) & (for B142 , B143 being (Element of ( BOOLEAN )) holds ( B139 . <* B142 , B143 *> ) = H25(B142 , B143))) implies B138 = B139)) from FACIRC_1:sch 2;
end;
func xor2a -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L47: (for B144 , B145 being (Element of ( BOOLEAN )) holds ( it . <* B144 , B145 *> ) = ( ( 'not' B144 ) 'xor' B145 ));
existence
proof
deffunc H26((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'xor' $2 );
thus L48: (ex B146 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B147 , B148 being (Element of ( BOOLEAN )) holds ( B146 . <* B147 , B148 *> ) = H26(B147 , B148))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H27((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'xor' $2 );
thus L49: (for B149 , B150 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B151 , B152 being (Element of ( BOOLEAN )) holds ( B149 . <* B151 , B152 *> ) = H27(B151 , B152)) & (for B153 , B154 being (Element of ( BOOLEAN )) holds ( B150 . <* B153 , B154 *> ) = H27(B153 , B154))) implies B149 = B150)) from FACIRC_1:sch 2;
end;
func xor2b -> (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L50: (for B155 , B156 being (Element of ( BOOLEAN )) holds ( it . <* B155 , B156 *> ) = ( ( 'not' B155 ) 'xor' ( 'not' B156 ) ));
existence
proof
deffunc H28((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'xor' ( 'not' $2 ) );
thus L51: (ex B157 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B158 , B159 being (Element of ( BOOLEAN )) holds ( B157 . <* B158 , B159 *> ) = H28(B158 , B159))) from FACIRC_1:sch 1;
end;
uniqueness
proof
deffunc H29((Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( 'not' $1 ) 'xor' ( 'not' $2 ) );
thus L52: (for B160 , B161 being (Function of ( 2 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B162 , B163 being (Element of ( BOOLEAN )) holds ( B160 . <* B162 , B163 *> ) = H29(B162 , B163)) & (for B164 , B165 being (Element of ( BOOLEAN )) holds ( B161 . <* B164 , B165 *> ) = H29(B164 , B165))) implies B160 = B161)) from FACIRC_1:sch 2;
end;
end;
theorem
L54: (for B166 , B167 being (Element of ( BOOLEAN )) holds (( ( and2 ) . <* B166 , B167 *> ) = ( B166 '&' B167 ) & ( ( and2a ) . <* B166 , B167 *> ) = ( ( 'not' B166 ) '&' B167 ) & ( ( and2b ) . <* B166 , B167 *> ) = ( ( 'not' B166 ) '&' ( 'not' B167 ) ))) by L4 , L7 , L10;
theorem
L55: (for B168 , B169 being (Element of ( BOOLEAN )) holds (( ( nand2 ) . <* B168 , B169 *> ) = ( 'not' ( B168 '&' B169 ) ) & ( ( nand2a ) . <* B168 , B169 *> ) = ( 'not' ( ( 'not' B168 ) '&' B169 ) ) & ( ( nand2b ) . <* B168 , B169 *> ) = ( 'not' ( ( 'not' B168 ) '&' ( 'not' B169 ) ) ))) by L14 , L17 , L20;
theorem
L56: (for B170 , B171 being (Element of ( BOOLEAN )) holds (( ( or2 ) . <* B170 , B171 *> ) = ( B170 'or' B171 ) & ( ( or2a ) . <* B170 , B171 *> ) = ( ( 'not' B170 ) 'or' B171 ) & ( ( or2b ) . <* B170 , B171 *> ) = ( ( 'not' B170 ) 'or' ( 'not' B171 ) ))) by L24 , L27 , L30;
theorem
L57: (for B172 , B173 being (Element of ( BOOLEAN )) holds (( ( nor2 ) . <* B172 , B173 *> ) = ( 'not' ( B172 'or' B173 ) ) & ( ( nor2a ) . <* B172 , B173 *> ) = ( 'not' ( ( 'not' B172 ) 'or' B173 ) ) & ( ( nor2b ) . <* B172 , B173 *> ) = ( 'not' ( ( 'not' B172 ) 'or' ( 'not' B173 ) ) ))) by L34 , L37 , L40;
theorem
L58: (for B174 , B175 being (Element of ( BOOLEAN )) holds (( ( xor2 ) . <* B174 , B175 *> ) = ( B174 'xor' B175 ) & ( ( xor2a ) . <* B174 , B175 *> ) = ( ( 'not' B174 ) 'xor' B175 ) & ( ( xor2b ) . <* B174 , B175 *> ) = ( ( 'not' B174 ) 'xor' ( 'not' B175 ) ))) by L44 , L47 , L50;
theorem
L59: (for B176 , B177 being (Element of ( BOOLEAN )) holds (( ( and2 ) . <* B176 , B177 *> ) = ( ( nor2b ) . <* B176 , B177 *> ) & ( ( and2a ) . <* B176 , B177 *> ) = ( ( nor2a ) . <* B177 , B176 *> ) & ( ( and2b ) . <* B176 , B177 *> ) = ( ( nor2 ) . <* B176 , B177 *> )))
proof
let C5 , C6 being (Element of ( BOOLEAN ));
thus L60: ( ( and2 ) . <* C5 , C6 *> ) = ( 'not' ( ( 'not' C5 ) 'or' ( 'not' C6 ) ) ) by L4
.= ( ( nor2b ) . <* C5 , C6 *> ) by L40;
thus L61: ( ( and2a ) . <* C5 , C6 *> ) = ( 'not' ( ( 'not' ( 'not' C5 ) ) 'or' ( 'not' C6 ) ) ) by L7
.= ( ( nor2a ) . <* C6 , C5 *> ) by L37;
thus L62: ( ( and2b ) . <* C5 , C6 *> ) = ( 'not' ( ( 'not' ( 'not' C5 ) ) 'or' ( 'not' ( 'not' C6 ) ) ) ) by L10
.= ( ( nor2 ) . <* C5 , C6 *> ) by L34;
end;
theorem
L63: (for B178 , B179 being (Element of ( BOOLEAN )) holds (( ( or2 ) . <* B178 , B179 *> ) = ( ( nand2b ) . <* B178 , B179 *> ) & ( ( or2a ) . <* B178 , B179 *> ) = ( ( nand2a ) . <* B179 , B178 *> ) & ( ( or2b ) . <* B178 , B179 *> ) = ( ( nand2 ) . <* B178 , B179 *> )))
proof
let C7 , C8 being (Element of ( BOOLEAN ));
thus L64: ( ( or2 ) . <* C7 , C8 *> ) = ( C7 'or' C8 ) by L24
.= ( ( nand2b ) . <* C7 , C8 *> ) by L20;
thus L65: ( ( or2a ) . <* C7 , C8 *> ) = ( ( 'not' C7 ) 'or' C8 ) by L27
.= ( ( nand2a ) . <* C8 , C7 *> ) by L17;
thus L66: ( ( or2b ) . <* C7 , C8 *> ) = ( ( 'not' C7 ) 'or' ( 'not' C8 ) ) by L30
.= ( ( nand2 ) . <* C7 , C8 *> ) by L14;
end;
theorem
L67: (for B180 , B181 being (Element of ( BOOLEAN )) holds ( ( xor2b ) . <* B180 , B181 *> ) = ( ( xor2 ) . <* B180 , B181 *> ))
proof
let C9 , C10 being (Element of ( BOOLEAN ));
thus L68: ( ( xor2b ) . <* C9 , C10 *> ) = ( ( 'not' C9 ) 'xor' ( 'not' C10 ) ) by L50
.= ( C9 'xor' C10 )
.= ( ( xor2 ) . <* C9 , C10 *> ) by L44;
end;
theorem
L69: (( ( and2 ) . <* ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and2 ) . <* ( 0 ) , 1 *> ) = ( 0 ) & ( ( and2 ) . <* 1 , ( 0 ) *> ) = ( 0 ) & ( ( and2 ) . <* 1 , 1 *> ) = 1 & ( ( and2a ) . <* ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and2a ) . <* ( 0 ) , 1 *> ) = 1 & ( ( and2a ) . <* 1 , ( 0 ) *> ) = ( 0 ) & ( ( and2a ) . <* 1 , 1 *> ) = ( 0 ) & ( ( and2b ) . <* ( 0 ) , ( 0 ) *> ) = 1 & ( ( and2b ) . <* ( 0 ) , 1 *> ) = ( 0 ) & ( ( and2b ) . <* 1 , ( 0 ) *> ) = ( 0 ) & ( ( and2b ) . <* 1 , 1 *> ) = ( 0 ))
proof
thus L70: ( ( and2 ) . <* ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) '&' ( FALSE ) ) by L4
.= ( 0 );
thus L71: ( ( and2 ) . <* ( 0 ) , 1 *> ) = ( ( FALSE ) '&' ( TRUE ) ) by L4
.= ( 0 );
thus L72: ( ( and2 ) . <* 1 , ( 0 ) *> ) = ( ( TRUE ) '&' ( FALSE ) ) by L4
.= ( 0 );
thus L73: ( ( and2 ) . <* 1 , 1 *> ) = ( ( TRUE ) '&' ( TRUE ) ) by L4
.= 1;
thus L74: ( ( and2a ) . <* ( 0 ) , ( 0 ) *> ) = ( ( 'not' ( FALSE ) ) '&' ( FALSE ) ) by L7
.= ( 0 );
thus L75: ( ( and2a ) . <* ( 0 ) , 1 *> ) = ( ( 'not' ( FALSE ) ) '&' ( TRUE ) ) by L7
.= 1;
thus L76: ( ( and2a ) . <* 1 , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) '&' ( FALSE ) ) by L7
.= ( 0 );
thus L77: ( ( and2a ) . <* 1 , 1 *> ) = ( ( 'not' ( TRUE ) ) '&' ( TRUE ) ) by L7
.= ( 0 );
thus L78: ( ( and2b ) . <* ( 0 ) , ( 0 ) *> ) = ( ( TRUE ) '&' ( 'not' ( FALSE ) ) ) by L10
.= 1;
thus L79: ( ( and2b ) . <* ( 0 ) , 1 *> ) = ( ( 'not' ( FALSE ) ) '&' ( 'not' ( TRUE ) ) ) by L10
.= ( 0 );
thus L80: ( ( and2b ) . <* 1 , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) '&' ( 'not' ( FALSE ) ) ) by L10
.= ( 0 );
thus L81: ( ( and2b ) . <* 1 , 1 *> ) = ( ( FALSE ) '&' ( 'not' ( TRUE ) ) ) by L10
.= ( 0 );
end;
theorem
L82: (( ( or2 ) . <* ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( or2 ) . <* ( 0 ) , 1 *> ) = 1 & ( ( or2 ) . <* 1 , ( 0 ) *> ) = 1 & ( ( or2 ) . <* 1 , 1 *> ) = 1 & ( ( or2a ) . <* ( 0 ) , ( 0 ) *> ) = 1 & ( ( or2a ) . <* ( 0 ) , 1 *> ) = 1 & ( ( or2a ) . <* 1 , ( 0 ) *> ) = ( 0 ) & ( ( or2a ) . <* 1 , 1 *> ) = 1 & ( ( or2b ) . <* ( 0 ) , ( 0 ) *> ) = 1 & ( ( or2b ) . <* ( 0 ) , 1 *> ) = 1 & ( ( or2b ) . <* 1 , ( 0 ) *> ) = 1 & ( ( or2b ) . <* 1 , 1 *> ) = ( 0 ))
proof
thus L83: ( ( or2 ) . <* ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) 'or' ( FALSE ) ) by L24
.= ( 0 );
thus L84: ( ( or2 ) . <* ( 0 ) , 1 *> ) = ( ( FALSE ) 'or' ( TRUE ) ) by L24
.= 1;
thus L85: ( ( or2 ) . <* 1 , ( 0 ) *> ) = ( ( TRUE ) 'or' ( FALSE ) ) by L24
.= 1;
thus L86: ( ( or2 ) . <* 1 , 1 *> ) = ( ( TRUE ) 'or' ( TRUE ) ) by L24
.= 1;
thus L87: ( ( or2a ) . <* ( 0 ) , ( 0 ) *> ) = ( ( TRUE ) 'or' ( FALSE ) ) by L27
.= 1;
thus L88: ( ( or2a ) . <* ( 0 ) , 1 *> ) = ( ( 'not' ( FALSE ) ) 'or' ( TRUE ) ) by L27
.= 1;
thus L89: ( ( or2a ) . <* 1 , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) 'or' ( FALSE ) ) by L27
.= ( 0 );
thus L90: ( ( or2a ) . <* 1 , 1 *> ) = ( ( 'not' ( TRUE ) ) 'or' ( TRUE ) ) by L27
.= 1;
thus L91: ( ( or2b ) . <* ( 0 ) , ( 0 ) *> ) = ( ( TRUE ) 'or' ( 'not' ( FALSE ) ) ) by L30
.= 1;
thus L92: ( ( or2b ) . <* ( 0 ) , 1 *> ) = ( ( TRUE ) 'or' ( 'not' ( TRUE ) ) ) by L30
.= 1;
thus L93: ( ( or2b ) . <* 1 , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) 'or' ( TRUE ) ) by L30
.= 1;
thus L94: ( ( or2b ) . <* 1 , 1 *> ) = ( ( FALSE ) 'or' ( 'not' ( TRUE ) ) ) by L30
.= ( 0 );
end;
theorem
L95: (( ( xor2 ) . <* ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( xor2 ) . <* ( 0 ) , 1 *> ) = 1 & ( ( xor2 ) . <* 1 , ( 0 ) *> ) = 1 & ( ( xor2 ) . <* 1 , 1 *> ) = ( 0 ) & ( ( xor2a ) . <* ( 0 ) , ( 0 ) *> ) = 1 & ( ( xor2a ) . <* ( 0 ) , 1 *> ) = ( 0 ) & ( ( xor2a ) . <* 1 , ( 0 ) *> ) = ( 0 ) & ( ( xor2a ) . <* 1 , 1 *> ) = 1)
proof
thus L96: ( ( xor2 ) . <* ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) 'xor' ( FALSE ) ) by L44
.= ( 0 );
thus L97: ( ( xor2 ) . <* ( 0 ) , 1 *> ) = ( ( FALSE ) 'xor' ( TRUE ) ) by L44
.= 1;
thus L98: ( ( xor2 ) . <* 1 , ( 0 ) *> ) = ( ( TRUE ) 'xor' ( FALSE ) ) by L44
.= 1;
thus L99: ( ( xor2 ) . <* 1 , 1 *> ) = ( ( TRUE ) 'xor' ( TRUE ) ) by L44
.= ( 0 );
thus L100: ( ( xor2a ) . <* ( 0 ) , ( 0 ) *> ) = ( ( 'not' ( FALSE ) ) 'xor' ( FALSE ) ) by L47
.= 1;
thus L101: ( ( xor2a ) . <* ( 0 ) , 1 *> ) = ( ( 'not' ( FALSE ) ) 'xor' ( TRUE ) ) by L47
.= ( 0 );
thus L102: ( ( xor2a ) . <* 1 , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) 'xor' ( FALSE ) ) by L47
.= ( 0 );
thus L103: ( ( xor2a ) . <* 1 , 1 *> ) = ( ( 'not' ( TRUE ) ) 'xor' ( TRUE ) ) by L47
.= 1;
end;
definition
func and3 -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L104: (for B182 , B183 , B184 being (Element of ( BOOLEAN )) holds ( it . <* B182 , B183 , B184 *> ) = ( ( B182 '&' B183 ) '&' B184 ));
existence
proof
deffunc H30((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 '&' $2 ) '&' $3 );
thus L105: (ex B185 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B186 , B187 , B188 being (Element of ( BOOLEAN )) holds ( B185 . <* B186 , B187 , B188 *> ) = H30(B186 , B187 , B188))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H31((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 '&' $2 ) '&' $3 );
thus L106: (for B189 , B190 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B191 , B192 , B193 being (Element of ( BOOLEAN )) holds ( B189 . <* B191 , B192 , B193 *> ) = H31(B191 , B192 , B193)) & (for B194 , B195 , B196 being (Element of ( BOOLEAN )) holds ( B190 . <* B194 , B195 , B196 *> ) = H31(B194 , B195 , B196))) implies B189 = B190)) from FACIRC_1:sch 5;
end;
func and3a -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L107: (for B197 , B198 , B199 being (Element of ( BOOLEAN )) holds ( it . <* B197 , B198 , B199 *> ) = ( ( ( 'not' B197 ) '&' B198 ) '&' B199 ));
existence
proof
deffunc H32((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) '&' $2 ) '&' $3 );
thus L108: (ex B200 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B201 , B202 , B203 being (Element of ( BOOLEAN )) holds ( B200 . <* B201 , B202 , B203 *> ) = H32(B201 , B202 , B203))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H33((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) '&' $2 ) '&' $3 );
thus L109: (for B204 , B205 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B206 , B207 , B208 being (Element of ( BOOLEAN )) holds ( B204 . <* B206 , B207 , B208 *> ) = H33(B206 , B207 , B208)) & (for B209 , B210 , B211 being (Element of ( BOOLEAN )) holds ( B205 . <* B209 , B210 , B211 *> ) = H33(B209 , B210 , B211))) implies B204 = B205)) from FACIRC_1:sch 5;
end;
func and3b -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L110: (for B212 , B213 , B214 being (Element of ( BOOLEAN )) holds ( it . <* B212 , B213 , B214 *> ) = ( ( ( 'not' B212 ) '&' ( 'not' B213 ) ) '&' B214 ));
existence
proof
deffunc H34((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' $3 );
thus L111: (ex B215 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B216 , B217 , B218 being (Element of ( BOOLEAN )) holds ( B215 . <* B216 , B217 , B218 *> ) = H34(B216 , B217 , B218))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H35((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' $3 );
thus L112: (for B219 , B220 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B221 , B222 , B223 being (Element of ( BOOLEAN )) holds ( B219 . <* B221 , B222 , B223 *> ) = H35(B221 , B222 , B223)) & (for B224 , B225 , B226 being (Element of ( BOOLEAN )) holds ( B220 . <* B224 , B225 , B226 *> ) = H35(B224 , B225 , B226))) implies B219 = B220)) from FACIRC_1:sch 5;
end;
func and3c -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L113: (for B227 , B228 , B229 being (Element of ( BOOLEAN )) holds ( it . <* B227 , B228 , B229 *> ) = ( ( ( 'not' B227 ) '&' ( 'not' B228 ) ) '&' ( 'not' B229 ) ));
existence
proof
deffunc H36((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' ( 'not' $3 ) );
thus L114: (ex B230 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B231 , B232 , B233 being (Element of ( BOOLEAN )) holds ( B230 . <* B231 , B232 , B233 *> ) = H36(B231 , B232 , B233))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H37((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' ( 'not' $3 ) );
thus L115: (for B234 , B235 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B236 , B237 , B238 being (Element of ( BOOLEAN )) holds ( B234 . <* B236 , B237 , B238 *> ) = H37(B236 , B237 , B238)) & (for B239 , B240 , B241 being (Element of ( BOOLEAN )) holds ( B235 . <* B239 , B240 , B241 *> ) = H37(B239 , B240 , B241))) implies B234 = B235)) from FACIRC_1:sch 5;
end;
end;
definition
func nand3 -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L117: (for B242 , B243 , B244 being (Element of ( BOOLEAN )) holds ( it . <* B242 , B243 , B244 *> ) = ( 'not' ( ( B242 '&' B243 ) '&' B244 ) ));
existence
proof
deffunc H38((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( $1 '&' $2 ) '&' $3 ) );
thus L118: (ex B245 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B246 , B247 , B248 being (Element of ( BOOLEAN )) holds ( B245 . <* B246 , B247 , B248 *> ) = H38(B246 , B247 , B248))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H39((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( $1 '&' $2 ) '&' $3 ) );
thus L119: (for B249 , B250 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B251 , B252 , B253 being (Element of ( BOOLEAN )) holds ( B249 . <* B251 , B252 , B253 *> ) = H39(B251 , B252 , B253)) & (for B254 , B255 , B256 being (Element of ( BOOLEAN )) holds ( B250 . <* B254 , B255 , B256 *> ) = H39(B254 , B255 , B256))) implies B249 = B250)) from FACIRC_1:sch 5;
end;
func nand3a -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L120: (for B257 , B258 , B259 being (Element of ( BOOLEAN )) holds ( it . <* B257 , B258 , B259 *> ) = ( 'not' ( ( ( 'not' B257 ) '&' B258 ) '&' B259 ) ));
existence
proof
deffunc H40((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) '&' $2 ) '&' $3 ) );
thus L121: (ex B260 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B261 , B262 , B263 being (Element of ( BOOLEAN )) holds ( B260 . <* B261 , B262 , B263 *> ) = H40(B261 , B262 , B263))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H41((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) '&' $2 ) '&' $3 ) );
thus L122: (for B264 , B265 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B266 , B267 , B268 being (Element of ( BOOLEAN )) holds ( B264 . <* B266 , B267 , B268 *> ) = H41(B266 , B267 , B268)) & (for B269 , B270 , B271 being (Element of ( BOOLEAN )) holds ( B265 . <* B269 , B270 , B271 *> ) = H41(B269 , B270 , B271))) implies B264 = B265)) from FACIRC_1:sch 5;
end;
func nand3b -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L123: (for B272 , B273 , B274 being (Element of ( BOOLEAN )) holds ( it . <* B272 , B273 , B274 *> ) = ( 'not' ( ( ( 'not' B272 ) '&' ( 'not' B273 ) ) '&' B274 ) ));
existence
proof
deffunc H42((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' $3 ) );
thus L124: (ex B275 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B276 , B277 , B278 being (Element of ( BOOLEAN )) holds ( B275 . <* B276 , B277 , B278 *> ) = H42(B276 , B277 , B278))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H43((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' $3 ) );
thus L125: (for B279 , B280 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B281 , B282 , B283 being (Element of ( BOOLEAN )) holds ( B279 . <* B281 , B282 , B283 *> ) = H43(B281 , B282 , B283)) & (for B284 , B285 , B286 being (Element of ( BOOLEAN )) holds ( B280 . <* B284 , B285 , B286 *> ) = H43(B284 , B285 , B286))) implies B279 = B280)) from FACIRC_1:sch 5;
end;
func nand3c -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L126: (for B287 , B288 , B289 being (Element of ( BOOLEAN )) holds ( it . <* B287 , B288 , B289 *> ) = ( 'not' ( ( ( 'not' B287 ) '&' ( 'not' B288 ) ) '&' ( 'not' B289 ) ) ));
existence
proof
deffunc H44((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' ( 'not' $3 ) ) );
thus L127: (ex B290 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B291 , B292 , B293 being (Element of ( BOOLEAN )) holds ( B290 . <* B291 , B292 , B293 *> ) = H44(B291 , B292 , B293))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H45((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) '&' ( 'not' $2 ) ) '&' ( 'not' $3 ) ) );
thus L128: (for B294 , B295 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B296 , B297 , B298 being (Element of ( BOOLEAN )) holds ( B294 . <* B296 , B297 , B298 *> ) = H45(B296 , B297 , B298)) & (for B299 , B300 , B301 being (Element of ( BOOLEAN )) holds ( B295 . <* B299 , B300 , B301 *> ) = H45(B299 , B300 , B301))) implies B294 = B295)) from FACIRC_1:sch 5;
end;
end;
definition
func or3 -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L130: (for B302 , B303 , B304 being (Element of ( BOOLEAN )) holds ( it . <* B302 , B303 , B304 *> ) = ( ( B302 'or' B303 ) 'or' B304 ));
existence
proof
deffunc H46((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 'or' $2 ) 'or' $3 );
thus L131: (ex B305 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B306 , B307 , B308 being (Element of ( BOOLEAN )) holds ( B305 . <* B306 , B307 , B308 *> ) = H46(B306 , B307 , B308))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H47((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 'or' $2 ) 'or' $3 );
thus L132: (for B309 , B310 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B311 , B312 , B313 being (Element of ( BOOLEAN )) holds ( B309 . <* B311 , B312 , B313 *> ) = H47(B311 , B312 , B313)) & (for B314 , B315 , B316 being (Element of ( BOOLEAN )) holds ( B310 . <* B314 , B315 , B316 *> ) = H47(B314 , B315 , B316))) implies B309 = B310)) from FACIRC_1:sch 5;
end;
func or3a -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L133: (for B317 , B318 , B319 being (Element of ( BOOLEAN )) holds ( it . <* B317 , B318 , B319 *> ) = ( ( ( 'not' B317 ) 'or' B318 ) 'or' B319 ));
existence
proof
deffunc H48((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) 'or' $2 ) 'or' $3 );
thus L134: (ex B320 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B321 , B322 , B323 being (Element of ( BOOLEAN )) holds ( B320 . <* B321 , B322 , B323 *> ) = H48(B321 , B322 , B323))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H49((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) 'or' $2 ) 'or' $3 );
thus L135: (for B324 , B325 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B326 , B327 , B328 being (Element of ( BOOLEAN )) holds ( B324 . <* B326 , B327 , B328 *> ) = H49(B326 , B327 , B328)) & (for B329 , B330 , B331 being (Element of ( BOOLEAN )) holds ( B325 . <* B329 , B330 , B331 *> ) = H49(B329 , B330 , B331))) implies B324 = B325)) from FACIRC_1:sch 5;
end;
func or3b -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L136: (for B332 , B333 , B334 being (Element of ( BOOLEAN )) holds ( it . <* B332 , B333 , B334 *> ) = ( ( ( 'not' B332 ) 'or' ( 'not' B333 ) ) 'or' B334 ));
existence
proof
deffunc H50((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' $3 );
thus L137: (ex B335 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B336 , B337 , B338 being (Element of ( BOOLEAN )) holds ( B335 . <* B336 , B337 , B338 *> ) = H50(B336 , B337 , B338))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H51((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' $3 );
thus L138: (for B339 , B340 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B341 , B342 , B343 being (Element of ( BOOLEAN )) holds ( B339 . <* B341 , B342 , B343 *> ) = H51(B341 , B342 , B343)) & (for B344 , B345 , B346 being (Element of ( BOOLEAN )) holds ( B340 . <* B344 , B345 , B346 *> ) = H51(B344 , B345 , B346))) implies B339 = B340)) from FACIRC_1:sch 5;
end;
func or3c -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L139: (for B347 , B348 , B349 being (Element of ( BOOLEAN )) holds ( it . <* B347 , B348 , B349 *> ) = ( ( ( 'not' B347 ) 'or' ( 'not' B348 ) ) 'or' ( 'not' B349 ) ));
existence
proof
deffunc H52((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' ( 'not' $3 ) );
thus L140: (ex B350 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B351 , B352 , B353 being (Element of ( BOOLEAN )) holds ( B350 . <* B351 , B352 , B353 *> ) = H52(B351 , B352 , B353))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H53((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' ( 'not' $3 ) );
thus L141: (for B354 , B355 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B356 , B357 , B358 being (Element of ( BOOLEAN )) holds ( B354 . <* B356 , B357 , B358 *> ) = H53(B356 , B357 , B358)) & (for B359 , B360 , B361 being (Element of ( BOOLEAN )) holds ( B355 . <* B359 , B360 , B361 *> ) = H53(B359 , B360 , B361))) implies B354 = B355)) from FACIRC_1:sch 5;
end;
end;
definition
func nor3 -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L143: (for B362 , B363 , B364 being (Element of ( BOOLEAN )) holds ( it . <* B362 , B363 , B364 *> ) = ( 'not' ( ( B362 'or' B363 ) 'or' B364 ) ));
existence
proof
deffunc H54((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( $1 'or' $2 ) 'or' $3 ) );
thus L144: (ex B365 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B366 , B367 , B368 being (Element of ( BOOLEAN )) holds ( B365 . <* B366 , B367 , B368 *> ) = H54(B366 , B367 , B368))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H55((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( $1 'or' $2 ) 'or' $3 ) );
thus L145: (for B369 , B370 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B371 , B372 , B373 being (Element of ( BOOLEAN )) holds ( B369 . <* B371 , B372 , B373 *> ) = H55(B371 , B372 , B373)) & (for B374 , B375 , B376 being (Element of ( BOOLEAN )) holds ( B370 . <* B374 , B375 , B376 *> ) = H55(B374 , B375 , B376))) implies B369 = B370)) from FACIRC_1:sch 5;
end;
func nor3a -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L146: (for B377 , B378 , B379 being (Element of ( BOOLEAN )) holds ( it . <* B377 , B378 , B379 *> ) = ( 'not' ( ( ( 'not' B377 ) 'or' B378 ) 'or' B379 ) ));
existence
proof
deffunc H56((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) 'or' $2 ) 'or' $3 ) );
thus L147: (ex B380 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B381 , B382 , B383 being (Element of ( BOOLEAN )) holds ( B380 . <* B381 , B382 , B383 *> ) = H56(B381 , B382 , B383))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H57((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) 'or' $2 ) 'or' $3 ) );
thus L148: (for B384 , B385 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B386 , B387 , B388 being (Element of ( BOOLEAN )) holds ( B384 . <* B386 , B387 , B388 *> ) = H57(B386 , B387 , B388)) & (for B389 , B390 , B391 being (Element of ( BOOLEAN )) holds ( B385 . <* B389 , B390 , B391 *> ) = H57(B389 , B390 , B391))) implies B384 = B385)) from FACIRC_1:sch 5;
end;
func nor3b -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L149: (for B392 , B393 , B394 being (Element of ( BOOLEAN )) holds ( it . <* B392 , B393 , B394 *> ) = ( 'not' ( ( ( 'not' B392 ) 'or' ( 'not' B393 ) ) 'or' B394 ) ));
existence
proof
deffunc H58((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' $3 ) );
thus L150: (ex B395 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B396 , B397 , B398 being (Element of ( BOOLEAN )) holds ( B395 . <* B396 , B397 , B398 *> ) = H58(B396 , B397 , B398))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H59((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' $3 ) );
thus L151: (for B399 , B400 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B401 , B402 , B403 being (Element of ( BOOLEAN )) holds ( B399 . <* B401 , B402 , B403 *> ) = H59(B401 , B402 , B403)) & (for B404 , B405 , B406 being (Element of ( BOOLEAN )) holds ( B400 . <* B404 , B405 , B406 *> ) = H59(B404 , B405 , B406))) implies B399 = B400)) from FACIRC_1:sch 5;
end;
func nor3c -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L152: (for B407 , B408 , B409 being (Element of ( BOOLEAN )) holds ( it . <* B407 , B408 , B409 *> ) = ( 'not' ( ( ( 'not' B407 ) 'or' ( 'not' B408 ) ) 'or' ( 'not' B409 ) ) ));
existence
proof
deffunc H60((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' ( 'not' $3 ) ) );
thus L153: (ex B410 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B411 , B412 , B413 being (Element of ( BOOLEAN )) holds ( B410 . <* B411 , B412 , B413 *> ) = H60(B411 , B412 , B413))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H61((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( 'not' ( ( ( 'not' $1 ) 'or' ( 'not' $2 ) ) 'or' ( 'not' $3 ) ) );
thus L154: (for B414 , B415 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B416 , B417 , B418 being (Element of ( BOOLEAN )) holds ( B414 . <* B416 , B417 , B418 *> ) = H61(B416 , B417 , B418)) & (for B419 , B420 , B421 being (Element of ( BOOLEAN )) holds ( B415 . <* B419 , B420 , B421 *> ) = H61(B419 , B420 , B421))) implies B414 = B415)) from FACIRC_1:sch 5;
end;
end;
definition
func xor3 -> (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) means 
:L156: (for B422 , B423 , B424 being (Element of ( BOOLEAN )) holds ( it . <* B422 , B423 , B424 *> ) = ( ( B422 'xor' B423 ) 'xor' B424 ));
existence
proof
deffunc H62((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 'xor' $2 ) 'xor' $3 );
thus L157: (ex B425 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st (for B426 , B427 , B428 being (Element of ( BOOLEAN )) holds ( B425 . <* B426 , B427 , B428 *> ) = H62(B426 , B427 , B428))) from FACIRC_1:sch 4;
end;
uniqueness
proof
deffunc H63((Element of ( BOOLEAN )) , (Element of ( BOOLEAN )) , (Element of ( BOOLEAN ))) = ( ( $1 'xor' $2 ) 'xor' $3 );
thus L158: (for B429 , B430 being (Function of ( 3 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (((for B431 , B432 , B433 being (Element of ( BOOLEAN )) holds ( B429 . <* B431 , B432 , B433 *> ) = H63(B431 , B432 , B433)) & (for B434 , B435 , B436 being (Element of ( BOOLEAN )) holds ( B430 . <* B434 , B435 , B436 *> ) = H63(B434 , B435 , B436))) implies B429 = B430)) from FACIRC_1:sch 5;
end;
end;
theorem
L160: (for B437 , B438 , B439 being (Element of ( BOOLEAN )) holds (( ( and3 ) . <* B437 , B438 , B439 *> ) = ( ( B437 '&' B438 ) '&' B439 ) & ( ( and3a ) . <* B437 , B438 , B439 *> ) = ( ( ( 'not' B437 ) '&' B438 ) '&' B439 ) & ( ( and3b ) . <* B437 , B438 , B439 *> ) = ( ( ( 'not' B437 ) '&' ( 'not' B438 ) ) '&' B439 ) & ( ( and3c ) . <* B437 , B438 , B439 *> ) = ( ( ( 'not' B437 ) '&' ( 'not' B438 ) ) '&' ( 'not' B439 ) ))) by L104 , L107 , L110 , L113;
theorem
L161: (for B440 , B441 , B442 being (Element of ( BOOLEAN )) holds (( ( nand3 ) . <* B440 , B441 , B442 *> ) = ( 'not' ( ( B440 '&' B441 ) '&' B442 ) ) & ( ( nand3a ) . <* B440 , B441 , B442 *> ) = ( 'not' ( ( ( 'not' B440 ) '&' B441 ) '&' B442 ) ) & ( ( nand3b ) . <* B440 , B441 , B442 *> ) = ( 'not' ( ( ( 'not' B440 ) '&' ( 'not' B441 ) ) '&' B442 ) ) & ( ( nand3c ) . <* B440 , B441 , B442 *> ) = ( 'not' ( ( ( 'not' B440 ) '&' ( 'not' B441 ) ) '&' ( 'not' B442 ) ) ))) by L117 , L120 , L123 , L126;
theorem
L162: (for B443 , B444 , B445 being (Element of ( BOOLEAN )) holds (( ( or3 ) . <* B443 , B444 , B445 *> ) = ( ( B443 'or' B444 ) 'or' B445 ) & ( ( or3a ) . <* B443 , B444 , B445 *> ) = ( ( ( 'not' B443 ) 'or' B444 ) 'or' B445 ) & ( ( or3b ) . <* B443 , B444 , B445 *> ) = ( ( ( 'not' B443 ) 'or' ( 'not' B444 ) ) 'or' B445 ) & ( ( or3c ) . <* B443 , B444 , B445 *> ) = ( ( ( 'not' B443 ) 'or' ( 'not' B444 ) ) 'or' ( 'not' B445 ) ))) by L130 , L133 , L136 , L139;
theorem
L163: (for B446 , B447 , B448 being (Element of ( BOOLEAN )) holds (( ( nor3 ) . <* B446 , B447 , B448 *> ) = ( 'not' ( ( B446 'or' B447 ) 'or' B448 ) ) & ( ( nor3a ) . <* B446 , B447 , B448 *> ) = ( 'not' ( ( ( 'not' B446 ) 'or' B447 ) 'or' B448 ) ) & ( ( nor3b ) . <* B446 , B447 , B448 *> ) = ( 'not' ( ( ( 'not' B446 ) 'or' ( 'not' B447 ) ) 'or' B448 ) ) & ( ( nor3c ) . <* B446 , B447 , B448 *> ) = ( 'not' ( ( ( 'not' B446 ) 'or' ( 'not' B447 ) ) 'or' ( 'not' B448 ) ) ))) by L143 , L146 , L149 , L152;
theorem
L164: (for B449 , B450 , B451 being (Element of ( BOOLEAN )) holds (( ( and3 ) . <* B449 , B450 , B451 *> ) = ( ( nor3c ) . <* B449 , B450 , B451 *> ) & ( ( and3a ) . <* B449 , B450 , B451 *> ) = ( ( nor3b ) . <* B451 , B450 , B449 *> ) & ( ( and3b ) . <* B449 , B450 , B451 *> ) = ( ( nor3a ) . <* B451 , B450 , B449 *> ) & ( ( and3c ) . <* B449 , B450 , B451 *> ) = ( ( nor3 ) . <* B449 , B450 , B451 *> )))
proof
let C11 , C12 , C13 being (Element of ( BOOLEAN ));
thus L165: ( ( and3 ) . <* C11 , C12 , C13 *> ) = ( 'not' ( ( 'not' ( 'not' ( ( 'not' C11 ) 'or' ( 'not' C12 ) ) ) ) 'or' ( 'not' C13 ) ) ) by L104
.= ( ( nor3c ) . <* C11 , C12 , C13 *> ) by L152;
thus L166: ( ( and3a ) . <* C11 , C12 , C13 *> ) = ( 'not' ( ( 'not' ( 'not' ( ( 'not' ( 'not' C11 ) ) 'or' ( 'not' C12 ) ) ) ) 'or' ( 'not' C13 ) ) ) by L107
.= ( 'not' ( ( ( 'not' C13 ) 'or' ( 'not' C12 ) ) 'or' C11 ) )
.= ( ( nor3b ) . <* C13 , C12 , C11 *> ) by L149;
thus L167: ( ( and3b ) . <* C11 , C12 , C13 *> ) = ( 'not' ( ( 'not' ( 'not' ( ( 'not' ( 'not' C11 ) ) 'or' ( 'not' ( 'not' C12 ) ) ) ) ) 'or' ( 'not' C13 ) ) ) by L110
.= ( 'not' ( ( ( 'not' C13 ) 'or' C12 ) 'or' C11 ) )
.= ( ( nor3a ) . <* C13 , C12 , C11 *> ) by L146;
thus L168: ( ( and3c ) . <* C11 , C12 , C13 *> ) = ( 'not' ( ( 'not' ( 'not' ( ( 'not' ( 'not' C11 ) ) 'or' ( 'not' ( 'not' C12 ) ) ) ) ) 'or' ( 'not' ( 'not' C13 ) ) ) ) by L113
.= ( ( nor3 ) . <* C11 , C12 , C13 *> ) by L143;
end;
theorem
L169: (for B452 , B453 , B454 being (Element of ( BOOLEAN )) holds (( ( or3 ) . <* B452 , B453 , B454 *> ) = ( ( nand3c ) . <* B452 , B453 , B454 *> ) & ( ( or3a ) . <* B452 , B453 , B454 *> ) = ( ( nand3b ) . <* B454 , B453 , B452 *> ) & ( ( or3b ) . <* B452 , B453 , B454 *> ) = ( ( nand3a ) . <* B454 , B453 , B452 *> ) & ( ( or3c ) . <* B452 , B453 , B454 *> ) = ( ( nand3 ) . <* B452 , B453 , B454 *> )))
proof
let C14 , C15 , C16 being (Element of ( BOOLEAN ));
thus L170: ( ( or3 ) . <* C14 , C15 , C16 *> ) = ( ( C14 'or' C15 ) 'or' C16 ) by L130
.= ( ( nand3c ) . <* C14 , C15 , C16 *> ) by L126;
thus L171: ( ( or3a ) . <* C14 , C15 , C16 *> ) = ( ( ( 'not' C14 ) 'or' C15 ) 'or' C16 ) by L133
.= ( 'not' ( ( ( 'not' C16 ) '&' ( 'not' C15 ) ) '&' C14 ) )
.= ( ( nand3b ) . <* C16 , C15 , C14 *> ) by L123;
thus L172: ( ( or3b ) . <* C14 , C15 , C16 *> ) = ( ( ( 'not' C14 ) 'or' ( 'not' C15 ) ) 'or' C16 ) by L136
.= ( 'not' ( ( ( 'not' C16 ) '&' C15 ) '&' C14 ) )
.= ( ( nand3a ) . <* C16 , C15 , C14 *> ) by L120;
thus L173: ( ( or3c ) . <* C14 , C15 , C16 *> ) = ( ( ( 'not' C14 ) 'or' ( 'not' C15 ) ) 'or' ( 'not' C16 ) ) by L139
.= ( ( nand3 ) . <* C14 , C15 , C16 *> ) by L117;
end;
theorem
L174: (( ( and3 ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3 ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3 ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3 ) . <* ( 0 ) , 1 , 1 *> ) = ( 0 ) & ( ( and3 ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3 ) . <* 1 , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3 ) . <* 1 , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3 ) . <* 1 , 1 , 1 *> ) = 1)
proof
thus L175: ( ( and3 ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( ( FALSE ) '&' ( FALSE ) ) '&' ( FALSE ) ) by L104
.= ( 0 );
thus L176: ( ( and3 ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( FALSE ) '&' ( FALSE ) ) '&' ( TRUE ) ) by L104
.= ( 0 );
thus L177: ( ( and3 ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( ( FALSE ) '&' ( TRUE ) ) '&' ( FALSE ) ) by L104
.= ( 0 );
thus L178: ( ( and3 ) . <* ( 0 ) , 1 , 1 *> ) = ( ( FALSE ) '&' ( TRUE ) ) by L104
.= ( 0 );
thus L179: ( ( and3 ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( ( TRUE ) '&' ( FALSE ) ) '&' ( FALSE ) ) by L104
.= ( 0 );
thus L180: ( ( and3 ) . <* 1 , ( 0 ) , 1 *> ) = ( ( FALSE ) '&' ( TRUE ) ) by L104
.= ( 0 );
thus L181: ( ( and3 ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( TRUE ) '&' ( TRUE ) ) '&' ( FALSE ) ) by L104
.= ( 0 );
thus L182: ( ( and3 ) . <* 1 , 1 , 1 *> ) = ( ( TRUE ) '&' ( TRUE ) ) by L104
.= 1;
end;
theorem
L183: (( ( and3a ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3a ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3a ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3a ) . <* ( 0 ) , 1 , 1 *> ) = 1 & ( ( and3a ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3a ) . <* 1 , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3a ) . <* 1 , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3a ) . <* 1 , 1 , 1 *> ) = ( 0 ))
proof
thus L184: ( ( and3a ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( FALSE ) ) '&' ( FALSE ) ) by L107
.= ( 0 );
thus L185: ( ( and3a ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( FALSE ) ) '&' ( TRUE ) ) by L107
.= ( 0 );
thus L186: ( ( and3a ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( TRUE ) ) '&' ( FALSE ) ) by L107
.= ( 0 );
thus L187: ( ( and3a ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( TRUE ) ) '&' ( TRUE ) ) by L107
.= 1;
thus L188: ( ( and3a ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( FALSE ) ) '&' ( FALSE ) ) by L107
.= ( 0 );
thus L189: ( ( and3a ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( FALSE ) ) '&' ( TRUE ) ) by L107
.= ( 0 );
thus L190: ( ( and3a ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( TRUE ) ) '&' ( FALSE ) ) by L107
.= ( 0 );
thus L191: ( ( and3a ) . <* 1 , 1 , 1 *> ) = ( ( 'not' ( TRUE ) ) '&' ( TRUE ) ) by L107
.= ( 0 );
end;
theorem
L192: (( ( and3b ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3b ) . <* ( 0 ) , ( 0 ) , 1 *> ) = 1 & ( ( and3b ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3b ) . <* ( 0 ) , 1 , 1 *> ) = ( 0 ) & ( ( and3b ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3b ) . <* 1 , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3b ) . <* 1 , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3b ) . <* 1 , 1 , 1 *> ) = ( 0 ))
proof
thus L193: ( ( and3b ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( 'not' ( FALSE ) ) ) '&' ( FALSE ) ) by L110
.= ( 0 );
thus L194: ( ( and3b ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( TRUE ) '&' ( 'not' ( FALSE ) ) ) '&' ( TRUE ) ) by L110
.= 1;
thus L195: ( ( and3b ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( 'not' ( TRUE ) ) ) '&' ( FALSE ) ) by L110
.= ( 0 );
thus L196: ( ( and3b ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( 'not' ( TRUE ) ) ) '&' ( TRUE ) ) by L110
.= ( 0 );
thus L197: ( ( and3b ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( 'not' ( FALSE ) ) ) '&' ( FALSE ) ) by L110
.= ( 0 );
thus L198: ( ( and3b ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( 'not' ( FALSE ) ) ) '&' ( TRUE ) ) by L110
.= ( 0 );
thus L199: ( ( and3b ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( 'not' ( TRUE ) ) ) '&' ( FALSE ) ) by L110
.= ( 0 );
thus L200: ( ( and3b ) . <* 1 , 1 , 1 *> ) = ( ( ( FALSE ) '&' ( 'not' ( TRUE ) ) ) '&' ( TRUE ) ) by L110
.= ( 0 );
end;
theorem
L201: (( ( and3c ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = 1 & ( ( and3c ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3c ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3c ) . <* ( 0 ) , 1 , 1 *> ) = ( 0 ) & ( ( and3c ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( and3c ) . <* 1 , ( 0 ) , 1 *> ) = ( 0 ) & ( ( and3c ) . <* 1 , 1 , ( 0 ) *> ) = ( 0 ) & ( ( and3c ) . <* 1 , 1 , 1 *> ) = ( 0 ))
proof
thus L202: ( ( and3c ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( ( TRUE ) '&' ( 'not' ( FALSE ) ) ) '&' ( 'not' ( FALSE ) ) ) by L113
.= 1;
thus L203: ( ( and3c ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( 'not' ( FALSE ) ) ) '&' ( 'not' ( TRUE ) ) ) by L113
.= ( 0 );
thus L204: ( ( and3c ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( 'not' ( TRUE ) ) ) '&' ( 'not' ( FALSE ) ) ) by L113
.= ( 0 );
thus L205: ( ( and3c ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( 'not' ( FALSE ) ) '&' ( 'not' ( TRUE ) ) ) '&' ( FALSE ) ) by L113
.= ( 0 );
thus L206: ( ( and3c ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( 'not' ( FALSE ) ) ) '&' ( 'not' ( FALSE ) ) ) by L113
.= ( 0 );
thus L207: ( ( and3c ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( 'not' ( FALSE ) ) ) '&' ( FALSE ) ) by L113
.= ( 0 );
thus L208: ( ( and3c ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( FALSE ) '&' ( 'not' ( TRUE ) ) ) '&' ( 'not' ( FALSE ) ) ) by L113
.= ( 0 );
thus L209: ( ( and3c ) . <* 1 , 1 , 1 *> ) = ( ( ( 'not' ( TRUE ) ) '&' ( 'not' ( TRUE ) ) ) '&' ( FALSE ) ) by L113
.= ( 0 );
end;
theorem
L210: (( ( or3 ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( or3 ) . <* ( 0 ) , ( 0 ) , 1 *> ) = 1 & ( ( or3 ) . <* ( 0 ) , 1 , ( 0 ) *> ) = 1 & ( ( or3 ) . <* ( 0 ) , 1 , 1 *> ) = 1 & ( ( or3 ) . <* 1 , ( 0 ) , ( 0 ) *> ) = 1 & ( ( or3 ) . <* 1 , ( 0 ) , 1 *> ) = 1 & ( ( or3 ) . <* 1 , 1 , ( 0 ) *> ) = 1 & ( ( or3 ) . <* 1 , 1 , 1 *> ) = 1)
proof
thus L211: ( ( or3 ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) 'or' ( FALSE ) ) by L130
.= ( 0 );
thus L212: ( ( or3 ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( FALSE ) 'or' ( FALSE ) ) 'or' ( TRUE ) ) by L130
.= 1;
thus L213: ( ( or3 ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( TRUE ) 'or' ( FALSE ) ) by L130
.= 1;
thus L214: ( ( or3 ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( FALSE ) 'or' ( TRUE ) ) 'or' ( TRUE ) ) by L130
.= 1;
thus L215: ( ( or3 ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( TRUE ) 'or' ( FALSE ) ) by L130
.= 1;
thus L216: ( ( or3 ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( TRUE ) 'or' ( FALSE ) ) 'or' ( TRUE ) ) by L130
.= 1;
thus L217: ( ( or3 ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( TRUE ) 'or' ( TRUE ) ) 'or' ( FALSE ) ) by L130
.= 1;
thus L218: ( ( or3 ) . <* 1 , 1 , 1 *> ) = ( ( ( TRUE ) 'or' ( TRUE ) ) 'or' ( TRUE ) ) by L130
.= 1;
end;
theorem
L219: (( ( or3a ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = 1 & ( ( or3a ) . <* ( 0 ) , ( 0 ) , 1 *> ) = 1 & ( ( or3a ) . <* ( 0 ) , 1 , ( 0 ) *> ) = 1 & ( ( or3a ) . <* ( 0 ) , 1 , 1 *> ) = 1 & ( ( or3a ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( or3a ) . <* 1 , ( 0 ) , 1 *> ) = 1 & ( ( or3a ) . <* 1 , 1 , ( 0 ) *> ) = 1 & ( ( or3a ) . <* 1 , 1 , 1 *> ) = 1)
proof
thus L220: ( ( or3a ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( 'not' ( FALSE ) ) 'or' ( FALSE ) ) by L133
.= 1;
thus L221: ( ( or3a ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( FALSE ) ) 'or' ( TRUE ) ) by L133
.= 1;
thus L222: ( ( or3a ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( TRUE ) ) 'or' ( FALSE ) ) by L133
.= 1;
thus L223: ( ( or3a ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( TRUE ) ) 'or' ( TRUE ) ) by L133
.= 1;
thus L224: ( ( or3a ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) 'or' ( FALSE ) ) by L133
.= ( 0 );
thus L225: ( ( or3a ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( FALSE ) ) 'or' ( TRUE ) ) by L133
.= 1;
thus L226: ( ( or3a ) . <* 1 , 1 , ( 0 ) *> ) = ( ( TRUE ) 'or' ( FALSE ) ) by L133
.= 1;
thus L227: ( ( or3a ) . <* 1 , 1 , 1 *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( TRUE ) ) 'or' ( TRUE ) ) by L133
.= 1;
end;
theorem
L228: (( ( or3b ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = 1 & ( ( or3b ) . <* ( 0 ) , ( 0 ) , 1 *> ) = 1 & ( ( or3b ) . <* ( 0 ) , 1 , ( 0 ) *> ) = 1 & ( ( or3b ) . <* ( 0 ) , 1 , 1 *> ) = 1 & ( ( or3b ) . <* 1 , ( 0 ) , ( 0 ) *> ) = 1 & ( ( or3b ) . <* 1 , ( 0 ) , 1 *> ) = 1 & ( ( or3b ) . <* 1 , 1 , ( 0 ) *> ) = ( 0 ) & ( ( or3b ) . <* 1 , 1 , 1 *> ) = 1)
proof
thus L229: ( ( or3b ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( ( TRUE ) 'or' ( 'not' ( FALSE ) ) ) 'or' ( FALSE ) ) by L136
.= 1;
thus L230: ( ( or3b ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( 'not' ( FALSE ) ) ) 'or' ( TRUE ) ) by L136
.= 1;
thus L231: ( ( or3b ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( 'not' ( FALSE ) ) 'or' ( 'not' ( TRUE ) ) ) by L136
.= 1;
thus L232: ( ( or3b ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( 'not' ( TRUE ) ) ) 'or' ( TRUE ) ) by L136
.= 1;
thus L233: ( ( or3b ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) 'or' ( 'not' ( FALSE ) ) ) by L136
.= 1;
thus L234: ( ( or3b ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( 'not' ( FALSE ) ) ) 'or' ( TRUE ) ) by L136
.= 1;
thus L235: ( ( or3b ) . <* 1 , 1 , ( 0 ) *> ) = ( ( 'not' ( TRUE ) ) 'or' ( 'not' ( TRUE ) ) ) by L136
.= ( 0 );
thus L236: ( ( or3b ) . <* 1 , 1 , 1 *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( 'not' ( TRUE ) ) ) 'or' ( TRUE ) ) by L136
.= 1;
end;
theorem
L237: (( ( or3c ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = 1 & ( ( or3c ) . <* ( 0 ) , ( 0 ) , 1 *> ) = 1 & ( ( or3c ) . <* ( 0 ) , 1 , ( 0 ) *> ) = 1 & ( ( or3c ) . <* ( 0 ) , 1 , 1 *> ) = 1 & ( ( or3c ) . <* 1 , ( 0 ) , ( 0 ) *> ) = 1 & ( ( or3c ) . <* 1 , ( 0 ) , 1 *> ) = 1 & ( ( or3c ) . <* 1 , 1 , ( 0 ) *> ) = 1 & ( ( or3c ) . <* 1 , 1 , 1 *> ) = ( 0 ))
proof
thus L238: ( ( or3c ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( 'not' ( FALSE ) ) ) 'or' ( TRUE ) ) by L139
.= 1;
thus L239: ( ( or3c ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( 'not' ( FALSE ) ) ) 'or' ( FALSE ) ) by L139
.= 1;
thus L240: ( ( or3c ) . <* ( 0 ) , 1 , ( 0 ) *> ) = ( ( ( 'not' ( FALSE ) ) 'or' ( 'not' ( TRUE ) ) ) 'or' ( TRUE ) ) by L139
.= 1;
thus L241: ( ( or3c ) . <* ( 0 ) , 1 , 1 *> ) = ( ( ( TRUE ) 'or' ( 'not' ( TRUE ) ) ) 'or' ( 'not' ( TRUE ) ) ) by L139
.= 1;
thus L242: ( ( or3c ) . <* 1 , ( 0 ) , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( 'not' ( FALSE ) ) ) 'or' ( TRUE ) ) by L139
.= 1;
thus L243: ( ( or3c ) . <* 1 , ( 0 ) , 1 *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( TRUE ) ) 'or' ( 'not' ( TRUE ) ) ) by L139
.= 1;
thus L244: ( ( or3c ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( 'not' ( TRUE ) ) 'or' ( 'not' ( TRUE ) ) ) 'or' ( TRUE ) ) by L139
.= 1;
thus L245: ( ( or3c ) . <* 1 , 1 , 1 *> ) = ( ( ( FALSE ) 'or' ( 'not' ( TRUE ) ) ) 'or' ( 'not' ( TRUE ) ) ) by L139
.= ( 0 );
end;
theorem
L246: (( ( xor3 ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( 0 ) & ( ( xor3 ) . <* ( 0 ) , ( 0 ) , 1 *> ) = 1 & ( ( xor3 ) . <* ( 0 ) , 1 , ( 0 ) *> ) = 1 & ( ( xor3 ) . <* ( 0 ) , 1 , 1 *> ) = ( 0 ) & ( ( xor3 ) . <* 1 , ( 0 ) , ( 0 ) *> ) = 1 & ( ( xor3 ) . <* 1 , ( 0 ) , 1 *> ) = ( 0 ) & ( ( xor3 ) . <* 1 , 1 , ( 0 ) *> ) = ( 0 ) & ( ( xor3 ) . <* 1 , 1 , 1 *> ) = 1)
proof
thus L247: ( ( xor3 ) . <* ( 0 ) , ( 0 ) , ( 0 ) *> ) = ( ( FALSE ) 'xor' ( FALSE ) ) by L156
.= ( 0 );
thus L248: ( ( xor3 ) . <* ( 0 ) , ( 0 ) , 1 *> ) = ( ( ( FALSE ) 'xor' ( FALSE ) ) 'xor' ( TRUE ) ) by L156
.= 1;
thus L249: ( ( xor3 ) . <* ( 0 ) , 1 , ( 0 ) *> ) = 1 by L156 , BINARITH:13;
thus L250: ( ( xor3 ) . <* ( 0 ) , 1 , 1 *> ) = ( ( TRUE ) 'xor' ( TRUE ) ) by L156 , BINARITH:13
.= ( 0 );
thus L251: ( ( xor3 ) . <* 1 , ( 0 ) , ( 0 ) *> ) = 1 by L156 , BINARITH:13;
thus L252: ( ( xor3 ) . <* 1 , ( 0 ) , 1 *> ) = ( ( TRUE ) 'xor' ( TRUE ) ) by L156 , BINARITH:13
.= ( 0 );
thus L253: ( ( xor3 ) . <* 1 , 1 , ( 0 ) *> ) = ( ( ( TRUE ) 'xor' ( TRUE ) ) 'xor' ( FALSE ) ) by L156
.= ( 0 );
thus L254: ( ( xor3 ) . <* 1 , 1 , 1 *> ) = ( ( ( TRUE ) 'xor' ( TRUE ) ) 'xor' ( TRUE ) ) by L156
.= 1;
end;
begin
definition
let C17 , C18 being set;
func CompStr (C17 , C18) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( 1GateCircStr (<* C17 , C18 *> , ( xor2a )) );
correctness;
end;
definition
let C19 , C20 being set;
func CompCirc (C19 , C20) ->  strict  Boolean  gate`2=den (Circuit of ( CompStr (C19 , C20) )) equals 
( 1GateCircuit (C19 , C20 , ( xor2a )) );
coherence;
end;
definition
let C21 , C22 being set;
func CompOutput (C21 , C22) -> (Element of ( InnerVertices ( CompStr (C21 , C22) ) )) equals 
[ <* C21 , C22 *> , ( xor2a ) ];
coherence by FACIRC_1:47;
end;
definition
let C23 , C24 being set;
func IncrementStr (C23 , C24) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( 1GateCircStr (<* C23 , C24 *> , ( and2a )) );
correctness;
end;
definition
let C25 , C26 being set;
func IncrementCirc (C25 , C26) ->  strict  Boolean  gate`2=den (Circuit of ( IncrementStr (C25 , C26) )) equals 
( 1GateCircuit (C25 , C26 , ( and2a )) );
coherence;
end;
definition
let C27 , C28 being set;
func IncrementOutput (C27 , C28) -> (Element of ( InnerVertices ( IncrementStr (C27 , C28) ) )) equals 
[ <* C27 , C28 *> , ( and2a ) ];
coherence by FACIRC_1:47;
end;
definition
let C29 , C30 being set;
func BitCompStr (C29 , C30) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign equals 
( ( CompStr (C29 , C30) ) +* ( IncrementStr (C29 , C30) ) );
correctness;
end;
definition
let C31 , C32 being set;
func BitCompCirc (C31 , C32) ->  strict  Boolean  gate`2=den (Circuit of ( BitCompStr (C31 , C32) )) equals 
( ( CompCirc (C31 , C32) ) +* ( IncrementCirc (C31 , C32) ) );
coherence;
end;
theorem
L263: (for B455 , B456 being non  pair set holds (the carrier of ( CompStr (B455 , B456) )) = ( { B455 , B456 } \/ { [ <* B455 , B456 *> , ( xor2a ) ] } ))
proof
let C33 , C34 being non  pair set;
set D1 = <* C33 , C34 *>;
L264: ( rng D1 ) = { C33 , C34 } by FINSEQ_2:127;
thus L265: thesis by L264 , CIRCCOMB:def 6;
end;
theorem
L266: (for B457 , B458 being non  pair set holds [ <* B457 , B458 *> , ( xor2a ) ] in ( InnerVertices ( CompStr (B457 , B458) ) ))
proof
let C35 , C36 being non  pair set;
L267: ( InnerVertices ( CompStr (C35 , C36) ) ) = { [ <* C35 , C36 *> , ( xor2a ) ] } by CIRCCOMB:42;
thus L268: thesis by L267 , TARSKI:def 1;
end;
theorem
L269: (for B459 , B460 being non  pair set holds (B459 in ( InputVertices ( CompStr (B459 , B460) ) ) & B460 in ( InputVertices ( CompStr (B459 , B460) ) )))
proof
let C37 , C38 being non  pair set;
L270: ( InputVertices ( CompStr (C37 , C38) ) ) = { C37 , C38 } by FACIRC_1:40;
thus L271: thesis by L270 , TARSKI:def 2;
end;
theorem
L272: (for B461 , B462 being non  pair set holds ( InputVertices ( CompStr (B461 , B462) ) ) is  without_pairs)
proof
let C39 , C40 being non  pair set;
L273: ( InputVertices ( CompStr (C39 , C40) ) ) = { C39 , C40 } by FACIRC_1:40;
thus L274: thesis by L273;
end;
theorem
L275: (for B463 , B464 being non  pair set holds (the carrier of ( IncrementStr (B463 , B464) )) = ( { B463 , B464 } \/ { [ <* B463 , B464 *> , ( and2a ) ] } ))
proof
let C41 , C42 being non  pair set;
set D2 = <* C41 , C42 *>;
L276: ( rng D2 ) = { C41 , C42 } by FINSEQ_2:127;
thus L277: thesis by L276 , CIRCCOMB:def 6;
end;
theorem
L278: (for B465 , B466 being non  pair set holds [ <* B465 , B466 *> , ( and2a ) ] in ( InnerVertices ( IncrementStr (B465 , B466) ) ))
proof
let C43 , C44 being non  pair set;
L279: ( InnerVertices ( IncrementStr (C43 , C44) ) ) = { [ <* C43 , C44 *> , ( and2a ) ] } by CIRCCOMB:42;
thus L280: thesis by L279 , TARSKI:def 1;
end;
theorem
L281: (for B467 , B468 being non  pair set holds (B467 in ( InputVertices ( IncrementStr (B467 , B468) ) ) & B468 in ( InputVertices ( IncrementStr (B467 , B468) ) )))
proof
let C45 , C46 being non  pair set;
L282: ( InputVertices ( IncrementStr (C45 , C46) ) ) = { C45 , C46 } by FACIRC_1:40;
thus L283: thesis by L282 , TARSKI:def 2;
end;
theorem
L284: (for B469 , B470 being non  pair set holds ( InputVertices ( IncrementStr (B469 , B470) ) ) is  without_pairs)
proof
let C47 , C48 being non  pair set;
L285: ( InputVertices ( IncrementStr (C47 , C48) ) ) = { C47 , C48 } by FACIRC_1:40;
thus L286: thesis by L285;
end;
theorem
L287: (for B471 , B472 being non  pair set holds ( InnerVertices ( BitCompStr (B471 , B472) ) ) is Relation)
proof
let C49 , C50 being non  pair set;
set D3 = ( CompStr (C49 , C50) );
set D4 = ( IncrementStr (C49 , C50) );
L288: (( InnerVertices D3 ) is Relation & ( InnerVertices D4 ) is Relation) by FACIRC_1:38;
thus L289: thesis by L288 , FACIRC_1:3;
end;
theorem
L290: (for B473 , B474 being non  pair set holds (B473 in (the carrier of ( BitCompStr (B473 , B474) )) & B474 in (the carrier of ( BitCompStr (B473 , B474) )) & [ <* B473 , B474 *> , ( xor2a ) ] in (the carrier of ( BitCompStr (B473 , B474) )) & [ <* B473 , B474 *> , ( and2a ) ] in (the carrier of ( BitCompStr (B473 , B474) ))))
proof
let C51 , C52 being non  pair set;
set D5 = <* C51 , C52 *>;
set D6 = ( CompStr (C51 , C52) );
set D7 = ( IncrementStr (C51 , C52) );
L291: ([ D5 , ( xor2a ) ] in (the carrier of D6) & [ D5 , ( and2a ) ] in (the carrier of D7)) by FACIRC_1:43;
L292: (C51 in (the carrier of D6) & C52 in (the carrier of D6)) by FACIRC_1:43;
thus L293: thesis by L292 , L291 , FACIRC_1:20;
end;
theorem
L294: (for B475 , B476 being non  pair set holds (the carrier of ( BitCompStr (B475 , B476) )) = ( { B475 , B476 } \/ { [ <* B475 , B476 *> , ( xor2a ) ] , [ <* B475 , B476 *> , ( and2a ) ] } ))
proof
let C53 , C54 being non  pair set;
set D8 = <* C53 , C54 *>;
set D9 = ( CompStr (C53 , C54) );
set D10 = ( IncrementStr (C53 , C54) );
L295: ((the carrier of D9) = ( { C53 , C54 } \/ { [ D8 , ( xor2a ) ] } ) & (the carrier of D10) = ( { C53 , C54 } \/ { [ D8 , ( and2a ) ] } )) by L263 , L275;
L296: (the carrier of ( BitCompStr (C53 , C54) )) = ( ( { C53 , C54 } \/ { [ D8 , ( xor2a ) ] } ) \/ ( { C53 , C54 } \/ { [ D8 , ( and2a ) ] } ) ) by L295 , CIRCCOMB:def 2
.= ( ( { C53 , C54 } \/ ( { C53 , C54 } \/ { [ D8 , ( xor2a ) ] } ) ) \/ { [ D8 , ( and2a ) ] } ) by XBOOLE_1:4
.= ( ( ( { C53 , C54 } \/ { C53 , C54 } ) \/ { [ D8 , ( xor2a ) ] } ) \/ { [ D8 , ( and2a ) ] } ) by XBOOLE_1:4
.= ( { C53 , C54 } \/ ( { [ D8 , ( xor2a ) ] } \/ { [ D8 , ( and2a ) ] } ) ) by XBOOLE_1:4
.= ( { C53 , C54 } \/ { [ D8 , ( xor2a ) ] , [ D8 , ( and2a ) ] } ) by ENUMSET1:1;
thus L297: thesis by L296;
end;
theorem
L298: (for B477 , B478 being non  pair set holds ( InnerVertices ( BitCompStr (B477 , B478) ) ) = { [ <* B477 , B478 *> , ( xor2a ) ] , [ <* B477 , B478 *> , ( and2a ) ] })
proof
let C55 , C56 being non  pair set;
set D11 = <* C55 , C56 *>;
set D12 = ( CompStr (C55 , C56) );
set D13 = ( IncrementStr (C55 , C56) );
set D14 = ( BitCompStr (C55 , C56) );
L299: (( InnerVertices D12 ) = { [ D11 , ( xor2a ) ] } & ( InnerVertices D13 ) = { [ D11 , ( and2a ) ] }) by CIRCCOMB:42;
L300: ( InnerVertices D14 ) = ( ( InnerVertices D12 ) \/ ( InnerVertices D13 ) ) by FACIRC_1:27
.= { [ D11 , ( xor2a ) ] , [ D11 , ( and2a ) ] } by L299 , ENUMSET1:1;
thus L301: thesis by L300;
end;
theorem
L302: (for B479 , B480 being non  pair set holds ([ <* B479 , B480 *> , ( xor2a ) ] in ( InnerVertices ( BitCompStr (B479 , B480) ) ) & [ <* B479 , B480 *> , ( and2a ) ] in ( InnerVertices ( BitCompStr (B479 , B480) ) )))
proof
let C57 , C58 being non  pair set;
L303: ( InnerVertices ( BitCompStr (C57 , C58) ) ) = { [ <* C57 , C58 *> , ( xor2a ) ] , [ <* C57 , C58 *> , ( and2a ) ] } by L298;
thus L304: thesis by L303 , TARSKI:def 2;
end;
theorem
L305: (for B481 , B482 being non  pair set holds ( InputVertices ( BitCompStr (B481 , B482) ) ) = { B481 , B482 })
proof
let C59 , C60 being non  pair set;
set D15 = ( CompStr (C59 , C60) );
set D16 = ( IncrementStr (C59 , C60) );
set D17 = ( BitCompStr (C59 , C60) );
L306: (( InputVertices D15 ) = { C59 , C60 } & ( InputVertices D16 ) = { C59 , C60 }) by FACIRC_1:40;
L307: (( InnerVertices D15 ) is Relation & ( InnerVertices D16 ) is Relation) by FACIRC_1:38;
L308: ( InputVertices D17 ) = ( { C59 , C60 } \/ { C59 , C60 } ) by L307 , L306 , FACIRC_1:7
.= { C59 , C60 };
thus L309: thesis by L308;
end;
theorem
L310: (for B483 , B484 being non  pair set holds (B483 in ( InputVertices ( BitCompStr (B483 , B484) ) ) & B484 in ( InputVertices ( BitCompStr (B483 , B484) ) )))
proof
let C61 , C62 being non  pair set;
L311: ( InputVertices ( BitCompStr (C61 , C62) ) ) = { C61 , C62 } by L305;
thus L312: thesis by L311 , TARSKI:def 2;
end;
theorem
L313: (for B485 , B486 being non  pair set holds ( InputVertices ( BitCompStr (B485 , B486) ) ) is  without_pairs)
proof
let C63 , C64 being non  pair set;
L314: ( InputVertices ( BitCompStr (C63 , C64) ) ) = { C63 , C64 } by L305;
thus L315: thesis by L314;
end;
theorem
L316: (for B487 , B488 being non  pair set holds (for B489 being (State of ( CompCirc (B487 , B488) )) holds (( ( Following B489 ) . ( CompOutput (B487 , B488) ) ) = ( ( xor2a ) . <* ( B489 . B487 ) , ( B489 . B488 ) *> ) & ( ( Following B489 ) . B487 ) = ( B489 . B487 ) & ( ( Following B489 ) . B488 ) = ( B489 . B488 ))))
proof
let C65 , C66 being non  pair set;
let C67 being (State of ( CompCirc (C65 , C66) ));
set D18 = <* C65 , C66 *>;
set D19 = ( CompStr (C65 , C66) );
L317: (( dom C67 ) = (the carrier of D19) & C65 in (the carrier of D19)) by CIRCUIT1:3 , FACIRC_1:43;
L318: C66 in (the carrier of D19) by FACIRC_1:43;
L319: ( InnerVertices D19 ) = (the carrier' of D19) by FACIRC_1:37;
thus L320: ( ( Following C67 ) . ( CompOutput (C65 , C66) ) ) = ( ( xor2a ) . ( C67 * D18 ) ) by L319 , FACIRC_1:35
.= ( ( xor2a ) . <* ( C67 . C65 ) , ( C67 . C66 ) *> ) by L317 , L318 , FINSEQ_2:125;
L321: ( InputVertices D19 ) = { C65 , C66 } by FACIRC_1:40;
L322: (C65 in ( InputVertices D19 ) & C66 in ( InputVertices D19 )) by L321 , TARSKI:def 2;
thus L323: thesis by L322 , CIRCUIT2:def 5;
end;
theorem
L324: (for B490 , B491 being non  pair set holds (for B492 being (State of ( CompCirc (B490 , B491) )) holds (for B493 , B494 being (Element of ( BOOLEAN )) holds ((B493 = ( B492 . B490 ) & B494 = ( B492 . B491 )) implies (( ( Following B492 ) . ( CompOutput (B490 , B491) ) ) = ( ( 'not' B493 ) 'xor' B494 ) & ( ( Following B492 ) . B490 ) = B493 & ( ( Following B492 ) . B491 ) = B494)))))
proof
let C68 , C69 being non  pair set;
let C70 being (State of ( CompCirc (C68 , C69) ));
let C71 , C72 being (Element of ( BOOLEAN ));
assume L325: (C71 = ( C70 . C68 ) & C72 = ( C70 . C69 ));
thus L326: ( ( Following C70 ) . ( CompOutput (C68 , C69) ) ) = ( ( xor2a ) . <* ( C70 . C68 ) , ( C70 . C69 ) *> ) by L316
.= ( ( 'not' C71 ) 'xor' C72 ) by L325 , L47;
thus L327: thesis by L325 , L316;
end;
theorem
L328: (for B495 , B496 being non  pair set holds (for B497 being (State of ( BitCompCirc (B495 , B496) )) holds (( ( Following B497 ) . ( CompOutput (B495 , B496) ) ) = ( ( xor2a ) . <* ( B497 . B495 ) , ( B497 . B496 ) *> ) & ( ( Following B497 ) . B495 ) = ( B497 . B495 ) & ( ( Following B497 ) . B496 ) = ( B497 . B496 ))))
proof
let C73 , C74 being non  pair set;
let C75 being (State of ( BitCompCirc (C73 , C74) ));
set D20 = <* C73 , C74 *>;
set D21 = ( BitCompStr (C73 , C74) );
L329: (( dom C75 ) = (the carrier of D21) & C73 in (the carrier of D21)) by L290 , CIRCUIT1:3;
L330: C74 in (the carrier of D21) by L290;
L331: ( InnerVertices D21 ) = (the carrier' of D21) by FACIRC_1:37;
thus L332: ( ( Following C75 ) . ( CompOutput (C73 , C74) ) ) = ( ( xor2a ) . ( C75 * D20 ) ) by L331 , L302 , FACIRC_1:35
.= ( ( xor2a ) . <* ( C75 . C73 ) , ( C75 . C74 ) *> ) by L329 , L330 , FINSEQ_2:125;
L333: (C73 in ( InputVertices D21 ) & C74 in ( InputVertices D21 )) by L310;
thus L334: thesis by L333 , CIRCUIT2:def 5;
end;
theorem
L335: (for B498 , B499 being non  pair set holds (for B500 being (State of ( BitCompCirc (B498 , B499) )) holds (for B501 , B502 being (Element of ( BOOLEAN )) holds ((B501 = ( B500 . B498 ) & B502 = ( B500 . B499 )) implies (( ( Following B500 ) . ( CompOutput (B498 , B499) ) ) = ( ( 'not' B501 ) 'xor' B502 ) & ( ( Following B500 ) . B498 ) = B501 & ( ( Following B500 ) . B499 ) = B502)))))
proof
let C76 , C77 being non  pair set;
let C78 being (State of ( BitCompCirc (C76 , C77) ));
let C79 , C80 being (Element of ( BOOLEAN ));
assume L336: (C79 = ( C78 . C76 ) & C80 = ( C78 . C77 ));
thus L337: ( ( Following C78 ) . ( CompOutput (C76 , C77) ) ) = ( ( xor2a ) . <* ( C78 . C76 ) , ( C78 . C77 ) *> ) by L328
.= ( ( 'not' C79 ) 'xor' C80 ) by L336 , L47;
thus L338: thesis by L336 , L328;
end;
theorem
L339: (for B503 , B504 being non  pair set holds (for B505 being (State of ( IncrementCirc (B503 , B504) )) holds (( ( Following B505 ) . ( IncrementOutput (B503 , B504) ) ) = ( ( and2a ) . <* ( B505 . B503 ) , ( B505 . B504 ) *> ) & ( ( Following B505 ) . B503 ) = ( B505 . B503 ) & ( ( Following B505 ) . B504 ) = ( B505 . B504 ))))
proof
let C81 , C82 being non  pair set;
let C83 being (State of ( IncrementCirc (C81 , C82) ));
set D22 = <* C81 , C82 *>;
set D23 = ( IncrementStr (C81 , C82) );
L340: (( dom C83 ) = (the carrier of D23) & C81 in (the carrier of D23)) by CIRCUIT1:3 , FACIRC_1:43;
L341: C82 in (the carrier of D23) by FACIRC_1:43;
L342: ( InnerVertices D23 ) = (the carrier' of D23) by FACIRC_1:37;
thus L343: ( ( Following C83 ) . ( IncrementOutput (C81 , C82) ) ) = ( ( and2a ) . ( C83 * D22 ) ) by L342 , FACIRC_1:35
.= ( ( and2a ) . <* ( C83 . C81 ) , ( C83 . C82 ) *> ) by L340 , L341 , FINSEQ_2:125;
L344: ( InputVertices D23 ) = { C81 , C82 } by FACIRC_1:40;
L345: (C81 in ( InputVertices D23 ) & C82 in ( InputVertices D23 )) by L344 , TARSKI:def 2;
thus L346: thesis by L345 , CIRCUIT2:def 5;
end;
theorem
L347: (for B506 , B507 being non  pair set holds (for B508 being (State of ( IncrementCirc (B506 , B507) )) holds (for B509 , B510 being (Element of ( BOOLEAN )) holds ((B509 = ( B508 . B506 ) & B510 = ( B508 . B507 )) implies (( ( Following B508 ) . ( IncrementOutput (B506 , B507) ) ) = ( ( 'not' B509 ) '&' B510 ) & ( ( Following B508 ) . B506 ) = B509 & ( ( Following B508 ) . B507 ) = B510)))))
proof
let C84 , C85 being non  pair set;
let C86 being (State of ( IncrementCirc (C84 , C85) ));
let C87 , C88 being (Element of ( BOOLEAN ));
assume L348: (C87 = ( C86 . C84 ) & C88 = ( C86 . C85 ));
thus L349: ( ( Following C86 ) . ( IncrementOutput (C84 , C85) ) ) = ( ( and2a ) . <* ( C86 . C84 ) , ( C86 . C85 ) *> ) by L339
.= ( ( 'not' C87 ) '&' C88 ) by L348 , L7;
thus L350: thesis by L348 , L339;
end;
theorem
L351: (for B511 , B512 being non  pair set holds (for B513 being (State of ( BitCompCirc (B511 , B512) )) holds (( ( Following B513 ) . ( IncrementOutput (B511 , B512) ) ) = ( ( and2a ) . <* ( B513 . B511 ) , ( B513 . B512 ) *> ) & ( ( Following B513 ) . B511 ) = ( B513 . B511 ) & ( ( Following B513 ) . B512 ) = ( B513 . B512 ))))
proof
let C89 , C90 being non  pair set;
let C91 being (State of ( BitCompCirc (C89 , C90) ));
set D24 = <* C89 , C90 *>;
set D25 = ( BitCompStr (C89 , C90) );
L352: (( dom C91 ) = (the carrier of D25) & C89 in (the carrier of D25)) by L290 , CIRCUIT1:3;
L353: C90 in (the carrier of D25) by L290;
L354: ( InnerVertices D25 ) = (the carrier' of D25) by FACIRC_1:37;
thus L355: ( ( Following C91 ) . ( IncrementOutput (C89 , C90) ) ) = ( ( and2a ) . ( C91 * D24 ) ) by L354 , L302 , FACIRC_1:35
.= ( ( and2a ) . <* ( C91 . C89 ) , ( C91 . C90 ) *> ) by L352 , L353 , FINSEQ_2:125;
L356: ( InputVertices D25 ) = { C89 , C90 } by L305;
L357: (C89 in ( InputVertices D25 ) & C90 in ( InputVertices D25 )) by L356 , TARSKI:def 2;
thus L358: thesis by L357 , CIRCUIT2:def 5;
end;
theorem
L359: (for B514 , B515 being non  pair set holds (for B516 being (State of ( BitCompCirc (B514 , B515) )) holds (for B517 , B518 being (Element of ( BOOLEAN )) holds ((B517 = ( B516 . B514 ) & B518 = ( B516 . B515 )) implies (( ( Following B516 ) . ( IncrementOutput (B514 , B515) ) ) = ( ( 'not' B517 ) '&' B518 ) & ( ( Following B516 ) . B514 ) = B517 & ( ( Following B516 ) . B515 ) = B518)))))
proof
let C92 , C93 being non  pair set;
let C94 being (State of ( BitCompCirc (C92 , C93) ));
let C95 , C96 being (Element of ( BOOLEAN ));
assume L360: (C95 = ( C94 . C92 ) & C96 = ( C94 . C93 ));
thus L361: ( ( Following C94 ) . ( IncrementOutput (C92 , C93) ) ) = ( ( and2a ) . <* ( C94 . C92 ) , ( C94 . C93 ) *> ) by L351
.= ( ( 'not' C95 ) '&' C96 ) by L360 , L7;
thus L362: thesis by L360 , L351;
end;
theorem
L363: (for B519 , B520 being non  pair set holds (for B521 being (State of ( BitCompCirc (B519 , B520) )) holds (( ( Following B521 ) . ( CompOutput (B519 , B520) ) ) = ( ( xor2a ) . <* ( B521 . B519 ) , ( B521 . B520 ) *> ) & ( ( Following B521 ) . ( IncrementOutput (B519 , B520) ) ) = ( ( and2a ) . <* ( B521 . B519 ) , ( B521 . B520 ) *> ) & ( ( Following B521 ) . B519 ) = ( B521 . B519 ) & ( ( Following B521 ) . B520 ) = ( B521 . B520 )))) by L328 , L351;
theorem
L364: (for B522 , B523 being non  pair set holds (for B524 being (State of ( BitCompCirc (B522 , B523) )) holds (for B525 , B526 being (Element of ( BOOLEAN )) holds ((B525 = ( B524 . B522 ) & B526 = ( B524 . B523 )) implies (( ( Following B524 ) . ( CompOutput (B522 , B523) ) ) = ( ( 'not' B525 ) 'xor' B526 ) & ( ( Following B524 ) . ( IncrementOutput (B522 , B523) ) ) = ( ( 'not' B525 ) '&' B526 ) & ( ( Following B524 ) . B522 ) = B525 & ( ( Following B524 ) . B523 ) = B526))))) by L335 , L359;
theorem
L365: (for B527 , B528 being non  pair set holds (for B529 being (State of ( BitCompCirc (B527 , B528) )) holds ( Following B529 ) is  stable))
proof
let C97 , C98 being non  pair set;
set D26 = <* C97 , C98 *>;
set D27 = ( BitCompStr (C97 , C98) );
let C99 being (State of ( BitCompCirc (C97 , C98) ));
set D28 = ( Following C99 );
set D29 = ( Following D28 );
L366: (the carrier of D27) = ( { C97 , C98 } \/ { [ D26 , ( xor2a ) ] , [ D26 , ( and2a ) ] } ) by L294;
L367:
now
let C100 being set;
L368: ( D28 . [ D26 , ( xor2a ) ] ) = ( D28 . ( CompOutput (C97 , C98) ) )
.= ( ( xor2a ) . <* ( C99 . C97 ) , ( C99 . C98 ) *> ) by L328;
assume L369: C100 in (the carrier of D27);
L370: (C100 in { C97 , C98 } or C100 in { [ D26 , ( xor2a ) ] , [ D26 , ( and2a ) ] }) by L369 , L366 , XBOOLE_0:def 3;
L371: (C100 = C97 or C100 = C98 or C100 = [ D26 , ( xor2a ) ] or C100 = [ D26 , ( and2a ) ]) by L370 , TARSKI:def 2;
L372: ( D29 . [ D26 , ( and2a ) ] ) = ( D29 . ( IncrementOutput (C97 , C98) ) )
.= ( ( and2a ) . <* ( D28 . C97 ) , ( D28 . C98 ) *> ) by L351;
L373: ( D29 . [ D26 , ( xor2a ) ] ) = ( D29 . ( CompOutput (C97 , C98) ) )
.= ( ( xor2a ) . <* ( D28 . C97 ) , ( D28 . C98 ) *> ) by L328;
L374: ( D28 . [ D26 , ( and2a ) ] ) = ( D28 . ( IncrementOutput (C97 , C98) ) )
.= ( ( and2a ) . <* ( C99 . C97 ) , ( C99 . C98 ) *> ) by L351;
L375: ( D28 . C97 ) = ( C99 . C97 ) by L328;
thus L376: ( D29 . C100 ) = ( D28 . C100 ) by L375 , L371 , L368 , L374 , L373 , L372 , L328;
end;
L377: (( dom D28 ) = (the carrier of D27) & ( dom D29 ) = (the carrier of D27)) by CIRCUIT1:3;
thus L378: ( Following C99 ) = ( Following ( Following C99 ) ) by L377 , L367 , FUNCT_1:2;
end;
