:: Bilinear Functionals in Vector Spaces
::  by Jaros{\l}aw Kotowicz
::
:: Received November 5, 2002
:: Copyright (c) 2002-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, VECTSP_1, FUNCT_1, ZFMISC_1, XBOOLE_0, FUNCOP_1,
      SUPINF_2, ALGSTR_0, ARYTM_3, SUBSET_1, RELAT_1, ARYTM_1, RLVECT_1,
      MESFUNC1, BINOP_1, FUNCT_5, TARSKI, HAHNBAN, HAHNBAN1, MSSUBFAM,
      UNIALG_1, LATTICES, RLSUB_1, VECTSP10, GROUP_6, RELAT_2, SPPOL_1,
      BILINEAR;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, FUNCT_1, RELAT_1,
      STRUCT_0, ALGSTR_0, RLVECT_1, BINOP_1, GROUP_1, VECTSP_1, RELSET_1,
      FUNCT_2, FUNCOP_1, FUNCT_5, VECTSP_4, HAHNBAN1, VECTSP10;
 constructors BORSUK_1, VECTSP10, FUNCOP_1, BINOP_1, FUNCT_5;
 registrations SUBSET_1, RELSET_1, STRUCT_0, VECTSP_1, VECTSP_4, HAHNBAN1,
      VECTSP10, FUNCT_2;
 requirements SUBSET, BOOLE;
 definitions HAHNBAN1, TARSKI, XBOOLE_0, VECTSP_4, BINOP_1, STRUCT_0, VECTSP_1;
 theorems FUNCT_5, XBOOLE_1, FUNCT_2, HAHNBAN1, VECTSP_1, FUNCOP_1, RLVECT_1,
      VECTSP_4, TARSKI, FUNCT_1, ZFMISC_1, DOMAIN_1, VECTSP10, GROUP_1,
      BINOP_1, STRUCT_0, VECTSP_2, XTUPLE_0;
 schemes BINOP_1;

begin
definition
let C1 being 1-sorted;
let C2 , C3 being VectSpStr over C1;
mode Form of C2 , C3
 is (Function of [: (the carrier of C2) , (the carrier of C3) :] , (the carrier of C1));
end;
definition
let C4 being non  empty ZeroStr;
let C5 , C6 being VectSpStr over C4;
func NulForm (C5 , C6) -> (Form of C5 , C6) equals 
( [: (the carrier of C5) , (the carrier of C6) :] --> ( 0. C4 ) );
coherence;
end;
definition
let C7 being non  empty addLoopStr;
let C8 , C9 being non  empty VectSpStr over C7;
let C10 , C11 being (Form of C8 , C9);
func C10 + C11 -> (Form of C8 , C9) means 
:L3: (for B1 being (Vector of C8) holds (for B2 being (Vector of C9) holds ( it . (B1 , B2) ) = ( ( C10 . (B1 , B2) ) + ( C11 . (B1 , B2) ) )));
existence
proof
set D1 = (the carrier of C8);
set D2 = (the carrier of C9);
set D3 = (the carrier of C7);
deffunc H1((Element of D1) , (Element of D2)) = ( ( C10 . ($1 , $2) ) + ( C11 . ($1 , $2) ) );
consider C12 being (Function of [: D1 , D2 :] , D3) such that L4: (for B3 being (Element of D1) holds (for B4 being (Element of D2) holds ( C12 . (B3 , B4) ) = H1(B3 , B4))) from BINOP_1:sch 4;
reconsider D4 = C12 as (Form of C8 , C9);
take D4;
thus L5: thesis by L4;
end;
uniqueness
proof
let C13 , C14 being (Form of C8 , C9);
assume that
L6: (for B5 being (Vector of C8) holds (for B6 being (Vector of C9) holds ( C13 . (B5 , B6) ) = ( ( C10 . (B5 , B6) ) + ( C11 . (B5 , B6) ) )))
and
L7: (for B7 being (Vector of C8) holds (for B8 being (Vector of C9) holds ( C14 . (B7 , B8) ) = ( ( C10 . (B7 , B8) ) + ( C11 . (B7 , B8) ) )));
L8:
now
let C15 being (Vector of C8);
let C16 being (Vector of C9);
thus L9: ( C13 . (C15 , C16) ) = ( ( C10 . (C15 , C16) ) + ( C11 . (C15 , C16) ) ) by L6
.= ( C14 . (C15 , C16) ) by L7;
end;
thus L10: thesis by L8 , BINOP_1:2;
end;
end;
definition
let C17 being non  empty multMagma;
let C18 , C19 being non  empty VectSpStr over C17;
let C20 being (Form of C18 , C19);
let C21 being (Element of C17);
func C21 * C20 -> (Form of C18 , C19) means 
:L12: (for B9 being (Vector of C18) holds (for B10 being (Vector of C19) holds ( it . (B9 , B10) ) = ( C21 * ( C20 . (B9 , B10) ) )));
existence
proof
set D5 = (the carrier of C18);
set D6 = (the carrier of C19);
set D7 = (the carrier of C17);
deffunc H2((Element of D5) , (Element of D6)) = ( C21 * ( C20 . ($1 , $2) ) );
consider C22 being (Function of [: D5 , D6 :] , D7) such that L13: (for B11 being (Element of D5) holds (for B12 being (Element of D6) holds ( C22 . (B11 , B12) ) = H2(B11 , B12))) from BINOP_1:sch 4;
reconsider D8 = C22 as (Form of C18 , C19);
take D8;
thus L14: thesis by L13;
end;
uniqueness
proof
let C23 , C24 being (Form of C18 , C19);
assume that
L15: (for B13 being (Vector of C18) holds (for B14 being (Vector of C19) holds ( C23 . (B13 , B14) ) = ( C21 * ( C20 . (B13 , B14) ) )))
and
L16: (for B15 being (Vector of C18) holds (for B16 being (Vector of C19) holds ( C24 . (B15 , B16) ) = ( C21 * ( C20 . (B15 , B16) ) )));
L17:
now
let C25 being (Vector of C18);
let C26 being (Vector of C19);
thus L18: ( C23 . (C25 , C26) ) = ( C21 * ( C20 . (C25 , C26) ) ) by L15
.= ( C24 . (C25 , C26) ) by L16;
end;
thus L19: thesis by L17 , BINOP_1:2;
end;
end;
definition
let C27 being non  empty addLoopStr;
let C28 , C29 being non  empty VectSpStr over C27;
let C30 being (Form of C28 , C29);
func - C30 -> (Form of C28 , C29) means 
:L21: (for B17 being (Vector of C28) holds (for B18 being (Vector of C29) holds ( it . (B17 , B18) ) = ( - ( C30 . (B17 , B18) ) )));
existence
proof
set D9 = (the carrier of C28);
set D10 = (the carrier of C29);
set D11 = (the carrier of C27);
deffunc H3((Element of D9) , (Element of D10)) = ( - ( C30 . ($1 , $2) ) );
consider C31 being (Function of [: D9 , D10 :] , D11) such that L22: (for B19 being (Element of D9) holds (for B20 being (Element of D10) holds ( C31 . (B19 , B20) ) = H3(B19 , B20))) from BINOP_1:sch 4;
reconsider D12 = C31 as (Form of C28 , C29);
take D12;
thus L23: thesis by L22;
end;
uniqueness
proof
let C32 , C33 being (Form of C28 , C29);
assume that
L24: (for B21 being (Vector of C28) holds (for B22 being (Vector of C29) holds ( C32 . (B21 , B22) ) = ( - ( C30 . (B21 , B22) ) )))
and
L25: (for B23 being (Vector of C28) holds (for B24 being (Vector of C29) holds ( C33 . (B23 , B24) ) = ( - ( C30 . (B23 , B24) ) )));
L26:
now
let C34 being (Vector of C28);
let C35 being (Vector of C29);
thus L27: ( C32 . (C34 , C35) ) = ( - ( C30 . (C34 , C35) ) ) by L24
.= ( C33 . (C34 , C35) ) by L25;
end;
thus L28: thesis by L26 , BINOP_1:2;
end;
end;
definition
let C36 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr;
let C37 , C38 being non  empty VectSpStr over C36;
let C39 being (Form of C37 , C38);
redefine func - C39 equals 
( ( - ( 1. C36 ) ) * C39 );
compatibility
proof
let C40 being (Form of C37 , C38);
thus L30: (C40 = ( - C39 ) implies C40 = ( ( - ( 1. C36 ) ) * C39 ))
proof
assume L31: C40 = ( - C39 );
L32:
now
let C41 being (Vector of C37);
let C42 being (Vector of C38);
thus L33: ( C40 . (C41 , C42) ) = ( - ( C39 . (C41 , C42) ) ) by L31 , L21
.= ( ( - ( 1. C36 ) ) * ( C39 . (C41 , C42) ) ) by VECTSP_2:29
.= ( ( ( - ( 1. C36 ) ) * C39 ) . (C41 , C42) ) by L12;
end;
thus L34: thesis by L32 , BINOP_1:2;
end;

assume L35: C40 = ( ( - ( 1. C36 ) ) * C39 );
L36:
now
let C43 being (Vector of C37);
let C44 being (Vector of C38);
thus L37: ( C40 . (C43 , C44) ) = ( ( - ( 1. C36 ) ) * ( C39 . (C43 , C44) ) ) by L35 , L12
.= ( - ( C39 . (C43 , C44) ) ) by VECTSP_2:29
.= ( ( - C39 ) . (C43 , C44) ) by L21;
end;
thus L38: thesis by L36 , BINOP_1:2;
end;
end;
definition
let C45 being non  empty addLoopStr;
let C46 , C47 being non  empty VectSpStr over C45;
let C48 , C49 being (Form of C46 , C47);
func C48 - C49 -> (Form of C46 , C47) equals 
( C48 + ( - C49 ) );
correctness;
end;
definition
let C50 being non  empty addLoopStr;
let C51 , C52 being non  empty VectSpStr over C50;
let C53 , C54 being (Form of C51 , C52);
redefine func C53 - C54 means 
:L41: (for B25 being (Vector of C51) holds (for B26 being (Vector of C52) holds ( it . (B25 , B26) ) = ( ( C53 . (B25 , B26) ) - ( C54 . (B25 , B26) ) )));
compatibility
proof
let C55 being (Form of C51 , C52);
thus L42: (C55 = ( C53 - C54 ) implies (for B27 being (Vector of C51) holds (for B28 being (Vector of C52) holds ( C55 . (B27 , B28) ) = ( ( C53 . (B27 , B28) ) - ( C54 . (B27 , B28) ) ))))
proof
assume L43: C55 = ( C53 - C54 );
let C56 being (Vector of C51);
let C57 being (Vector of C52);
thus L44: ( C55 . (C56 , C57) ) = ( ( C53 . (C56 , C57) ) + ( ( - C54 ) . (C56 , C57) ) ) by L43 , L3
.= ( ( C53 . (C56 , C57) ) + ( - ( C54 . (C56 , C57) ) ) ) by L21
.= ( ( C53 . (C56 , C57) ) - ( C54 . (C56 , C57) ) ) by RLVECT_1:def 11;
end;

assume L45: (for B29 being (Vector of C51) holds (for B30 being (Vector of C52) holds ( C55 . (B29 , B30) ) = ( ( C53 . (B29 , B30) ) - ( C54 . (B29 , B30) ) )));
L46:
now
let C58 being (Vector of C51);
let C59 being (Vector of C52);
thus L47: ( C55 . (C58 , C59) ) = ( ( C53 . (C58 , C59) ) - ( C54 . (C58 , C59) ) ) by L45
.= ( ( C53 . (C58 , C59) ) + ( - ( C54 . (C58 , C59) ) ) ) by RLVECT_1:def 11
.= ( ( C53 . (C58 , C59) ) + ( ( - C54 ) . (C58 , C59) ) ) by L21
.= ( ( C53 - C54 ) . (C58 , C59) ) by L3;
end;
thus L48: thesis by L46 , BINOP_1:2;
end;
end;
definition
let C60 being  Abelian non  empty addLoopStr;
let C61 , C62 being non  empty VectSpStr over C60;
let C63 , C64 being (Form of C61 , C62);
redefine func C63 + C64;

commutativity
proof
let C65 , C66 being (Form of C61 , C62);
L50:
now
let C67 being (Vector of C61);
let C68 being (Vector of C62);
thus L51: ( ( C65 + C66 ) . (C67 , C68) ) = ( ( C65 . (C67 , C68) ) + ( C66 . (C67 , C68) ) ) by L3
.= ( ( C66 + C65 ) . (C67 , C68) ) by L3;
end;
thus L52: ( C65 + C66 ) = ( C66 + C65 ) by L50 , BINOP_1:2;
end;
end;
theorem
L54: (for B31 being  right_zeroed non  empty addLoopStr holds (for B32 , B33 being non  empty VectSpStr over B31 holds (for B34 being (Form of B32 , B33) holds ( B34 + ( NulForm (B32 , B33) ) ) = B34)))
proof
let C69 being  right_zeroed non  empty addLoopStr;
let C70 , C71 being non  empty VectSpStr over C69;
let C72 being (Form of C70 , C71);
set D13 = ( NulForm (C70 , C71) );
L55:
now
let C73 being (Vector of C70);
let C74 being (Vector of C71);
thus L56: ( ( C72 + D13 ) . (C73 , C74) ) = ( ( C72 . (C73 , C74) ) + ( D13 . (C73 , C74) ) ) by L3
.= ( ( C72 . (C73 , C74) ) + ( 0. C69 ) ) by FUNCOP_1:70
.= ( C72 . (C73 , C74) ) by RLVECT_1:def 4;
end;
thus L57: thesis by L55 , BINOP_1:2;
end;
theorem
L58: (for B35 being  add-associative non  empty addLoopStr holds (for B36 , B37 being non  empty VectSpStr over B35 holds (for B38 , B39 , B40 being (Form of B36 , B37) holds ( ( B38 + B39 ) + B40 ) = ( B38 + ( B39 + B40 ) ))))
proof
let C75 being  add-associative non  empty addLoopStr;
let C76 , C77 being non  empty VectSpStr over C75;
let C78 , C79 , C80 being (Form of C76 , C77);
L59:
now
let C81 being (Vector of C76);
let C82 being (Vector of C77);
thus L60: ( ( ( C78 + C79 ) + C80 ) . (C81 , C82) ) = ( ( ( C78 + C79 ) . (C81 , C82) ) + ( C80 . (C81 , C82) ) ) by L3
.= ( ( ( C78 . (C81 , C82) ) + ( C79 . (C81 , C82) ) ) + ( C80 . (C81 , C82) ) ) by L3
.= ( ( C78 . (C81 , C82) ) + ( ( C79 . (C81 , C82) ) + ( C80 . (C81 , C82) ) ) ) by RLVECT_1:def 3
.= ( ( C78 . (C81 , C82) ) + ( ( C79 + C80 ) . (C81 , C82) ) ) by L3
.= ( ( C78 + ( C79 + C80 ) ) . (C81 , C82) ) by L3;
end;
thus L61: thesis by L59 , BINOP_1:2;
end;
theorem
L62: (for B41 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B42 , B43 being non  empty VectSpStr over B41 holds (for B44 being (Form of B42 , B43) holds ( B44 - B44 ) = ( NulForm (B42 , B43) ))))
proof
let C83 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C84 , C85 being non  empty VectSpStr over C83;
let C86 being (Form of C84 , C85);
L63:
now
let C87 being (Vector of C84);
let C88 being (Vector of C85);
thus L64: ( ( C86 - C86 ) . (C87 , C88) ) = ( ( C86 . (C87 , C88) ) - ( C86 . (C87 , C88) ) ) by L41
.= ( 0. C83 ) by RLVECT_1:15
.= ( ( NulForm (C84 , C85) ) . (C87 , C88) ) by FUNCOP_1:70;
end;
thus L65: thesis by L63 , BINOP_1:2;
end;
theorem
L66: (for B45 being  right-distributive non  empty doubleLoopStr holds (for B46 , B47 being non  empty VectSpStr over B45 holds (for B48 being (Element of B45) holds (for B49 , B50 being (Form of B46 , B47) holds ( B48 * ( B49 + B50 ) ) = ( ( B48 * B49 ) + ( B48 * B50 ) )))))
proof
let C89 being  right-distributive non  empty doubleLoopStr;
let C90 , C91 being non  empty VectSpStr over C89;
let C92 being (Element of C89);
let C93 , C94 being (Form of C90 , C91);
L67:
now
let C95 being (Vector of C90);
let C96 being (Vector of C91);
thus L68: ( ( C92 * ( C93 + C94 ) ) . (C95 , C96) ) = ( C92 * ( ( C93 + C94 ) . (C95 , C96) ) ) by L12
.= ( C92 * ( ( C93 . (C95 , C96) ) + ( C94 . (C95 , C96) ) ) ) by L3
.= ( ( C92 * ( C93 . (C95 , C96) ) ) + ( C92 * ( C94 . (C95 , C96) ) ) ) by VECTSP_1:def 2
.= ( ( ( C92 * C93 ) . (C95 , C96) ) + ( C92 * ( C94 . (C95 , C96) ) ) ) by L12
.= ( ( ( C92 * C93 ) . (C95 , C96) ) + ( ( C92 * C94 ) . (C95 , C96) ) ) by L12
.= ( ( ( C92 * C93 ) + ( C92 * C94 ) ) . (C95 , C96) ) by L3;
end;
thus L69: thesis by L67 , BINOP_1:2;
end;
theorem
L70: (for B51 being  left-distributive non  empty doubleLoopStr holds (for B52 , B53 being non  empty VectSpStr over B51 holds (for B54 , B55 being (Element of B51) holds (for B56 being (Form of B52 , B53) holds ( ( B54 + B55 ) * B56 ) = ( ( B54 * B56 ) + ( B55 * B56 ) )))))
proof
let C97 being  left-distributive non  empty doubleLoopStr;
let C98 , C99 being non  empty VectSpStr over C97;
let C100 , C101 being (Element of C97);
let C102 being (Form of C98 , C99);
L71:
now
let C103 being (Vector of C98);
let C104 being (Vector of C99);
thus L72: ( ( ( C100 + C101 ) * C102 ) . (C103 , C104) ) = ( ( C100 + C101 ) * ( C102 . (C103 , C104) ) ) by L12
.= ( ( C100 * ( C102 . (C103 , C104) ) ) + ( C101 * ( C102 . (C103 , C104) ) ) ) by VECTSP_1:def 3
.= ( ( ( C100 * C102 ) . (C103 , C104) ) + ( C101 * ( C102 . (C103 , C104) ) ) ) by L12
.= ( ( ( C100 * C102 ) . (C103 , C104) ) + ( ( C101 * C102 ) . (C103 , C104) ) ) by L12
.= ( ( ( C100 * C102 ) + ( C101 * C102 ) ) . (C103 , C104) ) by L3;
end;
thus L73: thesis by L71 , BINOP_1:2;
end;
theorem
L74: (for B57 being  associative non  empty doubleLoopStr holds (for B58 , B59 being non  empty VectSpStr over B57 holds (for B60 , B61 being (Element of B57) holds (for B62 being (Form of B58 , B59) holds ( ( B60 * B61 ) * B62 ) = ( B60 * ( B61 * B62 ) )))))
proof
let C105 being  associative non  empty doubleLoopStr;
let C106 , C107 being non  empty VectSpStr over C105;
let C108 , C109 being (Element of C105);
let C110 being (Form of C106 , C107);
L75:
now
let C111 being (Vector of C106);
let C112 being (Vector of C107);
thus L76: ( ( ( C108 * C109 ) * C110 ) . (C111 , C112) ) = ( ( C108 * C109 ) * ( C110 . (C111 , C112) ) ) by L12
.= ( C108 * ( C109 * ( C110 . (C111 , C112) ) ) ) by GROUP_1:def 3
.= ( C108 * ( ( C109 * C110 ) . (C111 , C112) ) ) by L12
.= ( ( C108 * ( C109 * C110 ) ) . (C111 , C112) ) by L12;
end;
thus L77: thesis by L75 , BINOP_1:2;
end;
theorem
L78: (for B63 being  left_unital non  empty doubleLoopStr holds (for B64 , B65 being non  empty VectSpStr over B63 holds (for B66 being (Form of B64 , B65) holds ( ( 1. B63 ) * B66 ) = B66)))
proof
let C113 being  left_unital non  empty doubleLoopStr;
let C114 , C115 being non  empty VectSpStr over C113;
let C116 being (Form of C114 , C115);
L79:
now
let C117 being (Vector of C114);
let C118 being (Vector of C115);
thus L80: ( ( ( 1. C113 ) * C116 ) . (C117 , C118) ) = ( ( 1. C113 ) * ( C116 . (C117 , C118) ) ) by L12
.= ( C116 . (C117 , C118) ) by VECTSP_1:def 8;
end;
thus L81: thesis by L79 , BINOP_1:2;
end;
begin
definition
let C119 being non  empty 1-sorted;
let C120 , C121 being non  empty VectSpStr over C119;
let C122 being (Form of C120 , C121);
let C123 being (Vector of C120);
func FunctionalFAF (C122 , C123) -> (Functional of C121) equals 
( ( curry C122 ) . C123 );
correctness;
end;
definition
let C124 being non  empty 1-sorted;
let C125 , C126 being non  empty VectSpStr over C124;
let C127 being (Form of C125 , C126);
let C128 being (Vector of C126);
func FunctionalSAF (C127 , C128) -> (Functional of C125) equals 
( ( curry' C127 ) . C128 );
correctness;
end;
theorem
L84: (for B67 being non  empty 1-sorted holds (for B68 , B69 being non  empty VectSpStr over B67 holds (for B70 being (Form of B68 , B69) holds (for B71 being (Vector of B68) holds (( dom ( FunctionalFAF (B70 , B71) ) ) = (the carrier of B69) & ( rng ( FunctionalFAF (B70 , B71) ) ) c= (the carrier of B67) & (for B72 being (Vector of B69) holds ( ( FunctionalFAF (B70 , B71) ) . B72 ) = ( B70 . (B71 , B72) )))))))
proof
let C129 being non  empty 1-sorted;
let C130 , C131 being non  empty VectSpStr over C129;
let C132 being (Form of C130 , C131);
let C133 being (Vector of C130);
set D14 = ( FunctionalFAF (C132 , C133) );
L85: ( dom C132 ) = [: (the carrier of C130) , (the carrier of C131) :] by FUNCT_2:def 1;
L86: (ex B73 being Function st (( ( curry C132 ) . C133 ) = B73 & ( dom B73 ) = (the carrier of C131) & ( rng B73 ) c= ( rng C132 ) & (for B74 being set holds (B74 in (the carrier of C131) implies ( B73 . B74 ) = ( C132 . (C133 , B74) ))))) by L85 , FUNCT_5:29;
thus L87: (( dom D14 ) = (the carrier of C131) & ( rng D14 ) c= (the carrier of C129)) by L86;
let C134 being (Vector of C131);
thus L88: thesis by L86;
end;
theorem
L89: (for B75 being non  empty 1-sorted holds (for B76 , B77 being non  empty VectSpStr over B75 holds (for B78 being (Form of B76 , B77) holds (for B79 being (Vector of B77) holds (( dom ( FunctionalSAF (B78 , B79) ) ) = (the carrier of B76) & ( rng ( FunctionalSAF (B78 , B79) ) ) c= (the carrier of B75) & (for B80 being (Vector of B76) holds ( ( FunctionalSAF (B78 , B79) ) . B80 ) = ( B78 . (B80 , B79) )))))))
proof
let C135 being non  empty 1-sorted;
let C136 , C137 being non  empty VectSpStr over C135;
let C138 being (Form of C136 , C137);
let C139 being (Vector of C137);
set D15 = ( FunctionalSAF (C138 , C139) );
L90: ( dom C138 ) = [: (the carrier of C136) , (the carrier of C137) :] by FUNCT_2:def 1;
L91: (ex B81 being Function st (( ( curry' C138 ) . C139 ) = B81 & ( dom B81 ) = (the carrier of C136) & ( rng B81 ) c= ( rng C138 ) & (for B82 being set holds (B82 in (the carrier of C136) implies ( B81 . B82 ) = ( C138 . (B82 , C139) ))))) by L90 , FUNCT_5:32;
thus L92: (( dom D15 ) = (the carrier of C136) & ( rng D15 ) c= (the carrier of C135)) by L91;
let C140 being (Vector of C136);
thus L93: thesis by L91;
end;
theorem
L94: (for B83 being non  empty ZeroStr holds (for B84 , B85 being non  empty VectSpStr over B83 holds (for B86 being (Vector of B84) holds ( FunctionalFAF (( NulForm (B84 , B85) ) , B86) ) = ( 0Functional B85 ))))
proof
let C141 being non  empty ZeroStr;
let C142 , C143 being non  empty VectSpStr over C141;
let C144 being (Vector of C142);
set D16 = ( NulForm (C142 , C143) );
L95:
now
let C145 being (Vector of C143);
thus L96: ( ( FunctionalFAF (D16 , C144) ) . C145 ) = ( D16 . (C144 , C145) ) by L84
.= ( 0. C141 ) by FUNCOP_1:70
.= ( ( 0Functional C143 ) . C145 ) by HAHNBAN1:14;
end;
thus L97: thesis by L95 , FUNCT_2:63;
end;
theorem
L98: (for B87 being non  empty ZeroStr holds (for B88 , B89 being non  empty VectSpStr over B87 holds (for B90 being (Vector of B89) holds ( FunctionalSAF (( NulForm (B88 , B89) ) , B90) ) = ( 0Functional B88 ))))
proof
let C146 being non  empty ZeroStr;
let C147 , C148 being non  empty VectSpStr over C146;
let C149 being (Vector of C148);
set D17 = ( NulForm (C147 , C148) );
L99:
now
let C150 being (Vector of C147);
thus L100: ( ( FunctionalSAF (D17 , C149) ) . C150 ) = ( D17 . (C150 , C149) ) by L89
.= ( 0. C146 ) by FUNCOP_1:70
.= ( ( 0Functional C147 ) . C150 ) by HAHNBAN1:14;
end;
thus L101: thesis by L99 , FUNCT_2:63;
end;
theorem
L102: (for B91 being non  empty addLoopStr holds (for B92 , B93 being non  empty VectSpStr over B91 holds (for B94 , B95 being (Form of B92 , B93) holds (for B96 being (Vector of B93) holds ( FunctionalSAF (( B94 + B95 ) , B96) ) = ( ( FunctionalSAF (B94 , B96) ) + ( FunctionalSAF (B95 , B96) ) )))))
proof
let C151 being non  empty addLoopStr;
let C152 , C153 being non  empty VectSpStr over C151;
let C154 , C155 being (Form of C152 , C153);
let C156 being (Vector of C153);
L103:
now
let C157 being (Vector of C152);
thus L104: ( ( FunctionalSAF (( C154 + C155 ) , C156) ) . C157 ) = ( ( C154 + C155 ) . (C157 , C156) ) by L89
.= ( ( C154 . (C157 , C156) ) + ( C155 . (C157 , C156) ) ) by L3
.= ( ( ( FunctionalSAF (C154 , C156) ) . C157 ) + ( C155 . (C157 , C156) ) ) by L89
.= ( ( ( FunctionalSAF (C154 , C156) ) . C157 ) + ( ( FunctionalSAF (C155 , C156) ) . C157 ) ) by L89
.= ( ( ( FunctionalSAF (C154 , C156) ) + ( FunctionalSAF (C155 , C156) ) ) . C157 ) by HAHNBAN1:def 3;
end;
thus L105: thesis by L103 , FUNCT_2:63;
end;
theorem
L106: (for B97 being non  empty addLoopStr holds (for B98 , B99 being non  empty VectSpStr over B97 holds (for B100 , B101 being (Form of B98 , B99) holds (for B102 being (Vector of B98) holds ( FunctionalFAF (( B100 + B101 ) , B102) ) = ( ( FunctionalFAF (B100 , B102) ) + ( FunctionalFAF (B101 , B102) ) )))))
proof
let C158 being non  empty addLoopStr;
let C159 , C160 being non  empty VectSpStr over C158;
let C161 , C162 being (Form of C159 , C160);
let C163 being (Vector of C159);
L107:
now
let C164 being (Vector of C160);
thus L108: ( ( FunctionalFAF (( C161 + C162 ) , C163) ) . C164 ) = ( ( C161 + C162 ) . (C163 , C164) ) by L84
.= ( ( C161 . (C163 , C164) ) + ( C162 . (C163 , C164) ) ) by L3
.= ( ( ( FunctionalFAF (C161 , C163) ) . C164 ) + ( C162 . (C163 , C164) ) ) by L84
.= ( ( ( FunctionalFAF (C161 , C163) ) . C164 ) + ( ( FunctionalFAF (C162 , C163) ) . C164 ) ) by L84
.= ( ( ( FunctionalFAF (C161 , C163) ) + ( FunctionalFAF (C162 , C163) ) ) . C164 ) by HAHNBAN1:def 3;
end;
thus L109: thesis by L107 , FUNCT_2:63;
end;
theorem
L110: (for B103 being non  empty doubleLoopStr holds (for B104 , B105 being non  empty VectSpStr over B103 holds (for B106 being (Form of B104 , B105) holds (for B107 being (Element of B103) holds (for B108 being (Vector of B105) holds ( FunctionalSAF (( B107 * B106 ) , B108) ) = ( B107 * ( FunctionalSAF (B106 , B108) ) ))))))
proof
let C165 being non  empty doubleLoopStr;
let C166 , C167 being non  empty VectSpStr over C165;
let C168 being (Form of C166 , C167);
let C169 being (Element of C165);
let C170 being (Vector of C167);
L111:
now
let C171 being (Vector of C166);
thus L112: ( ( FunctionalSAF (( C169 * C168 ) , C170) ) . C171 ) = ( ( C169 * C168 ) . (C171 , C170) ) by L89
.= ( C169 * ( C168 . (C171 , C170) ) ) by L12
.= ( C169 * ( ( FunctionalSAF (C168 , C170) ) . C171 ) ) by L89
.= ( ( C169 * ( FunctionalSAF (C168 , C170) ) ) . C171 ) by HAHNBAN1:def 6;
end;
thus L113: thesis by L111 , FUNCT_2:63;
end;
theorem
L114: (for B109 being non  empty doubleLoopStr holds (for B110 , B111 being non  empty VectSpStr over B109 holds (for B112 being (Form of B110 , B111) holds (for B113 being (Element of B109) holds (for B114 being (Vector of B110) holds ( FunctionalFAF (( B113 * B112 ) , B114) ) = ( B113 * ( FunctionalFAF (B112 , B114) ) ))))))
proof
let C172 being non  empty doubleLoopStr;
let C173 , C174 being non  empty VectSpStr over C172;
let C175 being (Form of C173 , C174);
let C176 being (Element of C172);
let C177 being (Vector of C173);
L115:
now
let C178 being (Vector of C174);
thus L116: ( ( FunctionalFAF (( C176 * C175 ) , C177) ) . C178 ) = ( ( C176 * C175 ) . (C177 , C178) ) by L84
.= ( C176 * ( C175 . (C177 , C178) ) ) by L12
.= ( C176 * ( ( FunctionalFAF (C175 , C177) ) . C178 ) ) by L84
.= ( ( C176 * ( FunctionalFAF (C175 , C177) ) ) . C178 ) by HAHNBAN1:def 6;
end;
thus L117: thesis by L115 , FUNCT_2:63;
end;
theorem
L118: (for B115 being non  empty addLoopStr holds (for B116 , B117 being non  empty VectSpStr over B115 holds (for B118 being (Form of B116 , B117) holds (for B119 being (Vector of B117) holds ( FunctionalSAF (( - B118 ) , B119) ) = ( - ( FunctionalSAF (B118 , B119) ) )))))
proof
let C179 being non  empty addLoopStr;
let C180 , C181 being non  empty VectSpStr over C179;
let C182 being (Form of C180 , C181);
let C183 being (Vector of C181);
L119:
now
let C184 being (Vector of C180);
thus L120: ( ( FunctionalSAF (( - C182 ) , C183) ) . C184 ) = ( ( - C182 ) . (C184 , C183) ) by L89
.= ( - ( C182 . (C184 , C183) ) ) by L21
.= ( - ( ( FunctionalSAF (C182 , C183) ) . C184 ) ) by L89
.= ( ( - ( FunctionalSAF (C182 , C183) ) ) . C184 ) by HAHNBAN1:def 4;
end;
thus L121: thesis by L119 , FUNCT_2:63;
end;
theorem
L122: (for B120 being non  empty addLoopStr holds (for B121 , B122 being non  empty VectSpStr over B120 holds (for B123 being (Form of B121 , B122) holds (for B124 being (Vector of B121) holds ( FunctionalFAF (( - B123 ) , B124) ) = ( - ( FunctionalFAF (B123 , B124) ) )))))
proof
let C185 being non  empty addLoopStr;
let C186 , C187 being non  empty VectSpStr over C185;
let C188 being (Form of C186 , C187);
let C189 being (Vector of C186);
L123:
now
let C190 being (Vector of C187);
thus L124: ( ( FunctionalFAF (( - C188 ) , C189) ) . C190 ) = ( ( - C188 ) . (C189 , C190) ) by L84
.= ( - ( C188 . (C189 , C190) ) ) by L21
.= ( - ( ( FunctionalFAF (C188 , C189) ) . C190 ) ) by L84
.= ( ( - ( FunctionalFAF (C188 , C189) ) ) . C190 ) by HAHNBAN1:def 4;
end;
thus L125: thesis by L123 , FUNCT_2:63;
end;
theorem
L126: (for B125 being non  empty addLoopStr holds (for B126 , B127 being non  empty VectSpStr over B125 holds (for B128 , B129 being (Form of B126 , B127) holds (for B130 being (Vector of B127) holds ( FunctionalSAF (( B128 - B129 ) , B130) ) = ( ( FunctionalSAF (B128 , B130) ) - ( FunctionalSAF (B129 , B130) ) )))))
proof
let C191 being non  empty addLoopStr;
let C192 , C193 being non  empty VectSpStr over C191;
let C194 , C195 being (Form of C192 , C193);
let C196 being (Vector of C193);
L127:
now
let C197 being (Vector of C192);
thus L128: ( ( FunctionalSAF (( C194 - C195 ) , C196) ) . C197 ) = ( ( C194 - C195 ) . (C197 , C196) ) by L89
.= ( ( C194 . (C197 , C196) ) - ( C195 . (C197 , C196) ) ) by L41
.= ( ( ( FunctionalSAF (C194 , C196) ) . C197 ) - ( C195 . (C197 , C196) ) ) by L89
.= ( ( ( FunctionalSAF (C194 , C196) ) . C197 ) - ( ( FunctionalSAF (C195 , C196) ) . C197 ) ) by L89
.= ( ( ( FunctionalSAF (C194 , C196) ) . C197 ) + ( - ( ( FunctionalSAF (C195 , C196) ) . C197 ) ) ) by RLVECT_1:def 11
.= ( ( ( FunctionalSAF (C194 , C196) ) . C197 ) + ( ( - ( FunctionalSAF (C195 , C196) ) ) . C197 ) ) by HAHNBAN1:def 4
.= ( ( ( FunctionalSAF (C194 , C196) ) - ( FunctionalSAF (C195 , C196) ) ) . C197 ) by HAHNBAN1:def 3;
end;
thus L129: thesis by L127 , FUNCT_2:63;
end;
theorem
L130: (for B131 being non  empty addLoopStr holds (for B132 , B133 being non  empty VectSpStr over B131 holds (for B134 , B135 being (Form of B132 , B133) holds (for B136 being (Vector of B132) holds ( FunctionalFAF (( B134 - B135 ) , B136) ) = ( ( FunctionalFAF (B134 , B136) ) - ( FunctionalFAF (B135 , B136) ) )))))
proof
let C198 being non  empty addLoopStr;
let C199 , C200 being non  empty VectSpStr over C198;
let C201 , C202 being (Form of C199 , C200);
let C203 being (Vector of C199);
L131:
now
let C204 being (Vector of C200);
thus L132: ( ( FunctionalFAF (( C201 - C202 ) , C203) ) . C204 ) = ( ( C201 - C202 ) . (C203 , C204) ) by L84
.= ( ( C201 . (C203 , C204) ) - ( C202 . (C203 , C204) ) ) by L41
.= ( ( ( FunctionalFAF (C201 , C203) ) . C204 ) - ( C202 . (C203 , C204) ) ) by L84
.= ( ( ( FunctionalFAF (C201 , C203) ) . C204 ) - ( ( FunctionalFAF (C202 , C203) ) . C204 ) ) by L84
.= ( ( ( FunctionalFAF (C201 , C203) ) . C204 ) + ( - ( ( FunctionalFAF (C202 , C203) ) . C204 ) ) ) by RLVECT_1:def 11
.= ( ( ( FunctionalFAF (C201 , C203) ) . C204 ) + ( ( - ( FunctionalFAF (C202 , C203) ) ) . C204 ) ) by HAHNBAN1:def 4
.= ( ( ( FunctionalFAF (C201 , C203) ) - ( FunctionalFAF (C202 , C203) ) ) . C204 ) by HAHNBAN1:def 3;
end;
thus L133: thesis by L131 , FUNCT_2:63;
end;
begin
definition
let C205 being non  empty multMagma;
let C206 , C207 being non  empty VectSpStr over C205;
let C208 being (Functional of C206);
let C209 being (Functional of C207);
func FormFunctional (C208 , C209) -> (Form of C206 , C207) means 
:L134: (for B137 being (Vector of C206) holds (for B138 being (Vector of C207) holds ( it . (B137 , B138) ) = ( ( C208 . B137 ) * ( C209 . B138 ) )));
existence
proof
deffunc H4((Vector of C206) , (Vector of C207)) = ( ( C208 . $1 ) * ( C209 . $2 ) );
set D18 = (the carrier of C206);
set D19 = (the carrier of C207);
set D20 = (the carrier of C205);
consider C210 being (Function of [: D18 , D19 :] , D20) such that L135: (for B139 being (Element of D18) holds (for B140 being (Element of D19) holds ( C210 . (B139 , B140) ) = H4(B139 , B140))) from BINOP_1:sch 4;
reconsider D21 = C210 as (Form of C206 , C207);
take D21;
thus L136: thesis by L135;
end;
uniqueness
proof
let C211 , C212 being (Form of C206 , C207);
assume that
L137: (for B141 being (Vector of C206) holds (for B142 being (Vector of C207) holds ( C211 . (B141 , B142) ) = ( ( C208 . B141 ) * ( C209 . B142 ) )))
and
L138: (for B143 being (Vector of C206) holds (for B144 being (Vector of C207) holds ( C212 . (B143 , B144) ) = ( ( C208 . B143 ) * ( C209 . B144 ) )));
L139:
now
let C213 being (Vector of C206);
let C214 being (Vector of C207);
thus L140: ( C211 . (C213 , C214) ) = ( ( C208 . C213 ) * ( C209 . C214 ) ) by L137
.= ( C212 . (C213 , C214) ) by L138;
end;
thus L141: thesis by L139 , BINOP_1:2;
end;
end;
theorem
L143: (for B145 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B146 , B147 being non  empty VectSpStr over B145 holds (for B148 being (Functional of B146) holds (for B149 being (Vector of B146) holds (for B150 being (Vector of B147) holds ( ( FormFunctional (B148 , ( 0Functional B147 )) ) . (B149 , B150) ) = ( 0. B145 ))))))
proof
let C215 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C216 , C217 being non  empty VectSpStr over C215;
let C218 being (Functional of C216);
let C219 being (Vector of C216);
let C220 being (Vector of C217);
set D22 = ( 0Functional C217 );
set D23 = ( FormFunctional (C218 , D22) );
thus L144: ( D23 . (C219 , C220) ) = ( ( C218 . C219 ) * ( D22 . C220 ) ) by L134
.= ( ( C218 . C219 ) * ( 0. C215 ) ) by FUNCOP_1:7
.= ( 0. C215 ) by VECTSP_1:6;
end;
theorem
L145: (for B151 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr holds (for B152 , B153 being non  empty VectSpStr over B151 holds (for B154 being (Functional of B153) holds (for B155 being (Vector of B152) holds (for B156 being (Vector of B153) holds ( ( FormFunctional (( 0Functional B152 ) , B154) ) . (B155 , B156) ) = ( 0. B151 ))))))
proof
let C221 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr;
let C222 , C223 being non  empty VectSpStr over C221;
let C224 being (Functional of C223);
let C225 being (Vector of C222);
let C226 being (Vector of C223);
set D24 = ( 0Functional C222 );
set D25 = ( FormFunctional (D24 , C224) );
thus L146: ( D25 . (C225 , C226) ) = ( ( D24 . C225 ) * ( C224 . C226 ) ) by L134
.= ( ( 0. C221 ) * ( C224 . C226 ) ) by FUNCOP_1:7
.= ( 0. C221 ) by VECTSP_1:7;
end;
theorem
L147: (for B157 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B158 , B159 being non  empty VectSpStr over B157 holds (for B160 being (Functional of B158) holds ( FormFunctional (B160 , ( 0Functional B159 )) ) = ( NulForm (B158 , B159) ))))
proof
let C227 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C228 , C229 being non  empty VectSpStr over C227;
let C230 being (Functional of C228);
L148:
now
let C231 being (Vector of C228);
let C232 being (Vector of C229);
thus L149: ( ( FormFunctional (C230 , ( 0Functional C229 )) ) . (C231 , C232) ) = ( 0. C227 ) by L143
.= ( ( NulForm (C228 , C229) ) . (C231 , C232) ) by FUNCOP_1:70;
end;
thus L150: thesis by L148 , BINOP_1:2;
end;
theorem
L151: (for B161 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr holds (for B162 , B163 being non  empty VectSpStr over B161 holds (for B164 being (Functional of B163) holds ( FormFunctional (( 0Functional B162 ) , B164) ) = ( NulForm (B162 , B163) ))))
proof
let C233 being  add-associative  right_zeroed  right_complementable  left-distributive non  empty doubleLoopStr;
let C234 , C235 being non  empty VectSpStr over C233;
let C236 being (Functional of C235);
L152:
now
let C237 being (Vector of C234);
let C238 being (Vector of C235);
thus L153: ( ( FormFunctional (( 0Functional C234 ) , C236) ) . (C237 , C238) ) = ( 0. C233 ) by L145
.= ( ( NulForm (C234 , C235) ) . (C237 , C238) ) by FUNCOP_1:70;
end;
thus L154: thesis by L152 , BINOP_1:2;
end;
theorem
L155: (for B165 being non  empty multMagma holds (for B166 , B167 being non  empty VectSpStr over B165 holds (for B168 being (Functional of B166) holds (for B169 being (Functional of B167) holds (for B170 being (Vector of B166) holds ( FunctionalFAF (( FormFunctional (B168 , B169) ) , B170) ) = ( ( B168 . B170 ) * B169 ))))))
proof
let C239 being non  empty multMagma;
let C240 , C241 being non  empty VectSpStr over C239;
let C242 being (Functional of C240);
let C243 being (Functional of C241);
let C244 being (Vector of C240);
set D26 = ( FormFunctional (C242 , C243) );
set D27 = ( FunctionalFAF (D26 , C244) );
L156:
now
let C245 being (Vector of C241);
thus L157: ( D27 . C245 ) = ( D26 . (C244 , C245) ) by L84
.= ( ( C242 . C244 ) * ( C243 . C245 ) ) by L134
.= ( ( ( C242 . C244 ) * C243 ) . C245 ) by HAHNBAN1:def 6;
end;
thus L158: thesis by L156 , FUNCT_2:63;
end;
theorem
L159: (for B171 being  commutative non  empty multMagma holds (for B172 , B173 being non  empty VectSpStr over B171 holds (for B174 being (Functional of B172) holds (for B175 being (Functional of B173) holds (for B176 being (Vector of B173) holds ( FunctionalSAF (( FormFunctional (B174 , B175) ) , B176) ) = ( ( B175 . B176 ) * B174 ))))))
proof
let C246 being  commutative non  empty multMagma;
let C247 , C248 being non  empty VectSpStr over C246;
let C249 being (Functional of C247);
let C250 being (Functional of C248);
let C251 being (Vector of C248);
set D28 = ( FormFunctional (C249 , C250) );
set D29 = ( FunctionalSAF (D28 , C251) );
L160:
now
let C252 being (Vector of C247);
thus L161: ( D29 . C252 ) = ( D28 . (C252 , C251) ) by L89
.= ( ( C249 . C252 ) * ( C250 . C251 ) ) by L134
.= ( ( ( C250 . C251 ) * C249 ) . C252 ) by HAHNBAN1:def 6;
end;
thus L162: thesis by L160 , FUNCT_2:63;
end;
begin
definition
let C253 being non  empty addLoopStr;
let C254 , C255 being non  empty VectSpStr over C253;
let C256 being (Form of C254 , C255);
attr C256 is  additiveFAF
means
:L163: (for B177 being (Vector of C254) holds ( FunctionalFAF (C256 , B177) ) is  additive);
attr C256 is  additiveSAF
means
:L164: (for B178 being (Vector of C255) holds ( FunctionalSAF (C256 , B178) ) is  additive);
end;
definition
let C257 being non  empty multMagma;
let C258 , C259 being non  empty VectSpStr over C257;
let C260 being (Form of C258 , C259);
attr C260 is  homogeneousFAF
means
:L166: (for B179 being (Vector of C258) holds ( FunctionalFAF (C260 , B179) ) is  homogeneous);
attr C260 is  homogeneousSAF
means
:L167: (for B180 being (Vector of C259) holds ( FunctionalSAF (C260 , B180) ) is  homogeneous);
end;
registration
let C261 being  right_zeroed non  empty addLoopStr;
let C262 , C263 being non  empty VectSpStr over C261;
cluster ( NulForm (C262 , C263) ) ->  additiveFAF;
coherence
proof
let C264 being (Vector of C262);
L169: ( FunctionalFAF (( NulForm (C262 , C263) ) , C264) ) = ( 0Functional C263 ) by L94;
thus L170: thesis by L169;
end;
cluster ( NulForm (C262 , C263) ) ->  additiveSAF;
coherence
proof
let C265 being (Vector of C263);
L171: ( FunctionalSAF (( NulForm (C262 , C263) ) , C265) ) = ( 0Functional C262 ) by L98;
thus L172: thesis by L171;
end;
end;
registration
let C266 being  right_zeroed non  empty addLoopStr;
let C267 , C268 being non  empty VectSpStr over C266;
cluster  additiveFAF  additiveSAF for (Form of C267 , C268);
existence
proof
take ( NulForm (C267 , C268) );
thus L174: thesis;
end;
end;
registration
let C269 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C270 , C271 being non  empty VectSpStr over C269;
cluster ( NulForm (C270 , C271) ) ->  homogeneousFAF;
coherence
proof
let C272 being (Vector of C270);
L176: ( FunctionalFAF (( NulForm (C270 , C271) ) , C272) ) = ( 0Functional C271 ) by L94;
thus L177: thesis by L176;
end;
cluster ( NulForm (C270 , C271) ) ->  homogeneousSAF;
coherence
proof
let C273 being (Vector of C271);
L178: ( FunctionalSAF (( NulForm (C270 , C271) ) , C273) ) = ( 0Functional C270 ) by L98;
thus L179: thesis by L178;
end;
end;
registration
let C274 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C275 , C276 being non  empty VectSpStr over C274;
cluster  additiveFAF  homogeneousFAF  additiveSAF  homogeneousSAF for (Form of C275 , C276);
existence
proof
take ( NulForm (C275 , C276) );
thus L181: thesis;
end;
end;
definition
let C277 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C278 , C279 being non  empty VectSpStr over C277;
mode bilinear-Form of C278 , C279
 is  additiveSAF  homogeneousSAF  additiveFAF  homogeneousFAF (Form of C278 , C279);
end;
registration
let C280 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C281 , C282 being non  empty VectSpStr over C280;
let C283 being  additiveFAF (Form of C281 , C282);
let C284 being (Vector of C281);
cluster ( FunctionalFAF (C283 , C284) ) ->  additive;
coherence by L163;
end;
registration
let C285 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C286 , C287 being non  empty VectSpStr over C285;
let C288 being  additiveSAF (Form of C286 , C287);
let C289 being (Vector of C287);
cluster ( FunctionalSAF (C288 , C289) ) ->  additive;
coherence by L164;
end;
registration
let C290 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C291 , C292 being non  empty VectSpStr over C290;
let C293 being  homogeneousFAF (Form of C291 , C292);
let C294 being (Vector of C291);
cluster ( FunctionalFAF (C293 , C294) ) ->  homogeneous;
coherence by L166;
end;
registration
let C295 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C296 , C297 being non  empty VectSpStr over C295;
let C298 being  homogeneousSAF (Form of C296 , C297);
let C299 being (Vector of C297);
cluster ( FunctionalSAF (C298 , C299) ) ->  homogeneous;
coherence by L167;
end;
registration
let C300 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C301 , C302 being non  empty VectSpStr over C300;
let C303 being (Functional of C301);
let C304 being  additive (Functional of C302);
cluster ( FormFunctional (C303 , C304) ) ->  additiveFAF;
coherence
proof
let C305 being (Vector of C301);
set D30 = ( FormFunctional (C303 , C304) );
set D31 = ( FunctionalFAF (D30 , C305) );
let C306 , C307 being (Vector of C302);
L188: D31 = ( ( C303 . C305 ) * C304 ) by L155;
thus L189: ( D31 . ( C306 + C307 ) ) = ( ( C303 . C305 ) * ( C304 . ( C306 + C307 ) ) ) by L188 , HAHNBAN1:def 6
.= ( ( C303 . C305 ) * ( ( C304 . C306 ) + ( C304 . C307 ) ) ) by VECTSP_1:def 20
.= ( ( ( C303 . C305 ) * ( C304 . C306 ) ) + ( ( C303 . C305 ) * ( C304 . C307 ) ) ) by VECTSP_1:def 2
.= ( ( ( C303 . C305 ) * ( C304 . C306 ) ) + ( D31 . C307 ) ) by L188 , HAHNBAN1:def 6
.= ( ( D31 . C306 ) + ( D31 . C307 ) ) by L188 , HAHNBAN1:def 6;
end;
end;
registration
let C308 being  add-associative  right_zeroed  right_complementable  commutative  right-distributive non  empty doubleLoopStr;
let C309 , C310 being non  empty VectSpStr over C308;
let C311 being  additive (Functional of C309);
let C312 being (Functional of C310);
cluster ( FormFunctional (C311 , C312) ) ->  additiveSAF;
coherence
proof
let C313 being (Vector of C310);
set D32 = ( FormFunctional (C311 , C312) );
set D33 = ( FunctionalSAF (D32 , C313) );
L191: D33 = ( ( C312 . C313 ) * C311 ) by L159;
thus L192: thesis by L191;
end;
end;
registration
let C314 being  add-associative  right_zeroed  right_complementable  commutative  associative  right-distributive non  empty doubleLoopStr;
let C315 , C316 being non  empty VectSpStr over C314;
let C317 being (Functional of C315);
let C318 being  homogeneous (Functional of C316);
cluster ( FormFunctional (C317 , C318) ) ->  homogeneousFAF;
coherence
proof
let C319 being (Vector of C315);
set D34 = ( FormFunctional (C317 , C318) );
set D35 = ( FunctionalFAF (D34 , C319) );
let C320 being (Vector of C316);
let C321 being (Scalar of C316);
L194: D35 = ( ( C317 . C319 ) * C318 ) by L155;
thus L195: ( D35 . ( C321 * C320 ) ) = ( ( C317 . C319 ) * ( C318 . ( C321 * C320 ) ) ) by L194 , HAHNBAN1:def 6
.= ( ( C317 . C319 ) * ( C321 * ( C318 . C320 ) ) ) by HAHNBAN1:def 8
.= ( C321 * ( ( C317 . C319 ) * ( C318 . C320 ) ) ) by GROUP_1:def 3
.= ( C321 * ( D35 . C320 ) ) by L194 , HAHNBAN1:def 6;
end;
end;
registration
let C322 being  add-associative  right_zeroed  right_complementable  commutative  associative  right-distributive non  empty doubleLoopStr;
let C323 , C324 being non  empty VectSpStr over C322;
let C325 being  homogeneous (Functional of C323);
let C326 being (Functional of C324);
cluster ( FormFunctional (C325 , C326) ) ->  homogeneousSAF;
coherence
proof
let C327 being (Vector of C324);
set D36 = ( FormFunctional (C325 , C326) );
set D37 = ( FunctionalSAF (D36 , C327) );
let C328 being (Vector of C323);
let C329 being (Scalar of C323);
L197: D37 = ( ( C326 . C327 ) * C325 ) by L159;
thus L198: ( D37 . ( C329 * C328 ) ) = ( ( C326 . C327 ) * ( C325 . ( C329 * C328 ) ) ) by L197 , HAHNBAN1:def 6
.= ( ( C326 . C327 ) * ( C329 * ( C325 . C328 ) ) ) by HAHNBAN1:def 8
.= ( C329 * ( ( C326 . C327 ) * ( C325 . C328 ) ) ) by GROUP_1:def 3
.= ( C329 * ( D37 . C328 ) ) by L197 , HAHNBAN1:def 6;
end;
end;
registration
let C330 being non  degenerated non  empty doubleLoopStr;
let C331 being non  trivial VectSpStr over C330;
let C332 being non  empty VectSpStr over C330;
let C333 being (Functional of C331);
let C334 being (Functional of C332);
cluster ( FormFunctional (C333 , C334) ) -> non  trivial;
coherence
proof
set D38 = ( FormFunctional (C333 , C334) );
set D39 = the (Vector of C332);
consider C335 being (Vector of C331) such that L200: C335 <> ( 0. C331 ) by STRUCT_0:def 18;
L201: [ ( 0. C331 ) , ( 0. C332 ) ] <> [ C335 , D39 ] by L200 , XTUPLE_0:1;
L202: ( dom D38 ) = [: (the carrier of C331) , (the carrier of C332) :] by FUNCT_2:def 1;
L203: ([ [ ( 0. C331 ) , ( 0. C332 ) ] , ( D38 . (( 0. C331 ) , ( 0. C332 )) ) ] in D38 & [ [ C335 , D39 ] , ( D38 . (C335 , D39) ) ] in D38) by L202 , FUNCT_1:1;
assume L204: D38 is  trivial;
per cases  by L204 , ZFMISC_1:131;
suppose L205: D38 = ( {} );

thus L206: contradiction by L205;
end;
suppose L207: (ex B181 being set st D38 = { B181 });

consider C336 being set such that L208: D38 = { C336 } by L207;
L209: ([ [ ( 0. C331 ) , ( 0. C332 ) ] , ( D38 . (( 0. C331 ) , ( 0. C332 )) ) ] = C336 & C336 = [ [ C335 , D39 ] , ( D38 . (C335 , D39) ) ]) by L203 , L208 , TARSKI:def 1;
thus L210: contradiction by L209 , L201 , XTUPLE_0:1;
end;
end;
end;
registration
let C337 being non  degenerated non  empty doubleLoopStr;
let C338 being non  empty VectSpStr over C337;
let C339 being non  trivial VectSpStr over C337;
let C340 being (Functional of C338);
let C341 being (Functional of C339);
cluster ( FormFunctional (C340 , C341) ) -> non  trivial;
coherence
proof
set D40 = ( FormFunctional (C340 , C341) );
set D41 = the (Vector of C338);
consider C342 being (Vector of C339) such that L213: C342 <> ( 0. C339 ) by STRUCT_0:def 18;
L214: [ ( 0. C338 ) , ( 0. C339 ) ] <> [ D41 , C342 ] by L213 , XTUPLE_0:1;
L215: ( dom D40 ) = [: (the carrier of C338) , (the carrier of C339) :] by FUNCT_2:def 1;
L216: ([ [ ( 0. C338 ) , ( 0. C339 ) ] , ( D40 . (( 0. C338 ) , ( 0. C339 )) ) ] in D40 & [ [ D41 , C342 ] , ( D40 . (D41 , C342) ) ] in D40) by L215 , FUNCT_1:1;
assume L217: D40 is  trivial;
per cases  by L217 , ZFMISC_1:131;
suppose L218: D40 = ( {} );

thus L219: contradiction by L218;
end;
suppose L220: (ex B182 being set st D40 = { B182 });

consider C343 being set such that L221: D40 = { C343 } by L220;
L222: ([ [ ( 0. C338 ) , ( 0. C339 ) ] , ( D40 . (( 0. C338 ) , ( 0. C339 )) ) ] = C343 & C343 = [ [ D41 , C342 ] , ( D40 . (D41 , C342) ) ]) by L216 , L221 , TARSKI:def 1;
thus L223: contradiction by L222 , L214 , XTUPLE_0:1;
end;
end;
end;
registration
let C344 being Field;
let C345 , C346 being non  trivial (VectSp of C344);
let C347 being non  constant  0-preserving (Functional of C345);
let C348 being non  constant  0-preserving (Functional of C346);
cluster ( FormFunctional (C347 , C348) ) -> non  constant;
coherence
proof
set D42 = ( FormFunctional (C347 , C348) );
consider C349 being (Vector of C345) such that L226: C349 <> ( 0. C345 ) and L227: ( C347 . C349 ) <> ( 0. C344 ) by VECTSP10:28;
consider C350 being (Vector of C346) such that L228: C350 <> ( 0. C346 ) and L229: ( C348 . C350 ) <> ( 0. C344 ) by VECTSP10:28;
L230: ( D42 . (C349 , C350) ) = ( ( C347 . C349 ) * ( C348 . C350 ) ) by L134;
L231: (( dom D42 ) = [: (the carrier of C345) , (the carrier of C346) :] & ( D42 . (C349 , C350) ) <> ( 0. C344 )) by L230 , L227 , L229 , FUNCT_2:def 1 , VECTSP_1:12;
L232: ( D42 . (( 0. C345 ) , ( 0. C346 )) ) = ( ( C347 . ( 0. C345 ) ) * ( C348 . ( 0. C346 ) ) ) by L134
.= ( ( 0. C344 ) * ( C348 . ( 0. C346 ) ) ) by HAHNBAN1:def 9
.= ( 0. C344 ) by VECTSP_1:7;
thus L233: thesis by L232 , L231 , BINOP_1:19;
end;
end;
registration
let C351 being Field;
let C352 , C353 being non  trivial (VectSp of C351);
cluster non  trivial non  constant  additiveFAF  homogeneousFAF  additiveSAF  homogeneousSAF for (Form of C352 , C353);
existence
proof
set D43 = the non  constant non  trivial (linear-Functional of C352);
set D44 = the non  constant non  trivial (linear-Functional of C353);
take ( FormFunctional (D43 , D44) );
thus L235: thesis;
end;
end;
registration
let C354 being  Abelian  add-associative  right_zeroed non  empty addLoopStr;
let C355 , C356 being non  empty VectSpStr over C354;
let C357 , C358 being  additiveSAF (Form of C355 , C356);
cluster ( C357 + C358 ) ->  additiveSAF;
correctness
proof
let C359 being (Vector of C356);
set D45 = ( FunctionalSAF (( C357 + C358 ) , C359) );
set D46 = ( FunctionalSAF (C357 , C359) );
set D47 = ( FunctionalSAF (C358 , C359) );
let C360 , C361 being (Vector of C355);
L237: D46 is  additive by L164;
L238: D47 is  additive by L164;
thus L239: ( D45 . ( C360 + C361 ) ) = ( ( D46 + D47 ) . ( C360 + C361 ) ) by L102
.= ( ( D46 . ( C360 + C361 ) ) + ( D47 . ( C360 + C361 ) ) ) by HAHNBAN1:def 3
.= ( ( ( D46 . C360 ) + ( D46 . C361 ) ) + ( D47 . ( C360 + C361 ) ) ) by L237 , VECTSP_1:def 20
.= ( ( ( D46 . C360 ) + ( D46 . C361 ) ) + ( ( D47 . C360 ) + ( D47 . C361 ) ) ) by L238 , VECTSP_1:def 20
.= ( ( ( ( D46 . C360 ) + ( D46 . C361 ) ) + ( D47 . C360 ) ) + ( D47 . C361 ) ) by RLVECT_1:def 3
.= ( ( ( ( D46 . C360 ) + ( D47 . C360 ) ) + ( D46 . C361 ) ) + ( D47 . C361 ) ) by RLVECT_1:def 3
.= ( ( ( ( D46 + D47 ) . C360 ) + ( D46 . C361 ) ) + ( D47 . C361 ) ) by HAHNBAN1:def 3
.= ( ( ( D46 + D47 ) . C360 ) + ( ( D46 . C361 ) + ( D47 . C361 ) ) ) by RLVECT_1:def 3
.= ( ( ( D46 + D47 ) . C360 ) + ( ( D46 + D47 ) . C361 ) ) by HAHNBAN1:def 3
.= ( ( D45 . C360 ) + ( ( D46 + D47 ) . C361 ) ) by L102
.= ( ( D45 . C360 ) + ( D45 . C361 ) ) by L102;
end;
end;
registration
let C362 being  Abelian  add-associative  right_zeroed non  empty addLoopStr;
let C363 , C364 being non  empty VectSpStr over C362;
let C365 , C366 being  additiveFAF (Form of C363 , C364);
cluster ( C365 + C366 ) ->  additiveFAF;
correctness
proof
let C367 being (Vector of C363);
set D48 = ( FunctionalFAF (( C365 + C366 ) , C367) );
set D49 = ( FunctionalFAF (C365 , C367) );
set D50 = ( FunctionalFAF (C366 , C367) );
let C368 , C369 being (Vector of C364);
L241: D49 is  additive by L163;
L242: D50 is  additive by L163;
thus L243: ( D48 . ( C368 + C369 ) ) = ( ( D49 + D50 ) . ( C368 + C369 ) ) by L106
.= ( ( D49 . ( C368 + C369 ) ) + ( D50 . ( C368 + C369 ) ) ) by HAHNBAN1:def 3
.= ( ( ( D49 . C368 ) + ( D49 . C369 ) ) + ( D50 . ( C368 + C369 ) ) ) by L241 , VECTSP_1:def 20
.= ( ( ( D49 . C368 ) + ( D49 . C369 ) ) + ( ( D50 . C368 ) + ( D50 . C369 ) ) ) by L242 , VECTSP_1:def 20
.= ( ( ( ( D49 . C368 ) + ( D49 . C369 ) ) + ( D50 . C368 ) ) + ( D50 . C369 ) ) by RLVECT_1:def 3
.= ( ( ( ( D49 . C368 ) + ( D50 . C368 ) ) + ( D49 . C369 ) ) + ( D50 . C369 ) ) by RLVECT_1:def 3
.= ( ( ( ( D49 + D50 ) . C368 ) + ( D49 . C369 ) ) + ( D50 . C369 ) ) by HAHNBAN1:def 3
.= ( ( ( D49 + D50 ) . C368 ) + ( ( D49 . C369 ) + ( D50 . C369 ) ) ) by RLVECT_1:def 3
.= ( ( ( D49 + D50 ) . C368 ) + ( ( D49 + D50 ) . C369 ) ) by HAHNBAN1:def 3
.= ( ( D48 . C368 ) + ( ( D49 + D50 ) . C369 ) ) by L106
.= ( ( D48 . C368 ) + ( D48 . C369 ) ) by L106;
end;
end;
registration
let C370 being  right-distributive  right_zeroed non  empty doubleLoopStr;
let C371 , C372 being non  empty VectSpStr over C370;
let C373 being  additiveSAF (Form of C371 , C372);
let C374 being (Element of C370);
cluster ( C374 * C373 ) ->  additiveSAF;
correctness
proof
let C375 being (Vector of C372);
set D51 = ( FunctionalSAF (( C374 * C373 ) , C375) );
set D52 = ( FunctionalSAF (C373 , C375) );
let C376 , C377 being (Vector of C371);
L245: D52 is  additive by L164;
thus L246: ( D51 . ( C376 + C377 ) ) = ( ( C374 * D52 ) . ( C376 + C377 ) ) by L110
.= ( C374 * ( D52 . ( C376 + C377 ) ) ) by HAHNBAN1:def 6
.= ( C374 * ( ( D52 . C376 ) + ( D52 . C377 ) ) ) by L245 , VECTSP_1:def 20
.= ( ( C374 * ( D52 . C376 ) ) + ( C374 * ( D52 . C377 ) ) ) by VECTSP_1:def 2
.= ( ( ( C374 * D52 ) . C376 ) + ( C374 * ( D52 . C377 ) ) ) by HAHNBAN1:def 6
.= ( ( ( C374 * D52 ) . C376 ) + ( ( C374 * D52 ) . C377 ) ) by HAHNBAN1:def 6
.= ( ( D51 . C376 ) + ( ( C374 * D52 ) . C377 ) ) by L110
.= ( ( D51 . C376 ) + ( D51 . C377 ) ) by L110;
end;
end;
registration
let C378 being  right-distributive  right_zeroed non  empty doubleLoopStr;
let C379 , C380 being non  empty VectSpStr over C378;
let C381 being  additiveFAF (Form of C379 , C380);
let C382 being (Element of C378);
cluster ( C382 * C381 ) ->  additiveFAF;
correctness
proof
let C383 being (Vector of C379);
set D53 = ( FunctionalFAF (( C382 * C381 ) , C383) );
set D54 = ( FunctionalFAF (C381 , C383) );
let C384 , C385 being (Vector of C380);
L248: D54 is  additive by L163;
thus L249: ( D53 . ( C384 + C385 ) ) = ( ( C382 * D54 ) . ( C384 + C385 ) ) by L114
.= ( C382 * ( D54 . ( C384 + C385 ) ) ) by HAHNBAN1:def 6
.= ( C382 * ( ( D54 . C384 ) + ( D54 . C385 ) ) ) by L248 , VECTSP_1:def 20
.= ( ( C382 * ( D54 . C384 ) ) + ( C382 * ( D54 . C385 ) ) ) by VECTSP_1:def 2
.= ( ( ( C382 * D54 ) . C384 ) + ( C382 * ( D54 . C385 ) ) ) by HAHNBAN1:def 6
.= ( ( ( C382 * D54 ) . C384 ) + ( ( C382 * D54 ) . C385 ) ) by HAHNBAN1:def 6
.= ( ( D53 . C384 ) + ( ( C382 * D54 ) . C385 ) ) by L114
.= ( ( D53 . C384 ) + ( D53 . C385 ) ) by L114;
end;
end;
registration
let C386 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C387 , C388 being non  empty VectSpStr over C386;
let C389 being  additiveSAF (Form of C387 , C388);
cluster ( - C389 ) ->  additiveSAF;
correctness
proof
let C390 being (Vector of C388);
set D55 = ( FunctionalSAF (( - C389 ) , C390) );
set D56 = ( FunctionalSAF (C389 , C390) );
let C391 , C392 being (Vector of C387);
L251: D56 is  additive by L164;
thus L252: ( D55 . ( C391 + C392 ) ) = ( ( - D56 ) . ( C391 + C392 ) ) by L118
.= ( - ( D56 . ( C391 + C392 ) ) ) by HAHNBAN1:def 4
.= ( - ( ( D56 . C391 ) + ( D56 . C392 ) ) ) by L251 , VECTSP_1:def 20
.= ( ( - ( D56 . C391 ) ) - ( D56 . C392 ) ) by RLVECT_1:30
.= ( ( ( - D56 ) . C391 ) - ( D56 . C392 ) ) by HAHNBAN1:def 4
.= ( ( ( - D56 ) . C391 ) + ( - ( D56 . C392 ) ) ) by RLVECT_1:def 11
.= ( ( ( - D56 ) . C391 ) + ( ( - D56 ) . C392 ) ) by HAHNBAN1:def 4
.= ( ( D55 . C391 ) + ( ( - D56 ) . C392 ) ) by L118
.= ( ( D55 . C391 ) + ( D55 . C392 ) ) by L118;
end;
end;
registration
let C393 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C394 , C395 being non  empty VectSpStr over C393;
let C396 being  additiveFAF (Form of C394 , C395);
cluster ( - C396 ) ->  additiveFAF;
correctness
proof
let C397 being (Vector of C394);
set D57 = ( FunctionalFAF (( - C396 ) , C397) );
set D58 = ( FunctionalFAF (C396 , C397) );
let C398 , C399 being (Vector of C395);
L254: D58 is  additive by L163;
thus L255: ( D57 . ( C398 + C399 ) ) = ( ( - D58 ) . ( C398 + C399 ) ) by L122
.= ( - ( D58 . ( C398 + C399 ) ) ) by HAHNBAN1:def 4
.= ( - ( ( D58 . C398 ) + ( D58 . C399 ) ) ) by L254 , VECTSP_1:def 20
.= ( ( - ( D58 . C398 ) ) - ( D58 . C399 ) ) by RLVECT_1:30
.= ( ( ( - D58 ) . C398 ) - ( D58 . C399 ) ) by HAHNBAN1:def 4
.= ( ( ( - D58 ) . C398 ) + ( - ( D58 . C399 ) ) ) by RLVECT_1:def 11
.= ( ( ( - D58 ) . C398 ) + ( ( - D58 ) . C399 ) ) by HAHNBAN1:def 4
.= ( ( D57 . C398 ) + ( ( - D58 ) . C399 ) ) by L122
.= ( ( D57 . C398 ) + ( D57 . C399 ) ) by L122;
end;
end;
registration
let C400 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C401 , C402 being non  empty VectSpStr over C400;
let C403 , C404 being  additiveSAF (Form of C401 , C402);
cluster ( C403 - C404 ) ->  additiveSAF;
correctness;
end;
registration
let C405 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C406 , C407 being non  empty VectSpStr over C405;
let C408 , C409 being  additiveFAF (Form of C406 , C407);
cluster ( C408 - C409 ) ->  additiveFAF;
correctness;
end;
registration
let C410 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C411 , C412 being non  empty VectSpStr over C410;
let C413 , C414 being  homogeneousSAF (Form of C411 , C412);
cluster ( C413 + C414 ) ->  homogeneousSAF;
correctness
proof
let C415 being (Vector of C412);
set D59 = ( FunctionalSAF (( C413 + C414 ) , C415) );
set D60 = ( FunctionalSAF (C413 , C415) );
set D61 = ( FunctionalSAF (C414 , C415) );
let C416 being (Vector of C411);
let C417 being (Scalar of C411);
thus L259: ( D59 . ( C417 * C416 ) ) = ( ( D60 + D61 ) . ( C417 * C416 ) ) by L102
.= ( ( D60 . ( C417 * C416 ) ) + ( D61 . ( C417 * C416 ) ) ) by HAHNBAN1:def 3
.= ( ( C417 * ( D60 . C416 ) ) + ( D61 . ( C417 * C416 ) ) ) by HAHNBAN1:def 8
.= ( ( C417 * ( D60 . C416 ) ) + ( C417 * ( D61 . C416 ) ) ) by HAHNBAN1:def 8
.= ( C417 * ( ( D60 . C416 ) + ( D61 . C416 ) ) ) by VECTSP_1:def 2
.= ( C417 * ( ( D60 + D61 ) . C416 ) ) by HAHNBAN1:def 3
.= ( C417 * ( D59 . C416 ) ) by L102;
end;
end;
registration
let C418 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C419 , C420 being non  empty VectSpStr over C418;
let C421 , C422 being  homogeneousFAF (Form of C419 , C420);
cluster ( C421 + C422 ) ->  homogeneousFAF;
correctness
proof
let C423 being (Vector of C419);
set D62 = ( FunctionalFAF (( C421 + C422 ) , C423) );
set D63 = ( FunctionalFAF (C421 , C423) );
set D64 = ( FunctionalFAF (C422 , C423) );
let C424 being (Vector of C420);
let C425 being (Scalar of C419);
thus L261: ( D62 . ( C425 * C424 ) ) = ( ( D63 + D64 ) . ( C425 * C424 ) ) by L106
.= ( ( D63 . ( C425 * C424 ) ) + ( D64 . ( C425 * C424 ) ) ) by HAHNBAN1:def 3
.= ( ( C425 * ( D63 . C424 ) ) + ( D64 . ( C425 * C424 ) ) ) by HAHNBAN1:def 8
.= ( ( C425 * ( D63 . C424 ) ) + ( C425 * ( D64 . C424 ) ) ) by HAHNBAN1:def 8
.= ( C425 * ( ( D63 . C424 ) + ( D64 . C424 ) ) ) by VECTSP_1:def 2
.= ( C425 * ( ( D63 + D64 ) . C424 ) ) by HAHNBAN1:def 3
.= ( C425 * ( D62 . C424 ) ) by L106;
end;
end;
registration
let C426 being  add-associative  right_zeroed  right_complementable  associative  commutative  right-distributive non  empty doubleLoopStr;
let C427 , C428 being non  empty VectSpStr over C426;
let C429 being  homogeneousSAF (Form of C427 , C428);
let C430 being (Element of C426);
cluster ( C430 * C429 ) ->  homogeneousSAF;
correctness
proof
let C431 being (Vector of C428);
set D65 = ( FunctionalSAF (( C430 * C429 ) , C431) );
set D66 = ( FunctionalSAF (C429 , C431) );
let C432 being (Vector of C427);
let C433 being (Scalar of C427);
thus L263: ( D65 . ( C433 * C432 ) ) = ( ( C430 * D66 ) . ( C433 * C432 ) ) by L110
.= ( C430 * ( D66 . ( C433 * C432 ) ) ) by HAHNBAN1:def 6
.= ( C430 * ( C433 * ( D66 . C432 ) ) ) by HAHNBAN1:def 8
.= ( C433 * ( C430 * ( D66 . C432 ) ) ) by GROUP_1:def 3
.= ( C433 * ( ( C430 * D66 ) . C432 ) ) by HAHNBAN1:def 6
.= ( C433 * ( D65 . C432 ) ) by L110;
end;
end;
registration
let C434 being  add-associative  right_zeroed  right_complementable  associative  commutative  right-distributive non  empty doubleLoopStr;
let C435 , C436 being non  empty VectSpStr over C434;
let C437 being  homogeneousFAF (Form of C435 , C436);
let C438 being (Element of C434);
cluster ( C438 * C437 ) ->  homogeneousFAF;
correctness
proof
let C439 being (Vector of C435);
set D67 = ( FunctionalFAF (( C438 * C437 ) , C439) );
set D68 = ( FunctionalFAF (C437 , C439) );
let C440 being (Vector of C436);
let C441 being (Scalar of C435);
thus L265: ( D67 . ( C441 * C440 ) ) = ( ( C438 * D68 ) . ( C441 * C440 ) ) by L114
.= ( C438 * ( D68 . ( C441 * C440 ) ) ) by HAHNBAN1:def 6
.= ( C438 * ( C441 * ( D68 . C440 ) ) ) by HAHNBAN1:def 8
.= ( C441 * ( C438 * ( D68 . C440 ) ) ) by GROUP_1:def 3
.= ( C441 * ( ( C438 * D68 ) . C440 ) ) by HAHNBAN1:def 6
.= ( C441 * ( D67 . C440 ) ) by L114;
end;
end;
registration
let C442 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C443 , C444 being non  empty VectSpStr over C442;
let C445 being  homogeneousSAF (Form of C443 , C444);
cluster ( - C445 ) ->  homogeneousSAF;
correctness
proof
let C446 being (Vector of C444);
set D69 = ( FunctionalSAF (( - C445 ) , C446) );
set D70 = ( FunctionalSAF (C445 , C446) );
let C447 being (Vector of C443);
let C448 being (Scalar of C443);
thus L267: ( D69 . ( C448 * C447 ) ) = ( ( - D70 ) . ( C448 * C447 ) ) by L118
.= ( - ( D70 . ( C448 * C447 ) ) ) by HAHNBAN1:def 4
.= ( - ( C448 * ( D70 . C447 ) ) ) by HAHNBAN1:def 8
.= ( C448 * ( - ( D70 . C447 ) ) ) by VECTSP_1:8
.= ( C448 * ( ( - D70 ) . C447 ) ) by HAHNBAN1:def 4
.= ( C448 * ( D69 . C447 ) ) by L118;
end;
end;
registration
let C449 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C450 , C451 being non  empty VectSpStr over C449;
let C452 being  homogeneousFAF (Form of C450 , C451);
cluster ( - C452 ) ->  homogeneousFAF;
correctness
proof
let C453 being (Vector of C450);
set D71 = ( FunctionalFAF (( - C452 ) , C453) );
set D72 = ( FunctionalFAF (C452 , C453) );
let C454 being (Vector of C451);
let C455 being (Scalar of C451);
thus L269: ( D71 . ( C455 * C454 ) ) = ( ( - D72 ) . ( C455 * C454 ) ) by L122
.= ( - ( D72 . ( C455 * C454 ) ) ) by HAHNBAN1:def 4
.= ( - ( C455 * ( D72 . C454 ) ) ) by HAHNBAN1:def 8
.= ( C455 * ( - ( D72 . C454 ) ) ) by VECTSP_1:8
.= ( C455 * ( ( - D72 ) . C454 ) ) by HAHNBAN1:def 4
.= ( C455 * ( D71 . C454 ) ) by L122;
end;
end;
registration
let C456 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C457 , C458 being non  empty VectSpStr over C456;
let C459 , C460 being  homogeneousSAF (Form of C457 , C458);
cluster ( C459 - C460 ) ->  homogeneousSAF;
correctness;
end;
registration
let C461 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C462 , C463 being non  empty VectSpStr over C461;
let C464 , C465 being  homogeneousFAF (Form of C462 , C463);
cluster ( C464 - C465 ) ->  homogeneousFAF;
correctness;
end;
theorem
L273: (for B183 being non  empty addLoopStr holds (for B184 , B185 being non  empty VectSpStr over B183 holds (for B186 , B187 being (Vector of B184) holds (for B188 being (Vector of B185) holds (for B189 being (Form of B184 , B185) holds (B189 is  additiveSAF implies ( B189 . (( B186 + B187 ) , B188) ) = ( ( B189 . (B186 , B188) ) + ( B189 . (B187 , B188) ) )))))))
proof
let C466 being non  empty addLoopStr;
let C467 , C468 being non  empty VectSpStr over C466;
let C469 , C470 being (Vector of C467);
let C471 being (Vector of C468);
let C472 being (Form of C467 , C468);
set D73 = ( FunctionalSAF (C472 , C471) );
assume L274: C472 is  additiveSAF;
L275: D73 is  additive by L274 , L164;
thus L276: ( C472 . (( C469 + C470 ) , C471) ) = ( D73 . ( C469 + C470 ) ) by L89
.= ( ( D73 . C469 ) + ( D73 . C470 ) ) by L275 , VECTSP_1:def 20
.= ( ( C472 . (C469 , C471) ) + ( D73 . C470 ) ) by L89
.= ( ( C472 . (C469 , C471) ) + ( C472 . (C470 , C471) ) ) by L89;
end;
theorem
L277: (for B190 being non  empty addLoopStr holds (for B191 , B192 being non  empty VectSpStr over B190 holds (for B193 being (Vector of B191) holds (for B194 , B195 being (Vector of B192) holds (for B196 being (Form of B191 , B192) holds (B196 is  additiveFAF implies ( B196 . (B193 , ( B194 + B195 )) ) = ( ( B196 . (B193 , B194) ) + ( B196 . (B193 , B195) ) )))))))
proof
let C473 being non  empty addLoopStr;
let C474 , C475 being non  empty VectSpStr over C473;
let C476 being (Vector of C474);
let C477 , C478 being (Vector of C475);
let C479 being (Form of C474 , C475);
set D74 = ( FunctionalFAF (C479 , C476) );
assume L278: C479 is  additiveFAF;
L279: D74 is  additive by L278 , L163;
thus L280: ( C479 . (C476 , ( C477 + C478 )) ) = ( D74 . ( C477 + C478 ) ) by L84
.= ( ( D74 . C477 ) + ( D74 . C478 ) ) by L279 , VECTSP_1:def 20
.= ( ( C479 . (C476 , C477) ) + ( D74 . C478 ) ) by L84
.= ( ( C479 . (C476 , C477) ) + ( C479 . (C476 , C478) ) ) by L84;
end;
theorem
L281: (for B197 being  right_zeroed non  empty addLoopStr holds (for B198 , B199 being non  empty VectSpStr over B197 holds (for B200 , B201 being (Vector of B198) holds (for B202 , B203 being (Vector of B199) holds (for B204 being  additiveSAF  additiveFAF (Form of B198 , B199) holds ( B204 . (( B200 + B201 ) , ( B202 + B203 )) ) = ( ( ( B204 . (B200 , B202) ) + ( B204 . (B200 , B203) ) ) + ( ( B204 . (B201 , B202) ) + ( B204 . (B201 , B203) ) ) ))))))
proof
let C480 being  right_zeroed non  empty addLoopStr;
let C481 , C482 being non  empty VectSpStr over C480;
let C483 , C484 being (Vector of C481);
let C485 , C486 being (Vector of C482);
let C487 being  additiveSAF  additiveFAF (Form of C481 , C482);
set D75 = ( C487 . (C483 , C485) );
set D76 = ( C487 . (C483 , C486) );
set D77 = ( C487 . (C484 , C485) );
set D78 = ( C487 . (C484 , C486) );
thus L282: ( C487 . (( C483 + C484 ) , ( C485 + C486 )) ) = ( ( C487 . (C483 , ( C485 + C486 )) ) + ( C487 . (C484 , ( C485 + C486 )) ) ) by L273
.= ( ( D75 + D76 ) + ( C487 . (C484 , ( C485 + C486 )) ) ) by L277
.= ( ( D75 + D76 ) + ( D77 + D78 ) ) by L277;
end;
theorem
L283: (for B205 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for B206 , B207 being  right_zeroed non  empty VectSpStr over B205 holds (for B208 being  additiveFAF (Form of B206 , B207) holds (for B209 being (Vector of B206) holds ( B208 . (B209 , ( 0. B207 )) ) = ( 0. B205 )))))
proof
let C488 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C489 , C490 being  right_zeroed non  empty VectSpStr over C488;
let C491 being  additiveFAF (Form of C489 , C490);
let C492 being (Vector of C489);
L284: ( C491 . (C492 , ( 0. C490 )) ) = ( C491 . (C492 , ( ( 0. C490 ) + ( 0. C490 ) )) ) by RLVECT_1:def 4
.= ( ( C491 . (C492 , ( 0. C490 )) ) + ( C491 . (C492 , ( 0. C490 )) ) ) by L277;
thus L285: thesis by L284 , RLVECT_1:9;
end;
theorem
L286: (for B210 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for B211 , B212 being  right_zeroed non  empty VectSpStr over B210 holds (for B213 being  additiveSAF (Form of B211 , B212) holds (for B214 being (Vector of B212) holds ( B213 . (( 0. B211 ) , B214) ) = ( 0. B210 )))))
proof
let C493 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C494 , C495 being  right_zeroed non  empty VectSpStr over C493;
let C496 being  additiveSAF (Form of C494 , C495);
let C497 being (Vector of C495);
L287: ( C496 . (( 0. C494 ) , C497) ) = ( C496 . (( ( 0. C494 ) + ( 0. C494 ) ) , C497) ) by RLVECT_1:def 4
.= ( ( C496 . (( 0. C494 ) , C497) ) + ( C496 . (( 0. C494 ) , C497) ) ) by L273;
thus L288: thesis by L287 , RLVECT_1:9;
end;
theorem
L289: (for B215 being non  empty multMagma holds (for B216 , B217 being non  empty VectSpStr over B215 holds (for B218 being (Vector of B216) holds (for B219 being (Vector of B217) holds (for B220 being (Element of B215) holds (for B221 being (Form of B216 , B217) holds (B221 is  homogeneousSAF implies ( B221 . (( B220 * B218 ) , B219) ) = ( B220 * ( B221 . (B218 , B219) ) ))))))))
proof
let C498 being non  empty multMagma;
let C499 , C500 being non  empty VectSpStr over C498;
let C501 being (Vector of C499);
let C502 being (Vector of C500);
let C503 being (Element of C498);
let C504 being (Form of C499 , C500);
set D79 = ( FunctionalSAF (C504 , C502) );
assume L290: C504 is  homogeneousSAF;
L291: D79 is  homogeneous by L290 , L167;
thus L292: ( C504 . (( C503 * C501 ) , C502) ) = ( D79 . ( C503 * C501 ) ) by L89
.= ( C503 * ( D79 . C501 ) ) by L291 , HAHNBAN1:def 8
.= ( C503 * ( C504 . (C501 , C502) ) ) by L89;
end;
theorem
L293: (for B222 being non  empty multMagma holds (for B223 , B224 being non  empty VectSpStr over B222 holds (for B225 being (Vector of B223) holds (for B226 being (Vector of B224) holds (for B227 being (Element of B222) holds (for B228 being (Form of B223 , B224) holds (B228 is  homogeneousFAF implies ( B228 . (B225 , ( B227 * B226 )) ) = ( B227 * ( B228 . (B225 , B226) ) ))))))))
proof
let C505 being non  empty multMagma;
let C506 , C507 being non  empty VectSpStr over C505;
let C508 being (Vector of C506);
let C509 being (Vector of C507);
let C510 being (Element of C505);
let C511 being (Form of C506 , C507);
set D80 = ( FunctionalFAF (C511 , C508) );
assume L294: C511 is  homogeneousFAF;
L295: D80 is  homogeneous by L294 , L166;
thus L296: ( C511 . (C508 , ( C510 * C509 )) ) = ( D80 . ( C510 * C509 ) ) by L84
.= ( C510 * ( D80 . C509 ) ) by L295 , HAHNBAN1:def 8
.= ( C510 * ( C511 . (C508 , C509) ) ) by L84;
end;
theorem
L297: (for B229 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr holds (for B230 , B231 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B229 holds (for B232 being  homogeneousSAF (Form of B230 , B231) holds (for B233 being (Vector of B231) holds ( B232 . (( 0. B230 ) , B233) ) = ( 0. B229 )))))
proof
let C512 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr;
let C513 , C514 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C512;
let C515 being  homogeneousSAF (Form of C513 , C514);
let C516 being (Vector of C514);
thus L298: ( C515 . (( 0. C513 ) , C516) ) = ( C515 . (( ( 0. C512 ) * ( 0. C513 ) ) , C516) ) by VECTSP10:1
.= ( ( 0. C512 ) * ( C515 . (( 0. C513 ) , C516) ) ) by L289
.= ( 0. C512 ) by VECTSP_1:7;
end;
theorem
L299: (for B234 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr holds (for B235 , B236 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B234 holds (for B237 being  homogeneousFAF (Form of B235 , B236) holds (for B238 being (Vector of B235) holds ( B237 . (B238 , ( 0. B236 )) ) = ( 0. B234 )))))
proof
let C517 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr;
let C518 , C519 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C517;
let C520 being  homogeneousFAF (Form of C518 , C519);
let C521 being (Vector of C518);
thus L300: ( C520 . (C521 , ( 0. C519 )) ) = ( C520 . (C521 , ( ( 0. C517 ) * ( 0. C519 ) )) ) by VECTSP10:1
.= ( ( 0. C517 ) * ( C520 . (C521 , ( 0. C519 )) ) ) by L293
.= ( 0. C517 ) by VECTSP_1:7;
end;
theorem
L301: (for B239 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B240 , B241 being (VectSp of B239) holds (for B242 , B243 being (Vector of B240) holds (for B244 being (Vector of B241) holds (for B245 being  additiveSAF  homogeneousSAF (Form of B240 , B241) holds ( B245 . (( B242 - B243 ) , B244) ) = ( ( B245 . (B242 , B244) ) - ( B245 . (B243 , B244) ) ))))))
proof
let C522 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C523 , C524 being (VectSp of C522);
let C525 , C526 being (Vector of C523);
let C527 being (Vector of C524);
let C528 being  additiveSAF  homogeneousSAF (Form of C523 , C524);
thus L302: ( C528 . (( C525 - C526 ) , C527) ) = ( C528 . (( C525 + ( - C526 ) ) , C527) ) by RLVECT_1:def 11
.= ( ( C528 . (C525 , C527) ) + ( C528 . (( - C526 ) , C527) ) ) by L273
.= ( ( C528 . (C525 , C527) ) + ( C528 . (( ( - ( 1. C522 ) ) * C526 ) , C527) ) ) by VECTSP_1:14
.= ( ( C528 . (C525 , C527) ) + ( ( - ( 1. C522 ) ) * ( C528 . (C526 , C527) ) ) ) by L289
.= ( ( C528 . (C525 , C527) ) + ( - ( ( 1. C522 ) * ( C528 . (C526 , C527) ) ) ) ) by VECTSP_1:9
.= ( ( C528 . (C525 , C527) ) - ( ( 1. C522 ) * ( C528 . (C526 , C527) ) ) ) by RLVECT_1:def 11
.= ( ( C528 . (C525 , C527) ) - ( C528 . (C526 , C527) ) ) by VECTSP_1:def 8;
end;
theorem
L303: (for B246 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B247 , B248 being (VectSp of B246) holds (for B249 being (Vector of B247) holds (for B250 , B251 being (Vector of B248) holds (for B252 being  additiveFAF  homogeneousFAF (Form of B247 , B248) holds ( B252 . (B249 , ( B250 - B251 )) ) = ( ( B252 . (B249 , B250) ) - ( B252 . (B249 , B251) ) ))))))
proof
let C529 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C530 , C531 being (VectSp of C529);
let C532 being (Vector of C530);
let C533 , C534 being (Vector of C531);
let C535 being  additiveFAF  homogeneousFAF (Form of C530 , C531);
thus L304: ( C535 . (C532 , ( C533 - C534 )) ) = ( C535 . (C532 , ( C533 + ( - C534 ) )) ) by RLVECT_1:def 11
.= ( ( C535 . (C532 , C533) ) + ( C535 . (C532 , ( - C534 )) ) ) by L277
.= ( ( C535 . (C532 , C533) ) + ( C535 . (C532 , ( ( - ( 1. C529 ) ) * C534 )) ) ) by VECTSP_1:14
.= ( ( C535 . (C532 , C533) ) + ( ( - ( 1. C529 ) ) * ( C535 . (C532 , C534) ) ) ) by L293
.= ( ( C535 . (C532 , C533) ) + ( - ( ( 1. C529 ) * ( C535 . (C532 , C534) ) ) ) ) by VECTSP_1:9
.= ( ( C535 . (C532 , C533) ) - ( ( 1. C529 ) * ( C535 . (C532 , C534) ) ) ) by RLVECT_1:def 11
.= ( ( C535 . (C532 , C533) ) - ( C535 . (C532 , C534) ) ) by VECTSP_1:def 8;
end;
theorem
L305: (for B253 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B254 , B255 being (VectSp of B253) holds (for B256 , B257 being (Vector of B254) holds (for B258 , B259 being (Vector of B255) holds (for B260 being (bilinear-Form of B254 , B255) holds ( B260 . (( B256 - B257 ) , ( B258 - B259 )) ) = ( ( ( B260 . (B256 , B258) ) - ( B260 . (B256 , B259) ) ) - ( ( B260 . (B257 , B258) ) - ( B260 . (B257 , B259) ) ) ))))))
proof
let C536 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C537 , C538 being (VectSp of C536);
let C539 , C540 being (Vector of C537);
let C541 , C542 being (Vector of C538);
let C543 being (bilinear-Form of C537 , C538);
set D81 = ( C543 . (C539 , C541) );
set D82 = ( C543 . (C539 , C542) );
set D83 = ( C543 . (C540 , C541) );
set D84 = ( C543 . (C540 , C542) );
thus L306: ( C543 . (( C539 - C540 ) , ( C541 - C542 )) ) = ( ( C543 . (C539 , ( C541 - C542 )) ) - ( C543 . (C540 , ( C541 - C542 )) ) ) by L301
.= ( ( D81 - D82 ) - ( C543 . (C540 , ( C541 - C542 )) ) ) by L303
.= ( ( D81 - D82 ) - ( D83 - D84 ) ) by L303;
end;
theorem
L307: (for B261 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr holds (for B262 , B263 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B261 holds (for B264 , B265 being (Vector of B262) holds (for B266 , B267 being (Vector of B263) holds (for B268 , B269 being (Element of B261) holds (for B270 being (bilinear-Form of B262 , B263) holds ( B270 . (( B264 + ( B268 * B265 ) ) , ( B266 + ( B269 * B267 ) )) ) = ( ( ( B270 . (B264 , B266) ) + ( B269 * ( B270 . (B264 , B267) ) ) ) + ( ( B268 * ( B270 . (B265 , B266) ) ) + ( B268 * ( B269 * ( B270 . (B265 , B267) ) ) ) ) )))))))
proof
let C544 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C545 , C546 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C544;
let C547 , C548 being (Vector of C545);
let C549 , C550 being (Vector of C546);
let C551 , C552 being (Element of C544);
let C553 being (bilinear-Form of C545 , C546);
set D85 = ( C553 . (C547 , C549) );
set D86 = ( C553 . (C547 , C550) );
set D87 = ( C553 . (C548 , C549) );
set D88 = ( C553 . (C548 , C550) );
thus L308: ( C553 . (( C547 + ( C551 * C548 ) ) , ( C549 + ( C552 * C550 ) )) ) = ( ( D85 + ( C553 . (C547 , ( C552 * C550 )) ) ) + ( ( C553 . (( C551 * C548 ) , C549) ) + ( C553 . (( C551 * C548 ) , ( C552 * C550 )) ) ) ) by L281
.= ( ( D85 + ( C552 * D86 ) ) + ( ( C553 . (( C551 * C548 ) , C549) ) + ( C553 . (( C551 * C548 ) , ( C552 * C550 )) ) ) ) by L293
.= ( ( D85 + ( C552 * D86 ) ) + ( ( C551 * D87 ) + ( C553 . (( C551 * C548 ) , ( C552 * C550 )) ) ) ) by L289
.= ( ( D85 + ( C552 * D86 ) ) + ( ( C551 * D87 ) + ( C551 * ( C553 . (C548 , ( C552 * C550 )) ) ) ) ) by L289
.= ( ( D85 + ( C552 * D86 ) ) + ( ( C551 * D87 ) + ( C551 * ( C552 * D88 ) ) ) ) by L293;
end;
theorem
L309: (for B271 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B272 , B273 being (VectSp of B271) holds (for B274 , B275 being (Vector of B272) holds (for B276 , B277 being (Vector of B273) holds (for B278 , B279 being (Element of B271) holds (for B280 being (bilinear-Form of B272 , B273) holds ( B280 . (( B274 - ( B278 * B275 ) ) , ( B276 - ( B279 * B277 ) )) ) = ( ( ( B280 . (B274 , B276) ) - ( B279 * ( B280 . (B274 , B277) ) ) ) - ( ( B278 * ( B280 . (B275 , B276) ) ) - ( B278 * ( B279 * ( B280 . (B275 , B277) ) ) ) ) )))))))
proof
let C554 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C555 , C556 being (VectSp of C554);
let C557 , C558 being (Vector of C555);
let C559 , C560 being (Vector of C556);
let C561 , C562 being (Element of C554);
let C563 being (bilinear-Form of C555 , C556);
set D89 = ( C563 . (C557 , C559) );
set D90 = ( C563 . (C557 , C560) );
set D91 = ( C563 . (C558 , C559) );
set D92 = ( C563 . (C558 , C560) );
thus L310: ( C563 . (( C557 - ( C561 * C558 ) ) , ( C559 - ( C562 * C560 ) )) ) = ( ( D89 - ( C563 . (C557 , ( C562 * C560 )) ) ) - ( ( C563 . (( C561 * C558 ) , C559) ) - ( C563 . (( C561 * C558 ) , ( C562 * C560 )) ) ) ) by L305
.= ( ( D89 - ( C562 * D90 ) ) - ( ( C563 . (( C561 * C558 ) , C559) ) - ( C563 . (( C561 * C558 ) , ( C562 * C560 )) ) ) ) by L293
.= ( ( D89 - ( C562 * D90 ) ) - ( ( C561 * D91 ) - ( C563 . (( C561 * C558 ) , ( C562 * C560 )) ) ) ) by L289
.= ( ( D89 - ( C562 * D90 ) ) - ( ( C561 * D91 ) - ( C561 * ( C563 . (C558 , ( C562 * C560 )) ) ) ) ) by L289
.= ( ( D89 - ( C562 * D90 ) ) - ( ( C561 * D91 ) - ( C561 * ( C562 * D92 ) ) ) ) by L293;
end;
theorem
L311: (for B281 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for B282 , B283 being  right_zeroed non  empty VectSpStr over B281 holds (for B284 being (Form of B282 , B283) holds ((B284 is  additiveFAF or B284 is  additiveSAF) implies (B284 is  constant iff (for B285 being (Vector of B282) holds (for B286 being (Vector of B283) holds ( B284 . (B285 , B286) ) = ( 0. B281 ))))))))
proof
let C564 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C565 , C566 being  right_zeroed non  empty VectSpStr over C564;
let C567 being (Form of C565 , C566);
L312: ( dom C567 ) = [: (the carrier of C565) , (the carrier of C566) :] by FUNCT_2:def 1;
assume L313: (C567 is  additiveFAF or C567 is  additiveSAF);
thus L314:now
assume L315: C567 is  constant;
let C568 being (Vector of C565);
let C569 being (Vector of C566);
per cases  by L313;
suppose L316: C567 is  additiveFAF;

thus L317: ( C567 . (C568 , C569) ) = ( C567 . (C568 , ( 0. C566 )) ) by L312 , L315 , BINOP_1:19
.= ( 0. C564 ) by L316 , L283;
end;
suppose L318: C567 is  additiveSAF;

thus L319: ( C567 . (C568 , C569) ) = ( C567 . (( 0. C565 ) , C569) ) by L312 , L315 , BINOP_1:19
.= ( 0. C564 ) by L318 , L286;
end;
end;
thus L321:now
assume L322: (for B287 being (Vector of C565) holds (for B288 being (Vector of C566) holds ( C567 . (B287 , B288) ) = ( 0. C564 )));
L323:
now
let C570 , C571 being set;
assume that
L324: C570 in ( dom C567 )
and
L325: C571 in ( dom C567 );
consider C572 being (Vector of C565), C573 being (Vector of C566) such that L326: C570 = [ C572 , C573 ] by L324 , DOMAIN_1:1;
consider C574 being (Vector of C565), C575 being (Vector of C566) such that L327: C571 = [ C574 , C575 ] by L325 , DOMAIN_1:1;
thus L328: ( C567 . C570 ) = ( C567 . (C572 , C573) ) by L326
.= ( 0. C564 ) by L322
.= ( C567 . (C574 , C575) ) by L322
.= ( C567 . C571 ) by L327;
end;
thus L329: C567 is  constant by L323 , FUNCT_1:def 10;
end;
end;
begin
definition
let C576 being ZeroStr;
let C577 , C578 being non  empty VectSpStr over C576;
let C579 being (Form of C577 , C578);
func leftker C579 -> (Subset of C577) equals 
{ B289 where B289 is (Vector of C577) : (for B290 being (Vector of C578) holds ( C579 . (B289 , B290) ) = ( 0. C576 )) };
correctness
proof
set D93 = { B291 where B291 is (Vector of C577) : (for B292 being (Vector of C578) holds ( C579 . (B291 , B292) ) = ( 0. C576 )) };
L322: D93 c= (the carrier of C577)
proof
let C580 being set;
assume L323: C580 in D93;
L324: (ex B293 being (Vector of C577) st (B293 = C580 & (for B294 being (Vector of C578) holds ( C579 . (B293 , B294) ) = ( 0. C576 )))) by L323;
thus L325: thesis by L324;
end;
thus L326: thesis by L322;
end;
end;
definition
let C581 being ZeroStr;
let C582 , C583 being non  empty VectSpStr over C581;
let C584 being (Form of C582 , C583);
func rightker C584 -> (Subset of C583) equals 
{ B295 where B295 is (Vector of C583) : (for B296 being (Vector of C582) holds ( C584 . (B296 , B295) ) = ( 0. C581 )) };
correctness
proof
set D94 = { B297 where B297 is (Vector of C583) : (for B298 being (Vector of C582) holds ( C584 . (B298 , B297) ) = ( 0. C581 )) };
L328: D94 c= (the carrier of C583)
proof
let C585 being set;
assume L329: C585 in D94;
L330: (ex B299 being (Vector of C583) st (B299 = C585 & (for B300 being (Vector of C582) holds ( C584 . (B300 , B299) ) = ( 0. C581 )))) by L329;
thus L331: thesis by L330;
end;
thus L332: thesis by L328;
end;
end;
definition
let C586 being ZeroStr;
let C587 being non  empty VectSpStr over C586;
let C588 being (Form of C587 , C587);
func diagker C588 -> (Subset of C587) equals 
{ B301 where B301 is (Vector of C587) : ( C588 . (B301 , B301) ) = ( 0. C586 ) };
correctness
proof
set D95 = { B302 where B302 is (Vector of C587) : ( C588 . (B302 , B302) ) = ( 0. C586 ) };
L334: D95 c= (the carrier of C587)
proof
let C589 being set;
assume L335: C589 in D95;
L336: (ex B303 being (Vector of C587) st (B303 = C589 & ( C588 . (B303 , B303) ) = ( 0. C586 ))) by L335;
thus L337: thesis by L336;
end;
thus L338: thesis by L334;
end;
end;
registration
let C590 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C591 being  right_zeroed non  empty VectSpStr over C590;
let C592 being non  empty VectSpStr over C590;
let C593 being  additiveSAF (Form of C591 , C592);
cluster ( leftker C593 ) -> non  empty;
coherence
proof
L340:
now
let C594 being (Vector of C592);
thus L341: ( C593 . (( 0. C591 ) , C594) ) = ( ( FunctionalSAF (C593 , C594) ) . ( 0. C591 ) ) by L89
.= ( 0. C590 ) by HAHNBAN1:def 9;
end;
L342: ( 0. C591 ) in ( leftker C593 ) by L340;
thus L343: thesis by L342;
end;
end;
registration
let C595 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C596 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C595;
let C597 being non  empty VectSpStr over C595;
let C598 being  homogeneousSAF (Form of C596 , C597);
cluster ( leftker C598 ) -> non  empty;
coherence
proof
L345:
now
let C599 being (Vector of C597);
thus L346: ( C598 . (( 0. C596 ) , C599) ) = ( ( FunctionalSAF (C598 , C599) ) . ( 0. C596 ) ) by L89
.= ( 0. C595 ) by HAHNBAN1:def 9;
end;
L347: ( 0. C596 ) in ( leftker C598 ) by L345;
thus L348: thesis by L347;
end;
end;
registration
let C600 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C601 being non  empty VectSpStr over C600;
let C602 being  right_zeroed non  empty VectSpStr over C600;
let C603 being  additiveFAF (Form of C601 , C602);
cluster ( rightker C603 ) -> non  empty;
coherence
proof
L350:
now
let C604 being (Vector of C601);
thus L351: ( C603 . (C604 , ( 0. C602 )) ) = ( ( FunctionalFAF (C603 , C604) ) . ( 0. C602 ) ) by L84
.= ( 0. C600 ) by HAHNBAN1:def 9;
end;
L352: ( 0. C602 ) in ( rightker C603 ) by L350;
thus L353: thesis by L352;
end;
end;
registration
let C605 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C606 being non  empty VectSpStr over C605;
let C607 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C605;
let C608 being  homogeneousFAF (Form of C606 , C607);
cluster ( rightker C608 ) -> non  empty;
coherence
proof
L355:
now
let C609 being (Vector of C606);
thus L356: ( C608 . (C609 , ( 0. C607 )) ) = ( ( FunctionalFAF (C608 , C609) ) . ( 0. C607 ) ) by L84
.= ( 0. C605 ) by HAHNBAN1:def 9;
end;
L357: ( 0. C607 ) in ( rightker C608 ) by L355;
thus L358: thesis by L357;
end;
end;
registration
let C610 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C611 being  right_zeroed non  empty VectSpStr over C610;
let C612 being  additiveFAF (Form of C611 , C611);
cluster ( diagker C612 ) -> non  empty;
coherence
proof
L360: ( C612 . (( 0. C611 ) , ( 0. C611 )) ) = ( 0. C610 ) by L283;
L361: ( 0. C611 ) in ( diagker C612 ) by L360;
thus L362: thesis by L361;
end;
end;
registration
let C613 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C614 being  right_zeroed non  empty VectSpStr over C613;
let C615 being  additiveSAF (Form of C614 , C614);
cluster ( diagker C615 ) -> non  empty;
coherence
proof
L364: ( C615 . (( 0. C614 ) , ( 0. C614 )) ) = ( 0. C613 ) by L286;
L365: ( 0. C614 ) in ( diagker C615 ) by L364;
thus L366: thesis by L365;
end;
end;
registration
let C616 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C617 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C616;
let C618 being  homogeneousFAF (Form of C617 , C617);
cluster ( diagker C618 ) -> non  empty;
coherence
proof
L368: ( C618 . (( 0. C617 ) , ( 0. C617 )) ) = ( 0. C616 ) by L299;
L369: ( 0. C617 ) in ( diagker C618 ) by L368;
thus L370: thesis by L369;
end;
end;
registration
let C619 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C620 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C619;
let C621 being  homogeneousSAF (Form of C620 , C620);
cluster ( diagker C621 ) -> non  empty;
coherence
proof
L372: ( C621 . (( 0. C620 ) , ( 0. C620 )) ) = ( 0. C619 ) by L297;
L373: ( 0. C620 ) in ( diagker C621 ) by L372;
thus L374: thesis by L373;
end;
end;
theorem
L376: (for B304 being ZeroStr holds (for B305 being non  empty VectSpStr over B304 holds (for B306 being (Form of B305 , B305) holds (( leftker B306 ) c= ( diagker B306 ) & ( rightker B306 ) c= ( diagker B306 )))))
proof
let C622 being ZeroStr;
let C623 being non  empty VectSpStr over C622;
let C624 being (Form of C623 , C623);
thus L377: ( leftker C624 ) c= ( diagker C624 )
proof
let C625 being set;
assume L378: C625 in ( leftker C624 );
consider C626 being (Vector of C623) such that L379: C626 = C625 and L380: (for B307 being (Vector of C623) holds ( C624 . (C626 , B307) ) = ( 0. C622 )) by L378;
L381: ( C624 . (C626 , C626) ) = ( 0. C622 ) by L380;
thus L382: thesis by L381 , L379;
end;

let C627 being set;
assume L383: C627 in ( rightker C624 );
consider C628 being (Vector of C623) such that L384: C628 = C627 and L385: (for B308 being (Vector of C623) holds ( C624 . (B308 , C628) ) = ( 0. C622 )) by L383;
L386: ( C624 . (C628 , C628) ) = ( 0. C622 ) by L385;
thus L387: thesis by L386 , L384;
end;
theorem
L388: (for B309 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B310 , B311 being non  empty VectSpStr over B309 holds (for B312 being  additiveSAF  homogeneousSAF (Form of B310 , B311) holds ( leftker B312 ) is  linearly-closed)))
proof
let C629 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C630 , C631 being non  empty VectSpStr over C629;
let C632 being  additiveSAF  homogeneousSAF (Form of C630 , C631);
set D96 = ( leftker C632 );
thus L389: (for B313 , B314 being (Vector of C630) holds ((B313 in D96 & B314 in D96) implies ( B313 + B314 ) in D96))
proof
let C633 , C634 being (Vector of C630);
assume that
L390: C633 in D96
and
L391: C634 in D96;
consider C635 being (Vector of C630) such that L392: C635 = C634 and L393: (for B315 being (Vector of C631) holds ( C632 . (C635 , B315) ) = ( 0. C629 )) by L391;
consider C636 being (Vector of C630) such that L394: C636 = C633 and L395: (for B316 being (Vector of C631) holds ( C632 . (C636 , B316) ) = ( 0. C629 )) by L390;
L396:
now
let C637 being (Vector of C631);
thus L397: ( C632 . (( C633 + C634 ) , C637) ) = ( ( C632 . (C636 , C637) ) + ( C632 . (C635 , C637) ) ) by L394 , L392 , L273
.= ( ( 0. C629 ) + ( C632 . (C635 , C637) ) ) by L395
.= ( ( 0. C629 ) + ( 0. C629 ) ) by L393
.= ( 0. C629 ) by RLVECT_1:def 4;
end;
thus L398: thesis by L396;
end;

let C638 being (Element of C629);
let C639 being (Vector of C630);
assume L399: C639 in D96;
consider C640 being (Vector of C630) such that L400: C640 = C639 and L401: (for B317 being (Vector of C631) holds ( C632 . (C640 , B317) ) = ( 0. C629 )) by L399;
L402:
now
let C641 being (Vector of C631);
thus L403: ( C632 . (( C638 * C639 ) , C641) ) = ( C638 * ( C632 . (C640 , C641) ) ) by L400 , L289
.= ( C638 * ( 0. C629 ) ) by L401
.= ( 0. C629 ) by VECTSP_1:6;
end;
thus L404: thesis by L402;
end;
theorem
L405: (for B318 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B319 , B320 being non  empty VectSpStr over B318 holds (for B321 being  additiveFAF  homogeneousFAF (Form of B319 , B320) holds ( rightker B321 ) is  linearly-closed)))
proof
let C642 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C643 , C644 being non  empty VectSpStr over C642;
let C645 being  additiveFAF  homogeneousFAF (Form of C643 , C644);
set D97 = ( rightker C645 );
thus L406: (for B322 , B323 being (Vector of C644) holds ((B322 in D97 & B323 in D97) implies ( B322 + B323 ) in D97))
proof
let C646 , C647 being (Vector of C644);
assume that
L407: C646 in D97
and
L408: C647 in D97;
consider C648 being (Vector of C644) such that L409: C648 = C647 and L410: (for B324 being (Vector of C643) holds ( C645 . (B324 , C648) ) = ( 0. C642 )) by L408;
consider C649 being (Vector of C644) such that L411: C649 = C646 and L412: (for B325 being (Vector of C643) holds ( C645 . (B325 , C649) ) = ( 0. C642 )) by L407;
L413:
now
let C650 being (Vector of C643);
thus L414: ( C645 . (C650 , ( C646 + C647 )) ) = ( ( C645 . (C650 , C649) ) + ( C645 . (C650 , C648) ) ) by L411 , L409 , L277
.= ( ( 0. C642 ) + ( C645 . (C650 , C648) ) ) by L412
.= ( ( 0. C642 ) + ( 0. C642 ) ) by L410
.= ( 0. C642 ) by RLVECT_1:def 4;
end;
thus L415: thesis by L413;
end;

let C651 being (Element of C642);
let C652 being (Vector of C644);
assume L416: C652 in D97;
consider C653 being (Vector of C644) such that L417: C653 = C652 and L418: (for B326 being (Vector of C643) holds ( C645 . (B326 , C653) ) = ( 0. C642 )) by L416;
L419:
now
let C654 being (Vector of C643);
thus L420: ( C645 . (C654 , ( C651 * C652 )) ) = ( C651 * ( C645 . (C654 , C653) ) ) by L417 , L293
.= ( C651 * ( 0. C642 ) ) by L418
.= ( 0. C642 ) by VECTSP_1:6;
end;
thus L421: thesis by L419;
end;
definition
let C655 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C656 being (VectSp of C655);
let C657 being non  empty VectSpStr over C655;
let C658 being  additiveSAF  homogeneousSAF (Form of C656 , C657);
func LKer C658 ->  strict non  empty (Subspace of C656) means 
:L422: (the carrier of it) = ( leftker C658 );
existence by L388 , VECTSP_4:34;
uniqueness by VECTSP_4:29;
end;
definition
let C659 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C660 being non  empty VectSpStr over C659;
let C661 being (VectSp of C659);
let C662 being  additiveFAF  homogeneousFAF (Form of C660 , C661);
func RKer C662 ->  strict non  empty (Subspace of C661) means 
:L424: (the carrier of it) = ( rightker C662 );
existence by L405 , VECTSP_4:34;
uniqueness by VECTSP_4:29;
end;
definition
let C663 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C664 being (VectSp of C663);
let C665 being non  empty VectSpStr over C663;
let C666 being  additiveSAF  homogeneousSAF (Form of C664 , C665);
func LQForm C666 ->  additiveSAF  homogeneousSAF (Form of ( VectQuot (C664 , ( LKer C666 )) ) , C665) means 
:L426: (for B327 being (Vector of ( VectQuot (C664 , ( LKer C666 )) )) holds (for B328 being (Vector of C665) holds (for B329 being (Vector of C664) holds (B327 = ( B329 + ( LKer C666 ) ) implies ( it . (B327 , B328) ) = ( C666 . (B329 , B328) )))));
existence
proof
set D98 = ( LKer C666 );
set D99 = ( VectQuot (C664 , D98) );
set D100 = ( CosetSet (C664 , D98) );
set D101 = ( addCoset (C664 , D98) );
set D102 = ( lmultCoset (C664 , D98) );
defpred S1[ set , set , set ] means (for B330 being (Vector of C664) holds ($1 = ( B330 + D98 ) implies $3 = ( C666 . (B330 , $2) )));
L427:
now
let C667 being (Vector of D99);
let C668 being (Vector of C665);
consider C669 being (Vector of C664) such that L428: C667 = ( C669 + D98 ) by VECTSP10:22;
take D103 = ( C666 . (C669 , C668) );
L429:
now
let C670 being (Vector of C664);
assume L430: C667 = ( C670 + D98 );
L431: C669 in ( C670 + D98 ) by L430 , L428 , VECTSP_4:44;
consider C671 being (Vector of C664) such that L432: C671 in D98 and L433: C669 = ( C670 + C671 ) by L431 , VECTSP_4:42;
L434: C671 in (the carrier of D98) by L432 , STRUCT_0:def 5;
L435: C671 in ( leftker C666 ) by L434 , L422;
L436: (ex B331 being (Vector of C664) st (B331 = C671 & (for B332 being (Vector of C665) holds ( C666 . (B331 , B332) ) = ( 0. C663 )))) by L435;
thus L437: D103 = ( ( C666 . (C670 , C668) ) + ( C666 . (C671 , C668) ) ) by L433 , L273
.= ( ( C666 . (C670 , C668) ) + ( 0. C663 ) ) by L436
.= ( C666 . (C670 , C668) ) by RLVECT_1:def 4;
end;
thus L438: S1[ C667 , C668 , D103 ] by L429;
end;
consider C672 being (Function of [: (the carrier of D99) , (the carrier of C665) :] , (the carrier of C663)) such that L439: (for B333 being (Vector of D99) holds (for B334 being (Vector of C665) holds S1[ B333 , B334 , ( C672 . (B333 , B334) ) ])) from BINOP_1:sch 3(L427);
reconsider D104 = C672 as (Form of D99 , C665);
L440: D100 = (the carrier of D99) by VECTSP10:def 6;
L441:
now
let C673 being (Vector of C665);
set D105 = ( FunctionalSAF (D104 , C673) );
L442:
now
let C674 , C675 being (Vector of D99);
consider C676 being (Vector of C664) such that L443: C674 = ( C676 + D98 ) by VECTSP10:22;
consider C677 being (Vector of C664) such that L444: C675 = ( C677 + D98 ) by VECTSP10:22;
L445: ((the addF of D99) = ( addCoset (C664 , D98) ) & ( D101 . (C674 , C675) ) = ( ( C676 + C677 ) + D98 )) by L440 , L443 , L444 , VECTSP10:def 3 , VECTSP10:def 6;
thus L446: ( D105 . ( C674 + C675 ) ) = ( D104 . (( C674 + C675 ) , C673) ) by L89
.= ( C666 . (( C676 + C677 ) , C673) ) by L439 , L445 , RLVECT_1:2
.= ( ( C666 . (C676 , C673) ) + ( C666 . (C677 , C673) ) ) by L273
.= ( ( D104 . (C674 , C673) ) + ( C666 . (C677 , C673) ) ) by L439 , L443
.= ( ( D104 . (C674 , C673) ) + ( D104 . (C675 , C673) ) ) by L439 , L444
.= ( ( D105 . C674 ) + ( D104 . (C675 , C673) ) ) by L89
.= ( ( D105 . C674 ) + ( D105 . C675 ) ) by L89;
end;
thus L447: D105 is  additive by L442 , VECTSP_1:def 20;
end;
reconsider D106 = D104 as  additiveSAF (Form of D99 , C665) by L441 , L164;
L448:
now
let C678 being (Vector of C665);
set D107 = ( FunctionalSAF (D106 , C678) );
L449:
now
let C679 being (Vector of D99);
let C680 being (Element of C663);
consider C681 being (Vector of C664) such that L450: C679 = ( C681 + D98 ) by VECTSP10:22;
L451: ((the lmult of D99) = ( lmultCoset (C664 , D98) ) & ( D102 . (C680 , C679) ) = ( ( C680 * C681 ) + D98 )) by L440 , L450 , VECTSP10:def 5 , VECTSP10:def 6;
thus L452: ( D107 . ( C680 * C679 ) ) = ( D106 . (( C680 * C679 ) , C678) ) by L89
.= ( C666 . (( C680 * C681 ) , C678) ) by L439 , L451
.= ( C680 * ( C666 . (C681 , C678) ) ) by L289
.= ( C680 * ( D106 . (C679 , C678) ) ) by L439 , L450
.= ( C680 * ( D107 . C679 ) ) by L89;
end;
thus L453: D107 is  homogeneous by L449 , HAHNBAN1:def 8;
end;
reconsider D108 = D106 as  additiveSAF  homogeneousSAF (Form of D99 , C665) by L448 , L167;
take D108;
thus L454: thesis by L439;
end;
uniqueness
proof
set D109 = ( LKer C666 );
set D110 = ( VectQuot (C664 , D109) );
let C682 , C683 being  additiveSAF  homogeneousSAF (Form of D110 , C665);
assume that
L455: (for B335 being (Vector of D110) holds (for B336 being (Vector of C665) holds (for B337 being (Vector of C664) holds (B335 = ( B337 + ( LKer C666 ) ) implies ( C682 . (B335 , B336) ) = ( C666 . (B337 , B336) )))))
and
L456: (for B338 being (Vector of D110) holds (for B339 being (Vector of C665) holds (for B340 being (Vector of C664) holds (B338 = ( B340 + ( LKer C666 ) ) implies ( C683 . (B338 , B339) ) = ( C666 . (B340 , B339) )))));
L457:
now
let C684 being (Vector of D110);
let C685 being (Vector of C665);
consider C686 being (Vector of C664) such that L458: C684 = ( C686 + D109 ) by VECTSP10:22;
thus L459: ( C682 . (C684 , C685) ) = ( C666 . (C686 , C685) ) by L455 , L458
.= ( C683 . (C684 , C685) ) by L456 , L458;
end;
thus L460: thesis by L457 , BINOP_1:2;
end;
end;
definition
let C687 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C688 being non  empty VectSpStr over C687;
let C689 being (VectSp of C687);
let C690 being  additiveFAF  homogeneousFAF (Form of C688 , C689);
func RQForm C690 ->  additiveFAF  homogeneousFAF (Form of C688 , ( VectQuot (C689 , ( RKer C690 )) )) means 
:L462: (for B341 being (Vector of ( VectQuot (C689 , ( RKer C690 )) )) holds (for B342 being (Vector of C688) holds (for B343 being (Vector of C689) holds (B341 = ( B343 + ( RKer C690 ) ) implies ( it . (B342 , B341) ) = ( C690 . (B342 , B343) )))));
existence
proof
set D111 = ( RKer C690 );
set D112 = ( VectQuot (C689 , D111) );
set D113 = ( CosetSet (C689 , D111) );
set D114 = ( addCoset (C689 , D111) );
set D115 = ( lmultCoset (C689 , D111) );
defpred S2[ set , set , set ] means (for B344 being (Vector of C689) holds ($2 = ( B344 + D111 ) implies $3 = ( C690 . ($1 , B344) )));
L463:
now
let C691 being (Vector of C688);
let C692 being (Vector of D112);
consider C693 being (Vector of C689) such that L464: C692 = ( C693 + D111 ) by VECTSP10:22;
take D116 = ( C690 . (C691 , C693) );
L465:
now
let C694 being (Vector of C689);
assume L466: C692 = ( C694 + D111 );
L467: C693 in ( C694 + D111 ) by L466 , L464 , VECTSP_4:44;
consider C695 being (Vector of C689) such that L468: C695 in D111 and L469: C693 = ( C694 + C695 ) by L467 , VECTSP_4:42;
L470: C695 in (the carrier of D111) by L468 , STRUCT_0:def 5;
L471: C695 in ( rightker C690 ) by L470 , L424;
L472: (ex B345 being (Vector of C689) st (B345 = C695 & (for B346 being (Vector of C688) holds ( C690 . (B346 , B345) ) = ( 0. C687 )))) by L471;
thus L473: D116 = ( ( C690 . (C691 , C694) ) + ( C690 . (C691 , C695) ) ) by L469 , L277
.= ( ( C690 . (C691 , C694) ) + ( 0. C687 ) ) by L472
.= ( C690 . (C691 , C694) ) by RLVECT_1:def 4;
end;
thus L474: S2[ C691 , C692 , D116 ] by L465;
end;
consider C696 being (Function of [: (the carrier of C688) , (the carrier of D112) :] , (the carrier of C687)) such that L475: (for B347 being (Vector of C688) holds (for B348 being (Vector of D112) holds S2[ B347 , B348 , ( C696 . (B347 , B348) ) ])) from BINOP_1:sch 3(L463);
reconsider D117 = C696 as (Form of C688 , D112);
L476: D113 = (the carrier of D112) by VECTSP10:def 6;
L477:
now
let C697 being (Vector of C688);
set D118 = ( FunctionalFAF (D117 , C697) );
L478:
now
let C698 , C699 being (Vector of D112);
consider C700 being (Vector of C689) such that L479: C698 = ( C700 + D111 ) by VECTSP10:22;
consider C701 being (Vector of C689) such that L480: C699 = ( C701 + D111 ) by VECTSP10:22;
L481: ((the addF of D112) = ( addCoset (C689 , D111) ) & ( D114 . (C698 , C699) ) = ( ( C700 + C701 ) + D111 )) by L476 , L479 , L480 , VECTSP10:def 3 , VECTSP10:def 6;
thus L482: ( D118 . ( C698 + C699 ) ) = ( D117 . (C697 , ( C698 + C699 )) ) by L84
.= ( C690 . (C697 , ( C700 + C701 )) ) by L475 , L481 , RLVECT_1:2
.= ( ( C690 . (C697 , C700) ) + ( C690 . (C697 , C701) ) ) by L277
.= ( ( D117 . (C697 , C698) ) + ( C690 . (C697 , C701) ) ) by L475 , L479
.= ( ( D117 . (C697 , C698) ) + ( D117 . (C697 , C699) ) ) by L475 , L480
.= ( ( D118 . C698 ) + ( D117 . (C697 , C699) ) ) by L84
.= ( ( D118 . C698 ) + ( D118 . C699 ) ) by L84;
end;
thus L483: D118 is  additive by L478 , VECTSP_1:def 20;
end;
reconsider D119 = D117 as  additiveFAF (Form of C688 , D112) by L477 , L163;
L484:
now
let C702 being (Vector of C688);
set D120 = ( FunctionalFAF (D119 , C702) );
L485:
now
let C703 being (Vector of D112);
let C704 being (Element of C687);
consider C705 being (Vector of C689) such that L486: C703 = ( C705 + D111 ) by VECTSP10:22;
L487: ((the lmult of D112) = ( lmultCoset (C689 , D111) ) & ( D115 . (C704 , C703) ) = ( ( C704 * C705 ) + D111 )) by L476 , L486 , VECTSP10:def 5 , VECTSP10:def 6;
thus L488: ( D120 . ( C704 * C703 ) ) = ( D119 . (C702 , ( C704 * C703 )) ) by L84
.= ( C690 . (C702 , ( C704 * C705 )) ) by L475 , L487
.= ( C704 * ( C690 . (C702 , C705) ) ) by L293
.= ( C704 * ( D119 . (C702 , C703) ) ) by L475 , L486
.= ( C704 * ( D120 . C703 ) ) by L84;
end;
thus L489: D120 is  homogeneous by L485 , HAHNBAN1:def 8;
end;
reconsider D121 = D119 as  additiveFAF  homogeneousFAF (Form of C688 , D112) by L484 , L166;
take D121;
thus L490: thesis by L475;
end;
uniqueness
proof
set D122 = ( RKer C690 );
set D123 = ( VectQuot (C689 , D122) );
let C706 , C707 being  additiveFAF  homogeneousFAF (Form of C688 , D123);
assume that
L491: (for B349 being (Vector of D123) holds (for B350 being (Vector of C688) holds (for B351 being (Vector of C689) holds (B349 = ( B351 + ( RKer C690 ) ) implies ( C706 . (B350 , B349) ) = ( C690 . (B350 , B351) )))))
and
L492: (for B352 being (Vector of D123) holds (for B353 being (Vector of C688) holds (for B354 being (Vector of C689) holds (B352 = ( B354 + ( RKer C690 ) ) implies ( C707 . (B353 , B352) ) = ( C690 . (B353 , B354) )))));
L493:
now
let C708 being (Vector of C688);
let C709 being (Vector of D123);
consider C710 being (Vector of C689) such that L494: C709 = ( C710 + D122 ) by VECTSP10:22;
thus L495: ( C706 . (C708 , C709) ) = ( C690 . (C708 , C710) ) by L491 , L494
.= ( C707 . (C708 , C709) ) by L492 , L494;
end;
thus L496: thesis by L493 , BINOP_1:2;
end;
end;
registration
let C711 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C712 , C713 being (VectSp of C711);
let C714 being (bilinear-Form of C712 , C713);
cluster ( LQForm C714 ) ->  additiveFAF  homogeneousFAF;
coherence
proof
set D124 = ( LQForm C714 );
thus L498: ( LQForm C714 ) is  additiveFAF
proof
let C715 being (Vector of ( VectQuot (C712 , ( LKer C714 )) ));
set D125 = ( FunctionalFAF (D124 , C715) );
consider C716 being (Vector of C712) such that L499: C715 = ( C716 + ( LKer C714 ) ) by VECTSP10:22;
let C717 , C718 being (Vector of C713);
thus L500: ( D125 . ( C717 + C718 ) ) = ( D124 . (C715 , ( C717 + C718 )) ) by L84
.= ( C714 . (C716 , ( C717 + C718 )) ) by L499 , L426
.= ( ( C714 . (C716 , C717) ) + ( C714 . (C716 , C718) ) ) by L277
.= ( ( D124 . (C715 , C717) ) + ( C714 . (C716 , C718) ) ) by L499 , L426
.= ( ( D124 . (C715 , C717) ) + ( D124 . (C715 , C718) ) ) by L499 , L426
.= ( ( D125 . C717 ) + ( D124 . (C715 , C718) ) ) by L84
.= ( ( D125 . C717 ) + ( D125 . C718 ) ) by L84;
end;

let C719 being (Vector of ( VectQuot (C712 , ( LKer C714 )) ));
set D126 = ( FunctionalFAF (D124 , C719) );
consider C720 being (Vector of C712) such that L501: C719 = ( C720 + ( LKer C714 ) ) by VECTSP10:22;
let C721 being (Vector of C713);
let C722 being (Scalar of C713);
thus L502: ( D126 . ( C722 * C721 ) ) = ( D124 . (C719 , ( C722 * C721 )) ) by L84
.= ( C714 . (C720 , ( C722 * C721 )) ) by L501 , L426
.= ( C722 * ( C714 . (C720 , C721) ) ) by L293
.= ( C722 * ( D124 . (C719 , C721) ) ) by L501 , L426
.= ( C722 * ( D126 . C721 ) ) by L84;
end;
cluster ( RQForm C714 ) ->  additiveSAF  homogeneousSAF;
coherence
proof
set D127 = ( RQForm C714 );
thus L503: ( RQForm C714 ) is  additiveSAF
proof
let C723 being (Vector of ( VectQuot (C713 , ( RKer C714 )) ));
set D128 = ( FunctionalSAF (D127 , C723) );
consider C724 being (Vector of C713) such that L504: C723 = ( C724 + ( RKer C714 ) ) by VECTSP10:22;
let C725 , C726 being (Vector of C712);
thus L505: ( D128 . ( C725 + C726 ) ) = ( D127 . (( C725 + C726 ) , C723) ) by L89
.= ( C714 . (( C725 + C726 ) , C724) ) by L504 , L462
.= ( ( C714 . (C725 , C724) ) + ( C714 . (C726 , C724) ) ) by L273
.= ( ( D127 . (C725 , C723) ) + ( C714 . (C726 , C724) ) ) by L504 , L462
.= ( ( D127 . (C725 , C723) ) + ( D127 . (C726 , C723) ) ) by L504 , L462
.= ( ( D128 . C725 ) + ( D127 . (C726 , C723) ) ) by L89
.= ( ( D128 . C725 ) + ( D128 . C726 ) ) by L89;
end;

let C727 being (Vector of ( VectQuot (C713 , ( RKer C714 )) ));
set D129 = ( FunctionalSAF (D127 , C727) );
consider C728 being (Vector of C713) such that L506: C727 = ( C728 + ( RKer C714 ) ) by VECTSP10:22;
let C729 being (Vector of C712);
let C730 being (Scalar of C712);
thus L507: ( D129 . ( C730 * C729 ) ) = ( D127 . (( C730 * C729 ) , C727) ) by L89
.= ( C714 . (( C730 * C729 ) , C728) ) by L506 , L462
.= ( C730 * ( C714 . (C729 , C728) ) ) by L289
.= ( C730 * ( D127 . (C729 , C727) ) ) by L506 , L462
.= ( C730 * ( D129 . C729 ) ) by L89;
end;
end;
definition
let C731 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C732 , C733 being (VectSp of C731);
let C734 being (bilinear-Form of C732 , C733);
func QForm C734 -> (bilinear-Form of ( VectQuot (C732 , ( LKer C734 )) ) , ( VectQuot (C733 , ( RKer C734 )) )) means 
:L509: (for B355 being (Vector of ( VectQuot (C732 , ( LKer C734 )) )) holds (for B356 being (Vector of ( VectQuot (C733 , ( RKer C734 )) )) holds (for B357 being (Vector of C732) holds (for B358 being (Vector of C733) holds ((B355 = ( B357 + ( LKer C734 ) ) & B356 = ( B358 + ( RKer C734 ) )) implies ( it . (B355 , B356) ) = ( C734 . (B357 , B358) ))))));
existence
proof
set D130 = ( LKer C734 );
set D131 = ( VectQuot (C732 , D130) );
set D132 = ( CosetSet (C732 , D130) );
set D133 = ( addCoset (C732 , D130) );
set D134 = ( lmultCoset (C732 , D130) );
set D135 = ( RKer C734 );
set D136 = ( VectQuot (C733 , D135) );
set D137 = ( CosetSet (C733 , D135) );
set D138 = ( addCoset (C733 , D135) );
set D139 = ( lmultCoset (C733 , D135) );
defpred S3[ set , set , set ] means (for B359 being (Vector of C732) holds (for B360 being (Vector of C733) holds (($1 = ( B359 + D130 ) & $2 = ( B360 + D135 )) implies $3 = ( C734 . (B359 , B360) ))));
L510:
now
let C735 being (Vector of D131);
let C736 being (Vector of D136);
consider C737 being (Vector of C732) such that L511: C735 = ( C737 + D130 ) by VECTSP10:22;
consider C738 being (Vector of C733) such that L512: C736 = ( C738 + D135 ) by VECTSP10:22;
take D140 = ( C734 . (C737 , C738) );
L513:
now
let C739 being (Vector of C732);
let C740 being (Vector of C733);
assume L514: C735 = ( C739 + D130 );
L515: C737 in ( C739 + D130 ) by L514 , L511 , VECTSP_4:44;
consider C741 being (Vector of C732) such that L516: C741 in D130 and L517: C737 = ( C739 + C741 ) by L515 , VECTSP_4:42;
L518: C741 in (the carrier of D130) by L516 , STRUCT_0:def 5;
L519: C741 in ( leftker C734 ) by L518 , L422;
L520: (ex B361 being (Vector of C732) st (B361 = C741 & (for B362 being (Vector of C733) holds ( C734 . (B361 , B362) ) = ( 0. C731 )))) by L519;
assume L521: C736 = ( C740 + D135 );
L522: C738 in ( C740 + D135 ) by L521 , L512 , VECTSP_4:44;
consider C742 being (Vector of C733) such that L523: C742 in D135 and L524: C738 = ( C740 + C742 ) by L522 , VECTSP_4:42;
L525: C742 in (the carrier of D135) by L523 , STRUCT_0:def 5;
L526: C742 in ( rightker C734 ) by L525 , L424;
L527: (ex B363 being (Vector of C733) st (B363 = C742 & (for B364 being (Vector of C732) holds ( C734 . (B364 , B363) ) = ( 0. C731 )))) by L526;
thus L528: D140 = ( ( ( C734 . (C739 , C740) ) + ( C734 . (C739 , C742) ) ) + ( ( C734 . (C741 , C740) ) + ( C734 . (C741 , C742) ) ) ) by L517 , L524 , L281
.= ( ( ( C734 . (C739 , C740) ) + ( 0. C731 ) ) + ( ( C734 . (C741 , C740) ) + ( C734 . (C741 , C742) ) ) ) by L527
.= ( ( ( C734 . (C739 , C740) ) + ( 0. C731 ) ) + ( ( 0. C731 ) + ( C734 . (C741 , C742) ) ) ) by L520
.= ( ( C734 . (C739 , C740) ) + ( ( 0. C731 ) + ( C734 . (C741 , C742) ) ) ) by RLVECT_1:def 4
.= ( ( C734 . (C739 , C740) ) + ( C734 . (C741 , C742) ) ) by RLVECT_1:4
.= ( ( C734 . (C739 , C740) ) + ( 0. C731 ) ) by L520
.= ( C734 . (C739 , C740) ) by RLVECT_1:def 4;
end;
thus L529: S3[ C735 , C736 , D140 ] by L513;
end;
consider C743 being (Function of [: (the carrier of D131) , (the carrier of D136) :] , (the carrier of C731)) such that L530: (for B365 being (Vector of D131) holds (for B366 being (Vector of D136) holds S3[ B365 , B366 , ( C743 . (B365 , B366) ) ])) from BINOP_1:sch 3(L510);
reconsider D141 = C743 as (Form of D131 , D136);
L531: D132 = (the carrier of D131) by VECTSP10:def 6;
L532:
now
let C744 being (Vector of D136);
consider C745 being (Vector of C733) such that L533: C744 = ( C745 + D135 ) by VECTSP10:22;
set D142 = ( FunctionalSAF (D141 , C744) );
L534:
now
let C746 being (Vector of D131);
let C747 being (Element of C731);
consider C748 being (Vector of C732) such that L535: C746 = ( C748 + D130 ) by VECTSP10:22;
L536: ((the lmult of D131) = D134 & ( D134 . (C747 , C746) ) = ( ( C747 * C748 ) + D130 )) by L531 , L535 , VECTSP10:def 5 , VECTSP10:def 6;
thus L537: ( D142 . ( C747 * C746 ) ) = ( D141 . (( C747 * C746 ) , C744) ) by L89
.= ( C734 . (( C747 * C748 ) , C745) ) by L530 , L533 , L536
.= ( C747 * ( C734 . (C748 , C745) ) ) by L289
.= ( C747 * ( D141 . (C746 , C744) ) ) by L530 , L533 , L535
.= ( C747 * ( D142 . C746 ) ) by L89;
end;
thus L538: D142 is  homogeneous by L534 , HAHNBAN1:def 8;
end;
L539: D137 = (the carrier of D136) by VECTSP10:def 6;
L540:
now
let C749 being (Vector of D131);
consider C750 being (Vector of C732) such that L541: C749 = ( C750 + D130 ) by VECTSP10:22;
set D143 = ( FunctionalFAF (D141 , C749) );
L542:
now
let C751 being (Vector of D136);
let C752 being (Element of C731);
consider C753 being (Vector of C733) such that L543: C751 = ( C753 + D135 ) by VECTSP10:22;
L544: ((the lmult of D136) = D139 & ( D139 . (C752 , C751) ) = ( ( C752 * C753 ) + D135 )) by L539 , L543 , VECTSP10:def 5 , VECTSP10:def 6;
thus L545: ( D143 . ( C752 * C751 ) ) = ( D141 . (C749 , ( C752 * C751 )) ) by L84
.= ( C734 . (C750 , ( C752 * C753 )) ) by L530 , L541 , L544
.= ( C752 * ( C734 . (C750 , C753) ) ) by L293
.= ( C752 * ( D141 . (C749 , C751) ) ) by L530 , L541 , L543
.= ( C752 * ( D143 . C751 ) ) by L84;
end;
thus L546: D143 is  homogeneous by L542 , HAHNBAN1:def 8;
end;
L547:
now
let C754 being (Vector of D136);
consider C755 being (Vector of C733) such that L548: C754 = ( C755 + D135 ) by VECTSP10:22;
set D144 = ( FunctionalSAF (D141 , C754) );
L549:
now
let C756 , C757 being (Vector of D131);
consider C758 being (Vector of C732) such that L550: C756 = ( C758 + D130 ) by VECTSP10:22;
consider C759 being (Vector of C732) such that L551: C757 = ( C759 + D130 ) by VECTSP10:22;
L552: ((the addF of D131) = D133 & ( D133 . (C756 , C757) ) = ( ( C758 + C759 ) + D130 )) by L531 , L550 , L551 , VECTSP10:def 3 , VECTSP10:def 6;
thus L553: ( D144 . ( C756 + C757 ) ) = ( D141 . (( C756 + C757 ) , C754) ) by L89
.= ( C734 . (( C758 + C759 ) , C755) ) by L530 , L548 , L552 , RLVECT_1:2
.= ( ( C734 . (C758 , C755) ) + ( C734 . (C759 , C755) ) ) by L273
.= ( ( D141 . (C756 , C754) ) + ( C734 . (C759 , C755) ) ) by L530 , L548 , L550
.= ( ( D141 . (C756 , C754) ) + ( D141 . (C757 , C754) ) ) by L530 , L548 , L551
.= ( ( D144 . C756 ) + ( D141 . (C757 , C754) ) ) by L89
.= ( ( D144 . C756 ) + ( D144 . C757 ) ) by L89;
end;
thus L554: D144 is  additive by L549 , VECTSP_1:def 20;
end;
L555:
now
let C760 being (Vector of D131);
consider C761 being (Vector of C732) such that L556: C760 = ( C761 + D130 ) by VECTSP10:22;
set D145 = ( FunctionalFAF (D141 , C760) );
L557:
now
let C762 , C763 being (Vector of D136);
consider C764 being (Vector of C733) such that L558: C762 = ( C764 + D135 ) by VECTSP10:22;
consider C765 being (Vector of C733) such that L559: C763 = ( C765 + D135 ) by VECTSP10:22;
L560: ((the addF of D136) = D138 & ( D138 . (C762 , C763) ) = ( ( C764 + C765 ) + D135 )) by L539 , L558 , L559 , VECTSP10:def 3 , VECTSP10:def 6;
thus L561: ( D145 . ( C762 + C763 ) ) = ( D141 . (C760 , ( C762 + C763 )) ) by L84
.= ( C734 . (C761 , ( C764 + C765 )) ) by L530 , L556 , L560 , RLVECT_1:2
.= ( ( C734 . (C761 , C764) ) + ( C734 . (C761 , C765) ) ) by L277
.= ( ( D141 . (C760 , C762) ) + ( C734 . (C761 , C765) ) ) by L530 , L556 , L558
.= ( ( D141 . (C760 , C762) ) + ( D141 . (C760 , C763) ) ) by L530 , L556 , L559
.= ( ( D145 . C762 ) + ( D141 . (C760 , C763) ) ) by L84
.= ( ( D145 . C762 ) + ( D145 . C763 ) ) by L84;
end;
thus L562: D145 is  additive by L557 , VECTSP_1:def 20;
end;
reconsider D146 = D141 as (bilinear-Form of D131 , D136) by L555 , L547 , L532 , L540 , L163 , L164 , L166 , L167;
take D146;
thus L563: thesis by L530;
end;
uniqueness
proof
set D147 = ( LKer C734 );
set D148 = ( VectQuot (C732 , D147) );
set D149 = ( RKer C734 );
set D150 = ( VectQuot (C733 , D149) );
let C766 , C767 being (bilinear-Form of D148 , D150);
assume that
L564: (for B367 being (Vector of D148) holds (for B368 being (Vector of D150) holds (for B369 being (Vector of C732) holds (for B370 being (Vector of C733) holds ((B367 = ( B369 + D147 ) & B368 = ( B370 + D149 )) implies ( C766 . (B367 , B368) ) = ( C734 . (B369 , B370) ))))))
and
L565: (for B371 being (Vector of D148) holds (for B372 being (Vector of D150) holds (for B373 being (Vector of C732) holds (for B374 being (Vector of C733) holds ((B371 = ( B373 + D147 ) & B372 = ( B374 + D149 )) implies ( C767 . (B371 , B372) ) = ( C734 . (B373 , B374) ))))));
L566:
now
let C768 being (Vector of D148);
let C769 being (Vector of D150);
consider C770 being (Vector of C732) such that L567: C768 = ( C770 + D147 ) by VECTSP10:22;
consider C771 being (Vector of C733) such that L568: C769 = ( C771 + D149 ) by VECTSP10:22;
thus L569: ( C766 . (C768 , C769) ) = ( C734 . (C770 , C771) ) by L564 , L567 , L568
.= ( C767 . (C768 , C769) ) by L565 , L567 , L568;
end;
thus L570: thesis by L566 , BINOP_1:2;
end;
end;
theorem
L572: (for B375 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B376 being (VectSp of B375) holds (for B377 being non  empty VectSpStr over B375 holds (for B378 being  additiveSAF  homogeneousSAF (Form of B376 , B377) holds ( rightker B378 ) = ( rightker ( LQForm B378 ) )))))
proof
let C772 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C773 being (VectSp of C772);
let C774 being non  empty VectSpStr over C772;
let C775 being  additiveSAF  homogeneousSAF (Form of C773 , C774);
set D151 = ( LQForm C775 );
set D152 = ( VectQuot (C773 , ( LKer C775 )) );
thus L573: ( rightker C775 ) c= ( rightker ( LQForm C775 ) )
proof
let C776 being set;
assume L574: C776 in ( rightker C775 );
consider C777 being (Vector of C774) such that L575: C776 = C777 and L576: (for B379 being (Vector of C773) holds ( C775 . (B379 , C777) ) = ( 0. C772 )) by L574;
L577:
now
let C778 being (Vector of D152);
consider C779 being (Vector of C773) such that L578: C778 = ( C779 + ( LKer C775 ) ) by VECTSP10:22;
thus L579: ( D151 . (C778 , C777) ) = ( C775 . (C779 , C777) ) by L578 , L426
.= ( 0. C772 ) by L576;
end;
thus L580: thesis by L577 , L575;
end;

let C780 being set;
assume L581: C780 in ( rightker D151 );
consider C781 being (Vector of C774) such that L582: C780 = C781 and L583: (for B380 being (Vector of D152) holds ( D151 . (B380 , C781) ) = ( 0. C772 )) by L581;
L584:
now
let C782 being (Vector of C773);
reconsider D153 = ( C782 + ( LKer C775 ) ) as (Vector of D152) by VECTSP10:23;
thus L585: ( C775 . (C782 , C781) ) = ( D151 . (D153 , C781) ) by L426
.= ( 0. C772 ) by L583;
end;
thus L586: thesis by L584 , L582;
end;
theorem
L587: (for B381 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B382 being non  empty VectSpStr over B381 holds (for B383 being (VectSp of B381) holds (for B384 being  additiveFAF  homogeneousFAF (Form of B382 , B383) holds ( leftker B384 ) = ( leftker ( RQForm B384 ) )))))
proof
let C783 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C784 being non  empty VectSpStr over C783;
let C785 being (VectSp of C783);
let C786 being  additiveFAF  homogeneousFAF (Form of C784 , C785);
set D154 = ( RQForm C786 );
set D155 = ( VectQuot (C785 , ( RKer C786 )) );
thus L588: ( leftker C786 ) c= ( leftker ( RQForm C786 ) )
proof
let C787 being set;
assume L589: C787 in ( leftker C786 );
consider C788 being (Vector of C784) such that L590: C787 = C788 and L591: (for B385 being (Vector of C785) holds ( C786 . (C788 , B385) ) = ( 0. C783 )) by L589;
L592:
now
let C789 being (Vector of D155);
consider C790 being (Vector of C785) such that L593: C789 = ( C790 + ( RKer C786 ) ) by VECTSP10:22;
thus L594: ( D154 . (C788 , C789) ) = ( C786 . (C788 , C790) ) by L593 , L462
.= ( 0. C783 ) by L591;
end;
thus L595: thesis by L592 , L590;
end;

let C791 being set;
assume L596: C791 in ( leftker D154 );
consider C792 being (Vector of C784) such that L597: C791 = C792 and L598: (for B386 being (Vector of D155) holds ( D154 . (C792 , B386) ) = ( 0. C783 )) by L596;
L599:
now
let C793 being (Vector of C785);
reconsider D156 = ( C793 + ( RKer C786 ) ) as (Vector of D155) by VECTSP10:23;
thus L600: ( C786 . (C792 , C793) ) = ( D154 . (C792 , D156) ) by L462
.= ( 0. C783 ) by L598;
end;
thus L601: thesis by L599 , L597;
end;
theorem
L602: (for B387 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B388 , B389 being (VectSp of B387) holds (for B390 being (bilinear-Form of B388 , B389) holds ( RKer B390 ) = ( RKer ( LQForm B390 ) ))))
proof
let C794 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C795 , C796 being (VectSp of C794);
let C797 being (bilinear-Form of C795 , C796);
L603: (the carrier of ( RKer C797 )) = ( rightker C797 ) by L424
.= ( rightker ( LQForm C797 ) ) by L572
.= (the carrier of ( RKer ( LQForm C797 ) )) by L424;
thus L604: thesis by L603 , VECTSP_4:29;
end;
theorem
L605: (for B391 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B392 , B393 being (VectSp of B391) holds (for B394 being (bilinear-Form of B392 , B393) holds ( LKer B394 ) = ( LKer ( RQForm B394 ) ))))
proof
let C798 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C799 , C800 being (VectSp of C798);
let C801 being (bilinear-Form of C799 , C800);
L606: (the carrier of ( LKer C801 )) = ( leftker C801 ) by L422
.= ( leftker ( RQForm C801 ) ) by L587
.= (the carrier of ( LKer ( RQForm C801 ) )) by L422;
thus L607: thesis by L606 , VECTSP_4:29;
end;
theorem
L608: (for B395 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B396 , B397 being (VectSp of B395) holds (for B398 being (bilinear-Form of B396 , B397) holds (( QForm B398 ) = ( RQForm ( LQForm B398 ) ) & ( QForm B398 ) = ( LQForm ( RQForm B398 ) )))))
proof
let C802 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C803 , C804 being (VectSp of C802);
let C805 being (bilinear-Form of C803 , C804);
set D157 = ( LKer C805 );
set D158 = ( VectQuot (C803 , D157) );
set D159 = ( RKer C805 );
set D160 = ( VectQuot (C804 , D159) );
set D161 = ( RKer ( LQForm C805 ) );
set D162 = ( VectQuot (C804 , D161) );
set D163 = ( LKer ( RQForm C805 ) );
set D164 = ( VectQuot (C803 , D163) );
L609: ( dom ( QForm C805 ) ) = [: (the carrier of D158) , (the carrier of D160) :] by FUNCT_2:def 1;
L610:
now
let C806 being set;
assume L611: C806 in ( dom ( QForm C805 ) );
consider C807 being (Vector of D158), C808 being (Vector of D160) such that L612: C806 = [ C807 , C808 ] by L611 , DOMAIN_1:1;
consider C809 being (Vector of C804) such that L613: C808 = ( C809 + D159 ) by VECTSP10:22;
L614: D159 = D161 by L602;
consider C810 being (Vector of C803) such that L615: C807 = ( C810 + D157 ) by VECTSP10:22;
thus L616: ( ( QForm C805 ) . C806 ) = ( ( QForm C805 ) . (C807 , C808) ) by L612
.= ( C805 . (C810 , C809) ) by L615 , L613 , L509
.= ( ( LQForm C805 ) . (C807 , C809) ) by L615 , L426
.= ( ( RQForm ( LQForm C805 ) ) . (C807 , C808) ) by L613 , L614 , L462
.= ( ( RQForm ( LQForm C805 ) ) . C806 ) by L612;
end;
L617: (( dom ( RQForm ( LQForm C805 ) ) ) = [: (the carrier of D158) , (the carrier of D162) :] & (the carrier of D162) = (the carrier of D160)) by L602 , FUNCT_2:def 1;
thus L618: ( QForm C805 ) = ( RQForm ( LQForm C805 ) ) by L617 , L609 , L610 , FUNCT_1:2;
L619:
now
let C811 being set;
assume L620: C811 in ( dom ( QForm C805 ) );
consider C812 being (Vector of D158), C813 being (Vector of D160) such that L621: C811 = [ C812 , C813 ] by L620 , DOMAIN_1:1;
consider C814 being (Vector of C804) such that L622: C813 = ( C814 + D159 ) by VECTSP10:22;
L623: D157 = D163 by L605;
consider C815 being (Vector of C803) such that L624: C812 = ( C815 + D157 ) by VECTSP10:22;
thus L625: ( ( QForm C805 ) . C811 ) = ( ( QForm C805 ) . (C812 , C813) ) by L621
.= ( C805 . (C815 , C814) ) by L624 , L622 , L509
.= ( ( RQForm C805 ) . (C815 , C813) ) by L622 , L462
.= ( ( LQForm ( RQForm C805 ) ) . (C812 , C813) ) by L624 , L623 , L426
.= ( ( LQForm ( RQForm C805 ) ) . C811 ) by L621;
end;
L626: (( dom ( LQForm ( RQForm C805 ) ) ) = [: (the carrier of D164) , (the carrier of D160) :] & (the carrier of D164) = (the carrier of D158)) by L605 , FUNCT_2:def 1;
thus L627: thesis by L626 , L609 , L619 , FUNCT_1:2;
end;
theorem
L628: (for B399 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B400 , B401 being (VectSp of B399) holds (for B402 being (bilinear-Form of B400 , B401) holds (( leftker ( QForm B402 ) ) = ( leftker ( RQForm ( LQForm B402 ) ) ) & ( rightker ( QForm B402 ) ) = ( rightker ( RQForm ( LQForm B402 ) ) ) & ( leftker ( QForm B402 ) ) = ( leftker ( LQForm ( RQForm B402 ) ) ) & ( rightker ( QForm B402 ) ) = ( rightker ( LQForm ( RQForm B402 ) ) )))))
proof
let C816 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C817 , C818 being (VectSp of C816);
let C819 being (bilinear-Form of C817 , C818);
set D165 = ( VectQuot (C817 , ( LKer C819 )) );
set D166 = ( VectQuot (C818 , ( RKer C819 )) );
set D167 = ( VectQuot (C818 , ( RKer ( LQForm C819 ) )) );
set D168 = ( VectQuot (C817 , ( LKer ( RQForm C819 ) )) );
set D169 = ( RQForm ( LQForm C819 ) );
set D170 = ( QForm C819 );
set D171 = ( LQForm ( RQForm C819 ) );
thus L629: ( leftker D170 ) c= ( leftker D169 )
proof
let C820 being set;
assume L630: C820 in ( leftker D170 );
consider C821 being (Vector of D165) such that L631: C820 = C821 and L632: (for B403 being (Vector of D166) holds ( D170 . (C821 , B403) ) = ( 0. C816 )) by L630;
L633:
now
let C822 being (Vector of D167);
reconsider D172 = C822 as (Vector of D166) by L602;
thus L634: ( D169 . (C821 , C822) ) = ( D170 . (C821 , D172) ) by L608
.= ( 0. C816 ) by L632;
end;
thus L635: thesis by L633 , L631;
end;

thus L636: ( leftker D169 ) c= ( leftker D170 )
proof
let C823 being set;
assume L637: C823 in ( leftker D169 );
consider C824 being (Vector of D165) such that L638: C823 = C824 and L639: (for B404 being (Vector of D167) holds ( D169 . (C824 , B404) ) = ( 0. C816 )) by L637;
L640:
now
let C825 being (Vector of D166);
reconsider D173 = C825 as (Vector of D167) by L602;
thus L641: ( D170 . (C824 , C825) ) = ( D169 . (C824 , D173) ) by L608
.= ( 0. C816 ) by L639;
end;
thus L642: thesis by L640 , L638;
end;

thus L643: ( rightker D170 ) c= ( rightker D169 )
proof
let C826 being set;
assume L644: C826 in ( rightker D170 );
consider C827 being (Vector of D166) such that L645: C826 = C827 and L646: (for B405 being (Vector of D165) holds ( D170 . (B405 , C827) ) = ( 0. C816 )) by L644;
reconsider D174 = C827 as (Vector of D167) by L602;
L647:
now
let C828 being (Vector of D165);
thus L648: ( D169 . (C828 , D174) ) = ( D170 . (C828 , C827) ) by L608
.= ( 0. C816 ) by L646;
end;
thus L649: thesis by L647 , L645;
end;

thus L650: ( rightker D169 ) c= ( rightker D170 )
proof
let C829 being set;
assume L651: C829 in ( rightker D169 );
consider C830 being (Vector of D167) such that L652: C829 = C830 and L653: (for B406 being (Vector of D165) holds ( D169 . (B406 , C830) ) = ( 0. C816 )) by L651;
reconsider D175 = C830 as (Vector of D166) by L602;
L654:
now
let C831 being (Vector of D165);
thus L655: ( D170 . (C831 , D175) ) = ( D169 . (C831 , C830) ) by L608
.= ( 0. C816 ) by L653;
end;
thus L656: thesis by L654 , L652;
end;

thus L657: ( leftker D170 ) c= ( leftker D171 )
proof
let C832 being set;
assume L658: C832 in ( leftker D170 );
consider C833 being (Vector of D165) such that L659: C832 = C833 and L660: (for B407 being (Vector of D166) holds ( D170 . (C833 , B407) ) = ( 0. C816 )) by L658;
reconsider D176 = C833 as (Vector of D168) by L605;
L661:
now
let C834 being (Vector of D166);
thus L662: ( D171 . (D176 , C834) ) = ( D170 . (C833 , C834) ) by L608
.= ( 0. C816 ) by L660;
end;
thus L663: thesis by L661 , L659;
end;

thus L664: ( leftker D171 ) c= ( leftker D170 )
proof
let C835 being set;
assume L665: C835 in ( leftker D171 );
consider C836 being (Vector of D168) such that L666: C835 = C836 and L667: (for B408 being (Vector of D166) holds ( D171 . (C836 , B408) ) = ( 0. C816 )) by L665;
reconsider D177 = C836 as (Vector of D165) by L605;
L668:
now
let C837 being (Vector of D166);
thus L669: ( D170 . (D177 , C837) ) = ( D171 . (C836 , C837) ) by L608
.= ( 0. C816 ) by L667;
end;
thus L670: thesis by L668 , L666;
end;

thus L671: ( rightker D170 ) c= ( rightker D171 )
proof
let C838 being set;
assume L672: C838 in ( rightker D170 );
consider C839 being (Vector of D166) such that L673: C838 = C839 and L674: (for B409 being (Vector of D165) holds ( D170 . (B409 , C839) ) = ( 0. C816 )) by L672;
L675:
now
let C840 being (Vector of D168);
reconsider D178 = C840 as (Vector of D165) by L605;
thus L676: ( D171 . (C840 , C839) ) = ( D170 . (D178 , C839) ) by L608
.= ( 0. C816 ) by L674;
end;
thus L677: thesis by L675 , L673;
end;

let C841 being set;
assume L678: C841 in ( rightker D171 );
consider C842 being (Vector of D166) such that L679: C841 = C842 and L680: (for B410 being (Vector of D168) holds ( D171 . (B410 , C842) ) = ( 0. C816 )) by L678;
L681:
now
let C843 being (Vector of D165);
reconsider D179 = C843 as (Vector of D168) by L605;
thus L682: ( D170 . (C843 , C842) ) = ( D171 . (D179 , C842) ) by L608
.= ( 0. C816 ) by L680;
end;
thus L683: thesis by L681 , L679;
end;
theorem
L684: (for B411 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B412 , B413 being non  empty VectSpStr over B411 holds (for B414 being (Functional of B412) holds (for B415 being (Functional of B413) holds ( ker B414 ) c= ( leftker ( FormFunctional (B414 , B415) ) )))))
proof
let C844 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C845 , C846 being non  empty VectSpStr over C844;
let C847 being (Functional of C845);
let C848 being (Functional of C846);
set D180 = ( FormFunctional (C847 , C848) );
L685: ( ker C847 ) = { B416 where B416 is (Vector of C845) : ( C847 . B416 ) = ( 0. C844 ) } by VECTSP10:def 9;
let C849 being set;
assume L686: C849 in ( ker C847 );
consider C850 being (Vector of C845) such that L687: C849 = C850 and L688: ( C847 . C850 ) = ( 0. C844 ) by L686 , L685;
L689:
now
let C851 being (Vector of C846);
thus L690: ( D180 . (C850 , C851) ) = ( ( C847 . C850 ) * ( C848 . C851 ) ) by L134
.= ( 0. C844 ) by L688 , VECTSP_1:7;
end;
thus L691: thesis by L689 , L687;
end;
theorem
L692: (for B417 being  add-associative  right_zeroed  right_complementable  associative  commutative  well-unital  almost_left_invertible  distributive non  empty doubleLoopStr holds (for B418 , B419 being non  empty VectSpStr over B417 holds (for B420 being (Functional of B418) holds (for B421 being (Functional of B419) holds (B421 <> ( 0Functional B419 ) implies ( leftker ( FormFunctional (B420 , B421) ) ) = ( ker B420 ))))))
proof
let C852 being  add-associative  right_zeroed  right_complementable  associative  commutative  well-unital  almost_left_invertible  distributive non  empty doubleLoopStr;
let C853 , C854 being non  empty VectSpStr over C852;
let C855 being (Functional of C853);
let C856 being (Functional of C854);
set D181 = ( FormFunctional (C855 , C856) );
assume L693: C856 <> ( 0Functional C854 );
L694: ( ker C855 ) = { B422 where B422 is (Vector of C853) : ( C855 . B422 ) = ( 0. C852 ) } by VECTSP10:def 9;
thus L695: ( leftker D181 ) c= ( ker C855 )
proof
let C857 being set;
assume L696: C857 in ( leftker D181 );
consider C858 being (Vector of C853) such that L697: C857 = C858 and L698: (for B423 being (Vector of C854) holds ( D181 . (C858 , B423) ) = ( 0. C852 )) by L696;
assume L699: (not C857 in ( ker C855 ));
L700: ( C855 . C858 ) <> ( 0. C852 ) by L699 , L694 , L697;
L701:
now
let C859 being (Vector of C854);
L702: ( ( C855 . C858 ) * ( C856 . C859 ) ) = ( D181 . (C858 , C859) ) by L134
.= ( 0. C852 ) by L698;
thus L703: ( C856 . C859 ) = ( 0. C852 ) by L702 , L700 , VECTSP_1:12
.= ( ( 0Functional C854 ) . C859 ) by HAHNBAN1:14;
end;
thus L704: contradiction by L701 , L693 , FUNCT_2:63;
end;

thus L705: thesis by L684;
end;
theorem
L706: (for B424 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B425 , B426 being non  empty VectSpStr over B424 holds (for B427 being (Functional of B425) holds (for B428 being (Functional of B426) holds ( ker B428 ) c= ( rightker ( FormFunctional (B427 , B428) ) )))))
proof
let C860 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C861 , C862 being non  empty VectSpStr over C860;
let C863 being (Functional of C861);
let C864 being (Functional of C862);
set D182 = ( FormFunctional (C863 , C864) );
L707: ( ker C864 ) = { B429 where B429 is (Vector of C862) : ( C864 . B429 ) = ( 0. C860 ) } by VECTSP10:def 9;
let C865 being set;
assume L708: C865 in ( ker C864 );
consider C866 being (Vector of C862) such that L709: C865 = C866 and L710: ( C864 . C866 ) = ( 0. C860 ) by L708 , L707;
L711:
now
let C867 being (Vector of C861);
thus L712: ( D182 . (C867 , C866) ) = ( ( C863 . C867 ) * ( C864 . C866 ) ) by L134
.= ( 0. C860 ) by L710 , VECTSP_1:6;
end;
thus L713: thesis by L711 , L709;
end;
theorem
L714: (for B430 being  add-associative  right_zeroed  right_complementable  associative  commutative  well-unital  almost_left_invertible  distributive non  empty doubleLoopStr holds (for B431 , B432 being non  empty VectSpStr over B430 holds (for B433 being (Functional of B431) holds (for B434 being (Functional of B432) holds (B433 <> ( 0Functional B431 ) implies ( rightker ( FormFunctional (B433 , B434) ) ) = ( ker B434 ))))))
proof
let C868 being  add-associative  right_zeroed  right_complementable  associative  commutative  well-unital  almost_left_invertible  distributive non  empty doubleLoopStr;
let C869 , C870 being non  empty VectSpStr over C868;
let C871 being (Functional of C869);
let C872 being (Functional of C870);
set D183 = ( FormFunctional (C871 , C872) );
assume L715: C871 <> ( 0Functional C869 );
L716: ( ker C872 ) = { B435 where B435 is (Vector of C870) : ( C872 . B435 ) = ( 0. C868 ) } by VECTSP10:def 9;
thus L717: ( rightker D183 ) c= ( ker C872 )
proof
let C873 being set;
assume L718: C873 in ( rightker D183 );
consider C874 being (Vector of C870) such that L719: C873 = C874 and L720: (for B436 being (Vector of C869) holds ( D183 . (B436 , C874) ) = ( 0. C868 )) by L718;
assume L721: (not C873 in ( ker C872 ));
L722: ( C872 . C874 ) <> ( 0. C868 ) by L721 , L716 , L719;
L723:
now
let C875 being (Vector of C869);
L724: ( ( C871 . C875 ) * ( C872 . C874 ) ) = ( D183 . (C875 , C874) ) by L134
.= ( 0. C868 ) by L720;
thus L725: ( C871 . C875 ) = ( 0. C868 ) by L724 , L722 , VECTSP_1:12
.= ( ( 0Functional C869 ) . C875 ) by HAHNBAN1:14;
end;
thus L726: contradiction by L723 , L715 , FUNCT_2:63;
end;

thus L727: thesis by L706;
end;
theorem
L728: (for B437 being  add-associative  right_zeroed  right_complementable  commutative  Abelian  associative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr holds (for B438 being (VectSp of B437) holds (for B439 being non  empty VectSpStr over B437 holds (for B440 being (linear-Functional of B438) holds (for B441 being (Functional of B439) holds (B441 <> ( 0Functional B439 ) implies (( LKer ( FormFunctional (B440 , B441) ) ) = ( Ker B440 ) & ( LQForm ( FormFunctional (B440 , B441) ) ) = ( FormFunctional (( CQFunctional B440 ) , B441) ))))))))
proof
let C876 being  add-associative  right_zeroed  right_complementable  commutative  Abelian  associative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr;
let C877 being (VectSp of C876);
let C878 being non  empty VectSpStr over C876;
let C879 being (linear-Functional of C877);
let C880 being (Functional of C878);
set D184 = ( FormFunctional (C879 , C880) );
set D185 = ( CQFunctional C879 );
set D186 = ( FormFunctional (( CQFunctional C879 ) , C880) );
set D187 = ( VectQuot (C877 , ( LKer D184 )) );
set D188 = ( VectQuot (C877 , ( Ker C879 )) );
assume L729: C880 <> ( 0Functional C878 );
L730: ( leftker D184 ) = ( ker C879 ) by L729 , L692;
L731: (the carrier of ( LKer D184 )) = ( leftker D184 ) by L422;
thus L732: ( LKer D184 ) = ( Ker C879 ) by L731 , L730 , VECTSP10:def 11;
L733:
now
let C881 being set;
assume L734: C881 in ( dom D186 );
consider C882 being (Vector of D188), C883 being (Vector of C878) such that L735: C881 = [ C882 , C883 ] by L734 , DOMAIN_1:1;
consider C884 being (Vector of C877) such that L736: C882 = ( C884 + ( Ker C879 ) ) by VECTSP10:22;
thus L737: ( D186 . C881 ) = ( D186 . (C882 , C883) ) by L735
.= ( ( D185 . C882 ) * ( C880 . C883 ) ) by L134
.= ( ( C879 . C884 ) * ( C880 . C883 ) ) by L736 , VECTSP10:35
.= ( D184 . (C884 , C883) ) by L134
.= ( ( LQForm D184 ) . (C882 , C883) ) by L732 , L736 , L426
.= ( ( LQForm D184 ) . C881 ) by L735;
end;
L738: (( dom ( LQForm D184 ) ) = [: (the carrier of D187) , (the carrier of C878) :] & ( dom D186 ) = [: (the carrier of D188) , (the carrier of C878) :]) by FUNCT_2:def 1;
thus L739: thesis by L738 , L732 , L733 , FUNCT_1:2;
end;
theorem
L740: (for B442 being  add-associative  right_zeroed  right_complementable  commutative  Abelian  associative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr holds (for B443 being non  empty VectSpStr over B442 holds (for B444 being (VectSp of B442) holds (for B445 being (Functional of B443) holds (for B446 being (linear-Functional of B444) holds (B445 <> ( 0Functional B443 ) implies (( RKer ( FormFunctional (B445 , B446) ) ) = ( Ker B446 ) & ( RQForm ( FormFunctional (B445 , B446) ) ) = ( FormFunctional (B445 , ( CQFunctional B446 )) ))))))))
proof
let C885 being  add-associative  right_zeroed  right_complementable  commutative  Abelian  associative  well-unital  distributive  almost_left_invertible non  empty doubleLoopStr;
let C886 being non  empty VectSpStr over C885;
let C887 being (VectSp of C885);
let C888 being (Functional of C886);
let C889 being (linear-Functional of C887);
set D189 = ( FormFunctional (C888 , C889) );
set D190 = ( CQFunctional C889 );
set D191 = ( FormFunctional (C888 , ( CQFunctional C889 )) );
set D192 = ( VectQuot (C887 , ( RKer D189 )) );
set D193 = ( VectQuot (C887 , ( Ker C889 )) );
assume L741: C888 <> ( 0Functional C886 );
L742: ( rightker D189 ) = ( ker C889 ) by L741 , L714;
L743: (the carrier of ( RKer D189 )) = ( rightker D189 ) by L424;
thus L744: ( RKer D189 ) = ( Ker C889 ) by L743 , L742 , VECTSP10:def 11;
L745:
now
let C890 being set;
assume L746: C890 in ( dom D191 );
consider C891 being (Vector of C886), C892 being (Vector of D193) such that L747: C890 = [ C891 , C892 ] by L746 , DOMAIN_1:1;
consider C893 being (Vector of C887) such that L748: C892 = ( C893 + ( Ker C889 ) ) by VECTSP10:22;
thus L749: ( D191 . C890 ) = ( D191 . (C891 , C892) ) by L747
.= ( ( C888 . C891 ) * ( D190 . C892 ) ) by L134
.= ( ( C888 . C891 ) * ( C889 . C893 ) ) by L748 , VECTSP10:35
.= ( D189 . (C891 , C893) ) by L134
.= ( ( RQForm D189 ) . (C891 , C892) ) by L744 , L748 , L462
.= ( ( RQForm D189 ) . C890 ) by L747;
end;
L750: (( dom ( RQForm D189 ) ) = [: (the carrier of C886) , (the carrier of D192) :] & ( dom D191 ) = [: (the carrier of C886) , (the carrier of D193) :]) by FUNCT_2:def 1;
thus L751: thesis by L750 , L744 , L745 , FUNCT_1:2;
end;
theorem
L752: (for B447 being Field holds (for B448 , B449 being non  trivial (VectSp of B447) holds (for B450 being non  constant (linear-Functional of B448) holds (for B451 being non  constant (linear-Functional of B449) holds ( QForm ( FormFunctional (B450 , B451) ) ) = ( FormFunctional (( CQFunctional B450 ) , ( CQFunctional B451 )) )))))
proof
let C894 being Field;
let C895 , C896 being non  trivial (VectSp of C894);
let C897 being non  constant (linear-Functional of C895);
let C898 being non  constant (linear-Functional of C896);
L753: ( CQFunctional C897 ) <> ( 0Functional ( VectQuot (C895 , ( Ker C897 )) ) );
L754: C898 <> ( 0Functional C896 );
L755: ( LQForm ( FormFunctional (C897 , C898) ) ) = ( FormFunctional (( CQFunctional C897 ) , C898) ) by L754 , L728;
thus L756: ( QForm ( FormFunctional (C897 , C898) ) ) = ( RQForm ( LQForm ( FormFunctional (C897 , C898) ) ) ) by L608
.= ( RQForm ( FormFunctional (( CQFunctional C897 ) , C898) ) ) by L754 , L755 , L728
.= ( FormFunctional (( CQFunctional C897 ) , ( CQFunctional C898 )) ) by L753 , L740;
end;
definition
let C899 being ZeroStr;
let C900 , C901 being non  empty VectSpStr over C899;
let C902 being (Form of C900 , C901);
attr C902 is  degenerated-on-left
means
:L757: ( leftker C902 ) <> { ( 0. C900 ) };
attr C902 is  degenerated-on-right
means
:L758: ( rightker C902 ) <> { ( 0. C901 ) };
end;
registration
let C903 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C904 being (VectSp of C903);
let C905 being  right_zeroed non  empty VectSpStr over C903;
let C906 being  additiveSAF  homogeneousSAF (Form of C904 , C905);
cluster ( LQForm C906 ) -> non  degenerated-on-left;
coherence
proof
set D194 = ( LQForm C906 );
set D195 = ( LKer C906 );
set D196 = ( VectQuot (C904 , D195) );
thus L760: ( leftker D194 ) c= { ( 0. D196 ) }
proof
let C907 being set;
assume L761: C907 in ( leftker D194 );
consider C908 being (Vector of D196) such that L762: C907 = C908 and L763: (for B452 being (Vector of C905) holds ( D194 . (C908 , B452) ) = ( 0. C903 )) by L761;
consider C909 being (Vector of C904) such that L764: C908 = ( C909 + D195 ) by VECTSP10:22;
L765:
now
let C910 being (Vector of C905);
thus L766: ( C906 . (C909 , C910) ) = ( D194 . (C908 , C910) ) by L764 , L426
.= ( 0. C903 ) by L763;
end;
L767: C909 in ( leftker C906 ) by L765;
L768: C909 in (the carrier of D195) by L767 , L422;
L769: C909 in D195 by L768 , STRUCT_0:def 5;
L770: ( C909 + D195 ) = (the carrier of D195) by L769 , VECTSP_4:49
.= ( zeroCoset (C904 , D195) ) by VECTSP10:def 4
.= ( 0. D196 ) by VECTSP10:21;
thus L771: thesis by L770 , L762 , L764 , TARSKI:def 1;
end;

let C911 being set;
assume L772: C911 in { ( 0. D196 ) };
L773: C911 = ( 0. D196 ) by L772 , TARSKI:def 1;
L774: (for B453 being (Vector of C905) holds ( D194 . (( 0. D196 ) , B453) ) = ( 0. C903 )) by L286;
thus L775: thesis by L774 , L773;
end;
end;
registration
let C912 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C913 being  right_zeroed non  empty VectSpStr over C912;
let C914 being (VectSp of C912);
let C915 being  additiveFAF  homogeneousFAF (Form of C913 , C914);
cluster ( RQForm C915 ) -> non  degenerated-on-right;
coherence
proof
set D197 = ( RQForm C915 );
set D198 = ( RKer C915 );
set D199 = ( VectQuot (C914 , D198) );
thus L777: ( rightker D197 ) c= { ( 0. D199 ) }
proof
let C916 being set;
assume L778: C916 in ( rightker D197 );
consider C917 being (Vector of D199) such that L779: C916 = C917 and L780: (for B454 being (Vector of C913) holds ( D197 . (B454 , C917) ) = ( 0. C912 )) by L778;
consider C918 being (Vector of C914) such that L781: C917 = ( C918 + D198 ) by VECTSP10:22;
L782:
now
let C919 being (Vector of C913);
thus L783: ( C915 . (C919 , C918) ) = ( D197 . (C919 , C917) ) by L781 , L462
.= ( 0. C912 ) by L780;
end;
L784: C918 in ( rightker C915 ) by L782;
L785: C918 in (the carrier of D198) by L784 , L424;
L786: C918 in D198 by L785 , STRUCT_0:def 5;
L787: ( C918 + D198 ) = (the carrier of D198) by L786 , VECTSP_4:49
.= ( zeroCoset (C914 , D198) ) by VECTSP10:def 4
.= ( 0. D199 ) by VECTSP10:21;
thus L788: thesis by L787 , L779 , L781 , TARSKI:def 1;
end;

let C920 being set;
assume L789: C920 in { ( 0. D199 ) };
L790: C920 = ( 0. D199 ) by L789 , TARSKI:def 1;
L791: (for B455 being (Vector of C913) holds ( D197 . (B455 , ( 0. D199 )) ) = ( 0. C912 )) by L283;
thus L792: thesis by L791 , L790;
end;
end;
registration
let C921 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C922 , C923 being (VectSp of C921);
let C924 being (bilinear-Form of C922 , C923);
cluster ( QForm C924 ) -> non  degenerated-on-left non  degenerated-on-right;
coherence
proof
L794: ( rightker ( RQForm C924 ) ) = { ( 0. ( VectQuot (C923 , ( RKer C924 )) ) ) } by L758;
L795: ( rightker ( LQForm ( RQForm C924 ) ) ) = { ( 0. ( VectQuot (C923 , ( RKer C924 )) ) ) } by L794 , L572;
L796: ( leftker ( LQForm C924 ) ) = { ( 0. ( VectQuot (C922 , ( LKer C924 )) ) ) } by L757;
L797: ( leftker ( RQForm ( LQForm C924 ) ) ) = { ( 0. ( VectQuot (C922 , ( LKer C924 )) ) ) } by L796 , L587;
L798: (( leftker ( RQForm ( LQForm C924 ) ) ) = ( leftker ( QForm C924 ) ) & ( rightker ( LQForm ( RQForm C924 ) ) ) = ( rightker ( QForm C924 ) )) by L628;
thus L799: thesis by L798 , L797 , L795 , L757 , L758;
end;
end;
registration
let C925 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C926 , C927 being (VectSp of C925);
let C928 being (bilinear-Form of C926 , C927);
cluster ( RQForm ( LQForm C928 ) ) -> non  degenerated-on-left non  degenerated-on-right;
coherence
proof
L801: ( leftker ( LQForm C928 ) ) = { ( 0. ( VectQuot (C926 , ( LKer C928 )) ) ) } by L757;
L802: ( leftker ( RQForm ( LQForm C928 ) ) ) = { ( 0. ( VectQuot (C926 , ( LKer C928 )) ) ) } by L801 , L587;
thus L803: thesis by L802 , L757;
end;
cluster ( LQForm ( RQForm C928 ) ) -> non  degenerated-on-left non  degenerated-on-right;
coherence
proof
L804: ( rightker ( RQForm C928 ) ) = { ( 0. ( VectQuot (C927 , ( RKer C928 )) ) ) } by L758;
L805: ( rightker ( LQForm ( RQForm C928 ) ) ) = { ( 0. ( VectQuot (C927 , ( RKer C928 )) ) ) } by L804 , L572;
thus L806: thesis by L805 , L758;
end;
end;
registration
let C929 being Field;
let C930 , C931 being non  trivial (VectSp of C929);
let C932 being non  constant (bilinear-Form of C930 , C931);
cluster ( QForm C932 ) -> non  constant;
coherence
proof
consider C933 being (Vector of C930), C934 being (Vector of C931) such that L808: ( C932 . (C933 , C934) ) <> ( 0. C929 ) by L311;
reconsider D200 = ( C934 + ( RKer C932 ) ) as (Vector of ( VectQuot (C931 , ( RKer C932 )) )) by VECTSP10:23;
reconsider D201 = ( C933 + ( LKer C932 ) ) as (Vector of ( VectQuot (C930 , ( LKer C932 )) )) by VECTSP10:23;
L809: ( ( QForm C932 ) . (D201 , D200) ) = ( C932 . (C933 , C934) ) by L509;
thus L810: thesis by L809 , L808 , L311;
end;
end;
begin
definition
let C935 being 1-sorted;
let C936 being VectSpStr over C935;
let C937 being (Form of C936 , C936);
attr C937 is  symmetric
means
:L812: (for B456 , B457 being (Vector of C936) holds ( C937 . (B456 , B457) ) = ( C937 . (B457 , B456) ));
end;
definition
let C938 being ZeroStr;
let C939 being VectSpStr over C938;
let C940 being (Form of C939 , C939);
attr C940 is  alternating
means
:L814: (for B458 being (Vector of C939) holds ( C940 . (B458 , B458) ) = ( 0. C938 ));
end;
registration
let C941 being non  empty ZeroStr;
let C942 being non  empty VectSpStr over C941;
cluster ( NulForm (C942 , C942) ) ->  symmetric;
coherence
proof
let C943 , C944 being (Vector of C942);
thus L816: ( ( NulForm (C942 , C942) ) . (C943 , C944) ) = ( 0. C941 ) by FUNCOP_1:70
.= ( ( NulForm (C942 , C942) ) . (C944 , C943) ) by FUNCOP_1:70;
end;
cluster ( NulForm (C942 , C942) ) ->  alternating;
coherence
proof
let C945 being (Vector of C942);
thus L817: ( ( NulForm (C942 , C942) ) . (C945 , C945) ) = ( 0. C941 ) by FUNCOP_1:70;
end;
end;
registration
let C946 being non  empty ZeroStr;
let C947 being non  empty VectSpStr over C946;
cluster  symmetric for (Form of C947 , C947);
existence
proof
take ( NulForm (C947 , C947) );
thus L819: thesis;
end;
cluster  alternating for (Form of C947 , C947);
existence
proof
take ( NulForm (C947 , C947) );
thus L820: thesis;
end;
end;
registration
let C948 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C949 being non  empty VectSpStr over C948;
cluster  symmetric  additiveFAF  homogeneousFAF  additiveSAF  homogeneousSAF for (Form of C949 , C949);
existence
proof
take ( NulForm (C949 , C949) );
thus L822: thesis;
end;
cluster  alternating  additiveFAF  homogeneousFAF  additiveSAF  homogeneousSAF for (Form of C949 , C949);
existence
proof
take ( NulForm (C949 , C949) );
thus L823: thesis;
end;
end;
registration
let C950 being Field;
let C951 being non  trivial (VectSp of C950);
cluster  symmetric non  trivial non  constant  additiveFAF  homogeneousFAF  additiveSAF  homogeneousSAF for (Form of C951 , C951);
existence
proof
set D202 = the non  constant non  trivial (linear-Functional of C951);
take D203 = ( FormFunctional (D202 , D202) );
L825:
now
let C952 , C953 being (Vector of C951);
thus L826: ( D203 . (C952 , C953) ) = ( ( D202 . C952 ) * ( D202 . C953 ) ) by L134
.= ( D203 . (C953 , C952) ) by L134;
end;
thus L827: thesis by L825 , L812;
end;
end;
registration
let C954 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C955 being non  empty VectSpStr over C954;
cluster  alternating  additiveFAF  additiveSAF for (Form of C955 , C955);
existence
proof
take ( NulForm (C955 , C955) );
thus L829: thesis;
end;
end;
registration
let C956 being non  empty addLoopStr;
let C957 being non  empty VectSpStr over C956;
let C958 , C959 being  symmetric (Form of C957 , C957);
cluster ( C958 + C959 ) ->  symmetric;
coherence
proof
let C960 , C961 being (Vector of C957);
thus L831: ( ( C958 + C959 ) . (C960 , C961) ) = ( ( C958 . (C960 , C961) ) + ( C959 . (C960 , C961) ) ) by L3
.= ( ( C958 . (C961 , C960) ) + ( C959 . (C960 , C961) ) ) by L812
.= ( ( C958 . (C961 , C960) ) + ( C959 . (C961 , C960) ) ) by L812
.= ( ( C958 + C959 ) . (C961 , C960) ) by L3;
end;
end;
registration
let C962 being non  empty doubleLoopStr;
let C963 being non  empty VectSpStr over C962;
let C964 being  symmetric (Form of C963 , C963);
let C965 being (Element of C962);
cluster ( C965 * C964 ) ->  symmetric;
coherence
proof
let C966 , C967 being (Vector of C963);
thus L833: ( ( C965 * C964 ) . (C966 , C967) ) = ( C965 * ( C964 . (C966 , C967) ) ) by L12
.= ( C965 * ( C964 . (C967 , C966) ) ) by L812
.= ( ( C965 * C964 ) . (C967 , C966) ) by L12;
end;
end;
registration
let C968 being non  empty addLoopStr;
let C969 being non  empty VectSpStr over C968;
let C970 being  symmetric (Form of C969 , C969);
cluster ( - C970 ) ->  symmetric;
coherence
proof
let C971 , C972 being (Vector of C969);
thus L835: ( ( - C970 ) . (C971 , C972) ) = ( - ( C970 . (C971 , C972) ) ) by L21
.= ( - ( C970 . (C972 , C971) ) ) by L812
.= ( ( - C970 ) . (C972 , C971) ) by L21;
end;
end;
registration
let C973 being non  empty addLoopStr;
let C974 being non  empty VectSpStr over C973;
let C975 , C976 being  symmetric (Form of C974 , C974);
cluster ( C975 - C976 ) ->  symmetric;
coherence;
end;
registration
let C977 being  right_zeroed non  empty addLoopStr;
let C978 being non  empty VectSpStr over C977;
let C979 , C980 being  alternating (Form of C978 , C978);
cluster ( C979 + C980 ) ->  alternating;
coherence
proof
let C981 being (Vector of C978);
thus L838: ( ( C979 + C980 ) . (C981 , C981) ) = ( ( C979 . (C981 , C981) ) + ( C980 . (C981 , C981) ) ) by L3
.= ( ( 0. C977 ) + ( C980 . (C981 , C981) ) ) by L814
.= ( ( 0. C977 ) + ( 0. C977 ) ) by L814
.= ( 0. C977 ) by RLVECT_1:def 4;
end;
end;
registration
let C982 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C983 being non  empty VectSpStr over C982;
let C984 being  alternating (Form of C983 , C983);
let C985 being (Scalar of C982);
cluster ( C985 * C984 ) ->  alternating;
coherence
proof
let C986 being (Vector of C983);
thus L840: ( ( C985 * C984 ) . (C986 , C986) ) = ( C985 * ( C984 . (C986 , C986) ) ) by L12
.= ( C985 * ( 0. C982 ) ) by L814
.= ( 0. C982 ) by VECTSP_1:6;
end;
end;
registration
let C987 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C988 being non  empty VectSpStr over C987;
let C989 being  alternating (Form of C988 , C988);
cluster ( - C989 ) ->  alternating;
coherence
proof
let C990 being (Vector of C988);
thus L842: ( ( - C989 ) . (C990 , C990) ) = ( - ( C989 . (C990 , C990) ) ) by L21
.= ( - ( 0. C987 ) ) by L814
.= ( 0. C987 ) by RLVECT_1:12;
end;
end;
registration
let C991 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C992 being non  empty VectSpStr over C991;
let C993 , C994 being  alternating (Form of C992 , C992);
cluster ( C993 - C994 ) ->  alternating;
coherence;
end;
theorem
L845: (for B459 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B460 being non  empty VectSpStr over B459 holds (for B461 being  symmetric (bilinear-Form of B460 , B460) holds ( leftker B461 ) = ( rightker B461 ))))
proof
let C995 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C996 being non  empty VectSpStr over C995;
let C997 being  symmetric (bilinear-Form of C996 , C996);
thus L846: ( leftker C997 ) c= ( rightker C997 )
proof
let C998 being set;
assume L847: C998 in ( leftker C997 );
consider C999 being (Vector of C996) such that L848: C999 = C998 and L849: (for B462 being (Vector of C996) holds ( C997 . (C999 , B462) ) = ( 0. C995 )) by L847;
L850:
now
let C1000 being (Vector of C996);
thus L851: ( C997 . (C1000 , C999) ) = ( C997 . (C999 , C1000) ) by L812
.= ( 0. C995 ) by L849;
end;
thus L852: thesis by L850 , L848;
end;

let C1001 being set;
assume L853: C1001 in ( rightker C997 );
consider C1002 being (Vector of C996) such that L854: C1002 = C1001 and L855: (for B463 being (Vector of C996) holds ( C997 . (B463 , C1002) ) = ( 0. C995 )) by L853;
L856:
now
let C1003 being (Vector of C996);
thus L857: ( C997 . (C1002 , C1003) ) = ( C997 . (C1003 , C1002) ) by L812
.= ( 0. C995 ) by L855;
end;
thus L858: thesis by L856 , L854;
end;
theorem
L859: (for B464 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B465 being non  empty VectSpStr over B464 holds (for B466 being  alternating  additiveSAF  additiveFAF (Form of B465 , B465) holds (for B467 , B468 being (Vector of B465) holds ( B466 . (B467 , B468) ) = ( - ( B466 . (B468 , B467) ) )))))
proof
let C1004 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C1005 being non  empty VectSpStr over C1004;
let C1006 being  alternating  additiveSAF  additiveFAF (Form of C1005 , C1005);
let C1007 , C1008 being (Vector of C1005);
L860: ( 0. C1004 ) = ( C1006 . (( C1007 + C1008 ) , ( C1007 + C1008 )) ) by L814
.= ( ( ( C1006 . (C1007 , C1007) ) + ( C1006 . (C1007 , C1008) ) ) + ( ( C1006 . (C1008 , C1007) ) + ( C1006 . (C1008 , C1008) ) ) ) by L281
.= ( ( ( 0. C1004 ) + ( C1006 . (C1007 , C1008) ) ) + ( ( C1006 . (C1008 , C1007) ) + ( C1006 . (C1008 , C1008) ) ) ) by L814
.= ( ( ( 0. C1004 ) + ( C1006 . (C1007 , C1008) ) ) + ( ( C1006 . (C1008 , C1007) ) + ( 0. C1004 ) ) ) by L814
.= ( ( ( 0. C1004 ) + ( C1006 . (C1007 , C1008) ) ) + ( C1006 . (C1008 , C1007) ) ) by RLVECT_1:def 4
.= ( ( C1006 . (C1007 , C1008) ) + ( C1006 . (C1008 , C1007) ) ) by RLVECT_1:4;
thus L861: thesis by L860 , RLVECT_1:6;
end;
definition
let C1009 being  Fanoian Field;
let C1010 being non  empty VectSpStr over C1009;
let C1011 being  additiveSAF  additiveFAF (Form of C1010 , C1010);
redefine attr C1011 is  alternating
means
(for B469 , B470 being (Vector of C1010) holds ( C1011 . (B469 , B470) ) = ( - ( C1011 . (B470 , B469) ) ));
compatibility
proof
thus L862: (C1011 is  alternating implies (for B471 , B472 being (Vector of C1010) holds ( C1011 . (B471 , B472) ) = ( - ( C1011 . (B472 , B471) ) ))) by L859;
assume L863: (for B473 , B474 being (Vector of C1010) holds ( C1011 . (B473 , B474) ) = ( - ( C1011 . (B474 , B473) ) ));
let C1012 being (Vector of C1010);
L864: ( C1011 . (C1012 , C1012) ) = ( - ( C1011 . (C1012 , C1012) ) ) by L863;
L865: ( ( C1011 . (C1012 , C1012) ) + ( C1011 . (C1012 , C1012) ) ) = ( 0. C1009 ) by L864 , VECTSP_1:16;
thus L866: thesis by L865 , VECTSP_1:def 18;
end;
end;
theorem
L868: (for B475 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr holds (for B476 being non  empty VectSpStr over B475 holds (for B477 being  alternating (bilinear-Form of B476 , B476) holds ( leftker B477 ) = ( rightker B477 ))))
proof
let C1013 being  add-associative  right_zeroed  right_complementable  right-distributive non  empty doubleLoopStr;
let C1014 being non  empty VectSpStr over C1013;
let C1015 being  alternating (bilinear-Form of C1014 , C1014);
thus L869: ( leftker C1015 ) c= ( rightker C1015 )
proof
let C1016 being set;
assume L870: C1016 in ( leftker C1015 );
consider C1017 being (Vector of C1014) such that L871: C1017 = C1016 and L872: (for B478 being (Vector of C1014) holds ( C1015 . (C1017 , B478) ) = ( 0. C1013 )) by L870;
L873:
now
let C1018 being (Vector of C1014);
thus L874: ( C1015 . (C1018 , C1017) ) = ( - ( C1015 . (C1017 , C1018) ) ) by L859
.= ( - ( 0. C1013 ) ) by L872
.= ( 0. C1013 ) by RLVECT_1:12;
end;
thus L875: thesis by L873 , L871;
end;

let C1019 being set;
assume L876: C1019 in ( rightker C1015 );
consider C1020 being (Vector of C1014) such that L877: C1020 = C1019 and L878: (for B479 being (Vector of C1014) holds ( C1015 . (B479 , C1020) ) = ( 0. C1013 )) by L876;
L879:
now
let C1021 being (Vector of C1014);
thus L880: ( C1015 . (C1020 , C1021) ) = ( - ( C1015 . (C1021 , C1020) ) ) by L859
.= ( - ( 0. C1013 ) ) by L878
.= ( 0. C1013 ) by RLVECT_1:12;
end;
thus L881: thesis by L879 , L877;
end;
