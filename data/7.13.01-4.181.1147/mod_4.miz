:: Opposite Rings, Modules and their Morphisms
::  by Micha{\l} Muzalewski
::
:: Received June 22, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, FUNCT_1, ZFMISC_1, RELAT_1, SUBSET_1, ALGSTR_0,
      ARYTM_0, STRUCT_0, MESFUNC1, SUPINF_2, VECTSP_1, RLVECT_1, ARYTM_3,
      ARYTM_1, GROUP_1, BINOP_1, LATTICES, FUNCSDOM, VECTSP_2, MSSUBFAM,
      FDIFF_1, GRCAT_1, GROUP_6, FUNCT_2, MOD_4;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, DOMAIN_1,
      STRUCT_0, ALGSTR_0, BINOP_1, RLVECT_1, GROUP_1, VECTSP_1, FUNCSDOM,
      VECTSP_2, GRCAT_1, FUNCT_4, GROUP_6, RINGCAT1;
 constructors DOMAIN_1, VECTSP_2, GRCAT_1, GROUP_6, RINGCAT1, FUNCOP_1,
      RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, STRUCT_0, VECTSP_1, VECTSP_2,
      ALGSTR_0, GRCAT_1, FUNCT_2, RINGCAT1, FUNCT_1;
 requirements SUBSET, BOOLE;
 definitions RLVECT_1, STRUCT_0, GROUP_1, GROUP_6, GRCAT_1, RINGCAT1, VECTSP_1,
      ALGSTR_0;
 theorems FUNCT_1, FUNCT_2, VECTSP_1, VECTSP_2, FUNCT_4, RLVECT_1, RELAT_1,
      GROUP_1, FUNCOP_1, GROUP_6, ALGSTR_0, STRUCT_0;

begin
registration
let C1 being non  empty addMagma;
cluster ( id C1 ) ->  bijective;
coherence
proof
set D1 = ( id C1 );
L1: ( rng D1 ) = (the carrier of C1) by RELAT_1:45;
L2: D1 is  one-to-one  onto by L1 , FUNCT_2:def 3;
thus L3: thesis by L2;
end;
end;
definition
let R1 being non  empty set;
let R2 being non  empty set;
let R3 being non  empty set;
let R4 being (Function of [: R1 , R2 :] , R3);
redefine func ~ R4 -> (Function of [: R2 , R1 :] , R3);

coherence by FUNCT_4:50;
end;
theorem
L6: (for R1 being non  empty set holds (for R2 being non  empty set holds (for R3 being non  empty set holds (for R4 being (Function of [: R1 , R2 :] , R3) holds (for B1 being (Element of R1) holds (for B2 being (Element of R2) holds ( R4 . (B1 , B2) ) = ( ( ~ R4 ) . (B2 , B1) )))))))
proof
let R1 being non  empty set;
let R2 being non  empty set;
let R3 being non  empty set;
let R4 being (Function of [: R1 , R2 :] , R3);
let C2 being (Element of R1);
let C3 being (Element of R2);
L7: ( dom R4 ) = [: R1 , R2 :] by FUNCT_2:def 1;
L8: [ C2 , C3 ] in ( dom R4 ) by L7;
L9: [ C3 , C2 ] in ( dom ( ~ R4 ) ) by L8 , FUNCT_4:42;
thus L10: thesis by L9 , FUNCT_4:43;
end;
begin
definition
let R5 being non  empty doubleLoopStr;
func opp R5 ->  strict doubleLoopStr equals 
doubleLoopStr (# (the carrier of R5) , (the addF of R5) , ( ~ (the multF of R5) ) , ( 1. R5 ) , ( 0. R5 ) #);
correctness;
end;
registration
let R5 being non  empty doubleLoopStr;
cluster ( opp R5 ) -> non  empty;
coherence;
end;
L13: (for B3 being  well-unital non  empty doubleLoopStr holds (for B4 , B5 being (Element of ( opp B3 )) holds (B5 = ( 1. B3 ) implies (( B4 * B5 ) = B4 & ( B5 * B4 ) = B4))))
proof
let C4 being  well-unital non  empty doubleLoopStr;
let C5 , C6 being (Element of ( opp C4 ));
assume L14: C6 = ( 1. C4 );
reconsider D2 = C5 , D3 = C6 as (Element of C4);
thus L15: ( C5 * C6 ) = ( D3 * D2 ) by L6
.= C5 by L14 , VECTSP_1:def 6;
thus L16: ( C6 * C5 ) = ( D2 * D3 ) by L6
.= C5 by L14 , VECTSP_1:def 6;
end;
registration
let C7 being  well-unital non  empty doubleLoopStr;
cluster ( opp C7 ) ->  well-unital;
coherence
proof
let C8 being (Element of ( opp C7 ));
thus L17: thesis by L13;
end;
end;
L19:
now
let C9 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
set D4 = ( opp C9 );
thus L20: (for B6 , B7 , B8 being (Scalar of D4) holds (( ( B6 + B7 ) + B8 ) = ( B6 + ( B7 + B8 ) ) & ( B6 + ( 0. D4 ) ) = B6))
proof
let C10 , C11 , C12 being (Scalar of D4);
reconsider D5 = C10 , D6 = C11 , D7 = C12 as (Scalar of C9);
thus L21: ( ( C10 + C11 ) + C12 ) = ( ( D5 + D6 ) + D7 )
.= ( D5 + ( D6 + D7 ) ) by RLVECT_1:def 3
.= ( C10 + ( C11 + C12 ) );
thus L22: ( C10 + ( 0. D4 ) ) = ( D5 + ( 0. C9 ) )
.= C10 by RLVECT_1:def 4;
end;

end;
registration
let C13 being  add-associative  right_complementable  right_zeroed non  empty doubleLoopStr;
cluster ( opp C13 ) ->  add-associative  right_zeroed  right_complementable;
coherence
proof
thus L21: (for B9 , B10 , B11 being (Element of ( opp C13 )) holds ( B9 + ( B10 + B11 ) ) = ( ( B9 + B10 ) + B11 )) by L19;
thus L22: (for B12 being (Element of ( opp C13 )) holds ( B12 + ( 0. ( opp C13 ) ) ) = B12) by L19;
let C14 being (Element of ( opp C13 ));
reconsider D8 = C14 as (Element of C13);
reconsider D9 = ( - D8 ) as (Element of ( opp C13 ));
take D9;
thus L23: ( C14 + D9 ) = ( D8 + ( - D8 ) )
.= ( 0. ( opp C13 ) ) by RLVECT_1:5;
end;
end;
L25: (for B13 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for B14 , B15 being (Scalar of B13) holds (for B16 , B17 being (Scalar of ( opp B13 )) holds ((B14 = B16 & B15 = B17) implies (( B14 + B15 ) = ( B16 + B17 ) & ( B14 * B15 ) = ( B17 * B16 ) & ( - B14 ) = ( - B16 ))))))
proof
let C15 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C16 , C17 being (Scalar of C15);
let C18 , C19 being (Scalar of ( opp C15 ));
assume that
L26: C16 = C18
and
L27: C17 = C19;
thus L28: ( C16 + C17 ) = ( C18 + C19 ) by L26 , L27;
thus L29: ( C16 * C17 ) = ( C19 * C18 ) by L26 , L27 , L6;
reconsider D10 = ( - C18 ) as (Element of C15);
L30: ( D10 + C16 ) = ( ( - C18 ) + C18 ) by L26
.= ( 0. ( opp C15 ) ) by RLVECT_1:5
.= ( 0. C15 );
thus L31: thesis by L30 , RLVECT_1:6;
end;
theorem
L32: (for R5 being non  empty doubleLoopStr holds (( the addLoopStr of ( opp R5 ) ) = ( the addLoopStr of R5 ) & (R5 is  add-associative  right_zeroed  right_complementable implies ( comp ( opp R5 ) ) = ( comp R5 )) & (for B18 being set holds (B18 is (Scalar of ( opp R5 )) iff B18 is (Scalar of R5)))))
proof
let R5 being non  empty doubleLoopStr;
thus L33: ( the addLoopStr of ( opp R5 ) ) = ( the addLoopStr of R5 );
thus L34:now
assume L35: R5 is  add-associative  right_zeroed  right_complementable;
L36: (for B19 being set holds (B19 in (the carrier of R5) implies ( ( comp ( opp R5 ) ) . B19 ) = ( ( comp R5 ) . B19 )))
proof
let C20 being set;
assume L37: C20 in (the carrier of R5);
reconsider D11 = C20 as (Element of R5) by L37;
reconsider D12 = D11 as (Element of ( opp R5 ));
L38: ( - D11 ) = ( - D12 ) by L35 , L25;
thus L39: ( ( comp ( opp R5 ) ) . C20 ) = ( - D12 ) by VECTSP_1:def 13
.= ( ( comp R5 ) . C20 ) by L38 , VECTSP_1:def 13;
end;
L40: (( dom ( comp ( opp R5 ) ) ) = (the carrier of R5) & ( dom ( comp R5 ) ) = (the carrier of R5)) by FUNCT_2:def 1;
thus L41: ( comp ( opp R5 ) ) = ( comp R5 ) by L40 , L36 , FUNCT_1:2;
end;
let C21 being set;
thus L42: thesis;
end;
L43: (for B20 being non  empty doubleLoopStr holds (for B21 , B22 , B23 , B24 being (Scalar of B20) holds (for B25 , B26 , B27 , B28 being (Scalar of ( opp B20 )) holds ((B21 = B25 & B22 = B26 & B23 = B27 & B24 = B28) implies (( ( B21 + B22 ) + B23 ) = ( ( B25 + B26 ) + B27 ) & ( B21 + ( B22 + B23 ) ) = ( B25 + ( B26 + B27 ) ) & ( ( B21 * B22 ) * B23 ) = ( B27 * ( B26 * B25 ) ) & ( B21 * ( B22 * B23 ) ) = ( ( B27 * B26 ) * B25 ) & ( B21 * ( B22 + B23 ) ) = ( ( B26 + B27 ) * B25 ) & ( ( B22 + B23 ) * B21 ) = ( B25 * ( B26 + B27 ) ) & ( ( B21 * B22 ) + ( B23 * B24 ) ) = ( ( B26 * B25 ) + ( B28 * B27 ) ))))))
proof
let C22 being non  empty doubleLoopStr;
let C23 , C24 , C25 , C26 being (Scalar of C22);
let C27 , C28 , C29 , C30 being (Scalar of ( opp C22 ));
assume that
L44: (C23 = C27 & C24 = C28 & C25 = C29)
and
L45: C26 = C30;
L46: (( C23 * C24 ) = ( C28 * C27 ) & ( C24 * C25 ) = ( C29 * C28 )) by L44 , L6;
thus L47: thesis by L46 , L44 , L45 , L6;
end;
theorem
L48: ((for B29 being  unital non  empty doubleLoopStr holds ( 1. B29 ) = ( 1. ( opp B29 ) )) & (for B30 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (( 0. B30 ) = ( 0. ( opp B30 ) ) & (for B31 , B32 , B33 , B34 being (Scalar of B30) holds (for B35 , B36 , B37 , B38 being (Scalar of ( opp B30 )) holds ((B31 = B35 & B32 = B36 & B33 = B37 & B34 = B38) implies (( B31 + B32 ) = ( B35 + B36 ) & ( B31 * B32 ) = ( B36 * B35 ) & ( - B31 ) = ( - B35 ) & ( ( B31 + B32 ) + B33 ) = ( ( B35 + B36 ) + B37 ) & ( B31 + ( B32 + B33 ) ) = ( B35 + ( B36 + B37 ) ) & ( ( B31 * B32 ) * B33 ) = ( B37 * ( B36 * B35 ) ) & ( B31 * ( B32 * B33 ) ) = ( ( B37 * B36 ) * B35 ) & ( B31 * ( B32 + B33 ) ) = ( ( B36 + B37 ) * B35 ) & ( ( B32 + B33 ) * B31 ) = ( B35 * ( B36 + B37 ) ) & ( ( B31 * B32 ) + ( B33 * B34 ) ) = ( ( B36 * B35 ) + ( B38 * B37 ) )))))))) by L25 , L43;
registration
let C31 being  Abelian non  empty doubleLoopStr;
cluster ( opp C31 ) ->  Abelian;
coherence
proof
let C32 , C33 being (Element of ( opp C31 ));
reconsider D13 = C32 , D14 = C33 as (Element of C31);
thus L49: ( C32 + C33 ) = ( D13 + D14 )
.= ( D14 + D13 )
.= ( C33 + C32 );
end;
end;
registration
let C34 being  add-associative non  empty doubleLoopStr;
cluster ( opp C34 ) ->  add-associative;
coherence
proof
let C35 , C36 , C37 being (Element of ( opp C34 ));
reconsider D15 = C35 , D16 = C36 , D17 = C37 as (Element of C34);
thus L51: ( ( C35 + C36 ) + C37 ) = ( ( D15 + D16 ) + D17 )
.= ( D15 + ( D16 + D17 ) ) by RLVECT_1:def 3
.= ( C35 + ( C36 + C37 ) );
end;
end;
registration
let C38 being  right_zeroed non  empty doubleLoopStr;
cluster ( opp C38 ) ->  right_zeroed;
coherence
proof
let C39 being (Element of ( opp C38 ));
reconsider D18 = C39 as (Element of C38);
thus L53: ( C39 + ( 0. ( opp C38 ) ) ) = ( D18 + ( 0. C38 ) )
.= C39 by RLVECT_1:def 4;
end;
end;
registration
let C40 being  right_complementable non  empty doubleLoopStr;
cluster ( opp C40 ) ->  right_complementable;
coherence
proof
let C41 being (Element of ( opp C40 ));
reconsider D19 = C41 as (Element of C40);
consider C42 being (Element of C40) such that L55: ( D19 + C42 ) = ( 0. C40 ) by ALGSTR_0:def 11;
reconsider D20 = C42 as (Element of ( opp C40 ));
take D20;
thus L56: thesis by L55;
end;
end;
registration
let C43 being  associative non  empty doubleLoopStr;
cluster ( opp C43 ) ->  associative;
coherence
proof
let C44 , C45 , C46 being (Element of ( opp C43 ));
reconsider D21 = C44 , D22 = C45 , D23 = C46 as (Element of C43);
thus L58: ( ( C44 * C45 ) * C46 ) = ( D23 * ( D22 * D21 ) ) by L43
.= ( ( D23 * D22 ) * D21 ) by GROUP_1:def 3
.= ( C44 * ( C45 * C46 ) ) by L43;
end;
end;
registration
let C47 being  distributive non  empty doubleLoopStr;
cluster ( opp C47 ) ->  distributive;
coherence
proof
let C48 , C49 , C50 being (Element of ( opp C47 ));
reconsider D24 = C48 , D25 = C49 , D26 = C50 as (Element of C47);
thus L60: ( C48 * ( C49 + C50 ) ) = ( ( D25 + D26 ) * D24 ) by L43
.= ( ( D25 * D24 ) + ( D26 * D24 ) ) by VECTSP_1:def 7
.= ( ( C48 * C49 ) + ( C48 * C50 ) ) by L43;
thus L61: ( ( C49 + C50 ) * C48 ) = ( D24 * ( D25 + D26 ) ) by L43
.= ( ( D24 * D25 ) + ( D24 * D26 ) ) by VECTSP_1:def 7
.= ( ( C49 * C48 ) + ( C50 * C48 ) ) by L43;
end;
end;
theorem
L63: (for B39 being Ring holds ( opp B39 ) is  strict  strict  strict  strict Ring);
theorem
L64: (for B40 being Skew-Field holds ( opp B40 ) is Skew-Field)
proof
let C51 being Skew-Field;
set D27 = ( opp C51 );
L65: (for B41 being (Scalar of D27) holds ((B41 <> ( 0. D27 ) implies (ex B42 being (Scalar of D27) st ( B42 * B41 ) = ( 1_ D27 ))) & ( 0. D27 ) <> ( 1_ D27 )))
proof
let C52 being (Scalar of D27);
L66: (C52 <> ( 0. D27 ) implies (ex B43 being (Scalar of D27) st ( B43 * C52 ) = ( 1_ D27 )))
proof
reconsider D28 = C52 as (Scalar of C51);
assume L67: C52 <> ( 0. D27 );
consider C53 being (Scalar of C51) such that L68: ( D28 * C53 ) = ( 1_ C51 ) by L67 , VECTSP_2:6;
reconsider D29 = C53 as (Scalar of ( opp C51 ));
take D29;
thus L69: thesis by L68 , L25;
end;
thus L70: thesis by L66;
end;
thus L71: thesis by L65 , STRUCT_0:def 8 , VECTSP_1:def 9;
end;
registration
let C54 being Skew-Field;
cluster ( opp C54 ) -> non  degenerated  almost_left_invertible  associative  Abelian  add-associative  right_zeroed  right_complementable  unital  distributive;
coherence by L64;
end;
L73: (for B44 being  commutative non  empty doubleLoopStr holds (for B45 , B46 being (Element of B44) holds ( B45 * B46 ) = ( B46 * B45 )));
theorem
L74: (for B47 being Field holds ( opp B47 ) is  strict  strict  strict  strict Field)
proof
let C55 being Field;
set D30 = ( opp C55 );
L75: (for B48 , B49 being (Scalar of D30) holds ( B48 * B49 ) = ( B49 * B48 ))
proof
let C56 , C57 being (Scalar of D30);
reconsider D31 = C56 , D32 = C57 as (Scalar of C55);
L76: ( D32 * D31 ) = ( C56 * C57 ) by L25;
thus L77: thesis by L76 , L25;
end;
thus L78: thesis by L75 , GROUP_1:def 12;
end;
registration
let C58 being Field;
cluster ( opp C58 ) ->  almost_left_invertible;
coherence;
end;
begin
definition
let R5 being non  empty doubleLoopStr;
let R6 being non  empty VectSpStr over R5;
func opp R6 ->  strict RightModStr over ( opp R5 ) means 
:L80: (for B50 being (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6)) holds (B50 = ( ~ (the lmult of R6) ) implies it = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , B50 #)));
existence
proof
reconsider D33 = ( ~ (the lmult of R6) ) as (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6));
take RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , D33 #);
thus L81: thesis;
end;
uniqueness
proof
reconsider D34 = ( ~ (the lmult of R6) ) as (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6));
let C59 , C60 being  strict RightModStr over ( opp R5 );
assume that
L82: (for B51 being (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6)) holds (B51 = ( ~ (the lmult of R6) ) implies C59 = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , B51 #)))
and
L83: (for B52 being (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6)) holds (B52 = ( ~ (the lmult of R6) ) implies C60 = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , B52 #)));
thus L84: C59 = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , D34 #) by L82
.= C60 by L83;
end;
end;
registration
let R5 being non  empty doubleLoopStr;
let R6 being non  empty VectSpStr over R5;
cluster ( opp R6 ) -> non  empty;
coherence
proof
reconsider D35 = ( ~ (the lmult of R6) ) as (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6));
L86: ( opp R6 ) = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , D35 #) by L80;
thus L87: (the carrier of ( opp R6 )) is non  empty by L86;
end;
end;
theorem
L89: (for R5 being non  empty doubleLoopStr holds (for R6 being non  empty VectSpStr over R5 holds (( the addLoopStr of ( opp R6 ) ) = ( the addLoopStr of R6 ) & (for B53 being set holds (B53 is (Vector of R6) iff B53 is (Vector of ( opp R6 )))))))
proof
let R5 being non  empty doubleLoopStr;
let R6 being non  empty VectSpStr over R5;
reconsider D36 = ( ~ (the lmult of R6) ) as (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6));
L90: ( opp R6 ) = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , D36 #) by L80;
thus L91: ( the addLoopStr of ( opp R6 ) ) = ( the addLoopStr of R6 ) by L90;
let C61 being set;
thus L92: thesis by L90;
end;
definition
let R5 being non  empty doubleLoopStr;
let R6 being non  empty VectSpStr over R5;
let C62 being (Function of [: (the carrier of R5) , (the carrier of R6) :] , (the carrier of R6));
func opp C62 -> (Function of [: (the carrier of ( opp R6 )) , (the carrier of ( opp R5 )) :] , (the carrier of ( opp R6 ))) equals 
( ~ C62 );
coherence
proof
L93: ( the addLoopStr of ( opp R6 ) ) = ( the addLoopStr of R6 ) by L89;
thus L94: thesis by L93;
end;
end;
theorem
L96: (for R5 being non  empty doubleLoopStr holds (for R6 being non  empty VectSpStr over R5 holds (the rmult of ( opp R6 )) = ( opp (the lmult of R6) )))
proof
let R5 being non  empty doubleLoopStr;
let R6 being non  empty VectSpStr over R5;
reconsider D37 = ( ~ (the lmult of R6) ) as (Function of [: (the carrier of R6) , (the carrier of ( opp R5 )) :] , (the carrier of R6));
L97: ( opp R6 ) = RightModStr (# (the carrier of R6) , (the addF of R6) , ( 0. R6 ) , D37 #) by L80;
thus L98: thesis by L97;
end;
definition
let R5 being non  empty doubleLoopStr;
let R7 being non  empty RightModStr over R5;
func opp R7 ->  strict VectSpStr over ( opp R5 ) means 
:L99: (for B54 being (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7)) holds (B54 = ( ~ (the rmult of R7) ) implies it = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , B54 #)));
existence
proof
reconsider D38 = ( ~ (the rmult of R7) ) as (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7));
take VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , D38 #);
thus L100: thesis;
end;
uniqueness
proof
reconsider D39 = ( ~ (the rmult of R7) ) as (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7));
let C63 , C64 being  strict VectSpStr over ( opp R5 );
assume that
L101: (for B55 being (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7)) holds (B55 = ( ~ (the rmult of R7) ) implies C63 = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , B55 #)))
and
L102: (for B56 being (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7)) holds (B56 = ( ~ (the rmult of R7) ) implies C64 = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , B56 #)));
thus L103: C63 = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , D39 #) by L101
.= C64 by L102;
end;
end;
registration
let R5 being non  empty doubleLoopStr;
let R7 being non  empty RightModStr over R5;
cluster ( opp R7 ) -> non  empty;
coherence
proof
reconsider D40 = ( ~ (the rmult of R7) ) as (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7));
L105: ( opp R7 ) = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , D40 #) by L99;
thus L106: (the carrier of ( opp R7 )) is non  empty by L105;
end;
end;
theorem
L108: (for R5 being non  empty doubleLoopStr holds (for R7 being non  empty RightModStr over R5 holds (( the addLoopStr of ( opp R7 ) ) = ( the addLoopStr of R7 ) & (for B57 being set holds (B57 is (Vector of R7) iff B57 is (Vector of ( opp R7 )))))))
proof
let R5 being non  empty doubleLoopStr;
let R7 being non  empty RightModStr over R5;
reconsider D41 = ( ~ (the rmult of R7) ) as (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7));
L109: ( opp R7 ) = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , D41 #) by L99;
thus L110: ( the addLoopStr of ( opp R7 ) ) = ( the addLoopStr of R7 ) by L109;
let C65 being set;
thus L111: thesis by L109;
end;
definition
let R5 being non  empty doubleLoopStr;
let R7 being non  empty RightModStr over R5;
let C66 being (Function of [: (the carrier of R7) , (the carrier of R5) :] , (the carrier of R7));
func opp C66 -> (Function of [: (the carrier of ( opp R5 )) , (the carrier of ( opp R7 )) :] , (the carrier of ( opp R7 ))) equals 
( ~ C66 );
coherence
proof
L112: ( the addLoopStr of ( opp R7 ) ) = ( the addLoopStr of R7 ) by L108;
reconsider D42 = ( ~ C66 ) as (Function of [: (the carrier of ( opp R5 )) , (the carrier of ( opp R7 )) :] , (the carrier of ( opp R7 ))) by L112;
L113: D42 is (Function of [: (the carrier of ( opp R5 )) , (the carrier of ( opp R7 )) :] , (the carrier of ( opp R7 )));
thus L114: thesis by L113;
end;
end;
theorem
L116: (for R5 being non  empty doubleLoopStr holds (for R7 being non  empty RightModStr over R5 holds (the lmult of ( opp R7 )) = ( opp (the rmult of R7) )))
proof
let R5 being non  empty doubleLoopStr;
let R7 being non  empty RightModStr over R5;
reconsider D43 = ( ~ (the rmult of R7) ) as (Function of [: (the carrier of ( opp R5 )) , (the carrier of R7) :] , (the carrier of R7));
L117: ( opp R7 ) = VectSpStr (# (the carrier of R7) , (the addF of R7) , ( 0. R7 ) , D43 #) by L99;
thus L118: thesis by L117;
end;
theorem
L119: (for R5 being non  empty doubleLoopStr holds (for R6 being non  empty VectSpStr over R5 holds (for B58 being (Function of [: (the carrier of R5) , (the carrier of R6) :] , (the carrier of R6)) holds (for B59 being (Scalar of R5) holds (for B60 being (Scalar of ( opp R5 )) holds (for B61 being (Vector of R6) holds (for B62 being (Vector of ( opp R6 )) holds ((B59 = B60 & B61 = B62) implies ( ( opp B58 ) . (B62 , B60) ) = ( B58 . (B59 , B61) ))))))))) by L6;
theorem
L120: (for B63 , B64 being Ring holds (for B65 being non  empty VectSpStr over B63 holds (for B66 being non  empty RightModStr over B64 holds (for B67 being (Scalar of B63) holds (for B68 being (Scalar of B64) holds (for B69 being (Vector of B65) holds (for B70 being (Vector of B66) holds ((B64 = ( opp B63 ) & B66 = ( opp B65 ) & B67 = B68 & B69 = B70) implies ( B70 * B68 ) = ( B67 * B69 )))))))))
proof
let C67 , C68 being Ring;
let C69 being non  empty VectSpStr over C67;
let C70 being non  empty RightModStr over C68;
let C71 being (Scalar of C67);
let C72 being (Scalar of C68);
let C73 being (Vector of C69);
let C74 being (Vector of C70);
assume that
L121: (C68 = ( opp C67 ) & C70 = ( opp C69 ))
and
L122: (C71 = C72 & C73 = C74);
set D44 = (the lmult of C69);
L123: ( opp D44 ) = (the rmult of ( opp C69 )) by L96;
thus L124: ( C74 * C72 ) = ( ( opp D44 ) . (C74 , C72) ) by L123 , L121 , VECTSP_2:def 7
.= ( C71 * C73 ) by L122 , L6;
end;
theorem
L125: (for B71 , B72 being Ring holds (for B73 being non  empty VectSpStr over B71 holds (for B74 being non  empty RightModStr over B72 holds (for B75 , B76 being (Vector of B73) holds (for B77 , B78 being (Vector of B74) holds ((B74 = ( opp B73 ) & B75 = B77 & B76 = B78) implies ( B77 + B78 ) = ( B75 + B76 )))))))
proof
let C75 , C76 being Ring;
let C77 being non  empty VectSpStr over C75;
L126: ( the addLoopStr of ( opp C77 ) ) = ( the addLoopStr of C77 ) by L89;
let C78 being non  empty RightModStr over C76;
let C79 , C80 being (Vector of C77);
let C81 , C82 being (Vector of C78);
assume L127: (C78 = ( opp C77 ) & C79 = C81 & C80 = C82);
thus L128: thesis by L127 , L126;
end;
theorem
L129: (for R5 being non  empty doubleLoopStr holds (for R7 being non  empty RightModStr over R5 holds (for B79 being (Function of [: (the carrier of R7) , (the carrier of R5) :] , (the carrier of R7)) holds (for B80 being (Scalar of R5) holds (for B81 being (Scalar of ( opp R5 )) holds (for B82 being (Vector of R7) holds (for B83 being (Vector of ( opp R7 )) holds ((B80 = B81 & B82 = B83) implies ( ( opp B79 ) . (B81 , B83) ) = ( B79 . (B82 , B80) ))))))))) by L6;
theorem
L130: (for B84 , B85 being Ring holds (for B86 being non  empty VectSpStr over B84 holds (for B87 being non  empty RightModStr over B85 holds (for B88 being (Scalar of B84) holds (for B89 being (Scalar of B85) holds (for B90 being (Vector of B86) holds (for B91 being (Vector of B87) holds ((B86 = ( opp B87 ) & B88 = B89 & B90 = B91) implies ( B91 * B89 ) = ( B88 * B90 )))))))))
proof
let C83 , C84 being Ring;
let C85 being non  empty VectSpStr over C83;
let C86 being non  empty RightModStr over C84;
let C87 being (Scalar of C83);
let C88 being (Scalar of C84);
let C89 being (Vector of C85);
let C90 being (Vector of C86);
assume that
L131: (C85 = ( opp C86 ) & C87 = C88 & C89 = C90);
set D45 = (the rmult of C86);
L132: ( opp D45 ) = (the lmult of ( opp C86 )) by L116;
thus L133: ( C90 * C88 ) = ( D45 . (C90 , C88) ) by VECTSP_2:def 7
.= ( C87 * C89 ) by L131 , L132 , L6;
end;
theorem
L134: (for B92 , B93 being Ring holds (for B94 being non  empty VectSpStr over B92 holds (for B95 being non  empty RightModStr over B93 holds (for B96 , B97 being (Vector of B94) holds (for B98 , B99 being (Vector of B95) holds ((B94 = ( opp B95 ) & B96 = B98 & B97 = B99) implies ( B98 + B99 ) = ( B96 + B97 )))))))
proof
let C91 , C92 being Ring;
let C93 being non  empty VectSpStr over C91;
let C94 being non  empty RightModStr over C92;
L135: ( the addLoopStr of ( opp C94 ) ) = ( the addLoopStr of C94 ) by L108;
let C95 , C96 being (Vector of C93);
let C97 , C98 being (Vector of C94);
assume L136: (C93 = ( opp C94 ) & C95 = C97 & C96 = C98);
thus L137: thesis by L136 , L135;
end;
theorem
L138: (for B100 being  strict non  empty doubleLoopStr holds (for B101 being non  empty VectSpStr over B100 holds ( opp ( opp B101 ) ) = ( the VectSpStr of B101 )))
proof
let C99 being  strict non  empty doubleLoopStr;
let C100 being non  empty VectSpStr over C99;
set D46 = ( opp C100 );
L139: ( opp ( opp C99 ) ) = C99 by FUNCT_4:53;
L140: ( opp (the rmult of D46) ) = ( opp ( opp (the lmult of C100) ) ) by L96
.= (the lmult of C100) by FUNCT_4:53;
L141: ( the addLoopStr of ( opp D46 ) ) = ( the addLoopStr of D46 ) by L108
.= ( the addLoopStr of C100 ) by L89;
thus L142: thesis by L141 , L140 , L139 , L116;
end;
theorem
L143: (for B102 being  strict non  empty doubleLoopStr holds (for B103 being non  empty RightModStr over B102 holds ( opp ( opp B103 ) ) = ( the RightModStr of B103 )))
proof
let C101 being  strict non  empty doubleLoopStr;
let C102 being non  empty RightModStr over C101;
set D47 = ( opp C102 );
L144: ( opp ( opp C101 ) ) = C101 by FUNCT_4:53;
L145: ( opp (the lmult of D47) ) = ( opp ( opp (the rmult of C102) ) ) by L116
.= (the rmult of C102) by FUNCT_4:53;
L146: ( the addLoopStr of ( opp D47 ) ) = ( the addLoopStr of D47 ) by L89
.= ( the addLoopStr of C102 ) by L108;
thus L147: thesis by L146 , L145 , L144 , L96;
end;
theorem
L148: (for B104 being Ring holds (for B105 being (LeftMod of B104) holds ( opp B105 ) is  strict  strict  strict  strict (RightMod of ( opp B104 ))))
proof
let C103 being Ring;
let C104 being (LeftMod of C103);
set D48 = ( opp C103 );
reconsider D49 = ( opp C104 ) as non  empty RightModStr over D48;
L149: ( the addLoopStr of ( opp C104 ) ) = ( the addLoopStr of C104 ) by L89;
L150: (for B106 , B107 being (Element of ( opp C104 )) holds (for B108 , B109 being (Element of C104) holds ((B108 = B106 & B107 = B109) implies ( B106 + B107 ) = ( B108 + B109 )))) by L149;
L151: ( opp C104 ) is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus L152: ( opp C104 ) is  Abelian
proof
let C105 , C106 being (Element of ( opp C104 ));
reconsider D50 = C105 , D51 = C106 as (Element of C104) by L89;
thus L153: ( C105 + C106 ) = ( D51 + D50 ) by L150
.= ( C106 + C105 ) by L149;
end;

thus L154:now
let C107 , C108 , C109 being (Element of ( opp C104 ));
reconsider D52 = C107 , D53 = C108 , D54 = C109 as (Element of C104) by L89;
thus L155: ( ( C107 + C108 ) + C109 ) = ( ( D52 + D53 ) + D54 ) by L149
.= ( D52 + ( D53 + D54 ) ) by RLVECT_1:def 3
.= ( C107 + ( C108 + C109 ) ) by L149;
end;
thus L156:now
let C110 being (Element of ( opp C104 ));
reconsider D55 = C110 as (Element of C104) by L89;
thus L157: ( C110 + ( 0. ( opp C104 ) ) ) = ( D55 + ( 0. C104 ) ) by L149
.= C110 by RLVECT_1:4;
end;
let C111 being (Element of ( opp C104 ));
reconsider D56 = C111 as (Element of C104) by L89;
consider C112 being (Element of C104) such that L158: ( D56 + C112 ) = ( 0. C104 ) by ALGSTR_0:def 11;
reconsider D57 = C112 as (Element of ( opp C104 )) by L89;
take D57;
thus L159: thesis by L149 , L158;
end;
L160:
now
let C113 , C114 being (Scalar of D48);
let C115 , C116 being (Vector of D49);
reconsider D58 = C115 , D59 = C116 as (Vector of C104) by L89;
reconsider D60 = C113 , D61 = C114 as (Scalar of C103);
L161: ( D61 * D58 ) = ( C115 * C114 ) by L120;
L162: ( D60 * D59 ) = ( C116 * C113 ) by L120;
L163: ( D60 * D58 ) = ( C115 * C113 ) by L120;
L164: ( C115 + C116 ) = ( D58 + D59 ) by L125;
thus L165: ( ( C115 + C116 ) * C113 ) = ( D60 * ( D58 + D59 ) ) by L164 , L120
.= ( ( D60 * D58 ) + ( D60 * D59 ) ) by VECTSP_1:def 14
.= ( ( C115 * C113 ) + ( C116 * C113 ) ) by L163 , L162 , L125;
thus L166: ( C115 * ( C113 + C114 ) ) = ( ( D60 + D61 ) * D58 ) by L120
.= ( ( D60 * D58 ) + ( D61 * D58 ) ) by VECTSP_1:def 15
.= ( ( C115 * C113 ) + ( C115 * C114 ) ) by L161 , L163 , L125;
thus L167: ( C115 * ( C114 * C113 ) ) = ( ( D60 * D61 ) * D58 ) by L25 , L120
.= ( D60 * ( D61 * D58 ) ) by VECTSP_1:def 16
.= ( ( C115 * C114 ) * C113 ) by L161 , L120;
thus L168: ( C115 * ( 1_ D48 ) ) = ( ( 1_ C103 ) * D58 ) by L120
.= C115 by VECTSP_1:def 17;
end;
thus L169: thesis by L160 , L151 , VECTSP_2:def 9;
end;
registration
let C117 being Ring;
let C118 being (LeftMod of C117);
cluster ( opp C118 ) ->  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like;
coherence by L148;
end;
theorem
L171: (for B110 being Ring holds (for B111 being (RightMod of B110) holds ( opp B111 ) is  strict  strict  strict  strict (LeftMod of ( opp B110 ))))
proof
let C119 being Ring;
let C120 being (RightMod of C119);
set D62 = ( opp C119 );
reconsider D63 = ( opp C120 ) as non  empty VectSpStr over D62;
L172: ( the addLoopStr of ( opp C120 ) ) = ( the addLoopStr of C120 ) by L108;
L173: (for B112 , B113 being (Element of ( opp C120 )) holds (for B114 , B115 being (Element of C120) holds ((B114 = B112 & B113 = B115) implies ( B112 + B113 ) = ( B114 + B115 )))) by L172;
L174: ( opp C120 ) is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus L175: ( opp C120 ) is  Abelian
proof
let C121 , C122 being (Element of ( opp C120 ));
reconsider D64 = C121 , D65 = C122 as (Element of C120) by L108;
thus L176: ( C121 + C122 ) = ( D65 + D64 ) by L173
.= ( C122 + C121 ) by L172;
end;

thus L177:now
let C123 , C124 , C125 being (Element of ( opp C120 ));
reconsider D66 = C123 , D67 = C124 , D68 = C125 as (Element of C120) by L108;
thus L178: ( ( C123 + C124 ) + C125 ) = ( ( D66 + D67 ) + D68 ) by L172
.= ( D66 + ( D67 + D68 ) ) by RLVECT_1:def 3
.= ( C123 + ( C124 + C125 ) ) by L172;
end;
thus L179:now
let C126 being (Element of ( opp C120 ));
reconsider D69 = C126 as (Element of C120) by L108;
thus L180: ( C126 + ( 0. ( opp C120 ) ) ) = ( D69 + ( 0. C120 ) ) by L172
.= C126 by RLVECT_1:4;
end;
let C127 being (Element of ( opp C120 ));
reconsider D70 = C127 as (Element of C120) by L108;
consider C128 being (Element of C120) such that L181: ( D70 + C128 ) = ( 0. C120 ) by ALGSTR_0:def 11;
reconsider D71 = C128 as (Element of ( opp C120 )) by L108;
take D71;
thus L182: thesis by L172 , L181;
end;
L183:
now
let C129 , C130 being (Scalar of D62);
let C131 , C132 being (Vector of D63);
reconsider D72 = C131 , D73 = C132 as (Vector of C120) by L108;
reconsider D74 = C129 , D75 = C130 as (Scalar of C119);
L184: ( D72 * D75 ) = ( C130 * C131 ) by L130;
L185: ( D73 * D74 ) = ( C129 * C132 ) by L130;
L186: ( D72 * D74 ) = ( C129 * C131 ) by L130;
L187: ( C131 + C132 ) = ( D72 + D73 ) by L134;
thus L188: ( C129 * ( C131 + C132 ) ) = ( ( D72 + D73 ) * D74 ) by L187 , L130
.= ( ( D72 * D74 ) + ( D73 * D74 ) ) by VECTSP_2:def 9
.= ( ( C129 * C131 ) + ( C129 * C132 ) ) by L186 , L185 , L134;
thus L189: ( ( C129 + C130 ) * C131 ) = ( D72 * ( D74 + D75 ) ) by L130
.= ( ( D72 * D74 ) + ( D72 * D75 ) ) by VECTSP_2:def 9
.= ( ( C129 * C131 ) + ( C130 * C131 ) ) by L184 , L186 , L134;
L190: ( C129 * C130 ) = ( D75 * D74 ) by L25;
thus L191: ( ( C129 * C130 ) * C131 ) = ( D72 * ( D75 * D74 ) ) by L190 , L130
.= ( ( D72 * D75 ) * D74 ) by VECTSP_2:def 9
.= ( C129 * ( C130 * C131 ) ) by L184 , L130;
thus L192: ( ( 1_ D62 ) * C131 ) = ( D72 * ( 1_ C119 ) ) by L130
.= C131 by VECTSP_2:def 9;
end;
thus L193: thesis by L183 , L174 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
registration
let C133 being Ring;
let C134 being (RightMod of C133);
cluster ( opp C134 ) ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence by L171;
end;
begin
definition
let C135 , C136 being non  empty multMagma;
let C137 being (Function of C135 , C136);
attr C137 is  antimultiplicative
means
:L195: (for B116 , B117 being (Scalar of C135) holds ( C137 . ( B116 * B117 ) ) = ( ( C137 . B117 ) * ( C137 . B116 ) ));
end;
definition
let C138 , C139 being non  empty doubleLoopStr;
let C140 being (Function of C138 , C139);
attr C140 is  antilinear
means
:L197: C140 is  additive  antimultiplicative  unity-preserving;
end;
registration
let C141 , C142 being non  empty doubleLoopStr;
cluster  antilinear ->  additive  antimultiplicative  unity-preserving for (Function of C141 , C142);
coherence by L197;
cluster  additive  antimultiplicative  unity-preserving ->  antilinear for (Function of C141 , C142);
coherence by L197;
end;
definition
let C143 , C144 being non  empty doubleLoopStr;
let C145 being (Function of C143 , C144);
attr C145 is  monomorphism
means
:L200: C145 is  linear  one-to-one;
attr C145 is  antimonomorphism
means
:L201: C145 is  antilinear  one-to-one;
end;
definition
let C146 , C147 being non  empty doubleLoopStr;
let C148 being (Function of C146 , C147);
attr C148 is  epimorphism
means
:L203: C148 is  linear  onto;
attr C148 is  antiepimorphism
means
:L204: C148 is  antilinear  onto;
end;
definition
let C149 , C150 being non  empty doubleLoopStr;
let C151 being (Function of C149 , C150);
attr C151 is  isomorphism
means
:L206: C151 is  monomorphism  onto;
attr C151 is  antiisomorphism
means
:L207: C151 is  antimonomorphism  onto;
end;
definition
let C152 being non  empty doubleLoopStr;
let C153 being (Function of C152 , C152);
attr C153 is  endomorphism
means
:L209: C153 is  linear;
attr C153 is  antiendomorphism
means
:L210: C153 is  antilinear;
end;
theorem
L212: (for R5 being non  empty doubleLoopStr holds (for R8 being (Function of R5 , R5) holds (R8 is  isomorphism iff (R8 is  additive & (for B118 , B119 being (Scalar of R5) holds ( R8 . ( B118 * B119 ) ) = ( ( R8 . B118 ) * ( R8 . B119 ) )) & ( R8 . ( 1_ R5 ) ) = ( 1_ R5 ) & R8 is  one-to-one  onto))))
proof
let R5 being non  empty doubleLoopStr;
let R8 being (Function of R5 , R5);
L213:
now
assume L214: R8 is  isomorphism;
L215: R8 is  monomorphism by L214 , L206;
L216: R8 is  linear by L215 , L200;
thus L217: (R8 is  additive & (for B120 , B121 being (Scalar of R5) holds (( R8 . ( B120 * B121 ) ) = ( ( R8 . B120 ) * ( R8 . B121 ) ) & ( R8 . ( 1_ R5 ) ) = ( 1_ R5 )))) by L216 , GROUP_1:def 13 , GROUP_6:def 6;
thus L218: R8 is  one-to-one by L215 , L200;
thus L219: R8 is  onto by L214 , L206;
end;
L220:
now
assume that
L221: (R8 is  additive & (for B122 , B123 being (Scalar of R5) holds ( R8 . ( B122 * B123 ) ) = ( ( R8 . B122 ) * ( R8 . B123 ) )) & ( R8 . ( 1_ R5 ) ) = ( 1_ R5 ))
and
L222: R8 is  one-to-one
and
L223: R8 is  onto;
L224: R8 is  multiplicative  unity-preserving by L221 , GROUP_1:def 13 , GROUP_6:def 6;
L225: R8 is  monomorphism by L224 , L222 , L200 , L221;
thus L226: R8 is  isomorphism by L225 , L223 , L206;
end;
thus L227: thesis by L220 , L213;
end;
theorem
L228: (for R5 being non  empty doubleLoopStr holds (for R8 being (Function of R5 , R5) holds (R8 is  antiisomorphism iff (R8 is  additive & (for B124 , B125 being (Scalar of R5) holds ( R8 . ( B124 * B125 ) ) = ( ( R8 . B125 ) * ( R8 . B124 ) )) & ( R8 . ( 1_ R5 ) ) = ( 1_ R5 ) & R8 is  one-to-one & R8 is  onto))))
proof
let R5 being non  empty doubleLoopStr;
let R8 being (Function of R5 , R5);
L229:
now
assume L230: R8 is  antiisomorphism;
L231: R8 is  antimonomorphism by L230 , L207;
L232: R8 is  antilinear by L231 , L201;
thus L233: (R8 is  additive & (for B126 , B127 being (Scalar of R5) holds (( R8 . ( B126 * B127 ) ) = ( ( R8 . B127 ) * ( R8 . B126 ) ) & ( R8 . ( 1_ R5 ) ) = ( 1_ R5 )))) by L232 , L195 , GROUP_1:def 13;
thus L234: R8 is  one-to-one by L231 , L201;
thus L235: R8 is  onto by L230 , L207;
end;
L236:
now
assume that
L237: (R8 is  additive & (for B128 , B129 being (Scalar of R5) holds ( R8 . ( B128 * B129 ) ) = ( ( R8 . B129 ) * ( R8 . B128 ) )) & ( R8 . ( 1_ R5 ) ) = ( 1_ R5 ))
and
L238: R8 is  one-to-one
and
L239: R8 is  onto;
L240: R8 is  additive  antimultiplicative  unity-preserving by L237 , L195 , GROUP_1:def 13;
L241: R8 is  antimonomorphism by L240 , L238 , L201;
thus L242: R8 is  antiisomorphism by L241 , L239 , L207;
end;
thus L243: thesis by L236 , L229;
end;
L244: (for R5 being non  empty doubleLoopStr holds ((for B130 , B131 being (Scalar of R5) holds ( ( id R5 ) . ( B130 * B131 ) ) = ( ( ( id R5 ) . B130 ) * ( ( id R5 ) . B131 ) )) & ( ( id R5 ) . ( 1_ R5 ) ) = ( 1_ R5 )))
proof
let R5 being non  empty doubleLoopStr;
set D76 = ( id R5 );
thus L245: (for B132 , B133 being (Scalar of R5) holds ( D76 . ( B132 * B133 ) ) = ( ( D76 . B132 ) * ( D76 . B133 ) ))
proof
let C154 , C155 being (Scalar of R5);
L246: (( D76 . ( C154 * C155 ) ) = ( C154 * C155 ) & ( D76 . C154 ) = C154) by FUNCT_1:18;
thus L247: thesis by L246 , FUNCT_1:18;
end;

thus L248: ( ( id R5 ) . ( 1_ R5 ) ) = ( 1_ R5 ) by FUNCT_1:18;
end;
registration
let R5 being non  empty doubleLoopStr;
cluster ( id R5 ) ->  isomorphism;
coherence
proof
set D77 = ( id R5 );
L249: D77 is  monomorphism by L200;
thus L250: thesis by L249 , L206;
end;
end;
L252: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (R11 is  additive implies ( R11 . ( 0. R9 ) ) = ( 0. R10 )))))
proof
let R9 being Ring;
let R10 being Ring;
let R11 being (Function of R9 , R10);
set D78 = ( 0. R9 );
assume L253: R11 is  additive;
L254: ( D78 + D78 ) = D78 by RLVECT_1:4;
L255: ( ( R11 . D78 ) + ( R11 . D78 ) ) = ( R11 . D78 ) by L254 , L253 , VECTSP_1:def 20
.= ( ( R11 . D78 ) + ( 0. R10 ) ) by RLVECT_1:4;
thus L256: thesis by L255 , RLVECT_1:8;
end;
L257: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (for R12 being (Scalar of R9) holds (R11 is  linear implies ( R11 . ( - R12 ) ) = ( - ( R11 . R12 ) ))))))
proof
let R9 being Ring;
let R10 being Ring;
let R11 being (Function of R9 , R10);
let R12 being (Scalar of R9);
set D79 = ( 0. R9 );
set D80 = ( 0. R10 );
set D81 = ( R11 . R12 );
L258: ( R12 + ( - R12 ) ) = D79 by RLVECT_1:5;
L259: ( D81 + ( - D81 ) ) = D80 by RLVECT_1:5;
assume L260: R11 is  linear;
L261: ( D81 + ( R11 . ( - R12 ) ) ) = ( R11 . D79 ) by L260 , L258 , VECTSP_1:def 20
.= D80 by L260 , L252;
thus L262: thesis by L261 , L259 , RLVECT_1:8;
end;
L263: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (for R12 being (Scalar of R9) holds (for R13 being (Scalar of R9) holds (R11 is  linear implies ( R11 . ( R12 - R13 ) ) = ( ( R11 . R12 ) - ( R11 . R13 ) )))))))
proof
let R9 being Ring;
let R10 being Ring;
let R11 being (Function of R9 , R10);
let R12 being (Scalar of R9);
let R13 being (Scalar of R9);
assume L264: R11 is  linear;
thus L265: ( R11 . ( R12 - R13 ) ) = ( ( R11 . R12 ) + ( R11 . ( - R13 ) ) ) by L264 , VECTSP_1:def 20
.= ( ( R11 . R12 ) - ( R11 . R13 ) ) by L264 , L257;
end;
theorem
L266: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (for R12 being (Scalar of R9) holds (for R13 being (Scalar of R9) holds (R11 is  linear implies (( R11 . ( 0. R9 ) ) = ( 0. R10 ) & ( R11 . ( - R12 ) ) = ( - ( R11 . R12 ) ) & ( R11 . ( R12 - R13 ) ) = ( ( R11 . R12 ) - ( R11 . R13 ) )))))))) by L252 , L257 , L263;
L267: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (R11 is  antilinear implies ( R11 . ( 0. R9 ) ) = ( 0. R10 )))))
proof
let R9 being Ring;
let R10 being Ring;
let R11 being (Function of R9 , R10);
set D82 = ( 0. R9 );
L268: ( D82 + D82 ) = D82 by RLVECT_1:4;
assume L269: R11 is  antilinear;
L270: ( ( R11 . D82 ) + ( R11 . D82 ) ) = ( R11 . D82 ) by L269 , L268 , VECTSP_1:def 20
.= ( ( R11 . D82 ) + ( 0. R10 ) ) by RLVECT_1:4;
thus L271: thesis by L270 , RLVECT_1:8;
end;
L272: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (for R12 being (Scalar of R9) holds (R11 is  antilinear implies ( R11 . ( - R12 ) ) = ( - ( R11 . R12 ) ))))))
proof
let R9 being Ring;
let R10 being Ring;
let R11 being (Function of R9 , R10);
let R12 being (Scalar of R9);
assume L273: R11 is  antilinear;
set D83 = ( 0. R9 );
set D84 = ( 0. R10 );
set D85 = ( R11 . R12 );
L274: ( D85 + ( - D85 ) ) = D84 by RLVECT_1:5;
L275: ( R12 + ( - R12 ) ) = D83 by RLVECT_1:5;
L276: ( D85 + ( R11 . ( - R12 ) ) ) = ( R11 . D83 ) by L275 , L273 , VECTSP_1:def 20
.= D84 by L273 , L267;
thus L277: thesis by L276 , L274 , RLVECT_1:8;
end;
L278: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (for R12 being (Scalar of R9) holds (for R13 being (Scalar of R9) holds (R11 is  antilinear implies ( R11 . ( R12 - R13 ) ) = ( ( R11 . R12 ) - ( R11 . R13 ) )))))))
proof
let R9 being Ring;
let R10 being Ring;
let R11 being (Function of R9 , R10);
let R12 being (Scalar of R9);
let R13 being (Scalar of R9);
assume L279: R11 is  antilinear;
thus L280: ( R11 . ( R12 - R13 ) ) = ( ( R11 . R12 ) + ( R11 . ( - R13 ) ) ) by L279 , VECTSP_1:def 20
.= ( ( R11 . R12 ) - ( R11 . R13 ) ) by L279 , L272;
end;
theorem
L281: (for R9 being Ring holds (for R10 being Ring holds (for R11 being (Function of R9 , R10) holds (for R12 being (Scalar of R9) holds (for R13 being (Scalar of R9) holds (R11 is  antilinear implies (( R11 . ( 0. R9 ) ) = ( 0. R10 ) & ( R11 . ( - R12 ) ) = ( - ( R11 . R12 ) ) & ( R11 . ( R12 - R13 ) ) = ( ( R11 . R12 ) - ( R11 . R13 ) )))))))) by L267 , L272 , L278;
theorem
L282: (for B134 being Ring holds (( id B134 ) is  antiisomorphism iff B134 is comRing))
proof
let C156 being Ring;
set D86 = ( id C156 );
L283:
now
assume L284: C156 is comRing;
L285: (for B135 , B136 being (Scalar of C156) holds ( D86 . ( B135 * B136 ) ) = ( ( D86 . B136 ) * ( D86 . B135 ) ))
proof
let C157 , C158 being (Scalar of C156);
L286: ( D86 . C158 ) = C158 by FUNCT_1:18;
L287: (( D86 . ( C157 * C158 ) ) = ( C157 * C158 ) & ( D86 . C157 ) = C157) by FUNCT_1:18;
thus L288: thesis by L287 , L284 , L286 , L73;
end;
L289: ( D86 . ( 1_ C156 ) ) = ( 1_ C156 ) by L244;
thus L290: D86 is  antiisomorphism by L289 , L285 , L228;
end;
L291:
now
assume L292: D86 is  antiisomorphism;
L293: (for B137 , B138 being (Element of C156) holds ( B137 * B138 ) = ( B138 * B137 ))
proof
let C159 , C160 being (Element of C156);
L294: ( D86 . C160 ) = C160 by FUNCT_1:18;
L295: (( D86 . ( C159 * C160 ) ) = ( C159 * C160 ) & ( D86 . C159 ) = C159) by FUNCT_1:18;
thus L296: thesis by L295 , L292 , L294 , L228;
end;
thus L297: C156 is comRing by L293 , GROUP_1:def 12;
end;
thus L298: thesis by L291 , L283;
end;
theorem
L299: (for B139 being Skew-Field holds (( id B139 ) is  antiisomorphism iff B139 is Field))
proof
let C161 being Skew-Field;
set D87 = ( id C161 );
L300:
now
assume L301: C161 is Field;
L302: (for B140 , B141 being (Scalar of C161) holds ( D87 . ( B140 * B141 ) ) = ( ( D87 . B141 ) * ( D87 . B140 ) ))
proof
let C162 , C163 being (Scalar of C161);
L303: ( D87 . C163 ) = C163 by FUNCT_1:18;
L304: (( D87 . ( C162 * C163 ) ) = ( C162 * C163 ) & ( D87 . C162 ) = C162) by FUNCT_1:18;
thus L305: thesis by L304 , L301 , L303 , GROUP_1:def 12;
end;
L306: ( D87 . ( 1_ C161 ) ) = ( 1_ C161 ) by L244;
thus L307: D87 is  antiisomorphism by L306 , L302 , L228;
end;
L308:
now
assume L309: D87 is  antiisomorphism;
L310: (for B142 , B143 being (Scalar of C161) holds ( B142 * B143 ) = ( B143 * B142 ))
proof
let C164 , C165 being (Scalar of C161);
L311: ( D87 . C165 ) = C165 by FUNCT_1:18;
L312: (( D87 . ( C164 * C165 ) ) = ( C164 * C165 ) & ( D87 . C164 ) = C164) by FUNCT_1:18;
thus L313: thesis by L312 , L309 , L311 , L228;
end;
thus L314: C161 is Field by L310 , GROUP_1:def 12;
end;
thus L315: thesis by L308 , L300;
end;
begin
definition
let C166 , C167 being non  empty doubleLoopStr;
let C168 being (Function of C166 , C167);
func opp C168 -> (Function of C166 , ( opp C167 )) equals 
C168;
coherence;
end;
L317: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  linear implies ( opp R19 ) is  additive))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D88 = ( opp R19 );
assume L318: R19 is  linear;
let C169 , C170 being (Scalar of R17);
thus L319: ( D88 . ( C169 + C170 ) ) = ( ( R19 . C169 ) + ( R19 . C170 ) ) by L318 , VECTSP_1:def 20
.= ( ( D88 . C169 ) + ( D88 . C170 ) );
end;
canceled 1;
theorem
L320: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  linear iff ( opp R19 ) is  antilinear))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D89 = ( opp R19 );
set D90 = ( opp R18 );
L321:
now
assume L322: R19 is  linear;
L323: (for B144 , B145 being (Scalar of R17) holds ( D89 . ( B144 * B145 ) ) = ( ( D89 . B145 ) * ( D89 . B144 ) ))
proof
let C171 , C172 being (Scalar of R17);
thus L324: ( D89 . ( C171 * C172 ) ) = ( ( R19 . C171 ) * ( R19 . C172 ) ) by L322 , GROUP_6:def 6
.= ( ( D89 . C172 ) * ( D89 . C171 ) ) by L25;
end;
L325: ( D89 . ( 1_ R17 ) ) = ( 1_ R18 ) by L322 , GROUP_1:def 13
.= ( 1_ D90 );
L326: D89 is  additive  antimultiplicative  unity-preserving by L325 , L317 , L323 , L195 , L322 , GROUP_1:def 13;
thus L327: D89 is  antilinear by L326;
end;
L328:
now
assume L329: D89 is  antilinear;
L330: (for B146 , B147 being (Scalar of R17) holds ( R19 . ( B146 + B147 ) ) = ( ( R19 . B146 ) + ( R19 . B147 ) ))
proof
let C173 , C174 being (Scalar of R17);
thus L331: ( R19 . ( C173 + C174 ) ) = ( ( D89 . C173 ) + ( D89 . C174 ) ) by L329 , VECTSP_1:def 20
.= ( ( R19 . C173 ) + ( R19 . C174 ) );
end;
L332: (for B148 , B149 being (Scalar of R17) holds ( R19 . ( B148 * B149 ) ) = ( ( R19 . B148 ) * ( R19 . B149 ) ))
proof
let C175 , C176 being (Scalar of R17);
thus L333: ( R19 . ( C175 * C176 ) ) = ( ( D89 . C176 ) * ( D89 . C175 ) ) by L329 , L195
.= ( ( R19 . C175 ) * ( R19 . C176 ) ) by L25;
end;
L334: ( R19 . ( 1_ R17 ) ) = ( 1_ D90 ) by L329 , GROUP_1:def 13
.= ( 1_ R18 );
L335: R19 is  additive  multiplicative  unity-preserving by L334 , L330 , L332 , VECTSP_1:def 20 , GROUP_1:def 13 , GROUP_6:def 6;
thus L336: R19 is  linear by L335;
end;
thus L337: thesis by L328 , L321;
end;
theorem
L338: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  antilinear iff ( opp R19 ) is  linear))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D91 = ( opp R19 );
set D92 = ( opp R18 );
thus L339:now
assume L340: R19 is  antilinear;
L341: D91 is  additive
proof
let C177 , C178 being (Scalar of R17);
thus L342: ( D91 . ( C177 + C178 ) ) = ( ( R19 . C177 ) + ( R19 . C178 ) ) by L340 , VECTSP_1:def 20
.= ( ( D91 . C177 ) + ( D91 . C178 ) );
end;
L343: D91 is  multiplicative
proof
let C179 , C180 being (Scalar of R17);
thus L344: ( D91 . ( C179 * C180 ) ) = ( ( R19 . C180 ) * ( R19 . C179 ) ) by L340 , L195
.= ( ( D91 . C179 ) * ( D91 . C180 ) ) by L25;
end;
L345: ( D91 . ( 1_ R17 ) ) = ( 1_ R18 ) by L340 , GROUP_1:def 13
.= ( 1_ D92 );
L346: D91 is  unity-preserving by L345 , GROUP_1:def 13;
thus L347: D91 is  linear by L346 , L341 , L343;
end;
assume L348: D91 is  additive  multiplicative  unity-preserving;
thus L349:now
let C181 , C182 being (Scalar of R17);
thus L350: ( R19 . ( C181 + C182 ) ) = ( ( D91 . C181 ) + ( D91 . C182 ) ) by L348 , VECTSP_1:def 20
.= ( ( R19 . C181 ) + ( R19 . C182 ) );
end;
thus L351:now
let C183 , C184 being (Scalar of R17);
thus L352: ( R19 . ( C183 * C184 ) ) = ( ( D91 . C183 ) * ( D91 . C184 ) ) by L348 , GROUP_6:def 6
.= ( ( R19 . C184 ) * ( R19 . C183 ) ) by L25;
end;
thus L353: ( R19 . ( 1_ R17 ) ) = ( 1_ D92 ) by L348 , GROUP_1:def 13
.= ( 1_ R18 );
end;
theorem
L354: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  monomorphism iff ( opp R19 ) is  antimonomorphism))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D93 = ( opp R19 );
L355: (R19 is  linear iff D93 is  antilinear) by L320;
L356: (D93 is  antimonomorphism iff (D93 is  antilinear & D93 is  one-to-one)) by L201;
thus L357: thesis by L356 , L355 , L200;
end;
theorem
L358: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  antimonomorphism iff ( opp R19 ) is  monomorphism))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D94 = ( opp R19 );
L359: (R19 is  antilinear iff D94 is  linear) by L338;
L360: (D94 is  monomorphism iff (D94 is  linear & D94 is  one-to-one)) by L200;
thus L361: thesis by L360 , L359 , L201;
end;
theorem
L362: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  epimorphism iff ( opp R19 ) is  antiepimorphism))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D95 = ( opp R19 );
set D96 = ( opp R18 );
L363: (R19 is  linear iff D95 is  antilinear) by L320;
thus L364: thesis by L363 , L203 , L204;
end;
theorem
L365: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  antiepimorphism iff ( opp R19 ) is  epimorphism))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D97 = ( opp R19 );
set D98 = ( opp R18 );
L366: (R19 is  antilinear iff D97 is  linear) by L338;
thus L367: thesis by L366 , L203 , L204;
end;
theorem
L368: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  isomorphism iff ( opp R19 ) is  antiisomorphism))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D99 = ( opp R19 );
set D100 = ( opp R18 );
L369: (R19 is  monomorphism iff D99 is  antimonomorphism) by L354;
thus L370: thesis by L369 , L206 , L207;
end;
theorem
L371: (for R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr holds (for R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R19 being (Function of R17 , R18) holds (R19 is  antiisomorphism iff ( opp R19 ) is  isomorphism))))
proof
let R17 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let R18 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R19 being (Function of R17 , R18);
set D101 = ( opp R19 );
set D102 = ( opp R18 );
L372: (R19 is  antimonomorphism iff D101 is  monomorphism) by L358;
thus L373: thesis by L372 , L206 , L207;
end;
theorem
L374: (for R20 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R21 being (Function of R20 , R20) holds (R21 is  endomorphism iff ( opp R21 ) is  antilinear)))
proof
let R20 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R21 being (Function of R20 , R20);
L375: (R21 is  linear iff ( opp R21 ) is  antilinear) by L320;
thus L376: thesis by L375 , L209;
end;
theorem
L377: (for R20 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R21 being (Function of R20 , R20) holds (R21 is  antiendomorphism iff ( opp R21 ) is  linear)))
proof
let R20 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr;
let R21 being (Function of R20 , R20);
L378: (R21 is  antilinear iff ( opp R21 ) is  linear) by L338;
thus L379: thesis by L378 , L210;
end;
theorem
L380: (for R20 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R21 being (Function of R20 , R20) holds (R21 is  isomorphism iff ( opp R21 ) is  antiisomorphism))) by L368;
theorem
L381: (for R20 being  add-associative  right_zeroed  right_complementable  well-unital non  empty doubleLoopStr holds (for R21 being (Function of R20 , R20) holds (R21 is  antiisomorphism iff ( opp R21 ) is  isomorphism))) by L371;
begin
definition
let C185 , C186 being AddGroup;
mode Homomorphism of C185 , C186
 is  additive (Function of C185 , C186);
end;
definition
let C187 being AddGroup;
mode Endomorphism of C187
 is (Homomorphism of C187 , C187);
end;
registration
let C188 being AddGroup;
cluster  bijective for (Endomorphism of C188);
existence
proof
take ( id C188 );
thus L384: thesis;
end;
end;
definition
let C189 being AddGroup;
mode Automorphism of C189
 is  bijective (Endomorphism of C189);
end;
L387: (for R22 being AddGroup holds (for R23 being AddGroup holds (for R24 being (Homomorphism of R22 , R23) holds ( R24 . ( 0. R22 ) ) = ( 0. R23 ))))
proof
let R22 being AddGroup;
let R23 being AddGroup;
let R24 being (Homomorphism of R22 , R23);
set D103 = ( 0. R22 );
L388: ( D103 + D103 ) = D103 by RLVECT_1:def 4;
L389: ( ( R24 . D103 ) + ( R24 . D103 ) ) = ( R24 . D103 ) by L388 , VECTSP_1:def 20
.= ( ( R24 . D103 ) + ( 0. R23 ) ) by RLVECT_1:def 4;
thus L390: thesis by L389 , RLVECT_1:8;
end;
L391: (for R22 being AddGroup holds (for R23 being AddGroup holds (for R24 being (Homomorphism of R22 , R23) holds (for R25 being (Element of R22) holds ( R24 . ( - R25 ) ) = ( - ( R24 . R25 ) )))))
proof
let R22 being AddGroup;
let R23 being AddGroup;
let R24 being (Homomorphism of R22 , R23);
let R25 being (Element of R22);
set D104 = ( 0. R22 );
set D105 = ( 0. R23 );
set D106 = ( R24 . R25 );
L392: ( R25 + ( - R25 ) ) = D104 by RLVECT_1:def 10;
L393: ( D106 + ( R24 . ( - R25 ) ) ) = ( R24 . D104 ) by L392 , VECTSP_1:def 20
.= D105 by L387;
thus L394: thesis by L393 , VECTSP_1:16;
end;
L395: (for R22 being AddGroup holds (for R23 being AddGroup holds (for R24 being (Homomorphism of R22 , R23) holds (for R25 being (Element of R22) holds (for R26 being (Element of R22) holds ( R24 . ( R25 - R26 ) ) = ( ( R24 . R25 ) - ( R24 . R26 ) ))))))
proof
let R22 being AddGroup;
let R23 being AddGroup;
let R24 being (Homomorphism of R22 , R23);
let R25 being (Element of R22);
let R26 being (Element of R22);
thus L396: ( R24 . ( R25 - R26 ) ) = ( ( R24 . R25 ) + ( R24 . ( - R26 ) ) ) by VECTSP_1:def 20
.= ( ( R24 . R25 ) - ( R24 . R26 ) ) by L391;
end;
theorem
L397: (for R22 being AddGroup holds (for R23 being AddGroup holds (for R24 being (Homomorphism of R22 , R23) holds (for R25 being (Element of R22) holds (for R26 being (Element of R22) holds (( R24 . ( 0. R22 ) ) = ( 0. R23 ) & ( R24 . ( - R25 ) ) = ( - ( R24 . R25 ) ) & ( R24 . ( R25 - R26 ) ) = ( ( R24 . R25 ) - ( R24 . R26 ) ))))))) by L387 , L391 , L395;
begin
L398: (for R32 being Ring holds (for R33 being Ring holds (for R35 being (LeftMod of R32) holds (for R36 being (LeftMod of R33) holds (for B150 , B151 being (Vector of R35) holds ( ( ZeroMap (R35 , R36) ) . ( B150 + B151 ) ) = ( ( ( ZeroMap (R35 , R36) ) . B150 ) + ( ( ZeroMap (R35 , R36) ) . B151 ) ))))))
proof
let R32 being Ring;
let R33 being Ring;
let R35 being (LeftMod of R32);
let R36 being (LeftMod of R33);
set D107 = ( ZeroMap (R35 , R36) );
thus L399: (for B152 , B153 being (Vector of R35) holds ( D107 . ( B152 + B153 ) ) = ( ( D107 . B152 ) + ( D107 . B153 ) ))
proof
let C190 , C191 being (Vector of R35);
L400: ( D107 . C191 ) = ( 0. R36 ) by FUNCOP_1:7;
L401: (( D107 . ( C190 + C191 ) ) = ( 0. R36 ) & ( D107 . C190 ) = ( 0. R36 )) by FUNCOP_1:7;
thus L402: thesis by L401 , L400 , RLVECT_1:def 4;
end;

end;
L400: (for R32 being Ring holds (for R33 being Ring holds (for R34 being (Function of R32 , R33) holds (for R35 being (LeftMod of R32) holds (for R36 being (LeftMod of R33) holds (for B154 being (Scalar of R32) holds (for B155 being (Vector of R35) holds ( ( ZeroMap (R35 , R36) ) . ( B154 * B155 ) ) = ( ( R34 . B154 ) * ( ( ZeroMap (R35 , R36) ) . B155 ) ))))))))
proof
let R32 being Ring;
let R33 being Ring;
let R34 being (Function of R32 , R33);
let R35 being (LeftMod of R32);
let R36 being (LeftMod of R33);
let C192 being (Scalar of R32);
let C193 being (Vector of R35);
set D108 = ( ZeroMap (R35 , R36) );
L401: (( D108 . ( C192 * C193 ) ) = ( 0. R36 ) & ( D108 . C193 ) = ( 0. R36 )) by FUNCOP_1:7;
thus L402: thesis by L401 , VECTSP_1:14;
end;
definition
let R32 being Ring;
let R33 being Ring;
let R34 being (Function of R32 , R33);
let R35 being (LeftMod of R32);
let R36 being (LeftMod of R33);
mode Homomorphism of R34 , R35 , R36
 -> (Function of R35 , R36)
means :L403: ((for B156 , B157 being (Vector of R35) holds ( it . ( B156 + B157 ) ) = ( ( it . B156 ) + ( it . B157 ) )) & (for B158 being (Scalar of R32) holds (for B159 being (Vector of R35) holds ( it . ( B158 * B159 ) ) = ( ( R34 . B158 ) * ( it . B159 ) ))));
existence
proof
take ( ZeroMap (R35 , R36) );
thus L404: thesis by L398 , L400;
end;
end;
theorem
L406: (for R32 being Ring holds (for R33 being Ring holds (for R34 being (Function of R32 , R33) holds (for R35 being (LeftMod of R32) holds (for R36 being (LeftMod of R33) holds ( ZeroMap (R35 , R36) ) is (Homomorphism of R34 , R35 , R36))))))
proof
let R32 being Ring;
let R33 being Ring;
let R34 being (Function of R32 , R33);
let R35 being (LeftMod of R32);
let R36 being (LeftMod of R33);
set D109 = ( ZeroMap (R35 , R36) );
L407: ((for B160 , B161 being (Vector of R35) holds ( D109 . ( B160 + B161 ) ) = ( ( D109 . B160 ) + ( D109 . B161 ) )) & (for B162 being (Scalar of R32) holds (for B163 being (Vector of R35) holds ( D109 . ( B162 * B163 ) ) = ( ( R34 . B162 ) * ( D109 . B163 ) )))) by L398 , L400;
thus L408: thesis by L407 , L403;
end;
definition
let R32 being Ring;
let R37 being (Function of R32 , R32);
let R35 being (LeftMod of R32);
mode Endomorphism of R37 , R35
 is (Homomorphism of R37 , R35 , R35);
end;
definition
let R32 being Ring;
let R35 being (LeftMod of R32);
let R39 being (LeftMod of R32);
mode Homomorphism of R35 , R39
 is (Homomorphism of ( id R32 ) , R35 , R39);
end;
theorem
L411: (for R32 being Ring holds (for R35 being (LeftMod of R32) holds (for R39 being (LeftMod of R32) holds (for B164 being (Function of R35 , R39) holds (B164 is (Homomorphism of R35 , R39) iff ((for B165 , B166 being (Vector of R35) holds ( B164 . ( B165 + B166 ) ) = ( ( B164 . B165 ) + ( B164 . B166 ) )) & (for B167 being (Scalar of R32) holds (for B168 being (Vector of R35) holds ( B164 . ( B167 * B168 ) ) = ( B167 * ( B164 . B168 ) )))))))))
proof
let R32 being Ring;
let R35 being (LeftMod of R32);
let R39 being (LeftMod of R32);
let C194 being (Function of R35 , R39);
set D110 = ( id R32 );
L412:
now
assume L413: (for B169 being (Scalar of R32) holds (for B170 being (Vector of R35) holds ( C194 . ( B169 * B170 ) ) = ( B169 * ( C194 . B170 ) )));
let C195 being (Scalar of R32);
let C196 being (Vector of R35);
L414: ( D110 . C195 ) = C195 by FUNCT_1:18;
thus L415: ( C194 . ( C195 * C196 ) ) = ( ( D110 . C195 ) * ( C194 . C196 ) ) by L414 , L413;
end;
L416:
now
assume L417: (for B171 being (Scalar of R32) holds (for B172 being (Vector of R35) holds ( C194 . ( B171 * B172 ) ) = ( ( D110 . B171 ) * ( C194 . B172 ) )));
let C197 being (Scalar of R32);
let C198 being (Vector of R35);
L418: ( D110 . C197 ) = C197 by FUNCT_1:18;
thus L419: ( C194 . ( C197 * C198 ) ) = ( C197 * ( C194 . C198 ) ) by L418 , L417;
end;
thus L420: thesis by L416 , L412 , L403;
end;
definition
let R32 being Ring;
let R35 being (LeftMod of R32);
mode Endomorphism of R35
 is (Homomorphism of R35 , R35);
end;
