:: Binary Operations Applied to Functions
::  by Andrzej Trybulec
::
:: Received September 4, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies FUNCT_1, FUNCT_3, PARTFUN1, RELAT_1, ZFMISC_1, XBOOLE_0, TARSKI,
      SUBSET_1, BINOP_1, MCART_1, FUNCOP_1, WELLORD1, MSUALG_4;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, MCART_1, RELAT_1, FUNCT_1,
      RELSET_1, PARTFUN1, FUNCT_2, FUNCT_3, BINOP_1, WELLORD1;
 constructors PARTFUN1, BINOP_1, FUNCT_3, RELSET_1, WELLORD1, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, RELSET_1,
      XTUPLE_0, FUNCT_3;
 requirements SUBSET, BOOLE;
 definitions TARSKI, RELAT_1, BINOP_1, FUNCT_1, WELLORD1, PARTFUN1, XTUPLE_0;
 theorems ZFMISC_1, RELAT_1, RELSET_1, FUNCT_1, FUNCT_2, FUNCT_3, TARSKI,
      BINOP_1, MCART_1, XBOOLE_0, XBOOLE_1, GRFUNC_1, XTUPLE_0;
 schemes FUNCT_1;

begin
theorem
L1: (for R4 being set holds ( delta R4 ) = <: ( id R4 ) , ( id R4 ) :>)
proof
let R4 being set;
thus L2: ( delta R4 ) = ( ( id [: R4 , R4 :] ) * ( delta R4 ) ) by FUNCT_2:17
.= ( [: ( id R4 ) , ( id R4 ) :] * ( delta R4 ) ) by FUNCT_3:69
.= <: ( id R4 ) , ( id R4 ) :> by FUNCT_3:78;
end;
definition
let R1 being Function;
func R1 ~ -> Function means 
:L3: (( dom it ) = ( dom R1 ) & (for R7 being set holds (R7 in ( dom R1 ) implies ((for R8 being set holds (for R11 being set holds (( R1 . R7 ) = [ R8 , R11 ] implies ( it . R7 ) = [ R11 , R8 ]))) & (( R1 . R7 ) = ( it . R7 ) or (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ])))))));
existence
proof
defpred S1[ set , set ] means ((for R8 being set holds (for R11 being set holds (( R1 . $1 ) = [ R8 , R11 ] implies $2 = [ R11 , R8 ]))) & (( R1 . $1 ) = $2 or (ex R8 being set st (ex R11 being set st ( R1 . $1 ) = [ R8 , R11 ]))));
L4:
now
let R7 being set;
assume that
L5: R7 in ( dom R1 );
L6:
now
per cases ;
suppose L7: (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ]));

consider R8 being set, R11 being set such that L8: ( R1 . R7 ) = [ R8 , R11 ] by L7;
take D1 = [ R11 , R8 ];
thus L9: (for R8 being set holds (for R11 being set holds (( R1 . R7 ) = [ R8 , R11 ] implies D1 = [ R11 , R8 ])))
proof
let C1 , C2 being set;
assume L10: ( R1 . R7 ) = [ C1 , C2 ];
L11: R11 = C2 by L10 , L8 , XTUPLE_0:1;
thus L12: thesis by L11 , L8 , L10 , XTUPLE_0:1;
end;

thus L13: (( R1 . R7 ) = D1 or (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ]))) by L7;
end;
suppose L14: (not (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ])));

take D2 = ( R1 . R7 );
thus L15: ((for R8 being set holds (for R11 being set holds (( R1 . R7 ) = [ R8 , R11 ] implies D2 = [ R11 , R8 ]))) & (( R1 . R7 ) = D2 or (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ])))) by L14;
end;
end;
thus L17: (ex R8 being set st S1[ R7 , R8 ]) by L6;
end;
L18:
now
let R7 being set;
let R9 being set;
let R10 being set;
assume that
L19: R7 in ( dom R1 );
assume that
L20: S1[ R7 , R9 ]
and
L21: S1[ R7 , R10 ];
L22:
now
per cases ;
suppose L23: (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ]));

consider R8 being set, R11 being set such that L24: ( R1 . R7 ) = [ R8 , R11 ] by L23;
L25: R9 = [ R11 , R8 ] by L20 , L24;
thus L26: R9 = R10 by L25 , L21 , L24;
end;
suppose L27: (not (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ])));

thus L28: R9 = R10 by L27 , L20 , L21;
end;
end;
thus L30: R9 = R10 by L22;
end;
thus L31: (ex R2 being Function st (( dom R2 ) = ( dom R1 ) & (for R7 being set holds (R7 in ( dom R1 ) implies S1[ R7 , ( R2 . R7 ) ])))) from FUNCT_1:sch 2(L18 , L4);
end;
uniqueness
proof
defpred S2[ Function ] means (for R7 being set holds (R7 in ( dom R1 ) implies ((for R8 being set holds (for R11 being set holds (( R1 . R7 ) = [ R8 , R11 ] implies ( $1 . R7 ) = [ R11 , R8 ]))) & (( R1 . R7 ) = ( $1 . R7 ) or (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ]))))));
let C3 , C4 being Function;
assume that
L32: ( dom C3 ) = ( dom R1 )
and
L33: S2[ C3 ]
and
L34: ( dom C4 ) = ( dom R1 )
and
L35: S2[ C4 ];
L36:
now
let R7 being set;
assume L37: R7 in ( dom R1 );
L38:
now
per cases ;
suppose L39: (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ]));

consider R8 being set, R11 being set such that L40: ( R1 . R7 ) = [ R8 , R11 ] by L39;
L41: ( C3 . R7 ) = [ R11 , R8 ] by L33 , L37 , L40;
thus L42: ( C3 . R7 ) = ( C4 . R7 ) by L41 , L35 , L37 , L40;
end;
suppose L43: (not (ex R8 being set st (ex R11 being set st ( R1 . R7 ) = [ R8 , R11 ])));

L44: ( C3 . R7 ) = ( R1 . R7 ) by L43 , L33 , L37;
thus L45: ( C3 . R7 ) = ( C4 . R7 ) by L44 , L35 , L37 , L43;
end;
end;
thus L47: ( C3 . R7 ) = ( C4 . R7 ) by L38;
end;
thus L48: thesis by L36 , L32 , L34 , FUNCT_1:2;
end;
involutiveness
proof
let C5 , C6 being Function;
assume that
L49: ( dom C5 ) = ( dom C6 )
and
L50: (for R7 being set holds (R7 in ( dom C6 ) implies ((for R8 being set holds (for R11 being set holds (( C6 . R7 ) = [ R8 , R11 ] implies ( C5 . R7 ) = [ R11 , R8 ]))) & (( C6 . R7 ) = ( C5 . R7 ) or (ex R8 being set st (ex R11 being set st ( C6 . R7 ) = [ R8 , R11 ]))))));
thus L51: ( dom C6 ) = ( dom C5 ) by L49;
let R7 being set;
assume L52: R7 in ( dom C5 );
thus L53: (for R8 being set holds (for R11 being set holds (( C5 . R7 ) = [ R8 , R11 ] implies ( C6 . R7 ) = [ R11 , R8 ])))
proof
let R8 being set;
let R11 being set;
assume that
L54: ( C5 . R7 ) = [ R8 , R11 ];
per cases ;
suppose L55: (ex R11 being set st (ex R8 being set st ( C6 . R7 ) = [ R11 , R8 ]));

consider R9 being set, R10 being set such that L56: ( C6 . R7 ) = [ R9 , R10 ] by L55;
L57: ( C5 . R7 ) = [ R10 , R9 ] by L49 , L50 , L52 , L56;
L58: R8 = R10 by L57 , L54 , XTUPLE_0:1;
thus L59: thesis by L58 , L54 , L56 , L57 , XTUPLE_0:1;
end;
suppose L60: (not (ex R11 being set st (ex R8 being set st ( C6 . R7 ) = [ R11 , R8 ])));

L61: ( C6 . R7 ) = ( C5 . R7 ) by L60 , L49 , L50 , L52;
thus L62: thesis by L61 , L49 , L50 , L52 , L54;
end;
end;

assume L64: ( C5 . R7 ) <> ( C6 . R7 );
consider R8 being set, R11 being set such that L65: ( C6 . R7 ) = [ R8 , R11 ] by L64 , L49 , L50 , L52;
take R11;
take R8;
thus L66: thesis by L49 , L50 , L52 , L65;
end;
end;
theorem
L68: (for R1 being Function holds (for R2 being Function holds <: R1 , R2 :> = ( <: R2 , R1 :> ~ )))
proof
let R1 being Function;
let R2 being Function;
L69: ( dom <: R1 , R2 :> ) = ( ( dom R2 ) /\ ( dom R1 ) ) by FUNCT_3:def 7
.= ( dom <: R2 , R1 :> ) by FUNCT_3:def 7;
L70:
now
let R7 being set;
assume L71: R7 in ( dom <: R1 , R2 :> );
L72: ( <: R2 , R1 :> . R7 ) = [ ( R2 . R7 ) , ( R1 . R7 ) ] by L71 , L69 , FUNCT_3:def 7;
thus L73: ( <: R1 , R2 :> . R7 ) = [ ( R1 . R7 ) , ( R2 . R7 ) ] by L71 , FUNCT_3:def 7
.= ( ( <: R2 , R1 :> ~ ) . R7 ) by L69 , L71 , L72 , L3;
end;
L74: ( dom <: R1 , R2 :> ) = ( dom ( <: R2 , R1 :> ~ ) ) by L69 , L3;
thus L75: thesis by L74 , L70 , FUNCT_1:2;
end;
theorem
L76: (for R1 being Function holds (for R4 being set holds ( ( R1 | R4 ) ~ ) = ( ( R1 ~ ) | R4 )))
proof
let R1 being Function;
let R4 being set;
L77: ( dom ( R1 | R4 ) ) = ( ( dom R1 ) /\ R4 ) by RELAT_1:61
.= ( ( dom ( R1 ~ ) ) /\ R4 ) by L3
.= ( dom ( ( R1 ~ ) | R4 ) ) by RELAT_1:61;
L78:
now
let R7 being set;
assume that
L79: R7 in ( dom ( ( R1 ~ ) | R4 ) );
L80: ( dom ( R1 | R4 ) ) c= ( dom R1 ) by RELAT_1:60;
L81:
now
per cases ;
suppose L82: (ex R8 being set st (ex R11 being set st ( ( R1 | R4 ) . R7 ) = [ R8 , R11 ]));

consider R8 being set, R11 being set such that L83: ( ( R1 | R4 ) . R7 ) = [ R8 , R11 ] by L82;
L84: ( R1 . R7 ) = [ R8 , R11 ] by L77 , L79 , L83 , FUNCT_1:47;
thus L85: ( ( ( R1 | R4 ) ~ ) . R7 ) = [ R11 , R8 ] by L77 , L79 , L83 , L3
.= ( ( R1 ~ ) . R7 ) by L77 , L79 , L80 , L84 , L3
.= ( ( ( R1 ~ ) | R4 ) . R7 ) by L79 , FUNCT_1:47;
end;
suppose L86: (not (ex R8 being set st (ex R11 being set st ( ( R1 | R4 ) . R7 ) = [ R8 , R11 ])));

L87: ( ( R1 | R4 ) . R7 ) = ( R1 . R7 ) by L77 , L79 , FUNCT_1:47;
L88: ( ( ( R1 | R4 ) ~ ) . R7 ) = ( ( R1 | R4 ) . R7 ) by L77 , L79 , L86 , L3;
thus L89: ( ( ( R1 | R4 ) ~ ) . R7 ) = ( ( R1 ~ ) . R7 ) by L88 , L77 , L79 , L80 , L86 , L87 , L3
.= ( ( ( R1 ~ ) | R4 ) . R7 ) by L79 , FUNCT_1:47;
end;
end;
thus L91: ( ( ( R1 | R4 ) ~ ) . R7 ) = ( ( ( R1 ~ ) | R4 ) . R7 ) by L81;
end;
L92: ( dom ( ( R1 | R4 ) ~ ) ) = ( dom ( R1 | R4 ) ) by L3;
thus L93: thesis by L92 , L77 , L78 , FUNCT_1:2;
end;
theorem
L94: (for R4 being set holds ( ( delta R4 ) ~ ) = ( delta R4 ))
proof
let R4 being set;
thus L95: ( ( delta R4 ) ~ ) = ( <: ( id R4 ) , ( id R4 ) :> ~ ) by L1
.= <: ( id R4 ) , ( id R4 ) :> by L68
.= ( delta R4 ) by L1;
end;
theorem
L96: (for R1 being Function holds (for R2 being Function holds (for R4 being set holds ( <: R1 , R2 :> | R4 ) = <: ( R1 | R4 ) , R2 :>)))
proof
let R1 being Function;
let R2 being Function;
let R4 being set;
L97: ( dom ( <: R1 , R2 :> | R4 ) ) = ( ( dom <: R1 , R2 :> ) /\ R4 ) by RELAT_1:61
.= ( ( ( dom R1 ) /\ ( dom R2 ) ) /\ R4 ) by FUNCT_3:def 7
.= ( ( ( dom R1 ) /\ R4 ) /\ ( dom R2 ) ) by XBOOLE_1:16
.= ( ( dom ( R1 | R4 ) ) /\ ( dom R2 ) ) by RELAT_1:61;
L98:
now
L99: ( dom ( <: R1 , R2 :> | R4 ) ) c= ( dom <: R1 , R2 :> ) by RELAT_1:60;
let R7 being set;
assume that
L100: R7 in ( dom ( <: R1 , R2 :> | R4 ) );
L101: R7 in ( dom ( R1 | R4 ) ) by L97 , L100 , XBOOLE_0:def 4;
thus L102: ( ( <: R1 , R2 :> | R4 ) . R7 ) = ( <: R1 , R2 :> . R7 ) by L100 , FUNCT_1:47
.= [ ( R1 . R7 ) , ( R2 . R7 ) ] by L100 , L99 , FUNCT_3:def 7
.= [ ( ( R1 | R4 ) . R7 ) , ( R2 . R7 ) ] by L101 , FUNCT_1:47;
end;
thus L103: thesis by L98 , L97 , FUNCT_3:def 7;
end;
theorem
L104: (for R1 being Function holds (for R2 being Function holds (for R4 being set holds ( <: R1 , R2 :> | R4 ) = <: R1 , ( R2 | R4 ) :>)))
proof
let R1 being Function;
let R2 being Function;
let R4 being set;
thus L105: ( <: R1 , R2 :> | R4 ) = ( ( <: R2 , R1 :> ~ ) | R4 ) by L68
.= ( ( <: R2 , R1 :> | R4 ) ~ ) by L76
.= ( <: ( R2 | R4 ) , R1 :> ~ ) by L96
.= <: R1 , ( R2 | R4 ) :> by L68;
end;
definition
let C7 , C8 being set;
func C7 --> C8 -> set equals 
[: C7 , { C8 } :];
coherence;
end;
registration
let C9 , C10 being set;
cluster ( C9 --> C10 ) ->  Function-like  Relation-like;
coherence
proof
thus L107: ( C9 --> C10 ) is  Function-like
proof
let R7 being set;
let R9 being set;
let R10 being set;
assume that
L108: [ R7 , R9 ] in ( C9 --> C10 )
and
L109: [ R7 , R10 ] in ( C9 --> C10 );
L110: R9 in { C10 } by L108 , ZFMISC_1:87;
L111: R9 = C10 by L110 , TARSKI:def 1;
L112: R10 in { C10 } by L109 , ZFMISC_1:87;
thus L113: thesis by L112 , L111 , TARSKI:def 1;
end;

thus L114: (for R7 being set holds (R7 in ( C9 --> C10 ) implies (ex R9 being set st (ex R10 being set st [ R9 , R10 ] = R7)))) by RELAT_1:def 1;
end;
end;
theorem
L116: (for R4 being set holds (for R7 being set holds (for R11 being set holds (R7 in R4 implies ( ( R4 --> R11 ) . R7 ) = R11))))
proof
let R4 being set;
let R7 being set;
let R11 being set;
assume L117: R7 in R4;
L118: R11 in { R11 } by TARSKI:def 1;
L119: [ R7 , R11 ] in ( R4 --> R11 ) by L118 , L117 , ZFMISC_1:87;
thus L120: thesis by L119 , FUNCT_1:1;
end;
theorem
L121: (for R4 being set holds (for R7 being set holds (R4 <> ( {} ) implies ( rng ( R4 --> R7 ) ) = { R7 }))) by RELAT_1:160;
theorem
L122: (for R1 being Function holds (for R7 being set holds (( rng R1 ) = { R7 } implies R1 = ( ( dom R1 ) --> R7 ))))
proof
let R1 being Function;
let R7 being set;
assume L123: ( rng R1 ) = { R7 };
L124: ( dom R1 ) <> ( {} ) by L123 , RELAT_1:42;
L125: (( dom ( ( dom R1 ) --> R7 ) ) = ( dom R1 ) & ( rng ( ( dom R1 ) --> R7 ) ) = { R7 }) by L124 , RELAT_1:160;
thus L126: thesis by L125 , L123 , FUNCT_1:7;
end;
registration
let R7 being set;
cluster ( ( {} ) --> R7 ) ->  empty;
coherence by ZFMISC_1:90;
end;
registration
let R7 being set;
let C11 being  empty set;
cluster ( C11 --> R7 ) ->  empty;
coherence;
end;
registration
let R7 being set;
let C12 being non  empty set;
cluster ( C12 --> R7 ) -> non  empty;
coherence;
end;
theorem
L130: (for R7 being set holds (( dom ( ( {} ) --> R7 ) ) = ( {} ) & ( rng ( ( {} ) --> R7 ) ) = ( {} )));
theorem
L131: (for R1 being Function holds (for R7 being set holds ((for R11 being set holds (R11 in ( dom R1 ) implies ( R1 . R11 ) = R7)) implies R1 = ( ( dom R1 ) --> R7 ))))
proof
let R1 being Function;
let R7 being set;
assume L132: (for R11 being set holds (R11 in ( dom R1 ) implies ( R1 . R11 ) = R7));
L133:
now
per cases ;
suppose L134: ( dom R1 ) = ( {} );

L135: ( dom ( ( {} ) --> R7 ) ) = ( {} );
thus L136: thesis by L135 , L134;
end;
suppose L137: ( dom R1 ) <> ( {} );

set D3 = the (Element of ( dom R1 ));
L138:
now
let R8 being set;
thus L139: (R8 in { R7 } implies (ex R9 being set st (R9 in ( dom R1 ) & R8 = ( R1 . R9 ))))
proof
assume L140: R8 in { R7 };
L141: R8 = R7 by L140 , TARSKI:def 1;
L142: ( R1 . D3 ) = R8 by L141 , L132 , L137;
thus L143: thesis by L142 , L137;
end;

assume L144: (ex R9 being set st (R9 in ( dom R1 ) & R8 = ( R1 . R9 )));
L145: R8 = R7 by L144 , L132;
thus L146: R8 in { R7 } by L145 , TARSKI:def 1;
end;
L147: ( rng R1 ) = { R7 } by L138 , FUNCT_1:def 3;
thus L148: thesis by L147 , L122;
end;
end;
thus L150: thesis by L133;
end;
theorem
L151: (for R4 being set holds (for R6 being set holds (for R7 being set holds ( ( R4 --> R7 ) | R6 ) = ( ( R4 /\ R6 ) --> R7 ))))
proof
let R4 being set;
let R6 being set;
let R7 being set;
L152: (R4 = ( {} ) or R4 <> ( {} ));
L153: (( R4 /\ R6 ) = ( {} ) or ( R4 /\ R6 ) <> ( {} ));
L154: ( dom ( ( R4 --> R7 ) | R6 ) ) = ( ( dom ( R4 --> R7 ) ) /\ R6 ) by RELAT_1:61
.= ( R4 /\ R6 ) by L152 , RELAT_1:160
.= ( dom ( ( R4 /\ R6 ) --> R7 ) ) by L153 , RELAT_1:160;
L155:
now
let R11 being set;
assume that
L156: R11 in ( dom ( ( R4 /\ R6 ) --> R7 ) );
L157: (( R4 /\ R6 ) = ( {} ) or ( R4 /\ R6 ) <> ( {} ));
L158: R11 in ( R4 /\ R6 ) by L157 , L156 , RELAT_1:160;
L159: R11 in R4 by L158 , XBOOLE_0:def 4;
thus L160: ( ( ( R4 --> R7 ) | R6 ) . R11 ) = ( ( R4 --> R7 ) . R11 ) by L154 , L156 , FUNCT_1:47
.= R7 by L159 , L116
.= ( ( ( R4 /\ R6 ) --> R7 ) . R11 ) by L158 , L116;
end;
thus L161: thesis by L155 , L154 , FUNCT_1:2;
end;
theorem
L162: (for R4 being set holds (for R7 being set holds (( dom ( R4 --> R7 ) ) = R4 & ( rng ( R4 --> R7 ) ) c= { R7 })))
proof
let R4 being set;
let R7 being set;
L163:
now
per cases ;
suppose L164: R4 = ( {} );

L165: ( rng ( ( {} ) --> R7 ) ) = ( {} );
thus L166: thesis by L165 , L164 , XBOOLE_1:2;
end;
suppose L167: R4 <> ( {} );

thus L168: thesis by L167 , RELAT_1:160;
end;
end;
thus L170: thesis by L163;
end;
theorem
L171: (for R4 being set holds (for R6 being set holds (for R7 being set holds (R7 in R6 implies ( ( R4 --> R7 ) " R6 ) = R4))))
proof
let R4 being set;
let R6 being set;
let R7 being set;
assume L172: R7 in R6;
L173:
now
per cases ;
suppose L174: R4 = ( {} );

thus L175: thesis by L174;
end;
suppose L176: R4 <> ( {} );

L177: ( rng ( R4 --> R7 ) ) = { R7 } by L176 , RELAT_1:160;
L178: { R7 } c= R6 by L172 , ZFMISC_1:31;
L179: ( { R7 } /\ R6 ) = { R7 } by L178 , XBOOLE_1:28;
thus L180: ( ( R4 --> R7 ) " R6 ) = ( ( R4 --> R7 ) " { R7 } ) by L179 , L177 , RELAT_1:133
.= ( dom ( R4 --> R7 ) ) by L177 , RELAT_1:134
.= R4 by L162;
end;
end;
thus L182: thesis by L173;
end;
theorem
L183: (for R4 being set holds (for R7 being set holds ( ( R4 --> R7 ) " { R7 } ) = R4))
proof
let R4 being set;
let R7 being set;
L184: R7 in { R7 } by TARSKI:def 1;
thus L185: thesis by L184 , L171;
end;
theorem
L186: (for R4 being set holds (for R6 being set holds (for R7 being set holds ((not R7 in R6) implies ( ( R4 --> R7 ) " R6 ) = ( {} )))))
proof
let R4 being set;
let R6 being set;
let R7 being set;
assume L187: (not R7 in R6);
L188: ( rng ( R4 --> R7 ) ) c= { R7 } by L162;
L189: ( rng ( R4 --> R7 ) ) misses R6 by L188 , L187 , XBOOLE_1:63 , ZFMISC_1:50;
thus L190: thesis by L189 , RELAT_1:138;
end;
theorem
L191: (for R3 being Function holds (for R4 being set holds (for R7 being set holds (R7 in ( dom R3 ) implies ( R3 * ( R4 --> R7 ) ) = ( R4 --> ( R3 . R7 ) )))))
proof
let R3 being Function;
let R4 being set;
let R7 being set;
assume L192: R7 in ( dom R3 );
L193:
now
let R11 being set;
assume L194: R11 in ( dom ( R3 * ( R4 --> R7 ) ) );
L195: R11 in ( dom ( R4 --> R7 ) ) by L194 , FUNCT_1:11;
L196: R11 in R4 by L195 , L162;
thus L197: ( ( R3 * ( R4 --> R7 ) ) . R11 ) = ( R3 . ( ( R4 --> R7 ) . R11 ) ) by L194 , FUNCT_1:12
.= ( R3 . R7 ) by L196 , L116
.= ( ( R4 --> ( R3 . R7 ) ) . R11 ) by L196 , L116;
end;
L198: ( dom ( R3 * ( R4 --> R7 ) ) ) = ( ( R4 --> R7 ) " ( dom R3 ) ) by RELAT_1:147
.= R4 by L192 , L171
.= ( dom ( R4 --> ( R3 . R7 ) ) ) by L162;
thus L199: thesis by L198 , L193 , FUNCT_1:2;
end;
theorem
L200: (for R3 being Function holds (for R4 being set holds (for R7 being set holds ((R4 <> ( {} ) & R7 in ( dom R3 )) implies ( dom ( R3 * ( R4 --> R7 ) ) ) <> ( {} )))))
proof
let R3 being Function;
let R4 being set;
let R7 being set;
assume that
L201: R4 <> ( {} )
and
L202: R7 in ( dom R3 );
set D4 = the (Element of R4);
L203: D4 in R4 by L201;
L204: D4 in ( dom ( R4 --> R7 ) ) by L203 , L162;
L205: ( ( R4 --> R7 ) . D4 ) = R7 by L201 , L116;
thus L206: thesis by L205 , L202 , L204 , FUNCT_1:11;
end;
theorem
L207: (for R3 being Function holds (for R4 being set holds (for R7 being set holds ( ( R4 --> R7 ) * R3 ) = ( ( R3 " R4 ) --> R7 ))))
proof
let R3 being Function;
let R4 being set;
let R7 being set;
L208: ( dom ( ( R4 --> R7 ) * R3 ) ) = ( R3 " ( dom ( R4 --> R7 ) ) ) by RELAT_1:147
.= ( R3 " R4 ) by L162;
L209:
now
let R11 being set;
assume L210: R11 in ( dom ( ( R4 --> R7 ) * R3 ) );
L211: ( R3 . R11 ) in ( dom ( R4 --> R7 ) ) by L210 , FUNCT_1:11;
L212: ( R3 . R11 ) in R4 by L211 , L162;
thus L213: ( ( ( R4 --> R7 ) * R3 ) . R11 ) = ( ( R4 --> R7 ) . ( R3 . R11 ) ) by L210 , FUNCT_1:12
.= R7 by L212 , L116
.= ( ( ( R3 " R4 ) --> R7 ) . R11 ) by L208 , L210 , L116;
end;
L214: ( dom ( ( R4 --> R7 ) * R3 ) ) = ( dom ( ( R3 " R4 ) --> R7 ) ) by L208 , L162;
thus L215: thesis by L214 , L209 , FUNCT_1:2;
end;
theorem
L216: (for R4 being set holds (for R7 being set holds (for R8 being set holds ( ( R4 --> [ R7 , R8 ] ) ~ ) = ( R4 --> [ R8 , R7 ] ))))
proof
let R4 being set;
let R7 being set;
let R8 being set;
L217: ( dom ( ( R4 --> [ R7 , R8 ] ) ~ ) ) = ( dom ( R4 --> [ R7 , R8 ] ) ) by L3;
L218: ( dom ( ( R4 --> [ R7 , R8 ] ) ~ ) ) = R4 by L217 , L162;
L219:
now
let R11 being set;
assume L220: R11 in ( dom ( ( R4 --> [ R7 , R8 ] ) ~ ) );
L221: ( ( R4 --> [ R7 , R8 ] ) . R11 ) = [ R7 , R8 ] by L220 , L218 , L116;
thus L222: ( ( ( R4 --> [ R7 , R8 ] ) ~ ) . R11 ) = [ R8 , R7 ] by L221 , L217 , L220 , L3
.= ( ( R4 --> [ R8 , R7 ] ) . R11 ) by L218 , L220 , L116;
end;
L223: ( dom ( ( R4 --> [ R7 , R8 ] ) ~ ) ) = ( dom ( R4 --> [ R8 , R7 ] ) ) by L218 , L162;
thus L224: thesis by L223 , L219 , FUNCT_1:2;
end;
definition
let R5 being Function;
let R1 being Function;
let R2 being Function;
func R5 .: (R1 , R2) -> set equals 
( R5 * <: R1 , R2 :> );
correctness;
end;
registration
let R5 being Function;
let R1 being Function;
let R2 being Function;
cluster ( R5 .: (R1 , R2) ) ->  Function-like  Relation-like;
coherence;
end;
L227: (for R1 being Function holds (for R2 being Function holds (for R5 being Function holds (for R7 being set holds (R7 in ( dom ( R5 * <: R1 , R2 :> ) ) implies ( ( R5 * <: R1 , R2 :> ) . R7 ) = ( R5 . (( R1 . R7 ) , ( R2 . R7 )) ))))))
proof
let R1 being Function;
let R2 being Function;
let R5 being Function;
let R7 being set;
assume L228: R7 in ( dom ( R5 * <: R1 , R2 :> ) );
L229: R7 in ( dom <: R1 , R2 :> ) by L228 , FUNCT_1:11;
thus L230: ( ( R5 * <: R1 , R2 :> ) . R7 ) = ( R5 . ( <: R1 , R2 :> . R7 ) ) by L228 , FUNCT_1:12
.= ( R5 . (( R1 . R7 ) , ( R2 . R7 )) ) by L229 , FUNCT_3:def 7;
end;
theorem
L231: (for R1 being Function holds (for R2 being Function holds (for R5 being Function holds (for R3 being Function holds ((( dom R3 ) = ( dom ( R5 .: (R1 , R2) ) ) & (for B1 being set holds (B1 in ( dom ( R5 .: (R1 , R2) ) ) implies ( R3 . B1 ) = ( R5 . (( R1 . B1 ) , ( R2 . B1 )) )))) implies R3 = ( R5 .: (R1 , R2) ))))))
proof
let R1 being Function;
let R2 being Function;
let R5 being Function;
let R3 being Function;
assume that
L232: ( dom R3 ) = ( dom ( R5 .: (R1 , R2) ) )
and
L233: (for B2 being set holds (B2 in ( dom ( R5 .: (R1 , R2) ) ) implies ( R3 . B2 ) = ( R5 . (( R1 . B2 ) , ( R2 . B2 )) )));
L234:
now
let C13 being set;
assume L235: C13 in ( dom ( R5 .: (R1 , R2) ) );
thus L236: ( R3 . C13 ) = ( R5 . (( R1 . C13 ) , ( R2 . C13 )) ) by L235 , L233
.= ( ( R5 .: (R1 , R2) ) . C13 ) by L235 , L227;
end;
thus L237: thesis by L234 , L232 , FUNCT_1:2;
end;
theorem
L238: (for R1 being Function holds (for R2 being Function holds (for R5 being Function holds (for R7 being set holds (R7 in ( dom ( R5 .: (R1 , R2) ) ) implies ( ( R5 .: (R1 , R2) ) . R7 ) = ( R5 . (( R1 . R7 ) , ( R2 . R7 )) )))))) by L227;
theorem
L239: (for R1 being Function holds (for R2 being Function holds (for R3 being Function holds (for R4 being set holds (for R5 being Function holds (( R1 | R4 ) = ( R2 | R4 ) implies ( ( R5 .: (R1 , R3) ) | R4 ) = ( ( R5 .: (R2 , R3) ) | R4 )))))))
proof
let R1 being Function;
let R2 being Function;
let R3 being Function;
let R4 being set;
let R5 being Function;
assume L240: ( R1 | R4 ) = ( R2 | R4 );
thus L241: ( ( R5 .: (R1 , R3) ) | R4 ) = ( R5 * ( <: R1 , R3 :> | R4 ) ) by RELAT_1:83
.= ( R5 * <: ( R1 | R4 ) , R3 :> ) by L96
.= ( R5 * ( <: R2 , R3 :> | R4 ) ) by L240 , L96
.= ( ( R5 .: (R2 , R3) ) | R4 ) by RELAT_1:83;
end;
theorem
L242: (for R1 being Function holds (for R2 being Function holds (for R3 being Function holds (for R4 being set holds (for R5 being Function holds (( R1 | R4 ) = ( R2 | R4 ) implies ( ( R5 .: (R3 , R1) ) | R4 ) = ( ( R5 .: (R3 , R2) ) | R4 )))))))
proof
let R1 being Function;
let R2 being Function;
let R3 being Function;
let R4 being set;
let R5 being Function;
assume L243: ( R1 | R4 ) = ( R2 | R4 );
thus L244: ( ( R5 .: (R3 , R1) ) | R4 ) = ( R5 * ( <: R3 , R1 :> | R4 ) ) by RELAT_1:83
.= ( R5 * <: R3 , ( R1 | R4 ) :> ) by L104
.= ( R5 * ( <: R3 , R2 :> | R4 ) ) by L243 , L104
.= ( ( R5 .: (R3 , R2) ) | R4 ) by RELAT_1:83;
end;
theorem
L245: (for R1 being Function holds (for R2 being Function holds (for R3 being Function holds (for R5 being Function holds ( ( R5 .: (R1 , R2) ) * R3 ) = ( R5 .: (( R1 * R3 ) , ( R2 * R3 )) )))))
proof
let R1 being Function;
let R2 being Function;
let R3 being Function;
let R5 being Function;
thus L246: ( ( R5 .: (R1 , R2) ) * R3 ) = ( R5 * ( <: R1 , R2 :> * R3 ) ) by RELAT_1:36
.= ( R5 .: (( R1 * R3 ) , ( R2 * R3 )) ) by FUNCT_3:55;
end;
definition
let R5 being Function;
let R1 being Function;
let R7 being set;
func R5 [:] (R1 , R7) -> set equals 
( R5 * <: R1 , ( ( dom R1 ) --> R7 ) :> );
correctness;
end;
registration
let R5 being Function;
let R1 being Function;
let R7 being set;
cluster ( R5 [:] (R1 , R7) ) ->  Function-like  Relation-like;
coherence;
end;
theorem
L249: (for R1 being Function holds (for R5 being Function holds (for R7 being set holds ( R5 [:] (R1 , R7) ) = ( R5 .: (R1 , ( ( dom R1 ) --> R7 )) ))));
theorem
L250: (for R1 being Function holds (for R5 being Function holds (for R7 being set holds (for R11 being set holds (R7 in ( dom ( R5 [:] (R1 , R11) ) ) implies ( ( R5 [:] (R1 , R11) ) . R7 ) = ( R5 . (( R1 . R7 ) , R11) ))))))
proof
let R1 being Function;
let R5 being Function;
let R7 being set;
let R11 being set;
L251: ( dom <: R1 , ( ( dom R1 ) --> R11 ) :> ) = ( ( dom R1 ) /\ ( dom ( ( dom R1 ) --> R11 ) ) ) by FUNCT_3:def 7;
assume L252: R7 in ( dom ( R5 [:] (R1 , R11) ) );
L253: R7 in ( dom <: R1 , ( ( dom R1 ) --> R11 ) :> ) by L252 , FUNCT_1:11;
L254: R7 in ( dom R1 ) by L253 , L251 , XBOOLE_0:def 4;
thus L255: ( ( R5 [:] (R1 , R11) ) . R7 ) = ( R5 . (( R1 . R7 ) , ( ( ( dom R1 ) --> R11 ) . R7 )) ) by L252 , L227
.= ( R5 . (( R1 . R7 ) , R11) ) by L254 , L116;
end;
theorem
L256: (for R1 being Function holds (for R2 being Function holds (for R4 being set holds (for R5 being Function holds (for R7 being set holds (( R1 | R4 ) = ( R2 | R4 ) implies ( ( R5 [:] (R1 , R7) ) | R4 ) = ( ( R5 [:] (R2 , R7) ) | R4 )))))))
proof
let R1 being Function;
let R2 being Function;
let R4 being set;
let R5 being Function;
let R7 being set;
assume L257: ( R1 | R4 ) = ( R2 | R4 );
L258: ( ( dom R1 ) /\ R4 ) = ( dom ( R1 | R4 ) ) by RELAT_1:61
.= ( ( dom R2 ) /\ R4 ) by L257 , RELAT_1:61;
L259: ( ( ( dom R1 ) --> R7 ) | R4 ) = ( ( ( dom R2 ) /\ R4 ) --> R7 ) by L258 , L151
.= ( ( ( dom R2 ) --> R7 ) | R4 ) by L151;
thus L260: ( ( R5 [:] (R1 , R7) ) | R4 ) = ( ( R5 .: (R1 , ( ( dom R1 ) --> R7 )) ) | R4 )
.= ( ( R5 .: (R2 , ( ( dom R1 ) --> R7 )) ) | R4 ) by L257 , L239
.= ( ( R5 .: (R2 , ( ( dom R2 ) --> R7 )) ) | R4 ) by L259 , L242
.= ( ( R5 [:] (R2 , R7) ) | R4 );
end;
theorem
L261: (for R1 being Function holds (for R3 being Function holds (for R5 being Function holds (for R7 being set holds ( ( R5 [:] (R1 , R7) ) * R3 ) = ( R5 [:] (( R1 * R3 ) , R7) )))))
proof
let R1 being Function;
let R3 being Function;
let R5 being Function;
let R7 being set;
L262: ( dom ( ( dom R1 ) --> R7 ) ) = ( dom R1 ) by L162;
L263: ( dom ( ( ( dom R1 ) --> R7 ) * R3 ) ) = ( dom ( R1 * R3 ) ) by L262 , RELAT_1:163;
L264:
now
let R11 being set;
assume L265: R11 in ( dom ( ( ( dom R1 ) --> R7 ) * R3 ) );
L266: ( R3 . R11 ) in ( dom ( ( dom R1 ) --> R7 ) ) by L265 , FUNCT_1:11;
thus L267: ( ( ( ( dom R1 ) --> R7 ) * R3 ) . R11 ) = ( ( ( dom R1 ) --> R7 ) . ( R3 . R11 ) ) by L265 , FUNCT_1:12
.= R7 by L262 , L266 , L116;
end;
thus L268: ( ( R5 [:] (R1 , R7) ) * R3 ) = ( ( R5 .: (R1 , ( ( dom R1 ) --> R7 )) ) * R3 )
.= ( R5 .: (( R1 * R3 ) , ( ( ( dom R1 ) --> R7 ) * R3 )) ) by L245
.= ( R5 [:] (( R1 * R3 ) , R7) ) by L263 , L264 , L131;
end;
theorem
L269: (for R1 being Function holds (for R4 being set holds (for R5 being Function holds (for R7 being set holds ( ( R5 [:] (R1 , R7) ) * ( id R4 ) ) = ( R5 [:] (( R1 | R4 ) , R7) )))))
proof
let R1 being Function;
let R4 being set;
let R5 being Function;
let R7 being set;
thus L270: ( ( R5 [:] (R1 , R7) ) * ( id R4 ) ) = ( R5 [:] (( R1 * ( id R4 ) ) , R7) ) by L261
.= ( R5 [:] (( R1 | R4 ) , R7) ) by RELAT_1:65;
end;
definition
let R5 being Function;
let R7 being set;
let R2 being Function;
func R5 [;] (R7 , R2) -> set equals 
( R5 * <: ( ( dom R2 ) --> R7 ) , R2 :> );
correctness;
end;
registration
let R5 being Function;
let R7 being set;
let R2 being Function;
cluster ( R5 [;] (R7 , R2) ) ->  Function-like  Relation-like;
coherence;
end;
theorem
L273: (for R2 being Function holds (for R5 being Function holds (for R7 being set holds ( R5 [;] (R7 , R2) ) = ( R5 .: (( ( dom R2 ) --> R7 ) , R2) ))));
theorem
L274: (for R1 being Function holds (for R5 being Function holds (for R7 being set holds (for R11 being set holds (R7 in ( dom ( R5 [;] (R11 , R1) ) ) implies ( ( R5 [;] (R11 , R1) ) . R7 ) = ( R5 . (R11 , ( R1 . R7 )) ))))))
proof
let R1 being Function;
let R5 being Function;
let R7 being set;
let R11 being set;
L275: ( dom <: ( ( dom R1 ) --> R11 ) , R1 :> ) = ( ( dom ( ( dom R1 ) --> R11 ) ) /\ ( dom R1 ) ) by FUNCT_3:def 7;
assume L276: R7 in ( dom ( R5 [;] (R11 , R1) ) );
L277: R7 in ( dom <: ( ( dom R1 ) --> R11 ) , R1 :> ) by L276 , FUNCT_1:11;
L278: R7 in ( dom R1 ) by L277 , L275 , XBOOLE_0:def 4;
thus L279: ( ( R5 [;] (R11 , R1) ) . R7 ) = ( R5 . (( ( ( dom R1 ) --> R11 ) . R7 ) , ( R1 . R7 )) ) by L276 , L227
.= ( R5 . (R11 , ( R1 . R7 )) ) by L278 , L116;
end;
theorem
L280: (for R1 being Function holds (for R2 being Function holds (for R4 being set holds (for R5 being Function holds (for R7 being set holds (( R1 | R4 ) = ( R2 | R4 ) implies ( ( R5 [;] (R7 , R1) ) | R4 ) = ( ( R5 [;] (R7 , R2) ) | R4 )))))))
proof
let R1 being Function;
let R2 being Function;
let R4 being set;
let R5 being Function;
let R7 being set;
assume L281: ( R1 | R4 ) = ( R2 | R4 );
L282: ( ( dom R1 ) /\ R4 ) = ( dom ( R1 | R4 ) ) by RELAT_1:61
.= ( ( dom R2 ) /\ R4 ) by L281 , RELAT_1:61;
L283: ( ( ( dom R1 ) --> R7 ) | R4 ) = ( ( ( dom R2 ) /\ R4 ) --> R7 ) by L282 , L151
.= ( ( ( dom R2 ) --> R7 ) | R4 ) by L151;
thus L284: ( ( R5 [;] (R7 , R1) ) | R4 ) = ( ( R5 .: (( ( dom R1 ) --> R7 ) , R1) ) | R4 )
.= ( ( R5 .: (( ( dom R1 ) --> R7 ) , R2) ) | R4 ) by L281 , L242
.= ( ( R5 .: (( ( dom R2 ) --> R7 ) , R2) ) | R4 ) by L283 , L239
.= ( ( R5 [;] (R7 , R2) ) | R4 );
end;
theorem
L285: (for R1 being Function holds (for R3 being Function holds (for R5 being Function holds (for R7 being set holds ( ( R5 [;] (R7 , R1) ) * R3 ) = ( R5 [;] (R7 , ( R1 * R3 )) )))))
proof
let R1 being Function;
let R3 being Function;
let R5 being Function;
let R7 being set;
L286: ( dom ( ( dom R1 ) --> R7 ) ) = ( dom R1 ) by L162;
L287: ( dom ( ( ( dom R1 ) --> R7 ) * R3 ) ) = ( dom ( R1 * R3 ) ) by L286 , RELAT_1:163;
L288:
now
let R11 being set;
assume L289: R11 in ( dom ( ( ( dom R1 ) --> R7 ) * R3 ) );
L290: ( R3 . R11 ) in ( dom ( ( dom R1 ) --> R7 ) ) by L289 , FUNCT_1:11;
thus L291: ( ( ( ( dom R1 ) --> R7 ) * R3 ) . R11 ) = ( ( ( dom R1 ) --> R7 ) . ( R3 . R11 ) ) by L289 , FUNCT_1:12
.= R7 by L286 , L290 , L116;
end;
thus L292: ( ( R5 [;] (R7 , R1) ) * R3 ) = ( ( R5 .: (( ( dom R1 ) --> R7 ) , R1) ) * R3 )
.= ( R5 .: (( ( ( dom R1 ) --> R7 ) * R3 ) , ( R1 * R3 )) ) by L245
.= ( R5 [;] (R7 , ( R1 * R3 )) ) by L287 , L288 , L131;
end;
theorem
L293: (for R1 being Function holds (for R4 being set holds (for R5 being Function holds (for R7 being set holds ( ( R5 [;] (R7 , R1) ) * ( id R4 ) ) = ( R5 [;] (R7 , ( R1 | R4 )) )))))
proof
let R1 being Function;
let R4 being set;
let R5 being Function;
let R7 being set;
thus L294: ( ( R5 [;] (R7 , R1) ) * ( id R4 ) ) = ( R5 [;] (R7 , ( R1 * ( id R4 ) )) ) by L285
.= ( R5 [;] (R7 , ( R1 | R4 )) ) by RELAT_1:65;
end;
theorem
L295: (for R12 being non  empty set holds (for R13 being set holds (for R14 being (BinOp of R12) holds (for R15 being (Function of R13 , R12) holds (for R16 being (Function of R13 , R12) holds ( R14 .: (R15 , R16) ) is (Function of R13 , R12))))))
proof
let R12 being non  empty set;
let R13 being set;
let R14 being (BinOp of R12);
let R15 being (Function of R13 , R12);
let R16 being (Function of R13 , R12);
L296: ( R14 * <: R15 , R16 :> ) is (Function of R13 , R12);
thus L297: thesis by L296;
end;
definition
let C14 being non  empty set;
let C15 being set;
let C16 being (BinOp of C14);
let C17 , C18 being (Function of C15 , C14);
redefine func C16 .: (C17 , C18) -> (Function of C15 , C14);

coherence by L295;
end;
theorem
L299: (for R12 being non  empty set holds (for R21 being non  empty set holds (for R22 being (BinOp of R12) holds (for R23 being (Function of R21 , R12) holds (for R24 being (Function of R21 , R12) holds (for B3 being (Element of R21) holds ( ( R22 .: (R23 , R24) ) . B3 ) = ( R22 . (( R23 . B3 ) , ( R24 . B3 )) )))))))
proof
let R12 being non  empty set;
let R21 being non  empty set;
let R22 being (BinOp of R12);
let R23 being (Function of R21 , R12);
let R24 being (Function of R21 , R12);
let C19 being (Element of R21);
L300: ( dom ( R22 .: (R23 , R24) ) ) = R21 by FUNCT_2:def 1;
thus L301: thesis by L300 , L227;
end;
theorem
L302: (for R12 being non  empty set holds (for R21 being non  empty set holds (for R22 being (BinOp of R12) holds (for R23 being (Function of R21 , R12) holds (for R24 being (Function of R21 , R12) holds (for B4 being (Function of R21 , R12) holds ((for B5 being (Element of R21) holds ( B4 . B5 ) = ( R22 . (( R23 . B5 ) , ( R24 . B5 )) )) implies B4 = ( R22 .: (R23 , R24) ))))))))
proof
let R12 being non  empty set;
let R21 being non  empty set;
let R22 being (BinOp of R12);
let R23 being (Function of R21 , R12);
let R24 being (Function of R21 , R12);
let C20 being (Function of R21 , R12);
assume L303: (for B6 being (Element of R21) holds ( C20 . B6 ) = ( R22 . (( R23 . B6 ) , ( R24 . B6 )) ));
L304:
now
let C21 being (Element of R21);
thus L305: ( C20 . C21 ) = ( R22 . (( R23 . C21 ) , ( R24 . C21 )) ) by L303
.= ( ( R22 .: (R23 , R24) ) . C21 ) by L299;
end;
thus L306: thesis by L304 , FUNCT_2:63;
end;
theorem
L307: (for R12 being non  empty set holds (for R21 being non  empty set holds (for R22 being (BinOp of R12) holds (for R23 being (Function of R21 , R12) holds (for B7 being (Function of R12 , R12) holds ( ( R22 .: (( id R12 ) , B7) ) * R23 ) = ( R22 .: (R23 , ( B7 * R23 )) ))))))
proof
let R12 being non  empty set;
let R21 being non  empty set;
let R22 being (BinOp of R12);
let R23 being (Function of R21 , R12);
let C22 being (Function of R12 , R12);
thus L308: ( ( R22 .: (( id R12 ) , C22) ) * R23 ) = ( R22 .: (( ( id R12 ) * R23 ) , ( C22 * R23 )) ) by L245
.= ( R22 .: (R23 , ( C22 * R23 )) ) by FUNCT_2:17;
end;
theorem
L309: (for R12 being non  empty set holds (for R21 being non  empty set holds (for R22 being (BinOp of R12) holds (for R23 being (Function of R21 , R12) holds (for B8 being (Function of R12 , R12) holds ( ( R22 .: (B8 , ( id R12 )) ) * R23 ) = ( R22 .: (( B8 * R23 ) , R23) ))))))
proof
let R12 being non  empty set;
let R21 being non  empty set;
let R22 being (BinOp of R12);
let R23 being (Function of R21 , R12);
let C23 being (Function of R12 , R12);
thus L310: ( ( R22 .: (C23 , ( id R12 )) ) * R23 ) = ( R22 .: (( C23 * R23 ) , ( ( id R12 ) * R23 )) ) by L245
.= ( R22 .: (( C23 * R23 ) , R23) ) by FUNCT_2:17;
end;
theorem
L311: (for R12 being non  empty set holds (for R21 being non  empty set holds (for R22 being (BinOp of R12) holds (for R23 being (Function of R21 , R12) holds ( ( R22 .: (( id R12 ) , ( id R12 )) ) * R23 ) = ( R22 .: (R23 , R23) )))))
proof
let R12 being non  empty set;
let R21 being non  empty set;
let R22 being (BinOp of R12);
let R23 being (Function of R21 , R12);
thus L312: ( ( R22 .: (( id R12 ) , ( id R12 )) ) * R23 ) = ( R22 .: (( ( id R12 ) * R23 ) , ( ( id R12 ) * R23 )) ) by L245
.= ( R22 .: (( ( id R12 ) * R23 ) , R23) ) by FUNCT_2:17
.= ( R22 .: (R23 , R23) ) by FUNCT_2:17;
end;
theorem
L313: (for R12 being non  empty set holds (for R22 being (BinOp of R12) holds (for R26 being (Element of R12) holds (for B9 being (Function of R12 , R12) holds ( ( R22 .: (( id R12 ) , B9) ) . R26 ) = ( R22 . (R26 , ( B9 . R26 )) )))))
proof
let R12 being non  empty set;
let R22 being (BinOp of R12);
let R26 being (Element of R12);
let C24 being (Function of R12 , R12);
thus L314: ( ( R22 .: (( id R12 ) , C24) ) . R26 ) = ( R22 . (( ( id R12 ) . R26 ) , ( C24 . R26 )) ) by L299
.= ( R22 . (R26 , ( C24 . R26 )) ) by FUNCT_1:18;
end;
theorem
L315: (for R12 being non  empty set holds (for R22 being (BinOp of R12) holds (for R26 being (Element of R12) holds (for B10 being (Function of R12 , R12) holds ( ( R22 .: (B10 , ( id R12 )) ) . R26 ) = ( R22 . (( B10 . R26 ) , R26) )))))
proof
let R12 being non  empty set;
let R22 being (BinOp of R12);
let R26 being (Element of R12);
let C25 being (Function of R12 , R12);
thus L316: ( ( R22 .: (C25 , ( id R12 )) ) . R26 ) = ( R22 . (( C25 . R26 ) , ( ( id R12 ) . R26 )) ) by L299
.= ( R22 . (( C25 . R26 ) , R26) ) by FUNCT_1:18;
end;
theorem
L317: (for R12 being non  empty set holds (for R22 being (BinOp of R12) holds (for R26 being (Element of R12) holds ( ( R22 .: (( id R12 ) , ( id R12 )) ) . R26 ) = ( R22 . (R26 , R26) ))))
proof
let R12 being non  empty set;
let R22 being (BinOp of R12);
let R26 being (Element of R12);
thus L318: ( ( R22 .: (( id R12 ) , ( id R12 )) ) . R26 ) = ( R22 . (( ( id R12 ) . R26 ) , ( ( id R12 ) . R26 )) ) by L299
.= ( R22 . (( ( id R12 ) . R26 ) , R26) ) by FUNCT_1:18
.= ( R22 . (R26 , R26) ) by FUNCT_1:18;
end;
theorem
L319: (for R4 being set holds (for R6 being set holds (for B11 being set holds (B11 in R6 implies ( R4 --> B11 ) is (Function of R4 , R6)))))
proof
let R4 being set;
let R6 being set;
let C26 being set;
L320: ( rng ( R4 --> C26 ) ) c= { C26 } by L162;
L321: ( dom ( R4 --> C26 ) ) = R4 by L162;
assume L322: C26 in R6;
L323: { C26 } c= R6 by L322 , ZFMISC_1:31;
L324: ( rng ( R4 --> C26 ) ) c= R6 by L323 , L320 , XBOOLE_1:1;
thus L325: thesis by L324 , L322 , L321 , FUNCT_2:def 1 , RELSET_1:4;
end;
definition
let C27 , C28 being set;
redefine func C27 --> C28 -> (Function of C27 , { C28 });

coherence
proof
L326: (( dom ( C27 --> C28 ) ) = C27 & ( rng ( C27 --> C28 ) ) c= { C28 }) by L162;
thus L327: thesis by L326 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
definition
let C29 being non  empty set;
let C30 being set;
let C31 being (Element of C29);
redefine func C30 --> C31 -> (Function of C30 , C29);

coherence by L319;
end;
theorem
L330: (for R4 being set holds (for R12 being non  empty set holds (for R26 being (Element of R12) holds ( R4 --> R26 ) is (Function of R4 , R12))));
theorem
L331: (for R12 being non  empty set holds (for R29 being set holds (for R30 being (BinOp of R12) holds (for R31 being (Function of R29 , R12) holds (for R34 being (Element of R12) holds ( R30 [:] (R31 , R34) ) is (Function of R29 , R12))))))
proof
let R12 being non  empty set;
let R29 being set;
let R30 being (BinOp of R12);
let R31 being (Function of R29 , R12);
let R34 being (Element of R12);
L332: ( dom R31 ) = R29 by FUNCT_2:def 1;
reconsider D5 = ( ( dom R31 ) --> R34 ) as (Function of R29 , R12) by L332;
L333: ( R30 * <: R31 , D5 :> ) is (Function of R29 , R12);
thus L334: thesis by L333;
end;
definition
let C32 being non  empty set;
let C33 being set;
let C34 being (BinOp of C32);
let C35 being (Function of C33 , C32);
let C36 being (Element of C32);
redefine func C34 [:] (C35 , C36) -> (Function of C33 , C32);

coherence by L331;
end;
theorem
L336: (for R12 being non  empty set holds (for R37 being non  empty set holds (for R38 being (BinOp of R12) holds (for R39 being (Function of R37 , R12) holds (for R42 being (Element of R12) holds (for B12 being (Element of R37) holds ( ( R38 [:] (R39 , R42) ) . B12 ) = ( R38 . (( R39 . B12 ) , R42) )))))))
proof
let R12 being non  empty set;
let R37 being non  empty set;
let R38 being (BinOp of R12);
let R39 being (Function of R37 , R12);
let R42 being (Element of R12);
let C37 being (Element of R37);
L337: ( dom ( R38 [:] (R39 , R42) ) ) = R37 by FUNCT_2:def 1;
thus L338: thesis by L337 , L250;
end;
theorem
L339: (for R12 being non  empty set holds (for R37 being non  empty set holds (for R38 being (BinOp of R12) holds (for R39 being (Function of R37 , R12) holds (for R40 being (Function of R37 , R12) holds (for R42 being (Element of R12) holds ((for B13 being (Element of R37) holds ( R40 . B13 ) = ( R38 . (( R39 . B13 ) , R42) )) implies R40 = ( R38 [:] (R39 , R42) ))))))))
proof
let R12 being non  empty set;
let R37 being non  empty set;
let R38 being (BinOp of R12);
let R39 being (Function of R37 , R12);
let R40 being (Function of R37 , R12);
let R42 being (Element of R12);
assume L340: (for B14 being (Element of R37) holds ( R40 . B14 ) = ( R38 . (( R39 . B14 ) , R42) ));
L341:
now
let C38 being (Element of R37);
thus L342: ( R40 . C38 ) = ( R38 . (( R39 . C38 ) , R42) ) by L340
.= ( ( R38 [:] (R39 , R42) ) . C38 ) by L336;
end;
thus L343: thesis by L341 , FUNCT_2:63;
end;
theorem
L344: (for R12 being non  empty set holds (for R37 being non  empty set holds (for R38 being (BinOp of R12) holds (for R39 being (Function of R37 , R12) holds (for R42 being (Element of R12) holds ( ( R38 [:] (( id R12 ) , R42) ) * R39 ) = ( R38 [:] (R39 , R42) ))))))
proof
let R12 being non  empty set;
let R37 being non  empty set;
let R38 being (BinOp of R12);
let R39 being (Function of R37 , R12);
let R42 being (Element of R12);
thus L345: ( ( R38 [:] (( id R12 ) , R42) ) * R39 ) = ( R38 [:] (( ( id R12 ) * R39 ) , R42) ) by L261
.= ( R38 [:] (R39 , R42) ) by FUNCT_2:17;
end;
theorem
L346: (for R12 being non  empty set holds (for R38 being (BinOp of R12) holds (for R42 being (Element of R12) holds ( ( R38 [:] (( id R12 ) , R42) ) . R42 ) = ( R38 . (R42 , R42) ))))
proof
let R12 being non  empty set;
let R38 being (BinOp of R12);
let R42 being (Element of R12);
thus L347: ( ( R38 [:] (( id R12 ) , R42) ) . R42 ) = ( R38 . (( ( id R12 ) . R42 ) , R42) ) by L336
.= ( R38 . (R42 , R42) ) by FUNCT_1:18;
end;
theorem
L348: (for R12 being non  empty set holds (for R45 being set holds (for R46 being (BinOp of R12) holds (for R48 being (Function of R45 , R12) holds (for R50 being (Element of R12) holds ( R46 [;] (R50 , R48) ) is (Function of R45 , R12))))))
proof
let R12 being non  empty set;
let R45 being set;
let R46 being (BinOp of R12);
let R48 being (Function of R45 , R12);
let R50 being (Element of R12);
L349: ( dom R48 ) = R45 by FUNCT_2:def 1;
reconsider D6 = ( ( dom R48 ) --> R50 ) as (Function of R45 , R12) by L349;
L350: ( R46 * <: D6 , R48 :> ) is (Function of R45 , R12);
thus L351: thesis by L350;
end;
definition
let C39 being non  empty set;
let C40 being set;
let C41 being (BinOp of C39);
let C42 being (Element of C39);
let C43 being (Function of C40 , C39);
redefine func C41 [;] (C42 , C43) -> (Function of C40 , C39);

coherence by L348;
end;
theorem
L353: (for R12 being non  empty set holds (for R53 being non  empty set holds (for R54 being (BinOp of R12) holds (for R55 being (Function of R53 , R12) holds (for R58 being (Element of R12) holds (for B15 being (Element of R53) holds ( ( R54 [;] (R58 , R55) ) . B15 ) = ( R54 . (R58 , ( R55 . B15 )) )))))))
proof
let R12 being non  empty set;
let R53 being non  empty set;
let R54 being (BinOp of R12);
let R55 being (Function of R53 , R12);
let R58 being (Element of R12);
let C44 being (Element of R53);
L354: ( dom ( R54 [;] (R58 , R55) ) ) = R53 by FUNCT_2:def 1;
thus L355: thesis by L354 , L274;
end;
theorem
L356: (for R12 being non  empty set holds (for R53 being non  empty set holds (for R54 being (BinOp of R12) holds (for R55 being (Function of R53 , R12) holds (for R56 being (Function of R53 , R12) holds (for R58 being (Element of R12) holds ((for B16 being (Element of R53) holds ( R56 . B16 ) = ( R54 . (R58 , ( R55 . B16 )) )) implies R56 = ( R54 [;] (R58 , R55) ))))))))
proof
let R12 being non  empty set;
let R53 being non  empty set;
let R54 being (BinOp of R12);
let R55 being (Function of R53 , R12);
let R56 being (Function of R53 , R12);
let R58 being (Element of R12);
assume L357: (for B17 being (Element of R53) holds ( R56 . B17 ) = ( R54 . (R58 , ( R55 . B17 )) ));
L358:
now
let C45 being (Element of R53);
thus L359: ( R56 . C45 ) = ( R54 . (R58 , ( R55 . C45 )) ) by L357
.= ( ( R54 [;] (R58 , R55) ) . C45 ) by L353;
end;
thus L360: thesis by L358 , FUNCT_2:63;
end;
theorem
L361: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R66 being (Element of R12) holds ( ( R62 [;] (R66 , ( id R12 )) ) * R63 ) = ( R62 [;] (R66 , R63) ))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R66 being (Element of R12);
thus L362: ( ( R62 [;] (R66 , ( id R12 )) ) * R63 ) = ( R62 [;] (R66 , ( ( id R12 ) * R63 )) ) by L285
.= ( R62 [;] (R66 , R63) ) by FUNCT_2:17;
end;
theorem
L363: (for R12 being non  empty set holds (for R62 being (BinOp of R12) holds (for R66 being (Element of R12) holds ( ( R62 [;] (R66 , ( id R12 )) ) . R66 ) = ( R62 . (R66 , R66) ))))
proof
let R12 being non  empty set;
let R62 being (BinOp of R12);
let R66 being (Element of R12);
thus L364: ( ( R62 [;] (R66 , ( id R12 )) ) . R66 ) = ( R62 . (R66 , ( ( id R12 ) . R66 )) ) by L353
.= ( R62 . (R66 , R66) ) by FUNCT_1:18;
end;
theorem
L365: (for B18 , B19 , B20 being non  empty set holds (for B21 being (Function of B18 , [: B19 , B20 :]) holds (for B22 being (Element of B18) holds ( ( B21 ~ ) . B22 ) = [ ( ( B21 . B22 ) `2 ) , ( ( B21 . B22 ) `1 ) ])))
proof
let C46 , C47 , C48 being non  empty set;
let C49 being (Function of C46 , [: C47 , C48 :]);
let C50 being (Element of C46);
L366: C50 in C46;
L367: C50 in ( dom C49 ) by L366 , FUNCT_2:def 1;
L368: ( C49 . C50 ) = [ ( ( C49 . C50 ) `1 ) , ( ( C49 . C50 ) `2 ) ] by MCART_1:22;
thus L369: thesis by L368 , L367 , L3;
end;
definition
let C51 , C52 , C53 being non  empty set;
let C54 being (Function of C51 , [: C52 , C53 :]);
redefine func rng C54 -> (Relation of C52 , C53);

coherence by RELAT_1:def 19;
end;
definition
let C55 , C56 , C57 being non  empty set;
let C58 being (Function of C55 , [: C56 , C57 :]);
redefine func C58 ~ -> (Function of C55 , [: C57 , C56 :]);

coherence
proof
L371: ( rng ( C58 ~ ) ) c= [: C57 , C56 :]
proof
let C59 being set;
assume L372: C59 in ( rng ( C58 ~ ) );
consider C60 being set such that L373: C60 in ( dom ( C58 ~ ) ) and L374: C59 = ( ( C58 ~ ) . C60 ) by L372 , FUNCT_1:def 3;
L375: C60 in ( dom C58 ) by L373 , L3;
reconsider D7 = C60 as (Element of C55) by L375;
L376: ( C58 . D7 ) = [ ( ( C58 . D7 ) `1 ) , ( ( C58 . D7 ) `2 ) ] by MCART_1:21;
L377: ( ( C58 ~ ) . D7 ) = [ ( ( C58 . D7 ) `2 ) , ( ( C58 . D7 ) `1 ) ] by L376 , L375 , L3;
thus L378: thesis by L377 , L374 , L376 , ZFMISC_1:88;
end;
L379: C55 = ( dom C58 ) by FUNCT_2:def 1
.= ( dom ( C58 ~ ) ) by L3;
thus L380: thesis by L379 , L371 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
theorem
L382: (for B23 , B24 , B25 being non  empty set holds (for B26 being (Function of B23 , [: B24 , B25 :]) holds ( rng ( B26 ~ ) ) = ( ( rng B26 ) ~ )))
proof
let C61 , C62 , C63 being non  empty set;
let C64 being (Function of C61 , [: C62 , C63 :]);
let C65 , C66 being set;
thus L383: ([ C65 , C66 ] in ( rng ( C64 ~ ) ) implies [ C65 , C66 ] in ( ( rng C64 ) ~ ))
proof
assume L384: [ C65 , C66 ] in ( rng ( C64 ~ ) );
consider C67 being set such that L385: C67 in ( dom ( C64 ~ ) ) and L386: [ C65 , C66 ] = ( ( C64 ~ ) . C67 ) by L384 , FUNCT_1:def 3;
L387: C67 in ( dom C64 ) by L385 , L3;
L388: ( C64 . C67 ) = ( ( ( C64 ~ ) ~ ) . C67 )
.= [ C66 , C65 ] by L385 , L386 , L3;
L389: [ C66 , C65 ] in ( rng C64 ) by L388 , L387 , FUNCT_1:def 3;
thus L390: thesis by L389 , RELAT_1:def 7;
end;

assume L391: [ C65 , C66 ] in ( ( rng C64 ) ~ );
L392: [ C66 , C65 ] in ( rng C64 ) by L391 , RELAT_1:def 7;
consider C68 being set such that L393: (C68 in ( dom C64 ) & [ C66 , C65 ] = ( C64 . C68 )) by L392 , FUNCT_1:def 3;
L394: (C68 in ( dom ( C64 ~ ) ) & ( ( C64 ~ ) . C68 ) = [ C65 , C66 ]) by L393 , L3;
thus L395: thesis by L394 , FUNCT_1:def 3;
end;
theorem
L396: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R67 being (Element of R12) holds (for R68 being (Element of R12) holds (R62 is  associative implies ( R62 [:] (( R62 [;] (R67 , R63) ) , R68) ) = ( R62 [;] (R67 , ( R62 [:] (R63 , R68) )) ))))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R67 being (Element of R12);
let R68 being (Element of R12);
assume L397: R62 is  associative;
per cases ;
suppose L398: R61 = ( {} );

thus L399: thesis by L398;
end;
suppose L400: R61 <> ( {} );

L401:
now
let R69 being (Element of R61);
reconsider D8 = ( R63 . R69 ) as (Element of R12) by L400 , FUNCT_2:5;
thus L402: ( ( R62 [:] (( R62 [;] (R67 , R63) ) , R68) ) . R69 ) = ( R62 . (( ( R62 [;] (R67 , R63) ) . R69 ) , R68) ) by L400 , L336
.= ( R62 . (( R62 . (R67 , D8) ) , R68) ) by L400 , L353
.= ( R62 . (R67 , ( R62 . (D8 , R68) )) ) by L397 , BINOP_1:def 3
.= ( R62 . (R67 , ( ( R62 [:] (R63 , R68) ) . R69 )) ) by L400 , L336;
end;
thus L403: thesis by L401 , L400 , L356;
end;
end;
theorem
L405: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R64 being (Function of R61 , R12) holds (for R66 being (Element of R12) holds (R62 is  associative implies ( R62 .: (( R62 [:] (R63 , R66) ) , R64) ) = ( R62 .: (R63 , ( R62 [;] (R66 , R64) )) ))))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R64 being (Function of R61 , R12);
let R66 being (Element of R12);
assume L406: R62 is  associative;
per cases ;
suppose L407: R61 = ( {} );

thus L408: thesis by L407;
end;
suppose L409: R61 <> ( {} );

L410:
now
let R69 being (Element of R61);
reconsider D9 = ( R63 . R69 ) , D10 = ( R64 . R69 ) as (Element of R12) by L409 , FUNCT_2:5;
thus L411: ( ( R62 .: (( R62 [:] (R63 , R66) ) , R64) ) . R69 ) = ( R62 . (( ( R62 [:] (R63 , R66) ) . R69 ) , ( R64 . R69 )) ) by L409 , L299
.= ( R62 . (( R62 . (D9 , R66) ) , D10) ) by L409 , L336
.= ( R62 . (D9 , ( R62 . (R66 , D10) )) ) by L406 , BINOP_1:def 3
.= ( R62 . (( R63 . R69 ) , ( ( R62 [;] (R66 , R64) ) . R69 )) ) by L409 , L353;
end;
thus L412: thesis by L410 , L409 , L302;
end;
end;
theorem
L414: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R64 being (Function of R61 , R12) holds (for R65 being (Function of R61 , R12) holds (R62 is  associative implies ( R62 .: (( R62 .: (R63 , R64) ) , R65) ) = ( R62 .: (R63 , ( R62 .: (R64 , R65) )) ))))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R64 being (Function of R61 , R12);
let R65 being (Function of R61 , R12);
assume L415: R62 is  associative;
per cases ;
suppose L416: R61 = ( {} );

thus L417: thesis by L416;
end;
suppose L418: R61 <> ( {} );

L419:
now
let R69 being (Element of R61);
reconsider D11 = ( R63 . R69 ) , D12 = ( R64 . R69 ) , D13 = ( R65 . R69 ) as (Element of R12) by L418 , FUNCT_2:5;
thus L420: ( ( R62 .: (( R62 .: (R63 , R64) ) , R65) ) . R69 ) = ( R62 . (( ( R62 .: (R63 , R64) ) . R69 ) , ( R65 . R69 )) ) by L418 , L299
.= ( R62 . (( R62 . (( R63 . R69 ) , ( R64 . R69 )) ) , ( R65 . R69 )) ) by L418 , L299
.= ( R62 . (D11 , ( R62 . (D12 , D13) )) ) by L415 , BINOP_1:def 3
.= ( R62 . (( R63 . R69 ) , ( ( R62 .: (R64 , R65) ) . R69 )) ) by L418 , L299;
end;
thus L421: thesis by L419 , L418 , L302;
end;
end;
theorem
L423: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R67 being (Element of R12) holds (for R68 being (Element of R12) holds (R62 is  associative implies ( R62 [;] (( R62 . (R67 , R68) ) , R63) ) = ( R62 [;] (R67 , ( R62 [;] (R68 , R63) )) ))))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R67 being (Element of R12);
let R68 being (Element of R12);
assume L424: R62 is  associative;
per cases ;
suppose L425: R61 = ( {} );

thus L426: thesis by L425;
end;
suppose L427: R61 <> ( {} );

L428:
now
let R69 being (Element of R61);
reconsider D14 = ( R63 . R69 ) as (Element of R12) by L427 , FUNCT_2:5;
thus L429: ( ( R62 [;] (( R62 . (R67 , R68) ) , R63) ) . R69 ) = ( R62 . (( R62 . (R67 , R68) ) , ( R63 . R69 )) ) by L427 , L353
.= ( R62 . (R67 , ( R62 . (R68 , D14) )) ) by L424 , BINOP_1:def 3
.= ( R62 . (R67 , ( ( R62 [;] (R68 , R63) ) . R69 )) ) by L427 , L353;
end;
thus L430: thesis by L428 , L427 , L356;
end;
end;
theorem
L432: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R67 being (Element of R12) holds (for R68 being (Element of R12) holds (R62 is  associative implies ( R62 [:] (R63 , ( R62 . (R67 , R68) )) ) = ( R62 [:] (( R62 [:] (R63 , R67) ) , R68) ))))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R67 being (Element of R12);
let R68 being (Element of R12);
assume L433: R62 is  associative;
per cases ;
suppose L434: R61 = ( {} );

thus L435: thesis by L434;
end;
suppose L436: R61 <> ( {} );

L437:
now
let R69 being (Element of R61);
reconsider D15 = ( R63 . R69 ) as (Element of R12) by L436 , FUNCT_2:5;
thus L438: ( ( R62 [:] (R63 , ( R62 . (R67 , R68) )) ) . R69 ) = ( R62 . (( R63 . R69 ) , ( R62 . (R67 , R68) )) ) by L436 , L336
.= ( R62 . (( R62 . (D15 , R67) ) , R68) ) by L433 , BINOP_1:def 3
.= ( R62 . (( ( R62 [:] (R63 , R67) ) . R69 ) , R68) ) by L436 , L336;
end;
thus L439: thesis by L437 , L436 , L339;
end;
end;
theorem
L441: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R66 being (Element of R12) holds (R62 is  commutative implies ( R62 [;] (R66 , R63) ) = ( R62 [:] (R63 , R66) )))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R66 being (Element of R12);
assume L442: R62 is  commutative;
per cases ;
suppose L443: R61 = ( {} );

thus L444: thesis by L443;
end;
suppose L445: R61 <> ( {} );

L446:
now
let R69 being (Element of R61);
reconsider D16 = ( R63 . R69 ) as (Element of R12) by L445 , FUNCT_2:5;
thus L447: ( ( R62 [;] (R66 , R63) ) . R69 ) = ( R62 . (R66 , D16) ) by L445 , L353
.= ( R62 . (( R63 . R69 ) , R66) ) by L442 , BINOP_1:def 2;
end;
thus L448: thesis by L446 , L445 , L339;
end;
end;
theorem
L450: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (for R64 being (Function of R61 , R12) holds (R62 is  commutative implies ( R62 .: (R63 , R64) ) = ( R62 .: (R64 , R63) )))))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
let R64 being (Function of R61 , R12);
assume L451: R62 is  commutative;
per cases ;
suppose L452: R61 = ( {} );

thus L453: thesis by L452;
end;
suppose L454: R61 <> ( {} );

L455:
now
let R69 being (Element of R61);
reconsider D17 = ( R63 . R69 ) , D18 = ( R64 . R69 ) as (Element of R12) by L454 , FUNCT_2:5;
thus L456: ( ( R62 .: (R63 , R64) ) . R69 ) = ( R62 . (D17 , D18) ) by L454 , L299
.= ( R62 . (( R64 . R69 ) , ( R63 . R69 )) ) by L451 , BINOP_1:def 2;
end;
thus L457: thesis by L455 , L454 , L302;
end;
end;
theorem
L459: (for R12 being non  empty set holds (for R61 being set holds (for R62 being (BinOp of R12) holds (for R63 being (Function of R61 , R12) holds (R62 is  idempotent implies ( R62 .: (R63 , R63) ) = R63)))))
proof
let R12 being non  empty set;
let R61 being set;
let R62 being (BinOp of R12);
let R63 being (Function of R61 , R12);
assume L460: R62 is  idempotent;
per cases ;
suppose L461: R61 = ( {} );

thus L462: ( R62 .: (R63 , R63) ) = ( {} ) by L461
.= R63 by L461;
end;
suppose L463: R61 <> ( {} );

L464:
now
let R69 being (Element of R61);
reconsider D19 = ( R63 . R69 ) as (Element of R12) by L463 , FUNCT_2:5;
thus L465: ( R63 . R69 ) = ( R62 . (D19 , D19) ) by L460
.= ( R62 . (( R63 . R69 ) , ( R63 . R69 )) );
end;
thus L466: thesis by L464 , L463 , L302;
end;
end;
theorem
L468: (for R12 being non  empty set holds (for R70 being non  empty set holds (for R71 being (BinOp of R12) holds (for R72 being (Function of R70 , R12) holds (for R74 being (Element of R70) holds (R71 is  idempotent implies ( ( R71 [;] (( R72 . R74 ) , R72) ) . R74 ) = ( R72 . R74 )))))))
proof
let R12 being non  empty set;
let R70 being non  empty set;
let R71 being (BinOp of R12);
let R72 being (Function of R70 , R12);
let R74 being (Element of R70);
assume L469: R71 is  idempotent;
thus L470: ( ( R71 [;] (( R72 . R74 ) , R72) ) . R74 ) = ( R71 . (( R72 . R74 ) , ( R72 . R74 )) ) by L353
.= ( R72 . R74 ) by L469;
end;
theorem
L471: (for R12 being non  empty set holds (for R70 being non  empty set holds (for R71 being (BinOp of R12) holds (for R72 being (Function of R70 , R12) holds (for R74 being (Element of R70) holds (R71 is  idempotent implies ( ( R71 [:] (R72 , ( R72 . R74 )) ) . R74 ) = ( R72 . R74 )))))))
proof
let R12 being non  empty set;
let R70 being non  empty set;
let R71 being (BinOp of R12);
let R72 being (Function of R70 , R12);
let R74 being (Element of R70);
assume L472: R71 is  idempotent;
thus L473: ( ( R71 [:] (R72 , ( R72 . R74 )) ) . R74 ) = ( R71 . (( R72 . R74 ) , ( R72 . R74 )) ) by L336
.= ( R72 . R74 ) by L472;
end;
theorem
L474: (for B27 , B28 , B29 being Function holds ([: ( rng B28 ) , ( rng B29 ) :] c= ( dom B27 ) implies ( dom ( B27 .: (B28 , B29) ) ) = ( ( dom B28 ) /\ ( dom B29 ) )))
proof
let C69 , C70 , C71 being Function;
assume that
L475: [: ( rng C70 ) , ( rng C71 ) :] c= ( dom C69 );
L476: ( rng <: C70 , C71 :> ) c= [: ( rng C70 ) , ( rng C71 ) :] by FUNCT_3:51;
thus L477: ( dom ( C69 .: (C70 , C71) ) ) = ( dom <: C70 , C71 :> ) by L476 , L475 , RELAT_1:27 , XBOOLE_1:1
.= ( ( dom C70 ) /\ ( dom C71 ) ) by FUNCT_3:def 7;
end;
definition
let C72 being Function;
attr C72 is  Function-yielding
means
:L478: (for B30 being set holds (B30 in ( dom C72 ) implies ( C72 . B30 ) is Function));
end;
registration
cluster  Function-yielding for Function;
existence
proof
take ( the set --> the Function );
let C73 being set;
thus L480: thesis;
end;
end;
registration
let C74 being  Function-yielding Function;
let C75 being set;
cluster ( C74 . C75 ) ->  Function-like  Relation-like;
coherence
proof
per cases ;
suppose L482: C75 in ( dom C74 );

thus L483: thesis by L482 , L478;
end;
suppose L484: (not C75 in ( dom C74 ));

thus L485: thesis by L484 , FUNCT_1:def 2;
end;
end;
end;
registration
let C76 being  Function-yielding Function;
let C77 being Function;
cluster ( C76 * C77 ) ->  Function-yielding;
coherence
proof
thus L488: ( C76 * C77 ) is  Function-yielding
proof
let C78 being set;
assume L489: C78 in ( dom ( C76 * C77 ) );
L490: ( ( C76 * C77 ) . C78 ) = ( C76 . ( C77 . C78 ) ) by L489 , FUNCT_1:12;
thus L491: thesis by L490;
end;

end;
end;
registration
let R6 being set;
let C79 being non  empty set;
cluster ( R6 --> C79 ) ->  non-empty;
coherence
proof
L490: (not ( {} ) in ( rng ( R6 --> C79 ) )) by TARSKI:def 1;
thus L491: thesis by L490 , RELAT_1:def 9;
end;
end;
theorem
L493: (for R11 being set holds (for R12 being non  empty set holds (for R70 being non  empty set holds (for R73 being (Element of R12) holds (for R74 being (Element of R70) holds ( ( [: R12 , R70 :] --> R11 ) . (R73 , R74) ) = R11)))))
proof
let R11 being set;
let R12 being non  empty set;
let R70 being non  empty set;
let R73 being (Element of R12);
let R74 being (Element of R70);
L494: [ R73 , R74 ] in [: R12 , R70 :] by ZFMISC_1:87;
thus L495: thesis by L494 , L116;
end;
definition
let R75 being set;
let R76 being set;
let R77 being set;
func (R75 , R76) .--> R77 -> Function equals 
( { [ R75 , R76 ] } --> R77 );
coherence;
end;
theorem
L497: (for R75 being set holds (for R76 being set holds (for R77 being set holds ( ( (R75 , R76) .--> R77 ) . (R75 , R76) ) = R77)))
proof
let R75 being set;
let R76 being set;
let R77 being set;
L498: [ R75 , R76 ] in { [ R75 , R76 ] } by TARSKI:def 1;
thus L499: thesis by L498 , L116;
end;
definition
let C80 , C81 , C82 , C83 being set;
func IFEQ (C80 , C81 , C82 , C83) -> set equals 
:L500: C82 if C80 = C81 otherwise C83;
correctness;
end;
definition
let C84 being set;
let C85 , C86 being set;
let C87 , C88 being (Element of C84);
redefine func IFEQ (C85 , C86 , C87 , C88) -> (Element of C84);

coherence
proof
L502: (C85 = C86 or C85 <> C86);
thus L503: thesis by L502 , L500;
end;
end;
definition
let C89 , C90 being set;
func C89 .--> C90 -> set equals 
( { C89 } --> C90 );
coherence;
end;
registration
let C91 , C92 being set;
cluster ( C91 .--> C92 ) ->  Function-like  Relation-like;
coherence;
end;
registration
let C93 , C94 being set;
cluster ( C93 .--> C94 ) ->  one-to-one;
coherence
proof
let C95 , C96 being set;
set D20 = ( C93 .--> C94 );
assume that
L507: C95 in ( dom D20 )
and
L508: C96 in ( dom D20 );
L509: ( dom D20 ) = { C93 } by L162;
L510: C95 = C93 by L509 , L507 , TARSKI:def 1;
thus L511: thesis by L510 , L509 , L508 , TARSKI:def 1;
end;
end;
theorem
L513: (for B31 , B32 being set holds ( ( B31 .--> B32 ) . B31 ) = B32)
proof
let C97 , C98 being set;
L514: C97 in { C97 } by TARSKI:def 1;
thus L515: thesis by L514 , L116;
end;
theorem
L516: (for B33 , B34 being set holds (for B35 being Function holds (( B33 .--> B34 ) c= B35 iff (B33 in ( dom B35 ) & ( B35 . B33 ) = B34))))
proof
let C99 , C100 being set;
let C101 being Function;
L517: ( dom ( C99 .--> C100 ) ) = { C99 } by L162;
L518: C99 in ( dom ( C99 .--> C100 ) ) by L517 , TARSKI:def 1;
thus L519:now
assume L520: ( C99 .--> C100 ) c= C101;
L521: { C99 } c= ( dom C101 ) by L520 , L517 , GRFUNC_1:2;
thus L522: C99 in ( dom C101 ) by L521 , ZFMISC_1:31;
thus L523: ( C101 . C99 ) = ( ( C99 .--> C100 ) . C99 ) by L518 , L520 , GRFUNC_1:2
.= C100 by L513;
end;
assume that
L524: C99 in ( dom C101 )
and
L525: ( C101 . C99 ) = C100;
L526:
now
let C102 being set;
assume L527: C102 in ( dom ( C99 .--> C100 ) );
L528: C102 = C99 by L527 , L517 , TARSKI:def 1;
thus L529: ( ( C99 .--> C100 ) . C102 ) = ( C101 . C102 ) by L528 , L525 , L513;
end;
L530: ( dom ( C99 .--> C100 ) ) c= ( dom C101 ) by L517 , L524 , ZFMISC_1:31;
thus L531: thesis by L530 , L526 , GRFUNC_1:2;
end;
notation
let C103 , C104 , C105 being set;
synonym (C103 , C104) :-> C105 for (C103 , C104) .--> C105;
end;
L533: (for B36 , B37 , B38 being set holds ( (B36 , B37) :-> B38 ) is (Function of [: { B36 } , { B37 } :] , { B38 }))
proof
let C106 , C107 , C108 being set;
L534: ( dom ( (C106 , C107) :-> C108 ) ) = { [ C106 , C107 ] } by L162
.= [: { C106 } , { C107 } :] by ZFMISC_1:29;
thus L535: thesis by L534 , FUNCT_2:def 1;
end;
definition
let C109 , C110 , C111 being set;
redefine func (C109 , C110) :-> C111 -> (Function of [: { C109 } , { C110 } :] , { C111 }) means 
(not contradiction);
coherence by L533;
compatibility
proof
let C112 being (Function of [: { C109 } , { C110 } :] , { C111 });
L536: ( (C109 , C110) .--> C111 ) is (Function of [: { C109 } , { C110 } :] , { C111 }) by L533;
thus L537: thesis by L536 , FUNCT_2:51;
end;
end;
theorem
L539: (for R78 being set holds (for R79 being set holds R78 in ( dom ( R78 .--> R79 ) )))
proof
let R78 being set;
let R79 being set;
L540: ( dom ( R78 .--> R79 ) ) = { R78 } by L162;
thus L541: thesis by L540 , TARSKI:def 1;
end;
theorem
L542: (for R78 being set holds (for R79 being set holds (for R80 being set holds (R80 in ( dom ( R78 .--> R79 ) ) implies R80 = R78))))
proof
let R78 being set;
let R79 being set;
let R80 being set;
L543: ( dom ( R78 .--> R79 ) ) = { R78 } by L162;
thus L544: thesis by L543 , TARSKI:def 1;
end;
theorem
L545: (for R4 being set holds (for R78 being set holds (for R79 being set holds ((not R78 in R4) implies ( ( R78 .--> R79 ) | R4 ) = ( {} )))))
proof
let R4 being set;
let R78 being set;
let R79 being set;
assume L546: (not R78 in R4);
L547: { R78 } misses R4 by L546 , ZFMISC_1:50;
L548: ( dom ( R78 .--> R79 ) ) misses R4 by L547 , L162;
thus L549: thesis by L548 , RELAT_1:66;
end;
notation
let R78 being set;
let R79 being set;
synonym R78 :-> R79 for R78 .--> R79;
end;
definition
let C113 , C114 being set;
redefine func C113 :-> C114 -> (Function of { C113 } , { C114 });

coherence;
end;
theorem
L552: (for R75 being set holds (for R76 being set holds (for R77 being set holds (for B39 being (Element of { R75 }) holds (for B40 being (Element of { R76 }) holds ( ( (R75 , R76) :-> R77 ) . (B39 , B40) ) = R77))))) by TARSKI:def 1;
registration
let C115 being  Function-yielding Function;
let C116 being set;
cluster ( C115 | C116 ) ->  Function-yielding;
coherence
proof
let C117 being set;
L553: ( C115 . C117 ) is Function;
thus L554: thesis by L553 , FUNCT_1:47;
end;
end;
registration
let C118 being set;
let C119 being Function;
cluster ( C118 --> C119 ) ->  Function-yielding;
coherence
proof
let C120 being set;
thus L556: thesis;
end;
end;
registration
let C121 , C122 being set;
cluster ( C121 --> C122 ) ->  constant;
coherence
proof
let C123 , C124 being set;
assume that
L558: C123 in ( dom ( C121 --> C122 ) )
and
L559: C124 in ( dom ( C121 --> C122 ) );
thus L560: ( ( C121 --> C122 ) . C123 ) = C122 by L558 , L116
.= ( ( C121 --> C122 ) . C124 ) by L559 , L116;
end;
end;
registration
cluster non  empty  constant for Function;
existence
proof
take ( { ( {} ) } --> ( {} ) );
thus L562: thesis;
end;
end;
registration
let C125 being  constant Function;
let C126 being set;
cluster ( C125 | C126 ) ->  constant;
coherence
proof
let C127 , C128 being set;
L564: ( dom ( C125 | C126 ) ) c= ( dom C125 ) by RELAT_1:60;
assume that
L565: C127 in ( dom ( C125 | C126 ) )
and
L566: C128 in ( dom ( C125 | C126 ) );
thus L567: ( ( C125 | C126 ) . C127 ) = ( C125 . C127 ) by L565 , FUNCT_1:47
.= ( C125 . C128 ) by L564 , L565 , L566 , FUNCT_1:def 10
.= ( ( C125 | C126 ) . C128 ) by L566 , FUNCT_1:47;
end;
end;
theorem
L569: (for B41 being non  empty  constant Function holds (ex R79 being set st (for R78 being set holds (R78 in ( dom B41 ) implies ( B41 . R78 ) = R79))))
proof
let C129 being non  empty  constant Function;
consider R79 being set such that L570: R79 in ( rng C129 ) by XBOOLE_0:def 1;
take R79;
L571: (ex B42 being set st (B42 in ( dom C129 ) & ( C129 . B42 ) = R79)) by L570 , FUNCT_1:def 3;
thus L572: thesis by L571 , FUNCT_1:def 10;
end;
theorem
L573: (for B43 being non  empty set holds (for B44 being set holds ( the_value_of ( B43 --> B44 ) ) = B44))
proof
let C130 being non  empty set;
let C131 being set;
set D21 = ( C130 --> C131 );
L574: (ex B45 being set st (B45 in ( dom D21 ) & ( the_value_of D21 ) = ( D21 . B45 ))) by FUNCT_1:def 12;
thus L575: thesis by L574 , L116;
end;
theorem
L576: (for B46 being  constant Function holds B46 = ( ( dom B46 ) --> ( the_value_of B46 ) ))
proof
let C132 being  constant Function;
thus L577: ( dom ( ( dom C132 ) --> ( the_value_of C132 ) ) ) = ( dom C132 ) by L162;
let C133 being set;
assume L578: C133 in ( dom C132 );
L579: (C132 <> ( {} ) & ( ( ( dom C132 ) --> ( the_value_of C132 ) ) . C133 ) = ( the_value_of C132 )) by L578 , L116;
thus L580: thesis by L579 , L578 , FUNCT_1:def 12;
end;
registration
let C134 being set;
let C135 being non  empty set;
cluster  total for (PartFunc of C134 , C135);
existence
proof
consider C136 being set such that L581: C136 in C135 by XBOOLE_0:def 1;
reconsider D22 = C136 as (Element of C135) by L581;
take ( C134 --> D22 );
thus L582: thesis;
end;
end;
registration
let C137 , C138 being set;
cluster ( C137 --> C138 ) -> C137 -defined;
coherence;
end;
registration
let C139 , C140 being set;
cluster ( C139 .--> C140 ) -> { C139 } -defined;
coherence;
end;
theorem
L586: (for R4 being set holds (for R6 being set holds (for R78 being set holds ( ( R4 --> R78 ) .: R6 ) c= { R78 })));
registration
let C141 being set;
let C142 being Function;
cluster ( C141 .--> C142 ) ->  Function-yielding;
coherence;
end;
registration
let C143 being set;
cluster  total for C143 -defined  non-empty C143 -defined  non-empty C143 -defined  non-empty C143 -defined  non-empty Function;
existence
proof
take ( C143 --> 1 );
thus L588: thesis;
end;
end;
theorem
L590: (for R78 being set holds (for R79 being set holds ( R78 .--> R79 ) is_isomorphism_of { [ R78 , R78 ] } , { [ R79 , R79 ] }))
proof
let R78 being set;
let R79 being set;
set D23 = ( R78 .--> R79 );
set D24 = { [ R78 , R78 ] };
set D25 = { [ R79 , R79 ] };
L591: ( field D24 ) = { R78 } by RELAT_1:173;
thus L592: ( dom D23 ) = ( field D24 ) by L591 , L162;
L593: ( field D25 ) = { R79 } by RELAT_1:173;
thus L594: ( rng D23 ) = ( field D25 ) by L593 , RELAT_1:160;
thus L595: D23 is  one-to-one;
let C144 , C145 being set;
thus L596:now
assume L597: [ C144 , C145 ] in D24;
L598: [ C144 , C145 ] = [ R78 , R78 ] by L597 , TARSKI:def 1;
L599: (C144 = R78 & C145 = R78) by L598 , XTUPLE_0:1;
thus L600: (C144 in ( field D24 ) & C145 in ( field D24 )) by L599 , L591 , TARSKI:def 1;
L601: ( D23 . R78 ) = R79 by L513;
thus L602: [ ( D23 . C144 ) , ( D23 . C145 ) ] in D25 by L601 , L599 , TARSKI:def 1;
end;
assume L603: (C144 in ( field D24 ) & C145 in ( field D24 ));
L604: (C144 = R78 & C145 = R78) by L603 , L591 , TARSKI:def 1;
thus L605: thesis by L604 , TARSKI:def 1;
end;
theorem
L606: (for R78 being set holds (for R79 being set holds { [ R78 , R78 ] } , { [ R79 , R79 ] } are_isomorphic ))
proof
let R78 being set;
let R79 being set;
take ( R78 .--> R79 );
thus L607: thesis by L590;
end;
registration
let C146 , C147 being set;
cluster ( C146 --> C147 ) ->  total for C146 -defined C146 -defined C146 -defined C146 -defined Function;
coherence;
end;
theorem
L609: (for R78 being set holds (for B47 being Function holds (R78 in ( dom B47 ) implies ( R78 .--> ( B47 . R78 ) ) c= B47)))
proof
let R78 being set;
let C148 being Function;
assume L610: R78 in ( dom C148 );
L611: [ R78 , ( C148 . R78 ) ] in C148 by L610 , FUNCT_1:1;
L612: { [ R78 , ( C148 . R78 ) ] } c= C148 by L611 , ZFMISC_1:31;
thus L613: thesis by L612 , ZFMISC_1:29;
end;
registration
let C149 being non  empty set;
let C150 being set;
let C151 being (Element of C149);
cluster ( C150 .--> C151 ) -> C149 -valued;
coherence
proof
L614: ( rng ( C150 .--> C151 ) ) = { C151 } by RELAT_1:160;
thus L615: ( rng ( C150 .--> C151 ) ) c= C149 by L614 , ZFMISC_1:31;
end;
end;
theorem
L617: (for R12 being non  empty set holds (for R71 being (BinOp of R12) holds (for R81 being set holds (for R82 being (Function of R81 , R12) holds (for R83 being (Function of R81 , R12) holds (for R84 being (Element of R12) holds (R71 is  associative implies ( R71 .: (( R71 [;] (R84 , R82) ) , R83) ) = ( R71 [;] (R84 , ( R71 .: (R82 , R83) )) ))))))))
proof
let R12 being non  empty set;
let R71 being (BinOp of R12);
let R81 being set;
let R82 being (Function of R81 , R12);
let R83 being (Function of R81 , R12);
let R84 being (Element of R12);
assume L618: R71 is  associative;
per cases ;
suppose L619: R81 = ( {} );

thus L620: thesis by L619;
end;
suppose L621: R81 <> ( {} );

L622:
now
let R85 being (Element of R81);
reconsider D26 = ( R82 . R85 ) , D27 = ( R83 . R85 ) as (Element of R12) by L621 , FUNCT_2:5;
thus L623: ( ( R71 [;] (R84 , ( R71 .: (R82 , R83) )) ) . R85 ) = ( R71 . (R84 , ( ( R71 .: (R82 , R83) ) . R85 )) ) by L621 , L353
.= ( R71 . (R84 , ( R71 . (D26 , D27) )) ) by L621 , L299
.= ( R71 . (( R71 . (R84 , D26) ) , D27) ) by L618 , BINOP_1:def 3
.= ( R71 . (( ( R71 [;] (R84 , R82) ) . R85 ) , ( R83 . R85 )) ) by L621 , L353;
end;
thus L624: thesis by L622 , L621 , L302;
end;
end;
registration
let C152 being set;
let C153 being non  empty set;
let C154 being (Element of C153);
cluster ( C152 --> C154 ) -> C153 -valued;
coherence;
end;
registration
let C155 being non  empty set;
let C156 being (Element of C155);
let C157 being set;
cluster ( C156 .--> C157 ) -> C155 -defined;
coherence
proof
L627: ( dom ( C156 .--> C157 ) ) = { C156 } by L162;
thus L628: ( dom ( C156 .--> C157 ) ) c= C155 by L627 , ZFMISC_1:31;
end;
end;
theorem
L630: (for B48 , B49 , B50 being set holds (B48 in B50 implies ( ( B48 .--> B49 ) | B50 ) = ( B48 .--> B49 )))
proof
let C158 , C159 , C160 being set;
assume L631: C158 in C160;
L632: { C158 } c= C160 by L631 , ZFMISC_1:31;
L633: ( dom ( C158 .--> C159 ) ) c= C160 by L632 , L162;
thus L634: thesis by L633 , RELAT_1:68;
end;
registration
let C161 being  functional set;
cluster C161 -valued ->  Function-yielding for Function;
coherence
proof
let C162 being Function;
assume L635: C162 is C161 -valued;
let C163 being set;
thus L636: thesis by L635;
end;
end;
definition
let C164 being Function;
attr C164 is  Relation-yielding
means
(for B51 being set holds (B51 in ( dom C164 ) implies ( C164 . B51 ) is Relation));
end;
registration
cluster  Function-yielding ->  Relation-yielding for Function;
coherence
proof
let C165 being Function;
assume L639: C165 is  Function-yielding;
let C166 being set;
thus L640: thesis by L639;
end;
end;
registration
cluster  empty ->  Function-yielding for Function;
coherence
proof
let C167 being Function;
assume L642: C167 is  empty;
let C168 being set;
thus L643: thesis by L642;
end;
end;
theorem
L645: (for B52 , B53 , B54 , B55 being set holds (( B52 --> B54 ) tolerates ( B53 --> B55 ) iff (B54 = B55 or B52 misses B53)))
proof
let C169 , C170 , C171 , C172 being set;
set D28 = ( C169 --> C171 );
set D29 = ( C170 --> C172 );
L646: ( dom D29 ) = C170 by L162;
L647: ( dom D28 ) = C169 by L162;
thus L648: (D28 tolerates D29 implies (C171 = C172 or C169 misses C170))
proof
assume that
L649: (for B56 being set holds (B56 in ( ( dom D28 ) /\ ( dom D29 ) ) implies ( D28 . B56 ) = ( D29 . B56 )))
and
L650: C171 <> C172;
assume L651: C169 meets C170;
consider C173 being set such that L652: C173 in C169 and L653: C173 in C170 by L651 , XBOOLE_0:3;
L654: ( D28 . C173 ) = C171 by L652 , L116;
L655: ( D29 . C173 ) = C172 by L653 , L116;
L656: C173 in ( C169 /\ C170 ) by L652 , L653 , XBOOLE_0:def 4;
thus L657: thesis by L656 , L647 , L646 , L649 , L650 , L654 , L655;
end;

assume L658: (C171 = C172 or C169 misses C170);
let C174 being set;
assume L659: C174 in ( ( dom D28 ) /\ ( dom D29 ) );
L660: C174 in C170 by L659;
L661: C174 in C169 by L647 , L659 , XBOOLE_0:def 4;
L662: ( D28 . C174 ) = C171 by L661 , L116;
thus L663: thesis by L662 , L658 , L661 , L660 , L116 , XBOOLE_0:3;
end;
theorem
L664: (for R86 being set holds (for R87 being set holds ( rng ( R86 .--> R87 ) ) = { R87 }))
proof
let R86 being set;
let R87 being set;
L665: ( dom ( R86 .--> R87 ) ) = { R86 } by L162;
thus L666: ( rng ( R86 .--> R87 ) ) = { ( ( R86 .--> R87 ) . R86 ) } by L665 , FUNCT_1:4
.= { R87 } by L513;
end;
theorem
L667: (for R86 being set holds (for R87 being set holds (for R88 being set holds (for R89 being set holds (R88 in R89 implies ( ( R89 --> R86 ) * ( R87 .--> R88 ) ) = ( R87 .--> R86 ))))))
proof
let R86 being set;
let R87 being set;
let R88 being set;
let R89 being set;
assume L668: R88 in R89;
L669: ( dom ( R87 .--> R88 ) ) = { R87 } by L162
.= ( dom ( R87 .--> R86 ) ) by L162;
L670: ( rng ( R87 .--> R88 ) ) = { R88 } by L664;
L671: ( rng ( R87 .--> R88 ) ) c= R89 by L670 , L668 , ZFMISC_1:31;
L672: ( rng ( R87 .--> R88 ) ) c= ( dom ( R89 --> R86 ) ) by L671 , L162;
thus L673: ( dom ( ( R89 --> R86 ) * ( R87 .--> R88 ) ) ) = ( dom ( R87 .--> R86 ) ) by L672 , L669 , RELAT_1:27;
let C175 being set;
assume L674: C175 in ( dom ( ( R89 --> R86 ) * ( R87 .--> R88 ) ) );
thus L675: ( ( ( R89 --> R86 ) * ( R87 .--> R88 ) ) . C175 ) = ( ( R89 --> R86 ) . ( ( R87 .--> R88 ) . C175 ) ) by L674 , FUNCT_1:12
.= ( ( R89 --> R86 ) . R88 ) by L674 , L116
.= R86 by L668 , L116
.= ( ( R87 .--> R86 ) . C175 ) by L674 , L116;
end;
