:: Some Set Series in Finite Topological Spaces. {F}undamental Concepts
:: for Image Processing
::  by Masami Tanaka and Yatsuka Nakamura
::
:: Received January 26, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ORDERS_2, SUBSET_1, FIN_TOPO, TARSKI, PRE_TOPC,
      FUNCT_1, NUMBERS, ZFMISC_1, STRUCT_0, ARYTM_3, CARD_1, RELAT_1, NAT_1,
      FINTOPO3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ORDINAL1, NAT_1,
      RELAT_1, FUNCT_1, FUNCT_2, FIN_TOPO, PRE_TOPC, STRUCT_0, ORDERS_2;
 constructors NAT_1, FIN_TOPO, RELSET_1;
 registrations SUBSET_1, ORDINAL1, RELSET_1, STRUCT_0, FIN_TOPO;
 requirements SUBSET, NUMERALS, ARITHM, BOOLE;
 definitions TARSKI, XBOOLE_0, SUBSET_1;
 theorems TARSKI, SUBSET_1, FUNCT_1, FUNCT_2, XBOOLE_0, XBOOLE_1, FIN_TOPO,
      FINTOPO2, ORDINAL1;
 schemes RECDEF_1, NAT_1, DOMAIN_1;

begin
definition
let R1 being non  empty RelStr;
let C1 being (Subset of R1);
func C1 ^d -> (Subset of R1) equals 
{ B1 where B1 is (Element of R1) : (for B2 being (Element of R1) holds (B2 in ( C1 ` ) implies (not B1 in ( U_FT B2 )))) };
coherence
proof
defpred S1[ (Element of R1) ] means (for R6 being (Element of R1) holds (R6 in ( C1 ` ) implies (not $1 in ( U_FT R6 ))));
L1: { R4 where R4 is (Element of R1) : S1[ R4 ] } is (Subset of R1) from DOMAIN_1:sch 7;
thus L2: thesis by L1;
end;
end;
theorem
L4: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies R2 c= ( R2 ^f ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
assume L5: R1 is  filled;
let C2 being set;
assume L6: C2 in R2;
reconsider D1 = C2 as (Element of R1) by L6;
L7: D1 in ( U_FT D1 ) by L5 , FIN_TOPO:def 4;
thus L8: thesis by L7 , L6 , FIN_TOPO:11;
end;
theorem
L9: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R4 being (Element of R1) holds (R4 in ( R2 ^d ) iff (for R6 being (Element of R1) holds (R6 in ( R2 ` ) implies (not R4 in ( U_FT R6 ))))))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R4 being (Element of R1);
thus L10: (R4 in ( R2 ^d ) implies (for R6 being (Element of R1) holds (R6 in ( R2 ` ) implies (not R4 in ( U_FT R6 )))))
proof
assume L11: R4 in ( R2 ^d );
L12: (ex R6 being (Element of R1) st (R6 = R4 & (for R7 being (Element of R1) holds (R7 in ( R2 ` ) implies (not R6 in ( U_FT R7 )))))) by L11;
thus L13: thesis by L12;
end;

assume L14: (for R7 being (Element of R1) holds (R7 in ( R2 ` ) implies (not R4 in ( U_FT R7 ))));
thus L15: thesis by L14;
end;
theorem
L16: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies ( R2 ^d ) c= R2)))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
assume L17: R1 is  filled;
thus L18: ( R2 ^d ) c= R2
proof
let C3 being set;
assume L19: C3 in ( R2 ^d );
reconsider D2 = C3 as (Element of R1) by L19;
L20:
now
assume L21: (not C3 in R2);
L22: C3 in ( R2 ` ) by L21 , L19 , SUBSET_1:29;
L23: C3 in ( U_FT D2 ) by L17 , FIN_TOPO:def 4;
thus L24: contradiction by L23 , L19 , L22 , L9;
end;
thus L25: thesis by L20;
end;

end;
theorem
L19: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( R2 ^d ) = ( ( ( R2 ` ) ^f ) ` )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L20: (for B3 being set holds (B3 in ( R2 ^d ) iff B3 in ( ( ( R2 ` ) ^f ) ` )))
proof
let C4 being set;
L21: ( ( R2 ` ) ^f ) = { R5 where R5 is (Element of R1) : (ex R6 being (Element of R1) st (R6 in ( R2 ` ) & R5 in ( U_FT R6 ))) } by FIN_TOPO:def 12;
thus L22: (C4 in ( R2 ^d ) implies C4 in ( ( ( R2 ` ) ^f ) ` ))
proof
L23: ( ( R2 ` ) ^f ) = { R5 where R5 is (Element of R1) : (ex R6 being (Element of R1) st (R6 in ( R2 ` ) & R5 in ( U_FT R6 ))) } by FIN_TOPO:def 12;
assume L24: C4 in ( R2 ^d );
L25: (not (ex R5 being (Element of R1) st (R5 = C4 & (ex R6 being (Element of R1) st (R6 in ( R2 ` ) & R5 in ( U_FT R6 )))))) by L24 , L9;
L26: (not C4 in ( ( R2 ` ) ^f )) by L25 , L23;
thus L27: thesis by L26 , L24 , SUBSET_1:29;
end;

assume L28: C4 in ( ( ( R2 ` ) ^f ) ` );
L29: (not C4 in ( ( R2 ` ) ^f )) by L28 , XBOOLE_0:def 5;
L30: (for R6 being (Element of R1) holds (R6 in ( R2 ` ) implies (not C4 in ( U_FT R6 )))) by L29 , L21;
thus L31: thesis by L30 , L28;
end;
thus L32: thesis by L20 , TARSKI:1;
end;
theorem
L33: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (R2 c= R3 implies ( R2 ^f ) c= ( R3 ^f )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
assume L34: R2 c= R3;
let C5 being set;
assume L35: C5 in ( R2 ^f );
L36: (ex R6 being (Element of R1) st (R6 in R2 & C5 in ( U_FT R6 ))) by L35 , FIN_TOPO:11;
thus L37: thesis by L36 , L34 , FIN_TOPO:11;
end;
theorem
L38: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (R2 c= R3 implies ( R2 ^d ) c= ( R3 ^d )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
assume L39: R2 c= R3;
L40: ( R3 ` ) c= ( R2 ` ) by L39 , SUBSET_1:12;
let C6 being set;
assume L41: C6 in ( R2 ^d );
L42: (for R6 being (Element of R1) holds (R6 in ( R3 ` ) implies (not C6 in ( U_FT R6 )))) by L41 , L40 , L9;
thus L43: thesis by L42 , L41;
end;
theorem
L44: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( ( R2 /\ R3 ) ^b ) c= ( ( R2 ^b ) /\ ( R3 ^b ) ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C7 being set;
assume L45: C7 in ( ( R2 /\ R3 ) ^b );
reconsider D3 = C7 as (Point of R1) by L45;
L46: ( U_FT D3 ) meets ( R2 /\ R3 ) by L45 , FIN_TOPO:8;
L47: ( U_FT D3 ) meets R3 by L46 , XBOOLE_1:74;
L48: C7 in ( R3 ^b ) by L47 , FIN_TOPO:8;
L49: ( U_FT D3 ) meets R2 by L46 , XBOOLE_1:74;
L50: C7 in ( R2 ^b ) by L49 , FIN_TOPO:8;
thus L51: thesis by L50 , L48 , XBOOLE_0:def 4;
end;
theorem
L52: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( ( R2 \/ R3 ) ^b ) = ( ( R2 ^b ) \/ ( R3 ^b ) ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
thus L53: ( ( R2 \/ R3 ) ^b ) c= ( ( R2 ^b ) \/ ( R3 ^b ) )
proof
let C8 being set;
assume L54: C8 in ( ( R2 \/ R3 ) ^b );
reconsider D4 = C8 as (Point of R1) by L54;
L55: ( U_FT D4 ) meets ( R2 \/ R3 ) by L54 , FIN_TOPO:8;
L56: (( U_FT D4 ) meets R2 or ( U_FT D4 ) meets R3) by L55 , XBOOLE_1:70;
L57: (C8 in ( R2 ^b ) or C8 in ( R3 ^b )) by L56 , FIN_TOPO:8;
thus L58: thesis by L57 , XBOOLE_0:def 3;
end;

let C9 being set;
assume L59: C9 in ( ( R2 ^b ) \/ ( R3 ^b ) );
reconsider D5 = C9 as (Point of R1) by L59;
L60: (C9 in ( R2 ^b ) or C9 in ( R3 ^b )) by L59 , XBOOLE_0:def 3;
L61: (( U_FT D5 ) meets R2 or ( U_FT D5 ) meets R3) by L60 , FIN_TOPO:8;
L62: ( U_FT D5 ) meets ( R2 \/ R3 ) by L61 , XBOOLE_1:70;
thus L63: thesis by L62 , FIN_TOPO:8;
end;
theorem
L64: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( ( R2 ^i ) \/ ( R3 ^i ) ) c= ( ( R2 \/ R3 ) ^i ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C10 being set;
assume L65: C10 in ( ( R2 ^i ) \/ ( R3 ^i ) );
reconsider D6 = C10 as (Point of R1) by L65;
L66: (C10 in ( R2 ^i ) or C10 in ( R3 ^i )) by L65 , XBOOLE_0:def 3;
L67: (( U_FT D6 ) c= R2 or ( U_FT D6 ) c= R3) by L66 , FIN_TOPO:7;
L68: (R2 c= ( R2 \/ R3 ) & R3 c= ( R2 \/ R3 )) by XBOOLE_1:7;
L69: ( U_FT D6 ) c= ( R2 \/ R3 ) by L68 , L67 , XBOOLE_1:1;
thus L70: thesis by L69 , FIN_TOPO:7;
end;
theorem
L71: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( ( R2 ^i ) /\ ( R3 ^i ) ) = ( ( R2 /\ R3 ) ^i ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
thus L72: ( ( R2 ^i ) /\ ( R3 ^i ) ) c= ( ( R2 /\ R3 ) ^i )
proof
let C11 being set;
assume L73: C11 in ( ( R2 ^i ) /\ ( R3 ^i ) );
reconsider D7 = C11 as (Point of R1) by L73;
L74: C11 in ( R3 ^i ) by L73 , XBOOLE_0:def 4;
L75: ( U_FT D7 ) c= R3 by L74 , FIN_TOPO:7;
L76: C11 in ( R2 ^i ) by L73 , XBOOLE_0:def 4;
L77: ( U_FT D7 ) c= R2 by L76 , FIN_TOPO:7;
L78: ( U_FT D7 ) c= ( R2 /\ R3 ) by L77 , L75 , XBOOLE_1:19;
thus L79: thesis by L78 , FIN_TOPO:7;
end;

let C12 being set;
assume L80: C12 in ( ( R2 /\ R3 ) ^i );
reconsider D8 = C12 as (Point of R1) by L80;
L81: ( U_FT D8 ) c= ( R2 /\ R3 ) by L80 , FIN_TOPO:7;
L82: ( U_FT D8 ) c= R3 by L81 , XBOOLE_1:18;
L83: C12 in ( R3 ^i ) by L82 , FIN_TOPO:7;
L84: ( U_FT D8 ) c= R2 by L81 , XBOOLE_1:18;
L85: C12 in ( R2 ^i ) by L84 , FIN_TOPO:7;
thus L86: thesis by L85 , L83 , XBOOLE_0:def 4;
end;
theorem
L87: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( ( R2 ^f ) \/ ( R3 ^f ) ) = ( ( R2 \/ R3 ) ^f ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
L88: (( R2 ^f ) c= ( ( R2 \/ R3 ) ^f ) & ( R3 ^f ) c= ( ( R2 \/ R3 ) ^f )) by L33 , XBOOLE_1:7;
thus L89: ( ( R2 ^f ) \/ ( R3 ^f ) ) c= ( ( R2 \/ R3 ) ^f ) by L88 , XBOOLE_1:8;
let C13 being set;
assume L90: C13 in ( ( R2 \/ R3 ) ^f );
consider R6 being (Element of R1) such that L91: R6 in ( R2 \/ R3 ) and L92: C13 in ( U_FT R6 ) by L90 , FIN_TOPO:11;
per cases  by L91 , XBOOLE_0:def 3;
suppose L93: R6 in R2;

L94: C13 in ( R2 ^f ) by L93 , L92 , FIN_TOPO:11;
thus L95: thesis by L94 , XBOOLE_0:def 3;
end;
suppose L96: R6 in R3;

L97: C13 in ( R3 ^f ) by L96 , L92 , FIN_TOPO:11;
thus L98: thesis by L97 , XBOOLE_0:def 3;
end;
end;
theorem
L100: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds ( ( R2 ^d ) /\ ( R3 ^d ) ) = ( ( R2 /\ R3 ) ^d ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
L101: ( R3 ^d ) = ( ( ( R3 ` ) ^f ) ` ) by L19;
thus L102: ( ( R2 ^d ) /\ ( R3 ^d ) ) = ( ( ( ( R2 ` ) ^f ) ` ) /\ ( R3 ^d ) ) by L19
.= ( ( ( ( R2 ` ) ^f ) \/ ( ( R3 ` ) ^f ) ) ` ) by L101 , XBOOLE_1:53
.= ( ( ( ( R2 ` ) \/ ( R3 ` ) ) ^f ) ` ) by L87
.= ( ( ( ( R2 /\ R3 ) ` ) ^f ) ` ) by XBOOLE_1:54
.= ( ( R2 /\ R3 ) ^d ) by L19;
end;
definition
let C14 being non  empty RelStr;
let C15 being (Subset of C14);
func Fcl C15 -> (Function of ( NAT ) , ( bool (the carrier of C14) )) means 
:L103: ((for B4 being (Element of ( NAT )) holds (for B5 being (Subset of C14) holds (B5 = ( it . B4 ) implies ( it . ( B4 + 1 ) ) = ( B5 ^b )))) & ( it . ( 0 ) ) = C15);
existence
proof
defpred S2[ set , set , set ] means (for B6 being (Subset of C14) holds (B6 = $2 implies $3 = ( B6 ^b )));
L104: (for B7 being (Element of ( NAT )) holds (for B8 being (Subset of C14) holds (ex B9 being (Subset of C14) st S2[ B7 , B8 , B9 ])))
proof
let C16 being (Element of ( NAT ));
let C17 being (Subset of C14);
reconsider D9 = C17 as (Subset of C14);
L105: S2[ C16 , C17 , ( D9 ^b ) ];
thus L106: thesis by L105;
end;
L107: (ex B10 being (Function of ( NAT ) , ( bool (the carrier of C14) )) st (( B10 . ( 0 ) ) = C15 & (for B11 being (Element of ( NAT )) holds S2[ B11 , ( B10 . B11 ) , ( B10 . ( B11 + 1 ) ) ]))) from RECDEF_1:sch 2(L104);
thus L108: thesis by L107;
end;
uniqueness
proof
let C18 , C19 being (Function of ( NAT ) , ( bool (the carrier of C14) ));
assume that
L109: (for B12 being (Element of ( NAT )) holds (for B13 being (Subset of C14) holds (B13 = ( C18 . B12 ) implies ( C18 . ( B12 + 1 ) ) = ( B13 ^b ))))
and
L110: ( C18 . ( 0 ) ) = C15
and
L111: (for B14 being (Element of ( NAT )) holds (for B15 being (Subset of C14) holds (B15 = ( C19 . B14 ) implies ( C19 . ( B14 + 1 ) ) = ( B15 ^b ))))
and
L112: ( C19 . ( 0 ) ) = C15;
defpred S3[ (Element of ( NAT )) ] means ( C18 . $1 ) = ( C19 . $1 );
L113: (for B16 being (Element of ( NAT )) holds (S3[ B16 ] implies S3[ ( B16 + 1 ) ]))
proof
let C20 being (Element of ( NAT ));
assume L114: S3[ C20 ];
reconsider D10 = ( C18 . C20 ) as (Subset of C14);
L115: ( D10 ^b ) = ( C18 . ( C20 + 1 ) ) by L109;
thus L116: thesis by L115 , L111 , L114;
end;
L117: ( dom C18 ) = ( NAT ) by FUNCT_2:def 1;
L118: ( dom C18 ) = ( dom C19 ) by L117 , FUNCT_2:def 1;
L119: S3[ ( 0 ) ] by L110 , L112;
L120: (for B17 being (Element of ( NAT )) holds S3[ B17 ]) from NAT_1:sch 1(L119 , L113);
L121: (for B18 being set holds (B18 in ( dom C18 ) implies ( C18 . B18 ) = ( C19 . B18 ))) by L120 , L117;
thus L122: C18 = C19 by L121 , L118 , FUNCT_1:2;
end;
end;
definition
let C21 being non  empty RelStr;
let C22 being (Subset of C21);
let C23 being Nat;
func Fcl (C22 , C23) -> (Subset of C21) equals 
( ( Fcl C22 ) . C23 );
coherence
proof
reconsider D11 = C23 as (Element of ( NAT )) by ORDINAL1:def 12;
L124: ( ( Fcl C22 ) . D11 ) c= (the carrier of C21);
thus L125: thesis by L124;
end;
end;
definition
let C24 being non  empty RelStr;
let C25 being (Subset of C24);
func Fint C25 -> (Function of ( NAT ) , ( bool (the carrier of C24) )) means 
:L127: ((for B19 being (Element of ( NAT )) holds (for B20 being (Subset of C24) holds (B20 = ( it . B19 ) implies ( it . ( B19 + 1 ) ) = ( B20 ^i )))) & ( it . ( 0 ) ) = C25);
existence
proof
defpred S4[ set , set , set ] means (for B21 being (Subset of C24) holds (B21 = $2 implies $3 = ( B21 ^i )));
L128: (for B22 being (Element of ( NAT )) holds (for B23 being (Subset of C24) holds (ex B24 being (Subset of C24) st S4[ B22 , B23 , B24 ])))
proof
let C26 being (Element of ( NAT ));
let C27 being (Subset of C24);
reconsider D12 = C27 as (Subset of C24);
L129: (for B25 being (Subset of C24) holds (B25 = C27 implies ( D12 ^i ) = ( B25 ^i )));
thus L130: thesis by L129;
end;
L131: (ex B26 being (Function of ( NAT ) , ( bool (the carrier of C24) )) st (( B26 . ( 0 ) ) = C25 & (for B27 being (Element of ( NAT )) holds S4[ B27 , ( B26 . B27 ) , ( B26 . ( B27 + 1 ) ) ]))) from RECDEF_1:sch 2(L128);
thus L132: thesis by L131;
end;
uniqueness
proof
let C28 , C29 being (Function of ( NAT ) , ( bool (the carrier of C24) ));
assume that
L133: (for B28 being (Element of ( NAT )) holds (for B29 being (Subset of C24) holds (B29 = ( C28 . B28 ) implies ( C28 . ( B28 + 1 ) ) = ( B29 ^i ))))
and
L134: ( C28 . ( 0 ) ) = C25
and
L135: (for B30 being (Element of ( NAT )) holds (for B31 being (Subset of C24) holds (B31 = ( C29 . B30 ) implies ( C29 . ( B30 + 1 ) ) = ( B31 ^i ))))
and
L136: ( C29 . ( 0 ) ) = C25;
defpred S5[ (Element of ( NAT )) ] means ( C28 . $1 ) = ( C29 . $1 );
L137: (for B32 being (Element of ( NAT )) holds (S5[ B32 ] implies S5[ ( B32 + 1 ) ]))
proof
let C30 being (Element of ( NAT ));
assume L138: S5[ C30 ];
reconsider D13 = ( C28 . C30 ) as (Subset of C24);
L139: ( D13 ^i ) = ( C28 . ( C30 + 1 ) ) by L133;
thus L140: thesis by L139 , L135 , L138;
end;
L141: ( dom C28 ) = ( NAT ) by FUNCT_2:def 1;
L142: ( dom C28 ) = ( dom C29 ) by L141 , FUNCT_2:def 1;
L143: S5[ ( 0 ) ] by L134 , L136;
L144: (for B33 being (Element of ( NAT )) holds S5[ B33 ]) from NAT_1:sch 1(L143 , L137);
L145: (for B34 being set holds (B34 in ( dom C28 ) implies ( C28 . B34 ) = ( C29 . B34 ))) by L144 , L141;
thus L146: C28 = C29 by L145 , L142 , FUNCT_1:2;
end;
end;
definition
let C31 being non  empty RelStr;
let C32 being (Subset of C31);
let C33 being Nat;
func Fint (C32 , C33) -> (Subset of C31) equals 
( ( Fint C32 ) . C33 );
coherence
proof
reconsider D14 = C33 as (Element of ( NAT )) by ORDINAL1:def 12;
L148: ( ( Fint C32 ) . D14 ) c= (the carrier of C31);
thus L149: thesis by L148;
end;
end;
theorem
L151: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B35 being (Element of ( NAT )) holds ( Fcl (R2 , ( B35 + 1 )) ) = ( ( Fcl (R2 , B35) ) ^b )))) by L103;
theorem
L152: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fcl (R2 , ( 0 )) ) = R2)) by L103;
theorem
L153: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fcl (R2 , 1) ) = ( R2 ^b )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L154: ( ( Fcl R2 ) . ( 0 ) ) = R2 by L103;
L155: ( ( Fcl R2 ) . ( ( 0 ) + 1 ) ) = ( R2 ^b ) by L154 , L103;
thus L156: thesis by L155;
end;
theorem
L157: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fcl (R2 , 2) ) = ( ( R2 ^b ) ^b )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L158: (for B36 being (Subset of R1) holds (B36 = ( ( Fcl R2 ) . 1 ) implies ( ( Fcl R2 ) . ( 1 + 1 ) ) = ( B36 ^b ))) by L103;
L159: ( Fcl (R2 , 2) ) = ( ( Fcl (R2 , 1) ) ^b ) by L158
.= ( ( R2 ^b ) ^b ) by L153;
thus L160: thesis by L159;
end;
theorem
L161: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B37 being (Element of ( NAT )) holds ( Fcl (( R2 \/ R3 ) , B37) ) = ( ( Fcl (R2 , B37) ) \/ ( Fcl (R3 , B37) ) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C34 being (Element of ( NAT ));
L162: (for B38 being (Element of ( NAT )) holds ( ( Fcl ( R2 \/ R3 ) ) . B38 ) = ( ( ( Fcl R2 ) . B38 ) \/ ( ( Fcl R3 ) . B38 ) ))
proof
defpred S6[ (Element of ( NAT )) ] means ( ( Fcl ( R2 \/ R3 ) ) . $1 ) = ( ( ( Fcl R2 ) . $1 ) \/ ( ( Fcl R3 ) . $1 ) );
L163: (for B39 being (Element of ( NAT )) holds (S6[ B39 ] implies S6[ ( B39 + 1 ) ]))
proof
let C35 being (Element of ( NAT ));
assume L164: S6[ C35 ];
L165: ( ( Fcl ( R2 \/ R3 ) ) . ( C35 + 1 ) ) = ( ( Fcl (( R2 \/ R3 ) , C35) ) ^b ) by L103
.= ( ( ( Fcl (R2 , C35) ) ^b ) \/ ( ( Fcl (R3 , C35) ) ^b ) ) by L164 , L52
.= ( ( Fcl (R2 , ( C35 + 1 )) ) \/ ( ( Fcl (R3 , C35) ) ^b ) ) by L103
.= ( ( ( Fcl R2 ) . ( C35 + 1 ) ) \/ ( ( Fcl R3 ) . ( C35 + 1 ) ) ) by L103;
thus L166: thesis by L165;
end;
L167: ( ( Fcl ( R2 \/ R3 ) ) . ( 0 ) ) = ( R2 \/ R3 ) by L103
.= ( ( ( Fcl R2 ) . ( 0 ) ) \/ R3 ) by L103
.= ( ( ( Fcl R2 ) . ( 0 ) ) \/ ( ( Fcl R3 ) . ( 0 ) ) ) by L103;
L168: S6[ ( 0 ) ] by L167;
L169: (for B40 being (Element of ( NAT )) holds S6[ B40 ]) from NAT_1:sch 1(L168 , L163);
thus L170: thesis by L169;
end;
thus L171: thesis by L162;
end;
theorem
L172: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B41 being (Element of ( NAT )) holds ( Fint (R2 , ( B41 + 1 )) ) = ( ( Fint (R2 , B41) ) ^i )))) by L127;
theorem
L173: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fint (R2 , ( 0 )) ) = R2)) by L127;
theorem
L174: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fint (R2 , 1) ) = ( R2 ^i )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L175: (( ( Fint R2 ) . ( 0 ) ) = R2 & (for B42 being (Subset of R1) holds (B42 = ( ( Fint R2 ) . ( 0 ) ) implies ( ( Fint R2 ) . ( ( 0 ) + 1 ) ) = ( B42 ^i )))) by L127;
thus L176: thesis by L175;
end;
theorem
L177: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fint (R2 , 2) ) = ( ( R2 ^i ) ^i )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
thus L178: ( Fint (R2 , 2) ) = ( Fint (R2 , ( 1 + 1 )) )
.= ( ( Fint (R2 , 1) ) ^i ) by L127
.= ( ( R2 ^i ) ^i ) by L174;
end;
theorem
L179: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B43 being (Element of ( NAT )) holds ( Fint (( R2 /\ R3 ) , B43) ) = ( ( Fint (R2 , B43) ) /\ ( Fint (R3 , B43) ) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
defpred S7[ (Element of ( NAT )) ] means ( ( Fint ( R2 /\ R3 ) ) . $1 ) = ( ( ( Fint R2 ) . $1 ) /\ ( ( Fint R3 ) . $1 ) );
let C36 being (Element of ( NAT ));
L180: (for B44 being (Element of ( NAT )) holds (S7[ B44 ] implies S7[ ( B44 + 1 ) ]))
proof
let C37 being (Element of ( NAT ));
assume L181: S7[ C37 ];
L182: ( ( Fint ( R2 /\ R3 ) ) . ( C37 + 1 ) ) = ( ( Fint (( R2 /\ R3 ) , C37) ) ^i ) by L127
.= ( ( ( Fint (R2 , C37) ) ^i ) /\ ( ( Fint (R3 , C37) ) ^i ) ) by L181 , L71
.= ( ( Fint (R2 , ( C37 + 1 )) ) /\ ( ( Fint (R3 , C37) ) ^i ) ) by L127
.= ( ( ( Fint R2 ) . ( C37 + 1 ) ) /\ ( ( Fint R3 ) . ( C37 + 1 ) ) ) by L127;
thus L183: thesis by L182;
end;
L184: ( ( Fint ( R2 /\ R3 ) ) . ( 0 ) ) = ( R2 /\ R3 ) by L127
.= ( ( ( Fint R2 ) . ( 0 ) ) /\ R3 ) by L127
.= ( ( ( Fint R2 ) . ( 0 ) ) /\ ( ( Fint R3 ) . ( 0 ) ) ) by L127;
L185: S7[ ( 0 ) ] by L184;
L186: (for B45 being (Element of ( NAT )) holds S7[ B45 ]) from NAT_1:sch 1(L185 , L180);
thus L187: thesis by L186;
end;
theorem
L188: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B46 being (Element of ( NAT )) holds R2 c= ( Fcl (R2 , B46) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
defpred S8[ (Element of ( NAT )) ] means R2 c= ( ( Fcl R2 ) . $1 );
assume L189: R1 is  filled;
L190: (for B47 being (Element of ( NAT )) holds (S8[ B47 ] implies S8[ ( B47 + 1 ) ]))
proof
let C38 being (Element of ( NAT ));
assume L191: S8[ C38 ];
L192: ( R2 ^b ) c= ( ( Fcl (R2 , C38) ) ^b ) by L191 , FIN_TOPO:14;
L193: ( R2 ^b ) c= ( Fcl (R2 , ( C38 + 1 )) ) by L192 , L103;
L194: R2 c= ( R2 ^b ) by L189 , FIN_TOPO:13;
thus L195: thesis by L194 , L193 , XBOOLE_1:1;
end;
let C39 being (Element of ( NAT ));
L196: S8[ ( 0 ) ] by L103;
L197: (for B48 being (Element of ( NAT )) holds S8[ B48 ]) from NAT_1:sch 1(L196 , L190);
thus L198: thesis by L197;
end;
theorem
L199: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B49 being (Element of ( NAT )) holds ( Fint (R2 , B49) ) c= R2))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
defpred S9[ (Element of ( NAT )) ] means ( ( Fint R2 ) . $1 ) c= R2;
assume L200: R1 is  filled;
L201: (for B50 being (Element of ( NAT )) holds (S9[ B50 ] implies S9[ ( B50 + 1 ) ]))
proof
let C40 being (Element of ( NAT ));
assume L202: S9[ C40 ];
L203: ( ( Fint (R2 , C40) ) ^i ) c= ( R2 ^i ) by L202 , FINTOPO2:1;
L204: ( Fint (R2 , ( C40 + 1 )) ) c= ( R2 ^i ) by L203 , L127;
L205: ( R2 ^i ) c= R2 by L200 , FIN_TOPO:22;
thus L206: thesis by L205 , L204 , XBOOLE_1:1;
end;
let C41 being (Element of ( NAT ));
L207: S9[ ( 0 ) ] by L127;
L208: (for B51 being (Element of ( NAT )) holds S9[ B51 ]) from NAT_1:sch 1(L207 , L201);
thus L209: thesis by L208;
end;
theorem
L210: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B52 being (Element of ( NAT )) holds ( Fcl (R2 , B52) ) c= ( Fcl (R2 , ( B52 + 1 )) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
assume L211: R1 is  filled;
let C42 being (Element of ( NAT ));
L212: ( ( ( Fcl R2 ) . C42 ) ^b ) = ( Fcl (R2 , ( C42 + 1 )) ) by L103;
thus L213: thesis by L212 , L211 , FIN_TOPO:13;
end;
theorem
L214: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B53 being (Element of ( NAT )) holds ( Fint (R2 , ( B53 + 1 )) ) c= ( Fint (R2 , B53) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
assume L215: R1 is  filled;
let C43 being (Element of ( NAT ));
L216: ( ( ( Fint R2 ) . C43 ) ^i ) = ( Fint (R2 , ( C43 + 1 )) ) by L127;
thus L217: thesis by L216 , L215 , FIN_TOPO:22;
end;
theorem
L218: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B54 being (Element of ( NAT )) holds ( ( Fint (( R2 ` ) , B54) ) ` ) = ( Fcl (R2 , B54) ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
defpred S10[ (Element of ( NAT )) ] means ( ( Fint (( R2 ` ) , $1) ) ` ) = ( Fcl (R2 , $1) );
L219: (for B55 being (Element of ( NAT )) holds (S10[ B55 ] implies S10[ ( B55 + 1 ) ]))
proof
let C44 being (Element of ( NAT ));
assume L220: S10[ C44 ];
L221: ( Fcl (R2 , ( C44 + 1 )) ) = ( ( Fcl (R2 , C44) ) ^b ) by L103
.= ( ( ( ( ( Fint (( R2 ` ) , C44) ) ` ) ` ) ^i ) ` ) by L220 , FIN_TOPO:16
.= ( ( Fint (( R2 ` ) , ( C44 + 1 )) ) ` ) by L127;
thus L222: thesis by L221;
end;
L223: ( ( Fint (( R2 ` ) , ( 0 )) ) ` ) = ( ( R2 ` ) ` ) by L127
.= ( Fcl (R2 , ( 0 )) ) by L103;
L224: S10[ ( 0 ) ] by L223;
L225: (for B56 being (Element of ( NAT )) holds S10[ B56 ]) from NAT_1:sch 1(L224 , L219);
thus L226: thesis by L225;
end;
theorem
L227: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B57 being (Element of ( NAT )) holds ( ( Fcl (( R2 ` ) , B57) ) ` ) = ( Fint (R2 , B57) ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let C45 being (Element of ( NAT ));
L228: ( Fint (R2 , C45) ) = ( ( ( Fint (( ( R2 ` ) ` ) , C45) ) ` ) ` )
.= ( ( Fcl (( R2 ` ) , C45) ) ` ) by L218;
thus L229: thesis by L228;
end;
theorem
L230: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B58 being (Element of ( NAT )) holds ( ( Fcl (R2 , B58) ) \/ ( Fcl (R3 , B58) ) ) = ( ( Fint (( ( R2 \/ R3 ) ` ) , B58) ) ` )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C46 being (Element of ( NAT ));
L231: ( ( Fcl (R2 , C46) ) \/ ( Fcl (R3 , C46) ) ) = ( Fcl (( R2 \/ R3 ) , C46) ) by L161
.= ( ( Fint (( ( R2 \/ R3 ) ` ) , C46) ) ` ) by L218;
thus L232: thesis by L231;
end;
theorem
L233: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B59 being (Element of ( NAT )) holds ( ( Fint (R2 , B59) ) /\ ( Fint (R3 , B59) ) ) = ( ( Fcl (( ( R2 /\ R3 ) ` ) , B59) ) ` )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C47 being (Element of ( NAT ));
L234: ( ( Fint (R2 , C47) ) /\ ( Fint (R3 , C47) ) ) = ( Fint (( R2 /\ R3 ) , C47) ) by L179
.= ( ( Fcl (( ( R2 /\ R3 ) ` ) , C47) ) ` ) by L227;
thus L235: thesis by L234;
end;
definition
let C48 being non  empty RelStr;
let C49 being (Subset of C48);
func Finf C49 -> (Function of ( NAT ) , ( bool (the carrier of C48) )) means 
:L236: ((for B60 being (Element of ( NAT )) holds (for B61 being (Subset of C48) holds (B61 = ( it . B60 ) implies ( it . ( B60 + 1 ) ) = ( B61 ^f )))) & ( it . ( 0 ) ) = C49);
existence
proof
defpred S11[ set , set , set ] means (for B62 being (Subset of C48) holds (B62 = $2 implies $3 = ( B62 ^f )));
L237: (for B63 being (Element of ( NAT )) holds (for B64 being (Subset of C48) holds (ex B65 being (Subset of C48) st S11[ B63 , B64 , B65 ])))
proof
let C50 being (Element of ( NAT ));
let C51 being (Subset of C48);
reconsider D15 = C51 as (Subset of C48);
L238: (for B66 being (Subset of C48) holds (B66 = C51 implies ( D15 ^f ) = ( B66 ^f )));
thus L239: thesis by L238;
end;
L240: (ex B67 being (Function of ( NAT ) , ( bool (the carrier of C48) )) st (( B67 . ( 0 ) ) = C49 & (for B68 being (Element of ( NAT )) holds S11[ B68 , ( B67 . B68 ) , ( B67 . ( B68 + 1 ) ) ]))) from RECDEF_1:sch 2(L237);
thus L241: thesis by L240;
end;
uniqueness
proof
let C52 , C53 being (Function of ( NAT ) , ( bool (the carrier of C48) ));
assume that
L242: (for B69 being (Element of ( NAT )) holds (for B70 being (Subset of C48) holds (B70 = ( C52 . B69 ) implies ( C52 . ( B69 + 1 ) ) = ( B70 ^f ))))
and
L243: ( C52 . ( 0 ) ) = C49
and
L244: (for B71 being (Element of ( NAT )) holds (for B72 being (Subset of C48) holds (B72 = ( C53 . B71 ) implies ( C53 . ( B71 + 1 ) ) = ( B72 ^f ))))
and
L245: ( C53 . ( 0 ) ) = C49;
defpred S12[ (Element of ( NAT )) ] means ( C52 . $1 ) = ( C53 . $1 );
L246: ( dom C52 ) = ( NAT ) by FUNCT_2:def 1;
L247: ( dom C52 ) = ( dom C53 ) by L246 , FUNCT_2:def 1;
L248: (for B73 being (Element of ( NAT )) holds S12[ B73 ])
proof
let C54 being (Element of ( NAT ));
L249: (for B74 being (Element of ( NAT )) holds (S12[ B74 ] implies S12[ ( B74 + 1 ) ]))
proof
let C55 being (Element of ( NAT ));
assume L250: S12[ C55 ];
reconsider D16 = ( C52 . C55 ) as (Subset of C48);
L251: ( D16 ^f ) = ( C52 . ( C55 + 1 ) ) by L242;
thus L252: thesis by L251 , L244 , L250;
end;
L253: S12[ ( 0 ) ] by L243 , L245;
L254: (for B75 being (Element of ( NAT )) holds S12[ B75 ]) from NAT_1:sch 1(L253 , L249);
thus L255: thesis by L254;
end;
L256: (for B76 being set holds (B76 in ( dom C52 ) implies ( C52 . B76 ) = ( C53 . B76 ))) by L248 , L246;
thus L257: C52 = C53 by L256 , L247 , FUNCT_1:2;
end;
end;
definition
let C56 being non  empty RelStr;
let C57 being (Subset of C56);
let C58 being Nat;
func Finf (C57 , C58) -> (Subset of C56) equals 
( ( Finf C57 ) . C58 );
coherence
proof
reconsider D17 = C58 as (Element of ( NAT )) by ORDINAL1:def 12;
L259: ( ( Finf C57 ) . D17 ) c= (the carrier of C56);
thus L260: thesis by L259;
end;
end;
definition
let C59 being non  empty RelStr;
let C60 being (Subset of C59);
func Fdfl C60 -> (Function of ( NAT ) , ( bool (the carrier of C59) )) means 
:L262: ((for B77 being (Element of ( NAT )) holds (for B78 being (Subset of C59) holds (B78 = ( it . B77 ) implies ( it . ( B77 + 1 ) ) = ( B78 ^d )))) & ( it . ( 0 ) ) = C60);
existence
proof
defpred S13[ set , set , set ] means (for B79 being (Subset of C59) holds (B79 = $2 implies $3 = ( B79 ^d )));
L263: (for B80 being (Element of ( NAT )) holds (for B81 being (Subset of C59) holds (ex B82 being (Subset of C59) st S13[ B80 , B81 , B82 ])))
proof
let C61 being (Element of ( NAT ));
let C62 being (Subset of C59);
L264: (for B83 being (Subset of C59) holds (B83 = C62 implies ( C62 ^d ) = ( B83 ^d )));
thus L265: thesis by L264;
end;
L266: (ex B84 being (Function of ( NAT ) , ( bool (the carrier of C59) )) st (( B84 . ( 0 ) ) = C60 & (for B85 being (Element of ( NAT )) holds S13[ B85 , ( B84 . B85 ) , ( B84 . ( B85 + 1 ) ) ]))) from RECDEF_1:sch 2(L263);
thus L267: thesis by L266;
end;
uniqueness
proof
let C63 , C64 being (Function of ( NAT ) , ( bool (the carrier of C59) ));
assume that
L268: (for B86 being (Element of ( NAT )) holds (for B87 being (Subset of C59) holds (B87 = ( C63 . B86 ) implies ( C63 . ( B86 + 1 ) ) = ( B87 ^d ))))
and
L269: ( C63 . ( 0 ) ) = C60
and
L270: (for B88 being (Element of ( NAT )) holds (for B89 being (Subset of C59) holds (B89 = ( C64 . B88 ) implies ( C64 . ( B88 + 1 ) ) = ( B89 ^d ))))
and
L271: ( C64 . ( 0 ) ) = C60;
defpred S14[ (Element of ( NAT )) ] means ( C63 . $1 ) = ( C64 . $1 );
L272: (for B90 being (Element of ( NAT )) holds (S14[ B90 ] implies S14[ ( B90 + 1 ) ]))
proof
let C65 being (Element of ( NAT ));
assume L273: S14[ C65 ];
reconsider D18 = ( C63 . C65 ) as (Subset of C59);
L274: ( D18 ^d ) = ( C63 . ( C65 + 1 ) ) by L268;
thus L275: thesis by L274 , L270 , L273;
end;
L276: ( dom C63 ) = ( NAT ) by FUNCT_2:def 1;
L277: ( dom C63 ) = ( dom C64 ) by L276 , FUNCT_2:def 1;
L278: S14[ ( 0 ) ] by L269 , L271;
L279: (for B91 being (Element of ( NAT )) holds S14[ B91 ]) from NAT_1:sch 1(L278 , L272);
L280: (for B92 being set holds (B92 in ( dom C63 ) implies ( C63 . B92 ) = ( C64 . B92 ))) by L279 , L276;
thus L281: C63 = C64 by L280 , L277 , FUNCT_1:2;
end;
end;
definition
let C66 being non  empty RelStr;
let C67 being (Subset of C66);
let C68 being Nat;
func Fdfl (C67 , C68) -> (Subset of C66) equals 
( ( Fdfl C67 ) . C68 );
coherence
proof
reconsider D19 = C68 as (Element of ( NAT )) by ORDINAL1:def 12;
L283: ( ( Fdfl C67 ) . D19 ) c= (the carrier of C66);
thus L284: thesis by L283;
end;
end;
theorem
L286: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B93 being (Element of ( NAT )) holds ( Finf (R2 , ( B93 + 1 )) ) = ( ( Finf (R2 , B93) ) ^f )))) by L236;
theorem
L287: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Finf (R2 , ( 0 )) ) = R2)) by L236;
theorem
L288: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Finf (R2 , 1) ) = ( R2 ^f )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L289: (( ( Finf R2 ) . ( 0 ) ) = R2 & (for B94 being (Subset of R1) holds (B94 = ( ( Finf R2 ) . ( 0 ) ) implies ( ( Finf R2 ) . ( ( 0 ) + 1 ) ) = ( B94 ^f )))) by L236;
thus L290: thesis by L289;
end;
theorem
L291: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Finf (R2 , 2) ) = ( ( R2 ^f ) ^f )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L292: ( Finf (R2 , 2) ) = ( Finf (R2 , ( 1 + 1 )) )
.= ( ( Finf (R2 , 1) ) ^f ) by L236
.= ( ( R2 ^f ) ^f ) by L288;
thus L293: thesis by L292;
end;
theorem
L294: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B95 being (Element of ( NAT )) holds ( Finf (( R2 \/ R3 ) , B95) ) = ( ( Finf (R2 , B95) ) \/ ( Finf (R3 , B95) ) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
defpred S15[ (Element of ( NAT )) ] means ( ( Finf ( R2 \/ R3 ) ) . $1 ) = ( ( ( Finf R2 ) . $1 ) \/ ( ( Finf R3 ) . $1 ) );
let C69 being (Element of ( NAT ));
L295: (for B96 being (Element of ( NAT )) holds (S15[ B96 ] implies S15[ ( B96 + 1 ) ]))
proof
let C70 being (Element of ( NAT ));
assume L296: S15[ C70 ];
L297: ( ( Finf ( R2 \/ R3 ) ) . ( C70 + 1 ) ) = ( ( Finf (( R2 \/ R3 ) , C70) ) ^f ) by L236
.= ( ( ( Finf (R2 , C70) ) ^f ) \/ ( ( Finf (R3 , C70) ) ^f ) ) by L296 , L87
.= ( ( Finf (R2 , ( C70 + 1 )) ) \/ ( ( Finf (R3 , C70) ) ^f ) ) by L236
.= ( ( ( Finf R2 ) . ( C70 + 1 ) ) \/ ( ( Finf R3 ) . ( C70 + 1 ) ) ) by L236;
thus L298: thesis by L297;
end;
L299: ( ( Finf ( R2 \/ R3 ) ) . ( 0 ) ) = ( R2 \/ R3 ) by L236
.= ( ( ( Finf R2 ) . ( 0 ) ) \/ R3 ) by L236
.= ( ( ( Finf R2 ) . ( 0 ) ) \/ ( ( Finf R3 ) . ( 0 ) ) ) by L236;
L300: S15[ ( 0 ) ] by L299;
L301: (for B97 being (Element of ( NAT )) holds S15[ B97 ]) from NAT_1:sch 1(L300 , L295);
thus L302: thesis by L301;
end;
theorem
L303: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B98 being (Element of ( NAT )) holds R2 c= ( Finf (R2 , B98) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
defpred S16[ (Element of ( NAT )) ] means R2 c= ( ( Finf R2 ) . $1 );
assume L304: R1 is  filled;
L305: (for B99 being (Element of ( NAT )) holds (S16[ B99 ] implies S16[ ( B99 + 1 ) ]))
proof
let C71 being (Element of ( NAT ));
assume L306: S16[ C71 ];
L307: ( R2 ^f ) c= ( ( Finf (R2 , C71) ) ^f ) by L306 , L33;
L308: ( R2 ^f ) c= ( Finf (R2 , ( C71 + 1 )) ) by L307 , L236;
L309: R2 c= ( R2 ^f ) by L304 , L4;
thus L310: thesis by L309 , L308 , XBOOLE_1:1;
end;
let C72 being (Element of ( NAT ));
L311: S16[ ( 0 ) ] by L236;
L312: (for B100 being (Element of ( NAT )) holds S16[ B100 ]) from NAT_1:sch 1(L311 , L305);
thus L313: thesis by L312;
end;
theorem
L314: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B101 being (Element of ( NAT )) holds ( Finf (R2 , B101) ) c= ( Finf (R2 , ( B101 + 1 )) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
assume L315: R1 is  filled;
let C73 being (Element of ( NAT ));
L316: ( ( ( Finf R2 ) . C73 ) ^f ) = ( Finf (R2 , ( C73 + 1 )) ) by L236;
thus L317: thesis by L316 , L315 , L4;
end;
theorem
L318: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B102 being (Element of ( NAT )) holds ( Fdfl (R2 , ( B102 + 1 )) ) = ( ( Fdfl (R2 , B102) ) ^d )))) by L262;
theorem
L319: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fdfl (R2 , ( 0 )) ) = R2)) by L262;
theorem
L320: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fdfl (R2 , 1) ) = ( R2 ^d )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L321: (( ( Fdfl R2 ) . ( 0 ) ) = R2 & (for B103 being (Subset of R1) holds (B103 = ( ( Fdfl R2 ) . ( 0 ) ) implies ( ( Fdfl R2 ) . ( ( 0 ) + 1 ) ) = ( B103 ^d )))) by L262;
thus L322: thesis by L321;
end;
theorem
L323: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds ( Fdfl (R2 , 2) ) = ( ( R2 ^d ) ^d )))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
L324: ( Fdfl (R2 , 2) ) = ( Fdfl (R2 , ( 1 + 1 )) )
.= ( ( Fdfl (R2 , 1) ) ^d ) by L262;
thus L325: thesis by L324 , L320;
end;
theorem
L326: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B104 being (Element of ( NAT )) holds ( Fdfl (( R2 /\ R3 ) , B104) ) = ( ( Fdfl (R2 , B104) ) /\ ( Fdfl (R3 , B104) ) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
defpred S17[ (Element of ( NAT )) ] means ( ( Fdfl ( R2 /\ R3 ) ) . $1 ) = ( ( ( Fdfl R2 ) . $1 ) /\ ( ( Fdfl R3 ) . $1 ) );
let C74 being (Element of ( NAT ));
L327: (for B105 being (Element of ( NAT )) holds (S17[ B105 ] implies S17[ ( B105 + 1 ) ]))
proof
let C75 being (Element of ( NAT ));
assume L328: S17[ C75 ];
L329: ( ( Fdfl ( R2 /\ R3 ) ) . ( C75 + 1 ) ) = ( ( Fdfl (( R2 /\ R3 ) , C75) ) ^d ) by L262
.= ( ( ( Fdfl (R2 , C75) ) ^d ) /\ ( ( Fdfl (R3 , C75) ) ^d ) ) by L328 , L100
.= ( ( Fdfl (R2 , ( C75 + 1 )) ) /\ ( ( Fdfl (R3 , C75) ) ^d ) ) by L262
.= ( ( ( Fdfl R2 ) . ( C75 + 1 ) ) /\ ( ( Fdfl R3 ) . ( C75 + 1 ) ) ) by L262;
thus L330: thesis by L329;
end;
L331: ( ( Fdfl ( R2 /\ R3 ) ) . ( 0 ) ) = ( R2 /\ R3 ) by L262
.= ( ( ( Fdfl R2 ) . ( 0 ) ) /\ R3 ) by L262
.= ( ( ( Fdfl R2 ) . ( 0 ) ) /\ ( ( Fdfl R3 ) . ( 0 ) ) ) by L262;
L332: S17[ ( 0 ) ] by L331;
L333: (for B106 being (Element of ( NAT )) holds S17[ B106 ]) from NAT_1:sch 1(L332 , L327);
thus L334: thesis by L333;
end;
theorem
L335: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B107 being (Element of ( NAT )) holds ( Fdfl (R2 , B107) ) c= R2))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
defpred S18[ (Element of ( NAT )) ] means ( ( Fdfl R2 ) . $1 ) c= R2;
assume L336: R1 is  filled;
L337: (for B108 being (Element of ( NAT )) holds (S18[ B108 ] implies S18[ ( B108 + 1 ) ]))
proof
let C76 being (Element of ( NAT ));
assume L338: S18[ C76 ];
L339: ( ( Fdfl (R2 , C76) ) ^d ) c= ( R2 ^d ) by L338 , L38;
L340: ( Fdfl (R2 , ( C76 + 1 )) ) c= ( R2 ^d ) by L339 , L262;
L341: ( R2 ^d ) c= R2 by L336 , L16;
thus L342: thesis by L341 , L340 , XBOOLE_1:1;
end;
let C77 being (Element of ( NAT ));
L343: S18[ ( 0 ) ] by L262;
L344: (for B109 being (Element of ( NAT )) holds S18[ B109 ]) from NAT_1:sch 1(L343 , L337);
thus L345: thesis by L344;
end;
theorem
L346: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (R1 is  filled implies (for B110 being (Element of ( NAT )) holds ( Fdfl (R2 , ( B110 + 1 )) ) c= ( Fdfl (R2 , B110) )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
assume L347: R1 is  filled;
let C78 being (Element of ( NAT ));
L348: ( ( ( Fdfl R2 ) . C78 ) ^d ) = ( Fdfl (R2 , ( C78 + 1 )) ) by L262;
thus L349: thesis by L348 , L347 , L16;
end;
theorem
L350: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for B111 being (Element of ( NAT )) holds ( Fdfl (R2 , B111) ) = ( ( Finf (( R2 ` ) , B111) ) ` ))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
defpred S19[ (Element of ( NAT )) ] means ( ( Fdfl R2 ) . $1 ) = ( ( ( Finf ( R2 ` ) ) . $1 ) ` );
let C79 being (Element of ( NAT ));
L351: (for B112 being (Element of ( NAT )) holds (S19[ B112 ] implies S19[ ( B112 + 1 ) ]))
proof
let C80 being (Element of ( NAT ));
assume L352: S19[ C80 ];
L353: ( ( Fdfl R2 ) . ( C80 + 1 ) ) = ( ( Fdfl (R2 , C80) ) ^d ) by L262;
L354: ( ( Fdfl R2 ) . ( C80 + 1 ) ) = ( ( ( ( ( Fdfl R2 ) . C80 ) ` ) ^f ) ` ) by L353 , L19
.= ( ( ( Finf ( R2 ` ) ) . ( C80 + 1 ) ) ` ) by L352 , L236;
thus L355: thesis by L354;
end;
L356: ( ( ( Finf ( R2 ` ) ) . ( 0 ) ) ` ) = ( ( R2 ` ) ` ) by L236
.= R2;
L357: S19[ ( 0 ) ] by L356 , L262;
L358: (for B113 being (Element of ( NAT )) holds S19[ B113 ]) from NAT_1:sch 1(L357 , L351);
thus L359: thesis by L358;
end;
theorem
L360: (for R1 being non  empty RelStr holds (for R2 being (Subset of R1) holds (for R3 being (Subset of R1) holds (for B114 being (Element of ( NAT )) holds ( ( Fdfl (R2 , B114) ) /\ ( Fdfl (R3 , B114) ) ) = ( ( Finf (( ( R2 /\ R3 ) ` ) , B114) ) ` )))))
proof
let R1 being non  empty RelStr;
let R2 being (Subset of R1);
let R3 being (Subset of R1);
let C81 being (Element of ( NAT ));
L361: ( ( Fdfl (R2 , C81) ) /\ ( Fdfl (R3 , C81) ) ) = ( Fdfl (( R2 /\ R3 ) , C81) ) by L326
.= ( ( Finf (( ( R2 /\ R3 ) ` ) , C81) ) ` ) by L350;
thus L362: thesis by L361;
end;
definition
let C82 being non  empty RelStr;
let C83 being Nat;
let C84 being (Element of C82);
func U_FT (C84 , C83) -> (Subset of C82) equals 
( Finf (( U_FT C84 ) , C83) );
coherence;
end;
theorem
L364: (for R1 being non  empty RelStr holds (for R4 being (Element of R1) holds ( U_FT (R4 , ( 0 )) ) = ( U_FT R4 ))) by L236;
theorem
L365: (for R1 being non  empty RelStr holds (for R4 being (Element of R1) holds (for B115 being (Element of ( NAT )) holds ( U_FT (R4 , ( B115 + 1 )) ) = ( ( U_FT (R4 , B115) ) ^f )))) by L236;
definition
let C85 , C86 being non  empty RelStr;
pred C85 , C86 are_mutually_symmetric 
means
((the carrier of C85) = (the carrier of C86) & (for B116 being (Element of C85) holds (for B117 being (Element of C86) holds (B117 in ( U_FT B116 ) iff B116 in ( U_FT B117 )))))
;symmetry
;
end;
