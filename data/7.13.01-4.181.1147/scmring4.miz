:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ORDINAL1, SUBSET_1, NUMBERS, XBOOLE_0, SETFAM_1, FUNCSDOM, AMI_3,
      AMI_1, FSM_1, STRUCT_0, AMI_2, FUNCT_1, TARSKI, RELAT_1, AMISTD_2,
      ARYTM_3, FUNCT_4, CIRCUIT2, CARD_1, GRAPHSP, ARYTM_1, SUPINF_2, FUNCOP_1,
      ZFMISC_1, PARTFUN1, RELOC, NAT_1, AMISTD_5, COMPOS_1, FINSET_1,
      GOBRD13, MEMSTR_0, EXTPRO_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1, RELAT_1,
      FINSET_1, NUMBERS, FUNCT_1, PARTFUN1, STRUCT_0, ALGSTR_0, FUNCSDOM,
      FUNCOP_1, XCMPLX_0, NAT_1, FUNCT_4, FUNCT_7, NAT_D, VALUED_1, PBOOLE,
      MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMI_2, AMI_3, SCMRING1, SCMRING2,
      SCMRING3, AMISTD_2, AMISTD_5;
 constructors XXREAL_0, REALSET2, AMI_3, AMISTD_2, SCMRING3, PRE_POLY, NAT_D,
      AMISTD_1, AMISTD_5, PBOOLE, INT_3, FUNCT_7, RELSET_1, MEMSTR_0, SCMRING1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, XREAL_0, NAT_1,
      CARD_3, STRUCT_0, AMI_3, SCMRING2, AMISTD_2, SCMRING3, FINSET_1,
      ORDINAL1, RELSET_1, GRFUNC_1, FUNCT_2, VALUED_1, FUNCT_4, COMPOS_1,
      EXTPRO_1, AMISTD_5, AMI_5, PBOOLE, PRE_POLY, FUNCT_7, ZFMISC_1, SUBSET_1,
      MEMSTR_0, NUMBERS, INT_1, CARD_1, AMI_2, INT_3, COMPOS_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, EXTPRO_1, FUNCOP_1, AMI_3, AMI_2, AMISTD_1, AMISTD_2,
      NAT_1, COMPOS_1, AMISTD_5, STRUCT_0, MEMSTR_0, COMPOS_0;
 theorems TARSKI, NAT_1, SCMRING2, AMI_3, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      SCMRING1, AMI_2, STRUCT_0, XBOOLE_0, XBOOLE_1, RELAT_1, GRFUNC_1,
      SCMRING3, AMISTD_2, PBOOLE, PARTFUN1, ORDINAL1, COMPOS_1, EXTPRO_1,
      AMISTD_5, MEMSTR_0, COMPOS_0, XTUPLE_0;
 schemes NAT_1;

begin
theorem
L1: (for R4 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds ( dl. (R7 , R4) ) = [ 1 , R4 ]))
proof
let R4 being (Element of ( NAT ));
let R7 being non  trivial Ring;
thus L2: ( dl. (R7 , R4) ) = ( dl. R4 ) by SCMRING3:def 1
.= [ 1 , R4 ];
end;
theorem
L3: (for R7 being non  trivial Ring holds (for B1 being (Data-Location of R7) holds (ex B2 being (Element of ( NAT )) st B1 = ( dl. (R7 , B2) ))))
proof
let R7 being non  trivial Ring;
let C1 being (Data-Location of R7);
L4: C1 in ( Data-Locations ( SCM ) ) by SCMRING2:1;
consider C2 being (Element of ( NAT )) such that L5: C1 = [ 1 , C2 ] by L4 , AMI_2:23 , AMI_3:27;
take C2;
thus L6: thesis by L5 , L1;
end;
theorem
L7: (for R7 being non  trivial Ring holds (for B3 , B4 being (Element of ( NAT )) holds (B3 <> B4 implies ( dl. (R7 , B3) ) <> ( dl. (R7 , B4) ))))
proof
let R7 being non  trivial Ring;
let C3 , C4 being (Element of ( NAT ));
assume L8: C3 <> C4;
L9: (( dl. (R7 , C4) ) = [ 1 , C4 ] & ( dl. (R7 , C3) ) = [ 1 , C3 ]) by L1;
thus L10: thesis by L9 , L8 , XTUPLE_0:1;
end;
theorem
L11: (for R7 being non  trivial Ring holds (for R13 being (State of ( SCM R7 )) holds ( Data-Locations ( SCM ) ) c= ( dom R13 )))
proof
let R7 being non  trivial Ring;
let R13 being (State of ( SCM R7 ));
L12: ( Data-Locations ( SCM R7 ) ) = ( Data-Locations ( SCM ) ) by SCMRING2:22;
thus L13: thesis by L12 , MEMSTR_0:8;
end;
theorem
L14: (for R7 being non  trivial Ring holds (for R8 being (Data-Location of R7) holds (for R10 being (Element of ( NAT )) holds (for R13 being (State of ( SCM R7 )) holds ( R13 . R8 ) = ( ( R13 +* ( Start-At (R10 , ( SCM R7 )) ) ) . R8 )))))
proof
let R7 being non  trivial Ring;
let R8 being (Data-Location of R7);
let R10 being (Element of ( NAT ));
let R13 being (State of ( SCM R7 ));
L15: R8 in (the carrier of ( SCM R7 ));
L16: R8 in ( dom R13 ) by L15 , PARTFUN1:def 2;
L17: (( dom ( Start-At (R10 , ( SCM R7 )) ) ) = { ( IC ( SCM R7 ) ) } & R8 in ( ( dom R13 ) \/ ( dom ( Start-At (R10 , ( SCM R7 )) ) ) )) by L16 , FUNCOP_1:13 , XBOOLE_0:def 3;
L18: R8 <> ( IC ( SCM R7 ) ) by SCMRING3:2;
L19: (not R8 in { ( IC ( SCM R7 ) ) }) by L18 , TARSKI:def 1;
thus L20: thesis by L19 , L17 , FUNCT_4:def 1;
end;
theorem
L21: (for R7 being non  trivial Ring holds (for B5 , B6 being (State of ( SCM R7 )) holds ((( IC B5 ) = ( IC B6 ) & (for B7 being (Data-Location of R7) holds ( B5 . B7 ) = ( B6 . B7 ))) implies B5 = B6)))
proof
let R7 being non  trivial Ring;
let C5 , C6 being (State of ( SCM R7 ));
assume that
L22: ( IC C5 ) = ( IC C6 );
L23: (( IC ( SCM R7 ) ) in ( dom C5 ) & ( IC ( SCM R7 ) ) in ( dom C6 )) by MEMSTR_0:2;
L24: (C5 = ( ( DataPart C5 ) +* ( Start-At (( IC C5 ) , ( SCM R7 )) ) ) & C6 = ( ( DataPart C6 ) +* ( Start-At (( IC C6 ) , ( SCM R7 )) ) )) by L23 , MEMSTR_0:26;
assume L25: (for B8 being (Data-Location of R7) holds ( C5 . B8 ) = ( C6 . B8 ));
L26: ( DataPart C5 ) = ( DataPart C6 )
proof
L27: ( dom ( DataPart C5 ) ) = ( Data-Locations ( SCM R7 ) ) by MEMSTR_0:9;
thus L28: ( dom ( DataPart C5 ) ) = ( dom ( DataPart C6 ) ) by L27 , MEMSTR_0:9;
let C7 being set;
assume L29: C7 in ( dom ( DataPart C5 ) );
L30: C7 is (Data-Location of R7) by L29 , L27 , SCMRING2:23;
thus L31: ( ( DataPart C5 ) . C7 ) = ( C5 . C7 ) by L29 , L27 , FUNCT_1:49
.= ( C6 . C7 ) by L30 , L25
.= ( ( DataPart C6 ) . C7 ) by L29 , L27 , FUNCT_1:49;
end;
thus L32: thesis by L26 , L22 , L24;
end;
registration
let R7 being non  trivial Ring;
cluster ( SCM R7 ) ->  relocable;
coherence
proof
let C8 being (Instruction of ( SCM R7 ));
let C9 , C10 being Nat;
reconsider D1 = C10 as (Element of ( NAT )) by ORDINAL1:def 12;
let C11 being (State of ( SCM R7 ));
L33: ( IC ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) ) = ( ( IC ( Exec (( IncAddr (C8 , C9) ) , C11) ) ) + D1 ) by MEMSTR_0:53
.= ( IC ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) ) by AMISTD_2:def 3;
per cases  by NAT_1:31 , SCMRING3:39;
suppose L34: ( InsCode C8 ) = ( 0 );

L35: C8 = ( halt ( SCM R7 ) ) by L34 , SCMRING3:12;
L36: ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) = ( IncIC (C11 , D1) ) by L35 , EXTPRO_1:def 3
.= ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) by L35 , EXTPRO_1:def 3;
thus L37: thesis by L36;
end;
suppose L38: ( InsCode C8 ) = 1;

consider C12 , C13 being (Data-Location of R7) such that L39: C8 = ( C12 := C13 ) by L38 , SCMRING3:13;
L40:
now
let C14 being (Data-Location of R7);
per cases ;
suppose L41: C12 = C14;

thus L42: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C14 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C14 ) by L39 , COMPOS_0:4
.= ( ( IncIC (C11 , D1) ) . C13 ) by L39 , L41 , SCMRING2:11
.= ( C11 . C13 ) by L14
.= ( ( Exec (C8 , C11) ) . C14 ) by L39 , L41 , SCMRING2:11
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C14 ) by L39 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C14 ) by L14;
end;
suppose L43: C12 <> C14;

thus L44: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C14 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C14 ) by L39 , COMPOS_0:4
.= ( ( IncIC (C11 , D1) ) . C14 ) by L39 , L43 , SCMRING2:11
.= ( C11 . C14 ) by L14
.= ( ( Exec (C8 , C11) ) . C14 ) by L39 , L43 , SCMRING2:11
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C14 ) by L39 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C14 ) by L14;
end;
end;
thus L46: thesis by L40 , L21 , L33;
end;
suppose L47: ( InsCode C8 ) = 2;

consider C15 , C16 being (Data-Location of R7) such that L48: C8 = ( AddTo (C15 , C16) ) by L47 , SCMRING3:14;
L49:
now
let C17 being (Data-Location of R7);
per cases ;
suppose L50: C15 = C17;

thus L51: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C17 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C17 ) by L48 , COMPOS_0:4
.= ( ( ( IncIC (C11 , D1) ) . C15 ) + ( ( IncIC (C11 , D1) ) . C16 ) ) by L50 , L48 , SCMRING2:12
.= ( ( C11 . C15 ) + ( ( IncIC (C11 , D1) ) . C16 ) ) by L14
.= ( ( C11 . C15 ) + ( C11 . C16 ) ) by L14
.= ( ( Exec (C8 , C11) ) . C17 ) by L48 , L50 , SCMRING2:12
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C17 ) by L48 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C17 ) by L14;
end;
suppose L52: C15 <> C17;

thus L53: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C17 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C17 ) by L48 , COMPOS_0:4
.= ( ( IncIC (C11 , D1) ) . C17 ) by L48 , L52 , SCMRING2:12
.= ( C11 . C17 ) by L14
.= ( ( Exec (C8 , C11) ) . C17 ) by L48 , L52 , SCMRING2:12
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C17 ) by L48 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C17 ) by L14;
end;
end;
thus L55: thesis by L49 , L21 , L33;
end;
suppose L56: ( InsCode C8 ) = 3;

consider C18 , C19 being (Data-Location of R7) such that L57: C8 = ( SubFrom (C18 , C19) ) by L56 , SCMRING3:15;
L58:
now
let C20 being (Data-Location of R7);
per cases ;
suppose L59: C18 = C20;

thus L60: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C20 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C20 ) by L57 , COMPOS_0:4
.= ( ( ( IncIC (C11 , D1) ) . C18 ) - ( ( IncIC (C11 , D1) ) . C19 ) ) by L59 , L57 , SCMRING2:13
.= ( ( C11 . C18 ) - ( ( IncIC (C11 , D1) ) . C19 ) ) by L14
.= ( ( C11 . C18 ) - ( C11 . C19 ) ) by L14
.= ( ( Exec (C8 , C11) ) . C20 ) by L57 , L59 , SCMRING2:13
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C20 ) by L57 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C20 ) by L14;
end;
suppose L61: C18 <> C20;

thus L62: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C20 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C20 ) by L57 , COMPOS_0:4
.= ( ( IncIC (C11 , D1) ) . C20 ) by L57 , L61 , SCMRING2:13
.= ( C11 . C20 ) by L14
.= ( ( Exec (C8 , C11) ) . C20 ) by L57 , L61 , SCMRING2:13
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C20 ) by L57 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C20 ) by L14;
end;
end;
thus L64: thesis by L58 , L21 , L33;
end;
suppose L65: ( InsCode C8 ) = 4;

consider C21 , C22 being (Data-Location of R7) such that L66: C8 = ( MultBy (C21 , C22) ) by L65 , SCMRING3:16;
L67:
now
let C23 being (Data-Location of R7);
per cases ;
suppose L68: C21 = C23;

thus L69: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C23 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C23 ) by L66 , COMPOS_0:4
.= ( ( ( IncIC (C11 , D1) ) . C21 ) * ( ( IncIC (C11 , D1) ) . C22 ) ) by L68 , L66 , SCMRING2:14
.= ( ( C11 . C21 ) * ( ( IncIC (C11 , D1) ) . C22 ) ) by L14
.= ( ( C11 . C21 ) * ( C11 . C22 ) ) by L14
.= ( ( Exec (C8 , C11) ) . C23 ) by L66 , L68 , SCMRING2:14
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C23 ) by L66 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C23 ) by L14;
end;
suppose L70: C21 <> C23;

thus L71: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C23 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C23 ) by L66 , COMPOS_0:4
.= ( ( IncIC (C11 , D1) ) . C23 ) by L66 , L70 , SCMRING2:14
.= ( C11 . C23 ) by L14
.= ( ( Exec (C8 , C11) ) . C23 ) by L66 , L70 , SCMRING2:14
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C23 ) by L66 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C23 ) by L14;
end;
end;
thus L73: thesis by L67 , L21 , L33;
end;
suppose L74: ( InsCode C8 ) = 5;

consider C24 being (Data-Location of R7), C25 being (Element of R7) such that L75: C8 = ( C24 := C25 ) by L74 , SCMRING3:17;
L76:
now
let C26 being (Data-Location of R7);
per cases ;
suppose L77: C24 = C26;

thus L78: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C26 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C26 ) by L75 , COMPOS_0:4
.= C25 by L77 , L75 , SCMRING2:17
.= ( ( Exec (C8 , C11) ) . C26 ) by L75 , L77 , SCMRING2:17
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C26 ) by L75 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C26 ) by L14;
end;
suppose L79: C24 <> C26;

thus L80: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C26 ) = ( ( Exec (C8 , ( IncIC (C11 , D1) )) ) . C26 ) by L75 , COMPOS_0:4
.= ( ( IncIC (C11 , D1) ) . C26 ) by L75 , L79 , SCMRING2:17
.= ( C11 . C26 ) by L14
.= ( ( Exec (C8 , C11) ) . C26 ) by L75 , L79 , SCMRING2:17
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C26 ) by L75 , COMPOS_0:4
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C26 ) by L14;
end;
end;
thus L82: thesis by L76 , L21 , L33;
end;
suppose L83: ( InsCode C8 ) = 6;

consider C27 being (Element of ( NAT )) such that L84: C8 = ( goto (C27 , R7) ) by L83 , SCMRING3:18;
L85: ( IncAddr (C8 , ( C9 + D1 )) ) = ( goto (( C27 + ( C9 + D1 ) ) , R7) ) by L84 , SCMRING3:37;
L86: ( IncAddr (C8 , C9) ) = ( goto (( C27 + C9 ) , R7) ) by L84 , SCMRING3:37;
L87:
now
let C28 being (Data-Location of R7);
thus L88: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C28 ) = ( ( IncIC (C11 , D1) ) . C28 ) by L85 , SCMRING2:15
.= ( C11 . C28 ) by L14
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C28 ) by L86 , SCMRING2:15
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C28 ) by L14;
end;
thus L89: thesis by L87 , L21 , L33;
end;
suppose L90: ( InsCode C8 ) = 7;

consider C29 being (Data-Location of R7), C30 being (Element of ( NAT )) such that L91: C8 = ( C29 =0_goto C30 ) by L90 , SCMRING3:19;
L92: ( IncAddr (C8 , ( C9 + D1 )) ) = ( C29 =0_goto ( C30 + ( C9 + D1 ) ) ) by L91 , SCMRING3:38;
L93: ( IncAddr (C8 , C9) ) = ( C29 =0_goto ( C30 + C9 ) ) by L91 , SCMRING3:38;
L94:
now
let C31 being (Data-Location of R7);
thus L95: ( ( Exec (( IncAddr (C8 , ( C9 + D1 )) ) , ( IncIC (C11 , D1) )) ) . C31 ) = ( ( IncIC (C11 , D1) ) . C31 ) by L92 , SCMRING2:16
.= ( C11 . C31 ) by L14
.= ( ( Exec (( IncAddr (C8 , C9) ) , C11) ) . C31 ) by L93 , SCMRING2:16
.= ( ( IncIC (( Exec (( IncAddr (C8 , C9) ) , C11) ) , D1) ) . C31 ) by L14;
end;
thus L96: thesis by L94 , L33 , L21;
end;
end;
end;
definition
let R7 being non  trivial Ring;
let C32 being (Data-Location of R7);
let C33 being (Element of R7);
redefine func C32 .--> C33 -> (FinPartState of ( SCM R7 ));

coherence
proof
set D2 = ( C32 .--> C33 );
set D3 = ( the_Values_of ( SCM R7 ) );
reconsider D4 = C32 as (Element of ( SCM-Memory )) by SCMRING2:def 1;
L99: ( dom D2 ) = { C32 } by FUNCOP_1:13;
L100: (for B9 being set holds (B9 in ( dom D2 ) implies ( D2 . B9 ) in ( D3 . B9 )))
proof
let C34 being set;
assume L101: C34 in ( dom D2 );
L102: C34 = C32 by L101 , L99 , TARSKI:def 1;
L103: ( D2 . C34 ) = C33 by L102 , FUNCOP_1:72;
L104: C32 in ( Data-Locations ( SCM ) ) by SCMRING2:1;
L105: C32 in ( SCM-Data-Loc ) by L104 , AMI_3:27;
L106: ( D3 . C34 ) = ( Values C32 ) by L99 , L101 , TARSKI:def 1
.= ( ( the_Values_of ( SCM R7 ) ) . C32 )
.= ( ( ( SCM-VAL R7 ) * ( SCM-OK ) ) . C32 ) by SCMRING2:24
.= (the carrier of R7) by L105 , SCMRING1:3;
thus L107: thesis by L106 , L103;
end;
thus L108: thesis by L100 , FUNCT_1:def 14;
end;
end;
registration
let C35 being non  trivial Ring;
cluster ( SCM C35 ) ->  IC-recognized;
coherence
proof
L110: (for B10 being non  halt-free  finite (the InstructionsF of ( SCM C35 )) -valued ( NAT ) -defined Function holds (for B11 being B10 -autonomic (FinPartState of ( SCM C35 )) holds (( DataPart B11 ) <> ( {} ) implies ( IC ( SCM C35 ) ) in ( dom B11 ))))
proof
let C36 being non  halt-free  finite (the InstructionsF of ( SCM C35 )) -valued ( NAT ) -defined Function;
let C37 being C36 -autonomic (FinPartState of ( SCM C35 ));
assume L111: ( DataPart C37 ) <> ( {} );
L112: ( dom ( DataPart C37 ) ) <> ( {} ) by L111;
assume L113: (not ( IC ( SCM C35 ) ) in ( dom C37 ));
L114: (not C37 is C36 -autonomic)
proof
set D5 = the (Element of ( ( NAT ) \ ( dom C36 ) ));
set D6 = the (Element of ( ( Data-Locations ( SCM ) ) \ ( dom C37 ) ));
set D7 = the (Element of ( dom ( DataPart C37 ) ));
L115: D7 in ( dom ( DataPart C37 ) ) by L112;
L116: ( DataPart C37 ) c= C37 by MEMSTR_0:12;
L117: ( dom ( DataPart C37 ) ) c= ( dom C37 ) by L116 , RELAT_1:11;
L118: ( dom ( DataPart C37 ) ) c= (the carrier of ( SCM C35 )) by RELAT_1:def 18;
reconsider D8 = D7 as (Element of ( SCM C35 )) by L118 , L115;
L119: (not ( Data-Locations ( SCM ) ) c= ( dom C37 ));
L120: ( ( Data-Locations ( SCM ) ) \ ( dom C37 ) ) <> ( {} ) by L119 , XBOOLE_1:37;
L121: D6 in ( Data-Locations ( SCM ) ) by L120 , XBOOLE_0:def 5;
reconsider D9 = D6 as (Data-Location of C35) by L121 , SCMRING2:1;
L122: (not D9 in ( dom C37 )) by L120 , XBOOLE_0:def 5;
L123: ( dom C37 ) misses { D9 } by L122 , ZFMISC_1:50;
L124: (not ( NAT ) c= ( dom C36 ));
L125: ( ( NAT ) \ ( dom C36 ) ) <> ( {} ) by L124 , XBOOLE_1:37;
reconsider D10 = D5 as (Element of ( NAT )) by L125 , XBOOLE_0:def 5;
L126: (not D10 in ( dom C36 )) by L125 , XBOOLE_0:def 5;
L127: ( Data-Locations ( SCM C35 ) ) = ( Data-Locations ( SCM ) ) by SCMRING2:22;
L128: ( dom ( DataPart C37 ) ) c= ( Data-Locations ( SCM ) ) by L127 , RELAT_1:58;
reconsider D11 = D8 as (Data-Location of C35) by L128 , L115 , SCMRING2:1;
L129: ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) = ( ( dom ( D9 .--> ( 0. C35 ) ) ) \/ ( dom ( Start-At (D10 , ( SCM C35 )) ) ) ) by FUNCT_4:def 1;
set D12 = ( C37 +* ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) );
set D13 = ( C36 +* ( D10 .--> ( D11 := D9 ) ) );
consider C38 being (State of ( SCM C35 )) such that L130: D12 c= C38 by PBOOLE:141;
consider C39 being (Instruction-Sequence of ( SCM C35 )) such that L131: D13 c= C39 by PBOOLE:145;
L132: ( dom D12 ) = ( ( dom C37 ) \/ ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) ) by FUNCT_4:def 1;
L133: ( dom ( Start-At (D10 , ( SCM C35 )) ) ) = { ( IC ( SCM C35 ) ) } by FUNCOP_1:13;
L134: ( IC ( SCM C35 ) ) in ( dom ( Start-At (D10 , ( SCM C35 )) ) ) by L133 , TARSKI:def 1;
L135: ( IC ( SCM C35 ) ) in ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) by L134 , L129 , XBOOLE_0:def 3;
L136: ( IC ( SCM C35 ) ) in ( dom D12 ) by L135 , L132 , XBOOLE_0:def 3;
L137: ( IC C38 ) = ( D12 . ( IC ( SCM C35 ) ) ) by L136 , L130 , GRFUNC_1:2
.= ( ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) . ( IC ( SCM C35 ) ) ) by L135 , FUNCT_4:13
.= ( ( Start-At (D10 , ( SCM C35 )) ) . ( IC ( SCM C35 ) ) ) by L134 , FUNCT_4:13
.= D10 by FUNCOP_1:72;
L138: ( dom ( Start-At (D10 , ( SCM C35 )) ) ) = { ( IC ( SCM C35 ) ) } by FUNCOP_1:13;
L139: D9 <> ( IC ( SCM C35 ) ) by SCMRING3:2;
L140: (not D9 in ( dom ( Start-At (D10 , ( SCM C35 )) ) )) by L139 , L133 , TARSKI:def 1;
L141: (not D9 in ( dom ( Start-At (D10 , ( SCM C35 )) ) )) by L139 , L138 , TARSKI:def 1;
L142: ( dom ( D9 .--> ( 0. C35 ) ) ) = { D9 } by FUNCOP_1:13;
L143: D9 in ( dom ( D9 .--> ( 0. C35 ) ) ) by L142 , TARSKI:def 1;
L144: D9 in ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) by L143 , L129 , XBOOLE_0:def 3;
L145: D9 in ( dom D12 ) by L144 , L132 , XBOOLE_0:def 3;
L146: ( C38 . D9 ) = ( D12 . D9 ) by L145 , L130 , GRFUNC_1:2
.= ( ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) . D9 ) by L144 , FUNCT_4:13
.= ( ( D9 .--> ( 0. C35 ) ) . D9 ) by L140 , FUNCT_4:11
.= ( 0. C35 ) by FUNCOP_1:72;
L147: ( dom ( D10 .--> ( D11 := D9 ) ) ) = { D10 } by FUNCOP_1:13;
L148: D10 in ( dom ( D10 .--> ( D11 := D9 ) ) ) by L147 , TARSKI:def 1;
L149: ( dom D13 ) = ( ( dom C36 ) \/ ( dom ( D10 .--> ( D11 := D9 ) ) ) ) by FUNCT_4:def 1;
L150: D10 in ( dom D13 ) by L149 , L148 , XBOOLE_0:def 3;
L151: ( C39 . D10 ) = ( D13 . D10 ) by L150 , L131 , GRFUNC_1:2
.= ( ( D10 .--> ( D11 := D9 ) ) . D10 ) by L148 , FUNCT_4:13
.= ( D11 := D9 ) by FUNCOP_1:72;
L152: ( dom C37 ) c= (the carrier of ( SCM C35 )) by RELAT_1:def 18;
L153: ( dom ( Comput (C39 , C38 , 1) ) ) = (the carrier of ( SCM C35 )) by PARTFUN1:def 2;
L154: ( dom ( ( Comput (C39 , C38 , 1) ) | ( dom C37 ) ) ) = ( dom C37 ) by L153 , L152 , RELAT_1:62;
consider C40 being (Element of C35) such that L155: C40 <> ( 0. C35 ) by STRUCT_0:def 18;
set D14 = ( C37 +* ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) );
set D15 = ( C36 +* ( D10 .--> ( D11 := D9 ) ) );
consider C41 being (State of ( SCM C35 )) such that L156: D14 c= C41 by PBOOLE:141;
consider C42 being (Instruction-Sequence of ( SCM C35 )) such that L157: D15 c= C42 by PBOOLE:145;
L158: ( dom ( Comput (C42 , C41 , 1) ) ) = (the carrier of ( SCM C35 )) by PARTFUN1:def 2;
L159: ( dom ( ( Comput (C42 , C41 , 1) ) | ( dom C37 ) ) ) = ( dom C37 ) by L152 , L158 , RELAT_1:62;
L160: ( dom C37 ) misses { ( IC ( SCM C35 ) ) } by L113 , ZFMISC_1:50;
L161: ( ( dom C37 ) /\ { ( IC ( SCM C35 ) ) } ) = ( {} ) by L160 , XBOOLE_0:def 7;
take D16 = C39;
take D17 = C42;
L162: ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) = ( ( dom ( D9 .--> ( 0. C35 ) ) ) \/ ( dom ( Start-At (D10 , ( SCM C35 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D9 .--> ( 0. C35 ) ) ) \/ { ( IC ( SCM C35 ) ) } ) by FUNCOP_1:13
.= ( { D9 } \/ { ( IC ( SCM C35 ) ) } ) by FUNCOP_1:13;
L163: ( ( dom C37 ) /\ ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) ) = ( ( ( dom C37 ) /\ { D9 } ) \/ ( {} ) ) by L162 , L161 , XBOOLE_1:23
.= ( {} ) by L123 , XBOOLE_0:def 7;
L164: ( dom C37 ) misses ( dom ( ( D9 .--> ( 0. C35 ) ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) by L163 , XBOOLE_0:def 7;
L165: C37 c= D12 by L164 , FUNCT_4:32;
L166: C37 c= C38 by L165 , L130 , XBOOLE_1:1;
L167: ( dom C36 ) misses ( dom ( D10 .--> ( D11 := D9 ) ) ) by L147 , L126 , ZFMISC_1:50;
L168: C36 c= D13 by L167 , FUNCT_4:32;
thus L169: C36 c= D16 by L168 , L131 , XBOOLE_1:1;
L170: ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) = ( ( dom ( D9 .--> C40 ) ) \/ ( dom ( Start-At (D10 , ( SCM C35 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( D9 .--> C40 ) ) \/ { ( IC ( SCM C35 ) ) } ) by FUNCOP_1:13
.= ( { D9 } \/ { ( IC ( SCM C35 ) ) } ) by FUNCOP_1:13;
L171: ( ( dom C37 ) /\ ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) ) = ( ( ( dom C37 ) /\ { D9 } ) \/ ( {} ) ) by L170 , L161 , XBOOLE_1:23
.= ( {} ) by L123 , XBOOLE_0:def 7;
L172: ( dom C37 ) misses ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) by L171 , XBOOLE_0:def 7;
L173: C37 c= D14 by L172 , FUNCT_4:32;
L174: C37 c= C41 by L173 , L156 , XBOOLE_1:1;
L175: C36 c= D15 by L167 , FUNCT_4:32;
thus L176: C36 c= D17 by L175 , L157 , XBOOLE_1:1;
take C38;
take C41;
thus L177: C37 c= C38 by L166;
thus L178: C37 c= C41 by L174;
take 1;
L179: ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) = ( ( dom ( D9 .--> C40 ) ) \/ ( dom ( Start-At (D10 , ( SCM C35 )) ) ) ) by FUNCT_4:def 1;
L180: ( dom ( D9 .--> C40 ) ) = { D9 } by FUNCOP_1:13;
L181: ( dom D14 ) = ( ( dom C37 ) \/ ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) ) by FUNCT_4:def 1;
L182: ( IC ( SCM C35 ) ) in ( dom ( Start-At (D10 , ( SCM C35 )) ) ) by L138 , TARSKI:def 1;
L183: ( IC ( SCM C35 ) ) in ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) by L182 , L179 , XBOOLE_0:def 3;
L184: ( IC ( SCM C35 ) ) in ( dom D14 ) by L183 , L181 , XBOOLE_0:def 3;
L185: ( IC C41 ) = ( D14 . ( IC ( SCM C35 ) ) ) by L184 , L156 , GRFUNC_1:2
.= ( ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) . ( IC ( SCM C35 ) ) ) by L183 , FUNCT_4:13
.= ( ( Start-At (D10 , ( SCM C35 )) ) . ( IC ( SCM C35 ) ) ) by L182 , FUNCT_4:13
.= D10 by FUNCOP_1:72;
L186: ( dom ( D10 .--> ( D11 := D9 ) ) ) = { D10 } by FUNCOP_1:13;
L187: D10 in ( dom ( D10 .--> ( D11 := D9 ) ) ) by L186 , TARSKI:def 1;
L188: ( dom D13 ) = ( ( dom C36 ) \/ ( dom ( D10 .--> ( D11 := D9 ) ) ) ) by FUNCT_4:def 1;
L189: D10 in ( dom D15 ) by L188 , L187 , XBOOLE_0:def 3;
L190: ( C42 . D10 ) = ( D15 . D10 ) by L189 , L157 , GRFUNC_1:2
.= ( ( D10 .--> ( D11 := D9 ) ) . D10 ) by L187 , FUNCT_4:13
.= ( D11 := D9 ) by FUNCOP_1:72;
L191: D9 in ( dom ( D9 .--> C40 ) ) by L180 , TARSKI:def 1;
L192: D9 in ( dom ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) ) by L191 , L179 , XBOOLE_0:def 3;
L193: D9 in ( dom D14 ) by L192 , L181 , XBOOLE_0:def 3;
L194: ( C41 . D9 ) = ( D14 . D9 ) by L193 , L156 , GRFUNC_1:2
.= ( ( ( D9 .--> C40 ) +* ( Start-At (D10 , ( SCM C35 )) ) ) . D9 ) by L192 , FUNCT_4:13
.= ( ( D9 .--> C40 ) . D9 ) by L141 , FUNCT_4:11
.= C40 by FUNCOP_1:72;
L195: ( C42 /. D10 ) = ( C42 . D10 ) by PBOOLE:143;
L196: ( ( Comput (C42 , C41 , ( ( 0 ) + 1 )) ) . D11 ) = ( ( Following (C42 , ( Comput (C42 , C41 , ( 0 )) )) ) . D11 ) by EXTPRO_1:3
.= ( ( Following (C42 , C41) ) . D11 )
.= C40 by L185 , L190 , L194 , L195 , SCMRING2:11;
L197: ( C39 /. D10 ) = ( C39 . D10 ) by PBOOLE:143;
L198: ( ( Comput (C39 , C38 , ( ( 0 ) + 1 )) ) . D11 ) = ( ( Following (C39 , ( Comput (C39 , C38 , ( 0 )) )) ) . D11 ) by EXTPRO_1:3
.= ( ( Following (C39 , C38) ) . D11 )
.= ( 0. C35 ) by L137 , L151 , L146 , L197 , SCMRING2:11;
L199: ( ( ( Comput (D16 , C38 , 1) ) | ( dom C37 ) ) . D11 ) = ( 0. C35 ) by L198 , L154 , L115 , L117 , FUNCT_1:47;
thus L200: ( ( Comput (D16 , C38 , 1) ) | ( dom C37 ) ) <> ( ( Comput (D17 , C41 , 1) ) | ( dom C37 ) ) by L199 , L155 , L115 , L159 , L117 , L196 , FUNCT_1:47;
end;
thus L201: contradiction by L114;
end;
thus L202: thesis by L110 , AMISTD_5:3;
end;
end;
registration
let C43 being non  trivial Ring;
cluster ( SCM C43 ) ->  CurIns-recognized;
coherence
proof
let C44 being non  halt-free  finite (the InstructionsF of ( SCM C43 )) -valued ( NAT ) -defined Function;
let C45 being C44 -autonomic non  empty (FinPartState of ( SCM C43 ));
let C46 being (State of ( SCM C43 ));
assume that
L204: C45 c= C46;
let C47 being (Instruction-Sequence of ( SCM C43 ));
assume that
L205: C44 c= C47;
let C48 being (Element of ( NAT ));
set D18 = ( Comput (C47 , C46 , C48) );
set D19 = ( IC D18 );
set D20 = ( D19 + 1 );
assume L206: (not ( IC ( Comput (C47 , C46 , C48) ) ) in ( dom C44 ));
set D21 = ( ( dl. (C43 , ( 0 )) ) := ( dl. (C43 , ( 0 )) ) );
set D22 = ( C44 +* ( D19 .--> D21 ) );
set D23 = ( C44 +* ( D19 .--> ( halt ( SCM C43 ) ) ) );
reconsider D24 = ( C47 +* ( D19 .--> D21 ) ) as (Instruction-Sequence of ( SCM C43 ));
reconsider D25 = ( C47 +* ( D19 .--> ( halt ( SCM C43 ) ) ) ) as (Instruction-Sequence of ( SCM C43 ));
L207: ( dom ( D19 .--> ( halt ( SCM C43 ) ) ) ) = { D19 } by FUNCOP_1:13;
L208: D19 in ( dom ( D19 .--> ( halt ( SCM C43 ) ) ) ) by L207 , TARSKI:def 1;
L209: ( dom ( D19 .--> D21 ) ) = { D19 } by FUNCOP_1:13;
L210: D19 in ( dom ( D19 .--> D21 ) ) by L209 , TARSKI:def 1;
L211: ( dom C44 ) misses ( dom ( D19 .--> ( halt ( SCM C43 ) ) ) ) by L206 , L207 , ZFMISC_1:50;
L212: ( dom C44 ) misses ( dom ( D19 .--> D21 ) ) by L206 , L209 , ZFMISC_1:50;
L213: D22 c= D24 by L205 , FUNCT_4:123;
L214: D23 c= D25 by L205 , FUNCT_4:123;
set D26 = ( Comput (D25 , C46 , C48) );
set D27 = ( Comput (D24 , C46 , C48) );
L215: (not C45 is C44 -autonomic)
proof
L216: ( ( D19 .--> ( halt ( SCM C43 ) ) ) . D19 ) = ( halt ( SCM C43 ) ) by FUNCOP_1:72;
L217: ( D25 . D19 ) = ( halt ( SCM C43 ) ) by L216 , L208 , FUNCT_4:13;
L218: ( ( D19 .--> D21 ) . D19 ) = D21 by FUNCOP_1:72;
take D24;
take D25;
L219: C44 c= D22 by L212 , FUNCT_4:32;
thus L220: C44 c= D24 by L219 , L213 , XBOOLE_1:1;
L221: C44 c= D23 by L211 , FUNCT_4:32;
thus L222: C44 c= D25 by L221 , L214 , XBOOLE_1:1;
take C46;
take C46;
thus L223: C45 c= C46 by L204;
L224: ( D27 | ( dom C45 ) ) = ( D18 | ( dom C45 ) ) by L220 , L205 , L204 , EXTPRO_1:def 10;
thus L225: C45 c= C46 by L204;
L226: ( D27 | ( dom C45 ) ) = ( D26 | ( dom C45 ) ) by L220 , L222 , L204 , EXTPRO_1:def 10;
take D28 = ( C48 + 1 );
set D29 = ( Comput (D24 , C46 , D28) );
L227: ( IC ( SCM C43 ) ) in ( dom C45 ) by AMISTD_5:6;
L228: ( IC D18 ) = ( IC ( D18 | ( dom C45 ) ) ) by L227 , FUNCT_1:49;
L229: ( IC D27 ) = D19 by L228 , L224 , L227 , FUNCT_1:49;
L230: ( CurInstr (D24 , D27) ) = ( D24 . D19 ) by L229 , PBOOLE:143
.= D21 by L218 , L210 , FUNCT_4:13;
L231: D29 = ( Following (D24 , D27) ) by EXTPRO_1:3
.= ( Exec (D21 , D27) ) by L230;
L232: ( IC ( Exec (D21 , D27) ) ) = ( succ ( IC D27 ) ) by SCMRING2:11;
L233: ( IC ( SCM C43 ) ) in ( dom C45 ) by AMISTD_5:6;
L234: ( IC D18 ) = ( IC ( D18 | ( dom C45 ) ) ) by L233 , FUNCT_1:49;
L235: ( IC D29 ) = D20 by L234 , L231 , L232 , L224 , L233 , FUNCT_1:49;
set D30 = ( Comput (D25 , C46 , D28) );
L236: D30 = ( Following (D25 , D26) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D25 , D26) ) , D26) );
L237: ( D25 /. ( IC D26 ) ) = ( D25 . ( IC D26 ) ) by PBOOLE:143;
L238: ( IC D26 ) = D19 by L224 , L234 , L226 , L233 , FUNCT_1:49;
L239: ( IC D30 ) = D19 by L238 , L236 , L217 , L237 , EXTPRO_1:def 3;
L240: (( IC ( D29 | ( dom C45 ) ) ) = ( IC D29 ) & ( IC ( D30 | ( dom C45 ) ) ) = ( IC D30 )) by L233 , FUNCT_1:49;
thus L241: thesis by L240 , L235 , L239;
end;
thus L242: contradiction by L215;
end;
end;
theorem
L244: (for R4 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds (for R8 being (Data-Location of R7) holds (for R9 being (Data-Location of R7) holds (for R14 being (State of ( SCM R7 )) holds (for R15 being (State of ( SCM R7 )) holds (for R17 being (Instruction-Sequence of ( SCM R7 )) holds (for R18 being (Instruction-Sequence of ( SCM R7 )) holds (for B12 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function holds (for B13 being B12 -autonomic non  empty (FinPartState of ( SCM R7 )) holds ((B13 c= R14 & B13 c= R15 & B12 c= R17 & B12 c= R18 & ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) ) = ( R8 := R9 ) & R8 in ( dom B13 )) implies ( ( Comput (R17 , R14 , R4) ) . R9 ) = ( ( Comput (R18 , R15 , R4) ) . R9 ))))))))))))
proof
let R4 being (Element of ( NAT ));
let R7 being non  trivial Ring;
let R8 being (Data-Location of R7);
let R9 being (Data-Location of R7);
let R14 being (State of ( SCM R7 ));
let R15 being (State of ( SCM R7 ));
let R17 being (Instruction-Sequence of ( SCM R7 ));
let R18 being (Instruction-Sequence of ( SCM R7 ));
set D31 = ( Comput (R18 , R15 , ( R4 + 1 )) );
set D32 = ( Comput (R17 , R14 , ( R4 + 1 )) );
set D33 = ( Comput (R18 , R15 , R4) );
set D34 = ( Comput (R17 , R14 , R4) );
set D35 = ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) );
let C49 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function;
let C50 being C49 -autonomic non  empty (FinPartState of ( SCM R7 ));
assume that
L245: (C50 c= R14 & C50 c= R15)
and
L246: (C49 c= R17 & C49 c= R18);
L247: (R8 in ( dom C50 ) implies (( ( D32 | ( dom C50 ) ) . R8 ) = ( D32 . R8 ) & ( ( D31 | ( dom C50 ) ) . R8 ) = ( D31 . R8 ))) by FUNCT_1:49;
L248: D31 = ( Following (R18 , D33) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R18 , D33) ) , D33) );
assume that
L249: D35 = ( R8 := R9 )
and
L250: (R8 in ( dom C50 ) & ( ( Comput (R17 , R14 , R4) ) . R9 ) <> ( ( Comput (R18 , R15 , R4) ) . R9 ));
L251: D32 = ( Following (R17 , D34) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R17 , D34) ) , D34) );
L252: ( D32 . R8 ) = ( D34 . R9 ) by L251 , L249 , SCMRING2:11;
L253: D35 = ( CurInstr (R18 , ( Comput (R18 , R15 , R4) )) ) by L245 , L246 , AMISTD_5:7;
L254: ( D31 . R8 ) = ( D33 . R9 ) by L253 , L248 , L249 , SCMRING2:11;
thus L255: contradiction by L254 , L245 , L247 , L250 , L252 , L246 , EXTPRO_1:def 10;
end;
theorem
L256: (for R4 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds (for R8 being (Data-Location of R7) holds (for R9 being (Data-Location of R7) holds (for R14 being (State of ( SCM R7 )) holds (for R15 being (State of ( SCM R7 )) holds (for R17 being (Instruction-Sequence of ( SCM R7 )) holds (for R18 being (Instruction-Sequence of ( SCM R7 )) holds (for B14 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function holds (for B15 being B14 -autonomic non  empty (FinPartState of ( SCM R7 )) holds ((B15 c= R14 & B15 c= R15 & B14 c= R17 & B14 c= R18 & ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) ) = ( AddTo (R8 , R9) ) & R8 in ( dom B15 )) implies ( ( ( Comput (R17 , R14 , R4) ) . R8 ) + ( ( Comput (R17 , R14 , R4) ) . R9 ) ) = ( ( ( Comput (R18 , R15 , R4) ) . R8 ) + ( ( Comput (R18 , R15 , R4) ) . R9 ) ))))))))))))
proof
let R4 being (Element of ( NAT ));
let R7 being non  trivial Ring;
let R8 being (Data-Location of R7);
let R9 being (Data-Location of R7);
let R14 being (State of ( SCM R7 ));
let R15 being (State of ( SCM R7 ));
let R17 being (Instruction-Sequence of ( SCM R7 ));
let R18 being (Instruction-Sequence of ( SCM R7 ));
set D36 = ( Comput (R18 , R15 , ( R4 + 1 )) );
set D37 = ( Comput (R17 , R14 , ( R4 + 1 )) );
set D38 = ( Comput (R18 , R15 , R4) );
set D39 = ( Comput (R17 , R14 , R4) );
set D40 = ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) );
let C51 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function;
let C52 being C51 -autonomic non  empty (FinPartState of ( SCM R7 ));
assume that
L257: (C52 c= R14 & C52 c= R15)
and
L258: (C51 c= R17 & C51 c= R18);
L259: (R8 in ( dom C52 ) implies (( ( D37 | ( dom C52 ) ) . R8 ) = ( D37 . R8 ) & ( ( D36 | ( dom C52 ) ) . R8 ) = ( D36 . R8 ))) by FUNCT_1:49;
L260: D36 = ( Following (R18 , D38) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R18 , D38) ) , D38) );
assume that
L261: D40 = ( AddTo (R8 , R9) )
and
L262: (R8 in ( dom C52 ) & ( ( ( Comput (R17 , R14 , R4) ) . R8 ) + ( ( Comput (R17 , R14 , R4) ) . R9 ) ) <> ( ( ( Comput (R18 , R15 , R4) ) . R8 ) + ( ( Comput (R18 , R15 , R4) ) . R9 ) ));
L263: D37 = ( Following (R17 , D39) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R17 , D39) ) , D39) );
L264: ( D37 . R8 ) = ( ( D39 . R8 ) + ( D39 . R9 ) ) by L263 , L261 , SCMRING2:12;
L265: D40 = ( CurInstr (R18 , ( Comput (R18 , R15 , R4) )) ) by L257 , L258 , AMISTD_5:7;
L266: ( D36 . R8 ) = ( ( D38 . R8 ) + ( D38 . R9 ) ) by L265 , L260 , L261 , SCMRING2:12;
thus L267: contradiction by L266 , L257 , L259 , L262 , L264 , L258 , EXTPRO_1:def 10;
end;
theorem
L268: (for R4 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds (for R8 being (Data-Location of R7) holds (for R9 being (Data-Location of R7) holds (for R14 being (State of ( SCM R7 )) holds (for R15 being (State of ( SCM R7 )) holds (for R17 being (Instruction-Sequence of ( SCM R7 )) holds (for R18 being (Instruction-Sequence of ( SCM R7 )) holds (for B16 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function holds (for B17 being B16 -autonomic non  empty (FinPartState of ( SCM R7 )) holds ((B17 c= R14 & B17 c= R15 & B16 c= R17 & B16 c= R18 & ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) ) = ( SubFrom (R8 , R9) ) & R8 in ( dom B17 )) implies ( ( ( Comput (R17 , R14 , R4) ) . R8 ) - ( ( Comput (R17 , R14 , R4) ) . R9 ) ) = ( ( ( Comput (R18 , R15 , R4) ) . R8 ) - ( ( Comput (R18 , R15 , R4) ) . R9 ) ))))))))))))
proof
let R4 being (Element of ( NAT ));
let R7 being non  trivial Ring;
let R8 being (Data-Location of R7);
let R9 being (Data-Location of R7);
let R14 being (State of ( SCM R7 ));
let R15 being (State of ( SCM R7 ));
let R17 being (Instruction-Sequence of ( SCM R7 ));
let R18 being (Instruction-Sequence of ( SCM R7 ));
set D41 = ( Comput (R18 , R15 , ( R4 + 1 )) );
set D42 = ( Comput (R17 , R14 , ( R4 + 1 )) );
set D43 = ( Comput (R18 , R15 , R4) );
set D44 = ( Comput (R17 , R14 , R4) );
set D45 = ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) );
let C53 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function;
let C54 being C53 -autonomic non  empty (FinPartState of ( SCM R7 ));
assume that
L269: (C54 c= R14 & C54 c= R15)
and
L270: (C53 c= R17 & C53 c= R18);
L271: (R8 in ( dom C54 ) implies (( ( D42 | ( dom C54 ) ) . R8 ) = ( D42 . R8 ) & ( ( D41 | ( dom C54 ) ) . R8 ) = ( D41 . R8 ))) by FUNCT_1:49;
L272: D41 = ( Following (R18 , D43) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R18 , D43) ) , D43) );
assume that
L273: D45 = ( SubFrom (R8 , R9) )
and
L274: (R8 in ( dom C54 ) & ( ( ( Comput (R17 , R14 , R4) ) . R8 ) - ( ( Comput (R17 , R14 , R4) ) . R9 ) ) <> ( ( ( Comput (R18 , R15 , R4) ) . R8 ) - ( ( Comput (R18 , R15 , R4) ) . R9 ) ));
L275: D42 = ( Following (R17 , D44) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R17 , D44) ) , D44) );
L276: ( D42 . R8 ) = ( ( D44 . R8 ) - ( D44 . R9 ) ) by L275 , L273 , SCMRING2:13;
L277: D45 = ( CurInstr (R18 , ( Comput (R18 , R15 , R4) )) ) by L269 , L270 , AMISTD_5:7;
L278: ( D41 . R8 ) = ( ( D43 . R8 ) - ( D43 . R9 ) ) by L277 , L272 , L273 , SCMRING2:13;
thus L279: contradiction by L278 , L269 , L271 , L274 , L276 , L270 , EXTPRO_1:def 10;
end;
theorem
L280: (for R4 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds (for R8 being (Data-Location of R7) holds (for R9 being (Data-Location of R7) holds (for R14 being (State of ( SCM R7 )) holds (for R15 being (State of ( SCM R7 )) holds (for R17 being (Instruction-Sequence of ( SCM R7 )) holds (for R18 being (Instruction-Sequence of ( SCM R7 )) holds (for B18 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function holds (for B19 being B18 -autonomic non  empty (FinPartState of ( SCM R7 )) holds ((B19 c= R14 & B19 c= R15 & B18 c= R17 & B18 c= R18 & ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) ) = ( MultBy (R8 , R9) ) & R8 in ( dom B19 )) implies ( ( ( Comput (R17 , R14 , R4) ) . R8 ) * ( ( Comput (R17 , R14 , R4) ) . R9 ) ) = ( ( ( Comput (R18 , R15 , R4) ) . R8 ) * ( ( Comput (R18 , R15 , R4) ) . R9 ) ))))))))))))
proof
let R4 being (Element of ( NAT ));
let R7 being non  trivial Ring;
let R8 being (Data-Location of R7);
let R9 being (Data-Location of R7);
let R14 being (State of ( SCM R7 ));
let R15 being (State of ( SCM R7 ));
let R17 being (Instruction-Sequence of ( SCM R7 ));
let R18 being (Instruction-Sequence of ( SCM R7 ));
set D46 = ( Comput (R18 , R15 , ( R4 + 1 )) );
set D47 = ( Comput (R17 , R14 , ( R4 + 1 )) );
set D48 = ( Comput (R18 , R15 , R4) );
set D49 = ( Comput (R17 , R14 , R4) );
set D50 = ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) );
let C55 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function;
let C56 being C55 -autonomic non  empty (FinPartState of ( SCM R7 ));
assume that
L281: (C56 c= R14 & C56 c= R15)
and
L282: (C55 c= R17 & C55 c= R18);
L283: (R8 in ( dom C56 ) implies (( ( D47 | ( dom C56 ) ) . R8 ) = ( D47 . R8 ) & ( ( D46 | ( dom C56 ) ) . R8 ) = ( D46 . R8 ))) by FUNCT_1:49;
L284: D46 = ( Following (R18 , D48) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R18 , D48) ) , D48) );
assume that
L285: D50 = ( MultBy (R8 , R9) )
and
L286: (R8 in ( dom C56 ) & ( ( ( Comput (R17 , R14 , R4) ) . R8 ) * ( ( Comput (R17 , R14 , R4) ) . R9 ) ) <> ( ( ( Comput (R18 , R15 , R4) ) . R8 ) * ( ( Comput (R18 , R15 , R4) ) . R9 ) ));
L287: D47 = ( Following (R17 , D49) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R17 , D49) ) , D49) );
L288: ( D47 . R8 ) = ( ( D49 . R8 ) * ( D49 . R9 ) ) by L287 , L285 , SCMRING2:14;
L289: D50 = ( CurInstr (R18 , ( Comput (R18 , R15 , R4) )) ) by L281 , L282 , AMISTD_5:7;
L290: ( D46 . R8 ) = ( ( D48 . R8 ) * ( D48 . R9 ) ) by L289 , L284 , L285 , SCMRING2:14;
thus L291: contradiction by L290 , L281 , L283 , L286 , L288 , L282 , EXTPRO_1:def 10;
end;
theorem
L292: (for R4 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds (for R8 being (Data-Location of R7) holds (for R10 being (Element of ( NAT )) holds (for R14 being (State of ( SCM R7 )) holds (for R15 being (State of ( SCM R7 )) holds (for R17 being (Instruction-Sequence of ( SCM R7 )) holds (for R18 being (Instruction-Sequence of ( SCM R7 )) holds (for B20 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function holds (for B21 being B20 -autonomic non  empty (FinPartState of ( SCM R7 )) holds ((B21 c= R14 & B21 c= R15 & B20 c= R17 & B20 c= R18 & ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) ) = ( R8 =0_goto R10 ) & R10 <> ( succ ( IC ( Comput (R17 , R14 , R4) ) ) )) implies (( ( Comput (R17 , R14 , R4) ) . R8 ) = ( 0. R7 ) iff ( ( Comput (R18 , R15 , R4) ) . R8 ) = ( 0. R7 )))))))))))))
proof
let R4 being (Element of ( NAT ));
let R7 being non  trivial Ring;
let R8 being (Data-Location of R7);
let R10 being (Element of ( NAT ));
let R14 being (State of ( SCM R7 ));
let R15 being (State of ( SCM R7 ));
let R17 being (Instruction-Sequence of ( SCM R7 ));
let R18 being (Instruction-Sequence of ( SCM R7 ));
set D51 = ( Comput (R18 , R15 , ( R4 + 1 )) );
set D52 = ( Comput (R17 , R14 , ( R4 + 1 )) );
set D53 = ( CurInstr (R17 , ( Comput (R17 , R14 , R4) )) );
let C57 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function;
let C58 being C57 -autonomic non  empty (FinPartState of ( SCM R7 ));
assume that
L293: (C58 c= R14 & C58 c= R15)
and
L294: (C57 c= R17 & C57 c= R18);
L295: D53 = ( CurInstr (R18 , ( Comput (R18 , R15 , R4) )) ) by L293 , L294 , AMISTD_5:7;
set D54 = ( Comput (R18 , R15 , R4) );
set D55 = ( Comput (R17 , R14 , R4) );
L296: D52 = ( Following (R17 , D55) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R17 , D55) ) , D55) );
L297: D51 = ( Following (R18 , D54) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R18 , D54) ) , D54) );
L298: ( IC ( SCM R7 ) ) in ( dom C58 ) by AMISTD_5:6;
L299: (( ( D52 | ( dom C58 ) ) . ( IC ( SCM R7 ) ) ) = ( D52 . ( IC ( SCM R7 ) ) ) & ( ( D51 | ( dom C58 ) ) . ( IC ( SCM R7 ) ) ) = ( D51 . ( IC ( SCM R7 ) ) )) by L298 , FUNCT_1:49;
assume that
L300: D53 = ( R8 =0_goto R10 )
and
L301: R10 <> ( succ ( IC ( Comput (R17 , R14 , R4) ) ) );
L302: ( IC D55 ) = ( IC D54 ) by L293 , L294 , AMISTD_5:7;
thus L303:now
assume L304: (( ( Comput (R17 , R14 , R4) ) . R8 ) = ( 0. R7 ) & ( ( Comput (R18 , R15 , R4) ) . R8 ) <> ( 0. R7 ));
L305: (( D52 . ( IC ( SCM R7 ) ) ) = R10 & ( D51 . ( IC ( SCM R7 ) ) ) = ( succ ( IC D54 ) )) by L304 , L295 , L296 , L297 , L300 , SCMRING2:16;
thus L306: contradiction by L305 , L293 , L302 , L299 , L301 , L294 , EXTPRO_1:def 10;
end;
assume that
L307: ( ( Comput (R18 , R15 , R4) ) . R8 ) = ( 0. R7 )
and
L308: ( ( Comput (R17 , R14 , R4) ) . R8 ) <> ( 0. R7 );
L309: ( D52 . ( IC ( SCM R7 ) ) ) = ( succ ( IC D55 ) ) by L296 , L300 , L308 , SCMRING2:16;
L310: ( D51 . ( IC ( SCM R7 ) ) ) = R10 by L295 , L297 , L300 , L307 , SCMRING2:16;
thus L311: contradiction by L310 , L293 , L299 , L301 , L309 , L294 , EXTPRO_1:def 10;
end;
begin
theorem
L312: (for R3 being (Element of ( NAT )) holds (for R7 being non  trivial Ring holds (for R14 being (State of ( SCM R7 )) holds (for R15 being (State of ( SCM R7 )) holds (for B22 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function holds (for B23 being non  empty B22 -autonomic (FinPartState of ( SCM R7 )) holds ((B23 c= R14 & ( IncIC (B23 , R3) ) c= R15) implies (for B24 , B25 being (Instruction-Sequence of ( SCM R7 )) holds ((B22 c= B24 & ( Reloc (B22 , R3) ) c= B25) implies (for B26 being (Element of ( NAT )) holds (( ( IC ( Comput (B24 , R14 , B26) ) ) + R3 ) = ( IC ( Comput (B25 , R15 , B26) ) ) & ( IncAddr (( CurInstr (B24 , ( Comput (B24 , R14 , B26) )) ) , R3) ) = ( CurInstr (B25 , ( Comput (B25 , R15 , B26) )) ) & ( ( Comput (B24 , R14 , B26) ) | ( dom ( DataPart B23 ) ) ) = ( ( Comput (B25 , R15 , B26) ) | ( dom ( DataPart B23 ) ) ) & ( DataPart ( Comput (B24 , ( R14 +* ( DataPart R15 ) ) , B26) ) ) = ( DataPart ( Comput (B25 , R15 , B26) ) ))))))))))))
proof
let R3 being (Element of ( NAT ));
let R7 being non  trivial Ring;
let R14 being (State of ( SCM R7 ));
let R15 being (State of ( SCM R7 ));
let C59 being non  halt-free  finite (the InstructionsF of ( SCM R7 )) -valued ( NAT ) -defined Function;
let C60 being non  empty C59 -autonomic (FinPartState of ( SCM R7 ));
assume that
L313: C60 c= R14
and
L314: ( IncIC (C60 , R3) ) c= R15;
L315: ( IC ( SCM R7 ) ) in ( dom C60 ) by AMISTD_5:6;
let C61 , C62 being (Instruction-Sequence of ( SCM R7 ));
assume that
L316: (C59 c= C61 & ( Reloc (C59 , R3) ) c= C62);
set D56 = ( R14 +* ( DataPart R15 ) );
defpred S1[ (Element of ( NAT )) ] means (( ( IC ( Comput (C61 , R14 , $1) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , $1) ) ) & ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , $1) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , $1) )) ) & ( ( Comput (C61 , R14 , $1) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , $1) ) | ( dom ( DataPart C60 ) ) ) & ( DataPart ( Comput (C61 , D56 , $1) ) ) = ( DataPart ( Comput (C62 , R15 , $1) ) ));
L317: ( IC C60 ) = ( IC R14 ) by L313 , L315 , GRFUNC_1:2;
L318: ( IC C60 ) = ( IC ( Comput (C61 , R14 , ( 0 )) ) ) by L317;
L319: ( IC C60 ) in ( dom C59 ) by L318 , L313 , L316 , AMISTD_5:def 4;
L320: C60 c= D56 by L313 , L314 , MEMSTR_0:61;
L321: (for B27 being (Element of ( NAT )) holds (S1[ B27 ] implies S1[ (( B27 + 1 ) qua (Element of ( NAT ))) ]))
proof
set D57 = ( DataPart C60 );
let C63 being (Element of ( NAT ));
assume that
L322: ( ( IC ( Comput (C61 , R14 , C63) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , C63) ) )
and
L323: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , C63) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , C63) )) )
and
L324: ( ( Comput (C61 , R14 , C63) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , C63) ) | ( dom ( DataPart C60 ) ) )
and
L325: ( DataPart ( Comput (C61 , D56 , C63) ) ) = ( DataPart ( Comput (C62 , R15 , C63) ) );
set D58 = ( Comput (C62 , R15 , ( C63 + 1 )) );
set D59 = ( Comput (C61 , D56 , C63) );
set D60 = ( Comput (C62 , R15 , C63) );
L326: D58 = ( Following (C62 , D60) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C62 , D60) ) , D60) );
L327:
now
let C64 being (State of ( SCM R7 ));
let C65 being (Data-Location of R7);
L328: C65 in ( Data-Locations ( SCM R7 ) ) by SCMRING2:23;
thus L329: C65 in ( dom ( DataPart C64 ) ) by L328 , MEMSTR_0:9;
end;
L330:
now
let C66 being (Data-Location of R7);
L331: C66 in ( dom ( DataPart D59 ) ) by L327;
thus L332: ( D59 . C66 ) = ( ( DataPart D59 ) . C66 ) by L331 , FUNCT_1:47
.= ( D60 . C66 ) by L325 , L331 , FUNCT_1:47;
end;
set D61 = ( Comput (C61 , R14 , ( C63 + 1 )) );
set D62 = ( Comput (C61 , R14 , C63) );
L333: ( dom D61 ) = (the carrier of ( SCM R7 )) by PARTFUN1:def 2;
L334: ( dom D61 ) = ( { ( IC ( SCM R7 ) ) } \/ ( Data-Locations ( SCM R7 ) ) ) by L333 , XBOOLE_1:45;
L335: ( succ ( ( IC D62 ) + R3 ) ) = ( ( succ ( IC D62 ) ) + R3 );
L336:
now
reconsider D63 = ( IC D61 ) as (Element of ( NAT ));
assume L337: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) );
L338: D63 in ( dom C59 ) by L313 , L316 , AMISTD_5:def 4;
L339: ( D63 + R3 ) in ( dom ( Reloc (C59 , R3) ) ) by L338 , COMPOS_1:46;
L340: ( ( Reloc (C59 , R3) ) . ( D63 + R3 ) ) = ( C62 . ( D63 + R3 ) ) by L339 , L316 , GRFUNC_1:2;
L341: ( C62 /. ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) ) = ( C62 . ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) ) by PBOOLE:143;
L342: ( CurInstr (C61 , D61) ) = ( C61 . D63 ) by PBOOLE:143
.= ( C59 . D63 ) by L338 , L316 , GRFUNC_1:2;
thus L343: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L342 , L337 , L338 , L340 , L341 , COMPOS_1:35;
end;
L344: ( dom D60 ) = (the carrier of ( SCM R7 )) by PARTFUN1:def 2;
L345: ( dom D60 ) = ( { ( IC ( SCM R7 ) ) } \/ ( Data-Locations ( SCM R7 ) ) ) by L344 , XBOOLE_1:45;
L346: ( dom D57 ) = ( ( dom C60 ) /\ ( Data-Locations ( SCM R7 ) ) ) by RELAT_1:61;
L347: ( dom D57 ) c= ( { ( IC ( SCM R7 ) ) } \/ ( Data-Locations ( SCM R7 ) ) ) by L346 , XBOOLE_1:10 , XBOOLE_1:17;
set D64 = ( Comput (C61 , D56 , ( C63 + 1 )) );
L348: ( dom ( DataPart D60 ) ) = ( Data-Locations ( SCM R7 ) ) by MEMSTR_0:9;
L349: ( dom ( DataPart D64 ) ) = ( Data-Locations ( SCM R7 ) ) by MEMSTR_0:9;
L350: ( dom ( DataPart D64 ) ) c= ( dom ( DataPart D58 ) ) by L349 , MEMSTR_0:9;
L351: ( dom ( DataPart D58 ) ) = ( Data-Locations ( SCM R7 ) ) by MEMSTR_0:9;
L352:
now
let C67 being set;
assume that
L353: C67 in ( dom ( DataPart D64 ) )
and
L354: ( D64 . C67 ) = ( D58 . C67 );
thus L355: ( ( DataPart D64 ) . C67 ) = ( D58 . C67 ) by L353 , L354 , FUNCT_1:47
.= ( ( DataPart D58 ) . C67 ) by L349 , L351 , L353 , FUNCT_1:47;
end;
L356: ( dom ( DataPart D59 ) ) = ( Data-Locations ( SCM R7 ) ) by MEMSTR_0:9;
L357:
now
let C68 being set;
assume that
L358: C68 in ( dom ( DataPart D64 ) )
and
L359: (( D64 . C68 ) = ( D59 . C68 ) & ( D58 . C68 ) = ( D60 . C68 ));
L360: ( ( DataPart D59 ) . C68 ) = ( D59 . C68 ) by L356 , L349 , L358 , FUNCT_1:47;
thus L361: ( ( DataPart D64 ) . C68 ) = ( ( DataPart D58 ) . C68 ) by L360 , L325 , L348 , L349 , L352 , L358 , L359 , FUNCT_1:47;
end;
L362: ( dom D62 ) = (the carrier of ( SCM R7 )) by PARTFUN1:def 2;
L363: ( dom D62 ) = ( { ( IC ( SCM R7 ) ) } \/ ( Data-Locations ( SCM R7 ) ) ) by L362 , XBOOLE_1:45;
L364: ( dom D58 ) = (the carrier of ( SCM R7 )) by PARTFUN1:def 2;
L365: ( dom D58 ) = ( { ( IC ( SCM R7 ) ) } \/ ( Data-Locations ( SCM R7 ) ) ) by L364 , XBOOLE_1:45;
set D65 = ( CurInstr (C61 , D62) );
L366: D61 = ( Following (C61 , D62) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C61 , D62) ) , D62) );
L367: ( dom ( D62 | ( dom D57 ) ) ) = ( ( dom D62 ) /\ ( dom D57 ) ) by RELAT_1:61
.= ( dom D57 ) by L363 , L347 , XBOOLE_1:28;
L368: ( dom ( D61 | ( dom D57 ) ) ) = ( ( dom D61 ) /\ ( dom D57 ) ) by RELAT_1:61
.= ( dom D57 ) by L334 , L347 , XBOOLE_1:28;
L369: ( dom ( D58 | ( dom ( DataPart C60 ) ) ) ) = ( ( dom D58 ) /\ ( dom D57 ) ) by RELAT_1:61
.= ( dom D57 ) by L365 , L347 , XBOOLE_1:28;
L370: ( dom ( D61 | ( dom D57 ) ) ) c= ( dom ( D58 | ( dom D57 ) ) ) by L369 , L368;
L371: ( dom ( D60 | ( dom ( DataPart C60 ) ) ) ) = ( ( dom D60 ) /\ ( dom D57 ) ) by RELAT_1:61
.= ( dom D57 ) by L345 , L347 , XBOOLE_1:28;
L372:
now
let C69 being set;
let C70 being (Data-Location of R7);
assume that
L373: C70 = C69
and
L374: C70 in ( dom D57 )
and
L375: (( D61 . C70 ) = ( D62 . C70 ) & ( D58 . C70 ) = ( D60 . C70 ));
L376: (( ( D62 | ( dom D57 ) ) . C70 ) = ( D62 . C70 ) & ( ( D60 | ( dom D57 ) ) . C70 ) = ( D60 . C70 )) by L367 , L371 , L374 , FUNCT_1:47;
thus L377: ( ( D61 | ( dom D57 ) ) . C69 ) = ( D61 . C70 ) by L368 , L373 , L374 , FUNCT_1:47
.= ( ( D58 | ( dom D57 ) ) . C69 ) by L324 , L369 , L373 , L374 , L375 , L376 , FUNCT_1:47;
end;
L378:
now
let C71 being set;
let C72 being (Data-Location of R7);
assume that
L379: (C72 = C71 & C72 in ( dom D57 ))
and
L380: ( D61 . C72 ) = ( D58 . C72 );
thus L381: ( ( D61 | ( dom D57 ) ) . C71 ) = ( D58 . C72 ) by L368 , L379 , L380 , FUNCT_1:47
.= ( ( D58 | ( dom D57 ) ) . C71 ) by L369 , L379 , FUNCT_1:47;
end;
L382: D64 = ( Following (C61 , D59) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (C61 , D62) ) , D59) ) by L313 , L320 , L316 , AMISTD_5:7;
per cases  by NAT_1:31 , SCMRING3:39;
suppose L383: ( InsCode D65 ) = ( 0 );

L384: D65 = ( halt ( SCM R7 ) ) by L383 , SCMRING3:12;
thus L385: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( ( IC D62 ) + R3 ) by L384 , L366 , EXTPRO_1:def 3
.= ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L322 , L323 , L326 , L384 , EXTPRO_1:def 3;
thus L386: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L385 , L336;
L387: D58 = D60 by L323 , L326 , L384 , EXTPRO_1:def 3;
thus L388: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L387 , L324 , L366 , L384 , EXTPRO_1:def 3;
thus L389: thesis by L325 , L382 , L384 , L387 , EXTPRO_1:def 3;
end;
suppose L390: ( InsCode D65 ) = 1;

consider C73 , C74 being (Data-Location of R7) such that L391: D65 = ( C73 := C74 ) by L390 , SCMRING3:13;
L392: ( IncAddr (D65 , R3) ) = ( C73 := C74 ) by L391 , COMPOS_0:4;
L393: ( ( Exec (D65 , D62) ) . ( IC ( SCM R7 ) ) ) = ( succ ( IC D62 ) ) by L391 , SCMRING2:11;
thus L394: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L393 , L322 , L323 , L366 , L326 , L335 , L392 , SCMRING2:11;
thus L395: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L322 , L323 , L336 , L366 , L326 , L335 , L392 , L393 , SCMRING2:11;
L396: ( D59 . C74 ) = ( D60 . C74 ) by L330;
L397:
now
L398: D57 c= C60 by RELAT_1:59;
L399: ( dom D57 ) c= ( dom C60 ) by L398 , GRFUNC_1:2;
let C75 being set;
assume L400: C75 in ( dom ( D61 | ( dom D57 ) ) );
L401: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D66 = C75 as (Data-Location of R7) by L401 , L368 , L400 , SCMRING2:23;
per cases ;
suppose L402: C73 = D66;

L403: (( D61 . D66 ) = ( D62 . C74 ) & ( D58 . D66 ) = ( D60 . C74 )) by L402 , L323 , L366 , L326 , L391 , L392 , SCMRING2:11;
thus L404: ( ( D61 | ( dom D57 ) ) . C75 ) = ( ( D58 | ( dom D57 ) ) . C75 ) by L403 , L313 , L320 , L368 , L378 , L391 , L396 , L400 , L399 , L402 , L244 , L316;
end;
suppose L405: C73 <> D66;

L406: (( D61 . D66 ) = ( D62 . D66 ) & ( D58 . D66 ) = ( D60 . D66 )) by L405 , L323 , L366 , L326 , L391 , L392 , SCMRING2:11;
thus L407: ( ( D61 | ( dom D57 ) ) . C75 ) = ( ( D58 | ( dom D57 ) ) . C75 ) by L406 , L368 , L372 , L400;
end;
end;
L409: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L397 , L370 , GRFUNC_1:2;
thus L410: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L409 , L368 , L369 , GRFUNC_1:3;
L411:
now
let C76 being set;
assume L412: C76 in ( dom ( DataPart D64 ) );
reconsider D67 = C76 as (Data-Location of R7) by L412 , L349 , SCMRING2:23;
per cases ;
suppose L413: C73 = D67;

L414: (( D58 . D67 ) = ( D60 . C74 ) & ( D64 . D67 ) = ( D59 . C74 )) by L413 , L323 , L326 , L382 , L391 , L392 , SCMRING2:11;
thus L415: ( ( DataPart D64 ) . C76 ) = ( ( DataPart D58 ) . C76 ) by L414 , L330 , L352 , L412;
end;
suppose L416: C73 <> D67;

L417: (( D64 . D67 ) = ( D59 . D67 ) & ( D58 . D67 ) = ( D60 . D67 )) by L416 , L323 , L326 , L382 , L391 , L392 , SCMRING2:11;
thus L418: ( ( DataPart D64 ) . C76 ) = ( ( DataPart D58 ) . C76 ) by L417 , L357 , L412;
end;
end;
L420: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L411 , L350 , GRFUNC_1:2;
thus L421: thesis by L420 , L349 , L351 , GRFUNC_1:3;
end;
suppose L422: ( InsCode D65 ) = 2;

consider C77 , C78 being (Data-Location of R7) such that L423: D65 = ( AddTo (C77 , C78) ) by L422 , SCMRING3:14;
L424: ( IncAddr (D65 , R3) ) = ( AddTo (C77 , C78) ) by L423 , COMPOS_0:4;
L425: ( ( Exec (D65 , D62) ) . ( IC ( SCM R7 ) ) ) = ( succ ( IC D62 ) ) by L423 , SCMRING2:12;
thus L426: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L425 , L322 , L323 , L366 , L326 , L335 , L424 , SCMRING2:12;
thus L427: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L322 , L323 , L336 , L366 , L326 , L335 , L424 , L425 , SCMRING2:12;
L428: (( D59 . C77 ) = ( D60 . C77 ) & ( D59 . C78 ) = ( D60 . C78 )) by L330;
L429:
now
L430: D57 c= C60 by RELAT_1:59;
L431: ( dom D57 ) c= ( dom C60 ) by L430 , GRFUNC_1:2;
let C79 being set;
assume that
L432: C79 in ( dom ( D61 | ( dom D57 ) ) );
L433: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D68 = C79 as (Data-Location of R7) by L433 , L368 , L432 , SCMRING2:23;
per cases ;
suppose L434: C77 = D68;

L435: (( D61 . D68 ) = ( ( D62 . C77 ) + ( D62 . C78 ) ) & ( D58 . D68 ) = ( ( D60 . C77 ) + ( D60 . C78 ) )) by L434 , L323 , L366 , L326 , L423 , L424 , SCMRING2:12;
thus L436: ( ( D61 | ( dom D57 ) ) . C79 ) = ( ( D58 | ( dom D57 ) ) . C79 ) by L435 , L313 , L320 , L368 , L378 , L423 , L428 , L432 , L431 , L434 , L256 , L316;
end;
suppose L437: C77 <> D68;

L438: (( D61 . D68 ) = ( D62 . D68 ) & ( D58 . D68 ) = ( D60 . D68 )) by L437 , L323 , L366 , L326 , L423 , L424 , SCMRING2:12;
thus L439: ( ( D61 | ( dom D57 ) ) . C79 ) = ( ( D58 | ( dom D57 ) ) . C79 ) by L438 , L368 , L372 , L432;
end;
end;
L441: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L429 , L370 , GRFUNC_1:2;
thus L442: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L441 , L368 , L369 , GRFUNC_1:3;
L443:
now
let C80 being set;
assume L444: C80 in ( dom ( DataPart D64 ) );
reconsider D69 = C80 as (Data-Location of R7) by L444 , L349 , SCMRING2:23;
per cases ;
suppose L445: C77 = D69;

L446: (( D58 . D69 ) = ( ( D60 . C77 ) + ( D60 . C78 ) ) & ( D64 . D69 ) = ( ( D59 . C77 ) + ( D59 . C78 ) )) by L445 , L323 , L326 , L382 , L423 , L424 , SCMRING2:12;
thus L447: ( ( DataPart D64 ) . C80 ) = ( ( DataPart D58 ) . C80 ) by L446 , L352 , L428 , L444;
end;
suppose L448: C77 <> D69;

L449: (( D64 . D69 ) = ( D59 . D69 ) & ( D58 . D69 ) = ( D60 . D69 )) by L448 , L323 , L326 , L382 , L423 , L424 , SCMRING2:12;
thus L450: ( ( DataPart D64 ) . C80 ) = ( ( DataPart D58 ) . C80 ) by L449 , L357 , L444;
end;
end;
L452: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L443 , L350 , GRFUNC_1:2;
thus L453: thesis by L452 , L349 , L351 , GRFUNC_1:3;
end;
suppose L454: ( InsCode D65 ) = 3;

consider C81 , C82 being (Data-Location of R7) such that L455: D65 = ( SubFrom (C81 , C82) ) by L454 , SCMRING3:15;
L456: ( IncAddr (D65 , R3) ) = ( SubFrom (C81 , C82) ) by L455 , COMPOS_0:4;
L457: ( ( Exec (D65 , D62) ) . ( IC ( SCM R7 ) ) ) = ( succ ( IC D62 ) ) by L455 , SCMRING2:13;
thus L458: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L457 , L322 , L323 , L366 , L326 , L335 , L456 , SCMRING2:13;
thus L459: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L322 , L323 , L336 , L366 , L326 , L335 , L456 , L457 , SCMRING2:13;
L460: (( D59 . C81 ) = ( D60 . C81 ) & ( D59 . C82 ) = ( D60 . C82 )) by L330;
L461:
now
L462: D57 c= C60 by RELAT_1:59;
L463: ( dom D57 ) c= ( dom C60 ) by L462 , GRFUNC_1:2;
let C83 being set;
assume that
L464: C83 in ( dom ( D61 | ( dom D57 ) ) );
L465: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D70 = C83 as (Data-Location of R7) by L465 , L368 , L464 , SCMRING2:23;
per cases ;
suppose L466: C81 = D70;

L467: (( D61 . D70 ) = ( ( D62 . C81 ) - ( D62 . C82 ) ) & ( D58 . D70 ) = ( ( D60 . C81 ) - ( D60 . C82 ) )) by L466 , L323 , L366 , L326 , L455 , L456 , SCMRING2:13;
thus L468: ( ( D61 | ( dom D57 ) ) . C83 ) = ( ( D58 | ( dom D57 ) ) . C83 ) by L467 , L313 , L320 , L368 , L378 , L455 , L460 , L464 , L463 , L466 , L268 , L316;
end;
suppose L469: C81 <> D70;

L470: (( D61 . D70 ) = ( D62 . D70 ) & ( D58 . D70 ) = ( D60 . D70 )) by L469 , L323 , L366 , L326 , L455 , L456 , SCMRING2:13;
thus L471: ( ( D61 | ( dom D57 ) ) . C83 ) = ( ( D58 | ( dom D57 ) ) . C83 ) by L470 , L368 , L372 , L464;
end;
end;
L473: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L461 , L370 , GRFUNC_1:2;
thus L474: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L473 , L368 , L369 , GRFUNC_1:3;
L475:
now
let C84 being set;
assume L476: C84 in ( dom ( DataPart D64 ) );
reconsider D71 = C84 as (Data-Location of R7) by L476 , L349 , SCMRING2:23;
per cases ;
suppose L477: C81 = D71;

L478: (( D58 . D71 ) = ( ( D60 . C81 ) - ( D60 . C82 ) ) & ( D64 . D71 ) = ( ( D59 . C81 ) - ( D59 . C82 ) )) by L477 , L323 , L326 , L382 , L455 , L456 , SCMRING2:13;
thus L479: ( ( DataPart D64 ) . C84 ) = ( ( DataPart D58 ) . C84 ) by L478 , L352 , L460 , L476;
end;
suppose L480: C81 <> D71;

L481: (( D64 . D71 ) = ( D59 . D71 ) & ( D58 . D71 ) = ( D60 . D71 )) by L480 , L323 , L326 , L382 , L455 , L456 , SCMRING2:13;
thus L482: ( ( DataPart D64 ) . C84 ) = ( ( DataPart D58 ) . C84 ) by L481 , L357 , L476;
end;
end;
L484: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L475 , L350 , GRFUNC_1:2;
thus L485: thesis by L484 , L349 , L351 , GRFUNC_1:3;
end;
suppose L486: ( InsCode D65 ) = 4;

consider C85 , C86 being (Data-Location of R7) such that L487: D65 = ( MultBy (C85 , C86) ) by L486 , SCMRING3:16;
L488: ( IncAddr (D65 , R3) ) = ( MultBy (C85 , C86) ) by L487 , COMPOS_0:4;
L489: ( ( Exec (D65 , D62) ) . ( IC ( SCM R7 ) ) ) = ( succ ( IC D62 ) ) by L487 , SCMRING2:14;
thus L490: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L489 , L322 , L323 , L366 , L326 , L335 , L488 , SCMRING2:14;
thus L491: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L322 , L323 , L336 , L366 , L326 , L335 , L488 , L489 , SCMRING2:14;
L492: (( D59 . C85 ) = ( D60 . C85 ) & ( D59 . C86 ) = ( D60 . C86 )) by L330;
L493:
now
L494: D57 c= C60 by RELAT_1:59;
L495: ( dom D57 ) c= ( dom C60 ) by L494 , GRFUNC_1:2;
let C87 being set;
assume that
L496: C87 in ( dom ( D61 | ( dom D57 ) ) );
L497: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D72 = C87 as (Data-Location of R7) by L497 , L368 , L496 , SCMRING2:23;
per cases ;
suppose L498: C85 = D72;

L499: (( D61 . D72 ) = ( ( D62 . C85 ) * ( D62 . C86 ) ) & ( D58 . D72 ) = ( ( D60 . C85 ) * ( D60 . C86 ) )) by L498 , L323 , L366 , L326 , L487 , L488 , SCMRING2:14;
thus L500: ( ( D61 | ( dom D57 ) ) . C87 ) = ( ( D58 | ( dom D57 ) ) . C87 ) by L499 , L313 , L320 , L368 , L378 , L487 , L492 , L496 , L495 , L498 , L280 , L316;
end;
suppose L501: C85 <> D72;

L502: (( D61 . D72 ) = ( D62 . D72 ) & ( D58 . D72 ) = ( D60 . D72 )) by L501 , L323 , L366 , L326 , L487 , L488 , SCMRING2:14;
thus L503: ( ( D61 | ( dom D57 ) ) . C87 ) = ( ( D58 | ( dom D57 ) ) . C87 ) by L502 , L368 , L372 , L496;
end;
end;
L505: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L493 , L370 , GRFUNC_1:2;
thus L506: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L505 , L368 , L369 , GRFUNC_1:3;
L507:
now
let C88 being set;
assume L508: C88 in ( dom ( DataPart D64 ) );
reconsider D73 = C88 as (Data-Location of R7) by L508 , L349 , SCMRING2:23;
per cases ;
suppose L509: C85 = D73;

L510: (( D58 . D73 ) = ( ( D60 . C85 ) * ( D60 . C86 ) ) & ( D64 . D73 ) = ( ( D59 . C85 ) * ( D59 . C86 ) )) by L509 , L323 , L326 , L382 , L487 , L488 , SCMRING2:14;
thus L511: ( ( DataPart D64 ) . C88 ) = ( ( DataPart D58 ) . C88 ) by L510 , L352 , L492 , L508;
end;
suppose L512: C85 <> D73;

L513: (( D64 . D73 ) = ( D59 . D73 ) & ( D58 . D73 ) = ( D60 . D73 )) by L512 , L323 , L326 , L382 , L487 , L488 , SCMRING2:14;
thus L514: ( ( DataPart D64 ) . C88 ) = ( ( DataPart D58 ) . C88 ) by L513 , L357 , L508;
end;
end;
L516: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L507 , L350 , GRFUNC_1:2;
thus L517: thesis by L516 , L349 , L351 , GRFUNC_1:3;
end;
suppose L518: ( InsCode D65 ) = 5;

consider C89 being (Data-Location of R7), C90 being (Element of R7) such that L519: D65 = ( C89 := C90 ) by L518 , SCMRING3:17;
L520: ( IncAddr (D65 , R3) ) = ( C89 := C90 ) by L519 , COMPOS_0:4;
L521: ( ( Exec (D65 , D62) ) . ( IC ( SCM R7 ) ) ) = ( succ ( IC D62 ) ) by L519 , SCMRING2:17;
thus L522: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L521 , L322 , L323 , L366 , L326 , L335 , L520 , SCMRING2:17;
thus L523: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L322 , L323 , L336 , L366 , L326 , L335 , L520 , L521 , SCMRING2:17;
L524:
now
let C91 being set;
assume L525: C91 in ( dom ( D61 | ( dom D57 ) ) );
L526: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D74 = C91 as (Data-Location of R7) by L526 , L368 , L525 , SCMRING2:23;
per cases ;
suppose L527: C89 = D74;

thus L528: ( ( D61 | ( dom D57 ) ) . C91 ) = ( D61 . D74 ) by L368 , L525 , FUNCT_1:49
.= C90 by L366 , L519 , L527 , SCMRING2:17
.= ( D58 . D74 ) by L323 , L326 , L520 , L527 , SCMRING2:17
.= ( ( D58 | ( dom D57 ) ) . C91 ) by L368 , L525 , FUNCT_1:49;
end;
suppose L529: C89 <> D74;

L530: (( D61 . D74 ) = ( D62 . D74 ) & ( D58 . D74 ) = ( D60 . D74 )) by L529 , L323 , L366 , L326 , L519 , L520 , SCMRING2:17;
thus L531: ( ( D61 | ( dom D57 ) ) . C91 ) = ( ( D58 | ( dom D57 ) ) . C91 ) by L530 , L368 , L372 , L525;
end;
end;
L533: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L524 , L370 , GRFUNC_1:2;
thus L534: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L533 , L368 , L369 , GRFUNC_1:3;
L535:
now
let C92 being set;
assume L536: C92 in ( dom ( DataPart D64 ) );
reconsider D75 = C92 as (Data-Location of R7) by L536 , L349 , SCMRING2:23;
per cases ;
suppose L537: C89 = D75;

L538: (( D58 . D75 ) = C90 & ( D64 . D75 ) = C90) by L537 , L323 , L326 , L382 , L519 , L520 , SCMRING2:17;
thus L539: ( ( DataPart D64 ) . C92 ) = ( ( DataPart D58 ) . C92 ) by L538 , L352 , L536;
end;
suppose L540: C89 <> D75;

L541: (( D64 . D75 ) = ( D59 . D75 ) & ( D58 . D75 ) = ( D60 . D75 )) by L540 , L323 , L326 , L382 , L519 , L520 , SCMRING2:17;
thus L542: ( ( DataPart D64 ) . C92 ) = ( ( DataPart D58 ) . C92 ) by L541 , L357 , L536;
end;
end;
L544: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L535 , L350 , GRFUNC_1:2;
thus L545: thesis by L544 , L349 , L351 , GRFUNC_1:3;
end;
suppose L546: ( InsCode D65 ) = 6;

consider C93 being (Element of ( NAT )) such that L547: D65 = ( goto (C93 , R7) ) by L546 , SCMRING3:18;
L548: ( CurInstr (C62 , D60) ) = ( goto (( C93 + R3 ) , R7) ) by L323 , L547 , SCMRING3:37;
thus L549: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( C93 + R3 ) by L366 , L547 , SCMRING2:15
.= ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L326 , L548 , SCMRING2:15;
thus L550: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) ) by L549 , L336;
L551:
now
let C94 being set;
assume that
L552: C94 in ( dom ( D61 | ( dom D57 ) ) );
L553: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D76 = C94 as (Data-Location of R7) by L553 , L368 , L552 , SCMRING2:23;
L554: (( D61 . D76 ) = ( D62 . D76 ) & ( D58 . D76 ) = ( D60 . D76 )) by L366 , L326 , L547 , L548 , SCMRING2:15;
thus L555: ( ( D61 | ( dom D57 ) ) . C94 ) = ( ( D58 | ( dom D57 ) ) . C94 ) by L554 , L368 , L372 , L552;
end;
L556: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L551 , L370 , GRFUNC_1:2;
thus L557: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L556 , L368 , L369 , GRFUNC_1:3;
L558:
now
let C95 being set;
assume L559: C95 in ( dom ( DataPart D64 ) );
reconsider D77 = C95 as (Data-Location of R7) by L559 , L349 , SCMRING2:23;
L560: (( D64 . D77 ) = ( D59 . D77 ) & ( D58 . D77 ) = ( D60 . D77 )) by L326 , L382 , L547 , L548 , SCMRING2:15;
thus L561: ( ( DataPart D64 ) . C95 ) = ( ( DataPart D58 ) . C95 ) by L560 , L357 , L559;
end;
L562: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L558 , L350 , GRFUNC_1:2;
thus L563: thesis by L562 , L349 , L351 , GRFUNC_1:3;
end;
suppose L564: ( InsCode D65 ) = 7;

consider C96 being (Data-Location of R7), C97 being (Element of ( NAT )) such that L565: D65 = ( C96 =0_goto C97 ) by L564 , SCMRING3:19;
L566:
now
per cases ;
case L567: ( D62 . C96 ) = ( 0. R7 );
thus L568: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( C97 + R3 ) by L567 , L366 , L565 , SCMRING2:16;
end;
case L569: ( D62 . C96 ) <> ( 0. R7 );
thus L570: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( succ ( IC D60 ) ) by L569 , L322 , L366 , L335 , L565 , SCMRING2:16;
end;
end;
L572: ( CurInstr (C62 , D60) ) = ( C96 =0_goto ( C97 + R3 ) ) by L323 , L565 , SCMRING3:38;
L573:
now
per cases ;
case L574: ( D60 . C96 ) = ( 0. R7 );
thus L575: ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) = ( C97 + R3 ) by L574 , L326 , L572 , SCMRING2:16;
end;
case L576: ( D60 . C96 ) <> ( 0. R7 );
thus L577: ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) = ( succ ( IC D60 ) ) by L576 , L326 , L572 , SCMRING2:16;
end;
end;
L579: ( D59 . C96 ) = ( D60 . C96 ) by L330;
L580:
now
per cases ;
suppose L581: C97 <> ( succ ( IC D62 ) );

thus L582: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L581 , L313 , L320 , L565 , L579 , L566 , L573 , L292 , L316;
end;
suppose L583: C97 = ( succ ( IC D62 ) );

thus L584: ( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L583 , L322 , L566 , L573;
end;
end;
thus L586: (( ( IC ( Comput (C61 , R14 , ( C63 + 1 )) ) ) + R3 ) = ( IC ( Comput (C62 , R15 , ( C63 + 1 )) ) ) & ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( C63 + 1 )) )) ) , R3) ) = ( CurInstr (C62 , ( Comput (C62 , R15 , ( C63 + 1 )) )) )) by L580 , L336;
L587:
now
let C98 being set;
assume that
L588: C98 in ( dom ( D61 | ( dom D57 ) ) );
L589: ( dom D57 ) c= ( Data-Locations ( SCM R7 ) ) by RELAT_1:58;
reconsider D78 = C98 as (Data-Location of R7) by L589 , L368 , L588 , SCMRING2:23;
L590: (( D61 . D78 ) = ( D62 . D78 ) & ( D58 . D78 ) = ( D60 . D78 )) by L366 , L326 , L565 , L572 , SCMRING2:16;
thus L591: ( ( D61 | ( dom D57 ) ) . C98 ) = ( ( D58 | ( dom D57 ) ) . C98 ) by L590 , L368 , L372 , L588;
end;
L592: ( D61 | ( dom D57 ) ) c= ( D58 | ( dom D57 ) ) by L587 , L370 , GRFUNC_1:2;
thus L593: ( ( Comput (C61 , R14 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) = ( ( Comput (C62 , R15 , ( C63 + 1 )) ) | ( dom ( DataPart C60 ) ) ) by L592 , L368 , L369 , GRFUNC_1:3;
L594:
now
let C99 being set;
assume L595: C99 in ( dom ( DataPart D64 ) );
reconsider D79 = C99 as (Data-Location of R7) by L595 , L349 , SCMRING2:23;
L596: (( D64 . D79 ) = ( D59 . D79 ) & ( D58 . D79 ) = ( D60 . D79 )) by L326 , L382 , L565 , L572 , SCMRING2:16;
thus L597: ( ( DataPart D64 ) . C99 ) = ( ( DataPart D58 ) . C99 ) by L596 , L357 , L595;
end;
L598: ( DataPart D64 ) c= ( DataPart ( Comput (C62 , R15 , ( C63 + 1 )) ) ) by L594 , L350 , GRFUNC_1:2;
thus L599: thesis by L598 , L349 , L351 , GRFUNC_1:3;
end;
end;
L601: ( DataPart C60 ) c= C60 by RELAT_1:59;
L602: ( DataPart ( IncIC (C60 , R3) ) ) = ( DataPart C60 ) by MEMSTR_0:51;
L603: ( DataPart C60 ) c= ( IncIC (C60 , R3) ) by L602 , MEMSTR_0:12;
L604: ( ( Comput (C61 , R14 , ( 0 )) ) | ( dom ( DataPart C60 ) ) ) = ( R14 | ( dom ( DataPart C60 ) ) )
.= ( DataPart C60 ) by L313 , L601 , GRFUNC_1:23 , XBOOLE_1:1
.= ( R15 | ( dom ( DataPart C60 ) ) ) by L603 , L314 , GRFUNC_1:23 , XBOOLE_1:1
.= ( ( Comput (C62 , R15 , ( 0 )) ) | ( dom ( DataPart C60 ) ) );
L605: ( DataPart ( Comput (C61 , D56 , ( 0 )) ) ) = ( DataPart ( R14 +* ( DataPart R15 ) ) )
.= ( DataPart R15 ) by PBOOLE:142
.= ( DataPart ( Comput (C62 , R15 , ( 0 )) ) );
L606: ( IC ( SCM R7 ) ) in ( dom ( IncIC (C60 , R3) ) ) by MEMSTR_0:52;
L607: ( ( IC ( Comput (C61 , R14 , ( 0 )) ) ) + R3 ) = ( ( IC R14 ) + R3 )
.= ( ( IC C60 ) + R3 ) by L313 , L315 , GRFUNC_1:2
.= ( ( IC C60 ) + R3 )
.= ( IC ( IncIC (C60 , R3) ) ) by MEMSTR_0:53
.= ( IC R15 ) by L314 , L606 , GRFUNC_1:2
.= ( IC ( Comput (C62 , R15 , ( 0 )) ) );
L608: ( IC ( SCM R7 ) ) in ( dom ( IncIC (C60 , R3) ) ) by MEMSTR_0:52;
L609: ( ( IC C60 ) + R3 ) in ( dom ( Reloc (C59 , R3) ) ) by L319 , COMPOS_1:46;
L610: ( C62 /. ( IC R15 ) ) = ( C62 . ( IC R15 ) ) by PBOOLE:143;
L611: ( CurInstr (C62 , ( Comput (C62 , R15 , ( 0 )) )) ) = ( C62 . ( IC R15 ) ) by L610
.= ( C62 . ( IC ( IncIC (C60 , R3) ) ) ) by L314 , L608 , GRFUNC_1:2
.= ( C62 . ( ( IC C60 ) + R3 ) ) by MEMSTR_0:53
.= ( C62 . ( ( IC C60 ) + R3 ) )
.= ( ( Reloc (C59 , R3) ) . ( ( IC C60 ) + R3 ) ) by L609 , L316 , GRFUNC_1:2;
L612: ( C59 . ( IC C60 ) ) = ( C61 . ( IC R14 ) ) by L317 , L319 , L316 , GRFUNC_1:2;
L613: ( CurInstr (C61 , R14) ) = ( C59 . ( IC C60 ) ) by L612 , PBOOLE:143;
L614: ( IncAddr (( CurInstr (C61 , ( Comput (C61 , R14 , ( 0 )) )) ) , R3) ) = ( IncAddr (( CurInstr (C61 , R14) ) , R3) )
.= ( CurInstr (C62 , ( Comput (C62 , R15 , ( 0 )) )) ) by L611 , L319 , L613 , COMPOS_1:35;
L615: S1[ (( 0 ) qua (Element of ( NAT ))) ] by L607 , L614 , L604 , L605;
L616: (for R4 being (Element of ( NAT )) holds S1[ R4 ]) from NAT_1:sch 1(L615 , L321);
thus L617: thesis by L616;
end;
registration
let C100 being non  trivial Ring;
cluster ( SCM C100 ) ->  relocable1  relocable2;
coherence
proof
thus L618: ( SCM C100 ) is  relocable1
proof
thus L619: (for B28 being (Element of ( NAT )) holds (for B29 being non  halt-free  finite (the InstructionsF of ( SCM C100 )) -valued ( NAT ) -defined Function holds (for B30 being B29 -autonomic non  empty (FinPartState of ( SCM C100 )) holds (for B31 , B32 being (State of ( SCM C100 )) holds ((B30 c= B31 & ( IncIC (B30 , B28) ) c= B32) implies (for B33 , B34 being (Instruction-Sequence of ( SCM C100 )) holds ((B29 c= B33 & ( Reloc (B29 , B28) ) c= B34) implies (for B35 being (Element of ( NAT )) holds ( IncAddr (( CurInstr (B33 , ( Comput (B33 , B31 , B35) )) ) , B28) ) = ( CurInstr (B34 , ( Comput (B34 , B32 , B35) )) ))))))))) by L312;
end;

let C101 being (Element of ( NAT ));
let C102 being non  halt-free  finite (the InstructionsF of ( SCM C100 )) -valued ( NAT ) -defined Function;
let C103 being C102 -autonomic non  empty (FinPartState of ( SCM C100 ));
let C104 , C105 being (State of ( SCM C100 ));
assume L620: (C103 c= C104 & ( IncIC (C103 , C101) ) c= C105);
let C106 , C107 being (Instruction-Sequence of ( SCM C100 ));
assume L621: (C102 c= C106 & ( Reloc (C102 , C101) ) c= C107);
thus L622: (for B36 being (Element of ( NAT )) holds ( ( Comput (C106 , C104 , B36) ) | ( dom ( DataPart C103 ) ) ) = ( ( Comput (C107 , C105 , B36) ) | ( dom ( DataPart C103 ) ) )) by L621 , L620 , L312;
end;
end;
