:: Full Subtracter Circuit. Part {II}
::  by Shin'nosuke Yamaguchi , Grzegorz Bancerek and Katsumi Wasaki
::
:: Received February 25, 2003
:: Copyright (c) 2003-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, FINSEQ_1, FSCIRC_1, FUNCT_1, ARYTM_3, XBOOLE_0,
      MSUALG_1, FUNCT_4, CIRCCOMB, CARD_1, FINSEQ_2, MARGREL1, FUNCOP_1,
      XBOOLEAN, STRUCT_0, PBOOLE, LATTICES, CIRCUIT1, RELAT_1, SUBSET_1,
      MSAFREE2, ORDINAL4, XXREAL_0, TARSKI, TWOSCOMP, PARTFUN1, FACIRC_1,
      CLASSES1, MCART_1, FSM_1, CIRCUIT2, GLIB_000, FSCIRC_2;
 notations TARSKI, XBOOLE_0, ENUMSET1,
      XTUPLE_0, SUBSET_1, CARD_1, NUMBERS, ORDINAL1,
      NAT_1, MCART_1, RELAT_1, STRUCT_0, FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      PBOOLE, MARGREL1, BINARITH, CLASSES1, MSUALG_1, MSAFREE2, CIRCUIT1,
      CIRCUIT2, CIRCCOMB, TWOSCOMP, FACIRC_1, FACIRC_2, FSCIRC_1, XXREAL_0;
 constructors ENUMSET1, CLASSES1, BINARITH, CIRCUIT1, CIRCUIT2, TWOSCOMP,
      FSCIRC_1, NAT_1, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, XXREAL_0, XREAL_0, NAT_1,
      FINSEQ_1, MARGREL1, FINSEQ_2, CARD_3, STRUCT_0, CIRCCOMB, FACIRC_1,
      CIRCCMB2, FACIRC_2, MSAFREE2, FINSET_1, CARD_1, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, CIRCUIT2, FACIRC_1, XBOOLE_0, MSAFREE2, FSCIRC_1,
      MARGREL1, XTUPLE_0;
 theorems TARSKI, ZFMISC_1, ENUMSET1, MCART_1, NAT_1, ORDINAL1,
      FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_6, PBOOLE, CIRCUIT2, CIRCCOMB,
      FACIRC_1, CIRCCMB2, CIRCUIT1, TWOSCOMP, FSCIRC_1, FACIRC_2, FUNCOP_1,
      XBOOLE_0, XBOOLE_1, FINSEQ_2, XREAL_1, CLASSES1, PARTFUN1, CARD_1,
      XTUPLE_0, XREGULAR;
 schemes NAT_1, CIRCCMB2, PBOOLE;

begin
definition
let C1 being Nat;
let C2 , C3 being FinSequence;
deffunc H1(set , Nat) = ( BorrowOutput (( C2 . ( $2 + 1 ) ) , ( C3 . ( $2 + 1 ) ) , $1) );
deffunc H2(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitSubtracterWithBorrowStr (( C2 . ( $3 + 1 ) ) , ( C3 . ( $3 + 1 ) ) , $2) ) );
L1: ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict;
func C1 -BitSubtracterStr (C2 , C3) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign means 
:L2: (ex B1 , B2 being (ManySortedSet of ( NAT )) st (it = ( B1 . C1 ) & ( B1 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B2 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B3 being Nat holds (for B4 being non  empty ManySortedSign holds (for B5 being set holds ((B4 = ( B1 . B3 ) & B5 = ( B2 . B3 )) implies (( B1 . ( B3 + 1 ) ) = ( B4 +* ( BitSubtracterWithBorrowStr (( C2 . ( B3 + 1 ) ) , ( C3 . ( B3 + 1 ) ) , B5) ) ) & ( B2 . ( B3 + 1 ) ) = ( BorrowOutput (( C2 . ( B3 + 1 ) ) , ( C3 . ( B3 + 1 ) ) , B5) ))))))));
uniqueness
proof
L3: (for B6 , B7 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign holds (((ex B8 , B9 being (ManySortedSet of ( NAT )) st (B6 = ( B8 . C1 ) & ( B8 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B9 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B10 being Nat holds (for B11 being non  empty ManySortedSign holds (for B12 being set holds ((B11 = ( B8 . B10 ) & B12 = ( B9 . B10 )) implies (( B8 . ( B10 + 1 ) ) = H2(B11 , B12 , B10) & ( B9 . ( B10 + 1 ) ) = H1(B12 , B10)))))))) & (ex B13 , B14 being (ManySortedSet of ( NAT )) st (B7 = ( B13 . C1 ) & ( B13 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B14 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B15 being Nat holds (for B16 being non  empty ManySortedSign holds (for B17 being set holds ((B16 = ( B13 . B15 ) & B17 = ( B14 . B15 )) implies (( B13 . ( B15 + 1 ) ) = H2(B16 , B17 , B15) & ( B14 . ( B15 + 1 ) ) = H1(B17 , B15))))))))) implies B6 = B7)) from CIRCCMB2:sch 9;
thus L4: thesis by L3;
end;
existence
proof
deffunc H3(set , Nat) = ( BitSubtracterWithBorrowStr (( C2 . ( $2 + 1 ) ) , ( C3 . ( $2 + 1 ) ) , $1) );
L5: (ex B18 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty non  empty  strict ManySortedSign st (ex B19 , B20 being (ManySortedSet of ( NAT )) st (B18 = ( B19 . C1 ) & ( B19 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B20 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B21 being Nat holds (for B22 being non  empty ManySortedSign holds (for B23 being set holds ((B22 = ( B19 . B21 ) & B23 = ( B20 . B21 )) implies (( B19 . ( B21 + 1 ) ) = ( B22 +* H3(B23 , B21) ) & ( B20 . ( B21 + 1 ) ) = H1(B23 , B21))))))))) from CIRCCMB2:sch 8(L1);
thus L6: thesis by L5;
end;
end;
definition
let C4 being Nat;
let C5 , C6 being FinSequence;
func C4 -BitSubtracterCirc (C5 , C6) ->  Boolean  gate`2=den  strict (Circuit of ( C4 -BitSubtracterStr (C5 , C6) )) means 
:L8: (ex B24 , B25 , B26 being (ManySortedSet of ( NAT )) st (( C4 -BitSubtracterStr (C5 , C6) ) = ( B24 . C4 ) & it = ( B25 . C4 ) & ( B24 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B25 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B26 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B27 being Nat holds (for B28 being non  empty ManySortedSign holds (for B29 being  non-empty MSAlgebra over B28 holds (for B30 being set holds ((B28 = ( B24 . B27 ) & B29 = ( B25 . B27 ) & B30 = ( B26 . B27 )) implies (( B24 . ( B27 + 1 ) ) = ( B28 +* ( BitSubtracterWithBorrowStr (( C5 . ( B27 + 1 ) ) , ( C6 . ( B27 + 1 ) ) , B30) ) ) & ( B25 . ( B27 + 1 ) ) = ( B29 +* ( BitSubtracterWithBorrowCirc (( C5 . ( B27 + 1 ) ) , ( C6 . ( B27 + 1 ) ) , B30) ) ) & ( B26 . ( B27 + 1 ) ) = ( BorrowOutput (( C5 . ( B27 + 1 ) ) , ( C6 . ( B27 + 1 ) ) , B30) )))))))));
uniqueness
proof
set D1 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D2 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D3 = ( C4 -BitSubtracterStr (C5 , C6) );
set D4 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H4(set , Nat) = ( BorrowOutput (( C5 . ( $2 + 1 ) ) , ( C6 . ( $2 + 1 ) ) , $1) );
deffunc H5(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitSubtracterWithBorrowStr (( C5 . ( $3 + 1 ) ) , ( C6 . ( $3 + 1 ) ) , $2) ) );
deffunc H6(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitSubtracterWithBorrowCirc (( C5 . ( $4 + 1 ) ) , ( C6 . ( $4 + 1 ) ) , $3) ) );
L9: (for B31 being non  empty ManySortedSign holds (for B32 being  non-empty MSAlgebra over B31 holds (for B33 being set holds (for B34 being Nat holds H6(B31 , B32 , B33 , B34) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H5(B31 , B33 , B34)))));
thus L10: (for B35 , B36 being  Boolean  gate`2=den  strict (Circuit of D3) holds (((ex B37 , B38 , B39 being (ManySortedSet of ( NAT )) st (D3 = ( B37 . C4 ) & B35 = ( B38 . C4 ) & ( B37 . ( 0 ) ) = D1 & ( B38 . ( 0 ) ) = D2 & ( B39 . ( 0 ) ) = D4 & (for B40 being Nat holds (for B41 being non  empty ManySortedSign holds (for B42 being  non-empty MSAlgebra over B41 holds (for B43 being set holds ((B41 = ( B37 . B40 ) & B42 = ( B38 . B40 ) & B43 = ( B39 . B40 )) implies (( B37 . ( B40 + 1 ) ) = H5(B41 , B43 , B40) & ( B38 . ( B40 + 1 ) ) = H6(B41 , B42 , B43 , B40) & ( B39 . ( B40 + 1 ) ) = H4(B43 , B40))))))))) & (ex B44 , B45 , B46 being (ManySortedSet of ( NAT )) st (D3 = ( B44 . C4 ) & B36 = ( B45 . C4 ) & ( B44 . ( 0 ) ) = D1 & ( B45 . ( 0 ) ) = D2 & ( B46 . ( 0 ) ) = D4 & (for B47 being Nat holds (for B48 being non  empty ManySortedSign holds (for B49 being  non-empty MSAlgebra over B48 holds (for B50 being set holds ((B48 = ( B44 . B47 ) & B49 = ( B45 . B47 ) & B50 = ( B46 . B47 )) implies (( B44 . ( B47 + 1 ) ) = H5(B48 , B50 , B47) & ( B45 . ( B47 + 1 ) ) = H6(B48 , B49 , B50 , B47) & ( B46 . ( B47 + 1 ) ) = H4(B50 , B47)))))))))) implies B35 = B36)) from CIRCCMB2:sch 21(L9);
end;
existence
proof
set D5 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D6 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D7 = ( C4 -BitSubtracterStr (C5 , C6) );
set D8 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
deffunc H7(set , Nat) = ( BorrowOutput (( C5 . ( $2 + 1 ) ) , ( C6 . ( $2 + 1 ) ) , $1) );
deffunc H8(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitSubtracterWithBorrowStr (( C5 . ( $3 + 1 ) ) , ( C6 . ( $3 + 1 ) ) , $2) ) );
deffunc H9(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitSubtracterWithBorrowCirc (( C5 . ( $4 + 1 ) ) , ( C6 . ( $4 + 1 ) ) , $3) ) );
L11: (for B51 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B52 being set holds (for B53 being Nat holds H8(B51 , B52 , B53) is  unsplit  gate`1=arity  gate`2isBoolean non  void  strict)));
L12: (for B54 , B55 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B56 being  Boolean  gate`2=den  strict (Circuit of B54) holds (for B57 being set holds (for B58 being Nat holds (B55 = H8(B54 , B57 , B58) implies H9(B54 , B56 , B57 , B58) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of B55))))));
L13: (for B59 being non  empty ManySortedSign holds (for B60 being  non-empty MSAlgebra over B59 holds (for B61 being set holds (for B62 being Nat holds H9(B59 , B60 , B61 , B62) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H8(B59 , B61 , B62)))));
L14: (ex B63 , B64 being (ManySortedSet of ( NAT )) st (( C4 -BitSubtracterStr (C5 , C6) ) = ( B63 . C4 ) & ( B63 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B64 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B65 being Nat holds (for B66 being non  empty ManySortedSign holds (for B67 being set holds ((B66 = ( B63 . B65 ) & B67 = ( B64 . B65 )) implies (( B63 . ( B65 + 1 ) ) = H8(B66 , B67 , B65) & ( B64 . ( B65 + 1 ) ) = H7(B67 , B65)))))))) by L2;
thus L15: (ex B68 being  Boolean  gate`2=den  strict (Circuit of D7) st (ex B69 , B70 , B71 being (ManySortedSet of ( NAT )) st (D7 = ( B69 . C4 ) & B68 = ( B70 . C4 ) & ( B69 . ( 0 ) ) = D5 & ( B70 . ( 0 ) ) = D6 & ( B71 . ( 0 ) ) = D8 & (for B72 being Nat holds (for B73 being non  empty ManySortedSign holds (for B74 being  non-empty MSAlgebra over B73 holds (for B75 being set holds ((B73 = ( B69 . B72 ) & B74 = ( B70 . B72 ) & B75 = ( B71 . B72 )) implies (( B69 . ( B72 + 1 ) ) = H8(B73 , B75 , B72) & ( B70 . ( B72 + 1 ) ) = H9(B73 , B74 , B75 , B72) & ( B71 . ( B72 + 1 ) ) = H7(B75 , B72)))))))))) from CIRCCMB2:sch 19(L11 , L14 , L13 , L12);
end;
end;
definition
let C7 being Nat;
let C8 , C9 being FinSequence;
set D9 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
func C7 -BitBorrowOutput (C8 , C9) -> (Element of ( InnerVertices ( C7 -BitSubtracterStr (C8 , C9) ) )) means 
:L17: (ex B76 being (ManySortedSet of ( NAT )) st (it = ( B76 . C7 ) & ( B76 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B77 being Nat holds ( B76 . ( B77 + 1 ) ) = ( BorrowOutput (( C8 . ( B77 + 1 ) ) , ( C9 . ( B77 + 1 ) ) , ( B76 . B77 )) ))));
uniqueness
proof
let C10 , C11 being (Element of ( InnerVertices ( C7 -BitSubtracterStr (C8 , C9) ) ));
given C12 being (ManySortedSet of ( NAT )) such that
L18: C10 = ( C12 . C7 )
and
L19: ( C12 . ( 0 ) ) = D9
and
L20: (for B78 being Nat holds ( C12 . ( B78 + 1 ) ) = ( BorrowOutput (( C8 . ( B78 + 1 ) ) , ( C9 . ( B78 + 1 ) ) , ( C12 . B78 )) ));

given C13 being (ManySortedSet of ( NAT )) such that
L21: C11 = ( C13 . C7 )
and
L22: ( C13 . ( 0 ) ) = D9
and
L23: (for B79 being Nat holds ( C13 . ( B79 + 1 ) ) = ( BorrowOutput (( C8 . ( B79 + 1 ) ) , ( C9 . ( B79 + 1 ) ) , ( C13 . B79 )) ));

deffunc H10(Nat , set) = ( BorrowOutput (( C8 . ( $1 + 1 ) ) , ( C9 . ( $1 + 1 ) ) , $2) );
L24: ( dom C12 ) = ( NAT ) by PARTFUN1:def 2;
L25: ( C12 . ( 0 ) ) = D9 by L19;
L26: (for B80 being Nat holds ( C12 . ( B80 + 1 ) ) = H10(B80 , ( C12 . B80 ))) by L20;
L27: ( dom C13 ) = ( NAT ) by PARTFUN1:def 2;
L28: ( C13 . ( 0 ) ) = D9 by L22;
L29: (for B81 being Nat holds ( C13 . ( B81 + 1 ) ) = H10(B81 , ( C13 . B81 ))) by L23;
L30: C12 = C13 from NAT_1:sch 15(L24 , L25 , L26 , L27 , L28 , L29);
thus L31: thesis by L30 , L18 , L21;
end;
existence
proof
defpred S1[ set , set , set ] means (not contradiction);
deffunc H11(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitSubtracterWithBorrowStr (( C8 . ( $3 + 1 ) ) , ( C9 . ( $3 + 1 ) ) , $2) ) );
deffunc H12(set , Nat) = ( BorrowOutput (( C8 . ( $2 + 1 ) ) , ( C9 . ( $2 + 1 ) ) , $1) );
consider C14 , C15 being (ManySortedSet of ( NAT )) such that L32: ( C7 -BitSubtracterStr (C8 , C9) ) = ( C14 . C7 ) and L33: ( C14 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L34: ( C15 . ( 0 ) ) = D9 and L35: (for B82 being Nat holds (for B83 being non  empty ManySortedSign holds (for B84 being set holds ((B83 = ( C14 . B82 ) & B84 = ( C15 . B82 )) implies (( C14 . ( B82 + 1 ) ) = H11(B83 , B84 , B82) & ( C15 . ( B82 + 1 ) ) = H12(B84 , B82)))))) by L2;
defpred S2[ Nat ] means (ex B85 being non  empty ManySortedSign st (B85 = ( C14 . $1 ) & ( C15 . $1 ) in ( InnerVertices B85 )));
L36: ( InnerVertices ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) ) = { D9 } by CIRCCOMB:42;
L37: D9 in ( InnerVertices ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) ) by L36 , TARSKI:def 1;
L38: S2[ ( 0 ) ] by L37 , L33 , L34;
L39: (for B86 being Nat holds (S2[ B86 ] implies S2[ ( B86 + 1 ) ]))
proof
let C16 being Nat;
assume that
L40: (ex B87 being non  empty ManySortedSign st (B87 = ( C14 . C16 ) & ( C15 . C16 ) in ( InnerVertices B87 )))
and
L41: (for B88 being non  empty ManySortedSign holds (B88 = ( C14 . ( C16 + 1 ) ) implies (not ( C15 . ( C16 + 1 ) ) in ( InnerVertices B88 ))));
consider C17 being non  empty ManySortedSign such that L42: C17 = ( C14 . C16 ) and L43: ( C15 . C16 ) in ( InnerVertices C17 ) by L40;
L44: ( BorrowOutput (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) in ( InnerVertices ( BitSubtracterWithBorrowStr (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) ) by FACIRC_1:21;
L45: ( BorrowOutput (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) in ( InnerVertices ( C17 +* ( BitSubtracterWithBorrowStr (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) ) ) by L44 , FACIRC_1:22;
L46: ( C14 . ( C16 + 1 ) ) = ( C17 +* ( BitSubtracterWithBorrowStr (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) ) by L35 , L42;
L47: ( C15 . ( C16 + 1 ) ) = ( BorrowOutput (( C8 . ( C16 + 1 ) ) , ( C9 . ( C16 + 1 ) ) , ( C15 . C16 )) ) by L35 , L42;
thus L48: contradiction by L47 , L41 , L45 , L46;
end;
L49: (for B89 being Nat holds S2[ B89 ]) from NAT_1:sch 2(L38 , L39);
L50: (ex B90 being non  empty ManySortedSign st (B90 = ( C14 . C7 ) & ( C15 . C7 ) in ( InnerVertices B90 ))) by L49;
reconsider D10 = ( C15 . C7 ) as (Element of ( InnerVertices ( C7 -BitSubtracterStr (C8 , C9) ) )) by L50 , L32;
take D10;
take C15;
thus L51: (D10 = ( C15 . C7 ) & ( C15 . ( 0 ) ) = D9) by L34;
let C18 being Nat;
L52: (ex B91 being non  empty ManySortedSign st (ex B92 being set st (B91 = ( C14 . ( 0 ) ) & B92 = ( C15 . ( 0 ) ) & S1[ B91 , B92 , ( 0 ) ]))) by L33;
L53: (for B93 being Nat holds (for B94 being non  empty ManySortedSign holds (for B95 being set holds ((B94 = ( C14 . B93 ) & B95 = ( C15 . B93 ) & S1[ B94 , B95 , B93 ]) implies S1[ H11(B94 , B95 , B93) , H12(B95 , B93) , ( B93 + 1 ) ]))));
L54: (for B96 being Nat holds (ex B97 being non  empty ManySortedSign st (B97 = ( C14 . B96 ) & S1[ B97 , ( C15 . B96 ) , B96 ]))) from CIRCCMB2:sch 2(L52 , L35 , L53);
L55: (ex B98 being non  empty ManySortedSign st B98 = ( C14 . C18 )) by L54;
thus L56: thesis by L55 , L35;
end;
end;
theorem
L58: (for B99 , B100 being FinSequence holds (for B101 , B102 , B103 being (ManySortedSet of ( NAT )) holds ((( B101 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B102 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B103 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B104 being Nat holds (for B105 being non  empty ManySortedSign holds (for B106 being  non-empty MSAlgebra over B105 holds (for B107 being set holds ((B105 = ( B101 . B104 ) & B106 = ( B102 . B104 ) & B107 = ( B103 . B104 )) implies (( B101 . ( B104 + 1 ) ) = ( B105 +* ( BitSubtracterWithBorrowStr (( B99 . ( B104 + 1 ) ) , ( B100 . ( B104 + 1 ) ) , B107) ) ) & ( B102 . ( B104 + 1 ) ) = ( B106 +* ( BitSubtracterWithBorrowCirc (( B99 . ( B104 + 1 ) ) , ( B100 . ( B104 + 1 ) ) , B107) ) ) & ( B103 . ( B104 + 1 ) ) = ( BorrowOutput (( B99 . ( B104 + 1 ) ) , ( B100 . ( B104 + 1 ) ) , B107) )))))))) implies (for B108 being Nat holds (( B108 -BitSubtracterStr (B99 , B100) ) = ( B101 . B108 ) & ( B108 -BitSubtracterCirc (B99 , B100) ) = ( B102 . B108 ) & ( B108 -BitBorrowOutput (B99 , B100) ) = ( B103 . B108 ))))))
proof
let C19 , C20 being FinSequence;
let C21 , C22 , C23 being (ManySortedSet of ( NAT ));
deffunc H13(set , Nat) = ( BorrowOutput (( C19 . ( $2 + 1 ) ) , ( C20 . ( $2 + 1 ) ) , $1) );
deffunc H14(Nat , set) = ( BorrowOutput (( C19 . ( $1 + 1 ) ) , ( C20 . ( $1 + 1 ) ) , $2) );
deffunc H15(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitSubtracterWithBorrowStr (( C19 . ( $3 + 1 ) ) , ( C20 . ( $3 + 1 ) ) , $2) ) );
deffunc H16(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitSubtracterWithBorrowCirc (( C19 . ( $4 + 1 ) ) , ( C20 . ( $4 + 1 ) ) , $3) ) );
assume that
L59: (( C21 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( C22 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ))
and
L60: ( C23 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ]
and
L61: (for B109 being Nat holds (for B110 being non  empty ManySortedSign holds (for B111 being  non-empty MSAlgebra over B110 holds (for B112 being set holds ((B110 = ( C21 . B109 ) & B111 = ( C22 . B109 ) & B112 = ( C23 . B109 )) implies (( C21 . ( B109 + 1 ) ) = H15(B110 , B112 , B109) & ( C22 . ( B109 + 1 ) ) = H16(B110 , B111 , B112 , B109) & ( C23 . ( B109 + 1 ) ) = H13(B112 , B109)))))));
let C24 being Nat;
consider C25 , C26 , C27 being (ManySortedSet of ( NAT )) such that L62: ( C24 -BitSubtracterStr (C19 , C20) ) = ( C25 . C24 ) and L63: ( C24 -BitSubtracterCirc (C19 , C20) ) = ( C26 . C24 ) and L64: ( C25 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L65: ( C26 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L66: ( C27 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] and L67: (for B113 being Nat holds (for B114 being non  empty ManySortedSign holds (for B115 being  non-empty MSAlgebra over B114 holds (for B116 being set holds ((B114 = ( C25 . B113 ) & B115 = ( C26 . B113 ) & B116 = ( C27 . B113 )) implies (( C25 . ( B113 + 1 ) ) = H15(B114 , B116 , B113) & ( C26 . ( B113 + 1 ) ) = H16(B114 , B115 , B116 , B113) & ( C27 . ( B113 + 1 ) ) = H13(B116 , B113))))))) by L8;
L68: (ex B117 being non  empty ManySortedSign st (ex B118 being  non-empty MSAlgebra over B117 st (B117 = ( C21 . ( 0 ) ) & B118 = ( C22 . ( 0 ) )))) by L59;
L69: (( C21 . ( 0 ) ) = ( C25 . ( 0 ) ) & ( C22 . ( 0 ) ) = ( C26 . ( 0 ) ) & ( C23 . ( 0 ) ) = ( C27 . ( 0 ) )) by L59 , L60 , L64 , L65 , L66;
L70: (for B119 being non  empty ManySortedSign holds (for B120 being  non-empty MSAlgebra over B119 holds (for B121 being set holds (for B122 being Nat holds H16(B119 , B120 , B121 , B122) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H15(B119 , B121 , B122)))));
L71: (C21 = C25 & C22 = C26 & C23 = C27) from CIRCCMB2:sch 14(L68 , L69 , L61 , L67 , L70);
thus L72: (( C24 -BitSubtracterStr (C19 , C20) ) = ( C21 . C24 ) & ( C24 -BitSubtracterCirc (C19 , C20) ) = ( C22 . C24 )) by L71 , L62 , L63;
L73: (for B123 being Nat holds (for B124 being non  empty ManySortedSign holds (for B125 being set holds ((B124 = ( C21 . B123 ) & B125 = ( C23 . B123 )) implies (( C21 . ( B123 + 1 ) ) = H15(B124 , B125 , B123) & ( C23 . ( B123 + 1 ) ) = H13(B125 , B123)))))) from CIRCCMB2:sch 15(L59 , L61 , L70);
L74: ( C21 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) by L59;
L75: (for B126 being Nat holds (for B127 being set holds (B127 = ( C23 . B126 ) implies ( C23 . ( B126 + 1 ) ) = H13(B127 , B126)))) from CIRCCMB2:sch 3(L74 , L73);
L76: ( dom C23 ) = ( NAT ) by PARTFUN1:def 2;
L77: ( C23 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] by L60;
L78: (for B128 being Nat holds ( C23 . ( B128 + 1 ) ) = H14(B128 , ( C23 . B128 ))) by L75;
consider C28 being (ManySortedSet of ( NAT )) such that L79: ( C24 -BitBorrowOutput (C19 , C20) ) = ( C28 . C24 ) and L80: ( C28 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] and L81: (for B129 being Nat holds ( C28 . ( B129 + 1 ) ) = ( BorrowOutput (( C19 . ( B129 + 1 ) ) , ( C20 . ( B129 + 1 ) ) , ( C28 . B129 )) )) by L17;
L82: ( dom C28 ) = ( NAT ) by PARTFUN1:def 2;
L83: ( C28 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] by L80;
L84: (for B130 being Nat holds ( C28 . ( B130 + 1 ) ) = H14(B130 , ( C28 . B130 ))) by L81;
L85: C23 = C28 from NAT_1:sch 15(L76 , L77 , L78 , L82 , L83 , L84);
thus L86: thesis by L85 , L79;
end;
theorem
L87: (for B131 , B132 being FinSequence holds (( ( 0 ) -BitSubtracterStr (B131 , B132) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( ( 0 ) -BitSubtracterCirc (B131 , B132) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( ( 0 ) -BitBorrowOutput (B131 , B132) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ]))
proof
let C29 , C30 being FinSequence;
L88: (ex B133 , B134 , B135 being (ManySortedSet of ( NAT )) st (( ( 0 ) -BitSubtracterStr (C29 , C30) ) = ( B133 . ( 0 ) ) & ( ( 0 ) -BitSubtracterCirc (C29 , C30) ) = ( B134 . ( 0 ) ) & ( B133 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B134 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) & ( B135 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B136 being Nat holds (for B137 being non  empty ManySortedSign holds (for B138 being  non-empty MSAlgebra over B137 holds (for B139 being set holds ((B137 = ( B133 . B136 ) & B138 = ( B134 . B136 ) & B139 = ( B135 . B136 )) implies (( B133 . ( B136 + 1 ) ) = ( B137 +* ( BitSubtracterWithBorrowStr (( C29 . ( B136 + 1 ) ) , ( C30 . ( B136 + 1 ) ) , B139) ) ) & ( B134 . ( B136 + 1 ) ) = ( B138 +* ( BitSubtracterWithBorrowCirc (( C29 . ( B136 + 1 ) ) , ( C30 . ( B136 + 1 ) ) , B139) ) ) & ( B135 . ( B136 + 1 ) ) = ( BorrowOutput (( C29 . ( B136 + 1 ) ) , ( C30 . ( B136 + 1 ) ) , B139) ))))))))) by L8;
thus L89: ( ( 0 ) -BitSubtracterStr (C29 , C30) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) by L88;
thus L90: ( ( 0 ) -BitSubtracterCirc (C29 , C30) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) by L88;
L91: ( InnerVertices ( ( 0 ) -BitSubtracterStr (C29 , C30) ) ) = { [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] } by L88 , CIRCCOMB:42;
thus L92: thesis by L91 , TARSKI:def 1;
end;
theorem
L93: (for B140 , B141 being FinSequence holds (for B142 being set holds (B142 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] implies (( 1 -BitSubtracterStr (B140 , B141) ) = ( ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitSubtracterWithBorrowStr (( B140 . 1 ) , ( B141 . 1 ) , B142) ) ) & ( 1 -BitSubtracterCirc (B140 , B141) ) = ( ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitSubtracterWithBorrowCirc (( B140 . 1 ) , ( B141 . 1 ) , B142) ) ) & ( 1 -BitBorrowOutput (B140 , B141) ) = ( BorrowOutput (( B140 . 1 ) , ( B141 . 1 ) , B142) )))))
proof
let C31 , C32 being FinSequence;
let C33 being set;
assume that
L94: C33 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
consider C34 , C35 , C36 being (ManySortedSet of ( NAT )) such that L95: ( 1 -BitSubtracterStr (C31 , C32) ) = ( C34 . 1 ) and L96: ( 1 -BitSubtracterCirc (C31 , C32) ) = ( C35 . 1 ) and L97: ( C34 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L98: ( C35 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L99: ( C36 . ( 0 ) ) = C33 and L100: (for B143 being Nat holds (for B144 being non  empty ManySortedSign holds (for B145 being  non-empty MSAlgebra over B144 holds (for B146 being set holds ((B144 = ( C34 . B143 ) & B145 = ( C35 . B143 ) & B146 = ( C36 . B143 )) implies (( C34 . ( B143 + 1 ) ) = ( B144 +* ( BitSubtracterWithBorrowStr (( C31 . ( B143 + 1 ) ) , ( C32 . ( B143 + 1 ) ) , B146) ) ) & ( C35 . ( B143 + 1 ) ) = ( B145 +* ( BitSubtracterWithBorrowCirc (( C31 . ( B143 + 1 ) ) , ( C32 . ( B143 + 1 ) ) , B146) ) ) & ( C36 . ( B143 + 1 ) ) = ( BorrowOutput (( C31 . ( B143 + 1 ) ) , ( C32 . ( B143 + 1 ) ) , B146) ))))))) by L94 , L8;
L101: ( 1 -BitBorrowOutput (C31 , C32) ) = ( C36 . ( ( 0 ) + 1 ) ) by L94 , L97 , L98 , L99 , L100 , L58;
thus L102: thesis by L101 , L95 , L96 , L97 , L98 , L99 , L100;
end;
theorem
L103: (for B147 , B148 , B149 being set holds (B149 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] implies (( 1 -BitSubtracterStr (<* B147 *> , <* B148 *>) ) = ( ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitSubtracterWithBorrowStr (B147 , B148 , B149) ) ) & ( 1 -BitSubtracterCirc (<* B147 *> , <* B148 *>) ) = ( ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) +* ( BitSubtracterWithBorrowCirc (B147 , B148 , B149) ) ) & ( 1 -BitBorrowOutput (<* B147 *> , <* B148 *>) ) = ( BorrowOutput (B147 , B148 , B149) ))))
proof
let C37 , C38 being set;
L104: ( <* C37 *> . 1 ) = C37 by FINSEQ_1:40;
L105: ( <* C38 *> . 1 ) = C38 by FINSEQ_1:40;
thus L106: thesis by L105 , L104 , L93;
end;
theorem
L107: (for B150 being (Element of ( NAT )) holds (for B151 , B152 being (FinSeqLen of B150) holds (for B153 , B154 , B155 , B156 being FinSequence holds (( B150 -BitSubtracterStr (( B151 ^ B153 ) , ( B152 ^ B155 )) ) = ( B150 -BitSubtracterStr (( B151 ^ B154 ) , ( B152 ^ B156 )) ) & ( B150 -BitSubtracterCirc (( B151 ^ B153 ) , ( B152 ^ B155 )) ) = ( B150 -BitSubtracterCirc (( B151 ^ B154 ) , ( B152 ^ B156 )) ) & ( B150 -BitBorrowOutput (( B151 ^ B153 ) , ( B152 ^ B155 )) ) = ( B150 -BitBorrowOutput (( B151 ^ B154 ) , ( B152 ^ B156 )) )))))
proof
let C39 being (Element of ( NAT ));
set D11 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
let C40 , C41 being (FinSeqLen of C39);
let C42 , C43 , C44 , C45 being FinSequence;
deffunc H17(set , Nat) = ( BorrowOutput (( ( C40 ^ C42 ) . ( $2 + 1 ) ) , ( ( C41 ^ C44 ) . ( $2 + 1 ) ) , $1) );
deffunc H18(non  empty ManySortedSign , set , Nat) = ( $1 +* ( BitSubtracterWithBorrowStr (( ( C40 ^ C42 ) . ( $3 + 1 ) ) , ( ( C41 ^ C44 ) . ( $3 + 1 ) ) , $2) ) );
deffunc H19(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , Nat) = ( $2 +* ( BitSubtracterWithBorrowCirc (( ( C40 ^ C42 ) . ( $4 + 1 ) ) , ( ( C41 ^ C44 ) . ( $4 + 1 ) ) , $3) ) );
consider C46 , C47 , C48 being (ManySortedSet of ( NAT )) such that L108: ( C39 -BitSubtracterStr (( C40 ^ C42 ) , ( C41 ^ C44 )) ) = ( C46 . C39 ) and L109: ( C39 -BitSubtracterCirc (( C40 ^ C42 ) , ( C41 ^ C44 )) ) = ( C47 . C39 ) and L110: ( C46 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L111: ( C47 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L112: ( C48 . ( 0 ) ) = D11 and L113: (for B157 being Nat holds (for B158 being non  empty ManySortedSign holds (for B159 being  non-empty MSAlgebra over B158 holds (for B160 being set holds ((B158 = ( C46 . B157 ) & B159 = ( C47 . B157 ) & B160 = ( C48 . B157 )) implies (( C46 . ( B157 + 1 ) ) = H18(B158 , B160 , B157) & ( C47 . ( B157 + 1 ) ) = H19(B158 , B159 , B160 , B157) & ( C48 . ( B157 + 1 ) ) = H17(B160 , B157))))))) by L8;
consider C49 , C50 , C51 being (ManySortedSet of ( NAT )) such that L114: ( C39 -BitSubtracterStr (( C40 ^ C43 ) , ( C41 ^ C45 )) ) = ( C49 . C39 ) and L115: ( C39 -BitSubtracterCirc (( C40 ^ C43 ) , ( C41 ^ C45 )) ) = ( C50 . C39 ) and L116: ( C49 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L117: ( C50 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L118: ( C51 . ( 0 ) ) = D11 and L119: (for B161 being Nat holds (for B162 being non  empty ManySortedSign holds (for B163 being  non-empty MSAlgebra over B162 holds (for B164 being set holds ((B162 = ( C49 . B161 ) & B163 = ( C50 . B161 ) & B164 = ( C51 . B161 )) implies (( C49 . ( B161 + 1 ) ) = ( B162 +* ( BitSubtracterWithBorrowStr (( ( C40 ^ C43 ) . ( B161 + 1 ) ) , ( ( C41 ^ C45 ) . ( B161 + 1 ) ) , B164) ) ) & ( C50 . ( B161 + 1 ) ) = ( B163 +* ( BitSubtracterWithBorrowCirc (( ( C40 ^ C43 ) . ( B161 + 1 ) ) , ( ( C41 ^ C45 ) . ( B161 + 1 ) ) , B164) ) ) & ( C51 . ( B161 + 1 ) ) = ( BorrowOutput (( ( C40 ^ C43 ) . ( B161 + 1 ) ) , ( ( C41 ^ C45 ) . ( B161 + 1 ) ) , B164) ))))))) by L8;
defpred S3[ Nat ] means ($1 <= C39 implies (( C48 . $1 ) = ( C51 . $1 ) & ( C46 . $1 ) = ( C49 . $1 ) & ( C47 . $1 ) = ( C50 . $1 )));
L120: S3[ ( 0 ) ] by L110 , L111 , L112 , L116 , L117 , L118;
L121: (for B165 being Nat holds (S3[ B165 ] implies S3[ ( B165 + 1 ) ]))
proof
let C52 being Nat;
assume that
L122: (C52 <= C39 implies (( C48 . C52 ) = ( C51 . C52 ) & ( C46 . C52 ) = ( C49 . C52 ) & ( C47 . C52 ) = ( C50 . C52 )))
and
L123: ( C52 + 1 ) <= C39;
L124: ( len C40 ) = C39 by CARD_1:def 7;
L125: ( len C41 ) = C39 by CARD_1:def 7;
L126: ( dom C40 ) = ( Seg C39 ) by L124 , FINSEQ_1:def 3;
L127: ( dom C41 ) = ( Seg C39 ) by L125 , FINSEQ_1:def 3;
L128: ( ( 0 ) + 1 ) <= ( C52 + 1 ) by XREAL_1:6;
L129: ( C52 + 1 ) in ( Seg C39 ) by L128 , L123 , FINSEQ_1:1;
L130: ( ( C40 ^ C42 ) . ( C52 + 1 ) ) = ( C40 . ( C52 + 1 ) ) by L129 , L126 , FINSEQ_1:def 7;
L131: ( ( C40 ^ C43 ) . ( C52 + 1 ) ) = ( C40 . ( C52 + 1 ) ) by L126 , L129 , FINSEQ_1:def 7;
L132: ( ( C41 ^ C44 ) . ( C52 + 1 ) ) = ( C41 . ( C52 + 1 ) ) by L127 , L129 , FINSEQ_1:def 7;
L133: ( ( C41 ^ C45 ) . ( C52 + 1 ) ) = ( C41 . ( C52 + 1 ) ) by L127 , L129 , FINSEQ_1:def 7;
defpred S4[ set , set , set , set ] means (not contradiction);
L134: (ex B166 being non  empty ManySortedSign st (ex B167 being  non-empty MSAlgebra over B166 st (ex B168 being set st (B166 = ( C46 . ( 0 ) ) & B167 = ( C47 . ( 0 ) ) & B168 = ( C48 . ( 0 ) ) & S4[ B166 , B167 , B168 , ( 0 ) ])))) by L110 , L111;
L135: (for B169 being Nat holds (for B170 being non  empty ManySortedSign holds (for B171 being  non-empty MSAlgebra over B170 holds (for B172 being set holds ((B170 = ( C46 . B169 ) & B171 = ( C47 . B169 ) & B172 = ( C48 . B169 ) & S4[ B170 , B171 , B172 , B169 ]) implies S4[ H18(B170 , B172 , B169) , H19(B170 , B171 , B172 , B169) , H17(B172 , B169) , ( B169 + 1 ) ])))));
L136: (for B173 being non  empty ManySortedSign holds (for B174 being  non-empty MSAlgebra over B173 holds (for B175 being set holds (for B176 being Nat holds H19(B173 , B174 , B175 , B176) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H18(B173 , B175 , B176)))));
L137: (for B177 being Nat holds (ex B178 being non  empty ManySortedSign st (ex B179 being  non-empty MSAlgebra over B178 st (B178 = ( C46 . B177 ) & B179 = ( C47 . B177 ) & S4[ B178 , B179 , ( C48 . B177 ) , B177 ])))) from CIRCCMB2:sch 13(L134 , L113 , L135 , L136);
consider C53 being non  empty ManySortedSign, C54 being  non-empty MSAlgebra over C53 such that L138: C53 = ( C46 . C52 ) and L139: C54 = ( C47 . C52 ) by L137;
thus L140: ( C48 . ( C52 + 1 ) ) = ( BorrowOutput (( ( C40 ^ C43 ) . ( C52 + 1 ) ) , ( ( C41 ^ C45 ) . ( C52 + 1 ) ) , ( C51 . C52 )) ) by L113 , L122 , L123 , L130 , L131 , L132 , L133 , L138 , L139 , NAT_1:13
.= ( C51 . ( C52 + 1 ) ) by L119 , L122 , L123 , L138 , L139 , NAT_1:13;
thus L141: ( C46 . ( C52 + 1 ) ) = ( C53 +* ( BitSubtracterWithBorrowStr (( ( C40 ^ C43 ) . ( C52 + 1 ) ) , ( ( C41 ^ C45 ) . ( C52 + 1 ) ) , ( C51 . C52 )) ) ) by L113 , L122 , L123 , L130 , L131 , L132 , L133 , L138 , L139 , NAT_1:13
.= ( C49 . ( C52 + 1 ) ) by L119 , L122 , L123 , L138 , L139 , NAT_1:13;
thus L142: ( C47 . ( C52 + 1 ) ) = ( C54 +* ( BitSubtracterWithBorrowCirc (( ( C40 ^ C43 ) . ( C52 + 1 ) ) , ( ( C41 ^ C45 ) . ( C52 + 1 ) ) , ( C51 . C52 )) ) ) by L113 , L122 , L123 , L130 , L131 , L132 , L133 , L138 , L139 , NAT_1:13
.= ( C50 . ( C52 + 1 ) ) by L119 , L122 , L123 , L138 , L139 , NAT_1:13;
end;
L143: (for B180 being Nat holds S3[ B180 ]) from NAT_1:sch 2(L120 , L121);
thus L144: (( C39 -BitSubtracterStr (( C40 ^ C42 ) , ( C41 ^ C44 )) ) = ( C39 -BitSubtracterStr (( C40 ^ C43 ) , ( C41 ^ C45 )) ) & ( C39 -BitSubtracterCirc (( C40 ^ C42 ) , ( C41 ^ C44 )) ) = ( C39 -BitSubtracterCirc (( C40 ^ C43 ) , ( C41 ^ C45 )) )) by L143 , L108 , L109 , L114 , L115;
L145: ( C39 -BitBorrowOutput (( C40 ^ C42 ) , ( C41 ^ C44 )) ) = ( C48 . C39 ) by L110 , L111 , L112 , L113 , L58;
L146: ( C39 -BitBorrowOutput (( C40 ^ C43 ) , ( C41 ^ C45 )) ) = ( C51 . C39 ) by L116 , L117 , L118 , L119 , L58;
thus L147: thesis by L146 , L143 , L145;
end;
theorem
L148: (for B181 being (Element of ( NAT )) holds (for B182 , B183 being (FinSeqLen of B181) holds (for B184 , B185 being set holds (( ( B181 + 1 ) -BitSubtracterStr (( B182 ^ <* B184 *> ) , ( B183 ^ <* B185 *> )) ) = ( ( B181 -BitSubtracterStr (B182 , B183) ) +* ( BitSubtracterWithBorrowStr (B184 , B185 , ( B181 -BitBorrowOutput (B182 , B183) )) ) ) & ( ( B181 + 1 ) -BitSubtracterCirc (( B182 ^ <* B184 *> ) , ( B183 ^ <* B185 *> )) ) = ( ( B181 -BitSubtracterCirc (B182 , B183) ) +* ( BitSubtracterWithBorrowCirc (B184 , B185 , ( B181 -BitBorrowOutput (B182 , B183) )) ) ) & ( ( B181 + 1 ) -BitBorrowOutput (( B182 ^ <* B184 *> ) , ( B183 ^ <* B185 *> )) ) = ( BorrowOutput (B184 , B185 , ( B181 -BitBorrowOutput (B182 , B183) )) )))))
proof
let C55 being (Element of ( NAT ));
set D12 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
let C56 , C57 being (FinSeqLen of C55);
let C58 , C59 being set;
set D13 = ( C56 ^ <* C58 *> );
set D14 = ( C57 ^ <* C59 *> );
consider C60 , C61 , C62 being (ManySortedSet of ( NAT )) such that L149: ( C55 -BitSubtracterStr (D13 , D14) ) = ( C60 . C55 ) and L150: ( C55 -BitSubtracterCirc (D13 , D14) ) = ( C61 . C55 ) and L151: ( C60 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L152: ( C61 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L153: ( C62 . ( 0 ) ) = D12 and L154: (for B186 being Nat holds (for B187 being non  empty ManySortedSign holds (for B188 being  non-empty MSAlgebra over B187 holds (for B189 being set holds ((B187 = ( C60 . B186 ) & B188 = ( C61 . B186 ) & B189 = ( C62 . B186 )) implies (( C60 . ( B186 + 1 ) ) = ( B187 +* ( BitSubtracterWithBorrowStr (( D13 . ( B186 + 1 ) ) , ( D14 . ( B186 + 1 ) ) , B189) ) ) & ( C61 . ( B186 + 1 ) ) = ( B188 +* ( BitSubtracterWithBorrowCirc (( D13 . ( B186 + 1 ) ) , ( D14 . ( B186 + 1 ) ) , B189) ) ) & ( C62 . ( B186 + 1 ) ) = ( BorrowOutput (( D13 . ( B186 + 1 ) ) , ( D14 . ( B186 + 1 ) ) , B189) ))))))) by L8;
L155: ( C55 -BitBorrowOutput (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C62 . C55 ) by L151 , L152 , L153 , L154 , L58;
L156: ( ( C55 + 1 ) -BitSubtracterStr (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C60 . ( C55 + 1 ) ) by L151 , L152 , L153 , L154 , L58;
L157: ( ( C55 + 1 ) -BitSubtracterCirc (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C61 . ( C55 + 1 ) ) by L151 , L152 , L153 , L154 , L58;
L158: ( ( C55 + 1 ) -BitBorrowOutput (( C56 ^ <* C58 *> ) , ( C57 ^ <* C59 *> )) ) = ( C62 . ( C55 + 1 ) ) by L151 , L152 , L153 , L154 , L58;
L159: ( len C56 ) = C55 by CARD_1:def 7;
L160: ( len C57 ) = C55 by CARD_1:def 7;
L161: ( D13 . ( C55 + 1 ) ) = C58 by L159 , FINSEQ_1:42;
L162: ( D14 . ( C55 + 1 ) ) = C59 by L160 , FINSEQ_1:42;
L163: ( C56 ^ ( <*> ) ) = C56 by FINSEQ_1:34;
L164: ( C57 ^ ( <*> ) ) = C57 by FINSEQ_1:34;
L165: ( C55 -BitSubtracterStr (D13 , D14) ) = ( C55 -BitSubtracterStr (C56 , C57) ) by L164 , L163 , L107;
L166: ( C55 -BitSubtracterCirc (D13 , D14) ) = ( C55 -BitSubtracterCirc (C56 , C57) ) by L163 , L164 , L107;
L167: ( C55 -BitBorrowOutput (D13 , D14) ) = ( C55 -BitBorrowOutput (C56 , C57) ) by L163 , L164 , L107;
thus L168: thesis by L167 , L149 , L150 , L154 , L155 , L156 , L157 , L158 , L161 , L162 , L165 , L166;
end;
theorem
L169: (for B190 being (Element of ( NAT )) holds (for B191 , B192 being FinSequence holds (( ( B190 + 1 ) -BitSubtracterStr (B191 , B192) ) = ( ( B190 -BitSubtracterStr (B191 , B192) ) +* ( BitSubtracterWithBorrowStr (( B191 . ( B190 + 1 ) ) , ( B192 . ( B190 + 1 ) ) , ( B190 -BitBorrowOutput (B191 , B192) )) ) ) & ( ( B190 + 1 ) -BitSubtracterCirc (B191 , B192) ) = ( ( B190 -BitSubtracterCirc (B191 , B192) ) +* ( BitSubtracterWithBorrowCirc (( B191 . ( B190 + 1 ) ) , ( B192 . ( B190 + 1 ) ) , ( B190 -BitBorrowOutput (B191 , B192) )) ) ) & ( ( B190 + 1 ) -BitBorrowOutput (B191 , B192) ) = ( BorrowOutput (( B191 . ( B190 + 1 ) ) , ( B192 . ( B190 + 1 ) ) , ( B190 -BitBorrowOutput (B191 , B192) )) ))))
proof
let C63 being (Element of ( NAT ));
let C64 , C65 being FinSequence;
set D15 = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ];
consider C66 , C67 , C68 being (ManySortedSet of ( NAT )) such that L170: ( C63 -BitSubtracterStr (C64 , C65) ) = ( C66 . C63 ) and L171: ( C63 -BitSubtracterCirc (C64 , C65) ) = ( C67 . C63 ) and L172: ( C66 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L173: ( C67 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L174: ( C68 . ( 0 ) ) = D15 and L175: (for B193 being Nat holds (for B194 being non  empty ManySortedSign holds (for B195 being  non-empty MSAlgebra over B194 holds (for B196 being set holds ((B194 = ( C66 . B193 ) & B195 = ( C67 . B193 ) & B196 = ( C68 . B193 )) implies (( C66 . ( B193 + 1 ) ) = ( B194 +* ( BitSubtracterWithBorrowStr (( C64 . ( B193 + 1 ) ) , ( C65 . ( B193 + 1 ) ) , B196) ) ) & ( C67 . ( B193 + 1 ) ) = ( B195 +* ( BitSubtracterWithBorrowCirc (( C64 . ( B193 + 1 ) ) , ( C65 . ( B193 + 1 ) ) , B196) ) ) & ( C68 . ( B193 + 1 ) ) = ( BorrowOutput (( C64 . ( B193 + 1 ) ) , ( C65 . ( B193 + 1 ) ) , B196) ))))))) by L8;
L176: ( C63 -BitBorrowOutput (C64 , C65) ) = ( C68 . C63 ) by L172 , L173 , L174 , L175 , L58;
L177: ( ( C63 + 1 ) -BitSubtracterStr (C64 , C65) ) = ( C66 . ( C63 + 1 ) ) by L172 , L173 , L174 , L175 , L58;
L178: ( ( C63 + 1 ) -BitSubtracterCirc (C64 , C65) ) = ( C67 . ( C63 + 1 ) ) by L172 , L173 , L174 , L175 , L58;
L179: ( ( C63 + 1 ) -BitBorrowOutput (C64 , C65) ) = ( C68 . ( C63 + 1 ) ) by L172 , L173 , L174 , L175 , L58;
thus L180: thesis by L179 , L170 , L171 , L175 , L176 , L177 , L178;
end;
theorem
L181: (for B197 , B198 being (Element of ( NAT )) holds (B197 <= B198 implies (for B199 , B200 being FinSequence holds ( InnerVertices ( B197 -BitSubtracterStr (B199 , B200) ) ) c= ( InnerVertices ( B198 -BitSubtracterStr (B199 , B200) ) ))))
proof
let C69 , C70 being (Element of ( NAT ));
assume that
L182: C69 <= C70;
let C71 , C72 being FinSequence;
consider C73 being Nat such that L183: C70 = ( C69 + C73 ) by L182 , NAT_1:10;
reconsider D16 = C73 as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S5[ (Element of ( NAT )) ] means ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) c= ( InnerVertices ( ( C69 + $1 ) -BitSubtracterStr (C71 , C72) ) );
L184: S5[ ( 0 ) ];
L185: (for B201 being (Element of ( NAT )) holds (S5[ B201 ] implies S5[ ( B201 + 1 ) ]))
proof
let C74 being (Element of ( NAT ));
assume L186: ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) c= ( InnerVertices ( ( C69 + C74 ) -BitSubtracterStr (C71 , C72) ) );
L187: ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) c= ( ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) \/ ( InnerVertices ( BitSubtracterWithBorrowStr (( C71 . ( ( C69 + C74 ) + 1 ) ) , ( C72 . ( ( C69 + C74 ) + 1 ) ) , ( ( C69 + C74 ) -BitBorrowOutput (C71 , C72) )) ) ) ) by XBOOLE_1:7;
L188: ( ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) \/ ( InnerVertices ( BitSubtracterWithBorrowStr (( C71 . ( ( C69 + C74 ) + 1 ) ) , ( C72 . ( ( C69 + C74 ) + 1 ) ) , ( ( C69 + C74 ) -BitBorrowOutput (C71 , C72) )) ) ) ) c= ( ( InnerVertices ( ( C69 + C74 ) -BitSubtracterStr (C71 , C72) ) ) \/ ( InnerVertices ( BitSubtracterWithBorrowStr (( C71 . ( ( C69 + C74 ) + 1 ) ) , ( C72 . ( ( C69 + C74 ) + 1 ) ) , ( ( C69 + C74 ) -BitBorrowOutput (C71 , C72) )) ) ) ) by L186 , XBOOLE_1:9;
L189: ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) c= ( ( InnerVertices ( ( C69 + C74 ) -BitSubtracterStr (C71 , C72) ) ) \/ ( InnerVertices ( BitSubtracterWithBorrowStr (( C71 . ( ( C69 + C74 ) + 1 ) ) , ( C72 . ( ( C69 + C74 ) + 1 ) ) , ( ( C69 + C74 ) -BitBorrowOutput (C71 , C72) )) ) ) ) by L188 , L187 , XBOOLE_1:1;
L190: ( InnerVertices ( C69 -BitSubtracterStr (C71 , C72) ) ) c= ( InnerVertices ( ( ( C69 + C74 ) -BitSubtracterStr (C71 , C72) ) +* ( BitSubtracterWithBorrowStr (( C71 . ( ( C69 + C74 ) + 1 ) ) , ( C72 . ( ( C69 + C74 ) + 1 ) ) , ( ( C69 + C74 ) -BitBorrowOutput (C71 , C72) )) ) ) ) by L189 , FACIRC_1:27;
thus L191: thesis by L190 , L169;
end;
L192: (for B202 being (Element of ( NAT )) holds S5[ B202 ]) from NAT_1:sch 1(L184 , L185);
L193: C70 = ( C69 + D16 ) by L183;
thus L194: thesis by L193 , L192;
end;
theorem
L195: (for B203 being (Element of ( NAT )) holds (for B204 , B205 being FinSequence holds ( InnerVertices ( ( B203 + 1 ) -BitSubtracterStr (B204 , B205) ) ) = ( ( InnerVertices ( B203 -BitSubtracterStr (B204 , B205) ) ) \/ ( InnerVertices ( BitSubtracterWithBorrowStr (( B204 . ( B203 + 1 ) ) , ( B205 . ( B203 + 1 ) ) , ( B203 -BitBorrowOutput (B204 , B205) )) ) ) )))
proof
let C75 being (Element of ( NAT ));
let C76 , C77 being FinSequence;
L196: ( InnerVertices ( ( C75 -BitSubtracterStr (C76 , C77) ) +* ( BitSubtracterWithBorrowStr (( C76 . ( C75 + 1 ) ) , ( C77 . ( C75 + 1 ) ) , ( C75 -BitBorrowOutput (C76 , C77) )) ) ) ) = ( ( InnerVertices ( C75 -BitSubtracterStr (C76 , C77) ) ) \/ ( InnerVertices ( BitSubtracterWithBorrowStr (( C76 . ( C75 + 1 ) ) , ( C77 . ( C75 + 1 ) ) , ( C75 -BitBorrowOutput (C76 , C77) )) ) ) ) by FACIRC_1:27;
thus L197: thesis by L196 , L169;
end;
definition
let C78 , C79 being (Element of ( NAT ));
assume that
L198: C78 >= 1
and
L199: C78 <= C79;
let C80 , C81 being FinSequence;
func (C78 , C79) -BitSubtracterOutput (C80 , C81) -> (Element of ( InnerVertices ( C79 -BitSubtracterStr (C80 , C81) ) )) means 
:L200: (ex B206 being (Element of ( NAT )) st (C78 = ( B206 + 1 ) & it = ( BitSubtracterOutput (( C80 . C78 ) , ( C81 . C78 ) , ( B206 -BitBorrowOutput (C80 , C81) )) )));
uniqueness;
existence
proof
consider C82 being Nat such that L201: C78 = ( 1 + C82 ) by L198 , NAT_1:10;
reconsider D17 = C82 as (Element of ( NAT )) by ORDINAL1:def 12;
set D18 = ( BitSubtracterOutput (( C80 . C78 ) , ( C81 . C78 ) , ( D17 -BitBorrowOutput (C80 , C81) )) );
L202: ( InnerVertices ( C78 -BitSubtracterStr (C80 , C81) ) ) c= ( InnerVertices ( C79 -BitSubtracterStr (C80 , C81) ) ) by L199 , L181;
L203: D18 in ( InnerVertices ( BitSubtracterWithBorrowStr (( C80 . ( D17 + 1 ) ) , ( C81 . ( D17 + 1 ) ) , ( D17 -BitBorrowOutput (C80 , C81) )) ) ) by L201 , FACIRC_1:21;
L204: ( C78 -BitSubtracterStr (C80 , C81) ) = ( ( D17 -BitSubtracterStr (C80 , C81) ) +* ( BitSubtracterWithBorrowStr (( C80 . ( D17 + 1 ) ) , ( C81 . ( D17 + 1 ) ) , ( D17 -BitBorrowOutput (C80 , C81) )) ) ) by L201 , L169;
reconsider D19 = D18 as (Element of ( BitSubtracterWithBorrowStr (( C80 . ( D17 + 1 ) ) , ( C81 . ( D17 + 1 ) ) , ( D17 -BitBorrowOutput (C80 , C81) )) )) by L203;
L205: ( (the carrier of ( BitSubtracterWithBorrowStr (( C80 . ( D17 + 1 ) ) , ( C81 . ( D17 + 1 ) ) , ( D17 -BitBorrowOutput (C80 , C81) )) )) \/ (the carrier of ( D17 -BitSubtracterStr (C80 , C81) )) ) = (the carrier of ( C78 -BitSubtracterStr (C80 , C81) )) by L204 , CIRCCOMB:def 2;
L206: D19 in (the carrier of ( C78 -BitSubtracterStr (C80 , C81) )) by L205 , XBOOLE_0:def 3;
L207: D19 in ( InnerVertices ( C78 -BitSubtracterStr (C80 , C81) ) ) by L206 , L203 , L204 , CIRCCOMB:15;
thus L208: thesis by L207 , L201 , L202;
end;
end;
theorem
L210: (for B207 , B208 being (Element of ( NAT )) holds (B208 < B207 implies (for B209 , B210 being FinSequence holds ( (( B208 + 1 ) , B207) -BitSubtracterOutput (B209 , B210) ) = ( BitSubtracterOutput (( B209 . ( B208 + 1 ) ) , ( B210 . ( B208 + 1 ) ) , ( B208 -BitBorrowOutput (B209 , B210) )) ))))
proof
let C83 , C84 being (Element of ( NAT ));
assume that
L211: C84 < C83;
let C85 , C86 being FinSequence;
L212: ( C84 + 1 ) >= 1 by NAT_1:11;
L213: ( C84 + 1 ) <= C83 by L211 , NAT_1:13;
L214: (ex B211 being (Element of ( NAT )) st (( C84 + 1 ) = ( B211 + 1 ) & ( (( C84 + 1 ) , C83) -BitSubtracterOutput (C85 , C86) ) = ( BitSubtracterOutput (( C85 . ( C84 + 1 ) ) , ( C86 . ( C84 + 1 ) ) , ( B211 -BitBorrowOutput (C85 , C86) )) ))) by L213 , L212 , L200;
thus L215: thesis by L214;
end;
theorem
L216: (for B212 being (Element of ( NAT )) holds (for B213 , B214 being FinSequence holds ( InnerVertices ( B212 -BitSubtracterStr (B213 , B214) ) ) is Relation))
proof
let C87 being (Element of ( NAT ));
let C88 , C89 being FinSequence;
defpred S6[ (Element of ( NAT )) ] means ( InnerVertices ( $1 -BitSubtracterStr (C88 , C89) ) ) is Relation;
L217: ( ( 0 ) -BitSubtracterStr (C88 , C89) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) by L87;
L218: S6[ ( 0 ) ] by L217 , FACIRC_1:38;
L219:
now
let C90 being (Element of ( NAT ));
assume L220: S6[ C90 ];
L221: ( ( C90 + 1 ) -BitSubtracterStr (C88 , C89) ) = ( ( C90 -BitSubtracterStr (C88 , C89) ) +* ( BitSubtracterWithBorrowStr (( C88 . ( C90 + 1 ) ) , ( C89 . ( C90 + 1 ) ) , ( C90 -BitBorrowOutput (C88 , C89) )) ) ) by L169;
L222: ( InnerVertices ( BitSubtracterWithBorrowStr (( C88 . ( C90 + 1 ) ) , ( C89 . ( C90 + 1 ) ) , ( C90 -BitBorrowOutput (C88 , C89) )) ) ) is Relation by FSCIRC_1:22;
thus L223: S6[ ( C90 + 1 ) ] by L222 , L220 , L221 , FACIRC_1:3;
end;
L224: (for B215 being (Element of ( NAT )) holds S6[ B215 ]) from NAT_1:sch 1(L218 , L219);
thus L225: thesis by L224;
end;
theorem
L226: (for B216 , B217 , B218 being set holds ( InnerVertices ( BorrowIStr (B216 , B217 , B218) ) ) = { [ <* B216 , B217 *> , ( and2a ) ] , [ <* B217 , B218 *> , ( and2 ) ] , [ <* B216 , B218 *> , ( and2a ) ] })
proof
let C91 , C92 , C93 being set;
L227: ( ( 1GateCircStr (<* C91 , C92 *> , ( and2a )) ) +* ( 1GateCircStr (<* C92 , C93 *> , ( and2 )) ) ) tolerates ( 1GateCircStr (<* C91 , C93 *> , ( and2a )) ) by CIRCCOMB:47;
L228: ( 1GateCircStr (<* C91 , C92 *> , ( and2a )) ) tolerates ( 1GateCircStr (<* C92 , C93 *> , ( and2 )) ) by CIRCCOMB:47;
L229: ( InnerVertices ( BorrowIStr (C91 , C92 , C93) ) ) = ( ( InnerVertices ( ( 1GateCircStr (<* C91 , C92 *> , ( and2a )) ) +* ( 1GateCircStr (<* C92 , C93 *> , ( and2 )) ) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C91 , C93 *> , ( and2a )) ) ) ) by L227 , CIRCCOMB:11
.= ( ( ( InnerVertices ( 1GateCircStr (<* C91 , C92 *> , ( and2a )) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C92 , C93 *> , ( and2 )) ) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C91 , C93 *> , ( and2a )) ) ) ) by L228 , CIRCCOMB:11
.= ( ( { [ <* C91 , C92 *> , ( and2a ) ] } \/ ( InnerVertices ( 1GateCircStr (<* C92 , C93 *> , ( and2 )) ) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C91 , C93 *> , ( and2a )) ) ) ) by CIRCCOMB:42
.= ( ( { [ <* C91 , C92 *> , ( and2a ) ] } \/ { [ <* C92 , C93 *> , ( and2 ) ] } ) \/ ( InnerVertices ( 1GateCircStr (<* C91 , C93 *> , ( and2a )) ) ) ) by CIRCCOMB:42
.= ( ( { [ <* C91 , C92 *> , ( and2a ) ] } \/ { [ <* C92 , C93 *> , ( and2 ) ] } ) \/ { [ <* C91 , C93 *> , ( and2a ) ] } ) by CIRCCOMB:42
.= ( { [ <* C91 , C92 *> , ( and2a ) ] , [ <* C92 , C93 *> , ( and2 ) ] } \/ { [ <* C91 , C93 *> , ( and2a ) ] } ) by ENUMSET1:1
.= { [ <* C91 , C92 *> , ( and2a ) ] , [ <* C92 , C93 *> , ( and2 ) ] , [ <* C91 , C93 *> , ( and2a ) ] } by ENUMSET1:3;
thus L230: thesis by L229;
end;
theorem
L231: (for B219 , B220 , B221 being set holds ((B219 <> [ <* B220 , B221 *> , ( and2 ) ] & B220 <> [ <* B219 , B221 *> , ( and2a ) ] & B221 <> [ <* B219 , B220 *> , ( and2a ) ]) implies ( InputVertices ( BorrowIStr (B219 , B220 , B221) ) ) = { B219 , B220 , B221 }))
proof
let C94 , C95 , C96 being set;
assume that
L232: C94 <> [ <* C95 , C96 *> , ( and2 ) ]
and
L233: C95 <> [ <* C94 , C96 *> , ( and2a ) ]
and
L234: C96 <> [ <* C94 , C95 *> , ( and2a ) ];
L235: ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) tolerates ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) by CIRCCOMB:47;
L236: C95 in { 1 , C95 } by TARSKI:def 2;
L237: C95 in { 2 , C95 } by TARSKI:def 2;
L238: { 1 , C95 } in [ 1 , C95 ] by TARSKI:def 2;
L239: { 2 , C95 } in [ 2 , C95 ] by TARSKI:def 2;
L240: <* C95 , C96 *> = ( <* C95 *> ^ <* C96 *> ) by FINSEQ_1:def 9;
L241: <* C95 *> c= <* C95 , C96 *> by L240 , FINSEQ_6:10;
L242: <* C95 *> = { [ 1 , C95 ] } by FINSEQ_1:def 5;
L243: [ 1 , C95 ] in <* C95 *> by L242 , TARSKI:def 1;
L244: <* C95 , C96 *> in { <* C95 , C96 *> } by TARSKI:def 1;
L245: { <* C95 , C96 *> } in [ <* C95 , C96 *> , ( and2 ) ] by TARSKI:def 2;
L246: C95 <> [ <* C95 , C96 *> , ( and2 ) ] by L245 , L236 , L238 , L241 , L243 , L244 , XREGULAR:9;
L247: C96 in { 2 , C96 } by TARSKI:def 2;
L248: { 2 , C96 } in [ 2 , C96 ] by TARSKI:def 2;
L249: ( dom <* C95 , C96 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L250: 2 in ( dom <* C95 , C96 *> ) by L249 , FINSEQ_1:1;
L251: ( <* C95 , C96 *> . 2 ) = C96 by FINSEQ_1:44;
L252: [ 2 , C96 ] in <* C95 , C96 *> by L251 , L250 , FUNCT_1:1;
L253: C96 <> [ <* C95 , C96 *> , ( and2 ) ] by L252 , L244 , L245 , L247 , L248 , XREGULAR:9;
L254: ( dom <* C94 , C95 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L255: 2 in ( dom <* C94 , C95 *> ) by L254 , FINSEQ_1:1;
L256: ( <* C94 , C95 *> . 2 ) = C95 by FINSEQ_1:44;
L257: [ 2 , C95 ] in <* C94 , C95 *> by L256 , L255 , FUNCT_1:1;
L258: <* C94 , C95 *> in { <* C94 , C95 *> } by TARSKI:def 1;
L259: { <* C94 , C95 *> } in [ <* C94 , C95 *> , ( and2a ) ] by TARSKI:def 2;
L260: C95 <> [ <* C94 , C95 *> , ( and2a ) ] by L259 , L237 , L239 , L257 , L258 , XREGULAR:9;
L261: (not [ <* C94 , C95 *> , ( and2a ) ] in { C95 , C96 }) by L260 , L234 , TARSKI:def 2;
L262: C94 in { 1 , C94 } by TARSKI:def 2;
L263: { 1 , C94 } in [ 1 , C94 ] by TARSKI:def 2;
L264: <* C94 , C95 *> = ( <* C94 *> ^ <* C95 *> ) by FINSEQ_1:def 9;
L265: <* C94 *> c= <* C94 , C95 *> by L264 , FINSEQ_6:10;
L266: <* C94 *> = { [ 1 , C94 ] } by FINSEQ_1:def 5;
L267: [ 1 , C94 ] in <* C94 *> by L266 , TARSKI:def 1;
L268: <* C94 , C95 *> in { <* C94 , C95 *> } by TARSKI:def 1;
L269: { <* C94 , C95 *> } in [ <* C94 , C95 *> , ( and2a ) ] by TARSKI:def 2;
L270: C94 <> [ <* C94 , C95 *> , ( and2a ) ] by L269 , L262 , L263 , L265 , L267 , L268 , XREGULAR:9;
L271: (not C96 in { [ <* C94 , C95 *> , ( and2a ) ] , [ <* C95 , C96 *> , ( and2 ) ] }) by L234 , L253 , TARSKI:def 2;
L272: (not C94 in { [ <* C94 , C95 *> , ( and2a ) ] , [ <* C95 , C96 *> , ( and2 ) ] }) by L232 , L270 , TARSKI:def 2;
L273: C96 in { 2 , C96 } by TARSKI:def 2;
L274: { 2 , C96 } in [ 2 , C96 ] by TARSKI:def 2;
L275: ( dom <* C94 , C96 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L276: 2 in ( dom <* C94 , C96 *> ) by L275 , FINSEQ_1:1;
L277: ( <* C94 , C96 *> . 2 ) = C96 by FINSEQ_1:44;
L278: [ 2 , C96 ] in <* C94 , C96 *> by L277 , L276 , FUNCT_1:1;
L279: <* C94 , C96 *> in { <* C94 , C96 *> } by TARSKI:def 1;
L280: { <* C94 , C96 *> } in [ <* C94 , C96 *> , ( and2a ) ] by TARSKI:def 2;
L281: C96 <> [ <* C94 , C96 *> , ( and2a ) ] by L280 , L273 , L274 , L278 , L279 , XREGULAR:9;
L282: C94 in { 1 , C94 } by TARSKI:def 2;
L283: { 1 , C94 } in [ 1 , C94 ] by TARSKI:def 2;
L284: <* C94 , C96 *> = ( <* C94 *> ^ <* C96 *> ) by FINSEQ_1:def 9;
L285: <* C94 *> c= <* C94 , C96 *> by L284 , FINSEQ_6:10;
L286: <* C94 *> = { [ 1 , C94 ] } by FINSEQ_1:def 5;
L287: [ 1 , C94 ] in <* C94 *> by L286 , TARSKI:def 1;
L288: <* C94 , C96 *> in { <* C94 , C96 *> } by TARSKI:def 1;
L289: { <* C94 , C96 *> } in [ <* C94 , C96 *> , ( and2a ) ] by TARSKI:def 2;
L290: C94 <> [ <* C94 , C96 *> , ( and2a ) ] by L289 , L282 , L283 , L285 , L287 , L288 , XREGULAR:9;
L291: (not [ <* C94 , C96 *> , ( and2a ) ] in { C94 , C95 , C96 }) by L290 , L233 , L281 , ENUMSET1:def 1;
L292: ( InputVertices ( BorrowIStr (C94 , C95 , C96) ) ) = ( ( ( InputVertices ( ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) +* ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( InnerVertices ( ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) +* ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( InnerVertices ( ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) +* ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by L235 , CIRCCOMB:11
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ ( InnerVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( ( InnerVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \/ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( { [ <* C94 , C95 *> , ( and2a ) ] } \/ ( InnerVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) ) ) ) by CIRCCOMB:42
.= ( ( ( ( ( InputVertices ( 1GateCircStr (<* C94 , C95 *> , ( and2a )) ) ) \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( { [ <* C94 , C95 *> , ( and2a ) ] } \/ { [ <* C95 , C96 *> , ( and2 ) ] } ) ) ) by CIRCCOMB:42
.= ( ( ( ( { C94 , C95 } \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C95 , C96 *> , ( and2 )) ) ) \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( { [ <* C94 , C95 *> , ( and2a ) ] } \/ { [ <* C95 , C96 *> , ( and2 ) ] } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C94 , C95 } \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( { C95 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( ( InputVertices ( 1GateCircStr (<* C94 , C96 *> , ( and2a )) ) ) \ ( { [ <* C94 , C95 *> , ( and2a ) ] } \/ { [ <* C95 , C96 *> , ( and2 ) ] } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C94 , C95 } \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( { C95 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( { C94 , C96 } \ ( { [ <* C94 , C95 *> , ( and2a ) ] } \/ { [ <* C95 , C96 *> , ( and2 ) ] } ) ) ) by FACIRC_1:40
.= ( ( ( ( { C94 , C95 } \ { [ <* C95 , C96 *> , ( and2 ) ] } ) \/ ( { C95 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( { C94 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] , [ <* C95 , C96 *> , ( and2 ) ] } ) ) by ENUMSET1:1
.= ( ( ( { C94 , C95 } \/ ( { C95 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] } ) ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( { C94 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] , [ <* C95 , C96 *> , ( and2 ) ] } ) ) by L232 , L246 , FACIRC_2:1
.= ( ( ( { C94 , C95 } \/ { C95 , C96 } ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ ( { C94 , C96 } \ { [ <* C94 , C95 *> , ( and2a ) ] , [ <* C95 , C96 *> , ( and2 ) ] } ) ) by L261 , ZFMISC_1:57
.= ( ( ( { C94 , C95 } \/ { C95 , C96 } ) \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ { C94 , C96 } ) by L271 , L272 , ZFMISC_1:63
.= ( ( { C94 , C95 , C95 , C96 } \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ { C94 , C96 } ) by ENUMSET1:5
.= ( ( { C95 , C95 , C94 , C96 } \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ { C94 , C96 } ) by ENUMSET1:67
.= ( ( { C95 , C94 , C96 } \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ { C94 , C96 } ) by ENUMSET1:31
.= ( ( { C94 , C95 , C96 } \ { [ <* C94 , C96 *> , ( and2a ) ] } ) \/ { C94 , C96 } ) by ENUMSET1:58
.= ( { C94 , C95 , C96 } \/ { C94 , C96 } ) by L291 , ZFMISC_1:57
.= { C94 , C95 , C96 , C96 , C94 } by ENUMSET1:9
.= ( { C94 , C95 , C96 , C96 } \/ { C94 } ) by ENUMSET1:10
.= ( { C96 , C96 , C94 , C95 } \/ { C94 } ) by ENUMSET1:73
.= ( { C96 , C94 , C95 } \/ { C94 } ) by ENUMSET1:31
.= { C96 , C94 , C95 , C94 } by ENUMSET1:6
.= { C94 , C94 , C95 , C96 } by ENUMSET1:70
.= { C94 , C95 , C96 } by ENUMSET1:31;
thus L293: thesis by L292;
end;
theorem
L294: (for B222 , B223 , B224 being set holds ( InnerVertices ( BorrowStr (B222 , B223 , B224) ) ) = ( { [ <* B222 , B223 *> , ( and2a ) ] , [ <* B223 , B224 *> , ( and2 ) ] , [ <* B222 , B224 *> , ( and2a ) ] } \/ { ( BorrowOutput (B222 , B223 , B224) ) } ))
proof
let C97 , C98 , C99 being set;
set D20 = [ <* C97 , C98 *> , ( and2a ) ];
set D21 = [ <* C98 , C99 *> , ( and2 ) ];
set D22 = [ <* C97 , C99 *> , ( and2a ) ];
set D23 = ( 1GateCircStr (<* C97 , C98 *> , ( and2a )) );
set D24 = ( 1GateCircStr (<* C98 , C99 *> , ( and2 )) );
set D25 = ( 1GateCircStr (<* C97 , C99 *> , ( and2a )) );
set D26 = ( 1GateCircStr (<* [ <* C97 , C98 *> , ( and2a ) ] , [ <* C98 , C99 *> , ( and2 ) ] , [ <* C97 , C99 *> , ( and2a ) ] *> , ( or3 )) );
L295: D23 tolerates ( ( D24 +* D25 ) +* D26 ) by CIRCCOMB:47;
L296: D24 tolerates ( D25 +* D26 ) by CIRCCOMB:47;
L297: D25 tolerates D26 by CIRCCOMB:47;
L298: ( InnerVertices ( D24 +* ( D25 +* D26 ) ) ) = ( ( InnerVertices D24 ) \/ ( InnerVertices ( D25 +* D26 ) ) ) by L296 , CIRCCOMB:11;
L299: ( InnerVertices ( D25 +* D26 ) ) = ( ( InnerVertices D25 ) \/ ( InnerVertices D26 ) ) by L297 , CIRCCOMB:11;
thus L300: ( InnerVertices ( BorrowStr (C97 , C98 , C99) ) ) = ( InnerVertices ( ( D23 +* ( D24 +* D25 ) ) +* D26 ) ) by CIRCCOMB:6
.= ( InnerVertices ( D23 +* ( ( D24 +* D25 ) +* D26 ) ) ) by CIRCCOMB:6
.= ( ( InnerVertices D23 ) \/ ( InnerVertices ( ( D24 +* D25 ) +* D26 ) ) ) by L295 , CIRCCOMB:11
.= ( ( InnerVertices D23 ) \/ ( InnerVertices ( D24 +* ( D25 +* D26 ) ) ) ) by CIRCCOMB:6
.= ( ( ( InnerVertices D23 ) \/ ( InnerVertices D24 ) ) \/ ( ( InnerVertices D25 ) \/ ( InnerVertices D26 ) ) ) by L298 , L299 , XBOOLE_1:4
.= ( ( ( ( InnerVertices D23 ) \/ ( InnerVertices D24 ) ) \/ ( InnerVertices D25 ) ) \/ ( InnerVertices D26 ) ) by XBOOLE_1:4
.= ( ( ( { D20 } \/ ( InnerVertices D24 ) ) \/ ( InnerVertices D25 ) ) \/ ( InnerVertices D26 ) ) by CIRCCOMB:42
.= ( ( ( { D20 } \/ { D21 } ) \/ ( InnerVertices D25 ) ) \/ ( InnerVertices D26 ) ) by CIRCCOMB:42
.= ( ( ( { D20 } \/ { D21 } ) \/ { D22 } ) \/ ( InnerVertices D26 ) ) by CIRCCOMB:42
.= ( ( { D20 , D21 } \/ { D22 } ) \/ ( InnerVertices D26 ) ) by ENUMSET1:1
.= ( { D20 , D21 , D22 } \/ ( InnerVertices D26 ) ) by ENUMSET1:3
.= ( { D20 , D21 , D22 } \/ { ( BorrowOutput (C97 , C98 , C99) ) } ) by CIRCCOMB:42;
end;
theorem
L301: (for B225 , B226 , B227 being set holds ((B225 <> [ <* B226 , B227 *> , ( and2 ) ] & B226 <> [ <* B225 , B227 *> , ( and2a ) ] & B227 <> [ <* B225 , B226 *> , ( and2a ) ]) implies ( InputVertices ( BorrowStr (B225 , B226 , B227) ) ) = { B225 , B226 , B227 }))
proof
let C100 , C101 , C102 being set;
set D27 = [ <* C100 , C101 *> , ( and2a ) ];
set D28 = [ <* C101 , C102 *> , ( and2 ) ];
set D29 = [ <* C100 , C102 *> , ( and2a ) ];
set D30 = ( 1GateCircStr (<* D27 , D28 , D29 *> , ( or3 )) );
L302: ( InnerVertices D30 ) = { [ <* D27 , D28 , D29 *> , ( or3 ) ] } by CIRCCOMB:42;
L303: ( InputVertices D30 ) = ( rng <* D27 , D28 , D29 *> ) by CIRCCOMB:42
.= { D27 , D28 , D29 } by FINSEQ_2:128;
set D31 = ( BorrowIStr (C100 , C101 , C102) );
assume that
L304: C100 <> D28
and
L305: C101 <> D29
and
L306: C102 <> D27;
L307: ( rng <* C100 , C102 *> ) = { C100 , C102 } by FINSEQ_2:127;
L308: C100 in ( rng <* C100 , C102 *> ) by L307 , TARSKI:def 2;
L309: ( len <* D27 , D28 , D29 *> ) = 3 by FINSEQ_1:45;
L310: ( Seg 3 ) = ( dom <* D27 , D28 , D29 *> ) by L309 , FINSEQ_1:def 3;
L311: 3 in ( dom <* D27 , D28 , D29 *> ) by L310 , FINSEQ_1:1;
L312: ( <* D27 , D28 , D29 *> . 3 ) = D29 by FINSEQ_1:45;
L313: [ 3 , D29 ] in <* D27 , D28 , D29 *> by L312 , L311 , FUNCT_1:1;
L314: D29 in ( rng <* D27 , D28 , D29 *> ) by L313 , XTUPLE_0:def 13;
L315: ( the_rank_of D29 ) in ( the_rank_of [ <* D27 , D28 , D29 *> , ( or3 ) ] ) by L314 , CLASSES1:82;
L316: ( rng <* C100 , C101 *> ) = { C100 , C101 } by FINSEQ_2:127;
L317: C101 in ( rng <* C100 , C101 *> ) by L316 , TARSKI:def 2;
L318: 1 in ( dom <* D27 , D28 , D29 *> ) by L310 , FINSEQ_1:1;
L319: ( <* D27 , D28 , D29 *> . 1 ) = D27 by FINSEQ_1:45;
L320: [ 1 , D27 ] in <* D27 , D28 , D29 *> by L319 , L318 , FUNCT_1:1;
L321: D27 in ( rng <* D27 , D28 , D29 *> ) by L320 , XTUPLE_0:def 13;
L322: ( the_rank_of D27 ) in ( the_rank_of [ <* D27 , D28 , D29 *> , ( or3 ) ] ) by L321 , CLASSES1:82;
L323: ( rng <* C101 , C102 *> ) = { C101 , C102 } by FINSEQ_2:127;
L324: C102 in ( rng <* C101 , C102 *> ) by L323 , TARSKI:def 2;
L325: 2 in ( dom <* D27 , D28 , D29 *> ) by L310 , FINSEQ_1:1;
L326: ( <* D27 , D28 , D29 *> . 2 ) = D28 by FINSEQ_1:45;
L327: [ 2 , D28 ] in <* D27 , D28 , D29 *> by L326 , L325 , FUNCT_1:1;
L328: D28 in ( rng <* D27 , D28 , D29 *> ) by L327 , XTUPLE_0:def 13;
L329: ( the_rank_of D28 ) in ( the_rank_of [ <* D27 , D28 , D29 *> , ( or3 ) ] ) by L328 , CLASSES1:82;
L330: ( { D27 , D28 , D29 } \ { D27 , D28 , D29 } ) = ( {} ) by XBOOLE_1:37;
L331: ( { C100 , C101 , C102 } \ { [ <* D27 , D28 , D29 *> , ( or3 ) ] } ) = { C100 , C101 , C102 }
proof
thus L332: ( { C100 , C101 , C102 } \ { [ <* D27 , D28 , D29 *> , ( or3 ) ] } ) c= { C100 , C101 , C102 };
let C103 being set;
assume L333: C103 in { C100 , C101 , C102 };
L334: (C103 = C100 or C103 = C101 or C103 = C102) by L333 , ENUMSET1:def 1;
L335: C103 <> [ <* D27 , D28 , D29 *> , ( or3 ) ] by L334 , L308 , L315 , L317 , L322 , L324 , L329 , CLASSES1:82;
L336: (not C103 in { [ <* D27 , D28 , D29 *> , ( or3 ) ] }) by L335 , TARSKI:def 1;
thus L337: thesis by L336 , L333 , XBOOLE_0:def 5;
end;
thus L338: ( InputVertices ( BorrowStr (C100 , C101 , C102) ) ) = ( ( ( InputVertices D31 ) \ ( InnerVertices D30 ) ) \/ ( ( InputVertices D30 ) \ ( InnerVertices D31 ) ) ) by CIRCCMB2:5 , CIRCCOMB:47
.= ( { C100 , C101 , C102 } \/ ( { D27 , D28 , D29 } \ ( InnerVertices D31 ) ) ) by L302 , L303 , L304 , L305 , L306 , L331 , L231
.= ( { C100 , C101 , C102 } \/ ( {} ) ) by L330 , L226
.= { C100 , C101 , C102 };
end;
theorem
L339: (for B228 , B229 , B230 being set holds ((B228 <> [ <* B229 , B230 *> , ( and2 ) ] & B229 <> [ <* B228 , B230 *> , ( and2a ) ] & B230 <> [ <* B228 , B229 *> , ( and2a ) ] & B230 <> [ <* B228 , B229 *> , ( 'xor' ) ]) implies ( InputVertices ( BitSubtracterWithBorrowStr (B228 , B229 , B230) ) ) = { B228 , B229 , B230 }))
proof
let C104 , C105 , C106 being set;
assume that
L340: C104 <> [ <* C105 , C106 *> , ( and2 ) ]
and
L341: C105 <> [ <* C104 , C106 *> , ( and2a ) ]
and
L342: C106 <> [ <* C104 , C105 *> , ( and2a ) ]
and
L343: C106 <> [ <* C104 , C105 *> , ( 'xor' ) ];
L344: ( InputVertices ( 2GatesCircStr (C104 , C105 , C106 , ( 'xor' )) ) ) = { C104 , C105 , C106 } by L343 , FACIRC_1:57;
L345: ( InputVertices ( BorrowStr (C104 , C105 , C106) ) ) = { C104 , C105 , C106 } by L340 , L341 , L342 , L301;
thus L346: thesis by L345 , L344 , CIRCCOMB:47 , FACIRC_2:21;
end;
theorem
L347: (for B231 , B232 , B233 being set holds ( InnerVertices ( BitSubtracterWithBorrowStr (B231 , B232 , B233) ) ) = ( ( { [ <* B231 , B232 *> , ( 'xor' ) ] , ( 2GatesCircOutput (B231 , B232 , B233 , ( 'xor' )) ) } \/ { [ <* B231 , B232 *> , ( and2a ) ] , [ <* B232 , B233 *> , ( and2 ) ] , [ <* B231 , B233 *> , ( and2a ) ] } ) \/ { ( BorrowOutput (B231 , B232 , B233) ) } ))
proof
let C107 , C108 , C109 being set;
L348: ( 2GatesCircStr (C107 , C108 , C109 , ( 'xor' )) ) tolerates ( BorrowStr (C107 , C108 , C109) ) by CIRCCOMB:47;
L349: ( InnerVertices ( BitSubtracterWithBorrowStr (C107 , C108 , C109) ) ) = ( ( InnerVertices ( 2GatesCircStr (C107 , C108 , C109 , ( 'xor' )) ) ) \/ ( InnerVertices ( BorrowStr (C107 , C108 , C109) ) ) ) by L348 , CIRCCOMB:11
.= ( { [ <* C107 , C108 *> , ( 'xor' ) ] , ( 2GatesCircOutput (C107 , C108 , C109 , ( 'xor' )) ) } \/ ( InnerVertices ( BorrowStr (C107 , C108 , C109) ) ) ) by FACIRC_1:56
.= ( { [ <* C107 , C108 *> , ( 'xor' ) ] , ( 2GatesCircOutput (C107 , C108 , C109 , ( 'xor' )) ) } \/ ( { [ <* C107 , C108 *> , ( and2a ) ] , [ <* C108 , C109 *> , ( and2 ) ] , [ <* C107 , C109 *> , ( and2a ) ] } \/ { ( BorrowOutput (C107 , C108 , C109) ) } ) ) by L294
.= ( ( { [ <* C107 , C108 *> , ( 'xor' ) ] , ( 2GatesCircOutput (C107 , C108 , C109 , ( 'xor' )) ) } \/ { [ <* C107 , C108 *> , ( and2a ) ] , [ <* C108 , C109 *> , ( and2 ) ] , [ <* C107 , C109 *> , ( and2a ) ] } ) \/ { ( BorrowOutput (C107 , C108 , C109) ) } ) by XBOOLE_1:4;
thus L350: thesis by L349;
end;
registration
let C110 being (Element of ( NAT ));
let C111 , C112 being FinSequence;
cluster ( C110 -BitBorrowOutput (C111 , C112) ) ->  pair;
coherence
proof
L351: (ex B234 being (ManySortedSet of ( NAT )) st (( ( 0 ) -BitBorrowOutput (C111 , C112) ) = ( B234 . ( 0 ) ) & ( B234 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] & (for B235 being Nat holds ( B234 . ( B235 + 1 ) ) = ( BorrowOutput (( C111 . ( B235 + 1 ) ) , ( C112 . ( B235 + 1 ) ) , ( B234 . B235 )) )))) by L17;
defpred S7[ (Element of ( NAT )) ] means ( $1 -BitBorrowOutput (C111 , C112) ) is  pair;
L352: S7[ ( 0 ) ] by L351;
L353: (for B236 being (Element of ( NAT )) holds (S7[ B236 ] implies S7[ ( B236 + 1 ) ]))
proof
let C113 being (Element of ( NAT ));
L354: ( ( C113 + 1 ) -BitBorrowOutput (C111 , C112) ) = ( BorrowOutput (( C111 . ( C113 + 1 ) ) , ( C112 . ( C113 + 1 ) ) , ( C113 -BitBorrowOutput (C111 , C112) )) ) by L169
.= [ <* [ <* ( C111 . ( C113 + 1 ) ) , ( C112 . ( C113 + 1 ) ) *> , ( and2a ) ] , [ <* ( C112 . ( C113 + 1 ) ) , ( C113 -BitBorrowOutput (C111 , C112) ) *> , ( and2 ) ] , [ <* ( C111 . ( C113 + 1 ) ) , ( C113 -BitBorrowOutput (C111 , C112) ) *> , ( and2a ) ] *> , ( or3 ) ];
thus L355: thesis by L354;
end;
L356: (for B237 being (Element of ( NAT )) holds S7[ B237 ]) from NAT_1:sch 1(L352 , L353);
thus L357: thesis by L356;
end;
end;
theorem
L359: (for B238 , B239 being FinSequence holds (for B240 being (Element of ( NAT )) holds ((( ( B240 -BitBorrowOutput (B238 , B239) ) `1 ) = ( <*> ) & ( ( B240 -BitBorrowOutput (B238 , B239) ) `2 ) = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) & ( proj1 ( ( B240 -BitBorrowOutput (B238 , B239) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) )) or (( card ( ( B240 -BitBorrowOutput (B238 , B239) ) `1 ) ) = 3 & ( ( B240 -BitBorrowOutput (B238 , B239) ) `2 ) = ( or3 ) & ( proj1 ( ( B240 -BitBorrowOutput (B238 , B239) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )))))
proof
let C114 , C115 being FinSequence;
defpred S8[ (Element of ( NAT )) ] means ((( ( $1 -BitBorrowOutput (C114 , C115) ) `1 ) = ( <*> ) & ( ( $1 -BitBorrowOutput (C114 , C115) ) `2 ) = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) & ( proj1 ( ( $1 -BitBorrowOutput (C114 , C115) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) )) or (( card ( ( $1 -BitBorrowOutput (C114 , C115) ) `1 ) ) = 3 & ( ( $1 -BitBorrowOutput (C114 , C115) ) `2 ) = ( or3 ) & ( proj1 ( ( $1 -BitBorrowOutput (C114 , C115) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )));
L360: ( dom ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) ) by FUNCOP_1:13;
L361: ( ( 0 ) -BitBorrowOutput (C114 , C115) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] by L87;
L362: S8[ ( 0 ) ] by L361 , L360 , MCART_1:7;
L363:
now
let C116 being (Element of ( NAT ));
assume L364: S8[ C116 ];
set D32 = ( C116 -BitBorrowOutput (C114 , C115) );
L365: ( ( C116 + 1 ) -BitBorrowOutput (C114 , C115) ) = ( BorrowOutput (( C114 . ( C116 + 1 ) ) , ( C115 . ( C116 + 1 ) ) , D32) ) by L169
.= [ <* [ <* ( C114 . ( C116 + 1 ) ) , ( C115 . ( C116 + 1 ) ) *> , ( and2a ) ] , [ <* ( C115 . ( C116 + 1 ) ) , D32 *> , ( and2 ) ] , [ <* ( C114 . ( C116 + 1 ) ) , D32 *> , ( and2a ) ] *> , ( or3 ) ];
L366: ( dom ( or3 ) ) = ( 3 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L367: ( ( ( C116 + 1 ) -BitBorrowOutput (C114 , C115) ) `1 ) = <* [ <* ( C114 . ( C116 + 1 ) ) , ( C115 . ( C116 + 1 ) ) *> , ( and2a ) ] , [ <* ( C115 . ( C116 + 1 ) ) , D32 *> , ( and2 ) ] , [ <* ( C114 . ( C116 + 1 ) ) , D32 *> , ( and2a ) ] *> by L365 , MCART_1:7;
thus L368: S8[ ( C116 + 1 ) ] by L367 , L365 , L366 , FINSEQ_1:45 , MCART_1:7;
end;
thus L369: (for B241 being (Element of ( NAT )) holds S8[ B241 ]) from NAT_1:sch 1(L362 , L363);
end;
theorem
L370: (for B242 being (Element of ( NAT )) holds (for B243 , B244 being FinSequence holds (for B245 being set holds (( B242 -BitBorrowOutput (B243 , B244) ) <> [ B245 , ( and2 ) ] & ( B242 -BitBorrowOutput (B243 , B244) ) <> [ B245 , ( and2a ) ] & ( B242 -BitBorrowOutput (B243 , B244) ) <> [ B245 , ( 'xor' ) ]))))
proof
let C117 being (Element of ( NAT ));
let C118 , C119 being FinSequence;
let C120 being set;
L371: ( dom ( and2 ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L372: ( dom ( and2a ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L373: ( dom ( 'xor' ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by FUNCT_2:def 1;
L374: ( proj1 ( [ C120 , ( and2 ) ] `2 ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by L371;
L375: ( proj1 ( [ C120 , ( and2a ) ] `2 ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by L372;
L376: ( proj1 ( [ C120 , ( 'xor' ) ] `2 ) ) = ( 2 -tuples_on ( BOOLEAN ) ) by L373;
L377: (( proj1 ( ( C117 -BitBorrowOutput (C118 , C119) ) `2 ) ) = ( ( 0 ) -tuples_on ( BOOLEAN ) ) or ( proj1 ( ( C117 -BitBorrowOutput (C118 , C119) ) `2 ) ) = ( 3 -tuples_on ( BOOLEAN ) )) by L359;
thus L378: thesis by L377 , L374 , L375 , L376 , FINSEQ_2:110;
end;
theorem
L379: (for B246 , B247 being  nonpair-yielding FinSequence holds (for B248 being (Element of ( NAT )) holds (( InputVertices ( ( B248 + 1 ) -BitSubtracterStr (B246 , B247) ) ) = ( ( InputVertices ( B248 -BitSubtracterStr (B246 , B247) ) ) \/ ( ( InputVertices ( BitSubtracterWithBorrowStr (( B246 . ( B248 + 1 ) ) , ( B247 . ( B248 + 1 ) ) , ( B248 -BitBorrowOutput (B246 , B247) )) ) ) \ { ( B248 -BitBorrowOutput (B246 , B247) ) } ) ) & ( InnerVertices ( B248 -BitSubtracterStr (B246 , B247) ) ) is Relation & ( InputVertices ( B248 -BitSubtracterStr (B246 , B247) ) ) is  without_pairs)))
proof
let C121 , C122 being  nonpair-yielding FinSequence;
deffunc H20(Nat) = ( $1 -BitSubtracterStr (C121 , C122) );
deffunc H21(set , Nat) = ( BitSubtracterWithBorrowStr (( C121 . ( $2 + 1 ) ) , ( C122 . ( $2 + 1 ) ) , $1) );
deffunc H22(Nat) = ( $1 -BitBorrowOutput (C121 , C122) );
consider C123 being (ManySortedSet of ( NAT )) such that L380: (for B249 being (Element of ( NAT )) holds ( C123 . B249 ) = H22(B249)) from PBOOLE:sch 5;
deffunc H23(Nat) = ( C123 . $1 );
deffunc H24(set , Nat) = ( BorrowOutput (( C121 . ( $2 + 1 ) ) , ( C122 . ( $2 + 1 ) ) , $1) );
set D33 = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) );
L381: ( ( 0 ) -BitSubtracterStr (C121 , C122) ) = ( 1GateCircStr (( <*> ) , D33) ) by L87;
L382: ( InnerVertices H20(( 0 )) ) is Relation by L381 , FACIRC_1:38;
L383: ( InputVertices H20(( 0 )) ) is  without_pairs by L381 , FACIRC_1:39;
L384: H23(( 0 )) = ( ( 0 ) -BitBorrowOutput (C121 , C122) ) by L380;
L385: ( C123 . ( 0 ) ) in ( InnerVertices H20(( 0 )) ) by L384;
L386: (for B250 being Nat holds (for B251 being set holds ( InnerVertices H21(B251 , B250) ) is Relation)) by FSCIRC_1:22;
L387:
now
let C124 being (Element of ( NAT ));
let C125 being set;
assume that
L388: C125 = H23(C124);
L389: H23(C124) = ( C124 -BitBorrowOutput (C121 , C122) ) by L380;
L390: C125 <> [ <* ( C121 . ( C124 + 1 ) ) , ( C122 . ( C124 + 1 ) ) *> , ( and2a ) ] by L389 , L388 , L370;
L391: C125 <> [ <* ( C121 . ( C124 + 1 ) ) , ( C122 . ( C124 + 1 ) ) *> , ( 'xor' ) ] by L388 , L389 , L370;
thus L392: ( InputVertices H21(C125 , C124) ) = { ( C121 . ( C124 + 1 ) ) , ( C122 . ( C124 + 1 ) ) , C125 } by L391 , L390 , L339;
end;
L393: (for B252 being Nat holds (for B253 being set holds (B253 = ( C123 . B252 ) implies ( ( InputVertices H21(B253 , B252) ) \ { B253 } ) is  without_pairs)))
proof
let C126 being Nat;
let C127 being set;
assume that
L394: C127 = H23(C126);
L395: C126 in ( NAT ) by ORDINAL1:def 12;
L396: ( InputVertices H21(C127 , C126) ) = { ( C121 . ( C126 + 1 ) ) , ( C122 . ( C126 + 1 ) ) , C127 } by L395 , L387 , L394;
thus L397: ( ( InputVertices H21(C127 , C126) ) \ { C127 } ) is  without_pairs
proof
let C128 being  pair set;
assume L398: C128 in ( ( InputVertices H21(C127 , C126) ) \ { C127 } );
L399: C128 in ( InputVertices H21(C127 , C126) ) by L398 , XBOOLE_0:def 5;
L400: (C128 = ( C121 . ( C126 + 1 ) ) or C128 = ( C122 . ( C126 + 1 ) ) or C128 = C127) by L399 , L396 , ENUMSET1:def 1;
L401: (not C128 in { C127 }) by L398 , XBOOLE_0:def 5;
thus L402: contradiction by L401 , L400 , TARSKI:def 1;
end;

end;
L398:
now
let C129 being Nat;
let C130 being non  empty ManySortedSign;
let C131 being set;
L399: C129 in ( NAT ) by ORDINAL1:def 12;
assume that
L400: C130 = H20(C129)
and
L401: C131 = ( C123 . C129 );
L402: C131 = ( C129 -BitBorrowOutput (C121 , C122) ) by L380 , L399 , L401;
L403: H23(( C129 + 1 )) = ( ( C129 + 1 ) -BitBorrowOutput (C121 , C122) ) by L380;
thus L404: H20(( C129 + 1 )) = ( C130 +* H21(C131 , C129) ) by L399 , L400 , L402 , L169;
thus L405: ( C123 . ( C129 + 1 ) ) = H24(C131 , C129) by L399 , L402 , L403 , L169;
L406: ( InputVertices H21(C131 , C129) ) = { ( C121 . ( C129 + 1 ) ) , ( C122 . ( C129 + 1 ) ) , C131 } by L387 , L399 , L401;
thus L407: C131 in ( InputVertices H21(C131 , C129) ) by L406 , ENUMSET1:def 1;
L408: ( InnerVertices H21(C131 , C129) ) = ( ( { [ <* ( C121 . ( C129 + 1 ) ) , ( C122 . ( C129 + 1 ) ) *> , ( 'xor' ) ] , ( 2GatesCircOutput (( C121 . ( C129 + 1 ) ) , ( C122 . ( C129 + 1 ) ) , C131 , ( 'xor' )) ) } \/ { [ <* ( C121 . ( C129 + 1 ) ) , ( C122 . ( C129 + 1 ) ) *> , ( and2a ) ] , [ <* ( C122 . ( C129 + 1 ) ) , C131 *> , ( and2 ) ] , [ <* ( C121 . ( C129 + 1 ) ) , C131 *> , ( and2a ) ] } ) \/ { ( BorrowOutput (( C121 . ( C129 + 1 ) ) , ( C122 . ( C129 + 1 ) ) , C131) ) } ) by L347;
L409: H24(C131 , C129) in { H24(C131 , C129) } by TARSKI:def 1;
thus L410: H24(C131 , C129) in ( InnerVertices H21(C131 , C129) ) by L409 , L408 , XBOOLE_0:def 3;
end;
L411: (for B254 being Nat holds (( InputVertices H20(( B254 + 1 )) ) = ( ( InputVertices H20(B254) ) \/ ( ( InputVertices H21(( C123 . B254 ) , B254) ) \ { ( C123 . B254 ) } ) ) & ( InnerVertices H20(B254) ) is Relation & ( InputVertices H20(B254) ) is  without_pairs)) from CIRCCMB2:sch 11(L382 , L383 , L385 , L386 , L393 , L398);
let C132 being (Element of ( NAT ));
L412: ( C123 . C132 ) = ( C132 -BitBorrowOutput (C121 , C122) ) by L380;
thus L413: thesis by L412 , L411;
end;
theorem
L414: (for B255 being (Element of ( NAT )) holds (for B256 , B257 being  nonpair-yielding (FinSeqLen of B255) holds ( InputVertices ( B255 -BitSubtracterStr (B256 , B257) ) ) = ( ( rng B256 ) \/ ( rng B257 ) )))
proof
defpred S9[ (Element of ( NAT )) ] means (for B258 , B259 being  nonpair-yielding (FinSeqLen of $1) holds ( InputVertices ( $1 -BitSubtracterStr (B258 , B259) ) ) = ( ( rng B258 ) \/ ( rng B259 ) ));
L415: S9[ ( 0 ) ]
proof
let C133 , C134 being  nonpair-yielding (FinSeqLen of ( 0 ));
set D34 = ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) );
L416: ( ( 0 ) -BitSubtracterStr (C133 , C134) ) = ( 1GateCircStr (( <*> ) , D34) ) by L87;
thus L417: ( InputVertices ( ( 0 ) -BitSubtracterStr (C133 , C134) ) ) = ( rng ( <*> ) ) by L416 , CIRCCOMB:42
.= ( ( rng C133 ) \/ ( rng C134 ) );
end;
L418: (for B260 being (Element of ( NAT )) holds (S9[ B260 ] implies S9[ ( B260 + 1 ) ]))
proof
let C135 being (Element of ( NAT ));
assume that
L419: S9[ C135 ];
let C136 , C137 being  nonpair-yielding (FinSeqLen of ( C135 + 1 ));
consider C138 being  nonpair-yielding (FinSeqLen of C135), C139 being non  pair set such that L420: C136 = ( C138 ^ <* C139 *> ) by FACIRC_2:34;
consider C140 being  nonpair-yielding (FinSeqLen of C135), C141 being non  pair set such that L421: C137 = ( C140 ^ <* C141 *> ) by FACIRC_2:34;
set D35 = ( ( C135 + 1 ) -BitSubtracterStr (C136 , C137) );
L422: 1 in ( Seg 1 ) by FINSEQ_1:1;
L423: 1 in ( dom <* C139 *> ) by L422 , FINSEQ_1:def 8;
L424: ( len C138 ) = C135 by CARD_1:def 7;
L425: ( C136 . ( C135 + 1 ) ) = ( <* C139 *> . 1 ) by L424 , L420 , L423 , FINSEQ_1:def 7
.= C139 by FINSEQ_1:def 8;
L426: 1 in ( dom <* C141 *> ) by L422 , FINSEQ_1:def 8;
L427: ( len C140 ) = C135 by CARD_1:def 7;
L428: ( C137 . ( C135 + 1 ) ) = ( <* C141 *> . 1 ) by L427 , L421 , L426 , FINSEQ_1:def 7
.= C141 by FINSEQ_1:def 8;
L429: { C139 , C141 , ( C135 -BitBorrowOutput (C136 , C137) ) } = { ( C135 -BitBorrowOutput (C136 , C137) ) , C139 , C141 } by ENUMSET1:59;
L430: ( rng C136 ) = ( ( rng C138 ) \/ ( rng <* C139 *> ) ) by L420 , FINSEQ_1:31
.= ( ( rng C138 ) \/ { C139 } ) by FINSEQ_1:38;
L431: ( rng C137 ) = ( ( rng C140 ) \/ ( rng <* C141 *> ) ) by L421 , FINSEQ_1:31
.= ( ( rng C140 ) \/ { C141 } ) by FINSEQ_1:38;
L432: ( C135 -BitBorrowOutput (C136 , C137) ) <> [ <* C139 , C141 *> , ( and2a ) ] by L370;
L433: ( C135 -BitBorrowOutput (C136 , C137) ) <> [ <* C139 , C141 *> , ( 'xor' ) ] by L370;
L434: C138 = ( C138 ^ ( {} ) ) by FINSEQ_1:34;
L435: C140 = ( C140 ^ ( {} ) ) by FINSEQ_1:34;
L436: ( C135 -BitSubtracterStr (C136 , C137) ) = ( C135 -BitSubtracterStr (C138 , C140) ) by L435 , L420 , L421 , L434 , L107;
thus L437: ( InputVertices D35 ) = ( ( InputVertices ( C135 -BitSubtracterStr (C138 , C140) ) ) \/ ( ( InputVertices ( BitSubtracterWithBorrowStr (C139 , C141 , ( C135 -BitBorrowOutput (C136 , C137) )) ) ) \ { ( C135 -BitBorrowOutput (C136 , C137) ) } ) ) by L436 , L425 , L428 , L379
.= ( ( ( rng C138 ) \/ ( rng C140 ) ) \/ ( ( InputVertices ( BitSubtracterWithBorrowStr (C139 , C141 , ( C135 -BitBorrowOutput (C136 , C137) )) ) ) \ { ( C135 -BitBorrowOutput (C136 , C137) ) } ) ) by L419
.= ( ( ( rng C138 ) \/ ( rng C140 ) ) \/ ( { C139 , C141 , ( C135 -BitBorrowOutput (C136 , C137) ) } \ { ( C135 -BitBorrowOutput (C136 , C137) ) } ) ) by L432 , L433 , L339
.= ( ( ( rng C138 ) \/ ( rng C140 ) ) \/ { C139 , C141 } ) by L429 , ENUMSET1:86
.= ( ( ( rng C138 ) \/ ( rng C140 ) ) \/ ( { C139 } \/ { C141 } ) ) by ENUMSET1:1
.= ( ( ( ( rng C138 ) \/ ( rng C140 ) ) \/ { C139 } ) \/ { C141 } ) by XBOOLE_1:4
.= ( ( ( ( rng C138 ) \/ { C139 } ) \/ ( rng C140 ) ) \/ { C141 } ) by XBOOLE_1:4
.= ( ( rng C136 ) \/ ( rng C137 ) ) by L430 , L431 , XBOOLE_1:4;
end;
thus L438: (for B261 being (Element of ( NAT )) holds S9[ B261 ]) from NAT_1:sch 1(L415 , L418);
end;
L439: (for B262 , B263 , B264 being set holds (for B265 being (State of ( BorrowCirc (B262 , B263 , B264) )) holds (for B266 , B267 , B268 being (Element of ( BOOLEAN )) holds ((B266 = ( B265 . B262 ) & B267 = ( B265 . B263 ) & B268 = ( B265 . B264 )) implies (( ( Following B265 ) . [ <* B262 , B263 *> , ( and2a ) ] ) = ( ( 'not' B266 ) '&' B267 ) & ( ( Following B265 ) . [ <* B263 , B264 *> , ( and2 ) ] ) = ( B267 '&' B268 ) & ( ( Following B265 ) . [ <* B262 , B264 *> , ( and2a ) ] ) = ( ( 'not' B266 ) '&' B268 ))))))
proof
let C142 , C143 , C144 being set;
let C145 being (State of ( BorrowCirc (C142 , C143 , C144) ));
let C146 , C147 , C148 being (Element of ( BOOLEAN ));
assume that
L440: C146 = ( C145 . C142 )
and
L441: C147 = ( C145 . C143 )
and
L442: C148 = ( C145 . C144 );
set D36 = ( BorrowStr (C142 , C143 , C144) );
L443: ( InnerVertices D36 ) = (the carrier' of D36) by FACIRC_1:37;
L444: ( dom C145 ) = (the carrier of D36) by CIRCUIT1:3;
L445: C142 in (the carrier of D36) by FSCIRC_1:6;
L446: C143 in (the carrier of D36) by FSCIRC_1:6;
L447: C144 in (the carrier of D36) by FSCIRC_1:6;
L448: [ <* C142 , C143 *> , ( and2a ) ] in ( InnerVertices ( BorrowStr (C142 , C143 , C144) ) ) by FSCIRC_1:7;
thus L449: ( ( Following C145 ) . [ <* C142 , C143 *> , ( and2a ) ] ) = ( ( and2a ) . ( C145 * <* C142 , C143 *> ) ) by L448 , L443 , FACIRC_1:35
.= ( ( and2a ) . <* C146 , C147 *> ) by L440 , L441 , L444 , L445 , L446 , FINSEQ_2:125
.= ( ( 'not' C146 ) '&' C147 ) by TWOSCOMP:def 2;
L450: [ <* C143 , C144 *> , ( and2 ) ] in ( InnerVertices ( BorrowStr (C142 , C143 , C144) ) ) by FSCIRC_1:7;
thus L451: ( ( Following C145 ) . [ <* C143 , C144 *> , ( and2 ) ] ) = ( ( and2 ) . ( C145 * <* C143 , C144 *> ) ) by L450 , L443 , FACIRC_1:35
.= ( ( and2 ) . <* C147 , C148 *> ) by L441 , L442 , L444 , L446 , L447 , FINSEQ_2:125
.= ( C147 '&' C148 ) by TWOSCOMP:def 1;
L452: [ <* C142 , C144 *> , ( and2a ) ] in ( InnerVertices ( BorrowStr (C142 , C143 , C144) ) ) by FSCIRC_1:7;
thus L453: ( ( Following C145 ) . [ <* C142 , C144 *> , ( and2a ) ] ) = ( ( and2a ) . ( C145 * <* C142 , C144 *> ) ) by L452 , L443 , FACIRC_1:35
.= ( ( and2a ) . <* C146 , C148 *> ) by L440 , L442 , L444 , L445 , L447 , FINSEQ_2:125
.= ( ( 'not' C146 ) '&' C148 ) by TWOSCOMP:def 2;
end;
theorem
L454: (for B269 , B270 , B271 being set holds (for B272 being (State of ( BorrowCirc (B269 , B270 , B271) )) holds (for B273 , B274 , B275 being (Element of ( BOOLEAN )) holds ((B273 = ( B272 . [ <* B269 , B270 *> , ( and2a ) ] ) & B274 = ( B272 . [ <* B270 , B271 *> , ( and2 ) ] ) & B275 = ( B272 . [ <* B269 , B271 *> , ( and2a ) ] )) implies ( ( Following B272 ) . ( BorrowOutput (B269 , B270 , B271) ) ) = ( ( B273 'or' B274 ) 'or' B275 )))))
proof
let C149 , C150 , C151 being set;
let C152 being (State of ( BorrowCirc (C149 , C150 , C151) ));
let C153 , C154 , C155 being (Element of ( BOOLEAN ));
assume that
L455: C153 = ( C152 . [ <* C149 , C150 *> , ( and2a ) ] )
and
L456: C154 = ( C152 . [ <* C150 , C151 *> , ( and2 ) ] )
and
L457: C155 = ( C152 . [ <* C149 , C151 *> , ( and2a ) ] );
set D37 = [ <* C149 , C150 *> , ( and2a ) ];
set D38 = [ <* C150 , C151 *> , ( and2 ) ];
set D39 = [ <* C149 , C151 *> , ( and2a ) ];
set D40 = ( BorrowStr (C149 , C150 , C151) );
L458: ( InnerVertices D40 ) = (the carrier' of D40) by FACIRC_1:37;
L459: ( dom C152 ) = (the carrier of D40) by CIRCUIT1:3;
reconsider D41 = D37 , D42 = D38 , D43 = D39 as (Element of ( InnerVertices D40 )) by FSCIRC_1:7;
thus L460: ( ( Following C152 ) . ( BorrowOutput (C149 , C150 , C151) ) ) = ( ( or3 ) . ( C152 * <* D41 , D42 , D43 *> ) ) by L458 , FACIRC_1:35
.= ( ( or3 ) . <* C153 , C154 , C155 *> ) by L455 , L456 , L457 , L459 , FINSEQ_2:126
.= ( ( C153 'or' C154 ) 'or' C155 ) by FACIRC_1:def 7;
end;
L461: (for B276 , B277 , B278 being set holds ((B276 <> [ <* B277 , B278 *> , ( and2 ) ] & B277 <> [ <* B276 , B278 *> , ( and2a ) ] & B278 <> [ <* B276 , B277 *> , ( and2a ) ]) implies (for B279 being (State of ( BorrowCirc (B276 , B277 , B278) )) holds (for B280 , B281 , B282 being (Element of ( BOOLEAN )) holds ((B280 = ( B279 . B276 ) & B281 = ( B279 . B277 ) & B282 = ( B279 . B278 )) implies (( ( Following (B279 , 2) ) . ( BorrowOutput (B276 , B277 , B278) ) ) = ( ( ( ( 'not' B280 ) '&' B281 ) 'or' ( B281 '&' B282 ) ) 'or' ( ( 'not' B280 ) '&' B282 ) ) & ( ( Following (B279 , 2) ) . [ <* B276 , B277 *> , ( and2a ) ] ) = ( ( 'not' B280 ) '&' B281 ) & ( ( Following (B279 , 2) ) . [ <* B277 , B278 *> , ( and2 ) ] ) = ( B281 '&' B282 ) & ( ( Following (B279 , 2) ) . [ <* B276 , B278 *> , ( and2a ) ] ) = ( ( 'not' B280 ) '&' B282 )))))))
proof
let C156 , C157 , C158 being set;
assume that
L462: C156 <> [ <* C157 , C158 *> , ( and2 ) ]
and
L463: C157 <> [ <* C156 , C158 *> , ( and2a ) ]
and
L464: C158 <> [ <* C156 , C157 *> , ( and2a ) ];
let C159 being (State of ( BorrowCirc (C156 , C157 , C158) ));
let C160 , C161 , C162 being (Element of ( BOOLEAN ));
assume that
L465: C160 = ( C159 . C156 )
and
L466: C161 = ( C159 . C157 )
and
L467: C162 = ( C159 . C158 );
set D44 = [ <* C156 , C157 *> , ( and2a ) ];
set D45 = [ <* C157 , C158 *> , ( and2 ) ];
set D46 = [ <* C156 , C158 *> , ( and2a ) ];
set D47 = ( BorrowStr (C156 , C157 , C158) );
reconsider D48 = C156 , D49 = C157 , D50 = C158 as (Vertex of D47) by FSCIRC_1:6;
L468: ( InputVertices D47 ) = { C156 , C157 , C158 } by L462 , L463 , L464 , L301;
L469: C156 in ( InputVertices D47 ) by L468 , ENUMSET1:def 1;
L470: C157 in ( InputVertices D47 ) by L468 , ENUMSET1:def 1;
L471: C158 in ( InputVertices D47 ) by L468 , ENUMSET1:def 1;
L472: ( ( Following C159 ) . D48 ) = ( C159 . C156 ) by L469 , CIRCUIT2:def 5;
L473: ( ( Following C159 ) . D49 ) = ( C159 . C157 ) by L470 , CIRCUIT2:def 5;
L474: ( ( Following C159 ) . D50 ) = ( C159 . C158 ) by L471 , CIRCUIT2:def 5;
L475: ( Following (C159 , 2) ) = ( Following ( Following C159 ) ) by FACIRC_1:15;
L476: ( ( Following C159 ) . D44 ) = ( ( 'not' C160 ) '&' C161 ) by L465 , L466 , L467 , L439;
L477: ( ( Following C159 ) . D45 ) = ( C161 '&' C162 ) by L465 , L466 , L467 , L439;
L478: ( ( Following C159 ) . D46 ) = ( ( 'not' C160 ) '&' C162 ) by L465 , L466 , L467 , L439;
thus L479: ( ( Following (C159 , 2) ) . ( BorrowOutput (C156 , C157 , C158) ) ) = ( ( ( ( 'not' C160 ) '&' C161 ) 'or' ( C161 '&' C162 ) ) 'or' ( ( 'not' C160 ) '&' C162 ) ) by L478 , L475 , L476 , L477 , L454;
thus L480: thesis by L465 , L466 , L467 , L472 , L473 , L474 , L475 , L439;
end;
theorem
L481: (for B283 , B284 , B285 being set holds ((B283 <> [ <* B284 , B285 *> , ( and2 ) ] & B284 <> [ <* B283 , B285 *> , ( and2a ) ] & B285 <> [ <* B283 , B284 *> , ( and2a ) ]) implies (for B286 being (State of ( BorrowCirc (B283 , B284 , B285) )) holds ( Following (B286 , 2) ) is  stable)))
proof
let C163 , C164 , C165 being set;
set D51 = ( BorrowStr (C163 , C164 , C165) );
assume that
L482: C163 <> [ <* C164 , C165 *> , ( and2 ) ]
and
L483: C164 <> [ <* C163 , C165 *> , ( and2a ) ]
and
L484: C165 <> [ <* C163 , C164 *> , ( and2a ) ];
let C166 being (State of ( BorrowCirc (C163 , C164 , C165) ));
L485: ( dom ( Following ( Following (C166 , 2) ) ) ) = (the carrier of D51) by CIRCUIT1:3;
L486: ( dom ( Following (C166 , 2) ) ) = (the carrier of D51) by CIRCUIT1:3;
reconsider D52 = C163 , D53 = C164 , D54 = C165 as (Vertex of D51) by FSCIRC_1:6;
set D55 = ( C166 . D52 );
set D56 = ( C166 . D53 );
set D57 = ( C166 . D54 );
set D58 = ( Following (C166 , 2) );
set D59 = ( Following D58 );
L487: D55 = ( C166 . C163 );
L488: D56 = ( C166 . C164 );
L489: D57 = ( C166 . C165 );
L490: ( D58 . ( BorrowOutput (C163 , C164 , C165) ) ) = ( ( ( ( 'not' D55 ) '&' D56 ) 'or' ( D56 '&' D57 ) ) 'or' ( ( 'not' D55 ) '&' D57 ) ) by L482 , L483 , L484 , L461;
L491: ( D58 . [ <* C163 , C164 *> , ( and2a ) ] ) = ( ( 'not' D55 ) '&' D56 ) by L482 , L483 , L484 , L489 , L461;
L492: ( D58 . [ <* C164 , C165 *> , ( and2 ) ] ) = ( D56 '&' D57 ) by L482 , L483 , L484 , L487 , L461;
L493: ( D58 . [ <* C163 , C165 *> , ( and2a ) ] ) = ( ( 'not' D55 ) '&' D57 ) by L482 , L483 , L484 , L488 , L461;
L494: D58 = ( Following ( Following C166 ) ) by FACIRC_1:15;
L495: ( InputVertices D51 ) = { C163 , C164 , C165 } by L482 , L483 , L484 , L301;
L496: C163 in ( InputVertices D51 ) by L495 , ENUMSET1:def 1;
L497: C164 in ( InputVertices D51 ) by L495 , ENUMSET1:def 1;
L498: C165 in ( InputVertices D51 ) by L495 , ENUMSET1:def 1;
L499: ( ( Following C166 ) . C163 ) = D55 by L496 , CIRCUIT2:def 5;
L500: ( ( Following C166 ) . C164 ) = D56 by L497 , CIRCUIT2:def 5;
L501: ( ( Following C166 ) . C165 ) = D57 by L498 , CIRCUIT2:def 5;
L502: ( D58 . C163 ) = D55 by L494 , L496 , L499 , CIRCUIT2:def 5;
L503: ( D58 . C164 ) = D56 by L494 , L497 , L500 , CIRCUIT2:def 5;
L504: ( D58 . C165 ) = D57 by L494 , L498 , L501 , CIRCUIT2:def 5;
L505:
now
let C167 being set;
assume L506: C167 in (the carrier of D51);
reconsider D60 = C167 as (Vertex of D51) by L506;
L507: D60 in ( ( InputVertices D51 ) \/ ( InnerVertices D51 ) ) by L506 , XBOOLE_1:45;
thus L508: ( D58 . C167 ) = ( D59 . C167 )
proof
per cases  by L507 , XBOOLE_0:def 3;
suppose L509: D60 in ( InputVertices D51 );

thus L510: thesis by L509 , CIRCUIT2:def 5;
end;
suppose L511: D60 in ( InnerVertices D51 );

L512: D60 in ( { [ <* C163 , C164 *> , ( and2a ) ] , [ <* C164 , C165 *> , ( and2 ) ] , [ <* C163 , C165 *> , ( and2a ) ] } \/ { ( BorrowOutput (C163 , C164 , C165) ) } ) by L511 , L294;
L513: (D60 in { [ <* C163 , C164 *> , ( and2a ) ] , [ <* C164 , C165 *> , ( and2 ) ] , [ <* C163 , C165 *> , ( and2a ) ] } or D60 in { ( BorrowOutput (C163 , C164 , C165) ) }) by L512 , XBOOLE_0:def 3;
L514: (D60 = [ <* C163 , C164 *> , ( and2a ) ] or D60 = [ <* C164 , C165 *> , ( and2 ) ] or D60 = [ <* C163 , C165 *> , ( and2a ) ] or D60 = ( BorrowOutput (C163 , C164 , C165) )) by L513 , ENUMSET1:def 1 , TARSKI:def 1;
thus L515: thesis by L514 , L490 , L491 , L492 , L493 , L502 , L503 , L504 , L439 , L454;
end;
end;

end;
thus L509: D58 = D59 by L505 , L485 , L486 , FUNCT_1:2;
end;
theorem
L510: (for B287 , B288 , B289 being set holds ((B287 <> [ <* B288 , B289 *> , ( and2 ) ] & B288 <> [ <* B287 , B289 *> , ( and2a ) ] & B289 <> [ <* B287 , B288 *> , ( and2a ) ] & B289 <> [ <* B287 , B288 *> , ( 'xor' ) ]) implies (for B290 being (State of ( BitSubtracterWithBorrowCirc (B287 , B288 , B289) )) holds (for B291 , B292 , B293 being (Element of ( BOOLEAN )) holds ((B291 = ( B290 . B287 ) & B292 = ( B290 . B288 ) & B293 = ( B290 . B289 )) implies (( ( Following (B290 , 2) ) . ( BitSubtracterOutput (B287 , B288 , B289) ) ) = ( ( B291 'xor' B292 ) 'xor' B293 ) & ( ( Following (B290 , 2) ) . ( BorrowOutput (B287 , B288 , B289) ) ) = ( ( ( ( 'not' B291 ) '&' B292 ) 'or' ( B292 '&' B293 ) ) 'or' ( ( 'not' B291 ) '&' B293 ) )))))))
proof
let C168 , C169 , C170 being set;
assume that
L511: C168 <> [ <* C169 , C170 *> , ( and2 ) ]
and
L512: C169 <> [ <* C168 , C170 *> , ( and2a ) ]
and
L513: C170 <> [ <* C168 , C169 *> , ( and2a ) ]
and
L514: C170 <> [ <* C168 , C169 *> , ( 'xor' ) ];
set D61 = ( 'xor' );
set D62 = ( 2GatesCircStr (C168 , C169 , C170 , ( 'xor' )) );
set D63 = ( BorrowStr (C168 , C169 , C170) );
set D64 = ( BitSubtracterWithBorrowCirc (C168 , C169 , C170) );
set D65 = ( BitSubtracterCirc (C168 , C169 , C170) );
set D66 = ( BorrowCirc (C168 , C169 , C170) );
let C171 being (State of D64);
let C172 , C173 , C174 being (Element of ( BOOLEAN ));
assume that
L515: C172 = ( C171 . C168 )
and
L516: C173 = ( C171 . C169 )
and
L517: C174 = ( C171 . C170 );
L518: C168 in (the carrier of D62) by FACIRC_1:60;
L519: C169 in (the carrier of D62) by FACIRC_1:60;
L520: C170 in (the carrier of D62) by FACIRC_1:60;
L521: C168 in (the carrier of D63) by FSCIRC_1:6;
L522: C169 in (the carrier of D63) by FSCIRC_1:6;
L523: C170 in (the carrier of D63) by FSCIRC_1:6;
reconsider D67 = ( C171 | (the carrier of D62) ) as (State of D65) by FACIRC_1:26;
reconsider D68 = ( C171 | (the carrier of D63) ) as (State of D66) by FACIRC_1:26;
reconsider D69 = C171 as (State of ( D65 +* D66 ));
L524: ( InputVertices D63 ) = { C168 , C169 , C170 } by L511 , L512 , L513 , L301;
L525: ( InnerVertices D62 ) misses ( InputVertices D62 ) by XBOOLE_1:79;
L526: ( InnerVertices D63 ) misses ( InputVertices D63 ) by XBOOLE_1:79;
L527: ( InnerVertices D62 ) misses ( InputVertices D63 ) by L514 , L524 , L525 , FACIRC_1:57;
L528: ( InnerVertices D63 ) misses ( InputVertices D62 ) by L514 , L524 , L526 , FACIRC_1:57;
L529: ( dom D67 ) = (the carrier of D62) by CIRCUIT1:3;
L530: C172 = ( D67 . C168 ) by L529 , L515 , L518 , FUNCT_1:47;
L531: C173 = ( D67 . C169 ) by L516 , L519 , L529 , FUNCT_1:47;
L532: C174 = ( D67 . C170 ) by L517 , L520 , L529 , FUNCT_1:47;
L533: ( ( Following (D69 , 2) ) . ( 2GatesCircOutput (C168 , C169 , C170 , D61) ) ) = ( ( Following (D67 , 2) ) . ( 2GatesCircOutput (C168 , C169 , C170 , D61) ) ) by L528 , FACIRC_1:32;
thus L534: ( ( Following (C171 , 2) ) . ( BitSubtracterOutput (C168 , C169 , C170) ) ) = ( ( C172 'xor' C173 ) 'xor' C174 ) by L533 , L514 , L530 , L531 , L532 , FACIRC_1:64;
L535: ( dom D68 ) = (the carrier of D63) by CIRCUIT1:3;
L536: C172 = ( D68 . C168 ) by L535 , L515 , L521 , FUNCT_1:47;
L537: C173 = ( D68 . C169 ) by L516 , L522 , L535 , FUNCT_1:47;
L538: C174 = ( D68 . C170 ) by L517 , L523 , L535 , FUNCT_1:47;
L539: ( ( Following (D69 , 2) ) . ( BorrowOutput (C168 , C169 , C170) ) ) = ( ( Following (D68 , 2) ) . ( BorrowOutput (C168 , C169 , C170) ) ) by L527 , FACIRC_1:33;
thus L540: thesis by L539 , L511 , L512 , L513 , L536 , L537 , L538 , L461;
end;
theorem
L541: (for B294 , B295 , B296 being set holds ((B294 <> [ <* B295 , B296 *> , ( and2 ) ] & B295 <> [ <* B294 , B296 *> , ( and2a ) ] & B296 <> [ <* B294 , B295 *> , ( and2a ) ] & B296 <> [ <* B294 , B295 *> , ( 'xor' ) ]) implies (for B297 being (State of ( BitSubtracterWithBorrowCirc (B294 , B295 , B296) )) holds ( Following (B297 , 2) ) is  stable)))
proof
let C175 , C176 , C177 being set;
assume that
L542: C175 <> [ <* C176 , C177 *> , ( and2 ) ]
and
L543: C176 <> [ <* C175 , C177 *> , ( and2a ) ]
and
L544: C177 <> [ <* C175 , C176 *> , ( and2a ) ]
and
L545: C177 <> [ <* C175 , C176 *> , ( 'xor' ) ];
set D70 = ( BitSubtracterWithBorrowStr (C175 , C176 , C177) );
set D71 = ( 2GatesCircStr (C175 , C176 , C177 , ( 'xor' )) );
set D72 = ( BorrowStr (C175 , C176 , C177) );
set D73 = ( BitSubtracterWithBorrowCirc (C175 , C176 , C177) );
set D74 = ( BitSubtracterCirc (C175 , C176 , C177) );
set D75 = ( BorrowCirc (C175 , C176 , C177) );
let C178 being (State of D73);
reconsider D76 = ( C178 | (the carrier of D71) ) as (State of D74) by FACIRC_1:26;
reconsider D77 = ( C178 | (the carrier of D72) ) as (State of D75) by FACIRC_1:26;
reconsider D78 = C178 as (State of ( D74 +* D75 ));
L546: ( InputVertices D72 ) = { C175 , C176 , C177 } by L542 , L543 , L544 , L301;
L547: ( InnerVertices D71 ) misses ( InputVertices D71 ) by XBOOLE_1:79;
L548: ( InnerVertices D72 ) misses ( InputVertices D72 ) by XBOOLE_1:79;
L549: ( InnerVertices D71 ) misses ( InputVertices D72 ) by L545 , L546 , L547 , FACIRC_1:57;
L550: ( InnerVertices D72 ) misses ( InputVertices D71 ) by L545 , L546 , L548 , FACIRC_1:57;
L551: ( Following (D76 , 2) ) = ( ( Following (D78 , 2) ) | (the carrier of D71) ) by L550 , FACIRC_1:30;
L552: ( Following (D76 , 3) ) = ( ( Following (D78 , 3) ) | (the carrier of D71) ) by L550 , FACIRC_1:30;
L553: ( Following (D77 , 2) ) = ( ( Following (D78 , 2) ) | (the carrier of D72) ) by L549 , FACIRC_1:31;
L554: ( Following (D77 , 3) ) = ( ( Following (D78 , 3) ) | (the carrier of D72) ) by L549 , FACIRC_1:31;
L555: ( Following (D76 , 2) ) is  stable by L545 , FACIRC_1:63;
L556: ( Following (D76 , 2) ) = ( Following ( Following (D76 , 2) ) ) by L555 , CIRCUIT2:def 6
.= ( Following (D76 , ( 2 + 1 )) ) by FACIRC_1:12;
L557: ( Following (D77 , 2) ) is  stable by L542 , L543 , L544 , L481;
L558: ( Following (D77 , 2) ) = ( Following ( Following (D77 , 2) ) ) by L557 , CIRCUIT2:def 6
.= ( Following (D77 , ( 2 + 1 )) ) by FACIRC_1:12;
L559: ( Following (C178 , ( 2 + 1 )) ) = ( Following ( Following (C178 , 2) ) ) by FACIRC_1:12;
L560: ( dom ( Following (C178 , 2) ) ) = (the carrier of D70) by CIRCUIT1:3;
L561: ( dom ( Following (C178 , 3) ) ) = (the carrier of D70) by CIRCUIT1:3;
L562: ( dom ( Following (D76 , 2) ) ) = (the carrier of D71) by CIRCUIT1:3;
L563: ( dom ( Following (D77 , 2) ) ) = (the carrier of D72) by CIRCUIT1:3;
L564: (the carrier of D70) = ( (the carrier of D71) \/ (the carrier of D72) ) by CIRCCOMB:def 2;
L565:
now
let C179 being set;
assume L566: C179 in (the carrier of D70);
L567: (C179 in (the carrier of D71) or C179 in (the carrier of D72)) by L566 , L564 , XBOOLE_0:def 3;
L568: ((( ( Following (C178 , 2) ) . C179 ) = ( ( Following (D76 , 2) ) . C179 ) & ( ( Following (C178 , 3) ) . C179 ) = ( ( Following (D76 , 3) ) . C179 )) or (( ( Following (C178 , 2) ) . C179 ) = ( ( Following (D77 , 2) ) . C179 ) & ( ( Following (C178 , 3) ) . C179 ) = ( ( Following (D77 , 3) ) . C179 ))) by L567 , L551 , L552 , L553 , L554 , L556 , L558 , L562 , L563 , FUNCT_1:47;
thus L569: ( ( Following (C178 , 2) ) . C179 ) = ( ( Following ( Following (C178 , 2) ) ) . C179 ) by L568 , L556 , L558 , FACIRC_1:12;
end;
thus L570: ( Following (C178 , 2) ) = ( Following ( Following (C178 , 2) ) ) by L565 , L559 , L560 , L561 , FUNCT_1:2;
end;
theorem
L571: (for B298 being (Element of ( NAT )) holds (for B299 , B300 being  nonpair-yielding (FinSeqLen of B298) holds (for B301 being (State of ( B298 -BitSubtracterCirc (B299 , B300) )) holds ( Following (B301 , ( 1 + ( 2 * B298 ) )) ) is  stable)))
proof
let C180 being (Element of ( NAT ));
let C181 , C182 being  nonpair-yielding (FinSeqLen of C180);
deffunc H25(set , Nat) = ( BitSubtracterWithBorrowStr (( C181 . ( $2 + 1 ) ) , ( C182 . ( $2 + 1 ) ) , $1) );
deffunc H26(set , Nat) = ( BitSubtracterWithBorrowCirc (( C181 . ( $2 + 1 ) ) , ( C182 . ( $2 + 1 ) ) , $1) );
deffunc H27(set , Nat) = ( BorrowOutput (( C181 . ( $2 + 1 ) ) , ( C182 . ( $2 + 1 ) ) , $1) );
set D79 = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
set D80 = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) );
consider C183 being (Function of ( NAT ) , ( NAT )) such that L572: ( C183 . ( 0 ) ) = 1 and L573: ( C183 . 1 ) = 2 and L574: ( C183 . 2 ) = C180 by FACIRC_2:35;
deffunc H28((Element of ( NAT ))) = ( C183 . $1 );
L575: (for B302 being set holds (for B303 being Nat holds H26(B302 , B303) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of H25(B302 , B303))));
L576:
now
let C184 being (State of D80);
L577: ( Following (C184 , 1) ) = ( Following C184 ) by FACIRC_1:14;
thus L578: ( Following (C184 , H28(( 0 ))) ) is  stable by L577 , L572 , CIRCCMB2:2;
end;
deffunc H29((Element of ( NAT ))) = ( $1 -BitBorrowOutput (C181 , C182) );
consider C185 being (ManySortedSet of ( NAT )) such that L579: (for B304 being (Element of ( NAT )) holds ( C185 . B304 ) = H29(B304)) from PBOOLE:sch 5;
L580: (for B305 being Nat holds (for B306 being set holds (for B307 being  non-empty (Circuit of H25(B306 , B305)) holds ((B306 = ( C185 . B305 ) & B307 = H26(B306 , B305)) implies (for B308 being (State of B307) holds ( Following (B308 , H28(1)) ) is  stable)))))
proof
let C186 being Nat;
let C187 being set;
let C188 being  non-empty (Circuit of H25(C187 , C186));
L581: C186 in ( NAT ) by ORDINAL1:def 12;
assume L582: C187 = ( C185 . C186 );
L583: C187 = ( C186 -BitBorrowOutput (C181 , C182) ) by L582 , L579 , L581;
L584: C187 <> [ <* ( C181 . ( C186 + 1 ) ) , ( C182 . ( C186 + 1 ) ) *> , ( and2a ) ] by L583 , L581 , L370;
L585: C187 <> [ <* ( C181 . ( C186 + 1 ) ) , ( C182 . ( C186 + 1 ) ) *> , ( 'xor' ) ] by L581 , L583 , L370;
thus L586: thesis by L585 , L573 , L584 , L541;
end;
set D81 = ( C180 -BitSubtracterStr (C181 , C182) );
set D82 = ( C180 -BitSubtracterCirc (C181 , C182) );
set D83 = ( ( 0 ) -BitBorrowOutput (C181 , C182) );
consider C189 , C190 , C191 being (ManySortedSet of ( NAT )) such that L587: ( C180 -BitSubtracterStr (C181 , C182) ) = ( C189 . C180 ) and L588: ( C180 -BitSubtracterCirc (C181 , C182) ) = ( C190 . C180 ) and L589: ( C189 . ( 0 ) ) = ( 1GateCircStr (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L590: ( C190 . ( 0 ) ) = ( 1GateCircuit (( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) )) ) and L591: ( C191 . ( 0 ) ) = [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] and L592: (for B309 being Nat holds (for B310 being non  empty ManySortedSign holds (for B311 being  non-empty MSAlgebra over B310 holds (for B312 being set holds ((B310 = ( C189 . B309 ) & B311 = ( C190 . B309 ) & B312 = ( C191 . B309 )) implies (( C189 . ( B309 + 1 ) ) = ( B310 +* ( BitSubtracterWithBorrowStr (( C181 . ( B309 + 1 ) ) , ( C182 . ( B309 + 1 ) ) , B312) ) ) & ( C190 . ( B309 + 1 ) ) = ( B311 +* ( BitSubtracterWithBorrowCirc (( C181 . ( B309 + 1 ) ) , ( C182 . ( B309 + 1 ) ) , B312) ) ) & ( C191 . ( B309 + 1 ) ) = ( BorrowOutput (( C181 . ( B309 + 1 ) ) , ( C182 . ( B309 + 1 ) ) , B312) ))))))) by L8;
L593:
now
let C192 being set;
assume L594: C192 in ( NAT );
reconsider D84 = C192 as (Element of ( NAT )) by L594;
thus L595: ( C191 . C192 ) = ( D84 -BitBorrowOutput (C181 , C182) ) by L589 , L590 , L591 , L592 , L58
.= ( C185 . C192 ) by L579;
end;
L596: C191 = C185 by L593 , PBOOLE:3;
L597: (ex B313 , B314 being (ManySortedSet of ( NAT )) st (D81 = ( B313 . H28(2) ) & D82 = ( B314 . H28(2) ) & ( B313 . ( 0 ) ) = D79 & ( B314 . ( 0 ) ) = D80 & ( C185 . ( 0 ) ) = D83 & (for B315 being Nat holds (for B316 being non  empty ManySortedSign holds (for B317 being  non-empty MSAlgebra over B316 holds (for B318 being set holds (for B319 being  non-empty MSAlgebra over H25(B318 , B315) holds ((B316 = ( B313 . B315 ) & B317 = ( B314 . B315 ) & B318 = ( C185 . B315 ) & B319 = H26(B318 , B315)) implies (( B313 . ( B315 + 1 ) ) = ( B316 +* H25(B318 , B315) ) & ( B314 . ( B315 + 1 ) ) = ( B317 +* B319 ) & ( C185 . ( B315 + 1 ) ) = H27(B318 , B315))))))))))
proof
take C189;
take C190;
thus L598: thesis by L574 , L579 , L587 , L588 , L589 , L590 , L592 , L596;
end;
L599: (( InnerVertices D79 ) is Relation & ( InputVertices D79 ) is  without_pairs) by FACIRC_1:38 , FACIRC_1:39;
L600: [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] = D83 by L87;
L601: ( InnerVertices D79 ) = { [ ( <*> ) , ( ( ( 0 ) -tuples_on ( BOOLEAN ) ) --> ( TRUE ) ) ] } by CIRCCOMB:42;
L602: (( C185 . ( 0 ) ) = D83 & D83 in ( InnerVertices D79 )) by L601 , L579 , L600 , TARSKI:def 1;
L603: (for B320 being Nat holds (for B321 being set holds ( InnerVertices H25(B321 , B320) ) is Relation)) by FSCIRC_1:22;
L604: (for B322 being Nat holds (for B323 being set holds (B323 = ( C185 . B322 ) implies ( ( InputVertices H25(B323 , B322) ) \ { B323 } ) is  without_pairs)))
proof
let C193 being Nat;
let C194 being set;
assume that
L605: C194 = ( C185 . C193 );
L606: C193 in ( NAT ) by ORDINAL1:def 12;
L607: C194 = ( C193 -BitBorrowOutput (C181 , C182) ) by L606 , L579 , L605;
L608: C194 <> [ <* ( C181 . ( C193 + 1 ) ) , ( C182 . ( C193 + 1 ) ) *> , ( and2a ) ] by L607 , L606 , L370;
L609: C194 <> [ <* ( C181 . ( C193 + 1 ) ) , ( C182 . ( C193 + 1 ) ) *> , ( 'xor' ) ] by L606 , L607 , L370;
L610: ( InputVertices H25(C194 , C193) ) = { ( C181 . ( C193 + 1 ) ) , ( C182 . ( C193 + 1 ) ) , C194 } by L609 , L608 , L339;
let C195 being  pair set;
assume L611: C195 in ( ( InputVertices H25(C194 , C193) ) \ { C194 } );
L612: C195 in { ( C181 . ( C193 + 1 ) ) , ( C182 . ( C193 + 1 ) ) , C194 } by L611 , L610 , XBOOLE_0:def 5;
L613: (not C195 in { C194 }) by L611 , XBOOLE_0:def 5;
L614: (C195 = ( C181 . ( C193 + 1 ) ) or C195 = ( C182 . ( C193 + 1 ) ) or C195 = C194) by L612 , ENUMSET1:def 1;
thus L615: thesis by L614 , L613 , TARSKI:def 1;
end;
L616: (for B324 being Nat holds (for B325 being set holds (B325 = ( C185 . B324 ) implies (( C185 . ( B324 + 1 ) ) = H27(B325 , B324) & B325 in ( InputVertices H25(B325 , B324) ) & H27(B325 , B324) in ( InnerVertices H25(B325 , B324) )))))
proof
let C196 being Nat;
let C197 being set;
assume that
L617: C197 = ( C185 . C196 );
L618: C196 in ( NAT ) by ORDINAL1:def 12;
L619: C197 = ( C196 -BitBorrowOutput (C181 , C182) ) by L618 , L579 , L617;
L620: ( C185 . ( C196 + 1 ) ) = ( ( C196 + 1 ) -BitBorrowOutput (C181 , C182) ) by L579;
thus L621: ( C185 . ( C196 + 1 ) ) = H27(C197 , C196) by L620 , L618 , L619 , L169;
L622: C197 <> [ <* ( C181 . ( C196 + 1 ) ) , ( C182 . ( C196 + 1 ) ) *> , ( and2a ) ] by L618 , L619 , L370;
L623: C197 <> [ <* ( C181 . ( C196 + 1 ) ) , ( C182 . ( C196 + 1 ) ) *> , ( 'xor' ) ] by L618 , L619 , L370;
L624: ( InputVertices H25(C197 , C196) ) = { ( C181 . ( C196 + 1 ) ) , ( C182 . ( C196 + 1 ) ) , C197 } by L623 , L622 , L339;
thus L625: C197 in ( InputVertices H25(C197 , C196) ) by L624 , ENUMSET1:def 1;
set D85 = ( C181 . ( C196 + 1 ) );
set D86 = ( C182 . ( C196 + 1 ) );
L626: H27(C197 , C196) in { H27(C197 , C196) } by TARSKI:def 1;
L627: ( InnerVertices H25(C197 , C196) ) = ( ( { [ <* D85 , D86 *> , ( 'xor' ) ] , ( 2GatesCircOutput (D85 , D86 , C197 , ( 'xor' )) ) } \/ { [ <* D85 , D86 *> , ( and2a ) ] , [ <* D86 , C197 *> , ( and2 ) ] , [ <* D85 , C197 *> , ( and2a ) ] } ) \/ { ( BorrowOutput (D85 , D86 , C197) ) } ) by L347;
thus L628: thesis by L627 , L626 , XBOOLE_0:def 3;
end;
L629: (for B326 being (State of ( C180 -BitSubtracterCirc (C181 , C182) )) holds ( Following (B326 , ( H28(( 0 )) + ( H28(2) * H28(1) ) )) ) is  stable) from CIRCCMB2:sch 22(L575 , L576 , L580 , L597 , L599 , L602 , L603 , L604 , L616);
thus L630: thesis by L629 , L572 , L573 , L574;
end;
