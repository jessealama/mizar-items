:: Miscellaneous Facts about Functions
::  by Grzegorz Bancerek and Andrzej Trybulec
::
:: Received January 12, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, FUNCT_1, RELAT_1, TARSKI, XBOOLE_0, FUNCOP_1,
      PBOOLE, ZFMISC_1, FUNCT_4, FINSEQ_1, ARYTM_3, CARD_1, NAT_1, XXREAL_0,
      FINSET_1, SETFAM_1, FINSEQ_2, ORDINAL4, MCART_1, PARTFUN1, REWRITE1,
      FUNCT_2, ARYTM_1, RFINSEQ, CLASSES1, FUNCT_7, VALUED_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, ENUMSET1,
      XTUPLE_0, SUBSET_1, CARD_1, WELLORD2,
      NUMBERS, XCMPLX_0, XXREAL_0, ORDINAL1, NAT_1, SETFAM_1, PBOOLE, DOMAIN_1,
      RELAT_1, FUNCT_1, RELSET_1, BINOP_1, FINSET_1, PARTFUN1, FUNCOP_1,
      FUNCT_2, FINSEQ_1, FINSEQ_2, FUNCT_4, CLASSES1, RFINSEQ, NAT_D, REWRITE1,
      VALUED_1;
 constructors SETFAM_1, PARTFUN1, WELLORD2, BINOP_1, DOMAIN_1, FUNCT_4,
      XXREAL_0, NAT_1, INT_1, PBOOLE, RFINSEQ, NAT_D, REWRITE1, RELAT_2,
      REAL_1, CLASSES1, RELSET_1, VALUED_1, FINSEQ_2, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, PARTFUN1,
      FUNCOP_1, FUNCT_4, XREAL_0, NAT_1, INT_1, CARD_1, FINSEQ_1, FUNCT_2,
      RELSET_1, XXREAL_0, VALUED_1, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1, BINOP_1,
      FINSEQ_2, FUNCT_4, XTUPLE_0;
 theorems FINSEQ_1, RELAT_1, TARSKI, AXIOMS, ZFMISC_1, INT_1, FUNCT_1,
      FINSEQ_2, FUNCT_4, SUBSET_1, FINSET_1, CARD_1, NAT_1, FUNCT_2, FUNCOP_1,
      SETFAM_1, MCART_1, FINSEQ_3, ENUMSET1, REWRITE1, FINSEQ_4, RELSET_1,
      XBOOLE_0, XBOOLE_1, PARTFUN1, GRFUNC_1, XREAL_1, XXREAL_0, ORDINAL1,
      RFINSEQ, FINSEQ_5, NAT_D, WELLORD2, VALUED_1, XTUPLE_0;
 schemes NAT_1, DOMAIN_1, CLASSES1, FRAENKEL, FINSEQ_1, RECDEF_1, FUNCT_2;

begin
theorem
L1: (for B1 being Function holds (for B2 being set holds (( rng B1 ) c= B2 implies ( ( id B2 ) * B1 ) = B1)))
proof
let C1 being Function;
let C2 being set;
assume L2: ( rng C1 ) c= C2;
reconsider D1 = C1 as (Function of ( dom C1 ) , C2) by L2 , FUNCT_2:2;
L3: ( ( id C2 ) * D1 ) = D1 by FUNCT_2:17;
thus L4: thesis by L3;
end;
theorem
L5: (for B3 being set holds (for B4 being non  empty set holds (for B5 being (Function of B3 , B4) holds (B5 is  one-to-one implies (for B6 being (Subset of B3) holds (for B7 being (Subset of B4) holds (B7 c= ( B5 .: B6 ) implies ( B5 " B7 ) c= B6)))))))
proof
let C3 being set;
let C4 being non  empty set;
let C5 being (Function of C3 , C4);
assume that
L6: C5 is  one-to-one;
let C6 being (Subset of C3);
let C7 being (Subset of C4);
assume L7: C7 c= ( C5 .: C6 );
L8: ( C5 " C7 ) c= ( C5 " ( C5 .: C6 ) ) by L7 , RELAT_1:143;
L9: ( C5 " ( C5 .: C6 ) ) c= C6 by L6 , FUNCT_1:82;
thus L10: thesis by L9 , L8 , XBOOLE_1:1;
end;
theorem
L11: (for B8 , B9 being non  empty set holds (for B10 being (Function of B8 , B9) holds (B10 is  one-to-one implies (for B11 being (Element of B8) holds (for B12 being (Subset of B8) holds (( B10 . B11 ) in ( B10 .: B12 ) implies B11 in B12))))))
proof
let C8 , C9 being non  empty set;
let C10 being (Function of C8 , C9);
assume that
L12: C10 is  one-to-one;
let C11 being (Element of C8);
let C12 being (Subset of C8);
assume L13: ( C10 . C11 ) in ( C10 .: C12 );
L14: (ex B13 being (Element of C8) st (B13 in C12 & ( C10 . B13 ) = ( C10 . C11 ))) by L13 , FUNCT_2:65;
thus L15: thesis by L14 , L12 , FUNCT_2:19;
end;
theorem
L16: (for B14 , B15 being non  empty set holds (for B16 being (Function of B14 , B15) holds (B16 is  one-to-one implies (for B17 being (Element of B14) holds (for B18 being (Subset of B14) holds (for B19 being (Subset of B15) holds (( B16 . B17 ) in ( ( B16 .: B18 ) \ B19 ) implies B17 in ( B18 \ ( B16 " B19 ) ))))))))
proof
let C13 , C14 being non  empty set;
let C15 being (Function of C13 , C14);
assume that
L17: C15 is  one-to-one;
let C16 being (Element of C13);
let C17 being (Subset of C13);
let C18 being (Subset of C14);
assume L18: ( C15 . C16 ) in ( ( C15 .: C17 ) \ C18 );
L19:
now
assume L20: C16 in ( C15 " C18 );
L21: ( C15 . C16 ) in C18 by L20 , FUNCT_1:def 7;
thus L22: contradiction by L21 , L18 , XBOOLE_0:def 5;
end;
L23: ( C15 . C16 ) in ( C15 .: C17 ) by L18 , XBOOLE_0:def 5;
L24: C16 in C17 by L23 , L17 , L11;
thus L25: thesis by L24 , L19 , XBOOLE_0:def 5;
end;
theorem
L26: (for B20 , B21 being non  empty set holds (for B22 being (Function of B20 , B21) holds (B22 is  one-to-one implies (for B23 being (Element of B21) holds (for B24 being (Subset of B20) holds (for B25 being (Subset of B21) holds (B23 in ( ( B22 .: B24 ) \ B25 ) implies ( ( B22 " ) . B23 ) in ( B24 \ ( B22 " B25 ) ))))))))
proof
let C19 , C20 being non  empty set;
let C21 being (Function of C19 , C20);
assume that
L27: C21 is  one-to-one;
let C22 being (Element of C20);
let C23 being (Subset of C19);
let C24 being (Subset of C20);
assume L28: C22 in ( ( C21 .: C23 ) \ C24 );
L29: C22 in ( C21 .: C23 ) by L28 , XBOOLE_0:def 5;
L30: ( C21 .: C23 ) c= ( rng C21 ) by RELAT_1:111;
L31: ( ( C21 " ) . C22 ) in ( dom C21 ) by L30 , L27 , L29 , FUNCT_1:32;
reconsider D2 = ( ( C21 " ) . C22 ) as (Element of C19) by L31;
L32: C22 = ( C21 . D2 ) by L27 , L29 , L30 , FUNCT_1:35;
thus L33: thesis by L32 , L27 , L28 , L16;
end;
theorem
L34: (for B26 being Function holds (for B27 being set holds (B27 in ( dom B26 ) implies ( B26 | { B27 } ) = ( B27 .--> ( B26 . B27 ) ))))
proof
let C25 being Function;
let C26 being set;
assume L35: C26 in ( dom C25 );
thus L36: ( C25 | { C26 } ) = { [ C26 , ( C25 . C26 ) ] } by L35 , GRFUNC_1:28
.= ( C26 .--> ( C25 . C26 ) ) by ZFMISC_1:29;
end;
registration
let C27 , C28 being set;
cluster ( C27 .--> C28 ) -> non  empty;
coherence;
end;
registration
let C29 , C30 , C31 , C32 being set;
cluster ( (C29 , C30) --> (C31 , C32) ) -> non  empty;
coherence;
end;
theorem
L39: (for B28 being set holds (for B29 being (ManySortedSet of B28) holds (for B30 being set holds (B30 in B28 implies ( B30 .--> ( B29 . B30 ) ) = ( B29 | { B30 } )))))
proof
let C33 being set;
let C34 being (ManySortedSet of C33);
let C35 being set;
assume L40: C35 in C33;
L41: C35 in ( dom C34 ) by L40 , PARTFUN1:def 2;
thus L42: thesis by L41 , L34;
end;
theorem
L43: (for B31 , B32 being set holds (for B33 being (ManySortedSet of [: B31 , B32 :]) holds (for B34 , B35 being set holds ((B34 in B31 & B35 in B32) implies ( (B34 , B35) :-> ( B33 . (B34 , B35) ) ) = ( B33 | ([: { B34 } , { B35 } :] qua set) )))))
proof
let C36 , C37 being set;
let C38 being (ManySortedSet of [: C36 , C37 :]);
let C39 , C40 being set;
assume L44: (C39 in C36 & C40 in C37);
L45: [ C39 , C40 ] in [: C36 , C37 :] by L44 , ZFMISC_1:87;
thus L46: ( (C39 , C40) :-> ( C38 . (C39 , C40) ) ) = ( [ C39 , C40 ] .--> ( C38 . [ C39 , C40 ] ) )
.= ( C38 | ({ [ C39 , C40 ] } qua set) ) by L45 , L39
.= ( C38 | ([: { C39 } , { C40 } :] qua set) ) by ZFMISC_1:29;
end;
theorem
L47: (for B36 , B37 , B38 being Function holds (( rng B38 ) c= ( dom B36 ) implies ( B36 * ( B37 +* B38 ) ) = ( ( B36 * B37 ) +* ( B36 * B38 ) )))
proof
let C41 , C42 , C43 being Function;
assume that
L48: ( rng C43 ) c= ( dom C41 );
L49: ( dom C43 ) c= ( dom ( C42 +* C43 ) ) by FUNCT_4:10;
L50: ( dom C42 ) c= ( dom ( C42 +* C43 ) ) by FUNCT_4:10;
L51: ( dom ( C41 * ( C42 +* C43 ) ) ) = ( ( dom ( C41 * C42 ) ) \/ ( dom ( C41 * C43 ) ) )
proof
thus L52: ( dom ( C41 * ( C42 +* C43 ) ) ) c= ( ( dom ( C41 * C42 ) ) \/ ( dom ( C41 * C43 ) ) )
proof
let R2 being set;
assume L53: R2 in ( dom ( C41 * ( C42 +* C43 ) ) );
L54: ( ( C42 +* C43 ) . R2 ) in ( dom C41 ) by L53 , FUNCT_1:11;
L55: R2 in ( dom ( C42 +* C43 ) ) by L53 , FUNCT_1:11;
L56: R2 in ( ( dom C42 ) \/ ( dom C43 ) ) by L55 , FUNCT_4:def 1;
per cases ;
suppose L57: R2 in ( dom C43 );

L58: ( C43 . R2 ) in ( dom C41 ) by L57 , L54 , FUNCT_4:13;
L59: R2 in ( dom ( C41 * C43 ) ) by L58 , L57 , FUNCT_1:11;
thus L60: thesis by L59 , XBOOLE_0:def 3;
end;
suppose L61: (not R2 in ( dom C43 ));

L62: (( C42 . R2 ) in ( dom C41 ) & R2 in ( dom C42 )) by L61 , L56 , L54 , FUNCT_4:11 , XBOOLE_0:def 3;
L63: R2 in ( dom ( C41 * C42 ) ) by L62 , FUNCT_1:11;
thus L64: thesis by L63 , XBOOLE_0:def 3;
end;
end;

let R2 being set;
assume L66: R2 in ( ( dom ( C41 * C42 ) ) \/ ( dom ( C41 * C43 ) ) );
per cases ;
suppose L67: R2 in ( dom ( C41 * C43 ) );

L68: ( C43 . R2 ) in ( dom C41 ) by L67 , FUNCT_1:11;
L69: R2 in ( dom C43 ) by L67 , FUNCT_1:11;
L70: ( ( C42 +* C43 ) . R2 ) = ( C43 . R2 ) by L69 , FUNCT_4:13;
thus L71: thesis by L70 , L49 , L69 , L68 , FUNCT_1:11;
end;
suppose L72: (not R2 in ( dom ( C41 * C43 ) ));

L73: (R2 in ( dom C43 ) implies ( C43 . R2 ) in ( dom C41 ))
proof
assume L74: R2 in ( dom C43 );
L75: ( C43 . R2 ) in ( rng C43 ) by L74 , FUNCT_1:3;
thus L76: thesis by L75 , L48;
end;
L77: (not R2 in ( dom C43 )) by L73 , L72 , FUNCT_1:11;
L78: ( ( C42 +* C43 ) . R2 ) = ( C42 . R2 ) by L77 , FUNCT_4:11;
L79: R2 in ( dom ( C41 * C42 ) ) by L66 , L72 , XBOOLE_0:def 3;
L80: (( C42 . R2 ) in ( dom C41 ) & R2 in ( dom C42 )) by L79 , FUNCT_1:11;
thus L81: thesis by L80 , L50 , L78 , FUNCT_1:11;
end;
end;
L83:
now
let C44 being set;
assume L84: C44 in ( ( dom ( C41 * C42 ) ) \/ ( dom ( C41 * C43 ) ) );
thus L85: (C44 in ( dom ( C41 * C43 ) ) implies ( ( C41 * ( C42 +* C43 ) ) . C44 ) = ( ( C41 * C43 ) . C44 ))
proof
assume L86: C44 in ( dom ( C41 * C43 ) );
L87: C44 in ( dom C43 ) by L86 , FUNCT_1:11;
thus L88: ( ( C41 * ( C42 +* C43 ) ) . C44 ) = ( C41 . ( ( C42 +* C43 ) . C44 ) ) by L87 , L49 , FUNCT_1:13
.= ( C41 . ( C43 . C44 ) ) by L87 , FUNCT_4:13
.= ( ( C41 * C43 ) . C44 ) by L87 , FUNCT_1:13;
end;

assume L89: (not C44 in ( dom ( C41 * C43 ) ));
L90: (C44 in ( dom C43 ) implies ( C43 . C44 ) in ( dom C41 ))
proof
assume L91: C44 in ( dom C43 );
L92: ( C43 . C44 ) in ( rng C43 ) by L91 , FUNCT_1:3;
thus L93: thesis by L92 , L48;
end;
L94: (not C44 in ( dom C43 )) by L90 , L89 , FUNCT_1:11;
L95: C44 in ( dom ( C41 * C42 ) ) by L84 , L89 , XBOOLE_0:def 3;
L96: C44 in ( dom C42 ) by L95 , FUNCT_1:11;
thus L97: ( ( C41 * ( C42 +* C43 ) ) . C44 ) = ( C41 . ( ( C42 +* C43 ) . C44 ) ) by L96 , L50 , FUNCT_1:13
.= ( C41 . ( C42 . C44 ) ) by L94 , FUNCT_4:11
.= ( ( C41 * C42 ) . C44 ) by L96 , FUNCT_1:13;
end;
thus L98: thesis by L83 , L51 , FUNCT_4:def 1;
end;
theorem
L99: (for B39 , B40 , B41 being Function holds ( ( B40 +* B41 ) * B39 ) = ( ( B40 * B39 ) +* ( B41 * B39 ) ))
proof
let C45 , C46 , C47 being Function;
L100: ( dom ( ( C46 +* C47 ) * C45 ) ) = ( ( dom ( C46 * C45 ) ) \/ ( dom ( C47 * C45 ) ) )
proof
thus L101: ( dom ( ( C46 +* C47 ) * C45 ) ) c= ( ( dom ( C46 * C45 ) ) \/ ( dom ( C47 * C45 ) ) )
proof
let C48 being set;
assume L102: C48 in ( dom ( ( C46 +* C47 ) * C45 ) );
L103: ( C45 . C48 ) in ( dom ( C46 +* C47 ) ) by L102 , FUNCT_1:11;
L104: ( C45 . C48 ) in ( ( dom C46 ) \/ ( dom C47 ) ) by L103 , FUNCT_4:def 1;
L105: (( C45 . C48 ) in ( dom C46 ) or ( C45 . C48 ) in ( dom C47 )) by L104 , XBOOLE_0:def 3;
L106: C48 in ( dom C45 ) by L102 , FUNCT_1:11;
L107: (C48 in ( dom ( C46 * C45 ) ) or C48 in ( dom ( C47 * C45 ) )) by L106 , L105 , FUNCT_1:11;
thus L108: thesis by L107 , XBOOLE_0:def 3;
end;

let C49 being set;
assume L109: C49 in ( ( dom ( C46 * C45 ) ) \/ ( dom ( C47 * C45 ) ) );
L110: (C49 in ( dom ( C46 * C45 ) ) or C49 in ( dom ( C47 * C45 ) )) by L109 , XBOOLE_0:def 3;
L111: (( C45 . C49 ) in ( dom C46 ) or ( C45 . C49 ) in ( dom C47 )) by L110 , FUNCT_1:11;
L112: ( C45 . C49 ) in ( ( dom C46 ) \/ ( dom C47 ) ) by L111 , XBOOLE_0:def 3;
L113: ( C45 . C49 ) in ( dom ( C46 +* C47 ) ) by L112 , FUNCT_4:def 1;
L114: C49 in ( dom C45 ) by L110 , FUNCT_1:11;
thus L115: thesis by L114 , L113 , FUNCT_1:11;
end;
L116:
now
let C50 being set;
assume L117: C50 in ( ( dom ( C46 * C45 ) ) \/ ( dom ( C47 * C45 ) ) );
L118: (C50 in ( dom ( C46 * C45 ) ) or C50 in ( dom ( C47 * C45 ) )) by L117 , XBOOLE_0:def 3;
L119: C50 in ( dom C45 ) by L118 , FUNCT_1:11;
thus L120:now
assume L121: C50 in ( dom ( C47 * C45 ) );
L122: ( C45 . C50 ) in ( dom C47 ) by L121 , FUNCT_1:11;
thus L123: ( ( ( C46 +* C47 ) * C45 ) . C50 ) = ( ( C46 +* C47 ) . ( C45 . C50 ) ) by L119 , FUNCT_1:13
.= ( C47 . ( C45 . C50 ) ) by L122 , FUNCT_4:13
.= ( ( C47 * C45 ) . C50 ) by L121 , FUNCT_1:12;
end;
assume L124: (not C50 in ( dom ( C47 * C45 ) ));
L125: (not ( C45 . C50 ) in ( dom C47 )) by L124 , L119 , FUNCT_1:11;
thus L126: ( ( ( C46 +* C47 ) * C45 ) . C50 ) = ( ( C46 +* C47 ) . ( C45 . C50 ) ) by L119 , FUNCT_1:13
.= ( C46 . ( C45 . C50 ) ) by L125 , FUNCT_4:11
.= ( ( C46 * C45 ) . C50 ) by L119 , FUNCT_1:13;
end;
thus L127: thesis by L116 , L100 , FUNCT_4:def 1;
end;
theorem
L128: (for B42 , B43 , B44 being Function holds (( rng B42 ) misses ( dom B43 ) implies ( ( B44 +* B43 ) * B42 ) = ( B44 * B42 )))
proof
let C51 , C52 , C53 being Function;
assume L129: ( rng C51 ) misses ( dom C52 );
thus L130: ( ( C53 +* C52 ) * C51 ) = ( ( C53 * C51 ) +* ( C52 * C51 ) ) by L99
.= ( ( C53 * C51 ) +* ( {} ) ) by L129 , RELAT_1:44
.= ( C53 * C51 );
end;
theorem
L131: (for B45 , B46 being set holds (for B47 being set holds (B45 meets ( rng ( ( id B46 ) +* ( B45 --> B47 ) ) ) implies B47 in B45)))
proof
let C54 , C55 being set;
let C56 being set;
assume L132: C54 meets ( rng ( ( id C55 ) +* ( C54 --> C56 ) ) );
consider C57 being set such that L133: C57 in C54 and L134: C57 in ( rng ( ( id C55 ) +* ( C54 --> C56 ) ) ) by L132 , XBOOLE_0:3;
consider C58 being set such that L135: C58 in ( dom ( ( id C55 ) +* ( C54 --> C56 ) ) ) and L136: ( ( ( id C55 ) +* ( C54 --> C56 ) ) . C58 ) = C57 by L134 , FUNCT_1:def 3;
L137: C58 in ( ( dom ( id C55 ) ) \/ ( dom ( C54 --> C56 ) ) ) by L135 , FUNCT_4:def 1;
per cases ;
suppose L138: C58 in ( dom ( C54 --> C56 ) );

L139: C56 = ( ( C54 --> C56 ) . C58 ) by L138 , FUNCOP_1:7
.= C57 by L136 , L138 , FUNCT_4:13;
thus L140: thesis by L139 , L133;
end;
suppose L141: (not C58 in ( dom ( C54 --> C56 ) ));

L142: C58 in ( dom ( id C55 ) ) by L141 , L137 , XBOOLE_0:def 3;
L143: C57 = ( ( id C55 ) . C58 ) by L136 , L141 , FUNCT_4:11
.= C58 by L142 , FUNCT_1:18;
thus L144: thesis by L143 , L133 , L141 , FUNCOP_1:13;
end;
end;
theorem
L146: (for B48 , B49 being set holds (for B50 being set holds (B48 <> B49 implies (not B48 in ( rng ( ( id B50 ) +* ( B48 .--> B49 ) ) )))))
proof
let C59 , C60 being set;
let C61 being set;
assume L147: C59 <> C60;
L148: (not C60 in { C59 }) by L147 , TARSKI:def 1;
L149: { C59 } misses ( rng ( ( id C61 ) +* ( { C59 } --> C60 ) ) ) by L148 , L131;
thus L150: thesis by L149 , ZFMISC_1:48;
end;
theorem
L151: (for B51 being set holds (for B52 being set holds (for B53 being Function holds (( dom B53 ) = ( B51 \/ { B52 } ) implies B53 = ( ( B53 | B51 ) +* ( B52 .--> ( B53 . B52 ) ) )))))
proof
let C62 being set;
let C63 being set;
let C64 being Function;
assume L152: ( dom C64 ) = ( C62 \/ { C63 } );
L153: C63 in { C63 } by TARSKI:def 1;
L154: C63 in ( dom C64 ) by L153 , L152 , XBOOLE_0:def 3;
thus L155: C64 = ( ( C64 | C62 ) +* ( C64 | { C63 } ) ) by L152 , FUNCT_4:70
.= ( ( C64 | C62 ) +* ( C63 .--> ( C64 . C63 ) ) ) by L154 , L34;
end;
theorem
L156: (for B54 being Function holds (for B55 , B56 , B57 being set holds ( ( B54 +* ( B55 --> B56 ) ) +* ( B55 --> B57 ) ) = ( B54 +* ( B55 --> B57 ) )))
proof
let C65 being Function;
let C66 , C67 , C68 being set;
L157: ( dom ( C66 --> C68 ) ) = C66 by FUNCOP_1:13;
L158: ( dom ( C66 --> C67 ) ) = C66 by FUNCOP_1:13;
L159: ( dom ( C65 +* ( C66 --> C67 ) ) ) = ( ( dom C65 ) \/ C66 ) by L158 , FUNCT_4:def 1;
L160: ( dom ( ( C65 +* ( C66 --> C67 ) ) +* ( C66 --> C68 ) ) ) = ( ( ( dom C65 ) \/ C66 ) \/ C66 ) by L159 , L157 , FUNCT_4:def 1
.= ( ( dom C65 ) \/ ( C66 \/ C66 ) ) by XBOOLE_1:4
.= ( ( dom C65 ) \/ C66 );
L161:
now
let C69 being set;
assume L162: C69 in ( ( dom C65 ) \/ C66 );
per cases ;
suppose L163: C69 in C66;

L164: ( ( ( C65 +* ( C66 --> C67 ) ) +* ( C66 --> C68 ) ) . C69 ) = ( ( C66 --> C68 ) . C69 ) by L163 , L157 , FUNCT_4:13;
thus L165: ( ( ( C65 +* ( C66 --> C67 ) ) +* ( C66 --> C68 ) ) . C69 ) = ( ( C65 +* ( C66 --> C68 ) ) . C69 ) by L164 , L157 , L163 , FUNCT_4:13;
end;
suppose L166: (not C69 in C66);

L167: ( ( ( C65 +* ( C66 --> C67 ) ) +* ( C66 --> C68 ) ) . C69 ) = ( ( C65 +* ( C66 --> C67 ) ) . C69 ) by L166 , L157 , FUNCT_4:11;
L168: ( ( ( C65 +* ( C66 --> C67 ) ) +* ( C66 --> C68 ) ) . C69 ) = ( C65 . C69 ) by L167 , L158 , L166 , FUNCT_4:11;
thus L169: ( ( ( C65 +* ( C66 --> C67 ) ) +* ( C66 --> C68 ) ) . C69 ) = ( ( C65 +* ( C66 --> C68 ) ) . C69 ) by L168 , L157 , L166 , FUNCT_4:11;
end;
end;
L171: ( dom ( C65 +* ( C66 --> C68 ) ) ) = ( ( dom C65 ) \/ C66 ) by L157 , FUNCT_4:def 1;
thus L172: thesis by L171 , L160 , L161 , FUNCT_1:2;
end;
theorem
L173: ( INT ) <> ( ( INT ) * )
proof
L174:
now
L175: ( {} ) in 1 by CARD_1:49 , TARSKI:def 1;
assume L176: 1 in ( ( INT ) * );
L177: (ex R2 being set st (ex R3 being set st ( {} ) = [ R2 , R3 ])) by L176 , L175 , RELAT_1:def 1;
thus L178: contradiction by L177;
end;
thus L179: thesis by L174 , INT_1:def 2;
end;
theorem
L180: ( ( {} ) * ) = { ( {} ) }
proof
thus L181: ( ( {} ) * ) c= { ( {} ) }
proof
let R2 being set;
assume L182: R2 in ( ( {} ) * );
reconsider D3 = R2 as (FinSequence of ( {} )) by L182 , FINSEQ_1:def 11;
L183:
now
assume L184: R2 <> ( {} );
L185: (ex R2 being set st R2 in ( dom D3 )) by L184;
thus L186: contradiction by L185;
end;
thus L187: thesis by L183 , ZFMISC_1:31;
end;

let R2 being set;
assume L188: R2 in { ( {} ) };
L189: R2 = ( {} ) by L188 , TARSKI:def 1;
L190: ( rng ( {} ) ) = ( {} );
L191: R2 is (FinSequence of ( {} )) by L190 , L189 , FINSEQ_1:def 4;
thus L192: thesis by L191 , FINSEQ_1:def 11;
end;
theorem
L193: (for R2 being set holds (for R4 being set holds (<* R2 *> in ( R4 * ) iff R2 in R4)))
proof
let R2 being set;
let R4 being set;
L194: ( rng <* R2 *> ) = { R2 } by FINSEQ_1:38;
L195: ({ R2 } c= R4 iff <* R2 *> is (FinSequence of R4)) by L194 , FINSEQ_1:def 4;
thus L196: thesis by L195 , FINSEQ_1:def 11 , ZFMISC_1:31;
end;
theorem
L197: (for R4 being set holds (for R5 being set holds (( R4 * ) c= ( R5 * ) implies R4 c= R5)))
proof
let R4 being set;
let R5 being set;
assume L198: ( R4 * ) c= ( R5 * );
let R2 being set;
assume L199: R2 in R4;
L200: <* R2 *> in ( R4 * ) by L199 , L193;
thus L201: thesis by L200 , L198 , L193;
end;
theorem
L202: (for B58 being (Subset of ( NAT )) holds ((for R8 being (Element of ( NAT )) holds (for R7 being (Element of ( NAT )) holds ((R8 in B58 & R7 < R8) implies R7 in B58))) implies B58 is Cardinal))
proof
let C70 being (Subset of ( NAT ));
assume that
L203: (for R8 being (Element of ( NAT )) holds (for R7 being (Element of ( NAT )) holds ((R8 in C70 & R7 < R8) implies R7 in C70)));
per cases ;
suppose L204: C70 = ( {} );

thus L205: thesis by L204;
end;
suppose that L206: C70 <> ( {} )
and
L207: (ex B59 being Nat st (for B60 being Nat holds (B60 in C70 implies B60 <= B59)));
defpred S1[ set ] means $1 in C70;
consider C71 being Nat such that L208: (for B61 being Nat holds (S1[ B61 ] implies B61 <= C71)) by L207;
L209: (ex B62 being (Element of ( NAT )) st S1[ B62 ]) by L206 , SUBSET_1:4;
L210: (ex B63 being Nat st S1[ B63 ]) by L209;
consider C72 being Nat such that L211: S1[ C72 ] and L212: (for B64 being Nat holds (S1[ B64 ] implies B64 <= C72)) from NAT_1:sch 6(L208 , L210);
L213: C70 = { R6 where R6 is (Element of ( NAT )) : R6 < ( C72 + 1 ) }
proof
thus L214: C70 c= { R6 where R6 is (Element of ( NAT )) : R6 < ( C72 + 1 ) }
proof
let C73 being set;
assume L215: C73 in C70;
reconsider D4 = C73 as (Element of ( NAT )) by L215;
L216: D4 <= C72 by L212 , L215;
L217: D4 < ( C72 + 1 ) by L216 , NAT_1:13;
thus L218: thesis by L217;
end;

let C74 being set;
assume L219: C74 in { R6 where R6 is (Element of ( NAT )) : R6 < ( C72 + 1 ) };
consider C75 being (Element of ( NAT )) such that L220: C74 = C75 and L221: C75 < ( C72 + 1 ) by L219;
L222: C75 <= C72 by L221 , NAT_1:13;
L223: (C75 < C72 or C75 = C72) by L222 , XXREAL_0:1;
thus L224: thesis by L223 , L203 , L211 , L220;
end;
thus L225: thesis by L213 , AXIOMS:4;
end;
suppose L226: (for B65 being Nat holds (ex B66 being Nat st (B66 in C70 & B66 > B65)));

L227: ( NAT ) c= C70
proof
let C76 being set;
assume L228: C76 in ( NAT );
reconsider D5 = C76 as (Element of ( NAT )) by L228;
L229: (ex B67 being Nat st (B67 in C70 & B67 > D5)) by L226;
thus L230: thesis by L229 , L203;
end;
thus L231: thesis by L227 , XBOOLE_0:def 10;
end;
end;
theorem
L233: (for B68 being  finite set holds (for B69 being non  empty (Subset-Family of B68) holds (ex B70 being (Element of B69) st (for B71 being (Element of B69) holds (B71 c= B70 implies B71 = B70)))))
proof
let C77 being  finite set;
let C78 being non  empty (Subset-Family of C77);
reconsider D6 = ( COMPLEMENT C78 ) as non  empty (Subset-Family of C77) by SETFAM_1:32;
consider C79 being set such that L234: C79 in D6 and L235: (for B72 being set holds (B72 in D6 implies (C79 c= B72 implies B72 = C79))) by FINSET_1:6;
reconsider D7 = C79 as (Subset of C77) by L234;
reconsider D8 = ( D7 ` ) as (Element of C78) by L234 , SETFAM_1:def 7;
take D8;
let C80 being (Element of C78);
assume that
L236: C80 c= D8;
L237: ( ( C80 ` ) ` ) = C80;
L238: ( C80 ` ) in D6 by L237 , SETFAM_1:def 7;
L239: ( C80 ` ) = D7 by L238 , L235 , L236 , SUBSET_1:16;
thus L240: thesis by L239;
end;
theorem
L241: (for B73 , B74 being FinSequence holds (( len B73 ) = ( ( len B74 ) + 1 ) implies (for B75 being (Element of ( NAT )) holds (B75 in ( dom B74 ) iff (B75 in ( dom B73 ) & ( B75 + 1 ) in ( dom B73 ))))))
proof
let C81 , C82 being FinSequence;
assume L242: ( len C81 ) = ( ( len C82 ) + 1 );
let C83 being (Element of ( NAT ));
thus L243:now
assume L244: C83 in ( dom C82 );
L245: C83 >= 1 by L244 , FINSEQ_3:25;
L246: C83 <= ( len C82 ) by L244 , FINSEQ_3:25;
L247: ( len C82 ) <= ( len C81 ) by L242 , NAT_1:11;
L248: (( C83 + 1 ) >= 1 & C83 <= ( len C81 )) by L247 , L246 , NAT_1:11 , XXREAL_0:2;
L249: ( C83 + 1 ) <= ( len C81 ) by L242 , L246 , XREAL_1:6;
thus L250: (C83 in ( dom C81 ) & ( C83 + 1 ) in ( dom C81 )) by L249 , L245 , L248 , FINSEQ_3:25;
end;
assume that
L251: C83 in ( dom C81 )
and
L252: ( C83 + 1 ) in ( dom C81 );
L253: ( C83 + 1 ) <= ( len C81 ) by L252 , FINSEQ_3:25;
L254: C83 <= ( len C82 ) by L253 , L242 , XREAL_1:6;
L255: C83 >= 1 by L251 , FINSEQ_3:25;
thus L256: thesis by L255 , L254 , FINSEQ_3:25;
end;
registration
cluster  Function-yielding non  empty  non-empty for FinSequence;
existence
proof
take D9 = <* <* (( 0 ) qua set) *> *>;
L257: (( dom D9 ) = { 1 } & ( D9 . 1 ) = <* ( 0 ) *>) by FINSEQ_1:2 , FINSEQ_1:38 , FINSEQ_1:40;
thus L258: D9 is  Function-yielding
proof
let C84 being set;
assume L259: C84 in ( dom D9 );
thus L260: thesis by L259 , L257 , TARSKI:def 1;
end;

thus L261: D9 is non  empty;
let C85 being set;
assume L262: C85 in ( dom D9 );
thus L263: thesis by L262 , L257 , TARSKI:def 1;
end;
end;
registration
cluster  empty ->  Function-yielding for Function;
coherence;
let C86 being Function;
cluster <* C86 *> ->  Function-yielding;
coherence
proof
let C87 being set;
assume L265: C87 in ( dom <* C86 *> );
L266: C87 in { 1 } by L265 , FINSEQ_1:2 , FINSEQ_1:38;
L267: C87 = 1 by L266 , TARSKI:def 1;
thus L268: thesis by L267 , FINSEQ_1:40;
end;
let C88 being Function;
cluster <* C86 , C88 *> ->  Function-yielding;
coherence
proof
let C89 being set;
assume L269: C89 in ( dom <* C86 , C88 *> );
L270: C89 in { 1 , 2 } by L269 , FINSEQ_1:2 , FINSEQ_1:89;
L271: (C89 = 1 or C89 = 2) by L270 , TARSKI:def 2;
thus L272: thesis by L271 , FINSEQ_1:44;
end;
let C90 being Function;
cluster <* C86 , C88 , C90 *> ->  Function-yielding;
coherence
proof
let C91 being set;
assume L273: C91 in ( dom <* C86 , C88 , C90 *> );
L274: C91 in { 1 , 2 , 3 } by L273 , FINSEQ_1:89 , FINSEQ_3:1;
L275: (C91 = 1 or C91 = 2 or C91 = 3) by L274 , ENUMSET1:def 1;
thus L276: thesis by L275 , FINSEQ_1:45;
end;
end;
registration
let C92 being (Element of ( NAT ));
let C93 being Function;
cluster ( C92 |-> C93 ) ->  Function-yielding;
coherence;
end;
registration
let C94 , C95 being  Function-yielding FinSequence;
cluster ( C94 ^ C95 ) ->  Function-yielding;
coherence
proof
let C96 being set;
assume L279: C96 in ( dom ( C94 ^ C95 ) );
reconsider D10 = C96 as (Element of ( NAT )) by L279;
per cases ;
suppose L280: D10 in ( dom C94 );

L281: ( C94 . D10 ) = ( ( C94 ^ C95 ) . D10 ) by L280 , FINSEQ_1:def 7;
thus L282: thesis by L281;
end;
suppose L283: (not D10 in ( dom C94 ));

consider C97 being Nat such that L284: (C97 in ( dom C95 ) & D10 = ( ( len C94 ) + C97 )) by L283 , L279 , FINSEQ_1:25;
L285: ( C95 . C97 ) = ( ( C94 ^ C95 ) . D10 ) by L284 , FINSEQ_1:def 7;
thus L286: thesis by L285;
end;
end;
end;
theorem
L289: (for B76 , B77 being FinSequence holds (( B76 ^ B77 ) is  Function-yielding implies (B76 is  Function-yielding & B77 is  Function-yielding)))
proof
let C98 , C99 being FinSequence;
assume L290: (for B78 being set holds (B78 in ( dom ( C98 ^ C99 ) ) implies ( ( C98 ^ C99 ) . B78 ) is Function));
thus L291:now
let C100 being set;
assume L292: C100 in ( dom C98 );
L293: ( ( C98 ^ C99 ) . C100 ) = ( C98 . C100 ) by L292 , FINSEQ_1:def 7;
thus L294: ( C98 . C100 ) is Function by L293 , L290 , L292 , FINSEQ_3:22;
end;
let C101 being set;
assume L295: C101 in ( dom C99 );
reconsider D11 = C101 as (Element of ( NAT )) by L295;
L296: ( ( C98 ^ C99 ) . ( ( len C98 ) + D11 ) ) = ( C99 . C101 ) by L295 , FINSEQ_1:def 7;
thus L297: thesis by L296 , L290 , L295 , FINSEQ_1:28;
end;
begin
scheme Kappa2D { F1 , F2 , F3() -> non  empty set , F4((Element of F1()) , (Element of F2())) -> set } : (ex B79 being (Function of [: F1() , F2() :] , F3()) st (for B80 being (Element of F1()) holds (for B81 being (Element of F2()) holds ( B79 . (B80 , B81) ) = F4(B80 , B81))))
provided
L298: (for B82 being (Element of F1()) holds (for B83 being (Element of F2()) holds F4(B82 , B83) in F3()))
proof
deffunc H1((Element of [: F1() , F2() :])) = F4(( $1 `1 ) , ( $1 `2 ));
L299: (for B84 being (Element of [: F1() , F2() :]) holds H1(B84) in F3()) by L298;
consider C102 being (Function of [: F1() , F2() :] , F3()) such that L300: (for B85 being (Element of [: F1() , F2() :]) holds ( C102 . B85 ) = H1(B85)) from FUNCT_2:sch 8(L299);
take C102;
let C103 being (Element of F1());
let C104 being (Element of F2());
L301: (( [ C103 , C104 ] `1 ) = C103 & ( [ C103 , C104 ] `2 ) = C104);
thus L302: thesis by L301 , L300;
end;
scheme FinMono { F5() -> set , F6() -> non  empty set , F7 , F8(set) -> set } : { F7(B86) where B86 is (Element of F6()) : F8(B86) in F5() } is  finite
provided
L303: F5() is  finite
and
L304: (for B87 , B88 being (Element of F6()) holds (F8(B87) = F8(B88) implies B87 = B88))
proof
per cases ;
suppose L305: F5() = ( {} );

L306:
now
set D12 = the (Element of { F7(B89) where B89 is (Element of F6()) : F8(B89) in F5() });
assume L307: { F7(B90) where B90 is (Element of F6()) : F8(B90) in F5() } <> ( {} );
L308: D12 in { F7(B91) where B91 is (Element of F6()) : F8(B91) in F5() } by L307;
L309: (ex B92 being (Element of F6()) st (D12 = F7(B92) & F8(B92) in F5())) by L308;
thus L310: contradiction by L309 , L305;
end;
thus L311: thesis by L306;
end;
suppose L312: F5() <> ( {} );

reconsider D13 = F5() as non  empty set by L312;
defpred S2[ set ] means (ex B93 being (Element of F6()) st $1 = F8(B93));
set D14 = { B94 where B94 is (Element of F6()) : F8(B94) in D13 };
set D15 = { B95 where B95 is (Element of D13) : S2[ B95 ] };
L313: { F7(B96) where B96 is (Element of F6()) : F8(B96) in F5() } = { F7(B97) where B97 is (Element of F6()) : B97 in D14 }
proof
thus L314: { F7(B98) where B98 is (Element of F6()) : F8(B98) in F5() } c= { F7(B99) where B99 is (Element of F6()) : B99 in D14 }
proof
let C105 being set;
assume L315: C105 in { F7(B100) where B100 is (Element of F6()) : F8(B100) in F5() };
consider C106 being (Element of F6()) such that L316: C105 = F7(C106) and L317: F8(C106) in F5() by L315;
L318: C106 in D14 by L317;
thus L319: thesis by L318 , L316;
end;

let C107 being set;
assume L320: C107 in { F7(B101) where B101 is (Element of F6()) : B101 in D14 };
consider C108 being (Element of F6()) such that L321: C107 = F7(C108) and L322: C108 in D14 by L320;
L323: (ex B102 being (Element of F6()) st (B102 = C108 & F8(B102) in D13)) by L322;
thus L324: thesis by L323 , L321;
end;
L325: D15 , D14 are_equipotent 
proof
take D16 = { [ F8(B103) , B103 ] where B103 is (Element of F6()) : (not contradiction) };
thus L326:now
let C109 being set;
assume L327: C109 in D15;
consider C110 being (Element of D13) such that L328: C110 = C109 and L329: (ex B104 being (Element of F6()) st C110 = F8(B104)) by L327;
consider C111 being (Element of F6()) such that L330: C110 = F8(C111) by L329;
reconsider D17 = C111 as set;
take D18 = D17;
thus L331: (D18 in D14 & [ C109 , D18 ] in D16) by L328 , L330;
end;
thus L332:now
let C112 being set;
assume L333: C112 in D14;
consider C113 being (Element of F6()) such that L334: (C113 = C112 & F8(C113) in D13) by L333;
reconsider D19 = F8(C113) as set;
take D20 = D19;
thus L335: (D20 in D15 & [ D20 , C112 ] in D16) by L334;
end;
let C114 , C115 , C116 , C117 being set;
assume L336: [ C114 , C115 ] in D16;
consider C118 being (Element of F6()) such that L337: [ C114 , C115 ] = [ F8(C118) , C118 ] by L336;
assume L338: [ C116 , C117 ] in D16;
consider C119 being (Element of F6()) such that L339: [ C116 , C117 ] = [ F8(C119) , C119 ] by L338;
L340: (C116 = F8(C119) & C117 = C119) by L339 , XTUPLE_0:1;
L341: (C114 = F8(C118) & C115 = C118) by L337 , XTUPLE_0:1;
thus L342: thesis by L341 , L304 , L340;
end;
L343: D15 is (Subset of D13) from DOMAIN_1:sch 7;
L344: D15 is  finite by L343 , L303 , FINSET_1:1;
L345: D14 is  finite by L344 , L325 , CARD_1:38;
L346: { F7(B105) where B105 is (Element of F6()) : B105 in D14 } is  finite from FRAENKEL:sch 21(L345);
thus L347: thesis by L346 , L313;
end;
end;
scheme CardMono { F9() -> set , F10() -> non  empty set , F11(set) -> set } : F9() , { B106 where B106 is (Element of F10()) : F11(B106) in F9() } are_equipotent 
provided
L349: (for B107 being set holds (B107 in F9() implies (ex B108 being (Element of F10()) st B107 = F11(B108))))
and
L350: (for B109 , B110 being (Element of F10()) holds (F11(B109) = F11(B110) implies B109 = B110))
proof
set D21 = { B111 where B111 is (Element of F10()) : F11(B111) in F9() };
per cases ;
suppose L351: F9() = ( {} );

L352:
now
set D22 = the (Element of D21);
assume L353: D21 <> ( {} );
L354: D22 in D21 by L353;
L355: (ex B112 being (Element of F10()) st (D22 = B112 & F11(B112) in F9())) by L354;
thus L356: contradiction by L355 , L351;
end;
thus L357: thesis by L352 , L351;
end;
suppose L358: F9() <> ( {} );

reconsider D23 = F9() as non  empty set by L358;
L359: D23 , D21 are_equipotent 
proof
take D24 = { [ F11(B113) , B113 ] where B113 is (Element of F10()) : (not contradiction) };
thus L360:now
let C120 being set;
assume L361: C120 in D23;
consider C121 being (Element of F10()) such that L362: C120 = F11(C121) by L361 , L349;
reconsider D25 = C121 as set;
take D26 = D25;
thus L363: D26 in D21 by L361 , L362;
thus L364: [ C120 , D26 ] in D24 by L362;
end;
thus L365:now
let C122 being set;
assume L366: C122 in D21;
consider C123 being (Element of F10()) such that L367: (C123 = C122 & F11(C123) in D23) by L366;
reconsider D27 = F11(C123) as set;
take D28 = D27;
thus L368: (D28 in D23 & [ D28 , C122 ] in D24) by L367;
end;
let C124 , C125 , C126 , C127 being set;
assume L369: [ C124 , C125 ] in D24;
consider C128 being (Element of F10()) such that L370: [ C124 , C125 ] = [ F11(C128) , C128 ] by L369;
assume L371: [ C126 , C127 ] in D24;
consider C129 being (Element of F10()) such that L372: [ C126 , C127 ] = [ F11(C129) , C129 ] by L371;
L373: (C126 = F11(C129) & C127 = C129) by L372 , XTUPLE_0:1;
L374: (C124 = F11(C128) & C125 = C128) by L370 , XTUPLE_0:1;
thus L375: thesis by L374 , L350 , L373;
end;
thus L376: thesis by L359;
end;
end;
scheme CardMono9 { F12() -> set , F13() -> non  empty set , F14(set) -> set } : F12() , { F14(B114) where B114 is (Element of F13()) : B114 in F12() } are_equipotent 
provided
L378: F12() c= F13()
and
L379: (for B115 , B116 being (Element of F13()) holds (F14(B115) = F14(B116) implies B115 = B116))
proof
per cases ;
suppose L380: F12() = ( {} );

L381:
now
set D29 = the (Element of { F14(B117) where B117 is (Element of F13()) : B117 in F12() });
assume L382: { F14(B118) where B118 is (Element of F13()) : B118 in F12() } <> ( {} );
L383: D29 in { F14(B119) where B119 is (Element of F13()) : B119 in F12() } by L382;
L384: (ex B120 being (Element of F13()) st (D29 = F14(B120) & B120 in F12())) by L383;
thus L385: contradiction by L384 , L380;
end;
thus L386: thesis by L381 , L380;
end;
suppose L387: F12() <> ( {} );

reconsider D30 = F12() as non  empty set by L387;
set D31 = { F14(B121) where B121 is (Element of F13()) : B121 in D30 };
L388: D30 , D31 are_equipotent 
proof
take D32 = { [ B122 , F14(B122) ] where B122 is (Element of F13()) : (not contradiction) };
thus L389:now
let C130 being set;
assume L390: C130 in D30;
reconsider D33 = C130 as (Element of F13()) by L390 , L378;
take D34 = F14(D33);
thus L391: D34 in D31 by L390;
thus L392: [ C130 , D34 ] in D32;
end;
thus L393:now
let C131 being set;
assume L394: C131 in D31;
consider C132 being (Element of F13()) such that L395: (F14(C132) = C131 & C132 in D30) by L394;
reconsider D35 = C132 as set;
take D36 = D35;
thus L396: (D36 in D30 & [ D36 , C131 ] in D32) by L395;
end;
let C133 , C134 , C135 , C136 being set;
assume L397: [ C133 , C134 ] in D32;
consider C137 being (Element of F13()) such that L398: [ C133 , C134 ] = [ C137 , F14(C137) ] by L397;
assume L399: [ C135 , C136 ] in D32;
consider C138 being (Element of F13()) such that L400: [ C135 , C136 ] = [ C138 , F14(C138) ] by L399;
L401: (C135 = C138 & C136 = F14(C138)) by L400 , XTUPLE_0:1;
L402: (C133 = C137 & C134 = F14(C137)) by L398 , XTUPLE_0:1;
thus L403: thesis by L402 , L379 , L401;
end;
thus L404: thesis by L388;
end;
end;
scheme FuncSeqInd { P1[set] } : (for B123 being  Function-yielding FinSequence holds P1[ B123 ])
provided
L406: P1[ ( {} ) ]
and
L407: (for B124 being  Function-yielding FinSequence holds (P1[ B124 ] implies (for B125 being Function holds P1[ ( B124 ^ <* B125 *> ) ])))
proof
defpred S3[ FinSequence ] means ($1 is  Function-yielding implies P1[ $1 ]);
L408: (for B126 being FinSequence holds (for B127 being set holds (S3[ B126 ] implies S3[ ( B126 ^ <* B127 *> ) ])))
proof
let C139 being FinSequence;
let C140 being set;
assume that
L409: (C139 is  Function-yielding implies P1[ C139 ])
and
L410: ( C139 ^ <* C140 *> ) is  Function-yielding;
L411: ( <* C140 *> . 1 ) = C140 by FINSEQ_1:40;
L412: (C139 is  Function-yielding & <* C140 *> is  Function-yielding) by L410 , L289;
thus L413: thesis by L412 , L407 , L409 , L411;
end;
L414: S3[ ( {} ) ] by L406;
L415: (for B128 being FinSequence holds S3[ B128 ]) from FINSEQ_1:sch 3(L414 , L408);
thus L416: thesis by L415;
end;
begin
definition
let C141 , C142 being set;
assume L417: C141 in C142;
func In (C141 , C142) -> (Element of C142) equals 
:L418: C141;
correctness by L417;
end;
theorem
L420: (for R2 being set holds (for R4 being set holds (for R5 being set holds (R2 in ( R4 /\ R5 ) implies ( In (R2 , R4) ) = ( In (R2 , R5) )))))
proof
let R2 being set;
let R4 being set;
let R5 being set;
assume L421: R2 in ( R4 /\ R5 );
L422: R2 in R5 by L421 , XBOOLE_0:def 4;
L423: R2 in R4 by L421 , XBOOLE_0:def 4;
thus L424: ( In (R2 , R4) ) = R2 by L423 , L418
.= ( In (R2 , R5) ) by L422 , L418;
end;
definition
let C143 , C144 being Function;
let C145 being set;
pred C143 , C144 equal_outside C145
means
:L425: ( C143 | ( ( dom C143 ) \ C145 ) ) = ( C144 | ( ( dom C144 ) \ C145 ) )
;end;
theorem
L427: (for B129 being Function holds (for B130 being set holds B129 , B129 equal_outside B130))
proof
let C146 being Function;
let C147 being set;
thus L428: ( C146 | ( ( dom C146 ) \ C147 ) ) = ( C146 | ( ( dom C146 ) \ C147 ) );
end;
theorem
L429: (for B131 , B132 being Function holds (for B133 being set holds (B131 , B132 equal_outside B133 implies B132 , B131 equal_outside B133)))
proof
let C148 , C149 being Function;
let C150 being set;
assume L430: ( C148 | ( ( dom C148 ) \ C150 ) ) = ( C149 | ( ( dom C149 ) \ C150 ) );
thus L431: ( C149 | ( ( dom C149 ) \ C150 ) ) = ( C148 | ( ( dom C148 ) \ C150 ) ) by L430;
end;
theorem
L432: (for B134 , B135 , B136 being Function holds (for B137 being set holds ((B134 , B135 equal_outside B137 & B135 , B136 equal_outside B137) implies B134 , B136 equal_outside B137)))
proof
let C151 , C152 , C153 being Function;
let C154 being set;
assume L433: (( C151 | ( ( dom C151 ) \ C154 ) ) = ( C152 | ( ( dom C152 ) \ C154 ) ) & ( C152 | ( ( dom C152 ) \ C154 ) ) = ( C153 | ( ( dom C153 ) \ C154 ) ));
thus L434: ( C151 | ( ( dom C151 ) \ C154 ) ) = ( C153 | ( ( dom C153 ) \ C154 ) ) by L433;
end;
theorem
L435: (for B138 , B139 being Function holds (for B140 being set holds (B138 , B139 equal_outside B140 implies ( ( dom B138 ) \ B140 ) = ( ( dom B139 ) \ B140 ))))
proof
let C155 , C156 being Function;
let C157 being set;
assume L436: ( C155 | ( ( dom C155 ) \ C157 ) ) = ( C156 | ( ( dom C156 ) \ C157 ) );
thus L437: ( ( dom C155 ) \ C157 ) = ( ( dom C155 ) /\ ( ( dom C155 ) \ C157 ) ) by XBOOLE_1:28
.= ( dom ( C155 | ( ( dom C155 ) \ C157 ) ) ) by RELAT_1:61
.= ( ( dom C156 ) /\ ( ( dom C156 ) \ C157 ) ) by L436 , RELAT_1:61
.= ( ( dom C156 ) \ C157 ) by XBOOLE_1:28;
end;
theorem
L438: (for B141 , B142 being Function holds (for B143 being set holds (( dom B142 ) c= B143 implies B141 , ( B141 +* B142 ) equal_outside B143)))
proof
let C158 , C159 being Function;
let C160 being set;
assume L439: ( dom C159 ) c= C160;
L440: ( ( dom ( C158 +* C159 ) ) \ C160 ) = ( ( ( dom C158 ) \/ ( dom C159 ) ) \ C160 ) by FUNCT_4:def 1
.= ( ( ( dom C158 ) \ C160 ) \/ ( ( dom C159 ) \ C160 ) ) by XBOOLE_1:42
.= ( ( ( dom C158 ) \ C160 ) \/ ( {} ) ) by L439 , XBOOLE_1:37
.= ( ( dom C158 ) \ C160 );
L441: ( ( dom C158 ) \ C160 ) misses C160 by XBOOLE_1:79;
L442: ( ( dom C158 ) \ C160 ) misses ( dom C159 ) by L441 , L439 , XBOOLE_1:63;
thus L443: ( C158 | ( ( dom C158 ) \ C160 ) ) = ( ( C158 +* C159 ) | ( ( dom ( C158 +* C159 ) ) \ C160 ) ) by L442 , L440 , FUNCT_4:72;
end;
definition
let C161 being Function;
let C162 , C163 being set;
func C161 +* (C162 , C163) -> Function equals 
:L444: ( C161 +* ( C162 .--> C163 ) ) if C162 in ( dom C161 ) otherwise C161;
correctness;
end;
theorem
L446: (for B144 being Function holds (for B145 , B146 being set holds ( dom ( B144 +* (B146 , B145) ) ) = ( dom B144 )))
proof
let C164 being Function;
let C165 , C166 being set;
per cases ;
suppose L447: C166 in ( dom C164 );

L448: { C166 } c= ( dom C164 ) by L447 , ZFMISC_1:31;
thus L449: ( dom ( C164 +* (C166 , C165) ) ) = ( dom ( C164 +* ( C166 .--> C165 ) ) ) by L447 , L444
.= ( ( dom C164 ) \/ ( dom ( C166 .--> C165 ) ) ) by FUNCT_4:def 1
.= ( ( dom C164 ) \/ { C166 } ) by FUNCOP_1:13
.= ( dom C164 ) by L448 , XBOOLE_1:12;
end;
suppose L450: (not C166 in ( dom C164 ));

thus L451: thesis by L450 , L444;
end;
end;
theorem
L453: (for B147 being Function holds (for B148 , B149 being set holds (B149 in ( dom B147 ) implies ( ( B147 +* (B149 , B148) ) . B149 ) = B148)))
proof
let C167 being Function;
let C168 , C169 being set;
L454: ( dom ( C169 .--> C168 ) ) = { C169 } by FUNCOP_1:13;
L455: C169 in ( dom ( C169 .--> C168 ) ) by L454 , TARSKI:def 1;
assume L456: C169 in ( dom C167 );
thus L457: ( ( C167 +* (C169 , C168) ) . C169 ) = ( ( C167 +* ( C169 .--> C168 ) ) . C169 ) by L456 , L444
.= ( ( C169 .--> C168 ) . C169 ) by L455 , FUNCT_4:13
.= C168 by FUNCOP_1:72;
end;
theorem
L458: (for B150 being Function holds (for B151 , B152 , B153 being set holds (B152 <> B153 implies ( ( B150 +* (B152 , B151) ) . B153 ) = ( B150 . B153 ))))
proof
let C170 being Function;
let C171 , C172 , C173 being set;
assume that
L459: C172 <> C173;
L460: (not C173 in ( dom ( C172 .--> C171 ) )) by L459 , TARSKI:def 1;
per cases ;
suppose L461: C172 in ( dom C170 );

thus L462: ( ( C170 +* (C172 , C171) ) . C173 ) = ( ( C170 +* ( C172 .--> C171 ) ) . C173 ) by L461 , L444
.= ( C170 . C173 ) by L460 , FUNCT_4:11;
end;
suppose L463: (not C172 in ( dom C170 ));

thus L464: thesis by L463 , L444;
end;
end;
theorem
L466: (for B154 being Function holds (for B155 , B156 , B157 , B158 being set holds (B157 <> B158 implies ( ( B154 +* (B157 , B155) ) +* (B158 , B156) ) = ( ( B154 +* (B158 , B156) ) +* (B157 , B155) ))))
proof
let C174 being Function;
let C175 , C176 , C177 , C178 being set;
assume that
L467: C177 <> C178;
per cases ;
suppose that L468: C177 in ( dom C174 )
and
L469: C178 in ( dom C174 );
L470: C177 in ( dom ( C174 +* (C178 , C176) ) ) by L468 , L446;
L471: (( dom ( C177 .--> C175 ) ) = { C177 } & ( dom ( C178 .--> C176 ) ) = { C178 }) by FUNCOP_1:13;
L472: C178 in ( dom ( C174 +* (C177 , C175) ) ) by L469 , L446;
thus L473: ( ( C174 +* (C177 , C175) ) +* (C178 , C176) ) = ( ( C174 +* (C177 , C175) ) +* ( C178 .--> C176 ) ) by L472 , L444
.= ( ( C174 +* ( C177 .--> C175 ) ) +* ( C178 .--> C176 ) ) by L468 , L444
.= ( C174 +* ( ( C177 .--> C175 ) +* ( C178 .--> C176 ) ) ) by FUNCT_4:14
.= ( C174 +* ( ( C178 .--> C176 ) +* ( C177 .--> C175 ) ) ) by L467 , L471 , FUNCT_4:35 , ZFMISC_1:11
.= ( ( C174 +* ( C178 .--> C176 ) ) +* ( C177 .--> C175 ) ) by FUNCT_4:14
.= ( ( C174 +* (C178 , C176) ) +* ( C177 .--> C175 ) ) by L469 , L444
.= ( ( C174 +* (C178 , C176) ) +* (C177 , C175) ) by L470 , L444;
end;
suppose that L474: C177 in ( dom C174 )
and
L475: (not C178 in ( dom C174 ));
L476: (not C178 in ( dom ( C174 +* (C177 , C175) ) )) by L475 , L446;
thus L477: ( ( C174 +* (C177 , C175) ) +* (C178 , C176) ) = ( C174 +* (C177 , C175) ) by L476 , L444
.= ( ( C174 +* (C178 , C176) ) +* (C177 , C175) ) by L475 , L444;
end;
suppose that L478: (not C177 in ( dom C174 ))
and
L479: C178 in ( dom C174 );
L480: (not C177 in ( dom ( C174 +* (C178 , C176) ) )) by L478 , L446;
thus L481: ( ( C174 +* (C177 , C175) ) +* (C178 , C176) ) = ( C174 +* (C178 , C176) ) by L478 , L444
.= ( ( C174 +* (C178 , C176) ) +* (C177 , C175) ) by L480 , L444;
end;
suppose that L482: (not C177 in ( dom C174 ))
and
L483: (not C178 in ( dom C174 ));
L484: (not C177 in ( dom ( C174 +* (C178 , C176) ) )) by L482 , L446;
L485: (not C178 in ( dom ( C174 +* (C177 , C175) ) )) by L483 , L446;
thus L486: ( ( C174 +* (C177 , C175) ) +* (C178 , C176) ) = ( C174 +* (C177 , C175) ) by L485 , L444
.= C174 by L482 , L444
.= ( C174 +* (C178 , C176) ) by L483 , L444
.= ( ( C174 +* (C178 , C176) ) +* (C177 , C175) ) by L484 , L444;
end;
end;
theorem
L488: (for B159 being Function holds (for B160 , B161 , B162 being set holds ( ( B159 +* (B162 , B160) ) +* (B162 , B161) ) = ( B159 +* (B162 , B161) )))
proof
let C179 being Function;
let C180 , C181 , C182 being set;
L489: ( dom ( C182 .--> C180 ) ) = { C182 } by FUNCOP_1:13
.= ( dom ( C182 .--> C181 ) ) by FUNCOP_1:13;
per cases ;
suppose L490: C182 in ( dom C179 );

L491: C182 in ( dom ( C179 +* (C182 , C180) ) ) by L490 , L446;
thus L492: ( ( C179 +* (C182 , C180) ) +* (C182 , C181) ) = ( ( C179 +* (C182 , C180) ) +* ( C182 .--> C181 ) ) by L491 , L444
.= ( ( C179 +* ( C182 .--> C180 ) ) +* ( C182 .--> C181 ) ) by L490 , L444
.= ( C179 +* ( ( C182 .--> C180 ) +* ( C182 .--> C181 ) ) ) by FUNCT_4:14
.= ( C179 +* ( C182 .--> C181 ) ) by L489 , FUNCT_4:19
.= ( C179 +* (C182 , C181) ) by L490 , L444;
end;
suppose L493: (not C182 in ( dom C179 ));

thus L494: thesis by L493 , L444;
end;
end;
theorem
L496: (for B163 being Function holds (for B164 being set holds ( B163 +* (B164 , ( B163 . B164 )) ) = B163))
proof
let C183 being Function;
let C184 being set;
per cases ;
suppose L497: C184 in ( dom C183 );

L498: ( C184 .--> ( C183 . C184 ) ) = ( C183 | { C184 } ) by L497 , L34;
thus L499: ( C183 +* (C184 , ( C183 . C184 )) ) = ( C183 +* ( C184 .--> ( C183 . C184 ) ) ) by L497 , L444
.= C183 by L498 , FUNCT_4:75;
end;
suppose L500: (not C184 in ( dom C183 ));

thus L501: thesis by L500 , L444;
end;
end;
registration
let C185 being FinSequence;
let C186 , C187 being set;
cluster ( C185 +* (C186 , C187) ) ->  FinSequence-like;
coherence
proof
L503: ( dom ( C185 +* (C186 , C187) ) ) = ( dom C185 ) by L446
.= ( Seg ( len C185 ) ) by FINSEQ_1:def 3;
thus L504: thesis by L503 , FINSEQ_1:def 2;
end;
end;
definition
let C188 being set;
let C189 being (FinSequence of C188);
let C190 being (Element of ( NAT ));
let C191 being (Element of C188);
redefine func C189 +* (C190 , C191) -> (FinSequence of C188);

coherence
proof
per cases ;
suppose L506: C190 in ( dom C189 );

L507: ( C189 . C190 ) in ( rng C189 ) by L506 , FUNCT_1:def 3;
L508: { C191 } c= C188 by L507 , ZFMISC_1:31;
L509: (( ( rng C189 ) \/ ( rng ( C190 .--> C191 ) ) ) = ( ( rng C189 ) \/ { C191 } ) & ( ( rng C189 ) \/ { C191 } ) c= C188) by L508 , FUNCOP_1:8 , XBOOLE_1:8;
L510: ( C189 +* (C190 , C191) ) = ( C189 +* ( C190 .--> C191 ) ) by L506 , L444;
L511: ( rng ( C189 +* (C190 , C191) ) ) c= ( ( rng C189 ) \/ ( rng ( C190 .--> C191 ) ) ) by L510 , FUNCT_4:17;
L512: ( rng ( C189 +* (C190 , C191) ) ) c= C188 by L511 , L509 , XBOOLE_1:1;
thus L513: thesis by L512 , FINSEQ_1:def 4;
end;
suppose L514: (not C190 in ( dom C189 ));

thus L515: thesis by L514 , L444;
end;
end;
end;
theorem
L518: (for B165 being non  empty set holds (for B166 being (FinSequence of B165) holds (for B167 being (Element of B165) holds (for B168 being (Element of ( NAT )) holds (B168 in ( dom B166 ) implies ( ( B166 +* (B168 , B167) ) /. B168 ) = B167)))))
proof
let C192 being non  empty set;
let C193 being (FinSequence of C192);
let C194 being (Element of C192);
let C195 being (Element of ( NAT ));
assume L519: C195 in ( dom C193 );
L520: C195 in ( dom ( C193 +* (C195 , C194) ) ) by L519 , L446;
thus L521: ( ( C193 +* (C195 , C194) ) /. C195 ) = ( ( C193 +* (C195 , C194) ) . C195 ) by L520 , PARTFUN1:def 6
.= C194 by L519 , L453;
end;
theorem
L522: (for B169 being non  empty set holds (for B170 being (FinSequence of B169) holds (for B171 being (Element of B169) holds (for B172 , B173 being (Element of ( NAT )) holds ((B172 <> B173 & B173 in ( dom B170 )) implies ( ( B170 +* (B172 , B171) ) /. B173 ) = ( B170 /. B173 ))))))
proof
let C196 being non  empty set;
let C197 being (FinSequence of C196);
let C198 being (Element of C196);
let C199 , C200 being (Element of ( NAT ));
assume that
L523: C199 <> C200
and
L524: C200 in ( dom C197 );
L525: C200 in ( dom ( C197 +* (C199 , C198) ) ) by L524 , L446;
thus L526: ( ( C197 +* (C199 , C198) ) /. C200 ) = ( ( C197 +* (C199 , C198) ) . C200 ) by L525 , PARTFUN1:def 6
.= ( C197 . C200 ) by L523 , L458
.= ( C197 /. C200 ) by L524 , PARTFUN1:def 6;
end;
theorem
L527: (for B174 being non  empty set holds (for B175 being (FinSequence of B174) holds (for B176 , B177 being (Element of B174) holds (for B178 being (Element of ( NAT )) holds ( B175 +* (B178 , ( B175 /. B178 )) ) = B175))))
proof
let C201 being non  empty set;
let C202 being (FinSequence of C201);
let C203 , C204 being (Element of C201);
let C205 being (Element of ( NAT ));
per cases ;
suppose L528: C205 in ( dom C202 );

thus L529: ( C202 +* (C205 , ( C202 /. C205 )) ) = ( C202 +* (C205 , ( C202 . C205 )) ) by L528 , PARTFUN1:def 6
.= C202 by L496;
end;
suppose L530: (not C205 in ( dom C202 ));

thus L531: thesis by L530 , L444;
end;
end;
begin
definition
let C206 being set;
let C207 being  Function-yielding FinSequence;
func compose (C207 , C206) -> Function means 
:L533: (ex B179 being (ManySortedFunction of ( NAT )) st (it = ( B179 . ( len C207 ) ) & ( B179 . ( 0 ) ) = ( id C206 ) & (for B180 being (Element of ( NAT )) holds (( B180 + 1 ) in ( dom C207 ) implies (for B181 , B182 being Function holds ((B181 = ( B179 . B180 ) & B182 = ( C207 . ( B180 + 1 ) )) implies ( B179 . ( B180 + 1 ) ) = ( B182 * B181 )))))));
uniqueness
proof
let C208 , C209 being Function;
given C210 being (ManySortedFunction of ( NAT )) such that
L534: C208 = ( C210 . ( len C207 ) )
and
L535: ( C210 . ( 0 ) ) = ( id C206 )
and
L536: (for B183 being (Element of ( NAT )) holds (( B183 + 1 ) in ( dom C207 ) implies (for B184 , B185 being Function holds ((B184 = ( C210 . B183 ) & B185 = ( C207 . ( B183 + 1 ) )) implies ( C210 . ( B183 + 1 ) ) = ( B185 * B184 )))));

given C211 being (ManySortedFunction of ( NAT )) such that
L537: C209 = ( C211 . ( len C207 ) )
and
L538: ( C211 . ( 0 ) ) = ( id C206 )
and
L539: (for B186 being (Element of ( NAT )) holds (( B186 + 1 ) in ( dom C207 ) implies (for B187 , B188 being Function holds ((B187 = ( C211 . B186 ) & B188 = ( C207 . ( B186 + 1 ) )) implies ( C211 . ( B186 + 1 ) ) = ( B188 * B187 )))));

defpred S4[ (Element of ( NAT )) ] means ($1 <= ( len C207 ) implies (( C210 . $1 ) = ( C211 . $1 ) & ( C210 . $1 ) is Function));
L540: (for B189 being (Element of ( NAT )) holds (S4[ B189 ] implies S4[ ( B189 + 1 ) ]))
proof
let C212 being (Element of ( NAT ));
assume that
L541: (C212 <= ( len C207 ) implies (( C210 . C212 ) = ( C211 . C212 ) & ( C210 . C212 ) is Function))
and
L542: ( C212 + 1 ) <= ( len C207 );
reconsider D37 = ( C207 . ( C212 + 1 ) ) as Function;
reconsider D38 = ( C210 . C212 ) as Function;
L543: ( C212 + 1 ) >= 1 by NAT_1:11;
L544: ( C212 + 1 ) in ( dom C207 ) by L543 , L542 , FINSEQ_3:25;
L545: ( C210 . ( C212 + 1 ) ) = ( D37 * D38 ) by L544 , L536;
thus L546: thesis by L545 , L539 , L541 , L542 , L544 , NAT_1:13;
end;
L547: S4[ ( 0 ) ] by L535 , L538;
L548: (for B190 being (Element of ( NAT )) holds S4[ B190 ]) from NAT_1:sch 1(L547 , L540);
thus L549: thesis by L548 , L534 , L537;
end;
correctness
proof
reconsider D39 = ( 0 ) as Function;
defpred S5[ (Element of ( NAT )) , set , set ] means (((not $2 is Function) & $3 = D39) or ($2 is Function & (for B191 , B192 being Function holds ((B191 = $2 & B192 = ( C207 . ( $1 + 1 ) )) implies $3 = ( B192 * B191 )))));
L550: (for B193 being (Element of ( NAT )) holds (for B194 being set holds (ex B195 being set st S5[ B193 , B194 , B195 ])))
proof
let C213 being (Element of ( NAT ));
let C214 being set;
reconsider D40 = ( C207 . ( C213 + 1 ) ) as Function;
per cases ;
suppose L551: C214 is Function;

reconsider D41 = C214 as Function by L551;
take ( D40 * D41 );
thus L552: thesis;
end;
suppose L553: (not C214 is Function);

take ( 0 );
thus L554: thesis by L553;
end;
end;
consider C215 being Function such that L556: (( dom C215 ) = ( NAT ) & ( C215 . ( 0 ) ) = ( id C206 )) and L557: (for B196 being (Element of ( NAT )) holds S5[ B196 , ( C215 . B196 ) , ( C215 . ( B196 + 1 ) ) ]) from RECDEF_1:sch 1(L550);
defpred S6[ (Element of ( NAT )) ] means ( C215 . $1 ) is Function;
L558: (for B197 being (Element of ( NAT )) holds (S6[ B197 ] implies S6[ ( B197 + 1 ) ]))
proof
let C216 being (Element of ( NAT ));
reconsider D42 = ( C207 . ( C216 + 1 ) ) as Function;
assume L559: ( C215 . C216 ) is Function;
reconsider D43 = ( C215 . C216 ) as Function by L559;
L560: ( C215 . ( C216 + 1 ) ) = ( D42 * D43 ) by L557;
thus L561: thesis by L560;
end;
L562: S6[ ( 0 ) ] by L556;
L563: (for B198 being (Element of ( NAT )) holds S6[ B198 ]) from NAT_1:sch 1(L562 , L558);
reconsider D44 = ( C215 . ( len C207 ) ) as Function by L563;
L564: C215 is  Function-yielding
proof
let C217 being set;
assume L565: C217 in ( dom C215 );
thus L566: thesis by L565 , L556 , L563;
end;
reconsider D45 = C215 as (ManySortedFunction of ( NAT )) by L564 , L556 , PARTFUN1:def 2 , RELAT_1:def 18;
take D44;
take D45;
thus L567: (D44 = ( D45 . ( len C207 ) ) & ( D45 . ( 0 ) ) = ( id C206 )) by L556;
let C218 being (Element of ( NAT ));
thus L568: thesis by L557;
end;
end;
definition
let C219 being  Function-yielding FinSequence;
let C220 being set;
func apply (C219 , C220) -> FinSequence means 
:L570: (( len it ) = ( ( len C219 ) + 1 ) & ( it . 1 ) = C220 & (for B199 being (Element of ( NAT )) holds (for B200 being Function holds ((B199 in ( dom C219 ) & B200 = ( C219 . B199 )) implies ( it . ( B199 + 1 ) ) = ( B200 . ( it . B199 ) )))));
existence
proof
defpred S7[ (Element of ( NAT )) , set , set ] means (ex B201 being Function st (B201 = ( C219 . $1 ) & $3 = ( B201 . $2 )));
L571: (for B202 being (Element of ( NAT )) holds ((1 <= B202 & B202 < ( ( len C219 ) + 1 )) implies (for B203 being set holds (ex B204 being set st S7[ B202 , B203 , B204 ]))))
proof
let C221 being (Element of ( NAT ));
assume L572: 1 <= C221;
assume L573: C221 < ( ( len C219 ) + 1 );
reconsider D46 = ( C219 . C221 ) as Function;
let C222 being set;
take ( D46 . C222 );
take D46;
thus L574: thesis;
end;
consider C223 being FinSequence such that L575: (( len C223 ) = ( ( len C219 ) + 1 ) & (( C223 . 1 ) = C220 or ( ( len C219 ) + 1 ) = ( 0 ))) and L576: (for B205 being (Element of ( NAT )) holds ((1 <= B205 & B205 < ( ( len C219 ) + 1 )) implies S7[ B205 , ( C223 . B205 ) , ( C223 . ( B205 + 1 ) ) ])) from RECDEF_1:sch 3(L571);
take C223;
thus L577: (( len C223 ) = ( ( len C219 ) + 1 ) & ( C223 . 1 ) = C220) by L575;
let C224 being (Element of ( NAT ));
let C225 being Function;
assume L578: C224 in ( dom C219 );
L579: C224 <= ( len C219 ) by L578 , FINSEQ_3:25;
L580: C224 < ( ( len C219 ) + 1 ) by L579 , NAT_1:13;
L581: C224 >= 1 by L578 , FINSEQ_3:25;
L582: (ex B206 being Function st (B206 = ( C219 . C224 ) & ( C223 . ( C224 + 1 ) ) = ( B206 . ( C223 . C224 ) ))) by L581 , L576 , L580;
thus L583: thesis by L582;
end;
correctness
proof
let C226 , C227 being FinSequence;
assume that
L584: ( len C226 ) = ( ( len C219 ) + 1 )
and
L585: ( C226 . 1 ) = C220
and
L586: (for B207 being (Element of ( NAT )) holds (for B208 being Function holds ((B207 in ( dom C219 ) & B208 = ( C219 . B207 )) implies ( C226 . ( B207 + 1 ) ) = ( B208 . ( C226 . B207 ) ))))
and
L587: ( len C227 ) = ( ( len C219 ) + 1 )
and
L588: ( C227 . 1 ) = C220
and
L589: (for B209 being (Element of ( NAT )) holds (for B210 being Function holds ((B209 in ( dom C219 ) & B210 = ( C219 . B209 )) implies ( C227 . ( B209 + 1 ) ) = ( B210 . ( C227 . B209 ) ))));
defpred S8[ Nat ] means ($1 in ( dom C226 ) implies ( C226 . $1 ) = ( C227 . $1 ));
L590: (for B211 being Nat holds (S8[ B211 ] implies S8[ ( B211 + 1 ) ]))
proof
let C228 being Nat;
assume that
L591: (C228 in ( dom C226 ) implies ( C226 . C228 ) = ( C227 . C228 ))
and
L592: ( C228 + 1 ) in ( dom C226 );
L593: ( C228 + 1 ) <= ( len C226 ) by L592 , FINSEQ_3:25;
L594: C228 <= ( len C219 ) by L593 , L584 , XREAL_1:6;
per cases ;
suppose L595: C228 = ( 0 );

thus L596: thesis by L595 , L585 , L588;
end;
suppose L597: C228 > ( 0 );

reconsider D47 = ( C219 . C228 ) as Function;
L598: C228 >= ( ( 0 ) + 1 ) by L597 , NAT_1:13;
L599: C228 in ( dom C219 ) by L598 , L594 , FINSEQ_3:25;
thus L600: ( C226 . ( C228 + 1 ) ) = ( D47 . ( C227 . C228 ) ) by L599 , L584 , L586 , L591 , L241
.= ( C227 . ( C228 + 1 ) ) by L589 , L599;
end;
end;
L602: S8[ ( 0 ) ] by FINSEQ_3:25;
L603: (for B212 being Nat holds S8[ B212 ]) from NAT_1:sch 2(L602 , L590);
L604: ( dom C226 ) = ( dom C227 ) by L584 , L587 , FINSEQ_3:29;
thus L605: thesis by L604 , L603 , FINSEQ_1:13;
end;
end;
theorem
L607: (for R9 being set holds ( compose (( {} ) , R9) ) = ( id R9 ))
proof
let R9 being set;
L608: (ex B213 being (ManySortedFunction of ( NAT )) st (( compose (( {} ) , R9) ) = ( B213 . ( 0 ) ) & ( B213 . ( 0 ) ) = ( id R9 ) & (for B214 being (Element of ( NAT )) holds (( B214 + 1 ) in ( dom ( {} ) ) implies (for B215 , B216 being Function holds ((B215 = ( B213 . B214 ) & B216 = ( ( {} ) . ( B214 + 1 ) )) implies ( B213 . ( B214 + 1 ) ) = ( B216 * B215 ))))))) by L533 , CARD_1:27;
thus L609: thesis by L608;
end;
theorem
L610: (for R11 being set holds ( apply (( {} ) , R11) ) = <* R11 *>)
proof
let R11 being set;
L611: (( len ( apply (( {} ) , R11) ) ) = ( ( 0 ) + 1 ) & ( ( apply (( {} ) , R11) ) . 1 ) = R11) by L570 , CARD_1:27;
thus L612: thesis by L611 , FINSEQ_1:40;
end;
theorem
L613: (for R9 being set holds (for R12 being  Function-yielding FinSequence holds (for R14 being Function holds ( compose (( R12 ^ <* R14 *> ) , R9) ) = ( R14 * ( compose (R12 , R9) ) ))))
proof
let R9 being set;
let R12 being  Function-yielding FinSequence;
let R14 being Function;
L614: R14 = ( ( R12 ^ <* R14 *> ) . ( ( len R12 ) + 1 ) ) by FINSEQ_1:42;
L615: ( len <* R14 *> ) = 1 by FINSEQ_1:40;
L616: ( len ( R12 ^ <* R14 *> ) ) = ( ( len R12 ) + 1 ) by L615 , FINSEQ_1:22;
consider C229 being (ManySortedFunction of ( NAT )) such that L617: ( compose (( R12 ^ <* R14 *> ) , R9) ) = ( C229 . ( len ( R12 ^ <* R14 *> ) ) ) and L618: ( C229 . ( 0 ) ) = ( id R9 ) and L619: (for B217 being (Element of ( NAT )) holds (( B217 + 1 ) in ( dom ( R12 ^ <* R14 *> ) ) implies (for B218 , B219 being Function holds ((B218 = ( C229 . B217 ) & B219 = ( ( R12 ^ <* R14 *> ) . ( B217 + 1 ) )) implies ( C229 . ( B217 + 1 ) ) = ( B219 * B218 ))))) by L533;
reconsider D48 = ( C229 . ( len R12 ) ) as Function;
L620: ( dom R12 ) c= ( dom ( R12 ^ <* R14 *> ) ) by FINSEQ_1:26;
L621:
now
let C230 being (Element of ( NAT ));
assume L622: ( C230 + 1 ) in ( dom R12 );
let C231 , C232 being Function;
assume that
L623: C231 = ( C229 . C230 )
and
L624: C232 = ( R12 . ( C230 + 1 ) );
L625: C232 = ( ( R12 ^ <* R14 *> ) . ( C230 + 1 ) ) by L622 , L624 , FINSEQ_1:def 7;
thus L626: ( C229 . ( C230 + 1 ) ) = ( C232 * C231 ) by L625 , L619 , L620 , L622 , L623;
end;
L627: D48 = ( compose (R12 , R9) ) by L621 , L618 , L533;
L628: (1 in ( Seg 1 ) & ( dom <* R14 *> ) = ( Seg 1 )) by FINSEQ_1:2 , FINSEQ_1:38 , TARSKI:def 1;
thus L629: thesis by L628 , L617 , L619 , L627 , L616 , L614 , FINSEQ_1:28;
end;
theorem
L630: (for R11 being set holds (for R12 being  Function-yielding FinSequence holds (for R14 being Function holds ( apply (( R12 ^ <* R14 *> ) , R11) ) = ( ( apply (R12 , R11) ) ^ <* ( R14 . ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) ) *> ))))
proof
let R11 being set;
let R12 being  Function-yielding FinSequence;
let R14 being Function;
defpred S9[ Nat ] means ($1 in ( dom ( apply (R12 , R11) ) ) implies ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . $1 ) = ( ( apply (R12 , R11) ) . $1 ));
L631: ( len ( apply (R12 , R11) ) ) = ( ( len R12 ) + 1 ) by L570;
L632: ( ( apply (R12 , R11) ) . 1 ) = R11 by L570;
L633: (for B220 being Nat holds (S9[ B220 ] implies S9[ ( B220 + 1 ) ]))
proof
let C233 being Nat;
assume that
L634: (C233 in ( dom ( apply (R12 , R11) ) ) implies ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . C233 ) = ( ( apply (R12 , R11) ) . C233 ))
and
L635: ( C233 + 1 ) in ( dom ( apply (R12 , R11) ) );
L636: ( C233 + 1 ) <= ( len ( apply (R12 , R11) ) ) by L635 , FINSEQ_3:25;
L637: C233 <= ( len ( apply (R12 , R11) ) ) by L636 , NAT_1:13;
L638: C233 <= ( len R12 ) by L631 , L636 , XREAL_1:6;
per cases ;
suppose L639: C233 = ( 0 );

thus L640: thesis by L639 , L632 , L570;
end;
suppose L641: C233 > ( 0 );

reconsider D49 = ( R12 . C233 ) as Function;
L642: C233 >= ( ( 0 ) + 1 ) by L641 , NAT_1:13;
L643: C233 in ( dom R12 ) by L642 , L638 , FINSEQ_3:25;
L644: (( dom R12 ) c= ( dom ( R12 ^ <* R14 *> ) ) & D49 = ( ( R12 ^ <* R14 *> ) . C233 )) by L643 , FINSEQ_1:26 , FINSEQ_1:def 7;
L645: ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . ( C233 + 1 ) ) = ( D49 . ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . C233 ) ) by L644 , L643 , L570;
thus L646: thesis by L645 , L634 , L637 , L642 , L643 , L570 , FINSEQ_3:25;
end;
end;
L648: S9[ ( 0 ) ] by FINSEQ_3:25;
L649: (for B221 being Nat holds S9[ B221 ]) from NAT_1:sch 2(L648 , L633);
L650: ( len <* R14 *> ) = 1 by FINSEQ_1:40;
L651: ( len ( R12 ^ <* R14 *> ) ) = ( ( len R12 ) + 1 ) by L650 , FINSEQ_1:22;
L652: ( ( len R12 ) + 1 ) >= 1 by NAT_1:11;
L653: (( ( R12 ^ <* R14 *> ) . ( ( len R12 ) + 1 ) ) = R14 & ( ( len R12 ) + 1 ) in ( dom ( R12 ^ <* R14 *> ) )) by L652 , L651 , FINSEQ_1:42 , FINSEQ_3:25;
L654: ( ( len R12 ) + 1 ) in ( dom ( apply (R12 , R11) ) ) by L631 , L652 , FINSEQ_3:25;
L655:
now
let C234 being Nat;
assume L656: C234 in ( dom <* ( R14 . ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) ) *> );
L657: C234 in ( Seg 1 ) by L656 , FINSEQ_1:38;
L658: C234 = 1 by L657 , FINSEQ_1:2 , TARSKI:def 1;
L659: (( R14 . ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . ( ( len R12 ) + C234 ) ) ) = ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . ( ( len ( apply (R12 , R11) ) ) + C234 ) ) & ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . ( ( len R12 ) + C234 ) ) = ( ( apply (R12 , R11) ) . ( ( len R12 ) + C234 ) )) by L658 , L631 , L653 , L654 , L649 , L570;
thus L660: ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . ( ( len ( apply (R12 , R11) ) ) + C234 ) ) = ( <* ( R14 . ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) ) *> . C234 ) by L659 , L658 , FINSEQ_1:40;
end;
L661: ( len ( apply (( R12 ^ <* R14 *> ) , R11) ) ) = ( ( len ( R12 ^ <* R14 *> ) ) + 1 ) by L570;
L662: (( len <* ( R14 . ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) ) *> ) = 1 & ( dom ( apply (( R12 ^ <* R14 *> ) , R11) ) ) = ( Seg ( ( len ( apply (R12 , R11) ) ) + 1 ) )) by L661 , L631 , L651 , FINSEQ_1:40 , FINSEQ_1:def 3;
thus L663: thesis by L662 , L649 , L655 , FINSEQ_1:def 7;
end;
theorem
L664: (for R9 being set holds (for R12 being  Function-yielding FinSequence holds (for R14 being Function holds ( compose (( <* R14 *> ^ R12 ) , R9) ) = ( ( compose (R12 , ( R14 .: R9 )) ) * ( R14 | R9 ) ))))
proof
let R9 being set;
let R12 being  Function-yielding FinSequence;
let R14 being Function;
defpred S10[  Function-yielding FinSequence ] means ( compose (( <* R14 *> ^ $1 ) , R9) ) = ( ( compose ($1 , ( R14 .: R9 )) ) * ( R14 | R9 ) );
L665: (for B222 being  Function-yielding FinSequence holds (S10[ B222 ] implies (for B223 being Function holds S10[ ( B222 ^ <* B223 *> ) ])))
proof
let C235 being  Function-yielding FinSequence;
assume that
L666: ( compose (( <* R14 *> ^ C235 ) , R9) ) = ( ( compose (C235 , ( R14 .: R9 )) ) * ( R14 | R9 ) );
let C236 being Function;
thus L667: ( compose (( <* R14 *> ^ ( C235 ^ <* C236 *> ) ) , R9) ) = ( compose (( ( <* R14 *> ^ C235 ) ^ <* C236 *> ) , R9) ) by FINSEQ_1:32
.= ( C236 * ( compose (( <* R14 *> ^ C235 ) , R9) ) ) by L613
.= ( ( C236 * ( compose (C235 , ( R14 .: R9 )) ) ) * ( R14 | R9 ) ) by L666 , RELAT_1:36
.= ( ( compose (( C235 ^ <* C236 *> ) , ( R14 .: R9 )) ) * ( R14 | R9 ) ) by L613;
end;
L668: (( <* R14 *> ^ ( {} ) ) = <* R14 *> & ( ( {} ) ^ <* R14 *> ) = <* R14 *>) by FINSEQ_1:34;
L669: ( compose (( <* R14 *> ^ ( {} ) ) , R9) ) = ( R14 * ( compose (( {} ) , R9) ) ) by L668 , L613
.= ( R14 * ( id R9 ) ) by L607
.= ( R14 | R9 ) by RELAT_1:65
.= ( ( id ( rng ( R14 | R9 ) ) ) * ( R14 | R9 ) ) by RELAT_1:54
.= ( ( id ( R14 .: R9 ) ) * ( R14 | R9 ) ) by RELAT_1:115
.= ( ( compose (( {} ) , ( R14 .: R9 )) ) * ( R14 | R9 ) ) by L607;
L670: S10[ ( {} ) ] by L669;
L671: (for R12 being  Function-yielding FinSequence holds S10[ R12 ]) from FuncSeqInd(L670 , L665);
thus L672: thesis by L671;
end;
theorem
L673: (for R11 being set holds (for R12 being  Function-yielding FinSequence holds (for R14 being Function holds ( apply (( <* R14 *> ^ R12 ) , R11) ) = ( <* R11 *> ^ ( apply (R12 , ( R14 . R11 )) ) ))))
proof
let R11 being set;
let R12 being  Function-yielding FinSequence;
let R14 being Function;
defpred S11[  Function-yielding FinSequence ] means ( apply (( <* R14 *> ^ $1 ) , R11) ) = ( <* R11 *> ^ ( apply ($1 , ( R14 . R11 )) ) );
L674: ( len ( {} ) ) = ( 0 );
L675: (for B224 being  Function-yielding FinSequence holds (S11[ B224 ] implies (for B225 being Function holds S11[ ( B224 ^ <* B225 *> ) ])))
proof
let R12 being  Function-yielding FinSequence;
assume that
L676: ( apply (( <* R14 *> ^ R12 ) , R11) ) = ( <* R11 *> ^ ( apply (R12 , ( R14 . R11 )) ) );
let C237 being Function;
set D50 = ( <* R14 *> ^ R12 );
L677: ( len ( apply (R12 , ( R14 . R11 )) ) ) = ( ( len R12 ) + 1 ) by L570;
L678: ( len <* R14 *> ) = 1 by FINSEQ_1:40;
L679: ( len D50 ) = ( ( len R12 ) + 1 ) by L678 , FINSEQ_1:22;
L680: ( len D50 ) >= 1 by L679 , NAT_1:11;
L681: (( len <* R11 *> ) = 1 & ( len D50 ) in ( dom ( apply (R12 , ( R14 . R11 )) ) )) by L680 , L677 , L679 , FINSEQ_1:40 , FINSEQ_3:25;
L682: ( ( apply (D50 , R11) ) . ( 1 + ( len D50 ) ) ) = ( ( apply (R12 , ( R14 . R11 )) ) . ( ( len R12 ) + 1 ) ) by L681 , L676 , L679 , FINSEQ_1:def 7;
L683: ( apply (( D50 ^ <* C237 *> ) , R11) ) = ( ( apply (D50 , R11) ) ^ <* ( C237 . ( ( apply (D50 , R11) ) . ( ( len D50 ) + 1 ) ) ) *> ) by L630;
thus L684: ( apply (( <* R14 *> ^ ( R12 ^ <* C237 *> ) ) , R11) ) = ( ( <* R11 *> ^ ( apply (R12 , ( R14 . R11 )) ) ) ^ <* ( C237 . ( ( apply (R12 , ( R14 . R11 )) ) . ( ( len R12 ) + 1 ) ) ) *> ) by L683 , L676 , L682 , FINSEQ_1:32
.= ( <* R11 *> ^ ( ( apply (R12 , ( R14 . R11 )) ) ^ <* ( C237 . ( ( apply (R12 , ( R14 . R11 )) ) . ( ( len R12 ) + 1 ) ) ) *> ) ) by FINSEQ_1:32
.= ( <* R11 *> ^ ( apply (( R12 ^ <* C237 *> ) , ( R14 . R11 )) ) ) by L630;
end;
L685: (( <* R14 *> ^ ( {} ) ) = <* R14 *> & ( ( {} ) ^ <* R14 *> ) = <* R14 *>) by FINSEQ_1:34;
L686: ( apply (( <* R14 *> ^ ( {} ) ) , R11) ) = ( ( apply (( {} ) , R11) ) ^ <* ( R14 . ( ( apply (( {} ) , R11) ) . ( ( 0 ) + 1 ) ) ) *> ) by L685 , L674 , L630
.= ( <* R11 *> ^ <* ( R14 . ( ( apply (( {} ) , R11) ) . 1 ) ) *> ) by L610
.= ( <* R11 *> ^ <* ( R14 . ( <* R11 *> . 1 ) ) *> ) by L610
.= ( <* R11 *> ^ <* ( R14 . R11 ) *> ) by FINSEQ_1:40
.= ( <* R11 *> ^ ( apply (( {} ) , ( R14 . R11 )) ) ) by L610;
L687: S11[ ( {} ) ] by L686;
L688: (for R12 being  Function-yielding FinSequence holds S11[ R12 ]) from FuncSeqInd(L687 , L675);
thus L689: thesis by L688;
end;
theorem
L690: (for R9 being set holds (for R14 being Function holds ( compose (<* R14 *> , R9) ) = ( R14 * ( id R9 ) )))
proof
let R9 being set;
let R14 being Function;
L691: <* R14 *> = ( ( {} ) ^ <* R14 *> ) by FINSEQ_1:34;
thus L692: ( compose (<* R14 *> , R9) ) = ( R14 * ( compose (( {} ) , R9) ) ) by L691 , L613
.= ( R14 * ( id R9 ) ) by L607;
end;
theorem
L693: (for R9 being set holds (for R14 being Function holds (( dom R14 ) c= R9 implies ( compose (<* R14 *> , R9) ) = R14)))
proof
let R9 being set;
let R14 being Function;
L694: ( compose (<* R14 *> , R9) ) = ( R14 * ( id R9 ) ) by L690;
thus L695: thesis by L694 , RELAT_1:51;
end;
theorem
L696: (for R11 being set holds (for R14 being Function holds ( apply (<* R14 *> , R11) ) = <* R11 , ( R14 . R11 ) *>))
proof
let R11 being set;
let R14 being Function;
L697: ( <* R11 *> . ( ( 0 ) + 1 ) ) = R11 by FINSEQ_1:40;
L698: (( apply (( {} ) , R11) ) = <* R11 *> & ( len ( {} ) ) = ( 0 )) by L610;
thus L699: ( apply (<* R14 *> , R11) ) = ( apply (( ( {} ) ^ <* R14 *> ) , R11) ) by FINSEQ_1:34
.= ( <* R11 *> ^ <* ( R14 . R11 ) *> ) by L698 , L697 , L630
.= <* R11 , ( R14 . R11 ) *> by FINSEQ_1:def 9;
end;
theorem
L700: (for R9 being set holds (for R10 being set holds (for R12 being  Function-yielding FinSequence holds (for R13 being  Function-yielding FinSequence holds (( rng ( compose (R12 , R9) ) ) c= R10 implies ( compose (( R12 ^ R13 ) , R9) ) = ( ( compose (R13 , R10) ) * ( compose (R12 , R9) ) ))))))
proof
let R9 being set;
let R10 being set;
let R12 being  Function-yielding FinSequence;
let R13 being  Function-yielding FinSequence;
assume L701: ( rng ( compose (R12 , R9) ) ) c= R10;
defpred S12[  Function-yielding FinSequence ] means ( compose (( R12 ^ $1 ) , R9) ) = ( ( compose ($1 , R10) ) * ( compose (R12 , R9) ) );
L702: (for B226 being  Function-yielding FinSequence holds (S12[ B226 ] implies (for B227 being Function holds S12[ ( B226 ^ <* B227 *> ) ])))
proof
let R13 being  Function-yielding FinSequence;
assume that
L703: ( compose (( R12 ^ R13 ) , R9) ) = ( ( compose (R13 , R10) ) * ( compose (R12 , R9) ) );
let R14 being Function;
thus L704: ( compose (( R12 ^ ( R13 ^ <* R14 *> ) ) , R9) ) = ( compose (( ( R12 ^ R13 ) ^ <* R14 *> ) , R9) ) by FINSEQ_1:32
.= ( R14 * ( compose (( R12 ^ R13 ) , R9) ) ) by L613
.= ( ( R14 * ( compose (R13 , R10) ) ) * ( compose (R12 , R9) ) ) by L703 , RELAT_1:36
.= ( ( compose (( R13 ^ <* R14 *> ) , R10) ) * ( compose (R12 , R9) ) ) by L613;
end;
L705: ( compose (( R12 ^ ( {} ) ) , R9) ) = ( compose (R12 , R9) ) by FINSEQ_1:34
.= ( ( id R10 ) * ( compose (R12 , R9) ) ) by L701 , RELAT_1:53
.= ( ( compose (( {} ) , R10) ) * ( compose (R12 , R9) ) ) by L607;
L706: S12[ ( {} ) ] by L705;
L707: (for R13 being  Function-yielding FinSequence holds S12[ R13 ]) from FuncSeqInd(L706 , L702);
thus L708: thesis by L707;
end;
theorem
L709: (for R11 being set holds (for R12 being  Function-yielding FinSequence holds (for R13 being  Function-yielding FinSequence holds ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) = ( ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) . ( ( len R13 ) + 1 ) ))))
proof
let R11 being set;
let R12 being  Function-yielding FinSequence;
let R13 being  Function-yielding FinSequence;
defpred S13[  Function-yielding FinSequence ] means ( ( apply (( R12 ^ $1 ) , R11) ) . ( ( len ( R12 ^ $1 ) ) + 1 ) ) = ( ( apply ($1 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) . ( ( len $1 ) + 1 ) );
L710: (for B228 being  Function-yielding FinSequence holds (S13[ B228 ] implies (for B229 being Function holds S13[ ( B228 ^ <* B229 *> ) ])))
proof
set D51 = ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) );
let R13 being  Function-yielding FinSequence;
assume that
L711: ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) = ( ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) . ( ( len R13 ) + 1 ) );
let C238 being Function;
L712: ( len <* C238 *> ) = 1 by FINSEQ_1:40;
L713: ( len ( ( R12 ^ R13 ) ^ <* C238 *> ) ) = ( ( len ( R12 ^ R13 ) ) + 1 ) by L712 , FINSEQ_1:22;
L714: ( len ( R13 ^ <* C238 *> ) ) = ( ( len R13 ) + 1 ) by L712 , FINSEQ_1:22;
L715: (( apply (( R13 ^ <* C238 *> ) , D51) ) = ( ( apply (R13 , D51) ) ^ <* ( C238 . ( ( apply (R13 , D51) ) . ( ( len R13 ) + 1 ) ) ) *> ) & ( len ( apply (R13 , D51) ) ) = ( ( len R13 ) + 1 )) by L570 , L630;
L716: ( len ( apply (( R12 ^ R13 ) , R11) ) ) = ( ( len ( R12 ^ R13 ) ) + 1 ) by L570;
L717: (( R12 ^ ( R13 ^ <* C238 *> ) ) = ( ( R12 ^ R13 ) ^ <* C238 *> ) & ( apply (( ( R12 ^ R13 ) ^ <* C238 *> ) , R11) ) = ( ( apply (( R12 ^ R13 ) , R11) ) ^ <* ( C238 . ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) ) *> )) by L630 , FINSEQ_1:32;
thus L718: ( ( apply (( R12 ^ ( R13 ^ <* C238 *> ) ) , R11) ) . ( ( len ( R12 ^ ( R13 ^ <* C238 *> ) ) ) + 1 ) ) = ( C238 . ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) ) by L717 , L716 , L713 , FINSEQ_1:42
.= ( ( apply (( R13 ^ <* C238 *> ) , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) . ( ( len ( R13 ^ <* C238 *> ) ) + 1 ) ) by L711 , L715 , L714 , FINSEQ_1:42;
end;
L719: (( apply (( {} ) , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) = <* ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) *> & ( R12 ^ ( {} ) ) = R12) by L610 , FINSEQ_1:34;
L720: S13[ ( {} ) ] by L719 , FINSEQ_1:40;
L721: (for R13 being  Function-yielding FinSequence holds S13[ R13 ]) from FuncSeqInd(L720 , L710);
thus L722: thesis by L721;
end;
theorem
L723: (for R11 being set holds (for R12 being  Function-yielding FinSequence holds (for R13 being  Function-yielding FinSequence holds ( apply (( R12 ^ R13 ) , R11) ) = ( ( apply (R12 , R11) ) $^ ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ))))
proof
let R11 being set;
let R12 being  Function-yielding FinSequence;
let R13 being  Function-yielding FinSequence;
defpred S14[  Function-yielding FinSequence ] means ( apply (( R12 ^ $1 ) , R11) ) = ( ( apply (R12 , R11) ) $^ ( apply ($1 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) );
L724: ( len ( apply (R12 , R11) ) ) = ( ( len R12 ) + 1 ) by L570;
consider C239 being FinSequence, C240 being set such that L725: ( apply (R12 , R11) ) = ( C239 ^ <* C240 *> ) by L724 , CARD_1:27 , FINSEQ_1:46;
L726: (for B230 being  Function-yielding FinSequence holds (S14[ B230 ] implies (for B231 being Function holds S14[ ( B230 ^ <* B231 *> ) ])))
proof
let R13 being  Function-yielding FinSequence;
assume that
L727: ( apply (( R12 ^ R13 ) , R11) ) = ( ( apply (R12 , R11) ) $^ ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) );
L728: ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) = ( ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) . ( ( len R13 ) + 1 ) ) by L709;
let R14 being Function;
L729: ( len ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ) = ( ( len R13 ) + 1 ) by L570;
L730: ( len ( apply (( R13 ^ <* R14 *> ) , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ) = ( ( len ( R13 ^ <* R14 *> ) ) + 1 ) by L570;
thus L731: ( apply (( R12 ^ ( R13 ^ <* R14 *> ) ) , R11) ) = ( apply (( ( R12 ^ R13 ) ^ <* R14 *> ) , R11) ) by FINSEQ_1:32
.= ( ( apply (( R12 ^ R13 ) , R11) ) ^ <* ( R14 . ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) ) *> ) by L630
.= ( ( C239 ^ ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ) ^ <* ( R14 . ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) ) *> ) by L725 , L727 , L729 , CARD_1:27 , REWRITE1:2
.= ( C239 ^ ( ( apply (R13 , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ^ <* ( R14 . ( ( apply (( R12 ^ R13 ) , R11) ) . ( ( len ( R12 ^ R13 ) ) + 1 ) ) ) *> ) ) by FINSEQ_1:32
.= ( C239 ^ ( apply (( R13 ^ <* R14 *> ) , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ) by L728 , L630
.= ( ( apply (R12 , R11) ) $^ ( apply (( R13 ^ <* R14 *> ) , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ) by L725 , L730 , CARD_1:27 , REWRITE1:2;
end;
L732: ( len <* C240 *> ) = 1 by FINSEQ_1:40;
L733: ( ( len R12 ) + 1 ) = ( ( len C239 ) + 1 ) by L732 , L724 , L725 , FINSEQ_1:22;
L734: ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) = C240 by L733 , L725 , FINSEQ_1:42;
L735: ( apply (( R12 ^ ( {} ) ) , R11) ) = ( apply (R12 , R11) ) by FINSEQ_1:34
.= ( ( apply (R12 , R11) ) $^ <* ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) *> ) by L725 , L734 , REWRITE1:2
.= ( ( apply (R12 , R11) ) $^ ( apply (( {} ) , ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) )) ) ) by L610;
L736: S14[ ( {} ) ] by L735;
L737: (for R13 being  Function-yielding FinSequence holds S14[ R13 ]) from FuncSeqInd(L736 , L726);
thus L738: thesis by L737;
end;
theorem
L739: (for R9 being set holds (for R14 being Function holds (for R15 being Function holds ( compose (<* R14 , R15 *> , R9) ) = ( ( R15 * R14 ) * ( id R9 ) ))))
proof
let R9 being set;
let R14 being Function;
let R15 being Function;
L740: <* R14 , R15 *> = ( <* R14 *> ^ <* R15 *> ) by FINSEQ_1:def 9;
thus L741: ( compose (<* R14 , R15 *> , R9) ) = ( R15 * ( compose (<* R14 *> , R9) ) ) by L740 , L613
.= ( R15 * ( R14 * ( id R9 ) ) ) by L690
.= ( ( R15 * R14 ) * ( id R9 ) ) by RELAT_1:36;
end;
theorem
L742: (for R9 being set holds (for R14 being Function holds (for R15 being Function holds ((( dom R14 ) c= R9 or ( dom ( R15 * R14 ) ) c= R9) implies ( compose (<* R14 , R15 *> , R9) ) = ( R15 * R14 )))))
proof
let R9 being set;
let R14 being Function;
let R15 being Function;
L743: (( compose (<* R14 , R15 *> , R9) ) = ( ( R15 * R14 ) * ( id R9 ) ) & ( ( R15 * R14 ) * ( id R9 ) ) = ( R15 * ( R14 * ( id R9 ) ) )) by L739 , RELAT_1:36;
thus L744: thesis by L743 , RELAT_1:51;
end;
theorem
L745: (for R11 being set holds (for R14 being Function holds (for R15 being Function holds ( apply (<* R14 , R15 *> , R11) ) = <* R11 , ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *>)))
proof
let R11 being set;
let R14 being Function;
let R15 being Function;
L746: (( apply (<* R14 *> , R11) ) = <* R11 , ( R14 . R11 ) *> & ( len <* R14 *> ) = 1) by L696 , FINSEQ_1:40;
thus L747: ( apply (<* R14 , R15 *> , R11) ) = ( apply (( <* R14 *> ^ <* R15 *> ) , R11) ) by FINSEQ_1:def 9
.= ( <* R11 , ( R14 . R11 ) *> ^ <* ( R15 . ( <* R11 , ( R14 . R11 ) *> . ( 1 + 1 ) ) ) *> ) by L746 , L630
.= ( <* R11 , ( R14 . R11 ) *> ^ <* ( R15 . ( R14 . R11 ) ) *> ) by FINSEQ_1:44
.= <* R11 , ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> by FINSEQ_1:43;
end;
theorem
L748: (for R9 being set holds (for R14 being Function holds (for R15 being Function holds (for R16 being Function holds ( compose (<* R14 , R15 , R16 *> , R9) ) = ( ( ( R16 * R15 ) * R14 ) * ( id R9 ) )))))
proof
let R9 being set;
let R14 being Function;
let R15 being Function;
let R16 being Function;
L749: <* R14 , R15 , R16 *> = ( <* R14 , R15 *> ^ <* R16 *> ) by FINSEQ_1:43;
thus L750: ( compose (<* R14 , R15 , R16 *> , R9) ) = ( R16 * ( compose (<* R14 , R15 *> , R9) ) ) by L749 , L613
.= ( R16 * ( ( R15 * R14 ) * ( id R9 ) ) ) by L739
.= ( ( R16 * ( R15 * R14 ) ) * ( id R9 ) ) by RELAT_1:36
.= ( ( ( R16 * R15 ) * R14 ) * ( id R9 ) ) by RELAT_1:36;
end;
theorem
L751: (for R9 being set holds (for R14 being Function holds (for R15 being Function holds (for R16 being Function holds ((( dom R14 ) c= R9 or ( dom ( R15 * R14 ) ) c= R9 or ( dom ( ( R16 * R15 ) * R14 ) ) c= R9) implies ( compose (<* R14 , R15 , R16 *> , R9) ) = ( ( R16 * R15 ) * R14 ))))))
proof
let R9 being set;
let R14 being Function;
let R15 being Function;
let R16 being Function;
L752: (( ( R16 * R15 ) * ( R14 * ( id R9 ) ) ) = ( R16 * ( R15 * ( R14 * ( id R9 ) ) ) ) & ( R15 * ( R14 * ( id R9 ) ) ) = ( ( R15 * R14 ) * ( id R9 ) )) by RELAT_1:36;
L753: ( R16 * ( R15 * R14 ) ) = ( ( R16 * R15 ) * R14 ) by RELAT_1:36;
L754: (( compose (<* R14 , R15 , R16 *> , R9) ) = ( ( ( R16 * R15 ) * R14 ) * ( id R9 ) ) & ( ( ( R16 * R15 ) * R14 ) * ( id R9 ) ) = ( ( R16 * R15 ) * ( R14 * ( id R9 ) ) )) by L748 , RELAT_1:36;
thus L755: thesis by L754 , L752 , L753 , RELAT_1:51;
end;
theorem
L756: (for R11 being set holds (for R14 being Function holds (for R15 being Function holds (for R16 being Function holds ( apply (<* R14 , R15 , R16 *> , R11) ) = ( <* R11 *> ^ <* ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) , ( R16 . ( R15 . ( R14 . R11 ) ) ) *> )))))
proof
let R11 being set;
let R14 being Function;
let R15 being Function;
let R16 being Function;
L757: (( apply (<* R14 , R15 *> , R11) ) = <* R11 , ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> & ( len <* R14 , R15 *> ) = 2) by L745 , FINSEQ_1:44;
thus L758: ( apply (<* R14 , R15 , R16 *> , R11) ) = ( apply (( <* R14 , R15 *> ^ <* R16 *> ) , R11) ) by FINSEQ_1:43
.= ( <* R11 , ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> ^ <* ( R16 . ( <* R11 , ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> . ( 2 + 1 ) ) ) *> ) by L757 , L630
.= ( <* R11 , ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> ^ <* ( R16 . ( R15 . ( R14 . R11 ) ) ) *> ) by FINSEQ_1:45
.= ( ( <* R11 *> ^ <* ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> ) ^ <* ( R16 . ( R15 . ( R14 . R11 ) ) ) *> ) by FINSEQ_1:43
.= ( <* R11 *> ^ ( <* ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) *> ^ <* ( R16 . ( R15 . ( R14 . R11 ) ) ) *> ) ) by FINSEQ_1:32
.= ( <* R11 *> ^ <* ( R14 . R11 ) , ( R15 . ( R14 . R11 ) ) , ( R16 . ( R15 . ( R14 . R11 ) ) ) *> ) by FINSEQ_1:43;
end;
definition
let C241 being FinSequence;
func firstdom C241 means 
:L759: it is  empty if C241 is  empty otherwise it = ( proj1 ( C241 . 1 ) );
correctness;
func lastrng C241 means 
:L760: it is  empty if C241 is  empty otherwise it = ( proj2 ( C241 . ( len C241 ) ) );
correctness;
end;
theorem
L762: (( firstdom ( {} ) ) = ( {} ) & ( lastrng ( {} ) ) = ( {} )) by L759 , L760;
theorem
L763: (for R14 being Function holds (for B232 being FinSequence holds (( firstdom ( <* R14 *> ^ B232 ) ) = ( dom R14 ) & ( lastrng ( B232 ^ <* R14 *> ) ) = ( rng R14 ))))
proof
let R14 being Function;
let C242 being FinSequence;
thus L764: ( firstdom ( <* R14 *> ^ C242 ) ) = ( proj1 ( ( <* R14 *> ^ C242 ) . 1 ) ) by L759
.= ( dom R14 ) by FINSEQ_1:41;
L765: ( len <* R14 *> ) = 1 by FINSEQ_1:40;
L766: ( len ( C242 ^ <* R14 *> ) ) = ( ( len C242 ) + 1 ) by L765 , FINSEQ_1:22;
thus L767: ( lastrng ( C242 ^ <* R14 *> ) ) = ( proj2 ( ( C242 ^ <* R14 *> ) . ( ( len C242 ) + 1 ) ) ) by L766 , L760
.= ( rng R14 ) by FINSEQ_1:42;
end;
theorem
L768: (for R9 being set holds (for B233 being  Function-yielding FinSequence holds (B233 <> ( {} ) implies ( rng ( compose (B233 , R9) ) ) c= ( lastrng B233 ))))
proof
let R9 being set;
defpred S15[  Function-yielding FinSequence ] means ($1 <> ( {} ) implies ( rng ( compose ($1 , R9) ) ) c= ( lastrng $1 ));
L769: (for B234 being  Function-yielding FinSequence holds (S15[ B234 ] implies (for B235 being Function holds S15[ ( B234 ^ <* B235 *> ) ])))
proof
let R13 being  Function-yielding FinSequence;
assume L770: (R13 <> ( {} ) implies ( rng ( compose (R13 , R9) ) ) c= ( lastrng R13 ));
let R14 being Function;
assume L771: ( R13 ^ <* R14 *> ) <> ( {} );
L772: ( compose (( R13 ^ <* R14 *> ) , R9) ) = ( R14 * ( compose (R13 , R9) ) ) by L613;
L773: ( rng ( compose (( R13 ^ <* R14 *> ) , R9) ) ) c= ( rng R14 ) by L772 , RELAT_1:26;
thus L774: thesis by L773 , L763;
end;
L775: S15[ ( {} ) ];
thus L776: (for R12 being  Function-yielding FinSequence holds S15[ R12 ]) from FuncSeqInd(L775 , L769);
end;
definition
let C243 being FinSequence;
attr C243 is  FuncSeq-like
means
:L777: (ex B236 being FinSequence st (( len B236 ) = ( ( len C243 ) + 1 ) & (for B237 being (Element of ( NAT )) holds (B237 in ( dom C243 ) implies ( C243 . B237 ) in ( Funcs (( B236 . B237 ) , ( B236 . ( B237 + 1 ) )) )))));
end;
theorem
L779: (for B238 , B239 being FinSequence holds (( B238 ^ B239 ) is  FuncSeq-like implies (B238 is  FuncSeq-like & B239 is  FuncSeq-like)))
proof
let C244 , C245 being FinSequence;
given C246 being FinSequence such that
L780: ( len C246 ) = ( ( len ( C244 ^ C245 ) ) + 1 )
and
L781: (for B240 being (Element of ( NAT )) holds (B240 in ( dom ( C244 ^ C245 ) ) implies ( ( C244 ^ C245 ) . B240 ) in ( Funcs (( C246 . B240 ) , ( C246 . ( B240 + 1 ) )) )));

reconsider D52 = ( C246 | ( Seg ( ( len C244 ) + 1 ) ) ) , D53 = ( C246 | ( Seg ( len C244 ) ) ) as FinSequence by FINSEQ_1:15;
L782: ( len ( C244 ^ C245 ) ) = ( ( len C244 ) + ( len C245 ) ) by FINSEQ_1:22;
L783: ( len C244 ) <= ( len ( C244 ^ C245 ) ) by L782 , NAT_1:11;
L784: ( len ( C244 ^ C245 ) ) <= ( len C246 ) by L780 , NAT_1:11;
L785: ( len C244 ) <= ( len C246 ) by L784 , L783 , XXREAL_0:2;
L786: ( len D53 ) = ( len C244 ) by L785 , FINSEQ_1:17;
thus L787:now
take D54 = D52;
L788: ( len C244 ) <= ( len ( C244 ^ C245 ) ) by L782 , NAT_1:11;
L789: ( ( len C244 ) + 1 ) <= ( len C246 ) by L788 , L780 , XREAL_1:6;
thus L790: ( len D54 ) = ( ( len C244 ) + 1 ) by L789 , FINSEQ_1:17;
let C247 being (Element of ( NAT ));
assume L791: C247 in ( dom C244 );
L792: ( ( C244 ^ C245 ) . C247 ) = ( C244 . C247 ) by L791 , FINSEQ_1:def 7;
L793: ( C244 . C247 ) in ( Funcs (( C246 . C247 ) , ( C246 . ( C247 + 1 ) )) ) by L792 , L781 , L791 , FINSEQ_3:22;
L794: C247 in ( dom D54 ) by L790 , L791 , L241;
L795: ( C246 . C247 ) = ( D54 . C247 ) by L794 , FUNCT_1:47;
L796: ( C247 + 1 ) in ( dom D54 ) by L790 , L791 , L241;
thus L797: ( C244 . C247 ) in ( Funcs (( D54 . C247 ) , ( D54 . ( C247 + 1 ) )) ) by L796 , L793 , L795 , FUNCT_1:47;
end;
consider C248 being FinSequence such that L798: C246 = ( D53 ^ C248 ) by FINSEQ_1:80;
take C248;
L799: ( len C246 ) = ( ( len D53 ) + ( len C248 ) ) by L798 , FINSEQ_1:22;
thus L800: ( len C248 ) = ( ( len C245 ) + 1 ) by L799 , L780 , L782 , L786;
let C249 being (Element of ( NAT ));
assume L801: C249 in ( dom C245 );
L802: ( ( C244 ^ C245 ) . ( ( len C244 ) + C249 ) ) = ( C245 . C249 ) by L801 , FINSEQ_1:def 7;
L803: ( C245 . C249 ) in ( Funcs (( C246 . ( ( len C244 ) + C249 ) ) , ( C246 . ( ( ( len C244 ) + C249 ) + 1 ) )) ) by L802 , L781 , L801 , FINSEQ_1:28;
L804: ( ( len C244 ) + ( ( len C245 ) + 1 ) ) = ( ( len C244 ) + ( len C248 ) ) by L780 , L782 , L798 , L786 , FINSEQ_1:22;
L805: ( C249 + 1 ) in ( dom C248 ) by L804 , L801 , L241;
L806: ( C248 . ( C249 + 1 ) ) = ( C246 . ( ( len C244 ) + ( C249 + 1 ) ) ) by L805 , L798 , L786 , FINSEQ_1:def 7;
L807: C249 in ( dom C248 ) by L804 , L801 , L241;
thus L808: thesis by L807 , L798 , L786 , L803 , L806 , FINSEQ_1:def 7;
end;
registration
cluster  FuncSeq-like ->  Function-yielding for FinSequence;
coherence
proof
let C250 being FinSequence;
given C251 being FinSequence such that
L809: ( len C251 ) = ( ( len C250 ) + 1 )
and
L810: (for B241 being (Element of ( NAT )) holds (B241 in ( dom C250 ) implies ( C250 . B241 ) in ( Funcs (( C251 . B241 ) , ( C251 . ( B241 + 1 ) )) )));

let C252 being set;
assume L811: C252 in ( dom C250 );
reconsider D55 = C252 as (Element of ( NAT )) by L811;
L812: ( C250 . D55 ) in ( Funcs (( C251 . D55 ) , ( C251 . ( D55 + 1 ) )) ) by L810 , L811;
thus L813: thesis by L812;
end;
end;
registration
cluster  empty ->  FuncSeq-like for FinSequence;
coherence
proof
let C253 being FinSequence;
assume L815: C253 is  empty;
take D56 = <* ( {} ) *>;
thus L816: ( len D56 ) = ( ( len C253 ) + 1 ) by L815 , CARD_1:27 , FINSEQ_1:40;
thus L817: thesis by L815;
end;
end;
registration
let C254 being Function;
cluster <* C254 *> ->  FuncSeq-like;
coherence
proof
take D57 = <* ( dom C254 ) , ( rng C254 ) *>;
set D58 = <* C254 *>;
thus L819: ( len D57 ) = ( 1 + 1 ) by FINSEQ_1:44
.= ( ( len D58 ) + 1 ) by FINSEQ_1:40;
let C255 being (Element of ( NAT ));
assume L820: C255 in ( dom D58 );
L821: C255 in { 1 } by L820 , FINSEQ_1:2 , FINSEQ_1:38;
L822: C255 = 1 by L821 , TARSKI:def 1;
L823: ( D57 . ( C255 + 1 ) ) = ( rng C254 ) by L822 , FINSEQ_1:44;
L824: (( D58 . C255 ) = C254 & ( D57 . C255 ) = ( dom C254 )) by L822 , FINSEQ_1:40 , FINSEQ_1:44;
thus L825: thesis by L824 , L823 , FUNCT_2:def 2;
end;
end;
registration
cluster  FuncSeq-like non  empty  non-empty for FinSequence;
existence
proof
set D59 = the non  empty Function;
take D60 = <* D59 *>;
thus L827: D60 is  FuncSeq-like;
thus L828: D60 is non  empty;
let C256 being set;
assume L829: C256 in ( dom D60 );
L830: C256 in { 1 } by L829 , FINSEQ_1:2 , FINSEQ_1:38;
L831: C256 = 1 by L830 , TARSKI:def 1;
thus L832: thesis by L831 , FINSEQ_1:40;
end;
end;
definition
mode FuncSequence
 is  FuncSeq-like FinSequence;
end;
theorem
L835: (for R9 being set holds (for B242 being FuncSequence holds (B242 <> ( {} ) implies ( dom ( compose (B242 , R9) ) ) = ( ( firstdom B242 ) /\ R9 ))))
proof
let R9 being set;
defpred S16[  Function-yielding FinSequence ] means (($1 is FuncSequence & $1 <> ( {} )) implies ( dom ( compose ($1 , R9) ) ) = ( ( firstdom $1 ) /\ R9 ));
L836: (for B243 being  Function-yielding FinSequence holds (S16[ B243 ] implies (for B244 being Function holds S16[ ( B243 ^ <* B244 *> ) ])))
proof
let R13 being  Function-yielding FinSequence;
assume L837: ((R13 is FuncSequence & R13 <> ( {} )) implies ( dom ( compose (R13 , R9) ) ) = ( ( firstdom R13 ) /\ R9 ));
let R14 being Function;
assume that
L838: ( R13 ^ <* R14 *> ) is FuncSequence
and
L839: ( R13 ^ <* R14 *> ) <> ( {} );
L840: ( compose (( R13 ^ <* R14 *> ) , R9) ) = ( R14 * ( compose (R13 , R9) ) ) by L613;
per cases ;
suppose L841: R13 = ( {} );

L842: ( R13 ^ <* R14 *> ) = <* R14 *> by L841 , FINSEQ_1:34;
L843: ( compose (( R13 ^ <* R14 *> ) , R9) ) = ( R14 * ( id R9 ) ) by L842 , L690;
L844: ( <* R14 *> ^ ( {} ) ) = <* R14 *> by FINSEQ_1:34;
L845: ( firstdom ( R13 ^ <* R14 *> ) ) = ( dom R14 ) by L844 , L842 , L763;
thus L846: thesis by L845 , L843 , FUNCT_1:19;
end;
suppose L847: R13 <> ( {} );

consider C257 being set, C258 being FinSequence such that L848: R13 = ( <* C257 *> ^ C258 ) and L849: ( len R13 ) = ( ( len C258 ) + 1 ) by L847 , REWRITE1:5;
L850: ( R13 . 1 ) = C257 by L848 , FINSEQ_1:41;
L851: ( firstdom R13 ) = ( proj1 C257 ) by L850 , L848 , L759;
L852: ( len R13 ) >= 1 by L849 , NAT_1:11;
L853: ( len R13 ) in ( dom R13 ) by L852 , FINSEQ_3:25;
L854: ( ( R13 ^ <* R14 *> ) . ( len R13 ) ) = ( R13 . ( len R13 ) ) by L853 , FINSEQ_1:def 7;
L855: ( rng ( compose (R13 , R9) ) ) c= ( lastrng R13 ) by L847 , L768;
consider C259 being FinSequence such that L856: ( len C259 ) = ( ( len ( R13 ^ <* R14 *> ) ) + 1 ) and L857: (for B245 being (Element of ( NAT )) holds (B245 in ( dom ( R13 ^ <* R14 *> ) ) implies ( ( R13 ^ <* R14 *> ) . B245 ) in ( Funcs (( C259 . B245 ) , ( C259 . ( B245 + 1 ) )) ))) by L838 , L777;
consider C260 being FinSequence, C261 being set such that L858: R13 = ( C260 ^ <* C261 *> ) by L847 , FINSEQ_1:46;
L859: ( len <* R14 *> ) = 1 by FINSEQ_1:40;
L860: ( len ( R13 ^ <* R14 *> ) ) = ( ( len R13 ) + 1 ) by L859 , FINSEQ_1:22;
L861: ( len R13 ) <= ( len ( R13 ^ <* R14 *> ) ) by L860 , NAT_1:11;
L862: ( len R13 ) in ( dom ( R13 ^ <* R14 *> ) ) by L861 , L852 , FINSEQ_3:25;
L863: ( ( R13 ^ <* R14 *> ) . ( len R13 ) ) in ( Funcs (( C259 . ( len R13 ) ) , ( C259 . ( ( len R13 ) + 1 ) )) ) by L862 , L857;
L864: ( len <* C261 *> ) = 1 by FINSEQ_1:40;
L865: ( len R13 ) = ( ( len C260 ) + 1 ) by L864 , L858 , FINSEQ_1:22;
L866: ( R13 . ( len R13 ) ) = C261 by L865 , L858 , FINSEQ_1:42;
consider C262 being Function such that L867: C261 = C262 and L868: ( dom C262 ) = ( C259 . ( len R13 ) ) and L869: ( rng C262 ) c= ( C259 . ( ( len R13 ) + 1 ) ) by L866 , L863 , L854 , FUNCT_2:def 2;
L870: ( ( <* C257 *> ^ ( C258 ^ <* R14 *> ) ) . 1 ) = C257 by FINSEQ_1:41;
L871: ( ( len R13 ) + 1 ) >= 1 by NAT_1:11;
L872: ( ( len R13 ) + 1 ) in ( dom ( R13 ^ <* R14 *> ) ) by L871 , L860 , FINSEQ_3:25;
L873: ( ( R13 ^ <* R14 *> ) . ( ( len R13 ) + 1 ) ) in ( Funcs (( C259 . ( ( len R13 ) + 1 ) ) , ( C259 . ( ( ( len R13 ) + 1 ) + 1 ) )) ) by L872 , L857;
L874: ( ( R13 ^ <* R14 *> ) . ( ( len R13 ) + 1 ) ) = R14 by FINSEQ_1:42;
L875: (ex B246 being Function st (R14 = B246 & ( dom B246 ) = ( C259 . ( ( len R13 ) + 1 ) ) & ( rng B246 ) c= ( C259 . ( ( ( len R13 ) + 1 ) + 1 ) ))) by L874 , L873 , FUNCT_2:def 2;
L876: ( R13 ^ <* R14 *> ) = ( <* C257 *> ^ ( C258 ^ <* R14 *> ) ) by L848 , FINSEQ_1:32;
L877: ( firstdom ( R13 ^ <* R14 *> ) ) = ( proj1 C257 ) by L876 , L870 , L759;
L878: ( lastrng R13 ) = ( rng C262 ) by L858 , L867 , L763;
thus L879: thesis by L878 , L837 , L838 , L840 , L847 , L877 , L851 , L869 , L875 , L855 , L779 , RELAT_1:27 , XBOOLE_1:1;
end;
end;
L881: S16[ ( {} ) ];
L882: (for B247 being  Function-yielding FinSequence holds S16[ B247 ]) from FuncSeqInd(L881 , L836);
thus L883: thesis by L882;
end;
theorem
L884: (for B248 being FuncSequence holds ( dom ( compose (B248 , ( firstdom B248 )) ) ) = ( firstdom B248 ))
proof
let C263 being FuncSequence;
per cases ;
suppose L885: C263 = ( {} );

L886: ( compose (C263 , ( firstdom C263 )) ) = ( id ( firstdom C263 ) ) by L885 , L607;
thus L887: thesis by L886 , RELAT_1:45;
end;
suppose L888: C263 <> ( {} );

L889: ( dom ( compose (C263 , ( firstdom C263 )) ) ) = ( ( firstdom C263 ) /\ ( firstdom C263 ) ) by L888 , L835;
thus L890: thesis by L889;
end;
end;
theorem
L892: (for B249 being FuncSequence holds (for B250 being Function holds (( rng B250 ) c= ( firstdom B249 ) implies ( <* B250 *> ^ B249 ) is FuncSequence)))
proof
let C264 being FuncSequence;
let C265 being Function;
assume that
L893: ( rng C265 ) c= ( firstdom C264 );
consider C266 being FinSequence such that L894: ( len C266 ) = ( ( len C264 ) + 1 ) and L895: (for B251 being (Element of ( NAT )) holds (B251 in ( dom C264 ) implies ( C264 . B251 ) in ( Funcs (( C266 . B251 ) , ( C266 . ( B251 + 1 ) )) ))) by L777;
set D61 = ( <* ( dom C265 ) *> ^ C266 );
L896: ( len <* ( dom C265 ) *> ) = 1 by FINSEQ_1:40;
L897: ( len <* C265 *> ) = 1 by FINSEQ_1:40;
L898: ( len ( <* C265 *> ^ C264 ) ) = ( ( len C264 ) + 1 ) by L897 , FINSEQ_1:22;
L899:
now
assume L900: C264 <> ( {} );
L901: ( len C264 ) >= ( ( 0 ) + 1 ) by L900 , NAT_1:13;
L902: 1 in ( dom C264 ) by L901 , FINSEQ_3:25;
L903: ( C264 . 1 ) in ( Funcs (( C266 . 1 ) , ( C266 . ( 1 + 1 ) )) ) by L902 , L895;
L904: (ex B252 being Function st (( C264 . 1 ) = B252 & ( dom B252 ) = ( C266 . 1 ) & ( rng B252 ) c= ( C266 . 2 ))) by L903 , FUNCT_2:def 2;
thus L905: ( rng C265 ) c= ( C266 . 1 ) by L904 , L893 , L900 , L759;
end;
L906: ( <* C265 *> ^ C264 ) is  FuncSeq-like
proof
take D61;
L907: 1 <= ( len C266 ) by L894 , NAT_1:11;
L908: 1 in ( dom C266 ) by L907 , FINSEQ_3:25;
thus L909: ( len D61 ) = ( ( len ( <* C265 *> ^ C264 ) ) + 1 ) by L894 , L896 , L898 , FINSEQ_1:22;
let C267 being (Element of ( NAT ));
assume L910: C267 in ( dom ( <* C265 *> ^ C264 ) );
L911: C267 >= 1 by L910 , FINSEQ_3:25;
L912: ( {} ) c= ( C266 . 1 ) by XBOOLE_1:2;
L913: ( rng C265 ) c= ( C266 . 1 ) by L912 , L893 , L899 , L762;
L914: C267 <= ( ( len C264 ) + 1 ) by L898 , L910 , FINSEQ_3:25;
per cases ;
suppose L915: C267 = 1;

L916: (( D61 . C267 ) = ( dom C265 ) & ( ( <* C265 *> ^ C264 ) . C267 ) = C265) by L915 , FINSEQ_1:41;
L917: ( D61 . ( C267 + 1 ) ) = ( C266 . 1 ) by L896 , L908 , L915 , FINSEQ_1:def 7;
thus L918: thesis by L917 , L913 , L916 , FUNCT_2:def 2;
end;
suppose L919: C267 <> 1;

L920: C267 > 1 by L919 , L911 , XXREAL_0:1;
L921: C267 >= ( 1 + 1 ) by L920 , NAT_1:13;
consider C268 being Nat such that L922: C267 = ( ( 1 + 1 ) + C268 ) by L921 , NAT_1:10;
L923: C267 = ( ( C268 + 1 ) + 1 ) by L922;
L924: (( C268 + 1 ) >= 1 & ( C268 + 1 ) <= ( len C264 )) by L923 , L914 , NAT_1:11 , XREAL_1:6;
L925: ( C268 + 1 ) in ( dom C264 ) by L924 , FINSEQ_3:25;
L926: ( C264 . ( C268 + 1 ) ) = ( ( <* C265 *> ^ C264 ) . C267 ) by L925 , L897 , L923 , FINSEQ_1:def 7;
L927: ( ( C268 + 1 ) + 1 ) in ( dom C266 ) by L894 , L925 , L241;
L928: ( C264 . ( C268 + 1 ) ) in ( Funcs (( C266 . ( C268 + 1 ) ) , ( C266 . ( ( C268 + 1 ) + 1 ) )) ) by L895 , L925;
L929: ( C268 + 1 ) in ( dom C266 ) by L894 , L925 , L241;
L930: ( D61 . C267 ) = ( C266 . ( C268 + 1 ) ) by L929 , L896 , L922 , L928 , FINSEQ_1:def 7;
thus L931: thesis by L930 , L896 , L922 , L928 , L927 , L926 , FINSEQ_1:def 7;
end;
end;
thus L933: thesis by L906;
end;
theorem
L934: (for B253 being FuncSequence holds (for B254 being Function holds (( lastrng B253 ) c= ( dom B254 ) implies ( B253 ^ <* B254 *> ) is FuncSequence)))
proof
let C269 being FuncSequence;
let C270 being Function;
assume that
L935: ( lastrng C269 ) c= ( dom C270 );
consider C271 being FinSequence such that L936: ( len C271 ) = ( ( len C269 ) + 1 ) and L937: (for B255 being (Element of ( NAT )) holds (B255 in ( dom C269 ) implies ( C269 . B255 ) in ( Funcs (( C271 . B255 ) , ( C271 . ( B255 + 1 ) )) ))) by L777;
consider C272 being FinSequence, C273 being set such that L938: C271 = ( C272 ^ <* C273 *> ) by L936 , CARD_1:27 , FINSEQ_1:46;
L939:
now
assume L940: ( len C269 ) in ( dom C269 );
L941: ( C269 . ( len C269 ) ) in ( Funcs (( C271 . ( len C269 ) ) , ( C271 . ( ( len C269 ) + 1 ) )) ) by L940 , L937;
consider C274 being Function such that L942: ( C269 . ( len C269 ) ) = C274 and L943: ( dom C274 ) = ( C271 . ( len C269 ) ) and L944: ( rng C274 ) c= ( C271 . ( ( len C269 ) + 1 ) ) by L941 , FUNCT_2:def 2;
L945: ( lastrng C269 ) = ( rng C274 ) by L940 , L942 , L760 , RELAT_1:38;
thus L946: ( C269 . ( len C269 ) ) in ( Funcs (( C271 . ( len C269 ) ) , ( dom C270 )) ) by L945 , L935 , L942 , L943 , FUNCT_2:def 2;
end;
L947: ( <* ( dom C270 ) , ( rng C270 ) *> . 1 ) = ( dom C270 ) by FINSEQ_1:44;
L948: ( <* ( dom C270 ) , ( rng C270 ) *> . 2 ) = ( rng C270 ) by FINSEQ_1:44;
L949: ( len <* C270 *> ) = 1 by FINSEQ_1:40;
L950: ( len ( C269 ^ <* C270 *> ) ) = ( ( len C269 ) + 1 ) by L949 , FINSEQ_1:22;
set D62 = ( C272 ^ <* ( dom C270 ) , ( rng C270 ) *> );
L951: ( len <* ( dom C270 ) , ( rng C270 ) *> ) = 2 by FINSEQ_1:44;
L952: ( len D62 ) = ( ( len C272 ) + ( 1 + 1 ) ) by L951 , FINSEQ_1:22;
L953: ( dom <* ( dom C270 ) , ( rng C270 ) *> ) = ( Seg 2 ) by FINSEQ_1:89;
L954: 1 in ( dom <* ( dom C270 ) , ( rng C270 ) *> ) by L953 , FINSEQ_1:2 , TARSKI:def 2;
L955: ( len <* C273 *> ) = 1 by FINSEQ_1:40;
L956: ( len C271 ) = ( ( len C272 ) + 1 ) by L955 , L938 , FINSEQ_1:22;
L957: 2 in ( dom <* ( dom C270 ) , ( rng C270 ) *> ) by L953 , FINSEQ_1:2 , TARSKI:def 2;
L958: ( C269 ^ <* C270 *> ) is  FuncSeq-like
proof
take D62;
thus L959: ( len D62 ) = ( ( len ( C269 ^ <* C270 *> ) ) + 1 ) by L936 , L956 , L950 , L952;
let C275 being (Element of ( NAT ));
assume L960: C275 in ( dom ( C269 ^ <* C270 *> ) );
L961: C275 >= 1 by L960 , FINSEQ_3:25;
L962: C275 <= ( ( len C269 ) + 1 ) by L950 , L960 , FINSEQ_3:25;
L963: (C275 = ( ( len C269 ) + 1 ) or ( len C269 ) >= C275) by L962 , NAT_1:8;
per cases  by L963 , XXREAL_0:1;
suppose L964: C275 = ( ( len C269 ) + 1 );

L965: (( D62 . C275 ) = ( dom C270 ) & ( ( C269 ^ <* C270 *> ) . C275 ) = C270) by L964 , L936 , L956 , L954 , L947 , FINSEQ_1:42 , FINSEQ_1:def 7;
L966: ( D62 . ( C275 + 1 ) ) = ( rng C270 ) by L936 , L956 , L952 , L957 , L948 , L964 , FINSEQ_1:def 7;
thus L967: thesis by L966 , L965 , FUNCT_2:def 2;
end;
suppose L968: C275 = ( len C269 );

L969: C275 in ( dom C272 ) by L968 , L936 , L956 , L961 , FINSEQ_3:25;
L970: (( D62 . C275 ) = ( C272 . C275 ) & ( C272 . C275 ) = ( C271 . C275 )) by L969 , L938 , FINSEQ_1:def 7;
L971: (( len C269 ) in ( dom C269 ) & ( D62 . ( C275 + 1 ) ) = ( dom C270 )) by L936 , L956 , L954 , L947 , L961 , L968 , FINSEQ_1:def 7 , FINSEQ_3:25;
thus L972: thesis by L971 , L939 , L968 , L970 , FINSEQ_1:def 7;
end;
suppose L973: C275 < ( len C269 );

L974: C275 in ( dom C272 ) by L973 , L936 , L956 , L961 , FINSEQ_3:25;
L975: (( C271 . C275 ) = ( C272 . C275 ) & ( C272 . C275 ) = ( D62 . C275 )) by L974 , L938 , FINSEQ_1:def 7;
L976: ( C275 + 1 ) >= 1 by NAT_1:11;
L977: C275 in ( dom C269 ) by L961 , L973 , FINSEQ_3:25;
L978: (( C269 . C275 ) in ( Funcs (( C271 . C275 ) , ( C271 . ( C275 + 1 ) )) ) & ( C269 . C275 ) = ( ( C269 ^ <* C270 *> ) . C275 )) by L977 , L937 , FINSEQ_1:def 7;
L979: ( C275 + 1 ) <= ( len C269 ) by L973 , NAT_1:13;
L980: ( C275 + 1 ) in ( dom C272 ) by L979 , L936 , L956 , L976 , FINSEQ_3:25;
L981: ( C271 . ( C275 + 1 ) ) = ( C272 . ( C275 + 1 ) ) by L980 , L938 , FINSEQ_1:def 7;
thus L982: thesis by L981 , L980 , L975 , L978 , FINSEQ_1:def 7;
end;
end;
thus L984: thesis by L958;
end;
theorem
L985: (for R9 being set holds (for R11 being set holds (for B256 being FuncSequence holds ((R11 in ( firstdom B256 ) & R11 in R9) implies ( ( apply (B256 , R11) ) . ( ( len B256 ) + 1 ) ) = ( ( compose (B256 , R9) ) . R11 )))))
proof
let R9 being set;
let R11 being set;
defpred S17[  Function-yielding FinSequence ] means (($1 is FuncSequence & R11 in ( firstdom $1 ) & R11 in R9) implies ( ( apply ($1 , R11) ) . ( ( len $1 ) + 1 ) ) = ( ( compose ($1 , R9) ) . R11 ));
L986: (for B257 being  Function-yielding FinSequence holds (S17[ B257 ] implies (for B258 being Function holds S17[ ( B257 ^ <* B258 *> ) ])))
proof
L987: ( dom ( id R9 ) ) = R9;
let R12 being  Function-yielding FinSequence;
assume that
L988: ((R12 is FuncSequence & R11 in ( firstdom R12 ) & R11 in R9) implies ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) = ( ( compose (R12 , R9) ) . R11 ));
let R14 being Function;
assume that
L989: ( R12 ^ <* R14 *> ) is FuncSequence
and
L990: R11 in ( firstdom ( R12 ^ <* R14 *> ) )
and
L991: R11 in R9;
L992: R12 is FuncSequence by L989 , L779;
L993: ( ( id R9 ) . R11 ) = R11 by L991 , FUNCT_1:17;
L994: ( ( R14 * ( id R9 ) ) . R11 ) = ( R14 . R11 ) by L993 , L991 , L987 , FUNCT_1:13;
L995: ( len <* R14 *> ) = 1 by FINSEQ_1:40;
L996: ( compose (( R12 ^ <* R14 *> ) , R9) ) = ( R14 * ( compose (R12 , R9) ) ) by L613;
L997: (( apply (<* R14 *> , R11) ) = <* R11 , ( R14 . R11 ) *> & ( compose (<* R14 *> , R9) ) = ( R14 * ( id R9 ) )) by L690 , L696;
L998: ( apply (( R12 ^ <* R14 *> ) , R11) ) = ( ( apply (R12 , R11) ) ^ <* ( R14 . ( ( apply (R12 , R11) ) . ( ( len R12 ) + 1 ) ) ) *> ) by L630;
per cases ;
suppose L999: R12 = ( {} );

L1000: ( R12 ^ <* R14 *> ) = <* R14 *> by L999 , FINSEQ_1:34;
thus L1001: thesis by L1000 , L995 , L997 , L994 , FINSEQ_1:44;
end;
suppose L1002: R12 <> ( {} );

L1003: ( dom ( compose (R12 , R9) ) ) = ( ( firstdom R12 ) /\ R9 ) by L1002 , L992 , L835;
L1004: ( firstdom ( R12 ^ <* R14 *> ) ) = ( proj1 ( ( R12 ^ <* R14 *> ) . 1 ) ) by L759;
L1005: ( firstdom R12 ) = ( proj1 ( R12 . 1 ) ) by L1002 , L759;
L1006: ( len R12 ) >= ( ( 0 ) + 1 ) by L1002 , NAT_1:13;
L1007: 1 in ( dom R12 ) by L1006 , FINSEQ_3:25;
L1008: ( R12 . 1 ) = ( ( R12 ^ <* R14 *> ) . 1 ) by L1007 , FINSEQ_1:def 7;
L1009: R11 in ( ( firstdom R12 ) /\ R9 ) by L1008 , L990 , L991 , L1005 , L1004 , XBOOLE_0:def 4;
L1010: (( len ( apply (R12 , R11) ) ) = ( ( len R12 ) + 1 ) & ( len ( R12 ^ <* R14 *> ) ) = ( ( len R12 ) + 1 )) by L995 , L570 , FINSEQ_1:22;
thus L1011: ( ( apply (( R12 ^ <* R14 *> ) , R11) ) . ( ( len ( R12 ^ <* R14 *> ) ) + 1 ) ) = ( R14 . ( ( compose (R12 , R9) ) . R11 ) ) by L1010 , L988 , L989 , L990 , L991 , L998 , L1005 , L1004 , L1007 , L779 , FINSEQ_1:42 , FINSEQ_1:def 7
.= ( ( compose (( R12 ^ <* R14 *> ) , R9) ) . R11 ) by L996 , L1003 , L1009 , FUNCT_1:13;
end;
end;
L1013: S17[ ( {} ) ] by L759;
L1014: (for R12 being  Function-yielding FinSequence holds S17[ R12 ]) from FuncSeqInd(L1013 , L986);
thus L1015: thesis by L1014;
end;
definition
let C276 , C277 being set;
assume that
L1016: (C277 is  empty implies C276 is  empty);
mode FuncSequence of C276 , C277
 -> FuncSequence
means :L1017: (( firstdom it ) = C276 & ( lastrng it ) c= C277);
existence
proof
set D63 = the (Function of C276 , C277);
take D64 = <* D63 *>;
L1018: (( D64 ^ ( {} ) ) = D64 & ( ( {} ) ^ D64 ) = D64) by FINSEQ_1:34;
L1019: (( dom D63 ) = C276 & ( rng D63 ) c= C277) by L1016 , FUNCT_2:def 1;
thus L1020: thesis by L1019 , L1018 , L763;
end;
end;
definition
let C278 being non  empty set;
let C279 being set;
let C280 being (FuncSequence of C279 , C278);
redefine func compose (C280 , C279) -> (Function of C279 , C278);

coherence
proof
L1022: ( firstdom C280 ) = C279 by L1017;
L1023:
now
assume L1024: C280 = ( {} );
L1025: (C279 = ( {} ) & ( compose (C280 , C279) ) = ( id C279 )) by L1024 , L1022 , L759 , L607;
thus L1026: ( rng ( compose (C280 , C279) ) ) = ( {} ) by L1025;
end;
L1027: ( rng ( compose (C280 , C279) ) ) c= ( lastrng C280 ) by L1023 , L768 , XBOOLE_1:2;
L1028: ( lastrng C280 ) c= C278 by L1017;
L1029: ( rng ( compose (C280 , C279) ) ) c= C278 by L1028 , L1027 , XBOOLE_1:1;
L1030: ( dom ( compose (C280 , C279) ) ) = C279 by L1022 , L884;
thus L1031: thesis by L1030 , L1029 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
definition
let C281 being  non-empty non  empty FinSequence;
mode FuncSequence of C281
 -> FinSequence
means :L1033: (( ( len it ) + 1 ) = ( len C281 ) & (for B259 being (Element of ( NAT )) holds (B259 in ( dom it ) implies ( it . B259 ) in ( Funcs (( C281 . B259 ) , ( C281 . ( B259 + 1 ) )) ))));
existence
proof
defpred S18[ set , set ] means (ex B260 being (Element of ( NAT )) st (B260 = $1 & $2 in ( Funcs (( C281 . B260 ) , ( C281 . ( B260 + 1 ) )) )));
consider C282 being Nat such that L1034: ( len C281 ) = ( C282 + 1 ) by NAT_1:6;
reconsider D65 = C282 as (Element of ( NAT )) by ORDINAL1:def 12;
L1035: (for B261 being set holds (B261 in ( Seg D65 ) implies (ex B262 being set st S18[ B261 , B262 ])))
proof
let C283 being set;
assume L1036: C283 in ( Seg D65 );
reconsider D66 = C283 as (Element of ( NAT )) by L1036;
L1037: D66 <= D65 by L1036 , FINSEQ_1:1;
L1038: (( D66 + 1 ) >= 1 & ( D66 + 1 ) <= ( D65 + 1 )) by L1037 , NAT_1:11 , XREAL_1:6;
L1039: ( D66 + 1 ) in ( dom C281 ) by L1038 , L1034 , FINSEQ_3:25;
L1040: D65 <= ( D65 + 1 ) by NAT_1:11;
L1041: D66 <= ( D65 + 1 ) by L1040 , L1037 , XXREAL_0:2;
L1042: D66 >= 1 by L1036 , FINSEQ_1:1;
L1043: D66 in ( dom C281 ) by L1042 , L1034 , L1041 , FINSEQ_3:25;
reconsider D67 = ( C281 . D66 ) , D68 = ( C281 . ( D66 + 1 ) ) as non  empty set by L1043 , L1039;
set D69 = the (Function of D67 , D68);
take D69;
take D66;
thus L1044: thesis by FUNCT_2:8;
end;
consider C284 being Function such that L1045: ( dom C284 ) = ( Seg D65 ) and L1046: (for B263 being set holds (B263 in ( Seg D65 ) implies S18[ B263 , ( C284 . B263 ) ])) from CLASSES1:sch 1(L1035);
reconsider D70 = C284 as FinSequence by L1045 , FINSEQ_1:def 2;
take D70;
thus L1047: ( ( len D70 ) + 1 ) = ( len C281 ) by L1034 , L1045 , FINSEQ_1:def 3;
let C285 being (Element of ( NAT ));
assume L1048: C285 in ( dom D70 );
L1049: (ex B264 being (Element of ( NAT )) st (B264 = C285 & ( D70 . C285 ) in ( Funcs (( C281 . B264 ) , ( C281 . ( B264 + 1 ) )) ))) by L1048 , L1045 , L1046;
thus L1050: thesis by L1049;
end;
end;
registration
let C286 being  non-empty non  empty FinSequence;
cluster  ->  FuncSeq-like  non-empty for (FuncSequence of C286);
coherence
proof
let C287 being (FuncSequence of C286);
thus L1052: C287 is  FuncSeq-like
proof
take C286;
thus L1053: thesis by L1033;
end;

let C288 being set;
assume L1054: C288 in ( dom C287 );
reconsider D71 = C288 as (Element of ( NAT )) by L1054;
L1055: ( len C286 ) = ( ( len C287 ) + 1 ) by L1033;
L1056: (D71 in ( dom C286 ) & ( D71 + 1 ) in ( dom C286 )) by L1055 , L1054 , L241;
reconsider D72 = ( C286 . D71 ) , D73 = ( C286 . ( D71 + 1 ) ) as non  empty set by L1056;
L1057: ( C287 . D71 ) in ( Funcs (D72 , D73) ) by L1054 , L1033;
L1058: (ex R14 being Function st (( C287 . C288 ) = R14 & ( dom R14 ) = D72 & ( rng R14 ) c= D73)) by L1057 , FUNCT_2:def 2;
thus L1059: thesis by L1058;
end;
end;
theorem
L1061: (for B265 being  non-empty non  empty FinSequence holds (for B266 being (FuncSequence of B265) holds (B266 <> ( {} ) implies (( firstdom B266 ) = ( B265 . 1 ) & ( lastrng B266 ) c= ( B265 . ( len B265 ) )))))
proof
let C289 being  non-empty non  empty FinSequence;
let C290 being (FuncSequence of C289);
assume L1062: C290 <> ( {} );
L1063: 1 in ( dom C290 ) by L1062 , FINSEQ_5:6;
L1064: ( C290 . 1 ) in ( Funcs (( C289 . 1 ) , ( C289 . ( 1 + 1 ) )) ) by L1063 , L1033;
L1065: (ex B267 being Function st (( C290 . 1 ) = B267 & ( dom B267 ) = ( C289 . 1 ) & ( rng B267 ) c= ( C289 . 2 ))) by L1064 , FUNCT_2:def 2;
thus L1066: ( firstdom C290 ) = ( C289 . 1 ) by L1065 , L1062 , L759;
L1067: ( len C290 ) in ( dom C290 ) by L1062 , FINSEQ_5:6;
L1068: ( C290 . ( len C290 ) ) in ( Funcs (( C289 . ( len C290 ) ) , ( C289 . ( ( len C290 ) + 1 ) )) ) by L1067 , L1033;
L1069: (ex B268 being Function st (( C290 . ( len C290 ) ) = B268 & ( dom B268 ) = ( C289 . ( len C290 ) ) & ( rng B268 ) c= ( C289 . ( ( len C290 ) + 1 ) ))) by L1068 , FUNCT_2:def 2;
L1070: ( ( len C290 ) + 1 ) = ( len C289 ) by L1033;
thus L1071: thesis by L1070 , L1062 , L1069 , L760;
end;
theorem
L1072: (for B269 being  non-empty non  empty FinSequence holds (for B270 being (FuncSequence of B269) holds (( dom ( compose (B270 , ( B269 . 1 )) ) ) = ( B269 . 1 ) & ( rng ( compose (B270 , ( B269 . 1 )) ) ) c= ( B269 . ( len B269 ) ))))
proof
let C291 being  non-empty non  empty FinSequence;
let C292 being (FuncSequence of C291);
per cases ;
suppose L1073: C292 = ( {} );

L1074: ( len C291 ) = ( ( len C292 ) + 1 ) by L1033;
L1075: (( compose (C292 , ( C291 . 1 )) ) = ( id ( C291 . 1 ) ) & ( len C292 ) = ( 0 )) by L1073 , L607;
thus L1076: thesis by L1075 , L1074 , RELAT_1:45;
end;
suppose L1077: C292 <> ( {} );

L1078: ( lastrng C292 ) c= ( C291 . ( len C291 ) ) by L1077 , L1061;
L1079: (( firstdom C292 ) = ( C291 . 1 ) & ( rng ( compose (C292 , ( C291 . 1 )) ) ) c= ( lastrng C292 )) by L1077 , L768 , L1061;
thus L1080: thesis by L1079 , L1078 , L884 , XBOOLE_1:1;
end;
end;
registration
let C293 being set;
let C294 being (Function of ( NAT ) , ( bool [: C293 , C293 :] ));
let C295 being Nat;
cluster ( C294 . C295 ) ->  Relation-like;
coherence
proof
reconsider D74 = C295 as (Element of ( NAT )) by ORDINAL1:def 12;
L1082: ( C294 . D74 ) is (Element of ( bool [: C293 , C293 :] ));
thus L1083: thesis by L1082;
end;
end;
L1085: (for R9 being set holds (for B271 being (Function of R9 , R9) holds ( rng B271 ) c= ( dom B271 )))
proof
let R9 being set;
let C296 being (Function of R9 , R9);
L1086: ( dom C296 ) = R9 by FUNCT_2:52;
thus L1087: thesis by L1086;
end;
L1088: (for B272 being Relation holds (for B273 being (Element of ( NAT )) holds (for B274 , B275 being (Function of ( NAT ) , ( bool [: ( field B272 ) , ( field B272 ) :] )) holds ((( B274 . ( 0 ) ) = ( id ( field B272 ) ) & (for B276 being Nat holds ( B274 . ( B276 + 1 ) ) = ( B272 * ( B274 . B276 ) )) & ( B275 . ( 0 ) ) = ( id ( field B272 ) ) & (for B277 being Nat holds ( B275 . ( B277 + 1 ) ) = ( B272 * ( B275 . B277 ) ))) implies B274 = B275))))
proof
let C297 being Relation;
let C298 being (Element of ( NAT ));
let C299 , C300 being (Function of ( NAT ) , ( bool [: ( field C297 ) , ( field C297 ) :] ));
assume that
L1089: ( C299 . ( 0 ) ) = ( id ( field C297 ) )
and
L1090: (for B278 being Nat holds ( C299 . ( B278 + 1 ) ) = ( C297 * ( C299 . B278 ) ))
and
L1091: ( C300 . ( 0 ) ) = ( id ( field C297 ) )
and
L1092: (for B279 being Nat holds ( C300 . ( B279 + 1 ) ) = ( C297 * ( C300 . B279 ) ));
defpred S19[ Nat , Relation , set ] means $3 = ( C297 * $2 );
L1093: (for B280 being Nat holds S19[ B280 , ( C299 . B280 ) , ( C299 . ( B280 + 1 ) ) ]) by L1090;
set D75 = ( bool [: ( field C297 ) , ( field C297 ) :] );
reconsider D76 = ( id ( field C297 ) ) as (Element of D75);
L1094: ( C300 . ( 0 ) ) = D76 by L1091;
L1095: (for B281 being Nat holds (for B282 , B283 , B284 being (Element of D75) holds ((S19[ B281 , B282 , B283 ] & S19[ B281 , B282 , B284 ]) implies B283 = B284)));
L1096: (for B285 being Nat holds S19[ B285 , ( C300 . B285 ) , ( C300 . ( B285 + 1 ) ) ]) by L1092;
L1097: ( C299 . ( 0 ) ) = D76 by L1089;
L1098: C299 = C300 from NAT_1:sch 14(L1097 , L1093 , L1094 , L1096 , L1095);
thus L1099: thesis by L1098;
end;
definition
let C301 being Relation;
let C302 being Nat;
func iter (C301 , C302) -> Relation means 
:L1100: (ex B286 being (Function of ( NAT ) , ( bool [: ( field C301 ) , ( field C301 ) :] )) st (it = ( B286 . C302 ) & ( B286 . ( 0 ) ) = ( id ( field C301 ) ) & (for B287 being Nat holds ( B286 . ( B287 + 1 ) ) = ( C301 * ( B286 . B287 ) ))));
existence
proof
reconsider D77 = C302 as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S20[ Nat , Relation , set ] means $3 = ( C301 * $2 );
set D78 = ( bool [: ( field C301 ) , ( field C301 ) :] );
reconsider D79 = ( id ( field C301 ) ) as (Element of D78);
L1101: (for B288 being (Element of ( NAT )) holds (for B289 being (Element of D78) holds (ex B290 being (Element of D78) st S20[ B288 , B289 , B290 ])))
proof
L1102: (( dom C301 ) c= ( field C301 ) & ( rng C301 ) c= ( field C301 )) by XBOOLE_1:7;
reconsider D80 = C301 as (Relation of ( field C301 ) , ( field C301 )) by L1102 , RELSET_1:4;
let C303 being (Element of ( NAT ));
let C304 being (Element of D78);
reconsider D81 = C304 as (Relation of ( field C301 ) , ( field C301 ));
L1103: ( D80 * D81 ) is (Element of D78);
thus L1104: thesis by L1103;
end;
consider C305 being (Function of ( NAT ) , D78) such that L1105: (( C305 . ( 0 ) ) = D79 & (for B291 being (Element of ( NAT )) holds S20[ B291 , ( C305 . B291 ) , ( C305 . ( B291 + 1 ) ) ])) from RECDEF_1:sch 2(L1101);
L1106: (for B292 being Nat holds S20[ B292 , ( C305 . B292 ) , ( C305 . ( B292 + 1 ) ) ])
proof
let C306 being Nat;
L1107: C306 in ( NAT ) by ORDINAL1:def 12;
thus L1108: thesis by L1107 , L1105;
end;
L1109: ( C305 . D77 ) is (Relation of ( field C301 ) , ( field C301 ));
thus L1110: thesis by L1109 , L1105 , L1106;
end;
uniqueness by L1088;
end;
registration
let C307 being Function;
let C308 being Nat;
cluster ( iter (C307 , C308) ) ->  Function-like;
coherence
proof
consider C309 being (Function of ( NAT ) , ( bool [: ( field C307 ) , ( field C307 ) :] )) such that L1112: (( C309 . C308 ) = ( iter (C307 , C308) ) & ( C309 . ( 0 ) ) = ( id ( field C307 ) )) and L1113: (for B293 being Nat holds ( C309 . ( B293 + 1 ) ) = ( C307 * ( C309 . B293 ) )) by L1100;
defpred S21[ Nat ] means ( C309 . $1 ) is Function;
L1114: S21[ ( 0 ) ] by L1112;
L1115: (for B294 being Nat holds (S21[ B294 ] implies S21[ ( B294 + 1 ) ]))
proof
let C310 being Nat;
assume L1116: S21[ C310 ];
reconsider D82 = ( C309 . C310 ) as Function by L1116;
L1117: ( C309 . ( C310 + 1 ) ) = ( D82 * C307 ) by L1113;
thus L1118: thesis by L1117;
end;
L1119: (for B295 being Nat holds S21[ B295 ]) from NAT_1:sch 2(L1114 , L1115);
thus L1120: thesis by L1119 , L1112;
end;
end;
L1122: (for R20 being Relation holds (( ( id ( field R20 ) ) * R20 ) = R20 & ( R20 * ( id ( field R20 ) ) ) = R20))
proof
let R20 being Relation;
L1123: (( dom R20 ) c= ( field R20 ) & ( rng R20 ) c= ( field R20 )) by XBOOLE_1:7;
thus L1124: thesis by L1123 , RELAT_1:51 , RELAT_1:53;
end;
theorem
L1125: (for R20 being Relation holds ( iter (R20 , ( 0 )) ) = ( id ( field R20 ) ))
proof
let R20 being Relation;
L1126: (ex B296 being (Function of ( NAT ) , ( bool [: ( field R20 ) , ( field R20 ) :] )) st (( iter (R20 , ( 0 )) ) = ( B296 . ( 0 ) ) & ( B296 . ( 0 ) ) = ( id ( field R20 ) ) & (for B297 being Nat holds ( B296 . ( B297 + 1 ) ) = ( R20 * ( B296 . B297 ) )))) by L1100;
thus L1127: thesis by L1126;
end;
L1128: (for R20 being Relation holds (( rng R20 ) c= ( dom R20 ) implies ( iter (R20 , ( 0 )) ) = ( id ( dom R20 ) )))
proof
let R20 being Relation;
assume L1129: ( rng R20 ) c= ( dom R20 );
L1130: ( field R20 ) = ( dom R20 ) by L1129 , XBOOLE_1:12;
thus L1131: thesis by L1130 , L1125;
end;
theorem
L1132: (for R20 being Relation holds (for B298 being Nat holds ( iter (R20 , ( B298 + 1 )) ) = ( R20 * ( iter (R20 , B298) ) )))
proof
let R20 being Relation;
let C311 being Nat;
consider C312 being (Function of ( NAT ) , ( bool [: ( field R20 ) , ( field R20 ) :] )) such that L1133: (( C312 . ( C311 + 1 ) ) = ( iter (R20 , ( C311 + 1 )) ) & ( C312 . ( 0 ) ) = ( id ( field R20 ) )) and L1134: (for B299 being Nat holds ( C312 . ( B299 + 1 ) ) = ( R20 * ( C312 . B299 ) )) by L1100;
L1135: ( C312 . ( C311 + 1 ) ) = ( R20 * ( C312 . C311 ) ) by L1134;
thus L1136: thesis by L1135 , L1133 , L1134 , L1100;
end;
theorem
L1137: (for R20 being Relation holds ( iter (R20 , 1) ) = R20)
proof
let R20 being Relation;
thus L1138: ( iter (R20 , 1) ) = ( iter (R20 , ( ( 0 ) + 1 )) )
.= ( R20 * ( iter (R20 , ( 0 )) ) ) by L1132
.= ( R20 * ( id ( field R20 ) ) ) by L1125
.= R20 by L1122;
end;
theorem
L1139: (for R20 being Relation holds (for B300 being Nat holds ( iter (R20 , ( B300 + 1 )) ) = ( ( iter (R20 , B300) ) * R20 )))
proof
let R20 being Relation;
let C313 being Nat;
defpred S22[ Nat ] means ( iter (R20 , ( $1 + 1 )) ) = ( ( iter (R20 , $1) ) * R20 );
L1140: (for B301 being Nat holds (S22[ B301 ] implies S22[ ( B301 + 1 ) ]))
proof
let C314 being Nat;
assume L1141: ( iter (R20 , ( C314 + 1 )) ) = ( ( iter (R20 , C314) ) * R20 );
thus L1142: ( ( iter (R20 , ( C314 + 1 )) ) * R20 ) = ( ( R20 * ( iter (R20 , C314) ) ) * R20 ) by L1132
.= ( R20 * ( ( iter (R20 , C314) ) * R20 ) ) by RELAT_1:36
.= ( iter (R20 , ( ( C314 + 1 ) + 1 )) ) by L1141 , L1132;
end;
L1143: ( iter (R20 , ( ( 0 ) + 1 )) ) = R20 by L1137
.= ( ( id ( field R20 ) ) * R20 ) by L1122
.= ( ( iter (R20 , ( 0 )) ) * R20 ) by L1125;
L1144: S22[ ( 0 ) ] by L1143;
L1145: (for B302 being Nat holds S22[ B302 ]) from NAT_1:sch 2(L1144 , L1140);
thus L1146: thesis by L1145;
end;
theorem
L1147: (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds (( dom ( iter (R20 , R18) ) ) c= ( field R20 ) & ( rng ( iter (R20 , R18) ) ) c= ( field R20 ))))
proof
let R18 being (Element of ( NAT ));
let R20 being Relation;
defpred S23[ (Element of ( NAT )) ] means (( dom ( iter (R20 , $1) ) ) c= ( field R20 ) & ( rng ( iter (R20 , $1) ) ) c= ( field R20 ));
L1148: (for R19 being (Element of ( NAT )) holds (S23[ R19 ] implies S23[ ( R19 + 1 ) ]))
proof
let R19 being (Element of ( NAT ));
L1149: ( iter (R20 , ( R19 + 1 )) ) = ( ( iter (R20 , R19) ) * R20 ) by L1139;
L1150: ( dom ( iter (R20 , ( R19 + 1 )) ) ) c= ( dom ( iter (R20 , R19) ) ) by L1149 , RELAT_1:25;
L1151: ( iter (R20 , ( R19 + 1 )) ) = ( R20 * ( iter (R20 , R19) ) ) by L1132;
L1152: ( rng ( iter (R20 , ( R19 + 1 )) ) ) c= ( rng ( iter (R20 , R19) ) ) by L1151 , RELAT_1:26;
assume L1153: (( dom ( iter (R20 , R19) ) ) c= ( field R20 ) & ( rng ( iter (R20 , R19) ) ) c= ( field R20 ));
thus L1154: thesis by L1153 , L1150 , L1152 , XBOOLE_1:1;
end;
L1155: ( iter (R20 , ( 0 )) ) = ( id ( field R20 ) ) by L1125;
L1156: S23[ ( 0 ) ] by L1155 , RELAT_1:45;
L1157: (for R19 being (Element of ( NAT )) holds S23[ R19 ]) from NAT_1:sch 1(L1156 , L1148);
thus L1158: thesis by L1157;
end;
theorem
L1159: (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds (R18 <> ( 0 ) implies (( dom ( iter (R20 , R18) ) ) c= ( dom R20 ) & ( rng ( iter (R20 , R18) ) ) c= ( rng R20 )))))
proof
let R18 being (Element of ( NAT ));
let R20 being Relation;
defpred S24[ Nat ] means (( dom ( iter (R20 , ( $1 + 1 )) ) ) c= ( dom R20 ) & ( rng ( iter (R20 , ( $1 + 1 )) ) ) c= ( rng R20 ));
assume L1160: R18 <> ( 0 );
L1161: (ex B303 being Nat st R18 = ( B303 + 1 )) by L1160 , NAT_1:6;
L1162: (for B304 being Nat holds (S24[ B304 ] implies S24[ ( B304 + 1 ) ]))
proof
let C315 being Nat;
assume that
L1163: ( dom ( iter (R20 , ( C315 + 1 )) ) ) c= ( dom R20 )
and
L1164: ( rng ( iter (R20 , ( C315 + 1 )) ) ) c= ( rng R20 );
L1165: (( iter (R20 , ( ( C315 + 1 ) + 1 )) ) = ( R20 * ( iter (R20 , ( C315 + 1 )) ) ) & ( iter (R20 , ( ( C315 + 1 ) + 1 )) ) = ( ( iter (R20 , ( C315 + 1 )) ) * R20 )) by L1132 , L1139;
thus L1166: thesis by L1165 , RELAT_1:25 , RELAT_1:26;
end;
L1167: S24[ ( 0 ) ] by L1137;
L1168: (for B305 being Nat holds S24[ B305 ]) from NAT_1:sch 2(L1167 , L1162);
thus L1169: thesis by L1168 , L1161;
end;
theorem
L1170: (for R20 being Relation holds (for B306 being Nat holds (( rng R20 ) c= ( dom R20 ) implies (( dom ( iter (R20 , B306) ) ) = ( dom R20 ) & ( rng ( iter (R20 , B306) ) ) c= ( dom R20 )))))
proof
let R20 being Relation;
let C316 being Nat;
defpred S25[ Nat ] means (( dom ( iter (R20 , $1) ) ) = ( dom R20 ) & ( rng ( iter (R20 , $1) ) ) c= ( dom R20 ));
L1171: (for B307 being Nat holds (S25[ B307 ] implies S25[ ( B307 + 1 ) ]))
proof
let C317 being Nat;
assume L1172: (( dom ( iter (R20 , C317) ) ) = ( dom R20 ) & ( rng ( iter (R20 , C317) ) ) c= ( dom R20 ));
L1173: ( iter (R20 , ( C317 + 1 )) ) = ( R20 * ( iter (R20 , C317) ) ) by L1132;
L1174: ( rng ( iter (R20 , ( C317 + 1 )) ) ) c= ( rng ( iter (R20 , C317) ) ) by L1173 , RELAT_1:26;
L1175: ( iter (R20 , ( C317 + 1 )) ) = ( ( iter (R20 , C317) ) * R20 ) by L1139;
thus L1176: thesis by L1175 , L1172 , L1174 , RELAT_1:27 , XBOOLE_1:1;
end;
assume L1177: ( rng R20 ) c= ( dom R20 );
L1178: ( iter (R20 , ( 0 )) ) = ( id ( dom R20 ) ) by L1177 , L1128;
L1179: S25[ ( 0 ) ] by L1178 , RELAT_1:45;
L1180: (for B308 being Nat holds S25[ B308 ]) from NAT_1:sch 2(L1179 , L1171);
thus L1181: thesis by L1180;
end;
theorem
L1182: (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds ( ( id ( field R20 ) ) * ( iter (R20 , R18) ) ) = ( iter (R20 , R18) )))
proof
let R18 being (Element of ( NAT ));
let R20 being Relation;
L1183: ( dom ( iter (R20 , R18) ) ) c= ( field R20 ) by L1147;
thus L1184: thesis by L1183 , RELAT_1:51;
end;
theorem
L1185: (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds ( ( iter (R20 , R18) ) * ( id ( field R20 ) ) ) = ( iter (R20 , R18) )))
proof
let R18 being (Element of ( NAT ));
let R20 being Relation;
L1186: ( rng ( iter (R20 , R18) ) ) c= ( field R20 ) by L1147;
thus L1187: thesis by L1186 , RELAT_1:53;
end;
theorem
L1188: (for R17 being (Element of ( NAT )) holds (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds ( ( iter (R20 , R17) ) * ( iter (R20 , R18) ) ) = ( iter (R20 , ( R18 + R17 )) ))))
proof
let R17 being (Element of ( NAT ));
let R18 being (Element of ( NAT ));
let R20 being Relation;
defpred S26[ (Element of ( NAT )) ] means ( ( iter (R20 , $1) ) * ( iter (R20 , R18) ) ) = ( iter (R20 , ( R18 + $1 )) );
L1189: (for R19 being (Element of ( NAT )) holds (S26[ R19 ] implies S26[ ( R19 + 1 ) ]))
proof
let R19 being (Element of ( NAT ));
assume L1190: ( ( iter (R20 , R19) ) * ( iter (R20 , R18) ) ) = ( iter (R20 , ( R18 + R19 )) );
thus L1191: ( ( iter (R20 , ( R19 + 1 )) ) * ( iter (R20 , R18) ) ) = ( ( R20 * ( iter (R20 , R19) ) ) * ( iter (R20 , R18) ) ) by L1132
.= ( R20 * ( ( iter (R20 , R19) ) * ( iter (R20 , R18) ) ) ) by RELAT_1:36
.= ( iter (R20 , ( ( R18 + R19 ) + 1 )) ) by L1190 , L1132
.= ( iter (R20 , ( R18 + ( R19 + 1 ) )) );
end;
L1192: ( ( iter (R20 , ( 0 )) ) * ( iter (R20 , R18) ) ) = ( ( id ( field R20 ) ) * ( iter (R20 , R18) ) ) by L1125
.= ( iter (R20 , ( R18 + ( 0 ) )) ) by L1182;
L1193: S26[ ( 0 ) ] by L1192;
L1194: (for R19 being (Element of ( NAT )) holds S26[ R19 ]) from NAT_1:sch 1(L1193 , L1189);
thus L1195: thesis by L1194;
end;
L1196: (for R17 being (Element of ( NAT )) holds (for R19 being (Element of ( NAT )) holds (for R20 being Relation holds (( iter (( iter (R20 , R17) ) , R19) ) = ( iter (R20 , ( R17 * R19 )) ) implies ( iter (( iter (R20 , R17) ) , ( R19 + 1 )) ) = ( iter (R20 , ( R17 * ( R19 + 1 ) )) )))))
proof
let R17 being (Element of ( NAT ));
let R19 being (Element of ( NAT ));
let R20 being Relation;
assume L1197: ( iter (( iter (R20 , R17) ) , R19) ) = ( iter (R20 , ( R17 * R19 )) );
thus L1198: ( iter (( iter (R20 , R17) ) , ( R19 + 1 )) ) = ( ( iter (R20 , R17) ) * ( iter (( iter (R20 , R17) ) , R19) ) ) by L1132
.= ( iter (R20 , ( ( R17 * R19 ) + ( R17 * 1 ) )) ) by L1197 , L1188
.= ( iter (R20 , ( R17 * ( R19 + 1 ) )) );
end;
theorem
L1199: (for R17 being (Element of ( NAT )) holds (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds (R18 <> ( 0 ) implies ( iter (( iter (R20 , R17) ) , R18) ) = ( iter (R20 , ( R17 * R18 )) )))))
proof
let R17 being (Element of ( NAT ));
let R18 being (Element of ( NAT ));
let R20 being Relation;
defpred S27[ (Element of ( NAT )) ] means ( iter (( iter (R20 , R17) ) , ( $1 + 1 )) ) = ( iter (R20 , ( R17 * ( $1 + 1 ) )) );
L1200: (for R19 being (Element of ( NAT )) holds (S27[ R19 ] implies S27[ ( R19 + 1 ) ])) by L1196;
L1201: S27[ ( 0 ) ] by L1137;
L1202: (for R19 being (Element of ( NAT )) holds S27[ R19 ]) from NAT_1:sch 1(L1201 , L1200);
assume L1203: R18 <> ( 0 );
consider C318 being Nat such that L1204: R18 = ( C318 + 1 ) by L1203 , NAT_1:6;
reconsider D83 = C318 as (Element of ( NAT )) by ORDINAL1:def 12;
L1205: R18 = ( D83 + 1 ) by L1204;
thus L1206: thesis by L1205 , L1202;
end;
theorem
L1207: (for R17 being (Element of ( NAT )) holds (for R18 being (Element of ( NAT )) holds (for R20 being Relation holds (( rng R20 ) c= ( dom R20 ) implies ( iter (( iter (R20 , R17) ) , R18) ) = ( iter (R20 , ( R17 * R18 )) )))))
proof
let R17 being (Element of ( NAT ));
let R18 being (Element of ( NAT ));
let R20 being Relation;
defpred S28[ (Element of ( NAT )) ] means ( iter (( iter (R20 , R17) ) , $1) ) = ( iter (R20 , ( R17 * $1 )) );
assume L1208: ( rng R20 ) c= ( dom R20 );
L1209: ( dom ( iter (R20 , R17) ) ) = ( dom R20 ) by L1208 , L1170;
L1210: ( field ( iter (R20 , R17) ) ) = ( dom R20 ) by L1209 , L1208 , L1170 , XBOOLE_1:12;
L1211: ( iter (( iter (R20 , R17) ) , ( 0 )) ) = ( id ( dom R20 ) ) by L1210 , L1125
.= ( id ( field R20 ) ) by L1208 , XBOOLE_1:12
.= ( iter (R20 , ( R17 * ( 0 ) )) ) by L1125;
L1212: S28[ ( 0 ) ] by L1211;
L1213: (for R19 being (Element of ( NAT )) holds (S28[ R19 ] implies S28[ ( R19 + 1 ) ])) by L1196;
L1214: (for R19 being (Element of ( NAT )) holds S28[ R19 ]) from NAT_1:sch 1(L1212 , L1213);
thus L1215: thesis by L1214;
end;
theorem
L1216: (for R18 being (Element of ( NAT )) holds ( iter (( {} ) , R18) ) = ( {} ))
proof
let R18 being (Element of ( NAT ));
defpred S29[ (Element of ( NAT )) ] means ( iter (( {} ) , $1) ) = ( {} );
L1217: (for R19 being (Element of ( NAT )) holds (S29[ R19 ] implies S29[ ( R19 + 1 ) ]))
proof
let R19 being (Element of ( NAT ));
assume L1218: ( iter (( {} ) , R19) ) = ( {} );
thus L1219: ( iter (( {} ) , ( R19 + 1 )) ) = ( ( iter (( {} ) , R19) ) * ( {} ) ) by L1132
.= ( {} );
end;
L1220: ( iter (( {} ) , ( 0 )) ) = ( id ( field ( {} ) ) ) by L1125
.= ( {} );
L1221: S29[ ( 0 ) ] by L1220;
L1222: (for R19 being (Element of ( NAT )) holds S29[ R19 ]) from NAT_1:sch 1(L1221 , L1217);
thus L1223: thesis by L1222;
end;
theorem
L1224: (for R9 being set holds (for R18 being (Element of ( NAT )) holds ( iter (( id R9 ) , R18) ) = ( id R9 )))
proof
let R9 being set;
let R18 being (Element of ( NAT ));
defpred S30[ (Element of ( NAT )) ] means ( iter (( id R9 ) , $1) ) = ( id R9 );
L1225: (for R19 being (Element of ( NAT )) holds (S30[ R19 ] implies S30[ ( R19 + 1 ) ]))
proof
let R19 being (Element of ( NAT ));
assume L1226: S30[ R19 ];
thus L1227: ( iter (( id R9 ) , ( R19 + 1 )) ) = ( ( iter (( id R9 ) , R19) ) * ( id R9 ) ) by L1132
.= ( id R9 ) by L1226 , FUNCT_2:17;
end;
L1228: ( id ( field ( id R9 ) ) ) = ( id R9 );
L1229: S30[ ( 0 ) ] by L1228 , L1125;
L1230: (for R19 being (Element of ( NAT )) holds S30[ R19 ]) from NAT_1:sch 1(L1229 , L1225);
thus L1231: thesis by L1230;
end;
theorem
L1232: (for R20 being Relation holds (( rng R20 ) misses ( dom R20 ) implies ( iter (R20 , 2) ) = ( {} )))
proof
let R20 being Relation;
assume L1233: ( rng R20 ) misses ( dom R20 );
thus L1234: ( iter (R20 , 2) ) = ( iter (R20 , ( 1 + 1 )) )
.= ( ( iter (R20 , 1) ) * R20 ) by L1139
.= ( R20 * R20 ) by L1137
.= ( {} ) by L1233 , RELAT_1:44;
end;
theorem
L1235: (for R9 being set holds (for B309 being Nat holds (for B310 being (Function of R9 , R9) holds ( iter (B310 , B309) ) is (Function of R9 , R9))))
proof
let R9 being set;
let C319 being Nat;
let C320 being (Function of R9 , R9);
L1236: (R9 = ( {} ) implies R9 = ( {} ));
L1237: ( dom C320 ) = R9 by L1236 , FUNCT_2:def 1;
L1238: ( rng C320 ) c= R9;
L1239: (( dom ( iter (C320 , C319) ) ) = R9 & ( rng ( iter (C320 , C319) ) ) c= R9) by L1238 , L1237 , L1170;
reconsider D84 = ( iter (C320 , C319) ) as (Relation of R9 , R9) by L1239 , RELSET_1:4;
L1240: ( dom D84 ) = R9 by L1237 , L1238 , L1170;
thus L1241: thesis by L1240 , L1236 , FUNCT_2:def 1;
end;
theorem
L1242: (for R9 being set holds (for B311 being (Function of R9 , R9) holds ( iter (B311 , ( 0 )) ) = ( id R9 )))
proof
let R9 being set;
let C321 being (Function of R9 , R9);
L1243: (( iter (C321 , ( 0 )) ) = ( id ( field C321 ) ) & ( field C321 ) = ( dom C321 )) by L1085 , L1125 , XBOOLE_1:12;
thus L1244: thesis by L1243 , FUNCT_2:52;
end;
theorem
L1245: (for R9 being set holds (for R17 being (Element of ( NAT )) holds (for R18 being (Element of ( NAT )) holds (for B312 being (Function of R9 , R9) holds ( iter (( iter (B312 , R17) ) , R18) ) = ( iter (B312 , ( R17 * R18 )) )))))
proof
let R9 being set;
let R17 being (Element of ( NAT ));
let R18 being (Element of ( NAT ));
let C322 being (Function of R9 , R9);
L1246: ( rng C322 ) c= ( dom C322 ) by L1085;
thus L1247: thesis by L1246 , L1207;
end;
theorem
L1248: (for R9 being set holds (for R18 being (Element of ( NAT )) holds (for B313 being (PartFunc of R9 , R9) holds ( iter (B313 , R18) ) is (PartFunc of R9 , R9))))
proof
let R9 being set;
let R18 being (Element of ( NAT ));
let C323 being (PartFunc of R9 , R9);
L1249: ( field C323 ) = ( ( dom C323 ) \/ ( rng C323 ) );
L1250: ( rng ( iter (C323 , R18) ) ) c= ( field C323 ) by L1147;
L1251: ( rng ( iter (C323 , R18) ) ) c= R9 by L1250 , L1249 , XBOOLE_1:1;
L1252: ( dom ( iter (C323 , R18) ) ) c= ( field C323 ) by L1147;
L1253: ( dom ( iter (C323 , R18) ) ) c= R9 by L1252 , L1249 , XBOOLE_1:1;
thus L1254: thesis by L1253 , L1251 , RELSET_1:4;
end;
theorem
L1255: (for R1 being set holds (for R9 being set holds (for R14 being Function holds (for R18 being (Element of ( NAT )) holds ((R18 <> ( 0 ) & R1 in R9 & R14 = ( R9 --> R1 )) implies ( iter (R14 , R18) ) = R14)))))
proof
let R1 being set;
let R9 being set;
let R14 being Function;
let R18 being (Element of ( NAT ));
assume that
L1256: R18 <> ( 0 )
and
L1257: R1 in R9
and
L1258: R14 = ( R9 --> R1 );
defpred S31[ (Element of ( NAT )) ] means ( iter (R14 , ( $1 + 1 )) ) = R14;
L1259:
now
L1260: ( dom R14 ) = R9 by L1258 , FUNCOP_1:13;
let R19 being (Element of ( NAT ));
assume that
L1261: S31[ R19 ];
L1262:
now
let R11 being set;
assume L1263: R11 in ( dom R14 );
L1264: ( R14 . R11 ) = R1 by L1263 , L1258 , L1260 , FUNCOP_1:7;
thus L1265: ( ( iter (R14 , ( ( R19 + 1 ) + 1 )) ) . R11 ) = ( ( R14 * R14 ) . R11 ) by L1261 , L1139
.= ( R14 . ( R14 . R11 ) ) by L1263 , FUNCT_1:13
.= ( R14 . R11 ) by L1257 , L1258 , L1264 , FUNCOP_1:7;
end;
L1266: ( rng R14 ) = { R1 } by L1257 , L1258 , FUNCOP_1:8;
L1267: ( rng R14 ) c= ( dom R14 ) by L1266 , L1257 , L1260 , ZFMISC_1:31;
L1268: ( dom ( iter (R14 , ( ( R19 + 1 ) + 1 )) ) ) = ( dom R14 ) by L1267 , L1170;
thus L1269: S31[ ( R19 + 1 ) ] by L1268 , L1262 , FUNCT_1:2;
end;
L1270: S31[ ( 0 ) ] by L1137;
L1271: (for R19 being (Element of ( NAT )) holds S31[ R19 ]) from NAT_1:sch 1(L1270 , L1259);
consider C324 being Nat such that L1272: R18 = ( C324 + 1 ) by L1256 , NAT_1:6;
reconsider D85 = C324 as (Element of ( NAT )) by ORDINAL1:def 12;
L1273: R18 = ( D85 + 1 ) by L1272;
thus L1274: thesis by L1273 , L1271;
end;
theorem
L1275: (for B314 being Function holds (for B315 being (Element of ( NAT )) holds ( iter (B314 , B315) ) = ( compose (( B315 |-> B314 ) , ( field B314 )) )))
proof
let C325 being Function;
defpred S32[ (Element of ( NAT )) ] means ( iter (C325 , $1) ) = ( compose (( $1 |-> C325 ) , ( field C325 )) );
L1276:
now
let C326 being (Element of ( NAT ));
assume L1277: S32[ C326 ];
L1278: ( iter (C325 , ( C326 + 1 )) ) = ( C325 * ( compose (( C326 |-> C325 ) , ( field C325 )) ) ) by L1277 , L1139
.= ( compose (( ( C326 |-> C325 ) ^ <* C325 *> ) , ( field C325 )) ) by L613
.= ( compose (( ( C326 + 1 ) |-> C325 ) , ( field C325 )) ) by FINSEQ_2:60;
thus L1279: S32[ ( C326 + 1 ) ] by L1278;
end;
L1280: ( iter (C325 , ( 0 )) ) = ( id ( field C325 ) ) by L1125
.= ( compose (( {} ) , ( field C325 )) ) by L607
.= ( compose (( ( 0 ) |-> C325 ) , ( field C325 )) );
L1281: S32[ ( 0 ) ] by L1280;
thus L1282: (for B316 being (Element of ( NAT )) holds S32[ B316 ]) from NAT_1:sch 1(L1281 , L1276);
end;
begin
theorem
L1283: (for B317 , B318 being Function holds (for B319 , B320 being set holds ((B318 c= B317 & (not B319 in ( dom B318 ))) implies B318 c= ( B317 +* (B319 , B320) ))))
proof
let C327 , C328 being Function;
let C329 , C330 being set;
assume that
L1284: C328 c= C327
and
L1285: (not C329 in ( dom C328 ));
L1286:
now
let C331 being set;
assume L1287: C331 in ( dom C328 );
thus L1288: ( C328 . C331 ) = ( C327 . C331 ) by L1287 , L1284 , GRFUNC_1:2
.= ( ( C327 +* (C329 , C330) ) . C331 ) by L1285 , L1287 , L458;
end;
L1289: ( dom C328 ) c= ( dom C327 ) by L1284 , GRFUNC_1:2;
L1290: ( dom C328 ) c= ( dom ( C327 +* (C329 , C330) ) ) by L1289 , L446;
thus L1291: thesis by L1290 , L1286 , GRFUNC_1:2;
end;
theorem
L1292: (for B321 , B322 being Function holds (for B323 being set holds ((( B321 | B323 ) = ( B322 | B323 ) & B321 , B322 equal_outside B323) implies B321 = B322)))
proof
let C332 , C333 being Function;
let C334 being set;
assume that
L1293: (( C332 | C334 ) = ( C333 | C334 ) & C332 , C333 equal_outside C334);
thus L1294: C332 = ( C332 | ( ( dom C332 ) \/ C334 ) ) by RELAT_1:68 , XBOOLE_1:7
.= ( C332 | ( ( ( dom C332 ) \ C334 ) \/ C334 ) ) by XBOOLE_1:39
.= ( ( C332 | ( ( dom C332 ) \ C334 ) ) \/ ( C332 | C334 ) ) by RELAT_1:78
.= ( ( C333 | ( ( dom C333 ) \ C334 ) ) \/ ( C333 | C334 ) ) by L1293 , L425
.= ( C333 | ( ( ( dom C333 ) \ C334 ) \/ C334 ) ) by RELAT_1:78
.= ( C333 | ( ( dom C333 ) \/ C334 ) ) by XBOOLE_1:39
.= C333 by RELAT_1:68 , XBOOLE_1:7;
end;
theorem
L1295: (for B324 being Function holds (for B325 , B326 , B327 being set holds (B325 in B327 implies B324 , ( B324 +* (B325 , B326) ) equal_outside B327)))
proof
let C335 being Function;
let C336 , C337 , C338 being set;
per cases ;
suppose L1296: C336 in ( dom C335 );

assume L1297: C336 in C338;
L1298: { C336 } c= C338 by L1297 , ZFMISC_1:31;
L1299: ( dom ( C336 .--> C337 ) ) c= C338 by L1298 , FUNCOP_1:13;
L1300: ( C335 +* (C336 , C337) ) = ( C335 +* ( C336 .--> C337 ) ) by L1296 , L444;
thus L1301: thesis by L1300 , L1299 , L438;
end;
suppose L1302: (not C336 in ( dom C335 ));

L1303: ( C335 +* (C336 , C337) ) = C335 by L1302 , L444;
thus L1304: thesis by L1303 , L427;
end;
end;
theorem
L1306: (for B328 being Function holds (for B329 , B330 , B331 being set holds (B329 in B331 or ( ( B328 +* (B329 , B330) ) | B331 ) = ( B328 | B331 ))))
proof
let C339 being Function;
let C340 , C341 , C342 being set;
per cases ;
suppose L1307: C340 in ( dom C339 );

assume L1308: (not C340 in C342);
L1309: { C340 } misses C342 by L1308 , ZFMISC_1:50;
L1310: ( dom ( C340 .--> C341 ) ) misses C342 by L1309 , FUNCOP_1:13;
thus L1311: ( ( C339 +* (C340 , C341) ) | C342 ) = ( ( C339 +* ( C340 .--> C341 ) ) | C342 ) by L1307 , L444
.= ( C339 | C342 ) by L1310 , FUNCT_4:72;
end;
suppose L1312: (not C340 in ( dom C339 ));

thus L1313: thesis by L1312 , L444;
end;
end;
theorem
L1315: (for B332 , B333 being Function holds (for B334 , B335 , B336 being set holds (( B332 | B336 ) = ( B333 | B336 ) implies ( ( B332 +* (B334 , B335) ) | B336 ) = ( ( B333 +* (B334 , B335) ) | B336 ))))
proof
let C343 , C344 being Function;
let C345 , C346 , C347 being set;
assume that
L1316: ( C343 | C347 ) = ( C344 | C347 );
per cases ;
suppose that L1317: C345 in C347
and
L1318: C345 in ( dom C344 );
L1319:
now
assume L1320: (not C345 in ( dom C343 ));
L1321: (not C345 in ( ( dom C343 ) /\ C347 )) by L1320 , XBOOLE_0:def 4;
L1322: (not C345 in ( dom ( C344 | C347 ) )) by L1321 , L1316 , RELAT_1:61;
L1323: (not C345 in ( ( dom C344 ) /\ C347 )) by L1322 , RELAT_1:61;
thus L1324: contradiction by L1323 , L1317 , L1318 , XBOOLE_0:def 4;
end;
thus L1325: ( ( C343 +* (C345 , C346) ) | C347 ) = ( ( C343 +* ( C345 .--> C346 ) ) | C347 ) by L1319 , L444
.= ( ( C344 | C347 ) +* ( ( C345 .--> C346 ) | C347 ) ) by L1316 , FUNCT_4:71
.= ( ( C344 +* ( C345 .--> C346 ) ) | C347 ) by FUNCT_4:71
.= ( ( C344 +* (C345 , C346) ) | C347 ) by L1318 , L444;
end;
suppose that L1326: C345 in C347
and
L1327: (not C345 in ( dom C344 ));
L1328:
now
assume L1329: C345 in ( dom C343 );
L1330: C345 in ( ( dom C343 ) /\ C347 ) by L1329 , L1326 , XBOOLE_0:def 4;
L1331: C345 in ( dom ( C344 | C347 ) ) by L1330 , L1316 , RELAT_1:61;
L1332: C345 in ( ( dom C344 ) /\ C347 ) by L1331 , RELAT_1:61;
thus L1333: contradiction by L1332 , L1327 , XBOOLE_0:def 4;
end;
thus L1334: ( ( C343 +* (C345 , C346) ) | C347 ) = ( C344 | C347 ) by L1328 , L1316 , L444
.= ( ( C344 +* (C345 , C346) ) | C347 ) by L1327 , L444;
end;
suppose L1335: (not C345 in C347);

thus L1336: ( ( C343 +* (C345 , C346) ) | C347 ) = ( C343 | C347 ) by L1335 , L1306
.= ( ( C344 +* (C345 , C346) ) | C347 ) by L1316 , L1335 , L1306;
end;
end;
theorem
L1338: (for B337 being Function holds (for B338 , B339 being set holds ( ( B337 +* ( B338 .--> B339 ) ) . B338 ) = B339))
proof
let C348 being Function;
let C349 , C350 being set;
L1339: ( dom ( C349 .--> C350 ) ) = { C349 } by FUNCOP_1:13;
L1340: C349 in ( dom ( C349 .--> C350 ) ) by L1339 , TARSKI:def 1;
thus L1341: ( ( C348 +* ( C349 .--> C350 ) ) . C349 ) = ( ( C349 .--> C350 ) . C349 ) by L1340 , FUNCT_4:13
.= C350 by FUNCOP_1:72;
end;
theorem
L1342: (for B340 , B341 being set holds ( <* B340 *> +* (1 , B341) ) = <* B341 *>)
proof
let C351 , C352 being set;
L1343: ( dom <* C352 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:def 8;
L1344: ( dom <* C351 *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:def 8;
L1345: 1 in ( dom <* C351 *> ) by L1344 , TARSKI:def 1;
L1346: ( <* C351 *> +* (1 , C352) ) = ( <* C351 *> +* ( 1 .--> C352 ) ) by L1345 , L444;
L1347: (for B342 being set holds (B342 in { 1 } implies ( ( <* C351 *> +* (1 , C352) ) . B342 ) = ( <* C352 *> . B342 )))
proof
let C353 being set;
assume L1348: C353 in { 1 };
L1349: C353 = 1 by L1348 , TARSKI:def 1;
thus L1350: ( ( <* C351 *> +* (1 , C352) ) . C353 ) = C352 by L1349 , L1346 , L1338
.= ( <* C352 *> . C353 ) by L1349 , FINSEQ_1:def 8;
end;
L1351: ( dom ( <* C351 *> +* (1 , C352) ) ) = ( ( dom <* C351 *> ) \/ ( dom ( 1 .--> C352 ) ) ) by L1346 , FUNCT_4:def 1
.= ( { 1 } \/ { 1 } ) by L1344 , FUNCOP_1:13
.= { 1 };
thus L1352: thesis by L1351 , L1343 , L1347 , FUNCT_1:2;
end;
theorem
L1353: (for B343 being Function holds (for B344 being set holds (B344 in ( dom B343 ) implies ( B343 +* ( B344 .--> ( B343 . B344 ) ) ) = B343)))
proof
let C354 being Function;
let C355 being set;
assume L1354: C355 in ( dom C354 );
thus L1355: ( C354 +* ( C355 .--> ( C354 . C355 ) ) ) = ( C354 +* (C355 , ( C354 . C355 )) ) by L1354 , L444
.= C354 by L496;
end;
theorem
L1356: (for B345 being FinSequence holds (for B346 being set holds (for R21 being Nat holds ( len ( B345 +* (R21 , B346) ) ) = ( len B345 ))))
proof
let C356 being FinSequence;
let C357 being set;
let R21 being Nat;
L1357: ( dom ( C356 +* (R21 , C357) ) ) = ( dom C356 ) by L446;
L1358: ( Seg ( len ( C356 +* (R21 , C357) ) ) ) = ( dom C356 ) by L1357 , FINSEQ_1:def 3
.= ( Seg ( len C356 ) ) by FINSEQ_1:def 3;
thus L1359: thesis by L1358 , FINSEQ_1:6;
end;
theorem
L1360: (for R21 being Nat holds (for B347 being non  empty set holds (for B348 being (FinSequence of B347) holds (for B349 being (Element of B347) holds (R21 in ( dom B348 ) implies ( B348 +* (R21 , B349) ) = ( ( ( B348 | ( R21 -' 1 ) ) ^ <* B349 *> ) ^ ( B348 /^ R21 ) ))))))
proof
let R21 being Nat;
let C358 being non  empty set;
let C359 being (FinSequence of C358);
let C360 being (Element of C358);
assume L1361: R21 in ( dom C359 );
L1362: 1 <= R21 by L1361 , FINSEQ_3:25;
L1363: R21 <= ( len C359 ) by L1361 , FINSEQ_3:25;
L1364: ( len ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ^ ( C359 /^ R21 ) ) ) = ( ( len ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ) + ( len ( C359 /^ R21 ) ) ) by FINSEQ_1:22
.= ( ( ( len ( C359 | ( R21 -' 1 ) ) ) + ( len <* C360 *> ) ) + ( len ( C359 /^ R21 ) ) ) by FINSEQ_1:22
.= ( ( ( len ( C359 | ( R21 -' 1 ) ) ) + 1 ) + ( len ( C359 /^ R21 ) ) ) by FINSEQ_1:39
.= ( ( ( R21 -' 1 ) + 1 ) + ( len ( C359 /^ R21 ) ) ) by L1363 , FINSEQ_1:59 , NAT_D:44
.= ( ( ( R21 -' 1 ) + 1 ) + ( ( len C359 ) - R21 ) ) by L1363 , RFINSEQ:def 1
.= ( ( ( R21 - 1 ) + 1 ) + ( ( len C359 ) - R21 ) ) by L1362 , XREAL_1:233;
L1365: (for B350 being Nat holds ((1 <= B350 & B350 <= ( len ( C359 +* (R21 , C360) ) )) implies ( ( C359 +* (R21 , C360) ) . B350 ) = ( ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ^ ( C359 /^ R21 ) ) . B350 )))
proof
L1366: ( len ( C359 | ( R21 -' 1 ) ) ) = ( R21 -' 1 ) by L1363 , FINSEQ_1:59 , NAT_D:44
.= ( R21 - 1 ) by L1362 , XREAL_1:233;
let C361 being Nat;
assume that
L1367: 1 <= C361
and
L1368: C361 <= ( len ( C359 +* (R21 , C360) ) );
L1369: ( len ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ) = ( ( len ( C359 | ( R21 -' 1 ) ) ) + ( len <* C360 *> ) ) by FINSEQ_1:22
.= ( ( len ( C359 | ( R21 -' 1 ) ) ) + 1 ) by FINSEQ_1:39
.= ( ( R21 -' 1 ) + 1 ) by L1363 , FINSEQ_1:59 , NAT_D:44
.= ( ( R21 - 1 ) + 1 ) by L1362 , XREAL_1:233
.= R21;
L1370: ( len ( C359 +* (R21 , C360) ) ) = ( len C359 ) by L1356;
L1371:
now
per cases  by XXREAL_0:1;
case L1372: R21 < C361;
L1373: ( R21 + 1 ) <= C361 by L1372 , NAT_1:13;
L1374: ( ( R21 + 1 ) - R21 ) <= ( C361 - R21 ) by L1373 , XREAL_1:9;
L1375: 1 <= ( C361 -' R21 ) by L1374 , NAT_D:39;
L1376: ( C361 - R21 ) <= ( ( len C359 ) - R21 ) by L1368 , L1370 , XREAL_1:9;
L1377: R21 <= ( len C359 ) by L1361 , FINSEQ_3:25;
L1378: ( len ( C359 /^ R21 ) ) = ( ( len C359 ) -' R21 ) by RFINSEQ:29
.= ( ( len C359 ) - R21 ) by L1377 , XREAL_1:233;
L1379: ( C361 -' R21 ) <= ( len ( C359 /^ R21 ) ) by L1378 , L1374 , L1376 , NAT_D:39;
L1380: ( C361 -' R21 ) in ( dom ( C359 /^ R21 ) ) by L1379 , L1375 , FINSEQ_3:25;
L1381: C361 <= ( len ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ^ ( C359 /^ R21 ) ) ) by L1364 , L1368 , L1356;
L1382: ( ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ^ ( C359 /^ R21 ) ) . C361 ) = ( ( C359 /^ R21 ) . ( C361 - ( len ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ) ) ) by L1381 , L1369 , L1372 , FINSEQ_1:24
.= ( ( C359 /^ R21 ) . ( C361 -' R21 ) ) by L1369 , L1372 , XREAL_1:233
.= ( C359 . ( ( C361 -' R21 ) + R21 ) ) by L1377 , L1380 , RFINSEQ:def 1
.= ( C359 . C361 ) by L1372 , XREAL_1:235;
thus L1383: thesis by L1382 , L1372 , L458;
end;
case L1384: C361 = R21;
L1385: R21 = ( ( len ( C359 | ( R21 -' 1 ) ) ) + 1 ) by L1366;
L1386: ( ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ^ ( C359 /^ R21 ) ) . C361 ) = ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) . R21 ) by L1367 , L1369 , L1384 , FINSEQ_1:64
.= C360 by L1385 , FINSEQ_1:42;
thus L1387: thesis by L1386 , L1361 , L1384 , L453;
end;
case L1388: C361 < R21;
L1389: ( C361 + 1 ) <= R21 by L1388 , NAT_1:13;
L1390: ( ( C361 + 1 ) - 1 ) <= ( R21 - 1 ) by L1389 , XREAL_1:9;
L1391: C361 <= ( R21 -' 1 ) by L1390 , L1362 , XREAL_1:233;
L1392: ( ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) ^ ( C359 /^ R21 ) ) . C361 ) = ( ( ( C359 | ( R21 -' 1 ) ) ^ <* C360 *> ) . C361 ) by L1367 , L1369 , L1388 , FINSEQ_1:64
.= ( ( C359 | ( R21 -' 1 ) ) . C361 ) by L1367 , L1366 , L1390 , FINSEQ_1:64
.= ( C359 . C361 ) by L1391 , FINSEQ_3:112;
thus L1393: thesis by L1392 , L1388 , L458;
end;
end;
thus L1395: thesis by L1371;
end;
thus L1396: thesis by L1365 , L1364 , L1356 , FINSEQ_1:14;
end;
definition
let R23 being Function;
let R25 being set;
let R26 being set;
func Swap (R23 , R25 , R26) equals 
:L1397: ( ( R23 +* (R25 , ( R23 . R26 )) ) +* (R26 , ( R23 . R25 )) ) if (R25 in ( dom R23 ) & R26 in ( dom R23 )) otherwise R23;
correctness;
end;
registration
let R23 being Function;
let R25 being set;
let R26 being set;
cluster ( Swap (R23 , R25 , R26) ) ->  Relation-like  Function-like;
coherence
proof
per cases ;
suppose L1399: (R25 in ( dom R23 ) & R26 in ( dom R23 ));

L1400: ( Swap (R23 , R25 , R26) ) = ( ( R23 +* (R25 , ( R23 . R26 )) ) +* (R26 , ( R23 . R25 )) ) by L1399 , L1397;
thus L1401: thesis by L1400;
end;
suppose L1402: (not (R25 in ( dom R23 ) & R26 in ( dom R23 )));

thus L1403: thesis by L1402 , L1397;
end;
end;
end;
theorem
L1406: (for R23 being Function holds (for R25 being set holds (for R26 being set holds ( dom ( Swap (R23 , R25 , R26) ) ) = ( dom R23 ))))
proof
let R23 being Function;
let R25 being set;
let R26 being set;
per cases ;
suppose L1407: (R25 in ( dom R23 ) & R26 in ( dom R23 ));

thus L1408: ( dom ( Swap (R23 , R25 , R26) ) ) = ( dom ( ( R23 +* (R25 , ( R23 . R26 )) ) +* (R26 , ( R23 . R25 )) ) ) by L1407 , L1397
.= ( dom ( R23 +* (R25 , ( R23 . R26 )) ) ) by L446
.= ( dom R23 ) by L446;
end;
suppose L1409: (not (R25 in ( dom R23 ) & R26 in ( dom R23 )));

thus L1410: thesis by L1409 , L1397;
end;
end;
theorem
L1412: (for R23 being Function holds (for R25 being set holds (for R26 being set holds ( rng ( R23 +* (R25 , R26) ) ) c= ( ( rng R23 ) \/ { R26 } ))))
proof
let R23 being Function;
let R25 being set;
let R26 being set;
L1413: ( rng ( R25 .--> R26 ) ) = { R26 } by FUNCOP_1:8;
per cases ;
suppose L1414: R25 in ( dom R23 );

L1415: ( R23 +* (R25 , R26) ) = ( R23 +* ( R25 .--> R26 ) ) by L1414 , L444;
thus L1416: thesis by L1415 , L1413 , FUNCT_4:17;
end;
suppose L1417: (not R25 in ( dom R23 ));

L1418: ( R23 +* (R25 , R26) ) = R23 by L1417 , L444;
thus L1419: thesis by L1418 , XBOOLE_1:7;
end;
end;
theorem
L1421: (for R23 being Function holds (for R25 being set holds (for R26 being set holds ( rng R23 ) c= ( ( rng ( R23 +* (R25 , R26) ) ) \/ { ( R23 . R25 ) } ))))
proof
let R23 being Function;
let R25 being set;
let R26 being set;
let R27 being set;
assume L1422: R27 in ( rng R23 );
consider R24 being set such that L1423: R24 in ( dom R23 ) and L1424: R27 = ( R23 . R24 ) by L1422 , FUNCT_1:def 3;
L1425: ( dom R23 ) = ( dom ( R23 +* (R25 , R26) ) ) by L446;
per cases ;
suppose L1426: R24 = R25;

L1427: R27 in { ( R23 . R25 ) } by L1426 , L1424 , TARSKI:def 1;
thus L1428: thesis by L1427 , XBOOLE_0:def 3;
end;
suppose L1429: R24 <> R25;

L1430: ( ( R23 +* (R25 , R26) ) . R24 ) = ( R23 . R24 ) by L1429 , L458;
L1431: R27 in ( rng ( R23 +* (R25 , R26) ) ) by L1430 , L1423 , L1424 , L1425 , FUNCT_1:3;
thus L1432: thesis by L1431 , XBOOLE_0:def 3;
end;
end;
theorem
L1434: (for R23 being Function holds (for R25 being set holds (for R26 being set holds (R25 in ( dom R23 ) implies R26 in ( rng ( R23 +* (R25 , R26) ) )))))
proof
let R23 being Function;
let R25 being set;
let R26 being set;
assume L1435: R25 in ( dom R23 );
L1436: (R25 in ( dom ( R23 +* (R25 , R26) ) ) & ( ( R23 +* (R25 , R26) ) . R25 ) = R26) by L1435 , L446 , L453;
thus L1437: thesis by L1436 , FUNCT_1:3;
end;
theorem
L1438: (for R23 being Function holds (for R25 being set holds (for R26 being set holds ( rng ( Swap (R23 , R25 , R26) ) ) = ( rng R23 ))))
proof
let R23 being Function;
let R25 being set;
let R26 being set;
per cases ;
suppose that L1439: R25 in ( dom R23 )
and
L1440: R26 in ( dom R23 );
L1441: ( R23 . R25 ) in ( rng R23 ) by L1439 , FUNCT_1:3;
L1442: ( R23 . R25 ) in ( ( rng R23 ) \/ { ( R23 . R26 ) } ) by L1441 , XBOOLE_0:def 3;
L1443: ( ( ( rng R23 ) \/ { ( R23 . R26 ) } ) \/ { ( R23 . R25 ) } ) = ( ( rng R23 ) \/ { ( R23 . R26 ) } ) by L1442 , ZFMISC_1:40
.= ( rng R23 ) by L1440 , FUNCT_1:3 , ZFMISC_1:40;
L1444: ( ( rng ( R23 +* (R25 , ( R23 . R26 )) ) ) \/ { ( R23 . R25 ) } ) c= ( rng R23 ) by L1443 , L1412 , XBOOLE_1:9;
L1445: ( ( R23 +* (R25 , ( R23 . R26 )) ) . R26 ) = ( R23 . R26 )
proof
per cases ;
suppose L1446: R25 <> R26;

thus L1447: thesis by L1446 , L458;
end;
suppose L1448: R25 = R26;

thus L1449: thesis by L1448 , L1439 , L453;
end;
end;
L1451: ( rng R23 ) c= ( ( rng ( R23 +* (R25 , ( R23 . R26 )) ) ) \/ { ( R23 . R25 ) } ) by L1421;
L1452: ( Swap (R23 , R25 , R26) ) = ( ( R23 +* (R25 , ( R23 . R26 )) ) +* (R26 , ( R23 . R25 )) ) by L1439 , L1440 , L1397;
L1453: ( rng ( Swap (R23 , R25 , R26) ) ) c= ( ( rng ( R23 +* (R25 , ( R23 . R26 )) ) ) \/ { ( R23 . R25 ) } ) by L1452 , L1412;
L1454: ( rng ( Swap (R23 , R25 , R26) ) ) c= ( rng R23 ) by L1453 , L1444 , XBOOLE_1:1;
L1455: R26 in ( dom ( R23 +* (R25 , ( R23 . R26 )) ) ) by L1440 , L446;
L1456: ( R23 . R26 ) in ( rng ( Swap (R23 , R25 , R26) ) )
proof
per cases ;
suppose L1457: ( R23 . R25 ) = ( R23 . R26 );

thus L1458: thesis by L1457 , L1452 , L1455 , L1434;
end;
suppose L1459: ( R23 . R25 ) <> ( R23 . R26 );

L1460: ( dom ( Swap (R23 , R25 , R26) ) ) = ( dom R23 ) by L1406;
L1461: ( ( Swap (R23 , R25 , R26) ) . R25 ) = ( ( R23 +* (R25 , ( R23 . R26 )) ) . R25 ) by L1452 , L1459 , L458
.= ( R23 . R26 ) by L1439 , L453;
thus L1462: thesis by L1461 , L1439 , L1460 , FUNCT_1:3;
end;
end;
L1464: ( R23 . R25 ) in ( rng ( Swap (R23 , R25 , R26) ) ) by L1452 , L1455 , L1434;
L1465: ( R23 . R25 ) in ( ( rng ( Swap (R23 , R25 , R26) ) ) \/ { ( R23 . R26 ) } ) by L1464 , XBOOLE_0:def 3;
L1466: ( ( ( rng ( Swap (R23 , R25 , R26) ) ) \/ { ( R23 . R26 ) } ) \/ { ( R23 . R25 ) } ) = ( ( rng ( Swap (R23 , R25 , R26) ) ) \/ { ( R23 . R26 ) } ) by L1465 , ZFMISC_1:40
.= ( rng ( Swap (R23 , R25 , R26) ) ) by L1456 , ZFMISC_1:40;
L1467: ( ( rng ( R23 +* (R25 , ( R23 . R26 )) ) ) \/ { ( R23 . R25 ) } ) c= ( rng ( Swap (R23 , R25 , R26) ) ) by L1466 , L1452 , L1445 , L1421 , XBOOLE_1:9;
L1468: ( rng R23 ) c= ( rng ( Swap (R23 , R25 , R26) ) ) by L1467 , L1451 , XBOOLE_1:1;
thus L1469: thesis by L1468 , L1454 , XBOOLE_0:def 10;
end;
suppose L1470: (not (R25 in ( dom R23 ) & R26 in ( dom R23 )));

thus L1471: thesis by L1470 , L1397;
end;
end;
scheme  { F15() -> set , F16() -> non  empty set , F17(set) -> set } : F15() , { F17(B351) where B351 is (Element of F16()) : B351 in F15() } are_equipotent 
provided
L1473: F15() c= F16()
and
L1474: (for B352 , B353 being (Element of F16()) holds ((B352 in F15() & B353 in F15() & F17(B352) = F17(B353)) implies B352 = B353))
proof
per cases ;
suppose L1475: F15() <> ( {} );

reconsider D86 = F15() as non  empty set by L1475;
set D87 = { F17(B354) where B354 is (Element of D86) : B354 in F15() };
set D88 = { F17(B355) where B355 is (Element of F16()) : B355 in F15() };
L1476:
now
let C362 being set;
thus L1477:now
assume L1478: C362 in D87;
L1479: (ex B356 being (Element of D86) st (F17(B356) = C362 & B356 in F15())) by L1478;
thus L1480: C362 in D88 by L1479 , L1473;
end;
thus L1481:now
assume L1482: C362 in D88;
L1483: (ex B357 being (Element of F16()) st (F17(B357) = C362 & B357 in F15())) by L1482;
thus L1484: C362 in D87 by L1483;
end;
end;
L1482:
now
let C363 , C364 being (Element of D86);
L1483: (C363 in F15() & C364 in F15());
reconsider D89 = C363 , D90 = C364 as (Element of F16()) by L1483 , L1473;
assume L1484: F17(C363) = F17(C364);
L1485: D89 = D90 by L1484 , L1474;
thus L1486: C363 = C364 by L1485;
end;
L1487: F15() c= D86;
L1488: F15() , D87 are_equipotent  from CardMono9(L1487 , L1482);
thus L1489: thesis by L1488 , L1476 , TARSKI:1;
end;
suppose L1490: F15() = ( {} );

L1491:
now
set D91 = the (Element of { F17(B358) where B358 is (Element of F16()) : B358 in F15() });
assume L1492: { F17(B359) where B359 is (Element of F16()) : B359 in F15() } <> ( {} );
L1493: D91 in { F17(B360) where B360 is (Element of F16()) : B360 in F15() } by L1492;
L1494: (ex B361 being (Element of F16()) st (D91 = F17(B361) & B361 in F15())) by L1493;
thus L1495: contradiction by L1494 , L1490;
end;
thus L1496: thesis by L1491 , L1490;
end;
end;
theorem
L1498: (for B362 , B363 , B364 being Function holds (for B365 being set holds (B362 , B363 equal_outside B365 implies ( B362 +* B364 ) , ( B363 +* B364 ) equal_outside B365)))
proof
let C365 , C366 , C367 being Function;
let C368 being set;
L1499: ( dom ( ( C365 +* C367 ) | ( ( dom ( C365 +* C367 ) ) \ C368 ) ) ) = ( ( dom ( C365 +* C367 ) ) \ C368 ) by RELAT_1:156
.= ( ( ( dom C365 ) \/ ( dom C367 ) ) \ C368 ) by FUNCT_4:def 1
.= ( ( ( dom C365 ) \ C368 ) \/ ( ( dom C367 ) \ C368 ) ) by XBOOLE_1:42;
assume L1500: C365 , C366 equal_outside C368;
L1501: ( C365 | ( ( dom C365 ) \ C368 ) ) = ( C366 | ( ( dom C366 ) \ C368 ) ) by L1500 , L425;
L1502: ( ( dom C365 ) \ C368 ) = ( dom ( C366 | ( ( dom C366 ) \ C368 ) ) ) by L1501 , RELAT_1:156
.= ( ( dom C366 ) \ C368 ) by RELAT_1:156;
L1503: ( dom ( ( C365 +* C367 ) | ( ( dom ( C365 +* C367 ) ) \ C368 ) ) ) = ( ( ( dom C366 ) \/ ( dom C367 ) ) \ C368 ) by L1502 , L1499 , XBOOLE_1:42
.= ( ( dom ( C366 +* C367 ) ) \ C368 ) by FUNCT_4:def 1
.= ( dom ( ( C366 +* C367 ) | ( ( dom ( C366 +* C367 ) ) \ C368 ) ) ) by RELAT_1:156;
L1504:
now
let C369 being set;
assume L1505: C369 in ( dom ( ( C365 +* C367 ) | ( ( dom ( C365 +* C367 ) ) \ C368 ) ) );
L1506: (C369 in ( ( dom C365 ) \ C368 ) or C369 in ( ( dom C367 ) \ C368 )) by L1505 , L1499 , XBOOLE_0:def 3;
per cases ;
suppose L1507: C369 in ( ( dom C367 ) \ C368 );

thus L1508: ( ( ( C365 +* C367 ) | ( ( dom ( C365 +* C367 ) ) \ C368 ) ) . C369 ) = ( ( C365 +* C367 ) . C369 ) by L1505 , FUNCT_1:47
.= ( C367 . C369 ) by L1507 , FUNCT_4:13
.= ( ( C366 +* C367 ) . C369 ) by L1507 , FUNCT_4:13
.= ( ( ( C366 +* C367 ) | ( ( dom ( C366 +* C367 ) ) \ C368 ) ) . C369 ) by L1503 , L1505 , FUNCT_1:47;
end;
suppose L1509: (not C369 in ( ( dom C367 ) \ C368 ));

L1510: (not C369 in C368) by L1506 , XBOOLE_0:def 5;
L1511: (not C369 in ( dom C367 )) by L1510 , L1509 , XBOOLE_0:def 5;
L1512: C369 in ( ( dom C365 ) \ C368 ) by L1499 , L1505 , L1509 , XBOOLE_0:def 3;
thus L1513: ( ( ( C365 +* C367 ) | ( ( dom ( C365 +* C367 ) ) \ C368 ) ) . C369 ) = ( ( C365 +* C367 ) . C369 ) by L1505 , FUNCT_1:47
.= ( C365 . C369 ) by L1511 , FUNCT_4:11
.= ( ( C366 | ( ( dom C366 ) \ C368 ) ) . C369 ) by L1501 , L1506 , L1509 , FUNCT_1:49
.= ( C366 . C369 ) by L1502 , L1512 , FUNCT_1:49
.= ( ( C366 +* C367 ) . C369 ) by L1511 , FUNCT_4:11
.= ( ( ( C366 +* C367 ) | ( ( dom ( C366 +* C367 ) ) \ C368 ) ) . C369 ) by L1503 , L1505 , FUNCT_1:47;
end;
end;
L1515: ( ( C365 +* C367 ) | ( ( dom ( C365 +* C367 ) ) \ C368 ) ) = ( ( C366 +* C367 ) | ( ( dom ( C366 +* C367 ) ) \ C368 ) ) by L1504 , L1503 , FUNCT_1:2;
thus L1516: thesis by L1515 , L425;
end;
theorem
L1517: (for B366 , B367 , B368 being Function holds (for B369 being set holds (B366 , B367 equal_outside B369 implies ( B368 +* B366 ) , ( B368 +* B367 ) equal_outside B369)))
proof
let C370 , C371 , C372 being Function;
let C373 being set;
assume L1518: C370 , C371 equal_outside C373;
L1519: ( C370 | ( ( dom C370 ) \ C373 ) ) = ( C371 | ( ( dom C371 ) \ C373 ) ) by L1518 , L425;
L1520: ( ( dom C370 ) \ C373 ) = ( dom ( C371 | ( ( dom C371 ) \ C373 ) ) ) by L1519 , RELAT_1:156
.= ( ( dom C371 ) \ C373 ) by RELAT_1:156;
L1521: ( dom ( ( C372 +* C370 ) | ( ( dom ( C372 +* C370 ) ) \ C373 ) ) ) = ( ( dom ( C372 +* C370 ) ) \ C373 ) by RELAT_1:156
.= ( ( ( dom C372 ) \/ ( dom C370 ) ) \ C373 ) by FUNCT_4:def 1
.= ( ( ( dom C372 ) \ C373 ) \/ ( ( dom C370 ) \ C373 ) ) by XBOOLE_1:42;
L1522: ( dom ( ( C372 +* C370 ) | ( ( dom ( C372 +* C370 ) ) \ C373 ) ) ) = ( ( ( dom C372 ) \/ ( dom C371 ) ) \ C373 ) by L1521 , L1520 , XBOOLE_1:42
.= ( ( dom ( C372 +* C371 ) ) \ C373 ) by FUNCT_4:def 1
.= ( dom ( ( C372 +* C371 ) | ( ( dom ( C372 +* C371 ) ) \ C373 ) ) ) by RELAT_1:156;
L1523:
now
let C374 being set;
assume L1524: C374 in ( dom ( ( C372 +* C370 ) | ( ( dom ( C372 +* C370 ) ) \ C373 ) ) );
L1525: (C374 in ( ( dom C372 ) \ C373 ) or C374 in ( ( dom C370 ) \ C373 )) by L1524 , L1521 , XBOOLE_0:def 3;
per cases ;
suppose L1526: C374 in ( ( dom C370 ) \ C373 );

thus L1527: ( ( ( C372 +* C370 ) | ( ( dom ( C372 +* C370 ) ) \ C373 ) ) . C374 ) = ( ( C372 +* C370 ) . C374 ) by L1524 , FUNCT_1:47
.= ( C370 . C374 ) by L1526 , FUNCT_4:13
.= ( ( C371 | ( ( dom C371 ) \ C373 ) ) . C374 ) by L1519 , L1526 , FUNCT_1:49
.= ( C371 . C374 ) by L1520 , L1526 , FUNCT_1:49
.= ( ( C372 +* C371 ) . C374 ) by L1520 , L1526 , FUNCT_4:13
.= ( ( ( C372 +* C371 ) | ( ( dom ( C372 +* C371 ) ) \ C373 ) ) . C374 ) by L1522 , L1524 , FUNCT_1:47;
end;
suppose L1528: (not C374 in ( ( dom C370 ) \ C373 ));

L1529: (not C374 in C373) by L1525 , XBOOLE_0:def 5;
L1530: (not C374 in ( dom C370 )) by L1529 , L1528 , XBOOLE_0:def 5;
L1531: (not C374 in ( dom C371 )) by L1520 , L1528 , L1529 , XBOOLE_0:def 5;
thus L1532: ( ( ( C372 +* C370 ) | ( ( dom ( C372 +* C370 ) ) \ C373 ) ) . C374 ) = ( ( C372 +* C370 ) . C374 ) by L1524 , FUNCT_1:47
.= ( C372 . C374 ) by L1530 , FUNCT_4:11
.= ( ( C372 +* C371 ) . C374 ) by L1531 , FUNCT_4:11
.= ( ( ( C372 +* C371 ) | ( ( dom ( C372 +* C371 ) ) \ C373 ) ) . C374 ) by L1522 , L1524 , FUNCT_1:47;
end;
end;
L1534: ( ( C372 +* C370 ) | ( ( dom ( C372 +* C370 ) ) \ C373 ) ) = ( ( C372 +* C371 ) | ( ( dom ( C372 +* C371 ) ) \ C373 ) ) by L1523 , L1522 , FUNCT_1:2;
thus L1535: thesis by L1534 , L425;
end;
theorem
L1536: (for B370 , B371 , B372 being Function holds (( B370 +* B372 ) = ( B371 +* B372 ) iff B370 , B371 equal_outside ( dom B372 )))
proof
let C375 , C376 , C377 being Function;
thus L1537: (( C375 +* C377 ) = ( C376 +* C377 ) implies C375 , C376 equal_outside ( dom C377 ))
proof
assume L1538: ( C375 +* C377 ) = ( C376 +* C377 );
L1539: ( C375 +* C377 ) , C376 equal_outside ( dom C377 ) by L1538 , L429 , L438;
L1540: C375 , ( C375 +* C377 ) equal_outside ( dom C377 ) by L438;
thus L1541: thesis by L1540 , L1539 , L432;
end;

assume L1542: C375 , C376 equal_outside ( dom C377 );
L1543: ( ( dom C375 ) \ ( dom C377 ) ) = ( ( dom C376 ) \ ( dom C377 ) ) by L1542 , L435;
L1544: (for B373 being set holds (B373 in ( dom ( C375 +* C377 ) ) implies ( ( C375 +* C377 ) . B373 ) = ( ( C376 +* C377 ) . B373 )))
proof
let C378 being set;
assume L1545: C378 in ( dom ( C375 +* C377 ) );
per cases ;
suppose L1546: C378 in ( dom C377 );

thus L1547: ( ( C375 +* C377 ) . C378 ) = ( C377 . C378 ) by L1546 , FUNCT_4:13
.= ( ( C376 +* C377 ) . C378 ) by L1546 , FUNCT_4:13;
end;
suppose L1548: (not C378 in ( dom C377 ));

L1549: ( dom ( C375 +* C377 ) ) = ( ( dom C375 ) \/ ( dom C377 ) ) by FUNCT_4:def 1;
L1550: C378 in ( dom C375 ) by L1549 , L1545 , L1548 , XBOOLE_0:def 3;
L1551: C378 in ( ( dom C375 ) \ ( dom C377 ) ) by L1550 , L1548 , XBOOLE_0:def 5;
L1552: ( C375 | ( ( dom C375 ) \ ( dom C377 ) ) ) = ( C376 | ( ( dom C376 ) \ ( dom C377 ) ) ) by L1542 , L425;
thus L1553: ( ( C375 +* C377 ) . C378 ) = ( C375 . C378 ) by L1548 , FUNCT_4:11
.= ( ( C376 | ( ( dom C376 ) \ ( dom C377 ) ) ) . C378 ) by L1552 , L1551 , FUNCT_1:49
.= ( C376 . C378 ) by L1543 , L1551 , FUNCT_1:49
.= ( ( C376 +* C377 ) . C378 ) by L1548 , FUNCT_4:11;
end;
end;
L1555: ( dom ( C375 +* C377 ) ) = ( ( dom C375 ) \/ ( dom C377 ) ) by FUNCT_4:def 1
.= ( ( ( dom C376 ) \ ( dom C377 ) ) \/ ( dom C377 ) ) by L1543 , XBOOLE_1:39
.= ( ( dom C376 ) \/ ( dom C377 ) ) by XBOOLE_1:39
.= ( dom ( C376 +* C377 ) ) by FUNCT_4:def 1;
thus L1556: thesis by L1555 , L1544 , FUNCT_1:2;
end;
theorem
L1557: (for B374 , B375 , B376 being set holds (for B377 being Function holds (( B377 . B374 ) = ( B377 . B375 ) implies ( B377 . B376 ) = ( ( B377 * ( ( id ( dom B377 ) ) +* (B374 , B375) ) ) . B376 ))))
proof
let C379 , C380 , C381 being set;
let C382 being Function;
assume L1558: ( C382 . C379 ) = ( C382 . C380 );
set D92 = ( ( id ( dom C382 ) ) +* (C379 , C380) );
L1559: ( dom ( id ( dom C382 ) ) ) = ( dom C382 );
per cases ;
suppose L1560: (not C379 in ( dom C382 ));

L1561: ( id ( dom C382 ) ) = D92 by L1560 , L1559 , L444;
thus L1562: thesis by L1561 , RELAT_1:52;
end;
suppose L1563: C379 in ( dom C382 );

L1564: ( dom D92 ) = ( dom C382 ) by L1559 , L446;
L1565: ( D92 . C379 ) = C380 by L1559 , L1563 , L453;
thus L1566: ( C382 . C381 ) = ( ( C382 * ( ( id ( dom C382 ) ) +* (C379 , C380) ) ) . C381 )
proof
per cases ;
suppose L1567: C381 in ( dom C382 );

L1568:
now
assume L1569: C381 <> C379;
L1570: ( D92 . C381 ) = ( ( id ( dom C382 ) ) . C381 ) by L1569 , L458
.= C381 by L1567 , FUNCT_1:18;
thus L1571: thesis by L1570 , L1564 , L1567 , FUNCT_1:13;
end;
thus L1572: thesis by L1568 , L1558 , L1563 , L1565 , L1564 , FUNCT_1:13;
end;
suppose L1573: (not C381 in ( dom C382 ));

L1574: ( dom ( C382 * D92 ) ) c= ( dom D92 ) by RELAT_1:25;
L1575: (not C381 in ( dom ( C382 * D92 ) )) by L1574 , L1564 , L1573;
L1576: ( ( C382 * D92 ) . C381 ) = ( {} ) by L1575 , FUNCT_1:def 2;
thus L1577: thesis by L1576 , L1573 , FUNCT_1:def 2;
end;
end;

end;
end;
theorem
L1568: (for B378 , B379 being set holds (for B380 being Function holds ((B378 in ( dom B380 ) implies (B379 in ( dom B380 ) & ( B380 . B378 ) = ( B380 . B379 ))) implies B380 = ( B380 * ( ( id ( dom B380 ) ) +* (B378 , B379) ) ))))
proof
let C383 , C384 being set;
let C385 being Function;
assume L1569: (C383 in ( dom C385 ) implies (C384 in ( dom C385 ) & ( C385 . C383 ) = ( C385 . C384 )));
set D93 = ( ( id ( dom C385 ) ) +* (C383 , C384) );
set D94 = ( C385 * D93 );
L1570: ( dom ( id ( dom C385 ) ) ) = ( dom C385 );
per cases ;
suppose L1571: (not C383 in ( dom C385 ));

L1572: ( id ( dom C385 ) ) = D93 by L1571 , L1570 , L444;
thus L1573: thesis by L1572 , RELAT_1:52;
end;
suppose L1574: C383 in ( dom C385 );

L1575: ( dom D93 ) = ( dom C385 ) by L1570 , L446;
L1576:
now
L1577: ( rng D93 ) c= ( dom C385 )
proof
let C386 being set;
assume L1578: C386 in ( rng D93 );
consider C387 being set such that L1579: C387 in ( dom D93 ) and L1580: C386 = ( D93 . C387 ) by L1578 , FUNCT_1:def 3;
per cases ;
suppose L1581: C387 = C383;

thus L1582: thesis by L1581 , L1569 , L1570 , L1574 , L1580 , L453;
end;
suppose L1583: C387 <> C383;

L1584: ( ( id ( dom C385 ) ) . C387 ) = ( D93 . C387 ) by L1583 , L458;
thus L1585: thesis by L1584 , L1575 , L1579 , L1580 , FUNCT_1:18;
end;
end;
thus L1587: ( dom C385 ) = ( dom D94 ) by L1577 , L1575 , RELAT_1:27;
let C388 being set;
assume L1588: C388 in ( dom C385 );
thus L1589: ( C385 . C388 ) = ( D94 . C388 ) by L1569 , L1574 , L1557;
end;
thus L1590: thesis by L1576 , FUNCT_1:2;
end;
end;
theorem
L1592: (for B381 being Function holds (for B382 being set holds (B382 in ( dom B381 ) implies ( B381 +* ( B382 .--> ( B381 . B382 ) ) ) = B381)))
proof
let C389 being Function;
let C390 being set;
assume L1593: C390 in ( dom C389 );
thus L1594: ( C389 +* ( C390 .--> ( C389 . C390 ) ) ) = ( C389 +* (C390 , ( C389 . C390 )) ) by L1593 , L444
.= C389 by L496;
end;
theorem
L1595: (for B383 being set holds (for B384 being (Permutation of B383) holds (for B385 , B386 being (Element of B383) holds ( ( B384 +* (B385 , ( B384 . B386 )) ) +* (B386 , ( B384 . B385 )) ) is (Permutation of B383))))
proof
let C391 being set;
let C392 being (Permutation of C391);
let C393 , C394 being (Element of C391);
set D95 = ( C392 +* (C393 , ( C392 . C394 )) );
set D96 = ( D95 +* (C394 , ( C392 . C393 )) );
L1596: ( dom D96 ) = ( dom D95 ) by L446;
L1597: ( dom D95 ) = ( dom C392 ) by L446;
L1598: (C391 = ( {} ) implies C391 = ( {} ));
L1599: ( dom C392 ) = C391 by L1598 , FUNCT_2:def 1;
per cases ;
suppose L1600: C391 is  empty;

L1601: D96 = ( {} ) by L1600 , L1596 , L1597;
thus L1602: thesis by L1601 , L1596 , L1597 , L1598;
end;
suppose L1603: C391 is non  empty;

L1604: ( rng C392 ) = C391 by FUNCT_2:def 3;
L1605: ( C392 . C393 ) in C391 by L1604 , L1599 , L1603 , FUNCT_1:def 3;
thus L1606: ( ( C392 +* (C393 , ( C392 . C394 )) ) +* (C394 , ( C392 . C393 )) ) is (Permutation of C391)
proof
per cases ;
suppose L1607: C393 = C394;

L1608: D96 = D95 by L1607 , L496
.= C392 by L1607 , L496;
thus L1609: thesis by L1608;
end;
suppose L1610: C393 <> C394;

L1611: ( D96 . C393 ) = ( D95 . C393 ) by L1610 , L458
.= ( C392 . C394 ) by L1599 , L1603 , L453;
L1612:
now
let C395 being set;
assume that
L1613: C395 in C391
and
L1614: C395 <> C393
and
L1615: C395 <> C394;
thus L1616: ( D96 . C395 ) = ( D95 . C395 ) by L1615 , L458
.= ( C392 . C395 ) by L1614 , L458;
end;
L1617: ( D96 . C394 ) = ( C392 . C393 ) by L1597 , L1599 , L1603 , L453;
L1618:
now
let C396 being set;
thus L1619:now
assume L1620: C396 in ( rng D96 );
consider C397 being set such that L1621: C397 in ( dom D96 ) and L1622: C396 = ( D96 . C397 ) by L1620 , FUNCT_1:def 3;
L1623: ( C392 . C397 ) in C391 by L1596 , L1597 , L1604 , L1621 , FUNCT_1:def 3;
per cases ;
suppose L1624: C397 = C393;

thus L1625: C396 in C391 by L1624 , L1599 , L1603 , L1604 , L1611 , L1622 , FUNCT_1:def 3;
end;
suppose L1626: C397 = C394;

thus L1627: C396 in C391 by L1626 , L1597 , L1599 , L1605 , L1622 , L453;
end;
suppose L1628: (C397 <> C393 & C397 <> C394);

thus L1629: C396 in C391 by L1628 , L1596 , L1597 , L1612 , L1621 , L1622 , L1623;
end;
end;
assume L1631: C396 in C391;
consider C398 being set such that L1632: C398 in ( dom C392 ) and L1633: C396 = ( C392 . C398 ) by L1631 , L1604 , FUNCT_1:def 3;
per cases ;
suppose L1634: C398 = C393;

thus L1635: C396 in ( rng D96 ) by L1634 , L1596 , L1597 , L1599 , L1617 , L1632 , L1633 , FUNCT_1:def 3;
end;
suppose L1636: C398 = C394;

thus L1637: C396 in ( rng D96 ) by L1636 , L1596 , L1597 , L1599 , L1611 , L1632 , L1633 , FUNCT_1:def 3;
end;
suppose L1638: (C398 <> C393 & C398 <> C394);

L1639: ( D96 . C398 ) = ( C392 . C398 ) by L1638 , L1612 , L1632;
thus L1640: C396 in ( rng D96 ) by L1639 , L1596 , L1597 , L1632 , L1633 , FUNCT_1:def 3;
end;
end;
L1642: ( rng D96 ) = C391 by L1618 , TARSKI:1;
reconsider D97 = D96 as (Function of C391 , C391) by L1642 , L1596 , L1597 , L1599 , L1603 , FUNCT_2:def 1 , RELSET_1:4;
L1643:
now
let C399 , C400 being set;
assume that
L1644: C399 in C391
and
L1645: C400 in C391
and
L1646: ( D97 . C399 ) = ( D97 . C400 )
and
L1647: C399 <> C400;
per cases ;
suppose L1648: (C399 = C393 & C400 = C394);

thus L1649: contradiction by L1648 , L1603 , L1610 , L1611 , L1617 , L1646 , FUNCT_2:19;
end;
suppose L1650: (C399 = C394 & C400 = C393);

thus L1651: contradiction by L1650 , L1603 , L1610 , L1611 , L1617 , L1646 , FUNCT_2:19;
end;
suppose L1652: (C399 = C393 & C400 <> C394);

L1653: ( D97 . C400 ) = ( C392 . C400 ) by L1652 , L1612 , L1645 , L1647;
thus L1654: contradiction by L1653 , L1611 , L1645 , L1646 , L1652 , FUNCT_2:19;
end;
suppose L1655: (C399 <> C393 & C400 = C394);

L1656: ( D97 . C399 ) = ( C392 . C399 ) by L1655 , L1612 , L1644 , L1647;
thus L1657: contradiction by L1656 , L1617 , L1644 , L1646 , L1655 , FUNCT_2:19;
end;
suppose L1658: (C399 = C394 & C400 <> C393);

L1659: ( D97 . C400 ) = ( C392 . C400 ) by L1658 , L1612 , L1645 , L1647;
thus L1660: contradiction by L1659 , L1617 , L1645 , L1646 , L1658 , FUNCT_2:19;
end;
suppose L1661: (C399 <> C394 & C400 = C393);

L1662: ( D97 . C399 ) = ( C392 . C399 ) by L1661 , L1612 , L1644 , L1647;
thus L1663: contradiction by L1662 , L1611 , L1644 , L1646 , L1661 , FUNCT_2:19;
end;
suppose L1664: (C399 <> C394 & C400 <> C393 & C399 <> C393 & C400 <> C394);

L1665: (( D97 . C399 ) = ( C392 . C399 ) & ( D97 . C400 ) = ( C392 . C400 )) by L1664 , L1612 , L1644 , L1645;
thus L1666: contradiction by L1665 , L1644 , L1645 , L1646 , L1647 , FUNCT_2:19;
end;
end;
L1668: D97 is  one-to-one by L1643 , L1603 , FUNCT_2:19;
L1669: ( rng D97 ) = C391 by L1618 , TARSKI:1;
L1670: D97 is  onto by L1669 , FUNCT_2:def 3;
thus L1671: thesis by L1670 , L1668;
end;
end;

end;
end;
theorem
L1608: (for B387 being Function holds (for B388 , B389 being set holds ((B388 in ( dom B387 ) & B389 in ( dom B387 )) implies (ex B390 being (Permutation of ( dom B387 )) st ( ( B387 +* (B388 , ( B387 . B389 )) ) +* (B389 , ( B387 . B388 )) ) = ( B387 * B390 )))))
proof
let C401 being Function;
let C402 , C403 being set;
assume that
L1609: C402 in ( dom C401 )
and
L1610: C403 in ( dom C401 );
set D98 = ( id ( dom C401 ) );
L1611: (( D98 . C402 ) = C402 & ( D98 . C403 ) = C403) by L1609 , L1610 , FUNCT_1:18;
reconsider D99 = ( ( D98 +* (C402 , C403) ) +* (C403 , C402) ) as (Permutation of ( dom C401 )) by L1611 , L1609 , L1610 , L1595;
set D100 = ( D98 +* (C402 , C403) );
set D101 = ( C401 * D99 );
set D102 = ( C401 +* (C402 , ( C401 . C403 )) );
take D99;
set D103 = ( D102 +* (C403 , ( C401 . C402 )) );
L1612: ( dom D98 ) = ( dom C401 );
L1613: ( dom D102 ) = ( dom D103 ) by L446;
L1614: ( dom D99 ) = ( dom D100 ) by L446;
L1615: ( dom D100 ) = ( dom D98 ) by L446;
L1616: ( dom C401 ) = ( dom D102 ) by L446;
L1617:
now
thus L1618: ( dom C401 ) = ( dom D103 ) by L1613 , L446;
L1619: ( rng D99 ) = ( dom C401 ) by FUNCT_2:def 3;
thus L1620: ( dom C401 ) = ( dom D101 ) by L1619 , L1614 , L1615 , RELAT_1:27;
let C404 being set;
assume that
L1621: C404 in ( dom C401 );
per cases ;
suppose L1622: C402 <> C403;

thus L1623: ( D103 . C404 ) = ( D101 . C404 )
proof
per cases ;
suppose L1624: C404 = C402;

thus L1625: ( D103 . C404 ) = ( D102 . C404 ) by L1624 , L1622 , L458
.= ( C401 . C403 ) by L1621 , L1624 , L453
.= ( C401 . ( D100 . C402 ) ) by L1609 , L1612 , L453
.= ( C401 . ( D99 . C402 ) ) by L1622 , L458
.= ( D101 . C404 ) by L1614 , L1615 , L1621 , L1624 , FUNCT_1:13;
end;
suppose L1626: C404 = C403;

thus L1627: ( D103 . C404 ) = ( C401 . C402 ) by L1626 , L1616 , L1621 , L453
.= ( C401 . ( D99 . C403 ) ) by L1610 , L1615 , L453
.= ( D101 . C404 ) by L1614 , L1615 , L1621 , L1626 , FUNCT_1:13;
end;
suppose L1628: (C404 <> C402 & C404 <> C403);

L1629: ( D99 . C404 ) = ( D100 . C404 ) by L1628 , L458
.= ( D98 . C404 ) by L1628 , L458
.= C404 by L1621 , FUNCT_1:18;
thus L1630: ( D103 . C404 ) = ( D102 . C404 ) by L1628 , L458
.= ( C401 . ( D99 . C404 ) ) by L1628 , L1629 , L458
.= ( D101 . C404 ) by L1614 , L1615 , L1621 , FUNCT_1:13;
end;
end;

end;
suppose L1624: C402 = C403;

L1625: C402 = ( D98 . C402 ) by L1609 , FUNCT_1:17;
L1626: (D102 = C401 & D98 = ( D98 +* (C402 , ( D98 . C403 )) )) by L1624 , L496;
thus L1627: ( D103 . C404 ) = ( D101 . C404 ) by L1626 , L1624 , L1625 , RELAT_1:52;
end;
end;
thus L1629: thesis by L1617 , FUNCT_1:2;
end;
theorem
L1630: (for B391 being Function holds (for B392 , B393 being set holds (B392 in ( dom B391 ) implies ( dom B391 ) = ( dom ( B391 +* ( B392 .--> B393 ) ) ))))
proof
let C405 being Function;
let C406 , C407 being set;
assume L1631: C406 in ( dom C405 );
thus L1632: ( dom C405 ) = ( dom ( C405 +* (C406 , C407) ) ) by L446
.= ( dom ( C405 +* ( C406 .--> C407 ) ) ) by L1631 , L444;
end;
theorem
L1633: (for B394 , B395 being (FinSequence of ( INT )) holds (for B396 , B397 being (Element of ( NAT )) holds ((1 <= B397 & B397 <= ( len B394 ) & 1 <= B396 & B396 <= ( len B394 ) & B395 = ( ( B394 +* (B396 , ( B394 /. B397 )) ) +* (B397 , ( B394 /. B396 )) )) implies (( B394 . B396 ) = ( B395 . B397 ) & ( B394 . B397 ) = ( B395 . B396 ) & (for B398 being set holds ((B398 <> B396 & B398 <> B397 & B398 in ( dom B394 )) implies ( B394 . B398 ) = ( B395 . B398 ))) & B394 , B395 are_fiberwise_equipotent ))))
proof
let C408 , C409 being (FinSequence of ( INT ));
let C410 , C411 being (Element of ( NAT ));
assume that
L1634: (1 <= C411 & C411 <= ( len C408 ))
and
L1635: (1 <= C410 & C410 <= ( len C408 ))
and
L1636: C409 = ( ( C408 +* (C410 , ( C408 /. C411 )) ) +* (C411 , ( C408 /. C410 )) );
L1637: ( dom ( C408 +* (C410 , ( C408 /. C411 )) ) ) = ( dom C408 ) by L446;
L1638: C411 in ( dom C408 ) by L1634 , FINSEQ_3:25;
thus L1639: ( C409 . C411 ) = ( C408 /. C410 ) by L1638 , L1636 , L1637 , L453
.= ( C408 . C410 ) by L1635 , FINSEQ_4:15;
L1640: C410 in ( dom C408 ) by L1635 , FINSEQ_3:25;
thus L1641:now
per cases ;
suppose L1642: C410 = C411;

thus L1643: ( C409 . C410 ) = ( C408 . C411 ) by L1642 , L1639;
end;
suppose L1644: C410 <> C411;

thus L1645: ( C409 . C410 ) = ( ( C408 +* (C410 , ( C408 /. C411 )) ) . C410 ) by L1644 , L1636 , L458
.= ( C408 /. C411 ) by L1640 , L453
.= ( C408 . C411 ) by L1634 , FINSEQ_4:15;
end;
end;
L1647:
now
let C412 being set;
assume that
L1648: C412 <> C410
and
L1649: C412 <> C411
and
L1650: C412 in ( dom C408 );
thus L1651: ( C409 . C412 ) = ( ( C408 +* (C410 , ( C408 /. C411 )) ) . C412 ) by L1636 , L1649 , L458
.= ( C408 . C412 ) by L1648 , L458;
end;
L1652: ( dom C409 ) = ( dom C408 ) by L1636 , L1637 , L446;
thus L1653: thesis by L1652 , L1638 , L1640 , L1639 , L1641 , L1647 , RFINSEQ:28;
end;
theorem
L1654: (for B399 being Function holds (for B400 , B401 , B402 , B403 , B404 , B405 being set holds ((B400 <> B402 & B400 <> B404) implies ( ( ( ( B399 +* ( B400 .--> B401 ) ) +* ( B402 .--> B403 ) ) +* ( B404 .--> B405 ) ) . B400 ) = B401)))
proof
let C413 being Function;
let C414 , C415 , C416 , C417 , C418 , C419 being set;
assume L1655: (C414 <> C416 & C414 <> C418);
thus L1656: ( ( ( ( C413 +* ( C414 .--> C415 ) ) +* ( C416 .--> C417 ) ) +* ( C418 .--> C419 ) ) . C414 ) = ( ( C413 +* ( C414 .--> C415 ) ) . C414 ) by L1655 , FUNCT_4:91
.= C415 by L1338;
end;
theorem
L1657: (for B406 , B407 , B408 , B409 being set holds (for B410 being (Function of B406 , B407) holds (B409 in B407 implies ( B410 +* (B408 , B409) ) is (Function of B406 , B407))))
proof
let C420 , C421 , C422 , C423 being set;
let C424 being (Function of C420 , C421);
assume that
L1658: C423 in C421;
L1659: ( dom C424 ) = C420 by L1658 , FUNCT_2:def 1;
per cases ;
suppose L1660: (not C422 in C420);

thus L1661: thesis by L1660 , L1659 , L444;
end;
suppose L1662: C422 in C420;

set D104 = ( C422 .--> C423 );
set D105 = ( C424 +* D104 );
L1663: ( rng D104 ) = { C423 } by FUNCOP_1:8;
L1664: ( rng D104 ) c= C421 by L1663 , L1658 , ZFMISC_1:31;
L1665: (( rng D105 ) c= ( ( rng C424 ) \/ ( rng D104 ) ) & ( ( rng C424 ) \/ ( rng D104 ) ) c= ( C421 \/ C421 )) by L1664 , FUNCT_4:17 , XBOOLE_1:13;
L1666: { C422 } c= C420 by L1662 , ZFMISC_1:31;
L1667: ( dom D105 ) = ( C420 \/ ( dom D104 ) ) by L1659 , FUNCT_4:def 1
.= ( C420 \/ { C422 } ) by FUNCOP_1:13
.= C420 by L1666 , XBOOLE_1:12;
L1668: ( C424 +* D104 ) is (Function of C420 , C421) by L1667 , L1665 , FUNCT_2:2 , XBOOLE_1:1;
L1669: C422 in ( dom C424 ) by L1658 , L1662 , FUNCT_2:def 1;
thus L1670: thesis by L1669 , L1668 , L444;
end;
end;
theorem
L1672: (for R4 being set holds (for R14 being Function holds (for R25 being set holds (for R26 being set holds (( rng R14 ) c= R4 implies ( R14 +~ (R25 , R26) ) = ( ( ( id R4 ) +* (R25 , R26) ) * R14 ))))))
proof
let R4 being set;
let R14 being Function;
let R25 being set;
let R26 being set;
assume L1673: ( rng R14 ) c= R4;
per cases ;
suppose L1674: R25 in R4;

L1675: R25 in ( dom ( id R4 ) ) by L1674;
thus L1676: ( R14 +~ (R25 , R26) ) = ( ( ( id R4 ) * R14 ) +* ( ( R25 .--> R26 ) * R14 ) ) by L1673 , RELAT_1:53
.= ( ( ( id R4 ) +* ( R25 .--> R26 ) ) * R14 ) by L99
.= ( ( ( id R4 ) +* (R25 , R26) ) * R14 ) by L1675 , L444;
end;
suppose L1677: (not R25 in R4);

L1678: (not R25 in ( dom ( id R4 ) )) by L1677;
L1679: (not R25 in ( rng R14 )) by L1673 , L1677;
thus L1680: ( R14 +~ (R25 , R26) ) = R14 by L1679 , FUNCT_4:103
.= ( ( id R4 ) * R14 ) by L1673 , RELAT_1:53
.= ( ( ( id R4 ) +* (R25 , R26) ) * R14 ) by L1678 , L444;
end;
end;
theorem
L1682: (for R14 being Function holds (for R15 being Function holds (for R25 being set holds (for R26 being set holds ( ( R14 +* R15 ) +~ (R25 , R26) ) = ( ( R14 +~ (R25 , R26) ) +* ( R15 +~ (R25 , R26) ) )))))
proof
let R14 being Function;
let R15 being Function;
let R25 being set;
let R26 being set;
set D106 = ( ( rng R14 ) \/ ( rng R15 ) );
L1683: ( R15 +~ (R25 , R26) ) = ( ( ( id D106 ) +* (R25 , R26) ) * R15 ) by L1672 , XBOOLE_1:7;
L1684: ( dom ( ( id D106 ) +* (R25 , R26) ) ) = ( dom ( id D106 ) ) by L446
.= D106;
L1685: ( rng ( R14 +* R15 ) ) c= D106 by FUNCT_4:17;
thus L1686: ( ( R14 +* R15 ) +~ (R25 , R26) ) = ( ( ( id D106 ) +* (R25 , R26) ) * ( R14 +* R15 ) ) by L1685 , L1672
.= ( ( ( ( id D106 ) +* (R25 , R26) ) * R14 ) +* ( ( ( id D106 ) +* (R25 , R26) ) * R15 ) ) by L1684 , L47 , XBOOLE_1:7
.= ( ( R14 +~ (R25 , R26) ) +* ( R15 +~ (R25 , R26) ) ) by L1683 , L1672 , XBOOLE_1:7;
end;
definition
let C425 , C426 being set;
func C425 followed_by C426 equals 
( ( ( NAT ) --> C426 ) +* (( 0 ) , C425) );
coherence;
end;
registration
let C427 , C428 being set;
cluster ( C427 followed_by C428 ) ->  Function-like  Relation-like;
coherence;
end;
theorem
L1689: (for R28 being set holds (for R29 being set holds ( dom ( R28 followed_by R29 ) ) = ( NAT )))
proof
let R28 being set;
let R29 being set;
thus L1690: ( dom ( R28 followed_by R29 ) ) = ( dom ( ( ( NAT ) --> R29 ) +* (( 0 ) , R28) ) )
.= ( dom ( ( NAT ) --> R29 ) ) by L446
.= ( NAT ) by FUNCOP_1:13;
end;
definition
let C429 being non  empty set;
let C430 , C431 being (Element of C429);
redefine func C430 followed_by C431 -> (sequence of C429);

coherence
proof
L1691: ( C430 followed_by C431 ) = ( ( ( NAT ) --> C431 ) +* (( 0 ) , C430) );
thus L1692: thesis by L1691 , L1657;
end;
end;
theorem
L1694: (for R28 being set holds (for R29 being set holds ( ( R28 followed_by R29 ) . ( 0 ) ) = R28))
proof
let R28 being set;
let R29 being set;
L1695: ( dom ( ( NAT ) --> R29 ) ) = ( NAT ) by FUNCOP_1:13;
thus L1696: thesis by L1695 , L453;
end;
theorem
L1697: (for R28 being set holds (for R29 being set holds (for R31 being Nat holds (R31 > ( 0 ) implies ( ( R28 followed_by R29 ) . R31 ) = R29))))
proof
let R28 being set;
let R29 being set;
let R31 being Nat;
L1698: R31 in ( NAT ) by ORDINAL1:def 12;
assume L1699: R31 > ( 0 );
thus L1700: ( ( R28 followed_by R29 ) . R31 ) = ( ( ( NAT ) --> R29 ) . R31 ) by L1699 , L458
.= R29 by L1698 , FUNCOP_1:7;
end;
definition
let C432 , C433 , C434 being set;
func (C432 , C433) followed_by C434 equals 
( ( ( NAT ) --> C434 ) +* ( (( 0 ) , 1) --> (C432 , C433) ) );
coherence;
end;
registration
let C435 , C436 , C437 being set;
cluster ( (C435 , C436) followed_by C437 ) ->  Function-like  Relation-like;
coherence;
end;
theorem
L1703: (for R28 being set holds (for R29 being set holds (for R30 being set holds ( dom ( (R28 , R29) followed_by R30 ) ) = ( NAT ))))
proof
let R28 being set;
let R29 being set;
let R30 being set;
thus L1704: ( dom ( (R28 , R29) followed_by R30 ) ) = ( ( dom ( ( NAT ) --> R30 ) ) \/ ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) ) by FUNCT_4:def 1
.= ( ( NAT ) \/ ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) ) by FUNCOP_1:13
.= ( ( NAT ) \/ { ( 0 ) , 1 } ) by FUNCT_4:62
.= ( NAT ) by XBOOLE_1:12;
end;
theorem
L1705: (for R28 being set holds (for R29 being set holds (for R30 being set holds ( ( (R28 , R29) followed_by R30 ) . ( 0 ) ) = R28)))
proof
let R28 being set;
let R29 being set;
let R30 being set;
L1706: ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) = { ( 0 ) , 1 } by FUNCT_4:62;
L1707: ( 0 ) in ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) by L1706 , TARSKI:def 2;
thus L1708: ( ( (R28 , R29) followed_by R30 ) . ( 0 ) ) = ( ( ( ( NAT ) --> R30 ) +* ( (( 0 ) , 1) --> (R28 , R29) ) ) . ( 0 ) )
.= ( ( (( 0 ) , 1) --> (R28 , R29) ) . ( 0 ) ) by L1707 , FUNCT_4:13
.= R28 by FUNCT_4:63;
end;
theorem
L1709: (for R28 being set holds (for R29 being set holds (for R30 being set holds ( ( (R28 , R29) followed_by R30 ) . 1 ) = R29)))
proof
let R28 being set;
let R29 being set;
let R30 being set;
L1710: ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) = { ( 0 ) , 1 } by FUNCT_4:62;
L1711: 1 in ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) by L1710 , TARSKI:def 2;
thus L1712: ( ( (R28 , R29) followed_by R30 ) . 1 ) = ( ( ( ( NAT ) --> R30 ) +* ( (( 0 ) , 1) --> (R28 , R29) ) ) . 1 )
.= ( ( (( 0 ) , 1) --> (R28 , R29) ) . 1 ) by L1711 , FUNCT_4:13
.= R29 by FUNCT_4:63;
end;
theorem
L1713: (for R28 being set holds (for R29 being set holds (for R30 being set holds (for R31 being Nat holds (R31 > 1 implies ( ( (R28 , R29) followed_by R30 ) . R31 ) = R30)))))
proof
let R28 being set;
let R29 being set;
let R30 being set;
let R31 being Nat;
assume L1714: R31 > 1;
L1715: ( dom ( (( 0 ) , 1) --> (R28 , R29) ) ) = { ( 0 ) , 1 } by FUNCT_4:62;
L1716: (not R31 in ( dom ( (( 0 ) , 1) --> (R28 , R29) ) )) by L1715 , L1714 , TARSKI:def 2;
L1717: R31 in ( NAT ) by ORDINAL1:def 12;
thus L1718: ( ( (R28 , R29) followed_by R30 ) . R31 ) = ( ( ( ( NAT ) --> R30 ) +* ( (( 0 ) , 1) --> (R28 , R29) ) ) . R31 )
.= ( ( ( NAT ) --> R30 ) . R31 ) by L1716 , FUNCT_4:11
.= R30 by L1717 , FUNCOP_1:7;
end;
theorem
L1719: (for R28 being set holds (for R29 being set holds (for R30 being set holds ( (R28 , R29) followed_by R30 ) = ( ( R28 followed_by R30 ) +* (1 , R29) ))))
proof
let R28 being set;
let R29 being set;
let R30 being set;
set D107 = ( (R28 , R29) followed_by R30 );
set D108 = ( ( R28 followed_by R30 ) +* (1 , R29) );
L1720: ( dom ( R28 followed_by R30 ) ) = ( NAT ) by L1689;
L1721: ( dom D107 ) = ( NAT ) by L1703;
thus L1722: ( dom D107 ) = ( dom D108 ) by L1721 , L1720 , L446;
let C438 being set;
assume L1723: C438 in ( dom D107 );
reconsider D109 = C438 as Nat by L1723 , L1721;
per cases  by NAT_1:25;
suppose L1724: D109 = ( 0 );

thus L1725: ( D107 . C438 ) = R28 by L1724 , L1705
.= ( ( R28 followed_by R30 ) . C438 ) by L1724 , L1694
.= ( D108 . C438 ) by L1724 , L458;
end;
suppose L1726: D109 = 1;

thus L1727: ( D107 . C438 ) = R29 by L1726 , L1709
.= ( D108 . C438 ) by L1720 , L1726 , L453;
end;
suppose L1728: D109 > 1;

thus L1729: ( D107 . C438 ) = R30 by L1728 , L1713
.= ( ( R28 followed_by R30 ) . C438 ) by L1728 , L1697
.= ( D108 . C438 ) by L1728 , L458;
end;
end;
definition
let C439 being non  empty set;
let C440 , C441 , C442 being (Element of C439);
redefine func (C440 , C441) followed_by C442 -> (sequence of C439);

coherence
proof
L1731: ( (C440 , C441) followed_by C442 ) = ( ( C440 followed_by C442 ) +* (1 , C441) ) by L1719;
thus L1732: thesis by L1731 , L1657;
end;
end;
theorem
L1734: (for R28 being set holds (for R29 being set holds ( rng ( R28 followed_by R29 ) ) = { R28 , R29 }))
proof
let R28 being set;
let R29 being set;
L1735: ( rng ( ( NAT ) --> R29 ) ) = { R29 } by FUNCOP_1:8;
L1736: ( rng ( ( ( NAT ) --> R29 ) +* (( 0 ) , R28) ) ) c= ( { R29 } \/ { R28 } ) by L1735 , L1412;
thus L1737: ( rng ( R28 followed_by R29 ) ) c= { R28 , R29 } by L1736 , ENUMSET1:1;
let C443 being set;
assume L1738: C443 in { R28 , R29 };
L1739: ( dom ( ( NAT ) --> R29 ) ) = ( NAT ) by FUNCOP_1:13;
L1740: 1 in ( dom ( ( NAT ) --> R29 ) ) by L1739;
L1741: 1 in ( dom ( R28 followed_by R29 ) ) by L1740 , L446;
L1742: ( ( R28 followed_by R29 ) . 1 ) = R29 by L1697;
L1743: R29 in ( rng ( R28 followed_by R29 ) ) by L1742 , L1741 , FUNCT_1:3;
L1744: R28 in ( rng ( R28 followed_by R29 ) ) by L1739 , L1434;
thus L1745: thesis by L1744 , L1738 , L1743 , TARSKI:def 2;
end;
theorem
L1746: (for R28 being set holds (for R29 being set holds (for R30 being set holds ( rng ( (R28 , R29) followed_by R30 ) ) = { R28 , R29 , R30 })))
proof
let R28 being set;
let R29 being set;
let R30 being set;
L1747: ( (R28 , R29) followed_by R30 ) = ( ( R28 followed_by R30 ) +* (1 , R29) ) by L1719;
L1748: ( dom ( (R28 , R29) followed_by R30 ) ) = ( dom ( R28 followed_by R30 ) ) by L1747 , L446
.= ( dom ( ( NAT ) --> R30 ) ) by L446
.= ( NAT ) by FUNCOP_1:13;
L1749: ( ( (R28 , R29) followed_by R30 ) . 2 ) = R30 by L1713;
L1750: R30 in ( rng ( (R28 , R29) followed_by R30 ) ) by L1749 , L1748 , FUNCT_1:3;
L1751: ( ( (R28 , R29) followed_by R30 ) . 1 ) = R29 by L1709;
L1752: R29 in ( rng ( (R28 , R29) followed_by R30 ) ) by L1751 , L1748 , FUNCT_1:3;
L1753: ( rng ( R28 followed_by R30 ) ) = { R28 , R30 } by L1734;
L1754: ( rng ( ( R28 followed_by R30 ) +* (1 , R29) ) ) c= ( { R28 , R30 } \/ { R29 } ) by L1753 , L1412;
L1755: ( rng ( ( R28 followed_by R30 ) +* (1 , R29) ) ) c= { R28 , R30 , R29 } by L1754 , ENUMSET1:3;
thus L1756: ( rng ( (R28 , R29) followed_by R30 ) ) c= { R28 , R29 , R30 } by L1755 , L1747 , ENUMSET1:57;
let C444 being set;
L1757: ( ( (R28 , R29) followed_by R30 ) . ( 0 ) ) = R28 by L1705;
L1758: R28 in ( rng ( (R28 , R29) followed_by R30 ) ) by L1757 , L1748 , FUNCT_1:3;
assume L1759: C444 in { R28 , R29 , R30 };
thus L1760: thesis by L1759 , L1758 , L1752 , L1750 , ENUMSET1:def 1;
end;
definition
let C445 , C446 being set;
let C447 being (Function of C445 , C446);
let C448 being set;
let C449 being (Element of C446);
redefine func C447 +* (C448 , C449) -> (Function of C445 , C446);

coherence
proof
set D110 = ( C447 +* (C448 , C449) );
L1761: ( rng D110 ) c= ( ( rng C447 ) \/ { C449 } ) by L1412;
per cases ;
suppose L1762: C446 is  empty;

L1763: ( dom C447 ) is  empty by L1762;
thus L1764: thesis by L1763 , L444;
end;
suppose L1765: C446 is non  empty;

L1766: { C449 } c= C446 by L1765 , ZFMISC_1:31;
L1767: ( ( rng C447 ) \/ { C449 } ) c= C446 by L1766 , XBOOLE_1:8;
L1768: ( rng D110 ) c= C446 by L1767 , L1761 , XBOOLE_1:1;
L1769: ( dom C447 ) = C445 by L1765 , FUNCT_2:def 1;
L1770: ( dom D110 ) = C445 by L1769 , L446;
thus L1771: thesis by L1770 , L1765 , L1768 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
end;
theorem
L1774: (for B411 , B412 being non  empty set holds (for B413 being (Function of B411 , B412) holds (for B414 being (Element of B411) holds (for B415 being set holds ( ( B413 +* (B414 , B415) ) . B414 ) = B415))))
proof
let C450 , C451 being non  empty set;
let C452 being (Function of C450 , C451);
let C453 being (Element of C450);
let C454 being set;
L1775: C453 in C450;
L1776: C453 in ( dom C452 ) by L1775 , FUNCT_2:def 1;
thus L1777: thesis by L1776 , L453;
end;
theorem
L1778: (for B416 , B417 being non  empty set holds (for B418 , B419 being (Function of B416 , B417) holds (for B420 being (Element of B416) holds ((for B421 being (Element of B416) holds (( B418 . B421 ) <> ( B419 . B421 ) implies B421 = B420)) implies B418 = ( B419 +* (B420 , ( B418 . B420 )) )))))
proof
let C455 , C456 being non  empty set;
let C457 , C458 being (Function of C455 , C456);
let C459 being (Element of C455);
assume that
L1779: (for B422 being (Element of C455) holds (( C457 . B422 ) <> ( C458 . B422 ) implies B422 = C459));
L1780: C459 in C455;
L1781: C459 in ( dom C458 ) by L1780 , FUNCT_2:def 1;
L1782: ( dom C457 ) = C455 by FUNCT_2:def 1
.= ( C455 \/ { C459 } ) by XBOOLE_1:12
.= ( ( dom C458 ) \/ { C459 } ) by FUNCT_2:def 1
.= ( ( dom C458 ) \/ ( dom ( C459 .--> ( C457 . C459 ) ) ) ) by FUNCOP_1:13;
L1783: (for B423 being set holds (B423 in ( ( dom C458 ) \/ ( dom ( C459 .--> ( C457 . C459 ) ) ) ) implies ((B423 in ( dom ( C459 .--> ( C457 . C459 ) ) ) implies ( C457 . B423 ) = ( ( C459 .--> ( C457 . C459 ) ) . B423 )) & ((not B423 in ( dom ( C459 .--> ( C457 . C459 ) ) )) implies ( C457 . B423 ) = ( C458 . B423 )))))
proof
let C460 being set;
assume L1784: C460 in ( ( dom C458 ) \/ ( dom ( C459 .--> ( C457 . C459 ) ) ) );
thus L1785: (C460 in ( dom ( C459 .--> ( C457 . C459 ) ) ) implies ( C457 . C460 ) = ( ( C459 .--> ( C457 . C459 ) ) . C460 ))
proof
assume L1786: C460 in ( dom ( C459 .--> ( C457 . C459 ) ) );
L1787: C460 in { C459 } by L1786 , FUNCOP_1:13;
L1788: C460 = C459 by L1787 , TARSKI:def 1;
thus L1789: thesis by L1788 , FUNCOP_1:72;
end;

assume L1790: (not C460 in ( dom ( C459 .--> ( C457 . C459 ) ) ));
L1791: (not C460 in { C459 }) by L1790 , FUNCOP_1:13;
L1792: C460 <> C459 by L1791 , TARSKI:def 1;
thus L1793: thesis by L1792 , L1779 , L1784;
end;
thus L1794: C457 = ( C458 +* ( C459 .--> ( C457 . C459 ) ) ) by L1783 , L1782 , FUNCT_4:def 1
.= ( C458 +* (C459 , ( C457 . C459 )) ) by L1781 , L444;
end;
theorem
L1795: (for R4 being set holds (for R14 being Function holds (for B424 being R4 -defined Function holds R14 , ( R14 +* B424 ) equal_outside R4)))
proof
let R4 being set;
let R14 being Function;
let C461 being R4 -defined Function;
L1796: ( dom C461 ) c= R4;
thus L1797: thesis by L1796 , L438;
end;
theorem
L1798: (for R4 being set holds (for B425 , B426 being R4 -defined Function holds B425 , B426 equal_outside R4))
proof
let R4 being set;
let C462 , C463 being R4 -defined Function;
L1799: ( ( dom C463 ) \ R4 ) = ( {} ) by XBOOLE_1:37;
L1800: ( ( dom C462 ) \ R4 ) = ( {} ) by XBOOLE_1:37;
thus L1801: ( C462 | ( ( dom C462 ) \ R4 ) ) = ( {} ) by L1800
.= ( C463 | ( ( dom C463 ) \ R4 ) ) by L1799;
end;
theorem
L1802: (for R4 being set holds (for B427 , B428 being R4 -defined Function holds (for B429 being Function holds ( B429 +* B427 ) , ( B429 +* B428 ) equal_outside R4)))
proof
let R4 being set;
let C464 , C465 being R4 -defined Function;
let C466 being Function;
L1803: C466 , ( C466 +* C464 ) equal_outside R4 by L1795;
L1804: ( C466 +* C464 ) , C466 equal_outside R4 by L1803 , L429;
L1805: C466 , ( C466 +* C465 ) equal_outside R4 by L1795;
thus L1806: thesis by L1805 , L1804 , L432;
end;
theorem
L1807: (for R17 being (Element of ( NAT )) holds (for B430 being ( NAT ) -defined Function holds ( card ( Shift (B430 , R17) ) ) = ( card B430 )))
proof
let R17 being (Element of ( NAT ));
defpred S33[ set ] means (not contradiction);
deffunc H2((Element of ( NAT ))) = $1;
let C467 being ( NAT ) -defined Function;
L1808: (for B431 being set holds (B431 in ( dom C467 ) implies (ex B432 being (Element of ( NAT )) st B431 = H2(B432))));
defpred S34[ (Element of ( NAT )) ] means $1 in ( dom C467 );
deffunc H3((Element of ( NAT ))) = ( $1 + R17 );
set D111 = { R6 where R6 is (Element of ( NAT )) : H2(R6) in ( dom C467 ) };
set D112 = { H3(R6) where R6 is (Element of ( NAT )) : (R6 in { R32 where R32 is (Element of ( NAT )) : S34[ R32 ] } & S33[ R6 ]) };
set D113 = { H3(R6) where R6 is (Element of ( NAT )) : R6 in D111 };
set D114 = { ( R6 + R17 ) where R6 is (Element of ( NAT )) : R6 in ( dom C467 ) };
L1809: (for B433 , B434 being (Element of ( NAT )) holds (H2(B433) = H2(B434) implies B433 = B434));
L1810: ( dom C467 ) , D111 are_equipotent  from CardMono(L1808 , L1809);
L1811: D112 c= D114
proof
let C468 being set;
assume L1812: C468 in D112;
consider R6 being (Element of ( NAT )) such that L1813: C468 = H3(R6) and L1814: (R6 in { R32 where R32 is (Element of ( NAT )) : S34[ R32 ] } & S33[ R6 ]) by L1812;
L1815: (ex R32 being (Element of ( NAT )) st (R32 = R6 & S34[ R32 ])) by L1814;
thus L1816: thesis by L1815 , L1813;
end;
set D115 = { R6 where R6 is (Element of ( NAT )) : S34[ R6 ] };
L1817: D115 is (Subset of ( NAT )) from DOMAIN_1:sch 7;
L1818: D115 c= ( NAT ) by L1817;
set D116 = { R6 where R6 is (Element of ( NAT )) : R6 in ( dom C467 ) };
L1819: (for B435 , B436 being (Element of ( NAT )) holds (H3(B435) = H3(B436) implies B435 = B436));
L1820: D116 , D113 are_equipotent  from CardMono9(L1818 , L1819);
L1821: D114 c= D113
proof
let C469 being set;
assume L1822: C469 in D114;
consider R6 being (Element of ( NAT )) such that L1823: C469 = ( R6 + R17 ) and L1824: R6 in ( dom C467 ) by L1822;
L1825: R6 in D116 by L1824;
thus L1826: thesis by L1825 , L1823;
end;
L1827: ( dom ( Shift (C467 , R17) ) ) = D114 by VALUED_1:def 12;
L1828: D113 c= D112
proof
let C470 being set;
assume L1829: C470 in D113;
L1830: (ex R6 being (Element of ( NAT )) st (C470 = H3(R6) & R6 in D116)) by L1829;
thus L1831: thesis by L1830;
end;
L1832: D114 c= D112 by L1828 , L1821 , XBOOLE_1:1;
L1833: D112 = D114 by L1832 , L1811 , XBOOLE_0:def 10;
L1834: D112 = D113 by L1833 , L1821 , L1828 , XBOOLE_0:def 10;
L1835: ( dom ( Shift (C467 , R17) ) ) , ( dom C467 ) are_equipotent  by L1834 , L1810 , L1833 , L1820 , L1827 , WELLORD2:15;
thus L1836: ( card ( Shift (C467 , R17) ) ) = ( card ( dom ( Shift (C467 , R17) ) ) ) by CARD_1:62
.= ( card ( dom C467 ) ) by L1835 , CARD_1:5
.= ( card C467 ) by CARD_1:62;
end;
theorem
L1837: (for R4 being set holds (for R5 being set holds (for R14 being Function holds (for R15 being Function holds ((( dom R14 ) = ( dom R15 ) & ( dom R14 ) c= ( R4 \/ R5 ) & ( R14 | R5 ) = ( R15 | R5 )) implies R14 , R15 equal_outside R4)))))
proof
let R4 being set;
let R5 being set;
let R14 being Function;
let R15 being Function;
assume that
L1838: ( dom R14 ) = ( dom R15 )
and
L1839: ( dom R14 ) c= ( R4 \/ R5 );
assume L1840: ( R14 | R5 ) = ( R15 | R5 );
thus L1841: ( R14 | ( ( dom R14 ) \ R4 ) ) = ( R15 | ( ( dom R15 ) \ R4 ) ) by L1840 , L1838 , L1839 , RELAT_1:153 , XBOOLE_1:43;
end;
theorem
L1842: (for R4 being set holds (for R5 being set holds (for R14 being Function holds (for R15 being Function holds ((( dom R14 ) = ( dom R15 ) & R5 c= ( dom R14 ) & R4 misses R5 & R14 , R15 equal_outside R4) implies ( R14 | R5 ) = ( R15 | R5 ))))))
proof
let R4 being set;
let R5 being set;
let R14 being Function;
let R15 being Function;
assume that
L1843: ( dom R14 ) = ( dom R15 )
and
L1844: (R5 c= ( dom R14 ) & R4 misses R5);
assume L1845: ( R14 | ( ( dom R14 ) \ R4 ) ) = ( R15 | ( ( dom R15 ) \ R4 ) );
thus L1846: thesis by L1845 , L1843 , L1844 , RELAT_1:153 , XBOOLE_1:86;
end;
theorem
L1847: (for R33 being set holds (for R34 being set holds (for R35 being set holds (for R36 being (ManySortedSet of R35) holds (for R37 being (ManySortedSet of R35) holds ((R35 c= ( R33 \/ R34 ) & ( R36 | R34 ) = ( R37 | R34 )) implies R36 , R37 equal_outside R33))))))
proof
let R33 being set;
let R34 being set;
let R35 being set;
let R36 being (ManySortedSet of R35);
let R37 being (ManySortedSet of R35);
L1848: (( dom R36 ) = R35 & ( dom R37 ) = R35) by PARTFUN1:def 2;
thus L1849: thesis by L1848 , L1837;
end;
theorem
L1850: (for R33 being set holds (for R34 being set holds (for R35 being set holds (for R36 being (ManySortedSet of R35) holds (for R37 being (ManySortedSet of R35) holds ((R34 c= R35 & R33 misses R34 & R36 , R37 equal_outside R33) implies ( R36 | R34 ) = ( R37 | R34 )))))))
proof
let R33 being set;
let R34 being set;
let R35 being set;
let R36 being (ManySortedSet of R35);
let R37 being (ManySortedSet of R35);
L1851: (( dom R36 ) = R35 & ( dom R37 ) = R35) by PARTFUN1:def 2;
thus L1852: thesis by L1851 , L1842;
end;
registration
let C471 being non  empty set;
let C472 being C471 -valued Function;
let C473 being set;
let C474 being (Element of C471);
cluster ( C472 +* (C473 , C474) ) -> C471 -valued;
coherence
proof
L1853: ( rng ( C472 +* (C473 , C474) ) ) c= ( ( rng C472 ) \/ { C474 } ) by L1412;
thus L1854: ( rng ( C472 +* (C473 , C474) ) ) c= C471 by L1853 , XBOOLE_1:1;
end;
end;
theorem
L1856: (for R14 being Function holds (for R15 being Function holds (for R25 being set holds (for R26 being set holds ((R14 c= R15 & (not R25 in ( dom R14 ))) implies R14 c= ( R15 +* (R25 , R26) ))))))
proof
let R14 being Function;
let R15 being Function;
let R25 being set;
let R26 being set;
assume that
L1857: R14 c= R15;
assume L1858: (not R25 in ( dom R14 ));
L1859: R14 c= ( R14 +* ( R25 .--> R26 ) ) by L1858 , FUNCT_4:107;
per cases ;
suppose L1860: R25 in ( dom R15 );

L1861: ( R15 +* (R25 , R26) ) = ( R15 +* ( R25 .--> R26 ) ) by L1860 , L444;
L1862: ( R14 +* ( R25 .--> R26 ) ) c= ( R15 +* (R25 , R26) ) by L1861 , L1857 , FUNCT_4:123;
thus L1863: R14 c= ( R15 +* (R25 , R26) ) by L1862 , L1859 , XBOOLE_1:1;
end;
suppose L1864: (not R25 in ( dom R15 ));

thus L1865: R14 c= ( R15 +* (R25 , R26) ) by L1864 , L1857 , L444;
end;
end;
theorem
L1867: (for B437 being non  empty set holds (for B438 being (ManySortedSet of B437) holds (for B439 , B440 being (Element of B437) holds (for B441 , B442 being set holds ( B438 +* ( (B439 , B440) --> (B441 , B442) ) ) = ( ( B438 +* (B439 , B441) ) +* (B440 , B442) )))))
proof
let C475 being non  empty set;
let C476 being (ManySortedSet of C475);
let C477 , C478 being (Element of C475);
let C479 , C480 being set;
L1868: ( dom C476 ) = C475 by PARTFUN1:def 2;
L1869: C477 in ( dom C476 ) by L1868;
L1870: ( dom ( C476 +* (C477 , C479) ) ) = C475 by L1868 , L446;
L1871: C478 in ( dom ( C476 +* (C477 , C479) ) ) by L1870;
thus L1872: ( C476 +* ( (C477 , C478) --> (C479 , C480) ) ) = ( C476 +* ( ( C477 .--> C479 ) +* ( C478 .--> C480 ) ) )
.= ( ( C476 +* ( C477 .--> C479 ) ) +* ( C478 .--> C480 ) ) by FUNCT_4:14
.= ( ( C476 +* (C477 , C479) ) +* ( C478 .--> C480 ) ) by L1869 , L444
.= ( ( C476 +* (C477 , C479) ) +* (C478 , C480) ) by L1871 , L444;
end;
