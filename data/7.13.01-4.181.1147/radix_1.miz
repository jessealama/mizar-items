:: Definitions of Radix-2k Signed-Digit number and its adder algorithm
::  by Yoshinori Fujisawa and Yasushi Fuwa
::
:: Received September 7, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, INT_1, ARYTM_1, ARYTM_3, CARD_1, XXREAL_0,
      SUBSET_1, RELAT_1, NEWTON, POWER, TARSKI, XBOOLE_0, FINSEQ_2, FINSEQ_1,
      FUNCT_1, PARTFUN1, CARD_3, ORDINAL4, RADIX_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, ORDINAL1,
      NAT_D, FUNCT_1, PARTFUN1, NEWTON, POWER, FINSEQ_1, RVSUM_1, FINSEQ_2,
      GR_CY_1, XXREAL_0;
 constructors REAL_1, NAT_D, FINSOP_1, NEWTON, POWER, GR_CY_1, BINOP_2;
 registrations RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED,
      NEWTON, XBOOLE_0, VALUED_0, POWER, CARD_1, FINSEQ_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, RVSUM_1;
 theorems NAT_1, NAT_2, INT_1, FINSEQ_1, EULER_1, PREPOWER, POWER, RVSUM_1,
      FINSEQ_2, FINSEQ_4, TARSKI, FUNCT_1, PEPIN, FINSEQ_5, NEWTON, XCMPLX_1,
      XREAL_1, XXREAL_0, FINSOP_1, ORDINAL1, NAT_D, PARTFUN1, CARD_1, XREAL_0;
 schemes NAT_1, FINSEQ_2;

begin
theorem
L1: (for R1 being Nat holds (for R3 being Nat holds (( R3 mod R1 ) = ( R1 - 1 ) implies ( ( R3 + 1 ) mod R1 ) = ( 0 )))) by NAT_D:69;
theorem
L2: (for R1 being Nat holds (for R3 being Nat holds (( R3 mod R1 ) < ( R1 - 1 ) implies ( ( R3 + 1 ) mod R1 ) = ( ( R3 mod R1 ) + 1 )))) by NAT_D:70;
theorem
L3: (for R1 being Nat holds (for R2 being Nat holds (for R3 being Nat holds (R2 <> ( 0 ) implies ( ( R1 mod ( R2 * R3 ) ) mod R3 ) = ( R1 mod R3 )))))
proof
let R1 being Nat;
let R2 being Nat;
let R3 being Nat;
assume L4: R2 <> ( 0 );
per cases ;
suppose L5: R3 <> ( 0 );

reconsider D1 = R1 , D2 = R2 , D3 = R3 as Integer;
L6: ( D2 * D3 ) <> ( 0 ) by L4 , L5 , XCMPLX_1:6;
thus L7: ( ( R1 mod ( R2 * R3 ) ) mod R3 ) = ( ( D1 - ( ( D1 div ( D2 * D3 ) ) * ( D2 * D3 ) ) ) mod D3 ) by L6 , INT_1:def 10
.= ( ( D1 + ( ( - ( D2 * ( D1 div ( D2 * D3 ) ) ) ) * D3 ) ) mod D3 )
.= ( R1 mod R3 ) by EULER_1:12;
end;
suppose L8: R3 = ( 0 );

thus L9: ( ( R1 mod ( R2 * R3 ) ) mod R3 ) = ( 0 ) by L8 , NAT_D:def 2
.= ( R1 mod R3 ) by L8 , NAT_D:def 2;
end;
end;
theorem
L11: (for R1 being Nat holds (for R3 being Nat holds (R1 <> ( 0 ) implies (( ( R3 + 1 ) mod R1 ) = ( 0 ) or ( ( R3 + 1 ) mod R1 ) = ( ( R3 mod R1 ) + 1 )))))
proof
let R1 being Nat;
let R3 being Nat;
assume L12: R1 <> ( 0 );
L13: R1 >= 1 by L12 , NAT_1:14;
reconsider D4 = ( R1 - 1 ) as (Element of ( NAT )) by L13 , INT_1:3 , XREAL_1:48;
L14: ( R3 mod R1 ) < ( ( R1 - 1 ) + 1 ) by L12 , NAT_D:1;
L15: ( R3 mod R1 ) <= D4 by L14 , NAT_1:13;
per cases  by L15 , XXREAL_0:1;
suppose L16: ( R3 mod R1 ) < ( R1 - 1 );

thus L17: thesis by L16 , L2;
end;
suppose L18: ( R3 mod R1 ) = ( R1 - 1 );

thus L19: thesis by L18 , L1;
end;
end;
theorem
L21: (for R8 being Nat holds (for R9 being Nat holds (for R11 being Nat holds ((R8 <> ( 0 ) & R9 <> ( 0 )) implies ( ( R11 mod ( R8 |^ R9 ) ) div ( R8 |^ ( R9 -' 1 ) ) ) < R8))))
proof
let R8 being Nat;
let R9 being Nat;
let R11 being Nat;
assume that
L22: R8 <> ( 0 )
and
L23: R9 <> ( 0 );
L24: ( R11 mod ( R8 |^ R9 ) ) < ( R8 |^ R9 ) by L22 , NAT_D:1 , PREPOWER:6;
reconsider D5 = R11 , D6 = R8 , D7 = R9 as (Element of ( NAT )) by ORDINAL1:def 12;
set D8 = ( D6 |^ ( D7 -' 1 ) );
set D9 = ( D5 mod ( D6 |^ D7 ) );
L25: ( D6 |^ D7 ) = ( D6 * ( D6 |^ ( D7 -' 1 ) ) ) by L22 , L23 , PEPIN:26;
L26: ( D9 mod D8 ) = ( D5 mod D8 ) by L25 , L22 , L3
.= ( D5 - ( D8 * ( D5 div D8 ) ) ) by L22 , NEWTON:63 , PREPOWER:6;
L27: D9 = ( ( D8 * ( D9 div D8 ) ) + ( D5 - ( D8 * ( D5 div D8 ) ) ) ) by L26 , L22 , NAT_D:2 , PREPOWER:6;
L28: ( ( D8 * ( D9 div D8 ) ) + ( D5 - ( D8 * ( D5 div D8 ) ) ) ) < ( D6 * D8 ) by L27 , L22 , L23 , L24 , PEPIN:26;
L29: D8 <> ( 0 ) by L22 , PREPOWER:6;
L30: [\ ( D5 / D8 ) /] <= ( D5 / D8 ) by INT_1:def 6;
L31: (( D5 div D8 ) = [\ ( D5 / D8 ) /] & ( ( D9 div D8 ) + [\ ( D5 / D8 ) /] ) <= ( ( D9 div D8 ) + ( D5 / D8 ) )) by L30 , INT_1:def 9 , XREAL_1:6;
L32: ( ( ( D9 div D8 ) + [\ ( D5 / D8 ) /] ) - [\ ( D5 / D8 ) /] ) <= ( ( ( D9 div D8 ) + ( D5 / D8 ) ) - ( D5 div D8 ) ) by L31 , XREAL_1:9;
L33: D8 > ( 0 ) by L22 , PREPOWER:6;
L34: ( ( ( ( D8 * ( D9 div D8 ) ) + D5 ) - ( D8 * ( D5 div D8 ) ) ) / D8 ) < ( ( D6 * D8 ) / D8 ) by L33 , L28 , XREAL_1:74;
L35: ( ( ( ( D8 * ( D9 div D8 ) ) / D8 ) + ( D5 / D8 ) ) - ( ( D8 * ( D5 div D8 ) ) / D8 ) ) < ( ( D6 * D8 ) / D8 ) by L34 , XCMPLX_1:124;
L36: ( ( ( D9 div D8 ) + ( D5 / D8 ) ) - ( ( D8 * ( D5 div D8 ) ) / D8 ) ) < ( ( D6 * D8 ) / D8 ) by L35 , L29 , XCMPLX_1:89;
L37: ( ( ( D9 div D8 ) + ( D5 / D8 ) ) - ( D5 div D8 ) ) < ( ( D6 * D8 ) / D8 ) by L36 , L29 , XCMPLX_1:89;
L38: ( ( ( D9 div D8 ) + ( D5 / D8 ) ) - ( D5 div D8 ) ) < D6 by L37 , L29 , XCMPLX_1:89;
thus L39: thesis by L38 , L32 , XXREAL_0:2;
end;
canceled 1;
theorem
L40: (for R4 being Integer holds (for R5 being Integer holds (for R6 being Integer holds ((R5 > ( 0 ) & R6 >= ( 0 )) implies ( ( R4 mod ( R5 * R6 ) ) mod R6 ) = ( R4 mod R6 )))))
proof
let R4 being Integer;
let R5 being Integer;
let R6 being Integer;
assume that
L41: R5 > ( 0 )
and
L42: R6 >= ( 0 );
per cases  by L42;
suppose L43: R6 > ( 0 );

L44: ( R5 * R6 ) <> ( 0 ) by L43 , L41 , XCMPLX_1:6;
L45: ( ( R4 mod ( R5 * R6 ) ) mod R6 ) = ( ( R4 - ( ( R4 div ( R5 * R6 ) ) * ( R5 * R6 ) ) ) mod R6 ) by L44 , INT_1:def 10
.= ( ( R4 + ( ( - ( R5 * ( R4 div ( R5 * R6 ) ) ) ) * R6 ) ) mod R6 );
thus L46: thesis by L45 , EULER_1:12;
end;
suppose L47: R6 = ( 0 );

L48: ( ( R4 mod ( R5 * R6 ) ) mod R6 ) = ( 0 ) by L47 , INT_1:def 10;
thus L49: thesis by L48 , L47 , INT_1:def 10;
end;
end;
begin
definition
let C1 being Nat;
func Radix C1 -> (Element of ( NAT )) equals 
( 2 to_power C1 );
correctness by ORDINAL1:def 12;
end;
definition
let C2 being Nat;
func C2 -SD -> set equals 
{ B1 where B1 is (Element of ( INT )) : (B1 <= ( ( Radix C2 ) - 1 ) & B1 >= ( ( - ( Radix C2 ) ) + 1 )) };
correctness;
end;
L53: (for B2 being Nat holds (B2 >= 2 implies ( Radix B2 ) >= ( 2 + 2 )))
proof
defpred S1[ Nat ] means ( Radix $1 ) >= ( 2 + 2 );
let R9 being Nat;
L54: (for B3 being Nat holds ((B3 >= 2 & S1[ B3 ]) implies S1[ ( B3 + 1 ) ]))
proof
let C3 being Nat;
assume L55: C3 >= 2;
L56: ( Radix ( C3 + 1 ) ) = ( ( 2 to_power C3 ) * ( 2 to_power 1 ) ) by POWER:27
.= ( ( Radix C3 ) * 2 ) by POWER:25;
L57: ( Radix ( C3 + 1 ) ) >= ( Radix C3 ) by L56 , XREAL_1:155;
assume L58: ( Radix C3 ) >= ( 2 + 2 );
thus L59: thesis by L58 , L57 , XXREAL_0:2;
end;
L60: ( Radix 2 ) = ( 2 to_power ( 1 + 1 ) )
.= ( ( 2 to_power 1 ) * ( 2 to_power 1 ) ) by POWER:27
.= ( 2 * ( 2 to_power 1 ) ) by POWER:25
.= ( 2 * 2 ) by POWER:25;
L61: S1[ 2 ] by L60;
L62: (for B4 being Nat holds (B4 >= 2 implies S1[ B4 ])) from NAT_1:sch 8(L61 , L54);
thus L63: thesis by L62;
end;
theorem
L64: (for R7 being set holds (R7 in ( ( 0 ) -SD ) iff R7 = ( 0 )))
proof
let C4 being set;
L65: ( Radix ( 0 ) ) = 1 by POWER:24;
thus L66:now
assume L67: C4 in ( ( 0 ) -SD );
L68: (ex B5 being (Element of ( INT )) st (C4 = B5 & B5 <= ( 0 ) & B5 >= ( 0 ))) by L67 , L65;
thus L69: C4 = ( 0 ) by L68;
end;
assume L70: C4 = ( 0 );
L71: C4 is (Element of ( INT )) by L70 , INT_1:def 2;
thus L72: thesis by L71 , L65 , L70;
end;
theorem
L73: ( ( 0 ) -SD ) = { ( 0 ) } by L64 , TARSKI:def 1;
theorem
L74: (for R9 being Nat holds ( R9 -SD ) c= ( ( R9 + 1 ) -SD ))
proof
let R9 being Nat;
let C5 being set;
assume L75: C5 in ( R9 -SD );
consider C6 being (Element of ( INT )) such that L76: C5 = C6 and L77: C6 <= ( ( Radix R9 ) - 1 ) and L78: C6 >= ( ( - ( Radix R9 ) ) + 1 ) by L75;
L79: R9 < ( R9 + 1 ) by NAT_1:13;
L80: ( 2 to_power R9 ) < ( 2 to_power ( R9 + 1 ) ) by L79 , POWER:39;
L81: ( - ( Radix R9 ) ) > ( - ( Radix ( R9 + 1 ) ) ) by L80 , XREAL_1:24;
L82: ( ( - ( Radix R9 ) ) + 1 ) > ( ( - ( Radix ( R9 + 1 ) ) ) + 1 ) by L81 , XREAL_1:6;
L83: C6 >= ( ( - ( Radix ( R9 + 1 ) ) ) + 1 ) by L82 , L78 , XXREAL_0:2;
L84: ( ( Radix R9 ) - 1 ) < ( ( Radix ( R9 + 1 ) ) - 1 ) by L80 , XREAL_1:9;
L85: C6 <= ( ( Radix ( R9 + 1 ) ) - 1 ) by L84 , L77 , XXREAL_0:2;
thus L86: thesis by L85 , L76 , L83;
end;
theorem
L87: (for R7 being set holds (for R9 being Nat holds (R7 in ( R9 -SD ) implies R7 is Integer)))
proof
let R7 being set;
let R9 being Nat;
assume L88: R7 in ( R9 -SD );
L89: (ex B6 being (Element of ( INT )) st (R7 = B6 & B6 <= ( ( Radix R9 ) - 1 ) & B6 >= ( ( - ( Radix R9 ) ) + 1 ))) by L88;
thus L90: thesis by L89;
end;
theorem
L91: (for R9 being Nat holds ( R9 -SD ) c= ( INT ))
proof
let R9 being Nat;
let C7 being set;
assume L92: C7 in ( R9 -SD );
L93: C7 is Integer by L92 , L87;
thus L94: thesis by L93 , INT_1:def 2;
end;
theorem
L95: (for R4 being Integer holds (for R9 being Nat holds (R4 in ( R9 -SD ) implies (R4 <= ( ( Radix R9 ) - 1 ) & R4 >= ( ( - ( Radix R9 ) ) + 1 )))))
proof
let R4 being Integer;
let R9 being Nat;
assume L96: R4 in ( R9 -SD );
L97: (ex B7 being (Element of ( INT )) st (B7 = R4 & B7 <= ( ( Radix R9 ) - 1 ) & B7 >= ( ( - ( Radix R9 ) ) + 1 ))) by L96;
thus L98: thesis by L97;
end;
theorem
L99: (for R9 being Nat holds ( 0 ) in ( R9 -SD ))
proof
let R9 being Nat;
defpred S2[ Nat ] means ( 0 ) in ( $1 -SD );
L100: (for B8 being Nat holds (S2[ B8 ] implies S2[ ( B8 + 1 ) ]))
proof
let C8 being Nat;
assume L101: ( 0 ) in ( C8 -SD );
L102: ( C8 -SD ) c= ( ( C8 + 1 ) -SD ) by L74;
thus L103: thesis by L102 , L101;
end;
L104: S2[ ( 0 ) ] by L64;
L105: (for B9 being Nat holds S2[ B9 ]) from NAT_1:sch 2(L104 , L100);
thus L106: thesis by L105;
end;
registration
let C9 being Nat;
cluster ( C9 -SD ) -> non  empty;
coherence by L99;
end;
definition
let C10 being Nat;
redefine func C10 -SD -> non  empty (Subset of ( INT ));

coherence by L91;
end;
begin
theorem
L109: (for R8 being Nat holds (for R9 being Nat holds (for R11 being Nat holds (for R15 being (Tuple of R11 , ( R9 -SD )) holds (R8 in ( Seg R11 ) implies ( R15 . R8 ) is (Element of ( R9 -SD )))))))
proof
let R8 being Nat;
let R9 being Nat;
let R11 being Nat;
let R15 being (Tuple of R11 , ( R9 -SD ));
L110: ( len R15 ) = R11 by CARD_1:def 7;
assume L111: R8 in ( Seg R11 );
L112: R8 in ( dom R15 ) by L111 , L110 , FINSEQ_1:def 3;
L113: ( R15 . R8 ) in ( rng R15 ) by L112 , FUNCT_1:def 3;
L114: ( rng R15 ) c= ( R9 -SD ) by FINSEQ_1:def 4;
thus L115: thesis by L114 , L113;
end;
definition
let C11 , C12 , C13 being Nat;
let C14 being (Tuple of C13 , ( C12 -SD ));
func DigA (C14 , C11) -> Integer equals 
:L116: ( C14 . C11 ) if C11 in ( Seg C13 ) , ( 0 ) if C11 = ( 0 );
coherence by INT_1:def 2;
consistency by FINSEQ_1:1;
end;
definition
let C15 , C16 , C17 being Nat;
let C18 being (Tuple of C17 , ( C16 -SD ));
func DigB (C18 , C15) -> (Element of ( INT )) equals 
( DigA (C18 , C15) );
coherence by INT_1:def 2;
end;
theorem
L119: (for R8 being Nat holds (for R9 being Nat holds (for R11 being Nat holds (for R15 being (Tuple of R11 , ( R9 -SD )) holds (R8 in ( Seg R11 ) implies ( DigA (R15 , R8) ) is (Element of ( R9 -SD )))))))
proof
let R8 being Nat;
let R9 being Nat;
let R11 being Nat;
let R15 being (Tuple of R11 , ( R9 -SD ));
assume L120: R8 in ( Seg R11 );
L121: ( R15 . R8 ) = ( DigA (R15 , R8) ) by L120 , L116;
thus L122: thesis by L121 , L120 , L109;
end;
theorem
L123: (for R10 being Nat holds (for B10 being (Tuple of 1 , ( INT )) holds (( B10 /. 1 ) = R10 implies B10 = <* R10 *>)))
proof
let R10 being Nat;
let C19 being (Tuple of 1 , ( INT ));
assume L124: ( C19 /. 1 ) = R10;
L125: ( len C19 ) = 1 by CARD_1:def 7;
L126: ( C19 /. 1 ) = ( C19 . 1 ) by L125 , FINSEQ_4:15;
thus L127: thesis by L126 , L124 , L125 , FINSEQ_1:40;
end;
definition
let C20 , C21 , C22 being Nat;
let C23 being (Tuple of C22 , ( C21 -SD ));
func SubDigit (C23 , C20 , C21) -> (Element of ( INT )) equals 
( ( ( Radix C21 ) |^ ( C20 -' 1 ) ) * ( DigB (C23 , C20) ) );
coherence by INT_1:def 2;
end;
definition
let C24 , C25 being Nat;
let C26 being (Tuple of C24 , ( C25 -SD ));
func DigitSD C26 -> (Tuple of C24 , ( INT )) means 
:L129: (for B11 being Nat holds (B11 in ( Seg C24 ) implies ( it /. B11 ) = ( SubDigit (C26 , B11 , C25) )));
existence
proof
deffunc H1(Nat) = ( SubDigit (C26 , $1 , C25) );
consider C27 being (FinSequence of ( INT )) such that L130: ( len C27 ) = C24 and L131: (for B12 being Nat holds (B12 in ( dom C27 ) implies ( C27 . B12 ) = H1(B12))) from FINSEQ_2:sch 1;
L132: ( dom C27 ) = ( Seg C24 ) by L130 , FINSEQ_1:def 3;
reconsider D10 = C27 as (Tuple of C24 , ( INT )) by L130 , CARD_1:def 7;
take D10;
let C28 being Nat;
assume L133: C28 in ( Seg C24 );
L134: C28 in ( dom D10 ) by L133 , L130 , FINSEQ_1:def 3;
thus L135: ( D10 /. C28 ) = ( D10 . C28 ) by L134 , PARTFUN1:def 6
.= ( SubDigit (C26 , C28 , C25) ) by L131 , L132 , L133;
end;
uniqueness
proof
let C29 , C30 being (Tuple of C24 , ( INT ));
assume that
L136: (for B13 being Nat holds (B13 in ( Seg C24 ) implies ( C29 /. B13 ) = ( SubDigit (C26 , B13 , C25) )))
and
L137: (for B14 being Nat holds (B14 in ( Seg C24 ) implies ( C30 /. B14 ) = ( SubDigit (C26 , B14 , C25) )));
L138: ( len C29 ) = C24 by CARD_1:def 7;
L139: ( dom C29 ) = ( Seg C24 ) by L138 , FINSEQ_1:def 3;
L140: ( len C30 ) = C24 by CARD_1:def 7;
L141:
now
let C31 being Nat;
assume L142: C31 in ( dom C29 );
L143: C31 in ( dom C30 ) by L142 , L140 , L139 , FINSEQ_1:def 3;
L144: ( C29 . C31 ) = ( C29 /. C31 ) by L142 , PARTFUN1:def 6
.= ( SubDigit (C26 , C31 , C25) ) by L136 , L139 , L142
.= ( C30 /. C31 ) by L137 , L139 , L142
.= ( C30 . C31 ) by L143 , PARTFUN1:def 6;
thus L145: ( C29 . C31 ) = ( C30 . C31 ) by L144;
end;
thus L146: thesis by L141 , L138 , L140 , FINSEQ_2:9;
end;
end;
definition
let C32 , C33 being Nat;
let C34 being (Tuple of C32 , ( C33 -SD ));
func SDDec C34 -> Integer equals 
( Sum ( DigitSD C34 ) );
coherence;
end;
definition
let C35 , C36 , C37 being Nat;
func DigitDC (C37 , C35 , C36) -> (Element of ( C36 -SD )) equals 
( ( C37 mod ( ( Radix C36 ) |^ C35 ) ) div ( ( Radix C36 ) |^ ( C35 -' 1 ) ) );
coherence
proof
reconsider D11 = C35 , D12 = C36 as (Element of ( NAT )) by ORDINAL1:def 12;
set D13 = ( ( Radix D12 ) |^ D11 );
set D14 = ( ( Radix D12 ) |^ ( D11 -' 1 ) );
defpred S3[ Nat ] means ( ( $1 mod D13 ) div D14 ) is (Element of ( D12 -SD ));
L149: ( 0 ) in ( D12 -SD ) by L99;
L150: ( Radix D12 ) <> ( 0 ) by POWER:34;
L151: D14 > ( 0 ) by L150 , NAT_1:14 , PREPOWER:11;
L152: ( ( 0 ) div D14 ) = ( 0 ) by L151 , NAT_D:27;
L153: ( Radix D12 ) >= 1 by L150 , NAT_1:14;
L154: (for B15 being Nat holds (S3[ B15 ] implies S3[ ( B15 + 1 ) ]))
proof
reconsider D15 = ( ( Radix D12 ) - 1 ) as (Element of ( NAT )) by L153 , INT_1:3 , XREAL_1:48;
let C38 being Nat;
assume L155: ( ( C38 mod D13 ) div D14 ) is (Element of ( D12 -SD ));
set D16 = ( ( ( C38 + 1 ) mod D13 ) div D14 );
per cases ;
suppose L156: D11 = ( 0 );

L157: ( ( Radix D12 ) |^ D11 ) = ( ( Radix D12 ) to_power D11 )
.= 1 by L156 , POWER:24;
L158: ( ( C38 + 1 ) mod D13 ) = ( ( ( C38 + 1 ) * 1 ) mod 1 ) by L157
.= ( 0 ) by NAT_D:13;
L159: D16 = ( 0 ) by L158 , L151 , NAT_D:27;
thus L160: thesis by L159 , L99;
end;
suppose L161: D11 > ( 0 );

L162: ( - 1 ) >= ( - ( Radix D12 ) ) by L153 , XREAL_1:24;
L163: (D16 is (Element of ( INT )) & ( 0 ) >= ( ( - ( Radix D12 ) ) + 1 )) by L162 , INT_1:def 2 , XREAL_1:59;
L164: D16 < ( ( ( Radix D12 ) - 1 ) + 1 ) by L150 , L161 , L21;
L165: D16 <= D15 by L164 , NAT_1:13;
L166: D16 in ( D12 -SD ) by L165 , L163;
thus L167: thesis by L166;
end;
end;
L169: D13 > ( 0 ) by L150 , NAT_1:14 , PREPOWER:11;
L170: S3[ ( 0 ) ] by L169 , L152 , L149 , NAT_D:24;
L171: (for B16 being Nat holds S3[ B16 ]) from NAT_1:sch 2(L170 , L154);
thus L172: thesis by L171;
end;
end;
definition
let C39 , C40 , C41 being Nat;
func DecSD (C41 , C40 , C39) -> (Tuple of C40 , ( C39 -SD )) means 
:L174: (for B17 being Nat holds (B17 in ( Seg C40 ) implies ( DigA (it , B17) ) = ( DigitDC (C41 , B17 , C39) )));
existence
proof
deffunc H2(Nat) = ( DigitDC (C41 , $1 , C39) );
consider C42 being (FinSequence of ( C39 -SD )) such that L175: ( len C42 ) = C40 and L176: (for B18 being Nat holds (B18 in ( dom C42 ) implies ( C42 . B18 ) = H2(B18))) from FINSEQ_2:sch 1;
L177: ( dom C42 ) = ( Seg C40 ) by L175 , FINSEQ_1:def 3;
reconsider D17 = C42 as (Tuple of C40 , ( C39 -SD )) by L175 , CARD_1:def 7;
take D17;
let R8 being Nat;
assume L178: R8 in ( Seg C40 );
thus L179: ( DigA (D17 , R8) ) = ( D17 . R8 ) by L178 , L116
.= ( DigitDC (C41 , R8 , C39) ) by L176 , L177 , L178;
end;
uniqueness
proof
let C43 , C44 being (Tuple of C40 , ( C39 -SD ));
assume that
L180: (for B19 being Nat holds (B19 in ( Seg C40 ) implies ( DigA (C43 , B19) ) = ( DigitDC (C41 , B19 , C39) )))
and
L181: (for B20 being Nat holds (B20 in ( Seg C40 ) implies ( DigA (C44 , B20) ) = ( DigitDC (C41 , B20 , C39) )));
L182: ( len C43 ) = C40 by CARD_1:def 7;
L183: ( dom C43 ) = ( Seg C40 ) by L182 , FINSEQ_1:def 3;
L184:
now
let C45 being Nat;
assume L185: C45 in ( dom C43 );
L186: ( C43 . C45 ) = ( DigA (C43 , C45) ) by L185 , L183 , L116
.= ( DigitDC (C41 , C45 , C39) ) by L180 , L183 , L185
.= ( DigA (C44 , C45) ) by L181 , L183 , L185
.= ( C44 . C45 ) by L183 , L185 , L116;
thus L187: ( C43 . C45 ) = ( C44 . C45 ) by L186;
end;
L188: ( len C44 ) = C40 by CARD_1:def 7;
thus L189: thesis by L188 , L182 , L184 , FINSEQ_2:9;
end;
end;
begin
definition
let C46 being Integer;
func SD_Add_Carry C46 -> Integer equals 
:L191: 1 if C46 > 2 , ( - 1 ) if C46 < ( - 2 ) otherwise ( 0 );
coherence;
consistency;
end;
theorem
L193: ( SD_Add_Carry ( 0 ) ) = ( 0 ) by L191;
L194: (for B21 being Integer holds (( - 1 ) <= ( SD_Add_Carry B21 ) & ( SD_Add_Carry B21 ) <= 1))
proof
let C47 being Integer;
per cases ;
suppose L195: C47 < ( - 2 );

thus L196: thesis by L195 , L191;
end;
suppose L197: (( - 2 ) <= C47 & C47 <= 2);

thus L198: thesis by L197 , L191;
end;
suppose L199: C47 > 2;

thus L200: thesis by L199 , L191;
end;
end;
definition
let C48 being Integer;
let C49 being Nat;
func SD_Add_Data (C48 , C49) -> Integer equals 
( C48 - ( ( SD_Add_Carry C48 ) * ( Radix C49 ) ) );
coherence;
end;
theorem
L203: (for R9 being Nat holds ( SD_Add_Data (( 0 ) , R9) ) = ( 0 )) by L193;
theorem
L204: (for R4 being Integer holds (for R5 being Integer holds (for R9 being Nat holds ((R9 >= 2 & R4 in ( R9 -SD ) & R5 in ( R9 -SD )) implies (( ( - ( Radix R9 ) ) + 2 ) <= ( SD_Add_Data (( R4 + R5 ) , R9) ) & ( SD_Add_Data (( R4 + R5 ) , R9) ) <= ( ( Radix R9 ) - 2 ))))))
proof
let R4 being Integer;
let R5 being Integer;
let R9 being Nat;
assume that
L205: R9 >= 2
and
L206: (R4 in ( R9 -SD ) & R5 in ( R9 -SD ));
L207: (( ( - ( Radix R9 ) ) + 1 ) <= R4 & ( ( - ( Radix R9 ) ) + 1 ) <= R5) by L206 , L95;
set D18 = ( R4 + R5 );
L208: (R4 <= ( ( Radix R9 ) - 1 ) & R5 <= ( ( Radix R9 ) - 1 )) by L206 , L95;
L209: D18 <= ( ( ( Radix R9 ) - 1 ) + ( ( Radix R9 ) - 1 ) ) by L208 , XREAL_1:7;
per cases ;
suppose L210: D18 < ( - 2 );

L211: ( ( ( - ( Radix R9 ) ) + 1 ) + ( 1 + ( - ( Radix R9 ) ) ) ) <= D18 by L207 , XREAL_1:7;
L212: ( ( ( - ( Radix R9 ) ) + ( 1 + 1 ) ) - ( Radix R9 ) ) <= D18 by L211;
L213: (( SD_Add_Carry D18 ) = ( - 1 ) & ( D18 + ( Radix R9 ) ) < ( ( - 2 ) + ( Radix R9 ) )) by L210 , L191 , XREAL_1:6;
thus L214: thesis by L213 , L212 , XREAL_1:20;
end;
suppose L215: (( - 2 ) <= D18 & D18 <= 2);

L216: ( Radix R9 ) >= ( 2 + 2 ) by L205 , L53;
L217: ( ( Radix R9 ) - 2 ) >= 2 by L216 , XREAL_1:19;
L218: ( - ( Radix R9 ) ) <= ( - ( 2 + 2 ) ) by L216 , XREAL_1:24;
L219: ( - ( Radix R9 ) ) <= ( ( - 2 ) + ( - 2 ) ) by L218;
L220: ( ( - ( Radix R9 ) ) - ( - 2 ) ) <= ( - 2 ) by L219 , XREAL_1:20;
L221: ( SD_Add_Carry D18 ) = ( 0 ) by L215 , L191;
thus L222: thesis by L221 , L215 , L217 , L220 , XXREAL_0:2;
end;
suppose L223: D18 > 2;

L224: D18 <= ( ( ( ( Radix R9 ) - 1 ) - 1 ) + ( Radix R9 ) ) by L209;
L225: (( SD_Add_Carry D18 ) = 1 & ( D18 - ( Radix R9 ) ) > ( 2 - ( Radix R9 ) )) by L223 , L191 , XREAL_1:9;
thus L226: thesis by L225 , L224 , XREAL_1:20;
end;
end;
begin
definition
let C50 , C51 , C52 being Nat;
pred C51 is_represented_by C50 , C52
means
:L228: C51 < ( ( Radix C52 ) |^ C50 )
;end;
theorem
L230: (for R9 being Nat holds (for R10 being Nat holds (R10 is_represented_by 1 , R9 implies ( DigA (( DecSD (R10 , 1 , R9) ) , 1) ) = R10)))
proof
let R9 being Nat;
let R10 being Nat;
assume L231: R10 is_represented_by 1 , R9;
L232: R10 < ( ( Radix R9 ) |^ 1 ) by L231 , L228;
L233: 1 in ( Seg 1 ) by FINSEQ_1:1;
thus L234: ( DigA (( DecSD (R10 , 1 , R9) ) , 1) ) = ( DigitDC (R10 , 1 , R9) ) by L233 , L174
.= ( ( R10 mod ( ( Radix R9 ) |^ 1 ) ) div ( ( Radix R9 ) |^ ( 0 ) ) ) by XREAL_1:232
.= ( ( R10 mod ( ( Radix R9 ) |^ 1 ) ) div 1 ) by NEWTON:4
.= ( R10 mod ( ( Radix R9 ) |^ 1 ) ) by NAT_2:4
.= R10 by L232 , NAT_D:24;
end;
theorem
L235: (for R9 being Nat holds (for R11 being Nat holds (R11 >= 1 implies (for R10 being Nat holds (R10 is_represented_by R11 , R9 implies R10 = ( SDDec ( DecSD (R10 , R11 , R9) ) ))))))
proof
let R9 being Nat;
let R11 being Nat;
defpred S4[ Nat ] means (for R10 being Nat holds (R10 is_represented_by $1 , R9 implies R10 = ( SDDec ( DecSD (R10 , $1 , R9) ) )));
L236: (for B22 being Nat holds ((B22 >= 1 & S4[ B22 ]) implies S4[ ( B22 + 1 ) ]))
proof
let C53 being Nat;
assume that
L237: C53 >= 1
and
L238: S4[ C53 ];
L239: (for R12 being Nat holds (R12 is_represented_by ( C53 + 1 ) , R9 implies R12 = ( SDDec ( DecSD (R12 , ( C53 + 1 ) , R9) ) )))
proof
let R12 being Nat;
set D19 = ( C53 + 1 );
set D20 = ( ( Radix R9 ) |^ C53 );
set D21 = ( R12 mod D20 );
set D22 = ( D20 * ( R12 div D20 ) );
L240: ( D19 -' 1 ) = C53 by NAT_D:34;
L241: ( C53 + 1 ) <= ( len ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) ) ) by CARD_1:def 7;
L242: 1 <= ( C53 + 1 ) by NAT_1:12;
L243: ( C53 + 1 ) in ( Seg ( C53 + 1 ) ) by L242 , FINSEQ_1:1;
assume L244: R12 is_represented_by ( C53 + 1 ) , R9;
L245: R12 < ( ( Radix R9 ) |^ ( C53 + 1 ) ) by L244 , L228;
L246: ( R12 div D20 ) = ( DigitDC (R12 , ( C53 + 1 ) , R9) ) by L245 , L240 , NAT_D:24;
L247: D22 = ( SubDigit (( DecSD (R12 , ( C53 + 1 ) , R9) ) , ( C53 + 1 ) , R9) ) by L246 , L240 , L243 , L174
.= ( ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) ) /. ( C53 + 1 ) ) by L243 , L129
.= ( ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) ) . ( C53 + 1 ) ) by L241 , FINSEQ_4:15 , NAT_1:12;
L248: ( ( DigitSD ( DecSD (D21 , C53 , R9) ) ) ^ <* D22 *> ) = ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) )
proof
L249: D22 is (Element of ( INT )) by INT_1:def 2;
reconsider D23 = <* D22 *> as (FinSequence of ( INT )) by L249 , FINSEQ_1:74;
reconsider D24 = ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) ) as (FinSequence of ( INT ));
set D25 = ( DigitSD ( DecSD (D21 , C53 , R9) ) );
reconsider D26 = ( D25 ^ D23 ) as (FinSequence of ( INT ));
L250: ( len D26 ) = ( ( len ( DigitSD ( DecSD (D21 , C53 , R9) ) ) ) + ( len <* D22 *> ) ) by FINSEQ_1:22
.= ( C53 + ( len <* D22 *> ) ) by CARD_1:def 7
.= ( C53 + 1 ) by FINSEQ_1:39;
L251: (for B23 being Nat holds ((1 <= B23 & B23 <= ( len D26 )) implies ( D26 /. B23 ) = ( D24 /. B23 )))
proof
let C54 being Nat;
assume L252: (1 <= C54 & C54 <= ( len D26 ));
L253: C54 in ( Seg ( C53 + 1 ) ) by L252 , L250 , FINSEQ_1:1;
per cases  by L253 , FINSEQ_2:7;
suppose L254: C54 in ( Seg C53 );

L255: ( D21 mod ( ( Radix R9 ) |^ C54 ) ) = ( R12 mod ( ( Radix R9 ) |^ C54 ) )
proof
L256: C54 <= C53 by L254 , FINSEQ_1:1;
L257: ( ( Radix R9 ) |^ C54 ) divides ( ( Radix R9 ) |^ C53 ) by L256 , NEWTON:89;
consider C55 being Nat such that L258: ( ( Radix R9 ) |^ C53 ) = ( ( ( Radix R9 ) |^ C54 ) * C55 ) by L257 , NAT_D:def 3;
L259: ( Radix R9 ) <> ( 0 ) by POWER:34;
L260: C55 <> ( 0 ) by L259 , L258 , PREPOWER:5;
thus L261: thesis by L260 , L258 , L3;
end;
L262: C54 in ( dom ( D25 ^ D23 ) ) by L250 , L253 , FINSEQ_1:def 3;
L263: ( len D24 ) = ( C53 + 1 ) by CARD_1:def 7;
L264: C54 in ( dom D24 ) by L263 , L253 , FINSEQ_1:def 3;
L265: ( D24 . C54 ) = ( D24 /. C54 ) by L264 , PARTFUN1:def 6;
L266: ( D24 . C54 ) = ( ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) ) /. C54 ) by L264 , PARTFUN1:def 6
.= ( SubDigit (( DecSD (R12 , ( C53 + 1 ) , R9) ) , C54 , R9) ) by L253 , L129
.= ( ( ( Radix R9 ) |^ ( C54 -' 1 ) ) * ( DigitDC (R12 , C54 , R9) ) ) by L253 , L174
.= ( ( ( Radix R9 ) |^ ( C54 -' 1 ) ) * ( ( R12 mod ( ( Radix R9 ) |^ C54 ) ) div ( ( Radix R9 ) |^ ( C54 -' 1 ) ) ) );
L267: ( len D25 ) = C53 by CARD_1:def 7;
L268: C54 in ( dom D25 ) by L267 , L254 , FINSEQ_1:def 3;
L269: ( ( D25 ^ D23 ) . C54 ) = ( ( DigitSD ( DecSD (D21 , C53 , R9) ) ) . C54 ) by L268 , FINSEQ_1:def 7
.= ( ( DigitSD ( DecSD (D21 , C53 , R9) ) ) /. C54 ) by L268 , PARTFUN1:def 6
.= ( SubDigit (( DecSD (D21 , C53 , R9) ) , C54 , R9) ) by L254 , L129
.= ( ( ( Radix R9 ) |^ ( C54 -' 1 ) ) * ( DigitDC (D21 , C54 , R9) ) ) by L254 , L174
.= ( ( ( Radix R9 ) |^ ( C54 -' 1 ) ) * ( ( R12 mod ( ( Radix R9 ) |^ C54 ) ) div ( ( Radix R9 ) |^ ( C54 -' 1 ) ) ) ) by L255;
thus L270: thesis by L269 , L266 , L265 , L262 , PARTFUN1:def 6;
end;
suppose L271: C54 = ( C53 + 1 );

thus L272: ( D26 /. C54 ) = ( D26 . ( C53 + 1 ) ) by L271 , L242 , L250 , FINSEQ_4:15
.= ( ( D25 ^ D23 ) . ( ( len D25 ) + 1 ) ) by CARD_1:def 7
.= ( ( DigitSD ( DecSD (R12 , ( C53 + 1 ) , R9) ) ) . ( C53 + 1 ) ) by L247 , FINSEQ_1:42
.= ( D24 /. C54 ) by L241 , L271 , FINSEQ_4:15 , NAT_1:12;
end;
end;
L274: ( len D24 ) = ( C53 + 1 ) by CARD_1:def 7;
thus L275: thesis by L274 , L250 , L251 , FINSEQ_5:13;
end;
L276: ( Radix R9 ) <> ( 0 ) by POWER:34;
L277: D20 <> ( 0 ) by L276 , PREPOWER:5;
L278: D21 < D20 by L277 , NAT_D:1;
L279: D21 is_represented_by C53 , R9 by L278 , L228;
L280: R12 = ( ( D20 * ( R12 div D20 ) ) + ( R12 mod D20 ) ) by L277 , NAT_D:2;
L281: R12 = ( ( SDDec ( DecSD (D21 , C53 , R9) ) ) + D22 ) by L280 , L238 , L279;
thus L282: thesis by L281 , L248 , RVSUM_1:74;
end;
thus L283: thesis by L239;
end;
L284: S4[ 1 ]
proof
let R10 being Nat;
assume L285: R10 is_represented_by 1 , R9;
reconsider D27 = R10 as (Element of ( REAL )) by XREAL_0:def 1;
reconsider D28 = <* D27 *> as (FinSequence of ( REAL ));
L286: 1 in ( Seg 1 ) by FINSEQ_1:1;
L287: ( SubDigit (( DecSD (R10 , 1 , R9) ) , 1 , R9) ) = ( ( ( Radix R9 ) |^ ( 0 ) ) * ( DigB (( DecSD (R10 , 1 , R9) ) , 1) ) ) by XREAL_1:232
.= ( 1 * ( DigB (( DecSD (R10 , 1 , R9) ) , 1) ) ) by NEWTON:4
.= R10 by L285 , L230;
L288: ( ( DigitSD ( DecSD (R10 , 1 , R9) ) ) /. 1 ) = R10 by L287 , L286 , L129;
thus L289: ( SDDec ( DecSD (R10 , 1 , R9) ) ) = ( Sum D28 ) by L288 , L123
.= R10 by FINSOP_1:11;
end;
L290: (for B24 being Nat holds (B24 >= 1 implies S4[ B24 ])) from NAT_1:sch 8(L284 , L236);
thus L291: thesis by L290;
end;
theorem
L292: (for R9 being Nat holds (for R10 being Nat holds (for R11 being Nat holds ((R10 is_represented_by 1 , R9 & R11 is_represented_by 1 , R9) implies ( SD_Add_Carry ( ( DigA (( DecSD (R10 , 1 , R9) ) , 1) ) + ( DigA (( DecSD (R11 , 1 , R9) ) , 1) ) ) ) = ( SD_Add_Carry ( R10 + R11 ) )))))
proof
let R9 being Nat;
let R10 being Nat;
let R11 being Nat;
assume that
L293: R10 is_represented_by 1 , R9
and
L294: R11 is_represented_by 1 , R9;
L295: ( SD_Add_Carry ( ( DigA (( DecSD (R10 , 1 , R9) ) , 1) ) + ( DigA (( DecSD (R11 , 1 , R9) ) , 1) ) ) ) = ( SD_Add_Carry ( R10 + ( DigA (( DecSD (R11 , 1 , R9) ) , 1) ) ) ) by L293 , L230
.= ( SD_Add_Carry ( R10 + R11 ) ) by L294 , L230;
thus L296: thesis by L295;
end;
L297: (for R9 being Nat holds (for R10 being Nat holds (for R11 being Nat holds (for R8 being Nat holds (R8 in ( Seg R11 ) implies ( DigA (( DecSD (R10 , ( R11 + 1 ) , R9) ) , R8) ) = ( DigA (( DecSD (( R10 mod ( ( Radix R9 ) |^ R11 ) ) , R11 , R9) ) , R8) ))))))
proof
let R9 being Nat;
let R10 being Nat;
let R11 being Nat;
let R8 being Nat;
assume L298: R8 in ( Seg R11 );
L299: R8 <= R11 by L298 , FINSEQ_1:1;
L300: R8 <= ( R11 + 1 ) by L299 , NAT_1:12;
L301: 1 <= R8 by L298 , FINSEQ_1:1;
L302: R8 in ( Seg ( R11 + 1 ) ) by L301 , L300 , FINSEQ_1:1;
L303: ( ( Radix R9 ) |^ R8 ) divides ( ( Radix R9 ) |^ R11 ) by L299 , NEWTON:89;
consider C56 being Nat such that L304: ( ( Radix R9 ) |^ R11 ) = ( ( ( Radix R9 ) |^ R8 ) * C56 ) by L303 , NAT_D:def 3;
L305: ( Radix R9 ) <> ( 0 ) by POWER:34;
L306: C56 <> ( 0 ) by L305 , L304 , PREPOWER:5;
L307: ( DigA (( DecSD (( R10 mod ( ( Radix R9 ) |^ R11 ) ) , R11 , R9) ) , R8) ) = ( DigitDC (( R10 mod ( ( Radix R9 ) |^ R11 ) ) , R8 , R9) ) by L298 , L174
.= ( DigitDC (R10 , R8 , R9) ) by L304 , L306 , L3
.= ( DigA (( DecSD (R10 , ( R11 + 1 ) , R9) ) , R8) ) by L302 , L174;
thus L308: thesis by L307;
end;
theorem
L309: (for R9 being Nat holds (for R10 being Nat holds (for R11 being Nat holds (R10 is_represented_by ( R11 + 1 ) , R9 implies ( DigA (( DecSD (R10 , ( R11 + 1 ) , R9) ) , ( R11 + 1 )) ) = ( R10 div ( ( Radix R9 ) |^ R11 ) )))))
proof
let R9 being Nat;
let R10 being Nat;
let R11 being Nat;
assume L310: R10 is_represented_by ( R11 + 1 ) , R9;
L311: R10 < ( ( Radix R9 ) |^ ( R11 + 1 ) ) by L310 , L228;
L312: ( R11 + 1 ) in ( Seg ( R11 + 1 ) ) by FINSEQ_1:3;
L313: ( DigA (( DecSD (R10 , ( R11 + 1 ) , R9) ) , ( R11 + 1 )) ) = ( DigitDC (R10 , ( R11 + 1 ) , R9) ) by L312 , L174
.= ( R10 div ( ( Radix R9 ) |^ ( ( R11 + 1 ) -' 1 ) ) ) by L311 , NAT_D:24
.= ( R10 div ( ( Radix R9 ) |^ R11 ) ) by NAT_D:34;
thus L314: thesis by L313;
end;
begin
definition
let C57 , C58 , C59 being Nat;
let C60 , C61 being (Tuple of C59 , ( C57 -SD ));
assume that
L315: C58 in ( Seg C59 )
and
L316: C57 >= 2;
func Add (C60 , C61 , C58 , C57) -> (Element of ( C57 -SD )) equals 
:L317: ( ( SD_Add_Data (( ( DigA (C60 , C58) ) + ( DigA (C61 , C58) ) ) , C57) ) + ( SD_Add_Carry ( ( DigA (C60 , ( C58 -' 1 )) ) + ( DigA (C61 , ( C58 -' 1 )) ) ) ) );
coherence
proof
set D29 = ( SD_Add_Carry ( ( DigA (C60 , ( C58 -' 1 )) ) + ( DigA (C61 , ( C58 -' 1 )) ) ) );
set D30 = ( SD_Add_Data (( ( DigA (C60 , C58) ) + ( DigA (C61 , C58) ) ) , C57) );
L318: ( - 1 ) <= D29 by L194;
L319: D29 <= 1 by L194;
L320: (( DigA (C60 , C58) ) is (Element of ( C57 -SD )) & ( DigA (C61 , C58) ) is (Element of ( C57 -SD ))) by L315 , L119;
L321: D30 <= ( ( Radix C57 ) - 2 ) by L320 , L316 , L204;
L322: ( D30 + D29 ) <= ( ( ( Radix C57 ) - 2 ) + 1 ) by L321 , L319 , XREAL_1:7;
L323: ( ( - ( Radix C57 ) ) + 2 ) <= D30 by L316 , L320 , L204;
L324: (( D30 + D29 ) is (Element of ( INT )) & ( ( ( - ( Radix C57 ) ) + 2 ) + ( - 1 ) ) <= ( D30 + D29 )) by L323 , L318 , INT_1:def 2 , XREAL_1:7;
L325: ( D30 + D29 ) in ( C57 -SD ) by L324 , L322;
thus L326: thesis by L325;
end;
end;
definition
let C62 , C63 being Nat;
let C64 , C65 being (Tuple of C62 , ( C63 -SD ));
func C64 '+' C65 -> (Tuple of C62 , ( C63 -SD )) means 
:L328: (for R8 being Nat holds (R8 in ( Seg C62 ) implies ( DigA (it , R8) ) = ( Add (C64 , C65 , R8 , C63) )));
existence
proof
deffunc H3(Nat) = ( Add (C64 , C65 , $1 , C63) );
consider C66 being (FinSequence of ( C63 -SD )) such that L329: ( len C66 ) = C62 and L330: (for B25 being Nat holds (B25 in ( dom C66 ) implies ( C66 . B25 ) = H3(B25))) from FINSEQ_2:sch 1;
L331: ( dom C66 ) = ( Seg C62 ) by L329 , FINSEQ_1:def 3;
reconsider D31 = C66 as (Tuple of C62 , ( C63 -SD )) by L329 , CARD_1:def 7;
take D31;
let R8 being Nat;
assume L332: R8 in ( Seg C62 );
thus L333: ( DigA (D31 , R8) ) = ( D31 . R8 ) by L332 , L116
.= ( Add (C64 , C65 , R8 , C63) ) by L330 , L331 , L332;
end;
uniqueness
proof
let C67 , C68 being (Tuple of C62 , ( C63 -SD ));
assume that
L334: (for R8 being Nat holds (R8 in ( Seg C62 ) implies ( DigA (C67 , R8) ) = ( Add (C64 , C65 , R8 , C63) )))
and
L335: (for R8 being Nat holds (R8 in ( Seg C62 ) implies ( DigA (C68 , R8) ) = ( Add (C64 , C65 , R8 , C63) )));
L336: ( len C67 ) = C62 by CARD_1:def 7;
L337: ( dom C67 ) = ( Seg C62 ) by L336 , FINSEQ_1:def 3;
L338:
now
let C69 being Nat;
assume L339: C69 in ( dom C67 );
L340: ( C67 . C69 ) = ( DigA (C67 , C69) ) by L339 , L337 , L116
.= ( Add (C64 , C65 , C69 , C63) ) by L334 , L337 , L339
.= ( DigA (C68 , C69) ) by L335 , L337 , L339
.= ( C68 . C69 ) by L337 , L339 , L116;
thus L341: ( C67 . C69 ) = ( C68 . C69 ) by L340;
end;
L342: ( len C68 ) = C62 by CARD_1:def 7;
thus L343: thesis by L342 , L336 , L338 , FINSEQ_2:9;
end;
end;
theorem
L345: (for R9 being Nat holds (for R10 being Nat holds (for R11 being Nat holds ((R9 >= 2 & R10 is_represented_by 1 , R9 & R11 is_represented_by 1 , R9) implies ( SDDec ( ( DecSD (R10 , 1 , R9) ) '+' ( DecSD (R11 , 1 , R9) ) ) ) = ( SD_Add_Data (( R10 + R11 ) , R9) )))))
proof
let R9 being Nat;
let R10 being Nat;
let R11 being Nat;
assume that
L346: R9 >= 2
and
L347: R10 is_represented_by 1 , R9
and
L348: R11 is_represented_by 1 , R9;
set D32 = ( DecSD (R11 , 1 , R9) );
set D33 = ( DecSD (R10 , 1 , R9) );
L349: 1 in ( Seg 1 ) by FINSEQ_1:1;
L350: ( DigA (( D33 '+' D32 ) , 1) ) = ( Add (D33 , D32 , 1 , R9) ) by L349 , L328
.= ( ( SD_Add_Data (( ( DigA (D33 , 1) ) + ( DigA (D32 , 1) ) ) , R9) ) + ( SD_Add_Carry ( ( DigA (D33 , ( 1 -' 1 )) ) + ( DigA (D32 , ( 1 -' 1 )) ) ) ) ) by L346 , L349 , L317
.= ( ( SD_Add_Data (( ( DigA (D33 , 1) ) + ( DigA (D32 , 1) ) ) , R9) ) + ( SD_Add_Carry ( ( DigA (D33 , ( 0 )) ) + ( DigA (D32 , ( 1 -' 1 )) ) ) ) ) by XREAL_1:232
.= ( ( SD_Add_Data (( ( DigA (D33 , 1) ) + ( DigA (D32 , 1) ) ) , R9) ) + ( SD_Add_Carry ( ( DigA (D33 , ( 0 )) ) + ( DigA (D32 , ( 0 )) ) ) ) ) by XREAL_1:232
.= ( ( SD_Add_Data (( ( DigA (D33 , 1) ) + ( DigA (D32 , 1) ) ) , R9) ) + ( SD_Add_Carry ( ( 0 ) + ( DigA (D32 , ( 0 )) ) ) ) ) by L116
.= ( ( SD_Add_Data (( ( DigA (D33 , 1) ) + ( DigA (D32 , 1) ) ) , R9) ) + ( 0 ) ) by L116 , L193
.= ( SD_Add_Data (( R10 + ( DigA (D32 , 1) ) ) , R9) ) by L347 , L230
.= ( SD_Add_Data (( R10 + R11 ) , R9) ) by L348 , L230;
L351: ( ( DigitSD ( D33 '+' D32 ) ) /. 1 ) = ( SubDigit (( D33 '+' D32 ) , 1 , R9) ) by L349 , L129
.= ( ( ( Radix R9 ) |^ ( 0 ) ) * ( DigA (( D33 '+' D32 ) , 1) ) ) by XREAL_1:232
.= ( 1 * ( DigA (( D33 '+' D32 ) , 1) ) ) by NEWTON:4
.= ( SD_Add_Data (( R10 + R11 ) , R9) ) by L350;
reconsider D34 = ( SD_Add_Data (( R10 + R11 ) , R9) ) as (Element of ( INT )) by INT_1:def 2;
L352: ( len ( DigitSD ( D33 '+' D32 ) ) ) = 1 by CARD_1:def 7;
L353: 1 in ( Seg 1 ) by FINSEQ_1:1;
L354: 1 in ( dom ( DigitSD ( D33 '+' D32 ) ) ) by L353 , L352 , FINSEQ_1:def 3;
L355: ( ( DigitSD ( D33 '+' D32 ) ) . 1 ) = ( SD_Add_Data (( R10 + R11 ) , R9) ) by L354 , L351 , PARTFUN1:def 6;
L356: ( SDDec ( D33 '+' D32 ) ) = ( Sum <* D34 *> ) by L355 , L352 , FINSEQ_1:40
.= ( SD_Add_Data (( R10 + R11 ) , R9) ) by RVSUM_1:73;
thus L357: thesis by L356;
end;
theorem
L358: (for R11 being Nat holds (R11 >= 1 implies (for R9 being Nat holds (for R13 being Nat holds (for R14 being Nat holds ((R9 >= 2 & R13 is_represented_by R11 , R9 & R14 is_represented_by R11 , R9) implies ( R13 + R14 ) = ( ( SDDec ( ( DecSD (R13 , R11 , R9) ) '+' ( DecSD (R14 , R11 , R9) ) ) ) + ( ( ( Radix R9 ) |^ R11 ) * ( SD_Add_Carry ( ( DigA (( DecSD (R13 , R11 , R9) ) , R11) ) + ( DigA (( DecSD (R14 , R11 , R9) ) , R11) ) ) ) ) )))))))
proof
defpred S5[ Nat ] means (for B26 , B27 , B28 being Nat holds ((B26 >= 2 & B27 is_represented_by $1 , B26 & B28 is_represented_by $1 , B26) implies ( B27 + B28 ) = ( ( SDDec ( ( DecSD (B27 , $1 , B26) ) '+' ( DecSD (B28 , $1 , B26) ) ) ) + ( ( ( Radix B26 ) |^ $1 ) * ( SD_Add_Carry ( ( DigA (( DecSD (B27 , $1 , B26) ) , $1) ) + ( DigA (( DecSD (B28 , $1 , B26) ) , $1) ) ) ) ) )));
let R11 being Nat;
assume L359: R11 >= 1;
L360: (for B29 being Nat holds ((B29 >= 1 & S5[ B29 ]) implies S5[ ( B29 + 1 ) ]))
proof
let C70 being Nat;
assume that
L361: C70 >= 1
and
L362: S5[ C70 ];
L363: C70 in ( Seg C70 ) by L361 , FINSEQ_1:3;
let C71 , C72 , C73 being Nat;
L364: ( C70 + 1 ) in ( Seg ( C70 + 1 ) ) by FINSEQ_1:3;
set D35 = ( ( DecSD (C72 , ( C70 + 1 ) , C71) ) '+' ( DecSD (C73 , ( C70 + 1 ) , C71) ) );
set D36 = ( C73 mod ( ( Radix C71 ) |^ C70 ) );
set D37 = ( C72 mod ( ( Radix C71 ) |^ C70 ) );
assume that
L365: C71 >= 2
and
L366: C72 is_represented_by ( C70 + 1 ) , C71
and
L367: C73 is_represented_by ( C70 + 1 ) , C71;
set D38 = ( ( DecSD (D37 , C70 , C71) ) '+' ( DecSD (D36 , C70 , C71) ) );
L368: ( len ( DigitSD D38 ) ) = C70 by CARD_1:def 7;
L369: ( len ( DigitSD D35 ) ) = ( C70 + 1 ) by CARD_1:def 7;
L370: (for B30 being Nat holds ((1 <= B30 & B30 <= ( len ( DigitSD D35 ) )) implies ( ( DigitSD D35 ) . B30 ) = ( ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) . B30 )))
proof
let C74 being Nat;
assume that
L371: 1 <= C74
and
L372: C74 <= ( len ( DigitSD D35 ) );
L373: ( C74 -' 1 ) = ( C74 - 1 ) by L371 , XREAL_1:233;
L374: C74 <= ( C70 + 1 ) by L372 , CARD_1:def 7;
L375: C74 in ( Seg ( C70 + 1 ) ) by L374 , L371 , FINSEQ_1:1;
L376: C74 in ( dom ( DigitSD D35 ) ) by L375 , L369 , FINSEQ_1:def 3;
per cases  by L375 , FINSEQ_2:7;
suppose L377: C74 in ( Seg C70 );

L378: C74 in ( dom ( DigitSD D38 ) ) by L377 , L368 , FINSEQ_1:def 3;
L379: ( ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) . C74 ) = ( ( DigitSD D38 ) . C74 ) by L378 , FINSEQ_1:def 7
.= ( ( DigitSD D38 ) /. C74 ) by L378 , PARTFUN1:def 6
.= ( SubDigit (D38 , C74 , C71) ) by L377 , L129
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( Add (( DecSD (D37 , C70 , C71) ) , ( DecSD (D36 , C70 , C71) ) , C74 , C71) ) ) by L377 , L328
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , ( C74 -' 1 )) ) ) ) ) ) by L365 , L377 , L317;
L380: ( ( DigitSD D35 ) . C74 ) = ( ( DigitSD D35 ) /. C74 ) by L376 , PARTFUN1:def 6
.= ( SubDigit (D35 , C74 , C71) ) by L375 , L129
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( Add (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74 , C71) ) ) by L375 , L328
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) ) ) ) ) by L365 , L375 , L317;
L381:
now
per cases  by L371 , XXREAL_0:1;
suppose L382: C74 = 1;

L383: ( ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) . C74 ) = ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , ( 0 )) ) ) ) ) ) by L382 , L379 , XREAL_1:232
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , ( 0 )) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , ( 0 )) ) ) ) ) ) by L382 , XREAL_1:232
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , ( 0 )) ) + ( 0 ) ) ) ) ) by L116
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( 0 ) ) ) by L116 , L193;
L384: ( ( DigitSD D35 ) . C74 ) = ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( 0 )) ) ) ) ) ) by L380 , L382 , XREAL_1:232
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( 0 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( 0 )) ) ) ) ) ) by L382 , XREAL_1:232
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( 0 )) ) + ( 0 ) ) ) ) ) by L116
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) + ( 0 ) ) ) by L116 , L193
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) ) by L377 , L297
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) ) by L377 , L297;
thus L385: thesis by L384 , L383;
end;
suppose L386: C74 > 1;

L387: ( C74 - 1 ) <= C70 by L374 , XREAL_1:20;
L388: ( C74 -' 1 ) >= 1 by L386 , NAT_D:49;
L389: ( C74 -' 1 ) in ( Seg C70 ) by L388 , L373 , L387 , FINSEQ_1:1;
L390: ( ( DigitSD D35 ) . C74 ) = ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) ) ) ) ) by L377 , L380 , L297
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) ) ) ) ) by L377 , L297
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C74 -' 1 )) ) ) ) ) ) by L389 , L297
.= ( ( ( Radix C71 ) |^ ( C74 -' 1 ) ) * ( ( SD_Add_Data (( ( DigA (( DecSD (D37 , C70 , C71) ) , C74) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C74) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , ( C74 -' 1 )) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , ( C74 -' 1 )) ) ) ) ) ) by L389 , L297;
thus L391: thesis by L390 , L379;
end;
end;
thus L393: thesis by L381;
end;
suppose L394: C74 = ( C70 + 1 );

L395: ( ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) . C74 ) = ( ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) . ( ( len ( DigitSD D38 ) ) + 1 ) ) by L394 , CARD_1:def 7
.= ( SubDigit (D35 , ( C70 + 1 ) , C71) ) by FINSEQ_1:42
.= ( ( DigitSD D35 ) /. ( C70 + 1 ) ) by L364 , L129
.= ( ( DigitSD D35 ) . ( C70 + 1 ) ) by L376 , L394 , PARTFUN1:def 6;
thus L396: thesis by L395 , L394;
end;
end;
L398: ( SubDigit (D35 , ( C70 + 1 ) , C71) ) = ( ( ( Radix C71 ) |^ C70 ) * ( DigB (D35 , ( C70 + 1 )) ) ) by NAT_D:34;
L399: ( Radix C71 ) > ( 0 ) by POWER:34;
L400: C72 = ( ( ( C72 div ( ( Radix C71 ) |^ C70 ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( C72 mod ( ( Radix C71 ) |^ C70 ) ) ) by L399 , NAT_D:2 , PREPOWER:6;
set D39 = ( C73 div ( ( Radix C71 ) |^ C70 ) );
set D40 = ( C72 div ( ( Radix C71 ) |^ C70 ) );
L401: ( len <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) = 1 by FINSEQ_1:39;
L402: ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) = D39 by L367 , L309;
L403: D36 < ( ( Radix C71 ) |^ C70 ) by L399 , NAT_D:1 , PREPOWER:6;
L404: D36 is_represented_by C70 , C71 by L403 , L228;
L405: D37 < ( ( Radix C71 ) |^ C70 ) by L399 , NAT_D:1 , PREPOWER:6;
L406: D37 is_represented_by C70 , C71 by L405 , L228;
L407: ( len ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) ) = ( ( len ( DigitSD D38 ) ) + ( len <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) ) by FINSEQ_1:22
.= ( C70 + 1 ) by L401 , CARD_1:def 7;
L408: ( len ( DigitSD D35 ) ) = ( len ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) ) by L407 , CARD_1:def 7;
L409: ( DigitSD D35 ) = ( ( DigitSD D38 ) ^ <* ( SubDigit (D35 , ( C70 + 1 ) , C71) ) *> ) by L408 , L370 , FINSEQ_1:14;
L410: ( SDDec D35 ) = ( ( ( ( Radix C71 ) |^ C70 ) * ( DigB (D35 , ( C70 + 1 )) ) ) + ( Sum ( DigitSD D38 ) ) ) by L409 , L398 , RVSUM_1:74
.= ( ( ( Add (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 ) , C71) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by L364 , L328
.= ( ( ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( ( C70 + 1 ) -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( ( C70 + 1 ) -' 1 )) ) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by L364 , L365 , L317
.= ( ( ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( ( C70 + 1 ) -' 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C70) ) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by NAT_D:34
.= ( ( ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , C70) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C70) ) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by NAT_D:34
.= ( ( ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , C70) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , C70) ) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by L363 , L297
.= ( ( ( ( SD_Add_Data (( ( DigA (( DecSD (C72 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) + ( DigA (( DecSD (C73 , ( C70 + 1 ) , C71) ) , ( C70 + 1 )) ) ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , C70) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C70) ) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by L363 , L297
.= ( ( ( ( SD_Add_Data (( D40 + D39 ) , C71) ) + ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , C70) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C70) ) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( Sum ( DigitSD D38 ) ) ) by L366 , L402 , L309
.= ( ( ( SD_Add_Data (( D40 + D39 ) , C71) ) * ( ( Radix C71 ) |^ C70 ) ) + ( ( ( SD_Add_Carry ( ( DigA (( DecSD (D37 , C70 , C71) ) , C70) ) + ( DigA (( DecSD (D36 , C70 , C71) ) , C70) ) ) ) * ( ( Radix C71 ) |^ C70 ) ) + ( SDDec ( ( DecSD (D37 , C70 , C71) ) '+' ( DecSD (D36 , C70 , C71) ) ) ) ) )
.= ( ( ( SD_Add_Data (( D40 + D39 ) , C71) ) * ( ( Radix C71 ) |^ C70 ) ) + ( D37 + D36 ) ) by L362 , L365 , L406 , L404
.= ( ( ( ( SD_Add_Data (( D40 + D39 ) , C71) ) * ( ( Radix C71 ) |^ C70 ) ) + D37 ) + D36 );
L411: ( ( SDDec D35 ) + ( ( SD_Add_Carry ( D40 + D39 ) ) * ( ( Radix C71 ) |^ ( C70 + 1 ) ) ) ) = ( ( ( ( ( SD_Add_Data (( D40 + D39 ) , C71) ) * ( ( Radix C71 ) |^ C70 ) ) + ( ( SD_Add_Carry ( D40 + D39 ) ) * ( ( Radix C71 ) |^ ( C70 + 1 ) ) ) ) + D37 ) + D36 ) by L410
.= ( ( ( ( ( SD_Add_Data (( D40 + D39 ) , C71) ) * ( ( Radix C71 ) |^ C70 ) ) + ( ( SD_Add_Carry ( D40 + D39 ) ) * ( ( ( Radix C71 ) |^ C70 ) * ( Radix C71 ) ) ) ) + D37 ) + D36 ) by NEWTON:6
.= ( ( ( D40 * ( ( Radix C71 ) |^ C70 ) ) + D37 ) + ( ( D39 * ( ( Radix C71 ) |^ C70 ) ) + D36 ) )
.= ( C72 + C73 ) by L399 , L400 , NAT_D:2 , PREPOWER:6;
thus L412: thesis by L411 , L366 , L402 , L309;
end;
L413: S5[ 1 ]
proof
let C75 , C76 , C77 being Nat;
assume L414: (C75 >= 2 & C76 is_represented_by 1 , C75 & C77 is_represented_by 1 , C75);
L415: (( SDDec ( ( DecSD (C76 , 1 , C75) ) '+' ( DecSD (C77 , 1 , C75) ) ) ) = ( SD_Add_Data (( C76 + C77 ) , C75) ) & ( SD_Add_Carry ( ( DigA (( DecSD (C76 , 1 , C75) ) , 1) ) + ( DigA (( DecSD (C77 , 1 , C75) ) , 1) ) ) ) = ( SD_Add_Carry ( C76 + C77 ) )) by L414 , L292 , L345;
L416: ( ( SD_Add_Data (( C76 + C77 ) , C75) ) + ( ( SD_Add_Carry ( C76 + C77 ) ) * ( Radix C75 ) ) ) = ( ( C76 + C77 ) - ( 0 ) );
thus L417: thesis by L416 , L415 , NEWTON:5;
end;
L418: (for B31 being Nat holds (B31 >= 1 implies S5[ B31 ])) from NAT_1:sch 8(L413 , L360);
thus L419: thesis by L418 , L359;
end;
