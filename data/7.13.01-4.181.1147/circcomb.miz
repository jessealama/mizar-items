:: Combining of Circuits
::  by Yatsuka Nakamura and Grzegorz Bancerek
::
:: Received May 11, 1995
:: Copyright (c) 1995-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies MSUALG_1, SUBSET_1, STRUCT_0, NUMBERS, XBOOLE_0, CARD_3,
      FINSEQ_1, FUNCOP_1, FINSEQ_2, PBOOLE, FUNCT_4, RELAT_1, PARTFUN1,
      FUNCT_1, TARSKI, MSAFREE2, FINSET_1, GLIB_000, MARGREL1, CIRCUIT1, FSM_1,
      CIRCUIT2, MCART_1, NAT_1, CARD_1, LATTICES, XBOOLEAN, CIRCCOMB;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, CARD_1, NUMBERS, ORDINAL1, MCART_1,
      RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, FINSET_1, FUNCT_2, FUNCOP_1,
      PARTFUN1, FUNCT_4, CARD_3, MARGREL1, PBOOLE, STRUCT_0, MSUALG_1,
      MSAFREE2, CIRCUIT1, CIRCUIT2;
 constructors MARGREL1, CIRCUIT1, CIRCUIT2, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      FINSEQ_1, MARGREL1, CARD_3, PBOOLE, STRUCT_0, MSUALG_1, MSUALG_2,
      MSAFREE2, FUNCT_4, RELSET_1, FINSEQ_2, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions TARSKI, PARTFUN1, MSUALG_1, FINSET_1, MSAFREE2, STRUCT_0,
      XBOOLE_0, FUNCOP_1, PBOOLE, MARGREL1, XTUPLE_0;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, FINSEQ_2, MSUALG_1, FUNCT_1, FUNCT_2,
      FUNCT_4, PBOOLE, GRFUNC_1, FUNCOP_1, PARTFUN1, RELAT_1, MSAFREE2,
      CIRCUIT1, CIRCUIT2, MCART_1, CARD_3, MONOID_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, CARD_1, FINSEQ_3, XTUPLE_0, XREGULAR;
 schemes FUNCT_1;

begin
definition
let C1 being ManySortedSign;
mode Gate of C1
 is (Element of (the carrier' of C1));
end;
L2:
now
let C2 being (Element of ( NAT ));
let C3 being non  empty set;
thus L3: ( product ( ( Seg C2 ) --> C3 ) ) = ( product ( C2 |-> C3 ) ) by FINSEQ_2:def 2
.= ( C2 -tuples_on C3 ) by FINSEQ_3:131;
end;
registration
let C4 , C5 being set;
let C6 being (ManySortedSet of C4);
let C7 being (ManySortedSet of C5);
cluster ( C6 +* C7 ) -> ( C4 \/ C5 ) -defined;
coherence
proof
L4: ( dom C7 ) = C5 by PARTFUN1:def 2;
L5: ( dom C6 ) = C4 by PARTFUN1:def 2;
L6: ( dom ( C6 +* C7 ) ) = ( C4 \/ C5 ) by L5 , L4 , FUNCT_4:def 1;
thus L7: thesis by L6 , RELAT_1:def 18;
end;
end;
registration
let C8 , C9 being set;
let C10 being (ManySortedSet of C8);
let C11 being (ManySortedSet of C9);
cluster ( C10 +* C11 ) ->  total for ( C8 \/ C9 ) -defined ( C8 \/ C9 ) -defined ( C8 \/ C9 ) -defined ( C8 \/ C9 ) -defined Function;
coherence
proof
L9: ( dom C11 ) = C9 by PARTFUN1:def 2;
L10: ( dom C10 ) = C8 by PARTFUN1:def 2;
L11: ( dom ( C10 +* C11 ) ) = ( C8 \/ C9 ) by L10 , L9 , FUNCT_4:def 1;
thus L12: thesis by L11 , PARTFUN1:def 2;
end;
end;
registration
let C12 , C13 being set;
cluster ( C12 .--> C13 ) -> { C12 } -defined;
coherence;
end;
registration
let C14 , C15 being set;
cluster ( C14 .--> C15 ) ->  total for { C14 } -defined { C14 } -defined { C14 } -defined { C14 } -defined Function;
coherence;
end;
registration
let C16 being set;
let C17 being non  empty set;
cluster ( C16 .--> C17 ) ->  non-empty;
coherence;
end;
theorem
L17: (for B1 , B2 being set holds (for B3 being (ManySortedSet of B1) holds (for B4 being (ManySortedSet of B2) holds (B3 c= B4 implies ( B3 # ) c= ( B4 # )))))
proof
let C18 , C19 being set;
let C20 being (ManySortedSet of C18);
let C21 being (ManySortedSet of C19);
assume L18: C20 c= C21;
L19:
now
L20: ( dom C20 ) c= ( dom C21 ) by L18 , RELAT_1:11;
L21: ( dom C21 ) = C19 by PARTFUN1:def 2;
L22: ( dom ( C21 # ) ) = ( C19 * ) by PARTFUN1:def 2;
let C22 being set;
L23: ( dom C20 ) = C18 by PARTFUN1:def 2;
assume L24: C22 in ( C20 # );
consider C23 , C24 being set such that L25: [ C23 , C24 ] = C22 by L24 , RELAT_1:def 1;
L26: ( dom ( C20 # ) ) = ( C18 * ) by PARTFUN1:def 2;
reconsider D1 = C23 as (Element of ( C18 * )) by L26 , L24 , L25 , XTUPLE_0:def 12;
L27: ( rng D1 ) c= C18 by FINSEQ_1:def 4;
L28: ( rng D1 ) c= C18 by FINSEQ_1:def 4;
L29: ( rng D1 ) c= C19 by L28 , L23 , L21 , L20 , XBOOLE_1:1;
L30: D1 is (FinSequence of C19) by L29 , FINSEQ_1:def 4;
reconsider D2 = D1 as (Element of ( C19 * )) by L30 , FINSEQ_1:def 11;
L31: ( rng D2 ) c= C19 by FINSEQ_1:def 4;
L32: C24 = ( ( C20 # ) . D1 ) by L24 , L25 , FUNCT_1:1
.= ( product ( C20 * D1 ) ) by FINSEQ_2:def 5
.= ( product ( C21 * D2 ) ) by L18 , L23 , L21 , L27 , L31 , PARTFUN1:54 , PARTFUN1:79
.= ( ( C21 # ) . D2 ) by FINSEQ_2:def 5;
thus L33: C22 in ( C21 # ) by L32 , L25 , L22 , FUNCT_1:1;
end;
thus L34: thesis by L19 , TARSKI:def 3;
end;
theorem
L35: (for B5 being set holds (for B6 being non  empty set holds (for B7 being (FinSequence of B5) holds ( ( ( B5 --> B6 ) # ) . B7 ) = ( ( len B7 ) -tuples_on B6 ))))
proof
let C25 being set;
let C26 being non  empty set;
let C27 being (FinSequence of C25);
L36: ( rng C27 ) c= C25 by FINSEQ_1:def 4;
L37: ( ( rng C27 ) /\ C25 ) = ( rng C27 ) by L36 , XBOOLE_1:28;
L38: ( C27 " C25 ) = ( C27 " ( rng C27 ) ) by L37 , RELAT_1:133
.= ( dom C27 ) by RELAT_1:134;
L39: C27 in ( C25 * ) by FINSEQ_1:def 11;
thus L40: ( ( ( C25 --> C26 ) # ) . C27 ) = ( product ( ( C25 --> C26 ) * C27 ) ) by L39 , FINSEQ_2:def 5
.= ( product ( ( C27 " C25 ) --> C26 ) ) by FUNCOP_1:19
.= ( product ( ( Seg ( len C27 ) ) --> C26 ) ) by L38 , FINSEQ_1:def 3
.= ( ( len C27 ) -tuples_on C26 ) by L2;
end;
definition
let C28 being set;
let C29 , C30 being  non-empty (ManySortedSet of C28);
let C31 being set;
let C32 , C33 being  non-empty (ManySortedSet of C31);
let C34 being (ManySortedFunction of C29 , C30);
let C35 being (ManySortedFunction of C32 , C33);
redefine func C34 +* C35 -> (ManySortedFunction of ( C29 +* C32 ) , ( C30 +* C33 ));

coherence
proof
set D3 = ( C29 +* C32 );
set D4 = ( C30 +* C33 );
set D5 = ( C34 +* C35 );
L41: ( dom C30 ) = C28 by PARTFUN1:def 2;
L42: ( dom C32 ) = C31 by PARTFUN1:def 2;
L43: ( dom C33 ) = C31 by PARTFUN1:def 2;
L44: ( dom C35 ) = C31 by PARTFUN1:def 2;
L45: ( dom C34 ) = C28 by PARTFUN1:def 2;
reconsider D6 = D5 as (ManySortedFunction of ( C28 \/ C31 ));
L46: ( dom C29 ) = C28 by PARTFUN1:def 2;
L47: D6 is (ManySortedFunction of D3 , D4)
proof
let C36 being set;
L48: ((not C36 in C31) or C36 in C31);
assume L49: C36 in ( C28 \/ C31 );
L50: (C36 in C28 or C36 in C31) by L49 , XBOOLE_0:def 3;
L51: ((( D6 . C36 ) = ( C34 . C36 ) & ( C34 . C36 ) is (Function of ( C29 . C36 ) , ( C30 . C36 )) & ( D3 . C36 ) = ( C29 . C36 ) & ( D4 . C36 ) = ( C30 . C36 )) or (( D6 . C36 ) = ( C35 . C36 ) & ( C35 . C36 ) is (Function of ( C32 . C36 ) , ( C33 . C36 )) & ( D3 . C36 ) = ( C32 . C36 ) & ( D4 . C36 ) = ( C33 . C36 ))) by L50 , L46 , L41 , L45 , L42 , L43 , L44 , L49 , L48 , FUNCT_4:def 1 , PBOOLE:def 15;
thus L52: thesis by L51;
end;
thus L53: thesis by L47;
end;
end;
definition
let C37 , C38 being ManySortedSign;
pred C37 tolerates C38
means
((the Arity of C37) tolerates (the Arity of C38) & (the ResultSort of C37) tolerates (the ResultSort of C38))
;reflexivity
;
symmetry
;
end;
definition
let C39 , C40 being non  empty ManySortedSign;
func C39 +* C40 ->  strict non  empty ManySortedSign means 
:L56: ((the carrier of it) = ( (the carrier of C39) \/ (the carrier of C40) ) & (the carrier' of it) = ( (the carrier' of C39) \/ (the carrier' of C40) ) & (the Arity of it) = ( (the Arity of C39) +* (the Arity of C40) ) & (the ResultSort of it) = ( (the ResultSort of C39) +* (the ResultSort of C40) ));
existence
proof
set D7 = ( (the ResultSort of C39) +* (the ResultSort of C40) );
set D8 = ( (the Arity of C39) +* (the Arity of C40) );
set D9 = ( (the carrier' of C39) \/ (the carrier' of C40) );
reconsider D10 = ( (the carrier of C39) \/ (the carrier of C40) ) as non  empty set;
L57: ( dom (the ResultSort of C40) ) = (the carrier' of C40) by FUNCT_2:def 1;
L58: ( dom (the ResultSort of C39) ) = (the carrier' of C39) by FUNCT_2:def 1;
L59: ( dom D7 ) = D9 by L58 , L57 , FUNCT_4:def 1;
L60: (the carrier of C39) c= D10 by XBOOLE_1:7;
L61: (the carrier of C40) c= D10 by XBOOLE_1:7;
L62: ( rng (the ResultSort of C40) ) c= (the carrier of C40) by RELAT_1:def 19;
L63: ( rng (the ResultSort of C40) ) c= D10 by L62 , L61 , XBOOLE_1:1;
L64: ( rng (the ResultSort of C39) ) c= (the carrier of C39) by RELAT_1:def 19;
L65: ( rng (the ResultSort of C39) ) c= D10 by L64 , L60 , XBOOLE_1:1;
L66: ( ( rng (the ResultSort of C39) ) \/ ( rng (the ResultSort of C40) ) ) c= D10 by L65 , L63 , XBOOLE_1:8;
L67: ( rng D7 ) c= ( ( rng (the ResultSort of C39) ) \/ ( rng (the ResultSort of C40) ) ) by FUNCT_4:17;
L68: ( rng D7 ) c= D10 by L67 , L66 , XBOOLE_1:1;
reconsider D11 = D7 as (Function of D9 , D10) by L68 , L59 , FUNCT_2:def 1 , RELSET_1:4;
L69: ( dom (the Arity of C40) ) = (the carrier' of C40) by FUNCT_2:def 1;
L70: ( dom (the Arity of C39) ) = (the carrier' of C39) by FUNCT_2:def 1;
L71: ( dom D8 ) = D9 by L70 , L69 , FUNCT_4:def 1;
L72: ( rng (the Arity of C39) ) c= ( (the carrier of C39) * ) by RELAT_1:def 19;
L73: ( rng (the Arity of C40) ) c= ( (the carrier of C40) * ) by RELAT_1:def 19;
L74: ( (the carrier of C40) * ) c= ( D10 * ) by FINSEQ_1:62 , XBOOLE_1:7;
L75: ( rng (the Arity of C40) ) c= ( D10 * ) by L74 , L73 , XBOOLE_1:1;
L76: ( (the carrier of C39) * ) c= ( D10 * ) by FINSEQ_1:62 , XBOOLE_1:7;
L77: ( rng (the Arity of C39) ) c= ( D10 * ) by L76 , L72 , XBOOLE_1:1;
L78: ( ( rng (the Arity of C39) ) \/ ( rng (the Arity of C40) ) ) c= ( D10 * ) by L77 , L75 , XBOOLE_1:8;
L79: ( rng D8 ) c= ( ( rng (the Arity of C39) ) \/ ( rng (the Arity of C40) ) ) by FUNCT_4:17;
L80: ( rng D8 ) c= ( D10 * ) by L79 , L78 , XBOOLE_1:1;
reconsider D12 = D8 as (Function of D9 , ( D10 * )) by L80 , L71 , FUNCT_2:def 1 , RELSET_1:4;
take ManySortedSign (# D10 , D9 , D12 , D11 #);
thus L81: thesis;
end;
uniqueness;
end;
theorem
L83: (for B8 , B9 , B10 being non  empty ManySortedSign holds ((B8 tolerates B9 & B9 tolerates B10 & B10 tolerates B8) implies ( B8 +* B9 ) tolerates B10))
proof
let C41 , C42 , C43 being non  empty ManySortedSign;
assume that
L84: (the Arity of C41) tolerates (the Arity of C42)
and
L85: (the ResultSort of C41) tolerates (the ResultSort of C42)
and
L86: (the Arity of C42) tolerates (the Arity of C43)
and
L87: (the ResultSort of C42) tolerates (the ResultSort of C43)
and
L88: (the Arity of C43) tolerates (the Arity of C41)
and
L89: (the ResultSort of C43) tolerates (the ResultSort of C41);
L90: (the Arity of ( C41 +* C42 )) = ( (the Arity of C41) +* (the Arity of C42) ) by L56;
thus L91: (the Arity of ( C41 +* C42 )) tolerates (the Arity of C43) by L90 , L84 , L86 , L88 , FUNCT_4:125;
L92: (the ResultSort of ( C41 +* C42 )) = ( (the ResultSort of C41) +* (the ResultSort of C42) ) by L56;
thus L93: thesis by L92 , L85 , L87 , L89 , FUNCT_4:125;
end;
theorem
L94: (for B11 being non  empty ManySortedSign holds ( B11 +* B11 ) = ( the ManySortedSign of B11 ))
proof
let C44 being non  empty ManySortedSign;
L95: (the carrier' of C44) = ( (the carrier' of C44) \/ (the carrier' of C44) );
L96: (the Arity of C44) = ( (the Arity of C44) +* (the Arity of C44) );
L97: (the ResultSort of C44) = ( (the ResultSort of C44) +* (the ResultSort of C44) );
L98: (the carrier of C44) = ( (the carrier of C44) \/ (the carrier of C44) );
thus L99: thesis by L98 , L95 , L96 , L97 , L56;
end;
theorem
L100: (for B12 , B13 being non  empty ManySortedSign holds (B12 tolerates B13 implies ( B12 +* B13 ) = ( B13 +* B12 )))
proof
let C45 , C46 being non  empty ManySortedSign;
set D13 = ( C45 +* C46 );
assume that
L101: (the Arity of C45) tolerates (the Arity of C46)
and
L102: (the ResultSort of C45) tolerates (the ResultSort of C46);
L103: (the carrier' of D13) = ( (the carrier' of C45) \/ (the carrier' of C46) ) by L56;
L104: ( (the ResultSort of C45) +* (the ResultSort of C46) ) = ( (the ResultSort of C46) +* (the ResultSort of C45) ) by L102 , FUNCT_4:34;
L105: (the ResultSort of D13) = ( (the ResultSort of C46) +* (the ResultSort of C45) ) by L104 , L56;
L106: ( (the Arity of C45) +* (the Arity of C46) ) = ( (the Arity of C46) +* (the Arity of C45) ) by L101 , FUNCT_4:34;
L107: (the Arity of D13) = ( (the Arity of C46) +* (the Arity of C45) ) by L106 , L56;
L108: (the carrier of D13) = ( (the carrier of C45) \/ (the carrier of C46) ) by L56;
thus L109: thesis by L108 , L103 , L107 , L105 , L56;
end;
theorem
L110: (for B14 , B15 , B16 being non  empty ManySortedSign holds ( ( B14 +* B15 ) +* B16 ) = ( B14 +* ( B15 +* B16 ) ))
proof
let C47 , C48 , C49 being non  empty ManySortedSign;
set D14 = ( C47 +* C48 );
set D15 = ( C48 +* C49 );
set D16 = ( D14 +* C49 );
set D17 = ( C47 +* D15 );
L111: (the carrier of D15) = ( (the carrier of C48) \/ (the carrier of C49) ) by L56;
L112: (the carrier of D16) = ( (the carrier of D14) \/ (the carrier of C49) ) by L56;
L113: (the carrier of D17) = ( (the carrier of C47) \/ (the carrier of D15) ) by L56;
L114: (the carrier of D14) = ( (the carrier of C47) \/ (the carrier of C48) ) by L56;
L115: (the carrier of D16) = (the carrier of D17) by L114 , L111 , L112 , L113 , XBOOLE_1:4;
L116: (the carrier' of D15) = ( (the carrier' of C48) \/ (the carrier' of C49) ) by L56;
L117: (the carrier' of D16) = ( (the carrier' of D14) \/ (the carrier' of C49) ) by L56;
L118: (the Arity of D15) = ( (the Arity of C48) +* (the Arity of C49) ) by L56;
L119: (the Arity of D17) = ( (the Arity of C47) +* (the Arity of D15) ) by L56;
L120: (the carrier' of D17) = ( (the carrier' of C47) \/ (the carrier' of D15) ) by L56;
L121: (the carrier' of D14) = ( (the carrier' of C47) \/ (the carrier' of C48) ) by L56;
L122: (the carrier' of D16) = (the carrier' of D17) by L121 , L116 , L117 , L120 , XBOOLE_1:4;
L123: (the ResultSort of D17) = ( (the ResultSort of C47) +* (the ResultSort of D15) ) by L56;
L124: (the ResultSort of D16) = ( (the ResultSort of D14) +* (the ResultSort of C49) ) by L56;
L125: (the Arity of D16) = ( (the Arity of D14) +* (the Arity of C49) ) by L56;
L126: (the Arity of D14) = ( (the Arity of C47) +* (the Arity of C48) ) by L56;
L127: (the Arity of D16) = (the Arity of D17) by L126 , L118 , L125 , L119 , FUNCT_4:14;
L128: (the ResultSort of D15) = ( (the ResultSort of C48) +* (the ResultSort of C49) ) by L56;
L129: (the ResultSort of D14) = ( (the ResultSort of C47) +* (the ResultSort of C48) ) by L56;
thus L130: thesis by L129 , L128 , L124 , L123 , L115 , L122 , L127 , FUNCT_4:14;
end;
theorem
L131: (for B17 being  one-to-one Function holds (for B18 , B19 being  Circuit-like non  empty ManySortedSign holds (((the ResultSort of B18) c= B17 & (the ResultSort of B19) c= B17) implies ( B18 +* B19 ) is  Circuit-like)))
proof
let C50 being  one-to-one Function;
let C51 , C52 being  Circuit-like non  empty ManySortedSign;
assume that
L132: (the ResultSort of C51) c= C50
and
L133: (the ResultSort of C52) c= C50;
let C53 being non  void non  empty ManySortedSign;
set D18 = (the ResultSort of C51);
set D19 = (the ResultSort of C52);
set D20 = (the ResultSort of C53);
L134: ( D18 +* D19 ) c= ( D18 \/ D19 ) by FUNCT_4:29;
assume L135: C53 = ( C51 +* C52 );
L136: D20 = ( D18 +* D19 ) by L135 , L56;
L137: ( D18 \/ D19 ) c= C50 by L132 , L133 , XBOOLE_1:8;
L138: ( D18 +* D19 ) c= C50 by L137 , L134 , XBOOLE_1:1;
L139: ( dom D20 ) c= ( dom C50 ) by L138 , L136 , GRFUNC_1:2;
let C54 , C55 being (Gate of C53);
L140: ( dom D20 ) = (the carrier' of C53) by FUNCT_2:def 1;
L141: C54 in ( dom D20 ) by L140;
L142: C55 in ( dom D20 ) by L140;
assume L143: ( the_result_sort_of C54 ) = ( the_result_sort_of C55 );
L144: ( D20 . C55 ) = ( C50 . C55 ) by L136 , L140 , L138 , GRFUNC_1:2;
L145: ( D20 . C54 ) = ( C50 . C54 ) by L136 , L140 , L138 , GRFUNC_1:2;
thus L146: thesis by L145 , L143 , L141 , L142 , L144 , L139 , FUNCT_1:def 4;
end;
theorem
L147: (for B20 , B21 being  Circuit-like non  empty ManySortedSign holds (( InnerVertices B20 ) misses ( InnerVertices B21 ) implies ( B20 +* B21 ) is  Circuit-like))
proof
let C56 , C57 being  Circuit-like non  empty ManySortedSign;
assume L148: ( InnerVertices C56 ) misses ( InnerVertices C57 );
set D21 = (the ResultSort of C56);
set D22 = (the ResultSort of C57);
let C58 being non  void non  empty ManySortedSign;
set D23 = (the ResultSort of C58);
L149: ( dom D21 ) = (the carrier' of C56) by FUNCT_2:def 1;
assume L150: C58 = ( C56 +* C57 );
L151: D23 = ( D21 +* D22 ) by L150 , L56;
L152: ( dom D22 ) = (the carrier' of C57) by FUNCT_2:def 1;
let C59 , C60 being (Gate of C58);
L153: (the carrier' of C58) = ( (the carrier' of C56) \/ (the carrier' of C57) ) by L150 , L56;
L154: (((not C59 in (the carrier' of C57)) & C59 in (the carrier' of C56)) or C59 in (the carrier' of C57)) by L153 , XBOOLE_0:def 3;
L155: ((( D23 . C59 ) = ( D21 . C59 ) & ( D21 . C59 ) in ( rng D21 ) & C59 in (the carrier' of C56)) or (( D23 . C59 ) = ( D22 . C59 ) & ( D22 . C59 ) in ( rng D22 ) & C59 in (the carrier' of C57))) by L154 , L151 , L149 , L152 , L153 , FUNCT_1:def 3 , FUNCT_4:def 1;
L156: (((not C60 in (the carrier' of C57)) & C60 in (the carrier' of C56)) or C60 in (the carrier' of C57)) by L153 , XBOOLE_0:def 3;
L157: ((( D23 . C60 ) = ( D21 . C60 ) & ( D21 . C60 ) in ( rng D21 ) & C60 in (the carrier' of C56)) or (( D23 . C60 ) = ( D22 . C60 ) & ( D22 . C60 ) in ( rng D22 ) & C60 in (the carrier' of C57))) by L156 , L151 , L149 , L152 , L153 , FUNCT_1:def 3 , FUNCT_4:def 1;
assume L158: ( the_result_sort_of C59 ) = ( the_result_sort_of C60 );
per cases  by L148 , L158 , L155 , L157 , XBOOLE_0:3;
suppose L159: (( D23 . C59 ) = ( D21 . C59 ) & C59 in (the carrier' of C56) & ( D23 . C60 ) = ( D21 . C60 ) & C60 in (the carrier' of C56));

reconsider D24 = C56 as non  void  Circuit-like non  empty ManySortedSign by L159;
reconsider D25 = C59 , D26 = C60 as (Gate of D24) by L159;
L160: ( the_result_sort_of D26 ) = ( D21 . D26 );
L161: ( the_result_sort_of D25 ) = ( D21 . D25 );
thus L162: thesis by L161 , L158 , L159 , L160 , MSAFREE2:def 6;
end;
suppose L163: (( D23 . C59 ) = ( D22 . C59 ) & C59 in (the carrier' of C57) & ( D23 . C60 ) = ( D22 . C60 ) & C60 in (the carrier' of C57));

reconsider D27 = C57 as non  void  Circuit-like non  empty ManySortedSign by L163;
reconsider D28 = C59 , D29 = C60 as (Gate of D27) by L163;
L164: ( the_result_sort_of D29 ) = ( D22 . D29 );
L165: ( the_result_sort_of D28 ) = ( D22 . D28 );
thus L166: thesis by L165 , L158 , L163 , L164 , MSAFREE2:def 6;
end;
end;
theorem
L168: (for B22 , B23 being non  empty ManySortedSign holds (((not B22 is  void) or (not B23 is  void)) implies ( B22 +* B23 ) is non  void))
proof
let C61 , C62 being non  empty ManySortedSign;
assume L169: ((not C61 is  void) or (not C62 is  void));
L170: (the carrier' of ( C61 +* C62 )) = ( (the carrier' of C61) \/ (the carrier' of C62) ) by L56;
thus L171: (the carrier' of ( C61 +* C62 )) is non  empty by L170 , L169;
end;
theorem
L172: (for B24 , B25 being  finite non  empty ManySortedSign holds ( B24 +* B25 ) is  finite)
proof
let C63 , C64 being  finite non  empty ManySortedSign;
reconsider D30 = (the carrier of C63) , D31 = (the carrier of C64) as  finite set;
L173: (the carrier of ( C63 +* C64 )) = ( D30 \/ D31 ) by L56;
thus L174: thesis by L173;
end;
registration
let C65 being non  void non  empty ManySortedSign;
let C66 being non  empty ManySortedSign;
cluster ( C65 +* C66 ) -> non  void;
coherence by L168;
cluster ( C66 +* C65 ) -> non  void;
coherence by L168;
end;
theorem
L176: (for B26 , B27 being non  empty ManySortedSign holds (B26 tolerates B27 implies (( InnerVertices ( B26 +* B27 ) ) = ( ( InnerVertices B26 ) \/ ( InnerVertices B27 ) ) & ( InputVertices ( B26 +* B27 ) ) c= ( ( InputVertices B26 ) \/ ( InputVertices B27 ) ))))
proof
let C67 , C68 being non  empty ManySortedSign;
set D32 = (the ResultSort of C67);
set D33 = (the ResultSort of C68);
assume that
L177: (the Arity of C67) tolerates (the Arity of C68)
and
L178: D32 tolerates D33;
set D34 = ( C67 +* C68 );
set D35 = (the ResultSort of D34);
L179: D35 = ( D32 +* D33 ) by L56;
L180: D32 c= D35 by L179 , L178 , FUNCT_4:28;
L181: ( rng D32 ) c= ( rng D35 ) by L180 , RELAT_1:11;
L182: ( rng D33 ) c= ( rng D35 ) by L179 , FUNCT_4:18;
L183: ( ( rng D32 ) \/ ( rng D33 ) ) c= ( rng D35 ) by L182 , L181 , XBOOLE_1:8;
L184: ( rng D35 ) c= ( ( rng D32 ) \/ ( rng D33 ) ) by L179 , FUNCT_4:17;
thus L185: ( InnerVertices D34 ) = ( ( InnerVertices C67 ) \/ ( InnerVertices C68 ) ) by L184 , L183 , XBOOLE_0:def 10;
let C69 being set;
assume L186: C69 in ( InputVertices D34 );
L187: (not C69 in ( rng D35 )) by L186 , XBOOLE_0:def 5;
L188: ( rng D35 ) = ( ( rng D32 ) \/ ( rng D33 ) ) by L184 , L183 , XBOOLE_0:def 10;
L189: (not C69 in ( rng D33 )) by L188 , L187 , XBOOLE_0:def 3;
L190: (the carrier of D34) = ( (the carrier of C67) \/ (the carrier of C68) ) by L56;
L191: (C69 in (the carrier of C67) or C69 in (the carrier of C68)) by L190 , L186 , XBOOLE_0:def 3;
L192: (not C69 in ( rng D32 )) by L188 , L187 , XBOOLE_0:def 3;
L193: (C69 in ( (the carrier of C67) \ ( rng D32 ) ) or C69 in ( (the carrier of C68) \ ( rng D33 ) )) by L192 , L191 , L189 , XBOOLE_0:def 5;
thus L194: thesis by L193 , XBOOLE_0:def 3;
end;
theorem
L195: (for B28 , B29 being non  empty ManySortedSign holds (for B30 being (Vertex of B29) holds (B30 in ( InputVertices ( B28 +* B29 ) ) implies B30 in ( InputVertices B29 ))))
proof
let C70 , C71 being non  empty ManySortedSign;
set D36 = (the ResultSort of C70);
set D37 = (the ResultSort of C71);
set D38 = ( C70 +* C71 );
set D39 = (the ResultSort of D38);
let C72 being (Vertex of C71);
L196: D39 = ( D36 +* D37 ) by L56;
L197: ( rng D37 ) c= ( rng D39 ) by L196 , FUNCT_4:18;
assume L198: C72 in ( InputVertices D38 );
L199: (not C72 in ( rng D37 )) by L198 , L197 , XBOOLE_0:def 5;
thus L200: thesis by L199 , XBOOLE_0:def 5;
end;
theorem
L201: (for B31 , B32 being non  empty ManySortedSign holds (B31 tolerates B32 implies (for B33 being (Vertex of B31) holds (B33 in ( InputVertices ( B31 +* B32 ) ) implies B33 in ( InputVertices B31 )))))
proof
let C73 , C74 being non  empty ManySortedSign;
assume that
L202: (the Arity of C73) tolerates (the Arity of C74)
and
L203: (the ResultSort of C73) tolerates (the ResultSort of C74);
set D40 = ( C73 +* C74 );
set D41 = (the ResultSort of D40);
set D42 = (the ResultSort of C73);
set D43 = (the ResultSort of C74);
L204: D41 = ( D42 +* D43 ) by L56;
L205: D42 c= D41 by L204 , L203 , FUNCT_4:28;
L206: ( rng D42 ) c= ( rng D41 ) by L205 , RELAT_1:11;
let C75 being (Vertex of C73);
assume L207: C75 in ( InputVertices D40 );
L208: (not C75 in ( rng D42 )) by L207 , L206 , XBOOLE_0:def 5;
thus L209: thesis by L208 , XBOOLE_0:def 5;
end;
theorem
L210: (for B34 being non  empty ManySortedSign holds (for B35 being non  void non  empty ManySortedSign holds (for B36 being (OperSymbol of B35) holds (for B37 being (OperSymbol of ( B34 +* B35 )) holds (B36 = B37 implies (( the_arity_of B37 ) = ( the_arity_of B36 ) & ( the_result_sort_of B37 ) = ( the_result_sort_of B36 )))))))
proof
let C76 being non  empty ManySortedSign;
let C77 being non  void non  empty ManySortedSign;
let C78 being (OperSymbol of C77);
let C79 being (OperSymbol of ( C76 +* C77 ));
assume L211: C78 = C79;
L212: ( dom (the Arity of C77) ) = (the carrier' of C77) by FUNCT_2:def 1;
L213: (the Arity of ( C76 +* C77 )) = ( (the Arity of C76) +* (the Arity of C77) ) by L56;
thus L214: ( the_arity_of C79 ) = ( the_arity_of C78 ) by L213 , L211 , L212 , FUNCT_4:13;
L215: ( dom (the ResultSort of C77) ) = (the carrier' of C77) by FUNCT_2:def 1;
L216: (the ResultSort of ( C76 +* C77 )) = ( (the ResultSort of C76) +* (the ResultSort of C77) ) by L56;
thus L217: thesis by L216 , L211 , L215 , FUNCT_4:13;
end;
theorem
L218: (for B38 being non  empty ManySortedSign holds (for B39 , B40 being  Circuit-like non  void non  empty ManySortedSign holds (B40 = ( B38 +* B39 ) implies (for B41 being (Vertex of B39) holds (B41 in ( InnerVertices B39 ) implies (for B42 being (Vertex of B40) holds (B41 = B42 implies (B42 in ( InnerVertices B40 ) & ( action_at B42 ) = ( action_at B41 )))))))))
proof
let C80 being non  empty ManySortedSign;
let C81 , C82 being  Circuit-like non  void non  empty ManySortedSign;
assume that
L219: C82 = ( C80 +* C81 );
let C83 being (Vertex of C81);
assume that
L220: C83 in ( InnerVertices C81 );
L221: (the carrier' of C82) = ( (the carrier' of C80) \/ (the carrier' of C81) ) by L219 , L56;
reconsider D44 = ( action_at C83 ) as (OperSymbol of C82) by L221 , XBOOLE_0:def 3;
let C84 being (Vertex of C82);
assume that
L222: C83 = C84;
L223: (the ResultSort of C82) = ( (the ResultSort of C80) +* (the ResultSort of C81) ) by L219 , L56;
L224: ( InnerVertices C81 ) c= ( InnerVertices C82 ) by L223 , FUNCT_4:18;
thus L225: C84 in ( InnerVertices C82 ) by L224 , L220 , L222;
L226: ( the_result_sort_of ( action_at C83 ) ) = C83 by L220 , MSAFREE2:def 7;
L227: C84 = ( the_result_sort_of D44 ) by L226 , L219 , L222 , L210;
thus L228: thesis by L227 , L220 , L222 , L224 , MSAFREE2:def 7;
end;
theorem
L229: (for B43 being non  void non  empty ManySortedSign holds (for B44 being non  empty ManySortedSign holds (B43 tolerates B44 implies (for B45 being (OperSymbol of B43) holds (for B46 being (OperSymbol of ( B43 +* B44 )) holds (B45 = B46 implies (( the_arity_of B46 ) = ( the_arity_of B45 ) & ( the_result_sort_of B46 ) = ( the_result_sort_of B45 ))))))))
proof
let C85 being non  void non  empty ManySortedSign;
let C86 being non  empty ManySortedSign;
assume that
L230: (the Arity of C85) tolerates (the Arity of C86)
and
L231: (the ResultSort of C85) tolerates (the ResultSort of C86);
let C87 being (OperSymbol of C85);
let C88 being (OperSymbol of ( C85 +* C86 ));
assume L232: C87 = C88;
L233: ( dom (the Arity of C85) ) = (the carrier' of C85) by FUNCT_2:def 1;
L234: (the Arity of ( C85 +* C86 )) = ( (the Arity of C85) +* (the Arity of C86) ) by L56;
thus L235: ( the_arity_of C88 ) = ( the_arity_of C87 ) by L234 , L230 , L232 , L233 , FUNCT_4:15;
L236: ( dom (the ResultSort of C85) ) = (the carrier' of C85) by FUNCT_2:def 1;
L237: (the ResultSort of ( C85 +* C86 )) = ( (the ResultSort of C85) +* (the ResultSort of C86) ) by L56;
thus L238: thesis by L237 , L231 , L232 , L236 , FUNCT_4:15;
end;
theorem
L239: (for B47 , B48 being  Circuit-like non  void non  empty ManySortedSign holds (for B49 being non  empty ManySortedSign holds ((B47 tolerates B49 & B48 = ( B47 +* B49 )) implies (for B50 being (Vertex of B47) holds (B50 in ( InnerVertices B47 ) implies (for B51 being (Vertex of B48) holds (B50 = B51 implies (B51 in ( InnerVertices B48 ) & ( action_at B51 ) = ( action_at B50 )))))))))
proof
let C89 , C90 being  Circuit-like non  void non  empty ManySortedSign;
let C91 being non  empty ManySortedSign;
assume that
L240: C89 tolerates C91
and
L241: C90 = ( C89 +* C91 );
let C92 being (Vertex of C89);
assume that
L242: C92 in ( InnerVertices C89 );
let C93 being (Vertex of C90);
assume that
L243: C92 = C93;
L244: ( InnerVertices C90 ) = ( ( InnerVertices C89 ) \/ ( InnerVertices C91 ) ) by L240 , L241 , L176;
thus L245: C93 in ( InnerVertices C90 ) by L244 , L242 , L243 , XBOOLE_0:def 3;
L246: (the carrier' of C90) = ( (the carrier' of C89) \/ (the carrier' of C91) ) by L241 , L56;
reconsider D45 = ( action_at C92 ) as (OperSymbol of C90) by L246 , XBOOLE_0:def 3;
L247: ( the_result_sort_of ( action_at C92 ) ) = C92 by L242 , MSAFREE2:def 7;
L248: C93 = ( the_result_sort_of D45 ) by L247 , L240 , L241 , L243 , L229;
thus L249: thesis by L248 , L245 , MSAFREE2:def 7;
end;
begin
definition
let C94 , C95 being non  empty ManySortedSign;
let C96 being MSAlgebra over C94;
let C97 being MSAlgebra over C95;
pred C96 tolerates C97
means
:L250: (C94 tolerates C95 & (the Sorts of C96) tolerates (the Sorts of C97) & (the Charact of C96) tolerates (the Charact of C97))
;end;
definition
let C98 , C99 being non  empty ManySortedSign;
let C100 being  non-empty MSAlgebra over C98;
let C101 being  non-empty MSAlgebra over C99;
assume L252: (the Sorts of C100) tolerates (the Sorts of C101);
func C100 +* C101 ->  strict  non-empty MSAlgebra over ( C98 +* C99 ) means 
:L253: ((the Sorts of it) = ( (the Sorts of C100) +* (the Sorts of C101) ) & (the Charact of it) = ( (the Charact of C100) +* (the Charact of C101) ));
uniqueness;
existence
proof
set D46 = ( (the Charact of C100) +* (the Charact of C101) );
set D47 = (the Sorts of C100);
set D48 = (the Sorts of C101);
set D49 = ( C98 +* C99 );
set D50 = (the carrier of D49);
set D51 = (the carrier of C98);
set D52 = (the carrier of C99);
set D53 = ( ( D47 # ) +* ( D48 # ) );
L254: ( dom ( D48 # ) ) = ( D52 * ) by PARTFUN1:def 2;
L255: (the ResultSort of D49) = ( (the ResultSort of C98) +* (the ResultSort of C99) ) by L56;
L256: ( rng (the ResultSort of C99) ) c= D52 by RELAT_1:def 19;
L257: ( dom D48 ) = D52 by PARTFUN1:def 2;
L258: (the carrier of D49) = ( (the carrier of C98) \/ (the carrier of C99) ) by L56;
reconsider D54 = ( (the Sorts of C100) +* (the Sorts of C101) ) as  non-empty (ManySortedSet of (the carrier of ( C98 +* C99 ))) by L258;
L259: ( dom ( D54 # ) ) = ( D50 * ) by PARTFUN1:def 2;
L260: D54 = ( D47 \/ D48 ) by L252 , FUNCT_4:30;
L261: ( D48 # ) c= ( D54 # ) by L260 , L17 , XBOOLE_1:7;
L262: ( dom D53 ) = ( ( D51 * ) \/ ( D52 * ) ) by PARTFUN1:def 2;
L263: ( dom D47 ) = D51 by PARTFUN1:def 2;
L264: ( rng (the ResultSort of C98) ) c= D51 by RELAT_1:def 19;
L265: ( ( D47 +* D48 ) * ( (the ResultSort of C98) +* (the ResultSort of C99) ) ) = ( ( D47 * (the ResultSort of C98) ) +* ( D48 * (the ResultSort of C99) ) ) by L264 , L252 , L263 , L257 , L256 , FUNCT_4:69;
L266: ( rng (the Arity of C99) ) c= ( D52 * ) by RELAT_1:def 19;
L267: ( dom ( D47 # ) ) = ( D51 * ) by PARTFUN1:def 2;
L268: ( D47 # ) tolerates ( D48 # )
proof
let C102 being set;
assume L269: C102 in ( ( dom ( D47 # ) ) /\ ( dom ( D48 # ) ) );
reconsider D55 = C102 as (Element of ( D51 * )) by L269 , L267 , XBOOLE_0:def 4;
reconsider D56 = C102 as (Element of ( D52 * )) by L254 , L269 , XBOOLE_0:def 4;
L270: ( rng D55 ) c= D51 by FINSEQ_1:def 4;
L271: ( rng D56 ) c= D52 by FINSEQ_1:def 4;
thus L272: ( ( D47 # ) . C102 ) = ( product ( D47 * D55 ) ) by FINSEQ_2:def 5
.= ( product ( D48 * D56 ) ) by L252 , L263 , L257 , L270 , L271 , PARTFUN1:79
.= ( ( D48 # ) . C102 ) by FINSEQ_2:def 5;
end;
L273: D53 = ( ( D47 # ) \/ ( D48 # ) ) by L268 , FUNCT_4:30;
L274: ( D47 # ) c= ( D54 # ) by L260 , L17 , XBOOLE_1:7;
L275: D53 c= ( D54 # ) by L274 , L273 , L261 , XBOOLE_1:8;
L276: (the carrier' of D49) = ( (the carrier' of C98) \/ (the carrier' of C99) ) by L56;
L277: ( rng (the Arity of D49) ) c= ( D50 * ) by RELAT_1:def 19;
L278: ( rng (the Arity of C98) ) c= ( D51 * ) by RELAT_1:def 19;
L279: ( ( rng (the Arity of C98) ) \/ ( rng (the Arity of C99) ) ) c= ( ( D51 * ) \/ ( D52 * ) ) by L278 , L266 , XBOOLE_1:13;
L280: (the Arity of D49) = ( (the Arity of C98) +* (the Arity of C99) ) by L56;
L281: ( rng (the Arity of D49) ) c= ( ( rng (the Arity of C98) ) \/ ( rng (the Arity of C99) ) ) by L280 , FUNCT_4:17;
L282: ( rng (the Arity of D49) ) c= ( dom D53 ) by L281 , L279 , L262 , XBOOLE_1:1;
L283: D53 tolerates ( D54 # ) by L275 , PARTFUN1:54;
L284: ( ( ( D47 # ) +* ( D48 # ) ) * ( (the Arity of C98) +* (the Arity of C99) ) ) = ( ( ( D47 # ) * (the Arity of C98) ) +* ( ( D48 # ) * (the Arity of C99) ) ) by L267 , L254 , L278 , L266 , L268 , FUNCT_4:69;
reconsider D57 = D46 as (ManySortedFunction of ( ( D54 # ) * (the Arity of D49) ) , ( D54 * (the ResultSort of D49) )) by L276 , L280 , L255 , L259 , L277 , L282 , L265 , L283 , L284 , PARTFUN1:79;
reconsider D58 = MSAlgebra (# D54 , D57 #) as  strict  non-empty MSAlgebra over D49 by MSUALG_1:def 3;
take D58;
thus L285: thesis;
end;
end;
theorem
L287: (for B52 being non  void non  empty ManySortedSign holds (for B53 being MSAlgebra over B52 holds B53 tolerates B53))
proof
let C103 being non  void non  empty ManySortedSign;
let C104 being MSAlgebra over C103;
thus L288: C103 tolerates C103;
thus L289: thesis;
end;
theorem
L290: (for B54 , B55 being non  void non  empty ManySortedSign holds (for B56 being MSAlgebra over B54 holds (for B57 being MSAlgebra over B55 holds (B56 tolerates B57 implies B57 tolerates B56))))
proof
let C105 , C106 being non  void non  empty ManySortedSign;
let C107 being MSAlgebra over C105;
let C108 being MSAlgebra over C106;
assume that
L291: C105 tolerates C106
and
L292: (the Sorts of C107) tolerates (the Sorts of C108)
and
L293: (the Charact of C107) tolerates (the Charact of C108);
thus L294: (C106 tolerates C105 & (the Sorts of C108) tolerates (the Sorts of C107) & (the Charact of C108) tolerates (the Charact of C107)) by L291 , L292 , L293;
end;
theorem
L295: (for B58 , B59 , B60 being non  empty ManySortedSign holds (for B61 being  non-empty MSAlgebra over B58 holds (for B62 being  non-empty MSAlgebra over B59 holds (for B63 being MSAlgebra over B60 holds ((B61 tolerates B62 & B62 tolerates B63 & B63 tolerates B61) implies ( B61 +* B62 ) tolerates B63)))))
proof
let C109 , C110 , C111 being non  empty ManySortedSign;
let C112 being  non-empty MSAlgebra over C109;
let C113 being  non-empty MSAlgebra over C110;
let C114 being MSAlgebra over C111;
assume that
L296: C109 tolerates C110
and
L297: (the Sorts of C112) tolerates (the Sorts of C113)
and
L298: (the Charact of C112) tolerates (the Charact of C113)
and
L299: C110 tolerates C111
and
L300: (the Sorts of C113) tolerates (the Sorts of C114)
and
L301: (the Charact of C113) tolerates (the Charact of C114)
and
L302: C111 tolerates C109
and
L303: (the Sorts of C114) tolerates (the Sorts of C112)
and
L304: (the Charact of C114) tolerates (the Charact of C112);
thus L305: ( C109 +* C110 ) tolerates C111 by L296 , L299 , L302 , L83;
L306: (the Sorts of ( C112 +* C113 )) = ( (the Sorts of C112) +* (the Sorts of C113) ) by L297 , L253;
thus L307: (the Sorts of ( C112 +* C113 )) tolerates (the Sorts of C114) by L306 , L297 , L300 , L303 , FUNCT_4:125;
L308: (the Charact of ( C112 +* C113 )) = ( (the Charact of C112) +* (the Charact of C113) ) by L297 , L253;
thus L309: thesis by L308 , L298 , L301 , L304 , FUNCT_4:125;
end;
theorem
L310: (for B64 being  strict non  empty ManySortedSign holds (for B65 being  non-empty MSAlgebra over B64 holds ( B65 +* B65 ) = ( the MSAlgebra of B65 )))
proof
let C115 being  strict non  empty ManySortedSign;
let C116 being  non-empty MSAlgebra over C115;
set D59 = ( the MSAlgebra of C116 );
set D60 = (the Sorts of D59);
set D61 = (the Charact of D59);
set D62 = (the Sorts of ( C116 +* C116 ));
set D63 = (the Charact of ( C116 +* C116 ));
L311: D61 = ( D61 +* D61 );
L312: D63 = D61 by L311 , L253;
L313: D60 = ( D60 +* D60 );
L314: D62 = D60 by L313 , L253;
thus L315: thesis by L314 , L312;
end;
theorem
L316: (for B66 , B67 being non  empty ManySortedSign holds (for B68 being  non-empty MSAlgebra over B66 holds (for B69 being  non-empty MSAlgebra over B67 holds (B68 tolerates B69 implies ( B68 +* B69 ) = ( B69 +* B68 )))))
proof
let C117 , C118 being non  empty ManySortedSign;
let C119 being  non-empty MSAlgebra over C117;
let C120 being  non-empty MSAlgebra over C118;
set D64 = ( C119 +* C120 );
assume that
L317: C117 tolerates C118
and
L318: (the Sorts of C119) tolerates (the Sorts of C120)
and
L319: (the Charact of C119) tolerates (the Charact of C120);
L320: ( (the Sorts of C119) +* (the Sorts of C120) ) = ( (the Sorts of C120) +* (the Sorts of C119) ) by L318 , FUNCT_4:34;
L321: (the Sorts of D64) = ( (the Sorts of C120) +* (the Sorts of C119) ) by L320 , L318 , L253;
L322: ( (the Charact of C119) +* (the Charact of C120) ) = ( (the Charact of C120) +* (the Charact of C119) ) by L319 , FUNCT_4:34;
L323: (the Charact of D64) = ( (the Charact of C120) +* (the Charact of C119) ) by L322 , L318 , L253;
L324: ( C117 +* C118 ) = ( C118 +* C117 ) by L317 , L100;
thus L325: thesis by L324 , L318 , L321 , L323 , L253;
end;
theorem
L326: (for B70 , B71 , B72 being non  empty ManySortedSign holds (for B73 being  non-empty MSAlgebra over B70 holds (for B74 being  non-empty MSAlgebra over B71 holds (for B75 being  non-empty MSAlgebra over B72 holds (((the Sorts of B73) tolerates (the Sorts of B74) & (the Sorts of B74) tolerates (the Sorts of B75) & (the Sorts of B75) tolerates (the Sorts of B73)) implies ( ( B73 +* B74 ) +* B75 ) = ( B73 +* ( B74 +* B75 ) ))))))
proof
let C121 , C122 , C123 being non  empty ManySortedSign;
let C124 being  non-empty MSAlgebra over C121;
let C125 being  non-empty MSAlgebra over C122;
let C126 being  non-empty MSAlgebra over C123;
assume that
L327: (the Sorts of C124) tolerates (the Sorts of C125)
and
L328: (the Sorts of C125) tolerates (the Sorts of C126)
and
L329: (the Sorts of C126) tolerates (the Sorts of C124);
set D65 = ( C124 +* C125 );
set D66 = ( C125 +* C126 );
L330: (the Charact of D65) = ( (the Charact of C124) +* (the Charact of C125) ) by L327 , L253;
set D67 = ( D65 +* C126 );
set D68 = ( C124 +* D66 );
set D69 = (the Sorts of C124);
set D70 = (the Sorts of C125);
set D71 = (the Sorts of C126);
L331: (the Sorts of D66) = ( (the Sorts of C125) +* (the Sorts of C126) ) by L328 , L253;
L332: (the Sorts of C124) tolerates (the Sorts of D66)
proof
let C127 being set;
assume L333: C127 in ( ( dom D69 ) /\ ( dom (the Sorts of D66) ) );
L334: C127 in ( dom (the Sorts of D66) ) by L333 , XBOOLE_0:def 4;
L335: (C127 in ( dom D70 ) or C127 in ( dom D71 )) by L334 , L331 , FUNCT_4:12;
L336: C127 in ( dom D69 ) by L333 , XBOOLE_0:def 4;
L337: ((C127 in ( ( dom D69 ) /\ ( dom D70 ) ) & ( ( D70 +* D71 ) . C127 ) = ( D70 . C127 )) or (C127 in ( ( dom D71 ) /\ ( dom D69 ) ) & ( ( D70 +* D71 ) . C127 ) = ( D71 . C127 ))) by L336 , L328 , L335 , FUNCT_4:13 , FUNCT_4:15 , XBOOLE_0:def 4;
thus L338: thesis by L337 , L327 , L329 , L331 , PARTFUN1:def 4;
end;
L339: (the Sorts of D68) = ( (the Sorts of C124) +* (the Sorts of D66) ) by L332 , L253;
L340: (the Charact of D66) = ( (the Charact of C125) +* (the Charact of C126) ) by L328 , L253;
L341: (the Charact of D68) = ( (the Charact of C124) +* (the Charact of D66) ) by L332 , L253;
L342: (the Sorts of D65) = ( (the Sorts of C124) +* (the Sorts of C125) ) by L327 , L253;
L343: (the Sorts of D65) tolerates (the Sorts of C126)
proof
let C128 being set;
assume L344: C128 in ( ( dom (the Sorts of D65) ) /\ ( dom D71 ) );
L345: C128 in ( dom (the Sorts of D65) ) by L344 , XBOOLE_0:def 4;
L346: (C128 in ( dom D69 ) or C128 in ( dom D70 )) by L345 , L342 , FUNCT_4:12;
L347: C128 in ( dom D71 ) by L344 , XBOOLE_0:def 4;
L348: ((C128 in ( ( dom D71 ) /\ ( dom D69 ) ) & ( ( D69 +* D70 ) . C128 ) = ( D69 . C128 )) or (C128 in ( ( dom D70 ) /\ ( dom D71 ) ) & ( ( D69 +* D70 ) . C128 ) = ( D70 . C128 ))) by L347 , L327 , L346 , FUNCT_4:13 , FUNCT_4:15 , XBOOLE_0:def 4;
thus L349: thesis by L348 , L328 , L329 , L342 , PARTFUN1:def 4;
end;
L350: (the Charact of D67) = ( (the Charact of D65) +* (the Charact of C126) ) by L343 , L253;
L351: (the Charact of D67) = (the Charact of D68) by L350 , L330 , L340 , L341 , FUNCT_4:14;
L352: (the Sorts of D67) = ( (the Sorts of D65) +* (the Sorts of C126) ) by L343 , L253;
L353: (the Sorts of D67) = (the Sorts of D68) by L352 , L342 , L331 , L339 , FUNCT_4:14;
thus L354: thesis by L353 , L351;
end;
theorem
L355: (for B76 , B77 being non  empty ManySortedSign holds (for B78 being  finite-yielding  non-empty MSAlgebra over B76 holds (for B79 being  finite-yielding  non-empty MSAlgebra over B77 holds ((the Sorts of B78) tolerates (the Sorts of B79) implies ( B78 +* B79 ) is  finite-yielding))))
proof
let C129 , C130 being non  empty ManySortedSign;
let C131 being  finite-yielding  non-empty MSAlgebra over C129;
let C132 being  finite-yielding  non-empty MSAlgebra over C130;
assume that
L356: (the Sorts of C131) tolerates (the Sorts of C132);
let C133 being set;
set D72 = ( C131 +* C132 );
set D73 = (the Sorts of D72);
set D74 = (the Sorts of C131);
set D75 = (the Sorts of C132);
L357: ( dom D74 ) = (the carrier of C129) by PARTFUN1:def 2;
L358: D74 is  finite-yielding by MSAFREE2:def 11;
assume L359: C133 in (the carrier of ( C129 +* C130 ));
reconsider D76 = C133 as (Vertex of ( C129 +* C130 )) by L359;
L360: ( dom D75 ) = (the carrier of C130) by PARTFUN1:def 2;
L361: (the carrier of ( C129 +* C130 )) = ( (the carrier of C129) \/ (the carrier of C130) ) by L56;
L362: (D76 in (the carrier of C129) or D76 in (the carrier of C130)) by L361 , XBOOLE_0:def 3;
L363: D75 is  finite-yielding by MSAFREE2:def 11;
L364: D73 = ( D74 +* D75 ) by L356 , L253;
L365: ((( D73 . D76 ) = ( D74 . D76 ) & ( D74 . D76 ) is  finite) or (( D73 . D76 ) = ( D75 . D76 ) & ( D75 . D76 ) is  finite)) by L364 , L356 , L357 , L360 , L362 , L358 , L363 , FUNCT_4:13 , FUNCT_4:15;
thus L366: thesis by L365;
end;
theorem
L367: (for B80 , B81 being non  empty ManySortedSign holds (for B82 being  non-empty MSAlgebra over B80 holds (for B83 being (Element of ( product (the Sorts of B82) )) holds (for B84 being  non-empty MSAlgebra over B81 holds (for B85 being (Element of ( product (the Sorts of B84) )) holds ((the Sorts of B82) tolerates (the Sorts of B84) implies ( B83 +* B85 ) in ( product (the Sorts of ( B82 +* B84 )) )))))))
proof
let C134 , C135 being non  empty ManySortedSign;
let C136 being  non-empty MSAlgebra over C134;
let C137 being (Element of ( product ((the Sorts of C136) qua  non-empty (ManySortedSet of (the carrier of C134))) ));
let C138 being  non-empty MSAlgebra over C135;
let C139 being (Element of ( product ((the Sorts of C138) qua  non-empty (ManySortedSet of (the carrier of C135))) ));
assume L368: (the Sorts of C136) tolerates (the Sorts of C138);
L369: (the Sorts of ( C136 +* C138 )) = ( (the Sorts of C136) +* (the Sorts of C138) ) by L368 , L253;
thus L370: thesis by L369 , CARD_3:97;
end;
theorem
L371: (for B86 , B87 being non  empty ManySortedSign holds (for B88 being  non-empty MSAlgebra over B86 holds (for B89 being  non-empty MSAlgebra over B87 holds ((the Sorts of B88) tolerates (the Sorts of B89) implies (for B90 being (Element of ( product (the Sorts of ( B88 +* B89 )) )) holds (( B90 | (the carrier of B86) ) in ( product (the Sorts of B88) ) & ( B90 | (the carrier of B87) ) in ( product (the Sorts of B89) )))))))
proof
let C140 , C141 being non  empty ManySortedSign;
let C142 being  non-empty MSAlgebra over C140;
let C143 being  non-empty MSAlgebra over C141;
L372: ( dom (the Sorts of C142) ) = (the carrier of C140) by PARTFUN1:def 2;
L373: ( dom (the Sorts of C143) ) = (the carrier of C141) by PARTFUN1:def 2;
assume L374: (the Sorts of C142) tolerates (the Sorts of C143);
L375: (the Sorts of ( C142 +* C143 )) = ( (the Sorts of C142) +* (the Sorts of C143) ) by L374 , L253;
thus L376: thesis by L375 , L374 , L372 , L373 , CARD_3:98 , CARD_3:99;
end;
theorem
L377: (for B91 , B92 being non  void non  empty ManySortedSign holds (for B93 being  non-empty MSAlgebra over B91 holds (for B94 being  non-empty MSAlgebra over B92 holds ((the Sorts of B93) tolerates (the Sorts of B94) implies (for B95 being (OperSymbol of ( B91 +* B92 )) holds (for B96 being (OperSymbol of B92) holds (B95 = B96 implies ( Den (B95 , ( B93 +* B94 )) ) = ( Den (B96 , B94) ))))))))
proof
let C144 , C145 being non  void non  empty ManySortedSign;
let C146 being  non-empty MSAlgebra over C144;
let C147 being  non-empty MSAlgebra over C145;
L378: ( dom (the Charact of C147) ) = (the carrier' of C145) by PARTFUN1:def 2;
assume L379: (the Sorts of C146) tolerates (the Sorts of C147);
L380: (the Charact of ( C146 +* C147 )) = ( (the Charact of C146) +* (the Charact of C147) ) by L379 , L253;
let C148 being (OperSymbol of ( C144 +* C145 ));
let C149 being (OperSymbol of C145);
assume L381: C148 = C149;
thus L382: thesis by L381 , L380 , L378 , FUNCT_4:13;
end;
theorem
L383: (for B97 , B98 being non  void non  empty ManySortedSign holds (for B99 being  non-empty MSAlgebra over B97 holds (for B100 being  non-empty MSAlgebra over B98 holds (((the Sorts of B99) tolerates (the Sorts of B100) & (the Charact of B99) tolerates (the Charact of B100)) implies (for B101 being (OperSymbol of ( B97 +* B98 )) holds (for B102 being (OperSymbol of B97) holds (B101 = B102 implies ( Den (B101 , ( B99 +* B100 )) ) = ( Den (B102 , B99) ))))))))
proof
let C150 , C151 being non  void non  empty ManySortedSign;
let C152 being  non-empty MSAlgebra over C150;
let C153 being  non-empty MSAlgebra over C151;
L384: ( dom (the Charact of C152) ) = (the carrier' of C150) by PARTFUN1:def 2;
assume L385: (the Sorts of C152) tolerates (the Sorts of C153);
L386: (the Charact of ( C152 +* C153 )) = ( (the Charact of C152) +* (the Charact of C153) ) by L385 , L253;
assume L387: (the Charact of C152) tolerates (the Charact of C153);
let C154 being (OperSymbol of ( C150 +* C151 ));
let C155 being (OperSymbol of C150);
assume L388: C154 = C155;
thus L389: thesis by L388 , L386 , L387 , L384 , FUNCT_4:15;
end;
theorem
L390: (for B103 , B104 , B105 being non  void  Circuit-like non  empty ManySortedSign holds (B105 = ( B103 +* B104 ) implies (for B106 being  non-empty (Circuit of B103) holds (for B107 being  non-empty (Circuit of B104) holds (for B108 being  non-empty (Circuit of B105) holds (for B109 being (State of B108) holds (for B110 being (State of B107) holds (B110 = ( B109 | (the carrier of B104) ) implies (for B111 being (Gate of B105) holds (for B112 being (Gate of B104) holds (B111 = B112 implies ( B111 depends_on_in B109 ) = ( B112 depends_on_in B110 ))))))))))))
proof
let C156 , C157 , C158 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L391: C158 = ( C156 +* C157 );
let C159 being  non-empty (Circuit of C156);
let C160 being  non-empty (Circuit of C157);
let C161 being  non-empty (Circuit of C158);
let C162 being (State of C161);
let C163 being (State of C160);
assume that
L392: C163 = ( C162 | (the carrier of C157) );
let C164 being (OperSymbol of C158);
let C165 being (OperSymbol of C157);
assume that
L393: C164 = C165;
L394: ( (the carrier of C157) |` ( the_arity_of C165 ) ) = ( the_arity_of C165 );
thus L395: ( C164 depends_on_in C162 ) = ( C162 * ( the_arity_of C164 ) ) by CIRCUIT1:def 3
.= ( C162 * ( the_arity_of C165 ) ) by L391 , L393 , L210
.= ( C163 * ( the_arity_of C165 ) ) by L392 , L394 , MONOID_1:1
.= ( C165 depends_on_in C163 ) by CIRCUIT1:def 3;
end;
theorem
L396: (for B113 , B114 , B115 being non  void  Circuit-like non  empty ManySortedSign holds ((B115 = ( B113 +* B114 ) & B113 tolerates B114) implies (for B116 being  non-empty (Circuit of B113) holds (for B117 being  non-empty (Circuit of B114) holds (for B118 being  non-empty (Circuit of B115) holds (for B119 being (State of B118) holds (for B120 being (State of B116) holds (B120 = ( B119 | (the carrier of B113) ) implies (for B121 being (Gate of B115) holds (for B122 being (Gate of B113) holds (B121 = B122 implies ( B121 depends_on_in B119 ) = ( B122 depends_on_in B120 ))))))))))))
proof
let C166 , C167 , C168 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L397: C168 = ( C166 +* C167 )
and
L398: C166 tolerates C167;
let C169 being  non-empty (Circuit of C166);
let C170 being  non-empty (Circuit of C167);
let C171 being  non-empty (Circuit of C168);
let C172 being (State of C171);
let C173 being (State of C169);
assume that
L399: C173 = ( C172 | (the carrier of C166) );
let C174 being (Gate of C168);
let C175 being (Gate of C166);
assume that
L400: C174 = C175;
L401: ( (the carrier of C166) |` ( the_arity_of C175 ) ) = ( the_arity_of C175 );
thus L402: ( C174 depends_on_in C172 ) = ( C172 * ( the_arity_of C174 ) ) by CIRCUIT1:def 3
.= ( C172 * ( the_arity_of C175 ) ) by L397 , L398 , L400 , L229
.= ( C173 * ( the_arity_of C175 ) ) by L399 , L401 , MONOID_1:1
.= ( C175 depends_on_in C173 ) by CIRCUIT1:def 3;
end;
theorem
L403: (for B123 , B124 , B125 being non  void  Circuit-like non  empty ManySortedSign holds (B125 = ( B123 +* B124 ) implies (for B126 being  non-empty (Circuit of B123) holds (for B127 being  non-empty (Circuit of B124) holds (for B128 being  non-empty (Circuit of B125) holds ((B126 tolerates B127 & B128 = ( B126 +* B127 )) implies (for B129 being (State of B128) holds (for B130 being (Vertex of B125) holds ((for B131 being (State of B126) holds (B131 = ( B129 | (the carrier of B123) ) implies ((B130 in ( InnerVertices B123 ) or (B130 in (the carrier of B123) & B130 in ( InputVertices B125 ))) implies ( ( Following B129 ) . B130 ) = ( ( Following B131 ) . B130 )))) & (for B132 being (State of B127) holds (B132 = ( B129 | (the carrier of B124) ) implies ((B130 in ( InnerVertices B124 ) or (B130 in (the carrier of B124) & B130 in ( InputVertices B125 ))) implies ( ( Following B129 ) . B130 ) = ( ( Following B132 ) . B130 )))))))))))))
proof
let C176 , C177 , C178 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L404: C178 = ( C176 +* C177 );
let C179 being  non-empty (Circuit of C176);
let C180 being  non-empty (Circuit of C177);
let C181 being  non-empty (Circuit of C178);
assume that
L405: C176 tolerates C177
and
L406: (the Sorts of C179) tolerates (the Sorts of C180)
and
L407: (the Charact of C179) tolerates (the Charact of C180)
and
L408: C181 = ( C179 +* C180 );
let C182 being (State of C181);
let C183 being (Vertex of C178);
thus L409:now
let C184 being (State of C179);
assume that
L410: C184 = ( C182 | (the carrier of C176) );
L411:
now
assume L412: C183 in ( InnerVertices C176 );
reconsider D77 = C183 as (Element of ( InnerVertices C176 )) by L412;
L413: ( ( Following C184 ) . D77 ) = ( ( Den (( action_at D77 ) , C179) ) . ( ( action_at D77 ) depends_on_in C184 ) ) by CIRCUIT2:def 5;
L414: D77 in ( InnerVertices C178 ) by L404 , L405 , L239;
L415: ( ( Following C182 ) . C183 ) = ( ( Den (( action_at C183 ) , C181) ) . ( ( action_at C183 ) depends_on_in C182 ) ) by L414 , CIRCUIT2:def 5;
L416: ( action_at C183 ) = ( action_at D77 ) by L404 , L405 , L239;
L417: ( Den (( action_at D77 ) , C179) ) = ( Den (( action_at C183 ) , C181) ) by L416 , L404 , L406 , L407 , L408 , L383;
thus L418: ( ( Following C182 ) . C183 ) = ( ( Following C184 ) . C183 ) by L417 , L404 , L405 , L410 , L416 , L415 , L413 , L396;
end;
L419:
now
assume that
L420: C183 in (the carrier of C176)
and
L421: C183 in ( InputVertices C178 );
reconsider D78 = C183 as (Vertex of C176) by L420;
L422: D78 in ( InputVertices C176 ) by L404 , L405 , L421 , L201;
L423: ( ( Following C184 ) . D78 ) = ( C184 . D78 ) by L422 , CIRCUIT2:def 5;
L424: ( dom C184 ) = (the carrier of C176) by CIRCUIT1:3;
L425: ( ( Following C182 ) . C183 ) = ( C182 . C183 ) by L421 , CIRCUIT2:def 5;
thus L426: ( ( Following C182 ) . C183 ) = ( ( Following C184 ) . C183 ) by L425 , L410 , L423 , L424 , FUNCT_1:47;
end;
thus L427: ((C183 in ( InnerVertices C176 ) or (C183 in (the carrier of C176) & C183 in ( InputVertices C178 ))) implies ( ( Following C182 ) . C183 ) = ( ( Following C184 ) . C183 )) by L419 , L411;
end;
let C185 being (State of C180);
assume that
L428: C185 = ( C182 | (the carrier of C177) );
L429:
now
assume L430: C183 in ( InnerVertices C177 );
reconsider D79 = C183 as (Element of ( InnerVertices C177 )) by L430;
L431: ( ( Following C185 ) . D79 ) = ( ( Den (( action_at D79 ) , C180) ) . ( ( action_at D79 ) depends_on_in C185 ) ) by CIRCUIT2:def 5;
L432: D79 in ( InnerVertices C178 ) by L404 , L218;
L433: ( ( Following C182 ) . C183 ) = ( ( Den (( action_at C183 ) , C181) ) . ( ( action_at C183 ) depends_on_in C182 ) ) by L432 , CIRCUIT2:def 5;
L434: ( action_at C183 ) = ( action_at D79 ) by L404 , L218;
L435: ( Den (( action_at D79 ) , C180) ) = ( Den (( action_at C183 ) , C181) ) by L434 , L404 , L406 , L408 , L377;
thus L436: ( ( Following C182 ) . C183 ) = ( ( Following C185 ) . C183 ) by L435 , L404 , L428 , L434 , L433 , L431 , L390;
end;
L437:
now
assume that
L438: C183 in (the carrier of C177)
and
L439: C183 in ( InputVertices C178 );
reconsider D80 = C183 as (Vertex of C177) by L438;
L440: D80 in ( InputVertices C177 ) by L404 , L439 , L195;
L441: ( ( Following C185 ) . D80 ) = ( C185 . D80 ) by L440 , CIRCUIT2:def 5;
L442: ( dom C185 ) = (the carrier of C177) by CIRCUIT1:3;
L443: ( ( Following C182 ) . C183 ) = ( C182 . C183 ) by L439 , CIRCUIT2:def 5;
thus L444: ( ( Following C182 ) . C183 ) = ( ( Following C185 ) . C183 ) by L443 , L428 , L441 , L442 , FUNCT_1:47;
end;
thus L445: thesis by L437 , L429;
end;
theorem
L446: (for B133 , B134 , B135 being non  void  Circuit-like non  empty ManySortedSign holds ((( InnerVertices B133 ) misses ( InputVertices B134 ) & B135 = ( B133 +* B134 )) implies (for B136 being  non-empty (Circuit of B133) holds (for B137 being  non-empty (Circuit of B134) holds (for B138 being  non-empty (Circuit of B135) holds ((B136 tolerates B137 & B138 = ( B136 +* B137 )) implies (for B139 being (State of B138) holds (for B140 being (State of B136) holds (for B141 being (State of B137) holds ((B140 = ( B139 | (the carrier of B133) ) & B141 = ( B139 | (the carrier of B134) )) implies ( Following B139 ) = ( ( Following B140 ) +* ( Following B141 ) )))))))))))
proof
let C186 , C187 , C188 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L447: ( InnerVertices C186 ) misses ( InputVertices C187 )
and
L448: C188 = ( C186 +* C187 );
L449: (the carrier of C188) = ( (the carrier of C186) \/ (the carrier of C187) ) by L448 , L56;
let C189 being  non-empty (Circuit of C186);
let C190 being  non-empty (Circuit of C187);
let C191 being  non-empty (Circuit of C188);
assume that
L450: C189 tolerates C190
and
L451: C191 = ( C189 +* C190 );
let C192 being (State of C191);
let C193 being (State of C189);
let C194 being (State of C190);
assume that
L452: C193 = ( C192 | (the carrier of C186) )
and
L453: C194 = ( C192 | (the carrier of C187) );
L454: ( dom ( Following C194 ) ) = (the carrier of C187) by CIRCUIT1:3;
L455: ( dom ( Following C193 ) ) = (the carrier of C186) by CIRCUIT1:3;
L456:
now
let C195 being set;
assume L457: C195 in ( ( dom ( Following C193 ) ) \/ ( dom ( Following C194 ) ) );
reconsider D81 = C195 as (Vertex of C188) by L457 , L448 , L455 , L454 , L56;
thus L458:now
assume L459: C195 in ( dom ( Following C194 ) );
reconsider D82 = C195 as (Vertex of C187) by L459 , CIRCUIT1:3;
L460:
now
L461: (the ResultSort of C188) = ( (the ResultSort of C186) +* (the ResultSort of C187) ) by L448 , L56;
L462: ( rng (the ResultSort of C188) ) c= ( ( rng (the ResultSort of C186) ) \/ ( rng (the ResultSort of C187) ) ) by L461 , FUNCT_4:17;
assume L463: D82 in ( InputVertices C187 );
L464: (not D82 in ( rng (the ResultSort of C187) )) by L463 , XBOOLE_0:def 5;
L465: (not D82 in ( rng (the ResultSort of C186) )) by L447 , L463 , XBOOLE_0:3;
L466: (not D81 in ( rng (the ResultSort of C188) )) by L465 , L464 , L462 , XBOOLE_0:def 3;
thus L467: D81 in ( InputVertices C188 ) by L466 , XBOOLE_0:def 5;
end;
L468: ( ( InputVertices C187 ) \/ ( InnerVertices C187 ) ) = (the carrier of C187) by XBOOLE_1:45;
L469: (D82 in ( InnerVertices C187 ) or D82 in ( InputVertices C187 )) by L468 , XBOOLE_0:def 3;
L470: (D81 in ( InnerVertices C187 ) or (D81 in (the carrier of C187) & D81 in ( InputVertices C188 ))) by L469 , L460;
thus L471: ( ( Following C192 ) . C195 ) = ( ( Following C194 ) . C195 ) by L470 , L448 , L450 , L451 , L453 , L403;
end;
assume L472: (not C195 in ( dom ( Following C194 ) ));
reconsider D83 = D81 as (Vertex of C186) by L472 , L449 , L454 , XBOOLE_0:def 3;
L473: ( rng (the ResultSort of C187) ) c= (the carrier of C187) by RELAT_1:def 19;
L474: (not D83 in ( rng (the ResultSort of C187) )) by L473 , L454 , L472;
L475:
now
assume L476: D83 in ( InputVertices C186 );
L477: (not D83 in ( rng (the ResultSort of C186) )) by L476 , XBOOLE_0:def 5;
L478: (the ResultSort of C188) = ( (the ResultSort of C186) +* (the ResultSort of C187) ) by L448 , L56;
L479: ( rng (the ResultSort of C188) ) c= ( ( rng (the ResultSort of C186) ) \/ ( rng (the ResultSort of C187) ) ) by L478 , FUNCT_4:17;
L480: (not D81 in ( rng (the ResultSort of C188) )) by L479 , L474 , L477 , XBOOLE_0:def 3;
thus L481: D81 in ( InputVertices C188 ) by L480 , XBOOLE_0:def 5;
end;
L482: ( ( InputVertices C186 ) \/ ( InnerVertices C186 ) ) = (the carrier of C186) by XBOOLE_1:45;
L483: (D83 in ( InnerVertices C186 ) or D83 in ( InputVertices C186 )) by L482 , XBOOLE_0:def 3;
thus L484: ( ( Following C192 ) . C195 ) = ( ( Following C193 ) . C195 ) by L483 , L448 , L450 , L451 , L452 , L475 , L403;
end;
L485: ( dom ( Following C192 ) ) = (the carrier of C188) by CIRCUIT1:3;
thus L486: thesis by L485 , L449 , L455 , L454 , L456 , FUNCT_4:def 1;
end;
theorem
L487: (for B142 , B143 , B144 being non  void  Circuit-like non  empty ManySortedSign holds ((( InnerVertices B143 ) misses ( InputVertices B142 ) & B144 = ( B142 +* B143 )) implies (for B145 being  non-empty (Circuit of B142) holds (for B146 being  non-empty (Circuit of B143) holds (for B147 being  non-empty (Circuit of B144) holds ((B145 tolerates B146 & B147 = ( B145 +* B146 )) implies (for B148 being (State of B147) holds (for B149 being (State of B145) holds (for B150 being (State of B146) holds ((B149 = ( B148 | (the carrier of B142) ) & B150 = ( B148 | (the carrier of B143) )) implies ( Following B148 ) = ( ( Following B150 ) +* ( Following B149 ) )))))))))))
proof
let C196 , C197 , C198 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L488: ( InnerVertices C197 ) misses ( InputVertices C196 )
and
L489: C198 = ( C196 +* C197 );
let C199 being  non-empty (Circuit of C196);
let C200 being  non-empty (Circuit of C197);
let C201 being  non-empty (Circuit of C198);
assume that
L490: C199 tolerates C200
and
L491: C201 = ( C199 +* C200 );
L492: C196 tolerates C197 by L490 , L250;
L493: C198 = ( C197 +* C196 ) by L492 , L489 , L100;
L494: C201 = ( C200 +* C199 ) by L490 , L491 , L316;
thus L495: thesis by L494 , L488 , L490 , L493 , L290 , L446;
end;
theorem
L496: (for B151 , B152 , B153 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B151 ) c= ( InputVertices B152 ) & B153 = ( B151 +* B152 )) implies (for B154 being  non-empty (Circuit of B151) holds (for B155 being  non-empty (Circuit of B152) holds (for B156 being  non-empty (Circuit of B153) holds ((B154 tolerates B155 & B156 = ( B154 +* B155 )) implies (for B157 being (State of B156) holds (for B158 being (State of B154) holds (for B159 being (State of B155) holds ((B158 = ( B157 | (the carrier of B151) ) & B159 = ( B157 | (the carrier of B152) )) implies ( Following B157 ) = ( ( Following B159 ) +* ( Following B158 ) )))))))))))
proof
let C202 , C203 , C204 being non  void  Circuit-like non  empty ManySortedSign;
assume L497: ( InputVertices C202 ) c= ( InputVertices C203 );
L498: ( InnerVertices C203 ) misses ( InputVertices C202 ) by L497 , XBOOLE_1:63 , XBOOLE_1:79;
thus L499: thesis by L498 , L487;
end;
theorem
L500: (for B160 , B161 , B162 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B161 ) c= ( InputVertices B160 ) & B162 = ( B160 +* B161 )) implies (for B163 being  non-empty (Circuit of B160) holds (for B164 being  non-empty (Circuit of B161) holds (for B165 being  non-empty (Circuit of B162) holds ((B163 tolerates B164 & B165 = ( B163 +* B164 )) implies (for B166 being (State of B165) holds (for B167 being (State of B163) holds (for B168 being (State of B164) holds ((B167 = ( B166 | (the carrier of B160) ) & B168 = ( B166 | (the carrier of B161) )) implies ( Following B166 ) = ( ( Following B167 ) +* ( Following B168 ) )))))))))))
proof
let C205 , C206 , C207 being non  void  Circuit-like non  empty ManySortedSign;
assume L501: ( InputVertices C206 ) c= ( InputVertices C205 );
L502: ( InnerVertices C205 ) misses ( InputVertices C206 ) by L501 , XBOOLE_1:63 , XBOOLE_1:79;
thus L503: thesis by L502 , L446;
end;
begin
definition
let C208 being set;
let C209 being FinSequence;
let C210 being set;
func 1GateCircStr (C209 , C208 , C210) -> non  void  strict ManySortedSign means 
:L504: ((the carrier of it) = ( ( rng C209 ) \/ { C210 } ) & (the carrier' of it) = { [ C209 , C208 ] } & ( (the Arity of it) . [ C209 , C208 ] ) = C209 & ( (the ResultSort of it) . [ C209 , C208 ] ) = C210);
existence
proof
set D84 = [ C209 , C208 ];
reconsider D85 = ( ( rng C209 ) \/ { C210 } ) as non  empty set;
L505: C210 in { C210 } by TARSKI:def 1;
reconsider D86 = C210 as (Element of D85) by L505 , XBOOLE_0:def 3;
L506: ( rng C209 ) c= D85 by XBOOLE_1:7;
L507: C209 is (FinSequence of D85) by L506 , FINSEQ_1:def 4;
reconsider D87 = C209 as (Element of ( D85 * )) by L507 , FINSEQ_1:def 11;
reconsider D88 = ( { D84 } --> D86 ) as (Function of { D84 } , D85);
reconsider D89 = ( { D84 } --> D87 ) as (Function of { D84 } , ( D85 * ));
reconsider D90 = ManySortedSign (# D85 , { D84 } , D89 , D88 #) as non  void  strict ManySortedSign;
take D90;
L508: D84 in { D84 } by TARSKI:def 1;
thus L509: thesis by L508 , FUNCOP_1:7;
end;
uniqueness
proof
let C211 , C212 being non  void  strict ManySortedSign;
assume L510: (not thesis);
L511: ( dom (the Arity of C211) ) = { [ C209 , C208 ] } by L510 , FUNCT_2:def 1;
L512: (the Arity of C211) = { [ [ C209 , C208 ] , C209 ] } by L511 , L510 , GRFUNC_1:7;
L513: ( dom (the ResultSort of C211) ) = { [ C209 , C208 ] } by L510 , FUNCT_2:def 1;
L514: (the ResultSort of C211) = { [ [ C209 , C208 ] , C210 ] } by L513 , L510 , GRFUNC_1:7;
L515: ( dom (the Arity of C212) ) = { [ C209 , C208 ] } by L510 , FUNCT_2:def 1;
L516: (the Arity of C212) = { [ [ C209 , C208 ] , C209 ] } by L515 , L510 , GRFUNC_1:7;
L517: ( dom (the ResultSort of C212) ) = { [ C209 , C208 ] } by L510 , FUNCT_2:def 1;
thus L518: thesis by L517 , L510 , L512 , L516 , L514 , GRFUNC_1:7;
end;
end;
registration
let C213 being set;
let C214 being FinSequence;
let C215 being set;
cluster ( 1GateCircStr (C214 , C213 , C215) ) -> non  empty;
coherence
proof
L520: (the carrier of ( 1GateCircStr (C214 , C213 , C215) )) = ( ( rng C214 ) \/ { C215 } ) by L504;
thus L521: (the carrier of ( 1GateCircStr (C214 , C213 , C215) )) is non  empty by L520;
end;
end;
theorem
L523: (for B169 , B170 being set holds (for B171 being FinSequence holds ((the Arity of ( 1GateCircStr (B171 , B169 , B170) )) = ( (B171 , B169) .--> B171 ) & (the ResultSort of ( 1GateCircStr (B171 , B169 , B170) )) = ( (B171 , B169) .--> B170 ))))
proof
let C216 , C217 being set;
let C218 being FinSequence;
set D91 = ( 1GateCircStr (C218 , C216 , C217) );
L524: ( (the Arity of D91) . [ C218 , C216 ] ) = C218 by L504;
L525: (for B172 being set holds (B172 in { [ C218 , C216 ] } implies ( (the Arity of D91) . B172 ) = C218)) by L524 , TARSKI:def 1;
L526: (the carrier' of D91) = { [ C218 , C216 ] } by L504;
L527: ( dom (the Arity of D91) ) = { [ C218 , C216 ] } by L526 , FUNCT_2:def 1;
thus L528: (the Arity of D91) = ( (C218 , C216) .--> C218 ) by L527 , L525 , FUNCOP_1:11;
L529: ( (the ResultSort of D91) . [ C218 , C216 ] ) = C217 by L504;
L530: (for B173 being set holds (B173 in { [ C218 , C216 ] } implies ( (the ResultSort of D91) . B173 ) = C217)) by L529 , TARSKI:def 1;
L531: ( dom (the ResultSort of D91) ) = { [ C218 , C216 ] } by L526 , FUNCT_2:def 1;
thus L532: thesis by L531 , L530 , FUNCOP_1:11;
end;
theorem
L533: (for B174 , B175 being set holds (for B176 being FinSequence holds (for B177 being (Gate of ( 1GateCircStr (B176 , B174 , B175) )) holds (B177 = [ B176 , B174 ] & ( the_arity_of B177 ) = B176 & ( the_result_sort_of B177 ) = B175))))
proof
let C219 , C220 being set;
let C221 being FinSequence;
set D92 = ( 1GateCircStr (C221 , C219 , C220) );
let C222 being (Gate of ( 1GateCircStr (C221 , C219 , C220) ));
L534: ( (the ResultSort of D92) . [ C221 , C219 ] ) = C220 by L504;
L535: (the carrier' of D92) = { [ C221 , C219 ] } by L504;
thus L536: C222 = [ C221 , C219 ] by L535 , TARSKI:def 1;
L537: ( (the Arity of D92) . [ C221 , C219 ] ) = C221 by L504;
thus L538: thesis by L537 , L535 , L534 , TARSKI:def 1;
end;
theorem
L539: (for B178 , B179 being set holds (for B180 being FinSequence holds (( InputVertices ( 1GateCircStr (B180 , B178 , B179) ) ) = ( ( rng B180 ) \ { B179 } ) & ( InnerVertices ( 1GateCircStr (B180 , B178 , B179) ) ) = { B179 })))
proof
let C223 , C224 being set;
let C225 being FinSequence;
L540: (the ResultSort of ( 1GateCircStr (C225 , C223 , C224) )) = ( (C225 , C223) .--> C224 ) by L523;
L541: ( rng (the ResultSort of ( 1GateCircStr (C225 , C223 , C224) )) ) = { C224 } by L540 , FUNCOP_1:8;
L542: (the carrier of ( 1GateCircStr (C225 , C223 , C224) )) = ( ( rng C225 ) \/ { C224 } ) by L504;
thus L543: thesis by L542 , L541 , XBOOLE_1:40;
end;
definition
let C226 being set;
let C227 being FinSequence;
func 1GateCircStr (C227 , C226) -> non  void  strict ManySortedSign means 
:L544: ((the carrier of it) = ( ( rng C227 ) \/ { [ C227 , C226 ] } ) & (the carrier' of it) = { [ C227 , C226 ] } & ( (the Arity of it) . [ C227 , C226 ] ) = C227 & ( (the ResultSort of it) . [ C227 , C226 ] ) = [ C227 , C226 ]);
existence
proof
take ( 1GateCircStr (C227 , C226 , [ C227 , C226 ]) );
thus L545: thesis by L504;
end;
uniqueness
proof
let C228 , C229 being non  void  strict ManySortedSign;
assume L546: (not thesis);
L547: C228 = ( 1GateCircStr (C227 , C226 , [ C227 , C226 ]) ) by L546 , L504;
thus L548: thesis by L547 , L546 , L504;
end;
end;
registration
let C230 being set;
let C231 being FinSequence;
cluster ( 1GateCircStr (C231 , C230) ) -> non  empty;
coherence
proof
L550: (the carrier of ( 1GateCircStr (C231 , C230) )) = ( ( rng C231 ) \/ { [ C231 , C230 ] } ) by L544;
thus L551: (the carrier of ( 1GateCircStr (C231 , C230) )) is non  empty by L550;
end;
end;
theorem
L553: (for B181 being set holds (for B182 being FinSequence holds ( 1GateCircStr (B182 , B181) ) = ( 1GateCircStr (B182 , B181 , [ B182 , B181 ]) )))
proof
let C232 being set;
let C233 being FinSequence;
set D93 = ( 1GateCircStr (C233 , C232) );
L554: (the carrier' of D93) = { [ C233 , C232 ] } by L544;
L555: ( (the Arity of D93) . [ C233 , C232 ] ) = C233 by L544;
L556: ( (the ResultSort of D93) . [ C233 , C232 ] ) = [ C233 , C232 ] by L544;
L557: (the carrier of D93) = ( ( rng C233 ) \/ { [ C233 , C232 ] } ) by L544;
thus L558: thesis by L557 , L554 , L555 , L556 , L504;
end;
theorem
L559: (for B183 being set holds (for B184 being FinSequence holds ((the Arity of ( 1GateCircStr (B184 , B183) )) = ( (B184 , B183) .--> B184 ) & (the ResultSort of ( 1GateCircStr (B184 , B183) )) = ( (B184 , B183) .--> [ B184 , B183 ] ))))
proof
let C234 being set;
let C235 being FinSequence;
set D94 = ( 1GateCircStr (C235 , C234) );
L560: ( (the Arity of D94) . [ C235 , C234 ] ) = C235 by L544;
L561: (for B185 being set holds (B185 in { [ C235 , C234 ] } implies ( (the Arity of D94) . B185 ) = C235)) by L560 , TARSKI:def 1;
L562: (the carrier' of D94) = { [ C235 , C234 ] } by L544;
L563: ( dom (the Arity of D94) ) = { [ C235 , C234 ] } by L562 , FUNCT_2:def 1;
thus L564: (the Arity of ( 1GateCircStr (C235 , C234) )) = ( (C235 , C234) .--> C235 ) by L563 , L561 , FUNCOP_1:11;
L565: ( (the ResultSort of D94) . [ C235 , C234 ] ) = [ C235 , C234 ] by L544;
L566: (for B186 being set holds (B186 in { [ C235 , C234 ] } implies ( (the ResultSort of D94) . B186 ) = [ C235 , C234 ])) by L565 , TARSKI:def 1;
L567: ( dom (the ResultSort of D94) ) = { [ C235 , C234 ] } by L562 , FUNCT_2:def 1;
thus L568: thesis by L567 , L566 , FUNCOP_1:11;
end;
theorem
L569: (for B187 being set holds (for B188 being FinSequence holds (for B189 being (Gate of ( 1GateCircStr (B188 , B187) )) holds (B189 = [ B188 , B187 ] & ( the_arity_of B189 ) = B188 & ( the_result_sort_of B189 ) = B189))))
proof
let C236 being set;
let C237 being FinSequence;
set D95 = ( 1GateCircStr (C237 , C236) );
let C238 being (Gate of ( 1GateCircStr (C237 , C236) ));
L570: (the carrier' of D95) = { [ C237 , C236 ] } by L544;
thus L571: C238 = [ C237 , C236 ] by L570 , TARSKI:def 1;
thus L572: thesis by L571 , L544;
end;
theorem
L573: (for B190 being set holds (for B191 being FinSequence holds (( InputVertices ( 1GateCircStr (B191 , B190) ) ) = ( rng B191 ) & ( InnerVertices ( 1GateCircStr (B191 , B190) ) ) = { [ B191 , B190 ] })))
proof
let C239 being set;
let C240 being FinSequence;
L574: (the ResultSort of ( 1GateCircStr (C240 , C239) )) = ( (C240 , C239) .--> [ C240 , C239 ] ) by L559;
L575: ( rng (the ResultSort of ( 1GateCircStr (C240 , C239) )) ) = { [ C240 , C239 ] } by L574 , FUNCOP_1:8;
L576: (the carrier of ( 1GateCircStr (C240 , C239) )) = ( ( rng C240 ) \/ { [ C240 , C239 ] } ) by L544;
thus L577: ( InputVertices ( 1GateCircStr (C240 , C239) ) ) c= ( rng C240 ) by L576 , L575 , XBOOLE_1:43;
L578:
now
assume L579: [ C240 , C239 ] in ( rng C240 );
consider C241 being set such that L580: [ C241 , [ C240 , C239 ] ] in C240 by L579 , XTUPLE_0:def 13;
L581: { C241 , [ C240 , C239 ] } in { { C241 , [ C240 , C239 ] } , { C241 } } by TARSKI:def 2;
L582: { C240 , C239 } in { { C240 , C239 } , { C240 } } by TARSKI:def 2;
L583: C240 in { C240 , C239 } by TARSKI:def 2;
L584: [ C240 , C239 ] in { C241 , [ C240 , C239 ] } by TARSKI:def 2;
thus L585: contradiction by L584 , L580 , L583 , L582 , L581 , XREGULAR:9;
end;
thus L586: ( rng C240 ) c= ( InputVertices ( 1GateCircStr (C240 , C239) ) )
proof
let C242 being set;
assume L587: C242 in ( rng C240 );
L588: C242 in ( ( rng C240 ) \/ { [ C240 , C239 ] } ) by L587 , XBOOLE_0:def 3;
L589: (not C242 in { [ C240 , C239 ] }) by L578 , L587 , TARSKI:def 1;
thus L590: thesis by L589 , L575 , L576 , L588 , XBOOLE_0:def 5;
end;

thus L591: thesis by L574 , FUNCOP_1:8;
end;
theorem
L592: (for B192 being set holds (for B193 , B194 being FinSequence holds ( 1GateCircStr (B193 , B192) ) tolerates ( 1GateCircStr (B194 , B192) )))
proof
let C243 being set;
let C244 , C245 being FinSequence;
set D96 = ( 1GateCircStr (C244 , C243) );
set D97 = ( 1GateCircStr (C245 , C243) );
L593: ([ C244 , C243 ] <> [ C245 , C243 ] implies { [ C244 , C243 ] } misses { [ C245 , C243 ] }) by ZFMISC_1:11;
L594: (the Arity of D97) = ( (C245 , C243) .--> C245 ) by L559;
L595: (the Arity of D96) = ( (C244 , C243) .--> C244 ) by L559;
thus L596: (the Arity of D96) tolerates (the Arity of D97) by L595 , L594 , L593 , FUNCOP_1:87 , XTUPLE_0:1;
L597: (the ResultSort of D97) = ( (C245 , C243) .--> [ C245 , C243 ] ) by L559;
L598: (the ResultSort of D96) = ( (C244 , C243) .--> [ C244 , C243 ] ) by L559;
thus L599: thesis by L598 , L597 , L593 , FUNCOP_1:87;
end;
begin
definition
let C246 being ManySortedSign;
attr C246 is  unsplit
means
:L600: (the ResultSort of C246) = ( id (the carrier' of C246) );
attr C246 is  gate`1=arity
means
:L601: (for B195 being set holds (B195 in (the carrier' of C246) implies B195 = [ ( (the Arity of C246) . B195 ) , ( B195 `2 ) ]));
attr C246 is  gate`2isBoolean
means
:L602: (for B196 being set holds (B196 in (the carrier' of C246) implies (for B197 being FinSequence holds (B197 = ( (the Arity of C246) . B196 ) implies (ex B198 being (Function of ( ( len B197 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st B196 = [ ( B196 `1 ) , B198 ])))));
end;
definition
let C247 being non  empty ManySortedSign;
let C248 being MSAlgebra over C247;
attr C248 is  gate`2=den
means
:L604: (for B199 being set holds (B199 in (the carrier' of C247) implies B199 = [ ( B199 `1 ) , ( (the Charact of C248) . B199 ) ]));
end;
definition
let C249 being non  empty ManySortedSign;
attr C249 is  gate`2=den
means
(ex B200 being MSAlgebra over C249 st B200 is  gate`2=den);
end;
scheme MSSLambdaWeak { F1 , F2() -> set , F3() -> (Function of F1() , F2()) , F4(set , set) -> set } : (ex B201 being (ManySortedSet of F1()) st (for B202 being set holds (for B203 being (Element of F2()) holds ((B202 in F1() & B203 = ( F3() . B202 )) implies ( B201 . B202 ) = F4(B202 , B203)))))
proof
deffunc H1(set) = F4($1 , ( F3() . $1 ));
consider C250 being Function such that L607: ( dom C250 ) = F1() and L608: (for B204 being set holds (B204 in F1() implies ( C250 . B204 ) = H1(B204))) from FUNCT_1:sch 3;
reconsider D98 = C250 as (ManySortedSet of F1()) by L607 , PARTFUN1:def 2 , RELAT_1:def 18;
take D98;
thus L609: thesis by L608;
end;
scheme Lemma { F5() -> non  empty ManySortedSign , F6(set , set) -> set } : (ex B205 being  strict MSAlgebra over F5() st ((the Sorts of B205) = ( (the carrier of F5()) --> ( BOOLEAN ) ) & (for B206 being set holds (for B207 being (Element of ( (the carrier of F5()) * )) holds ((B206 in (the carrier' of F5()) & B207 = ( (the Arity of F5()) . B206 )) implies ( (the Charact of B205) . B206 ) = F6(B206 , B207))))))
provided
L610: (for B208 being set holds (for B209 being (Element of ( (the carrier of F5()) * )) holds ((B208 in (the carrier' of F5()) & B209 = ( (the Arity of F5()) . B208 )) implies F6(B208 , B209) is (Function of ( ( len B209 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )))))
proof
set D99 = F5();
set D100 = ( (the carrier of D99) --> ( BOOLEAN ) );
consider C251 being (ManySortedSet of (the carrier' of D99)) such that L611: (for B210 being set holds (for B211 being (Element of ( (the carrier of D99) * )) holds ((B210 in (the carrier' of D99) & B211 = ( (the Arity of D99) . B210 )) implies ( C251 . B210 ) = F6(B210 , B211)))) from MSSLambdaWeak;
L612: ( dom C251 ) = (the carrier' of D99) by PARTFUN1:def 2;
L613: C251 is  Function-yielding
proof
let C252 being set;
assume L614: C252 in ( dom C251 );
reconsider D101 = C252 as (Gate of D99) by L614 , PARTFUN1:def 2;
reconsider D102 = ( (the Arity of D99) . D101 ) as (Element of ( (the carrier of D99) * )) by L612 , L614 , FUNCT_2:5;
L615: ( C251 . C252 ) = F6(D101 , D102) by L611 , L612 , L614;
thus L616: thesis by L615 , L610 , L612 , L614;
end;
reconsider D103 = C251 as (ManySortedFunction of (the carrier' of D99)) by L613;
L617: ( dom (the ResultSort of D99) ) = (the carrier' of D99) by FUNCT_2:def 1;
L618: ( dom (the Arity of D99) ) = (the carrier' of D99) by FUNCT_2:def 1;
L619:
now
let C253 being set;
assume L620: C253 in (the carrier' of D99);
reconsider D104 = C253 as (Gate of D99) by L620;
reconsider D105 = ( (the Arity of D99) . D104 ) as (Element of ( (the carrier of D99) * )) by L620 , FUNCT_2:5;
L621: ( ( ( D100 # ) * (the Arity of D99) ) . C253 ) = ( ( D100 # ) . D105 ) by L618 , L620 , FUNCT_1:13;
reconsider D106 = ( (the ResultSort of D99) . D104 ) as (Vertex of D99) by L620 , FUNCT_2:5;
L622: ( D100 . D106 ) = ( BOOLEAN ) by FUNCOP_1:7;
L623: ( ( D100 * (the ResultSort of D99) ) . C253 ) = ( BOOLEAN ) by L622 , L617 , L620 , FUNCT_1:13;
L624: ( ( D100 # ) . D105 ) = ( ( len D105 ) -tuples_on ( BOOLEAN ) ) by L35;
L625: ( D103 . C253 ) = F6(D104 , D105) by L611 , L620;
thus L626: ( D103 . C253 ) is (Function of ( ( ( D100 # ) * (the Arity of D99) ) . C253 ) , ( ( D100 * (the ResultSort of D99) ) . C253 )) by L625 , L610 , L620 , L621 , L624 , L623;
end;
reconsider D107 = D103 as (ManySortedFunction of ( ( D100 # ) * (the Arity of D99) ) , ( D100 * (the ResultSort of D99) )) by L619 , PBOOLE:def 15;
take MSAlgebra (# D100 , D107 #);
thus L627: thesis by L611;
end;
registration
cluster  gate`2isBoolean ->  gate`2=den for non  empty non  empty non  empty non  empty ManySortedSign;
coherence
proof
deffunc H2(set , set) = ( $1 `2 );
let C254 being non  empty ManySortedSign;
assume L628: (for B212 being set holds (B212 in (the carrier' of C254) implies (for B213 being FinSequence holds (B213 = ( (the Arity of C254) . B212 ) implies (ex B214 being (Function of ( ( len B213 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st B212 = [ ( B212 `1 ) , B214 ])))));
L629:
now
let C255 being set;
let C256 being (Element of ( (the carrier of C254) * ));
assume that
L630: C255 in (the carrier' of C254)
and
L631: C256 = ( (the Arity of C254) . C255 );
L632: (ex B215 being (Function of ( ( len C256 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st C255 = [ ( C255 `1 ) , B215 ]) by L628 , L630 , L631;
thus L633: H2(C255 , C256) is (Function of ( ( len C256 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) by L632 , MCART_1:7;
end;
consider C257 being  strict MSAlgebra over C254 such that L634: ((the Sorts of C257) = ( (the carrier of C254) --> ( BOOLEAN ) ) & (for B216 being set holds (for B217 being (Element of ( (the carrier of C254) * )) holds ((B216 in (the carrier' of C254) & B217 = ( (the Arity of C254) . B216 )) implies ( (the Charact of C257) . B216 ) = H2(B216 , B217))))) from Lemma(L629);
take C257;
let C258 being set;
assume L635: C258 in (the carrier' of C254);
reconsider D108 = ( (the Arity of C254) . C258 ) as (Element of ( (the carrier of C254) * )) by L635 , FUNCT_2:5;
consider C259 being (Function of ( ( len D108 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L636: C258 = [ ( C258 `1 ) , C259 ] by L628 , L635;
L637: C259 = ( C258 `2 ) by L636 , MCART_1:7;
thus L638: thesis by L637 , L634 , L635 , L636;
end;
end;
theorem
L640: (for B218 being non  empty ManySortedSign holds (B218 is  unsplit iff (for B219 being set holds (B219 in (the carrier' of B218) implies ( (the ResultSort of B218) . B219 ) = B219))))
proof
let C260 being non  empty ManySortedSign;
thus L641:now
assume L642: C260 is  unsplit;
L643: (the ResultSort of C260) = ( id (the carrier' of C260) ) by L642 , L600;
thus L644: (for B220 being set holds (B220 in (the carrier' of C260) implies ( (the ResultSort of C260) . B220 ) = B220)) by L643 , FUNCT_1:17;
end;
assume L645: (for B221 being set holds (B221 in (the carrier' of C260) implies ( (the ResultSort of C260) . B221 ) = B221));
L646: ( dom (the ResultSort of C260) ) = (the carrier' of C260) by FUNCT_2:def 1;
thus L647: (the ResultSort of C260) = ( id (the carrier' of C260) ) by L646 , L645 , FUNCT_1:17;
end;
theorem
L648: (for B222 being non  empty ManySortedSign holds (B222 is  unsplit implies (the carrier' of B222) c= (the carrier of B222)))
proof
let C261 being non  empty ManySortedSign;
assume L649: C261 is  unsplit;
let C262 being set;
assume L650: C262 in (the carrier' of C261);
L651: ( (the ResultSort of C261) . C262 ) = C262 by L650 , L649 , L640;
thus L652: thesis by L651 , L650 , FUNCT_2:5;
end;
registration
cluster  unsplit ->  Circuit-like for non  empty non  empty non  empty non  empty ManySortedSign;
coherence
proof
let C263 being non  empty ManySortedSign;
assume that
L653: (the ResultSort of C263) = ( id (the carrier' of C263) );
let C264 being non  void non  empty ManySortedSign;
assume that
L654: C264 = C263;
let C265 , C266 being (Gate of C264);
L655: ( the_result_sort_of C265 ) = C265 by L653 , L654 , FUNCT_1:17;
thus L656: thesis by L655 , L653 , L654 , FUNCT_1:17;
end;
end;
theorem
L658: (for B223 being set holds (for B224 being FinSequence holds ( 1GateCircStr (B224 , B223) ) is  unsplit  gate`1=arity))
proof
let C267 being set;
let C268 being FinSequence;
set D109 = ( 1GateCircStr (C268 , C267) );
L659:
now
let C269 being set;
assume L660: C269 in { [ C268 , C267 ] };
L661: C269 = [ C268 , C267 ] by L660 , TARSKI:def 1;
thus L662: ( (the ResultSort of D109) . C269 ) = C269 by L661 , L544;
end;
L663: (the carrier' of D109) = { [ C268 , C267 ] } by L544;
L664: ( dom (the ResultSort of D109) ) = { [ C268 , C267 ] } by L663 , FUNCT_2:def 1;
thus L665: (the ResultSort of D109) = ( id (the carrier' of D109) ) by L664 , L663 , L659 , FUNCT_1:17;
let C270 being set;
assume L666: C270 in (the carrier' of D109);
L667: C270 = [ C268 , C267 ] by L666 , L663 , TARSKI:def 1;
L668: ( (the Arity of D109) . C270 ) = C268 by L667 , L544;
thus L669: thesis by L668 , L667 , MCART_1:7;
end;
registration
let C271 being set;
let C272 being FinSequence;
cluster ( 1GateCircStr (C272 , C271) ) ->  unsplit  gate`1=arity;
coherence by L658;
end;
registration
cluster  unsplit  gate`1=arity non  void  strict non  empty for ManySortedSign;
existence
proof
set D110 = the set;
set D111 = the FinSequence;
take ( 1GateCircStr (D111 , D110) );
thus L671: thesis;
end;
end;
theorem
L673: (for B225 , B226 being  unsplit  gate`1=arity non  empty ManySortedSign holds B225 tolerates B226)
proof
let C273 , C274 being  unsplit  gate`1=arity non  empty ManySortedSign;
set D112 = (the Arity of C273);
set D113 = (the Arity of C274);
set D114 = (the ResultSort of C273);
set D115 = (the ResultSort of C274);
thus L674: D112 tolerates D113
proof
let C275 being set;
assume L675: C275 in ( ( dom D112 ) /\ ( dom D113 ) );
L676: C275 in ( dom D113 ) by L675 , XBOOLE_0:def 4;
L677: C275 in (the carrier' of C274) by L676 , FUNCT_2:def 1;
L678: C275 = [ ( D113 . C275 ) , ( C275 `2 ) ] by L677 , L601;
L679: C275 in ( dom D112 ) by L675 , XBOOLE_0:def 4;
L680: C275 in (the carrier' of C273) by L679 , FUNCT_2:def 1;
L681: C275 = [ ( D112 . C275 ) , ( C275 `2 ) ] by L680 , L601;
thus L682: thesis by L681 , L678 , XTUPLE_0:1;
end;

let C276 being set;
assume L683: C276 in ( ( dom D114 ) /\ ( dom D115 ) );
L684: C276 in ( dom D114 ) by L683 , XBOOLE_0:def 4;
L685: C276 in (the carrier' of C273) by L684 , FUNCT_2:def 1;
L686: ( D114 . C276 ) = C276 by L685 , L640;
L687: C276 in ( dom D115 ) by L683 , XBOOLE_0:def 4;
L688: C276 in (the carrier' of C274) by L687 , FUNCT_2:def 1;
thus L689: thesis by L688 , L686 , L640;
end;
theorem
L690: (for B227 , B228 being non  empty ManySortedSign holds (for B229 being MSAlgebra over B227 holds (for B230 being MSAlgebra over B228 holds ((B229 is  gate`2=den & B230 is  gate`2=den) implies (the Charact of B229) tolerates (the Charact of B230)))))
proof
let C277 , C278 being non  empty ManySortedSign;
let C279 being MSAlgebra over C277;
let C280 being MSAlgebra over C278;
assume that
L691: C279 is  gate`2=den
and
L692: C280 is  gate`2=den;
let C281 being set;
set D116 = (the Charact of C279);
set D117 = (the Charact of C280);
assume L693: C281 in ( ( dom D116 ) /\ ( dom D117 ) );
L694: C281 in ( dom D117 ) by L693 , XBOOLE_0:def 4;
L695: C281 in (the carrier' of C278) by L694 , PARTFUN1:def 2;
L696: C281 = [ ( C281 `1 ) , ( D117 . C281 ) ] by L695 , L692 , L604;
L697: C281 in ( dom D116 ) by L693 , XBOOLE_0:def 4;
L698: C281 in (the carrier' of C277) by L697 , PARTFUN1:def 2;
L699: C281 = [ ( C281 `1 ) , ( D116 . C281 ) ] by L698 , L691 , L604;
thus L700: thesis by L699 , L696 , XTUPLE_0:1;
end;
theorem
L701: (for B231 , B232 being  unsplit non  empty ManySortedSign holds ( B231 +* B232 ) is  unsplit)
proof
let C282 , C283 being  unsplit non  empty ManySortedSign;
set D118 = ( C282 +* C283 );
L702: (the ResultSort of D118) = ( (the ResultSort of C282) +* (the ResultSort of C283) ) by L56;
L703: (the ResultSort of C282) = ( id (the carrier' of C282) ) by L600;
L704: (the ResultSort of C283) = ( id (the carrier' of C283) ) by L600;
L705: (the carrier' of D118) = ( (the carrier' of C282) \/ (the carrier' of C283) ) by L56;
thus L706: (the ResultSort of D118) = ( id (the carrier' of D118) ) by L705 , L702 , L703 , L704 , FUNCT_4:22;
end;
registration
let C284 , C285 being  unsplit non  empty ManySortedSign;
cluster ( C284 +* C285 ) ->  unsplit;
coherence by L701;
end;
theorem
L708: (for B233 , B234 being  gate`1=arity non  empty ManySortedSign holds ( B233 +* B234 ) is  gate`1=arity)
proof
let C286 , C287 being  gate`1=arity non  empty ManySortedSign;
set D119 = ( C286 +* C287 );
let C288 being set;
L709: ( dom (the Arity of C286) ) = (the carrier' of C286) by FUNCT_2:def 1;
L710: (the Arity of D119) = ( (the Arity of C286) +* (the Arity of C287) ) by L56;
assume L711: C288 in (the carrier' of D119);
reconsider D120 = C288 as (Gate of D119) by L711;
L712: ( dom (the Arity of C287) ) = (the carrier' of C287) by FUNCT_2:def 1;
L713: (the carrier' of D119) = ( (the carrier' of C286) \/ (the carrier' of C287) ) by L56;
L714: (D120 in (the carrier' of C286) or D120 in (the carrier' of C287)) by L713 , L711 , XBOOLE_0:def 3;
L715:
now
assume L716: (not D120 in (the carrier' of C287));
reconsider D121 = D120 as (Gate of C286) by L716 , L713 , L711 , XBOOLE_0:def 3;
thus L717: D120 = [ ( (the Arity of C286) . D121 ) , ( D120 `2 ) ] by L714 , L716 , L601
.= [ ( (the Arity of D119) . D120 ) , ( D120 `2 ) ] by L713 , L710 , L711 , L709 , L712 , L716 , FUNCT_4:def 1;
end;
L718:
now
assume L719: D120 in (the carrier' of C287);
reconsider D122 = D120 as (Gate of C287) by L719;
thus L720: D120 = [ ( (the Arity of C287) . D122 ) , ( D120 `2 ) ] by L719 , L601
.= [ ( (the Arity of D119) . D120 ) , ( D120 `2 ) ] by L713 , L710 , L709 , L712 , L719 , FUNCT_4:def 1;
end;
thus L721: thesis by L718 , L715;
end;
registration
let C289 , C290 being  gate`1=arity non  empty ManySortedSign;
cluster ( C289 +* C290 ) ->  gate`1=arity;
coherence by L708;
end;
theorem
L723: (for B235 , B236 being non  empty ManySortedSign holds ((B235 is  gate`2isBoolean & B236 is  gate`2isBoolean) implies ( B235 +* B236 ) is  gate`2isBoolean))
proof
let C291 , C292 being non  empty ManySortedSign;
set D123 = ( C291 +* C292 );
assume that
L724: C291 is  gate`2isBoolean
and
L725: C292 is  gate`2isBoolean;
let C293 being set;
assume L726: C293 in (the carrier' of D123);
let C294 being FinSequence;
assume that
L727: C294 = ( (the Arity of D123) . C293 );
reconsider D124 = C293 as (Gate of D123) by L726;
L728: ( dom (the Arity of C291) ) = (the carrier' of C291) by FUNCT_2:def 1;
L729: (the Arity of D123) = ( (the Arity of C291) +* (the Arity of C292) ) by L56;
L730: ( dom (the Arity of C292) ) = (the carrier' of C292) by FUNCT_2:def 1;
L731: (the carrier' of D123) = ( (the carrier' of C291) \/ (the carrier' of C292) ) by L56;
L732: (D124 in (the carrier' of C291) or D124 in (the carrier' of C292)) by L731 , L726 , XBOOLE_0:def 3;
L733:
now
assume L734: (not D124 in (the carrier' of C292));
reconsider D125 = D124 as (Gate of C291) by L734 , L731 , L726 , XBOOLE_0:def 3;
L735: ( (the Arity of C291) . D125 ) = C294 by L731 , L729 , L726 , L727 , L728 , L730 , L734 , FUNCT_4:def 1;
thus L736: thesis by L735 , L724 , L732 , L734 , L602;
end;
L737:
now
assume L738: D124 in (the carrier' of C292);
reconsider D126 = D124 as (Gate of C292) by L738;
L739: ( (the Arity of C292) . D126 ) = C294 by L731 , L729 , L727 , L728 , L730 , L738 , FUNCT_4:def 1;
thus L740: thesis by L739 , L725 , L738 , L602;
end;
thus L741: thesis by L737 , L733;
end;
begin
definition
let C295 being Nat;
mode FinSeqLen of C295
 is C295 -element FinSequence;
end;
definition
let C296 being Nat;
let C297 , C298 being non  empty set;
let C299 being (Function of ( C296 -tuples_on C297 ) , C298);
let C300 being (FinSeqLen of C296);
let C301 being set;
assume that
L743: (C301 in ( rng C300 ) implies C297 = C298);
func 1GateCircuit (C300 , C299 , C301) ->  strict  non-empty MSAlgebra over ( 1GateCircStr (C300 , C299 , C301) ) means 
((the Sorts of it) = ( ( ( rng C300 ) --> C297 ) +* ( C301 .--> C298 ) ) & ( (the Charact of it) . [ C300 , C299 ] ) = C299);
existence
proof
L744: C300 is (FinSequence of ( rng C300 )) by FINSEQ_1:def 4;
reconsider D127 = C300 as (Element of ( ( rng C300 ) * )) by L744 , FINSEQ_1:def 11;
set D128 = ( ( rng C300 ) --> C297 );
set D129 = ( C301 .--> C298 );
set D130 = ( 1GateCircStr (C300 , C299 , C301) );
set D131 = ( D128 +* D129 );
set D132 = ( (the carrier' of D130) --> C299 );
L745: ( dom ( C301 .--> C298 ) ) = { C301 } by FUNCOP_1:13;
L746: C301 in { C301 } by TARSKI:def 1;
L747: ( D131 . C301 ) = ( ( C301 .--> C298 ) . C301 ) by L746 , L745 , FUNCT_4:13
.= C298 by L746 , FUNCOP_1:7;
L748: (the carrier of D130) = ( ( rng C300 ) \/ { C301 } ) by L504;
reconsider D133 = D131 as  non-empty (ManySortedSet of (the carrier of D130)) by L748;
L749: ( rng C300 ) c= (the carrier of D130) by L748 , XBOOLE_1:7;
L750: C300 is (FinSequence of (the carrier of D130)) by L749 , FINSEQ_1:def 4;
reconsider D134 = C300 as (Element of ( (the carrier of D130) * )) by L750 , FINSEQ_1:def 11;
L751: ( dom ( D128 # ) ) = ( ( rng C300 ) * ) by PARTFUN1:def 2;
L752: ( dom ( ( rng C300 ) --> C297 ) ) = ( rng C300 ) by FUNCOP_1:13;
L753: D128 tolerates D129
proof
let C302 being set;
assume L754: C302 in ( ( dom D128 ) /\ ( dom D129 ) );
L755: C302 in ( rng C300 ) by L754 , L752 , XBOOLE_0:def 4;
L756: ( D128 . C302 ) = C297 by L755 , FUNCOP_1:7;
L757: C302 in { C301 } by L745 , L754 , XBOOLE_0:def 4;
L758: C301 = C302 by L757 , TARSKI:def 1;
thus L759: thesis by L758 , L743 , L752 , L754 , L757 , L756 , FUNCOP_1:7 , XBOOLE_0:def 4;
end;
L760: D128 c= D133 by L753 , FUNCT_4:28;
L761: ( D128 # ) c= ( D133 # ) by L760 , L17;
L762: ( ( D128 # ) . D127 ) = ( ( D133 # ) . D134 ) by L761 , L751 , GRFUNC_1:2;
L763: (the carrier' of D130) = { [ C300 , C299 ] } by L504;
L764: ( dom (the ResultSort of D130) ) = { [ C300 , C299 ] } by L763 , FUNCT_2:def 1;
L765: ( (the ResultSort of D130) . [ C300 , C299 ] ) = C301 by L504;
L766: ( (the Arity of D130) . [ C300 , C299 ] ) = C300 by L504;
L767: ( len C300 ) = C296 by CARD_1:def 7;
L768: ( dom (the Arity of D130) ) = { [ C300 , C299 ] } by L763 , FUNCT_2:def 1;
L769:
now
let C303 being set;
L770: ( ( D133 # ) . D134 ) = ( C296 -tuples_on C297 ) by L767 , L762 , L35;
assume L771: C303 in (the carrier' of D130);
L772: C303 = [ C300 , C299 ] by L771 , L763 , TARSKI:def 1;
L773: ( ( ( D133 # ) * (the Arity of D130) ) . C303 ) = ( ( D133 # ) . C300 ) by L772 , L763 , L766 , L768 , L771 , FUNCT_1:13;
L774: ( ( D133 * (the ResultSort of D130) ) . C303 ) = C298 by L763 , L765 , L747 , L764 , L771 , L772 , FUNCT_1:13;
thus L775: ( D132 . C303 ) is (Function of ( ( ( D133 # ) * (the Arity of D130) ) . C303 ) , ( ( D133 * (the ResultSort of D130) ) . C303 )) by L774 , L771 , L773 , L770 , FUNCOP_1:7;
end;
reconsider D135 = D132 as (ManySortedFunction of ( ( D133 # ) * (the Arity of D130) ) , ( D133 * (the ResultSort of D130) )) by L769 , PBOOLE:def 15;
reconsider D136 = MSAlgebra (# D133 , D135 #) as  non-empty  strict MSAlgebra over ( 1GateCircStr (C300 , C299 , C301) ) by MSUALG_1:def 3;
take D136;
L776: [ C300 , C299 ] in { [ C300 , C299 ] } by TARSKI:def 1;
thus L777: thesis by L776 , L763 , FUNCOP_1:7;
end;
uniqueness
proof
set D137 = ( 1GateCircStr (C300 , C299 , C301) );
let C304 , C305 being  strict  non-empty MSAlgebra over D137;
assume that
L778: (not thesis);
L779: (the carrier' of D137) = { [ C300 , C299 ] } by L504;
L780: ( dom (the Charact of C304) ) = { [ C300 , C299 ] } by L779 , PARTFUN1:def 2;
L781: (the Charact of C304) = { [ [ C300 , C299 ] , C299 ] } by L780 , L778 , GRFUNC_1:7;
L782: ( dom (the Charact of C305) ) = { [ C300 , C299 ] } by L779 , PARTFUN1:def 2;
thus L783: thesis by L782 , L778 , L781 , GRFUNC_1:7;
end;
end;
definition
let C306 being Nat;
let C307 being non  empty set;
let C308 being (Function of ( C306 -tuples_on C307 ) , C307);
let C309 being (FinSeqLen of C306);
func 1GateCircuit (C309 , C308) ->  strict  non-empty MSAlgebra over ( 1GateCircStr (C309 , C308) ) means 
:L785: ((the Sorts of it) = ( (the carrier of ( 1GateCircStr (C309 , C308) )) --> C307 ) & ( (the Charact of it) . [ C309 , C308 ] ) = C308);
existence
proof
set D138 = ( 1GateCircStr (C309 , C308) );
set D139 = ( (the carrier of D138) --> C307 );
set D140 = ( (the carrier' of D138) --> C308 );
L786: ( len C309 ) = C306 by CARD_1:def 7;
L787: ( (the Arity of D138) . [ C309 , C308 ] ) = C309 by L544;
L788: ( (the ResultSort of D138) . [ C309 , C308 ] ) = [ C309 , C308 ] by L544;
L789: (the carrier' of D138) = { [ C309 , C308 ] } by L544;
L790: ( dom (the ResultSort of D138) ) = { [ C309 , C308 ] } by L789 , FUNCT_2:def 1;
L791: (the carrier of D138) = ( ( rng C309 ) \/ { [ C309 , C308 ] } ) by L544;
L792: ( rng C309 ) c= (the carrier of D138) by L791 , XBOOLE_1:7;
L793: C309 is (FinSequence of (the carrier of D138)) by L792 , FINSEQ_1:def 4;
reconsider D141 = C309 as (Element of ( (the carrier of D138) * )) by L793 , FINSEQ_1:def 11;
L794: [ C309 , C308 ] in { [ C309 , C308 ] } by TARSKI:def 1;
L795: [ C309 , C308 ] in (the carrier of D138) by L794 , L791 , XBOOLE_0:def 3;
L796: ( D139 . [ C309 , C308 ] ) = C307 by L795 , FUNCOP_1:7;
L797: ( dom (the Arity of D138) ) = { [ C309 , C308 ] } by L789 , FUNCT_2:def 1;
L798:
now
let C310 being set;
L799: ( ( D139 # ) . D141 ) = ( C306 -tuples_on C307 ) by L786 , L35;
assume L800: C310 in (the carrier' of D138);
L801: C310 = [ C309 , C308 ] by L800 , L789 , TARSKI:def 1;
L802: ( ( ( D139 # ) * (the Arity of D138) ) . C310 ) = ( ( D139 # ) . C309 ) by L801 , L789 , L787 , L797 , L800 , FUNCT_1:13;
L803: ( ( D139 * (the ResultSort of D138) ) . C310 ) = C307 by L789 , L788 , L796 , L790 , L800 , L801 , FUNCT_1:13;
thus L804: ( D140 . C310 ) is (Function of ( ( ( D139 # ) * (the Arity of D138) ) . C310 ) , ( ( D139 * (the ResultSort of D138) ) . C310 )) by L803 , L800 , L802 , L799 , FUNCOP_1:7;
end;
reconsider D142 = D140 as (ManySortedFunction of ( ( D139 # ) * (the Arity of D138) ) , ( D139 * (the ResultSort of D138) )) by L798 , PBOOLE:def 15;
reconsider D143 = MSAlgebra (# D139 , D142 #) as  non-empty  strict MSAlgebra over ( 1GateCircStr (C309 , C308) ) by MSUALG_1:def 3;
take D143;
thus L805: thesis by L789 , L794 , FUNCOP_1:7;
end;
uniqueness
proof
set D144 = ( 1GateCircStr (C309 , C308) );
let C311 , C312 being  strict  non-empty MSAlgebra over D144;
assume that
L806: (not thesis);
L807: (the carrier' of D144) = { [ C309 , C308 ] } by L544;
L808: ( dom (the Charact of C311) ) = { [ C309 , C308 ] } by L807 , PARTFUN1:def 2;
L809: (the Charact of C311) = { [ [ C309 , C308 ] , C308 ] } by L808 , L806 , GRFUNC_1:7;
L810: ( dom (the Charact of C312) ) = { [ C309 , C308 ] } by L807 , PARTFUN1:def 2;
thus L811: thesis by L810 , L806 , L809 , GRFUNC_1:7;
end;
end;
theorem
L813: (for B237 being Nat holds (for B238 being non  empty set holds (for B239 being (Function of ( B237 -tuples_on B238 ) , B238) holds (for B240 being (FinSeqLen of B237) holds (( 1GateCircuit (B240 , B239) ) is  gate`2=den & ( 1GateCircStr (B240 , B239) ) is  gate`2=den)))))
proof
let C313 being Nat;
let C314 being non  empty set;
let C315 being (Function of ( C313 -tuples_on C314 ) , C314);
let C316 being (FinSeqLen of C313);
thus L814: ( 1GateCircuit (C316 , C315) ) is  gate`2=den
proof
let C317 being set;
assume L815: C317 in (the carrier' of ( 1GateCircStr (C316 , C315) ));
L816: C317 = [ C316 , C315 ] by L815 , L569;
thus L817: C317 = [ ( C317 `1 ) , C315 ] by L816 , MCART_1:7
.= [ ( C317 `1 ) , ( (the Charact of ( 1GateCircuit (C316 , C315) )) . C317 ) ] by L816 , L785;
end;

take ( 1GateCircuit (C316 , C315) );
thus L818: thesis by L814;
end;
registration
let C318 being Nat;
let C319 being non  empty set;
let C320 being (Function of ( C318 -tuples_on C319 ) , C319);
let C321 being (FinSeqLen of C318);
cluster ( 1GateCircuit (C321 , C320) ) ->  gate`2=den;
coherence by L813;
cluster ( 1GateCircStr (C321 , C320) ) ->  gate`2=den;
coherence by L813;
end;
theorem
L820: (for B241 being Nat holds (for B242 being (FinSeqLen of B241) holds (for B243 being (Function of ( B241 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds ( 1GateCircStr (B242 , B243) ) is  gate`2isBoolean)))
proof
set D145 = ( BOOLEAN );
let C322 being Nat;
let C323 being (FinSeqLen of C322);
let C324 being (Function of ( C322 -tuples_on D145 ) , D145);
let C325 being set;
L821: ( len C323 ) = C322 by CARD_1:def 7;
L822: ( (the Arity of ( 1GateCircStr (C323 , C324) )) . [ C323 , C324 ] ) = C323 by L544;
assume L823: C325 in (the carrier' of ( 1GateCircStr (C323 , C324) ));
L824: C325 = [ C323 , C324 ] by L823 , L569;
let C326 being FinSequence;
assume L825: C326 = ( (the Arity of ( 1GateCircStr (C323 , C324) )) . C325 );
reconsider D146 = C324 as (Function of ( ( len C326 ) -tuples_on D145 ) , D145) by L825 , L824 , L822 , L821;
take D146;
thus L826: thesis by L824 , MCART_1:7;
end;
registration
let C327 being Nat;
let C328 being (Function of ( C327 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C329 being (FinSeqLen of C327);
cluster ( 1GateCircStr (C329 , C328) ) ->  gate`2isBoolean;
coherence by L820;
end;
registration
cluster  gate`2isBoolean non  empty for ManySortedSign;
existence
proof
set D147 = the (FinSeqLen of ( 0 ));
set D148 = the (Function of ( ( 0 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
take ( 1GateCircStr (D147 , D148) );
thus L828: thesis;
end;
end;
registration
let C330 , C331 being  gate`2isBoolean non  empty ManySortedSign;
cluster ( C330 +* C331 ) ->  gate`2isBoolean;
coherence by L723;
end;
theorem
L831: (for B244 being Nat holds (for B245 being non  empty set holds (for B246 being (Function of ( B244 -tuples_on B245 ) , B245) holds (for B247 being (FinSeqLen of B244) holds ((the Charact of ( 1GateCircuit (B247 , B246) )) = ( (B247 , B246) .--> B246 ) & (for B248 being (Vertex of ( 1GateCircStr (B247 , B246) )) holds ( (the Sorts of ( 1GateCircuit (B247 , B246) )) . B248 ) = B245))))))
proof
let C332 being Nat;
let C333 being non  empty set;
let C334 being (Function of ( C332 -tuples_on C333 ) , C333);
let C335 being (FinSeqLen of C332);
set D149 = ( 1GateCircStr (C335 , C334) );
set D150 = ( 1GateCircuit (C335 , C334) );
L832: ( (the Charact of D150) . [ C335 , C334 ] ) = C334 by L785;
L833: (for B249 being set holds (B249 in { [ C335 , C334 ] } implies ( (the Charact of D150) . B249 ) = C334)) by L832 , TARSKI:def 1;
L834: (the carrier' of D149) = { [ C335 , C334 ] } by L544;
L835: ( dom (the Charact of D150) ) = { [ C335 , C334 ] } by L834 , PARTFUN1:def 2;
thus L836: (the Charact of D150) = ( (C335 , C334) .--> C334 ) by L835 , L833 , FUNCOP_1:11;
let C336 being (Vertex of D149);
L837: (the Sorts of D150) = ( (the carrier of D149) --> C333 ) by L785;
thus L838: thesis by L837 , FUNCOP_1:7;
end;
registration
let C337 being Nat;
let C338 being non  empty  finite set;
let C339 being (Function of ( C337 -tuples_on C338 ) , C338);
let C340 being (FinSeqLen of C337);
cluster ( 1GateCircuit (C340 , C339) ) ->  finite-yielding;
coherence
proof
let C341 being set;
set D151 = ( 1GateCircStr (C340 , C339) );
assume L839: C341 in (the carrier of D151);
thus L840: thesis by L839 , L831;
end;
end;
theorem
L842: (for B250 being Nat holds (for B251 being non  empty set holds (for B252 being (Function of ( B250 -tuples_on B251 ) , B251) holds (for B253 , B254 being (FinSeqLen of B250) holds ( 1GateCircuit (B253 , B252) ) tolerates ( 1GateCircuit (B254 , B252) )))))
proof
let C342 being Nat;
let C343 being non  empty set;
let C344 being (Function of ( C342 -tuples_on C343 ) , C343);
let C345 , C346 being (FinSeqLen of C342);
set D152 = ( 1GateCircStr (C345 , C344) );
set D153 = ( 1GateCircStr (C346 , C344) );
set D154 = ( 1GateCircuit (C345 , C344) );
set D155 = ( 1GateCircuit (C346 , C344) );
thus L843: ( 1GateCircStr (C345 , C344) ) tolerates ( 1GateCircStr (C346 , C344) ) by L592;
L844: (the Sorts of D155) = ( (the carrier of D153) --> C343 ) by L785;
L845: (the Sorts of D154) = ( (the carrier of D152) --> C343 ) by L785;
thus L846: (the Sorts of D154) tolerates (the Sorts of D155) by L845 , L844 , FUNCOP_1:87;
L847: (the Charact of D155) = ( (C346 , C344) .--> C344 ) by L831;
L848: (the Charact of D154) = ( (C345 , C344) .--> C344 ) by L831;
thus L849: thesis by L848 , L847 , FUNCOP_1:87;
end;
theorem
L850: (for B255 being Nat holds (for B256 being  finite non  empty set holds (for B257 being (Function of ( B255 -tuples_on B256 ) , B256) holds (for B258 being (FinSeqLen of B255) holds (for B259 being (State of ( 1GateCircuit (B258 , B257) )) holds ( ( Following B259 ) . [ B258 , B257 ] ) = ( B257 . ( B259 * B258 ) ))))))
proof
let C347 being Nat;
let C348 being non  empty  finite set;
let C349 being (Function of ( C347 -tuples_on C348 ) , C348);
let C350 being (FinSeqLen of C347);
let C351 being (State of ( 1GateCircuit (C350 , C349) ));
set D156 = ( 1GateCircStr (C350 , C349) );
set D157 = ( 1GateCircuit (C350 , C349) );
set D158 = ( InnerVertices D156 );
L851: D158 = { [ C350 , C349 ] } by L573;
reconsider D159 = [ C350 , C349 ] as (Element of D158) by L851 , TARSKI:def 1;
L852: (the carrier' of D156) = { [ C350 , C349 ] } by L544;
reconsider D160 = [ C350 , C349 ] as (Gate of D156) by L852 , TARSKI:def 1;
L853: ( the_result_sort_of D160 ) = D159 by L544;
L854: ( action_at D159 ) = D160 by L853 , MSAFREE2:def 7;
L855: ( the_arity_of D160 ) = C350 by L544;
L856: ( D160 depends_on_in C351 ) = ( C351 * C350 ) by L855 , CIRCUIT1:def 3;
L857: ( ( Following C351 ) . D159 ) = ( ( Den (( action_at D159 ) , D157) ) . ( ( action_at D159 ) depends_on_in C351 ) ) by CIRCUIT2:def 5;
thus L858: thesis by L857 , L854 , L856 , L785;
end;
begin
definition
let C352 being non  empty ManySortedSign;
let C353 being MSAlgebra over C352;
attr C353 is  Boolean
means
:L859: (for B260 being (Vertex of C352) holds ( (the Sorts of C353) . B260 ) = ( BOOLEAN ));
end;
theorem
L861: (for B261 being non  empty ManySortedSign holds (for B262 being MSAlgebra over B261 holds (B262 is  Boolean iff (the Sorts of B262) = ( (the carrier of B261) --> ( BOOLEAN ) ))))
proof
let C354 being non  empty ManySortedSign;
let C355 being MSAlgebra over C354;
L862: ( dom (the Sorts of C355) ) = (the carrier of C354) by PARTFUN1:def 2;
thus L863: (C355 is  Boolean implies (the Sorts of C355) = ( (the carrier of C354) --> ( BOOLEAN ) ))
proof
assume L864: (for B263 being (Vertex of C354) holds ( (the Sorts of C355) . B263 ) = ( BOOLEAN ));
L865: (for B264 being set holds (B264 in (the carrier of C354) implies ( (the Sorts of C355) . B264 ) = ( BOOLEAN ))) by L864;
thus L866: thesis by L865 , L862 , FUNCOP_1:11;
end;

assume L867: (the Sorts of C355) = ( (the carrier of C354) --> ( BOOLEAN ) );
let C356 being (Vertex of C354);
thus L868: thesis by L867 , FUNCOP_1:7;
end;
registration
let C357 being non  empty ManySortedSign;
cluster  Boolean ->  non-empty  finite-yielding for MSAlgebra over C357;
coherence
proof
let C358 being MSAlgebra over C357;
assume L869: C358 is  Boolean;
L870: (the Sorts of C358) = ( (the carrier of C357) --> ( BOOLEAN ) ) by L869 , L861;
thus L871: C358 is  non-empty by L870 , MSUALG_1:def 3;
let C359 being set;
thus L872: thesis by L869 , L859;
end;
end;
theorem
L874: (for B265 being non  empty ManySortedSign holds (for B266 being MSAlgebra over B265 holds (B266 is  Boolean iff ( rng (the Sorts of B266) ) c= { ( BOOLEAN ) })))
proof
let C360 being non  empty ManySortedSign;
let C361 being MSAlgebra over C360;
thus L875:now
assume L876: C361 is  Boolean;
L877: (the Sorts of C361) = ( (the carrier of C360) --> ( BOOLEAN ) ) by L876 , L861;
thus L878: ( rng (the Sorts of C361) ) c= { ( BOOLEAN ) } by L877 , FUNCOP_1:13;
end;
assume L879: ( rng (the Sorts of C361) ) c= { ( BOOLEAN ) };
let C362 being (Vertex of C360);
L880: ( dom (the Sorts of C361) ) = (the carrier of C360) by PARTFUN1:def 2;
L881: ( (the Sorts of C361) . C362 ) in ( rng (the Sorts of C361) ) by L880 , FUNCT_1:def 3;
thus L882: thesis by L881 , L879 , TARSKI:def 1;
end;
theorem
L883: (for B267 , B268 being non  empty ManySortedSign holds (for B269 being MSAlgebra over B267 holds (for B270 being MSAlgebra over B268 holds ((B269 is  Boolean & B270 is  Boolean) implies (the Sorts of B269) tolerates (the Sorts of B270)))))
proof
let C363 , C364 being non  empty ManySortedSign;
let C365 being MSAlgebra over C363;
let C366 being MSAlgebra over C364;
assume that
L884: C365 is  Boolean
and
L885: C366 is  Boolean;
L886: (the Sorts of C366) = ( (the carrier of C364) --> ( BOOLEAN ) ) by L885 , L861;
L887: (the Sorts of C365) = ( (the carrier of C363) --> ( BOOLEAN ) ) by L884 , L861;
thus L888: thesis by L887 , L886 , FUNCOP_1:87;
end;
theorem
L889: (for B271 , B272 being  unsplit  gate`1=arity non  empty ManySortedSign holds (for B273 being MSAlgebra over B271 holds (for B274 being MSAlgebra over B272 holds ((B273 is  Boolean  gate`2=den & B274 is  Boolean  gate`2=den) implies B273 tolerates B274))))
proof
let C367 , C368 being  unsplit  gate`1=arity non  empty ManySortedSign;
let C369 being MSAlgebra over C367;
let C370 being MSAlgebra over C368;
assume that
L890: C369 is  Boolean  gate`2=den
and
L891: C370 is  Boolean  gate`2=den;
thus L892: (C367 tolerates C368 & (the Sorts of C369) tolerates (the Sorts of C370) & (the Charact of C369) tolerates (the Charact of C370)) by L890 , L891 , L673 , L690 , L883;
end;
registration
let C371 being non  empty ManySortedSign;
cluster  Boolean for  strict  strict  strict  strict MSAlgebra over C371;
existence
proof
deffunc H3(set , (Element of ( (the carrier of C371) * ))) = ( ( ( len $2 ) -tuples_on ( BOOLEAN ) ) --> ( FALSE ) );
L893: (for B275 being set holds (for B276 being (Element of ( (the carrier of C371) * )) holds ((B275 in (the carrier' of C371) & B276 = ( (the Arity of C371) . B275 )) implies H3(B275 , B276) is (Function of ( ( len B276 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )))));
consider C372 being  strict MSAlgebra over C371 such that L894: ((the Sorts of C372) = ( (the carrier of C371) --> ( BOOLEAN ) ) & (for B277 being set holds (for B278 being (Element of ( (the carrier of C371) * )) holds ((B277 in (the carrier' of C371) & B278 = ( (the Arity of C371) . B277 )) implies ( (the Charact of C372) . B277 ) = H3(B277 , B278))))) from Lemma(L893);
take C372;
let C373 being (Vertex of C371);
thus L895: thesis by L894 , FUNCOP_1:7;
end;
end;
theorem
L897: (for B279 being Nat holds (for B280 being (Function of ( B279 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) holds (for B281 being (FinSeqLen of B279) holds ( 1GateCircuit (B281 , B280) ) is  Boolean)))
proof
let C374 being Nat;
let C375 being (Function of ( C374 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C376 being (FinSeqLen of C374);
set D161 = ( 1GateCircStr (C376 , C375) );
set D162 = ( 1GateCircuit (C376 , C375) );
let C377 being (Vertex of D161);
L898: (the Sorts of D162) = ( (the carrier of D161) --> ( BOOLEAN ) ) by L785;
thus L899: thesis by L898 , FUNCOP_1:7;
end;
theorem
L900: (for B282 , B283 being non  empty ManySortedSign holds (for B284 being  Boolean MSAlgebra over B282 holds (for B285 being  Boolean MSAlgebra over B283 holds ( B284 +* B285 ) is  Boolean)))
proof
let C378 , C379 being non  empty ManySortedSign;
let C380 being  Boolean MSAlgebra over C378;
let C381 being  Boolean MSAlgebra over C379;
set D163 = ( C380 +* C381 );
set D164 = ( C378 +* C379 );
L901: ( dom (the Sorts of C380) ) = (the carrier of C378) by PARTFUN1:def 2;
let C382 being (Vertex of D164);
L902: ( dom (the Sorts of C381) ) = (the carrier of C379) by PARTFUN1:def 2;
L903: (the carrier of D164) = ( (the carrier of C378) \/ (the carrier of C379) ) by L56;
L904: (C382 in (the carrier of C378) or C382 in (the carrier of C379)) by L903 , XBOOLE_0:def 3;
L905: (the Sorts of C381) = ( (the carrier of C379) --> ( BOOLEAN ) ) by L861;
L906: (the Sorts of C380) = ( (the carrier of C378) --> ( BOOLEAN ) ) by L861;
L907: (the Sorts of C380) tolerates (the Sorts of C381) by L906 , L905 , FUNCOP_1:87;
L908: (the Sorts of D163) = ( (the Sorts of C380) +* (the Sorts of C381) ) by L907 , L253;
L909: ((( (the Sorts of D163) . C382 ) = ( (the Sorts of C380) . C382 ) & ( (the Sorts of C380) . C382 ) = ( BOOLEAN )) or (( (the Sorts of D163) . C382 ) = ( (the Sorts of C381) . C382 ) & ( (the Sorts of C381) . C382 ) = ( BOOLEAN ))) by L908 , L906 , L905 , L907 , L901 , L902 , L904 , FUNCOP_1:7 , FUNCT_4:13 , FUNCT_4:15;
thus L910: thesis by L909;
end;
theorem
L911: (for B286 , B287 being non  empty ManySortedSign holds (for B288 being  non-empty MSAlgebra over B286 holds (for B289 being  non-empty MSAlgebra over B287 holds ((B288 is  gate`2=den & B289 is  gate`2=den & (the Sorts of B288) tolerates (the Sorts of B289)) implies ( B288 +* B289 ) is  gate`2=den))))
proof
let C383 , C384 being non  empty ManySortedSign;
let C385 being  non-empty MSAlgebra over C383;
let C386 being  non-empty MSAlgebra over C384;
set D165 = ( C385 +* C386 );
set D166 = ( C383 +* C384 );
assume that
L912: C385 is  gate`2=den
and
L913: C386 is  gate`2=den
and
L914: (the Sorts of C385) tolerates (the Sorts of C386);
L915: (the Charact of D165) = ( (the Charact of C385) +* (the Charact of C386) ) by L914 , L253;
let C387 being set;
L916: ( dom (the Charact of C385) ) = (the carrier' of C383) by PARTFUN1:def 2;
L917: ( dom (the Charact of C386) ) = (the carrier' of C384) by PARTFUN1:def 2;
L918: (the carrier' of D166) = ( (the carrier' of C383) \/ (the carrier' of C384) ) by L56;
assume L919: C387 in (the carrier' of D166);
L920: (C387 in (the carrier' of C383) or C387 in (the carrier' of C384)) by L919 , L918 , XBOOLE_0:def 3;
L921: (the Charact of C385) tolerates (the Charact of C386) by L912 , L913 , L690;
L922: ((( (the Charact of D165) . C387 ) = ( (the Charact of C385) . C387 ) & [ ( C387 `1 ) , ( (the Charact of C385) . C387 ) ] = C387) or (( (the Charact of D165) . C387 ) = ( (the Charact of C386) . C387 ) & [ ( C387 `1 ) , ( (the Charact of C386) . C387 ) ] = C387)) by L921 , L912 , L913 , L915 , L916 , L917 , L920 , L604 , FUNCT_4:13 , FUNCT_4:15;
thus L923: thesis by L922;
end;
registration
cluster  unsplit  gate`1=arity  gate`2=den  gate`2isBoolean non  void  strict for non  empty non  empty non  empty non  empty ManySortedSign;
existence
proof
set D167 = the (FinSeqLen of 1);
set D168 = the (Function of ( 1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
take ( 1GateCircStr (D167 , D168) );
thus L924: thesis;
end;
end;
registration
let C388 being  gate`2isBoolean non  empty ManySortedSign;
cluster  Boolean  gate`2=den for  strict  strict  strict  strict MSAlgebra over C388;
existence
proof
deffunc H4(set , set) = ( $1 `2 );
L926:
now
let C389 being set;
let C390 being (Element of ( (the carrier of C388) * ));
assume that
L927: C389 in (the carrier' of C388)
and
L928: C390 = ( (the Arity of C388) . C389 );
L929: (ex B290 being (Function of ( ( len C390 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) st C389 = [ ( C389 `1 ) , B290 ]) by L927 , L928 , L602;
thus L930: H4(C389 , C390) is (Function of ( ( len C390 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) by L929 , MCART_1:7;
end;
consider C391 being  strict MSAlgebra over C388 such that L931: ((the Sorts of C391) = ( (the carrier of C388) --> ( BOOLEAN ) ) & (for B291 being set holds (for B292 being (Element of ( (the carrier of C388) * )) holds ((B291 in (the carrier' of C388) & B292 = ( (the Arity of C388) . B291 )) implies ( (the Charact of C391) . B291 ) = H4(B291 , B292))))) from Lemma(L926);
take C391;
thus L932: C391 is  Boolean
proof
let C392 being (Vertex of C388);
thus L933: thesis by L931 , FUNCOP_1:7;
end;

let C393 being set;
assume L934: C393 in (the carrier' of C388);
reconsider D169 = ( (the Arity of C388) . C393 ) as (Element of ( (the carrier of C388) * )) by L934 , FUNCT_2:5;
consider C394 being (Function of ( ( len D169 ) -tuples_on ( BOOLEAN ) ) , ( BOOLEAN )) such that L935: C393 = [ ( C393 `1 ) , C394 ] by L934 , L602;
L936: ( C393 `2 ) = C394 by L935 , MCART_1:7;
thus L937: thesis by L936 , L931 , L934 , L935;
end;
end;
registration
let C395 , C396 being  unsplit  gate`2isBoolean non  void non  empty ManySortedSign;
let C397 being  Boolean  gate`2=den (Circuit of C395);
let C398 being  Boolean  gate`2=den (Circuit of C396);
cluster ( C397 +* C398 ) ->  Boolean  gate`2=den;
coherence
proof
L939: (the Sorts of C397) tolerates (the Sorts of C398) by L883;
thus L940: thesis by L939 , L900 , L911;
end;
end;
registration
let C399 being Nat;
let C400 being  finite non  empty set;
let C401 being (Function of ( C399 -tuples_on C400 ) , C400);
let C402 being (FinSeqLen of C399);
cluster  gate`2=den  strict  non-empty for (Circuit of ( 1GateCircStr (C402 , C401) ));
existence
proof
take ( 1GateCircuit (C402 , C401) );
thus L942: thesis;
end;
end;
registration
let C403 being Nat;
let C404 being  finite non  empty set;
let C405 being (Function of ( C403 -tuples_on C404 ) , C404);
let C406 being (FinSeqLen of C403);
cluster ( 1GateCircuit (C406 , C405) ) ->  gate`2=den;
coherence;
end;
theorem
L945: (for B293 , B294 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign holds (for B295 being  Boolean  gate`2=den (Circuit of B293) holds (for B296 being  Boolean  gate`2=den (Circuit of B294) holds (for B297 being (State of ( B295 +* B296 )) holds (for B298 being (Vertex of ( B293 +* B294 )) holds ((for B299 being (State of B295) holds (B299 = ( B297 | (the carrier of B293) ) implies ((B298 in ( InnerVertices B293 ) or (B298 in (the carrier of B293) & B298 in ( InputVertices ( B293 +* B294 ) ))) implies ( ( Following B297 ) . B298 ) = ( ( Following B299 ) . B298 )))) & (for B300 being (State of B296) holds (B300 = ( B297 | (the carrier of B294) ) implies ((B298 in ( InnerVertices B294 ) or (B298 in (the carrier of B294) & B298 in ( InputVertices ( B293 +* B294 ) ))) implies ( ( Following B297 ) . B298 ) = ( ( Following B300 ) . B298 ))))))))))
proof
let C407 , C408 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign;
let C409 being  Boolean  gate`2=den (Circuit of C407);
let C410 being  Boolean  gate`2=den (Circuit of C408);
L946: C409 tolerates C410 by L889;
thus L947: thesis by L946 , L403;
end;
