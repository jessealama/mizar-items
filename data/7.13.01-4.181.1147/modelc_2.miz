:: Model Checking, Part II
::  by Kazuhisa Ishida
::
:: Received April 21, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, CARD_1, ARYTM_3, XXREAL_0, XBOOLE_0, FINSEQ_1,
      MODELC_1, XBOOLEAN, ORDINAL4, TARSKI, RELAT_1, SUBSET_1, ZF_LANG,
      FUNCT_1, ARYTM_1, BINOP_1, ZFMISC_1, FUNCOP_1, FUNCT_2, VALUED_1,
      MARGREL1, ZF_MODEL, MODELC_2, STRUCT_0, FUNCT_5, LATTICES, ROBBINS1,
      EQREL_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0,
      RELAT_1, FUNCT_1, BINOP_1, FUNCT_2, ORDINAL1, NAT_1, FINSEQ_1, FUNCOP_1,
      MARGREL1, FUNCT_5, MODELC_1, STRUCT_0, LATTICES, ROBBINS1;
 constructors BINOP_1, VALUED_1, MODELC_1, RELSET_1, FUNCT_5;
 registrations XBOOLE_0, SUBSET_1, ORDINAL1, XXREAL_0, XREAL_0, NAT_1,
      XBOOLEAN, MARGREL1, FINSEQ_1, CARD_1, STRUCT_0, MODELC_1, RELSET_1,
      FUNCT_2;
 requirements REAL, NUMERALS, ARITHM, SUBSET, BOOLE;
 definitions TARSKI, BINOP_1, XBOOLEAN, ROBBINS1, LATTICES;
 theorems XBOOLE_0, ZFMISC_1, XBOOLE_1, TARSKI, FUNCT_1, FUNCT_2, NAT_1,
      XREAL_1, FINSEQ_1, FUNCOP_1, XXREAL_0, FINSEQ_5, XBOOLEAN, MODELC_1,
      ORDINAL1;
 schemes NAT_1, FUNCT_2, XBOOLE_0, BINOP_1, BINOP_2, MODELC_1;

begin
definition
let C1 being set;
func CastNat C1 -> Nat equals
:L1: C1 if C1 is Nat otherwise ( 0 );
correctness;
end;
L3: (for B1 , B2 , B3 being Nat holds ((B1 < B2 & B2 <= ( B3 + 1 )) implies B1 <= B3))
proof
let C2 , C3 , C4 being Nat;
assume that
L4: C2 < C3
and
L5: C3 <= ( C4 + 1 );
L6: ( C2 + 1 ) <= C3 by L4 , NAT_1:13;
L7: ( C2 + 1 ) <= ( C4 + 1 ) by L6 , L5 , XXREAL_0:2;
thus L8: thesis by L7 , XREAL_1:6;
end;
definition
let R2 being Nat;
func atom. R2 -> (FinSequence of ( NAT )) equals
<* ( 6 + R2 ) *>;
coherence;
end;
definition
let R12 being (FinSequence of ( NAT ));
func 'not' R12 -> (FinSequence of ( NAT )) equals
( <* ( 0 ) *> ^ R12 );
coherence;
let R13 being (FinSequence of ( NAT ));
func R12 '&' R13 -> (FinSequence of ( NAT )) equals
( ( <* 1 *> ^ R12 ) ^ R13 );
coherence;
func R12 'or' R13 -> (FinSequence of ( NAT )) equals
( ( <* 2 *> ^ R12 ) ^ R13 );
coherence;
end;
definition
let R12 being (FinSequence of ( NAT ));
func 'X' R12 -> (FinSequence of ( NAT )) equals
( <* 3 *> ^ R12 );
coherence;
let R13 being (FinSequence of ( NAT ));
func R12 'U' R13 -> (FinSequence of ( NAT )) equals
( ( <* 4 *> ^ R12 ) ^ R13 );
coherence;
func R12 'R' R13 -> (FinSequence of ( NAT )) equals
( ( <* 5 *> ^ R12 ) ^ R13 );
coherence;
end;
L12: (for R2 being Nat holds (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ( len ( ( <* R2 *> ^ R12 ) ^ R13 ) ) = ( ( 1 + ( len R12 ) ) + ( len R13 ) ))))
proof
let R2 being Nat;
let R12 being (FinSequence of ( NAT ));
let R13 being (FinSequence of ( NAT ));
L13: ( len ( R12 ^ R13 ) ) = ( ( len R12 ) + ( len R13 ) ) by FINSEQ_1:22;
L14: ( ( len <* R2 *> ) + ( len ( R12 ^ R13 ) ) ) = ( ( ( len <* R2 *> ) + ( len R12 ) ) + ( len R13 ) ) by L13;
L15: ( len ( ( <* R2 *> ^ R12 ) ^ R13 ) ) = ( len ( <* R2 *> ^ ( R12 ^ R13 ) ) ) by FINSEQ_1:32
.= ( ( len <* R2 *> ) + ( len ( R12 ^ R13 ) ) ) by FINSEQ_1:22;
thus L16: thesis by L15 , L14 , FINSEQ_1:40;
end;
definition
func LTL_WFF -> non  empty set means
:L17: ((for R4 being set holds (R4 in it implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in it) & (for R12 being (FinSequence of ( NAT )) holds (R12 in it implies ( 'not' R12 ) in it)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in it & R13 in it) implies ( R12 '&' R13 ) in it))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in it & R13 in it) implies ( R12 'or' R13 ) in it))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in it implies ( 'X' R12 ) in it)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in it & R13 in it) implies ( R12 'U' R13 ) in it))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in it & R13 in it) implies ( R12 'R' R13 ) in it))) & (for R8 being non  empty set holds (((for R4 being set holds (R4 in R8 implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in R8) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R8 implies ( 'not' R12 ) in R8)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 '&' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'or' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R8 implies ( 'X' R12 ) in R8)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'U' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'R' R13 ) in R8)))) implies it c= R8)));
existence
proof
defpred S1[ set ] means ((for R4 being set holds (R4 in $1 implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in $1) & (for R12 being (FinSequence of ( NAT )) holds (R12 in $1 implies ( 'not' R12 ) in $1)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in $1 & R13 in $1) implies ( R12 '&' R13 ) in $1))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in $1 & R13 in $1) implies ( R12 'or' R13 ) in $1))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in $1 implies ( 'X' R12 ) in $1)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in $1 & R13 in $1) implies ( R12 'U' R13 ) in $1))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in $1 & R13 in $1) implies ( R12 'R' R13 ) in $1))));
defpred S2[ set ] means (for R8 being non  empty set holds (S1[ R8 ] implies $1 in R8));
consider R7 being set such that L18: (for R4 being set holds (R4 in R7 iff (R4 in ( ( NAT ) * ) & S2[ R4 ]))) from XBOOLE_0:sch 1;
L19:
now
set D1 = ( atom. ( 0 ) );
take D2 = D1;
L20: (D1 in ( ( NAT ) * ) & (for R8 being non  empty set holds (S1[ R8 ] implies D1 in R8))) by FINSEQ_1:def 11;
thus L21: D2 in R7 by L20 , L18;
end;
reconsider D3 = R7 as non  empty set by L19;
take D3;
thus L22: (for R4 being set holds (R4 in D3 implies R4 is (FinSequence of ( NAT ))))
proof
let R4 being set;
assume L23: R4 in D3;
L24: R4 in ( ( NAT ) * ) by L23 , L18;
thus L25: thesis by L24 , FINSEQ_1:def 11;
end;

thus L26: (for R2 being Nat holds ( atom. R2 ) in D3)
proof
let R2 being Nat;
L27: (( atom. R2 ) in ( ( NAT ) * ) & (for R8 being non  empty set holds (S1[ R8 ] implies ( atom. R2 ) in R8))) by FINSEQ_1:def 11;
thus L28: thesis by L27 , L18;
end;

thus L29: (for R12 being (FinSequence of ( NAT )) holds (R12 in D3 implies ( 'not' R12 ) in D3))
proof
let R12 being (FinSequence of ( NAT ));
assume L30: R12 in D3;
L31: (for R8 being non  empty set holds (S1[ R8 ] implies ( 'not' R12 ) in R8))
proof
let R8 being non  empty set;
assume L32: S1[ R8 ];
L33: R12 in R8 by L32 , L18 , L30;
thus L34: thesis by L33 , L32;
end;
L35: ( 'not' R12 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L36: thesis by L35 , L18 , L31;
end;

thus L37: (for R13 being (FinSequence of ( NAT )) holds (for R12 being (FinSequence of ( NAT )) holds ((R13 in D3 & R12 in D3) implies ( R13 '&' R12 ) in D3)))
proof
let R13 being (FinSequence of ( NAT ));
let R12 being (FinSequence of ( NAT ));
assume L38: (R13 in D3 & R12 in D3);
L39: (for R8 being non  empty set holds (S1[ R8 ] implies ( R13 '&' R12 ) in R8))
proof
let R8 being non  empty set;
assume L40: S1[ R8 ];
L41: (R12 in R8 & R13 in R8) by L40 , L18 , L38;
thus L42: thesis by L41 , L40;
end;
L43: ( R13 '&' R12 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L44: thesis by L43 , L18 , L39;
end;

thus L45: (for R13 being (FinSequence of ( NAT )) holds (for R12 being (FinSequence of ( NAT )) holds ((R13 in D3 & R12 in D3) implies ( R13 'or' R12 ) in D3)))
proof
let R13 being (FinSequence of ( NAT ));
let R12 being (FinSequence of ( NAT ));
assume L46: (R13 in D3 & R12 in D3);
L47: (for R8 being non  empty set holds (S1[ R8 ] implies ( R13 'or' R12 ) in R8))
proof
let R8 being non  empty set;
assume L48: S1[ R8 ];
L49: (R12 in R8 & R13 in R8) by L48 , L18 , L46;
thus L50: thesis by L49 , L48;
end;
L51: ( R13 'or' R12 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L52: thesis by L51 , L18 , L47;
end;

thus L53: (for R12 being (FinSequence of ( NAT )) holds (R12 in D3 implies ( 'X' R12 ) in D3))
proof
let R12 being (FinSequence of ( NAT ));
assume L54: R12 in D3;
L55: (for R8 being non  empty set holds (S1[ R8 ] implies ( 'X' R12 ) in R8))
proof
let R8 being non  empty set;
assume L56: S1[ R8 ];
L57: R12 in R8 by L56 , L18 , L54;
thus L58: thesis by L57 , L56;
end;
L59: ( 'X' R12 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L60: thesis by L59 , L18 , L55;
end;

thus L61: (for R13 being (FinSequence of ( NAT )) holds (for R12 being (FinSequence of ( NAT )) holds ((R13 in D3 & R12 in D3) implies ( R13 'U' R12 ) in D3)))
proof
let R13 being (FinSequence of ( NAT ));
let R12 being (FinSequence of ( NAT ));
assume L62: (R13 in D3 & R12 in D3);
L63: (for R8 being non  empty set holds (S1[ R8 ] implies ( R13 'U' R12 ) in R8))
proof
let R8 being non  empty set;
assume L64: S1[ R8 ];
L65: (R12 in R8 & R13 in R8) by L64 , L18 , L62;
thus L66: thesis by L65 , L64;
end;
L67: ( R13 'U' R12 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L68: thesis by L67 , L18 , L63;
end;

thus L69: (for R13 being (FinSequence of ( NAT )) holds (for R12 being (FinSequence of ( NAT )) holds ((R13 in D3 & R12 in D3) implies ( R13 'R' R12 ) in D3)))
proof
let R13 being (FinSequence of ( NAT ));
let R12 being (FinSequence of ( NAT ));
assume L70: (R13 in D3 & R12 in D3);
L71: (for R8 being non  empty set holds (S1[ R8 ] implies ( R13 'R' R12 ) in R8))
proof
let R8 being non  empty set;
assume L72: S1[ R8 ];
L73: (R12 in R8 & R13 in R8) by L72 , L18 , L70;
thus L74: thesis by L73 , L72;
end;
L75: ( R13 'R' R12 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L76: thesis by L75 , L18 , L71;
end;

let R8 being non  empty set;
assume that
L77: S1[ R8 ];
let R4 being set;
assume L78: R4 in D3;
thus L79: thesis by L78 , L18 , L77;
end;
uniqueness
proof
let R9 being non  empty set;
let R10 being non  empty set;
assume L80: ((for R4 being set holds (R4 in R9 implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in R9) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R9 implies ( 'not' R12 ) in R9)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R9 & R13 in R9) implies ( R12 '&' R13 ) in R9))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R9 & R13 in R9) implies ( R12 'or' R13 ) in R9))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R9 implies ( 'X' R12 ) in R9)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R9 & R13 in R9) implies ( R12 'U' R13 ) in R9))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R9 & R13 in R9) implies ( R12 'R' R13 ) in R9))) & (for R8 being non  empty set holds (((for R4 being set holds (R4 in R8 implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in R8) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R8 implies ( 'not' R12 ) in R8)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 '&' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'or' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R8 implies ( 'X' R12 ) in R8)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'U' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'R' R13 ) in R8)))) implies R9 c= R8)) & (for R4 being set holds (R4 in R10 implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in R10) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R10 implies ( 'not' R12 ) in R10)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R10 & R13 in R10) implies ( R12 '&' R13 ) in R10))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R10 & R13 in R10) implies ( R12 'or' R13 ) in R10))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R10 implies ( 'X' R12 ) in R10)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R10 & R13 in R10) implies ( R12 'U' R13 ) in R10))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R10 & R13 in R10) implies ( R12 'R' R13 ) in R10))) & (for R8 being non  empty set holds (((for R4 being set holds (R4 in R8 implies R4 is (FinSequence of ( NAT )))) & (for R2 being Nat holds ( atom. R2 ) in R8) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R8 implies ( 'not' R12 ) in R8)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 '&' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'or' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (R12 in R8 implies ( 'X' R12 ) in R8)) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'U' R13 ) in R8))) & (for R12 being (FinSequence of ( NAT )) holds (for R13 being (FinSequence of ( NAT )) holds ((R12 in R8 & R13 in R8) implies ( R12 'R' R13 ) in R8)))) implies R10 c= R8)));
L81: (R9 c= R10 & R10 c= R9) by L80;
thus L82: thesis by L81 , XBOOLE_0:def 10;
end;
end;
definition
let C5 being (FinSequence of ( NAT ));
attr C5 is  LTL-formula-like
means
:L84: C5 is (Element of ( LTL_WFF ));
end;
registration
cluster  LTL-formula-like for (FinSequence of ( NAT ));
existence
proof
set D4 = the (Element of ( LTL_WFF ));
reconsider D5 = D4 as (FinSequence of ( NAT )) by L17;
take D5;
thus L86: D5 is (Element of ( LTL_WFF ));
end;
end;
definition
mode LTL-formula
 is  LTL-formula-like (FinSequence of ( NAT ));
end;
theorem
L89: (for R4 being set holds (R4 is LTL-formula iff R4 in ( LTL_WFF )))
proof
let R4 being set;
thus L90: (R4 is LTL-formula implies R4 in ( LTL_WFF ))
proof
assume L91: R4 is LTL-formula;
L92: R4 is (Element of ( LTL_WFF )) by L91 , L84;
thus L93: thesis by L92;
end;

assume L94: R4 in ( LTL_WFF );
thus L95: thesis by L94 , L17 , L84;
end;
registration
let R2 being Nat;
cluster ( atom. R2 ) ->  LTL-formula-like;
coherence
proof
L96: ( atom. R2 ) is (Element of ( LTL_WFF )) by L17;
thus L97: thesis by L96 , L84;
end;
end;
registration
let R18 being LTL-formula;
cluster ( 'not' R18 ) ->  LTL-formula-like;
coherence
proof
L99: R18 is (Element of ( LTL_WFF )) by L84;
L100: ( 'not' R18 ) is (Element of ( LTL_WFF )) by L99 , L17;
thus L101: thesis by L100 , L84;
end;
cluster ( 'X' R18 ) ->  LTL-formula-like;
coherence
proof
L102: R18 is (Element of ( LTL_WFF )) by L84;
L103: ( 'X' R18 ) is (Element of ( LTL_WFF )) by L102 , L17;
thus L104: thesis by L103 , L84;
end;
let R16 being LTL-formula;
cluster ( R18 '&' R16 ) ->  LTL-formula-like;
coherence
proof
L105: (R18 is (Element of ( LTL_WFF )) & R16 is (Element of ( LTL_WFF ))) by L84;
L106: ( R18 '&' R16 ) is (Element of ( LTL_WFF )) by L105 , L17;
thus L107: thesis by L106 , L84;
end;
cluster ( R18 'or' R16 ) ->  LTL-formula-like;
coherence
proof
L108: (R18 is (Element of ( LTL_WFF )) & R16 is (Element of ( LTL_WFF ))) by L84;
L109: ( R18 'or' R16 ) is (Element of ( LTL_WFF )) by L108 , L17;
thus L110: thesis by L109 , L84;
end;
cluster ( R18 'U' R16 ) ->  LTL-formula-like;
coherence
proof
L111: (R18 is (Element of ( LTL_WFF )) & R16 is (Element of ( LTL_WFF ))) by L84;
L112: ( R18 'U' R16 ) is (Element of ( LTL_WFF )) by L111 , L17;
thus L113: thesis by L112 , L84;
end;
cluster ( R18 'R' R16 ) ->  LTL-formula-like;
coherence
proof
L114: (R18 is (Element of ( LTL_WFF )) & R16 is (Element of ( LTL_WFF ))) by L84;
L115: ( R18 'R' R16 ) is (Element of ( LTL_WFF )) by L114 , L17;
thus L116: thesis by L115 , L84;
end;
end;
definition
let R18 being LTL-formula;
attr R18 is  atomic
means
:L118: (ex R2 being Nat st R18 = ( atom. R2 ));
attr R18 is  negative
means
:L119: (ex R19 being LTL-formula st R18 = ( 'not' R19 ));
attr R18 is  conjunctive
means
:L120: (ex R14 being LTL-formula st (ex R16 being LTL-formula st R18 = ( R14 '&' R16 )));
attr R18 is  disjunctive
means
:L121: (ex R14 being LTL-formula st (ex R16 being LTL-formula st R18 = ( R14 'or' R16 )));
attr R18 is  next
means
:L122: (ex R19 being LTL-formula st R18 = ( 'X' R19 ));
attr R18 is  Until
means
:L123: (ex R14 being LTL-formula st (ex R16 being LTL-formula st R18 = ( R14 'U' R16 )));
attr R18 is  Release
means
:L124: (ex R14 being LTL-formula st (ex R16 being LTL-formula st R18 = ( R14 'R' R16 )));
end;
theorem
L126: (for R18 being LTL-formula holds (R18 is  atomic or R18 is  negative or R18 is  conjunctive or R18 is  disjunctive or R18 is  next or R18 is  Until or R18 is  Release))
proof
let R18 being LTL-formula;
L127: R18 is (Element of ( LTL_WFF )) by L84;
assume L128: (not thesis);
L129: ( atom. ( 0 ) ) <> R18 by L128 , L118;
L130: (not ( atom. ( 0 ) ) in { R18 }) by L129 , TARSKI:def 1;
L131:
now
let R12 being (FinSequence of ( NAT ));
let R13 being (FinSequence of ( NAT ));
assume L132: (R12 in ( ( LTL_WFF ) \ { R18 } ) & R13 in ( ( LTL_WFF ) \ { R18 } ));
reconsider D6 = R12 , D7 = R13 as LTL-formula by L132 , L84;
L133: ( D6 'R' D7 ) <> R18 by L128 , L124;
L134: (not ( R12 'R' R13 ) in { R18 }) by L133 , TARSKI:def 1;
L135: ( R12 'R' R13 ) in ( LTL_WFF ) by L132 , L17;
thus L136: ( R12 'R' R13 ) in ( ( LTL_WFF ) \ { R18 } ) by L135 , L134 , XBOOLE_0:def 5;
end;
L137:
now
let R12 being (FinSequence of ( NAT ));
let R13 being (FinSequence of ( NAT ));
assume L138: (R12 in ( ( LTL_WFF ) \ { R18 } ) & R13 in ( ( LTL_WFF ) \ { R18 } ));
reconsider D8 = R12 , D9 = R13 as LTL-formula by L138 , L84;
L139: ( D8 'U' D9 ) <> R18 by L128 , L123;
L140: (not ( R12 'U' R13 ) in { R18 }) by L139 , TARSKI:def 1;
L141: ( R12 'U' R13 ) in ( LTL_WFF ) by L138 , L17;
thus L142: ( R12 'U' R13 ) in ( ( LTL_WFF ) \ { R18 } ) by L141 , L140 , XBOOLE_0:def 5;
end;
L143:
now
let R12 being (FinSequence of ( NAT ));
assume L144: R12 in ( ( LTL_WFF ) \ { R18 } );
reconsider D10 = R12 as LTL-formula by L144 , L84;
L145: ( 'X' D10 ) <> R18 by L128 , L122;
L146: (not ( 'X' R12 ) in { R18 }) by L145 , TARSKI:def 1;
L147: ( 'X' R12 ) in ( LTL_WFF ) by L144 , L17;
thus L148: ( 'X' R12 ) in ( ( LTL_WFF ) \ { R18 } ) by L147 , L146 , XBOOLE_0:def 5;
end;
L149:
now
let R12 being (FinSequence of ( NAT ));
let R13 being (FinSequence of ( NAT ));
assume L150: (R12 in ( ( LTL_WFF ) \ { R18 } ) & R13 in ( ( LTL_WFF ) \ { R18 } ));
reconsider D11 = R12 , D12 = R13 as LTL-formula by L150 , L84;
L151: ( D11 'or' D12 ) <> R18 by L128 , L121;
L152: (not ( R12 'or' R13 ) in { R18 }) by L151 , TARSKI:def 1;
L153: ( R12 'or' R13 ) in ( LTL_WFF ) by L150 , L17;
thus L154: ( R12 'or' R13 ) in ( ( LTL_WFF ) \ { R18 } ) by L153 , L152 , XBOOLE_0:def 5;
end;
L155:
now
let R12 being (FinSequence of ( NAT ));
let R13 being (FinSequence of ( NAT ));
assume L156: (R12 in ( ( LTL_WFF ) \ { R18 } ) & R13 in ( ( LTL_WFF ) \ { R18 } ));
reconsider D13 = R12 , D14 = R13 as LTL-formula by L156 , L84;
L157: ( D13 '&' D14 ) <> R18 by L128 , L120;
L158: (not ( R12 '&' R13 ) in { R18 }) by L157 , TARSKI:def 1;
L159: ( R12 '&' R13 ) in ( LTL_WFF ) by L156 , L17;
thus L160: ( R12 '&' R13 ) in ( ( LTL_WFF ) \ { R18 } ) by L159 , L158 , XBOOLE_0:def 5;
end;
L161:
now
let R12 being (FinSequence of ( NAT ));
assume L162: R12 in ( ( LTL_WFF ) \ { R18 } );
reconsider D15 = R12 as LTL-formula by L162 , L84;
L163: ( 'not' D15 ) <> R18 by L128 , L119;
L164: (not ( 'not' R12 ) in { R18 }) by L163 , TARSKI:def 1;
L165: ( 'not' R12 ) in ( LTL_WFF ) by L162 , L17;
thus L166: ( 'not' R12 ) in ( ( LTL_WFF ) \ { R18 } ) by L165 , L164 , XBOOLE_0:def 5;
end;
L167:
now
let R2 being Nat;
L168: ( atom. R2 ) <> R18 by L128 , L118;
L169: (not ( atom. R2 ) in { R18 }) by L168 , TARSKI:def 1;
L170: ( atom. R2 ) in ( LTL_WFF ) by L17;
thus L171: ( atom. R2 ) in ( ( LTL_WFF ) \ { R18 } ) by L170 , L169 , XBOOLE_0:def 5;
end;
L172: ( atom. ( 0 ) ) in ( LTL_WFF ) by L17;
L173: ( ( LTL_WFF ) \ { R18 } ) is non  empty by L172 , L130 , XBOOLE_0:def 5;
L174: (for R4 being set holds (R4 in ( ( LTL_WFF ) \ { R18 } ) implies R4 is (FinSequence of ( NAT )))) by L17;
L175: ( LTL_WFF ) c= ( ( LTL_WFF ) \ { R18 } ) by L174 , L173 , L167 , L161 , L155 , L149 , L143 , L137 , L131 , L17;
L176: R18 in ( ( LTL_WFF ) \ { R18 } ) by L175 , L127 , TARSKI:def 3;
L177: (not R18 in { R18 }) by L176 , XBOOLE_0:def 5;
thus L178: contradiction by L177 , TARSKI:def 1;
end;
L179: (for R18 being LTL-formula holds (R18 is  negative implies ( R18 . 1 ) = ( 0 )))
proof
let R18 being LTL-formula;
assume L180: R18 is  negative;
L181: (ex R19 being LTL-formula st R18 = ( 'not' R19 )) by L180 , L119;
thus L182: thesis by L181 , FINSEQ_1:41;
end;
L183: (for R18 being LTL-formula holds (R18 is  conjunctive implies ( R18 . 1 ) = 1))
proof
let R18 being LTL-formula;
assume L184: R18 is  conjunctive;
consider R14 being LTL-formula, R16 being LTL-formula such that L185: R18 = ( R14 '&' R16 ) by L184 , L120;
L186: ( ( <* 1 *> ^ R14 ) ^ R16 ) = ( <* 1 *> ^ ( R14 ^ R16 ) ) by FINSEQ_1:32;
thus L187: thesis by L186 , L185 , FINSEQ_1:41;
end;
L188: (for R18 being LTL-formula holds (R18 is  disjunctive implies ( R18 . 1 ) = 2))
proof
let R18 being LTL-formula;
assume L189: R18 is  disjunctive;
consider R14 being LTL-formula, R16 being LTL-formula such that L190: R18 = ( R14 'or' R16 ) by L189 , L121;
L191: ( ( <* 2 *> ^ R14 ) ^ R16 ) = ( <* 2 *> ^ ( R14 ^ R16 ) ) by FINSEQ_1:32;
thus L192: thesis by L191 , L190 , FINSEQ_1:41;
end;
L193: (for R18 being LTL-formula holds (R18 is  next implies ( R18 . 1 ) = 3))
proof
let R18 being LTL-formula;
assume L194: R18 is  next;
L195: (ex R19 being LTL-formula st R18 = ( 'X' R19 )) by L194 , L122;
thus L196: thesis by L195 , FINSEQ_1:41;
end;
L197: (for R18 being LTL-formula holds (R18 is  Until implies ( R18 . 1 ) = 4))
proof
let R18 being LTL-formula;
assume L198: R18 is  Until;
consider R14 being LTL-formula, R16 being LTL-formula such that L199: R18 = ( R14 'U' R16 ) by L198 , L123;
L200: ( ( <* 4 *> ^ R14 ) ^ R16 ) = ( <* 4 *> ^ ( R14 ^ R16 ) ) by FINSEQ_1:32;
thus L201: thesis by L200 , L199 , FINSEQ_1:41;
end;
L202: (for R18 being LTL-formula holds (R18 is  Release implies ( R18 . 1 ) = 5))
proof
let R18 being LTL-formula;
assume L203: R18 is  Release;
consider R14 being LTL-formula, R16 being LTL-formula such that L204: R18 = ( R14 'R' R16 ) by L203 , L124;
L205: ( ( <* 5 *> ^ R14 ) ^ R16 ) = ( <* 5 *> ^ ( R14 ^ R16 ) ) by FINSEQ_1:32;
thus L206: thesis by L205 , L204 , FINSEQ_1:41;
end;
L207: (for R18 being LTL-formula holds (R18 is  atomic implies ((not ( R18 . 1 ) = ( 0 )) & (not ( R18 . 1 ) = 1) & (not ( R18 . 1 ) = 2) & (not ( R18 . 1 ) = 3) & (not ( R18 . 1 ) = 4) & (not ( R18 . 1 ) = 5))))
proof
let R18 being LTL-formula;
assume L208: R18 is  atomic;
consider R2 being Nat such that L209: R18 = ( atom. R2 ) by L208 , L118;
L210: (( 3 + ( 0 ) ) < ( 3 + ( 3 + R2 ) ) & ( 4 + ( 0 ) ) < ( 4 + ( 2 + R2 ) )) by XREAL_1:8;
L211: ( 5 + ( 0 ) ) < ( 5 + ( 1 + R2 ) ) by XREAL_1:8;
L212: (( 1 + ( 0 ) ) < ( 1 + ( 5 + R2 ) ) & ( 2 + ( 0 ) ) < ( 2 + ( 4 + R2 ) )) by XREAL_1:8;
thus L213: thesis by L212 , L209 , L210 , L211 , FINSEQ_1:40;
end;
L214: (for R18 being LTL-formula holds ((R18 is  atomic & ( R18 . 1 ) <> ( 0 ) & ( R18 . 1 ) <> 1 & ( R18 . 1 ) <> 2 & ( R18 . 1 ) <> 3 & ( R18 . 1 ) <> 4 & ( R18 . 1 ) <> 5) or (R18 is  negative & ( R18 . 1 ) = ( 0 )) or (R18 is  conjunctive & ( R18 . 1 ) = 1) or (R18 is  disjunctive & ( R18 . 1 ) = 2) or (R18 is  next & ( R18 . 1 ) = 3) or (R18 is  Until & ( R18 . 1 ) = 4) or (R18 is  Release & ( R18 . 1 ) = 5)))
proof
let R18 being LTL-formula;
per cases  by L126;
case L215: R18 is  atomic;
thus L216: thesis by L215 , L207;
end;
case L217: R18 is  negative;
thus L218: thesis by L217 , L179;
end;
case L219: R18 is  conjunctive;
thus L220: thesis by L219 , L183;
end;
case L221: R18 is  disjunctive;
thus L222: thesis by L221 , L188;
end;
case L223: R18 is  next;
thus L224: thesis by L223 , L193;
end;
case L225: R18 is  Until;
thus L226: thesis by L225 , L197;
end;
case L227: R18 is  Release;
thus L228: thesis by L227 , L202;
end;
end;
theorem
L230: (for R18 being LTL-formula holds 1 <= ( len R18 ))
proof
let R18 being LTL-formula;
per cases  by L126;
suppose L231: R18 is  atomic;

L232: (ex R2 being Nat st R18 = ( atom. R2 )) by L231 , L118;
thus L233: thesis by L232 , FINSEQ_1:40;
end;
suppose L234: R18 is  negative;

consider R19 being LTL-formula such that L235: R18 = ( 'not' R19 ) by L234 , L119;
L236: ( len R18 ) = ( 1 + ( len R19 ) ) by L235 , FINSEQ_5:8;
thus L237: thesis by L236 , NAT_1:11;
end;
suppose L238: R18 is  conjunctive;

consider R14 being LTL-formula, R16 being LTL-formula such that L239: R18 = ( R14 '&' R16 ) by L238 , L120;
L240: (1 <= ( 1 + ( len R14 ) ) & ( 1 + ( len R14 ) ) <= ( ( 1 + ( len R14 ) ) + ( len R16 ) )) by NAT_1:11;
L241: ( len R18 ) = ( ( 1 + ( len R14 ) ) + ( len R16 ) ) by L239 , L12;
thus L242: thesis by L241 , L240 , XXREAL_0:2;
end;
suppose L243: R18 is  disjunctive;

consider R14 being LTL-formula, R16 being LTL-formula such that L244: R18 = ( R14 'or' R16 ) by L243 , L121;
L245: (1 <= ( 1 + ( len R14 ) ) & ( 1 + ( len R14 ) ) <= ( ( 1 + ( len R14 ) ) + ( len R16 ) )) by NAT_1:11;
L246: ( len R18 ) = ( ( 1 + ( len R14 ) ) + ( len R16 ) ) by L244 , L12;
thus L247: thesis by L246 , L245 , XXREAL_0:2;
end;
suppose L248: R18 is  next;

consider R19 being LTL-formula such that L249: R18 = ( 'X' R19 ) by L248 , L122;
L250: ( len R18 ) = ( 1 + ( len R19 ) ) by L249 , FINSEQ_5:8;
thus L251: thesis by L250 , NAT_1:11;
end;
suppose L252: R18 is  Until;

consider R14 being LTL-formula, R16 being LTL-formula such that L253: R18 = ( R14 'U' R16 ) by L252 , L123;
L254: (1 <= ( 1 + ( len R14 ) ) & ( 1 + ( len R14 ) ) <= ( ( 1 + ( len R14 ) ) + ( len R16 ) )) by NAT_1:11;
L255: ( len R18 ) = ( ( 1 + ( len R14 ) ) + ( len R16 ) ) by L253 , L12;
thus L256: thesis by L255 , L254 , XXREAL_0:2;
end;
suppose L257: R18 is  Release;

consider R14 being LTL-formula, R16 being LTL-formula such that L258: R18 = ( R14 'R' R16 ) by L257 , L124;
L259: (1 <= ( 1 + ( len R14 ) ) & ( 1 + ( len R14 ) ) <= ( ( 1 + ( len R14 ) ) + ( len R16 ) )) by NAT_1:11;
L260: ( len R18 ) = ( ( 1 + ( len R14 ) ) + ( len R16 ) ) by L258 , L12;
thus L261: thesis by L260 , L259 , XXREAL_0:2;
end;
end;
L263: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (for R21 being FinSequence holds (R18 = ( R14 ^ R21 ) implies R18 = R14))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
let R21 being FinSequence;
defpred S3[ Nat ] means (for R18 being LTL-formula holds (for R14 being LTL-formula holds (for R21 being FinSequence holds ((( len R18 ) = $1 & R18 = ( R14 ^ R21 )) implies R18 = R14))));
L264: (for B4 being Nat holds ((for B5 being Nat holds (B5 < B4 implies (for R18 being LTL-formula holds (for R14 being LTL-formula holds (for R21 being FinSequence holds ((( len R18 ) = B5 & R18 = ( R14 ^ R21 )) implies R18 = R14)))))) implies (for R18 being LTL-formula holds (for R14 being LTL-formula holds (for R21 being FinSequence holds ((( len R18 ) = B4 & R18 = ( R14 ^ R21 )) implies R18 = R14))))))
proof
let C6 being Nat;
assume that
L265: (for B6 being Nat holds (B6 < C6 implies (for R18 being LTL-formula holds (for R14 being LTL-formula holds (for R21 being FinSequence holds ((( len R18 ) = B6 & R18 = ( R14 ^ R21 )) implies R18 = R14))))));
let R18 being LTL-formula;
let R14 being LTL-formula;
let R21 being FinSequence;
assume that
L266: ( len R18 ) = C6
and
L267: R18 = ( R14 ^ R21 );
L268: (( dom R14 ) = ( Seg ( len R14 ) ) & 1 <= ( len R14 )) by L230 , FINSEQ_1:def 3;
L269: 1 in ( dom R14 ) by L268 , FINSEQ_1:1;
L270:
now
L271: ( len <* ( 0 ) *> ) = 1 by FINSEQ_1:40;
assume L272: R18 is  negative;
consider R19 being LTL-formula such that L273: R18 = ( 'not' R19 ) by L272 , L119;
L274: ( ( R14 ^ R21 ) . 1 ) = ( 0 ) by L267 , L272 , L179;
L275: ( R14 . 1 ) = ( 0 ) by L274 , L269 , FINSEQ_1:def 7;
L276: R14 is  negative by L275 , L214;
consider R15 being LTL-formula such that L277: R14 = ( 'not' R15 ) by L276 , L119;
L278: ( ( len <* ( 0 ) *> ) + ( len R19 ) ) = ( len R18 ) by L273 , FINSEQ_1:22;
L279: ( len R19 ) < ( len R18 ) by L278 , L271 , NAT_1:13;
L280: ( ( <* ( 0 ) *> ^ R15 ) ^ R21 ) = ( <* ( 0 ) *> ^ ( R15 ^ R21 ) ) by FINSEQ_1:32;
L281: R19 = ( R15 ^ R21 ) by L280 , L267 , L273 , L277 , FINSEQ_1:33;
thus L282: thesis by L281 , L265 , L266 , L273 , L277 , L279;
end;
L283:
now
assume L284: R18 is  Release;
consider R17 being LTL-formula, R16 being LTL-formula such that L285: R18 = ( R17 'R' R16 ) by L284 , L124;
L286: ( ( len R16 ) + ( 1 + ( len R17 ) ) ) = ( ( ( len R16 ) + 1 ) + ( len R17 ) );
L287: (( len ( <* 5 *> ^ R17 ) ) = ( ( len <* 5 *> ) + ( len R17 ) ) & ( len <* 5 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L288: ( ( len ( <* 5 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) by L285 , FINSEQ_1:22;
L289: ( ( len R16 ) + 1 ) <= ( len R18 ) by L288 , L287 , L286 , NAT_1:11;
L290: ( len R16 ) < ( len R18 ) by L289 , NAT_1:13;
L291: ( ( R14 ^ R21 ) . 1 ) = 5 by L267 , L284 , L202;
L292: ( R14 . 1 ) = 5 by L291 , L269 , FINSEQ_1:def 7;
L293: R14 is  Release by L292 , L214;
consider R15 being LTL-formula, R19 being LTL-formula such that L294: R14 = ( R15 'R' R19 ) by L293 , L124;
L295:
now
L296: ( ( ( ( len R15 ) + 1 ) + ( len R19 ) ) + ( len R21 ) ) = ( ( ( len R15 ) + 1 ) + ( ( len R19 ) + ( len R21 ) ) );
given R22 being FinSequence such that
L297: R15 = ( R17 ^ R22 );

L298: (( len ( R14 ^ R21 ) ) = ( ( len R14 ) + ( len R21 ) ) & ( len <* 5 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L299: (( len ( <* 5 *> ^ R15 ) ) = ( ( len <* 5 *> ) + ( len R15 ) ) & ( len R14 ) = ( ( len ( <* 5 *> ^ R15 ) ) + ( len R19 ) )) by L294 , FINSEQ_1:22;
L300: ( ( len R15 ) + 1 ) <= ( len R18 ) by L299 , L267 , L298 , L296 , NAT_1:11;
L301: ( len R15 ) < ( len R18 ) by L300 , NAT_1:13;
thus L302: R15 = R17 by L301 , L265 , L266 , L297;
end;
L303: (( ( <* 5 *> ^ R15 ) ^ R19 ) = ( <* 5 *> ^ ( R15 ^ R19 ) ) & ( ( <* 5 *> ^ ( R15 ^ R19 ) ) ^ R21 ) = ( <* 5 *> ^ ( ( R15 ^ R19 ) ^ R21 ) )) by FINSEQ_1:32;
L304:
now
given R22 being FinSequence such that
L305: R17 = ( R15 ^ R22 );

L306: ( len <* 5 *> ) = 1 by FINSEQ_1:40;
L307: (( ( len ( <* 5 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) & ( len ( <* 5 *> ^ R17 ) ) = ( ( len <* 5 *> ) + ( len R17 ) )) by L285 , FINSEQ_1:22;
L308: ( ( len R17 ) + 1 ) <= ( len R18 ) by L307 , L306 , NAT_1:11;
L309: ( len R17 ) < ( len R18 ) by L308 , NAT_1:13;
thus L310: R17 = R15 by L309 , L265 , L266 , L305;
end;
L311: ( ( R15 ^ R19 ) ^ R21 ) = ( R15 ^ ( R19 ^ R21 ) ) by FINSEQ_1:32;
L312: ( ( <* 5 *> ^ R17 ) ^ R16 ) = ( <* 5 *> ^ ( R17 ^ R16 ) ) by FINSEQ_1:32;
L313: ( R17 ^ R16 ) = ( R15 ^ ( R19 ^ R21 ) ) by L312 , L267 , L285 , L294 , L303 , L311 , FINSEQ_1:33;
L314: (( len R15 ) <= ( len R17 ) implies (ex R22 being FinSequence st R17 = ( R15 ^ R22 ))) by L313 , FINSEQ_1:47;
L315: R16 = ( R19 ^ R21 ) by L314 , L313 , L304 , L295 , FINSEQ_1:33 , FINSEQ_1:47;
thus L316: thesis by L315 , L265 , L266 , L267 , L294 , L303 , L311 , L290;
end;
L317:
now
assume L318: R18 is  Until;
consider R17 being LTL-formula, R16 being LTL-formula such that L319: R18 = ( R17 'U' R16 ) by L318 , L123;
L320: ( ( len R16 ) + ( 1 + ( len R17 ) ) ) = ( ( ( len R16 ) + 1 ) + ( len R17 ) );
L321: (( len ( <* 4 *> ^ R17 ) ) = ( ( len <* 4 *> ) + ( len R17 ) ) & ( len <* 4 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L322: ( ( len ( <* 4 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) by L319 , FINSEQ_1:22;
L323: ( ( len R16 ) + 1 ) <= ( len R18 ) by L322 , L321 , L320 , NAT_1:11;
L324: ( len R16 ) < ( len R18 ) by L323 , NAT_1:13;
L325: ( ( R14 ^ R21 ) . 1 ) = 4 by L267 , L318 , L197;
L326: ( R14 . 1 ) = 4 by L325 , L269 , FINSEQ_1:def 7;
L327: R14 is  Until by L326 , L214;
consider R15 being LTL-formula, R19 being LTL-formula such that L328: R14 = ( R15 'U' R19 ) by L327 , L123;
L329:
now
L330: ( ( ( ( len R15 ) + 1 ) + ( len R19 ) ) + ( len R21 ) ) = ( ( ( len R15 ) + 1 ) + ( ( len R19 ) + ( len R21 ) ) );
given R22 being FinSequence such that
L331: R15 = ( R17 ^ R22 );

L332: (( len ( R14 ^ R21 ) ) = ( ( len R14 ) + ( len R21 ) ) & ( len <* 4 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L333: (( len ( <* 4 *> ^ R15 ) ) = ( ( len <* 4 *> ) + ( len R15 ) ) & ( len R14 ) = ( ( len ( <* 4 *> ^ R15 ) ) + ( len R19 ) )) by L328 , FINSEQ_1:22;
L334: ( ( len R15 ) + 1 ) <= ( len R18 ) by L333 , L267 , L332 , L330 , NAT_1:11;
L335: ( len R15 ) < ( len R18 ) by L334 , NAT_1:13;
thus L336: R15 = R17 by L335 , L265 , L266 , L331;
end;
L337: (( ( <* 4 *> ^ R15 ) ^ R19 ) = ( <* 4 *> ^ ( R15 ^ R19 ) ) & ( ( <* 4 *> ^ ( R15 ^ R19 ) ) ^ R21 ) = ( <* 4 *> ^ ( ( R15 ^ R19 ) ^ R21 ) )) by FINSEQ_1:32;
L338:
now
given R22 being FinSequence such that
L339: R17 = ( R15 ^ R22 );

L340: ( len <* 4 *> ) = 1 by FINSEQ_1:40;
L341: (( ( len ( <* 4 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) & ( len ( <* 4 *> ^ R17 ) ) = ( ( len <* 4 *> ) + ( len R17 ) )) by L319 , FINSEQ_1:22;
L342: ( ( len R17 ) + 1 ) <= ( len R18 ) by L341 , L340 , NAT_1:11;
L343: ( len R17 ) < ( len R18 ) by L342 , NAT_1:13;
thus L344: R17 = R15 by L343 , L265 , L266 , L339;
end;
L345: ( ( R15 ^ R19 ) ^ R21 ) = ( R15 ^ ( R19 ^ R21 ) ) by FINSEQ_1:32;
L346: ( ( <* 4 *> ^ R17 ) ^ R16 ) = ( <* 4 *> ^ ( R17 ^ R16 ) ) by FINSEQ_1:32;
L347: ( R17 ^ R16 ) = ( R15 ^ ( R19 ^ R21 ) ) by L346 , L267 , L319 , L328 , L337 , L345 , FINSEQ_1:33;
L348: (( len R15 ) <= ( len R17 ) implies (ex R22 being FinSequence st R17 = ( R15 ^ R22 ))) by L347 , FINSEQ_1:47;
L349: R16 = ( R19 ^ R21 ) by L348 , L347 , L338 , L329 , FINSEQ_1:33 , FINSEQ_1:47;
thus L350: thesis by L349 , L265 , L266 , L267 , L328 , L337 , L345 , L324;
end;
L351:
now
assume L352: R18 is  disjunctive;
consider R17 being LTL-formula, R16 being LTL-formula such that L353: R18 = ( R17 'or' R16 ) by L352 , L121;
L354: ( ( len R16 ) + ( 1 + ( len R17 ) ) ) = ( ( ( len R16 ) + 1 ) + ( len R17 ) );
L355: (( len ( <* 2 *> ^ R17 ) ) = ( ( len <* 2 *> ) + ( len R17 ) ) & ( len <* 2 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L356: ( ( len ( <* 2 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) by L353 , FINSEQ_1:22;
L357: ( ( len R16 ) + 1 ) <= ( len R18 ) by L356 , L355 , L354 , NAT_1:11;
L358: ( len R16 ) < ( len R18 ) by L357 , NAT_1:13;
L359: ( ( R14 ^ R21 ) . 1 ) = 2 by L267 , L352 , L188;
L360: ( R14 . 1 ) = 2 by L359 , L269 , FINSEQ_1:def 7;
L361: R14 is  disjunctive by L360 , L214;
consider R15 being LTL-formula, R19 being LTL-formula such that L362: R14 = ( R15 'or' R19 ) by L361 , L121;
L363:
now
L364: ( ( ( ( len R15 ) + 1 ) + ( len R19 ) ) + ( len R21 ) ) = ( ( ( len R15 ) + 1 ) + ( ( len R19 ) + ( len R21 ) ) );
given R22 being FinSequence such that
L365: R15 = ( R17 ^ R22 );

L366: (( len ( R14 ^ R21 ) ) = ( ( len R14 ) + ( len R21 ) ) & ( len <* 2 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L367: (( len ( <* 2 *> ^ R15 ) ) = ( ( len <* 2 *> ) + ( len R15 ) ) & ( len R14 ) = ( ( len ( <* 2 *> ^ R15 ) ) + ( len R19 ) )) by L362 , FINSEQ_1:22;
L368: ( ( len R15 ) + 1 ) <= ( len R18 ) by L367 , L267 , L366 , L364 , NAT_1:11;
L369: ( len R15 ) < ( len R18 ) by L368 , NAT_1:13;
thus L370: R15 = R17 by L369 , L265 , L266 , L365;
end;
L371: (( ( <* 2 *> ^ R15 ) ^ R19 ) = ( <* 2 *> ^ ( R15 ^ R19 ) ) & ( ( <* 2 *> ^ ( R15 ^ R19 ) ) ^ R21 ) = ( <* 2 *> ^ ( ( R15 ^ R19 ) ^ R21 ) )) by FINSEQ_1:32;
L372:
now
given R22 being FinSequence such that
L373: R17 = ( R15 ^ R22 );

L374: ( len <* 2 *> ) = 1 by FINSEQ_1:40;
L375: (( ( len ( <* 2 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) & ( len ( <* 2 *> ^ R17 ) ) = ( ( len <* 2 *> ) + ( len R17 ) )) by L353 , FINSEQ_1:22;
L376: ( ( len R17 ) + 1 ) <= ( len R18 ) by L375 , L374 , NAT_1:11;
L377: ( len R17 ) < ( len R18 ) by L376 , NAT_1:13;
thus L378: R17 = R15 by L377 , L265 , L266 , L373;
end;
L379: ( ( R15 ^ R19 ) ^ R21 ) = ( R15 ^ ( R19 ^ R21 ) ) by FINSEQ_1:32;
L380: ( ( <* 2 *> ^ R17 ) ^ R16 ) = ( <* 2 *> ^ ( R17 ^ R16 ) ) by FINSEQ_1:32;
L381: ( R17 ^ R16 ) = ( R15 ^ ( R19 ^ R21 ) ) by L380 , L267 , L353 , L362 , L371 , L379 , FINSEQ_1:33;
L382: (( len R15 ) <= ( len R17 ) implies (ex R22 being FinSequence st R17 = ( R15 ^ R22 ))) by L381 , FINSEQ_1:47;
L383: R16 = ( R19 ^ R21 ) by L382 , L381 , L372 , L363 , FINSEQ_1:33 , FINSEQ_1:47;
thus L384: thesis by L383 , L265 , L266 , L267 , L362 , L371 , L379 , L358;
end;
L385:
now
assume L386: R18 is  conjunctive;
consider R17 being LTL-formula, R16 being LTL-formula such that L387: R18 = ( R17 '&' R16 ) by L386 , L120;
L388: ( ( len R16 ) + ( 1 + ( len R17 ) ) ) = ( ( ( len R16 ) + 1 ) + ( len R17 ) );
L389: (( len ( <* 1 *> ^ R17 ) ) = ( ( len <* 1 *> ) + ( len R17 ) ) & ( len <* 1 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L390: ( ( len ( <* 1 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) by L387 , FINSEQ_1:22;
L391: ( ( len R16 ) + 1 ) <= ( len R18 ) by L390 , L389 , L388 , NAT_1:11;
L392: ( len R16 ) < ( len R18 ) by L391 , NAT_1:13;
L393: ( ( R14 ^ R21 ) . 1 ) = 1 by L267 , L386 , L183;
L394: ( R14 . 1 ) = 1 by L393 , L269 , FINSEQ_1:def 7;
L395: R14 is  conjunctive by L394 , L214;
consider R15 being LTL-formula, R19 being LTL-formula such that L396: R14 = ( R15 '&' R19 ) by L395 , L120;
L397:
now
L398: ( ( ( ( len R15 ) + 1 ) + ( len R19 ) ) + ( len R21 ) ) = ( ( ( len R15 ) + 1 ) + ( ( len R19 ) + ( len R21 ) ) );
given R22 being FinSequence such that
L399: R15 = ( R17 ^ R22 );

L400: (( len ( R14 ^ R21 ) ) = ( ( len R14 ) + ( len R21 ) ) & ( len <* 1 *> ) = 1) by FINSEQ_1:22 , FINSEQ_1:40;
L401: (( len ( <* 1 *> ^ R15 ) ) = ( ( len <* 1 *> ) + ( len R15 ) ) & ( len R14 ) = ( ( len ( <* 1 *> ^ R15 ) ) + ( len R19 ) )) by L396 , FINSEQ_1:22;
L402: ( ( len R15 ) + 1 ) <= ( len R18 ) by L401 , L267 , L400 , L398 , NAT_1:11;
L403: ( len R15 ) < ( len R18 ) by L402 , NAT_1:13;
thus L404: R15 = R17 by L403 , L265 , L266 , L399;
end;
L405: (( ( <* 1 *> ^ R15 ) ^ R19 ) = ( <* 1 *> ^ ( R15 ^ R19 ) ) & ( ( <* 1 *> ^ ( R15 ^ R19 ) ) ^ R21 ) = ( <* 1 *> ^ ( ( R15 ^ R19 ) ^ R21 ) )) by FINSEQ_1:32;
L406:
now
given R22 being FinSequence such that
L407: R17 = ( R15 ^ R22 );

L408: ( len <* 1 *> ) = 1 by FINSEQ_1:40;
L409: (( ( len ( <* 1 *> ^ R17 ) ) + ( len R16 ) ) = ( len R18 ) & ( len ( <* 1 *> ^ R17 ) ) = ( ( len <* 1 *> ) + ( len R17 ) )) by L387 , FINSEQ_1:22;
L410: ( ( len R17 ) + 1 ) <= ( len R18 ) by L409 , L408 , NAT_1:11;
L411: ( len R17 ) < ( len R18 ) by L410 , NAT_1:13;
thus L412: R17 = R15 by L411 , L265 , L266 , L407;
end;
L413: ( ( R15 ^ R19 ) ^ R21 ) = ( R15 ^ ( R19 ^ R21 ) ) by FINSEQ_1:32;
L414: ( ( <* 1 *> ^ R17 ) ^ R16 ) = ( <* 1 *> ^ ( R17 ^ R16 ) ) by FINSEQ_1:32;
L415: ( R17 ^ R16 ) = ( R15 ^ ( R19 ^ R21 ) ) by L414 , L267 , L387 , L396 , L405 , L413 , FINSEQ_1:33;
L416: (( len R15 ) <= ( len R17 ) implies (ex R22 being FinSequence st R17 = ( R15 ^ R22 ))) by L415 , FINSEQ_1:47;
L417: R16 = ( R19 ^ R21 ) by L416 , L415 , L406 , L397 , FINSEQ_1:33 , FINSEQ_1:47;
thus L418: thesis by L417 , L265 , L266 , L267 , L396 , L405 , L413 , L392;
end;
L419:
now
L420: ( len <* 3 *> ) = 1 by FINSEQ_1:40;
assume L421: R18 is  next;
consider R19 being LTL-formula such that L422: R18 = ( 'X' R19 ) by L421 , L122;
L423: ( ( R14 ^ R21 ) . 1 ) = 3 by L267 , L421 , L193;
L424: ( R14 . 1 ) = 3 by L423 , L269 , FINSEQ_1:def 7;
L425: R14 is  next by L424 , L214;
consider R15 being LTL-formula such that L426: R14 = ( 'X' R15 ) by L425 , L122;
L427: ( ( len <* 3 *> ) + ( len R19 ) ) = ( len R18 ) by L422 , FINSEQ_1:22;
L428: ( len R19 ) < ( len R18 ) by L427 , L420 , NAT_1:13;
L429: ( ( <* 3 *> ^ R15 ) ^ R21 ) = ( <* 3 *> ^ ( R15 ^ R21 ) ) by FINSEQ_1:32;
L430: R19 = ( R15 ^ R21 ) by L429 , L267 , L422 , L426 , FINSEQ_1:33;
thus L431: thesis by L430 , L265 , L266 , L422 , L426 , L428;
end;
L432: ( ( len R14 ) + ( len R21 ) ) = ( len ( R14 ^ R21 ) ) by FINSEQ_1:22;
L433:
now
L434: 1 <= ( len R14 ) by L230;
assume L435: R18 is  atomic;
L436: (ex R1 being Nat st R18 = ( atom. R1 )) by L435 , L118;
L437: ( len R18 ) = 1 by L436 , FINSEQ_1:40;
L438: ( len R14 ) <= 1 by L437 , L267 , L432 , NAT_1:11;
L439: ( 1 + ( len R21 ) ) = ( 1 + ( 0 ) ) by L438 , L267 , L432 , L437 , L434 , XXREAL_0:1;
L440: R21 = ( {} ) by L439;
thus L441: thesis by L440 , L267 , FINSEQ_1:34;
end;
thus L442: thesis by L433 , L270 , L385 , L351 , L419 , L317 , L283 , L126;
end;
L443: (for B7 being Nat holds ((for B8 being Nat holds (B8 < B7 implies S3[ B8 ])) implies S3[ B7 ])) by L264;
L444: (for B9 being Nat holds S3[ B9 ]) from NAT_1:sch 4(L443);
L445: ( len R18 ) = ( len R18 );
thus L446: thesis by L445 , L444;
end;
L447: (for R16 being LTL-formula holds (for R17 being LTL-formula holds (for R18 being LTL-formula holds (for R19 being LTL-formula holds (( R18 '&' R16 ) = ( R19 '&' R17 ) implies (R18 = R19 & R16 = R17))))))
proof
let R16 being LTL-formula;
let R17 being LTL-formula;
let R18 being LTL-formula;
let R19 being LTL-formula;
assume L448: ( R18 '&' R16 ) = ( R19 '&' R17 );
L449: (( ( <* 1 *> ^ R18 ) ^ R16 ) = ( <* 1 *> ^ ( R18 ^ R16 ) ) & ( ( <* 1 *> ^ R19 ) ^ R17 ) = ( <* 1 *> ^ ( R19 ^ R17 ) )) by FINSEQ_1:32;
L450: ( R18 ^ R16 ) = ( R19 ^ R17 ) by L449 , L448 , FINSEQ_1:33;
L451: (( len R19 ) <= ( len R18 ) implies (ex R21 being FinSequence st R18 = ( R19 ^ R21 ))) by L450 , FINSEQ_1:47;
L452: (( len R18 ) <= ( len R19 ) implies (ex R21 being FinSequence st R19 = ( R18 ^ R21 ))) by L450 , FINSEQ_1:47;
thus L453: R18 = R19 by L452 , L451 , L263;
L454: ((ex R21 being FinSequence st R19 = ( R18 ^ R21 )) implies R19 = R18) by L263;
thus L455: thesis by L454 , L448 , L451 , L452 , L263 , FINSEQ_1:33;
end;
L456: (for R16 being LTL-formula holds (for R17 being LTL-formula holds (for R18 being LTL-formula holds (for R19 being LTL-formula holds (( R18 'or' R16 ) = ( R19 'or' R17 ) implies (R18 = R19 & R16 = R17))))))
proof
let R16 being LTL-formula;
let R17 being LTL-formula;
let R18 being LTL-formula;
let R19 being LTL-formula;
assume L457: ( R18 'or' R16 ) = ( R19 'or' R17 );
L458: (( ( <* 2 *> ^ R18 ) ^ R16 ) = ( <* 2 *> ^ ( R18 ^ R16 ) ) & ( ( <* 2 *> ^ R19 ) ^ R17 ) = ( <* 2 *> ^ ( R19 ^ R17 ) )) by FINSEQ_1:32;
L459: ( R18 ^ R16 ) = ( R19 ^ R17 ) by L458 , L457 , FINSEQ_1:33;
L460: (( len R19 ) <= ( len R18 ) implies (ex R21 being FinSequence st R18 = ( R19 ^ R21 ))) by L459 , FINSEQ_1:47;
L461: (( len R18 ) <= ( len R19 ) implies (ex R21 being FinSequence st R19 = ( R18 ^ R21 ))) by L459 , FINSEQ_1:47;
thus L462: R18 = R19 by L461 , L460 , L263;
L463: ((ex R21 being FinSequence st R19 = ( R18 ^ R21 )) implies R19 = R18) by L263;
thus L464: thesis by L463 , L457 , L460 , L461 , L263 , FINSEQ_1:33;
end;
L465: (for R16 being LTL-formula holds (for R17 being LTL-formula holds (for R18 being LTL-formula holds (for R19 being LTL-formula holds (( R18 'U' R16 ) = ( R19 'U' R17 ) implies (R18 = R19 & R16 = R17))))))
proof
let R16 being LTL-formula;
let R17 being LTL-formula;
let R18 being LTL-formula;
let R19 being LTL-formula;
assume L466: ( R18 'U' R16 ) = ( R19 'U' R17 );
L467: (( ( <* 4 *> ^ R18 ) ^ R16 ) = ( <* 4 *> ^ ( R18 ^ R16 ) ) & ( ( <* 4 *> ^ R19 ) ^ R17 ) = ( <* 4 *> ^ ( R19 ^ R17 ) )) by FINSEQ_1:32;
L468: ( R18 ^ R16 ) = ( R19 ^ R17 ) by L467 , L466 , FINSEQ_1:33;
L469: (( len R19 ) <= ( len R18 ) implies (ex R21 being FinSequence st R18 = ( R19 ^ R21 ))) by L468 , FINSEQ_1:47;
L470: (( len R18 ) <= ( len R19 ) implies (ex R21 being FinSequence st R19 = ( R18 ^ R21 ))) by L468 , FINSEQ_1:47;
thus L471: R18 = R19 by L470 , L469 , L263;
L472: ((ex R21 being FinSequence st R19 = ( R18 ^ R21 )) implies R19 = R18) by L263;
thus L473: thesis by L472 , L466 , L469 , L470 , L263 , FINSEQ_1:33;
end;
L474: (for R16 being LTL-formula holds (for R17 being LTL-formula holds (for R18 being LTL-formula holds (for R19 being LTL-formula holds (( R18 'R' R16 ) = ( R19 'R' R17 ) implies (R18 = R19 & R16 = R17))))))
proof
let R16 being LTL-formula;
let R17 being LTL-formula;
let R18 being LTL-formula;
let R19 being LTL-formula;
assume L475: ( R18 'R' R16 ) = ( R19 'R' R17 );
L476: (( ( <* 5 *> ^ R18 ) ^ R16 ) = ( <* 5 *> ^ ( R18 ^ R16 ) ) & ( ( <* 5 *> ^ R19 ) ^ R17 ) = ( <* 5 *> ^ ( R19 ^ R17 ) )) by FINSEQ_1:32;
L477: ( R18 ^ R16 ) = ( R19 ^ R17 ) by L476 , L475 , FINSEQ_1:33;
L478: (( len R19 ) <= ( len R18 ) implies (ex R21 being FinSequence st R18 = ( R19 ^ R21 ))) by L477 , FINSEQ_1:47;
L479: (( len R18 ) <= ( len R19 ) implies (ex R21 being FinSequence st R19 = ( R18 ^ R21 ))) by L477 , FINSEQ_1:47;
thus L480: R18 = R19 by L479 , L478 , L263;
L481: ((ex R21 being FinSequence st R19 = ( R18 ^ R21 )) implies R19 = R18) by L263;
thus L482: thesis by L481 , L475 , L478 , L479 , L263 , FINSEQ_1:33;
end;
L483: (for R18 being LTL-formula holds (R18 is  negative implies ((not R18 is  atomic) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))))
proof
let R18 being LTL-formula;
assume L484: R18 is  negative;
L485: ( R18 . 1 ) = ( 0 ) by L484 , L179;
thus L486: thesis by L485 , L183 , L188 , L193 , L197 , L202 , L207;
end;
L487: (for R18 being LTL-formula holds (R18 is  conjunctive implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))))
proof
let R18 being LTL-formula;
assume L488: R18 is  conjunctive;
L489: ( R18 . 1 ) = 1 by L488 , L183;
thus L490: thesis by L489 , L179 , L188 , L193 , L197 , L202 , L207;
end;
L491: (for R18 being LTL-formula holds (R18 is  disjunctive implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))))
proof
let R18 being LTL-formula;
assume L492: R18 is  disjunctive;
L493: ( R18 . 1 ) = 2 by L492 , L188;
thus L494: thesis by L493 , L179 , L183 , L193 , L197 , L202 , L207;
end;
L495: (for R18 being LTL-formula holds (R18 is  next implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  Until) & (not R18 is  Release))))
proof
let R18 being LTL-formula;
assume L496: R18 is  next;
L497: ( R18 . 1 ) = 3 by L496 , L193;
thus L498: thesis by L497 , L179 , L183 , L188 , L197 , L202 , L207;
end;
L499: (for R18 being LTL-formula holds (R18 is  Until implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Release))))
proof
let R18 being LTL-formula;
assume L500: R18 is  Until;
L501: ( R18 . 1 ) = 4 by L500 , L197;
thus L502: thesis by L501 , L179 , L183 , L188 , L193 , L202 , L207;
end;
L503: (for R18 being LTL-formula holds (R18 is  Release implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until))))
proof
let R18 being LTL-formula;
assume L504: R18 is  Release;
L505: ( R18 . 1 ) = 5 by L504 , L202;
thus L506: thesis by L505 , L179 , L183 , L188 , L193 , L197 , L207;
end;
definition
let R18 being LTL-formula;
assume L507: (R18 is  negative or R18 is  next);
func the_argument_of R18 -> LTL-formula means
:L508: ( 'not' it ) = R18 if R18 is  negative otherwise ( 'X' it ) = R18;
existence by L507 , L119 , L122;
uniqueness by FINSEQ_1:33;
consistency;
end;
definition
let R18 being LTL-formula;
assume L510: (R18 is  conjunctive or R18 is  disjunctive or R18 is  Until or R18 is  Release);
func the_left_argument_of R18 -> LTL-formula means
:L511: (ex R19 being LTL-formula st ( it '&' R19 ) = R18) if R18 is  conjunctive , (ex R19 being LTL-formula st ( it 'or' R19 ) = R18) if R18 is  disjunctive , (ex R19 being LTL-formula st ( it 'U' R19 ) = R18) if R18 is  Until otherwise (ex R19 being LTL-formula st ( it 'R' R19 ) = R18);
existence by L510 , L120 , L121 , L123 , L124;
uniqueness by L447 , L456 , L465 , L474;
consistency by L487 , L491;
func the_right_argument_of R18 -> LTL-formula means
:L512: (ex R19 being LTL-formula st ( R19 '&' it ) = R18) if R18 is  conjunctive , (ex R19 being LTL-formula st ( R19 'or' it ) = R18) if R18 is  disjunctive , (ex R19 being LTL-formula st ( R19 'U' it ) = R18) if R18 is  Until otherwise (ex R19 being LTL-formula st ( R19 'R' it ) = R18);
existence
proof
L513: (R18 is  Until implies (ex R16 being LTL-formula st (ex R19 being LTL-formula st ( R19 'U' R16 ) = R18)))
proof
assume L514: R18 is  Until;
consider R16 being LTL-formula, R14 being LTL-formula such that L515: ( R16 'U' R14 ) = R18 by L514 , L123;
take R14;
thus L516: thesis by L515;
end;
L517: (R18 is  disjunctive implies (ex R16 being LTL-formula st (ex R19 being LTL-formula st ( R19 'or' R16 ) = R18)))
proof
assume L518: R18 is  disjunctive;
consider R16 being LTL-formula, R14 being LTL-formula such that L519: ( R16 'or' R14 ) = R18 by L518 , L121;
take R14;
thus L520: thesis by L519;
end;
L521: (R18 is  conjunctive implies (ex R16 being LTL-formula st (ex R19 being LTL-formula st ( R19 '&' R16 ) = R18)))
proof
assume L522: R18 is  conjunctive;
consider R16 being LTL-formula, R14 being LTL-formula such that L523: ( R16 '&' R14 ) = R18 by L522 , L120;
take R14;
thus L524: thesis by L523;
end;
L525: (((not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  Until)) implies (ex R16 being LTL-formula st (ex R19 being LTL-formula st ( R19 'R' R16 ) = R18)))
proof
assume L526: ((not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  Until));
consider R16 being LTL-formula, R14 being LTL-formula such that L527: ( R16 'R' R14 ) = R18 by L526 , L510 , L124;
take R14;
thus L528: thesis by L527;
end;
thus L529: thesis by L525 , L521 , L517 , L513;
end;
uniqueness by L447 , L456 , L465 , L474;
consistency by L491 , L499;
end;
theorem
L531: (for R18 being LTL-formula holds (R18 is  negative implies R18 = ( 'not' ( the_argument_of R18 ) ))) by L508;
theorem
L532: (for R18 being LTL-formula holds (R18 is  next implies R18 = ( 'X' ( the_argument_of R18 ) )))
proof
let R18 being LTL-formula;
assume L533: R18 is  next;
L534: (not R18 is  negative) by L533 , L495;
thus L535: thesis by L534 , L533 , L508;
end;
theorem
L536: (for R18 being LTL-formula holds (R18 is  conjunctive implies R18 = ( ( the_left_argument_of R18 ) '&' ( the_right_argument_of R18 ) )))
proof
let R18 being LTL-formula;
assume L537: R18 is  conjunctive;
L538: (ex R19 being LTL-formula st R18 = ( R19 '&' ( the_right_argument_of R18 ) )) by L537 , L512;
thus L539: thesis by L538 , L537 , L511;
end;
theorem
L540: (for R18 being LTL-formula holds (R18 is  disjunctive implies R18 = ( ( the_left_argument_of R18 ) 'or' ( the_right_argument_of R18 ) )))
proof
let R18 being LTL-formula;
assume L541: R18 is  disjunctive;
L542: (ex R19 being LTL-formula st R18 = ( R19 'or' ( the_right_argument_of R18 ) )) by L541 , L512;
thus L543: thesis by L542 , L541 , L511;
end;
theorem
L544: (for R18 being LTL-formula holds (R18 is  Until implies R18 = ( ( the_left_argument_of R18 ) 'U' ( the_right_argument_of R18 ) )))
proof
let R18 being LTL-formula;
assume L545: R18 is  Until;
L546: (ex R19 being LTL-formula st R18 = ( R19 'U' ( the_right_argument_of R18 ) )) by L545 , L512;
thus L547: thesis by L546 , L545 , L511;
end;
theorem
L548: (for R18 being LTL-formula holds (R18 is  Release implies R18 = ( ( the_left_argument_of R18 ) 'R' ( the_right_argument_of R18 ) )))
proof
let R18 being LTL-formula;
assume L549: R18 is  Release;
L550: (not R18 is  Until) by L549 , L503;
L551: ((not R18 is  conjunctive) & (not R18 is  disjunctive)) by L549 , L503;
L552: (ex R19 being LTL-formula st R18 = ( R19 'R' ( the_right_argument_of R18 ) )) by L551 , L549 , L550 , L512;
thus L553: thesis by L552 , L549 , L551 , L550 , L511;
end;
theorem
L554: (for R18 being LTL-formula holds ((R18 is  negative or R18 is  next) implies (( len R18 ) = ( 1 + ( len ( the_argument_of R18 ) ) ) & ( len ( the_argument_of R18 ) ) < ( len R18 ))))
proof
let R18 being LTL-formula;
assume L555: (R18 is  negative or R18 is  next);
per cases  by L555;
suppose L556: R18 is  negative;

L557: R18 = ( 'not' ( the_argument_of R18 ) ) by L556 , L508;
L558: ( len R18 ) = ( 1 + ( len ( the_argument_of R18 ) ) ) by L557 , FINSEQ_5:8;
thus L559: thesis by L558 , NAT_1:19;
end;
suppose L560: R18 is  next;

L561: R18 = ( 'X' ( the_argument_of R18 ) ) by L560 , L532;
L562: ( len R18 ) = ( 1 + ( len ( the_argument_of R18 ) ) ) by L561 , FINSEQ_5:8;
thus L563: thesis by L562 , NAT_1:19;
end;
end;
theorem
L565: (for R18 being LTL-formula holds ((R18 is  conjunctive or R18 is  disjunctive or R18 is  Until or R18 is  Release) implies (( len R18 ) = ( ( 1 + ( len ( the_left_argument_of R18 ) ) ) + ( len ( the_right_argument_of R18 ) ) ) & ( len ( the_left_argument_of R18 ) ) < ( len R18 ) & ( len ( the_right_argument_of R18 ) ) < ( len R18 ))))
proof
let R18 being LTL-formula;
set D16 = ( len ( the_left_argument_of R18 ) );
set D17 = ( len ( the_right_argument_of R18 ) );
set D18 = ( D17 + 1 );
assume L566: (R18 is  conjunctive or R18 is  disjunctive or R18 is  Until or R18 is  Release);
per cases  by L566;
suppose L567: R18 is  conjunctive;

L568: R18 = ( ( the_left_argument_of R18 ) '&' ( the_right_argument_of R18 ) ) by L567 , L536;
L569: ( len R18 ) = ( ( 1 + D16 ) + D17 ) by L568 , L12;
L570: 1 <= D18 by NAT_1:11;
L571: D16 < ( D16 + D18 ) by L570 , NAT_1:19;
L572: 1 <= ( 1 + D16 ) by NAT_1:11;
thus L573: thesis by L572 , L569 , L571 , NAT_1:19;
end;
suppose L574: R18 is  disjunctive;

L575: R18 = ( ( the_left_argument_of R18 ) 'or' ( the_right_argument_of R18 ) ) by L574 , L540;
L576: ( len R18 ) = ( ( 1 + D16 ) + D17 ) by L575 , L12;
L577: 1 <= D18 by NAT_1:11;
L578: D16 < ( D16 + D18 ) by L577 , NAT_1:19;
L579: 1 <= ( 1 + D16 ) by NAT_1:11;
thus L580: thesis by L579 , L576 , L578 , NAT_1:19;
end;
suppose L581: R18 is  Until;

L582: R18 = ( ( the_left_argument_of R18 ) 'U' ( the_right_argument_of R18 ) ) by L581 , L544;
L583: ( len R18 ) = ( ( 1 + D16 ) + D17 ) by L582 , L12;
L584: 1 <= D18 by NAT_1:11;
L585: D16 < ( D16 + D18 ) by L584 , NAT_1:19;
L586: 1 <= ( 1 + D16 ) by NAT_1:11;
thus L587: thesis by L586 , L583 , L585 , NAT_1:19;
end;
suppose L588: R18 is  Release;

L589: R18 = ( ( the_left_argument_of R18 ) 'R' ( the_right_argument_of R18 ) ) by L588 , L548;
L590: ( len R18 ) = ( ( 1 + D16 ) + D17 ) by L589 , L12;
L591: 1 <= D18 by NAT_1:11;
L592: D16 < ( D16 + D18 ) by L591 , NAT_1:19;
L593: 1 <= ( 1 + D16 ) by NAT_1:11;
thus L594: thesis by L593 , L590 , L592 , NAT_1:19;
end;
end;
definition
let R18 being LTL-formula;
let R14 being LTL-formula;
pred R18 is_immediate_constituent_of R14
means
:L596: (R14 = ( 'not' R18 ) or R14 = ( 'X' R18 ) or (ex R19 being LTL-formula st (R14 = ( R18 '&' R19 ) or R14 = ( R19 '&' R18 ) or R14 = ( R18 'or' R19 ) or R14 = ( R19 'or' R18 ) or R14 = ( R18 'U' R19 ) or R14 = ( R19 'U' R18 ) or R14 = ( R18 'R' R19 ) or R14 = ( R19 'R' R18 ))))
;end;
theorem
L598: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (( ( 'not' R14 ) . 1 ) = ( 0 ) & ( ( R14 '&' R16 ) . 1 ) = 1 & ( ( R14 'or' R16 ) . 1 ) = 2 & ( ( 'X' R14 ) . 1 ) = 3 & ( ( R14 'U' R16 ) . 1 ) = 4 & ( ( R14 'R' R16 ) . 1 ) = 5)))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
thus L599: ( ( 'not' R14 ) . 1 ) = ( 0 ) by FINSEQ_1:41;
thus L600: ( ( R14 '&' R16 ) . 1 ) = ( ( <* 1 *> ^ ( R14 ^ R16 ) ) . 1 ) by FINSEQ_1:32
.= 1 by FINSEQ_1:41;
thus L601: ( ( R14 'or' R16 ) . 1 ) = ( ( <* 2 *> ^ ( R14 ^ R16 ) ) . 1 ) by FINSEQ_1:32
.= 2 by FINSEQ_1:41;
thus L602: ( ( 'X' R14 ) . 1 ) = 3 by FINSEQ_1:41;
thus L603: ( ( R14 'U' R16 ) . 1 ) = ( ( <* 4 *> ^ ( R14 ^ R16 ) ) . 1 ) by FINSEQ_1:32
.= 4 by FINSEQ_1:41;
thus L604: ( ( R14 'R' R16 ) . 1 ) = ( ( <* 5 *> ^ ( R14 ^ R16 ) ) . 1 ) by FINSEQ_1:32
.= 5 by FINSEQ_1:41;
end;
theorem
L605: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of ( 'not' R14 ) iff R18 = R14)))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
thus L606: (R18 is_immediate_constituent_of ( 'not' R14 ) implies R18 = R14)
proof
L607:
now
given R19 being LTL-formula such that
L608: (( 'not' R14 ) = ( R18 '&' R19 ) or ( 'not' R14 ) = ( R19 '&' R18 ) or ( 'not' R14 ) = ( R18 'or' R19 ) or ( 'not' R14 ) = ( R19 'or' R18 ) or ( 'not' R14 ) = ( R18 'U' R19 ) or ( 'not' R14 ) = ( R19 'U' R18 ) or ( 'not' R14 ) = ( R18 'R' R19 ) or ( 'not' R14 ) = ( R19 'R' R18 ));

L609: ( ( 'not' R14 ) . 1 ) = ( 0 ) by L598;
thus L610: contradiction by L609 , L608 , L598;
end;
L611:
now
assume L612: ( 'not' R14 ) = ( 'X' R18 );
L613: ( ( 'not' R14 ) . 1 ) = ( 0 ) by L598;
thus L614: contradiction by L613 , L612 , L598;
end;
assume L615: R18 is_immediate_constituent_of ( 'not' R14 );
L616: (( 'not' R14 ) = ( 'not' R18 ) or ( 'not' R14 ) = ( 'X' R18 ) or (ex R19 being LTL-formula st (( 'not' R14 ) = ( R18 '&' R19 ) or ( 'not' R14 ) = ( R19 '&' R18 ) or ( 'not' R14 ) = ( R18 'or' R19 ) or ( 'not' R14 ) = ( R19 'or' R18 ) or ( 'not' R14 ) = ( R18 'U' R19 ) or ( 'not' R14 ) = ( R19 'U' R18 ) or ( 'not' R14 ) = ( R18 'R' R19 ) or ( 'not' R14 ) = ( R19 'R' R18 )))) by L615 , L596;
thus L617: thesis by L616 , L611 , L607 , FINSEQ_1:33;
end;

thus L618: thesis by L596;
end;
theorem
L619: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of ( 'X' R14 ) iff R18 = R14)))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
thus L620: (R18 is_immediate_constituent_of ( 'X' R14 ) implies R18 = R14)
proof
L621:
now
given R19 being LTL-formula such that
L622: (( 'X' R14 ) = ( R18 '&' R19 ) or ( 'X' R14 ) = ( R19 '&' R18 ) or ( 'X' R14 ) = ( R18 'or' R19 ) or ( 'X' R14 ) = ( R19 'or' R18 ) or ( 'X' R14 ) = ( R18 'U' R19 ) or ( 'X' R14 ) = ( R19 'U' R18 ) or ( 'X' R14 ) = ( R18 'R' R19 ) or ( 'X' R14 ) = ( R19 'R' R18 ));

L623: ( ( 'X' R14 ) . 1 ) = 3 by L598;
thus L624: contradiction by L623 , L622 , L598;
end;
L625:
now
assume L626: ( 'X' R14 ) = ( 'not' R18 );
L627: ( ( 'X' R14 ) . 1 ) = 3 by L598;
thus L628: contradiction by L627 , L626 , L598;
end;
assume L629: R18 is_immediate_constituent_of ( 'X' R14 );
L630: (( 'X' R14 ) = ( 'not' R18 ) or ( 'X' R14 ) = ( 'X' R18 ) or (ex R19 being LTL-formula st (( 'X' R14 ) = ( R18 '&' R19 ) or ( 'X' R14 ) = ( R19 '&' R18 ) or ( 'X' R14 ) = ( R18 'or' R19 ) or ( 'X' R14 ) = ( R19 'or' R18 ) or ( 'X' R14 ) = ( R18 'U' R19 ) or ( 'X' R14 ) = ( R19 'U' R18 ) or ( 'X' R14 ) = ( R18 'R' R19 ) or ( 'X' R14 ) = ( R19 'R' R18 )))) by L629 , L596;
thus L631: thesis by L630 , L625 , L621 , FINSEQ_1:33;
end;

thus L632: thesis by L596;
end;
theorem
L633: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of ( R14 '&' R16 ) iff (R18 = R14 or R18 = R16)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
thus L634: (R18 is_immediate_constituent_of ( R14 '&' R16 ) implies (R18 = R14 or R18 = R16))
proof
set D19 = ( R14 '&' R16 );
L635:
now
assume L636: (D19 = ( 'not' R18 ) or D19 = ( 'X' R18 ));
L637: ( D19 . 1 ) = 1 by L598;
thus L638: contradiction by L637 , L636 , L598;
end;
L639:
now
given R19 being LTL-formula such that
L640: (D19 = ( R18 'or' R19 ) or D19 = ( R19 'or' R18 ) or D19 = ( R18 'U' R19 ) or D19 = ( R19 'U' R18 ) or D19 = ( R18 'R' R19 ) or D19 = ( R19 'R' R18 ));

L641: ( D19 . 1 ) = 1 by L598;
thus L642: contradiction by L641 , L640 , L598;
end;
assume L643: R18 is_immediate_constituent_of ( R14 '&' R16 );
L644: (D19 = ( 'not' R18 ) or D19 = ( 'X' R18 ) or (ex R19 being LTL-formula st (D19 = ( R18 '&' R19 ) or D19 = ( R19 '&' R18 ) or D19 = ( R18 'or' R19 ) or D19 = ( R19 'or' R18 ) or D19 = ( R18 'U' R19 ) or D19 = ( R19 'U' R18 ) or D19 = ( R18 'R' R19 ) or D19 = ( R19 'R' R18 )))) by L643 , L596;
thus L645: thesis by L644 , L635 , L639 , L447;
end;

thus L646: thesis by L596;
end;
theorem
L647: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of ( R14 'or' R16 ) iff (R18 = R14 or R18 = R16)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
thus L648: (R18 is_immediate_constituent_of ( R14 'or' R16 ) implies (R18 = R14 or R18 = R16))
proof
set D20 = ( R14 'or' R16 );
L649:
now
assume L650: (D20 = ( 'not' R18 ) or D20 = ( 'X' R18 ));
L651: ( D20 . 1 ) = 2 by L598;
thus L652: contradiction by L651 , L650 , L598;
end;
L653:
now
given R19 being LTL-formula such that
L654: (D20 = ( R18 '&' R19 ) or D20 = ( R19 '&' R18 ) or D20 = ( R18 'U' R19 ) or D20 = ( R19 'U' R18 ) or D20 = ( R18 'R' R19 ) or D20 = ( R19 'R' R18 ));

L655: ( D20 . 1 ) = 2 by L598;
thus L656: contradiction by L655 , L654 , L598;
end;
assume L657: R18 is_immediate_constituent_of ( R14 'or' R16 );
L658: (D20 = ( 'not' R18 ) or D20 = ( 'X' R18 ) or (ex R19 being LTL-formula st (D20 = ( R18 '&' R19 ) or D20 = ( R19 '&' R18 ) or D20 = ( R18 'or' R19 ) or D20 = ( R19 'or' R18 ) or D20 = ( R18 'U' R19 ) or D20 = ( R19 'U' R18 ) or D20 = ( R18 'R' R19 ) or D20 = ( R19 'R' R18 )))) by L657 , L596;
thus L659: thesis by L658 , L649 , L653 , L456;
end;

thus L660: thesis by L596;
end;
theorem
L661: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of ( R14 'U' R16 ) iff (R18 = R14 or R18 = R16)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
thus L662: (R18 is_immediate_constituent_of ( R14 'U' R16 ) implies (R18 = R14 or R18 = R16))
proof
set D21 = ( R14 'U' R16 );
L663:
now
assume L664: (D21 = ( 'not' R18 ) or D21 = ( 'X' R18 ));
L665: ( D21 . 1 ) = 4 by L598;
thus L666: contradiction by L665 , L664 , L598;
end;
L667:
now
given R19 being LTL-formula such that
L668: (D21 = ( R18 '&' R19 ) or D21 = ( R19 '&' R18 ) or D21 = ( R18 'or' R19 ) or D21 = ( R19 'or' R18 ) or D21 = ( R18 'R' R19 ) or D21 = ( R19 'R' R18 ));

L669: ( D21 . 1 ) = 4 by L598;
thus L670: contradiction by L669 , L668 , L598;
end;
assume L671: R18 is_immediate_constituent_of ( R14 'U' R16 );
L672: (D21 = ( 'not' R18 ) or D21 = ( 'X' R18 ) or (ex R19 being LTL-formula st (D21 = ( R18 '&' R19 ) or D21 = ( R19 '&' R18 ) or D21 = ( R18 'or' R19 ) or D21 = ( R19 'or' R18 ) or D21 = ( R18 'U' R19 ) or D21 = ( R19 'U' R18 ) or D21 = ( R18 'R' R19 ) or D21 = ( R19 'R' R18 )))) by L671 , L596;
thus L673: thesis by L672 , L663 , L667 , L465;
end;

thus L674: thesis by L596;
end;
theorem
L675: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of ( R14 'R' R16 ) iff (R18 = R14 or R18 = R16)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
thus L676: (R18 is_immediate_constituent_of ( R14 'R' R16 ) implies (R18 = R14 or R18 = R16))
proof
set D22 = ( R14 'R' R16 );
L677:
now
assume L678: (D22 = ( 'not' R18 ) or D22 = ( 'X' R18 ));
L679: ( D22 . 1 ) = 5 by L598;
thus L680: contradiction by L679 , L678 , L598;
end;
L681:
now
given R19 being LTL-formula such that
L682: (D22 = ( R18 '&' R19 ) or D22 = ( R19 '&' R18 ) or D22 = ( R18 'or' R19 ) or D22 = ( R19 'or' R18 ) or D22 = ( R18 'U' R19 ) or D22 = ( R19 'U' R18 ));

L683: ( D22 . 1 ) = 5 by L598;
thus L684: contradiction by L683 , L682 , L598;
end;
assume L685: R18 is_immediate_constituent_of ( R14 'R' R16 );
L686: (D22 = ( 'not' R18 ) or D22 = ( 'X' R18 ) or (ex R19 being LTL-formula st (D22 = ( R18 '&' R19 ) or D22 = ( R19 '&' R18 ) or D22 = ( R18 'or' R19 ) or D22 = ( R19 'or' R18 ) or D22 = ( R18 'U' R19 ) or D22 = ( R19 'U' R18 ) or D22 = ( R18 'R' R19 ) or D22 = ( R19 'R' R18 )))) by L685 , L596;
thus L687: thesis by L686 , L677 , L681 , L474;
end;

thus L688: thesis by L596;
end;
theorem
L689: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  atomic implies (not R18 is_immediate_constituent_of R14))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L690: R14 is  atomic;
L691: ((not ( R14 . 1 ) = 2) & (not ( R14 . 1 ) = 3)) by L690 , L207;
L692: ((not ( R14 . 1 ) = 4) & (not ( R14 . 1 ) = 5)) by L690 , L207;
L693: ((not ( R14 . 1 ) = ( 0 )) & (not ( R14 . 1 ) = 1)) by L690 , L207;
L694:
now
assume L695: R18 is_immediate_constituent_of R14;
L696: (R14 = ( 'not' R18 ) or R14 = ( 'X' R18 ) or (ex R19 being LTL-formula st (R14 = ( R18 '&' R19 ) or R14 = ( R19 '&' R18 ) or R14 = ( R18 'or' R19 ) or R14 = ( R19 'or' R18 ) or R14 = ( R18 'U' R19 ) or R14 = ( R19 'U' R18 ) or R14 = ( R18 'R' R19 ) or R14 = ( R19 'R' R18 )))) by L695 , L596;
thus L697: contradiction by L696 , L693 , L691 , L692 , L598;
end;
thus L698: thesis by L694;
end;
theorem
L699: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  negative implies (R18 is_immediate_constituent_of R14 iff R18 = ( the_argument_of R14 )))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L700: R14 is  negative;
L701: R14 = ( 'not' ( the_argument_of R14 ) ) by L700 , L508;
thus L702: thesis by L701 , L605;
end;
theorem
L703: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  next implies (R18 is_immediate_constituent_of R14 iff R18 = ( the_argument_of R14 )))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L704: R14 is  next;
L705: R14 = ( 'X' ( the_argument_of R14 ) ) by L704 , L532;
thus L706: thesis by L705 , L619;
end;
theorem
L707: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  conjunctive implies (R18 is_immediate_constituent_of R14 iff (R18 = ( the_left_argument_of R14 ) or R18 = ( the_right_argument_of R14 ))))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L708: R14 is  conjunctive;
L709: R14 = ( ( the_left_argument_of R14 ) '&' ( the_right_argument_of R14 ) ) by L708 , L536;
thus L710: thesis by L709 , L633;
end;
theorem
L711: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  disjunctive implies (R18 is_immediate_constituent_of R14 iff (R18 = ( the_left_argument_of R14 ) or R18 = ( the_right_argument_of R14 ))))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L712: R14 is  disjunctive;
L713: R14 = ( ( the_left_argument_of R14 ) 'or' ( the_right_argument_of R14 ) ) by L712 , L540;
thus L714: thesis by L713 , L647;
end;
theorem
L715: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  Until implies (R18 is_immediate_constituent_of R14 iff (R18 = ( the_left_argument_of R14 ) or R18 = ( the_right_argument_of R14 ))))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L716: R14 is  Until;
L717: R14 = ( ( the_left_argument_of R14 ) 'U' ( the_right_argument_of R14 ) ) by L716 , L544;
thus L718: thesis by L717 , L661;
end;
theorem
L719: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is  Release implies (R18 is_immediate_constituent_of R14 iff (R18 = ( the_left_argument_of R14 ) or R18 = ( the_right_argument_of R14 ))))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L720: R14 is  Release;
L721: R14 = ( ( the_left_argument_of R14 ) 'R' ( the_right_argument_of R14 ) ) by L720 , L548;
thus L722: thesis by L721 , L675;
end;
theorem
L723: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of R14 implies (R14 is  negative or R14 is  next or R14 is  conjunctive or R14 is  disjunctive or R14 is  Until or R14 is  Release)))) by L126 , L689;
definition
let R18 being LTL-formula;
let R14 being LTL-formula;
pred R18 is_subformula_of R14
means
:L724: (ex R2 being Nat st (ex R23 being FinSequence st (1 <= R2 & ( len R23 ) = R2 & ( R23 . 1 ) = R18 & ( R23 . R2 ) = R14 & (for R1 being Nat holds ((1 <= R1 & R1 < R2) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R23 . R1 ) = R19 & ( R23 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))))))
;reflexivity
proof
let C7 being LTL-formula;
take 1;
take <* C7 *>;
thus L725: 1 <= 1;
thus L726: ( len <* C7 *> ) = 1 by FINSEQ_1:40;
thus L727: (( <* C7 *> . 1 ) = C7 & ( <* C7 *> . 1 ) = C7) by FINSEQ_1:def 8;
thus L728: thesis;
end;
end;
theorem
L730: (for R18 being LTL-formula holds R18 is_subformula_of R18);
definition
let R18 being LTL-formula;
let R14 being LTL-formula;
pred R18 is_proper_subformula_of R14
means
:L731: (R18 is_subformula_of R14 & R18 <> R14)
;irreflexivity
;
end;
theorem
L733: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of R14 implies ( len R18 ) < ( len R14 ))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L734: R18 is_immediate_constituent_of R14;
per cases  by L734 , L126 , L689;
suppose L735: (R14 is  negative or R14 is  next);

L736: R18 = ( the_argument_of R14 ) by L735 , L734 , L699 , L703;
thus L737: thesis by L736 , L735 , L554;
end;
suppose L738: (R14 is  conjunctive or R14 is  disjunctive or R14 is  Until or R14 is  Release);

L739: (R18 = ( the_left_argument_of R14 ) or R18 = ( the_right_argument_of R14 )) by L738 , L734 , L707 , L711 , L715 , L719;
thus L740: thesis by L739 , L738 , L565;
end;
end;
theorem
L742: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_immediate_constituent_of R14 implies R18 is_proper_subformula_of R14)))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L743: R18 is_immediate_constituent_of R14;
thus L744: R18 is_subformula_of R14
proof
take D23 = 2;
take D24 = <* R18 , R14 *>;
thus L745: 1 <= D23;
thus L746: ( len D24 ) = D23 by FINSEQ_1:44;
thus L747: (( D24 . 1 ) = R18 & ( D24 . D23 ) = R14) by FINSEQ_1:44;
let R1 being Nat;
assume that
L748: 1 <= R1
and
L749: R1 < D23;
take R18;
take R14;
L750: R1 < ( 1 + 1 ) by L749;
L751: R1 <= 1 by L750 , NAT_1:13;
L752: R1 = 1 by L751 , L748 , XXREAL_0:1;
thus L753: (( D24 . R1 ) = R18 & ( D24 . ( R1 + 1 ) ) = R14) by L752 , FINSEQ_1:44;
thus L754: thesis by L743;
end;

assume L755: R18 = R14;
L756: ( len R18 ) = ( len R14 ) by L755;
thus L757: contradiction by L756 , L743 , L733;
end;
theorem
L758: (for R16 being LTL-formula holds ((R16 is  negative or R16 is  next) implies ( the_argument_of R16 ) is_subformula_of R16))
proof
let R16 being LTL-formula;
assume L759: (R16 is  negative or R16 is  next);
L760: ( the_argument_of R16 ) is_immediate_constituent_of R16 by L759 , L699 , L703;
L761: ( the_argument_of R16 ) is_proper_subformula_of R16 by L760 , L742;
thus L762: thesis by L761 , L731;
end;
theorem
L763: (for R16 being LTL-formula holds ((R16 is  conjunctive or R16 is  disjunctive or R16 is  Until or R16 is  Release) implies (( the_left_argument_of R16 ) is_subformula_of R16 & ( the_right_argument_of R16 ) is_subformula_of R16)))
proof
let R16 being LTL-formula;
assume L764: (R16 is  conjunctive or R16 is  disjunctive or R16 is  Until or R16 is  Release);
L765: ( the_right_argument_of R16 ) is_immediate_constituent_of R16 by L764 , L707 , L711 , L715 , L719;
L766: ( the_right_argument_of R16 ) is_proper_subformula_of R16 by L765 , L742;
L767: ( the_left_argument_of R16 ) is_immediate_constituent_of R16 by L764 , L707 , L711 , L715 , L719;
L768: ( the_left_argument_of R16 ) is_proper_subformula_of R16 by L767 , L742;
thus L769: thesis by L768 , L766 , L731;
end;
theorem
L770: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_proper_subformula_of R14 implies ( len R18 ) < ( len R14 ))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L771: R18 is_subformula_of R14;
consider R2 being Nat, R23 being FinSequence such that L772: 1 <= R2 and L773: ( len R23 ) = R2 and L774: ( R23 . 1 ) = R18 and L775: ( R23 . R2 ) = R14 and L776: (for R1 being Nat holds ((1 <= R1 & R1 < R2) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R23 . R1 ) = R19 & ( R23 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))) by L771 , L724;
defpred S4[ Nat ] means ((1 <= $1 & $1 < R2) implies (for R19 being LTL-formula holds (( R23 . ( $1 + 1 ) ) = R19 implies ( len R18 ) < ( len R19 ))));
L777: (for R1 being Nat holds (S4[ R1 ] implies S4[ ( R1 + 1 ) ]))
proof
let R1 being Nat;
assume that
L778: ((1 <= R1 & R1 < R2) implies (for R19 being LTL-formula holds (( R23 . ( R1 + 1 ) ) = R19 implies ( len R18 ) < ( len R19 ))))
and
L779: 1 <= ( R1 + 1 )
and
L780: ( R1 + 1 ) < R2;
consider R15 being LTL-formula, R16 being LTL-formula such that L781: ( R23 . ( R1 + 1 ) ) = R15 and L782: (( R23 . ( ( R1 + 1 ) + 1 ) ) = R16 & R15 is_immediate_constituent_of R16) by L776 , L779 , L780;
let R19 being LTL-formula;
assume that
L783: ( R23 . ( ( R1 + 1 ) + 1 ) ) = R19;
L784:
now
given C8 being Nat such that
L785: R1 = ( C8 + 1 );

L786: ( len R18 ) < ( len R15 ) by L778 , L780 , L781 , L785 , NAT_1:11 , NAT_1:13;
thus L787: thesis by L786 , L783 , L782 , L733 , XXREAL_0:2;
end;
L788: (R1 = ( 0 ) implies ( len R18 ) < ( len R19 )) by L774 , L783 , L781 , L782 , L733;
thus L789: thesis by L788 , L784 , NAT_1:6;
end;
assume L790: R18 <> R14;
L791: 1 < R2 by L790 , L772 , L774 , L775 , XXREAL_0:1;
L792: ( 1 + 1 ) <= R2 by L791 , NAT_1:13;
consider C9 being Nat such that L793: R2 = ( 2 + C9 ) by L792 , NAT_1:10;
L794: S4[ ( 0 ) ];
L795: (for R1 being Nat holds S4[ R1 ]) from NAT_1:sch 2(L794 , L777);
L796: ( ( 1 + 1 ) + C9 ) = ( ( 1 + C9 ) + 1 );
L797: ( 1 + C9 ) < R2 by L796 , L793 , NAT_1:13;
thus L798: thesis by L797 , L775 , L795 , L793 , L796 , NAT_1:11;
end;
theorem
L799: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R18 is_proper_subformula_of R14 implies (ex R16 being LTL-formula st R16 is_immediate_constituent_of R14))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L800: R18 is_subformula_of R14;
consider R2 being Nat, R23 being FinSequence such that L801: 1 <= R2 and L802: ( len R23 ) = R2 and L803: ( R23 . 1 ) = R18 and L804: ( R23 . R2 ) = R14 and L805: (for R1 being Nat holds ((1 <= R1 & R1 < R2) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R23 . R1 ) = R19 & ( R23 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))) by L800 , L724;
assume L806: R18 <> R14;
L807: 1 < R2 by L806 , L801 , L803 , L804 , XXREAL_0:1;
L808: ( 1 + 1 ) <= R2 by L807 , NAT_1:13;
consider C10 being Nat such that L809: R2 = ( 2 + C10 ) by L808 , NAT_1:10;
L810: ( ( 1 + 1 ) + C10 ) = ( ( 1 + C10 ) + 1 );
L811: ( 1 + C10 ) < R2 by L810 , L809 , NAT_1:13;
consider R19 being LTL-formula, R15 being LTL-formula such that L812: ( R23 . ( 1 + C10 ) ) = R19 and L813: (( R23 . ( ( 1 + C10 ) + 1 ) ) = R15 & R19 is_immediate_constituent_of R15) by L811 , L805 , NAT_1:11;
take R19;
thus L814: thesis by L804 , L809 , L813;
end;
theorem
L815: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds ((R14 is_proper_subformula_of R16 & R16 is_proper_subformula_of R18) implies R14 is_proper_subformula_of R18))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
assume that
L816: R14 is_subformula_of R16
and
L817: R14 <> R16
and
L818: R16 is_subformula_of R18
and
L819: R16 <> R18;
consider R3 being Nat, R24 being FinSequence such that L820: 1 <= R3 and L821: ( len R24 ) = R3 and L822: ( R24 . 1 ) = R16 and L823: ( R24 . R3 ) = R18 and L824: (for R1 being Nat holds ((1 <= R1 & R1 < R3) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R24 . R1 ) = R19 & ( R24 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))) by L818 , L724;
consider R2 being Nat, R23 being FinSequence such that L825: 1 <= R2 and L826: ( len R23 ) = R2 and L827: ( R23 . 1 ) = R14 and L828: ( R23 . R2 ) = R16 and L829: (for R1 being Nat holds ((1 <= R1 & R1 < R2) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R23 . R1 ) = R19 & ( R23 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))) by L816 , L724;
L830: 1 < R2 by L817 , L825 , L827 , L828 , XXREAL_0:1;
L831: ( 1 + 1 ) <= R2 by L830 , NAT_1:13;
consider C11 being Nat such that L832: R2 = ( 2 + C11 ) by L831 , NAT_1:10;
reconsider D25 = ( R23 | ( Seg ( 1 + C11 ) ) ) as FinSequence by FINSEQ_1:15;
thus L833: R14 is_subformula_of R18
proof
take D26 = ( ( 1 + C11 ) + R3 );
take D27 = ( D25 ^ R24 );
L834: ( ( ( 1 + C11 ) + R3 ) - ( 1 + C11 ) ) = R3;
L835: R3 <= ( R3 + ( 1 + C11 ) ) by NAT_1:11;
thus L836: 1 <= D26 by L835 , L820 , XXREAL_0:2;
L837: ( ( 1 + 1 ) + C11 ) = ( ( 1 + C11 ) + 1 );
L838: ( 1 + C11 ) <= R2 by L837 , L832 , NAT_1:11;
L839: ( len D25 ) = ( 1 + C11 ) by L838 , L826 , FINSEQ_1:17;
thus L840: ( len D27 ) = D26 by L839 , L821 , FINSEQ_1:22;
L841:
now
let R25 being Nat;
assume L842: (1 <= R25 & R25 <= ( 1 + C11 ));
L843: R25 in ( Seg ( 1 + C11 ) ) by L842 , FINSEQ_1:1;
L844: R25 in ( dom D25 ) by L843 , L826 , L838 , FINSEQ_1:17;
L845: ( D27 . R25 ) = ( D25 . R25 ) by L844 , FINSEQ_1:def 7;
thus L846: ( D27 . R25 ) = ( R23 . R25 ) by L845 , L843 , FUNCT_1:49;
end;
L847: 1 <= ( 1 + C11 ) by NAT_1:11;
thus L848: ( D27 . 1 ) = R14 by L847 , L827 , L841;
L849: ( ( len D25 ) + 1 ) <= ( ( len D25 ) + R3 ) by L820 , XREAL_1:7;
L850: ( len D25 ) < D26 by L849 , L839 , NAT_1:13;
L851: ( D27 . D26 ) = ( R24 . ( D26 - ( len D25 ) ) ) by L850 , L840 , FINSEQ_1:24;
thus L852: ( D27 . D26 ) = R18 by L851 , L826 , L823 , L838 , L834 , FINSEQ_1:17;
let R25 being Nat;
assume that
L853: 1 <= R25
and
L854: R25 < D26;
L855: ( R25 + ( 0 ) ) <= ( R25 + 1 ) by XREAL_1:7;
L856: 1 <= ( R25 + 1 ) by L855 , L853 , XXREAL_0:2;
L857:
now
assume L858: R25 < ( 1 + C11 );
L859: ( R25 + 1 ) <= ( 1 + C11 ) by L858 , NAT_1:13;
L860: ( R25 + 1 ) <= R2 by L859 , L838 , XXREAL_0:2;
L861: R25 < R2 by L860 , NAT_1:13;
consider R15 being LTL-formula, R17 being LTL-formula such that L862: (( R23 . R25 ) = R15 & ( R23 . ( R25 + 1 ) ) = R17 & R15 is_immediate_constituent_of R17) by L861 , L829 , L853;
take D28 = R15;
take D29 = R17;
thus L863: (( D27 . R25 ) = D28 & ( D27 . ( R25 + 1 ) ) = D29 & D28 is_immediate_constituent_of D29) by L841 , L853 , L856 , L858 , L859 , L862;
end;
L864:
now
L865: ( R25 + 1 ) <= D26 by L854 , NAT_1:13;
assume L866: ( 1 + C11 ) < R25;
L867: ( 1 + C11 ) < ( R25 + 1 ) by L866 , NAT_1:13;
L868: ( ( 1 + C11 ) + 1 ) <= R25 by L866 , NAT_1:13;
consider C12 being Nat such that L869: R25 = ( ( ( 1 + C11 ) + 1 ) + C12 ) by L868 , NAT_1:10;
L870: ( R25 - ( 1 + C11 ) ) < ( D26 - ( 1 + C11 ) ) by L854 , XREAL_1:9;
consider R15 being LTL-formula, R17 being LTL-formula such that L871: (( R24 . ( 1 + C12 ) ) = R15 & ( R24 . ( ( 1 + C12 ) + 1 ) ) = R17 & R15 is_immediate_constituent_of R17) by L870 , L824 , L869 , NAT_1:11;
take D30 = R15;
take D31 = R17;
L872: ( ( ( 1 + C12 ) + ( 1 + C11 ) ) - ( 1 + C11 ) ) = ( ( ( 1 + C12 ) + ( 1 + C11 ) ) + ( - ( 1 + C11 ) ) );
L873: ( ( R25 + 1 ) - ( len D25 ) ) = ( 1 + ( R25 + ( - ( len D25 ) ) ) )
.= ( ( 1 + C12 ) + 1 ) by L826 , L838 , L869 , L872 , FINSEQ_1:17;
thus L874: (( D27 . R25 ) = D30 & ( D27 . ( R25 + 1 ) ) = D31 & D30 is_immediate_constituent_of D31) by L873 , L839 , L840 , L854 , L866 , L867 , L865 , L872 , L871 , FINSEQ_1:24;
end;
L875:
now
L876: (( R25 + 1 ) <= D26 & ( ( R25 + 1 ) - R25 ) = ( ( R25 + 1 ) + ( - R25 ) )) by L854 , NAT_1:13;
assume L877: R25 = ( 1 + C11 );
L878: R25 < ( ( 1 + C11 ) + 1 ) by L877 , NAT_1:13;
consider R15 being LTL-formula, R17 being LTL-formula such that L879: (( R23 . R25 ) = R15 & ( R23 . ( R25 + 1 ) ) = R17 & R15 is_immediate_constituent_of R17) by L878 , L829 , L832 , L853;
take D32 = R15;
take D33 = R17;
L880: ( 1 + C11 ) < ( R25 + 1 ) by L877 , NAT_1:13;
thus L881: (( D27 . R25 ) = D32 & ( D27 . ( R25 + 1 ) ) = D33 & D32 is_immediate_constituent_of D33) by L880 , L828 , L822 , L832 , L839 , L840 , L841 , L853 , L877 , L876 , L879 , FINSEQ_1:24;
end;
thus L882: thesis by L875 , L857 , L864 , XXREAL_0:1;
end;

assume L883: R14 = R18;
L884: R14 is_proper_subformula_of R16 by L816 , L817 , L731;
L885: ( len R14 ) < ( len R16 ) by L884 , L770;
L886: R16 is_proper_subformula_of R18 by L818 , L819 , L731;
thus L887: contradiction by L886 , L883 , L885 , L770;
end;
theorem
L888: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds ((R14 is_subformula_of R16 & R16 is_subformula_of R18) implies R14 is_subformula_of R18))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
assume that
L889: R14 is_subformula_of R16
and
L890: R16 is_subformula_of R18;
L891:
now
assume L892: R14 <> R16;
L893: R14 is_proper_subformula_of R16 by L892 , L889 , L731;
L894:
now
assume L895: R16 <> R18;
L896: R16 is_proper_subformula_of R18 by L895 , L890 , L731;
L897: R14 is_proper_subformula_of R18 by L896 , L893 , L815;
thus L898: thesis by L897 , L731;
end;
thus L899: thesis by L894 , L889;
end;
thus L900: thesis by L891 , L890;
end;
theorem
L901: (for R16 being LTL-formula holds (for R18 being LTL-formula holds ((R16 is_subformula_of R18 & R18 is_subformula_of R16) implies R16 = R18)))
proof
let R16 being LTL-formula;
let R18 being LTL-formula;
assume that
L902: R16 is_subformula_of R18
and
L903: R18 is_subformula_of R16;
assume L904: R16 <> R18;
L905: R16 is_proper_subformula_of R18 by L904 , L902 , L731;
L906: ( len R16 ) < ( len R18 ) by L905 , L770;
L907: R18 is_proper_subformula_of R16 by L903 , L904 , L731;
thus L908: contradiction by L907 , L906 , L770;
end;
theorem
L909: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (((R16 is  negative or R16 is  next) & R14 is_proper_subformula_of R16) implies R14 is_subformula_of ( the_argument_of R16 ))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
assume that
L910: (R16 is  negative or R16 is  next)
and
L911: R14 is_subformula_of R16
and
L912: R14 <> R16;
consider R2 being Nat, R23 being FinSequence such that L913: 1 <= R2 and L914: ( len R23 ) = R2 and L915: ( R23 . 1 ) = R14 and L916: ( R23 . R2 ) = R16 and L917: (for R1 being Nat holds ((1 <= R1 & R1 < R2) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R23 . R1 ) = R19 & ( R23 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))) by L911 , L724;
L918: 1 < R2 by L912 , L913 , L915 , L916 , XXREAL_0:1;
L919: ( 1 + 1 ) <= R2 by L918 , NAT_1:13;
consider C13 being Nat such that L920: R2 = ( 2 + C13 ) by L919 , NAT_1:10;
reconsider D34 = ( R23 | ( Seg ( 1 + C13 ) ) ) as FinSequence by FINSEQ_1:15;
take D35 = ( 1 + C13 );
take D34;
thus L921: 1 <= D35 by NAT_1:11;
L922: ( 1 + C13 ) <= ( ( 1 + C13 ) + 1 ) by NAT_1:11;
thus L923: ( len D34 ) = D35 by L922 , L914 , L920 , FINSEQ_1:17;
L924:
now
let R25 being Nat;
L925: R25 is (Element of ( NAT )) by ORDINAL1:def 12;
assume L926: (1 <= R25 & R25 <= D35);
L927: R25 in { R26 where R26 is (Element of ( NAT )) : (1 <= R26 & R26 <= ( 1 + C13 )) } by L926 , L925;
L928: R25 in ( Seg ( 1 + C13 ) ) by L927 , FINSEQ_1:def 1;
thus L929: ( D34 . R25 ) = ( R23 . R25 ) by L928 , FUNCT_1:49;
end;
thus L930: ( D34 . 1 ) = R14 by L924 , L915 , L921;
L931: D35 < ( D35 + 1 ) by NAT_1:13;
consider R15 being LTL-formula, R17 being LTL-formula such that L932: ( R23 . D35 ) = R15 and L933: (( R23 . ( D35 + 1 ) ) = R17 & R15 is_immediate_constituent_of R17) by L931 , L917 , L920 , NAT_1:11;
L934: R15 = ( the_argument_of R16 ) by L910 , L916 , L920 , L933 , L699 , L703;
thus L935: ( D34 . D35 ) = ( the_argument_of R16 ) by L934 , L921 , L924 , L932;
let R25 being Nat;
assume that
L936: 1 <= R25
and
L937: R25 < D35;
L938: D35 <= ( D35 + 1 ) by NAT_1:11;
L939: R25 < R2 by L938 , L920 , L937 , XXREAL_0:2;
consider R15 being LTL-formula, R17 being LTL-formula such that L940: (( R23 . R25 ) = R15 & ( R23 . ( R25 + 1 ) ) = R17 & R15 is_immediate_constituent_of R17) by L939 , L917 , L936;
take R15;
take R17;
L941: (1 <= ( 1 + R25 ) & ( R25 + 1 ) <= D35) by L936 , L937 , NAT_1:13;
thus L942: thesis by L941 , L924 , L936 , L937 , L940;
end;
theorem
L943: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (((R16 is  conjunctive or R16 is  disjunctive or R16 is  Until or R16 is  Release) & R14 is_proper_subformula_of R16) implies (R14 is_subformula_of ( the_left_argument_of R16 ) or R14 is_subformula_of ( the_right_argument_of R16 )))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
assume that
L944: (R16 is  conjunctive or R16 is  disjunctive or R16 is  Until or R16 is  Release)
and
L945: R14 is_subformula_of R16
and
L946: R14 <> R16;
consider R2 being Nat, R23 being FinSequence such that L947: 1 <= R2 and L948: ( len R23 ) = R2 and L949: ( R23 . 1 ) = R14 and L950: ( R23 . R2 ) = R16 and L951: (for R1 being Nat holds ((1 <= R1 & R1 < R2) implies (ex R19 being LTL-formula st (ex R15 being LTL-formula st (( R23 . R1 ) = R19 & ( R23 . ( R1 + 1 ) ) = R15 & R19 is_immediate_constituent_of R15))))) by L945 , L724;
L952: 1 < R2 by L946 , L947 , L949 , L950 , XXREAL_0:1;
L953: ( 1 + 1 ) <= R2 by L952 , NAT_1:13;
consider C14 being Nat such that L954: R2 = ( 2 + C14 ) by L953 , NAT_1:10;
reconsider D36 = ( R23 | ( Seg ( 1 + C14 ) ) ) as FinSequence by FINSEQ_1:15;
L955: ( ( 1 + 1 ) + C14 ) = ( ( 1 + C14 ) + 1 );
L956: ( 1 + C14 ) < R2 by L955 , L954 , NAT_1:13;
consider R19 being LTL-formula, R17 being LTL-formula such that L957: ( R23 . ( 1 + C14 ) ) = R19 and L958: (( R23 . ( ( 1 + C14 ) + 1 ) ) = R17 & R19 is_immediate_constituent_of R17) by L956 , L951 , NAT_1:11;
L959: R14 is_subformula_of R19
proof
take D37 = ( 1 + C14 );
take D36;
thus L960: 1 <= D37 by NAT_1:11;
L961: ( 1 + C14 ) <= ( ( 1 + C14 ) + 1 ) by NAT_1:11;
thus L962: ( len D36 ) = D37 by L961 , L948 , L954 , FINSEQ_1:17;
L963:
now
let R25 being Nat;
L964: R25 is (Element of ( NAT )) by ORDINAL1:def 12;
assume L965: (1 <= R25 & R25 <= D37);
L966: R25 in { R26 where R26 is (Element of ( NAT )) : (1 <= R26 & R26 <= ( 1 + C14 )) } by L965 , L964;
L967: R25 in ( Seg ( 1 + C14 ) ) by L966 , FINSEQ_1:def 1;
thus L968: ( D36 . R25 ) = ( R23 . R25 ) by L967 , FUNCT_1:49;
end;
thus L969: ( D36 . 1 ) = R14 by L963 , L949 , L960;
thus L970: ( D36 . D37 ) = R19 by L957 , L960 , L963;
let R25 being Nat;
assume that
L971: 1 <= R25
and
L972: R25 < D37;
L973: D37 <= ( D37 + 1 ) by NAT_1:11;
L974: R25 < R2 by L973 , L954 , L972 , XXREAL_0:2;
consider R15 being LTL-formula, R17 being LTL-formula such that L975: (( R23 . R25 ) = R15 & ( R23 . ( R25 + 1 ) ) = R17 & R15 is_immediate_constituent_of R17) by L974 , L951 , L971;
take R15;
take R17;
L976: (1 <= ( 1 + R25 ) & ( R25 + 1 ) <= D37) by L971 , L972 , NAT_1:13;
thus L977: thesis by L976 , L963 , L971 , L972 , L975;
end;
thus L978: thesis by L959 , L944 , L950 , L954 , L958 , L707 , L711 , L715 , L719;
end;
theorem
L979: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_proper_subformula_of ( 'not' R18 ) implies R14 is_subformula_of R18)))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L980: R14 is_proper_subformula_of ( 'not' R18 );
L981: ( 'not' R18 ) is  negative by L119;
L982: ( the_argument_of ( 'not' R18 ) ) = R18 by L981 , L508;
thus L983: thesis by L982 , L980 , L981 , L909;
end;
theorem
L984: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_proper_subformula_of ( 'X' R18 ) implies R14 is_subformula_of R18)))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L985: R14 is_proper_subformula_of ( 'X' R18 );
L986: ( 'X' R18 ) is  next by L122;
L987: (not ( 'X' R18 ) is  negative) by L986 , L495;
L988: ( the_argument_of ( 'X' R18 ) ) = R18 by L987 , L986 , L508;
thus L989: thesis by L988 , L985 , L986 , L909;
end;
theorem
L990: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_proper_subformula_of ( R16 '&' R18 ) implies (R14 is_subformula_of R16 or R14 is_subformula_of R18)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
assume L991: R14 is_proper_subformula_of ( R16 '&' R18 );
L992: ( R16 '&' R18 ) is  conjunctive by L120;
L993: (( the_left_argument_of ( R16 '&' R18 ) ) = R16 & ( the_right_argument_of ( R16 '&' R18 ) ) = R18) by L992 , L511 , L512;
thus L994: thesis by L993 , L991 , L992 , L943;
end;
theorem
L995: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_proper_subformula_of ( R16 'or' R18 ) implies (R14 is_subformula_of R16 or R14 is_subformula_of R18)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
assume L996: R14 is_proper_subformula_of ( R16 'or' R18 );
L997: ( R16 'or' R18 ) is  disjunctive by L121;
L998: (( the_left_argument_of ( R16 'or' R18 ) ) = R16 & ( the_right_argument_of ( R16 'or' R18 ) ) = R18) by L997 , L511 , L512;
thus L999: thesis by L998 , L996 , L997 , L943;
end;
theorem
L1000: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_proper_subformula_of ( R16 'U' R18 ) implies (R14 is_subformula_of R16 or R14 is_subformula_of R18)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
assume L1001: R14 is_proper_subformula_of ( R16 'U' R18 );
L1002: ( R16 'U' R18 ) is  Until by L123;
L1003: (( the_left_argument_of ( R16 'U' R18 ) ) = R16 & ( the_right_argument_of ( R16 'U' R18 ) ) = R18) by L1002 , L511 , L512;
thus L1004: thesis by L1003 , L1001 , L1002 , L943;
end;
theorem
L1005: (for R14 being LTL-formula holds (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_proper_subformula_of ( R16 'R' R18 ) implies (R14 is_subformula_of R16 or R14 is_subformula_of R18)))))
proof
let R14 being LTL-formula;
let R16 being LTL-formula;
let R18 being LTL-formula;
assume L1006: R14 is_proper_subformula_of ( R16 'R' R18 );
set D38 = ( R16 'R' R18 );
L1007: D38 is  Release by L124;
L1008: (not D38 is  Until) by L1007 , L503;
L1009: ((not D38 is  conjunctive) & (not D38 is  disjunctive)) by L1007 , L503;
L1010: (( the_left_argument_of D38 ) = R16 & ( the_right_argument_of D38 ) = R18) by L1009 , L1007 , L1008 , L511 , L512;
thus L1011: thesis by L1010 , L1006 , L1007 , L943;
end;
definition
let R18 being LTL-formula;
func Subformulae R18 -> set means
:L1012: (for R4 being set holds (R4 in it iff (ex R14 being LTL-formula st (R14 = R4 & R14 is_subformula_of R18))));
existence
proof
defpred S5[ set ] means (ex R14 being LTL-formula st (R14 = $1 & R14 is_subformula_of R18));
consider R6 being set such that L1013: (for R4 being set holds (R4 in R6 iff (R4 in ( ( NAT ) * ) & S5[ R4 ]))) from XBOOLE_0:sch 1;
take R6;
let R4 being set;
thus L1014: (R4 in R6 implies (ex R14 being LTL-formula st (R14 = R4 & R14 is_subformula_of R18))) by L1013;
given R14 being LTL-formula such that
L1015: (R14 = R4 & R14 is_subformula_of R18);

L1016: R14 in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L1017: thesis by L1016 , L1013 , L1015;
end;
uniqueness
proof
let R6 being set;
let R7 being set;
assume that
L1018: (for R4 being set holds (R4 in R6 iff (ex R14 being LTL-formula st (R14 = R4 & R14 is_subformula_of R18))))
and
L1019: (for R4 being set holds (R4 in R7 iff (ex R14 being LTL-formula st (R14 = R4 & R14 is_subformula_of R18))));
L1020:
now
let R4 being set;
thus L1021: (R4 in R6 implies R4 in R7)
proof
assume L1022: R4 in R6;
L1023: (ex R14 being LTL-formula st (R14 = R4 & R14 is_subformula_of R18)) by L1022 , L1018;
thus L1024: thesis by L1023 , L1019;
end;

assume L1025: R4 in R7;
L1026: (ex R14 being LTL-formula st (R14 = R4 & R14 is_subformula_of R18)) by L1025 , L1019;
thus L1027: R4 in R6 by L1026 , L1018;
end;
thus L1028: thesis by L1020 , TARSKI:1;
end;
end;
theorem
L1030: (for R16 being LTL-formula holds (for R18 being LTL-formula holds (R16 in ( Subformulae R18 ) iff R16 is_subformula_of R18)))
proof
let R16 being LTL-formula;
let R18 being LTL-formula;
L1031: (R16 in ( Subformulae R18 ) implies R16 is_subformula_of R18)
proof
assume L1032: R16 in ( Subformulae R18 );
L1033: (ex R14 being LTL-formula st (R14 = R16 & R14 is_subformula_of R18)) by L1032 , L1012;
thus L1034: thesis by L1033;
end;
thus L1035: thesis by L1031 , L1012;
end;
registration
let R18 being LTL-formula;
cluster ( Subformulae R18 ) -> non  empty;
coherence by L1030;
end;
theorem
L1037: (for R14 being LTL-formula holds (for R18 being LTL-formula holds (R14 is_subformula_of R18 implies ( Subformulae R14 ) c= ( Subformulae R18 ))))
proof
let R14 being LTL-formula;
let R18 being LTL-formula;
assume L1038: R14 is_subformula_of R18;
let R4 being set;
assume L1039: R4 in ( Subformulae R14 );
consider R15 being LTL-formula such that L1040: R15 = R4 and L1041: R15 is_subformula_of R14 by L1039 , L1012;
L1042: R15 is_subformula_of R18 by L1038 , L1041 , L888;
thus L1043: thesis by L1042 , L1040 , L1012;
end;
theorem
L1044: (for R4 being set holds (for R18 being LTL-formula holds (R4 is (Subset of ( Subformulae R18 )) implies R4 is (Subset of ( LTL_WFF )))))
proof
let R4 being set;
let R18 being LTL-formula;
assume L1045: R4 is (Subset of ( Subformulae R18 ));
L1046: (for R5 being set holds (R5 in R4 implies R5 in ( LTL_WFF )))
proof
let R5 being set;
assume L1047: R5 in R4;
L1048: (ex R14 being LTL-formula st (R14 = R5 & R14 is_subformula_of R18)) by L1047 , L1045 , L1012;
thus L1049: thesis by L1048 , L89;
end;
thus L1050: thesis by L1046 , TARSKI:def 3;
end;
scheme LTLInd { P1[LTL-formula] } : (for R18 being LTL-formula holds P1[ R18 ])
provided
L1051: (for R18 being LTL-formula holds (R18 is  atomic implies P1[ R18 ]))
and
L1052: (for R18 being LTL-formula holds (((R18 is  negative or R18 is  next) & P1[ ( the_argument_of R18 ) ]) implies P1[ R18 ]))
and
L1053: (for R18 being LTL-formula holds (((R18 is  conjunctive or R18 is  disjunctive or R18 is  Until or R18 is  Release) & P1[ ( the_left_argument_of R18 ) ] & P1[ ( the_right_argument_of R18 ) ]) implies P1[ R18 ]))
proof
defpred S6[ Nat ] means (for R18 being LTL-formula holds (( len R18 ) = $1 implies P1[ R18 ]));
L1054: (for B10 being Nat holds ((for B11 being Nat holds (B11 < B10 implies S6[ B11 ])) implies S6[ B10 ]))
proof
let C15 being Nat;
assume that
L1055: (for B12 being Nat holds (B12 < C15 implies (for R18 being LTL-formula holds (( len R18 ) = B12 implies P1[ R18 ]))));
let R18 being LTL-formula;
assume that
L1056: ( len R18 ) = C15;
L1057:
now
assume L1058: (R18 is  conjunctive or R18 is  disjunctive or R18 is  Until or R18 is  Release);
L1059: ( len ( the_right_argument_of R18 ) ) < ( len R18 ) by L1058 , L565;
L1060: P1[ ( the_right_argument_of R18 ) ] by L1059 , L1055 , L1056;
L1061: ( len ( the_left_argument_of R18 ) ) < ( len R18 ) by L1058 , L565;
L1062: P1[ ( the_left_argument_of R18 ) ] by L1061 , L1055 , L1056;
thus L1063: thesis by L1062 , L1053 , L1058 , L1060;
end;
L1064:
now
assume L1065: (R18 is  negative or R18 is  next);
L1066: ( len ( the_argument_of R18 ) ) < ( len R18 ) by L1065 , L554;
L1067: P1[ ( the_argument_of R18 ) ] by L1066 , L1055 , L1056;
thus L1068: thesis by L1067 , L1052 , L1065;
end;
thus L1069: thesis by L1064 , L1051 , L1057 , L126;
end;
L1070: (for B13 being Nat holds S6[ B13 ]) from NAT_1:sch 4(L1054);
let R18 being LTL-formula;
L1071: ( len R18 ) = ( len R18 );
thus L1072: thesis by L1071 , L1070;
end;
scheme LTLCompInd { P2[LTL-formula] } : (for R18 being LTL-formula holds P2[ R18 ])
provided
L1073: (for R18 being LTL-formula holds ((for R14 being LTL-formula holds (R14 is_proper_subformula_of R18 implies P2[ R14 ])) implies P2[ R18 ]))
proof
defpred S7[ Nat ] means (for R18 being LTL-formula holds (( len R18 ) = $1 implies P2[ R18 ]));
L1074: (for B14 being Nat holds ((for B15 being Nat holds (B15 < B14 implies S7[ B15 ])) implies S7[ B14 ]))
proof
let C16 being Nat;
assume that
L1075: (for B16 being Nat holds (B16 < C16 implies (for R18 being LTL-formula holds (( len R18 ) = B16 implies P2[ R18 ]))));
let R18 being LTL-formula;
assume that
L1076: ( len R18 ) = C16;
L1077:
now
let R14 being LTL-formula;
assume L1078: R14 is_proper_subformula_of R18;
L1079: ( len R14 ) < ( len R18 ) by L1078 , L770;
thus L1080: P2[ R14 ] by L1079 , L1075 , L1076;
end;
thus L1081: thesis by L1077 , L1073;
end;
L1082: (for B17 being Nat holds S7[ B17 ]) from NAT_1:sch 4(L1074);
let R18 being LTL-formula;
L1083: ( len R18 ) = ( len R18 );
thus L1084: thesis by L1083 , L1082;
end;
definition
let C17 being set;
func CastLTL C17 -> LTL-formula equals
:L1085: C17 if C17 in ( LTL_WFF ) otherwise ( atom. ( 0 ) );
correctness by L89;
end;
definition
struct (OrthoLattStr) LTLModelStr(# carrier -> set , BasicAssign -> (Subset of the carrier) , L_meet -> (BinOp of the carrier) , L_join -> (BinOp of the carrier) , Compl -> (UnOp of the carrier) , NEXT -> (UnOp of the carrier) , UNTIL -> (BinOp of the carrier) , RELEASE -> (BinOp of the carrier) #);
end;
definition
let C18 being LTLModelStr;
mode Assign of C18
 is (Element of (the carrier of C18));
end;
definition
func atomic_LTL -> (Subset of ( LTL_WFF )) equals
{ B18 where B18 is LTL-formula : B18 is  atomic };
correctness
proof
set D39 = { B19 where B19 is LTL-formula : B19 is  atomic };
L1089: D39 c= ( LTL_WFF )
proof
let C19 being set;
assume L1090: C19 in D39;
L1091: (ex B20 being LTL-formula st (C19 = B20 & B20 is  atomic)) by L1090;
thus L1092: thesis by L1091 , L89;
end;
thus L1093: thesis by L1089;
end;
end;
definition
let C20 being LTLModelStr;
let C21 being (Function of ( atomic_LTL ) , (the BasicAssign of C20));
let C22 being (Function of ( LTL_WFF ) , (the carrier of C20));
pred C22 is-Evaluation-for C21
means
:L1095: (for B21 being LTL-formula holds ((B21 is  atomic implies ( C22 . B21 ) = ( C21 . B21 )) & (B21 is  negative implies ( C22 . B21 ) = ( (the Compl of C20) . ( C22 . ( the_argument_of B21 ) ) )) & (B21 is  conjunctive implies ( C22 . B21 ) = ( (the L_meet of C20) . (( C22 . ( the_left_argument_of B21 ) ) , ( C22 . ( the_right_argument_of B21 ) )) )) & (B21 is  disjunctive implies ( C22 . B21 ) = ( (the L_join of C20) . (( C22 . ( the_left_argument_of B21 ) ) , ( C22 . ( the_right_argument_of B21 ) )) )) & (B21 is  next implies ( C22 . B21 ) = ( (the NEXT of C20) . ( C22 . ( the_argument_of B21 ) ) )) & (B21 is  Until implies ( C22 . B21 ) = ( (the UNTIL of C20) . (( C22 . ( the_left_argument_of B21 ) ) , ( C22 . ( the_right_argument_of B21 ) )) )) & (B21 is  Release implies ( C22 . B21 ) = ( (the RELEASE of C20) . (( C22 . ( the_left_argument_of B21 ) ) , ( C22 . ( the_right_argument_of B21 ) )) ))))
;end;
definition
let C23 being LTLModelStr;
let C24 being (Function of ( atomic_LTL ) , (the BasicAssign of C23));
let C25 being (Function of ( LTL_WFF ) , (the carrier of C23));
let C26 being Nat;
pred C25 is-PreEvaluation-for C26 , C24
means
:L1097: (for B22 being LTL-formula holds (( len B22 ) <= C26 implies ((B22 is  atomic implies ( C25 . B22 ) = ( C24 . B22 )) & (B22 is  negative implies ( C25 . B22 ) = ( (the Compl of C23) . ( C25 . ( the_argument_of B22 ) ) )) & (B22 is  conjunctive implies ( C25 . B22 ) = ( (the L_meet of C23) . (( C25 . ( the_left_argument_of B22 ) ) , ( C25 . ( the_right_argument_of B22 ) )) )) & (B22 is  disjunctive implies ( C25 . B22 ) = ( (the L_join of C23) . (( C25 . ( the_left_argument_of B22 ) ) , ( C25 . ( the_right_argument_of B22 ) )) )) & (B22 is  next implies ( C25 . B22 ) = ( (the NEXT of C23) . ( C25 . ( the_argument_of B22 ) ) )) & (B22 is  Until implies ( C25 . B22 ) = ( (the UNTIL of C23) . (( C25 . ( the_left_argument_of B22 ) ) , ( C25 . ( the_right_argument_of B22 ) )) )) & (B22 is  Release implies ( C25 . B22 ) = ( (the RELEASE of C23) . (( C25 . ( the_left_argument_of B22 ) ) , ( C25 . ( the_right_argument_of B22 ) )) )))))
;end;
definition
let C27 being LTLModelStr;
let C28 being (Function of ( atomic_LTL ) , (the BasicAssign of C27));
let C29 , C30 being (Function of ( LTL_WFF ) , (the carrier of C27));
let C31 being Nat;
let C32 being LTL-formula;
func GraftEval (C27 , C28 , C29 , C30 , C31 , C32) -> set equals
:L1099: ( C29 . C32 ) if ( len C32 ) > ( C31 + 1 ) , ( C28 . C32 ) if (( len C32 ) = ( C31 + 1 ) & C32 is  atomic) , ( (the Compl of C27) . ( C30 . ( the_argument_of C32 ) ) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  negative) , ( (the L_meet of C27) . (( C30 . ( the_left_argument_of C32 ) ) , ( C30 . ( the_right_argument_of C32 ) )) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  conjunctive) , ( (the L_join of C27) . (( C30 . ( the_left_argument_of C32 ) ) , ( C30 . ( the_right_argument_of C32 ) )) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  disjunctive) , ( (the NEXT of C27) . ( C30 . ( the_argument_of C32 ) ) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  next) , ( (the UNTIL of C27) . (( C30 . ( the_left_argument_of C32 ) ) , ( C30 . ( the_right_argument_of C32 ) )) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  Until) , ( (the RELEASE of C27) . (( C30 . ( the_left_argument_of C32 ) ) , ( C30 . ( the_right_argument_of C32 ) )) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  Release) , ( C30 . C32 ) if ( len C32 ) < ( C31 + 1 ) otherwise ( {} );
coherence;
consistency by L483 , L487 , L491 , L495 , L499 , L503;
end;
definition
let C33 being LTLModelStr;
attr C33 is  with_basic
means
:L1101: (the BasicAssign of C33) is non  empty;
end;
definition
func TrivialLTLModel -> LTLModelStr equals
LTLModelStr (# 1 , ( [#] 1 ) , ( op2 ) , ( op2 ) , ( op1 ) , ( op1 ) , ( op2 ) , ( op2 ) #);
coherence;
end;
registration
cluster ( TrivialLTLModel ) ->  with_basic  strict non  empty;
coherence
proof
thus L1104: (the BasicAssign of ( TrivialLTLModel )) is non  empty;
thus L1105: thesis;
end;
end;
registration
cluster non  empty for LTLModelStr;
existence
proof
take ( TrivialLTLModel );
thus L1107: thesis;
end;
end;
registration
cluster  with_basic for non  empty non  empty non  empty non  empty LTLModelStr;
existence
proof
take ( TrivialLTLModel );
thus L1109: thesis;
end;
end;
definition
mode LTLModel
 is  with_basic non  empty LTLModelStr;
end;
registration
let C34 being LTLModel;
cluster (the BasicAssign of C34) -> non  empty;
coherence by L1101;
end;
L1113: (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R29 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds R29 is-PreEvaluation-for ( 0 ) , R28)))
proof
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
let R29 being (Function of ( LTL_WFF ) , (the carrier of R27));
L1114: (for B23 being LTL-formula holds (( len B23 ) <= ( 0 ) implies ((B23 is  atomic implies ( R29 . B23 ) = ( R28 . B23 )) & (B23 is  negative implies ( R29 . B23 ) = ( (the Compl of R27) . ( R29 . ( the_argument_of B23 ) ) )) & (B23 is  conjunctive implies ( R29 . B23 ) = ( (the L_meet of R27) . (( R29 . ( the_left_argument_of B23 ) ) , ( R29 . ( the_right_argument_of B23 ) )) )) & (B23 is  disjunctive implies ( R29 . B23 ) = ( (the L_join of R27) . (( R29 . ( the_left_argument_of B23 ) ) , ( R29 . ( the_right_argument_of B23 ) )) )) & (B23 is  next implies ( R29 . B23 ) = ( (the NEXT of R27) . ( R29 . ( the_argument_of B23 ) ) )) & (B23 is  Until implies ( R29 . B23 ) = ( (the UNTIL of R27) . (( R29 . ( the_left_argument_of B23 ) ) , ( R29 . ( the_right_argument_of B23 ) )) )) & (B23 is  Release implies ( R29 . B23 ) = ( (the RELEASE of R27) . (( R29 . ( the_left_argument_of B23 ) ) , ( R29 . ( the_right_argument_of B23 ) )) ))))) by L230;
thus L1115: thesis by L1114 , L1097;
end;
L1116: (for R2 being Nat holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R29 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds (R29 is-PreEvaluation-for ( R2 + 1 ) , R28 implies R29 is-PreEvaluation-for R2 , R28)))))
proof
let R2 being Nat;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
let R29 being (Function of ( LTL_WFF ) , (the carrier of R27));
assume L1117: R29 is-PreEvaluation-for ( R2 + 1 ) , R28;
L1118: (for B24 being LTL-formula holds (( len B24 ) <= R2 implies ((B24 is  atomic implies ( R29 . B24 ) = ( R28 . B24 )) & (B24 is  negative implies ( R29 . B24 ) = ( (the Compl of R27) . ( R29 . ( the_argument_of B24 ) ) )) & (B24 is  conjunctive implies ( R29 . B24 ) = ( (the L_meet of R27) . (( R29 . ( the_left_argument_of B24 ) ) , ( R29 . ( the_right_argument_of B24 ) )) )) & (B24 is  disjunctive implies ( R29 . B24 ) = ( (the L_join of R27) . (( R29 . ( the_left_argument_of B24 ) ) , ( R29 . ( the_right_argument_of B24 ) )) )) & (B24 is  next implies ( R29 . B24 ) = ( (the NEXT of R27) . ( R29 . ( the_argument_of B24 ) ) )) & (B24 is  Until implies ( R29 . B24 ) = ( (the UNTIL of R27) . (( R29 . ( the_left_argument_of B24 ) ) , ( R29 . ( the_right_argument_of B24 ) )) )) & (B24 is  Release implies ( R29 . B24 ) = ( (the RELEASE of R27) . (( R29 . ( the_left_argument_of B24 ) ) , ( R29 . ( the_right_argument_of B24 ) )) )))))
proof
let C35 being LTL-formula;
assume L1119: ( len C35 ) <= R2;
L1120: ( len C35 ) < ( R2 + 1 ) by L1119 , NAT_1:13;
thus L1121: thesis by L1120 , L1117 , L1097;
end;
thus L1122: thesis by L1118 , L1097;
end;
L1123: (for R2 being Nat holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R29 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds (R29 is-Evaluation-for R28 implies R29 is-PreEvaluation-for R2 , R28)))))
proof
let R2 being Nat;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
let R29 being (Function of ( LTL_WFF ) , (the carrier of R27));
assume L1124: R29 is-Evaluation-for R28;
L1125: (for B25 being LTL-formula holds (( len B25 ) <= R2 implies ((B25 is  atomic implies ( R29 . B25 ) = ( R28 . B25 )) & (B25 is  negative implies ( R29 . B25 ) = ( (the Compl of R27) . ( R29 . ( the_argument_of B25 ) ) )) & (B25 is  conjunctive implies ( R29 . B25 ) = ( (the L_meet of R27) . (( R29 . ( the_left_argument_of B25 ) ) , ( R29 . ( the_right_argument_of B25 ) )) )) & (B25 is  disjunctive implies ( R29 . B25 ) = ( (the L_join of R27) . (( R29 . ( the_left_argument_of B25 ) ) , ( R29 . ( the_right_argument_of B25 ) )) )) & (B25 is  next implies ( R29 . B25 ) = ( (the NEXT of R27) . ( R29 . ( the_argument_of B25 ) ) )) & (B25 is  Until implies ( R29 . B25 ) = ( (the UNTIL of R27) . (( R29 . ( the_left_argument_of B25 ) ) , ( R29 . ( the_right_argument_of B25 ) )) )) & (B25 is  Release implies ( R29 . B25 ) = ( (the RELEASE of R27) . (( R29 . ( the_left_argument_of B25 ) ) , ( R29 . ( the_right_argument_of B25 ) )) ))))) by L1124 , L1095;
thus L1126: thesis by L1125 , L1097;
end;
L1127: (for R2 being Nat holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R30 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds (for R31 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds ((R30 is-PreEvaluation-for R2 , R28 & R31 is-PreEvaluation-for R2 , R28) implies (for B26 being LTL-formula holds (( len B26 ) <= R2 implies ( R30 . B26 ) = ( R31 . B26 )))))))))
proof
let R2 being Nat;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
let R30 being (Function of ( LTL_WFF ) , (the carrier of R27));
let R31 being (Function of ( LTL_WFF ) , (the carrier of R27));
defpred S8[ Nat ] means ((R30 is-PreEvaluation-for $1 , R28 & R31 is-PreEvaluation-for $1 , R28) implies (for B27 being LTL-formula holds (( len B27 ) <= $1 implies ( R30 . B27 ) = ( R31 . B27 ))));
L1128: (for B28 being Nat holds (S8[ B28 ] implies S8[ ( B28 + 1 ) ]))
proof
let C36 being Nat;
assume that
L1129: S8[ C36 ];
assume that
L1130: R30 is-PreEvaluation-for ( C36 + 1 ) , R28
and
L1131: R31 is-PreEvaluation-for ( C36 + 1 ) , R28;
let C37 being LTL-formula;
assume that
L1132: ( len C37 ) <= ( C36 + 1 );
per cases  by L126;
suppose L1133: C37 is  atomic;

L1134: ( R30 . C37 ) = ( R28 . C37 ) by L1133 , L1130 , L1132 , L1097;
thus L1135: thesis by L1134 , L1131 , L1132 , L1133 , L1097;
end;
suppose L1136: C37 is  negative;

L1137: ( len ( the_argument_of C37 ) ) < ( len C37 ) by L1136 , L554;
L1138: ( len ( the_argument_of C37 ) ) <= C36 by L1137 , L1132 , L3;
L1139: ( R31 . C37 ) = ( (the Compl of R27) . ( R31 . ( the_argument_of C37 ) ) ) by L1131 , L1132 , L1136 , L1097
.= ( (the Compl of R27) . ( R30 . ( the_argument_of C37 ) ) ) by L1129 , L1130 , L1131 , L1138 , L1116;
thus L1140: thesis by L1139 , L1130 , L1132 , L1136 , L1097;
end;
suppose L1141: C37 is  next;

L1142: ( len ( the_argument_of C37 ) ) < ( len C37 ) by L1141 , L554;
L1143: ( len ( the_argument_of C37 ) ) <= C36 by L1142 , L1132 , L3;
L1144: ( R31 . C37 ) = ( (the NEXT of R27) . ( R31 . ( the_argument_of C37 ) ) ) by L1131 , L1132 , L1141 , L1097
.= ( (the NEXT of R27) . ( R30 . ( the_argument_of C37 ) ) ) by L1129 , L1130 , L1131 , L1143 , L1116;
thus L1145: thesis by L1144 , L1130 , L1132 , L1141 , L1097;
end;
suppose L1146: C37 is  conjunctive;

L1147: ( len ( the_left_argument_of C37 ) ) < ( len C37 ) by L1146 , L565;
L1148: ( len ( the_left_argument_of C37 ) ) <= C36 by L1147 , L1132 , L3;
L1149: ( R30 . ( the_left_argument_of C37 ) ) = ( R31 . ( the_left_argument_of C37 ) ) by L1148 , L1129 , L1130 , L1131 , L1116;
L1150: ( len ( the_right_argument_of C37 ) ) < ( len C37 ) by L1146 , L565;
L1151: ( len ( the_right_argument_of C37 ) ) <= C36 by L1150 , L1132 , L3;
L1152: ( R31 . C37 ) = ( (the L_meet of R27) . (( R31 . ( the_left_argument_of C37 ) ) , ( R31 . ( the_right_argument_of C37 ) )) ) by L1131 , L1132 , L1146 , L1097
.= ( (the L_meet of R27) . (( R30 . ( the_left_argument_of C37 ) ) , ( R30 . ( the_right_argument_of C37 ) )) ) by L1129 , L1130 , L1131 , L1149 , L1151 , L1116;
thus L1153: thesis by L1152 , L1130 , L1132 , L1146 , L1097;
end;
suppose L1154: C37 is  disjunctive;

L1155: ( len ( the_left_argument_of C37 ) ) < ( len C37 ) by L1154 , L565;
L1156: ( len ( the_left_argument_of C37 ) ) <= C36 by L1155 , L1132 , L3;
L1157: ( R30 . ( the_left_argument_of C37 ) ) = ( R31 . ( the_left_argument_of C37 ) ) by L1156 , L1129 , L1130 , L1131 , L1116;
L1158: ( len ( the_right_argument_of C37 ) ) < ( len C37 ) by L1154 , L565;
L1159: ( len ( the_right_argument_of C37 ) ) <= C36 by L1158 , L1132 , L3;
L1160: ( R31 . C37 ) = ( (the L_join of R27) . (( R31 . ( the_left_argument_of C37 ) ) , ( R31 . ( the_right_argument_of C37 ) )) ) by L1131 , L1132 , L1154 , L1097
.= ( (the L_join of R27) . (( R30 . ( the_left_argument_of C37 ) ) , ( R30 . ( the_right_argument_of C37 ) )) ) by L1129 , L1130 , L1131 , L1157 , L1159 , L1116;
thus L1161: thesis by L1160 , L1130 , L1132 , L1154 , L1097;
end;
suppose L1162: C37 is  Until;

L1163: ( len ( the_left_argument_of C37 ) ) < ( len C37 ) by L1162 , L565;
L1164: ( len ( the_left_argument_of C37 ) ) <= C36 by L1163 , L1132 , L3;
L1165: ( R30 . ( the_left_argument_of C37 ) ) = ( R31 . ( the_left_argument_of C37 ) ) by L1164 , L1129 , L1130 , L1131 , L1116;
L1166: ( len ( the_right_argument_of C37 ) ) < ( len C37 ) by L1162 , L565;
L1167: ( len ( the_right_argument_of C37 ) ) <= C36 by L1166 , L1132 , L3;
L1168: ( R31 . C37 ) = ( (the UNTIL of R27) . (( R31 . ( the_left_argument_of C37 ) ) , ( R31 . ( the_right_argument_of C37 ) )) ) by L1131 , L1132 , L1162 , L1097
.= ( (the UNTIL of R27) . (( R30 . ( the_left_argument_of C37 ) ) , ( R30 . ( the_right_argument_of C37 ) )) ) by L1129 , L1130 , L1131 , L1165 , L1167 , L1116;
thus L1169: thesis by L1168 , L1130 , L1132 , L1162 , L1097;
end;
suppose L1170: C37 is  Release;

L1171: ( len ( the_left_argument_of C37 ) ) < ( len C37 ) by L1170 , L565;
L1172: ( len ( the_left_argument_of C37 ) ) <= C36 by L1171 , L1132 , L3;
L1173: ( R30 . ( the_left_argument_of C37 ) ) = ( R31 . ( the_left_argument_of C37 ) ) by L1172 , L1129 , L1130 , L1131 , L1116;
L1174: ( len ( the_right_argument_of C37 ) ) < ( len C37 ) by L1170 , L565;
L1175: ( len ( the_right_argument_of C37 ) ) <= C36 by L1174 , L1132 , L3;
L1176: ( R31 . C37 ) = ( (the RELEASE of R27) . (( R31 . ( the_left_argument_of C37 ) ) , ( R31 . ( the_right_argument_of C37 ) )) ) by L1131 , L1132 , L1170 , L1097
.= ( (the RELEASE of R27) . (( R30 . ( the_left_argument_of C37 ) ) , ( R30 . ( the_right_argument_of C37 ) )) ) by L1129 , L1130 , L1131 , L1173 , L1175 , L1116;
thus L1177: thesis by L1176 , L1130 , L1132 , L1170 , L1097;
end;
end;
L1179: S8[ ( 0 ) ] by L230;
L1180: (for B29 being Nat holds S8[ B29 ]) from NAT_1:sch 2(L1179 , L1128);
thus L1181: thesis by L1180;
end;
L1182: (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R2 being Nat holds (ex R29 being (Function of ( LTL_WFF ) , (the carrier of R27)) st R29 is-PreEvaluation-for R2 , R28))))
proof
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
defpred S9[ Nat ] means (ex B30 being (Function of ( LTL_WFF ) , (the carrier of R27)) st B30 is-PreEvaluation-for $1 , R28);
L1183: (for B31 being Nat holds (S9[ B31 ] implies S9[ ( B31 + 1 ) ]))
proof
let C38 being Nat;
assume L1184: S9[ C38 ];
consider C39 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1185: C39 is-PreEvaluation-for C38 , R28 by L1184;
L1186: S9[ ( C38 + 1 ) ]
proof
deffunc H1(set) = ( GraftEval (R27 , R28 , C39 , C39 , C38 , ( CastLTL $1 )) );
L1187: (for B32 being set holds (B32 in ( LTL_WFF ) implies H1(B32) in (the carrier of R27)))
proof
let C40 being set;
assume that
L1188: C40 in ( LTL_WFF );
reconsider D40 = C40 as LTL-formula by L1188 , L89;
L1189: H1(D40) = ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) by L1188 , L1085;
per cases  by L126 , XXREAL_0:1;
suppose L1190: ( len D40 ) > ( C38 + 1 );

L1191: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( C39 . D40 ) by L1190 , L1099;
thus L1192: thesis by L1191 , L1188 , L1189 , FUNCT_2:5;
end;
suppose L1193: (( len D40 ) = ( C38 + 1 ) & D40 is  atomic);

L1194: D40 in ( atomic_LTL ) by L1193;
L1195: ( R28 . D40 ) in (the BasicAssign of R27) by L1194 , FUNCT_2:5;
L1196: ( R28 . D40 ) in (the carrier of R27) by L1195;
thus L1197: thesis by L1196 , L1189 , L1193 , L1099;
end;
suppose L1198: (( len D40 ) = ( C38 + 1 ) & D40 is  negative);

L1199: ( the_argument_of D40 ) in ( LTL_WFF ) by L89;
L1200: ( C39 . ( the_argument_of D40 ) ) in (the carrier of R27) by L1199 , FUNCT_2:5;
L1201: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( (the Compl of R27) . ( C39 . ( the_argument_of D40 ) ) ) by L1198 , L1099;
thus L1202: thesis by L1201 , L1189 , L1200 , FUNCT_2:5;
end;
suppose L1203: (( len D40 ) = ( C38 + 1 ) & D40 is  conjunctive);

L1204: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( (the L_meet of R27) . (( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) )) ) by L1203 , L1099;
L1205: ( the_right_argument_of D40 ) in ( LTL_WFF ) by L89;
L1206: ( C39 . ( the_right_argument_of D40 ) ) in (the carrier of R27) by L1205 , FUNCT_2:5;
L1207: ( the_left_argument_of D40 ) in ( LTL_WFF ) by L89;
L1208: ( C39 . ( the_left_argument_of D40 ) ) in (the carrier of R27) by L1207 , FUNCT_2:5;
L1209: [ ( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) ) ] in [: (the carrier of R27) , (the carrier of R27) :] by L1208 , L1206 , ZFMISC_1:def 2;
thus L1210: thesis by L1209 , L1189 , L1204 , FUNCT_2:5;
end;
suppose L1211: (( len D40 ) = ( C38 + 1 ) & D40 is  disjunctive);

L1212: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( (the L_join of R27) . (( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) )) ) by L1211 , L1099;
L1213: ( the_right_argument_of D40 ) in ( LTL_WFF ) by L89;
L1214: ( C39 . ( the_right_argument_of D40 ) ) in (the carrier of R27) by L1213 , FUNCT_2:5;
L1215: ( the_left_argument_of D40 ) in ( LTL_WFF ) by L89;
L1216: ( C39 . ( the_left_argument_of D40 ) ) in (the carrier of R27) by L1215 , FUNCT_2:5;
L1217: [ ( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) ) ] in [: (the carrier of R27) , (the carrier of R27) :] by L1216 , L1214 , ZFMISC_1:def 2;
thus L1218: thesis by L1217 , L1189 , L1212 , FUNCT_2:5;
end;
suppose L1219: (( len D40 ) = ( C38 + 1 ) & D40 is  next);

L1220: ( the_argument_of D40 ) in ( LTL_WFF ) by L89;
L1221: ( C39 . ( the_argument_of D40 ) ) in (the carrier of R27) by L1220 , FUNCT_2:5;
L1222: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( (the NEXT of R27) . ( C39 . ( the_argument_of D40 ) ) ) by L1219 , L1099;
thus L1223: thesis by L1222 , L1189 , L1221 , FUNCT_2:5;
end;
suppose L1224: (( len D40 ) = ( C38 + 1 ) & D40 is  Until);

L1225: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( (the UNTIL of R27) . (( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) )) ) by L1224 , L1099;
L1226: ( the_right_argument_of D40 ) in ( LTL_WFF ) by L89;
L1227: ( C39 . ( the_right_argument_of D40 ) ) in (the carrier of R27) by L1226 , FUNCT_2:5;
L1228: ( the_left_argument_of D40 ) in ( LTL_WFF ) by L89;
L1229: ( C39 . ( the_left_argument_of D40 ) ) in (the carrier of R27) by L1228 , FUNCT_2:5;
L1230: [ ( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) ) ] in [: (the carrier of R27) , (the carrier of R27) :] by L1229 , L1227 , ZFMISC_1:def 2;
thus L1231: thesis by L1230 , L1189 , L1225 , FUNCT_2:5;
end;
suppose L1232: (( len D40 ) = ( C38 + 1 ) & D40 is  Release);

L1233: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( (the RELEASE of R27) . (( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) )) ) by L1232 , L1099;
L1234: ( the_right_argument_of D40 ) in ( LTL_WFF ) by L89;
L1235: ( C39 . ( the_right_argument_of D40 ) ) in (the carrier of R27) by L1234 , FUNCT_2:5;
L1236: ( the_left_argument_of D40 ) in ( LTL_WFF ) by L89;
L1237: ( C39 . ( the_left_argument_of D40 ) ) in (the carrier of R27) by L1236 , FUNCT_2:5;
L1238: [ ( C39 . ( the_left_argument_of D40 ) ) , ( C39 . ( the_right_argument_of D40 ) ) ] in [: (the carrier of R27) , (the carrier of R27) :] by L1237 , L1235 , ZFMISC_1:def 2;
thus L1239: thesis by L1238 , L1189 , L1233 , FUNCT_2:5;
end;
suppose L1240: ( len D40 ) < ( C38 + 1 );

L1241: ( GraftEval (R27 , R28 , C39 , C39 , C38 , D40) ) = ( C39 . D40 ) by L1240 , L1099;
thus L1242: thesis by L1241 , L1188 , L1189 , FUNCT_2:5;
end;
end;
consider C41 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1244: (for B33 being set holds (B33 in ( LTL_WFF ) implies ( C41 . B33 ) = H1(B33))) from FUNCT_2:sch 2(L1187);
take C41;
L1245: (for B34 being LTL-formula holds (( len B34 ) < ( C38 + 1 ) implies ( C41 . B34 ) = ( C39 . B34 )))
proof
let C42 being LTL-formula;
assume that
L1246: ( len C42 ) < ( C38 + 1 );
L1247: C42 in ( LTL_WFF ) by L89;
L1248: ( C41 . C42 ) = H1(C42) by L1247 , L1244
.= ( GraftEval (R27 , R28 , C39 , C39 , C38 , C42) ) by L1247 , L1085;
thus L1249: thesis by L1248 , L1246 , L1099;
end;
L1250: (for B35 being LTL-formula holds (( len B35 ) <= ( C38 + 1 ) implies ((B35 is  atomic implies ( C41 . B35 ) = ( R28 . B35 )) & (B35 is  negative implies ( C41 . B35 ) = ( (the Compl of R27) . ( C41 . ( the_argument_of B35 ) ) )) & (B35 is  conjunctive implies ( C41 . B35 ) = ( (the L_meet of R27) . (( C41 . ( the_left_argument_of B35 ) ) , ( C41 . ( the_right_argument_of B35 ) )) )) & (B35 is  disjunctive implies ( C41 . B35 ) = ( (the L_join of R27) . (( C41 . ( the_left_argument_of B35 ) ) , ( C41 . ( the_right_argument_of B35 ) )) )) & (B35 is  next implies ( C41 . B35 ) = ( (the NEXT of R27) . ( C41 . ( the_argument_of B35 ) ) )) & (B35 is  Until implies ( C41 . B35 ) = ( (the UNTIL of R27) . (( C41 . ( the_left_argument_of B35 ) ) , ( C41 . ( the_right_argument_of B35 ) )) )) & (B35 is  Release implies ( C41 . B35 ) = ( (the RELEASE of R27) . (( C41 . ( the_left_argument_of B35 ) ) , ( C41 . ( the_right_argument_of B35 ) )) )))))
proof
let C43 being LTL-formula;
assume that
L1251: ( len C43 ) <= ( C38 + 1 );
L1252: C43 in ( LTL_WFF ) by L89;
L1253: ( C41 . C43 ) = H1(C43) by L1252 , L1244
.= ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) by L1252 , L1085;
L1254: (C43 is  negative implies ( C41 . C43 ) = ( (the Compl of R27) . ( C41 . ( the_argument_of C43 ) ) ))
proof
assume L1255: C43 is  negative;
L1256: ( len ( the_argument_of C43 ) ) < ( len C43 ) by L1255 , L554;
L1257: ( len ( the_argument_of C43 ) ) <= C38 by L1256 , L1251 , L3;
L1258: ( len ( the_argument_of C43 ) ) < ( C38 + 1 ) by L1257 , NAT_1:13;
per cases  by L1251 , NAT_1:8;
suppose L1259: ( len C43 ) <= C38;

L1260: ( len C43 ) < ( C38 + 1 ) by L1259 , NAT_1:13;
L1261: ( C41 . C43 ) = ( C39 . C43 ) by L1260 , L1245
.= ( (the Compl of R27) . ( C39 . ( the_argument_of C43 ) ) ) by L1185 , L1255 , L1259 , L1097;
thus L1262: thesis by L1261 , L1245 , L1258;
end;
suppose L1263: ( len C43 ) = ( C38 + 1 );

L1264: ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) = ( (the Compl of R27) . ( C39 . ( the_argument_of C43 ) ) ) by L1263 , L1255 , L1099
.= ( (the Compl of R27) . ( C41 . ( the_argument_of C43 ) ) ) by L1245 , L1258;
thus L1265: thesis by L1264 , L1253;
end;
end;
L1267: (C43 is  Release implies ( C41 . C43 ) = ( (the RELEASE of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ))
proof
assume L1268: C43 is  Release;
L1269: ( len ( the_right_argument_of C43 ) ) < ( len C43 ) by L1268 , L565;
L1270: ( len ( the_right_argument_of C43 ) ) <= C38 by L1269 , L1251 , L3;
L1271: ( len ( the_right_argument_of C43 ) ) < ( C38 + 1 ) by L1270 , NAT_1:13;
L1272: ( len ( the_left_argument_of C43 ) ) < ( len C43 ) by L1268 , L565;
L1273: ( len ( the_left_argument_of C43 ) ) <= C38 by L1272 , L1251 , L3;
L1274: ( len ( the_left_argument_of C43 ) ) < ( C38 + 1 ) by L1273 , NAT_1:13;
L1275: ( C39 . ( the_left_argument_of C43 ) ) = ( C41 . ( the_left_argument_of C43 ) ) by L1274 , L1245;
per cases  by L1251 , NAT_1:8;
suppose L1276: ( len C43 ) <= C38;

L1277: ( len C43 ) < ( C38 + 1 ) by L1276 , NAT_1:13;
L1278: ( C41 . C43 ) = ( C39 . C43 ) by L1277 , L1245
.= ( (the RELEASE of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1185 , L1268 , L1276 , L1097;
thus L1279: thesis by L1278 , L1245 , L1275 , L1271;
end;
suppose L1280: ( len C43 ) = ( C38 + 1 );

L1281: ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) = ( (the RELEASE of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1280 , L1268 , L1099
.= ( (the RELEASE of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ) by L1245 , L1275 , L1271;
thus L1282: thesis by L1281 , L1253;
end;
end;
L1284: (C43 is  Until implies ( C41 . C43 ) = ( (the UNTIL of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ))
proof
assume L1285: C43 is  Until;
L1286: ( len ( the_right_argument_of C43 ) ) < ( len C43 ) by L1285 , L565;
L1287: ( len ( the_right_argument_of C43 ) ) <= C38 by L1286 , L1251 , L3;
L1288: ( len ( the_right_argument_of C43 ) ) < ( C38 + 1 ) by L1287 , NAT_1:13;
L1289: ( len ( the_left_argument_of C43 ) ) < ( len C43 ) by L1285 , L565;
L1290: ( len ( the_left_argument_of C43 ) ) <= C38 by L1289 , L1251 , L3;
L1291: ( len ( the_left_argument_of C43 ) ) < ( C38 + 1 ) by L1290 , NAT_1:13;
L1292: ( C39 . ( the_left_argument_of C43 ) ) = ( C41 . ( the_left_argument_of C43 ) ) by L1291 , L1245;
per cases  by L1251 , NAT_1:8;
suppose L1293: ( len C43 ) <= C38;

L1294: ( len C43 ) < ( C38 + 1 ) by L1293 , NAT_1:13;
L1295: ( C41 . C43 ) = ( C39 . C43 ) by L1294 , L1245
.= ( (the UNTIL of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1185 , L1285 , L1293 , L1097;
thus L1296: thesis by L1295 , L1245 , L1292 , L1288;
end;
suppose L1297: ( len C43 ) = ( C38 + 1 );

L1298: ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) = ( (the UNTIL of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1297 , L1285 , L1099
.= ( (the UNTIL of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ) by L1245 , L1292 , L1288;
thus L1299: thesis by L1298 , L1253;
end;
end;
L1301: (C43 is  disjunctive implies ( C41 . C43 ) = ( (the L_join of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ))
proof
assume L1302: C43 is  disjunctive;
L1303: ( len ( the_right_argument_of C43 ) ) < ( len C43 ) by L1302 , L565;
L1304: ( len ( the_right_argument_of C43 ) ) <= C38 by L1303 , L1251 , L3;
L1305: ( len ( the_right_argument_of C43 ) ) < ( C38 + 1 ) by L1304 , NAT_1:13;
L1306: ( len ( the_left_argument_of C43 ) ) < ( len C43 ) by L1302 , L565;
L1307: ( len ( the_left_argument_of C43 ) ) <= C38 by L1306 , L1251 , L3;
L1308: ( len ( the_left_argument_of C43 ) ) < ( C38 + 1 ) by L1307 , NAT_1:13;
L1309: ( C39 . ( the_left_argument_of C43 ) ) = ( C41 . ( the_left_argument_of C43 ) ) by L1308 , L1245;
per cases  by L1251 , NAT_1:8;
suppose L1310: ( len C43 ) <= C38;

L1311: ( len C43 ) < ( C38 + 1 ) by L1310 , NAT_1:13;
L1312: ( C41 . C43 ) = ( C39 . C43 ) by L1311 , L1245
.= ( (the L_join of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1185 , L1302 , L1310 , L1097;
thus L1313: thesis by L1312 , L1245 , L1309 , L1305;
end;
suppose L1314: ( len C43 ) = ( C38 + 1 );

L1315: ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) = ( (the L_join of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1314 , L1302 , L1099
.= ( (the L_join of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ) by L1245 , L1309 , L1305;
thus L1316: thesis by L1315 , L1253;
end;
end;
L1318: (C43 is  conjunctive implies ( C41 . C43 ) = ( (the L_meet of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ))
proof
assume L1319: C43 is  conjunctive;
L1320: ( len ( the_right_argument_of C43 ) ) < ( len C43 ) by L1319 , L565;
L1321: ( len ( the_right_argument_of C43 ) ) <= C38 by L1320 , L1251 , L3;
L1322: ( len ( the_right_argument_of C43 ) ) < ( C38 + 1 ) by L1321 , NAT_1:13;
L1323: ( len ( the_left_argument_of C43 ) ) < ( len C43 ) by L1319 , L565;
L1324: ( len ( the_left_argument_of C43 ) ) <= C38 by L1323 , L1251 , L3;
L1325: ( len ( the_left_argument_of C43 ) ) < ( C38 + 1 ) by L1324 , NAT_1:13;
L1326: ( C39 . ( the_left_argument_of C43 ) ) = ( C41 . ( the_left_argument_of C43 ) ) by L1325 , L1245;
per cases  by L1251 , NAT_1:8;
suppose L1327: ( len C43 ) <= C38;

L1328: ( len C43 ) < ( C38 + 1 ) by L1327 , NAT_1:13;
L1329: ( C41 . C43 ) = ( C39 . C43 ) by L1328 , L1245
.= ( (the L_meet of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1185 , L1319 , L1327 , L1097;
thus L1330: thesis by L1329 , L1245 , L1326 , L1322;
end;
suppose L1331: ( len C43 ) = ( C38 + 1 );

L1332: ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) = ( (the L_meet of R27) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L1331 , L1319 , L1099
.= ( (the L_meet of R27) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ) by L1245 , L1326 , L1322;
thus L1333: thesis by L1332 , L1253;
end;
end;
L1335: (C43 is  next implies ( C41 . C43 ) = ( (the NEXT of R27) . ( C41 . ( the_argument_of C43 ) ) ))
proof
assume L1336: C43 is  next;
L1337: ( len ( the_argument_of C43 ) ) < ( len C43 ) by L1336 , L554;
L1338: ( len ( the_argument_of C43 ) ) <= C38 by L1337 , L1251 , L3;
L1339: ( len ( the_argument_of C43 ) ) < ( C38 + 1 ) by L1338 , NAT_1:13;
per cases  by L1251 , NAT_1:8;
suppose L1340: ( len C43 ) <= C38;

L1341: ( len C43 ) < ( C38 + 1 ) by L1340 , NAT_1:13;
L1342: ( C41 . C43 ) = ( C39 . C43 ) by L1341 , L1245
.= ( (the NEXT of R27) . ( C39 . ( the_argument_of C43 ) ) ) by L1185 , L1336 , L1340 , L1097;
thus L1343: thesis by L1342 , L1245 , L1339;
end;
suppose L1344: ( len C43 ) = ( C38 + 1 );

L1345: ( GraftEval (R27 , R28 , C39 , C39 , C38 , C43) ) = ( (the NEXT of R27) . ( C39 . ( the_argument_of C43 ) ) ) by L1344 , L1336 , L1099
.= ( (the NEXT of R27) . ( C41 . ( the_argument_of C43 ) ) ) by L1245 , L1339;
thus L1346: thesis by L1345 , L1253;
end;
end;
L1348: (C43 is  atomic implies ( C41 . C43 ) = ( R28 . C43 ))
proof
assume L1349: C43 is  atomic;
per cases  by L1251 , NAT_1:8;
suppose L1350: ( len C43 ) <= C38;

L1351: ( len C43 ) < ( C38 + 1 ) by L1350 , NAT_1:13;
L1352: ( C41 . C43 ) = ( C39 . C43 ) by L1351 , L1245
.= ( R28 . C43 ) by L1185 , L1349 , L1350 , L1097;
thus L1353: thesis by L1352;
end;
suppose L1354: ( len C43 ) = ( C38 + 1 );

thus L1355: thesis by L1354 , L1253 , L1349 , L1099;
end;
end;
thus L1357: thesis by L1348 , L1254 , L1318 , L1301 , L1335 , L1284 , L1267;
end;
thus L1358: thesis by L1250 , L1097;
end;
thus L1359: thesis by L1186;
end;
L1360: S9[ ( 0 ) ]
proof
consider C44 being set such that L1361: C44 in (the carrier of R27) by XBOOLE_0:def 1;
set D41 = ( ( LTL_WFF ) --> C44 );
L1362: (( dom D41 ) = ( LTL_WFF ) & ( rng D41 ) c= { C44 }) by FUNCOP_1:13;
L1363: { C44 } c= (the carrier of R27) by L1361 , ZFMISC_1:31;
reconsider D42 = D41 as (Function of ( LTL_WFF ) , (the carrier of R27)) by L1363 , L1362 , FUNCT_2:2 , XBOOLE_1:1;
take D42;
thus L1364: thesis by L1113;
end;
L1365: (for B36 being Nat holds S9[ B36 ]) from NAT_1:sch 2(L1360 , L1183);
thus L1366: thesis by L1365;
end;
L1367: (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R29 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds ((for R2 being Nat holds R29 is-PreEvaluation-for R2 , R28) implies R29 is-Evaluation-for R28))))
proof
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
let R29 being (Function of ( LTL_WFF ) , (the carrier of R27));
assume L1368: (for R2 being Nat holds R29 is-PreEvaluation-for R2 , R28);
let C45 being LTL-formula;
set D43 = ( len C45 );
L1369: R29 is-PreEvaluation-for D43 , R28 by L1368;
thus L1370: thesis by L1369 , L1097;
end;
definition
let C46 being LTLModel;
let C47 being (Function of ( atomic_LTL ) , (the BasicAssign of C46));
let C48 being Nat;
func EvalSet (C46 , C47 , C48) -> non  empty set equals
{ B37 where B37 is (Function of ( LTL_WFF ) , (the carrier of C46)) : B37 is-PreEvaluation-for C48 , C47 };
correctness
proof
set D44 = { B38 where B38 is (Function of ( LTL_WFF ) , (the carrier of C46)) : B38 is-PreEvaluation-for C48 , C47 };
consider C49 being (Function of ( LTL_WFF ) , (the carrier of C46)) such that L1371: C49 is-PreEvaluation-for C48 , C47 by L1182;
L1372: C49 in D44 by L1371;
thus L1373: thesis by L1372;
end;
end;
definition
let C50 being LTLModel;
let C51 being (Element of (the carrier of C50));
let C52 being set;
func CastEval (C50 , C52 , C51) -> (Function of ( LTL_WFF ) , (the carrier of C50)) equals
:L1375: C52 if C52 in ( Funcs (( LTL_WFF ) , (the carrier of C50)) ) otherwise ( ( LTL_WFF ) --> C51 );
correctness by FUNCT_2:66;
end;
definition
let C53 being LTLModel;
let C54 being (Function of ( atomic_LTL ) , (the BasicAssign of C53));
func EvalFamily (C53 , C54) -> non  empty set means
:L1377: (for B39 being set holds (B39 in it iff (B39 in ( bool ( Funcs (( LTL_WFF ) , (the carrier of C53)) ) ) & (ex B40 being Nat st B39 = ( EvalSet (C53 , C54 , B40) )))));
existence
proof
defpred S10[ set ] means (ex B41 being Nat st $1 = ( EvalSet (C53 , C54 , B41) ));
set D45 = ( bool ( Funcs (( LTL_WFF ) , (the carrier of C53)) ) );
consider C55 being set such that L1378: (for B42 being set holds (B42 in C55 iff (B42 in D45 & S10[ B42 ]))) from XBOOLE_0:sch 1;
L1379: C55 is non  empty
proof
set D46 = ( EvalSet (C53 , C54 , ( 0 )) );
L1380: D46 c= ( Funcs (( LTL_WFF ) , (the carrier of C53)) )
proof
let C56 being set;
assume L1381: C56 in D46;
L1382: (ex B43 being (Function of ( LTL_WFF ) , (the carrier of C53)) st (C56 = B43 & B43 is-PreEvaluation-for ( 0 ) , C54)) by L1381;
thus L1383: thesis by L1382 , FUNCT_2:8;
end;
thus L1384: thesis by L1380 , L1378;
end;
reconsider D47 = C55 as non  empty set by L1379;
take D47;
thus L1385: thesis by L1378;
end;
uniqueness
proof
defpred S11[ set ] means ($1 in ( bool ( Funcs (( LTL_WFF ) , (the carrier of C53)) ) ) & (ex B44 being Nat st $1 = ( EvalSet (C53 , C54 , B44) )));
L1386: (for B45 , B46 being set holds (((for B47 being set holds (B47 in B45 iff S11[ B47 ])) & (for B48 being set holds (B48 in B46 iff S11[ B48 ]))) implies B45 = B46)) from XBOOLE_0:sch 3;
thus L1387: thesis by L1386;
end;
end;
L1389: (for R2 being Nat holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( EvalSet (R27 , R28 , R2) ) in ( EvalFamily (R27 , R28) ))))
proof
let R2 being Nat;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
set D48 = ( EvalSet (R27 , R28 , R2) );
L1390: D48 c= ( Funcs (( LTL_WFF ) , (the carrier of R27)) )
proof
let C57 being set;
assume L1391: C57 in D48;
L1392: (ex B49 being (Function of ( LTL_WFF ) , (the carrier of R27)) st (C57 = B49 & B49 is-PreEvaluation-for R2 , R28)) by L1391;
thus L1393: thesis by L1392 , FUNCT_2:8;
end;
thus L1394: thesis by L1390 , L1377;
end;
theorem
L1395: (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (ex R29 being (Function of ( LTL_WFF ) , (the carrier of R27)) st R29 is-Evaluation-for R28)))
proof
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
set D49 = ( EvalFamily (R27 , R28) );
set D50 = the (Element of (the carrier of R27));
L1396: (for B50 being set holds (B50 in D49 implies B50 <> ( {} )))
proof
let C58 being set;
assume L1397: C58 in D49;
L1398: (ex B51 being Nat st C58 = ( EvalSet (R27 , R28 , B51) )) by L1397 , L1377;
thus L1399: thesis by L1398;
end;
consider C59 being Function such that L1400: ( dom C59 ) = D49 and L1401: (for B52 being set holds (B52 in D49 implies ( C59 . B52 ) in B52)) by L1396 , FUNCT_1:111;
deffunc H2(set) = ( C59 . ( EvalSet (R27 , R28 , ( CastNat $1 )) ) );
L1402: (for B53 being set holds (B53 in ( NAT ) implies H2(B53) is (Function of ( LTL_WFF ) , (the carrier of R27))))
proof
let C60 being set;
assume that
L1403: C60 in ( NAT );
set D51 = H2(C60);
reconsider D52 = C60 as Nat by L1403;
L1404: ( CastNat D52 ) = D52 by L1;
L1405: D51 in ( EvalSet (R27 , R28 , D52) ) by L1404 , L1401 , L1389;
L1406: (ex B54 being (Function of ( LTL_WFF ) , (the carrier of R27)) st (D51 = B54 & B54 is-PreEvaluation-for D52 , R28)) by L1405;
thus L1407: thesis by L1406;
end;
L1408: (for B55 being set holds (B55 in ( NAT ) implies H2(B55) in ( Funcs (( LTL_WFF ) , (the carrier of R27)) )))
proof
let C61 being set;
assume L1409: C61 in ( NAT );
L1410: H2(C61) is (Function of ( LTL_WFF ) , (the carrier of R27)) by L1409 , L1402;
thus L1411: thesis by L1410 , FUNCT_2:8;
end;
consider C62 being (Function of ( NAT ) , ( Funcs (( LTL_WFF ) , (the carrier of R27)) )) such that L1412: (for B56 being set holds (B56 in ( NAT ) implies ( C62 . B56 ) = H2(B56))) from FUNCT_2:sch 2(L1408);
deffunc H3(set) = ( ( CastEval (R27 , ( C62 . ( len ( CastLTL $1 ) ) ) , D50) ) . $1 );
L1413: (for B57 being set holds (B57 in ( LTL_WFF ) implies H3(B57) in (the carrier of R27))) by FUNCT_2:5;
consider C63 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1414: (for B58 being set holds (B58 in ( LTL_WFF ) implies ( C63 . B58 ) = H3(B58))) from FUNCT_2:sch 2(L1413);
take C63;
L1415: (for B59 being Nat holds C63 is-PreEvaluation-for B59 , R28)
proof
defpred S12[ Nat ] means C63 is-PreEvaluation-for $1 , R28;
L1416: (for B60 being Nat holds (S12[ B60 ] implies S12[ ( B60 + 1 ) ]))
proof
let C64 being Nat;
assume that
L1417: S12[ C64 ];
L1418: (for B61 being LTL-formula holds (( len B61 ) <= ( C64 + 1 ) implies ((B61 is  atomic implies ( C63 . B61 ) = ( R28 . B61 )) & (B61 is  negative implies ( C63 . B61 ) = ( (the Compl of R27) . ( C63 . ( the_argument_of B61 ) ) )) & (B61 is  conjunctive implies ( C63 . B61 ) = ( (the L_meet of R27) . (( C63 . ( the_left_argument_of B61 ) ) , ( C63 . ( the_right_argument_of B61 ) )) )) & (B61 is  disjunctive implies ( C63 . B61 ) = ( (the L_join of R27) . (( C63 . ( the_left_argument_of B61 ) ) , ( C63 . ( the_right_argument_of B61 ) )) )) & (B61 is  next implies ( C63 . B61 ) = ( (the NEXT of R27) . ( C63 . ( the_argument_of B61 ) ) )) & (B61 is  Until implies ( C63 . B61 ) = ( (the UNTIL of R27) . (( C63 . ( the_left_argument_of B61 ) ) , ( C63 . ( the_right_argument_of B61 ) )) )) & (B61 is  Release implies ( C63 . B61 ) = ( (the RELEASE of R27) . (( C63 . ( the_left_argument_of B61 ) ) , ( C63 . ( the_right_argument_of B61 ) )) )))))
proof
let C65 being LTL-formula;
assume that
L1419: ( len C65 ) <= ( C64 + 1 );
L1420:
now
per cases  by L1419 , NAT_1:8;
case L1421: ( len C65 ) <= C64;
thus L1422: thesis by L1421 , L1417 , L1097;
end;
case L1423: ( len C65 ) = ( C64 + 1 );
set D53 = H2(( len C65 ));
L1424: C65 in ( LTL_WFF ) by L89;
L1425: ( C62 . ( len ( CastLTL C65 ) ) ) = ( C62 . ( len C65 ) ) by L1424 , L1085
.= H2(( len C65 )) by L1412;
L1426: ( CastEval (R27 , ( C62 . ( len ( CastLTL C65 ) ) ) , D50) ) = H2(( len C65 )) by L1425 , L1375;
reconsider D54 = D53 as (Function of ( LTL_WFF ) , (the carrier of R27)) by L1426;
L1427: (D54 = ( C59 . ( EvalSet (R27 , R28 , ( len C65 )) ) ) & ( C59 . ( EvalSet (R27 , R28 , ( len C65 )) ) ) in ( EvalSet (R27 , R28 , ( len C65 )) )) by L1401 , L1 , L1389;
L1428: (ex B62 being (Function of ( LTL_WFF ) , (the carrier of R27)) st (D54 = B62 & B62 is-PreEvaluation-for ( len C65 ) , R28)) by L1427;
L1429: D54 is-PreEvaluation-for C64 , R28 by L1428 , L1423 , L1116;
L1430: ( C63 . C65 ) = ( D54 . C65 ) by L1414 , L1424 , L1426;
L1431: (C65 is  next implies ( C63 . C65 ) = ( (the NEXT of R27) . ( C63 . ( the_argument_of C65 ) ) ))
proof
assume L1432: C65 is  next;
L1433: ( len ( the_argument_of C65 ) ) < ( len C65 ) by L1432 , L554;
L1434: ( len ( the_argument_of C65 ) ) <= C64 by L1433 , L1423 , NAT_1:13;
L1435: ( C63 . C65 ) = ( (the NEXT of R27) . ( D54 . ( the_argument_of C65 ) ) ) by L1430 , L1428 , L1432 , L1097
.= ( (the NEXT of R27) . ( C63 . ( the_argument_of C65 ) ) ) by L1417 , L1429 , L1434 , L1127;
thus L1436: thesis by L1435;
end;
L1437: (C65 is  Release implies ( C63 . C65 ) = ( (the RELEASE of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ))
proof
assume L1438: C65 is  Release;
L1439: ( len ( the_right_argument_of C65 ) ) < ( len C65 ) by L1438 , L565;
L1440: ( len ( the_right_argument_of C65 ) ) <= C64 by L1439 , L1423 , NAT_1:13;
L1441: ( len ( the_left_argument_of C65 ) ) < ( len C65 ) by L1438 , L565;
L1442: ( len ( the_left_argument_of C65 ) ) <= C64 by L1441 , L1423 , NAT_1:13;
L1443: ( C63 . ( the_left_argument_of C65 ) ) = ( D54 . ( the_left_argument_of C65 ) ) by L1442 , L1417 , L1429 , L1127;
L1444: ( C63 . C65 ) = ( (the RELEASE of R27) . (( D54 . ( the_left_argument_of C65 ) ) , ( D54 . ( the_right_argument_of C65 ) )) ) by L1430 , L1428 , L1438 , L1097
.= ( (the RELEASE of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ) by L1417 , L1429 , L1443 , L1440 , L1127;
thus L1445: thesis by L1444;
end;
L1446: (C65 is  Until implies ( C63 . C65 ) = ( (the UNTIL of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ))
proof
assume L1447: C65 is  Until;
L1448: ( len ( the_right_argument_of C65 ) ) < ( len C65 ) by L1447 , L565;
L1449: ( len ( the_right_argument_of C65 ) ) <= C64 by L1448 , L1423 , NAT_1:13;
L1450: ( len ( the_left_argument_of C65 ) ) < ( len C65 ) by L1447 , L565;
L1451: ( len ( the_left_argument_of C65 ) ) <= C64 by L1450 , L1423 , NAT_1:13;
L1452: ( C63 . ( the_left_argument_of C65 ) ) = ( D54 . ( the_left_argument_of C65 ) ) by L1451 , L1417 , L1429 , L1127;
L1453: ( C63 . C65 ) = ( (the UNTIL of R27) . (( D54 . ( the_left_argument_of C65 ) ) , ( D54 . ( the_right_argument_of C65 ) )) ) by L1430 , L1428 , L1447 , L1097
.= ( (the UNTIL of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ) by L1417 , L1429 , L1452 , L1449 , L1127;
thus L1454: thesis by L1453;
end;
L1455: (C65 is  disjunctive implies ( C63 . C65 ) = ( (the L_join of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ))
proof
assume L1456: C65 is  disjunctive;
L1457: ( len ( the_right_argument_of C65 ) ) < ( len C65 ) by L1456 , L565;
L1458: ( len ( the_right_argument_of C65 ) ) <= C64 by L1457 , L1423 , NAT_1:13;
L1459: ( len ( the_left_argument_of C65 ) ) < ( len C65 ) by L1456 , L565;
L1460: ( len ( the_left_argument_of C65 ) ) <= C64 by L1459 , L1423 , NAT_1:13;
L1461: ( C63 . ( the_left_argument_of C65 ) ) = ( D54 . ( the_left_argument_of C65 ) ) by L1460 , L1417 , L1429 , L1127;
L1462: ( C63 . C65 ) = ( (the L_join of R27) . (( D54 . ( the_left_argument_of C65 ) ) , ( D54 . ( the_right_argument_of C65 ) )) ) by L1430 , L1428 , L1456 , L1097
.= ( (the L_join of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ) by L1417 , L1429 , L1461 , L1458 , L1127;
thus L1463: thesis by L1462;
end;
L1464: (C65 is  conjunctive implies ( C63 . C65 ) = ( (the L_meet of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ))
proof
assume L1465: C65 is  conjunctive;
L1466: ( len ( the_right_argument_of C65 ) ) < ( len C65 ) by L1465 , L565;
L1467: ( len ( the_right_argument_of C65 ) ) <= C64 by L1466 , L1423 , NAT_1:13;
L1468: ( len ( the_left_argument_of C65 ) ) < ( len C65 ) by L1465 , L565;
L1469: ( len ( the_left_argument_of C65 ) ) <= C64 by L1468 , L1423 , NAT_1:13;
L1470: ( C63 . ( the_left_argument_of C65 ) ) = ( D54 . ( the_left_argument_of C65 ) ) by L1469 , L1417 , L1429 , L1127;
L1471: ( C63 . C65 ) = ( (the L_meet of R27) . (( D54 . ( the_left_argument_of C65 ) ) , ( D54 . ( the_right_argument_of C65 ) )) ) by L1430 , L1428 , L1465 , L1097
.= ( (the L_meet of R27) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ) by L1417 , L1429 , L1470 , L1467 , L1127;
thus L1472: thesis by L1471;
end;
L1473: (C65 is  negative implies ( C63 . C65 ) = ( (the Compl of R27) . ( C63 . ( the_argument_of C65 ) ) ))
proof
assume L1474: C65 is  negative;
L1475: ( len ( the_argument_of C65 ) ) < ( len C65 ) by L1474 , L554;
L1476: ( len ( the_argument_of C65 ) ) <= C64 by L1475 , L1423 , NAT_1:13;
L1477: ( C63 . C65 ) = ( (the Compl of R27) . ( D54 . ( the_argument_of C65 ) ) ) by L1430 , L1428 , L1474 , L1097
.= ( (the Compl of R27) . ( C63 . ( the_argument_of C65 ) ) ) by L1417 , L1429 , L1476 , L1127;
thus L1478: thesis by L1477;
end;
thus L1479: thesis by L1473 , L1430 , L1428 , L1431 , L1464 , L1455 , L1446 , L1437 , L1097;
end;
end;
thus L1481: thesis by L1420;
end;
thus L1482: thesis by L1418 , L1097;
end;
L1483: (for B63 being LTL-formula holds (( len B63 ) <= ( 0 ) implies ((B63 is  atomic implies ( C63 . B63 ) = ( R28 . B63 )) & (B63 is  negative implies ( C63 . B63 ) = ( (the Compl of R27) . ( C63 . ( the_argument_of B63 ) ) )) & (B63 is  conjunctive implies ( C63 . B63 ) = ( (the L_meet of R27) . (( C63 . ( the_left_argument_of B63 ) ) , ( C63 . ( the_right_argument_of B63 ) )) )) & (B63 is  disjunctive implies ( C63 . B63 ) = ( (the L_join of R27) . (( C63 . ( the_left_argument_of B63 ) ) , ( C63 . ( the_right_argument_of B63 ) )) )) & (B63 is  next implies ( C63 . B63 ) = ( (the NEXT of R27) . ( C63 . ( the_argument_of B63 ) ) )) & (B63 is  Until implies ( C63 . B63 ) = ( (the UNTIL of R27) . (( C63 . ( the_left_argument_of B63 ) ) , ( C63 . ( the_right_argument_of B63 ) )) )) & (B63 is  Release implies ( C63 . B63 ) = ( (the RELEASE of R27) . (( C63 . ( the_left_argument_of B63 ) ) , ( C63 . ( the_right_argument_of B63 ) )) ))))) by L230;
L1484: S12[ ( 0 ) ] by L1483 , L1097;
L1485: (for B64 being Nat holds S12[ B64 ]) from NAT_1:sch 2(L1484 , L1416);
thus L1486: thesis by L1485;
end;
thus L1487: thesis by L1415 , L1367;
end;
theorem
L1488: (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds (for R30 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds (for R31 being (Function of ( LTL_WFF ) , (the carrier of R27)) holds ((R30 is-Evaluation-for R28 & R31 is-Evaluation-for R28) implies R30 = R31)))))
proof
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
let R30 being (Function of ( LTL_WFF ) , (the carrier of R27));
let R31 being (Function of ( LTL_WFF ) , (the carrier of R27));
assume L1489: (R30 is-Evaluation-for R28 & R31 is-Evaluation-for R28);
L1490: (for B65 being set holds (B65 in ( LTL_WFF ) implies ( R30 . B65 ) = ( R31 . B65 )))
proof
let C66 being set;
assume L1491: C66 in ( LTL_WFF );
reconsider D55 = C66 as LTL-formula by L1491 , L89;
set D56 = ( len D55 );
L1492: (R30 is-PreEvaluation-for D56 , R28 & R31 is-PreEvaluation-for D56 , R28) by L1489 , L1123;
thus L1493: thesis by L1492 , L1127;
end;
thus L1494: thesis by L1490 , FUNCT_2:12;
end;
definition
let C67 being LTLModel;
let C68 being (Function of ( atomic_LTL ) , (the BasicAssign of C67));
let C69 being LTL-formula;
func Evaluate (C69 , C68) -> (Assign of C67) means
:L1495: (ex B66 being (Function of ( LTL_WFF ) , (the carrier of C67)) st (B66 is-Evaluation-for C68 & it = ( B66 . C69 )));
existence
proof
consider C70 being (Function of ( LTL_WFF ) , (the carrier of C67)) such that L1496: C70 is-Evaluation-for C68 by L1395;
set D57 = ( C70 . C69 );
L1497: C69 in ( LTL_WFF ) by L89;
reconsider D58 = D57 as (Assign of C67) by L1497 , FUNCT_2:5;
take D58;
thus L1498: thesis by L1496;
end;
uniqueness by L1488;
end;
notation
let C71 being LTLModel;
let C72 being (Assign of C71);
synonym 'not' C72 for C72 `;
let C73 being (Assign of C71);
synonym C72 '&' C73 for C72 "/\" C73;
synonym C72 'or' C73 for C72 "\/" C73;
end;
definition
let C74 being LTLModel;
let C75 being (Assign of C74);
func 'X' C75 -> (Assign of C74) equals
( (the NEXT of C74) . C75 );
correctness;
end;
definition
let C76 being LTLModel;
let C77 , C78 being (Assign of C76);
func C77 'U' C78 -> (Assign of C76) equals
( (the UNTIL of C76) . (C77 , C78) );
correctness;
func C77 'R' C78 -> (Assign of C76) equals
( (the RELEASE of C76) . (C77 , C78) );
correctness;
end;
theorem
L1503: (for R18 being LTL-formula holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( Evaluate (( 'not' R18 ) , R28) ) = ( 'not' ( Evaluate (R18 , R28) ) ))))
proof
let R18 being LTL-formula;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
consider C79 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1504: C79 is-Evaluation-for R28 and L1505: ( Evaluate (( 'not' R18 ) , R28) ) = ( C79 . ( 'not' R18 ) ) by L1495;
L1506: (ex B67 being (Function of ( LTL_WFF ) , (the carrier of R27)) st (B67 is-Evaluation-for R28 & ( Evaluate (R18 , R28) ) = ( B67 . R18 ))) by L1495;
L1507: ( 'not' R18 ) is  negative by L119;
L1508: ( Evaluate (( 'not' R18 ) , R28) ) = ( (the Compl of R27) . ( C79 . ( the_argument_of ( 'not' R18 ) ) ) ) by L1507 , L1504 , L1505 , L1095
.= ( (the Compl of R27) . ( C79 . R18 ) ) by L1507 , L508
.= ( 'not' ( Evaluate (R18 , R28) ) ) by L1504 , L1506 , L1488;
thus L1509: thesis by L1508;
end;
theorem
L1510: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( Evaluate (( R19 '&' R20 ) , R28) ) = ( ( Evaluate (R19 , R28) ) '&' ( Evaluate (R20 , R28) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
consider C80 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1511: C80 is-Evaluation-for R28 and L1512: ( Evaluate (( R19 '&' R20 ) , R28) ) = ( C80 . ( R19 '&' R20 ) ) by L1495;
consider C81 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1513: C81 is-Evaluation-for R28 and L1514: ( Evaluate (R19 , R28) ) = ( C81 . R19 ) by L1495;
consider C82 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1515: C82 is-Evaluation-for R28 and L1516: ( Evaluate (R20 , R28) ) = ( C82 . R20 ) by L1495;
L1517: C80 = C82 by L1511 , L1515 , L1488;
L1518: ( R19 '&' R20 ) is  conjunctive by L120;
L1519: (( the_left_argument_of ( R19 '&' R20 ) ) = R19 & ( the_right_argument_of ( R19 '&' R20 ) ) = R20) by L1518 , L511 , L512;
L1520: C80 = C81 by L1511 , L1513 , L1488;
thus L1521: thesis by L1520 , L1511 , L1512 , L1514 , L1516 , L1517 , L1518 , L1519 , L1095;
end;
theorem
L1522: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( Evaluate (( R19 'or' R20 ) , R28) ) = ( ( Evaluate (R19 , R28) ) 'or' ( Evaluate (R20 , R28) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
consider C83 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1523: C83 is-Evaluation-for R28 and L1524: ( Evaluate (( R19 'or' R20 ) , R28) ) = ( C83 . ( R19 'or' R20 ) ) by L1495;
consider C84 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1525: C84 is-Evaluation-for R28 and L1526: ( Evaluate (R19 , R28) ) = ( C84 . R19 ) by L1495;
consider C85 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1527: C85 is-Evaluation-for R28 and L1528: ( Evaluate (R20 , R28) ) = ( C85 . R20 ) by L1495;
L1529: C83 = C85 by L1523 , L1527 , L1488;
L1530: ( R19 'or' R20 ) is  disjunctive by L121;
L1531: (( the_left_argument_of ( R19 'or' R20 ) ) = R19 & ( the_right_argument_of ( R19 'or' R20 ) ) = R20) by L1530 , L511 , L512;
L1532: C83 = C84 by L1523 , L1525 , L1488;
thus L1533: thesis by L1532 , L1523 , L1524 , L1526 , L1528 , L1529 , L1530 , L1531 , L1095;
end;
theorem
L1534: (for R18 being LTL-formula holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( Evaluate (( 'X' R18 ) , R28) ) = ( 'X' ( Evaluate (R18 , R28) ) ))))
proof
let R18 being LTL-formula;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
consider C86 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1535: C86 is-Evaluation-for R28 and L1536: ( Evaluate (( 'X' R18 ) , R28) ) = ( C86 . ( 'X' R18 ) ) by L1495;
L1537: (ex B68 being (Function of ( LTL_WFF ) , (the carrier of R27)) st (B68 is-Evaluation-for R28 & ( Evaluate (R18 , R28) ) = ( B68 . R18 ))) by L1495;
L1538: ( 'X' R18 ) is  next by L122;
L1539: (not ( 'X' R18 ) is  negative) by L1538 , L495;
L1540: ( Evaluate (( 'X' R18 ) , R28) ) = ( (the NEXT of R27) . ( C86 . ( the_argument_of ( 'X' R18 ) ) ) ) by L1535 , L1536 , L1538 , L1095
.= ( (the NEXT of R27) . ( C86 . R18 ) ) by L1538 , L1539 , L508
.= ( 'X' ( Evaluate (R18 , R28) ) ) by L1535 , L1537 , L1488;
thus L1541: thesis by L1540;
end;
theorem
L1542: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( Evaluate (( R19 'U' R20 ) , R28) ) = ( ( Evaluate (R19 , R28) ) 'U' ( Evaluate (R20 , R28) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
consider C87 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1543: C87 is-Evaluation-for R28 and L1544: ( Evaluate (( R19 'U' R20 ) , R28) ) = ( C87 . ( R19 'U' R20 ) ) by L1495;
consider C88 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1545: C88 is-Evaluation-for R28 and L1546: ( Evaluate (R19 , R28) ) = ( C88 . R19 ) by L1495;
consider C89 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1547: C89 is-Evaluation-for R28 and L1548: ( Evaluate (R20 , R28) ) = ( C89 . R20 ) by L1495;
L1549: C87 = C89 by L1543 , L1547 , L1488;
L1550: ( R19 'U' R20 ) is  Until by L123;
L1551: (( the_left_argument_of ( R19 'U' R20 ) ) = R19 & ( the_right_argument_of ( R19 'U' R20 ) ) = R20) by L1550 , L511 , L512;
L1552: C87 = C88 by L1543 , L1545 , L1488;
thus L1553: thesis by L1552 , L1543 , L1544 , L1546 , L1548 , L1549 , L1550 , L1551 , L1095;
end;
theorem
L1554: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R27 being LTLModel holds (for R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27)) holds ( Evaluate (( R19 'R' R20 ) , R28) ) = ( ( Evaluate (R19 , R28) ) 'R' ( Evaluate (R20 , R28) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R27 being LTLModel;
let R28 being (Function of ( atomic_LTL ) , (the BasicAssign of R27));
consider C90 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1555: C90 is-Evaluation-for R28 and L1556: ( Evaluate (( R19 'R' R20 ) , R28) ) = ( C90 . ( R19 'R' R20 ) ) by L1495;
consider C91 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1557: C91 is-Evaluation-for R28 and L1558: ( Evaluate (R19 , R28) ) = ( C91 . R19 ) by L1495;
consider C92 being (Function of ( LTL_WFF ) , (the carrier of R27)) such that L1559: C92 is-Evaluation-for R28 and L1560: ( Evaluate (R20 , R28) ) = ( C92 . R20 ) by L1495;
L1561: C90 = C92 by L1555 , L1559 , L1488;
L1562: ( R19 'R' R20 ) is  Release by L124;
L1563: (not ( R19 'R' R20 ) is  Until) by L1562 , L503;
L1564: ((not ( R19 'R' R20 ) is  conjunctive) & (not ( R19 'R' R20 ) is  disjunctive)) by L1562 , L503;
L1565: (( the_left_argument_of ( R19 'R' R20 ) ) = R19 & ( the_right_argument_of ( R19 'R' R20 ) ) = R20) by L1564 , L1562 , L1563 , L511 , L512;
L1566: C90 = C91 by L1555 , L1557 , L1488;
thus L1567: thesis by L1566 , L1555 , L1556 , L1558 , L1560 , L1561 , L1562 , L1565 , L1095;
end;
definition
let C93 being non  empty set;
func Inf_seq C93 -> non  empty set equals
( Funcs (( NAT ) , C93) );
correctness;
end;
definition
let C94 being non  empty set;
let C95 being (sequence of C94);
func CastSeq C95 -> (Element of ( Inf_seq C94 )) equals
C95;
correctness by FUNCT_2:8;
end;
definition
let C96 being non  empty set;
let C97 being set;
assume L1570: C97 is (Element of ( Inf_seq C96 ));
func CastSeq (C97 , C96) -> (sequence of C96) equals
:L1571: C97;
correctness by L1570 , FUNCT_2:66;
end;
definition
let C98 being non  empty set;
let C99 being set;
let C100 being Nat;
func Shift (C99 , C100 , C98) -> (Element of ( Inf_seq C98 )) equals
( CastSeq ( ( CastSeq (C99 , C98) ) ^\ C100 ) );
correctness;
end;
definition
let C101 being non  empty set;
let C102 being (Element of ( Inf_seq C101 ));
let C103 being Nat;
func Shift (C102 , C103) -> (Element of ( Inf_seq C101 )) equals
( Shift (C102 , C103 , C101) );
correctness;
end;
L1575: (for R11 being non  empty set holds (for B69 being (Element of ( Inf_seq R11 )) holds ( Shift (B69 , ( 0 )) ) = B69))
proof
let R11 being non  empty set;
let C104 being (Element of ( Inf_seq R11 ));
set D59 = ( CastSeq (C104 , R11) );
L1576: (for R5 being set holds (R5 in ( NAT ) implies ( ( D59 ^\ ( 0 ) ) . R5 ) = ( D59 . R5 )))
proof
let R5 being set;
assume L1577: R5 in ( NAT );
reconsider D60 = R5 as (Element of ( NAT )) by L1577;
L1578: ( ( D59 ^\ ( 0 ) ) . D60 ) = ( D59 . ( D60 + ( 0 ) ) ) by NAT_1:def 3;
thus L1579: thesis by L1578;
end;
L1580: ( Shift (C104 , ( 0 )) ) = ( CastSeq D59 ) by L1576 , FUNCT_2:12;
thus L1581: thesis by L1580 , L1571;
end;
L1582: (for R1 being Nat holds (for R2 being Nat holds (for R11 being non  empty set holds (for B70 being (Element of ( Inf_seq R11 )) holds ( Shift (( Shift (B70 , R1) ) , R2) ) = ( Shift (B70 , ( R2 + R1 )) )))))
proof
let R1 being Nat;
let R2 being Nat;
let R11 being non  empty set;
let C105 being (Element of ( Inf_seq R11 ));
set D61 = ( R2 + R1 );
set D62 = ( Shift (C105 , R1) );
set D63 = ( CastSeq (C105 , R11) );
set D64 = ( CastSeq (D62 , R11) );
L1583: (for R3 being Nat holds ( D64 . R3 ) = ( D63 . ( R3 + R1 ) ))
proof
let R3 being Nat;
L1584: ( D64 . R3 ) = ( ( D63 ^\ R1 ) . R3 ) by L1571;
thus L1585: thesis by L1584 , NAT_1:def 3;
end;
L1586: (for R3 being Nat holds ( ( D64 ^\ R2 ) . R3 ) = ( ( D63 ^\ D61 ) . R3 ))
proof
let R3 being Nat;
L1587: ( ( D64 ^\ R2 ) . R3 ) = ( D64 . ( R3 + R2 ) ) by NAT_1:def 3
.= ( D63 . ( ( R3 + R2 ) + R1 ) ) by L1583
.= ( D63 . ( R3 + D61 ) );
thus L1588: thesis by L1587 , NAT_1:def 3;
end;
L1589: (for R5 being set holds (R5 in ( NAT ) implies ( ( D64 ^\ R2 ) . R5 ) = ( ( D63 ^\ D61 ) . R5 ))) by L1586;
thus L1590: thesis by L1589 , FUNCT_2:12;
end;
definition
let C106 being non  empty set;
let C107 being set;
func Not_0 (C107 , C106) -> (Element of ( ModelSP ( Inf_seq C106 ) )) means
:L1591: (for B71 being set holds (B71 in ( Inf_seq C106 ) implies (( 'not' ( Castboolean ( ( Fid (C107 , ( Inf_seq C106 )) ) . B71 ) ) ) = ( TRUE ) iff ( ( Fid (it , ( Inf_seq C106 )) ) . B71 ) = ( TRUE ))));
existence
proof
set D65 = ( Inf_seq C106 );
deffunc H4(set , (Function of D65 , ( BOOLEAN ))) = ( 'not' ( Castboolean ( $2 . $1 ) ) );
consider C108 being set such that L1592: (C108 in ( ModelSP D65 ) & (for B72 being set holds (B72 in D65 implies (H4(B72 , ( Fid (C107 , D65) )) = ( TRUE ) iff ( ( Fid (C108 , D65) ) . B72 ) = ( TRUE ))))) from MODELC_1:sch 2;
take C108;
thus L1593: thesis by L1592;
end;
uniqueness
proof
set D66 = ( Inf_seq C106 );
deffunc H5(set , (Function of D66 , ( BOOLEAN ))) = ( 'not' ( Castboolean ( $2 . $1 ) ) );
L1594: (for B73 , B74 being set holds ((B73 in ( ModelSP D66 ) & (for B75 being set holds (B75 in D66 implies (H5(B75 , ( Fid (C107 , D66) )) = ( TRUE ) iff ( ( Fid (B73 , D66) ) . B75 ) = ( TRUE )))) & B74 in ( ModelSP D66 ) & (for B76 being set holds (B76 in D66 implies (H5(B76 , ( Fid (C107 , D66) )) = ( TRUE ) iff ( ( Fid (B74 , D66) ) . B76 ) = ( TRUE ))))) implies B73 = B74)) from MODELC_1:sch 3;
thus L1595: thesis by L1594;
end;
end;
L1597: (for R11 being non  empty set holds (for B77 , B78 being (UnOp of ( ModelSP ( Inf_seq R11 ) )) holds (((for B79 being set holds (B79 in ( ModelSP ( Inf_seq R11 ) ) implies ( B77 . B79 ) = ( Not_0 (B79 , R11) ))) & (for B80 being set holds (B80 in ( ModelSP ( Inf_seq R11 ) ) implies ( B78 . B80 ) = ( Not_0 (B80 , R11) )))) implies B77 = B78)))
proof
let R11 being non  empty set;
set D67 = ( ModelSP ( Inf_seq R11 ) );
deffunc H6(set) = ( Not_0 ($1 , R11) );
L1598: (for B81 , B82 being (UnOp of D67) holds (((for B83 being set holds (B83 in D67 implies ( B81 . B83 ) = H6(B83))) & (for B84 being set holds (B84 in D67 implies ( B82 . B84 ) = H6(B84)))) implies B81 = B82)) from MODELC_1:sch 5;
thus L1599: thesis by L1598;
end;
definition
let C109 being non  empty set;
func Not_ C109 -> (UnOp of ( ModelSP ( Inf_seq C109 ) )) means
:L1600: (for B85 being set holds (B85 in ( ModelSP ( Inf_seq C109 ) ) implies ( it . B85 ) = ( Not_0 (B85 , C109) )));
existence
proof
set D68 = ( ModelSP ( Inf_seq C109 ) );
deffunc H7(set) = ( Not_0 ($1 , C109) );
L1601: (ex B86 being (UnOp of D68) st (for B87 being set holds (B87 in D68 implies ( B86 . B87 ) = H7(B87)))) from MODELC_1:sch 4;
thus L1602: thesis by L1601;
end;
uniqueness by L1597;
end;
definition
let C110 being non  empty set;
let C111 being (Function of ( Inf_seq C110 ) , ( BOOLEAN ));
let C112 being set;
func Next_univ (C112 , C111) -> (Element of ( BOOLEAN )) equals
:L1604: ( TRUE ) if (C112 is (Element of ( Inf_seq C110 )) & ( C111 . ( Shift (C112 , 1 , C110) ) ) = ( TRUE )) otherwise ( FALSE );
correctness;
end;
definition
let C113 being non  empty set;
let C114 being set;
func Next_0 (C114 , C113) -> (Element of ( ModelSP ( Inf_seq C113 ) )) means
:L1606: (for B88 being set holds (B88 in ( Inf_seq C113 ) implies (( Next_univ (B88 , ( Fid (C114 , ( Inf_seq C113 )) )) ) = ( TRUE ) iff ( ( Fid (it , ( Inf_seq C113 )) ) . B88 ) = ( TRUE ))));
existence
proof
deffunc H8(set , (Function of ( Inf_seq C113 ) , ( BOOLEAN ))) = ( Next_univ ($1 , $2) );
consider C115 being set such that L1607: (C115 in ( ModelSP ( Inf_seq C113 ) ) & (for B89 being set holds (B89 in ( Inf_seq C113 ) implies (H8(B89 , ( Fid (C114 , ( Inf_seq C113 )) )) = ( TRUE ) iff ( ( Fid (C115 , ( Inf_seq C113 )) ) . B89 ) = ( TRUE ))))) from MODELC_1:sch 2;
take C115;
thus L1608: thesis by L1607;
end;
uniqueness
proof
deffunc H9(set , (Function of ( Inf_seq C113 ) , ( BOOLEAN ))) = ( Next_univ ($1 , $2) );
L1609: (for B90 , B91 being set holds ((B90 in ( ModelSP ( Inf_seq C113 ) ) & (for B92 being set holds (B92 in ( Inf_seq C113 ) implies (H9(B92 , ( Fid (C114 , ( Inf_seq C113 )) )) = ( TRUE ) iff ( ( Fid (B90 , ( Inf_seq C113 )) ) . B92 ) = ( TRUE )))) & B91 in ( ModelSP ( Inf_seq C113 ) ) & (for B93 being set holds (B93 in ( Inf_seq C113 ) implies (H9(B93 , ( Fid (C114 , ( Inf_seq C113 )) )) = ( TRUE ) iff ( ( Fid (B91 , ( Inf_seq C113 )) ) . B93 ) = ( TRUE ))))) implies B90 = B91)) from MODELC_1:sch 3;
thus L1610: thesis by L1609;
end;
end;
L1612: (for R11 being non  empty set holds (for B94 , B95 being (UnOp of ( ModelSP ( Inf_seq R11 ) )) holds (((for B96 being set holds (B96 in ( ModelSP ( Inf_seq R11 ) ) implies ( B94 . B96 ) = ( Next_0 (B96 , R11) ))) & (for B97 being set holds (B97 in ( ModelSP ( Inf_seq R11 ) ) implies ( B95 . B97 ) = ( Next_0 (B97 , R11) )))) implies B94 = B95)))
proof
let R11 being non  empty set;
set D69 = ( ModelSP ( Inf_seq R11 ) );
deffunc H10(set) = ( Next_0 ($1 , R11) );
L1613: (for B98 , B99 being (UnOp of D69) holds (((for B100 being set holds (B100 in D69 implies ( B98 . B100 ) = H10(B100))) & (for B101 being set holds (B101 in D69 implies ( B99 . B101 ) = H10(B101)))) implies B98 = B99)) from MODELC_1:sch 5;
thus L1614: thesis by L1613;
end;
definition
let C116 being non  empty set;
func Next_ C116 -> (UnOp of ( ModelSP ( Inf_seq C116 ) )) means
:L1615: (for B102 being set holds (B102 in ( ModelSP ( Inf_seq C116 ) ) implies ( it . B102 ) = ( Next_0 (B102 , C116) )));
existence
proof
set D70 = ( ModelSP ( Inf_seq C116 ) );
deffunc H11(set) = ( Next_0 ($1 , C116) );
L1616: (ex B103 being (UnOp of D70) st (for B104 being set holds (B104 in D70 implies ( B103 . B104 ) = H11(B104)))) from MODELC_1:sch 4;
thus L1617: thesis by L1616;
end;
uniqueness by L1612;
end;
definition
let C117 being non  empty set;
let C118 , C119 being set;
func And_0 (C118 , C119 , C117) -> (Element of ( ModelSP ( Inf_seq C117 ) )) means
:L1619: (for B105 being set holds (B105 in ( Inf_seq C117 ) implies (( ( Castboolean ( ( Fid (C118 , ( Inf_seq C117 )) ) . B105 ) ) '&' ( Castboolean ( ( Fid (C119 , ( Inf_seq C117 )) ) . B105 ) ) ) = ( TRUE ) iff ( ( Fid (it , ( Inf_seq C117 )) ) . B105 ) = ( TRUE ))));
existence
proof
deffunc H12(set , (Function of ( Inf_seq C117 ) , ( BOOLEAN )) , (Function of ( Inf_seq C117 ) , ( BOOLEAN ))) = ( ( Castboolean ( $2 . $1 ) ) '&' ( Castboolean ( $3 . $1 ) ) );
consider C120 being set such that L1620: (C120 in ( ModelSP ( Inf_seq C117 ) ) & (for B106 being set holds (B106 in ( Inf_seq C117 ) implies (H12(B106 , ( Fid (C118 , ( Inf_seq C117 )) ) , ( Fid (C119 , ( Inf_seq C117 )) )) = ( TRUE ) iff ( ( Fid (C120 , ( Inf_seq C117 )) ) . B106 ) = ( TRUE ))))) from MODELC_1:sch 6;
take C120;
thus L1621: thesis by L1620;
end;
uniqueness
proof
deffunc H13(set , (Function of ( Inf_seq C117 ) , ( BOOLEAN )) , (Function of ( Inf_seq C117 ) , ( BOOLEAN ))) = ( ( Castboolean ( $2 . $1 ) ) '&' ( Castboolean ( $3 . $1 ) ) );
L1622: (for B107 , B108 being set holds ((B107 in ( ModelSP ( Inf_seq C117 ) ) & (for B109 being set holds (B109 in ( Inf_seq C117 ) implies (H13(B109 , ( Fid (C118 , ( Inf_seq C117 )) ) , ( Fid (C119 , ( Inf_seq C117 )) )) = ( TRUE ) iff ( ( Fid (B107 , ( Inf_seq C117 )) ) . B109 ) = ( TRUE )))) & B108 in ( ModelSP ( Inf_seq C117 ) ) & (for B110 being set holds (B110 in ( Inf_seq C117 ) implies (H13(B110 , ( Fid (C118 , ( Inf_seq C117 )) ) , ( Fid (C119 , ( Inf_seq C117 )) )) = ( TRUE ) iff ( ( Fid (B108 , ( Inf_seq C117 )) ) . B110 ) = ( TRUE ))))) implies B107 = B108)) from MODELC_1:sch 7;
thus L1623: thesis by L1622;
end;
end;
L1625: (for R11 being non  empty set holds (for B111 , B112 being (BinOp of ( ModelSP ( Inf_seq R11 ) )) holds (((for B113 , B114 being set holds ((B113 in ( ModelSP ( Inf_seq R11 ) ) & B114 in ( ModelSP ( Inf_seq R11 ) )) implies ( B111 . (B113 , B114) ) = ( And_0 (B113 , B114 , R11) ))) & (for B115 , B116 being set holds ((B115 in ( ModelSP ( Inf_seq R11 ) ) & B116 in ( ModelSP ( Inf_seq R11 ) )) implies ( B112 . (B115 , B116) ) = ( And_0 (B115 , B116 , R11) )))) implies B111 = B112)))
proof
let R11 being non  empty set;
set D71 = ( ModelSP ( Inf_seq R11 ) );
deffunc H14((Element of D71) , (Element of D71)) = ( And_0 ($1 , $2 , R11) );
L1626: (for B117 , B118 being (BinOp of D71) holds (((for B119 , B120 being (Element of D71) holds ( B117 . (B119 , B120) ) = H14(B119 , B120)) & (for B121 , B122 being (Element of D71) holds ( B118 . (B121 , B122) ) = H14(B121 , B122))) implies B117 = B118)) from BINOP_2:sch 2;
L1627: (for B123 , B124 being (BinOp of D71) holds (((for B125 , B126 being set holds ((B125 in D71 & B126 in D71) implies ( B123 . (B125 , B126) ) = ( And_0 (B125 , B126 , R11) ))) & (for B127 , B128 being set holds ((B127 in D71 & B128 in D71) implies ( B124 . (B127 , B128) ) = ( And_0 (B127 , B128 , R11) )))) implies B123 = B124))
proof
let C121 , C122 being (BinOp of D71);
assume L1628: ((for B129 , B130 being set holds ((B129 in D71 & B130 in D71) implies ( C121 . (B129 , B130) ) = ( And_0 (B129 , B130 , R11) ))) & (for B131 , B132 being set holds ((B131 in D71 & B132 in D71) implies ( C122 . (B131 , B132) ) = ( And_0 (B131 , B132 , R11) ))));
L1629: ((for B133 , B134 being (Element of D71) holds ( C121 . (B133 , B134) ) = H14(B133 , B134)) & (for B135 , B136 being (Element of D71) holds ( C122 . (B135 , B136) ) = H14(B135 , B136))) by L1628;
thus L1630: thesis by L1629 , L1626;
end;
thus L1631: thesis by L1627;
end;
definition
let C123 being non  empty set;
func And_ C123 -> (BinOp of ( ModelSP ( Inf_seq C123 ) )) means
:L1632: (for B137 , B138 being set holds ((B137 in ( ModelSP ( Inf_seq C123 ) ) & B138 in ( ModelSP ( Inf_seq C123 ) )) implies ( it . (B137 , B138) ) = ( And_0 (B137 , B138 , C123) )));
existence
proof
set D72 = ( ModelSP ( Inf_seq C123 ) );
deffunc H15((Element of D72) , (Element of D72)) = ( And_0 ($1 , $2 , C123) );
consider C124 being (BinOp of D72) such that L1633: (for B139 , B140 being (Element of D72) holds ( C124 . (B139 , B140) ) = H15(B139 , B140)) from BINOP_1:sch 4;
L1634: (for B141 , B142 being set holds ((B141 in D72 & B142 in D72) implies ( C124 . (B141 , B142) ) = ( And_0 (B141 , B142 , C123) ))) by L1633;
thus L1635: thesis by L1634;
end;
uniqueness by L1625;
end;
definition
let C125 being non  empty set;
let C126 , C127 being (Function of ( Inf_seq C125 ) , ( BOOLEAN ));
let C128 being set;
func Until_univ (C128 , C126 , C127 , C125) -> (Element of ( BOOLEAN )) equals
:L1637: ( TRUE ) if (C128 is (Element of ( Inf_seq C125 )) & (ex B143 being Nat st ((for B144 being Nat holds (B144 < B143 implies ( C126 . ( Shift (C128 , B144 , C125) ) ) = ( TRUE ))) & ( C127 . ( Shift (C128 , B143 , C125) ) ) = ( TRUE )))) otherwise ( FALSE );
correctness;
end;
definition
let C129 being non  empty set;
let C130 , C131 being set;
func Until_0 (C130 , C131 , C129) -> (Element of ( ModelSP ( Inf_seq C129 ) )) means
:L1639: (for B145 being set holds (B145 in ( Inf_seq C129 ) implies (( Until_univ (B145 , ( Fid (C130 , ( Inf_seq C129 )) ) , ( Fid (C131 , ( Inf_seq C129 )) ) , C129) ) = ( TRUE ) iff ( ( Fid (it , ( Inf_seq C129 )) ) . B145 ) = ( TRUE ))));
existence
proof
deffunc H16(set , (Function of ( Inf_seq C129 ) , ( BOOLEAN )) , (Function of ( Inf_seq C129 ) , ( BOOLEAN ))) = ( Until_univ ($1 , $2 , $3 , C129) );
consider C132 being set such that L1640: (C132 in ( ModelSP ( Inf_seq C129 ) ) & (for B146 being set holds (B146 in ( Inf_seq C129 ) implies (H16(B146 , ( Fid (C130 , ( Inf_seq C129 )) ) , ( Fid (C131 , ( Inf_seq C129 )) )) = ( TRUE ) iff ( ( Fid (C132 , ( Inf_seq C129 )) ) . B146 ) = ( TRUE ))))) from MODELC_1:sch 6;
take C132;
thus L1641: thesis by L1640;
end;
uniqueness
proof
deffunc H17(set , (Function of ( Inf_seq C129 ) , ( BOOLEAN )) , (Function of ( Inf_seq C129 ) , ( BOOLEAN ))) = ( Until_univ ($1 , $2 , $3 , C129) );
L1642: (for B147 , B148 being set holds ((B147 in ( ModelSP ( Inf_seq C129 ) ) & (for B149 being set holds (B149 in ( Inf_seq C129 ) implies (H17(B149 , ( Fid (C130 , ( Inf_seq C129 )) ) , ( Fid (C131 , ( Inf_seq C129 )) )) = ( TRUE ) iff ( ( Fid (B147 , ( Inf_seq C129 )) ) . B149 ) = ( TRUE )))) & B148 in ( ModelSP ( Inf_seq C129 ) ) & (for B150 being set holds (B150 in ( Inf_seq C129 ) implies (H17(B150 , ( Fid (C130 , ( Inf_seq C129 )) ) , ( Fid (C131 , ( Inf_seq C129 )) )) = ( TRUE ) iff ( ( Fid (B148 , ( Inf_seq C129 )) ) . B150 ) = ( TRUE ))))) implies B147 = B148)) from MODELC_1:sch 7;
thus L1643: thesis by L1642;
end;
end;
L1645: (for R11 being non  empty set holds (for B151 , B152 being (BinOp of ( ModelSP ( Inf_seq R11 ) )) holds (((for B153 , B154 being set holds ((B153 in ( ModelSP ( Inf_seq R11 ) ) & B154 in ( ModelSP ( Inf_seq R11 ) )) implies ( B151 . (B153 , B154) ) = ( Until_0 (B153 , B154 , R11) ))) & (for B155 , B156 being set holds ((B155 in ( ModelSP ( Inf_seq R11 ) ) & B156 in ( ModelSP ( Inf_seq R11 ) )) implies ( B152 . (B155 , B156) ) = ( Until_0 (B155 , B156 , R11) )))) implies B151 = B152)))
proof
let R11 being non  empty set;
set D73 = ( ModelSP ( Inf_seq R11 ) );
deffunc H18((Element of D73) , (Element of D73)) = ( Until_0 ($1 , $2 , R11) );
L1646: (for B157 , B158 being (BinOp of D73) holds (((for B159 , B160 being (Element of D73) holds ( B157 . (B159 , B160) ) = H18(B159 , B160)) & (for B161 , B162 being (Element of D73) holds ( B158 . (B161 , B162) ) = H18(B161 , B162))) implies B157 = B158)) from BINOP_2:sch 2;
L1647: (for B163 , B164 being (BinOp of D73) holds (((for B165 , B166 being set holds ((B165 in D73 & B166 in D73) implies ( B163 . (B165 , B166) ) = ( Until_0 (B165 , B166 , R11) ))) & (for B167 , B168 being set holds ((B167 in D73 & B168 in D73) implies ( B164 . (B167 , B168) ) = ( Until_0 (B167 , B168 , R11) )))) implies B163 = B164))
proof
let C133 , C134 being (BinOp of D73);
assume L1648: ((for B169 , B170 being set holds ((B169 in D73 & B170 in D73) implies ( C133 . (B169 , B170) ) = ( Until_0 (B169 , B170 , R11) ))) & (for B171 , B172 being set holds ((B171 in D73 & B172 in D73) implies ( C134 . (B171 , B172) ) = ( Until_0 (B171 , B172 , R11) ))));
L1649: ((for B173 , B174 being (Element of D73) holds ( C133 . (B173 , B174) ) = H18(B173 , B174)) & (for B175 , B176 being (Element of D73) holds ( C134 . (B175 , B176) ) = H18(B175 , B176))) by L1648;
thus L1650: thesis by L1649 , L1646;
end;
thus L1651: thesis by L1647;
end;
definition
let C135 being non  empty set;
func Until_ C135 -> (BinOp of ( ModelSP ( Inf_seq C135 ) )) means
:L1652: (for B177 , B178 being set holds ((B177 in ( ModelSP ( Inf_seq C135 ) ) & B178 in ( ModelSP ( Inf_seq C135 ) )) implies ( it . (B177 , B178) ) = ( Until_0 (B177 , B178 , C135) )));
existence
proof
set D74 = ( ModelSP ( Inf_seq C135 ) );
deffunc H19((Element of D74) , (Element of D74)) = ( Until_0 ($1 , $2 , C135) );
consider C136 being (BinOp of D74) such that L1653: (for B179 , B180 being (Element of D74) holds ( C136 . (B179 , B180) ) = H19(B179 , B180)) from BINOP_1:sch 4;
L1654: (for B181 , B182 being set holds ((B181 in D74 & B182 in D74) implies ( C136 . (B181 , B182) ) = ( Until_0 (B181 , B182 , C135) ))) by L1653;
thus L1655: thesis by L1654;
end;
uniqueness by L1645;
end;
L1657: (for R11 being non  empty set holds (for B183 , B184 being (BinOp of ( ModelSP ( Inf_seq R11 ) )) holds (((for B185 , B186 being set holds ((B185 in ( ModelSP ( Inf_seq R11 ) ) & B186 in ( ModelSP ( Inf_seq R11 ) )) implies ( B183 . (B185 , B186) ) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . B185 ) , ( ( Not_ R11 ) . B186 )) ) ))) & (for B187 , B188 being set holds ((B187 in ( ModelSP ( Inf_seq R11 ) ) & B188 in ( ModelSP ( Inf_seq R11 ) )) implies ( B184 . (B187 , B188) ) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . B187 ) , ( ( Not_ R11 ) . B188 )) ) )))) implies B183 = B184)))
proof
let R11 being non  empty set;
set D75 = ( ModelSP ( Inf_seq R11 ) );
deffunc H20((Element of D75) , (Element of D75)) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . $1 ) , ( ( Not_ R11 ) . $2 )) ) );
L1658: (for B189 , B190 being (BinOp of D75) holds (((for B191 , B192 being (Element of D75) holds ( B189 . (B191 , B192) ) = H20(B191 , B192)) & (for B193 , B194 being (Element of D75) holds ( B190 . (B193 , B194) ) = H20(B193 , B194))) implies B189 = B190)) from BINOP_2:sch 2;
L1659: (for B195 , B196 being (BinOp of D75) holds (((for B197 , B198 being set holds ((B197 in D75 & B198 in D75) implies ( B195 . (B197 , B198) ) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . B197 ) , ( ( Not_ R11 ) . B198 )) ) ))) & (for B199 , B200 being set holds ((B199 in D75 & B200 in D75) implies ( B196 . (B199 , B200) ) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . B199 ) , ( ( Not_ R11 ) . B200 )) ) )))) implies B195 = B196))
proof
let C137 , C138 being (BinOp of D75);
assume L1660: ((for B201 , B202 being set holds ((B201 in D75 & B202 in D75) implies ( C137 . (B201 , B202) ) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . B201 ) , ( ( Not_ R11 ) . B202 )) ) ))) & (for B203 , B204 being set holds ((B203 in D75 & B204 in D75) implies ( C138 . (B203 , B204) ) = ( ( Not_ R11 ) . ( ( And_ R11 ) . (( ( Not_ R11 ) . B203 ) , ( ( Not_ R11 ) . B204 )) ) ))));
L1661: ((for B205 , B206 being (Element of D75) holds ( C137 . (B205 , B206) ) = H20(B205 , B206)) & (for B207 , B208 being (Element of D75) holds ( C138 . (B207 , B208) ) = H20(B207 , B208))) by L1660;
thus L1662: thesis by L1661 , L1658;
end;
thus L1663: thesis by L1659;
end;
L1664: (for R11 being non  empty set holds (for B209 , B210 being (BinOp of ( ModelSP ( Inf_seq R11 ) )) holds (((for B211 , B212 being set holds ((B211 in ( ModelSP ( Inf_seq R11 ) ) & B212 in ( ModelSP ( Inf_seq R11 ) )) implies ( B209 . (B211 , B212) ) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . B211 ) , ( ( Not_ R11 ) . B212 )) ) ))) & (for B213 , B214 being set holds ((B213 in ( ModelSP ( Inf_seq R11 ) ) & B214 in ( ModelSP ( Inf_seq R11 ) )) implies ( B210 . (B213 , B214) ) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . B213 ) , ( ( Not_ R11 ) . B214 )) ) )))) implies B209 = B210)))
proof
let R11 being non  empty set;
set D76 = ( ModelSP ( Inf_seq R11 ) );
deffunc H21((Element of D76) , (Element of D76)) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . $1 ) , ( ( Not_ R11 ) . $2 )) ) );
L1665: (for B215 , B216 being (BinOp of D76) holds (((for B217 , B218 being (Element of D76) holds ( B215 . (B217 , B218) ) = H21(B217 , B218)) & (for B219 , B220 being (Element of D76) holds ( B216 . (B219 , B220) ) = H21(B219 , B220))) implies B215 = B216)) from BINOP_2:sch 2;
L1666: (for B221 , B222 being (BinOp of D76) holds (((for B223 , B224 being set holds ((B223 in D76 & B224 in D76) implies ( B221 . (B223 , B224) ) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . B223 ) , ( ( Not_ R11 ) . B224 )) ) ))) & (for B225 , B226 being set holds ((B225 in D76 & B226 in D76) implies ( B222 . (B225 , B226) ) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . B225 ) , ( ( Not_ R11 ) . B226 )) ) )))) implies B221 = B222))
proof
let C139 , C140 being (BinOp of D76);
assume L1667: ((for B227 , B228 being set holds ((B227 in D76 & B228 in D76) implies ( C139 . (B227 , B228) ) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . B227 ) , ( ( Not_ R11 ) . B228 )) ) ))) & (for B229 , B230 being set holds ((B229 in D76 & B230 in D76) implies ( C140 . (B229 , B230) ) = ( ( Not_ R11 ) . ( ( Until_ R11 ) . (( ( Not_ R11 ) . B229 ) , ( ( Not_ R11 ) . B230 )) ) ))));
L1668: ((for B231 , B232 being (Element of D76) holds ( C139 . (B231 , B232) ) = H21(B231 , B232)) & (for B233 , B234 being (Element of D76) holds ( C140 . (B233 , B234) ) = H21(B233 , B234))) by L1667;
thus L1669: thesis by L1668 , L1665;
end;
thus L1670: thesis by L1666;
end;
definition
let C141 being non  empty set;
func Or_ C141 -> (BinOp of ( ModelSP ( Inf_seq C141 ) )) means
:L1671: (for B235 , B236 being set holds ((B235 in ( ModelSP ( Inf_seq C141 ) ) & B236 in ( ModelSP ( Inf_seq C141 ) )) implies ( it . (B235 , B236) ) = ( ( Not_ C141 ) . ( ( And_ C141 ) . (( ( Not_ C141 ) . B235 ) , ( ( Not_ C141 ) . B236 )) ) )));
existence
proof
set D77 = ( ModelSP ( Inf_seq C141 ) );
deffunc H22((Element of D77) , (Element of D77)) = ( ( Not_ C141 ) . ( ( And_ C141 ) . (( ( Not_ C141 ) . $1 ) , ( ( Not_ C141 ) . $2 )) ) );
consider C142 being (BinOp of D77) such that L1672: (for B237 , B238 being (Element of D77) holds ( C142 . (B237 , B238) ) = H22(B237 , B238)) from BINOP_1:sch 4;
L1673: (for B239 , B240 being set holds ((B239 in D77 & B240 in D77) implies ( C142 . (B239 , B240) ) = ( ( Not_ C141 ) . ( ( And_ C141 ) . (( ( Not_ C141 ) . B239 ) , ( ( Not_ C141 ) . B240 )) ) ))) by L1672;
thus L1674: thesis by L1673;
end;
uniqueness by L1657;
func Release_ C141 -> (BinOp of ( ModelSP ( Inf_seq C141 ) )) means
:L1675: (for B241 , B242 being set holds ((B241 in ( ModelSP ( Inf_seq C141 ) ) & B242 in ( ModelSP ( Inf_seq C141 ) )) implies ( it . (B241 , B242) ) = ( ( Not_ C141 ) . ( ( Until_ C141 ) . (( ( Not_ C141 ) . B241 ) , ( ( Not_ C141 ) . B242 )) ) )));
existence
proof
set D78 = ( ModelSP ( Inf_seq C141 ) );
deffunc H23((Element of D78) , (Element of D78)) = ( ( Not_ C141 ) . ( ( Until_ C141 ) . (( ( Not_ C141 ) . $1 ) , ( ( Not_ C141 ) . $2 )) ) );
consider C143 being (BinOp of D78) such that L1676: (for B243 , B244 being (Element of D78) holds ( C143 . (B243 , B244) ) = H23(B243 , B244)) from BINOP_1:sch 4;
L1677: (for B245 , B246 being set holds ((B245 in D78 & B246 in D78) implies ( C143 . (B245 , B246) ) = ( ( Not_ C141 ) . ( ( Until_ C141 ) . (( ( Not_ C141 ) . B245 ) , ( ( Not_ C141 ) . B246 )) ) ))) by L1676;
thus L1678: thesis by L1677;
end;
uniqueness by L1664;
end;
definition
let C144 being non  empty set;
let C145 being non  empty (Subset of ( ModelSP ( Inf_seq C144 ) ));
func Inf_seqModel (C144 , C145) -> LTLModelStr equals
LTLModelStr (# ( ModelSP ( Inf_seq C144 ) ) , C145 , ( And_ C144 ) , ( Or_ C144 ) , ( Not_ C144 ) , ( Next_ C144 ) , ( Until_ C144 ) , ( Release_ C144 ) #);
coherence;
end;
registration
let C146 being non  empty set;
let C147 being non  empty (Subset of ( ModelSP ( Inf_seq C146 ) ));
cluster ( Inf_seqModel (C146 , C147) ) ->  with_basic  strict non  empty;
coherence
proof
thus L1681: (the BasicAssign of ( Inf_seqModel (C146 , C147) )) is non  empty;
thus L1682: thesis;
end;
end;
definition
let C148 being non  empty set;
let C149 being non  empty (Subset of ( ModelSP ( Inf_seq C148 ) ));
let C150 being (Element of ( Inf_seq C148 ));
let C151 being (Assign of ( Inf_seqModel (C148 , C149) ));
pred C150 |= C151
means
:L1684: ( ( Fid (C151 , ( Inf_seq C148 )) ) . C150 ) = ( TRUE )
;end;
notation
let C152 being non  empty set;
let C153 being non  empty (Subset of ( ModelSP ( Inf_seq C152 ) ));
let C154 being (Element of ( Inf_seq C152 ));
let C155 being (Assign of ( Inf_seqModel (C152 , C153) ));
antonym C154 |/= C155 for C154 |= C155;
end;
theorem
L1687: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (for R35 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (( R34 'or' R35 ) = ( 'not' ( ( 'not' R34 ) '&' ( 'not' R35 ) ) ) & ( R34 'R' R35 ) = ( 'not' ( ( 'not' R34 ) 'U' ( 'not' R35 ) ) )))))) by L1671 , L1675;
theorem
L1688: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R33 being (Element of ( Inf_seq R11 )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (R33 |= ( 'not' R34 ) iff R33 |/= R34)))))
proof
let R11 being non  empty set;
let R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) ));
let R33 being (Element of ( Inf_seq R11 ));
let R34 being (Assign of ( Inf_seqModel (R11 , R32) ));
set D79 = ( Inf_seq R11 );
L1689: ( 'not' R34 ) = ( Not_0 (R34 , R11) ) by L1600;
thus L1690: (R33 |= ( 'not' R34 ) implies R33 |/= R34)
proof
assume L1691: R33 |= ( 'not' R34 );
L1692: ( ( Fid (( 'not' R34 ) , D79) ) . R33 ) = ( TRUE ) by L1691 , L1684;
L1693: ( 'not' ( Castboolean ( ( Fid (R34 , D79) ) . R33 ) ) ) = ( TRUE ) by L1692 , L1689 , L1591;
L1694: ( ( Fid (R34 , D79) ) . R33 ) = ( FALSE ) by L1693 , MODELC_1:def 4;
thus L1695: thesis by L1694 , L1684;
end;

assume L1696: R33 |/= R34;
L1697: (not ( ( Fid (R34 , D79) ) . R33 ) = ( TRUE )) by L1696 , L1684;
L1698: (not ( Castboolean ( ( Fid (R34 , D79) ) . R33 ) ) = ( TRUE )) by L1697 , MODELC_1:def 4;
L1699: ( Castboolean ( ( Fid (R34 , D79) ) . R33 ) ) = ( FALSE ) by L1698 , XBOOLEAN:def 3;
L1700: ( 'not' ( Castboolean ( ( Fid (R34 , D79) ) . R33 ) ) ) = ( TRUE ) by L1699;
L1701: ( ( Fid (( 'not' R34 ) , D79) ) . R33 ) = ( TRUE ) by L1700 , L1689 , L1591;
thus L1702: thesis by L1701 , L1684;
end;
theorem
L1703: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R33 being (Element of ( Inf_seq R11 )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (for R35 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (R33 |= ( R34 '&' R35 ) iff (R33 |= R34 & R33 |= R35)))))))
proof
let R11 being non  empty set;
let R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) ));
let R33 being (Element of ( Inf_seq R11 ));
let R34 being (Assign of ( Inf_seqModel (R11 , R32) ));
let R35 being (Assign of ( Inf_seqModel (R11 , R32) ));
set D80 = ( Inf_seq R11 );
L1704: ( R34 '&' R35 ) = ( And_0 (R34 , R35 , R11) ) by L1632;
thus L1705: (R33 |= ( R34 '&' R35 ) implies (R33 |= R34 & R33 |= R35))
proof
assume L1706: R33 |= ( R34 '&' R35 );
L1707: ( ( Fid (( And_0 (R34 , R35 , R11) ) , D80) ) . R33 ) = ( TRUE ) by L1706 , L1704 , L1684;
L1708: ( ( Castboolean ( ( Fid (R34 , D80) ) . R33 ) ) '&' ( Castboolean ( ( Fid (R35 , D80) ) . R33 ) ) ) = ( TRUE ) by L1707 , L1619;
L1709: ( Castboolean ( ( Fid (R35 , D80) ) . R33 ) ) = ( TRUE ) by L1708 , XBOOLEAN:101;
L1710: ( ( Fid (R35 , D80) ) . R33 ) = ( TRUE ) by L1709 , MODELC_1:def 4;
L1711: ( Castboolean ( ( Fid (R34 , D80) ) . R33 ) ) = ( TRUE ) by L1708 , XBOOLEAN:101;
L1712: ( ( Fid (R34 , D80) ) . R33 ) = ( TRUE ) by L1711 , MODELC_1:def 4;
thus L1713: thesis by L1712 , L1710 , L1684;
end;

assume L1714: (R33 |= R34 & R33 |= R35);
L1715: (( ( Fid (R34 , D80) ) . R33 ) = ( TRUE ) & ( ( Fid (R35 , D80) ) . R33 ) = ( TRUE )) by L1714 , L1684;
L1716: ( ( Castboolean ( ( Fid (R34 , D80) ) . R33 ) ) '&' ( Castboolean ( ( Fid (R35 , D80) ) . R33 ) ) ) = ( TRUE ) by L1715 , MODELC_1:def 4;
L1717: ( ( Fid (( R34 '&' R35 ) , D80) ) . R33 ) = ( TRUE ) by L1716 , L1704 , L1619;
thus L1718: thesis by L1717 , L1684;
end;
theorem
L1719: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R33 being (Element of ( Inf_seq R11 )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (R33 |= ( 'X' R34 ) iff ( Shift (R33 , 1) ) |= R34)))))
proof
let R11 being non  empty set;
let R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) ));
let R33 being (Element of ( Inf_seq R11 ));
let R34 being (Assign of ( Inf_seqModel (R11 , R32) ));
set D81 = ( Inf_seq R11 );
set D82 = ( Shift (R33 , 1) );
set D83 = ( Shift (R33 , 1 , R11) );
L1720: ( 'X' R34 ) = ( Next_0 (R34 , R11) ) by L1615;
thus L1721: (R33 |= ( 'X' R34 ) implies D82 |= R34)
proof
assume L1722: R33 |= ( 'X' R34 );
L1723: ( ( Fid (( Next_0 (R34 , R11) ) , D81) ) . R33 ) = ( TRUE ) by L1722 , L1720 , L1684;
L1724: ( Next_univ (R33 , ( Fid (R34 , D81) )) ) = ( TRUE ) by L1723 , L1606;
L1725: ( ( Fid (R34 , D81) ) . D83 ) = ( TRUE ) by L1724 , L1604;
thus L1726: thesis by L1725 , L1684;
end;

assume L1727: D82 |= R34;
L1728: ( ( Fid (R34 , D81) ) . D82 ) = ( TRUE ) by L1727 , L1684;
L1729: ( Next_univ (R33 , ( Fid (R34 , D81) )) ) = ( TRUE ) by L1728 , L1604;
L1730: ( ( Fid (( 'X' R34 ) , D81) ) . R33 ) = ( TRUE ) by L1729 , L1720 , L1606;
thus L1731: thesis by L1730 , L1684;
end;
theorem
L1732: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R33 being (Element of ( Inf_seq R11 )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (for R35 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (R33 |= ( R34 'U' R35 ) iff (ex B247 being Nat st ((for B248 being Nat holds (B248 < B247 implies ( Shift (R33 , B248) ) |= R34)) & ( Shift (R33 , B247) ) |= R35))))))))
proof
let R11 being non  empty set;
let R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) ));
let R33 being (Element of ( Inf_seq R11 ));
let R34 being (Assign of ( Inf_seqModel (R11 , R32) ));
let R35 being (Assign of ( Inf_seqModel (R11 , R32) ));
set D84 = ( Inf_seq R11 );
L1733: ( R34 'U' R35 ) = ( Until_0 (R34 , R35 , R11) ) by L1652;
L1734: ((ex B249 being Nat st ((for B250 being Nat holds (B250 < B249 implies ( Shift (R33 , B250) ) |= R34)) & ( Shift (R33 , B249) ) |= R35)) implies R33 |= ( R34 'U' R35 ))
proof
assume L1735: (ex B251 being Nat st ((for B252 being Nat holds (B252 < B251 implies ( Shift (R33 , B252) ) |= R34)) & ( Shift (R33 , B251) ) |= R35));
L1736: (ex B253 being Nat st ((for B254 being Nat holds (B254 < B253 implies ( ( Fid (R34 , D84) ) . ( Shift (R33 , B254 , R11) ) ) = ( TRUE ))) & ( ( Fid (R35 , D84) ) . ( Shift (R33 , B253 , R11) ) ) = ( TRUE )))
proof
consider C156 being Nat such that L1737: (for B255 being Nat holds (B255 < C156 implies ( Shift (R33 , B255) ) |= R34)) and L1738: ( Shift (R33 , C156) ) |= R35 by L1735;
take C156;
L1739: (for B256 being Nat holds (B256 < C156 implies ( ( Fid (R34 , D84) ) . ( Shift (R33 , B256 , R11) ) ) = ( TRUE )))
proof
let C157 being Nat;
assume L1740: C157 < C156;
L1741: ( Shift (R33 , C157) ) |= R34 by L1740 , L1737;
thus L1742: thesis by L1741 , L1684;
end;
thus L1743: thesis by L1739 , L1738 , L1684;
end;
L1744: ( Until_univ (R33 , ( Fid (R34 , D84) ) , ( Fid (R35 , D84) ) , R11) ) = ( TRUE ) by L1736 , L1637;
L1745: ( ( Fid (( R34 'U' R35 ) , D84) ) . R33 ) = ( TRUE ) by L1744 , L1733 , L1639;
thus L1746: thesis by L1745 , L1684;
end;
L1747: (R33 |= ( R34 'U' R35 ) implies (ex B257 being Nat st ((for B258 being Nat holds (B258 < B257 implies ( Shift (R33 , B258) ) |= R34)) & ( Shift (R33 , B257) ) |= R35)))
proof
assume L1748: R33 |= ( R34 'U' R35 );
L1749: ( ( Fid (( Until_0 (R34 , R35 , R11) ) , D84) ) . R33 ) = ( TRUE ) by L1748 , L1733 , L1684;
L1750: ( Until_univ (R33 , ( Fid (R34 , D84) ) , ( Fid (R35 , D84) ) , R11) ) = ( TRUE ) by L1749 , L1639;
consider C158 being Nat such that L1751: (for B259 being Nat holds (B259 < C158 implies ( ( Fid (R34 , D84) ) . ( Shift (R33 , B259 , R11) ) ) = ( TRUE ))) and L1752: ( ( Fid (R35 , D84) ) . ( Shift (R33 , C158 , R11) ) ) = ( TRUE ) by L1750 , L1637;
take C158;
L1753: (for B260 being Nat holds (B260 < C158 implies ( Shift (R33 , B260) ) |= R34))
proof
let C159 being Nat;
assume that
L1754: C159 < C158;
set D85 = ( Shift (R33 , C159) );
L1755: ( ( Fid (R34 , D84) ) . D85 ) = ( TRUE ) by L1751 , L1754;
thus L1756: thesis by L1755 , L1684;
end;
thus L1757: thesis by L1753 , L1752 , L1684;
end;
thus L1758: thesis by L1747 , L1734;
end;
theorem
L1759: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R33 being (Element of ( Inf_seq R11 )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (for R35 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (R33 |= ( R34 'or' R35 ) iff (R33 |= R34 or R33 |= R35)))))))
proof
let R11 being non  empty set;
let R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) ));
let R33 being (Element of ( Inf_seq R11 ));
let R34 being (Assign of ( Inf_seqModel (R11 , R32) ));
let R35 being (Assign of ( Inf_seqModel (R11 , R32) ));
L1760: (R33 |= ( R34 'or' R35 ) iff R33 |= ( 'not' ( ( 'not' R34 ) '&' ( 'not' R35 ) ) )) by L1671;
L1761: (R33 |= ( R34 'or' R35 ) iff (not R33 |= ( ( 'not' R34 ) '&' ( 'not' R35 ) ))) by L1760 , L1688;
L1762: (R33 |= ( R34 'or' R35 ) iff ((not R33 |= ( 'not' R34 )) or (not R33 |= ( 'not' R35 )))) by L1761 , L1703;
thus L1763: thesis by L1762 , L1688;
end;
theorem
L1764: (for R11 being non  empty set holds (for R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) )) holds (for R33 being (Element of ( Inf_seq R11 )) holds (for R34 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (for R35 being (Assign of ( Inf_seqModel (R11 , R32) )) holds (R33 |= ( R34 'R' R35 ) iff (for B261 being Nat holds ((for B262 being Nat holds (B262 < B261 implies ( Shift (R33 , B262) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B261) ) |= R35))))))))
proof
let R11 being non  empty set;
let R32 being non  empty (Subset of ( ModelSP ( Inf_seq R11 ) ));
let R33 being (Element of ( Inf_seq R11 ));
let R34 being (Assign of ( Inf_seqModel (R11 , R32) ));
let R35 being (Assign of ( Inf_seqModel (R11 , R32) ));
L1765: ((for B263 being Nat holds ((for B264 being Nat holds (B264 < B263 implies ( Shift (R33 , B264) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B263) ) |/= ( 'not' R35 ))) implies (for B265 being Nat holds ((for B266 being Nat holds (B266 < B265 implies ( Shift (R33 , B266) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B265) ) |= R35)))
proof
assume L1766: (for B267 being Nat holds ((for B268 being Nat holds (B268 < B267 implies ( Shift (R33 , B268) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B267) ) |/= ( 'not' R35 )));
L1767: (for B269 being Nat holds ((for B270 being Nat holds (B270 < B269 implies ( Shift (R33 , B270) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B269) ) |= R35))
proof
let C160 being Nat;
L1768: ((for B271 being Nat holds (B271 < C160 implies ( Shift (R33 , B271) ) |= ( 'not' R34 ))) implies ( Shift (R33 , C160) ) |/= ( 'not' R35 )) by L1766;
thus L1769: thesis by L1768 , L1688;
end;
thus L1770: thesis by L1767;
end;
L1771: ((for B272 being Nat holds ((for B273 being Nat holds (B273 < B272 implies ( Shift (R33 , B273) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B272) ) |= R35)) implies (for B274 being Nat holds ((for B275 being Nat holds (B275 < B274 implies ( Shift (R33 , B275) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B274) ) |/= ( 'not' R35 ))))
proof
assume L1772: (for B276 being Nat holds ((for B277 being Nat holds (B277 < B276 implies ( Shift (R33 , B277) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B276) ) |= R35));
L1773: (for B278 being Nat holds ((for B279 being Nat holds (B279 < B278 implies ( Shift (R33 , B279) ) |= ( 'not' R34 ))) implies ( Shift (R33 , B278) ) |/= ( 'not' R35 )))
proof
let C161 being Nat;
L1774: ((for B280 being Nat holds (B280 < C161 implies ( Shift (R33 , B280) ) |= ( 'not' R34 ))) implies ( Shift (R33 , C161) ) |= R35) by L1772;
thus L1775: thesis by L1774 , L1688;
end;
thus L1776: thesis by L1773;
end;
L1777: (R33 |= ( R34 'R' R35 ) iff R33 |= ( 'not' ( ( 'not' R34 ) 'U' ( 'not' R35 ) ) )) by L1675;
L1778: (R33 |= ( R34 'R' R35 ) iff (not R33 |= ( ( 'not' R34 ) 'U' ( 'not' R35 ) ))) by L1777 , L1688;
thus L1779: thesis by L1778 , L1765 , L1771 , L1732;
end;
definition
func AtomicFamily -> non  empty set equals
( bool ( atomic_LTL ) );
correctness;
end;
definition
let C162 , C163 being set;
func AtomicFunc (C162 , C163) -> (Element of ( BOOLEAN )) equals
:L1781: ( TRUE ) if (C163 in ( Inf_seq ( AtomicFamily ) ) & C162 in ( ( CastSeq (C163 , ( AtomicFamily )) ) . ( 0 ) )) otherwise ( FALSE );
correctness;
end;
L1783: (for R11 being non  empty set holds (for B281 , B282 being set holds ((B281 in ( ModelSP R11 ) & B282 in ( ModelSP R11 )) implies (( Fid (B281 , R11) ) = ( Fid (B282 , R11) ) implies B281 = B282))))
proof
let R11 being non  empty set;
let C164 , C165 being set;
assume that
L1784: C164 in ( ModelSP R11 )
and
L1785: C165 in ( ModelSP R11 );
assume L1786: ( Fid (C164 , R11) ) = ( Fid (C165 , R11) );
L1787: ( Fid (C164 , R11) ) = C164 by L1784 , MODELC_1:def 41;
thus L1788: thesis by L1787 , L1785 , L1786 , MODELC_1:def 41;
end;
definition
let C166 being set;
func AtomicAsgn C166 -> (Element of ( ModelSP ( Inf_seq ( AtomicFamily ) ) )) means
:L1789: (for B283 being set holds (B283 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (it , ( Inf_seq ( AtomicFamily ) )) ) . B283 ) = ( AtomicFunc (C166 , B283) )));
existence
proof
deffunc H24(set) = ( AtomicFunc (C166 , $1) );
L1790: (for B284 being set holds (B284 in ( Inf_seq ( AtomicFamily ) ) implies H24(B284) in ( BOOLEAN )));
consider C167 being (Function of ( Inf_seq ( AtomicFamily ) ) , ( BOOLEAN )) such that L1791: (for B285 being set holds (B285 in ( Inf_seq ( AtomicFamily ) ) implies ( C167 . B285 ) = H24(B285))) from FUNCT_2:sch 2(L1790);
reconsider D86 = C167 as (Element of ( Funcs (( Inf_seq ( AtomicFamily ) ) , ( BOOLEAN )) )) by FUNCT_2:8;
reconsider D87 = D86 as (Element of ( ModelSP ( Inf_seq ( AtomicFamily ) ) )) by MODELC_1:def 40;
take D87;
L1792: (for B286 being set holds (B286 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (D87 , ( Inf_seq ( AtomicFamily ) )) ) . B286 ) = ( AtomicFunc (C166 , B286) )))
proof
reconsider D88 = D87 as (Function of ( Inf_seq ( AtomicFamily ) ) , ( BOOLEAN ));
let C168 being set;
assume that
L1793: C168 in ( Inf_seq ( AtomicFamily ) );
L1794: ( ( Fid (D88 , ( Inf_seq ( AtomicFamily ) )) ) . C168 ) = ( D88 . C168 ) by MODELC_1:def 41
.= ( AtomicFunc (C166 , C168) ) by L1791 , L1793;
thus L1795: thesis by L1794;
end;
thus L1796: thesis by L1792;
end;
uniqueness
proof
L1797: (for B287 , B288 being (Element of ( ModelSP ( Inf_seq ( AtomicFamily ) ) )) holds (((for B289 being set holds (B289 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (B287 , ( Inf_seq ( AtomicFamily ) )) ) . B289 ) = ( AtomicFunc (C166 , B289) ))) & (for B290 being set holds (B290 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (B288 , ( Inf_seq ( AtomicFamily ) )) ) . B290 ) = ( AtomicFunc (C166 , B290) )))) implies B287 = B288))
proof
let C169 , C170 being (Element of ( ModelSP ( Inf_seq ( AtomicFamily ) ) ));
assume that
L1798: (for B291 being set holds (B291 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (C169 , ( Inf_seq ( AtomicFamily ) )) ) . B291 ) = ( AtomicFunc (C166 , B291) )))
and
L1799: (for B292 being set holds (B292 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (C170 , ( Inf_seq ( AtomicFamily ) )) ) . B292 ) = ( AtomicFunc (C166 , B292) )));
L1800: (for B293 being set holds (B293 in ( Inf_seq ( AtomicFamily ) ) implies ( ( Fid (C169 , ( Inf_seq ( AtomicFamily ) )) ) . B293 ) = ( ( Fid (C170 , ( Inf_seq ( AtomicFamily ) )) ) . B293 )))
proof
let C171 being set;
assume that
L1801: C171 in ( Inf_seq ( AtomicFamily ) );
L1802: ( ( Fid (C169 , ( Inf_seq ( AtomicFamily ) )) ) . C171 ) = ( AtomicFunc (C166 , C171) ) by L1798 , L1801;
thus L1803: thesis by L1802 , L1799 , L1801;
end;
thus L1804: thesis by L1800 , L1783 , FUNCT_2:12;
end;
thus L1805: thesis by L1797;
end;
end;
definition
func AtomicBasicAsgn -> non  empty (Subset of ( ModelSP ( Inf_seq ( AtomicFamily ) ) )) equals
{ B294 where B294 is (Element of ( ModelSP ( Inf_seq ( AtomicFamily ) ) )) : (ex B295 being set st B294 = ( AtomicAsgn B295 )) };
correctness
proof
set D89 = ( ModelSP ( Inf_seq ( AtomicFamily ) ) );
set D90 = ( AtomicAsgn ( {} ) );
set D91 = { B296 where B296 is (Element of ( ModelSP ( Inf_seq ( AtomicFamily ) ) )) : (ex B297 being set st B296 = ( AtomicAsgn B297 )) };
L1807: D91 c= D89
proof
let C172 being set;
assume L1808: C172 in D91;
L1809: (ex B298 being (Element of D89) st (C172 = B298 & (ex B299 being set st B298 = ( AtomicAsgn B299 )))) by L1808;
thus L1810: thesis by L1809;
end;
L1811: D90 in D91;
thus L1812: thesis by L1811 , L1807;
end;
end;
definition
func AtomicKai -> (Function of ( atomic_LTL ) , (the BasicAssign of ( Inf_seqModel (( AtomicFamily ) , ( AtomicBasicAsgn )) ))) means
:L1814: (for B300 being set holds (B300 in ( atomic_LTL ) implies ( it . B300 ) = ( AtomicAsgn B300 )));
existence
proof
deffunc H25(set) = ( AtomicAsgn $1 );
L1815: (for B301 being set holds (B301 in ( atomic_LTL ) implies H25(B301) in (the BasicAssign of ( Inf_seqModel (( AtomicFamily ) , ( AtomicBasicAsgn )) ))));
consider C173 being (Function of ( atomic_LTL ) , (the BasicAssign of ( Inf_seqModel (( AtomicFamily ) , ( AtomicBasicAsgn )) ))) such that L1816: (for B302 being set holds (B302 in ( atomic_LTL ) implies ( C173 . B302 ) = H25(B302))) from FUNCT_2:sch 2(L1815);
take C173;
thus L1817: thesis by L1816;
end;
uniqueness
proof
L1818: (for B303 , B304 being (Function of ( atomic_LTL ) , (the BasicAssign of ( Inf_seqModel (( AtomicFamily ) , ( AtomicBasicAsgn )) ))) holds (((for B305 being set holds (B305 in ( atomic_LTL ) implies ( B303 . B305 ) = ( AtomicAsgn B305 ))) & (for B306 being set holds (B306 in ( atomic_LTL ) implies ( B304 . B306 ) = ( AtomicAsgn B306 )))) implies B303 = B304))
proof
let C174 , C175 being (Function of ( atomic_LTL ) , (the BasicAssign of ( Inf_seqModel (( AtomicFamily ) , ( AtomicBasicAsgn )) )));
assume that
L1819: (for B307 being set holds (B307 in ( atomic_LTL ) implies ( C174 . B307 ) = ( AtomicAsgn B307 )))
and
L1820: (for B308 being set holds (B308 in ( atomic_LTL ) implies ( C175 . B308 ) = ( AtomicAsgn B308 )));
L1821: (for B309 being set holds (B309 in ( atomic_LTL ) implies ( C174 . B309 ) = ( C175 . B309 )))
proof
let C176 being set;
assume that
L1822: C176 in ( atomic_LTL );
L1823: ( C174 . C176 ) = ( AtomicAsgn C176 ) by L1819 , L1822;
thus L1824: thesis by L1823 , L1820 , L1822;
end;
thus L1825: thesis by L1821 , FUNCT_2:12;
end;
thus L1826: thesis by L1818;
end;
end;
definition
let C177 being (Element of ( Inf_seq ( AtomicFamily ) ));
let C178 being LTL-formula;
pred C177 |= C178
means
:L1828: C177 |= ( Evaluate (C178 , ( AtomicKai )) )
;end;
notation
let C179 being (Element of ( Inf_seq ( AtomicFamily ) ));
let C180 being LTL-formula;
antonym C179 |/= C180 for C179 |= C180;
end;
definition
let C181 being (Element of ( Inf_seq ( AtomicFamily ) ));
let C182 being (Subset of ( LTL_WFF ));
pred C181 |= C182
means
:L1831: (for B310 being LTL-formula holds (B310 in C182 implies C181 |= B310))
;end;
notation
let C183 being (Element of ( Inf_seq ( AtomicFamily ) ));
let C184 being (Subset of ( LTL_WFF ));
antonym C183 |/= C184 for C183 |= C184;
end;
definition
let C185 being (Subset of ( LTL_WFF ));
func 'X' C185 -> (Subset of ( LTL_WFF )) equals
{ B311 where B311 is LTL-formula : (ex B312 being LTL-formula st (B312 in C185 & B311 = ( 'X' B312 ))) };
correctness
proof
set D92 = { B313 where B313 is LTL-formula : (ex B314 being LTL-formula st (B314 in C185 & B313 = ( 'X' B314 ))) };
L1834: D92 c= ( LTL_WFF )
proof
let C186 being set;
assume L1835: C186 in D92;
L1836: (ex B315 being LTL-formula st (C186 = B315 & (ex B316 being LTL-formula st (B316 in C185 & B315 = ( 'X' B316 ))))) by L1835;
thus L1837: thesis by L1836 , L89;
end;
thus L1838: thesis by L1834;
end;
end;
theorem
L1840: (for R18 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R18 is  atomic implies (R36 |= R18 iff R18 in ( ( CastSeq (R36 , ( AtomicFamily )) ) . ( 0 ) )))))
proof
let R18 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
assume L1841: R18 is  atomic;
L1842: R18 in ( atomic_LTL ) by L1841;
L1843: (R36 |= R18 iff R36 |= ( Evaluate (R18 , ( AtomicKai )) )) by L1828;
L1844: (ex B317 being (Function of ( LTL_WFF ) , (the carrier of ( Inf_seqModel (( AtomicFamily ) , ( AtomicBasicAsgn )) ))) st (B317 is-Evaluation-for ( AtomicKai ) & ( Evaluate (R18 , ( AtomicKai )) ) = ( B317 . R18 ))) by L1495;
L1845: ( Evaluate (R18 , ( AtomicKai )) ) = ( ( AtomicKai ) . R18 ) by L1844 , L1841 , L1095
.= ( AtomicAsgn R18 ) by L1842 , L1814;
L1846: (R36 |= R18 iff ( ( Fid (( AtomicAsgn R18 ) , ( Inf_seq ( AtomicFamily ) )) ) . R36 ) = ( TRUE )) by L1845 , L1843 , L1684;
L1847: (R36 |= R18 iff ( AtomicFunc (R18 , R36) ) = ( TRUE )) by L1846 , L1789;
thus L1848: thesis by L1847 , L1781;
end;
theorem
L1849: (for R18 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( 'not' R18 ) iff R36 |/= R18)))
proof
let R18 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1850: (R36 |= ( 'not' R18 ) iff R36 |= ( Evaluate (( 'not' R18 ) , ( AtomicKai )) )) by L1828;
L1851: (R36 |= ( 'not' R18 ) iff R36 |= ( 'not' ( Evaluate (R18 , ( AtomicKai )) ) )) by L1850 , L1503;
L1852: (R36 |= ( 'not' R18 ) iff R36 |/= ( Evaluate (R18 , ( AtomicKai )) )) by L1851 , L1688;
thus L1853: thesis by L1852 , L1828;
end;
theorem
L1854: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 '&' R20 ) iff (R36 |= R19 & R36 |= R20)))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1855: (R36 |= ( R19 '&' R20 ) iff R36 |= ( Evaluate (( R19 '&' R20 ) , ( AtomicKai )) )) by L1828;
L1856: (R36 |= ( R19 '&' R20 ) iff R36 |= ( ( Evaluate (R19 , ( AtomicKai )) ) '&' ( Evaluate (R20 , ( AtomicKai )) ) )) by L1855 , L1510;
L1857: (R36 |= ( R19 '&' R20 ) iff (R36 |= ( Evaluate (R19 , ( AtomicKai )) ) & R36 |= ( Evaluate (R20 , ( AtomicKai )) ))) by L1856 , L1703;
thus L1858: thesis by L1857 , L1828;
end;
theorem
L1859: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 'or' R20 ) iff (R36 |= R19 or R36 |= R20)))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1860: (R36 |= ( R19 'or' R20 ) iff R36 |= ( Evaluate (( R19 'or' R20 ) , ( AtomicKai )) )) by L1828;
L1861: (R36 |= ( R19 'or' R20 ) iff R36 |= ( ( Evaluate (R19 , ( AtomicKai )) ) 'or' ( Evaluate (R20 , ( AtomicKai )) ) )) by L1860 , L1522;
L1862: (R36 |= ( R19 'or' R20 ) iff (R36 |= ( Evaluate (R19 , ( AtomicKai )) ) or R36 |= ( Evaluate (R20 , ( AtomicKai )) ))) by L1861 , L1759;
thus L1863: thesis by L1862 , L1828;
end;
theorem
L1864: (for R18 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( 'X' R18 ) iff ( Shift (R36 , 1) ) |= R18)))
proof
let R18 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1865: (R36 |= ( 'X' R18 ) iff R36 |= ( Evaluate (( 'X' R18 ) , ( AtomicKai )) )) by L1828;
L1866: (R36 |= ( 'X' R18 ) iff R36 |= ( 'X' ( Evaluate (R18 , ( AtomicKai )) ) )) by L1865 , L1534;
L1867: (R36 |= ( 'X' R18 ) iff ( Shift (R36 , 1) ) |= ( Evaluate (R18 , ( AtomicKai )) )) by L1866 , L1719;
thus L1868: thesis by L1867 , L1828;
end;
theorem
L1869: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 'U' R20 ) iff (ex B318 being Nat st ((for B319 being Nat holds (B319 < B318 implies ( Shift (R36 , B319) ) |= R19)) & ( Shift (R36 , B318) ) |= R20))))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1870: ((ex B320 being Nat st ((for B321 being Nat holds (B321 < B320 implies ( Shift (R36 , B321) ) |= ( Evaluate (R19 , ( AtomicKai )) ))) & ( Shift (R36 , B320) ) |= ( Evaluate (R20 , ( AtomicKai )) ))) implies (ex B322 being Nat st ((for B323 being Nat holds (B323 < B322 implies ( Shift (R36 , B323) ) |= R19)) & ( Shift (R36 , B322) ) |= R20)))
proof
assume L1871: (ex B324 being Nat st ((for B325 being Nat holds (B325 < B324 implies ( Shift (R36 , B325) ) |= ( Evaluate (R19 , ( AtomicKai )) ))) & ( Shift (R36 , B324) ) |= ( Evaluate (R20 , ( AtomicKai )) )));
consider C187 being Nat such that L1872: (for B326 being Nat holds (B326 < C187 implies ( Shift (R36 , B326) ) |= ( Evaluate (R19 , ( AtomicKai )) ))) and L1873: ( Shift (R36 , C187) ) |= ( Evaluate (R20 , ( AtomicKai )) ) by L1871;
take C187;
L1874: (for B327 being Nat holds (B327 < C187 implies ( Shift (R36 , B327) ) |= R19))
proof
let C188 being Nat;
assume L1875: C188 < C187;
L1876: ( Shift (R36 , C188) ) |= ( Evaluate (R19 , ( AtomicKai )) ) by L1875 , L1872;
thus L1877: thesis by L1876 , L1828;
end;
thus L1878: thesis by L1874 , L1873 , L1828;
end;
L1879: ((ex B328 being Nat st ((for B329 being Nat holds (B329 < B328 implies ( Shift (R36 , B329) ) |= R19)) & ( Shift (R36 , B328) ) |= R20)) implies (ex B330 being Nat st ((for B331 being Nat holds (B331 < B330 implies ( Shift (R36 , B331) ) |= ( Evaluate (R19 , ( AtomicKai )) ))) & ( Shift (R36 , B330) ) |= ( Evaluate (R20 , ( AtomicKai )) ))))
proof
assume L1880: (ex B332 being Nat st ((for B333 being Nat holds (B333 < B332 implies ( Shift (R36 , B333) ) |= R19)) & ( Shift (R36 , B332) ) |= R20));
consider C189 being Nat such that L1881: (for B334 being Nat holds (B334 < C189 implies ( Shift (R36 , B334) ) |= R19)) and L1882: ( Shift (R36 , C189) ) |= R20 by L1880;
take C189;
L1883: (for B335 being Nat holds (B335 < C189 implies ( Shift (R36 , B335) ) |= ( Evaluate (R19 , ( AtomicKai )) )))
proof
let C190 being Nat;
assume L1884: C190 < C189;
L1885: ( Shift (R36 , C190) ) |= R19 by L1884 , L1881;
thus L1886: thesis by L1885 , L1828;
end;
thus L1887: thesis by L1883 , L1882 , L1828;
end;
L1888: (R36 |= ( R19 'U' R20 ) iff R36 |= ( Evaluate (( R19 'U' R20 ) , ( AtomicKai )) )) by L1828;
L1889: (R36 |= ( R19 'U' R20 ) iff R36 |= ( ( Evaluate (R19 , ( AtomicKai )) ) 'U' ( Evaluate (R20 , ( AtomicKai )) ) )) by L1888 , L1542;
thus L1890: thesis by L1889 , L1870 , L1879 , L1732;
end;
theorem
L1891: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 'R' R20 ) iff (for B336 being Nat holds ((for B337 being Nat holds (B337 < B336 implies ( Shift (R36 , B337) ) |= ( 'not' R19 ))) implies ( Shift (R36 , B336) ) |= R20))))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1892: ((for B338 being Nat holds ((for B339 being Nat holds (B339 < B338 implies ( Shift (R36 , B339) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) ))) implies ( Shift (R36 , B338) ) |= ( Evaluate (R20 , ( AtomicKai )) ))) implies (for B340 being Nat holds ((for B341 being Nat holds (B341 < B340 implies ( Shift (R36 , B341) ) |= ( 'not' R19 ))) implies ( Shift (R36 , B340) ) |= R20)))
proof
assume L1893: (for B342 being Nat holds ((for B343 being Nat holds (B343 < B342 implies ( Shift (R36 , B343) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) ))) implies ( Shift (R36 , B342) ) |= ( Evaluate (R20 , ( AtomicKai )) )));
L1894: (for B344 being Nat holds ((for B345 being Nat holds (B345 < B344 implies ( Shift (R36 , B345) ) |= ( 'not' R19 ))) implies ( Shift (R36 , B344) ) |= R20))
proof
let C191 being Nat;
L1895: ((for B346 being Nat holds (B346 < C191 implies ( Shift (R36 , B346) ) |= ( 'not' R19 ))) implies ( Shift (R36 , C191) ) |= R20)
proof
assume L1896: (for B347 being Nat holds (B347 < C191 implies ( Shift (R36 , B347) ) |= ( 'not' R19 )));
L1897: (for B348 being Nat holds (B348 < C191 implies ( Shift (R36 , B348) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) )))
proof
let C192 being Nat;
assume L1898: C192 < C191;
L1899: ( Shift (R36 , C192) ) |= ( 'not' R19 ) by L1898 , L1896;
L1900: ( Shift (R36 , C192) ) |= ( Evaluate (( 'not' R19 ) , ( AtomicKai )) ) by L1899 , L1828;
thus L1901: thesis by L1900 , L1503;
end;
L1902: ( Shift (R36 , C191) ) |= ( Evaluate (R20 , ( AtomicKai )) ) by L1897 , L1893;
thus L1903: thesis by L1902 , L1828;
end;
thus L1904: thesis by L1895;
end;
thus L1905: thesis by L1894;
end;
L1906: ((for B349 being Nat holds ((for B350 being Nat holds (B350 < B349 implies ( Shift (R36 , B350) ) |= ( 'not' R19 ))) implies ( Shift (R36 , B349) ) |= R20)) implies (for B351 being Nat holds ((for B352 being Nat holds (B352 < B351 implies ( Shift (R36 , B352) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) ))) implies ( Shift (R36 , B351) ) |= ( Evaluate (R20 , ( AtomicKai )) ))))
proof
assume L1907: (for B353 being Nat holds ((for B354 being Nat holds (B354 < B353 implies ( Shift (R36 , B354) ) |= ( 'not' R19 ))) implies ( Shift (R36 , B353) ) |= R20));
L1908: (for B355 being Nat holds ((for B356 being Nat holds (B356 < B355 implies ( Shift (R36 , B356) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) ))) implies ( Shift (R36 , B355) ) |= ( Evaluate (R20 , ( AtomicKai )) )))
proof
let C193 being Nat;
L1909: ((for B357 being Nat holds (B357 < C193 implies ( Shift (R36 , B357) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) ))) implies ( Shift (R36 , C193) ) |= ( Evaluate (R20 , ( AtomicKai )) ))
proof
assume L1910: (for B358 being Nat holds (B358 < C193 implies ( Shift (R36 , B358) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) )));
L1911: (for B359 being Nat holds (B359 < C193 implies ( Shift (R36 , B359) ) |= ( 'not' R19 )))
proof
let C194 being Nat;
assume L1912: C194 < C193;
L1913: ( Shift (R36 , C194) ) |= ( 'not' ( Evaluate (R19 , ( AtomicKai )) ) ) by L1912 , L1910;
L1914: ( Shift (R36 , C194) ) |= ( Evaluate (( 'not' R19 ) , ( AtomicKai )) ) by L1913 , L1503;
thus L1915: thesis by L1914 , L1828;
end;
L1916: ( Shift (R36 , C193) ) |= R20 by L1911 , L1907;
thus L1917: thesis by L1916 , L1828;
end;
thus L1918: thesis by L1909;
end;
thus L1919: thesis by L1908;
end;
L1920: (R36 |= ( R19 'R' R20 ) iff R36 |= ( Evaluate (( R19 'R' R20 ) , ( AtomicKai )) )) by L1828;
L1921: (R36 |= ( R19 'R' R20 ) iff R36 |= ( ( Evaluate (R19 , ( AtomicKai )) ) 'R' ( Evaluate (R20 , ( AtomicKai )) ) )) by L1920 , L1554;
thus L1922: thesis by L1921 , L1892 , L1906 , L1764;
end;
theorem
L1923: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( 'not' ( R19 'or' R20 ) ) iff R36 |= ( ( 'not' R19 ) '&' ( 'not' R20 ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1924: (R36 |= ( 'not' ( R19 'or' R20 ) ) iff R36 |/= ( R19 'or' R20 )) by L1849;
L1925: (R36 |= ( 'not' ( R19 'or' R20 ) ) iff (not (R36 |= R19 or R36 |= R20))) by L1924 , L1859;
L1926: (R36 |= ( 'not' ( R19 'or' R20 ) ) iff (R36 |= ( 'not' R19 ) & R36 |= ( 'not' R20 ))) by L1925 , L1849;
thus L1927: thesis by L1926 , L1854;
end;
theorem
L1928: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( 'not' ( R19 '&' R20 ) ) iff R36 |= ( ( 'not' R19 ) 'or' ( 'not' R20 ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1929: (R36 |= ( 'not' ( R19 '&' R20 ) ) iff R36 |/= ( R19 '&' R20 )) by L1849;
L1930: (R36 |= ( 'not' ( R19 '&' R20 ) ) iff (not (R36 |= R19 & R36 |= R20))) by L1929 , L1854;
L1931: (R36 |= ( 'not' ( R19 '&' R20 ) ) iff (R36 |= ( 'not' R19 ) or R36 |= ( 'not' R20 ))) by L1930 , L1849;
thus L1932: thesis by L1931 , L1859;
end;
theorem
L1933: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 'R' R20 ) iff R36 |= ( 'not' ( ( 'not' R19 ) 'U' ( 'not' R20 ) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
set D93 = ( Evaluate (R19 , ( AtomicKai )) );
set D94 = ( Evaluate (R20 , ( AtomicKai )) );
set D95 = ( 'not' R19 );
set D96 = ( 'not' R20 );
L1934: (R36 |= ( D95 'U' D96 ) iff R36 |= ( Evaluate (( D95 'U' D96 ) , ( AtomicKai )) )) by L1828;
L1935: (R36 |= ( R19 'R' R20 ) iff R36 |= ( Evaluate (( R19 'R' R20 ) , ( AtomicKai )) )) by L1828;
L1936: (R36 |= ( R19 'R' R20 ) iff R36 |= ( D93 'R' D94 )) by L1935 , L1554;
L1937: (R36 |= ( R19 'R' R20 ) iff R36 |= ( 'not' ( ( 'not' D93 ) 'U' ( 'not' D94 ) ) )) by L1936 , L1675;
L1938: (( 'not' D93 ) = ( Evaluate (D95 , ( AtomicKai )) ) & ( 'not' D94 ) = ( Evaluate (D96 , ( AtomicKai )) )) by L1503;
L1939: (R36 |= ( D95 'U' D96 ) iff R36 |= ( ( 'not' D93 ) 'U' ( 'not' D94 ) )) by L1938 , L1934 , L1542;
thus L1940: thesis by L1939 , L1937 , L1688 , L1849;
end;
theorem
L1941: (for R18 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |/= ( 'not' R18 ) iff R36 |= R18))) by L1849;
theorem
L1942: (for R18 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( 'X' ( 'not' R18 ) ) iff R36 |= ( 'not' ( 'X' R18 ) ))))
proof
let R18 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1943: (R36 |= ( 'X' ( 'not' R18 ) ) iff ( Shift (R36 , 1) ) |= ( 'not' R18 )) by L1864;
L1944: (R36 |= ( 'X' ( 'not' R18 ) ) iff ( Shift (R36 , 1) ) |/= R18) by L1943 , L1849;
L1945: (R36 |= ( 'X' ( 'not' R18 ) ) iff (not R36 |= ( 'X' R18 ))) by L1944 , L1864;
thus L1946: thesis by L1945 , L1849;
end;
theorem
L1947: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 'U' R20 ) iff R36 |= ( R20 'or' ( R19 '&' ( 'X' ( R19 'U' R20 ) ) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
L1948: (R36 |= ( R20 'or' ( R19 '&' ( 'X' ( R19 'U' R20 ) ) ) ) implies R36 |= ( R19 'U' R20 ))
proof
assume L1949: R36 |= ( R20 'or' ( R19 '&' ( 'X' ( R19 'U' R20 ) ) ) );
L1950:
now
per cases  by L1949 , L1859;
suppose L1951: R36 |= R20;

L1952: (ex B360 being Nat st ((for B361 being Nat holds (B361 < B360 implies ( Shift (R36 , B361) ) |= R19)) & ( Shift (R36 , B360) ) |= R20))
proof
take ( 0 );
thus L1953: thesis by L1951 , L1575;
end;
thus L1954: thesis by L1952 , L1869;
end;
suppose L1955: R36 |= ( R19 '&' ( 'X' ( R19 'U' R20 ) ) );

set D97 = ( Shift (R36 , 1) );
L1956: R36 |= ( 'X' ( R19 'U' R20 ) ) by L1955 , L1854;
L1957: ( Shift (R36 , 1) ) |= ( R19 'U' R20 ) by L1956 , L1864;
consider C195 being Nat such that L1958: (for B362 being Nat holds (B362 < C195 implies ( Shift (D97 , B362) ) |= R19)) and L1959: ( Shift (D97 , C195) ) |= R20 by L1957 , L1869;
set D98 = ( C195 + 1 );
L1960: R36 |= R19 by L1955 , L1854;
L1961: (for B363 being Nat holds (B363 < D98 implies ( Shift (R36 , B363) ) |= R19))
proof
let C196 being Nat;
assume that
L1962: C196 < D98;
L1963:
now
per cases ;
suppose L1964: C196 = ( 0 );

thus L1965: thesis by L1964 , L1960 , L1575;
end;
suppose L1966: C196 > ( 0 );

set D99 = ( C196 - 1 );
reconsider D100 = D99 as Nat by L1966 , NAT_1:20;
L1967: ( C196 - 1 ) < ( D98 - 1 ) by L1962 , XREAL_1:14;
L1968: ( Shift (D97 , D100) ) |= R19 by L1967 , L1958;
L1969: ( Shift (R36 , ( D100 + 1 )) ) |= R19 by L1968 , L1582;
thus L1970: thesis by L1969;
end;
end;
thus L1972: thesis by L1963;
end;
L1973: ( Shift (R36 , D98) ) |= R20 by L1959 , L1582;
thus L1974: thesis by L1973 , L1961 , L1869;
end;
end;
thus L1976: thesis by L1950;
end;
L1977: (R36 |= ( R19 'U' R20 ) implies R36 |= ( R20 'or' ( R19 '&' ( 'X' ( R19 'U' R20 ) ) ) ))
proof
assume L1978: R36 |= ( R19 'U' R20 );
consider C197 being Nat such that L1979: (for B364 being Nat holds (B364 < C197 implies ( Shift (R36 , B364) ) |= R19)) and L1980: ( Shift (R36 , C197) ) |= R20 by L1978 , L1869;
per cases ;
suppose L1981: C197 = ( 0 );

L1982: R36 |= R20 by L1981 , L1980 , L1575;
thus L1983: thesis by L1982 , L1859;
end;
suppose L1984: C197 > ( 0 );

set D101 = ( C197 - 1 );
reconsider D102 = D101 as Nat by L1984 , NAT_1:20;
set D103 = ( Shift (R36 , 1) );
L1985: (for B365 being Nat holds (B365 < D102 implies ( Shift (D103 , B365) ) |= R19))
proof
let C198 being Nat;
assume L1986: C198 < D102;
L1987: ( C198 + 1 ) < ( D102 + 1 ) by L1986 , XREAL_1:8;
L1988: ( Shift (R36 , ( C198 + 1 )) ) = ( Shift (D103 , C198) ) by L1582;
thus L1989: thesis by L1988 , L1979 , L1987;
end;
L1990: ( Shift (R36 , ( D102 + 1 )) ) = ( Shift (D103 , D102) ) by L1582;
L1991: D103 |= ( R19 'U' R20 ) by L1990 , L1980 , L1985 , L1869;
L1992: R36 |= ( 'X' ( R19 'U' R20 ) ) by L1991 , L1864;
L1993: ( Shift (R36 , ( 0 )) ) = R36 by L1575;
L1994: R36 |= R19 by L1993 , L1979 , L1984;
L1995: R36 |= ( R19 '&' ( 'X' ( R19 'U' R20 ) ) ) by L1994 , L1992 , L1854;
thus L1996: thesis by L1995 , L1859;
end;
end;
thus L1998: thesis by L1977 , L1948;
end;
theorem
L1999: (for R19 being LTL-formula holds (for R20 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (R36 |= ( R19 'R' R20 ) iff R36 |= ( ( R19 '&' R20 ) 'or' ( R20 '&' ( 'X' ( R19 'R' R20 ) ) ) )))))
proof
let R19 being LTL-formula;
let R20 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
set D104 = ( 'not' R19 );
set D105 = ( 'not' R20 );
L2000: (R36 |= ( R19 'R' R20 ) iff R36 |= ( 'not' ( D104 'U' D105 ) )) by L1933;
L2001: (R36 |= ( R19 'R' R20 ) iff R36 |/= ( D104 'U' D105 )) by L2000 , L1849;
L2002: (R36 |= ( R19 'R' R20 ) iff R36 |/= ( D105 'or' ( D104 '&' ( 'X' ( D104 'U' D105 ) ) ) )) by L2001 , L1947;
L2003: (R36 |= ( R19 'R' R20 ) iff R36 |= ( 'not' ( D105 'or' ( D104 '&' ( 'X' ( D104 'U' D105 ) ) ) ) )) by L2002 , L1849;
L2004: (R36 |= ( R19 'R' R20 ) iff R36 |= ( ( 'not' D105 ) '&' ( 'not' ( D104 '&' ( 'X' ( D104 'U' D105 ) ) ) ) )) by L2003 , L1923;
L2005: (R36 |= ( R19 'R' R20 ) iff (R36 |= ( 'not' D105 ) & R36 |= ( 'not' ( D104 '&' ( 'X' ( D104 'U' D105 ) ) ) ))) by L2004 , L1854;
L2006: (R36 |= ( R19 'R' R20 ) iff (R36 |/= D105 & R36 |= ( ( 'not' D104 ) 'or' ( 'not' ( 'X' ( D104 'U' D105 ) ) ) ))) by L2005 , L1849 , L1928;
L2007: (R36 |= ( R19 'R' R20 ) iff (R36 |= R20 & (R36 |= ( 'not' D104 ) or R36 |= ( 'not' ( 'X' ( D104 'U' D105 ) ) )))) by L2006 , L1849 , L1859;
L2008: (R36 |= ( R19 'R' R20 ) iff (R36 |= R20 & (R36 |/= D104 or R36 |= ( 'X' ( 'not' ( D104 'U' D105 ) ) )))) by L2007 , L1849 , L1942;
L2009: (R36 |= ( R19 'R' R20 ) iff (R36 |= R20 & (R36 |/= D104 or ( Shift (R36 , 1) ) |= ( 'not' ( D104 'U' D105 ) )))) by L2008 , L1864;
L2010: (R36 |= ( R19 'R' R20 ) iff (R36 |= R20 & (R36 |= R19 or ( Shift (R36 , 1) ) |= ( R19 'R' R20 )))) by L2009 , L1849 , L1933;
L2011: (R36 |= ( R19 'R' R20 ) iff (R36 |= R20 & (R36 |= R19 or R36 |= ( 'X' ( R19 'R' R20 ) )))) by L2010 , L1864;
L2012: (R36 |= ( R19 'R' R20 ) iff (R36 |= ( R19 '&' R20 ) or R36 |= ( R20 '&' ( 'X' ( R19 'R' R20 ) ) ))) by L2011 , L1854;
thus L2013: thesis by L2012 , L1859;
end;
theorem
L2014: (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (for R37 being (Subset of ( LTL_WFF )) holds (R36 |= ( 'X' R37 ) iff ( Shift (R36 , 1) ) |= R37)))
proof
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
let R37 being (Subset of ( LTL_WFF ));
L2015: (( Shift (R36 , 1) ) |= R37 implies R36 |= ( 'X' R37 ))
proof
assume L2016: ( Shift (R36 , 1) ) |= R37;
L2017: (for B366 being LTL-formula holds (B366 in R37 implies R36 |= ( 'X' B366 )))
proof
let C199 being LTL-formula;
assume L2018: C199 in R37;
L2019: ( Shift (R36 , 1) ) |= C199 by L2018 , L2016 , L1831;
thus L2020: thesis by L2019 , L1864;
end;
L2021: (for B367 being LTL-formula holds (B367 in ( 'X' R37 ) implies R36 |= B367))
proof
let C200 being LTL-formula;
assume L2022: C200 in ( 'X' R37 );
L2023: (ex B368 being LTL-formula st (C200 = B368 & (ex B369 being LTL-formula st (B369 in R37 & B368 = ( 'X' B369 ))))) by L2022;
thus L2024: thesis by L2023 , L2017;
end;
thus L2025: thesis by L2021 , L1831;
end;
L2026: (R36 |= ( 'X' R37 ) implies ( Shift (R36 , 1) ) |= R37)
proof
assume L2027: R36 |= ( 'X' R37 );
L2028: (for B370 being LTL-formula holds (B370 in R37 implies ( Shift (R36 , 1) ) |= B370))
proof
let C201 being LTL-formula;
set D106 = ( 'X' C201 );
assume L2029: C201 in R37;
L2030: D106 in ( 'X' R37 ) by L2029;
L2031: R36 |= D106 by L2030 , L2027 , L1831;
thus L2032: thesis by L2031 , L1864;
end;
thus L2033: thesis by L2028 , L1831;
end;
thus L2034: thesis by L2026 , L2015;
end;
theorem
L2035: (for R18 being LTL-formula holds ((R18 is  atomic implies ((not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))) & (R18 is  negative implies ((not R18 is  atomic) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))) & (R18 is  conjunctive implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))) & (R18 is  disjunctive implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  next) & (not R18 is  Until) & (not R18 is  Release))) & (R18 is  next implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  Until) & (not R18 is  Release))) & (R18 is  Until implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Release))) & (R18 is  Release implies ((not R18 is  atomic) & (not R18 is  negative) & (not R18 is  conjunctive) & (not R18 is  disjunctive) & (not R18 is  next) & (not R18 is  Until))))) by L483 , L487 , L491 , L495 , L499 , L503;
theorem
L2036: (for R11 being non  empty set holds (for B371 being (Element of ( Inf_seq R11 )) holds ( Shift (B371 , ( 0 )) ) = B371)) by L1575;
theorem
L2037: (for R1 being Nat holds (for R2 being Nat holds (for R11 being non  empty set holds (for B372 being (Element of ( Inf_seq R11 )) holds ( Shift (( Shift (B372 , R1) ) , R2) ) = ( Shift (B372 , ( R2 + R1 )) ))))) by L1582;
theorem
L2038: (for R11 being non  empty set holds (for B373 being (sequence of R11) holds ( CastSeq (( CastSeq B373 ) , R11) ) = B373)) by L1571;
theorem
L2039: (for R11 being non  empty set holds (for B374 being (Element of ( Inf_seq R11 )) holds ( CastSeq ( CastSeq (B374 , R11) ) ) = B374)) by L1571;
theorem
L2040: (for R18 being LTL-formula holds (for R36 being (Element of ( Inf_seq ( AtomicFamily ) )) holds (for R37 being (Subset of ( LTL_WFF )) holds ((R18 in R37 & ( 'not' R18 ) in R37) implies R36 |/= R37))))
proof
let R18 being LTL-formula;
let R36 being (Element of ( Inf_seq ( AtomicFamily ) ));
let R37 being (Subset of ( LTL_WFF ));
assume L2041: (R18 in R37 & ( 'not' R18 ) in R37);
L2042:
now
assume L2043: R36 |= R37;
L2044: (R36 |= R18 & R36 |= ( 'not' R18 )) by L2043 , L2041 , L1831;
thus L2045: contradiction by L2044 , L1849;
end;
thus L2046: thesis by L2042;
end;
