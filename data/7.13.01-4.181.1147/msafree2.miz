:: Preliminaries to Circuits, II
::  by Yatsuka Nakamura , Piotr Rudnicki , Andrzej Trybulec and Pauline N. Kawamoto
::
:: Received December 13, 1994
:: Copyright (c) 1994-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies MSUALG_1, GLIB_000, SUBSET_1, XBOOLE_0, UNIALG_2, STRUCT_0,
      RELAT_1, TARSKI, FUNCT_1, FUNCOP_1, PBOOLE, CARD_3, FINSEQ_1, MARGREL1,
      NAT_1, PARTFUN1, PRELAMB, MSAFREE, MSUALG_3, TREES_4, REALSET1, MSUALG_2,
      FINSET_1, PRALG_1, CARD_1, TREES_2, DTCONSTR, TREES_3, ZFMISC_1, LANG1,
      TDGROUP, TREES_1, MSAFREE2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NAT_1, CARD_1,
      RELAT_1, FUNCT_1, PARTFUN1, FINSET_1, FINSEQ_1, FUNCT_2, CARD_3, TREES_1,
      TREES_2, TREES_3, TREES_4, PBOOLE, STRUCT_0, MSUALG_1, FINSEQ_2, MSAFREE,
      MSUALG_2, FUNCOP_1, DTCONSTR, LANG1, PRE_POLY, RELSET_1, MSUALG_3;
 constructors XXREAL_0, NAT_1, MSUALG_3, MSAFREE, SEQ_4, RELSET_1, PRE_POLY,
      FINSEQ_2;
 registrations XBOOLE_0, FUNCT_1, RELSET_1, FUNCOP_1, FINSET_1, TREES_1,
      CARD_3, TREES_2, TREES_3, PRE_CIRC, STRUCT_0, DTCONSTR, RELAT_1,
      MSUALG_1, MSUALG_2, MSAFREE, ORDINAL1, PBOOLE, FINSEQ_1;
 requirements BOOLE, SUBSET;
 definitions TARSKI, MSUALG_1, FINSET_1, MSUALG_2, FUNCT_1, STRUCT_0, PBOOLE,
      FUNCOP_1;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, FINSEQ_3, FUNCT_1, FUNCT_2, TREES_3,
      TREES_4, SUBSET_1, CARD_3, FUNCOP_1, PBOOLE, MSUALG_1, MSUALG_2, MSAFREE,
      CARD_2, CARD_1, DTCONSTR, LANG1, PRE_CIRC, RELAT_1, RELSET_1, XBOOLE_0,
      XBOOLE_1, FINSET_1, PARTFUN1, FINSEQ_2, XTUPLE_0;
 schemes DOMAIN_1, PBOOLE, MSAFREE1, FUNCT_1;

begin
definition
let C1 being ManySortedSign;
mode Vertex of C1
 is (Element of C1);
end;
definition
let C2 being non  empty ManySortedSign;
func SortsWithConstants C2 -> (Subset of C2) equals 
:L2: { B1 where B1 is (SortSymbol of C2) : B1 is  with_const_op } if C2 is non  void otherwise ( {} );
coherence
proof
thus L3:now
defpred S1[ (SortSymbol of C2) ] means $1 is  with_const_op;
assume L4: C2 is non  void;
L5: { B2 where B2 is (SortSymbol of C2) : S1[ B2 ] } is (Subset of C2) from DOMAIN_1:sch 7;
thus L6: { B3 where B3 is (SortSymbol of C2) : B3 is  with_const_op } is (Subset of C2) by L5;
end;
assume L7: C2 is  void;
thus L8: thesis by SUBSET_1:1;
end;
consistency;
end;
definition
let C3 being non  empty ManySortedSign;
func InputVertices C3 -> (Subset of C3) equals 
( (the carrier of C3) \ ( rng (the ResultSort of C3) ) );
coherence;
func InnerVertices C3 -> (Subset of C3) equals 
( rng (the ResultSort of C3) );
coherence;
end;
theorem
L11: (for B4 being  void non  empty ManySortedSign holds ( InputVertices B4 ) = (the carrier of B4));
theorem
L12: (for B5 being non  void non  empty ManySortedSign holds (for B6 being (Vertex of B5) holds (B6 in ( InputVertices B5 ) implies (not (ex B7 being (OperSymbol of B5) st ( the_result_sort_of B7 ) = B6)))))
proof
let C4 being non  void non  empty ManySortedSign;
let C5 being (Vertex of C4);
assume L13: C5 in ( InputVertices C4 );
let C6 being (OperSymbol of C4);
assume that
L14: ( the_result_sort_of C6 ) = C5;
L15: C6 in (the carrier' of C4);
L16: C6 in ( dom (the ResultSort of C4) ) by L15 , FUNCT_2:def 1;
L17: C5 in ( rng (the ResultSort of C4) ) by L16 , L14 , FUNCT_1:def 3;
thus L18: contradiction by L17 , L13 , XBOOLE_0:def 5;
end;
theorem
L19: (for B8 being non  empty ManySortedSign holds ( SortsWithConstants B8 ) c= ( InnerVertices B8 ))
proof
let C7 being non  empty ManySortedSign;
per cases ;
suppose L20: C7 is  void;

thus L21: thesis by L20 , L2;
end;
suppose L22: C7 is non  void;

let C8 being set;
assume L23: C8 in ( SortsWithConstants C7 );
L24: ( SortsWithConstants C7 ) = { B9 where B9 is (SortSymbol of C7) : B9 is  with_const_op } by L22 , L2;
consider C9 being (SortSymbol of C7) such that L25: C9 = C8 and L26: C9 is  with_const_op by L24 , L23;
L27: (ex B10 being (OperSymbol of C7) st (( (the Arity of C7) . B10 ) = ( {} ) & ( (the ResultSort of C7) . B10 ) = C9)) by L26 , MSUALG_2:def 1;
thus L28: thesis by L27 , L22 , L25 , FUNCT_2:4;
end;
end;
theorem
L30: (for B11 being non  empty ManySortedSign holds ( InputVertices B11 ) misses ( SortsWithConstants B11 ))
proof
let C10 being non  empty ManySortedSign;
L31: ( InputVertices C10 ) misses ( InnerVertices C10 ) by XBOOLE_1:79;
thus L32: thesis by L31 , L19 , XBOOLE_1:63;
end;
definition
let C11 being non  empty ManySortedSign;
attr C11 is  with_input_V
means
:L33: ( InputVertices C11 ) <> ( {} );
end;
registration
cluster non  void  with_input_V for non  empty non  empty non  empty non  empty ManySortedSign;
existence
proof
L35: ( {} ) in { ( {} ) , { ( {} ) } } by TARSKI:def 2;
reconsider D1 = ( { ( {} ) } --> ( {} ) ) as (Function of { ( {} ) } , { ( {} ) , { ( {} ) } }) by L35 , FUNCOP_1:46;
L36: ( {} ) in ( { ( {} ) , { ( {} ) } } * ) by FINSEQ_1:49;
reconsider D2 = ( { ( {} ) } --> ( {} ) ) as (Function of { ( {} ) } , ( { ( {} ) , { ( {} ) } } * )) by L36 , FUNCOP_1:46;
take D3 = ManySortedSign (# { ( {} ) , { ( {} ) } } , { ( {} ) } , D2 , D1 #);
L37: ( rng (the ResultSort of D3) ) = { ( {} ) } by FUNCOP_1:8;
L38: ({ ( {} ) } in (the carrier of D3) & (not { ( {} ) } in ( rng (the ResultSort of D3) ))) by L37 , TARSKI:def 2;
L39: ( InputVertices D3 ) <> ( {} ) by L38 , XBOOLE_0:def 5;
thus L40: thesis by L39 , L33;
end;
end;
registration
let C12 being  with_input_V non  empty ManySortedSign;
cluster ( InputVertices C12 ) -> non  empty;
coherence by L33;
end;
registration
let C13 being non  void non  empty ManySortedSign;
cluster ( InnerVertices C13 ) -> non  empty;
coherence
proof
L43: ( dom (the ResultSort of C13) ) = (the carrier' of C13) by FUNCT_2:def 1;
thus L44: thesis by L43 , RELAT_1:42;
end;
end;
definition
let C14 being non  empty ManySortedSign;
let C15 being  non-empty MSAlgebra over C14;
mode InputValues of C15
 -> (ManySortedSet of ( InputVertices C14 ))
means (for B12 being (Vertex of C14) holds (B12 in ( InputVertices C14 ) implies ( it . B12 ) in ( (the Sorts of C15) . B12 )));
existence
proof
set D4 = the (Element of ( product (the Sorts of C15) ));
set D5 = ( D4 | ( InputVertices C14 ) );
L46: (( dom (the Sorts of C15) ) = (the carrier of C14) & (ex B13 being Function st (D4 = B13 & ( dom B13 ) = ( dom (the Sorts of C15) ) & (for B14 being set holds (B14 in ( dom (the Sorts of C15) ) implies ( B13 . B14 ) in ( (the Sorts of C15) . B14 )))))) by CARD_3:def 5 , PARTFUN1:def 2;
reconsider D6 = D5 as (ManySortedSet of ( InputVertices C14 ));
take D6;
let C16 being (Vertex of C14);
assume L47: C16 in ( InputVertices C14 );
L48: ( D6 . C16 ) = ( D4 . C16 ) by L47 , FUNCT_1:49;
thus L49: thesis by L48 , L46;
end;
end;
definition
let C17 being non  empty ManySortedSign;
attr C17 is  Circuit-like
means
:L51: (for B15 being non  void non  empty ManySortedSign holds (B15 = C17 implies (for B16 , B17 being (OperSymbol of B15) holds (( the_result_sort_of B16 ) = ( the_result_sort_of B17 ) implies B16 = B17))));
end;
registration
cluster  void ->  Circuit-like for non  empty non  empty non  empty non  empty ManySortedSign;
coherence
proof
let C18 being non  empty ManySortedSign;
assume that
L53: C18 is  void;
let C19 being non  void non  empty ManySortedSign;
thus L54: thesis by L53;
end;
end;
registration
cluster non  void  Circuit-like  strict for non  empty non  empty non  empty non  empty ManySortedSign;
existence
proof
L56: ( {} ) in ( { ( {} ) } * ) by FINSEQ_1:49;
reconsider D7 = ( { ( {} ) } --> ( {} ) ) as (Function of { ( {} ) } , ( { ( {} ) } * )) by L56 , FUNCOP_1:46;
reconsider D8 = ( { ( {} ) } --> ( {} ) ) as (Function of { ( {} ) } , { ( {} ) });
take D9 = ManySortedSign (# { ( {} ) } , { ( {} ) } , D7 , D8 #);
L57: D9 is  Circuit-like
proof
let C20 being non  void non  empty ManySortedSign;
assume L58: C20 = D9;
let C21 , C22 being (OperSymbol of C20);
assume that
L59: ( the_result_sort_of C21 ) = ( the_result_sort_of C22 );
thus L60: C21 = ( {} ) by L58 , TARSKI:def 1
.= C22 by L58 , TARSKI:def 1;
end;
thus L61: thesis by L57;
end;
end;
definition
let C23 being  Circuit-like non  void non  empty ManySortedSign;
let C24 being (Vertex of C23);
assume that
L63: C24 in ( InnerVertices C23 );
func action_at C24 -> (OperSymbol of C23) means 
( the_result_sort_of it ) = C24;
existence
proof
consider C25 being set such that L64: C25 in ( dom (the ResultSort of C23) ) and L65: ( (the ResultSort of C23) . C25 ) = C24 by L63 , FUNCT_1:def 3;
reconsider D10 = C25 as (OperSymbol of C23) by L64;
take D10;
thus L66: thesis by L65;
end;
uniqueness by L51;
end;
begin
theorem
L68: (for B18 being non  void non  empty ManySortedSign holds (for B19 being MSAlgebra over B18 holds (for B20 being (OperSymbol of B18) holds (for B21 being FinSequence holds ((( len B21 ) = ( len ( the_arity_of B20 ) ) & (for B22 being Nat holds (B22 in ( dom B21 ) implies ( B21 . B22 ) in ( (the Sorts of B19) . ( ( the_arity_of B20 ) /. B22 ) )))) implies B21 in ( Args (B20 , B19) ))))))
proof
let C26 being non  void non  empty ManySortedSign;
let C27 being MSAlgebra over C26;
let C28 being (OperSymbol of C26);
let C29 being FinSequence;
assume that
L69: ( len C29 ) = ( len ( the_arity_of C28 ) )
and
L70: (for B23 being Nat holds (B23 in ( dom C29 ) implies ( C29 . B23 ) in ( (the Sorts of C27) . ( ( the_arity_of C28 ) /. B23 ) )));
set D11 = ( (the Sorts of C27) * ( the_arity_of C28 ) );
L71: ( dom C29 ) = ( dom ( the_arity_of C28 ) ) by L69 , FINSEQ_3:29;
L72: ( rng ( the_arity_of C28 ) ) c= (the carrier of C26);
L73: ( rng ( the_arity_of C28 ) ) c= ( dom (the Sorts of C27) ) by L72 , PARTFUN1:def 2;
L74: ( dom C29 ) = ( dom D11 ) by L73 , L71 , RELAT_1:27;
L75:
now
let C30 being set;
assume L76: C30 in ( dom D11 );
reconsider D12 = C30 as Nat by L76;
L77: ( D11 . D12 ) = ( (the Sorts of C27) . ( ( the_arity_of C28 ) . D12 ) ) by L76 , FUNCT_1:12
.= ( (the Sorts of C27) . ( ( the_arity_of C28 ) /. D12 ) ) by L71 , L74 , L76 , PARTFUN1:def 6;
thus L78: ( C29 . C30 ) in ( D11 . C30 ) by L77 , L70 , L74 , L76;
end;
L79: ( dom (the Arity of C26) ) = (the carrier' of C26) by FUNCT_2:def 1;
L80: ( ( ( (the Sorts of C27) # ) * (the Arity of C26) ) . C28 ) = ( ( (the Sorts of C27) # ) . ( the_arity_of C28 ) ) by L79 , FUNCT_1:13
.= ( product ( (the Sorts of C27) * ( the_arity_of C28 ) ) ) by FINSEQ_2:def 5;
thus L81: thesis by L80 , L74 , L75 , CARD_3:def 5;
end;
definition
let C31 being non  void non  empty ManySortedSign;
let C32 being  non-empty MSAlgebra over C31;
func FreeEnv C32 ->  free  strict  non-empty MSAlgebra over C31 equals 
( FreeMSA (the Sorts of C32) );
coherence by MSAFREE:17;
end;
definition
let C33 being non  void non  empty ManySortedSign;
let C34 being  non-empty MSAlgebra over C33;
func Eval C34 -> (ManySortedFunction of ( FreeEnv C34 ) , C34) means 
(it is_homomorphism ( FreeEnv C34 ) , C34 & (for B24 being (SortSymbol of C33) holds (for B25 , B26 being set holds ((B26 in ( FreeSort ((the Sorts of C34) , B24) ) & B26 = ( root-tree [ B25 , B24 ] ) & B25 in ( (the Sorts of C34) . B24 )) implies ( ( it . B24 ) . B26 ) = B25))));
existence
proof
reconsider D13 = ( FreeGen (the Sorts of C34) ) as  free (GeneratorSet of ( FreeEnv C34 )) by MSAFREE:16;
defpred S2[ set , set ] means (ex B27 being (SortSymbol of C33) st (ex B28 being (Function of ( D13 . B27 ) , ( (the Sorts of C34) . B27 )) st (B28 = $2 & B27 = $1 & (for B29 , B30 being set holds ((B30 in ( D13 . B27 ) & B30 = ( root-tree [ B29 , B27 ] ) & B29 in ( (the Sorts of C34) . B27 )) implies ( B28 . B30 ) = B29)))));
L83: (for B31 being set holds (B31 in (the carrier of C33) implies (ex B32 being set st S2[ B31 , B32 ])))
proof
let C35 being set;
assume L84: C35 in (the carrier of C33);
reconsider D14 = C35 as (SortSymbol of C33) by L84;
defpred S3[ set , set ] means $1 = ( root-tree [ $2 , D14 ] );
L85: (for B33 being set holds (B33 in ( D13 . D14 ) implies (ex B34 being set st (B34 in ( (the Sorts of C34) . D14 ) & S3[ B33 , B34 ]))))
proof
let C36 being set;
assume L86: C36 in ( D13 . D14 );
L87: C36 in ( FreeGen (D14 , (the Sorts of C34)) ) by L86 , MSAFREE:def 16;
thus L88: thesis by L87 , MSAFREE:def 15;
end;
consider C37 being Function such that L89: (( dom C37 ) = ( D13 . D14 ) & ( rng C37 ) c= ( (the Sorts of C34) . D14 ) & (for B35 being set holds (B35 in ( D13 . D14 ) implies S3[ B35 , ( C37 . B35 ) ]))) from FUNCT_1:sch 5(L85);
reconsider D15 = C37 as (Function of ( D13 . D14 ) , ( (the Sorts of C34) . D14 )) by L89 , FUNCT_2:def 1 , RELSET_1:4;
take C37;
take D14;
take D15;
thus L90: (D15 = C37 & D14 = C35);
let C38 , C39 being set;
assume that
L91: C39 in ( D13 . D14 )
and
L92: C39 = ( root-tree [ C38 , D14 ] )
and
L93: C38 in ( (the Sorts of C34) . D14 );
L94: C39 = ( root-tree [ ( C37 . C39 ) , D14 ] ) by L89 , L91;
L95: [ C38 , D14 ] = [ ( C37 . C39 ) , D14 ] by L94 , L92 , TREES_4:4;
thus L96: thesis by L95 , XTUPLE_0:1;
end;
consider C40 being (ManySortedSet of (the carrier of C33)) such that L97: (for B36 being set holds (B36 in (the carrier of C33) implies S2[ B36 , ( C40 . B36 ) ])) from PBOOLE:sch 3(L83);
L98:
now
let C41 being set;
assume L99: C41 in ( dom C40 );
L100: C41 in (the carrier of C33) by L99;
L101: S2[ C41 , ( C40 . C41 ) ] by L100 , L97;
thus L102: ( C40 . C41 ) is Function by L101;
end;
reconsider D16 = C40 as (ManySortedFunction of (the carrier of C33)) by L98 , FUNCOP_1:def 6;
L103:
now
let C42 being set;
assume L104: C42 in (the carrier of C33);
L105: S2[ C42 , ( D16 . C42 ) ] by L104 , L97;
thus L106: ( D16 . C42 ) is (Function of ( D13 . C42 ) , ( (the Sorts of C34) . C42 )) by L105;
end;
reconsider D17 = D16 as (ManySortedFunction of D13 , (the Sorts of C34)) by L103 , PBOOLE:def 15;
consider C43 being (ManySortedFunction of ( FreeEnv C34 ) , C34) such that L107: C43 is_homomorphism ( FreeEnv C34 ) , C34 and L108: ( C43 || D13 ) = D17 by MSAFREE:def 5;
take C43;
thus L109: C43 is_homomorphism ( FreeEnv C34 ) , C34 by L107;
let C44 being (SortSymbol of C33);
let C45 , C46 being set;
L110: (ex B37 being (SortSymbol of C33) st (ex B38 being (Function of ( D13 . B37 ) , ( (the Sorts of C34) . B37 )) st (B38 = ( D17 . C44 ) & B37 = C44 & (for B39 , B40 being set holds ((B40 in ( D13 . B37 ) & B40 = ( root-tree [ B39 , B37 ] ) & B39 in ( (the Sorts of C34) . B37 )) implies ( B38 . B40 ) = B39))))) by L97;
assume that
L111: C46 in ( FreeSort ((the Sorts of C34) , C44) )
and
L112: (C46 = ( root-tree [ C45 , C44 ] ) & C45 in ( (the Sorts of C34) . C44 ));
L113: C46 in ( FreeGen (C44 , (the Sorts of C34)) ) by L112 , MSAFREE:def 15;
L114: C46 in ( D13 . C44 ) by L113 , MSAFREE:def 16;
thus L115: ( ( C43 . C44 ) . C46 ) = ( ( ( C43 . C44 ) | ( D13 . C44 ) ) . C46 ) by L114 , FUNCT_1:49
.= ( ( D17 . C44 ) . C46 ) by L108 , MSAFREE:def 1
.= C45 by L112 , L114 , L110;
end;
uniqueness
proof
defpred S4[ set , set , set ] means $3 = ( root-tree [ $2 , $1 ] );
let C47 , C48 being (ManySortedFunction of ( FreeEnv C34 ) , C34);
reconsider D18 = C47 , D19 = C48 as (ManySortedFunction of ( FreeMSA (the Sorts of C34) ) , C34);
assume L116: C47 is_homomorphism ( FreeEnv C34 ) , C34;
L117: D18 is_homomorphism ( FreeMSA (the Sorts of C34) ) , C34 by L116;
assume L118: (for B41 being (SortSymbol of C33) holds (for B42 , B43 being set holds ((B43 in ( FreeSort ((the Sorts of C34) , B41) ) & B43 = ( root-tree [ B42 , B41 ] ) & B42 in ( (the Sorts of C34) . B41 )) implies ( ( C47 . B41 ) . B43 ) = B42)));
L119: (for B44 being (SortSymbol of C33) holds (for B45 , B46 being set holds (B46 in ( FreeGen (B44 , (the Sorts of C34)) ) implies (( ( D18 . B44 ) . B46 ) = B45 iff S4[ B44 , B45 , B46 ]))))
proof
let C49 being (SortSymbol of C33);
let C50 , C51 being set;
assume L120: C51 in ( FreeGen (C49 , (the Sorts of C34)) );
consider C52 being set such that L121: C52 in ( (the Sorts of C34) . C49 ) and L122: C51 = ( root-tree [ C52 , C49 ] ) by L120 , MSAFREE:def 15;
L123: C51 in ( ( FreeSort (the Sorts of C34) ) . C49 ) by L120;
L124: C51 in ( FreeSort ((the Sorts of C34) , C49) ) by L123 , MSAFREE:def 11;
thus L125: (( ( D18 . C49 ) . C51 ) = C50 implies C51 = ( root-tree [ C50 , C49 ] )) by L124 , L118 , L121 , L122;
assume L126: C51 = ( root-tree [ C50 , C49 ] );
L127: [ C50 , C49 ] = [ C52 , C49 ] by L126 , L122 , TREES_4:4;
L128: C50 = C52 by L127 , XTUPLE_0:1;
thus L129: thesis by L128 , L118 , L124 , L121 , L122;
end;
assume L130: C48 is_homomorphism ( FreeEnv C34 ) , C34;
L131: D19 is_homomorphism ( FreeMSA (the Sorts of C34) ) , C34 by L130;
assume L132: (for B47 being (SortSymbol of C33) holds (for B48 , B49 being set holds ((B49 in ( FreeSort ((the Sorts of C34) , B47) ) & B49 = ( root-tree [ B48 , B47 ] ) & B48 in ( (the Sorts of C34) . B47 )) implies ( ( C48 . B47 ) . B49 ) = B48)));
L133: (for B50 being (SortSymbol of C33) holds (for B51 , B52 being set holds (B52 in ( FreeGen (B50 , (the Sorts of C34)) ) implies (( ( D19 . B50 ) . B52 ) = B51 iff S4[ B50 , B51 , B52 ]))))
proof
let C53 being (SortSymbol of C33);
let C54 , C55 being set;
assume L134: C55 in ( FreeGen (C53 , (the Sorts of C34)) );
consider C56 being set such that L135: C56 in ( (the Sorts of C34) . C53 ) and L136: C55 = ( root-tree [ C56 , C53 ] ) by L134 , MSAFREE:def 15;
L137: C55 in ( ( FreeSort (the Sorts of C34) ) . C53 ) by L134;
L138: C55 in ( FreeSort ((the Sorts of C34) , C53) ) by L137 , MSAFREE:def 11;
thus L139: (( ( D19 . C53 ) . C55 ) = C54 implies C55 = ( root-tree [ C54 , C53 ] )) by L138 , L132 , L135 , L136;
assume L140: C55 = ( root-tree [ C54 , C53 ] );
L141: [ C54 , C53 ] = [ C56 , C53 ] by L140 , L136 , TREES_4:4;
L142: C54 = C56 by L141 , XTUPLE_0:1;
thus L143: thesis by L142 , L132 , L138 , L135 , L136;
end;
L144: D18 = D19 from MSAFREE1:sch 3(L117 , L119 , L131 , L133);
thus L145: thesis by L144;
end;
end;
theorem
L147: (for B53 being non  void non  empty ManySortedSign holds (for B54 being  non-empty MSAlgebra over B53 holds (the Sorts of B54) is (GeneratorSet of B54)))
proof
let C57 being non  void non  empty ManySortedSign;
let C58 being  non-empty MSAlgebra over C57;
reconsider D20 = ( the MSAlgebra of C58 ) as  non-empty MSAlgebra over C57;
reconsider D21 = (the Sorts of C58) as  non-empty (MSSubset of D20) by PBOOLE:def 18;
set D22 = ( GenMSAlg D21 );
L148: (the Sorts of D22) is (MSSubset of C58) by MSUALG_2:def 9;
L149:
now
let C59 being (MSSubset of C58);
assume that
L150: C59 = (the Sorts of D22);
reconsider D23 = C59 as (MSSubset of D20);
L151: D23 is  opers_closed by L150 , MSUALG_2:def 9;
L152:
now
let C60 being (OperSymbol of C57);
L153: D23 is_closed_on C60 by L151 , MSUALG_2:def 6;
L154: ( rng ( ( Den (C60 , ( the MSAlgebra of C58 )) ) | ( ( ( D23 # ) * (the Arity of C57) ) . C60 ) ) ) c= ( ( D23 * (the ResultSort of C57) ) . C60 ) by L153 , MSUALG_2:def 5;
L155: ( Den (C60 , C58) ) = ( Den (C60 , ( the MSAlgebra of C58 )) );
thus L156: C59 is_closed_on C60 by L155 , L154 , MSUALG_2:def 5;
end;
thus L157: C59 is  opers_closed by L152 , MSUALG_2:def 6;
reconsider D24 = ( Opers (C58 , C59) ) as (ManySortedFunction of ( ( D23 # ) * (the Arity of C57) ) , ( D23 * (the ResultSort of C57) ));
L158:
now
let C61 being (OperSymbol of C57);
L159: (D23 is_closed_on C61 & ( Den (C61 , C58) ) = ( Den (C61 , ( the MSAlgebra of C58 )) )) by L151 , MSUALG_2:def 6;
thus L160: ( D24 . C61 ) = ( C61 /. C59 ) by MSUALG_2:def 8
.= ( ( Den (C61 , C58) ) | ( ( ( C59 # ) * (the Arity of C57) ) . C61 ) ) by L152 , MSUALG_2:def 7
.= ( C61 /. D23 ) by L159 , MSUALG_2:def 7;
end;
L161: (the Charact of D22) = ( Opers (D20 , D23) ) by L150 , MSUALG_2:def 9;
thus L162: (the Charact of D22) = ( Opers (C58 , C59) ) by L161 , L158 , MSUALG_2:def 8;
end;
reconsider D25 = D22 as  strict  non-empty (MSSubAlgebra of C58) by L149 , L148 , MSUALG_2:def 9;
reconsider D26 = (the Sorts of C58) as (MSSubset of C58) by PBOOLE:def 18;
L163:
now
let C62 being (MSSubAlgebra of C58);
L164:
now
let C63 being (MSSubset of D20);
assume that
L165: C63 = (the Sorts of C62);
reconsider D27 = C63 as (MSSubset of C58);
L166: D27 is  opers_closed by L165 , MSUALG_2:def 9;
L167:
now
let C64 being (OperSymbol of C57);
L168: D27 is_closed_on C64 by L166 , MSUALG_2:def 6;
L169: ( rng ( ( Den (C64 , C58) ) | ( ( ( D27 # ) * (the Arity of C57) ) . C64 ) ) ) c= ( ( D27 * (the ResultSort of C57) ) . C64 ) by L168 , MSUALG_2:def 5;
L170: ( Den (C64 , ( the MSAlgebra of C58 )) ) = ( Den (C64 , C58) );
thus L171: C63 is_closed_on C64 by L170 , L169 , MSUALG_2:def 5;
end;
thus L172: C63 is  opers_closed by L167 , MSUALG_2:def 6;
reconsider D28 = ( Opers (D20 , C63) ) as (ManySortedFunction of ( ( D27 # ) * (the Arity of C57) ) , ( D27 * (the ResultSort of C57) ));
L173:
now
let C65 being (OperSymbol of C57);
L174: ( Den (C65 , C58) ) = ( Den (C65 , ( the MSAlgebra of C58 )) );
L175: D27 is_closed_on C65 by L166 , MSUALG_2:def 6;
thus L176: ( D28 . C65 ) = ( C65 /. C63 ) by MSUALG_2:def 8
.= ( ( Den (C65 , C58) ) | ( ( ( C63 # ) * (the Arity of C57) ) . C65 ) ) by L167 , L174 , MSUALG_2:def 7
.= ( C65 /. D27 ) by L175 , MSUALG_2:def 7;
end;
L177: (the Charact of C62) = ( Opers (C58 , D27) ) by L165 , MSUALG_2:def 9;
thus L178: (the Charact of C62) = ( Opers (D20 , C63) ) by L177 , L173 , MSUALG_2:def 8;
end;
L179: (the Sorts of C62) is (MSSubset of ( the MSAlgebra of C58 )) by MSUALG_2:def 9;
reconsider D29 = C62 as (MSSubAlgebra of D20) by L179 , L164 , MSUALG_2:def 9;
assume L180: D26 is (MSSubset of C62);
L181: D25 is (MSSubAlgebra of D29) by L180 , MSUALG_2:def 17;
thus L182: D25 is (MSSubAlgebra of C62) by L181;
end;
L183: D26 is (MSSubset of ( GenMSAlg D21 )) by MSUALG_2:def 17;
L184: ( GenMSAlg D21 ) = ( GenMSAlg D26 ) by L183 , L163 , MSUALG_2:def 17;
L185: (the Sorts of ( GenMSAlg D26 )) = (the Sorts of C58) by L184 , MSUALG_2:21;
thus L186: thesis by L185 , MSAFREE:def 4;
end;
definition
let C66 being non  empty ManySortedSign;
let C67 being MSAlgebra over C66;
attr C67 is  finitely-generated
means
:L187: (for B55 being non  void non  empty ManySortedSign holds (B55 = C66 implies (for B56 being MSAlgebra over B55 holds (B56 = C67 implies (ex B57 being (GeneratorSet of B56) st B57 is  finite-yielding))))) if (not C66 is  void) otherwise (the Sorts of C67) is  finite-yielding;
consistency;
end;
definition
let C68 being non  empty ManySortedSign;
let C69 being MSAlgebra over C68;
attr C69 is  finite-yielding
means
:L189: (the Sorts of C69) is  finite-yielding;
end;
registration
let C70 being non  empty ManySortedSign;
cluster  finite-yielding ->  finitely-generated for  non-empty  non-empty  non-empty  non-empty MSAlgebra over C70;
coherence
proof
let C71 being  non-empty MSAlgebra over C70;
assume L191: C71 is  finite-yielding;
per cases ;
case L192: C70 is non  void;
let C72 being non  void non  empty ManySortedSign;
assume that
L193: C72 = C70;
let C73 being MSAlgebra over C72;
assume L194: C73 = C71;
reconsider D30 = (the Sorts of C71) as (GeneratorSet of C73) by L194 , L193 , L147;
take D30;
thus L195: thesis by L191 , L189;
end;
case L196: C70 is  void;
thus L197: thesis by L191 , L189;
end;
end;
end;
definition
let C74 being non  empty ManySortedSign;
func Trivial_Algebra C74 ->  strict MSAlgebra over C74 means 
:L200: (the Sorts of it) = ( (the carrier of C74) --> { ( 0 ) } );
existence
proof
reconsider D31 = ( (the carrier of C74) --> { ( 0 ) } ) as (ManySortedSet of (the carrier of C74));
set D32 = the (ManySortedFunction of ( ( D31 # ) * (the Arity of C74) ) , ( D31 * (the ResultSort of C74) ));
take MSAlgebra (# D31 , D32 #);
thus L201: thesis;
end;
uniqueness
proof
let C75 , C76 being  strict MSAlgebra over C74;
assume that
L202: (the Sorts of C75) = ( (the carrier of C74) --> { ( 0 ) } )
and
L203: (the Sorts of C76) = ( (the carrier of C74) --> { ( 0 ) } );
set D33 = (the Sorts of C75);
L204: ( dom (the ResultSort of C74) ) = (the carrier' of C74) by FUNCT_2:def 1;
L205:
now
let C77 being set;
set D34 = ( ( D33 * (the ResultSort of C74) ) . C77 );
assume L206: C77 in (the carrier' of C74);
L207: D34 = ( D33 . ( (the ResultSort of C74) . C77 ) ) by L206 , L204 , FUNCT_1:13
.= { ( 0 ) } by L202 , L206 , FUNCOP_1:7 , FUNCT_2:5;
reconsider D35 = D34 as non  empty set by L207;
reconsider D36 = ( (the Charact of C75) . C77 ) , D37 = ( (the Charact of C76) . C77 ) as (Function of ( ( ( D33 # ) * (the Arity of C74) ) . C77 ) , D35) by L202 , L203 , L206 , PBOOLE:def 15;
L208:
now
let C78 being set;
assume L209: C78 in ( ( ( D33 # ) * (the Arity of C74) ) . C77 );
L210: ( D36 . C78 ) in D35 by L209 , FUNCT_2:5;
L211: ( D36 . C78 ) = ( 0 ) by L210 , L207 , TARSKI:def 1;
L212: ( D37 . C78 ) in D35 by L209 , FUNCT_2:5;
thus L213: ( D36 . C78 ) = ( D37 . C78 ) by L212 , L207 , L211 , TARSKI:def 1;
end;
thus L214: ( (the Charact of C75) . C77 ) = ( (the Charact of C76) . C77 ) by L208 , FUNCT_2:12;
end;
thus L215: thesis by L205 , L202 , L203 , PBOOLE:3;
end;
end;
registration
let C79 being non  empty ManySortedSign;
cluster  finite-yielding  non-empty  strict for MSAlgebra over C79;
existence
proof
take D38 = ( Trivial_Algebra C79 );
L217: (the Sorts of D38) = ( (the carrier of C79) --> { ( 0 ) } ) by L200;
L218: (the Sorts of D38) is  finite-yielding
proof
let C80 being set;
assume L219: C80 in (the carrier of C79);
thus L220: thesis by L219 , L217 , FUNCOP_1:7;
end;
thus L221: D38 is  finite-yielding by L218 , L189;
thus L222: D38 is  non-empty by L217 , MSUALG_1:def 3;
thus L223: thesis;
end;
end;
definition
let C81 being non  empty ManySortedSign;
attr C81 is  monotonic
means
(for B58 being  finitely-generated  non-empty MSAlgebra over C81 holds B58 is  finite-yielding);
end;
registration
cluster non  void  finite  monotonic  Circuit-like for non  empty non  empty non  empty non  empty ManySortedSign;
existence
proof
L226: ( {} ) in ( { ( {} ) } * ) by FINSEQ_1:49;
reconsider D39 = ( { [ ( {} ) , { ( {} ) } ] } --> ( {} ) ) as (Function of { [ ( {} ) , { ( {} ) } ] } , ( { ( {} ) } * )) by L226 , FUNCOP_1:46;
reconsider D40 = ( { [ ( {} ) , { ( {} ) } ] } --> ( {} ) ) as (Function of { [ ( {} ) , { ( {} ) } ] } , { ( {} ) });
take D41 = ManySortedSign (# { ( {} ) } , { [ ( {} ) , { ( {} ) } ] } , D39 , D40 #);
thus L227: D41 is non  void;
thus L228: D41 is  finite;
thus L229: D41 is  monotonic
proof
reconsider D42 = D41 as non  void non  empty ManySortedSign;
let C82 being  finitely-generated  non-empty MSAlgebra over D41;
reconsider D43 = C82 as  non-empty MSAlgebra over D42;
set D44 = the (SortSymbol of D42);
consider C83 being (GeneratorSet of D43) such that L230: C83 is  finite-yielding by L187;
reconsider D45 = ( C83 . D44 ) as  finite set by L230;
set D46 = the (OperSymbol of D42);
set D47 = ( D44 .--> ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) );
set D48 = ( D46 .--> ( Den (D46 , D43) ) );
reconsider D49 = C83 as (MSSubset of D43);
let C84 being set;
L231: D44 = ( {} ) by TARSKI:def 1;
reconsider D50 = D47 as  non-empty (ManySortedSet of (the carrier of D41)) by L231;
assume L232: C84 in (the carrier of D41);
L233: C84 = D44 by L232 , L231 , TARSKI:def 1;
reconsider D51 = D50 as (ManySortedSet of (the carrier of D42));
L234: ( Args (D46 , D43) ) = ( ( (the Sorts of D43) # ) . ( (the Arity of D41) . D46 ) ) by FUNCT_2:15
.= ( ( (the Sorts of D43) # ) . ( <*> (the carrier of D42) ) ) by FUNCOP_1:7
.= { ( {} ) } by PRE_CIRC:2;
L235: ( dom ( Den (D46 , D43) ) ) = { ( {} ) } by L234 , FUNCT_2:def 1;
L236:
now
let C85 being set;
assume L237: C85 in (the carrier' of D41);
L238: C85 = [ ( {} ) , { ( {} ) } ] by L237 , TARSKI:def 1;
L239: C85 = D46 by L238 , TARSKI:def 1;
L240: ( ( ( D50 # ) * (the Arity of D41) ) . C85 ) = ( ( D50 # ) . ( (the Arity of D41) . C85 ) ) by L237 , FUNCT_2:15
.= ( ( D50 # ) . ( <*> (the carrier of D41) ) ) by L237 , FUNCOP_1:7
.= { ( {} ) } by PRE_CIRC:2;
reconsider D52 = ( D48 . C85 ) as (Function of ( ( ( D50 # ) * (the Arity of D41) ) . C85 ) , ( Result (D46 , D43) )) by L240 , L234 , L239 , FUNCOP_1:72;
L241: ( D48 . C85 ) = ( Den (D46 , D43) ) by L239 , FUNCOP_1:72;
L242: ( rng D52 ) = { ( ( Den (D46 , D43) ) . ( {} ) ) } by L241 , L235 , FUNCT_1:4;
L243: ( ( D50 * (the ResultSort of D41) ) . C85 ) = ( D50 . ( (the ResultSort of D41) . C85 ) ) by L237 , FUNCT_2:15
.= ( D50 . D44 ) by L231 , L237 , FUNCOP_1:7
.= ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) by FUNCOP_1:72;
L244: ( rng D52 ) c= ( ( D50 * (the ResultSort of D41) ) . C85 ) by L243 , L242 , XBOOLE_1:7;
thus L245: ( D48 . C85 ) is (Function of ( ( ( D50 # ) * (the Arity of D41) ) . C85 ) , ( ( D50 * (the ResultSort of D41) ) . C85 )) by L244 , FUNCT_2:6;
end;
L246: D46 = [ ( {} ) , { ( {} ) } ] by TARSKI:def 1;
reconsider D53 = D48 as (ManySortedFunction of ( ( D50 # ) * (the Arity of D41) ) , ( D50 * (the ResultSort of D41) )) by L246 , L236 , PBOOLE:def 15;
L247:
now
let C86 being (MSSubset of D43);
assume L248: C86 = (the Sorts of MSAlgebra (# D50 , D53 #));
thus L249: C86 is  opers_closed
proof
let C87 being (OperSymbol of D42);
let C88 being set;
assume L250: C88 in ( rng ( ( Den (C87 , D43) ) | ( ( ( C86 # ) * (the Arity of D42) ) . C87 ) ) );
L251: C87 = D46 by L246 , TARSKI:def 1;
L252: (( dom (the ResultSort of D42) ) = { [ ( {} ) , { ( {} ) } ] } & ( (the ResultSort of D42) . D46 ) = D44) by L231 , FUNCOP_1:7 , FUNCOP_1:13;
L253: ( ( Den (D46 , D43) ) | { ( {} ) } ) = ( Den (D46 , D43) ) by L235 , RELAT_1:68;
L254: ( ( ( C86 # ) * (the Arity of D41) ) . D46 ) = ( ( C86 # ) . ( (the Arity of D41) . D46 ) ) by FUNCT_2:15
.= ( ( D50 # ) . ( <*> (the carrier of D41) ) ) by L248 , FUNCOP_1:7
.= { ( {} ) } by PRE_CIRC:2;
L255: (ex B59 being set st (B59 in ( dom ( Den (D46 , D43) ) ) & C88 = ( ( Den (D46 , D43) ) . B59 ))) by L254 , L251 , L253 , L250 , FUNCT_1:def 3;
L256: C88 = ( ( Den (D46 , D43) ) . ( {} ) ) by L255 , L234 , TARSKI:def 1;
L257: C88 in { ( ( Den (D46 , D43) ) . ( {} ) ) } by L256 , TARSKI:def 1;
L258: ( C86 . D44 ) = ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) by L248 , FUNCOP_1:72;
L259: C88 in ( C86 . D44 ) by L258 , L257 , XBOOLE_0:def 3;
thus L260: thesis by L259 , L251 , L252 , FUNCT_1:13;
end;

L261:
now
let C89 being (OperSymbol of D42);
L262: ( ( ( C86 # ) * (the Arity of D42) ) . D46 ) = ( ( C86 # ) . ( (the Arity of D42) . D46 ) ) by FUNCT_2:15
.= ( ( D50 # ) . ( <*> (the carrier of D42) ) ) by L248 , FUNCOP_1:7
.= { ( {} ) } by PRE_CIRC:2;
L263: ( ( Den (D46 , D43) ) | ( ( ( C86 # ) * (the Arity of D42) ) . D46 ) ) = ( Den (D46 , D43) ) by L262 , L235 , RELAT_1:68;
L264: ( (the Charact of MSAlgebra (# D50 , D53 #)) . D46 ) = ( ( Den (D46 , D43) ) | ( ( ( C86 # ) * (the Arity of D42) ) . D46 ) ) by L263 , FUNCOP_1:72;
L265: (C89 = D46 & C86 is_closed_on D46) by L246 , L249 , MSUALG_2:def 6 , TARSKI:def 1;
thus L266: ( (the Charact of MSAlgebra (# D50 , D53 #)) . C89 ) = ( C89 /. C86 ) by L265 , L264 , MSUALG_2:def 7;
end;
thus L267: (the Charact of MSAlgebra (# D50 , D53 #)) = ( Opers (D43 , C86) ) by L261 , L248 , MSUALG_2:def 8;
end;
reconsider D54 = MSAlgebra (# D50 , D53 #) as  non-empty MSAlgebra over D42 by MSUALG_1:def 3;
L268: ( Result (D46 , D43) ) = ( (the Sorts of D43) . ( (the ResultSort of D41) . D46 ) ) by FUNCT_2:15
.= ( (the Sorts of D43) . ( {} ) ) by FUNCOP_1:7;
L269: D51 c= (the Sorts of D43)
proof
let C90 being set;
assume L270: C90 in (the carrier of D42);
L271: C90 = ( {} ) by L270 , TARSKI:def 1;
L272: ( D51 . C90 ) = ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) by L271 , L231 , FUNCOP_1:72;
L273: C83 c= (the Sorts of D43) by PBOOLE:def 18;
L274: ( C83 . D44 ) c= ( (the Sorts of D43) . C90 ) by L273 , L231 , L271 , PBOOLE:def 2;
L275: ( dom ( Den (D46 , D43) ) ) = ( Args (D46 , D43) ) by FUNCT_2:def 1;
L276: ( {} ) in ( dom ( Den (D46 , D43) ) ) by L275 , L234 , TARSKI:def 1;
L277: ( ( Den (D46 , D43) ) . ( {} ) ) in ( rng ( Den (D46 , D43) ) ) by L276 , FUNCT_1:def 3;
L278: { ( ( Den (D46 , D43) ) . ( {} ) ) } c= ( (the Sorts of D43) . C90 ) by L277 , L268 , L271 , ZFMISC_1:31;
thus L279: thesis by L278 , L272 , L274 , XBOOLE_1:8;
end;
L280: (the Sorts of MSAlgebra (# D50 , D53 #)) is (MSSubset of D43) by L269 , PBOOLE:def 18;
reconsider D55 = D54 as  strict (MSSubAlgebra of D43) by L280 , L247 , MSUALG_2:def 9;
L281:
now
let C91 being (MSSubAlgebra of D43);
assume L282: D49 is (MSSubset of C91);
L283:
now
L284: ( Constants D43 ) is (MSSubset of C91) by MSUALG_2:10;
L285: ( Constants D43 ) c= (the Sorts of C91) by L284 , PBOOLE:def 18;
L286: ( ( Constants D43 ) . D44 ) c= ( (the Sorts of C91) . D44 ) by L285 , PBOOLE:def 2;
L287: ( Constants (D43 , D44) ) c= ( (the Sorts of C91) . D44 ) by L286 , MSUALG_2:def 4;
L288: ( {} ) in ( dom ( Den (D46 , D43) ) ) by L235 , TARSKI:def 1;
L289: ( ( Den (D46 , D43) ) . ( {} ) ) in ( rng ( Den (D46 , D43) ) ) by L288 , FUNCT_1:def 3;
reconsider D56 = ( ( Den (D46 , D43) ) . ( {} ) ) as (Element of ( (the Sorts of D43) . D44 )) by L289 , L268 , TARSKI:def 1;
let C92 being set;
L290: (( (the Arity of D42) . D46 ) = ( {} ) & (ex B60 being non  empty set st (B60 = ( (the Sorts of D43) . D44 ) & ( Constants (D43 , D44) ) = { B61 where B61 is (Element of B60) : (ex B62 being (OperSymbol of D42) st (( (the Arity of D42) . B62 ) = ( {} ) & ( (the ResultSort of D42) . B62 ) = D44 & B61 in ( rng ( Den (B62 , D43) ) ))) }))) by FUNCOP_1:7 , MSUALG_2:def 3;
L291: D56 in ( rng ( Den (D46 , D43) ) ) by L288 , FUNCT_1:def 3;
L292: ( ( Den (D46 , D43) ) . ( {} ) ) in ( Constants (D43 , D44) ) by L291 , L231 , L290;
L293: { ( ( Den (D46 , D43) ) . ( {} ) ) } c= ( (the Sorts of C91) . D44 ) by L292 , L287 , ZFMISC_1:31;
L294: C83 c= (the Sorts of C91) by L282 , PBOOLE:def 18;
L295: (( (the Sorts of D55) . D44 ) = ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) & ( C83 . D44 ) c= ( (the Sorts of C91) . D44 )) by L294 , FUNCOP_1:72 , PBOOLE:def 2;
assume L296: C92 in (the carrier of D42);
L297: C92 = D44 by L296 , L231 , TARSKI:def 1;
thus L298: ( (the Sorts of D55) . C92 ) c= ( (the Sorts of C91) . C92 ) by L297 , L295 , L293 , XBOOLE_1:8;
end;
L299: (the Sorts of D55) c= (the Sorts of C91) by L283 , PBOOLE:def 2;
thus L300: D55 is (MSSubAlgebra of C91) by L299 , MSUALG_2:8;
end;
L301:
now
let C93 being set;
assume L302: C93 in (the carrier of D42);
L303: C93 = D44 by L302 , L231 , TARSKI:def 1;
L304: ( (the Sorts of D55) . D44 ) = ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) by FUNCOP_1:72;
thus L305: ( D49 . C93 ) c= ( (the Sorts of D55) . C93 ) by L304 , L303 , XBOOLE_1:7;
end;
L306: D49 c= (the Sorts of D55) by L301 , PBOOLE:def 2;
L307: D49 is (MSSubset of D55) by L306 , PBOOLE:def 18;
L308: ( D44 .--> ( ( C83 . D44 ) \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) ) = (the Sorts of ( GenMSAlg C83 )) by L307 , L281 , MSUALG_2:def 17
.= (the Sorts of D43) by MSAFREE:def 4;
L309: ( (the Sorts of C82) . C84 ) = ( D45 \/ { ( ( Den (D46 , D43) ) . ( {} ) ) } ) by L308 , L233 , FUNCOP_1:72;
thus L310: thesis by L309;
end;

thus L311: D41 is  Circuit-like
proof
let C94 being non  void non  empty ManySortedSign;
assume L312: C94 = D41;
let C95 , C96 being (OperSymbol of C94);
assume that
L313: ( the_result_sort_of C95 ) = ( the_result_sort_of C96 );
L314: C95 = [ ( {} ) , { ( {} ) } ] by L312 , TARSKI:def 1;
thus L315: thesis by L314 , L312 , TARSKI:def 1;
end;

end;
end;
theorem
L313: (for B63 being non  void non  empty ManySortedSign holds (for B64 being  non-empty (ManySortedSet of (the carrier of B63)) holds (for B65 being (SortSymbol of B63) holds (for B66 being (Element of ( (the Sorts of ( FreeMSA B64 )) . B65 )) holds B66 is  finite  finite  finite  finite DecoratedTree))))
proof
let C97 being non  void non  empty ManySortedSign;
let C98 being  non-empty (ManySortedSet of (the carrier of C97));
let C99 being (SortSymbol of C97);
let C100 being (Element of ( (the Sorts of ( FreeMSA C98 )) . C99 ));
L314: ( FreeMSA C98 ) = MSAlgebra (# ( FreeSort C98 ) , ( FreeOper C98 ) #) by MSAFREE:def 14;
L315: ( (the Sorts of ( FreeMSA C98 )) . C99 ) = ( FreeSort (C98 , C99) ) by L314 , MSAFREE:def 11;
L316: C100 in ( TS ( DTConMSA C98 ) ) by L315 , TARSKI:def 3;
reconsider D57 = C100 as DecoratedTree by L316;
L317: ( dom D57 ) is  finite by L316;
thus L318: thesis by L317 , FINSET_1:10;
end;
theorem
L319: (for B67 being non  void non  empty ManySortedSign holds (for B68 being  non-empty  finite-yielding (ManySortedSet of (the carrier of B67)) holds ( FreeMSA B68 ) is  finitely-generated))
proof
let C101 being non  void non  empty ManySortedSign;
let C102 being  non-empty  finite-yielding (ManySortedSet of (the carrier of C101));
per cases ;
case L320: C101 is non  void;
reconsider D58 = ( FreeGen C102 ) as (GeneratorSet of ( FreeMSA C102 ));
let C103 being non  void non  empty ManySortedSign;
assume that
L321: C103 = C101;
let C104 being MSAlgebra over C103;
assume L322: C104 = ( FreeMSA C102 );
reconsider D59 = D58 as (GeneratorSet of C104) by L322 , L321;
take D59;
thus L323: D59 is  finite-yielding
proof
let C105 being set;
reconsider D60 = ( D59 . C105 ) as set;
assume L324: C105 in (the carrier of C103);
reconsider D61 = C105 as (SortSymbol of C101) by L324 , L321;
reconsider D62 = ( C102 . D61 ) as non  empty  finite set;
L325:
now
defpred S5[ set , set ] means $1 = ( root-tree [ $2 , C105 ] );
L326: (for B69 being set holds (B69 in D60 implies (ex B70 being set st (B70 in D62 & S5[ B69 , B70 ]))))
proof
L327: D60 = ( FreeGen (D61 , C102) ) by MSAFREE:def 16;
let C106 being set;
assume L328: C106 in D60;
consider C107 being set such that L329: (C107 in D62 & C106 = ( root-tree [ C107 , C105 ] )) by L328 , L327 , MSAFREE:def 15;
take C107;
thus L330: thesis by L329;
end;
consider C108 being Function such that L331: ( dom C108 ) = D60 and L332: ( rng C108 ) c= D62 and L333: (for B71 being set holds (B71 in D60 implies S5[ B71 , ( C108 . B71 ) ])) from FUNCT_1:sch 5(L326);
take D63 = C108;
L334: D63 is  one-to-one
proof
let C109 , C110 being set;
assume that
L335: C109 in ( dom D63 )
and
L336: C110 in ( dom D63 )
and
L337: ( D63 . C109 ) = ( D63 . C110 );
thus L338: C109 = ( root-tree [ ( D63 . C110 ) , C105 ] ) by L331 , L333 , L335 , L337
.= C110 by L331 , L333 , L336;
end;
thus L339: (ex B72 being Function st (B72 is  one-to-one & ( dom B72 ) = D60 & ( rng B72 ) c= D62)) by L334 , L331 , L332;
end;
L340: (( card D60 ) c= ( card D62 ) or ( card D60 ) in ( card D62 )) by L325 , CARD_1:10;
thus L341: thesis by L340 , CARD_2:49;
end;

end;
case L324: C101 is  void;
thus L325: thesis by L324;
end;
end;
theorem
L327: (for B73 being non  void non  empty ManySortedSign holds (for B74 being  non-empty MSAlgebra over B73 holds (for B75 being (Vertex of B73) holds (for B76 being (Element of ( (the Sorts of ( FreeEnv B74 )) . B75 )) holds (B75 in ( InputVertices B73 ) implies (ex B77 being (Element of ( (the Sorts of B74) . B75 )) st B76 = ( root-tree [ B77 , B75 ] )))))))
proof
let C111 being non  void non  empty ManySortedSign;
let C112 being  non-empty MSAlgebra over C111;
let C113 being (Vertex of C111);
let C114 being (Element of ( (the Sorts of ( FreeEnv C112 )) . C113 ));
L328: ( FreeEnv C112 ) = MSAlgebra (# ( FreeSort (the Sorts of C112) ) , ( FreeOper (the Sorts of C112) ) #) by MSAFREE:def 14;
L329: C114 in ( ( FreeSort (the Sorts of C112) ) . C113 ) by L328;
L330: C114 in ( FreeSort ((the Sorts of C112) , C113) ) by L329 , MSAFREE:def 11;
L331: C114 in { B78 where B78 is (Element of ( TS ( DTConMSA (the Sorts of C112) ) )) : ((ex B79 being set st (B79 in ( (the Sorts of C112) . C113 ) & B78 = ( root-tree [ B79 , C113 ] ))) or (ex B80 being (OperSymbol of C111) st ([ B80 , (the carrier of C111) ] = ( B78 . ( {} ) ) & ( the_result_sort_of B80 ) = C113))) } by L330 , MSAFREE:def 10;
consider C115 being (Element of ( TS ( DTConMSA (the Sorts of C112) ) )) such that L332: C115 = C114 and L333: ((ex B81 being set st (B81 in ( (the Sorts of C112) . C113 ) & C115 = ( root-tree [ B81 , C113 ] ))) or (ex B82 being (OperSymbol of C111) st ([ B82 , (the carrier of C111) ] = ( C115 . ( {} ) ) & ( the_result_sort_of B82 ) = C113))) by L331;
assume L334: C113 in ( InputVertices C111 );
consider C116 being set such that L335: C116 in ( (the Sorts of C112) . C113 ) and L336: C115 = ( root-tree [ C116 , C113 ] ) by L334 , L333 , L12;
reconsider D64 = C116 as (Element of ( (the Sorts of C112) . C113 )) by L335;
take D64;
thus L337: thesis by L332 , L336;
end;
theorem
L338: (for B83 being non  void non  empty ManySortedSign holds (for B84 being  non-empty (ManySortedSet of (the carrier of B83)) holds (for B85 being (OperSymbol of B83) holds (for B86 being  DTree-yielding FinSequence holds (( [ B85 , (the carrier of B83) ] -tree B86 ) in ( (the Sorts of ( FreeMSA B84 )) . ( the_result_sort_of B85 ) ) implies ( len B86 ) = ( len ( the_arity_of B85 ) ))))))
proof
let C117 being non  void non  empty ManySortedSign;
let C118 being  non-empty (ManySortedSet of (the carrier of C117));
let C119 being (OperSymbol of C117);
let C120 being  DTree-yielding FinSequence;
set D65 = ( the_result_sort_of C119 );
assume L339: ( [ C119 , (the carrier of C117) ] -tree C120 ) in ( (the Sorts of ( FreeMSA C118 )) . ( the_result_sort_of C119 ) );
L340: ( FreeMSA C118 ) = MSAlgebra (# ( FreeSort C118 ) , ( FreeOper C118 ) #) by MSAFREE:def 14;
L341: ( [ C119 , (the carrier of C117) ] -tree C120 ) in ( FreeSort (C118 , D65) ) by L340 , L339 , MSAFREE:def 11;
L342: ( [ C119 , (the carrier of C117) ] -tree C120 ) in { B87 where B87 is (Element of ( TS ( DTConMSA C118 ) )) : ((ex B88 being set st (B88 in ( C118 . D65 ) & B87 = ( root-tree [ B88 , D65 ] ))) or (ex B89 being (OperSymbol of C117) st ([ B89 , (the carrier of C117) ] = ( B87 . ( {} ) ) & ( the_result_sort_of B89 ) = D65))) } by L341 , MSAFREE:def 10;
L343: (the carrier of C117) in { (the carrier of C117) } by TARSKI:def 1;
L344: [ C119 , (the carrier of C117) ] in [: (the carrier' of C117) , { (the carrier of C117) } :] by L343 , ZFMISC_1:87;
reconsider D66 = [ C119 , (the carrier of C117) ] as (NonTerminal of ( DTConMSA C118 )) by L344 , MSAFREE:6;
reconsider D67 = ( [: (the carrier' of C117) , { (the carrier of C117) } :] \/ ( Union ( coprod C118 ) ) ) as non  empty set;
reconsider D68 = ( REL C118 ) as (Relation of D67 , ( D67 * ));
L345: ( DTConMSA C118 ) = DTConstrStr (# D67 , D68 #) by MSAFREE:def 8;
reconsider D69 = ( TS ( DTConMSA C118 ) ) as (Subset of ( FinTrees D67 )) by L345;
reconsider D70 = D66 as (Element of D67) by L345;
L346: (for B90 being set holds (B90 in D69 implies B90 is (DecoratedTree of D67)));
reconsider D71 = D69 as (DTree-set of D67) by L346 , TREES_3:def 6;
consider C121 being (Element of ( TS ( DTConMSA C118 ) )) such that L347: C121 = ( [ C119 , (the carrier of C117) ] -tree C120 ) and L348: ((ex B91 being set st (B91 in ( C118 . D65 ) & C121 = ( root-tree [ B91 , D65 ] ))) or (ex B92 being (OperSymbol of C117) st ([ B92 , (the carrier of C117) ] = ( C121 . ( {} ) ) & ( the_result_sort_of B92 ) = D65))) by L342;
L349: ( C121 . ( {} ) ) = [ C119 , (the carrier of C117) ] by L347 , TREES_4:def 4;
consider C122 being (FinSequence of ( TS ( DTConMSA C118 ) )) such that L350: C121 = ( D66 -tree C122 ) and L351: D66 ==> ( roots C122 ) by L349 , DTCONSTR:10;
reconsider D72 = C122 as (FinSequence of D71);
reconsider D73 = ( roots D72 ) as (FinSequence of D67);
reconsider D74 = D73 as (Element of ( D67 * )) by FINSEQ_1:def 11;
L352: [ D70 , D74 ] in D68 by L351 , L345 , LANG1:def 1;
L353: ( len ( roots C122 ) ) = ( len ( the_arity_of C119 ) ) by L352 , MSAFREE:def 7;
reconsider D75 = C122 as  DTree-yielding FinSequence;
L354: ( dom ( roots D75 ) ) = ( dom D75 ) by TREES_3:def 18;
L355: D75 = C120 by L347 , L350 , TREES_4:15;
thus L356: thesis by L355 , L353 , L354 , FINSEQ_3:29;
end;
theorem
L357: (for B93 being non  void non  empty ManySortedSign holds (for B94 being  non-empty (ManySortedSet of (the carrier of B93)) holds (for B95 being (OperSymbol of B93) holds (for B96 being  DTree-yielding FinSequence holds (( [ B95 , (the carrier of B93) ] -tree B96 ) in ( (the Sorts of ( FreeMSA B94 )) . ( the_result_sort_of B95 ) ) implies (for B97 being Nat holds (B97 in ( dom ( the_arity_of B95 ) ) implies ( B96 . B97 ) in ( (the Sorts of ( FreeMSA B94 )) . ( ( the_arity_of B95 ) . B97 ) ))))))))
proof
let C123 being non  void non  empty ManySortedSign;
let C124 being  non-empty (ManySortedSet of (the carrier of C123));
let C125 being (OperSymbol of C123);
let C126 being  DTree-yielding FinSequence;
L358: ( FreeMSA C124 ) = MSAlgebra (# ( FreeSort C124 ) , ( FreeOper C124 ) #) by MSAFREE:def 14;
assume L359: ( [ C125 , (the carrier of C123) ] -tree C126 ) in ( (the Sorts of ( FreeMSA C124 )) . ( the_result_sort_of C125 ) );
L360:
now
L361: (the carrier of C123) in { (the carrier of C123) } by TARSKI:def 1;
L362: [ C125 , (the carrier of C123) ] in [: (the carrier' of C123) , { (the carrier of C123) } :] by L361 , ZFMISC_1:87;
reconsider D76 = [ C125 , (the carrier of C123) ] as (NonTerminal of ( DTConMSA C124 )) by L362 , MSAFREE:6;
set D77 = ( the_result_sort_of C125 );
reconsider D78 = ( the_arity_of C125 ) as (Element of ( (the carrier of C123) * ));
let C127 being Nat;
assume L363: C127 in ( dom ( the_arity_of C125 ) );
L364: ( D78 . C127 ) in ( rng D78 ) by L363 , FUNCT_1:def 3;
reconsider D79 = ( D78 . C127 ) as (SortSymbol of C123) by L364;
L365: ( (the Sorts of ( FreeMSA C124 )) . D79 ) = ( FreeSort (C124 , D79) ) by L358 , MSAFREE:def 11
.= ( FreeSort (C124 , ( ( the_arity_of C125 ) /. C127 )) ) by L363 , PARTFUN1:def 6;
L366: ( [ C125 , (the carrier of C123) ] -tree C126 ) in ( FreeSort (C124 , D77) ) by L359 , L358 , MSAFREE:def 11;
L367: ( [ C125 , (the carrier of C123) ] -tree C126 ) in { B98 where B98 is (Element of ( TS ( DTConMSA C124 ) )) : ((ex B99 being set st (B99 in ( C124 . D77 ) & B98 = ( root-tree [ B99 , D77 ] ))) or (ex B100 being (OperSymbol of C123) st ([ B100 , (the carrier of C123) ] = ( B98 . ( {} ) ) & ( the_result_sort_of B100 ) = D77))) } by L366 , MSAFREE:def 10;
consider C128 being (Element of ( TS ( DTConMSA C124 ) )) such that L368: C128 = ( [ C125 , (the carrier of C123) ] -tree C126 ) and L369: ((ex B101 being set st (B101 in ( C124 . D77 ) & C128 = ( root-tree [ B101 , D77 ] ))) or (ex B102 being (OperSymbol of C123) st ([ B102 , (the carrier of C123) ] = ( C128 . ( {} ) ) & ( the_result_sort_of B102 ) = D77))) by L367;
L370: ( C128 . ( {} ) ) = [ C125 , (the carrier of C123) ] by L368 , TREES_4:def 4;
consider C129 being (FinSequence of ( TS ( DTConMSA C124 ) )) such that L371: C128 = ( D76 -tree C129 ) and L372: D76 ==> ( roots C129 ) by L370 , DTCONSTR:10;
L373: D76 = ( Sym (C125 , C124) ) by MSAFREE:def 9;
L374: C129 in ( ( ( ( FreeSort C124 ) # ) * (the Arity of C123) ) . C125 ) by L373 , L372 , MSAFREE:10;
L375: (( dom C126 ) = ( Seg ( len C126 ) ) & ( dom ( the_arity_of C125 ) ) = ( Seg ( len ( the_arity_of C125 ) ) )) by FINSEQ_1:def 3;
L376: C127 in ( dom C126 ) by L375 , L359 , L363 , L338;
reconsider D80 = C129 as  DTree-yielding FinSequence;
L377: D80 = C126 by L368 , L371 , TREES_4:15;
thus L378: ( C126 . C127 ) in ( (the Sorts of ( FreeMSA C124 )) . ( ( the_arity_of C125 ) . C127 ) ) by L377 , L376 , L374 , L365 , MSAFREE:9;
end;
thus L379: thesis by L360;
end;
registration
let C130 being non  void non  empty ManySortedSign;
let C131 being  non-empty (ManySortedSet of (the carrier of C130));
let C132 being (Vertex of C130);
cluster  ->  finite non  empty  Function-like  Relation-like for (Element of ( (the Sorts of ( FreeMSA C131 )) . C132 ));
coherence
proof
let C133 being (Element of ( (the Sorts of ( FreeMSA C131 )) . C132 ));
reconsider D81 = C133 as DecoratedTree by L313;
thus L380: C133 is  finite by L313;
L381: ( dom D81 ) is Tree;
thus L382: C133 is non  empty by L381;
thus L383: thesis by L313;
end;
end;
registration
let C134 being non  void non  empty ManySortedSign;
let C135 being  non-empty (ManySortedSet of (the carrier of C134));
let C136 being (Vertex of C134);
cluster  Function-like  Relation-like for (Element of ( (the Sorts of ( FreeMSA C135 )) . C136 ));
existence
proof
set D82 = the (Element of ( (the Sorts of ( FreeMSA C135 )) . C136 ));
take D82;
thus L385: thesis;
end;
end;
registration
let C137 being non  void non  empty ManySortedSign;
let C138 being  non-empty (ManySortedSet of (the carrier of C137));
let C139 being (Vertex of C137);
cluster  ->  DecoratedTree-like for  Function-like  Relation-like  Function-like  Relation-like  Function-like  Relation-like  Function-like  Relation-like (Element of ( (the Sorts of ( FreeMSA C138 )) . C139 ));
coherence by L313;
end;
registration
let C140 being non  void non  empty ManySortedSign;
let C141 being  non-empty (ManySortedSet of (the carrier of C140));
let C142 being (Vertex of C140);
cluster  finite for (Element of ( (the Sorts of ( FreeMSA C141 )) . C142 ));
existence
proof
set D83 = the (Element of ( (the Sorts of ( FreeMSA C141 )) . C142 ));
take D83;
thus L388: thesis;
end;
end;
theorem
L390: (for B103 being non  void non  empty ManySortedSign holds (for B104 being  non-empty (ManySortedSet of (the carrier of B103)) holds (for B105 being (Vertex of B103) holds (for B106 being (OperSymbol of B103) holds (for B107 being (Element of ( (the Sorts of ( FreeMSA B104 )) . B105 )) holds (( B107 . ( {} ) ) = [ B106 , (the carrier of B103) ] implies (ex B108 being  DTree-yielding FinSequence st (( len B108 ) = ( len ( the_arity_of B106 ) ) & (for B109 being Nat holds (B109 in ( dom B108 ) implies ( B108 . B109 ) in ( (the Sorts of ( FreeMSA B104 )) . ( ( the_arity_of B106 ) . B109 ) )))))))))))
proof
let C143 being non  void non  empty ManySortedSign;
let C144 being  non-empty (ManySortedSet of (the carrier of C143));
let C145 being (Vertex of C143);
let C146 being (OperSymbol of C143);
let C147 being (Element of ( (the Sorts of ( FreeMSA C144 )) . C145 ));
assume that
L391: ( C147 . ( {} ) ) = [ C146 , (the carrier of C143) ];
L392: (the carrier of C143) in { (the carrier of C143) } by TARSKI:def 1;
L393: [ C146 , (the carrier of C143) ] in [: (the carrier' of C143) , { (the carrier of C143) } :] by L392 , ZFMISC_1:87;
reconsider D84 = [ C146 , (the carrier of C143) ] as (NonTerminal of ( DTConMSA C144 )) by L393 , MSAFREE:6;
L394: ( FreeMSA C144 ) = MSAlgebra (# ( FreeSort C144 ) , ( FreeOper C144 ) #) by MSAFREE:def 14;
L395: ( (the Sorts of ( FreeMSA C144 )) . C145 ) = ( FreeSort (C144 , C145) ) by L394 , MSAFREE:def 11;
L396: C147 in ( FreeSort (C144 , C145) ) by L395;
L397: C147 in { B110 where B110 is (Element of ( TS ( DTConMSA C144 ) )) : ((ex B111 being set st (B111 in ( C144 . C145 ) & B110 = ( root-tree [ B111 , C145 ] ))) or (ex B112 being (OperSymbol of C143) st ([ B112 , (the carrier of C143) ] = ( B110 . ( {} ) ) & ( the_result_sort_of B112 ) = C145))) } by L396 , MSAFREE:def 10;
consider C148 being (Element of ( TS ( DTConMSA C144 ) )) such that L398: C148 = C147 and L399: ((ex B113 being set st (B113 in ( C144 . C145 ) & C148 = ( root-tree [ B113 , C145 ] ))) or (ex B114 being (OperSymbol of C143) st ([ B114 , (the carrier of C143) ] = ( C148 . ( {} ) ) & ( the_result_sort_of B114 ) = C145))) by L397;
consider C149 being set such that L400: ((C149 in ( C144 . C145 ) & C148 = ( root-tree [ C149 , C145 ] )) or (ex B115 being (OperSymbol of C143) st ([ B115 , (the carrier of C143) ] = ( C148 . ( {} ) ) & ( the_result_sort_of B115 ) = C145))) by L399;
consider C150 being (FinSequence of ( TS ( DTConMSA C144 ) )) such that L401: C148 = ( D84 -tree C150 ) and L402: D84 ==> ( roots C150 ) by L391 , L398 , DTCONSTR:10;
L403:
now
assume L404: C148 = ( root-tree [ C149 , C145 ] );
L405: ( C148 . ( {} ) ) = [ C149 , C145 ] by L404 , TREES_4:3;
L406: (for B116 being set holds (not B116 in B116));
L407: ( C148 . ( {} ) ) = [ C146 , (the carrier of C143) ] by L401 , TREES_4:def 4;
L408: (the carrier of C143) = C145 by L407 , L405 , XTUPLE_0:1;
thus L409: contradiction by L408 , L406;
end;
consider C151 being (OperSymbol of C143) such that L410: [ C151 , (the carrier of C143) ] = ( C148 . ( {} ) ) and L411: ( the_result_sort_of C151 ) = C145 by L403 , L400;
L412: C146 = C151 by L391 , L398 , L410 , XTUPLE_0:1;
L413: ( len C150 ) = ( len ( the_arity_of C146 ) ) by L412 , L398 , L401 , L411 , L338;
L414: ( dom C150 ) = ( Seg ( len ( the_arity_of C146 ) ) ) by L413 , FINSEQ_1:def 3
.= ( dom ( the_arity_of C146 ) ) by FINSEQ_1:def 3;
L415: (for B117 being Nat holds (B117 in ( dom C150 ) implies ( C150 . B117 ) in ( (the Sorts of ( FreeMSA C144 )) . ( ( the_arity_of C146 ) . B117 ) ))) by L414 , L398 , L401 , L411 , L412 , L357;
thus L416: thesis by L415 , L413;
end;
definition
let C152 being non  void non  empty ManySortedSign;
let C153 being  non-empty (ManySortedSet of (the carrier of C152));
let C154 being (SortSymbol of C152);
let C155 being (Element of ( (the Sorts of ( FreeMSA C153 )) . C154 ));
func depth C155 -> Nat means 
(ex B118 being  finite DecoratedTree st (ex B119 being  finite Tree st (B118 = C155 & B119 = ( dom B118 ) & it = ( height B119 ))));
existence
proof
reconsider D85 = C155 as  finite DecoratedTree;
reconsider D86 = ( dom D85 ) as  finite Tree;
take ( height D86 );
take D85;
take D86;
thus L417: thesis;
end;
uniqueness;
end;
