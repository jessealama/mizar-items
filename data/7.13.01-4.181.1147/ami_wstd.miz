:: Weakly Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 22, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ORDINAL1, AMI_1, FSM_1, FUNCT_4,
      FUNCOP_1, RELAT_1, TARSKI, FUNCT_1, CARD_3, ZFMISC_1, CIRCUIT2, NAT_1,
      GLIB_000, XXREAL_0, PARTFUN1, FINSEQ_1, ARYTM_3, GRAPH_2, CARD_1,
      FUNCT_2, FINSEQ_4, ARYTM_1, FINSET_1, FRECHET, WAYBEL_0, MEMBERED,
      AMISTD_1, EXTPRO_1, AMI_WSTD, STRUCT_0, COMPOS_1, QUANTAL1, GOBRD13,
      MEMSTR_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, RELAT_1, ORDINAL1, CARD_1,
      XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4, FUNCOP_1, FINSET_1,
      FUNCT_4, FUNCT_7, MEASURE6, STRUCT_0, GRAPH_2, NAT_D, XXREAL_2, MEMSTR_0,
      COMPOS_0, COMPOS_1, EXTPRO_1, FUNCT_2, AMISTD_1;
 constructors WELLORD2, REAL_1, FINSEQ_4, REALSET1, NAT_D, XXREAL_2, RELSET_1,
      PRE_POLY, GRAPH_2, AMISTD_1, FUNCT_7, FUNCT_4, PBOOLE, XTUPLE_0;
 registrations RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCOP_1, FINSET_1,
      XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, FUNCT_7, JORDAN1J, CARD_1,
      XXREAL_2, RELSET_1, FUNCT_4, AMISTD_1, EXTPRO_1, PRE_POLY, MEMSTR_0,
      MEASURE6, COMPOS_0, XTUPLE_0;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, EXTPRO_1, XBOOLE_0, FUNCOP_1, NAT_1, AMISTD_1,
      MEMSTR_0, XTUPLE_0;
 theorems TARSKI, FINSEQ_4, FINSEQ_1, GRAPH_2, NAT_1, FUNCT_4, FUNCT_1,
      FUNCT_2, ZFMISC_1, CARD_1, FUNCOP_1, ORDINAL1, GRFUNC_1, FINSEQ_3, INT_1,
      REVROT_1, FUNCT_7, XBOOLE_0, MEMBERED, XREAL_1, XXREAL_0, FINSEQ_6,
      PARTFUN1, XXREAL_2, XREAL_0, NAT_D, PBOOLE, RECDEF_2, AMISTD_1, MEMSTR_0,
      CARD_3;
 schemes NAT_1, FUNCT_7, FINSEQ_2, FRAENKEL, DOMAIN_1, FINSEQ_4;

begin
begin
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C1 , C2 being Nat;
pred C1 <= C2 , R7
means
:L1: (ex B1 being non  empty (FinSequence of ( NAT )) st (( B1 /. 1 ) = C1 & ( B1 /. ( len B1 ) ) = C2 & (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len B1 )) implies ( B1 /. ( R4 + 1 ) ) in ( SUCC (( B1 /. R4 ) , R7) )))))
;end;
theorem
L3: (for R12 being (Element of ( NAT )) holds (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B2 , B3 being Nat holds ((B2 <= B3 , R7 & B3 <= R12 , R7) implies B2 <= R12 , R7)))))
proof
let R12 being (Element of ( NAT ));
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C3 , C4 being Nat;
given C5 being non  empty (FinSequence of ( NAT )) such that
L4: ( C5 /. 1 ) = C3
and
L5: ( C5 /. ( len C5 ) ) = C4
and
L6: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len C5 )) implies ( C5 /. ( R4 + 1 ) ) in ( SUCC (( C5 /. R4 ) , R7) )));

given C6 being non  empty (FinSequence of ( NAT )) such that
L7: ( C6 /. 1 ) = C4
and
L8: ( C6 /. ( len C6 ) ) = R12
and
L9: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len C6 )) implies ( C6 /. ( R4 + 1 ) ) in ( SUCC (( C6 /. R4 ) , R7) )));

take ( C5 ^' C6 );
thus L10: ( ( C5 ^' C6 ) /. 1 ) = C3 by L4 , GRAPH_2:53;
L11:
now
per cases ;
suppose L12: C6 is  trivial;

L13: (ex B4 being (Element of ( NAT )) st C6 = <* B4 *>) by L12 , FINSEQ_6:107;
L14: ( C5 ^' C6 ) = C5 by L13 , GRAPH_2:56;
thus L15: ( ( C5 ^' C6 ) /. ( len ( C5 ^' C6 ) ) ) = R12 by L14 , L5 , L7 , L8 , L13 , FINSEQ_1:39;
end;
suppose L16: (not C6 is  trivial);

thus L17: ( ( C5 ^' C6 ) /. ( len ( C5 ^' C6 ) ) ) = R12 by L16 , L8 , GRAPH_2:54;
end;
end;
thus L19: ( ( C5 ^' C6 ) /. ( len ( C5 ^' C6 ) ) ) = R12 by L11;
let R4 being (Element of ( NAT ));
assume that
L20: 1 <= R4
and
L21: R4 < ( len ( C5 ^' C6 ) );
L22: ( ( len ( C5 ^' C6 ) ) + 1 ) = ( ( len C5 ) + ( len C6 ) ) by GRAPH_2:13;
per cases  by XXREAL_0:1;
suppose L23: R4 < ( len C5 );

L24: ( R4 + 1 ) <= ( len C5 ) by L23 , NAT_1:13;
L25: ( ( C5 ^' C6 ) /. ( R4 + 1 ) ) = ( C5 /. ( R4 + 1 ) ) by L24 , GRAPH_2:57 , NAT_1:11;
L26: ( ( C5 ^' C6 ) /. R4 ) = ( C5 /. R4 ) by L20 , L23 , GRAPH_2:57;
thus L27: thesis by L26 , L6 , L20 , L23 , L25;
end;
suppose L28: R4 = ( len C5 );

L29: ( ( C5 ^' C6 ) /. R4 ) = ( C6 /. 1 ) by L28 , L5 , L7 , L20 , GRAPH_2:57;
L30: ( R4 + 1 ) < ( ( len ( C5 ^' C6 ) ) + 1 ) by L21 , XREAL_1:6;
L31: 1 < ( len C6 ) by L30 , L22 , L28 , XREAL_1:6;
L32: ( ( C5 ^' C6 ) /. ( R4 + 1 ) ) = ( C6 /. ( 1 + 1 ) ) by L31 , L28 , GRAPH_2:58;
thus L33: thesis by L32 , L9 , L29 , L31;
end;
suppose L34: R4 > ( len C5 );

consider C7 being Nat such that L35: ( ( len C5 ) + C7 ) = R4 by L34 , NAT_1:10;
reconsider D1 = C7 as (Element of ( NAT )) by ORDINAL1:def 12;
L36: ( ( len C5 ) + D1 ) > ( ( len C5 ) + ( 0 ) ) by L34 , L35;
L37: ( ( ( len C5 ) + D1 ) + 1 ) < ( ( len C5 ) + ( len C6 ) ) by L21 , L22 , L35 , XREAL_1:6;
L38: ( ( len C5 ) + ( D1 + 1 ) ) < ( ( len C5 ) + ( len C6 ) ) by L37;
L39: ( D1 + 1 ) < ( len C6 ) by L38 , XREAL_1:6;
L40: ( ( C5 ^' C6 ) /. ( R4 + 1 ) ) = ( ( C5 ^' C6 ) /. ( ( len C5 ) + ( D1 + 1 ) ) ) by L35
.= ( C6 /. ( ( D1 + 1 ) + 1 ) ) by L39 , GRAPH_2:58 , NAT_1:11;
L41: D1 <= ( D1 + 1 ) by NAT_1:11;
L42: D1 < ( len C6 ) by L41 , L39 , XXREAL_0:2;
L43: ( ( C5 ^' C6 ) /. R4 ) = ( C6 /. ( D1 + 1 ) ) by L42 , L35 , L36 , GRAPH_2:58 , NAT_1:14;
thus L44: thesis by L43 , L9 , L39 , L40 , NAT_1:11;
end;
end;
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
attr R7 is  InsLoc-antisymmetric
means
(for R10 being (Element of ( NAT )) holds (for R11 being (Element of ( NAT )) holds ((R10 <= R11 , R7 & R11 <= R10 , R7) implies R10 = R11)));
end;
definition
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
attr R7 is  weakly_standard
means
:L47: (ex B5 being (Function of ( NAT ) , ( NAT )) st (B5 is  bijective & (for B6 , B7 being (Element of ( NAT )) holds (B6 <= B7 iff ( B5 . B6 ) <= ( B5 . B7 ) , R7))));
end;
theorem
L49: (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B8 , B9 being (Function of ( NAT ) , ( NAT )) holds ((B8 is  bijective & (for B10 , B11 being (Element of ( NAT )) holds (B10 <= B11 iff ( B8 . B10 ) <= ( B8 . B11 ) , R7)) & B9 is  bijective & (for B12 , B13 being (Element of ( NAT )) holds (B12 <= B13 iff ( B9 . B12 ) <= ( B9 . B13 ) , R7))) implies B8 = B9))))
proof
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C8 , C9 being (Function of ( NAT ) , ( NAT ));
assume that
L50: C8 is  bijective
and
L51: (for B14 , B15 being (Element of ( NAT )) holds (B14 <= B15 iff ( C8 . B14 ) <= ( C8 . B15 ) , R7))
and
L52: C9 is  bijective
and
L53: (for B16 , B17 being (Element of ( NAT )) holds (B16 <= B17 iff ( C9 . B16 ) <= ( C9 . B17 ) , R7));
L54: ( dom C8 ) = ( NAT ) by FUNCT_2:def 1;
L55: ( dom C9 ) = ( NAT ) by FUNCT_2:def 1;
defpred S1[ Nat ] means ( C8 . $1 ) <> ( C9 . $1 );
assume L56: C8 <> C9;
L57: (ex B18 being (Element of ( NAT )) st S1[ B18 ]) by L56 , FUNCT_2:63;
L58: (ex B19 being Nat st S1[ B19 ]) by L57;
consider C10 being Nat such that L59: S1[ C10 ] and L60: (for B20 being Nat holds (S1[ B20 ] implies C10 <= B20)) from NAT_1:sch 5(L58);
reconsider D2 = C10 as (Element of ( NAT )) by ORDINAL1:def 12;
L61: ( rng C8 ) = ( NAT ) by L50 , FUNCT_2:def 3;
L62: ( rng C9 ) = ( NAT ) by L52 , FUNCT_2:def 3;
consider C11 being set such that L63: C11 in ( dom C8 ) and L64: ( C9 . D2 ) = ( C8 . C11 ) by L61 , FUNCT_1:def 3;
reconsider D3 = C11 as (Element of ( NAT )) by L63;
consider C12 being set such that L65: C12 in ( dom C9 ) and L66: ( C8 . D2 ) = ( C9 . C12 ) by L62 , FUNCT_1:def 3;
reconsider D4 = C12 as (Element of ( NAT )) by L65;
per cases ;
suppose L67: (D3 <= D2 & D4 <= D2);

L68: ( C9 . D4 ) <= ( C9 . D2 ) , R7 by L67 , L53;
L69: D2 <= D3 by L68 , L51 , L66 , L64;
thus L70: contradiction by L69 , L59 , L64 , L67 , XXREAL_0:1;
end;
suppose L71: (D2 <= D3 & D4 <= D2);

L72: ( C9 . D4 ) = ( C8 . D4 )
proof
assume L73: (not thesis);
L74: D2 <= D4 by L73 , L60;
thus L75: contradiction by L74 , L59 , L66 , L71 , XXREAL_0:1;
end;
thus L76: contradiction by L72 , L50 , L59 , L66 , L54 , FUNCT_1:def 4;
end;
suppose L77: (D3 <= D2 & D2 <= D4);

L78: ( C8 . D3 ) = ( C9 . D3 )
proof
assume L79: (not thesis);
L80: D2 <= D3 by L79 , L60;
thus L81: contradiction by L80 , L59 , L64 , L77 , XXREAL_0:1;
end;
thus L82: contradiction by L78 , L52 , L59 , L64 , L55 , FUNCT_1:def 4;
end;
suppose L83: (D2 <= D3 & D2 <= D4);

L84: ( C9 . D2 ) <= ( C9 . D4 ) , R7 by L83 , L53;
L85: D3 <= D2 by L84 , L51 , L66 , L64;
thus L86: contradiction by L85 , L59 , L64 , L83 , XXREAL_0:1;
end;
end;
L88: (for R3 being (Element of ( NAT )) holds (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds R3 <= R3 , R7)))
proof
let R3 being (Element of ( NAT ));
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
reconsider D5 = R3 as (Element of ( NAT ));
reconsider D6 = <* D5 *> as non  empty (FinSequence of ( NAT ));
take D6;
thus L89: ( D6 /. 1 ) = R3 by FINSEQ_4:16;
thus L90: thesis by L89 , FINSEQ_1:39;
end;
theorem
L91: (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B21 being (Function of ( NAT ) , ( NAT )) holds (B21 is  bijective implies ((for B22 , B23 being (Element of ( NAT )) holds (B22 <= B23 iff ( B21 . B22 ) <= ( B21 . B23 ) , R7)) iff (for B24 being (Element of ( NAT )) holds (( B21 . ( B24 + 1 ) ) in ( SUCC (( B21 . B24 ) , R7) ) & (for B25 being (Element of ( NAT )) holds (( B21 . B25 ) in ( SUCC (( B21 . B24 ) , R7) ) implies B24 <= B25)))))))))
proof
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C13 being (Function of ( NAT ) , ( NAT ));
assume L92: C13 is  bijective;
thus L93:now
assume L94: (for B26 , B27 being (Element of ( NAT )) holds (B26 <= B27 iff ( C13 . B26 ) <= ( C13 . B27 ) , R7));
let C14 being (Element of ( NAT ));
L95: C14 <= ( C14 + 1 ) by NAT_1:11;
L96: ( C13 . C14 ) <= ( C13 . ( C14 + 1 ) ) , R7 by L95 , L94;
consider C15 being non  empty (FinSequence of ( NAT )) such that L97: ( C15 /. 1 ) = ( C13 . C14 ) and L98: ( C15 /. ( len C15 ) ) = ( C13 . ( C14 + 1 ) ) and L99: (for R4 being (Element of ( NAT )) holds ((1 <= R4 & R4 < ( len C15 )) implies ( C15 /. ( R4 + 1 ) ) in ( SUCC (( C15 /. R4 ) , R7) ))) by L96 , L1;
set D7 = ( C15 -| ( C13 . ( C14 + 1 ) ) );
set D8 = ( ( C13 . ( C14 + 1 ) ) .. C15 );
L100: ( C13 . ( C14 + 1 ) ) in ( rng C15 ) by L98 , REVROT_1:3;
L101: ( len D7 ) = ( D8 - 1 ) by L100 , FINSEQ_4:34;
L102: ( ( len D7 ) + 1 ) = D8 by L101;
L103: D8 in ( dom C15 ) by L100 , FINSEQ_4:20;
L104: ( C15 /. ( ( len D7 ) + 1 ) ) = ( C15 . D8 ) by L103 , L101 , PARTFUN1:def 6
.= ( C13 . ( C14 + 1 ) ) by L100 , FINSEQ_4:19;
L105: D8 <= ( len C15 ) by L103 , FINSEQ_3:25;
L106: ( len D7 ) < ( len C15 ) by L105 , L102 , NAT_1:13;
L107: 1 <= ( len C15 ) by NAT_1:14;
L108: 1 in ( dom C15 ) by L107 , FINSEQ_3:25;
L109: ( C15 /. 1 ) = ( C15 . 1 ) by L108 , PARTFUN1:def 6;
L110: ( C15 . D8 ) = ( C13 . ( C14 + 1 ) ) by L100 , FINSEQ_4:19;
L111: ( dom C13 ) = ( NAT ) by FUNCT_2:def 1;
L112: ( C13 . C14 ) <> ( C13 . ( C14 + 1 ) )
proof
assume L113: (not thesis);
L114: ( ( 0 ) + C14 ) = ( C14 + 1 ) by L113 , L92 , L111 , FUNCT_1:def 4;
thus L115: contradiction by L114;
end;
L116: ( len D7 ) <> ( 0 ) by L112 , L97 , L110 , L108 , L101 , PARTFUN1:def 6;
L117: 1 <= D8 by L103 , FINSEQ_3:25;
L118: 1 < D8 by L117 , L97 , L112 , L110 , L109 , XXREAL_0:1;
L119: 1 <= ( len D7 ) by L118 , L102 , NAT_1:13;
reconsider D9 = D7 as non  empty (FinSequence of ( NAT )) by L116 , L100 , FINSEQ_4:41;
L120: ( rng C13 ) = ( NAT ) by L92 , FUNCT_2:def 3;
consider C16 being set such that L121: C16 in ( dom C13 ) and L122: ( C13 . C16 ) = ( C15 /. ( len D9 ) ) by L120 , FUNCT_1:def 3;
reconsider D10 = C16 as (Element of ( NAT )) by L121;
L123: ( len D9 ) in ( dom C15 ) by L119 , L106 , FINSEQ_3:25;
L124: ( len D9 ) in ( dom D9 ) by L119 , FINSEQ_3:25;
L125: ( D9 /. ( len D9 ) ) = ( D9 . ( len D9 ) ) by L124 , PARTFUN1:def 6
.= ( C15 . ( len D9 ) ) by L100 , L124 , FINSEQ_4:36
.= ( C15 /. ( len D9 ) ) by L123 , PARTFUN1:def 6;
L126:
now
L127: ( rng D9 ) misses { ( C13 . ( C14 + 1 ) ) } by L100 , FINSEQ_4:38;
L128: ( ( rng D9 ) /\ { ( C13 . ( C14 + 1 ) ) } ) = ( {} ) by L127 , XBOOLE_0:def 7;
L129: ((not ( C13 . ( C14 + 1 ) ) in ( rng D9 )) or (not ( C13 . ( C14 + 1 ) ) in { ( C13 . ( C14 + 1 ) ) })) by L128 , XBOOLE_0:def 4;
assume L130: D10 = ( C14 + 1 );
L131: ( len D9 ) in ( dom D9 ) by L119 , FINSEQ_3:25;
L132: ( D9 /. ( len D9 ) ) = ( D9 . ( len D9 ) ) by L131 , PARTFUN1:def 6;
thus L133: contradiction by L132 , L122 , L125 , L130 , L129 , L131 , FUNCT_1:def 3 , TARSKI:def 1;
end;
reconsider D11 = <* ( C15 /. ( len D9 ) ) , ( C15 /. D8 ) *> as non  empty (FinSequence of ( NAT ));
L134: ( len D11 ) = 2 by FINSEQ_1:44;
L135: 2 in ( dom D11 ) by L134 , FINSEQ_3:25;
L136: ( D11 /. ( len D11 ) ) = ( D11 . 2 ) by L135 , L134 , PARTFUN1:def 6
.= ( C15 /. D8 ) by FINSEQ_1:44
.= ( C13 . ( C14 + 1 ) ) by L110 , L103 , PARTFUN1:def 6;
L137: 1 in ( dom D11 ) by L134 , FINSEQ_3:25;
L138:
now
let R4 being (Element of ( NAT ));
assume L139: (1 <= R4 & R4 < ( len D11 ));
L140: (R4 <> ( 0 ) & R4 < 2) by L139 , FINSEQ_1:44;
L141: R4 = 1 by L140 , NAT_1:26;
L142: ( D11 /. R4 ) = ( D11 . 1 ) by L141 , L137 , PARTFUN1:def 6
.= ( C15 /. ( len D9 ) ) by FINSEQ_1:44;
L143: ( D11 /. ( R4 + 1 ) ) = ( D11 . 2 ) by L135 , L141 , PARTFUN1:def 6
.= ( C15 /. ( ( len D9 ) + 1 ) ) by L101 , FINSEQ_1:44;
thus L144: ( D11 /. ( R4 + 1 ) ) in ( SUCC (( D11 /. R4 ) , R7) ) by L143 , L99 , L119 , L106 , L142;
end;
L145:
now
let R4 being (Element of ( NAT ));
assume that
L146: 1 <= R4
and
L147: R4 < ( len D9 );
L148: 1 <= ( R4 + 1 ) by L146 , NAT_1:13;
L149: ( R4 + 1 ) <= ( len D9 ) by L147 , NAT_1:13;
L150: ( R4 + 1 ) <= ( len C15 ) by L149 , L106 , XXREAL_0:2;
L151: ( R4 + 1 ) in ( dom C15 ) by L150 , L148 , FINSEQ_3:25;
L152: R4 <= ( len C15 ) by L106 , L147 , XXREAL_0:2;
L153: R4 in ( dom C15 ) by L152 , L146 , FINSEQ_3:25;
L154: R4 in ( dom D9 ) by L146 , L147 , FINSEQ_3:25;
L155: ( D9 /. R4 ) = ( D9 . R4 ) by L154 , PARTFUN1:def 6
.= ( C15 . R4 ) by L100 , L154 , FINSEQ_4:36
.= ( C15 /. R4 ) by L153 , PARTFUN1:def 6;
L156: R4 < ( len C15 ) by L106 , L147 , XXREAL_0:2;
L157: ( R4 + 1 ) in ( dom D9 ) by L148 , L149 , FINSEQ_3:25;
L158: ( D9 /. ( R4 + 1 ) ) = ( D9 . ( R4 + 1 ) ) by L157 , PARTFUN1:def 6
.= ( C15 . ( R4 + 1 ) ) by L100 , L157 , FINSEQ_4:36
.= ( C15 /. ( R4 + 1 ) ) by L151 , PARTFUN1:def 6;
thus L159: ( D9 /. ( R4 + 1 ) ) in ( SUCC (( D9 /. R4 ) , R7) ) by L158 , L99 , L146 , L155 , L156;
end;
L160: ( D11 /. 1 ) = ( D11 . 1 ) by L137 , PARTFUN1:def 6
.= ( C13 . D10 ) by L122 , FINSEQ_1:44;
L161: ( C13 . D10 ) <= ( C13 . ( C14 + 1 ) ) , R7 by L160 , L136 , L138 , L1;
L162: D10 <= ( C14 + 1 ) by L161 , L94;
L163: 1 in ( dom D9 ) by L119 , FINSEQ_3:25;
L164: ( D9 /. 1 ) = ( D9 . 1 ) by L163 , PARTFUN1:def 6
.= ( C15 . 1 ) by L100 , L163 , FINSEQ_4:36
.= ( C13 . C14 ) by L97 , L108 , PARTFUN1:def 6;
L165: ( C13 . C14 ) <= ( C13 . D10 ) , R7 by L164 , L122 , L125 , L145 , L1;
L166: C14 <= D10 by L165 , L94;
L167: (D10 = C14 or D10 = ( C14 + 1 )) by L166 , L162 , NAT_1:9;
thus L168: ( C13 . ( C14 + 1 ) ) in ( SUCC (( C13 . C14 ) , R7) ) by L167 , L99 , L119 , L106 , L104 , L122 , L126;
let C17 being (Element of ( NAT ));
reconsider D12 = ( C13 . C14 ) , D13 = ( C13 . C17 ) as (Element of ( NAT ));
reconsider D14 = <* D12 , D13 *> as non  empty (FinSequence of ( NAT ));
L169: ( len D14 ) = 2 by FINSEQ_1:44;
L170: 2 in ( dom D14 ) by L169 , FINSEQ_3:25;
L171: 1 in ( dom D14 ) by L169 , FINSEQ_3:25;
L172: ( D14 /. 1 ) = ( D14 . 1 ) by L171 , PARTFUN1:def 6
.= ( C13 . C14 ) by FINSEQ_1:44;
assume L173: ( C13 . C17 ) in ( SUCC (( C13 . C14 ) , R7) );
L174:
now
let C18 being (Element of ( NAT ));
assume L175: (1 <= C18 & C18 < ( len D14 ));
L176: (C18 <> ( 0 ) & C18 < 2) by L175 , FINSEQ_1:44;
L177: C18 = 1 by L176 , NAT_1:26;
L178: ( D14 /. C18 ) = ( D14 . 1 ) by L177 , L171 , PARTFUN1:def 6
.= ( C13 . C14 ) by FINSEQ_1:44;
L179: ( D14 /. ( C18 + 1 ) ) = ( D14 . 2 ) by L170 , L177 , PARTFUN1:def 6
.= ( C13 . C17 ) by FINSEQ_1:44;
thus L180: ( D14 /. ( C18 + 1 ) ) in ( SUCC (( D14 /. C18 ) , R7) ) by L179 , L173 , L178;
end;
L181: ( D14 /. ( len D14 ) ) = ( D14 . 2 ) by L169 , L170 , PARTFUN1:def 6
.= ( C13 . C17 ) by FINSEQ_1:44;
L182: ( C13 . C14 ) <= ( C13 . C17 ) , R7 by L181 , L172 , L174 , L1;
thus L183: C14 <= C17 by L182 , L94;
end;
assume L184: (for B28 being (Element of ( NAT )) holds (( C13 . ( B28 + 1 ) ) in ( SUCC (( C13 . B28 ) , R7) ) & (for B29 being (Element of ( NAT )) holds (( C13 . B29 ) in ( SUCC (( C13 . B28 ) , R7) ) implies B28 <= B29))));
let C19 , C20 being (Element of ( NAT ));
thus L185:now
assume L186: C19 <= C20;
per cases  by L186 , XXREAL_0:1;
suppose L187: C19 = C20;

thus L188: ( C13 . C19 ) <= ( C13 . C20 ) , R7 by L187 , L88;
end;
suppose L189: C19 < C20;

thus L190: ( C13 . C19 ) <= ( C13 . C20 ) , R7
proof
reconsider D15 = C13 as (Function of ( NAT ) , ( NAT ));
set D16 = ( C20 -' C19 );
deffunc H1(Nat) = ( D15 . ( ( C19 + $1 ) -' 1 ) );
consider C21 being (FinSequence of ( NAT )) such that L191: ( len C21 ) = ( D16 + 1 ) and L192: (for B30 being Nat holds (B30 in ( dom C21 ) implies ( C21 . B30 ) = H1(B30))) from FINSEQ_2:sch 1;
reconsider D17 = C21 as non  empty (FinSequence of ( NAT )) by L191;
take D17;
L193: 1 <= ( D16 + 1 ) by NAT_1:11;
L194: 1 in ( dom D17 ) by L193 , L191 , FINSEQ_3:25;
thus L195: ( D17 /. 1 ) = ( D17 . 1 ) by L194 , PARTFUN1:def 6
.= ( C13 . ( ( C19 + 1 ) -' 1 ) ) by L192 , L194
.= ( C13 . C19 ) by NAT_D:34;
L196: ( C19 + 1 ) <= C20 by L189 , INT_1:7;
L197: 1 <= ( C20 - C19 ) by L196 , XREAL_1:19;
L198: ( 0 ) <= ( C20 - C19 ) by L197 , XXREAL_0:2;
L199: D16 = ( C20 - C19 ) by L198 , XREAL_0:def 2;
L200: ( len D17 ) in ( dom D17 ) by L191 , L193 , FINSEQ_3:25;
thus L201: ( D17 /. ( len D17 ) ) = ( D17 . ( len D17 ) ) by L200 , PARTFUN1:def 6
.= ( C13 . ( ( C19 + ( D16 + 1 ) ) -' 1 ) ) by L191 , L192 , L200
.= ( C13 . ( ( ( C19 + D16 ) + 1 ) -' 1 ) )
.= ( C13 . C20 ) by L199 , NAT_D:34;
let C22 being (Element of ( NAT ));
assume that
L202: 1 <= C22
and
L203: C22 < ( len D17 );
L204: C22 in ( dom D17 ) by L202 , L203 , FINSEQ_3:25;
L205: ( D17 /. C22 ) = ( D17 . C22 ) by L204 , PARTFUN1:def 6
.= ( C13 . ( ( C19 + C22 ) -' 1 ) ) by L192 , L204;
L206: C22 <= ( C19 + C22 ) by NAT_1:11;
L207: (1 <= ( C22 + 1 ) & ( C22 + 1 ) <= ( len D17 )) by L202 , L203 , NAT_1:13;
L208: ( C22 + 1 ) in ( dom D17 ) by L207 , FINSEQ_3:25;
L209: ( D17 /. ( C22 + 1 ) ) = ( D17 . ( C22 + 1 ) ) by L208 , PARTFUN1:def 6
.= ( C13 . ( ( C19 + ( C22 + 1 ) ) -' 1 ) ) by L192 , L208
.= ( C13 . ( ( ( C19 + C22 ) + 1 ) -' 1 ) )
.= ( C13 . ( ( ( C19 + C22 ) -' 1 ) + 1 ) ) by L202 , L206 , NAT_D:38 , XXREAL_0:2;
thus L210: thesis by L209 , L184 , L205;
end;

end;
end;
assume L192: ( C13 . C19 ) <= ( C13 . C20 ) , R7;
consider C23 being non  empty (FinSequence of ( NAT )) such that L193: ( C23 /. 1 ) = ( C13 . C19 ) and L194: ( C23 /. ( len C23 ) ) = ( C13 . C20 ) and L195: (for B31 being (Element of ( NAT )) holds ((1 <= B31 & B31 < ( len C23 )) implies ( C23 /. ( B31 + 1 ) ) in ( SUCC (( C23 /. B31 ) , R7) ))) by L192 , L1;
defpred S2[ (Element of ( NAT )) ] means ((1 <= $1 & $1 <= ( len C23 )) implies (ex B32 being (Element of ( NAT )) st (( C23 /. $1 ) = ( C13 . B32 ) & C19 <= B32)));
L196:
now
let C24 being (Element of ( NAT ));
assume that
L197: S2[ C24 ];
L198:
now
assume that
L199: 1 <= ( C24 + 1 )
and
L200: ( C24 + 1 ) <= ( len C23 );
per cases  by NAT_1:3;
suppose L201: C24 = ( 0 );

thus L202: (ex B33 being (Element of ( NAT )) st (( C23 /. ( C24 + 1 ) ) = ( C13 . B33 ) & C19 <= B33)) by L201 , L193;
end;
suppose L203: C24 > ( 0 );

L204: ( rng C13 ) = ( NAT ) by L92 , FUNCT_2:def 3;
consider C25 being set such that L205: C25 in ( dom C13 ) and L206: ( C13 . C25 ) = ( C23 /. ( C24 + 1 ) ) by L204 , FUNCT_1:def 3;
consider C26 being (Element of ( NAT )) such that L207: ( C23 /. C24 ) = ( C13 . C26 ) and L208: C19 <= C26 by L197 , L200 , L203 , NAT_1:13 , NAT_1:14;
reconsider D18 = C25 as (Element of ( NAT )) by L205;
L209: C24 < ( len C23 ) by L200 , NAT_1:13;
L210: ( C23 /. ( C24 + 1 ) ) in ( SUCC (( C23 /. C24 ) , R7) ) by L209 , L195 , L203 , NAT_1:14;
L211: C26 <= D18 by L210 , L184 , L207 , L206;
thus L212: (ex B34 being (Element of ( NAT )) st (( C23 /. ( C24 + 1 ) ) = ( C13 . B34 ) & C19 <= B34)) by L211 , L208 , L206 , XXREAL_0:2;
end;
end;
thus L214: S2[ ( C24 + 1 ) ] by L198;
end;
L215: 1 <= ( len C23 ) by NAT_1:14;
L216: S2[ ( 0 ) ];
L217: (for B35 being (Element of ( NAT )) holds S2[ B35 ]) from NAT_1:sch 1(L216 , L196);
L218: (( dom C13 ) = ( NAT ) & (ex B36 being (Element of ( NAT )) st (( C23 /. ( len C23 ) ) = ( C13 . B36 ) & C19 <= B36))) by L217 , L215 , FUNCT_2:def 1;
thus L219: thesis by L218 , L92 , L194 , FUNCT_1:def 4;
end;
theorem
L220: (for R6 being  with_zero set holds (for R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (R7 is  weakly_standard iff (ex B37 being (Function of ( NAT ) , ( NAT )) st (B37 is  bijective & (for B38 being (Element of ( NAT )) holds (( B37 . ( B38 + 1 ) ) in ( SUCC (( B37 . B38 ) , R7) ) & (for B39 being (Element of ( NAT )) holds (( B37 . B39 ) in ( SUCC (( B37 . B38 ) , R7) ) implies B38 <= B39)))))))))
proof
let R6 being  with_zero set;
let R7 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
thus L221:now
assume L222: R7 is  weakly_standard;
consider C27 being (Function of ( NAT ) , ( NAT )) such that L223: C27 is  bijective and L224: (for B40 , B41 being (Element of ( NAT )) holds (B40 <= B41 iff ( C27 . B40 ) <= ( C27 . B41 ) , R7)) by L222 , L47;
thus L225: (ex B42 being (Function of ( NAT ) , ( NAT )) st (B42 is  bijective & (for B43 being (Element of ( NAT )) holds (( B42 . ( B43 + 1 ) ) in ( SUCC (( B42 . B43 ) , R7) ) & (for B44 being (Element of ( NAT )) holds (( B42 . B44 ) in ( SUCC (( B42 . B43 ) , R7) ) implies B43 <= B44))))))
proof
take C27;
thus L226: C27 is  bijective by L223;
thus L227: thesis by L223 , L224 , L91;
end;

end;
given C28 being (Function of ( NAT ) , ( NAT )) such that
L226: C28 is  bijective
and
L227: (for B45 being (Element of ( NAT )) holds (( C28 . ( B45 + 1 ) ) in ( SUCC (( C28 . B45 ) , R7) ) & (for B46 being (Element of ( NAT )) holds (( C28 . B46 ) in ( SUCC (( C28 . B45 ) , R7) ) implies B45 <= B46))));

take C28;
thus L228: C28 is  bijective by L226;
thus L229: thesis by L226 , L227 , L91;
end;
set D19 = { [ 1 , ( 0 ) , ( 0 ) ] , [ ( 0 ) , ( 0 ) , ( 0 ) ] };
begin
L230: (for R6 being  with_zero set holds (for B47 being (Instruction of ( STC R6 )) holds (for B48 being (State of ( STC R6 )) holds (( InsCode B47 ) = 1 implies ( IC ( Exec (B47 , B48) ) ) = ( succ ( IC B48 ) )))))
proof
let R6 being  with_zero set;
let C29 being (Instruction of ( STC R6 ));
let C30 being (State of ( STC R6 ));
set D20 = ( STC R6 );
assume L231: ( InsCode C29 ) = 1;
L232:
now
assume L233: C29 in { [ ( 0 ) , ( 0 ) , ( 0 ) ] };
L234: C29 = [ ( 0 ) , ( 0 ) , ( 0 ) ] by L233 , TARSKI:def 1;
thus L235: contradiction by L234 , L231 , RECDEF_2:def 1;
end;
L236: (the InstructionsF of D20) = D19 by AMISTD_1:def 7;
L237: (C29 = [ 1 , ( 0 ) , ( 0 ) ] or C29 = [ ( 0 ) , ( 0 ) , ( 0 ) ]) by L236 , TARSKI:def 2;
L238: C29 in { [ 1 , ( 0 ) , ( 0 ) ] } by L237 , L231 , RECDEF_2:def 1 , TARSKI:def 1;
L239: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
L240: ( 0 ) in ( dom ( ( 0 ) .--> ( succ ( C30 . ( 0 ) ) ) ) ) by L239 , FUNCOP_1:13;
consider C31 being (Function of ( product ( the_Values_of D20 ) ) , ( product ( the_Values_of D20 ) )) such that L241: (for B49 being (Element of ( product ( the_Values_of D20 ) )) holds ( C31 . B49 ) = ( B49 +* ( ( 0 ) .--> ( succ ( B49 . ( 0 ) ) ) ) )) and L242: (the Execution of D20) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C31 ) +* ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D20 ) ) ) ) ) by AMISTD_1:def 7;
L243: (for B50 being (State of D20) holds ( C31 . B50 ) = ( B50 +* ( ( 0 ) .--> ( succ ( B50 . ( 0 ) ) ) ) ))
proof
let C32 being (State of D20);
reconsider D21 = C32 as (Element of ( product ( the_Values_of D20 ) )) by CARD_3:107;
L244: ( C31 . D21 ) = ( D21 +* ( ( 0 ) .--> ( succ ( D21 . ( 0 ) ) ) ) ) by L241;
thus L245: thesis by L244;
end;
L246: (the ZeroF of D20) = ( 0 ) by AMISTD_1:def 7;
L247: ( dom ( [ ( 0 ) , ( 0 ) , ( 0 ) ] .--> ( id ( product ( the_Values_of D20 ) ) ) ) ) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] } by FUNCOP_1:13;
L248: ( (the Execution of D20) . C29 ) = ( ( [ 1 , ( 0 ) , ( 0 ) ] .--> C31 ) . C29 ) by L247 , L242 , L232 , FUNCT_4:11
.= C31 by L238 , FUNCOP_1:7;
thus L249: ( IC ( Exec (C29 , C30) ) ) = ( ( C30 +* ( ( 0 ) .--> ( succ ( C30 . ( 0 ) ) ) ) ) . ( 0 ) ) by L248 , L246 , L243
.= ( ( ( 0 ) .--> ( succ ( C30 . ( 0 ) ) ) ) . ( 0 ) ) by L240 , FUNCT_4:13
.= ( succ ( IC C30 ) ) by L246 , L239 , FUNCOP_1:7;
end;
L250: (for R5 being Nat holds (for R6 being  with_zero set holds (for B51 being (Element of ( NAT )) holds (for B52 being (Element of (the InstructionsF of ( STC R6 ))) holds ((B51 = R5 & ( InsCode B52 ) = 1) implies ( NIC (B52 , B51) ) = { ( R5 + 1 ) })))))
proof
let R5 being Nat;
let R6 being  with_zero set;
let C33 being (Element of ( NAT ));
let C34 being (Element of (the InstructionsF of ( STC R6 )));
assume that
L251: C33 = R5
and
L252: ( InsCode C34 ) = 1;
set D22 = ( STC R6 );
set D23 = { ( IC ( Exec (C34 , B53) ) ) where B53 is (Element of ( product ( the_Values_of ( STC R6 ) ) )) : ( IC B53 ) = C33 };
L253:
now
reconsider D24 = ( ( NAT ) --> C34 ) as (Instruction-Sequence of D22);
reconsider D25 = C33 as (Element of ( Values ( IC D22 ) )) by MEMSTR_0:def 6;
reconsider D26 = the C33 -started (State of D22) as (Element of ( product ( the_Values_of D22 ) )) by CARD_3:107;
set D27 = ( ( IC D22 ) .--> D25 );
L254: ( dom D27 ) = { ( IC D22 ) } by FUNCOP_1:13;
let C35 being set;
reconsider D28 = ( D26 +* D27 ) as (Element of ( product ( the_Values_of ( STC R6 ) ) )) by CARD_3:107;
thus L255:now
assume L256: C35 in D23;
L257: (ex B54 being (Element of ( product ( the_Values_of ( STC R6 ) ) )) st (C35 = ( IC ( Exec (C34 , B54) ) ) & ( IC B54 ) = C33)) by L256;
L258: C35 = ( succ R5 ) by L257 , L251 , L252 , L230
.= ( R5 + 1 );
thus L259: C35 in { ( R5 + 1 ) } by L258 , TARSKI:def 1;
end;
assume L260: C35 in { ( R5 + 1 ) };
L261: C35 = ( succ R5 ) by L260 , TARSKI:def 1;
L262: ( IC D22 ) in ( dom D27 ) by L254 , TARSKI:def 1;
L263: ( IC D28 ) = ( D27 . ( IC D22 ) ) by L262 , FUNCT_4:13
.= R5 by L251 , FUNCOP_1:72;
L264: ( IC ( Exec (C34 , D28) ) ) = ( succ R5 ) by L263 , L252 , L230;
thus L265: C35 in D23 by L264 , L251 , L261 , L263;
end;
thus L266: thesis by L253 , TARSKI:1;
end;
registration
let C36 being  with_zero set;
cluster ( STC C36 ) ->  weakly_standard;
coherence
proof
reconsider D29 = ( id ( NAT ) ) as (Function of ( NAT ) , ( NAT ));
set D30 = ( STC C36 );
L267:
now
let C37 being (Element of ( NAT ));
reconsider D31 = ( D29 . C37 ) as (Element of ( NAT ));
L268: ( SUCC (D31 , ( STC C36 )) ) = { C37 , ( C37 + 1 ) } by AMISTD_1:8 , FUNCT_1:18;
L269: ( D29 . ( C37 + 1 ) ) = ( C37 + 1 ) by FUNCT_1:18;
thus L270: ( D29 . ( C37 + 1 ) ) in ( SUCC (( D29 . C37 ) , ( STC C36 )) ) by L269 , L268 , TARSKI:def 2;
let C38 being (Element of ( NAT ));
assume L271: ( D29 . C38 ) in ( SUCC (( D29 . C37 ) , ( STC C36 )) );
L272: (( D29 . C38 ) = C37 or ( D29 . C38 ) = ( C37 + 1 )) by L271 , L268 , TARSKI:def 2;
L273: (C38 = ( C37 + 1 ) or C38 = C37) by L272 , FUNCT_1:18;
thus L274: C37 <= C38 by L273 , NAT_1:11;
end;
thus L275: thesis by L267 , L220;
end;
end;
registration
let C39 being  with_zero set;
cluster  weakly_standard  halting for  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C39;
existence
proof
take ( STC C39 );
thus L277: thesis;
end;
end;
definition
let C40 being  with_zero set;
let C41 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C40;
let C42 being Nat;
func il. (C41 , C42) -> (Element of ( NAT )) means 
:L279: (ex B55 being (Function of ( NAT ) , ( NAT )) st (B55 is  bijective & (for B56 , B57 being (Element of ( NAT )) holds (B56 <= B57 iff ( B55 . B56 ) <= ( B55 . B57 ) , C41)) & it = ( B55 . C42 )));
existence
proof
reconsider D32 = C42 as (Element of ( NAT )) by ORDINAL1:def 12;
consider C43 being (Function of ( NAT ) , ( NAT )) such that L280: (C43 is  bijective & (for B58 , B59 being (Element of ( NAT )) holds (B58 <= B59 iff ( C43 . B58 ) <= ( C43 . B59 ) , C41))) by L47;
reconsider D33 = ( C43 . D32 ) as (Element of ( NAT ));
take D33;
take C43;
thus L281: thesis by L280;
end;
uniqueness by L49;
end;
theorem
L283: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B60 , B61 being Nat holds (( il. (R15 , B60) ) = ( il. (R15 , B61) ) implies B60 = B61))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C44 , C45 being Nat;
assume L284: ( il. (R15 , C44) ) = ( il. (R15 , C45) );
L285: (C44 is (Element of ( NAT )) & C45 is (Element of ( NAT ))) by ORDINAL1:def 12;
consider C46 being (Function of ( NAT ) , ( NAT )) such that L286: (C46 is  bijective & (for B62 , B63 being (Element of ( NAT )) holds (B62 <= B63 iff ( C46 . B62 ) <= ( C46 . B63 ) , R15))) and L287: ( il. (R15 , C45) ) = ( C46 . C45 ) by L279;
consider C47 being (Function of ( NAT ) , ( NAT )) such that L288: C47 is  bijective and L289: (for B64 , B65 being (Element of ( NAT )) holds (B64 <= B65 iff ( C47 . B64 ) <= ( C47 . B65 ) , R15)) and L290: ( il. (R15 , C44) ) = ( C47 . C44 ) by L279;
L291: ( dom C47 ) = ( NAT ) by FUNCT_2:def 1;
L292: C47 = C46 by L288 , L289 , L286 , L49;
thus L293: thesis by L292 , L284 , L285 , L288 , L290 , L287 , L291 , FUNCT_1:def 4;
end;
theorem
L294: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B66 being Nat holds (ex B67 being Nat st B66 = ( il. (R15 , B67) )))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C48 being Nat;
consider C49 being (Function of ( NAT ) , ( NAT )) such that L295: C49 is  bijective and L296: (for B68 , B69 being (Element of ( NAT )) holds (B68 <= B69 iff ( C49 . B68 ) <= ( C49 . B69 ) , R15)) and L297: ( il. (R15 , ( 0 )) ) = ( C49 . ( 0 ) ) by L279;
L298: (C48 in ( NAT ) & ( rng C49 ) = ( NAT )) by L295 , FUNCT_2:def 3 , ORDINAL1:def 12;
consider C50 being set such that L299: C50 in ( dom C49 ) and L300: ( C49 . C50 ) = C48 by L298 , FUNCT_1:def 3;
reconsider D34 = C50 as Nat by L299;
take D34;
reconsider D35 = C48 as (Element of ( NAT )) by ORDINAL1:def 12;
L301: D35 = ( il. (R15 , D34) ) by L295 , L296 , L300 , L279;
thus L302: thesis by L301;
end;
definition
let C51 being  with_zero set;
let C52 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C51;
let C53 being Nat;
func locnum (C53 , C52) -> Nat means 
:L303: ( il. (C52 , it) ) = C53;
existence by L294;
uniqueness by L283;
end;
definition
let C54 being  with_zero set;
let C55 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C54;
let C56 being Nat;
redefine func locnum (C56 , C55) -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
theorem
L306: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B70 , B71 being (Element of ( NAT )) holds (( locnum (B70 , R15) ) = ( locnum (B71 , R15) ) implies B70 = B71))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C57 , C58 being (Element of ( NAT ));
assume L307: ( locnum (C57 , R15) ) = ( locnum (C58 , R15) );
L308: ( il. (R15 , ( locnum (C57 , R15) )) ) = C57 by L303;
thus L309: thesis by L308 , L307 , L303;
end;
theorem
L310: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B72 , B73 being Nat holds (( il. (R15 , B72) ) <= ( il. (R15 , B73) ) , R15 iff B72 <= B73))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C59 , C60 being Nat;
L311: (C59 is (Element of ( NAT )) & C60 is (Element of ( NAT ))) by ORDINAL1:def 12;
consider C61 being (Function of ( NAT ) , ( NAT )) such that L312: (C61 is  bijective & (for B74 , B75 being (Element of ( NAT )) holds (B74 <= B75 iff ( C61 . B74 ) <= ( C61 . B75 ) , R15))) and L313: ( il. (R15 , C60) ) = ( C61 . C60 ) by L279;
consider C62 being (Function of ( NAT ) , ( NAT )) such that L314: C62 is  bijective and L315: (for B76 , B77 being (Element of ( NAT )) holds (B76 <= B77 iff ( C62 . B76 ) <= ( C62 . B77 ) , R15)) and L316: ( il. (R15 , C59) ) = ( C62 . C59 ) by L279;
L317: C62 = C61 by L314 , L315 , L312 , L49;
thus L318: thesis by L317 , L311 , L315 , L316 , L313;
end;
theorem
L319: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B78 , B79 being (Element of ( NAT )) holds (( locnum (B78 , R15) ) <= ( locnum (B79 , R15) ) iff B78 <= B79 , R15))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C63 , C64 being (Element of ( NAT ));
L320: (( il. (R15 , ( locnum (C63 , R15) )) ) = C63 & ( il. (R15 , ( locnum (C64 , R15) )) ) = C64) by L303;
thus L321: thesis by L320 , L310;
end;
theorem
L322: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds R15 is  InsLoc-antisymmetric))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C65 , C66 being (Element of ( NAT ));
assume L323: (C65 <= C66 , R15 & C66 <= C65 , R15);
reconsider D36 = R15 as  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
reconsider D37 = C65 , D38 = C66 as (Element of ( NAT ));
L324: (( locnum (D37 , D36) ) <= ( locnum (D38 , D36) ) & ( locnum (D38 , D36) ) <= ( locnum (D37 , D36) )) by L323 , L319;
thus L325: thesis by L324 , L306 , XXREAL_0:1;
end;
registration
let R6 being  with_zero set;
cluster  weakly_standard ->  InsLoc-antisymmetric for  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
coherence by L322;
end;
definition
let C67 being  with_zero set;
let C68 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C67;
let C69 being (Element of ( NAT ));
let C70 being Nat;
func C69 + (C70 , C68) -> (Element of ( NAT )) equals 
( il. (C68 , ( ( locnum (C69 , C68) ) + C70 )) );
coherence;
end;
theorem
L328: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B80 being (Element of ( NAT )) holds ( B80 + (( 0 ) , R15) ) = B80))) by L303;
theorem
L329: (for R5 being Nat holds (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B81 , B82 being (Element of ( NAT )) holds (( B81 + (R5 , R15) ) = ( B82 + (R5 , R15) ) implies B81 = B82)))))
proof
let R5 being Nat;
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C71 , C72 being (Element of ( NAT ));
assume L330: ( C71 + (R5 , R15) ) = ( C72 + (R5 , R15) );
L331: ( ( locnum (C71 , R15) ) + R5 ) = ( ( locnum (C72 , R15) ) + R5 ) by L330 , L283;
thus L332: thesis by L331 , L306;
end;
theorem
L333: (for R5 being Nat holds (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B83 being (Element of ( NAT )) holds ( ( locnum (B83 , R15) ) + R5 ) = ( locnum (( B83 + (R5 , R15) ) , R15) ))))) by L303;
definition
let C73 being  with_zero set;
let C74 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C73;
let C75 being (Element of ( NAT ));
func NextLoc (C75 , C74) -> (Element of ( NAT )) equals 
( C75 + (1 , C74) );
coherence;
end;
theorem
L335: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B84 being (Element of ( NAT )) holds ( NextLoc (B84 , R15) ) = ( il. (R15 , ( ( locnum (B84 , R15) ) + 1 )) ))));
theorem
L336: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B85 being (Element of ( NAT )) holds B85 <> ( NextLoc (B85 , R15) ))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C76 being (Element of ( NAT ));
assume L337: C76 = ( NextLoc (C76 , R15) );
L338: ( locnum (C76 , R15) ) = ( ( locnum (C76 , R15) ) + 1 ) by L337 , L303;
thus L339: thesis by L338;
end;
theorem
L340: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B86 , B87 being (Element of ( NAT )) holds (( NextLoc (B86 , R15) ) = ( NextLoc (B87 , R15) ) implies B86 = B87))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C77 , C78 being (Element of ( NAT ));
assume that
L341: ( NextLoc (C77 , R15) ) = ( NextLoc (C78 , R15) );
set D39 = ( locnum (C78 , R15) );
set D40 = ( locnum (C77 , R15) );
L342: ( D40 + ( 0 ) ) = ( ( D40 + 1 ) - 1 )
.= ( ( D39 + 1 ) - 1 ) by L341 , L283
.= ( D39 + ( 0 ) );
thus L343: thesis by L342 , L306;
end;
theorem
L344: (for R5 being Nat holds (for R6 being  with_zero set holds ( il. (( STC R6 ) , R5) ) = R5))
proof
let R5 being Nat;
let R6 being  with_zero set;
set D41 = ( STC R6 );
reconsider D42 = ( id ( NAT ) ) as (Function of ( NAT ) , ( NAT ));
consider C79 being (Function of ( NAT ) , ( NAT )) such that L345: (C79 is  bijective & (for B88 , B89 being (Element of ( NAT )) holds (B88 <= B89 iff ( C79 . B88 ) <= ( C79 . B89 ) , ( STC R6 )))) and L346: ( il. (D41 , R5) ) = ( C79 . R5 ) by L279;
L347:
now
let C80 being (Element of ( NAT ));
reconsider D43 = ( D42 . C80 ) as (Element of ( NAT ));
L348: ( SUCC (D43 , ( STC R6 )) ) = { C80 , ( C80 + 1 ) } by AMISTD_1:8 , FUNCT_1:18;
L349: ( D42 . ( C80 + 1 ) ) = ( C80 + 1 ) by FUNCT_1:18;
thus L350: ( D42 . ( C80 + 1 ) ) in ( SUCC (( D42 . C80 ) , ( STC R6 )) ) by L349 , L348 , TARSKI:def 2;
let C81 being (Element of ( NAT ));
L351: C81 = ( D42 . C81 ) by FUNCT_1:18;
assume L352: ( D42 . C81 ) in ( SUCC (( D42 . C80 ) , ( STC R6 )) );
L353: (C81 = C80 or C81 = ( C80 + 1 )) by L352 , L348 , L351 , TARSKI:def 2;
thus L354: C80 <= C81 by L353 , NAT_1:11;
end;
L355: (for B90 , B91 being (Element of ( NAT )) holds (B90 <= B91 iff ( D42 . B90 ) <= ( D42 . B91 ) , D41)) by L347 , L91;
L356: (R5 is (Element of ( NAT )) & C79 = D42) by L355 , L345 , L49 , ORDINAL1:def 12;
thus L357: thesis by L356 , L346 , FUNCT_1:18;
end;
theorem
L358: (for R6 being  with_zero set holds (for B92 being (Instruction of ( STC R6 )) holds (for B93 being (State of ( STC R6 )) holds (( InsCode B92 ) = 1 implies ( IC ( Exec (B92 , B93) ) ) = ( NextLoc (( IC B93 ) , ( STC R6 )) )))))
proof
let R6 being  with_zero set;
let C82 being (Instruction of ( STC R6 ));
let C83 being (State of ( STC R6 ));
set D44 = ( STC R6 );
set D45 = ( locnum (( IC C83 ) , ( STC R6 )) );
reconsider D46 = ( IC C83 ) as (Element of ( NAT ));
assume L359: ( InsCode C82 ) = 1;
L360: ( IC ( Exec (C82 , C83) ) ) = ( succ ( IC C83 ) ) by L359 , L230
.= ( D46 + 1 );
L361: (( il. (D44 , D45) ) = D45 & ( il. (D44 , ( D45 + 1 )) ) = ( D45 + 1 )) by L344;
thus L362: thesis by L361 , L360 , L303;
end;
theorem
L363: (for R6 being  with_zero set holds (for B94 being (Element of ( NAT )) holds (for B95 being (Element of (the InstructionsF of ( STC R6 ))) holds (( InsCode B95 ) = 1 implies ( NIC (B95 , B94) ) = { ( NextLoc (B94 , ( STC R6 )) ) }))))
proof
let R6 being  with_zero set;
let C84 being (Element of ( NAT ));
let C85 being (Element of (the InstructionsF of ( STC R6 )));
assume L364: ( InsCode C85 ) = 1;
set D47 = ( STC R6 );
consider C86 being Nat such that L365: C84 = ( il. (D47 , C86) ) by L294;
L366: C86 = ( locnum (C84 , D47) ) by L365 , L303;
L367: ( NextLoc (C84 , ( STC R6 )) ) = ( C86 + 1 ) by L366 , L344;
thus L368: thesis by L367 , L364 , L365 , L250 , L344;
end;
theorem
L369: (for R6 being  with_zero set holds (for B96 being (Element of ( NAT )) holds ( SUCC (B96 , ( STC R6 )) ) = { B96 , ( NextLoc (B96 , ( STC R6 )) ) }))
proof
let R6 being  with_zero set;
let C87 being (Element of ( NAT ));
set D48 = ( STC R6 );
consider C88 being Nat such that L370: C87 = ( il. (D48 , C88) ) by L294;
L371: C88 = ( locnum (C87 , D48) ) by L370 , L303;
thus L372: ( SUCC (C87 , ( STC R6 )) ) = { C88 , ( C88 + 1 ) } by L370 , L344 , AMISTD_1:8
.= { C88 , ( il. (D48 , ( C88 + 1 )) ) } by L344
.= { C87 , ( NextLoc (C87 , ( STC R6 )) ) } by L370 , L371 , L344;
end;
definition
let C89 being  with_zero set;
let C90 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C89;
let C91 being (Instruction of C90);
attr C91 is  sequential
means
(for B97 being (State of C90) holds ( ( Exec (C91 , B97) ) . ( IC C90 ) ) = ( NextLoc (( IC B97 ) , C90) ));
end;
theorem
L374: (for R6 being  with_zero set holds (for B98 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B99 being (Element of ( NAT )) holds (for B100 being (Instruction of B98) holds (B100 is  sequential implies ( NIC (B100 , B99) ) = { ( NextLoc (B99 , B98) ) })))))
proof
let R6 being  with_zero set;
let C92 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C93 being (Element of ( NAT ));
let C94 being (Instruction of C92);
assume that
L375: (for B101 being (State of C92) holds ( ( Exec (C94 , B101) ) . ( IC C92 ) ) = ( NextLoc (( IC B101 ) , C92) ));
L376:
now
let C95 being set;
L377:
now
reconsider D49 = C93 as (Element of ( Values ( IC C92 ) )) by MEMSTR_0:def 6;
set D50 = C94;
set D51 = the (State of C92);
set D52 = the (Instruction-Sequence of C92);
assume L378: C95 = ( NextLoc (C93 , C92) );
reconsider D53 = ( D51 +* (( IC C92 ) , D49) ) as (Element of ( product ( the_Values_of C92 ) )) by CARD_3:107;
L379: C93 in ( NAT );
L380: C93 in ( dom D52 ) by L379 , PARTFUN1:def 2;
L381: ( ( D52 +* (C93 , C94) ) /. C93 ) = ( ( D52 +* (C93 , C94) ) . C93 ) by PBOOLE:143
.= C94 by L380 , FUNCT_7:31;
L382: ( IC C92 ) in ( dom D51 ) by MEMSTR_0:2;
L383: ( IC D53 ) = C93 by L382 , FUNCT_7:31;
L384: ( IC ( Following (( D52 +* (C93 , C94) ) , D53) ) ) = ( NextLoc (C93 , C92) ) by L383 , L375 , L381;
thus L385: C95 in { ( IC ( Exec (C94 , B102) ) ) where B102 is (Element of ( product ( the_Values_of C92 ) )) : ( IC B102 ) = C93 } by L384 , L378 , L383 , L381;
end;
L386:
now
assume L387: C95 in { ( IC ( Exec (C94 , B103) ) ) where B103 is (Element of ( product ( the_Values_of C92 ) )) : ( IC B103 ) = C93 };
L388: (ex B104 being (Element of ( product ( the_Values_of C92 ) )) st (C95 = ( IC ( Exec (C94 , B104) ) ) & ( IC B104 ) = C93)) by L387;
thus L389: C95 = ( NextLoc (C93 , C92) ) by L388 , L375;
end;
thus L390: (C95 in { ( NextLoc (C93 , C92) ) } iff C95 in { ( IC ( Exec (C94 , B105) ) ) where B105 is (Element of ( product ( the_Values_of C92 ) )) : ( IC B105 ) = C93 }) by L386 , L377 , TARSKI:def 1;
end;
thus L391: thesis by L376 , TARSKI:1;
end;
theorem
L392: (for R6 being  with_zero set holds (for B106 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B107 being (Instruction of B106) holds (B107 is  sequential implies B107 is non  halting))))
proof
let R6 being  with_zero set;
let C96 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C97 being (Instruction of C96);
assume that
L393: C97 is  sequential;
set D54 = the (State of C96);
L394: ( NIC (C97 , ( IC D54 )) ) = { ( NextLoc (( IC D54 ) , C96) ) } by L393 , L374;
L395: ( NIC (C97 , ( IC D54 )) ) <> { ( IC D54 ) } by L394 , L336 , ZFMISC_1:3;
thus L396: thesis by L395 , AMISTD_1:2;
end;
registration
let R6 being  with_zero set;
let C98 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
cluster  sequential -> non  halting for (Instruction of C98);
coherence by L392;
cluster  halting -> non  sequential for (Instruction of C98);
coherence;
end;
begin
definition
let C99 being  with_zero set;
let C100 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C99;
let C101 being ( NAT ) -defined (the InstructionsF of C100) -valued Function;
attr C101 is  para-closed
means
(for B108 being (State of C100) holds (( IC B108 ) = ( il. (C100 , ( 0 )) ) implies (for B109 being (Element of ( NAT )) holds ( IC ( Comput (C101 , B108 , B109) ) ) in ( dom C101 ))));
end;
theorem
L399: (for R6 being  with_zero set holds (for B110 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B111 being ( NAT ) -defined (the InstructionsF of B110) -valued  finite Function holds ((B111 is  really-closed & ( il. (B110 , ( 0 )) ) in ( dom B111 )) implies B111 is  para-closed))))
proof
let R6 being  with_zero set;
let C102 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C103 being ( NAT ) -defined (the InstructionsF of C102) -valued  finite Function;
assume L400: C103 is  really-closed;
L401: (for B112 being (State of C102) holds (( IC B112 ) in ( dom C103 ) implies (for B113 being (Element of ( NAT )) holds ( IC ( Comput (C103 , B112 , B113) ) ) in ( dom C103 )))) by L400 , AMISTD_1:14;
assume L402: ( il. (C102 , ( 0 )) ) in ( dom C103 );
let C104 being (State of C102);
assume L403: ( IC C104 ) = ( il. (C102 , ( 0 )) );
thus L404: thesis by L403 , L401 , L402;
end;
theorem
L405: (for R6 being  with_zero set holds (for B114 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (( ( il. (B114 , ( 0 )) ) .--> ( halt B114 ) ) qua ( NAT ) -defined (the InstructionsF of B114) -valued  finite Function) is  really-closed))
proof
let R6 being  with_zero set;
let C105 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
reconsider D55 = ( ( il. (C105 , ( 0 )) ) .--> ( halt C105 ) ) as ( NAT ) -defined (the InstructionsF of C105) -valued  finite Function;
let C106 being (Element of ( NAT ));
assume L406: C106 in ( dom ( ( il. (C105 , ( 0 )) ) .--> ( halt C105 ) ) );
L407: ( dom D55 ) = { ( il. (C105 , ( 0 )) ) } by FUNCOP_1:13;
L408: C106 = ( il. (C105 , ( 0 )) ) by L406 , TARSKI:def 1;
L409: ( D55 /. C106 ) = ( D55 . C106 ) by L406 , PARTFUN1:def 6
.= ( halt C105 ) by L408 , FUNCOP_1:72;
thus L410: thesis by L409 , L407 , L408 , AMISTD_1:2;
end;
definition
let C107 being  with_zero set;
let C108 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C107;
let C109 being (the InstructionsF of C108) -valued ( NAT ) -defined  finite Function;
attr C109 is  lower
means
:L411: (for B115 being (Element of ( NAT )) holds (B115 in ( dom C109 ) implies (for B116 being (Element of ( NAT )) holds (B116 <= B115 , C108 implies B116 in ( dom C109 )))));
end;
registration
let C110 being  with_zero set;
let C111 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C110;
cluster  empty ->  lower for  finite (the InstructionsF of C111) -valued ( NAT ) -defined  finite (the InstructionsF of C111) -valued ( NAT ) -defined  finite (the InstructionsF of C111) -valued ( NAT ) -defined  finite (the InstructionsF of C111) -valued ( NAT ) -defined Function;
coherence
proof
let C112 being  finite (the InstructionsF of C111) -valued ( NAT ) -defined Function;
assume that
L413: C112 is  empty;
let C113 being (Element of ( NAT ));
assume L414: C113 in ( dom C112 );
thus L415: thesis by L414 , L413;
end;
end;
theorem
L417: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B117 being (Element of (the InstructionsF of R15)) holds ( ( il. (R15 , ( 0 )) ) .--> B117 ) is  lower)))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C114 being (Element of (the InstructionsF of R15));
set D56 = ( ( il. (R15 , ( 0 )) ) .--> C114 );
let C115 being (Element of ( NAT ));
assume that
L418: C115 in ( dom D56 );
let C116 being (Element of ( NAT ));
assume that
L419: C116 <= C115 , R15;
consider C117 being Nat such that L420: C116 = ( il. (R15 , C117) ) by L294;
L421: C115 = ( il. (R15 , ( 0 )) ) by L418 , TARSKI:def 1;
L422: (( 0 ) <= C117 & C117 <= ( 0 )) by L421 , L419 , L420 , L310 , NAT_1:2;
thus L423: thesis by L422 , L418 , L421 , L420 , XXREAL_0:1;
end;
registration
let C118 being  with_zero set;
let C119 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C118;
cluster  lower 1 -element for ( NAT ) -defined (the InstructionsF of C119) -valued  finite ( NAT ) -defined (the InstructionsF of C119) -valued  finite ( NAT ) -defined (the InstructionsF of C119) -valued  finite ( NAT ) -defined (the InstructionsF of C119) -valued  finite Function;
existence
proof
set D57 = the (Instruction of C119);
take ( ( il. (C119 , ( 0 )) ) .--> D57 );
thus L424: thesis by L417;
end;
end;
theorem
L426: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B118 being  lower non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds ( il. (R15 , ( 0 )) ) in ( dom B118 ))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C120 being  lower non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
consider C121 being set such that L427: C121 in ( dom C120 ) by XBOOLE_0:def 1;
reconsider D58 = C121 as (Element of ( NAT )) by L427;
consider C122 being (Function of ( NAT ) , ( NAT )) such that L428: C122 is  bijective and L429: (for B119 , B120 being (Element of ( NAT )) holds (B119 <= B120 iff ( C122 . B119 ) <= ( C122 . B120 ) , R15)) and L430: ( il. (R15 , ( 0 )) ) = ( C122 . ( 0 ) ) by L279;
L431: ( rng C122 ) = ( NAT ) by L428 , FUNCT_2:def 3;
consider C123 being set such that L432: C123 in ( dom C122 ) and L433: D58 = ( C122 . C123 ) by L431 , FUNCT_1:def 3;
reconsider D59 = C123 as (Element of ( NAT )) by L432;
L434: ( 0 ) <= D59 by NAT_1:2;
L435: ( C122 . ( 0 ) ) <= ( C122 . D59 ) , R15 by L434 , L429;
thus L436: thesis by L435 , L427 , L430 , L433 , L411;
end;
theorem
L437: (for R5 being Nat holds (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B121 being  lower ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds (R5 < ( card B121 ) iff ( il. (R15 , R5) ) in ( dom B121 ))))))
proof
let R5 being Nat;
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C124 being  lower ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
deffunc H2((Element of ( NAT ))) = ( il. (R15 , $1) );
defpred S3[ (Element of ( NAT )) ] means H2($1) in ( dom C124 );
set D60 = { R3 where R3 is (Element of ( NAT )) : S3[ R3 ] };
L438: D60 is (Subset of ( NAT )) from DOMAIN_1:sch 7;
L439:
now
let C125 , C126 being (Element of ( NAT ));
assume L440: C125 in D60;
L441: (ex B122 being (Element of ( NAT )) st (B122 = C125 & ( il. (R15 , B122) ) in ( dom C124 ))) by L440;
assume L442: C126 < C125;
L443: ( il. (R15 , C126) ) <= ( il. (R15 , C125) ) , R15 by L442 , L310;
L444: ( il. (R15 , C126) ) in ( dom C124 ) by L443 , L441 , L411;
thus L445: C126 in D60 by L444;
end;
L446:
now
let C127 being set;
assume L447: C127 in ( dom C124 );
reconsider D61 = C127 as (Element of ( NAT )) by L447;
consider C128 being Nat such that L448: D61 = ( il. (R15 , C128) ) by L294;
reconsider D62 = C128 as (Element of ( NAT )) by ORDINAL1:def 12;
take D63 = D62;
thus L449: C127 = H2(D63) by L448;
end;
reconsider D64 = D60 as Cardinal by L438 , L439 , FUNCT_7:20;
set D65 = { R3 where R3 is (Element of ( NAT )) : H2(R3) in ( dom C124 ) };
L450: R5 is (Element of ( NAT )) by ORDINAL1:def 12;
L451: ( card D64 ) = D64 by CARD_1:def 2;
L452: (for B123 , B124 being (Element of ( NAT )) holds (H2(B123) = H2(B124) implies B123 = B124)) by L283;
L453: ( dom C124 ) , D65 are_equipotent  from FUNCT_7:sch 3(L446 , L452);
L454: ( card R5 ) = R5 by CARD_1:def 2;
thus L455:now
assume L456: R5 < ( card C124 );
L457: ( card R5 ) in ( card ( card C124 ) ) by L456 , NAT_1:41;
L458: R5 in ( card ( dom C124 ) ) by L457 , L454 , CARD_1:62;
L459: R5 in ( card D64 ) by L458 , L453 , CARD_1:5;
L460: (ex B125 being (Element of ( NAT )) st (B125 = R5 & ( il. (R15 , B125) ) in ( dom C124 ))) by L459 , L451;
thus L461: ( il. (R15 , R5) ) in ( dom C124 ) by L460;
end;
assume L462: ( il. (R15 , R5) ) in ( dom C124 );
L463: R5 in ( card D64 ) by L462 , L450 , L451;
L464: R5 in ( card ( dom C124 ) ) by L463 , L453 , CARD_1:5;
L465: ( card R5 ) in ( card ( card C124 ) ) by L464 , L454 , CARD_1:62;
thus L466: thesis by L465 , NAT_1:41;
end;
definition
let C129 being  with_zero set;
let C130 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C129;
let C131 being non  empty ( NAT ) -defined (the InstructionsF of C130) -valued  finite Function;
func LastLoc C131 -> (Element of ( NAT )) means 
:L467: (ex B126 being  finite non  empty  natural-membered set st (B126 = { ( locnum (B127 , C130) ) where B127 is (Element of ( NAT )) : B127 in ( dom C131 ) } & it = ( il. (C130 , ( max B126 )) )));
existence
proof
deffunc H3((Element of ( NAT ))) = ( locnum ($1 , C130) );
set D66 = { H3(B128) where B128 is (Element of ( NAT )) : B128 in ( dom C131 ) };
set D67 = the (Element of ( dom C131 ));
reconsider D68 = D67 as (Element of ( NAT ));
L468: ( locnum (D68 , C130) ) in D66;
L469: D66 c= ( NAT )
proof
let C132 being set;
assume L470: C132 in D66;
L471: (ex B129 being (Element of ( NAT )) st (C132 = ( locnum (B129 , C130) ) & B129 in ( dom C131 ))) by L470;
thus L472: thesis by L471;
end;
L473: ( dom C131 ) is  finite;
L474: D66 is  finite from FRAENKEL:sch 21(L473);
reconsider D69 = D66 as  finite non  empty (Subset of ( NAT )) by L474 , L468 , L469;
take ( il. (C130 , ( max D69 )) );
take D69;
thus L475: thesis;
end;
uniqueness;
end;
theorem
L477: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B130 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds ( LastLoc B130 ) in ( dom B130 ))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C133 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
consider C134 being  finite non  empty  natural-membered set such that L478: C134 = { ( locnum (B131 , R15) ) where B131 is (Element of ( NAT )) : B131 in ( dom C133 ) } and L479: ( LastLoc C133 ) = ( il. (R15 , ( max C134 )) ) by L467;
L480: ( max C134 ) in C134 by XXREAL_2:def 8;
L481: (ex B132 being (Element of ( NAT )) st (( max C134 ) = ( locnum (B132 , R15) ) & B132 in ( dom C133 ))) by L480 , L478;
thus L482: thesis by L481 , L479 , L303;
end;
theorem
L483: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B133 , B134 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds (B133 c= B134 implies ( LastLoc B133 ) <= ( LastLoc B134 ) , R15))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C135 , C136 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
assume that
L484: C135 c= C136;
consider C137 being  finite non  empty  natural-membered set such that L485: C137 = { ( locnum (B135 , R15) ) where B135 is (Element of ( NAT )) : B135 in ( dom C136 ) } and L486: ( LastLoc C136 ) = ( il. (R15 , ( max C137 )) ) by L467;
consider C138 being  finite non  empty  natural-membered set such that L487: C138 = { ( locnum (B136 , R15) ) where B136 is (Element of ( NAT )) : B136 in ( dom C135 ) } and L488: ( LastLoc C135 ) = ( il. (R15 , ( max C138 )) ) by L467;
reconsider D70 = C138 , D71 = C137 as non  empty  finite (Subset of ( REAL )) by MEMBERED:3;
L489: C138 c= C137
proof
let C139 being set;
assume L490: C139 in C138;
L491: (ex B137 being (Element of ( NAT )) st (C139 = ( locnum (B137 , R15) ) & B137 in ( dom C135 ))) by L490 , L487;
L492: ( dom C135 ) c= ( dom C136 ) by L484 , GRFUNC_1:2;
thus L493: thesis by L492 , L485 , L491;
end;
L494: ( max D70 ) <= ( max D71 ) by L489 , XXREAL_2:59;
thus L495: thesis by L494 , L488 , L486 , L310;
end;
theorem
L496: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B138 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds (for B139 being (Element of ( NAT )) holds (B139 in ( dom B138 ) implies B139 <= ( LastLoc B138 ) , R15)))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C140 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
let C141 being (Element of ( NAT ));
assume that
L497: C141 in ( dom C140 );
consider C142 being  finite non  empty  natural-membered set such that L498: C142 = { ( locnum (B140 , R15) ) where B140 is (Element of ( NAT )) : B140 in ( dom C140 ) } and L499: ( LastLoc C140 ) = ( il. (R15 , ( max C142 )) ) by L467;
L500: ( locnum (C141 , R15) ) in C142 by L497 , L498;
L501: ( locnum (C141 , R15) ) <= ( max C142 ) by L500 , XXREAL_2:def 8;
L502: ( locnum (( LastLoc C140 ) , R15) ) = ( max C142 ) by L499 , L303;
thus L503: thesis by L502 , L501 , L319;
end;
theorem
L504: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B141 being  lower non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds (for B142 being non  empty ( NAT ) -defined ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds ((B141 c= B142 & ( LastLoc B141 ) = ( LastLoc B142 )) implies B141 = B142)))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C143 being  lower non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
let C144 being non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
assume that
L505: C143 c= C144
and
L506: ( LastLoc C143 ) = ( LastLoc C144 );
L507: ( dom C143 ) = ( dom C144 )
proof
thus L508: ( dom C143 ) c= ( dom C144 ) by L505 , GRFUNC_1:2;
let C145 being set;
assume L509: C145 in ( dom C144 );
reconsider D72 = C145 as (Element of ( NAT )) by L509;
L510: ( LastLoc C143 ) in ( dom C143 ) by L477;
L511: D72 <= ( LastLoc C143 ) , R15 by L506 , L509 , L496;
thus L512: thesis by L511 , L510 , L411;
end;
thus L513: thesis by L507 , L505 , GRFUNC_1:3;
end;
theorem
L514: (for R6 being  with_zero set holds (for R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6 holds (for B143 being  lower non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function holds ( LastLoc B143 ) = ( il. (R15 , ( ( card B143 ) -' 1 )) ))))
proof
let R6 being  with_zero set;
let R15 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
let C146 being  lower non  empty ( NAT ) -defined (the InstructionsF of R15) -valued  finite Function;
consider C147 being Nat such that L515: ( LastLoc C146 ) = ( il. (R15 , C147) ) by L294;
reconsider D73 = C147 as (Element of ( NAT )) by ORDINAL1:def 12;
L516: ( LastLoc C146 ) in ( dom C146 ) by L477;
L517: D73 < ( card C146 ) by L516 , L515 , L437;
L518: D73 <= ( ( card C146 ) -' 1 ) by L517 , NAT_D:49;
per cases  by L518 , XXREAL_0:1;
suppose L519: D73 < ( ( card C146 ) -' 1 );

L520: ( D73 + 1 ) < ( ( ( card C146 ) -' 1 ) + 1 ) by L519 , XREAL_1:6;
L521: ( D73 + 1 ) < ( card C146 ) by L520 , NAT_1:14 , XREAL_1:235;
L522: ( il. (R15 , ( D73 + 1 )) ) in ( dom C146 ) by L521 , L437;
L523: ( il. (R15 , ( D73 + 1 )) ) <= ( LastLoc C146 ) , R15 by L522 , L496;
L524: ( D73 + 1 ) <= D73 by L523 , L515 , L310;
L525: D73 <= ( D73 + 1 ) by NAT_1:11;
L526: ( D73 + ( 0 ) ) = ( D73 + 1 ) by L525 , L524 , XXREAL_0:1;
thus L527: thesis by L526;
end;
suppose L528: D73 = ( ( card C146 ) -' 1 );

thus L529: thesis by L528 , L515;
end;
end;
registration
let C148 being  with_zero set;
let C149 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C148;
cluster  really-closed  lower non  empty ->  para-closed for ( NAT ) -defined (the InstructionsF of C149) -valued  finite ( NAT ) -defined (the InstructionsF of C149) -valued  finite ( NAT ) -defined (the InstructionsF of C149) -valued  finite ( NAT ) -defined (the InstructionsF of C149) -valued  finite Function;
coherence
proof
let C150 being ( NAT ) -defined (the InstructionsF of C149) -valued  finite Function;
assume L531: C150 is  really-closed;
assume L532: C150 is  lower non  empty;
L533: ( il. (C149 , ( 0 )) ) in ( dom C150 ) by L532 , L426;
thus L534: thesis by L533 , L531 , L399;
end;
end;
L536:
now
let R6 being  with_zero set;
let C151 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R6;
set D74 = ( ( il. (C151 , ( 0 )) ) .--> ( halt C151 ) );
L537: ( dom D74 ) = { ( il. (C151 , ( 0 )) ) } by FUNCOP_1:13;
L538: ( card ( dom D74 ) ) = 1 by L537 , CARD_1:30;
L539: D74 is  lower ( NAT ) -defined (the InstructionsF of C151) -valued  finite  lower ( NAT ) -defined (the InstructionsF of C151) -valued  finite  lower ( NAT ) -defined (the InstructionsF of C151) -valued  finite  lower ( NAT ) -defined (the InstructionsF of C151) -valued  finite Function by L417;
L540: ( LastLoc D74 ) = ( il. (C151 , ( ( card D74 ) -' 1 )) ) by L539 , L514
.= ( il. (C151 , ( ( card ( dom D74 ) ) -' 1 )) ) by CARD_1:62
.= ( il. (C151 , ( 0 )) ) by L538 , XREAL_1:232;
thus L541: ( D74 . ( LastLoc D74 ) ) = ( halt C151 ) by L540 , FUNCOP_1:72;
let C152 being (Element of ( NAT ));
assume that
L542: ( D74 . C152 ) = ( halt C151 );
assume L543: C152 in ( dom D74 );
thus L544: C152 = ( LastLoc D74 ) by L543 , L540 , TARSKI:def 1;
end;
definition
let C153 being  with_zero set;
let C154 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C153;
let C155 being non  empty ( NAT ) -defined (the InstructionsF of C154) -valued  finite Function;
attr C155 is  halt-ending
means
:L545: ( C155 . ( LastLoc C155 ) ) = ( halt C154 );
attr C155 is  unique-halt
means
:L546: (for B144 being (Element of ( NAT )) holds ((( C155 . B144 ) = ( halt C154 ) & B144 in ( dom C155 )) implies B144 = ( LastLoc C155 )));
end;
registration
let C156 being  with_zero set;
let C157 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C156;
cluster  halt-ending  unique-halt  trivial for  lower non  empty ( NAT ) -defined (the InstructionsF of C157) -valued  finite  lower non  empty ( NAT ) -defined (the InstructionsF of C157) -valued  finite  lower non  empty ( NAT ) -defined (the InstructionsF of C157) -valued  finite  lower non  empty ( NAT ) -defined (the InstructionsF of C157) -valued  finite Function;
existence
proof
reconsider D75 = ( ( il. (C157 , ( 0 )) ) .--> ( halt C157 ) ) as  lower non  empty ( NAT ) -defined (the InstructionsF of C157) -valued  finite Function by L417;
take D75;
thus L548: ( D75 . ( LastLoc D75 ) ) = ( halt C157 ) by L536;
thus L549: (for B145 being (Element of ( NAT )) holds ((( D75 . B145 ) = ( halt C157 ) & B145 in ( dom D75 )) implies B145 = ( LastLoc D75 ))) by L536;
thus L550: thesis;
end;
end;
registration
let C158 being  with_zero set;
let C159 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C158;
cluster  trivial  really-closed  lower non  empty for ( NAT ) -defined (the InstructionsF of C159) -valued  finite ( NAT ) -defined (the InstructionsF of C159) -valued  finite ( NAT ) -defined (the InstructionsF of C159) -valued  finite ( NAT ) -defined (the InstructionsF of C159) -valued  finite Function;
existence
proof
reconsider D76 = ( ( il. (C159 , ( 0 )) ) .--> ( halt C159 ) ) as  lower non  empty ( NAT ) -defined (the InstructionsF of C159) -valued  finite Function by L417;
take D76;
thus L552: thesis by L405;
end;
end;
registration
let C160 being  with_zero set;
let C161 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C160;
cluster  halt-ending  unique-halt  trivial  really-closed for  lower non  empty ( NAT ) -defined (the InstructionsF of C161) -valued  finite  lower non  empty ( NAT ) -defined (the InstructionsF of C161) -valued  finite  lower non  empty ( NAT ) -defined (the InstructionsF of C161) -valued  finite  lower non  empty ( NAT ) -defined (the InstructionsF of C161) -valued  finite Function;
existence
proof
reconsider D77 = ( ( il. (C161 , ( 0 )) ) .--> ( halt C161 ) ) as  lower non  empty ( NAT ) -defined (the InstructionsF of C161) -valued  finite Function by L417;
take D77;
thus L554: ( D77 . ( LastLoc D77 ) ) = ( halt C161 ) by L536;
thus L555: (for B146 being (Element of ( NAT )) holds ((( D77 . B146 ) = ( halt C161 ) & B146 in ( dom D77 )) implies B146 = ( LastLoc D77 ))) by L536;
thus L556: thesis by L405;
end;
end;
definition
let C162 being  with_zero set;
let C163 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C162;
mode pre-Macro of C163
 is  halt-ending  unique-halt  lower non  empty ( NAT ) -defined (the InstructionsF of C163) -valued  finite Function;
end;
registration
let C164 being  with_zero set;
let C165 being  weakly_standard  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C164;
cluster  really-closed for (pre-Macro of C165);
existence
proof
reconsider D78 = ( ( il. (C165 , ( 0 )) ) .--> ( halt C165 ) ) as  lower non  empty ( NAT ) -defined (the InstructionsF of C165) -valued  finite Function by L417;
L559: (( D78 . ( LastLoc D78 ) ) = ( halt C165 ) & (for B147 being (Element of ( NAT )) holds ((( D78 . B147 ) = ( halt C165 ) & B147 in ( dom D78 )) implies B147 = ( LastLoc D78 )))) by L536;
reconsider D79 = D78 as (pre-Macro of C165) by L559 , L545 , L546;
take D79;
thus L560: thesis by L405;
end;
end;
theorem
L562: (for B148 being  with_zero set holds (for B149 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B148 holds (for B150 , B151 being (Element of ( NAT )) holds (( SUCC (B150 , B149) ) = ( NAT ) implies B150 <= B151 , B149))))
proof
let C166 being  with_zero set;
let C167 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C166;
let C168 , C169 being (Element of ( NAT ));
assume that
L563: ( SUCC (C168 , C167) ) = ( NAT );
defpred S4[ set , set ] means (($1 = 1 implies $2 = C168) & ($1 = 2 implies $2 = C169));
L564: (for B152 being Nat holds (B152 in ( Seg 2 ) implies (ex B153 being (Element of ( NAT )) st S4[ B152 , B153 ])))
proof
let C170 being Nat;
assume L565: C170 in ( Seg 2 );
per cases  by L565 , FINSEQ_1:2 , TARSKI:def 2;
suppose L566: C170 = 1;

reconsider D80 = C168 as (Element of ( NAT ));
take D80;
thus L567: thesis by L566;
end;
suppose L568: C170 = 2;

reconsider D81 = C169 as (Element of ( NAT ));
take D81;
thus L569: thesis by L568;
end;
end;
consider C171 being (FinSequence of ( NAT )) such that L571: ( len C171 ) = 2 and L572: (for B154 being Nat holds (B154 in ( Seg 2 ) implies S4[ B154 , ( C171 /. B154 ) ])) from FINSEQ_4:sch 1(L564);
L573: 1 in ( Seg 2 ) by FINSEQ_1:2 , TARSKI:def 2;
L574: ( C171 /. 1 ) = C168 by L573 , L572;
reconsider D82 = C171 as non  empty (FinSequence of ( NAT )) by L571;
take D82;
L575: 2 in ( Seg 2 ) by FINSEQ_1:2 , TARSKI:def 2;
thus L576: (( D82 /. 1 ) = C168 & ( D82 /. ( len D82 ) ) = C169) by L575 , L571 , L572 , L573;
let C172 being (Element of ( NAT ));
assume L577: 1 <= C172;
assume L578: C172 < ( len D82 );
L579: C172 < ( 1 + 1 ) by L578 , L571;
L580: C172 <= 1 by L579 , NAT_1:13;
L581: C172 = 1 by L580 , L577 , XXREAL_0:1;
thus L582: thesis by L581 , L563 , L574;
end;
definition
let C173 being  with_zero set;
let C174 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C173;
let C175 being (Element of ( NAT ));
let C176 being Nat;
func C175 -' (C176 , C174) -> (Element of ( NAT )) equals 
( il. (C174 , ( ( locnum (C175 , C174) ) -' C176 )) );
coherence;
end;
theorem
L584: (for R20 being  with_zero set holds (for R21 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20 holds (for R22 being (Element of ( NAT )) holds ( R22 -' (( 0 ) , R21) ) = R22)))
proof
let R20 being  with_zero set;
let R21 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let R22 being (Element of ( NAT ));
thus L585: ( R22 -' (( 0 ) , R21) ) = ( il. (R21 , ( locnum (R22 , R21) )) ) by NAT_D:40
.= R22 by L303;
end;
theorem
L586: (for R18 being Nat holds (for R20 being  with_zero set holds (for R21 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20 holds (for R22 being (Element of ( NAT )) holds ( ( R22 + (R18 , R21) ) -' (R18 , R21) ) = R22))))
proof
let R18 being Nat;
let R20 being  with_zero set;
let R21 being  weakly_standard  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let R22 being (Element of ( NAT ));
thus L587: ( ( R22 + (R18 , R21) ) -' (R18 , R21) ) = ( il. (R21 , ( ( ( locnum (R22 , R21) ) + R18 ) -' R18 )) ) by L303
.= ( il. (R21 , ( locnum (R22 , R21) )) ) by NAT_D:34
.= R22 by L303;
end;
