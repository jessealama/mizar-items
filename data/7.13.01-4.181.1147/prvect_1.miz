:: Product of Families of Groups and Vector Spaces
::  by Anna Lango and Grzegorz Bancerek
::
:: Received December 29, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RLVECT_1, ALGSTR_0, XBOOLE_0, STRUCT_0, VECTSP_1, SUPINF_2,
      BINOP_1, SUBSET_1, FUNCT_1, ARYTM_3, FINSEQOP, ARYTM_1, RELAT_1, GROUP_1,
      NAT_1, FINSEQ_2, CARD_3, FUNCOP_1, SETWISEO, ZFMISC_1, PARTFUN1, TARSKI,
      FINSEQ_1, MESFUNC1, MCART_1, FUNCT_6, GROUP_2, NUMBERS, PRVECT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ORDINAL1, NAT_1,
      CARD_3, RELAT_1, FUNCT_1, STRUCT_0, ALGSTR_0, PARTFUN1, FUNCT_2, FUNCT_3,
      BINOP_1, FUNCOP_1, RLVECT_1, GROUP_1, VECTSP_1, FINSEQOP, FINSEQ_1,
      FUNCT_6, SETWISEO, FINSEQ_2;
 constructors PARTFUN1, BINOP_1, FUNCT_3, SETWISEO, FUNCT_5, CARD_3, FINSEQOP,
      FUNCT_6, VECTSP_1, RLVECT_1, RELSET_1, FINSEQ_2;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2, FINSEQ_1,
      FINSEQ_2, CARD_3, STRUCT_0, VECTSP_1, RELSET_1, CARD_1;
 requirements BOOLE, SUBSET;
 definitions TARSKI, BINOP_1, FINSEQOP, VECTSP_1, STRUCT_0, RELAT_1, RLVECT_1,
      ALGSTR_0;
 theorems BINOP_1, FUNCT_1, FUNCT_2, FUNCT_3, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQOP, FUNCOP_1, VECTSP_1, ZFMISC_1, SETWISEO, TARSKI, CARD_3,
      FUNCT_6, RLVECT_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, FVSUM_1,
      GROUP_1, CARD_1, XTUPLE_0;
 schemes FUNCT_1, BINOP_1, FUNCT_2, FINSEQ_1, CLASSES1;

begin
deffunc H1(1-sorted) = (the carrier of $1);
deffunc H2(addLoopStr) = (the addF of $1);
deffunc H3(non  empty addLoopStr) = ( comp $1 );
deffunc H4(addLoopStr) = ( 0. $1 );
theorem
L1: (for R1 being  Abelian  add-associative  right_complementable  right_zeroed non  empty addLoopStr holds ( 0. R1 ) is_a_unity_wrt (the addF of R1))
proof
let R1 being  Abelian  add-associative  right_complementable  right_zeroed non  empty addLoopStr;
L2:
now
let C1 being (Element of R1);
thus L3: ( (the addF of R1) . (( 0. R1 ) , C1) ) = ( ( 0. R1 ) + C1 )
.= C1 by RLVECT_1:4;
thus L4: ( (the addF of R1) . (C1 , ( 0. R1 )) ) = ( C1 + ( 0. R1 ) )
.= C1 by RLVECT_1:4;
end;
thus L5: thesis by L2 , BINOP_1:3;
end;
theorem
L6: (for B1 being AbGroup holds ( comp B1 ) is_an_inverseOp_wrt (the addF of B1))
proof
let C2 being AbGroup;
L7: ( 0. C2 ) is_a_unity_wrt (the addF of C2) by L1;
L8:
now
let C3 being (Element of C2);
thus L9: ( (the addF of C2) . (C3 , ( ( comp C2 ) . C3 )) ) = ( C3 + ( - C3 ) ) by VECTSP_1:def 13
.= ( 0. C2 ) by RLVECT_1:5
.= ( the_unity_wrt (the addF of C2) ) by L7 , BINOP_1:def 8;
thus L10: ( (the addF of C2) . (( ( comp C2 ) . C3 ) , C3) ) = ( ( ( comp C2 ) . C3 ) + C3 )
.= ( C3 + ( - C3 ) ) by VECTSP_1:def 13
.= ( 0. C2 ) by RLVECT_1:5
.= ( the_unity_wrt (the addF of C2) ) by L7 , BINOP_1:def 8;
end;
thus L11: thesis by L8 , FINSEQOP:def 1;
end;
L12: (for R1 being  Abelian  add-associative  right_complementable  right_zeroed non  empty addLoopStr holds ( comp R1 ) is_an_inverseOp_wrt (the addF of R1))
proof
let R1 being  Abelian  add-associative  right_complementable  right_zeroed non  empty addLoopStr;
L13: ( 0. R1 ) is_a_unity_wrt (the addF of R1) by L1;
L14:
now
let C4 being (Element of R1);
thus L15: ( (the addF of R1) . (C4 , ( ( comp R1 ) . C4 )) ) = ( C4 + ( - C4 ) ) by VECTSP_1:def 13
.= ( 0. R1 ) by RLVECT_1:5
.= ( the_unity_wrt (the addF of R1) ) by L13 , BINOP_1:def 8;
thus L16: ( (the addF of R1) . (( ( comp R1 ) . C4 ) , C4) ) = ( ( ( comp R1 ) . C4 ) + C4 )
.= ( C4 + ( - C4 ) ) by VECTSP_1:def 13
.= ( 0. R1 ) by RLVECT_1:5
.= ( the_unity_wrt (the addF of R1) ) by L13 , BINOP_1:def 8;
end;
thus L17: thesis by L14 , FINSEQOP:def 1;
end;
theorem
L18: (for R2 being non  empty addLoopStr holds (((the addF of R2) is  commutative  associative & ( 0. R2 ) is_a_unity_wrt (the addF of R2) & ( comp R2 ) is_an_inverseOp_wrt (the addF of R2)) implies R2 is AbGroup))
proof
let R2 being non  empty addLoopStr;
assume that
L19: ((the addF of R2) is  commutative & (the addF of R2) is  associative)
and
L20: ( 0. R2 ) is_a_unity_wrt (the addF of R2)
and
L21: ( comp R2 ) is_an_inverseOp_wrt (the addF of R2);
L22: R2 is  right_complementable
proof
let C5 being (Element of R2);
reconsider D1 = ( ( comp R2 ) . C5 ) as (Element of R2);
take D1;
thus L23: ( C5 + D1 ) = ( the_unity_wrt (the addF of R2) ) by L21 , FINSEQOP:def 1
.= ( 0. R2 ) by L20 , BINOP_1:def 8;
end;
L24: (for B2 , B3 , B4 being (Element of R2) holds (( B2 + B3 ) = ( B3 + B2 ) & ( ( B2 + B3 ) + B4 ) = ( B2 + ( B3 + B4 ) ) & ( B2 + ( 0. R2 ) ) = B2)) by L19 , L20 , BINOP_1:3 , BINOP_1:def 2 , BINOP_1:def 3;
thus L25: thesis by L24 , L22 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
end;
L26: (for R2 being non  empty addLoopStr holds ((the addF of R2) is  commutative  associative implies R2 is  Abelian  add-associative))
proof
let R2 being non  empty addLoopStr;
assume that
L27: (the addF of R2) is  commutative
and
L28: (the addF of R2) is  associative;
thus L29: R2 is  Abelian
proof
let C6 , C7 being (Element of R2);
thus L30: thesis by L27 , BINOP_1:def 2;
end;

let C8 , C9 , C10 being (Element of R2);
thus L31: thesis by L28 , BINOP_1:def 3;
end;
L32: (for R2 being non  empty addLoopStr holds (( 0. R2 ) is_a_unity_wrt (the addF of R2) implies R2 is  right_zeroed))
proof
let R2 being non  empty addLoopStr;
assume L33: ( 0. R2 ) is_a_unity_wrt (the addF of R2);
let C11 being (Element of R2);
thus L34: thesis by L33 , BINOP_1:3;
end;
L35: (for R3 being Field holds (the multF of R3) is  associative)
proof
let R3 being Field;
let C12 , C13 , C14 being (Element of R3);
thus L36: ( (the multF of R3) . (C12 , ( (the multF of R3) . (C13 , C14) )) ) = ( C12 * ( C13 * C14 ) )
.= ( ( C12 * C13 ) * C14 ) by GROUP_1:def 3
.= ( (the multF of R3) . (( (the multF of R3) . (C12 , C13) ) , C14) );
end;
theorem
L37: (for R3 being Field holds ( 0. R3 ) is_a_unity_wrt (the addF of R3))
proof
let R3 being Field;
L38:
now
let C15 being (Element of R3);
thus L39: ( (the addF of R3) . (( 0. R3 ) , C15) ) = ( C15 + ( 0. R3 ) ) by RLVECT_1:2
.= C15 by RLVECT_1:4;
thus L40: ( (the addF of R3) . (C15 , ( 0. R3 )) ) = ( C15 + ( 0. R3 ) )
.= C15 by RLVECT_1:4;
end;
thus L41: thesis by L38 , BINOP_1:3;
end;
theorem
L42: (for R3 being Field holds ( 1_ R3 ) is_a_unity_wrt (the multF of R3))
proof
let R3 being Field;
L43:
now
let C16 being (Element of R3);
thus L44: ( (the multF of R3) . (( 1_ R3 ) , C16) ) = ( ( 1_ R3 ) * C16 )
.= C16 by VECTSP_1:def 8;
thus L45: ( (the multF of R3) . (C16 , ( 1_ R3 )) ) = ( C16 * ( 1_ R3 ) )
.= C16 by VECTSP_1:def 8;
end;
thus L46: thesis by L43 , BINOP_1:3;
end;
L47: (for R3 being Field holds (the multF of R3) is_distributive_wrt (the addF of R3))
proof
let R3 being Field;
L48:
now
let C17 , C18 , C19 being (Element of R3);
thus L49: ( (the multF of R3) . (C17 , ( (the addF of R3) . (C18 , C19) )) ) = ( C17 * ( C18 + C19 ) )
.= ( ( C17 * C18 ) + ( C17 * C19 ) ) by VECTSP_1:def 7
.= ( (the addF of R3) . (( (the multF of R3) . (C17 , C18) ) , ( (the multF of R3) . (C17 , C19) )) );
thus L50: ( (the multF of R3) . (( (the addF of R3) . (C17 , C18) ) , C19) ) = ( ( C17 + C18 ) * C19 )
.= ( ( C17 * C19 ) + ( C18 * C19 ) ) by VECTSP_1:def 7
.= ( (the addF of R3) . (( (the multF of R3) . (C17 , C19) ) , ( (the multF of R3) . (C18 , C19) )) );
end;
thus L51: thesis by L48 , BINOP_1:11;
end;
begin
definition
let R6 being non  empty set;
let R5 being Nat;
let C20 being (BinOp of R6);
let C21 , C22 being (Element of ( R5 -tuples_on R6 ));
redefine func C20 .: (C21 , C22) -> (Element of ( R5 -tuples_on R6 ));

coherence by FINSEQ_2:120;
end;
definition
let C23 being non  empty set;
let C24 being (BinOp of C23);
let C25 being Nat;
func product (C24 , C25) -> (BinOp of ( C25 -tuples_on C23 )) means 
:L53: (for B5 , B6 being (Element of ( C25 -tuples_on C23 )) holds ( it . (B5 , B6) ) = ( C24 .: (B5 , B6) ));
existence
proof
defpred S1[ set , set , set ] means (ex B7 , B8 being (Element of ( C25 -tuples_on C23 )) st ($1 = B7 & $2 = B8 & $3 = ( C24 .: (B7 , B8) )));
L54: (for B9 , B10 being (Element of (( C25 -tuples_on C23 ) qua non  empty set)) holds (ex B11 being (Element of (( C25 -tuples_on C23 ) qua non  empty set)) st S1[ B9 , B10 , B11 ]))
proof
let C26 , C27 being (Element of (( C25 -tuples_on C23 ) qua non  empty set));
reconsider D2 = C26 , D3 = C27 as (Element of ( C25 -tuples_on C23 ));
reconsider D4 = ( C24 .: (D2 , D3) ) as (Element of (( C25 -tuples_on C23 ) qua non  empty set));
take D4;
take D2;
take D3;
thus L55: thesis;
end;
consider C28 being (BinOp of ( C25 -tuples_on C23 )) such that L56: (for B12 , B13 being (Element of (( C25 -tuples_on C23 ) qua non  empty set)) holds S1[ B12 , B13 , ( C28 . (B12 , B13) ) ]) from BINOP_1:sch 3(L54);
take C28;
let C29 , C30 being (Element of ( C25 -tuples_on C23 ));
reconsider D5 = C29 , D6 = C30 as (Element of (( C25 -tuples_on C23 ) qua non  empty set));
L57: (ex B14 , B15 being (Element of ( C25 -tuples_on C23 )) st (D5 = B14 & D6 = B15 & ( C28 . (D5 , D6) ) = ( C24 .: (B14 , B15) ))) by L56;
thus L58: thesis by L57;
end;
uniqueness
proof
let C31 , C32 being (BinOp of ( C25 -tuples_on C23 ));
assume that
L59: (for B16 , B17 being (Element of ( C25 -tuples_on C23 )) holds ( C31 . (B16 , B17) ) = ( C24 .: (B16 , B17) ))
and
L60: (for B18 , B19 being (Element of ( C25 -tuples_on C23 )) holds ( C32 . (B18 , B19) ) = ( C24 .: (B18 , B19) ));
L61:
now
let C33 , C34 being (Element of ( C25 -tuples_on C23 ));
L62: ( C31 . (C33 , C34) ) = ( C24 .: (C33 , C34) ) by L59;
thus L63: ( C31 . (C33 , C34) ) = ( C32 . (C33 , C34) ) by L62 , L60;
end;
thus L64: C31 = C32 by L61 , BINOP_1:2;
end;
end;
definition
let R6 being non  empty set;
let C35 being (UnOp of R6);
let R5 being Nat;
func product (C35 , R5) -> (UnOp of ( R5 -tuples_on R6 )) means 
:L66: (for B20 being (Element of ( R5 -tuples_on R6 )) holds ( it . B20 ) = ( C35 * B20 ));
existence
proof
defpred S2[ set , set ] means (ex B21 being (Element of ( R5 -tuples_on R6 )) st (B21 = $1 & $2 = ( C35 * B21 )));
L67: (for B22 being (Element of (( R5 -tuples_on R6 ) qua non  empty set)) holds (ex B23 being (Element of (( R5 -tuples_on R6 ) qua non  empty set)) st S2[ B22 , B23 ]))
proof
let C36 being (Element of (( R5 -tuples_on R6 ) qua non  empty set));
reconsider D7 = C36 as (Element of ( R5 -tuples_on R6 ));
reconsider D8 = ( C35 * D7 ) as (Element of (( R5 -tuples_on R6 ) qua non  empty set)) by FINSEQ_2:113;
take D8;
take D7;
thus L68: thesis;
end;
consider C37 being (UnOp of ( R5 -tuples_on R6 )) such that L69: (for B24 being (Element of (( R5 -tuples_on R6 ) qua non  empty set)) holds S2[ B24 , ( C37 . B24 ) ]) from FUNCT_2:sch 3(L67);
take C37;
let C38 being (Element of ( R5 -tuples_on R6 ));
reconsider D9 = C38 as (Element of (( R5 -tuples_on R6 ) qua non  empty set));
L70: (ex B25 being (Element of ( R5 -tuples_on R6 )) st (B25 = D9 & ( C37 . D9 ) = ( C35 * B25 ))) by L69;
thus L71: thesis by L70;
end;
uniqueness
proof
let C39 , C40 being (UnOp of ( R5 -tuples_on R6 ));
assume that
L72: (for B26 being (Element of ( R5 -tuples_on R6 )) holds ( C39 . B26 ) = ( C35 * B26 ))
and
L73: (for B27 being (Element of ( R5 -tuples_on R6 )) holds ( C40 . B27 ) = ( C35 * B27 ));
L74:
now
let C41 being (Element of ( R5 -tuples_on R6 ));
L75: ( C39 . C41 ) = ( C35 * C41 ) by L72;
thus L76: ( C39 . C41 ) = ( C40 . C41 ) by L75 , L73;
end;
thus L77: thesis by L74 , FUNCT_2:63;
end;
end;
theorem
L79: (for R5 being Nat holds (for R6 being non  empty set holds (for R8 being (BinOp of R6) holds (R8 is  commutative implies ( product (R8 , R5) ) is  commutative))))
proof
let R5 being Nat;
let R6 being non  empty set;
let R8 being (BinOp of R6);
assume L80: R8 is  commutative;
L81:
now
let C42 , C43 being (Element of ( R5 -tuples_on R6 ));
thus L82: ( ( product (R8 , R5) ) . (C42 , C43) ) = ( R8 .: (C42 , C43) ) by L53
.= ( R8 .: (C43 , C42) ) by L80 , FINSEQOP:33
.= ( ( product (R8 , R5) ) . (C43 , C42) ) by L53;
end;
thus L83: thesis by L81 , BINOP_1:def 2;
end;
theorem
L84: (for R5 being Nat holds (for R6 being non  empty set holds (for R8 being (BinOp of R6) holds (R8 is  associative implies ( product (R8 , R5) ) is  associative))))
proof
let R5 being Nat;
let R6 being non  empty set;
let R8 being (BinOp of R6);
assume L85: R8 is  associative;
L86:
now
let C44 , C45 , C46 being (Element of ( R5 -tuples_on R6 ));
thus L87: ( ( product (R8 , R5) ) . (( ( product (R8 , R5) ) . (C44 , C45) ) , C46) ) = ( ( product (R8 , R5) ) . (( R8 .: (C44 , C45) ) , C46) ) by L53
.= ( R8 .: (( R8 .: (C44 , C45) ) , C46) ) by L53
.= ( R8 .: (C44 , ( R8 .: (C45 , C46) )) ) by L85 , FINSEQOP:28
.= ( ( product (R8 , R5) ) . (C44 , ( R8 .: (C45 , C46) )) ) by L53
.= ( ( product (R8 , R5) ) . (C44 , ( ( product (R8 , R5) ) . (C45 , C46) )) ) by L53;
end;
thus L88: thesis by L86 , BINOP_1:def 3;
end;
theorem
L89: (for R5 being Nat holds (for R6 being non  empty set holds (for R7 being (Element of R6) holds (for R8 being (BinOp of R6) holds (R7 is_a_unity_wrt R8 implies ( R5 |-> R7 ) is_a_unity_wrt ( product (R8 , R5) ))))))
proof
let R5 being Nat;
let R6 being non  empty set;
let R7 being (Element of R6);
let R8 being (BinOp of R6);
assume L90: R7 is_a_unity_wrt R8;
L91: (R8 is  having_a_unity & R7 = ( the_unity_wrt R8 )) by L90 , BINOP_1:def 8 , SETWISEO:def 2;
L92:
now
let C47 being (Element of (( R5 -tuples_on R6 ) qua non  empty set));
reconsider D10 = C47 as (Element of ( R5 -tuples_on R6 ));
thus L93: ( ( product (R8 , R5) ) . (( R5 |-> R7 ) , C47) ) = ( R8 .: (( R5 |-> R7 ) , D10) ) by L53
.= C47 by L91 , FINSEQOP:56;
thus L94: ( ( product (R8 , R5) ) . (C47 , ( R5 |-> R7 )) ) = ( R8 .: (D10 , ( R5 |-> R7 )) ) by L53
.= C47 by L91 , FINSEQOP:56;
end;
thus L95: thesis by L92 , BINOP_1:3;
end;
theorem
L96: (for R5 being Nat holds (for R6 being non  empty set holds (for R8 being (BinOp of R6) holds (for R9 being (UnOp of R6) holds ((R8 is  having_a_unity & R8 is  associative & R9 is_an_inverseOp_wrt R8) implies ( product (R9 , R5) ) is_an_inverseOp_wrt ( product (R8 , R5) ))))))
proof
let R5 being Nat;
let R6 being non  empty set;
let R8 being (BinOp of R6);
let R9 being (UnOp of R6);
assume that
L97: R8 is  having_a_unity
and
L98: R8 is  associative
and
L99: R9 is_an_inverseOp_wrt R8;
L100: R8 is  having_an_inverseOp by L99 , FINSEQOP:def 2;
L101: R9 = ( the_inverseOp_wrt R8 ) by L100 , L97 , L98 , L99 , FINSEQOP:def 3;
L102:
now
let C48 being (Element of (( R5 -tuples_on R6 ) qua non  empty set));
reconsider D11 = C48 as (Element of ( R5 -tuples_on R6 ));
reconsider D12 = ( R9 * D11 ) as (Element of ( R5 -tuples_on R6 )) by FINSEQ_2:113;
thus L103: ( ( product (R8 , R5) ) . (C48 , ( ( product (R9 , R5) ) . C48 )) ) = ( ( product (R8 , R5) ) . (D11 , ( R9 * D11 )) ) by L66
.= ( R8 .: (D11 , D12) ) by L53
.= ( R5 |-> ( the_unity_wrt R8 ) ) by L97 , L98 , L100 , L101 , FINSEQOP:73;
thus L104: ( ( product (R8 , R5) ) . (( ( product (R9 , R5) ) . C48 ) , C48) ) = ( ( product (R8 , R5) ) . (( R9 * D11 ) , D11) ) by L66
.= ( R8 .: (D12 , D11) ) by L53
.= ( R5 |-> ( the_unity_wrt R8 ) ) by L97 , L98 , L100 , L101 , FINSEQOP:73;
end;
L105: (ex R7 being (Element of R6) st R7 is_a_unity_wrt R8) by L97 , SETWISEO:def 2;
L106: ( the_unity_wrt R8 ) is_a_unity_wrt R8 by L105 , BINOP_1:def 8;
L107: ( R5 |-> ( the_unity_wrt R8 ) ) is_a_unity_wrt ( product (R8 , R5) ) by L106 , L89;
L108: ( R5 |-> ( the_unity_wrt R8 ) ) = ( the_unity_wrt ( product (R8 , R5) ) ) by L107 , BINOP_1:def 8;
thus L109: thesis by L108 , L102 , FINSEQOP:def 1;
end;
begin
definition
let C49 being non  empty addLoopStr;
let R5 being Nat;
assume L110: C49 is  Abelian  add-associative  right_zeroed  right_complementable;
func R5 -Group_over C49 ->  strict AbGroup equals 
:L111: addLoopStr (# ( R5 -tuples_on (the carrier of C49) ) , ( product ((the addF of C49) , R5) ) , (( R5 |-> ( 0. C49 ) ) qua (Element of ( R5 -tuples_on (the carrier of C49) ))) #);
coherence
proof
set D13 = addLoopStr (# ( R5 -tuples_on (the carrier of C49) ) , ( product ((the addF of C49) , R5) ) , (( R5 |-> ( 0. C49 ) ) qua (Element of ( R5 -tuples_on (the carrier of C49) ))) #);
reconsider D14 = D13 as non  empty addLoopStr;
L112: (the addF of C49) is  commutative  associative by L110 , FVSUM_1:1 , FVSUM_1:2;
L113: ( product ((the addF of C49) , R5) ) is  commutative  associative by L112 , L79 , L84;
L114: ( 0. C49 ) is_a_unity_wrt (the addF of C49) by L110 , L1;
L115: D14 is  right_complementable
proof
set D15 = (the addF of C49);
set D16 = ( comp C49 );
let C50 being (Element of D14);
reconsider D17 = ( ( product (( comp C49 ) , R5) ) . C50 ) as (Element of D14) by FUNCT_2:5;
take D17;
L116: (D15 is  associative & D15 is  having_a_unity) by L110 , L114 , FVSUM_1:2 , SETWISEO:def 2;
L117: ( product (D16 , R5) ) is_an_inverseOp_wrt ( product (D15 , R5) ) by L116 , L110 , L12 , L96;
L118: ( C50 + D17 ) = ( the_unity_wrt ( product (D15 , R5) ) ) by L117 , FINSEQOP:def 1;
L119: ( 0. D14 ) is_a_unity_wrt (the addF of D14) by L110 , L1 , L89;
thus L120: thesis by L119 , L118 , BINOP_1:def 8;
end;
L121: (( 0. D14 ) = ( R5 |-> ( 0. C49 ) ) & (( R5 |-> ( 0. C49 ) ) qua (Element of ( R5 -tuples_on (the carrier of C49) ))) is_a_unity_wrt ( product ((the addF of C49) , R5) )) by L110 , L1 , L89;
thus L122: thesis by L121 , L113 , L115 , L26 , L32;
end;
end;
registration
let C51 being AbGroup;
let R5 being Nat;
cluster ( R5 -Group_over C51 ) -> non  empty;
coherence;
end;
definition
let R4 being Field;
let R5 being Nat;
func R5 -Mult_over R4 -> (Function of [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :] , ( R5 -tuples_on (the carrier of R4) )) means 
:L125: (for B28 being (Element of R4) holds (for B29 being (Element of ( R5 -tuples_on (the carrier of R4) )) holds ( it . (B28 , B29) ) = ( (the multF of R4) [;] (B28 , B29) )));
existence
proof
defpred S3[ set , set ] means (ex B30 being (Element of R4) st (ex B31 being (Element of ( R5 -tuples_on (the carrier of R4) )) st ($1 = [ B30 , B31 ] & $2 = ( (the multF of R4) [;] (B30 , B31) ))));
L126: (for R10 being set holds (R10 in [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :] implies (ex R11 being set st (R11 in ( R5 -tuples_on (the carrier of R4) ) & S3[ R10 , R11 ]))))
proof
let R10 being set;
assume L127: R10 in [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :];
consider C52 , C53 being set such that L128: C52 in (the carrier of R4) and L129: C53 in ( R5 -tuples_on (the carrier of R4) ) and L130: [ C52 , C53 ] = R10 by L127 , ZFMISC_1:84;
reconsider D18 = C53 as (Element of ( R5 -tuples_on (the carrier of R4) )) by L129;
reconsider D19 = C52 as (Element of R4) by L128;
take D20 = ( (the multF of R4) [;] (D19 , D18) );
L131: D20 is (Element of ( R5 -tuples_on (the carrier of R4) )) by FINSEQ_2:121;
thus L132: D20 in ( R5 -tuples_on (the carrier of R4) ) by L131;
take D19;
take D18;
thus L133: thesis by L130;
end;
consider C54 being (Function of [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :] , ( R5 -tuples_on (the carrier of R4) )) such that L134: (for R10 being set holds (R10 in [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :] implies S3[ R10 , ( C54 . R10 ) ])) from FUNCT_2:sch 1(L126);
take C54;
let C55 being (Element of R4);
let C56 being (Element of ( R5 -tuples_on (the carrier of R4) ));
L135: [ C55 , C56 ] in [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :] by ZFMISC_1:87;
consider C57 being (Element of R4), C58 being (Element of ( R5 -tuples_on (the carrier of R4) )) such that L136: [ C55 , C56 ] = [ C57 , C58 ] and L137: ( C54 . [ C55 , C56 ] ) = ( (the multF of R4) [;] (C57 , C58) ) by L135 , L134;
L138: C57 = C55 by L136 , XTUPLE_0:1;
thus L139: thesis by L138 , L136 , L137 , XTUPLE_0:1;
end;
uniqueness
proof
let C59 , C60 being (Function of [: (the carrier of R4) , ( R5 -tuples_on (the carrier of R4) ) :] , ( R5 -tuples_on (the carrier of R4) ));
assume that
L140: (for B32 being (Element of R4) holds (for B33 being (Element of ( R5 -tuples_on (the carrier of R4) )) holds ( C59 . (B32 , B33) ) = ( (the multF of R4) [;] (B32 , B33) )))
and
L141: (for B34 being (Element of R4) holds (for B35 being (Element of ( R5 -tuples_on (the carrier of R4) )) holds ( C60 . (B34 , B35) ) = ( (the multF of R4) [;] (B34 , B35) )));
L142:
now
let C61 being (Element of R4);
let C62 being (Element of ( R5 -tuples_on (the carrier of R4) ));
L143: ( C59 . (C61 , C62) ) = ( (the multF of R4) [;] (C61 , C62) ) by L140;
thus L144: ( C59 . (C61 , C62) ) = ( C60 . (C61 , C62) ) by L143 , L141;
end;
thus L145: thesis by L142 , BINOP_1:2;
end;
end;
definition
let R4 being Field;
let R5 being Nat;
func R5 -VectSp_over R4 ->  strict VectSpStr over R4 means 
:L147: (( the addLoopStr of it ) = ( R5 -Group_over R4 ) & (the lmult of it) = ( R5 -Mult_over R4 ));
existence
proof
L148: ( R5 -Group_over R4 ) = addLoopStr (# ( R5 -tuples_on (the carrier of R4) ) , ( product ((the addF of R4) , R5) ) , (( R5 |-> ( 0. R4 ) ) qua (Element of ( R5 -tuples_on (the carrier of R4) ))) #) by L111;
reconsider D21 = ( R5 -Mult_over R4 ) as (Function of [: (the carrier of R4) , (the carrier of ( R5 -Group_over R4 )) :] , (the carrier of ( R5 -Group_over R4 ))) by L148;
set D22 = ( R5 -Group_over R4 );
take VectSpStr (# H1(D22) , H2(D22) , H4(D22) , D21 #);
thus L149: thesis;
end;
uniqueness;
end;
registration
let R4 being Field;
let R5 being Nat;
cluster ( R5 -VectSp_over R4 ) -> non  empty;
coherence
proof
L151: ( the addLoopStr of ( R5 -VectSp_over R4 ) ) = ( R5 -Group_over R4 ) by L147;
thus L152: (the carrier of ( R5 -VectSp_over R4 )) is non  empty by L151;
end;
end;
theorem
L154: (for R5 being Nat holds (for R12 being non  empty set holds (for R13 being (BinOp of R12) holds (for R14 being (BinOp of R12) holds (for R15 being (Element of R12) holds (for R16 being (Element of ( R5 -tuples_on R12 )) holds (for R17 being (Element of ( R5 -tuples_on R12 )) holds (R13 is_distributive_wrt R14 implies ( R13 [;] (R15 , ( R14 .: (R16 , R17) )) ) = ( R14 .: (( R13 [;] (R15 , R16) ) , ( R13 [;] (R15 , R17) )) )))))))))
proof
let R5 being Nat;
let R12 being non  empty set;
let R13 being (BinOp of R12);
let R14 being (BinOp of R12);
let R15 being (Element of R12);
let R16 being (Element of ( R5 -tuples_on R12 ));
let R17 being (Element of ( R5 -tuples_on R12 ));
L155: ( R13 [;] (R15 , ( R14 .: (R16 , R17) )) ) = ( R13 [;] (R15 , ( R14 * <: R16 , R17 :> )) ) by FUNCOP_1:def 3
.= ( R13 * <: ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) , ( R14 * <: R16 , R17 :> ) :> ) by FUNCOP_1:def 5;
L156: (( rng ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) ) c= ( rng R13 ) & ( rng ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) ) c= ( rng R13 )) by RELAT_1:26;
L157: (( rng <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) c= [: ( rng ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) ) , ( rng ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) ) :] & [: ( rng ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) ) , ( rng ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) ) :] c= [: ( rng R13 ) , ( rng R13 ) :]) by L156 , FUNCT_3:51 , ZFMISC_1:96;
L158: ( rng <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) c= [: ( rng R13 ) , ( rng R13 ) :] by L157 , XBOOLE_1:1;
L159: ( rng R13 ) c= R12 by RELAT_1:def 19;
L160: [: ( rng R13 ) , ( rng R13 ) :] c= [: R12 , R12 :] by L159 , ZFMISC_1:96;
L161: ( rng <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) c= [: R12 , R12 :] by L160 , L158 , XBOOLE_1:1;
L162: ( rng <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) c= ( dom R14 ) by L161 , FUNCT_2:def 1;
L163: ( dom R17 ) = ( Seg ( len R17 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L164: (( rng R16 ) c= R12 & ( rng R17 ) c= R12) by FINSEQ_1:def 4;
L165: [: ( rng R16 ) , ( rng R17 ) :] c= [: R12 , R12 :] by L164 , ZFMISC_1:96;
L166: ( rng <: R16 , R17 :> ) c= [: ( rng R16 ) , ( rng R17 ) :] by FUNCT_3:51;
L167: ( rng <: R16 , R17 :> ) c= [: R12 , R12 :] by L166 , L165 , XBOOLE_1:1;
L168: ( rng <: R16 , R17 :> ) c= ( dom R14 ) by L167 , FUNCT_2:def 1;
L169: ( dom ( ( dom R17 ) --> R15 ) ) = ( dom R17 ) by FUNCOP_1:13
.= ( Seg ( len R17 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L170: ( dom R16 ) = ( Seg ( len R16 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L171: ( dom <: R16 , R17 :> ) = ( Seg R5 ) by L170 , L163 , FUNCT_3:50;
L172: ( dom ( R14 * <: R16 , R17 :> ) ) = ( Seg R5 ) by L171 , L168 , RELAT_1:27;
L173: ( dom ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) ) = ( Seg R5 ) by L172 , FUNCOP_1:13;
L174: ( dom <: ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) , ( R14 * <: R16 , R17 :> ) :> ) = ( Seg R5 ) by L173 , L172 , FUNCT_3:50;
L175: ( rng R17 ) c= R12 by FINSEQ_1:def 4;
L176: (( rng <: ( ( dom R17 ) --> R15 ) , R17 :> ) c= [: ( rng ( ( dom R17 ) --> R15 ) ) , ( rng R17 ) :] & [: ( rng ( ( dom R17 ) --> R15 ) ) , ( rng R17 ) :] c= [: ( rng ( ( dom R17 ) --> R15 ) ) , R12 :]) by L175 , FUNCT_3:51 , ZFMISC_1:96;
L177: ( rng <: ( ( dom R17 ) --> R15 ) , R17 :> ) c= [: ( rng ( ( dom R17 ) --> R15 ) ) , R12 :] by L176 , XBOOLE_1:1;
L178: ( rng ( ( dom R17 ) --> R15 ) ) c= { R15 } by FUNCOP_1:13;
L179: [: ( rng ( ( dom R17 ) --> R15 ) ) , R12 :] c= [: { R15 } , R12 :] by L178 , ZFMISC_1:96;
L180: ( rng <: ( ( dom R17 ) --> R15 ) , R17 :> ) c= [: { R15 } , R12 :] by L179 , L177 , XBOOLE_1:1;
L181: ( dom R16 ) = ( Seg ( len R16 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L182: ( rng R16 ) c= R12 by FINSEQ_1:def 4;
L183: (( rng <: ( ( dom R16 ) --> R15 ) , R16 :> ) c= [: ( rng ( ( dom R16 ) --> R15 ) ) , ( rng R16 ) :] & [: ( rng ( ( dom R16 ) --> R15 ) ) , ( rng R16 ) :] c= [: ( rng ( ( dom R16 ) --> R15 ) ) , R12 :]) by L182 , FUNCT_3:51 , ZFMISC_1:96;
L184: ( rng <: ( ( dom R16 ) --> R15 ) , R16 :> ) c= [: ( rng ( ( dom R16 ) --> R15 ) ) , R12 :] by L183 , XBOOLE_1:1;
L185: ( rng ( ( dom R16 ) --> R15 ) ) c= { R15 } by FUNCOP_1:13;
L186: [: ( rng ( ( dom R16 ) --> R15 ) ) , R12 :] c= [: { R15 } , R12 :] by L185 , ZFMISC_1:96;
L187: ( rng <: ( ( dom R16 ) --> R15 ) , R16 :> ) c= [: { R15 } , R12 :] by L186 , L184 , XBOOLE_1:1;
L188: ( dom ( ( dom R16 ) --> R15 ) ) = ( dom R16 ) by FUNCOP_1:13
.= ( Seg ( len R16 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L189: { R15 } c= R12 by ZFMISC_1:31;
L190: [: { R15 } , R12 :] c= [: R12 , R12 :] by L189 , ZFMISC_1:96;
L191: (( rng ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) ) c= { R15 } & { R15 } c= R12) by FUNCOP_1:13 , ZFMISC_1:31;
L192: ( rng ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) ) c= R12 by L191 , XBOOLE_1:1;
L193: ( dom R17 ) = ( Seg ( len R17 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L194: ( dom R13 ) = [: R12 , R12 :] by FUNCT_2:def 1;
L195: ( dom ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) ) = ( dom <: ( ( dom R17 ) --> R15 ) , R17 :> ) by L194 , L180 , L190 , RELAT_1:27 , XBOOLE_1:1
.= ( Seg R5 ) by L169 , L193 , FUNCT_3:50;
L196: { R15 } c= R12 by ZFMISC_1:31;
L197: [: { R15 } , R12 :] c= [: R12 , R12 :] by L196 , ZFMISC_1:96;
set D23 = ( R13 * <: ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) , ( R14 * <: R16 , R17 :> ) :> );
L198: ( R14 .: (( R13 [;] (R15 , R16) ) , ( R13 [;] (R15 , R17) )) ) = ( R14 .: (( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 [;] (R15 , R17) )) ) by FUNCOP_1:def 5
.= ( R14 .: (( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> )) ) by FUNCOP_1:def 5
.= ( R14 * <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) by FUNCOP_1:def 3;
L199: ( dom R13 ) = [: R12 , R12 :] by FUNCT_2:def 1;
L200: ( dom ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) ) = ( dom <: ( ( dom R16 ) --> R15 ) , R16 :> ) by L199 , L187 , L197 , RELAT_1:27 , XBOOLE_1:1
.= ( Seg R5 ) by L188 , L181 , FUNCT_3:50;
L201: ( dom <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) = ( Seg R5 ) by L200 , L195 , FUNCT_3:50;
L202: ( dom ( R14 * <: ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) , ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) :> ) ) = ( Seg R5 ) by L201 , L162 , RELAT_1:27;
L203: ( rng ( R14 * <: R16 , R17 :> ) ) c= R12 by RELAT_1:def 19;
L204: (( rng <: ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) , ( R14 * <: R16 , R17 :> ) :> ) c= [: ( rng ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) ) , ( rng ( R14 * <: R16 , R17 :> ) ) :] & [: ( rng ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) ) , ( rng ( R14 * <: R16 , R17 :> ) ) :] c= [: R12 , R12 :]) by L203 , L192 , FUNCT_3:51 , ZFMISC_1:96;
L205: ( rng <: ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) , ( R14 * <: R16 , R17 :> ) :> ) c= [: R12 , R12 :] by L204 , XBOOLE_1:1;
L206: ( rng <: ( ( dom ( R14 * <: R16 , R17 :> ) ) --> R15 ) , ( R14 * <: R16 , R17 :> ) :> ) c= ( dom R13 ) by L205 , FUNCT_2:def 1;
L207: ( dom D23 ) = ( Seg R5 ) by L206 , L174 , RELAT_1:27;
assume L208: R13 is_distributive_wrt R14;
L209: (for R10 being set holds (R10 in ( dom D23 ) implies ( ( R13 [;] (R15 , ( R14 .: (R16 , R17) )) ) . R10 ) = ( ( R14 .: (( R13 [;] (R15 , R16) ) , ( R13 [;] (R15 , R17) )) ) . R10 )))
proof
L210: ( rng R16 ) c= R12 by FINSEQ_1:def 4;
L211: (( rng <: ( ( dom R16 ) --> R15 ) , R16 :> ) c= [: ( rng ( ( dom R16 ) --> R15 ) ) , ( rng R16 ) :] & [: ( rng ( ( dom R16 ) --> R15 ) ) , ( rng R16 ) :] c= [: ( rng ( ( dom R16 ) --> R15 ) ) , R12 :]) by L210 , FUNCT_3:51 , ZFMISC_1:96;
L212: ( rng <: ( ( dom R16 ) --> R15 ) , R16 :> ) c= [: ( rng ( ( dom R16 ) --> R15 ) ) , R12 :] by L211 , XBOOLE_1:1;
L213: ( rng ( ( dom R16 ) --> R15 ) ) c= { R15 } by FUNCOP_1:13;
L214: [: ( rng ( ( dom R16 ) --> R15 ) ) , R12 :] c= [: { R15 } , R12 :] by L213 , ZFMISC_1:96;
L215: ( rng <: ( ( dom R16 ) --> R15 ) , R16 :> ) c= [: { R15 } , R12 :] by L214 , L212 , XBOOLE_1:1;
L216: (( rng R16 ) c= R12 & ( rng R17 ) c= R12) by FINSEQ_1:def 4;
L217: { R15 } c= R12 by ZFMISC_1:31;
L218: [: { R15 } , R12 :] c= [: R12 , R12 :] by L217 , ZFMISC_1:96;
L219: ( dom ( ( dom R17 ) --> R15 ) ) = ( dom R17 ) by FUNCOP_1:13
.= ( Seg ( len R17 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L220: { R15 } c= R12 by ZFMISC_1:31;
L221: [: { R15 } , R12 :] c= [: R12 , R12 :] by L220 , ZFMISC_1:96;
L222: ( dom R16 ) = ( Seg ( len R16 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L223: ( rng R17 ) c= R12 by FINSEQ_1:def 4;
L224: (( rng <: ( ( dom R17 ) --> R15 ) , R17 :> ) c= [: ( rng ( ( dom R17 ) --> R15 ) ) , ( rng R17 ) :] & [: ( rng ( ( dom R17 ) --> R15 ) ) , ( rng R17 ) :] c= [: ( rng ( ( dom R17 ) --> R15 ) ) , R12 :]) by L223 , FUNCT_3:51 , ZFMISC_1:96;
L225: ( rng <: ( ( dom R17 ) --> R15 ) , R17 :> ) c= [: ( rng ( ( dom R17 ) --> R15 ) ) , R12 :] by L224 , XBOOLE_1:1;
L226: ( rng ( ( dom R17 ) --> R15 ) ) c= { R15 } by FUNCOP_1:13;
L227: [: ( rng ( ( dom R17 ) --> R15 ) ) , R12 :] c= [: { R15 } , R12 :] by L226 , ZFMISC_1:96;
L228: ( rng <: ( ( dom R17 ) --> R15 ) , R17 :> ) c= [: { R15 } , R12 :] by L227 , L225 , XBOOLE_1:1;
L229: ( dom ( ( dom R16 ) --> R15 ) ) = ( dom R16 ) by FUNCOP_1:13
.= ( Seg ( len R16 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
let R10 being set;
L230: ( dom <: ( ( dom ( R14 .: (R16 , R17) ) ) --> R15 ) , ( R14 .: (R16 , R17) ) :> ) = ( ( dom ( ( dom ( R14 .: (R16 , R17) ) ) --> R15 ) ) /\ ( dom ( R14 .: (R16 , R17) ) ) ) by FUNCT_3:def 7;
assume L231: R10 in ( dom D23 );
L232: R10 in ( dom ( R13 * <: ( ( dom ( R14 .: (R16 , R17) ) ) --> R15 ) , ( R14 .: (R16 , R17) ) :> ) ) by L231 , L155 , FUNCOP_1:def 5;
L233: R10 in ( dom <: ( ( dom ( R14 .: (R16 , R17) ) ) --> R15 ) , ( R14 .: (R16 , R17) ) :> ) by L232 , FUNCT_1:11;
L234: R10 in ( dom ( R14 .: (R16 , R17) ) ) by L233 , L230 , XBOOLE_0:def 4;
L235: ( dom R16 ) = ( Seg ( len R16 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L236: ( R16 . R10 ) in ( rng R16 ) by L235 , L207 , L231 , FUNCT_1:def 3;
L237: ( dom R17 ) = ( Seg ( len R17 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L238: ( dom R13 ) = [: R12 , R12 :] by FUNCT_2:def 1;
L239: ( dom ( R13 * <: ( ( dom R16 ) --> R15 ) , R16 :> ) ) = ( dom <: ( ( dom R16 ) --> R15 ) , R16 :> ) by L238 , L215 , L221 , RELAT_1:27 , XBOOLE_1:1
.= ( Seg R5 ) by L229 , L222 , FUNCT_3:50;
L240: R10 in ( dom ( R13 [;] (R15 , R16) ) ) by L239 , L207 , L231 , FUNCOP_1:def 5;
L241: ( dom R17 ) = ( Seg ( len R17 ) ) by FINSEQ_1:def 3
.= ( Seg R5 ) by CARD_1:def 7;
L242: ( R17 . R10 ) in ( rng R17 ) by L241 , L207 , L231 , FUNCT_1:def 3;
L243: ( dom R13 ) = [: R12 , R12 :] by FUNCT_2:def 1;
L244: ( dom ( R13 * <: ( ( dom R17 ) --> R15 ) , R17 :> ) ) = ( dom <: ( ( dom R17 ) --> R15 ) , R17 :> ) by L243 , L228 , L218 , RELAT_1:27 , XBOOLE_1:1
.= ( Seg R5 ) by L219 , L237 , FUNCT_3:50;
L245: R10 in ( dom ( R13 [;] (R15 , R17) ) ) by L244 , L207 , L231 , FUNCOP_1:def 5;
L246: ( ( R13 [;] (R15 , ( R14 .: (R16 , R17) )) ) . R10 ) = ( R13 . (R15 , ( ( R14 .: (R16 , R17) ) . R10 )) ) by L155 , L231 , FUNCOP_1:32
.= ( R13 . (R15 , ( R14 . (( R16 . R10 ) , ( R17 . R10 )) )) ) by L234 , FUNCOP_1:22
.= ( R14 . (( R13 . (R15 , ( R16 . R10 )) ) , ( R13 . (R15 , ( R17 . R10 )) )) ) by L208 , L236 , L216 , L242 , BINOP_1:11
.= ( R14 . (( ( R13 [;] (R15 , R16) ) . R10 ) , ( R13 . (R15 , ( R17 . R10 )) )) ) by L240 , FUNCOP_1:32
.= ( R14 . (( ( R13 [;] (R15 , R16) ) . R10 ) , ( ( R13 [;] (R15 , R17) ) . R10 )) ) by L245 , FUNCOP_1:32
.= ( ( R14 .: (( R13 [;] (R15 , R16) ) , ( R13 [;] (R15 , R17) )) ) . R10 ) by L198 , L207 , L202 , L231 , FUNCOP_1:22;
thus L247: thesis by L246;
end;
thus L248: thesis by L209 , L155 , L198 , L174 , L206 , L202 , FUNCT_1:2 , RELAT_1:27;
end;
definition
let C63 being non  empty set;
let C64 being Nat;
let C65 being (BinOp of C63);
let C66 being (Element of C63);
let C67 being (Element of ( C64 -tuples_on C63 ));
redefine func C65 [;] (C66 , C67) -> (Element of ( C64 -tuples_on C63 ));

coherence by FINSEQ_2:121;
end;
registration
let R4 being Field;
let R5 being Nat;
cluster ( R5 -VectSp_over R4 ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
L250: (( the addLoopStr of ( R5 -VectSp_over R4 ) ) = ( R5 -Group_over R4 ) & ( R5 -Group_over R4 ) = addLoopStr (# ( R5 -tuples_on (the carrier of R4) ) , ( product ((the addF of R4) , R5) ) , (( R5 |-> ( 0. R4 ) ) qua (Element of ( R5 -tuples_on (the carrier of R4) ))) #)) by L111 , L147;
L251: ( 1_ R4 ) is_a_unity_wrt (the multF of R4) by L42;
L252: ((the multF of R4) is  having_a_unity & ( the_unity_wrt (the multF of R4) ) = ( 1_ R4 )) by L251 , BINOP_1:def 8 , SETWISEO:def 2;
L253: ( R5 -VectSp_over R4 ) is  vector-distributive
proof
let C68 being (Element of R4);
let C69 , C70 being (Element of ( R5 -VectSp_over R4 ));
reconsider D24 = C69 , D25 = C70 as (Element of ( R5 -tuples_on (the carrier of R4) )) by L250;
thus L254: ( C68 * ( C69 + C70 ) ) = ( ( R5 -Mult_over R4 ) . (C68 , ( ( product ((the addF of R4) , R5) ) . (C69 , C70) )) ) by L250 , L147
.= ( ( R5 -Mult_over R4 ) . (C68 , ( (the addF of R4) .: (D24 , D25) )) ) by L53
.= ( (the multF of R4) [;] (C68 , ( (the addF of R4) .: (D24 , D25) )) ) by L125
.= ( (the addF of R4) .: (( (the multF of R4) [;] (C68 , D24) ) , ( (the multF of R4) [;] (C68 , D25) )) ) by L47 , L154
.= ( ( product ((the addF of R4) , R5) ) . (( (the multF of R4) [;] (C68 , D24) ) , ( (the multF of R4) [;] (C68 , D25) )) ) by L53
.= ( ( product ((the addF of R4) , R5) ) . (( ( R5 -Mult_over R4 ) . (C68 , D24) ) , ( (the multF of R4) [;] (C68 , D25) )) ) by L125
.= ( ( product ((the addF of R4) , R5) ) . (( ( R5 -Mult_over R4 ) . (C68 , D24) ) , ( ( R5 -Mult_over R4 ) . (C68 , D25) )) ) by L125
.= ( ( product ((the addF of R4) , R5) ) . (( (the lmult of ( R5 -VectSp_over R4 )) . (C68 , C69) ) , ( ( R5 -Mult_over R4 ) . (C68 , D25) )) ) by L147
.= ( ( C68 * C69 ) + ( C68 * C70 ) ) by L250 , L147;
end;
L255: ( R5 -VectSp_over R4 ) is  scalar-distributive
proof
let C71 , C72 being (Element of R4);
let C73 being (Element of ( R5 -VectSp_over R4 ));
reconsider D26 = C73 as (Element of ( R5 -tuples_on (the carrier of R4) )) by L250;
thus L256: ( ( C71 + C72 ) * C73 ) = ( ( R5 -Mult_over R4 ) . (( C71 + C72 ) , D26) ) by L147
.= ( (the multF of R4) [;] (( (the addF of R4) . (C71 , C72) ) , D26) ) by L125
.= ( (the addF of R4) .: (( (the multF of R4) [;] (C71 , D26) ) , ( (the multF of R4) [;] (C72 , D26) )) ) by L47 , FINSEQOP:46
.= ( ( product ((the addF of R4) , R5) ) . (( (the multF of R4) [;] (C71 , D26) ) , ( (the multF of R4) [;] (C72 , D26) )) ) by L53
.= ( ( product ((the addF of R4) , R5) ) . (( ( R5 -Mult_over R4 ) . (C71 , D26) ) , ( (the multF of R4) [;] (C72 , D26) )) ) by L125
.= ( ( product ((the addF of R4) , R5) ) . (( ( R5 -Mult_over R4 ) . (C71 , D26) ) , ( ( R5 -Mult_over R4 ) . (C72 , D26) )) ) by L125
.= ( ( product ((the addF of R4) , R5) ) . (( (the lmult of ( R5 -VectSp_over R4 )) . (C71 , C73) ) , ( ( R5 -Mult_over R4 ) . (C72 , D26) )) ) by L147
.= ( ( C71 * C73 ) + ( C72 * C73 ) ) by L250 , L147;
end;
L257: ( R5 -VectSp_over R4 ) is  scalar-associative
proof
let C74 , C75 being (Element of R4);
let C76 being (Element of ( R5 -VectSp_over R4 ));
reconsider D27 = C76 as (Element of ( R5 -tuples_on (the carrier of R4) )) by L250;
thus L258: ( ( C74 * C75 ) * C76 ) = ( ( R5 -Mult_over R4 ) . (( C74 * C75 ) , D27) ) by L147
.= ( (the multF of R4) [;] (( C74 * C75 ) , D27) ) by L125
.= ( (the multF of R4) [;] (C74 , ( (the multF of R4) [;] (C75 , D27) )) ) by L35 , FINSEQOP:31
.= ( ( R5 -Mult_over R4 ) . (C74 , ( (the multF of R4) [;] (C75 , D27) )) ) by L125
.= ( ( R5 -Mult_over R4 ) . (C74 , ( ( R5 -Mult_over R4 ) . (C75 , D27) )) ) by L125
.= ( ( R5 -Mult_over R4 ) . (C74 , ( (the lmult of ( R5 -VectSp_over R4 )) . (C75 , C76) )) ) by L147
.= ( C74 * ( C75 * C76 ) ) by L147;
end;
L259: ( R5 -VectSp_over R4 ) is  scalar-unital
proof
let C77 being (Element of ( R5 -VectSp_over R4 ));
reconsider D28 = C77 as (Element of ( R5 -tuples_on (the carrier of R4) )) by L250;
thus L260: ( ( 1. R4 ) * C77 ) = ( ( R5 -Mult_over R4 ) . (( 1. R4 ) , D28) ) by L147
.= ( (the multF of R4) [;] (( 1. R4 ) , D28) ) by L125
.= C77 by L252 , FINSEQOP:57;
end;
thus L261: thesis by L259 , L253 , L255 , L257;
end;
end;
begin
definition
mode Domain-Sequence
 is non  empty  non-empty FinSequence;
end;
scheme NEFinSeqLambda { F1() -> non  empty FinSequence , F2(set) -> set } : (ex B36 being non  empty FinSequence st (( len B36 ) = ( len F1() ) & (for B37 being (Element of ( dom F1() )) holds ( B36 . B37 ) = F2(B37))))
proof
consider C78 being FinSequence such that L264: (( len C78 ) = ( len F1() ) & (for B38 being Nat holds (B38 in ( dom C78 ) implies ( C78 . B38 ) = F2(B38)))) from FINSEQ_1:sch 2;
L265: ( dom C78 ) = ( dom F1() ) by L264 , FINSEQ_3:29;
reconsider D29 = C78 as non  empty FinSequence by L265;
take D29;
thus L266: ( len D29 ) = ( len F1() ) by L264;
let C79 being (Element of ( dom F1() ));
L267: ( dom F1() ) = ( Seg ( len F1() ) ) by FINSEQ_1:def 3;
L268: ( dom C78 ) = ( Seg ( len F1() ) ) by L264 , FINSEQ_1:def 3;
thus L269: thesis by L268 , L264 , L267;
end;
definition
let C80 being  non-empty non  empty Function;
let C81 being (Element of ( product C80 ));
let C82 being (Element of ( dom C80 ));
redefine func C81 . C82 -> (Element of ( C80 . C82 ));

coherence by CARD_3:9;
end;
begin
definition
let C83 being  non-empty non  empty Function;
mode BinOps of C83
 -> Function
means :L271: (( dom it ) = ( dom C83 ) & (for B39 being (Element of ( dom C83 )) holds ( it . B39 ) is (BinOp of ( C83 . B39 ))));
existence
proof
deffunc H5(set) = ( pr1 (( C83 . $1 ) , ( C83 . $1 )) );
consider C84 being Function such that L272: (( dom C84 ) = ( dom C83 ) & (for R18 being set holds (R18 in ( dom C83 ) implies ( C84 . R18 ) = H5(R18)))) from FUNCT_1:sch 3;
take C84;
thus L273: ( dom C84 ) = ( dom C83 ) by L272;
let C85 being (Element of ( dom C83 ));
L274: ( C84 . C85 ) = ( pr1 (( C83 . C85 ) , ( C83 . C85 )) ) by L272;
thus L275: thesis by L274;
end;
mode UnOps of C83
 -> Function
means :L276: (( dom it ) = ( dom C83 ) & (for B40 being (Element of ( dom C83 )) holds ( it . B40 ) is (UnOp of ( C83 . B40 ))));
existence
proof
deffunc H6(set) = ( id ( C83 . $1 ) );
consider C86 being Function such that L277: (( dom C86 ) = ( dom C83 ) & (for R18 being set holds (R18 in ( dom C83 ) implies ( C86 . R18 ) = H6(R18)))) from FUNCT_1:sch 3;
take C86;
thus L278: ( dom C86 ) = ( dom C83 ) by L277;
let C87 being (Element of ( dom C83 ));
L279: ( C86 . C87 ) = ( id ( C83 . C87 ) ) by L277;
thus L280: thesis by L279;
end;
end;
registration
let R22 being Domain-Sequence;
cluster  ->  FinSequence-like for (BinOps of R22);
coherence
proof
let C88 being (BinOps of R22);
L282: (( dom R22 ) = ( dom C88 ) & ( dom R22 ) = ( Seg ( len R22 ) )) by L271 , FINSEQ_1:def 3;
thus L283: thesis by L282 , FINSEQ_1:def 2;
end;
cluster  ->  FinSequence-like for (UnOps of R22);
coherence
proof
let C89 being (UnOps of R22);
L284: (( dom R22 ) = ( dom C89 ) & ( dom R22 ) = ( Seg ( len R22 ) )) by L276 , FINSEQ_1:def 3;
thus L285: thesis by L284 , FINSEQ_1:def 2;
end;
end;
theorem
L287: (for R22 being Domain-Sequence holds (for R24 being FinSequence holds (R24 is (BinOps of R22) iff (( len R24 ) = ( len R22 ) & (for R23 being (Element of ( dom R22 )) holds ( R24 . R23 ) is (BinOp of ( R22 . R23 )))))))
proof
let R22 being Domain-Sequence;
let R24 being FinSequence;
L288: (( dom R24 ) = ( dom R22 ) iff ( len R24 ) = ( len R22 )) by FINSEQ_3:29;
thus L289: thesis by L288 , L271;
end;
theorem
L290: (for R22 being Domain-Sequence holds (for R24 being FinSequence holds (R24 is (UnOps of R22) iff (( len R24 ) = ( len R22 ) & (for R23 being (Element of ( dom R22 )) holds ( R24 . R23 ) is (UnOp of ( R22 . R23 )))))))
proof
let R22 being Domain-Sequence;
let R24 being FinSequence;
L291: (( dom R24 ) = ( dom R22 ) iff ( len R24 ) = ( len R22 )) by FINSEQ_3:29;
thus L292: thesis by L291 , L276;
end;
definition
let R22 being Domain-Sequence;
let C90 being (BinOps of R22);
let R23 being (Element of ( dom R22 ));
redefine func C90 . R23 -> (BinOp of ( R22 . R23 ));

coherence by L287;
end;
definition
let R22 being Domain-Sequence;
let C91 being (UnOps of R22);
let R23 being (Element of ( dom R22 ));
redefine func C91 . R23 -> (UnOp of ( R22 . R23 ));

coherence by L290;
end;
theorem
L295: (for R22 being Domain-Sequence holds (for B41 , B42 being (UnOp of ( product R22 )) holds ((for B43 being (Element of ( product R22 )) holds (for B44 being (Element of ( dom R22 )) holds ( ( B41 . B43 ) . B44 ) = ( ( B42 . B43 ) . B44 ))) implies B41 = B42)))
proof
let R22 being Domain-Sequence;
let C92 , C93 being (UnOp of ( product R22 ));
assume that
L296: (for B45 being (Element of ( product R22 )) holds (for B46 being (Element of ( dom R22 )) holds ( ( C92 . B45 ) . B46 ) = ( ( C93 . B45 ) . B46 )));
L297:
now
let C94 being (Element of ( product R22 ));
L298: (( dom ( C92 . C94 ) ) = ( dom R22 ) & ( dom ( C93 . C94 ) ) = ( dom R22 )) by CARD_3:9;
L299: (for R18 being set holds (R18 in ( dom R22 ) implies ( ( C92 . C94 ) . R18 ) = ( ( C93 . C94 ) . R18 ))) by L296;
thus L300: ( C92 . C94 ) = ( C93 . C94 ) by L299 , L298 , FUNCT_1:2;
end;
thus L301: thesis by L297 , FUNCT_2:63;
end;
theorem
L302: (for R22 being Domain-Sequence holds (for B47 being (UnOps of R22) holds (( doms B47 ) = R22 & ( product ( rngs B47 ) ) c= ( product R22 ))))
proof
let R22 being Domain-Sequence;
let C95 being (UnOps of R22);
L303: ( dom ( doms C95 ) ) = ( C95 " ( SubFuncs ( rng C95 ) ) ) by FUNCT_6:def 2;
L304: (( dom R22 ) = ( Seg ( len R22 ) ) & ( dom C95 ) = ( Seg ( len C95 ) )) by FINSEQ_1:def 3;
L305: ( len C95 ) = ( len R22 ) by L290;
L306: ( dom C95 ) c= ( C95 " ( SubFuncs ( rng C95 ) ) )
proof
let R18 being set;
assume L307: R18 in ( dom C95 );
reconsider D30 = R18 as (Element of ( dom R22 )) by L307 , L304 , L290;
L308: ( C95 . D30 ) is (UnOp of ( R22 . D30 ));
thus L309: thesis by L308 , L304 , L305 , FUNCT_6:19;
end;
L310: ( C95 " ( SubFuncs ( rng C95 ) ) ) c= ( dom C95 ) by RELAT_1:132;
L311: ( dom ( doms C95 ) ) = ( dom C95 ) by L310 , L303 , L306 , XBOOLE_0:def 10;
L312:
now
let R18 being set;
assume L313: R18 in ( dom C95 );
reconsider D31 = R18 as (Element of ( dom R22 )) by L313 , L304 , L290;
L314: ( ( rngs C95 ) . D31 ) = ( rng ( C95 . D31 ) ) by L304 , L305 , FUNCT_6:22;
thus L315: ( ( rngs C95 ) . R18 ) c= ( R22 . R18 ) by L314 , RELAT_1:def 19;
end;
L316:
now
let R18 being set;
assume L317: R18 in ( dom C95 );
reconsider D32 = R18 as (Element of ( dom R22 )) by L317 , L304 , L290;
L318: ( ( doms C95 ) . D32 ) = ( dom ( C95 . D32 ) ) by L304 , L305 , FUNCT_6:22
.= ( R22 . D32 ) by FUNCT_2:def 1;
thus L319: ( ( doms C95 ) . R18 ) = ( R22 . R18 ) by L318;
end;
thus L320: ( doms C95 ) = R22 by L316 , L304 , L305 , L311 , FUNCT_1:2;
L321: ( dom ( rngs C95 ) ) = ( C95 " ( SubFuncs ( rng C95 ) ) ) by FUNCT_6:def 3;
thus L322: thesis by L321 , L303 , L304 , L305 , L311 , L312 , CARD_3:27;
end;
definition
let R22 being Domain-Sequence;
let C96 being (UnOps of R22);
redefine func Frege C96 -> (UnOp of ( product R22 ));

coherence
proof
L323: (( product ( rngs C96 ) ) c= ( product R22 ) & ( rng ( Frege C96 ) ) = ( product ( rngs C96 ) )) by L302 , FUNCT_6:38;
L324: (( dom ( Frege C96 ) ) = ( product ( doms C96 ) ) & ( doms C96 ) = R22) by L302 , FUNCT_6:def 7;
thus L325: thesis by L324 , L323 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
theorem
L327: (for R22 being Domain-Sequence holds (for B48 being (UnOps of R22) holds (for B49 being (Element of ( product R22 )) holds (for B50 being (Element of ( dom R22 )) holds ( ( ( Frege B48 ) . B49 ) . B50 ) = ( ( B48 . B50 ) . ( B49 . B50 ) )))))
proof
let R22 being Domain-Sequence;
let C97 being (UnOps of R22);
let C98 being (Element of ( product R22 ));
let C99 being (Element of ( dom R22 ));
L328: (( dom C97 ) = ( Seg ( len C97 ) ) & ( doms C97 ) = R22) by L302 , FINSEQ_1:def 3;
L329: (( dom R22 ) = ( Seg ( len R22 ) ) & ( len R22 ) = ( len C97 )) by L290 , FINSEQ_1:def 3;
thus L330: thesis by L329 , L328 , FUNCT_6:37;
end;
definition
let C100 being  functional non  empty set;
let C101 being (BinOp of C100);
let C102 , C103 being (Element of C100);
redefine func C101 . (C102 , C103) -> (Element of C100);

coherence
proof
L331: ( C101 . (C102 , C103) ) is (Element of C100);
thus L332: thesis by L331;
end;
end;
theorem
L334: (for R22 being Domain-Sequence holds (for B51 , B52 being (BinOp of ( product R22 )) holds ((for B53 , B54 being (Element of ( product R22 )) holds (for B55 being (Element of ( dom R22 )) holds ( ( B51 . (B53 , B54) ) . B55 ) = ( ( B52 . (B53 , B54) ) . B55 ))) implies B51 = B52)))
proof
let R22 being Domain-Sequence;
let C104 , C105 being (BinOp of ( product R22 ));
assume that
L335: (for B56 , B57 being (Element of ( product R22 )) holds (for B58 being (Element of ( dom R22 )) holds ( ( C104 . (B56 , B57) ) . B58 ) = ( ( C105 . (B56 , B57) ) . B58 )));
L336:
now
let C106 , C107 being (Element of ( product R22 ));
L337: (( dom ( C104 . (C106 , C107) ) ) = ( dom R22 ) & ( dom ( C105 . (C106 , C107) ) ) = ( dom R22 )) by CARD_3:9;
L338: (for R18 being set holds (R18 in ( dom R22 ) implies ( ( C104 . (C106 , C107) ) . R18 ) = ( ( C105 . (C106 , C107) ) . R18 ))) by L335;
thus L339: ( C104 . (C106 , C107) ) = ( C105 . (C106 , C107) ) by L338 , L337 , FUNCT_1:2;
end;
thus L340: thesis by L336 , BINOP_1:2;
end;
definition
let R22 being Domain-Sequence;
let C108 being (BinOps of R22);
func [:C108 :] -> (BinOp of ( product R22 )) means 
:L341: (for B59 , B60 being (Element of ( product R22 )) holds (for B61 being (Element of ( dom R22 )) holds ( ( it . (B59 , B60) ) . B61 ) = ( ( C108 . B61 ) . (( B59 . B61 ) , ( B60 . B61 )) )));
existence
proof
defpred S4[ (Element of ( product R22 )) , (Element of ( product R22 )) , (Element of ( product R22 )) ] means (for B62 being (Element of ( dom R22 )) holds ( $3 . B62 ) = ( ( C108 . B62 ) . (( $1 . B62 ) , ( $2 . B62 )) ));
L342: (for B63 , B64 being (Element of ( product R22 )) holds (ex B65 being (Element of ( product R22 )) st S4[ B63 , B64 , B65 ]))
proof
let C109 , C110 being (Element of ( product R22 ));
defpred S5[ set , set ] means (ex R25 being (Element of ( dom R22 )) st ($1 = R25 & $2 = ( ( C108 . R25 ) . (( C109 . R25 ) , ( C110 . R25 )) )));
L343: (for R18 being set holds (R18 in ( dom R22 ) implies (ex R20 being set st S5[ R18 , R20 ])))
proof
let R18 being set;
assume L344: R18 in ( dom R22 );
reconsider D33 = R18 as (Element of ( dom R22 )) by L344;
take ( ( C108 . D33 ) . (( C109 . D33 ) , ( C110 . D33 )) );
thus L345: thesis;
end;
consider C111 being Function such that L346: (( dom C111 ) = ( dom R22 ) & (for B66 being set holds (B66 in ( dom R22 ) implies S5[ B66 , ( C111 . B66 ) ]))) from CLASSES1:sch 1(L343);
L347:
now
let R18 being set;
assume L348: R18 in ( dom R22 );
L349: (ex R25 being (Element of ( dom R22 )) st (R18 = R25 & ( C111 . R18 ) = ( ( C108 . R25 ) . (( C109 . R25 ) , ( C110 . R25 )) ))) by L348 , L346;
thus L350: ( C111 . R18 ) in ( R22 . R18 ) by L349;
end;
reconsider D34 = C111 as (Element of ( product R22 )) by L347 , L346 , CARD_3:9;
take D34;
let R25 being (Element of ( dom R22 ));
L351: (ex B67 being (Element of ( dom R22 )) st (B67 = R25 & ( C111 . R25 ) = ( ( C108 . B67 ) . (( C109 . B67 ) , ( C110 . B67 )) ))) by L346;
thus L352: thesis by L351;
end;
consider C112 being (BinOp of ( product R22 )) such that L353: (for B68 , B69 being (Element of ( product R22 )) holds S4[ B68 , B69 , ( C112 . (B68 , B69) ) ]) from BINOP_1:sch 3(L342);
take C112;
thus L354: thesis by L353;
end;
uniqueness
proof
let C113 , C114 being (BinOp of ( product R22 ));
assume that
L355: (for B70 , B71 being (Element of ( product R22 )) holds (for B72 being (Element of ( dom R22 )) holds ( ( C113 . (B70 , B71) ) . B72 ) = ( ( C108 . B72 ) . (( B70 . B72 ) , ( B71 . B72 )) )))
and
L356: (for B73 , B74 being (Element of ( product R22 )) holds (for B75 being (Element of ( dom R22 )) holds ( ( C114 . (B73 , B74) ) . B75 ) = ( ( C108 . B75 ) . (( B73 . B75 ) , ( B74 . B75 )) )));
L357:
now
let C115 , C116 being (Element of ( product R22 ));
let C117 being (Element of ( dom R22 ));
thus L358: ( ( C113 . (C115 , C116) ) . C117 ) = ( ( C108 . C117 ) . (( C115 . C117 ) , ( C116 . C117 )) ) by L355
.= ( ( C114 . (C115 , C116) ) . C117 ) by L356;
end;
thus L359: thesis by L357 , L334;
end;
end;
theorem
L361: (for R22 being Domain-Sequence holds (for B76 being (BinOps of R22) holds ((for R25 being (Element of ( dom R22 )) holds ( B76 . R25 ) is  commutative) implies [: B76 :] is  commutative)))
proof
let R22 being Domain-Sequence;
let C118 being (BinOps of R22);
assume that
L362: (for R25 being (Element of ( dom R22 )) holds ( C118 . R25 ) is  commutative);
let C119 , C120 being (Element of ( product R22 ));
L363:
now
let R20 being set;
assume L364: R20 in ( dom R22 );
reconsider D35 = R20 as (Element of ( dom R22 )) by L364;
L365: ( ( [: C118 :] . (C120 , C119) ) . D35 ) = ( ( C118 . D35 ) . (( C120 . D35 ) , ( C119 . D35 )) ) by L341;
L366: (( C118 . D35 ) is  commutative & ( ( [: C118 :] . (C119 , C120) ) . D35 ) = ( ( C118 . D35 ) . (( C119 . D35 ) , ( C120 . D35 )) )) by L362 , L341;
thus L367: ( ( [: C118 :] . (C119 , C120) ) . R20 ) = ( ( [: C118 :] . (C120 , C119) ) . R20 ) by L366 , L365 , BINOP_1:def 2;
end;
L368: (( dom ( [: C118 :] . (C119 , C120) ) ) = ( dom R22 ) & ( dom ( [: C118 :] . (C120 , C119) ) ) = ( dom R22 )) by CARD_3:9;
thus L369: thesis by L368 , L363 , FUNCT_1:2;
end;
theorem
L370: (for R22 being Domain-Sequence holds (for B77 being (BinOps of R22) holds ((for R25 being (Element of ( dom R22 )) holds ( B77 . R25 ) is  associative) implies [: B77 :] is  associative)))
proof
let R22 being Domain-Sequence;
let C121 being (BinOps of R22);
assume that
L371: (for R25 being (Element of ( dom R22 )) holds ( C121 . R25 ) is  associative);
let C122 , C123 , C124 being (Element of ( product R22 ));
L372:
now
set D36 = ( [: C121 :] . (C122 , C123) );
set D37 = ( [: C121 :] . (C123 , C124) );
let C125 being set;
assume L373: C125 in ( dom R22 );
reconsider D38 = C125 as (Element of ( dom R22 )) by L373;
L374: (( ( [: C121 :] . (C123 , C124) ) . D38 ) = ( ( C121 . D38 ) . (( C123 . D38 ) , ( C124 . D38 )) ) & ( ( [: C121 :] . (C122 , D37) ) . D38 ) = ( ( C121 . D38 ) . (( C122 . D38 ) , ( D37 . D38 )) )) by L341;
L375: ( ( [: C121 :] . (D36 , C124) ) . D38 ) = ( ( C121 . D38 ) . (( D36 . D38 ) , ( C124 . D38 )) ) by L341;
L376: (( C121 . D38 ) is  associative & ( ( [: C121 :] . (C122 , C123) ) . D38 ) = ( ( C121 . D38 ) . (( C122 . D38 ) , ( C123 . D38 )) )) by L371 , L341;
thus L377: ( ( [: C121 :] . (C122 , ( [: C121 :] . (C123 , C124) )) ) . C125 ) = ( ( [: C121 :] . (( [: C121 :] . (C122 , C123) ) , C124) ) . C125 ) by L376 , L374 , L375 , BINOP_1:def 3;
end;
L378: (( dom ( [: C121 :] . (C122 , ( [: C121 :] . (C123 , C124) )) ) ) = ( dom R22 ) & ( dom ( [: C121 :] . (( [: C121 :] . (C122 , C123) ) , C124) ) ) = ( dom R22 )) by CARD_3:9;
thus L379: thesis by L378 , L372 , FUNCT_1:2;
end;
theorem
L380: (for R22 being Domain-Sequence holds (for B78 being (BinOps of R22) holds (for B79 being (Element of ( product R22 )) holds ((for R25 being (Element of ( dom R22 )) holds ( B79 . R25 ) is_a_unity_wrt ( B78 . R25 )) implies B79 is_a_unity_wrt [: B78 :]))))
proof
let R22 being Domain-Sequence;
let C126 being (BinOps of R22);
let C127 being (Element of ( product R22 ));
assume that
L381: (for R25 being (Element of ( dom R22 )) holds ( C127 . R25 ) is_a_unity_wrt ( C126 . R25 ));
L382:
now
let C128 being (Element of ( product R22 ));
L383: ( dom C128 ) = ( dom R22 ) by CARD_3:9;
L384:
now
let R19 being set;
assume L385: R19 in ( dom R22 );
reconsider D39 = R19 as (Element of ( dom R22 )) by L385;
L386: (( ( [: C126 :] . (C127 , C128) ) . D39 ) = ( ( C126 . D39 ) . (( C127 . D39 ) , ( C128 . D39 )) ) & ( C127 . D39 ) is_a_unity_wrt ( C126 . D39 )) by L381 , L341;
thus L387: ( ( [: C126 :] . (C127 , C128) ) . R19 ) = ( C128 . R19 ) by L386 , BINOP_1:3;
end;
L388: ( dom ( [: C126 :] . (C127 , C128) ) ) = ( dom R22 ) by CARD_3:9;
thus L389: ( [: C126 :] . (C127 , C128) ) = C128 by L388 , L383 , L384 , FUNCT_1:2;
L390:
now
let R19 being set;
assume L391: R19 in ( dom R22 );
reconsider D40 = R19 as (Element of ( dom R22 )) by L391;
L392: (( ( [: C126 :] . (C128 , C127) ) . D40 ) = ( ( C126 . D40 ) . (( C128 . D40 ) , ( C127 . D40 )) ) & ( C127 . D40 ) is_a_unity_wrt ( C126 . D40 )) by L381 , L341;
thus L393: ( ( [: C126 :] . (C128 , C127) ) . R19 ) = ( C128 . R19 ) by L392 , BINOP_1:3;
end;
L394: ( dom ( [: C126 :] . (C128 , C127) ) ) = ( dom R22 ) by CARD_3:9;
thus L395: ( [: C126 :] . (C128 , C127) ) = C128 by L394 , L383 , L390 , FUNCT_1:2;
end;
thus L396: thesis by L382 , BINOP_1:3;
end;
theorem
L397: (for R22 being Domain-Sequence holds (for B80 being (BinOps of R22) holds (for B81 being (UnOps of R22) holds ((for R25 being (Element of ( dom R22 )) holds (( B81 . R25 ) is_an_inverseOp_wrt ( B80 . R25 ) & ( B80 . R25 ) is  having_a_unity)) implies ( Frege B81 ) is_an_inverseOp_wrt [: B80 :]))))
proof
let R22 being Domain-Sequence;
let C129 being (BinOps of R22);
let C130 being (UnOps of R22);
assume that
L398: (for R25 being (Element of ( dom R22 )) holds (( C130 . R25 ) is_an_inverseOp_wrt ( C129 . R25 ) & ( C129 . R25 ) is  having_a_unity));
defpred S6[ set , set ] means (ex R25 being (Element of ( dom R22 )) st ($1 = R25 & $2 = ( the_unity_wrt ( C129 . R25 ) )));
L399: (for R18 being set holds (R18 in ( dom R22 ) implies (ex R19 being set st S6[ R18 , R19 ])))
proof
let R18 being set;
assume L400: R18 in ( dom R22 );
reconsider D41 = R18 as (Element of ( dom R22 )) by L400;
take ( the_unity_wrt ( C129 . D41 ) );
thus L401: thesis;
end;
consider C131 being Function such that L402: (( dom C131 ) = ( dom R22 ) & (for R18 being set holds (R18 in ( dom R22 ) implies S6[ R18 , ( C131 . R18 ) ]))) from CLASSES1:sch 1(L399);
L403:
now
let R18 being set;
assume L404: R18 in ( dom R22 );
L405: (ex R25 being (Element of ( dom R22 )) st (R18 = R25 & ( C131 . R18 ) = ( the_unity_wrt ( C129 . R25 ) ))) by L404 , L402;
thus L406: ( C131 . R18 ) in ( R22 . R18 ) by L405;
end;
reconsider D42 = C131 as (Element of ( product R22 )) by L403 , L402 , CARD_3:9;
let C132 being (Element of ( product R22 ));
L407: ( dom D42 ) = ( dom R22 ) by CARD_3:9;
L408:
now
let R19 being set;
assume L409: R19 in ( dom R22 );
reconsider D43 = R19 as (Element of ( dom R22 )) by L409;
L410: (( ( ( Frege C130 ) . C132 ) . D43 ) = ( ( C130 . D43 ) . ( C132 . D43 ) ) & ( C130 . D43 ) is_an_inverseOp_wrt ( C129 . D43 )) by L398 , L327;
L411: ((ex B82 being (Element of ( dom R22 )) st (D43 = B82 & ( D42 . D43 ) = ( the_unity_wrt ( C129 . B82 ) ))) & ( ( [: C129 :] . (C132 , ( ( Frege C130 ) . C132 )) ) . D43 ) = ( ( C129 . D43 ) . (( C132 . D43 ) , ( ( ( Frege C130 ) . C132 ) . D43 )) )) by L402 , L341;
thus L412: ( ( [: C129 :] . (C132 , ( ( Frege C130 ) . C132 )) ) . R19 ) = ( D42 . R19 ) by L411 , L410 , FINSEQOP:def 1;
end;
L413:
now
let R25 being (Element of ( dom R22 ));
L414: ((ex B83 being (Element of ( dom R22 )) st (R25 = B83 & ( D42 . R25 ) = ( the_unity_wrt ( C129 . B83 ) ))) & ( C129 . R25 ) is  having_a_unity) by L398 , L402;
thus L415: ( D42 . R25 ) is_a_unity_wrt ( C129 . R25 ) by L414 , SETWISEO:14;
end;
L416: D42 is_a_unity_wrt [: C129 :] by L413 , L380;
L417: D42 = ( the_unity_wrt [: C129 :] ) by L416 , BINOP_1:def 8;
L418:
now
let R19 being set;
assume L419: R19 in ( dom R22 );
reconsider D44 = R19 as (Element of ( dom R22 )) by L419;
L420: (( ( ( Frege C130 ) . C132 ) . D44 ) = ( ( C130 . D44 ) . ( C132 . D44 ) ) & ( C130 . D44 ) is_an_inverseOp_wrt ( C129 . D44 )) by L398 , L327;
L421: ((ex B84 being (Element of ( dom R22 )) st (D44 = B84 & ( D42 . D44 ) = ( the_unity_wrt ( C129 . B84 ) ))) & ( ( [: C129 :] . (( ( Frege C130 ) . C132 ) , C132) ) . D44 ) = ( ( C129 . D44 ) . (( ( ( Frege C130 ) . C132 ) . D44 ) , ( C132 . D44 )) )) by L402 , L341;
thus L422: ( ( [: C129 :] . (( ( Frege C130 ) . C132 ) , C132) ) . R19 ) = ( D42 . R19 ) by L421 , L420 , FINSEQOP:def 1;
end;
L423: ( dom ( [: C129 :] . (C132 , ( ( Frege C130 ) . C132 )) ) ) = ( dom R22 ) by CARD_3:9;
thus L424: ( [: C129 :] . (C132 , ( ( Frege C130 ) . C132 )) ) = ( the_unity_wrt [: C129 :] ) by L423 , L417 , L407 , L408 , FUNCT_1:2;
L425: ( dom ( [: C129 :] . (( ( Frege C130 ) . C132 ) , C132) ) ) = ( dom R22 ) by CARD_3:9;
thus L426: ( [: C129 :] . (( ( Frege C130 ) . C132 ) , C132) ) = ( the_unity_wrt [: C129 :] ) by L425 , L417 , L407 , L418 , FUNCT_1:2;
end;
begin
definition
let C133 being Relation;
attr C133 is  AbGroup-yielding
means
:L427: (for R18 being set holds (R18 in ( rng C133 ) implies R18 is AbGroup));
end;
registration
cluster non  empty  AbGroup-yielding for FinSequence;
existence
proof
set D45 = the AbGroup;
take <* D45 *>;
thus L429: <* D45 *> is non  empty;
let R18 being set;
assume that
L430: R18 in ( rng <* D45 *> )
and
L431: (not R18 is AbGroup);
L432: R18 in { D45 } by L430 , FINSEQ_1:38;
thus L433: contradiction by L432 , L431 , TARSKI:def 1;
end;
end;
definition
mode Group-Sequence
 is non  empty  AbGroup-yielding FinSequence;
end;
definition
let C134 being Group-Sequence;
let C135 being (Element of ( dom C134 ));
redefine func C134 . C135 -> AbGroup;

coherence
proof
L436: ( C134 . C135 ) in ( rng C134 ) by FUNCT_1:def 3;
thus L437: thesis by L436 , L427;
end;
end;
definition
let C136 being Group-Sequence;
func carr C136 -> Domain-Sequence means 
:L439: (( len it ) = ( len C136 ) & (for B85 being (Element of ( dom C136 )) holds ( it . B85 ) = (the carrier of ( C136 . B85 ))));
existence
proof
defpred S7[ set , set ] means (ex B86 being (Element of ( dom C136 )) st (B86 = $1 & $2 = (the carrier of ( C136 . B86 ))));
L440: (for B87 being Nat holds (B87 in ( Seg ( len C136 ) ) implies (ex R18 being set st S7[ B87 , R18 ])))
proof
let C137 being Nat;
assume L441: C137 in ( Seg ( len C136 ) );
reconsider D46 = C137 as (Element of ( dom C136 )) by L441 , FINSEQ_1:def 3;
take (the carrier of ( C136 . D46 ));
thus L442: thesis;
end;
consider C138 being FinSequence such that L443: (( dom C138 ) = ( Seg ( len C136 ) ) & (for B88 being Nat holds (B88 in ( Seg ( len C136 ) ) implies S7[ B88 , ( C138 . B88 ) ]))) from FINSEQ_1:sch 1(L440);
L444: C138 is  non-empty
proof
assume L445: ( {} ) in ( rng C138 );
consider R18 being set such that L446: R18 in ( dom C138 ) and L447: ( {} ) = ( C138 . R18 ) by L445 , FUNCT_1:def 3;
reconsider D47 = R18 as (Element of ( NAT )) by L446;
L448: (ex B89 being (Element of ( dom C136 )) st (B89 = D47 & ( C138 . D47 ) = (the carrier of ( C136 . B89 )))) by L443 , L446;
thus L449: contradiction by L448 , L447;
end;
reconsider D48 = C138 as Domain-Sequence by L444 , L443;
take D48;
thus L450: ( len D48 ) = ( len C136 ) by L443 , FINSEQ_1:def 3;
let C139 being (Element of ( dom C136 ));
reconsider D49 = C139 as (Element of ( NAT ));
L451: ( dom C136 ) = ( Seg ( len C136 ) ) by FINSEQ_1:def 3;
L452: (ex B90 being (Element of ( dom C136 )) st (B90 = D49 & ( D48 . D49 ) = (the carrier of ( C136 . B90 )))) by L451 , L443;
thus L453: thesis by L452;
end;
uniqueness
proof
let C140 , C141 being Domain-Sequence;
assume that
L454: ( len C140 ) = ( len C136 )
and
L455: (for B91 being (Element of ( dom C136 )) holds ( C140 . B91 ) = (the carrier of ( C136 . B91 )))
and
L456: ( len C141 ) = ( len C136 )
and
L457: (for B92 being (Element of ( dom C136 )) holds ( C141 . B92 ) = (the carrier of ( C136 . B92 )));
reconsider D50 = C140 , D51 = C141 as FinSequence;
L458:
now
let C142 being Nat;
assume L459: C142 in ( dom D50 );
reconsider D52 = C142 as (Element of ( dom C136 )) by L459 , L454 , FINSEQ_3:29;
L460: ( D50 . C142 ) = (the carrier of ( C136 . D52 )) by L455;
thus L461: ( D50 . C142 ) = ( D51 . C142 ) by L460 , L457;
end;
L462: (( dom D50 ) = ( Seg ( len D50 ) ) & ( dom D51 ) = ( Seg ( len D51 ) )) by FINSEQ_1:def 3;
thus L463: thesis by L462 , L454 , L456 , L458 , FINSEQ_1:13;
end;
end;
definition
let R26 being Group-Sequence;
let R27 being (Element of ( dom ( carr R26 ) ));
redefine func R26 . R27 -> AbGroup;

coherence
proof
L465: (( dom R26 ) = ( Seg ( len R26 ) ) & ( Seg ( len ( carr R26 ) ) ) = ( dom ( carr R26 ) )) by FINSEQ_1:def 3;
reconsider D53 = R27 as (Element of ( dom R26 )) by L465 , L439;
L466: ( R26 . D53 ) is AbGroup;
thus L467: thesis by L466;
end;
end;
definition
let R26 being Group-Sequence;
func addop R26 -> (BinOps of ( carr R26 )) means 
:L469: (( len it ) = ( len ( carr R26 ) ) & (for R27 being (Element of ( dom ( carr R26 ) )) holds ( it . R27 ) = (the addF of ( R26 . R27 ))));
existence
proof
deffunc H7((Element of ( dom ( carr R26 ) ))) = (the addF of ( R26 . $1 ));
consider C143 being non  empty FinSequence such that L470: (( len C143 ) = ( len ( carr R26 ) ) & (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C143 . R27 ) = H7(R27))) from NEFinSeqLambda;
L471:
now
let R27 being (Element of ( dom ( carr R26 ) ));
L472: ( len R26 ) = ( len ( carr R26 ) ) by L439;
reconsider D54 = R27 as (Element of ( dom R26 )) by L472 , FINSEQ_3:29;
L473: (( C143 . R27 ) = (the addF of ( R26 . R27 )) & (the carrier of ( R26 . D54 )) = ( ( carr R26 ) . D54 )) by L470 , L439;
thus L474: ( C143 . R27 ) is (BinOp of ( ( carr R26 ) . R27 )) by L473;
end;
reconsider D55 = C143 as (BinOps of ( carr R26 )) by L471 , L470 , L287;
take D55;
thus L475: thesis by L470;
end;
uniqueness
proof
let C144 , C145 being (BinOps of ( carr R26 ));
assume that
L476: ( len C144 ) = ( len ( carr R26 ) )
and
L477: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C144 . R27 ) = (the addF of ( R26 . R27 )))
and
L478: ( len C145 ) = ( len ( carr R26 ) )
and
L479: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C145 . R27 ) = (the addF of ( R26 . R27 )));
reconsider D56 = C144 , D57 = C145 as FinSequence;
L480:
now
let C146 being Nat;
assume L481: C146 in ( dom D56 );
reconsider D58 = C146 as (Element of ( dom ( carr R26 ) )) by L481 , L476 , FINSEQ_3:29;
L482: ( D56 . C146 ) = (the addF of ( R26 . D58 )) by L477;
thus L483: ( D56 . C146 ) = ( D57 . C146 ) by L482 , L479;
end;
L484: (( dom D56 ) = ( Seg ( len D56 ) ) & ( dom D57 ) = ( Seg ( len D57 ) )) by FINSEQ_1:def 3;
thus L485: thesis by L484 , L476 , L478 , L480 , FINSEQ_1:13;
end;
func complop R26 -> (UnOps of ( carr R26 )) means 
:L486: (( len it ) = ( len ( carr R26 ) ) & (for R27 being (Element of ( dom ( carr R26 ) )) holds ( it . R27 ) = ( comp ( R26 . R27 ) )));
existence
proof
deffunc H8((Element of ( dom ( carr R26 ) ))) = ( comp ( R26 . $1 ) );
consider C147 being non  empty FinSequence such that L487: (( len C147 ) = ( len ( carr R26 ) ) & (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C147 . R27 ) = H8(R27))) from NEFinSeqLambda;
L488:
now
let R27 being (Element of ( dom ( carr R26 ) ));
L489: ( len R26 ) = ( len ( carr R26 ) ) by L439;
reconsider D59 = R27 as (Element of ( dom R26 )) by L489 , FINSEQ_3:29;
L490: (( C147 . R27 ) = ( comp ( R26 . R27 ) ) & (the carrier of ( R26 . D59 )) = ( ( carr R26 ) . D59 )) by L487 , L439;
thus L491: ( C147 . R27 ) is (UnOp of ( ( carr R26 ) . R27 )) by L490;
end;
reconsider D60 = C147 as (UnOps of ( carr R26 )) by L488 , L487 , L290;
take D60;
thus L492: thesis by L487;
end;
uniqueness
proof
let C148 , C149 being (UnOps of ( carr R26 ));
assume that
L493: ( len C148 ) = ( len ( carr R26 ) )
and
L494: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C148 . R27 ) = ( comp ( R26 . R27 ) ))
and
L495: ( len C149 ) = ( len ( carr R26 ) )
and
L496: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C149 . R27 ) = ( comp ( R26 . R27 ) ));
reconsider D61 = C148 , D62 = C149 as FinSequence;
L497:
now
let C150 being Nat;
assume L498: C150 in ( dom D61 );
reconsider D63 = C150 as (Element of ( dom ( carr R26 ) )) by L498 , L493 , FINSEQ_3:29;
L499: ( C148 . C150 ) = ( comp ( R26 . D63 ) ) by L494;
thus L500: ( C148 . C150 ) = ( C149 . C150 ) by L499 , L496;
end;
L501: (( dom D61 ) = ( Seg ( len D61 ) ) & ( dom D62 ) = ( Seg ( len D62 ) )) by FINSEQ_1:def 3;
thus L502: thesis by L501 , L493 , L495 , L497 , FINSEQ_1:13;
end;
func zeros R26 -> (Element of ( product ( carr R26 ) )) means 
:L503: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( it . R27 ) = ( 0. ( R26 . R27 ) ));
existence
proof
deffunc H9((Element of ( dom ( carr R26 ) ))) = ( 0. ( R26 . $1 ) );
L504: ( dom ( carr R26 ) ) = ( Seg ( len ( carr R26 ) ) ) by FINSEQ_1:def 3;
consider C151 being non  empty FinSequence such that L505: (( len C151 ) = ( len ( carr R26 ) ) & (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C151 . R27 ) = H9(R27))) from NEFinSeqLambda;
L506: ( dom R26 ) = ( Seg ( len R26 ) ) by FINSEQ_1:def 3;
L507:
now
let C152 being set;
assume L508: C152 in ( dom ( carr R26 ) );
reconsider D64 = C152 as (Element of ( dom ( carr R26 ) )) by L508;
reconsider D65 = D64 as (Element of ( dom R26 )) by L506 , L504 , L439;
L509: (( C151 . D64 ) = ( 0. ( R26 . D64 ) ) & ( ( carr R26 ) . D65 ) = (the carrier of ( R26 . D65 ))) by L505 , L439;
thus L510: ( C151 . C152 ) in ( ( carr R26 ) . C152 ) by L509;
end;
L511: ( dom C151 ) = ( Seg ( len C151 ) ) by FINSEQ_1:def 3;
reconsider D66 = C151 as (Element of ( product ( carr R26 ) )) by L511 , L505 , L504 , L507 , CARD_3:9;
take D66;
thus L512: thesis by L505;
end;
uniqueness
proof
let C153 , C154 being (Element of ( product ( carr R26 ) ));
assume that
L513: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C153 . R27 ) = ( 0. ( R26 . R27 ) ))
and
L514: (for R27 being (Element of ( dom ( carr R26 ) )) holds ( C154 . R27 ) = ( 0. ( R26 . R27 ) ));
reconsider D67 = C153 , D68 = C154 as Function;
L515:
now
let R18 being set;
assume L516: R18 in ( dom ( carr R26 ) );
reconsider D69 = R18 as (Element of ( dom ( carr R26 ) )) by L516;
thus L517: ( D67 . R18 ) = ( 0. ( R26 . D69 ) ) by L513
.= ( D68 . R18 ) by L514;
end;
L518: (( dom D67 ) = ( dom ( carr R26 ) ) & ( dom D68 ) = ( dom ( carr R26 ) )) by CARD_3:9;
thus L519: thesis by L518 , L515 , FUNCT_1:2;
end;
end;
definition
let C155 being Group-Sequence;
func product C155 ->  strict AbGroup equals 
addLoopStr (# ( product ( carr C155 ) ) , [: ( addop C155 ) :] , ( zeros C155 ) #);
coherence
proof
reconsider D70 = addLoopStr (# ( product ( carr C155 ) ) , [: ( addop C155 ) :] , ( zeros C155 ) #) as non  empty addLoopStr;
L521:
now
let C156 being (Element of ( dom ( carr C155 ) ));
L522: ( dom C155 ) = ( Seg ( len C155 ) ) by FINSEQ_1:def 3
.= ( Seg ( len ( carr C155 ) ) ) by L439
.= ( dom ( carr C155 ) ) by FINSEQ_1:def 3;
thus L523: ( ( carr C155 ) . C156 ) = H1(( C155 . C156 )) by L522 , L439;
end;
L524:
now
let C157 being (Element of ( dom ( carr C155 ) ));
L525: (( ( addop C155 ) . C157 ) = H2(( C155 . C157 )) & ( ( carr C155 ) . C157 ) = H1(( C155 . C157 ))) by L521 , L469;
thus L526: ( ( addop C155 ) . C157 ) is  associative by L525 , FVSUM_1:2;
end;
L527: [: ( addop C155 ) :] is  associative by L524 , L370;
L528:
now
let C158 being (Element of ( dom ( carr C155 ) ));
L529: ( ( carr C155 ) . C158 ) = H1(( C155 . C158 )) by L521;
L530: (( ( addop C155 ) . C158 ) = H2(( C155 . C158 )) & ( ( zeros C155 ) . C158 ) = H4(( C155 . C158 ))) by L469 , L503;
thus L531: ( ( zeros C155 ) . C158 ) is_a_unity_wrt ( ( addop C155 ) . C158 ) by L530 , L529 , L1;
end;
L532: ( zeros C155 ) is_a_unity_wrt [: ( addop C155 ) :] by L528 , L380;
L533: D70 is  right_complementable
proof
let C159 being (Element of D70);
reconsider D71 = ( ( Frege ( complop C155 ) ) . C159 ) as (Element of D70) by FUNCT_2:5;
take D71;
L534:
now
let C160 being (Element of ( dom ( carr C155 ) ));
L535: (( ( addop C155 ) . C160 ) = H2(( C155 . C160 )) & ( ( complop C155 ) . C160 ) = H3(( C155 . C160 ))) by L469 , L486;
L536: (H4(( C155 . C160 )) is_a_unity_wrt H2(( C155 . C160 )) & ( ( carr C155 ) . C160 ) = H1(( C155 . C160 ))) by L521 , L1;
thus L537: (( ( complop C155 ) . C160 ) is_an_inverseOp_wrt ( ( addop C155 ) . C160 ) & ( ( addop C155 ) . C160 ) is  having_a_unity) by L536 , L535 , L6 , SETWISEO:def 2;
end;
L538: ( Frege ( complop C155 ) ) is_an_inverseOp_wrt [: ( addop C155 ) :] by L534 , L397;
L539: ( C159 + D71 ) = ( the_unity_wrt [: ( addop C155 ) :] ) by L538 , FINSEQOP:def 1;
thus L540: thesis by L539 , L532 , BINOP_1:def 8;
end;
L541:
now
let C161 being (Element of ( dom ( carr C155 ) ));
L542: (( ( addop C155 ) . C161 ) = H2(( C155 . C161 )) & ( ( carr C155 ) . C161 ) = H1(( C155 . C161 ))) by L521 , L469;
thus L543: ( ( addop C155 ) . C161 ) is  commutative by L542 , FVSUM_1:1;
end;
L544: (( 0. D70 ) = ( zeros C155 ) & [: ( addop C155 ) :] is  commutative) by L541 , L361;
thus L545: thesis by L544 , L527 , L532 , L533 , L26 , L32;
end;
end;
