:: Coherent Space
::  by Jaros{\l}aw Kotowicz and Konrad Raczkowski
::
:: Received December 29, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, CLASSES1, ZFMISC_1, EQREL_1, TOLER_1, SETFAM_1,
      SUBSET_1, FUNCT_2, FUNCT_1, RELAT_1, MCART_1, GRAPH_1, ENS_1, PARTFUN1,
      CAT_1, COH_SP, STRUCT_0, MONOID_0, RELAT_2, BINOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, SETFAM_1, RELAT_1, RELSET_1,
      MCART_1, FUNCT_1, PARTFUN1, CLASSES1, FUNCT_2, BINOP_1, EQREL_1, TOLER_1,
      STRUCT_0, GRAPH_1, CAT_1;
 constructors BINOP_1, EQREL_1, CLASSES1, TOLER_1, CAT_1, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2,
      EQREL_1, CAT_2, RELAT_1, CAT_1, XTUPLE_0;
 requirements SUBSET, BOOLE;
 definitions TARSKI, CLASSES1, XBOOLE_0, BINOP_1, RELAT_1, CAT_1, GRAPH_1,
      XTUPLE_0;
 theorems TARSKI, ZFMISC_1, TOLER_1, ENUMSET1, RELAT_1, FUNCT_2, CLASSES1,
      PARTFUN1, MCART_1, FUNCT_1, DOMAIN_1, CAT_1, XBOOLE_0, XBOOLE_1, EQREL_1,
      XTUPLE_0;
 schemes TOLER_1, TARSKI, FUNCT_2, BINOP_1, XBOOLE_0;

begin
definition
let C1 being set;
attr C1 is  binary_complete
means
:L1: (for R8 being set holds ((R8 c= C1 & (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in C1)))) implies ( union R8 ) in C1));
end;
registration
cluster  subset-closed  binary_complete non  empty for set;
existence
proof
take D1 = { ( {} ) };
thus L3: (for R4 being set holds (for R5 being set holds ((R4 in D1 & R5 c= R4) implies R5 in D1)))
proof
let R4 being set;
let R5 being set;
assume that
L4: R4 in D1
and
L5: R5 c= R4;
L6: R4 = ( {} ) by L4 , TARSKI:def 1;
thus L7: thesis by L6 , L4 , L5;
end;

thus L8: (for R8 being set holds ((R8 c= D1 & (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in D1)))) implies ( union R8 ) in D1))
proof
let R8 being set;
assume that
L9: R8 c= D1
and
L10: (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in D1)));
L11:
now
per cases  by L9 , ZFMISC_1:33;
suppose L12: R8 = ( {} );

thus L13: thesis by L12 , TARSKI:def 1 , ZFMISC_1:2;
end;
suppose L14: R8 = { ( {} ) };

L15: ( union R8 ) = ( {} ) by L14 , ZFMISC_1:25;
thus L16: thesis by L15 , TARSKI:def 1;
end;
end;
thus L18: thesis by L11;
end;

thus L19: thesis;
end;
end;
definition
mode Coherence_Space
 is  subset-closed  binary_complete non  empty set;
end;
theorem
L22: (for R9 being Coherence_Space holds ( {} ) in R9)
proof
let R9 being Coherence_Space;
L23: (( {} ) c= R9 & (for R4 being set holds (for R5 being set holds ((R4 in ( {} ) & R5 in ( {} )) implies ( R4 \/ R5 ) in R9)))) by XBOOLE_1:2;
thus L24: thesis by L23 , L1 , ZFMISC_1:2;
end;
theorem
L25: (for R7 being set holds ( bool R7 ) is Coherence_Space)
proof
let R7 being set;
L26: (for R8 being set holds ((R8 c= ( bool R7 ) & (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in ( bool R7 ))))) implies ( union R8 ) in ( bool R7 )))
proof
let R8 being set;
assume that
L27: R8 c= ( bool R7 )
and
L28: (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in ( bool R7 ))));
L29: (for R4 being set holds (R4 in R8 implies R4 c= R7)) by L27;
L30: ( union R8 ) c= R7 by L29 , ZFMISC_1:76;
thus L31: thesis by L30;
end;
L32: (for R4 being set holds (for R5 being set holds ((R4 in ( bool R7 ) & R5 c= R4) implies R5 in ( bool R7 ))))
proof
let R4 being set;
let R5 being set;
assume L33: (R4 in ( bool R7 ) & R5 c= R4);
L34: R5 c= R7 by L33 , XBOOLE_1:1;
thus L35: thesis by L34;
end;
thus L36: thesis by L32 , L26 , L1 , CLASSES1:def 1;
end;
theorem
L37: { ( {} ) } is Coherence_Space by L25 , ZFMISC_1:1;
theorem
L38: (for R1 being set holds (for R9 being Coherence_Space holds (R1 in ( union R9 ) implies { R1 } in R9)))
proof
let R1 being set;
let R9 being Coherence_Space;
assume L39: R1 in ( union R9 );
consider R7 being set such that L40: R1 in R7 and L41: R7 in R9 by L39 , TARSKI:def 4;
L42: { R1 } c= R7 by L40 , ZFMISC_1:31;
thus L43: thesis by L42 , L41 , CLASSES1:def 1;
end;
definition
let C2 being Coherence_Space;
func Web C2 -> (Tolerance of ( union C2 )) means 
:L44: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in it iff (ex R7 being set st (R7 in C2 & R1 in R7 & R2 in R7)))));
existence
proof
defpred S1[ set , set ] means (ex R7 being set st (R7 in C2 & $1 in R7 & $2 in R7));
L45: (for R1 being set holds (R1 in ( union C2 ) implies S1[ R1 , R1 ]))
proof
let R1 being set;
assume that
L46: R1 in ( union C2 );
take { R1 };
thus L47: thesis by L46 , L38 , TARSKI:def 1;
end;
L48: (for R1 being set holds (for R2 being set holds ((R1 in ( union C2 ) & R2 in ( union C2 ) & S1[ R1 , R2 ]) implies S1[ R2 , R1 ])));
consider C3 being (Tolerance of ( union C2 )) such that L49: (for R1 being set holds (for R2 being set holds ((R1 in ( union C2 ) & R2 in ( union C2 )) implies ([ R1 , R2 ] in C3 iff S1[ R1 , R2 ])))) from TOLER_1:sch 1(L45 , L48);
take C3;
let R1 being set;
let R2 being set;
thus L50: ([ R1 , R2 ] in C3 implies (ex R7 being set st (R7 in C2 & R1 in R7 & R2 in R7)))
proof
assume L51: [ R1 , R2 ] in C3;
L52: (R1 in ( union C2 ) & R2 in ( union C2 )) by L51 , ZFMISC_1:87;
thus L53: thesis by L52 , L49 , L51;
end;

given R7 being set such that
L54: (R7 in C2 & R1 in R7 & R2 in R7);

L55: (R1 in ( union C2 ) & R2 in ( union C2 )) by L54 , TARSKI:def 4;
thus L56: thesis by L55 , L49 , L54;
end;
uniqueness by TOLER_1:25;
end;
theorem
L58: (for R9 being Coherence_Space holds (for R11 being (Tolerance of ( union R9 )) holds (R11 = ( Web R9 ) iff (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in R11 iff { R1 , R2 } in R9))))))
proof
let R9 being Coherence_Space;
let R11 being (Tolerance of ( union R9 ));
thus L59: (R11 = ( Web R9 ) implies (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in R11 iff { R1 , R2 } in R9))))
proof
assume L60: R11 = ( Web R9 );
let R1 being set;
let R2 being set;
thus L61: ([ R1 , R2 ] in R11 implies { R1 , R2 } in R9)
proof
assume L62: [ R1 , R2 ] in R11;
consider R7 being set such that L63: R7 in R9 and L64: (R1 in R7 & R2 in R7) by L62 , L60 , L44;
L65: { R1 , R2 } c= R7 by L64 , ZFMISC_1:32;
thus L66: thesis by L65 , L63 , CLASSES1:def 1;
end;

L67: (R1 in { R1 , R2 } & R2 in { R1 , R2 }) by TARSKI:def 2;
assume L68: { R1 , R2 } in R9;
thus L69: thesis by L68 , L60 , L67 , L44;
end;

assume L70: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in R11 iff { R1 , R2 } in R9)));
L71: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in R11 iff (ex R7 being set st (R7 in R9 & R1 in R7 & R2 in R7)))))
proof
let R1 being set;
let R2 being set;
thus L72: ([ R1 , R2 ] in R11 implies (ex R7 being set st (R7 in R9 & R1 in R7 & R2 in R7)))
proof
assume L73: [ R1 , R2 ] in R11;
take { R1 , R2 };
thus L74: thesis by L70 , L73 , TARSKI:def 2;
end;

given R7 being set such that
L75: R7 in R9
and
L76: (R1 in R7 & R2 in R7);

L77: { R1 , R2 } c= R7 by L76 , ZFMISC_1:32;
L78: { R1 , R2 } in R9 by L77 , L75 , CLASSES1:def 1;
thus L79: thesis by L78 , L70;
end;
thus L80: thesis by L71 , L44;
end;
theorem
L81: (for R4 being set holds (for R9 being Coherence_Space holds (R4 in R9 iff (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies { R1 , R2 } in R9))))))
proof
let R4 being set;
let R9 being Coherence_Space;
defpred S2[ set , set ] means { $1 } = $2;
thus L82: (R4 in R9 implies (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies { R1 , R2 } in R9))))
proof
assume L83: R4 in R9;
let R1 being set;
let R2 being set;
assume L84: (R1 in R4 & R2 in R4);
L85: { R1 , R2 } c= R4 by L84 , ZFMISC_1:32;
thus L86: thesis by L85 , L83 , CLASSES1:def 1;
end;

L87: (for R1 being set holds (for R2 being set holds (for R3 being set holds ((S2[ R1 , R2 ] & S2[ R1 , R3 ]) implies R2 = R3))));
consider R7 being set such that L88: (for R1 being set holds (R1 in R7 iff (ex R2 being set st (R2 in R4 & S2[ R2 , R1 ])))) from TARSKI:sch 1(L87);
assume L89: (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies { R1 , R2 } in R9)));
L90: (for R5 being set holds (for R6 being set holds ((R5 in R7 & R6 in R7) implies ( R5 \/ R6 ) in R9)))
proof
let R5 being set;
let R6 being set;
assume that
L91: R5 in R7
and
L92: R6 in R7;
consider R3 being set such that L93: R3 in R4 and L94: { R3 } = R6 by L88 , L92;
consider R2 being set such that L95: R2 in R4 and L96: { R2 } = R5 by L88 , L91;
L97: { R2 , R3 } in R9 by L89 , L95 , L93;
thus L98: thesis by L97 , L96 , L94 , ENUMSET1:1;
end;
L99: ( union R7 ) = R4
proof
thus L100: ( union R7 ) c= R4
proof
let R1 being set;
assume L101: R1 in ( union R7 );
consider C4 being set such that L102: R1 in C4 and L103: C4 in R7 by L101 , TARSKI:def 4;
L104: (ex R2 being set st (R2 in R4 & C4 = { R2 })) by L88 , L103;
thus L105: thesis by L104 , L102 , TARSKI:def 1;
end;

let R1 being set;
assume L106: R1 in R4;
L107: { R1 } in R7 by L106 , L88;
L108: R1 in { R1 } by TARSKI:def 1;
thus L109: thesis by L108 , L107 , TARSKI:def 4;
end;
L110: R7 c= R9
proof
let R1 being set;
assume L111: R1 in R7;
consider R2 being set such that L112: R2 in R4 and L113: { R2 } = R1 by L111 , L88;
L114: { R2 , R2 } in R9 by L89 , L112;
thus L115: thesis by L114 , L113 , ENUMSET1:29;
end;
thus L116: thesis by L110 , L90 , L99 , L1;
end;
theorem
L117: (for R4 being set holds (for R9 being Coherence_Space holds (R4 in R9 iff (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in ( Web R9 )))))))
proof
let R4 being set;
let R9 being Coherence_Space;
thus L118: (R4 in R9 implies (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in ( Web R9 )))))
proof
assume L119: R4 in R9;
let R1 being set;
let R2 being set;
assume L120: (R1 in R4 & R2 in R4);
L121: { R1 , R2 } in R9 by L120 , L119 , L81;
thus L122: thesis by L121 , L58;
end;

assume L123: (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in ( Web R9 ))));
L124:
now
let R1 being set;
let R2 being set;
assume L125: (R1 in R4 & R2 in R4);
L126: [ R1 , R2 ] in ( Web R9 ) by L125 , L123;
thus L127: { R1 , R2 } in R9 by L126 , L58;
end;
thus L128: thesis by L124 , L81;
end;
theorem
L129: (for R4 being set holds (for R9 being Coherence_Space holds ((for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies { R1 , R2 } in R9))) implies R4 c= ( union R9 ))))
proof
let R4 being set;
let R9 being Coherence_Space;
assume L130: (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies { R1 , R2 } in R9)));
let R1 being set;
assume L131: R1 in R4;
L132: { R1 , R1 } in R9 by L131 , L130;
L133: { R1 } in R9 by L132 , ENUMSET1:29;
L134: R1 in { R1 } by TARSKI:def 1;
thus L135: thesis by L134 , L133 , TARSKI:def 4;
end;
theorem
L136: (for R9 being Coherence_Space holds (for R10 being Coherence_Space holds (( Web R9 ) = ( Web R10 ) implies R9 = R10)))
proof
let R9 being Coherence_Space;
let R10 being Coherence_Space;
assume L137: ( Web R9 ) = ( Web R10 );
thus L138: R9 c= R10
proof
let R1 being set;
assume L139: R1 in R9;
L140: (for R3 being set holds (for R2 being set holds ((R3 in R1 & R2 in R1) implies [ R3 , R2 ] in ( Web R10 )))) by L139 , L137 , L117;
thus L141: thesis by L140 , L117;
end;

let R1 being set;
assume L142: R1 in R10;
L143: (for R3 being set holds (for R2 being set holds ((R3 in R1 & R2 in R1) implies [ R3 , R2 ] in ( Web R9 )))) by L142 , L137 , L117;
thus L144: thesis by L143 , L117;
end;
theorem
L145: (for R9 being Coherence_Space holds (( union R9 ) in R9 implies R9 = ( bool ( union R9 ) )))
proof
let R9 being Coherence_Space;
assume L146: ( union R9 ) in R9;
thus L147: R9 c= ( bool ( union R9 ) ) by ZFMISC_1:82;
let R1 being set;
assume L148: R1 in ( bool ( union R9 ) );
thus L149: thesis by L148 , L146 , CLASSES1:def 1;
end;
theorem
L150: (for R9 being Coherence_Space holds (R9 = ( bool ( union R9 ) ) implies ( Web R9 ) = ( Total ( union R9 ) )))
proof
let R9 being Coherence_Space;
reconsider D2 = ( Total ( union R9 ) ) as (Tolerance of ( union R9 ));
assume L151: R9 = ( bool ( union R9 ) );
L152:
now
let R1 being set;
let R2 being set;
thus L153: ([ R1 , R2 ] in D2 implies { R1 , R2 } in R9)
proof
assume L154: [ R1 , R2 ] in D2;
L155: (R1 in ( union R9 ) & R2 in ( union R9 )) by L154 , ZFMISC_1:87;
L156: { R1 , R2 } c= ( union R9 )
proof
let R3 being set;
assume L157: R3 in { R1 , R2 };
thus L158: thesis by L157 , L155 , TARSKI:def 2;
end;
thus L159: thesis by L156 , L151;
end;

assume L160: { R1 , R2 } in R9;
L161: (R1 in ( union R9 ) & R2 in ( union R9 )) by L160 , L151 , ZFMISC_1:32;
thus L162: [ R1 , R2 ] in D2 by L161 , TOLER_1:2;
end;
thus L163: thesis by L152 , L58;
end;
definition
let C5 being set;
let C6 being (Tolerance of C5);
func CohSp C6 -> Coherence_Space means 
:L164: (for R4 being set holds (R4 in it iff (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in C6)))));
existence
proof
defpred S3[ set ] means (for R1 being set holds (for R2 being set holds ((R1 in $1 & R2 in $1) implies [ R1 , R2 ] in C6)));
consider C7 being set such that L165: (for R1 being set holds (R1 in C7 iff (R1 in ( bool C5 ) & S3[ R1 ]))) from XBOOLE_0:sch 1;
L166: (for R8 being set holds ((R8 c= C7 & (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in C7)))) implies ( union R8 ) in C7))
proof
let R8 being set;
assume that
L167: R8 c= C7
and
L168: (for R4 being set holds (for R5 being set holds ((R4 in R8 & R5 in R8) implies ( R4 \/ R5 ) in C7)));
L169:
now
let R1 being set;
let R2 being set;
assume that
L170: R1 in ( union R8 )
and
L171: R2 in ( union R8 );
consider C8 being set such that L172: R2 in C8 and L173: C8 in R8 by L171 , TARSKI:def 4;
consider C9 being set such that L174: R1 in C9 and L175: C9 in R8 by L170 , TARSKI:def 4;
L176: R1 in ( C9 \/ C8 ) by L174 , XBOOLE_0:def 3;
L177: R2 in ( C9 \/ C8 ) by L172 , XBOOLE_0:def 3;
L178: ( C9 \/ C8 ) in C7 by L168 , L175 , L173;
thus L179: [ R1 , R2 ] in C6 by L178 , L165 , L176 , L177;
end;
L180:
now
let R4 being set;
assume L181: R4 in R8;
L182: R4 in ( bool C5 ) by L181 , L165 , L167;
thus L183: R4 c= C5 by L182;
end;
L184: ( union R8 ) c= C5 by L180 , ZFMISC_1:76;
thus L185: thesis by L184 , L165 , L169;
end;
L186: (for R4 being set holds (for R5 being set holds ((R4 in C7 & R5 c= R4) implies R5 in C7)))
proof
let R4 being set;
let R5 being set;
assume that
L187: R4 in C7
and
L188: R5 c= R4;
L189: R4 in ( bool C5 ) by L165 , L187;
L190: R5 c= C5 by L189 , L188 , XBOOLE_1:1;
L191: (for R1 being set holds (for R2 being set holds ((R1 in R5 & R2 in R5) implies [ R1 , R2 ] in C6))) by L165 , L187 , L188;
thus L192: thesis by L191 , L165 , L190;
end;
L193: (S3[ ( {} ) ] & ( {} ) c= C5) by XBOOLE_1:2;
reconsider D3 = C7 as Coherence_Space by L193 , L165 , L186 , L166 , L1 , CLASSES1:def 1;
take D3;
let R4 being set;
thus L194: (R4 in D3 implies (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in C6)))) by L165;
assume L195: (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in C6)));
L196: R4 c= C5 by L195 , TOLER_1:18 , TOLER_1:def 1;
thus L197: thesis by L196 , L165 , L195;
end;
uniqueness
proof
let R9 being Coherence_Space;
let R10 being Coherence_Space;
assume that
L198: (for R4 being set holds (R4 in R9 iff (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in C6)))))
and
L199: (for R4 being set holds (R4 in R10 iff (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in C6)))));
thus L200: R9 c= R10
proof
let R1 being set;
assume L201: R1 in R9;
L202: (for R3 being set holds (for R2 being set holds ((R3 in R1 & R2 in R1) implies [ R3 , R2 ] in C6))) by L201 , L198;
thus L203: thesis by L202 , L199;
end;

let R1 being set;
assume L204: R1 in R10;
L205: (for R3 being set holds (for R2 being set holds ((R3 in R1 & R2 in R1) implies [ R3 , R2 ] in C6))) by L204 , L199;
thus L206: thesis by L205 , L198;
end;
end;
theorem
L208: (for R7 being set holds (for R12 being (Tolerance of R7) holds ( Web ( CohSp R12 ) ) = R12))
proof
let R7 being set;
let R12 being (Tolerance of R7);
L209:
now
let R1 being set;
let R2 being set;
thus L210: ([ R1 , R2 ] in ( Web ( CohSp R12 ) ) implies [ R1 , R2 ] in R12)
proof
assume L211: [ R1 , R2 ] in ( Web ( CohSp R12 ) );
L212: { R1 , R2 } in ( CohSp R12 ) by L211 , L58;
L213: (R1 in { R1 , R2 } & R2 in { R1 , R2 }) by TARSKI:def 2;
thus L214: thesis by L213 , L212 , L164;
end;

assume L215: [ R1 , R2 ] in R12;
L216: (R1 in R7 & R2 in R7) by L215 , ZFMISC_1:87;
L217: (for B1 , B2 being set holds ((B1 in { R1 , R2 } & B2 in { R1 , R2 }) implies [ B1 , B2 ] in R12))
proof
let C10 , C11 being set;
assume that
L218: C10 in { R1 , R2 }
and
L219: C11 in { R1 , R2 };
L220: (C11 = R1 or C11 = R2) by L219 , TARSKI:def 2;
L221: (C10 = R1 or C10 = R2) by L218 , TARSKI:def 2;
thus L222: thesis by L221 , L215 , L216 , L220 , EQREL_1:6 , TOLER_1:7;
end;
L223: { R1 , R2 } in ( CohSp R12 ) by L217 , L164;
thus L224: [ R1 , R2 ] in ( Web ( CohSp R12 ) ) by L223 , L58;
end;
thus L225: thesis by L209 , RELAT_1:def 2;
end;
theorem
L226: (for R9 being Coherence_Space holds ( CohSp ( Web R9 ) ) = R9)
proof
let R9 being Coherence_Space;
thus L227: ( CohSp ( Web R9 ) ) c= R9
proof
let R1 being set;
assume L228: R1 in ( CohSp ( Web R9 ) );
L229: (for R2 being set holds (for R3 being set holds ((R2 in R1 & R3 in R1) implies [ R2 , R3 ] in ( Web R9 )))) by L228 , L164;
thus L230: thesis by L229 , L117;
end;

let R1 being set;
assume L231: R1 in R9;
L232: (for R2 being set holds (for R3 being set holds ((R2 in R1 & R3 in R1) implies [ R2 , R3 ] in ( Web R9 )))) by L231 , L117;
thus L233: thesis by L232 , L164;
end;
theorem
L234: (for R4 being set holds (for R7 being set holds (for R12 being (Tolerance of R7) holds (R4 in ( CohSp R12 ) iff R4 is (TolSet of R12)))))
proof
let R4 being set;
let R7 being set;
let R12 being (Tolerance of R7);
thus L235: (R4 in ( CohSp R12 ) implies R4 is (TolSet of R12))
proof
assume L236: R4 in ( CohSp R12 );
L237: (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in R12))) by L236 , L164;
thus L238: thesis by L237 , TOLER_1:def 1;
end;

assume L239: R4 is (TolSet of R12);
L240: (for R1 being set holds (for R2 being set holds ((R1 in R4 & R2 in R4) implies [ R1 , R2 ] in R12))) by L239 , TOLER_1:def 1;
thus L241: thesis by L240 , L164;
end;
theorem
L242: (for R7 being set holds (for R12 being (Tolerance of R7) holds ( CohSp R12 ) = ( TolSets R12 )))
proof
let R7 being set;
let R12 being (Tolerance of R7);
thus L243: ( CohSp R12 ) c= ( TolSets R12 )
proof
let R1 being set;
assume L244: R1 in ( CohSp R12 );
L245: R1 is (TolSet of R12) by L244 , L234;
thus L246: thesis by L245 , TOLER_1:def 3;
end;

let R1 being set;
assume L247: R1 in ( TolSets R12 );
L248: R1 is (TolSet of R12) by L247 , TOLER_1:def 3;
thus L249: thesis by L248 , L234;
end;
begin
definition
let R7 being set;
func CSp R7 -> set equals 
{ B3 where B3 is (Subset-Family of R7) : B3 is Coherence_Space };
coherence;
end;
registration
let R7 being set;
cluster ( CSp R7 ) -> non  empty;
coherence
proof
reconsider D4 = ( bool R7 ) as (Subset-Family of R7);
set D5 = { B4 where B4 is (Subset-Family of R7) : B4 is Coherence_Space };
L251: D4 is Coherence_Space by L25;
L252: D4 in D5 by L251;
thus L253: thesis by L252;
end;
end;
registration
let C12 being set;
cluster  ->  subset-closed  binary_complete non  empty for (Element of ( CSp C12 ));
coherence
proof
let C13 being (Element of ( CSp C12 ));
L255: C13 in { B5 where B5 is (Subset-Family of C12) : B5 is Coherence_Space };
L256: (ex B6 being (Subset-Family of C12) st (C13 = B6 & B6 is Coherence_Space)) by L255;
thus L257: thesis by L256;
end;
end;
theorem
L259: (for R1 being set holds (for R2 being set holds (for R7 being set holds (for R13 being (Element of ( CSp R7 )) holds ({ R1 , R2 } in R13 implies (R1 in ( union R13 ) & R2 in ( union R13 )))))))
proof
let R1 being set;
let R2 being set;
let R7 being set;
let R13 being (Element of ( CSp R7 ));
L260: ({ R1 } c= { R1 , R2 } & { R2 } c= { R1 , R2 }) by ZFMISC_1:7;
L261: (R1 in { R1 } & R2 in { R2 }) by TARSKI:def 1;
assume L262: { R1 , R2 } in R13;
thus L263: thesis by L262 , L260 , L261 , TARSKI:def 4;
end;
definition
let R7 being set;
func FuncsC R7 -> set equals 
( union { ( Funcs (( union B7 ) , ( union B8 )) ) where B7 is (Element of ( CSp R7 )) , B8 is (Element of ( CSp R7 )) : (not contradiction) } );
coherence;
end;
registration
let R7 being set;
cluster ( FuncsC R7 ) -> non  empty  functional;
coherence
proof
reconsider D6 = ( bool R7 ) as (Subset-Family of R7);
L265: D6 is Coherence_Space by L25;
L266: D6 in { B9 where B9 is (Subset-Family of R7) : B9 is Coherence_Space } by L265;
reconsider D7 = D6 as (Element of ( CSp R7 )) by L266;
set D8 = { ( Funcs (( union B10 ) , ( union B11 )) ) where B10 is (Element of ( CSp R7 )) , B11 is (Element of ( CSp R7 )) : (not contradiction) };
L267: (( id ( union D7 ) ) in ( Funcs (( union D7 ) , ( union D7 )) ) & ( Funcs (( union D7 ) , ( union D7 )) ) in D8) by FUNCT_2:9;
reconsider D9 = ( union D8 ) as non  empty set by L267 , TARSKI:def 4;
L268:
now
let C14 being set;
assume L269: C14 in D9;
consider C15 being set such that L270: C14 in C15 and L271: C15 in D8 by L269 , TARSKI:def 4;
L272: (ex B12 , B13 being (Element of ( CSp R7 )) st C15 = ( Funcs (( union B12 ) , ( union B13 )) )) by L271;
thus L273: C14 is Function by L272 , L270;
end;
thus L274: thesis by L268 , FUNCT_1:def 13;
end;
end;
theorem
L276: (for R1 being set holds (for R7 being set holds (R1 in ( FuncsC R7 ) iff (ex R14 being (Element of ( CSp R7 )) st (ex R15 being (Element of ( CSp R7 )) st ((( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & R1 is (Function of ( union R14 ) , ( union R15 ))))))))
proof
let R1 being set;
let R7 being set;
set D10 = { ( Funcs (( union B14 ) , ( union B15 )) ) where B14 is (Element of ( CSp R7 )) , B15 is (Element of ( CSp R7 )) : (not contradiction) };
thus L277: (R1 in ( FuncsC R7 ) implies (ex R14 being (Element of ( CSp R7 )) st (ex R15 being (Element of ( CSp R7 )) st ((( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & R1 is (Function of ( union R14 ) , ( union R15 ))))))
proof
assume L278: R1 in ( FuncsC R7 );
consider C16 being set such that L279: R1 in C16 and L280: C16 in D10 by L278 , TARSKI:def 4;
consider C17 , C18 being (Element of ( CSp R7 )) such that L281: C16 = ( Funcs (( union C17 ) , ( union C18 )) ) by L280;
take C17;
take C18;
thus L282: thesis by L279 , L281 , FUNCT_2:66;
end;

given C19 , C20 being (Element of ( CSp R7 )) such that
L283: ((( union C20 ) = ( {} ) implies ( union C19 ) = ( {} )) & R1 is (Function of ( union C19 ) , ( union C20 )));

L284: ( Funcs (( union C19 ) , ( union C20 )) ) in D10;
L285: R1 in ( Funcs (( union C19 ) , ( union C20 )) ) by L283 , FUNCT_2:8;
thus L286: thesis by L285 , L284 , TARSKI:def 4;
end;
definition
let R7 being set;
func MapsC R7 -> set equals 
{ [ [ B16 , B17 ] , B18 ] where B16 is (Element of ( CSp R7 )) , B17 is (Element of ( CSp R7 )) , B18 is (Element of ( FuncsC R7 )) : ((( union B17 ) = ( {} ) implies ( union B16 ) = ( {} )) & B18 is (Function of ( union B16 ) , ( union B17 )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in B16 implies { ( B18 . R1 ) , ( B18 . R2 ) } in B17)))) };
coherence;
end;
registration
let R7 being set;
cluster ( MapsC R7 ) -> non  empty;
coherence
proof
set D11 = { [ [ B19 , B20 ] , B21 ] where B19 is (Element of ( CSp R7 )) , B20 is (Element of ( CSp R7 )) , B21 is (Element of ( FuncsC R7 )) : ((( union B20 ) = ( {} ) implies ( union B19 ) = ( {} )) & B21 is (Function of ( union B19 ) , ( union B20 )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in B19 implies { ( B21 . R1 ) , ( B21 . R2 ) } in B20)))) };
L288:
now
reconsider D12 = ( bool R7 ) as (Subset-Family of R7);
L289: D12 is Coherence_Space by L25;
L290: D12 in { B22 where B22 is (Subset-Family of R7) : B22 is Coherence_Space } by L289;
reconsider D13 = D12 as (Element of ( CSp R7 )) by L290;
set D14 = ( id ( union D13 ) );
take D15 = [ [ D13 , D13 ] , D14 ];
L291: (( union D13 ) = ( {} ) implies ( union D13 ) = ( {} ));
reconsider D16 = D14 as (Element of ( FuncsC R7 )) by L276;
L292:
now
let R1 being set;
let R2 being set;
assume L293: { R1 , R2 } in D13;
L294: R1 in ( union D13 ) by L293 , L259;
L295: ( D16 . R1 ) = R1 by L294 , FUNCT_1:18;
L296: R2 in ( union D13 ) by L293 , L259;
thus L297: { ( D16 . R1 ) , ( D16 . R2 ) } in D13 by L296 , L293 , L295 , FUNCT_1:18;
end;
thus L298: D15 in D11 by L292 , L291;
end;
thus L299: thesis by L288;
end;
end;
theorem
L301: (for R7 being set holds (for R17 being (Element of ( MapsC R7 )) holds (ex R16 being (Element of ( FuncsC R7 )) st (ex R14 being (Element of ( CSp R7 )) st (ex R15 being (Element of ( CSp R7 )) st (R17 = [ [ R14 , R15 ] , R16 ] & (( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & R16 is (Function of ( union R14 ) , ( union R15 )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15)))))))))
proof
let R7 being set;
let R17 being (Element of ( MapsC R7 ));
L302: R17 in { [ [ R14 , R15 ] , R16 ] where R14 is (Element of ( CSp R7 )) , R15 is (Element of ( CSp R7 )) , R16 is (Element of ( FuncsC R7 )) : ((( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & R16 is (Function of ( union R14 ) , ( union R15 )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15)))) };
L303: (ex R14 being (Element of ( CSp R7 )) st (ex R15 being (Element of ( CSp R7 )) st (ex R16 being (Element of ( FuncsC R7 )) st (R17 = [ [ R14 , R15 ] , R16 ] & (( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & R16 is (Function of ( union R14 ) , ( union R15 )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15))))))) by L302;
thus L304: thesis by L303;
end;
theorem
L305: (for R7 being set holds (for R14 being (Element of ( CSp R7 )) holds (for R15 being (Element of ( CSp R7 )) holds (for B23 being (Function of ( union R14 ) , ( union R15 )) holds (((( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( B23 . R1 ) , ( B23 . R2 ) } in R15)))) implies [ [ R14 , R15 ] , B23 ] in ( MapsC R7 ))))))
proof
let R7 being set;
let R14 being (Element of ( CSp R7 ));
let R15 being (Element of ( CSp R7 ));
let C21 being (Function of ( union R14 ) , ( union R15 ));
assume that
L306: (( union R15 ) = ( {} ) implies ( union R14 ) = ( {} ))
and
L307: (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( C21 . R1 ) , ( C21 . R2 ) } in R15)));
reconsider D17 = C21 as (Element of ( FuncsC R7 )) by L306 , L276;
L308: (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( D17 . R1 ) , ( D17 . R2 ) } in R15))) by L307;
thus L309: thesis by L308 , L306;
end;
registration
let C22 being set;
let C23 being (Element of ( MapsC C22 ));
cluster ( C23 `2 ) ->  Function-like  Relation-like;
coherence
proof
consider C24 being (Element of ( FuncsC C22 )), C25 , C26 being (Element of ( CSp C22 )) such that L310: (C23 = [ [ C25 , C26 ] , C24 ] & (( union C26 ) = ( {} ) implies ( union C25 ) = ( {} )) & C24 is (Function of ( union C25 ) , ( union C26 )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in C25 implies { ( C24 . R1 ) , ( C24 . R2 ) } in C26)))) by L301;
L311: ( [ [ C25 , C26 ] , C24 ] `2 ) = C24;
thus L312: thesis by L311 , L310;
end;
end;
definition
let R7 being set;
let R17 being (Element of ( MapsC R7 ));
func dom R17 -> (Element of ( CSp R7 )) equals 
( ( R17 `1 ) `1 );
coherence
proof
consider R16 being (Element of ( FuncsC R7 )), R14 being (Element of ( CSp R7 )), R15 being (Element of ( CSp R7 )) such that L314: R17 = [ [ R14 , R15 ] , R16 ] and L315: (( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) and L316: R16 is (Function of ( union R14 ) , ( union R15 )) and L317: (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15))) by L301;
L318: ([ R14 , R15 ] = ( [ [ R14 , R15 ] , R16 ] `1 ) & ( [ R14 , R15 ] `1 ) = R14);
thus L319: thesis by L318 , L314;
end;
func cod R17 -> (Element of ( CSp R7 )) equals 
( ( R17 `1 ) `2 );
coherence
proof
consider R16 being (Element of ( FuncsC R7 )), R14 being (Element of ( CSp R7 )), R15 being (Element of ( CSp R7 )) such that L320: R17 = [ [ R14 , R15 ] , R16 ] and L321: (( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) and L322: R16 is (Function of ( union R14 ) , ( union R15 )) and L323: (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15))) by L301;
L324: ([ R14 , R15 ] = ( [ [ R14 , R15 ] , R16 ] `1 ) & ( [ R14 , R15 ] `2 ) = R15);
thus L325: thesis by L324 , L320;
end;
end;
theorem
L327: (for R7 being set holds (for R17 being (Element of ( MapsC R7 )) holds R17 = [ [ ( dom R17 ) , ( cod R17 ) ] , ( R17 `2 ) ]))
proof
let R7 being set;
let R17 being (Element of ( MapsC R7 ));
consider R16 being (Element of ( FuncsC R7 )), R14 being (Element of ( CSp R7 )), R15 being (Element of ( CSp R7 )) such that L328: R17 = [ [ R14 , R15 ] , R16 ] and L329: (( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) and L330: R16 is (Function of ( union R14 ) , ( union R15 )) and L331: (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15))) by L301;
L332: [ R14 , R15 ] = ( [ [ R14 , R15 ] , R16 ] `1 );
L333: ( R17 `1 ) = [ ( dom R17 ) , ( cod R17 ) ] by L332 , L328 , MCART_1:8;
thus L334: thesis by L333 , L328 , MCART_1:8;
end;
L335: (for R7 being set holds (for R17 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds ((( R17 `2 ) = ( R18 `2 ) & ( dom R17 ) = ( dom R18 ) & ( cod R17 ) = ( cod R18 )) implies R17 = R18))))
proof
let R7 being set;
let R17 being (Element of ( MapsC R7 ));
let R18 being (Element of ( MapsC R7 ));
L336: R17 = [ [ ( dom R17 ) , ( cod R17 ) ] , ( R17 `2 ) ] by L327;
thus L337: thesis by L336 , L327;
end;
definition
let R7 being set;
let R13 being (Element of ( CSp R7 ));
func id$ R13 -> (Element of ( MapsC R7 )) equals 
[ [ R13 , R13 ] , ( id ( union R13 ) ) ];
coherence
proof
set D18 = ( id ( union R13 ) );
L338:
now
let R1 being set;
let R2 being set;
assume L339: { R1 , R2 } in R13;
L340: R1 in ( union R13 ) by L339 , L259;
L341: ( ( id ( union R13 ) ) . R1 ) = R1 by L340 , FUNCT_1:18;
L342: R2 in ( union R13 ) by L339 , L259;
thus L343: { ( D18 . R1 ) , ( D18 . R2 ) } in R13 by L342 , L339 , L341 , FUNCT_1:18;
end;
thus L344: thesis by L338 , L305;
end;
end;
L346: (for B24 , B25 , B26 , B27 , B28 , B29 being set holds ([ [ B24 , B26 ] , B28 ] = [ [ B25 , B27 ] , B29 ] implies (B24 = B25 & B26 = B27)))
proof
let C27 , C28 , C29 , C30 , C31 , C32 being set;
assume L347: [ [ C27 , C29 ] , C31 ] = [ [ C28 , C30 ] , C32 ];
L348: [ C27 , C29 ] = [ C28 , C30 ] by L347 , XTUPLE_0:1;
thus L349: thesis by L348 , XTUPLE_0:1;
end;
theorem
L350: (for R7 being set holds (for R17 being (Element of ( MapsC R7 )) holds ((( union ( cod R17 ) ) <> ( {} ) or ( union ( dom R17 ) ) = ( {} )) & ( R17 `2 ) is (Function of ( union ( dom R17 ) ) , ( union ( cod R17 ) )) & (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in ( dom R17 ) implies { ( ( R17 `2 ) . R1 ) , ( ( R17 `2 ) . R2 ) } in ( cod R17 )))))))
proof
let R7 being set;
let R17 being (Element of ( MapsC R7 ));
consider R16 being (Element of ( FuncsC R7 )), R14 being (Element of ( CSp R7 )), R15 being (Element of ( CSp R7 )) such that L351: R17 = [ [ R14 , R15 ] , R16 ] and L352: ((( union R15 ) = ( {} ) implies ( union R14 ) = ( {} )) & R16 is (Function of ( union R14 ) , ( union R15 ))) and L353: (for R1 being set holds (for R2 being set holds ({ R1 , R2 } in R14 implies { ( R16 . R1 ) , ( R16 . R2 ) } in R15))) by L301;
L354: R17 = [ [ ( dom R17 ) , ( cod R17 ) ] , ( R17 `2 ) ] by L327;
L355: R15 = ( cod R17 ) by L354 , L351 , L346;
L356: (R16 = ( R17 `2 ) & R14 = ( dom R17 )) by L351 , L354 , L346 , XTUPLE_0:1;
thus L357: ((( union ( cod R17 ) ) <> ( {} ) or ( union ( dom R17 ) ) = ( {} )) & ( R17 `2 ) is (Function of ( union ( dom R17 ) ) , ( union ( cod R17 ) ))) by L356 , L351 , L352 , L354 , L346;
let R1 being set;
let R2 being set;
assume L358: { R1 , R2 } in ( dom R17 );
thus L359: thesis by L358 , L353 , L356 , L355;
end;
definition
let R7 being set;
let R18 being (Element of ( MapsC R7 ));
let R19 being (Element of ( MapsC R7 ));
assume L360: ( cod R18 ) = ( dom R19 );
func R19 * R18 -> (Element of ( MapsC R7 )) equals 
:L361: [ [ ( dom R18 ) , ( cod R19 ) ] , ( ( R19 `2 ) * ( R18 `2 ) ) ];
coherence
proof
L362: (( union ( cod R19 ) ) <> ( {} ) or ( union ( dom R19 ) ) = ( {} )) by L350;
L363: (( union ( cod R18 ) ) <> ( {} ) or ( union ( dom R18 ) ) = ( {} )) by L350;
L364: ( R18 `2 ) is (Function of ( union ( dom R18 ) ) , ( union ( cod R18 ) )) by L350;
L365:
now
let R1 being set;
let R2 being set;
assume L366: { R1 , R2 } in ( dom R18 );
L367: R1 in ( union ( dom R18 ) ) by L366 , L259;
L368: R1 in ( dom ( R18 `2 ) ) by L367 , L363 , L364 , FUNCT_2:def 1;
L369: R2 in ( union ( dom R18 ) ) by L366 , L259;
L370: R2 in ( dom ( R18 `2 ) ) by L369 , L363 , L364 , FUNCT_2:def 1;
L371: { ( ( R18 `2 ) . R1 ) , ( ( R18 `2 ) . R2 ) } in ( cod R18 ) by L366 , L350;
L372: { ( ( R19 `2 ) . ( ( R18 `2 ) . R1 ) ) , ( ( R19 `2 ) . ( ( R18 `2 ) . R2 ) ) } in ( cod R19 ) by L371 , L360 , L350;
L373: { ( ( ( R19 `2 ) * ( R18 `2 ) ) . R1 ) , ( ( R19 `2 ) . ( ( R18 `2 ) . R2 ) ) } in ( cod R19 ) by L372 , L368 , FUNCT_1:13;
thus L374: { ( ( ( R19 `2 ) * ( R18 `2 ) ) . R1 ) , ( ( ( R19 `2 ) * ( R18 `2 ) ) . R2 ) } in ( cod R19 ) by L373 , L370 , FUNCT_1:13;
end;
L375: ( R19 `2 ) is (Function of ( union ( dom R19 ) ) , ( union ( cod R19 ) )) by L350;
L376: ( ( R19 `2 ) * ( R18 `2 ) ) is (Function of ( union ( dom R18 ) ) , ( union ( cod R19 ) )) by L375 , L360 , L363 , L364 , FUNCT_2:13;
thus L377: thesis by L376 , L360 , L363 , L362 , L365 , L305;
end;
end;
theorem
L379: (for R7 being set holds (for R18 being (Element of ( MapsC R7 )) holds (for R19 being (Element of ( MapsC R7 )) holds (( dom R19 ) = ( cod R18 ) implies (( ( R19 * R18 ) `2 ) = ( ( R19 `2 ) * ( R18 `2 ) ) & ( dom ( R19 * R18 ) ) = ( dom R18 ) & ( cod ( R19 * R18 ) ) = ( cod R19 ))))))
proof
let R7 being set;
let R18 being (Element of ( MapsC R7 ));
let R19 being (Element of ( MapsC R7 ));
assume L380: ( dom R19 ) = ( cod R18 );
L381: [ [ ( dom R18 ) , ( cod R19 ) ] , ( ( R19 `2 ) * ( R18 `2 ) ) ] = ( R19 * R18 ) by L380 , L361
.= [ [ ( dom ( R19 * R18 ) ) , ( cod ( R19 * R18 ) ) ] , ( ( R19 * R18 ) `2 ) ] by L327;
thus L382: thesis by L381 , L346 , XTUPLE_0:1;
end;
theorem
L383: (for R7 being set holds (for R18 being (Element of ( MapsC R7 )) holds (for R19 being (Element of ( MapsC R7 )) holds (for R20 being (Element of ( MapsC R7 )) holds ((( dom R19 ) = ( cod R18 ) & ( dom R20 ) = ( cod R19 )) implies ( R20 * ( R19 * R18 ) ) = ( ( R20 * R19 ) * R18 ))))))
proof
let R7 being set;
let R18 being (Element of ( MapsC R7 ));
let R19 being (Element of ( MapsC R7 ));
let R20 being (Element of ( MapsC R7 ));
assume that
L384: ( dom R19 ) = ( cod R18 )
and
L385: ( dom R20 ) = ( cod R19 );
L386: ( cod ( R19 * R18 ) ) = ( cod R19 ) by L384 , L379;
L387: ( ( R19 * R18 ) `2 ) = ( ( R19 `2 ) * ( R18 `2 ) ) by L384 , L379;
L388: ( ( R20 * ( R19 * R18 ) ) `2 ) = ( ( R20 `2 ) * ( ( R19 `2 ) * ( R18 `2 ) ) ) by L387 , L385 , L386 , L379;
L389: ( dom ( R20 * R19 ) ) = ( dom R19 ) by L385 , L379;
L390: ( dom ( ( R20 * R19 ) * R18 ) ) = ( dom R18 ) by L389 , L384 , L379;
L391: ( dom ( R19 * R18 ) ) = ( dom R18 ) by L384 , L379;
L392: ( dom ( R20 * ( R19 * R18 ) ) ) = ( dom R18 ) by L391 , L385 , L386 , L379;
L393: ( cod ( R20 * R19 ) ) = ( cod R20 ) by L385 , L379;
L394: ( cod ( ( R20 * R19 ) * R18 ) ) = ( cod R20 ) by L393 , L384 , L389 , L379;
L395: ( ( R20 * R19 ) `2 ) = ( ( R20 `2 ) * ( R19 `2 ) ) by L385 , L379;
L396: ( ( ( R20 * R19 ) * R18 ) `2 ) = ( ( ( R20 `2 ) * ( R19 `2 ) ) * ( R18 `2 ) ) by L395 , L384 , L389 , L379;
L397: ( cod ( R20 * ( R19 * R18 ) ) ) = ( cod R20 ) by L385 , L386 , L379;
thus L398: thesis by L397 , L388 , L392 , L396 , L390 , L394 , L335 , RELAT_1:36;
end;
theorem
L399: (for R7 being set holds (for R13 being (Element of ( CSp R7 )) holds (( ( id$ R13 ) `2 ) = ( id ( union R13 ) ) & ( dom ( id$ R13 ) ) = R13 & ( cod ( id$ R13 ) ) = R13)))
proof
let R7 being set;
let R13 being (Element of ( CSp R7 ));
L400: [ [ ( dom ( id$ R13 ) ) , ( cod ( id$ R13 ) ) ] , ( ( id$ R13 ) `2 ) ] = [ [ R13 , R13 ] , ( id ( union R13 ) ) ] by L327;
thus L401: thesis by L400 , L346 , XTUPLE_0:1;
end;
theorem
L402: (for R7 being set holds (for R17 being (Element of ( MapsC R7 )) holds (( R17 * ( id$ ( dom R17 ) ) ) = R17 & ( ( id$ ( cod R17 ) ) * R17 ) = R17)))
proof
let R7 being set;
let R17 being (Element of ( MapsC R7 ));
set D19 = ( id$ ( dom R17 ) );
set D20 = ( id$ ( cod R17 ) );
L403: (( D19 `2 ) = ( id ( union ( dom R17 ) ) ) & ( dom D19 ) = ( dom R17 )) by L399;
L404: ( R17 `2 ) is (Function of ( union ( dom R17 ) ) , ( union ( cod R17 ) )) by L350;
L405: ( rng ( R17 `2 ) ) c= ( union ( cod R17 ) ) by L404 , RELAT_1:def 19;
L406: (( union ( cod R17 ) ) <> ( {} ) or ( union ( dom R17 ) ) = ( {} )) by L350;
L407: ( dom ( R17 `2 ) ) = ( union ( dom R17 ) ) by L406 , L404 , FUNCT_2:def 1;
L408: ( cod D19 ) = ( dom R17 ) by L399;
L409: ( cod ( R17 * D19 ) ) = ( cod R17 ) by L408 , L379;
L410: (( ( R17 * D19 ) `2 ) = ( ( R17 `2 ) * ( D19 `2 ) ) & ( dom ( R17 * D19 ) ) = ( dom D19 )) by L408 , L379;
thus L411: ( R17 * D19 ) = R17 by L410 , L407 , L403 , L409 , L335 , RELAT_1:52;
L412: (( D20 `2 ) = ( id ( union ( cod R17 ) ) ) & ( cod D20 ) = ( cod R17 )) by L399;
L413: ( dom D20 ) = ( cod R17 ) by L399;
L414: ( cod ( D20 * R17 ) ) = ( cod D20 ) by L413 , L379;
L415: (( ( D20 * R17 ) `2 ) = ( ( D20 `2 ) * ( R17 `2 ) ) & ( dom ( D20 * R17 ) ) = ( dom R17 )) by L413 , L379;
thus L416: thesis by L415 , L405 , L412 , L414 , L335 , RELAT_1:53;
end;
definition
let R7 being set;
func CDom R7 -> (Function of ( MapsC R7 ) , ( CSp R7 )) means 
:L417: (for R17 being (Element of ( MapsC R7 )) holds ( it . R17 ) = ( dom R17 ));
existence
proof
deffunc H1((Element of ( MapsC R7 ))) = ( dom $1 );
thus L418: (ex B30 being (Function of ( MapsC R7 ) , ( CSp R7 )) st (for B31 being (Element of ( MapsC R7 )) holds ( B30 . B31 ) = H1(B31))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C33 , C34 being (Function of ( MapsC R7 ) , ( CSp R7 ));
assume that
L419: (for R17 being (Element of ( MapsC R7 )) holds ( C33 . R17 ) = ( dom R17 ))
and
L420: (for R17 being (Element of ( MapsC R7 )) holds ( C34 . R17 ) = ( dom R17 ));
L421:
now
let R17 being (Element of ( MapsC R7 ));
thus L422: ( C33 . R17 ) = ( dom R17 ) by L419
.= ( C34 . R17 ) by L420;
end;
thus L423: thesis by L421 , FUNCT_2:63;
end;
func CCod R7 -> (Function of ( MapsC R7 ) , ( CSp R7 )) means 
:L424: (for R17 being (Element of ( MapsC R7 )) holds ( it . R17 ) = ( cod R17 ));
existence
proof
deffunc H2((Element of ( MapsC R7 ))) = ( cod $1 );
thus L425: (ex B32 being (Function of ( MapsC R7 ) , ( CSp R7 )) st (for B33 being (Element of ( MapsC R7 )) holds ( B32 . B33 ) = H2(B33))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C35 , C36 being (Function of ( MapsC R7 ) , ( CSp R7 ));
assume that
L426: (for R17 being (Element of ( MapsC R7 )) holds ( C35 . R17 ) = ( cod R17 ))
and
L427: (for R17 being (Element of ( MapsC R7 )) holds ( C36 . R17 ) = ( cod R17 ));
L428:
now
let R17 being (Element of ( MapsC R7 ));
thus L429: ( C35 . R17 ) = ( cod R17 ) by L426
.= ( C36 . R17 ) by L427;
end;
thus L430: thesis by L428 , FUNCT_2:63;
end;
func CComp R7 -> (PartFunc of [: ( MapsC R7 ) , ( MapsC R7 ) :] , ( MapsC R7 )) means 
:L431: ((for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds ([ R19 , R18 ] in ( dom it ) iff ( dom R19 ) = ( cod R18 )))) & (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds (( dom R19 ) = ( cod R18 ) implies ( it . [ R19 , R18 ] ) = ( R19 * R18 )))));
existence
proof
defpred S4[ set , set , set ] means (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds ((R19 = $1 & R18 = $2) implies (( dom R19 ) = ( cod R18 ) & $3 = ( R19 * R18 )))));
L432: (for B34 , B35 , B36 , B37 being set holds ((B34 in ( MapsC R7 ) & B35 in ( MapsC R7 ) & S4[ B34 , B35 , B36 ] & S4[ B34 , B35 , B37 ]) implies B36 = B37))
proof
let C37 , C38 , C39 , C40 being set;
assume L433: (C37 in ( MapsC R7 ) & C38 in ( MapsC R7 ));
reconsider D21 = C37 , D22 = C38 as (Element of ( MapsC R7 )) by L433;
assume that
L434: S4[ C37 , C38 , C39 ]
and
L435: S4[ C37 , C38 , C40 ];
L436: C39 = ( D21 * D22 ) by L434;
thus L437: thesis by L436 , L435;
end;
L438: (for B38 , B39 , B40 being set holds ((B38 in ( MapsC R7 ) & B39 in ( MapsC R7 ) & S4[ B38 , B39 , B40 ]) implies B40 in ( MapsC R7 )))
proof
let C41 , C42 , C43 being set;
assume L439: (C41 in ( MapsC R7 ) & C42 in ( MapsC R7 ));
reconsider D23 = C41 , D24 = C42 as (Element of ( MapsC R7 )) by L439;
assume L440: S4[ C41 , C42 , C43 ];
L441: C43 = ( D23 * D24 ) by L440;
thus L442: thesis by L441;
end;
consider C44 being (PartFunc of [: ( MapsC R7 ) , ( MapsC R7 ) :] , ( MapsC R7 )) such that L443: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( dom C44 ) iff (R1 in ( MapsC R7 ) & R2 in ( MapsC R7 ) & (ex R3 being set st S4[ R1 , R2 , R3 ]))))) and L444: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( dom C44 ) implies S4[ R1 , R2 , ( C44 . (R1 , R2) ) ]))) from BINOP_1:sch 5(L438 , L432);
take C44;
thus L445: (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds ([ R19 , R18 ] in ( dom C44 ) iff ( dom R19 ) = ( cod R18 ))))
proof
let R19 being (Element of ( MapsC R7 ));
let R18 being (Element of ( MapsC R7 ));
thus L446: ([ R19 , R18 ] in ( dom C44 ) implies ( dom R19 ) = ( cod R18 ))
proof
assume L447: [ R19 , R18 ] in ( dom C44 );
L448: (ex B41 being set st S4[ R19 , R18 , B41 ]) by L447 , L443;
thus L449: thesis by L448;
end;

assume L450: ( dom R19 ) = ( cod R18 );
L451: S4[ R19 , R18 , ( R19 * R18 ) ] by L450;
thus L452: thesis by L451 , L443;
end;

let R19 being (Element of ( MapsC R7 ));
let R18 being (Element of ( MapsC R7 ));
assume L453: ( dom R19 ) = ( cod R18 );
L454: [ R19 , R18 ] in ( dom C44 ) by L453 , L445;
L455: S4[ R19 , R18 , ( C44 . (R19 , R18) ) ] by L454 , L444;
thus L456: thesis by L455;
end;
uniqueness
proof
let C45 , C46 being (PartFunc of [: ( MapsC R7 ) , ( MapsC R7 ) :] , ( MapsC R7 ));
assume that
L457: (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds ([ R19 , R18 ] in ( dom C45 ) iff ( dom R19 ) = ( cod R18 ))))
and
L458: (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds (( dom R19 ) = ( cod R18 ) implies ( C45 . [ R19 , R18 ] ) = ( R19 * R18 ))))
and
L459: (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds ([ R19 , R18 ] in ( dom C46 ) iff ( dom R19 ) = ( cod R18 ))))
and
L460: (for R19 being (Element of ( MapsC R7 )) holds (for R18 being (Element of ( MapsC R7 )) holds (( dom R19 ) = ( cod R18 ) implies ( C46 . [ R19 , R18 ] ) = ( R19 * R18 ))));
L461: ( dom C45 ) = ( dom C46 )
proof
let C47 , C48 being set;
thus L462: ([ C47 , C48 ] in ( dom C45 ) implies [ C47 , C48 ] in ( dom C46 ))
proof
assume L463: [ C47 , C48 ] in ( dom C45 );
reconsider D25 = C47 , D26 = C48 as (Element of ( MapsC R7 )) by L463 , ZFMISC_1:87;
L464: ( dom D25 ) = ( cod D26 ) by L457 , L463;
thus L465: thesis by L464 , L459;
end;

assume L466: [ C47 , C48 ] in ( dom C46 );
reconsider D27 = C47 , D28 = C48 as (Element of ( MapsC R7 )) by L466 , ZFMISC_1:87;
L467: ( dom D27 ) = ( cod D28 ) by L459 , L466;
thus L468: thesis by L467 , L457;
end;
L469:
now
let C49 being (Element of [: ( MapsC R7 ) , ( MapsC R7 ) :]);
assume that
L470: C49 in ( dom C45 );
consider C50 , C51 being (Element of ( MapsC R7 )) such that L471: C49 = [ C50 , C51 ] by DOMAIN_1:1;
L472: ( dom C50 ) = ( cod C51 ) by L457 , L470 , L471;
L473: ( C45 . [ C50 , C51 ] ) = ( C50 * C51 ) by L472 , L458;
thus L474: ( C45 . C49 ) = ( C46 . C49 ) by L473 , L460 , L471 , L472;
end;
thus L475: thesis by L469 , L461 , PARTFUN1:5;
end;
end;
canceled 1;
definition
canceled 1;
let R7 being set;
func CohCat R7 -> non  empty non  void  strict CatStr equals 
CatStr (# ( CSp R7 ) , ( MapsC R7 ) , ( CDom R7 ) , ( CCod R7 ) , ( CComp R7 ) #);
coherence;
end;
registration
let R7 being set;
cluster ( CohCat R7 ) ->  Category-like  transitive  associative  reflexive;
coherence
proof
set D29 = ( MapsC R7 );
set D30 = ( CDom R7 );
set D31 = ( CCod R7 );
set D32 = ( CComp R7 );
set D33 = ( CohCat R7 );
thus L478: D33 is  Category-like
proof
let C52 , C53 being (Morphism of D33);
reconsider D34 = C52 , D35 = C53 as (Element of D29);
L479: (( D30 . C53 ) = ( dom D35 ) & ( D31 . C52 ) = ( cod D34 )) by L417 , L424;
thus L480: thesis by L479 , L431;
end;

thus L481: D33 is  transitive
proof
let C54 , C55 being (Morphism of D33);
assume that
L482: ( dom C55 ) = ( cod C54 );
L483: [ C55 , C54 ] in ( dom (the Comp of D33) ) by L482 , L478 , CAT_1:def 6;
L484: ( (the Comp of D33) . (C55 , C54) ) = ( C55 (*) C54 ) by L483 , CAT_1:def 1;
reconsider D36 = C54 , D37 = C55 as (Element of D29);
L485: (( D30 . D37 ) = ( dom D37 ) & ( D31 . D36 ) = ( cod D36 )) by L417 , L424;
L486: ( D32 . [ D37 , D36 ] ) = ( D37 * D36 ) by L485 , L482 , L431;
L487: (( D30 . D36 ) = ( dom D36 ) & ( D31 . D37 ) = ( cod D37 )) by L417 , L424;
L488: (( dom ( D37 * D36 ) ) = ( dom D36 ) & ( cod ( D37 * D36 ) ) = ( cod D37 )) by L482 , L485 , L379;
thus L489: thesis by L488 , L486 , L487 , L417 , L424 , L484;
end;

thus L490: D33 is  associative
proof
let C56 , C57 , C58 being (Morphism of D33);
assume that
L491: ( dom C58 ) = ( cod C57 )
and
L492: ( dom C57 ) = ( cod C56 );
reconsider D38 = C56 , D39 = C57 , D40 = C58 as (Element of D29);
L493: (( dom D40 ) = ( D30 . D40 ) & ( cod D39 ) = ( D31 . D39 )) by L417 , L424;
L494: ( dom ( D40 * D39 ) ) = ( dom D39 ) by L493 , L491 , L379;
L495: (( dom D39 ) = ( D30 . D39 ) & ( cod D38 ) = ( D31 . D38 )) by L417 , L424;
L496: ( cod ( D39 * D38 ) ) = ( dom D40 ) by L495 , L491 , L492 , L493 , L379;
L497: [ C58 , C57 ] in ( dom (the Comp of D33) ) by L478 , CAT_1:def 6 , L491;
L498: ( C58 (*) C57 ) = ( (the Comp of D33) . (C58 , C57) ) by L497 , CAT_1:def 1;
L499: ( dom ( C58 (*) C57 ) ) = ( dom C57 ) by L481 , CAT_1:def 7 , L491;
L500: [ ( C58 (*) C57 ) , C56 ] in ( dom (the Comp of D33) ) by L499 , L478 , CAT_1:def 6 , L492;
L501: [ C57 , C56 ] in ( dom (the Comp of D33) ) by L478 , CAT_1:def 6 , L492;
L502: ( C57 (*) C56 ) = ( (the Comp of D33) . (C57 , C56) ) by L501 , CAT_1:def 1;
L503: ( cod ( C57 (*) C56 ) ) = ( cod C57 ) by L481 , CAT_1:def 7 , L492;
L504: [ C58 , ( C57 (*) C56 ) ] in ( dom (the Comp of D33) ) by L503 , L478 , CAT_1:def 6 , L491;
thus L505: ( C58 (*) ( C57 (*) C56 ) ) = ( (the Comp of D33) . (C58 , ( (the Comp of D33) . (C57 , C56) )) ) by L504 , L502 , CAT_1:def 1
.= ( D32 . [ D40 , ( D39 * D38 ) ] ) by L492 , L495 , L431
.= ( D40 * ( D39 * D38 ) ) by L496 , L431
.= ( ( D40 * D39 ) * D38 ) by L491 , L492 , L493 , L495 , L383
.= ( D32 . [ ( D40 * D39 ) , D38 ] ) by L492 , L495 , L494 , L431
.= ( (the Comp of D33) . (( (the Comp of D33) . (C58 , C57) ) , C56) ) by L491 , L493 , L431
.= ( ( C58 (*) C57 ) (*) C56 ) by L498 , L500 , CAT_1:def 1;
end;

let C59 being (Object of D33);
reconsider D41 = C59 as (Element of ( CSp R7 ));
reconsider D42 = ( id$ D41 ) as (Morphism of D33);
L506: ( cod D42 ) = ( cod ( id$ D41 ) ) by L424
.= D41 by L399;
L507: ( dom D42 ) = ( dom ( id$ D41 ) ) by L417
.= D41 by L399;
L508: ( id$ D41 ) in ( Hom (C59 , C59) ) by L507 , L506;
thus L509: ( Hom (C59 , C59) ) <> ( {} ) by L508;
end;
end;
L511: (for R7 being set holds (for B42 being (Element of ( CohCat R7 )) holds (for B43 being (Element of ( CSp R7 )) holds (B42 = B43 implies (for B44 being (Morphism of B42 , B42) holds (B44 = ( id$ B43 ) implies (for B45 being (Element of ( CohCat R7 )) holds ((( Hom (B42 , B45) ) <> ( {} ) implies (for B46 being (Morphism of B42 , B45) holds ( B46 (*) B44 ) = B46)) & (( Hom (B45 , B42) ) <> ( {} ) implies (for B47 being (Morphism of B45 , B42) holds ( B44 (*) B47 ) = B47))))))))))
proof
let R7 being set;
let C60 being (Element of ( CohCat R7 ));
let C61 being (Element of ( CSp R7 ));
assume that
L512: C60 = C61;
let C62 being (Morphism of C60 , C60);
assume that
L513: C62 = ( id$ C61 );
let C63 being (Element of ( CohCat R7 ));
thus L514: (( Hom (C60 , C63) ) <> ( {} ) implies (for B48 being (Morphism of C60 , C63) holds ( B48 (*) C62 ) = B48))
proof
assume L515: ( Hom (C60 , C63) ) <> ( {} );
let C64 being (Morphism of C60 , C63);
reconsider D43 = C64 as (Element of ( MapsC R7 ));
L516: ( Hom (C60 , C60) ) <> ( {} );
L517: ( cod C62 ) = C60 by L516 , CAT_1:5
.= ( dom C64 ) by L515 , CAT_1:5;
L518: ( dom D43 ) = ( dom C64 ) by L417
.= C61 by L512 , L515 , CAT_1:5;
L519: ( cod ( id$ C61 ) ) = ( dom D43 ) by L518 , L399;
L520: [ C64 , C62 ] in ( dom (the Comp of ( CohCat R7 )) ) by L517 , CAT_1:def 6;
thus L521: ( C64 (*) C62 ) = ( (the Comp of ( CohCat R7 )) . (C64 , C62) ) by L520 , CAT_1:def 1
.= ( D43 * ( id$ C61 ) ) by L519 , L513 , L431
.= C64 by L518 , L402;
end;

thus L522: (( Hom (C63 , C60) ) <> ( {} ) implies (for B49 being (Morphism of C63 , C60) holds ( C62 (*) B49 ) = B49))
proof
assume L523: ( Hom (C63 , C60) ) <> ( {} );
let C65 being (Morphism of C63 , C60);
reconsider D44 = C65 as (Element of ( MapsC R7 ));
L524: ( Hom (C60 , C60) ) <> ( {} );
L525: ( dom C62 ) = C60 by L524 , CAT_1:5
.= ( cod C65 ) by L523 , CAT_1:5;
L526: ( cod D44 ) = ( cod C65 ) by L424
.= C61 by L512 , L523 , CAT_1:5;
L527: ( dom ( id$ C61 ) ) = ( cod D44 ) by L526 , L399;
L528: [ C62 , C65 ] in ( dom (the Comp of ( CohCat R7 )) ) by L525 , CAT_1:def 6;
thus L529: ( C62 (*) C65 ) = ( (the Comp of ( CohCat R7 )) . (C62 , C65) ) by L528 , CAT_1:def 1
.= ( ( id$ C61 ) * D44 ) by L513 , L527 , L431
.= C65 by L526 , L402;
end;

end;
registration
let R7 being set;
cluster ( CohCat R7 ) ->  with_identities;
coherence
proof
let C66 being (Element of ( CohCat R7 ));
reconsider D45 = C66 as (Element of ( CSp R7 ));
reconsider D46 = ( id$ D45 ) as (Morphism of ( CohCat R7 ));
L523: ( cod D46 ) = ( cod ( id$ D45 ) ) by L424
.= D45 by L399;
L524: ( dom D46 ) = ( dom ( id$ D45 ) ) by L417
.= D45 by L399;
L525: D46 in ( Hom (C66 , C66) ) by L524 , L523;
reconsider D47 = D46 as (Morphism of C66 , C66) by L525 , CAT_1:def 5;
take D47;
thus L526: thesis by L511;
end;
end;
begin
definition
let C67 being set;
func Toler C67 -> set means 
:L528: (for R1 being set holds (R1 in it iff R1 is (Tolerance of C67)));
existence
proof
defpred S5[ set ] means $1 is (Tolerance of C67);
consider R4 being set such that L529: (for R1 being set holds (R1 in R4 iff (R1 in ( bool [: C67 , C67 :] ) & S5[ R1 ]))) from XBOOLE_0:sch 1;
take R4;
let R1 being set;
thus L530: (R1 in R4 implies R1 is (Tolerance of C67)) by L529;
assume L531: R1 is (Tolerance of C67);
thus L532: thesis by L531 , L529;
end;
uniqueness
proof
let C68 , C69 being set;
assume that
L533: (for R1 being set holds (R1 in C68 iff R1 is (Tolerance of C67)))
and
L534: (for R1 being set holds (R1 in C69 iff R1 is (Tolerance of C67)));
L535:
now
let R1 being set;
L536:
now
assume L537: R1 in C69;
L538: R1 is (Tolerance of C67) by L537 , L534;
thus L539: R1 in C68 by L538 , L533;
end;
L540:
now
assume L541: R1 in C68;
L542: R1 is (Tolerance of C67) by L541 , L533;
thus L543: R1 in C69 by L542 , L534;
end;
thus L544: (R1 in C68 iff R1 in C69) by L540 , L536;
end;
thus L545: thesis by L535 , TARSKI:1;
end;
end;
registration
let C70 being set;
cluster ( Toler C70 ) -> non  empty;
coherence
proof
set D48 = the (Tolerance of C70);
L547: D48 in ( Toler C70 ) by L528;
thus L548: thesis by L547;
end;
end;
definition
let C71 being set;
func Toler_on_subsets C71 -> set equals 
( union { ( Toler B50 ) where B50 is (Subset of C71) : (not contradiction) } );
coherence;
end;
registration
let C72 being set;
cluster ( Toler_on_subsets C72 ) -> non  empty;
coherence
proof
set D49 = { ( Toler B51 ) where B51 is (Subset of C72) : (not contradiction) };
L551: ( {} ) c= C72 by XBOOLE_1:2;
L552: ( Toler ( {} ) ) in D49 by L551;
L553: ( {} ) in ( Toler ( {} ) ) by L528 , TOLER_1:14;
thus L554: thesis by L553 , L552 , TARSKI:def 4;
end;
end;
theorem
L556: (for R1 being set holds (for R7 being set holds (R1 in ( Toler_on_subsets R7 ) iff (ex R8 being set st (R8 c= R7 & R1 is (Tolerance of R8))))))
proof
let R1 being set;
let R7 being set;
set D50 = { ( Toler B52 ) where B52 is (Subset of R7) : (not contradiction) };
thus L557: (R1 in ( Toler_on_subsets R7 ) implies (ex R8 being set st (R8 c= R7 & R1 is (Tolerance of R8))))
proof
assume L558: R1 in ( Toler_on_subsets R7 );
consider R4 being set such that L559: R1 in R4 and L560: R4 in D50 by L558 , TARSKI:def 4;
consider C73 being (Subset of R7) such that L561: R4 = ( Toler C73 ) by L560;
take C73;
thus L562: thesis by L559 , L561 , L528;
end;

given R8 being set such that
L563: R8 c= R7
and
L564: R1 is (Tolerance of R8);

reconsider D51 = R8 as (Subset of R7) by L563;
L565: ( Toler D51 ) in D50;
L566: R1 in ( Toler D51 ) by L564 , L528;
thus L567: thesis by L566 , L565 , TARSKI:def 4;
end;
theorem
L568: (for R4 being set holds ( Total R4 ) in ( Toler R4 )) by L528;
theorem
L569: (for R7 being set holds ( {} ) in ( Toler_on_subsets R7 ))
proof
let R7 being set;
set D52 = { ( Toler B53 ) where B53 is (Subset of R7) : (not contradiction) };
L570: ( {} ) c= R7 by XBOOLE_1:2;
L571: ( Toler ( {} ) ) in D52 by L570;
L572: ( {} ) in ( Toler ( {} ) ) by L528 , TOLER_1:14;
thus L573: thesis by L572 , L571 , TARSKI:def 4;
end;
theorem
L574: (for R4 being set holds (for R7 being set holds (R4 c= R7 implies ( Total R4 ) in ( Toler_on_subsets R7 ))))
proof
let R4 being set;
let R7 being set;
set D53 = { ( Toler B54 ) where B54 is (Subset of R7) : (not contradiction) };
assume L575: R4 c= R7;
L576: ( Toler R4 ) in D53 by L575;
L577: ( Total R4 ) in ( Toler R4 ) by L528;
thus L578: thesis by L577 , L576 , TARSKI:def 4;
end;
theorem
L579: (for R4 being set holds (for R7 being set holds (R4 c= R7 implies ( id R4 ) in ( Toler_on_subsets R7 ))))
proof
let R4 being set;
let R7 being set;
set D54 = { ( Toler B55 ) where B55 is (Subset of R7) : (not contradiction) };
assume L580: R4 c= R7;
L581: ( Toler R4 ) in D54 by L580;
L582: ( id R4 ) in ( Toler R4 ) by L528;
thus L583: thesis by L582 , L581 , TARSKI:def 4;
end;
theorem
L584: (for R7 being set holds ( Total R7 ) in ( Toler_on_subsets R7 )) by L574;
theorem
L585: (for R7 being set holds ( id R7 ) in ( Toler_on_subsets R7 )) by L579;
definition
let R7 being set;
func TOL R7 -> set equals 
{ [ B56 , B57 ] where B56 is (Element of ( Toler_on_subsets R7 )) , B57 is (Subset of R7) : B56 is (Tolerance of B57) };
coherence;
end;
registration
let R7 being set;
cluster ( TOL R7 ) -> non  empty;
coherence
proof
set D55 = { [ B58 , B59 ] where B58 is (Element of ( Toler_on_subsets R7 )) , B59 is (Subset of R7) : B58 is (Tolerance of B59) };
L587:
now
reconsider D56 = ( {} ) as (Subset of R7) by XBOOLE_1:2;
reconsider D57 = ( {} ) as (Element of ( Toler_on_subsets R7 )) by L569;
take D58 = [ D57 , D56 ];
thus L588: D58 in D55 by TOLER_1:14;
end;
thus L589: thesis by L587;
end;
end;
theorem
L591: (for R7 being set holds [ ( {} ) , ( {} ) ] in ( TOL R7 ))
proof
let R7 being set;
L592: (( {} ) in ( Toler_on_subsets R7 ) & ( {} ) c= R7) by L569 , XBOOLE_1:2;
thus L593: thesis by L592 , TOLER_1:14;
end;
theorem
L594: (for R4 being set holds (for R7 being set holds (R4 c= R7 implies [ ( id R4 ) , R4 ] in ( TOL R7 ))))
proof
let R4 being set;
let R7 being set;
assume L595: R4 c= R7;
L596: ( id R4 ) in ( Toler_on_subsets R7 ) by L595 , L579;
thus L597: thesis by L596 , L595;
end;
theorem
L598: (for R4 being set holds (for R7 being set holds (R4 c= R7 implies [ ( Total R4 ) , R4 ] in ( TOL R7 ))))
proof
let R4 being set;
let R7 being set;
assume L599: R4 c= R7;
L600: ( Total R4 ) in ( Toler_on_subsets R7 ) by L599 , L574;
thus L601: thesis by L600 , L599;
end;
theorem
L602: (for R7 being set holds [ ( id R7 ) , R7 ] in ( TOL R7 )) by L594;
theorem
L603: (for R7 being set holds [ ( Total R7 ) , R7 ] in ( TOL R7 )) by L598;
definition
let R7 being set;
let R21 being (Element of ( TOL R7 ));
redefine func R21 `2 -> (Subset of R7);

coherence
proof
L604: R21 in { [ B60 , B61 ] where B60 is (Element of ( Toler_on_subsets R7 )) , B61 is (Subset of R7) : B60 is (Tolerance of B61) };
consider C74 being (Element of ( Toler_on_subsets R7 )), C75 being (Subset of R7) such that L605: (R21 = [ C74 , C75 ] & C74 is (Tolerance of C75)) by L604;
L606: ( [ C74 , C75 ] `2 ) = C75;
thus L607: thesis by L606 , L605;
end;
redefine func R21 `1 -> (Tolerance of ( R21 `2 ));

coherence
proof
L608: R21 in { [ B62 , B63 ] where B62 is (Element of ( Toler_on_subsets R7 )) , B63 is (Subset of R7) : B62 is (Tolerance of B63) };
consider C76 being (Element of ( Toler_on_subsets R7 )), C77 being (Subset of R7) such that L609: R21 = [ C76 , C77 ] and L610: C76 is (Tolerance of C77) by L608;
L611: (( [ C76 , C77 ] `2 ) = C77 & ( [ C76 , C77 ] `1 ) = C76);
thus L612: thesis by L611 , L609 , L610;
end;
end;
definition
let R7 being set;
func FuncsT R7 -> set equals 
( union { ( Funcs (( B64 `2 ) , ( B65 `2 )) ) where B64 is (Element of ( TOL R7 )) , B65 is (Element of ( TOL R7 )) : (not contradiction) } );
coherence;
end;
registration
let R7 being set;
cluster ( FuncsT R7 ) -> non  empty  functional;
coherence
proof
set D59 = { ( Funcs (( B66 `2 ) , ( B67 `2 )) ) where B66 is (Element of ( TOL R7 )) , B67 is (Element of ( TOL R7 )) : (not contradiction) };
reconsider D60 = [ ( Total ( {} R7 ) ) , ( {} R7 ) ] as (Element of ( TOL R7 )) by L598;
L615: ( [ ( Total ( {} R7 ) ) , ( {} R7 ) ] `2 ) = ( {} R7 );
L616: ( id ( {} R7 ) ) in ( Funcs (( D60 `2 ) , ( D60 `2 )) ) by L615 , FUNCT_2:9;
L617: ( Funcs (( D60 `2 ) , ( D60 `2 )) ) in D59;
reconsider D61 = ( union D59 ) as non  empty set by L617 , L616 , TARSKI:def 4;
L618:
now
let C78 being set;
assume L619: C78 in D61;
consider C79 being set such that L620: C78 in C79 and L621: C79 in D59 by L619 , TARSKI:def 4;
L622: (ex B68 , B69 being (Element of ( TOL R7 )) st C79 = ( Funcs (( B68 `2 ) , ( B69 `2 )) )) by L621;
thus L623: C78 is Function by L622 , L620;
end;
thus L624: thesis by L618 , FUNCT_1:def 13;
end;
end;
theorem
L626: (for R1 being set holds (for R7 being set holds (R1 in ( FuncsT R7 ) iff (ex R22 being (Element of ( TOL R7 )) st (ex R23 being (Element of ( TOL R7 )) st ((( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) & R1 is (Function of ( R22 `2 ) , ( R23 `2 ))))))))
proof
let R1 being set;
let R7 being set;
set D62 = { ( Funcs (( B70 `2 ) , ( B71 `2 )) ) where B70 is (Element of ( TOL R7 )) , B71 is (Element of ( TOL R7 )) : (not contradiction) };
thus L627: (R1 in ( FuncsT R7 ) implies (ex B72 , B73 being (Element of ( TOL R7 )) st ((( B73 `2 ) = ( {} ) implies ( B72 `2 ) = ( {} )) & R1 is (Function of ( B72 `2 ) , ( B73 `2 )))))
proof
assume L628: R1 in ( FuncsT R7 );
consider C80 being set such that L629: R1 in C80 and L630: C80 in D62 by L628 , TARSKI:def 4;
consider C81 , C82 being (Element of ( TOL R7 )) such that L631: C80 = ( Funcs (( C81 `2 ) , ( C82 `2 )) ) by L630;
take C81;
take C82;
thus L632: thesis by L629 , L631 , FUNCT_2:66;
end;

given C83 , C84 being (Element of ( TOL R7 )) such that
L633: ((( C84 `2 ) = ( {} ) implies ( C83 `2 ) = ( {} )) & R1 is (Function of ( C83 `2 ) , ( C84 `2 )));

L634: ( Funcs (( C83 `2 ) , ( C84 `2 )) ) in D62;
L635: R1 in ( Funcs (( C83 `2 ) , ( C84 `2 )) ) by L633 , FUNCT_2:8;
thus L636: thesis by L635 , L634 , TARSKI:def 4;
end;
definition
let R7 being set;
func MapsT R7 -> set equals 
{ [ [ B74 , B75 ] , B76 ] where B74 is (Element of ( TOL R7 )) , B75 is (Element of ( TOL R7 )) , B76 is (Element of ( FuncsT R7 )) : ((( B75 `2 ) = ( {} ) implies ( B74 `2 ) = ( {} )) & B76 is (Function of ( B74 `2 ) , ( B75 `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( B74 `1 ) implies [ ( B76 . R1 ) , ( B76 . R2 ) ] in ( B75 `1 ))))) };
coherence;
end;
registration
let R7 being set;
cluster ( MapsT R7 ) -> non  empty;
coherence
proof
set D63 = { [ [ B77 , B78 ] , B79 ] where B77 is (Element of ( TOL R7 )) , B78 is (Element of ( TOL R7 )) , B79 is (Element of ( FuncsT R7 )) : ((( B78 `2 ) = ( {} ) implies ( B77 `2 ) = ( {} )) & B79 is (Function of ( B77 `2 ) , ( B78 `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( B77 `1 ) implies [ ( B79 . R1 ) , ( B79 . R2 ) ] in ( B78 `1 ))))) };
L638:
now
set D64 = [ ( Total ( {} R7 ) ) , ( {} R7 ) ];
set D65 = ( id ( D64 `2 ) );
take D66 = [ [ D64 , D64 ] , D65 ];
reconsider D67 = D64 as (Element of ( TOL R7 )) by L598;
L639: (( D67 `2 ) = ( {} ) implies ( D67 `2 ) = ( {} ));
reconsider D68 = D65 as (Element of ( FuncsT R7 )) by L639 , L626;
L640: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( D67 `1 ) implies [ ( D68 . R1 ) , ( D68 . R2 ) ] in ( D67 `1 ))));
thus L641: D66 in D63 by L640;
end;
thus L642: thesis by L638;
end;
end;
theorem
L644: (for R7 being set holds (for R25 being (Element of ( MapsT R7 )) holds (ex R24 being (Element of ( FuncsT R7 )) st (ex R22 being (Element of ( TOL R7 )) st (ex R23 being (Element of ( TOL R7 )) st (R25 = [ [ R22 , R23 ] , R24 ] & (( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) & R24 is (Function of ( R22 `2 ) , ( R23 `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( R24 . R1 ) , ( R24 . R2 ) ] in ( R23 `1 ))))))))))
proof
let R7 being set;
let R25 being (Element of ( MapsT R7 ));
L645: R25 in { [ [ R22 , R23 ] , R24 ] where R22 is (Element of ( TOL R7 )) , R23 is (Element of ( TOL R7 )) , R24 is (Element of ( FuncsT R7 )) : ((( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) & R24 is (Function of ( R22 `2 ) , ( R23 `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( R24 . R1 ) , ( R24 . R2 ) ] in ( R23 `1 ))))) };
L646: (ex R22 being (Element of ( TOL R7 )) st (ex R23 being (Element of ( TOL R7 )) st (ex R24 being (Element of ( FuncsT R7 )) st (R25 = [ [ R22 , R23 ] , R24 ] & (( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) & R24 is (Function of ( R22 `2 ) , ( R23 `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( R24 . R1 ) , ( R24 . R2 ) ] in ( R23 `1 )))))))) by L645;
thus L647: thesis by L646;
end;
theorem
L648: (for R7 being set holds (for R22 being (Element of ( TOL R7 )) holds (for R23 being (Element of ( TOL R7 )) holds (for B80 being (Function of ( R22 `2 ) , ( R23 `2 )) holds (((( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( B80 . R1 ) , ( B80 . R2 ) ] in ( R23 `1 ))))) implies [ [ R22 , R23 ] , B80 ] in ( MapsT R7 ))))))
proof
let R7 being set;
let R22 being (Element of ( TOL R7 ));
let R23 being (Element of ( TOL R7 ));
let C85 being (Function of ( R22 `2 ) , ( R23 `2 ));
assume that
L649: (( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} ))
and
L650: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( C85 . R1 ) , ( C85 . R2 ) ] in ( R23 `1 ))));
reconsider D69 = C85 as (Element of ( FuncsT R7 )) by L649 , L626;
L651: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( D69 . R1 ) , ( D69 . R2 ) ] in ( R23 `1 )))) by L650;
thus L652: thesis by L651 , L649;
end;
registration
let C86 being set;
let C87 being (Element of ( MapsT C86 ));
cluster ( C87 `2 ) ->  Function-like  Relation-like;
coherence
proof
consider C88 being (Element of ( FuncsT C86 )), C89 , C90 being (Element of ( TOL C86 )) such that L653: (C87 = [ [ C89 , C90 ] , C88 ] & (( C90 `2 ) = ( {} ) implies ( C89 `2 ) = ( {} )) & C88 is (Function of ( C89 `2 ) , ( C90 `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( C89 `1 ) implies [ ( C88 . R1 ) , ( C88 . R2 ) ] in ( C90 `1 ))))) by L644;
L654: ( [ [ C89 , C90 ] , C88 ] `2 ) = C88;
thus L655: thesis by L654 , L653;
end;
end;
definition
let R7 being set;
let R25 being (Element of ( MapsT R7 ));
func dom R25 -> (Element of ( TOL R7 )) equals 
( ( R25 `1 ) `1 );
coherence
proof
consider R24 being (Element of ( FuncsT R7 )), R22 being (Element of ( TOL R7 )), R23 being (Element of ( TOL R7 )) such that L657: R25 = [ [ R22 , R23 ] , R24 ] and L658: (( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) and L659: R24 is (Function of ( R22 `2 ) , ( R23 `2 )) and L660: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( R24 . R1 ) , ( R24 . R2 ) ] in ( R23 `1 )))) by L644;
L661: ([ R22 , R23 ] = ( [ [ R22 , R23 ] , R24 ] `1 ) & ( [ R22 , R23 ] `1 ) = R22);
thus L662: thesis by L661 , L657;
end;
func cod R25 -> (Element of ( TOL R7 )) equals 
( ( R25 `1 ) `2 );
coherence
proof
consider C91 being (Element of ( FuncsT R7 )), R22 being (Element of ( TOL R7 )), R23 being (Element of ( TOL R7 )) such that L663: R25 = [ [ R22 , R23 ] , C91 ] and L664: (( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) and L665: C91 is (Function of ( R22 `2 ) , ( R23 `2 )) and L666: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( C91 . R1 ) , ( C91 . R2 ) ] in ( R23 `1 )))) by L644;
L667: ([ R22 , R23 ] = ( [ [ R22 , R23 ] , C91 ] `1 ) & ( [ R22 , R23 ] `2 ) = R23);
thus L668: thesis by L667 , L663;
end;
end;
theorem
L670: (for R7 being set holds (for R25 being (Element of ( MapsT R7 )) holds R25 = [ [ ( dom R25 ) , ( cod R25 ) ] , ( R25 `2 ) ]))
proof
let R7 being set;
let R25 being (Element of ( MapsT R7 ));
consider R24 being (Element of ( FuncsT R7 )), R22 being (Element of ( TOL R7 )), R23 being (Element of ( TOL R7 )) such that L671: R25 = [ [ R22 , R23 ] , R24 ] and L672: (( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) and L673: R24 is (Function of ( R22 `2 ) , ( R23 `2 )) and L674: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( R24 . R1 ) , ( R24 . R2 ) ] in ( R23 `1 )))) by L644;
L675: [ R22 , R23 ] = ( [ [ R22 , R23 ] , R24 ] `1 );
L676: ( R25 `1 ) = [ ( dom R25 ) , ( cod R25 ) ] by L675 , L671 , MCART_1:8;
thus L677: thesis by L676 , L671 , MCART_1:8;
end;
L678: (for R7 being set holds (for R25 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds ((( R25 `2 ) = ( R26 `2 ) & ( dom R25 ) = ( dom R26 ) & ( cod R25 ) = ( cod R26 )) implies R25 = R26))))
proof
let R7 being set;
let R25 being (Element of ( MapsT R7 ));
let R26 being (Element of ( MapsT R7 ));
L679: R25 = [ [ ( dom R25 ) , ( cod R25 ) ] , ( R25 `2 ) ] by L670;
thus L680: thesis by L679 , L670;
end;
definition
let R7 being set;
let R21 being (Element of ( TOL R7 ));
func id$ R21 -> (Element of ( MapsT R7 )) equals 
[ [ R21 , R21 ] , ( id ( R21 `2 ) ) ];
coherence
proof
set D70 = ( id ( R21 `2 ) );
L681:
now
let R1 being set;
let R2 being set;
assume L682: [ R1 , R2 ] in ( R21 `1 );
L683: R1 in ( R21 `2 ) by L682 , ZFMISC_1:87;
L684: ( ( id ( R21 `2 ) ) . R1 ) = R1 by L683 , FUNCT_1:18;
L685: R2 in ( R21 `2 ) by L682 , ZFMISC_1:87;
thus L686: [ ( D70 . R1 ) , ( D70 . R2 ) ] in ( R21 `1 ) by L685 , L682 , L684 , FUNCT_1:18;
end;
thus L687: thesis by L681 , L648;
end;
end;
theorem
L689: (for R7 being set holds (for R25 being (Element of ( MapsT R7 )) holds ((( ( cod R25 ) `2 ) <> ( {} ) or ( ( dom R25 ) `2 ) = ( {} )) & ( R25 `2 ) is (Function of ( ( dom R25 ) `2 ) , ( ( cod R25 ) `2 )) & (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( ( dom R25 ) `1 ) implies [ ( ( R25 `2 ) . R1 ) , ( ( R25 `2 ) . R2 ) ] in ( ( cod R25 ) `1 )))))))
proof
let R7 being set;
let R25 being (Element of ( MapsT R7 ));
consider R24 being (Element of ( FuncsT R7 )), R22 being (Element of ( TOL R7 )), R23 being (Element of ( TOL R7 )) such that L690: R25 = [ [ R22 , R23 ] , R24 ] and L691: ((( R23 `2 ) = ( {} ) implies ( R22 `2 ) = ( {} )) & R24 is (Function of ( R22 `2 ) , ( R23 `2 ))) and L692: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( R22 `1 ) implies [ ( R24 . R1 ) , ( R24 . R2 ) ] in ( R23 `1 )))) by L644;
L693: R25 = [ [ ( dom R25 ) , ( cod R25 ) ] , ( R25 `2 ) ] by L670;
L694: R23 = ( cod R25 ) by L693 , L690 , L346;
L695: (R24 = ( R25 `2 ) & R22 = ( dom R25 )) by L690 , L693 , L346 , XTUPLE_0:1;
thus L696: ((( ( cod R25 ) `2 ) <> ( {} ) or ( ( dom R25 ) `2 ) = ( {} )) & ( R25 `2 ) is (Function of ( ( dom R25 ) `2 ) , ( ( cod R25 ) `2 ))) by L695 , L690 , L691 , L693 , L346;
let R1 being set;
let R2 being set;
assume L697: [ R1 , R2 ] in ( ( dom R25 ) `1 );
thus L698: thesis by L697 , L692 , L695 , L694;
end;
definition
let R7 being set;
let R26 being (Element of ( MapsT R7 ));
let R27 being (Element of ( MapsT R7 ));
assume L699: ( cod R26 ) = ( dom R27 );
func R27 * R26 -> (Element of ( MapsT R7 )) equals 
:L700: [ [ ( dom R26 ) , ( cod R27 ) ] , ( ( R27 `2 ) * ( R26 `2 ) ) ];
coherence
proof
L701: (( ( cod R27 ) `2 ) <> ( {} ) or ( ( dom R27 ) `2 ) = ( {} )) by L689;
L702: (( ( cod R26 ) `2 ) <> ( {} ) or ( ( dom R26 ) `2 ) = ( {} )) by L689;
L703: ( R26 `2 ) is (Function of ( ( dom R26 ) `2 ) , ( ( cod R26 ) `2 )) by L689;
L704:
now
let R1 being set;
let R2 being set;
assume L705: [ R1 , R2 ] in ( ( dom R26 ) `1 );
L706: R1 in ( ( dom R26 ) `2 ) by L705 , ZFMISC_1:87;
L707: R1 in ( dom ( R26 `2 ) ) by L706 , L702 , L703 , FUNCT_2:def 1;
L708: R2 in ( ( dom R26 ) `2 ) by L705 , ZFMISC_1:87;
L709: R2 in ( dom ( R26 `2 ) ) by L708 , L702 , L703 , FUNCT_2:def 1;
L710: [ ( ( R26 `2 ) . R1 ) , ( ( R26 `2 ) . R2 ) ] in ( ( cod R26 ) `1 ) by L705 , L689;
L711: [ ( ( R27 `2 ) . ( ( R26 `2 ) . R1 ) ) , ( ( R27 `2 ) . ( ( R26 `2 ) . R2 ) ) ] in ( ( cod R27 ) `1 ) by L710 , L699 , L689;
L712: [ ( ( ( R27 `2 ) * ( R26 `2 ) ) . R1 ) , ( ( R27 `2 ) . ( ( R26 `2 ) . R2 ) ) ] in ( ( cod R27 ) `1 ) by L711 , L707 , FUNCT_1:13;
thus L713: [ ( ( ( R27 `2 ) * ( R26 `2 ) ) . R1 ) , ( ( ( R27 `2 ) * ( R26 `2 ) ) . R2 ) ] in ( ( cod R27 ) `1 ) by L712 , L709 , FUNCT_1:13;
end;
L714: ( R27 `2 ) is (Function of ( ( dom R27 ) `2 ) , ( ( cod R27 ) `2 )) by L689;
L715: ( ( R27 `2 ) * ( R26 `2 ) ) is (Function of ( ( dom R26 ) `2 ) , ( ( cod R27 ) `2 )) by L714 , L699 , L702 , L703 , FUNCT_2:13;
thus L716: thesis by L715 , L699 , L702 , L701 , L704 , L648;
end;
end;
theorem
L718: (for R7 being set holds (for R26 being (Element of ( MapsT R7 )) holds (for R27 being (Element of ( MapsT R7 )) holds (( dom R27 ) = ( cod R26 ) implies (( ( R27 * R26 ) `2 ) = ( ( R27 `2 ) * ( R26 `2 ) ) & ( dom ( R27 * R26 ) ) = ( dom R26 ) & ( cod ( R27 * R26 ) ) = ( cod R27 ))))))
proof
let R7 being set;
let R26 being (Element of ( MapsT R7 ));
let R27 being (Element of ( MapsT R7 ));
assume L719: ( dom R27 ) = ( cod R26 );
L720: [ [ ( dom R26 ) , ( cod R27 ) ] , ( ( R27 `2 ) * ( R26 `2 ) ) ] = ( R27 * R26 ) by L719 , L700
.= [ [ ( dom ( R27 * R26 ) ) , ( cod ( R27 * R26 ) ) ] , ( ( R27 * R26 ) `2 ) ] by L670;
thus L721: thesis by L720 , L346 , XTUPLE_0:1;
end;
theorem
L722: (for R7 being set holds (for R26 being (Element of ( MapsT R7 )) holds (for R27 being (Element of ( MapsT R7 )) holds (for R28 being (Element of ( MapsT R7 )) holds ((( dom R27 ) = ( cod R26 ) & ( dom R28 ) = ( cod R27 )) implies ( R28 * ( R27 * R26 ) ) = ( ( R28 * R27 ) * R26 ))))))
proof
let R7 being set;
let R26 being (Element of ( MapsT R7 ));
let R27 being (Element of ( MapsT R7 ));
let R28 being (Element of ( MapsT R7 ));
assume that
L723: ( dom R27 ) = ( cod R26 )
and
L724: ( dom R28 ) = ( cod R27 );
L725: ( cod ( R27 * R26 ) ) = ( cod R27 ) by L723 , L718;
L726: ( ( R27 * R26 ) `2 ) = ( ( R27 `2 ) * ( R26 `2 ) ) by L723 , L718;
L727: ( ( R28 * ( R27 * R26 ) ) `2 ) = ( ( R28 `2 ) * ( ( R27 `2 ) * ( R26 `2 ) ) ) by L726 , L724 , L725 , L718;
L728: ( dom ( R28 * R27 ) ) = ( dom R27 ) by L724 , L718;
L729: ( dom ( ( R28 * R27 ) * R26 ) ) = ( dom R26 ) by L728 , L723 , L718;
L730: ( dom ( R27 * R26 ) ) = ( dom R26 ) by L723 , L718;
L731: ( dom ( R28 * ( R27 * R26 ) ) ) = ( dom R26 ) by L730 , L724 , L725 , L718;
L732: ( cod ( R28 * R27 ) ) = ( cod R28 ) by L724 , L718;
L733: ( cod ( ( R28 * R27 ) * R26 ) ) = ( cod R28 ) by L732 , L723 , L728 , L718;
L734: ( ( R28 * R27 ) `2 ) = ( ( R28 `2 ) * ( R27 `2 ) ) by L724 , L718;
L735: ( ( ( R28 * R27 ) * R26 ) `2 ) = ( ( ( R28 `2 ) * ( R27 `2 ) ) * ( R26 `2 ) ) by L734 , L723 , L728 , L718;
L736: ( cod ( R28 * ( R27 * R26 ) ) ) = ( cod R28 ) by L724 , L725 , L718;
thus L737: thesis by L736 , L727 , L731 , L735 , L729 , L733 , L678 , RELAT_1:36;
end;
theorem
L738: (for R7 being set holds (for R21 being (Element of ( TOL R7 )) holds (( ( id$ R21 ) `2 ) = ( id ( R21 `2 ) ) & ( dom ( id$ R21 ) ) = R21 & ( cod ( id$ R21 ) ) = R21)))
proof
let R7 being set;
let R21 being (Element of ( TOL R7 ));
L739: [ [ ( dom ( id$ R21 ) ) , ( cod ( id$ R21 ) ) ] , ( ( id$ R21 ) `2 ) ] = [ [ R21 , R21 ] , ( id ( R21 `2 ) ) ] by L670;
thus L740: thesis by L739 , L346 , XTUPLE_0:1;
end;
theorem
L741: (for R7 being set holds (for R25 being (Element of ( MapsT R7 )) holds (( R25 * ( id$ ( dom R25 ) ) ) = R25 & ( ( id$ ( cod R25 ) ) * R25 ) = R25)))
proof
let R7 being set;
let R25 being (Element of ( MapsT R7 ));
set D71 = ( id$ ( dom R25 ) );
set D72 = ( id$ ( cod R25 ) );
L742: (( D71 `2 ) = ( id ( ( dom R25 ) `2 ) ) & ( dom D71 ) = ( dom R25 )) by L738;
L743: ( R25 `2 ) is (Function of ( ( dom R25 ) `2 ) , ( ( cod R25 ) `2 )) by L689;
L744: ( rng ( R25 `2 ) ) c= ( ( cod R25 ) `2 ) by L743 , RELAT_1:def 19;
L745: (( ( cod R25 ) `2 ) <> ( {} ) or ( ( dom R25 ) `2 ) = ( {} )) by L689;
L746: ( dom ( R25 `2 ) ) = ( ( dom R25 ) `2 ) by L745 , L743 , FUNCT_2:def 1;
L747: ( cod D71 ) = ( dom R25 ) by L738;
L748: ( cod ( R25 * D71 ) ) = ( cod R25 ) by L747 , L718;
L749: (( ( R25 * D71 ) `2 ) = ( ( R25 `2 ) * ( D71 `2 ) ) & ( dom ( R25 * D71 ) ) = ( dom D71 )) by L747 , L718;
thus L750: ( R25 * D71 ) = R25 by L749 , L746 , L742 , L748 , L678 , RELAT_1:52;
L751: (( D72 `2 ) = ( id ( ( cod R25 ) `2 ) ) & ( cod D72 ) = ( cod R25 )) by L738;
L752: ( dom D72 ) = ( cod R25 ) by L738;
L753: ( cod ( D72 * R25 ) ) = ( cod D72 ) by L752 , L718;
L754: (( ( D72 * R25 ) `2 ) = ( ( D72 `2 ) * ( R25 `2 ) ) & ( dom ( D72 * R25 ) ) = ( dom R25 )) by L752 , L718;
thus L755: thesis by L754 , L744 , L751 , L753 , L678 , RELAT_1:53;
end;
definition
let R7 being set;
func fDom R7 -> (Function of ( MapsT R7 ) , ( TOL R7 )) means 
:L756: (for R25 being (Element of ( MapsT R7 )) holds ( it . R25 ) = ( dom R25 ));
existence
proof
deffunc H3((Element of ( MapsT R7 ))) = ( dom $1 );
thus L757: (ex B81 being (Function of ( MapsT R7 ) , ( TOL R7 )) st (for B82 being (Element of ( MapsT R7 )) holds ( B81 . B82 ) = H3(B82))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C92 , C93 being (Function of ( MapsT R7 ) , ( TOL R7 ));
assume that
L758: (for R25 being (Element of ( MapsT R7 )) holds ( C92 . R25 ) = ( dom R25 ))
and
L759: (for R25 being (Element of ( MapsT R7 )) holds ( C93 . R25 ) = ( dom R25 ));
L760:
now
let R25 being (Element of ( MapsT R7 ));
thus L761: ( C92 . R25 ) = ( dom R25 ) by L758
.= ( C93 . R25 ) by L759;
end;
thus L762: thesis by L760 , FUNCT_2:63;
end;
func fCod R7 -> (Function of ( MapsT R7 ) , ( TOL R7 )) means 
:L763: (for R25 being (Element of ( MapsT R7 )) holds ( it . R25 ) = ( cod R25 ));
existence
proof
deffunc H4((Element of ( MapsT R7 ))) = ( cod $1 );
thus L764: (ex B83 being (Function of ( MapsT R7 ) , ( TOL R7 )) st (for B84 being (Element of ( MapsT R7 )) holds ( B83 . B84 ) = H4(B84))) from FUNCT_2:sch 4;
end;
uniqueness
proof
let C94 , C95 being (Function of ( MapsT R7 ) , ( TOL R7 ));
assume that
L765: (for R25 being (Element of ( MapsT R7 )) holds ( C94 . R25 ) = ( cod R25 ))
and
L766: (for R25 being (Element of ( MapsT R7 )) holds ( C95 . R25 ) = ( cod R25 ));
L767:
now
let R25 being (Element of ( MapsT R7 ));
thus L768: ( C94 . R25 ) = ( cod R25 ) by L765
.= ( C95 . R25 ) by L766;
end;
thus L769: thesis by L767 , FUNCT_2:63;
end;
func fComp R7 -> (PartFunc of [: ( MapsT R7 ) , ( MapsT R7 ) :] , ( MapsT R7 )) means 
:L770: ((for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds ([ R27 , R26 ] in ( dom it ) iff ( dom R27 ) = ( cod R26 )))) & (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds (( dom R27 ) = ( cod R26 ) implies ( it . [ R27 , R26 ] ) = ( R27 * R26 )))));
existence
proof
defpred S6[ set , set , set ] means (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds ((R27 = $1 & R26 = $2) implies (( dom R27 ) = ( cod R26 ) & $3 = ( R27 * R26 )))));
L771: (for B85 , B86 , B87 , B88 being set holds ((B85 in ( MapsT R7 ) & B86 in ( MapsT R7 ) & S6[ B85 , B86 , B87 ] & S6[ B85 , B86 , B88 ]) implies B87 = B88))
proof
let C96 , C97 , C98 , C99 being set;
assume L772: (C96 in ( MapsT R7 ) & C97 in ( MapsT R7 ));
reconsider D73 = C96 , D74 = C97 as (Element of ( MapsT R7 )) by L772;
assume that
L773: S6[ C96 , C97 , C98 ]
and
L774: S6[ C96 , C97 , C99 ];
L775: C98 = ( D73 * D74 ) by L773;
thus L776: thesis by L775 , L774;
end;
L777: (for B89 , B90 , B91 being set holds ((B89 in ( MapsT R7 ) & B90 in ( MapsT R7 ) & S6[ B89 , B90 , B91 ]) implies B91 in ( MapsT R7 )))
proof
let C100 , C101 , C102 being set;
assume L778: (C100 in ( MapsT R7 ) & C101 in ( MapsT R7 ));
reconsider D75 = C100 , D76 = C101 as (Element of ( MapsT R7 )) by L778;
assume L779: S6[ C100 , C101 , C102 ];
L780: C102 = ( D75 * D76 ) by L779;
thus L781: thesis by L780;
end;
consider C103 being (PartFunc of [: ( MapsT R7 ) , ( MapsT R7 ) :] , ( MapsT R7 )) such that L782: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( dom C103 ) iff (R1 in ( MapsT R7 ) & R2 in ( MapsT R7 ) & (ex R3 being set st S6[ R1 , R2 , R3 ]))))) and L783: (for R1 being set holds (for R2 being set holds ([ R1 , R2 ] in ( dom C103 ) implies S6[ R1 , R2 , ( C103 . (R1 , R2) ) ]))) from BINOP_1:sch 5(L777 , L771);
take C103;
thus L784: (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds ([ R27 , R26 ] in ( dom C103 ) iff ( dom R27 ) = ( cod R26 ))))
proof
let R27 being (Element of ( MapsT R7 ));
let R26 being (Element of ( MapsT R7 ));
thus L785: ([ R27 , R26 ] in ( dom C103 ) implies ( dom R27 ) = ( cod R26 ))
proof
assume L786: [ R27 , R26 ] in ( dom C103 );
L787: (ex B92 being set st S6[ R27 , R26 , B92 ]) by L786 , L782;
thus L788: thesis by L787;
end;

assume L789: ( dom R27 ) = ( cod R26 );
L790: S6[ R27 , R26 , ( R27 * R26 ) ] by L789;
thus L791: thesis by L790 , L782;
end;

let R27 being (Element of ( MapsT R7 ));
let R26 being (Element of ( MapsT R7 ));
assume L792: ( dom R27 ) = ( cod R26 );
L793: [ R27 , R26 ] in ( dom C103 ) by L792 , L784;
L794: S6[ R27 , R26 , ( C103 . (R27 , R26) ) ] by L793 , L783;
thus L795: thesis by L794;
end;
uniqueness
proof
let C104 , C105 being (PartFunc of [: ( MapsT R7 ) , ( MapsT R7 ) :] , ( MapsT R7 ));
assume that
L796: (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds ([ R27 , R26 ] in ( dom C104 ) iff ( dom R27 ) = ( cod R26 ))))
and
L797: (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds (( dom R27 ) = ( cod R26 ) implies ( C104 . [ R27 , R26 ] ) = ( R27 * R26 ))))
and
L798: (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds ([ R27 , R26 ] in ( dom C105 ) iff ( dom R27 ) = ( cod R26 ))))
and
L799: (for R27 being (Element of ( MapsT R7 )) holds (for R26 being (Element of ( MapsT R7 )) holds (( dom R27 ) = ( cod R26 ) implies ( C105 . [ R27 , R26 ] ) = ( R27 * R26 ))));
L800: ( dom C104 ) = ( dom C105 )
proof
let C106 , C107 being set;
thus L801: ([ C106 , C107 ] in ( dom C104 ) implies [ C106 , C107 ] in ( dom C105 ))
proof
assume L802: [ C106 , C107 ] in ( dom C104 );
reconsider D77 = C106 , D78 = C107 as (Element of ( MapsT R7 )) by L802 , ZFMISC_1:87;
L803: ( dom D77 ) = ( cod D78 ) by L796 , L802;
thus L804: thesis by L803 , L798;
end;

assume L805: [ C106 , C107 ] in ( dom C105 );
reconsider D79 = C106 , D80 = C107 as (Element of ( MapsT R7 )) by L805 , ZFMISC_1:87;
L806: ( dom D79 ) = ( cod D80 ) by L798 , L805;
thus L807: thesis by L806 , L796;
end;
L808:
now
let C108 being (Element of [: ( MapsT R7 ) , ( MapsT R7 ) :]);
assume that
L809: C108 in ( dom C104 );
consider C109 , C110 being (Element of ( MapsT R7 )) such that L810: C108 = [ C109 , C110 ] by DOMAIN_1:1;
L811: ( dom C109 ) = ( cod C110 ) by L796 , L809 , L810;
L812: ( C104 . [ C109 , C110 ] ) = ( C109 * C110 ) by L811 , L797;
thus L813: ( C104 . C108 ) = ( C105 . C108 ) by L812 , L799 , L810 , L811;
end;
thus L814: thesis by L808 , L800 , PARTFUN1:5;
end;
end;
definition
canceled 1;
let R7 being set;
func TolCat R7 -> non  empty non  void  strict CatStr equals 
CatStr (# ( TOL R7 ) , ( MapsT R7 ) , ( fDom R7 ) , ( fCod R7 ) , ( fComp R7 ) #);
coherence;
end;
registration
let R7 being set;
cluster ( TolCat R7 ) ->  Category-like  transitive  associative  reflexive;
coherence
proof
set D81 = ( TolCat R7 );
set D82 = ( MapsT R7 );
set D83 = ( fDom R7 );
set D84 = ( fCod R7 );
set D85 = ( fComp R7 );
thus L817: D81 is  Category-like
proof
let C111 , C112 being (Morphism of D81);
reconsider D86 = C111 , D87 = C112 as (Element of D82);
L818: (( D83 . D87 ) = ( dom D87 ) & ( D84 . D86 ) = ( cod D86 )) by L756 , L763;
thus L819: thesis by L818 , L770;
end;

thus L820: D81 is  transitive
proof
let C113 , C114 being (Morphism of D81);
assume that
L821: ( dom C114 ) = ( cod C113 );
L822: [ C114 , C113 ] in ( dom (the Comp of D81) ) by L821 , L817 , CAT_1:def 6;
L823: ( (the Comp of D81) . (C114 , C113) ) = ( C114 (*) C113 ) by L822 , CAT_1:def 1;
reconsider D88 = C113 , D89 = C114 as (Element of D82);
L824: (( D83 . D89 ) = ( dom D89 ) & ( D84 . D88 ) = ( cod D88 )) by L756 , L763;
L825: ( D85 . [ D89 , D88 ] ) = ( D89 * D88 ) by L824 , L821 , L770;
L826: (( D83 . D88 ) = ( dom D88 ) & ( D84 . D89 ) = ( cod D89 )) by L756 , L763;
L827: (( dom ( D89 * D88 ) ) = ( dom D88 ) & ( cod ( D89 * D88 ) ) = ( cod D89 )) by L821 , L824 , L718;
thus L828: thesis by L827 , L825 , L826 , L756 , L763 , L823;
end;

thus L829: D81 is  associative
proof
let C115 , C116 , C117 being (Morphism of D81);
assume that
L830: ( dom C117 ) = ( cod C116 )
and
L831: ( dom C116 ) = ( cod C115 );
reconsider D90 = C115 , D91 = C116 , D92 = C117 as (Element of D82);
L832: (( dom D92 ) = ( D83 . D92 ) & ( cod D91 ) = ( D84 . D91 )) by L756 , L763;
L833: ( dom ( D92 * D91 ) ) = ( dom D91 ) by L832 , L830 , L718;
L834: (( dom D91 ) = ( D83 . D91 ) & ( cod D90 ) = ( D84 . D90 )) by L756 , L763;
L835: ( cod ( D91 * D90 ) ) = ( dom D92 ) by L834 , L830 , L831 , L832 , L718;
L836: [ C117 , C116 ] in ( dom (the Comp of D81) ) by L830 , L817 , CAT_1:def 6;
L837: ( C117 (*) C116 ) = ( (the Comp of D81) . (C117 , C116) ) by L836 , CAT_1:def 1;
L838: [ C116 , C115 ] in ( dom (the Comp of D81) ) by L831 , L817 , CAT_1:def 6;
L839: ( C116 (*) C115 ) = ( (the Comp of D81) . (C116 , C115) ) by L838 , CAT_1:def 1;
L840: ( dom ( C117 (*) C116 ) ) = ( dom C116 ) by L820 , CAT_1:def 7 , L830;
L841: [ ( C117 (*) C116 ) , C115 ] in ( dom (the Comp of D81) ) by L840 , L817 , CAT_1:def 6 , L831;
L842: ( cod ( C116 (*) C115 ) ) = ( cod C116 ) by L820 , CAT_1:def 7 , L831;
L843: [ C117 , ( C116 (*) C115 ) ] in ( dom (the Comp of D81) ) by L842 , L817 , CAT_1:def 6 , L830;
thus L844: ( C117 (*) ( C116 (*) C115 ) ) = ( (the Comp of D81) . (C117 , ( (the Comp of D81) . (C116 , C115) )) ) by L843 , L839 , CAT_1:def 1
.= ( D85 . [ D92 , ( D91 * D90 ) ] ) by L831 , L834 , L770
.= ( D92 * ( D91 * D90 ) ) by L835 , L770
.= ( ( D92 * D91 ) * D90 ) by L830 , L831 , L832 , L834 , L722
.= ( D85 . [ ( D92 * D91 ) , D90 ] ) by L831 , L834 , L833 , L770
.= ( (the Comp of D81) . (( (the Comp of D81) . (C117 , C116) ) , C115) ) by L830 , L832 , L770
.= ( ( C117 (*) C116 ) (*) C115 ) by L837 , L841 , CAT_1:def 1;
end;

let C118 being (Object of D81);
reconsider D93 = C118 as (Element of ( TOL R7 ));
reconsider D94 = ( id$ D93 ) as (Morphism of D81);
L845: ( cod D94 ) = ( cod ( id$ D93 ) ) by L763
.= D93 by L738;
L846: ( dom D94 ) = ( dom ( id$ D93 ) ) by L756
.= D93 by L738;
L847: ( id$ D93 ) in ( Hom (C118 , C118) ) by L846 , L845;
thus L848: ( Hom (C118 , C118) ) <> ( {} ) by L847;
end;
end;
L850: (for R7 being set holds (for B93 being (Element of ( TolCat R7 )) holds (for B94 being (Element of ( TOL R7 )) holds (B93 = B94 implies (for B95 being (Morphism of B93 , B93) holds (B95 = ( id$ B94 ) implies (for B96 being (Element of ( TolCat R7 )) holds ((( Hom (B93 , B96) ) <> ( {} ) implies (for B97 being (Morphism of B93 , B96) holds ( B97 (*) B95 ) = B97)) & (( Hom (B96 , B93) ) <> ( {} ) implies (for B98 being (Morphism of B96 , B93) holds ( B95 (*) B98 ) = B98))))))))))
proof
let R7 being set;
let C119 being (Element of ( TolCat R7 ));
let C120 being (Element of ( TOL R7 ));
assume that
L851: C119 = C120;
let C121 being (Morphism of C119 , C119);
assume that
L852: C121 = ( id$ C120 );
let C122 being (Element of ( TolCat R7 ));
thus L853: (( Hom (C119 , C122) ) <> ( {} ) implies (for B99 being (Morphism of C119 , C122) holds ( B99 (*) C121 ) = B99))
proof
assume L854: ( Hom (C119 , C122) ) <> ( {} );
let C123 being (Morphism of C119 , C122);
reconsider D95 = C123 as (Element of ( MapsT R7 ));
L855: ( Hom (C119 , C119) ) <> ( {} );
L856: ( cod C121 ) = C119 by L855 , CAT_1:5
.= ( dom C123 ) by L854 , CAT_1:5;
L857: ( dom D95 ) = ( dom C123 ) by L756
.= C120 by L851 , L854 , CAT_1:5;
L858: ( cod ( id$ C120 ) ) = ( dom D95 ) by L857 , L738;
L859: [ C123 , C121 ] in ( dom (the Comp of ( TolCat R7 )) ) by L856 , CAT_1:def 6;
thus L860: ( C123 (*) C121 ) = ( (the Comp of ( TolCat R7 )) . (C123 , C121) ) by L859 , CAT_1:def 1
.= ( D95 * ( id$ C120 ) ) by L858 , L852 , L770
.= C123 by L857 , L741;
end;

thus L861: (( Hom (C122 , C119) ) <> ( {} ) implies (for B100 being (Morphism of C122 , C119) holds ( C121 (*) B100 ) = B100))
proof
assume L862: ( Hom (C122 , C119) ) <> ( {} );
let C124 being (Morphism of C122 , C119);
reconsider D96 = C124 as (Element of ( MapsT R7 ));
L863: ( Hom (C119 , C119) ) <> ( {} );
L864: ( dom C121 ) = C119 by L863 , CAT_1:5
.= ( cod C124 ) by L862 , CAT_1:5;
L865: ( cod D96 ) = ( cod C124 ) by L763
.= C120 by L851 , L862 , CAT_1:5;
L866: ( dom ( id$ C120 ) ) = ( cod D96 ) by L865 , L738;
L867: [ C121 , C124 ] in ( dom (the Comp of ( TolCat R7 )) ) by L864 , CAT_1:def 6;
thus L868: ( C121 (*) C124 ) = ( (the Comp of ( TolCat R7 )) . (C121 , C124) ) by L867 , CAT_1:def 1
.= ( ( id$ C120 ) * D96 ) by L852 , L866 , L770
.= C124 by L865 , L741;
end;

end;
registration
let R7 being set;
cluster ( TolCat R7 ) ->  with_identities;
coherence
proof
let C125 being (Element of ( TolCat R7 ));
reconsider D97 = C125 as (Element of ( TOL R7 ));
reconsider D98 = ( id$ D97 ) as (Morphism of ( TolCat R7 ));
L862: ( cod D98 ) = ( cod ( id$ D97 ) ) by L763
.= D97 by L738;
L863: ( dom D98 ) = ( dom ( id$ D97 ) ) by L756
.= D97 by L738;
L864: D98 in ( Hom (C125 , C125) ) by L863 , L862;
reconsider D99 = D98 as (Morphism of C125 , C125) by L864 , CAT_1:def 5;
take D99;
thus L865: thesis by L850;
end;
end;
