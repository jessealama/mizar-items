:: Comma Category
::  by Grzegorz Bancerek and Agata Darmochwa\l
::
:: Received February 20, 1992
:: Copyright (c) 1992-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies CAT_1, STRUCT_0, FUNCT_1, XBOOLE_0, SUBSET_1, ZFMISC_1, TARSKI,
      MCART_1, RELAT_1, GRAPH_1, PARTFUN1, CAT_2, FUNCOP_1, FUNCT_3, COMMACAT,
      MONOID_0, RELAT_2, BINOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, BINOP_1, FUNCOP_1, STRUCT_0, GRAPH_1, CAT_1, CAT_2, MCART_1,
      DOMAIN_1;
 constructors DOMAIN_1, CAT_2, FUNCOP_1, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, CAT_1, CAT_2, STRUCT_0, XTUPLE_0;
 requirements SUBSET, BOOLE;
 definitions TARSKI, XBOOLE_0, CAT_1, BINOP_1, FUNCOP_1, GRAPH_1;
 theorems TARSKI, ZFMISC_1, MCART_1, FUNCT_1, FUNCT_2, CAT_1, CAT_2, GRFUNC_1,
      RELSET_1, FUNCOP_1, XTUPLE_0;
 schemes FUNCT_2, CLASSES1;

begin
deffunc H1(CatStr) = (the carrier of $1);
deffunc H2(CatStr) = (the carrier' of $1);
definition
let R2 being Category;
let R3 being Category;
let R4 being Category;
let C1 being (Functor of R2 , R4);
let C2 being (Functor of R3 , R4);
given R6 being (Object of R2) , R9 being (Object of R3) , R12 being (Morphism of R4) such that
L1: R12 in ( Hom (( C1 . R6 ) , ( C2 . R9 )) );

func commaObjs (C1 , C2) -> non  empty (Subset of [: [: (the carrier of R2) , (the carrier of R3) :] , (the carrier' of R4) :]) equals 
:L2: { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( C1 . R5 ) , ( C2 . R8 )) ) };
coherence
proof
L3: { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( C1 . R5 ) , ( C2 . R8 )) ) } c= [: [: (the carrier of R2) , (the carrier of R3) :] , (the carrier' of R4) :]
proof
let R10 being set;
assume L4: R10 in { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( C1 . R5 ) , ( C2 . R8 )) ) };
L5: (ex R5 being (Object of R2) st (ex R8 being (Object of R3) st (ex R11 being (Morphism of R4) st (R10 = [ [ R5 , R8 ] , R11 ] & R11 in ( Hom (( C1 . R5 ) , ( C2 . R8 )) ))))) by L4;
thus L6: thesis by L5;
end;
L7: [ [ R6 , R9 ] , R12 ] in { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( C1 . R5 ) , ( C2 . R8 )) ) } by L1;
thus L8: thesis by L7 , L3;
end;
end;
theorem
L10: (for R2 being Category holds (for R3 being Category holds (for R4 being Category holds (for R17 being (Functor of R2 , R4) holds (for R18 being (Functor of R3 , R4) holds (for R19 being (Element of ( commaObjs (R17 , R18) )) holds ((ex R5 being (Object of R2) st (ex R8 being (Object of R3) st (ex R11 being (Morphism of R4) st R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) )))) implies (R19 = [ [ ( R19 `11 ) , ( R19 `12 ) ] , ( R19 `2 ) ] & ( R19 `2 ) in ( Hom (( R17 . ( R19 `11 ) ) , ( R18 . ( R19 `12 ) )) ) & ( dom ( R19 `2 ) ) = ( R17 . ( R19 `11 ) ) & ( cod ( R19 `2 ) ) = ( R18 . ( R19 `12 ) )))))))))
proof
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
let R19 being (Element of ( commaObjs (R17 , R18) ));
assume L11: (ex R5 being (Object of R2) st (ex R8 being (Object of R3) st (ex R11 being (Morphism of R4) st R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ))));
L12: ( commaObjs (R17 , R18) ) = { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) } by L11 , L2;
L13: R19 in ( commaObjs (R17 , R18) );
consider R5 being (Object of R2), R8 being (Object of R3), R11 being (Morphism of R4) such that L14: R19 = [ [ R5 , R8 ] , R11 ] and L15: R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) by L13 , L12;
L16: ( R19 `2 ) = R11 by L14 , MCART_1:7;
L17: (( R19 `11 ) = R5 & ( R19 `12 ) = R8) by L14 , MCART_1:85;
thus L18: thesis by L17 , L14 , L15 , L16 , CAT_1:1;
end;
definition
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
given R6 being (Object of R2) , R9 being (Object of R3) , R12 being (Morphism of R4) such that
L19: R12 in ( Hom (( R17 . R6 ) , ( R18 . R9 )) );

func commaMorphs (R17 , R18) -> non  empty (Subset of [: [: ( commaObjs (R17 , R18) ) , ( commaObjs (R17 , R18) ) :] , [: (the carrier' of R2) , (the carrier' of R3) :] :]) equals 
:L20: { [ [ R20 , R21 ] , [ R13 , R15 ] ] where R13 is (Morphism of R2) , R15 is (Morphism of R3) , R20 is (Element of ( commaObjs (R17 , R18) )) , R21 is (Element of ( commaObjs (R17 , R18) )) : (( dom R13 ) = ( R20 `11 ) & ( cod R13 ) = ( R21 `11 ) & ( dom R15 ) = ( R20 `12 ) & ( cod R15 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R13 ) ) = ( ( R18 . R15 ) (*) ( R20 `2 ) )) };
coherence
proof
L21: ( commaObjs (R17 , R18) ) = { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) } by L19 , L2;
L22: [ [ R6 , R9 ] , R12 ] in ( commaObjs (R17 , R18) ) by L21 , L19;
reconsider D1 = [ [ R6 , R9 ] , R12 ] as (Element of ( commaObjs (R17 , R18) )) by L22;
set D2 = { [ [ R20 , R21 ] , [ R13 , R15 ] ] where R13 is (Morphism of R2) , R15 is (Morphism of R3) , R20 is (Element of ( commaObjs (R17 , R18) )) , R21 is (Element of ( commaObjs (R17 , R18) )) : (( dom R13 ) = ( R20 `11 ) & ( cod R13 ) = ( R21 `11 ) & ( dom R15 ) = ( R20 `12 ) & ( cod R15 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R13 ) ) = ( ( R18 . R15 ) (*) ( R20 `2 ) )) };
L23: (( dom ( id R9 ) ) = R9 & ( cod ( id R9 ) ) = R9);
L24: (( ( D1 `1 ) `1 ) = ( D1 `11 ) & ( ( D1 `1 ) `2 ) = ( D1 `12 )) by MCART_1:def 14 , MCART_1:def 15;
L25: D2 c= [: [: ( commaObjs (R17 , R18) ) , ( commaObjs (R17 , R18) ) :] , [: (the carrier' of R2) , (the carrier' of R3) :] :]
proof
let R10 being set;
assume L26: R10 in D2;
L27: (ex R13 being (Morphism of R2) st (ex R15 being (Morphism of R3) st (ex R20 being (Element of ( commaObjs (R17 , R18) )) st (ex R21 being (Element of ( commaObjs (R17 , R18) )) st (R10 = [ [ R20 , R21 ] , [ R13 , R15 ] ] & ( dom R13 ) = ( R20 `11 ) & ( cod R13 ) = ( R21 `11 ) & ( dom R15 ) = ( R20 `12 ) & ( cod R15 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R13 ) ) = ( ( R18 . R15 ) (*) ( R20 `2 ) )))))) by L26;
thus L28: thesis by L27;
end;
L29: (( [ R6 , R9 ] `2 ) = R9 & ( D1 `2 ) = R12) by MCART_1:7;
L30: (( D1 `1 ) = [ R6 , R9 ] & ( [ R6 , R9 ] `1 ) = R6) by MCART_1:7;
L31: ( cod R12 ) = ( R18 . R9 ) by L19 , CAT_1:1;
L32: ( ( id ( R18 . R9 ) ) (*) R12 ) = R12 by L31 , CAT_1:21;
L33: ( dom R12 ) = ( R17 . R6 ) by L19 , CAT_1:1;
L34: ( R12 (*) ( id ( R17 . R6 ) ) ) = R12 by L33 , CAT_1:22;
L35: (( R17 . ( id R6 ) ) = ( id ( R17 . R6 ) ) & ( R18 . ( id R9 ) ) = ( id ( R18 . R9 ) )) by CAT_1:71;
L36: (( dom ( id R6 ) ) = R6 & ( cod ( id R6 ) ) = R6);
L37: [ [ D1 , D1 ] , [ ( id R6 ) , ( id R9 ) ] ] in D2 by L36 , L23 , L24 , L30 , L29 , L34 , L32 , L35;
thus L38: thesis by L37 , L25;
end;
end;
definition
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
let R22 being (Element of ( commaMorphs (R17 , R18) ));
redefine func R22 `11 -> (Element of ( commaObjs (R17 , R18) ));

coherence
proof
thus L40: ( R22 `11 ) is (Element of ( commaObjs (R17 , R18) ));
end;
redefine func R22 `12 -> (Element of ( commaObjs (R17 , R18) ));

coherence
proof
thus L41: ( R22 `12 ) is (Element of ( commaObjs (R17 , R18) ));
end;
end;
theorem
L43: (for R2 being Category holds (for R3 being Category holds (for R4 being Category holds (for R17 being (Functor of R2 , R4) holds (for R18 being (Functor of R3 , R4) holds (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ((ex R5 being (Object of R2) st (ex R8 being (Object of R3) st (ex R11 being (Morphism of R4) st R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) )))) implies (R22 = [ [ ( R22 `11 ) , ( R22 `12 ) ] , [ ( R22 `21 ) , ( R22 `22 ) ] ] & ( dom ( R22 `21 ) ) = ( ( R22 `11 ) `11 ) & ( cod ( R22 `21 ) ) = ( ( R22 `12 ) `11 ) & ( dom ( R22 `22 ) ) = ( ( R22 `11 ) `12 ) & ( cod ( R22 `22 ) ) = ( ( R22 `12 ) `12 ) & ( ( ( R22 `12 ) `2 ) (*) ( R17 . ( R22 `21 ) ) ) = ( ( R18 . ( R22 `22 ) ) (*) ( ( R22 `11 ) `2 ) )))))))))
proof
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
let R22 being (Element of ( commaMorphs (R17 , R18) ));
assume L44: (ex R5 being (Object of R2) st (ex R8 being (Object of R3) st (ex R11 being (Morphism of R4) st R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ))));
L45: ( commaMorphs (R17 , R18) ) = { [ [ R20 , R21 ] , [ R13 , R15 ] ] where R13 is (Morphism of R2) , R15 is (Morphism of R3) , R20 is (Element of ( commaObjs (R17 , R18) )) , R21 is (Element of ( commaObjs (R17 , R18) )) : (( dom R13 ) = ( R20 `11 ) & ( cod R13 ) = ( R21 `11 ) & ( dom R15 ) = ( R20 `12 ) & ( cod R15 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R13 ) ) = ( ( R18 . R15 ) (*) ( R20 `2 ) )) } by L44 , L20;
L46: R22 in ( commaMorphs (R17 , R18) );
consider R13 being (Morphism of R2), R15 being (Morphism of R3), R20 being (Element of ( commaObjs (R17 , R18) )), R21 being (Element of ( commaObjs (R17 , R18) )) such that L47: R22 = [ [ R20 , R21 ] , [ R13 , R15 ] ] and L48: (( dom R13 ) = ( R20 `11 ) & ( cod R13 ) = ( R21 `11 ) & ( dom R15 ) = ( R20 `12 ) & ( cod R15 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R13 ) ) = ( ( R18 . R15 ) (*) ( R20 `2 ) )) by L46 , L45;
L49: ( R22 `21 ) = R13 by L47 , MCART_1:85;
L50: (( R22 `11 ) = R20 & ( R22 `12 ) = R21) by L47 , MCART_1:85;
thus L51: thesis by L50 , L47 , L48 , L49 , MCART_1:85;
end;
definition
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
let R23 being (Element of ( commaMorphs (R17 , R18) ));
let R24 being (Element of ( commaMorphs (R17 , R18) ));
given R6 being (Object of R2) , R9 being (Object of R3) , R12 being (Morphism of R4) such that
L52: R12 in ( Hom (( R17 . R6 ) , ( R18 . R9 )) );

assume L53: ( R23 `12 ) = ( R24 `11 );
func R24 * R23 -> (Element of ( commaMorphs (R17 , R18) )) equals 
:L54: [ [ ( R23 `11 ) , ( R24 `12 ) ] , [ ( ( R24 `21 ) (*) ( R23 `21 ) ) , ( ( R24 `22 ) (*) ( R23 `22 ) ) ] ];
coherence
proof
set D3 = ( ( R24 `22 ) (*) ( R23 `22 ) );
set D4 = ( ( R24 `21 ) (*) ( R23 `21 ) );
L55: (( R17 . ( cod ( R24 `21 ) ) ) = ( cod ( R17 . ( R24 `21 ) ) ) & ( dom ( R17 . ( R24 `21 ) ) ) = ( R17 . ( dom ( R24 `21 ) ) )) by CAT_1:72;
L56: ( cod ( R17 . ( R23 `21 ) ) ) = ( R17 . ( cod ( R23 `21 ) ) ) by CAT_1:72;
L57: ( cod ( ( R23 `12 ) `2 ) ) = ( R18 . ( ( R23 `12 ) `12 ) ) by L52 , L10;
L58: ( dom ( R23 `22 ) ) = ( ( R23 `11 ) `12 ) by L52 , L43;
L59: (( ( ( R24 `12 ) `2 ) (*) ( R17 . ( R24 `21 ) ) ) = ( ( R18 . ( R24 `22 ) ) (*) ( ( R24 `11 ) `2 ) ) & ( dom ( ( R24 `12 ) `2 ) ) = ( R17 . ( ( R24 `12 ) `11 ) )) by L52 , L10 , L43;
L60: ( cod ( R18 . ( R23 `22 ) ) ) = ( R18 . ( cod ( R23 `22 ) ) ) by CAT_1:72;
L61: (( ( ( R23 `12 ) `2 ) (*) ( R17 . ( R23 `21 ) ) ) = ( ( R18 . ( R23 `22 ) ) (*) ( ( R23 `11 ) `2 ) ) & ( dom ( ( R23 `12 ) `2 ) ) = ( R17 . ( ( R23 `12 ) `11 ) )) by L52 , L10 , L43;
L62: ( dom ( R18 . ( R24 `22 ) ) ) = ( R18 . ( dom ( R24 `22 ) ) ) by CAT_1:72;
L63: (( cod ( ( R23 `11 ) `2 ) ) = ( R18 . ( ( R23 `11 ) `12 ) ) & ( dom ( R18 . ( R23 `22 ) ) ) = ( R18 . ( dom ( R23 `22 ) ) )) by L52 , L10 , CAT_1:72;
L64: ( cod ( R24 `21 ) ) = ( ( R24 `12 ) `11 ) by L52 , L43;
L65: ( commaMorphs (R17 , R18) ) = { [ [ R20 , R21 ] , [ R13 , R15 ] ] where R13 is (Morphism of R2) , R15 is (Morphism of R3) , R20 is (Element of ( commaObjs (R17 , R18) )) , R21 is (Element of ( commaObjs (R17 , R18) )) : (( dom R13 ) = ( R20 `11 ) & ( cod R13 ) = ( R21 `11 ) & ( dom R15 ) = ( R20 `12 ) & ( cod R15 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R13 ) ) = ( ( R18 . R15 ) (*) ( R20 `2 ) )) } by L52 , L20;
L66: ( dom ( R24 `22 ) ) = ( ( R24 `11 ) `12 ) by L52 , L43;
L67: ( cod ( R23 `22 ) ) = ( ( R23 `12 ) `12 ) by L52 , L43;
L68: (( dom D3 ) = ( dom ( R23 `22 ) ) & ( cod D3 ) = ( cod ( R24 `22 ) )) by L67 , L53 , L66 , CAT_1:17;
L69: (( dom ( R23 `21 ) ) = ( ( R23 `11 ) `11 ) & ( cod ( R24 `22 ) ) = ( ( R24 `12 ) `12 )) by L52 , L43;
L70: ( cod ( R23 `21 ) ) = ( ( R23 `12 ) `11 ) by L52 , L43;
L71: ( dom ( R24 `21 ) ) = ( ( R24 `11 ) `11 ) by L52 , L43;
L72: (( dom D4 ) = ( dom ( R23 `21 ) ) & ( cod D4 ) = ( cod ( R24 `21 ) )) by L71 , L53 , L70 , CAT_1:17;
L73: ( ( ( R24 `12 ) `2 ) (*) ( R17 . D4 ) ) = ( ( ( R24 `12 ) `2 ) (*) ( ( R17 . ( R24 `21 ) ) (*) ( R17 . ( R23 `21 ) ) ) ) by L53 , L70 , L71 , CAT_1:64
.= ( ( ( R18 . ( R24 `22 ) ) (*) ( ( R24 `11 ) `2 ) ) (*) ( R17 . ( R23 `21 ) ) ) by L53 , L70 , L71 , L64 , L59 , L55 , L56 , CAT_1:18
.= ( ( R18 . ( R24 `22 ) ) (*) ( ( R18 . ( R23 `22 ) ) (*) ( ( R23 `11 ) `2 ) ) ) by L53 , L70 , L66 , L61 , L57 , L56 , L62 , CAT_1:18
.= ( ( ( R18 . ( R24 `22 ) ) (*) ( R18 . ( R23 `22 ) ) ) (*) ( ( R23 `11 ) `2 ) ) by L53 , L58 , L67 , L66 , L62 , L63 , L60 , CAT_1:18
.= ( ( R18 . D3 ) (*) ( ( R23 `11 ) `2 ) ) by L53 , L67 , L66 , CAT_1:64;
L74: [ [ ( R23 `11 ) , ( R24 `12 ) ] , [ ( ( R24 `21 ) (*) ( R23 `21 ) ) , ( ( R24 `22 ) (*) ( R23 `22 ) ) ] ] in ( commaMorphs (R17 , R18) ) by L73 , L58 , L64 , L69 , L65 , L72 , L68;
thus L75: thesis by L74;
end;
end;
definition
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
func commaComp (R17 , R18) -> (PartFunc of [: ( commaMorphs (R17 , R18) ) , ( commaMorphs (R17 , R18) ) :] , ( commaMorphs (R17 , R18) )) means 
:L77: (( dom it ) = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) } & (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds (for R25 being (Element of ( commaMorphs (R17 , R18) )) holds ([ R22 , R25 ] in ( dom it ) implies ( it . [ R22 , R25 ] ) = ( R22 * R25 )))));
existence
proof
defpred S1[ set , set ] means (ex R23 being (Element of ( commaMorphs (R17 , R18) )) st (ex R24 being (Element of ( commaMorphs (R17 , R18) )) st ($1 = [ R23 , R24 ] & $2 = ( R23 * R24 ))));
set D5 = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) };
L78: (for R10 being set holds (R10 in D5 implies (ex R1 being set st S1[ R10 , R1 ])))
proof
let R10 being set;
assume L79: R10 in D5;
consider R23 being (Element of ( commaMorphs (R17 , R18) )), R24 being (Element of ( commaMorphs (R17 , R18) )) such that L80: R10 = [ R23 , R24 ] and L81: ( R23 `11 ) = ( R24 `12 ) by L79;
reconsider D6 = ( R23 * R24 ) as set;
take D6;
take R23;
take R24;
thus L82: thesis by L80;
end;
consider C3 being Function such that L83: (( dom C3 ) = D5 & (for R10 being set holds (R10 in D5 implies S1[ R10 , ( C3 . R10 ) ]))) from CLASSES1:sch 1(L78);
L84: ( rng C3 ) c= ( commaMorphs (R17 , R18) )
proof
let R10 being set;
assume L85: R10 in ( rng C3 );
consider R1 being set such that L86: R1 in ( dom C3 ) and L87: R10 = ( C3 . R1 ) by L85 , FUNCT_1:def 3;
L88: (ex R23 being (Element of ( commaMorphs (R17 , R18) )) st (ex R24 being (Element of ( commaMorphs (R17 , R18) )) st (R1 = [ R23 , R24 ] & ( C3 . R1 ) = ( R23 * R24 )))) by L83 , L86;
thus L89: thesis by L88 , L87;
end;
L90: ( dom C3 ) c= [: ( commaMorphs (R17 , R18) ) , ( commaMorphs (R17 , R18) ) :]
proof
let R10 being set;
assume L91: R10 in ( dom C3 );
L92: (ex R23 being (Element of ( commaMorphs (R17 , R18) )) st (ex R24 being (Element of ( commaMorphs (R17 , R18) )) st (R10 = [ R23 , R24 ] & ( R23 `11 ) = ( R24 `12 )))) by L91 , L83;
thus L93: thesis by L92;
end;
reconsider D7 = C3 as (PartFunc of [: ( commaMorphs (R17 , R18) ) , ( commaMorphs (R17 , R18) ) :] , ( commaMorphs (R17 , R18) )) by L90 , L84 , RELSET_1:4;
take D7;
thus L94: ( dom D7 ) = D5 by L83;
let R23 being (Element of ( commaMorphs (R17 , R18) ));
let R24 being (Element of ( commaMorphs (R17 , R18) ));
assume L95: [ R23 , R24 ] in ( dom D7 );
consider R22 being (Element of ( commaMorphs (R17 , R18) )), R25 being (Element of ( commaMorphs (R17 , R18) )) such that L96: [ R23 , R24 ] = [ R22 , R25 ] and L97: ( D7 . [ R23 , R24 ] ) = ( R22 * R25 ) by L95 , L83;
L98: R23 = R22 by L96 , XTUPLE_0:1;
thus L99: thesis by L98 , L96 , L97 , XTUPLE_0:1;
end;
uniqueness
proof
let C4 , C5 being (PartFunc of [: ( commaMorphs (R17 , R18) ) , ( commaMorphs (R17 , R18) ) :] , ( commaMorphs (R17 , R18) ));
assume that
L100: (( dom C4 ) = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) } & (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds (for R25 being (Element of ( commaMorphs (R17 , R18) )) holds ([ R22 , R25 ] in ( dom C4 ) implies ( C4 . [ R22 , R25 ] ) = ( R22 * R25 )))))
and
L101: (( dom C5 ) = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) } & (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds (for R25 being (Element of ( commaMorphs (R17 , R18) )) holds ([ R22 , R25 ] in ( dom C5 ) implies ( C5 . [ R22 , R25 ] ) = ( R22 * R25 )))));
L102:
now
let R10 being set;
assume L103: R10 in { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) };
consider R23 being (Element of ( commaMorphs (R17 , R18) )), R24 being (Element of ( commaMorphs (R17 , R18) )) such that L104: R10 = [ R23 , R24 ] and L105: ( R23 `11 ) = ( R24 `12 ) by L103;
thus L106: ( C4 . R10 ) = ( R23 * R24 ) by L100 , L103 , L104
.= ( C5 . R10 ) by L101 , L103 , L104;
end;
thus L107: thesis by L102 , L100 , L101 , FUNCT_1:2;
end;
end;
definition
let R2 being Category;
let R3 being Category;
let R4 being Category;
let R17 being (Functor of R2 , R4);
let R18 being (Functor of R3 , R4);
given R6 being (Object of R2) , R9 being (Object of R3) , R12 being (Morphism of R4) such that
L109: R12 in ( Hom (( R17 . R6 ) , ( R18 . R9 )) );

func R17 comma R18 ->  strict Category means 
((the carrier of it) = ( commaObjs (R17 , R18) ) & (the carrier' of it) = ( commaMorphs (R17 , R18) ) & (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( (the Source of it) . R22 ) = ( R22 `11 )) & (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( (the Target of it) . R22 ) = ( R22 `12 )) & (the Comp of it) = ( commaComp (R17 , R18) ));
existence
proof
reconsider D8 = ( commaObjs (R17 , R18) ) , D9 = ( commaMorphs (R17 , R18) ) as non  empty set;
defpred S2[ (Element of ( commaObjs (R17 , R18) )) , set ] means $2 = [ [ $1 , $1 ] , [ ( id ( $1 `11 ) ) , ( id ( $1 `12 ) ) ] ];
deffunc H3((Element of ( commaMorphs (R17 , R18) ))) = ( $1 `12 );
deffunc H4((Element of ( commaMorphs (R17 , R18) ))) = ( $1 `11 );
consider C6 being (Function of ( commaMorphs (R17 , R18) ) , ( commaObjs (R17 , R18) )) such that L110: (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( C6 . R22 ) = H4(R22)) from FUNCT_2:sch 4;
set D10 = the (Function of ( commaObjs (R17 , R18) ) , ( commaMorphs (R17 , R18) ));
reconsider D11 = D10 as (Function of D8 , D9);
reconsider D12 = ( commaComp (R17 , R18) ) as (PartFunc of [: D9 , D9 :] , D9);
consider C7 being (Function of ( commaMorphs (R17 , R18) ) , ( commaObjs (R17 , R18) )) such that L111: (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( C7 . R22 ) = H3(R22)) from FUNCT_2:sch 4;
reconsider D13 = C6 , D14 = C7 as (Function of D9 , D8);
set D15 = CatStr (# D8 , D9 , D13 , D14 , D12 #);
L112: ( dom (the Comp of D15) ) = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) } by L77;
L113: (for B1 , B2 being (Morphism of D15) holds (for R23 being (Element of ( commaMorphs (R17 , R18) )) holds (for R24 being (Element of ( commaMorphs (R17 , R18) )) holds ((B1 = R23 & B2 = R24 & ( dom B2 ) = ( cod B1 )) implies ( B2 (*) B1 ) = [ [ ( R23 `11 ) , ( R24 `12 ) ] , [ ( ( R24 `21 ) (*) ( R23 `21 ) ) , ( ( R24 `22 ) (*) ( R23 `22 ) ) ] ]))))
proof
let C8 , C9 being (Morphism of D15);
let R23 being (Element of ( commaMorphs (R17 , R18) ));
let R24 being (Element of ( commaMorphs (R17 , R18) ));
assume that
L114: (C8 = R23 & C9 = R24)
and
L115: ( dom C9 ) = ( cod C8 );
L116: (( dom C9 ) = ( R24 `11 ) & ( cod C8 ) = ( R23 `12 )) by L110 , L111 , L114;
L117: [ R24 , R23 ] in ( dom D12 ) by L116 , L112 , L115;
L118: ( D12 . (R24 , R23) ) = ( R24 * R23 ) by L117 , L77;
L119: ( C9 (*) C8 ) = ( D12 . (C9 , C8) ) by L114 , L117 , CAT_1:def 1;
thus L120: thesis by L119 , L109 , L114 , L115 , L116 , L118 , L54;
end;
L121: (for B3 being (Element of D15) holds ( Hom (B3 , B3) ) <> ( {} ))
proof
let C10 being (Element of D15);
reconsider D16 = C10 as (Element of ( commaObjs (R17 , R18) ));
set D17 = [ [ D16 , D16 ] , [ ( id ( D16 `11 ) ) , ( id ( D16 `12 ) ) ] ];
reconsider D18 = ( id ( D16 `11 ) ) as (Morphism of R2);
reconsider D19 = ( id ( D16 `12 ) ) as (Morphism of R3);
L122: ( dom D18 ) = ( D16 `11 ) by CAT_1:58;
L123: ( cod D18 ) = ( D16 `11 ) by CAT_1:58;
L124: ( dom D19 ) = ( D16 `12 ) by CAT_1:58;
L125: ( cod D19 ) = ( D16 `12 ) by CAT_1:58;
L126: D16 in ( commaObjs (R17 , R18) );
L127: D16 in { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) } by L126 , L109 , L2;
consider R5 being (Object of R2), R8 being (Object of R3), R11 being (Morphism of R4) such that L128: D16 = [ [ R5 , R8 ] , R11 ] and L129: R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) by L127;
L130: ( R17 . D18 ) = ( id ( R17 . ( D16 `11 ) ) ) by CAT_1:71;
L131: ( R18 . D19 ) = ( id ( R18 . ( D16 `12 ) ) ) by CAT_1:71;
L132: ( [ [ R5 , R8 ] , R11 ] `2 ) = R11;
L133: R5 = ( D16 `11 ) by L128 , MCART_1:85;
L134: R8 = ( D16 `12 ) by L128 , MCART_1:85;
L135: ( cod ( D16 `2 ) ) = ( cod R11 ) by L132 , L128
.= ( R18 . R8 ) by L129 , CAT_1:1
.= ( R18 . ( D16 `12 ) ) by L134;
L136: ( dom ( D16 `2 ) ) = ( R17 . R5 ) by L128 , L129 , CAT_1:1 , L132
.= ( R17 . ( D16 `11 ) ) by L133;
L137: ( ( D16 `2 ) (*) ( R17 . D18 ) ) = ( D16 `2 ) by L136 , L130 , CAT_1:22
.= ( ( R18 . D19 ) (*) ( D16 `2 ) ) by L131 , L135 , CAT_1:21;
L138: D17 in { [ [ B6 , B7 ] , [ B4 , B5 ] ] where B4 is (Morphism of R2) , B5 is (Morphism of R3) , B6 is (Element of ( commaObjs (R17 , R18) )) , B7 is (Element of ( commaObjs (R17 , R18) )) : (( dom B4 ) = ( B6 `11 ) & ( cod B4 ) = ( B7 `11 ) & ( dom B5 ) = ( B6 `12 ) & ( cod B5 ) = ( B7 `12 ) & ( ( B7 `2 ) (*) ( R17 . B4 ) ) = ( ( R18 . B5 ) (*) ( B6 `2 ) )) } by L122 , L123 , L124 , L125 , L137;
L139: D17 in ( commaMorphs (R17 , R18) ) by L138 , L20 , L109;
reconsider D20 = D17 as (Morphism of D15) by L139;
L140: ( cod D20 ) = ( D14 . D20 )
.= ( [ [ D16 , D16 ] , [ D18 , D19 ] ] `12 ) by L111
.= C10 by MCART_1:85;
L141: ( dom D20 ) = ( D13 . D20 )
.= ( [ [ D16 , D16 ] , [ D18 , D19 ] ] `11 ) by L110
.= C10 by MCART_1:85;
L142: D20 in ( Hom (C10 , C10) ) by L141 , L140;
thus L143: ( Hom (C10 , C10) ) <> ( {} ) by L142;
end;
L144: (for B8 being (Element of D15) holds (ex B9 being (Morphism of B8 , B8) st (for B10 being (Element of D15) holds ((( Hom (B8 , B10) ) <> ( {} ) implies (for B11 being (Morphism of B8 , B10) holds ( B11 (*) B9 ) = B11)) & (( Hom (B10 , B8) ) <> ( {} ) implies (for B12 being (Morphism of B10 , B8) holds ( B9 (*) B12 ) = B12))))))
proof
let C11 being (Element of D15);
reconsider D21 = C11 as (Element of ( commaObjs (R17 , R18) ));
set D22 = [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ];
reconsider D23 = ( id ( D21 `11 ) ) as (Morphism of R2);
reconsider D24 = ( id ( D21 `12 ) ) as (Morphism of R3);
L145: ( dom D23 ) = ( D21 `11 ) by CAT_1:58;
L146: ( cod D23 ) = ( D21 `11 ) by CAT_1:58;
L147: ( dom D24 ) = ( D21 `12 ) by CAT_1:58;
L148: ( cod D24 ) = ( D21 `12 ) by CAT_1:58;
L149: D21 in ( commaObjs (R17 , R18) );
L150: D21 in { [ [ R5 , R8 ] , R11 ] where R5 is (Object of R2) , R8 is (Object of R3) , R11 is (Morphism of R4) : R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) } by L149 , L109 , L2;
consider R5 being (Object of R2), R8 being (Object of R3), R11 being (Morphism of R4) such that L151: D21 = [ [ R5 , R8 ] , R11 ] and L152: R11 in ( Hom (( R17 . R5 ) , ( R18 . R8 )) ) by L150;
L153: ( R17 . D23 ) = ( id ( R17 . ( D21 `11 ) ) ) by CAT_1:71;
L154: ( R18 . D24 ) = ( id ( R18 . ( D21 `12 ) ) ) by CAT_1:71;
L155: ( [ [ R5 , R8 ] , R11 ] `2 ) = R11;
L156: R5 = ( D21 `11 ) by L151 , MCART_1:85;
L157: R8 = ( D21 `12 ) by L151 , MCART_1:85;
L158: ( cod ( D21 `2 ) ) = ( cod R11 ) by L155 , L151
.= ( R18 . R8 ) by L152 , CAT_1:1
.= ( R18 . ( D21 `12 ) ) by L157;
L159: ( dom ( D21 `2 ) ) = ( R17 . R5 ) by L151 , L152 , CAT_1:1 , L155
.= ( R17 . ( D21 `11 ) ) by L156;
L160: ( ( D21 `2 ) (*) ( R17 . D23 ) ) = ( D21 `2 ) by L159 , L153 , CAT_1:22
.= ( ( R18 . D24 ) (*) ( D21 `2 ) ) by L154 , L158 , CAT_1:21;
L161: D22 in { [ [ B15 , B16 ] , [ B13 , B14 ] ] where B13 is (Morphism of R2) , B14 is (Morphism of R3) , B15 is (Element of ( commaObjs (R17 , R18) )) , B16 is (Element of ( commaObjs (R17 , R18) )) : (( dom B13 ) = ( B15 `11 ) & ( cod B13 ) = ( B16 `11 ) & ( dom B14 ) = ( B15 `12 ) & ( cod B14 ) = ( B16 `12 ) & ( ( B16 `2 ) (*) ( R17 . B13 ) ) = ( ( R18 . B14 ) (*) ( B15 `2 ) )) } by L145 , L146 , L147 , L148 , L160;
L162: D22 in ( commaMorphs (R17 , R18) ) by L161 , L20 , L109;
reconsider D25 = D22 as (Morphism of D15) by L162;
L163: ( cod D25 ) = ( D14 . D25 )
.= ( [ [ D21 , D21 ] , [ D23 , D24 ] ] `12 ) by L111
.= C11 by MCART_1:85;
L164: ( dom D25 ) = ( D13 . D25 )
.= ( [ [ D21 , D21 ] , [ D23 , D24 ] ] `11 ) by L110
.= C11 by MCART_1:85;
L165: D25 in ( Hom (C11 , C11) ) by L164 , L163;
reconsider D26 = D25 as (Morphism of C11 , C11) by L165 , CAT_1:def 5;
take D26;
let C12 being (Element of D15);
thus L166: (( Hom (C11 , C12) ) <> ( {} ) implies (for B17 being (Morphism of C11 , C12) holds ( B17 (*) D26 ) = B17))
proof
assume L167: ( Hom (C11 , C12) ) <> ( {} );
let C13 being (Morphism of C11 , C12);
reconsider D27 = C13 as (Element of ( commaMorphs (R17 , R18) ));
reconsider D28 = D26 as (Element of ( commaMorphs (R17 , R18) ));
L168: ( commaMorphs (R17 , R18) ) = { [ [ R20 , R21 ] , [ R14 , R16 ] ] where R14 is (Morphism of R2) , R16 is (Morphism of R3) , R20 is (Element of ( commaObjs (R17 , R18) )) , R21 is (Element of ( commaObjs (R17 , R18) )) : (( dom R14 ) = ( R20 `11 ) & ( cod R14 ) = ( R21 `11 ) & ( dom R16 ) = ( R20 `12 ) & ( cod R16 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R14 ) ) = ( ( R18 . R16 ) (*) ( R20 `2 ) )) } by L109 , L20;
L169: D27 in ( commaMorphs (R17 , R18) );
consider R14 being (Morphism of R2), R16 being (Morphism of R3), R20 being (Element of ( commaObjs (R17 , R18) )), R21 being (Element of ( commaObjs (R17 , R18) )) such that L170: D27 = [ [ R20 , R21 ] , [ R14 , R16 ] ] and L171: ( dom R14 ) = ( R20 `11 ) and L172: ( cod R14 ) = ( R21 `11 ) and L173: ( dom R16 ) = ( R20 `12 ) and L174: (( cod R16 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R14 ) ) = ( ( R18 . R16 ) (*) ( R20 `2 ) )) by L169 , L168;
L175: ( dom ( commaComp (R17 , R18) ) ) = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) } by L77;
L176: ( D28 `21 ) = ( [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ] `21 )
.= ( id ( D21 `11 ) ) by MCART_1:85;
L177: ( D28 `22 ) = ( [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ] `22 )
.= ( id ( D21 `12 ) ) by MCART_1:85;
L178: R20 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `11 ) by MCART_1:85
.= ( D27 `11 ) by L170;
L179: R21 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `12 ) by MCART_1:85
.= ( D27 `12 ) by L170;
L180: R14 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `21 ) by MCART_1:85
.= ( D27 `21 ) by L170;
L181: R16 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `22 ) by MCART_1:85
.= ( D27 `22 ) by L170;
L182: ( dom C13 ) = C11 by L167 , CAT_1:5;
L183: ( dom C13 ) = ( D27 `11 ) by L110
.= ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `11 ) by L170
.= R20 by MCART_1:85;
L184: R20 = C11 by L167 , CAT_1:5 , L183
.= [ [ R5 , R8 ] , R11 ] by L151;
L185: ( dom ( D27 `21 ) ) = ( dom ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `21 ) ) by L170
.= ( dom R14 ) by MCART_1:85
.= ( R20 `11 ) by L171
.= ( [ [ R5 , R8 ] , R11 ] `11 ) by L184
.= ( D21 `11 ) by L151;
L186: ( dom ( D27 `22 ) ) = ( dom ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `22 ) ) by L170
.= ( dom R16 ) by MCART_1:85
.= ( R20 `12 ) by L173
.= ( [ [ R5 , R8 ] , R11 ] `12 ) by L184
.= ( D21 `12 ) by L151;
L187: ( D28 `11 ) = ( [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ] `11 )
.= ( dom C13 ) by L182 , MCART_1:85
.= ( D13 . D27 )
.= ( D27 `11 ) by L110;
L188: ( D28 `11 ) = D21 by MCART_1:85
.= ( D28 `12 ) by MCART_1:85;
L189: ( D27 `11 ) = ( D28 `12 ) by L188 , L187;
L190: [ D27 , D28 ] in ( dom ( commaComp (R17 , R18) ) ) by L189 , L175;
thus L191: ( C13 (*) D26 ) = ( ( commaComp (R17 , R18) ) . (C13 , D26) ) by L190 , CAT_1:def 1
.= ( D27 * D28 ) by L190 , L77
.= [ [ ( D27 `11 ) , ( D27 `12 ) ] , [ ( ( D27 `21 ) (*) ( id ( D21 `11 ) ) ) , ( ( D27 `22 ) (*) ( D28 `22 ) ) ] ] by L109 , L188 , L54 , L187 , L176
.= [ [ ( D27 `11 ) , ( D27 `12 ) ] , [ ( D27 `21 ) , ( ( D27 `22 ) (*) ( D28 `22 ) ) ] ] by L185 , CAT_1:22
.= [ [ ( D27 `11 ) , ( D27 `12 ) ] , [ ( D27 `21 ) , ( D27 `22 ) ] ] by CAT_1:22 , L177 , L186
.= C13 by L178 , L179 , L180 , L181 , L170;
end;

thus L192: (( Hom (C12 , C11) ) <> ( {} ) implies (for B18 being (Morphism of C12 , C11) holds ( D26 (*) B18 ) = B18))
proof
assume L193: ( Hom (C12 , C11) ) <> ( {} );
let C14 being (Morphism of C12 , C11);
reconsider D29 = C14 as (Element of ( commaMorphs (R17 , R18) ));
reconsider D30 = D26 as (Element of ( commaMorphs (R17 , R18) ));
L194: ( commaMorphs (R17 , R18) ) = { [ [ R20 , R21 ] , [ R14 , R16 ] ] where R14 is (Morphism of R2) , R16 is (Morphism of R3) , R20 is (Element of ( commaObjs (R17 , R18) )) , R21 is (Element of ( commaObjs (R17 , R18) )) : (( dom R14 ) = ( R20 `11 ) & ( cod R14 ) = ( R21 `11 ) & ( dom R16 ) = ( R20 `12 ) & ( cod R16 ) = ( R21 `12 ) & ( ( R21 `2 ) (*) ( R17 . R14 ) ) = ( ( R18 . R16 ) (*) ( R20 `2 ) )) } by L109 , L20;
L195: D29 in ( commaMorphs (R17 , R18) );
consider R14 being (Morphism of R2), R16 being (Morphism of R3), R20 being (Element of ( commaObjs (R17 , R18) )), R21 being (Element of ( commaObjs (R17 , R18) )) such that L196: D29 = [ [ R20 , R21 ] , [ R14 , R16 ] ] and L197: ( dom R14 ) = ( R20 `11 ) and L198: ( cod R14 ) = ( R21 `11 ) and L199: ( dom R16 ) = ( R20 `12 ) and L200: ( cod R16 ) = ( R21 `12 ) and L201: ( ( R21 `2 ) (*) ( R17 . R14 ) ) = ( ( R18 . R16 ) (*) ( R20 `2 ) ) by L195 , L194;
L202: ( dom ( commaComp (R17 , R18) ) ) = { [ R23 , R24 ] where R23 is (Element of ( commaMorphs (R17 , R18) )) , R24 is (Element of ( commaMorphs (R17 , R18) )) : ( R23 `11 ) = ( R24 `12 ) } by L77;
L203: ( D30 `21 ) = ( [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ] `21 )
.= ( id ( D21 `11 ) ) by MCART_1:85;
L204: ( D30 `22 ) = ( [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ] `22 )
.= ( id ( D21 `12 ) ) by MCART_1:85;
L205: R20 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `11 ) by MCART_1:85
.= ( D29 `11 ) by L196;
L206: R21 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `12 ) by MCART_1:85
.= ( D29 `12 ) by L196;
L207: R14 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `21 ) by MCART_1:85
.= ( D29 `21 ) by L196;
L208: R16 = ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `22 ) by MCART_1:85
.= ( D29 `22 ) by L196;
L209: ( cod C14 ) = C11 by L193 , CAT_1:5;
L210: ( cod C14 ) = ( D29 `12 ) by L111
.= ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `12 ) by L196
.= R21 by MCART_1:85;
L211: R21 = C11 by L193 , CAT_1:5 , L210
.= [ [ R5 , R8 ] , R11 ] by L151;
L212: ( cod ( D29 `21 ) ) = ( cod ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `21 ) ) by L196
.= ( cod R14 ) by MCART_1:85
.= ( R21 `11 ) by L198
.= ( [ [ R5 , R8 ] , R11 ] `11 ) by L211
.= ( D21 `11 ) by L151;
L213: ( cod ( D29 `22 ) ) = ( cod ( [ [ R20 , R21 ] , [ R14 , R16 ] ] `22 ) ) by L196
.= ( cod R16 ) by MCART_1:85
.= ( R21 `12 ) by L200
.= ( [ [ R5 , R8 ] , R11 ] `12 ) by L211
.= ( D21 `12 ) by L151;
L214: ( D30 `11 ) = ( [ [ D21 , D21 ] , [ ( id ( D21 `11 ) ) , ( id ( D21 `12 ) ) ] ] `11 )
.= ( cod C14 ) by L209 , MCART_1:85
.= ( D14 . D29 )
.= ( D29 `12 ) by L111;
L215: ( D30 `11 ) = D21 by MCART_1:85
.= ( D30 `12 ) by MCART_1:85;
L216: ( D29 `12 ) = ( D30 `11 ) by L214;
L217: [ D30 , D29 ] in ( dom ( commaComp (R17 , R18) ) ) by L216 , L202;
thus L218: ( D26 (*) C14 ) = ( ( commaComp (R17 , R18) ) . (D26 , C14) ) by L217 , CAT_1:def 1
.= ( D30 * D29 ) by L217 , L77
.= [ [ ( D29 `11 ) , ( D29 `12 ) ] , [ ( ( D30 `21 ) (*) ( D29 `21 ) ) , ( ( D30 `22 ) (*) ( D29 `22 ) ) ] ] by L109 , L215 , L54 , L214
.= [ [ ( D29 `11 ) , ( D29 `12 ) ] , [ ( D29 `21 ) , ( ( D30 `22 ) (*) ( D29 `22 ) ) ] ] by L212 , CAT_1:21 , L203
.= [ [ ( D29 `11 ) , ( D29 `12 ) ] , [ ( D29 `21 ) , ( D29 `22 ) ] ] by CAT_1:21 , L204 , L213
.= C14 by L205 , L206 , L207 , L208 , L196;
end;

end;
L193: (for B19 , B20 being (Morphism of D15) holds (( dom B20 ) = ( cod B19 ) implies (( dom ( B20 (*) B19 ) ) = ( dom B19 ) & ( cod ( B20 (*) B19 ) ) = ( cod B20 ))))
proof
let C15 , C16 being (Morphism of D15);
assume that
L194: ( dom C16 ) = ( cod C15 );
reconsider D31 = C15 , D32 = C16 as (Element of ( commaMorphs (R17 , R18) ));
L195: (( dom C16 ) = ( D32 `11 ) & ( cod C15 ) = ( D31 `12 )) by L110 , L111;
L196: [ D32 , D31 ] in ( dom D12 ) by L195 , L112 , L194;
L197: (( C16 (*) C15 ) = ( D12 . (C16 , C15) ) & ( D12 . (D32 , D31) ) = ( D32 * D31 )) by L196 , L77 , CAT_1:def 1;
L198: (( dom C15 ) = ( C15 `11 ) & ( cod C16 ) = ( C16 `12 )) by L110 , L111;
L199: (( dom ( C16 (*) C15 ) ) = ( ( C16 (*) C15 ) `11 ) & ( cod ( C16 (*) C15 ) ) = ( ( C16 (*) C15 ) `12 )) by L110 , L111;
L200: ( D32 * D31 ) = [ [ ( D31 `11 ) , ( D32 `12 ) ] , [ ( ( D32 `21 ) (*) ( D31 `21 ) ) , ( ( D32 `22 ) (*) ( D31 `22 ) ) ] ] by L109 , L194 , L195 , L54;
thus L201: thesis by L200 , L199 , L198 , L197 , MCART_1:85;
end;
L202: (for B21 , B22 , B23 being (Morphism of D15) holds ((( dom B23 ) = ( cod B22 ) & ( dom B22 ) = ( cod B21 )) implies ( B23 (*) ( B22 (*) B21 ) ) = ( ( B23 (*) B22 ) (*) B21 )))
proof
let C17 , C18 , C19 being (Morphism of D15);
reconsider D33 = C17 , D34 = C18 , D35 = C19 , D36 = ( C18 (*) C17 ) , D37 = ( C19 (*) C18 ) as (Element of ( commaMorphs (R17 , R18) ));
assume that
L203: ( dom C19 ) = ( cod C18 )
and
L204: ( dom C18 ) = ( cod C17 );
L205: (( dom C18 ) = ( C18 `11 ) & ( cod C18 ) = ( C18 `12 )) by L110 , L111;
L206: ( dom ( C19 (*) C18 ) ) = ( dom C18 ) by L193 , L203;
L207: ( ( C19 (*) C18 ) (*) C17 ) = [ [ ( C17 `11 ) , ( D37 `12 ) ] , [ ( ( D37 `21 ) (*) ( D33 `21 ) ) , ( ( D37 `22 ) (*) ( D33 `22 ) ) ] ] by L206 , L113 , L204;
L208: (( dom C19 ) = ( C19 `11 ) & ( cod C17 ) = ( C17 `12 )) by L110 , L111;
L209: ( cod ( C18 (*) C17 ) ) = ( cod C18 ) by L193 , L204;
L210: ( C19 (*) ( C18 (*) C17 ) ) = [ [ ( D36 `11 ) , ( C19 `12 ) ] , [ ( ( D35 `21 ) (*) ( D36 `21 ) ) , ( ( D35 `22 ) (*) ( D36 `22 ) ) ] ] by L209 , L113 , L203;
L211: (( dom ( D35 `21 ) ) = ( ( D35 `11 ) `11 ) & ( cod ( D33 `21 ) ) = ( ( D33 `12 ) `11 )) by L109 , L43;
L212: (( dom ( D35 `22 ) ) = ( ( D35 `11 ) `12 ) & ( cod ( D33 `22 ) ) = ( ( D33 `12 ) `12 )) by L109 , L43;
L213: (( dom ( D34 `22 ) ) = ( ( D34 `11 ) `12 ) & ( cod ( D34 `22 ) ) = ( ( D34 `12 ) `12 )) by L109 , L43;
L214: ( C19 (*) C18 ) = [ [ ( C18 `11 ) , ( C19 `12 ) ] , [ ( ( D35 `21 ) (*) ( D34 `21 ) ) , ( ( D35 `22 ) (*) ( D34 `22 ) ) ] ] by L113 , L203;
L215: (( ( C19 (*) C18 ) `12 ) = ( C19 `12 ) & ( D37 `21 ) = ( ( D35 `21 ) (*) ( D34 `21 ) )) by L214 , MCART_1:85;
L216: ( C18 (*) C17 ) = [ [ ( C17 `11 ) , ( C18 `12 ) ] , [ ( ( D34 `21 ) (*) ( D33 `21 ) ) , ( ( D34 `22 ) (*) ( D33 `22 ) ) ] ] by L113 , L204;
L217: (( ( C18 (*) C17 ) `11 ) = ( C17 `11 ) & ( D36 `21 ) = ( ( D34 `21 ) (*) ( D33 `21 ) )) by L216 , MCART_1:85;
L218: ( D36 `22 ) = ( ( D34 `22 ) (*) ( D33 `22 ) ) by L216 , MCART_1:85;
L219: ( D37 `22 ) = ( ( D35 `22 ) (*) ( D34 `22 ) ) by L214 , MCART_1:85;
L220: (( dom ( D34 `21 ) ) = ( ( D34 `11 ) `11 ) & ( cod ( D34 `21 ) ) = ( ( D34 `12 ) `11 )) by L109 , L43;
L221: ( ( ( D35 `21 ) (*) ( D34 `21 ) ) (*) ( D33 `21 ) ) = ( ( D35 `21 ) (*) ( ( D34 `21 ) (*) ( D33 `21 ) ) ) by L220 , L203 , L204 , L205 , L211 , L208 , CAT_1:18;
thus L222: thesis by L221 , L203 , L204 , L205 , L208 , L213 , L212 , L210 , L207 , L215 , L217 , L219 , L218 , CAT_1:18;
end;
L223: (for B24 , B25 being (Morphism of D15) holds ([ B25 , B24 ] in ( dom (the Comp of D15) ) iff ( dom B25 ) = ( cod B24 )))
proof
let C20 , C21 being (Morphism of D15);
reconsider D38 = C20 , D39 = C21 as (Element of ( commaMorphs (R17 , R18) ));
L224: (( dom C21 ) = ( D39 `11 ) & ( cod C20 ) = ( D38 `12 )) by L110 , L111;
thus L225: ([ C21 , C20 ] in ( dom (the Comp of D15) ) implies ( dom C21 ) = ( cod C20 ))
proof
assume L226: [ C21 , C20 ] in ( dom (the Comp of D15) );
consider R23 being (Element of ( commaMorphs (R17 , R18) )), R24 being (Element of ( commaMorphs (R17 , R18) )) such that L227: [ C21 , C20 ] = [ R23 , R24 ] and L228: ( R23 `11 ) = ( R24 `12 ) by L226 , L112;
L229: C21 = R23 by L227 , XTUPLE_0:1;
thus L230: thesis by L229 , L224 , L227 , L228 , XTUPLE_0:1;
end;

thus L231: thesis by L112 , L224;
end;
reconsider D40 = D15 as  strict Category by L223 , L193 , L202 , L121 , L144 , CAT_1:def 6 , CAT_1:def 7 , CAT_1:def 8 , CAT_1:def 9 , CAT_1:def 10;
take D40;
thus L232: thesis by L110 , L111;
end;
uniqueness
proof
let C22 , C23 being  strict Category;
assume that
L233: (the carrier of C22) = ( commaObjs (R17 , R18) )
and
L234: (the carrier' of C22) = ( commaMorphs (R17 , R18) )
and
L235: (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( (the Source of C22) . R22 ) = ( R22 `11 ))
and
L236: (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( (the Target of C22) . R22 ) = ( R22 `12 ))
and
L237: (the Comp of C22) = ( commaComp (R17 , R18) )
and
L238: ((the carrier of C23) = ( commaObjs (R17 , R18) ) & (the carrier' of C23) = ( commaMorphs (R17 , R18) ))
and
L239: (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( (the Source of C23) . R22 ) = ( R22 `11 ))
and
L240: (for R22 being (Element of ( commaMorphs (R17 , R18) )) holds ( (the Target of C23) . R22 ) = ( R22 `12 ))
and
L241: (the Comp of C23) = ( commaComp (R17 , R18) );
L242:
now
let C24 being (Element of H2(C22));
thus L243: ( (the Target of C22) . C24 ) = ( C24 `12 ) by L234 , L236
.= ( (the Target of C23) . C24 ) by L234 , L240;
end;
L244: (the Target of C22) = (the Target of C23) by L242 , L233 , L234 , L238 , FUNCT_2:63;
L245:
now
let C25 being (Element of H2(C22));
thus L246: ( (the Source of C22) . C25 ) = ( C25 `11 ) by L234 , L235
.= ( (the Source of C23) . C25 ) by L234 , L239;
end;
L247: (the Source of C22) = (the Source of C23) by L245 , L233 , L234 , L238 , FUNCT_2:63;
thus L248: thesis by L247 , L233 , L234 , L237 , L238 , L241 , L244;
end;
end;
theorem
L250: (for R1 being set holds (for R10 being set holds ((the carrier of ( 1Cat (R10 , R1) )) = { R10 } & (the carrier' of ( 1Cat (R10 , R1) )) = { R1 })));
theorem
L251: (for R1 being set holds (for R10 being set holds (for B26 , B27 being (Object of ( 1Cat (R10 , R1) )) holds ( Hom (B26 , B27) ) = { R1 })))
proof
let R1 being set;
let R10 being set;
let C26 , C27 being (Object of ( 1Cat (R10 , R1) ));
thus L252: ( Hom (C26 , C27) ) c= { R1 };
L253: R1 is (Morphism of ( 1Cat (R10 , R1) )) by TARSKI:def 1;
L254: R1 in ( Hom (C26 , C27) ) by L253 , CAT_1:11;
thus L255: thesis by L254 , ZFMISC_1:31;
end;
definition
let R2 being Category;
let R5 being (Object of R2);
func 1Cat R5 ->  strict (Subcategory of R2) equals 
( 1Cat (R5 , ( id R5 )) );
coherence
proof
L256:
now
let C28 being (Object of ( 1Cat (R5 , ( id R5 )) ));
L257: ( id C28 ) = ( id R5 ) by TARSKI:def 1;
thus L258: (for R6 being (Object of R2) holds (C28 = R6 implies ( id C28 ) = ( id R6 ))) by L257 , TARSKI:def 1;
end;
L259:
now
let C29 , C30 being (Object of ( 1Cat (R5 , ( id R5 )) ));
L260: (C29 = R5 & C30 = R5) by TARSKI:def 1;
L261: (( id R5 ) in ( Hom (R5 , R5) ) & ( Hom (C29 , C29) ) = { ( id R5 ) }) by L251 , CAT_1:27;
thus L262: (for R6 being (Object of R2) holds (for R7 being (Object of R2) holds ((C29 = R6 & C30 = R7) implies ( Hom (C29 , C30) ) c= ( Hom (R6 , R7) )))) by L261 , L260 , ZFMISC_1:31;
end;
set D41 = ( id R5 );
set D42 = ( (D41 , D41) .--> D41 );
L263: ( dom D42 ) = { [ D41 , D41 ] } by FUNCOP_1:13;
L264: ( dom D41 ) = R5;
L265: ( cod D41 ) = R5;
L266: ( D42 . (D41 , D41) ) = D41 by FUNCOP_1:71;
L267:
now
let R10 being set;
assume L268: R10 in ( dom (the Comp of ( 1Cat (R5 , D41) )) );
thus L269: ( (the Comp of ( 1Cat (R5 , D41) )) . R10 ) = D41 by L268 , L266 , L263 , TARSKI:def 1
.= ( D41 (*) (D41 qua (Morphism of R2)) ) by L265 , CAT_1:21
.= ( (the Comp of R2) . (D41 , D41) ) by L264 , L265 , CAT_1:16
.= ( (the Comp of R2) . R10 ) by L263 , L268 , TARSKI:def 1;
end;
L270: [ D41 , D41 ] in ( dom (the Comp of R2) ) by L264 , L265 , CAT_1:15;
L271: ( dom (the Comp of ( 1Cat (R5 , D41) )) ) c= ( dom (the Comp of R2) ) by L270 , L263 , ZFMISC_1:31;
L272: (H1(( 1Cat (R5 , ( id R5 )) )) = { R5 } & (the Comp of ( 1Cat (R5 , ( id R5 )) )) c= (the Comp of R2)) by L271 , L267 , GRFUNC_1:2;
thus L273: thesis by L272 , L259 , L256 , CAT_2:def 4;
end;
end;
definition
let R2 being Category;
let R5 being (Object of R2);
func R5 comma R2 ->  strict Category equals 
( ( incl ( 1Cat R5 ) ) comma ( id R2 ) );
coherence;
func R2 comma R5 ->  strict Category equals 
( ( id R2 ) comma ( incl ( 1Cat R5 ) ) );
coherence;
end;
