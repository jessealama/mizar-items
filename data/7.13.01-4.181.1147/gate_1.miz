:: Logic Gates and Logical Equivalence of Adders
::  by Yatsuka Nakamura
::
:: Received February 4, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, GATE_1;
 notations TARSKI, XBOOLE_0;
 constructors TARSKI, XBOOLE_0;
 registrations XBOOLE_0;

begin
definition
let C1 being set;
func NOT1 C1 equals 
:L1: ( {} ) if C1 is non  empty otherwise { ( {} ) };
correctness;
end;
registration
let C2 being  empty set;
cluster ( NOT1 C2 ) -> non  empty;
coherence by L1;
end;
registration
let C3 being non  empty set;
cluster ( NOT1 C3 ) ->  empty;
coherence by L1;
end;
theorem
L5: (( NOT1 { ( {} ) } ) = ( {} ) & ( NOT1 ( {} ) ) = { ( {} ) }) by L1;
theorem
L6: (for B1 being set holds (( NOT1 B1 ) is non  empty iff (not B1 is non  empty)));
theorem
L7: ( NOT1 ( {} ) ) is non  empty;
definition
let C4 , C5 being set;
func AND2 (C4 , C5) equals 
:L8: ( NOT1 ( {} ) ) if (C4 is non  empty & C5 is non  empty) otherwise ( {} );
correctness;
commutativity
;
end;
registration
let C6 , C7 being non  empty set;
cluster ( AND2 (C6 , C7) ) -> non  empty;
coherence by L8;
end;
registration
let C8 being  empty set;
let C9 being set;
cluster ( AND2 (C8 , C9) ) ->  empty;
coherence by L8;
end;
theorem
L12: (for R1 being set holds (for R2 being set holds (( AND2 (R1 , R2) ) is non  empty iff (R1 is non  empty & R2 is non  empty))));
definition
let C10 , C11 being set;
func OR2 (C10 , C11) equals 
:L13: ( NOT1 ( {} ) ) if (C10 is non  empty or C11 is non  empty) otherwise ( {} );
correctness;
commutativity
;
end;
registration
let C12 being set;
let C13 being non  empty set;
cluster ( OR2 (C12 , C13) ) -> non  empty;
coherence by L13;
end;
registration
let C14 , C15 being  empty set;
cluster ( OR2 (C14 , C15) ) ->  empty;
coherence by L13;
end;
theorem
L17: (for R1 being set holds (for R2 being set holds (( OR2 (R1 , R2) ) is non  empty iff (R1 is non  empty or R2 is non  empty))));
definition
let C16 , C17 being set;
func XOR2 (C16 , C17) equals 
:L18: ( NOT1 ( {} ) ) if ((C16 is non  empty & (not C17 is non  empty)) or ((not C16 is non  empty) & C17 is non  empty)) otherwise ( {} );
correctness;
commutativity
;
end;
registration
let C18 being  empty set;
let C19 being non  empty set;
cluster ( XOR2 (C18 , C19) ) -> non  empty;
coherence by L18;
end;
registration
let C20 , C21 being  empty set;
cluster ( XOR2 (C20 , C21) ) ->  empty;
coherence by L18;
end;
registration
let C22 , C23 being non  empty set;
cluster ( XOR2 (C22 , C23) ) ->  empty;
coherence by L18;
end;
theorem
L23: (for R1 being set holds (for R2 being set holds (( XOR2 (R1 , R2) ) is non  empty iff ((R1 is non  empty & (not R2 is non  empty)) or ((not R1 is non  empty) & R2 is non  empty)))));
theorem
L24: (for R1 being set holds (not ( XOR2 (R1 , R1) ) is non  empty))
proof
let R1 being set;
L25: (( XOR2 (R1 , R1) ) is non  empty iff ((R1 is non  empty & (not R1 is non  empty)) or ((not R1 is non  empty) & R1 is non  empty)));
thus L26: thesis by L25;
end;
theorem
L27: (for R1 being set holds (( XOR2 (R1 , ( {} )) ) is non  empty iff R1 is non  empty));
theorem
L28: (for R1 being set holds (for R2 being set holds (( XOR2 (R1 , R2) ) is non  empty iff ( XOR2 (R2 , R1) ) is non  empty)));
definition
let C24 , C25 being set;
func EQV2 (C24 , C25) equals 
:L29: ( NOT1 ( {} ) ) if (C24 is non  empty iff C25 is non  empty) otherwise ( {} );
correctness;
commutativity
;
end;
registration
let C26 being  empty set;
let C27 being non  empty set;
cluster ( EQV2 (C26 , C27) ) ->  empty;
coherence by L29;
end;
registration
let C28 , C29 being  empty set;
cluster ( EQV2 (C28 , C29) ) -> non  empty;
coherence by L29;
end;
registration
let C30 , C31 being non  empty set;
cluster ( EQV2 (C30 , C31) ) -> non  empty;
coherence by L29;
end;
theorem
L34: (for R1 being set holds (for R2 being set holds (( EQV2 (R1 , R2) ) is non  empty iff (R1 is non  empty iff R2 is non  empty))));
theorem
L35: (for R1 being set holds (for R2 being set holds (( EQV2 (R1 , R2) ) is non  empty iff (not ( XOR2 (R1 , R2) ) is non  empty))))
proof
let R1 being set;
let R2 being set;
L36: (( EQV2 (R1 , R2) ) is non  empty iff (R1 is non  empty iff R2 is non  empty));
thus L37: thesis by L36;
end;
definition
let C32 , C33 being set;
func NAND2 (C32 , C33) equals 
:L38: ( NOT1 ( {} ) ) if (not (C32 is non  empty & C33 is non  empty)) otherwise ( {} );
correctness;
commutativity
;
end;
registration
let C34 being  empty set;
let C35 being set;
cluster ( NAND2 (C34 , C35) ) -> non  empty;
coherence by L38;
end;
registration
let C36 , C37 being non  empty set;
cluster ( NAND2 (C36 , C37) ) ->  empty;
coherence by L38;
end;
theorem
L42: (for R1 being set holds (for R2 being set holds (( NAND2 (R1 , R2) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty)))));
definition
let C38 , C39 being set;
func NOR2 (C38 , C39) equals 
:L43: ( NOT1 ( {} ) ) if (not (C38 is non  empty or C39 is non  empty)) otherwise ( {} );
correctness;
commutativity
;
end;
registration
let C40 , C41 being  empty set;
cluster ( NOR2 (C40 , C41) ) -> non  empty;
coherence by L43;
end;
registration
let C42 being non  empty set;
let C43 being set;
cluster ( NOR2 (C42 , C43) ) ->  empty;
coherence by L43;
end;
theorem
L47: (for R1 being set holds (for R2 being set holds (( NOR2 (R1 , R2) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty)))));
definition
let C44 , C45 , C46 being set;
func AND3 (C44 , C45 , C46) equals 
:L48: ( NOT1 ( {} ) ) if (C44 is non  empty & C45 is non  empty & C46 is non  empty) otherwise ( {} );
correctness;
end;
registration
let C47 , C48 , C49 being non  empty set;
cluster ( AND3 (C47 , C48 , C49) ) -> non  empty;
coherence by L48;
end;
registration
let C50 being  empty set;
let C51 , C52 being set;
cluster ( AND3 (C50 , C51 , C52) ) ->  empty;
coherence by L48;
cluster ( AND3 (C51 , C50 , C52) ) ->  empty;
coherence by L48;
cluster ( AND3 (C51 , C52 , C50) ) ->  empty;
coherence by L48;
end;
theorem
L52: (for R1 being set holds (for R2 being set holds (for R3 being set holds (( AND3 (R1 , R2 , R3) ) is non  empty iff (R1 is non  empty & R2 is non  empty & R3 is non  empty)))));
definition
let C53 , C54 , C55 being set;
func OR3 (C53 , C54 , C55) equals 
:L53: ( NOT1 ( {} ) ) if (C53 is non  empty or C54 is non  empty or C55 is non  empty) otherwise ( {} );
correctness;
end;
registration
let C56 , C57 , C58 being  empty set;
cluster ( OR3 (C56 , C57 , C58) ) ->  empty;
coherence by L53;
end;
registration
let C59 being non  empty set;
let C60 , C61 being set;
cluster ( OR3 (C59 , C60 , C61) ) -> non  empty;
coherence by L53;
cluster ( OR3 (C60 , C59 , C61) ) -> non  empty;
coherence by L53;
cluster ( OR3 (C60 , C61 , C59) ) -> non  empty;
coherence by L53;
end;
theorem
L57: (for R1 being set holds (for R2 being set holds (for R3 being set holds (( OR3 (R1 , R2 , R3) ) is non  empty iff (R1 is non  empty or R2 is non  empty or R3 is non  empty)))));
definition
let C62 , C63 , C64 being set;
func XOR3 (C62 , C63 , C64) equals 
:L58: ( NOT1 ( {} ) ) if ((((C62 is non  empty & (not C63 is non  empty)) or ((not C62 is non  empty) & C63 is non  empty)) & (not C64 is non  empty)) or ((not ((C62 is non  empty & (not C63 is non  empty)) or ((not C62 is non  empty) & C63 is non  empty))) & C64 is non  empty)) otherwise ( {} );
correctness;
end;
registration
let C65 , C66 , C67 being  empty set;
cluster ( XOR3 (C65 , C66 , C67) ) ->  empty;
coherence by L58;
end;
registration
let C68 , C69 being  empty set;
let C70 being non  empty set;
cluster ( XOR3 (C68 , C69 , C70) ) -> non  empty;
coherence by L58;
cluster ( XOR3 (C68 , C70 , C69) ) -> non  empty;
coherence by L58;
cluster ( XOR3 (C70 , C68 , C69) ) -> non  empty;
coherence by L58;
end;
registration
let C71 , C72 being non  empty set;
let C73 being  empty set;
cluster ( XOR3 (C71 , C72 , C73) ) ->  empty;
coherence by L58;
cluster ( XOR3 (C71 , C73 , C72) ) ->  empty;
coherence by L58;
cluster ( XOR3 (C73 , C71 , C72) ) ->  empty;
coherence by L58;
end;
registration
let C74 , C75 , C76 being non  empty set;
cluster ( XOR3 (C74 , C75 , C76) ) -> non  empty;
coherence by L58;
end;
theorem
L64: (for R1 being set holds (for R2 being set holds (for R3 being set holds (( XOR3 (R1 , R2 , R3) ) is non  empty iff ((((R1 is non  empty & (not R2 is non  empty)) or ((not R1 is non  empty) & R2 is non  empty)) & (not R3 is non  empty)) or ((not ((R1 is non  empty & (not R2 is non  empty)) or ((not R1 is non  empty) & R2 is non  empty))) & R3 is non  empty))))));
definition
let C77 , C78 , C79 being set;
func MAJ3 (C77 , C78 , C79) equals 
:L65: ( NOT1 ( {} ) ) if ((C77 is non  empty & C78 is non  empty) or (C78 is non  empty & C79 is non  empty) or (C79 is non  empty & C77 is non  empty)) otherwise ( {} );
correctness;
end;
registration
let C80 , C81 being non  empty set;
let C82 being set;
cluster ( MAJ3 (C80 , C81 , C82) ) -> non  empty;
coherence by L65;
cluster ( MAJ3 (C80 , C82 , C81) ) -> non  empty;
coherence by L65;
cluster ( MAJ3 (C82 , C80 , C81) ) -> non  empty;
coherence by L65;
end;
registration
let C83 , C84 being  empty set;
let C85 being set;
cluster ( MAJ3 (C83 , C84 , C85) ) ->  empty;
coherence by L65;
cluster ( MAJ3 (C83 , C85 , C84) ) ->  empty;
coherence by L65;
cluster ( MAJ3 (C85 , C83 , C84) ) ->  empty;
coherence by L65;
end;
theorem
L69: (for R1 being set holds (for R2 being set holds (for R3 being set holds (( MAJ3 (R1 , R2 , R3) ) is non  empty iff ((R1 is non  empty & R2 is non  empty) or (R2 is non  empty & R3 is non  empty) or (R3 is non  empty & R1 is non  empty))))));
definition
let C86 , C87 , C88 being set;
func NAND3 (C86 , C87 , C88) equals 
:L70: ( NOT1 ( {} ) ) if (not (C86 is non  empty & C87 is non  empty & C88 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L72: (for R1 being set holds (for R2 being set holds (for R3 being set holds (( NAND3 (R1 , R2 , R3) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty & R3 is non  empty)))))) by L70;
definition
let C89 , C90 , C91 being set;
func NOR3 (C89 , C90 , C91) equals 
:L73: ( NOT1 ( {} ) ) if (not (C89 is non  empty or C90 is non  empty or C91 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L75: (for R1 being set holds (for R2 being set holds (for R3 being set holds (( NOR3 (R1 , R2 , R3) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty or R3 is non  empty)))))) by L73;
definition
let C92 , C93 , C94 , C95 being set;
func AND4 (C92 , C93 , C94 , C95) equals 
:L76: ( NOT1 ( {} ) ) if (C92 is non  empty & C93 is non  empty & C94 is non  empty & C95 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L78: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (( AND4 (R1 , R2 , R3 , R4) ) is non  empty iff (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty)))))) by L76;
definition
let C96 , C97 , C98 , C99 being set;
func OR4 (C96 , C97 , C98 , C99) equals 
:L79: ( NOT1 ( {} ) ) if (C96 is non  empty or C97 is non  empty or C98 is non  empty or C99 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L81: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (( OR4 (R1 , R2 , R3 , R4) ) is non  empty iff (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty)))))) by L79;
definition
let C100 , C101 , C102 , C103 being set;
func NAND4 (C100 , C101 , C102 , C103) equals 
:L82: ( NOT1 ( {} ) ) if (not (C100 is non  empty & C101 is non  empty & C102 is non  empty & C103 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L84: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (( NAND4 (R1 , R2 , R3 , R4) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty))))))) by L82;
definition
let C104 , C105 , C106 , C107 being set;
func NOR4 (C104 , C105 , C106 , C107) equals 
:L85: ( NOT1 ( {} ) ) if (not (C104 is non  empty or C105 is non  empty or C106 is non  empty or C107 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L87: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (( NOR4 (R1 , R2 , R3 , R4) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty))))))) by L85;
definition
let C108 , C109 , C110 , C111 , C112 being set;
func AND5 (C108 , C109 , C110 , C111 , C112) equals 
:L88: ( NOT1 ( {} ) ) if (C108 is non  empty & C109 is non  empty & C110 is non  empty & C111 is non  empty & C112 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L90: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (( AND5 (R1 , R2 , R3 , R4 , R5) ) is non  empty iff (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty))))))) by L88;
definition
let C113 , C114 , C115 , C116 , C117 being set;
func OR5 (C113 , C114 , C115 , C116 , C117) equals 
:L91: ( NOT1 ( {} ) ) if (C113 is non  empty or C114 is non  empty or C115 is non  empty or C116 is non  empty or C117 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L93: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (( OR5 (R1 , R2 , R3 , R4 , R5) ) is non  empty iff (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty))))))) by L91;
definition
let C118 , C119 , C120 , C121 , C122 being set;
func NAND5 (C118 , C119 , C120 , C121 , C122) equals 
:L94: ( NOT1 ( {} ) ) if (not (C118 is non  empty & C119 is non  empty & C120 is non  empty & C121 is non  empty & C122 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L96: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (( NAND5 (R1 , R2 , R3 , R4 , R5) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty)))))))) by L94;
definition
let C123 , C124 , C125 , C126 , C127 being set;
func NOR5 (C123 , C124 , C125 , C126 , C127) equals 
:L97: ( NOT1 ( {} ) ) if (not (C123 is non  empty or C124 is non  empty or C125 is non  empty or C126 is non  empty or C127 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L99: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (( NOR5 (R1 , R2 , R3 , R4 , R5) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty)))))))) by L97;
definition
let C128 , C129 , C130 , C131 , C132 , C133 being set;
func AND6 (C128 , C129 , C130 , C131 , C132 , C133) equals 
:L100: ( NOT1 ( {} ) ) if (C128 is non  empty & C129 is non  empty & C130 is non  empty & C131 is non  empty & C132 is non  empty & C133 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L102: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (( AND6 (R1 , R2 , R3 , R4 , R5 , R6) ) is non  empty iff (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty & R6 is non  empty)))))))) by L100;
definition
let C134 , C135 , C136 , C137 , C138 , C139 being set;
func OR6 (C134 , C135 , C136 , C137 , C138 , C139) equals 
:L103: ( NOT1 ( {} ) ) if (C134 is non  empty or C135 is non  empty or C136 is non  empty or C137 is non  empty or C138 is non  empty or C139 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L105: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (( OR6 (R1 , R2 , R3 , R4 , R5 , R6) ) is non  empty iff (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty or R6 is non  empty)))))))) by L103;
definition
let C140 , C141 , C142 , C143 , C144 , C145 being set;
func NAND6 (C140 , C141 , C142 , C143 , C144 , C145) equals 
:L106: ( NOT1 ( {} ) ) if (not (C140 is non  empty & C141 is non  empty & C142 is non  empty & C143 is non  empty & C144 is non  empty & C145 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L108: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (( NAND6 (R1 , R2 , R3 , R4 , R5 , R6) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty & R6 is non  empty))))))))) by L106;
definition
let C146 , C147 , C148 , C149 , C150 , C151 being set;
func NOR6 (C146 , C147 , C148 , C149 , C150 , C151) equals 
:L109: ( NOT1 ( {} ) ) if (not (C146 is non  empty or C147 is non  empty or C148 is non  empty or C149 is non  empty or C150 is non  empty or C151 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L111: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (( NOR6 (R1 , R2 , R3 , R4 , R5 , R6) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty or R6 is non  empty))))))))) by L109;
definition
let C152 , C153 , C154 , C155 , C156 , C157 , C158 being set;
func AND7 (C152 , C153 , C154 , C155 , C156 , C157 , C158) equals 
:L112: ( NOT1 ( {} ) ) if (C152 is non  empty & C153 is non  empty & C154 is non  empty & C155 is non  empty & C156 is non  empty & C157 is non  empty & C158 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L114: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (( AND7 (R1 , R2 , R3 , R4 , R5 , R6 , R7) ) is non  empty iff (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty & R6 is non  empty & R7 is non  empty))))))))) by L112;
definition
let C159 , C160 , C161 , C162 , C163 , C164 , C165 being set;
func OR7 (C159 , C160 , C161 , C162 , C163 , C164 , C165) equals 
:L115: ( NOT1 ( {} ) ) if (C159 is non  empty or C160 is non  empty or C161 is non  empty or C162 is non  empty or C163 is non  empty or C164 is non  empty or C165 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L117: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (( OR7 (R1 , R2 , R3 , R4 , R5 , R6 , R7) ) is non  empty iff (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty or R6 is non  empty or R7 is non  empty))))))))) by L115;
definition
let C166 , C167 , C168 , C169 , C170 , C171 , C172 being set;
func NAND7 (C166 , C167 , C168 , C169 , C170 , C171 , C172) equals 
:L118: ( NOT1 ( {} ) ) if (not (C166 is non  empty & C167 is non  empty & C168 is non  empty & C169 is non  empty & C170 is non  empty & C171 is non  empty & C172 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L120: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (( NAND7 (R1 , R2 , R3 , R4 , R5 , R6 , R7) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty & R6 is non  empty & R7 is non  empty)))))))))) by L118;
definition
let C173 , C174 , C175 , C176 , C177 , C178 , C179 being set;
func NOR7 (C173 , C174 , C175 , C176 , C177 , C178 , C179) equals 
:L121: ( NOT1 ( {} ) ) if (not (C173 is non  empty or C174 is non  empty or C175 is non  empty or C176 is non  empty or C177 is non  empty or C178 is non  empty or C179 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L123: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (( NOR7 (R1 , R2 , R3 , R4 , R5 , R6 , R7) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty or R6 is non  empty or R7 is non  empty)))))))))) by L121;
definition
let C180 , C181 , C182 , C183 , C184 , C185 , C186 , C187 being set;
func AND8 (C180 , C181 , C182 , C183 , C184 , C185 , C186 , C187) equals 
:L124: ( NOT1 ( {} ) ) if (C180 is non  empty & C181 is non  empty & C182 is non  empty & C183 is non  empty & C184 is non  empty & C185 is non  empty & C186 is non  empty & C187 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L126: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (for R8 being set holds (( AND8 (R1 , R2 , R3 , R4 , R5 , R6 , R7 , R8) ) is non  empty iff (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty & R6 is non  empty & R7 is non  empty & R8 is non  empty)))))))))) by L124;
definition
let C188 , C189 , C190 , C191 , C192 , C193 , C194 , C195 being set;
func OR8 (C188 , C189 , C190 , C191 , C192 , C193 , C194 , C195) equals 
:L127: ( NOT1 ( {} ) ) if (C188 is non  empty or C189 is non  empty or C190 is non  empty or C191 is non  empty or C192 is non  empty or C193 is non  empty or C194 is non  empty or C195 is non  empty) otherwise ( {} );
correctness;
end;
theorem
L129: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (for R8 being set holds (( OR8 (R1 , R2 , R3 , R4 , R5 , R6 , R7 , R8) ) is non  empty iff (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty or R6 is non  empty or R7 is non  empty or R8 is non  empty)))))))))) by L127;
definition
let C196 , C197 , C198 , C199 , C200 , C201 , C202 , C203 being set;
func NAND8 (C196 , C197 , C198 , C199 , C200 , C201 , C202 , C203) equals 
:L130: ( NOT1 ( {} ) ) if (not (C196 is non  empty & C197 is non  empty & C198 is non  empty & C199 is non  empty & C200 is non  empty & C201 is non  empty & C202 is non  empty & C203 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L132: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (for R8 being set holds (( NAND8 (R1 , R2 , R3 , R4 , R5 , R6 , R7 , R8) ) is non  empty iff (not (R1 is non  empty & R2 is non  empty & R3 is non  empty & R4 is non  empty & R5 is non  empty & R6 is non  empty & R7 is non  empty & R8 is non  empty))))))))))) by L130;
definition
let C204 , C205 , C206 , C207 , C208 , C209 , C210 , C211 being set;
func NOR8 (C204 , C205 , C206 , C207 , C208 , C209 , C210 , C211) equals 
:L133: ( NOT1 ( {} ) ) if (not (C204 is non  empty or C205 is non  empty or C206 is non  empty or C207 is non  empty or C208 is non  empty or C209 is non  empty or C210 is non  empty or C211 is non  empty)) otherwise ( {} );
correctness;
end;
theorem
L135: (for R1 being set holds (for R2 being set holds (for R3 being set holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R7 being set holds (for R8 being set holds (( NOR8 (R1 , R2 , R3 , R4 , R5 , R6 , R7 , R8) ) is non  empty iff (not (R1 is non  empty or R2 is non  empty or R3 is non  empty or R4 is non  empty or R5 is non  empty or R6 is non  empty or R7 is non  empty or R8 is non  empty))))))))))) by L133;
begin
theorem
L136: (for B2 , B3 , B4 , B5 , B6 , B7 , B8 , B9 , B10 , B11 , B12 , B13 , B14 , B15 , B16 , B17 , B18 , B19 , B20 being set holds (((( MAJ3 (B3 , B7 , B2) ) is non  empty implies B11 is non  empty) & (( MAJ3 (B4 , B8 , B11) ) is non  empty implies B12 is non  empty) & (( MAJ3 (B5 , B9 , B12) ) is non  empty implies B13 is non  empty) & (( MAJ3 (B6 , B10 , B13) ) is non  empty implies B14 is non  empty) & (B15 is non  empty implies ( OR2 (B3 , B7) ) is non  empty) & (B16 is non  empty implies ( OR2 (B4 , B8) ) is non  empty) & (B17 is non  empty implies ( OR2 (B5 , B9) ) is non  empty) & (B18 is non  empty implies ( OR2 (B6 , B10) ) is non  empty) & (B19 is non  empty implies ( AND5 (B2 , B15 , B16 , B17 , B18) ) is non  empty) & (B20 is non  empty iff ( OR2 (B14 , B19) ) is non  empty)) implies (B14 is non  empty iff B20 is non  empty)))
proof
let C212 , C213 , C214 , C215 , C216 , C217 , C218 , C219 , C220 , C221 , C222 , C223 , C224 , C225 , C226 , C227 , C228 , C229 , C230 being set;
assume that
L137: ((( MAJ3 (C213 , C217 , C212) ) is non  empty implies C221 is non  empty) & (( MAJ3 (C214 , C218 , C221) ) is non  empty implies C222 is non  empty) & (( MAJ3 (C215 , C219 , C222) ) is non  empty implies C223 is non  empty))
and
L138: (( MAJ3 (C216 , C220 , C223) ) is non  empty implies C224 is non  empty)
and
L139: (C225 is non  empty implies ( OR2 (C213 , C217) ) is non  empty)
and
L140: (C226 is non  empty implies ( OR2 (C214 , C218) ) is non  empty)
and
L141: (C227 is non  empty implies ( OR2 (C215 , C219) ) is non  empty)
and
L142: (C228 is non  empty implies ( OR2 (C216 , C220) ) is non  empty)
and
L143: (C229 is non  empty implies ( AND5 (C212 , C225 , C226 , C227 , C228) ) is non  empty)
and
L144: (C230 is non  empty implies ( OR2 (C224 , C229) ) is non  empty)
and
L145: (( OR2 (C224 , C229) ) is non  empty implies C230 is non  empty);
L146:
now
assume L147: C229 is non  empty;
L148: C212 is non  empty by L147 , L143 , L88;
L149: (C215 is non  empty or C219 is non  empty) by L141 , L143 , L147 , L88;
L150: (C214 is non  empty or C218 is non  empty) by L140 , L143 , L147 , L88;
L151: (C216 is non  empty or C220 is non  empty) by L142 , L143 , L147 , L88;
L152: (C213 is non  empty or C217 is non  empty) by L139 , L143 , L147 , L88;
thus L153: ( MAJ3 (C216 , C220 , C223) ) is non  empty by L152 , L137 , L148 , L150 , L149 , L151;
end;
thus L154: (C224 is non  empty implies C230 is non  empty) by L145;
assume L155: C230 is non  empty;
thus L156: thesis by L155 , L138 , L144 , L146;
end;
definition
let C231 , C232 being set;
func MODADD2 (C231 , C232) equals 
:L157: ( NOT1 ( {} ) ) if ((C231 is non  empty or C232 is non  empty) & (not (C231 is non  empty & C232 is non  empty))) otherwise ( {} );
correctness;
commutativity
;
end;
theorem
L159: (for R1 being set holds (for R2 being set holds (( MODADD2 (R1 , R2) ) is non  empty iff ((R1 is non  empty or R2 is non  empty) & (not (R1 is non  empty & R2 is non  empty)))))) by L157;
notation
let C233 , C234 , C235 being set;
synonym ADD1 (C233 , C234 , C235) for XOR3 (C233 , C234 , C235);
synonym CARR1 (C233 , C234 , C235) for MAJ3 (C233 , C234 , C235);
end;
definition
let C236 , C237 , C238 , C239 , C240 being set;
func ADD2 (C238 , C239 , C236 , C237 , C240) equals 
( XOR3 (C238 , C239 , ( CARR1 (C236 , C237 , C240) )) );
coherence;
end;
definition
let C241 , C242 , C243 , C244 , C245 being set;
func CARR2 (C243 , C244 , C241 , C242 , C245) equals 
( MAJ3 (C243 , C244 , ( CARR1 (C241 , C242 , C245) )) );
coherence;
end;
definition
let C246 , C247 , C248 , C249 , C250 , C251 , C252 being set;
func ADD3 (C250 , C251 , C248 , C249 , C246 , C247 , C252) equals 
( XOR3 (C250 , C251 , ( CARR2 (C248 , C249 , C246 , C247 , C252) )) );
coherence;
end;
definition
let C253 , C254 , C255 , C256 , C257 , C258 , C259 being set;
func CARR3 (C257 , C258 , C255 , C256 , C253 , C254 , C259) equals 
( MAJ3 (C257 , C258 , ( CARR2 (C255 , C256 , C253 , C254 , C259) )) );
coherence;
end;
definition
let C260 , C261 , C262 , C263 , C264 , C265 , C266 , C267 , C268 being set;
func ADD4 (C266 , C267 , C264 , C265 , C262 , C263 , C260 , C261 , C268) equals 
( XOR3 (C266 , C267 , ( CARR3 (C264 , C265 , C262 , C263 , C260 , C261 , C268) )) );
coherence;
end;
definition
let C269 , C270 , C271 , C272 , C273 , C274 , C275 , C276 , C277 being set;
func CARR4 (C275 , C276 , C273 , C274 , C271 , C272 , C269 , C270 , C277) equals 
( MAJ3 (C275 , C276 , ( CARR3 (C273 , C274 , C271 , C272 , C269 , C270 , C277) )) );
coherence;
end;
theorem
L167: (for B21 , B22 , B23 , B24 , B25 , B26 , B27 , B28 , B29 , B30 , B31 , B32 , B33 , B34 , B35 , B36 , B37 , B38 , B39 , B40 , B41 , B42 , B43 , B44 , B45 , B46 , B47 , B48 , B49 , B50 , B51 , B52 , B53 , B54 , B55 , B56 , B57 , B58 , B59 , B60 , B61 being set holds (((B31 is non  empty iff ( NOR2 (B22 , B23) ) is non  empty) & (B32 is non  empty iff ( NAND2 (B22 , B23) ) is non  empty) & (B33 is non  empty iff ( MODADD2 (B22 , B23) ) is non  empty) & (B34 is non  empty iff ( NOR2 (B24 , B25) ) is non  empty) & (B35 is non  empty iff ( NAND2 (B24 , B25) ) is non  empty) & (B36 is non  empty iff ( MODADD2 (B24 , B25) ) is non  empty) & (B37 is non  empty iff ( NOR2 (B26 , B27) ) is non  empty) & (B38 is non  empty iff ( NAND2 (B26 , B27) ) is non  empty) & (B39 is non  empty iff ( MODADD2 (B26 , B27) ) is non  empty) & (B40 is non  empty iff ( NOR2 (B28 , B29) ) is non  empty) & (B41 is non  empty iff ( NAND2 (B28 , B29) ) is non  empty) & (B42 is non  empty iff ( MODADD2 (B28 , B29) ) is non  empty) & (B43 is non  empty iff ( NOT1 B21 ) is non  empty) & (B44 is non  empty iff ( NOT1 B43 ) is non  empty) & (B58 is non  empty iff ( XOR2 (B44 , B33) ) is non  empty) & (B45 is non  empty iff ( AND2 (B43 , B32) ) is non  empty) & (B46 is non  empty iff ( NOR2 (B45 , B31) ) is non  empty) & (B59 is non  empty iff ( XOR2 (B46 , B36) ) is non  empty) & (B47 is non  empty iff ( AND2 (B31 , B35) ) is non  empty) & (B48 is non  empty iff ( AND3 (B35 , B32 , B43) ) is non  empty) & (B49 is non  empty iff ( NOR3 (B47 , B48 , B34) ) is non  empty) & (B60 is non  empty iff ( XOR2 (B49 , B39) ) is non  empty) & (B50 is non  empty iff ( AND2 (B34 , B38) ) is non  empty) & (B51 is non  empty iff ( AND3 (B31 , B38 , B35) ) is non  empty) & (B52 is non  empty iff ( AND4 (B38 , B35 , B32 , B43) ) is non  empty) & (B53 is non  empty iff ( NOR4 (B50 , B51 , B52 , B37) ) is non  empty) & (B61 is non  empty iff ( XOR2 (B53 , B42) ) is non  empty) & (B54 is non  empty iff ( AND2 (B37 , B41) ) is non  empty) & (B55 is non  empty iff ( AND3 (B34 , B41 , B38) ) is non  empty) & (B56 is non  empty iff ( AND4 (B31 , B41 , B38 , B35) ) is non  empty) & (B57 is non  empty iff ( AND5 (B41 , B38 , B35 , B32 , B43) ) is non  empty) & (B30 is non  empty iff ( NOR5 (B40 , B54 , B55 , B56 , B57) ) is non  empty)) implies ((B58 is non  empty iff ( ADD1 (B22 , B23 , B21) ) is non  empty) & (B59 is non  empty iff ( ADD2 (B24 , B25 , B22 , B23 , B21) ) is non  empty) & (B60 is non  empty iff ( ADD3 (B26 , B27 , B24 , B25 , B22 , B23 , B21) ) is non  empty) & (B61 is non  empty iff ( ADD4 (B28 , B29 , B26 , B27 , B24 , B25 , B22 , B23 , B21) ) is non  empty) & (B30 is non  empty iff ( CARR4 (B28 , B29 , B26 , B27 , B24 , B25 , B22 , B23 , B21) ) is non  empty))))
proof
let C278 , C279 , C280 , C281 , C282 , C283 , C284 , C285 , C286 , C287 , C288 , C289 , C290 , C291 , C292 , C293 , C294 , C295 , C296 , C297 , C298 , C299 , C300 , C301 , C302 , C303 , C304 , C305 , C306 , C307 , C308 , C309 , C310 , C311 , C312 , C313 , C314 , C315 , C316 , C317 , C318 being set;
assume that
L168: (C288 is non  empty iff ( NOR2 (C279 , C280) ) is non  empty)
and
L169: (C289 is non  empty iff ( NAND2 (C279 , C280) ) is non  empty)
and
L170: (C290 is non  empty iff ( MODADD2 (C279 , C280) ) is non  empty)
and
L171: (C291 is non  empty iff ( NOR2 (C281 , C282) ) is non  empty)
and
L172: (C292 is non  empty iff ( NAND2 (C281 , C282) ) is non  empty)
and
L173: (C293 is non  empty iff ( MODADD2 (C281 , C282) ) is non  empty)
and
L174: (C294 is non  empty iff ( NOR2 (C283 , C284) ) is non  empty)
and
L175: (C295 is non  empty iff ( NAND2 (C283 , C284) ) is non  empty)
and
L176: (C296 is non  empty iff ( MODADD2 (C283 , C284) ) is non  empty)
and
L177: (C297 is non  empty iff ( NOR2 (C285 , C286) ) is non  empty)
and
L178: (C298 is non  empty iff ( NAND2 (C285 , C286) ) is non  empty)
and
L179: (C299 is non  empty iff ( MODADD2 (C285 , C286) ) is non  empty)
and
L180: (C300 is non  empty iff ( NOT1 C278 ) is non  empty)
and
L181: ((C301 is non  empty iff ( NOT1 C300 ) is non  empty) & (C315 is non  empty iff ( XOR2 (C301 , C290) ) is non  empty))
and
L182: (C302 is non  empty iff ( AND2 (C300 , C289) ) is non  empty)
and
L183: ((C303 is non  empty iff ( NOR2 (C302 , C288) ) is non  empty) & (C316 is non  empty iff ( XOR2 (C303 , C293) ) is non  empty))
and
L184: (C304 is non  empty iff ( AND2 (C288 , C292) ) is non  empty)
and
L185: (C305 is non  empty iff ( AND3 (C292 , C289 , C300) ) is non  empty)
and
L186: ((C306 is non  empty iff ( NOR3 (C304 , C305 , C291) ) is non  empty) & (C317 is non  empty iff ( XOR2 (C306 , C296) ) is non  empty))
and
L187: (C307 is non  empty iff ( AND2 (C291 , C295) ) is non  empty)
and
L188: ((C308 is non  empty iff ( AND3 (C288 , C295 , C292) ) is non  empty) & (C309 is non  empty iff ( AND4 (C295 , C292 , C289 , C300) ) is non  empty) & (C310 is non  empty iff ( NOR4 (C307 , C308 , C309 , C294) ) is non  empty) & (C318 is non  empty iff ( XOR2 (C310 , C299) ) is non  empty))
and
L189: (C311 is non  empty iff ( AND2 (C294 , C298) ) is non  empty)
and
L190: ((C312 is non  empty iff ( AND3 (C291 , C298 , C295) ) is non  empty) & (C313 is non  empty iff ( AND4 (C288 , C298 , C295 , C292) ) is non  empty) & (C314 is non  empty iff ( AND5 (C298 , C295 , C292 , C289 , C300) ) is non  empty))
and
L191: (C287 is non  empty iff ( NOR5 (C297 , C311 , C312 , C313 , C314) ) is non  empty);
L192: (C289 is non  empty iff (not (C279 is non  empty & C280 is non  empty))) by L169;
L193: (C290 is non  empty iff ((C279 is non  empty or C280 is non  empty) & (not (C279 is non  empty & C280 is non  empty)))) by L170 , L157;
thus L194:now
assume L195: C315 is non  empty;
per cases  by L180 , L181 , L195;
suppose L196: (C278 is non  empty & C290 is  empty);

thus L197: ( ADD1 (C279 , C280 , C278) ) is non  empty by L196 , L193;
end;
suppose L198: (C278 is  empty & C290 is non  empty);

thus L199: ( ADD1 (C279 , C280 , C278) ) is non  empty by L198 , L193;
end;
end;
thus L201:now
assume L202: ( ADD1 (C279 , C280 , C278) ) is non  empty;
per cases  by L193 , L202;
suppose L203: (C278 is non  empty & C290 is  empty);

thus L204: C315 is non  empty by L203 , L180 , L181;
end;
suppose L205: (C278 is  empty & C290 is non  empty);

thus L206: C315 is non  empty by L205 , L180 , L181;
end;
end;
L208: (C288 is non  empty iff (not (C279 is non  empty or C280 is non  empty))) by L168;
L209: (C293 is non  empty iff ((C281 is non  empty or C282 is non  empty) & (not (C281 is non  empty & C282 is non  empty)))) by L173 , L157;
thus L210:now
assume L211: C316 is non  empty;
per cases  by L180 , L182 , L183 , L211;
suppose L212: ((C278 is non  empty or C289 is  empty) & C288 is  empty & C293 is  empty);

thus L213: ( ADD2 (C281 , C282 , C279 , C280 , C278) ) is non  empty by L212 , L208 , L192 , L209;
end;
suppose L214: (((C278 is  empty & C289 is non  empty) or C288 is non  empty) & C293 is non  empty);

thus L215: ( ADD2 (C281 , C282 , C279 , C280 , C278) ) is non  empty by L214 , L208 , L192 , L209;
end;
end;
L217: (C300 is non  empty iff (not C278 is non  empty)) by L180;
thus L218:now
assume L219: ( ADD2 (C281 , C282 , C279 , C280 , C278) ) is non  empty;
per cases  by L182 , L208 , L192 , L209 , L217 , L219;
suppose L220: (C302 is  empty & C288 is  empty & C293 is  empty);

thus L221: C316 is non  empty by L220 , L183;
end;
suppose L222: ((C302 is non  empty or C288 is non  empty) & C293 is non  empty);

thus L223: C316 is non  empty by L222 , L183;
end;
end;
L225: (C291 is non  empty iff (not (C281 is non  empty or C282 is non  empty))) by L171;
L226: (C292 is non  empty iff (not (C281 is non  empty & C282 is non  empty))) by L172;
L227: (C296 is non  empty iff ((C283 is non  empty or C284 is non  empty) & (not (C283 is non  empty & C284 is non  empty)))) by L176 , L157;
thus L228:now
assume L229: C317 is non  empty;
per cases  by L176 , L186 , L229 , L73 , L157;
suppose L230: (C304 is  empty & C305 is  empty & C291 is  empty & C283 is  empty & C284 is  empty);

thus L231: ( ADD3 (C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L230 , L184 , L185 , L208 , L192 , L225 , L226 , L217;
end;
suppose L232: (C304 is  empty & C305 is  empty & C291 is  empty & C283 is non  empty & C284 is non  empty);

thus L233: ( ADD3 (C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L232 , L184 , L185 , L208 , L192 , L225 , L226 , L217;
end;
suppose L234: (C304 is non  empty & C296 is non  empty);

L235: (C281 is  empty or C282 is  empty) by L234 , L172 , L184;
L236: (C279 is  empty & C280 is  empty) by L168 , L184 , L234;
thus L237: ( ADD3 (C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L236 , L227 , L234 , L235;
end;
suppose L238: (C305 is non  empty & C296 is non  empty);

L239: C278 is  empty by L238 , L180 , L185;
thus L240: ( ADD3 (C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L239 , L185 , L192 , L226 , L227 , L238;
end;
suppose L241: (C291 is non  empty & C296 is non  empty);

thus L242: ( ADD3 (C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L241 , L225 , L227;
end;
end;
thus L244:now
assume L245: ( ADD3 (C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty;
per cases  by L184 , L185 , L208 , L192 , L225 , L226 , L227 , L217 , L245;
suppose L246: (C304 is  empty & C305 is  empty & C291 is  empty & C283 is  empty & C284 is  empty);

thus L247: C317 is non  empty by L246 , L176 , L186 , L73 , L157;
end;
suppose L248: (C304 is  empty & C305 is  empty & C291 is  empty & C283 is non  empty & C284 is non  empty);

thus L249: C317 is non  empty by L248 , L176 , L186 , L73 , L157;
end;
suppose L250: (C304 is non  empty & C296 is non  empty);

thus L251: C317 is non  empty by L250 , L186 , L73;
end;
suppose L252: (C305 is non  empty & C296 is non  empty);

thus L253: C317 is non  empty by L252 , L186 , L73;
end;
suppose L254: (C291 is non  empty & C296 is non  empty);

thus L255: C317 is non  empty by L254 , L186 , L73;
end;
end;
L257: (C295 is non  empty iff (not (C283 is non  empty & C284 is non  empty))) by L175;
L258: (C299 is non  empty iff ((C285 is non  empty or C286 is non  empty) & (not (C285 is non  empty & C286 is non  empty)))) by L179 , L157;
L259: (C294 is non  empty iff (not (C283 is non  empty or C284 is non  empty))) by L174;
thus L260:now
assume L261: C318 is non  empty;
per cases  by L180 , L188 , L261 , L76 , L85;
suppose L262: (C307 is  empty & (C288 is  empty or C295 is  empty or C292 is  empty) & (C295 is  empty or C292 is  empty or C289 is  empty or C278 is non  empty) & C294 is  empty & C299 is  empty);

thus L263: ( ADD4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L262 , L187 , L208 , L192 , L225 , L226 , L259 , L257 , L258;
end;
suppose L264: (C307 is non  empty & C299 is non  empty);

thus L265: ( ADD4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L264 , L187 , L225 , L257 , L258;
end;
suppose L266: (C288 is non  empty & C295 is non  empty & C292 is non  empty & C299 is non  empty);

thus L267: ( ADD4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L266 , L208 , L226 , L257 , L258;
end;
suppose L268: (C295 is non  empty & C292 is non  empty & C289 is non  empty & C278 is  empty & C299 is non  empty);

thus L269: ( ADD4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L268 , L192 , L226 , L257 , L258;
end;
suppose L270: (C294 is non  empty & C299 is non  empty);

thus L271: ( ADD4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L270 , L259 , L258;
end;
end;
thus L273:now
assume L274: ( ADD4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty;
thus L275: C318 is non  empty
proof
assume L276: C318 is  empty;
per cases  by L180 , L188 , L276 , L76 , L85;
suppose L277: (C307 is  empty & (C288 is  empty or C295 is  empty or C292 is  empty) & (C295 is  empty or C292 is  empty or C289 is  empty or C278 is non  empty) & C294 is  empty & C299 is non  empty);

thus L278: thesis by L277 , L187 , L208 , L192 , L225 , L226 , L259 , L257 , L258 , L274;
end;
suppose L279: (C307 is non  empty & C299 is  empty);

thus L280: thesis by L279 , L187 , L225 , L257 , L258 , L274;
end;
suppose L281: (C288 is non  empty & C295 is non  empty & C292 is non  empty & C299 is  empty);

thus L282: thesis by L281 , L208 , L226 , L257 , L258 , L274;
end;
suppose L283: (C295 is non  empty & C292 is non  empty & C289 is non  empty & C278 is  empty & C299 is  empty);

thus L284: thesis by L283 , L192 , L226 , L257 , L258 , L274;
end;
suppose L285: (C294 is non  empty & C299 is  empty);

thus L286: thesis by L285 , L259 , L258 , L274;
end;
end;

end;
L276: (C298 is non  empty iff (not (C285 is non  empty & C286 is non  empty))) by L178;
L277: (C297 is non  empty iff (not (C285 is non  empty or C286 is non  empty))) by L177;
L278:
now
assume that
L279: C297 is  empty
and
L280: C311 is  empty
and
L281: (C312 is  empty & C313 is  empty & C314 is  empty);
per cases  by L180 , L190 , L281 , L76 , L88;
suppose L282: C298 is  empty;

thus L283: ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L282 , L276;
end;
suppose L284: C295 is  empty;

thus L285: ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L284 , L257 , L277 , L279;
end;
suppose L286: (C292 is  empty & C291 is  empty);

thus L287: ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L286 , L189 , L226 , L259 , L277 , L276 , L279 , L280;
end;
suppose L288: (C289 is  empty & C291 is  empty);

thus L289: ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L288 , L189 , L192 , L225 , L259 , L277 , L276 , L279 , L280;
end;
suppose L290: (C278 is non  empty & C288 is  empty & C291 is  empty);

thus L291: ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty by L290 , L189 , L208 , L225 , L259 , L277 , L276 , L279 , L280;
end;
end;
thus L293: (C287 is non  empty implies ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty) by L278 , L191 , L97;
assume L294: ( CARR4 (C285 , C286 , C283 , C284 , C281 , C282 , C279 , C280 , C278) ) is non  empty;
assume L295: C287 is  empty;
per cases  by L180 , L189 , L190 , L191 , L295 , L76 , L88 , L97;
suppose L296: C297 is non  empty;

thus L297: thesis by L296 , L277 , L294;
end;
suppose L298: (C294 is non  empty & C298 is non  empty);

thus L299: thesis by L298 , L259 , L276 , L294;
end;
suppose L300: (C291 is non  empty & C298 is non  empty & C295 is non  empty);

thus L301: thesis by L300 , L225 , L257 , L276 , L294;
end;
suppose L302: (C288 is non  empty & C298 is non  empty & C295 is non  empty & C292 is non  empty);

thus L303: thesis by L302 , L208 , L226 , L257 , L276 , L294;
end;
suppose L304: (C298 is non  empty & C295 is non  empty & C292 is non  empty & C289 is non  empty & C278 is  empty);

thus L305: thesis by L304 , L192 , L226 , L257 , L276 , L294;
end;
end;
