:: Many-Argument Relations
::  by Edmund Woronowicz
::
:: Received June 1, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, NUMBERS, XBOOLE_0, FUNCOP_1, FUNCT_2, RELAT_1, TARSKI,
      FINSEQ_1, CARD_3, FUNCT_1, ZFMISC_1, ORDINAL4, CARD_1, XBOOLEAN,
      MARGREL1, PARTFUN1, NAT_1, UNIALG_1, FINSEQ_2, UNIALG_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ORDINAL1, FUNCT_1,
      RELAT_1, NAT_1, FUNCT_2, XBOOLEAN, CARD_3, FINSEQ_1, FINSEQ_2, FUNCOP_1,
      PARTFUN1;
 constructors FUNCOP_1, XCMPLX_0, FINSEQ_1, XBOOLEAN, RELSET_1, CARD_3,
      FINSEQ_2;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, XBOOLEAN, FINSEQ_1,
      FINSEQ_2, ORDINAL1, RELSET_1, PARTFUN1, FUNCOP_1, XXREAL_0, CARD_1,
      CARD_3, FUNCT_2;
 requirements SUBSET, BOOLE, ARITHM;
 definitions TARSKI, XBOOLE_0, XBOOLEAN, FINSEQ_1, CARD_3, FUNCT_1, FUNCOP_1;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, FUNCT_2, FUNCOP_1, XBOOLE_0, XBOOLE_1,
      XBOOLEAN, FUNCT_1, CARD_3, FINSEQ_3, RELAT_1, RELSET_1, PARTFUN1,
      ORDINAL1, FINSEQ_2;
 schemes XBOOLE_0, FUNCT_1;

begin
definition
let C1 being non  empty set;
let C2 being set;
let C3 being (Element of C1);
redefine func C2 --> C3 -> (Function of C2 , C1);

coherence
proof
set D1 = ( C2 --> C3 );
L1: ( dom D1 ) = C2 by FUNCOP_1:13;
thus L2: thesis by L1;
end;
end;
definition
let C4 being  FinSequence-membered set;
redefine attr C4 is  with_common_domain
means
:L4: (for B1 , B2 being FinSequence holds ((B1 in C4 & B2 in C4) implies ( len B1 ) = ( len B2 )));
compatibility
proof
thus L5: (C4 is  with_common_domain implies (for B3 , B4 being FinSequence holds ((B3 in C4 & B4 in C4) implies ( len B3 ) = ( len B4 ))))
proof
assume L6: C4 is  with_common_domain;
let C5 , C6 being FinSequence;
assume L7: (C5 in C4 & C6 in C4);
L8: ( dom C5 ) = ( dom C6 ) by L7 , L6 , CARD_3:def 10;
thus L9: ( len C5 ) = ( len C6 ) by L8 , FINSEQ_3:29;
end;

assume L10: (for B5 , B6 being FinSequence holds ((B5 in C4 & B6 in C4) implies ( len B5 ) = ( len B6 )));
let C7 , C8 being Function;
assume L11: (C7 in C4 & C8 in C4);
reconsider D2 = C7 , D3 = C8 as FinSequence by L11;
L12: ( len D2 ) = ( len D3 ) by L10 , L11;
thus L13: thesis by L12 , FINSEQ_3:29;
end;
end;
registration
cluster  FinSequence-membered  with_common_domain for set;
existence
proof
take ( {} );
thus L15: ((for B7 being set holds (B7 in ( {} ) implies B7 is FinSequence)) & (for B8 , B9 being FinSequence holds ((B8 in ( {} ) & B9 in ( {} )) implies ( len B8 ) = ( len B9 ))));
end;
end;
definition
mode relation
 is  FinSequence-membered  with_common_domain set;
end;
theorem
L18: (for R5 being set holds (for R6 being relation holds (R5 c= R6 implies R5 is relation)));
theorem
L19: (for R8 being FinSequence holds { R8 } is relation)
proof
let R8 being FinSequence;
L20: (for R2 being set holds (R2 in { R8 } implies R2 is FinSequence)) by TARSKI:def 1;
reconsider D4 = { R8 } as  FinSequence-membered set by L20 , FINSEQ_1:def 18;
L21: D4 is  with_common_domain;
thus L22: thesis by L21;
end;
scheme relexist { F1() -> set , P1[FinSequence] } : (ex R7 being relation st (for R8 being FinSequence holds (R8 in R7 iff (R8 in F1() & P1[ R8 ]))))
provided
L23: (for R8 being FinSequence holds (for R11 being FinSequence holds ((P1[ R8 ] & P1[ R11 ]) implies ( len R8 ) = ( len R11 ))))
proof
defpred S1[ set ] means (ex R8 being FinSequence st (P1[ R8 ] & $1 = R8));
consider R5 being set such that L24: (for R1 being set holds (R1 in R5 iff (R1 in F1() & S1[ R1 ]))) from XBOOLE_0:sch 1;
L25: R5 is  FinSequence-membered
proof
let C9 being set;
assume L26: C9 in R5;
L27: (ex R8 being FinSequence st (P1[ R8 ] & C9 = R8)) by L26 , L24;
thus L28: thesis by L27;
end;
reconsider D5 = R5 as  FinSequence-membered set by L25;
L29: D5 is  with_common_domain
proof
let R8 being FinSequence;
let R11 being FinSequence;
assume that
L30: R8 in D5
and
L31: R11 in D5;
L32: (ex B10 being FinSequence st (P1[ B10 ] & R11 = B10)) by L24 , L31;
L33: (ex B11 being FinSequence st (P1[ B11 ] & R8 = B11)) by L24 , L30;
thus L34: thesis by L33 , L23 , L32;
end;
reconsider D6 = D5 as relation by L29;
L35: (for R8 being FinSequence holds (R8 in D6 iff (R8 in F1() & P1[ R8 ])))
proof
let R8 being FinSequence;
L36:
now
assume L37: R8 in D6;
L38: (ex B12 being FinSequence st (P1[ B12 ] & R8 = B12)) by L37 , L24;
thus L39: (R8 in F1() & P1[ R8 ]) by L38 , L24 , L37;
end;
thus L40: thesis by L36 , L24;
end;
thus L41: thesis by L35;
end;
definition
let R6 being relation;
let R7 being relation;
redefine pred R6 = R7
means
(for R8 being FinSequence holds (R8 in R6 iff R8 in R7))
;compatibility
proof
thus L42: (R6 = R7 implies (for R8 being FinSequence holds (R8 in R6 iff R8 in R7)));
thus L43: ((for R8 being FinSequence holds (R8 in R6 iff R8 in R7)) implies R6 = R7)
proof
assume L44: (for R8 being FinSequence holds (R8 in R6 iff R8 in R7));
L45: (for R1 being set holds (R1 in R6 iff R1 in R7)) by L44;
thus L46: thesis by L45 , TARSKI:1;
end;

end;
end;
registration
cluster  empty ->  with_common_domain for set;
coherence
proof
let C10 being set;
assume L45: C10 is  empty;
L46: (for B13 , B14 being FinSequence holds ((B13 in C10 & B14 in C10) implies ( len B13 ) = ( len B14 ))) by L45;
thus L47: thesis by L46 , L4 , L45;
end;
end;
theorem
L49: (for R6 being relation holds ((for R8 being FinSequence holds (not R8 in R6)) implies R6 = ( {} )))
proof
let R6 being relation;
assume that
L50: (for R8 being FinSequence holds (not R8 in R6));
assume L51: R6 <> ( {} );
L52: (ex B15 being set st B15 in R6) by L51 , XBOOLE_0:def 1;
thus L53: contradiction by L52 , L50;
end;
definition
let R6 being relation;
assume L54: R6 <> ( {} );
func the_arity_of R6 -> (Element of ( NAT )) means 
(for R8 being FinSequence holds (R8 in R6 implies it = ( len R8 )));
existence
proof
consider C11 being FinSequence such that L55: C11 in R6 by L54 , L49;
L56: (for R8 being FinSequence holds (R8 in R6 implies ( len C11 ) = ( len R8 ))) by L55 , L4;
thus L57: thesis by L56;
end;
uniqueness
proof
let C12 , C13 being (Element of ( NAT ));
assume that
L58: (for R8 being FinSequence holds (R8 in R6 implies C12 = ( len R8 )))
and
L59: (for R8 being FinSequence holds (R8 in R6 implies C13 = ( len R8 )));
consider R8 being FinSequence such that L60: R8 in R6 by L54 , L49;
L61: ( len R8 ) = C12 by L58 , L60;
thus L62: thesis by L61 , L59 , L60;
end;
end;
definition
let R3 being (Element of ( NAT ));
mode relation_length of R3
 -> relation
means (for R8 being FinSequence holds (R8 in it implies ( len R8 ) = R3));
existence
proof
take ( {} );
thus L64: thesis;
end;
end;
definition
let C14 being set;
mode relation of C14
 -> relation
means (for R8 being FinSequence holds (R8 in it implies ( rng R8 ) c= C14));
existence
proof
take ( {} );
thus L66: thesis;
end;
end;
theorem
L68: (for R5 being set holds ( {} ) is (relation of R5))
proof
let R5 being set;
thus L69: (for R8 being FinSequence holds (R8 in ( {} ) implies ( rng R8 ) c= R5));
end;
theorem
L70: (for R3 being (Element of ( NAT )) holds ( {} ) is (relation_length of R3))
proof
let R3 being (Element of ( NAT ));
thus L71: (for R8 being FinSequence holds (R8 in ( {} ) implies ( len R8 ) = R3));
end;
definition
let R5 being set;
let R3 being (Element of ( NAT ));
mode relation of R5 , R3
 -> relation
means (it is (relation of R5) & it is (relation_length of R3));
existence
proof
take ( {} );
thus L72: thesis by L68 , L70;
end;
end;
definition
let R4 being non  empty set;
func relations_on R4 -> set means 
:L74: (for R5 being set holds (R5 in it iff (R5 c= ( R4 * ) & (for B16 , B17 being (FinSequence of R4) holds ((B16 in R5 & B17 in R5) implies ( len B16 ) = ( len B17 ))))));
existence
proof
defpred S2[ set ] means (ex B18 being set st (B18 = $1 & B18 c= ( R4 * ) & (for B19 , B20 being (FinSequence of R4) holds ((B19 in B18 & B20 in B18) implies ( len B19 ) = ( len B20 )))));
consider C15 being set such that L75: (for R1 being set holds (R1 in C15 iff (R1 in ( bool ( R4 * ) ) & S2[ R1 ]))) from XBOOLE_0:sch 1;
take C15;
L76: (for B21 being set holds (B21 in C15 iff (B21 c= ( R4 * ) & (for B22 , B23 being (FinSequence of R4) holds ((B22 in B21 & B23 in B21) implies ( len B22 ) = ( len B23 ))))))
proof
let C16 being set;
thus L77: (C16 in C15 implies (C16 c= ( R4 * ) & (for B24 , B25 being (FinSequence of R4) holds ((B24 in C16 & B25 in C16) implies ( len B24 ) = ( len B25 )))))
proof
assume L78: C16 in C15;
L79: (ex B26 being set st (B26 = C16 & B26 c= ( R4 * ) & (for B27 , B28 being (FinSequence of R4) holds ((B27 in B26 & B28 in B26) implies ( len B27 ) = ( len B28 ))))) by L78 , L75;
thus L80: thesis by L79;
end;

thus L81: thesis by L75;
end;
thus L82: thesis by L76;
end;
uniqueness
proof
let C17 , C18 being set;
assume that
L83: (for B29 being set holds (B29 in C17 iff (B29 c= ( R4 * ) & (for B30 , B31 being (FinSequence of R4) holds ((B30 in B29 & B31 in B29) implies ( len B30 ) = ( len B31 ))))))
and
L84: (for B32 being set holds (B32 in C18 iff (B32 c= ( R4 * ) & (for B33 , B34 being (FinSequence of R4) holds ((B33 in B32 & B34 in B32) implies ( len B33 ) = ( len B34 ))))));
L85: (for B35 being set holds (B35 in C17 iff B35 in C18))
proof
let R1 being set;
thus L86: (R1 in C17 implies R1 in C18)
proof
assume L87: R1 in C17;
L88: (for B36 , B37 being (FinSequence of R4) holds ((B36 in R1 & B37 in R1) implies ( len B36 ) = ( len B37 ))) by L87 , L83;
L89: R1 c= ( R4 * ) by L83 , L87;
thus L90: thesis by L89 , L84 , L88;
end;

thus L91: (R1 in C18 implies R1 in C17)
proof
assume L92: R1 in C18;
L93: (for B38 , B39 being (FinSequence of R4) holds ((B38 in R1 & B39 in R1) implies ( len B38 ) = ( len B39 ))) by L92 , L84;
L94: R1 c= ( R4 * ) by L84 , L92;
thus L95: thesis by L94 , L83 , L93;
end;

end;
thus L92: thesis by L85 , TARSKI:1;
end;
end;
registration
let R4 being non  empty set;
cluster ( relations_on R4 ) -> non  empty;
coherence
proof
L94: (for B40 , B41 being (FinSequence of R4) holds ((B40 in ( {} ) & B41 in ( {} )) implies ( len B40 ) = ( len B41 )));
defpred S3[ set ] means (ex B42 being set st (B42 = $1 & B42 c= ( R4 * ) & (for B43 , B44 being (FinSequence of R4) holds ((B43 in B42 & B44 in B42) implies ( len B43 ) = ( len B44 )))));
consider C19 being set such that L95: (for R1 being set holds (R1 in C19 iff (R1 in ( bool ( R4 * ) ) & S3[ R1 ]))) from XBOOLE_0:sch 1;
L96: ( {} ) c= ( R4 * ) by XBOOLE_1:2;
reconsider D7 = C19 as non  empty set by L96 , L95 , L94;
L97: (for B45 being set holds (B45 in D7 iff (B45 c= ( R4 * ) & (for B46 , B47 being (FinSequence of R4) holds ((B46 in B45 & B47 in B45) implies ( len B46 ) = ( len B47 ))))))
proof
let C20 being set;
thus L98: (C20 in D7 implies (C20 c= ( R4 * ) & (for B48 , B49 being (FinSequence of R4) holds ((B48 in C20 & B49 in C20) implies ( len B48 ) = ( len B49 )))))
proof
assume L99: C20 in D7;
L100: (ex B50 being set st (B50 = C20 & B50 c= ( R4 * ) & (for B51 , B52 being (FinSequence of R4) holds ((B51 in B50 & B52 in B50) implies ( len B51 ) = ( len B52 ))))) by L99 , L95;
thus L101: thesis by L100;
end;

thus L102: thesis by L95;
end;
thus L103: thesis by L97 , L74;
end;
end;
definition
let C21 being non  empty set;
mode relation of C21
 is (Element of ( relations_on C21 ));
end;
theorem
L106: (for R4 being non  empty set holds (for R5 being set holds (for R15 being (Element of ( relations_on R4 )) holds (R5 c= R15 implies R5 is (Element of ( relations_on R4 ))))))
proof
let R4 being non  empty set;
let R5 being set;
let R15 being (Element of ( relations_on R4 ));
assume L107: R5 c= R15;
L108: (for R12 being (FinSequence of R4) holds (for R13 being (FinSequence of R4) holds ((R12 in R5 & R13 in R5) implies ( len R12 ) = ( len R13 )))) by L107 , L74;
L109: R15 c= ( R4 * ) by L74;
L110: R5 c= ( R4 * ) by L109 , L107 , XBOOLE_1:1;
thus L111: thesis by L110 , L108 , L74;
end;
theorem
L112: (for R4 being non  empty set holds (for R12 being (FinSequence of R4) holds { R12 } is (Element of ( relations_on R4 ))))
proof
let R4 being non  empty set;
let R12 being (FinSequence of R4);
L113: (for B53 , B54 being (FinSequence of R4) holds ((B53 in { R12 } & B54 in { R12 }) implies ( len B53 ) = ( len B54 )))
proof
let C22 , C23 being (FinSequence of R4);
assume that
L114: C22 in { R12 }
and
L115: C23 in { R12 };
L116: C22 = R12 by L114 , TARSKI:def 1;
thus L117: thesis by L116 , L115 , TARSKI:def 1;
end;
L118: R12 in ( R4 * ) by FINSEQ_1:def 11;
L119: { R12 } c= ( R4 * ) by L118 , ZFMISC_1:31;
thus L120: thesis by L119 , L113 , L74;
end;
theorem
L121: (for R4 being non  empty set holds (for B55 , B56 being (Element of R4) holds { <* B55 , B56 *> } is (Element of ( relations_on R4 ))))
proof
let R4 being non  empty set;
let C24 , C25 being (Element of R4);
L122: (for B57 , B58 being (FinSequence of R4) holds ((B57 in { <* C24 , C25 *> } & B58 in { <* C24 , C25 *> }) implies ( len B57 ) = ( len B58 )))
proof
let C26 , C27 being (FinSequence of R4);
assume that
L123: C26 in { <* C24 , C25 *> }
and
L124: C27 in { <* C24 , C25 *> };
L125: C26 = <* C24 , C25 *> by L123 , TARSKI:def 1;
thus L126: thesis by L125 , L124 , TARSKI:def 1;
end;
L127: ( <* C24 *> ^ <* C25 *> ) is (FinSequence of R4);
L128: <* C24 , C25 *> in ( R4 * ) by L127 , FINSEQ_1:def 11;
L129: { <* C24 , C25 *> } c= ( R4 * ) by L128 , ZFMISC_1:31;
thus L130: thesis by L129 , L122 , L74;
end;
definition
let R4 being non  empty set;
let R14 being (Element of ( relations_on R4 ));
let R15 being (Element of ( relations_on R4 ));
redefine pred R14 = R15
means
:L131: (for R12 being (FinSequence of R4) holds (R12 in R14 iff R12 in R15))
;compatibility
proof
thus L132: (R14 = R15 implies (for R12 being (FinSequence of R4) holds (R12 in R14 iff R12 in R15)));
thus L133: ((for R12 being (FinSequence of R4) holds (R12 in R14 iff R12 in R15)) implies R14 = R15)
proof
assume L134: (for R12 being (FinSequence of R4) holds (R12 in R14 iff R12 in R15));
L135:
now
let R1 being set;
L136:
now
assume L137: R1 in R15;
L138: R15 is (Subset of ( R4 * )) by L74;
L139: R1 is (FinSequence of R4) by L138 , L137 , FINSEQ_1:def 11;
thus L140: R1 in R14 by L139 , L134 , L137;
end;
L141:
now
assume L142: R1 in R14;
L143: R14 is (Subset of ( R4 * )) by L74;
L144: R1 is (FinSequence of R4) by L143 , L142 , FINSEQ_1:def 11;
thus L145: R1 in R15 by L144 , L134 , L142;
end;
thus L146: (R1 in R14 iff R1 in R15) by L141 , L136;
end;
thus L147: thesis by L135 , TARSKI:1;
end;

end;
end;
scheme relDexist { F2() -> non  empty set , P2[(FinSequence of F2())] } : (ex B59 being (Element of ( relations_on F2() )) st (for B60 being (FinSequence of F2()) holds (B60 in B59 iff P2[ B60 ])))
provided
L135: (for B61 , B62 being (FinSequence of F2()) holds ((P2[ B61 ] & P2[ B62 ]) implies ( len B61 ) = ( len B62 )))
proof
defpred S4[ set ] means (ex B63 being (FinSequence of F2()) st (P2[ B63 ] & $1 = B63));
consider C28 being set such that L136: (for R1 being set holds (R1 in C28 iff (R1 in ( F2() * ) & S4[ R1 ]))) from XBOOLE_0:sch 1;
L137: (for B64 , B65 being (FinSequence of F2()) holds ((B64 in C28 & B65 in C28) implies ( len B64 ) = ( len B65 )))
proof
let C29 , C30 being (FinSequence of F2());
assume that
L138: C29 in C28
and
L139: C30 in C28;
L140: (ex B66 being (FinSequence of F2()) st (P2[ B66 ] & C30 = B66)) by L136 , L139;
L141: (ex B67 being (FinSequence of F2()) st (P2[ B67 ] & C29 = B67)) by L136 , L138;
thus L142: thesis by L141 , L135 , L140;
end;
L143: (for R1 being set holds (R1 in C28 implies R1 in ( F2() * ))) by L136;
L144: C28 c= ( F2() * ) by L143 , TARSKI:def 3;
reconsider D8 = C28 as (Element of ( relations_on F2() )) by L144 , L137 , L74;
L145: (for B68 being (FinSequence of F2()) holds (B68 in D8 iff P2[ B68 ]))
proof
let C31 being (FinSequence of F2());
L146:
now
L147: C31 in ( F2() * ) by FINSEQ_1:def 11;
assume L148: P2[ C31 ];
thus L149: C31 in D8 by L148 , L136 , L147;
end;
L150:
now
assume L151: C31 in D8;
L152: (ex B69 being (FinSequence of F2()) st (P2[ B69 ] & C31 = B69)) by L151 , L136;
thus L153: P2[ C31 ] by L152;
end;
thus L154: thesis by L150 , L146;
end;
thus L155: thesis by L145;
end;
definition
let R4 being non  empty set;
func empty_rel R4 -> (Element of ( relations_on R4 )) means 
:L156: (for R12 being (FinSequence of R4) holds (not R12 in it));
existence
proof
defpred S5[ (FinSequence of R4) ] means contradiction;
L157: (for R12 being (FinSequence of R4) holds (for R13 being (FinSequence of R4) holds ((S5[ R12 ] & S5[ R13 ]) implies ( len R12 ) = ( len R13 ))));
consider R15 being (Element of ( relations_on R4 )) such that L158: (for R12 being (FinSequence of R4) holds (R12 in R15 iff S5[ R12 ])) from relDexist(L157);
take R15;
thus L159: thesis by L158;
end;
uniqueness
proof
let C32 , C33 being (Element of ( relations_on R4 ));
assume that
L160: (for R12 being (FinSequence of R4) holds (not R12 in C32))
and
L161: (for R12 being (FinSequence of R4) holds (not R12 in C33));
L162: (for R12 being (FinSequence of R4) holds (R12 in C32 iff R12 in C33)) by L160 , L161;
thus L163: C32 = C33 by L162 , L131;
end;
end;
theorem
L165: (for R4 being non  empty set holds ( empty_rel R4 ) = ( {} ))
proof
let R4 being non  empty set;
assume L166: (not thesis);
set D9 = the (Element of ( empty_rel R4 ));
L167: ( empty_rel R4 ) is (Subset of ( R4 * )) by L74;
L168: D9 in ( R4 * ) by L167 , L166 , TARSKI:def 3;
reconsider D10 = D9 as (FinSequence of R4) by L168 , FINSEQ_1:def 11;
L169: D10 in ( empty_rel R4 ) by L166;
thus L170: contradiction by L169 , L156;
end;
definition
let R4 being non  empty set;
let R14 being (Element of ( relations_on R4 ));
assume L171: R14 <> ( empty_rel R4 );
func the_arity_of R14 -> (Element of ( NAT )) means 
(for R12 being (FinSequence of R4) holds (R12 in R14 implies it = ( len R12 )));
existence
proof
consider C34 being (FinSequence of R4) such that L172: C34 in R14 by L171 , L156;
L173: (for R12 being (FinSequence of R4) holds (R12 in R14 implies ( len C34 ) = ( len R12 ))) by L172 , L74;
thus L174: thesis by L173;
end;
uniqueness
proof
let C35 , C36 being (Element of ( NAT ));
assume that
L175: (for R12 being (FinSequence of R4) holds (R12 in R14 implies C35 = ( len R12 )))
and
L176: (for R12 being (FinSequence of R4) holds (R12 in R14 implies C36 = ( len R12 )));
consider R12 being (FinSequence of R4) such that L177: R12 in R14 by L171 , L156;
L178: ( len R12 ) = C35 by L175 , L177;
thus L179: thesis by L178 , L176 , L177;
end;
end;
scheme relDexist2 { F3() -> non  empty set , F4() -> (Element of ( NAT )) , P3[(FinSequence of F3())] } : (ex B70 being (Element of ( relations_on F3() )) st (for B71 being (FinSequence of F3()) holds (( len B71 ) = F4() implies (B71 in B70 iff P3[ B71 ]))))
proof
defpred S6[ set ] means (ex B72 being (FinSequence of F3()) st (( len B72 ) = F4() & P3[ B72 ] & $1 = B72));
consider C37 being set such that L181: (for R1 being set holds (R1 in C37 iff (R1 in ( F3() * ) & S6[ R1 ]))) from XBOOLE_0:sch 1;
L182: (for B73 , B74 being (FinSequence of F3()) holds ((B73 in C37 & B74 in C37) implies ( len B73 ) = ( len B74 )))
proof
let C38 , C39 being (FinSequence of F3());
assume that
L183: C38 in C37
and
L184: C39 in C37;
L185: (ex B75 being (FinSequence of F3()) st (( len B75 ) = F4() & P3[ B75 ] & C39 = B75)) by L181 , L184;
L186: (ex B76 being (FinSequence of F3()) st (( len B76 ) = F4() & P3[ B76 ] & C38 = B76)) by L181 , L183;
thus L187: thesis by L186 , L185;
end;
L188: (for R1 being set holds (R1 in C37 implies R1 in ( F3() * ))) by L181;
L189: C37 c= ( F3() * ) by L188 , TARSKI:def 3;
reconsider D11 = C37 as (Element of ( relations_on F3() )) by L189 , L182 , L74;
L190: (for B77 being (FinSequence of F3()) holds (( len B77 ) = F4() implies (B77 in D11 iff P3[ B77 ])))
proof
let C40 being (FinSequence of F3());
assume that
L191: ( len C40 ) = F4();
L192:
now
L193: C40 in ( F3() * ) by FINSEQ_1:def 11;
assume L194: P3[ C40 ];
thus L195: C40 in D11 by L194 , L181 , L191 , L193;
end;
L196:
now
assume L197: C40 in D11;
L198: (ex B78 being (FinSequence of F3()) st (( len B78 ) = F4() & P3[ B78 ] & C40 = B78)) by L197 , L181;
thus L199: P3[ C40 ] by L198;
end;
thus L200: thesis by L196 , L192;
end;
thus L201: thesis by L190;
end;
definition
func BOOLEAN -> set equals 
{ ( 0 ) , 1 };
coherence;
end;
registration
cluster ( BOOLEAN ) -> non  empty;
coherence;
end;
definition
redefine func FALSE -> (Element of ( BOOLEAN ));

coherence by TARSKI:def 2;
redefine func TRUE -> (Element of ( BOOLEAN ));

coherence by TARSKI:def 2;
end;
definition
let C41 being set;
redefine attr C41 is  boolean
means
:L205: C41 in ( BOOLEAN );
compatibility
proof
thus L206:now
assume L207: C41 is  boolean;
L208: (C41 = ( FALSE ) or C41 = ( TRUE )) by L207 , XBOOLEAN:def 3;
thus L209: C41 in ( BOOLEAN ) by L208;
end;
assume L210: C41 in ( BOOLEAN );
thus L211: (C41 = ( FALSE ) or C41 = ( TRUE )) by L210 , TARSKI:def 2;
end;
end;
registration
cluster  ->  boolean for (Element of ( BOOLEAN ));
coherence by L205;
end;
definition
let C42 being  boolean set;
redefine func 'not' C42 equals 
( TRUE ) if C42 = ( FALSE ) otherwise ( FALSE );
compatibility
proof
let R18 being  boolean set;
thus L214: (C42 = ( FALSE ) implies (R18 = ( 'not' C42 ) iff R18 = ( TRUE )));
assume L215: C42 <> ( FALSE );
L216: C42 = ( TRUE ) by L215 , XBOOLEAN:def 3;
thus L217: thesis by L216;
end;
consistency;
let C43 being  boolean set;
redefine func C42 '&' C43 equals 
( TRUE ) if (C42 = ( TRUE ) & C43 = ( TRUE )) otherwise ( FALSE );
compatibility
proof
let C44 being set;
thus L218: ((C42 = ( TRUE ) & C43 = ( TRUE )) implies (C44 = ( C42 '&' C43 ) iff C44 = ( TRUE )));
assume L219: (C42 <> ( TRUE ) or C43 <> ( TRUE ));
L220: (C42 = ( FALSE ) or C43 = ( FALSE )) by L219 , XBOOLEAN:def 3;
thus L221: thesis by L220;
end;
consistency;
end;
definition
let C45 being (Element of ( BOOLEAN ));
redefine func 'not' C45 -> (Element of ( BOOLEAN ));

correctness by L205;
let C46 being (Element of ( BOOLEAN ));
redefine func C45 '&' C46 -> (Element of ( BOOLEAN ));

correctness by L205;
end;
canceled 1;
theorem
L224: (for R17 being  boolean set holds ((R17 = ( FALSE ) iff ( 'not' R17 ) = ( TRUE )) & (R17 = ( TRUE ) iff ( 'not' R17 ) = ( FALSE ))));
theorem
L225: (for R17 being  boolean set holds (for R18 being  boolean set holds ((( R17 '&' R18 ) = ( TRUE ) iff (R17 = ( TRUE ) & R18 = ( TRUE ))) & (( R17 '&' R18 ) = ( FALSE ) iff (R17 = ( FALSE ) or R18 = ( FALSE )))))) by XBOOLEAN:101 , XBOOLEAN:140;
theorem
L226: (for R17 being  boolean set holds ( ( FALSE ) '&' R17 ) = ( FALSE ));
theorem
L227: (for R17 being  boolean set holds ( ( TRUE ) '&' R17 ) = R17);
theorem
L228: (for R17 being  boolean set holds (( R17 '&' R17 ) = ( FALSE ) implies R17 = ( FALSE )));
theorem
L229: (for R16 being  boolean set holds (for R17 being  boolean set holds (for R18 being  boolean set holds ( R17 '&' ( R18 '&' R16 ) ) = ( ( R17 '&' R18 ) '&' R16 ))));
definition
let R5 being set;
func ALL R5 equals 
:L230: ( TRUE ) if (not ( FALSE ) in R5) otherwise ( FALSE );
correctness;
end;
registration
let R5 being set;
cluster ( ALL R5 ) ->  boolean;
correctness by L230;
end;
definition
let R5 being set;
redefine func ALL R5 -> (Element of ( BOOLEAN ));

correctness by L205;
end;
theorem
L234: (for R5 being set holds (((not ( FALSE ) in R5) iff ( ALL R5 ) = ( TRUE )) & (( FALSE ) in R5 iff ( ALL R5 ) = ( FALSE )))) by L230;
begin
definition
let C47 being Relation;
attr C47 is  boolean-valued
means
:L235: ( rng C47 ) c= ( BOOLEAN );
end;
registration
cluster  boolean-valued for Function;
existence
proof
take ( {} );
thus L237: ( rng ( {} ) ) c= ( BOOLEAN ) by XBOOLE_1:2;
end;
end;
registration
let C48 being  boolean-valued Function;
let C49 being set;
cluster ( C48 . C49 ) ->  boolean;
coherence
proof
per cases ;
suppose L239: (not C49 in ( dom C48 ));

L240: ( C48 . C49 ) = ( FALSE ) by L239 , FUNCT_1:def 2;
thus L241: ( C48 . C49 ) in ( BOOLEAN ) by L240;
end;
suppose L242: C49 in ( dom C48 );

L243: ( rng C48 ) c= ( BOOLEAN ) by L235;
L244: ( C48 . C49 ) in ( rng C48 ) by L242 , FUNCT_1:def 3;
thus L245: ( C48 . C49 ) in ( BOOLEAN ) by L244 , L243;
end;
end;
end;
definition
let C50 being  boolean-valued Function;
func 'not' C50 ->  boolean-valued Function means 
:L248: (( dom it ) = ( dom C50 ) & (for B79 being set holds (B79 in ( dom C50 ) implies ( it . B79 ) = ( 'not' ( C50 . B79 ) ))));
existence
proof
deffunc H1(set) = ( 'not' ( C50 . $1 ) );
consider C51 being Function such that L249: ( dom C51 ) = ( dom C50 ) and L250: (for B80 being set holds (B80 in ( dom C50 ) implies ( C51 . B80 ) = H1(B80))) from FUNCT_1:sch 3;
L251: C51 is  boolean-valued
proof
let C52 being set;
assume L252: C52 in ( rng C51 );
consider C53 being set such that L253: C53 in ( dom C51 ) and L254: C52 = ( C51 . C53 ) by L252 , FUNCT_1:def 3;
L255: C52 = ( 'not' ( C50 . C53 ) ) by L249 , L250 , L253 , L254;
L256: (C52 = ( FALSE ) or C52 = ( TRUE )) by L255 , XBOOLEAN:def 3;
thus L257: thesis by L256;
end;
thus L258: thesis by L251 , L249 , L250;
end;
uniqueness
proof
let C54 , C55 being  boolean-valued Function;
assume that
L259: ( dom C54 ) = ( dom C50 )
and
L260: (for B81 being set holds (B81 in ( dom C50 ) implies ( C54 . B81 ) = ( 'not' ( C50 . B81 ) )))
and
L261: ( dom C55 ) = ( dom C50 )
and
L262: (for B82 being set holds (B82 in ( dom C50 ) implies ( C55 . B82 ) = ( 'not' ( C50 . B82 ) )));
L263: (for B83 being set holds (B83 in ( dom C50 ) implies ( C54 . B83 ) = ( C55 . B83 )))
proof
let C56 being set;
assume L264: C56 in ( dom C50 );
L265: ( C54 . C56 ) = ( 'not' ( C50 . C56 ) ) by L264 , L260;
thus L266: thesis by L265 , L262 , L264;
end;
thus L267: thesis by L263 , L259 , L261 , FUNCT_1:2;
end;
involutiveness
proof
let C57 , C58 being  boolean-valued Function;
assume that
L268: ( dom C57 ) = ( dom C58 )
and
L269: (for B84 being set holds (B84 in ( dom C58 ) implies ( C57 . B84 ) = ( 'not' ( C58 . B84 ) )));
thus L270: ( dom C58 ) = ( dom C57 ) by L268;
let C59 being set;
assume L271: C59 in ( dom C57 );
thus L272: ( C58 . C59 ) = ( 'not' ( 'not' ( C58 . C59 ) ) )
.= ( 'not' ( C57 . C59 ) ) by L268 , L269 , L271;
end;
let C60 being  boolean-valued Function;
func C50 '&' C60 ->  boolean-valued Function means 
:L273: (( dom it ) = ( ( dom C50 ) /\ ( dom C60 ) ) & (for B85 being set holds (B85 in ( dom it ) implies ( it . B85 ) = ( ( C50 . B85 ) '&' ( C60 . B85 ) ))));
existence
proof
deffunc H2(set) = ( ( C50 . $1 ) '&' ( C60 . $1 ) );
consider C61 being Function such that L274: ( dom C61 ) = ( ( dom C50 ) /\ ( dom C60 ) ) and L275: (for B86 being set holds (B86 in ( ( dom C50 ) /\ ( dom C60 ) ) implies ( C61 . B86 ) = H2(B86))) from FUNCT_1:sch 3;
L276: C61 is  boolean-valued
proof
let C62 being set;
assume L277: C62 in ( rng C61 );
consider C63 being set such that L278: C63 in ( dom C61 ) and L279: C62 = ( C61 . C63 ) by L277 , FUNCT_1:def 3;
L280: C62 = ( ( C50 . C63 ) '&' ( C60 . C63 ) ) by L274 , L275 , L278 , L279;
L281: (C62 = ( FALSE ) or C62 = ( TRUE )) by L280 , XBOOLEAN:def 3;
thus L282: thesis by L281;
end;
thus L283: thesis by L276 , L274 , L275;
end;
uniqueness
proof
let C64 , C65 being  boolean-valued Function;
assume that
L284: ( dom C64 ) = ( ( dom C50 ) /\ ( dom C60 ) )
and
L285: (for B87 being set holds (B87 in ( dom C64 ) implies ( C64 . B87 ) = ( ( C50 . B87 ) '&' ( C60 . B87 ) )))
and
L286: ( dom C65 ) = ( ( dom C50 ) /\ ( dom C60 ) )
and
L287: (for B88 being set holds (B88 in ( dom C65 ) implies ( C65 . B88 ) = ( ( C50 . B88 ) '&' ( C60 . B88 ) )));
L288: (for B89 being set holds (B89 in ( dom C64 ) implies ( C64 . B89 ) = ( C65 . B89 )))
proof
let C66 being set;
assume L289: C66 in ( dom C64 );
L290: ( C64 . C66 ) = ( ( C50 . C66 ) '&' ( C60 . C66 ) ) by L289 , L285;
thus L291: thesis by L290 , L284 , L286 , L287 , L289;
end;
thus L292: thesis by L288 , L284 , L286 , FUNCT_1:2;
end;
commutativity
;
idempotence
;
end;
registration
let C67 being set;
cluster  ->  boolean-valued for (Function of C67 , ( BOOLEAN ));
coherence
proof
let C68 being (Function of C67 , ( BOOLEAN ));
thus L294: ( rng C68 ) c= ( BOOLEAN ) by RELAT_1:def 19;
end;
end;
definition
let C69 being non  empty set;
let C70 being (Function of C69 , ( BOOLEAN ));
redefine func 'not' C70 -> (Function of C69 , ( BOOLEAN )) means 
(for B90 being (Element of C69) holds ( it . B90 ) = ( 'not' ( C70 . B90 ) ));
coherence
proof
L296: ( dom ( 'not' C70 ) ) = ( dom C70 ) by L248
.= C69 by PARTFUN1:def 2;
L297: ( rng ( 'not' C70 ) ) c= ( BOOLEAN ) by L235;
thus L298: thesis by L297 , L296 , FUNCT_2:2;
end;
compatibility
proof
let C71 being (Function of C69 , ( BOOLEAN ));
L299: ( dom C71 ) = C69 by FUNCT_2:def 1;
thus L300:now
assume L301: C71 = ( 'not' C70 );
let C72 being (Element of C69);
L302: C72 in C69;
L303: C72 in ( dom C70 ) by L302 , FUNCT_2:def 1;
thus L304: ( C71 . C72 ) = ( 'not' ( C70 . C72 ) ) by L303 , L301 , L248;
end;
L305: ( dom C70 ) = C69 by FUNCT_2:def 1;
assume L306: (for B91 being (Element of C69) holds ( C71 . B91 ) = ( 'not' ( C70 . B91 ) ));
L307: (for B92 being set holds (B92 in ( dom C70 ) implies ( C71 . B92 ) = ( 'not' ( C70 . B92 ) ))) by L306 , L305;
thus L308: thesis by L307 , L299 , L305 , L248;
end;
let C73 being (Function of C69 , ( BOOLEAN ));
redefine func C70 '&' C73 -> (Function of C69 , ( BOOLEAN )) means 
(for B93 being (Element of C69) holds ( it . B93 ) = ( ( C70 . B93 ) '&' ( C73 . B93 ) ));
coherence
proof
L309: ( rng ( C70 '&' C73 ) ) c= ( BOOLEAN ) by L235;
L310: (( dom C70 ) = C69 & ( dom C73 ) = C69) by PARTFUN1:def 2;
L311: ( dom ( C70 '&' C73 ) ) = ( C69 /\ C69 ) by L310 , L273
.= C69;
thus L312: thesis by L311 , L309 , FUNCT_2:2;
end;
compatibility
proof
let C74 being (Function of C69 , ( BOOLEAN ));
L313: ( dom C74 ) = C69 by FUNCT_2:def 1;
thus L314:now
assume L315: C74 = ( C70 '&' C73 );
let C75 being (Element of C69);
L316: ( dom C73 ) = C69 by FUNCT_2:def 1;
L317: ( dom C70 ) = C69 by FUNCT_2:def 1;
L318: ( dom ( C70 '&' C73 ) ) = ( C69 /\ C69 ) by L317 , L316 , L273
.= C69;
thus L319: ( C74 . C75 ) = ( ( C70 . C75 ) '&' ( C73 . C75 ) ) by L318 , L315 , L273;
end;
L320: ( dom C73 ) = C69 by FUNCT_2:def 1;
L321: ( dom C74 ) = ( C69 /\ C69 ) by FUNCT_2:def 1
.= ( ( dom C70 ) /\ ( dom C73 ) ) by L320 , FUNCT_2:def 1;
assume L322: (for B94 being (Element of C69) holds ( C74 . B94 ) = ( ( C70 . B94 ) '&' ( C73 . B94 ) ));
L323: (for B95 being set holds (B95 in ( dom C74 ) implies ( C74 . B95 ) = ( ( C70 . B95 ) '&' ( C73 . B95 ) ))) by L322 , L313;
thus L324: thesis by L323 , L321 , L273;
end;
end;
begin
definition
let C76 being Relation;
attr C76 is  homogeneous
means
:L326: ( dom C76 ) is  with_common_domain;
end;
definition
let R19 being set;
let C77 being (PartFunc of ( R19 * ) , R19);
attr C77 is  quasi_total
means
:L328: (for R21 being (FinSequence of R19) holds (for R22 being (FinSequence of R19) holds ((( len R21 ) = ( len R22 ) & R21 in ( dom C77 )) implies R22 in ( dom C77 ))));
end;
registration
let C78 being Relation;
let C79 being  with_common_domain set;
cluster ( C78 | C79 ) ->  homogeneous;
coherence
proof
L330: ( dom ( C78 | C79 ) ) c= C79 by RELAT_1:58;
thus L331: ( dom ( C78 | C79 ) ) is  with_common_domain by L330;
end;
end;
registration
let C80 being non  empty set;
let C81 being (PartFunc of ( C80 * ) , C80);
cluster ( dom C81 ) ->  FinSequence-membered;
coherence
proof
L333: ( dom C81 ) c= ( C80 * ) by RELAT_1:def 18;
thus L334: thesis by L333;
end;
end;
registration
let C82 being non  empty set;
cluster  homogeneous  quasi_total non  empty for (PartFunc of ( C82 * ) , C82);
existence
proof
set D12 = the (Element of C82);
set D13 = ( ( <*> C82 ) .--> D12 );
L336: ( dom D13 ) = { ( <*> C82 ) } by FUNCOP_1:13;
L337: ( dom D13 ) c= ( C82 * )
proof
let R20 being set;
assume L338: R20 in ( dom D13 );
L339: R20 = ( <*> C82 ) by L338 , L336 , TARSKI:def 1;
thus L340: thesis by L339 , FINSEQ_1:def 11;
end;
L341: ( rng D13 ) = { D12 } by FUNCOP_1:8;
L342: ( rng D13 ) c= C82
proof
let R20 being set;
assume L343: R20 in ( rng D13 );
L344: R20 = D12 by L343 , L341 , TARSKI:def 1;
thus L345: thesis by L344;
end;
reconsider D14 = D13 as (PartFunc of ( C82 * ) , C82) by L342 , L337 , RELSET_1:4;
L346: D14 is  quasi_total
proof
let C83 , C84 being (FinSequence of C82);
assume that
L347: ( len C83 ) = ( len C84 )
and
L348: C83 in ( dom D14 );
L349: C83 = ( <*> C82 ) by L336 , L348 , TARSKI:def 1;
L350: ( len C83 ) = ( 0 ) by L349;
L351: C84 = ( <*> C82 ) by L350 , L347;
thus L352: thesis by L351 , L336 , TARSKI:def 1;
end;
L353: D14 is  homogeneous
proof
let C85 , C86 being FinSequence;
assume that
L354: C85 in ( dom D14 )
and
L355: C86 in ( dom D14 );
L356: C85 = ( <*> C82 ) by L336 , L354 , TARSKI:def 1;
thus L357: thesis by L356 , L336 , L355 , TARSKI:def 1;
end;
thus L358: thesis by L353 , L346;
end;
end;
registration
cluster  homogeneous non  empty for Function;
existence
proof
set D15 = the  homogeneous non  empty (PartFunc of ( { ( {} ) } * ) , { ( {} ) });
take D15;
thus L360: thesis;
end;
end;
registration
let C87 being  homogeneous Relation;
cluster ( dom C87 ) ->  with_common_domain;
coherence by L326;
end;
theorem
L363: (for B96 being non  empty set holds (for B97 being (Element of B96) holds ( ( <*> B96 ) .--> B97 ) is  homogeneous  quasi_total non  empty  homogeneous  quasi_total non  empty  homogeneous  quasi_total non  empty  homogeneous  quasi_total non  empty (PartFunc of ( B96 * ) , B96)))
proof
let C88 being non  empty set;
let C89 being (Element of C88);
set D16 = ( ( <*> C88 ) .--> C89 );
L364: ( dom D16 ) = { ( <*> C88 ) } by FUNCOP_1:13;
L365: ( dom D16 ) c= ( C88 * )
proof
let R20 being set;
assume L366: R20 in ( dom D16 );
L367: R20 = ( <*> C88 ) by L366 , L364 , TARSKI:def 1;
thus L368: thesis by L367 , FINSEQ_1:def 11;
end;
L369: ( rng D16 ) = { C89 } by FUNCOP_1:8;
L370: ( rng D16 ) c= C88
proof
let R20 being set;
assume L371: R20 in ( rng D16 );
L372: R20 = C89 by L371 , L369 , TARSKI:def 1;
thus L373: thesis by L372;
end;
reconsider D17 = D16 as (PartFunc of ( C88 * ) , C88) by L370 , L365 , RELSET_1:4;
L374: D17 is  quasi_total
proof
let C90 , C91 being (FinSequence of C88);
assume that
L375: ( len C90 ) = ( len C91 )
and
L376: C90 in ( dom D17 );
L377: C90 = ( <*> C88 ) by L364 , L376 , TARSKI:def 1;
L378: ( len C90 ) = ( 0 ) by L377;
L379: C91 = ( <*> C88 ) by L378 , L375;
thus L380: thesis by L379 , L364 , TARSKI:def 1;
end;
L381: D17 is  homogeneous
proof
let C92 , C93 being FinSequence;
assume that
L382: C92 in ( dom D17 )
and
L383: C93 in ( dom D17 );
L384: C92 = ( <*> C88 ) by L364 , L382 , TARSKI:def 1;
thus L385: thesis by L384 , L364 , L383 , TARSKI:def 1;
end;
thus L386: thesis by L381 , L374;
end;
theorem
L387: (for B98 being non  empty set holds (for B99 being (Element of B98) holds ( ( <*> B98 ) .--> B99 ) is (Element of ( PFuncs (( B98 * ) , B98) ))))
proof
let C94 being non  empty set;
let C95 being (Element of C94);
set D18 = ( ( <*> C94 ) .--> C95 );
L388: ( dom D18 ) = { ( <*> C94 ) } by FUNCOP_1:13;
L389: ( dom D18 ) c= ( C94 * )
proof
let R20 being set;
assume L390: R20 in ( dom D18 );
L391: R20 = ( <*> C94 ) by L390 , L388 , TARSKI:def 1;
thus L392: thesis by L391 , FINSEQ_1:def 11;
end;
L393: ( rng D18 ) = { C95 } by FUNCOP_1:8;
L394: ( rng D18 ) c= C94
proof
let R20 being set;
assume L395: R20 in ( rng D18 );
L396: R20 = C95 by L395 , L393 , TARSKI:def 1;
thus L397: thesis by L396;
end;
reconsider D19 = D18 as (PartFunc of ( C94 * ) , C94) by L394 , L389 , RELSET_1:4;
L398: D19 in ( PFuncs (( C94 * ) , C94) ) by PARTFUN1:45;
thus L399: thesis by L398;
end;
definition
let R19 being set;
mode PFuncFinSequence of R19
 is (FinSequence of ( PFuncs (( R19 * ) , R19) ));
end;
definition
let R19 being set;
let C96 being (PFuncFinSequence of R19);
attr C96 is  homogeneous
means
:L401: (for R24 being Nat holds (for R23 being (PartFunc of ( R19 * ) , R19) holds ((R24 in ( dom C96 ) & R23 = ( C96 . R24 )) implies R23 is  homogeneous)));
end;
definition
let R19 being set;
let C97 being (PFuncFinSequence of R19);
attr C97 is  quasi_total
means
:L403: (for R24 being Nat holds (for R23 being (PartFunc of ( R19 * ) , R19) holds ((R24 in ( dom C97 ) & R23 = ( C97 . R24 )) implies R23 is  quasi_total)));
end;
definition
let C98 being non  empty set;
let C99 being (Element of ( PFuncs (( C98 * ) , C98) ));
redefine func <*C99 *> -> (PFuncFinSequence of C98);

coherence
proof
L405: <* C99 *> is (FinSequence of ( PFuncs (( C98 * ) , C98) ));
thus L406: thesis by L405;
end;
end;
registration
let C100 being non  empty set;
cluster  homogeneous  quasi_total  non-empty for (PFuncFinSequence of C100);
existence
proof
set D20 = the (Element of C100);
reconsider D21 = ( ( <*> C100 ) .--> D20 ) as (PartFunc of ( C100 * ) , C100) by L363;
reconsider D22 = D21 as (Element of ( PFuncs (( C100 * ) , C100) )) by PARTFUN1:45;
take <* D22 *>;
thus L408: <* D22 *> is  homogeneous
proof
let R24 being Nat;
let C101 being (PartFunc of ( C100 * ) , C100);
assume that
L409: R24 in ( dom <* D22 *> )
and
L410: C101 = ( <* D22 *> . R24 );
L411: R24 in { 1 } by L409 , FINSEQ_1:2 , FINSEQ_1:def 8;
L412: C101 = ( <* D22 *> . 1 ) by L411 , L410 , TARSKI:def 1;
L413: C101 = D22 by L412 , FINSEQ_1:def 8;
thus L414: thesis by L413 , L363;
end;

thus L415: <* D22 *> is  quasi_total
proof
let R24 being Nat;
let C102 being (PartFunc of ( C100 * ) , C100);
assume that
L416: R24 in ( dom <* D22 *> )
and
L417: C102 = ( <* D22 *> . R24 );
L418: R24 in { 1 } by L416 , FINSEQ_1:2 , FINSEQ_1:def 8;
L419: C102 = ( <* D22 *> . 1 ) by L418 , L417 , TARSKI:def 1;
L420: C102 = D22 by L419 , FINSEQ_1:def 8;
thus L421: thesis by L420 , L363;
end;

thus L422: <* D22 *> is  non-empty
proof
let C103 being set;
assume L423: C103 in ( dom <* D22 *> );
reconsider D23 = C103 as (Element of ( NAT )) by L423;
L424: D23 in { 1 } by L423 , FINSEQ_1:2 , FINSEQ_1:def 8;
L425: D23 = 1 by L424 , TARSKI:def 1;
thus L426: thesis by L425 , FINSEQ_1:def 8;
end;

end;
end;
registration
let C104 being non  empty set;
let C105 being  homogeneous (PFuncFinSequence of C104);
let C106 being set;
cluster ( C105 . C106 ) ->  homogeneous;
coherence
proof
per cases ;
suppose L424: C106 in ( dom C105 );

L425: ( rng C105 ) c= ( PFuncs (( C104 * ) , C104) ) by RELAT_1:def 19;
L426: ( C105 . C106 ) in ( rng C105 ) by L424 , FUNCT_1:3;
L427: ( C105 . C106 ) is (PartFunc of ( C104 * ) , C104) by L426 , L425 , PARTFUN1:46;
thus L428: thesis by L427 , L424 , L401;
end;
suppose L429: (not C106 in ( dom C105 ));

let C107 being Function;
thus L430: thesis by L429 , FUNCT_1:def 2 , RELAT_1:38;
end;
end;
end;
theorem
L433: (for R26 being non  empty set holds (for R28 being (Element of R26) holds (for B100 being (Element of ( PFuncs (( R26 * ) , R26) )) holds (B100 = ( ( <*> R26 ) .--> R28 ) implies <* B100 *> is  homogeneous  quasi_total  non-empty))))
proof
let R26 being non  empty set;
let R28 being (Element of R26);
let C108 being (Element of ( PFuncs (( R26 * ) , R26) ));
assume that
L434: C108 = ( ( <*> R26 ) .--> R28 );
L435: (for R24 being Nat holds (for R27 being (PartFunc of ( R26 * ) , R26) holds ((R24 in ( dom <* C108 *> ) & R27 = ( <* C108 *> . R24 )) implies R27 is  homogeneous)))
proof
let R24 being Nat;
let R27 being (PartFunc of ( R26 * ) , R26);
assume that
L436: R24 in ( dom <* C108 *> )
and
L437: R27 = ( <* C108 *> . R24 );
L438: R24 in { 1 } by L436 , FINSEQ_1:2 , FINSEQ_1:def 8;
L439: R27 = ( <* C108 *> . 1 ) by L438 , L437 , TARSKI:def 1;
L440: R27 = C108 by L439 , FINSEQ_1:def 8;
thus L441: thesis by L440 , L434 , L363;
end;
L442: (for R24 being Nat holds (for R27 being (PartFunc of ( R26 * ) , R26) holds ((R24 in ( dom <* C108 *> ) & R27 = ( <* C108 *> . R24 )) implies R27 is  quasi_total)))
proof
let R24 being Nat;
let R27 being (PartFunc of ( R26 * ) , R26);
assume that
L443: R24 in ( dom <* C108 *> )
and
L444: R27 = ( <* C108 *> . R24 );
L445: R24 in { 1 } by L443 , FINSEQ_1:2 , FINSEQ_1:def 8;
L446: R27 = ( <* C108 *> . 1 ) by L445 , L444 , TARSKI:def 1;
L447: R27 = C108 by L446 , FINSEQ_1:def 8;
thus L448: thesis by L447 , L434 , L363;
end;
L449: (for B101 being set holds (B101 in ( dom <* C108 *> ) implies ( <* C108 *> . B101 ) is non  empty))
proof
let C109 being set;
assume L450: C109 in ( dom <* C108 *> );
L451: C109 in { 1 } by L450 , FINSEQ_1:2 , FINSEQ_1:def 8;
L452: ( <* C108 *> . C109 ) = ( <* C108 *> . 1 ) by L451 , TARSKI:def 1;
thus L453: thesis by L452 , L434 , FINSEQ_1:def 8;
end;
thus L454: thesis by L449 , L435 , L442 , L401 , L403 , FUNCT_1:def 9;
end;
definition
let C110 being  homogeneous Relation;
func arity C110 -> Nat means 
:L455: (for B102 being FinSequence holds (B102 in ( dom C110 ) implies it = ( len B102 ))) if (ex B103 being FinSequence st B103 in ( dom C110 )) otherwise it = ( 0 );
consistency;
existence
proof
thus L456: ((ex B104 being FinSequence st B104 in ( dom C110 )) implies (ex R24 being Nat st (for B105 being FinSequence holds (B105 in ( dom C110 ) implies R24 = ( len B105 )))))
proof
given C111 being FinSequence such that
L457: C111 in ( dom C110 );

take ( len C111 );
let C112 being FinSequence;
assume L458: C112 in ( dom C110 );
L459: ( dom C111 ) = ( dom C112 ) by L458 , L457 , CARD_3:def 10;
thus L460: thesis by L459 , FINSEQ_3:29;
end;

thus L461: thesis;
end;
uniqueness
proof
let R24 being Nat;
let R25 being Nat;
thus L462:now
given C113 being FinSequence such that
L463: C113 in ( dom C110 );

assume that
L464: (for B106 being FinSequence holds (B106 in ( dom C110 ) implies R24 = ( len B106 )))
and
L465: (for B107 being FinSequence holds (B107 in ( dom C110 ) implies R25 = ( len B107 )));
L466: R24 = ( len C113 ) by L463 , L464;
thus L467: R24 = R25 by L466 , L463 , L465;
end;
thus L468: thesis;
end;
end;
definition
let C114 being  homogeneous Function;
redefine func arity C114 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
begin
theorem
L471: (for B108 being Nat holds (for B109 being non  empty set holds (for B110 being non  empty (Subset of B109) holds ( ( B108 -tuples_on B109 ) /\ ( B108 -tuples_on B110 ) ) = ( B108 -tuples_on B110 ))))
proof
let C115 being Nat;
let C116 being non  empty set;
let C117 being non  empty (Subset of C116);
L472: ( C115 -tuples_on C117 ) c= ( C115 -tuples_on C116 )
proof
let C118 being set;
assume L473: C118 in ( C115 -tuples_on C117 );
L474: C118 is (Tuple of C115 , C117) by L473 , FINSEQ_2:131;
L475: C118 is (Element of ( C115 -tuples_on C116 )) by L474 , FINSEQ_2:109;
thus L476: thesis by L475;
end;
thus L477: thesis by L472 , XBOOLE_1:28;
end;
theorem
L478: (for B111 being non  empty set holds (for B112 being  homogeneous  quasi_total non  empty (PartFunc of ( B111 * ) , B111) holds ( dom B112 ) = ( ( arity B112 ) -tuples_on B111 )))
proof
let C119 being non  empty set;
let C120 being  homogeneous  quasi_total non  empty (PartFunc of ( C119 * ) , C119);
set D24 = the (Element of ( dom C120 ));
L479: ( dom C120 ) c= ( C119 * ) by RELAT_1:def 18;
L480: D24 in ( C119 * ) by L479 , TARSKI:def 3;
thus L481: ( dom C120 ) c= ( ( arity C120 ) -tuples_on C119 )
proof
let C121 being set;
assume L482: C121 in ( dom C120 );
reconsider D25 = C121 as (FinSequence of C119) by L482 , L479 , FINSEQ_1:def 11;
L483: ( len D25 ) = ( arity C120 ) by L482 , L455;
L484: D25 is (Element of ( ( arity C120 ) -tuples_on C119 )) by L483 , FINSEQ_2:92;
thus L485: thesis by L484;
end;

reconsider D26 = D24 as (FinSequence of C119) by L480 , FINSEQ_1:def 11;
let C122 being set;
assume L486: C122 in ( ( arity C120 ) -tuples_on C119 );
L487: C122 in { B113 where B113 is (Element of ( C119 * )) : ( len B113 ) = ( arity C120 ) } by L486 , FINSEQ_2:def 4;
L488: (ex B114 being (Element of ( C119 * )) st (C122 = B114 & ( len B114 ) = ( arity C120 ))) by L487;
L489: ( len D26 ) = ( arity C120 ) by L455;
thus L490: thesis by L489 , L488 , L328;
end;
definition
let C123 being non  empty set;
mode PFuncsDomHQN of C123
 -> non  empty set
means :L491: (for B115 being (Element of it) holds B115 is  homogeneous  quasi_total non  empty  homogeneous  quasi_total non  empty  homogeneous  quasi_total non  empty  homogeneous  quasi_total non  empty (PartFunc of ( C123 * ) , C123));
existence
proof
set D27 = the (Element of C123);
reconsider D28 = { ( { ( <*> C123 ) } --> D27 ) } as non  empty set;
take D28;
let C124 being (Element of D28);
L492: C124 = ( ( <*> C123 ) .--> D27 ) by TARSKI:def 1;
thus L493: thesis by L492 , L363;
end;
end;
definition
let C125 being non  empty set;
let C126 being (PFuncsDomHQN of C125);
redefine mode Element of C126
 ->  homogeneous  quasi_total non  empty (PartFunc of ( C125 * ) , C125);
coherence by L491;
end;
