:: Model Checking, Part {I}
::  by Kazuhisa Ishida
::
:: Received November 14, 2006
:: Copyright (c) 2006-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, ARYTM_3, XXREAL_0, SUBSET_1, CARD_1, FUNCT_1,
      RELAT_1, XBOOLEAN, TARSKI, XBOOLE_0, FINSEQ_1, ZF_LANG, ORDINAL4,
      PARTFUN1, ZFMISC_1, BINOP_1, FUNCOP_1, FUNCT_2, FUNCT_7, ORDERS_1,
      MARGREL1, ZF_MODEL, ARYTM_1, FUNCT_3, COHSP_1, ABIAN, KNASTER, MODELC_1,
      STRUCT_0, ORDERS_2, FUNCT_5, ROBBINS1, LATTICES;
 notations RELSET_1, RELAT_1, TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS,
      XCMPLX_0, ORDINAL1, NAT_1, FUNCT_1, FUNCT_2, FUNCT_3, FUNCT_7, BINOP_1,
      FINSEQ_1, PARTFUN1, KNASTER, XXREAL_0, ABIAN, ORDERS_1, FUNCOP_1,
      MARGREL1, FUNCT_5, STRUCT_0, ORDERS_2, LATTICES, ROBBINS1;
 constructors BINOP_1, FUNCT_3, REAL_1, NAT_1, MARGREL1, ABIAN, KNASTER,
      RELSET_1, FUNCT_5, ROBBINS1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, PARTFUN1, XXREAL_0,
      XREAL_0, NAT_1, INT_1, XBOOLEAN, MARGREL1, KNASTER, CARD_1, RELSET_1,
      STRUCT_0;
 requirements REAL, NUMERALS, ARITHM, SUBSET, BOOLE;
 definitions RELAT_1, TARSKI, BINOP_1, MARGREL1, XBOOLEAN, ROBBINS1, LATTICES;
 theorems RELSET_1, XBOOLE_0, ZFMISC_1, XBOOLE_1, TARSKI, FUNCT_1, FUNCT_2,
      FUNCT_3, FUNCT_7, PARTFUN1, RELAT_1, NAT_1, INT_1, KNASTER, XREAL_1,
      ABIAN, FINSEQ_1, ORDERS_1, FUNCOP_1, XXREAL_0, RELSET_2, MARGREL1,
      FINSEQ_5, XBOOLEAN, ORDINAL1, XTUPLE_0;
 schemes NAT_1, FUNCT_2, XBOOLE_0, BINOP_1, BINOP_2;

begin
L1: (for B1 , B2 , B3 being Nat holds ((B1 < B2 & B2 <= ( B3 + 1 )) implies B1 <= B3))
proof
let C1 , C2 , C3 being Nat;
assume that
L2: C1 < C2
and
L3: C2 <= ( C3 + 1 );
L4: ( C1 + 1 ) <= C2 by L2 , NAT_1:13;
L5: ( C1 + 1 ) <= ( C3 + 1 ) by L4 , L3 , XXREAL_0:2;
thus L6: thesis by L5 , XREAL_1:6;
end;
definition
let C4 , C5 being set;
let C6 being (Element of C5);
func k_id (C4 , C5 , C6) -> (Element of C5) equals
:L7: C4 if C4 in C5 otherwise C6;
correctness;
end;
definition
let C7 being set;
func k_nat C7 -> (Element of ( NAT )) equals
:L9: C7 if C7 in ( NAT ) otherwise ( 0 );
correctness;
end;
definition
let C8 being Function;
let C9 , C10 being set;
func UnivF (C9 , C8 , C10) -> set equals
:L11: ( C8 . C9 ) if C9 in ( dom C8 ) otherwise C10;
correctness;
end;
definition
let C11 being set;
func Castboolean C11 ->  boolean set equals
:L13: C11 if C11 is  boolean  boolean  boolean  boolean set otherwise ( FALSE );
correctness;
end;
definition
let C12 , C13 being set;
func CastBool (C13 , C12) -> (Subset of C12) equals
:L15: C13 if C13 c= C12 otherwise ( {} );
correctness by XBOOLE_1:2;
end;
definition
let R2 being (Element of ( NAT ));
func atom. R2 -> (FinSequence of ( NAT )) equals
<* ( 5 + R2 ) *>;
coherence;
end;
definition
let R8 being (FinSequence of ( NAT ));
func 'not' R8 -> (FinSequence of ( NAT )) equals
( <* ( 0 ) *> ^ R8 );
coherence;
let R9 being (FinSequence of ( NAT ));
func R8 '&' R9 -> (FinSequence of ( NAT )) equals
( ( <* 1 *> ^ R8 ) ^ R9 );
coherence;
end;
definition
let R8 being (FinSequence of ( NAT ));
func EX R8 -> (FinSequence of ( NAT )) equals
( <* 2 *> ^ R8 );
coherence;
func EG R8 -> (FinSequence of ( NAT )) equals
( <* 3 *> ^ R8 );
coherence;
let R9 being (FinSequence of ( NAT ));
func R8 EU R9 -> (FinSequence of ( NAT )) equals
( ( <* 4 *> ^ R8 ) ^ R9 );
coherence;
end;
L20: (for R2 being (Element of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ( len ( ( <* R2 *> ^ R8 ) ^ R9 ) ) = ( ( 1 + ( len R8 ) ) + ( len R9 ) ))))
proof
let R2 being (Element of ( NAT ));
let R8 being (FinSequence of ( NAT ));
let R9 being (FinSequence of ( NAT ));
L21: ( len ( R8 ^ R9 ) ) = ( ( len R8 ) + ( len R9 ) ) by FINSEQ_1:22;
L22: ( ( len <* R2 *> ) + ( len ( R8 ^ R9 ) ) ) = ( ( ( len <* R2 *> ) + ( len R8 ) ) + ( len R9 ) ) by L21;
L23: ( len ( ( <* R2 *> ^ R8 ) ^ R9 ) ) = ( len ( <* R2 *> ^ ( R8 ^ R9 ) ) ) by FINSEQ_1:32
.= ( ( len <* R2 *> ) + ( len ( R8 ^ R9 ) ) ) by FINSEQ_1:22;
thus L24: thesis by L23 , L22 , FINSEQ_1:40;
end;
definition
func CTL_WFF -> non  empty set means
:L25: ((for R3 being set holds (R3 in it implies R3 is (FinSequence of ( NAT )))) & (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in it) & (for R8 being (FinSequence of ( NAT )) holds (R8 in it implies ( 'not' R8 ) in it)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in it & R9 in it) implies ( R8 '&' R9 ) in it))) & (for R8 being (FinSequence of ( NAT )) holds (R8 in it implies ( EX R8 ) in it)) & (for R8 being (FinSequence of ( NAT )) holds (R8 in it implies ( EG R8 ) in it)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in it & R9 in it) implies ( R8 EU R9 ) in it))) & (for R5 being non  empty set holds (((for R3 being set holds (R3 in R5 implies R3 is (FinSequence of ( NAT )))) & (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in R5) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( 'not' R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R5 & R9 in R5) implies ( R8 '&' R9 ) in R5))) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( EX R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( EG R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R5 & R9 in R5) implies ( R8 EU R9 ) in R5)))) implies it c= R5)));
existence
proof
defpred S1[ set ] means ((for R3 being set holds (R3 in $1 implies R3 is (FinSequence of ( NAT )))) & (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in $1) & (for R8 being (FinSequence of ( NAT )) holds (R8 in $1 implies ( 'not' R8 ) in $1)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in $1 & R9 in $1) implies ( R8 '&' R9 ) in $1))) & (for R8 being (FinSequence of ( NAT )) holds (R8 in $1 implies ( EX R8 ) in $1)) & (for R8 being (FinSequence of ( NAT )) holds (R8 in $1 implies ( EG R8 ) in $1)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in $1 & R9 in $1) implies ( R8 EU R9 ) in $1))));
defpred S2[ set ] means (for R5 being non  empty set holds (S1[ R5 ] implies $1 in R5));
consider R4 being set such that L26: (for R3 being set holds (R3 in R4 iff (R3 in ( ( NAT ) * ) & S2[ R3 ]))) from XBOOLE_0:sch 1;
L27:
now
set D1 = ( atom. ( 0 ) );
L28: (for R5 being non  empty set holds (S1[ R5 ] implies D1 in R5));
take D2 = D1;
L29: D1 in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L30: D2 in R4 by L29 , L26 , L28;
end;
reconsider D3 = R4 as non  empty set by L27;
take D3;
thus L31: (for R3 being set holds (R3 in D3 implies R3 is (FinSequence of ( NAT ))))
proof
let R3 being set;
assume L32: R3 in D3;
L33: R3 in ( ( NAT ) * ) by L32 , L26;
thus L34: thesis by L33 , FINSEQ_1:def 11;
end;

thus L35: (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in D3)
proof
let R2 being (Element of ( NAT ));
L36: (for R5 being non  empty set holds (S1[ R5 ] implies ( atom. R2 ) in R5));
L37: ( atom. R2 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L38: thesis by L37 , L26 , L36;
end;

thus L39: (for R8 being (FinSequence of ( NAT )) holds (R8 in D3 implies ( 'not' R8 ) in D3))
proof
let R8 being (FinSequence of ( NAT ));
assume L40: R8 in D3;
L41: (for R5 being non  empty set holds (S1[ R5 ] implies ( 'not' R8 ) in R5))
proof
let R5 being non  empty set;
assume L42: S1[ R5 ];
L43: R8 in R5 by L42 , L26 , L40;
thus L44: thesis by L43 , L42;
end;
L45: ( 'not' R8 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L46: thesis by L45 , L26 , L41;
end;

thus L47: (for R9 being (FinSequence of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds ((R9 in D3 & R8 in D3) implies ( R9 '&' R8 ) in D3)))
proof
let R9 being (FinSequence of ( NAT ));
let R8 being (FinSequence of ( NAT ));
assume that
L48: R9 in D3
and
L49: R8 in D3;
L50: (for R5 being non  empty set holds (S1[ R5 ] implies ( R9 '&' R8 ) in R5))
proof
let R5 being non  empty set;
assume L51: S1[ R5 ];
L52: R9 in R5 by L51 , L26 , L48;
L53: R8 in R5 by L26 , L49 , L51;
thus L54: thesis by L53 , L51 , L52;
end;
L55: ( R9 '&' R8 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L56: thesis by L55 , L26 , L50;
end;

thus L57: (for R8 being (FinSequence of ( NAT )) holds (R8 in D3 implies ( EX R8 ) in D3))
proof
let R8 being (FinSequence of ( NAT ));
assume L58: R8 in D3;
L59: (for R5 being non  empty set holds (S1[ R5 ] implies ( EX R8 ) in R5))
proof
let R5 being non  empty set;
assume L60: S1[ R5 ];
L61: R8 in R5 by L60 , L26 , L58;
thus L62: thesis by L61 , L60;
end;
L63: ( EX R8 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L64: thesis by L63 , L26 , L59;
end;

thus L65: (for R8 being (FinSequence of ( NAT )) holds (R8 in D3 implies ( EG R8 ) in D3))
proof
let R8 being (FinSequence of ( NAT ));
assume L66: R8 in D3;
L67: (for R5 being non  empty set holds (S1[ R5 ] implies ( EG R8 ) in R5))
proof
let R5 being non  empty set;
assume L68: S1[ R5 ];
L69: R8 in R5 by L68 , L26 , L66;
thus L70: thesis by L69 , L68;
end;
L71: ( EG R8 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L72: thesis by L71 , L26 , L67;
end;

thus L73: (for R9 being (FinSequence of ( NAT )) holds (for R8 being (FinSequence of ( NAT )) holds ((R9 in D3 & R8 in D3) implies ( R9 EU R8 ) in D3)))
proof
let R9 being (FinSequence of ( NAT ));
let R8 being (FinSequence of ( NAT ));
assume that
L74: R9 in D3
and
L75: R8 in D3;
L76: (for R5 being non  empty set holds (S1[ R5 ] implies ( R9 EU R8 ) in R5))
proof
let R5 being non  empty set;
assume L77: S1[ R5 ];
L78: R9 in R5 by L77 , L26 , L74;
L79: R8 in R5 by L26 , L75 , L77;
thus L80: thesis by L79 , L77 , L78;
end;
L81: ( R9 EU R8 ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
thus L82: thesis by L81 , L26 , L76;
end;

let R5 being non  empty set;
assume that
L83: S1[ R5 ];
let R3 being set;
assume L84: R3 in D3;
thus L85: thesis by L84 , L26 , L83;
end;
uniqueness
proof
let R6 being non  empty set;
let R7 being non  empty set;
assume that
L86: (for R3 being set holds (R3 in R6 implies R3 is (FinSequence of ( NAT ))))
and
L87: (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in R6)
and
L88: (for R8 being (FinSequence of ( NAT )) holds (R8 in R6 implies ( 'not' R8 ) in R6))
and
L89: (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R6 & R9 in R6) implies ( R8 '&' R9 ) in R6)))
and
L90: (for R8 being (FinSequence of ( NAT )) holds (R8 in R6 implies ( EX R8 ) in R6))
and
L91: (for R8 being (FinSequence of ( NAT )) holds (R8 in R6 implies ( EG R8 ) in R6))
and
L92: (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R6 & R9 in R6) implies ( R8 EU R9 ) in R6)))
and
L93: (for R5 being non  empty set holds (((for R3 being set holds (R3 in R5 implies R3 is (FinSequence of ( NAT )))) & (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in R5) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( 'not' R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R5 & R9 in R5) implies ( R8 '&' R9 ) in R5))) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( EX R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( EG R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R5 & R9 in R5) implies ( R8 EU R9 ) in R5)))) implies R6 c= R5))
and
L94: (for R3 being set holds (R3 in R7 implies R3 is (FinSequence of ( NAT ))))
and
L95: (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in R7)
and
L96: (for R8 being (FinSequence of ( NAT )) holds (R8 in R7 implies ( 'not' R8 ) in R7))
and
L97: (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R7 & R9 in R7) implies ( R8 '&' R9 ) in R7)))
and
L98: (for R8 being (FinSequence of ( NAT )) holds (R8 in R7 implies ( EX R8 ) in R7))
and
L99: (for R8 being (FinSequence of ( NAT )) holds (R8 in R7 implies ( EG R8 ) in R7))
and
L100: (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R7 & R9 in R7) implies ( R8 EU R9 ) in R7)))
and
L101: (for R5 being non  empty set holds (((for R3 being set holds (R3 in R5 implies R3 is (FinSequence of ( NAT )))) & (for R2 being (Element of ( NAT )) holds ( atom. R2 ) in R5) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( 'not' R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R5 & R9 in R5) implies ( R8 '&' R9 ) in R5))) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( EX R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (R8 in R5 implies ( EG R8 ) in R5)) & (for R8 being (FinSequence of ( NAT )) holds (for R9 being (FinSequence of ( NAT )) holds ((R8 in R5 & R9 in R5) implies ( R8 EU R9 ) in R5)))) implies R7 c= R5));
L102: R7 c= R6 by L86 , L87 , L88 , L89 , L90 , L91 , L92 , L101;
L103: R6 c= R7 by L93 , L94 , L95 , L96 , L97 , L98 , L99 , L100;
thus L104: thesis by L103 , L102 , XBOOLE_0:def 10;
end;
end;
definition
let C14 being (FinSequence of ( NAT ));
attr C14 is  CTL-formula-like
means
:L106: C14 is (Element of ( CTL_WFF ));
end;
registration
cluster  CTL-formula-like for (FinSequence of ( NAT ));
existence
proof
set D4 = the (Element of ( CTL_WFF ));
reconsider D5 = D4 as (FinSequence of ( NAT )) by L25;
take D5;
thus L108: D5 is (Element of ( CTL_WFF ));
end;
end;
definition
mode CTL-formula
 is  CTL-formula-like (FinSequence of ( NAT ));
end;
theorem
L111: (for R3 being set holds (R3 is CTL-formula iff R3 in ( CTL_WFF )))
proof
let R3 being set;
thus L112: (R3 is CTL-formula implies R3 in ( CTL_WFF ))
proof
assume L113: R3 is CTL-formula;
L114: R3 is (Element of ( CTL_WFF )) by L113 , L106;
thus L115: thesis by L114;
end;

assume L116: R3 in ( CTL_WFF );
thus L117: thesis by L116 , L25 , L106;
end;
registration
let R2 being (Element of ( NAT ));
cluster ( atom. R2 ) ->  CTL-formula-like;
coherence
proof
L118: ( atom. R2 ) is (Element of ( CTL_WFF )) by L25;
thus L119: thesis by L118 , L106;
end;
end;
registration
let R14 being CTL-formula;
cluster ( 'not' R14 ) ->  CTL-formula-like;
coherence
proof
L121: R14 is (Element of ( CTL_WFF )) by L106;
L122: ( 'not' R14 ) is (Element of ( CTL_WFF )) by L121 , L25;
thus L123: thesis by L122 , L106;
end;
cluster ( EX R14 ) ->  CTL-formula-like;
coherence
proof
L124: R14 is (Element of ( CTL_WFF )) by L106;
L125: ( EX R14 ) is (Element of ( CTL_WFF )) by L124 , L25;
thus L126: thesis by L125 , L106;
end;
cluster ( EG R14 ) ->  CTL-formula-like;
coherence
proof
L127: R14 is (Element of ( CTL_WFF )) by L106;
L128: ( EG R14 ) is (Element of ( CTL_WFF )) by L127 , L25;
thus L129: thesis by L128 , L106;
end;
let R12 being CTL-formula;
cluster ( R14 '&' R12 ) ->  CTL-formula-like;
coherence
proof
L130: R12 is (Element of ( CTL_WFF )) by L106;
L131: R14 is (Element of ( CTL_WFF )) by L106;
L132: ( R14 '&' R12 ) is (Element of ( CTL_WFF )) by L131 , L130 , L25;
thus L133: thesis by L132 , L106;
end;
cluster ( R14 EU R12 ) ->  CTL-formula-like;
coherence
proof
L134: R12 is (Element of ( CTL_WFF )) by L106;
L135: R14 is (Element of ( CTL_WFF )) by L106;
L136: ( R14 EU R12 ) is (Element of ( CTL_WFF )) by L135 , L134 , L25;
thus L137: thesis by L136 , L106;
end;
end;
definition
let R14 being CTL-formula;
attr R14 is  atomic
means
:L139: (ex R2 being (Element of ( NAT )) st R14 = ( atom. R2 ));
attr R14 is  negative
means
:L140: (ex R15 being CTL-formula st R14 = ( 'not' R15 ));
attr R14 is  conjunctive
means
:L141: (ex R10 being CTL-formula st (ex R12 being CTL-formula st R14 = ( R10 '&' R12 )));
attr R14 is  ExistNext
means
:L142: (ex R15 being CTL-formula st R14 = ( EX R15 ));
attr R14 is  ExistGlobal
means
:L143: (ex R15 being CTL-formula st R14 = ( EG R15 ));
attr R14 is  ExistUntill
means
:L144: (ex R10 being CTL-formula st (ex R12 being CTL-formula st R14 = ( R10 EU R12 )));
end;
definition
let R10 being CTL-formula;
let R12 being CTL-formula;
func R10 'or' R12 -> CTL-formula equals
( 'not' ( ( 'not' R10 ) '&' ( 'not' R12 ) ) );
coherence;
end;
theorem
L147: (for R14 being CTL-formula holds (R14 is  atomic or R14 is  negative or R14 is  conjunctive or R14 is  ExistNext or R14 is  ExistGlobal or R14 is  ExistUntill))
proof
let R14 being CTL-formula;
L148: R14 is (Element of ( CTL_WFF )) by L106;
assume L149: (not thesis);
L150: ( atom. ( 0 ) ) <> R14 by L149 , L139;
L151: (not ( atom. ( 0 ) ) in { R14 }) by L150 , TARSKI:def 1;
L152:
now
let R8 being (FinSequence of ( NAT ));
assume L153: R8 in ( ( CTL_WFF ) \ { R14 } );
reconsider D6 = R8 as CTL-formula by L153 , L106;
L154: ( EG D6 ) <> R14 by L149 , L143;
L155: (not ( EG R8 ) in { R14 }) by L154 , TARSKI:def 1;
L156: ( EG R8 ) in ( CTL_WFF ) by L153 , L25;
thus L157: ( EG R8 ) in ( ( CTL_WFF ) \ { R14 } ) by L156 , L155 , XBOOLE_0:def 5;
end;
L158:
now
let R8 being (FinSequence of ( NAT ));
assume L159: R8 in ( ( CTL_WFF ) \ { R14 } );
reconsider D7 = R8 as CTL-formula by L159 , L106;
L160: ( EX D7 ) <> R14 by L149 , L142;
L161: (not ( EX R8 ) in { R14 }) by L160 , TARSKI:def 1;
L162: ( EX R8 ) in ( CTL_WFF ) by L159 , L25;
thus L163: ( EX R8 ) in ( ( CTL_WFF ) \ { R14 } ) by L162 , L161 , XBOOLE_0:def 5;
end;
L164:
now
let R8 being (FinSequence of ( NAT ));
let R9 being (FinSequence of ( NAT ));
assume that
L165: R8 in ( ( CTL_WFF ) \ { R14 } )
and
L166: R9 in ( ( CTL_WFF ) \ { R14 } );
reconsider D8 = R8 , D9 = R9 as CTL-formula by L165 , L166 , L106;
L167: ( D8 '&' D9 ) <> R14 by L149 , L141;
L168: (not ( R8 '&' R9 ) in { R14 }) by L167 , TARSKI:def 1;
L169: ( R8 '&' R9 ) in ( CTL_WFF ) by L165 , L166 , L25;
thus L170: ( R8 '&' R9 ) in ( ( CTL_WFF ) \ { R14 } ) by L169 , L168 , XBOOLE_0:def 5;
end;
L171:
now
let R8 being (FinSequence of ( NAT ));
assume L172: R8 in ( ( CTL_WFF ) \ { R14 } );
reconsider D10 = R8 as CTL-formula by L172 , L106;
L173: ( 'not' D10 ) <> R14 by L149 , L140;
L174: (not ( 'not' R8 ) in { R14 }) by L173 , TARSKI:def 1;
L175: ( 'not' R8 ) in ( CTL_WFF ) by L172 , L25;
thus L176: ( 'not' R8 ) in ( ( CTL_WFF ) \ { R14 } ) by L175 , L174 , XBOOLE_0:def 5;
end;
L177:
now
let R8 being (FinSequence of ( NAT ));
let R9 being (FinSequence of ( NAT ));
assume that
L178: R8 in ( ( CTL_WFF ) \ { R14 } )
and
L179: R9 in ( ( CTL_WFF ) \ { R14 } );
reconsider D11 = R8 , D12 = R9 as CTL-formula by L178 , L179 , L106;
L180: ( D11 EU D12 ) <> R14 by L149 , L144;
L181: (not ( R8 EU R9 ) in { R14 }) by L180 , TARSKI:def 1;
L182: ( R8 EU R9 ) in ( CTL_WFF ) by L178 , L179 , L25;
thus L183: ( R8 EU R9 ) in ( ( CTL_WFF ) \ { R14 } ) by L182 , L181 , XBOOLE_0:def 5;
end;
L184:
now
let R2 being (Element of ( NAT ));
L185: ( atom. R2 ) <> R14 by L149 , L139;
L186: (not ( atom. R2 ) in { R14 }) by L185 , TARSKI:def 1;
L187: ( atom. R2 ) in ( CTL_WFF ) by L25;
thus L188: ( atom. R2 ) in ( ( CTL_WFF ) \ { R14 } ) by L187 , L186 , XBOOLE_0:def 5;
end;
L189: ( atom. ( 0 ) ) in ( CTL_WFF ) by L25;
L190: ( ( CTL_WFF ) \ { R14 } ) is non  empty by L189 , L151 , XBOOLE_0:def 5;
L191: (for R3 being set holds (R3 in ( ( CTL_WFF ) \ { R14 } ) implies R3 is (FinSequence of ( NAT )))) by L25;
L192: ( CTL_WFF ) c= ( ( CTL_WFF ) \ { R14 } ) by L191 , L190 , L184 , L171 , L164 , L158 , L152 , L177 , L25;
L193: R14 in ( ( CTL_WFF ) \ { R14 } ) by L192 , L148 , TARSKI:def 3;
L194: (not R14 in { R14 }) by L193 , XBOOLE_0:def 5;
thus L195: contradiction by L194 , TARSKI:def 1;
end;
L196: (for R14 being CTL-formula holds (R14 is  negative implies ( R14 . 1 ) = ( 0 )))
proof
let R14 being CTL-formula;
assume L197: R14 is  negative;
L198: (ex R15 being CTL-formula st R14 = ( 'not' R15 )) by L197 , L140;
thus L199: thesis by L198 , FINSEQ_1:41;
end;
L200: (for R14 being CTL-formula holds (R14 is  conjunctive implies ( R14 . 1 ) = 1))
proof
let R14 being CTL-formula;
assume L201: R14 is  conjunctive;
consider R10 being CTL-formula, R12 being CTL-formula such that L202: R14 = ( R10 '&' R12 ) by L201 , L141;
L203: ( ( <* 1 *> ^ R10 ) ^ R12 ) = ( <* 1 *> ^ ( R10 ^ R12 ) ) by FINSEQ_1:32;
thus L204: thesis by L203 , L202 , FINSEQ_1:41;
end;
L205: (for R14 being CTL-formula holds (R14 is  ExistNext implies ( R14 . 1 ) = 2))
proof
let R14 being CTL-formula;
assume L206: R14 is  ExistNext;
L207: (ex R15 being CTL-formula st R14 = ( EX R15 )) by L206 , L142;
thus L208: thesis by L207 , FINSEQ_1:41;
end;
L209: (for R14 being CTL-formula holds (R14 is  ExistGlobal implies ( R14 . 1 ) = 3))
proof
let R14 being CTL-formula;
assume L210: R14 is  ExistGlobal;
L211: (ex R15 being CTL-formula st R14 = ( EG R15 )) by L210 , L143;
thus L212: thesis by L211 , FINSEQ_1:41;
end;
L213: (for R14 being CTL-formula holds (R14 is  ExistUntill implies ( R14 . 1 ) = 4))
proof
let R14 being CTL-formula;
assume L214: R14 is  ExistUntill;
consider R10 being CTL-formula, R12 being CTL-formula such that L215: R14 = ( R10 EU R12 ) by L214 , L144;
L216: ( ( <* 4 *> ^ R10 ) ^ R12 ) = ( <* 4 *> ^ ( R10 ^ R12 ) ) by FINSEQ_1:32;
thus L217: thesis by L216 , L215 , FINSEQ_1:41;
end;
L218: (for R14 being CTL-formula holds (R14 is  atomic implies ((not ( R14 . 1 ) = ( 0 )) & (not ( R14 . 1 ) = 1) & (not ( R14 . 1 ) = 2) & (not ( R14 . 1 ) = 3) & (not ( R14 . 1 ) = 4))))
proof
let R14 being CTL-formula;
assume L219: R14 is  atomic;
consider R2 being (Element of ( NAT )) such that L220: R14 = ( atom. R2 ) by L219 , L139;
L221: ( 2 + ( 0 ) ) < ( 2 + ( 3 + R2 ) ) by XREAL_1:8;
L222: ( 4 + ( 0 ) ) < ( 4 + ( 1 + R2 ) ) by XREAL_1:8;
L223: ( 3 + ( 0 ) ) < ( 3 + ( 2 + R2 ) ) by XREAL_1:8;
L224: ( 1 + ( 0 ) ) < ( 1 + ( 4 + R2 ) ) by XREAL_1:8;
thus L225: thesis by L224 , L220 , L221 , L223 , L222 , FINSEQ_1:40;
end;
L226: (for R14 being CTL-formula holds ((R14 is  atomic & ( R14 . 1 ) <> ( 0 ) & ( R14 . 1 ) <> 1 & ( R14 . 1 ) <> 2 & ( R14 . 1 ) <> 3 & ( R14 . 1 ) <> 4) or (R14 is  negative & ( R14 . 1 ) = ( 0 )) or (R14 is  conjunctive & ( R14 . 1 ) = 1) or (R14 is  ExistNext & ( R14 . 1 ) = 2) or (R14 is  ExistGlobal & ( R14 . 1 ) = 3) or (R14 is  ExistUntill & ( R14 . 1 ) = 4)))
proof
let R14 being CTL-formula;
per cases  by L147;
case L227: R14 is  atomic;
thus L228: thesis by L227 , L218;
end;
case L229: R14 is  negative;
thus L230: thesis by L229 , L196;
end;
case L231: R14 is  conjunctive;
thus L232: thesis by L231 , L200;
end;
case L233: R14 is  ExistNext;
thus L234: thesis by L233 , L205;
end;
case L235: R14 is  ExistGlobal;
thus L236: thesis by L235 , L209;
end;
case L237: R14 is  ExistUntill;
thus L238: thesis by L237 , L213;
end;
end;
L240: (for R14 being CTL-formula holds 1 <= ( len R14 ))
proof
let R14 being CTL-formula;
per cases  by L147;
suppose L241: R14 is  atomic;

L242: (ex R2 being (Element of ( NAT )) st R14 = ( atom. R2 )) by L241 , L139;
thus L243: thesis by L242 , FINSEQ_1:40;
end;
suppose L244: R14 is  negative;

consider R15 being CTL-formula such that L245: R14 = ( 'not' R15 ) by L244 , L140;
L246: ( len R14 ) = ( 1 + ( len R15 ) ) by L245 , FINSEQ_5:8;
thus L247: thesis by L246 , NAT_1:11;
end;
suppose L248: R14 is  conjunctive;

consider R10 being CTL-formula, R12 being CTL-formula such that L249: R14 = ( R10 '&' R12 ) by L248 , L141;
L250: 1 <= ( 1 + ( len R10 ) ) by NAT_1:11;
L251: ( 1 + ( len R10 ) ) <= ( ( 1 + ( len R10 ) ) + ( len R12 ) ) by NAT_1:11;
L252: ( len R14 ) = ( ( 1 + ( len R10 ) ) + ( len R12 ) ) by L249 , L20;
thus L253: thesis by L252 , L250 , L251 , XXREAL_0:2;
end;
suppose L254: R14 is  ExistNext;

consider R15 being CTL-formula such that L255: R14 = ( EX R15 ) by L254 , L142;
L256: ( len R14 ) = ( 1 + ( len R15 ) ) by L255 , FINSEQ_5:8;
thus L257: thesis by L256 , NAT_1:11;
end;
suppose L258: R14 is  ExistGlobal;

consider R15 being CTL-formula such that L259: R14 = ( EG R15 ) by L258 , L143;
L260: ( len R14 ) = ( 1 + ( len R15 ) ) by L259 , FINSEQ_5:8;
thus L261: thesis by L260 , NAT_1:11;
end;
suppose L262: R14 is  ExistUntill;

consider R10 being CTL-formula, R12 being CTL-formula such that L263: R14 = ( R10 EU R12 ) by L262 , L144;
L264: 1 <= ( 1 + ( len R10 ) ) by NAT_1:11;
L265: ( 1 + ( len R10 ) ) <= ( ( 1 + ( len R10 ) ) + ( len R12 ) ) by NAT_1:11;
L266: ( len R14 ) = ( ( 1 + ( len R10 ) ) + ( len R12 ) ) by L263 , L20;
thus L267: thesis by L266 , L264 , L265 , XXREAL_0:2;
end;
end;
L269: (for R10 being CTL-formula holds (for R14 being CTL-formula holds (for R17 being FinSequence holds (R14 = ( R10 ^ R17 ) implies R14 = R10))))
proof
let R10 being CTL-formula;
let R14 being CTL-formula;
let R17 being FinSequence;
defpred S3[ Nat ] means (for R14 being CTL-formula holds (for R10 being CTL-formula holds (for R17 being FinSequence holds ((( len R14 ) = $1 & R14 = ( R10 ^ R17 )) implies R14 = R10))));
L270: (for B4 being Nat holds ((for B5 being Nat holds (B5 < B4 implies (for R14 being CTL-formula holds (for R10 being CTL-formula holds (for R17 being FinSequence holds ((( len R14 ) = B5 & R14 = ( R10 ^ R17 )) implies R14 = R10)))))) implies (for R14 being CTL-formula holds (for R10 being CTL-formula holds (for R17 being FinSequence holds ((( len R14 ) = B4 & R14 = ( R10 ^ R17 )) implies R14 = R10))))))
proof
let C15 being Nat;
assume that
L271: (for B6 being Nat holds (B6 < C15 implies (for R14 being CTL-formula holds (for R10 being CTL-formula holds (for R17 being FinSequence holds ((( len R14 ) = B6 & R14 = ( R10 ^ R17 )) implies R14 = R10))))));
let R14 being CTL-formula;
let R10 being CTL-formula;
let R17 being FinSequence;
assume that
L272: ( len R14 ) = C15
and
L273: R14 = ( R10 ^ R17 );
L274: ( dom R10 ) = ( Seg ( len R10 ) ) by FINSEQ_1:def 3;
L275: 1 <= ( len R10 ) by L240;
L276: 1 in ( dom R10 ) by L275 , L274 , FINSEQ_1:1;
L277:
now
L278: ( len <* ( 0 ) *> ) = 1 by FINSEQ_1:40;
assume L279: R14 is  negative;
consider R15 being CTL-formula such that L280: R14 = ( 'not' R15 ) by L279 , L140;
L281: ( ( R10 ^ R17 ) . 1 ) = ( 0 ) by L273 , L279 , L196;
L282: ( R10 . 1 ) = ( 0 ) by L281 , L276 , FINSEQ_1:def 7;
L283: R10 is  negative by L282 , L226;
consider R11 being CTL-formula such that L284: R10 = ( 'not' R11 ) by L283 , L140;
L285: ( ( len <* ( 0 ) *> ) + ( len R15 ) ) = ( len R14 ) by L280 , FINSEQ_1:22;
L286: ( len R15 ) < ( len R14 ) by L285 , L278 , NAT_1:13;
L287: ( ( <* ( 0 ) *> ^ R11 ) ^ R17 ) = ( <* ( 0 ) *> ^ ( R11 ^ R17 ) ) by FINSEQ_1:32;
L288: R15 = ( R11 ^ R17 ) by L287 , L273 , L280 , L284 , FINSEQ_1:33;
thus L289: thesis by L288 , L271 , L272 , L280 , L284 , L286;
end;
L290:
now
L291: ( len <* 4 *> ) = 1 by FINSEQ_1:40;
assume L292: R14 is  ExistUntill;
consider R13 being CTL-formula, R12 being CTL-formula such that L293: R14 = ( R13 EU R12 ) by L292 , L144;
L294: ( ( R10 ^ R17 ) . 1 ) = 4 by L273 , L292 , L213;
L295: ( R10 . 1 ) = 4 by L294 , L276 , FINSEQ_1:def 7;
L296: R10 is  ExistUntill by L295 , L226;
consider R11 being CTL-formula, R15 being CTL-formula such that L297: R10 = ( R11 EU R15 ) by L296 , L144;
L298: ( ( len R12 ) + ( 1 + ( len R13 ) ) ) = ( ( ( len R12 ) + 1 ) + ( len R13 ) );
L299: ( len ( <* 4 *> ^ R13 ) ) = ( ( len <* 4 *> ) + ( len R13 ) ) by FINSEQ_1:22;
L300: ( ( len ( <* 4 *> ^ R13 ) ) + ( len R12 ) ) = ( len R14 ) by L293 , FINSEQ_1:22;
L301: ( ( len R12 ) + 1 ) <= ( len R14 ) by L300 , L299 , L291 , L298 , NAT_1:11;
L302: ( len R12 ) < ( len R14 ) by L301 , NAT_1:13;
L303: ( ( R11 ^ R15 ) ^ R17 ) = ( R11 ^ ( R15 ^ R17 ) ) by FINSEQ_1:32;
L304:
now
L305: ( len <* 4 *> ) = 1 by FINSEQ_1:40;
given R18 being FinSequence such that
L306: R13 = ( R11 ^ R18 );

L307: ( len ( <* 4 *> ^ R13 ) ) = ( ( len <* 4 *> ) + ( len R13 ) ) by FINSEQ_1:22;
L308: ( ( len ( <* 4 *> ^ R13 ) ) + ( len R12 ) ) = ( len R14 ) by L293 , FINSEQ_1:22;
L309: ( ( len R13 ) + 1 ) <= ( len R14 ) by L308 , L307 , L305 , NAT_1:11;
L310: ( len R13 ) < ( len R14 ) by L309 , NAT_1:13;
thus L311: R13 = R11 by L310 , L271 , L272 , L306;
end;
L312: ( ( <* 4 *> ^ ( R11 ^ R15 ) ) ^ R17 ) = ( <* 4 *> ^ ( ( R11 ^ R15 ) ^ R17 ) ) by FINSEQ_1:32;
L313:
now
L314: ( len <* 4 *> ) = 1 by FINSEQ_1:40;
L315: ( len ( <* 4 *> ^ R11 ) ) = ( ( len <* 4 *> ) + ( len R11 ) ) by FINSEQ_1:22;
L316: ( ( ( ( len R11 ) + 1 ) + ( len R15 ) ) + ( len R17 ) ) = ( ( ( len R11 ) + 1 ) + ( ( len R15 ) + ( len R17 ) ) );
given R18 being FinSequence such that
L317: R11 = ( R13 ^ R18 );

L318: ( len ( R10 ^ R17 ) ) = ( ( len R10 ) + ( len R17 ) ) by FINSEQ_1:22;
L319: ( len R10 ) = ( ( len ( <* 4 *> ^ R11 ) ) + ( len R15 ) ) by L297 , FINSEQ_1:22;
L320: ( ( len R11 ) + 1 ) <= ( len R14 ) by L319 , L273 , L318 , L315 , L314 , L316 , NAT_1:11;
L321: ( len R11 ) < ( len R14 ) by L320 , NAT_1:13;
thus L322: R11 = R13 by L321 , L271 , L272 , L317;
end;
L323: ( ( <* 4 *> ^ R11 ) ^ R15 ) = ( <* 4 *> ^ ( R11 ^ R15 ) ) by FINSEQ_1:32;
L324: ( ( <* 4 *> ^ R13 ) ^ R12 ) = ( <* 4 *> ^ ( R13 ^ R12 ) ) by FINSEQ_1:32;
L325: ( R13 ^ R12 ) = ( R11 ^ ( R15 ^ R17 ) ) by L324 , L273 , L293 , L297 , L323 , L312 , L303 , FINSEQ_1:33;
L326: (( len R11 ) <= ( len R13 ) implies (ex R18 being FinSequence st R13 = ( R11 ^ R18 ))) by L325 , FINSEQ_1:47;
L327: R12 = ( R15 ^ R17 ) by L326 , L325 , L304 , L313 , FINSEQ_1:33 , FINSEQ_1:47;
thus L328: thesis by L327 , L271 , L272 , L273 , L297 , L323 , L312 , L303 , L302;
end;
L329:
now
L330: ( len <* 1 *> ) = 1 by FINSEQ_1:40;
assume L331: R14 is  conjunctive;
consider R13 being CTL-formula, R12 being CTL-formula such that L332: R14 = ( R13 '&' R12 ) by L331 , L141;
L333: ( ( R10 ^ R17 ) . 1 ) = 1 by L273 , L331 , L200;
L334: ( R10 . 1 ) = 1 by L333 , L276 , FINSEQ_1:def 7;
L335: R10 is  conjunctive by L334 , L226;
consider R11 being CTL-formula, R15 being CTL-formula such that L336: R10 = ( R11 '&' R15 ) by L335 , L141;
L337: ( ( len R12 ) + ( 1 + ( len R13 ) ) ) = ( ( ( len R12 ) + 1 ) + ( len R13 ) );
L338: ( len ( <* 1 *> ^ R13 ) ) = ( ( len <* 1 *> ) + ( len R13 ) ) by FINSEQ_1:22;
L339: ( ( len ( <* 1 *> ^ R13 ) ) + ( len R12 ) ) = ( len R14 ) by L332 , FINSEQ_1:22;
L340: ( ( len R12 ) + 1 ) <= ( len R14 ) by L339 , L338 , L330 , L337 , NAT_1:11;
L341: ( len R12 ) < ( len R14 ) by L340 , NAT_1:13;
L342: ( ( R11 ^ R15 ) ^ R17 ) = ( R11 ^ ( R15 ^ R17 ) ) by FINSEQ_1:32;
L343:
now
L344: ( len <* 1 *> ) = 1 by FINSEQ_1:40;
given R18 being FinSequence such that
L345: R13 = ( R11 ^ R18 );

L346: ( len ( <* 1 *> ^ R13 ) ) = ( ( len <* 1 *> ) + ( len R13 ) ) by FINSEQ_1:22;
L347: ( ( len ( <* 1 *> ^ R13 ) ) + ( len R12 ) ) = ( len R14 ) by L332 , FINSEQ_1:22;
L348: ( ( len R13 ) + 1 ) <= ( len R14 ) by L347 , L346 , L344 , NAT_1:11;
L349: ( len R13 ) < ( len R14 ) by L348 , NAT_1:13;
thus L350: R13 = R11 by L349 , L271 , L272 , L345;
end;
L351: ( ( <* 1 *> ^ ( R11 ^ R15 ) ) ^ R17 ) = ( <* 1 *> ^ ( ( R11 ^ R15 ) ^ R17 ) ) by FINSEQ_1:32;
L352:
now
L353: ( len ( <* 1 *> ^ R11 ) ) = ( ( len <* 1 *> ) + ( len R11 ) ) by FINSEQ_1:22;
L354: ( len <* 1 *> ) = 1 by FINSEQ_1:40;
L355: ( ( ( ( len R11 ) + 1 ) + ( len R15 ) ) + ( len R17 ) ) = ( ( ( len R11 ) + 1 ) + ( ( len R15 ) + ( len R17 ) ) );
given R18 being FinSequence such that
L356: R11 = ( R13 ^ R18 );

L357: ( len ( R10 ^ R17 ) ) = ( ( len R10 ) + ( len R17 ) ) by FINSEQ_1:22;
L358: ( len R10 ) = ( ( len ( <* 1 *> ^ R11 ) ) + ( len R15 ) ) by L336 , FINSEQ_1:22;
L359: ( ( len R11 ) + 1 ) <= ( len R14 ) by L358 , L273 , L357 , L354 , L353 , L355 , NAT_1:11;
L360: ( len R11 ) < ( len R14 ) by L359 , NAT_1:13;
thus L361: R11 = R13 by L360 , L271 , L272 , L356;
end;
L362: ( ( <* 1 *> ^ R11 ) ^ R15 ) = ( <* 1 *> ^ ( R11 ^ R15 ) ) by FINSEQ_1:32;
L363: ( ( <* 1 *> ^ R13 ) ^ R12 ) = ( <* 1 *> ^ ( R13 ^ R12 ) ) by FINSEQ_1:32;
L364: ( R13 ^ R12 ) = ( R11 ^ ( R15 ^ R17 ) ) by L363 , L273 , L332 , L336 , L362 , L351 , L342 , FINSEQ_1:33;
L365: (( len R11 ) <= ( len R13 ) implies (ex R18 being FinSequence st R13 = ( R11 ^ R18 ))) by L364 , FINSEQ_1:47;
L366: R12 = ( R15 ^ R17 ) by L365 , L364 , L343 , L352 , FINSEQ_1:33 , FINSEQ_1:47;
thus L367: thesis by L366 , L271 , L272 , L273 , L336 , L362 , L351 , L342 , L341;
end;
L368:
now
L369: ( len <* 3 *> ) = 1 by FINSEQ_1:40;
assume L370: R14 is  ExistGlobal;
consider R15 being CTL-formula such that L371: R14 = ( EG R15 ) by L370 , L143;
L372: ( ( R10 ^ R17 ) . 1 ) = 3 by L273 , L370 , L209;
L373: ( R10 . 1 ) = 3 by L372 , L276 , FINSEQ_1:def 7;
L374: R10 is  ExistGlobal by L373 , L226;
consider R11 being CTL-formula such that L375: R10 = ( EG R11 ) by L374 , L143;
L376: ( ( len <* 3 *> ) + ( len R15 ) ) = ( len R14 ) by L371 , FINSEQ_1:22;
L377: ( len R15 ) < ( len R14 ) by L376 , L369 , NAT_1:13;
L378: ( ( <* 3 *> ^ R11 ) ^ R17 ) = ( <* 3 *> ^ ( R11 ^ R17 ) ) by FINSEQ_1:32;
L379: R15 = ( R11 ^ R17 ) by L378 , L273 , L371 , L375 , FINSEQ_1:33;
thus L380: thesis by L379 , L271 , L272 , L371 , L375 , L377;
end;
L381:
now
L382: ( len <* 2 *> ) = 1 by FINSEQ_1:40;
assume L383: R14 is  ExistNext;
consider R15 being CTL-formula such that L384: R14 = ( EX R15 ) by L383 , L142;
L385: ( ( R10 ^ R17 ) . 1 ) = 2 by L273 , L383 , L205;
L386: ( R10 . 1 ) = 2 by L385 , L276 , FINSEQ_1:def 7;
L387: R10 is  ExistNext by L386 , L226;
consider R11 being CTL-formula such that L388: R10 = ( EX R11 ) by L387 , L142;
L389: ( ( len <* 2 *> ) + ( len R15 ) ) = ( len R14 ) by L384 , FINSEQ_1:22;
L390: ( len R15 ) < ( len R14 ) by L389 , L382 , NAT_1:13;
L391: ( ( <* 2 *> ^ R11 ) ^ R17 ) = ( <* 2 *> ^ ( R11 ^ R17 ) ) by FINSEQ_1:32;
L392: R15 = ( R11 ^ R17 ) by L391 , L273 , L384 , L388 , FINSEQ_1:33;
thus L393: thesis by L392 , L271 , L272 , L384 , L388 , L390;
end;
L394: ( ( len R10 ) + ( len R17 ) ) = ( len ( R10 ^ R17 ) ) by FINSEQ_1:22;
L395:
now
L396: 1 <= ( len R10 ) by L240;
assume L397: R14 is  atomic;
L398: (ex R1 being (Element of ( NAT )) st R14 = ( atom. R1 )) by L397 , L139;
L399: ( len R14 ) = 1 by L398 , FINSEQ_1:40;
L400: ( len R10 ) <= 1 by L399 , L273 , L394 , NAT_1:11;
L401: ( 1 + ( len R17 ) ) = ( 1 + ( 0 ) ) by L400 , L273 , L394 , L399 , L396 , XXREAL_0:1;
L402: R17 = ( {} ) by L401;
thus L403: thesis by L402 , L273 , FINSEQ_1:34;
end;
thus L404: thesis by L395 , L277 , L329 , L381 , L368 , L290 , L147;
end;
L405: (for B7 being Nat holds ((for B8 being Nat holds (B8 < B7 implies S3[ B8 ])) implies S3[ B7 ])) by L270;
L406: (for B9 being Nat holds S3[ B9 ]) from NAT_1:sch 4(L405);
L407: ( len R14 ) = ( len R14 );
thus L408: thesis by L407 , L406;
end;
L409: (for R12 being CTL-formula holds (for R13 being CTL-formula holds (for R14 being CTL-formula holds (for R15 being CTL-formula holds (( R14 '&' R12 ) = ( R15 '&' R13 ) implies (R14 = R15 & R12 = R13))))))
proof
let R12 being CTL-formula;
let R13 being CTL-formula;
let R14 being CTL-formula;
let R15 being CTL-formula;
assume L410: ( R14 '&' R12 ) = ( R15 '&' R13 );
L411: ( ( <* 1 *> ^ R15 ) ^ R13 ) = ( <* 1 *> ^ ( R15 ^ R13 ) ) by FINSEQ_1:32;
L412: ( ( <* 1 *> ^ R14 ) ^ R12 ) = ( <* 1 *> ^ ( R14 ^ R12 ) ) by FINSEQ_1:32;
L413: ( R14 ^ R12 ) = ( R15 ^ R13 ) by L412 , L410 , L411 , FINSEQ_1:33;
L414: (( len R15 ) <= ( len R14 ) implies (ex R17 being FinSequence st R14 = ( R15 ^ R17 ))) by L413 , FINSEQ_1:47;
L415: (( len R14 ) <= ( len R15 ) implies (ex R17 being FinSequence st R15 = ( R14 ^ R17 ))) by L413 , FINSEQ_1:47;
thus L416: R14 = R15 by L415 , L414 , L269;
L417: ((ex R17 being FinSequence st R15 = ( R14 ^ R17 )) implies R15 = R14) by L269;
thus L418: thesis by L417 , L410 , L414 , L415 , L269 , FINSEQ_1:33;
end;
L419: (for R12 being CTL-formula holds (for R13 being CTL-formula holds (for R14 being CTL-formula holds (for R15 being CTL-formula holds (( R14 EU R12 ) = ( R15 EU R13 ) implies (R14 = R15 & R12 = R13))))))
proof
let R12 being CTL-formula;
let R13 being CTL-formula;
let R14 being CTL-formula;
let R15 being CTL-formula;
assume L420: ( R14 EU R12 ) = ( R15 EU R13 );
L421: ( ( <* 4 *> ^ R15 ) ^ R13 ) = ( <* 4 *> ^ ( R15 ^ R13 ) ) by FINSEQ_1:32;
L422: ( ( <* 4 *> ^ R14 ) ^ R12 ) = ( <* 4 *> ^ ( R14 ^ R12 ) ) by FINSEQ_1:32;
L423: ( R14 ^ R12 ) = ( R15 ^ R13 ) by L422 , L420 , L421 , FINSEQ_1:33;
L424: (( len R15 ) <= ( len R14 ) implies (ex R17 being FinSequence st R14 = ( R15 ^ R17 ))) by L423 , FINSEQ_1:47;
L425: (( len R14 ) <= ( len R15 ) implies (ex R17 being FinSequence st R15 = ( R14 ^ R17 ))) by L423 , FINSEQ_1:47;
thus L426: R14 = R15 by L425 , L424 , L269;
L427: ((ex R17 being FinSequence st R15 = ( R14 ^ R17 )) implies R15 = R14) by L269;
thus L428: thesis by L427 , L420 , L424 , L425 , L269 , FINSEQ_1:33;
end;
L429: (for R14 being CTL-formula holds (R14 is  atomic implies ((not R14 is  negative) & (not R14 is  conjunctive) & (not R14 is  ExistNext) & (not R14 is  ExistGlobal) & (not R14 is  ExistUntill))))
proof
let R14 being CTL-formula;
assume L430: R14 is  atomic;
L431: (not ( R14 . 1 ) = 1) by L430 , L218;
L432: (not ( R14 . 1 ) = 3) by L430 , L218;
L433: (not ( R14 . 1 ) = 2) by L430 , L218;
L434: (not ( R14 . 1 ) = 4) by L430 , L218;
L435: (not ( R14 . 1 ) = ( 0 )) by L430 , L218;
thus L436: thesis by L435 , L431 , L433 , L432 , L434 , L196 , L200 , L205 , L209 , L213;
end;
L437: (for R14 being CTL-formula holds (R14 is  negative implies ((not R14 is  atomic) & (not R14 is  conjunctive) & (not R14 is  ExistNext) & (not R14 is  ExistGlobal) & (not R14 is  ExistUntill))))
proof
let R14 being CTL-formula;
assume L438: R14 is  negative;
L439: ( R14 . 1 ) = ( 0 ) by L438 , L196;
thus L440: thesis by L439 , L200 , L205 , L209 , L213 , L218;
end;
L441: (for R14 being CTL-formula holds (R14 is  conjunctive implies ((not R14 is  atomic) & (not R14 is  negative) & (not R14 is  ExistNext) & (not R14 is  ExistGlobal) & (not R14 is  ExistUntill))))
proof
let R14 being CTL-formula;
assume L442: R14 is  conjunctive;
L443: ( R14 . 1 ) = 1 by L442 , L200;
thus L444: thesis by L443 , L196 , L205 , L209 , L213 , L218;
end;
L445: (for R14 being CTL-formula holds (R14 is  ExistNext implies ((not R14 is  atomic) & (not R14 is  conjunctive) & (not R14 is  negative) & (not R14 is  ExistGlobal) & (not R14 is  ExistUntill))))
proof
let R14 being CTL-formula;
assume L446: R14 is  ExistNext;
L447: ( R14 . 1 ) = 2 by L446 , L205;
thus L448: thesis by L447 , L196 , L200 , L209 , L213 , L218;
end;
L449: (for R14 being CTL-formula holds (R14 is  ExistGlobal implies ((not R14 is  atomic) & (not R14 is  conjunctive) & (not R14 is  negative) & (not R14 is  ExistNext) & (not R14 is  ExistUntill))))
proof
let R14 being CTL-formula;
assume L450: R14 is  ExistGlobal;
L451: ( R14 . 1 ) = 3 by L450 , L209;
thus L452: thesis by L451 , L196 , L200 , L205 , L213 , L218;
end;
definition
let R14 being CTL-formula;
assume L453: (R14 is  negative or R14 is  ExistNext or R14 is  ExistGlobal);
func the_argument_of R14 -> CTL-formula means
:L454: ( 'not' it ) = R14 if R14 is  negative , ( EX it ) = R14 if R14 is  ExistNext otherwise ( EG it ) = R14;
existence by L453 , L140 , L142 , L143;
uniqueness by FINSEQ_1:33;
consistency by L437;
end;
definition
let R14 being CTL-formula;
assume L456: (R14 is  conjunctive or R14 is  ExistUntill);
func the_left_argument_of R14 -> CTL-formula means
:L457: (ex R15 being CTL-formula st ( it '&' R15 ) = R14) if R14 is  conjunctive otherwise (ex R15 being CTL-formula st ( it EU R15 ) = R14);
existence by L456 , L141 , L144;
uniqueness by L409 , L419;
consistency;
func the_right_argument_of R14 -> CTL-formula means
:L458: (ex R15 being CTL-formula st ( R15 '&' it ) = R14) if R14 is  conjunctive otherwise (ex R15 being CTL-formula st ( R15 EU it ) = R14);
existence
proof
thus L459: (R14 is  conjunctive implies (ex R12 being CTL-formula st (ex R15 being CTL-formula st ( R15 '&' R12 ) = R14)))
proof
assume L460: R14 is  conjunctive;
consider R12 being CTL-formula, R10 being CTL-formula such that L461: ( R12 '&' R10 ) = R14 by L460 , L141;
take R10;
thus L462: thesis by L461;
end;

thus L463: ((not R14 is  conjunctive) implies (ex R12 being CTL-formula st (ex R15 being CTL-formula st ( R15 EU R12 ) = R14)))
proof
assume L464: (not R14 is  conjunctive);
consider R12 being CTL-formula, R10 being CTL-formula such that L465: ( R12 EU R10 ) = R14 by L464 , L456 , L144;
take R10;
thus L466: thesis by L465;
end;

end;
uniqueness by L409 , L419;
consistency;
end;
L465: (for R14 being CTL-formula holds (R14 is  ExistGlobal implies R14 = ( EG ( the_argument_of R14 ) )))
proof
let R14 being CTL-formula;
assume L466: R14 is  ExistGlobal;
L467: (not R14 is  ExistNext) by L466 , L449;
L468: (not R14 is  negative) by L466 , L449;
thus L469: thesis by L468 , L466 , L467 , L454;
end;
L470: (for R14 being CTL-formula holds (R14 is  conjunctive implies R14 = ( ( the_left_argument_of R14 ) '&' ( the_right_argument_of R14 ) )))
proof
let R14 being CTL-formula;
assume L471: R14 is  conjunctive;
L472: (ex R15 being CTL-formula st R14 = ( R15 '&' ( the_right_argument_of R14 ) )) by L471 , L458;
thus L473: thesis by L472 , L471 , L457;
end;
L474: (for R14 being CTL-formula holds (R14 is  ExistUntill implies R14 = ( ( the_left_argument_of R14 ) EU ( the_right_argument_of R14 ) )))
proof
let R14 being CTL-formula;
assume L475: R14 is  ExistUntill;
L476: ( R14 . 1 ) = 4 by L475 , L213;
L477: (not R14 is  conjunctive) by L476 , L200;
L478: (ex R15 being CTL-formula st R14 = ( R15 EU ( the_right_argument_of R14 ) )) by L477 , L475 , L458;
thus L479: thesis by L478 , L475 , L477 , L457;
end;
L480: (for R14 being CTL-formula holds ((R14 is  negative or R14 is  ExistNext or R14 is  ExistGlobal) implies ( len ( the_argument_of R14 ) ) < ( len R14 )))
proof
let R14 being CTL-formula;
assume L481: (R14 is  negative or R14 is  ExistNext or R14 is  ExistGlobal);
per cases  by L481;
suppose L482: R14 is  negative;

L483: R14 = ( 'not' ( the_argument_of R14 ) ) by L482 , L454;
L484: ( len R14 ) = ( 1 + ( len ( the_argument_of R14 ) ) ) by L483 , FINSEQ_5:8;
thus L485: thesis by L484 , NAT_1:19;
end;
suppose L486: R14 is  ExistNext;

L487: R14 = ( EX ( the_argument_of R14 ) ) by L486 , L454;
L488: ( len R14 ) = ( 1 + ( len ( the_argument_of R14 ) ) ) by L487 , FINSEQ_5:8;
thus L489: thesis by L488 , NAT_1:19;
end;
suppose L490: R14 is  ExistGlobal;

L491: R14 = ( EG ( the_argument_of R14 ) ) by L490 , L465;
L492: ( len R14 ) = ( 1 + ( len ( the_argument_of R14 ) ) ) by L491 , FINSEQ_5:8;
thus L493: thesis by L492 , NAT_1:19;
end;
end;
L495: (for R14 being CTL-formula holds ((R14 is  conjunctive or R14 is  ExistUntill) implies (( len ( the_left_argument_of R14 ) ) < ( len R14 ) & ( len ( the_right_argument_of R14 ) ) < ( len R14 ))))
proof
let R14 being CTL-formula;
set D13 = ( len ( the_left_argument_of R14 ) );
set D14 = ( len ( the_right_argument_of R14 ) );
set D15 = ( D14 + 1 );
assume L496: (R14 is  conjunctive or R14 is  ExistUntill);
per cases  by L496;
suppose L497: R14 is  conjunctive;

L498: R14 = ( ( the_left_argument_of R14 ) '&' ( the_right_argument_of R14 ) ) by L497 , L470;
L499: ( len R14 ) = ( ( 1 + D13 ) + D14 ) by L498 , L20;
L500: 1 <= D15 by NAT_1:11;
L501: D13 < ( D13 + D15 ) by L500 , NAT_1:19;
L502: 1 <= ( 1 + D13 ) by NAT_1:11;
thus L503: thesis by L502 , L499 , L501 , NAT_1:19;
end;
suppose L504: R14 is  ExistUntill;

L505: R14 = ( ( the_left_argument_of R14 ) EU ( the_right_argument_of R14 ) ) by L504 , L474;
L506: ( len R14 ) = ( ( 1 + D13 ) + D14 ) by L505 , L20;
L507: 1 <= D15 by NAT_1:11;
L508: D13 < ( D13 + D15 ) by L507 , NAT_1:19;
L509: 1 <= ( 1 + D13 ) by NAT_1:11;
thus L510: thesis by L509 , L506 , L508 , NAT_1:19;
end;
end;
definition
let C16 being set;
func CastCTLformula C16 -> CTL-formula equals
:L512: C16 if C16 in ( CTL_WFF ) otherwise ( atom. ( 0 ) );
correctness by L111;
end;
definition
let C17 being set;
struct (RelStr) KripkeStr over C17(# carrier -> set , Starts -> (Subset of the carrier) , InternalRel -> (Relation of the carrier , the carrier) , Label -> (Function of the carrier , ( bool C17 )) #);
end;
definition
struct (ComplULattStr) CTLModelStr(# carrier -> set , BasicAssign -> (Subset of the carrier) , L_meet -> (BinOp of the carrier) , Compl -> (UnOp of the carrier) , EneXt -> (UnOp of the carrier) , EGlobal -> (UnOp of the carrier) , EUntill -> (BinOp of the carrier) #);
end;
definition
let C18 being CTLModelStr;
mode Assign of C18
 is (Element of (the carrier of C18));
end;
definition
func atomic_WFF -> (Subset of ( CTL_WFF )) equals
{ B10 where B10 is CTL-formula : B10 is  atomic };
correctness
proof
set D16 = { B11 where B11 is CTL-formula : B11 is  atomic };
L517: D16 c= ( CTL_WFF )
proof
let C19 being set;
assume L518: C19 in D16;
L519: (ex B12 being CTL-formula st (C19 = B12 & B12 is  atomic)) by L518;
thus L520: thesis by L519 , L111;
end;
thus L521: thesis by L517;
end;
end;
definition
let C20 being CTLModelStr;
let C21 being (Function of ( atomic_WFF ) , (the BasicAssign of C20));
let C22 being (Function of ( CTL_WFF ) , (the carrier of C20));
pred C22 is-Evaluation-for C21
means
:L523: (for B13 being CTL-formula holds ((B13 is  atomic implies ( C22 . B13 ) = ( C21 . B13 )) & (B13 is  negative implies ( C22 . B13 ) = ( (the Compl of C20) . ( C22 . ( the_argument_of B13 ) ) )) & (B13 is  conjunctive implies ( C22 . B13 ) = ( (the L_meet of C20) . (( C22 . ( the_left_argument_of B13 ) ) , ( C22 . ( the_right_argument_of B13 ) )) )) & (B13 is  ExistNext implies ( C22 . B13 ) = ( (the EneXt of C20) . ( C22 . ( the_argument_of B13 ) ) )) & (B13 is  ExistGlobal implies ( C22 . B13 ) = ( (the EGlobal of C20) . ( C22 . ( the_argument_of B13 ) ) )) & (B13 is  ExistUntill implies ( C22 . B13 ) = ( (the EUntill of C20) . (( C22 . ( the_left_argument_of B13 ) ) , ( C22 . ( the_right_argument_of B13 ) )) ))))
;end;
definition
let C23 being CTLModelStr;
let C24 being (Function of ( atomic_WFF ) , (the BasicAssign of C23));
let C25 being (Function of ( CTL_WFF ) , (the carrier of C23));
let C26 being (Element of ( NAT ));
pred C25 is-PreEvaluation-for C26 , C24
means
:L525: (for B14 being CTL-formula holds (( len B14 ) <= C26 implies ((B14 is  atomic implies ( C25 . B14 ) = ( C24 . B14 )) & (B14 is  negative implies ( C25 . B14 ) = ( (the Compl of C23) . ( C25 . ( the_argument_of B14 ) ) )) & (B14 is  conjunctive implies ( C25 . B14 ) = ( (the L_meet of C23) . (( C25 . ( the_left_argument_of B14 ) ) , ( C25 . ( the_right_argument_of B14 ) )) )) & (B14 is  ExistNext implies ( C25 . B14 ) = ( (the EneXt of C23) . ( C25 . ( the_argument_of B14 ) ) )) & (B14 is  ExistGlobal implies ( C25 . B14 ) = ( (the EGlobal of C23) . ( C25 . ( the_argument_of B14 ) ) )) & (B14 is  ExistUntill implies ( C25 . B14 ) = ( (the EUntill of C23) . (( C25 . ( the_left_argument_of B14 ) ) , ( C25 . ( the_right_argument_of B14 ) )) )))))
;end;
definition
let C27 being CTLModelStr;
let C28 being (Function of ( atomic_WFF ) , (the BasicAssign of C27));
let C29 , C30 being (Function of ( CTL_WFF ) , (the carrier of C27));
let C31 being (Element of ( NAT ));
let C32 being CTL-formula;
func GraftEval (C27 , C28 , C29 , C30 , C31 , C32) -> set equals
:L527: ( C29 . C32 ) if ( len C32 ) > ( C31 + 1 ) , ( C28 . C32 ) if (( len C32 ) = ( C31 + 1 ) & C32 is  atomic) , ( (the Compl of C27) . ( C30 . ( the_argument_of C32 ) ) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  negative) , ( (the L_meet of C27) . (( C30 . ( the_left_argument_of C32 ) ) , ( C30 . ( the_right_argument_of C32 ) )) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  conjunctive) , ( (the EneXt of C27) . ( C30 . ( the_argument_of C32 ) ) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  ExistNext) , ( (the EGlobal of C27) . ( C30 . ( the_argument_of C32 ) ) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  ExistGlobal) , ( (the EUntill of C27) . (( C30 . ( the_left_argument_of C32 ) ) , ( C30 . ( the_right_argument_of C32 ) )) ) if (( len C32 ) = ( C31 + 1 ) & C32 is  ExistUntill) , ( C30 . C32 ) if ( len C32 ) < ( C31 + 1 ) otherwise ( {} );
coherence;
consistency by L429 , L437 , L441 , L445 , L449;
end;
definition
let C33 being CTLModelStr;
attr C33 is  with_basic
means
:L529: (the BasicAssign of C33) is non  empty;
end;
definition
func TrivialCTLModel -> CTLModelStr equals
CTLModelStr (# 1 , ( [#] 1 ) , ( op2 ) , ( op1 ) , ( op1 ) , ( op1 ) , ( op2 ) #);
coherence;
end;
registration
cluster ( TrivialCTLModel ) ->  with_basic  strict non  empty;
coherence
proof
thus L532: (the BasicAssign of ( TrivialCTLModel )) is non  empty;
thus L533: thesis;
end;
end;
registration
cluster non  empty for CTLModelStr;
existence
proof
take ( TrivialCTLModel );
thus L535: thesis;
end;
end;
registration
cluster  with_basic for non  empty non  empty non  empty non  empty CTLModelStr;
existence
proof
take ( TrivialCTLModel );
thus L537: thesis;
end;
end;
definition
mode CTLModel
 is  with_basic non  empty CTLModelStr;
end;
registration
let C34 being CTLModel;
cluster (the BasicAssign of C34) -> non  empty;
coherence by L529;
end;
L541: (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R21 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds R21 is-PreEvaluation-for ( 0 ) , R20)))
proof
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
let R21 being (Function of ( CTL_WFF ) , (the carrier of R19));
L542: (for B15 being CTL-formula holds (( len B15 ) <= ( 0 ) implies ((B15 is  atomic implies ( R21 . B15 ) = ( R20 . B15 )) & (B15 is  negative implies ( R21 . B15 ) = ( (the Compl of R19) . ( R21 . ( the_argument_of B15 ) ) )) & (B15 is  conjunctive implies ( R21 . B15 ) = ( (the L_meet of R19) . (( R21 . ( the_left_argument_of B15 ) ) , ( R21 . ( the_right_argument_of B15 ) )) )) & (B15 is  ExistNext implies ( R21 . B15 ) = ( (the EneXt of R19) . ( R21 . ( the_argument_of B15 ) ) )) & (B15 is  ExistGlobal implies ( R21 . B15 ) = ( (the EGlobal of R19) . ( R21 . ( the_argument_of B15 ) ) )) & (B15 is  ExistUntill implies ( R21 . B15 ) = ( (the EUntill of R19) . (( R21 . ( the_left_argument_of B15 ) ) , ( R21 . ( the_right_argument_of B15 ) )) ))))) by L240;
thus L543: thesis by L542 , L525;
end;
L544: (for R2 being (Element of ( NAT )) holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R21 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds (R21 is-PreEvaluation-for ( R2 + 1 ) , R20 implies R21 is-PreEvaluation-for R2 , R20)))))
proof
let R2 being (Element of ( NAT ));
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
let R21 being (Function of ( CTL_WFF ) , (the carrier of R19));
assume L545: R21 is-PreEvaluation-for ( R2 + 1 ) , R20;
L546: (for B16 being CTL-formula holds (( len B16 ) <= R2 implies ((B16 is  atomic implies ( R21 . B16 ) = ( R20 . B16 )) & (B16 is  negative implies ( R21 . B16 ) = ( (the Compl of R19) . ( R21 . ( the_argument_of B16 ) ) )) & (B16 is  conjunctive implies ( R21 . B16 ) = ( (the L_meet of R19) . (( R21 . ( the_left_argument_of B16 ) ) , ( R21 . ( the_right_argument_of B16 ) )) )) & (B16 is  ExistNext implies ( R21 . B16 ) = ( (the EneXt of R19) . ( R21 . ( the_argument_of B16 ) ) )) & (B16 is  ExistGlobal implies ( R21 . B16 ) = ( (the EGlobal of R19) . ( R21 . ( the_argument_of B16 ) ) )) & (B16 is  ExistUntill implies ( R21 . B16 ) = ( (the EUntill of R19) . (( R21 . ( the_left_argument_of B16 ) ) , ( R21 . ( the_right_argument_of B16 ) )) )))))
proof
let C35 being CTL-formula;
assume L547: ( len C35 ) <= R2;
L548: ( len C35 ) < ( R2 + 1 ) by L547 , NAT_1:13;
thus L549: thesis by L548 , L545 , L525;
end;
thus L550: thesis by L546 , L525;
end;
L551: (for R2 being (Element of ( NAT )) holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R21 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds (R21 is-Evaluation-for R20 implies R21 is-PreEvaluation-for R2 , R20)))))
proof
let R2 being (Element of ( NAT ));
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
let R21 being (Function of ( CTL_WFF ) , (the carrier of R19));
assume L552: R21 is-Evaluation-for R20;
L553: (for B17 being CTL-formula holds (( len B17 ) <= R2 implies ((B17 is  atomic implies ( R21 . B17 ) = ( R20 . B17 )) & (B17 is  negative implies ( R21 . B17 ) = ( (the Compl of R19) . ( R21 . ( the_argument_of B17 ) ) )) & (B17 is  conjunctive implies ( R21 . B17 ) = ( (the L_meet of R19) . (( R21 . ( the_left_argument_of B17 ) ) , ( R21 . ( the_right_argument_of B17 ) )) )) & (B17 is  ExistNext implies ( R21 . B17 ) = ( (the EneXt of R19) . ( R21 . ( the_argument_of B17 ) ) )) & (B17 is  ExistGlobal implies ( R21 . B17 ) = ( (the EGlobal of R19) . ( R21 . ( the_argument_of B17 ) ) )) & (B17 is  ExistUntill implies ( R21 . B17 ) = ( (the EUntill of R19) . (( R21 . ( the_left_argument_of B17 ) ) , ( R21 . ( the_right_argument_of B17 ) )) ))))) by L552 , L523;
thus L554: thesis by L553 , L525;
end;
L555: (for R2 being (Element of ( NAT )) holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R22 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds (for R23 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds ((R22 is-PreEvaluation-for R2 , R20 & R23 is-PreEvaluation-for R2 , R20) implies (for B18 being CTL-formula holds (( len B18 ) <= R2 implies ( R22 . B18 ) = ( R23 . B18 )))))))))
proof
let R2 being (Element of ( NAT ));
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
let R22 being (Function of ( CTL_WFF ) , (the carrier of R19));
let R23 being (Function of ( CTL_WFF ) , (the carrier of R19));
defpred S4[ (Element of ( NAT )) ] means ((R22 is-PreEvaluation-for $1 , R20 & R23 is-PreEvaluation-for $1 , R20) implies (for B19 being CTL-formula holds (( len B19 ) <= $1 implies ( R22 . B19 ) = ( R23 . B19 ))));
L556: (for B20 being (Element of ( NAT )) holds (S4[ B20 ] implies S4[ ( B20 + 1 ) ]))
proof
let C36 being (Element of ( NAT ));
assume that
L557: S4[ C36 ];
assume that
L558: R22 is-PreEvaluation-for ( C36 + 1 ) , R20
and
L559: R23 is-PreEvaluation-for ( C36 + 1 ) , R20;
let C37 being CTL-formula;
assume that
L560: ( len C37 ) <= ( C36 + 1 );
per cases  by L147;
suppose L561: C37 is  atomic;

L562: ( R22 . C37 ) = ( R20 . C37 ) by L561 , L558 , L560 , L525;
thus L563: thesis by L562 , L559 , L560 , L561 , L525;
end;
suppose L564: C37 is  negative;

L565: ( len ( the_argument_of C37 ) ) < ( len C37 ) by L564 , L480;
L566: ( len ( the_argument_of C37 ) ) <= C36 by L565 , L560 , L1;
L567: ( R23 . C37 ) = ( (the Compl of R19) . ( R23 . ( the_argument_of C37 ) ) ) by L559 , L560 , L564 , L525
.= ( (the Compl of R19) . ( R22 . ( the_argument_of C37 ) ) ) by L557 , L558 , L559 , L566 , L544;
thus L568: thesis by L567 , L558 , L560 , L564 , L525;
end;
suppose L569: C37 is  ExistNext;

L570: ( len ( the_argument_of C37 ) ) < ( len C37 ) by L569 , L480;
L571: ( len ( the_argument_of C37 ) ) <= C36 by L570 , L560 , L1;
L572: ( R23 . C37 ) = ( (the EneXt of R19) . ( R23 . ( the_argument_of C37 ) ) ) by L559 , L560 , L569 , L525
.= ( (the EneXt of R19) . ( R22 . ( the_argument_of C37 ) ) ) by L557 , L558 , L559 , L571 , L544;
thus L573: thesis by L572 , L558 , L560 , L569 , L525;
end;
suppose L574: C37 is  ExistGlobal;

L575: ( len ( the_argument_of C37 ) ) < ( len C37 ) by L574 , L480;
L576: ( len ( the_argument_of C37 ) ) <= C36 by L575 , L560 , L1;
L577: ( R23 . C37 ) = ( (the EGlobal of R19) . ( R23 . ( the_argument_of C37 ) ) ) by L559 , L560 , L574 , L525
.= ( (the EGlobal of R19) . ( R22 . ( the_argument_of C37 ) ) ) by L557 , L558 , L559 , L576 , L544;
thus L578: thesis by L577 , L558 , L560 , L574 , L525;
end;
suppose L579: C37 is  conjunctive;

L580: ( len ( the_left_argument_of C37 ) ) < ( len C37 ) by L579 , L495;
L581: ( len ( the_left_argument_of C37 ) ) <= C36 by L580 , L560 , L1;
L582: ( R22 . ( the_left_argument_of C37 ) ) = ( R23 . ( the_left_argument_of C37 ) ) by L581 , L557 , L558 , L559 , L544;
L583: ( len ( the_right_argument_of C37 ) ) < ( len C37 ) by L579 , L495;
L584: ( len ( the_right_argument_of C37 ) ) <= C36 by L583 , L560 , L1;
L585: ( R23 . C37 ) = ( (the L_meet of R19) . (( R23 . ( the_left_argument_of C37 ) ) , ( R23 . ( the_right_argument_of C37 ) )) ) by L559 , L560 , L579 , L525
.= ( (the L_meet of R19) . (( R22 . ( the_left_argument_of C37 ) ) , ( R22 . ( the_right_argument_of C37 ) )) ) by L557 , L558 , L559 , L582 , L584 , L544;
thus L586: thesis by L585 , L558 , L560 , L579 , L525;
end;
suppose L587: C37 is  ExistUntill;

L588: ( len ( the_left_argument_of C37 ) ) < ( len C37 ) by L587 , L495;
L589: ( len ( the_left_argument_of C37 ) ) <= C36 by L588 , L560 , L1;
L590: ( R22 . ( the_left_argument_of C37 ) ) = ( R23 . ( the_left_argument_of C37 ) ) by L589 , L557 , L558 , L559 , L544;
L591: ( len ( the_right_argument_of C37 ) ) < ( len C37 ) by L587 , L495;
L592: ( len ( the_right_argument_of C37 ) ) <= C36 by L591 , L560 , L1;
L593: ( R23 . C37 ) = ( (the EUntill of R19) . (( R23 . ( the_left_argument_of C37 ) ) , ( R23 . ( the_right_argument_of C37 ) )) ) by L559 , L560 , L587 , L525
.= ( (the EUntill of R19) . (( R22 . ( the_left_argument_of C37 ) ) , ( R22 . ( the_right_argument_of C37 ) )) ) by L557 , L558 , L559 , L590 , L592 , L544;
thus L594: thesis by L593 , L558 , L560 , L587 , L525;
end;
end;
L596: S4[ ( 0 ) ] by L240;
L597: (for B21 being (Element of ( NAT )) holds S4[ B21 ]) from NAT_1:sch 1(L596 , L556);
thus L598: thesis by L597;
end;
L599: (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R2 being (Element of ( NAT )) holds (ex R21 being (Function of ( CTL_WFF ) , (the carrier of R19)) st R21 is-PreEvaluation-for R2 , R20))))
proof
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
defpred S5[ (Element of ( NAT )) ] means (ex B22 being (Function of ( CTL_WFF ) , (the carrier of R19)) st B22 is-PreEvaluation-for $1 , R20);
L600: (for B23 being (Element of ( NAT )) holds (S5[ B23 ] implies S5[ ( B23 + 1 ) ]))
proof
let C38 being (Element of ( NAT ));
assume L601: S5[ C38 ];
consider C39 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L602: C39 is-PreEvaluation-for C38 , R20 by L601;
L603: S5[ ( C38 + 1 ) ]
proof
deffunc H1(set) = ( GraftEval (R19 , R20 , C39 , C39 , C38 , ( CastCTLformula $1 )) );
L604: (for B24 being set holds (B24 in ( CTL_WFF ) implies H1(B24) in (the carrier of R19)))
proof
let C40 being set;
assume that
L605: C40 in ( CTL_WFF );
reconsider D17 = C40 as CTL-formula by L605 , L111;
L606: H1(D17) = ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) by L605 , L512;
per cases  by L147 , XXREAL_0:1;
suppose L607: ( len D17 ) > ( C38 + 1 );

L608: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( C39 . D17 ) by L607 , L527;
thus L609: thesis by L608 , L605 , L606 , FUNCT_2:5;
end;
suppose L610: (( len D17 ) = ( C38 + 1 ) & D17 is  atomic);

L611: D17 in ( atomic_WFF ) by L610;
L612: ( R20 . D17 ) in (the BasicAssign of R19) by L611 , FUNCT_2:5;
L613: ( R20 . D17 ) in (the carrier of R19) by L612;
thus L614: thesis by L613 , L606 , L610 , L527;
end;
suppose L615: (( len D17 ) = ( C38 + 1 ) & D17 is  negative);

L616: ( the_argument_of D17 ) in ( CTL_WFF ) by L111;
L617: ( C39 . ( the_argument_of D17 ) ) in (the carrier of R19) by L616 , FUNCT_2:5;
L618: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( (the Compl of R19) . ( C39 . ( the_argument_of D17 ) ) ) by L615 , L527;
thus L619: thesis by L618 , L606 , L617 , FUNCT_2:5;
end;
suppose L620: (( len D17 ) = ( C38 + 1 ) & D17 is  conjunctive);

L621: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( (the L_meet of R19) . (( C39 . ( the_left_argument_of D17 ) ) , ( C39 . ( the_right_argument_of D17 ) )) ) by L620 , L527;
L622: ( the_right_argument_of D17 ) in ( CTL_WFF ) by L111;
L623: ( C39 . ( the_right_argument_of D17 ) ) in (the carrier of R19) by L622 , FUNCT_2:5;
L624: ( the_left_argument_of D17 ) in ( CTL_WFF ) by L111;
L625: ( C39 . ( the_left_argument_of D17 ) ) in (the carrier of R19) by L624 , FUNCT_2:5;
L626: [ ( C39 . ( the_left_argument_of D17 ) ) , ( C39 . ( the_right_argument_of D17 ) ) ] in [: (the carrier of R19) , (the carrier of R19) :] by L625 , L623 , ZFMISC_1:def 2;
thus L627: thesis by L626 , L606 , L621 , FUNCT_2:5;
end;
suppose L628: (( len D17 ) = ( C38 + 1 ) & D17 is  ExistNext);

L629: ( the_argument_of D17 ) in ( CTL_WFF ) by L111;
L630: ( C39 . ( the_argument_of D17 ) ) in (the carrier of R19) by L629 , FUNCT_2:5;
L631: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( (the EneXt of R19) . ( C39 . ( the_argument_of D17 ) ) ) by L628 , L527;
thus L632: thesis by L631 , L606 , L630 , FUNCT_2:5;
end;
suppose L633: (( len D17 ) = ( C38 + 1 ) & D17 is  ExistGlobal);

L634: ( the_argument_of D17 ) in ( CTL_WFF ) by L111;
L635: ( C39 . ( the_argument_of D17 ) ) in (the carrier of R19) by L634 , FUNCT_2:5;
L636: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( (the EGlobal of R19) . ( C39 . ( the_argument_of D17 ) ) ) by L633 , L527;
thus L637: thesis by L636 , L606 , L635 , FUNCT_2:5;
end;
suppose L638: (( len D17 ) = ( C38 + 1 ) & D17 is  ExistUntill);

L639: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( (the EUntill of R19) . (( C39 . ( the_left_argument_of D17 ) ) , ( C39 . ( the_right_argument_of D17 ) )) ) by L638 , L527;
L640: ( the_right_argument_of D17 ) in ( CTL_WFF ) by L111;
L641: ( C39 . ( the_right_argument_of D17 ) ) in (the carrier of R19) by L640 , FUNCT_2:5;
L642: ( the_left_argument_of D17 ) in ( CTL_WFF ) by L111;
L643: ( C39 . ( the_left_argument_of D17 ) ) in (the carrier of R19) by L642 , FUNCT_2:5;
L644: [ ( C39 . ( the_left_argument_of D17 ) ) , ( C39 . ( the_right_argument_of D17 ) ) ] in [: (the carrier of R19) , (the carrier of R19) :] by L643 , L641 , ZFMISC_1:def 2;
thus L645: thesis by L644 , L606 , L639 , FUNCT_2:5;
end;
suppose L646: ( len D17 ) < ( C38 + 1 );

L647: ( GraftEval (R19 , R20 , C39 , C39 , C38 , D17) ) = ( C39 . D17 ) by L646 , L527;
thus L648: thesis by L647 , L605 , L606 , FUNCT_2:5;
end;
end;
consider C41 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L650: (for B25 being set holds (B25 in ( CTL_WFF ) implies ( C41 . B25 ) = H1(B25))) from FUNCT_2:sch 2(L604);
take C41;
L651: (for B26 being CTL-formula holds (( len B26 ) < ( C38 + 1 ) implies ( C41 . B26 ) = ( C39 . B26 )))
proof
let C42 being CTL-formula;
assume that
L652: ( len C42 ) < ( C38 + 1 );
L653: C42 in ( CTL_WFF ) by L111;
L654: ( C41 . C42 ) = H1(C42) by L653 , L650
.= ( GraftEval (R19 , R20 , C39 , C39 , C38 , C42) ) by L653 , L512;
thus L655: thesis by L654 , L652 , L527;
end;
L656: (for B27 being CTL-formula holds (( len B27 ) <= ( C38 + 1 ) implies ((B27 is  atomic implies ( C41 . B27 ) = ( R20 . B27 )) & (B27 is  negative implies ( C41 . B27 ) = ( (the Compl of R19) . ( C41 . ( the_argument_of B27 ) ) )) & (B27 is  conjunctive implies ( C41 . B27 ) = ( (the L_meet of R19) . (( C41 . ( the_left_argument_of B27 ) ) , ( C41 . ( the_right_argument_of B27 ) )) )) & (B27 is  ExistNext implies ( C41 . B27 ) = ( (the EneXt of R19) . ( C41 . ( the_argument_of B27 ) ) )) & (B27 is  ExistGlobal implies ( C41 . B27 ) = ( (the EGlobal of R19) . ( C41 . ( the_argument_of B27 ) ) )) & (B27 is  ExistUntill implies ( C41 . B27 ) = ( (the EUntill of R19) . (( C41 . ( the_left_argument_of B27 ) ) , ( C41 . ( the_right_argument_of B27 ) )) )))))
proof
let C43 being CTL-formula;
assume that
L657: ( len C43 ) <= ( C38 + 1 );
L658: C43 in ( CTL_WFF ) by L111;
L659: ( C41 . C43 ) = H1(C43) by L658 , L650
.= ( GraftEval (R19 , R20 , C39 , C39 , C38 , C43) ) by L658 , L512;
L660: (C43 is  negative implies ( C41 . C43 ) = ( (the Compl of R19) . ( C41 . ( the_argument_of C43 ) ) ))
proof
assume L661: C43 is  negative;
L662: ( len ( the_argument_of C43 ) ) < ( len C43 ) by L661 , L480;
L663: ( len ( the_argument_of C43 ) ) <= C38 by L662 , L657 , L1;
L664: ( len ( the_argument_of C43 ) ) < ( C38 + 1 ) by L663 , NAT_1:13;
per cases  by L657 , NAT_1:8;
suppose L665: ( len C43 ) <= C38;

L666: ( len C43 ) < ( C38 + 1 ) by L665 , NAT_1:13;
L667: ( C41 . C43 ) = ( C39 . C43 ) by L666 , L651
.= ( (the Compl of R19) . ( C39 . ( the_argument_of C43 ) ) ) by L602 , L661 , L665 , L525;
thus L668: thesis by L667 , L651 , L664;
end;
suppose L669: ( len C43 ) = ( C38 + 1 );

L670: ( GraftEval (R19 , R20 , C39 , C39 , C38 , C43) ) = ( (the Compl of R19) . ( C39 . ( the_argument_of C43 ) ) ) by L669 , L661 , L527
.= ( (the Compl of R19) . ( C41 . ( the_argument_of C43 ) ) ) by L651 , L664;
thus L671: thesis by L670 , L659;
end;
end;
L673: (C43 is  ExistUntill implies ( C41 . C43 ) = ( (the EUntill of R19) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ))
proof
assume L674: C43 is  ExistUntill;
L675: ( len ( the_right_argument_of C43 ) ) < ( len C43 ) by L674 , L495;
L676: ( len ( the_right_argument_of C43 ) ) <= C38 by L675 , L657 , L1;
L677: ( len ( the_right_argument_of C43 ) ) < ( C38 + 1 ) by L676 , NAT_1:13;
L678: ( len ( the_left_argument_of C43 ) ) < ( len C43 ) by L674 , L495;
L679: ( len ( the_left_argument_of C43 ) ) <= C38 by L678 , L657 , L1;
L680: ( len ( the_left_argument_of C43 ) ) < ( C38 + 1 ) by L679 , NAT_1:13;
L681: ( C39 . ( the_left_argument_of C43 ) ) = ( C41 . ( the_left_argument_of C43 ) ) by L680 , L651;
per cases  by L657 , NAT_1:8;
suppose L682: ( len C43 ) <= C38;

L683: ( len C43 ) < ( C38 + 1 ) by L682 , NAT_1:13;
L684: ( C41 . C43 ) = ( C39 . C43 ) by L683 , L651
.= ( (the EUntill of R19) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L602 , L674 , L682 , L525;
thus L685: thesis by L684 , L651 , L681 , L677;
end;
suppose L686: ( len C43 ) = ( C38 + 1 );

L687: ( GraftEval (R19 , R20 , C39 , C39 , C38 , C43) ) = ( (the EUntill of R19) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L686 , L674 , L527
.= ( (the EUntill of R19) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ) by L651 , L681 , L677;
thus L688: thesis by L687 , L659;
end;
end;
L690: (C43 is  conjunctive implies ( C41 . C43 ) = ( (the L_meet of R19) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ))
proof
assume L691: C43 is  conjunctive;
L692: ( len ( the_right_argument_of C43 ) ) < ( len C43 ) by L691 , L495;
L693: ( len ( the_right_argument_of C43 ) ) <= C38 by L692 , L657 , L1;
L694: ( len ( the_right_argument_of C43 ) ) < ( C38 + 1 ) by L693 , NAT_1:13;
L695: ( len ( the_left_argument_of C43 ) ) < ( len C43 ) by L691 , L495;
L696: ( len ( the_left_argument_of C43 ) ) <= C38 by L695 , L657 , L1;
L697: ( len ( the_left_argument_of C43 ) ) < ( C38 + 1 ) by L696 , NAT_1:13;
L698: ( C39 . ( the_left_argument_of C43 ) ) = ( C41 . ( the_left_argument_of C43 ) ) by L697 , L651;
per cases  by L657 , NAT_1:8;
suppose L699: ( len C43 ) <= C38;

L700: ( len C43 ) < ( C38 + 1 ) by L699 , NAT_1:13;
L701: ( C41 . C43 ) = ( C39 . C43 ) by L700 , L651
.= ( (the L_meet of R19) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L602 , L691 , L699 , L525;
thus L702: thesis by L701 , L651 , L698 , L694;
end;
suppose L703: ( len C43 ) = ( C38 + 1 );

L704: ( GraftEval (R19 , R20 , C39 , C39 , C38 , C43) ) = ( (the L_meet of R19) . (( C39 . ( the_left_argument_of C43 ) ) , ( C39 . ( the_right_argument_of C43 ) )) ) by L703 , L691 , L527
.= ( (the L_meet of R19) . (( C41 . ( the_left_argument_of C43 ) ) , ( C41 . ( the_right_argument_of C43 ) )) ) by L651 , L698 , L694;
thus L705: thesis by L704 , L659;
end;
end;
L707: (C43 is  ExistGlobal implies ( C41 . C43 ) = ( (the EGlobal of R19) . ( C41 . ( the_argument_of C43 ) ) ))
proof
assume L708: C43 is  ExistGlobal;
L709: ( len ( the_argument_of C43 ) ) < ( len C43 ) by L708 , L480;
L710: ( len ( the_argument_of C43 ) ) <= C38 by L709 , L657 , L1;
L711: ( len ( the_argument_of C43 ) ) < ( C38 + 1 ) by L710 , NAT_1:13;
per cases  by L657 , NAT_1:8;
suppose L712: ( len C43 ) <= C38;

L713: ( len C43 ) < ( C38 + 1 ) by L712 , NAT_1:13;
L714: ( C41 . C43 ) = ( C39 . C43 ) by L713 , L651
.= ( (the EGlobal of R19) . ( C39 . ( the_argument_of C43 ) ) ) by L602 , L708 , L712 , L525;
thus L715: thesis by L714 , L651 , L711;
end;
suppose L716: ( len C43 ) = ( C38 + 1 );

L717: ( GraftEval (R19 , R20 , C39 , C39 , C38 , C43) ) = ( (the EGlobal of R19) . ( C39 . ( the_argument_of C43 ) ) ) by L716 , L708 , L527
.= ( (the EGlobal of R19) . ( C41 . ( the_argument_of C43 ) ) ) by L651 , L711;
thus L718: thesis by L717 , L659;
end;
end;
L720: (C43 is  ExistNext implies ( C41 . C43 ) = ( (the EneXt of R19) . ( C41 . ( the_argument_of C43 ) ) ))
proof
assume L721: C43 is  ExistNext;
L722: ( len ( the_argument_of C43 ) ) < ( len C43 ) by L721 , L480;
L723: ( len ( the_argument_of C43 ) ) <= C38 by L722 , L657 , L1;
L724: ( len ( the_argument_of C43 ) ) < ( C38 + 1 ) by L723 , NAT_1:13;
per cases  by L657 , NAT_1:8;
suppose L725: ( len C43 ) <= C38;

L726: ( len C43 ) < ( C38 + 1 ) by L725 , NAT_1:13;
L727: ( C41 . C43 ) = ( C39 . C43 ) by L726 , L651
.= ( (the EneXt of R19) . ( C39 . ( the_argument_of C43 ) ) ) by L602 , L721 , L725 , L525;
thus L728: thesis by L727 , L651 , L724;
end;
suppose L729: ( len C43 ) = ( C38 + 1 );

L730: ( GraftEval (R19 , R20 , C39 , C39 , C38 , C43) ) = ( (the EneXt of R19) . ( C39 . ( the_argument_of C43 ) ) ) by L729 , L721 , L527
.= ( (the EneXt of R19) . ( C41 . ( the_argument_of C43 ) ) ) by L651 , L724;
thus L731: thesis by L730 , L659;
end;
end;
L733: (C43 is  atomic implies ( C41 . C43 ) = ( R20 . C43 ))
proof
assume L734: C43 is  atomic;
per cases  by L657 , NAT_1:8;
suppose L735: ( len C43 ) <= C38;

L736: ( len C43 ) < ( C38 + 1 ) by L735 , NAT_1:13;
L737: ( C41 . C43 ) = ( C39 . C43 ) by L736 , L651
.= ( R20 . C43 ) by L602 , L734 , L735 , L525;
thus L738: thesis by L737;
end;
suppose L739: ( len C43 ) = ( C38 + 1 );

thus L740: thesis by L739 , L659 , L734 , L527;
end;
end;
thus L742: thesis by L733 , L660 , L690 , L720 , L707 , L673;
end;
thus L743: thesis by L656 , L525;
end;
thus L744: thesis by L603;
end;
L745: S5[ ( 0 ) ]
proof
consider C44 being set such that L746: C44 in (the carrier of R19) by XBOOLE_0:def 1;
set D18 = ( ( CTL_WFF ) --> C44 );
L747: ( dom D18 ) = ( CTL_WFF ) by FUNCOP_1:13;
L748: ( rng D18 ) c= { C44 } by FUNCOP_1:13;
L749: { C44 } c= (the carrier of R19) by L746 , ZFMISC_1:31;
reconsider D19 = D18 as (Function of ( CTL_WFF ) , (the carrier of R19)) by L749 , L747 , L748 , FUNCT_2:2 , XBOOLE_1:1;
take D19;
thus L750: thesis by L541;
end;
L751: (for B28 being (Element of ( NAT )) holds S5[ B28 ]) from NAT_1:sch 1(L745 , L600);
thus L752: thesis by L751;
end;
L753: (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R21 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds ((for R2 being (Element of ( NAT )) holds R21 is-PreEvaluation-for R2 , R20) implies R21 is-Evaluation-for R20))))
proof
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
let R21 being (Function of ( CTL_WFF ) , (the carrier of R19));
assume L754: (for R2 being (Element of ( NAT )) holds R21 is-PreEvaluation-for R2 , R20);
let C45 being CTL-formula;
set D20 = ( len C45 );
L755: R21 is-PreEvaluation-for D20 , R20 by L754;
thus L756: thesis by L755 , L525;
end;
definition
let C46 being CTLModel;
let C47 being (Function of ( atomic_WFF ) , (the BasicAssign of C46));
let C48 being (Element of ( NAT ));
func EvalSet (C46 , C47 , C48) -> non  empty set equals
{ B29 where B29 is (Function of ( CTL_WFF ) , (the carrier of C46)) : B29 is-PreEvaluation-for C48 , C47 };
correctness
proof
set D21 = { B30 where B30 is (Function of ( CTL_WFF ) , (the carrier of C46)) : B30 is-PreEvaluation-for C48 , C47 };
consider C49 being (Function of ( CTL_WFF ) , (the carrier of C46)) such that L757: C49 is-PreEvaluation-for C48 , C47 by L599;
L758: C49 in D21 by L757;
thus L759: thesis by L758;
end;
end;
definition
let C50 being CTLModel;
let C51 being (Element of (the carrier of C50));
let C52 being set;
func CastEval (C50 , C52 , C51) -> (Function of ( CTL_WFF ) , (the carrier of C50)) equals
:L761: C52 if C52 in ( Funcs (( CTL_WFF ) , (the carrier of C50)) ) otherwise ( ( CTL_WFF ) --> C51 );
correctness by FUNCT_2:66;
end;
definition
let C53 being CTLModel;
let C54 being (Function of ( atomic_WFF ) , (the BasicAssign of C53));
func EvalFamily (C53 , C54) -> non  empty set means
:L763: (for B31 being set holds (B31 in it iff (B31 in ( bool ( Funcs (( CTL_WFF ) , (the carrier of C53)) ) ) & (ex B32 being (Element of ( NAT )) st B31 = ( EvalSet (C53 , C54 , B32) )))));
existence
proof
defpred S6[ set ] means (ex B33 being (Element of ( NAT )) st $1 = ( EvalSet (C53 , C54 , B33) ));
set D22 = ( bool ( Funcs (( CTL_WFF ) , (the carrier of C53)) ) );
consider C55 being set such that L764: (for B34 being set holds (B34 in C55 iff (B34 in D22 & S6[ B34 ]))) from XBOOLE_0:sch 1;
L765: C55 is non  empty
proof
set D23 = ( EvalSet (C53 , C54 , ( 0 )) );
L766: D23 c= ( Funcs (( CTL_WFF ) , (the carrier of C53)) )
proof
let C56 being set;
assume L767: C56 in D23;
L768: (ex B35 being (Function of ( CTL_WFF ) , (the carrier of C53)) st (C56 = B35 & B35 is-PreEvaluation-for ( 0 ) , C54)) by L767;
thus L769: thesis by L768 , FUNCT_2:8;
end;
thus L770: thesis by L766 , L764;
end;
reconsider D24 = C55 as non  empty set by L765;
take D24;
thus L771: thesis by L764;
end;
uniqueness
proof
defpred S7[ set ] means ($1 in ( bool ( Funcs (( CTL_WFF ) , (the carrier of C53)) ) ) & (ex B36 being (Element of ( NAT )) st $1 = ( EvalSet (C53 , C54 , B36) )));
L772: (for B37 , B38 being set holds (((for B39 being set holds (B39 in B37 iff S7[ B39 ])) & (for B40 being set holds (B40 in B38 iff S7[ B40 ]))) implies B37 = B38)) from XBOOLE_0:sch 3;
thus L773: thesis by L772;
end;
end;
L775: (for R2 being (Element of ( NAT )) holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( EvalSet (R19 , R20 , R2) ) in ( EvalFamily (R19 , R20) ))))
proof
let R2 being (Element of ( NAT ));
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
set D25 = ( EvalSet (R19 , R20 , R2) );
L776: D25 c= ( Funcs (( CTL_WFF ) , (the carrier of R19)) )
proof
let C57 being set;
assume L777: C57 in D25;
L778: (ex B41 being (Function of ( CTL_WFF ) , (the carrier of R19)) st (C57 = B41 & B41 is-PreEvaluation-for R2 , R20)) by L777;
thus L779: thesis by L778 , FUNCT_2:8;
end;
thus L780: thesis by L776 , L763;
end;
theorem
L781: (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (ex R21 being (Function of ( CTL_WFF ) , (the carrier of R19)) st R21 is-Evaluation-for R20)))
proof
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
set D26 = ( EvalFamily (R19 , R20) );
set D27 = the (Element of (the carrier of R19));
L782: (for B42 being set holds (B42 in D26 implies B42 <> ( {} )))
proof
let C58 being set;
assume L783: C58 in D26;
L784: (ex B43 being (Element of ( NAT )) st C58 = ( EvalSet (R19 , R20 , B43) )) by L783 , L763;
thus L785: thesis by L784;
end;
consider C59 being Function such that L786: ( dom C59 ) = D26 and L787: (for B44 being set holds (B44 in D26 implies ( C59 . B44 ) in B44)) by L782 , FUNCT_1:111;
deffunc H2(set) = ( C59 . ( EvalSet (R19 , R20 , ( k_nat $1 )) ) );
L788: (for B45 being set holds (B45 in ( NAT ) implies H2(B45) is (Function of ( CTL_WFF ) , (the carrier of R19))))
proof
let C60 being set;
assume that
L789: C60 in ( NAT );
L790: ( k_nat C60 ) = C60 by L789 , L9;
set D28 = H2(C60);
reconsider D29 = C60 as (Element of ( NAT )) by L789;
L791: D28 in ( EvalSet (R19 , R20 , D29) ) by L787 , L790 , L775;
L792: (ex B46 being (Function of ( CTL_WFF ) , (the carrier of R19)) st (D28 = B46 & B46 is-PreEvaluation-for D29 , R20)) by L791;
thus L793: thesis by L792;
end;
L794: (for B47 being set holds (B47 in ( NAT ) implies H2(B47) in ( Funcs (( CTL_WFF ) , (the carrier of R19)) )))
proof
let C61 being set;
assume L795: C61 in ( NAT );
L796: H2(C61) is (Function of ( CTL_WFF ) , (the carrier of R19)) by L795 , L788;
thus L797: thesis by L796 , FUNCT_2:8;
end;
consider C62 being (Function of ( NAT ) , ( Funcs (( CTL_WFF ) , (the carrier of R19)) )) such that L798: (for B48 being set holds (B48 in ( NAT ) implies ( C62 . B48 ) = H2(B48))) from FUNCT_2:sch 2(L794);
deffunc H3(set) = ( ( CastEval (R19 , ( C62 . ( len ( CastCTLformula $1 ) ) ) , D27) ) . $1 );
L799: (for B49 being set holds (B49 in ( CTL_WFF ) implies H3(B49) in (the carrier of R19))) by FUNCT_2:5;
consider C63 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L800: (for B50 being set holds (B50 in ( CTL_WFF ) implies ( C63 . B50 ) = H3(B50))) from FUNCT_2:sch 2(L799);
take C63;
L801: (for B51 being (Element of ( NAT )) holds C63 is-PreEvaluation-for B51 , R20)
proof
defpred S8[ (Element of ( NAT )) ] means C63 is-PreEvaluation-for $1 , R20;
L802: (for B52 being (Element of ( NAT )) holds (S8[ B52 ] implies S8[ ( B52 + 1 ) ]))
proof
let C64 being (Element of ( NAT ));
assume that
L803: S8[ C64 ];
L804: (for B53 being CTL-formula holds (( len B53 ) <= ( C64 + 1 ) implies ((B53 is  atomic implies ( C63 . B53 ) = ( R20 . B53 )) & (B53 is  negative implies ( C63 . B53 ) = ( (the Compl of R19) . ( C63 . ( the_argument_of B53 ) ) )) & (B53 is  conjunctive implies ( C63 . B53 ) = ( (the L_meet of R19) . (( C63 . ( the_left_argument_of B53 ) ) , ( C63 . ( the_right_argument_of B53 ) )) )) & (B53 is  ExistNext implies ( C63 . B53 ) = ( (the EneXt of R19) . ( C63 . ( the_argument_of B53 ) ) )) & (B53 is  ExistGlobal implies ( C63 . B53 ) = ( (the EGlobal of R19) . ( C63 . ( the_argument_of B53 ) ) )) & (B53 is  ExistUntill implies ( C63 . B53 ) = ( (the EUntill of R19) . (( C63 . ( the_left_argument_of B53 ) ) , ( C63 . ( the_right_argument_of B53 ) )) )))))
proof
let C65 being CTL-formula;
assume that
L805: ( len C65 ) <= ( C64 + 1 );
L806:
now
per cases  by L805 , NAT_1:8;
case L807: ( len C65 ) <= C64;
thus L808: thesis by L807 , L803 , L525;
end;
case L809: ( len C65 ) = ( C64 + 1 );
set D30 = H2(( len C65 ));
L810: C65 in ( CTL_WFF ) by L111;
L811: ( C62 . ( len ( CastCTLformula C65 ) ) ) = ( C62 . ( len C65 ) ) by L810 , L512
.= H2(( len C65 )) by L798;
L812: ( CastEval (R19 , ( C62 . ( len ( CastCTLformula C65 ) ) ) , D27) ) = H2(( len C65 )) by L811 , L761;
reconsider D31 = D30 as (Function of ( CTL_WFF ) , (the carrier of R19)) by L812;
L813: D31 = ( C59 . ( EvalSet (R19 , R20 , ( len C65 )) ) ) by L9;
L814: ( C59 . ( EvalSet (R19 , R20 , ( len C65 )) ) ) in ( EvalSet (R19 , R20 , ( len C65 )) ) by L787 , L775;
L815: (ex B54 being (Function of ( CTL_WFF ) , (the carrier of R19)) st (D31 = B54 & B54 is-PreEvaluation-for ( len C65 ) , R20)) by L814 , L813;
L816: D31 is-PreEvaluation-for C64 , R20 by L815 , L809 , L544;
L817: ( C63 . C65 ) = ( D31 . C65 ) by L800 , L810 , L812;
L818: (C65 is  ExistNext implies ( C63 . C65 ) = ( (the EneXt of R19) . ( C63 . ( the_argument_of C65 ) ) ))
proof
assume L819: C65 is  ExistNext;
L820: ( len ( the_argument_of C65 ) ) < ( len C65 ) by L819 , L480;
L821: ( len ( the_argument_of C65 ) ) <= C64 by L820 , L809 , NAT_1:13;
L822: ( C63 . C65 ) = ( (the EneXt of R19) . ( D31 . ( the_argument_of C65 ) ) ) by L817 , L815 , L819 , L525
.= ( (the EneXt of R19) . ( C63 . ( the_argument_of C65 ) ) ) by L803 , L816 , L821 , L555;
thus L823: thesis by L822;
end;
L824: (C65 is  ExistUntill implies ( C63 . C65 ) = ( (the EUntill of R19) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ))
proof
assume L825: C65 is  ExistUntill;
L826: ( len ( the_right_argument_of C65 ) ) < ( len C65 ) by L825 , L495;
L827: ( len ( the_right_argument_of C65 ) ) <= C64 by L826 , L809 , NAT_1:13;
L828: ( len ( the_left_argument_of C65 ) ) < ( len C65 ) by L825 , L495;
L829: ( len ( the_left_argument_of C65 ) ) <= C64 by L828 , L809 , NAT_1:13;
L830: ( C63 . ( the_left_argument_of C65 ) ) = ( D31 . ( the_left_argument_of C65 ) ) by L829 , L803 , L816 , L555;
L831: ( C63 . C65 ) = ( (the EUntill of R19) . (( D31 . ( the_left_argument_of C65 ) ) , ( D31 . ( the_right_argument_of C65 ) )) ) by L817 , L815 , L825 , L525
.= ( (the EUntill of R19) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ) by L803 , L816 , L830 , L827 , L555;
thus L832: thesis by L831;
end;
L833: (C65 is  conjunctive implies ( C63 . C65 ) = ( (the L_meet of R19) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ))
proof
assume L834: C65 is  conjunctive;
L835: ( len ( the_right_argument_of C65 ) ) < ( len C65 ) by L834 , L495;
L836: ( len ( the_right_argument_of C65 ) ) <= C64 by L835 , L809 , NAT_1:13;
L837: ( len ( the_left_argument_of C65 ) ) < ( len C65 ) by L834 , L495;
L838: ( len ( the_left_argument_of C65 ) ) <= C64 by L837 , L809 , NAT_1:13;
L839: ( C63 . ( the_left_argument_of C65 ) ) = ( D31 . ( the_left_argument_of C65 ) ) by L838 , L803 , L816 , L555;
L840: ( C63 . C65 ) = ( (the L_meet of R19) . (( D31 . ( the_left_argument_of C65 ) ) , ( D31 . ( the_right_argument_of C65 ) )) ) by L817 , L815 , L834 , L525
.= ( (the L_meet of R19) . (( C63 . ( the_left_argument_of C65 ) ) , ( C63 . ( the_right_argument_of C65 ) )) ) by L803 , L816 , L839 , L836 , L555;
thus L841: thesis by L840;
end;
L842: (C65 is  ExistGlobal implies ( C63 . C65 ) = ( (the EGlobal of R19) . ( C63 . ( the_argument_of C65 ) ) ))
proof
assume L843: C65 is  ExistGlobal;
L844: ( len ( the_argument_of C65 ) ) < ( len C65 ) by L843 , L480;
L845: ( len ( the_argument_of C65 ) ) <= C64 by L844 , L809 , NAT_1:13;
L846: ( C63 . C65 ) = ( (the EGlobal of R19) . ( D31 . ( the_argument_of C65 ) ) ) by L817 , L815 , L843 , L525
.= ( (the EGlobal of R19) . ( C63 . ( the_argument_of C65 ) ) ) by L803 , L816 , L845 , L555;
thus L847: thesis by L846;
end;
L848: (C65 is  negative implies ( C63 . C65 ) = ( (the Compl of R19) . ( C63 . ( the_argument_of C65 ) ) ))
proof
assume L849: C65 is  negative;
L850: ( len ( the_argument_of C65 ) ) < ( len C65 ) by L849 , L480;
L851: ( len ( the_argument_of C65 ) ) <= C64 by L850 , L809 , NAT_1:13;
L852: ( C63 . C65 ) = ( (the Compl of R19) . ( D31 . ( the_argument_of C65 ) ) ) by L817 , L815 , L849 , L525
.= ( (the Compl of R19) . ( C63 . ( the_argument_of C65 ) ) ) by L803 , L816 , L851 , L555;
thus L853: thesis by L852;
end;
thus L854: thesis by L848 , L817 , L815 , L818 , L842 , L833 , L824 , L525;
end;
end;
thus L856: thesis by L806;
end;
thus L857: thesis by L804 , L525;
end;
L858: (for B55 being CTL-formula holds (( len B55 ) <= ( 0 ) implies ((B55 is  atomic implies ( C63 . B55 ) = ( R20 . B55 )) & (B55 is  negative implies ( C63 . B55 ) = ( (the Compl of R19) . ( C63 . ( the_argument_of B55 ) ) )) & (B55 is  conjunctive implies ( C63 . B55 ) = ( (the L_meet of R19) . (( C63 . ( the_left_argument_of B55 ) ) , ( C63 . ( the_right_argument_of B55 ) )) )) & (B55 is  ExistNext implies ( C63 . B55 ) = ( (the EneXt of R19) . ( C63 . ( the_argument_of B55 ) ) )) & (B55 is  ExistGlobal implies ( C63 . B55 ) = ( (the EGlobal of R19) . ( C63 . ( the_argument_of B55 ) ) )) & (B55 is  ExistUntill implies ( C63 . B55 ) = ( (the EUntill of R19) . (( C63 . ( the_left_argument_of B55 ) ) , ( C63 . ( the_right_argument_of B55 ) )) ))))) by L240;
L859: S8[ ( 0 ) ] by L858 , L525;
L860: (for B56 being (Element of ( NAT )) holds S8[ B56 ]) from NAT_1:sch 1(L859 , L802);
thus L861: thesis by L860;
end;
thus L862: thesis by L801 , L753;
end;
theorem
L863: (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds (for R22 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds (for R23 being (Function of ( CTL_WFF ) , (the carrier of R19)) holds ((R22 is-Evaluation-for R20 & R23 is-Evaluation-for R20) implies R22 = R23)))))
proof
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
let R22 being (Function of ( CTL_WFF ) , (the carrier of R19));
let R23 being (Function of ( CTL_WFF ) , (the carrier of R19));
assume that
L864: R22 is-Evaluation-for R20
and
L865: R23 is-Evaluation-for R20;
L866: (for B57 being set holds (B57 in ( CTL_WFF ) implies ( R22 . B57 ) = ( R23 . B57 )))
proof
let C66 being set;
assume L867: C66 in ( CTL_WFF );
reconsider D32 = C66 as CTL-formula by L867 , L111;
set D33 = ( len D32 );
L868: R23 is-PreEvaluation-for D33 , R20 by L865 , L551;
L869: R22 is-PreEvaluation-for D33 , R20 by L864 , L551;
thus L870: thesis by L869 , L868 , L555;
end;
thus L871: thesis by L866 , FUNCT_2:12;
end;
definition
let C67 being CTLModel;
let C68 being (Function of ( atomic_WFF ) , (the BasicAssign of C67));
let C69 being CTL-formula;
func Evaluate (C69 , C68) -> (Assign of C67) means
:L872: (ex B58 being (Function of ( CTL_WFF ) , (the carrier of C67)) st (B58 is-Evaluation-for C68 & it = ( B58 . C69 )));
existence
proof
consider C70 being (Function of ( CTL_WFF ) , (the carrier of C67)) such that L873: C70 is-Evaluation-for C68 by L781;
set D34 = ( C70 . C69 );
L874: C69 in ( CTL_WFF ) by L111;
reconsider D35 = D34 as (Assign of C67) by L874 , FUNCT_2:5;
take D35;
thus L875: thesis by L873;
end;
uniqueness by L863;
end;
notation
let C71 being CTLModel;
let C72 being (Assign of C71);
synonym 'not' C72 for C72 `;
let C73 being (Assign of C71);
synonym C72 '&' C73 for C72 "/\" C73;
end;
definition
let C74 being CTLModel;
let C75 being (Assign of C74);
func EX C75 -> (Assign of C74) equals
( (the EneXt of C74) . C75 );
correctness;
func EG C75 -> (Assign of C74) equals
( (the EGlobal of C74) . C75 );
correctness;
end;
definition
let C76 being CTLModel;
let C77 , C78 being (Assign of C76);
func C77 EU C78 -> (Assign of C76) equals
( (the EUntill of C76) . (C77 , C78) );
correctness;
func C77 'or' C78 -> (Assign of C76) equals
( 'not' ( ( 'not' C77 ) '&' ( 'not' C78 ) ) );
correctness;
end;
theorem
L880: (for R14 being CTL-formula holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( Evaluate (( 'not' R14 ) , R20) ) = ( 'not' ( Evaluate (R14 , R20) ) ))))
proof
let R14 being CTL-formula;
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
consider C79 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L881: C79 is-Evaluation-for R20 and L882: ( Evaluate (( 'not' R14 ) , R20) ) = ( C79 . ( 'not' R14 ) ) by L872;
L883: (ex B59 being (Function of ( CTL_WFF ) , (the carrier of R19)) st (B59 is-Evaluation-for R20 & ( Evaluate (R14 , R20) ) = ( B59 . R14 ))) by L872;
L884: ( 'not' R14 ) is  negative by L140;
L885: ( Evaluate (( 'not' R14 ) , R20) ) = ( (the Compl of R19) . ( C79 . ( the_argument_of ( 'not' R14 ) ) ) ) by L884 , L881 , L882 , L523
.= ( (the Compl of R19) . ( C79 . R14 ) ) by L884 , L454
.= ( 'not' ( Evaluate (R14 , R20) ) ) by L881 , L883 , L863;
thus L886: thesis by L885;
end;
theorem
L887: (for R15 being CTL-formula holds (for R16 being CTL-formula holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( Evaluate (( R15 '&' R16 ) , R20) ) = ( ( Evaluate (R15 , R20) ) '&' ( Evaluate (R16 , R20) ) )))))
proof
let R15 being CTL-formula;
let R16 being CTL-formula;
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
consider C80 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L888: C80 is-Evaluation-for R20 and L889: ( Evaluate (( R15 '&' R16 ) , R20) ) = ( C80 . ( R15 '&' R16 ) ) by L872;
consider C81 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L890: C81 is-Evaluation-for R20 and L891: ( Evaluate (R15 , R20) ) = ( C81 . R15 ) by L872;
consider C82 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L892: C82 is-Evaluation-for R20 and L893: ( Evaluate (R16 , R20) ) = ( C82 . R16 ) by L872;
L894: C80 = C82 by L888 , L892 , L863;
L895: ( R15 '&' R16 ) is  conjunctive by L141;
L896: ( the_left_argument_of ( R15 '&' R16 ) ) = R15 by L895 , L457;
L897: ( the_right_argument_of ( R15 '&' R16 ) ) = R16 by L895 , L458;
L898: C80 = C81 by L888 , L890 , L863;
thus L899: thesis by L898 , L888 , L889 , L891 , L893 , L894 , L895 , L896 , L897 , L523;
end;
theorem
L900: (for R14 being CTL-formula holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( Evaluate (( EX R14 ) , R20) ) = ( EX ( Evaluate (R14 , R20) ) ))))
proof
let R14 being CTL-formula;
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
consider C83 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L901: C83 is-Evaluation-for R20 and L902: ( Evaluate (( EX R14 ) , R20) ) = ( C83 . ( EX R14 ) ) by L872;
L903: (ex B60 being (Function of ( CTL_WFF ) , (the carrier of R19)) st (B60 is-Evaluation-for R20 & ( Evaluate (R14 , R20) ) = ( B60 . R14 ))) by L872;
L904: ( EX R14 ) is  ExistNext by L142;
L905: ( Evaluate (( EX R14 ) , R20) ) = ( (the EneXt of R19) . ( C83 . ( the_argument_of ( EX R14 ) ) ) ) by L904 , L901 , L902 , L523
.= ( (the EneXt of R19) . ( C83 . R14 ) ) by L904 , L454
.= ( EX ( Evaluate (R14 , R20) ) ) by L901 , L903 , L863;
thus L906: thesis by L905;
end;
theorem
L907: (for R14 being CTL-formula holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( Evaluate (( EG R14 ) , R20) ) = ( EG ( Evaluate (R14 , R20) ) ))))
proof
let R14 being CTL-formula;
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
consider C84 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L908: C84 is-Evaluation-for R20 and L909: ( Evaluate (( EG R14 ) , R20) ) = ( C84 . ( EG R14 ) ) by L872;
L910: (ex B61 being (Function of ( CTL_WFF ) , (the carrier of R19)) st (B61 is-Evaluation-for R20 & ( Evaluate (R14 , R20) ) = ( B61 . R14 ))) by L872;
L911: ( EG R14 ) is  ExistGlobal by L143;
L912: (not ( EG R14 ) is  negative) by L911 , L449;
L913: (not ( EG R14 ) is  ExistNext) by L911 , L449;
L914: ( Evaluate (( EG R14 ) , R20) ) = ( (the EGlobal of R19) . ( C84 . ( the_argument_of ( EG R14 ) ) ) ) by L908 , L909 , L911 , L523
.= ( (the EGlobal of R19) . ( C84 . R14 ) ) by L911 , L912 , L913 , L454
.= ( EG ( Evaluate (R14 , R20) ) ) by L908 , L910 , L863;
thus L915: thesis by L914;
end;
theorem
L916: (for R15 being CTL-formula holds (for R16 being CTL-formula holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( Evaluate (( R15 EU R16 ) , R20) ) = ( ( Evaluate (R15 , R20) ) EU ( Evaluate (R16 , R20) ) )))))
proof
let R15 being CTL-formula;
let R16 being CTL-formula;
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
consider C85 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L917: C85 is-Evaluation-for R20 and L918: ( Evaluate (( R15 EU R16 ) , R20) ) = ( C85 . ( R15 EU R16 ) ) by L872;
consider C86 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L919: C86 is-Evaluation-for R20 and L920: ( Evaluate (R15 , R20) ) = ( C86 . R15 ) by L872;
consider C87 being (Function of ( CTL_WFF ) , (the carrier of R19)) such that L921: C87 is-Evaluation-for R20 and L922: ( Evaluate (R16 , R20) ) = ( C87 . R16 ) by L872;
L923: C85 = C87 by L917 , L921 , L863;
L924: ( R15 EU R16 ) is  ExistUntill by L144;
L925: ( ( R15 EU R16 ) . 1 ) = 4 by L924 , L213;
L926: (not ( R15 EU R16 ) is  conjunctive) by L925 , L200;
L927: ( the_left_argument_of ( R15 EU R16 ) ) = R15 by L926 , L924 , L457;
L928: ( the_right_argument_of ( R15 EU R16 ) ) = R16 by L924 , L926 , L458;
L929: C85 = C86 by L917 , L919 , L863;
thus L930: thesis by L929 , L917 , L918 , L920 , L922 , L923 , L924 , L927 , L928 , L523;
end;
theorem
L931: (for R15 being CTL-formula holds (for R16 being CTL-formula holds (for R19 being CTLModel holds (for R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19)) holds ( Evaluate (( R15 'or' R16 ) , R20) ) = ( ( Evaluate (R15 , R20) ) 'or' ( Evaluate (R16 , R20) ) )))))
proof
let R15 being CTL-formula;
let R16 being CTL-formula;
let R19 being CTLModel;
let R20 being (Function of ( atomic_WFF ) , (the BasicAssign of R19));
L932: ( Evaluate (( R15 'or' R16 ) , R20) ) = ( 'not' ( Evaluate (( ( 'not' R15 ) '&' ( 'not' R16 ) ) , R20) ) ) by L880
.= ( 'not' ( ( Evaluate (( 'not' R15 ) , R20) ) '&' ( Evaluate (( 'not' R16 ) , R20) ) ) ) by L887
.= ( 'not' ( ( 'not' ( Evaluate (R15 , R20) ) ) '&' ( Evaluate (( 'not' R16 ) , R20) ) ) ) by L880;
thus L933: thesis by L932 , L880;
end;
notation
let C88 being Function;
let C89 being Nat;
synonym C88 |** C89 for iter (C88 , C89);
end;
definition
let C90 being set;
let C91 being (Function of C90 , C90);
let C92 being Nat;
redefine func C91 |** C92 -> (Function of C90 , C90);

coherence
proof
reconsider D36 = C92 as (Element of ( NAT )) by ORDINAL1:def 12;
L935: ( iter (C91 , D36) ) is (Function of C90 , C90);
thus L936: thesis by L935;
end;
end;
L938: (for B62 being set holds (for B63 being (Relation of B62 , B62) holds (B63 is  total implies (for B64 being set holds (B64 in B62 implies (ex B65 being set st (B65 in B62 & [ B64 , B65 ] in B63)))))))
proof
let C93 being set;
let C94 being (Relation of C93 , C93);
L939: (C94 is  total implies (for B66 being set holds (B66 in C93 implies (ex B67 being set st (B67 in C93 & [ B66 , B67 ] in C94)))))
proof
assume L940: C94 is  total;
L941: (for B68 being set holds (B68 in C93 implies (ex B69 being set st (B69 in C93 & [ B68 , B69 ] in C94))))
proof
let C95 being set;
assume that
L942: C95 in C93;
L943: ( dom C94 ) = C93 by L940 , PARTFUN1:def 2;
consider C96 being (Element of C93) such that L944: [ C95 , C96 ] in C94 by L943 , L942 , RELSET_1:24;
take C96;
thus L945: thesis by L942 , L944;
end;
thus L946: thesis by L941;
end;
thus L947: thesis by L939;
end;
L948: (for B70 being set holds (for B71 being (Relation of B70 , B70) holds ((for B72 being set holds (B72 in B70 implies (ex B73 being set st (B73 in B70 & [ B72 , B73 ] in B71)))) implies B71 is  total)))
proof
let C97 being set;
let C98 being (Relation of C97 , C97);
L949: ((for B74 being set holds (B74 in C97 implies (ex B75 being set st (B75 in C97 & [ B74 , B75 ] in C98)))) implies C98 is  total)
proof
assume L950: (for B76 being set holds (B76 in C97 implies (ex B77 being set st (B77 in C97 & [ B76 , B77 ] in C98))));
L951: C97 c= ( dom C98 )
proof
let C99 being set;
assume L952: C99 in C97;
L953: (ex B78 being set st (B78 in C97 & [ C99 , B78 ] in C98)) by L952 , L950;
thus L954: thesis by L953 , XTUPLE_0:def 12;
end;
L955: ( dom C98 ) c= C97 by RELAT_1:def 18;
L956: ( dom C98 ) = C97 by L955 , L951 , XBOOLE_0:def 10;
thus L957: thesis by L956 , PARTFUN1:def 2;
end;
thus L958: thesis by L949;
end;
L959: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds ( R25 .: { R26 } ) is non  empty)))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
L960: R26 in { R26 } by TARSKI:def 1;
L961: (ex B79 being set st (B79 in R24 & [ R26 , B79 ] in R25)) by L938;
thus L962: thesis by L961 , L960 , RELAT_1:def 13;
end;
scheme ExistPath { F1() -> non  empty set , F2() ->  total (Relation of F1() , F1()) , F3() -> (Element of F1()) , F4((Element of F1())) -> set } : (ex B80 being (Function of ( NAT ) , F1()) st (( B80 . ( 0 ) ) = F3() & (for B81 being (Element of ( NAT )) holds ([ ( B80 . B81 ) , ( B80 . ( B81 + 1 ) ) ] in F2() & ( B80 . ( B81 + 1 ) ) in F4(( B80 . B81 ))))))
provided
L963: (for B82 being (Element of F1()) holds ( ( Im (F2() , B82) ) /\ F4(B82) ) is non  empty non  empty non  empty non  empty (Subset of F1()))
proof
L964: (for B83 being set holds (B83 in ( BOOL F1() ) implies B83 <> ( {} ))) by ORDERS_1:1;
consider C100 being Function such that L965: ( dom C100 ) = ( BOOL F1() ) and L966: (for B84 being set holds (B84 in ( BOOL F1() ) implies ( C100 . B84 ) in B84)) by L964 , FUNCT_1:111;
L967: F3() in F1();
L968: (ex B85 being (Function of ( NAT ) , F1()) st (( B85 . ( 0 ) ) = F3() & (for B86 being (Element of ( NAT )) holds ( B85 . ( B86 + 1 ) ) = ( C100 . ( ( F2() .: { ( B85 . B86 ) } ) /\ F4(( B85 . B86 )) ) ))))
proof
deffunc H4(set) = ( C100 . ( ( F2() .: { ( k_id ($1 , F1() , F3()) ) } ) /\ F4(( k_id ($1 , F1() , F3()) )) ) );
L969: (for B87 being set holds (B87 in F1() implies H4(B87) in F1()))
proof
let C101 being set;
assume that
L970: C101 in F1();
L971: ( k_id (C101 , F1() , F3()) ) = C101 by L970 , L7;
reconsider D37 = C101 as (Element of F1()) by L970;
set D38 = ( ( Im (F2() , D37) ) /\ F4(D37) );
L972: D38 is non  empty non  empty non  empty non  empty (Subset of F1()) by L963;
L973: D38 in ( BOOL F1() ) by L972 , ORDERS_1:2;
L974: ( C100 . D38 ) in D38 by L973 , L966;
L975: H4(D37) in ( F2() .: { D37 } ) by L974 , L971 , XBOOLE_0:def 4;
L976: ( rng F2() ) c= F1() by RELAT_1:def 19;
L977: ( F2() .: { D37 } ) c= ( rng F2() ) by RELAT_1:111;
L978: ( F2() .: { D37 } ) c= F1() by L977 , L976 , XBOOLE_1:1;
thus L979: thesis by L978 , L975;
end;
consider C102 being (Function of F1() , F1()) such that L980: (for B88 being set holds (B88 in F1() implies ( C102 . B88 ) = H4(B88))) from FUNCT_2:sch 2(L969);
deffunc H5(set) = ( ( C102 |** ( k_nat $1 ) ) . F3() );
L981: (for B89 being set holds (B89 in ( NAT ) implies H5(B89) in F1()));
consider C103 being (Function of ( NAT ) , F1()) such that L982: (for B90 being set holds (B90 in ( NAT ) implies ( C103 . B90 ) = H5(B90))) from FUNCT_2:sch 2(L981);
L983: (for B91 being (Element of ( NAT )) holds ( C103 . ( B91 + 1 ) ) = ( C100 . ( ( F2() .: { ( C103 . B91 ) } ) /\ F4(( C103 . B91 )) ) ))
proof
let C104 being (Element of ( NAT ));
L984: F3() in ( dom ( C102 |** C104 ) ) by L967 , FUNCT_2:def 1;
L985: ( k_id (( C103 . C104 ) , F1() , F3()) ) = ( C103 . C104 ) by L7;
L986: ( C103 . ( C104 + 1 ) ) = H5(( C104 + 1 )) by L982
.= ( ( C102 |** ( C104 + 1 ) ) . F3() ) by L9
.= ( ( C102 * ( C102 |** C104 ) ) . F3() ) by FUNCT_7:71
.= ( C102 . ( ( C102 |** C104 ) . F3() ) ) by L984 , FUNCT_1:13
.= ( C102 . ( ( C102 |** ( k_nat C104 ) ) . F3() ) ) by L9
.= ( C102 . ( C103 . C104 ) ) by L982
.= ( C100 . ( ( F2() .: { ( C103 . C104 ) } ) /\ F4(( C103 . C104 )) ) ) by L980 , L985;
thus L987: thesis by L986;
end;
take C103;
L988: ( C103 . ( 0 ) ) = H5(( 0 )) by L982
.= ( ( C102 |** ( 0 ) ) . F3() ) by L9
.= ( ( id F1() ) . F3() ) by FUNCT_7:84
.= F3() by FUNCT_1:18;
thus L989: thesis by L988 , L983;
end;
consider C105 being (Function of ( NAT ) , F1()) such that L990: ( C105 . ( 0 ) ) = F3() and L991: (for B92 being (Element of ( NAT )) holds ( C105 . ( B92 + 1 ) ) = ( C100 . ( ( F2() .: { ( C105 . B92 ) } ) /\ F4(( C105 . B92 )) ) )) by L968;
take C105;
L992: (for B93 being (Element of ( NAT )) holds ( C105 . ( B93 + 1 ) ) in ( ( F2() .: { ( C105 . B93 ) } ) /\ F4(( C105 . B93 )) ))
proof
let C106 being (Element of ( NAT ));
set D39 = ( C105 . C106 );
set D40 = ( ( Im (F2() , D39) ) /\ F4(D39) );
L993: D40 is non  empty non  empty non  empty non  empty (Subset of F1()) by L963;
L994: D40 in ( BOOL F1() ) by L993 , ORDERS_1:2;
L995: ( C100 . D40 ) in D40 by L994 , L966;
thus L996: thesis by L995 , L991;
end;
L997: (for B94 being (Element of ( NAT )) holds ([ ( C105 . B94 ) , ( C105 . ( B94 + 1 ) ) ] in F2() & ( C105 . ( B94 + 1 ) ) in F4(( C105 . B94 ))))
proof
let C107 being (Element of ( NAT ));
L998: ( C105 . ( C107 + 1 ) ) in ( ( Im (F2() , ( C105 . C107 )) ) /\ F4(( C105 . C107 )) ) by L992;
L999: ( C105 . ( C107 + 1 ) ) in ( Im (F2() , ( C105 . C107 )) ) by L998 , XBOOLE_0:def 4;
thus L1000: thesis by L999 , L998 , RELSET_2:9 , XBOOLE_0:def 4;
end;
thus L1001: thesis by L997 , L990;
end;
L1002: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R27 being (Element of R24) holds (ex B95 being (Function of ( NAT ) , R24) st (( B95 . ( 0 ) ) = R27 & (for R2 being (Element of ( NAT )) holds [ ( B95 . R2 ) , ( B95 . ( R2 + 1 ) ) ] in R25))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R27 being (Element of R24);
deffunc H6((Element of R24)) = R24;
L1003: (for R26 being (Element of R24) holds ( ( Im (R25 , R26) ) /\ H6(R26) ) is non  empty non  empty non  empty non  empty (Subset of R24))
proof
let R26 being (Element of R24);
set D41 = ( R25 .: { R26 } );
L1004: ( rng R25 ) c= R24 by RELAT_1:def 19;
L1005: D41 c= ( rng R25 ) by RELAT_1:111;
L1006: ( ( R25 .: { R26 } ) /\ H6(R26) ) = D41 by L1005 , L1004 , XBOOLE_1:1 , XBOOLE_1:28;
thus L1007: thesis by L1006 , L1005 , L1004 , L959 , XBOOLE_1:1;
end;
consider C108 being (Function of ( NAT ) , R24) such that L1008: (( C108 . ( 0 ) ) = R27 & (for R2 being (Element of ( NAT )) holds ([ ( C108 . R2 ) , ( C108 . ( R2 + 1 ) ) ] in R25 & ( C108 . ( R2 + 1 ) ) in H6(( C108 . R2 ))))) from ExistPath(L1003);
take C108;
thus L1009: thesis by L1008;
end;
definition
let C109 being non  empty set;
let C110 being  total (Relation of C109 , C109);
mode inf_path of C110
 -> (Function of ( NAT ) , C109)
means :L1010: (for B96 being (Element of ( NAT )) holds [ ( it . B96 ) , ( it . ( B96 + 1 ) ) ] in C110);
existence
proof
set D42 = the (Element of C109);
consider C111 being (Function of ( NAT ) , C109) such that L1011: ( C111 . ( 0 ) ) = D42 and L1012: (for B97 being (Element of ( NAT )) holds [ ( C111 . B97 ) , ( C111 . ( B97 + 1 ) ) ] in C110) by L1002;
take C111;
thus L1013: thesis by L1012;
end;
end;
definition
let C112 being non  empty set;
func ModelSP C112 -> set equals
( Funcs (C112 , ( BOOLEAN )) );
correctness;
end;
registration
let C113 being non  empty set;
cluster ( ModelSP C113 ) -> non  empty;
coherence;
end;
definition
let C114 being non  empty set;
let C115 being set;
func Fid (C115 , C114) -> (Function of C114 , ( BOOLEAN )) equals
:L1017: C115 if C115 in ( ModelSP C114 ) otherwise ( C114 --> ( FALSE ) );
correctness by FUNCT_2:66;
end;
L1019: (for R24 being non  empty set holds (for R26 being (Element of R24) holds (for B98 being set holds (( ( Fid (B98 , R24) ) . R26 ) <> ( TRUE ) implies ( ( Fid (B98 , R24) ) . R26 ) = ( FALSE ))))) by TARSKI:def 2;
scheme Func1EX { F5() -> non  empty set , F6() -> (Function of F5() , ( BOOLEAN )) , F7(set , (Function of F5() , ( BOOLEAN ))) ->  boolean set } : (ex B99 being set st (B99 in ( ModelSP F5() ) & (for B100 being set holds (B100 in F5() implies (F7(B100 , F6()) = ( TRUE ) iff ( ( Fid (B99 , F5()) ) . B100 ) = ( TRUE ))))))
proof
deffunc H7(set) = F7($1 , F6());
L1020: (for B101 being set holds (B101 in F5() implies H7(B101) in ( BOOLEAN ))) by MARGREL1:def 12;
consider C116 being (Function of F5() , ( BOOLEAN )) such that L1021: (for B102 being set holds (B102 in F5() implies ( C116 . B102 ) = H7(B102))) from FUNCT_2:sch 2(L1020);
take C116;
L1022: C116 in ( ModelSP F5() ) by FUNCT_2:8;
L1023: ( Fid (C116 , F5()) ) = C116 by L1022 , L1017;
thus L1024: thesis by L1023 , L1021 , FUNCT_2:8;
end;
scheme Func1Unique { F8() -> non  empty set , F9() -> (Function of F8() , ( BOOLEAN )) , F10(set , (Function of F8() , ( BOOLEAN ))) ->  boolean set } : (for B103 , B104 being set holds ((B103 in ( ModelSP F8() ) & (for B105 being set holds (B105 in F8() implies (F10(B105 , F9()) = ( TRUE ) iff ( ( Fid (B103 , F8()) ) . B105 ) = ( TRUE )))) & B104 in ( ModelSP F8() ) & (for B106 being set holds (B106 in F8() implies (F10(B106 , F9()) = ( TRUE ) iff ( ( Fid (B104 , F8()) ) . B106 ) = ( TRUE ))))) implies B103 = B104))
proof
let C117 , C118 being set;
assume that
L1025: C117 in ( ModelSP F8() )
and
L1026: (for B107 being set holds (B107 in F8() implies (F10(B107 , F9()) = ( TRUE ) iff ( ( Fid (C117 , F8()) ) . B107 ) = ( TRUE ))))
and
L1027: C118 in ( ModelSP F8() )
and
L1028: (for B108 being set holds (B108 in F8() implies (F10(B108 , F9()) = ( TRUE ) iff ( ( Fid (C118 , F8()) ) . B108 ) = ( TRUE ))));
L1029: (for B109 being set holds (B109 in F8() implies ( ( Fid (C117 , F8()) ) . B109 ) = ( ( Fid (C118 , F8()) ) . B109 )))
proof
let C119 being set;
assume that
L1030: C119 in F8();
set D43 = F10(C119 , F9());
set D44 = ( ( Fid (C117 , F8()) ) . C119 );
L1031: (D43 = ( TRUE ) iff D44 = ( TRUE )) by L1026 , L1030;
set D45 = ( ( Fid (C118 , F8()) ) . C119 );
L1032: (D43 = ( TRUE ) iff D45 = ( TRUE )) by L1028 , L1030;
per cases ;
suppose L1033: D43 = ( TRUE );

thus L1034: thesis by L1033 , L1028 , L1030 , L1031;
end;
suppose L1035: D43 <> ( TRUE );

L1036: D44 = ( FALSE ) by L1035 , L1030 , L1031 , L1019;
thus L1037: thesis by L1036 , L1030 , L1032 , L1035 , L1019;
end;
end;
L1039: C117 = ( Fid (C117 , F8()) ) by L1025 , L1017
.= ( Fid (C118 , F8()) ) by L1029 , FUNCT_2:12
.= C118 by L1027 , L1017;
thus L1040: thesis by L1039;
end;
scheme UnOpEX { F11() -> non  empty set , F12(set) -> (Element of F11()) } : (ex B110 being (UnOp of F11()) st (for B111 being set holds (B111 in F11() implies ( B110 . B111 ) = F12(B111))))
proof
deffunc H8(set) = F12($1);
L1041: (for B112 being set holds (B112 in F11() implies H8(B112) in F11()));
L1042: (ex B113 being (Function of F11() , F11()) st (for B114 being set holds (B114 in F11() implies ( B113 . B114 ) = H8(B114)))) from FUNCT_2:sch 2(L1041);
thus L1043: thesis by L1042;
end;
scheme UnOpUnique { F13() -> non  empty set , F14() -> non  empty set , F15(set) -> (Element of F14()) } : (for B115 , B116 being (UnOp of F14()) holds (((for B117 being set holds (B117 in F14() implies ( B115 . B117 ) = F15(B117))) & (for B118 being set holds (B118 in F14() implies ( B116 . B118 ) = F15(B118)))) implies B115 = B116))
proof
let C120 , C121 being (UnOp of F14());
assume that
L1044: (for B119 being set holds (B119 in F14() implies ( C120 . B119 ) = F15(B119)))
and
L1045: (for B120 being set holds (B120 in F14() implies ( C121 . B120 ) = F15(B120)));
L1046: (for B121 being (Element of F14()) holds ( C120 . B121 ) = ( C121 . B121 ))
proof
let C122 being (Element of F14());
L1047: ( C120 . C122 ) = F15(C122) by L1044
.= ( C121 . C122 ) by L1045;
thus L1048: thesis by L1047;
end;
thus L1049: thesis by L1046 , FUNCT_2:63;
end;
scheme Func2EX { F16() -> non  empty set , F17() -> (Function of F16() , ( BOOLEAN )) , F18() -> (Function of F16() , ( BOOLEAN )) , F19(set , (Function of F16() , ( BOOLEAN )) , (Function of F16() , ( BOOLEAN ))) ->  boolean set } : (ex B122 being set st (B122 in ( ModelSP F16() ) & (for B123 being set holds (B123 in F16() implies (F19(B123 , F17() , F18()) = ( TRUE ) iff ( ( Fid (B122 , F16()) ) . B123 ) = ( TRUE ))))))
proof
deffunc H9(set) = F19($1 , F17() , F18());
L1050: (for B124 being set holds (B124 in F16() implies H9(B124) in ( BOOLEAN ))) by MARGREL1:def 12;
consider C123 being (Function of F16() , ( BOOLEAN )) such that L1051: (for B125 being set holds (B125 in F16() implies ( C123 . B125 ) = H9(B125))) from FUNCT_2:sch 2(L1050);
take C123;
L1052: C123 in ( ModelSP F16() ) by FUNCT_2:8;
L1053: ( Fid (C123 , F16()) ) = C123 by L1052 , L1017;
thus L1054: thesis by L1053 , L1051 , FUNCT_2:8;
end;
scheme Func2Unique { F20() -> non  empty set , F21() -> (Function of F20() , ( BOOLEAN )) , F22() -> (Function of F20() , ( BOOLEAN )) , F23(set , (Function of F20() , ( BOOLEAN )) , (Function of F20() , ( BOOLEAN ))) ->  boolean set } : (for B126 , B127 being set holds ((B126 in ( ModelSP F20() ) & (for B128 being set holds (B128 in F20() implies (F23(B128 , F21() , F22()) = ( TRUE ) iff ( ( Fid (B126 , F20()) ) . B128 ) = ( TRUE )))) & B127 in ( ModelSP F20() ) & (for B129 being set holds (B129 in F20() implies (F23(B129 , F21() , F22()) = ( TRUE ) iff ( ( Fid (B127 , F20()) ) . B129 ) = ( TRUE ))))) implies B126 = B127))
proof
let C124 , C125 being set;
assume that
L1055: C124 in ( ModelSP F20() )
and
L1056: (for B130 being set holds (B130 in F20() implies (F23(B130 , F21() , F22()) = ( TRUE ) iff ( ( Fid (C124 , F20()) ) . B130 ) = ( TRUE ))))
and
L1057: C125 in ( ModelSP F20() )
and
L1058: (for B131 being set holds (B131 in F20() implies (F23(B131 , F21() , F22()) = ( TRUE ) iff ( ( Fid (C125 , F20()) ) . B131 ) = ( TRUE ))));
L1059: (for B132 being set holds (B132 in F20() implies ( ( Fid (C124 , F20()) ) . B132 ) = ( ( Fid (C125 , F20()) ) . B132 )))
proof
let C126 being set;
assume that
L1060: C126 in F20();
set D46 = F23(C126 , F21() , F22());
set D47 = ( ( Fid (C124 , F20()) ) . C126 );
L1061: (D46 = ( TRUE ) iff D47 = ( TRUE )) by L1056 , L1060;
set D48 = ( ( Fid (C125 , F20()) ) . C126 );
L1062: (D46 = ( TRUE ) iff D48 = ( TRUE )) by L1058 , L1060;
per cases ;
suppose L1063: D46 = ( TRUE );

thus L1064: thesis by L1063 , L1058 , L1060 , L1061;
end;
suppose L1065: D46 <> ( TRUE );

L1066: D47 = ( FALSE ) by L1065 , L1060 , L1061 , L1019;
thus L1067: thesis by L1066 , L1060 , L1062 , L1065 , L1019;
end;
end;
L1069: C124 = ( Fid (C124 , F20()) ) by L1055 , L1017
.= ( Fid (C125 , F20()) ) by L1059 , FUNCT_2:12
.= C125 by L1057 , L1017;
thus L1070: thesis by L1069;
end;
definition
let C127 being non  empty set;
let C128 being set;
func Not_0 (C128 , C127) -> (Element of ( ModelSP C127 )) means
:L1071: (for B133 being set holds (B133 in C127 implies (( 'not' ( Castboolean ( ( Fid (C128 , C127) ) . B133 ) ) ) = ( TRUE ) iff ( ( Fid (it , C127) ) . B133 ) = ( TRUE ))));
existence
proof
deffunc H10(set , (Function of C127 , ( BOOLEAN ))) = ( 'not' ( Castboolean ( $2 . $1 ) ) );
consider C129 being set such that L1072: C129 in ( ModelSP C127 ) and L1073: (for B134 being set holds (B134 in C127 implies (H10(B134 , ( Fid (C128 , C127) )) = ( TRUE ) iff ( ( Fid (C129 , C127) ) . B134 ) = ( TRUE )))) from Func1EX;
take C129;
thus L1074: thesis by L1072 , L1073;
end;
uniqueness
proof
deffunc H11(set , (Function of C127 , ( BOOLEAN ))) = ( 'not' ( Castboolean ( $2 . $1 ) ) );
L1075: (for B135 , B136 being set holds ((B135 in ( ModelSP C127 ) & (for B137 being set holds (B137 in C127 implies (H11(B137 , ( Fid (C128 , C127) )) = ( TRUE ) iff ( ( Fid (B135 , C127) ) . B137 ) = ( TRUE )))) & B136 in ( ModelSP C127 ) & (for B138 being set holds (B138 in C127 implies (H11(B138 , ( Fid (C128 , C127) )) = ( TRUE ) iff ( ( Fid (B136 , C127) ) . B138 ) = ( TRUE ))))) implies B135 = B136)) from Func1Unique;
thus L1076: thesis by L1075;
end;
end;
L1078: (for R24 being non  empty set holds (for B139 , B140 being (UnOp of ( ModelSP R24 )) holds (((for B141 being set holds (B141 in ( ModelSP R24 ) implies ( B139 . B141 ) = ( Not_0 (B141 , R24) ))) & (for B142 being set holds (B142 in ( ModelSP R24 ) implies ( B140 . B142 ) = ( Not_0 (B142 , R24) )))) implies B139 = B140)))
proof
let R24 being non  empty set;
set D49 = ( ModelSP R24 );
deffunc H12(set) = ( Not_0 ($1 , R24) );
L1079: (for B143 , B144 being (UnOp of D49) holds (((for B145 being set holds (B145 in D49 implies ( B143 . B145 ) = H12(B145))) & (for B146 being set holds (B146 in D49 implies ( B144 . B146 ) = H12(B146)))) implies B143 = B144)) from UnOpUnique;
thus L1080: thesis by L1079;
end;
definition
let C130 being non  empty set;
func Not_ C130 -> (UnOp of ( ModelSP C130 )) means
:L1081: (for B147 being set holds (B147 in ( ModelSP C130 ) implies ( it . B147 ) = ( Not_0 (B147 , C130) )));
existence
proof
set D50 = ( ModelSP C130 );
deffunc H13(set) = ( Not_0 ($1 , C130) );
L1082: (ex B148 being (UnOp of D50) st (for B149 being set holds (B149 in D50 implies ( B148 . B149 ) = H13(B149)))) from UnOpEX;
thus L1083: thesis by L1082;
end;
uniqueness by L1078;
end;
definition
let C131 being non  empty set;
let C132 being  total (Relation of C131 , C131);
let C133 being (Function of C131 , ( BOOLEAN ));
let C134 being set;
func EneXt_univ (C134 , C133 , C132) -> (Element of ( BOOLEAN )) equals
:L1085: ( TRUE ) if (C134 in C131 & (ex B150 being (inf_path of C132) st (( B150 . ( 0 ) ) = C134 & ( C133 . ( B150 . 1 ) ) = ( TRUE )))) otherwise ( FALSE );
correctness;
end;
definition
let C135 being non  empty set;
let C136 being  total (Relation of C135 , C135);
let C137 being set;
func EneXt_0 (C137 , C136) -> (Element of ( ModelSP C135 )) means
:L1087: (for B151 being set holds (B151 in C135 implies (( EneXt_univ (B151 , ( Fid (C137 , C135) ) , C136) ) = ( TRUE ) iff ( ( Fid (it , C135) ) . B151 ) = ( TRUE ))));
existence
proof
deffunc H14(set , (Function of C135 , ( BOOLEAN ))) = ( EneXt_univ ($1 , $2 , C136) );
consider C138 being set such that L1088: C138 in ( ModelSP C135 ) and L1089: (for B152 being set holds (B152 in C135 implies (H14(B152 , ( Fid (C137 , C135) )) = ( TRUE ) iff ( ( Fid (C138 , C135) ) . B152 ) = ( TRUE )))) from Func1EX;
take C138;
thus L1090: thesis by L1088 , L1089;
end;
uniqueness
proof
deffunc H15(set , (Function of C135 , ( BOOLEAN ))) = ( EneXt_univ ($1 , $2 , C136) );
L1091: (for B153 , B154 being set holds ((B153 in ( ModelSP C135 ) & (for B155 being set holds (B155 in C135 implies (H15(B155 , ( Fid (C137 , C135) )) = ( TRUE ) iff ( ( Fid (B153 , C135) ) . B155 ) = ( TRUE )))) & B154 in ( ModelSP C135 ) & (for B156 being set holds (B156 in C135 implies (H15(B156 , ( Fid (C137 , C135) )) = ( TRUE ) iff ( ( Fid (B154 , C135) ) . B156 ) = ( TRUE ))))) implies B153 = B154)) from Func1Unique;
thus L1092: thesis by L1091;
end;
end;
L1094: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for B157 , B158 being (UnOp of ( ModelSP R24 )) holds (((for B159 being set holds (B159 in ( ModelSP R24 ) implies ( B157 . B159 ) = ( EneXt_0 (B159 , R25) ))) & (for B160 being set holds (B160 in ( ModelSP R24 ) implies ( B158 . B160 ) = ( EneXt_0 (B160 , R25) )))) implies B157 = B158))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
set D51 = ( ModelSP R24 );
deffunc H16(set) = ( EneXt_0 ($1 , R25) );
L1095: (for B161 , B162 being (UnOp of D51) holds (((for B163 being set holds (B163 in D51 implies ( B161 . B163 ) = H16(B163))) & (for B164 being set holds (B164 in D51 implies ( B162 . B164 ) = H16(B164)))) implies B161 = B162)) from UnOpUnique;
thus L1096: thesis by L1095;
end;
definition
let C139 being non  empty set;
let C140 being  total (Relation of C139 , C139);
func EneXt_ C140 -> (UnOp of ( ModelSP C139 )) means
:L1097: (for B165 being set holds (B165 in ( ModelSP C139 ) implies ( it . B165 ) = ( EneXt_0 (B165 , C140) )));
existence
proof
set D52 = ( ModelSP C139 );
deffunc H17(set) = ( EneXt_0 ($1 , C140) );
L1098: (ex B166 being (UnOp of D52) st (for B167 being set holds (B167 in D52 implies ( B166 . B167 ) = H17(B167)))) from UnOpEX;
thus L1099: thesis by L1098;
end;
uniqueness by L1094;
end;
definition
let C141 being non  empty set;
let C142 being  total (Relation of C141 , C141);
let C143 being (Function of C141 , ( BOOLEAN ));
let C144 being set;
func EGlobal_univ (C144 , C143 , C142) -> (Element of ( BOOLEAN )) equals
:L1101: ( TRUE ) if (C144 in C141 & (ex B168 being (inf_path of C142) st (( B168 . ( 0 ) ) = C144 & (for B169 being (Element of ( NAT )) holds ( C143 . ( B168 . B169 ) ) = ( TRUE ))))) otherwise ( FALSE );
correctness;
end;
definition
let C145 being non  empty set;
let C146 being  total (Relation of C145 , C145);
let C147 being set;
func EGlobal_0 (C147 , C146) -> (Element of ( ModelSP C145 )) means
:L1103: (for B170 being set holds (B170 in C145 implies (( EGlobal_univ (B170 , ( Fid (C147 , C145) ) , C146) ) = ( TRUE ) iff ( ( Fid (it , C145) ) . B170 ) = ( TRUE ))));
existence
proof
deffunc H18(set , (Function of C145 , ( BOOLEAN ))) = ( EGlobal_univ ($1 , $2 , C146) );
consider C148 being set such that L1104: C148 in ( ModelSP C145 ) and L1105: (for B171 being set holds (B171 in C145 implies (H18(B171 , ( Fid (C147 , C145) )) = ( TRUE ) iff ( ( Fid (C148 , C145) ) . B171 ) = ( TRUE )))) from Func1EX;
take C148;
thus L1106: thesis by L1104 , L1105;
end;
uniqueness
proof
deffunc H19(set , (Function of C145 , ( BOOLEAN ))) = ( EGlobal_univ ($1 , $2 , C146) );
L1107: (for B172 , B173 being set holds ((B172 in ( ModelSP C145 ) & (for B174 being set holds (B174 in C145 implies (H19(B174 , ( Fid (C147 , C145) )) = ( TRUE ) iff ( ( Fid (B172 , C145) ) . B174 ) = ( TRUE )))) & B173 in ( ModelSP C145 ) & (for B175 being set holds (B175 in C145 implies (H19(B175 , ( Fid (C147 , C145) )) = ( TRUE ) iff ( ( Fid (B173 , C145) ) . B175 ) = ( TRUE ))))) implies B172 = B173)) from Func1Unique;
thus L1108: thesis by L1107;
end;
end;
L1110: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for B176 , B177 being (UnOp of ( ModelSP R24 )) holds (((for B178 being set holds (B178 in ( ModelSP R24 ) implies ( B176 . B178 ) = ( EGlobal_0 (B178 , R25) ))) & (for B179 being set holds (B179 in ( ModelSP R24 ) implies ( B177 . B179 ) = ( EGlobal_0 (B179 , R25) )))) implies B176 = B177))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
set D53 = ( ModelSP R24 );
deffunc H20(set) = ( EGlobal_0 ($1 , R25) );
L1111: (for B180 , B181 being (UnOp of D53) holds (((for B182 being set holds (B182 in D53 implies ( B180 . B182 ) = H20(B182))) & (for B183 being set holds (B183 in D53 implies ( B181 . B183 ) = H20(B183)))) implies B180 = B181)) from UnOpUnique;
thus L1112: thesis by L1111;
end;
definition
let C149 being non  empty set;
let C150 being  total (Relation of C149 , C149);
func EGlobal_ C150 -> (UnOp of ( ModelSP C149 )) means
:L1113: (for B184 being set holds (B184 in ( ModelSP C149 ) implies ( it . B184 ) = ( EGlobal_0 (B184 , C150) )));
existence
proof
set D54 = ( ModelSP C149 );
deffunc H21(set) = ( EGlobal_0 ($1 , C150) );
L1114: (ex B185 being (UnOp of D54) st (for B186 being set holds (B186 in D54 implies ( B185 . B186 ) = H21(B186)))) from UnOpEX;
thus L1115: thesis by L1114;
end;
uniqueness by L1110;
end;
definition
let C151 being non  empty set;
let C152 , C153 being set;
func And_0 (C152 , C153 , C151) -> (Element of ( ModelSP C151 )) means
:L1117: (for B187 being set holds (B187 in C151 implies (( ( Castboolean ( ( Fid (C152 , C151) ) . B187 ) ) '&' ( Castboolean ( ( Fid (C153 , C151) ) . B187 ) ) ) = ( TRUE ) iff ( ( Fid (it , C151) ) . B187 ) = ( TRUE ))));
existence
proof
deffunc H22(set , (Function of C151 , ( BOOLEAN )) , (Function of C151 , ( BOOLEAN ))) = ( ( Castboolean ( $2 . $1 ) ) '&' ( Castboolean ( $3 . $1 ) ) );
consider C154 being set such that L1118: C154 in ( ModelSP C151 ) and L1119: (for B188 being set holds (B188 in C151 implies (H22(B188 , ( Fid (C152 , C151) ) , ( Fid (C153 , C151) )) = ( TRUE ) iff ( ( Fid (C154 , C151) ) . B188 ) = ( TRUE )))) from Func2EX;
take C154;
thus L1120: thesis by L1118 , L1119;
end;
uniqueness
proof
deffunc H23(set , (Function of C151 , ( BOOLEAN )) , (Function of C151 , ( BOOLEAN ))) = ( ( Castboolean ( $2 . $1 ) ) '&' ( Castboolean ( $3 . $1 ) ) );
L1121: (for B189 , B190 being set holds ((B189 in ( ModelSP C151 ) & (for B191 being set holds (B191 in C151 implies (H23(B191 , ( Fid (C152 , C151) ) , ( Fid (C153 , C151) )) = ( TRUE ) iff ( ( Fid (B189 , C151) ) . B191 ) = ( TRUE )))) & B190 in ( ModelSP C151 ) & (for B192 being set holds (B192 in C151 implies (H23(B192 , ( Fid (C152 , C151) ) , ( Fid (C153 , C151) )) = ( TRUE ) iff ( ( Fid (B190 , C151) ) . B192 ) = ( TRUE ))))) implies B189 = B190)) from Func2Unique;
thus L1122: thesis by L1121;
end;
end;
L1124: (for R24 being non  empty set holds (for B193 , B194 being (BinOp of ( ModelSP R24 )) holds (((for B195 , B196 being set holds ((B195 in ( ModelSP R24 ) & B196 in ( ModelSP R24 )) implies ( B193 . (B195 , B196) ) = ( And_0 (B195 , B196 , R24) ))) & (for B197 , B198 being set holds ((B197 in ( ModelSP R24 ) & B198 in ( ModelSP R24 )) implies ( B194 . (B197 , B198) ) = ( And_0 (B197 , B198 , R24) )))) implies B193 = B194)))
proof
let R24 being non  empty set;
set D55 = ( ModelSP R24 );
deffunc H24((Element of D55) , (Element of D55)) = ( And_0 ($1 , $2 , R24) );
L1125: (for B199 , B200 being (BinOp of D55) holds (((for B201 , B202 being (Element of D55) holds ( B199 . (B201 , B202) ) = H24(B201 , B202)) & (for B203 , B204 being (Element of D55) holds ( B200 . (B203 , B204) ) = H24(B203 , B204))) implies B199 = B200)) from BINOP_2:sch 2;
L1126: (for B205 , B206 being (BinOp of D55) holds (((for B207 , B208 being set holds ((B207 in D55 & B208 in D55) implies ( B205 . (B207 , B208) ) = ( And_0 (B207 , B208 , R24) ))) & (for B209 , B210 being set holds ((B209 in D55 & B210 in D55) implies ( B206 . (B209 , B210) ) = ( And_0 (B209 , B210 , R24) )))) implies B205 = B206))
proof
let C155 , C156 being (BinOp of D55);
assume that
L1127: (for B211 , B212 being set holds ((B211 in D55 & B212 in D55) implies ( C155 . (B211 , B212) ) = ( And_0 (B211 , B212 , R24) )))
and
L1128: (for B213 , B214 being set holds ((B213 in D55 & B214 in D55) implies ( C156 . (B213 , B214) ) = ( And_0 (B213 , B214 , R24) )));
L1129: (for B215 , B216 being (Element of D55) holds ( C156 . (B215 , B216) ) = H24(B215 , B216)) by L1128;
L1130: (for B217 , B218 being (Element of D55) holds ( C155 . (B217 , B218) ) = H24(B217 , B218)) by L1127;
thus L1131: thesis by L1130 , L1125 , L1129;
end;
thus L1132: thesis by L1126;
end;
definition
let C157 being non  empty set;
func And_ C157 -> (BinOp of ( ModelSP C157 )) means
:L1133: (for B219 , B220 being set holds ((B219 in ( ModelSP C157 ) & B220 in ( ModelSP C157 )) implies ( it . (B219 , B220) ) = ( And_0 (B219 , B220 , C157) )));
existence
proof
set D56 = ( ModelSP C157 );
deffunc H25((Element of D56) , (Element of D56)) = ( And_0 ($1 , $2 , C157) );
consider C158 being (BinOp of D56) such that L1134: (for B221 , B222 being (Element of D56) holds ( C158 . (B221 , B222) ) = H25(B221 , B222)) from BINOP_1:sch 4;
L1135: (for B223 , B224 being set holds ((B223 in D56 & B224 in D56) implies ( C158 . (B223 , B224) ) = ( And_0 (B223 , B224 , C157) ))) by L1134;
thus L1136: thesis by L1135;
end;
uniqueness by L1124;
end;
definition
let C159 being non  empty set;
let C160 being  total (Relation of C159 , C159);
let C161 , C162 being (Function of C159 , ( BOOLEAN ));
let C163 being set;
func EUntill_univ (C163 , C161 , C162 , C160) -> (Element of ( BOOLEAN )) equals
:L1138: ( TRUE ) if (C163 in C159 & (ex B225 being (inf_path of C160) st (( B225 . ( 0 ) ) = C163 & (ex B226 being (Element of ( NAT )) st ((for B227 being (Element of ( NAT )) holds (B227 < B226 implies ( C161 . ( B225 . B227 ) ) = ( TRUE ))) & ( C162 . ( B225 . B226 ) ) = ( TRUE )))))) otherwise ( FALSE );
correctness;
end;
definition
let C164 being non  empty set;
let C165 being  total (Relation of C164 , C164);
let C166 , C167 being set;
func EUntill_0 (C166 , C167 , C165) -> (Element of ( ModelSP C164 )) means
:L1140: (for B228 being set holds (B228 in C164 implies (( EUntill_univ (B228 , ( Fid (C166 , C164) ) , ( Fid (C167 , C164) ) , C165) ) = ( TRUE ) iff ( ( Fid (it , C164) ) . B228 ) = ( TRUE ))));
existence
proof
deffunc H26(set , (Function of C164 , ( BOOLEAN )) , (Function of C164 , ( BOOLEAN ))) = ( EUntill_univ ($1 , $2 , $3 , C165) );
consider C168 being set such that L1141: C168 in ( ModelSP C164 ) and L1142: (for B229 being set holds (B229 in C164 implies (H26(B229 , ( Fid (C166 , C164) ) , ( Fid (C167 , C164) )) = ( TRUE ) iff ( ( Fid (C168 , C164) ) . B229 ) = ( TRUE )))) from Func2EX;
take C168;
thus L1143: thesis by L1141 , L1142;
end;
uniqueness
proof
deffunc H27(set , (Function of C164 , ( BOOLEAN )) , (Function of C164 , ( BOOLEAN ))) = ( EUntill_univ ($1 , $2 , $3 , C165) );
L1144: (for B230 , B231 being set holds ((B230 in ( ModelSP C164 ) & (for B232 being set holds (B232 in C164 implies (H27(B232 , ( Fid (C166 , C164) ) , ( Fid (C167 , C164) )) = ( TRUE ) iff ( ( Fid (B230 , C164) ) . B232 ) = ( TRUE )))) & B231 in ( ModelSP C164 ) & (for B233 being set holds (B233 in C164 implies (H27(B233 , ( Fid (C166 , C164) ) , ( Fid (C167 , C164) )) = ( TRUE ) iff ( ( Fid (B231 , C164) ) . B233 ) = ( TRUE ))))) implies B230 = B231)) from Func2Unique;
thus L1145: thesis by L1144;
end;
end;
L1147: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for B234 , B235 being (BinOp of ( ModelSP R24 )) holds (((for B236 , B237 being set holds ((B236 in ( ModelSP R24 ) & B237 in ( ModelSP R24 )) implies ( B234 . (B236 , B237) ) = ( EUntill_0 (B236 , B237 , R25) ))) & (for B238 , B239 being set holds ((B238 in ( ModelSP R24 ) & B239 in ( ModelSP R24 )) implies ( B235 . (B238 , B239) ) = ( EUntill_0 (B238 , B239 , R25) )))) implies B234 = B235))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
set D57 = ( ModelSP R24 );
deffunc H28((Element of D57) , (Element of D57)) = ( EUntill_0 ($1 , $2 , R25) );
L1148: (for B240 , B241 being (BinOp of D57) holds (((for B242 , B243 being (Element of D57) holds ( B240 . (B242 , B243) ) = H28(B242 , B243)) & (for B244 , B245 being (Element of D57) holds ( B241 . (B244 , B245) ) = H28(B244 , B245))) implies B240 = B241)) from BINOP_2:sch 2;
L1149: (for B246 , B247 being (BinOp of D57) holds (((for B248 , B249 being set holds ((B248 in D57 & B249 in D57) implies ( B246 . (B248 , B249) ) = ( EUntill_0 (B248 , B249 , R25) ))) & (for B250 , B251 being set holds ((B250 in D57 & B251 in D57) implies ( B247 . (B250 , B251) ) = ( EUntill_0 (B250 , B251 , R25) )))) implies B246 = B247))
proof
let C169 , C170 being (BinOp of D57);
assume that
L1150: (for B252 , B253 being set holds ((B252 in D57 & B253 in D57) implies ( C169 . (B252 , B253) ) = ( EUntill_0 (B252 , B253 , R25) )))
and
L1151: (for B254 , B255 being set holds ((B254 in D57 & B255 in D57) implies ( C170 . (B254 , B255) ) = ( EUntill_0 (B254 , B255 , R25) )));
L1152: (for B256 , B257 being (Element of D57) holds ( C170 . (B256 , B257) ) = H28(B256 , B257)) by L1151;
L1153: (for B258 , B259 being (Element of D57) holds ( C169 . (B258 , B259) ) = H28(B258 , B259)) by L1150;
thus L1154: thesis by L1153 , L1148 , L1152;
end;
thus L1155: thesis by L1149;
end;
definition
let C171 being non  empty set;
let C172 being  total (Relation of C171 , C171);
func EUntill_ C172 -> (BinOp of ( ModelSP C171 )) means
:L1156: (for B260 , B261 being set holds ((B260 in ( ModelSP C171 ) & B261 in ( ModelSP C171 )) implies ( it . (B260 , B261) ) = ( EUntill_0 (B260 , B261 , C172) )));
existence
proof
set D58 = ( ModelSP C171 );
deffunc H29((Element of D58) , (Element of D58)) = ( EUntill_0 ($1 , $2 , C172) );
consider C173 being (BinOp of D58) such that L1157: (for B262 , B263 being (Element of D58) holds ( C173 . (B262 , B263) ) = H29(B262 , B263)) from BINOP_1:sch 4;
L1158: (for B264 , B265 being set holds ((B264 in D58 & B265 in D58) implies ( C173 . (B264 , B265) ) = ( EUntill_0 (B264 , B265 , C172) ))) by L1157;
thus L1159: thesis by L1158;
end;
uniqueness by L1147;
end;
definition
let C174 being non  empty set;
let C175 being non  empty (Subset of ( ModelSP C174 ));
let C176 being set;
func F_LABEL (C176 , C175) -> (Subset of C175) means
:L1161: (for B266 being set holds (B266 in it iff (B266 in C175 & (ex B267 being (Function of C174 , ( BOOLEAN )) st (B267 = B266 & ( B267 . C176 ) = ( TRUE ))))));
existence
proof
defpred S9[ set ] means (ex B268 being (Function of C174 , ( BOOLEAN )) st (B268 = $1 & ( B268 . C176 ) = ( TRUE )));
consider C177 being set such that L1162: (for B269 being set holds (B269 in C177 iff (B269 in C175 & S9[ B269 ]))) from XBOOLE_0:sch 1;
L1163: (for B270 being set holds (B270 in C177 implies B270 in C175)) by L1162;
reconsider D59 = C177 as (Subset of C175) by L1163 , TARSKI:def 3;
take D59;
thus L1164: thesis by L1162;
end;
uniqueness
proof
defpred S10[ set ] means ($1 in C175 & (ex B271 being (Function of C174 , ( BOOLEAN )) st (B271 = $1 & ( B271 . C176 ) = ( TRUE ))));
L1165: (for B272 , B273 being set holds (((for B274 being set holds (B274 in B272 iff S10[ B274 ])) & (for B275 being set holds (B275 in B273 iff S10[ B275 ]))) implies B272 = B273)) from XBOOLE_0:sch 3;
thus L1166: thesis by L1165;
end;
end;
definition
let C178 being non  empty set;
let C179 being non  empty (Subset of ( ModelSP C178 ));
func Label_ C179 -> (Function of C178 , ( bool C179 )) means
:L1168: (for B276 being set holds (B276 in C178 implies ( it . B276 ) = ( F_LABEL (B276 , C179) )));
existence
proof
deffunc H30(set) = ( F_LABEL ($1 , C179) );
L1169: (for B277 being set holds (B277 in C178 implies H30(B277) in ( bool C179 )));
consider C180 being (Function of C178 , ( bool C179 )) such that L1170: (for B278 being set holds (B278 in C178 implies ( C180 . B278 ) = H30(B278))) from FUNCT_2:sch 2(L1169);
take C180;
thus L1171: thesis by L1170;
end;
uniqueness
proof
L1172: (for B279 , B280 being (Function of C178 , ( bool C179 )) holds (((for B281 being set holds (B281 in C178 implies ( B279 . B281 ) = ( F_LABEL (B281 , C179) ))) & (for B282 being set holds (B282 in C178 implies ( B280 . B282 ) = ( F_LABEL (B282 , C179) )))) implies B279 = B280))
proof
let C181 , C182 being (Function of C178 , ( bool C179 ));
assume that
L1173: (for B283 being set holds (B283 in C178 implies ( C181 . B283 ) = ( F_LABEL (B283 , C179) )))
and
L1174: (for B284 being set holds (B284 in C178 implies ( C182 . B284 ) = ( F_LABEL (B284 , C179) )));
L1175: (for B285 being set holds (B285 in C178 implies ( C181 . B285 ) = ( C182 . B285 )))
proof
let C183 being set;
assume that
L1176: C183 in C178;
L1177: ( C181 . C183 ) = ( F_LABEL (C183 , C179) ) by L1173 , L1176
.= ( C182 . C183 ) by L1174 , L1176;
thus L1178: thesis by L1177;
end;
thus L1179: thesis by L1175 , FUNCT_2:12;
end;
thus L1180: thesis by L1172;
end;
end;
definition
let C184 being non  empty set;
let C185 being (Subset of C184);
let C186 being  total (Relation of C184 , C184);
let C187 being non  empty (Subset of ( ModelSP C184 ));
func KModel (C186 , C185 , C187) -> KripkeStr over C187 equals
KripkeStr (# C184 , C185 , C186 , ( Label_ C187 ) #);
coherence;
end;
registration
let C188 being non  empty set;
let C189 being (Subset of C188);
let C190 being  total (Relation of C188 , C188);
let C191 being non  empty (Subset of ( ModelSP C188 ));
cluster (the carrier of ( KModel (C190 , C189 , C191) )) -> non  empty;
coherence;
end;
registration
let C192 being non  empty set;
let C193 being (Subset of C192);
let C194 being  total (Relation of C192 , C192);
let C195 being non  empty (Subset of ( ModelSP C192 ));
cluster ( ModelSP (the carrier of ( KModel (C194 , C193 , C195) )) ) -> non  empty for (Subset of ( Funcs ((the carrier of ( KModel (C194 , C193 , C195) )) , ( BOOLEAN )) ));
coherence;
end;
definition
let C196 being non  empty set;
let C197 being  total (Relation of C196 , C196);
let C198 being non  empty (Subset of ( ModelSP C196 ));
func BASSModel (C197 , C198) -> CTLModelStr equals
CTLModelStr (# ( ModelSP C196 ) , C198 , ( And_ C196 ) , ( Not_ C196 ) , ( EneXt_ C197 ) , ( EGlobal_ C197 ) , ( EUntill_ C197 ) #);
coherence;
end;
registration
let C199 being non  empty set;
let C200 being  total (Relation of C199 , C199);
let C201 being non  empty (Subset of ( ModelSP C199 ));
cluster ( BASSModel (C200 , C201) ) ->  with_basic non  empty;
coherence
proof
set D60 = ( BASSModel (C200 , C201) );
thus L1186: (the BasicAssign of D60) is non  empty;
thus L1187: thesis;
end;
end;
definition
let C202 being non  empty set;
let C203 being  total (Relation of C202 , C202);
let C204 being non  empty (Subset of ( ModelSP C202 ));
let C205 being (Element of C202);
let C206 being (Assign of ( BASSModel (C203 , C204) ));
pred C205 |= C206
means
:L1189: ( ( Fid (C206 , C202) ) . C205 ) = ( TRUE )
;end;
notation
let C207 being non  empty set;
let C208 being  total (Relation of C207 , C207);
let C209 being non  empty (Subset of ( ModelSP C207 ));
let C210 being (Element of C207);
let C211 being (Assign of ( BASSModel (C208 , C209) ));
antonym C210 |/= C211 for C210 |= C211;
end;
theorem
L1192: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B286 being (Assign of ( BASSModel (R25 , R29) )) holds (B286 in R29 implies (R26 |= B286 iff B286 in ( ( Label_ R29 ) . R26 ))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C212 being (Assign of ( BASSModel (R25 , R29) ));
assume that
L1193: C212 in R29;
thus L1194: (R26 |= C212 implies C212 in ( ( Label_ R29 ) . R26 ))
proof
set D61 = ( Fid (C212 , R24) );
assume L1195: R26 |= C212;
L1196: ( D61 . R26 ) = ( TRUE ) by L1195 , L1189;
L1197: C212 = D61 by L1017;
L1198: C212 in ( F_LABEL (R26 , R29) ) by L1197 , L1193 , L1196 , L1161;
thus L1199: thesis by L1198 , L1168;
end;

assume L1200: C212 in ( ( Label_ R29 ) . R26 );
L1201: C212 in ( F_LABEL (R26 , R29) ) by L1200 , L1168;
consider C213 being (Function of R24 , ( BOOLEAN )) such that L1202: C213 = C212 and L1203: ( C213 . R26 ) = ( TRUE ) by L1201 , L1161;
L1204: ( Fid (C212 , R24) ) = C213 by L1202 , L1017;
thus L1205: thesis by L1204 , L1203 , L1189;
end;
theorem
L1206: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B287 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( 'not' B287 ) iff R26 |/= B287))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C214 being (Assign of ( BASSModel (R25 , R29) ));
L1207: ( 'not' C214 ) = ( Not_0 (C214 , R24) ) by L1081;
L1208: (R26 |/= C214 implies R26 |= ( 'not' C214 ))
proof
assume L1209: R26 |/= C214;
L1210: (not ( ( Fid (C214 , R24) ) . R26 ) = ( TRUE )) by L1209 , L1189;
L1211: (not ( Castboolean ( ( Fid (C214 , R24) ) . R26 ) ) = ( TRUE )) by L1210 , L13;
L1212: ( Castboolean ( ( Fid (C214 , R24) ) . R26 ) ) = ( FALSE ) by L1211 , XBOOLEAN:def 3;
L1213: ( 'not' ( Castboolean ( ( Fid (C214 , R24) ) . R26 ) ) ) = ( TRUE ) by L1212;
L1214: ( ( Fid (( 'not' C214 ) , R24) ) . R26 ) = ( TRUE ) by L1213 , L1207 , L1071;
thus L1215: thesis by L1214 , L1189;
end;
L1216: (R26 |= ( 'not' C214 ) implies R26 |/= C214)
proof
assume L1217: R26 |= ( 'not' C214 );
L1218: ( ( Fid (( Not_0 (C214 , R24) ) , R24) ) . R26 ) = ( TRUE ) by L1217 , L1207 , L1189;
L1219: ( 'not' ( Castboolean ( ( Fid (C214 , R24) ) . R26 ) ) ) = ( TRUE ) by L1218 , L1071;
L1220: ( ( Fid (C214 , R24) ) . R26 ) = ( FALSE ) by L1219 , L13;
thus L1221: thesis by L1220 , L1189;
end;
thus L1222: thesis by L1216 , L1208;
end;
theorem
L1223: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B288 , B289 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( B288 '&' B289 ) iff (R26 |= B288 & R26 |= B289)))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C215 , C216 being (Assign of ( BASSModel (R25 , R29) ));
L1224: ( C215 '&' C216 ) = ( And_0 (C215 , C216 , R24) ) by L1133;
L1225: (R26 |= ( C215 '&' C216 ) implies (R26 |= C215 & R26 |= C216))
proof
assume L1226: R26 |= ( C215 '&' C216 );
L1227: ( ( Fid (( And_0 (C215 , C216 , R24) ) , R24) ) . R26 ) = ( TRUE ) by L1226 , L1224 , L1189;
L1228: ( ( Castboolean ( ( Fid (C215 , R24) ) . R26 ) ) '&' ( Castboolean ( ( Fid (C216 , R24) ) . R26 ) ) ) = ( TRUE ) by L1227 , L1117;
L1229: ( Castboolean ( ( Fid (C216 , R24) ) . R26 ) ) = ( TRUE ) by L1228 , XBOOLEAN:101;
L1230: ( ( Fid (C216 , R24) ) . R26 ) = ( TRUE ) by L1229 , L13;
L1231: ( Castboolean ( ( Fid (C215 , R24) ) . R26 ) ) = ( TRUE ) by L1228 , XBOOLEAN:101;
L1232: ( ( Fid (C215 , R24) ) . R26 ) = ( TRUE ) by L1231 , L13;
thus L1233: thesis by L1232 , L1230 , L1189;
end;
L1234: ((R26 |= C215 & R26 |= C216) implies R26 |= ( C215 '&' C216 ))
proof
assume that
L1235: R26 |= C215
and
L1236: R26 |= C216;
L1237: ( ( Fid (C216 , R24) ) . R26 ) = ( TRUE ) by L1236 , L1189;
L1238: ( ( Fid (C215 , R24) ) . R26 ) = ( TRUE ) by L1235 , L1189;
L1239: ( ( Castboolean ( ( Fid (C215 , R24) ) . R26 ) ) '&' ( Castboolean ( ( Fid (C216 , R24) ) . R26 ) ) ) = ( TRUE ) by L1238 , L1237 , L13;
L1240: ( ( Fid (( C215 '&' C216 ) , R24) ) . R26 ) = ( TRUE ) by L1239 , L1224 , L1117;
thus L1241: thesis by L1240 , L1189;
end;
thus L1242: thesis by L1234 , L1225;
end;
theorem
L1243: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B290 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( EX B290 ) iff (ex B291 being (inf_path of R25) st (( B291 . ( 0 ) ) = R26 & ( B291 . 1 ) |= B290))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C217 being (Assign of ( BASSModel (R25 , R29) ));
L1244: ( EX C217 ) = ( EneXt_0 (C217 , R25) ) by L1097;
L1245: ((ex B292 being (inf_path of R25) st (( B292 . ( 0 ) ) = R26 & ( B292 . 1 ) |= C217)) implies R26 |= ( EX C217 ))
proof
assume L1246: (ex B293 being (inf_path of R25) st (( B293 . ( 0 ) ) = R26 & ( B293 . 1 ) |= C217));
L1247: (ex B294 being (inf_path of R25) st (( B294 . ( 0 ) ) = R26 & ( ( Fid (C217 , R24) ) . ( B294 . 1 ) ) = ( TRUE )))
proof
consider C218 being (inf_path of R25) such that L1248: ( C218 . ( 0 ) ) = R26 and L1249: ( C218 . 1 ) |= C217 by L1246;
take C218;
thus L1250: thesis by L1248 , L1249 , L1189;
end;
L1251: ( EneXt_univ (R26 , ( Fid (C217 , R24) ) , R25) ) = ( TRUE ) by L1247 , L1085;
L1252: ( ( Fid (( EX C217 ) , R24) ) . R26 ) = ( TRUE ) by L1251 , L1244 , L1087;
thus L1253: thesis by L1252 , L1189;
end;
L1254: (R26 |= ( EX C217 ) implies (ex B295 being (inf_path of R25) st (( B295 . ( 0 ) ) = R26 & ( B295 . 1 ) |= C217)))
proof
assume L1255: R26 |= ( EX C217 );
L1256: ( ( Fid (( EneXt_0 (C217 , R25) ) , R24) ) . R26 ) = ( TRUE ) by L1255 , L1244 , L1189;
L1257: ( EneXt_univ (R26 , ( Fid (C217 , R24) ) , R25) ) = ( TRUE ) by L1256 , L1087;
consider C219 being (inf_path of R25) such that L1258: ( C219 . ( 0 ) ) = R26 and L1259: ( ( Fid (C217 , R24) ) . ( C219 . 1 ) ) = ( TRUE ) by L1257 , L1085;
take C219;
thus L1260: thesis by L1258 , L1259 , L1189;
end;
thus L1261: thesis by L1254 , L1245;
end;
theorem
L1262: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B296 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( EG B296 ) iff (ex B297 being (inf_path of R25) st (( B297 . ( 0 ) ) = R26 & (for B298 being (Element of ( NAT )) holds ( B297 . B298 ) |= B296)))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C220 being (Assign of ( BASSModel (R25 , R29) ));
L1263: ( EG C220 ) = ( EGlobal_0 (C220 , R25) ) by L1113;
L1264: ((ex B299 being (inf_path of R25) st (( B299 . ( 0 ) ) = R26 & (for B300 being (Element of ( NAT )) holds ( B299 . B300 ) |= C220))) implies R26 |= ( EG C220 ))
proof
assume L1265: (ex B301 being (inf_path of R25) st (( B301 . ( 0 ) ) = R26 & (for B302 being (Element of ( NAT )) holds ( B301 . B302 ) |= C220)));
L1266: (ex B303 being (inf_path of R25) st (( B303 . ( 0 ) ) = R26 & (for B304 being (Element of ( NAT )) holds ( ( Fid (C220 , R24) ) . ( B303 . B304 ) ) = ( TRUE ))))
proof
consider C221 being (inf_path of R25) such that L1267: ( C221 . ( 0 ) ) = R26 and L1268: (for B305 being (Element of ( NAT )) holds ( C221 . B305 ) |= C220) by L1265;
take C221;
L1269: (for B306 being (Element of ( NAT )) holds ( ( Fid (C220 , R24) ) . ( C221 . B306 ) ) = ( TRUE ))
proof
let C222 being (Element of ( NAT ));
L1270: ( C221 . C222 ) |= C220 by L1268;
thus L1271: thesis by L1270 , L1189;
end;
thus L1272: thesis by L1269 , L1267;
end;
L1273: ( EGlobal_univ (R26 , ( Fid (C220 , R24) ) , R25) ) = ( TRUE ) by L1266 , L1101;
L1274: ( ( Fid (( EG C220 ) , R24) ) . R26 ) = ( TRUE ) by L1273 , L1263 , L1103;
thus L1275: thesis by L1274 , L1189;
end;
L1276: (R26 |= ( EG C220 ) implies (ex B307 being (inf_path of R25) st (( B307 . ( 0 ) ) = R26 & (for B308 being (Element of ( NAT )) holds ( B307 . B308 ) |= C220))))
proof
assume L1277: R26 |= ( EG C220 );
L1278: ( ( Fid (( EGlobal_0 (C220 , R25) ) , R24) ) . R26 ) = ( TRUE ) by L1277 , L1263 , L1189;
L1279: ( EGlobal_univ (R26 , ( Fid (C220 , R24) ) , R25) ) = ( TRUE ) by L1278 , L1103;
consider C223 being (inf_path of R25) such that L1280: ( C223 . ( 0 ) ) = R26 and L1281: (for B309 being (Element of ( NAT )) holds ( ( Fid (C220 , R24) ) . ( C223 . B309 ) ) = ( TRUE )) by L1279 , L1101;
take C223;
L1282: (for B310 being (Element of ( NAT )) holds ( C223 . B310 ) |= C220)
proof
let C224 being (Element of ( NAT ));
L1283: ( ( Fid (C220 , R24) ) . ( C223 . C224 ) ) = ( TRUE ) by L1281;
thus L1284: thesis by L1283 , L1189;
end;
thus L1285: thesis by L1282 , L1280;
end;
thus L1286: thesis by L1276 , L1264;
end;
theorem
L1287: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B311 , B312 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( B311 EU B312 ) iff (ex B313 being (inf_path of R25) st (( B313 . ( 0 ) ) = R26 & (ex B314 being (Element of ( NAT )) st ((for B315 being (Element of ( NAT )) holds (B315 < B314 implies ( B313 . B315 ) |= B311)) & ( B313 . B314 ) |= B312))))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C225 , C226 being (Assign of ( BASSModel (R25 , R29) ));
L1288: ( C225 EU C226 ) = ( EUntill_0 (C225 , C226 , R25) ) by L1156;
L1289: ((ex B316 being (inf_path of R25) st (( B316 . ( 0 ) ) = R26 & (ex B317 being (Element of ( NAT )) st ((for B318 being (Element of ( NAT )) holds (B318 < B317 implies ( B316 . B318 ) |= C225)) & ( B316 . B317 ) |= C226)))) implies R26 |= ( C225 EU C226 ))
proof
assume L1290: (ex B319 being (inf_path of R25) st (( B319 . ( 0 ) ) = R26 & (ex B320 being (Element of ( NAT )) st ((for B321 being (Element of ( NAT )) holds (B321 < B320 implies ( B319 . B321 ) |= C225)) & ( B319 . B320 ) |= C226))));
L1291: (ex B322 being (inf_path of R25) st (( B322 . ( 0 ) ) = R26 & (ex B323 being (Element of ( NAT )) st ((for B324 being (Element of ( NAT )) holds (B324 < B323 implies ( ( Fid (C225 , R24) ) . ( B322 . B324 ) ) = ( TRUE ))) & ( ( Fid (C226 , R24) ) . ( B322 . B323 ) ) = ( TRUE )))))
proof
consider C227 being (inf_path of R25) such that L1292: ( C227 . ( 0 ) ) = R26 and L1293: (ex B325 being (Element of ( NAT )) st ((for B326 being (Element of ( NAT )) holds (B326 < B325 implies ( C227 . B326 ) |= C225)) & ( C227 . B325 ) |= C226)) by L1290;
take C227;
L1294: (ex B327 being (Element of ( NAT )) st ((for B328 being (Element of ( NAT )) holds (B328 < B327 implies ( ( Fid (C225 , R24) ) . ( C227 . B328 ) ) = ( TRUE ))) & ( ( Fid (C226 , R24) ) . ( C227 . B327 ) ) = ( TRUE )))
proof
consider C228 being (Element of ( NAT )) such that L1295: (for B329 being (Element of ( NAT )) holds (B329 < C228 implies ( C227 . B329 ) |= C225)) and L1296: ( C227 . C228 ) |= C226 by L1293;
take C228;
L1297: (for B330 being (Element of ( NAT )) holds (B330 < C228 implies ( ( Fid (C225 , R24) ) . ( C227 . B330 ) ) = ( TRUE )))
proof
let C229 being (Element of ( NAT ));
assume L1298: C229 < C228;
L1299: ( C227 . C229 ) |= C225 by L1298 , L1295;
thus L1300: thesis by L1299 , L1189;
end;
thus L1301: thesis by L1297 , L1296 , L1189;
end;
thus L1302: thesis by L1294 , L1292;
end;
L1303: ( EUntill_univ (R26 , ( Fid (C225 , R24) ) , ( Fid (C226 , R24) ) , R25) ) = ( TRUE ) by L1291 , L1138;
L1304: ( ( Fid (( C225 EU C226 ) , R24) ) . R26 ) = ( TRUE ) by L1303 , L1288 , L1140;
thus L1305: thesis by L1304 , L1189;
end;
L1306: (R26 |= ( C225 EU C226 ) implies (ex B331 being (inf_path of R25) st (( B331 . ( 0 ) ) = R26 & (ex B332 being (Element of ( NAT )) st ((for B333 being (Element of ( NAT )) holds (B333 < B332 implies ( B331 . B333 ) |= C225)) & ( B331 . B332 ) |= C226)))))
proof
assume L1307: R26 |= ( C225 EU C226 );
L1308: ( ( Fid (( EUntill_0 (C225 , C226 , R25) ) , R24) ) . R26 ) = ( TRUE ) by L1307 , L1288 , L1189;
L1309: ( EUntill_univ (R26 , ( Fid (C225 , R24) ) , ( Fid (C226 , R24) ) , R25) ) = ( TRUE ) by L1308 , L1140;
consider C230 being (inf_path of R25) such that L1310: ( C230 . ( 0 ) ) = R26 and L1311: (ex B334 being (Element of ( NAT )) st ((for B335 being (Element of ( NAT )) holds (B335 < B334 implies ( ( Fid (C225 , R24) ) . ( C230 . B335 ) ) = ( TRUE ))) & ( ( Fid (C226 , R24) ) . ( C230 . B334 ) ) = ( TRUE ))) by L1309 , L1138;
take C230;
L1312: (ex B336 being (Element of ( NAT )) st ((for B337 being (Element of ( NAT )) holds (B337 < B336 implies ( C230 . B337 ) |= C225)) & ( C230 . B336 ) |= C226))
proof
consider C231 being (Element of ( NAT )) such that L1313: (for B338 being (Element of ( NAT )) holds (B338 < C231 implies ( ( Fid (C225 , R24) ) . ( C230 . B338 ) ) = ( TRUE ))) and L1314: ( ( Fid (C226 , R24) ) . ( C230 . C231 ) ) = ( TRUE ) by L1311;
take C231;
L1315: (for B339 being (Element of ( NAT )) holds (B339 < C231 implies ( C230 . B339 ) |= C225))
proof
let C232 being (Element of ( NAT ));
assume L1316: C232 < C231;
L1317: ( ( Fid (C225 , R24) ) . ( C230 . C232 ) ) = ( TRUE ) by L1316 , L1313;
thus L1318: thesis by L1317 , L1189;
end;
thus L1319: thesis by L1315 , L1314 , L1189;
end;
thus L1320: thesis by L1312 , L1310;
end;
thus L1321: thesis by L1306 , L1289;
end;
theorem
L1322: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B340 , B341 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( B340 'or' B341 ) iff (R26 |= B340 or R26 |= B341)))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C233 , C234 being (Assign of ( BASSModel (R25 , R29) ));
L1323: (R26 |= ( C233 'or' C234 ) iff (not R26 |= ( ( 'not' C233 ) '&' ( 'not' C234 ) ))) by L1206;
L1324: (R26 |= ( C233 'or' C234 ) iff ((not R26 |= ( 'not' C233 )) or (not R26 |= ( 'not' C234 )))) by L1323 , L1223;
thus L1325: thesis by L1324 , L1206;
end;
definition
let C235 being non  empty set;
let C236 being  total (Relation of C235 , C235);
let C237 being non  empty (Subset of ( ModelSP C235 ));
let C238 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (C236 , C237) )));
let C239 being (Element of C235);
let C240 being CTL-formula;
pred C239 , C238 |= C240
means
:L1326: C239 |= ( Evaluate (C240 , C238) )
;end;
notation
let C241 being non  empty set;
let C242 being  total (Relation of C241 , C241);
let C243 being non  empty (Subset of ( ModelSP C241 ));
let C244 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (C242 , C243) )));
let C245 being (Element of C241);
let C246 being CTL-formula;
antonym C245 , C244 |/= C246 for C245 , C244 |= C246;
end;
theorem
L1329: (for R14 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R14 is  atomic implies (R26 , R30 |= R14 iff ( R30 . R14 ) in ( ( Label_ R29 ) . R26 )))))))))
proof
let R14 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
assume L1330: R14 is  atomic;
L1331: (ex B342 being (Function of ( CTL_WFF ) , (the carrier of ( BASSModel (R25 , R29) ))) st (B342 is-Evaluation-for R30 & ( Evaluate (R14 , R30) ) = ( B342 . R14 ))) by L872;
L1332: ( Evaluate (R14 , R30) ) = ( R30 . R14 ) by L1331 , L1330 , L523;
L1333: (R26 , R30 |= R14 iff R26 |= ( Evaluate (R14 , R30) )) by L1326;
L1334: R14 in ( atomic_WFF ) by L1330;
L1335: ( Evaluate (R14 , R30) ) in R29 by L1334 , L1332 , FUNCT_2:5;
thus L1336: thesis by L1335 , L1332 , L1333 , L1192;
end;
theorem
L1337: (for R14 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R26 , R30 |= ( 'not' R14 ) iff R26 , R30 |/= R14)))))))
proof
let R14 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
L1338: (R26 , R30 |= ( 'not' R14 ) iff R26 |= ( Evaluate (( 'not' R14 ) , R30) )) by L1326;
L1339: (R26 , R30 |= ( 'not' R14 ) iff R26 |= ( 'not' ( Evaluate (R14 , R30) ) )) by L1338 , L880;
L1340: (R26 , R30 |= ( 'not' R14 ) iff R26 |/= ( Evaluate (R14 , R30) )) by L1339 , L1206;
thus L1341: thesis by L1340 , L1326;
end;
theorem
L1342: (for R15 being CTL-formula holds (for R16 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R26 , R30 |= ( R15 '&' R16 ) iff (R26 , R30 |= R15 & R26 , R30 |= R16)))))))))
proof
let R15 being CTL-formula;
let R16 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
L1343: (R26 , R30 |= ( R15 '&' R16 ) iff R26 |= ( Evaluate (( R15 '&' R16 ) , R30) )) by L1326;
L1344: (R26 , R30 |= ( R15 '&' R16 ) iff R26 |= ( ( Evaluate (R15 , R30) ) '&' ( Evaluate (R16 , R30) ) )) by L1343 , L887;
L1345: (R26 , R30 |= ( R15 '&' R16 ) iff (R26 |= ( Evaluate (R15 , R30) ) & R26 |= ( Evaluate (R16 , R30) ))) by L1344 , L1223;
thus L1346: thesis by L1345 , L1326;
end;
theorem
L1347: (for R15 being CTL-formula holds (for R16 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R26 , R30 |= ( R15 'or' R16 ) iff (R26 , R30 |= R15 or R26 , R30 |= R16)))))))))
proof
let R15 being CTL-formula;
let R16 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
L1348: (R26 , R30 |= ( R15 'or' R16 ) iff R26 |= ( Evaluate (( R15 'or' R16 ) , R30) )) by L1326;
L1349: (R26 , R30 |= ( R15 'or' R16 ) iff R26 |= ( ( Evaluate (R15 , R30) ) 'or' ( Evaluate (R16 , R30) ) )) by L1348 , L931;
L1350: (R26 , R30 |= ( R15 'or' R16 ) iff (R26 |= ( Evaluate (R15 , R30) ) or R26 |= ( Evaluate (R16 , R30) ))) by L1349 , L1322;
thus L1351: thesis by L1350 , L1326;
end;
theorem
L1352: (for R14 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R26 , R30 |= ( EX R14 ) iff (ex B343 being (inf_path of R25) st (( B343 . ( 0 ) ) = R26 & ( B343 . 1 ) , R30 |= R14)))))))))
proof
let R14 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
L1353: ((ex B344 being (inf_path of R25) st (( B344 . ( 0 ) ) = R26 & ( B344 . 1 ) |= ( Evaluate (R14 , R30) ))) implies (ex B345 being (inf_path of R25) st (( B345 . ( 0 ) ) = R26 & ( B345 . 1 ) , R30 |= R14)))
proof
given C247 being (inf_path of R25) such that
L1354: ( C247 . ( 0 ) ) = R26
and
L1355: ( C247 . 1 ) |= ( Evaluate (R14 , R30) );

take C247;
thus L1356: thesis by L1354 , L1355 , L1326;
end;
L1357: ((ex B346 being (inf_path of R25) st (( B346 . ( 0 ) ) = R26 & ( B346 . 1 ) , R30 |= R14)) implies (ex B347 being (inf_path of R25) st (( B347 . ( 0 ) ) = R26 & ( B347 . 1 ) |= ( Evaluate (R14 , R30) ))))
proof
given C248 being (inf_path of R25) such that
L1358: ( C248 . ( 0 ) ) = R26
and
L1359: ( C248 . 1 ) , R30 |= R14;

take C248;
thus L1360: thesis by L1358 , L1359 , L1326;
end;
L1361: (R26 , R30 |= ( EX R14 ) iff R26 |= ( Evaluate (( EX R14 ) , R30) )) by L1326;
L1362: (R26 , R30 |= ( EX R14 ) iff R26 |= ( EX ( Evaluate (R14 , R30) ) )) by L1361 , L900;
thus L1363: thesis by L1362 , L1353 , L1357 , L1243;
end;
theorem
L1364: (for R14 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R26 , R30 |= ( EG R14 ) iff (ex B348 being (inf_path of R25) st (( B348 . ( 0 ) ) = R26 & (for B349 being (Element of ( NAT )) holds ( B348 . B349 ) , R30 |= R14))))))))))
proof
let R14 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
L1365: ((ex B350 being (inf_path of R25) st (( B350 . ( 0 ) ) = R26 & (for B351 being (Element of ( NAT )) holds ( B350 . B351 ) |= ( Evaluate (R14 , R30) )))) implies (ex B352 being (inf_path of R25) st (( B352 . ( 0 ) ) = R26 & (for B353 being (Element of ( NAT )) holds ( B352 . B353 ) , R30 |= R14))))
proof
given C249 being (inf_path of R25) such that
L1366: ( C249 . ( 0 ) ) = R26
and
L1367: (for B354 being (Element of ( NAT )) holds ( C249 . B354 ) |= ( Evaluate (R14 , R30) ));

take C249;
L1368: (for B355 being (Element of ( NAT )) holds ( C249 . B355 ) , R30 |= R14)
proof
let C250 being (Element of ( NAT ));
L1369: ( C249 . C250 ) |= ( Evaluate (R14 , R30) ) by L1367;
thus L1370: thesis by L1369 , L1326;
end;
thus L1371: thesis by L1368 , L1366;
end;
L1372: ((ex B356 being (inf_path of R25) st (( B356 . ( 0 ) ) = R26 & (for B357 being (Element of ( NAT )) holds ( B356 . B357 ) , R30 |= R14))) implies (ex B358 being (inf_path of R25) st (( B358 . ( 0 ) ) = R26 & (for B359 being (Element of ( NAT )) holds ( B358 . B359 ) |= ( Evaluate (R14 , R30) )))))
proof
given C251 being (inf_path of R25) such that
L1373: ( C251 . ( 0 ) ) = R26
and
L1374: (for B360 being (Element of ( NAT )) holds ( C251 . B360 ) , R30 |= R14);

take C251;
L1375: (for B361 being (Element of ( NAT )) holds ( C251 . B361 ) |= ( Evaluate (R14 , R30) ))
proof
let C252 being (Element of ( NAT ));
L1376: ( C251 . C252 ) , R30 |= R14 by L1374;
thus L1377: thesis by L1376 , L1326;
end;
thus L1378: thesis by L1375 , L1373;
end;
L1379: (R26 , R30 |= ( EG R14 ) iff R26 |= ( Evaluate (( EG R14 ) , R30) )) by L1326;
L1380: (R26 , R30 |= ( EG R14 ) iff R26 |= ( EG ( Evaluate (R14 , R30) ) )) by L1379 , L907;
thus L1381: thesis by L1380 , L1365 , L1372 , L1262;
end;
theorem
L1382: (for R15 being CTL-formula holds (for R16 being CTL-formula holds (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) ))) holds (R26 , R30 |= ( R15 EU R16 ) iff (ex B362 being (inf_path of R25) st (( B362 . ( 0 ) ) = R26 & (ex B363 being (Element of ( NAT )) st ((for B364 being (Element of ( NAT )) holds (B364 < B363 implies ( B362 . B364 ) , R30 |= R15)) & ( B362 . B363 ) , R30 |= R16))))))))))))
proof
let R15 being CTL-formula;
let R16 being CTL-formula;
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let R30 being (Function of ( atomic_WFF ) , (the BasicAssign of ( BASSModel (R25 , R29) )));
L1383: ((ex B365 being (inf_path of R25) st (( B365 . ( 0 ) ) = R26 & (ex B366 being (Element of ( NAT )) st ((for B367 being (Element of ( NAT )) holds (B367 < B366 implies ( B365 . B367 ) |= ( Evaluate (R15 , R30) ))) & ( B365 . B366 ) |= ( Evaluate (R16 , R30) ))))) implies (ex B368 being (inf_path of R25) st (( B368 . ( 0 ) ) = R26 & (ex B369 being (Element of ( NAT )) st ((for B370 being (Element of ( NAT )) holds (B370 < B369 implies ( B368 . B370 ) , R30 |= R15)) & ( B368 . B369 ) , R30 |= R16)))))
proof
given C253 being (inf_path of R25) such that
L1384: ( C253 . ( 0 ) ) = R26
and
L1385: (ex B371 being (Element of ( NAT )) st ((for B372 being (Element of ( NAT )) holds (B372 < B371 implies ( C253 . B372 ) |= ( Evaluate (R15 , R30) ))) & ( C253 . B371 ) |= ( Evaluate (R16 , R30) )));

take C253;
consider C254 being (Element of ( NAT )) such that L1386: (for B373 being (Element of ( NAT )) holds (B373 < C254 implies ( C253 . B373 ) |= ( Evaluate (R15 , R30) ))) and L1387: ( C253 . C254 ) |= ( Evaluate (R16 , R30) ) by L1385;
L1388: (for B374 being (Element of ( NAT )) holds (B374 < C254 implies ( C253 . B374 ) , R30 |= R15))
proof
let C255 being (Element of ( NAT ));
assume L1389: C255 < C254;
L1390: ( C253 . C255 ) |= ( Evaluate (R15 , R30) ) by L1389 , L1386;
thus L1391: thesis by L1390 , L1326;
end;
L1392: (( C253 . C254 ) |= ( Evaluate (R16 , R30) ) iff ( C253 . C254 ) , R30 |= R16) by L1326;
thus L1393: thesis by L1392 , L1384 , L1387 , L1388;
end;
L1394: ((ex B375 being (inf_path of R25) st (( B375 . ( 0 ) ) = R26 & (ex B376 being (Element of ( NAT )) st ((for B377 being (Element of ( NAT )) holds (B377 < B376 implies ( B375 . B377 ) , R30 |= R15)) & ( B375 . B376 ) , R30 |= R16)))) implies (ex B378 being (inf_path of R25) st (( B378 . ( 0 ) ) = R26 & (ex B379 being (Element of ( NAT )) st ((for B380 being (Element of ( NAT )) holds (B380 < B379 implies ( B378 . B380 ) |= ( Evaluate (R15 , R30) ))) & ( B378 . B379 ) |= ( Evaluate (R16 , R30) ))))))
proof
given C256 being (inf_path of R25) such that
L1395: ( C256 . ( 0 ) ) = R26
and
L1396: (ex B381 being (Element of ( NAT )) st ((for B382 being (Element of ( NAT )) holds (B382 < B381 implies ( C256 . B382 ) , R30 |= R15)) & ( C256 . B381 ) , R30 |= R16));

take C256;
consider C257 being (Element of ( NAT )) such that L1397: (for B383 being (Element of ( NAT )) holds (B383 < C257 implies ( C256 . B383 ) , R30 |= R15)) and L1398: ( C256 . C257 ) , R30 |= R16 by L1396;
L1399: (for B384 being (Element of ( NAT )) holds (B384 < C257 implies ( C256 . B384 ) |= ( Evaluate (R15 , R30) )))
proof
let C258 being (Element of ( NAT ));
assume L1400: C258 < C257;
L1401: ( C256 . C258 ) , R30 |= R15 by L1400 , L1397;
thus L1402: thesis by L1401 , L1326;
end;
L1403: (( C256 . C257 ) |= ( Evaluate (R16 , R30) ) iff ( C256 . C257 ) , R30 |= R16) by L1326;
thus L1404: thesis by L1403 , L1395 , L1398 , L1399;
end;
L1405: (R26 , R30 |= ( R15 EU R16 ) iff R26 |= ( Evaluate (( R15 EU R16 ) , R30) )) by L1326;
L1406: (R26 , R30 |= ( R15 EU R16 ) iff R26 |= ( ( Evaluate (R15 , R30) ) EU ( Evaluate (R16 , R30) ) )) by L1405 , L916;
thus L1407: thesis by L1406 , L1383 , L1394 , L1287;
end;
theorem
L1408: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R27 being (Element of R24) holds (ex B385 being (inf_path of R25) st ( B385 . ( 0 ) ) = R27))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R27 being (Element of R24);
consider C259 being (Function of ( NAT ) , R24) such that L1409: ( C259 . ( 0 ) ) = R27 and L1410: (for B386 being (Element of ( NAT )) holds [ ( C259 . B386 ) , ( C259 . ( B386 + 1 ) ) ] in R25) by L1002;
reconsider D62 = C259 as (inf_path of R25) by L1410 , L1010;
take D62;
thus L1411: thesis by L1409;
end;
theorem
L1412: (for R24 being non  empty set holds (for B387 being (Relation of R24 , R24) holds (B387 is  total iff (for B388 being set holds (B388 in R24 implies (ex B389 being set st (B389 in R24 & [ B388 , B389 ] in B387))))))) by L938 , L948;
definition
let C260 being non  empty set;
let C261 being  total (Relation of C260 , C260);
let C262 being (Element of C260);
let C263 being (inf_path of C261);
let C264 being set;
func PrePath (C264 , C262 , C263) -> (Element of C260) equals
:L1413: C262 if C264 = ( 0 ) otherwise ( C263 . ( k_nat ( ( k_nat C264 ) - 1 ) ) );
correctness;
end;
theorem
L1415: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R27 being (Element of R24) holds (for R28 being (Element of R24) holds ([ R27 , R28 ] in R25 implies (ex B390 being (inf_path of R25) st (( B390 . ( 0 ) ) = R27 & ( B390 . 1 ) = R28)))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R27 being (Element of R24);
let R28 being (Element of R24);
consider C265 being (inf_path of R25) such that L1416: ( C265 . ( 0 ) ) = R28 by L1408;
deffunc H31(set) = ( PrePath ($1 , R27 , C265) );
L1417: (for B391 being set holds (B391 in ( NAT ) implies H31(B391) in R24));
consider C266 being (Function of ( NAT ) , R24) such that L1418: (for B392 being set holds (B392 in ( NAT ) implies ( C266 . B392 ) = H31(B392))) from FUNCT_2:sch 2(L1417);
assume L1419: [ R27 , R28 ] in R25;
L1420: (for B393 being (Element of ( NAT )) holds [ ( C266 . B393 ) , ( C266 . ( B393 + 1 ) ) ] in R25)
proof
let C267 being (Element of ( NAT ));
set D63 = ( C267 + 1 );
set D64 = ( C267 - 1 );
per cases ;
suppose L1421: C267 = ( 0 );

L1422: ( k_nat ( ( k_nat D63 ) - 1 ) ) = ( k_nat ( 1 - 1 ) ) by L1421 , L9
.= ( 0 ) by L9;
L1423: ( C266 . C267 ) = H31(C267) by L1418
.= R27 by L1421 , L1413;
L1424: ( C266 . D63 ) = H31(D63) by L1418
.= R28 by L1416 , L1422 , L1413;
thus L1425: thesis by L1424 , L1419 , L1423;
end;
suppose L1426: C267 <> ( 0 );

reconsider D65 = D64 as (Element of ( NAT )) by L1426 , NAT_1:20;
L1427: ( C266 . D63 ) = H31(D63) by L1418
.= ( C265 . ( k_nat ( ( k_nat D63 ) - 1 ) ) ) by L1413
.= ( C265 . ( k_nat ( D63 - 1 ) ) ) by L9
.= ( C265 . ( D65 + 1 ) ) by L9;
L1428: ( C266 . C267 ) = H31(C267) by L1418
.= ( C265 . ( k_nat ( ( k_nat C267 ) - 1 ) ) ) by L1426 , L1413
.= ( C265 . ( k_nat ( C267 - 1 ) ) ) by L9
.= ( C265 . D65 ) by L9;
thus L1429: thesis by L1428 , L1427 , L1010;
end;
end;
reconsider D66 = C266 as (inf_path of R25) by L1420 , L1010;
L1431: ( D66 . ( 0 ) ) = H31(( 0 )) by L1418
.= R27 by L1413;
take D66;
L1432: ( D66 . 1 ) = H31(1) by L1418
.= ( C265 . ( k_nat ( ( k_nat 1 ) - 1 ) ) ) by L1413
.= ( C265 . ( k_nat ( 1 - 1 ) ) ) by L9
.= R28 by L1416 , L9;
thus L1433: thesis by L1432 , L1431;
end;
theorem
L1434: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R26 being (Element of R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B394 being (Assign of ( BASSModel (R25 , R29) )) holds (R26 |= ( EX B394 ) iff (ex B395 being (Element of R24) st ([ R26 , B395 ] in R25 & B395 |= B394))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R26 being (Element of R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C268 being (Assign of ( BASSModel (R25 , R29) ));
L1435: (R26 |= ( EX C268 ) implies (ex B396 being (Element of R24) st ([ R26 , B396 ] in R25 & B396 |= C268)))
proof
assume L1436: R26 |= ( EX C268 );
consider C269 being (inf_path of R25) such that L1437: ( C269 . ( 0 ) ) = R26 and L1438: ( C269 . 1 ) |= C268 by L1436 , L1243;
L1439: [ ( C269 . ( 0 ) ) , ( C269 . ( ( 0 ) + 1 ) ) ] in R25 by L1010;
thus L1440: thesis by L1439 , L1437 , L1438;
end;
L1441: ((ex B397 being (Element of R24) st ([ R26 , B397 ] in R25 & B397 |= C268)) implies R26 |= ( EX C268 ))
proof
given C270 being (Element of R24) such that
L1442: [ R26 , C270 ] in R25
and
L1443: C270 |= C268;

L1444: (ex B398 being (inf_path of R25) st (( B398 . ( 0 ) ) = R26 & ( B398 . 1 ) = C270)) by L1442 , L1415;
thus L1445: thesis by L1444 , L1443 , L1243;
end;
thus L1446: thesis by L1441 , L1435;
end;
definition
let C271 being non  empty set;
let C272 being  total (Relation of C271 , C271);
let C273 being (Subset of C271);
func Pred (C273 , C272) -> (Subset of C271) equals
{ B399 where B399 is (Element of C271) : (ex B400 being (Element of C271) st (B400 in C273 & [ B399 , B400 ] in C272)) };
coherence
proof
set D67 = { B401 where B401 is (Element of C271) : (ex B402 being (Element of C271) st (B402 in C273 & [ B401 , B402 ] in C272)) };
L1447: D67 c= C271
proof
let C274 being set;
assume L1448: C274 in D67;
L1449: (ex B403 being (Element of C271) st (C274 = B403 & (ex B404 being (Element of C271) st (B404 in C273 & [ B403 , B404 ] in C272)))) by L1448;
thus L1450: thesis by L1449;
end;
thus L1451: thesis by L1447;
end;
end;
definition
let C275 being non  empty set;
let C276 being  total (Relation of C275 , C275);
let C277 being non  empty (Subset of ( ModelSP C275 ));
let C278 being (Assign of ( BASSModel (C276 , C277) ));
func SIGMA C278 -> (Subset of C275) equals
{ B405 where B405 is (Element of C275) : B405 |= C278 };
correctness
proof
set D68 = { B406 where B406 is (Element of C275) : B406 |= C278 };
L1453: D68 c= C275
proof
let C279 being set;
assume L1454: C279 in D68;
L1455: (ex B407 being (Element of C275) st (C279 = B407 & B407 |= C278)) by L1454;
thus L1456: thesis by L1455;
end;
thus L1457: thesis by L1453;
end;
end;
L1459: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B408 being (Assign of ( BASSModel (R25 , R29) )) holds ( SIGMA B408 ) = { B409 where B409 is (Element of R24) : ( ( Fid (B408 , R24) ) . B409 ) = ( TRUE ) }))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C280 being (Assign of ( BASSModel (R25 , R29) ));
L1460: (for B410 being set holds (B410 in { B411 where B411 is (Element of R24) : ( ( Fid (C280 , R24) ) . B411 ) = ( TRUE ) } implies B410 in ( SIGMA C280 )))
proof
let C281 being set;
assume L1461: C281 in { B412 where B412 is (Element of R24) : ( ( Fid (C280 , R24) ) . B412 ) = ( TRUE ) };
consider C282 being (Element of R24) such that L1462: C281 = C282 and L1463: ( ( Fid (C280 , R24) ) . C282 ) = ( TRUE ) by L1461;
L1464: C282 |= C280 by L1463 , L1189;
thus L1465: thesis by L1464 , L1462;
end;
L1466: (for B413 being set holds (B413 in ( SIGMA C280 ) implies B413 in { B414 where B414 is (Element of R24) : ( ( Fid (C280 , R24) ) . B414 ) = ( TRUE ) }))
proof
let C283 being set;
assume L1467: C283 in ( SIGMA C280 );
consider C284 being (Element of R24) such that L1468: C283 = C284 and L1469: C284 |= C280 by L1467;
L1470: ( ( Fid (C280 , R24) ) . C284 ) = ( TRUE ) by L1469 , L1189;
thus L1471: thesis by L1470 , L1468;
end;
thus L1472: thesis by L1466 , L1460 , TARSKI:1;
end;
L1473: (for B415 being non  empty set holds (for B416 , B417 being (Function of B415 , ( BOOLEAN )) holds ({ B418 where B418 is (Element of B415) : ( B416 . B418 ) = ( TRUE ) } = { B419 where B419 is (Element of B415) : ( B417 . B419 ) = ( TRUE ) } implies B416 = B417)))
proof
let C285 being non  empty set;
let C286 , C287 being (Function of C285 , ( BOOLEAN ));
set D69 = { B420 where B420 is (Element of C285) : ( C286 . B420 ) = ( TRUE ) };
set D70 = { B421 where B421 is (Element of C285) : ( C287 . B421 ) = ( TRUE ) };
assume that
L1474: D69 = D70;
L1475: (for B422 being set holds (B422 in C285 implies ( C286 . B422 ) = ( C287 . B422 )))
proof
let C288 being set;
assume that
L1476: C288 in C285;
per cases ;
suppose L1477: C288 in D69;

L1478: (ex B423 being (Element of C285) st (B423 = C288 & ( C286 . B423 ) = ( TRUE ))) by L1477;
L1479: (ex B424 being (Element of C285) st (B424 = C288 & ( C287 . B424 ) = ( TRUE ))) by L1474 , L1477;
thus L1480: thesis by L1479 , L1478;
end;
suppose L1481: (not C288 in D69);

L1482: ( C286 . C288 ) = ( FALSE )
proof
assume L1483: ( C286 . C288 ) <> ( FALSE );
L1484: ( C286 . C288 ) in ( BOOLEAN ) by L1476 , FUNCT_2:5;
L1485: ( C286 . C288 ) = ( TRUE ) by L1484 , L1483 , TARSKI:def 2;
thus L1486: contradiction by L1485 , L1476 , L1481;
end;
L1487: ( C287 . C288 ) = ( FALSE )
proof
assume L1488: ( C287 . C288 ) <> ( FALSE );
L1489: ( C287 . C288 ) in ( BOOLEAN ) by L1476 , FUNCT_2:5;
L1490: ( C287 . C288 ) = ( TRUE ) by L1489 , L1488 , TARSKI:def 2;
thus L1491: contradiction by L1490 , L1474 , L1476 , L1481;
end;
thus L1492: thesis by L1487 , L1482;
end;
end;
thus L1494: thesis by L1475 , FUNCT_2:12;
end;
L1495: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B425 , B426 being (Assign of ( BASSModel (R25 , R29) )) holds (( Fid (B425 , R24) ) = ( Fid (B426 , R24) ) implies B425 = B426)))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C289 , C290 being (Assign of ( BASSModel (R25 , R29) ));
L1496: ( Fid (C289 , R24) ) = C289 by L1017;
thus L1497: thesis by L1496 , L1017;
end;
theorem
L1498: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B427 , B428 being (Assign of ( BASSModel (R25 , R29) )) holds (( SIGMA B427 ) = ( SIGMA B428 ) implies B427 = B428)))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C291 , C292 being (Assign of ( BASSModel (R25 , R29) ));
assume L1499: ( SIGMA C291 ) = ( SIGMA C292 );
L1500: ( SIGMA C291 ) = { B429 where B429 is (Element of R24) : ( ( Fid (C291 , R24) ) . B429 ) = ( TRUE ) } by L1459;
L1501: { B430 where B430 is (Element of R24) : ( ( Fid (C291 , R24) ) . B430 ) = ( TRUE ) } = { B431 where B431 is (Element of R24) : ( ( Fid (C292 , R24) ) . B431 ) = ( TRUE ) } by L1500 , L1499 , L1459;
thus L1502: thesis by L1501 , L1473 , L1495;
end;
definition
let C293 being non  empty set;
let C294 being  total (Relation of C293 , C293);
let C295 being non  empty (Subset of ( ModelSP C293 ));
let C296 being (Subset of C293);
func Tau (C296 , C294 , C295) -> (Assign of ( BASSModel (C294 , C295) )) means
:L1503: (for B432 being set holds (B432 in C293 implies ( ( Fid (it , C293) ) . B432 ) = ( ( chi (C296 , C293) ) . B432 )));
existence
proof
deffunc H32(set) = ( ( chi (C296 , C293) ) . $1 );
L1504: (for B433 being set holds (B433 in C293 implies H32(B433) in ( BOOLEAN )))
proof
let C297 being set;
assume that
L1505: C297 in C293;
per cases ;
suppose L1506: C297 in C296;

L1507: H32(C297) = 1 by L1506 , FUNCT_3:def 3;
thus L1508: thesis by L1507 , TARSKI:def 2;
end;
suppose L1509: (not C297 in C296);

L1510: H32(C297) = ( 0 ) by L1509 , L1505 , FUNCT_3:def 3;
thus L1511: thesis by L1510 , TARSKI:def 2;
end;
end;
consider C298 being (Function of C293 , ( BOOLEAN )) such that L1513: (for B434 being set holds (B434 in C293 implies ( C298 . B434 ) = H32(B434))) from FUNCT_2:sch 2(L1504);
reconsider D71 = C298 as (Assign of ( BASSModel (C294 , C295) )) by FUNCT_2:8;
take D71;
L1514: ( Fid (D71 , C293) ) = D71 by L1017;
thus L1515: thesis by L1514 , L1513;
end;
uniqueness
proof
let C299 , C300 being (Assign of ( BASSModel (C294 , C295) ));
assume that
L1516: (for B435 being set holds (B435 in C293 implies ( ( Fid (C299 , C293) ) . B435 ) = ( ( chi (C296 , C293) ) . B435 )))
and
L1517: (for B436 being set holds (B436 in C293 implies ( ( Fid (C300 , C293) ) . B436 ) = ( ( chi (C296 , C293) ) . B436 )));
L1518: (for B437 being set holds (B437 in C293 implies ( ( Fid (C299 , C293) ) . B437 ) = ( ( Fid (C300 , C293) ) . B437 )))
proof
let C301 being set;
assume that
L1519: C301 in C293;
L1520: ( ( Fid (C299 , C293) ) . C301 ) = ( ( chi (C296 , C293) ) . C301 ) by L1516 , L1519
.= ( ( Fid (C300 , C293) ) . C301 ) by L1517 , L1519;
thus L1521: thesis by L1520;
end;
thus L1522: thesis by L1518 , L1495 , FUNCT_2:12;
end;
end;
theorem
L1524: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B438 , B439 being (Subset of R24) holds (( Tau (B438 , R25 , R29) ) = ( Tau (B439 , R25 , R29) ) implies B438 = B439)))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C302 , C303 being (Subset of R24);
set D72 = ( Tau (C302 , R25 , R29) );
set D73 = ( Tau (C303 , R25 , R29) );
assume L1525: D72 = D73;
L1526: (for B440 being set holds (B440 in C303 implies B440 in C302))
proof
let C304 being set;
assume L1527: C304 in C303;
L1528: ( ( chi (C303 , R24) ) . C304 ) = 1 by L1527 , FUNCT_3:def 3;
L1529: ( ( Fid (D73 , R24) ) . C304 ) = ( TRUE ) by L1528 , L1527 , L1503;
L1530: ( ( chi (C302 , R24) ) . C304 ) = 1 by L1529 , L1525 , L1527 , L1503;
thus L1531: thesis by L1530 , FUNCT_3:36;
end;
L1532: (for B441 being set holds (B441 in C302 implies B441 in C303))
proof
let C305 being set;
assume L1533: C305 in C302;
L1534: ( ( chi (C302 , R24) ) . C305 ) = 1 by L1533 , FUNCT_3:def 3;
L1535: ( ( Fid (D72 , R24) ) . C305 ) = ( TRUE ) by L1534 , L1533 , L1503;
L1536: ( ( chi (C303 , R24) ) . C305 ) = 1 by L1535 , L1525 , L1533 , L1503;
thus L1537: thesis by L1536 , FUNCT_3:36;
end;
thus L1538: thesis by L1532 , L1526 , TARSKI:1;
end;
theorem
L1539: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B442 being (Assign of ( BASSModel (R25 , R29) )) holds ( Tau (( SIGMA B442 ) , R25 , R29) ) = B442))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C306 being (Assign of ( BASSModel (R25 , R29) ));
set D74 = ( SIGMA C306 );
set D75 = ( Tau (D74 , R25 , R29) );
L1540: D74 = { B443 where B443 is (Element of R24) : ( ( Fid (C306 , R24) ) . B443 ) = ( TRUE ) } by L1459;
L1541: (for B444 being set holds (B444 in R24 implies ( ( Fid (C306 , R24) ) . B444 ) = ( ( Fid (D75 , R24) ) . B444 )))
proof
let C307 being set;
assume L1542: C307 in R24;
reconsider D76 = C307 as (Element of R24) by L1542;
per cases ;
suppose L1543: D76 in D74;

L1544: ( ( Fid (D75 , R24) ) . D76 ) = ( ( chi (D74 , R24) ) . D76 ) by L1503
.= 1 by L1543 , FUNCT_3:def 3;
L1545: (ex B445 being (Element of R24) st (B445 = D76 & ( ( Fid (C306 , R24) ) . B445 ) = ( TRUE ))) by L1540 , L1543;
thus L1546: thesis by L1545 , L1544;
end;
suppose L1547: (not D76 in D74);

L1548: ( ( Fid (C306 , R24) ) . D76 ) = ( FALSE )
proof
assume L1549: ( ( Fid (C306 , R24) ) . D76 ) <> ( FALSE );
L1550: ( ( Fid (C306 , R24) ) . D76 ) = ( TRUE ) by L1549 , TARSKI:def 2;
thus L1551: contradiction by L1550 , L1540 , L1547;
end;
L1552: ( ( Fid (D75 , R24) ) . D76 ) = ( ( chi (D74 , R24) ) . D76 ) by L1503
.= ( 0 ) by L1547 , FUNCT_3:def 3;
thus L1553: thesis by L1552 , L1548;
end;
end;
thus L1555: thesis by L1541 , L1495 , FUNCT_2:12;
end;
theorem
L1556: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B446 being (Subset of R24) holds ( SIGMA ( Tau (B446 , R25 , R29) ) ) = B446))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C308 being (Subset of R24);
set D77 = ( Tau (C308 , R25 , R29) );
set D78 = ( SIGMA D77 );
L1557: D78 = { B447 where B447 is (Element of R24) : ( ( Fid (D77 , R24) ) . B447 ) = ( TRUE ) } by L1459;
L1558: (for B448 being set holds (B448 in D78 iff B448 in C308))
proof
let C309 being set;
thus L1559: (C309 in D78 implies C309 in C308)
proof
assume L1560: C309 in D78;
L1561: (ex B449 being (Element of R24) st (C309 = B449 & ( ( Fid (D77 , R24) ) . B449 ) = ( TRUE ))) by L1560 , L1557;
L1562: ( ( chi (C308 , R24) ) . C309 ) = ( TRUE ) by L1561 , L1503;
thus L1563: thesis by L1562 , FUNCT_3:36;
end;

assume L1564: C309 in C308;
L1565: ( ( Fid (D77 , R24) ) . C309 ) = ( ( chi (C308 , R24) ) . C309 ) by L1564 , L1503
.= 1 by L1564 , FUNCT_3:def 3;
thus L1566: thesis by L1565 , L1557 , L1564;
end;
thus L1567: thesis by L1558 , TARSKI:1;
end;
theorem
L1568: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B450 , B451 being (Assign of ( BASSModel (R25 , R29) )) holds (( SIGMA ( 'not' B450 ) ) = ( R24 \ ( SIGMA B450 ) ) & ( SIGMA ( B450 '&' B451 ) ) = ( ( SIGMA B450 ) /\ ( SIGMA B451 ) ) & ( SIGMA ( B450 'or' B451 ) ) = ( ( SIGMA B450 ) \/ ( SIGMA B451 ) ))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C310 , C311 being (Assign of ( BASSModel (R25 , R29) ));
L1569: (for B452 being set holds (B452 in ( SIGMA ( 'not' C310 ) ) iff B452 in ( R24 \ ( SIGMA C310 ) )))
proof
let C312 being set;
L1570: (C312 in ( SIGMA ( 'not' C310 ) ) implies C312 in ( R24 \ ( SIGMA C310 ) ))
proof
assume L1571: C312 in ( SIGMA ( 'not' C310 ) );
L1572: (ex B453 being (Element of R24) st (B453 = C312 & B453 |= ( 'not' C310 ))) by L1571;
reconsider D79 = C312 as (Element of R24) by L1571;
L1573: (not D79 in ( SIGMA C310 ))
proof
assume L1574: D79 in ( SIGMA C310 );
L1575: (ex B454 being (Element of R24) st (B454 = D79 & B454 |= C310)) by L1574;
thus L1576: contradiction by L1575 , L1572 , L1206;
end;
thus L1577: thesis by L1573 , XBOOLE_0:def 5;
end;
L1578: (C312 in ( R24 \ ( SIGMA C310 ) ) implies C312 in ( SIGMA ( 'not' C310 ) ))
proof
assume L1579: C312 in ( R24 \ ( SIGMA C310 ) );
reconsider D80 = C312 as (Element of R24) by L1579;
L1580: (not D80 in ( SIGMA C310 )) by L1579 , XBOOLE_0:def 5;
L1581: D80 |/= C310 by L1580;
L1582: D80 |= ( 'not' C310 ) by L1581 , L1206;
thus L1583: thesis by L1582;
end;
thus L1584: thesis by L1578 , L1570;
end;
L1585: (for B455 being set holds (B455 in ( SIGMA ( C310 'or' C311 ) ) iff B455 in ( ( SIGMA C310 ) \/ ( SIGMA C311 ) )))
proof
let C313 being set;
L1586: (C313 in ( ( SIGMA C310 ) \/ ( SIGMA C311 ) ) implies C313 in ( SIGMA ( C310 'or' C311 ) ))
proof
assume L1587: C313 in ( ( SIGMA C310 ) \/ ( SIGMA C311 ) );
per cases  by L1587 , XBOOLE_0:def 3;
suppose L1588: C313 in ( SIGMA C310 );

L1589: (ex B456 being (Element of R24) st (B456 = C313 & B456 |= C310)) by L1588;
reconsider D81 = C313 as (Element of R24) by L1588;
L1590: D81 |= ( C310 'or' C311 ) by L1589 , L1322;
thus L1591: thesis by L1590;
end;
suppose L1592: C313 in ( SIGMA C311 );

L1593: (ex B457 being (Element of R24) st (B457 = C313 & B457 |= C311)) by L1592;
reconsider D82 = C313 as (Element of R24) by L1592;
L1594: D82 |= ( C310 'or' C311 ) by L1593 , L1322;
thus L1595: thesis by L1594;
end;
end;
L1597: (C313 in ( SIGMA ( C310 'or' C311 ) ) implies C313 in ( ( SIGMA C310 ) \/ ( SIGMA C311 ) ))
proof
assume L1598: C313 in ( SIGMA ( C310 'or' C311 ) );
L1599: (ex B458 being (Element of R24) st (B458 = C313 & B458 |= ( C310 'or' C311 ))) by L1598;
reconsider D83 = C313 as (Element of R24) by L1598;
per cases  by L1599 , L1322;
suppose L1600: D83 |= C310;

L1601: D83 in ( SIGMA C310 ) by L1600;
thus L1602: thesis by L1601 , XBOOLE_0:def 3;
end;
suppose L1603: D83 |= C311;

L1604: D83 in ( SIGMA C311 ) by L1603;
thus L1605: thesis by L1604 , XBOOLE_0:def 3;
end;
end;
thus L1607: thesis by L1597 , L1586;
end;
L1608: (for B459 being set holds (B459 in ( SIGMA ( C310 '&' C311 ) ) iff B459 in ( ( SIGMA C310 ) /\ ( SIGMA C311 ) )))
proof
let C314 being set;
thus L1609: (C314 in ( SIGMA ( C310 '&' C311 ) ) implies C314 in ( ( SIGMA C310 ) /\ ( SIGMA C311 ) ))
proof
assume L1610: C314 in ( SIGMA ( C310 '&' C311 ) );
L1611: (ex B460 being (Element of R24) st (B460 = C314 & B460 |= ( C310 '&' C311 ))) by L1610;
reconsider D84 = C314 as (Element of R24) by L1610;
L1612: D84 |= C311 by L1611 , L1223;
L1613: D84 in ( SIGMA C311 ) by L1612;
L1614: D84 |= C310 by L1611 , L1223;
L1615: D84 in ( SIGMA C310 ) by L1614;
thus L1616: thesis by L1615 , L1613 , XBOOLE_0:def 4;
end;

assume L1617: C314 in ( ( SIGMA C310 ) /\ ( SIGMA C311 ) );
L1618: C314 in ( SIGMA C311 ) by L1617 , XBOOLE_0:def 4;
L1619: C314 in ( SIGMA C310 ) by L1617 , XBOOLE_0:def 4;
L1620: (ex B461 being (Element of R24) st (B461 = C314 & B461 |= C310)) by L1619;
reconsider D85 = C314 as (Element of R24) by L1617;
L1621: (ex B462 being (Element of R24) st (B462 = D85 & B462 |= C311)) by L1618;
L1622: D85 |= ( C310 '&' C311 ) by L1621 , L1620 , L1223;
thus L1623: thesis by L1622;
end;
thus L1624: thesis by L1608 , L1569 , L1585 , TARSKI:1;
end;
theorem
L1625: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B463 , B464 being (Subset of R24) holds (B463 c= B464 implies (for B465 being (Element of R24) holds (B465 |= ( Tau (B463 , R25 , R29) ) implies B465 |= ( Tau (B464 , R25 , R29) ))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C315 , C316 being (Subset of R24);
set D86 = ( Tau (C315 , R25 , R29) );
set D87 = ( Tau (C316 , R25 , R29) );
assume L1626: C315 c= C316;
let C317 being (Element of R24);
assume L1627: C317 |= D86;
L1628: ( ( Fid (D86 , R24) ) . C317 ) = ( TRUE ) by L1627 , L1189;
L1629: ( ( chi (C315 , R24) ) . C317 ) = 1 by L1628 , L1503;
L1630: C317 in C315 by L1629 , FUNCT_3:def 3;
L1631: ( ( chi (C316 , R24) ) . C317 ) = 1 by L1630 , L1626 , FUNCT_3:def 3;
L1632: ( ( Fid (D87 , R24) ) . C317 ) = ( TRUE ) by L1631 , L1503;
thus L1633: thesis by L1632 , L1189;
end;
theorem
L1634: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B466 , B467 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B468 being (Element of R24) holds (B468 |= B466 implies B468 |= B467)) implies ( SIGMA B466 ) c= ( SIGMA B467 ))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C318 , C319 being (Assign of ( BASSModel (R25 , R29) ));
assume L1635: (for B469 being (Element of R24) holds (B469 |= C318 implies B469 |= C319));
let C320 being set;
assume L1636: C320 in ( SIGMA C318 );
consider C321 being (Element of R24) such that L1637: C320 = C321 and L1638: C321 |= C318 by L1636;
L1639: C321 |= C319 by L1635 , L1638;
thus L1640: thesis by L1639 , L1637;
end;
definition
let C322 being non  empty set;
let C323 being  total (Relation of C322 , C322);
let C324 being non  empty (Subset of ( ModelSP C322 ));
let C325 , C326 being (Assign of ( BASSModel (C323 , C324) ));
func Fax (C325 , C326) -> (Assign of ( BASSModel (C323 , C324) )) equals
( C325 '&' ( EX C326 ) );
correctness;
end;
theorem
L1642: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B470 , B471 , B472 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B473 being (Element of R24) holds (B473 |= B471 implies B473 |= B472)) implies (for B474 being (Element of R24) holds (B474 |= ( Fax (B470 , B471) ) implies B474 |= ( Fax (B470 , B472) ))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C327 , C328 , C329 being (Assign of ( BASSModel (R25 , R29) ));
assume L1643: (for B475 being (Element of R24) holds (B475 |= C328 implies B475 |= C329));
let C330 being (Element of R24);
assume L1644: C330 |= ( Fax (C327 , C328) );
L1645: C330 |= ( EX C328 ) by L1644 , L1223;
consider C331 being (inf_path of R25) such that L1646: ( C331 . ( 0 ) ) = C330 and L1647: ( C331 . 1 ) |= C328 by L1645 , L1243;
L1648: ( C331 . 1 ) |= C329 by L1643 , L1647;
L1649: C330 |= ( EX C329 ) by L1648 , L1646 , L1243;
L1650: C330 |= C327 by L1644 , L1223;
thus L1651: thesis by L1650 , L1649 , L1223;
end;
definition
let C332 being non  empty set;
let C333 being  total (Relation of C332 , C332);
let C334 being non  empty (Subset of ( ModelSP C332 ));
let C335 being (Assign of ( BASSModel (C333 , C334) ));
let C336 being (Subset of C332);
func SigFaxTau (C335 , C336 , C333 , C334) -> (Subset of C332) equals
( SIGMA ( Fax (C335 , ( Tau (C336 , C333 , C334) )) ) );
coherence;
end;
theorem
L1653: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B476 being (Assign of ( BASSModel (R25 , R29) )) holds (for B477 , B478 being (Subset of R24) holds (B477 c= B478 implies ( SigFaxTau (B476 , B477 , R25 , R29) ) c= ( SigFaxTau (B476 , B478 , R25 , R29) )))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C337 being (Assign of ( BASSModel (R25 , R29) ));
let C338 , C339 being (Subset of R24);
assume L1654: C338 c= C339;
L1655: (for B479 being (Element of R24) holds (B479 |= ( Tau (C338 , R25 , R29) ) implies B479 |= ( Tau (C339 , R25 , R29) ))) by L1654 , L1625;
L1656: (for B480 being (Element of R24) holds (B480 |= ( Fax (C337 , ( Tau (C338 , R25 , R29) )) ) implies B480 |= ( Fax (C337 , ( Tau (C339 , R25 , R29) )) ))) by L1655 , L1642;
thus L1657: thesis by L1656 , L1634;
end;
definition
let C340 being non  empty set;
let C341 being  total (Relation of C340 , C340);
let C342 being (inf_path of C341);
let C343 being (Element of ( NAT ));
func PathShift (C342 , C343) -> (inf_path of C341) means
:L1658: (for B481 being (Element of ( NAT )) holds ( it . B481 ) = ( C342 . ( B481 + C343 ) ));
existence
proof
deffunc H33(set) = ( C342 . ( ( k_nat $1 ) + C343 ) );
L1659: (for B482 being set holds (B482 in ( NAT ) implies H33(B482) in C340));
consider C344 being (Function of ( NAT ) , C340) such that L1660: (for B483 being set holds (B483 in ( NAT ) implies ( C344 . B483 ) = H33(B483))) from FUNCT_2:sch 2(L1659);
L1661: (for B484 being (Element of ( NAT )) holds ( C344 . B484 ) = ( C342 . ( B484 + C343 ) ))
proof
let C345 being (Element of ( NAT ));
L1662: H33(C345) = ( C342 . ( C345 + C343 ) ) by L9;
thus L1663: thesis by L1662 , L1660;
end;
L1664: (for B485 being (Element of ( NAT )) holds [ ( C344 . B485 ) , ( C344 . ( B485 + 1 ) ) ] in C341)
proof
let C346 being (Element of ( NAT ));
set D88 = ( C346 + 1 );
set D89 = ( C346 + C343 );
L1665: ( C344 . ( C346 + 1 ) ) = ( C342 . ( D88 + C343 ) ) by L1661
.= ( C342 . ( D89 + 1 ) );
L1666: ( C344 . C346 ) = ( C342 . D89 ) by L1661;
thus L1667: thesis by L1666 , L1665 , L1010;
end;
reconsider D90 = C344 as (inf_path of C341) by L1664 , L1010;
take D90;
thus L1668: thesis by L1661;
end;
uniqueness
proof
L1669: (for B486 , B487 being (inf_path of C341) holds (((for B488 being (Element of ( NAT )) holds ( B486 . B488 ) = ( C342 . ( B488 + C343 ) )) & (for B489 being (Element of ( NAT )) holds ( B487 . B489 ) = ( C342 . ( B489 + C343 ) ))) implies B486 = B487))
proof
let C347 , C348 being (inf_path of C341);
assume that
L1670: (for B490 being (Element of ( NAT )) holds ( C347 . B490 ) = ( C342 . ( B490 + C343 ) ))
and
L1671: (for B491 being (Element of ( NAT )) holds ( C348 . B491 ) = ( C342 . ( B491 + C343 ) ));
L1672: (for B492 being set holds (B492 in ( NAT ) implies ( C347 . B492 ) = ( C348 . B492 )))
proof
let C349 being set;
assume L1673: C349 in ( NAT );
reconsider D91 = C349 as (Element of ( NAT )) by L1673;
L1674: ( C347 . D91 ) = ( C342 . ( D91 + C343 ) ) by L1670
.= ( C348 . D91 ) by L1671;
thus L1675: thesis by L1674;
end;
thus L1676: thesis by L1672 , FUNCT_2:12;
end;
thus L1677: thesis by L1669;
end;
end;
definition
let C350 being non  empty set;
let C351 being  total (Relation of C350 , C350);
let C352 , C353 being (inf_path of C351);
let C354 , C355 being (Element of ( NAT ));
func PathChange (C352 , C353 , C355 , C354) -> set equals
:L1679: ( C352 . C354 ) if C354 < C355 otherwise ( C353 . ( C354 - C355 ) );
correctness;
end;
definition
let C356 being non  empty set;
let C357 being  total (Relation of C356 , C356);
let C358 , C359 being (inf_path of C357);
let C360 being (Element of ( NAT ));
func PathConc (C358 , C359 , C360) -> (Function of ( NAT ) , C356) means
:L1681: (for B493 being (Element of ( NAT )) holds ( it . B493 ) = ( PathChange (C358 , C359 , C360 , B493) ));
existence
proof
deffunc H34(set) = ( PathChange (C358 , C359 , C360 , ( k_nat $1 )) );
L1682: (for B494 being set holds (B494 in ( NAT ) implies H34(B494) in C356))
proof
let C361 being set;
assume L1683: C361 in ( NAT );
reconsider D92 = C361 as (Element of ( NAT )) by L1683;
set D93 = ( PathChange (C358 , C359 , C360 , D92) );
L1684: H34(D92) = ( PathChange (C358 , C359 , C360 , D92) ) by L9;
per cases ;
suppose L1685: D92 < C360;

L1686: D93 = ( C358 . D92 ) by L1685 , L1679;
thus L1687: thesis by L1686 , L1684;
end;
suppose L1688: (not D92 < C360);

set D94 = ( D92 - C360 );
reconsider D95 = D94 as (Element of ( NAT )) by L1688 , NAT_1:21;
L1689: D93 = ( C359 . D95 ) by L1688 , L1679;
thus L1690: thesis by L1689 , L1684;
end;
end;
consider C362 being (Function of ( NAT ) , C356) such that L1692: (for B495 being set holds (B495 in ( NAT ) implies ( C362 . B495 ) = H34(B495))) from FUNCT_2:sch 2(L1682);
take C362;
let C363 being (Element of ( NAT ));
L1693: ( k_nat C363 ) = C363 by L9;
thus L1694: thesis by L1693 , L1692;
end;
uniqueness
proof
let C364 , C365 being (Function of ( NAT ) , C356);
assume that
L1695: (for B496 being (Element of ( NAT )) holds ( C364 . B496 ) = ( PathChange (C358 , C359 , C360 , B496) ))
and
L1696: (for B497 being (Element of ( NAT )) holds ( C365 . B497 ) = ( PathChange (C358 , C359 , C360 , B497) ));
L1697: (for B498 being set holds (B498 in ( NAT ) implies ( C364 . B498 ) = ( C365 . B498 )))
proof
let C366 being set;
assume L1698: C366 in ( NAT );
reconsider D96 = C366 as (Element of ( NAT )) by L1698;
L1699: ( C364 . D96 ) = ( PathChange (C358 , C359 , C360 , D96) ) by L1695
.= ( C365 . D96 ) by L1696;
thus L1700: thesis by L1699;
end;
thus L1701: thesis by L1697 , FUNCT_2:12;
end;
end;
theorem
L1703: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for B499 , B500 being (inf_path of R25) holds (for B501 being (Element of ( NAT )) holds (( B499 . B501 ) = ( B500 . ( 0 ) ) implies ( PathConc (B499 , B500 , B501) ) is (inf_path of R25))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let C367 , C368 being (inf_path of R25);
let C369 being (Element of ( NAT ));
set D97 = ( PathConc (C367 , C368 , C369) );
assume L1704: ( C367 . C369 ) = ( C368 . ( 0 ) );
L1705: (for B502 being (Element of ( NAT )) holds [ ( D97 . B502 ) , ( D97 . ( B502 + 1 ) ) ] in R25)
proof
let C370 being (Element of ( NAT ));
set D98 = ( C370 + 1 );
per cases  by XXREAL_0:1;
suppose L1706: D98 < C369;

L1707: C370 < C369 by L1706 , NAT_1:13;
L1708: ( D97 . C370 ) = ( PathChange (C367 , C368 , C369 , C370) ) by L1681
.= ( C367 . C370 ) by L1707 , L1679;
L1709: ( D97 . D98 ) = ( PathChange (C367 , C368 , C369 , D98) ) by L1681
.= ( C367 . D98 ) by L1706 , L1679;
thus L1710: thesis by L1709 , L1708 , L1010;
end;
suppose L1711: D98 = C369;

L1712: C370 < C369 by L1711 , NAT_1:13;
L1713: ( D97 . C370 ) = ( PathChange (C367 , C368 , C369 , C370) ) by L1681
.= ( C367 . C370 ) by L1712 , L1679;
L1714: ( D97 . D98 ) = ( PathChange (C367 , C368 , C369 , D98) ) by L1681
.= ( C368 . ( D98 - C369 ) ) by L1711 , L1679
.= ( C367 . D98 ) by L1704 , L1711;
thus L1715: thesis by L1714 , L1713 , L1010;
end;
suppose L1716: C369 < D98;

L1717: C369 <= C370 by L1716 , NAT_1:13;
reconsider D99 = ( C370 - C369 ) as (Element of ( NAT )) by L1717 , NAT_1:21;
L1718: ( D97 . D98 ) = ( PathChange (C367 , C368 , C369 , D98) ) by L1681
.= ( C368 . ( D98 - C369 ) ) by L1716 , L1679
.= ( C368 . ( D99 + 1 ) );
L1719: ( D97 . C370 ) = ( PathChange (C367 , C368 , C369 , C370) ) by L1681
.= ( C368 . D99 ) by L1717 , L1679;
thus L1720: thesis by L1719 , L1718 , L1010;
end;
end;
thus L1722: thesis by L1705 , L1010;
end;
theorem
L1723: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B503 being (Assign of ( BASSModel (R25 , R29) )) holds (for B504 being (Element of R24) holds (B504 |= ( EG B503 ) iff B504 |= ( Fax (B503 , ( EG B503 )) )))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C371 being (Assign of ( BASSModel (R25 , R29) ));
let C372 being (Element of R24);
set D100 = ( EG C371 );
thus L1724: (C372 |= ( EG C371 ) implies C372 |= ( Fax (C371 , ( EG C371 )) ))
proof
set D101 = ( EG C371 );
assume L1725: C372 |= ( EG C371 );
consider C373 being (inf_path of R25) such that L1726: ( C373 . ( 0 ) ) = C372 and L1727: (for B505 being (Element of ( NAT )) holds ( C373 . B505 ) |= C371) by L1725 , L1262;
set D102 = ( PathShift (C373 , 1) );
L1728: (for B506 being (Element of ( NAT )) holds ( D102 . B506 ) |= C371)
proof
let C374 being (Element of ( NAT ));
set D103 = ( C374 + 1 );
L1729: ( D102 . C374 ) = ( C373 . D103 ) by L1658;
thus L1730: thesis by L1729 , L1727;
end;
L1731: ( C373 . ( ( 0 ) + 1 ) ) = ( D102 . ( 0 ) ) by L1658;
L1732: ( C373 . 1 ) |= D101 by L1731 , L1728 , L1262;
L1733: C372 |= ( EX D101 ) by L1732 , L1726 , L1243;
L1734: C372 |= C371 by L1726 , L1727;
thus L1735: thesis by L1734 , L1733 , L1223;
end;

assume L1736: C372 |= ( Fax (C371 , D100) );
L1737: C372 |= ( EX D100 ) by L1736 , L1223;
consider C375 being (inf_path of R25) such that L1738: ( C375 . ( 0 ) ) = C372 and L1739: ( C375 . 1 ) |= D100 by L1737 , L1243;
consider C376 being (inf_path of R25) such that L1740: ( C376 . ( 0 ) ) = ( C375 . 1 ) and L1741: (for B507 being (Element of ( NAT )) holds ( C376 . B507 ) |= C371) by L1739 , L1262;
set D104 = ( PathConc (C375 , C376 , 1) );
reconsider D105 = D104 as (inf_path of R25) by L1740 , L1703;
L1742: ( D105 . ( 0 ) ) = ( PathChange (C375 , C376 , 1 , ( 0 )) ) by L1681
.= C372 by L1738 , L1679;
L1743: (for B508 being (Element of ( NAT )) holds ( D105 . B508 ) |= C371)
proof
let C377 being (Element of ( NAT ));
per cases ;
suppose L1744: C377 < 1;

L1745: C377 = ( 0 )
proof
assume L1746: C377 <> ( 0 );
L1747: C377 < ( ( 0 ) + 1 ) by L1744;
thus L1748: contradiction by L1747 , L1746 , NAT_1:22;
end;
thus L1749: thesis by L1745 , L1736 , L1742 , L1223;
end;
suppose L1750: (not C377 < 1);

reconsider D106 = ( C377 - 1 ) as (Element of ( NAT )) by L1750 , NAT_1:21;
L1751: ( D105 . C377 ) = ( PathChange (C375 , C376 , 1 , C377) ) by L1681
.= ( C376 . D106 ) by L1750 , L1679;
thus L1752: thesis by L1751 , L1741;
end;
end;
thus L1754: thesis by L1743 , L1742 , L1262;
end;
theorem
L1755: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B509 being (Assign of ( BASSModel (R25 , R29) )) holds (for B510 being (Element of R24) holds (B510 |= B509 implies ((for B511 being (Element of R24) holds (B511 |= B509 implies B511 |= ( EX B509 ))) implies (ex B512 being (inf_path of R25) st (( B512 . ( 0 ) ) = B510 & (for B513 being (Element of ( NAT )) holds ( B512 . B513 ) |= B509))))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C378 being (Assign of ( BASSModel (R25 , R29) ));
let C379 being (Element of R24);
assume that
L1756: C379 |= C378;
deffunc H35(set) = { B514 where B514 is (Element of R24) : [ $1 , B514 ] in R25 };
assume L1757: (for B515 being (Element of R24) holds (B515 |= C378 implies B515 |= ( EX C378 )));
L1758: (for B516 being set holds (B516 in ( BOOL R24 ) implies B516 <> ( {} ))) by ORDERS_1:1;
consider C380 being Function such that L1759: ( dom C380 ) = ( BOOL R24 ) and L1760: (for B517 being set holds (B517 in ( BOOL R24 ) implies ( C380 . B517 ) in B517)) by L1758 , FUNCT_1:111;
deffunc H36(set) = ( UnivF (( H35($1) /\ ( SIGMA C378 ) ) , C380 , C379) );
L1761: (for B518 being set holds (B518 in R24 implies H36(B518) in R24))
proof
let C381 being set;
assume that
L1762: C381 in R24;
set D107 = ( H35(C381) /\ ( SIGMA C378 ) );
per cases ;
suppose L1763: D107 in ( dom C380 );

L1764: H36(C381) = ( C380 . D107 ) by L1763 , L11;
L1765: H36(C381) in D107 by L1764 , L1759 , L1760 , L1763;
L1766: H36(C381) in H35(C381) by L1765 , XBOOLE_0:def 4;
L1767: (ex B519 being (Element of R24) st (B519 = H36(C381) & [ C381 , B519 ] in R25)) by L1766;
thus L1768: thesis by L1767;
end;
suppose L1769: (not D107 in ( dom C380 ));

L1770: H36(C381) = C379 by L1769 , L11;
thus L1771: thesis by L1770;
end;
end;
consider C382 being (Function of R24 , R24) such that L1773: (for B520 being set holds (B520 in R24 implies ( C382 . B520 ) = H36(B520))) from FUNCT_2:sch 2(L1761);
deffunc H37(set) = ( ( C382 |** ( k_nat $1 ) ) . C379 );
L1774: (for B521 being set holds (B521 in ( NAT ) implies H37(B521) in R24));
consider C383 being (Function of ( NAT ) , R24) such that L1775: (for B522 being set holds (B522 in ( NAT ) implies ( C383 . B522 ) = H37(B522))) from FUNCT_2:sch 2(L1774);
L1776: ( C383 . ( 0 ) ) = H37(( 0 )) by L1775
.= ( ( C382 |** ( 0 ) ) . C379 ) by L9
.= ( ( id R24 ) . C379 ) by FUNCT_7:84
.= C379 by FUNCT_1:18;
L1777: C379 in R24;
L1778: (for B523 being (Element of ( NAT )) holds ([ ( C383 . B523 ) , ( C383 . ( B523 + 1 ) ) ] in R25 & ( C383 . B523 ) |= C378))
proof
defpred S11[ (Element of ( NAT )) ] means ([ ( C383 . $1 ) , ( C383 . ( $1 + 1 ) ) ] in R25 & ( C383 . $1 ) |= C378);
L1779: (for B524 being (Element of ( NAT )) holds (S11[ B524 ] implies S11[ ( B524 + 1 ) ]))
proof
let C384 being (Element of ( NAT ));
set D108 = ( C384 + 1 );
set D109 = ( D108 + 1 );
set D110 = ( C383 . C384 );
set D111 = ( C383 . D108 );
set D112 = ( C383 . D109 );
set D113 = ( H35(D110) /\ ( SIGMA C378 ) );
set D114 = ( H35(D111) /\ ( SIGMA C378 ) );
L1780: C379 in ( dom ( C382 |** C384 ) ) by L1777 , FUNCT_2:def 1;
assume L1781: S11[ C384 ];
L1782: D110 |= ( EX C378 ) by L1781 , L1757;
consider C385 being (inf_path of R25) such that L1783: ( C385 . ( 0 ) ) = D110 and L1784: ( C385 . 1 ) |= C378 by L1782 , L1243;
set D115 = ( C385 . 1 );
L1785: [ ( C385 . ( 0 ) ) , ( C385 . ( ( 0 ) + 1 ) ) ] in R25 by L1010;
L1786: D115 in H35(D110) by L1785 , L1783;
L1787: D115 in ( SIGMA C378 ) by L1784;
L1788: D113 <> ( {} ) by L1787 , L1786 , XBOOLE_0:def 4;
L1789: (not D113 in { ( {} ) }) by L1788 , TARSKI:def 1;
L1790: D113 in ( ( bool R24 ) \ { ( {} ) } ) by L1789 , XBOOLE_0:def 5;
L1791: D113 in ( BOOL R24 ) by L1790 , ORDERS_1:def 2;
L1792: D113 in ( dom C380 ) by L1759 , L1790 , ORDERS_1:def 2;
L1793: D111 = H37(D108) by L1775
.= ( ( C382 |** D108 ) . C379 ) by L9
.= ( ( C382 * ( C382 |** C384 ) ) . C379 ) by FUNCT_7:71
.= ( C382 . ( ( C382 |** C384 ) . C379 ) ) by L1780 , FUNCT_1:13
.= ( C382 . H37(C384) ) by L9
.= ( C382 . D110 ) by L1775
.= H36(D110) by L1773
.= ( C380 . D113 ) by L1792 , L11;
L1794: D111 in D113 by L1793 , L1760 , L1791;
L1795: D111 in ( SIGMA C378 ) by L1794 , XBOOLE_0:def 4;
L1796: (ex B525 being (Element of R24) st (B525 = D111 & B525 |= C378)) by L1795;
L1797: D111 |= ( EX C378 ) by L1796 , L1757;
consider C386 being (inf_path of R25) such that L1798: ( C386 . ( 0 ) ) = D111 and L1799: ( C386 . 1 ) |= C378 by L1797 , L1243;
set D116 = ( C386 . 1 );
L1800: [ ( C386 . ( 0 ) ) , ( C386 . ( ( 0 ) + 1 ) ) ] in R25 by L1010;
L1801: D116 in H35(D111) by L1800 , L1798;
L1802: D116 in ( SIGMA C378 ) by L1799;
L1803: D116 in D114 by L1802 , L1801 , XBOOLE_0:def 4;
L1804: (not D114 in { ( {} ) }) by L1803 , TARSKI:def 1;
L1805: D114 in ( ( bool R24 ) \ { ( {} ) } ) by L1804 , XBOOLE_0:def 5;
L1806: D114 in ( BOOL R24 ) by L1805 , ORDERS_1:def 2;
L1807: C379 in ( dom ( C382 |** D108 ) ) by L1777 , FUNCT_2:def 1;
L1808: D114 in ( dom C380 ) by L1759 , L1805 , ORDERS_1:def 2;
L1809: D112 = H37(D109) by L1775
.= ( ( C382 |** D109 ) . C379 ) by L9
.= ( ( C382 * ( C382 |** D108 ) ) . C379 ) by FUNCT_7:71
.= ( C382 . ( ( C382 |** D108 ) . C379 ) ) by L1807 , FUNCT_1:13
.= ( C382 . H37(D108) ) by L9
.= ( C382 . D111 ) by L1775
.= H36(D111) by L1773
.= ( C380 . D114 ) by L1808 , L11;
L1810: D112 in D114 by L1809 , L1760 , L1806;
L1811: D112 in H35(D111) by L1810 , XBOOLE_0:def 4;
L1812: (ex B526 being (Element of R24) st (B526 = D112 & [ D111 , B526 ] in R25)) by L1811;
thus L1813: thesis by L1812 , L1796;
end;
L1814: S11[ ( 0 ) ]
proof
set D117 = ( H35(C379) /\ ( SIGMA C378 ) );
set D118 = ( C380 . D117 );
L1815: C379 |= ( EX C378 ) by L1756 , L1757;
consider C387 being (inf_path of R25) such that L1816: ( C387 . ( 0 ) ) = C379 and L1817: ( C387 . 1 ) |= C378 by L1815 , L1243;
set D119 = ( C387 . 1 );
L1818: [ ( C387 . ( 0 ) ) , ( C387 . ( ( 0 ) + 1 ) ) ] in R25 by L1010;
L1819: D119 in H35(C379) by L1818 , L1816;
L1820: D119 in ( SIGMA C378 ) by L1817;
L1821: D117 <> ( {} ) by L1820 , L1819 , XBOOLE_0:def 4;
L1822: (not D117 in { ( {} ) }) by L1821 , TARSKI:def 1;
L1823: D117 in ( ( bool R24 ) \ { ( {} ) } ) by L1822 , XBOOLE_0:def 5;
L1824: D117 in ( dom C380 ) by L1823 , L1759 , ORDERS_1:def 2;
L1825: D117 in ( BOOL R24 ) by L1823 , ORDERS_1:def 2;
L1826: D118 in D117 by L1825 , L1760;
L1827: D118 in H35(C379) by L1826 , XBOOLE_0:def 4;
consider C388 being (Element of R24) such that L1828: D118 = C388 and L1829: [ C379 , C388 ] in R25 by L1827;
L1830: C388 in ( SIGMA C378 ) by L1826 , L1828 , XBOOLE_0:def 4;
consider C389 being (Element of R24) such that L1831: C388 = C389 and L1832: C389 |= C378 by L1830;
L1833: ( C383 . 1 ) = H37(1) by L1775
.= ( ( C382 |** 1 ) . C379 ) by L9
.= ( C382 . C379 ) by FUNCT_7:70
.= H36(C379) by L1773
.= C389 by L1824 , L1828 , L1831 , L11;
thus L1834: thesis by L1833 , L1756 , L1776 , L1829 , L1831;
end;
L1835: (for B527 being (Element of ( NAT )) holds S11[ B527 ]) from NAT_1:sch 1(L1814 , L1779);
thus L1836: thesis by L1835;
end;
reconsider D120 = C383 as (inf_path of R25) by L1778 , L1010;
take D120;
thus L1837: thesis by L1776 , L1778;
end;
theorem
L1838: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B528 , B529 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B530 being (Element of R24) holds (B530 |= B529 iff B530 |= ( Fax (B528 , B529) ))) implies (for B531 being (Element of R24) holds (B531 |= B529 implies B531 |= ( EG B528 ))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C390 , C391 being (Assign of ( BASSModel (R25 , R29) ));
assume L1839: (for B532 being (Element of R24) holds (B532 |= C391 iff B532 |= ( Fax (C390 , C391) )));
L1840: (for B533 being (Element of R24) holds (B533 |= C391 implies B533 |= ( EX C391 )))
proof
let C392 being (Element of R24);
assume L1841: C392 |= C391;
L1842: C392 |= ( C390 '&' ( EX C391 ) ) by L1841 , L1839;
thus L1843: thesis by L1842 , L1223;
end;
L1844: (for B534 being (Element of R24) holds (B534 |= C391 implies B534 |= ( EG C390 )))
proof
let C393 being (Element of R24);
assume L1845: C393 |= C391;
consider C394 being (inf_path of R25) such that L1846: ( C394 . ( 0 ) ) = C393 and L1847: (for B535 being (Element of ( NAT )) holds ( C394 . B535 ) |= C391) by L1845 , L1840 , L1755;
L1848: (for B536 being (Element of ( NAT )) holds ( C394 . B536 ) |= C390)
proof
let C395 being (Element of ( NAT ));
L1849: ( C394 . C395 ) |= C391 by L1847;
L1850: ( C394 . C395 ) |= ( C390 '&' ( EX C391 ) ) by L1849 , L1839;
thus L1851: thesis by L1850 , L1223;
end;
thus L1852: thesis by L1848 , L1846 , L1262;
end;
thus L1853: thesis by L1844;
end;
definition
let C396 being non  empty set;
let C397 being  total (Relation of C396 , C396);
let C398 being non  empty (Subset of ( ModelSP C396 ));
let C399 being (Assign of ( BASSModel (C397 , C398) ));
func TransEG C399 ->  c=-monotone (Function of ( bool C396 ) , ( bool C396 )) means
:L1854: (for B537 being (Subset of C396) holds ( it . B537 ) = ( SigFaxTau (C399 , B537 , C397 , C398) ));
existence
proof
deffunc H38(set) = ( SigFaxTau (C399 , ( CastBool ($1 , C396) ) , C397 , C398) );
L1855: (for B538 being set holds (B538 in ( bool C396 ) implies H38(B538) in ( bool C396 )));
consider C400 being (Function of ( bool C396 ) , ( bool C396 )) such that L1856: (for B539 being set holds (B539 in ( bool C396 ) implies ( C400 . B539 ) = H38(B539))) from FUNCT_2:sch 2(L1855);
L1857: (for B540 being (Subset of C396) holds ( C400 . B540 ) = ( SigFaxTau (C399 , B540 , C397 , C398) ))
proof
let C401 being (Subset of C396);
L1858: H38(C401) = ( SigFaxTau (C399 , C401 , C397 , C398) ) by L15;
thus L1859: thesis by L1858 , L1856;
end;
L1860: (for B541 , B542 being (Subset of C396) holds (B541 c= B542 implies ( C400 . B541 ) c= ( C400 . B542 )))
proof
let C402 , C403 being (Subset of C396);
assume that
L1861: C402 c= C403;
L1862: ( C400 . C403 ) = ( SigFaxTau (C399 , C403 , C397 , C398) ) by L1857;
L1863: ( C400 . C402 ) = ( SigFaxTau (C399 , C402 , C397 , C398) ) by L1857;
thus L1864: thesis by L1863 , L1861 , L1862 , L1653;
end;
reconsider D121 = C400 as  c=-monotone (Function of ( bool C396 ) , ( bool C396 )) by L1860 , KNASTER:def 1;
take D121;
thus L1865: thesis by L1857;
end;
uniqueness
proof
let C404 , C405 being  c=-monotone (Function of ( bool C396 ) , ( bool C396 ));
assume that
L1866: (for B543 being (Subset of C396) holds ( C404 . B543 ) = ( SigFaxTau (C399 , B543 , C397 , C398) ))
and
L1867: (for B544 being (Subset of C396) holds ( C405 . B544 ) = ( SigFaxTau (C399 , B544 , C397 , C398) ));
L1868: (for B545 being set holds (B545 in ( bool C396 ) implies ( C404 . B545 ) = ( C405 . B545 )))
proof
let C406 being set;
assume L1869: C406 in ( bool C396 );
reconsider D122 = C406 as (Subset of C396) by L1869;
L1870: ( C404 . D122 ) = ( SigFaxTau (C399 , D122 , C397 , C398) ) by L1866
.= ( C405 . D122 ) by L1867;
thus L1871: thesis by L1870;
end;
thus L1872: thesis by L1868 , FUNCT_2:12;
end;
end;
theorem
L1874: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B546 , B547 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B548 being (Element of R24) holds (B548 |= B547 iff B548 |= ( Fax (B546 , B547) ))) iff ( SIGMA B547 ) is_a_fixpoint_of ( TransEG B546 ))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C407 , C408 being (Assign of ( BASSModel (R25 , R29) ));
set D123 = ( SIGMA C408 );
set D124 = ( SIGMA ( Fax (C407 , C408) ) );
L1875: ( ( TransEG C407 ) . D123 ) = ( SigFaxTau (C407 , D123 , R25 , R29) ) by L1854
.= D124 by L1539;
L1876: (D123 is_a_fixpoint_of ( TransEG C407 ) implies (for B549 being (Element of R24) holds (B549 |= C408 iff B549 |= ( Fax (C407 , C408) ))))
proof
assume L1877: D123 is_a_fixpoint_of ( TransEG C407 );
L1878: D123 = D124 by L1877 , L1875 , ABIAN:def 4;
L1879: (for B550 being (Element of R24) holds (B550 |= C408 iff B550 |= ( Fax (C407 , C408) )))
proof
let C409 being (Element of R24);
thus L1880: (C409 |= C408 implies C409 |= ( Fax (C407 , C408) ))
proof
assume L1881: C409 |= C408;
L1882: C409 in D124 by L1881 , L1878;
L1883: (ex B551 being (Element of R24) st (C409 = B551 & B551 |= ( Fax (C407 , C408) ))) by L1882;
thus L1884: thesis by L1883;
end;

assume L1885: C409 |= ( Fax (C407 , C408) );
L1886: C409 in D123 by L1885 , L1878;
L1887: (ex B552 being (Element of R24) st (C409 = B552 & B552 |= C408)) by L1886;
thus L1888: thesis by L1887;
end;
thus L1889: thesis by L1879;
end;
L1890: ((for B553 being (Element of R24) holds (B553 |= C408 iff B553 |= ( Fax (C407 , C408) ))) implies D123 is_a_fixpoint_of ( TransEG C407 ))
proof
assume L1891: (for B554 being (Element of R24) holds (B554 |= C408 iff B554 |= ( Fax (C407 , C408) )));
L1892: (for B555 being set holds (B555 in D124 implies B555 in D123))
proof
let C410 being set;
assume L1893: C410 in D124;
consider C411 being (Element of R24) such that L1894: C410 = C411 and L1895: C411 |= ( Fax (C407 , C408) ) by L1893;
L1896: C411 |= C408 by L1891 , L1895;
thus L1897: thesis by L1896 , L1894;
end;
L1898: (for B556 being set holds (B556 in D123 implies B556 in D124))
proof
let C412 being set;
assume L1899: C412 in D123;
consider C413 being (Element of R24) such that L1900: C412 = C413 and L1901: C413 |= C408 by L1899;
L1902: C413 |= ( Fax (C407 , C408) ) by L1891 , L1901;
thus L1903: thesis by L1902 , L1900;
end;
L1904: D123 = ( ( TransEG C407 ) . D123 ) by L1898 , L1875 , L1892 , TARSKI:1;
thus L1905: thesis by L1904 , ABIAN:def 4;
end;
thus L1906: thesis by L1890 , L1876;
end;
theorem
L1907: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B557 being (Assign of ( BASSModel (R25 , R29) )) holds ( SIGMA ( EG B557 ) ) = ( gfp (R24 , ( TransEG B557 )) )))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C414 being (Assign of ( BASSModel (R25 , R29) ));
set D125 = ( EG C414 );
set D126 = ( Tau (( gfp (R24 , ( TransEG C414 )) ) , R25 , R29) );
L1908: ( SIGMA D126 ) = ( gfp (R24 , ( TransEG C414 )) ) by L1556;
L1909: ( SIGMA D126 ) is_a_fixpoint_of ( TransEG C414 ) by L1908 , KNASTER:5;
L1910: (for B558 being (Element of R24) holds (B558 |= D126 iff B558 |= ( Fax (C414 , D126) ))) by L1909 , L1874;
L1911: ( SIGMA D126 ) c= ( SIGMA D125 )
proof
let C415 being set;
assume L1912: C415 in ( SIGMA D126 );
consider C416 being (Element of R24) such that L1913: C415 = C416 and L1914: C416 |= D126 by L1912;
L1915: C416 |= D125 by L1910 , L1914 , L1838;
thus L1916: thesis by L1915 , L1913;
end;
L1917: (for B559 being (Element of R24) holds (B559 |= D125 iff B559 |= ( Fax (C414 , D125) ))) by L1723;
L1918: ( SIGMA D125 ) is_a_fixpoint_of ( TransEG C414 ) by L1917 , L1874;
L1919: ( SIGMA D125 ) c= ( gfp (R24 , ( TransEG C414 )) ) by L1918 , KNASTER:8;
thus L1920: thesis by L1919 , L1908 , L1911 , XBOOLE_0:def 10;
end;
definition
let C417 being non  empty set;
let C418 being  total (Relation of C417 , C417);
let C419 being non  empty (Subset of ( ModelSP C417 ));
let C420 , C421 , C422 being (Assign of ( BASSModel (C418 , C419) ));
func Foax (C421 , C420 , C422) -> (Assign of ( BASSModel (C418 , C419) )) equals
( C421 'or' ( Fax (C420 , C422) ) );
coherence;
end;
theorem
L1922: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B560 , B561 , B562 , B563 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B564 being (Element of R24) holds (B564 |= B562 implies B564 |= B563)) implies (for B565 being (Element of R24) holds (B565 |= ( Foax (B561 , B560 , B562) ) implies B565 |= ( Foax (B561 , B560 , B563) ))))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C423 , C424 , C425 , C426 being (Assign of ( BASSModel (R25 , R29) ));
assume L1923: (for B566 being (Element of R24) holds (B566 |= C425 implies B566 |= C426));
let C427 being (Element of R24);
assume L1924: C427 |= ( Foax (C424 , C423 , C425) );
per cases  by L1924 , L1322;
suppose L1925: C427 |= C424;

thus L1926: thesis by L1925 , L1322;
end;
suppose L1927: C427 |= ( Fax (C423 , C425) );

L1928: C427 |= ( EX C425 ) by L1927 , L1223;
consider C428 being (inf_path of R25) such that L1929: ( C428 . ( 0 ) ) = C427 and L1930: ( C428 . 1 ) |= C425 by L1928 , L1243;
L1931: ( C428 . 1 ) |= C426 by L1923 , L1930;
L1932: C427 |= ( EX C426 ) by L1931 , L1929 , L1243;
L1933: C427 |= C423 by L1927 , L1223;
L1934: C427 |= ( C423 '&' ( EX C426 ) ) by L1933 , L1932 , L1223;
thus L1935: thesis by L1934 , L1322;
end;
end;
definition
let C429 being non  empty set;
let C430 being  total (Relation of C429 , C429);
let C431 being non  empty (Subset of ( ModelSP C429 ));
let C432 , C433 being (Assign of ( BASSModel (C430 , C431) ));
let C434 being (Subset of C429);
func SigFoaxTau (C433 , C432 , C434 , C430 , C431) -> (Subset of C429) equals
( SIGMA ( Foax (C433 , C432 , ( Tau (C434 , C430 , C431) )) ) );
coherence;
end;
theorem
L1938: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B567 , B568 being (Assign of ( BASSModel (R25 , R29) )) holds (for B569 , B570 being (Subset of R24) holds (B569 c= B570 implies ( SigFoaxTau (B568 , B567 , B569 , R25 , R29) ) c= ( SigFoaxTau (B568 , B567 , B570 , R25 , R29) )))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C435 , C436 being (Assign of ( BASSModel (R25 , R29) ));
let C437 , C438 being (Subset of R24);
assume L1939: C437 c= C438;
L1940: (for B571 being (Element of R24) holds (B571 |= ( Tau (C437 , R25 , R29) ) implies B571 |= ( Tau (C438 , R25 , R29) ))) by L1939 , L1625;
L1941: (for B572 being (Element of R24) holds (B572 |= ( Foax (C436 , C435 , ( Tau (C437 , R25 , R29) )) ) implies B572 |= ( Foax (C436 , C435 , ( Tau (C438 , R25 , R29) )) ))) by L1940 , L1922;
thus L1942: thesis by L1941 , L1634;
end;
theorem
L1943: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B573 , B574 being (Assign of ( BASSModel (R25 , R29) )) holds (for B575 being (Element of R24) holds (B575 |= ( B573 EU B574 ) iff B575 |= ( Foax (B574 , B573 , ( B573 EU B574 )) )))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C439 , C440 being (Assign of ( BASSModel (R25 , R29) ));
let C441 being (Element of R24);
L1944: (C441 |= ( Foax (C440 , C439 , ( C439 EU C440 )) ) implies C441 |= ( C439 EU C440 ))
proof
assume L1945: C441 |= ( Foax (C440 , C439 , ( C439 EU C440 )) );
per cases  by L1945 , L1322;
suppose L1946: C441 |= C440;

set D127 = ( 0 );
consider C442 being (inf_path of R25) such that L1947: ( C442 . ( 0 ) ) = C441 by L1408;
L1948: (for B576 being (Element of ( NAT )) holds (B576 < D127 implies ( C442 . B576 ) |= C439));
thus L1949: thesis by L1948 , L1946 , L1947 , L1287;
end;
suppose L1950: C441 |= ( Fax (C439 , ( C439 EU C440 )) );

set D128 = ( C439 EU C440 );
L1951: C441 |= ( EX D128 ) by L1950 , L1223;
consider C443 being (inf_path of R25) such that L1952: ( C443 . ( 0 ) ) = C441 and L1953: ( C443 . 1 ) |= D128 by L1951 , L1243;
consider C444 being (inf_path of R25) such that L1954: ( C444 . ( 0 ) ) = ( C443 . 1 ) and L1955: (ex B577 being (Element of ( NAT )) st ((for B578 being (Element of ( NAT )) holds (B578 < B577 implies ( C444 . B578 ) |= C439)) & ( C444 . B577 ) |= C440)) by L1953 , L1287;
set D129 = ( PathConc (C443 , C444 , 1) );
reconsider D130 = D129 as (inf_path of R25) by L1954 , L1703;
L1956: ( D130 . ( 0 ) ) = ( PathChange (C443 , C444 , 1 , ( 0 )) ) by L1681
.= C441 by L1952 , L1679;
consider C445 being (Element of ( NAT )) such that L1957: (for B579 being (Element of ( NAT )) holds (B579 < C445 implies ( C444 . B579 ) |= C439)) and L1958: ( C444 . C445 ) |= C440 by L1955;
set D131 = ( C445 + 1 );
L1959: (not D131 < 1) by NAT_1:11;
L1960: C441 |= C439 by L1950 , L1223;
L1961: (for B580 being (Element of ( NAT )) holds (B580 < D131 implies ( D130 . B580 ) |= C439))
proof
let C446 being (Element of ( NAT ));
assume that
L1962: C446 < D131;
per cases ;
suppose L1963: C446 < 1;

thus L1964: thesis by L1963 , L1960 , L1956 , NAT_1:14;
end;
suppose L1965: (not C446 < 1);

set D132 = ( C446 - 1 );
reconsider D133 = D132 as (Element of ( NAT )) by L1965 , NAT_1:21;
L1966: ( ( C446 - 1 ) + 1 ) <= C445 by L1962 , INT_1:7;
L1967: D133 < C445 by L1966 , NAT_1:13;
L1968: ( D130 . C446 ) = ( PathChange (C443 , C444 , 1 , C446) ) by L1681
.= ( C444 . D133 ) by L1965 , L1679;
thus L1969: thesis by L1968 , L1957 , L1967;
end;
end;
L1971: ( D130 . D131 ) = ( PathChange (C443 , C444 , 1 , D131) ) by L1681
.= ( C444 . ( D131 - 1 ) ) by L1959 , L1679
.= ( C444 . C445 );
thus L1972: thesis by L1971 , L1958 , L1956 , L1961 , L1287;
end;
end;
L1974: (C441 |= ( C439 EU C440 ) implies C441 |= ( Foax (C440 , C439 , ( C439 EU C440 )) ))
proof
assume L1975: C441 |= ( C439 EU C440 );
consider C447 being (inf_path of R25) such that L1976: ( C447 . ( 0 ) ) = C441 and L1977: (ex B581 being (Element of ( NAT )) st ((for B582 being (Element of ( NAT )) holds (B582 < B581 implies ( C447 . B582 ) |= C439)) & ( C447 . B581 ) |= C440)) by L1975 , L1287;
consider C448 being (Element of ( NAT )) such that L1978: (for B583 being (Element of ( NAT )) holds (B583 < C448 implies ( C447 . B583 ) |= C439)) and L1979: ( C447 . C448 ) |= C440 by L1977;
per cases ;
suppose L1980: C448 = ( 0 );

thus L1981: thesis by L1980 , L1976 , L1979 , L1322;
end;
suppose L1982: C448 > ( 0 );

set D134 = ( C448 - 1 );
reconsider D135 = D134 as (Element of ( NAT )) by L1982 , NAT_1:20;
set D136 = ( C439 EU C440 );
set D137 = ( PathShift (C447 , 1) );
L1983: ( D137 . D135 ) = ( C447 . ( D135 + 1 ) ) by L1658
.= ( C447 . C448 );
L1984: (for B584 being (Element of ( NAT )) holds (B584 < D135 implies ( D137 . B584 ) |= C439))
proof
let C449 being (Element of ( NAT ));
assume L1985: C449 < D135;
L1986: ( C449 + 1 ) <= D135 by L1985 , INT_1:7;
L1987: ( C449 + 1 ) < ( D135 + 1 ) by L1986 , NAT_1:13;
L1988: ( C447 . ( C449 + 1 ) ) |= C439 by L1987 , L1978;
thus L1989: thesis by L1988 , L1658;
end;
L1990: ( D137 . ( 0 ) ) = ( C447 . ( ( 0 ) + 1 ) ) by L1658
.= ( C447 . 1 );
L1991: ( C447 . 1 ) |= D136 by L1990 , L1979 , L1983 , L1984 , L1287;
L1992: C441 |= ( EX D136 ) by L1991 , L1976 , L1243;
L1993: C441 |= C439 by L1976 , L1978 , L1982;
L1994: C441 |= ( Fax (C439 , D136) ) by L1993 , L1992 , L1223;
thus L1995: thesis by L1994 , L1322;
end;
end;
thus L1997: thesis by L1974 , L1944;
end;
theorem
L1998: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B585 , B586 , B587 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B588 being (Element of R24) holds (B588 |= B587 iff B588 |= ( Foax (B586 , B585 , B587) ))) implies (for B589 being (Element of R24) holds (B589 |= ( B585 EU B586 ) implies B589 |= B587)))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C450 , C451 , C452 being (Assign of ( BASSModel (R25 , R29) ));
assume L1999: (for B590 being (Element of R24) holds (B590 |= C452 iff B590 |= ( Foax (C451 , C450 , C452) )));
let C453 being (Element of R24);
assume L2000: C453 |= ( C450 EU C451 );
consider C454 being (inf_path of R25) such that L2001: ( C454 . ( 0 ) ) = C453 and L2002: (ex B591 being (Element of ( NAT )) st ((for B592 being (Element of ( NAT )) holds (B592 < B591 implies ( C454 . B592 ) |= C450)) & ( C454 . B591 ) |= C451)) by L2000 , L1287;
consider C455 being (Element of ( NAT )) such that L2003: (for B593 being (Element of ( NAT )) holds (B593 < C455 implies ( C454 . B593 ) |= C450)) and L2004: ( C454 . C455 ) |= C451 by L2002;
L2005: (for B594 being (Element of ( NAT )) holds (B594 <= C455 implies ( C454 . ( k_nat ( C455 - B594 ) ) ) |= C452))
proof
defpred S12[ (Element of ( NAT )) ] means ($1 <= C455 implies ( C454 . ( k_nat ( C455 - $1 ) ) ) |= C452);
L2006: (for B595 being (Element of ( NAT )) holds (S12[ B595 ] implies S12[ ( B595 + 1 ) ]))
proof
let C456 being (Element of ( NAT ));
assume that
L2007: S12[ C456 ];
set D138 = ( C456 + 1 );
L2008: (D138 <= C455 implies ( C454 . ( k_nat ( C455 - D138 ) ) ) |= C452)
proof
set D139 = ( C455 - D138 );
assume L2009: D138 <= C455;
reconsider D140 = D139 as (Element of ( NAT )) by L2009 , NAT_1:21;
set D141 = ( PathShift (C454 , D140) );
L2010: ( D141 . ( 0 ) ) = ( C454 . ( D140 + ( 0 ) ) ) by L1658
.= ( C454 . D140 );
L2011: D140 <= ( D140 + C456 ) by NAT_1:12;
L2012: D140 < ( ( D140 + C456 ) + 1 ) by L2011 , NAT_1:13;
L2013: ( C454 . D140 ) |= C450 by L2012 , L2003;
L2014: ( D141 . 1 ) = ( C454 . ( D140 + 1 ) ) by L1658;
L2015: ( C454 . ( D140 + 1 ) ) |= C452 by L2007 , L2009 , L9 , NAT_1:13;
L2016: ( C454 . D140 ) |= ( EX C452 ) by L2015 , L2010 , L2014 , L1243;
L2017: ( C454 . D140 ) |= ( Fax (C450 , C452) ) by L2016 , L2013 , L1223;
L2018: ( C454 . D140 ) |= ( Foax (C451 , C450 , C452) ) by L2017 , L1322;
L2019: ( k_nat D140 ) = D140 by L9;
thus L2020: thesis by L2019 , L1999 , L2018;
end;
thus L2021: thesis by L2008;
end;
L2022: S12[ ( 0 ) ]
proof
assume L2023: ( 0 ) <= C455;
L2024: ( k_nat ( C455 - ( 0 ) ) ) = C455 by L9;
L2025: ( C454 . C455 ) |= ( Foax (C451 , C450 , C452) ) by L2004 , L1322;
thus L2026: thesis by L2025 , L1999 , L2024;
end;
L2027: (for B596 being (Element of ( NAT )) holds S12[ B596 ]) from NAT_1:sch 1(L2022 , L2006);
thus L2028: thesis by L2027;
end;
L2029: ( C454 . ( k_nat ( C455 - C455 ) ) ) |= C452 by L2005;
thus L2030: thesis by L2029 , L2001 , L9;
end;
definition
let C457 being non  empty set;
let C458 being  total (Relation of C457 , C457);
let C459 being non  empty (Subset of ( ModelSP C457 ));
let C460 , C461 being (Assign of ( BASSModel (C458 , C459) ));
func TransEU (C460 , C461) ->  c=-monotone (Function of ( bool C457 ) , ( bool C457 )) means
:L2031: (for B597 being (Subset of C457) holds ( it . B597 ) = ( SigFoaxTau (C461 , C460 , B597 , C458 , C459) ));
existence
proof
deffunc H39(set) = ( SigFoaxTau (C461 , C460 , ( CastBool ($1 , C457) ) , C458 , C459) );
L2032: (for B598 being set holds (B598 in ( bool C457 ) implies H39(B598) in ( bool C457 )));
consider C462 being (Function of ( bool C457 ) , ( bool C457 )) such that L2033: (for B599 being set holds (B599 in ( bool C457 ) implies ( C462 . B599 ) = H39(B599))) from FUNCT_2:sch 2(L2032);
L2034: (for B600 being (Subset of C457) holds ( C462 . B600 ) = ( SigFoaxTau (C461 , C460 , B600 , C458 , C459) ))
proof
let C463 being (Subset of C457);
L2035: ( CastBool (C463 , C457) ) = C463 by L15;
thus L2036: thesis by L2035 , L2033;
end;
L2037: (for B601 , B602 being (Subset of C457) holds (B601 c= B602 implies ( C462 . B601 ) c= ( C462 . B602 )))
proof
let C464 , C465 being (Subset of C457);
assume that
L2038: C464 c= C465;
L2039: ( C462 . C465 ) = ( SigFoaxTau (C461 , C460 , C465 , C458 , C459) ) by L2034;
L2040: ( C462 . C464 ) = ( SigFoaxTau (C461 , C460 , C464 , C458 , C459) ) by L2034;
thus L2041: thesis by L2040 , L2038 , L2039 , L1938;
end;
reconsider D142 = C462 as  c=-monotone (Function of ( bool C457 ) , ( bool C457 )) by L2037 , KNASTER:def 1;
take D142;
thus L2042: thesis by L2034;
end;
uniqueness
proof
let C466 , C467 being  c=-monotone (Function of ( bool C457 ) , ( bool C457 ));
assume that
L2043: (for B603 being (Subset of C457) holds ( C466 . B603 ) = ( SigFoaxTau (C461 , C460 , B603 , C458 , C459) ))
and
L2044: (for B604 being (Subset of C457) holds ( C467 . B604 ) = ( SigFoaxTau (C461 , C460 , B604 , C458 , C459) ));
L2045: (for B605 being set holds (B605 in ( bool C457 ) implies ( C466 . B605 ) = ( C467 . B605 )))
proof
let C468 being set;
assume L2046: C468 in ( bool C457 );
reconsider D143 = C468 as (Subset of C457) by L2046;
L2047: ( C466 . D143 ) = ( SigFoaxTau (C461 , C460 , D143 , C458 , C459) ) by L2043
.= ( C467 . D143 ) by L2044;
thus L2048: thesis by L2047;
end;
thus L2049: thesis by L2045 , FUNCT_2:12;
end;
end;
theorem
L2051: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B606 , B607 , B608 being (Assign of ( BASSModel (R25 , R29) )) holds ((for B609 being (Element of R24) holds (B609 |= B608 iff B609 |= ( Foax (B607 , B606 , B608) ))) iff ( SIGMA B608 ) is_a_fixpoint_of ( TransEU (B606 , B607) ))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C469 , C470 , C471 being (Assign of ( BASSModel (R25 , R29) ));
set D144 = ( SIGMA C471 );
set D145 = ( SIGMA ( Foax (C470 , C469 , C471) ) );
L2052: ( ( TransEU (C469 , C470) ) . D144 ) = ( SigFoaxTau (C470 , C469 , D144 , R25 , R29) ) by L2031
.= D145 by L1539;
L2053: (D144 is_a_fixpoint_of ( TransEU (C469 , C470) ) implies (for B610 being (Element of R24) holds (B610 |= C471 iff B610 |= ( Foax (C470 , C469 , C471) ))))
proof
assume L2054: D144 is_a_fixpoint_of ( TransEU (C469 , C470) );
L2055: D144 = D145 by L2054 , L2052 , ABIAN:def 4;
L2056: (for B611 being (Element of R24) holds (B611 |= C471 iff B611 |= ( Foax (C470 , C469 , C471) )))
proof
let C472 being (Element of R24);
thus L2057: (C472 |= C471 implies C472 |= ( Foax (C470 , C469 , C471) ))
proof
assume L2058: C472 |= C471;
L2059: C472 in D144 by L2058;
L2060: (ex B612 being (Element of R24) st (C472 = B612 & B612 |= ( Foax (C470 , C469 , C471) ))) by L2059 , L2055;
thus L2061: thesis by L2060;
end;

assume L2062: C472 |= ( Foax (C470 , C469 , C471) );
L2063: C472 in D145 by L2062;
L2064: (ex B613 being (Element of R24) st (C472 = B613 & B613 |= C471)) by L2063 , L2055;
thus L2065: thesis by L2064;
end;
thus L2066: thesis by L2056;
end;
L2067: ((for B614 being (Element of R24) holds (B614 |= C471 iff B614 |= ( Foax (C470 , C469 , C471) ))) implies D144 is_a_fixpoint_of ( TransEU (C469 , C470) ))
proof
assume L2068: (for B615 being (Element of R24) holds (B615 |= C471 iff B615 |= ( Foax (C470 , C469 , C471) )));
L2069: (for B616 being set holds (B616 in D145 implies B616 in D144))
proof
let C473 being set;
assume L2070: C473 in D145;
consider C474 being (Element of R24) such that L2071: C473 = C474 and L2072: C474 |= ( Foax (C470 , C469 , C471) ) by L2070;
L2073: C474 |= C471 by L2068 , L2072;
thus L2074: thesis by L2073 , L2071;
end;
L2075: (for B617 being set holds (B617 in D144 implies B617 in D145))
proof
let C475 being set;
assume L2076: C475 in D144;
consider C476 being (Element of R24) such that L2077: C475 = C476 and L2078: C476 |= C471 by L2076;
L2079: C476 |= ( Foax (C470 , C469 , C471) ) by L2068 , L2078;
thus L2080: thesis by L2079 , L2077;
end;
L2081: D144 = D145 by L2075 , L2069 , TARSKI:1;
thus L2082: thesis by L2081 , L2052 , ABIAN:def 4;
end;
thus L2083: thesis by L2067 , L2053;
end;
theorem
L2084: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B618 , B619 being (Assign of ( BASSModel (R25 , R29) )) holds ( SIGMA ( B618 EU B619 ) ) = ( lfp (R24 , ( TransEU (B618 , B619) )) )))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C477 , C478 being (Assign of ( BASSModel (R25 , R29) ));
set D146 = ( C477 EU C478 );
set D147 = ( Tau (( lfp (R24 , ( TransEU (C477 , C478) )) ) , R25 , R29) );
L2085: ( SIGMA D147 ) = ( lfp (R24 , ( TransEU (C477 , C478) )) ) by L1556;
L2086: ( lfp (R24 , ( TransEU (C477 , C478) )) ) is_a_fixpoint_of ( TransEU (C477 , C478) ) by KNASTER:4;
L2087: (for B620 being (Element of R24) holds (B620 |= D147 iff B620 |= ( Foax (C478 , C477 , D147) ))) by L2086 , L2085 , L2051;
L2088: ( SIGMA D146 ) c= ( SIGMA D147 )
proof
let C479 being set;
assume L2089: C479 in ( SIGMA D146 );
consider C480 being (Element of R24) such that L2090: C479 = C480 and L2091: C480 |= D146 by L2089;
L2092: C480 |= D147 by L2087 , L2091 , L1998;
thus L2093: thesis by L2092 , L2090;
end;
L2094: (for B621 being (Element of R24) holds (B621 |= D146 iff B621 |= ( Foax (C478 , C477 , D146) ))) by L1943;
L2095: ( SIGMA D146 ) is_a_fixpoint_of ( TransEU (C477 , C478) ) by L2094 , L2051;
L2096: ( lfp (R24 , ( TransEU (C477 , C478) )) ) c= ( SIGMA D146 ) by L2095 , KNASTER:8;
thus L2097: thesis by L2096 , L2085 , L2088 , XBOOLE_0:def 10;
end;
theorem
L2098: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B622 being (Assign of ( BASSModel (R25 , R29) )) holds ( SIGMA ( EX B622 ) ) = ( Pred (( SIGMA B622 ) , R25) )))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C481 being (Assign of ( BASSModel (R25 , R29) ));
set D148 = ( EX C481 );
set D149 = ( SIGMA C481 );
L2099: (for B623 being set holds (B623 in ( Pred (D149 , R25) ) implies B623 in ( SIGMA D148 )))
proof
let C482 being set;
assume L2100: C482 in ( Pred (D149 , R25) );
consider C483 being (Element of R24) such that L2101: C482 = C483 and L2102: (ex B624 being (Element of R24) st (B624 in D149 & [ C483 , B624 ] in R25)) by L2100;
consider C484 being (Element of R24) such that L2103: C484 in D149 and L2104: [ C483 , C484 ] in R25 by L2102;
L2105: (ex B625 being (Element of R24) st (C484 = B625 & B625 |= C481)) by L2103;
L2106: C483 |= D148 by L2105 , L2104 , L1434;
thus L2107: thesis by L2106 , L2101;
end;
L2108: (for B626 being set holds (B626 in ( SIGMA D148 ) implies B626 in ( Pred (D149 , R25) )))
proof
let C485 being set;
assume L2109: C485 in ( SIGMA D148 );
consider C486 being (Element of R24) such that L2110: C485 = C486 and L2111: C486 |= D148 by L2109;
consider C487 being (Element of R24) such that L2112: [ C486 , C487 ] in R25 and L2113: C487 |= C481 by L2111 , L1434;
L2114: C487 in D149 by L2113;
thus L2115: thesis by L2114 , L2110 , L2112;
end;
thus L2116: thesis by L2108 , L2099 , TARSKI:1;
end;
theorem
L2117: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B627 being (Assign of ( BASSModel (R25 , R29) )) holds (for B628 being (Subset of R24) holds ( ( TransEG B627 ) . B628 ) = ( ( SIGMA B627 ) /\ ( Pred (B628 , R25) ) ))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C488 being (Assign of ( BASSModel (R25 , R29) ));
let C489 being (Subset of R24);
set D150 = ( Tau (C489 , R25 , R29) );
L2118: ( ( TransEG C488 ) . C489 ) = ( SigFaxTau (C488 , C489 , R25 , R29) ) by L1854
.= ( ( SIGMA C488 ) /\ ( SIGMA ( EX D150 ) ) ) by L1568
.= ( ( SIGMA C488 ) /\ ( Pred (( SIGMA D150 ) , R25) ) ) by L2098;
thus L2119: thesis by L2118 , L1556;
end;
theorem
L2120: (for R24 being non  empty set holds (for R25 being  total (Relation of R24 , R24) holds (for R29 being non  empty (Subset of ( ModelSP R24 )) holds (for B629 , B630 being (Assign of ( BASSModel (R25 , R29) )) holds (for B631 being (Subset of R24) holds ( ( TransEU (B629 , B630) ) . B631 ) = ( ( SIGMA B630 ) \/ ( ( SIGMA B629 ) /\ ( Pred (B631 , R25) ) ) ))))))
proof
let R24 being non  empty set;
let R25 being  total (Relation of R24 , R24);
let R29 being non  empty (Subset of ( ModelSP R24 ));
let C490 , C491 being (Assign of ( BASSModel (R25 , R29) ));
let C492 being (Subset of R24);
set D151 = ( Tau (C492 , R25 , R29) );
L2121: ( ( TransEU (C490 , C491) ) . C492 ) = ( SigFoaxTau (C491 , C490 , C492 , R25 , R29) ) by L2031
.= ( ( SIGMA C491 ) \/ ( SIGMA ( Fax (C490 , D151) ) ) ) by L1568
.= ( ( SIGMA C491 ) \/ ( ( SIGMA C490 ) /\ ( SIGMA ( EX D151 ) ) ) ) by L1568
.= ( ( SIGMA C491 ) \/ ( ( SIGMA C490 ) /\ ( Pred (( SIGMA D151 ) , R25) ) ) ) by L2098;
thus L2122: thesis by L2121 , L1556;
end;
