:: First order languages: syntax, part two; semantics.
::  by Marco B. Caminati
::
:: Received December 29, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, RELAT_1,
      FUNCT_2, FINSEQ_1, FUNCT_1, ARYTM_3, XCMPLX_0, CARD_1, MONOID_0,
      ORDINAL1, ARYTM_1, XXREAL_0, ORDINAL4, PARTFUN1, FINSEQ_2, EQREL_1,
      COMPLEX1, FUNCT_3, MCART_1, FUNCT_4, FUNCOP_1, MARGREL1, XBOOLEAN,
      RFINSEQ, FUNCT_5, FINSET_1, FOMODEL0, FOMODEL1, FOMODEL2;
 notations TARSKI, XTUPLE_0,
      XBOOLEAN, MARGREL1, MONOID_0, XBOOLE_0, ZFMISC_1, SUBSET_1,
      DOMAIN_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, BINOP_1, RFUNCT_3,
      FUNCOP_1, FUNCT_4, MCART_1, ORDINAL1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, INT_2, FINSEQ_1, EQREL_1, FINSEQ_2, RELSET_1, RFINSEQ,
      FINSEQOP, FUNCT_5, FINSET_1, FOMODEL0, FOMODEL1;
 constructors TARSKI, XBOOLE_0, ZFMISC_1, CARD_1, NAT_1, NUMBERS, INT_1,
      ARYTM_3, FINSEQ_1, XCMPLX_0, FUNCT_1, MONOID_0, XXREAL_0, RELAT_2,
      RFINSEQ, FUNCT_2, FUNCT_4, FUNCT_7, FUNCOP_1, FINSEQ_2, EQREL_1,
      COMPLEX1, RELSET_1, MCART_1, PARTFUN1, FINSEQOP, MATRIX_2, FUNCT_3,
      SETFAM_1, PRE_POLY, FINSET_1, BINOP_1, FUNCT_5, RFUNCT_3, STRUCT_0,
      FOMODEL0, FOMODEL1, XTUPLE_0;
 registrations XCMPLX_0, NAT_1, RELAT_1, NUMBERS, REAL_1, FUNCT_1, INT_1,
      FINSEQ_1, XREAL_0, FUNCT_2, FINSEQ_2, SUBSET_1, FUNCOP_1, RELSET_1,
      FUNCT_4, PARTFUN1, EQREL_1, FINSEQ_6, PRE_POLY, CARD_1, XBOOLE_0,
      XXREAL_0, ZFMISC_1, SETFAM_1, MARGREL1, FINSET_1, RAMSEY_1, CARD_5,
      XBOOLEAN, FOMODEL0, FOMODEL1, ORDINAL1, XTUPLE_0;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions FINSEQ_1, FUNCT_1, XBOOLE_0, RELAT_1, PARTFUN1, FUNCOP_1,
      SUBSET_1, RELSET_1, MARGREL1, EQREL_1, XBOOLEAN, BINOP_1, FOMODEL0,
      FOMODEL1, XTUPLE_0;
 theorems TARSKI, XBOOLE_0, FUNCT_1, FINSEQ_1, RELAT_1, XBOOLE_1, ZFMISC_1,
      FUNCT_2, XXREAL_0, NAT_1, ORDINAL1, EQREL_1, PARTFUN1, FINSEQ_2, XREAL_1,
      MCART_1, FUNCT_4, FUNCOP_1, FUNCT_5, FINSEQ_6, RELSET_1, GRFUNC_1,
      FOMODEL0, FOMODEL1, DOMAIN_1, ABSVALUE, FUNCT_7, BINOP_1, FUNCT_6,
      CARD_1;
 schemes NAT_1, FUNCT_1, FUNCT_2, CLASSES1, RECDEF_1, DOMAIN_1, BINOP_1,
      FRAENKEL;

begin
definition
let R15 being Language;
redefine func TheNorSymbOf R15 -> (Element of R15);

coherence;
end;
definition
let C1 being non  empty set;
func C1 -deltaInterpreter -> (Function of ( 2 -tuples_on C1 ) , ( BOOLEAN )) equals 
( chi (( ( C1 -concatenation ) .: ( id ( 1 -tuples_on C1 ) ) ) , ( 2 -tuples_on C1 )) );
coherence;
end;
definition
let C2 being set;
redefine func id C2 -> (Equivalence_Relation of C2);

coherence by EQREL_1:3;
end;
definition
let C3 being Language;
let C4 being non  empty set;
let C5 being  ofAtomicFormula (Element of C3);
mode Interpreter of C5 , C4
means :L4: it is (Function of ( ( abs ( ar C5 ) ) -tuples_on C4 ) , ( BOOLEAN )) if C5 is  relational otherwise it is (Function of ( ( abs ( ar C5 ) ) -tuples_on C4 ) , C4);
existence
proof
thus L5: (C5 is  relational implies (ex B1 being set st B1 is (Function of ( ( abs ( ar C5 ) ) -tuples_on C4 ) , ( BOOLEAN ))))
proof
assume L6: C5 is  relational;
take the (Function of ( ( abs ( ar C5 ) ) -tuples_on C4 ) , ( BOOLEAN ));
thus L7: thesis;
end;

assume L8: (not C5 is  relational);
take the (Function of ( ( abs ( ar C5 ) ) -tuples_on C4 ) , C4);
thus L9: thesis;
end;
consistency;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C6 being  ofAtomicFormula (Element of R15);
redefine mode Interpreter of C6 , R22
 -> (Function of ( ( abs ( ar C6 ) ) -tuples_on R22 ) , ( R22 \/ ( BOOLEAN ) ));
coherence
proof
let C7 being (Interpreter of C6 , R22);
set D1 = ( abs ( ar C6 ) );
set D2 = ( D1 -tuples_on R22 );
set D3 = ( R22 \/ ( BOOLEAN ) );
L11: D2 c= ( D2 \/ ( {} ) );
reconsider D4 = D2 as (Subset of D2) by L11;
reconsider D5 = ( BOOLEAN ) , D6 = R22 as (Subset of D3) by XBOOLE_1:7;
per cases ;
suppose L12: C6 is  relational;

reconsider D7 = C7 as (Function of D4 , D5) by L12 , L4;
L13: [: D4 , D5 :] c= [: D2 , D3 :];
reconsider D8 = D7 as (Relation of D2 , D3) by L13 , XBOOLE_1:1;
L14: D8 is (Function of D2 , D3);
thus L15: thesis by L14;
end;
suppose L16: (not C6 is  relational);

reconsider D9 = C7 as (Function of D4 , D6) by L16 , L4;
L17: [: D4 , D6 :] c= [: D2 , D3 :];
reconsider D10 = D9 as (Relation of D2 , D3) by L17 , XBOOLE_1:1;
L18: D10 is (Function of D2 , D3);
thus L19: thesis by L18;
end;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C8 being  termal (Element of R15);
cluster  -> R22 -valued for (Interpreter of C8 , R22);
coherence by L4;
end;
registration
let C9 being Language;
cluster  literal ->  own for (Element of C9);
coherence;
end;
definition
let R15 being Language;
let R22 being non  empty set;
mode Interpreter of R15 , R22
 -> Function
means :L24: (for B2 being  own (Element of R15) holds ( it . B2 ) is (Interpreter of B2 , R22));
existence
proof
set D11 = ( OwnSymbolsOf R15 );
defpred S1[ set , set ] means (ex B3 being  own (Element of R15) st ($1 = B3 & $2 is (Interpreter of B3 , R22)));
L25: (for B4 being set holds (B4 in D11 implies (ex B5 being set st S1[ B4 , B5 ])))
proof
let C10 being set;
assume L26: C10 in D11;
reconsider D12 = C10 as  own (Element of R15) by L26 , FOMODEL1:def 19;
take D13 = the (Interpreter of D12 , R22);
take D12;
thus L27: (C10 = D12 & D13 is (Interpreter of D12 , R22));
end;
consider C11 being Function such that L28: (( dom C11 ) = D11 & (for B6 being set holds (B6 in D11 implies S1[ B6 , ( C11 . B6 ) ]))) from CLASSES1:sch 1(L25);
take C11;
thus L29: (for B7 being  own (Element of R15) holds ( C11 . B7 ) is (Interpreter of B7 , R22))
proof
let C12 being  own (Element of R15);
L30: C12 in D11 by FOMODEL1:def 19;
consider C13 being  own (Element of R15) such that L31: (C12 = C13 & ( C11 . C12 ) is (Interpreter of C13 , R22)) by L30 , L28;
thus L32: ( C11 . C12 ) is (Interpreter of C12 , R22) by L31;
end;

end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let R25 being Function;
attr R25 is R15 , R22 -interpreter-like
means
:L31: (R25 is (Interpreter of R15 , R22) & R25 is  Function-yielding);
end;
registration
let R15 being Language;
let C14 being non  empty set;
cluster (R15 , C14)-interpreter-like ->  Function-yielding for Function;
coherence by L31;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C15 being  own (Element of R15);
cluster  -> non  empty for (Interpreter of C15 , R22);
coherence;
end;
L35: (for R15 being Language holds (for R22 being non  empty set holds (for B8 being (Interpreter of R15 , R22) holds ( OwnSymbolsOf R15 ) c= ( dom B8 ))))
proof
let R15 being Language;
let R22 being non  empty set;
set D14 = ( AllSymbolsOf R15 );
set D15 = ( AtomicFormulaSymbolsOf R15 );
set D16 = ( OwnSymbolsOf R15 );
let C16 being (Interpreter of R15 , R22);
L36:
now
let C17 being set;
assume L37: C17 in D16;
reconsider D17 = C17 as  own (Element of R15) by L37 , FOMODEL1:def 19;
L38: ( C16 . D17 ) is non  empty by L24;
thus L39: C17 in ( dom C16 ) by L38 , FUNCT_1:def 2;
end;
thus L40: thesis by L36 , TARSKI:def 3;
end;
L41: (for R15 being Language holds (for R22 being non  empty set holds (for R25 being Function holds (R25 is (R15 , R22)-interpreter-like implies ( OwnSymbolsOf R15 ) c= ( dom R25 )))))
proof
let R15 being Language;
let R22 being non  empty set;
let R25 being Function;
assume L42: R25 is (R15 , R22)-interpreter-like;
L43: R25 is (Interpreter of R15 , R22) by L42 , L31;
thus L44: thesis by L43 , L35;
end;
registration
let C18 being Language;
let C19 being non  empty set;
cluster (C18 , C19)-interpreter-like for Function;
existence
proof
set D18 = ( OwnSymbolsOf C18 );
set D19 = ( AllSymbolsOf C18 );
set D20 = the (Interpreter of C18 , C19);
reconsider D21 = ( D20 | D18 ) as Function;
L45: ( dom D21 ) = ( D18 /\ ( dom D20 ) ) by RELAT_1:61
.= D18 by L35 , XBOOLE_1:28;
take D21;
L46: (for B9 being  own (Element of C18) holds (( D21 . B9 ) is (Interpreter of B9 , C19) & ( D21 . B9 ) is Function))
proof
let C20 being  own (Element of C18);
L47: C20 in ( dom D21 ) by L45 , FOMODEL1:def 19;
L48: ( D21 . C20 ) = ( D20 . C20 ) by L47 , FUNCT_1:47;
thus L49: ( D21 . C20 ) is (Interpreter of C20 , C19) by L48 , L24;
thus L50: ( D21 . C20 ) is Function by L48 , L24;
end;
reconsider D22 = D21 as (Interpreter of C18 , C19) by L46 , L24;
L51:
now
let R12 being set;
assume L52: R12 in ( dom D21 );
reconsider D23 = R12 as  own (Element of C18) by L52 , L45 , FOMODEL1:def 19;
L53: ( D22 . D23 ) is Function by L46;
thus L54: ( D22 . R12 ) is Function by L53;
end;
L55: D22 is  Function-yielding by L51 , FUNCOP_1:def 6;
thus L56: thesis by L55 , L31;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C21 being (R15 , R22)-interpreter-like Function;
let C22 being  own (Element of R15);
redefine func C21 . C22 -> (Interpreter of C22 , R22);

coherence
proof
reconsider D24 = C21 as (Interpreter of R15 , R22) by L31;
L58: ( D24 . C22 ) is (Interpreter of C22 , R22) by L24;
thus L59: thesis by L58;
end;
end;
registration
let C23 being Language;
let C24 being non  empty set;
let C25 being (C23 , C24)-interpreter-like Function;
let C26 being  own (Element of C23);
let C27 being (Interpreter of C26 , C24);
cluster ( C25 +* ( C26 .--> C27 ) ) -> (C23 , C24)-interpreter-like;
coherence
proof
set D25 = ( C26 .--> C27 );
set D26 = ( OwnSymbolsOf C23 );
set D27 = ( C25 +* D25 );
L61: (D26 c= ( dom C25 ) & ( dom C25 ) c= ( ( dom C25 ) \/ ( dom D25 ) )) by L41 , XBOOLE_1:7;
L62: D26 c= ( ( dom C25 ) \/ ( dom D25 ) ) by L61 , XBOOLE_1:1;
reconsider D28 = C25 as (Interpreter of C23 , C24) by L31;
L63:
now
let C28 being  own (Element of C23);
L64: C28 in D26 by FOMODEL1:def 19;
per cases ;
suppose L65: C28 in ( dom D25 );

L66: ( D27 . C28 ) = ( D25 . C28 ) by L65 , L64 , L62 , FUNCT_4:def 1
.= C27 by L65 , FUNCOP_1:7;
thus L67: ( D27 . C28 ) is (Interpreter of C28 , C24) by L66 , L65 , TARSKI:def 1;
end;
suppose L68: (not C28 in ( dom D25 ));

L69: ( D27 . C28 ) = ( D28 . C28 ) by L68 , L62 , L64 , FUNCT_4:def 1;
thus L70: ( D27 . C28 ) is (Interpreter of C28 , C24) by L69 , L24;
end;
end;
L72: (D27 is (Interpreter of C23 , C24) & D27 is  Function-yielding) by L63 , L24;
thus L73: thesis by L72 , L31;
end;
end;
definition
let R25 being Function;
let R12 being set;
let R13 being set;
func (R12 , R13) ReassignIn R25 -> Function equals 
( R25 +* ( R12 .--> ( ( {} ) .--> R13 ) ) );
coherence;
end;
registration
let C29 being Language;
let C30 being non  empty set;
let C31 being (C29 , C30)-interpreter-like Function;
let C32 being  literal (Element of C29);
let C33 being (Element of C30);
cluster ( (C32 , C33) ReassignIn C31 ) -> (C29 , C30)-interpreter-like;
coherence
proof
set D29 = ( (C32 , C33) ReassignIn C31 );
set D30 = ( abs ( ar C32 ) );
L76: (D30 = ( 0 ) & { ( {} ) } = ( ( 0 ) -tuples_on C30 )) by FOMODEL0:10;
reconsider D31 = ( { ( {} ) } --> C33 ) as (Function of ( D30 -tuples_on C30 ) , C30) by L76;
reconsider D32 = D31 as (Interpreter of C32 , C30) by L4;
L77: D29 = ( C31 +* ( C32 .--> D32 ) );
thus L78: thesis by L77;
end;
end;
registration
let C34 being Language;
cluster ( AllSymbolsOf C34 ) -> non  empty;
coherence;
end;
registration
let C35 being set;
let C36 , C37 being non  empty set;
cluster  ->  Function-yielding for (Function of C36 , ( Funcs (C35 , C37) ));
coherence;
end;
registration
let C38 , C39 , C40 being non  empty set;
cluster  Function-yielding for (Function of C38 , ( Funcs (C39 , C40) ));
existence
proof
take the (Function of C38 , ( Funcs (C39 , C40) ));
thus L82: thesis;
end;
end;
definition
let C41 being  Function-yielding Function;
let C42 being Function;
func ^^^C42 , C41 __ -> Function means 
:L84: (( dom it ) = ( dom C41 ) & (for R12 being set holds (R12 in ( dom C41 ) implies ( it . R12 ) = ( C42 * ( C41 . R12 ) ))));
existence
proof
deffunc H1(set) = ( C42 * ( C41 . $1 ) );
consider C43 being Function such that L85: (( dom C43 ) = ( dom C41 ) & (for R12 being set holds (R12 in ( dom C41 ) implies ( C43 . R12 ) = H1(R12)))) from FUNCT_1:sch 3;
take C43;
thus L86: thesis by L85;
end;
uniqueness
proof
let C44 , C45 being Function;
assume L87: (( dom C44 ) = ( dom C41 ) & (for R12 being set holds (R12 in ( dom C41 ) implies ( C44 . R12 ) = ( C42 * ( C41 . R12 ) ))));
assume L88: (( dom C45 ) = ( dom C41 ) & (for R12 being set holds (R12 in ( dom C41 ) implies ( C45 . R12 ) = ( C42 * ( C41 . R12 ) ))));
L89:
now
let R12 being set;
assume L90: R12 in ( dom C44 );
L91: (( C44 . R12 ) = ( C42 * ( C41 . R12 ) ) & ( C45 . R12 ) = ( C42 * ( C41 . R12 ) )) by L90 , L87 , L88;
thus L92: ( C44 . R12 ) = ( C45 . R12 ) by L91;
end;
thus L93: thesis by L89 , L87 , L88 , FUNCT_1:2;
end;
end;
registration
let C46 being  empty Function;
let C47 being Function;
cluster ^^^ C47 , C46 __ ->  empty;
coherence
proof
L95: ( dom ^^^ C47 , C46 __ ) = ( dom C46 ) by L84
.= ( {} );
thus L96: thesis by L95;
end;
end;
definition
let C48 being  Function-yielding Function;
let C49 being Function;
func ^^^C48 , C49 __ -> Function means 
:L98: (( dom it ) = ( ( dom C48 ) /\ ( dom C49 ) ) & (for B10 being set holds (B10 in ( dom it ) implies ( it . B10 ) = ( ( C48 . B10 ) . ( C49 . B10 ) ))));
existence
proof
set D33 = ( ( dom C48 ) /\ ( dom C49 ) );
deffunc H2(set) = ( ( C48 . $1 ) . ( C49 . $1 ) );
consider C50 being Function such that L99: (( dom C50 ) = D33 & (for B11 being set holds (B11 in D33 implies ( C50 . B11 ) = H2(B11)))) from FUNCT_1:sch 3;
take C50;
thus L100: thesis by L99;
end;
uniqueness
proof
set D34 = ( ( dom C48 ) /\ ( dom C49 ) );
let C51 , C52 being Function;
assume L101: (( dom C51 ) = D34 & (for B12 being set holds (B12 in ( dom C51 ) implies ( C51 . B12 ) = ( ( C48 . B12 ) . ( C49 . B12 ) ))));
assume L102: (( dom C52 ) = D34 & (for B13 being set holds (B13 in ( dom C52 ) implies ( C52 . B13 ) = ( ( C48 . B13 ) . ( C49 . B13 ) ))));
L103:
now
let C53 being set;
assume L104: C53 in ( dom C51 );
thus L105: ( C51 . C53 ) = ( ( C48 . C53 ) . ( C49 . C53 ) ) by L101 , L104
.= ( C52 . C53 ) by L102 , L104 , L101;
end;
thus L106: thesis by L103 , L101 , L102 , FUNCT_1:2;
end;
end;
registration
let C54 being  Function-yielding Function;
let C55 being  empty Function;
cluster ^^^ C54 , C55 __ ->  empty;
coherence
proof
L108: ( dom ^^^ C54 , C55 __ ) = ( ( dom C54 ) /\ ( dom C55 ) ) by L98
.= ( {} );
thus L109: thesis by L108;
end;
end;
registration
let C56 being  FinSequence-membered set;
cluster C56 -valued ->  Function-yielding for Function;
coherence;
end;
registration
let C57 , C58 being non  empty set;
let C59 being C58 -valued FinSequence;
let C60 being (Function of C58 , C57);
cluster ( C60 * C59 ) -> ( len C59 ) -element for FinSequence;
coherence
proof
reconsider D35 = C59 as (FinSequence of C58) by FOMODEL0:26;
L112: ( len ( C60 * D35 ) ) = ( len D35 ) by FINSEQ_2:33;
thus L113: thesis by L112 , CARD_1:def 7;
end;
end;
registration
let C61 , C62 being non  empty set;
let C63 being (Function of C61 , C62);
let C64 being C61 -valued FinSequence;
cluster ( C63 * C64 ) ->  FinSequence-like;
coherence;
end;
registration
let C65 , C66 being non  empty set;
let C67 being Nat;
let C68 being C67 -element C66 -valued FinSequence;
let C69 being (Function of C66 , C65);
cluster ( C69 * C68 ) -> C67 -element for (FinSequence of C65);
coherence;
end;
L117: (for B14 being non  empty set holds (for B15 being Language holds (for B16 being (B15 , B14)-interpreter-like Function holds (for B17 being  termal (string of B15) holds ( ( abs ( ar B17 ) ) -tuples_on B14 ) = ( dom ( B16 . ( ( B15 -firstChar ) . B17 ) ) ))))) by FUNCT_2:def 1;
theorem
L118: (for R15 being Language holds (for B18 being ( 0 ) -termal (string of R15) holds B18 = <* ( ( R15 -firstChar ) . B18 ) *>))
proof
let R15 being Language;
let C70 being ( 0 ) -termal (string of R15);
reconsider D36 = ( ( R15 -multiCat ) . ( SubTerms C70 ) ) as  empty set;
L119: C70 = ( <* ( ( R15 -firstChar ) . C70 ) *> ^ D36 ) by FOMODEL1:def 37
.= <* ( ( R15 -firstChar ) . C70 ) *>;
thus L120: thesis by L119;
end;
L121: (for R15 being Language holds (for R22 being non  empty set holds (for B19 being (R15 , R22)-interpreter-like Function holds (for B20 being (Function of ( AllTermsOf R15 ) , R22) holds (^^^ ( B19 * ( R15 -firstChar ) ) , ^^^ B20 , ( R15 -subTerms ) __ __ is (Element of ( Funcs (( AllTermsOf R15 ) , R22) )) & ( AllTermsOf R15 ) c= ( dom ( B19 * ( R15 -firstChar ) ) ))))))
proof
let R15 being Language;
let R22 being non  empty set;
let C71 being (R15 , R22)-interpreter-like Function;
set D37 = ( AllTermsOf R15 );
set D38 = ( R15 -firstChar );
set D39 = ( R15 -subTerms );
set D40 = ( AllSymbolsOf R15 );
set D41 = ( AtomicTermsOf R15 );
set D42 = ( R15 -termsOfMaxDepth );
L122: ( dom D38 ) = ( ( D40 * ) \ { ( {} ) } ) by FUNCT_2:def 1;
let C72 being (Function of D37 , R22);
set D43 = ^^^ C72 , D39 __;
set D44 = ^^^ ( C71 * D38 ) , D43 __;
L123: ( dom D43 ) = ( dom D39 ) by L84
.= D37 by FUNCT_2:def 1;
L124: (for B21 being set holds (B21 in D37 implies (B21 in ( dom ( C71 * D38 ) ) & (B21 in ( dom D44 ) implies ( D44 . B21 ) in R22))))
proof
let C73 being set;
assume L125: C73 in D37;
reconsider D45 = C73 as  termal (string of R15) by L125;
set D46 = ( abs ( ar D45 ) );
reconsider D47 = ( D38 . D45 ) as  termal (Element of R15);
reconsider D48 = D47 as  own (Element of R15);
reconsider D49 = D48 as (Element of ( OwnSymbolsOf R15 )) by FOMODEL1:def 19;
L126: (D49 in ( OwnSymbolsOf R15 ) & ( OwnSymbolsOf R15 ) c= ( dom C71 )) by L41;
thus L127: C73 in ( dom ( C71 * D38 ) ) by L126 , L122 , FUNCT_1:11;
reconsider D50 = C73 as (Element of D37) by L125;
reconsider D51 = ( C71 . D48 ) as (Interpreter of D48 , R22);
L128: ( D39 . D50 ) = ( SubTerms D45 ) by FOMODEL1:def 39;
reconsider D52 = ( D39 . D50 ) as D46 -element (FinSequence of D37) by L128 , FINSEQ_1:def 11;
reconsider D53 = ( C72 * D52 ) as D46 -element (FinSequence of R22);
L129: ( len D53 ) = D46 by CARD_1:def 7;
reconsider D54 = D53 as (Element of ( D46 -tuples_on R22 )) by L129 , FINSEQ_2:133;
L130: ( D46 -tuples_on R22 ) c= ( dom ( C71 . D49 ) ) by L117;
L131: D54 in ( dom D51 ) by L130 , TARSKI:def 3;
L132: D50 in D37;
L133: D50 in ( dom D39 ) by L132 , FUNCT_2:def 1;
assume L134: C73 in ( dom D44 );
L135: ( D44 . D45 ) = ( ( ( C71 * D38 ) . D45 ) . ( D43 . D45 ) ) by L134 , L98
.= ( ( C71 . D48 ) . ( D43 . D45 ) ) by L127 , FUNCT_1:12
.= ( D51 . D54 ) by L84 , L133;
thus L136: ( D44 . C73 ) in R22 by L135 , L131 , FUNCT_1:102;
end;
L137: (for B22 being set holds (B22 in D37 implies B22 in ( dom ( C71 * D38 ) ))) by L124;
L138: D37 c= ( dom ( C71 * D38 ) ) by L137 , TARSKI:def 3;
L139: ( dom D44 ) = ( ( dom ( C71 * D38 ) ) /\ D37 ) by L123 , L98
.= D37 by L138 , XBOOLE_1:28;
L140: (for B23 being set holds (B23 in D37 implies ( D44 . B23 ) in R22)) by L139 , L124;
L141: D44 is (Function of D37 , R22) by L140 , L139 , FUNCT_2:3;
thus L142: D44 is (Element of ( Funcs (D37 , R22) )) by L141 , FUNCT_2:8;
thus L143: thesis by L137 , TARSKI:def 3;
end;
definition
let R15 being Language;
let C74 being non  empty set;
let C75 being (Element of C74);
let C76 being (R15 , C74)-interpreter-like Function;
func (C76 , C75) -TermEval -> (Function of ( NAT ) , ( Funcs (( AllTermsOf R15 ) , C74) )) means 
:L144: (( it . ( 0 ) ) = ( ( AllTermsOf R15 ) --> C75 ) & (for R5 being (Element of ( NAT )) holds ( it . ( R5 + 1 ) ) = ^^^ ( C76 * ( R15 -firstChar ) ) , ^^^ (( it . R5 ) qua Function) , ( R15 -subTerms ) __ __));
existence
proof
set D55 = ( AllTermsOf R15 );
set D56 = ( R15 -firstChar );
set D57 = ( R15 -subTerms );
set D58 = ( AllSymbolsOf R15 );
set D59 = ( AtomicTermsOf R15 );
set D60 = ( R15 -termsOfMaxDepth );
set D61 = ( D55 --> C75 );
defpred S2[ set , (Element of ( Funcs (D55 , C74) )) , set ] means $3 = ^^^ ( C76 * D56 ) , ^^^ $2 , D57 __ __;
reconsider D62 = D61 as (Function of D55 , C74);
reconsider D63 = D62 as (Element of ( Funcs (D55 , C74) )) by FUNCT_2:8;
L145: (for B24 being (Element of ( NAT )) holds (for B25 being (Element of ( Funcs (D55 , C74) )) holds (ex B26 being (Element of ( Funcs (D55 , C74) )) st S2[ B24 , B25 , B26 ])))
proof
let R5 being (Element of ( NAT ));
let C77 being (Element of ( Funcs (D55 , C74) ));
reconsider D64 = C77 as (Function of D55 , C74);
reconsider D65 = ^^^ ( C76 * D56 ) , ^^^ D64 , D57 __ __ as (Function of D55 , C74) by L121;
reconsider D66 = D65 as (Element of ( Funcs (D55 , C74) )) by FUNCT_2:8;
take D66;
thus L146: thesis;
end;
consider C78 being (Function of ( NAT ) , ( Funcs (D55 , C74) )) such that L147: (( C78 . ( 0 ) ) = D63 & (for B27 being (Element of ( NAT )) holds S2[ B27 , (( C78 . B27 ) qua (Element of ( Funcs (D55 , C74) ))) , ( C78 . ( B27 + 1 ) ) ])) from RECDEF_1:sch 2(L145);
take C78;
thus L148: thesis by L147;
end;
uniqueness
proof
set D67 = ( AllTermsOf R15 );
set D68 = ( R15 -firstChar );
set D69 = ( R15 -subTerms );
set D70 = ( AllSymbolsOf R15 );
set D71 = ( AtomicTermsOf R15 );
set D72 = ( R15 -termsOfMaxDepth );
set D73 = ( D67 --> C75 );
reconsider D74 = D73 as (Element of ( Funcs (D67 , C74) )) by FUNCT_2:8;
defpred S3[ set , set , set ] means (for B28 being (Element of ( Funcs (D67 , C74) )) holds ($2 = B28 implies $3 = ^^^ ( C76 * D68 ) , ^^^ B28 , D69 __ __));
let C79 , C80 being (Function of ( NAT ) , ( Funcs (D67 , C74) ));
assume L149: (( C79 . ( 0 ) ) = D73 & (for R5 being (Element of ( NAT )) holds ( C79 . ( R5 + 1 ) ) = ^^^ ( C76 * D68 ) , ^^^ ( C79 . R5 ) , D69 __ __));
assume L150: (( C80 . ( 0 ) ) = D73 & (for R5 being (Element of ( NAT )) holds ( C80 . ( R5 + 1 ) ) = ^^^ ( C76 * D68 ) , ^^^ ( C80 . R5 ) , D69 __ __));
L151: ( C79 . ( 0 ) ) = D74 by L149;
L152: (for R2 being Nat holds S3[ R2 , ( C79 . R2 ) , ( C79 . ( R2 + 1 ) ) ])
proof
let R2 being Nat;
reconsider D75 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
let C81 being (Element of ( Funcs (D67 , C74) ));
assume L153: ( C79 . R2 ) = C81;
L154: ( C79 . D75 ) = C81 by L153;
thus L155: thesis by L154 , L149;
end;
L156: ( C80 . ( 0 ) ) = D74 by L150;
L157: (for R2 being Nat holds S3[ R2 , ( C80 . R2 ) , ( C80 . ( R2 + 1 ) ) ])
proof
let R2 being Nat;
reconsider D76 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
let C82 being (Element of ( Funcs (D67 , C74) ));
assume L158: ( C80 . R2 ) = C82;
L159: ( C80 . D76 ) = C82 by L158;
thus L160: thesis by L159 , L150;
end;
L161: (for B29 being Nat holds (for B30 , B31 , B32 being (Element of ( Funcs (D67 , C74) )) holds ((S3[ B29 , B30 , B31 ] & S3[ B29 , B30 , B32 ]) implies B31 = B32)))
proof
let R2 being Nat;
let C83 , C84 , C85 being (Element of ( Funcs (D67 , C74) ));
assume L162: (for B33 being (Element of ( Funcs (D67 , C74) )) holds (C83 = B33 implies C84 = ^^^ ( C76 * D68 ) , ^^^ B33 , D69 __ __));
L163: C84 = ^^^ ( C76 * D68 ) , ^^^ C83 , D69 __ __ by L162;
assume L164: (for B34 being (Element of ( Funcs (D67 , C74) )) holds (C83 = B34 implies C85 = ^^^ ( C76 * D68 ) , ^^^ B34 , D69 __ __));
thus L165: C84 = C85 by L164 , L163;
end;
L166: C79 = C80 from NAT_1:sch 14(L151 , L152 , L156 , L157 , L161);
thus L167: thesis by L166;
end;
end;
L169: (for R15 being Language holds (for R22 being non  empty set holds (for B35 being (Element of R22) holds (for B36 being (R15 , R22)-interpreter-like Function holds (for B37 being  termal (string of R15) holds (for B38 being (Element of ( NAT )) holds (( ( ( (B36 , B35) -TermEval ) . ( B38 + 1 ) ) . B37 ) = ( ( B36 . ( ( R15 -firstChar ) . B37 ) ) . ( ( ( (B36 , B35) -TermEval ) . B38 ) * ( SubTerms B37 ) ) ) & (B37 is ( 0 ) -termal implies ( ( ( (B36 , B35) -TermEval ) . ( B38 + 1 ) ) . B37 ) = ( ( B36 . ( ( R15 -firstChar ) . B37 ) ) . ( {} ) )))))))))
proof
let R15 being Language;
let R22 being non  empty set;
let C86 being (Element of R22);
let C87 being (R15 , R22)-interpreter-like Function;
let C88 being  termal (string of R15);
let R5 being (Element of ( NAT ));
set D77 = ( (C87 , C86) -TermEval );
set D78 = ( R15 -firstChar );
set D79 = ( R15 -subTerms );
set D80 = ( AllTermsOf R15 );
L170: (C88 in D80 & D80 c= ( dom ( C87 * D78 ) )) by L121 , FOMODEL1:def 32;
reconsider D81 = C88 as (Element of D80) by FOMODEL1:def 32;
set D82 = ^^^ ( C87 * D78 ) , ^^^ ( D77 . R5 ) , D79 __ __;
L171: ( dom D79 ) = D80 by FUNCT_2:def 1;
L172: D82 is (Function of D80 , R22) by L121;
L173: ( dom D82 ) = D80 by L172 , FUNCT_2:def 1;
L174: ( ( D77 . ( R5 + 1 ) ) . C88 ) = ( D82 . C88 ) by L144
.= ( ( ( C87 * D78 ) . C88 ) . ( ^^^ ( D77 . R5 ) , D79 __ . C88 ) ) by L170 , L98 , L173
.= ( ( ( C87 * D78 ) . C88 ) . ( ( D77 . R5 ) * ( D79 . D81 ) ) ) by L84 , L171
.= ( ( ( C87 * D78 ) . C88 ) . ( ( D77 . R5 ) * ( SubTerms C88 ) ) ) by FOMODEL1:def 39
.= ( ( C87 . ( D78 . C88 ) ) . ( ( D77 . R5 ) * ( SubTerms C88 ) ) ) by L170 , FUNCT_1:12;
thus L175: ( ( D77 . ( R5 + 1 ) ) . C88 ) = ( ( C87 . ( D78 . C88 ) ) . ( ( D77 . R5 ) * ( SubTerms C88 ) ) ) by L174;
assume L176: C88 is ( 0 ) -termal;
reconsider D83 = C88 as ( 0 ) -termal (string of R15) by L176;
reconsider D84 = ( D78 . D83 ) as  literal (Element of R15);
reconsider D85 = ( C87 . D84 ) as (Interpreter of D84 , R22);
L177: ( ( D77 . ( R5 + 1 ) ) . C88 ) = ( D85 . ( {} ) ) by L174;
thus L178: thesis by L177;
end;
L179: (for R15 being Language holds (for R22 being non  empty set holds (for B39 being (R15 , R22)-interpreter-like Function holds (for B40 , B41 being (Element of R22) holds (for B42 being Nat holds (for B43 being B42 -termal (string of R15) holds (for B44 being Nat holds ( ( ( (B39 , B40) -TermEval ) . ( B42 + 1 ) ) . B43 ) = ( ( ( (B39 , B41) -TermEval ) . ( ( B42 + 1 ) + B44 ) ) . B43 ))))))))
proof
let R15 being Language;
let R22 being non  empty set;
let C89 being (R15 , R22)-interpreter-like Function;
let C90 , C91 being (Element of R22);
set D86 = ( R15 -firstChar );
set D87 = ( R15 -subTerms );
set D88 = ( AllTermsOf R15 );
set D89 = ( R15 -termsOfMaxDepth );
set D90 = ( (C89 , C90) -TermEval );
set D91 = ( (C89 , C91) -TermEval );
set D92 = ( AllSymbolsOf R15 );
defpred S4[ Nat ] means (for B45 being $1 -termal (string of R15) holds (for B46 being Nat holds ( ( D90 . ( $1 + 1 ) ) . B45 ) = ( ( D91 . ( ( $1 + 1 ) + B46 ) ) . B45 )));
L180: S4[ ( 0 ) ]
proof
let C92 being ( 0 ) -termal (string of R15);
let C93 being Nat;
reconsider D93 = C93 as (Element of ( NAT )) by ORDINAL1:def 12;
L181: ( ( D90 . ( ( 0 ) + 1 ) ) . C92 ) = ( ( C89 . ( ( R15 -firstChar ) . C92 ) ) . ( {} ) ) by L169
.= ( ( D91 . ( ( ( 0 ) + 1 ) + D93 ) ) . C92 ) by L169;
thus L182: thesis by L181;
end;
L183: (for B47 being (Element of ( NAT )) holds (S4[ B47 ] implies S4[ ( B47 + 1 ) ]))
proof
let C94 being (Element of ( NAT ));
assume L184: S4[ C94 ];
reconsider D94 = ( C94 + 1 ) as (Element of ( NAT ));
let C95 being ( C94 + 1 ) -termal (string of R15);
let C96 being Nat;
reconsider D95 = ( D94 + C96 ) as (Element of ( NAT ));
reconsider D96 = C95 as  termal (string of R15);
L185: ( ( D90 . D94 ) * ( SubTerms C95 ) ) = ( ( D91 . ( D94 + C96 ) ) * ( SubTerms C95 ) )
proof
set D97 = ( SubTerms C95 );
set D98 = ( abs ( ar C95 ) );
reconsider D99 = D97 as D98 -element (FinSequence of D88) by FINSEQ_1:def 11;
reconsider D100 = D97 as ( D89 . C94 ) -valued Function;
L186: ( len D99 ) = D98 by CARD_1:def 7;
L187: ( dom D100 ) = ( Seg D98 ) by L186 , FINSEQ_1:def 3;
reconsider D101 = ( D90 . D94 ) , D102 = ( D91 . D95 ) as (Function of D88 , R22);
reconsider D103 = ( D101 * D99 ) , D104 = ( D102 * D99 ) as D98 -element (FinSequence of R22);
L188: (( len D103 ) = D98 & ( len D104 ) = D98) by CARD_1:def 7;
L189: (( dom D103 ) = ( Seg D98 ) & ( dom D104 ) = ( Seg D98 )) by L188 , FINSEQ_1:def 3;
L190: (for B48 being set holds (B48 in ( Seg D98 ) implies ( D103 . B48 ) = ( D104 . B48 )))
proof
let C97 being set;
assume L191: C97 in ( Seg D98 );
L192: (( D100 . C97 ) in ( ( D92 * ) \ { ( {} ) } ) & ( D100 . C97 ) in ( D89 . C94 )) by L191 , L187 , FUNCT_1:102;
reconsider D105 = ( D100 . C97 ) as C94 -termal (string of R15) by L192 , FOMODEL1:def 33;
L193: ( D103 . C97 ) = ( ( D90 . D94 ) . D105 ) by L191 , L189 , FUNCT_1:12
.= ( D102 . ( D100 . C97 ) ) by L184
.= ( D104 . C97 ) by L191 , L189 , FUNCT_1:12;
thus L194: thesis by L193;
end;
thus L195: thesis by L190 , L189 , FUNCT_1:2;
end;
L196: ( ( D90 . ( D94 + 1 ) ) . D96 ) = ( ( C89 . ( D86 . D96 ) ) . ( ( D91 . D95 ) * ( SubTerms C95 ) ) ) by L169 , L185
.= ( ( D91 . ( D95 + 1 ) ) . D96 ) by L169;
thus L197: thesis by L196;
end;
L198: (for B49 being (Element of ( NAT )) holds S4[ B49 ]) from NAT_1:sch 1(L180 , L183);
L199:
now
let C98 being Nat;
reconsider D106 = C98 as (Element of ( NAT )) by ORDINAL1:def 12;
L200: S4[ D106 ] by L198;
thus L201: S4[ C98 ] by L200;
end;
thus L202: thesis by L199;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C99 being (R15 , R22)-interpreter-like Function;
let C100 being (Element of ( AllTermsOf R15 ));
func C99 -TermEval C100 -> (Element of R22) means 
:L203: (for B50 being (Element of R22) holds (for R5 being (Element of ( NAT )) holds (C100 in ( ( R15 -termsOfMaxDepth ) . R5 ) implies it = ( ( ( (C99 , B50) -TermEval ) . ( R5 + 1 ) ) . C100 ))));
existence
proof
set D107 = ( R15 -termsOfMaxDepth );
set D108 = ( AllTermsOf R15 );
consider R5 being (Element of ( NAT )) such that L204: C100 in ( D107 . R5 ) by FOMODEL1:5;
set D109 = the (Element of R22);
reconsider D110 = C100 as (string of R15);
reconsider D111 = D110 as R5 -termal (string of R15) by L204 , FOMODEL1:def 33;
reconsider D112 = ( R5 + 1 ) as (Element of ( NAT ));
reconsider D113 = ( ( (C99 , D109) -TermEval ) . D112 ) as (Function of D108 , R22);
reconsider D114 = ( D113 . C100 ) as (Element of R22);
take D114;
let C101 being (Element of R22);
let R6 being (Element of ( NAT ));
assume L205: C100 in ( D107 . R6 );
reconsider D115 = D110 as R6 -termal (string of R15) by L205 , FOMODEL1:def 33;
L206: D114 = ( ( ( (C99 , C101) -TermEval ) . ( ( R5 + 1 ) + R6 ) ) . D111 ) by L179
.= ( ( ( (C99 , C101) -TermEval ) . ( ( R6 + 1 ) + R5 ) ) . D115 )
.= ( ( ( (C99 , C101) -TermEval ) . ( R6 + 1 ) ) . D115 ) by L179;
thus L207: thesis by L206;
end;
uniqueness
proof
set D116 = ( R15 -termsOfMaxDepth );
set D117 = ( AllTermsOf R15 );
let C102 , C103 being (Element of R22);
assume L208: (for B51 being (Element of R22) holds (for R5 being (Element of ( NAT )) holds (C100 in ( D116 . R5 ) implies C102 = ( ( ( (C99 , B51) -TermEval ) . ( R5 + 1 ) ) . C100 ))));
assume L209: (for B52 being (Element of R22) holds (for R6 being (Element of ( NAT )) holds (C100 in ( D116 . R6 ) implies C103 = ( ( ( (C99 , B52) -TermEval ) . ( R6 + 1 ) ) . C100 ))));
consider R5 being (Element of ( NAT )) such that L210: C100 in ( D116 . R5 ) by FOMODEL1:5;
set D118 = the (Element of R22);
L211: C102 = ( ( ( (C99 , D118) -TermEval ) . ( R5 + 1 ) ) . C100 ) by L208 , L210
.= C103 by L209 , L210;
thus L212: thesis by L211;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C104 being (R15 , R22)-interpreter-like Function;
func C104 -TermEval -> (Function of ( AllTermsOf R15 ) , R22) means 
:L214: (for B53 being (Element of ( AllTermsOf R15 )) holds ( it . B53 ) = ( C104 -TermEval B53 ));
existence
proof
set D119 = ( AllTermsOf R15 );
deffunc H3((Element of D119)) = ( C104 -TermEval $1 );
consider C105 being (Function of D119 , R22) such that L215: (for B54 being (Element of D119) holds ( C105 . B54 ) = H3(B54)) from FUNCT_2:sch 4;
take C105;
thus L216: thesis by L215;
end;
uniqueness
proof
set D120 = ( AllTermsOf R15 );
let C106 , C107 being (Function of D120 , R22);
assume L217: (for B55 being (Element of ( AllTermsOf R15 )) holds ( C106 . B55 ) = ( C104 -TermEval B55 ));
assume L218: (for B56 being (Element of ( AllTermsOf R15 )) holds ( C107 . B56 ) = ( C104 -TermEval B56 ));
L219:
now
let C108 being (Element of D120);
thus L220: ( C106 . C108 ) = ( C104 -TermEval C108 ) by L217
.= ( C107 . C108 ) by L218;
end;
thus L221: thesis by L219 , FUNCT_2:63;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C109 being (R15 , R22)-interpreter-like Function;
func C109 === -> Function equals 
( C109 +* ( ( TheEqSymbOf R15 ) .--> ( R22 -deltaInterpreter ) ) );
coherence;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C110 being (R15 , R22)-interpreter-like Function;
let C111 being set;
attr C111 is C110 -extension
means
:L224: C111 = ( C110 === );
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C112 being (R15 , R22)-interpreter-like Function;
cluster ( C112 === ) -> C112 -extension for Function;
coherence by L224;
cluster C112 -extension ->  Function-like for set;
coherence
proof
let R12 being set;
assume L226: R12 is C112 -extension;
L227: R12 = ( C112 === ) by L226 , L224;
thus L228: thesis by L227;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C113 being (R15 , R22)-interpreter-like Function;
cluster C113 -extension for Function;
existence
proof
take D121 = ( C113 === );
thus L230: thesis;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C114 being (R15 , R22)-interpreter-like Function;
cluster ( C114 === ) -> (R15 , R22)-interpreter-like;
coherence
proof
set D122 = ( TheEqSymbOf R15 );
set D123 = ( D122 .--> ( R22 -deltaInterpreter ) );
set D124 = ( OwnSymbolsOf R15 );
set D125 = ( AtomicFormulaSymbolsOf R15 );
L232:
now
let C115 being  own (Element of R15);
L233: C115 in D124 by FOMODEL1:def 19;
L234: (not C115 in ( D125 \ D124 )) by L233 , XBOOLE_0:def 5;
L235: (not C115 in { D122 }) by L234 , FOMODEL1:9;
L236: (not C115 in ( dom D123 )) by L235;
L237: ( ( C114 === ) . C115 ) = ( C114 . C115 ) by L236 , FUNCT_4:11;
thus L238: ( ( C114 === ) . C115 ) is (Interpreter of C115 , R22) by L237;
end;
thus L239: ( C114 === ) is (Interpreter of R15 , R22) by L232 , L24;
thus L240: thesis;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C116 being (R15 , R22)-interpreter-like Function;
let C117 being C116 -extension Function;
let C118 being  ofAtomicFormula (Element of R15);
redefine func C117 . C118 -> (Interpreter of C118 , R22);

coherence
proof
set D126 = (the adicity of R15);
set D127 = ( TheEqSymbOf R15 );
set D128 = ( R22 -deltaInterpreter );
set D129 = ( D127 .--> D128 );
set D130 = ( ar C118 );
set D131 = ( AtomicFormulaSymbolsOf R15 );
set D132 = ( OwnSymbolsOf R15 );
reconsider D133 = C118 as (Element of D131) by FOMODEL1:def 20;
reconsider D134 = D127 as  ofAtomicFormula (Element of R15);
L242: ( ar D134 ) = ( - 2 ) by FOMODEL1:def 23;
L243: ( abs ( ar D134 ) ) = ( - ( - 2 ) ) by L242 , ABSVALUE:def 1
.= 2;
L244: C117 = ( C116 === ) by L224;
per cases ;
suppose L245: C118 is  own;

reconsider D135 = C118 as  own (Element of R15) by L245;
L246: ( ( C116 === ) . D135 ) is (Interpreter of C118 , R22);
thus L247: thesis by L246 , L224;
end;
suppose L248: (not C118 is  own);

L249: (not D133 in D132) by L248 , FOMODEL1:def 19;
L250: D133 in ( D131 \ D132 ) by L249 , XBOOLE_0:def 5;
L251: D133 in { D127 } by L250 , FOMODEL1:9;
L252: C118 = D127 by L251 , TARSKI:def 1;
L253: (( C117 . C118 ) is (Function of ( ( abs D130 ) -tuples_on R22 ) , ( BOOLEAN )) & C118 is  relational) by L252 , L243 , L244 , FUNCT_7:94;
thus L254: thesis by L253 , L4;
end;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C119 being (R15 , R22)-interpreter-like Function;
let C120 being  0wff (string of R15);
func C119 -AtomicEval C120 equals 
( ( ( C119 === ) . ( ( R15 -firstChar ) . C120 ) ) . ( ( C119 -TermEval ) * ( SubTerms C120 ) ) );
coherence;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C121 being (R15 , R22)-interpreter-like Function;
let C122 being  0wff (string of R15);
redefine func C121 -AtomicEval C122 -> (Element of ( BOOLEAN ));

coherence
proof
set D136 = ( R15 -firstChar );
set D137 = ( C121 -TermEval );
set D138 = ( AllTermsOf R15 );
reconsider D139 = ( D136 . C122 ) as  relational (Element of R15);
set D140 = ( abs ( ar D139 ) );
reconsider D141 = ( ( C121 === ) . D139 ) as (Interpreter of D139 , R22);
reconsider D142 = D141 as (Function of ( D140 -tuples_on R22 ) , ( BOOLEAN )) by L4;
reconsider D143 = ( SubTerms C122 ) as D140 -element (FinSequence of D138) by FINSEQ_1:def 11;
reconsider D144 = ( D137 * D143 ) as D140 -element (FinSequence of R22);
L258: ( len D144 ) = D140 by CARD_1:def 7;
reconsider D145 = D144 as (Element of ( D140 -tuples_on R22 )) by L258 , FINSEQ_2:133;
L259: ( D142 . D145 ) is (Element of ( BOOLEAN ));
thus L260: thesis by L259;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C123 being (R15 , R22)-interpreter-like Function;
cluster ( C123 | ( OwnSymbolsOf R15 ) ) -> ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) ) -valued for Function;
coherence
proof
set D146 = ( OwnSymbolsOf R15 );
set D147 = ( C123 | D146 );
set D148 = ( dom D147 );
set D149 = ( R22 \/ ( BOOLEAN ) );
L262:
now
let C124 being set;
assume L263: C124 in ( rng D147 );
L264: C124 in ( D147 .: D148 ) by L263 , RELAT_1:113;
consider R12 being set such that L265: (R12 in D148 & R12 in D148 & C124 = ( D147 . R12 )) by L264 , FUNCT_1:def 6;
L266: R12 in D146 by L265;
reconsider D150 = R12 as  own (Element of R15) by L266 , FOMODEL1:def 19;
reconsider D151 = ( abs ( ar D150 ) ) as (Element of ( NAT ));
reconsider D152 = ( D151 -tuples_on R22 ) as (Subset of ( R22 * )) by FINSEQ_2:134;
L267: D149 c= D149;
reconsider D153 = D149 as (Subset of D149) by L267;
L268: ( D147 . R12 ) = ( C123 . D150 ) by L265 , FUNCT_1:49;
reconsider D154 = ( D147 . R12 ) as (Function of D152 , D153) by L268;
L269: [: D152 , D153 :] c= [: ( R22 * ) , D149 :];
reconsider D155 = D154 as (Relation of ( R22 * ) , D149) by L269 , XBOOLE_1:1;
L270: D155 is (PartFunc of ( R22 * ) , D149);
thus L271: C124 in ( PFuncs (( R22 * ) , D149) ) by L270 , L265 , PARTFUN1:45;
end;
L272: ( rng D147 ) c= ( PFuncs (( R22 * ) , D149) ) by L262 , TARSKI:def 3;
thus L273: thesis by L272 , RELAT_1:def 19;
end;
cluster ( C123 | ( OwnSymbolsOf R15 ) ) -> (R15 , R22)-interpreter-like for Function;
coherence
proof
set D156 = ( OwnSymbolsOf R15 );
set D157 = ( C123 | D156 );
set D158 = ( dom D157 );
set D159 = ( R22 \/ ( BOOLEAN ) );
L274:
now
let C125 being  own (Element of R15);
L275: C125 in D156 by FOMODEL1:def 19;
L276: ( D157 . C125 ) = ( C123 . C125 ) by L275 , FUNCT_1:49;
thus L277: ( D157 . C125 ) is (Interpreter of C125 , R22) by L276;
end;
L278: D157 is (Interpreter of R15 , R22) by L274 , L24;
thus L279: thesis by L278 , L31;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C126 being (R15 , R22)-interpreter-like Function;
cluster ( C126 | ( OwnSymbolsOf R15 ) ) ->  total for ( OwnSymbolsOf R15 ) -defined ( OwnSymbolsOf R15 ) -defined ( OwnSymbolsOf R15 ) -defined ( OwnSymbolsOf R15 ) -defined Relation;
coherence
proof
set D160 = ( OwnSymbolsOf R15 );
set D161 = ( C126 | D160 );
set D162 = ( dom D161 );
set D163 = ( R22 \/ ( BOOLEAN ) );
L281: (D160 c= ( dom D161 ) & ( dom D161 ) c= D160) by L41;
L282: ( dom D161 ) = D160 by L281 , XBOOLE_0:def 10;
thus L283: thesis by L282 , PARTFUN1:def 2;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
func R22 -InterpretersOf R15 equals 
{ B57 where B57 is (Element of ( Funcs (( OwnSymbolsOf R15 ) , ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) )) )) : B57 is (R15 , R22)-interpreter-like };
coherence;
end;
definition
let R15 being Language;
let R22 being non  empty set;
redefine func R22 -InterpretersOf R15 -> (Subset of ( Funcs (( OwnSymbolsOf R15 ) , ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) )) ));

coherence
proof
set D164 = ( R22 -InterpretersOf R15 );
set D165 = ( OwnSymbolsOf R15 );
set D166 = ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) );
defpred S5[ (Element of ( Funcs (D165 , D166) )) ] means $1 is (R15 , R22)-interpreter-like;
L286: { B58 where B58 is (Element of ( Funcs (D165 , D166) )) : S5[ B58 ] } is (Subset of ( Funcs (D165 , D166) )) from DOMAIN_1:sch 7;
thus L287: thesis by L286;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
cluster ( R22 -InterpretersOf R15 ) -> non  empty;
coherence
proof
set D167 = the (R15 , R22)-interpreter-like Function;
set D168 = ( OwnSymbolsOf R15 );
set D169 = ( D167 | D168 );
set D170 = ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) );
L289: (( dom D169 ) c= D168 & ( rng D169 ) c= D170);
reconsider D171 = D169 as (Relation of D168 , D170) by L289 , RELSET_1:4;
reconsider D172 = D171 as (Element of ( Funcs (D168 , D170) )) by FUNCT_2:8;
L290: (ex B59 being (Element of ( Funcs (D168 , D170) )) st (D169 = B59 & B59 is (R15 , R22)-interpreter-like))
proof
take D172;
thus L291: thesis;
end;
L292: D169 in ( R22 -InterpretersOf R15 ) by L290;
thus L293: thesis by L292;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
cluster  -> (R15 , R22)-interpreter-like for (Element of ( R22 -InterpretersOf R15 ));
coherence
proof
set D173 = ( R22 -InterpretersOf R15 );
set D174 = ( OwnSymbolsOf R15 );
set D175 = ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) );
let C127 being (Element of D173);
L295: C127 in D173;
consider C128 being (Element of ( Funcs (D174 , D175) )) such that L296: (C127 = C128 & C128 is (R15 , R22)-interpreter-like) by L295;
thus L297: thesis by L296;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
func R15 -TruthEval R22 -> (Function of [: ( R22 -InterpretersOf R15 ) , ( AtomicFormulasOf R15 ) :] , ( BOOLEAN )) means 
:L299: (for B60 being (Element of ( R22 -InterpretersOf R15 )) holds (for B61 being (Element of ( AtomicFormulasOf R15 )) holds ( it . (B60 , B61) ) = ( B60 -AtomicEval B61 )));
existence
proof
set D176 = ( R22 -InterpretersOf R15 );
set D177 = ( AtomicFormulasOf R15 );
deffunc H4((Element of D176) , (Element of D177)) = (( $1 -AtomicEval $2 ) qua (Element of ( BOOLEAN )));
consider C129 being (Function of [: D176 , D177 :] , ( BOOLEAN )) such that L300: (for B62 being (Element of D176) holds (for B63 being (Element of D177) holds ( C129 . (B62 , B63) ) = H4(B62 , B63))) from BINOP_1:sch 4;
take C129;
thus L301: (for B64 being (Element of D176) holds (for B65 being (Element of D177) holds ( C129 . (B64 , B65) ) = ( B64 -AtomicEval B65 ))) by L300;
end;
uniqueness
proof
set D178 = ( R22 -InterpretersOf R15 );
set D179 = ( AtomicFormulasOf R15 );
set D180 = ( BOOLEAN );
let C130 , C131 being (Function of [: D178 , D179 :] , D180);
deffunc H5((Element of D178) , (Element of D179)) = ( $1 -AtomicEval $2 );
assume that
L302: (for B66 being (Element of D178) holds (for B67 being (Element of D179) holds ( C130 . (B66 , B67) ) = H5(B66 , B67)))
and
L303: (for B68 being (Element of D178) holds (for B69 being (Element of D179) holds ( C131 . (B68 , B69) ) = H5(B68 , B69)));
L304:
now
let C132 being (Element of D178);
let C133 being (Element of D179);
thus L305: ( C130 . (C132 , C133) ) = H5(C132 , C133) by L302
.= ( C131 . (C132 , C133) ) by L303;
end;
thus L306: C130 = C131 by L304 , BINOP_1:2;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C134 being (Element of ( R22 -InterpretersOf R15 ));
let C135 being (PartFunc of [: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
let C136 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ));
func C135 -ExFunctor (C134 , C136) -> (Element of ( BOOLEAN )) equals 
:L308: ( TRUE ) if (ex B70 being (Element of R22) st (ex B71 being  literal (Element of R15) st (( C136 . 1 ) = B71 & ( C135 . (( (B71 , B70) ReassignIn C134 ) , ( C136 /^ 1 )) ) = ( TRUE )))) otherwise ( FALSE );
coherence;
consistency;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C137 being (Element of ( PFuncs ([: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
func ExIterator C137 -> (PartFunc of [: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) means 
:L310: ((for B72 being (Element of ( R22 -InterpretersOf R15 )) holds (for B73 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) holds ([ B72 , B73 ] in ( dom it ) iff (ex B74 being  literal (Element of R15) st (ex B75 being (string of R15) st ([ B72 , B75 ] in ( dom C137 ) & B73 = ( <* B74 *> ^ B75 ))))))) & (for B76 being (Element of ( R22 -InterpretersOf R15 )) holds (for B77 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) holds ([ B76 , B77 ] in ( dom it ) implies ( it . (B76 , B77) ) = ( C137 -ExFunctor (B76 , B77) )))));
existence
proof
set D181 = ( AllSymbolsOf R15 );
set D182 = ( R22 -InterpretersOf R15 );
set D183 = ( ( D181 * ) \ { ( {} ) } );
deffunc H6((Element of D182) , (Element of D183)) = ( C137 -ExFunctor ($1 , $2) );
defpred S6[ (Element of D182) , (Element of D183) ] means (ex B78 being  literal (Element of R15) st (ex B79 being (string of R15) st ([ $1 , B79 ] in ( dom C137 ) & $2 = ( <* B78 *> ^ B79 ))));
L311: (for B80 being (Element of D182) holds (for B81 being (Element of D183) holds (S6[ B80 , B81 ] implies H6(B80 , B81) in ( BOOLEAN ))));
consider C138 being (PartFunc of [: D182 , D183 :] , ( BOOLEAN )) such that L312: ((for B82 being (Element of D182) holds (for B83 being (Element of D183) holds ([ B82 , B83 ] in ( dom C138 ) iff S6[ B82 , B83 ]))) & (for B84 being (Element of D182) holds (for B85 being (Element of D183) holds ([ B84 , B85 ] in ( dom C138 ) implies ( C138 . (B84 , B85) ) = H6(B84 , B85))))) from BINOP_1:sch 8(L311);
take C138;
thus L313: thesis by L312;
end;
uniqueness
proof
set D184 = ( AllSymbolsOf R15 );
set D185 = ( R22 -InterpretersOf R15 );
set D186 = ( ( D184 * ) \ { ( {} ) } );
set D187 = [: D185 , D186 :];
let C139 , C140 being (PartFunc of D187 , ( BOOLEAN ));
defpred S7[ (Element of D185) , (Element of D186) ] means (ex B86 being  literal (Element of R15) st (ex B87 being (string of R15) st ([ $1 , B87 ] in ( dom C137 ) & $2 = ( <* B86 *> ^ B87 ))));
assume that
L314: (for B88 being (Element of D185) holds (for B89 being (Element of D186) holds ([ B88 , B89 ] in ( dom C139 ) iff S7[ B88 , B89 ])))
and
L315: (for B90 being (Element of D185) holds (for B91 being (Element of D186) holds ([ B90 , B91 ] in ( dom C139 ) implies ( C139 . (B90 , B91) ) = ( C137 -ExFunctor (B90 , B91) ))));
assume that
L316: (for B92 being (Element of D185) holds (for B93 being (Element of D186) holds ([ B92 , B93 ] in ( dom C140 ) iff S7[ B92 , B93 ])))
and
L317: (for B94 being (Element of D185) holds (for B95 being (Element of D186) holds ([ B94 , B95 ] in ( dom C140 ) implies ( C140 . (B94 , B95) ) = ( C137 -ExFunctor (B94 , B95) ))));
L318:
now
let C141 being set;
assume L319: C141 in ( dom C139 );
reconsider D188 = C141 as (Element of D187) by L319;
consider C142 , C143 being set such that L320: (C142 in D185 & C143 in D186 & D188 = [ C142 , C143 ]) by ZFMISC_1:def 2;
reconsider D189 = C142 as (Element of D185) by L320;
reconsider D190 = C143 as (Element of D186) by L320;
L321: S7[ D189 , D190 ] by L314 , L319 , L320;
thus L322: C141 in ( dom C140 ) by L321 , L316 , L320;
end;
L323: ( dom C139 ) c= ( dom C140 ) by L318 , TARSKI:def 3;
L324:
now
let C144 being set;
assume L325: C144 in ( dom C140 );
reconsider D191 = C144 as (Element of D187) by L325;
consider C145 , C146 being set such that L326: (C145 in D185 & C146 in D186 & D191 = [ C145 , C146 ]) by ZFMISC_1:def 2;
reconsider D192 = C145 as (Element of D185) by L326;
reconsider D193 = C146 as (Element of D186) by L326;
L327: S7[ D192 , D193 ] by L316 , L325 , L326;
thus L328: C144 in ( dom C139 ) by L327 , L314 , L326;
end;
L329: ( dom C140 ) c= ( dom C139 ) by L324 , TARSKI:def 3;
L330: ( dom C140 ) = ( dom C139 ) by L329 , L323 , XBOOLE_0:def 10;
L331:
now
let C147 being set;
assume L332: C147 in ( dom C139 );
reconsider D194 = C147 as (Element of D187) by L332;
consider C148 , C149 being set such that L333: (C148 in D185 & C149 in D186 & D194 = [ C148 , C149 ]) by ZFMISC_1:def 2;
reconsider D195 = C148 as (Element of D185) by L333;
reconsider D196 = C149 as (Element of D186) by L333;
L334: ( C139 . C147 ) = ( C139 . (D195 , D196) ) by L333
.= ( C137 -ExFunctor (D195 , D196) ) by L315 , L333 , L332
.= ( C140 . (D195 , D196) ) by L317 , L333 , L332 , L323
.= ( C140 . C147 ) by L333;
thus L335: ( C139 . C147 ) = ( C140 . C147 ) by L334;
end;
thus L336: thesis by L331 , L330 , FUNCT_1:2;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C150 being (PartFunc of [: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
let C151 being (Element of ( R22 -InterpretersOf R15 ));
let C152 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ));
func C150 -NorFunctor (C151 , C152) -> (Element of ( BOOLEAN )) equals 
:L338: ( TRUE ) if (ex B96 , B97 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) st ([ C151 , B96 ] in ( dom C150 ) & ( C150 . (C151 , B96) ) = ( FALSE ) & ( C150 . (C151 , B97) ) = ( FALSE ) & C152 = ( ( <* ( TheNorSymbOf R15 ) *> ^ B96 ) ^ B97 ))) otherwise ( FALSE );
coherence;
consistency;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C153 being (Element of ( PFuncs ([: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
func NorIterator C153 -> (PartFunc of [: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) means 
:L340: ((for B98 being (Element of ( R22 -InterpretersOf R15 )) holds (for B99 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) holds ([ B98 , B99 ] in ( dom it ) iff (ex B100 , B101 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) st (B99 = ( ( <* ( TheNorSymbOf R15 ) *> ^ B100 ) ^ B101 ) & [ B98 , B100 ] in ( dom C153 ) & [ B98 , B101 ] in ( dom C153 )))))) & (for B102 being (Element of ( R22 -InterpretersOf R15 )) holds (for B103 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) holds ([ B102 , B103 ] in ( dom it ) implies ( it . (B102 , B103) ) = ( C153 -NorFunctor (B102 , B103) )))));
existence
proof
set D197 = ( AllSymbolsOf R15 );
set D198 = ( R22 -InterpretersOf R15 );
set D199 = ( ( D197 * ) \ { ( {} ) } );
reconsider D200 = C153 as (PartFunc of [: D198 , D199 :] , ( BOOLEAN ));
deffunc H7((Element of D198) , (Element of D199)) = ( D200 -NorFunctor ($1 , $2) );
defpred S8[ (Element of D198) , (Element of D199) ] means (ex B104 , B105 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) st ($2 = ( ( <* ( TheNorSymbOf R15 ) *> ^ B104 ) ^ B105 ) & [ $1 , B104 ] in ( dom D200 ) & [ $1 , B105 ] in ( dom D200 )));
L341: (for B106 being (Element of D198) holds (for B107 being (Element of D199) holds (S8[ B106 , B107 ] implies H7(B106 , B107) in ( BOOLEAN ))));
consider C154 being (PartFunc of [: D198 , D199 :] , ( BOOLEAN )) such that L342: ((for B108 being (Element of D198) holds (for B109 being (Element of D199) holds ([ B108 , B109 ] in ( dom C154 ) iff S8[ B108 , B109 ]))) & (for B110 being (Element of D198) holds (for B111 being (Element of D199) holds ([ B110 , B111 ] in ( dom C154 ) implies ( C154 . (B110 , B111) ) = H7(B110 , B111))))) from BINOP_1:sch 8(L341);
take C154;
thus L343: thesis by L342;
end;
uniqueness
proof
set D201 = ( AllSymbolsOf R15 );
set D202 = ( R22 -InterpretersOf R15 );
set D203 = ( ( D201 * ) \ { ( {} ) } );
set D204 = [: D202 , D203 :];
deffunc H8((Element of D202) , (Element of D203)) = ( C153 -NorFunctor ($1 , $2) );
defpred S9[ (Element of D202) , (Element of D203) ] means (ex B112 , B113 being (Element of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) st ($2 = ( ( <* ( TheNorSymbOf R15 ) *> ^ B112 ) ^ B113 ) & [ $1 , B112 ] in ( dom C153 ) & [ $1 , B113 ] in ( dom C153 )));
let C155 , C156 being (PartFunc of D204 , ( BOOLEAN ));
assume that
L344: (for B114 being (Element of D202) holds (for B115 being (Element of D203) holds ([ B114 , B115 ] in ( dom C155 ) iff S9[ B114 , B115 ])))
and
L345: (for B116 being (Element of D202) holds (for B117 being (Element of D203) holds ([ B116 , B117 ] in ( dom C155 ) implies ( C155 . (B116 , B117) ) = H8(B116 , B117))));
assume that
L346: (for B118 being (Element of D202) holds (for B119 being (Element of D203) holds ([ B118 , B119 ] in ( dom C156 ) iff S9[ B118 , B119 ])))
and
L347: (for B120 being (Element of D202) holds (for B121 being (Element of D203) holds ([ B120 , B121 ] in ( dom C156 ) implies ( C156 . (B120 , B121) ) = H8(B120 , B121))));
L348:
now
let C157 being set;
assume L349: C157 in ( dom C155 );
reconsider D205 = C157 as (Element of D204) by L349;
consider C158 , C159 being set such that L350: (C158 in D202 & C159 in D203 & D205 = [ C158 , C159 ]) by ZFMISC_1:def 2;
reconsider D206 = C158 as (Element of D202) by L350;
reconsider D207 = C159 as (Element of D203) by L350;
L351: S9[ D206 , D207 ] by L344 , L349 , L350;
thus L352: C157 in ( dom C156 ) by L351 , L346 , L350;
end;
L353: ( dom C155 ) c= ( dom C156 ) by L348 , TARSKI:def 3;
L354:
now
let C160 being set;
assume L355: C160 in ( dom C156 );
reconsider D208 = C160 as (Element of D204) by L355;
consider C161 , C162 being set such that L356: (C161 in D202 & C162 in D203 & D208 = [ C161 , C162 ]) by ZFMISC_1:def 2;
reconsider D209 = C161 as (Element of D202) by L356;
reconsider D210 = C162 as (Element of D203) by L356;
L357: S9[ D209 , D210 ] by L346 , L355 , L356;
thus L358: C160 in ( dom C155 ) by L357 , L344 , L356;
end;
L359: ( dom C156 ) c= ( dom C155 ) by L354 , TARSKI:def 3;
L360: ( dom C156 ) = ( dom C155 ) by L359 , L353 , XBOOLE_0:def 10;
L361:
now
let C163 being set;
assume L362: C163 in ( dom C155 );
reconsider D211 = C163 as (Element of D204) by L362;
consider C164 , C165 being set such that L363: (C164 in D202 & C165 in D203 & D211 = [ C164 , C165 ]) by ZFMISC_1:def 2;
reconsider D212 = C164 as (Element of D202) by L363;
reconsider D213 = C165 as (Element of D203) by L363;
L364: ( C155 . C163 ) = ( C155 . (D212 , D213) ) by L363
.= H8(D212 , D213) by L345 , L363 , L362
.= ( C156 . (D212 , D213) ) by L347 , L363 , L362 , L353
.= ( C156 . C163 ) by L363;
thus L365: ( C155 . C163 ) = ( C156 . C163 ) by L364;
end;
thus L366: thesis by L361 , L360 , FUNCT_1:2;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
func (R15 , R22) -TruthEval -> (Function of ( NAT ) , ( PFuncs ([: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) )) means 
:L368: (( it . ( 0 ) ) = ( R15 -TruthEval R22 ) & (for R5 being (Element of ( NAT )) holds ( it . ( R5 + 1 ) ) = ( ( ( ExIterator ( it . R5 ) ) +* ( NorIterator ( it . R5 ) ) ) +* ( it . R5 ) )));
existence
proof
set D214 = ( AllSymbolsOf R15 );
set D215 = ( R22 -InterpretersOf R15 );
set D216 = ( AtomicFormulasOf R15 );
set D217 = ( ( D214 * ) \ { ( {} ) } );
set D218 = [: D215 , D217 :];
reconsider D219 = D215 as (Subset of D215) by XBOOLE_0:def 10;
reconsider D220 = ( BOOLEAN ) as (Subset of ( BOOLEAN )) by XBOOLE_0:def 10;
reconsider D221 = [: D219 , D216 :] as (Subset of D218);
L369: [: D221 , D220 :] c= [: D218 , ( BOOLEAN ) :];
L370: ( R15 -TruthEval R22 ) is (PartFunc of D218 , ( BOOLEAN )) by L369 , XBOOLE_1:1;
reconsider D222 = ( R15 -TruthEval R22 ) as (Element of ( PFuncs (D218 , ( BOOLEAN )) )) by L370 , PARTFUN1:45;
deffunc H9((Element of ( PFuncs (D218 , ( BOOLEAN )) ))) = ( ( ( ExIterator $1 ) +* ( NorIterator $1 ) ) +* $1 );
defpred S10[ set , (Element of ( PFuncs (D218 , ( BOOLEAN )) )) , set ] means $3 = H9($2);
L371: (for B122 being (Element of ( NAT )) holds (for B123 being (Element of ( PFuncs (D218 , ( BOOLEAN )) )) holds (ex B124 being (Element of ( PFuncs (D218 , ( BOOLEAN )) )) st S10[ B122 , B123 , B124 ])))
proof
let C166 being (Element of ( NAT ));
let C167 being (Element of ( PFuncs (D218 , ( BOOLEAN )) ));
reconsider D223 = H9(C167) as (Element of ( PFuncs (D218 , ( BOOLEAN )) )) by PARTFUN1:45;
take D224 = D223;
thus L372: thesis;
end;
consider C168 being (Function of ( NAT ) , ( PFuncs (D218 , ( BOOLEAN )) )) such that L373: (( C168 . ( 0 ) ) = D222 & (for B125 being (Element of ( NAT )) holds S10[ B125 , (( C168 . B125 ) qua (Element of ( PFuncs (D218 , ( BOOLEAN )) ))) , ( C168 . ( B125 + 1 ) ) ])) from RECDEF_1:sch 2(L371);
take C168;
thus L374: ( C168 . ( 0 ) ) = ( R15 -TruthEval R22 ) by L373;
thus L375: (for R5 being (Element of ( NAT )) holds ( C168 . ( R5 + 1 ) ) = ( ( ( ExIterator ( C168 . R5 ) ) +* ( NorIterator ( C168 . R5 ) ) ) +* ( C168 . R5 ) )) by L373;
end;
uniqueness
proof
set D225 = ( AllSymbolsOf R15 );
set D226 = ( R22 -InterpretersOf R15 );
set D227 = ( AtomicFormulasOf R15 );
set D228 = ( ( D225 * ) \ { ( {} ) } );
set D229 = [: D226 , D228 :];
set D230 = ( R15 -TruthEval R22 );
L376: ([: D226 , D227 :] c= D229 & ( BOOLEAN ) c= ( BOOLEAN )) by ZFMISC_1:96;
L377: (( dom D230 ) c= D229 & ( rng D230 ) c= ( BOOLEAN )) by L376 , XBOOLE_1:1;
L378: D230 is (Relation of D229 , ( BOOLEAN )) by L377 , RELSET_1:4;
reconsider D231 = D230 as (Element of ( PFuncs (D229 , ( BOOLEAN )) )) by L378 , PARTFUN1:45;
deffunc H10(set , (Element of ( PFuncs (D229 , ( BOOLEAN )) ))) = ( ( ( ExIterator $2 ) +* ( NorIterator $2 ) ) +* $2 );
defpred S11[ set , set , set ] means (for B126 being (Element of ( PFuncs (D229 , ( BOOLEAN )) )) holds ($2 = B126 implies $3 = H10($1 , B126)));
let C169 , C170 being (Function of ( NAT ) , ( PFuncs (D229 , ( BOOLEAN )) ));
assume L379: (( C169 . ( 0 ) ) = D230 & (for R5 being (Element of ( NAT )) holds ( C169 . ( R5 + 1 ) ) = ( ( ( ExIterator ( C169 . R5 ) ) +* ( NorIterator ( C169 . R5 ) ) ) +* ( C169 . R5 ) )));
assume L380: (( C170 . ( 0 ) ) = D230 & (for R5 being (Element of ( NAT )) holds ( C170 . ( R5 + 1 ) ) = ( ( ( ExIterator ( C170 . R5 ) ) +* ( NorIterator ( C170 . R5 ) ) ) +* ( C170 . R5 ) )));
L381: ( C169 . ( 0 ) ) = D231 by L379;
L382: (for R2 being Nat holds S11[ R2 , ( C169 . R2 ) , ( C169 . ( R2 + 1 ) ) ])
proof
let R2 being Nat;
reconsider D232 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
let C171 being (Element of ( PFuncs (D229 , ( BOOLEAN )) ));
assume L383: C171 = ( C169 . R2 );
L384: ( C169 . ( D232 + 1 ) ) = H10(R2 , C171) by L383 , L379;
thus L385: thesis by L384;
end;
L386: ( C170 . ( 0 ) ) = D231 by L380;
L387: (for R2 being Nat holds S11[ R2 , ( C170 . R2 ) , ( C170 . ( R2 + 1 ) ) ])
proof
let R2 being Nat;
reconsider D233 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
let C172 being (Element of ( PFuncs (D229 , ( BOOLEAN )) ));
assume L388: C172 = ( C170 . R2 );
L389: ( C170 . ( D233 + 1 ) ) = H10(R2 , C172) by L388 , L380;
thus L390: thesis by L389;
end;
L391: (for B127 being Nat holds (for B128 , B129 , B130 being (Element of ( PFuncs (D229 , ( BOOLEAN )) )) holds ((S11[ B127 , B128 , B129 ] & S11[ B127 , B128 , B130 ]) implies B129 = B130)))
proof
let C173 being Nat;
let C174 , C175 , C176 being (Element of ( PFuncs (D229 , ( BOOLEAN )) ));
assume that
L392: S11[ C173 , C174 , C175 ]
and
L393: S11[ C173 , C174 , C176 ];
L394: C176 = H10(C173 , C174) by L393;
thus L395: thesis by L392 , L394;
end;
thus L396: thesis from NAT_1:sch 14(L381 , L382 , L386 , L387 , L391);
end;
end;
theorem
L398: (for R15 being Language holds (for R22 being non  empty set holds (for B131 being (R15 , R22)-interpreter-like Function holds ( B131 | ( OwnSymbolsOf R15 ) ) in ( R22 -InterpretersOf R15 ))))
proof
let R15 being Language;
let R22 being non  empty set;
let C177 being (R15 , R22)-interpreter-like Function;
set D234 = ( OwnSymbolsOf R15 );
set D235 = ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) );
L399: (( dom ( C177 | D234 ) ) c= D234 & ( rng ( C177 | D234 ) ) c= D235);
L400: ( C177 | D234 ) is (Function of D234 , D235) by L399 , RELSET_1:4;
L401: (( C177 | D234 ) is (R15 , R22)-interpreter-like & ( C177 | D234 ) is (Element of ( Funcs (D234 , D235) ))) by L400 , FUNCT_2:8;
thus L402: thesis by L401;
end;
definition
let C178 being Language;
let C179 being Nat;
let C180 being non  empty set;
func (C178 , C180) -TruthEval C179 -> (Element of ( PFuncs ([: ( C180 -InterpretersOf C178 ) , ( ( ( AllSymbolsOf C178 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) )) means 
:L403: (for R5 being (Element of ( NAT )) holds (C179 = R5 implies it = ( ( (C178 , C180) -TruthEval ) . R5 )));
existence
proof
set D236 = ( (C178 , C180) -TruthEval );
reconsider D237 = C179 as (Element of ( NAT )) by ORDINAL1:def 12;
take ( D236 . D237 );
let R5 being (Element of ( NAT ));
assume L404: C179 = R5;
thus L405: ( D236 . D237 ) = ( D236 . R5 ) by L404;
end;
uniqueness
proof
set D238 = ( C180 -InterpretersOf C178 );
set D239 = ( AllSymbolsOf C178 );
set D240 = ( (C178 , C180) -TruthEval );
let C181 , C182 being (Element of ( PFuncs ([: D238 , ( ( D239 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
assume that
L406: (for R5 being (Element of ( NAT )) holds (C179 = R5 implies C181 = ( ( (C178 , C180) -TruthEval ) . R5 )))
and
L407: (for R5 being (Element of ( NAT )) holds (C179 = R5 implies C182 = ( ( (C178 , C180) -TruthEval ) . R5 )));
reconsider D241 = C179 as (Element of ( NAT )) by ORDINAL1:def 12;
thus L408: C181 = ( D240 . D241 ) by L406
.= C182 by L407;
end;
end;
L410: (for R2 being Nat holds (for R12 being set holds (for R15 being Language holds (for R22 being non  empty set holds (for R3 being Nat holds (R12 in ( dom ( (R15 , R22) -TruthEval R2 ) ) implies (R12 in ( dom ( (R15 , R22) -TruthEval ( R2 + R3 ) ) ) & ( ( (R15 , R22) -TruthEval R2 ) . R12 ) = ( ( (R15 , R22) -TruthEval ( R2 + R3 ) ) . R12 ))))))))
proof
let R2 being Nat;
let R12 being set;
let R15 being Language;
let R22 being non  empty set;
set D242 = ( (R15 , R22) -TruthEval );
defpred S12[ Nat ] means (R12 in ( dom ( (R15 , R22) -TruthEval R2 ) ) implies (R12 in ( dom ( (R15 , R22) -TruthEval ( R2 + $1 ) ) ) & ( ( (R15 , R22) -TruthEval R2 ) . R12 ) = ( ( (R15 , R22) -TruthEval ( R2 + $1 ) ) . R12 )));
L411: S12[ ( 0 ) ];
L412: (for R3 being Nat holds (S12[ R3 ] implies S12[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
reconsider D243 = ( R2 + R3 ) , D244 = ( ( R2 + R3 ) + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L413: S12[ R3 ];
set D245 = ( (R15 , R22) -TruthEval R2 );
set D246 = ( (R15 , R22) -TruthEval ( R2 + R3 ) );
set D247 = ( (R15 , R22) -TruthEval ( ( R2 + R3 ) + 1 ) );
L414: (( D242 . D243 ) = D246 & ( D242 . D244 ) = D247) by L403;
L415: ( D242 . D244 ) = ( ( ( ExIterator ( D242 . D243 ) ) +* ( NorIterator ( D242 . D243 ) ) ) +* ( D242 . D243 ) ) by L368;
L416: ( dom ( D242 . D244 ) ) = ( ( dom ( ( ExIterator ( D242 . D243 ) ) +* ( NorIterator ( D242 . D243 ) ) ) ) \/ ( dom ( D242 . D243 ) ) ) by L415 , FUNCT_4:def 1;
L417: ( dom ( D242 . D243 ) ) c= ( dom ( D242 . D244 ) ) by L416 , XBOOLE_1:7;
assume L418: R12 in ( dom D245 );
L419: R12 in ( dom ( D242 . D243 ) ) by L418 , L413 , L403;
L420: R12 in ( dom ( D242 . D244 ) ) by L419 , L417;
thus L421: R12 in ( dom ( (R15 , R22) -TruthEval ( R2 + ( R3 + 1 ) ) ) ) by L414 , L418 , L413 , L417;
L422: R12 in ( ( dom ( ( ExIterator ( D242 . D243 ) ) +* ( NorIterator ( D242 . D243 ) ) ) ) \/ ( dom ( D242 . D243 ) ) ) by L420 , L415 , FUNCT_4:def 1;
thus L423: thesis by L422 , L413 , L414 , L418 , L415 , FUNCT_4:def 1;
end;
thus L424: (for R3 being Nat holds S12[ R3 ]) from NAT_1:sch 2(L411 , L412);
end;
L425: (for R9 being set holds (for R10 being set holds (for R11 being set holds (for R12 being set holds (R12 in ( ( R9 \/ R10 ) \/ R11 ) iff (R12 in R9 or R12 in R10 or R12 in R11))))))
proof
let R9 being set;
let R10 being set;
let R11 being set;
let R12 being set;
set D248 = ( ( R9 \/ R10 ) \/ R11 );
L426: (R12 in D248 iff (R12 in ( R9 \/ R10 ) or R12 in R11)) by XBOOLE_0:def 3;
thus L427: thesis by L426 , XBOOLE_0:def 3;
end;
L428: (for R15 being Language holds (for R23 being non  empty set holds (for R24 being non  empty set holds (for R2 being Nat holds (for B132 being (Element of ( R23 -InterpretersOf R15 )) holds (for B133 being (Element of ( R24 -InterpretersOf R15 )) holds (for B134 being (string of R15) holds ([ B132 , B134 ] in ( dom ( (R15 , R23) -TruthEval R2 ) ) implies [ B133 , B134 ] in ( dom ( (R15 , R24) -TruthEval R2 ) )))))))))
proof
let R15 being Language;
let R23 being non  empty set;
let R24 being non  empty set;
set D249 = ( AllSymbolsOf R15 );
set D250 = ( TheNorSymbOf R15 );
set D251 = ( R23 -InterpretersOf R15 );
set D252 = ( R24 -InterpretersOf R15 );
set D253 = ( AtomicFormulasOf R15 );
defpred S13[ Nat ] means (for B135 being (Element of D251) holds (for B136 being (Element of D252) holds (for B137 being (string of R15) holds ([ B135 , B137 ] in ( dom ( (R15 , R23) -TruthEval $1 ) ) implies [ B136 , B137 ] in ( dom ( (R15 , R24) -TruthEval $1 ) )))));
L429: S13[ ( 0 ) ]
proof
set D254 = ( (R15 , R23) -TruthEval ( 0 ) );
set D255 = ( (R15 , R24) -TruthEval ( 0 ) );
reconsider D256 = ( 0 ) as (Element of ( NAT ));
reconsider D257 = ( ( (R15 , R23) -TruthEval ) . D256 ) as (Element of ( PFuncs ([: D251 , ( ( D249 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
reconsider D258 = ( ( (R15 , R24) -TruthEval ) . D256 ) as (Element of ( PFuncs ([: D252 , ( ( D249 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
L430: (D254 = D257 & D255 = D258) by L403;
L431: (D257 = ( R15 -TruthEval R23 ) & D258 = ( R15 -TruthEval R24 )) by L368;
L432: ( dom D254 ) = [: D251 , D253 :] by L430 , L431 , FUNCT_2:def 1;
L433: ( dom D255 ) = [: D252 , D253 :] by L430 , L431 , FUNCT_2:def 1;
let C183 being (Element of D251);
let C184 being (Element of D252);
let R19 being (string of R15);
assume L434: [ C183 , R19 ] in ( dom D254 );
L435: (C183 in D251 & R19 in D253) by L434 , L432 , ZFMISC_1:87;
thus L436: [ C184 , R19 ] in ( dom D255 ) by L435 , L433 , ZFMISC_1:87;
end;
L437: (for R3 being Nat holds (S13[ R3 ] implies S13[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
reconsider D259 = R3 , D260 = ( R3 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L438: S13[ R3 ];
let C185 being (Element of D251);
let C186 being (Element of D252);
set D261 = ( (R15 , R23) -TruthEval R3 );
set D262 = ( (R15 , R23) -TruthEval ( R3 + 1 ) );
set D263 = ( (R15 , R24) -TruthEval R3 );
set D264 = ( (R15 , R24) -TruthEval ( R3 + 1 ) );
L439: ( dom D262 ) = ( ( ( dom ( ExIterator D261 ) ) \/ ( dom ( NorIterator D261 ) ) ) \/ ( dom D261 ) )
proof
reconsider D265 = ( ( (R15 , R23) -TruthEval ) . D260 ) as (Element of ( PFuncs ([: D251 , ( ( D249 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
reconsider D266 = ( ( (R15 , R23) -TruthEval ) . D259 ) as (Element of ( PFuncs ([: D251 , ( ( D249 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
L440: (D261 = D266 & D262 = D265) by L403;
L441: D262 = ( ( ( ExIterator D266 ) +* ( NorIterator D266 ) ) +* D266 ) by L440 , L368;
L442: ( dom D262 ) = ( ( dom ( ( ExIterator D266 ) +* ( NorIterator D266 ) ) ) \/ ( dom D266 ) ) by L441 , FUNCT_4:def 1
.= ( ( ( dom ( ExIterator D266 ) ) \/ ( dom ( NorIterator D266 ) ) ) \/ ( dom D266 ) ) by FUNCT_4:def 1;
thus L443: thesis by L442 , L440;
end;
L444: ( dom D264 ) = ( ( ( dom ( ExIterator D263 ) ) \/ ( dom ( NorIterator D263 ) ) ) \/ ( dom D263 ) )
proof
reconsider D267 = ( ( (R15 , R24) -TruthEval ) . D260 ) as (Element of ( PFuncs ([: D252 , ( ( D249 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
reconsider D268 = ( ( (R15 , R24) -TruthEval ) . D259 ) as (Element of ( PFuncs ([: D252 , ( ( D249 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
L445: (D263 = D268 & D264 = D267) by L403;
L446: D264 = ( ( ( ExIterator D268 ) +* ( NorIterator D268 ) ) +* D268 ) by L445 , L368;
L447: ( dom D264 ) = ( ( dom ( ( ExIterator D268 ) +* ( NorIterator D268 ) ) ) \/ ( dom D268 ) ) by L446 , FUNCT_4:def 1
.= ( ( ( dom ( ExIterator D268 ) ) \/ ( dom ( NorIterator D268 ) ) ) \/ ( dom D268 ) ) by FUNCT_4:def 1;
thus L448: thesis by L447 , L445;
end;
let R19 being (string of R15);
set D269 = [ C185 , R19 ];
assume L449: D269 in ( dom D262 );
per cases  by L449 , L425 , L439;
suppose L450: D269 in ( dom ( ExIterator D261 ) );

consider C187 being  literal (Element of R15), C188 being (string of R15) such that L451: ([ C185 , C188 ] in ( dom D261 ) & R19 = ( <* C187 *> ^ C188 )) by L450 , L310;
L452: ([ C186 , C188 ] in ( dom D263 ) & R19 = ( <* C187 *> ^ C188 )) by L451 , L438;
L453: [ C186 , R19 ] in ( dom ( ExIterator D263 ) ) by L452 , L310;
thus L454: [ C186 , R19 ] in ( dom D264 ) by L453 , L425 , L444;
end;
suppose L455: D269 in ( dom ( NorIterator D261 ) );

consider C189 , C190 being (string of R15) such that L456: (R19 = ( ( <* ( TheNorSymbOf R15 ) *> ^ C189 ) ^ C190 ) & [ C185 , C189 ] in ( dom D261 ) & [ C185 , C190 ] in ( dom D261 )) by L455 , L340;
L457: (R19 = ( ( <* D250 *> ^ C189 ) ^ C190 ) & [ C186 , C189 ] in ( dom D263 ) & [ C186 , C190 ] in ( dom D263 )) by L456 , L438;
L458: [ C186 , R19 ] in ( dom ( NorIterator D263 ) ) by L457 , L340;
thus L459: thesis by L458 , L425 , L444;
end;
suppose L460: D269 in ( dom D261 );

L461: [ C186 , R19 ] in ( dom D263 ) by L460 , L438;
thus L462: thesis by L461 , L425 , L444;
end;
end;
thus L464: (for R2 being Nat holds S13[ R2 ]) from NAT_1:sch 2(L429 , L437);
end;
L465: (for R5 being (Element of ( NAT )) holds (for R15 being Language holds (for R22 being non  empty set holds ( curry ( ( (R15 , R22) -TruthEval ) . R5 ) ) is (Function of ( R22 -InterpretersOf R15 ) , ( PFuncs (( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) , ( BOOLEAN )) )))))
proof
let R5 being (Element of ( NAT ));
let R15 being Language;
let R22 being non  empty set;
set D270 = ( R22 -InterpretersOf R15 );
set D271 = ( AtomicFormulasOf R15 );
set D272 = ( ( (R15 , R22) -TruthEval ) . R5 );
set D273 = ( AllSymbolsOf R15 );
set D274 = ( (R15 , R22) -TruthEval );
reconsider D275 = ( curry D272 ) as (Element of ( PFuncs (D270 , ( PFuncs (( ( D273 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) )) by FUNCT_6:14;
set D276 = the (Element of D271);
reconsider D277 = ( 0 ) as (Element of ( NAT ));
L466: ( dom ( R15 -TruthEval R22 ) ) = [: D270 , D271 :] by FUNCT_2:def 1;
L467: ( dom ( D274 . ( 0 ) ) ) = [: D270 , D271 :] by L466 , L368;
L468:
now
let R12 being set;
assume L469: R12 in D270;
L470: [ R12 , D276 ] in ( dom ( D274 . ( 0 ) ) ) by L469 , L467 , ZFMISC_1:87;
L471: [ R12 , D276 ] in ( dom ( (R15 , R22) -TruthEval ( 0 ) ) ) by L470 , L403;
L472: [ R12 , D276 ] in ( dom ( (R15 , R22) -TruthEval ( ( 0 ) + R5 ) ) ) by L471 , L410;
L473: [ R12 , D276 ] in ( dom D272 ) by L472 , L403;
thus L474: R12 in ( dom D275 ) by L473 , FUNCT_5:19;
end;
L475: (D270 c= ( dom D275 ) & ( dom D275 ) c= D270) by L468 , TARSKI:def 3;
L476: ( dom D275 ) = D270 by L475 , XBOOLE_0:def 10;
reconsider D278 = D275 as  total (PartFunc of D270 , ( PFuncs (( ( D273 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L476 , PARTFUN1:def 2;
L477: ( curry D272 ) = D278;
thus L478: thesis by L477;
end;
L479: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( curry ( (R15 , R22) -TruthEval R2 ) ) is (Function of ( R22 -InterpretersOf R15 ) , ( PFuncs (( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) , ( BOOLEAN )) )))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
reconsider D279 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
set D280 = ( (R15 , R22) -TruthEval D279 );
set D281 = ( ( (R15 , R22) -TruthEval ) . D279 );
L480: ( curry D280 ) = ( curry D281 ) by L403;
thus L481: thesis by L480 , L465;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let R2 being Nat;
let C191 being (Element of ( R22 -InterpretersOf R15 ));
func (C191 , R2) -TruthEval -> (Element of ( PFuncs (( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) , ( BOOLEAN )) )) equals 
( ( curry ( (R15 , R22) -TruthEval R2 ) ) . C191 );
coherence
proof
set D282 = ( R22 -InterpretersOf R15 );
set D283 = ( AllSymbolsOf R15 );
reconsider D284 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
L482: ( curry ( (R15 , R22) -TruthEval D284 ) ) = ( curry ( ( (R15 , R22) -TruthEval ) . D284 ) ) by L403;
reconsider D285 = ( curry ( (R15 , R22) -TruthEval D284 ) ) as (Function of D282 , ( PFuncs (( ( D283 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L482 , L465;
L483: ( D285 . C191 ) is (Element of ( PFuncs (( ( D283 * ) \ { ( {} ) } ) , ( BOOLEAN )) ));
thus L484: thesis by L483;
end;
end;
L486: (for R2 being Nat holds (for R3 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (for B138 being (Element of ( R22 -InterpretersOf R15 )) holds ( (B138 , R2) -TruthEval ) c= ( (B138 , ( R2 + R3 )) -TruthEval ))))))
proof
let R2 being Nat;
let R3 being Nat;
let R15 being Language;
let R22 being non  empty set;
set D286 = ( R22 -InterpretersOf R15 );
set D287 = ( AllSymbolsOf R15 );
let C192 being (Element of D286);
set D288 = ( (C192 , R2) -TruthEval );
set D289 = ( (C192 , ( R2 + R3 )) -TruthEval );
set D290 = ( (R15 , R22) -TruthEval R2 );
set D291 = ( (R15 , R22) -TruthEval ( R2 + R3 ) );
reconsider D292 = ( curry D290 ) , D293 = ( curry D291 ) as (Function of D286 , ( PFuncs (( ( D287 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L479;
L487: (D288 = ( D292 . C192 ) & D289 = ( D293 . C192 ) & ( dom D292 ) = D286) by FUNCT_2:def 1;
L488: (for R12 being set holds (R12 in ( dom D288 ) implies (R12 in ( dom D289 ) & ( D288 . R12 ) = ( D289 . R12 ))))
proof
let R12 being set;
assume L489: R12 in ( dom D288 );
L490: [ C192 , R12 ] in ( dom D290 ) by L489 , L487 , FUNCT_5:31;
L491: ([ C192 , R12 ] in ( dom D291 ) & ( D291 . [ C192 , R12 ] ) = ( D290 . [ C192 , R12 ] )) by L490 , L410;
L492: (R12 in ( dom D289 ) & ( D289 . R12 ) = ( D291 . (C192 , R12) )) by L491 , FUNCT_5:20;
L493: ( D289 . R12 ) = ( D290 . (C192 , R12) ) by L492 , L490 , L410
.= ( D288 . R12 ) by L489 , L487 , FUNCT_5:31;
thus L494: (R12 in ( dom D289 ) & ( D288 . R12 ) = ( D289 . R12 )) by L493 , L491 , FUNCT_5:20;
end;
L495: ((for R12 being set holds (R12 in ( dom D288 ) implies R12 in ( dom D289 ))) & (for R12 being set holds (R12 in ( dom D288 ) implies ( D288 . R12 ) = ( D289 . R12 )))) by L488;
L496: ( dom D288 ) c= ( dom D289 ) by L495 , TARSKI:def 3;
thus L497: thesis by L496 , L495 , GRFUNC_1:2;
end;
L498: (for R2 being Nat holds (for R15 being Language holds (for R23 being non  empty set holds (for R24 being non  empty set holds (for B139 being (Element of ( R23 -InterpretersOf R15 )) holds (for B140 being (Element of ( R24 -InterpretersOf R15 )) holds ( dom ( (B139 , R2) -TruthEval ) ) c= ( dom ( (B140 , R2) -TruthEval ) )))))))
proof
let R2 being Nat;
let R15 being Language;
let R23 being non  empty set;
let R24 being non  empty set;
reconsider D294 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
set D295 = ( R23 -InterpretersOf R15 );
set D296 = ( R24 -InterpretersOf R15 );
set D297 = ( ( (R15 , R23) -TruthEval ) . D294 );
set D298 = ( AllSymbolsOf R15 );
set D299 = ( (R15 , R23) -TruthEval D294 );
set D300 = ( (R15 , R24) -TruthEval D294 );
set D301 = ( ( (R15 , R24) -TruthEval ) . D294 );
let C193 being (Element of D295);
let C194 being (Element of D296);
L499: (D297 = D299 & D301 = D300) by L403;
set D302 = ( (C193 , R2) -TruthEval );
set D303 = ( (C194 , R2) -TruthEval );
L500: (( ( curry D297 ) . C193 ) = D302 & ( ( curry D301 ) . C194 ) = D303) by L403;
reconsider D304 = ( ( curry ( ( (R15 , R23) -TruthEval ) . D294 ) ) . C193 ) , D305 = ( ( curry ( ( (R15 , R24) -TruthEval ) . D294 ) ) . C194 ) as (Element of ( PFuncs (( ( D298 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L500;
reconsider D306 = ( curry D297 ) as (Function of D295 , ( PFuncs (( ( D298 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L465;
L501: C193 in D295;
L502: D297 is (Element of ( PFuncs ([: D295 , ( ( D298 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
L503: ( dom D297 ) c= [: D295 , ( ( D298 * ) \ { ( {} ) } ) :] by L502 , RELAT_1:def 18;
L504: ( uncurry D306 ) = D297 by L503 , FUNCT_5:50;
L505:
now
let C195 being set;
assume L506: C195 in ( dom D304 );
reconsider D307 = C195 as (Element of ( ( D298 * ) \ { ( {} ) } )) by L506;
L507: (C193 in ( dom D306 ) & D304 = ( D306 . C193 ) & C195 in ( dom D304 )) by L501 , L506 , FUNCT_2:def 1;
L508: [ C193 , D307 ] in ( dom D299 ) by L507 , L499 , L504 , FUNCT_5:38;
L509: [ C194 , C195 ] in ( dom D301 ) by L508 , L499 , L428;
thus L510: C195 in ( dom D305 ) by L509 , FUNCT_5:20;
end;
thus L511: thesis by L505 , L500 , TARSKI:def 3;
end;
L512: (for R5 being (Element of ( NAT )) holds (for R15 being Language holds (for R23 being non  empty set holds (for R24 being non  empty set holds (for B141 being (Element of ( R23 -InterpretersOf R15 )) holds (for B142 being (Element of ( R24 -InterpretersOf R15 )) holds ( dom ( (B141 , R5) -TruthEval ) ) = ( dom ( (B142 , R5) -TruthEval ) )))))))
proof
let R5 being (Element of ( NAT ));
let R15 being Language;
let R23 being non  empty set;
let R24 being non  empty set;
set D308 = ( R23 -InterpretersOf R15 );
set D309 = ( R24 -InterpretersOf R15 );
let C196 being (Element of D308);
let C197 being (Element of D309);
set D310 = ( (C196 , R5) -TruthEval );
set D311 = ( (C197 , R5) -TruthEval );
L513: (( dom D310 ) c= ( dom D311 ) & ( dom D311 ) c= ( dom D310 )) by L498;
thus L514: thesis by L513 , XBOOLE_0:def 10;
end;
definition
let R15 being Language;
let R2 being Nat;
func R15 -formulasOfMaxDepth R2 -> (Subset of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) means 
:L515: (for B143 being non  empty set holds (for B144 being (Element of ( B143 -InterpretersOf R15 )) holds (for B145 being (Element of ( NAT )) holds (R2 = B145 implies it = ( dom ( (B144 , B145) -TruthEval ) )))));
existence
proof
set D312 = ( AllSymbolsOf R15 );
set D313 = the non  empty set;
set D314 = the (Element of ( D313 -InterpretersOf R15 ));
reconsider D315 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D316 = ( dom ( (D314 , D315) -TruthEval ) ) as (Subset of ( ( D312 * ) \ { ( {} ) } ));
take D316;
let R22 being non  empty set;
set D317 = ( R22 -InterpretersOf R15 );
let C198 being (Element of D317);
let R5 being (Element of ( NAT ));
assume L516: R2 = R5;
thus L517: D316 = ( dom ( (C198 , R5) -TruthEval ) ) by L516 , L512;
end;
uniqueness
proof
set D318 = ( AllSymbolsOf R15 );
let C199 , C200 being (Subset of ( ( D318 * ) \ { ( {} ) } ));
assume that
L518: (for B146 being non  empty set holds (for B147 being (Element of ( B146 -InterpretersOf R15 )) holds (for B148 being (Element of ( NAT )) holds (R2 = B148 implies C199 = ( dom ( (B147 , B148) -TruthEval ) )))))
and
L519: (for B149 being non  empty set holds (for B150 being (Element of ( B149 -InterpretersOf R15 )) holds (for B151 being (Element of ( NAT )) holds (R2 = B151 implies C200 = ( dom ( (B150 , B151) -TruthEval ) )))));
set D319 = the non  empty set;
set D320 = the (Element of ( D319 -InterpretersOf R15 ));
reconsider D321 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
thus L520: C199 = ( dom ( (D320 , D321) -TruthEval ) ) by L518
.= C200 by L519;
end;
end;
L522: (for R2 being Nat holds (for R3 being Nat holds (for R15 being Language holds ( R15 -formulasOfMaxDepth R2 ) c= ( R15 -formulasOfMaxDepth ( R2 + R3 ) ))))
proof
let R2 being Nat;
let R3 being Nat;
let R15 being Language;
set D322 = the non  empty set;
set D323 = ( R15 -formulasOfMaxDepth R2 );
set D324 = ( R15 -formulasOfMaxDepth ( R2 + R3 ) );
set D325 = ( D322 -InterpretersOf R15 );
set D326 = the (Element of D325);
reconsider D327 = R2 , D328 = ( R2 + R3 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D329 = ( (D326 , D327) -TruthEval );
set D330 = ( (D326 , D328) -TruthEval );
L523: (D323 = ( dom D329 ) & D324 = ( dom D330 )) by L515;
L524: D329 c= D330 by L486;
thus L525: thesis by L524 , L523 , GRFUNC_1:2;
end;
L526: (for R15 being Language holds ( R15 -formulasOfMaxDepth ( 0 ) ) = ( AtomicFormulasOf R15 ))
proof
let R15 being Language;
set D331 = the non  empty set;
set D332 = ( AtomicFormulasOf R15 );
set D333 = ( D331 -InterpretersOf R15 );
set D334 = the (Element of D333);
reconsider D335 = ( 0 ) as (Element of ( NAT ));
L527: [: D333 , D332 :] = ( dom ( R15 -TruthEval D331 ) ) by FUNCT_2:def 1
.= ( dom ( ( (R15 , D331) -TruthEval ) . D335 ) ) by L368
.= ( dom ( (R15 , D331) -TruthEval ( 0 ) ) ) by L403;
L528:
now
let R12 being set;
assume L529: R12 in D332;
L530: [ D334 , R12 ] in ( dom ( (R15 , D331) -TruthEval ( 0 ) ) ) by L529 , L527 , ZFMISC_1:def 2;
L531: R12 in ( dom ( (D334 , D335) -TruthEval ) ) by L530 , FUNCT_5:20;
thus L532: R12 in ( R15 -formulasOfMaxDepth ( 0 ) ) by L531 , L515;
end;
L533: D332 c= ( R15 -formulasOfMaxDepth ( 0 ) ) by L528 , TARSKI:def 3;
L534:
now
let R12 being set;
assume L535: R12 in ( R15 -formulasOfMaxDepth ( 0 ) );
L536: R12 in ( dom ( (D334 , D335) -TruthEval ) ) by L535 , L515;
set D336 = ( (R15 , D331) -TruthEval D335 );
set D337 = ( (D334 , D335) -TruthEval );
L537: D336 = ( ( (R15 , D331) -TruthEval ) . D335 ) by L403;
reconsider D338 = ( curry D336 ) as (Function of D333 , ( PFuncs (( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L537 , L465;
L538: ( dom D338 ) = D333 by FUNCT_2:def 1;
L539: [ D334 , R12 ] in [: D333 , D332 :] by L538 , L527 , L536 , FUNCT_5:31;
L540: ( [ D334 , R12 ] `2 ) in D332 by L539 , MCART_1:10;
thus L541: R12 in D332 by L540;
end;
L542: ( R15 -formulasOfMaxDepth ( 0 ) ) c= D332 by L534 , TARSKI:def 3;
thus L543: thesis by L542 , L533 , XBOOLE_0:def 10;
end;
definition
let R15 being Language;
let R2 being Nat;
let R19 being (string of R15);
attr R19 is R2 -wff
means
:L544: R19 in ( R15 -formulasOfMaxDepth R2 );
end;
definition
let R15 being Language;
let R19 being (string of R15);
attr R19 is  wff
means
:L546: (ex R2 being Nat st R19 is R2 -wff);
end;
registration
let R15 being Language;
cluster ( 0 ) -wff ->  0wff for (string of R15);
coherence
proof
set D339 = ( AtomicFormulasOf R15 );
set D340 = ( R15 -formulasOfMaxDepth ( 0 ) );
let C201 being (string of R15);
assume L548: C201 is ( 0 ) -wff;
L549: C201 in D340 by L548 , L544;
L550: C201 in D339 by L549 , L526;
thus L551: thesis by L550;
end;
cluster  0wff -> ( 0 ) -wff for (string of R15);
coherence
proof
set D341 = ( AtomicFormulasOf R15 );
let C202 being (string of R15);
assume L552: C202 is  0wff;
L553: C202 in D341 by L552;
L554: C202 in ( R15 -formulasOfMaxDepth ( 0 ) ) by L553 , L526;
thus L555: thesis by L554 , L544;
end;
let R2 being Nat;
cluster R2 -wff ->  wff for (string of R15);
coherence by L546;
let R3 being Nat;
cluster ( R2 + ( ( 0 ) * R3 ) ) -wff -> ( R2 + R3 ) -wff for (string of R15);
coherence
proof
set D342 = ( R15 -formulasOfMaxDepth R2 );
set D343 = ( R15 -formulasOfMaxDepth ( R2 + R3 ) );
L556: D342 c= D343 by L522;
let R19 being (string of R15);
assume L557: R19 is ( R2 + ( ( 0 ) * R3 ) ) -wff;
L558: R19 in D342 by L557 , L544;
thus L559: thesis by L558 , L544 , L556;
end;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster R2 -wff for (string of R15);
existence
proof
set D344 = the  0wff (string of R15);
L561: D344 is ( ( 0 ) + ( ( 0 ) * R2 ) ) -wff;
L562: D344 is ( ( 0 ) + R2 ) -wff by L561;
thus L563: thesis by L562;
end;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster ( R15 -formulasOfMaxDepth R2 ) -> non  empty;
coherence
proof
set D345 = ( R15 -formulasOfMaxDepth R2 );
set D346 = the R2 -wff (string of R15);
L565: D346 in D345 by L544;
thus L566: thesis by L565;
end;
end;
registration
let R15 being Language;
cluster  wff for (string of R15);
existence
proof
take the ( 0 ) -wff (string of R15);
thus L568: thesis;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C203 being (Element of ( R22 -InterpretersOf R15 ));
let C204 being  wff (string of R15);
func C203 -TruthEval C204 -> (Element of ( BOOLEAN )) means 
:L570: (for B152 being Nat holds (C204 is B152 -wff implies it = ( ( (C203 , B152) -TruthEval ) . C204 )));
existence
proof
set D347 = ( R22 -InterpretersOf R15 );
set D348 = ( AllSymbolsOf R15 );
set D349 = C203;
set D350 = C203;
consider R3 being Nat such that L571: C204 is R3 -wff by L546;
reconsider D351 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
set D352 = ( (D349 , R3) -TruthEval );
reconsider D353 = C204 as R3 -wff (string of R15) by L571;
L572: ( R15 -formulasOfMaxDepth D351 ) = ( dom ( (D349 , D351) -TruthEval ) ) by L515;
L573: D353 in ( dom D352 ) by L572 , L544;
L574: ( D352 . D353 ) = ( D352 /. D353 ) by L573 , PARTFUN1:def 6;
reconsider D354 = ( D352 . D353 ) as (Element of ( BOOLEAN )) by L574;
take D354;
let R2 being Nat;
set D355 = ( (D350 , R2) -TruthEval );
set D356 = ( (D350 , ( R2 + R3 )) -TruthEval );
set D357 = ( (D349 , ( R3 + R2 )) -TruthEval );
reconsider D358 = R2 , D359 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
L575: (( R15 -formulasOfMaxDepth R2 ) = ( dom ( (D350 , D358) -TruthEval ) ) & ( R15 -formulasOfMaxDepth D359 ) = ( dom ( (D349 , D359) -TruthEval ) )) by L515;
L576: (D355 c= D356 & D352 c= D357 & D356 = D357) by L486;
assume L577: C204 is R2 -wff;
L578: C204 in ( dom D355 ) by L577 , L575 , L544;
L579: ( D355 . C204 ) = ( D356 . C204 ) by L578 , L576 , GRFUNC_1:2;
L580: D353 in ( dom D352 ) by L572 , L544;
thus L581: D354 = ( D355 . C204 ) by L580 , L579 , L576 , GRFUNC_1:2;
end;
uniqueness
proof
let C205 , C206 being (Element of ( BOOLEAN ));
assume L582: (for B153 being Nat holds (C204 is B153 -wff implies C205 = ( ( (C203 , B153) -TruthEval ) . C204 )));
assume L583: (for B154 being Nat holds (C204 is B154 -wff implies C206 = ( ( (C203 , B154) -TruthEval ) . C204 )));
consider C207 being Nat such that L584: C204 is C207 -wff by L546;
thus L585: C205 = ( ( (C203 , C207) -TruthEval ) . C204 ) by L582 , L584
.= C206 by L583 , L584;
end;
end;
definition
let R15 being Language;
func AllFormulasOf R15 equals 
{ B155 where B155 is (string of R15) : (ex R2 being Nat st B155 is R2 -wff) };
coherence;
end;
registration
let R15 being Language;
cluster ( AllFormulasOf R15 ) -> non  empty;
coherence
proof
set D360 = the ( 0 ) -wff (string of R15);
L588: D360 in ( AllFormulasOf R15 );
thus L589: thesis by L588;
end;
end;
theorem
L591: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (for R30 being (Element of R22) holds (for R33 being  termal (string of R15) holds (for R34 being (R15 , R22)-interpreter-like Function holds (( ( ( (R34 , R30) -TermEval ) . ( R2 + 1 ) ) . R33 ) = ( ( R34 . ( ( R15 -firstChar ) . R33 ) ) . ( ( ( (R34 , R30) -TermEval ) . R2 ) * ( SubTerms R33 ) ) ) & (R33 is ( 0 ) -termal implies ( ( ( (R34 , R30) -TermEval ) . ( R2 + 1 ) ) . R33 ) = ( ( R34 . ( ( R15 -firstChar ) . R33 ) ) . ( {} ) )))))))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
let R30 being (Element of R22);
let R33 being  termal (string of R15);
let R34 being (R15 , R22)-interpreter-like Function;
reconsider D361 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
L592: (( ( ( (R34 , R30) -TermEval ) . ( D361 + 1 ) ) . R33 ) = ( ( R34 . ( ( R15 -firstChar ) . R33 ) ) . ( ( ( (R34 , R30) -TermEval ) . D361 ) * ( SubTerms R33 ) ) ) & (R33 is ( 0 ) -termal implies ( ( ( (R34 , R30) -TermEval ) . ( D361 + 1 ) ) . R33 ) = ( ( R34 . ( ( R15 -firstChar ) . R33 ) ) . ( {} ) ))) by L169;
thus L593: thesis by L592;
end;
theorem
L594: (for R2 being Nat holds (for R3 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (for R31 being (Element of R22) holds (for R32 being (Element of R22) holds (for R34 being (R15 , R22)-interpreter-like Function holds (for B156 being R2 -termal (string of R15) holds ( ( ( (R34 , R31) -TermEval ) . ( R2 + 1 ) ) . B156 ) = ( ( ( (R34 , R32) -TermEval ) . ( ( R2 + 1 ) + R3 ) ) . B156 ))))))))) by L179;
theorem
L595: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( curry ( (R15 , R22) -TruthEval R2 ) ) is (Function of ( R22 -InterpretersOf R15 ) , ( PFuncs (( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) , ( BOOLEAN )) ))))) by L479;
theorem
L596: (for R9 being set holds (for R10 being set holds (for R11 being set holds (for R12 being set holds (R12 in ( ( R9 \/ R10 ) \/ R11 ) iff (R12 in R9 or R12 in R10 or R12 in R11)))))) by L425;
theorem
L597: (for R15 being Language holds ( R15 -formulasOfMaxDepth ( 0 ) ) = ( AtomicFormulasOf R15 )) by L526;
definition
let R15 being Language;
let R2 being Nat;
redefine func R15 -formulasOfMaxDepth R2 means 
:L598: (for B157 being non  empty set holds (for B158 being (Element of ( B157 -InterpretersOf R15 )) holds it = ( dom ( (B158 , R2) -TruthEval ) )));
compatibility
proof
reconsider D362 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
set D363 = ( AllSymbolsOf R15 );
set D364 = ( R15 -formulasOfMaxDepth R2 );
defpred S14[ set ] means (for B159 being non  empty set holds (for B160 being (Element of ( B159 -InterpretersOf R15 )) holds $1 = ( dom ( (B160 , R2) -TruthEval ) )));
let C208 being (Subset of ( ( D363 * ) \ { ( {} ) } ));
thus L599: (C208 = D364 implies S14[ C208 ])
proof
assume L600: C208 = D364;
thus L601: (for B161 being non  empty set holds (for B162 being (Element of ( B161 -InterpretersOf R15 )) holds C208 = ( dom ( (B162 , R2) -TruthEval ) )))
proof
let R22 being non  empty set;
set D365 = ( R22 -InterpretersOf R15 );
let C209 being (Element of D365);
L602: D364 = ( dom ( (C209 , D362) -TruthEval ) ) by L515;
thus L603: C208 = ( dom ( (C209 , R2) -TruthEval ) ) by L602 , L600;
end;

end;

assume L602: S14[ C208 ];
L603: (for B163 being non  empty set holds (for B164 being (Element of ( B163 -InterpretersOf R15 )) holds (for B165 being (Element of ( NAT )) holds (R2 = B165 implies C208 = ( dom ( (B164 , B165) -TruthEval ) ))))) by L602;
thus L604: C208 = D364 by L603 , L515;
end;
end;
L606: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( curry ( (R15 , R22) -TruthEval R2 ) ) is (Function of ( R22 -InterpretersOf R15 ) , ( Funcs (( R15 -formulasOfMaxDepth R2 ) , ( BOOLEAN )) )))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
reconsider D366 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
set D367 = ( (R15 , R22) -TruthEval R2 );
set D368 = ( R22 -InterpretersOf R15 );
set D369 = ( AllSymbolsOf R15 );
set D370 = ( R15 -formulasOfMaxDepth R2 );
reconsider D371 = ( curry D367 ) as (Function of D368 , ( PFuncs (( ( D369 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L479;
L607: ( dom D371 ) = D368 by FUNCT_2:def 1;
L608:
now
let R12 being set;
assume L609: R12 in D368;
reconsider D372 = R12 as (Element of D368) by L609;
reconsider D373 = ( D371 . D372 ) as (Element of ( PFuncs (( ( D369 * ) \ { ( {} ) } ) , ( BOOLEAN )) ));
L610: (D373 is ( BOOLEAN ) -valued & D373 = ( (D372 , R2) -TruthEval ));
L611: (D373 = D373 & ( dom D373 ) = D370 & ( rng D373 ) c= ( BOOLEAN )) by L610 , L598;
thus L612: ( D371 . R12 ) in ( Funcs (D370 , ( BOOLEAN )) ) by L611 , FUNCT_2:def 2;
end;
thus L613: thesis by L608 , L607 , FUNCT_2:3;
end;
theorem
L614: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (( (R15 , R22) -TruthEval R2 ) in ( Funcs ([: ( R22 -InterpretersOf R15 ) , ( R15 -formulasOfMaxDepth R2 ) :] , ( BOOLEAN )) ) & ( ( (R15 , R22) -TruthEval ) . R2 ) in ( Funcs ([: ( R22 -InterpretersOf R15 ) , ( R15 -formulasOfMaxDepth R2 ) :] , ( BOOLEAN )) )))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
set D374 = ( (R15 , R22) -TruthEval R2 );
set D375 = ( R22 -InterpretersOf R15 );
set D376 = ( R15 -formulasOfMaxDepth R2 );
set D377 = ( AllSymbolsOf R15 );
reconsider D378 = R2 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D379 = D374 as (PartFunc of [: D375 , ( ( D377 * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
L615: ( dom D374 ) c= [: D375 , ( ( D377 * ) \ { ( {} ) } ) :];
L616: ( uncurry ( curry D374 ) ) = D374 by L615 , FUNCT_5:50;
reconsider D380 = ( curry D374 ) as (Function of D375 , ( Funcs (D376 , ( BOOLEAN )) )) by L606;
L617: (( rng D380 ) c= ( Funcs (D376 , ( BOOLEAN )) ) & ( dom D380 ) = D375) by FUNCT_2:def 1;
L618: (D374 = D374 & ( dom D374 ) = [: D375 , D376 :] & ( rng D374 ) c= ( BOOLEAN )) by L617 , L616 , FUNCT_5:26;
thus L619: D374 in ( Funcs ([: D375 , D376 :] , ( BOOLEAN )) ) by L618 , FUNCT_2:def 2;
L620: ( ( (R15 , R22) -TruthEval ) . D378 ) in ( Funcs ([: D375 , D376 :] , ( BOOLEAN )) ) by L619 , L403;
thus L621: thesis by L620;
end;
definition
let R15 being Language;
let R2 being Nat;
func R2 -ExFormulasOf R15 equals 
{ ( <* B166 *> ^ B167 ) where B166 is (Element of ( LettersOf R15 )) , B167 is (Element of ( R15 -formulasOfMaxDepth R2 )) : (not contradiction) };
coherence;
func R2 -NorFormulasOf R15 equals 
{ ( ( <* ( TheNorSymbOf R15 ) *> ^ B168 ) ^ B169 ) where B168 is (Element of ( R15 -formulasOfMaxDepth R2 )) , B169 is (Element of ( R15 -formulasOfMaxDepth R2 )) : (not contradiction) };
coherence;
end;
definition
let R15 being Language;
let C210 , C211 being (string of R15);
redefine func C210 ^ C211 -> (string of R15);

coherence
proof
set D381 = ( AllSymbolsOf R15 );
reconsider D382 = C210 , D383 = C211 as non  empty (FinSequence of D381) by FOMODEL0:5;
L623: ( D382 ^ D383 ) is non  empty non  empty non  empty non  empty (FinSequence of D381);
thus L624: thesis by L623 , FOMODEL0:5;
end;
end;
definition
let R15 being Language;
let R18 being (Element of R15);
redefine func <*R18 *> -> (string of R15);

coherence
proof
set D384 = ( AllSymbolsOf R15 );
L626: <* R18 *> is non  empty non  empty non  empty non  empty (FinSequence of D384);
thus L627: thesis by L626 , FOMODEL0:5;
end;
end;
L629: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( dom ( NorIterator ( (R15 , R22) -TruthEval R2 ) ) ) = [: ( R22 -InterpretersOf R15 ) , ( R2 -NorFormulasOf R15 ) :])))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
set D385 = R2;
set D386 = ( R22 -InterpretersOf R15 );
set D387 = ( AllSymbolsOf R15 );
set D388 = ( TheNorSymbOf R15 );
set D389 = ( (R15 , R22) -TruthEval D385 );
set D390 = ( R15 -formulasOfMaxDepth D385 );
set D391 = ( NorIterator D389 );
deffunc H11(FinSequence , FinSequence) = ( ( <* D388 *> ^ $1 ) ^ $2 );
defpred S15[  ] means (not contradiction);
set D392 = { H11(B170 , B171) where B170 , B171 is (Element of D390) : S15[  ] };
set D393 = ( dom D391 );
set D394 = [: D386 , D392 :];
L630: D389 is (Element of ( Funcs ([: D386 , D390 :] , ( BOOLEAN )) )) by L614;
reconsider D395 = D389 as (Function of [: D386 , D390 :] , ( BOOLEAN )) by L630;
L631: ( dom D395 ) = [: D386 , D390 :] by FUNCT_2:def 1;
reconsider D396 = D391 as (PartFunc of [: D386 , ( ( D387 * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
L632: [: D386 , ( ( D387 * ) \ { ( {} ) } ) :] = { [ B172 , B173 ] where B172 is (Element of D386) , B173 is (Element of ( ( D387 * ) \ { ( {} ) } )) : (not contradiction) } by DOMAIN_1:19;
L633:
now
let R14 being set;
assume L634: R14 in D393;
L635: R14 in [: D386 , ( ( D387 * ) \ { ( {} ) } ) :] by L634;
consider C212 being (Element of D386), C213 being (Element of ( ( D387 * ) \ { ( {} ) } )) such that L636: (R14 = [ C212 , C213 ] & (not contradiction)) by L635 , L632;
consider C214 , C215 being (Element of ( ( D387 * ) \ { ( {} ) } )) such that L637: (C213 = ( ( <* D388 *> ^ C214 ) ^ C215 ) & [ C212 , C214 ] in ( dom D389 ) & [ C212 , C215 ] in ( dom D389 )) by L340 , L634 , L636;
reconsider D397 = C214 , D398 = C215 as (Element of D390) by L637 , L631 , ZFMISC_1:87;
set D399 = H11(D397 , D398);
L638: (C212 in D386 & D399 in D392 & R14 = [ C212 , D399 ]) by L636 , L637;
thus L639: R14 in D394 by L638 , ZFMISC_1:def 2;
end;
L640: D393 c= D394 by L633 , TARSKI:def 3;
L641:
now
let R14 being set;
assume L642: R14 in D394;
consider C216 , C217 being set such that L643: (C216 in D386 & C217 in D392 & R14 = [ C216 , C217 ]) by L642 , ZFMISC_1:def 2;
reconsider D400 = C216 as (Element of D386) by L643;
consider C218 , C219 being (Element of D390) such that L644: (C217 = H11(C218 , C219) & (not contradiction)) by L643;
reconsider D401 = C218 , D402 = C219 as (string of R15);
L645: ( ( <* D388 *> ^ D401 ) ^ D402 ) is (string of R15);
reconsider D403 = C217 as (string of R15) by L645 , L644;
L646: ([ D400 , C218 ] in ( dom D395 ) & [ D400 , C219 ] in ( dom D395 )) by L631;
L647: [ D400 , D403 ] in D393 by L646 , L644 , L340;
thus L648: R14 in D393 by L647 , L643;
end;
L649: D394 c= D393 by L641 , TARSKI:def 3;
thus L650: thesis by L649 , L640 , XBOOLE_0:def 10;
end;
L651: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( dom ( ExIterator ( (R15 , R22) -TruthEval R2 ) ) ) = [: ( R22 -InterpretersOf R15 ) , ( R2 -ExFormulasOf R15 ) :])))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
set D404 = R2;
set D405 = ( R22 -InterpretersOf R15 );
set D406 = ( AllSymbolsOf R15 );
set D407 = ( TheNorSymbOf R15 );
set D408 = ( (R15 , R22) -TruthEval D404 );
set D409 = ( R15 -formulasOfMaxDepth D404 );
set D410 = ( ExIterator D408 );
set D411 = ( LettersOf R15 );
deffunc H12(set , FinSequence) = ( <* $1 *> ^ $2 );
defpred S16[  ] means (not contradiction);
set D412 = { H12(B174 , B175) where B174 is (Element of D411) , B175 is (Element of D409) : S16[  ] };
set D413 = ( dom D410 );
set D414 = [: D405 , D412 :];
L652: D408 is (Element of ( Funcs ([: D405 , D409 :] , ( BOOLEAN )) )) by L614;
reconsider D415 = D408 as (Function of [: D405 , D409 :] , ( BOOLEAN )) by L652;
L653: ( dom D415 ) = [: D405 , D409 :] by FUNCT_2:def 1;
reconsider D416 = D410 as (PartFunc of [: D405 , ( ( D406 * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
L654: [: D405 , ( ( D406 * ) \ { ( {} ) } ) :] = { [ B176 , B177 ] where B176 is (Element of D405) , B177 is (Element of ( ( D406 * ) \ { ( {} ) } )) : (not contradiction) } by DOMAIN_1:19;
L655:
now
let R14 being set;
assume L656: R14 in D413;
L657: R14 in [: D405 , ( ( D406 * ) \ { ( {} ) } ) :] by L656;
consider C220 being (Element of D405), C221 being (Element of ( ( D406 * ) \ { ( {} ) } )) such that L658: (R14 = [ C220 , C221 ] & (not contradiction)) by L657 , L654;
consider C222 being  literal (Element of R15), C223 being (string of R15) such that L659: ([ C220 , C223 ] in ( dom D408 ) & C221 = ( <* C222 *> ^ C223 )) by L310 , L656 , L658;
reconsider D417 = C223 as (Element of D409) by L653 , L659 , ZFMISC_1:87;
reconsider D418 = C222 as (Element of D411) by FOMODEL1:def 14;
L660: (C221 = ( <* D418 *> ^ D417 ) & (not contradiction)) by L659;
L661: C221 in D412 by L660;
thus L662: R14 in D414 by L661 , L658 , ZFMISC_1:def 2;
end;
L663: D413 c= D414 by L655 , TARSKI:def 3;
L664:
now
let R14 being set;
assume L665: R14 in D414;
consider C224 , C225 being set such that L666: (C224 in D405 & C225 in D412 & R14 = [ C224 , C225 ]) by L665 , ZFMISC_1:def 2;
reconsider D419 = C224 as (Element of D405) by L666;
consider C226 being (Element of D411), C227 being (Element of D409) such that L667: (C225 = H12(C226 , C227) & (not contradiction)) by L666;
reconsider D420 = C226 as  literal (Element of R15);
reconsider D421 = C227 as (string of R15);
L668: ([ D419 , C227 ] in ( dom D408 ) & C225 = ( <* D420 *> ^ D421 )) by L667 , L653;
thus L669: R14 in D413 by L668 , L666 , L310;
end;
L670: D414 c= D413 by L664 , TARSKI:def 3;
thus L671: thesis by L670 , L663 , XBOOLE_0:def 10;
end;
theorem
L672: (for R2 being Nat holds (for R15 being Language holds ( R15 -formulasOfMaxDepth ( R2 + 1 ) ) = ( ( ( R2 -ExFormulasOf R15 ) \/ ( R2 -NorFormulasOf R15 ) ) \/ ( R15 -formulasOfMaxDepth R2 ) )))
proof
let R2 being Nat;
let R15 being Language;
set D422 = the non  empty set;
set D423 = ( R2 + 1 );
set D424 = ( D422 -InterpretersOf R15 );
set D425 = ( AllSymbolsOf R15 );
set D426 = ( TheNorSymbOf R15 );
set D427 = the (Element of D424);
reconsider D428 = R2 , D429 = D423 as (Element of ( NAT )) by ORDINAL1:def 12;
set D430 = ( (R15 , D422) -TruthEval );
set D431 = ( D430 . D429 );
set D432 = ( curry D431 );
set D433 = ( R15 -formulasOfMaxDepth R2 );
set D434 = ( R15 -formulasOfMaxDepth D423 );
L673: ( D430 . D428 ) is (Element of ( PFuncs ([: D424 , ( ( D425 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) ));
reconsider D435 = ( D430 . D428 ) as (PartFunc of [: D424 , ( ( D425 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) by L673;
L674: (( (R15 , D422) -TruthEval D423 ) = D431 & ( (R15 , D422) -TruthEval R2 ) = D435) by L403;
reconsider D436 = D432 as (Function of D424 , ( Funcs (D434 , ( BOOLEAN )) )) by L606 , L674;
reconsider D437 = ( D436 . D427 ) as (Function of D434 , ( BOOLEAN ));
L675: D435 is (Element of ( Funcs ([: D424 , D433 :] , ( BOOLEAN )) )) by L614;
reconsider D438 = D435 as (Function of [: D424 , D433 :] , ( BOOLEAN )) by L675;
L676: (( dom D437 ) = D434 & ( dom D436 ) = D424) by FUNCT_2:def 1;
L677: D434 = ( proj2 ( ( dom D431 ) /\ [: { D427 } , ( proj2 ( dom D431 ) ) :] ) ) by L676 , FUNCT_5:31;
L678: D431 = ( ( ( ExIterator ( D430 . D428 ) ) +* ( NorIterator ( D430 . D428 ) ) ) +* D435 ) by L368;
reconsider D439 = ( ExIterator ( D430 . D428 ) ) as (PartFunc of [: D424 , ( ( D425 * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
reconsider D440 = ( dom D439 ) as (Relation of D424 , ( ( D425 * ) \ { ( {} ) } ));
reconsider D441 = ( dom ( NorIterator ( D430 . D428 ) ) ) , D442 = ( dom D435 ) as (Relation of D424 , ( ( D425 * ) \ { ( {} ) } ));
L679: D442 = ( dom D438 )
.= [: D424 , D433 :] by FUNCT_2:def 1;
L680: ( dom D431 ) = ( ( dom ( ( ExIterator ( D430 . D428 ) ) +* ( NorIterator ( D430 . D428 ) ) ) ) \/ ( dom D435 ) ) by L678 , FUNCT_4:def 1
.= ( ( D440 \/ D441 ) \/ D442 ) by FUNCT_4:def 1;
set D443 = ( R2 -NorFormulasOf R15 );
set D444 = ( R2 -ExFormulasOf R15 );
L681: ( (R15 , D422) -TruthEval R2 ) = D435 by L403;
L682: (D441 = [: D424 , D443 :] & D440 = [: D424 , D444 :]) by L681 , L629 , L651;
L683: ( ( D440 \/ D441 ) \/ D442 ) = ( [: D424 , ( D444 \/ D443 ) :] \/ [: D424 , D433 :] ) by L682 , L679 , ZFMISC_1:97
.= [: D424 , ( ( D444 \/ D443 ) \/ D433 ) :] by ZFMISC_1:97;
reconsider D445 = [: { D427 } , ( ( D444 \/ D443 ) \/ D433 ) :] as (Subset of [: D424 , ( ( D444 \/ D443 ) \/ D433 ) :]) by ZFMISC_1:96;
L684: D434 = ( rng ( [: D424 , ( ( D444 \/ D443 ) \/ D433 ) :] /\ D445 ) ) by L683 , L677 , L680 , RELAT_1:160
.= ( ( D444 \/ D443 ) \/ D433 ) by RELAT_1:160;
thus L685: thesis by L684;
end;
theorem
L686: (for R15 being Language holds ( AtomicFormulasOf R15 ) is R15 -prefix)
proof
let R15 being Language;
set D446 = ( AtomicFormulasOf R15 );
set D447 = ( AllSymbolsOf R15 );
set D448 = ( AllTermsOf R15 );
set D449 = ( R15 -multiCat );
L687:
now
let C228 , C229 , C230 , C231 being D447 -valued FinSequence;
assume L688: C228 in D446;
consider C232 being (string of R15) such that L689: (C228 = C232 & C232 is  0wff) by L688;
assume L690: C230 in D446;
consider C233 being (string of R15) such that L691: (C230 = C233 & C233 is  0wff) by L690;
consider C234 being  relational (Element of R15), C235 being ( abs ( ar C234 ) ) -element (Element of ( D448 * )) such that L692: C232 = ( <* C234 *> ^ ( D449 . C235 ) ) by L689 , FOMODEL1:def 35;
consider C236 being  relational (Element of R15), C237 being ( abs ( ar C236 ) ) -element (Element of ( D448 * )) such that L693: C233 = ( <* C236 *> ^ ( D449 . C237 ) ) by L691 , FOMODEL1:def 35;
assume L694: ( C228 ^ C229 ) = ( C230 ^ C231 );
L695: ( <* C234 *> ^ ( ( D449 . C235 ) ^ C229 ) ) = ( ( <* C236 *> ^ ( D449 . C237 ) ) ^ C231 ) by L694 , L689 , L691 , L692 , L693 , FINSEQ_1:32
.= ( <* C236 *> ^ ( ( D449 . C237 ) ^ C231 ) ) by FINSEQ_1:32;
L696: C234 = ( ( <* C236 *> ^ ( ( D449 . C237 ) ^ C231 ) ) . 1 ) by L695 , FINSEQ_1:41
.= C236 by FINSEQ_1:41;
set D450 = ( abs ( ar C234 ) );
set D451 = ( D450 -tuples_on D448 );
reconsider D452 = C235 , D453 = C237 as (Element of D451) by L696 , FOMODEL0:16;
reconsider D454 = ( D449 .: D451 ) as D447 -prefix set;
L697: (( ( ( D447 * ) \ { ( {} ) } ) * ) c= ( ( D447 * ) * ) & ( D448 * ) c= ( ( ( D447 * ) \ { ( {} ) } ) * ));
L698: (C235 in ( ( D447 * ) * ) & C237 in ( ( D447 * ) * ) & ( dom D449 ) = ( ( D447 * ) * )) by L697 , FUNCT_2:def 1 , TARSKI:def 3;
L699: (( D449 . D452 ) in D454 & ( D449 . D453 ) in D454) by L698 , FUNCT_1:def 6;
reconsider D455 = C235 , D456 = C237 as (Element of ( ( D447 * ) * )) by L697 , TARSKI:def 3;
L700: ( ( D449 . D455 ) ^ C229 ) = ( ( D449 . D456 ) ^ C231 ) by L696 , L695 , FINSEQ_1:33;
thus L701: (C228 = C230 & C229 = C231) by L700 , L689 , L691 , L699 , L692 , L693 , L696 , FOMODEL0:def 20;
end;
L702: D446 is D447 -prefix by L687 , FOMODEL0:def 20;
thus L703: thesis by L702;
end;
registration
let R15 being Language;
cluster ( AtomicFormulasOf R15 ) -> R15 -prefix for set;
coherence by L686;
end;
registration
let R15 being Language;
cluster ( R15 -formulasOfMaxDepth ( 0 ) ) -> R15 -prefix for set;
coherence
proof
L705: ( R15 -formulasOfMaxDepth ( 0 ) ) = ( AtomicFormulasOf R15 ) by L526;
thus L706: thesis by L705;
end;
end;
definition
let R15 being Language;
let R42 being  wff (string of R15);
func Depth R42 -> Nat means 
:L708: (R42 is it -wff & (for R3 being Nat holds (R42 is R3 -wff implies it <= R3)));
existence
proof
defpred S17[ Nat ] means R42 is $1 -wff;
consider R2 being Nat such that L709: R42 is R2 -wff by L546;
L710: (ex B178 being Nat st S17[ B178 ]) by L709;
consider C238 being Nat such that L711: (S17[ C238 ] & (for R3 being Nat holds (S17[ R3 ] implies C238 <= R3))) from NAT_1:sch 5(L710);
take C238;
thus L712: thesis by L711;
end;
uniqueness
proof
let C239 , C240 being Nat;
assume L713: (R42 is C239 -wff & (for R3 being Nat holds (R42 is R3 -wff implies C239 <= R3)));
assume L714: (R42 is C240 -wff & (for R3 being Nat holds (R42 is R3 -wff implies C240 <= R3)));
L715: C240 <= C239 by L714 , L713;
L716: C239 <= C240 by L713 , L714;
thus L717: thesis by L716 , L715 , XXREAL_0:1;
end;
end;
L719: (for R2 being Nat holds (for R15 being Language holds (for R42 being  wff (string of R15) holds (R42 in ( ( R15 -formulasOfMaxDepth R2 ) \ ( R15 -formulasOfMaxDepth ( 0 ) ) ) implies (ex R3 being Nat st (R42 is ( R3 + 1 ) -wff & (not R42 is R3 -wff) & ( R3 + 1 ) <= R2))))))
proof
let R2 being Nat;
let R15 being Language;
let R42 being  wff (string of R15);
set D457 = ( R15 -formulasOfMaxDepth R2 );
set D458 = ( R15 -formulasOfMaxDepth ( 0 ) );
assume L720: R42 in ( D457 \ D458 );
L721: (not R42 in D458) by L720 , XBOOLE_0:def 5;
L722: (not R42 is ( 0 ) -wff) by L721 , L544;
L723: ( Depth R42 ) <> ( 0 ) by L722 , L708;
consider R3 being Nat such that L724: ( Depth R42 ) = ( R3 + 1 ) by L723 , NAT_1:6;
take R3;
thus L725: (R42 is ( R3 + 1 ) -wff & (not R42 is R3 -wff)) by L708 , L724;
thus L726: ( R3 + 1 ) <= R2 by L724 , L708;
end;
L727: (for R2 being Nat holds (for R15 being Language holds (for R19 being (string of R15) holds ((R19 is ( R2 + 1 ) -wff & (not R19 is R2 -wff)) implies ((ex B179 being  literal (Element of R15) st (ex B180 being R2 -wff (string of R15) st R19 = ( <* B179 *> ^ B180 ))) or (ex B181 , B182 being R2 -wff (string of R15) st R19 = ( ( <* ( TheNorSymbOf R15 ) *> ^ B181 ) ^ B182 )))))))
proof
let R2 being Nat;
let R15 being Language;
let R19 being (string of R15);
set D459 = ( R15 -formulasOfMaxDepth R2 );
set D460 = ( R15 -formulasOfMaxDepth ( R2 + 1 ) );
set D461 = ( LettersOf R15 );
set D462 = ( TheNorSymbOf R15 );
set D463 = ( R2 -ExFormulasOf R15 );
set D464 = ( R2 -NorFormulasOf R15 );
assume L728: R19 is ( R2 + 1 ) -wff;
L729: R19 in D460 by L728 , L544;
L730: R19 in ( ( D463 \/ D464 ) \/ D459 ) by L729 , L672;
L731: (R19 in D463 or R19 in D464 or R19 in D459) by L730 , L425;
assume L732: R19 is non R2 -wff;
assume L733: (not (ex B183 being  literal (Element of R15) st (ex B184 being R2 -wff (string of R15) st R19 = ( <* B183 *> ^ B184 ))));
L734: (R19 in D463 implies (ex B185 being  literal (Element of R15) st (ex B186 being R2 -wff (string of R15) st R19 = ( <* B185 *> ^ B186 ))))
proof
assume L735: R19 in D463;
consider C241 being (Element of D461), C242 being (Element of D459) such that L736: (R19 = ( <* C241 *> ^ C242 ) & (not contradiction)) by L735;
reconsider D465 = C242 as R2 -wff (string of R15) by L544;
reconsider D466 = C241 as  literal (Element of R15);
take D466;
take D465;
thus L737: thesis by L736;
end;
consider C243 , C244 being (Element of D459) such that L738: (R19 = ( ( <* D462 *> ^ C243 ) ^ C244 ) & (not contradiction)) by L734 , L733 , L732 , L731 , L544;
reconsider D467 = C243 , D468 = C244 as R2 -wff (string of R15) by L544;
take D467;
take D468;
thus L739: thesis by L738;
end;
registration
let R15 being Language;
let R2 being Nat;
let C245 , C246 being R2 -wff (string of R15);
cluster ( ( <* ( TheNorSymbOf R15 ) *> ^ C245 ) ^ C246 ) -> ( R2 + 1 ) -wff for (string of R15);
coherence
proof
set D469 = ( TheNorSymbOf R15 );
set D470 = ( R15 -formulasOfMaxDepth R2 );
set D471 = ( R2 -NorFormulasOf R15 );
set D472 = ( R15 -formulasOfMaxDepth ( R2 + 1 ) );
set D473 = ( R2 -ExFormulasOf R15 );
set D474 = ( ( <* D469 *> ^ C245 ) ^ C246 );
reconsider D475 = C245 , D476 = C246 as (Element of D470) by L544;
L740: (D474 = ( ( <* D469 *> ^ D475 ) ^ D476 ) & (not contradiction));
L741: D474 in D471 by L740;
L742: D474 in ( ( D473 \/ D471 ) \/ D470 ) by L741 , L425;
reconsider D477 = D474 as (Element of D472) by L742 , L672;
L743: D477 is ( R2 + 1 ) -wff by L544;
thus L744: thesis by L743;
end;
end;
registration
let R15 being Language;
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
cluster ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ->  wff for (string of R15);
coherence
proof
set D478 = ( TheNorSymbOf R15 );
set D479 = ( ( <* D478 *> ^ R43 ) ^ R44 );
consider R2 being Nat such that L746: R43 is R2 -wff by L546;
consider R3 being Nat such that L747: R44 is R3 -wff by L546;
reconsider D480 = R43 as ( R2 + ( ( 0 ) * R3 ) ) -wff (string of R15) by L746;
reconsider D481 = R44 as ( R3 + ( ( 0 ) * R2 ) ) -wff (string of R15) by L747;
reconsider D482 = D480 as ( R2 + R3 ) -wff (string of R15);
reconsider D483 = D481 as ( R2 + R3 ) -wff (string of R15);
L748: ( ( <* D478 *> ^ D482 ) ^ D483 ) is ( ( R2 + R3 ) + 1 ) -wff ( ( R2 + R3 ) + 1 ) -wff ( ( R2 + R3 ) + 1 ) -wff ( ( R2 + R3 ) + 1 ) -wff (string of R15);
thus L749: thesis by L748;
end;
end;
registration
let R15 being Language;
let R2 being Nat;
let C247 being R2 -wff (string of R15);
let C248 being  literal (Element of R15);
cluster ( <* C248 *> ^ C247 ) -> ( R2 + 1 ) -wff for (string of R15);
coherence
proof
set D484 = ( LettersOf R15 );
set D485 = ( R15 -formulasOfMaxDepth R2 );
set D486 = ( R2 -NorFormulasOf R15 );
set D487 = ( R15 -formulasOfMaxDepth ( R2 + 1 ) );
set D488 = ( R2 -ExFormulasOf R15 );
set D489 = ( <* C248 *> ^ C247 );
reconsider D490 = C248 as (Element of D484) by FOMODEL1:def 14;
reconsider D491 = C247 as (Element of D485) by L544;
L751: (D489 = ( <* D490 *> ^ D491 ) & (not contradiction));
L752: D489 in D488 by L751;
L753: D489 in ( ( D488 \/ D486 ) \/ D485 ) by L752 , L425;
reconsider D492 = D489 as (Element of D487) by L753 , L672;
L754: D492 is ( R2 + 1 ) -wff by L544;
thus L755: thesis by L754;
end;
end;
registration
let R15 being Language;
let R35 being  literal (Element of R15);
let R42 being  wff (string of R15);
cluster ( <* R35 *> ^ R42 ) ->  wff for (string of R15);
coherence
proof
consider R2 being Nat such that L757: R42 is R2 -wff by L546;
reconsider D493 = R42 as R2 -wff (string of R15) by L757;
set D494 = ( <* R35 *> ^ D493 );
L758: D494 is ( R2 + 1 ) -wff;
thus L759: thesis by L758;
end;
end;
registration
let R15 being Language;
let R19 being (string of R15);
let C249 being non  relational (Element of R15);
cluster ( <* C249 *> ^ R19 ) -> non  0wff for (string of R15);
coherence
proof
set D495 = ( R15 -firstChar );
set D496 = ( <* C249 *> ^ R19 );
set D497 = ( AllSymbolsOf R15 );
L761: ( D495 . D496 ) = ( D496 . 1 ) by FOMODEL0:6
.= C249 by FINSEQ_1:41;
thus L762: thesis by L761;
end;
end;
registration
let R15 being Language;
let R20 being (string of R15);
let R21 being (string of R15);
let C250 being non  relational (Element of R15);
cluster ( ( <* C250 *> ^ R20 ) ^ R21 ) -> non  0wff for (string of R15);
coherence
proof
L764: ( ( <* C250 *> ^ R20 ) ^ R21 ) = ( <* C250 *> ^ ( R20 ^ R21 ) ) by FINSEQ_1:32;
thus L765: thesis by L764;
end;
end;
registration
let R15 being Language;
cluster ( TheNorSymbOf R15 ) -> non  relational for (Element of R15);
coherence;
end;
registration
let R15 being Language;
let R19 being (string of R15);
cluster ( <* ( TheNorSymbOf R15 ) *> ^ R19 ) -> non  0wff for (string of R15);
coherence;
end;
registration
let R15 being Language;
let R35 being  literal (Element of R15);
let R19 being (string of R15);
cluster ( <* R35 *> ^ R19 ) -> non  0wff for (string of R15);
coherence;
end;
definition
let R15 being Language;
let R19 being (string of R15);
attr R19 is  exal
means
:L770: ( ( R15 -firstChar ) . R19 ) is  literal;
end;
registration
let R15 being Language;
let R19 being (string of R15);
let R35 being  literal (Element of R15);
cluster ( <* R35 *> ^ R19 ) ->  exal for (string of R15);
coherence
proof
set D498 = ( <* R35 *> ^ R19 );
set D499 = ( R15 -firstChar );
L772: ( D499 . D498 ) = ( D498 . 1 ) by FOMODEL0:6
.= R35 by FINSEQ_1:41;
thus L773: thesis by L772 , L770;
end;
end;
registration
let R15 being Language;
let R38 being non  zero Nat;
cluster  exal for R38 -wff R38 -wff R38 -wff R38 -wff (string of R15);
existence
proof
consider R2 being Nat such that L775: R38 = ( R2 + 1 ) by NAT_1:6;
set D500 = the R2 -wff (string of R15);
set D501 = the  literal (Element of R15);
set D502 = ( <* D501 *> ^ D500 );
reconsider D503 = D502 as R38 -wff (string of R15) by L775;
take D503;
thus L776: thesis;
end;
end;
registration
let R15 being Language;
cluster  exal -> non  0wff for (string of R15);
coherence
proof
set D504 = ( R15 -firstChar );
let R19 being (string of R15);
assume L778: R19 is  exal;
L779: ( D504 . R19 ) is  literal by L778 , L770;
thus L780: thesis by L779;
end;
end;
registration
let R15 being Language;
let R38 being non  zero Nat;
cluster non  0wff for  exal R38 -wff  exal R38 -wff  exal R38 -wff  exal R38 -wff (string of R15);
existence
proof
set D505 = the  literal (Element of R15);
consider R2 being Nat such that L782: R38 = ( R2 + 1 ) by NAT_1:6;
set D506 = the R2 -wff (string of R15);
reconsider D507 = ( <* D505 *> ^ D506 ) as  exal R38 -wff (string of R15) by L782;
take D507;
thus L783: thesis;
end;
end;
registration
let R15 being Language;
cluster non  0wff for  exal  wff  exal  wff  exal  wff  exal  wff (string of R15);
existence
proof
set D508 = the non  zero Nat;
set D509 = the non  0wff  exal D508 -wff (string of R15);
take D509;
thus L785: thesis;
end;
end;
L787: (for R15 being Language holds (for R42 being  wff (string of R15) holds (R42 is non  0wff implies ( Depth R42 ) <> ( 0 ))))
proof
let R15 being Language;
let R42 being  wff (string of R15);
assume L788: R42 is non  0wff;
L789: (not R42 is ( 0 ) -wff) by L788;
thus L790: ( Depth R42 ) <> ( 0 ) by L789 , L708;
end;
registration
let R15 being Language;
let C251 being non  0wff  wff (string of R15);
cluster ( Depth C251 ) -> non  zero for Nat;
coherence by L787;
end;
L792: (for R15 being Language holds (for R19 being (string of R15) holds ((R19 is  wff & R19 is non  0wff) implies (( R19 . 1 ) in ( LettersOf R15 ) or ( R19 . 1 ) = ( TheNorSymbOf R15 )))))
proof
let R15 being Language;
let R19 being (string of R15);
set D510 = ( LettersOf R15 );
set D511 = ( TheNorSymbOf R15 );
set D512 = ( AllSymbolsOf R15 );
assume L793: R19 is  wff;
reconsider D513 = R19 as  wff (string of R15) by L793;
set D514 = ( Depth D513 );
assume L794: R19 is non  0wff;
consider R2 being Nat such that L795: D514 = ( R2 + 1 ) by L794 , NAT_1:6;
L796: (D513 is ( R2 + 1 ) -wff & (not D513 is R2 -wff)) by L708 , L795;
per cases  by L796 , L727;
suppose L797: (ex B187 being  literal (Element of R15) st (ex B188 being R2 -wff (string of R15) st R19 = ( <* B187 *> ^ B188 )));

consider C252 being  literal (Element of R15), C253 being R2 -wff (string of R15) such that L798: R19 = ( <* C252 *> ^ C253 ) by L797;
L799: C252 = ( R19 . 1 ) by L798 , FINSEQ_1:41;
thus L800: thesis by L799 , FOMODEL1:def 14;
end;
suppose L801: (ex B189 , B190 being R2 -wff (string of R15) st R19 = ( ( <* D511 *> ^ B189 ) ^ B190 ));

consider C254 , C255 being R2 -wff (string of R15) such that L802: R19 = ( ( <* D511 *> ^ C254 ) ^ C255 ) by L801;
L803: ( R19 . 1 ) = ( ( <* D511 *> ^ ( C254 ^ C255 ) ) . 1 ) by L802 , FINSEQ_1:32
.= D511 by FINSEQ_1:41;
thus L804: thesis by L803;
end;
end;
registration
let R15 being Language;
let C256 being non  0wff  wff (string of R15);
cluster ( ( R15 -firstChar ) . C256 ) -> non  relational for (Element of R15);
coherence
proof
set D515 = ( R15 -firstChar );
set D516 = ( LettersOf R15 );
set D517 = ( TheNorSymbOf R15 );
set D518 = ( AllSymbolsOf R15 );
per cases  by L792;
suppose L806: ( C256 . 1 ) in D516;

reconsider D519 = ( D515 . C256 ) as (Element of D516) by L806 , FOMODEL0:6;
L807: D519 is non  relational;
thus L808: thesis by L807;
end;
suppose L809: ( C256 . 1 ) = D517;

thus L810: thesis by L809 , FOMODEL0:6;
end;
end;
end;
L813: (for R2 being Nat holds (for R15 being Language holds ( R15 -formulasOfMaxDepth R2 ) is R15 -prefix))
proof
let R2 being Nat;
let R15 being Language;
set D520 = ( AllSymbolsOf R15 );
set D521 = ( AtomicFormulasOf R15 );
set D522 = ( TheNorSymbOf R15 );
set D523 = ( R15 -formulasOfMaxDepth ( 0 ) );
set D524 = ( R15 -firstChar );
defpred S18[ Nat ] means ( R15 -formulasOfMaxDepth $1 ) is D520 -prefix;
L814: S18[ ( 0 ) ];
L815: (for R3 being Nat holds (S18[ R3 ] implies S18[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
assume L816: S18[ R3 ];
set D525 = ( R3 + 1 );
set D526 = ( R15 -formulasOfMaxDepth D525 );
set D527 = ( R15 -formulasOfMaxDepth R3 );
L817: ( D526 \ D523 ) is D520 -prefix
proof
L818:
now
let C257 , C258 , C259 , C260 being D520 -valued FinSequence;
assume L819: C257 in ( D526 \ D523 );
reconsider D528 = C257 as D525 -wff (string of R15) by L819 , L544;
consider C261 being Nat such that L820: (D528 is ( C261 + 1 ) -wff & (not D528 is C261 -wff) & ( C261 + 1 ) <= D525) by L719 , L819;
assume L821: C259 in ( D526 \ D523 );
reconsider D529 = C259 as D525 -wff (string of R15) by L821 , L544;
consider C262 being Nat such that L822: (D529 is ( C262 + 1 ) -wff & (not D529 is C262 -wff) & ( C262 + 1 ) <= D525) by L719 , L821;
L823: (C261 <= R3 & C262 <= R3) by L820 , L822 , XREAL_1:6;
consider C263 being Nat such that L824: R3 = ( C261 + C263 ) by L823 , NAT_1:10;
consider C264 being Nat such that L825: R3 = ( C262 + C264 ) by L823 , NAT_1:10;
assume L826: ( C257 ^ C258 ) = ( C259 ^ C260 );
per cases  by L727 , L820;
suppose L827: (ex B191 being  literal (Element of R15) st (ex B192 being C261 -wff (string of R15) st D528 = ( <* B191 *> ^ B192 )));

consider C265 being  literal (Element of R15), C266 being C261 -wff (string of R15) such that L828: D528 = ( <* C265 *> ^ C266 ) by L827;
per cases  by L727 , L822;
suppose L829: (ex B193 being  literal (Element of R15) st (ex B194 being C262 -wff (string of R15) st D529 = ( <* B193 *> ^ B194 )));

consider C267 being  literal (Element of R15), C268 being C262 -wff (string of R15) such that L830: D529 = ( <* C267 *> ^ C268 ) by L829;
L831: ( ( <* C267 *> ^ C268 ) ^ C260 ) = ( <* C265 *> ^ ( C266 ^ C258 ) ) by L830 , L826 , L828 , FINSEQ_1:32;
L832: ( <* C267 *> ^ ( C268 ^ C260 ) ) = ( <* C265 *> ^ ( C266 ^ C258 ) ) by L831 , FINSEQ_1:32;
L833: ( ( <* C267 *> ^ ( C268 ^ C260 ) ) . 1 ) = C265 by L832 , FINSEQ_1:41;
L834: C267 = C265 by L833 , FINSEQ_1:41;
L835: ( <* C265 *> ^ ( C268 ^ C260 ) ) = ( <* C265 *> ^ ( C266 ^ C258 ) ) by L832 , L833 , FINSEQ_1:41;
L836: ( C268 ^ C260 ) = ( C266 ^ C258 ) by L835 , FINSEQ_1:33;
L837: (C266 is ( C261 + ( ( 0 ) * C263 ) ) -wff & C268 is ( C262 + ( ( 0 ) * C264 ) ) -wff);
L838: (C266 in D527 & C268 in D527) by L837 , L824 , L825 , L544;
thus L839: (C257 = C259 & C258 = C260) by L838 , L828 , L834 , L830 , L816 , L836 , FOMODEL0:def 20;
end;
suppose L840: (ex B195 , B196 being C262 -wff (string of R15) st D529 = ( ( <* D522 *> ^ B195 ) ^ B196 ));

consider C269 , C270 being C262 -wff (string of R15) such that L841: D529 = ( ( <* D522 *> ^ C269 ) ^ C270 ) by L840;
L842: ( D528 . 1 ) = ( ( D529 ^ C260 ) . 1 ) by L826 , FOMODEL0:28
.= ( D529 . 1 ) by FOMODEL0:28
.= ( ( <* D522 *> ^ ( C269 ^ C270 ) ) . 1 ) by L841 , FINSEQ_1:32
.= D522 by FINSEQ_1:41;
thus L843: (C257 = C259 & C258 = C260) by L842 , L828 , FINSEQ_1:41;
end;
end;
suppose L845: (ex B197 , B198 being C261 -wff (string of R15) st D528 = ( ( <* D522 *> ^ B197 ) ^ B198 ));

consider C271 , C272 being C261 -wff (string of R15) such that L846: D528 = ( ( <* D522 *> ^ C271 ) ^ C272 ) by L845;
L847: ( D528 . 1 ) = ( ( <* D522 *> ^ ( C271 ^ C272 ) ) . 1 ) by L846 , FINSEQ_1:32
.= D522 by FINSEQ_1:41;
per cases  by L822 , L727;
suppose L848: (ex B199 being  literal (Element of R15) st (ex B200 being C262 -wff (string of R15) st D529 = ( <* B199 *> ^ B200 )));

consider C273 being  literal (Element of R15), C274 being C262 -wff (string of R15) such that L849: D529 = ( <* C273 *> ^ C274 ) by L848;
L850: ( D528 . 1 ) = ( ( D529 ^ C260 ) . 1 ) by L826 , FOMODEL0:28
.= ( ( <* C273 *> ^ C274 ) . 1 ) by L849 , FOMODEL0:28
.= C273 by FINSEQ_1:41;
thus L851: (C257 = C259 & C258 = C260) by L850 , L847;
end;
suppose L852: (ex B201 , B202 being C262 -wff (string of R15) st D529 = ( ( <* D522 *> ^ B201 ) ^ B202 ));

consider C275 , C276 being C262 -wff (string of R15) such that L853: D529 = ( ( <* D522 *> ^ C275 ) ^ C276 ) by L852;
L854: (C271 is ( C261 + ( ( 0 ) * C263 ) ) -wff & C275 is ( C262 + ( ( 0 ) * C264 ) ) -wff);
L855: (C271 in D527 & C275 in D527 & C272 in D527 & C276 in D527) by L854 , L824 , L825 , L544;
L856: ( <* D522 *> ^ ( ( C271 ^ C272 ) ^ C258 ) ) = ( ( <* D522 *> ^ ( C271 ^ C272 ) ) ^ C258 ) by FINSEQ_1:32
.= ( ( ( <* D522 *> ^ C275 ) ^ C276 ) ^ C260 ) by L846 , L853 , L826 , FINSEQ_1:32
.= ( ( <* D522 *> ^ ( C275 ^ C276 ) ) ^ C260 ) by FINSEQ_1:32
.= ( <* D522 *> ^ ( ( C275 ^ C276 ) ^ C260 ) ) by FINSEQ_1:32;
L857: ( ( C271 ^ C272 ) ^ C258 ) = ( ( C275 ^ C276 ) ^ C260 ) by L856 , FINSEQ_1:33
.= ( C275 ^ ( C276 ^ C260 ) ) by FINSEQ_1:32;
L858: ( C271 ^ ( C272 ^ C258 ) ) = ( C275 ^ ( C276 ^ C260 ) ) by L857 , FINSEQ_1:32;
L859: (C271 = C275 & ( C272 ^ C258 ) = ( C276 ^ C260 )) by L858 , L816 , L855 , FOMODEL0:def 20;
thus L860: (C257 = C259 & C258 = C260) by L859 , L846 , L853 , L816 , L855 , FOMODEL0:def 20;
end;
end;
end;
thus L863: thesis by L818 , FOMODEL0:def 20;
end;
L864:
now
let C277 , C278 , C279 , C280 being D520 -valued FinSequence;
assume L865: (C277 in D526 & C279 in D526 & ( C277 ^ C278 ) = ( C279 ^ C280 ));
reconsider D530 = C277 , D531 = C279 as D525 -wff (string of R15) by L865 , L544;
per cases ;
suppose L866: D530 in D523;

L867: D530 is ( 0 ) -wff by L866 , L544;
reconsider D532 = D530 as  0wff (string of R15) by L867;
L868: ( D524 . D532 ) is  relational  relational  relational  relational (Element of R15);
L869: ( D530 . 1 ) is  relational  relational  relational  relational (Element of R15) by L868 , FOMODEL0:6;
L870: ( ( D531 ^ C280 ) . 1 ) is  relational  relational  relational  relational (Element of R15) by L869 , L865 , FOMODEL0:28;
L871: ( D531 . 1 ) is  relational  relational  relational  relational (Element of R15) by L870 , FOMODEL0:28;
L872: ( D524 . D531 ) is  relational by L871 , FOMODEL0:6;
L873: D531 is  0wff by L872;
L874: D531 is ( 0 ) -wff by L873;
L875: (D531 in D523 & D530 in D523) by L874 , L866 , L544;
thus L876: (C277 = C279 & C278 = C280) by L875 , L865 , FOMODEL0:def 20;
end;
suppose L877: (not D530 in D523);

L878: D530 is non ( 0 ) -wff by L877 , L544;
reconsider D533 = D530 as non  0wff  wff (string of R15) by L878;
L879: ( D524 . D531 ) = ( D531 . 1 ) by FOMODEL0:6
.= ( ( D530 ^ C278 ) . 1 ) by L865 , FOMODEL0:28
.= ( D530 . 1 ) by FOMODEL0:28
.= ( D524 . D533 ) by FOMODEL0:6;
L880: D531 is non ( 0 ) -wff by L879;
L881: (not D531 in D523) by L880 , L544;
L882: (D530 in ( D526 \ D523 ) & D531 in ( D526 \ D523 )) by L881 , L865 , L877 , XBOOLE_0:def 5;
thus L883: (C277 = C279 & C278 = C280) by L882 , L865 , L817 , FOMODEL0:def 20;
end;
end;
thus L885: thesis by L864 , FOMODEL0:def 20;
end;
L886: (for R3 being Nat holds S18[ R3 ]) from NAT_1:sch 2(L814 , L815);
L887: ( R15 -formulasOfMaxDepth R2 ) is D520 -prefix by L886;
thus L888: thesis by L887;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster ( R15 -formulasOfMaxDepth R2 ) -> R15 -prefix for set;
coherence by L813;
end;
definition
let R15 being Language;
redefine func AllFormulasOf R15 -> (Subset of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ));

coherence
proof
set D534 = ( AllFormulasOf R15 );
set D535 = ( AllSymbolsOf R15 );
set D536 = ( ( D535 * ) \ { ( {} ) } );
L890:
now
let R12 being set;
assume L891: R12 in D534;
consider C281 being (string of R15) such that L892: (R12 = C281 & (ex R2 being Nat st C281 is R2 -wff)) by L891;
thus L893: R12 in D536 by L892;
end;
thus L894: thesis by L890 , TARSKI:def 3;
end;
end;
registration
let R15 being Language;
cluster  ->  wff for (Element of ( AllFormulasOf R15 ));
coherence
proof
set D537 = ( AllFormulasOf R15 );
let C282 being (Element of D537);
L896: C282 in D537;
consider C283 being (string of R15) such that L897: (C282 = C283 & (ex R2 being Nat st C283 is R2 -wff)) by L896;
thus L898: thesis by L897;
end;
end;
L900: (for R15 being Language holds ( AllFormulasOf R15 ) is R15 -prefix)
proof
let R15 being Language;
set D538 = ( AllFormulasOf R15 );
set D539 = ( AllSymbolsOf R15 );
L901:
now
let C284 , C285 , C286 , C287 being D539 -valued FinSequence;
assume L902: (C284 in D538 & C286 in D538 & ( C284 ^ C285 ) = ( C286 ^ C287 ));
reconsider D540 = C284 , D541 = C286 as  wff (string of R15) by L902;
consider C288 being Nat such that L903: D540 is C288 -wff by L546;
consider C289 being Nat such that L904: D541 is C289 -wff by L546;
set D542 = ( C288 + C289 );
set D543 = ( R15 -formulasOfMaxDepth D542 );
L905: (D540 is ( C288 + ( ( 0 ) * C289 ) ) -wff & D541 is ( C289 + ( ( 0 ) * C288 ) ) -wff) by L903 , L904;
reconsider D544 = D540 , D545 = D541 as D542 -wff (string of R15) by L905;
L906: (D544 in D543 & D545 in D543) by L544;
thus L907: (C284 = C286 & C285 = C287) by L906 , L902 , FOMODEL0:def 20;
end;
L908: D538 is D539 -prefix by L901 , FOMODEL0:def 20;
thus L909: thesis by L908;
end;
registration
let R15 being Language;
cluster ( AllFormulasOf R15 ) -> R15 -prefix for set;
coherence by L900;
end;
theorem
L911: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( dom ( NorIterator ( (R15 , R22) -TruthEval R2 ) ) ) = [: ( R22 -InterpretersOf R15 ) , ( R2 -NorFormulasOf R15 ) :]))) by L629;
theorem
L912: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds ( dom ( ExIterator ( (R15 , R22) -TruthEval R2 ) ) ) = [: ( R22 -InterpretersOf R15 ) , ( R2 -ExFormulasOf R15 ) :]))) by L651;
L913: (for R22 being non  empty set holds ( ( R22 -deltaInterpreter ) " { 1 } ) = ( ( R22 -concatenation ) .: ( id ( 1 -tuples_on R22 ) ) ))
proof
let R22 being non  empty set;
set D546 = ( R22 -deltaInterpreter );
set D547 = ( R22 -concatenation );
set D548 = ( 1 -tuples_on R22 );
set D549 = ( 2 -tuples_on R22 );
set D550 = ( D547 .: ( id D548 ) );
set D551 = D549;
L914: ( D546 " { 1 } ) = ( D550 /\ ( ( 1 + 1 ) -tuples_on R22 ) ) by FOMODEL0:24
.= ( ( D547 .: ( id D548 ) ) /\ ( D547 .: [: D548 , D548 :] ) ) by FOMODEL0:22;
reconsider D552 = ( D547 .: ( id D548 ) ) as (Subset of ( D547 .: [: D548 , D548 :] )) by RELAT_1:123;
L915: ( D552 /\ ( D547 .: [: D548 , D548 :] ) ) = ( D552 null ( D547 .: [: D548 , D548 :] ) )
.= D552;
thus L916: thesis by L915 , L914;
end;
theorem
L917: (for R22 being non  empty set holds ( ( R22 -deltaInterpreter ) " { 1 } ) = { <* B203 , B203 *> where B203 is (Element of R22) : (not contradiction) })
proof
let R22 being non  empty set;
set D553 = { <* B204 , B204 *> where B204 is (Element of R22) : (not contradiction) };
set D554 = ( ( R22 -deltaInterpreter ) " { 1 } );
set D555 = ( ( R22 -concatenation ) .: ( id ( 1 -tuples_on R22 ) ) );
L918: (D554 = D555 & D555 = D553) by L913 , FOMODEL0:38;
thus L919: thesis by L918;
end;
definition
let R15 being Language;
redefine func TheEqSymbOf R15 -> (Element of R15);

coherence;
end;
registration
let R15 being Language;
cluster ( ( ar ( TheEqSymbOf R15 ) ) + 2 ) ->  zero for number;
coherence
proof
set D556 = ( TheEqSymbOf R15 );
L921: ( ar D556 ) = ( - 2 ) by FOMODEL1:def 23;
thus L922: thesis by L921;
end;
cluster ( ( abs ( ar ( TheEqSymbOf R15 ) ) ) - 2 ) ->  zero for number;
coherence
proof
set D557 = ( TheEqSymbOf R15 );
L923: ( abs ( - 2 ) ) = ( - ( - 2 ) ) by ABSVALUE:def 1
.= 2;
L924: ( abs ( ar D557 ) ) = 2 by L923 , FOMODEL1:def 23;
thus L925: thesis by L924;
end;
end;
theorem
L927: (for R15 being Language holds (for R22 being non  empty set holds (for B205 being  0wff (string of R15) holds (for B206 being (R15 , R22)-interpreter-like Function holds ((( ( R15 -firstChar ) . B205 ) <> ( TheEqSymbOf R15 ) implies ( B206 -AtomicEval B205 ) = ( ( B206 . ( ( R15 -firstChar ) . B205 ) ) . ( ( B206 -TermEval ) * ( SubTerms B205 ) ) )) & (( ( R15 -firstChar ) . B205 ) = ( TheEqSymbOf R15 ) implies ( B206 -AtomicEval B205 ) = ( ( R22 -deltaInterpreter ) . ( ( B206 -TermEval ) * ( SubTerms B205 ) ) )))))))
proof
let R15 being Language;
let R22 being non  empty set;
let C290 being  0wff (string of R15);
let C291 being (R15 , R22)-interpreter-like Function;
set D558 = ( AllTermsOf R15 );
set D559 = ( TheEqSymbOf R15 );
set D560 = ( SubTerms C290 );
set D561 = ( R15 -firstChar );
set D562 = ( D561 . C290 );
set D563 = ( abs ( ar D562 ) );
set D564 = ( AtomicFormulasOf R15 );
set D565 = ( R22 -deltaInterpreter );
set D566 = ( SubTerms C290 );
set D567 = ( C291 -AtomicEval C290 );
set D568 = ( ( C291 === ) . D562 );
set D569 = ( C291 -TermEval );
set D570 = ( C291 . D562 );
L928: ( ( abs ( ar D559 ) ) - 2 ) = ( 0 );
thus L929: (D562 <> D559 implies D567 = ( ( C291 . ( D561 . C290 ) ) . ( D569 * D566 ) ))
proof
assume L930: D562 <> D559;
L931: (not D562 in { D559 }) by L930 , TARSKI:def 1;
L932: (not D562 in ( dom ( D559 .--> D565 ) )) by L931;
thus L933: D567 = ( D570 . ( D569 * D566 ) ) by L932 , FUNCT_4:11;
end;

assume L934: D562 = D559;
L935: (D562 in { D559 } & D563 = 2) by L934 , L928 , TARSKI:def 1;
L936: D562 in ( dom ( D559 .--> D565 ) ) by L935 , FUNCOP_1:13;
L937: D568 = ( ( D559 .--> D565 ) . D562 ) by L936 , FUNCT_4:13
.= D565 by L935 , FUNCOP_1:7;
thus L938: D567 = ( D565 . ( D569 * D566 ) ) by L937;
end;
theorem
L939: (for R15 being Language holds (for R22 being non  empty set holds (for B207 being (R15 , R22)-interpreter-like Function holds (for B208 being  0wff (string of R15) holds (( ( R15 -firstChar ) . B208 ) = ( TheEqSymbOf R15 ) implies (( B207 -AtomicEval B208 ) = 1 iff ( ( B207 -TermEval ) . ( ( SubTerms B208 ) . 1 ) ) = ( ( B207 -TermEval ) . ( ( SubTerms B208 ) . 2 ) )))))))
proof
let R15 being Language;
let R22 being non  empty set;
let C292 being (R15 , R22)-interpreter-like Function;
let C293 being  0wff (string of R15);
set D571 = ( TheEqSymbOf R15 );
set D572 = ( SubTerms C293 );
set D573 = ( R15 -firstChar );
set D574 = ( D573 . C293 );
set D575 = ( C292 -TermEval );
set D576 = ( C292 -AtomicEval C293 );
set D577 = ( R22 -deltaInterpreter );
set D578 = ( 2 -tuples_on R22 );
set D579 = ( AllTermsOf R15 );
set D580 = { <* B209 , B209 *> where B209 is (Element of R22) : (not contradiction) };
set D581 = ( abs ( ar D574 ) );
L940: D578 = { <* B210 , B211 *> where B210 , B211 is (Element of R22) : (not contradiction) } by FINSEQ_2:99;
L941: ( ( abs ( ar D571 ) ) - 2 ) = ( 0 );
reconsider D582 = D574 as  relational (Element of R15);
set D583 = ( ( C292 === ) . D582 );
reconsider D584 = D571 as  relational (Element of R15);
assume L942: D574 = D571;
L943: (D576 = ( D577 . ( D575 * D572 ) ) & D581 = 2) by L942 , L927 , L941;
L944: (D576 = 1 iff ( D575 * D572 ) in ( D577 " { 1 } )) by L943 , FOMODEL0:25;
L945: (D576 = 1 iff ( D575 * D572 ) in D580) by L944 , L917;
reconsider D585 = D572 as 2 -element (FinSequence of D579) by L942 , L941 , FINSEQ_1:def 11;
reconsider D586 = ( D575 * D585 ) as (FinSequence of R22);
reconsider D587 = D586 as (Element of D578) by FOMODEL0:16;
L946: D587 in D578;
consider C294 , C295 being (Element of R22) such that L947: (D587 = <* C294 , C295 *> & (not contradiction)) by L946 , L940;
L948: (( D587 . 1 ) = C294 & ( D587 . 2 ) = C295) by L947 , FINSEQ_1:44;
L949: 1 <= 2;
L950: (1 <= 1 & 1 <= ( len D586 ) & 1 <= 2 & 2 <= ( len D586 )) by L949 , CARD_1:def 7;
L951: (1 in ( Seg ( len D586 ) ) & 2 in ( Seg ( len D586 ) )) by L950;
L952: (1 in ( dom D586 ) & 2 in ( dom D586 )) by L951 , FINSEQ_1:def 3;
L953: (( D586 . 1 ) = ( D575 . ( D572 . 1 ) ) & ( D586 . 2 ) = ( D575 . ( D572 . 2 ) )) by L952 , FUNCT_1:12;
L954: (D586 in D580 implies ( D575 . ( D572 . 1 ) ) = ( D575 . ( D572 . 2 ) ))
proof
assume L955: D586 in D580;
consider C296 being (Element of R22) such that L956: (<* C296 , C296 *> = D586 & (not contradiction)) by L955;
L957: (( D586 . 1 ) = C296 & ( D586 . 2 ) = C296) by L956 , FINSEQ_1:44;
thus L958: thesis by L957 , L953;
end;
thus L959: thesis by L954 , L945 , L953 , L947 , L948;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster ( R2 -ExFormulasOf R15 ) -> non  empty for set;
coherence
proof
set D588 = ( R2 -ExFormulasOf R15 );
set D589 = ( LettersOf R15 );
set D590 = ( R15 -formulasOfMaxDepth R2 );
set D591 = the (Element of D589);
set D592 = the (Element of D590);
set D593 = ( <* D591 *> ^ D592 );
L960: D593 in D588;
thus L961: thesis by L960;
end;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster ( R2 -NorFormulasOf R15 ) -> non  empty for set;
coherence
proof
set D594 = ( R2 -NorFormulasOf R15 );
set D595 = ( R15 -formulasOfMaxDepth R2 );
set D596 = ( TheNorSymbOf R15 );
set D597 = the (Element of D595);
set D598 = the (Element of D595);
L963: ( ( <* D596 *> ^ D597 ) ^ D598 ) in D594;
thus L964: thesis by L963;
end;
end;
definition
let R15 being Language;
let R2 being Nat;
redefine func R2 -NorFormulasOf R15 -> (Subset of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ));

coherence
proof
set D599 = ( R2 -NorFormulasOf R15 );
set D600 = ( R15 -formulasOfMaxDepth R2 );
set D601 = ( TheNorSymbOf R15 );
set D602 = ( AllSymbolsOf R15 );
L966:
now
let R12 being set;
assume L967: R12 in D599;
consider C297 , C298 being (Element of D600) such that L968: (R12 = ( ( <* D601 *> ^ C297 ) ^ C298 ) & (not contradiction)) by L967;
thus L969: R12 in ( ( D602 * ) \ { ( {} ) } ) by L968;
end;
thus L970: thesis by L966 , TARSKI:def 3;
end;
end;
registration
let R15 being Language;
let C299 being  exal (string of R15);
cluster ( ( R15 -firstChar ) . C299 ) ->  literal for (Element of R15);
coherence by L770;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster  -> non  exal for (Element of ( R2 -NorFormulasOf R15 ));
coherence
proof
set D603 = ( R2 -NorFormulasOf R15 );
set D604 = ( R15 -formulasOfMaxDepth R2 );
set D605 = ( R15 -firstChar );
set D606 = ( TheNorSymbOf R15 );
set D607 = ( AllSymbolsOf R15 );
let C300 being (Element of D603);
L973: C300 in D603;
consider C301 , C302 being (Element of D604) such that L974: (C300 = ( ( <* D606 *> ^ C301 ) ^ C302 ) & (not contradiction)) by L973;
reconsider D608 = C300 as (string of R15);
L975: ( D605 . D608 ) = ( D608 . 1 ) by FOMODEL0:6
.= ( ( <* D606 *> ^ ( C301 ^ C302 ) ) . 1 ) by L974 , FINSEQ_1:32
.= D606 by FINSEQ_1:41;
thus L976: thesis by L975;
end;
end;
L978: (for R2 being Nat holds (for R15 being Language holds (for R42 being  wff (string of R15) holds ((( Depth R42 ) = ( R2 + 1 ) & R42 is  exal) implies R42 in ( R2 -ExFormulasOf R15 )))))
proof
let R2 being Nat;
let R15 being Language;
let R42 being  wff (string of R15);
set D609 = ( Depth R42 );
set D610 = ( R15 -formulasOfMaxDepth R2 );
set D611 = ( R2 -ExFormulasOf R15 );
set D612 = ( R15 -formulasOfMaxDepth ( R2 + 1 ) );
set D613 = ( R2 -NorFormulasOf R15 );
L979: ( D612 \ D610 ) = ( ( ( D611 \/ D613 ) \/ D610 ) \ D610 ) by L672
.= ( ( D611 \/ D613 ) \ D610 ) by XBOOLE_1:40;
assume L980: D609 = ( R2 + 1 );
L981: (R42 is ( R2 + 1 ) -wff & (not R42 is R2 -wff)) by L980 , L708;
L982: (R42 in D612 & (not R42 in D610)) by L981 , L544;
L983: R42 in ( D612 \ D610 ) by L982 , XBOOLE_0:def 5;
assume L984: R42 is  exal;
L985: (not R42 in D613) by L984;
thus L986: R42 in D611 by L985 , L983 , L979 , XBOOLE_0:def 3;
end;
L987: (for R15 being Language holds (for R35 being  literal (Element of R15) holds (for R43 being  wff (string of R15) holds ( Depth ( <* R35 *> ^ R43 ) ) > ( Depth R43 ))))
proof
let R15 being Language;
let R35 being  literal (Element of R15);
let R43 being  wff (string of R15);
set D614 = ( TheNorSymbOf R15 );
set D615 = ( <* R35 *> ^ R43 );
set D616 = ( Depth R43 );
set D617 = ( Depth D615 );
set D618 = ( LettersOf R15 );
consider R3 being Nat such that L988: D617 = ( R3 + 1 ) by NAT_1:6;
set D619 = ( R15 -formulasOfMaxDepth R3 );
L989: D615 in ( R3 -ExFormulasOf R15 ) by L978 , L988;
consider C303 being (Element of D618), C304 being (Element of D619) such that L990: (D615 = ( <* C303 *> ^ C304 ) & (not contradiction)) by L989;
L991: D616 <= R3 by L708;
L992: ( D616 + ( 0 ) ) < ( R3 + 1 ) by L991 , XREAL_1:8;
thus L993: thesis by L992 , L988;
end;
definition
let R15 being Language;
let R2 being Nat;
redefine func R2 -ExFormulasOf R15 -> (Subset of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ));

coherence
proof
set D620 = ( R2 -ExFormulasOf R15 );
set D621 = ( AllSymbolsOf R15 );
set D622 = ( R15 -formulasOfMaxDepth R2 );
set D623 = ( LettersOf R15 );
L994:
now
let R12 being set;
assume L995: R12 in D620;
consider C305 being (Element of D623), C306 being (Element of D622) such that L996: (R12 = ( <* C305 *> ^ C306 ) & (not contradiction)) by L995;
thus L997: R12 in ( ( D621 * ) \ { ( {} ) } ) by L996;
end;
thus L998: thesis by L994 , TARSKI:def 3;
end;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster  ->  exal for (Element of ( R2 -ExFormulasOf R15 ));
coherence
proof
set D624 = ( R2 -ExFormulasOf R15 );
set D625 = ( LettersOf R15 );
set D626 = ( R15 -formulasOfMaxDepth R2 );
let C307 being (Element of D624);
L1000: C307 in D624;
consider C308 being (Element of D625), C309 being (Element of D626) such that L1001: C307 = ( <* C308 *> ^ C309 ) by L1000;
thus L1002: thesis by L1001;
end;
end;
L1004: (for R2 being Nat holds (for R15 being Language holds (for R42 being  wff (string of R15) holds ((( Depth R42 ) = ( R2 + 1 ) & (not R42 is  exal)) implies R42 in ( R2 -NorFormulasOf R15 )))))
proof
let R2 being Nat;
let R15 being Language;
let R42 being  wff (string of R15);
set D627 = ( Depth R42 );
set D628 = ( R15 -formulasOfMaxDepth R2 );
set D629 = ( R2 -ExFormulasOf R15 );
set D630 = ( R15 -formulasOfMaxDepth ( R2 + 1 ) );
set D631 = ( R2 -NorFormulasOf R15 );
L1005: ( D630 \ D628 ) = ( ( ( D629 \/ D631 ) \/ D628 ) \ D628 ) by L672
.= ( ( D629 \/ D631 ) \ D628 ) by XBOOLE_1:40;
assume L1006: D627 = ( R2 + 1 );
L1007: (R42 is ( R2 + 1 ) -wff & (not R42 is R2 -wff)) by L1006 , L708;
L1008: (R42 in D630 & (not R42 in D628)) by L1007 , L544;
L1009: R42 in ( D630 \ D628 ) by L1008 , XBOOLE_0:def 5;
assume L1010: (not R42 is  exal);
L1011: (not R42 in D629) by L1010;
thus L1012: R42 in D631 by L1011 , L1005 , L1009 , XBOOLE_0:def 3;
end;
registration
let R15 being Language;
cluster non  literal for (Element of R15);
existence
proof
take ( TheNorSymbOf R15 );
thus L1013: thesis;
end;
end;
registration
let R15 being Language;
let R19 being (string of R15);
let C310 being non  literal (Element of R15);
cluster ( <* C310 *> ^ R19 ) -> non  exal for (string of R15);
coherence
proof
set D632 = ( <* C310 *> ^ R19 );
set D633 = ( R15 -firstChar );
set D634 = ( AllSymbolsOf R15 );
L1015: ( D633 . D632 ) = ( D632 . 1 ) by FOMODEL0:6
.= C310 by FINSEQ_1:41;
thus L1016: thesis by L1015;
end;
end;
registration
let R15 being Language;
let R20 being (string of R15);
let R21 being (string of R15);
let C311 being non  literal (Element of R15);
cluster ( ( <* C311 *> ^ R20 ) ^ R21 ) -> non  exal for (string of R15);
coherence
proof
L1018: ( ( <* C311 *> ^ R20 ) ^ R21 ) = ( <* C311 *> ^ ( R20 ^ R21 ) ) by FINSEQ_1:32;
thus L1019: thesis by L1018;
end;
end;
registration
let R15 being Language;
cluster ( TheNorSymbOf R15 ) -> non  literal for (Element of R15);
coherence;
end;
theorem
L1022: (for R15 being Language holds (for R42 being  wff (string of R15) holds R42 in ( AllFormulasOf R15 )))
proof
let R15 being Language;
let R42 being  wff (string of R15);
set D635 = ( AllFormulasOf R15 );
consider R2 being Nat such that L1023: R42 is R2 -wff by L546;
thus L1024: thesis by L1023;
end;
L1025: (for R15 being Language holds (for R43 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds (( Depth ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) > ( Depth R43 ) & ( Depth ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) > ( Depth R44 )))))
proof
let R15 being Language;
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
set D636 = ( TheNorSymbOf R15 );
set D637 = ( ( <* D636 *> ^ R43 ) ^ R44 );
set D638 = ( Depth R43 );
set D639 = ( Depth R44 );
set D640 = ( Depth D637 );
set D641 = ( LettersOf R15 );
set D642 = ( AllFormulasOf R15 );
set D643 = ( AllSymbolsOf R15 );
consider R3 being Nat such that L1026: D640 = ( R3 + 1 ) by NAT_1:6;
set D644 = ( R15 -formulasOfMaxDepth R3 );
L1027: D637 in ( R3 -NorFormulasOf R15 ) by L1004 , L1026;
consider C312 , C313 being (Element of D644) such that L1028: (D637 = ( ( <* D636 *> ^ C312 ) ^ C313 ) & (not contradiction)) by L1027;
reconsider D645 = C312 , D646 = C313 as R3 -wff (string of R15) by L544;
L1029: ( <* D636 *> ^ ( R43 ^ R44 ) ) = D637 by FINSEQ_1:32
.= ( <* D636 *> ^ ( C312 ^ C313 ) ) by L1028 , FINSEQ_1:32;
L1030: ( R43 ^ R44 ) = ( D645 ^ D646 ) by L1029 , FINSEQ_1:33;
L1031: (D638 <= R3 & D639 <= R3) by L708;
L1032: (( D638 + ( 0 ) ) < ( R3 + 1 ) & ( D639 + ( 0 ) ) < ( R3 + 1 )) by L1031 , XREAL_1:8;
thus L1033: thesis by L1032 , L1026;
end;
L1034: (for R15 being Language holds (for R43 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds ( Depth ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) = ( ( max (( Depth R43 ) , ( Depth R44 )) ) + 1 ))))
proof
let R15 being Language;
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
set D647 = ( TheNorSymbOf R15 );
set D648 = ( ( <* D647 *> ^ R43 ) ^ R44 );
set D649 = ( Depth R43 );
set D650 = ( Depth R44 );
set D651 = ( max (D649 , D650) );
set D652 = ( Depth D648 );
L1035: (D652 <= D652 & D652 > D649 & D652 > D650) by L1025;
L1036: D652 > D651 by L1035 , XXREAL_0:def 10;
L1037: ( D651 + 1 ) <= D652 by L1036 , NAT_1:13;
reconsider D653 = ( D651 - D649 ) , D654 = ( D651 - D650 ) as Nat;
L1038: (R43 is ( D649 + ( ( 0 ) * D653 ) ) -wff & R44 is ( D650 + ( ( 0 ) * D654 ) ) -wff) by L708;
L1039: (R43 is ( D649 + D653 ) -wff & R44 is ( D650 + D654 ) -wff) by L1038;
reconsider D655 = R43 , D656 = R44 as D651 -wff (string of R15) by L1039;
thus L1040: D652 = ( D651 + 1 ) by L708;
end;
notation
let R15 being Language;
let R2 being Nat;
let R19 being (string of R15);
antonym R19 is R2 -nonwff for R19 is R2 -wff;
end;
registration
let R2 being Nat;
let R15 being Language;
cluster non R2 -wff -> R2 -nonwff for (string of R15);
coherence;
end;
registration
let R15 being Language;
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
cluster ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) -> ( max (( Depth R43 ) , ( Depth R44 )) ) -nonwff for (string of R15);
coherence
proof
set D657 = ( TheNorSymbOf R15 );
set D658 = ( ( <* D657 *> ^ R43 ) ^ R44 );
set D659 = ( Depth R43 );
set D660 = ( Depth R44 );
set D661 = ( Depth D658 );
set D662 = ( max (D659 , D660) );
L1043: D661 = ( D662 + 1 ) by L1034;
L1044: D661 > ( D662 + ( 0 ) ) by L1043 , XREAL_1:8;
thus L1045: thesis by L1044 , L708;
end;
end;
registration
let R15 being Language;
let R42 being  wff (string of R15);
let R35 being  literal (Element of R15);
cluster ( <* R35 *> ^ R42 ) -> ( Depth R42 ) -nonwff for (string of R15);
coherence
proof
set D663 = ( Depth R42 );
set D664 = ( <* R35 *> ^ R42 );
set D665 = ( Depth D664 );
L1047: D663 < D665 by L987;
thus L1048: thesis by L1047 , L708;
end;
end;
registration
let R15 being Language;
let R42 being  wff (string of R15);
let R35 being  literal (Element of R15);
cluster ( <* R35 *> ^ R42 ) -> ( 1 + ( Depth R42 ) ) -wff for (string of R15);
coherence
proof
set D666 = ( Depth R42 );
set D667 = ( <* R35 *> ^ R42 );
set D668 = ( Depth D667 );
reconsider D669 = R42 as D666 -wff (string of R15) by L708;
L1050: ( <* R35 *> ^ D669 ) is ( D666 + 1 ) -wff;
thus L1051: thesis by L1050;
end;
end;
L1053: (for R15 being Language holds (for R22 being non  empty set holds (for B212 being Relation holds (B212 in ( R22 -InterpretersOf R15 ) implies ( dom B212 ) = ( OwnSymbolsOf R15 )))))
proof
let R15 being Language;
let R22 being non  empty set;
set D670 = ( OwnSymbolsOf R15 );
set D671 = ( R22 -InterpretersOf R15 );
let C314 being Relation;
assume L1054: C314 in D671;
consider C315 being (Element of ( Funcs (D670 , ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) )) )) such that L1055: (C314 = C315 & C315 is (R15 , R22)-interpreter-like) by L1054;
reconsider D672 = C315 as (Function of D670 , ( PFuncs (( R22 * ) , ( R22 \/ ( BOOLEAN ) )) ));
thus L1056: ( dom C314 ) = D670 by L1055 , FUNCT_2:def 1;
end;
registration
let R15 being Language;
let R22 being non  empty set;
cluster  -> ( OwnSymbolsOf R15 ) -defined for (Element of ( R22 -InterpretersOf R15 ));
coherence
proof
set D673 = ( OwnSymbolsOf R15 );
set D674 = ( R22 -InterpretersOf R15 );
let C316 being (Element of D674);
L1057: ( dom C316 ) c= D673 by L1053;
thus L1058: thesis by L1057 , RELAT_1:def 18;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
cluster ( OwnSymbolsOf R15 ) -defined for (Element of ( R22 -InterpretersOf R15 ));
existence
proof
set D675 = ( OwnSymbolsOf R15 );
set D676 = ( R22 -InterpretersOf R15 );
set D677 = the (Element of D676);
take D677;
thus L1060: thesis;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
cluster  ->  total for ( OwnSymbolsOf R15 ) -defined ( OwnSymbolsOf R15 ) -defined ( OwnSymbolsOf R15 ) -defined ( OwnSymbolsOf R15 ) -defined (Element of ( R22 -InterpretersOf R15 ));
coherence
proof
set D678 = ( OwnSymbolsOf R15 );
set D679 = ( R22 -InterpretersOf R15 );
let C317 being D678 -defined (Element of D679);
L1062: ( dom C317 ) = D678 by L1053;
thus L1063: thesis by L1062 , PARTFUN1:def 2;
end;
end;
definition
let R15 being Language;
let R22 being non  empty set;
let C318 being (Element of ( R22 -InterpretersOf R15 ));
let C319 being  literal (Element of R15);
let C320 being (Element of R22);
redefine func (C319 , C320) ReassignIn C318 -> (Element of ( R22 -InterpretersOf R15 ));

coherence
proof
set D680 = ( R22 -InterpretersOf R15 );
set D681 = ( (C319 , C320) ReassignIn C318 );
set D682 = ( OwnSymbolsOf R15 );
set D683 = ( { ( {} ) } --> C320 );
set D684 = ( C319 .--> D683 );
reconsider D685 = C319 as  own (Element of R15);
L1065: D685 in D682 by FOMODEL1:def 19;
L1066: ({ C319 } c= D682 & ( dom D684 ) = { C319 }) by L1065 , FUNCOP_1:13 , ZFMISC_1:31;
reconsider D686 = ( dom D684 ) as (Subset of D682) by L1066;
L1067: ( dom D681 ) = ( ( dom C318 ) \/ D686 ) by FUNCT_4:def 1
.= ( D682 \/ D686 ) by PARTFUN1:def 2
.= D682;
reconsider D687 = D681 as D682 -defined Function by L1067 , RELAT_1:def 18;
L1068: ( D687 | D682 ) = D687;
thus L1069: thesis by L1068 , L398;
end;
end;
L1071: (for R2 being Nat holds (for R15 being Language holds (for R19 being (string of R15) holds (for R22 being non  empty set holds (for B213 being (Element of ( R22 -InterpretersOf R15 )) holds (R19 is R2 -wff implies ( ( (B213 , R2) -TruthEval ) . R19 ) = ( ( (R15 , R22) -TruthEval R2 ) . [ B213 , R19 ] )))))))
proof
let R2 being Nat;
let R15 being Language;
let R19 being (string of R15);
let R22 being non  empty set;
set D688 = ( R22 -InterpretersOf R15 );
let C321 being (Element of D688);
set D689 = ( (C321 , R2) -TruthEval );
set D690 = ( (R15 , R22) -TruthEval R2 );
set D691 = ( R15 -formulasOfMaxDepth R2 );
L1072: D690 is (Element of ( Funcs ([: D688 , D691 :] , ( BOOLEAN )) )) by L614;
reconsider D692 = D690 as (Function of [: D688 , D691 :] , ( BOOLEAN )) by L1072;
L1073: ( dom D692 ) = [: D688 , D691 :] by FUNCT_2:def 1;
assume L1074: R19 is R2 -wff;
L1075: R19 in D691 by L1074 , L544;
L1076: ([ C321 , R19 ] in ( dom D690 ) & D689 = ( ( curry D690 ) . C321 )) by L1075 , L1073 , ZFMISC_1:87;
L1077: (R19 in ( dom D689 ) & ( D689 . R19 ) = ( D690 . (C321 , R19) )) by L1076 , FUNCT_5:20;
thus L1078: thesis by L1077;
end;
L1079: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (for R35 being  literal (Element of R15) holds (for R43 being  wff (string of R15) holds (for R45 being (Element of ( R22 -InterpretersOf R15 )) holds (for B214 being (PartFunc of [: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) holds ((( dom B214 ) = [: ( R22 -InterpretersOf R15 ) , ( R15 -formulasOfMaxDepth R2 ) :] & R43 is R2 -wff) implies (( B214 -ExFunctor (R45 , ( <* R35 *> ^ R43 )) ) = 1 iff (ex R30 being (Element of R22) st ( B214 . (( (R35 , R30) ReassignIn R45 ) , R43) ) = ( TRUE )))))))))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
let R35 being  literal (Element of R15);
let R43 being  wff (string of R15);
let R45 being (Element of ( R22 -InterpretersOf R15 ));
set D693 = ( R22 -InterpretersOf R15 );
set D694 = ( AllSymbolsOf R15 );
set D695 = ( TheNorSymbOf R15 );
set D696 = ( <* R35 *> ^ R43 );
set D697 = ( AllFormulasOf R15 );
set D698 = ( R15 -formulasOfMaxDepth R2 );
let C322 being (PartFunc of [: D693 , ( ( D694 * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
assume L1080: (( dom C322 ) = [: D693 , D698 :] & R43 is R2 -wff);
set D699 = ( C322 -ExFunctor (R45 , D696) );
reconsider D700 = D696 , D701 = R43 as (FinSequence of D694) by FOMODEL0:26;
L1081: ( ( <* R35 *> ^ D701 ) /^ 1 ) = D701 by FINSEQ_6:45;
thus L1082:now
assume L1083: D699 = 1;
consider C323 being (Element of R22), C324 being  literal (Element of R15) such that L1084: (( D696 . 1 ) = C324 & ( C322 . (( (C324 , C323) ReassignIn R45 ) , ( D696 /^ 1 )) ) = ( TRUE )) by L1083 , L308;
take D702 = C323;
thus L1085: ( C322 . (( (R35 , D702) ReassignIn R45 ) , R43) ) = ( TRUE ) by L1084 , L1081 , FINSEQ_1:41;
end;
given R30 being (Element of R22) such that
L1086: ( C322 . (( (R35 , R30) ReassignIn R45 ) , R43) ) = ( TRUE );

L1087: (ex R31 being (Element of R22) st (ex R36 being  literal (Element of R15) st (( D700 . 1 ) = R36 & ( C322 . (( (R36 , R31) ReassignIn R45 ) , ( D700 /^ 1 )) ) = ( TRUE )))) by L1081 , L1086 , FINSEQ_1:41;
thus L1088: thesis by L1087 , L308;
end;
L1089: (for R15 being Language holds (for R22 being non  empty set holds (for R35 being  literal (Element of R15) holds (for R42 being  wff (string of R15) holds (for R45 being (Element of ( R22 -InterpretersOf R15 )) holds (( R45 -TruthEval ( <* R35 *> ^ R42 ) ) = ( TRUE ) iff (ex R30 being (Element of R22) st ( ( (R35 , R30) ReassignIn R45 ) -TruthEval R42 ) = 1)))))))
proof
let R15 being Language;
let R22 being non  empty set;
let R35 being  literal (Element of R15);
let R42 being  wff (string of R15);
let R45 being (Element of ( R22 -InterpretersOf R15 ));
set D703 = ( TheNorSymbOf R15 );
set D704 = ( R22 -InterpretersOf R15 );
set D705 = ( AllSymbolsOf R15 );
set D706 = ( PFuncs ([: D704 , ( ( D705 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) );
set D707 = ( Depth R42 );
set D708 = ( D707 + 1 );
set D709 = ( LettersOf R15 );
reconsider D710 = R42 as D707 -wff (string of R15) by L708;
reconsider D711 = ( <* R35 *> ^ R42 ) as D708 -wff (string of R15);
deffunc H13((Element of D706)) = ( ExIterator $1 );
deffunc H14((Element of D706)) = ( NorIterator $1 );
set D712 = ( (R15 , R22) -TruthEval );
reconsider D713 = D707 , D714 = D708 as (Element of ( NAT )) by ORDINAL1:def 12;
set D715 = ( R15 -formulasOfMaxDepth D707 );
set D716 = ( R15 -formulasOfMaxDepth D708 );
reconsider D717 = D710 as (Element of D715) by L544;
reconsider D718 = R35 as (Element of D709) by FOMODEL1:def 14;
set D719 = ( (R15 , R22) -TruthEval D708 );
set D720 = ( (R15 , R22) -TruthEval D707 );
set D721 = ( D707 -NorFormulasOf R15 );
set D722 = ( D707 -ExFormulasOf R15 );
L1090: (D711 = ( <* D718 *> ^ D717 ) & (not contradiction));
L1091: (D711 in D722 & (not D711 in D721)) by L1090;
L1092: ([ R45 , D711 ] in [: D704 , D722 :] & (not [ R45 , D711 ] in [: D704 , D721 :])) by L1091 , ZFMISC_1:87;
L1093: ([ R45 , D711 ] in ( dom ( ExIterator D720 ) ) & (not [ R45 , D711 ] in ( dom ( NorIterator D720 ) ))) by L1092 , L629 , L651;
L1094: ( D712 . D714 ) = ( ( ( ExIterator ( D712 . D713 ) ) +* ( NorIterator ( D712 . D713 ) ) ) +* ( D712 . D713 ) ) by L368;
L1095: D720 is (Element of ( Funcs ([: D704 , D715 :] , ( BOOLEAN )) )) by L614;
reconsider D723 = D720 as (Function of [: D704 , D715 :] , ( BOOLEAN )) by L1095;
L1096: (not [ R45 , D711 ] in ( dom ( D712 . D713 ) ))
proof
L1097: (not D711 in D715) by L544;
L1098: ( dom ( D712 . D713 ) ) = ( dom D723 ) by L403
.= [: D704 , D715 :] by FUNCT_2:def 1;
thus L1099: thesis by L1098 , L1097 , ZFMISC_1:87;
end;
L1100: ( dom D723 ) = [: D704 , D715 :] by FUNCT_2:def 1;
L1101: ( R45 -TruthEval D711 ) = ( ( (R45 , D708) -TruthEval ) . D711 ) by L570
.= ( D719 . [ R45 , D711 ] ) by L1071
.= ( ( D712 . D714 ) . [ R45 , D711 ] ) by L403
.= ( ( ( ExIterator ( D712 . D713 ) ) +* ( NorIterator ( D712 . D713 ) ) ) . [ R45 , D711 ] ) by L1094 , L1096 , FUNCT_4:11
.= ( ( ( ExIterator ( D712 . D713 ) ) +* ( NorIterator D720 ) ) . [ R45 , D711 ] ) by L403
.= ( ( ExIterator ( D712 . D713 ) ) . [ R45 , D711 ] ) by L1093 , FUNCT_4:11
.= ( H13(D720) . (R45 , D711) ) by L403
.= ( D720 -ExFunctor (R45 , D711) ) by L1093 , L310;
L1102: ((ex R30 being (Element of R22) st ( D720 . (( (R35 , R30) ReassignIn R45 ) , D710) ) = ( TRUE )) implies (ex R30 being (Element of R22) st ( ( (R35 , R30) ReassignIn R45 ) -TruthEval D710 ) = ( TRUE )))
proof
given R30 being (Element of R22) such that
L1103: ( D720 . (( (R35 , R30) ReassignIn R45 ) , D710) ) = ( TRUE );

take R30;
set D724 = ( (R35 , R30) ReassignIn R45 );
L1104: ( ( (D724 , D707) -TruthEval ) . D710 ) = ( TRUE ) by L1103 , L1071;
thus L1105: thesis by L1104 , L570;
end;
L1106: ((ex R30 being (Element of R22) st ( ( (R35 , R30) ReassignIn R45 ) -TruthEval D710 ) = ( TRUE )) implies (ex R30 being (Element of R22) st ( D720 . (( (R35 , R30) ReassignIn R45 ) , D710) ) = ( TRUE )))
proof
given R30 being (Element of R22) such that
L1107: ( ( (R35 , R30) ReassignIn R45 ) -TruthEval D710 ) = ( TRUE );

take R30;
set D725 = ( (R35 , R30) ReassignIn R45 );
L1108: ( ( (D725 , D707) -TruthEval ) . D710 ) = ( TRUE ) by L1107 , L570;
thus L1109: thesis by L1108 , L1071;
end;
thus L1110: thesis by L1106 , L1101 , L1100 , L1079 , L1102;
end;
L1111: (for R2 being Nat holds (for R15 being Language holds (for R21 being (string of R15) holds (for R22 being non  empty set holds (for R43 being  wff (string of R15) holds (for R45 being (Element of ( R22 -InterpretersOf R15 )) holds (for B215 being (PartFunc of [: ( R22 -InterpretersOf R15 ) , ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) :] , ( BOOLEAN )) holds ((( dom B215 ) = [: ( R22 -InterpretersOf R15 ) , ( R15 -formulasOfMaxDepth R2 ) :] & R43 is R2 -wff) implies (( B215 -NorFunctor (R45 , ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R21 )) ) = 1 iff (( B215 . (R45 , R43) ) = ( 0 ) & ( B215 . (R45 , R21) ) = ( 0 )))))))))))
proof
let R2 being Nat;
let R15 being Language;
let R21 being (string of R15);
let R22 being non  empty set;
let R43 being  wff (string of R15);
let R45 being (Element of ( R22 -InterpretersOf R15 ));
set D726 = ( R22 -InterpretersOf R15 );
set D727 = ( AllSymbolsOf R15 );
set D728 = ( TheNorSymbOf R15 );
set D729 = R21;
set D730 = ( ( <* D728 *> ^ R43 ) ^ D729 );
set D731 = ( AllFormulasOf R15 );
set D732 = ( R15 -formulasOfMaxDepth R2 );
let C325 being (PartFunc of [: D726 , ( ( D727 * ) \ { ( {} ) } ) :] , ( BOOLEAN ));
assume L1112: (( dom C325 ) = [: D726 , D732 :] & R43 is R2 -wff);
L1113: R43 in D732 by L1112 , L544;
L1114: [ R45 , R43 ] in ( dom C325 ) by L1113 , L1112 , ZFMISC_1:87;
set D733 = ( C325 -NorFunctor (R45 , D730) );
set D734 = ( C325 . (R45 , R43) );
set D735 = ( C325 . (R45 , D729) );
thus L1115:now
assume L1116: D733 = 1;
consider R19 being (string of R15), R20 being (string of R15) such that L1117: ([ R45 , R19 ] in ( dom C325 ) & ( C325 . (R45 , R19) ) = ( FALSE ) & ( C325 . (R45 , R20) ) = ( FALSE ) & D730 = ( ( <* D728 *> ^ R19 ) ^ R20 )) by L1116 , L338;
L1118: (R19 in D732 & R43 in D732) by L1112 , L1117 , L544 , ZFMISC_1:87;
L1119: ( <* D728 *> ^ ( R19 ^ R20 ) ) = D730 by L1117 , FINSEQ_1:32
.= ( <* D728 *> ^ ( R43 ^ D729 ) ) by FINSEQ_1:32;
L1120: ( R19 ^ R20 ) = ( R43 ^ D729 ) by L1119 , FINSEQ_1:33;
thus L1121: (D734 = ( 0 ) & D735 = ( 0 )) by L1120 , L1117 , L1118 , FOMODEL0:def 20;
end;
assume L1122: (D734 = ( 0 ) & D735 = ( 0 ));
thus L1123: D733 = 1 by L1122 , L1114 , L338;
end;
L1124: (for R15 being Language holds (for R22 being non  empty set holds (for R43 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds (for R45 being (Element of ( R22 -InterpretersOf R15 )) holds (( R45 -TruthEval ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) = ( TRUE ) iff (( R45 -TruthEval R43 ) = ( FALSE ) & ( R45 -TruthEval R44 ) = ( FALSE ))))))))
proof
let R15 being Language;
let R22 being non  empty set;
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
let R45 being (Element of ( R22 -InterpretersOf R15 ));
set D736 = ( TheNorSymbOf R15 );
set D737 = ( R22 -InterpretersOf R15 );
set D738 = ( AllSymbolsOf R15 );
set D739 = ( BOOLEAN );
set D740 = ( PFuncs ([: D737 , ( ( D738 * ) \ { ( {} ) } ) :] , ( BOOLEAN )) );
set D741 = ( Depth R43 );
set D742 = ( Depth R44 );
deffunc H15((Element of D740)) = ( ExIterator $1 );
deffunc H16((Element of D740)) = ( NorIterator $1 );
set D743 = ( (R15 , R22) -TruthEval );
set D744 = ( max (D741 , D742) );
set D745 = ( D744 + 1 );
reconsider D746 = ( D744 - D741 ) , D747 = ( D744 - D742 ) as Nat;
L1125: (R43 is ( D741 + ( ( 0 ) * D746 ) ) -wff & R44 is ( D742 + ( ( 0 ) * D747 ) ) -wff) by L708;
L1126: (R43 is ( D741 + D746 ) -wff & R44 is ( D742 + D747 ) -wff) by L1125;
reconsider D748 = R43 , D749 = R44 as D744 -wff (string of R15) by L1126;
reconsider D750 = ( ( <* D736 *> ^ D748 ) ^ D749 ) as ( D744 + 1 ) -wff (string of R15);
reconsider D751 = D744 , D752 = D745 as (Element of ( NAT )) by ORDINAL1:def 12;
set D753 = ( R15 -formulasOfMaxDepth D744 );
set D754 = ( R15 -formulasOfMaxDepth D745 );
set D755 = ( (R15 , R22) -TruthEval D745 );
set D756 = ( (R15 , R22) -TruthEval D744 );
set D757 = ( D744 -NorFormulasOf R15 );
L1127: ( R45 -TruthEval R43 ) = ( ( (R45 , D744) -TruthEval ) . D748 ) by L570
.= ( D756 . (R45 , R43) ) by L1071;
L1128: ( R45 -TruthEval D749 ) = ( ( (R45 , D744) -TruthEval ) . D749 ) by L570
.= ( D756 . (R45 , R44) ) by L1071;
reconsider D758 = D748 , D759 = D749 as (Element of D753) by L544;
L1129: (D750 = ( ( <* D736 *> ^ D758 ) ^ D759 ) & (not contradiction));
L1130: D750 in D757 by L1129;
L1131: [ R45 , D750 ] in [: D737 , D757 :] by L1130 , ZFMISC_1:87;
L1132: [ R45 , D750 ] in ( dom ( NorIterator D756 ) ) by L1131 , L629;
L1133: ( D743 . D752 ) = ( ( ( ExIterator ( D743 . D751 ) ) +* ( NorIterator ( D743 . D751 ) ) ) +* ( D743 . D751 ) ) by L368;
L1134: D756 is (Element of ( Funcs ([: D737 , D753 :] , ( BOOLEAN )) )) by L614;
reconsider D760 = D756 as (Function of [: D737 , D753 :] , ( BOOLEAN )) by L1134;
L1135: (not [ R45 , D750 ] in ( dom ( D743 . D751 ) ))
proof
L1136: (not D750 in D753) by L544;
L1137: ( dom ( D743 . D751 ) ) = ( dom D760 ) by L403
.= [: D737 , D753 :] by FUNCT_2:def 1;
thus L1138: thesis by L1137 , L1136 , ZFMISC_1:87;
end;
L1139: ( dom D760 ) = [: D737 , D753 :] by FUNCT_2:def 1;
L1140: ( R45 -TruthEval D750 ) = ( ( (R45 , D745) -TruthEval ) . D750 ) by L570
.= ( D755 . [ R45 , D750 ] ) by L1071
.= ( ( D743 . D752 ) . [ R45 , D750 ] ) by L403
.= ( ( ( ExIterator ( D743 . D751 ) ) +* ( NorIterator ( D743 . D751 ) ) ) . [ R45 , D750 ] ) by L1133 , L1135 , FUNCT_4:11
.= ( ( ( ExIterator ( D743 . D751 ) ) +* ( NorIterator D756 ) ) . [ R45 , D750 ] ) by L403
.= ( H16(D756) . (R45 , D750) ) by L1132 , FUNCT_4:13
.= ( D756 -NorFunctor (R45 , D750) ) by L1132 , L340;
thus L1141: thesis by L1140 , L1139 , L1111 , L1128 , L1127;
end;
definition
let R15 being Language;
let R19 being (string of R15);
func xnot R19 -> (string of R15) equals 
( ( <* ( TheNorSymbOf R15 ) *> ^ R19 ) ^ R19 );
coherence;
end;
registration
let R15 being Language;
let R2 being Nat;
let C326 being R2 -wff (string of R15);
cluster ( xnot C326 ) -> ( R2 + 1 ) -wff for (string of R15);
coherence;
end;
registration
let R15 being Language;
let R42 being  wff (string of R15);
cluster ( xnot R42 ) ->  wff for (string of R15);
coherence;
end;
registration
let R15 being Language;
cluster ( TheEqSymbOf R15 ) -> non  own for (Element of R15);
coherence
proof
set D761 = ( TheEqSymbOf R15 );
set D762 = ( RelSymbolsOf R15 );
set D763 = ( OwnSymbolsOf R15 );
L1145: D761 in { D761 } by TARSKI:def 1;
L1146: D761 in ( D762 \ D763 ) by L1145 , FOMODEL1:1;
L1147: (not D761 in D763) by L1146 , XBOOLE_0:def 5;
thus L1148: thesis by L1147 , FOMODEL1:def 19;
end;
end;
definition
let R15 being Language;
let R9 being set;
attr R9 is R15 -mincover
means
:L1150: (for R42 being  wff (string of R15) holds (R42 in R9 iff (not ( xnot R42 ) in R9)));
end;
theorem
L1152: (for R15 being Language holds (for R35 being  literal (Element of R15) holds (for R43 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds (( Depth ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) = ( 1 + ( max (( Depth R43 ) , ( Depth R44 )) ) ) & ( Depth ( <* R35 *> ^ R43 ) ) = ( ( Depth R43 ) + 1 ))))))
proof
let R15 being Language;
let R35 being  literal (Element of R15);
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
set D764 = ( TheNorSymbOf R15 );
set D765 = ( Depth R43 );
set D766 = ( Depth R44 );
set D767 = ( <* R35 *> ^ R43 );
set D768 = ( ( <* D764 *> ^ R43 ) ^ R44 );
thus L1153: ( Depth D768 ) = ( 1 + ( max (D765 , D766) ) ) by L1034;
thus L1154: ( Depth D767 ) = ( D765 + 1 ) by L708;
end;
theorem
L1155: (for R2 being Nat holds (for R15 being Language holds (for R42 being  wff (string of R15) holds (( Depth R42 ) = ( R2 + 1 ) implies ((R42 is  exal iff R42 in ( R2 -ExFormulasOf R15 )) & (R42 is non  exal iff R42 in ( R2 -NorFormulasOf R15 ))))))) by L978 , L1004;
theorem
L1156: (for R15 being Language holds (for R22 being non  empty set holds (for R35 being  literal (Element of R15) holds (for R42 being  wff (string of R15) holds (for R43 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds (for R45 being (Element of ( R22 -InterpretersOf R15 )) holds ((( R45 -TruthEval ( <* R35 *> ^ R42 ) ) = ( TRUE ) iff (ex R30 being (Element of R22) st ( ( (R35 , R30) ReassignIn R45 ) -TruthEval R42 ) = 1)) & (( R45 -TruthEval ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) = ( TRUE ) iff (( R45 -TruthEval R43 ) = ( FALSE ) & ( R45 -TruthEval R44 ) = ( FALSE ))))))))))) by L1089 , L1124;
theorem
L1157: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (for R30 being (Element of R22) holds (for R46 being (R15 , R22)-interpreter-like Function holds ( ( ( (R46 , R30) -TermEval ) . ( R2 + 1 ) ) | ( ( R15 -termsOfMaxDepth ) . R2 ) ) = ( ( R46 -TermEval ) | ( ( R15 -termsOfMaxDepth ) . R2 ) ))))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
let R30 being (Element of R22);
let R46 being (R15 , R22)-interpreter-like Function;
reconsider D769 = R2 , D770 = ( R2 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D771 = ( R15 -termsOfMaxDepth );
set D772 = ( R46 -TermEval );
set D773 = ( (R46 , R30) -TermEval );
set D774 = ( AllTermsOf R15 );
reconsider D775 = ( D773 . D770 ) as (Function of D774 , R22);
reconsider D776 = ( D771 . D769 ) , D777 = ( D771 . D770 ) as (Subset of D774) by FOMODEL1:2;
set D778 = ( D775 | D776 );
set D779 = ( D772 | D776 );
L1158: (( dom D778 ) = D776 & ( dom D779 ) = D776) by PARTFUN1:def 2;
L1159:
now
let R12 being set;
assume L1160: R12 in ( dom D778 );
L1161: R12 in ( dom D775 ) by L1160 , RELAT_1:57;
reconsider D780 = R12 as (Element of D774) by L1161;
reconsider D781 = R12 as (Element of D776) by L1160;
L1162: (( ( D778 . D781 ) \+\ ( D775 . D781 ) ) = ( {} ) & ( ( D779 . D781 ) \+\ ( D772 . D781 ) ) = ( {} ));
L1163: (( D778 . R12 ) = ( D775 . D780 ) & ( D779 . R12 ) = ( D772 . R12 )) by L1162 , FOMODEL0:29;
L1164: ( D778 . R12 ) = ( R46 -TermEval D780 ) by L1163 , L1160 , L203
.= ( D779 . R12 ) by L1163 , L214;
thus L1165: ( D778 . R12 ) = ( D779 . R12 ) by L1164;
end;
thus L1166: thesis by L1159 , L1158 , FUNCT_1:2;
end;
theorem
L1167: (for R15 being Language holds (for R22 being non  empty set holds (for R33 being  termal (string of R15) holds (for R46 being (R15 , R22)-interpreter-like Function holds ( ( R46 -TermEval ) . R33 ) = ( ( R46 . ( ( R15 -firstChar ) . R33 ) ) . ( ( R46 -TermEval ) * ( SubTerms R33 ) ) )))))
proof
let R15 being Language;
let R22 being non  empty set;
let R33 being  termal (string of R15);
let R46 being (R15 , R22)-interpreter-like Function;
set D782 = the (Element of R22);
set D783 = ( R46 -TermEval );
set D784 = ( (R46 , D782) -TermEval );
set D785 = ( AllTermsOf R15 );
set D786 = ( R15 -firstChar );
set D787 = ( D786 . R33 );
set D788 = ( Depth R33 );
set D789 = ( R15 -termsOfMaxDepth );
set D790 = ( SubTerms R33 );
reconsider D791 = D788 , D792 = ( D788 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L1168: R33 is ( D788 + ( ( 0 ) * 1 ) ) -termal by FOMODEL1:def 40;
reconsider D793 = R33 as D788 -termal (string of R15) by FOMODEL1:def 40;
reconsider D794 = R33 as ( D791 + 1 ) -termal (string of R15) by L1168;
reconsider D795 = ( D789 . D791 ) , D796 = ( D789 . D792 ) as (Subset of D785) by FOMODEL1:2;
reconsider D797 = D793 as (Element of ( D789 . D791 )) by FOMODEL1:def 33;
reconsider D798 = R33 as (Element of D785) by FOMODEL1:def 32;
set D799 = ( R46 -TermEval D798 );
reconsider D800 = ( D784 . D792 ) as (Function of D785 , R22);
L1169: ( SubTerms D794 ) is D795 -valued;
L1170: (( dom ( D783 | D795 ) ) = D795 & ( dom ( D800 | D795 ) ) = D795 & ( rng D790 ) c= D795) by L1169 , PARTFUN1:def 2 , RELAT_1:def 19;
L1171: ( D783 . R33 ) = D799 by L214
.= ( ( D784 . D792 ) . D797 ) by L203
.= ( ( D784 . ( ( D788 + 1 ) + 1 ) ) . D793 ) by L179
.= ( ( R46 . D787 ) . ( ( D784 . D792 ) * D790 ) ) by L591
.= ( ( R46 . D787 ) . ( ( ( D784 . D792 ) | D795 ) * D790 ) ) by L1170 , RELAT_1:165
.= ( ( R46 . D787 ) . ( ( D783 | D795 ) * D790 ) ) by L1157
.= ( ( R46 . D787 ) . ( D783 * D790 ) ) by L1170 , RELAT_1:165;
thus L1172: thesis by L1171;
end;
definition
let R15 being Language;
let R42 being  wff (string of R15);
set D801 = ( R15 -firstChar );
set D802 = ( Depth R42 );
set D803 = ( D801 . R42 );
set D804 = ( LettersOf R15 );
set D805 = ( TheNorSymbOf R15 );
set D806 = ( AllFormulasOf R15 );
set D807 = ( AllSymbolsOf R15 );
defpred S19[ set ] means (ex R43 being  wff (string of R15) st (ex R27 being FinSequence st (R27 is D807 -valued & $1 = [ R43 , R27 ] & R42 = ( ( <* ( ( R15 -firstChar ) . R42 ) *> ^ R43 ) ^ R27 ))));
func SubWffsOf R42 means 
:L1173: (ex R43 being  wff (string of R15) st (ex R27 being FinSequence st (R27 is ( AllSymbolsOf R15 ) -valued & it = [ R43 , R27 ] & R42 = ( ( <* ( ( R15 -firstChar ) . R42 ) *> ^ R43 ) ^ R27 )))) if R42 is non  0wff otherwise it = [ R42 , ( {} ) ];
existence
proof
thus L1174: (R42 is non  0wff implies (ex B216 being set st S19[ B216 ]))
proof
assume L1175: R42 is non  0wff;
consider R2 being Nat such that L1176: D802 = ( R2 + 1 ) by L1175 , NAT_1:6;
per cases ;
suppose L1177: R42 is  exal;

L1178: R42 in ( R2 -ExFormulasOf R15 ) by L1177 , L1176 , L978;
consider C327 being (Element of D804), C328 being (Element of ( R15 -formulasOfMaxDepth R2 )) such that L1179: R42 = ( <* C327 *> ^ C328 ) by L1178;
L1180: C327 = ( R42 . 1 ) by L1179 , FINSEQ_1:41
.= D803 by FOMODEL0:6;
reconsider D808 = C327 as  literal (Element of R15);
reconsider D809 = C328 as R2 -wff (string of R15) by L544;
take D810 = [ D809 , ( {} ) ];
take D809;
take D811 = ( ( {} ) null D807 );
thus L1181: D811 is D807 -valued;
thus L1182: D810 = [ D809 , D811 ];
thus L1183: thesis by L1179 , L1180;
end;
suppose L1184: (not R42 is  exal);

L1185: R42 in ( R2 -NorFormulasOf R15 ) by L1184 , L1176 , L1004;
consider C329 , C330 being (Element of ( R15 -formulasOfMaxDepth R2 )) such that L1186: (R42 = ( ( <* D805 *> ^ C329 ) ^ C330 ) & (not contradiction)) by L1185;
L1187: D803 = ( R42 . 1 ) by FOMODEL0:6
.= ( ( <* D805 *> ^ ( C329 ^ C330 ) ) . 1 ) by L1186 , FINSEQ_1:32
.= D805 by FINSEQ_1:41;
reconsider D812 = C329 , D813 = C330 as R2 -wff (string of R15) by L544;
take D814 = [ D812 , C330 ];
take D812;
take D815 = D813;
thus L1188: D815 is D807 -valued;
thus L1189: D814 = [ D812 , D815 ];
thus L1190: R42 = ( ( <* D803 *> ^ D812 ) ^ D815 ) by L1186 , L1187;
end;
end;

assume L1192: R42 is  0wff;
take D816 = [ R42 , ( {} ) ];
thus L1193: thesis;
end;
uniqueness
proof
let C331 , C332 being set;
thus L1194: ((R42 is non  0wff & S19[ C331 ] & S19[ C332 ]) implies C331 = C332)
proof
assume L1195: R42 is non  0wff;
reconsider D817 = R42 as non  0wff (string of R15) by L1195;
assume L1196: (S19[ C331 ] & S19[ C332 ]);
consider R43 being  wff (string of R15), R28 being FinSequence such that L1197: (R28 is D807 -valued & C331 = [ R43 , R28 ] & D817 = ( ( <* D803 *> ^ R43 ) ^ R28 )) by L1196;
consider R44 being  wff (string of R15), R29 being FinSequence such that L1198: (R29 is D807 -valued & C332 = [ R44 , R29 ] & D817 = ( ( <* D803 *> ^ R44 ) ^ R29 )) by L1196;
reconsider D818 = R28 , D819 = R29 as D807 -valued FinSequence by L1197 , L1198;
L1199: ( <* D803 *> ^ ( R43 ^ R28 ) ) = D817 by L1197 , FINSEQ_1:32
.= ( <* D803 *> ^ ( R44 ^ R29 ) ) by L1198 , FINSEQ_1:32;
L1200: (( R43 ^ D818 ) = ( R44 ^ D819 ) & R43 in D806 & R44 in D806) by L1199 , L1022 , FINSEQ_1:33;
L1201: (R43 = R44 & D818 = D819) by L1200 , FOMODEL0:def 20;
thus L1202: thesis by L1201 , L1197 , L1198;
end;

thus L1203: ((R42 is  0wff & C331 = [ R42 , ( {} ) ] & C332 = [ R42 , ( {} ) ]) implies C331 = C332);
end;
consistency;
end;
definition
let R15 being Language;
let R42 being  wff (string of R15);
set D820 = ( SubWffsOf R42 );
set D821 = ( AllSymbolsOf R15 );
set D822 = ( R15 -firstChar );
func head R42 ->  wff (string of R15) equals 
( ( SubWffsOf R42 ) `1 );
coherence
proof
per cases ;
suppose L1205: R42 is non  0wff;

consider R43 being  wff (string of R15), R27 being FinSequence such that L1206: (R27 is D821 -valued & D820 = [ R43 , R27 ] & R42 = ( ( <* ( D822 . R42 ) *> ^ R43 ) ^ R27 )) by L1205 , L1173;
L1207: ( ( D820 `1 ) \+\ R43 ) = ( {} ) by L1206;
thus L1208: thesis by L1207 , FOMODEL0:29;
end;
suppose L1209: R42 is  0wff;

L1210: D820 = [ R42 , ( {} ) ] by L1209 , L1173;
L1211: ( ( D820 `1 ) \+\ R42 ) = ( {} ) by L1210;
thus L1212: thesis by L1211 , FOMODEL0:29;
end;
end;
func tail R42 -> (Element of ( ( AllSymbolsOf R15 ) * )) equals 
( ( SubWffsOf R42 ) `2 );
coherence
proof
per cases ;
suppose L1214: R42 is non  0wff;

consider R43 being  wff (string of R15), R27 being FinSequence such that L1215: (R27 is D821 -valued & D820 = [ R43 , R27 ] & R42 = ( ( <* ( D822 . R42 ) *> ^ R43 ) ^ R27 )) by L1214 , L1173;
L1216: ( ( D820 `2 ) \+\ R27 ) = ( {} ) by L1215;
L1217: (( D820 `2 ) = R27 & R27 is (FinSequence of D821)) by L1216 , L1215 , FOMODEL0:26 , FOMODEL0:29;
thus L1218: thesis by L1217 , FINSEQ_1:def 11;
end;
suppose L1219: R42 is  0wff;

L1220: D820 = [ R42 , ( {} ) ] by L1219 , L1173;
L1221: ( ( D820 `2 ) \+\ ( {} ) ) = ( ( {} ) null D821 ) by L1220;
reconsider D823 = ( D820 `2 ) as D821 -valued FinSequence by L1221;
L1222: D823 is (FinSequence of D821) by FOMODEL0:26;
thus L1223: thesis by L1222 , FINSEQ_1:def 11;
end;
end;
end;
registration
let R15 being Language;
let R2 being Nat;
cluster ( ( R15 -formulasOfMaxDepth R2 ) \ ( AllFormulasOf R15 ) ) ->  empty for set;
coherence
proof
set D824 = ( R15 -formulasOfMaxDepth R2 );
set D825 = ( AllFormulasOf R15 );
L1226:
now
let R12 being set;
assume L1227: R12 in D824;
reconsider D826 = R12 as R2 -wff (string of R15) by L1227 , L544;
L1228: D826 in D825;
thus L1229: R12 in D825 by L1228;
end;
L1230: D824 c= D825 by L1226 , TARSKI:def 3;
thus L1231: thesis by L1230;
end;
end;
registration
let R15 being Language;
cluster ( ( AtomicFormulasOf R15 ) \ ( AllFormulasOf R15 ) ) ->  empty for set;
coherence
proof
L1233: ( ( R15 -formulasOfMaxDepth ( 0 ) ) \ ( AllFormulasOf R15 ) ) = ( {} );
thus L1234: thesis by L1233 , L526;
end;
end;
theorem
L1236: (for R15 being Language holds (for R35 being  literal (Element of R15) holds (for R43 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds (( Depth ( <* R35 *> ^ R43 ) ) > ( Depth R43 ) & ( Depth ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) > ( Depth R43 ) & ( Depth ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) > ( Depth R44 )))))) by L987 , L1025;
theorem
L1237: (for R12 being set holds (for R15 being Language holds (for R29 being FinSequence holds (for R42 being  wff (string of R15) holds (for R44 being  wff (string of R15) holds ((not R42 is  0wff) implies (R42 = ( ( <* R12 *> ^ R44 ) ^ R29 ) iff (R12 = ( ( R15 -firstChar ) . R42 ) & R44 = ( head R42 ) & R29 = ( tail R42 )))))))))
proof
let R12 being set;
let R15 being Language;
let R29 being FinSequence;
let R42 being  wff (string of R15);
let R44 being  wff (string of R15);
set D827 = ( SubWffsOf R42 );
set D828 = ( R15 -firstChar );
set D829 = ( D828 . R42 );
set D830 = ( AllSymbolsOf R15 );
assume L1238: (not R42 is  0wff);
consider R43 being  wff (string of R15), R27 being FinSequence such that L1239: (R27 is D830 -valued & D827 = [ R43 , R27 ] & R42 = ( ( <* D829 *> ^ R43 ) ^ R27 )) by L1238 , L1173;
L1240: (( ( D827 `1 ) \+\ R43 ) = ( {} ) & ( ( D827 `2 ) \+\ R27 ) = ( {} )) by L1239;
L1241: (( D827 `1 ) = R43 & ( D827 `2 ) = R27) by L1240 , FOMODEL0:29;
thus L1242:now
assume L1243: R42 = ( ( <* R12 *> ^ R44 ) ^ R29 );
L1244: ( R42 . 1 ) = ( ( <* R12 *> ^ ( R44 ^ R29 ) ) . 1 ) by L1243 , FINSEQ_1:32
.= R12 by FINSEQ_1:41;
thus L1245: R12 = D829 by L1244 , FOMODEL0:6;
L1246: (( rng R29 ) c= ( rng R42 ) & ( rng R42 ) c= D830) by L1243 , FINSEQ_1:30 , RELAT_1:def 19;
L1247: ( rng R29 ) c= D830 by L1246 , XBOOLE_1:1;
L1248: (R29 is D830 -valued & [ R44 , R29 ] = [ R44 , R29 ] & R42 = ( ( <* D829 *> ^ R44 ) ^ R29 )) by L1247 , L1244 , L1243 , FOMODEL0:6 , RELAT_1:def 19;
L1249: D827 = [ R44 , R29 ] by L1248 , L1238 , L1173;
thus L1250: (R44 = ( head R42 ) & R29 = ( tail R42 )) by L1249 , MCART_1:7;
end;
assume L1251: (R12 = D829 & R44 = ( head R42 ) & R29 = ( tail R42 ));
thus L1252: thesis by L1251 , L1241 , L1239;
end;
registration
let R15 being Language;
let R38 being non  zero Nat;
cluster non  exal for non  0wff R38 -wff non  0wff R38 -wff non  0wff R38 -wff non  0wff R38 -wff (string of R15);
existence
proof
set D831 = the ( 0 ) -wff (string of R15);
set D832 = ( TheNorSymbOf R15 );
set D833 = ( ( <* D832 *> ^ D831 ) ^ D831 );
consider R2 being Nat such that L1253: R38 = ( R2 + 1 ) by NAT_1:6;
L1254: D833 is non  0wff ( 1 + ( ( 0 ) * R2 ) ) -wff non  0wff ( 1 + ( ( 0 ) * R2 ) ) -wff non  0wff ( 1 + ( ( 0 ) * R2 ) ) -wff non  0wff ( 1 + ( ( 0 ) * R2 ) ) -wff (string of R15);
reconsider D834 = D833 as non  0wff R38 -wff (string of R15) by L1254 , L1253;
take D834;
thus L1255: thesis;
end;
end;
registration
let R15 being Language;
let C333 being  exal  wff (string of R15);
cluster ( tail C333 ) ->  empty for set;
coherence
proof
set D835 = ( Depth C333 );
set D836 = ( LettersOf R15 );
set D837 = ( head C333 );
set D838 = ( tail C333 );
set D839 = ( R15 -firstChar );
set D840 = ( AllFormulasOf R15 );
set D841 = ( AllSymbolsOf R15 );
set D842 = ( D839 . C333 );
consider R2 being Nat such that L1257: D835 = ( R2 + 1 ) by NAT_1:6;
set D843 = ( R15 -formulasOfMaxDepth R2 );
L1258: C333 in ( R2 -ExFormulasOf R15 ) by L1257 , L978;
consider C334 being (Element of D836), C335 being (Element of D843) such that L1259: (C333 = ( <* C334 *> ^ C335 ) & (not contradiction)) by L1258;
reconsider D844 = C335 as R2 -wff (string of R15) by L544;
L1260: C333 = ( ( <* C334 *> ^ D844 ) ^ ( {} ) ) by L1259;
thus L1261: thesis by L1260 , L1237;
end;
end;
L1263: (for R2 being Nat holds (for R15 being Language holds (for R42 being  wff (string of R15) holds ((( Depth R42 ) = ( R2 + 1 ) & (not R42 is  exal)) implies (ex B217 being R2 -wff (string of R15) st ( tail R42 ) = B217)))))
proof
let R2 being Nat;
let R15 being Language;
let R42 being  wff (string of R15);
set D845 = ( Depth R42 );
set D846 = ( R15 -formulasOfMaxDepth R2 );
set D847 = ( TheNorSymbOf R15 );
assume L1264: (D845 = ( R2 + 1 ) & (not R42 is  exal));
L1265: R42 in ( R2 -NorFormulasOf R15 ) by L1264 , L1004;
consider C336 , C337 being (Element of D846) such that L1266: (R42 = ( ( <* D847 *> ^ C336 ) ^ C337 ) & (not contradiction)) by L1265;
reconsider D848 = C336 , D849 = C337 as R2 -wff (string of R15) by L544;
set D850 = ( Depth D848 );
set D851 = ( Depth D849 );
take D849;
L1267: R42 = ( ( <* D847 *> ^ D848 ) ^ D849 ) by L1266;
thus L1268: D849 = ( tail R42 ) by L1267 , L1237;
thus L1269: thesis;
end;
definition
let R15 being Language;
let C338 being non  exal non  0wff  wff (string of R15);
redefine func tail C338 ->  wff (string of R15);

coherence
proof
consider R2 being Nat such that L1270: ( Depth C338 ) = ( R2 + 1 ) by NAT_1:6;
consider C339 being R2 -wff (string of R15) such that L1271: ( tail C338 ) = C339 by L1270 , L1263;
thus L1272: thesis by L1271;
end;
end;
registration
let R15 being Language;
let C340 being non  exal non  0wff  wff (string of R15);
cluster ( tail C340 ) ->  wff for (string of R15);
coherence;
end;
registration
let R15 being Language;
let R40 being  0wff (string of R15);
identify head R40 with R40 null;
compatibility
proof
L1275: (R40 = ( [ R40 , ( {} ) ] `1 ) & ( SubWffsOf R40 ) = [ R40 , ( {} ) ]) by L1173;
thus L1276: thesis by L1275;
end;
end;
registration
let R15 being Language;
let C341 being non  0wff non  exal  wff (string of R15);
cluster ( ( ( R15 -firstChar ) . C341 ) \+\ ( TheNorSymbOf R15 ) ) ->  empty for set;
coherence
proof
set D852 = ( R15 -firstChar );
set D853 = ( TheNorSymbOf R15 );
set D854 = ( D852 . C341 );
consider R2 being Nat such that L1278: ( Depth C341 ) = ( R2 + 1 ) by NAT_1:6;
L1279: C341 in ( R2 -NorFormulasOf R15 ) by L1278 , L1004;
consider C342 , C343 being (Element of ( R15 -formulasOfMaxDepth R2 )) such that L1280: C341 = ( ( <* D853 *> ^ C342 ) ^ C343 ) by L1279;
L1281: ( D852 . C341 ) = ( C341 . 1 ) by FOMODEL0:6
.= ( ( <* D853 *> ^ ( C342 ^ C343 ) ) . 1 ) by L1280 , FINSEQ_1:32
.= D853 by FINSEQ_1:41;
thus L1282: thesis by L1281;
end;
end;
L1284: (for R2 being Nat holds (for R15 being Language holds (for R42 being  wff (string of R15) holds (((not R42 is  0wff) & (not R42 is  exal) & R42 is ( R2 + 1 ) -wff) implies (( head R42 ) is R2 -wff R2 -wff R2 -wff R2 -wff (string of R15) & ( tail R42 ) is R2 -wff R2 -wff R2 -wff R2 -wff (string of R15))))))
proof
let R2 being Nat;
let R15 being Language;
let R42 being  wff (string of R15);
assume L1285: ((not R42 is  0wff) & (not R42 is  exal) & R42 is ( R2 + 1 ) -wff);
reconsider D855 = R42 as non  0wff non  exal ( R2 + 1 ) -wff (string of R15) by L1285;
set D856 = ( TheNorSymbOf R15 );
set D857 = ( R15 -firstChar );
set D858 = ( D857 . D855 );
set D859 = ( Depth ( head D855 ) );
set D860 = ( Depth ( tail D855 ) );
set D861 = ( max (D859 , D860) );
set D862 = ( Depth D855 );
reconsider D863 = ( head D855 ) as D859 -wff (string of R15) by L708;
reconsider D864 = ( tail D855 ) as D860 -wff (string of R15) by L708;
L1286: D862 <= ( R2 + 1 ) by L708;
L1287: ( ( D857 . D855 ) \+\ D856 ) = ( {} );
L1288: D858 = D856 by L1287 , FOMODEL0:29;
L1289: D855 = ( ( <* D856 *> ^ D863 ) ^ D864 ) by L1288 , L1237;
L1290: ( D861 + 1 ) <= ( R2 + 1 ) by L1289 , L1286 , L1152;
L1291: ( ( D861 + 1 ) - 1 ) <= ( ( R2 + 1 ) - 1 ) by L1290 , XREAL_1:6;
L1292: (( D861 + ( - D859 ) ) <= ( R2 + ( - D859 ) ) & ( D861 + ( - D860 ) ) <= ( R2 + ( - D860 ) )) by L1291 , XREAL_1:6;
L1293: (( ( max (D859 , D860) ) - D859 ) <= ( R2 - D859 ) & ( ( max (D859 , D860) ) - D860 ) <= ( R2 - D860 )) by L1292;
L1294: (( 0 ) <= ( R2 - D859 ) & ( 0 ) <= ( R2 - D860 )) by L1293;
reconsider D865 = ( R2 - D859 ) , D866 = ( R2 - D860 ) as Nat by L1294;
L1295: (D863 is ( D859 + ( ( 0 ) * D865 ) ) -wff & D864 is ( D860 + ( ( 0 ) * D866 ) ) -wff);
L1296: (D863 is ( D859 + D865 ) -wff & D864 is ( D860 + D866 ) -wff) by L1295;
thus L1297: thesis by L1296;
end;
registration
let R2 being Nat;
let R15 being Language;
let C344 being ( R2 + 1 ) -wff (string of R15);
cluster ( head C344 ) -> R2 -wff for (string of R15);
coherence
proof
set D867 = ( Depth C344 );
set D868 = ( R15 -firstChar );
set D869 = ( D868 . C344 );
set D870 = ( TheNorSymbOf R15 );
set D871 = ( Depth ( head C344 ) );
reconsider D872 = ( head C344 ) as D871 -wff (string of R15) by L708;
L1298: D867 <= ( R2 + 1 ) by L708;
per cases ;
suppose L1299: C344 is  0wff;

reconsider D873 = C344 as ( 0 ) -wff (string of R15) by L1299;
L1300: D873 is ( ( 0 ) + ( ( 0 ) * R2 ) ) -wff;
L1301: ( D873 null D873 ) is ( ( 0 ) + R2 ) -wff ( ( 0 ) + R2 ) -wff ( ( 0 ) + R2 ) -wff ( ( 0 ) + R2 ) -wff (string of R15) by L1300;
L1302: ( head D873 ) is R2 -wff by L1301;
thus L1303: thesis by L1302;
end;
suppose L1304: ((not C344 is  0wff) & (not C344 is  exal));

reconsider D874 = C344 as non  0wff non  exal ( R2 + 1 ) -wff (string of R15) by L1304;
L1305: ( head D874 ) is R2 -wff R2 -wff R2 -wff R2 -wff (string of R15) by L1284;
thus L1306: thesis by L1305;
end;
suppose L1307: ((not C344 is  0wff) & C344 is  exal);

reconsider D875 = C344 as non  0wff  exal ( R2 + 1 ) -wff (string of R15) by L1307;
set D876 = ( tail D875 );
L1308: D875 = ( ( <* D869 *> ^ D872 ) ^ D876 ) by L1237
.= ( <* D869 *> ^ D872 );
L1309: ( D871 + 1 ) <= ( R2 + 1 ) by L1308 , L1298 , L1152;
L1310: D871 <= R2 by L1309 , XREAL_1:6;
L1311: ( D871 + ( - D871 ) ) <= ( R2 + ( - D871 ) ) by L1310 , XREAL_1:6;
reconsider D877 = ( R2 - D871 ) as Nat by L1311;
L1312: D872 is ( D871 + ( ( 0 ) * D877 ) ) -wff;
L1313: D872 is ( D871 + D877 ) -wff by L1312;
thus L1314: thesis by L1313;
end;
end;
end;
registration
let R2 being Nat;
let R15 being Language;
let C345 being ( R2 + 1 ) -wff non  exal non  0wff (string of R15);
cluster ( tail C345 ) -> R2 -wff for (string of R15);
coherence by L1284;
end;
theorem
L1318: (for R2 being Nat holds (for R15 being Language holds (for R22 being non  empty set holds (for B218 being (Element of ( R22 -InterpretersOf R15 )) holds ( (B218 , R2) -TruthEval ) in ( Funcs (( R15 -formulasOfMaxDepth R2 ) , ( BOOLEAN )) )))))
proof
let R2 being Nat;
let R15 being Language;
let R22 being non  empty set;
set D878 = ( R15 -formulasOfMaxDepth R2 );
set D879 = ( R22 -InterpretersOf R15 );
let C346 being (Element of D879);
reconsider D880 = ( curry ( (R15 , R22) -TruthEval R2 ) ) as (Function of D879 , ( Funcs (D878 , ( BOOLEAN )) )) by L606;
L1319: ( D880 . C346 ) in ( Funcs (D878 , ( BOOLEAN )) );
thus L1320: thesis by L1319;
end;
L1321: (for R15 being Language holds (for R22 being non  empty set holds (for R40 being  0wff (string of R15) holds (for B219 being (Element of ( R22 -InterpretersOf R15 )) holds ( B219 -TruthEval R40 ) = ( B219 -AtomicEval R40 )))))
proof
let R15 being Language;
let R22 being non  empty set;
let R40 being  0wff (string of R15);
set D881 = ( R22 -InterpretersOf R15 );
let C347 being (Element of D881);
set D882 = ( C347 -TruthEval R40 );
set D883 = ( C347 -AtomicEval R40 );
set D884 = ( (R15 , R22) -TruthEval ( 0 ) );
set D885 = ( R15 -formulasOfMaxDepth ( 0 ) );
set D886 = ( AtomicFormulasOf R15 );
set D887 = ( AllSymbolsOf R15 );
reconsider D888 = R40 as (Element of D885) by L544;
reconsider D889 = D888 as (Element of D886) by L526;
reconsider D890 = ( 0 ) as (Element of ( NAT ));
L1322: ( (C347 , ( 0 )) -TruthEval ) is (Element of ( Funcs (D885 , ( BOOLEAN )) )) by L1318;
reconsider D891 = ( (C347 , ( 0 )) -TruthEval ) as (Function of D885 , ( BOOLEAN )) by L1322;
set D892 = ( curry D884 );
reconsider D893 = ( curry D884 ) as (Function of D881 , ( PFuncs (( ( D887 * ) \ { ( {} ) } ) , ( BOOLEAN )) )) by L479;
L1323: (( dom D893 ) = D881 & ( dom D891 ) = D885) by FUNCT_2:def 1;
L1324: (C347 in ( dom D893 ) & D891 = ( D893 . C347 ) & D888 in ( dom D891 )) by L1323;
L1325: (( D891 . R40 ) = ( D884 . (C347 , R40) ) & [ C347 , R40 ] in ( dom D884 )) by L1324 , FUNCT_5:31;
L1326: D882 = ( D891 . R40 ) by L570
.= ( ( ( (R15 , R22) -TruthEval ) . D890 ) . [ C347 , R40 ] ) by L1325 , L403
.= ( ( R15 -TruthEval R22 ) . (C347 , D889) ) by L368
.= D883 by L299;
thus L1327: thesis by L1326;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C348 being (Element of ( R22 -InterpretersOf R15 ));
let R40 being  0wff (string of R15);
identify C348 -TruthEval R40 with C348 -AtomicEval R40;
compatibility by L1321;
identify C348 -AtomicEval R40 with C348 -TruthEval R40;
compatibility;
end;
registration
let R15 being Language;
cluster non  literal for  ofAtomicFormula  ofAtomicFormula  ofAtomicFormula  ofAtomicFormula (Element of R15);
existence
proof
take ( TheEqSymbOf R15 );
thus L1329: thesis;
end;
end;
L1331: (for R9 being set holds (for R15 being Language holds (for R22 being non  empty set holds (for B220 , B221 being (R15 , R22)-interpreter-like Function holds (( B220 | R9 ) = ( B221 | R9 ) implies ( ( B220 -TermEval ) | ( R9 * ) ) = ( ( B221 -TermEval ) | ( R9 * ) ))))))
proof
let R9 being set;
let R15 being Language;
let R22 being non  empty set;
set D894 = ( R15 -termsOfMaxDepth );
set D895 = ( OwnSymbolsOf R15 );
set D896 = ( AllTermsOf R15 );
set D897 = ( AllSymbolsOf R15 );
set D898 = ( LettersOf R15 );
set D899 = ( R15 -firstChar );
set D900 = ( R15 -multiCat );
let C349 , C350 being (R15 , R22)-interpreter-like Function;
set D901 = ( C349 -TermEval );
set D902 = ( C350 -TermEval );
set D903 = ( C349 | R9 );
set D904 = ( C350 | R9 );
assume L1332: D903 = D904;
L1333: (( dom D901 ) = D896 & ( dom D902 ) = D896 & D903 = D904) by L1332 , FUNCT_2:def 1;
defpred S20[ Nat ] means ( ( C349 -TermEval ) | ( ( R9 * ) /\ ( D894 . $1 ) ) ) = ( ( C350 -TermEval ) | ( ( R9 * ) /\ ( D894 . $1 ) ) );
L1334: S20[ ( 0 ) ]
proof
set D905 = ( ( R9 * ) /\ ( D894 . ( 0 ) ) );
L1335: (( D894 . ( 0 ) ) c= D896 & D905 c= ( D894 . ( 0 ) )) by FOMODEL1:2;
reconsider D906 = D905 as (Subset of D896) by L1335 , XBOOLE_1:1;
L1336: (( dom ( D901 | D906 ) ) = D905 & ( dom ( D902 | D906 ) ) = D905) by PARTFUN1:def 2;
L1337:
now
let R12 being set;
assume L1338: R12 in ( dom ( D901 | D905 ) );
reconsider D907 = D906 as non  empty (Subset of D896) by L1338;
reconsider D908 = R12 as (Element of D907) by L1338;
reconsider D909 = R12 as ( 0 ) -termal (string of R15) by L1338 , L1336 , FOMODEL1:def 33;
set D910 = ( D899 . D909 );
set D911 = ( SubTerms D909 );
reconsider D912 = R9 as non  empty set by L1338;
reconsider D913 = R12 as non  empty (Element of ( D912 * )) by L1338 , L1336;
L1339: ( { ( D913 . 1 ) } \ D912 ) = ( {} );
L1340: ( D913 . 1 ) in D912 by L1339 , ZFMISC_1:60;
reconsider D914 = D910 as (Element of D912) by L1340 , FOMODEL0:6;
L1341: (( ( D903 . D914 ) \+\ ( C349 . D914 ) ) = ( {} ) & ( ( D904 . D914 ) \+\ ( C350 . D914 ) ) = ( {} ) & ( ( ( D901 | D907 ) . D908 ) \+\ ( D901 . D908 ) ) = ( {} ) & ( ( ( D902 | D907 ) . D908 ) \+\ ( D902 . D908 ) ) = ( {} ));
L1342: (( D903 . D910 ) = ( C349 . D910 ) & ( D904 . D910 ) = ( C350 . D910 ) & ( ( D901 | D905 ) . R12 ) = ( D901 . R12 ) & ( ( D902 | D905 ) . R12 ) = ( D902 . R12 )) by L1341 , FOMODEL0:29;
thus L1343: ( ( D901 | D905 ) . R12 ) = ( ( C349 . D910 ) . ( D901 * D911 ) ) by L1342 , L1167
.= ( ( C350 . D910 ) . ( D902 * D911 ) ) by L1332 , L1342
.= ( ( D902 | D905 ) . R12 ) by L1342 , L1167;
end;
thus L1344: thesis by L1337 , L1336 , FUNCT_1:2;
end;
L1345: (for R3 being Nat holds (S20[ R3 ] implies S20[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
set D915 = ( ( R9 * ) /\ ( D894 . R3 ) );
set D916 = ( ( R9 * ) /\ ( D894 . ( R3 + 1 ) ) );
reconsider D917 = R3 , D918 = ( R3 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L1346: S20[ R3 ];
L1347: (D916 c= ( D894 . D918 ) & D915 c= ( D894 . D917 ) & ( D894 . D917 ) c= D896 & ( D894 . D918 ) c= D896) by FOMODEL1:2;
reconsider D919 = D916 , D920 = D915 as (Subset of D896) by L1347 , XBOOLE_1:1;
L1348: (( dom ( D901 | D920 ) ) = D915 & ( dom ( D902 | D920 ) ) = D915 & ( dom ( D901 | D919 ) ) = D916 & ( dom ( D902 | D919 ) ) = D916) by PARTFUN1:def 2;
L1349:
now
let R12 being set;
assume L1350: R12 in ( dom ( D901 | D916 ) );
reconsider D921 = R12 as ( D917 + 1 ) -termal (string of R15) by L1350 , L1348 , FOMODEL1:def 33;
reconsider D922 = R9 as non  empty set by L1350;
reconsider D923 = D919 as non  empty (Subset of D896) by L1350;
reconsider D924 = R12 as non  empty (Element of ( D922 * )) by L1350 , L1348;
reconsider D925 = R12 as (Element of D923) by L1350;
set D926 = ( D899 . D921 );
set D927 = ( abs ( ar D926 ) );
L1351: ( { ( D924 . 1 ) } \ D922 ) = ( {} );
L1352: ( D924 . 1 ) in D922 by L1351 , ZFMISC_1:60;
reconsider D928 = D926 as (Element of D922) by L1352 , FOMODEL0:6;
reconsider D929 = ( rng D921 ) as (Subset of R9) by L1350 , L1348 , RELAT_1:def 19;
L1353: ( D929 * ) c= ( R9 * );
reconsider D930 = ( ( rng D921 ) * ) as non  empty (Subset of ( R9 * )) by L1353;
reconsider D931 = ( SubTerms D921 ) as D930 -valued D927 -element FinSequence;
L1354: (( ( D903 . D928 ) \+\ ( C349 . D928 ) ) = ( {} ) & ( ( D904 . D928 ) \+\ ( C350 . D928 ) ) = ( {} ));
L1355: (( D903 . D928 ) = ( C349 . D928 ) & ( D904 . D928 ) = ( C350 . D928 )) by L1354 , FOMODEL0:29;
L1356: (( ( ( D901 | D923 ) . D925 ) \+\ ( D901 . D925 ) ) = ( {} ) & ( ( ( D902 | D923 ) . D925 ) \+\ ( D902 . D925 ) ) = ( {} ));
L1357: (( ( D901 | D916 ) . R12 ) = ( D901 . R12 ) & ( ( D902 | D916 ) . R12 ) = ( D902 . R12 )) by L1356 , FOMODEL0:29;
L1358: (( rng D931 ) c= ( D894 . D917 ) & ( rng D931 ) c= ( R9 * )) by RELAT_1:def 19;
L1359: (( ( D901 | D915 ) * D931 ) = ( D901 * D931 ) & ( ( D902 | D915 ) * D931 ) = ( D902 * D931 )) by L1358 , L1348 , RELAT_1:165 , XBOOLE_1:19;
L1360: ( ( C349 . D926 ) . ( ( D901 | D915 ) * D931 ) ) = ( D901 . D921 ) by L1359 , L1167;
thus L1361: ( ( D901 | D916 ) . R12 ) = ( ( D902 | D916 ) . R12 ) by L1360 , L1357 , L1346 , L1332 , L1355 , L1359 , L1167;
end;
thus L1362: thesis by L1349 , L1348 , FUNCT_1:2;
end;
L1363: (for R2 being Nat holds S20[ R2 ]) from NAT_1:sch 2(L1334 , L1345);
set D932 = ( D901 | ( R9 * ) );
set D933 = ( D902 | ( R9 * ) );
L1364: (( dom D932 ) = ( ( R9 * ) /\ D896 ) & ( dom D933 ) = ( ( R9 * ) /\ D896 )) by L1333 , RELAT_1:61;
L1365:
now
let R12 being set;
assume L1366: R12 in ( dom D932 );
reconsider D934 = ( ( R9 * ) /\ D896 ) as non  empty (Subset of D896) by L1366 , L1333 , RELAT_1:61;
reconsider D935 = R12 as  termal (string of R15) by L1366 , L1364;
set D936 = ( Depth D935 );
reconsider D937 = D935 as D936 -termal (string of R15) by FOMODEL1:def 40;
L1367: (D937 in ( R9 * ) & D937 in ( D894 . D936 )) by L1366 , FOMODEL1:def 33;
reconsider D938 = ( ( R9 * ) /\ ( D894 . D936 ) ) as non  empty set by L1367 , XBOOLE_0:def 4;
reconsider D939 = D937 as (Element of D938) by L1367 , XBOOLE_0:def 4;
reconsider D940 = R12 as (Element of ( R9 * )) by L1366;
set D941 = ( D901 | D938 );
set D942 = ( D902 | D938 );
L1368: (( ( D932 . D940 ) \+\ ( D901 . D940 ) ) = ( {} ) & ( ( D933 . D940 ) \+\ ( D902 . D940 ) ) = ( {} ) & ( ( D941 . D939 ) \+\ ( D901 . D939 ) ) = ( {} ) & ( ( D942 . D939 ) \+\ ( D902 . D939 ) ) = ( {} ));
L1369: (( D932 . R12 ) = ( D901 . R12 ) & ( D933 . R12 ) = ( D902 . R12 ) & ( D941 . R12 ) = ( D901 . R12 ) & ( D942 . R12 ) = ( D902 . R12 )) by L1368 , FOMODEL0:29;
thus L1370: ( D932 . R12 ) = ( D933 . R12 ) by L1369 , L1363;
end;
thus L1371: thesis by L1365 , L1364 , FUNCT_1:2;
end;
theorem
L1372: (for R15 being Language holds (for R22 being non  empty set holds (for R27 being FinSequence holds (for R30 being (Element of R22) holds (for R37 being  literal (Element of R15) holds (for R46 being (R15 , R22)-interpreter-like Function holds ((not R37 in ( rng R27 )) implies ( ( ( (R37 , R30) ReassignIn R46 ) -TermEval ) . R27 ) = ( ( R46 -TermEval ) . R27 ))))))))
proof
let R15 being Language;
let R22 being non  empty set;
let R27 being FinSequence;
let R30 being (Element of R22);
let R37 being  literal (Element of R15);
let R46 being (R15 , R22)-interpreter-like Function;
set D943 = R27;
set D944 = ( R22 -InterpretersOf R15 );
set D945 = ( (R37 , R30) ReassignIn R46 );
set D946 = ( R37 .--> ( ( {} ) .--> R30 ) );
L1373: ( D943 null ( {} ) ) is ( ( {} ) \/ ( rng D943 ) ) -valued ( ( {} ) \/ ( rng D943 ) ) -valued ( ( {} ) \/ ( rng D943 ) ) -valued ( ( {} ) \/ ( rng D943 ) ) -valued FinSequence;
L1374: D943 is (FinSequence of ( rng D943 )) by L1373 , FOMODEL0:26;
reconsider D947 = D943 as (Element of ( ( rng D943 ) * )) by L1374 , FINSEQ_1:def 11;
L1375: (( ( ( ( D945 -TermEval ) | ( ( rng D943 ) * ) ) . D947 ) \+\ ( ( D945 -TermEval ) . D947 ) ) = ( {} ) & ( ( ( ( R46 -TermEval ) | ( ( rng D943 ) * ) ) . D947 ) \+\ ( ( R46 -TermEval ) . D947 ) ) = ( {} ));
L1376: (( ( ( D945 -TermEval ) | ( ( rng D943 ) * ) ) . D943 ) = ( ( D945 -TermEval ) . D943 ) & ( ( ( R46 -TermEval ) | ( ( rng D943 ) * ) ) . D943 ) = ( ( R46 -TermEval ) . D943 )) by L1375 , FOMODEL0:29;
assume L1377: (not R37 in ( rng D943 ));
L1378: { R37 } misses ( rng D943 ) by L1377 , ZFMISC_1:50;
L1379: ( dom D946 ) misses ( rng D943 ) by L1378 , FUNCOP_1:13;
L1380: ( D945 | ( rng D943 ) ) = ( R46 | ( rng D943 ) ) by L1379 , FUNCT_4:72;
thus L1381: thesis by L1380 , L1376 , L1331;
end;
definition
let R9 being set;
let R15 being Language;
let R18 being (Element of R15);
attr R18 is R9 -occurring
means
:L1382: R18 in ( SymbolsOf ( ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } ) /\ R9 ) );
end;
definition
let R15 being Language;
let R18 being (Element of R15);
let R9 being set;
attr R9 is R18 -containing
means
R18 in ( SymbolsOf ( ( ( AllSymbolsOf R15 ) * ) \ ( { ( {} ) } /\ R9 ) ) );
end;
notation
let R9 being set;
let R15 being Language;
let R18 being (Element of R15);
antonym R18 is R9 -absent for R18 is R9 -occurring;
end;
notation
let R15 being Language;
let R18 being (Element of R15);
let R9 being set;
antonym R9 is R18 -free for R9 is R18 -containing;
end;
registration
let C351 being  finite set;
let R15 being Language;
cluster C351 -absent for  literal  literal  literal  literal (Element of R15);
existence
proof
set D948 = ( LettersOf R15 );
set D949 = ( AllSymbolsOf R15 );
reconsider D950 = ( ( ( D949 * ) \ { ( {} ) } ) /\ C351 ) as  FinSequence-membered (Subset of C351);
reconsider D951 = ( SymbolsOf D950 ) as  finite set;
reconsider D952 = ( D948 \ D951 ) as  infinite (Subset of D948);
set D953 = the (Element of D952);
reconsider D954 = D953 as  literal (Element of R15) by TARSKI:def 3;
take D954;
L1387: (not D954 in D951) by XBOOLE_0:def 5;
thus L1388: thesis by L1387 , L1382;
end;
end;
L1390: (for R15 being Language holds (for R19 being (string of R15) holds (R19 is  termal implies ( ( rng R19 ) /\ ( LettersOf R15 ) ) <> ( {} ))))
proof
let R15 being Language;
let R19 being (string of R15);
set D955 = ( LettersOf R15 );
set D956 = ( R15 -firstChar );
set D957 = ( AllTermsOf R15 );
set D958 = ( R15 -multiCat );
set D959 = ( AllSymbolsOf R15 );
set D960 = ( D959 -multiCat );
set D961 = ( R15 -termsOfMaxDepth );
reconsider D962 = D957 as (Subset of ( D959 * )) by XBOOLE_1:1;
defpred S21[ Nat ] means (for R19 being (string of R15) holds (R19 is $1 -termal implies ( ( rng R19 ) /\ D955 ) <> ( {} )));
L1391: S21[ ( 0 ) ]
proof
let R19 being (string of R15);
assume L1392: R19 is ( 0 ) -termal;
reconsider D963 = R19 as ( 0 ) -termal (string of R15) by L1392;
reconsider D964 = ( D956 . D963 ) as  literal (Element of R15);
reconsider D965 = D964 as (Element of D955) by FOMODEL1:def 14;
L1393: D963 = ( <* D964 *> ^ ( D958 . ( SubTerms D963 ) ) ) by FOMODEL1:def 37
.= ( <* D964 *> ^ ( {} ) )
.= <* D964 *>;
L1394: ( ( rng D963 ) /\ D955 ) = ( { D965 } null D955 ) by L1393 , FINSEQ_1:38;
thus L1395: thesis by L1394;
end;
L1396: (for R1 being Nat holds (S21[ R1 ] implies S21[ ( R1 + 1 ) ]))
proof
let R1 being Nat;
reconsider D966 = R1 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L1397: S21[ R1 ];
let R19 being (string of R15);
assume L1398: R19 is ( R1 + 1 ) -termal;
reconsider D967 = R19 as ( R1 + 1 ) -termal (string of R15) by L1398;
per cases ;
suppose L1399: (not D967 is ( 0 ) -termal);

L1400: ( D956 . D967 ) is  operational by L1399 , FOMODEL1:16;
reconsider D968 = ( abs ( ar ( D956 . D967 ) ) ) as non  zero Nat by L1400;
consider R2 being Nat such that L1401: D968 = ( R2 + 1 ) by NAT_1:6;
reconsider D969 = R2 , D970 = D968 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D971 = D967 as ( D966 + 1 ) -termal (string of R15);
reconsider D972 = ( SubTerms D967 ) as ( R2 + 1 ) -element (Element of ( D957 * )) by L1401;
L1402: D972 is ( ( R2 + 1 ) + ( 0 ) ) -element;
L1403: ( { ( D972 . ( R2 + 1 ) ) } \ D957 ) = ( {} ) by L1402;
reconsider D973 = ( D972 . ( R2 + 1 ) ) as (Element of D962) by L1403 , ZFMISC_1:60;
L1404: D973 is (Element of ( D959 * )) by TARSKI:def 3;
reconsider D974 = D973 as D959 -valued FinSequence by L1404;
reconsider D975 = ( D972 | ( Seg R2 ) ) as D962 -valued FinSequence;
L1405: ( ( ( D972 | ( Seg R2 ) ) ^ <* ( D972 . ( R2 + 1 ) ) *> ) \+\ D972 ) = ( {} );
L1406: D972 = ( D975 ^ <* D974 *> ) by L1405 , FOMODEL0:29;
L1407: ( D958 . D972 ) = ( ( D958 . D975 ) ^ D974 ) by L1406 , FOMODEL0:33;
L1408: D967 = ( <* ( D956 . D967 ) *> ^ ( ( D958 . D975 ) ^ D974 ) ) by L1407 , FOMODEL1:def 37;
L1409: ( rng D967 ) = ( ( rng <* ( D956 . D967 ) *> ) \/ ( rng ( ( D958 . D975 ) ^ D974 ) ) ) by L1408 , FINSEQ_1:31
.= ( { ( D956 . D967 ) } \/ ( rng ( ( D958 . D975 ) ^ D974 ) ) ) by FINSEQ_1:38
.= ( { ( D956 . D967 ) } \/ ( ( rng ( D958 . D975 ) ) \/ ( rng D974 ) ) ) by FINSEQ_1:31
.= ( ( rng D974 ) \/ ( { ( D956 . D967 ) } \/ ( rng ( D958 . D975 ) ) ) ) by XBOOLE_1:4;
L1410: ( ( rng D974 ) null ( { ( D956 . D967 ) } \/ ( rng ( D958 . D975 ) ) ) ) c= ( rng D967 ) by L1409;
L1411: ( ( rng D973 ) /\ D955 ) c= ( ( rng D967 ) /\ D955 ) by L1410 , XBOOLE_1:26;
L1412: ( SubTerms D971 ) is ( D961 . D966 ) -valued;
reconsider D976 = D972 as ( D961 . D966 ) -valued ( ( R2 + 1 ) + ( 0 ) ) -element FinSequence by L1412;
L1413: ( { ( D976 . ( R2 + 1 ) ) } \ ( D961 . D966 ) ) = ( {} );
reconsider D977 = D973 as (Element of ( D961 . D966 )) by L1413 , ZFMISC_1:60;
reconsider D978 = D977 as R1 -termal (string of R15) by FOMODEL1:def 33;
L1414: ( ( rng D978 ) /\ D955 ) <> ( {} ) by L1397;
thus L1415: thesis by L1414 , L1411;
end;
suppose L1416: D967 is ( 0 ) -termal;

thus L1417: thesis by L1416 , L1391;
end;
end;
L1419: (for R2 being Nat holds S21[ R2 ]) from NAT_1:sch 2(L1391 , L1396);
assume L1420: R19 is  termal;
reconsider D979 = R19 as  termal (string of R15) by L1420;
L1421: D979 is ( Depth D979 ) -termal by FOMODEL1:def 40;
thus L1422: thesis by L1421 , L1419;
end;
registration
let R15 being Language;
let R33 being  termal (string of R15);
cluster ( ( rng R33 ) /\ ( LettersOf R15 ) ) -> non  empty for set;
coherence by L1390;
end;
L1424: (for R15 being Language holds (for R19 being (string of R15) holds (R19 is  wff implies ( ( rng R19 ) /\ ( LettersOf R15 ) ) <> ( {} ))))
proof
let R15 being Language;
let R19 being (string of R15);
set D980 = ( LettersOf R15 );
set D981 = ( R15 -firstChar );
set D982 = ( AllTermsOf R15 );
set D983 = ( R15 -multiCat );
set D984 = ( AllSymbolsOf R15 );
set D985 = ( D984 -multiCat );
set D986 = ( R15 -termsOfMaxDepth );
reconsider D987 = D982 as (Subset of ( D984 * )) by XBOOLE_1:1;
defpred S22[ Nat ] means (for R19 being (string of R15) holds (R19 is $1 -wff implies ( ( rng R19 ) /\ D980 ) <> ( {} )));
L1425: S22[ ( 0 ) ]
proof
let R19 being (string of R15);
assume L1426: R19 is ( 0 ) -wff;
reconsider D988 = R19 as  0wff (string of R15) by L1426;
reconsider D989 = ( D981 . D988 ) as  relational (Element of R15);
reconsider D990 = ( abs ( ar D989 ) ) as non  zero Nat;
consider R2 being Nat such that L1427: D990 = ( R2 + 1 ) by NAT_1:6;
reconsider D991 = ( SubTerms D988 ) as ( ( R2 + 1 ) + ( 0 ) ) -element (Element of ( D982 * )) by L1427;
reconsider D992 = ( D991 | ( Seg R2 ) ) as ( D984 * ) -valued FinSequence;
L1428: ( { ( D991 . ( R2 + 1 ) ) } \ D982 ) = ( {} );
reconsider D993 = ( D991 . ( R2 + 1 ) ) as (Element of D982) by L1428 , ZFMISC_1:60;
reconsider D994 = D993 as  termal (string of R15);
L1429: ( ( ( D991 | ( Seg R2 ) ) ^ <* D993 *> ) \+\ D991 ) = ( {} );
L1430: D991 = ( ( D991 | ( Seg R2 ) ) ^ <* D993 *> ) by L1429 , FOMODEL0:29;
reconsider D995 = D993 as D984 -valued FinSequence;
L1431: D988 = ( <* D989 *> ^ ( D983 . D991 ) ) by FOMODEL1:def 38
.= ( <* D989 *> ^ ( ( D983 . D992 ) ^ D995 ) ) by L1430 , FOMODEL0:33;
L1432: ( rng D988 ) = ( ( rng <* D989 *> ) \/ ( rng ( ( D983 . D992 ) ^ D993 ) ) ) by L1431 , FINSEQ_1:31
.= ( ( rng <* D989 *> ) \/ ( ( rng ( D983 . D992 ) ) \/ ( rng D993 ) ) ) by FINSEQ_1:31
.= ( ( rng D993 ) \/ ( ( rng <* D989 *> ) \/ ( rng ( D983 . D992 ) ) ) ) by XBOOLE_1:4;
L1433: ( ( rng D994 ) null ( ( rng <* D989 *> ) \/ ( rng ( D983 . D992 ) ) ) ) c= ( rng D988 ) by L1432;
L1434: ( ( rng D994 ) /\ D980 ) c= ( ( rng D988 ) /\ D980 ) by L1433 , XBOOLE_1:26;
thus L1435: thesis by L1434;
end;
L1436: (for R1 being Nat holds (S22[ R1 ] implies S22[ ( R1 + 1 ) ]))
proof
let R1 being Nat;
assume L1437: S22[ R1 ];
let R19 being (string of R15);
assume L1438: R19 is ( R1 + 1 ) -wff;
reconsider D996 = R19 as ( R1 + 1 ) -wff (string of R15) by L1438;
per cases ;
suppose L1439: (not D996 is  0wff);

reconsider D997 = D996 as non  0wff  wff (string of R15) by L1439;
reconsider D998 = ( head D997 ) as R1 -wff (string of R15);
L1440: D997 = ( ( <* ( D981 . D997 ) *> ^ D998 ) ^ ( tail D996 ) ) by L1237;
L1441: ( rng D997 ) = ( ( rng ( <* ( D981 . D997 ) *> ^ D998 ) ) \/ ( rng ( tail D996 ) ) ) by L1440 , FINSEQ_1:31
.= ( ( ( rng D998 ) \/ ( rng <* ( D981 . D997 ) *> ) ) \/ ( rng ( tail D996 ) ) ) by FINSEQ_1:31
.= ( ( rng D998 ) \/ ( ( rng <* ( D981 . D997 ) *> ) \/ ( rng ( tail D996 ) ) ) ) by XBOOLE_1:4;
L1442: ( ( rng D998 ) null ( ( rng <* ( D981 . D997 ) *> ) \/ ( rng ( tail D996 ) ) ) ) c= ( rng D997 ) by L1441;
L1443: ( ( rng D998 ) /\ D980 ) c= ( ( rng D997 ) /\ D980 ) by L1442 , XBOOLE_1:26;
thus L1444: thesis by L1443 , L1437 , XBOOLE_1:3;
end;
suppose L1445: D996 is  0wff;

thus L1446: thesis by L1445 , L1425;
end;
end;
L1448: (for R2 being Nat holds S22[ R2 ]) from NAT_1:sch 2(L1425 , L1436);
assume L1449: R19 is  wff;
reconsider D999 = R19 as  wff (string of R15) by L1449;
L1450: D999 is ( Depth D999 ) -wff by L708;
thus L1451: thesis by L1450 , L1448;
end;
registration
let R15 being Language;
let R42 being  wff (string of R15);
cluster ( ( rng R42 ) /\ ( LettersOf R15 ) ) -> non  empty for set;
coherence by L1424;
end;
registration
let R8 being set;
let R15 being Language;
let C352 being (Subset of R8);
cluster C352 -occurring -> R8 -occurring for (Element of R15);
coherence
proof
set D1000 = ( AllSymbolsOf R15 );
set D1001 = ( C352 /\ ( ( D1000 * ) \ { ( {} ) } ) );
set D1002 = ( R8 /\ ( ( D1000 * ) \ { ( {} ) } ) );
reconsider D1003 = D1002 as  functional set;
reconsider D1004 = D1001 as (Subset of D1003) by XBOOLE_1:26;
L1453: ( SymbolsOf D1004 ) c= ( SymbolsOf D1003 ) by FOMODEL0:46;
let C353 being (Element of R15);
assume L1454: C353 is C352 -occurring;
L1455: C353 in ( SymbolsOf D1004 ) by L1454 , L1382;
thus L1456: C353 is R8 -occurring by L1455 , L1382 , L1453;
end;
end;
registration
let R7 being set;
let R8 being set;
let R15 being Language;
cluster ( R7 null R8 ) -absent -> ( R7 /\ R8 ) -absent for (Element of R15);
coherence;
end;
registration
let C354 being  finite set;
let R7 being set;
let R15 being Language;
cluster R7 -absent -> ( R7 \/ C354 ) -absent for C354 -absent C354 -absent C354 -absent C354 -absent (Element of R15);
coherence
proof
set D1005 = ( AllSymbolsOf R15 );
set D1006 = ( ( D1005 * ) \ { ( {} ) } );
reconsider D1007 = ( D1006 /\ R7 ) , D1008 = ( D1006 /\ C354 ) as (Subset of D1006);
reconsider D1009 = ( D1007 \/ D1008 ) as (Subset of D1006);
L1459: D1009 = ( D1006 /\ ( R7 \/ C354 ) ) by XBOOLE_1:23;
let C355 being C354 -absent (Element of R15);
assume L1460: C355 is R7 -absent;
L1461: ((not C355 in ( SymbolsOf D1007 )) & (not C355 in ( SymbolsOf D1008 ))) by L1460 , L1382;
L1462: (not C355 in ( ( SymbolsOf D1007 ) \/ ( SymbolsOf D1008 ) )) by L1461 , XBOOLE_0:def 3;
L1463: (not C355 in ( SymbolsOf D1009 )) by L1462 , FOMODEL0:47;
thus L1464: thesis by L1463 , L1459 , L1382;
end;
end;
registration
let R15 being Language;
let R22 being non  empty set;
let C356 being (R15 , R22)-interpreter-like Function;
cluster ( ( OwnSymbolsOf R15 ) \ ( dom C356 ) ) ->  empty for set;
coherence
proof
L1466: ( OwnSymbolsOf R15 ) c= ( dom C356 ) by L41;
thus L1467: thesis by L1466;
end;
end;
theorem
L1469: (for R15 being Language holds (for R22 being non  empty set holds (for R35 being  literal (Element of R15) holds (for R46 being (R15 , R22)-interpreter-like Function holds (ex R30 being (Element of R22) st (R30 = ( ( R46 . R35 ) . ( {} ) ) & ( (R35 , R30) ReassignIn R46 ) = R46))))))
proof
let R15 being Language;
let R22 being non  empty set;
let R35 being  literal (Element of R15);
let R46 being (R15 , R22)-interpreter-like Function;
set D1010 = ( OwnSymbolsOf R15 );
L1470: ( D1010 \ ( dom R46 ) ) = ( {} );
L1471: (D1010 c= ( dom R46 ) & { ( {} ) } = { ( {} ) }) by L1470 , XBOOLE_1:37;
reconsider D1011 = R35 as (Element of D1010) by FOMODEL1:def 19;
reconsider D1012 = ( R46 . R35 ) as (Interpreter of R35 , R22);
L1472: (D1012 is (Function of ( ( 0 ) -tuples_on R22 ) , R22) & ( ( 0 ) -tuples_on R22 ) = { ( {} ) }) by L4 , FOMODEL0:10;
reconsider D1013 = D1012 as (Function of { ( {} ) } , R22) by L1472;
reconsider D1014 = ( {} ) as (Element of { ( {} ) }) by TARSKI:def 1;
reconsider D1015 = ( D1013 . D1014 ) as (Element of R22);
take D1015;
thus L1473: D1015 = ( ( R46 . R35 ) . ( {} ) );
set D1016 = ( ( {} ) .--> D1015 );
set D1017 = ( R35 .--> D1016 );
set D1018 = ( (R35 , D1015) ReassignIn R46 );
L1474: D1016 = ( { ( {} ) } --> D1015 );
reconsider D1019 = D1016 as (Function of { ( {} ) } , R22) by L1474;
L1475: ( dom D1017 ) = { D1011 } by FUNCOP_1:13;
L1476: ( dom D1017 ) c= ( dom R46 ) by L1475 , L1471 , XBOOLE_1:1;
L1477:
now
let C357 being (Element of { ( {} ) });
L1478: (( D1013 . C357 ) = D1015 & ( D1019 . C357 ) = D1015) by FUNCOP_1:7;
thus L1479: ( D1013 . C357 ) = ( D1019 . C357 ) by L1478;
end;
L1480: D1013 = D1019 by L1477 , FUNCT_2:63;
L1481:
now
let R14 being set;
assume L1482: R14 in ( dom D1017 );
L1483: R14 in { R35 } by L1482;
thus L1484: ( D1017 . R14 ) = D1016 by L1483 , FUNCOP_1:7
.= ( R46 . R14 ) by L1480 , L1483 , TARSKI:def 1;
end;
L1485: D1017 tolerates R46 by L1481 , L1476 , PARTFUN1:53;
L1486: D1018 = ( D1017 +* R46 ) by L1485 , FUNCT_4:34
.= R46 by L1475 , L1471 , FUNCT_4:19 , XBOOLE_1:1;
thus L1487: thesis by L1486;
end;
definition
let R15 being Language;
let R9 being set;
attr R9 is R15 -covering
means
(for R42 being  wff (string of R15) holds (R42 in R9 or ( xnot R42 ) in R9));
end;
registration
let R15 being Language;
cluster R15 -mincover -> R15 -covering for set;
coherence
proof
let R9 being set;
assume L1489: R9 is R15 -mincover;
thus L1490: (for R42 being  wff (string of R15) holds ((not R42 in R9) implies ( xnot R42 ) in R9)) by L1489 , L1150;
thus L1491: thesis;
end;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let C358 being non  0wff non  exal  wff (string of R15);
let C359 being (Element of ( R22 -InterpretersOf R15 ));
cluster ( ( C359 -TruthEval C358 ) \+\ ( ( C359 -TruthEval ( head C358 ) ) 'nor' ( C359 -TruthEval ( tail C358 ) ) ) ) ->  empty for set;
coherence
proof
set D1020 = ( head C358 );
set D1021 = ( tail C358 );
set D1022 = ( C359 -TruthEval C358 );
set D1023 = ( C359 -TruthEval D1020 );
set D1024 = ( C359 -TruthEval D1021 );
set D1025 = ( D1023 'nor' D1024 );
set D1026 = ( R15 -firstChar );
set D1027 = ( D1026 . C358 );
set D1028 = ( TheNorSymbOf R15 );
L1493: ( D1027 \+\ D1028 ) = ( {} );
L1494: D1027 = D1028 by L1493 , FOMODEL0:29;
L1495: C358 = ( ( <* D1028 *> ^ D1020 ) ^ D1021 ) by L1494 , L1237;
L1496: D1025 = D1022
proof
per cases ;
suppose L1497: (not D1025 = ( 0 ));

L1498: ((not D1023 = 1) & (not D1024 = 1)) by L1497;
L1499: (D1023 = ( 0 ) & D1024 = ( 0 )) by L1498 , FOMODEL0:39;
thus L1500: thesis by L1499 , L1495 , L1124;
end;
suppose L1501: D1025 = ( 0 );

L1502: (( 1 - D1023 ) = ( 0 ) or ( 1 - D1024 ) = ( 0 )) by L1501;
L1503: (not D1022 = 1) by L1502 , L1495 , L1124;
thus L1504: thesis by L1503 , L1501 , FOMODEL0:39;
end;
end;
thus L1506: thesis by L1496;
end;
end;
definition
let R15 being Language;
func ExFormulasOf R15 -> (Subset of ( ( ( AllSymbolsOf R15 ) * ) \ { ( {} ) } )) equals 
{ B222 where B222 is (string of R15) : (B222 is  wff & B222 is  exal) };
coherence
proof
set D1029 = ( AllSymbolsOf R15 );
set D1030 = ( ( D1029 * ) \ { ( {} ) } );
defpred S23[ (string of R15) ] means ($1 is  wff & $1 is  exal);
defpred S24[ set ] means (not contradiction);
deffunc H17(set) = $1;
L1508: (for R19 being (string of R15) holds (S23[ R19 ] implies S24[ R19 ]));
set D1031 = { H17(R19) where R19 is (string of R15) : S23[ R19 ] };
L1509: D1031 c= { H17(R19) where R19 is (string of R15) : S24[ R19 ] } from FRAENKEL:sch 1(L1508);
thus L1510: thesis by L1509 , DOMAIN_1:18;
end;
end;
registration
let R15 being Language;
cluster ( ExFormulasOf R15 ) -> non  empty for set;
coherence
proof
L1512: the  exal  wff (string of R15) in ( ExFormulasOf R15 );
thus L1513: thesis by L1512;
end;
end;
registration
let R15 being Language;
cluster  ->  exal  wff for (Element of ( ExFormulasOf R15 ));
coherence
proof
set D1032 = ( ExFormulasOf R15 );
let C360 being (Element of ( ExFormulasOf R15 ));
L1515: C360 in D1032;
consider R19 being (string of R15) such that L1516: (C360 = R19 & R19 is  wff & R19 is  exal) by L1515;
reconsider D1033 = C360 as  exal  wff (string of R15) by L1516;
L1517: D1033 is  exal  wff  exal  wff  exal  wff  exal  wff (string of R15);
thus L1518: thesis by L1517;
end;
end;
registration
let R15 being Language;
cluster  ->  wff for (Element of ( ExFormulasOf R15 ));
coherence;
end;
registration
let R15 being Language;
cluster  ->  exal for (Element of ( ExFormulasOf R15 ));
coherence;
end;
registration
let R15 being Language;
cluster ( ( ExFormulasOf R15 ) \ ( AllFormulasOf R15 ) ) ->  empty for set;
coherence
proof
set D1034 = ( ExFormulasOf R15 );
set D1035 = ( AllFormulasOf R15 );
L1522: (for R12 being set holds (R12 in D1034 implies R12 in D1035)) by L1022;
L1523: D1034 c= D1035 by L1522 , TARSKI:def 3;
thus L1524: thesis by L1523;
end;
end;
registration
let R22 being non  empty set;
let R16 being Language;
let C361 being R16 -extending Language;
cluster (C361 , R22)-interpreter-like -> (R16 , R22)-interpreter-like for Function;
coherence
proof
set D1036 = ( OwnSymbolsOf R16 );
set D1037 = ( OwnSymbolsOf C361 );
set D1038 = (the adicity of R16);
set D1039 = (the adicity of C361);
set D1040 = ( AtomicFormulaSymbolsOf R16 );
set D1041 = ( TheEqSymbOf C361 );
set D1042 = ( AtomicFormulaSymbolsOf C361 );
set D1043 = ( TheEqSymbOf R16 );
let C362 being Function;
assume L1526: C362 is (C361 , R22)-interpreter-like;
reconsider D1044 = C362 as (C361 , R22)-interpreter-like Function by L1526;
reconsider D1045 = D1044 as (Interpreter of C361 , R22) by L31;
L1527: ( D1036 \ D1037 ) = ( {} );
L1528: (D1036 c= D1037 & ( dom D1038 ) = D1040 & ( dom D1039 ) = D1042) by L1527 , FUNCT_2:def 1 , XBOOLE_1:37;
L1529: D1038 c= D1039 by FOMODEL1:def 41;
L1530: ( dom D1038 ) c= ( dom D1039 ) by L1529 , RELAT_1:11;
L1531:
now
let C363 being  own (Element of R16);
L1532: C363 in D1040 by FOMODEL1:def 20;
L1533: C363 in ( dom D1038 ) by L1532 , FUNCT_2:def 1;
L1534: C363 in D1042 by L1532 , L1530 , L1528;
reconsider D1046 = C363 as  ofAtomicFormula (Element of C361) by L1534 , FOMODEL1:def 20;
L1535: C363 <> D1043;
L1536: (D1046 <> D1041 & D1046 <> ( TheNorSymbOf C361 )) by L1535 , FOMODEL1:def 41;
L1537: D1046 is (Element of D1037) by L1536 , FOMODEL1:15;
reconsider D1047 = D1046 as  own (Element of C361) by L1537 , FOMODEL1:def 19;
reconsider D1048 = ( D1045 . D1047 ) as (Interpreter of D1047 , R22) by L24;
set D1049 = ( ar D1047 );
set D1050 = ( ar C363 );
L1538: D1038 c= D1039 by FOMODEL1:def 41;
L1539: ( D1039 . D1047 ) = ( ( D1039 +* D1038 ) . D1047 ) by L1538 , FUNCT_4:98
.= ( D1038 . D1047 ) by L1533 , FUNCT_4:13;
L1540: D1050 = D1049 by L1539;
per cases ;
suppose L1541: D1047 is  relational;

L1542: (C363 is  relational & D1048 is (Function of ( ( abs D1050 ) -tuples_on R22 ) , ( BOOLEAN ))) by L1541 , L1540 , L4;
thus L1543: ( C362 . C363 ) is (Interpreter of C363 , R22) by L1542 , L4;
end;
suppose L1544: (not D1047 is  relational);

L1545: (D1048 is (Function of ( ( abs D1050 ) -tuples_on R22 ) , R22) & (not C363 is  relational)) by L1544 , L1540 , L4;
thus L1546: ( C362 . C363 ) is (Interpreter of C363 , R22) by L1545 , L4;
end;
end;
L1548: (C362 is (Interpreter of R16 , R22) & D1044 is  Function-yielding) by L1531 , L24;
thus L1549: thesis by L1548 , L31;
end;
end;
registration
let R22 being non  empty set;
let R16 being Language;
let C364 being R16 -extending Language;
let C365 being (C364 , R22)-interpreter-like Function;
cluster ( C365 | ( OwnSymbolsOf R16 ) ) -> (R16 , R22)-interpreter-like for Function;
coherence;
end;
registration
let R22 being non  empty set;
let R16 being Language;
let C366 being R16 -extending Language;
let C367 being (Element of ( R22 -InterpretersOf R16 ));
let C368 being (C366 , R22)-interpreter-like Function;
cluster ( C368 +* C367 ) -> (C366 , R22)-interpreter-like;
coherence
proof
set D1051 = ( C368 +* C367 );
set D1052 = ( OwnSymbolsOf R16 );
set D1053 = ( OwnSymbolsOf C366 );
set D1054 = (the adicity of R16);
set D1055 = (the adicity of C366);
set D1056 = ( AtomicFormulaSymbolsOf R16 );
L1552:
now
let C369 being  own (Element of C366);
per cases ;
suppose L1553: C369 in ( dom C367 );

L1554: (C369 in D1052 & ( D1051 . C369 ) = ( C367 . C369 )) by L1553 , FUNCT_4:13;
reconsider D1057 = C369 as  own (Element of R16) by L1554 , FOMODEL1:def 19;
L1555: D1057 in D1056 by FOMODEL1:def 20;
L1556: D1057 in ( dom D1054 ) by L1555 , FUNCT_2:def 1;
reconsider D1058 = ( C367 . D1057 ) as (Interpreter of D1057 , R22);
set D1059 = ( ar C369 );
set D1060 = ( ar D1057 );
L1557: D1054 c= D1055 by FOMODEL1:def 41;
L1558: ( D1055 . C369 ) = ( ( D1055 +* D1054 ) . C369 ) by L1557 , FUNCT_4:98
.= ( D1054 . C369 ) by L1556 , FUNCT_4:13;
L1559: D1060 = D1059 by L1558;
per cases ;
suppose L1560: D1057 is  relational;

L1561: (C369 is  relational & D1058 is (Function of ( ( abs D1059 ) -tuples_on R22 ) , ( BOOLEAN ))) by L1560 , L1559 , L4;
thus L1562: ( D1051 . C369 ) is (Interpreter of C369 , R22) by L1561 , L1554 , L4;
end;
suppose L1563: (not D1057 is  relational);

L1564: (D1058 is (Function of ( ( abs D1059 ) -tuples_on R22 ) , R22) & (not C369 is  relational)) by L1563 , L1559 , L4;
thus L1565: ( D1051 . C369 ) is (Interpreter of C369 , R22) by L1564 , L4 , L1554;
end;
end;
suppose L1567: (not C369 in ( dom C367 ));

L1568: ( D1051 . C369 ) = ( C368 . C369 ) by L1567 , FUNCT_4:11;
thus L1569: ( D1051 . C369 ) is (Interpreter of C369 , R22) by L1568;
end;
end;
L1571: D1051 is (Interpreter of C366 , R22) by L1552 , L24;
thus L1572: thesis by L1571 , L31;
end;
end;
definition
let R22 being non  empty set;
let R15 being Language;
let C370 being (Element of ( R22 -InterpretersOf R15 ));
let R9 being set;
attr R9 is C370 -satisfied
means
:L1574: (for R42 being  wff (string of R15) holds (R42 in R9 implies ( C370 -TruthEval R42 ) = 1));
end;
definition
let R15 being Language;
let R22 being non  empty set;
let R9 being set;
let C371 being (Element of ( R22 -InterpretersOf R15 ));
attr C371 is R9 -satisfying
means
:L1576: R9 is C371 -satisfied;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let C372 being  empty set;
let C373 being (Element of ( R22 -InterpretersOf R15 ));
cluster ( C372 null C373 ) -> C373 -satisfied;
coherence
proof
L1578: (for R42 being  wff (string of R15) holds (R42 in ( C372 null C373 ) implies ( C373 -TruthEval R42 ) = 1));
thus L1579: thesis by L1578 , L1574;
end;
end;
registration
let R9 being set;
let R22 being non  empty set;
let R15 being Language;
let C374 being (Element of ( R22 -InterpretersOf R15 ));
cluster C374 -satisfied for (Subset of R9);
existence
proof
reconsider D1061 = ( ( {} ) null C374 ) as (Subset of R9) by XBOOLE_1:2;
take D1061;
thus L1581: thesis;
end;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let C375 being (Element of ( R22 -InterpretersOf R15 ));
cluster C375 -satisfied for set;
existence
proof
take the C375 -satisfied (Subset of 1);
thus L1583: thesis;
end;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let C376 being (Element of ( R22 -InterpretersOf R15 ));
let C377 being C376 -satisfied set;
cluster  -> C376 -satisfied for (Subset of C377);
coherence
proof
let C378 being (Subset of C377);
L1585: (for R42 being  wff (string of R15) holds (R42 in C378 implies ( C376 -TruthEval R42 ) = 1)) by L1574;
thus L1586: thesis by L1585 , L1574;
end;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let C379 being (Element of ( R22 -InterpretersOf R15 ));
let C380 , C381 being C379 -satisfied set;
cluster ( C380 \/ C381 ) -> C379 -satisfied;
coherence
proof
L1588:
now
let R42 being  wff (string of R15);
assume L1589: R42 in ( C380 \/ C381 );
L1590: (R42 in C380 or R42 in C381) by L1589 , XBOOLE_0:def 3;
thus L1591: ( C379 -TruthEval R42 ) = 1 by L1590 , L1574;
end;
thus L1592: thesis by L1588 , L1574;
end;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let C382 being (Element of ( R22 -InterpretersOf R15 ));
let C383 being C382 -satisfied set;
cluster ( C382 null C383 ) -> C383 -satisfying for (Element of ( R22 -InterpretersOf R15 ));
coherence by L1576;
end;
definition
let R15 being Language;
let R9 being set;
attr R9 is R15 -correct
means
:L1595: (for B223 being non  empty set holds (for B224 being (Element of ( B223 -InterpretersOf R15 )) holds (for B225 being B224 -satisfied set holds (for R42 being  wff (string of R15) holds ([ B225 , R42 ] in R9 implies ( B224 -TruthEval R42 ) = 1)))));
end;
registration
let R15 being Language;
cluster ( ( {} ) null R15 ) -> R15 -correct;
coherence
proof
L1597: (for B226 being non  empty set holds (for B227 being (Element of ( B226 -InterpretersOf R15 )) holds (for B228 being B227 -satisfied set holds (for R42 being  wff (string of R15) holds ([ B228 , R42 ] in ( ( {} ) null R15 ) implies ( B227 -TruthEval R42 ) = 1)))));
thus L1598: thesis by L1597 , L1595;
end;
end;
registration
let R15 being Language;
let R9 being set;
cluster R15 -correct for (Subset of R9);
existence
proof
reconsider D1062 = ( ( {} ) null R15 ) as (Subset of R9) by XBOOLE_1:2;
take D1062;
thus L1600: D1062 is R15 -correct;
end;
end;
theorem
L1602: (for R15 being Language holds (for R22 being non  empty set holds (for R42 being  wff (string of R15) holds (for B229 being (Element of ( R22 -InterpretersOf R15 )) holds (( B229 -TruthEval R42 ) = 1 iff { R42 } is B229 -satisfied)))))
proof
let R15 being Language;
let R22 being non  empty set;
let R42 being  wff (string of R15);
let C384 being (Element of ( R22 -InterpretersOf R15 ));
thus L1603:now
assume L1604: ( C384 -TruthEval R42 ) = 1;
L1605: (for R41 being  wff (string of R15) holds (R41 in { R42 } implies ( C384 -TruthEval R41 ) = 1)) by L1604 , TARSKI:def 1;
thus L1606: { R42 } is C384 -satisfied by L1605 , L1574;
end;
assume L1607: { R42 } is C384 -satisfied;
reconsider D1063 = { R42 } as C384 -satisfied set by L1607;
L1608: R42 in D1063 by TARSKI:def 1;
thus L1609: ( C384 -TruthEval R42 ) = 1 by L1608 , L1574;
end;
theorem
L1610: (for R15 being Language holds (for R18 being (Element of R15) holds (for R19 being (string of R15) holds (R18 is { R19 } -occurring iff R18 in ( rng R19 )))))
proof
let R15 being Language;
let R18 being (Element of R15);
let R19 being (string of R15);
set D1064 = ( AllSymbolsOf R15 );
set D1065 = ( ( D1064 * ) \ { ( {} ) } );
reconsider D1066 = { R19 } as non  empty (Subset of D1065);
L1611: ( SymbolsOf ( D1065 /\ D1066 ) ) = ( rng R19 ) by FOMODEL0:45;
thus L1612: thesis by L1611 , L1382;
end;
registration
let R22 being non  empty set;
let R15 being Language;
let R43 being  wff (string of R15);
let R44 being  wff (string of R15);
let C385 being (Element of ( R22 -InterpretersOf R15 ));
cluster ( ( C385 -TruthEval ( ( <* ( TheNorSymbOf R15 ) *> ^ R43 ) ^ R44 ) ) \+\ ( ( C385 -TruthEval R43 ) 'nor' ( C385 -TruthEval R44 ) ) ) ->  empty for set;
coherence
proof
set D1067 = ( R15 -firstChar );
set D1068 = ( TheNorSymbOf R15 );
set D1069 = ( ( <* D1068 *> ^ R43 ) ^ R44 );
set D1070 = ( C385 -TruthEval D1069 );
set D1071 = ( C385 -TruthEval R43 );
set D1072 = ( C385 -TruthEval R44 );
set D1073 = ( head D1069 );
set D1074 = ( tail D1069 );
set D1075 = ( C385 -TruthEval D1073 );
set D1076 = ( C385 -TruthEval D1074 );
L1613: (R43 = D1073 & R44 = D1074) by L1237;
thus L1614: thesis by L1613;
end;
end;
registration
let R15 being Language;
let R42 being  wff (string of R15);
let R22 being non  empty set;
let C386 being (Element of ( R22 -InterpretersOf R15 ));
cluster ( ( C386 -TruthEval ( xnot R42 ) ) \+\ ( 'not' ( C386 -TruthEval R42 ) ) ) ->  empty for set;
coherence
proof
set D1077 = ( TheNorSymbOf R15 );
set D1078 = ( C386 -TruthEval R42 );
set D1079 = ( xnot R42 );
L1616: ( ( C386 -TruthEval D1079 ) \+\ ( D1078 'nor' D1078 ) ) = ( {} );
thus L1617: thesis by L1616;
end;
end;
definition
let R9 being set;
let R15 being Language;
let R42 being  wff (string of R15);
attr R42 is R9 -implied
means
(for B230 being non  empty set holds (for B231 being (Element of ( B230 -InterpretersOf R15 )) holds (R9 is B231 -satisfied implies ( B231 -TruthEval R42 ) = 1)));
end;
