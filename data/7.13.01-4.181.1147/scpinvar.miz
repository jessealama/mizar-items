:: Justifying the Correctness of Fibonacci Sequence and Euclide
:: Algorithm by Loop Invariant
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, TURING_1, FUNCT_1, CARD_1,
      SCMFSA_7, RELAT_1, ARYTM_3, CARD_3, FSM_1, XXREAL_0, COMPLEX1, ARYTM_1,
      AMI_2, SCMPDS_5, SCMPDS_4, INT_1, SCMPDS_8, SCMFSA6B, SCMFSA_9, UNIALG_2,
      SCMFSA7B, SCMP_GCD, SEMI_AF1, GRAPHSP, AMI_3, FINSEQ_1, SCPISORT, NAT_1,
      ORDINAL4, SFMASTR2, PRE_FF, FUNCT_4, CIRCUIT2, TARSKI, PBOOLE, MSUALG_1,
      STRUCT_0, VALUED_1, SCMFSA8B, INT_2, SCPINVAR, ORDINAL1, PARTFUN1,
      EXTPRO_1, SCMFSA6C, COMPOS_1, MEMSTR_0;
 notations XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, FUNCT_1, PARTFUN1,
      VALUED_1, XCMPLX_0, FUNCT_4, PBOOLE, INT_1, INT_2, ORDINAL1, NAT_1,
      STRUCT_0, MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMI_2, SCMPDS_2,
      SCMPDS_4, SCMPDS_6, SCMP_GCD, SCMPDS_5, SCMPDS_8, FUNCT_2, CARD_3,
      DOMAIN_1, FINSEQ_1, GR_CY_1, PRE_FF, SCPISORT, XXREAL_0;
 constructors DOMAIN_1, REAL_1, NAT_D, RECDEF_1, PRE_FF, MESFUNC1, GR_CY_1,
      SCM_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT,
      BINOP_2, AMI_2, MEMSTR_0, RELSET_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XREAL_0, NAT_1,
      INT_1, CARD_3, STRUCT_0, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMPDS_8, XBOOLE_0, FINSEQ_1, CARD_1, VALUED_1, VALUED_0, MEMSTR_0,
      RELAT_1, FUNCT_2, COMPOS_1, AFINSQ_1, EXTPRO_1, PBOOLE, FUNCT_4, AMI_3,
      COMPOS_0;
 requirements NUMERALS, REAL, SUBSET, ARITHM, BOOLE;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_3, SCMPDS_2, SCMP_GCD, SCPISORT,
      MEMSTR_0;
 theorems AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, ABSVALUE, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, INT_2, SCMPDS_8, SCMP_GCD,
      SCMPDS_7, FUNCT_1, FINSEQ_1, RVSUM_1, FINSEQ_2, MEMSTR_0, PRE_FF,
      SCPISORT, XBOOLE_1, XREAL_1, COMPLEX1, XXREAL_0, PREPOWER, ORDINAL1,
      FUNCOP_1, ZFMISC_1, NAT_D, FINSEQ_3, PBOOLE, PARTFUN1, AFINSQ_1,
      COMPOS_1, EXTPRO_1, CARD_3, XTUPLE_0;
 schemes NAT_1, SCMPDS_8, FUNCT_2;

begin
theorem
L1: (for R3 being (Instruction of ( SCMPDS )) holds (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Program of ( SCMPDS )) holds (( ( ( R3 ';' R4 ) ';' R5 ) . ( 0 ) ) = R3 & ( ( ( R3 ';' R4 ) ';' R5 ) . 1 ) = R4))))
proof
let R3 being (Instruction of ( SCMPDS ));
let R4 being (Instruction of ( SCMPDS ));
let R5 being (Program of ( SCMPDS ));
set D1 = ( R4 ';' R5 );
L2: ( ( R3 ';' R4 ) ';' R5 ) = ( R3 ';' D1 ) by SCMPDS_4:16
.= ( ( Load R3 ) ';' D1 ) by SCMPDS_4:def 2;
L3: ( 0 ) in ( dom ( Load R3 ) ) by COMPOS_1:50;
thus L4: ( ( ( R3 ';' R4 ) ';' R5 ) . ( 0 ) ) = ( ( Load R3 ) . ( 0 ) ) by L3 , L2 , AFINSQ_1:def 3
.= R3 by COMPOS_1:52;
L5: ( 0 ) in ( dom ( Load R4 ) ) by COMPOS_1:50;
L6: ( card D1 ) = ( ( card R5 ) + 1 ) by SCMPDS_6:6;
L7: ( 0 ) < ( card D1 ) by L6 , NAT_1:5;
L8: (( card ( Load R3 ) ) = 1 & ( 0 ) in ( dom D1 )) by L7 , AFINSQ_1:66 , COMPOS_1:54;
thus L9: ( ( ( R3 ';' R4 ) ';' R5 ) . 1 ) = ( ( ( Load R3 ) ';' D1 ) . ( ( 0 ) + 1 ) ) by L2
.= ( D1 . ( 0 ) ) by L8 , AFINSQ_1:def 3
.= ( ( ( Load R4 ) ';' R5 ) . ( 0 ) ) by SCMPDS_4:def 2
.= ( ( Load R4 ) . ( 0 ) ) by L5 , AFINSQ_1:def 3
.= R4 by COMPOS_1:52;
end;
theorem
L10: (for B1 , B2 being Int_position holds (ex B3 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) st (for B4 being (State of ( SCMPDS )) holds ((( B4 . B1 ) = ( B4 . B2 ) implies ( B3 . B4 ) = ( 0 )) & (( B4 . B1 ) <> ( B4 . B2 ) implies ( B3 . B4 ) = ( max (( abs ( B4 . B1 ) ) , ( abs ( B4 . B2 ) )) ))))))
proof
let C1 , C2 being Int_position;
defpred S1[ set , set ] means (ex B5 being (State of ( SCMPDS )) st (B5 = $1 & (( B5 . C1 ) = ( B5 . C2 ) implies $2 = ( 0 )) & (( B5 . C1 ) <> ( B5 . C2 ) implies $2 = ( max (( abs ( B5 . C1 ) ) , ( abs ( B5 . C2 ) )) ))));
L11:
now
let C3 being (Element of ( product ( the_Values_of ( SCMPDS ) ) ));
per cases ;
suppose L12: ( C3 . C1 ) = ( C3 . C2 );

reconsider D2 = ( 0 ) as (Element of ( NAT ));
take D3 = D2;
thus L13: S1[ C3 , D3 ] by L12;
end;
suppose L14: ( C3 . C1 ) <> ( C3 . C2 );

set D4 = ( max (( abs ( C3 . C1 ) ) , ( abs ( C3 . C2 ) )) );
reconsider D5 = D4 as (Element of ( NAT )) by XXREAL_0:16;
take D6 = D5;
thus L15: S1[ C3 , D6 ] by L14;
end;
end;
consider C4 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L17: (for B6 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) holds S1[ B6 , ( C4 . B6 ) ]) from FUNCT_2:sch 3(L11);
L18: (for B7 being (State of ( SCMPDS )) holds S1[ B7 , ( C4 . B7 ) ])
proof
let C5 being (State of ( SCMPDS ));
reconsider D7 = C5 as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L19: S1[ D7 , ( C4 . D7 ) ] by L17;
thus L20: thesis by L19;
end;
take C4;
thus L21:now
let C6 being (State of ( SCMPDS ));
L22: S1[ C6 , ( C4 . C6 ) ] by L18;
thus L23: ((( C6 . C1 ) = ( C6 . C2 ) implies ( C4 . C6 ) = ( 0 )) & (( C6 . C1 ) <> ( C6 . C2 ) implies ( C4 . C6 ) = ( max (( abs ( C6 . C1 ) ) , ( abs ( C6 . C2 ) )) ))) by L22;
end;
end;
theorem
L22: (for R6 being Int_position holds (ex B8 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) st (for B9 being (State of ( SCMPDS )) holds ((( B9 . R6 ) >= ( 0 ) implies ( B8 . B9 ) = ( 0 )) & (( B9 . R6 ) < ( 0 ) implies ( B8 . B9 ) = ( - ( B9 . R6 ) ))))))
proof
let R6 being Int_position;
defpred S2[ set , set ] means (ex B10 being (State of ( SCMPDS )) st (B10 = $1 & (( B10 . R6 ) >= ( 0 ) implies $2 = ( 0 )) & (( B10 . R6 ) < ( 0 ) implies $2 = ( - ( B10 . R6 ) ))));
L23:
now
let C7 being (Element of ( product ( the_Values_of ( SCMPDS ) ) ));
per cases ;
suppose L24: ( C7 . R6 ) >= ( 0 );

reconsider D8 = ( 0 ) as (Element of ( NAT ));
take D9 = D8;
thus L25: S2[ C7 , D9 ] by L24;
end;
suppose L26: ( C7 . R6 ) < ( 0 );

L27: ( - ( C7 . R6 ) ) > ( 0 ) by L26 , XREAL_1:58;
reconsider D10 = ( - ( C7 . R6 ) ) as (Element of ( NAT )) by L27 , INT_1:3;
take D11 = D10;
thus L28: S2[ C7 , D11 ] by L26;
end;
end;
consider C8 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L30: (for B11 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) holds S2[ B11 , ( C8 . B11 ) ]) from FUNCT_2:sch 3(L23);
L31: (for B12 being (State of ( SCMPDS )) holds S2[ B12 , ( C8 . B12 ) ])
proof
let C9 being (State of ( SCMPDS ));
reconsider D12 = C9 as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L32: S2[ D12 , ( C8 . D12 ) ] by L30;
thus L33: thesis by L32;
end;
take C8;
thus L34:now
let C10 being (State of ( SCMPDS ));
L35: S2[ C10 , ( C8 . C10 ) ] by L31;
thus L36: ((( C10 . R6 ) >= ( 0 ) implies ( C8 . C10 ) = ( 0 )) & (( C10 . R6 ) < ( 0 ) implies ( C8 . C10 ) = ( - ( C10 . R6 ) ))) by L35;
end;
end;
set D13 = ( NAT );
set D14 = ( SCM-Data-Loc );
begin
scheme WhileLEnd { F1((State of ( SCMPDS ))) -> (Element of ( NAT )) , F2() -> ( 0 ) -started (State of ( SCMPDS )) , F3() -> (Instruction-Sequence of ( SCMPDS )) , F4() ->  halt-free  shiftable (Program of ( SCMPDS )) , F5() -> Int_position , F6() -> Integer , P1[set] } : (F1(( Initialize ( IExec (( while<0 (F5() , F6() , F4()) ) , F3() , F2()) ) )) = ( 0 ) & P1[ ( Initialize ( IExec (( while<0 (F5() , F6() , F4()) ) , F3() , F2()) ) ) ])
provided
L35: (for B13 being ( 0 ) -started (State of ( SCMPDS )) holds (P1[ B13 ] implies (F1(B13) = ( 0 ) iff ( B13 . ( DataLoc (( F2() . F5() ) , F6()) ) ) >= ( 0 ))))
and
L36: P1[ F2() ]
and
L37: (for B14 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P1[ B14 ] & ( B14 . F5() ) = ( F2() . F5() ) & ( B14 . ( DataLoc (( F2() . F5() ) , F6()) ) ) < ( 0 )) implies (( ( IExec (F4() , R7 , B14) ) . F5() ) = ( B14 . F5() ) & F4() is_closed_on B14 , R7 & F4() is_halting_on B14 , R7 & F1(( Initialize ( IExec (F4() , R7 , B14) ) )) < F1(B14) & P1[ ( Initialize ( IExec (F4() , R7 , B14) ) ) ]))))
proof
set D15 = ( DataLoc (( F2() . F5() ) , F6()) );
set D16 = ( while<0 (F5() , F6() , F4()) );
defpred S3[ (Element of ( NAT )) ] means (for B15 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((F1(B15) <= $1 & ( B15 . F5() ) = ( F2() . F5() ) & P1[ B15 ]) implies (F1(( Initialize ( IExec (D16 , R7 , B15) ) )) = ( 0 ) & P1[ ( Initialize ( IExec (D16 , R7 , B15) ) ) ]))));
L38: S3[ ( 0 ) ]
proof
let C11 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
L39: ( Initialize C11 ) = C11 by MEMSTR_0:44;
assume that
L40: F1(C11) <= ( 0 )
and
L41: ( C11 . F5() ) = ( F2() . F5() )
and
L42: P1[ C11 ];
L43: F1(C11) >= ( 0 ) by NAT_1:2;
L44: F1(C11) = ( 0 ) by L43 , L40 , XXREAL_0:1;
L45: ( C11 . ( DataLoc (( F2() . F5() ) , F6()) ) ) >= ( 0 ) by L44 , L35 , L42;
L46: (for B16 being Int_position holds ( ( IExec (D16 , R7 , C11) ) . B16 ) = ( C11 . B16 )) by L45 , L41 , SCMPDS_8:12;
thus L47: thesis by L46 , L42 , L44 , L39 , SCPISORT:4;
end;
L48:
now
let C12 being (Element of ( NAT ));
assume L49: S3[ C12 ];
L50:
now
let C13 being ( 0 ) -started (State of ( SCMPDS ));
let R8 being (Instruction-Sequence of ( SCMPDS ));
assume that
L51: F1(C13) <= ( C12 + 1 )
and
L52: ( C13 . F5() ) = ( F2() . F5() )
and
L53: P1[ C13 ];
per cases ;
suppose L54: F1(C13) = ( 0 );

thus L55: (F1(( Initialize ( IExec (D16 , R8 , C13) ) )) = ( 0 ) & P1[ ( Initialize ( IExec (D16 , R8 , C13) ) ) ]) by L54 , L38 , L52 , L53;
end;
suppose L56: F1(C13) <> ( 0 );

set D17 = ( IExec (F4() , R8 , C13) );
L57: ( C13 . D15 ) < ( 0 ) by L35 , L53 , L56;
L58: (( D17 . F5() ) = ( F2() . F5() ) & P1[ ( Initialize D17 ) ]) by L57 , L37 , L52 , L53;
deffunc H1((State of ( SCMPDS ))) = F1($1);
L59: P1[ C13 ] by L53;
L60: (for B17 being ( 0 ) -started (State of ( SCMPDS )) holds ((P1[ B17 ] & H1(B17) = ( 0 )) implies ( B17 . ( DataLoc (( C13 . F5() ) , F6()) ) ) >= ( 0 ))) by L35 , L52;
L61: H1(( Initialize D17 )) < H1(C13) by L37 , L52 , L53 , L57;
L62: ( H1(( Initialize D17 )) + 1 ) <= H1(C13) by L61 , INT_1:7;
L63: ( H1(( Initialize D17 )) + 1 ) <= ( C12 + 1 ) by L62 , L51 , XXREAL_0:2;
L64: H1(( Initialize D17 )) <= C12 by L63 , XREAL_1:6;
L65: (for B18 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P1[ B18 ] & ( B18 . F5() ) = ( C13 . F5() ) & ( B18 . ( DataLoc (( C13 . F5() ) , F6()) ) ) < ( 0 )) implies (( ( IExec (F4() , R7 , B18) ) . F5() ) = ( B18 . F5() ) & F4() is_closed_on B18 , R7 & F4() is_halting_on B18 , R7 & H1(( Initialize ( IExec (F4() , R7 , B18) ) )) < H1(B18) & P1[ ( Initialize ( IExec (F4() , R7 , B18) ) ) ])))) by L37 , L52;
L66: ( C13 . ( DataLoc (( C13 . F5() ) , F6()) ) ) < ( 0 ) by L35 , L52 , L53 , L56;
L67: ( IExec (D16 , R8 , C13) ) = ( IExec (D16 , R8 , ( Initialize D17 )) ) from SCMPDS_8:sch 2(L66 , L60 , L59 , L65);
L68: ( ( Initialize D17 ) . F5() ) = ( D17 . F5() ) by SCMPDS_5:15;
thus L69: (H1(( Initialize ( IExec (D16 , R8 , C13) ) )) = ( 0 ) & P1[ ( Initialize ( IExec (D16 , R8 , C13) ) ) ]) by L68 , L49 , L64 , L58 , L67;
end;
end;
thus L71: S3[ ( C12 + 1 ) ] by L50;
end;
L72: (for B19 being (Element of ( NAT )) holds S3[ B19 ]) from NAT_1:sch 1(L38 , L48);
L73: S3[ F1(F2()) ] by L72;
thus L74: thesis by L73 , L36;
end;
set D18 = ( intpos 1 );
set D19 = ( intpos 2 );
set D20 = ( intpos 3 );
begin
definition
let C14 , C15 being (Element of ( NAT ));
func sum (C14 , C15) -> (Program of ( SCMPDS )) equals 
( ( ( ( ( ( GBP ) := ( 0 ) ) ';' ( ( intpos 1 ) := ( 0 ) ) ) ';' ( ( intpos 2 ) := ( - C14 ) ) ) ';' ( ( intpos 3 ) := ( C15 + 1 ) ) ) ';' ( while<0 (( GBP ) , 2 , ( ( ( AddTo (( GBP ) , 1 , ( intpos 3 ) , ( 0 )) ) ';' ( AddTo (( GBP ) , 2 , 1) ) ) ';' ( AddTo (( GBP ) , 3 , 1) ) )) ) );
coherence;
end;
definition
let C16 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT ));
let C17 being (State of ( SCMPDS ));
redefine func C16 . C17 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
theorem
L77: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B20 being ( 0 ) -started (State of ( SCMPDS )) holds (for B21 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B22 , B23 , B24 being Int_position holds (for B25 , B26 , B27 being (Element of ( NAT )) holds (for B28 being (FinSequence of ( INT )) holds ((B28 is_FinSequence_on B20 , B27 & ( len B28 ) = B25 & ( B20 . B23 ) = ( 0 ) & ( B20 . B22 ) = ( 0 ) & ( B20 . ( intpos B26 ) ) = ( - B25 ) & ( B20 . B24 ) = ( B27 + 1 ) & (for B29 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds (((ex B30 being (FinSequence of ( INT )) st (B30 is_FinSequence_on B20 , B27 & ( len B30 ) = ( ( B29 . ( intpos B26 ) ) + B25 ) & ( B29 . B23 ) = ( Sum B30 ) & ( B29 . B24 ) = ( ( B27 + 1 ) + ( len B30 ) ))) & ( B29 . B22 ) = ( 0 ) & ( B29 . ( intpos B26 ) ) < ( 0 ) & (for B31 being (Element of ( NAT )) holds (B31 > B27 implies ( B29 . ( intpos B31 ) ) = ( B20 . ( intpos B31 ) )))) implies (( ( IExec (B21 , R7 , B29) ) . B22 ) = ( 0 ) & B21 is_closed_on B29 , R7 & B21 is_halting_on B29 , R7 & ( ( IExec (B21 , R7 , B29) ) . ( intpos B26 ) ) = ( ( B29 . ( intpos B26 ) ) + 1 ) & (ex B32 being (FinSequence of ( INT )) st (B32 is_FinSequence_on B20 , B27 & ( len B32 ) = ( ( ( B29 . ( intpos B26 ) ) + B25 ) + 1 ) & ( ( IExec (B21 , R7 , B29) ) . B24 ) = ( ( B27 + 1 ) + ( len B32 ) ) & ( ( IExec (B21 , R7 , B29) ) . B23 ) = ( Sum B32 ))) & (for B33 being (Element of ( NAT )) holds (B33 > B27 implies ( ( IExec (B21 , R7 , B29) ) . ( intpos B33 ) ) = ( B20 . ( intpos B33 ) )))))))) implies (( ( IExec (( while<0 (B22 , B26 , B21) ) , R9 , B20) ) . B23 ) = ( Sum B28 ) & ( while<0 (B22 , B26 , B21) ) is_closed_on B20 , R9 & ( while<0 (B22 , B26 , B21) ) is_halting_on B20 , R9))))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C18 being ( 0 ) -started (State of ( SCMPDS ));
let C19 being  halt-free  shiftable (Program of ( SCMPDS ));
let C20 , C21 , C22 being Int_position;
let C23 , C24 , C25 being (Element of ( NAT ));
let C26 being (FinSequence of ( INT ));
set D21 = ( IExec (( while<0 (C20 , C24 , C19) ) , R9 , C18) );
set D22 = ( Initialize D21 );
set D23 = ( DataLoc (( C18 . C20 ) , C24) );
defpred S4[ (State of ( SCMPDS )) ] means ((for B34 being (Element of ( NAT )) holds (B34 > C25 implies ( $1 . ( intpos B34 ) ) = ( C18 . ( intpos B34 ) ))) & (ex B35 being (FinSequence of ( INT )) st (B35 is_FinSequence_on C18 , C25 & ( len B35 ) = ( ( $1 . ( intpos C24 ) ) + C23 ) & ( $1 . C21 ) = ( Sum B35 ) & ( $1 . ( intpos C24 ) ) <= ( 0 ) & ( $1 . C22 ) = ( ( C25 + 1 ) + ( len B35 ) ))));
assume that
L78: C26 is_FinSequence_on C18 , C25
and
L79: ( len C26 ) = C23
and
L80: ( C18 . C21 ) = ( 0 )
and
L81: ( C18 . C20 ) = ( 0 )
and
L82: ( C18 . ( intpos C24 ) ) = ( - C23 )
and
L83: ( C18 . C22 ) = ( C25 + 1 );
consider C27 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L84: (for B36 being (State of ( SCMPDS )) holds ((( B36 . D23 ) >= ( 0 ) implies ( C27 . B36 ) = ( 0 )) & (( B36 . D23 ) < ( 0 ) implies ( C27 . B36 ) = ( - ( B36 . D23 ) )))) by L22;
deffunc H2((State of ( SCMPDS ))) = ( C27 . $1 );
assume L85: (for B37 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds (((ex B38 being (FinSequence of ( INT )) st (B38 is_FinSequence_on C18 , C25 & ( len B38 ) = ( ( B37 . ( intpos C24 ) ) + C23 ) & ( B37 . C21 ) = ( Sum B38 ) & ( B37 . C22 ) = ( ( C25 + 1 ) + ( len B38 ) ))) & ( B37 . C20 ) = ( 0 ) & ( B37 . ( intpos C24 ) ) < ( 0 ) & (for B39 being (Element of ( NAT )) holds (B39 > C25 implies ( B37 . ( intpos B39 ) ) = ( C18 . ( intpos B39 ) )))) implies (( ( IExec (C19 , R7 , B37) ) . C20 ) = ( 0 ) & C19 is_closed_on B37 , R7 & C19 is_halting_on B37 , R7 & ( ( IExec (C19 , R7 , B37) ) . ( intpos C24 ) ) = ( ( B37 . ( intpos C24 ) ) + 1 ) & (ex B40 being (FinSequence of ( INT )) st (B40 is_FinSequence_on C18 , C25 & ( len B40 ) = ( ( ( B37 . ( intpos C24 ) ) + C23 ) + 1 ) & ( ( IExec (C19 , R7 , B37) ) . C22 ) = ( ( C25 + 1 ) + ( len B40 ) ) & ( ( IExec (C19 , R7 , B37) ) . C21 ) = ( Sum B40 ))) & (for B41 being (Element of ( NAT )) holds (B41 > C25 implies ( ( IExec (C19 , R7 , B37) ) . ( intpos B41 ) ) = ( C18 . ( intpos B41 ) )))))));
L86: (for B42 being ( 0 ) -started (State of ( SCMPDS )) holds (S4[ B42 ] implies (((H2(B42) = ( 0 ) & ( B42 . D23 ) < ( 0 )) implies contradiction) & (( B42 . D23 ) >= ( 0 ) implies H2(B42) = ( 0 )))))
proof
let C28 being ( 0 ) -started (State of ( SCMPDS ));
assume L87: S4[ C28 ];
thus L88:now
assume L89: H2(C28) = ( 0 );
assume L90: ( C28 . D23 ) < ( 0 );
L91: ( C28 . D23 ) < ( 0 ) by L90;
L92: H2(C28) = ( - ( C28 . D23 ) ) by L91 , L84;
thus L93: contradiction by L92 , L89 , L90;
end;
assume L94: ( C28 . D23 ) >= ( 0 );
L95: ( C28 . D23 ) >= ( 0 ) by L94;
thus L96: H2(C28) = ( 0 ) by L95 , L84;
end;
L97:
now
let C29 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
assume that
L98: S4[ C29 ]
and
L99: ( C29 . C20 ) = ( C18 . C20 )
and
L100: ( C29 . ( DataLoc (( C18 . C20 ) , C24) ) ) < ( 0 );
consider C30 being (FinSequence of ( INT )) such that L101: C30 is_FinSequence_on C18 , C25 and L102: (( len C30 ) = ( ( C29 . ( intpos C24 ) ) + C23 ) & ( C29 . C21 ) = ( Sum C30 )) and L103: ( C29 . C22 ) = ( ( C25 + 1 ) + ( len C30 ) ) by L98;
L104: ( C29 . C22 ) = ( ( C25 + 1 ) + ( len C30 ) ) by L103;
set D24 = ( IExec (C19 , R7 , C29) );
set D25 = ( Initialize D24 );
L105: (for B43 being (Element of ( NAT )) holds (B43 > C25 implies ( C29 . ( intpos B43 ) ) = ( C18 . ( intpos B43 ) ))) by L98;
L106: ( intpos ( ( 0 ) + C24 ) ) = D23 by L81 , SCMP_GCD:1;
L107: (( len C30 ) = ( ( C29 . ( intpos C24 ) ) + C23 ) & ( C29 . C21 ) = ( Sum C30 )) by L102;
thus L108: ( ( IExec (C19 , R7 , C29) ) . C20 ) = ( C29 . C20 ) by L107 , L81 , L85 , L99 , L100 , L105 , L101 , L104 , L106;
consider C31 being (FinSequence of ( INT )) such that L109: C31 is_FinSequence_on C18 , C25 and L110: ( len C31 ) = ( ( ( C29 . ( intpos C24 ) ) + C23 ) + 1 ) and L111: ( ( IExec (C19 , R7 , C29) ) . C22 ) = ( ( C25 + 1 ) + ( len C31 ) ) and L112: ( ( IExec (C19 , R7 , C29) ) . C21 ) = ( Sum C31 ) by L81 , L85 , L99 , L100 , L105 , L101 , L107 , L104 , L106;
thus L113: (C19 is_closed_on C29 , R7 & C19 is_halting_on C29 , R7) by L81 , L85 , L99 , L100 , L105 , L101 , L107 , L104 , L106;
L114: ( D24 . ( intpos C24 ) ) = ( ( C29 . ( intpos C24 ) ) + 1 ) by L81 , L85 , L99 , L100 , L105 , L101 , L107 , L104 , L106;
thus L115:now
per cases ;
suppose L116: ( D24 . ( intpos C24 ) ) >= ( 0 );

L117: ( D25 . D23 ) >= ( 0 ) by L116 , L106 , SCMPDS_5:15;
L118: H2(D25) = ( 0 ) by L117 , L84;
L119: H2(C29) <> ( 0 ) by L86 , L98 , L100;
thus L120: H2(D25) < H2(C29) by L119 , L118 , NAT_1:3;
end;
suppose L121: ( D24 . ( intpos C24 ) ) < ( 0 );

L122: ( C29 . D23 ) < ( 0 ) by L100;
L123: H2(C29) = ( - ( C29 . D23 ) ) by L122 , L84
.= ( - ( C29 . ( intpos C24 ) ) ) by L106;
L124: ( D25 . D23 ) < ( 0 ) by L106 , L121 , SCMPDS_5:15;
L125: H2(D25) = ( - ( D25 . D23 ) ) by L124 , L84
.= ( - ( ( C29 . ( intpos C24 ) ) + 1 ) ) by L106 , L114 , SCMPDS_5:15
.= ( ( - ( C29 . ( intpos C24 ) ) ) - 1 );
thus L126: H2(D25) < H2(C29) by L125 , L123 , XREAL_1:146;
end;
end;
thus L128: S4[ ( Initialize ( IExec (C19 , R7 , C29) ) ) ]
proof
thus L129:now
let C32 being (Element of ( NAT ));
assume L130: C32 > C25;
thus L131: ( D25 . ( intpos C32 ) ) = ( D24 . ( intpos C32 ) ) by SCMPDS_5:15
.= ( C18 . ( intpos C32 ) ) by L81 , L85 , L99 , L100 , L105 , L101 , L107 , L104 , L106 , L130;
end;
take C31;
thus L132: C31 is_FinSequence_on C18 , C25 by L109;
thus L133: ( len C31 ) = ( ( ( IExec (C19 , R7 , C29) ) . ( intpos C24 ) ) + C23 ) by L114 , L110
.= ( ( D25 . ( intpos C24 ) ) + C23 ) by SCMPDS_5:15;
thus L134: ( D25 . C21 ) = ( Sum C31 ) by L112 , SCMPDS_5:15;
L135: ( D25 . ( intpos C24 ) ) = ( ( C29 . ( intpos C24 ) ) + 1 ) by L114 , SCMPDS_5:15;
thus L136: ( D25 . ( intpos C24 ) ) <= ( 0 ) by L135 , L100 , L106 , INT_1:7;
thus L137: thesis by L111 , SCMPDS_5:15;
end;

end;
L129: S4[ C18 ]
proof
thus L130: (for B44 being (Element of ( NAT )) holds (B44 > C25 implies ( C18 . ( intpos B44 ) ) = ( C18 . ( intpos B44 ) )));
consider C33 being (FinSequence of ( INT )) such that L131: ( len C33 ) = ( 0 ) and L132: C33 is_FinSequence_on C18 , C25 by SCPISORT:2;
take C33;
thus L133: C33 is_FinSequence_on C18 , C25 by L132;
thus L134: ( len C33 ) = ( ( C18 . ( intpos C24 ) ) + C23 ) by L82 , L131
.= ( ( C18 . ( intpos C24 ) ) + C23 );
L135: C33 = ( <*> ( REAL ) ) by L131;
thus L136: ( C18 . C21 ) = ( Sum C33 ) by L135 , L80 , RVSUM_1:72;
thus L137: ( C18 . ( intpos C24 ) ) <= ( 0 ) by L82;
thus L138: thesis by L83 , L131;
end;
L139: (H2(D22) = ( 0 ) & S4[ D22 ]) from WhileLEnd(L86 , L129 , L97);
consider C34 being (FinSequence of ( INT )) such that L140: C34 is_FinSequence_on C18 , C25 and L141: ( len C34 ) = ( ( D22 . ( intpos C24 ) ) + C23 ) and L142: ( D22 . C21 ) = ( Sum C34 ) and L143: ( D22 . ( intpos C24 ) ) <= ( 0 ) by L139;
L144: ( D22 . ( intpos C24 ) ) = ( D21 . ( intpos ( ( 0 ) + C24 ) ) ) by SCMPDS_5:15
.= ( D21 . D23 ) by L81 , SCMP_GCD:1;
L145: ( D21 . D23 ) = ( D22 . D23 ) by SCMPDS_5:15;
L146: ( D22 . ( intpos C24 ) ) >= ( 0 ) by L145 , L86 , L139 , L144;
L147: ( D22 . ( intpos C24 ) ) = ( 0 ) by L146 , L143 , XXREAL_0:1;
L148:
now
let C35 being Nat;
reconsider D26 = C35 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L149: C35 in ( dom C26 );
L150: (1 <= C35 & C35 <= C23) by L149 , L79 , FINSEQ_3:25;
thus L151: ( C26 . C35 ) = ( C18 . ( intpos ( C25 + D26 ) ) ) by L150 , L78 , L79 , SCPISORT:def 1
.= ( C34 . C35 ) by L140 , L141 , L147 , L150 , SCPISORT:def 1;
end;
L152: C26 = C34 by L148 , L79 , L141 , L147 , FINSEQ_2:9;
thus L153: ( D21 . C21 ) = ( Sum C26 ) by L152 , L142 , SCMPDS_5:15;
L154: (for B45 being ( 0 ) -started (State of ( SCMPDS )) holds ((S4[ B45 ] & H2(B45) = ( 0 )) implies ( B45 . D23 ) >= ( 0 ))) by L86;
L155: (( while<0 (C20 , C24 , C19) ) is_closed_on C18 , R9 & ( while<0 (C20 , C24 , C19) ) is_halting_on C18 , R9) from SCMPDS_8:sch 1(L154 , L129 , L97);
thus L156: thesis by L155;
end;
set D27 = ( AddTo (( GBP ) , 1 , D20 , ( 0 )) );
set D28 = ( AddTo (( GBP ) , 2 , 1) );
set D29 = ( AddTo (( GBP ) , 3 , 1) );
set D30 = ( ( D27 ';' D28 ) ';' D29 );
set D31 = ( while<0 (( GBP ) , 2 , D30) );
L157: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B46 being ( 0 ) -started (State of ( SCMPDS )) holds (for B47 being (Element of ( NAT )) holds ((( B46 . ( GBP ) ) = ( 0 ) & ( B46 . D20 ) = B47) implies (( ( IExec (D30 , R9 , ( Initialize B46 )) ) . ( GBP ) ) = ( 0 ) & ( ( IExec (D30 , R9 , ( Initialize B46 )) ) . D18 ) = ( ( B46 . D18 ) + ( B46 . ( intpos B47 ) ) ) & ( ( IExec (D30 , R9 , ( Initialize B46 )) ) . D19 ) = ( ( B46 . D19 ) + 1 ) & ( ( IExec (D30 , R9 , ( Initialize B46 )) ) . D20 ) = ( B47 + 1 ) & (for B48 being (Element of ( NAT )) holds (B48 > 3 implies ( ( IExec (D30 , R9 , ( Initialize B46 )) ) . ( intpos B48 ) ) = ( B46 . ( intpos B48 ) ))))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
set D32 = ( GBP );
let C36 being ( 0 ) -started (State of ( SCMPDS ));
let C37 being (Element of ( NAT ));
assume that
L158: ( C36 . D32 ) = ( 0 )
and
L159: ( C36 . D20 ) = C37;
set D33 = ( Initialize C36 );
set D34 = ( IExec (D30 , R9 , ( Initialize C36 )) );
set D35 = ( IExec (( D27 ';' D28 ) , R9 , ( Initialize C36 )) );
set D36 = ( Exec (D27 , D33) );
L160: ( D33 . D20 ) = C37 by L159 , SCMPDS_5:15;
L161: ( D33 . D32 ) = ( 0 ) by L158 , SCMPDS_5:15;
L162: ( 0 ) <> ( abs ( ( D33 . ( GBP ) ) + 1 ) ) by L161 , ABSVALUE:def 1;
L163: D32 <> ( DataLoc (( D33 . ( GBP ) ) , 1) ) by L162 , XTUPLE_0:1;
L164: ( D36 . D32 ) = ( 0 ) by L163 , L161 , SCMPDS_2:49;
L165: ( 0 ) <> ( abs ( ( D36 . ( GBP ) ) + 2 ) ) by L164 , ABSVALUE:def 1;
L166: D32 <> ( DataLoc (( D36 . ( GBP ) ) , 2) ) by L165 , XTUPLE_0:1;
L167: 3 <> ( abs ( ( D33 . ( GBP ) ) + 1 ) ) by L161 , ABSVALUE:def 1;
L168: D20 <> ( DataLoc (( D33 . ( GBP ) ) , 1) ) by L167 , XTUPLE_0:1;
L169: ( D36 . D20 ) = C37 by L168 , L160 , SCMPDS_2:49;
L170: 3 <> ( abs ( ( D36 . ( GBP ) ) + 2 ) ) by L164 , ABSVALUE:def 1;
L171: D20 <> ( DataLoc (( D36 . ( GBP ) ) , 2) ) by L170 , XTUPLE_0:1;
L172: ( D35 . D20 ) = ( ( Exec (D28 , D36) ) . D20 ) by SCMPDS_5:42
.= C37 by L169 , L171 , SCMPDS_2:48;
L173: ( D33 . D18 ) = ( C36 . D18 ) by SCMPDS_5:15;
L174: ( DataLoc (( D33 . D32 ) , 1) ) = ( intpos ( ( 0 ) + 1 ) ) by L161 , SCMP_GCD:1;
L175: ( D36 . D18 ) = ( ( D33 . D18 ) + ( D33 . ( DataLoc (( D33 . D20 ) , ( 0 )) ) ) ) by L174 , SCMPDS_2:49
.= ( ( D33 . D18 ) + ( D33 . ( intpos ( C37 + ( 0 ) ) ) ) ) by L160 , SCMP_GCD:1
.= ( ( C36 . D18 ) + ( C36 . ( intpos C37 ) ) ) by L173 , SCMPDS_5:15;
L176: 1 <> ( abs ( ( D36 . ( GBP ) ) + 2 ) ) by L164 , ABSVALUE:def 1;
L177: D18 <> ( DataLoc (( D36 . ( GBP ) ) , 2) ) by L176 , XTUPLE_0:1;
L178: ( DataLoc (( D36 . D32 ) , 2) ) = ( intpos ( ( 0 ) + 2 ) ) by L164 , SCMP_GCD:1;
L179: ( abs ( ( D36 . D32 ) + 2 ) ) = ( ( 0 ) + 2 ) by L178 , XTUPLE_0:1;
L180: 2 <> ( abs ( ( D33 . ( GBP ) ) + 1 ) ) by L161 , ABSVALUE:def 1;
L181: D19 <> ( DataLoc (( D33 . ( GBP ) ) , 1) ) by L180 , XTUPLE_0:1;
L182: ( D36 . D19 ) = ( D33 . D19 ) by L181 , SCMPDS_2:49
.= ( C36 . D19 ) by SCMPDS_5:15;
L183: ( D35 . D32 ) = ( ( Exec (D28 , D36) ) . D32 ) by SCMPDS_5:42
.= ( 0 ) by L164 , L166 , SCMPDS_2:48;
L184: ( DataLoc (( D35 . D32 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L183 , SCMP_GCD:1;
L185: ( D35 . D19 ) = ( ( Exec (D28 , D36) ) . D19 ) by SCMPDS_5:42
.= ( ( C36 . D19 ) + 1 ) by L182 , L178 , SCMPDS_2:48;
L186: ( D35 . D18 ) = ( ( Exec (D28 , D36) ) . D18 ) by SCMPDS_5:42
.= ( ( C36 . D18 ) + ( C36 . ( intpos C37 ) ) ) by L175 , L177 , SCMPDS_2:48;
L187: ( 0 ) <> ( abs ( ( D35 . ( GBP ) ) + 3 ) ) by L183 , ABSVALUE:def 1;
L188: D32 <> ( DataLoc (( D35 . ( GBP ) ) , 3) ) by L187 , XTUPLE_0:1;
thus L189: ( D34 . D32 ) = ( ( Exec (D29 , D35) ) . D32 ) by SCMPDS_5:41
.= ( 0 ) by L183 , L188 , SCMPDS_2:48;
L190: 1 <> ( abs ( ( D35 . ( GBP ) ) + 3 ) ) by L183 , ABSVALUE:def 1;
L191: D18 <> ( DataLoc (( D35 . ( GBP ) ) , 3) ) by L190 , XTUPLE_0:1;
thus L192: ( D34 . D18 ) = ( ( Exec (D29 , D35) ) . D18 ) by SCMPDS_5:41
.= ( ( C36 . D18 ) + ( C36 . ( intpos C37 ) ) ) by L186 , L191 , SCMPDS_2:48;
L193: 2 <> ( abs ( ( D35 . ( GBP ) ) + 3 ) ) by L183 , ABSVALUE:def 1;
L194: D19 <> ( DataLoc (( D35 . ( GBP ) ) , 3) ) by L193 , XTUPLE_0:1;
thus L195: ( D34 . D19 ) = ( ( Exec (D29 , D35) ) . D19 ) by SCMPDS_5:41
.= ( ( C36 . D19 ) + 1 ) by L185 , L194 , SCMPDS_2:48;
thus L196: ( D34 . D20 ) = ( ( Exec (D29 , D35) ) . D20 ) by SCMPDS_5:41
.= ( C37 + 1 ) by L172 , L184 , SCMPDS_2:48;
L197: ( abs ( ( D33 . D32 ) + 1 ) ) = ( ( 0 ) + 1 ) by L174 , XTUPLE_0:1;
thus L198:now
let C38 being (Element of ( NAT ));
assume L199: C38 > 3;
L200: ( intpos C38 ) <> ( DataLoc (( D35 . D32 ) , 3) ) by L199 , L184 , XTUPLE_0:1;
L201: C38 <> ( abs ( ( D33 . D32 ) + 1 ) ) by L197 , L199;
L202: ( intpos C38 ) <> ( DataLoc (( D33 . D32 ) , 1) ) by L201 , XTUPLE_0:1;
L203: C38 <> ( abs ( ( D36 . D32 ) + 2 ) ) by L179 , L199;
L204: ( intpos C38 ) <> ( DataLoc (( D36 . D32 ) , 2) ) by L203 , XTUPLE_0:1;
thus L205: ( D34 . ( intpos C38 ) ) = ( ( Exec (D29 , D35) ) . ( intpos C38 ) ) by SCMPDS_5:41
.= ( D35 . ( intpos C38 ) ) by L200 , SCMPDS_2:48
.= ( ( Exec (D28 , D36) ) . ( intpos C38 ) ) by SCMPDS_5:42
.= ( D36 . ( intpos C38 ) ) by L204 , SCMPDS_2:48
.= ( D33 . ( intpos C38 ) ) by L202 , SCMPDS_2:49
.= ( C36 . ( intpos C38 ) ) by SCMPDS_5:15;
end;
end;
L199: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B49 being ( 0 ) -started (State of ( SCMPDS )) holds (for B50 , B51 being (Element of ( NAT )) holds (for B52 being (FinSequence of ( INT )) holds ((B51 >= 3 & B52 is_FinSequence_on B49 , B51 & ( len B52 ) = B50 & ( B49 . D18 ) = ( 0 ) & ( B49 . ( GBP ) ) = ( 0 ) & ( B49 . D19 ) = ( - B50 ) & ( B49 . D20 ) = ( B51 + 1 )) implies (( ( IExec (D31 , R9 , ( Initialize B49 )) ) . D18 ) = ( Sum B52 ) & D31 is_closed_on B49 , R9 & D31 is_halting_on B49 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C39 being ( 0 ) -started (State of ( SCMPDS ));
let C40 , C41 being (Element of ( NAT ));
let C42 being (FinSequence of ( INT ));
set D37 = ( GBP );
L200: ( Initialize C39 ) = C39 by MEMSTR_0:44;
assume that
L201: C41 >= 3
and
L202: (C42 is_FinSequence_on C39 , C41 & ( len C42 ) = C40 & ( C39 . D18 ) = ( 0 ) & ( C39 . D37 ) = ( 0 ) & ( C39 . D19 ) = ( - C40 ) & ( C39 . D20 ) = ( C41 + 1 ));
L203:
now
let C43 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
L204: ( Initialize C43 ) = C43 by MEMSTR_0:44;
given C44 being (FinSequence of ( INT )) such that
L205: C44 is_FinSequence_on C39 , C41
and
L206: ( len C44 ) = ( ( C43 . D19 ) + C40 )
and
L207: ( C43 . D18 ) = ( Sum C44 )
and
L208: ( C43 . D20 ) = ( ( C41 + 1 ) + ( len C44 ) );

assume that
L209: ( C43 . D37 ) = ( 0 )
and
L210: ( C43 . D19 ) < ( 0 );
assume L211: (for B53 being (Element of ( NAT )) holds (B53 > C41 implies ( C43 . ( intpos B53 ) ) = ( C39 . ( intpos B53 ) )));
thus L212: ( ( IExec (D30 , R7 , C43) ) . D37 ) = ( 0 ) by L208 , L209 , L157 , L204;
thus L213: (D30 is_closed_on C43 , R7 & D30 is_halting_on C43 , R7) by SCMPDS_6:20 , SCMPDS_6:21;
thus L214: ( ( IExec (D30 , R7 , C43) ) . D19 ) = ( ( C43 . D19 ) + 1 ) by L208 , L209 , L157 , L204;
thus L215: (ex B54 being (FinSequence of ( INT )) st (B54 is_FinSequence_on C39 , C41 & ( len B54 ) = ( ( ( C43 . D19 ) + C40 ) + 1 ) & ( ( IExec (D30 , R7 , C43) ) . D20 ) = ( ( C41 + 1 ) + ( len B54 ) ) & ( ( IExec (D30 , R7 , C43) ) . D18 ) = ( Sum B54 )))
proof
consider C45 being (FinSequence of ( INT )) such that L216: ( len C45 ) = ( ( len C44 ) + 1 ) and L217: C45 is_FinSequence_on C39 , C41 by SCPISORT:2;
take C45;
thus L218: C45 is_FinSequence_on C39 , C41 by L217;
thus L219: ( len C45 ) = ( ( ( C43 . D19 ) + C40 ) + 1 ) by L206 , L216;
thus L220: ( ( IExec (D30 , R7 , C43) ) . D20 ) = ( ( ( C41 + 1 ) + ( len C44 ) ) + 1 ) by L208 , L209 , L157 , L204
.= ( ( C41 + 1 ) + ( len C45 ) ) by L216;
L221: ( C41 + 1 ) > C41 by XREAL_1:29;
set D38 = ( len C45 );
L222: D38 >= 1 by L216 , NAT_1:11;
L223: ( C41 + D38 ) >= ( C41 + 1 ) by L222 , XREAL_1:6;
L224: ( C41 + D38 ) > C41 by L223 , L221 , XXREAL_0:2;
reconsider D39 = ( C45 . D38 ) as (Element of ( INT )) by INT_1:def 2;
L225:
now
let C46 being Nat;
L226: C46 in ( NAT ) by ORDINAL1:def 12;
assume that
L227: 1 <= C46
and
L228: C46 <= ( len C45 );
per cases ;
suppose L229: C46 = ( len C45 );

thus L230: ( C45 . C46 ) = ( ( C44 ^ <* D39 *> ) . C46 ) by L229 , L216 , FINSEQ_1:42;
end;
suppose L231: C46 <> ( len C45 );

L232: C46 < ( len C45 ) by L231 , L228 , XXREAL_0:1;
L233: C46 <= ( len C44 ) by L232 , L216 , INT_1:7;
L234: C46 in ( Seg ( len C44 ) ) by L233 , L227 , FINSEQ_1:1;
L235: C46 in ( dom C44 ) by L234 , FINSEQ_1:def 3;
thus L236: ( C45 . C46 ) = ( C39 . ( intpos ( C41 + C46 ) ) ) by L217 , L226 , L227 , L228 , SCPISORT:def 1
.= ( C44 . C46 ) by L205 , L226 , L227 , L233 , SCPISORT:def 1
.= ( ( C44 ^ <* D39 *> ) . C46 ) by L235 , FINSEQ_1:def 7;
end;
end;
L238: ( len ( C44 ^ <* D39 *> ) ) = ( len C45 ) by L216 , FINSEQ_2:16;
L239: ( C44 ^ <* D39 *> ) = C45 by L238 , L225 , FINSEQ_1:14;
L240: ( C45 . D38 ) = ( C39 . ( intpos ( C41 + D38 ) ) ) by L217 , L222 , SCPISORT:def 1
.= ( C43 . ( intpos ( ( C41 + 1 ) + ( len C44 ) ) ) ) by L211 , L216 , L224;
thus L241: ( ( IExec (D30 , R7 , C43) ) . D18 ) = ( ( C43 . D18 ) + ( C45 . D38 ) ) by L240 , L208 , L209 , L157 , L204
.= ( Sum C45 ) by L207 , L239 , RVSUM_1:74;
end;

thus L242:now
let C47 being (Element of ( NAT ));
assume L243: C47 > C41;
L244: C47 > 3 by L243 , L201 , XXREAL_0:2;
thus L245: ( ( IExec (D30 , R7 , C43) ) . ( intpos C47 ) ) = ( C43 . ( intpos C47 ) ) by L244 , L208 , L209 , L157 , L204
.= ( C39 . ( intpos C47 ) ) by L211 , L243;
end;
end;
thus L243: thesis by L203 , L202 , L77 , L200;
end;
L244: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B55 being ( 0 ) -started (State of ( SCMPDS )) holds (for B56 , B57 being (Element of ( NAT )) holds (for B58 being (FinSequence of ( INT )) holds ((B57 >= 3 & B58 is_FinSequence_on B55 , B57 & ( len B58 ) = B56) implies (( ( IExec (( sum (B56 , B57) ) , R9 , B55) ) . D18 ) = ( Sum B58 ) & ( sum (B56 , B57) ) is_halting_on B55 , R9))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C48 being ( 0 ) -started (State of ( SCMPDS ));
let C49 , C50 being (Element of ( NAT ));
let C51 being (FinSequence of ( INT ));
L245: ( Initialize C48 ) = C48 by MEMSTR_0:44;
assume that
L246: C50 >= 3
and
L247: C51 is_FinSequence_on C48 , C50
and
L248: ( len C51 ) = C49;
set D40 = ( GBP );
set D41 = ( D40 := ( 0 ) );
set D42 = ( D18 := ( 0 ) );
set D43 = ( D19 := ( - C49 ) );
set D44 = ( D20 := ( C50 + 1 ) );
set D45 = ( Initialize C48 );
set D46 = ( ( ( D41 ';' D42 ) ';' D43 ) ';' D44 );
set D47 = ( IExec (D46 , R9 , ( Initialize C48 )) );
set D48 = R9;
set D49 = ( IExec (( ( D41 ';' D42 ) ';' D43 ) , R9 , ( Initialize C48 )) );
set D50 = ( IExec (( D41 ';' D42 ) , R9 , ( Initialize C48 )) );
set D51 = ( Exec (D41 , D45) );
L249:
now
let C52 being (Element of ( NAT ));
assume that
L250: 1 <= C52
and
L251: C52 <= ( len C51 );
L252: ( C50 + 1 ) >= ( 3 + 1 ) by L246 , XREAL_1:6;
L253: ( C50 + C52 ) >= ( C50 + 1 ) by L250 , XREAL_1:6;
L254: ( C50 + C52 ) <> 3 by L253 , L252 , XXREAL_0:2;
L255: ( intpos ( C50 + C52 ) ) <> D20 by L254 , XTUPLE_0:1;
L256: ( C50 + C52 ) <> ( 0 ) by L252 , L253 , XXREAL_0:2;
L257: ( intpos ( C50 + C52 ) ) <> D40 by L256 , XTUPLE_0:1;
L258: ( C50 + C52 ) <> 1 by L252 , L253 , XXREAL_0:2;
L259: ( intpos ( C50 + C52 ) ) <> D18 by L258 , XTUPLE_0:1;
L260: ( C50 + C52 ) <> 2 by L252 , L253 , XXREAL_0:2;
L261: ( intpos ( C50 + C52 ) ) <> D19 by L260 , XTUPLE_0:1;
thus L262: ( D47 . ( intpos ( C50 + C52 ) ) ) = ( ( Exec (D44 , D49) ) . ( intpos ( C50 + C52 ) ) ) by SCMPDS_5:41
.= ( D49 . ( intpos ( C50 + C52 ) ) ) by L255 , SCMPDS_2:45
.= ( ( Exec (D43 , D50) ) . ( intpos ( C50 + C52 ) ) ) by SCMPDS_5:41
.= ( D50 . ( intpos ( C50 + C52 ) ) ) by L261 , SCMPDS_2:45
.= ( ( Exec (D42 , D51) ) . ( intpos ( C50 + C52 ) ) ) by SCMPDS_5:42
.= ( D51 . ( intpos ( C50 + C52 ) ) ) by L259 , SCMPDS_2:45
.= ( D45 . ( intpos ( C50 + C52 ) ) ) by L257 , SCMPDS_2:45
.= ( C48 . ( intpos ( C50 + C52 ) ) ) by SCMPDS_5:15
.= ( C51 . C52 ) by L247 , L250 , L251 , SCPISORT:def 1;
end;
L263: C51 is_FinSequence_on D47 , C50 by L249 , SCPISORT:def 1;
L264: C51 is_FinSequence_on ( Initialize D47 ) , C50
proof
let C53 being (Element of ( NAT ));
assume L265: (1 <= C53 & C53 <= ( len C51 ));
L266: ( C51 . C53 ) = ( D47 . ( intpos ( C50 + C53 ) ) ) by L265 , L263 , SCPISORT:def 1;
thus L267: thesis by L266 , SCMPDS_5:15;
end;
L268: ( D51 . D40 ) = ( 0 ) by SCMPDS_2:45;
L269: ( D50 . D40 ) = ( ( Exec (D42 , D51) ) . D40 ) by SCMPDS_5:42
.= ( 0 ) by L268 , AMI_3:10 , SCMPDS_2:45;
L270: ( D49 . D40 ) = ( ( Exec (D43 , D50) ) . D40 ) by SCMPDS_5:41
.= ( 0 ) by L269 , AMI_3:10 , SCMPDS_2:45;
L271: ( D47 . D20 ) = ( ( Exec (D44 , D49) ) . D20 ) by SCMPDS_5:41
.= ( C50 + 1 ) by SCMPDS_2:45;
L272: ( ( Initialize D47 ) . D20 ) = ( D47 . D20 ) by SCMPDS_5:15;
L273: ( D50 . D18 ) = ( ( Exec (D42 , D51) ) . D18 ) by SCMPDS_5:42
.= ( 0 ) by SCMPDS_2:45;
L274: ( D49 . D18 ) = ( ( Exec (D43 , D50) ) . D18 ) by SCMPDS_5:41
.= ( 0 ) by L273 , AMI_3:10 , SCMPDS_2:45;
L275: ( ( Initialize D47 ) . D18 ) = ( D47 . D18 ) by SCMPDS_5:15;
L276: ( D47 . D18 ) = ( ( Exec (D44 , D49) ) . D18 ) by SCMPDS_5:41
.= ( 0 ) by L274 , AMI_3:10 , SCMPDS_2:45;
L277: ( D49 . D19 ) = ( ( Exec (D43 , D50) ) . D19 ) by SCMPDS_5:41
.= ( - C49 ) by SCMPDS_2:45;
L278: ( ( Initialize D47 ) . D19 ) = ( D47 . D19 ) by SCMPDS_5:15;
L279: ( ( Initialize D47 ) . D40 ) = ( D47 . D40 ) by SCMPDS_5:15;
L280: ( D47 . D19 ) = ( ( Exec (D44 , D49) ) . D19 ) by SCMPDS_5:41
.= ( - C49 ) by L277 , AMI_3:10 , SCMPDS_2:45;
L281: ( D47 . D40 ) = ( ( Exec (D44 , D49) ) . D40 ) by SCMPDS_5:41
.= ( 0 ) by L270 , AMI_3:10 , SCMPDS_2:45;
L282: (D31 is_closed_on ( Initialize D47 ) , D48 & D31 is_halting_on ( Initialize D47 ) , D48) by L281 , L246 , L248 , L276 , L280 , L271 , L199 , L264 , L272 , L275 , L278 , L279;
L283: (D31 is_closed_on D47 , D48 & D31 is_halting_on D47 , D48) by L282 , SCMPDS_6:125 , SCMPDS_6:126;
L284: ( IExec (D31 , D48 , ( Initialize D47 )) ) = ( IExec (D31 , D48 , ( Initialize ( Initialize D47 ) )) );
L285: ( ( IExec (D31 , D48 , ( Initialize D47 )) ) . D18 ) = ( Sum C51 ) by L284 , L246 , L248 , L281 , L276 , L280 , L271 , L199 , L264 , L272 , L275 , L278 , L279;
thus L286: ( ( IExec (( sum (C49 , C50) ) , R9 , C48) ) . D18 ) = ( Sum C51 ) by L285 , L283 , L245 , SCPISORT:7;
thus L287: thesis by L283 , SCPISORT:9;
end;
theorem
L288: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B59 being ( 0 ) -started (State of ( SCMPDS )) holds (for B60 , B61 being (Element of ( NAT )) holds (for B62 being (FinSequence of ( INT )) holds ((B61 >= 3 & B62 is_FinSequence_on B59 , B61 & ( len B62 ) = B60) implies (( ( IExec (( sum (B60 , B61) ) , R9 , B59) ) . ( intpos 1 ) ) = ( Sum B62 ) & ( sum (B60 , B61) ) is  parahalting))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C54 being ( 0 ) -started (State of ( SCMPDS ));
let C55 , C56 being (Element of ( NAT ));
let C57 being (FinSequence of ( INT ));
assume that
L289: C56 >= 3
and
L290: (C57 is_FinSequence_on C54 , C56 & ( len C57 ) = C55);
thus L291: ( ( IExec (( sum (C55 , C56) ) , R9 , C54) ) . D18 ) = ( Sum C57 ) by L289 , L290 , L244;
L292:
now
let C58 being (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
consider C59 being (FinSequence of ( INT )) such that L293: (( len C59 ) = C55 & C59 is_FinSequence_on C58 , C56) by SCPISORT:2;
L294: C59 is_FinSequence_on ( Initialize C58 ) , C56
proof
let C60 being (Element of ( NAT ));
assume L295: (1 <= C60 & C60 <= ( len C59 ));
L296: ( C59 . C60 ) = ( C58 . ( intpos ( C56 + C60 ) ) ) by L295 , L293 , SCPISORT:def 1;
thus L297: thesis by L296 , SCMPDS_5:15;
end;
L298: ( sum (C55 , C56) ) is_halting_on ( Initialize C58 ) , R7 by L294 , L289 , L244 , L293;
thus L299: ( sum (C55 , C56) ) is_halting_on C58 , R7 by L298 , SCMPDS_6:126;
end;
thus L300: thesis by L292 , SCMPDS_6:21;
end;
begin
scheme WhileGEnd { F7((State of ( SCMPDS ))) -> (Element of ( NAT )) , F8() -> ( 0 ) -started (State of ( SCMPDS )) , F9() -> (Instruction-Sequence of ( SCMPDS )) , F10() ->  halt-free  shiftable (Program of ( SCMPDS )) , F11() -> Int_position , F12() -> Integer , P2[set] } : (F7(( Initialize ( IExec (( while>0 (F11() , F12() , F10()) ) , F9() , F8()) ) )) = ( 0 ) & P2[ ( Initialize ( IExec (( while>0 (F11() , F12() , F10()) ) , F9() , F8()) ) ) ])
provided
L301: (for B63 being ( 0 ) -started (State of ( SCMPDS )) holds (P2[ B63 ] implies (F7(B63) = ( 0 ) iff ( B63 . ( DataLoc (( F8() . F11() ) , F12()) ) ) <= ( 0 ))))
and
L302: P2[ F8() ]
and
L303: (for B64 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P2[ B64 ] & ( B64 . F11() ) = ( F8() . F11() ) & ( B64 . ( DataLoc (( F8() . F11() ) , F12()) ) ) > ( 0 )) implies (( ( IExec (F10() , R7 , B64) ) . F11() ) = ( B64 . F11() ) & F10() is_closed_on B64 , R7 & F10() is_halting_on B64 , R7 & F7(( Initialize ( IExec (F10() , R7 , B64) ) )) < F7(B64) & P2[ ( Initialize ( IExec (F10() , R7 , B64) ) ) ]))))
proof
set D52 = ( DataLoc (( F8() . F11() ) , F12()) );
set D53 = ( while>0 (F11() , F12() , F10()) );
defpred S5[ (Element of ( NAT )) ] means (for B65 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((F7(B65) <= $1 & ( B65 . F11() ) = ( F8() . F11() ) & P2[ B65 ]) implies (F7(( Initialize ( IExec (D53 , R7 , B65) ) )) = ( 0 ) & P2[ ( Initialize ( IExec (D53 , R7 , B65) ) ) ]))));
L304: S5[ ( 0 ) ]
proof
let C61 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
L305: ( Initialize C61 ) = C61 by MEMSTR_0:44;
assume that
L306: F7(C61) <= ( 0 )
and
L307: ( C61 . F11() ) = ( F8() . F11() )
and
L308: P2[ C61 ];
L309: F7(C61) >= ( 0 ) by NAT_1:2;
L310: F7(C61) = ( 0 ) by L309 , L306 , XXREAL_0:1;
L311: ( C61 . ( DataLoc (( F8() . F11() ) , F12()) ) ) <= ( 0 ) by L310 , L301 , L308;
L312: (for B66 being Int_position holds ( ( IExec (D53 , R7 , C61) ) . B66 ) = ( C61 . B66 )) by L311 , L307 , SCMPDS_8:23;
thus L313: thesis by L312 , L308 , L310 , L305 , SCPISORT:4;
end;
L314:
now
let C62 being (Element of ( NAT ));
assume L315: S5[ C62 ];
L316:
now
let C63 being ( 0 ) -started (State of ( SCMPDS ));
let R8 being (Instruction-Sequence of ( SCMPDS ));
assume that
L317: F7(C63) <= ( C62 + 1 )
and
L318: ( C63 . F11() ) = ( F8() . F11() )
and
L319: P2[ C63 ];
per cases ;
suppose L320: F7(C63) = ( 0 );

thus L321: (F7(( Initialize ( IExec (D53 , R8 , C63) ) )) = ( 0 ) & P2[ ( Initialize ( IExec (D53 , R8 , C63) ) ) ]) by L320 , L304 , L318 , L319;
end;
suppose L322: F7(C63) <> ( 0 );

set D54 = ( IExec (F10() , R8 , C63) );
L323: ( C63 . D52 ) > ( 0 ) by L301 , L319 , L322;
L324: (( D54 . F11() ) = ( F8() . F11() ) & P2[ ( Initialize D54 ) ]) by L323 , L303 , L318 , L319;
deffunc H3((State of ( SCMPDS ))) = F7($1);
L325: P2[ C63 ] by L319;
L326: (for B67 being ( 0 ) -started (State of ( SCMPDS )) holds ((P2[ B67 ] & H3(B67) = ( 0 )) implies ( B67 . ( DataLoc (( C63 . F11() ) , F12()) ) ) <= ( 0 ))) by L301 , L318;
L327: H3(( Initialize D54 )) < H3(C63) by L303 , L318 , L319 , L323;
L328: ( H3(( Initialize D54 )) + 1 ) <= H3(C63) by L327 , INT_1:7;
L329: ( H3(( Initialize D54 )) + 1 ) <= ( C62 + 1 ) by L328 , L317 , XXREAL_0:2;
L330: H3(( Initialize D54 )) <= C62 by L329 , XREAL_1:6;
L331: (for B68 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P2[ B68 ] & ( B68 . F11() ) = ( C63 . F11() ) & ( B68 . ( DataLoc (( C63 . F11() ) , F12()) ) ) > ( 0 )) implies (( ( IExec (F10() , R7 , B68) ) . F11() ) = ( B68 . F11() ) & F10() is_closed_on B68 , R7 & F10() is_halting_on B68 , R7 & H3(( Initialize ( IExec (F10() , R7 , B68) ) )) < H3(B68) & P2[ ( Initialize ( IExec (F10() , R7 , B68) ) ) ])))) by L303 , L318;
L332: ( C63 . ( DataLoc (( C63 . F11() ) , F12()) ) ) > ( 0 ) by L301 , L318 , L319 , L322;
L333: ( IExec (D53 , R8 , C63) ) = ( IExec (D53 , R8 , ( Initialize D54 )) ) from SCMPDS_8:sch 4(L332 , L326 , L325 , L331);
L334: ( ( Initialize D54 ) . F11() ) = ( D54 . F11() ) by SCMPDS_5:15;
thus L335: (H3(( Initialize ( IExec (D53 , R8 , C63) ) )) = ( 0 ) & P2[ ( Initialize ( IExec (D53 , R8 , C63) ) ) ]) by L334 , L315 , L330 , L324 , L333;
end;
end;
thus L337: S5[ ( C62 + 1 ) ] by L316;
end;
L338: (for B69 being (Element of ( NAT )) holds S5[ B69 ]) from NAT_1:sch 1(L304 , L314);
L339: S5[ F7(F8()) ] by L338;
thus L340: thesis by L339 , L302;
end;
begin
definition
let C64 being (Element of ( NAT ));
func Fib-macro C64 -> (Program of ( SCMPDS )) equals 
( ( ( ( ( ( GBP ) := ( 0 ) ) ';' ( ( intpos 1 ) := ( 0 ) ) ) ';' ( ( intpos 2 ) := 1 ) ) ';' ( ( intpos 3 ) := C64 ) ) ';' ( while>0 (( GBP ) , 3 , ( ( ( ( (( GBP ) , 4) := (( GBP ) , 2) ) ';' ( AddTo (( GBP ) , 2 , ( GBP ) , 1) ) ) ';' ( (( GBP ) , 1) := (( GBP ) , 4) ) ) ';' ( AddTo (( GBP ) , 3 , ( - 1 )) ) )) ) );
coherence;
end;
theorem
L342: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B70 being ( 0 ) -started (State of ( SCMPDS )) holds (for B71 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B72 , B73 , B74 being Int_position holds (for B75 , B76 being (Element of ( NAT )) holds ((( B70 . B72 ) = ( 0 ) & ( B70 . B73 ) = ( 0 ) & ( B70 . B74 ) = 1 & ( B70 . ( intpos B76 ) ) = B75 & (for B77 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds (for B78 being (Element of ( NAT )) holds ((B75 = ( ( B77 . ( intpos B76 ) ) + B78 ) & ( B77 . B73 ) = ( Fib B78 ) & ( B77 . B74 ) = ( Fib ( B78 + 1 ) ) & ( B77 . B72 ) = ( 0 ) & ( B77 . ( intpos B76 ) ) > ( 0 )) implies (( ( IExec (B71 , R7 , B77) ) . B72 ) = ( 0 ) & B71 is_closed_on B77 , R7 & B71 is_halting_on B77 , R7 & ( ( IExec (B71 , R7 , B77) ) . ( intpos B76 ) ) = ( ( B77 . ( intpos B76 ) ) - 1 ) & ( ( IExec (B71 , R7 , B77) ) . B73 ) = ( Fib ( B78 + 1 ) ) & ( ( IExec (B71 , R7 , B77) ) . B74 ) = ( Fib ( ( B78 + 1 ) + 1 ) ))))))) implies (( ( IExec (( while>0 (B72 , B76 , B71) ) , R9 , B70) ) . B73 ) = ( Fib B75 ) & ( ( IExec (( while>0 (B72 , B76 , B71) ) , R9 , B70) ) . B74 ) = ( Fib ( B75 + 1 ) ) & ( while>0 (B72 , B76 , B71) ) is_closed_on B70 , R9 & ( while>0 (B72 , B76 , B71) ) is_halting_on B70 , R9)))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C65 being ( 0 ) -started (State of ( SCMPDS ));
let C66 being  halt-free  shiftable (Program of ( SCMPDS ));
let C67 , C68 , C69 being Int_position;
let C70 , C71 being (Element of ( NAT ));
set D55 = ( IExec (( while>0 (C67 , C71 , C66) ) , R9 , C65) );
set D56 = ( Initialize D55 );
set D57 = ( DataLoc (( C65 . C67 ) , C71) );
defpred S6[ (State of ( SCMPDS )) ] means (( $1 . ( intpos C71 ) ) >= ( 0 ) & (ex B79 being (Element of ( NAT )) st (C70 = ( ( $1 . ( intpos C71 ) ) + B79 ) & ( $1 . C68 ) = ( Fib B79 ) & ( $1 . C69 ) = ( Fib ( B79 + 1 ) ))));
assume that
L343: ( C65 . C67 ) = ( 0 )
and
L344: ( C65 . C68 ) = ( 0 )
and
L345: ( C65 . C69 ) = 1
and
L346: ( C65 . ( intpos C71 ) ) = C70;
consider C72 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L347: (for B80 being (State of ( SCMPDS )) holds ((( B80 . D57 ) <= ( 0 ) implies ( C72 . B80 ) = ( 0 )) & (( B80 . D57 ) > ( 0 ) implies ( C72 . B80 ) = ( B80 . D57 )))) by SCMPDS_8:5;
L348: (for B81 being ( 0 ) -started (State of ( SCMPDS )) holds ((( B81 . D57 ) <= ( 0 ) implies ( C72 . B81 ) = ( 0 )) & (( B81 . D57 ) > ( 0 ) implies ( C72 . B81 ) = ( B81 . D57 )))) by L347;
deffunc H4((State of ( SCMPDS ))) = ( C72 . $1 );
L349: (for B82 being ( 0 ) -started (State of ( SCMPDS )) holds (S6[ B82 ] implies ((not (H4(B82) = ( 0 ) & ( B82 . D57 ) > ( 0 ))) & (( B82 . D57 ) <= ( 0 ) implies H4(B82) = ( 0 ))))) by L348;
assume L350: (for B83 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds (for B84 being (Element of ( NAT )) holds ((C70 = ( ( B83 . ( intpos C71 ) ) + B84 ) & ( B83 . C68 ) = ( Fib B84 ) & ( B83 . C69 ) = ( Fib ( B84 + 1 ) ) & ( B83 . C67 ) = ( 0 ) & ( B83 . ( intpos C71 ) ) > ( 0 )) implies (( ( IExec (C66 , R7 , B83) ) . C67 ) = ( 0 ) & C66 is_closed_on B83 , R7 & C66 is_halting_on B83 , R7 & ( ( IExec (C66 , R7 , B83) ) . ( intpos C71 ) ) = ( ( B83 . ( intpos C71 ) ) - 1 ) & ( ( IExec (C66 , R7 , B83) ) . C68 ) = ( Fib ( B84 + 1 ) ) & ( ( IExec (C66 , R7 , B83) ) . C69 ) = ( Fib ( ( B84 + 1 ) + 1 ) ))))));
L351:
now
let C73 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
assume that
L352: S6[ C73 ]
and
L353: ( C73 . C67 ) = ( C65 . C67 )
and
L354: ( C73 . ( DataLoc (( C65 . C67 ) , C71) ) ) > ( 0 );
set D58 = ( IExec (C66 , R7 , C73) );
set D59 = ( Initialize D58 );
consider C74 being (Element of ( NAT )) such that L355: C70 = ( ( C73 . ( intpos C71 ) ) + C74 ) and L356: ( C73 . C68 ) = ( Fib C74 ) and L357: ( C73 . C69 ) = ( Fib ( C74 + 1 ) ) by L352;
L358: ( C73 . C69 ) = ( Fib ( C74 + 1 ) ) by L357;
L359: ( intpos ( ( 0 ) + C71 ) ) = D57 by L343 , SCMP_GCD:1;
L360: (C70 = ( ( C73 . ( intpos C71 ) ) + C74 ) & ( C73 . C68 ) = ( Fib C74 )) by L355 , L356;
thus L361: ( ( IExec (C66 , R7 , C73) ) . C67 ) = ( C73 . C67 ) by L360 , L343 , L350 , L353 , L354 , L358 , L359;
thus L362: (C66 is_closed_on C73 , R7 & C66 is_halting_on C73 , R7) by L343 , L350 , L353 , L354 , L360 , L358 , L359;
L363: ( D58 . ( intpos C71 ) ) = ( ( C73 . ( intpos C71 ) ) - 1 ) by L343 , L350 , L353 , L354 , L360 , L358 , L359;
thus L364:now
per cases ;
suppose L365: ( D58 . ( intpos C71 ) ) <= ( 0 );

L366: ( D59 . D57 ) <= ( 0 ) by L365 , L359 , SCMPDS_5:15;
L367: H4(D59) = ( 0 ) by L366 , L348;
L368: H4(C73) <> ( 0 ) by L349 , L352 , L354;
thus L369: H4(D59) < H4(C73) by L368 , L367 , NAT_1:3;
end;
suppose L370: ( D58 . ( intpos C71 ) ) > ( 0 );

L371: ( C73 . D57 ) > ( 0 ) by L354;
L372: H4(C73) = ( C73 . D57 ) by L371 , L348
.= ( C73 . ( intpos C71 ) ) by L359;
L373: ( D59 . D57 ) > ( 0 ) by L359 , L370 , SCMPDS_5:15;
L374: H4(D59) = ( D59 . D57 ) by L373 , L348
.= ( ( C73 . ( intpos C71 ) ) - 1 ) by L359 , L363 , SCMPDS_5:15;
thus L375: H4(D59) < H4(C73) by L374 , L372 , XREAL_1:146;
end;
end;
thus L377: S6[ D59 ]
proof
L378: ( C73 . ( intpos C71 ) ) >= ( 1 + ( 0 ) ) by L354 , L359 , INT_1:7;
L379: ( ( C73 . ( intpos C71 ) ) - 1 ) >= ( 0 ) by L378 , XREAL_1:48;
thus L380: ( D59 . ( intpos C71 ) ) >= ( 0 ) by L379 , L363 , SCMPDS_5:15;
take D60 = ( C74 + 1 );
thus L381: C70 = ( ( ( ( C73 . ( intpos C71 ) ) - 1 ) + 1 ) + C74 ) by L355
.= ( ( ( D59 . ( intpos C71 ) ) + 1 ) + C74 ) by L363 , SCMPDS_5:15
.= ( ( D59 . ( intpos C71 ) ) + D60 );
L382: (( D58 . C68 ) = ( Fib D60 ) & ( D58 . C69 ) = ( Fib ( ( C74 + 1 ) + 1 ) )) by L343 , L350 , L353 , L354 , L360 , L358 , L359;
thus L383: thesis by L382 , SCMPDS_5:15;
end;

end;
L378: S6[ C65 ]
proof
L379: ( C65 . ( intpos C71 ) ) = C70 by L346;
thus L380: ( C65 . ( intpos C71 ) ) >= ( 0 ) by L379 , NAT_1:2;
take D61 = ( 0 );
thus L381: C70 = ( ( C65 . ( intpos C71 ) ) + D61 ) by L346;
thus L382: ( C65 . C68 ) = ( Fib D61 ) by L344 , PRE_FF:1;
thus L383: thesis by L345 , PRE_FF:1;
end;
L384: (H4(D56) = ( 0 ) & S6[ D56 ]) from WhileGEnd(L349 , L378 , L351);
L385: ( D56 . D57 ) = ( D55 . D57 ) by SCMPDS_5:15;
L386: ( D56 . ( intpos C71 ) ) = ( D55 . ( intpos ( ( 0 ) + C71 ) ) ) by SCMPDS_5:15
.= ( D55 . D57 ) by L343 , SCMP_GCD:1;
L387: ( D56 . ( intpos C71 ) ) <= ( 0 ) by L386 , L349 , L384 , L385;
L388: ( D56 . ( intpos C71 ) ) = ( 0 ) by L387 , L384 , XXREAL_0:1;
thus L389: (( D55 . C68 ) = ( Fib C70 ) & ( D55 . C69 ) = ( Fib ( C70 + 1 ) )) by L388 , L384 , SCMPDS_5:15;
L390: (for B85 being ( 0 ) -started (State of ( SCMPDS )) holds ((S6[ B85 ] & H4(B85) = ( 0 )) implies ( B85 . D57 ) <= ( 0 ))) by L349;
L391: (( while>0 (C67 , C71 , C66) ) is_closed_on C65 , R9 & ( while>0 (C67 , C71 , C66) ) is_halting_on C65 , R9) from SCMPDS_8:sch 3(L390 , L378 , L351);
thus L392: thesis by L391;
end;
set D62 = ( (( GBP ) , 4) := (( GBP ) , 2) );
set D63 = ( AddTo (( GBP ) , 2 , ( GBP ) , 1) );
set D64 = ( (( GBP ) , 1) := (( GBP ) , 4) );
set D65 = ( AddTo (( GBP ) , 3 , ( - 1 )) );
set D66 = ( ( ( D62 ';' D63 ) ';' D64 ) ';' D65 );
set D67 = ( while>0 (( GBP ) , 3 , D66) );
L393: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B86 being ( 0 ) -started (State of ( SCMPDS )) holds (( B86 . ( GBP ) ) = ( 0 ) implies (( ( IExec (D66 , R9 , B86) ) . ( GBP ) ) = ( 0 ) & ( ( IExec (D66 , R9 , B86) ) . D18 ) = ( B86 . D19 ) & ( ( IExec (D66 , R9 , B86) ) . D19 ) = ( ( B86 . D18 ) + ( B86 . D19 ) ) & ( ( IExec (D66 , R9 , B86) ) . D20 ) = ( ( B86 . D20 ) - 1 )))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
set D68 = ( GBP );
let C75 being ( 0 ) -started (State of ( SCMPDS ));
set D69 = C75;
set D70 = ( IExec (D66 , R9 , C75) );
set D71 = ( IExec (( ( D62 ';' D63 ) ';' D64 ) , R9 , C75) );
set D72 = R9;
set D73 = ( IExec (( D62 ';' D63 ) , R9 , C75) );
set D74 = ( Exec (D62 , D69) );
set D75 = ( intpos 4 );
assume L394: ( C75 . D68 ) = ( 0 );
L395: ( D69 . D68 ) = ( 0 ) by L394;
L396: ( DataLoc (( D69 . D68 ) , 4) ) = ( intpos ( ( 0 ) + 4 ) ) by L395 , SCMP_GCD:1;
L397: ( D74 . D75 ) = ( D69 . ( DataLoc (( D69 . D68 ) , 2) ) ) by L396 , SCMPDS_2:47
.= ( D69 . ( intpos ( ( 0 ) + 2 ) ) ) by L395 , SCMP_GCD:1
.= ( C75 . D19 );
L398: ( 0 ) <> ( abs ( ( D69 . ( GBP ) ) + 4 ) ) by L395 , ABSVALUE:def 1;
L399: D68 <> ( DataLoc (( D69 . ( GBP ) ) , 4) ) by L398 , XTUPLE_0:1;
L400: ( D74 . D68 ) = ( 0 ) by L399 , L395 , SCMPDS_2:47;
L401: ( DataLoc (( D74 . D68 ) , 2) ) = ( intpos ( ( 0 ) + 2 ) ) by L400 , SCMP_GCD:1;
L402: ( 0 ) <> ( abs ( ( D74 . ( GBP ) ) + 2 ) ) by L400 , ABSVALUE:def 1;
L403: D68 <> ( DataLoc (( D74 . ( GBP ) ) , 2) ) by L402 , XTUPLE_0:1;
L404: ( D73 . D68 ) = ( ( Exec (D63 , D74) ) . D68 ) by SCMPDS_5:42
.= ( 0 ) by L400 , L403 , SCMPDS_2:49;
L405: ( DataLoc (( D73 . D68 ) , 1) ) = ( intpos ( ( 0 ) + 1 ) ) by L404 , SCMP_GCD:1;
L406: 4 <> ( abs ( ( D74 . ( GBP ) ) + 2 ) ) by L400 , ABSVALUE:def 1;
L407: D75 <> ( DataLoc (( D74 . ( GBP ) ) , 2) ) by L406 , XTUPLE_0:1;
L408: ( D73 . D75 ) = ( ( Exec (D63 , D74) ) . D75 ) by SCMPDS_5:42
.= ( C75 . D19 ) by L397 , L407 , SCMPDS_2:49;
L409: ( D71 . D18 ) = ( ( Exec (D64 , D73) ) . D18 ) by SCMPDS_5:41
.= ( D73 . ( DataLoc (( D73 . D68 ) , 4) ) ) by L405 , SCMPDS_2:47
.= ( C75 . D19 ) by L404 , L408 , SCMP_GCD:1;
L410: 3 <> ( abs ( ( D74 . ( GBP ) ) + 2 ) ) by L400 , ABSVALUE:def 1;
L411: D20 <> ( DataLoc (( D74 . ( GBP ) ) , 2) ) by L410 , XTUPLE_0:1;
L412: 2 <> ( abs ( ( D69 . ( GBP ) ) + 4 ) ) by L395 , ABSVALUE:def 1;
L413: D19 <> ( DataLoc (( D69 . ( GBP ) ) , 4) ) by L412 , XTUPLE_0:1;
L414: ( D74 . D19 ) = ( D69 . D19 ) by L413 , SCMPDS_2:47
.= ( C75 . D19 );
L415: 1 <> ( abs ( ( D69 . ( GBP ) ) + 4 ) ) by L395 , ABSVALUE:def 1;
L416: D18 <> ( DataLoc (( D69 . ( GBP ) ) , 4) ) by L415 , XTUPLE_0:1;
L417: ( D74 . D18 ) = ( D69 . D18 ) by L416 , SCMPDS_2:47
.= ( C75 . D18 );
L418: 3 <> ( abs ( ( D69 . ( GBP ) ) + 4 ) ) by L395 , ABSVALUE:def 1;
L419: D20 <> ( DataLoc (( D69 . ( GBP ) ) , 4) ) by L418 , XTUPLE_0:1;
L420: ( D74 . D20 ) = ( D69 . D20 ) by L419 , SCMPDS_2:47
.= ( C75 . D20 );
L421: ( 0 ) <> ( abs ( ( D73 . ( GBP ) ) + 1 ) ) by L404 , ABSVALUE:def 1;
L422: D68 <> ( DataLoc (( D73 . ( GBP ) ) , 1) ) by L421 , XTUPLE_0:1;
L423: ( D71 . D68 ) = ( ( Exec (D64 , D73) ) . D68 ) by SCMPDS_5:41
.= ( 0 ) by L404 , L422 , SCMPDS_2:47;
L424: ( DataLoc (( D71 . D68 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L423 , SCMP_GCD:1;
L425: 2 <> ( abs ( ( D73 . ( GBP ) ) + 1 ) ) by L404 , ABSVALUE:def 1;
L426: D19 <> ( DataLoc (( D73 . ( GBP ) ) , 1) ) by L425 , XTUPLE_0:1;
L427: ( D73 . D19 ) = ( ( Exec (D63 , D74) ) . D19 ) by SCMPDS_5:42
.= ( ( D74 . D19 ) + ( D74 . ( DataLoc (( D74 . D68 ) , 1) ) ) ) by L401 , SCMPDS_2:49
.= ( ( C75 . D19 ) + ( C75 . D18 ) ) by L400 , L417 , L414 , SCMP_GCD:1;
L428: ( D71 . D19 ) = ( ( Exec (D64 , D73) ) . D19 ) by SCMPDS_5:41
.= ( ( C75 . D19 ) + ( C75 . D18 ) ) by L427 , L426 , SCMPDS_2:47;
L429: 3 <> ( abs ( ( D73 . ( GBP ) ) + 1 ) ) by L404 , ABSVALUE:def 1;
L430: D20 <> ( DataLoc (( D73 . ( GBP ) ) , 1) ) by L429 , XTUPLE_0:1;
L431: ( 0 ) <> ( abs ( ( D71 . ( GBP ) ) + 3 ) ) by L423 , ABSVALUE:def 1;
L432: D68 <> ( DataLoc (( D71 . ( GBP ) ) , 3) ) by L431 , XTUPLE_0:1;
thus L433: ( D70 . D68 ) = ( ( Exec (D65 , D71) ) . D68 ) by SCMPDS_5:41
.= ( 0 ) by L423 , L432 , SCMPDS_2:48;
L434: 1 <> ( abs ( ( D71 . ( GBP ) ) + 3 ) ) by L423 , ABSVALUE:def 1;
L435: D18 <> ( DataLoc (( D71 . ( GBP ) ) , 3) ) by L434 , XTUPLE_0:1;
thus L436: ( D70 . D18 ) = ( ( Exec (D65 , D71) ) . D18 ) by SCMPDS_5:41
.= ( C75 . D19 ) by L409 , L435 , SCMPDS_2:48;
L437: 2 <> ( abs ( ( D71 . ( GBP ) ) + 3 ) ) by L423 , ABSVALUE:def 1;
L438: D19 <> ( DataLoc (( D71 . ( GBP ) ) , 3) ) by L437 , XTUPLE_0:1;
L439: ( D73 . D20 ) = ( ( Exec (D63 , D74) ) . D20 ) by SCMPDS_5:42
.= ( C75 . D20 ) by L420 , L411 , SCMPDS_2:49;
L440: ( D71 . D20 ) = ( ( Exec (D64 , D73) ) . D20 ) by SCMPDS_5:41
.= ( C75 . D20 ) by L439 , L430 , SCMPDS_2:47;
thus L441: ( D70 . D19 ) = ( ( Exec (D65 , D71) ) . D19 ) by SCMPDS_5:41
.= ( ( C75 . D18 ) + ( C75 . D19 ) ) by L428 , L438 , SCMPDS_2:48;
thus L442: ( D70 . D20 ) = ( ( Exec (D65 , D71) ) . D20 ) by SCMPDS_5:41
.= ( ( D71 . D20 ) + ( - 1 ) ) by L424 , SCMPDS_2:48
.= ( ( C75 . D20 ) - 1 ) by L440;
end;
L443: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B87 being ( 0 ) -started (State of ( SCMPDS )) holds (for B88 being (Element of ( NAT )) holds ((( B87 . ( GBP ) ) = ( 0 ) & ( B87 . D18 ) = ( 0 ) & ( B87 . D19 ) = 1 & ( B87 . D20 ) = B88) implies (( ( IExec (D67 , R9 , B87) ) . D18 ) = ( Fib B88 ) & ( ( IExec (D67 , R9 , B87) ) . D19 ) = ( Fib ( B88 + 1 ) ) & D67 is_closed_on B87 , R9 & D67 is_halting_on B87 , R9)))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C76 being ( 0 ) -started (State of ( SCMPDS ));
let C77 being (Element of ( NAT ));
set D76 = ( GBP );
L444:
now
let C78 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
let C79 being (Element of ( NAT ));
assume that
L445: C77 = ( ( C78 . D20 ) + C79 )
and
L446: ( C78 . D18 ) = ( Fib C79 )
and
L447: ( C78 . D19 ) = ( Fib ( C79 + 1 ) )
and
L448: ( C78 . D76 ) = ( 0 )
and
L449: ( C78 . D20 ) > ( 0 );
thus L450: ( ( IExec (D66 , R7 , C78) ) . D76 ) = ( 0 ) by L448 , L393;
thus L451: (D66 is_closed_on C78 , R7 & D66 is_halting_on C78 , R7) by SCMPDS_6:20 , SCMPDS_6:21;
thus L452: ( ( IExec (D66 , R7 , C78) ) . D20 ) = ( ( C78 . D20 ) - 1 ) by L448 , L393;
thus L453: ( ( IExec (D66 , R7 , C78) ) . D18 ) = ( Fib ( C79 + 1 ) ) by L447 , L448 , L393;
thus L454: ( ( IExec (D66 , R7 , C78) ) . D19 ) = ( ( C78 . D18 ) + ( C78 . D19 ) ) by L448 , L393
.= ( Fib ( ( C79 + 1 ) + 1 ) ) by L446 , L447 , PRE_FF:1;
end;
assume L455: (( C76 . ( GBP ) ) = ( 0 ) & ( C76 . D18 ) = ( 0 ) & ( C76 . D19 ) = 1 & ( C76 . D20 ) = C77);
thus L456: thesis by L455 , L444 , L342;
end;
L457: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B89 being ( 0 ) -started (State of ( SCMPDS )) holds (for B90 being (Element of ( NAT )) holds (( ( IExec (( Fib-macro B90 ) , R9 , B89) ) . D18 ) = ( Fib B90 ) & ( ( IExec (( Fib-macro B90 ) , R9 , B89) ) . D19 ) = ( Fib ( B90 + 1 ) ) & ( Fib-macro B90 ) is_halting_on B89 , R9))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C80 being ( 0 ) -started (State of ( SCMPDS ));
let C81 being (Element of ( NAT ));
set D77 = ( GBP );
set D78 = ( D77 := ( 0 ) );
set D79 = ( D18 := ( 0 ) );
set D80 = ( D19 := 1 );
set D81 = ( D20 := C81 );
set D82 = ( ( ( D78 ';' D79 ) ';' D80 ) ';' D81 );
set D83 = ( IExec (D82 , R9 , C80) );
set D84 = ( IExec (( ( D78 ';' D79 ) ';' D80 ) , R9 , C80) );
set D85 = ( IExec (( D78 ';' D79 ) , R9 , C80) );
set D86 = ( Exec (D78 , C80) );
L458: ( Initialize C80 ) = C80 by MEMSTR_0:44;
L459: ( D86 . D77 ) = ( 0 ) by SCMPDS_2:45;
L460: ( D85 . D77 ) = ( ( Exec (D79 , D86) ) . D77 ) by SCMPDS_5:42
.= ( 0 ) by L459 , AMI_3:10 , SCMPDS_2:45;
L461: ( D84 . D77 ) = ( ( Exec (D80 , D85) ) . D77 ) by SCMPDS_5:41
.= ( 0 ) by L460 , AMI_3:10 , SCMPDS_2:45;
L462: ( D85 . D18 ) = ( ( Exec (D79 , D86) ) . D18 ) by SCMPDS_5:42
.= ( 0 ) by SCMPDS_2:45;
L463: ( D84 . D18 ) = ( ( Exec (D80 , D85) ) . D18 ) by SCMPDS_5:41
.= ( 0 ) by L462 , AMI_3:10 , SCMPDS_2:45;
L464: ( D83 . D18 ) = ( ( Exec (D81 , D84) ) . D18 ) by SCMPDS_5:41
.= ( 0 ) by L463 , AMI_3:10 , SCMPDS_2:45;
L465: ( D84 . D19 ) = ( ( Exec (D80 , D85) ) . D19 ) by SCMPDS_5:41
.= 1 by SCMPDS_2:45;
L466: ( D83 . D19 ) = ( ( Exec (D81 , D84) ) . D19 ) by SCMPDS_5:41
.= 1 by L465 , AMI_3:10 , SCMPDS_2:45;
L467: ( D83 . D20 ) = ( ( Exec (D81 , D84) ) . D20 ) by SCMPDS_5:41
.= C81 by SCMPDS_2:45;
L468: ( D83 . D77 ) = ( ( Exec (D81 , D84) ) . D77 ) by SCMPDS_5:41
.= ( 0 ) by L461 , AMI_3:10 , SCMPDS_2:45;
L469: ( ( Initialize D83 ) . ( GBP ) ) = ( D83 . ( GBP ) ) by SCMPDS_5:15;
L470: ( ( Initialize D83 ) . D18 ) = ( D83 . D18 ) by SCMPDS_5:15;
L471: ( ( Initialize D83 ) . D19 ) = ( D83 . D19 ) by SCMPDS_5:15;
L472: ( ( Initialize D83 ) . D20 ) = ( D83 . D20 ) by SCMPDS_5:15;
L473: (D67 is_closed_on ( Initialize D83 ) , R9 & D67 is_halting_on ( Initialize D83 ) , R9) by L464 , L466 , L467 , L443 , L468 , L469 , L470 , L471 , L472;
L474: D67 is_closed_on D83 , R9
proof
L475: (for B91 being (Element of ( NAT )) holds ( IC ( Comput (( R9 +* ( stop D67 ) ) , ( Initialize ( Initialize D83 ) ) , B91) ) ) in ( dom ( stop D67 ) )) by L473 , SCMPDS_6:def 2;
thus L476: thesis by L475 , SCMPDS_6:def 2;
end;
L477: D67 is_halting_on D83 , R9
proof
L478: ( R9 +* ( stop D67 ) ) halts_on ( Initialize ( Initialize D83 ) ) by L473 , SCMPDS_6:def 3;
thus L479: thesis by L478 , SCMPDS_6:def 3;
end;
L480: ( ( IExec (D67 , R9 , ( Initialize D83 )) ) . D18 ) = ( Fib C81 ) by L468 , L464 , L466 , L467 , L443 , L469 , L470 , L471 , L472;
thus L481: ( ( IExec (( Fib-macro C81 ) , R9 , C80) ) . D18 ) = ( Fib C81 ) by L480 , L474 , L477 , SCPISORT:7;
L482: ( ( IExec (D67 , R9 , ( Initialize D83 )) ) . D19 ) = ( Fib ( C81 + 1 ) ) by L468 , L464 , L466 , L467 , L443 , L469 , L470 , L471 , L472;
thus L483: ( ( IExec (( Fib-macro C81 ) , R9 , C80) ) . D19 ) = ( Fib ( C81 + 1 ) ) by L482 , L474 , L477 , SCPISORT:7;
thus L484: thesis by L474 , L477 , L458 , SCPISORT:9;
end;
theorem
L485: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B92 being ( 0 ) -started (State of ( SCMPDS )) holds (for B93 being (Element of ( NAT )) holds (( ( IExec (( Fib-macro B93 ) , R9 , B92) ) . ( intpos 1 ) ) = ( Fib B93 ) & ( ( IExec (( Fib-macro B93 ) , R9 , B92) ) . ( intpos 2 ) ) = ( Fib ( B93 + 1 ) ) & ( Fib-macro B93 ) is  parahalting))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C82 being ( 0 ) -started (State of ( SCMPDS ));
let C83 being (Element of ( NAT ));
thus L486: (( ( IExec (( Fib-macro C83 ) , R9 , C82) ) . D18 ) = ( Fib C83 ) & ( ( IExec (( Fib-macro C83 ) , R9 , C82) ) . D19 ) = ( Fib ( C83 + 1 ) )) by L457;
L487: (for B94 being (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ( Fib-macro C83 ) is_halting_on B94 , R7))
proof
let C84 being (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
L488: ( Fib-macro C83 ) is_halting_on ( Initialize C84 ) , R7 by L457;
thus L489: thesis by L488 , SCMPDS_6:126;
end;
thus L490: thesis by L487 , SCMPDS_6:21;
end;
begin
definition
let C85 being Int_position;
let C86 being Integer;
let C87 being (Program of ( SCMPDS ));
func while<>0 (C85 , C86 , C87) -> (Program of ( SCMPDS )) equals 
( ( ( ( (C85 , C86) <>0_goto 2 ) ';' ( goto ( ( card C87 ) + 2 ) ) ) ';' C87 ) ';' ( goto ( - ( ( card C87 ) + 2 ) ) ) );
coherence;
end;
begin
theorem
L492: (for B95 being Int_position holds (for B96 being Integer holds (for B97 being (Program of ( SCMPDS )) holds ( card ( while<>0 (B95 , B96 , B97) ) ) = ( ( card B97 ) + 3 ))))
proof
let C88 being Int_position;
let C89 being Integer;
let C90 being (Program of ( SCMPDS ));
set D87 = ( (C88 , C89) <>0_goto 2 );
set D88 = ( goto ( ( card C90 ) + 2 ) );
set D89 = ( ( D87 ';' D88 ) ';' C90 );
thus L493: ( card ( while<>0 (C88 , C89 , C90) ) ) = ( ( card D89 ) + 1 ) by SCMP_GCD:4
.= ( ( ( card ( D87 ';' D88 ) ) + ( card C90 ) ) + 1 ) by AFINSQ_1:17
.= ( ( 2 + ( card C90 ) ) + 1 ) by SCMP_GCD:5
.= ( ( card C90 ) + 3 );
end;
L494: (for B98 being Int_position holds (for B99 being Integer holds (for B100 being (Program of ( SCMPDS )) holds ( card ( stop ( while<>0 (B98 , B99 , B100) ) ) ) = ( ( card B100 ) + 4 ))))
proof
let C91 being Int_position;
let C92 being Integer;
let C93 being (Program of ( SCMPDS ));
thus L495: ( card ( stop ( while<>0 (C91 , C92 , C93) ) ) ) = ( ( card ( while<>0 (C91 , C92 , C93) ) ) + 1 ) by COMPOS_1:55
.= ( ( ( card C93 ) + 3 ) + 1 ) by L492
.= ( ( card C93 ) + 4 );
end;
theorem
L496: (for B101 being Int_position holds (for B102 being Integer holds (for B103 being (Element of ( NAT )) holds (for B104 being (Program of ( SCMPDS )) holds (B103 < ( ( card B104 ) + 3 ) iff B103 in ( dom ( while<>0 (B101 , B102 , B104) ) ))))))
proof
let C94 being Int_position;
let C95 being Integer;
let C96 being (Element of ( NAT ));
let C97 being (Program of ( SCMPDS ));
L497: ( card ( while<>0 (C94 , C95 , C97) ) ) = ( ( card C97 ) + 3 ) by L492;
thus L498: thesis by L497 , AFINSQ_1:66;
end;
theorem
L499: (for B105 being Int_position holds (for B106 being Integer holds (for B107 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( while<>0 (B105 , B106 , B107) ) ) & 1 in ( dom ( while<>0 (B105 , B106 , B107) ) )))))
proof
let C98 being Int_position;
let C99 being Integer;
let C100 being (Program of ( SCMPDS ));
L500: 3 <= ( ( card C100 ) + 3 ) by NAT_1:11;
L501: (( 0 ) < ( ( card C100 ) + 3 ) & 1 < ( ( card C100 ) + 3 )) by L500 , XXREAL_0:2;
thus L502: thesis by L501 , L496;
end;
theorem
L503: (for B108 being Int_position holds (for B109 being Integer holds (for B110 being (Program of ( SCMPDS )) holds (( ( while<>0 (B108 , B109 , B110) ) . ( 0 ) ) = ( (B108 , B109) <>0_goto 2 ) & ( ( while<>0 (B108 , B109 , B110) ) . 1 ) = ( goto ( ( card B110 ) + 2 ) ) & ( ( while<>0 (B108 , B109 , B110) ) . ( ( card B110 ) + 2 ) ) = ( goto ( - ( ( card B110 ) + 2 ) ) )))))
proof
let C101 being Int_position;
let C102 being Integer;
let C103 being (Program of ( SCMPDS ));
set D90 = ( (C101 , C102) <>0_goto 2 );
set D91 = ( goto ( ( card C103 ) + 2 ) );
set D92 = ( goto ( - ( ( card C103 ) + 2 ) ) );
set D93 = ( ( D90 ';' D91 ) ';' C103 );
set D94 = ( while<>0 (C101 , C102 , C103) );
L504: D94 = ( ( D90 ';' D91 ) ';' ( C103 ';' D92 ) ) by SCMPDS_4:11;
thus L505: ( D94 . ( 0 ) ) = D90 by L504 , L1;
thus L506: ( D94 . 1 ) = D91 by L504 , L1;
L507: ( card D93 ) = ( ( card ( D90 ';' D91 ) ) + ( card C103 ) ) by AFINSQ_1:17
.= ( ( card C103 ) + 2 ) by SCMP_GCD:5;
thus L508: thesis by L507 , SCMP_GCD:6;
end;
L509: (for B111 being Int_position holds (for B112 being Integer holds (for B113 being (Program of ( SCMPDS )) holds ( while<>0 (B111 , B112 , B113) ) = ( ( (B111 , B112) <>0_goto 2 ) ';' ( ( ( goto ( ( card B113 ) + 2 ) ) ';' B113 ) ';' ( goto ( - ( ( card B113 ) + 2 ) ) ) ) ))))
proof
let C104 being Int_position;
let C105 being Integer;
let C106 being (Program of ( SCMPDS ));
set D95 = ( (C104 , C105) <>0_goto 2 );
set D96 = ( goto ( ( card C106 ) + 2 ) );
set D97 = ( goto ( - ( ( card C106 ) + 2 ) ) );
thus L510: ( while<>0 (C104 , C105 , C106) ) = ( ( D95 ';' ( D96 ';' C106 ) ) ';' D97 ) by SCMPDS_4:16
.= ( D95 ';' ( ( D96 ';' C106 ) ';' D97 ) ) by SCMPDS_4:15;
end;
theorem
L511: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B114 being (State of ( SCMPDS )) holds (for B115 being (Program of ( SCMPDS )) holds (for B116 being Int_position holds (for B117 being Integer holds (( B114 . ( DataLoc (( B114 . B116 ) , B117) ) ) = ( 0 ) implies (( while<>0 (B116 , B117 , B115) ) is_closed_on B114 , R9 & ( while<>0 (B116 , B117 , B115) ) is_halting_on B114 , R9)))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C107 being (State of ( SCMPDS ));
let C108 being (Program of ( SCMPDS ));
let C109 being Int_position;
let C110 being Integer;
set D98 = ( DataLoc (( C107 . C109 ) , C110) );
assume L512: ( C107 . D98 ) = ( 0 );
set D99 = ( while<>0 (C109 , C110 , C108) );
set D100 = ( stop D99 );
set D101 = D100;
set D102 = ( Initialize C107 );
set D103 = ( R9 +* D100 );
set D104 = ( Comput (D103 , D102 , 1) );
set D105 = ( Comput (D103 , D102 , 2) );
set D106 = D103;
set D107 = D103;
L513: (not D98 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L514: (not C109 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L515: ( D102 . ( DataLoc (( D102 . C109 ) , C110) ) ) = ( D102 . D98 ) by L514 , FUNCT_4:11
.= ( 0 ) by L512 , L513 , FUNCT_4:11;
set D108 = ( (C109 , C110) <>0_goto 2 );
set D109 = ( goto ( ( card C108 ) + 2 ) );
set D110 = ( goto ( - ( ( card C108 ) + 2 ) ) );
L516: ( IC D102 ) = ( 0 ) by MEMSTR_0:47;
L517: D99 = ( D108 ';' ( ( D109 ';' C108 ) ';' D110 ) ) by L509;
L518: ( Comput (D103 , D102 , ( ( 0 ) + 1 )) ) = ( Following (D103 , ( Comput (D103 , D102 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D103 , D102) )
.= ( Exec (D108 , D102) ) by L517 , SCMPDS_6:11;
L519: ( IC D104 ) = ( succ ( IC D102 ) ) by L518 , L515 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L516;
L520: D101 c= D103 by FUNCT_4:25;
L521: D100 c= D106 by L520;
L522: 1 in ( dom D99 ) by L499;
L523: 1 in ( dom D100 ) by L522 , COMPOS_1:62;
L524: ( D106 . 1 ) = ( D100 . 1 ) by L523 , L521 , GRFUNC_1:2
.= ( D99 . 1 ) by L522 , COMPOS_1:63
.= D109 by L503;
L525: ( card D99 ) = ( ( card C108 ) + 3 ) by L492;
L526: ( ( card C108 ) + 3 ) in ( dom D100 ) by L525 , COMPOS_1:64;
L527: ( D106 /. ( IC D104 ) ) = ( D106 . ( IC D104 ) ) by PBOOLE:143;
L528: ( Comput (D103 , D102 , ( 1 + 1 )) ) = ( Following (D103 , D104) ) by EXTPRO_1:3
.= ( Exec (D109 , D104) ) by L519 , L524 , L527;
L529: ( IC D105 ) = ( ICplusConst (D104 , ( ( card C108 ) + 2 )) ) by L528 , SCMPDS_2:54
.= ( ( ( card C108 ) + 2 ) + 1 ) by L519 , SCMPDS_6:12
.= ( ( card C108 ) + ( 2 + 1 ) );
L530: ( D107 /. ( IC D105 ) ) = ( D107 . ( IC D105 ) ) by PBOOLE:143;
L531: D100 c= D107 by L520;
L532: ( D107 . ( ( card C108 ) + 3 ) ) = ( D100 . ( ( card C108 ) + 3 ) ) by L531 , L526 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L525 , COMPOS_1:64;
L533: ( CurInstr (D107 , D105) ) = ( halt ( SCMPDS ) ) by L532 , L529 , L530;
L534:
now
let C111 being (Element of ( NAT ));
L535: (C111 = ( 0 ) or ( 0 ) < C111) by NAT_1:3;
L536: (C111 = ( 0 ) or ( ( 0 ) + 1 ) <= C111) by L535 , INT_1:7;
per cases  by L536 , XXREAL_0:1;
suppose L537: C111 = ( 0 );

L538: ( Comput (D103 , D102 , C111) ) = D102 by L537 , EXTPRO_1:2;
thus L539: ( IC ( Comput (D103 , D102 , C111) ) ) in ( dom D100 ) by L538 , L516 , COMPOS_1:36;
end;
suppose L540: C111 = 1;

thus L541: ( IC ( Comput (D103 , D102 , C111) ) ) in ( dom D100 ) by L540 , L522 , L519 , COMPOS_1:62;
end;
suppose L542: 1 < C111;

L543: ( 1 + 1 ) <= C111 by L542 , INT_1:7;
thus L544: ( IC ( Comput (D103 , D102 , C111) ) ) in ( dom D100 ) by L543 , L526 , L529 , L533 , EXTPRO_1:5;
end;
end;
thus L546: D99 is_closed_on C107 , R9 by L534 , SCMPDS_6:def 2;
L547: D103 halts_on D102 by L533 , EXTPRO_1:29;
thus L548: thesis by L547 , SCMPDS_6:def 3;
end;
theorem
L549: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B118 being (State of ( SCMPDS )) holds (for B119 being (Program of ( SCMPDS )) holds (for B120 , B121 being Int_position holds (for B122 being Integer holds (( B118 . ( DataLoc (( B118 . B120 ) , B122) ) ) = ( 0 ) implies ( IExec (( while<>0 (B120 , B122 , B119) ) , R9 , ( Initialize B118 )) ) = ( B118 +* ( Start-At (( ( card B119 ) + 3 ) , ( SCMPDS )) ) )))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C112 being (State of ( SCMPDS ));
let C113 being (Program of ( SCMPDS ));
let C114 , C115 being Int_position;
let C116 being Integer;
set D111 = ( DataLoc (( C112 . C114 ) , C116) );
assume L550: ( C112 . D111 ) = ( 0 );
set D112 = ( (C114 , C116) <>0_goto 2 );
set D113 = ( goto ( ( card C113 ) + 2 ) );
set D114 = ( goto ( - ( ( card C113 ) + 2 ) ) );
set D115 = ( while<>0 (C114 , C116 , C113) );
set D116 = ( stop D115 );
set D117 = D116;
set D118 = ( Initialize C112 );
set D119 = ( R9 +* D116 );
set D120 = ( Comput (D119 , D118 , 1) );
set D121 = ( Comput (D119 , D118 , 2) );
set D122 = D119;
set D123 = D119;
L551: ( IC D118 ) = ( 0 ) by MEMSTR_0:47;
L552: D117 c= D119 by FUNCT_4:25;
L553: D116 c= D122 by L552;
L554: D116 c= D123 by L552;
L555: (not D111 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L556: D115 = ( D112 ';' ( ( D113 ';' C113 ) ';' D114 ) ) by L509;
L557: ( Comput (D119 , D118 , ( ( 0 ) + 1 )) ) = ( Following (D119 , ( Comput (D119 , D118 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D119 , D118) )
.= ( Exec (D112 , D118) ) by L556 , SCMPDS_6:11;
L558: 1 in ( dom D115 ) by L499;
L559: 1 in ( dom D116 ) by L558 , COMPOS_1:62;
L560: ( D122 . 1 ) = ( D116 . 1 ) by L559 , L553 , GRFUNC_1:2
.= ( D115 . 1 ) by L558 , COMPOS_1:63
.= D113 by L503;
set D124 = ( Start-At (( ( card C113 ) + 3 ) , ( SCMPDS )) );
L561: (not C114 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L562: ( D118 . ( DataLoc (( D118 . C114 ) , C116) ) ) = ( D118 . D111 ) by L561 , FUNCT_4:11
.= ( 0 ) by L550 , L555 , FUNCT_4:11;
L563: ( IC D120 ) = ( succ ( IC D118 ) ) by L562 , L557 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L551;
L564: ( D119 /. ( IC D120 ) ) = ( D122 . ( IC D120 ) ) by PBOOLE:143;
L565: ( Comput (D119 , D118 , ( 1 + 1 )) ) = ( Following (D119 , D120) ) by EXTPRO_1:3
.= ( Exec (D113 , D120) ) by L563 , L560 , L564;
L566: ( IC D121 ) = ( ICplusConst (D120 , ( ( card C113 ) + 2 )) ) by L565 , SCMPDS_2:54
.= ( ( ( card C113 ) + 2 ) + 1 ) by L563 , SCMPDS_6:12
.= ( ( card C113 ) + ( 2 + 1 ) );
L567: ( D119 /. ( IC D121 ) ) = ( D123 . ( IC D121 ) ) by PBOOLE:143;
L568: ( card D115 ) = ( ( card C113 ) + 3 ) by L492;
L569: ( ( card C113 ) + 3 ) in ( dom D116 ) by L568 , COMPOS_1:64;
L570: ( D123 . ( ( card C113 ) + 3 ) ) = ( D116 . ( ( card C113 ) + 3 ) ) by L569 , L554 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L568 , COMPOS_1:64;
L571: ( CurInstr (D119 , D121) ) = ( halt ( SCMPDS ) ) by L570 , L566 , L567;
L572: D119 halts_on D118 by L571 , EXTPRO_1:29;
L573: D121 = ( Result (D119 , D118) ) by L572 , L571 , EXTPRO_1:def 9;
L574: ( IExec (D115 , R9 , ( Initialize C112 )) ) = ( Result (D119 , D118) ) by SCMPDS_4:def 5;
L575:
now
let C117 being set;
L576: ( dom D124 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L577: C117 in ( dom ( IExec (D115 , R9 , ( Initialize C112 )) ) );
per cases  by L577 , SCMPDS_4:6;
suppose L578: C117 is Int_position;

L579: C117 <> ( IC ( SCMPDS ) ) by L578 , SCMPDS_2:43;
L580: (not C117 in ( dom D124 )) by L579 , L576 , TARSKI:def 1;
L581: (not C117 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L578 , SCMPDS_4:18;
thus L582: ( ( IExec (D115 , R9 , ( Initialize C112 )) ) . C117 ) = ( D121 . C117 ) by L573 , L574
.= ( D120 . C117 ) by L565 , L578 , SCMPDS_2:54
.= ( D118 . C117 ) by L557 , L578 , SCMPDS_2:55
.= ( C112 . C117 ) by L581 , FUNCT_4:11
.= ( ( C112 +* D124 ) . C117 ) by L580 , FUNCT_4:11;
end;
suppose L583: C117 = ( IC ( SCMPDS ) );

thus L584: ( ( IExec (D115 , R9 , ( Initialize C112 )) ) . C117 ) = ( ( card C113 ) + 3 ) by L583 , L566 , L573 , L574
.= ( ( C112 +* D124 ) . C117 ) by L583 , FUNCT_4:113;
end;
end;
L586: ( dom ( IExec (D115 , R9 , ( Initialize C112 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C112 +* D124 ) ) by PARTFUN1:def 2;
thus L587: thesis by L586 , L575 , FUNCT_1:2;
end;
theorem
L588: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B123 being (State of ( SCMPDS )) holds (for B124 being (Program of ( SCMPDS )) holds (for B125 being Int_position holds (for B126 being Integer holds (( B123 . ( DataLoc (( B123 . B125 ) , B126) ) ) = ( 0 ) implies ( IC ( IExec (( while<>0 (B125 , B126 , B124) ) , R9 , ( Initialize B123 )) ) ) = ( ( card B124 ) + 3 )))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C118 being (State of ( SCMPDS ));
let C119 being (Program of ( SCMPDS ));
let C120 being Int_position;
let C121 being Integer;
assume L589: ( C118 . ( DataLoc (( C118 . C120 ) , C121) ) ) = ( 0 );
L590: ( IExec (( while<>0 (C120 , C121 , C119) ) , R9 , ( Initialize C118 )) ) = ( C118 +* ( Start-At (( ( card C119 ) + 3 ) , ( SCMPDS )) ) ) by L589 , L549;
thus L591: thesis by L590 , FUNCT_4:113;
end;
theorem
L592: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B127 being (State of ( SCMPDS )) holds (for B128 being (Program of ( SCMPDS )) holds (for B129 , B130 being Int_position holds (for B131 being Integer holds (( B127 . ( DataLoc (( B127 . B129 ) , B131) ) ) = ( 0 ) implies ( ( IExec (( while<>0 (B129 , B131 , B128) ) , R9 , ( Initialize B127 )) ) . B130 ) = ( B127 . B130 )))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C122 being (State of ( SCMPDS ));
let C123 being (Program of ( SCMPDS ));
let C124 , C125 being Int_position;
let C126 being Integer;
assume L593: ( C122 . ( DataLoc (( C122 . C124 ) , C126) ) ) = ( 0 );
L594: ( IExec (( while<>0 (C124 , C126 , C123) ) , R9 , ( Initialize C122 )) ) = ( C122 +* ( Start-At (( ( card C123 ) + 3 ) , ( SCMPDS )) ) ) by L593 , L549;
L595: (not C125 in ( dom ( Start-At (( ( card C123 ) + 3 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L596: thesis by L595 , L594 , FUNCT_4:11;
end;
L597: (for B132 being (Program of ( SCMPDS )) holds (for B133 being Int_position holds (for B134 being Integer holds ( Shift (B132 , 2) ) c= ( while<>0 (B133 , B134 , B132) ))))
proof
let C127 being (Program of ( SCMPDS ));
let C128 being Int_position;
let C129 being Integer;
set D125 = ( (C128 , C129) <>0_goto 2 );
set D126 = ( goto ( ( card C127 ) + 2 ) );
set D127 = ( goto ( - ( ( card C127 ) + 2 ) ) );
L598: (( card ( D125 ';' D126 ) ) = 2 & ( while<>0 (C128 , C129 , C127) ) = ( ( ( D125 ';' D126 ) ';' C127 ) ';' ( Load D127 ) )) by SCMPDS_4:def 3 , SCMP_GCD:5;
thus L599: thesis by L598 , SCMPDS_7:3;
end;
registration
let C130 being  shiftable (Program of ( SCMPDS ));
let C131 being Int_position;
let C132 being Integer;
cluster ( while<>0 (C131 , C132 , C130) ) ->  shiftable;
correctness
proof
set D128 = ( while<>0 (C131 , C132 , C130) );
set D129 = ( (C131 , C132) <>0_goto 2 );
set D130 = ( goto ( ( card C130 ) + 2 ) );
set D131 = ( ( D129 ';' D130 ) ';' C130 );
L600: ( card D131 ) = ( ( card ( D129 ';' D130 ) ) + ( card C130 ) ) by AFINSQ_1:17
.= ( 2 + ( card C130 ) ) by SCMP_GCD:5;
L601: (D131 = ( ( ( Load D129 ) ';' ( Load D130 ) ) ';' C130 ) & ( ( card D131 ) + ( - ( ( card C130 ) + 2 ) ) ) = ( 0 )) by L600 , SCMPDS_4:def 4;
thus L602: thesis by L601 , SCMPDS_4:23;
end;
end;
registration
let C133 being  halt-free (Program of ( SCMPDS ));
let C134 being Int_position;
let C135 being Integer;
cluster ( while<>0 (C134 , C135 , C133) ) ->  halt-free;
correctness
proof
reconsider D132 = ( goto ( ( card C133 ) + 2 ) ) as  No-StopCode (Instruction of ( SCMPDS )) by SCMPDS_5:21;
reconsider D133 = ( goto ( - ( ( card C133 ) + 2 ) ) ) as  No-StopCode (Instruction of ( SCMPDS )) by SCMPDS_5:21;
L604: ( while<>0 (C134 , C135 , C133) ) = ( ( ( ( (C134 , C135) <>0_goto 2 ) ';' D132 ) ';' C133 ) ';' D133 );
thus L605: thesis by L604;
end;
end;
begin
scheme WhileNHalt { F13((State of ( SCMPDS ))) -> (Element of ( NAT )) , F14() -> ( 0 ) -started (State of ( SCMPDS )) , F15() -> (Instruction-Sequence of ( SCMPDS )) , F16() ->  halt-free  shiftable (Program of ( SCMPDS )) , F17() -> Int_position , F18() -> Integer , P3[set] } : (( while<>0 (F17() , F18() , F16()) ) is_closed_on F14() , F15() & ( while<>0 (F17() , F18() , F16()) ) is_halting_on F14() , F15())
provided
L607: (for B135 being ( 0 ) -started (State of ( SCMPDS )) holds ((P3[ B135 ] & F13(B135) = ( 0 )) implies ( B135 . ( DataLoc (( F14() . F17() ) , F18()) ) ) = ( 0 )))
and
L608: P3[ F14() ]
and
L609: (for B136 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P3[ B136 ] & ( B136 . F17() ) = ( F14() . F17() ) & ( B136 . ( DataLoc (( F14() . F17() ) , F18()) ) ) <> ( 0 )) implies (( ( IExec (F16() , R7 , B136) ) . F17() ) = ( B136 . F17() ) & F16() is_closed_on B136 , R7 & F16() is_halting_on B136 , R7 & F13(( Initialize ( IExec (F16() , R7 , B136) ) )) < F13(B136) & P3[ ( Initialize ( IExec (F16() , R7 , B136) ) ) ]))))
proof
L610: ( Initialize F14() ) = F14() by MEMSTR_0:44;
set D134 = ( (F17() , F18()) <>0_goto 2 );
set D135 = ( goto ( ( card F16() ) + 2 ) );
set D136 = ( goto ( - ( ( card F16() ) + 2 ) ) );
set D137 = ( while<>0 (F17() , F18() , F16()) );
set D138 = ( stop D137 );
set D139 = ( stop F16() );
set D140 = ( DataLoc (( F14() . F17() ) , F18()) );
defpred S7[ (Element of ( NAT )) ] means (for B137 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((F13(( Initialize B137 )) <= $1 & P3[ ( Initialize B137 ) ] & ( B137 . F17() ) = ( F14() . F17() )) implies (D137 is_closed_on B137 , R7 & D137 is_halting_on B137 , R7))));
L611: (for B138 being (Element of ( NAT )) holds (S7[ B138 ] implies S7[ ( B138 + 1 ) ]))
proof
let C136 being (Element of ( NAT ));
assume L612: S7[ C136 ];
L613:
now
let C137 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
L614: ( Initialize C137 ) = C137 by MEMSTR_0:44;
assume L615: F13(( Initialize C137 )) <= ( C136 + 1 );
assume L616: P3[ ( Initialize C137 ) ];
assume L617: ( C137 . F17() ) = ( F14() . F17() );
per cases ;
suppose L618: ( C137 . D140 ) = ( 0 );

thus L619: (D137 is_closed_on C137 , R7 & D137 is_halting_on C137 , R7) by L618 , L617 , L511;
end;
suppose L620: ( C137 . D140 ) <> ( 0 );

L621: ( ( IExec (F16() , R7 , C137) ) . F17() ) = ( C137 . F17() ) by L609 , L616 , L617 , L620 , L614;
L622: ( 0 ) in ( dom D138 ) by COMPOS_1:36;
L623: D137 = ( D134 ';' ( ( D135 ';' F16() ) ';' D136 ) ) by L509;
L624: (not D140 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
set D141 = ( Initialize C137 );
set D142 = ( R7 +* D139 );
set D143 = ( Initialize C137 );
set D144 = ( R7 +* D138 );
set D145 = ( Comput (D144 , D143 , 1) );
set D146 = D144;
L625: D139 c= D142 by FUNCT_4:25;
set D147 = ( LifeSpan (D142 , D141) );
set D148 = ( Comput (D146 , D145 , D147) );
set D149 = D146;
set D150 = ( ( card F16() ) + 2 );
L626: ( IC D143 ) = ( 0 ) by MEMSTR_0:47;
set D151 = ( D147 + 1 );
set D152 = ( Comput (D144 , D143 , D151) );
set D153 = D144;
set D154 = ( Comput (D144 , D143 , ( D151 + 1 )) );
set D155 = D144;
L627: ( ( card F16() ) + 2 ) < ( ( card F16() ) + 3 ) by XREAL_1:6;
L628: D150 in ( dom D137 ) by L627 , L496;
L629: D138 c= D144 by FUNCT_4:25;
L630: D137 c= D138 by AFINSQ_1:74;
L631: D137 c= D144 by L630 , L629 , XBOOLE_1:1;
L632: ( Shift (F16() , 2) ) c= D137 by L597;
L633: ( Shift (F16() , 2) ) c= D144 by L632 , L631 , XBOOLE_1:1;
L634: ( Shift (F16() , 2) ) c= D146 by L633;
L635: ( Comput (D144 , D143 , ( ( 0 ) + 1 )) ) = ( Following (D144 , ( Comput (D144 , D143 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D144 , D143) )
.= ( Exec (D134 , D143) ) by L623 , SCMPDS_6:11;
L636: (for R6 being Int_position holds ( D141 . R6 ) = ( D145 . R6 )) by L635 , SCMPDS_2:55;
L637: ( DataPart D141 ) = ( DataPart D145 ) by L636 , SCMPDS_4:8;
L638: F16() is_halting_on C137 , R7 by L609 , L616 , L617 , L620 , L614;
L639: D142 halts_on D141 by L638 , SCMPDS_6:def 3;
L640: ( D142 +* D139 ) halts_on ( Initialize D141 ) by L639;
L641: F16() is_halting_on D141 , D142 by L640 , SCMPDS_6:def 3;
L642: ( IExec (F16() , R7 , ( Initialize C137 )) ) = ( Result (D142 , D141) ) by SCMPDS_4:def 5;
L643: P3[ ( Initialize ( IExec (F16() , R7 , ( Initialize C137 )) ) ) ] by L609 , L616 , L617 , L620 , L614;
L644: F16() is_closed_on C137 , R7 by L609 , L616 , L617 , L620 , L614;
L645: F16() is_closed_on D141 , D142 by L644 , SCMPDS_6:24;
L646: (not F17() in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L647: ( D143 . ( DataLoc (( D143 . F17() ) , F18()) ) ) = ( D143 . D140 ) by L646 , L617 , FUNCT_4:11
.= ( C137 . D140 ) by L624 , FUNCT_4:11;
L648: ( IC D145 ) = ( ICplusConst (D143 , 2) ) by L647 , L620 , L635 , SCMPDS_2:55
.= ( ( 0 ) + 2 ) by L626 , SCMPDS_6:12;
L649: ( IC D148 ) = D150 by L648 , L625 , L641 , L645 , L637 , L634 , SCMPDS_7:18;
L650: ( D153 /. ( IC D152 ) ) = ( D153 . ( IC D152 ) ) by PBOOLE:143;
L651: D152 = D148 by EXTPRO_1:4;
L652: ( CurInstr (D153 , D152) ) = ( D149 . D150 ) by L651 , L625 , L641 , L645 , L648 , L637 , L634 , L650 , SCMPDS_7:18
.= ( D146 . D150 )
.= ( D144 . D150 )
.= ( D137 . D150 ) by L628 , L631 , GRFUNC_1:2
.= D136 by L503;
L653: D154 = ( Following (D144 , D152) ) by EXTPRO_1:3
.= ( Exec (D136 , D152) ) by L652;
L654: ( IC D154 ) = ( ICplusConst (D152 , ( ( 0 ) - ( ( card F16() ) + 2 ) )) ) by L653 , SCMPDS_2:54
.= ( 0 ) by L649 , L651 , SCMPDS_7:1;
L655: ( Initialize D154 ) = D154 by L654 , MEMSTR_0:46;
L656: ( D155 +* D138 ) = D155;
L657: ( DataPart ( Comput (D142 , D141 , D147) ) ) = ( DataPart D148 ) by L625 , L641 , L645 , L648 , L637 , L634 , SCMPDS_7:18;
L658: ( DataPart D148 ) = ( DataPart ( Result (D142 , D141) ) ) by L657 , L639 , EXTPRO_1:23
.= ( DataPart ( Result (D142 , D141) ) )
.= ( DataPart ( IExec (F16() , R7 , ( Initialize C137 )) ) ) by SCMPDS_4:def 5;
L659: ( InsCode D136 ) = 14 by SCMPDS_2:12;
L660: ( InsCode D136 ) in { ( 0 ) , 4 , 5 , 6 , 14 } by L659 , ENUMSET1:def 3;
L661: ( Initialize D154 ) = ( Initialize D152 ) by L660 , L653 , SCMPDS_8:3
.= ( Initialize ( IExec (F16() , R7 , ( Initialize C137 )) ) ) by L658 , L651 , MEMSTR_0:80;
L662:
now
L663: F13(( Initialize ( IExec (F16() , R7 , ( Initialize C137 )) ) )) < F13(( Initialize C137 )) by L609 , L616 , L617 , L620 , L614;
L664: F13(( Initialize D154 )) < ( C136 + 1 ) by L663 , L615 , L661 , XXREAL_0:2;
assume L665: F13(( Initialize D154 )) > C136;
thus L666: contradiction by L665 , L664 , INT_1:7;
end;
L667: ( D148 . F17() ) = ( ( Comput (D142 , D141 , D147) ) . F17() ) by L657 , SCMPDS_4:8
.= ( ( Result (D142 , D141) ) . F17() ) by L639 , EXTPRO_1:23
.= ( F14() . F17() ) by L617 , L621 , L642 , L614;
L668: ( D154 . F17() ) = ( D152 . F17() ) by L653 , SCMPDS_2:54
.= ( F14() . F17() ) by L667 , EXTPRO_1:4;
L669: ( ( Initialize D154 ) . F17() ) = ( D154 . F17() ) by SCMPDS_5:15;
L670: P3[ ( Initialize ( Initialize D154 ) ) ] by L643 , L661;
L671: (D137 is_closed_on ( Initialize D154 ) , D155 & D137 is_halting_on ( Initialize D154 ) , D155) by L670 , L612 , L662 , L668 , L669;
L672: D137 is_closed_on D154 , D155
proof
L673: (for B139 being (Element of ( NAT )) holds ( IC ( Comput (( D155 +* ( stop D137 ) ) , ( Initialize ( Initialize D154 ) ) , B139) ) ) in ( dom ( stop D137 ) )) by L671 , SCMPDS_6:def 2;
thus L674: thesis by L673 , SCMPDS_6:def 2;
end;
L675:
now
let C138 being (Element of ( NAT ));
per cases ;
suppose L676: C138 < ( D151 + 1 );

L677: C138 <= D151 by L676 , INT_1:7;
thus L678:now
per cases  by L677 , NAT_1:8;
suppose L679: C138 <= D147;

thus L680:now
per cases ;
suppose L681: C138 = ( 0 );

thus L682: ( IC ( Comput (D144 , D143 , C138) ) ) in ( dom D138 ) by L681 , L622 , L626 , EXTPRO_1:2;
end;
suppose L683: C138 <> ( 0 );

consider C139 being Nat such that L684: C138 = ( C139 + 1 ) by L683 , NAT_1:6;
reconsider D156 = C139 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D157 = ( IC ( Comput (D142 , D141 , D156) ) ) as (Element of ( NAT ));
L685: D156 < C138 by L684 , XREAL_1:29;
L686: D156 < D147 by L685 , L679 , XXREAL_0:2;
L687: ( ( IC ( Comput (D142 , D141 , D156) ) ) + 2 ) = ( IC ( Comput (D146 , D145 , D156) ) ) by L686 , L625 , L641 , L645 , L648 , L637 , L634 , SCMPDS_7:16;
L688: ( IC ( Comput (D144 , D143 , C138) ) ) = ( D157 + 2 ) by L687 , L684 , EXTPRO_1:4;
L689: ( IC ( Comput (D142 , D141 , D156) ) ) in ( dom D139 ) by L644 , SCMPDS_6:def 2;
L690: D157 < ( card D139 ) by L689 , AFINSQ_1:66;
L691: D157 < ( ( card F16() ) + 1 ) by L690 , COMPOS_1:55;
L692: ( D157 + 2 ) < ( ( ( card F16() ) + 1 ) + 2 ) by L691 , XREAL_1:6;
L693: ( ( card F16() ) + 3 ) < ( ( card F16() ) + 4 ) by XREAL_1:6;
L694: ( D157 + 2 ) < ( ( card F16() ) + 4 ) by L693 , L692 , XXREAL_0:2;
L695: ( D157 + 2 ) < ( card D138 ) by L694 , L494;
thus L696: ( IC ( Comput (D144 , D143 , C138) ) ) in ( dom D138 ) by L695 , L688 , AFINSQ_1:66;
end;
end;
end;
suppose L681: C138 = D151;

L682: D150 in ( dom D138 ) by L628 , COMPOS_1:62;
thus L683: ( IC ( Comput (D144 , D143 , C138) ) ) in ( dom D138 ) by L682 , L625 , L641 , L645 , L648 , L637 , L634 , L651 , L681 , SCMPDS_7:18;
end;
end;
end;
suppose L679: C138 >= ( D151 + 1 );

consider C140 being Nat such that L680: C138 = ( ( D151 + 1 ) + C140 ) by L679 , NAT_1:10;
reconsider D158 = C140 as (Element of ( NAT )) by ORDINAL1:def 12;
L681: ( Comput (D144 , D143 , C138) ) = ( Comput (( D155 +* D138 ) , ( Initialize D154 ) , D158) ) by L680 , L655 , EXTPRO_1:4;
thus L682: ( IC ( Comput (D144 , D143 , C138) ) ) in ( dom D138 ) by L681 , L672 , SCMPDS_6:def 2;
end;
end;
thus L684: D137 is_closed_on C137 , R7 by L675 , SCMPDS_6:def 2;
L685: D137 is_halting_on D154 , D155
proof
L686: ( D155 +* ( stop D137 ) ) halts_on ( Initialize ( Initialize D154 ) ) by L671 , SCMPDS_6:def 3;
thus L687: thesis by L686 , SCMPDS_6:def 3;
end;
L688: D155 halts_on D154 by L685 , L656 , L655 , SCMPDS_6:def 3;
L689: D144 halts_on D154 by L688;
L690: D144 halts_on D143 by L689 , EXTPRO_1:22;
thus L691: D137 is_halting_on C137 , R7 by L690 , SCMPDS_6:def 3;
end;
end;
thus L693: thesis by L613;
end;
set D159 = F13(F14());
L694: S7[ ( 0 ) ]
proof
let C141 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
assume that
L695: (F13(( Initialize C141 )) <= ( 0 ) & P3[ ( Initialize C141 ) ])
and
L696: ( C141 . F17() ) = ( F14() . F17() );
L697: F13(( Initialize C141 )) >= ( 0 ) by NAT_1:2;
L698: ( ( Initialize C141 ) . D140 ) = ( C141 . D140 ) by SCMPDS_5:15;
L699: ( C141 . D140 ) = ( 0 ) by L698 , L607 , L695 , L697 , XXREAL_0:1;
thus L700: thesis by L699 , L696 , L511;
end;
L701: (for B140 being (Element of ( NAT )) holds S7[ B140 ]) from NAT_1:sch 1(L694 , L611);
L702: S7[ D159 ] by L701;
thus L703: thesis by L702 , L608 , L610;
end;
scheme WhileNExec { F19((State of ( SCMPDS ))) -> (Element of ( NAT )) , F20() -> ( 0 ) -started (State of ( SCMPDS )) , F21() -> (Instruction-Sequence of ( SCMPDS )) , F22() ->  halt-free  shiftable (Program of ( SCMPDS )) , F23() -> Int_position , F24() -> Integer , P4[set] } : ( IExec (( while<>0 (F23() , F24() , F22()) ) , F21() , F20()) ) = ( IExec (( while<>0 (F23() , F24() , F22()) ) , F21() , ( Initialize ( IExec (F22() , F21() , F20()) ) )) )
provided
L704: ( F20() . ( DataLoc (( F20() . F23() ) , F24()) ) ) <> ( 0 )
and
L705: (for B141 being ( 0 ) -started (State of ( SCMPDS )) holds ((P4[ B141 ] & F19(B141) = ( 0 )) implies ( B141 . ( DataLoc (( F20() . F23() ) , F24()) ) ) = ( 0 )))
and
L706: P4[ F20() ]
and
L707: (for B142 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P4[ B142 ] & ( B142 . F23() ) = ( F20() . F23() ) & ( B142 . ( DataLoc (( F20() . F23() ) , F24()) ) ) <> ( 0 )) implies (( ( IExec (F22() , R7 , B142) ) . F23() ) = ( B142 . F23() ) & F22() is_closed_on B142 , R7 & F22() is_halting_on B142 , R7 & F19(( Initialize ( IExec (F22() , R7 , B142) ) )) < F19(B142) & P4[ ( Initialize ( IExec (F22() , R7 , B142) ) ) ]))))
proof
L708: ( Initialize F20() ) = F20() by MEMSTR_0:44;
set D160 = ( while<>0 (F23() , F24() , F22()) );
set D161 = F20();
set D162 = ( F21() +* ( stop D160 ) );
set D163 = F20();
set D164 = ( F21() +* ( stop F22() ) );
set D165 = ( ( LifeSpan (D164 , D163) ) + 2 );
set D166 = ( Initialize ( IExec (F22() , F21() , F20()) ) );
set D167 = ( LifeSpan (D162 , D166) );
L709: ( stop F22() ) c= D164 by FUNCT_4:25;
L710: F22() is_closed_on F20() , F21() by L704 , L706 , L707;
L711: F22() is_closed_on D163 , D164 by L710 , L708 , SCMPDS_6:24;
L712: F22() is_halting_on F20() , F21() by L704 , L706 , L707;
L713: D164 halts_on D163 by L712 , L708 , SCMPDS_6:def 3;
L714: ( D164 +* ( stop F22() ) ) halts_on ( Initialize D163 ) by L713 , L708;
L715: F22() is_halting_on D163 , D164 by L714 , SCMPDS_6:def 3;
set D168 = ( Comput (D162 , D161 , 1) );
set D169 = D162;
set D170 = ( (F23() , F24()) <>0_goto 2 );
set D171 = ( goto ( ( card F22() ) + 2 ) );
set D172 = ( goto ( - ( ( card F22() ) + 2 ) ) );
set D173 = ( DataLoc (( F20() . F23() ) , F24()) );
L716: ( IC D161 ) = ( 0 ) by L708 , MEMSTR_0:47;
set D174 = ( LifeSpan (D164 , D163) );
set D175 = ( Comput (D169 , D168 , D174) );
set D176 = D169;
set D177 = ( ( card F22() ) + 2 );
L717: D160 = ( D170 ';' ( ( D171 ';' F22() ) ';' D172 ) ) by L509;
set D178 = ( D174 + 1 );
set D179 = ( Comput (D162 , D161 , D178) );
set D180 = D162;
L718: ( ( card F22() ) + 2 ) < ( ( card F22() ) + 3 ) by XREAL_1:6;
L719: D177 in ( dom D160 ) by L718 , L496;
set D181 = ( Comput (D162 , D161 , ( D178 + 1 )) );
set D182 = D162;
L720: ( IExec (F22() , F21() , F20()) ) = ( Result (D164 , D163) ) by SCMPDS_4:def 5;
L721: ( stop D160 ) c= D162 by FUNCT_4:25;
L722: D160 c= ( stop D160 ) by AFINSQ_1:74;
L723: D160 c= D162 by L722 , L721 , XBOOLE_1:1;
deffunc H5((State of ( SCMPDS ))) = F19($1);
L724: (for B143 being ( 0 ) -started (State of ( SCMPDS )) holds ((P4[ B143 ] & H5(B143) = ( 0 )) implies ( B143 . ( DataLoc (( F20() . F23() ) , F24()) ) ) = ( 0 ))) by L705;
L725: (for B144 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P4[ B144 ] & ( B144 . F23() ) = ( F20() . F23() ) & ( B144 . ( DataLoc (( F20() . F23() ) , F24()) ) ) <> ( 0 )) implies (( ( IExec (F22() , R7 , B144) ) . F23() ) = ( B144 . F23() ) & F22() is_closed_on B144 , R7 & F22() is_halting_on B144 , R7 & H5(( Initialize ( IExec (F22() , R7 , B144) ) )) < H5(B144) & P4[ ( Initialize ( IExec (F22() , R7 , B144) ) ) ])))) by L707;
L726: ( Comput (D162 , D161 , ( ( 0 ) + 1 )) ) = ( Following (D162 , ( Comput (D162 , D161 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D162 , D161) )
.= ( Exec (D170 , D161) ) by L717 , L708 , SCMPDS_6:11;
L727: ( Shift (F22() , 2) ) c= D160 by L597;
L728: ( Shift (F22() , 2) ) c= D162 by L727 , L723 , XBOOLE_1:1;
L729: ( Shift (F22() , 2) ) c= D169 by L728;
L730: (for R6 being Int_position holds ( D163 . R6 ) = ( D168 . R6 )) by L726 , SCMPDS_2:55;
L731: ( DataPart D163 ) = ( DataPart D168 ) by L730 , SCMPDS_4:8;
L732: ( IC D168 ) = ( ICplusConst (D161 , 2) ) by L704 , L726 , SCMPDS_2:55
.= ( ( 0 ) + 2 ) by L716 , SCMPDS_6:12;
L733: ( IC D175 ) = D177 by L732 , L709 , L715 , L711 , L731 , L729 , SCMPDS_7:18;
L734: ( D180 /. ( IC D179 ) ) = ( D180 . ( IC D179 ) ) by PBOOLE:143;
L735: D179 = D175 by EXTPRO_1:4;
L736: ( CurInstr (D180 , D179) ) = ( D176 . D177 ) by L735 , L709 , L715 , L711 , L732 , L731 , L729 , L734 , SCMPDS_7:18
.= ( D169 . D177 )
.= ( D162 . D177 )
.= ( D160 . D177 ) by L719 , L723 , GRFUNC_1:2
.= D172 by L503;
L737: D181 = ( Following (D162 , D179) ) by EXTPRO_1:3
.= ( Exec (D172 , D179) ) by L736;
L738: ( IC D181 ) = ( ICplusConst (D179 , ( ( 0 ) - ( ( card F22() ) + 2 ) )) ) by L737 , SCMPDS_2:54
.= ( 0 ) by L733 , L735 , SCMPDS_7:1;
L739: ( IC D166 ) = ( IC ( Comput (D162 , D161 , D165) ) ) by L738 , MEMSTR_0:47;
L740: ( DataPart ( Comput (D164 , D163 , D174) ) ) = ( DataPart D175 ) by L709 , L715 , L711 , L732 , L731 , L729 , SCMPDS_7:18;
L741:
now
let C142 being Int_position;
L742: (not C142 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L743: ( D175 . C142 ) = ( ( Comput (D164 , D163 , D174) ) . C142 ) by L740 , SCMPDS_4:8
.= ( ( Result (D164 , D163) ) . C142 ) by L713 , EXTPRO_1:23
.= ( ( IExec (F22() , F21() , F20()) ) . C142 ) by L720;
thus L744: ( D181 . C142 ) = ( ( IExec (F22() , F21() , F20()) ) . C142 ) by L743 , L735 , L737 , SCMPDS_2:54
.= ( D166 . C142 ) by L742 , FUNCT_4:11;
end;
L745: ( DataPart D181 ) = ( DataPart D166 ) by L741 , SCMPDS_4:8;
set D183 = ( LifeSpan (D162 , D161) );
L746: P4[ F20() ] by L706;
L747: (D160 is_closed_on F20() , F21() & D160 is_halting_on F20() , F21()) from WhileNHalt(L724 , L746 , L725);
L748: D162 halts_on D161 by L747 , L708 , SCMPDS_6:def 3;
deffunc H6((State of ( SCMPDS ))) = H5($1);
set D184 = ( IExec (F22() , F21() , F20()) );
set D185 = ( DataLoc (( D184 . F23() ) , F24()) );
set D186 = F21();
L749: ( ( IExec (F22() , F21() , F20()) ) . F23() ) = ( F20() . F23() ) by L704 , L706 , L707;
L750: ( ( Initialize D184 ) . F23() ) = ( D184 . F23() ) by SCMPDS_5:15;
L751: (for B145 being ( 0 ) -started (State of ( SCMPDS )) holds ((P4[ B145 ] & H6(B145) = ( 0 )) implies ( B145 . ( DataLoc (( ( Initialize D184 ) . F23() ) , F24()) ) ) = ( 0 ))) by L705 , L749 , L750;
L752: P4[ ( Initialize D184 ) ] by L704 , L706 , L707;
L753: (for B146 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P4[ B146 ] & ( B146 . F23() ) = ( ( Initialize D184 ) . F23() ) & ( B146 . ( DataLoc (( ( Initialize D184 ) . F23() ) , F24()) ) ) <> ( 0 )) implies (( ( IExec (F22() , R7 , B146) ) . F23() ) = ( B146 . F23() ) & F22() is_closed_on B146 , R7 & F22() is_halting_on B146 , R7 & H6(( Initialize ( IExec (F22() , R7 , B146) ) )) < H6(B146) & P4[ ( Initialize ( IExec (F22() , R7 , B146) ) ) ])))) by L707 , L749 , L750;
L754: (D160 is_closed_on ( Initialize D184 ) , F21() & D160 is_halting_on ( Initialize D184 ) , F21()) from WhileNHalt(L751 , L752 , L753);
L755: D160 is_halting_on D184 , F21()
proof
L756: ( F21() +* ( stop D160 ) ) halts_on ( Initialize ( Initialize D184 ) ) by L754 , SCMPDS_6:def 3;
thus L757: thesis by L756 , SCMPDS_6:def 3;
end;
L758: D162 halts_on D166 by L755 , SCMPDS_6:def 3;
L759: ( Comput (D162 , D161 , D165) ) = D166 by L745 , L739 , MEMSTR_0:78;
L760: ( CurInstr (D162 , ( Comput (D162 , D161 , D165) )) ) = D170 by L759 , L717 , SCMPDS_6:11;
L761: D183 > D165 by L760 , L748 , EXTPRO_1:36 , SCMPDS_6:16;
consider C143 being Nat such that L762: D183 = ( D165 + C143 ) by L761 , NAT_1:10;
reconsider D187 = C143 as (Element of ( NAT )) by ORDINAL1:def 12;
L763: ( IC ( Comput (D162 , D161 , ( D165 + D167 )) ) ) = ( IC ( Comput (D162 , D166 , D167) ) ) by L759 , EXTPRO_1:4;
L764: ( CurInstr (D162 , ( Comput (D162 , D161 , ( D165 + D167 )) )) ) = ( CurInstr (D162 , ( Comput (D162 , D166 , D167) )) ) by L763
.= ( halt ( SCMPDS ) ) by L758 , EXTPRO_1:def 15;
L765: ( D165 + D167 ) >= D183 by L764 , L748 , EXTPRO_1:def 15;
L766: D167 >= D187 by L765 , L762 , XREAL_1:6;
L767: ( Comput (D162 , D161 , D183) ) = ( Comput (D162 , D166 , D187) ) by L759 , L762 , EXTPRO_1:4;
L768: ( CurInstr (D162 , ( Comput (D162 , D166 , D187) )) ) = ( halt ( SCMPDS ) ) by L767 , L748 , EXTPRO_1:def 15;
L769: D187 >= D167 by L768 , L758 , EXTPRO_1:def 15;
L770: D187 = D167 by L769 , L766 , XXREAL_0:1;
L771: ( Result (D162 , D161) ) = ( Comput (D162 , D166 , D167) ) by L770 , L748 , L767 , EXTPRO_1:23;
thus L772: ( IExec (D160 , F21() , F20()) ) = ( Comput (D162 , D166 , D167) ) by L771 , SCMPDS_4:def 5
.= ( Result (D162 , D166) ) by L758 , EXTPRO_1:23
.= ( IExec (D160 , F21() , ( Initialize ( IExec (F22() , F21() , F20()) ) )) ) by SCMPDS_4:def 5;
end;
scheme WhileNEnd { F25((State of ( SCMPDS ))) -> (Element of ( NAT )) , F26() -> ( 0 ) -started (State of ( SCMPDS )) , F27() -> (Instruction-Sequence of ( SCMPDS )) , F28() ->  halt-free  shiftable (Program of ( SCMPDS )) , F29() -> Int_position , F30() -> Integer , P5[set] } : (F25(( Initialize ( IExec (( while<>0 (F29() , F30() , F28()) ) , F27() , F26()) ) )) = ( 0 ) & P5[ ( Initialize ( IExec (( while<>0 (F29() , F30() , F28()) ) , F27() , F26()) ) ) ])
provided
L773: (for B147 being ( 0 ) -started (State of ( SCMPDS )) holds (P5[ B147 ] implies (F25(B147) = ( 0 ) iff ( B147 . ( DataLoc (( F26() . F29() ) , F30()) ) ) = ( 0 ))))
and
L774: P5[ F26() ]
and
L775: (for B148 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P5[ B148 ] & ( B148 . F29() ) = ( F26() . F29() ) & ( B148 . ( DataLoc (( F26() . F29() ) , F30()) ) ) <> ( 0 )) implies (( ( IExec (F28() , R7 , B148) ) . F29() ) = ( B148 . F29() ) & F28() is_closed_on B148 , R7 & F28() is_halting_on B148 , R7 & F25(( Initialize ( IExec (F28() , R7 , B148) ) )) < F25(B148) & P5[ ( Initialize ( IExec (F28() , R7 , B148) ) ) ]))))
proof
set D188 = ( DataLoc (( F26() . F29() ) , F30()) );
set D189 = ( while<>0 (F29() , F30() , F28()) );
defpred S8[ (Element of ( NAT )) ] means (for B149 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((F25(B149) <= $1 & ( B149 . F29() ) = ( F26() . F29() ) & P5[ B149 ]) implies (F25(( Initialize ( IExec (D189 , R7 , B149) ) )) = ( 0 ) & P5[ ( Initialize ( IExec (D189 , R7 , B149) ) ) ]))));
L776: S8[ ( 0 ) ]
proof
let C144 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
L777: ( Initialize C144 ) = C144 by MEMSTR_0:44;
assume that
L778: F25(C144) <= ( 0 )
and
L779: ( C144 . F29() ) = ( F26() . F29() )
and
L780: P5[ C144 ];
L781: F25(C144) >= ( 0 ) by NAT_1:2;
L782: F25(C144) = ( 0 ) by L781 , L778 , XXREAL_0:1;
L783: ( C144 . ( DataLoc (( C144 . F29() ) , F30()) ) ) = ( 0 ) by L782 , L773 , L779 , L780;
L784: (for B150 being Int_position holds ( ( IExec (D189 , R7 , C144) ) . B150 ) = ( C144 . B150 )) by L783 , L592 , L777;
thus L785: thesis by L784 , L780 , L782 , L777 , SCPISORT:4;
end;
L786:
now
let C145 being (Element of ( NAT ));
assume L787: S8[ C145 ];
L788:
now
let C146 being ( 0 ) -started (State of ( SCMPDS ));
let R8 being (Instruction-Sequence of ( SCMPDS ));
assume that
L789: F25(C146) <= ( C145 + 1 )
and
L790: ( C146 . F29() ) = ( F26() . F29() )
and
L791: P5[ C146 ];
per cases ;
suppose L792: F25(C146) = ( 0 );

thus L793: (F25(( Initialize ( IExec (D189 , R8 , C146) ) )) = ( 0 ) & P5[ ( Initialize ( IExec (D189 , R8 , C146) ) ) ]) by L792 , L776 , L790 , L791;
end;
suppose L794: F25(C146) <> ( 0 );

set D190 = ( IExec (F28() , R8 , C146) );
L795: ( C146 . D188 ) <> ( 0 ) by L773 , L791 , L794;
L796: (( D190 . F29() ) = ( F26() . F29() ) & P5[ ( Initialize D190 ) ]) by L795 , L775 , L790 , L791;
deffunc H7((State of ( SCMPDS ))) = F25($1);
L797: P5[ C146 ] by L791;
L798: (for B151 being ( 0 ) -started (State of ( SCMPDS )) holds ((P5[ B151 ] & H7(B151) = ( 0 )) implies ( B151 . ( DataLoc (( C146 . F29() ) , F30()) ) ) = ( 0 ))) by L773 , L790;
L799: H7(( Initialize D190 )) < H7(C146) by L775 , L790 , L791 , L795;
L800: ( H7(( Initialize D190 )) + 1 ) <= H7(C146) by L799 , INT_1:7;
L801: ( H7(( Initialize D190 )) + 1 ) <= ( C145 + 1 ) by L800 , L789 , XXREAL_0:2;
L802: H7(( Initialize D190 )) <= C145 by L801 , XREAL_1:6;
L803: (for B152 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((P5[ B152 ] & ( B152 . F29() ) = ( C146 . F29() ) & ( B152 . ( DataLoc (( C146 . F29() ) , F30()) ) ) <> ( 0 )) implies (( ( IExec (F28() , R7 , B152) ) . F29() ) = ( B152 . F29() ) & F28() is_closed_on B152 , R7 & F28() is_halting_on B152 , R7 & H7(( Initialize ( IExec (F28() , R7 , B152) ) )) < H7(B152) & P5[ ( Initialize ( IExec (F28() , R7 , B152) ) ) ])))) by L775 , L790;
L804: ( C146 . ( DataLoc (( C146 . F29() ) , F30()) ) ) <> ( 0 ) by L773 , L790 , L791 , L794;
L805: ( IExec (D189 , R8 , C146) ) = ( IExec (D189 , R8 , ( Initialize D190 )) ) from WhileNExec(L804 , L798 , L797 , L803);
L806: ( ( Initialize D190 ) . F29() ) = ( D190 . F29() ) by SCMPDS_5:15;
thus L807: (H7(( Initialize ( IExec (D189 , R8 , C146) ) )) = ( 0 ) & P5[ ( Initialize ( IExec (D189 , R8 , C146) ) ) ]) by L806 , L787 , L802 , L796 , L805;
end;
end;
thus L809: S8[ ( C145 + 1 ) ] by L788;
end;
L810: (for B153 being (Element of ( NAT )) holds S8[ B153 ]) from NAT_1:sch 1(L776 , L786);
L811: S8[ F25(F26()) ] by L810;
thus L812: thesis by L811 , L774;
end;
theorem
L813: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B154 being ( 0 ) -started (State of ( SCMPDS )) holds (for B155 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B156 , B157 , B158 being Int_position holds (for B159 , B160 being Integer holds ((( card B155 ) > ( 0 ) & ( B154 . B156 ) = B160 & ( B154 . B157 ) > ( 0 ) & ( B154 . B158 ) > ( 0 ) & ( B154 . ( DataLoc (B160 , B159) ) ) = ( ( B154 . B157 ) - ( B154 . B158 ) ) & (for B161 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((( B161 . B157 ) > ( 0 ) & ( B161 . B158 ) > ( 0 ) & ( B161 . B156 ) = B160 & ( B161 . ( DataLoc (B160 , B159) ) ) = ( ( B161 . B157 ) - ( B161 . B158 ) ) & ( B161 . B157 ) <> ( B161 . B158 )) implies (( ( IExec (B155 , R7 , B161) ) . B156 ) = B160 & B155 is_closed_on B161 , R7 & B155 is_halting_on B161 , R7 & (( B161 . B157 ) > ( B161 . B158 ) implies (( ( IExec (B155 , R7 , B161) ) . B157 ) = ( ( B161 . B157 ) - ( B161 . B158 ) ) & ( ( IExec (B155 , R7 , B161) ) . B158 ) = ( B161 . B158 ))) & (( B161 . B157 ) <= ( B161 . B158 ) implies (( ( IExec (B155 , R7 , B161) ) . B158 ) = ( ( B161 . B158 ) - ( B161 . B157 ) ) & ( ( IExec (B155 , R7 , B161) ) . B157 ) = ( B161 . B157 ))) & ( ( IExec (B155 , R7 , B161) ) . ( DataLoc (B160 , B159) ) ) = ( ( ( IExec (B155 , R7 , B161) ) . B157 ) - ( ( IExec (B155 , R7 , B161) ) . B158 ) )))))) implies (( while<>0 (B156 , B159 , B155) ) is_closed_on B154 , R9 & ( while<>0 (B156 , B159 , B155) ) is_halting_on B154 , R9 & (( B154 . ( DataLoc (( B154 . B156 ) , B159) ) ) <> ( 0 ) implies ( IExec (( while<>0 (B156 , B159 , B155) ) , R9 , B154) ) = ( IExec (( while<>0 (B156 , B159 , B155) ) , R9 , ( Initialize ( IExec (B155 , R9 , B154) ) )) )))))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C147 being ( 0 ) -started (State of ( SCMPDS ));
let C148 being  halt-free  shiftable (Program of ( SCMPDS ));
let C149 , C150 , C151 being Int_position;
let C152 , C153 being Integer;
set D191 = ( DataLoc (( C147 . C149 ) , C152) );
assume L814: ( card C148 ) > ( 0 );
consider C154 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L815: (for B162 being (State of ( SCMPDS )) holds ((( B162 . C150 ) = ( B162 . C151 ) implies ( C154 . B162 ) = ( 0 )) & (( B162 . C150 ) <> ( B162 . C151 ) implies ( C154 . B162 ) = ( max (( abs ( B162 . C150 ) ) , ( abs ( B162 . C151 ) )) )))) by L10;
deffunc H8((State of ( SCMPDS ))) = ( C154 . $1 );
defpred S9[ set ] means (ex B163 being (State of ( SCMPDS )) st (B163 = $1 & ( B163 . C150 ) > ( 0 ) & ( B163 . C151 ) > ( 0 ) & ( B163 . ( DataLoc (C153 , C152) ) ) = ( ( B163 . C150 ) - ( B163 . C151 ) )));
assume that
L816: ( C147 . C149 ) = C153
and
L817: ( C147 . C150 ) > ( 0 )
and
L818: ( C147 . C151 ) > ( 0 )
and
L819: ( C147 . ( DataLoc (C153 , C152) ) ) = ( ( C147 . C150 ) - ( C147 . C151 ) );
assume L820: (for B164 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((( B164 . C150 ) > ( 0 ) & ( B164 . C151 ) > ( 0 ) & ( B164 . C149 ) = C153 & ( B164 . ( DataLoc (C153 , C152) ) ) = ( ( B164 . C150 ) - ( B164 . C151 ) ) & ( B164 . C150 ) <> ( B164 . C151 )) implies (( ( IExec (C148 , R7 , B164) ) . C149 ) = C153 & C148 is_closed_on B164 , R7 & C148 is_halting_on B164 , R7 & (( B164 . C150 ) > ( B164 . C151 ) implies (( ( IExec (C148 , R7 , B164) ) . C150 ) = ( ( B164 . C150 ) - ( B164 . C151 ) ) & ( ( IExec (C148 , R7 , B164) ) . C151 ) = ( B164 . C151 ))) & (( B164 . C150 ) <= ( B164 . C151 ) implies (( ( IExec (C148 , R7 , B164) ) . C151 ) = ( ( B164 . C151 ) - ( B164 . C150 ) ) & ( ( IExec (C148 , R7 , B164) ) . C150 ) = ( B164 . C150 ))) & ( ( IExec (C148 , R7 , B164) ) . ( DataLoc (C153 , C152) ) ) = ( ( ( IExec (C148 , R7 , B164) ) . C150 ) - ( ( IExec (C148 , R7 , B164) ) . C151 ) )))));
L821:
now
let C155 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
assume that
L822: S9[ C155 ]
and
L823: ( C155 . C149 ) = ( C147 . C149 )
and
L824: ( C155 . D191 ) <> ( 0 );
set D192 = ( IExec (C148 , R7 , C155) );
set D193 = ( Initialize D192 );
set D194 = C155;
set D195 = ( ( IExec (C148 , R7 , C155) ) . C150 );
set D196 = ( ( IExec (C148 , R7 , C155) ) . C151 );
consider C156 being (State of ( SCMPDS )) such that L825: C156 = C155 and L826: ( C156 . C150 ) > ( 0 ) and L827: ( C156 . C151 ) > ( 0 ) and L828: ( C156 . ( DataLoc (C153 , C152) ) ) = ( ( C156 . C150 ) - ( C156 . C151 ) ) by L822;
L829: ( C155 . C150 ) > ( 0 ) by L825 , L826;
L830: ( C155 . C151 ) > ( 0 ) by L825 , L827;
L831: ( C155 . ( DataLoc (C153 , C152) ) ) = ( ( C156 . C150 ) - ( C156 . C151 ) ) by L825 , L828
.= ( ( C155 . C150 ) - ( C156 . C151 ) ) by L825
.= ( ( C155 . C150 ) - ( C155 . C151 ) ) by L825;
L832: ( C155 . C150 ) <> ( C155 . C151 ) by L831 , L816 , L824;
thus L833: ( ( IExec (C148 , R7 , C155) ) . C149 ) = ( C155 . C149 ) by L832 , L816 , L820 , L823 , L829 , L830 , L831;
thus L834: (C148 is_closed_on C155 , R7 & C148 is_halting_on C155 , R7) by L816 , L820 , L823 , L829 , L830 , L831 , L832;
L835:
now
per cases ;
suppose L836: ( C155 . C150 ) > ( C155 . C151 );

L837: ( ( C155 . C150 ) - ( C155 . C151 ) ) > ( 0 ) by L836 , XREAL_1:50;
thus L838: D195 > ( 0 ) by L837 , L816 , L820 , L823 , L829 , L830 , L831 , L836;
thus L839: D196 > ( 0 ) by L816 , L820 , L823 , L829 , L830 , L831 , L836;
L840: D195 = ( ( C155 . C150 ) - ( C155 . C151 ) ) by L816 , L820 , L823 , L829 , L830 , L831 , L836;
thus L841:now
L842: ( max (( C155 . C150 ) , ( C155 . C151 )) ) = ( C155 . C150 ) by L836 , XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose L843: ( max (D195 , D196) ) = D195;

thus L844: ( max (D195 , D196) ) < ( max (( C155 . C150 ) , ( C155 . C151 )) ) by L843 , L830 , L840 , L842 , XREAL_1:44;
end;
suppose L845: ( max (D195 , D196) ) = D196;

thus L846: ( max (D195 , D196) ) < ( max (( C155 . C150 ) , ( C155 . C151 )) ) by L845 , L816 , L820 , L823 , L829 , L830 , L831 , L836 , L842;
end;
end;
end;
suppose L842: ( C155 . C150 ) <= ( C155 . C151 );

thus L843: D195 > ( 0 ) by L842 , L816 , L820 , L823 , L829 , L830 , L831 , L832;
L844: ( C155 . C150 ) < ( C155 . C151 ) by L832 , L842 , XXREAL_0:1;
L845: ( ( C155 . C151 ) - ( C155 . C150 ) ) > ( 0 ) by L844 , XREAL_1:50;
thus L846: D196 > ( 0 ) by L845 , L816 , L820 , L823 , L829 , L830 , L831 , L832 , L842;
L847: D196 = ( ( C155 . C151 ) - ( C155 . C150 ) ) by L816 , L820 , L823 , L829 , L830 , L831 , L832 , L842;
L848: D195 = ( C155 . C150 ) by L816 , L820 , L823 , L829 , L830 , L831 , L832 , L842;
thus L849:now
L850: ( max (( C155 . C150 ) , ( C155 . C151 )) ) = ( C155 . C151 ) by L842 , XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose L851: ( max (D195 , D196) ) = D196;

thus L852: ( max (D195 , D196) ) < ( max (( C155 . C150 ) , ( C155 . C151 )) ) by L851 , L829 , L847 , L850 , XREAL_1:44;
end;
suppose L853: ( max (D195 , D196) ) = D195;

thus L854: ( max (D195 , D196) ) < ( max (( C155 . C150 ) , ( C155 . C151 )) ) by L853 , L832 , L842 , L848 , L850 , XXREAL_0:1;
end;
end;
end;
end;
thus L851: H8(D193) < H8(D194)
proof
L852: ( D194 . C150 ) <> ( C155 . C151 ) by L832;
L853: ( D194 . C150 ) <> ( D194 . C151 ) by L852;
L854: H8(D194) = ( max (( abs ( D194 . C150 ) ) , ( abs ( D194 . C151 ) )) ) by L853 , L815
.= ( max (( abs ( C155 . C150 ) ) , ( abs ( D194 . C151 ) )) )
.= ( max (( abs ( C155 . C150 ) ) , ( abs ( C155 . C151 ) )) )
.= ( max (( C155 . C150 ) , ( abs ( C155 . C151 ) )) ) by L829 , ABSVALUE:def 1
.= ( max (( C155 . C150 ) , ( C155 . C151 )) ) by L830 , ABSVALUE:def 1;
L855: H8(D194) >= ( C155 . C150 ) by L854 , XXREAL_0:25;
L856: H8(D194) > ( 0 ) by L855 , L829 , XXREAL_0:2;
per cases ;
suppose L857: ( D193 . C150 ) = ( D193 . C151 );

thus L858: thesis by L857 , L815 , L856;
end;
suppose L859: ( D193 . C150 ) <> ( D193 . C151 );

L860: H8(D193) = ( max (( abs ( D193 . C150 ) ) , ( abs ( D193 . C151 ) )) ) by L859 , L815
.= ( max (( abs D195 ) , ( abs ( D193 . C151 ) )) ) by SCMPDS_5:15
.= ( max (( abs D195 ) , ( abs D196 )) ) by SCMPDS_5:15
.= ( max (D195 , ( abs D196 )) ) by L835 , ABSVALUE:def 1
.= ( max (D195 , D196) ) by L835 , ABSVALUE:def 1;
thus L861: thesis by L860 , L835 , L854;
end;
end;

L863: ( ( IExec (C148 , R7 , C155) ) . ( DataLoc (C153 , C152) ) ) = ( ( ( IExec (C148 , R7 , C155) ) . C150 ) - ( ( IExec (C148 , R7 , C155) ) . C151 ) ) by L816 , L820 , L823 , L829 , L830 , L831 , L832;
thus L864: S9[ ( Initialize D192 ) ]
proof
take D197 = ( Initialize D192 );
thus L865: D197 = ( Initialize D192 );
thus L866: (( D197 . C150 ) > ( 0 ) & ( D197 . C151 ) > ( 0 )) by L835 , SCMPDS_5:15;
thus L867: ( D197 . ( DataLoc (C153 , C152) ) ) = ( D195 - D196 ) by L863 , SCMPDS_5:15
.= ( ( D197 . C150 ) - D196 ) by SCMPDS_5:15
.= ( ( D197 . C150 ) - ( D197 . C151 ) ) by SCMPDS_5:15;
end;

end;
L865: (for B165 being ( 0 ) -started (State of ( SCMPDS )) holds ((S9[ B165 ] & H8(B165) = ( 0 )) implies ( B165 . D191 ) = ( 0 )))
proof
let C157 being ( 0 ) -started (State of ( SCMPDS ));
assume that
L866: S9[ C157 ]
and
L867: H8(C157) = ( 0 );
consider C158 being (State of ( SCMPDS )) such that L868: C158 = C157 and L869: ( C158 . C150 ) > ( 0 ) and L870: ( C158 . C151 ) > ( 0 ) and L871: ( C158 . ( DataLoc (C153 , C152) ) ) = ( ( C158 . C150 ) - ( C158 . C151 ) ) by L866;
L872:
now
assume L873: ( C157 . C150 ) <> ( C157 . C151 );
L874: ( C157 . C150 ) <> ( C157 . C151 ) by L873;
L875: ( C157 . C150 ) <> ( C157 . C151 ) by L874;
L876: H8(C157) = ( max (( abs ( C157 . C150 ) ) , ( abs ( C157 . C151 ) )) ) by L875 , L815
.= ( max (( abs ( C157 . C150 ) ) , ( abs ( C157 . C151 ) )) )
.= ( max (( abs ( C157 . C150 ) ) , ( abs ( C157 . C151 ) )) );
L877: ( C157 . C150 ) > ( 0 ) by L868 , L869;
L878: ( abs ( C157 . C150 ) ) > ( 0 ) by L877 , COMPLEX1:47;
thus L879: contradiction by L878 , L867 , L876 , XXREAL_0:25;
end;
thus L880: ( C157 . D191 ) = ( ( C158 . C150 ) - ( C158 . C151 ) ) by L816 , L868 , L871
.= ( ( C157 . C150 ) - ( C158 . C151 ) ) by L868
.= ( ( C157 . C150 ) - ( C157 . C151 ) ) by L868
.= ( 0 ) by L872;
end;
L881: S9[ C147 ] by L817 , L818 , L819;
L882: (( while<>0 (C149 , C152 , C148) ) is_closed_on C147 , R9 & ( while<>0 (C149 , C152 , C148) ) is_halting_on C147 , R9) from WhileNHalt(L865 , L881 , L821);
thus L883: (( while<>0 (C149 , C152 , C148) ) is_closed_on C147 , R9 & ( while<>0 (C149 , C152 , C148) ) is_halting_on C147 , R9) by L882;
assume L884: ( C147 . ( DataLoc (( C147 . C149 ) , C152) ) ) <> ( 0 );
L885: ( IExec (( while<>0 (C149 , C152 , C148) ) , R9 , C147) ) = ( IExec (( while<>0 (C149 , C152 , C148) ) , R9 , ( Initialize ( IExec (C148 , R9 , C147) ) )) ) from WhileNExec(L884 , L865 , L881 , L821);
thus L886: thesis by L885;
end;
begin
definition
func GCD-Algorithm -> (Program of ( SCMPDS )) equals 
( ( ( ( ( GBP ) := ( 0 ) ) ';' ( (( GBP ) , 3) := (( GBP ) , 1) ) ) ';' ( SubFrom (( GBP ) , 3 , ( GBP ) , 2) ) ) ';' ( while<>0 (( GBP ) , 3 , ( ( ( if>0 (( GBP ) , 3 , ( Load ( SubFrom (( GBP ) , 1 , ( GBP ) , 2) ) ) , ( Load ( SubFrom (( GBP ) , 2 , ( GBP ) , 1) ) )) ) ';' ( (( GBP ) , 3) := (( GBP ) , 1) ) ) ';' ( SubFrom (( GBP ) , 3 , ( GBP ) , 2) ) )) ) );
coherence;
end;
theorem
L888: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B166 being ( 0 ) -started (State of ( SCMPDS )) holds (for B167 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B168 , B169 , B170 being Int_position holds (for B171 , B172 being Integer holds ((( B166 . B168 ) = B172 & ( B166 . B169 ) > ( 0 ) & ( B166 . B170 ) > ( 0 ) & ( B166 . ( DataLoc (B172 , B171) ) ) = ( ( B166 . B169 ) - ( B166 . B170 ) ) & (for B173 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((( B173 . B169 ) > ( 0 ) & ( B173 . B170 ) > ( 0 ) & ( B173 . B168 ) = B172 & ( B173 . ( DataLoc (B172 , B171) ) ) = ( ( B173 . B169 ) - ( B173 . B170 ) ) & ( B173 . B169 ) <> ( B173 . B170 )) implies (( ( IExec (B167 , R7 , B173) ) . B168 ) = B172 & B167 is_closed_on B173 , R7 & B167 is_halting_on B173 , R7 & (( B173 . B169 ) > ( B173 . B170 ) implies (( ( IExec (B167 , R7 , B173) ) . B169 ) = ( ( B173 . B169 ) - ( B173 . B170 ) ) & ( ( IExec (B167 , R7 , B173) ) . B170 ) = ( B173 . B170 ))) & (( B173 . B169 ) <= ( B173 . B170 ) implies (( ( IExec (B167 , R7 , B173) ) . B170 ) = ( ( B173 . B170 ) - ( B173 . B169 ) ) & ( ( IExec (B167 , R7 , B173) ) . B169 ) = ( B173 . B169 ))) & ( ( IExec (B167 , R7 , B173) ) . ( DataLoc (B172 , B171) ) ) = ( ( ( IExec (B167 , R7 , B173) ) . B169 ) - ( ( IExec (B167 , R7 , B173) ) . B170 ) )))))) implies (( ( IExec (( while<>0 (B168 , B171 , B167) ) , R9 , B166) ) . B169 ) = ( ( B166 . B169 ) gcd ( B166 . B170 ) ) & ( ( IExec (( while<>0 (B168 , B171 , B167) ) , R9 , B166) ) . B170 ) = ( ( B166 . B169 ) gcd ( B166 . B170 ) ))))))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C159 being ( 0 ) -started (State of ( SCMPDS ));
let C160 being  halt-free  shiftable (Program of ( SCMPDS ));
let C161 , C162 , C163 being Int_position;
let C164 , C165 being Integer;
set D198 = ( DataLoc (( C159 . C161 ) , C164) );
consider C166 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L889: (for B174 being (State of ( SCMPDS )) holds ((( B174 . C162 ) = ( B174 . C163 ) implies ( C166 . B174 ) = ( 0 )) & (( B174 . C162 ) <> ( B174 . C163 ) implies ( C166 . B174 ) = ( max (( abs ( B174 . C162 ) ) , ( abs ( B174 . C163 ) )) )))) by L10;
deffunc H9((State of ( SCMPDS ))) = ( C166 . $1 );
set D199 = ( IExec (( while<>0 (C161 , C164 , C160) ) , R9 , C159) );
set D200 = D199;
defpred S10[ set ] means (ex B175 being ( 0 ) -started (State of ( SCMPDS )) st (B175 = $1 & ( B175 . C162 ) > ( 0 ) & ( B175 . C163 ) > ( 0 ) & ( ( B175 . C162 ) gcd ( B175 . C163 ) ) = ( ( C159 . C162 ) gcd ( C159 . C163 ) ) & ( B175 . ( DataLoc (C165 , C164) ) ) = ( ( B175 . C162 ) - ( B175 . C163 ) )));
assume that
L890: ( C159 . C161 ) = C165
and
L891: ( C159 . C162 ) > ( 0 )
and
L892: ( C159 . C163 ) > ( 0 )
and
L893: ( C159 . ( DataLoc (C165 , C164) ) ) = ( ( C159 . C162 ) - ( C159 . C163 ) );
assume L894: (for B176 being ( 0 ) -started (State of ( SCMPDS )) holds (for R7 being (Instruction-Sequence of ( SCMPDS )) holds ((( B176 . C162 ) > ( 0 ) & ( B176 . C163 ) > ( 0 ) & ( B176 . C161 ) = C165 & ( B176 . ( DataLoc (C165 , C164) ) ) = ( ( B176 . C162 ) - ( B176 . C163 ) ) & ( B176 . C162 ) <> ( B176 . C163 )) implies (( ( IExec (C160 , R7 , B176) ) . C161 ) = C165 & C160 is_closed_on B176 , R7 & C160 is_halting_on B176 , R7 & (( B176 . C162 ) > ( B176 . C163 ) implies (( ( IExec (C160 , R7 , B176) ) . C162 ) = ( ( B176 . C162 ) - ( B176 . C163 ) ) & ( ( IExec (C160 , R7 , B176) ) . C163 ) = ( B176 . C163 ))) & (( B176 . C162 ) <= ( B176 . C163 ) implies (( ( IExec (C160 , R7 , B176) ) . C163 ) = ( ( B176 . C163 ) - ( B176 . C162 ) ) & ( ( IExec (C160 , R7 , B176) ) . C162 ) = ( B176 . C162 ))) & ( ( IExec (C160 , R7 , B176) ) . ( DataLoc (C165 , C164) ) ) = ( ( ( IExec (C160 , R7 , B176) ) . C162 ) - ( ( IExec (C160 , R7 , B176) ) . C163 ) )))));
L895:
now
let C167 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
assume that
L896: S10[ C167 ]
and
L897: ( C167 . C161 ) = ( C159 . C161 )
and
L898: ( C167 . D198 ) <> ( 0 );
set D201 = ( IExec (C160 , R7 , C167) );
set D202 = ( Initialize D201 );
set D203 = C167;
set D204 = ( ( IExec (C160 , R7 , C167) ) . C162 );
set D205 = ( ( IExec (C160 , R7 , C167) ) . C163 );
consider C168 being (State of ( SCMPDS )) such that L899: C168 = C167 and L900: ( C168 . C162 ) > ( 0 ) and L901: ( C168 . C163 ) > ( 0 ) and L902: ( ( C168 . C162 ) gcd ( C168 . C163 ) ) = ( ( C159 . C162 ) gcd ( C159 . C163 ) ) and L903: ( C168 . ( DataLoc (C165 , C164) ) ) = ( ( C168 . C162 ) - ( C168 . C163 ) ) by L896;
L904: ( C167 . C162 ) > ( 0 ) by L899 , L900;
L905: ( C167 . C163 ) > ( 0 ) by L899 , L901;
L906: ( C167 . ( DataLoc (C165 , C164) ) ) = ( ( C168 . C162 ) - ( C168 . C163 ) ) by L899 , L903
.= ( ( C167 . C162 ) - ( C168 . C163 ) ) by L899
.= ( ( C167 . C162 ) - ( C167 . C163 ) ) by L899;
L907: (( C167 . C162 ) > ( C167 . C163 ) implies (( ( IExec (C160 , R7 , C167) ) . C162 ) = ( ( C167 . C162 ) - ( C167 . C163 ) ) & ( ( IExec (C160 , R7 , C167) ) . C163 ) = ( C167 . C163 ))) by L906 , L890 , L894 , L897 , L904 , L905;
L908: ( C167 . C162 ) <> ( C167 . C163 ) by L890 , L898 , L906;
thus L909: ( ( IExec (C160 , R7 , C167) ) . C161 ) = ( C167 . C161 ) by L908 , L890 , L894 , L897 , L904 , L905 , L906;
thus L910: (C160 is_closed_on C167 , R7 & C160 is_halting_on C167 , R7) by L890 , L894 , L897 , L904 , L905 , L906 , L908;
L911: (( C167 . C162 ) <= ( C167 . C163 ) implies (( ( IExec (C160 , R7 , C167) ) . C163 ) = ( ( C167 . C163 ) - ( C167 . C162 ) ) & ( ( IExec (C160 , R7 , C167) ) . C162 ) = ( C167 . C162 ))) by L890 , L894 , L897 , L904 , L905 , L906 , L908;
L912:
now
per cases ;
suppose L913: ( C167 . C162 ) > ( C167 . C163 );

L914: ( ( C167 . C162 ) - ( C167 . C163 ) ) > ( 0 ) by L913 , XREAL_1:50;
thus L915: D204 > ( 0 ) by L914 , L890 , L894 , L897 , L904 , L905 , L906 , L913;
thus L916: D205 > ( 0 ) by L890 , L894 , L897 , L904 , L905 , L906 , L913;
thus L917: ( D204 gcd D205 ) = ( ( C167 . C162 ) gcd ( C167 . C163 ) ) by L904 , L905 , L907 , L911 , PREPOWER:97;
L918: D204 = ( ( C167 . C162 ) - ( C167 . C163 ) ) by L890 , L894 , L897 , L904 , L905 , L906 , L913;
thus L919:now
L920: ( max (( C167 . C162 ) , ( C167 . C163 )) ) = ( C167 . C162 ) by L913 , XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose L921: ( max (D204 , D205) ) = D204;

thus L922: ( max (D204 , D205) ) < ( max (( C167 . C162 ) , ( C167 . C163 )) ) by L921 , L905 , L918 , L920 , XREAL_1:44;
end;
suppose L923: ( max (D204 , D205) ) = D205;

thus L924: ( max (D204 , D205) ) < ( max (( C167 . C162 ) , ( C167 . C163 )) ) by L923 , L890 , L894 , L897 , L904 , L905 , L906 , L913 , L920;
end;
end;
end;
suppose L920: ( C167 . C162 ) <= ( C167 . C163 );

thus L921: D204 > ( 0 ) by L920 , L890 , L894 , L897 , L904 , L905 , L906 , L908;
L922: ( C167 . C162 ) < ( C167 . C163 ) by L908 , L920 , XXREAL_0:1;
L923: ( ( C167 . C163 ) - ( C167 . C162 ) ) > ( 0 ) by L922 , XREAL_1:50;
thus L924: D205 > ( 0 ) by L923 , L890 , L894 , L897 , L904 , L905 , L906 , L908 , L920;
thus L925: ( D204 gcd D205 ) = ( ( C167 . C162 ) gcd ( C167 . C163 ) ) by L904 , L905 , L907 , L911 , PREPOWER:97;
L926: D205 = ( ( C167 . C163 ) - ( C167 . C162 ) ) by L890 , L894 , L897 , L904 , L905 , L906 , L908 , L920;
L927: D204 = ( C167 . C162 ) by L890 , L894 , L897 , L904 , L905 , L906 , L908 , L920;
thus L928:now
L929: ( max (( C167 . C162 ) , ( C167 . C163 )) ) = ( C167 . C163 ) by L920 , XXREAL_0:def 10;
per cases  by XXREAL_0:16;
suppose L930: ( max (D204 , D205) ) = D205;

thus L931: ( max (D204 , D205) ) < ( max (( C167 . C162 ) , ( C167 . C163 )) ) by L930 , L904 , L926 , L929 , XREAL_1:44;
end;
suppose L932: ( max (D204 , D205) ) = D204;

thus L933: ( max (D204 , D205) ) < ( max (( C167 . C162 ) , ( C167 . C163 )) ) by L932 , L908 , L920 , L927 , L929 , XXREAL_0:1;
end;
end;
end;
end;
thus L930: H9(D202) < H9(D203)
proof
L931: ( D203 . C162 ) <> ( C167 . C163 ) by L908;
L932: ( D203 . C162 ) <> ( D203 . C163 ) by L931;
L933: H9(D203) = ( max (( abs ( D203 . C162 ) ) , ( abs ( D203 . C163 ) )) ) by L932 , L889
.= ( max (( abs ( C167 . C162 ) ) , ( abs ( D203 . C163 ) )) )
.= ( max (( abs ( C167 . C162 ) ) , ( abs ( C167 . C163 ) )) )
.= ( max (( C167 . C162 ) , ( abs ( C167 . C163 ) )) ) by L904 , ABSVALUE:def 1
.= ( max (( C167 . C162 ) , ( C167 . C163 )) ) by L905 , ABSVALUE:def 1;
L934: H9(D203) >= ( C167 . C162 ) by L933 , XXREAL_0:25;
L935: H9(D203) > ( 0 ) by L934 , L904 , XXREAL_0:2;
per cases ;
suppose L936: ( D202 . C162 ) = ( D202 . C163 );

thus L937: thesis by L936 , L889 , L935;
end;
suppose L938: ( D202 . C162 ) <> ( D202 . C163 );

L939: H9(D202) = ( max (( abs ( D202 . C162 ) ) , ( abs ( D202 . C163 ) )) ) by L938 , L889
.= ( max (( abs D204 ) , ( abs ( D202 . C163 ) )) ) by SCMPDS_5:15
.= ( max (( abs D204 ) , ( abs D205 )) ) by SCMPDS_5:15
.= ( max (D204 , ( abs D205 )) ) by L912 , ABSVALUE:def 1
.= ( max (D204 , D205) ) by L912 , ABSVALUE:def 1;
thus L940: thesis by L939 , L912 , L933;
end;
end;

L942: ( ( IExec (C160 , R7 , C167) ) . ( DataLoc (C165 , C164) ) ) = ( ( ( IExec (C160 , R7 , C167) ) . C162 ) - ( ( IExec (C160 , R7 , C167) ) . C163 ) ) by L890 , L894 , L897 , L904 , L905 , L906 , L908;
thus L943: S10[ ( Initialize D201 ) ]
proof
take D206 = ( Initialize D201 );
thus L944: D206 = ( Initialize D201 );
thus L945: (( D206 . C162 ) > ( 0 ) & ( D206 . C163 ) > ( 0 )) by L912 , SCMPDS_5:15;
thus L946: ( ( D206 . C162 ) gcd ( D206 . C163 ) ) = ( ( D201 . C162 ) gcd ( D206 . C163 ) ) by SCMPDS_5:15
.= ( ( C167 . C162 ) gcd ( C167 . C163 ) ) by L912 , SCMPDS_5:15
.= ( ( C168 . C162 ) gcd ( C167 . C163 ) ) by L899
.= ( ( C159 . C162 ) gcd ( C159 . C163 ) ) by L899 , L902;
thus L947: ( D206 . ( DataLoc (C165 , C164) ) ) = ( D204 - D205 ) by L942 , SCMPDS_5:15
.= ( ( D206 . C162 ) - D205 ) by SCMPDS_5:15
.= ( ( D206 . C162 ) - ( D206 . C163 ) ) by SCMPDS_5:15;
end;

end;
L944: (for B177 being ( 0 ) -started (State of ( SCMPDS )) holds (S10[ B177 ] implies (H9(B177) = ( 0 ) iff ( B177 . D198 ) = ( 0 ))))
proof
let C169 being ( 0 ) -started (State of ( SCMPDS ));
assume L945: S10[ C169 ];
consider C170 being (State of ( SCMPDS )) such that L946: C170 = C169 and L947: ( C170 . C162 ) > ( 0 ) and L948: ( C170 . C163 ) > ( 0 ) and L949: ( ( C170 . C162 ) gcd ( C170 . C163 ) ) = ( ( C159 . C162 ) gcd ( C159 . C163 ) ) and L950: ( C170 . ( DataLoc (C165 , C164) ) ) = ( ( C170 . C162 ) - ( C170 . C163 ) ) by L945;
L951: ( C169 . D198 ) = ( ( C170 . C162 ) - ( C170 . C163 ) ) by L890 , L946 , L950
.= ( ( C169 . C162 ) - ( C170 . C163 ) ) by L946
.= ( ( C169 . C162 ) - ( C169 . C163 ) ) by L946;
thus L952:now
assume L953: H9(C169) = ( 0 );
L954:
now
assume L955: ( C169 . C162 ) <> ( C169 . C163 );
L956: ( C169 . C162 ) <> ( C169 . C163 ) by L955;
L957: ( C169 . C162 ) <> ( C169 . C163 ) by L956;
L958: H9(C169) = ( max (( abs ( C169 . C162 ) ) , ( abs ( C169 . C163 ) )) ) by L957 , L889
.= ( max (( abs ( C169 . C162 ) ) , ( abs ( C169 . C163 ) )) )
.= ( max (( abs ( C169 . C162 ) ) , ( abs ( C169 . C163 ) )) );
L959: ( C169 . C162 ) > ( 0 ) by L946 , L947;
L960: ( abs ( C169 . C162 ) ) > ( 0 ) by L959 , COMPLEX1:47;
thus L961: contradiction by L960 , L953 , L958 , XXREAL_0:25;
end;
thus L962: ( C169 . D198 ) = ( 0 ) by L954 , L951;
end;
thus L963: (( C169 . D198 ) = ( 0 ) implies H9(C169) = ( 0 )) by L889 , L951;
end;
L964: S10[ C159 ] by L891 , L892 , L893;
L965: (H9(( Initialize D200 )) = ( 0 ) & S10[ ( Initialize D200 ) ]) from WhileNEnd(L944 , L964 , L895);
consider C171 being ( 0 ) -started (State of ( SCMPDS )) such that L966: C171 = ( Initialize D200 ) and L967: ( C171 . C162 ) > ( 0 ) and L968: ( C171 . C163 ) > ( 0 ) and L969: ( ( C171 . C162 ) gcd ( C171 . C163 ) ) = ( ( C159 . C162 ) gcd ( C159 . C163 ) ) and L970: ( C171 . ( DataLoc (C165 , C164) ) ) = ( ( C171 . C162 ) - ( C171 . C163 ) ) by L965;
L971: ( ( Initialize D200 ) . D198 ) = ( D200 . D198 ) by SCMPDS_5:15;
L972: ( ( Initialize D200 ) . C162 ) = ( D200 . C162 ) by SCMPDS_5:15;
L973: ( ( Initialize D200 ) . C163 ) = ( D200 . C163 ) by SCMPDS_5:15;
L974: ( ( C171 . C162 ) - ( C171 . C163 ) ) = ( D199 . D198 ) by L890 , L966 , L970 , SCMPDS_5:15
.= ( 0 ) by L944 , L965 , L971;
L975: ( abs ( C171 . C162 ) ) = ( ( abs ( C171 . C162 ) ) gcd ( abs ( C171 . C163 ) ) ) by L974 , NAT_D:32
.= ( ( C159 . C162 ) gcd ( C159 . C163 ) ) by L969 , INT_2:34;
thus L976: ( ( IExec (( while<>0 (C161 , C164 , C160) ) , R9 , C159) ) . C162 ) = ( D200 . C162 )
.= ( ( C159 . C162 ) gcd ( C159 . C163 ) ) by L966 , L967 , L975 , L972 , ABSVALUE:def 1;
thus L977: ( ( IExec (( while<>0 (C161 , C164 , C160) ) , R9 , C159) ) . C163 ) = ( D200 . C163 )
.= ( ( C159 . C162 ) gcd ( C159 . C163 ) ) by L966 , L967 , L974 , L975 , L973 , ABSVALUE:def 1;
end;
set D207 = ( ( GBP ) := ( 0 ) );
set D208 = ( (( GBP ) , 3) := (( GBP ) , 1) );
set D209 = ( SubFrom (( GBP ) , 3 , ( GBP ) , 2) );
set D210 = ( Load ( SubFrom (( GBP ) , 1 , ( GBP ) , 2) ) );
set D211 = ( Load ( SubFrom (( GBP ) , 2 , ( GBP ) , 1) ) );
set D212 = ( if>0 (( GBP ) , 3 , D210 , D211) );
set D213 = ( (( GBP ) , 3) := (( GBP ) , 1) );
set D214 = ( SubFrom (( GBP ) , 3 , ( GBP ) , 2) );
set D215 = ( ( D212 ';' D213 ) ';' D214 );
set D216 = ( while<>0 (( GBP ) , 3 , D215) );
L978: ( card D215 ) = 6
proof
thus L979: ( card D215 ) = ( ( card ( D212 ';' D213 ) ) + 1 ) by SCMP_GCD:4
.= ( ( ( card D212 ) + 1 ) + 1 ) by SCMP_GCD:4
.= ( ( ( ( ( card D210 ) + ( card D211 ) ) + 2 ) + 1 ) + 1 ) by SCMPDS_6:65
.= ( ( ( ( 1 + ( card D211 ) ) + 2 ) + 1 ) + 1 ) by COMPOS_1:54
.= ( ( ( ( 1 + 1 ) + 2 ) + 1 ) + 1 ) by COMPOS_1:54
.= 6;
end;
L980: ( card D216 ) = 9
proof
thus L981: ( card D216 ) = ( 6 + 3 ) by L978 , L492
.= 9;
end;
theorem
L982: ( card ( GCD-Algorithm ) ) = 12
proof
thus L983: ( card ( GCD-Algorithm ) ) = ( ( card ( ( D207 ';' D208 ) ';' D209 ) ) + ( card D216 ) ) by AFINSQ_1:17
.= ( ( ( card ( D207 ';' D208 ) ) + 1 ) + ( card D216 ) ) by SCMP_GCD:4
.= ( ( 2 + 1 ) + 9 ) by L980 , SCMP_GCD:5
.= 12;
end;
L984: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B178 being ( 0 ) -started (State of ( SCMPDS )) holds (( B178 . ( GBP ) ) = ( 0 ) implies ((( B178 . D20 ) > ( 0 ) implies (( ( IExec (D215 , R9 , B178) ) . D18 ) = ( ( B178 . D18 ) - ( B178 . D19 ) ) & ( ( IExec (D215 , R9 , B178) ) . D19 ) = ( B178 . D19 ))) & (( B178 . D20 ) <= ( 0 ) implies (( ( IExec (D215 , R9 , B178) ) . D19 ) = ( ( B178 . D19 ) - ( B178 . D18 ) ) & ( ( IExec (D215 , R9 , B178) ) . D18 ) = ( B178 . D18 ))) & ( ( IExec (D215 , R9 , B178) ) . ( GBP ) ) = ( 0 ) & ( ( IExec (D215 , R9 , B178) ) . D20 ) = ( ( ( IExec (D215 , R9 , B178) ) . D18 ) - ( ( IExec (D215 , R9 , B178) ) . D19 ) )))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C172 being ( 0 ) -started (State of ( SCMPDS ));
set D217 = ( IExec (D212 , R9 , C172) );
set D218 = ( IExec (( D212 ';' D213 ) , R9 , C172) );
set D219 = ( GBP );
set D220 = C172;
set D221 = R9;
L985:
now
assume L986: ( D217 . ( GBP ) ) = ( 0 );
L987: ( DataLoc (( D217 . D219 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L986 , SCMP_GCD:1;
L988: ( D218 . D20 ) = ( ( Exec (D213 , D217) ) . D20 ) by SCMPDS_5:41
.= ( D217 . ( DataLoc (( D217 . D219 ) , 1) ) ) by L987 , SCMPDS_2:47
.= ( D217 . ( intpos ( ( 0 ) + 1 ) ) ) by L986 , SCMP_GCD:1;
L989: 1 <> ( abs ( ( D217 . ( GBP ) ) + 3 ) ) by L986 , ABSVALUE:def 1;
L990: D18 <> ( DataLoc (( D217 . ( GBP ) ) , 3) ) by L989 , XTUPLE_0:1;
L991: ( D218 . D18 ) = ( ( Exec (D213 , D217) ) . D18 ) by SCMPDS_5:41
.= ( D217 . D18 ) by L990 , SCMPDS_2:47;
L992: 2 <> ( abs ( ( D217 . ( GBP ) ) + 3 ) ) by L986 , ABSVALUE:def 1;
L993: D19 <> ( DataLoc (( D217 . ( GBP ) ) , 3) ) by L992 , XTUPLE_0:1;
L994: ( D218 . D19 ) = ( ( Exec (D213 , D217) ) . D19 ) by SCMPDS_5:41
.= ( D217 . D19 ) by L993 , SCMPDS_2:47;
L995: ( 0 ) <> ( abs ( ( D217 . ( GBP ) ) + 3 ) ) by L986 , ABSVALUE:def 1;
L996: D219 <> ( DataLoc (( D217 . ( GBP ) ) , 3) ) by L995 , XTUPLE_0:1;
L997: ( D218 . D219 ) = ( ( Exec (D213 , D217) ) . D219 ) by SCMPDS_5:41
.= ( 0 ) by L986 , L996 , SCMPDS_2:47;
L998: ( DataLoc (( D218 . D219 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L997 , SCMP_GCD:1;
L999: ( 0 ) <> ( abs ( ( D218 . ( GBP ) ) + 3 ) ) by L997 , ABSVALUE:def 1;
L1000: D219 <> ( DataLoc (( D218 . ( GBP ) ) , 3) ) by L999 , XTUPLE_0:1;
thus L1001: ( ( IExec (D215 , R9 , C172) ) . D219 ) = ( ( Exec (D214 , D218) ) . D219 ) by SCMPDS_5:41
.= ( 0 ) by L997 , L1000 , SCMPDS_2:50;
L1002: 1 <> ( abs ( ( D218 . ( GBP ) ) + 3 ) ) by L997 , ABSVALUE:def 1;
L1003: D18 <> ( DataLoc (( D218 . ( GBP ) ) , 3) ) by L1002 , XTUPLE_0:1;
thus L1004: ( ( IExec (D215 , R9 , C172) ) . D18 ) = ( ( Exec (D214 , D218) ) . D18 ) by SCMPDS_5:41
.= ( D217 . D18 ) by L991 , L1003 , SCMPDS_2:50;
L1005: 2 <> ( abs ( ( D218 . ( GBP ) ) + 3 ) ) by L997 , ABSVALUE:def 1;
L1006: D19 <> ( DataLoc (( D218 . ( GBP ) ) , 3) ) by L1005 , XTUPLE_0:1;
thus L1007: ( ( IExec (D215 , R9 , C172) ) . D19 ) = ( ( Exec (D214 , D218) ) . D19 ) by SCMPDS_5:41
.= ( D217 . D19 ) by L994 , L1006 , SCMPDS_2:50;
thus L1008: ( ( IExec (D215 , R9 , C172) ) . D20 ) = ( ( Exec (D214 , D218) ) . D20 ) by SCMPDS_5:41
.= ( ( D218 . D20 ) - ( D218 . ( DataLoc (( D218 . D219 ) , 2) ) ) ) by L998 , SCMPDS_2:50
.= ( ( ( IExec (D215 , R9 , C172) ) . D18 ) - ( ( IExec (D215 , R9 , C172) ) . D19 ) ) by L997 , L994 , L988 , L1004 , L1007 , SCMP_GCD:1;
end;
set D222 = C172;
set D223 = ( SubFrom (( GBP ) , 1 , ( GBP ) , 2) );
set D224 = ( SubFrom (( GBP ) , 2 , ( GBP ) , 1) );
assume L1009: ( C172 . ( GBP ) ) = ( 0 );
L1010: ( D222 . D219 ) = ( 0 ) by L1009;
L1011: ( DataLoc (( C172 . D219 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L1009 , SCMP_GCD:1;
L1012:
now
L1013: 2 <> ( abs ( ( D222 . ( GBP ) ) + 1 ) ) by L1010 , ABSVALUE:def 1;
L1014: D19 <> ( DataLoc (( D222 . ( GBP ) ) , 1) ) by L1013 , XTUPLE_0:1;
L1015: ( 0 ) <> ( abs ( ( D222 . ( GBP ) ) + 1 ) ) by L1010 , ABSVALUE:def 1;
L1016: D219 <> ( DataLoc (( D222 . ( GBP ) ) , 1) ) by L1015 , XTUPLE_0:1;
assume L1017: ( C172 . D20 ) > ( 0 );
thus L1018: ( D217 . D219 ) = ( ( IExec (D210 , R9 , C172) ) . D219 ) by L1017 , L1011 , SCMPDS_6:73
.= ( ( Exec (D223 , D222) ) . D219 ) by SCMPDS_5:40
.= ( 0 ) by L1010 , L1016 , SCMPDS_2:50;
L1019: ( DataLoc (( D222 . D219 ) , 1) ) = ( intpos ( ( 0 ) + 1 ) ) by L1010 , SCMP_GCD:1;
thus L1020: ( D217 . D18 ) = ( ( IExec (D210 , R9 , C172) ) . D18 ) by L1011 , L1017 , SCMPDS_6:73
.= ( ( Exec (D223 , D222) ) . D18 ) by SCMPDS_5:40
.= ( ( D222 . D18 ) - ( D222 . ( DataLoc (( D222 . D219 ) , 2) ) ) ) by L1019 , SCMPDS_2:50
.= ( ( D222 . D18 ) - ( D222 . ( intpos ( ( 0 ) + 2 ) ) ) ) by L1010 , SCMP_GCD:1
.= ( ( C172 . D18 ) - ( C172 . D19 ) );
thus L1021: ( D217 . D19 ) = ( ( IExec (D210 , R9 , C172) ) . D19 ) by L1011 , L1017 , SCMPDS_6:73
.= ( ( Exec (D223 , D222) ) . D19 ) by SCMPDS_5:40
.= ( C172 . D19 ) by L1014 , SCMPDS_2:50;
end;
thus L1022: (( C172 . D20 ) > ( 0 ) implies (( ( IExec (D215 , R9 , C172) ) . D18 ) = ( ( C172 . D18 ) - ( C172 . D19 ) ) & ( ( IExec (D215 , R9 , C172) ) . D19 ) = ( C172 . D19 ))) by L1012 , L985;
L1023:
now
L1024: 1 <> ( abs ( ( D222 . ( GBP ) ) + 2 ) ) by L1010 , ABSVALUE:def 1;
L1025: D18 <> ( DataLoc (( D222 . ( GBP ) ) , 2) ) by L1024 , XTUPLE_0:1;
L1026: ( 0 ) <> ( abs ( ( D222 . ( GBP ) ) + 2 ) ) by L1010 , ABSVALUE:def 1;
L1027: D219 <> ( DataLoc (( D222 . ( GBP ) ) , 2) ) by L1026 , XTUPLE_0:1;
assume L1028: ( C172 . D20 ) <= ( 0 );
thus L1029: ( D217 . D219 ) = ( ( IExec (D211 , R9 , C172) ) . D219 ) by L1028 , L1011 , SCMPDS_6:74
.= ( ( Exec (D224 , D222) ) . D219 ) by SCMPDS_5:40
.= ( 0 ) by L1010 , L1027 , SCMPDS_2:50;
L1030: ( DataLoc (( D222 . D219 ) , 2) ) = ( intpos ( ( 0 ) + 2 ) ) by L1010 , SCMP_GCD:1;
thus L1031: ( D217 . D19 ) = ( ( IExec (D211 , R9 , C172) ) . D19 ) by L1011 , L1028 , SCMPDS_6:74
.= ( ( Exec (D224 , D222) ) . D19 ) by SCMPDS_5:40
.= ( ( D222 . D19 ) - ( D222 . ( DataLoc (( D222 . D219 ) , 1) ) ) ) by L1030 , SCMPDS_2:50
.= ( ( D222 . D19 ) - ( D222 . ( intpos ( ( 0 ) + 1 ) ) ) ) by L1010 , SCMP_GCD:1
.= ( ( C172 . D19 ) - ( C172 . D18 ) );
thus L1032: ( D217 . D18 ) = ( ( IExec (D211 , R9 , C172) ) . D18 ) by L1011 , L1028 , SCMPDS_6:74
.= ( ( Exec (D224 , D222) ) . D18 ) by SCMPDS_5:40
.= ( C172 . D18 ) by L1025 , SCMPDS_2:50;
end;
thus L1033: (( C172 . D20 ) <= ( 0 ) implies (( ( IExec (D215 , R9 , C172) ) . D19 ) = ( ( C172 . D19 ) - ( C172 . D18 ) ) & ( ( IExec (D215 , R9 , C172) ) . D18 ) = ( C172 . D18 ))) by L1023 , L985;
L1034:
now
per cases ;
suppose L1035: ( C172 . D20 ) > ( 0 );

thus L1036: ( D217 . D219 ) = ( 0 ) by L1035 , L1012;
end;
suppose L1037: ( C172 . D20 ) <= ( 0 );

thus L1038: ( D217 . D219 ) = ( 0 ) by L1037 , L1023;
end;
end;
thus L1040: thesis by L1034 , L985;
end;
L1041: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B179 being ( 0 ) -started (State of ( SCMPDS )) holds ((( B179 . ( GBP ) ) = ( 0 ) & ( B179 . D18 ) > ( 0 ) & ( B179 . D19 ) > ( 0 ) & ( B179 . D20 ) = ( ( B179 . D18 ) - ( B179 . D19 ) )) implies (( ( IExec (D216 , R9 , B179) ) . D18 ) = ( ( B179 . D18 ) gcd ( B179 . D19 ) ) & ( ( IExec (D216 , R9 , B179) ) . D19 ) = ( ( B179 . D18 ) gcd ( B179 . D19 ) ) & D216 is_closed_on B179 , R9 & D216 is_halting_on B179 , R9))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
set D225 = ( GBP );
let C173 being ( 0 ) -started (State of ( SCMPDS ));
L1042: ( DataLoc (( 0 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by SCMP_GCD:1;
L1043:
now
let C174 being ( 0 ) -started (State of ( SCMPDS ));
let R7 being (Instruction-Sequence of ( SCMPDS ));
assume that
L1044: ( C174 . D18 ) > ( 0 )
and
L1045: ( C174 . D19 ) > ( 0 )
and
L1046: ( C174 . D225 ) = ( 0 )
and
L1047: ( C174 . ( DataLoc (( 0 ) , 3) ) ) = ( ( C174 . D18 ) - ( C174 . D19 ) )
and
L1048: ( C174 . D18 ) <> ( C174 . D19 );
thus L1049: ( ( IExec (D215 , R7 , C174) ) . D225 ) = ( 0 ) by L1046 , L984;
thus L1050: D215 is_closed_on C174 , R7 by SCMPDS_6:20;
thus L1051: D215 is_halting_on C174 , R7 by SCMPDS_6:21;
thus L1052:now
assume L1053: ( C174 . D18 ) > ( C174 . D19 );
L1054: ( C174 . D20 ) > ( 0 ) by L1053 , L1042 , L1047 , XREAL_1:50;
thus L1055: (( ( IExec (D215 , R7 , C174) ) . D18 ) = ( ( C174 . D18 ) - ( C174 . D19 ) ) & ( ( IExec (D215 , R7 , C174) ) . D19 ) = ( C174 . D19 )) by L1054 , L1046 , L984;
end;
thus L1056:now
assume L1057: ( C174 . D18 ) <= ( C174 . D19 );
L1058: ( C174 . D20 ) <= ( 0 ) by L1057 , L1042 , L1047 , XREAL_1:47;
thus L1059: (( ( IExec (D215 , R7 , C174) ) . D19 ) = ( ( C174 . D19 ) - ( C174 . D18 ) ) & ( ( IExec (D215 , R7 , C174) ) . D18 ) = ( C174 . D18 )) by L1058 , L1046 , L984;
end;
thus L1060: ( ( IExec (D215 , R7 , C174) ) . ( DataLoc (( 0 ) , 3) ) ) = ( ( ( IExec (D215 , R7 , C174) ) . D18 ) - ( ( IExec (D215 , R7 , C174) ) . D19 ) ) by L1042 , L1046 , L984;
end;
assume L1061: (( C173 . D225 ) = ( 0 ) & ( C173 . D18 ) > ( 0 ) & ( C173 . D19 ) > ( 0 ) & ( C173 . D20 ) = ( ( C173 . D18 ) - ( C173 . D19 ) ));
thus L1062: (( ( IExec (D216 , R9 , C173) ) . D18 ) = ( ( C173 . D18 ) gcd ( C173 . D19 ) ) & ( ( IExec (D216 , R9 , C173) ) . D19 ) = ( ( C173 . D18 ) gcd ( C173 . D19 ) )) by L1061 , L1042 , L1043 , L888;
thus L1063: (D216 is_closed_on C173 , R9 & D216 is_halting_on C173 , R9) by L1061 , L1042 , L1043 , L978 , L813;
end;
set D226 = ( ( ( D207 ';' D208 ) ';' D209 ) ';' D216 );
L1064: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B180 being ( 0 ) -started (State of ( SCMPDS )) holds ((( B180 . D18 ) > ( 0 ) & ( B180 . D19 ) > ( 0 )) implies (( ( IExec (D226 , R9 , B180) ) . D18 ) = ( ( B180 . D18 ) gcd ( B180 . D19 ) ) & ( ( IExec (D226 , R9 , B180) ) . D19 ) = ( ( B180 . D18 ) gcd ( B180 . D19 ) ) & D226 is_closed_on B180 , R9 & D226 is_halting_on B180 , R9))))
proof
let R9 being (Instruction-Sequence of ( SCMPDS ));
let C175 being ( 0 ) -started (State of ( SCMPDS ));
L1065: ( Initialize C175 ) = C175 by MEMSTR_0:44;
assume L1066: (( C175 . D18 ) > ( 0 ) & ( C175 . D19 ) > ( 0 ));
set D227 = C175;
set D228 = R9;
set D229 = ( IExec (( ( D207 ';' D208 ) ';' D209 ) , R9 , C175) );
set D230 = ( IExec (( D207 ';' D208 ) , R9 , C175) );
set D231 = R9;
set D232 = ( Exec (D207 , D227) );
set D233 = ( GBP );
L1067: ( D232 . D18 ) = ( D227 . D18 ) by AMI_3:10 , SCMPDS_2:45
.= ( C175 . D18 );
L1068: ( D232 . D233 ) = ( 0 ) by SCMPDS_2:45;
L1069: ( DataLoc (( D232 . D233 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L1068 , SCMP_GCD:1;
L1070: 1 <> ( abs ( ( D232 . ( GBP ) ) + 3 ) ) by L1068 , ABSVALUE:def 1;
L1071: D18 <> ( DataLoc (( D232 . ( GBP ) ) , 3) ) by L1070 , XTUPLE_0:1;
L1072: ( D230 . D18 ) = ( ( Exec (D208 , D232) ) . D18 ) by SCMPDS_5:42
.= ( C175 . D18 ) by L1067 , L1071 , SCMPDS_2:47;
L1073: ( D232 . D19 ) = ( D227 . D19 ) by AMI_3:10 , SCMPDS_2:45
.= ( C175 . D19 );
L1074: ( D230 . D20 ) = ( ( Exec (D208 , D232) ) . D20 ) by SCMPDS_5:42
.= ( D232 . ( DataLoc (( D232 . D233 ) , 1) ) ) by L1069 , SCMPDS_2:47
.= ( C175 . D18 ) by L1068 , L1067 , SCMP_GCD:1;
L1075: 2 <> ( abs ( ( D232 . ( GBP ) ) + 3 ) ) by L1068 , ABSVALUE:def 1;
L1076: D19 <> ( DataLoc (( D232 . ( GBP ) ) , 3) ) by L1075 , XTUPLE_0:1;
L1077: ( D230 . D19 ) = ( ( Exec (D208 , D232) ) . D19 ) by SCMPDS_5:42
.= ( C175 . D19 ) by L1073 , L1076 , SCMPDS_2:47;
L1078: ( 0 ) <> ( abs ( ( D232 . ( GBP ) ) + 3 ) ) by L1068 , ABSVALUE:def 1;
L1079: D233 <> ( DataLoc (( D232 . ( GBP ) ) , 3) ) by L1078 , XTUPLE_0:1;
L1080: ( D230 . D233 ) = ( ( Exec (D208 , D232) ) . D233 ) by SCMPDS_5:42
.= ( 0 ) by L1068 , L1079 , SCMPDS_2:47;
L1081: ( DataLoc (( D230 . D233 ) , 3) ) = ( intpos ( ( 0 ) + 3 ) ) by L1080 , SCMP_GCD:1;
L1082: ( 0 ) <> ( abs ( ( D230 . ( GBP ) ) + 3 ) ) by L1080 , ABSVALUE:def 1;
L1083: D233 <> ( DataLoc (( D230 . ( GBP ) ) , 3) ) by L1082 , XTUPLE_0:1;
L1084: ( D229 . D233 ) = ( ( Exec (D209 , D230) ) . D233 ) by SCMPDS_5:41
.= ( 0 ) by L1080 , L1083 , SCMPDS_2:50;
L1085: 1 <> ( abs ( ( D230 . ( GBP ) ) + 3 ) ) by L1080 , ABSVALUE:def 1;
L1086: D18 <> ( DataLoc (( D230 . ( GBP ) ) , 3) ) by L1085 , XTUPLE_0:1;
L1087: ( D229 . D18 ) = ( ( Exec (D209 , D230) ) . D18 ) by SCMPDS_5:41
.= ( C175 . D18 ) by L1072 , L1086 , SCMPDS_2:50;
L1088: 2 <> ( abs ( ( D230 . ( GBP ) ) + 3 ) ) by L1080 , ABSVALUE:def 1;
L1089: D19 <> ( DataLoc (( D230 . ( GBP ) ) , 3) ) by L1088 , XTUPLE_0:1;
L1090: ( D229 . D19 ) = ( ( Exec (D209 , D230) ) . D19 ) by SCMPDS_5:41
.= ( C175 . D19 ) by L1077 , L1089 , SCMPDS_2:50;
L1091: ( ( Initialize D229 ) . D18 ) = ( D229 . D18 ) by SCMPDS_5:15;
L1092: ( ( Initialize D229 ) . D19 ) = ( D229 . D19 ) by SCMPDS_5:15;
L1093: ( D229 . D20 ) = ( ( Exec (D209 , D230) ) . D20 ) by SCMPDS_5:41
.= ( ( D230 . D20 ) - ( D230 . ( DataLoc (( D230 . D233 ) , 2) ) ) ) by L1081 , SCMPDS_2:50
.= ( ( D229 . D18 ) - ( D229 . D19 ) ) by L1080 , L1077 , L1074 , L1087 , L1090 , SCMP_GCD:1;
L1094: ( ( Initialize D229 ) . ( GBP ) ) = ( D229 . ( GBP ) ) by SCMPDS_5:15;
L1095: ( ( Initialize D229 ) . D20 ) = ( D229 . D20 ) by SCMPDS_5:15;
L1096: (D216 is_closed_on ( Initialize D229 ) , R9 & D216 is_halting_on ( Initialize D229 ) , R9) by L1066 , L1084 , L1087 , L1090 , L1041 , L1091 , L1092 , L1093 , L1094 , L1095;
L1097: D216 is_closed_on D229 , D231
proof
L1098: (for B181 being (Element of ( NAT )) holds ( IC ( Comput (( D231 +* ( stop D216 ) ) , ( Initialize ( Initialize D229 ) ) , B181) ) ) in ( dom ( stop D216 ) )) by L1096 , SCMPDS_6:def 2;
thus L1099: thesis by L1098 , SCMPDS_6:def 2;
end;
L1100: D216 is_halting_on D229 , D231
proof
L1101: ( D231 +* ( stop D216 ) ) halts_on ( Initialize ( Initialize D229 ) ) by L1096 , SCMPDS_6:def 3;
thus L1102: thesis by L1101 , SCMPDS_6:def 3;
end;
L1103: ( ( IExec (D216 , D231 , ( Initialize D229 )) ) . D18 ) = ( ( D229 . D18 ) gcd ( D229 . D19 ) ) by L1066 , L1084 , L1087 , L1090 , L1093 , L1041 , L1091 , L1092 , L1095 , L1094;
thus L1104: ( ( IExec (D226 , R9 , C175) ) . D18 ) = ( ( C175 . D18 ) gcd ( C175 . D19 ) ) by L1103 , L1087 , L1090 , L1097 , L1100 , SCPISORT:7;
L1105: ( ( IExec (D216 , D231 , ( Initialize D229 )) ) . D19 ) = ( ( D229 . D18 ) gcd ( D229 . D19 ) ) by L1066 , L1084 , L1087 , L1090 , L1093 , L1041 , L1091 , L1092 , L1095 , L1094;
thus L1106: ( ( IExec (D226 , R9 , C175) ) . D19 ) = ( ( C175 . D18 ) gcd ( C175 . D19 ) ) by L1105 , L1087 , L1090 , L1097 , L1100 , SCPISORT:7;
thus L1107: thesis by L1097 , L1065 , L1100 , SCPISORT:9;
end;
theorem
L1108: (for R9 being (Instruction-Sequence of ( SCMPDS )) holds (for B182 being ( 0 ) -started (State of ( SCMPDS )) holds (for B183 , B184 being Integer holds ((( B182 . ( intpos 1 ) ) = B183 & ( B182 . ( intpos 2 ) ) = B184 & B183 > ( 0 ) & B184 > ( 0 )) implies (( ( IExec (( GCD-Algorithm ) , R9 , B182) ) . ( intpos 1 ) ) = ( B183 gcd B184 ) & ( ( IExec (( GCD-Algorithm ) , R9 , B182) ) . ( intpos 2 ) ) = ( B183 gcd B184 ) & ( GCD-Algorithm ) is_closed_on B182 , R9 & ( GCD-Algorithm ) is_halting_on B182 , R9))))) by L1064;
