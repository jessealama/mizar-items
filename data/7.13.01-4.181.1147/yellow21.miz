:: Categorial Background for Duality Theory
::  by Grzegorz Bancerek
::
:: Received August 1, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, ORDERS_2, ORDERS_1, ZFMISC_1, FUNCT_1, RELAT_1, CARD_3,
      XBOOLE_0, SUBSET_1, SETFAM_1, ORDERS_3, ALTCAT_1, YELLOW18, WAYBEL_0,
      TARSKI, REWRITE1, PBOOLE, FUNCT_2, SEQM_3, FILTER_0, CAT_1, QC_LANG1,
      FUNCTOR0, WELLORD1, ALTCAT_3, CAT_3, LATTICES, RELAT_2, ORDINAL1,
      WELLORD2, CARD_1, LATTICE3, XXREAL_0, ORDINAL2, ARYTM_3, RCOMP_1,
      TREES_2, WAYBEL_8, WAYBEL_3, ALTCAT_2, YELLOW21;
 notations TARSKI, XBOOLE_0, SETFAM_1, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2,
      FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, CARD_3, BINOP_1, ORDINAL1, CARD_1,
      ORDERS_1, STRUCT_0, ORDERS_2, LATTICE3, ORDERS_3, WELLORD1, WELLORD2,
      YELLOW_0, WAYBEL_0, YELLOW_1, WAYBEL_3, WAYBEL_8, ALTCAT_1, ALTCAT_2,
      FUNCTOR0, ALTCAT_3, YELLOW18;
 constructors WELLORD1, ORDERS_3, WAYBEL_8, ALTCAT_3, YELLOW18, RELSET_1,
      WAYBEL20;
 registrations SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2,
      CARD_1, STRUCT_0, ORDERS_2, LATTICE3, YELLOW_0, ALTCAT_2, FUNCTOR0,
      WAYBEL_0, WAYBEL_3, WAYBEL_8, WAYBEL10, FUNCTOR2, ALTCAT_4, WAYBEL17,
      YELLOW_9, YELLOW18, WELLORD1, WELLORD2;
 requirements SUBSET, BOOLE;
 definitions TARSKI, RELAT_2, WELLORD1, WELLORD2, ORDERS_2, LATTICE3, ORDERS_3,
      ALTCAT_1, ALTCAT_3, YELLOW_0, WAYBEL_0, WAYBEL_3, YELLOW18, XBOOLE_0,
      BINOP_1, STRUCT_0;
 theorems ZFMISC_1, RELAT_1, FUNCT_1, WELLORD1, WELLORD2, ORDERS_2, ORDERS_1,
      FUNCT_2, ALTCAT_1, ALTCAT_2, ORDERS_3, ALTCAT_3, ORDINAL1, CARD_1,
      CARD_5, WAYBEL_0, WAYBEL13, ORDINAL3, TARSKI, RELSET_1, RELAT_2,
      LATTICE3, YELLOW_0, YELLOW_2, WAYBEL_3, WAYBEL_8, YELLOW18, WAYBEL20,
      YELLOW16, XBOOLE_0, XBOOLE_1, PARTFUN1, SETFAM_1, XTUPLE_0;
 schemes TARSKI, CARD_3, PBOOLE, CLASSES1, YELLOW18, YELLOW20, XBOOLE_0;

begin
definition
let C1 being set;
func C1 as_1-sorted -> 1-sorted equals 
:L1: C1 if C1 is 1-sorted otherwise 1-sorted (# C1 #);
coherence;
consistency;
end;
definition
let C2 being set;
defpred S1[ set ] means ($1 is  strict  strict  strict  strict Poset & (the carrier of ( $1 as_1-sorted )) in C2);
func POSETS C2 means 
:L3: (for R1 being set holds (R1 in it iff (R1 is  strict  strict  strict  strict Poset & (the carrier of ( R1 as_1-sorted )) in C2)));
uniqueness
proof
let C3 , C4 being set;
assume that
L4: (for R1 being set holds (R1 in C3 iff S1[ R1 ]))
and
L5: (for R1 being set holds (R1 in C4 iff S1[ R1 ]));
thus L6: thesis from XBOOLE_0:sch 2(L4 , L5);
end;
existence
proof
defpred S2[ set , set ] means (ex B1 being  strict Poset st ($2 = B1 & (the InternalRel of B1) = $1));
defpred S3[ set , set ] means $2 is (Order of $1);
deffunc H1(set) = ( bool [: $1 , $1 :] );
consider C5 being Function such that L7: ( dom C5 ) = C2 and L8: (for R1 being set holds (R1 in C2 implies (for R2 being set holds (R2 in ( C5 . R1 ) iff (R2 in H1(R1) & S3[ R1 , R2 ]))))) from CARD_3:sch 2;
L9:
now
let C6 , C7 , C8 being set;
assume L10: S2[ C6 , C7 ];
consider C9 being  strict Poset such that L11: (C7 = C9 & (the InternalRel of C9) = C6) by L10;
L12: ( dom (the InternalRel of C9) ) = (the carrier of C9) by ORDERS_1:14;
assume L13: S2[ C6 , C8 ];
thus L14: C7 = C8 by L13 , L11 , L12 , ORDERS_1:14;
end;
consider C10 being set such that L15: (for R1 being set holds (R1 in C10 iff (ex R2 being set st (R2 in ( Union C5 ) & S2[ R2 , R1 ])))) from TARSKI:sch 1(L9);
take C10;
let R1 being set;
thus L16:now
assume L17: R1 in C10;
consider R2 being set such that L18: R2 in ( Union C5 ) and L19: (ex B2 being  strict Poset st (R1 = B2 & (the InternalRel of B2) = R2)) by L17 , L15;
consider C11 being  strict Poset such that L20: R1 = C11 and L21: (the InternalRel of C11) = R2 by L19;
thus L22: R1 is  strict  strict  strict  strict Poset by L20;
consider C12 being set such that L23: C12 in C2 and L24: R2 in ( C5 . C12 ) by L7 , L18 , CARD_5:2;
reconsider D1 = R2 as (Order of C12) by L8 , L23 , L24;
L25: (( dom D1 ) = C12 & ( dom D1 ) = (the carrier of C11)) by L21 , ORDERS_1:14;
thus L26: (the carrier of ( R1 as_1-sorted )) in C2 by L25 , L20 , L23 , L1;
end;
assume that
L27: R1 is  strict  strict  strict  strict Poset
and
L28: (the carrier of ( R1 as_1-sorted )) in C2;
reconsider D2 = R1 as  strict Poset by L27;
L29: ( R1 as_1-sorted ) = D2 by L1;
L30: (the InternalRel of D2) in ( C5 . (the carrier of D2) ) by L29 , L8 , L28;
L31: (the InternalRel of D2) in ( Union C5 ) by L30 , L7 , L28 , L29 , CARD_5:2;
thus L32: thesis by L31 , L15;
end;
end;
registration
let C13 being non  empty set;
cluster ( POSETS C13 ) -> non  empty;
coherence
proof
set D3 = the (Element of C13);
set D4 = the (Order of D3);
L34: ( RelStr (# D3 , D4 #) as_1-sorted ) = RelStr (# D3 , D4 #) by L1;
thus L35: thesis by L34 , L3;
end;
end;
registration
let C14 being  with_non-empty_elements set;
cluster ( POSETS C14 ) ->  POSet_set-like;
coherence
proof
let C15 being set;
assume L37: C15 in ( POSETS C14 );
L38: (the carrier of ( C15 as_1-sorted )) in C14 by L37 , L3;
reconsider D5 = C15 as Poset by L37 , L3;
L39: D5 = ( D5 as_1-sorted ) by L1;
thus L40: thesis by L39 , L38;
end;
end;
definition
let C16 being category;
attr C16 is  carrier-underlaid
means
:L42: (for B3 being (object of C16) holds (ex B4 being 1-sorted st (B3 = B4 & ( the_carrier_of B3 ) = (the carrier of B4))));
end;
definition
let C17 being category;
attr C17 is  lattice-wise
means
:L44: (C17 is  semi-functional  set-id-inheriting & (for B5 being (object of C17) holds B5 is LATTICE) & (for B6 , B7 being (object of C17) holds (for B8 , B9 being LATTICE holds ((B8 = B6 & B9 = B7) implies <^ B6 , B7 ^> c= ( MonFuncs (B8 , B9) )))));
end;
definition
let C18 being category;
attr C18 is  with_complete_lattices
means
:L46: (C18 is  lattice-wise & (for B10 being (object of C18) holds B10 is  complete  complete  complete  complete LATTICE));
end;
registration
cluster  with_complete_lattices ->  lattice-wise for category;
coherence by L46;
cluster  lattice-wise ->  concrete  carrier-underlaid for category;
coherence
proof
deffunc H2(set) = (the carrier of ( $1 as_1-sorted ));
let C19 being category;
assume that
L48: C19 is  semi-functional  set-id-inheriting
and
L49: (for B11 being (object of C19) holds B11 is LATTICE)
and
L50: (for B12 , B13 being (object of C19) holds (for B14 , B15 being LATTICE holds ((B14 = B12 & B15 = B13) implies <^ B12 , B13 ^> c= ( MonFuncs (B14 , B15) ))));
consider C20 being (ManySortedSet of C19) such that L51: (for B16 being (Element of C19) holds ( C20 . B16 ) = H2(B16)) from PBOOLE:sch 5;
L52: C19 is  para-functional
proof
take C20;
let C21 , C22 being (object of C19);
reconsider D6 = C21 , D7 = C22 as LATTICE by L49;
L53: <^ C21 , C22 ^> c= ( MonFuncs (D6 , D7) ) by L50;
L54: ( C22 as_1-sorted ) = D7 by L1;
L55: ( C20 . C22 ) = (the carrier of D7) by L54 , L51;
L56: ( C21 as_1-sorted ) = D6 by L1;
L57: ( C20 . C21 ) = (the carrier of D6) by L56 , L51;
L58: ( MonFuncs (D6 , D7) ) c= ( Funcs (( C20 . C21 ) , ( C20 . C22 )) ) by L57 , L55 , ORDERS_3:11;
thus L59: thesis by L58 , L53 , XBOOLE_1:1;
end;
thus L60: C19 is  concrete by L52 , L48;
let C23 being (object of C19);
reconsider D8 = C23 as LATTICE by L49;
L61: (( idm C23 ) in <^ C23 , C23 ^> & <^ C23 , C23 ^> c= ( MonFuncs (D8 , D8) )) by L50;
consider C24 being (Function of D8 , D8) such that L62: ( idm C23 ) = C24 and L63: C24 in ( Funcs ((the carrier of D8) , (the carrier of D8)) ) and L64: C24 is  monotone by L61 , ORDERS_3:def 6;
take D8;
thus L65: C23 = D8;
thus L66: ( the_carrier_of C23 ) = ( dom ( id ( the_carrier_of C23 ) ) ) by RELAT_1:45
.= ( dom C24 ) by L48 , L62 , YELLOW18:def 10
.= (the carrier of D8) by L63 , FUNCT_2:92;
end;
end;
scheme localCLCatEx { F1() -> non  empty set , P1[set , set , set] } : (ex B17 being  strict category st (B17 is  lattice-wise & (the carrier of B17) = F1() & (for B18 , B19 being LATTICE holds (for B20 being  monotone (Function of B18 , B19) holds (B20 in ( (the Arrows of B17) . (B18 , B19) ) iff (B18 in F1() & B19 in F1() & P1[ B18 , B19 , B20 ]))))))
provided
L68: (for B21 being (Element of F1()) holds B21 is LATTICE)
and
L69: (for B22 , B23 , B24 being LATTICE holds ((B22 in F1() & B23 in F1() & B24 in F1()) implies (for B25 being (Function of B22 , B23) holds (for B26 being (Function of B23 , B24) holds ((P1[ B22 , B23 , B25 ] & P1[ B23 , B24 , B26 ]) implies P1[ B22 , B24 , ( B26 * B25 ) ])))))
and
L70: (for B27 being LATTICE holds (B27 in F1() implies P1[ B27 , B27 , ( id B27 ) ]))
proof
defpred S4[ set , set ] means (ex B28 , B29 being LATTICE st ($1 = [ B28 , B29 ] & (for B30 being set holds (B30 in $2 iff (B30 in ( MonFuncs (B28 , B29) ) & P1[ B28 , B29 , B30 ])))));
set D9 = F1();
L71:
now
let R1 being set;
assume L72: R1 in [: D9 , D9 :];
consider C25 , C26 being set such that L73: (C25 in D9 & C26 in D9) and L74: R1 = [ C25 , C26 ] by L72 , ZFMISC_1:def 2;
reconsider D10 = C25 , D11 = C26 as LATTICE by L68 , L73;
defpred S5[ set ] means P1[ D10 , D11 , $1 ];
consider C27 being set such that L75: (for B31 being set holds (B31 in C27 iff (B31 in ( MonFuncs (D10 , D11) ) & S5[ B31 ]))) from XBOOLE_0:sch 1;
take D12 = C27;
thus L76: S4[ R1 , D12 ] by L74 , L75;
end;
consider C28 being Function such that L77: ( dom C28 ) = [: D9 , D9 :] and L78: (for R1 being set holds (R1 in [: D9 , D9 :] implies S4[ R1 , ( C28 . R1 ) ])) from CLASSES1:sch 1(L71);
defpred S6[ set , set ] means (for B32 being LATTICE holds (B32 = $1 implies $2 = (the carrier of B32)));
L79:
now
let R1 being set;
assume L80: R1 in D9;
reconsider D13 = R1 as LATTICE by L80 , L68;
reconsider D14 = (the carrier of D13) as set;
take D15 = D14;
thus L81: S6[ R1 , D15 ];
end;
consider C29 being Function such that L82: ( dom C29 ) = D9 and L83: (for R1 being set holds (R1 in D9 implies S6[ R1 , ( C29 . R1 ) ])) from CLASSES1:sch 1(L79);
deffunc H3(set , set) = ( C28 . [ $1 , $2 ] );
L84:
now
let C30 , C31 being LATTICE;
assume L85: (C30 in D9 & C31 in D9);
L86: [ C30 , C31 ] in [: D9 , D9 :] by L85 , ZFMISC_1:87;
consider C32 , C33 being LATTICE such that L87: [ C30 , C31 ] = [ C32 , C33 ] and L88: (for B33 being set holds (B33 in ( C28 . [ C30 , C31 ] ) iff (B33 in ( MonFuncs (C32 , C33) ) & P1[ C32 , C33 , B33 ]))) by L86 , L78;
let C34 being set;
L89: (C30 = C32 & C31 = C33) by L87 , XTUPLE_0:1;
thus L90:now
assume L91: C34 in ( C28 . [ C30 , C31 ] );
thus L92: P1[ C30 , C31 , C34 ] by L91 , L88 , L89;
thus L93: C34 in ( MonFuncs (C30 , C31) ) by L88 , L89 , L91;
L94: (ex B34 being (Function of C30 , C31) st (C34 = B34 & B34 in ( Funcs ((the carrier of C30) , (the carrier of C31)) ) & B34 is  monotone)) by L93 , ORDERS_3:def 6;
thus L95: (C34 in ( Funcs ((the carrier of C30) , (the carrier of C31)) ) & C34 is  monotone  monotone  monotone  monotone (Function of C30 , C31)) by L94;
end;
assume L96: C34 is  monotone  monotone  monotone  monotone (Function of C30 , C31);
reconsider D16 = C34 as  monotone (Function of C30 , C31) by L96;
L97: ((the carrier of C31) <> ( {} ) implies (( dom D16 ) = (the carrier of C30) & ( rng D16 ) c= (the carrier of C31))) by FUNCT_2:def 1;
L98: D16 in ( Funcs ((the carrier of C30) , (the carrier of C31)) ) by L97 , FUNCT_2:def 2;
L99: C34 in ( MonFuncs (C30 , C31) ) by L98 , ORDERS_3:def 6;
thus L100: (P1[ C30 , C31 , C34 ] implies C34 in ( C28 . [ C30 , C31 ] )) by L99 , L88 , L89;
end;
L101: (for B35 , B36 , B37 being (Element of D9) holds (for B38 , B39 being Function holds ((B38 in H3(B35 , B36) & B39 in H3(B36 , B37)) implies ( B39 * B38 ) in H3(B35 , B37))))
proof
let C35 , C36 , C37 being (Element of D9);
let C38 , C39 being Function;
assume that
L102: C38 in ( C28 . [ C35 , C36 ] )
and
L103: C39 in ( C28 . [ C36 , C37 ] );
reconsider D17 = C35 , D18 = C36 , D19 = C37 as LATTICE by L68;
reconsider D20 = C39 as  monotone (Function of D18 , D19) by L84 , L103;
reconsider D21 = C38 as  monotone (Function of D17 , D18) by L84 , L102;
L104: (P1[ D17 , D18 , D21 ] & P1[ D18 , D19 , D20 ]) by L84 , L102 , L103;
L105: P1[ C35 , C37 , ( D20 * D21 ) ] by L104 , L69;
L106: (( D20 * D21 ) is  monotone  monotone  monotone  monotone (Function of D17 , D19) implies ( D20 * D21 ) in ( C28 . [ D17 , D19 ] )) by L105 , L84;
thus L107: thesis by L106 , YELLOW_2:12;
end;
deffunc H4(set) = ( C29 . $1 );
L108: (for B40 , B41 being (Element of D9) holds H3(B40 , B41) c= ( Funcs (H4(B40) , H4(B41)) ))
proof
let C40 , C41 being (Element of D9);
let C42 being set;
reconsider D22 = C40 , D23 = C41 as LATTICE by L68;
assume L109: C42 in ( C28 . [ C40 , C41 ] );
L110: C42 in ( Funcs ((the carrier of D22) , (the carrier of D23)) ) by L109 , L84;
L111: C42 in ( Funcs (( C29 . C40 ) , (the carrier of D23)) ) by L110 , L83;
thus L112: thesis by L111 , L83;
end;
L113:
now
let C43 being (Element of D9);
reconsider D24 = C43 as LATTICE by L68;
L114: (( id ( C29 . C43 ) ) = ( id D24 ) & P1[ D24 , D24 , ( id D24 ) ]) by L70 , L83;
thus L115: ( id H4(C43) ) in H3(C43 , C43) by L114 , L84;
end;
consider C44 being  concrete  strict category such that L116: (the carrier of C44) = D9 and L117: (for B42 being (object of C44) holds ( the_carrier_of B42 ) = H4(B42)) and L118: (for B43 , B44 being (object of C44) holds <^ B43 , B44 ^> = H3(B43 , B44)) from YELLOW18:sch 16(L101 , L108 , L113);
take C44;
thus L119: C44 is  semi-functional  set-id-inheriting;
thus L120: (for B45 being (object of C44) holds B45 is LATTICE) by L68 , L116;
thus L121: (for B46 , B47 being (object of C44) holds (for B48 , B49 being LATTICE holds ((B48 = B46 & B49 = B47) implies <^ B46 , B47 ^> c= ( MonFuncs (B48 , B49) ))))
proof
let C45 , C46 being (object of C44);
let C47 , C48 being LATTICE;
assume L122: (C47 = C45 & C48 = C46);
let C49 being set;
L123: <^ C45 , C46 ^> = ( C28 . [ C47 , C48 ] ) by L118 , L122;
thus L124: thesis by L123 , L84 , L116 , L122;
end;

thus L125: (the carrier of C44) = F1() by L116;
let C50 , C51 being LATTICE;
let C52 being  monotone (Function of C50 , C51);
thus L126:now
assume L127: C52 in ( (the Arrows of C44) . (C50 , C51) );
L128: [ C50 , C51 ] in ( dom (the Arrows of C44) ) by L127 , FUNCT_1:def 2;
L129: [ C50 , C51 ] in [: D9 , D9 :] by L128 , L116;
thus L130: (C50 in D9 & C51 in D9) by L129 , ZFMISC_1:87;
reconsider D25 = C50 , D26 = C51 as (object of C44) by L116 , L129 , ZFMISC_1:87;
L131: ( (the Arrows of C44) . [ C50 , C51 ] ) = <^ D25 , D26 ^>
.= ( C28 . [ D25 , D26 ] ) by L118;
thus L132: P1[ C50 , C51 , C52 ] by L131 , L84 , L116 , L127;
end;
assume L133: (C50 in F1() & C51 in F1());
reconsider D27 = C50 , D28 = C51 as (object of C44) by L133 , L116;
L134: ( (the Arrows of C44) . [ C50 , C51 ] ) = <^ D27 , D28 ^>
.= ( C28 . [ D27 , D28 ] ) by L118;
thus L135: thesis by L134 , L84 , L133;
end;
registration
cluster  strict  with_complete_lattices for category;
existence
proof
defpred S7[ set , set , set ] means $3 = $3;
set D29 = the  complete LATTICE;
L136: (for B50 , B51 , B52 being LATTICE holds ((B50 in { D29 } & B51 in { D29 } & B52 in { D29 }) implies (for B53 being (Function of B50 , B51) holds (for B54 being (Function of B51 , B52) holds ((S7[ B50 , B51 , B53 ] & S7[ B51 , B52 , B54 ]) implies S7[ B50 , B52 , ( B54 * B53 ) ])))));
L137: (for B55 being LATTICE holds (B55 in { D29 } implies S7[ B55 , B55 , ( id B55 ) ]));
L138: (for B56 being (Element of { D29 }) holds B56 is LATTICE) by TARSKI:def 1;
consider C53 being  strict category such that L139: C53 is  lattice-wise and L140: (the carrier of C53) = { D29 } and L141: (for B57 , B58 being LATTICE holds (for B59 being  monotone (Function of B57 , B58) holds (B59 in ( (the Arrows of C53) . (B57 , B58) ) iff (B57 in { D29 } & B58 in { D29 } & S7[ B57 , B58 , B59 ])))) from localCLCatEx(L138 , L136 , L137);
take C53;
thus L142: C53 is  strict;
thus L143: C53 is  lattice-wise by L139;
let C54 being (object of C53);
thus L144: thesis by L140 , TARSKI:def 1;
end;
end;
theorem
L146: (for B60 being  carrier-underlaid category holds (for B61 being (object of B60) holds ( the_carrier_of B61 ) = (the carrier of ( B61 as_1-sorted ))))
proof
let C55 being  carrier-underlaid category;
let C56 being (object of C55);
L147: (ex B62 being 1-sorted st (C56 = B62 & ( the_carrier_of C56 ) = (the carrier of B62))) by L42;
thus L148: thesis by L147 , L1;
end;
theorem
L149: (for B63 being  set-id-inheriting  carrier-underlaid category holds (for B64 being (object of B63) holds ( idm B64 ) = ( id ( B64 as_1-sorted ) )))
proof
let C57 being  set-id-inheriting  carrier-underlaid category;
let C58 being (object of C57);
L150: (ex B65 being 1-sorted st (C58 = B65 & ( the_carrier_of C58 ) = (the carrier of B65))) by L42;
L151: ( the_carrier_of C58 ) = (the carrier of ( C58 as_1-sorted )) by L150 , L1;
thus L152: thesis by L151 , YELLOW18:def 10;
end;
notation
let C59 being  lattice-wise category;
let C60 being (object of C59);
synonym latt C60 for C60 as_1-sorted;
end;
definition
let C61 being  lattice-wise category;
let C62 being (object of C61);
redefine func latt C62 -> LATTICE equals 
C62;
coherence
proof
L154: C62 is LATTICE by L44;
thus L155: thesis by L154 , L1;
end;
compatibility
proof
L156: C62 is LATTICE by L44;
thus L157: thesis by L156 , L1;
end;
end;
notation
let C63 being  with_complete_lattices category;
let C64 being (object of C63);
synonym latt C64 for C64 as_1-sorted;
end;
definition
let C65 being  with_complete_lattices category;
let C66 being (object of C65);
redefine func latt C66 ->  complete LATTICE;

coherence by L46;
end;
definition
let C67 being  lattice-wise category;
let C68 , C69 being (object of C67);
assume that
L161: <^ C68 , C69 ^> <> ( {} );
let C70 being (Morphism of C68 , C69);
func @ C70 ->  monotone (Function of ( latt C68 ) , ( latt C69 )) equals 
:L162: C70;
coherence
proof
L163: (C70 in <^ C68 , C69 ^> & <^ C68 , C69 ^> c= ( MonFuncs (( latt C68 ) , ( latt C69 )) )) by L161 , L44;
L164: (ex B66 being (Function of ( latt C68 ) , ( latt C69 )) st (C70 = B66 & B66 in ( Funcs ((the carrier of ( latt C68 )) , (the carrier of ( latt C69 ))) ) & B66 is  monotone)) by L163 , ORDERS_3:def 6;
thus L165: thesis by L164;
end;
end;
theorem
L167: (for B67 being  lattice-wise category holds (for B68 , B69 , B70 being (object of B67) holds ((<^ B68 , B69 ^> <> ( {} ) & <^ B69 , B70 ^> <> ( {} )) implies (for B71 being (Morphism of B68 , B69) holds (for B72 being (Morphism of B69 , B70) holds ( B72 * B71 ) = ( ( @ B72 ) * ( @ B71 ) ))))))
proof
let C71 being  lattice-wise category;
let C72 , C73 , C74 being (object of C71);
assume that
L168: (<^ C72 , C73 ^> <> ( {} ) & <^ C73 , C74 ^> <> ( {} ));
let C75 being (Morphism of C72 , C73);
let C76 being (Morphism of C73 , C74);
L169: (C75 = ( @ C75 ) & C76 = ( @ C76 )) by L168 , L162;
thus L170: thesis by L169 , L168 , YELLOW18:36;
end;
scheme CLCatEx1 { F2() -> non  empty set , P2[set , set , set] } : (ex B73 being  lattice-wise  strict category st ((the carrier of B73) = F2() & (for B74 , B75 being (object of B73) holds (for B76 being  monotone (Function of ( latt B74 ) , ( latt B75 )) holds (B76 in <^ B74 , B75 ^> iff P2[ ( latt B74 ) , ( latt B75 ) , B76 ])))))
provided
L171: (for B77 being (Element of F2()) holds B77 is LATTICE)
and
L172: (for B78 , B79 , B80 being LATTICE holds ((B78 in F2() & B79 in F2() & B80 in F2()) implies (for B81 being (Function of B78 , B79) holds (for B82 being (Function of B79 , B80) holds ((P2[ B78 , B79 , B81 ] & P2[ B79 , B80 , B82 ]) implies P2[ B78 , B80 , ( B82 * B81 ) ])))))
and
L173: (for B83 being LATTICE holds (B83 in F2() implies P2[ B83 , B83 , ( id B83 ) ]))
proof
L174: (for B84 being LATTICE holds (B84 in F2() implies P2[ B84 , B84 , ( id B84 ) ])) by L173;
L175: (for B85 , B86 , B87 being LATTICE holds ((B85 in F2() & B86 in F2() & B87 in F2()) implies (for B88 being (Function of B85 , B86) holds (for B89 being (Function of B86 , B87) holds ((P2[ B85 , B86 , B88 ] & P2[ B86 , B87 , B89 ]) implies P2[ B85 , B87 , ( B89 * B88 ) ]))))) by L172;
consider C77 being  strict category such that L176: C77 is  lattice-wise and L177: (the carrier of C77) = F2() and L178: (for B90 , B91 being LATTICE holds (for B92 being  monotone (Function of B90 , B91) holds (B92 in ( (the Arrows of C77) . (B90 , B91) ) iff (B90 in F2() & B91 in F2() & P2[ B90 , B91 , B92 ])))) from localCLCatEx(L171 , L175 , L174);
reconsider D30 = C77 as  lattice-wise  strict category by L176;
take D30;
thus L179: (the carrier of D30) = F2() by L177;
let C78 , C79 being (object of D30);
thus L180: thesis by L177 , L178;
end;
scheme CLCatEx2 { F3() -> non  empty set , P3[set] , P4[set , set , set] } : (ex B93 being  lattice-wise  strict category st ((for B94 being LATTICE holds (B94 is (object of B93) iff (B94 is  strict & P3[ B94 ] & (the carrier of B94) in F3()))) & (for B95 , B96 being (object of B93) holds (for B97 being  monotone (Function of ( latt B95 ) , ( latt B96 )) holds (B97 in <^ B95 , B96 ^> iff P4[ ( latt B95 ) , ( latt B96 ) , B97 ])))))
provided
L181: (ex B98 being  strict LATTICE st (P3[ B98 ] & (the carrier of B98) in F3()))
and
L182: (for B99 , B100 , B101 being LATTICE holds ((P3[ B99 ] & P3[ B100 ] & P3[ B101 ]) implies (for B102 being (Function of B99 , B100) holds (for B103 being (Function of B100 , B101) holds ((P4[ B99 , B100 , B102 ] & P4[ B100 , B101 , B103 ]) implies P4[ B99 , B101 , ( B103 * B102 ) ])))))
and
L183: (for B104 being LATTICE holds (P3[ B104 ] implies P4[ B104 , B104 , ( id B104 ) ]))
proof
defpred S8[ set ] means ($1 is LATTICE & P3[ $1 ]);
consider C80 being set such that L184: (for R1 being set holds (R1 in C80 iff (R1 in ( POSETS F3() ) & S8[ R1 ]))) from XBOOLE_0:sch 1;
consider C81 being  strict LATTICE such that L185: P3[ C81 ] and L186: (the carrier of C81) in F3() by L181;
L187: ( C81 as_1-sorted ) = C81 by L1;
L188: C81 in ( POSETS F3() ) by L187 , L186 , L3;
reconsider D31 = C80 as non  empty set by L188 , L184 , L185;
L189:
now
let C82 , C83 , C84 being LATTICE;
assume that
L190: (C82 in D31 & C83 in D31)
and
L191: C84 in D31;
L192: P3[ C84 ] by L184 , L191;
L193: (P3[ C82 ] & P3[ C83 ]) by L184 , L190;
thus L194: (for B105 being (Function of C82 , C83) holds (for B106 being (Function of C83 , C84) holds ((P4[ C82 , C83 , B105 ] & P4[ C83 , C84 , B106 ]) implies P4[ C82 , C84 , ( B106 * B105 ) ]))) by L193 , L182 , L192;
end;
L195:
now
let C85 being LATTICE;
assume L196: C85 in D31;
L197: P3[ C85 ] by L196 , L184;
thus L198: P4[ C85 , C85 , ( id C85 ) ] by L197 , L183;
end;
L199: (for B107 being (Element of D31) holds B107 is LATTICE) by L184;
consider C86 being  lattice-wise  strict category such that L200: (the carrier of C86) = D31 and L201: (for B108 , B109 being (object of C86) holds (for B110 being  monotone (Function of ( latt B108 ) , ( latt B109 )) holds (B110 in <^ B108 , B109 ^> iff P4[ ( latt B108 ) , ( latt B109 ) , B110 ]))) from CLCatEx1(L199 , L189 , L195);
take C86;
thus L202:now
let C87 being LATTICE;
L203: ( C87 as_1-sorted ) = C87 by L1;
L204: (C87 in ( POSETS F3() ) iff (C87 is  strict  strict  strict  strict Poset & (the carrier of C87) in F3())) by L203 , L3;
thus L205: (C87 is (object of C86) iff (C87 is  strict & P3[ C87 ] & (the carrier of C87) in F3())) by L204 , L184 , L200;
end;
thus L206: thesis by L201;
end;
scheme CLCatUniq1 { F4() -> non  empty set , P5[set , set , set] } : (for B111 , B112 being  lattice-wise category holds (((the carrier of B111) = F4() & (for B113 , B114 being (object of B111) holds (for B115 being  monotone (Function of ( latt B113 ) , ( latt B114 )) holds (B115 in <^ B113 , B114 ^> iff P5[ B113 , B114 , B115 ]))) & (the carrier of B112) = F4() & (for B116 , B117 being (object of B112) holds (for B118 being  monotone (Function of ( latt B116 ) , ( latt B117 )) holds (B118 in <^ B116 , B117 ^> iff P5[ B116 , B117 , B118 ])))) implies ( the AltCatStr of B111 ) = ( the AltCatStr of B112 )))
proof
let C88 , C89 being  lattice-wise category;
deffunc H5(set , set) = ( (the Arrows of C88) . ($1 , $2) );
assume that
L207: (the carrier of C88) = F4()
and
L208: (for B119 , B120 being (object of C88) holds (for B121 being  monotone (Function of ( latt B119 ) , ( latt B120 )) holds (B121 in <^ B119 , B120 ^> iff P5[ B119 , B120 , B121 ])))
and
L209: (the carrier of C89) = F4()
and
L210: (for B122 , B123 being (object of C89) holds (for B124 being  monotone (Function of ( latt B122 ) , ( latt B123 )) holds (B124 in <^ B122 , B123 ^> iff P5[ B122 , B123 , B124 ])));
L211:
now
let C90 , C91 being (object of C89);
reconsider D32 = C90 , D33 = C91 as (object of C88) by L207 , L209;
L212: <^ D32 , D33 ^> = ( (the Arrows of C88) . (D32 , D33) );
thus L213: <^ C90 , C91 ^> = ( (the Arrows of C88) . (C90 , C91) )
proof
thus L214:now
let R1 being set;
assume L215: R1 in <^ C90 , C91 ^>;
reconsider D34 = R1 as (Morphism of C90 , C91) by L215;
L216: ( @ D34 ) = D34 by L215 , L162;
L217: P5[ ( latt D32 ) , ( latt D33 ) , ( @ D34 ) ] by L216 , L210 , L215;
thus L218: R1 in ( (the Arrows of C88) . (C90 , C91) ) by L217 , L208 , L212 , L216;
end;
let R1 being set;
assume L219: R1 in ( (the Arrows of C88) . (C90 , C91) );
reconsider D35 = R1 as (Morphism of D32 , D33) by L219;
L220: ( @ D35 ) = D35 by L219 , L162;
L221: P5[ ( latt C90 ) , ( latt C91 ) , ( @ D35 ) ] by L220 , L208 , L219;
thus L222: thesis by L221 , L210 , L220;
end;

end;
L214: (for B125 , B126 being (object of C88) holds <^ B125 , B126 ^> = ( (the Arrows of C88) . (B125 , B126) ));
L215: (for B127 , B128 being  para-functional  semi-functional category holds (((the carrier of B127) = F4() & (for B129 , B130 being (object of B127) holds <^ B129 , B130 ^> = H5(B129 , B130)) & (the carrier of B128) = F4() & (for B131 , B132 being (object of B128) holds <^ B131 , B132 ^> = H5(B131 , B132))) implies ( the AltCatStr of B127 ) = ( the AltCatStr of B128 ))) from YELLOW18:sch 19;
thus L216: thesis by L215 , L207 , L209 , L214 , L211;
end;
scheme CLCatUniq2 { F5() -> non  empty set , P6[set] , P7[set , set , set] } : (for B133 , B134 being  lattice-wise category holds (((for B135 being LATTICE holds (B135 is (object of B133) iff (B135 is  strict & P6[ B135 ] & (the carrier of B135) in F5()))) & (for B136 , B137 being (object of B133) holds (for B138 being  monotone (Function of ( latt B136 ) , ( latt B137 )) holds (B138 in <^ B136 , B137 ^> iff P7[ B136 , B137 , B138 ]))) & (for B139 being LATTICE holds (B139 is (object of B134) iff (B139 is  strict & P6[ B139 ] & (the carrier of B139) in F5()))) & (for B140 , B141 being (object of B134) holds (for B142 being  monotone (Function of ( latt B140 ) , ( latt B141 )) holds (B142 in <^ B140 , B141 ^> iff P7[ B140 , B141 , B142 ])))) implies ( the AltCatStr of B133 ) = ( the AltCatStr of B134 )))
proof
let C92 , C93 being  lattice-wise category;
assume that
L217: (for B143 being LATTICE holds (B143 is (object of C92) iff (B143 is  strict & P6[ B143 ] & (the carrier of B143) in F5())))
and
L218: (for B144 , B145 being (object of C92) holds (for B146 being  monotone (Function of ( latt B144 ) , ( latt B145 )) holds (B146 in <^ B144 , B145 ^> iff P7[ B144 , B145 , B146 ])))
and
L219: (for B147 being LATTICE holds (B147 is (object of C93) iff (B147 is  strict & P6[ B147 ] & (the carrier of B147) in F5())));
L220: (the carrier of C93) = (the carrier of C92)
proof
thus L221:now
let R1 being set;
assume L222: R1 in (the carrier of C93);
L223: R1 is LATTICE by L222 , L44;
L224: (R1 is  strict  strict  strict  strict LATTICE & P6[ R1 ]) by L223 , L219 , L222;
L225: ( R1 as_1-sorted ) = R1 by L223 , L1;
L226: (the carrier of ( R1 as_1-sorted )) in F5() by L225 , L219 , L222 , L223;
L227: R1 is (object of C92) by L226 , L217 , L225 , L224;
thus L228: R1 in (the carrier of C92) by L227;
end;
let R1 being set;
assume L229: R1 in (the carrier of C92);
L230: R1 is LATTICE by L229 , L44;
L231: (R1 is  strict  strict  strict  strict LATTICE & P6[ R1 ]) by L230 , L217 , L229;
L232: ( R1 as_1-sorted ) = R1 by L230 , L1;
L233: (the carrier of ( R1 as_1-sorted )) in F5() by L232 , L217 , L229 , L230;
L234: R1 is (object of C93) by L233 , L219 , L232 , L231;
thus L235: thesis by L234;
end;
L236: (for B148 , B149 being  lattice-wise category holds (((the carrier of B148) = (the carrier of C92) & (for B150 , B151 being (object of B148) holds (for B152 being  monotone (Function of ( latt B150 ) , ( latt B151 )) holds (B152 in <^ B150 , B151 ^> iff P7[ B150 , B151 , B152 ]))) & (the carrier of B149) = (the carrier of C92) & (for B153 , B154 being (object of B149) holds (for B155 being  monotone (Function of ( latt B153 ) , ( latt B154 )) holds (B155 in <^ B153 , B154 ^> iff P7[ B153 , B154 , B155 ])))) implies ( the AltCatStr of B148 ) = ( the AltCatStr of B149 ))) from CLCatUniq1;
thus L237: thesis by L236 , L218 , L220;
end;
scheme CLCovariantFunctorEx { P8 , P9[set , set , set] , F6 , F7() ->  lattice-wise category , F8(set) -> LATTICE , F9(set , set , set) -> Function } : (ex B156 being  covariant  strict (Functor of F6() , F7()) st ((for B157 being (object of F6()) holds ( B156 . B157 ) = F8(( latt B157 ))) & (for B158 , B159 being (object of F6()) holds (<^ B158 , B159 ^> <> ( {} ) implies (for B160 being (Morphism of B158 , B159) holds ( B156 . B160 ) = F9(( latt B158 ) , ( latt B159 ) , ( @ B160 )))))))
provided
L238: (for B161 , B162 being LATTICE holds (for B163 being (Function of B161 , B162) holds (B163 in ( (the Arrows of F6()) . (B161 , B162) ) iff (B161 in (the carrier of F6()) & B162 in (the carrier of F6()) & P8[ B161 , B162 , B163 ]))))
and
L239: (for B164 , B165 being LATTICE holds (for B166 being (Function of B164 , B165) holds (B166 in ( (the Arrows of F7()) . (B164 , B165) ) iff (B164 in (the carrier of F7()) & B165 in (the carrier of F7()) & P9[ B164 , B165 , B166 ]))))
and
L240: (for B167 being LATTICE holds (B167 in (the carrier of F6()) implies F8(B167) in (the carrier of F7())))
and
L241: (for B168 , B169 being LATTICE holds (for B170 being (Function of B168 , B169) holds (P8[ B168 , B169 , B170 ] implies (F9(B168 , B169 , B170) is (Function of F8(B168) , F8(B169)) & P9[ F8(B168) , F8(B169) , F9(B168 , B169 , B170) ]))))
and
L242: (for B171 being LATTICE holds (B171 in (the carrier of F6()) implies F9(B171 , B171 , ( id B171 )) = ( id F8(B171) )))
and
L243: (for B172 , B173 , B174 being LATTICE holds (for B175 being (Function of B172 , B173) holds (for B176 being (Function of B173 , B174) holds ((P8[ B172 , B173 , B175 ] & P8[ B173 , B174 , B176 ]) implies F9(B172 , B174 , ( B176 * B175 )) = ( F9(B173 , B174 , B176) * F9(B172 , B173 , B175) )))))
proof
L244: (for B177 , B178 being (object of F6()) holds (<^ B177 , B178 ^> <> ( {} ) implies (for B179 being (Morphism of B177 , B178) holds F9(B177 , B178 , B179) in ( (the Arrows of F7()) . (F8(B177) , F8(B178)) ))))
proof
let C94 , C95 being (object of F6());
assume that
L245: <^ C94 , C95 ^> <> ( {} );
let C96 being (Morphism of C94 , C95);
L246: C96 = ( @ C96 ) by L245 , L162;
L247: P8[ C94 , C95 , C96 ] by L246 , L238 , L245;
L248: (F9(C94 , C95 , C96) is (Function of F8(C94) , F8(C95)) & P9[ F8(C94) , F8(C95) , F9(C94 , C95 , C96) ]) by L247 , L241 , L246;
L249: (F8(C94) in (the carrier of F7()) & F8(C95) in (the carrier of F7())) by L240 , L246;
thus L250: thesis by L249 , L239 , L248;
end;
L251:
now
let C97 , C98 , C99 being (object of F6());
assume that
L252: <^ C97 , C98 ^> <> ( {} )
and
L253: <^ C98 , C99 ^> <> ( {} );
let C100 being (Morphism of C97 , C98);
let C101 being (Morphism of C98 , C99);
let C102 , C103 , C104 being (object of F7());
assume that
L254: C102 = F8(C97)
and
L255: C103 = F8(C98)
and
L256: C104 = F8(C99);
let C105 being (Morphism of C102 , C103);
let C106 being (Morphism of C103 , C104);
assume that
L257: (C105 = F9(C97 , C98 , C100) & C106 = F9(C98 , C99 , C101));
L258: F9(C97 , C98 , C100) in ( (the Arrows of F7()) . (F8(C97) , F8(C98)) ) by L244 , L252;
L259: ( @ C105 ) = C105 by L258 , L254 , L255 , L162;
L260: ( @ C101 ) = C101 by L253 , L162;
L261: P8[ C98 , C99 , C101 ] by L260 , L238 , L253;
L262: F9(C98 , C99 , C101) in ( (the Arrows of F7()) . (F8(C98) , F8(C99)) ) by L244 , L253;
L263: ( @ C106 ) = C106 by L262 , L255 , L256 , L162;
L264: ( @ C100 ) = C100 by L252 , L162;
L265: P8[ C97 , C98 , C100 ] by L264 , L238 , L252;
L266: F9(C97 , C99 , ( ( @ C101 ) * ( @ C100 ) )) = ( F9(C98 , C99 , C101) * F9(C97 , C98 , C100) ) by L265 , L243 , L264 , L260 , L261
.= ( C106 * C105 ) by L254 , L255 , L256 , L257 , L258 , L262 , L259 , L263 , L167;
thus L267: F9(C97 , C99 , ( C101 * C100 )) = ( C106 * C105 ) by L266 , L252 , L253 , L167;
end;
L268:
now
let C107 being (object of F6());
let C108 being (object of F7());
assume L269: C108 = F8(C107);
L270: ( idm C107 ) = ( id ( latt C107 ) ) by L149;
thus L271: F9(C107 , C107 , ( idm C107 )) = ( id ( latt C108 ) ) by L270 , L242 , L269
.= ( idm C108 ) by L149;
end;
L272: (for B180 being (object of F6()) holds F8(B180) is (object of F7()))
proof
let C109 being (object of F6());
L273: C109 is LATTICE by L44;
thus L274: thesis by L273 , L240;
end;
consider C110 being  covariant  strict (Functor of F6() , F7()) such that L275: (for B181 being (object of F6()) holds ( C110 . B181 ) = F8(B181)) and L276: (for B182 , B183 being (object of F6()) holds (<^ B182 , B183 ^> <> ( {} ) implies (for B184 being (Morphism of B182 , B183) holds ( C110 . B184 ) = F9(B182 , B183 , B184)))) from YELLOW18:sch 8(L272 , L244 , L251 , L268);
take C110;
thus L277: (for B185 being (object of F6()) holds ( C110 . B185 ) = F8(( latt B185 ))) by L275;
let C111 , C112 being (object of F6());
assume that
L278: <^ C111 , C112 ^> <> ( {} );
let C113 being (Morphism of C111 , C112);
L279: C113 = ( @ C113 ) by L278 , L162;
thus L280: thesis by L279 , L276 , L278;
end;
scheme CLContravariantFunctorEx { P10 , P11[set , set , set] , F10 , F11() ->  lattice-wise category , F12(set) -> LATTICE , F13(set , set , set) -> Function } : (ex B186 being  contravariant  strict (Functor of F10() , F11()) st ((for B187 being (object of F10()) holds ( B186 . B187 ) = F12(( latt B187 ))) & (for B188 , B189 being (object of F10()) holds (<^ B188 , B189 ^> <> ( {} ) implies (for B190 being (Morphism of B188 , B189) holds ( B186 . B190 ) = F13(( latt B188 ) , ( latt B189 ) , ( @ B190 )))))))
provided
L281: (for B191 , B192 being LATTICE holds (for B193 being (Function of B191 , B192) holds (B193 in ( (the Arrows of F10()) . (B191 , B192) ) iff (B191 in (the carrier of F10()) & B192 in (the carrier of F10()) & P10[ B191 , B192 , B193 ]))))
and
L282: (for B194 , B195 being LATTICE holds (for B196 being (Function of B194 , B195) holds (B196 in ( (the Arrows of F11()) . (B194 , B195) ) iff (B194 in (the carrier of F11()) & B195 in (the carrier of F11()) & P11[ B194 , B195 , B196 ]))))
and
L283: (for B197 being LATTICE holds (B197 in (the carrier of F10()) implies F12(B197) in (the carrier of F11())))
and
L284: (for B198 , B199 being LATTICE holds (for B200 being (Function of B198 , B199) holds (P10[ B198 , B199 , B200 ] implies (F13(B198 , B199 , B200) is (Function of F12(B199) , F12(B198)) & P11[ F12(B199) , F12(B198) , F13(B198 , B199 , B200) ]))))
and
L285: (for B201 being LATTICE holds (B201 in (the carrier of F10()) implies F13(B201 , B201 , ( id B201 )) = ( id F12(B201) )))
and
L286: (for B202 , B203 , B204 being LATTICE holds (for B205 being (Function of B202 , B203) holds (for B206 being (Function of B203 , B204) holds ((P10[ B202 , B203 , B205 ] & P10[ B203 , B204 , B206 ]) implies F13(B202 , B204 , ( B206 * B205 )) = ( F13(B202 , B203 , B205) * F13(B203 , B204 , B206) )))))
proof
L287: (for B207 , B208 being (object of F10()) holds (<^ B207 , B208 ^> <> ( {} ) implies (for B209 being (Morphism of B207 , B208) holds F13(B207 , B208 , B209) in ( (the Arrows of F11()) . (F12(B208) , F12(B207)) ))))
proof
let C114 , C115 being (object of F10());
assume that
L288: <^ C114 , C115 ^> <> ( {} );
let C116 being (Morphism of C114 , C115);
L289: C116 = ( @ C116 ) by L288 , L162;
L290: P10[ C114 , C115 , C116 ] by L289 , L281 , L288;
L291: (F13(C114 , C115 , C116) is (Function of F12(C115) , F12(C114)) & P11[ F12(C115) , F12(C114) , F13(C114 , C115 , C116) ]) by L290 , L284 , L289;
L292: (F12(C114) in (the carrier of F11()) & F12(C115) in (the carrier of F11())) by L283 , L289;
thus L293: thesis by L292 , L282 , L291;
end;
L294:
now
let C117 , C118 , C119 being (object of F10());
assume that
L295: <^ C117 , C118 ^> <> ( {} )
and
L296: <^ C118 , C119 ^> <> ( {} );
let C120 being (Morphism of C117 , C118);
let C121 being (Morphism of C118 , C119);
let C122 , C123 , C124 being (object of F11());
assume that
L297: C122 = F12(C117)
and
L298: C123 = F12(C118)
and
L299: C124 = F12(C119);
let C125 being (Morphism of C123 , C122);
let C126 being (Morphism of C124 , C123);
assume that
L300: (C125 = F13(C117 , C118 , C120) & C126 = F13(C118 , C119 , C121));
L301: F13(C117 , C118 , C120) in ( (the Arrows of F11()) . (F12(C118) , F12(C117)) ) by L287 , L295;
L302: ( @ C125 ) = C125 by L301 , L297 , L298 , L162;
L303: ( @ C121 ) = C121 by L296 , L162;
L304: P10[ C118 , C119 , C121 ] by L303 , L281 , L296;
L305: F13(C118 , C119 , C121) in ( (the Arrows of F11()) . (F12(C119) , F12(C118)) ) by L287 , L296;
L306: ( @ C126 ) = C126 by L305 , L298 , L299 , L162;
L307: ( @ C120 ) = C120 by L295 , L162;
L308: P10[ C117 , C118 , C120 ] by L307 , L281 , L295;
L309: F13(C117 , C119 , ( ( @ C121 ) * ( @ C120 ) )) = ( F13(C117 , C118 , C120) * F13(C118 , C119 , C121) ) by L308 , L286 , L307 , L303 , L304
.= ( C125 * C126 ) by L297 , L298 , L299 , L300 , L301 , L305 , L302 , L306 , L167;
thus L310: F13(C117 , C119 , ( C121 * C120 )) = ( C125 * C126 ) by L309 , L295 , L296 , L167;
end;
L311:
now
let C127 being (object of F10());
let C128 being (object of F11());
assume L312: C128 = F12(C127);
L313: ( idm C127 ) = ( id ( latt C127 ) ) by L149;
thus L314: F13(C127 , C127 , ( idm C127 )) = ( id ( latt C128 ) ) by L313 , L285 , L312
.= ( idm C128 ) by L149;
end;
L315: (for B210 being (object of F10()) holds F12(B210) is (object of F11()))
proof
let C129 being (object of F10());
L316: C129 is LATTICE by L44;
thus L317: thesis by L316 , L283;
end;
consider C130 being  contravariant  strict (Functor of F10() , F11()) such that L318: (for B211 being (object of F10()) holds ( C130 . B211 ) = F12(B211)) and L319: (for B212 , B213 being (object of F10()) holds (<^ B212 , B213 ^> <> ( {} ) implies (for B214 being (Morphism of B212 , B213) holds ( C130 . B214 ) = F13(B212 , B213 , B214)))) from YELLOW18:sch 9(L315 , L287 , L294 , L311);
take C130;
thus L320: (for B215 being (object of F10()) holds ( C130 . B215 ) = F12(( latt B215 ))) by L318;
let C131 , C132 being (object of F10());
assume that
L321: <^ C131 , C132 ^> <> ( {} );
let C133 being (Morphism of C131 , C132);
L322: C133 = ( @ C133 ) by L321 , L162;
thus L323: thesis by L322 , L319 , L321;
end;
scheme CLCatIsomorphism { P12 , P13[set , set , set] , F14 , F15() ->  lattice-wise category , F16(set) -> LATTICE , F17(set , set , set) -> Function } : F14() , F15() are_isomorphic 
provided
L324: (for B216 , B217 being LATTICE holds (for B218 being (Function of B216 , B217) holds (B218 in ( (the Arrows of F14()) . (B216 , B217) ) iff (B216 in (the carrier of F14()) & B217 in (the carrier of F14()) & P12[ B216 , B217 , B218 ]))))
and
L325: (for B219 , B220 being LATTICE holds (for B221 being (Function of B219 , B220) holds (B221 in ( (the Arrows of F15()) . (B219 , B220) ) iff (B219 in (the carrier of F15()) & B220 in (the carrier of F15()) & P13[ B219 , B220 , B221 ]))))
and
L326: (ex B222 being  covariant (Functor of F14() , F15()) st ((for B223 being (object of F14()) holds ( B222 . B223 ) = F16(B223)) & (for B224 , B225 being (object of F14()) holds (<^ B224 , B225 ^> <> ( {} ) implies (for B226 being (Morphism of B224 , B225) holds ( B222 . B226 ) = F17(B224 , B225 , B226))))))
and
L327: (for B227 , B228 being LATTICE holds ((B227 in (the carrier of F14()) & B228 in (the carrier of F14())) implies (F16(B227) = F16(B228) implies B227 = B228)))
and
L328: (for B229 , B230 being LATTICE holds (for B231 , B232 being (Function of B229 , B230) holds ((P12[ B229 , B230 , B231 ] & P12[ B229 , B230 , B232 ]) implies (F17(B229 , B230 , B231) = F17(B229 , B230 , B232) implies B231 = B232))))
and
L329: (for B233 , B234 being LATTICE holds (for B235 being (Function of B233 , B234) holds (P13[ B233 , B234 , B235 ] implies (ex B236 , B237 being LATTICE st (ex B238 being (Function of B236 , B237) st (B236 in (the carrier of F14()) & B237 in (the carrier of F14()) & P12[ B236 , B237 , B238 ] & B233 = F16(B236) & B234 = F16(B237) & B235 = F17(B236 , B237 , B238)))))))
proof
L330: (for B239 , B240 being (object of F14()) holds (F16(B239) = F16(B240) implies B239 = B240))
proof
let C134 , C135 being (object of F14());
L331: (C134 = ( latt C134 ) & C135 = ( latt C135 ));
thus L332: thesis by L331 , L327;
end;
L333:
now
let C136 , C137 being (object of F15());
assume that
L334: <^ C136 , C137 ^> <> ( {} );
let C138 being (Morphism of C136 , C137);
L335: ( @ C138 ) = C138 by L334 , L162;
L336: P13[ ( latt C136 ) , ( latt C137 ) , ( @ C138 ) ] by L335 , L325 , L334;
consider C139 , C140 being LATTICE, C141 being (Function of C139 , C140) such that L337: (C139 in (the carrier of F14()) & C140 in (the carrier of F14())) and L338: P12[ C139 , C140 , C141 ] and L339: (( latt C136 ) = F16(C139) & ( latt C137 ) = F16(C140) & ( @ C138 ) = F17(C139 , C140 , C141)) by L336 , L329;
reconsider D36 = C139 , D37 = C140 as (object of F14()) by L337;
L340: C141 in <^ D36 , D37 ^> by L324 , L338;
thus L341: (ex B241 , B242 being (object of F14()) st (ex B243 being (Morphism of B241 , B242) st (C136 = F16(B241) & C137 = F16(B242) & <^ B241 , B242 ^> <> ( {} ) & C138 = F17(B241 , B242 , B243)))) by L340 , L335 , L339;
end;
L342: (for B244 , B245 being (object of F14()) holds (<^ B244 , B245 ^> <> ( {} ) implies (for B246 , B247 being (Morphism of B244 , B245) holds (F17(B244 , B245 , B246) = F17(B244 , B245 , B247) implies B246 = B247))))
proof
let C142 , C143 being (object of F14());
assume that
L343: <^ C142 , C143 ^> <> ( {} );
let C144 , C145 being (Morphism of C142 , C143);
L344: ( @ C145 ) = C145 by L343 , L162;
L345: P12[ ( latt C142 ) , ( latt C143 ) , ( @ C145 ) ] by L344 , L324 , L343;
L346: ( @ C144 ) = C144 by L343 , L162;
L347: P12[ ( latt C142 ) , ( latt C143 ) , ( @ C144 ) ] by L346 , L324 , L343;
thus L348: thesis by L347 , L328 , L346 , L344 , L345;
end;
L349: (ex B248 being  covariant (Functor of F14() , F15()) st ((for B249 being (object of F14()) holds ( B248 . B249 ) = F16(B249)) & (for B250 , B251 being (object of F14()) holds (<^ B250 , B251 ^> <> ( {} ) implies (for B252 being (Morphism of B250 , B251) holds ( B248 . B252 ) = F17(B250 , B251 , B252)))))) by L326;
thus L350: thesis from YELLOW18:sch 11(L349 , L330 , L342 , L333);
end;
scheme CLCatAntiIsomorphism { P14 , P15[set , set , set] , F18 , F19() ->  lattice-wise category , F20(set) -> LATTICE , F21(set , set , set) -> Function } : F18() , F19() are_anti-isomorphic 
provided
L351: (for B253 , B254 being LATTICE holds (for B255 being (Function of B253 , B254) holds (B255 in ( (the Arrows of F18()) . (B253 , B254) ) iff (B253 in (the carrier of F18()) & B254 in (the carrier of F18()) & P14[ B253 , B254 , B255 ]))))
and
L352: (for B256 , B257 being LATTICE holds (for B258 being (Function of B256 , B257) holds (B258 in ( (the Arrows of F19()) . (B256 , B257) ) iff (B256 in (the carrier of F19()) & B257 in (the carrier of F19()) & P15[ B256 , B257 , B258 ]))))
and
L353: (ex B259 being  contravariant (Functor of F18() , F19()) st ((for B260 being (object of F18()) holds ( B259 . B260 ) = F20(B260)) & (for B261 , B262 being (object of F18()) holds (<^ B261 , B262 ^> <> ( {} ) implies (for B263 being (Morphism of B261 , B262) holds ( B259 . B263 ) = F21(B261 , B262 , B263))))))
and
L354: (for B264 , B265 being LATTICE holds ((B264 in (the carrier of F18()) & B265 in (the carrier of F18())) implies (F20(B264) = F20(B265) implies B264 = B265)))
and
L355: (for B266 , B267 being LATTICE holds (for B268 , B269 being (Function of B266 , B267) holds (F21(B266 , B267 , B268) = F21(B266 , B267 , B269) implies B268 = B269)))
and
L356: (for B270 , B271 being LATTICE holds (for B272 being (Function of B270 , B271) holds (P15[ B270 , B271 , B272 ] implies (ex B273 , B274 being LATTICE st (ex B275 being (Function of B273 , B274) st (B273 in (the carrier of F18()) & B274 in (the carrier of F18()) & P14[ B273 , B274 , B275 ] & B271 = F20(B273) & B270 = F20(B274) & B272 = F21(B273 , B274 , B275)))))))
proof
L357: (for B276 , B277 being (object of F18()) holds (F20(B276) = F20(B277) implies B276 = B277))
proof
let C146 , C147 being (object of F18());
L358: (C146 = ( latt C146 ) & C147 = ( latt C147 ));
thus L359: thesis by L358 , L354;
end;
L360:
now
let C148 , C149 being (object of F19());
assume that
L361: <^ C148 , C149 ^> <> ( {} );
let C150 being (Morphism of C148 , C149);
L362: ( @ C150 ) = C150 by L361 , L162;
L363: P15[ ( latt C148 ) , ( latt C149 ) , ( @ C150 ) ] by L362 , L352 , L361;
consider C151 , C152 being LATTICE, C153 being (Function of C151 , C152) such that L364: (C151 in (the carrier of F18()) & C152 in (the carrier of F18())) and L365: P14[ C151 , C152 , C153 ] and L366: (( latt C149 ) = F20(C151) & ( latt C148 ) = F20(C152) & ( @ C150 ) = F21(C151 , C152 , C153)) by L363 , L356;
reconsider D38 = C151 , D39 = C152 as (object of F18()) by L364;
L367: C153 in <^ D38 , D39 ^> by L351 , L365;
thus L368: (ex B278 , B279 being (object of F18()) st (ex B280 being (Morphism of B278 , B279) st (C149 = F20(B278) & C148 = F20(B279) & <^ B278 , B279 ^> <> ( {} ) & C150 = F21(B278 , B279 , B280)))) by L367 , L362 , L366;
end;
L369: (for B281 , B282 being (object of F18()) holds (<^ B281 , B282 ^> <> ( {} ) implies (for B283 , B284 being (Morphism of B281 , B282) holds (F21(B281 , B282 , B283) = F21(B281 , B282 , B284) implies B283 = B284))))
proof
let C154 , C155 being (object of F18());
assume that
L370: <^ C154 , C155 ^> <> ( {} );
let C156 , C157 being (Morphism of C154 , C155);
L371: (( @ C156 ) = C156 & ( @ C157 ) = C157) by L370 , L162;
thus L372: thesis by L371 , L355;
end;
L373: (ex B285 being  contravariant (Functor of F18() , F19()) st ((for B286 being (object of F18()) holds ( B285 . B286 ) = F20(B286)) & (for B287 , B288 being (object of F18()) holds (<^ B287 , B288 ^> <> ( {} ) implies (for B289 being (Morphism of B287 , B288) holds ( B285 . B289 ) = F21(B287 , B288 , B289)))))) by L353;
thus L374: thesis from YELLOW18:sch 13(L373 , L357 , L369 , L360);
end;
begin
definition
let C158 being  lattice-wise category;
attr C158 is  with_all_isomorphisms
means
:L375: (for B290 , B291 being (object of C158) holds (for B292 being (Function of ( latt B290 ) , ( latt B291 )) holds (B292 is  isomorphic implies B292 in <^ B290 , B291 ^>)));
end;
registration
cluster  with_all_isomorphisms for  strict  lattice-wise  strict  lattice-wise  strict  lattice-wise  strict  lattice-wise category;
existence
proof
defpred S9[ set , set , set ] means $3 = $3;
set D40 = the LATTICE;
L377: (for B293 , B294 , B295 being LATTICE holds ((B293 in { D40 } & B294 in { D40 } & B295 in { D40 }) implies (for B296 being (Function of B293 , B294) holds (for B297 being (Function of B294 , B295) holds ((S9[ B293 , B294 , B296 ] & S9[ B294 , B295 , B297 ]) implies S9[ B293 , B295 , ( B297 * B296 ) ])))));
L378: (for B298 being LATTICE holds (B298 in { D40 } implies S9[ B298 , B298 , ( id B298 ) ]));
L379: (for B299 being (Element of { D40 }) holds B299 is LATTICE) by TARSKI:def 1;
consider C159 being  strict category such that L380: C159 is  lattice-wise and L381: ((the carrier of C159) = { D40 } & (for B300 , B301 being LATTICE holds (for B302 being  monotone (Function of B300 , B301) holds (B302 in ( (the Arrows of C159) . (B300 , B301) ) iff (B300 in { D40 } & B301 in { D40 } & S9[ B300 , B301 , B302 ]))))) from localCLCatEx(L379 , L377 , L378);
reconsider D41 = C159 as  strict  lattice-wise category by L380;
take D41;
let C160 , C161 being (object of D41);
let C162 being (Function of ( latt C160 ) , ( latt C161 ));
thus L382: thesis by L381;
end;
end;
theorem
L384: (for B303 being  with_all_isomorphisms  lattice-wise category holds (for B304 , B305 being (object of B303) holds (for B306 being (Morphism of B304 , B305) holds (( @ B306 ) is  isomorphic implies B306 is  iso))))
proof
let C163 being  with_all_isomorphisms  lattice-wise category;
let C164 , C165 being (object of C163);
let C166 being (Morphism of C164 , C165);
assume L385: ( @ C166 ) is  isomorphic;
consider C167 being  monotone (Function of ( latt C165 ) , ( latt C164 )) such that L386: ( ( @ C166 ) * C167 ) = ( id ( latt C165 ) ) and L387: ( C167 * ( @ C166 ) ) = ( id ( latt C164 ) ) by L385 , YELLOW16:15;
L388: ( @ C166 ) in <^ C164 , C165 ^> by L385 , L375;
L389: C167 is  isomorphic by L386 , L387 , YELLOW16:15;
L390: C167 in <^ C165 , C164 ^> by L389 , L375;
reconsider D42 = C167 as (Morphism of C165 , C164) by L389 , L375;
L391: ( @ D42 ) = D42 by L390 , L162;
L392: ( idm C165 ) = ( id ( latt C165 ) ) by L149;
L393: ( C166 * D42 ) = ( idm C165 ) by L392 , L386 , L388 , L390 , L391 , L167;
L394: D42 is_right_inverse_of C166 by L393 , ALTCAT_3:def 1;
L395: ( idm C164 ) = ( id ( latt C164 ) ) by L149;
L396: ( D42 * C166 ) = ( idm C164 ) by L395 , L387 , L388 , L390 , L391 , L167;
L397: D42 is_left_inverse_of C166 by L396 , ALTCAT_3:def 1;
L398: C166 is  retraction  coretraction by L397 , L394 , ALTCAT_3:def 2 , ALTCAT_3:def 3;
thus L399: (( C166 * ( C166 " ) ) = ( idm C165 ) & ( ( C166 " ) * C166 ) = ( idm C164 )) by L398 , L388 , L390 , L393 , L396 , L397 , L394 , ALTCAT_3:def 4;
end;
theorem
L400: (for B307 being  lattice-wise category holds (for B308 , B309 being (object of B307) holds ((<^ B308 , B309 ^> <> ( {} ) & <^ B309 , B308 ^> <> ( {} )) implies (for B310 being (Morphism of B308 , B309) holds (B310 is  iso implies ( @ B310 ) is  isomorphic)))))
proof
let C168 being  lattice-wise category;
let C169 , C170 being (object of C168);
assume L401: (<^ C169 , C170 ^> <> ( {} ) & <^ C170 , C169 ^> <> ( {} ));
let C171 being (Morphism of C169 , C170);
assume that
L402: (( C171 * ( C171 " ) ) = ( idm C170 ) & ( ( C171 " ) * C171 ) = ( idm C169 ));
L403: (( idm C169 ) = ( id ( latt C169 ) ) & ( idm C170 ) = ( id ( latt C170 ) )) by L149;
L404: (( ( @ C171 ) * ( @ ( C171 " ) ) ) = ( C171 * ( C171 " ) ) & ( ( @ ( C171 " ) ) * ( @ C171 ) ) = ( ( C171 " ) * C171 )) by L401 , L167;
thus L405: thesis by L404 , L402 , L403 , YELLOW16:15;
end;
scheme CLCatEquivalence { P16 , P17[set , set , set] , F22 , F23() ->  lattice-wise category , F24 , F25(set) -> LATTICE , F26 , F27(set , set , set) -> Function , F28 , F29(set) -> Function } : F22() , F23() are_equivalent 
provided
L406: (for B311 , B312 being (object of F22()) holds (for B313 being  monotone (Function of ( latt B311 ) , ( latt B312 )) holds (B313 in <^ B311 , B312 ^> iff P16[ ( latt B311 ) , ( latt B312 ) , B313 ])))
and
L407: (for B314 , B315 being (object of F23()) holds (for B316 being  monotone (Function of ( latt B314 ) , ( latt B315 )) holds (B316 in <^ B314 , B315 ^> iff P17[ ( latt B314 ) , ( latt B315 ) , B316 ])))
and
L408: (ex B317 being  covariant (Functor of F22() , F23()) st ((for B318 being (object of F22()) holds ( B317 . B318 ) = F24(B318)) & (for B319 , B320 being (object of F22()) holds (<^ B319 , B320 ^> <> ( {} ) implies (for B321 being (Morphism of B319 , B320) holds ( B317 . B321 ) = F26(B319 , B320 , B321))))))
and
L409: (ex B322 being  covariant (Functor of F23() , F22()) st ((for B323 being (object of F23()) holds ( B322 . B323 ) = F25(B323)) & (for B324 , B325 being (object of F23()) holds (<^ B324 , B325 ^> <> ( {} ) implies (for B326 being (Morphism of B324 , B325) holds ( B322 . B326 ) = F27(B324 , B325 , B326))))))
and
L410: (for B327 being LATTICE holds (B327 in (the carrier of F22()) implies (ex B328 being  monotone (Function of F25(F24(B327)) , B327) st (B328 = F28(B327) & B328 is  isomorphic & P16[ F25(F24(B327)) , B327 , B328 ] & P16[ B327 , F25(F24(B327)) , ( B328 " ) ]))))
and
L411: (for B329 being LATTICE holds (B329 in (the carrier of F23()) implies (ex B330 being  monotone (Function of B329 , F24(F25(B329))) st (B330 = F29(B329) & B330 is  isomorphic & P17[ B329 , F24(F25(B329)) , B330 ] & P17[ F24(F25(B329)) , B329 , ( B330 " ) ]))))
and
L412: (for B331 , B332 being (object of F22()) holds (<^ B331 , B332 ^> <> ( {} ) implies (for B333 being (Morphism of B331 , B332) holds ( F28(B332) * F27(F24(B331) , F24(B332) , F26(B331 , B332 , B333)) ) = ( ( @ B333 ) * F28(B331) ))))
and
L413: (for B334 , B335 being (object of F23()) holds (<^ B334 , B335 ^> <> ( {} ) implies (for B336 being (Morphism of B334 , B335) holds ( F26(F25(B334) , F25(B335) , F27(B334 , B335 , B336)) * F29(B334) ) = ( F29(B335) * ( @ B336 ) ))))
proof
L414: (ex B337 being  covariant (Functor of F23() , F22()) st ((for B338 being (object of F23()) holds ( B337 . B338 ) = F25(B338)) & (for B339 , B340 being (object of F23()) holds (<^ B339 , B340 ^> <> ( {} ) implies (for B341 being (Morphism of B339 , B340) holds ( B337 . B341 ) = F27(B339 , B340 , B341)))))) by L409;
L415: (for B342 , B343 being (object of F23()) holds (<^ B342 , B343 ^> <> ( {} ) implies (for B344 being (Morphism of B342 , B343) holds ( F26(F25(B342) , F25(B343) , F27(B342 , B343 , B344)) * F29(B342) ) = ( F29(B343) * B344 ))))
proof
let C172 , C173 being (object of F23());
assume that
L416: <^ C172 , C173 ^> <> ( {} );
let C174 being (Morphism of C172 , C173);
L417: ( @ C174 ) = C174 by L416 , L162;
thus L418: thesis by L417 , L413 , L416;
end;
L419: (for B345 , B346 being (object of F22()) holds (<^ B345 , B346 ^> <> ( {} ) implies (for B347 being (Morphism of B345 , B346) holds ( F28(B346) * F27(F24(B345) , F24(B346) , F26(B345 , B346 , B347)) ) = ( B347 * F28(B345) ))))
proof
let C175 , C176 being (object of F22());
assume that
L420: <^ C175 , C176 ^> <> ( {} );
let C177 being (Morphism of C175 , C176);
L421: ( @ C177 ) = C177 by L420 , L162;
thus L422: thesis by L421 , L412 , L420;
end;
L423: (for B348 , B349 being (object of F23()) holds (B349 = F24(F25(B348)) implies (F29(B348) in <^ B348 , B349 ^> & ( F29(B348) " ) in <^ B349 , B348 ^> & F29(B348) is  one-to-one)))
proof
let C178 , C179 being (object of F23());
assume that
L424: C179 = F24(F25(C178));
consider C180 being  monotone (Function of ( latt C178 ) , F24(F25(C178))) such that L425: C180 = F29(C178) and L426: C180 is  isomorphic and L427: P17[ ( latt C178 ) , F24(F25(C178)) , C180 ] and L428: P17[ F24(F25(C178)) , ( latt C178 ) , ( C180 " ) ] by L411;
L429: ( latt C179 ) = C179;
thus L430: F29(C178) in <^ C178 , C179 ^> by L429 , L407 , L424 , L425 , L427;
L431: (ex B350 being (Function of F24(F25(C178)) , ( latt C178 )) st (B350 = ( C180 " ) & B350 is  monotone)) by L426 , WAYBEL_0:def 38;
thus L432: ( F29(C178) " ) in <^ C179 , C178 ^> by L431 , L407 , L424 , L429 , L425 , L428;
thus L433: thesis by L425 , L426;
end;
L434: (for B351 , B352 being (object of F22()) holds (B351 = F25(F24(B352)) implies (F28(B352) in <^ B351 , B352 ^> & ( F28(B352) " ) in <^ B352 , B351 ^> & F28(B352) is  one-to-one)))
proof
let C181 , C182 being (object of F22());
assume that
L435: C181 = F25(F24(C182));
consider C183 being  monotone (Function of F25(F24(C182)) , ( latt C182 )) such that L436: C183 = F28(C182) and L437: C183 is  isomorphic and L438: P16[ F25(F24(C182)) , ( latt C182 ) , C183 ] and L439: P16[ ( latt C182 ) , F25(F24(C182)) , ( C183 " ) ] by L410;
L440: ( latt C181 ) = C181;
thus L441: F28(C182) in <^ C181 , C182 ^> by L440 , L406 , L435 , L436 , L438;
L442: (ex B353 being (Function of ( latt C182 ) , F25(F24(C182))) st (B353 = ( C183 " ) & B353 is  monotone)) by L437 , WAYBEL_0:def 38;
thus L443: ( F28(C182) " ) in <^ C182 , C181 ^> by L442 , L406 , L435 , L440 , L436 , L439;
thus L444: thesis by L436 , L437;
end;
L445: (ex B354 being  covariant (Functor of F22() , F23()) st ((for B355 being (object of F22()) holds ( B354 . B355 ) = F24(B355)) & (for B356 , B357 being (object of F22()) holds (<^ B356 , B357 ^> <> ( {} ) implies (for B358 being (Morphism of B356 , B357) holds ( B354 . B358 ) = F26(B356 , B357 , B358)))))) by L408;
thus L446: thesis from YELLOW18:sch 22(L445 , L414 , L434 , L423 , L419 , L415);
end;
begin
definition
let C184 being Relation;
attr C184 is  upper-bounded
means
:L447: (ex R1 being set st (for R2 being set holds (R2 in ( field C184 ) implies [ R2 , R1 ] in C184)));
end;
L449: (for R1 being set holds (for B359 being set holds (R1 in B359 iff B359 = ( ( B359 \ { R1 } ) \/ { R1 } ))))
proof
let R1 being set;
let C185 being set;
L450: (R1 in C185 iff { R1 } c= C185) by ZFMISC_1:31;
thus L451: thesis by L450 , XBOOLE_1:7 , XBOOLE_1:45;
end;
registration
cluster  well-ordering ->  reflexive  transitive  antisymmetric  connected  well_founded for Relation;
coherence;
end;
registration
cluster  well-ordering for Relation;
existence
proof
consider C186 being Relation such that L453: C186 well_orders 5 by WELLORD2:17;
take ( C186 |_2 5 );
thus L454: thesis by L453 , WELLORD2:16;
end;
end;
theorem
L456: (for R1 being set holds (for R2 being set holds (for B360 being  one-to-one Function holds (for B361 being Relation holds ([ R1 , R2 ] in ( ( B360 * B361 ) * ( B360 " ) ) iff (R1 in ( dom B360 ) & R2 in ( dom B360 ) & [ ( B360 . R1 ) , ( B360 . R2 ) ] in B361))))))
proof
let R1 being set;
let R2 being set;
let C187 being  one-to-one Function;
let C188 being Relation;
L457: ( rng C187 ) = ( dom ( C187 " ) ) by FUNCT_1:33;
L458: ( dom C187 ) = ( rng ( C187 " ) ) by FUNCT_1:33;
thus L459:now
assume L460: [ R1 , R2 ] in ( ( C187 * C188 ) * ( C187 " ) );
consider C189 being set such that L461: [ R1 , C189 ] in ( C187 * C188 ) and L462: [ C189 , R2 ] in ( C187 " ) by L460 , RELAT_1:def 8;
L463: (R2 = ( ( C187 " ) . C189 ) & C189 in ( rng C187 )) by L457 , L462 , FUNCT_1:1;
consider C190 being set such that L464: [ R1 , C190 ] in C187 and L465: [ C190 , C189 ] in C188 by L461 , RELAT_1:def 8;
thus L466: (R1 in ( dom C187 ) & R2 in ( dom C187 )) by L458 , L462 , L464 , XTUPLE_0:def 12 , XTUPLE_0:def 13;
L467: C190 = ( C187 . R1 ) by L464 , FUNCT_1:1;
thus L468: [ ( C187 . R1 ) , ( C187 . R2 ) ] in C188 by L467 , L465 , L463 , FUNCT_1:35;
end;
assume that
L469: R1 in ( dom C187 )
and
L470: R2 in ( dom C187 )
and
L471: [ ( C187 . R1 ) , ( C187 . R2 ) ] in C188;
L472: (( ( C187 " ) . ( C187 . R2 ) ) = R2 & ( C187 . R2 ) in ( rng C187 )) by L470 , FUNCT_1:34 , FUNCT_1:def 3;
L473: [ ( C187 . R2 ) , R2 ] in ( C187 " ) by L472 , L457 , FUNCT_1:1;
L474: [ R1 , ( C187 . R1 ) ] in C187 by L469 , FUNCT_1:1;
L475: [ R1 , ( C187 . R2 ) ] in ( C187 * C188 ) by L474 , L471 , RELAT_1:def 8;
thus L476: thesis by L475 , L473 , RELAT_1:def 8;
end;
registration
let C191 being  one-to-one Function;
let C192 being  reflexive Relation;
cluster ( ( C191 * C192 ) * ( C191 " ) ) ->  reflexive;
coherence
proof
let R1 being set;
L477: C192 is_reflexive_in ( field C192 ) by RELAT_2:def 9;
assume L478: R1 in ( field ( ( C191 * C192 ) * ( C191 " ) ) );
L479: R1 in ( ( dom ( ( C191 * C192 ) * ( C191 " ) ) ) \/ ( rng ( ( C191 * C192 ) * ( C191 " ) ) ) ) by L478 , RELAT_1:def 6;
per cases  by L479 , XBOOLE_0:def 3;
suppose L480: R1 in ( dom ( ( C191 * C192 ) * ( C191 " ) ) );

consider C193 being set such that L481: [ R1 , C193 ] in ( ( C191 * C192 ) * ( C191 " ) ) by L480 , XTUPLE_0:def 12;
L482: [ ( C191 . R1 ) , ( C191 . C193 ) ] in C192 by L481 , L456;
L483: ( C191 . R1 ) in ( field C192 ) by L482 , RELAT_1:15;
L484: [ ( C191 . R1 ) , ( C191 . R1 ) ] in C192 by L483 , L477 , RELAT_2:def 1;
L485: R1 in ( dom C191 ) by L481 , L456;
thus L486: thesis by L485 , L484 , L456;
end;
suppose L487: R1 in ( rng ( ( C191 * C192 ) * ( C191 " ) ) );

consider C194 being set such that L488: [ C194 , R1 ] in ( ( C191 * C192 ) * ( C191 " ) ) by L487 , XTUPLE_0:def 13;
L489: [ ( C191 . C194 ) , ( C191 . R1 ) ] in C192 by L488 , L456;
L490: ( C191 . R1 ) in ( field C192 ) by L489 , RELAT_1:15;
L491: [ ( C191 . R1 ) , ( C191 . R1 ) ] in C192 by L490 , L477 , RELAT_2:def 1;
L492: R1 in ( dom C191 ) by L488 , L456;
thus L493: thesis by L492 , L491 , L456;
end;
end;
end;
registration
let C195 being  one-to-one Function;
let C196 being  antisymmetric Relation;
cluster ( ( C195 * C196 ) * ( C195 " ) ) ->  antisymmetric;
coherence
proof
let C197 , C198 being set;
assume that
L496: C197 in ( field ( ( C195 * C196 ) * ( C195 " ) ) )
and
L497: C198 in ( field ( ( C195 * C196 ) * ( C195 " ) ) );
assume that
L498: [ C197 , C198 ] in ( ( C195 * C196 ) * ( C195 " ) )
and
L499: [ C198 , C197 ] in ( ( C195 * C196 ) * ( C195 " ) );
L500: (C197 in ( dom C195 ) & C198 in ( dom C195 )) by L498 , L456;
L501: C196 is_antisymmetric_in ( field C196 ) by RELAT_2:def 12;
L502: [ ( C195 . C198 ) , ( C195 . C197 ) ] in C196 by L499 , L456;
L503: [ ( C195 . C197 ) , ( C195 . C198 ) ] in C196 by L498 , L456;
L504: (( C195 . C197 ) in ( field C196 ) & ( C195 . C198 ) in ( field C196 )) by L503 , RELAT_1:15;
L505: ( C195 . C197 ) = ( C195 . C198 ) by L504 , L503 , L502 , L501 , RELAT_2:def 4;
thus L506: thesis by L505 , L500 , FUNCT_1:def 4;
end;
end;
registration
let C199 being  one-to-one Function;
let C200 being  transitive Relation;
cluster ( ( C199 * C200 ) * ( C199 " ) ) ->  transitive;
coherence
proof
let C201 , C202 , C203 being set;
assume that
L508: C201 in ( field ( ( C199 * C200 ) * ( C199 " ) ) )
and
L509: C202 in ( field ( ( C199 * C200 ) * ( C199 " ) ) )
and
L510: C203 in ( field ( ( C199 * C200 ) * ( C199 " ) ) );
assume that
L511: [ C201 , C202 ] in ( ( C199 * C200 ) * ( C199 " ) )
and
L512: [ C202 , C203 ] in ( ( C199 * C200 ) * ( C199 " ) );
L513: (C201 in ( dom C199 ) & C203 in ( dom C199 )) by L511 , L512 , L456;
L514: [ ( C199 . C202 ) , ( C199 . C203 ) ] in C200 by L512 , L456;
L515: ( C199 . C203 ) in ( field C200 ) by L514 , RELAT_1:15;
L516: C200 is_transitive_in ( field C200 ) by RELAT_2:def 16;
L517: [ ( C199 . C201 ) , ( C199 . C202 ) ] in C200 by L511 , L456;
L518: (( C199 . C201 ) in ( field C200 ) & ( C199 . C202 ) in ( field C200 )) by L517 , RELAT_1:15;
L519: [ ( C199 . C201 ) , ( C199 . C203 ) ] in C200 by L518 , L517 , L514 , L515 , L516 , RELAT_2:def 8;
thus L520: thesis by L519 , L513 , L456;
end;
end;
theorem
L522: (for B362 being set holds (for B363 being Ordinal holds (B362 , B363 are_equipotent  implies (ex B364 being (Order of B362) st (B364 well_orders B362 & ( order_type_of B364 ) = B363)))))
proof
let C204 being set;
let C205 being Ordinal;
given C206 being Function such that
L523: C206 is  one-to-one
and
L524: ( dom C206 ) = C204
and
L525: ( rng C206 ) = C205;

reconsider D43 = C206 as (Function of C204 , C205) by L524 , L525 , FUNCT_2:2;
reconsider D44 = ( D43 " ) as (Function of C205 , C204) by L523 , L525 , FUNCT_2:25;
L526: ( dom D44 ) = C205 by L523 , L525 , FUNCT_1:33;
reconsider D45 = D43 as  one-to-one Function by L523;
L527: ( dom ( RelIncl C205 ) ) = C205 by ORDERS_1:14;
L528: ( rng ( RelIncl C205 ) ) = C205 by ORDERS_1:14;
L529: ( rng ( D43 * ( RelIncl C205 ) ) ) = C205 by L528 , L525 , L527 , RELAT_1:28;
set D46 = ( ( D43 * ( RelIncl C205 ) ) * D44 );
L530: ( dom ( D43 * ( RelIncl C205 ) ) ) = C204 by L524 , L525 , L527 , RELAT_1:27;
L531: ( dom D46 ) = C204 by L530 , L526 , L529 , RELAT_1:27;
L532: ( rng D44 ) = C204 by L523 , L524 , FUNCT_1:33;
L533: ( rng D46 ) = C204 by L532 , L526 , L529 , RELAT_1:28;
L534: ( field D46 ) = ( C204 \/ C204 ) by L533 , L531 , RELAT_1:def 6
.= C204;
reconsider D47 = D46 as (Relation of C204);
L535: ( ( D45 * ( RelIncl C205 ) ) * ( D45 " ) ) is_reflexive_in C204 by L534 , RELAT_2:def 9;
reconsider D48 = D47 as (Order of C204) by L535 , L531 , PARTFUN1:def 2;
L536: D43 is_isomorphism_of D48 , ( RelIncl C205 )
proof
thus L537: (( dom D43 ) = ( field D48 ) & ( rng D43 ) = ( field ( RelIncl C205 ) ) & D43 is  one-to-one) by L523 , L524 , L525 , L534 , WELLORD2:def 1;
let C207 , C208 being set;
thus L538:now
assume L539: [ C207 , C208 ] in D48;
thus L540: (C207 in ( field D48 ) & C208 in ( field D48 )) by L539 , RELAT_1:15;
consider C209 being set such that L541: [ C207 , C209 ] in ( D43 * ( RelIncl C205 ) ) and L542: [ C209 , C208 ] in D44 by L539 , RELAT_1:def 8;
L543: (C208 = ( D44 . C209 ) & C209 in ( dom D44 )) by L542 , FUNCT_1:1;
consider C210 being set such that L544: [ C207 , C210 ] in D43 and L545: [ C210 , C209 ] in ( RelIncl C205 ) by L541 , RELAT_1:def 8;
L546: C210 = ( D43 . C207 ) by L544 , FUNCT_1:1;
thus L547: [ ( D43 . C207 ) , ( D43 . C208 ) ] in ( RelIncl C205 ) by L546 , L523 , L525 , L545 , L543 , FUNCT_1:35;
end;
assume that
L548: C207 in ( field D48 )
and
L549: C208 in ( field D48 )
and
L550: [ ( D43 . C207 ) , ( D43 . C208 ) ] in ( RelIncl C205 );
L551: [ C207 , ( D43 . C207 ) ] in D43 by L524 , L534 , L548 , FUNCT_1:1;
L552: [ C207 , ( D43 . C208 ) ] in ( D43 * ( RelIncl C205 ) ) by L551 , L550 , RELAT_1:def 8;
L553: (( ( D43 " ) . ( D43 . C208 ) ) = C208 & ( D43 . C208 ) in C205) by L523 , L524 , L525 , L534 , L549 , FUNCT_1:34 , FUNCT_1:def 3;
L554: [ ( D43 . C208 ) , C208 ] in D44 by L553 , L526 , FUNCT_1:1;
thus L555: thesis by L554 , L552 , RELAT_1:def 8;
end;
L556: ( D43 " ) is_isomorphism_of ( RelIncl C205 ) , D48 by L536 , WELLORD1:39;
L557: D48 is  connected  well_founded by L556 , WELLORD1:43;
L558: (D48 is_connected_in C204 & D48 is_well_founded_in C204) by L557 , L534 , RELAT_2:def 14 , WELLORD1:3;
take D48;
L559: D48 is_antisymmetric_in C204 by L534 , RELAT_2:def 12;
L560: (D48 is_reflexive_in C204 & D48 is_transitive_in C204) by L534 , RELAT_2:def 9 , RELAT_2:def 16;
thus L561: D48 well_orders C204 by L560 , L559 , L558 , WELLORD1:def 5;
L562: D48 is  well-ordering by L561 , L534 , WELLORD1:4;
L563: D48 , ( RelIncl C205 ) are_isomorphic  by L536 , WELLORD1:def 8;
thus L564: thesis by L563 , L562 , WELLORD2:def 2;
end;
registration
let C211 being non  empty set;
cluster  upper-bounded  well-ordering for (Order of C211);
existence
proof
set D49 = the (Element of C211);
L565: (( C211 \ { D49 } ) , ( card ( C211 \ { D49 } ) ) are_equipotent  & { D49 } , { ( card ( C211 \ { D49 } ) ) } are_equipotent ) by CARD_1:28 , CARD_1:def 2;
L566: ( succ ( card ( C211 \ { D49 } ) ) ) = ( ( card ( C211 \ { D49 } ) ) \/ { ( card ( C211 \ { D49 } ) ) } ) by ORDINAL1:def 1;
L567: (not ( card ( C211 \ { D49 } ) ) in ( card ( C211 \ { D49 } ) ));
L568: { ( card ( C211 \ { D49 } ) ) } misses ( card ( C211 \ { D49 } ) ) by L567 , ZFMISC_1:50;
L569: ({ D49 } misses ( C211 \ { D49 } ) & C211 = ( ( C211 \ { D49 } ) \/ { D49 } )) by L449 , XBOOLE_1:79;
consider C212 being (Order of C211) such that L570: C212 well_orders C211 and L571: ( order_type_of C212 ) = ( succ ( card ( C211 \ { D49 } ) ) ) by L569 , L565 , L568 , L566 , L522 , CARD_1:31;
take C212;
L572: ( field C212 ) = C211 by ORDERS_1:15;
L573: C212 is  well-ordering by L572 , L570 , WELLORD1:4;
L574: C212 , ( RelIncl ( order_type_of C212 ) ) are_isomorphic  by L573 , WELLORD2:def 2;
L575: ( RelIncl ( order_type_of C212 ) ) , C212 are_isomorphic  by L574 , WELLORD1:40;
consider C213 being Function such that L576: C213 is_isomorphism_of ( RelIncl ( order_type_of C212 ) ) , C212 by L575 , WELLORD1:def 8;
L577: C213 is  one-to-one by L576 , WELLORD1:def 7;
L578: ( rng C213 ) = C211 by L572 , L576 , WELLORD1:def 7;
L579: ( field ( RelIncl ( order_type_of C212 ) ) ) = ( order_type_of C212 ) by WELLORD2:def 1;
L580: ( dom C213 ) = ( order_type_of C212 ) by L579 , L576 , WELLORD1:def 7;
thus L581: C212 is  upper-bounded
proof
take D50 = ( C213 . ( card ( C211 \ { D49 } ) ) );
let R2 being set;
L582: ( card ( C211 \ { D49 } ) ) in ( order_type_of C212 ) by L566 , L571 , ZFMISC_1:136;
assume L583: R2 in ( field C212 );
L584: ( ( C213 " ) . R2 ) in ( order_type_of C212 ) by L583 , L572 , L577 , L580 , L578 , FUNCT_1:32;
reconsider D51 = ( ( C213 " ) . R2 ) as Ordinal by L584;
L585: (( ( C213 " ) . R2 ) in ( card ( C211 \ { D49 } ) ) or ( ( C213 " ) . R2 ) = ( card ( C211 \ { D49 } ) )) by L566 , L571 , L584 , ZFMISC_1:136;
L586: D51 c= ( card ( C211 \ { D49 } ) ) by L585 , ORDINAL1:def 2;
L587: [ D51 , ( card ( C211 \ { D49 } ) ) ] in ( RelIncl ( order_type_of C212 ) ) by L586 , L584 , L582 , WELLORD2:def 1;
L588: [ ( C213 . D51 ) , D50 ] in C212 by L587 , L576 , WELLORD1:def 7;
thus L589: thesis by L588 , L572 , L577 , L578 , L583 , FUNCT_1:35;
end;

thus L590: thesis by L570 , L572 , WELLORD1:4;
end;
end;
theorem
L592: (for B365 being  reflexive non  empty RelStr holds (B365 is  upper-bounded iff (the InternalRel of B365) is  upper-bounded))
proof
let C214 being  reflexive non  empty RelStr;
L593: ( (the carrier of C214) \/ (the carrier of C214) ) = (the carrier of C214);
L594: ( field (the InternalRel of C214) ) c= (the carrier of C214) by L593 , RELSET_1:8;
thus L595: (C214 is  upper-bounded implies (the InternalRel of C214) is  upper-bounded)
proof
given C215 being (Element of C214) such that
L596: C215 is_>=_than (the carrier of C214);

take C215;
let R2 being set;
assume L597: R2 in ( field (the InternalRel of C214) );
reconsider D52 = R2 as (Element of C214) by L597 , L594;
L598: C215 >= D52 by L596 , LATTICE3:def 9;
thus L599: thesis by L598 , ORDERS_2:def 5;
end;

set D53 = the (Element of C214);
given R1 being set such that
L600: (for R2 being set holds (R2 in ( field (the InternalRel of C214) ) implies [ R2 , R1 ] in (the InternalRel of C214)));

L601: D53 <= D53;
L602: [ D53 , D53 ] in (the InternalRel of C214) by L601 , ORDERS_2:def 5;
L603: D53 in ( field (the InternalRel of C214) ) by L602 , RELAT_1:15;
L604: [ D53 , R1 ] in (the InternalRel of C214) by L603 , L600;
L605: R1 in ( field (the InternalRel of C214) ) by L604 , RELAT_1:15;
reconsider D54 = R1 as (Element of C214) by L605 , L594;
take D54;
let C216 being (Element of C214);
L606: C216 <= C216;
L607: [ C216 , C216 ] in (the InternalRel of C214) by L606 , ORDERS_2:def 5;
L608: C216 in ( field (the InternalRel of C214) ) by L607 , RELAT_1:15;
L609: [ C216 , D54 ] in (the InternalRel of C214) by L608 , L600;
thus L610: thesis by L609 , ORDERS_2:def 5;
end;
theorem
L611: (for B366 being  upper-bounded non  empty Poset holds ((the InternalRel of B366) is  well-ordering implies B366 is  connected  complete  continuous))
proof
let C217 being  upper-bounded non  empty Poset;
assume that
L612: (the InternalRel of C217) is  well-ordering;
L613: ( field (the InternalRel of C217) ) = (the carrier of C217) by ORDERS_1:15;
thus L614: C217 is  connected
proof
let C218 , C219 being (Element of C217);
L615: (C218 = C219 or C218 <> C219);
L616: ((the InternalRel of C217) is_connected_in (the carrier of C217) & (the InternalRel of C217) is_reflexive_in (the carrier of C217)) by L612 , L613 , RELAT_2:def 9 , RELAT_2:def 14;
L617: ([ C218 , C219 ] in (the InternalRel of C217) or [ C219 , C218 ] in (the InternalRel of C217)) by L616 , L615 , RELAT_2:def 1 , RELAT_2:def 6;
thus L618: (C218 <= C219 or C219 <= C218) by L617 , ORDERS_2:def 5;
end;

thus L619: C217 is  complete
proof
set D55 = the (Element of C217);
let C220 being set;
defpred S10[ set ] means (for B367 being (Element of C217) holds (B367 in C220 implies [ B367 , $1 ] in (the InternalRel of C217)));
consider C221 being set such that L620: (for R1 being set holds (R1 in C221 iff (R1 in (the carrier of C217) & S10[ R1 ]))) from XBOOLE_0:sch 1;
L621: C221 c= (the carrier of C217)
proof
let R1 being set;
thus L622: thesis by L620;
end;
L623: (the InternalRel of C217) is  upper-bounded by L592;
consider R1 being set such that L624: (for R2 being set holds (R2 in ( field (the InternalRel of C217) ) implies [ R2 , R1 ] in (the InternalRel of C217))) by L623 , L447;
L625: [ D55 , R1 ] in (the InternalRel of C217) by L613 , L624;
reconsider D56 = R1 as (Element of C217) by L625 , L613 , RELAT_1:15;
L626: (for B368 being (Element of C217) holds (B368 in C220 implies [ B368 , D56 ] in (the InternalRel of C217))) by L613 , L624;
L627: D56 in C221 by L626 , L620;
consider C222 being set such that L628: C222 in C221 and L629: (for B369 being set holds (B369 in C221 implies [ C222 , B369 ] in (the InternalRel of C217))) by L627 , L612 , L613 , L621 , WELLORD1:6;
reconsider D57 = C222 as (Element of C217) by L621 , L628;
take D57;
thus L630:now
let C223 being (Element of C217);
assume L631: C223 in C220;
L632: [ C223 , D57 ] in (the InternalRel of C217) by L631 , L620 , L628;
thus L633: C223 <= D57 by L632 , ORDERS_2:def 5;
end;
let C224 being (Element of C217);
assume L634: (for B370 being (Element of C217) holds (B370 in C220 implies B370 <= C224));
L635:
now
let C225 being (Element of C217);
assume L636: C225 in C220;
L637: C225 <= C224 by L636 , L634;
thus L638: [ C225 , C224 ] in (the InternalRel of C217) by L637 , ORDERS_2:def 5;
end;
L639: C224 in C221 by L635 , L620;
L640: [ D57 , C224 ] in (the InternalRel of C217) by L639 , L629;
thus L641: D57 <= C224 by L640 , ORDERS_2:def 5;
end;

thus L642: thesis by L619 , L614;
end;
theorem
L643: (for B371 being  upper-bounded non  empty Poset holds ((the InternalRel of B371) is  well-ordering implies (for B372 , B373 being (Element of B371) holds (B373 < B372 implies (ex B374 being (Element of B371) st (B374 is  compact & B373 <= B374 & B374 <= B372))))))
proof
let C226 being  upper-bounded non  empty Poset;
set D58 = (the InternalRel of C226);
set D59 = ( order_type_of D58 );
L644: ( field ( RelIncl D59 ) ) = D59 by WELLORD2:def 1;
assume L645: D58 is  well-ordering;
reconsider D60 = C226 as  complete Chain by L645 , L611;
let C227 , C228 being (Element of C226);
L646: D58 , ( RelIncl D59 ) are_isomorphic  by L645 , WELLORD2:def 2;
consider C229 being Function such that L647: C229 is_isomorphism_of D58 , ( RelIncl D59 ) by L646 , WELLORD1:def 8;
assume L648: C228 < C227;
L649: C228 <= C227 by L648 , ORDERS_2:def 6;
L650: [ C228 , C227 ] in D58 by L649 , ORDERS_2:def 5;
L651: [ ( C229 . C228 ) , ( C229 . C227 ) ] in ( RelIncl D59 ) by L650 , L647 , L648 , WELLORD1:36;
L652: ( C229 . C227 ) in D59 by L651 , L644 , RELAT_1:15;
L653: ( C229 . C227 ) <> ( C229 . C228 ) by L647 , L648 , L650 , WELLORD1:36;
L654: ( C229 . C228 ) in D59 by L651 , L644 , RELAT_1:15;
reconsider D61 = ( C229 . C227 ) , D62 = ( C229 . C228 ) as Ordinal by L654 , L652;
L655: D62 c= D61 by L651 , L652 , L654 , WELLORD2:def 1;
L656: D62 c< D61 by L655 , L653 , XBOOLE_0:def 8;
L657: D62 in D61 by L656 , ORDINAL1:11;
L658: ( succ D62 ) c= D61 by L657 , ORDINAL1:21;
L659: ( succ D62 ) in D59 by L658 , L652 , ORDINAL1:12;
L660: [ ( succ D62 ) , ( C229 . C227 ) ] in ( RelIncl D59 ) by L659 , L652 , L658 , WELLORD2:def 1;
L661: D62 c= ( succ D62 ) by ORDINAL3:1;
L662: ( rng C229 ) = D59 by L647 , L644 , WELLORD1:def 7;
consider C230 being set such that L663: C230 in ( dom C229 ) and L664: ( succ D62 ) = ( C229 . C230 ) by L662 , L659 , FUNCT_1:def 3;
L665: ( field D58 ) = (the carrier of C226) by ORDERS_1:15;
reconsider D63 = C230 as (Element of C226) by L665 , L647 , L663 , WELLORD1:def 7;
take D63;
L666: ( dom C229 ) = ( field D58 ) by L647 , WELLORD1:def 7;
thus L667: D63 is  compact
proof
let C231 being non  empty  directed (Subset of C226);
assume that
L668: D63 <= ( sup C231 )
and
L669: (for B375 being (Element of C226) holds (B375 in C231 implies (not D63 <= B375)));
L670: D60 is  complete;
L671: C231 is_<=_than C228
proof
let C232 being (Element of C226);
L672: C229 is  one-to-one by L647 , WELLORD1:def 7;
assume L673: C232 in C231;
L674: (not D63 <= C232) by L673 , L669;
L675: D63 >= C232 by L674 , L670 , WAYBEL_0:def 29;
L676: [ C232 , D63 ] in D58 by L675 , ORDERS_2:def 5;
L677: [ ( C229 . C232 ) , ( succ D62 ) ] in ( RelIncl D59 ) by L676 , L647 , L664 , WELLORD1:def 7;
L678: ( C229 . C232 ) in D59 by L677 , L644 , RELAT_1:15;
reconsider D64 = ( C229 . C232 ) as Ordinal by L678;
L679: D64 c= ( succ D62 ) by L659 , L677 , L678 , WELLORD2:def 1;
L680: C232 <> D63 by L669 , L673;
L681: D64 <> ( succ D62 ) by L680 , L664 , L665 , L666 , L672 , FUNCT_1:def 4;
L682: D64 c< ( succ D62 ) by L681 , L679 , XBOOLE_0:def 8;
L683: D64 in ( succ D62 ) by L682 , ORDINAL1:11;
L684: D64 c= D62 by L683 , ORDINAL1:22;
L685: [ D64 , D62 ] in ( RelIncl D59 ) by L684 , L654 , L678 , WELLORD2:def 1;
thus L686: [ C232 , C228 ] in D58 by L685 , L647 , L665 , WELLORD1:def 7;
end;
L687: ( sup C231 ) <= C228 by L671 , L670 , YELLOW_0:32;
L688: D63 <= C228 by L687 , L668 , YELLOW_0:def 2;
L689: [ D63 , C228 ] in D58 by L688 , ORDERS_2:def 5;
L690: [ ( succ D62 ) , D62 ] in ( RelIncl D59 ) by L689 , L647 , L664 , WELLORD1:def 7;
L691: ( succ D62 ) c= D62 by L690 , L654 , L659 , WELLORD2:def 1;
L692: D62 = ( succ D62 ) by L691 , L661 , XBOOLE_0:def 10;
thus L693: contradiction by L692 , ORDINAL1:9;
end;

L694: [ ( C229 . C228 ) , ( succ D62 ) ] in ( RelIncl D59 ) by L654 , L661 , L659 , WELLORD2:def 1;
thus L695: ([ C228 , D63 ] in D58 & [ D63 , C227 ] in D58) by L694 , L647 , L664 , L665 , L660 , WELLORD1:def 7;
end;
theorem
L696: (for B376 being  upper-bounded non  empty Poset holds ((the InternalRel of B376) is  well-ordering implies B376 is  algebraic))
proof
let C233 being  upper-bounded non  empty Poset;
assume L697: (the InternalRel of C233) is  well-ordering;
reconsider D65 = C233 as  connected  complete  continuous non  empty Poset by L697 , L611;
L698:
now
let C234 , C235 being (Element of D65);
assume L699: C234 << C235;
L700: ((C234 is  compact & C234 <= C234 & C234 <= C235) or C234 < C235) by L699 , WAYBEL_3:1 , WAYBEL_3:14;
consider C236 being (Element of D65) such that L701: C236 is  compact and L702: (C234 <= C236 & C236 <= C235) by L700 , L697 , L643;
take D66 = C236;
thus L703: D66 in (the carrier of ( CompactSublatt D65 )) by L701 , WAYBEL_8:def 1;
thus L704: (C234 <= D66 & D66 <= C235) by L702;
end;
thus L705: thesis by L698 , WAYBEL_8:7;
end;
registration
let C237 being non  empty set;
let C238 being  upper-bounded  well-ordering (Order of C237);
cluster RelStr (# C237 , C238 #) ->  complete  connected  continuous  algebraic;
coherence
proof
L706: RelStr (# C237 , C238 #) is  upper-bounded by L592;
thus L707: thesis by L706 , L611 , L696;
end;
end;
definition
defpred S11[ LATTICE , LATTICE , (Function of $1 , $2) ] means $3 is  directed-sups-preserving;
defpred S12[ LATTICE ] means $1 is  complete;
let C239 being non  empty set;
given C240 being (Element of C239) such that
L709: C240 is non  empty;

func C239 -UPS_category ->  lattice-wise  strict category means 
:L710: ((for B377 being LATTICE holds (B377 is (object of it) iff (B377 is  strict  complete & (the carrier of B377) in C239))) & (for B378 , B379 being (object of it) holds (for B380 being  monotone (Function of ( latt B378 ) , ( latt B379 )) holds (B380 in <^ B378 , B379 ^> iff B380 is  directed-sups-preserving))));
existence
proof
reconsider D67 = C240 as non  empty set by L709;
set D68 = the  upper-bounded  well-ordering (Order of D67);
L711: (for B381 being LATTICE holds (S12[ B381 ] implies S11[ B381 , B381 , ( id B381 ) ]));
L712: RelStr (# D67 , D68 #) is  complete;
L713: (ex B382 being  strict LATTICE st (S12[ B382 ] & (the carrier of B382) in C239)) by L712;
L714: (for B383 , B384 , B385 being LATTICE holds ((S12[ B383 ] & S12[ B384 ] & S12[ B385 ]) implies (for B386 being (Function of B383 , B384) holds (for B387 being (Function of B384 , B385) holds ((S11[ B383 , B384 , B386 ] & S11[ B384 , B385 , B387 ]) implies S11[ B383 , B385 , ( B387 * B386 ) ]))))) by WAYBEL20:28;
thus L715: (ex B388 being  lattice-wise  strict category st ((for B389 being LATTICE holds (B389 is (object of B388) iff (B389 is  strict & S12[ B389 ] & (the carrier of B389) in C239))) & (for B390 , B391 being (object of B388) holds (for B392 being  monotone (Function of ( latt B390 ) , ( latt B391 )) holds (B392 in <^ B390 , B391 ^> iff S11[ ( latt B390 ) , ( latt B391 ) , B392 ]))))) from CLCatEx2(L713 , L714 , L711);
end;
correctness
proof
reconsider D69 = C240 as non  empty set by L709;
let C241 , C242 being  lattice-wise  strict category;
assume that
L716: (for B393 being LATTICE holds (B393 is (object of C241) iff (B393 is  strict & S12[ B393 ] & (the carrier of B393) in C239)))
and
L717: (for B394 , B395 being (object of C241) holds (for B396 being  monotone (Function of ( latt B394 ) , ( latt B395 )) holds (B396 in <^ B394 , B395 ^> iff B396 is  directed-sups-preserving)))
and
L718: (for B397 being LATTICE holds (B397 is (object of C242) iff (B397 is  strict & S12[ B397 ] & (the carrier of B397) in C239)))
and
L719: (for B398 , B399 being (object of C242) holds (for B400 being  monotone (Function of ( latt B398 ) , ( latt B399 )) holds (B400 in <^ B398 , B399 ^> iff B400 is  directed-sups-preserving)));
defpred S13[ set , set , set ] means (ex B401 , B402 being LATTICE st (ex B403 being (Function of B401 , B402) st ($1 = B401 & $2 = B402 & $3 = B403 & B403 is  directed-sups-preserving)));
L720:
now
let C243 , C244 being (object of C241);
let C245 being  monotone (Function of ( latt C243 ) , ( latt C244 ));
L721: (C245 in <^ C243 , C244 ^> iff C245 is  directed-sups-preserving) by L717;
thus L722: (C245 in <^ C243 , C244 ^> iff S13[ C243 , C244 , C245 ]) by L721;
end;
L723:
now
let C246 , C247 being (object of C242);
let C248 being  monotone (Function of ( latt C246 ) , ( latt C247 ));
L724: (C248 in <^ C246 , C247 ^> iff C248 is  directed-sups-preserving) by L719;
thus L725: (C248 in <^ C246 , C247 ^> iff S13[ C246 , C247 , C248 ]) by L724;
end;
L726: (for B404 , B405 being  lattice-wise category holds (((for B406 being LATTICE holds (B406 is (object of B404) iff (B406 is  strict & S12[ B406 ] & (the carrier of B406) in C239))) & (for B407 , B408 being (object of B404) holds (for B409 being  monotone (Function of ( latt B407 ) , ( latt B408 )) holds (B409 in <^ B407 , B408 ^> iff S13[ B407 , B408 , B409 ]))) & (for B410 being LATTICE holds (B410 is (object of B405) iff (B410 is  strict & S12[ B410 ] & (the carrier of B410) in C239))) & (for B411 , B412 being (object of B405) holds (for B413 being  monotone (Function of ( latt B411 ) , ( latt B412 )) holds (B413 in <^ B411 , B412 ^> iff S13[ B411 , B412 , B413 ])))) implies ( the AltCatStr of B404 ) = ( the AltCatStr of B405 ))) from CLCatUniq2;
thus L727: thesis by L726 , L716 , L718 , L720 , L723;
end;
end;
registration
let C249 being  with_non-empty_element set;
cluster ( C249 -UPS_category ) ->  with_complete_lattices  with_all_isomorphisms;
coherence
proof
set D70 = ( C249 -UPS_category );
thus L729: D70 is  lattice-wise;
L730: (ex B414 being non  empty set st B414 in C249) by SETFAM_1:def 10;
thus L731:now
let C250 being (object of D70);
L732: C250 = ( latt C250 );
thus L733: C250 is  complete  complete  complete  complete LATTICE by L732 , L730 , L710;
end;
let C251 , C252 being (object of D70);
let C253 being (Function of ( latt C251 ) , ( latt C252 ));
reconsider D71 = ( latt C251 ) , D72 = ( latt C252 ) as  complete LATTICE by L730 , L710;
assume L734: C253 is  isomorphic;
L735: C253 is  sups-preserving  sups-preserving  sups-preserving  sups-preserving (Function of D71 , D72) by L734 , WAYBEL13:20;
thus L736: thesis by L735 , L730 , L710;
end;
end;
theorem
L738: (for B415 being  with_non-empty_element set holds (the carrier of ( B415 -UPS_category )) c= ( POSETS B415 ))
proof
let C254 being  with_non-empty_element set;
let R1 being set;
assume L739: R1 in (the carrier of ( C254 -UPS_category ));
reconsider D73 = R1 as (object of ( C254 -UPS_category )) by L739;
L740: (ex B416 being non  empty set st B416 in C254) by SETFAM_1:def 10;
L741: (the carrier of ( latt D73 )) in C254 by L740 , L710;
L742: ( latt D73 ) = D73;
L743: D73 is  strict  strict  strict  strict Poset by L742 , L740 , L710;
thus L744: thesis by L743 , L741 , L3;
end;
theorem
L745: (for B417 being  with_non-empty_element set holds (for R1 being set holds (R1 is (object of ( B417 -UPS_category )) iff (R1 is  complete  complete  complete  complete LATTICE & R1 in ( POSETS B417 )))))
proof
let C255 being  with_non-empty_element set;
let R1 being set;
thus L746:now
assume L747: R1 is (object of ( C255 -UPS_category ));
reconsider D74 = R1 as (object of ( C255 -UPS_category )) by L747;
L748: ( latt D74 ) = R1;
thus L749: R1 is  complete  complete  complete  complete LATTICE by L748;
L750: (D74 in (the carrier of ( C255 -UPS_category )) & (the carrier of ( C255 -UPS_category )) c= ( POSETS C255 )) by L738;
thus L751: R1 in ( POSETS C255 ) by L750;
end;
assume L752: R1 is  complete  complete  complete  complete LATTICE;
reconsider D75 = R1 as  complete LATTICE by L752;
assume L753: R1 in ( POSETS C255 );
L754: ((the carrier of ( D75 as_1-sorted )) in C255 & D75 is  strict) by L753 , L3;
L755: ( D75 as_1-sorted ) = D75 by L1;
thus L756: thesis by L755 , L754 , L710;
end;
theorem
L757: (for B418 being  with_non-empty_element set holds (for B419 being LATTICE holds ((the carrier of B419) in B418 implies (B419 is (object of ( B418 -UPS_category )) iff B419 is  strict  complete))))
proof
let C256 being  with_non-empty_element set;
let C257 being LATTICE;
assume L758: (the carrier of C257) in C256;
L759: ( C257 as_1-sorted ) = C257 by L1;
L760: (C257 in ( POSETS C256 ) iff C257 is  strict) by L759 , L758 , L3;
thus L761: thesis by L760 , L745;
end;
theorem
L762: (for B420 being  with_non-empty_element set holds (for B421 , B422 being (object of ( B420 -UPS_category )) holds (for B423 being set holds (B423 in <^ B421 , B422 ^> iff B423 is  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving (Function of ( latt B421 ) , ( latt B422 ))))))
proof
let C258 being  with_non-empty_element set;
let C259 , C260 being (object of ( C258 -UPS_category ));
let C261 being set;
L763: (ex B424 being non  empty set st B424 in C258) by SETFAM_1:def 10;
thus L764:now
assume L765: C261 in <^ C259 , C260 ^>;
reconsider D76 = C261 as (Morphism of C259 , C260) by L765;
L766: C261 = ( @ D76 ) by L765 , L162;
thus L767: C261 is  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving (Function of ( latt C259 ) , ( latt C260 )) by L766 , L763 , L765 , L710;
end;
thus L768: thesis by L763 , L710;
end;
registration
let C262 being  with_non-empty_element set;
let C263 , C264 being (object of ( C262 -UPS_category ));
cluster <^ C263 , C264 ^> -> non  empty;
coherence
proof
set D77 = the  directed-sups-preserving (Function of ( latt C263 ) , ( latt C264 ));
L769: D77 in <^ C263 , C264 ^> by L762;
thus L770: thesis by L769;
end;
end;
begin
registration
let C265 being  set-id-inheriting category;
cluster  ->  set-id-inheriting for non  empty non  empty non  empty non  empty (subcategory of C265);
coherence
proof
let C266 being non  empty (subcategory of C265);
let C267 being (object of C266);
L772: (C267 in (the carrier of C266) & (the carrier of C266) c= (the carrier of C265)) by ALTCAT_2:def 11;
reconsider D78 = C267 as (object of C265) by L772;
thus L773: ( idm C267 ) = ( idm D78 ) by ALTCAT_2:34
.= ( id ( the_carrier_of D78 ) ) by YELLOW18:def 10
.= ( id ( the_carrier_of C267 ) ) by ALTCAT_2:34;
end;
end;
registration
let C268 being  para-functional category;
cluster  ->  para-functional for non  empty non  empty non  empty non  empty (subcategory of C268);
coherence
proof
let C269 being non  empty (subcategory of C268);
consider C270 being (ManySortedSet of C268) such that L775: (for B425 , B426 being (object of C268) holds <^ B425 , B426 ^> c= ( Funcs (( C270 . B425 ) , ( C270 . B426 )) )) by YELLOW18:def 7;
set D79 = ( C270 | (the carrier of C269) );
L776: (the carrier of C269) c= (the carrier of C268) by ALTCAT_2:def 11;
L777: ( dom C270 ) = (the carrier of C268) by PARTFUN1:def 2;
L778: ( dom D79 ) = (the carrier of C269) by L777 , L776 , RELAT_1:62;
reconsider D80 = D79 as (ManySortedSet of C269) by L778 , PARTFUN1:def 2 , RELAT_1:def 18;
take D80;
let C271 , C272 being (object of C269);
L779: (C271 in (the carrier of C269) & C272 in (the carrier of C269));
reconsider D81 = C271 , D82 = C272 as (object of C268) by L779 , L776;
L780: (( C270 . C271 ) = ( D80 . C271 ) & ( C270 . C272 ) = ( D80 . C272 )) by FUNCT_1:49;
L781: (<^ C271 , C272 ^> c= <^ D81 , D82 ^> & <^ D81 , D82 ^> c= ( Funcs (( D80 . C271 ) , ( D80 . C272 )) )) by L780 , L775 , ALTCAT_2:31;
thus L782: thesis by L781 , XBOOLE_1:1;
end;
end;
registration
let C273 being  semi-functional category;
cluster  ->  semi-functional for non  empty  transitive non  empty  transitive non  empty  transitive non  empty  transitive (SubCatStr of C273);
coherence
proof
let C274 being non  empty  transitive (SubCatStr of C273);
let C275 , C276 , C277 being (object of C274);
assume that
L784: <^ C275 , C276 ^> <> ( {} )
and
L785: <^ C276 , C277 ^> <> ( {} )
and
L786: <^ C275 , C277 ^> <> ( {} );
reconsider D83 = C275 , D84 = C276 , D85 = C277 as (object of C273) by ALTCAT_2:29;
L787: (<^ D83 , D84 ^> <> ( {} ) & <^ D84 , D85 ^> <> ( {} )) by L784 , L785 , ALTCAT_2:31 , XBOOLE_1:3;
let C278 being (Morphism of C275 , C276);
let C279 being (Morphism of C276 , C277);
reconsider D86 = C279 as (Morphism of D84 , D85) by L785 , ALTCAT_2:33;
reconsider D87 = C278 as (Morphism of D83 , D84) by L784 , ALTCAT_2:33;
L788: <^ D83 , D85 ^> <> ( {} ) by L786 , ALTCAT_2:31 , XBOOLE_1:3;
let C280 , C281 being Function;
assume L789: (C278 = C280 & C279 = C281);
L790: ( D86 * D87 ) = ( C281 * C280 ) by L789 , L787 , L788 , ALTCAT_1:def 12;
thus L791: thesis by L790 , L784 , L785 , ALTCAT_2:32;
end;
end;
registration
let C282 being  carrier-underlaid category;
cluster  ->  carrier-underlaid for non  empty non  empty non  empty non  empty (subcategory of C282);
coherence
proof
let C283 being non  empty (subcategory of C282);
let C284 being (object of C283);
reconsider D88 = C284 as (object of C282) by ALTCAT_2:29;
consider C285 being 1-sorted such that L793: D88 = C285 and L794: ( the_carrier_of D88 ) = (the carrier of C285) by L42;
take C285;
thus L795: C284 = C285 by L793;
thus L796: thesis by L794 , ALTCAT_2:34;
end;
end;
registration
let C286 being  lattice-wise category;
cluster  ->  lattice-wise for non  empty non  empty non  empty non  empty (subcategory of C286);
coherence
proof
let C287 being non  empty (subcategory of C286);
thus L798: C287 is  semi-functional  set-id-inheriting;
thus L799:now
let C288 being (object of C287);
reconsider D89 = C288 as (object of C286) by ALTCAT_2:29;
L800: D89 is LATTICE by L44;
thus L801: C288 is LATTICE by L800;
end;
let C289 , C290 being (object of C287);
reconsider D90 = C289 , D91 = C290 as (object of C286) by ALTCAT_2:29;
let C291 , C292 being LATTICE;
assume L802: (C291 = C289 & C292 = C290);
L803: (<^ C289 , C290 ^> c= <^ D90 , D91 ^> & <^ D90 , D91 ^> c= ( MonFuncs (C291 , C292) )) by L802 , L44 , ALTCAT_2:31;
thus L804: thesis by L803 , XBOOLE_1:1;
end;
end;
registration
let C293 being  with_all_isomorphisms  lattice-wise category;
cluster  full ->  with_all_isomorphisms for non  empty non  empty non  empty non  empty (subcategory of C293);
coherence
proof
let C294 being non  empty (subcategory of C293);
assume that
L806: C294 is  full;
let C295 , C296 being (object of C294);
let C297 being (Function of ( latt C295 ) , ( latt C296 ));
reconsider D92 = C295 , D93 = C296 as (object of C293) by ALTCAT_2:29;
assume L807: C297 is  isomorphic;
L808: C297 in <^ D92 , D93 ^> by L807 , L375;
thus L809: thesis by L808 , L806 , ALTCAT_2:28;
end;
end;
registration
let C298 being  with_complete_lattices category;
cluster  ->  with_complete_lattices for non  empty non  empty non  empty non  empty (subcategory of C298);
coherence
proof
let C299 being non  empty (subcategory of C298);
thus L811: C299 is  lattice-wise;
let C300 being (object of C299);
reconsider D94 = C300 as (object of C298) by ALTCAT_2:29;
L812: D94 is  complete  complete  complete  complete LATTICE by L46;
thus L813: thesis by L812;
end;
end;
definition
let C301 being  with_non-empty_element set;
defpred S14[ (object of ( C301 -UPS_category )) ] means ( latt $1 ) is  continuous;
consider C302 being non  empty set such that L815: C302 in C301 by SETFAM_1:def 10;
set D95 = the  upper-bounded  well-ordering (Order of C302);
set D96 = RelStr (# C302 , D95 #);
func C301 -CONT_category ->  strict  full non  empty (subcategory of ( C301 -UPS_category )) means 
:L816: (for B427 being (object of ( C301 -UPS_category )) holds (B427 is (object of it) iff ( latt B427 ) is  continuous));
existence
proof
reconsider D97 = D96 as (object of ( C301 -UPS_category )) by L815 , L710;
L817: D97 = ( latt D97 );
L818: (ex B428 being (object of ( C301 -UPS_category )) st S14[ B428 ]) by L817;
thus L819: (ex B429 being  strict  full non  empty (subcategory of ( C301 -UPS_category )) st (for B430 being (object of ( C301 -UPS_category )) holds (B430 is (object of B429) iff S14[ B430 ]))) from YELLOW20:sch 2(L818);
end;
correctness
proof
let C303 , C304 being  strict  full non  empty (subcategory of ( C301 -UPS_category ));
assume that
L820: (for B431 being (object of ( C301 -UPS_category )) holds (B431 is (object of C303) iff S14[ B431 ]))
and
L821: (for B432 being (object of ( C301 -UPS_category )) holds (B432 is (object of C304) iff S14[ B432 ]));
L822: ( the AltCatStr of C303 ) = ( the AltCatStr of C304 ) from YELLOW20:sch 3(L820 , L821);
thus L823: thesis by L822;
end;
end;
definition
let C305 being  with_non-empty_element set;
defpred S15[ (object of ( C305 -CONT_category )) ] means ( latt $1 ) is  algebraic;
consider C306 being non  empty set such that L825: C306 in C305 by SETFAM_1:def 10;
set D98 = the  upper-bounded  well-ordering (Order of C306);
set D99 = RelStr (# C306 , D98 #);
func C305 -ALG_category ->  strict  full non  empty (subcategory of ( C305 -CONT_category )) means 
:L826: (for B433 being (object of ( C305 -CONT_category )) holds (B433 is (object of it) iff ( latt B433 ) is  algebraic));
existence
proof
reconsider D100 = D99 as (object of ( C305 -UPS_category )) by L825 , L710;
L827: D100 = ( latt D100 );
reconsider D101 = D100 as (object of ( C305 -CONT_category )) by L827 , L816;
L828: D101 = ( latt D101 );
L829: (ex B434 being (object of ( C305 -CONT_category )) st S15[ B434 ]) by L828;
thus L830: (ex B435 being  strict  full non  empty (subcategory of ( C305 -CONT_category )) st (for B436 being (object of ( C305 -CONT_category )) holds (B436 is (object of B435) iff S15[ B436 ]))) from YELLOW20:sch 2(L829);
end;
correctness
proof
let C307 , C308 being  strict  full non  empty (subcategory of ( C305 -CONT_category ));
assume that
L831: (for B437 being (object of ( C305 -CONT_category )) holds (B437 is (object of C307) iff S15[ B437 ]))
and
L832: (for B438 being (object of ( C305 -CONT_category )) holds (B438 is (object of C308) iff S15[ B438 ]));
L833: ( the AltCatStr of C307 ) = ( the AltCatStr of C308 ) from YELLOW20:sch 3(L831 , L832);
thus L834: thesis by L833;
end;
end;
theorem
L836: (for B439 being  with_non-empty_element set holds (for B440 being LATTICE holds ((the carrier of B440) in B439 implies (B440 is (object of ( B439 -CONT_category )) iff B440 is  strict  complete  continuous))))
proof
let C309 being  with_non-empty_element set;
let C310 being LATTICE;
assume that
L837: (the carrier of C310) in C309;
thus L838:now
assume L839: C310 is (object of ( C309 -CONT_category ));
reconsider D102 = C310 as (object of ( C309 -CONT_category )) by L839;
L840: (C310 = ( latt D102 ) & D102 is (object of ( C309 -UPS_category ))) by ALTCAT_2:29;
thus L841: C310 is  strict  complete  continuous by L840 , L837 , L816 , L757;
end;
assume L842: C310 is  strict  complete  continuous;
reconsider D103 = C310 as (object of ( C309 -UPS_category )) by L842 , L837 , L757;
L843: ( latt D103 ) = C310;
thus L844: thesis by L843 , L842 , L816;
end;
theorem
L845: (for B441 being  with_non-empty_element set holds (for B442 being LATTICE holds ((the carrier of B442) in B441 implies (B442 is (object of ( B441 -ALG_category )) iff B442 is  strict  complete  algebraic))))
proof
let C311 being  with_non-empty_element set;
let C312 being LATTICE;
assume that
L846: (the carrier of C312) in C311;
thus L847:now
assume L848: C312 is (object of ( C311 -ALG_category ));
reconsider D104 = C312 as (object of ( C311 -ALG_category )) by L848;
L849: (C312 = ( latt D104 ) & D104 is (object of ( C311 -CONT_category ))) by ALTCAT_2:29;
thus L850: C312 is  strict  complete  algebraic by L849 , L846 , L826 , L836;
end;
assume L851: C312 is  strict  complete  algebraic;
reconsider D105 = C312 as (object of ( C311 -CONT_category )) by L851 , L846 , L836;
L852: ( latt D105 ) = C312;
thus L853: thesis by L852 , L851 , L826;
end;
theorem
L854: (for B443 being  with_non-empty_element set holds (for B444 , B445 being (object of ( B443 -CONT_category )) holds (for B446 being set holds (B446 in <^ B444 , B445 ^> iff B446 is  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving (Function of ( latt B444 ) , ( latt B445 ))))))
proof
let C313 being  with_non-empty_element set;
let C314 , C315 being (object of ( C313 -CONT_category ));
let C316 being set;
reconsider D106 = C314 , D107 = C315 as (object of ( C313 -UPS_category )) by ALTCAT_2:29;
L855: <^ C314 , C315 ^> = <^ D106 , D107 ^> by ALTCAT_2:28;
thus L856: thesis by L855 , L762;
end;
theorem
L857: (for B447 being  with_non-empty_element set holds (for B448 , B449 being (object of ( B447 -ALG_category )) holds (for B450 being set holds (B450 in <^ B448 , B449 ^> iff B450 is  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving  directed-sups-preserving (Function of ( latt B448 ) , ( latt B449 ))))))
proof
let C317 being  with_non-empty_element set;
let C318 , C319 being (object of ( C317 -ALG_category ));
let C320 being set;
reconsider D108 = C318 , D109 = C319 as (object of ( C317 -CONT_category )) by ALTCAT_2:29;
L858: <^ C318 , C319 ^> = <^ D108 , D109 ^> by ALTCAT_2:28;
thus L859: thesis by L858 , L854;
end;
registration
let C321 being  with_non-empty_element set;
let C322 , C323 being (object of ( C321 -CONT_category ));
cluster <^ C322 , C323 ^> -> non  empty;
coherence
proof
set D110 = the  directed-sups-preserving (Function of ( latt C322 ) , ( latt C323 ));
L860: D110 in <^ C322 , C323 ^> by L854;
thus L861: thesis by L860;
end;
end;
registration
let C324 being  with_non-empty_element set;
let C325 , C326 being (object of ( C324 -ALG_category ));
cluster <^ C325 , C326 ^> -> non  empty;
coherence
proof
set D111 = the  directed-sups-preserving (Function of ( latt C325 ) , ( latt C326 ));
L863: D111 in <^ C325 , C326 ^> by L857;
thus L864: thesis by L863;
end;
end;
