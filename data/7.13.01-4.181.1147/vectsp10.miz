:: Quotient Vector Spaces and Functionals
::  by Jaros{\l}aw Kotowicz
::
:: Received November 5, 2002
:: Copyright (c) 2002-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ALGSTR_0, STRUCT_0, VECTSP_1, SUPINF_2, XBOOLE_0, RLVECT_1,
      SUBSET_1, ARYTM_3, BINOP_1, LATTICES, FUNCT_1, RELAT_1, MESFUNC1,
      ZFMISC_1, RLSUB_1, RLVECT_3, RLVECT_2, CARD_3, FUNCT_2, TARSKI, ARYTM_1,
      RLSUB_2, FINSEQ_4, MCART_1, GROUP_1, SETFAM_1, HAHNBAN, MSSUBFAM,
      UNIALG_1, HAHNBAN1, GROUP_6, VECTSP10;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, FUNCT_1, DOMAIN_1, STRUCT_0,
      ALGSTR_0, RLVECT_1, BINOP_1, GROUP_1, VECTSP_1, RELSET_1, FUNCT_2,
      VECTSP_4, VECTSP_5, VECTSP_6, VECTSP_7, GRCAT_1, HAHNBAN1;
 constructors REALSET2, VECTSP_5, VECTSP_6, VECTSP_7, HAHNBAN1, RELSET_1,
      GRCAT_1;
 registrations SUBSET_1, FUNCT_1, FINSET_1, STRUCT_0, VECTSP_1, VECTSP_4,
      HAHNBAN1, ALGSTR_0, FUNCT_2, RELAT_1, ZFMISC_1, RELSET_1;
 requirements SUBSET, BOOLE;
 definitions HAHNBAN1, TARSKI, XBOOLE_0, VECTSP_4, VECTSP_5, RLVECT_1, FUNCT_1,
      STRUCT_0, ALGSTR_0, VECTSP_1;
 theorems XBOOLE_1, FUNCT_2, HAHNBAN1, VECTSP_1, RLVECT_1, MCART_1, VECTSP_5,
      VECTSP_4, VECTSP_6, VECTSP_7, TARSKI, FUNCT_1, XBOOLE_0, ZFMISC_1,
      BINOP_1, GROUP_1, STRUCT_0, ALGSTR_0, XTUPLE_0;
 schemes FUNCT_2, BINOP_1;

begin
definition
let C1 being doubleLoopStr;
func StructVectSp C1 ->  strict VectSpStr over C1 equals 
VectSpStr (# (the carrier of C1) , (the addF of C1) , ( 0. C1 ) , (the multF of C1) #);
coherence;
end;
registration
let C2 being non  empty doubleLoopStr;
cluster ( StructVectSp C2 ) -> non  empty;
coherence;
end;
registration
let C3 being  Abelian non  empty doubleLoopStr;
cluster ( StructVectSp C3 ) ->  Abelian;
coherence
proof
set D1 = ( StructVectSp C3 );
L3:
now
let C4 , C5 being (Vector of D1);
reconsider D2 = C4 , D3 = C5 as (Element of C3);
thus L4: ( C4 + C5 ) = ( D3 + D2 ) by RLVECT_1:2
.= ( C5 + C4 );
end;
thus L5: thesis by L3 , RLVECT_1:def 2;
end;
end;
registration
let C6 being  add-associative non  empty doubleLoopStr;
cluster ( StructVectSp C6 ) ->  add-associative;
coherence
proof
set D4 = ( StructVectSp C6 );
L7:
now
let C7 , C8 , C9 being (Vector of D4);
reconsider D5 = C7 , D6 = C8 , D7 = C9 as (Element of C6);
thus L8: ( ( C7 + C8 ) + C9 ) = ( ( D5 + D6 ) + D7 )
.= ( D5 + ( D6 + D7 ) ) by RLVECT_1:def 3
.= ( C7 + ( C8 + C9 ) );
end;
thus L9: thesis by L7 , RLVECT_1:def 3;
end;
end;
registration
let C10 being  right_zeroed non  empty doubleLoopStr;
cluster ( StructVectSp C10 ) ->  right_zeroed;
coherence
proof
set D8 = ( StructVectSp C10 );
L11:
now
let C11 being (Vector of D8);
reconsider D9 = C11 as (Element of C10);
thus L12: ( C11 + ( 0. D8 ) ) = ( D9 + ( 0. C10 ) )
.= C11 by RLVECT_1:def 4;
end;
thus L13: thesis by L11 , RLVECT_1:def 4;
end;
end;
registration
let C12 being  right_complementable non  empty doubleLoopStr;
cluster ( StructVectSp C12 ) ->  right_complementable;
coherence
proof
set D10 = ( StructVectSp C12 );
let C13 being (Vector of D10);
reconsider D11 = C13 as (Element of C12);
consider C14 being (Element of C12) such that L15: ( D11 + C14 ) = ( 0. C12 ) by ALGSTR_0:def 11;
reconsider D12 = C14 as (Vector of D10);
take D12;
thus L16: thesis by L15;
end;
end;
registration
let C15 being  associative  left_unital  distributive non  empty doubleLoopStr;
cluster ( StructVectSp C15 ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
set D13 = ( StructVectSp C15 );
L18:
now
let C16 , C17 being (Element of C15);
let C18 , C19 being (Vector of D13);
reconsider D14 = C18 , D15 = C19 as (Element of C15);
thus L19: ( C16 * ( C18 + C19 ) ) = ( C16 * ( D14 + D15 ) )
.= ( ( C16 * D14 ) + ( C16 * D15 ) ) by VECTSP_1:def 7
.= ( ( C16 * C18 ) + ( C16 * C19 ) );
thus L20: ( ( C16 + C17 ) * C18 ) = ( ( C16 + C17 ) * D14 )
.= ( ( C16 * D14 ) + ( C17 * D14 ) ) by VECTSP_1:def 7
.= ( ( C16 * C18 ) + ( C17 * C18 ) );
thus L21: ( ( C16 * C17 ) * C18 ) = ( ( C16 * C17 ) * D14 )
.= ( C16 * ( C17 * D14 ) ) by GROUP_1:def 3
.= ( (the lmult of D13) . (C16 , ( C17 * C18 )) )
.= ( C16 * ( C17 * C18 ) );
thus L22: ( ( 1. C15 ) * C18 ) = ( ( 1. C15 ) * D14 )
.= C18 by VECTSP_1:def 8;
end;
thus L23: thesis by L18 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
end;
registration
let C20 being non  degenerated non  empty doubleLoopStr;
cluster ( StructVectSp C20 ) -> non  trivial;
coherence;
end;
registration
let C21 being non  degenerated non  empty doubleLoopStr;
cluster non  trivial for VectSpStr over C21;
existence
proof
take ( StructVectSp C21 );
thus L26: thesis;
end;
end;
registration
let C22 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
cluster  add-associative  right_zeroed  right_complementable  strict for non  empty non  empty non  empty non  empty VectSpStr over C22;
correctness
proof
take ( StructVectSp C22 );
thus L28: thesis;
end;
end;
registration
let C23 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr;
cluster  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  strict for non  empty non  empty non  empty non  empty VectSpStr over C23;
correctness
proof
take ( StructVectSp C23 );
thus L30: thesis;
end;
end;
registration
let C24 being  Abelian  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  degenerated non  empty doubleLoopStr;
cluster  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  strict for non  trivial non  trivial non  trivial non  trivial VectSpStr over C24;
existence
proof
take ( StructVectSp C24 );
thus L32: thesis;
end;
end;
theorem
L34: (for B1 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr holds (for B2 being (Element of B1) holds (for B3 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B1 holds (for B4 being (Vector of B3) holds (( ( 0. B1 ) * B4 ) = ( 0. B3 ) & ( B2 * ( 0. B3 ) ) = ( 0. B3 ))))))
proof
let C25 being  add-associative  right_zeroed  right_complementable  associative  left_unital  distributive non  empty doubleLoopStr;
let C26 being (Element of C25);
let C27 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C25;
let C28 being (Vector of C27);
L35: ( C28 + ( ( 0. C25 ) * C28 ) ) = ( ( ( 1. C25 ) * C28 ) + ( ( 0. C25 ) * C28 ) ) by VECTSP_1:def 17
.= ( ( ( 1. C25 ) + ( 0. C25 ) ) * C28 ) by VECTSP_1:def 15
.= ( ( 1. C25 ) * C28 ) by RLVECT_1:4
.= C28 by VECTSP_1:def 17
.= ( C28 + ( 0. C27 ) ) by RLVECT_1:4;
thus L36: ( ( 0. C25 ) * C28 ) = ( 0. C27 ) by L35 , RLVECT_1:8;
thus L37: ( C26 * ( 0. C27 ) ) = ( ( C26 * ( 0. C25 ) ) * C28 ) by L36 , VECTSP_1:def 16
.= ( 0. C27 ) by L36 , VECTSP_1:6;
end;
theorem
L38: (for B5 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B6 being (VectSp of B5) holds (for B7 , B8 being (Subspace of B6) holds (for B9 being (Vector of B6) holds ((( B7 /\ B8 ) = ( (0). B6 ) & B9 in B7 & B9 in B8) implies B9 = ( 0. B6 ))))))
proof
let C29 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C30 being (VectSp of C29);
let C31 , C32 being (Subspace of C30);
let C33 being (Vector of C30);
assume that
L39: ( C31 /\ C32 ) = ( (0). C30 )
and
L40: (C33 in C31 & C33 in C32);
L41: (C33 in (the carrier of C31) & C33 in (the carrier of C32)) by L40 , STRUCT_0:def 5;
L42: C33 in ( (the carrier of C31) /\ (the carrier of C32) ) by L41 , XBOOLE_0:def 4;
L43: C33 in (the carrier of ( C31 /\ C32 )) by L42 , VECTSP_5:def 2;
L44: C33 in { ( 0. C30 ) } by L43 , L39 , VECTSP_4:def 3;
thus L45: thesis by L44 , TARSKI:def 1;
end;
theorem
L46: (for B10 being Field holds (for B11 being (VectSp of B10) holds (for B12 being set holds (for B13 being (Vector of B11) holds (B12 in ( Lin { B13 } ) iff (ex B14 being (Element of B10) st B12 = ( B14 * B13 )))))))
proof
let C34 being Field;
let C35 being (VectSp of C34);
let C36 being set;
let C37 being (Vector of C35);
thus L47: (C36 in ( Lin { C37 } ) implies (ex B15 being (Element of C34) st C36 = ( B15 * C37 )))
proof
assume L48: C36 in ( Lin { C37 } );
consider C38 being (Linear_Combination of { C37 }) such that L49: C36 = ( Sum C38 ) by L48 , VECTSP_7:7;
L50: ( Sum C38 ) = ( ( C38 . C37 ) * C37 ) by VECTSP_6:17;
thus L51: thesis by L50 , L49;
end;

given C39 being (Element of C34) such that
L52: C36 = ( C39 * C37 );

deffunc H1(set) = ( 0. C34 );
consider C40 being (Function of (the carrier of C35) , (the carrier of C34)) such that L53: ( C40 . C37 ) = C39 and L54: (for B16 being (Vector of C35) holds (B16 <> C37 implies ( C40 . B16 ) = H1(B16))) from FUNCT_2:sch 6;
reconsider D16 = C40 as (Element of ( Funcs ((the carrier of C35) , (the carrier of C34)) )) by FUNCT_2:8;
L55:
now
let C41 being (Vector of C35);
assume L56: (not C41 in { C37 });
L57: C41 <> C37 by L56 , TARSKI:def 1;
thus L58: ( D16 . C41 ) = ( 0. C34 ) by L57 , L54;
end;
reconsider D17 = D16 as (Linear_Combination of C35) by L55 , VECTSP_6:def 1;
L59: ( Carrier D17 ) c= { C37 }
proof
let C42 being set;
assume L60: C42 in ( Carrier D17 );
L61: ( D17 . C42 ) <> ( 0. C34 ) by L60 , VECTSP_6:2;
L62: C42 = C37 by L61 , L54 , L60;
thus L63: thesis by L62 , TARSKI:def 1;
end;
reconsider D18 = D17 as (Linear_Combination of { C37 }) by L59 , VECTSP_6:def 4;
L64: ( Sum D18 ) = C36 by L52 , L53 , VECTSP_6:17;
thus L65: thesis by L64 , VECTSP_7:7;
end;
theorem
L66: (for B17 being Field holds (for B18 being (VectSp of B17) holds (for B19 being (Vector of B18) holds (for B20 , B21 being (Scalar of B18) holds ((B19 <> ( 0. B18 ) & ( B20 * B19 ) = ( B21 * B19 )) implies B20 = B21)))))
proof
let C43 being Field;
let C44 being (VectSp of C43);
let C45 being (Vector of C44);
let C46 , C47 being (Scalar of C44);
assume that
L67: C45 <> ( 0. C44 )
and
L68: ( C46 * C45 ) = ( C47 * C45 );
L69: ( ( C46 * C45 ) - ( C47 * C45 ) ) = ( 0. C44 ) by L68 , VECTSP_1:19;
L70: ( ( C46 - C47 ) * C45 ) = ( 0. C44 ) by L69 , VECTSP_4:82;
L71: ( C46 - C47 ) = ( 0. C43 ) by L70 , L67 , VECTSP_1:15;
thus L72: thesis by L71 , VECTSP_1:19;
end;
theorem
L73: (for B22 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B23 being (VectSp of B22) holds (for B24 , B25 being (Subspace of B23) holds (B23 is_the_direct_sum_of B24 , B25 implies (for B26 , B27 , B28 being (Vector of B23) holds ((B27 in B24 & B28 in B25 & B26 = ( B27 + B28 )) implies ( B26 |-- (B24 , B25) ) = [ B27 , B28 ]))))))
proof
let C48 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C49 being (VectSp of C48);
let C50 , C51 being (Subspace of C49);
assume L74: C49 is_the_direct_sum_of C50 , C51;
let C52 , C53 , C54 being (Vector of C49);
L75: (( [ C53 , C54 ] `1 ) = C53 & ( [ C53 , C54 ] `2 ) = C54) by MCART_1:7;
thus L76: thesis by L75 , L74 , VECTSP_5:def 6;
end;
theorem
L77: (for B29 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B30 being (VectSp of B29) holds (for B31 , B32 being (Subspace of B30) holds (B30 is_the_direct_sum_of B31 , B32 implies (for B33 , B34 , B35 being (Vector of B30) holds (( B33 |-- (B31 , B32) ) = [ B34 , B35 ] implies B33 = ( B34 + B35 )))))))
proof
let C55 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C56 being (VectSp of C55);
let C57 , C58 being (Subspace of C56);
assume that
L78: C56 is_the_direct_sum_of C57 , C58;
let C59 , C60 , C61 being (Vector of C56);
assume L79: ( C59 |-- (C57 , C58) ) = [ C60 , C61 ];
L80: (( ( C59 |-- (C57 , C58) ) `1 ) = C60 & ( ( C59 |-- (C57 , C58) ) `2 ) = C61) by L79 , MCART_1:7;
thus L81: thesis by L80 , L78 , VECTSP_5:def 6;
end;
theorem
L82: (for B36 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B37 being (VectSp of B36) holds (for B38 , B39 being (Subspace of B37) holds (B37 is_the_direct_sum_of B38 , B39 implies (for B40 , B41 , B42 being (Vector of B37) holds (( B40 |-- (B38 , B39) ) = [ B41 , B42 ] implies (B41 in B38 & B42 in B39)))))))
proof
let C62 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C63 being (VectSp of C62);
let C64 , C65 being (Subspace of C63);
assume that
L83: C63 is_the_direct_sum_of C64 , C65;
let C66 , C67 , C68 being (Vector of C63);
assume L84: ( C66 |-- (C64 , C65) ) = [ C67 , C68 ];
L85: (( ( C66 |-- (C64 , C65) ) `1 ) = C67 & ( ( C66 |-- (C64 , C65) ) `2 ) = C68) by L84 , MCART_1:7;
thus L86: thesis by L85 , L83 , VECTSP_5:def 6;
end;
theorem
L87: (for B43 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B44 being (VectSp of B43) holds (for B45 , B46 being (Subspace of B44) holds (B44 is_the_direct_sum_of B45 , B46 implies (for B47 , B48 , B49 being (Vector of B44) holds (( B47 |-- (B45 , B46) ) = [ B48 , B49 ] implies ( B47 |-- (B46 , B45) ) = [ B49 , B48 ]))))))
proof
let C69 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C70 being (VectSp of C69);
let C71 , C72 being (Subspace of C70);
assume L88: C70 is_the_direct_sum_of C71 , C72;
let C73 , C74 , C75 being (Vector of C70);
assume L89: ( C73 |-- (C71 , C72) ) = [ C74 , C75 ];
L90: ( ( C73 |-- (C71 , C72) ) `1 ) = C74 by L89 , MCART_1:7;
L91: C74 in C71 by L90 , L88 , VECTSP_5:def 6;
L92: ( ( C73 |-- (C71 , C72) ) `2 ) = C75 by L89 , MCART_1:7;
L93: C75 in C72 by L92 , L88 , VECTSP_5:def 6;
L94: C73 = ( C75 + C74 ) by L88 , L90 , L92 , VECTSP_5:def 6;
thus L95: thesis by L94 , L88 , L91 , L93 , L73 , VECTSP_5:41;
end;
theorem
L96: (for B50 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B51 being (VectSp of B50) holds (for B52 , B53 being (Subspace of B51) holds (B51 is_the_direct_sum_of B52 , B53 implies (for B54 being (Vector of B51) holds (B54 in B52 implies ( B54 |-- (B52 , B53) ) = [ B54 , ( 0. B51 ) ]))))))
proof
let C76 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C77 being (VectSp of C76);
let C78 , C79 being (Subspace of C77);
assume that
L97: C77 is_the_direct_sum_of C78 , C79;
let C80 being (Vector of C77);
assume that
L98: C80 in C78;
L99: (( 0. C77 ) in C79 & ( C80 + ( 0. C77 ) ) = C80) by RLVECT_1:4 , VECTSP_4:17;
thus L100: thesis by L99 , L97 , L98 , L73;
end;
theorem
L101: (for B55 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B56 being (VectSp of B55) holds (for B57 , B58 being (Subspace of B56) holds (B56 is_the_direct_sum_of B57 , B58 implies (for B59 being (Vector of B56) holds (B59 in B58 implies ( B59 |-- (B57 , B58) ) = [ ( 0. B56 ) , B59 ]))))))
proof
let C81 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C82 being (VectSp of C81);
let C83 , C84 being (Subspace of C82);
assume L102: C82 is_the_direct_sum_of C83 , C84;
let C85 being (Vector of C82);
assume L103: C85 in C84;
L104: ( C85 |-- (C84 , C83) ) = [ C85 , ( 0. C82 ) ] by L103 , L102 , L96 , VECTSP_5:41;
thus L105: thesis by L104 , L102 , L87 , VECTSP_5:41;
end;
theorem
L106: (for B60 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B61 being (VectSp of B60) holds (for B62 being (Subspace of B61) holds (for B63 being (Subspace of B62) holds (for B64 being (Vector of B61) holds (B64 in B63 implies B64 is (Vector of B62)))))))
proof
let C86 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C87 being (VectSp of C86);
let C88 being (Subspace of C87);
let C89 being (Subspace of C88);
let C90 being (Vector of C87);
assume L107: C90 in C89;
L108: ((the carrier of C89) c= (the carrier of C88) & C90 in (the carrier of C89)) by L107 , STRUCT_0:def 5 , VECTSP_4:def 2;
thus L109: thesis by L108;
end;
theorem
L110: (for B65 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B66 being (VectSp of B65) holds (for B67 , B68 , B69 being (Subspace of B66) holds (for B70 , B71 being (Subspace of B69) holds ((B70 = B67 & B71 = B68) implies ( B70 + B71 ) = ( B67 + B68 ))))))
proof
let C91 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C92 being (VectSp of C91);
let C93 , C94 , C95 being (Subspace of C92);
let C96 , C97 being (Subspace of C95);
assume that
L111: (C96 = C93 & C97 = C94);
reconsider D19 = ( C96 + C97 ) as (Subspace of C92) by VECTSP_4:26;
L112:
now
let C98 being (Vector of C92);
L113: ((the carrier of C96) c= (the carrier of C95) & (the carrier of C97) c= (the carrier of C95)) by VECTSP_4:def 2;
thus L114:now
assume L115: C98 in D19;
reconsider D20 = C98 as (Vector of C95) by L115 , L106;
consider C99 , C100 being (Vector of C95) such that L116: (C99 in C96 & C100 in C97) and L117: D20 = ( C99 + C100 ) by L115 , VECTSP_5:1;
reconsider D21 = C99 , D22 = C100 as (Vector of C92) by VECTSP_4:10;
L118: C98 = ( D21 + D22 ) by L117 , VECTSP_4:13;
thus L119: C98 in ( C93 + C94 ) by L118 , L111 , L116 , VECTSP_5:1;
end;
assume L120: C98 in ( C93 + C94 );
consider C101 , C102 being (Vector of C92) such that L121: (C101 in C93 & C102 in C94) and L122: C98 = ( C101 + C102 ) by L120 , VECTSP_5:1;
L123: (C101 in (the carrier of C96) & C102 in (the carrier of C97)) by L111 , L121 , STRUCT_0:def 5;
reconsider D23 = C101 , D24 = C102 as (Vector of C95) by L123 , L113;
L124: C98 = ( D23 + D24 ) by L122 , VECTSP_4:13;
thus L125: C98 in D19 by L124 , L111 , L121 , VECTSP_5:1;
end;
thus L126: thesis by L112 , VECTSP_4:30;
end;
theorem
L127: (for B72 being Field holds (for B73 being (VectSp of B72) holds (for B74 being (Subspace of B73) holds (for B75 being (Vector of B73) holds (for B76 being (Vector of B74) holds (B75 = B76 implies ( Lin { B76 } ) = ( Lin { B75 } )))))))
proof
let C103 being Field;
let C104 being (VectSp of C103);
let C105 being (Subspace of C104);
let C106 being (Vector of C104);
let C107 being (Vector of C105);
assume that
L128: C106 = C107;
reconsider D25 = ( Lin { C107 } ) as (Subspace of C104) by VECTSP_4:26;
L129:
now
let C108 being (Vector of C104);
thus L130:now
assume L131: C108 in D25;
consider C109 being (Element of C103) such that L132: C108 = ( C109 * C107 ) by L131 , L46;
L133: C108 = ( C109 * C106 ) by L128 , L132 , VECTSP_4:14;
thus L134: C108 in ( Lin { C106 } ) by L133 , L46;
end;
assume L135: C108 in ( Lin { C106 } );
consider C110 being (Element of C103) such that L136: C108 = ( C110 * C106 ) by L135 , L46;
L137: C108 = ( C110 * C107 ) by L128 , L136 , VECTSP_4:14;
thus L138: C108 in D25 by L137 , L46;
end;
thus L139: thesis by L129 , VECTSP_4:30;
end;
theorem
L140: (for B77 being Field holds (for B78 being (VectSp of B77) holds (for B79 being (Vector of B78) holds (for B80 being (Subspace of B78) holds ((not B79 in B80) implies (for B81 being (Vector of ( B80 + ( Lin { B79 } ) )) holds (for B82 being (Subspace of ( B80 + ( Lin { B79 } ) )) holds ((B79 = B81 & B82 = B80) implies ( B80 + ( Lin { B79 } ) ) is_the_direct_sum_of B82 , ( Lin { B81 } )))))))))
proof
let C111 being Field;
let C112 being (VectSp of C111);
let C113 being (Vector of C112);
let C114 being (Subspace of C112);
assume that
L141: (not C113 in C114);
let C115 being (Vector of ( C114 + ( Lin { C113 } ) ));
let C116 being (Subspace of ( C114 + ( Lin { C113 } ) ));
assume that
L142: C113 = C115
and
L143: C116 = C114;
L144: ( Lin { C113 } ) = ( Lin { C115 } ) by L142 , L127;
thus L145: ( the VectSpStr of ( C114 + ( Lin { C113 } ) ) ) = ( C116 + ( Lin { C115 } ) ) by L144 , L143 , L110;
assume L146: ( C116 /\ ( Lin { C115 } ) ) <> ( (0). ( C114 + ( Lin { C113 } ) ) );
consider C117 being (Vector of ( C114 + ( Lin { C113 } ) )) such that L147: (not (C117 in ( C116 /\ ( Lin { C115 } ) ) iff C117 in ( (0). ( C114 + ( Lin { C113 } ) ) ))) by L146 , VECTSP_4:30;
per cases  by L147;
suppose that L148: C117 in ( C116 /\ ( Lin { C115 } ) )
and
L149: (not C117 in ( (0). ( C114 + ( Lin { C113 } ) ) ));
L150: C117 in ( Lin { C115 } ) by L148 , VECTSP_5:3;
consider C118 being (Element of C111) such that L151: C117 = ( C118 * C115 ) by L150 , L46;
L152: C117 in C116 by L148 , VECTSP_5:3;
L153:
now
per cases ;
suppose L154: C118 = ( 0. C111 );

L155: C117 = ( 0. ( C114 + ( Lin { C113 } ) ) ) by L154 , L151 , VECTSP_1:15;
thus L156: contradiction by L155 , L149 , VECTSP_4:17;
end;
suppose L157: C118 <> ( 0. C111 );

L158: C115 = ( ( 1_ C111 ) * C115 ) by VECTSP_1:def 17
.= ( ( ( C118 " ) * C118 ) * C115 ) by L157 , VECTSP_1:def 10
.= ( ( C118 " ) * ( C118 * C115 ) ) by VECTSP_1:def 16;
thus L159: contradiction by L158 , L141 , L142 , L143 , L152 , L151 , VECTSP_4:21;
end;
end;
thus L161: contradiction by L153;
end;
suppose that L162: (not C117 in ( C116 /\ ( Lin { C115 } ) ))
and
L163: C117 in ( (0). ( C114 + ( Lin { C113 } ) ) );
L164: C117 = ( 0. ( C114 + ( Lin { C113 } ) ) ) by L163 , VECTSP_4:35;
thus L165: contradiction by L164 , L162 , VECTSP_4:17;
end;
end;
theorem
L167: (for B83 being Field holds (for B84 being (VectSp of B83) holds (for B85 being (Vector of B84) holds (for B86 being (Subspace of B84) holds (for B87 being (Vector of ( B86 + ( Lin { B85 } ) )) holds (for B88 being (Subspace of ( B86 + ( Lin { B85 } ) )) holds ((B85 = B87 & B86 = B88 & (not B85 in B86)) implies ( B87 |-- (B88 , ( Lin { B87 } )) ) = [ ( 0. B88 ) , B87 ])))))))
proof
let C119 being Field;
let C120 being (VectSp of C119);
let C121 being (Vector of C120);
let C122 being (Subspace of C120);
let C123 being (Vector of ( C122 + ( Lin { C121 } ) ));
let C124 being (Subspace of ( C122 + ( Lin { C121 } ) ));
assume L168: (C121 = C123 & C122 = C124 & (not C121 in C122));
L169: (C123 in { C123 } & ( C122 + ( Lin { C121 } ) ) is_the_direct_sum_of C124 , ( Lin { C123 } )) by L168 , L140 , TARSKI:def 1;
L170: ( C123 |-- (C124 , ( Lin { C123 } )) ) = [ ( 0. ( C122 + ( Lin { C121 } ) ) ) , C123 ] by L169 , L101 , VECTSP_7:8;
thus L171: thesis by L170 , VECTSP_4:11;
end;
theorem
L172: (for B89 being Field holds (for B90 being (VectSp of B89) holds (for B91 being (Vector of B90) holds (for B92 being (Subspace of B90) holds (for B93 being (Vector of ( B92 + ( Lin { B91 } ) )) holds (for B94 being (Subspace of ( B92 + ( Lin { B91 } ) )) holds ((B91 = B93 & B92 = B94 & (not B91 in B92)) implies (for B95 being (Vector of ( B92 + ( Lin { B91 } ) )) holds (B95 in B92 implies ( B95 |-- (B94 , ( Lin { B93 } )) ) = [ B95 , ( 0. B90 ) ])))))))))
proof
let C125 being Field;
let C126 being (VectSp of C125);
let C127 being (Vector of C126);
let C128 being (Subspace of C126);
let C129 being (Vector of ( C128 + ( Lin { C127 } ) ));
let C130 being (Subspace of ( C128 + ( Lin { C127 } ) ));
assume that
L173: C127 = C129
and
L174: C128 = C130
and
L175: (not C127 in C128);
L176: ( C128 + ( Lin { C127 } ) ) is_the_direct_sum_of C130 , ( Lin { C129 } ) by L173 , L174 , L175 , L140;
let C131 being (Vector of ( C128 + ( Lin { C127 } ) ));
assume L177: C131 in C128;
L178: ( C131 |-- (C130 , ( Lin { C129 } )) ) = [ C131 , ( 0. ( C128 + ( Lin { C127 } ) ) ) ] by L177 , L174 , L176 , L96;
thus L179: thesis by L178 , VECTSP_4:11;
end;
theorem
L180: (for B96 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr holds (for B97 being (VectSp of B96) holds (for B98 being (Vector of B97) holds (for B99 , B100 being (Subspace of B97) holds (ex B101 , B102 being (Vector of B97) st ( B98 |-- (B99 , B100) ) = [ B101 , B102 ])))))
proof
let C132 being  add-associative  right_zeroed  right_complementable  associative  Abelian  well-unital  distributive non  empty doubleLoopStr;
let C133 being (VectSp of C132);
let C134 being (Vector of C133);
let C135 , C136 being (Subspace of C133);
take ( ( C134 |-- (C135 , C136) ) `1 );
take ( ( C134 |-- (C135 , C136) ) `2 );
thus L181: thesis by MCART_1:21;
end;
theorem
L182: (for B103 being Field holds (for B104 being (VectSp of B103) holds (for B105 being (Vector of B104) holds (for B106 being (Subspace of B104) holds (for B107 being (Vector of ( B106 + ( Lin { B105 } ) )) holds (for B108 being (Subspace of ( B106 + ( Lin { B105 } ) )) holds ((B105 = B107 & B106 = B108 & (not B105 in B106)) implies (for B109 being (Vector of ( B106 + ( Lin { B105 } ) )) holds (ex B110 being (Vector of B106) st (ex B111 being (Element of B103) st ( B109 |-- (B108 , ( Lin { B107 } )) ) = [ B110 , ( B111 * B105 ) ]))))))))))
proof
let C137 being Field;
let C138 being (VectSp of C137);
let C139 being (Vector of C138);
let C140 being (Subspace of C138);
let C141 being (Vector of ( C140 + ( Lin { C139 } ) ));
let C142 being (Subspace of ( C140 + ( Lin { C139 } ) ));
assume that
L183: C139 = C141
and
L184: C140 = C142
and
L185: (not C139 in C140);
let C143 being (Vector of ( C140 + ( Lin { C139 } ) ));
consider C144 , C145 being (Vector of ( C140 + ( Lin { C139 } ) )) such that L186: ( C143 |-- (C142 , ( Lin { C141 } )) ) = [ C144 , C145 ] by L180;
L187: ( C140 + ( Lin { C139 } ) ) is_the_direct_sum_of C142 , ( Lin { C141 } ) by L183 , L184 , L185 , L140;
L188: C144 in C142 by L187 , L186 , L82;
reconsider D26 = C144 as (Vector of C140) by L188 , L184 , STRUCT_0:def 5;
L189: C145 in ( Lin { C141 } ) by L187 , L186 , L82;
consider C146 being (Element of C137) such that L190: C145 = ( C146 * C141 ) by L189 , L46;
take D26;
take C146;
thus L191: thesis by L183 , L186 , L190 , VECTSP_4:14;
end;
theorem
L192: (for B112 being Field holds (for B113 being (VectSp of B112) holds (for B114 being (Vector of B113) holds (for B115 being (Subspace of B113) holds (for B116 being (Vector of ( B115 + ( Lin { B114 } ) )) holds (for B117 being (Subspace of ( B115 + ( Lin { B114 } ) )) holds ((B114 = B116 & B115 = B117 & (not B114 in B115)) implies (for B118 , B119 being (Vector of ( B115 + ( Lin { B114 } ) )) holds (for B120 , B121 being (Vector of B115) holds (for B122 , B123 being (Element of B112) holds ((( B118 |-- (B117 , ( Lin { B116 } )) ) = [ B120 , ( B122 * B114 ) ] & ( B119 |-- (B117 , ( Lin { B116 } )) ) = [ B121 , ( B123 * B114 ) ]) implies ( ( B118 + B119 ) |-- (B117 , ( Lin { B116 } )) ) = [ ( B120 + B121 ) , ( ( B122 + B123 ) * B114 ) ])))))))))))
proof
let C147 being Field;
let C148 being (VectSp of C147);
let C149 being (Vector of C148);
let C150 being (Subspace of C148);
let C151 being (Vector of ( C150 + ( Lin { C149 } ) ));
let C152 being (Subspace of ( C150 + ( Lin { C149 } ) ));
assume that
L193: C149 = C151
and
L194: C150 = C152
and
L195: (not C149 in C150);
L196: ( C150 + ( Lin { C149 } ) ) is_the_direct_sum_of C152 , ( Lin { C151 } ) by L193 , L194 , L195 , L140;
let C153 , C154 being (Vector of ( C150 + ( Lin { C149 } ) ));
let C155 , C156 being (Vector of C150);
let C157 , C158 being (Element of C147);
assume that
L197: ( C153 |-- (C152 , ( Lin { C151 } )) ) = [ C155 , ( C157 * C149 ) ]
and
L198: ( C154 |-- (C152 , ( Lin { C151 } )) ) = [ C156 , ( C158 * C149 ) ];
reconsider D27 = C155 , D28 = C156 as (Vector of ( C150 + ( Lin { C149 } ) )) by L194 , VECTSP_4:10;
L199: ( C158 * C149 ) = ( C158 * C151 ) by L193 , VECTSP_4:14;
L200: D28 in C152 by L199 , L196 , L198 , L82;
L201: ( ( C157 + C158 ) * C149 ) = ( ( C157 + C158 ) * C151 ) by L193 , VECTSP_4:14;
L202: ( ( C157 + C158 ) * C149 ) in ( Lin { C151 } ) by L201 , L46;
reconsider D29 = C155 , D30 = C156 as (Vector of C148) by VECTSP_4:10;
L203: ( D27 + D28 ) = ( D29 + D30 ) by VECTSP_4:13
.= ( C155 + C156 ) by VECTSP_4:13;
L204: ( C157 * C149 ) = ( C157 * C151 ) by L193 , VECTSP_4:14;
L205: D27 in C152 by L204 , L196 , L197 , L82;
L206: ( D27 + D28 ) in C152 by L205 , L200 , VECTSP_4:20;
L207: C154 = ( D28 + ( C158 * C151 ) ) by L196 , L198 , L199 , L77;
L208: C153 = ( D27 + ( C157 * C151 ) ) by L196 , L197 , L204 , L77;
L209: ( C153 + C154 ) = ( ( ( D27 + ( C157 * C151 ) ) + D28 ) + ( C158 * C151 ) ) by L208 , L207 , RLVECT_1:def 3
.= ( ( ( D27 + D28 ) + ( C157 * C151 ) ) + ( C158 * C151 ) ) by RLVECT_1:def 3
.= ( ( D27 + D28 ) + ( ( C157 * C151 ) + ( C158 * C151 ) ) ) by RLVECT_1:def 3
.= ( ( D27 + D28 ) + ( ( C157 + C158 ) * C151 ) ) by VECTSP_1:def 15;
L210: ( ( C157 + C158 ) * C151 ) = ( ( C157 + C158 ) * C149 ) by L193 , VECTSP_4:14;
thus L211: thesis by L210 , L196 , L206 , L202 , L209 , L203 , L73;
end;
theorem
L212: (for B124 being Field holds (for B125 being (VectSp of B124) holds (for B126 being (Vector of B125) holds (for B127 being (Subspace of B125) holds (for B128 being (Vector of ( B127 + ( Lin { B126 } ) )) holds (for B129 being (Subspace of ( B127 + ( Lin { B126 } ) )) holds ((B126 = B128 & B127 = B129 & (not B126 in B127)) implies (for B130 being (Vector of ( B127 + ( Lin { B126 } ) )) holds (for B131 being (Vector of B127) holds (for B132 , B133 being (Element of B124) holds (( B130 |-- (B129 , ( Lin { B128 } )) ) = [ B131 , ( B133 * B126 ) ] implies ( ( B132 * B130 ) |-- (B129 , ( Lin { B128 } )) ) = [ ( B132 * B131 ) , ( ( B132 * B133 ) * B126 ) ])))))))))))
proof
let C159 being Field;
let C160 being (VectSp of C159);
let C161 being (Vector of C160);
let C162 being (Subspace of C160);
let C163 being (Vector of ( C162 + ( Lin { C161 } ) ));
let C164 being (Subspace of ( C162 + ( Lin { C161 } ) ));
assume that
L213: C161 = C163
and
L214: C162 = C164
and
L215: (not C161 in C162);
L216: ( C162 + ( Lin { C161 } ) ) is_the_direct_sum_of C164 , ( Lin { C163 } ) by L213 , L214 , L215 , L140;
let C165 being (Vector of ( C162 + ( Lin { C161 } ) ));
let C166 being (Vector of C162);
let C167 , C168 being (Element of C159);
assume that
L217: ( C165 |-- (C164 , ( Lin { C163 } )) ) = [ C166 , ( C168 * C161 ) ];
reconsider D31 = C166 as (Vector of ( C162 + ( Lin { C161 } ) )) by L214 , VECTSP_4:10;
L218: ( C168 * C163 ) = ( C168 * C161 ) by L213 , VECTSP_4:14;
L219: ( C167 * C165 ) = ( C167 * ( D31 + ( C168 * C163 ) ) ) by L218 , L216 , L217 , L77
.= ( ( C167 * D31 ) + ( C167 * ( C168 * C163 ) ) ) by VECTSP_1:def 14
.= ( ( C167 * D31 ) + ( ( C167 * C168 ) * C163 ) ) by VECTSP_1:def 16;
reconsider D32 = C166 as (Vector of C160) by VECTSP_4:10;
L220: ( ( C167 * C168 ) * C163 ) in ( Lin { C163 } ) by L46;
L221: ( ( C167 * C168 ) * C163 ) = ( ( C167 * C168 ) * C161 ) by L213 , VECTSP_4:14;
L222: ( C167 * D31 ) = ( C167 * D32 ) by VECTSP_4:14
.= ( C167 * C166 ) by VECTSP_4:14;
L223: ( C167 * D31 ) in C164 by L222 , L214 , STRUCT_0:def 5;
thus L224: thesis by L223 , L216 , L222 , L221 , L220 , L219 , L73;
end;
begin
definition
let C169 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C170 being (VectSp of C169);
let C171 being (Subspace of C170);
func CosetSet (C170 , C171) -> non  empty (Subset-Family of C170) equals 
{ B134 where B134 is (Coset of C171) : (not contradiction) };
correctness
proof
set D33 = { B135 where B135 is (Coset of C171) : (not contradiction) };
L225: D33 c= ( bool (the carrier of C170) )
proof
let C172 being set;
assume L226: C172 in D33;
L227: (ex B136 being (Coset of C171) st B136 = C172) by L226;
thus L228: thesis by L227;
end;
L229: (the carrier of C171) is (Coset of C171) by VECTSP_4:73;
L230: (the carrier of C171) in D33 by L229;
thus L231: thesis by L230 , L225;
end;
end;
definition
let C173 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C174 being (VectSp of C173);
let C175 being (Subspace of C174);
func addCoset (C174 , C175) -> (BinOp of ( CosetSet (C174 , C175) )) means 
:L233: (for B137 , B138 being (Element of ( CosetSet (C174 , C175) )) holds (for B139 , B140 being (Vector of C174) holds ((B137 = ( B139 + C175 ) & B138 = ( B140 + C175 )) implies ( it . (B137 , B138) ) = ( ( B139 + B140 ) + C175 ))));
existence
proof
defpred S1[ set , set , set ] means (for B141 , B142 being (Vector of C174) holds (($1 = ( B141 + C175 ) & $2 = ( B142 + C175 )) implies $3 = ( ( B141 + B142 ) + C175 )));
set D34 = ( CosetSet (C174 , C175) );
L234:
now
let C176 , C177 being (Element of D34);
L235: C176 in D34;
consider C178 being (Coset of C175) such that L236: C178 = C176 by L235;
consider C179 being (Vector of C174) such that L237: C178 = ( C179 + C175 ) by VECTSP_4:def 6;
L238: C177 in D34;
consider C180 being (Coset of C175) such that L239: C180 = C177 by L238;
consider C181 being (Vector of C174) such that L240: C180 = ( C181 + C175 ) by VECTSP_4:def 6;
reconsider D35 = ( ( C179 + C181 ) + C175 ) as (Coset of C175) by VECTSP_4:def 6;
L241: D35 in D34;
reconsider D36 = D35 as (Element of D34) by L241;
take D37 = D36;
thus L242: S1[ C176 , C177 , D37 ]
proof
let C182 , C183 being (Vector of C174);
assume that
L243: C176 = ( C182 + C175 )
and
L244: C177 = ( C183 + C175 );
L245: C182 in ( C179 + C175 ) by L236 , L237 , L243 , VECTSP_4:44;
consider C184 being (Vector of C174) such that L246: C184 in C175 and L247: C182 = ( C179 + C184 ) by L245 , VECTSP_4:42;
L248: C183 in ( C181 + C175 ) by L239 , L240 , L244 , VECTSP_4:44;
consider C185 being (Vector of C174) such that L249: C185 in C175 and L250: C183 = ( C181 + C185 ) by L248 , VECTSP_4:42;
L251: ( C184 + C185 ) in C175 by L246 , L249 , VECTSP_4:20;
L252: ( C182 + C183 ) = ( ( ( C184 + C179 ) + C181 ) + C185 ) by L247 , L250 , RLVECT_1:def 3
.= ( ( C184 + ( C179 + C181 ) ) + C185 ) by RLVECT_1:def 3
.= ( ( C179 + C181 ) + ( C184 + C185 ) ) by RLVECT_1:def 3;
L253: ( C182 + C183 ) in ( ( C179 + C181 ) + C175 ) by L252 , L251;
L254: ( C182 + C183 ) in ( ( C182 + C183 ) + C175 ) by VECTSP_4:44;
thus L255: thesis by L254 , L253 , VECTSP_4:56;
end;

end;
consider C186 being (Function of [: D34 , D34 :] , D34) such that L243: (for B143 , B144 being (Element of D34) holds S1[ B143 , B144 , ( C186 . (B143 , B144) ) ]) from BINOP_1:sch 3(L234);
reconsider D38 = C186 as (BinOp of D34);
take D38;
let C187 , C188 being (Element of D34);
let C189 , C190 being (Vector of C174);
assume L244: (C187 = ( C189 + C175 ) & C188 = ( C190 + C175 ));
thus L245: thesis by L244 , L243;
end;
uniqueness
proof
set D39 = ( CosetSet (C174 , C175) );
let C191 , C192 being (BinOp of ( CosetSet (C174 , C175) ));
assume that
L246: (for B145 , B146 being (Element of ( CosetSet (C174 , C175) )) holds (for B147 , B148 being (Vector of C174) holds ((B145 = ( B147 + C175 ) & B146 = ( B148 + C175 )) implies ( C191 . (B145 , B146) ) = ( ( B147 + B148 ) + C175 ))))
and
L247: (for B149 , B150 being (Element of ( CosetSet (C174 , C175) )) holds (for B151 , B152 being (Vector of C174) holds ((B149 = ( B151 + C175 ) & B150 = ( B152 + C175 )) implies ( C192 . (B149 , B150) ) = ( ( B151 + B152 ) + C175 ))));
L248:
now
let C193 , C194 being (Element of ( CosetSet (C174 , C175) ));
L249: C193 in D39;
consider C195 being (Coset of C175) such that L250: C195 = C193 by L249;
consider C196 being (Vector of C174) such that L251: C195 = ( C196 + C175 ) by VECTSP_4:def 6;
L252: C194 in D39;
consider C197 being (Coset of C175) such that L253: C197 = C194 by L252;
consider C198 being (Vector of C174) such that L254: C197 = ( C198 + C175 ) by VECTSP_4:def 6;
thus L255: ( C191 . (C193 , C194) ) = ( ( C196 + C198 ) + C175 ) by L246 , L250 , L253 , L251 , L254
.= ( C192 . (C193 , C194) ) by L247 , L250 , L253 , L251 , L254;
end;
thus L256: thesis by L248 , BINOP_1:2;
end;
end;
definition
let C199 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C200 being (VectSp of C199);
let C201 being (Subspace of C200);
func zeroCoset (C200 , C201) -> (Element of ( CosetSet (C200 , C201) )) equals 
(the carrier of C201);
coherence
proof
L258: (the carrier of C201) = ( ( 0. C200 ) + C201 ) by VECTSP_4:45;
L259: (the carrier of C201) is (Coset of C201) by L258 , VECTSP_4:def 6;
L260: (the carrier of C201) in ( CosetSet (C200 , C201) ) by L259;
thus L261: thesis by L260;
end;
end;
definition
let C202 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C203 being (VectSp of C202);
let C204 being (Subspace of C203);
func lmultCoset (C203 , C204) -> (Function of [: (the carrier of C202) , ( CosetSet (C203 , C204) ) :] , ( CosetSet (C203 , C204) )) means 
:L263: (for B153 being (Element of C202) holds (for B154 being (Element of ( CosetSet (C203 , C204) )) holds (for B155 being (Vector of C203) holds (B154 = ( B155 + C204 ) implies ( it . (B153 , B154) ) = ( ( B153 * B155 ) + C204 )))));
existence
proof
defpred S2[ (Element of C202) , set , set ] means (for B156 being (Vector of C203) holds ($2 = ( B156 + C204 ) implies $3 = ( ( $1 * B156 ) + C204 )));
set D40 = (the carrier of C202);
set D41 = ( CosetSet (C203 , C204) );
L264:
now
let C205 being (Element of C202);
let C206 being (Element of D41);
L265: C206 in D41;
consider C207 being (Coset of C204) such that L266: C207 = C206 by L265;
consider C208 being (Vector of C203) such that L267: C207 = ( C208 + C204 ) by VECTSP_4:def 6;
reconsider D42 = ( ( C205 * C208 ) + C204 ) as (Coset of C204) by VECTSP_4:def 6;
L268: D42 in D41;
reconsider D43 = D42 as (Element of D41) by L268;
take D44 = D43;
thus L269: S2[ C205 , C206 , D44 ]
proof
let C209 being (Vector of C203);
assume L270: C206 = ( C209 + C204 );
L271: C209 in ( C208 + C204 ) by L270 , L266 , L267 , VECTSP_4:44;
consider C210 being (Vector of C203) such that L272: (C210 in C204 & C209 = ( C208 + C210 )) by L271 , VECTSP_4:42;
L273: (( C205 * C209 ) = ( ( C205 * C208 ) + ( C205 * C210 ) ) & ( C205 * C210 ) in C204) by L272 , VECTSP_1:def 14 , VECTSP_4:21;
L274: ( C205 * C209 ) in ( ( C205 * C208 ) + C204 ) by L273;
L275: ( C205 * C209 ) in ( ( C205 * C209 ) + C204 ) by VECTSP_4:44;
thus L276: thesis by L275 , L274 , VECTSP_4:56;
end;

end;
consider C211 being (Function of [: D40 , D41 :] , D41) such that L270: (for B157 being (Element of C202) holds (for B158 being (Element of D41) holds S2[ B157 , B158 , ( C211 . (B157 , B158) ) ])) from BINOP_1:sch 3(L264);
take C211;
let C212 being (Element of C202);
let C213 being (Element of D41);
let C214 being (Vector of C203);
assume L271: C213 = ( C214 + C204 );
thus L272: thesis by L271 , L270;
end;
uniqueness
proof
set D45 = (the carrier of C202);
set D46 = ( CosetSet (C203 , C204) );
let C215 , C216 being (Function of [: D45 , D46 :] , D46);
assume that
L273: (for B159 being (Element of C202) holds (for B160 being (Element of ( CosetSet (C203 , C204) )) holds (for B161 being (Vector of C203) holds (B160 = ( B161 + C204 ) implies ( C215 . (B159 , B160) ) = ( ( B159 * B161 ) + C204 )))))
and
L274: (for B162 being (Element of C202) holds (for B163 being (Element of ( CosetSet (C203 , C204) )) holds (for B164 being (Vector of C203) holds (B163 = ( B164 + C204 ) implies ( C216 . (B162 , B163) ) = ( ( B162 * B164 ) + C204 )))));
set D47 = ( CosetSet (C203 , C204) );
L275:
now
let C217 being (Element of C202);
let C218 being (Element of ( CosetSet (C203 , C204) ));
L276: C218 in D47;
consider C219 being (Coset of C204) such that L277: C219 = C218 by L276;
consider C220 being (Vector of C203) such that L278: C219 = ( C220 + C204 ) by VECTSP_4:def 6;
thus L279: ( C215 . (C217 , C218) ) = ( ( C217 * C220 ) + C204 ) by L273 , L277 , L278
.= ( C216 . (C217 , C218) ) by L274 , L277 , L278;
end;
thus L280: thesis by L275 , BINOP_1:2;
end;
end;
definition
let C221 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C222 being (VectSp of C221);
let C223 being (Subspace of C222);
func VectQuot (C222 , C223) ->  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C221 means 
:L282: ((the carrier of it) = ( CosetSet (C222 , C223) ) & (the addF of it) = ( addCoset (C222 , C223) ) & ( 0. it ) = ( zeroCoset (C222 , C223) ) & (the lmult of it) = ( lmultCoset (C222 , C223) ));
existence
proof
set D48 = ( CosetSet (C222 , C223) );
set D49 = ( addCoset (C222 , C223) );
set D50 = ( zeroCoset (C222 , C223) );
set D51 = ( lmultCoset (C222 , C223) );
set D52 = VectSpStr (# D48 , D49 , D50 , D51 #);
L283: D52 is  right_zeroed
proof
let C224 being (Element of D52);
L284: C224 in D48;
consider C225 being (Coset of C223) such that L285: C224 = C225 by L284;
consider C226 being (Vector of C222) such that L286: C225 = ( C226 + C223 ) by VECTSP_4:def 6;
L287: ( 0. D52 ) = ( ( 0. C222 ) + C223 ) by VECTSP_4:45;
thus L288: ( C224 + ( 0. D52 ) ) = ( ( C226 + ( 0. C222 ) ) + C223 ) by L287 , L285 , L286 , L233
.= C224 by L285 , L286 , RLVECT_1:4;
end;
L289: D52 is  right_complementable
proof
let C227 being (Element of D52);
L290: ( 0. D52 ) = ( ( 0. C222 ) + C223 ) by VECTSP_4:45;
L291: C227 in D48;
consider C228 being (Coset of C223) such that L292: C227 = C228 by L291;
consider C229 being (Vector of C222) such that L293: C228 = ( C229 + C223 ) by VECTSP_4:def 6;
set D53 = ( ( - C229 ) + C223 );
L294: D53 is (Coset of C223) by VECTSP_4:def 6;
L295: D53 in D48 by L294;
reconsider D54 = D53 as (Element of D52) by L295;
take D54;
thus L296: ( C227 + D54 ) = ( ( C229 + ( - C229 ) ) + C223 ) by L292 , L293 , L233
.= ( 0. D52 ) by L290 , RLVECT_1:5;
end;
L297:
now
let C230 , C231 being (Element of C221);
let C232 , C233 being (Element of D52);
L298: C232 in D48;
consider C234 being (Coset of C223) such that L299: C232 = C234 by L298;
L300: C233 in D48;
consider C235 being (Coset of C223) such that L301: C233 = C235 by L300;
consider C236 being (Vector of C222) such that L302: C235 = ( C236 + C223 ) by VECTSP_4:def 6;
L303: (( D51 . (C230 , C233) ) = ( C230 * C233 ) & ( D51 . (C230 , C233) ) = ( ( C230 * C236 ) + C223 )) by L301 , L302 , L263;
consider C237 being (Vector of C222) such that L304: C234 = ( C237 + C223 ) by VECTSP_4:def 6;
L305: ( D49 . (C232 , C233) ) = ( ( C237 + C236 ) + C223 ) by L299 , L301 , L304 , L302 , L233;
L306: ( D51 . (C230 , C232) ) = ( ( C230 * C237 ) + C223 ) by L299 , L304 , L263;
thus L307: ( C230 * ( C232 + C233 ) ) = ( D51 . (C230 , ( (the addF of D52) . (C232 , C233) )) )
.= ( ( C230 * ( C237 + C236 ) ) + C223 ) by L305 , L263
.= ( ( ( C230 * C237 ) + ( C230 * C236 ) ) + C223 ) by VECTSP_1:def 14
.= ( ( C230 * C232 ) + ( C230 * C233 ) ) by L306 , L303 , L233;
L308: ( D51 . (C231 , C232) ) = ( ( C231 * C237 ) + C223 ) by L299 , L304 , L263;
thus L309: ( ( C230 + C231 ) * C232 ) = ( (the lmult of D52) . (( C230 + C231 ) , C232) )
.= ( ( ( C230 + C231 ) * C237 ) + C223 ) by L299 , L304 , L263
.= ( ( ( C230 * C237 ) + ( C231 * C237 ) ) + C223 ) by VECTSP_1:def 15
.= ( ( C230 * C232 ) + ( C231 * C232 ) ) by L306 , L308 , L233;
thus L310: ( ( C230 * C231 ) * C232 ) = ( (the lmult of D52) . (( C230 * C231 ) , C232) )
.= ( ( ( C230 * C231 ) * C237 ) + C223 ) by L299 , L304 , L263
.= ( ( C230 * ( C231 * C237 ) ) + C223 ) by VECTSP_1:def 16
.= ( D51 . (C230 , ( C231 * C232 )) ) by L308 , L263
.= ( C230 * ( C231 * C232 ) );
thus L311: ( ( 1_ C221 ) * C232 ) = ( (the lmult of D52) . (( 1_ C221 ) , C232) )
.= ( ( ( 1_ C221 ) * C237 ) + C223 ) by L299 , L304 , L263
.= C232 by L299 , L304 , VECTSP_1:def 17;
end;
L312: D52 is  Abelian
proof
let C238 , C239 being (Element of D52);
L313: C238 in D48;
consider C240 being (Coset of C223) such that L314: C238 = C240 by L313;
consider C241 being (Vector of C222) such that L315: C240 = ( C241 + C223 ) by VECTSP_4:def 6;
L316: C239 in D48;
consider C242 being (Coset of C223) such that L317: C239 = C242 by L316;
consider C243 being (Vector of C222) such that L318: C242 = ( C243 + C223 ) by VECTSP_4:def 6;
thus L319: ( C238 + C239 ) = ( ( C241 + C243 ) + C223 ) by L314 , L317 , L315 , L318 , L233
.= ( C239 + C238 ) by L314 , L317 , L315 , L318 , L233;
end;
L320: D52 is  add-associative
proof
let C244 , C245 , C246 being (Element of D52);
L321: C244 in D48;
consider C247 being (Coset of C223) such that L322: C244 = C247 by L321;
consider C248 being (Vector of C222) such that L323: C247 = ( C248 + C223 ) by VECTSP_4:def 6;
L324: C245 in D48;
consider C249 being (Coset of C223) such that L325: C245 = C249 by L324;
consider C250 being (Vector of C222) such that L326: C249 = ( C250 + C223 ) by VECTSP_4:def 6;
L327: C246 in D48;
consider C251 being (Coset of C223) such that L328: C246 = C251 by L327;
consider C252 being (Vector of C222) such that L329: C251 = ( C252 + C223 ) by VECTSP_4:def 6;
L330: ( D49 . (C245 , C246) ) = ( ( C250 + C252 ) + C223 ) by L325 , L328 , L326 , L329 , L233;
L331: ( D49 . (C244 , C245) ) = ( ( C248 + C250 ) + C223 ) by L322 , L325 , L323 , L326 , L233;
thus L332: ( ( C244 + C245 ) + C246 ) = ( ( ( C248 + C250 ) + C252 ) + C223 ) by L331 , L328 , L329 , L233
.= ( ( C248 + ( C250 + C252 ) ) + C223 ) by RLVECT_1:def 3
.= ( C244 + ( C245 + C246 ) ) by L322 , L323 , L330 , L233;
end;
reconsider D55 = D52 as  strict  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C221 by L320 , L312 , L283 , L289 , L297 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
take D55;
thus L333: thesis;
end;
uniqueness;
end;
theorem
L335: (for B165 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B166 being (VectSp of B165) holds (for B167 being (Subspace of B166) holds (( zeroCoset (B166 , B167) ) = ( ( 0. B166 ) + B167 ) & ( 0. ( VectQuot (B166 , B167) ) ) = ( zeroCoset (B166 , B167) )))))
proof
let C253 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C254 being (VectSp of C253);
let C255 being (Subspace of C254);
L336: (( 0. C254 ) = ( 0. C255 ) & ( 0. C255 ) in C255) by STRUCT_0:def 5 , VECTSP_4:11;
thus L337: ( zeroCoset (C254 , C255) ) = ( ( 0. C254 ) + C255 ) by L336 , VECTSP_4:49;
thus L338: thesis by L282;
end;
theorem
L339: (for B168 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B169 being (VectSp of B168) holds (for B170 being (Subspace of B169) holds (for B171 being (Vector of ( VectQuot (B169 , B170) )) holds (B171 is (Coset of B170) & (ex B172 being (Vector of B169) st B171 = ( B172 + B170 )))))))
proof
let C256 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C257 being (VectSp of C256);
let C258 being (Subspace of C257);
let C259 being (Vector of ( VectQuot (C257 , C258) ));
set D56 = ( VectQuot (C257 , C258) );
set D57 = ( CosetSet (C257 , C258) );
L340: D57 = (the carrier of D56) by L282;
L341: C259 in { B173 where B173 is (Coset of C258) : (not contradiction) } by L340;
L342: (ex B174 being (Coset of C258) st B174 = C259) by L341;
thus L343: thesis by L342 , VECTSP_4:def 6;
end;
theorem
L344: (for B175 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B176 being (VectSp of B175) holds (for B177 being (Subspace of B176) holds (for B178 being (Vector of B176) holds (( B178 + B177 ) is (Coset of B177) & ( B178 + B177 ) is (Vector of ( VectQuot (B176 , B177) )))))))
proof
let C260 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C261 being (VectSp of C260);
let C262 being (Subspace of C261);
let C263 being (Vector of C261);
set D58 = ( CosetSet (C261 , C262) );
thus L345: ( C263 + C262 ) is (Coset of C262) by VECTSP_4:def 6;
L346: ( C263 + C262 ) in D58 by L345;
thus L347: thesis by L346 , L282;
end;
theorem
L348: (for B179 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B180 being (VectSp of B179) holds (for B181 being (Subspace of B180) holds (for B182 being (Coset of B181) holds B182 is (Vector of ( VectQuot (B180 , B181) ))))))
proof
let C264 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C265 being (VectSp of C264);
let C266 being (Subspace of C265);
let C267 being (Coset of C266);
set D59 = ( CosetSet (C265 , C266) );
L349: C267 in D59;
thus L350: thesis by L349 , L282;
end;
theorem
L351: (for B183 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B184 being (VectSp of B183) holds (for B185 being (Subspace of B184) holds (for B186 being (Vector of ( VectQuot (B184 , B185) )) holds (for B187 being (Vector of B184) holds (for B188 being (Scalar of B184) holds (B186 = ( B187 + B185 ) implies ( B188 * B186 ) = ( ( B188 * B187 ) + B185 ))))))))
proof
let C268 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C269 being (VectSp of C268);
let C270 being (Subspace of C269);
set D60 = ( VectQuot (C269 , C270) );
set D61 = (the lmult of D60);
let C271 being (Vector of D60);
let C272 being (Vector of C269);
let C273 being (Scalar of C269);
assume L352: C271 = ( C272 + C270 );
L353: C271 is (Coset of C270) by L339;
L354: C271 in { B189 where B189 is (Coset of C270) : (not contradiction) } by L353;
reconsider D62 = C271 as (Element of ( CosetSet (C269 , C270) )) by L354;
thus L355: ( C273 * C271 ) = ( D61 . (C273 , C271) )
.= ( ( lmultCoset (C269 , C270) ) . (C273 , D62) ) by L282
.= ( ( C273 * C272 ) + C270 ) by L352 , L263;
end;
theorem
L356: (for B190 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B191 being (VectSp of B190) holds (for B192 being (Subspace of B191) holds (for B193 , B194 being (Vector of ( VectQuot (B191 , B192) )) holds (for B195 , B196 being (Vector of B191) holds ((B193 = ( B195 + B192 ) & B194 = ( B196 + B192 )) implies ( B193 + B194 ) = ( ( B195 + B196 ) + B192 )))))))
proof
let C274 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C275 being (VectSp of C274);
let C276 being (Subspace of C275);
set D63 = ( VectQuot (C275 , C276) );
let C277 , C278 being (Vector of D63);
let C279 , C280 being (Vector of C275);
assume L357: (C277 = ( C279 + C276 ) & C278 = ( C280 + C276 ));
L358: C278 is (Coset of C276) by L339;
L359: C278 in { B197 where B197 is (Coset of C276) : (not contradiction) } by L358;
L360: C277 is (Coset of C276) by L339;
L361: C277 in { B198 where B198 is (Coset of C276) : (not contradiction) } by L360;
reconsider D64 = C277 , D65 = C278 as (Element of ( CosetSet (C275 , C276) )) by L361 , L359;
thus L362: ( C277 + C278 ) = ( ( addCoset (C275 , C276) ) . (D64 , D65) ) by L282
.= ( ( C279 + C280 ) + C276 ) by L357 , L233;
end;
begin
theorem
L363: (for B199 being Field holds (for B200 being (VectSp of B199) holds (for B201 being (Subspace of B200) holds (for B202 being (linear-Functional of B201) holds (for B203 being (Vector of B200) holds (for B204 being (Vector of ( B201 + ( Lin { B203 } ) )) holds ((B203 = B204 & (not B203 in B201)) implies (for B205 being (Element of B199) holds (ex B206 being (linear-Functional of ( B201 + ( Lin { B203 } ) )) st (( B206 | (the carrier of B201) ) = B202 & ( B206 . B204 ) = B205))))))))))
proof
let C281 being Field;
let C282 being (VectSp of C281);
let C283 being (Subspace of C282);
let C284 being (linear-Functional of C283);
let C285 being (Vector of C282);
let C286 being (Vector of ( C283 + ( Lin { C285 } ) ));
assume that
L364: C285 = C286
and
L365: (not C285 in C283);
reconsider D66 = C283 as (Subspace of ( C283 + ( Lin { C285 } ) )) by VECTSP_5:7;
let C287 being (Element of C281);
defpred S3[ (Element of ( C283 + ( Lin { C285 } ) )) , (Element of C281) ] means (for B207 being (Vector of C283) holds (for B208 being (Element of C281) holds ((( ( $1 |-- (D66 , ( Lin { C286 } )) ) `1 ) = B207 & ( ( $1 |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( B208 * C285 )) implies $2 = ( ( C284 . B207 ) + ( B208 * C287 ) ))));
L366: (for B209 being (Element of ( C283 + ( Lin { C285 } ) )) holds (ex B210 being (Element of C281) st S3[ B209 , B210 ]))
proof
let C288 being (Element of ( C283 + ( Lin { C285 } ) ));
consider C289 being (Vector of C283), C290 being (Element of C281) such that L367: ( C288 |-- (D66 , ( Lin { C286 } )) ) = [ C289 , ( C290 * C285 ) ] by L364 , L365 , L182;
take ( ( C284 . C289 ) + ( C290 * C287 ) );
let C291 being (Vector of C283);
let C292 being (Element of C281);
assume that
L368: ( ( C288 |-- (D66 , ( Lin { C286 } )) ) `1 ) = C291
and
L369: ( ( C288 |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( C292 * C285 );
L370: C285 <> ( 0. C282 ) by L365 , VECTSP_4:17;
L371: C292 = C290 by L370 , L367 , L369 , L66 , MCART_1:7;
thus L372: thesis by L371 , L367 , L368 , MCART_1:7;
end;
consider C293 being (Function of (the carrier of ( C283 + ( Lin { C285 } ) )) , (the carrier of C281)) such that L373: (for B211 being (Element of ( C283 + ( Lin { C285 } ) )) holds S3[ B211 , ( C293 . B211 ) ]) from FUNCT_2:sch 3(L366);
L374:
now
let C294 being set;
assume L375: C294 in ( dom C284 );
reconsider D67 = C294 as (Vector of C283) by L375;
L376: C283 is (Subspace of ( C283 + ( Lin { C285 } ) )) by VECTSP_5:7;
L377: (the carrier of C283) c= (the carrier of ( C283 + ( Lin { C285 } ) )) by L376 , VECTSP_4:def 2;
reconsider D68 = D67 as (Vector of ( C283 + ( Lin { C285 } ) )) by L377 , TARSKI:def 3;
L378: D68 in C283 by STRUCT_0:def 5;
L379: ( D68 |-- (D66 , ( Lin { C286 } )) ) = [ D68 , ( 0. C282 ) ] by L378 , L364 , L365 , L172
.= [ D68 , ( ( 0. C281 ) * C285 ) ] by L34;
L380: (( ( D68 |-- (D66 , ( Lin { C286 } )) ) `1 ) = D67 & ( ( D68 |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( ( 0. C281 ) * C285 )) by L379 , MCART_1:7;
thus L381: ( C284 . C294 ) = ( ( C284 . D67 ) + ( 0. C281 ) ) by RLVECT_1:4
.= ( ( C284 . D67 ) + ( ( 0. C281 ) * C287 ) ) by VECTSP_1:7
.= ( C293 . C294 ) by L373 , L380;
end;
reconsider D69 = C293 as (Functional of ( C283 + ( Lin { C285 } ) ));
L382: ( C286 |-- (D66 , ( Lin { C286 } )) ) = [ ( 0. D66 ) , C286 ] by L364 , L365 , L167;
L383: ( ( C286 |-- (D66 , ( Lin { C286 } )) ) `1 ) = ( 0. C283 ) by L382 , MCART_1:7;
L384: D69 is  additive
proof
let C295 , C296 being (Vector of ( C283 + ( Lin { C285 } ) ));
consider C297 being (Vector of C283), C298 being (Element of C281) such that L385: ( C295 |-- (D66 , ( Lin { C286 } )) ) = [ C297 , ( C298 * C285 ) ] by L364 , L365 , L182;
L386: (( ( C295 |-- (D66 , ( Lin { C286 } )) ) `1 ) = C297 & ( ( C295 |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( C298 * C285 )) by L385 , MCART_1:7;
consider C299 being (Vector of C283), C300 being (Element of C281) such that L387: ( C296 |-- (D66 , ( Lin { C286 } )) ) = [ C299 , ( C300 * C285 ) ] by L364 , L365 , L182;
L388: (( ( C296 |-- (D66 , ( Lin { C286 } )) ) `1 ) = C299 & ( ( C296 |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( C300 * C285 )) by L387 , MCART_1:7;
L389: ( ( C295 + C296 ) |-- (D66 , ( Lin { C286 } )) ) = [ ( C297 + C299 ) , ( ( C298 + C300 ) * C285 ) ] by L364 , L365 , L385 , L387 , L192;
L390: (( ( ( C295 + C296 ) |-- (D66 , ( Lin { C286 } )) ) `1 ) = ( C297 + C299 ) & ( ( ( C295 + C296 ) |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( ( C298 + C300 ) * C285 )) by L389 , MCART_1:7;
thus L391: ( D69 . ( C295 + C296 ) ) = ( ( C284 . ( C297 + C299 ) ) + ( ( C298 + C300 ) * C287 ) ) by L390 , L373
.= ( ( C284 . ( C297 + C299 ) ) + ( ( C298 * C287 ) + ( C300 * C287 ) ) ) by VECTSP_1:def 3
.= ( ( ( C284 . C297 ) + ( C284 . C299 ) ) + ( ( C298 * C287 ) + ( C300 * C287 ) ) ) by VECTSP_1:def 20
.= ( ( ( ( C284 . C297 ) + ( C284 . C299 ) ) + ( C298 * C287 ) ) + ( C300 * C287 ) ) by RLVECT_1:def 3
.= ( ( ( ( C284 . C297 ) + ( C298 * C287 ) ) + ( C284 . C299 ) ) + ( C300 * C287 ) ) by RLVECT_1:def 3
.= ( ( ( C284 . C297 ) + ( C298 * C287 ) ) + ( ( C284 . C299 ) + ( C300 * C287 ) ) ) by RLVECT_1:def 3
.= ( ( D69 . C295 ) + ( ( C284 . C299 ) + ( C300 * C287 ) ) ) by L373 , L386
.= ( ( D69 . C295 ) + ( D69 . C296 ) ) by L373 , L388;
end;
L392: D69 is  homogeneous
proof
let C301 being (Vector of ( C283 + ( Lin { C285 } ) ));
let C302 being (Element of C281);
consider C303 being (Vector of C283), C304 being (Element of C281) such that L393: ( C301 |-- (D66 , ( Lin { C286 } )) ) = [ C303 , ( C304 * C285 ) ] by L364 , L365 , L182;
L394: (( ( C301 |-- (D66 , ( Lin { C286 } )) ) `1 ) = C303 & ( ( C301 |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( C304 * C285 )) by L393 , MCART_1:7;
L395: ( ( C302 * C301 ) |-- (D66 , ( Lin { C286 } )) ) = [ ( C302 * C303 ) , ( ( C302 * C304 ) * C285 ) ] by L364 , L365 , L393 , L212;
L396: (( ( ( C302 * C301 ) |-- (D66 , ( Lin { C286 } )) ) `1 ) = ( C302 * C303 ) & ( ( ( C302 * C301 ) |-- (D66 , ( Lin { C286 } )) ) `2 ) = ( ( C302 * C304 ) * C285 )) by L395 , MCART_1:7;
thus L397: ( D69 . ( C302 * C301 ) ) = ( ( C284 . ( C302 * C303 ) ) + ( ( C302 * C304 ) * C287 ) ) by L396 , L373
.= ( ( C302 * ( C284 . C303 ) ) + ( ( C302 * C304 ) * C287 ) ) by HAHNBAN1:def 8
.= ( ( C302 * ( C284 . C303 ) ) + ( C302 * ( C304 * C287 ) ) ) by GROUP_1:def 3
.= ( C302 * ( ( C284 . C303 ) + ( C304 * C287 ) ) ) by VECTSP_1:def 2
.= ( C302 * ( D69 . C301 ) ) by L373 , L394;
end;
reconsider D70 = D69 as (linear-Functional of ( C283 + ( Lin { C285 } ) )) by L392 , L384;
take D70;
L398: ( dom C284 ) = (the carrier of C283) by FUNCT_2:def 1;
L399: (( dom D70 ) = (the carrier of ( C283 + ( Lin { C285 } ) )) & C283 is (Subspace of ( C283 + ( Lin { C285 } ) ))) by FUNCT_2:def 1 , VECTSP_5:7;
L400: ( dom C284 ) c= ( dom D70 ) by L399 , L398 , VECTSP_4:def 2;
L401: ( dom C284 ) = ( ( dom D70 ) /\ (the carrier of C283) ) by L400 , L398 , XBOOLE_1:28;
thus L402: ( D70 | (the carrier of C283) ) = C284 by L401 , L374 , FUNCT_1:46;
L403: ( ( C286 |-- (D66 , ( Lin { C286 } )) ) `2 ) = C286 by L382 , MCART_1:7
.= ( ( 1_ C281 ) * C285 ) by L364 , VECTSP_1:def 17;
thus L404: ( D70 . C286 ) = ( ( C284 . ( 0. C283 ) ) + ( ( 1_ C281 ) * C287 ) ) by L403 , L373 , L383
.= ( ( 0. C281 ) + ( ( 1_ C281 ) * C287 ) ) by HAHNBAN1:def 9
.= ( ( 0. C281 ) + C287 ) by VECTSP_1:def 8
.= C287 by RLVECT_1:4;
end;
registration
let C305 being  right_zeroed non  empty addLoopStr;
let C306 being non  empty VectSpStr over C305;
cluster  additive  0-preserving for (Functional of C306);
existence
proof
take ( 0Functional C306 );
thus L405: thesis;
end;
end;
registration
let C307 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C308 being  right_zeroed non  empty VectSpStr over C307;
cluster  additive ->  0-preserving for (Functional of C308);
coherence
proof
let C309 being (Functional of C308);
assume L407: C309 is  additive;
L408: ( C309 . ( 0. C308 ) ) = ( C309 . ( ( 0. C308 ) + ( 0. C308 ) ) ) by RLVECT_1:def 4
.= ( ( C309 . ( 0. C308 ) ) + ( C309 . ( 0. C308 ) ) ) by L407 , VECTSP_1:def 20;
thus L409: ( C309 . ( 0. C308 ) ) = ( 0. C307 ) by L408 , RLVECT_1:9;
end;
end;
registration
let C310 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C311 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C310;
cluster  homogeneous ->  0-preserving for (Functional of C311);
coherence
proof
let C312 being (Functional of C311);
assume L411: C312 is  homogeneous;
thus L412: ( C312 . ( 0. C311 ) ) = ( C312 . ( ( 0. C310 ) * ( 0. C311 ) ) ) by L34
.= ( ( 0. C310 ) * ( C312 . ( 0. C311 ) ) ) by L411 , HAHNBAN1:def 8
.= ( 0. C310 ) by VECTSP_1:7;
end;
end;
registration
let C313 being non  empty ZeroStr;
let C314 being non  empty VectSpStr over C313;
cluster ( 0Functional C314 ) ->  constant;
coherence
proof
let C315 , C316 being set;
set D71 = ( 0Functional C314 );
assume L414: (C315 in ( dom D71 ) & C316 in ( dom D71 ));
reconsider D72 = C315 , D73 = C316 as (Vector of C314) by L414;
thus L415: ( D71 . C315 ) = ( D71 . D72 )
.= ( 0. C313 ) by HAHNBAN1:14
.= ( D71 . D73 ) by HAHNBAN1:14
.= ( D71 . C316 );
end;
end;
registration
let C317 being non  empty ZeroStr;
let C318 being non  empty VectSpStr over C317;
cluster  constant for (Functional of C318);
existence
proof
take ( 0Functional C318 );
thus L417: thesis;
end;
end;
definition
let C319 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C320 being  right_zeroed non  empty VectSpStr over C319;
let C321 being  0-preserving (Functional of C320);
redefine attr C321 is  constant
means
:L419: C321 = ( 0Functional C320 );
compatibility
proof
L420: (( C321 . ( 0. C320 ) ) = ( 0. C319 ) & (the carrier of C320) = ( dom C321 )) by FUNCT_2:def 1 , HAHNBAN1:def 9;
thus L421:now
assume L422: C321 is  constant;
L423:
now
let C322 being (Vector of C320);
thus L424: ( C321 . C322 ) = ( 0. C319 ) by L420 , L422 , FUNCT_1:def 10
.= ( ( 0Functional C320 ) . C322 ) by HAHNBAN1:14;
end;
thus L425: C321 = ( 0Functional C320 ) by L423 , FUNCT_2:63;
end;
assume L426: C321 = ( 0Functional C320 );
L427:
now
let C323 , C324 being set;
assume L428: (C323 in ( dom C321 ) & C324 in ( dom C321 ));
reconsider D74 = C323 , D75 = C324 as (Vector of C320) by L428;
thus L429: ( C321 . C323 ) = ( ( 0Functional C320 ) . D74 ) by L426
.= ( 0. C319 ) by HAHNBAN1:14
.= ( ( 0Functional C320 ) . D75 ) by HAHNBAN1:14
.= ( C321 . C324 ) by L426;
end;
thus L430: thesis by L427 , FUNCT_1:def 10;
end;
end;
registration
let C325 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
let C326 being  right_zeroed non  empty VectSpStr over C325;
cluster  constant  additive  0-preserving for (Functional of C326);
existence
proof
take ( 0Functional C326 );
thus L432: thesis;
end;
end;
registration
let C327 being Field;
let C328 being non  trivial (VectSp of C327);
cluster  additive  homogeneous non  constant non  trivial for (Functional of C328);
existence
proof
consider C329 being (Vector of C328) such that L434: C329 <> ( 0. C328 ) by STRUCT_0:def 18;
set D76 = the (Linear_Compl of ( Lin ({ C329 } qua (Subset of C328)) ));
L435: C328 is_the_direct_sum_of D76 , ( Lin { C329 } ) by VECTSP_5:def 5;
L436: ( the VectSpStr of C328 ) = ( D76 + ( Lin { C329 } ) ) by L435 , VECTSP_5:def 4;
reconsider D77 = C329 as (Vector of ( D76 + ( Lin { C329 } ) )) by L436;
L437: ( D76 /\ ( Lin { C329 } ) ) = ( (0). C328 ) by L435 , VECTSP_5:def 4;
L438:
now
L439: C329 in { C329 } by TARSKI:def 1;
L440: C329 in ( Lin { C329 } ) by L439 , VECTSP_7:8;
L441: C329 in (the carrier of ( Lin { C329 } )) by L440 , STRUCT_0:def 5;
assume L442: C329 in D76;
L443: C329 in (the carrier of D76) by L442 , STRUCT_0:def 5;
L444: C329 in ( (the carrier of D76) /\ (the carrier of ( Lin { C329 } )) ) by L443 , L441 , XBOOLE_0:def 4;
L445: C329 in (the carrier of ( D76 /\ ( Lin { C329 } ) )) by L444 , VECTSP_5:def 2;
L446: C329 in { ( 0. C328 ) } by L445 , L437 , VECTSP_4:def 3;
thus L447: contradiction by L446 , L434 , TARSKI:def 1;
end;
consider C330 being (linear-Functional of ( D76 + ( Lin { C329 } ) )) such that L448: ( C330 | (the carrier of D76) ) = ( 0Functional D76 ) and L449: ( C330 . D77 ) = ( 1_ C327 ) by L438 , L363;
reconsider D78 = C330 as (Functional of C328) by L436;
take D78;
thus L450: D78 is  additive
proof
let C331 , C332 being (Vector of C328);
reconsider D79 = C331 , D80 = C332 as (Vector of ( D76 + ( Lin { C329 } ) )) by L436;
L451: ( C331 + C332 ) = ( D79 + D80 ) by L436;
thus L452: thesis by L451 , VECTSP_1:def 20;
end;

thus L453: D78 is  homogeneous
proof
let C333 being (Vector of C328);
let C334 being (Element of C327);
reconsider D81 = C333 as (Vector of ( D76 + ( Lin { C329 } ) )) by L436;
L454: ( C334 * C333 ) = ( (the lmult of ( D76 + ( Lin { C329 } ) )) . (C334 , D81) ) by L436
.= ( C334 * D81 );
thus L455: thesis by L454 , HAHNBAN1:def 8;
end;

reconsider D82 = D78 as  homogeneous (Functional of C328) by L453;
thus L456: D78 is non  constant
proof
L457: ((the carrier of C328) = ( dom D78 ) & ( D82 . ( 0. C328 ) ) = ( 0. C327 )) by FUNCT_2:def 1 , HAHNBAN1:def 9;
assume L458: D78 is  constant;
thus L459: contradiction by L458 , L449 , L457 , FUNCT_1:def 10;
end;

thus L460: D78 is non  trivial
proof
set D83 = [ C329 , ( 1_ C327 ) ];
set D84 = [ ( 0. C328 ) , ( 0. C327 ) ];
L461: (the carrier of C328) = ( dom D78 ) by FUNCT_2:def 1;
L462: D83 in D78 by L461 , L449 , FUNCT_1:1;
L463: ( D82 . ( 0. C328 ) ) = ( 0. C327 ) by HAHNBAN1:def 9;
L464: D84 in D78 by L463 , L461 , FUNCT_1:1;
assume L465: D78 is  trivial;
per cases  by L465 , ZFMISC_1:131;
suppose L466: D78 = ( {} );

thus L467: contradiction by L466;
end;
suppose L468: (ex B212 being set st D78 = { B212 });

consider C335 being set such that L469: D78 = { C335 } by L468;
L470: (C335 = D83 & C335 = D84) by L462 , L464 , L469 , TARSKI:def 1;
thus L471: contradiction by L470 , XTUPLE_0:1;
end;
end;

end;
end;
registration
let C336 being Field;
let C337 being non  trivial (VectSp of C336);
cluster  trivial ->  constant for (Functional of C337);
coherence;
end;
definition
let C338 being Field;
let C339 being non  trivial (VectSp of C338);
let C340 being (Vector of C339);
let C341 being (Linear_Compl of ( Lin { C340 } ));
assume L463: C340 <> ( 0. C339 );
func coeffFunctional (C340 , C341) -> non  constant non  trivial (linear-Functional of C339) means 
:L464: (( it . C340 ) = ( 1_ C338 ) & ( it | (the carrier of C341) ) = ( 0Functional C341 ));
existence
proof
L465: C339 is_the_direct_sum_of C341 , ( Lin { C340 } ) by VECTSP_5:def 5;
L466: ( the VectSpStr of C339 ) = ( C341 + ( Lin { C340 } ) ) by L465 , VECTSP_5:def 4;
reconsider D85 = C340 as (Vector of ( C341 + ( Lin { C340 } ) )) by L466;
L467: ( C341 /\ ( Lin { C340 } ) ) = ( (0). C339 ) by L465 , VECTSP_5:def 4;
L468:
now
L469: C340 in { C340 } by TARSKI:def 1;
L470: C340 in ( Lin { C340 } ) by L469 , VECTSP_7:8;
L471: C340 in (the carrier of ( Lin { C340 } )) by L470 , STRUCT_0:def 5;
assume L472: C340 in C341;
L473: C340 in (the carrier of C341) by L472 , STRUCT_0:def 5;
L474: C340 in ( (the carrier of C341) /\ (the carrier of ( Lin { C340 } )) ) by L473 , L471 , XBOOLE_0:def 4;
L475: C340 in (the carrier of ( C341 /\ ( Lin { C340 } ) )) by L474 , VECTSP_5:def 2;
L476: C340 in { ( 0. C339 ) } by L475 , L467 , VECTSP_4:def 3;
thus L477: contradiction by L476 , L463 , TARSKI:def 1;
end;
consider C342 being (linear-Functional of ( C341 + ( Lin { C340 } ) )) such that L478: ( C342 | (the carrier of C341) ) = ( 0Functional C341 ) and L479: ( C342 . D85 ) = ( 1_ C338 ) by L468 , L363;
reconsider D86 = C342 as (Functional of C339) by L466;
L480: D86 is  additive
proof
let C343 , C344 being (Vector of C339);
reconsider D87 = C343 , D88 = C344 as (Vector of ( C341 + ( Lin { C340 } ) )) by L466;
L481: ( C343 + C344 ) = ( D87 + D88 ) by L466;
thus L482: thesis by L481 , VECTSP_1:def 20;
end;
L483: D86 is  homogeneous
proof
let C345 being (Vector of C339);
let C346 being (Element of C338);
reconsider D89 = C345 as (Vector of ( C341 + ( Lin { C340 } ) )) by L466;
L484: ( C346 * C345 ) = ( (the lmult of ( C341 + ( Lin { C340 } ) )) . (C346 , D89) ) by L466
.= ( C346 * D89 );
thus L485: thesis by L484 , HAHNBAN1:def 8;
end;
reconsider D90 = D86 as (linear-Functional of C339) by L483 , L480;
L486: D90 is non  constant
proof
L487: ((the carrier of C339) = ( dom D90 ) & ( D90 . ( 0. C339 ) ) = ( 0. C338 )) by FUNCT_2:def 1 , HAHNBAN1:def 9;
assume L488: D90 is  constant;
thus L489: contradiction by L488 , L479 , L487 , FUNCT_1:def 10;
end;
reconsider D91 = D90 as non  constant non  trivial (linear-Functional of C339) by L486;
take D91;
thus L490: thesis by L478 , L479;
end;
uniqueness
proof
let C347 , C348 being non  constant non  trivial (linear-Functional of C339);
assume that
L491: ( C347 . C340 ) = ( 1_ C338 )
and
L492: ( C347 | (the carrier of C341) ) = ( 0Functional C341 )
and
L493: ( C348 . C340 ) = ( 1_ C338 )
and
L494: ( C348 | (the carrier of C341) ) = ( 0Functional C341 );
L495: C339 is_the_direct_sum_of C341 , ( Lin { C340 } ) by VECTSP_5:def 5;
L496: ( the VectSpStr of C339 ) = ( C341 + ( Lin { C340 } ) ) by L495 , VECTSP_5:def 4;
L497:
now
let C349 being (Vector of C339);
L498: C349 in ( C341 + ( Lin { C340 } ) ) by L496 , STRUCT_0:def 5;
consider C350 , C351 being (Vector of C339) such that L499: C350 in C341 and L500: C351 in ( Lin { C340 } ) and L501: C349 = ( C350 + C351 ) by L498 , VECTSP_5:1;
consider C352 being (Element of C338) such that L502: C351 = ( C352 * C340 ) by L500 , L46;
L503: C350 in (the carrier of C341) by L499 , STRUCT_0:def 5;
L504: ( C347 . C350 ) = ( ( C348 | (the carrier of C341) ) . C350 ) by L503 , L492 , L494 , FUNCT_1:49
.= ( C348 . C350 ) by L503 , FUNCT_1:49;
thus L505: ( C347 . C349 ) = ( ( C347 . C350 ) + ( C347 . ( C352 * C340 ) ) ) by L501 , L502 , VECTSP_1:def 20
.= ( ( C347 . C350 ) + ( C352 * ( C347 . C340 ) ) ) by HAHNBAN1:def 8
.= ( ( C347 . C350 ) + ( C348 . ( C352 * C340 ) ) ) by L491 , L493 , HAHNBAN1:def 8
.= ( C348 . C349 ) by L501 , L502 , L504 , VECTSP_1:def 20;
end;
thus L506: thesis by L497 , FUNCT_2:63;
end;
end;
theorem
L508: (for B213 being Field holds (for B214 being non  trivial (VectSp of B213) holds (for B215 being non  constant  0-preserving (Functional of B214) holds (ex B216 being (Vector of B214) st (B216 <> ( 0. B214 ) & ( B215 . B216 ) <> ( 0. B213 ))))))
proof
let C353 being Field;
let C354 being non  trivial (VectSp of C353);
let C355 being non  constant  0-preserving (Functional of C354);
L509: ( C355 . ( 0. C354 ) ) = ( 0. C353 ) by HAHNBAN1:def 9;
assume L510: (for B217 being (Vector of C354) holds (B217 <> ( 0. C354 ) implies ( C355 . B217 ) = ( 0. C353 )));
L511:
now
let C356 , C357 being set;
assume L512: (C356 in ( dom C355 ) & C357 in ( dom C355 ));
reconsider D92 = C356 , D93 = C357 as (Vector of C354) by L512;
thus L513: ( C355 . C356 ) = ( C355 . D92 )
.= ( 0. C353 ) by L510 , L509
.= ( C355 . D93 ) by L510 , L509
.= ( C355 . C357 );
end;
thus L514: contradiction by L511 , FUNCT_1:def 10;
end;
theorem
L515: (for B218 being Field holds (for B219 being non  trivial (VectSp of B218) holds (for B220 being (Vector of B219) holds (for B221 being (Scalar of B219) holds (for B222 being (Linear_Compl of ( Lin { B220 } )) holds (B220 <> ( 0. B219 ) implies ( ( coeffFunctional (B220 , B222) ) . ( B221 * B220 ) ) = B221))))))
proof
let C358 being Field;
let C359 being non  trivial (VectSp of C358);
let C360 being (Vector of C359);
let C361 being (Scalar of C359);
let C362 being (Linear_Compl of ( Lin { C360 } ));
assume L516: C360 <> ( 0. C359 );
set D94 = ( coeffFunctional (C360 , C362) );
thus L517: ( D94 . ( C361 * C360 ) ) = ( C361 * ( D94 . C360 ) ) by HAHNBAN1:def 8
.= ( C361 * ( 1_ C358 ) ) by L516 , L464
.= C361 by VECTSP_1:def 8;
end;
theorem
L518: (for B223 being Field holds (for B224 being non  trivial (VectSp of B223) holds (for B225 , B226 being (Vector of B224) holds (for B227 being (Linear_Compl of ( Lin { B225 } )) holds ((B225 <> ( 0. B224 ) & B226 in B227) implies ( ( coeffFunctional (B225 , B227) ) . B226 ) = ( 0. B223 ))))))
proof
let C363 being Field;
let C364 being non  trivial (VectSp of C363);
let C365 , C366 being (Vector of C364);
let C367 being (Linear_Compl of ( Lin { C365 } ));
assume that
L519: C365 <> ( 0. C364 )
and
L520: C366 in C367;
set D95 = ( coeffFunctional (C365 , C367) );
set D96 = (the carrier of C367);
reconsider D97 = C366 as (Vector of C367) by L520 , STRUCT_0:def 5;
L521: C366 in D96 by L520 , STRUCT_0:def 5;
thus L522: ( D95 . C366 ) = ( ( D95 | D96 ) . C366 ) by L521 , FUNCT_1:49
.= ( ( 0Functional C367 ) . D97 ) by L519 , L464
.= ( 0. C363 ) by HAHNBAN1:14;
end;
theorem
L523: (for B228 being Field holds (for B229 being non  trivial (VectSp of B228) holds (for B230 , B231 being (Vector of B229) holds (for B232 being (Scalar of B229) holds (for B233 being (Linear_Compl of ( Lin { B230 } )) holds ((B230 <> ( 0. B229 ) & B231 in B233) implies ( ( coeffFunctional (B230 , B233) ) . ( ( B232 * B230 ) + B231 ) ) = B232))))))
proof
let C368 being Field;
let C369 being non  trivial (VectSp of C368);
let C370 , C371 being (Vector of C369);
let C372 being (Scalar of C369);
let C373 being (Linear_Compl of ( Lin { C370 } ));
assume that
L524: C370 <> ( 0. C369 )
and
L525: C371 in C373;
set D98 = ( coeffFunctional (C370 , C373) );
thus L526: ( D98 . ( ( C372 * C370 ) + C371 ) ) = ( ( D98 . ( C372 * C370 ) ) + ( D98 . C371 ) ) by VECTSP_1:def 20
.= ( ( D98 . ( C372 * C370 ) ) + ( 0. C368 ) ) by L524 , L525 , L518
.= ( D98 . ( C372 * C370 ) ) by RLVECT_1:def 4
.= C372 by L524 , L515;
end;
theorem
L527: (for B234 being non  empty addLoopStr holds (for B235 being non  empty VectSpStr over B234 holds (for B236 , B237 being (Functional of B235) holds (for B238 being (Vector of B235) holds ( ( B236 - B237 ) . B238 ) = ( ( B236 . B238 ) - ( B237 . B238 ) )))))
proof
let C374 being non  empty addLoopStr;
let C375 being non  empty VectSpStr over C374;
let C376 , C377 being (Functional of C375);
let C378 being (Vector of C375);
thus L528: ( ( C376 - C377 ) . C378 ) = ( ( C376 . C378 ) + ( ( - C377 ) . C378 ) ) by HAHNBAN1:def 3
.= ( ( C376 . C378 ) - ( C377 . C378 ) ) by HAHNBAN1:def 4;
end;
registration
let C379 being Field;
let C380 being non  trivial (VectSp of C379);
cluster ( C380 *' ) -> non  trivial;
coherence
proof
set D99 = the non  constant (linear-Functional of C380);
L529: D99 <> ( 0Functional C380 );
reconsider D100 = D99 as (Element of ( C380 *' )) by HAHNBAN1:def 10;
assume L530: ( C380 *' ) is  trivial;
L531: D100 = ( 0. ( C380 *' ) ) by L530 , STRUCT_0:def 18;
thus L532: contradiction by L531 , L529 , HAHNBAN1:def 10;
end;
end;
begin
definition
let C381 being non  empty ZeroStr;
let C382 being non  empty VectSpStr over C381;
let C383 being (Functional of C382);
func ker C383 -> (Subset of C382) equals 
{ B239 where B239 is (Vector of C382) : ( C383 . B239 ) = ( 0. C381 ) };
coherence
proof
set D101 = { B240 where B240 is (Vector of C382) : ( C383 . B240 ) = ( 0. C381 ) };
L534: D101 c= (the carrier of C382)
proof
let C384 being set;
assume L535: C384 in D101;
L536: (ex B241 being (Vector of C382) st (B241 = C384 & ( C383 . B241 ) = ( 0. C381 ))) by L535;
thus L537: thesis by L536;
end;
thus L538: thesis by L534;
end;
end;
registration
let C385 being  right_zeroed non  empty addLoopStr;
let C386 being non  empty VectSpStr over C385;
let C387 being  0-preserving (Functional of C386);
cluster ( ker C387 ) -> non  empty;
coherence
proof
L540: ( C387 . ( 0. C386 ) ) = ( 0. C385 ) by HAHNBAN1:def 9;
L541: ( 0. C386 ) in ( ker C387 ) by L540;
thus L542: thesis by L541;
end;
end;
theorem
L544: (for B242 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr holds (for B243 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over B242 holds (for B244 being (linear-Functional of B243) holds ( ker B244 ) is  linearly-closed)))
proof
let C388 being  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive non  empty doubleLoopStr;
let C389 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over C388;
let C390 being (linear-Functional of C389);
set D102 = ( ker C390 );
thus L545: (for B245 , B246 being (Vector of C389) holds ((B245 in D102 & B246 in D102) implies ( B245 + B246 ) in D102))
proof
let C391 , C392 being (Vector of C389);
assume L546: (C391 in D102 & C392 in D102);
L547: ((ex B247 being (Vector of C389) st (B247 = C391 & ( C390 . B247 ) = ( 0. C388 ))) & (ex B248 being (Vector of C389) st (B248 = C392 & ( C390 . B248 ) = ( 0. C388 )))) by L546;
L548: ( C390 . ( C391 + C392 ) ) = ( ( 0. C388 ) + ( 0. C388 ) ) by L547 , VECTSP_1:def 20
.= ( 0. C388 ) by RLVECT_1:4;
thus L549: thesis by L548;
end;

let C393 being (Element of C388);
let C394 being (Vector of C389);
assume L550: C394 in D102;
L551: (ex B249 being (Vector of C389) st (B249 = C394 & ( C390 . B249 ) = ( 0. C388 ))) by L550;
L552: ( C390 . ( C393 * C394 ) ) = ( C393 * ( 0. C388 ) ) by L551 , HAHNBAN1:def 8
.= ( 0. C388 ) by VECTSP_1:6;
thus L553: thesis by L552;
end;
definition
let C395 being non  empty ZeroStr;
let C396 being non  empty VectSpStr over C395;
let C397 being (Functional of C396);
attr C397 is  degenerated
means
:L554: ( ker C397 ) <> { ( 0. C396 ) };
end;
registration
let C398 being non  degenerated non  empty doubleLoopStr;
let C399 being non  trivial VectSpStr over C398;
cluster non  degenerated  0-preserving -> non  constant for (Functional of C399);
coherence
proof
let C400 being (Functional of C399);
assume that
L556: C400 is non  degenerated
and
L557: C400 is  0-preserving
and
L558: C400 is  constant;
L559: ( C400 . ( 0. C399 ) ) = ( 0. C398 ) by L557 , HAHNBAN1:def 9;
L560:
now
assume L561: (for B250 being (Vector of C399) holds (B250 <> ( 0. C399 ) implies ( C400 . B250 ) = ( 0. C398 )));
L562: (the carrier of C399) c= ( ker C400 )
proof
let C401 being set;
assume L563: C401 in (the carrier of C399);
reconsider D103 = C401 as (Vector of C399) by L563;
per cases ;
suppose L564: D103 = ( 0. C399 );

thus L565: thesis by L564 , L559;
end;
suppose L566: D103 <> ( 0. C399 );

L567: ( C400 . D103 ) = ( 0. C398 ) by L566 , L561;
thus L568: thesis by L567;
end;
end;
L570: (the carrier of C399) = ( ker C400 ) by L562 , XBOOLE_0:def 10
.= { ( 0. C399 ) } by L556 , L554;
thus L571: contradiction by L570;
end;
L572: ( dom C400 ) = (the carrier of C399) by FUNCT_2:def 1;
thus L573: contradiction by L572 , L558 , L559 , L560 , FUNCT_1:def 10;
end;
end;
definition
let C402 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C403 being (VectSp of C402);
let C404 being (linear-Functional of C403);
func Ker C404 ->  strict non  empty (Subspace of C403) means 
:L575: (the carrier of it) = ( ker C404 );
existence by L544 , VECTSP_4:34;
uniqueness by VECTSP_4:29;
end;
definition
let C405 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C406 being (VectSp of C405);
let C407 being (Subspace of C406);
let C408 being  additive (Functional of C406);
assume L577: (the carrier of C407) c= ( ker C408 );
func QFunctional (C408 , C407) ->  additive (Functional of ( VectQuot (C406 , C407) )) means 
:L578: (for B251 being (Vector of ( VectQuot (C406 , C407) )) holds (for B252 being (Vector of C406) holds (B251 = ( B252 + C407 ) implies ( it . B251 ) = ( C408 . B252 ))));
existence
proof
defpred S4[ set , set ] means (for B253 being (Vector of C406) holds ($1 = ( B253 + C407 ) implies $2 = ( C408 . B253 )));
set D104 = ( addCoset (C406 , C407) );
set D105 = ( CosetSet (C406 , C407) );
set D106 = ( VectQuot (C406 , C407) );
L579:
now
let C409 being (Vector of D106);
consider C410 being (Vector of C406) such that L580: C409 = ( C410 + C407 ) by L339;
take D107 = ( C408 . C410 );
thus L581: S4[ C409 , D107 ]
proof
let C411 being (Vector of C406);
assume L582: C409 = ( C411 + C407 );
L583: C410 in ( C411 + C407 ) by L582 , L580 , VECTSP_4:44;
consider C412 being (Vector of C406) such that L584: C412 in C407 and L585: C410 = ( C411 + C412 ) by L583 , VECTSP_4:42;
L586: C412 in (the carrier of C407) by L584 , STRUCT_0:def 5;
L587: C412 in ( ker C408 ) by L586 , L577;
L588: (ex B254 being (Vector of C406) st (B254 = C412 & ( C408 . B254 ) = ( 0. C405 ))) by L587;
thus L589: D107 = ( ( C408 . C411 ) + ( C408 . C412 ) ) by L585 , VECTSP_1:def 20
.= ( C408 . C411 ) by L588 , RLVECT_1:def 4;
end;

end;
consider C413 being (Function of (the carrier of D106) , (the carrier of C405)) such that L582: (for B255 being (Vector of D106) holds S4[ B255 , ( C413 . B255 ) ]) from FUNCT_2:sch 3(L579);
reconsider D108 = C413 as (Functional of D106);
L583: D105 = (the carrier of D106) by L282;
L584:
now
L585: (the addF of D106) = ( addCoset (C406 , C407) ) by L282;
let C414 , C415 being (Vector of D106);
consider C416 being (Vector of C406) such that L586: C414 = ( C416 + C407 ) by L339;
consider C417 being (Vector of C406) such that L587: C415 = ( C417 + C407 ) by L339;
L588: ( D104 . (C414 , C415) ) = ( ( C416 + C417 ) + C407 ) by L583 , L586 , L587 , L233;
thus L589: ( D108 . ( C414 + C415 ) ) = ( C408 . ( C416 + C417 ) ) by L588 , L582 , L585
.= ( ( C408 . C416 ) + ( C408 . C417 ) ) by VECTSP_1:def 20
.= ( ( D108 . C414 ) + ( C408 . C417 ) ) by L582 , L586
.= ( ( D108 . C414 ) + ( D108 . C415 ) ) by L582 , L587;
end;
reconsider D109 = D108 as  additive (Functional of D106) by L584 , VECTSP_1:def 20;
take D109;
thus L590: thesis by L582;
end;
uniqueness
proof
set D110 = ( VectQuot (C406 , C407) );
let C418 , C419 being  additive (Functional of D110);
assume that
L591: (for B256 being (Vector of ( VectQuot (C406 , C407) )) holds (for B257 being (Vector of C406) holds (B256 = ( B257 + C407 ) implies ( C418 . B256 ) = ( C408 . B257 ))))
and
L592: (for B258 being (Vector of ( VectQuot (C406 , C407) )) holds (for B259 being (Vector of C406) holds (B258 = ( B259 + C407 ) implies ( C419 . B258 ) = ( C408 . B259 ))));
L593:
now
let C420 being (Vector of D110);
consider C421 being (Vector of C406) such that L594: C420 = ( C421 + C407 ) by L339;
thus L595: ( C418 . C420 ) = ( C408 . C421 ) by L591 , L594
.= ( C419 . C420 ) by L592 , L594;
end;
thus L596: thesis by L593 , FUNCT_2:63;
end;
end;
theorem
L598: (for B260 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B261 being (VectSp of B260) holds (for B262 being (Subspace of B261) holds (for B263 being (linear-Functional of B261) holds ((the carrier of B262) c= ( ker B263 ) implies ( QFunctional (B263 , B262) ) is  homogeneous)))))
proof
let C422 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C423 being (VectSp of C422);
let C424 being (Subspace of C423);
let C425 being (linear-Functional of C423);
set D111 = ( QFunctional (C425 , C424) );
set D112 = ( VectQuot (C423 , C424) );
assume L599: (the carrier of C424) c= ( ker C425 );
L600:
now
set D113 = ( CosetSet (C423 , C424) );
let C426 being (Vector of D112);
let C427 being (Scalar of D112);
L601: D113 = (the carrier of D112) by L282;
L602: C426 in D113 by L601;
consider C428 being (Coset of C424) such that L603: C426 = C428 by L602;
consider C429 being (Vector of C423) such that L604: C428 = ( C429 + C424 ) by VECTSP_4:def 6;
L605: ( C427 * C426 ) = ( (the lmult of D112) . (C427 , C426) )
.= ( ( lmultCoset (C423 , C424) ) . (C427 , C426) ) by L282
.= ( ( C427 * C429 ) + C424 ) by L601 , L603 , L604 , L263;
thus L606: ( D111 . ( C427 * C426 ) ) = ( C425 . ( C427 * C429 ) ) by L605 , L599 , L578
.= ( C427 * ( C425 . C429 ) ) by HAHNBAN1:def 8
.= ( C427 * ( D111 . C426 ) ) by L599 , L603 , L604 , L578;
end;
thus L607: thesis by L600 , HAHNBAN1:def 8;
end;
definition
let C430 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C431 being (VectSp of C430);
let C432 being (linear-Functional of C431);
func CQFunctional C432 -> (linear-Functional of ( VectQuot (C431 , ( Ker C432 )) )) equals 
( QFunctional (C432 , ( Ker C432 )) );
correctness
proof
L608: (the carrier of ( Ker C432 )) = ( ker C432 ) by L575;
thus L609: thesis by L608 , L598;
end;
end;
theorem
L611: (for B264 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for B265 being (VectSp of B264) holds (for B266 being (linear-Functional of B265) holds (for B267 being (Vector of ( VectQuot (B265 , ( Ker B266 )) )) holds (for B268 being (Vector of B265) holds (B267 = ( B268 + ( Ker B266 ) ) implies ( ( CQFunctional B266 ) . B267 ) = ( B266 . B268 )))))))
proof
let C433 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C434 being (VectSp of C433);
let C435 being (linear-Functional of C434);
let C436 being (Vector of ( VectQuot (C434 , ( Ker C435 )) ));
let C437 being (Vector of C434);
assume L612: C436 = ( C437 + ( Ker C435 ) );
L613: (the carrier of ( Ker C435 )) = ( ker C435 ) by L575;
thus L614: thesis by L613 , L612 , L578;
end;
registration
let C438 being Field;
let C439 being non  trivial (VectSp of C438);
let C440 being non  constant (linear-Functional of C439);
cluster ( CQFunctional C440 ) -> non  constant;
coherence
proof
set D114 = ( Ker C440 );
set D115 = ( CQFunctional C440 );
set D116 = ( VectQuot (C439 , D114) );
consider C441 being (Vector of C439) such that L615: C441 <> ( 0. C439 ) and L616: ( C440 . C441 ) <> ( 0. C438 ) by L508;
reconsider D117 = ( C441 + D114 ) as (Vector of D116) by L344;
assume L617: D115 is  constant;
L618: D115 = ( 0Functional D116 ) by L617 , L419;
L619: ( 0. C438 ) = ( D115 . D117 ) by L618 , HAHNBAN1:14
.= ( C440 . C441 ) by L611;
thus L620: contradiction by L619 , L616;
end;
end;
registration
let C442 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let C443 being (VectSp of C442);
let C444 being (linear-Functional of C443);
cluster ( CQFunctional C444 ) -> non  degenerated;
coherence
proof
set D118 = ( CQFunctional C444 );
set D119 = ( Ker C444 );
set D120 = ( VectQuot (C443 , D119) );
L622: (the carrier of D119) = ( ker C444 ) by L575;
L623: (the carrier of D120) = ( CosetSet (C443 , D119) ) by L282;
thus L624: ( ker D118 ) c= { ( 0. D120 ) }
proof
let C445 being set;
assume L625: C445 in ( ker D118 );
consider C446 being (Vector of D120) such that L626: C445 = C446 and L627: ( D118 . C446 ) = ( 0. C442 ) by L625;
L628: C446 in ( CosetSet (C443 , D119) ) by L623;
consider C447 being (Coset of D119) such that L629: C446 = C447 by L628;
consider C448 being (Vector of C443) such that L630: C447 = ( C448 + D119 ) by VECTSP_4:def 6;
L631: ( C444 . C448 ) = ( 0. C442 ) by L622 , L627 , L629 , L630 , L578;
L632: C448 in ( ker C444 ) by L631;
L633: C448 in D119 by L632 , L622 , STRUCT_0:def 5;
L634: C446 = ( zeroCoset (C443 , D119) ) by L633 , L629 , L630 , VECTSP_4:49
.= ( 0. D120 ) by L335;
thus L635: thesis by L634 , L626 , TARSKI:def 1;
end;

thus L636: { ( 0. D120 ) } c= ( ker D118 )
proof
let C449 being set;
assume L637: C449 in { ( 0. D120 ) };
L638: C449 = ( 0. D120 ) by L637 , TARSKI:def 1;
L639: ( D118 . ( 0. D120 ) ) = ( 0. C442 ) by HAHNBAN1:def 9;
thus L640: thesis by L639 , L638;
end;

end;
end;
