:: Another { \bf times } Macro Instruction
::  by Piotr Rudnicki
::
:: Received June 4, 1998
:: Copyright (c) 1998-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FSM_1, SCMFSA_2, SF_MASTR, AMI_1, SCMFSA7B, SUBSET_1,
      XBOOLE_0, CARD_1, UNIALG_2, SCMFSA6B, FUNCT_1, FUNCT_4, SCMFSA6A, TARSKI,
      RELAT_1, ARYTM_3, GRAPHSP, MSUALG_1, SFMASTR1, SCMFSA_9, AMI_3,
      CARD_3, XXREAL_0, ARYTM_1, SCMFSA9A, COMPLEX1, AOFA_I00, PRE_FF,
      SFMASTR2, NAT_1, EXTPRO_1, SCMFSA6C, COMPOS_1, MEMSTR_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_2, XXREAL_0,
      RELAT_1, FUNCT_1, FUNCT_2, FUNCT_4, PBOOLE, PRE_FF, CARD_3, FUNCOP_1,
      STRUCT_0, MEMSTR_0, AMISTD_1, COMPOS_1, EXTPRO_1, SCMFSA_2, SCMFSA6A,
      SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA_9, SFMASTR1, SCMFSA9A,
      ORDINAL1, NAT_1, SCMFSA_M;
 constructors XXREAL_0, INT_2, PRE_FF, SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA_9,
      SFMASTR1, SCMFSA9A, RELSET_1, PRE_POLY, PBOOLE, SCMFSA8A, SCMFSA7B,
      AMISTD_2, AMISTD_1, SCMFSA_7, FUNCT_4, MEMSTR_0, SCMFSA_1, SCMFSA_M,
      SF_MASTR;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA_9, SFMASTR1, XBOOLE_0, RELAT_1,
      FUNCT_2, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4, FUNCOP_1, STRUCT_0,
      SCMFSA6A, MEMSTR_0, FINSEQ_1, AMI_3, SCMFSA_M;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions SCMFSA9A, SUBSET_1, SCMFSA6A, COMPOS_1, EXTPRO_1, MEMSTR_0,
      SCMFSA_2, SCMFSA_M;
 theorems TARSKI, ZFMISC_1, ABSVALUE, NAT_1, INT_1, FUNCT_4, PRE_FF, SCMFSA_2,
      SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B, SCMFSA8B, SCMFSA8C, SCMFSA_9,
      SFMASTR1, SCMFSA9A, XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, EXTPRO_1,
      MEMSTR_0, CARD_3, SCMFSA_M;
 schemes FUNCT_2, NAT_1;

begin
set D1 = ( Data-Locations ( SCM+FSA ) );
theorem
L1: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R7 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((R10 is_closed_on ( Initialized R1 ) , R4 & R10 is_halting_on ( Initialized R1 ) , R4 & (not R7 in ( UsedIntLoc R10 ))) implies ( ( IExec (R10 , R4 , R1) ) . R7 ) = ( ( Initialized R1 ) . R7 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R7 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D2 = R7;
assume that
L2: R10 is_closed_on ( Initialized R1 ) , R4
and
L3: R10 is_halting_on ( Initialized R1 ) , R4
and
L4: (not D2 in ( UsedIntLoc R10 ));
set D3 = ( Initialized R1 );
set D4 = ( R4 +* R10 );
L5: ( R4 +* R10 ) halts_on ( Initialize D3 ) by L3 , SCMFSA7B:def 7;
L6: D3 = ( Initialize D3 ) by MEMSTR_0:44;
L7: (for R13 being (Element of ( NAT )) holds (R13 < ( LifeSpan (D4 , D3) ) implies ( IC ( Comput (D4 , D3 , R13) ) ) in ( dom R10 ))) by L2 , L6 , SCMFSA7B:def 6;
L8: ( ( Comput (D4 , D3 , ( LifeSpan (D4 , D3) )) ) . D2 ) = ( D3 . D2 ) by L7 , L4 , FUNCT_4:25 , SF_MASTR:61;
L9: ( DataPart ( IExec (R10 , R4 , R1) ) ) = ( DataPart ( Result (D4 , D3) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D4 , D3) ) )
.= ( DataPart ( Comput (D4 , D3 , ( LifeSpan (D4 , D3) )) ) ) by L6 , L5 , EXTPRO_1:23;
thus L10: thesis by L9 , L8 , SCMFSA_M:2;
end;
theorem
L11: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R9 being FinSeq-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((R10 is_closed_on ( Initialized R1 ) , R4 & R10 is_halting_on ( Initialized R1 ) , R4 & (not R9 in ( UsedInt*Loc R10 ))) implies ( ( IExec (R10 , R4 , R1) ) . R9 ) = ( ( Initialized R1 ) . R9 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R9 being FinSeq-Location;
let R10 being (Program of ( SCM+FSA ));
set D5 = R9;
assume that
L12: R10 is_closed_on ( Initialized R1 ) , R4
and
L13: R10 is_halting_on ( Initialized R1 ) , R4
and
L14: (not D5 in ( UsedInt*Loc R10 ));
set D6 = ( Initialized R1 );
set D7 = ( R4 +* R10 );
L15: ( R4 +* R10 ) halts_on ( Initialize D6 ) by L13 , SCMFSA7B:def 7;
L16: D6 = ( Initialize D6 ) by MEMSTR_0:44;
L17: (for R13 being (Element of ( NAT )) holds (R13 < ( LifeSpan (D7 , D6) ) implies ( IC ( Comput (D7 , D6 , R13) ) ) in ( dom R10 ))) by L12 , L16 , SCMFSA7B:def 6;
L18: ( ( Comput (D7 , D6 , ( LifeSpan (D7 , D6) )) ) . D5 ) = ( D6 . D5 ) by L17 , L14 , FUNCT_4:25 , SF_MASTR:63;
L19: ( DataPart ( IExec (R10 , R4 , R1) ) ) = ( DataPart ( Result (D7 , D6) ) ) by SCMFSA6B:def 1
.= ( DataPart ( Result (D7 , D6) ) )
.= ( DataPart ( Comput (D7 , D6 , ( LifeSpan (D7 , D6) )) ) ) by L16 , L15 , EXTPRO_1:23;
thus L20: thesis by L19 , L18 , SCMFSA_M:2;
end;
theorem
L21: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((((R10 is_closed_on ( Initialized R1 ) , R4 & R10 is_halting_on ( Initialized R1 ) , R4) or R10 is  parahalting) & (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write) & (not R6 in ( UsedIntLoc R10 ))) implies ( ( IExec (R10 , R4 , R1) ) . R6 ) = ( R1 . R6 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
assume that
L22: ((R10 is_closed_on ( Initialized R1 ) , R4 & R10 is_halting_on ( Initialized R1 ) , R4) or R10 is  parahalting)
and
L23: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write)
and
L24: (not R6 in ( UsedIntLoc R10 ));
L25: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L26: (R10 is_closed_on ( Initialized R1 ) , R4 & R10 is_halting_on ( Initialized R1 ) , R4) by L22 , SCMFSA7B:18 , SCMFSA7B:19;
thus L27: ( ( IExec (R10 , R4 , R1) ) . R6 ) = ( ( Initialized R1 ) . R6 ) by L26 , L24 , L1
.= ( R1 . R6 ) by L23 , L25 , SCMFSA_M:9 , SCMFSA_M:37;
end;
theorem
L28: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (Program of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies (R10 is_closed_on R1 , R4 iff R10 is_closed_on ( Initialized R1 ) , R4)))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (Program of ( SCM+FSA ));
assume L29: ( R1 . ( intloc ( 0 ) ) ) = 1;
L30: ( DataPart ( Initialized R1 ) ) = ( DataPart R1 ) by L29 , SCMFSA_M:19;
thus L31: thesis by L30 , SCMFSA8B:3;
end;
theorem
L32: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R10 being (Program of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies ((R10 is_closed_on R1 , R4 & R10 is_halting_on R1 , R4) iff (R10 is_closed_on ( Initialized R1 ) , R4 & R10 is_halting_on ( Initialized R1 ) , R4))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R10 being (Program of ( SCM+FSA ));
assume L33: ( R1 . ( intloc ( 0 ) ) ) = 1;
L34: ( DataPart ( Initialized R1 ) ) = ( DataPart R1 ) by L33 , SCMFSA_M:19;
thus L35: thesis by L34 , SCMFSA8B:5;
end;
begin
definition
let C1 being Int-Location;
let C2 being (Program of ( SCM+FSA ));
func times* (C1 , C2) -> (Program of ( SCM+FSA )) equals 
( while>0 (( 1 -stRWNotIn ( { C1 } \/ ( UsedIntLoc C2 ) ) ) , ( C2 ";" ( SubFrom (( 1 -stRWNotIn ( { C1 } \/ ( UsedIntLoc C2 ) ) ) , ( intloc ( 0 ) )) ) )) );
correctness;
end;
definition
let C3 being Int-Location;
let C4 being (Program of ( SCM+FSA ));
func times (C3 , C4) -> (Program of ( SCM+FSA )) equals 
( ( ( 1 -stRWNotIn ( { C3 } \/ ( UsedIntLoc C4 ) ) ) := C3 ) ";" ( times* (C3 , C4) ) );
correctness;
end;
notation
let C5 being Int-Location;
let C6 being (Program of ( SCM+FSA ));
synonym C5 times C6 for times (C5 , C6);
end;
canceled 2;
theorem
L39: (for R7 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ( { R7 } \/ ( UsedIntLoc R10 ) ) c= ( UsedIntLoc ( times (R7 , R10) ) )))
proof
let R7 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D8 = R7;
set D9 = ( 1 -stRWNotIn ( { D8 } \/ ( UsedIntLoc R10 ) ) );
L40: ( UsedIntLoc ( times (D8 , R10) ) ) = ( ( UsedIntLoc ( D9 := D8 ) ) \/ ( UsedIntLoc ( while>0 (D9 , ( R10 ";" ( SubFrom (D9 , ( intloc ( 0 ) )) ) )) ) ) ) by SF_MASTR:29
.= ( { D9 , D8 } \/ ( UsedIntLoc ( while>0 (D9 , ( R10 ";" ( SubFrom (D9 , ( intloc ( 0 ) )) ) )) ) ) ) by SF_MASTR:14
.= ( { D9 , D8 } \/ ( { D9 } \/ ( UsedIntLoc ( R10 ";" ( SubFrom (D9 , ( intloc ( 0 ) )) ) ) ) ) ) by SCMFSA9A:24
.= ( ( { D9 , D8 } \/ { D9 } ) \/ ( UsedIntLoc ( R10 ";" ( SubFrom (D9 , ( intloc ( 0 ) )) ) ) ) ) by XBOOLE_1:4
.= ( { D9 , D8 } \/ ( UsedIntLoc ( R10 ";" ( SubFrom (D9 , ( intloc ( 0 ) )) ) ) ) ) by ZFMISC_1:9
.= ( { D9 , D8 } \/ ( ( UsedIntLoc R10 ) \/ ( UsedIntLoc ( SubFrom (D9 , ( intloc ( 0 ) )) ) ) ) ) by SF_MASTR:30
.= ( { D9 , D8 } \/ ( ( UsedIntLoc R10 ) \/ { D9 , ( intloc ( 0 ) ) } ) ) by SF_MASTR:14
.= ( ( { D9 , D8 } \/ ( UsedIntLoc R10 ) ) \/ { D9 , ( intloc ( 0 ) ) } ) by XBOOLE_1:4;
L41: ( { D9 , D8 } \/ ( UsedIntLoc R10 ) ) c= ( UsedIntLoc ( times (D8 , R10) ) ) by L40 , XBOOLE_1:7;
L42: ( UsedIntLoc R10 ) c= ( { D9 , D8 } \/ ( UsedIntLoc R10 ) ) by XBOOLE_1:7;
L43: ( UsedIntLoc R10 ) c= ( UsedIntLoc ( times (D8 , R10) ) ) by L42 , L41 , XBOOLE_1:1;
L44: ({ D8 } c= { D9 , D8 } & { D9 , D8 } c= ( { D9 , D8 } \/ ( UsedIntLoc R10 ) )) by XBOOLE_1:7 , ZFMISC_1:7;
L45: { D8 } c= ( { D9 , D8 } \/ ( UsedIntLoc R10 ) ) by L44 , XBOOLE_1:1;
L46: { D8 } c= ( UsedIntLoc ( times (D8 , R10) ) ) by L45 , L41 , XBOOLE_1:1;
thus L47: thesis by L46 , L43 , XBOOLE_1:8;
end;
theorem
L48: (for R7 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( times (R7 , R10) ) ) = ( UsedInt*Loc R10 )))
proof
let R7 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D10 = R7;
set D11 = ( 1 -stRWNotIn ( { D10 } \/ ( UsedIntLoc R10 ) ) );
thus L49: ( UsedInt*Loc ( times (D10 , R10) ) ) = ( ( UsedInt*Loc ( D11 := D10 ) ) \/ ( UsedInt*Loc ( while>0 (D11 , ( R10 ";" ( SubFrom (D11 , ( intloc ( 0 ) )) ) )) ) ) ) by SF_MASTR:45
.= ( ( {} ) \/ ( UsedInt*Loc ( while>0 (D11 , ( R10 ";" ( SubFrom (D11 , ( intloc ( 0 ) )) ) )) ) ) ) by SF_MASTR:32
.= ( UsedInt*Loc ( R10 ";" ( SubFrom (D11 , ( intloc ( 0 ) )) ) ) ) by SCMFSA9A:25
.= ( ( UsedInt*Loc R10 ) \/ ( UsedInt*Loc ( SubFrom (D11 , ( intloc ( 0 ) )) ) ) ) by SF_MASTR:46
.= ( ( UsedInt*Loc R10 ) \/ ( {} ) ) by SF_MASTR:32
.= ( UsedInt*Loc R10 );
end;
registration
let C7 being  good (Program of ( SCM+FSA ));
let C8 being Int-Location;
cluster ( times (C8 , C7) ) ->  good;
coherence;
end;
definition
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let C9 being (State of ( SCM+FSA ));
let C10 being (Program of ( SCM+FSA ));
let C11 being Int-Location;
func StepTimes (C11 , C10 , R4 , C9) -> (Function of ( NAT ) , ( product ( the_Values_of ( SCM+FSA ) ) )) equals 
( StepWhile>0 (( 1 -stRWNotIn ( { C11 } \/ ( UsedIntLoc C10 ) ) ) , ( C10 ";" ( SubFrom (( 1 -stRWNotIn ( { C11 } \/ ( UsedIntLoc C10 ) ) ) , ( intloc ( 0 ) )) ) ) , R4 , ( Exec (( ( 1 -stRWNotIn ( { C11 } \/ ( UsedIntLoc C10 ) ) ) := C11 ) , ( Initialized C9 )) )) );
correctness;
end;
theorem
L52: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . ( 0 ) ) . ( intloc ( 0 ) ) ) = 1))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
set D12 = R11;
set D13 = ( StepTimes (R6 , D12 , R4 , R1) );
set D14 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D12 ) ) );
set D15 = ( Initialized R1 );
thus L53: ( ( D13 . ( 0 ) ) . ( intloc ( 0 ) ) ) = ( ( Exec (( D14 := R6 ) , D15) ) . ( intloc ( 0 ) ) ) by SCMFSA_9:def 5
.= ( D15 . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
end;
theorem
L54: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write) implies ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . ( 0 ) ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) = ( R1 . R6 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
set D16 = R11;
set D17 = ( StepTimes (R6 , D16 , R4 , R1) );
set D18 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D16 ) ) );
set D19 = ( Initialized R1 );
assume L55: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write);
L56: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
thus L57: ( ( D17 . ( 0 ) ) . D18 ) = ( ( Exec (( D18 := R6 ) , D19) ) . D18 ) by SCMFSA_9:def 5
.= ( D19 . R6 ) by SCMFSA_2:63
.= ( R1 . R6 ) by L55 , L56 , SCMFSA_M:9 , SCMFSA_M:37;
end;
theorem
L58: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds (for R12 being (Element of ( NAT )) holds ((( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( intloc ( 0 ) ) ) = 1 & R11 is_closed_on ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) , ( R4 +* ( times* (R6 , R11) ) ) & R11 is_halting_on ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) , ( R4 +* ( times* (R6 , R11) ) )) implies (( ( ( StepTimes (R6 , R11 , R4 , R1) ) . ( R12 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 & (( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) > ( 0 ) implies ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . ( R12 + 1 ) ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) = ( ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) - 1 )))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
let R12 being (Element of ( NAT ));
set D20 = R11;
assume that
L59: ( ( ( StepTimes (R6 , D20 , R4 , R1) ) . R12 ) . ( intloc ( 0 ) ) ) = 1
and
L60: (D20 is_closed_on ( ( StepTimes (R6 , D20 , R4 , R1) ) . R12 ) , ( R4 +* ( times* (R6 , D20) ) ) & D20 is_halting_on ( ( StepTimes (R6 , D20 , R4 , R1) ) . R12 ) , ( R4 +* ( times* (R6 , D20) ) ));
set D21 = ( StepTimes (R6 , D20 , R4 , R1) );
L61: (D20 is_closed_on ( Initialized ( D21 . R12 ) ) , ( R4 +* ( times* (R6 , D20) ) ) & D20 is_halting_on ( Initialized ( D21 . R12 ) ) , ( R4 +* ( times* (R6 , D20) ) )) by L59 , L60 , L32;
set D22 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D20 ) ) );
set D23 = ( StepWhile>0 (D22 , ( D20 ";" ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) , R4 , ( Exec (( D22 := R6 ) , ( Initialized R1 )) )) );
L62: ( Macro ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) , ( R4 +* ( times* (R6 , D20) ) ) by SCMFSA7B:18;
L63: ( Macro ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) , ( R4 +* ( times* (R6 , D20) ) ) by SCMFSA7B:19;
L64: ( D20 ";" ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) is_halting_on ( Initialized ( D21 . R12 ) ) , ( R4 +* ( times* (R6 , D20) ) ) by L63 , L61 , L62 , SFMASTR1:3;
thus L65:now
per cases ;
suppose L66: ( ( D23 . R12 ) . D22 ) <= ( 0 );

L67: ( DataPart ( D23 . ( R12 + 1 ) ) ) = ( DataPart ( D21 . R12 ) ) by L66 , SCMFSA9A:31;
thus L68: ( ( ( StepTimes (R6 , D20 , R4 , R1) ) . ( R12 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L67 , L59 , SCMFSA_M:2;
end;
suppose L69: ( ( D23 . R12 ) . D22 ) > ( 0 );

L70: ( DataPart ( D23 . ( R12 + 1 ) ) ) = ( DataPart ( IExec (( D20 ";" ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) ) by L69 , L59 , L61 , L62 , L64 , SCMFSA9A:32 , SFMASTR1:2;
thus L71: ( ( D21 . ( R12 + 1 ) ) . ( intloc ( 0 ) ) ) = ( ( IExec (( D20 ";" ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) . ( intloc ( 0 ) ) ) by L70 , SCMFSA_M:2
.= ( ( Exec (( SubFrom (D22 , ( intloc ( 0 ) )) ) , ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) )) ) . ( intloc ( 0 ) ) ) by L61 , SFMASTR1:11
.= ( ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= 1 by L61 , SCMFSA8C:67;
end;
end;
L73: (not D22 in ( { R6 } \/ ( UsedIntLoc D20 ) )) by SCMFSA_M:25;
L74: (not D22 in ( UsedIntLoc D20 )) by L73 , XBOOLE_0:def 3;
assume L75: ( ( D21 . R12 ) . D22 ) > ( 0 );
L76: ( DataPart ( D23 . ( R12 + 1 ) ) ) = ( DataPart ( IExec (( D20 ";" ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) ) by L75 , L59 , L61 , L62 , L64 , SCMFSA9A:32 , SFMASTR1:2;
thus L77: ( ( D21 . ( R12 + 1 ) ) . D22 ) = ( ( IExec (( D20 ";" ( SubFrom (D22 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) . D22 ) by L76 , SCMFSA_M:2
.= ( ( Exec (( SubFrom (D22 , ( intloc ( 0 ) )) ) , ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) )) ) . D22 ) by L61 , SFMASTR1:11
.= ( ( ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) . D22 ) - ( ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( IExec (D20 , ( R4 +* ( times* (R6 , D20) ) ) , ( D21 . R12 )) ) . D22 ) - 1 ) by L61 , SCMFSA8C:67
.= ( ( ( Initialized ( D21 . R12 ) ) . D22 ) - 1 ) by L61 , L74 , L1
.= ( ( ( D21 . R12 ) . D22 ) - 1 ) by SCMFSA_M:37;
end;
theorem
L78: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write) implies ( ( ( StepTimes (R6 , R10 , R4 , R1) ) . ( 0 ) ) . R6 ) = ( R1 . R6 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D24 = ( StepTimes (R6 , R10 , R4 , R1) );
set D25 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R10 ) ) );
set D26 = ( Initialized R1 );
assume L79: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write);
L80: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L81: R6 in { R6 } by TARSKI:def 1;
L82: R6 in ( { R6 } \/ ( UsedIntLoc R10 ) ) by L81 , XBOOLE_0:def 3;
L83: D25 <> R6 by L82 , SCMFSA_M:25;
thus L84: ( ( D24 . ( 0 ) ) . R6 ) = ( ( Exec (( D25 := R6 ) , D26) ) . R6 ) by SCMFSA_9:def 5
.= ( D26 . R6 ) by L83 , SCMFSA_2:63
.= ( R1 . R6 ) by L79 , L80 , SCMFSA_M:9 , SCMFSA_M:37;
end;
theorem
L85: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R9 being FinSeq-Location holds (for R10 being (Program of ( SCM+FSA )) holds ( ( ( StepTimes (R6 , R10 , R4 , R1) ) . ( 0 ) ) . R9 ) = ( R1 . R9 ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R9 being FinSeq-Location;
let R10 being (Program of ( SCM+FSA ));
set D27 = ( StepTimes (R6 , R10 , R4 , R1) );
set D28 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R10 ) ) );
set D29 = ( Initialized R1 );
thus L86: ( ( D27 . ( 0 ) ) . R9 ) = ( ( Exec (( D28 := R6 ) , D29) ) . R9 ) by SCMFSA_9:def 5
.= ( D29 . R9 ) by SCMFSA_2:63
.= ( R1 . R9 ) by SCMFSA_M:37;
end;
definition
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let C12 being (State of ( SCM+FSA ));
let C13 being Int-Location;
let C14 being (Program of ( SCM+FSA ));
pred  ProperTimesBody C13 , C14 , C12 , R4
means
:L87: (for B1 being (Element of ( NAT )) holds (B1 < ( C12 . C13 ) implies (C14 is_closed_on ( ( StepTimes (C13 , C14 , R4 , C12) ) . B1 ) , ( R4 +* ( times* (C13 , C14) ) ) & C14 is_halting_on ( ( StepTimes (C13 , C14 , R4 , C12) ) . B1 ) , ( R4 +* ( times* (C13 , C14) ) ))))
;end;
theorem
L89: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (R10 is  parahalting implies  ProperTimesBody R6 , R10 , R1 , R4)))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
assume L90: R10 is  parahalting;
reconsider D30 = R10 as  parahalting (Program of ( SCM+FSA )) by L90;
let C15 being (Element of ( NAT ));
assume L91: C15 < ( R1 . R6 );
L92: D30 is  paraclosed;
thus L93: R10 is_closed_on ( ( StepTimes (R6 , R10 , R4 , R1) ) . C15 ) , ( R4 +* ( times* (R6 , R10) ) ) by L92 , SCMFSA7B:18;
thus L94: thesis by L90 , SCMFSA7B:19;
end;
theorem
L95: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds ( ProperTimesBody R6 , R11 , R1 , R4 implies (for R12 being (Element of ( NAT )) holds (R12 <= ( R1 . R6 ) implies ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( intloc ( 0 ) ) ) = 1)))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
set D31 = R11;
set D32 = ( StepTimes (R6 , D31 , R4 , R1) );
set D33 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D31 ) ) );
set D34 = ( Initialized R1 );
defpred S1[ (Element of ( NAT )) ] means ($1 <= ( R1 . R6 ) implies ( ( D32 . $1 ) . ( intloc ( 0 ) ) ) = 1);
assume L96:  ProperTimesBody R6 , D31 , R1 , R4;
L97: (for B2 being (Element of ( NAT )) holds (S1[ B2 ] implies S1[ ( B2 + 1 ) ]))
proof
let C16 being (Element of ( NAT ));
assume that
L98: (C16 <= ( R1 . R6 ) implies ( ( D32 . C16 ) . ( intloc ( 0 ) ) ) = 1)
and
L99: ( C16 + 1 ) <= ( R1 . R6 );
reconsider D35 = ( R1 . R6 ) as (Element of ( NAT )) by L99 , INT_1:3;
L100: C16 < D35 by L99 , NAT_1:13;
L101: (D31 is_closed_on ( D32 . C16 ) , ( R4 +* ( times* (R6 , D31) ) ) & D31 is_halting_on ( D32 . C16 ) , ( R4 +* ( times* (R6 , D31) ) )) by L100 , L96 , L87;
thus L102: thesis by L101 , L98 , L100 , L58;
end;
L103: S1[ ( 0 ) ]
proof
assume L104: ( 0 ) <= ( R1 . R6 );
thus L105: ( ( D32 . ( 0 ) ) . ( intloc ( 0 ) ) ) = ( ( Exec (( D33 := R6 ) , D34) ) . ( intloc ( 0 ) ) ) by SCMFSA_9:def 5
.= ( D34 . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
end;
thus L106: (for R12 being (Element of ( NAT )) holds S1[ R12 ]) from NAT_1:sch 1(L103 , L97);
end;
theorem
L107: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds (((( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write) &  ProperTimesBody R6 , R11 , R1 , R4) implies (for R12 being (Element of ( NAT )) holds (R12 <= ( R1 . R6 ) implies ( ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) + R12 ) = ( R1 . R6 ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
set D36 = R11;
assume that
L108: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write)
and
L109:  ProperTimesBody R6 , D36 , R1 , R4;
set D37 = ( Initialized R1 );
set D38 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D36 ) ) );
set D39 = ( StepTimes (R6 , D36 , R4 , R1) );
set D40 = ( StepWhile>0 (D38 , ( D36 ";" ( SubFrom (D38 , ( intloc ( 0 ) )) ) ) , R4 , ( Exec (( D38 := R6 ) , D37) )) );
defpred S2[ Nat ] means ($1 <= ( R1 . R6 ) implies ( ( ( ( StepTimes (R6 , D36 , R4 , R1) ) . $1 ) . D38 ) + $1 ) = ( R1 . R6 ));
L110: (for B3 being (Element of ( NAT )) holds (S2[ B3 ] implies S2[ ( B3 + 1 ) ]))
proof
L111: (not D38 in ( { R6 } \/ ( UsedIntLoc D36 ) )) by SCMFSA_M:25;
L112: (not D38 in ( UsedIntLoc D36 )) by L111 , XBOOLE_0:def 3;
let C17 being (Element of ( NAT ));
assume that
L113: (C17 <= ( R1 . R6 ) implies ( ( ( D39 . C17 ) . D38 ) + C17 ) = ( R1 . R6 ))
and
L114: ( C17 + 1 ) <= ( R1 . R6 );
reconsider D41 = ( R1 . R6 ) as (Element of ( NAT )) by L114 , INT_1:3;
L115: C17 < D41 by L114 , NAT_1:13;
L116: ( ( D39 . C17 ) . ( intloc ( 0 ) ) ) = 1 by L115 , L109 , L95;
L117:
now
assume L118: ( ( D40 . C17 ) . D38 ) <= ( 0 );
L119: ( ( ( D40 . C17 ) . D38 ) + C17 ) < ( ( R1 . R6 ) + ( 0 ) ) by L118 , L115 , XREAL_1:8;
thus L120: contradiction by L119 , L113 , L115;
end;
L121: ( Macro ( SubFrom (D38 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D36 , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) , ( R4 +* ( times* (R6 , D36) ) ) by SCMFSA7B:18;
L122: D36 is_closed_on ( D39 . C17 ) , ( R4 +* ( times* (R6 , D36) ) ) by L109 , L115 , L87;
L123: D36 is_closed_on ( Initialized ( D39 . C17 ) ) , ( R4 +* ( times* (R6 , D36) ) ) by L122 , L116 , L28;
L124: D36 is_halting_on ( D39 . C17 ) , ( R4 +* ( times* (R6 , D36) ) ) by L109 , L115 , L87;
L125: D36 is_halting_on ( Initialized ( D39 . C17 ) ) , ( R4 +* ( times* (R6 , D36) ) ) by L124 , L116 , L122 , L32;
L126: ( Macro ( SubFrom (D38 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D36 , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) , ( R4 +* ( times* (R6 , D36) ) ) by SCMFSA7B:19;
L127: ( D36 ";" ( SubFrom (D38 , ( intloc ( 0 ) )) ) ) is_halting_on ( Initialized ( D39 . C17 ) ) , ( R4 +* ( times* (R6 , D36) ) ) by L126 , L123 , L125 , L121 , SFMASTR1:3;
L128: ( DataPart ( D40 . ( C17 + 1 ) ) ) = ( DataPart ( IExec (( D36 ";" ( SubFrom (D38 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) ) by L127 , L116 , L123 , L125 , L121 , L117 , SCMFSA9A:32 , SFMASTR1:2;
L129: ( ( D39 . ( C17 + 1 ) ) . D38 ) = ( ( IExec (( D36 ";" ( SubFrom (D38 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) . D38 ) by L128 , SCMFSA_M:2
.= ( ( Exec (( SubFrom (D38 , ( intloc ( 0 ) )) ) , ( IExec (D36 , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) )) ) . D38 ) by L123 , L125 , SFMASTR1:11
.= ( ( ( IExec (D36 , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) . D38 ) - ( ( IExec (D36 , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( IExec (D36 , ( R4 +* ( times* (R6 , D36) ) ) , ( D39 . C17 )) ) . D38 ) - 1 ) by L123 , L125 , SCMFSA8C:67
.= ( ( ( Initialized ( D39 . C17 ) ) . D38 ) - 1 ) by L123 , L125 , L112 , L1
.= ( ( ( D39 . C17 ) . D38 ) - 1 ) by SCMFSA_M:37;
thus L130: thesis by L129 , L113 , L115;
end;
L131: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L132: S2[ ( 0 ) ]
proof
assume L133: ( 0 ) <= ( R1 . R6 );
thus L134: ( ( ( D39 . ( 0 ) ) . D38 ) + ( 0 ) ) = ( ( Exec (( D38 := R6 ) , D37) ) . D38 ) by SCMFSA_9:def 5
.= ( D37 . R6 ) by SCMFSA_2:63
.= ( R1 . R6 ) by L108 , L131 , SCMFSA_M:9 , SCMFSA_M:37;
end;
thus L135: (for R12 being (Element of ( NAT )) holds S2[ R12 ]) from NAT_1:sch 1(L132 , L110);
end;
theorem
L136: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds (( ProperTimesBody R6 , R11 , R1 , R4 & ( 0 ) <= ( R1 . R6 ) & (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write)) implies (for R12 being (Element of ( NAT )) holds (R12 >= ( R1 . R6 ) implies (( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) = ( 0 ) & ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( intloc ( 0 ) ) ) = 1))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
set D42 = R11;
assume that
L137:  ProperTimesBody R6 , D42 , R1 , R4
and
L138: ( 0 ) <= ( R1 . R6 )
and
L139: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write);
set D43 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D42 ) ) );
set D44 = ( StepTimes (R6 , D42 , R4 , R1) );
set D45 = ( StepWhile>0 (D43 , ( D42 ";" ( SubFrom (D43 , ( intloc ( 0 ) )) ) ) , R4 , ( Exec (( D43 := R6 ) , ( Initialized R1 )) )) );
defpred S3[ Nat ] means ($1 >= ( R1 . R6 ) implies (( ( D44 . $1 ) . D43 ) = ( 0 ) & ( ( D44 . $1 ) . ( intloc ( 0 ) ) ) = 1));
L140: (for R12 being (Element of ( NAT )) holds (S3[ R12 ] implies S3[ ( R12 + 1 ) ]))
proof
reconsider D46 = ( R1 . R6 ) as (Element of ( NAT )) by L138 , INT_1:3;
let R12 being (Element of ( NAT ));
assume that
L141: (R12 >= ( R1 . R6 ) implies (( ( D44 . R12 ) . D43 ) = ( 0 ) & ( ( D44 . R12 ) . ( intloc ( 0 ) ) ) = 1))
and
L142: ( R12 + 1 ) >= ( R1 . R6 );
per cases  by L142 , XXREAL_0:1;
suppose L143: ( R12 + 1 ) = D46;

L144: ( ( ( D44 . ( R12 + 1 ) ) . D43 ) + ( R12 + 1 ) ) = ( R1 . R6 ) by L143 , L137 , L139 , L107;
thus L145: ( ( D44 . ( R12 + 1 ) ) . D43 ) = ( 0 ) by L144 , L143;
thus L146: thesis by L137 , L143 , L95;
end;
suppose L147: ( R12 + 1 ) > D46;

L148: ( DataPart ( D45 . ( R12 + 1 ) ) ) = ( DataPart ( D45 . R12 ) ) by L147 , L141 , NAT_1:13 , SCMFSA9A:31;
thus L149: ( ( D44 . ( R12 + 1 ) ) . D43 ) = ( 0 ) by L148 , L141 , L147 , NAT_1:13 , SCMFSA_M:2;
thus L150: thesis by L141 , L147 , L148 , NAT_1:13 , SCMFSA_M:2;
end;
end;
L152: S3[ ( 0 ) ]
proof
assume L153: ( 0 ) >= ( R1 . R6 );
thus L154: ( ( D44 . ( 0 ) ) . D43 ) = ( ( ( D44 . ( 0 ) ) . D43 ) + ( 0 ) )
.= ( 0 ) by L137 , L138 , L139 , L153 , L107;
thus L155: thesis by L137 , L138 , L95;
end;
thus L156: (for R12 being (Element of ( NAT )) holds S3[ R12 ]) from NAT_1:sch 1(L152 , L140);
end;
theorem
L157: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds (( R1 . ( intloc ( 0 ) ) ) = 1 implies ( ( ( StepTimes (R6 , R10 , R4 , R1) ) . ( 0 ) ) | ( ( UsedIntLoc R10 ) \/ ( FinSeq-Locations ) ) ) = ( R1 | ( ( UsedIntLoc R10 ) \/ ( FinSeq-Locations ) ) ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D47 = ( StepTimes (R6 , R10 , R4 , R1) );
set D48 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R10 ) ) );
set D49 = ( Initialized R1 );
set D50 = ( UsedIntLoc R10 );
assume L158: ( R1 . ( intloc ( 0 ) ) ) = 1;
L159: ( DataPart ( Initialized R1 ) ) = ( DataPart R1 ) by L158 , SCMFSA_M:19;
L160:
now
let C18 being Int-Location;
L161: (not D48 in ( { R6 } \/ D50 )) by SCMFSA_M:25;
assume L162: C18 in D50;
L163: D48 <> C18 by L162 , L161 , XBOOLE_0:def 3;
thus L164: ( ( D47 . ( 0 ) ) . C18 ) = ( ( Exec (( D48 := R6 ) , D49) ) . C18 ) by SCMFSA_9:def 5
.= ( D49 . C18 ) by L163 , SCMFSA_2:63
.= ( R1 . C18 ) by L159 , SCMFSA_M:2;
end;
L165:
now
let C19 being FinSeq-Location;
thus L166: ( ( D47 . ( 0 ) ) . C19 ) = ( ( Exec (( D48 := R6 ) , D49) ) . C19 ) by SCMFSA_9:def 5
.= ( D49 . C19 ) by SCMFSA_2:63
.= ( R1 . C19 ) by SCMFSA_M:37;
end;
thus L167: thesis by L165 , L160 , SCMFSA_M:28;
end;
theorem
L168: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds (for R12 being (Element of ( NAT )) holds ((( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( intloc ( 0 ) ) ) = 1 & R11 is_halting_on ( Initialized ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) ) , ( R4 +* ( times* (R6 , R11) ) ) & R11 is_closed_on ( Initialized ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) ) , ( R4 +* ( times* (R6 , R11) ) ) & ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) . ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R11 ) ) ) ) > ( 0 )) implies ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . ( R12 + 1 ) ) | ( ( UsedIntLoc R11 ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (R11 , ( R4 +* ( times* (R6 , R11) ) ) , ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 )) ) | ( ( UsedIntLoc R11 ) \/ ( FinSeq-Locations ) ) )))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
let R12 being (Element of ( NAT ));
set D51 = ( FinSeq-Locations );
set D52 = R11;
set D53 = ( StepTimes (R6 , D52 , R4 , R1) );
set D54 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D52 ) ) );
set D55 = ( StepWhile>0 (D54 , ( D52 ";" ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) , R4 , ( Exec (( D54 := R6 ) , ( Initialized R1 )) )) );
set D56 = ( UsedIntLoc D52 );
assume that
L169: ( ( D53 . R12 ) . ( intloc ( 0 ) ) ) = 1
and
L170: (D52 is_halting_on ( Initialized ( D53 . R12 ) ) , ( R4 +* ( times* (R6 , D52) ) ) & D52 is_closed_on ( Initialized ( D53 . R12 ) ) , ( R4 +* ( times* (R6 , D52) ) ))
and
L171: ( ( D53 . R12 ) . D54 ) > ( 0 );
L172: ( Macro ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D52 , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) , ( R4 +* ( times* (R6 , D52) ) ) by SCMFSA7B:18;
L173: ( Macro ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D52 , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) , ( R4 +* ( times* (R6 , D52) ) ) by SCMFSA7B:19;
L174: ( D52 ";" ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) is_halting_on ( Initialized ( D53 . R12 ) ) , ( R4 +* ( times* (R6 , D52) ) ) by L173 , L170 , L172 , SFMASTR1:3;
L175: ( DataPart ( D55 . ( R12 + 1 ) ) ) = ( DataPart ( IExec (( D52 ";" ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) ) by L174 , L169 , L170 , L171 , L172 , SCMFSA9A:32 , SFMASTR1:2;
L176:
now
let C20 being Int-Location;
L177: (not D54 in ( { R6 } \/ D56 )) by SCMFSA_M:25;
assume L178: C20 in D56;
L179: D54 <> C20 by L178 , L177 , XBOOLE_0:def 3;
thus L180: ( ( D53 . ( R12 + 1 ) ) . C20 ) = ( ( IExec (( D52 ";" ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) . C20 ) by L175 , SCMFSA_M:2
.= ( ( Exec (( SubFrom (D54 , ( intloc ( 0 ) )) ) , ( IExec (D52 , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) )) ) . C20 ) by L170 , SFMASTR1:11
.= ( ( IExec (D52 , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) . C20 ) by L179 , SCMFSA_2:65;
end;
L181:
now
let C21 being FinSeq-Location;
thus L182: ( ( D53 . ( R12 + 1 ) ) . C21 ) = ( ( IExec (( D52 ";" ( SubFrom (D54 , ( intloc ( 0 ) )) ) ) , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) . C21 ) by L175 , SCMFSA_M:2
.= ( ( Exec (( SubFrom (D54 , ( intloc ( 0 ) )) ) , ( IExec (D52 , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) )) ) . C21 ) by L170 , SFMASTR1:12
.= ( ( IExec (D52 , ( R4 +* ( times* (R6 , D52) ) ) , ( D53 . R12 )) ) . C21 ) by SCMFSA_2:65;
end;
thus L183: thesis by L181 , L176 , SCMFSA_M:28;
end;
theorem
L184: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds (for R12 being (Element of ( NAT )) holds ((( ProperTimesBody R6 , R11 , R1 , R4 or R11 is  parahalting) & R12 < ( R1 . R6 ) & (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write)) implies ( ( ( StepTimes (R6 , R11 , R4 , R1) ) . ( R12 + 1 ) ) | ( ( UsedIntLoc R11 ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (R11 , ( R4 +* ( times* (R6 , R11) ) ) , ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 )) ) | ( ( UsedIntLoc R11 ) \/ ( FinSeq-Locations ) ) )))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
let R12 being (Element of ( NAT ));
set D57 = ( FinSeq-Locations );
set D58 = R11;
assume that
L185: ( ProperTimesBody R6 , D58 , R1 , R4 or D58 is  parahalting)
and
L186: R12 < ( R1 . R6 )
and
L187: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write);
set D59 = ( StepTimes (R6 , D58 , R4 , R1) );
L188: ( ( D59 . R12 ) . ( intloc ( 0 ) ) ) = 1 by L185 , L186 , L89 , L95;
set D60 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D58 ) ) );
L189:  ProperTimesBody R6 , D58 , R1 , R4 by L185 , L89;
L190: ( ( ( D59 . R12 ) . D60 ) + R12 ) = ( R1 . R6 ) by L189 , L186 , L187 , L107;
L191: D58 is_closed_on ( D59 . R12 ) , ( R4 +* ( times* (R6 , D58) ) ) by L186 , L189 , L87;
L192: D58 is_closed_on ( Initialized ( D59 . R12 ) ) , ( R4 +* ( times* (R6 , D58) ) ) by L191 , L188 , L28;
L193: ( R12 - R12 ) < ( ( R1 . R6 ) - R12 ) by L186 , XREAL_1:9;
L194: D58 is_halting_on ( D59 . R12 ) , ( R4 +* ( times* (R6 , D58) ) ) by L186 , L189 , L87;
L195: D58 is_halting_on ( Initialized ( D59 . R12 ) ) , ( R4 +* ( times* (R6 , D58) ) ) by L194 , L188 , L191 , L32;
thus L196: thesis by L195 , L188 , L192 , L190 , L193 , L168;
set D61 = ( UsedIntLoc D58 );
end;
theorem
L198: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R10 being (Program of ( SCM+FSA )) holds ((( R1 . R6 ) <= ( 0 ) & ( R1 . ( intloc ( 0 ) ) ) = 1) implies ( ( IExec (( times (R6 , R10) ) , R4 , R1) ) | ( ( UsedIntLoc R10 ) \/ ( FinSeq-Locations ) ) ) = ( R1 | ( ( UsedIntLoc R10 ) \/ ( FinSeq-Locations ) ) ))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R10 being (Program of ( SCM+FSA ));
set D62 = ( FinSeq-Locations );
assume that
L199: ( R1 . R6 ) <= ( 0 )
and
L200: ( R1 . ( intloc ( 0 ) ) ) = 1;
set D63 = ( UsedIntLoc R10 );
set D64 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc R10 ) ) );
set D65 = ( while>0 (D64 , ( R10 ";" ( SubFrom (D64 , ( intloc ( 0 ) )) ) )) );
set D66 = ( Exec (( D64 := R6 ) , ( Initialized R1 )) );
L201: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L202: D66 = ( IExec (( Macro ( D64 := R6 ) ) , R4 , R1) ) by SCMFSA6C:5;
L203: ( D66 . D64 ) = ( ( Initialized R1 ) . R6 ) by SCMFSA_2:63
.= ( R1 . R6 ) by L200 , L201 , SCMFSA_M:9 , SCMFSA_M:37;
L204: (D65 is_closed_on ( IExec (( Macro ( D64 := R6 ) ) , R4 , R1) ) , R4 & D65 is_halting_on ( IExec (( Macro ( D64 := R6 ) ) , R4 , R1) ) , R4) by L203 , L199 , L202 , SCMFSA_9:38;
L205: ( D66 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L206: ( DataPart ( IExec (D65 , R4 , D66) ) ) = ( DataPart D66 ) by L205 , L199 , L203 , SCMFSA9A:35;
L207:
now
let C22 being FinSeq-Location;
assume L208: C22 in D62;
thus L209: ( ( IExec (( times (R6 , R10) ) , R4 , R1) ) . C22 ) = ( ( IExec (D65 , R4 , D66) ) . C22 ) by L202 , L204 , SFMASTR1:15
.= ( D66 . C22 ) by L206 , SCMFSA_M:2
.= ( ( Initialized R1 ) . C22 ) by SCMFSA_2:63
.= ( R1 . C22 ) by SCMFSA_M:37;
end;
L210: ( DataPart R1 ) = ( DataPart ( Initialized R1 ) ) by L200 , SCMFSA_M:19;
L211:
now
let C23 being Int-Location;
L212: (not D64 in ( { R6 } \/ D63 )) by SCMFSA_M:25;
assume L213: C23 in D63;
L214: D64 <> C23 by L213 , L212 , XBOOLE_0:def 3;
thus L215: ( ( IExec (( times (R6 , R10) ) , R4 , R1) ) . C23 ) = ( ( IExec (D65 , R4 , D66) ) . C23 ) by L202 , L204 , SFMASTR1:14
.= ( D66 . C23 ) by L206 , SCMFSA_M:2
.= ( ( Initialized R1 ) . C23 ) by L214 , SCMFSA_2:63
.= ( R1 . C23 ) by L210 , SCMFSA_M:2;
end;
L216: ( [#] D62 ) = D62;
thus L217: thesis by L216 , L211 , L207 , SCMFSA_M:27;
end;
theorem
L218: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds (for R12 being (Element of ( NAT )) holds ((( R1 . R6 ) = R12 & ( ProperTimesBody R6 , R11 , R1 , R4 or R11 is  parahalting) & (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write)) implies ( DataPart ( IExec (( times (R6 , R11) ) , R4 , R1) ) ) = ( DataPart ( ( StepTimes (R6 , R11 , R4 , R1) ) . R12 ) )))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
let R12 being (Element of ( NAT ));
set D67 = R11;
assume L219: ( R1 . R6 ) = R12;
set D68 = ( StepTimes (R6 , D67 , R4 , R1) );
set D69 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D67 ) ) );
set D70 = ( D67 ";" ( SubFrom (D69 , ( intloc ( 0 ) )) ) );
set D71 = ( Exec (( D69 := R6 ) , ( Initialized R1 )) );
set D72 = ( Initialized D71 );
set D73 = ( StepWhile>0 (D69 , D70 , R4 , D71) );
set D74 = ( StepWhile>0 (D69 , D70 , R4 , D72) );
L220: ( D71 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L221: ( DataPart D72 ) = ( DataPart D71 ) by L220 , SCMFSA_M:19;
set D75 = ( while>0 (D69 , D70) );
assume L222: ( ProperTimesBody R6 , D67 , R1 , R4 or D67 is  parahalting);
L223:  ProperTimesBody R6 , D67 , R1 , R4 by L222 , L89;
assume L224: (( R1 . ( intloc ( 0 ) ) ) = 1 or R6 is  read-write);
L225: D68 = D73;
L226:  ProperBodyWhile>0 D69 , D70 , D71 , R4
proof
let C24 being (Element of ( NAT ));
assume L227: ( ( D73 . C24 ) . D69 ) > ( 0 );
L228: C24 < ( R1 . R6 ) by L227 , L219 , L223 , L224 , L225 , L136;
L229: ( ( D68 . C24 ) . ( intloc ( 0 ) ) ) = 1 by L228 , L222 , L89 , L95;
L230: ( DataPart ( D68 . C24 ) ) = ( DataPart ( Initialized ( D68 . C24 ) ) ) by L229 , SCMFSA_M:19;
L231: D67 is_closed_on ( D68 . C24 ) , ( R4 +* ( times* (R6 , D67) ) ) by L223 , L228 , L87;
L232: D67 is_closed_on ( Initialized ( D68 . C24 ) ) , ( R4 +* ( times* (R6 , D67) ) ) by L231 , L229 , L28;
L233: D67 is_halting_on ( D68 . C24 ) , ( R4 +* ( times* (R6 , D67) ) ) by L223 , L228 , L87;
L234: D67 is_halting_on ( Initialized ( D68 . C24 ) ) , ( R4 +* ( times* (R6 , D67) ) ) by L233 , L231 , L229 , L32;
L235: ( Macro ( SubFrom (D69 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D67 , ( R4 +* ( times* (R6 , D67) ) ) , ( D68 . C24 )) ) , ( R4 +* ( times* (R6 , D67) ) ) by SCMFSA7B:18;
L236: D70 is_closed_on ( Initialized ( D68 . C24 ) ) , ( R4 +* ( times* (R6 , D67) ) ) by L235 , L232 , L234 , SFMASTR1:2;
thus L237: D70 is_closed_on ( D73 . C24 ) , ( R4 +* D75 ) by L236 , L230 , SCMFSA8B:3;
L238: ( Macro ( SubFrom (D69 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D67 , ( R4 +* ( times* (R6 , D67) ) ) , ( D68 . C24 )) ) , ( R4 +* ( times* (R6 , D67) ) ) by SCMFSA7B:19;
L239: D70 is_halting_on ( Initialized ( D68 . C24 ) ) , ( R4 +* ( times* (R6 , D67) ) ) by L238 , L232 , L234 , L235 , SFMASTR1:3;
thus L240: thesis by L239 , L230 , L236 , SCMFSA8B:5;
end;
L241: ( DataPart ( D74 . R12 ) ) = ( DataPart ( D73 . R12 ) ) by L226 , L221 , SCMFSA9A:34;
L242:  WithVariantWhile>0 D69 , D70 , D72 , R4
proof
reconsider D76 = ( R1 . R6 ) as (Element of ( NAT )) by L219;
deffunc H1((State of ( SCM+FSA ))) = ( abs ( $1 . D69 ) );
consider C25 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L243: (for B4 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) holds ( C25 . B4 ) = H1(B4)) from FUNCT_2:sch 4;
L244: (for B5 being (State of ( SCM+FSA )) holds ( C25 . B5 ) = H1(B5))
proof
let C26 being (State of ( SCM+FSA ));
reconsider D77 = C26 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L245: ( C25 . D77 ) = H1(D77) by L243;
thus L246: thesis by L245;
end;
take C25;
let C27 being (Element of ( NAT ));
L247: ( DataPart ( D74 . C27 ) ) = ( DataPart ( D73 . C27 ) ) by L221 , L226 , SCMFSA9A:34;
L248: ( ( D74 . C27 ) . D69 ) = ( ( D73 . C27 ) . D69 ) by L247 , SCMFSA_M:2;
L249: ( DataPart ( D74 . ( C27 + 1 ) ) ) = ( DataPart ( D73 . ( C27 + 1 ) ) ) by L221 , L226 , SCMFSA9A:34;
L250: ( ( D74 . ( C27 + 1 ) ) . D69 ) = ( ( D73 . ( C27 + 1 ) ) . D69 ) by L249 , SCMFSA_M:2;
per cases ;
suppose L251: C27 < ( R1 . R6 );

L252: ( C27 - C27 ) < ( ( R1 . R6 ) - C27 ) by L251 , XREAL_1:9;
L253: ( ( ( D68 . C27 ) . D69 ) + C27 ) = ( R1 . R6 ) by L223 , L224 , L251 , L107;
L254: ( C27 + 1 ) <= D76 by L251 , NAT_1:13;
L255: ( ( C27 + 1 ) - ( C27 + 1 ) ) <= ( ( R1 . R6 ) - ( C27 + 1 ) ) by L254 , XREAL_1:9;
L256: ( ( ( D68 . ( C27 + 1 ) ) . D69 ) + ( C27 + 1 ) ) = ( R1 . R6 ) by L223 , L224 , L254 , L107;
L257: ( R1 . R6 ) = ( ( ( ( D68 . ( C27 + 1 ) ) . D69 ) + 1 ) + C27 ) by L256;
L258: ( C25 . ( D74 . ( C27 + 1 ) ) ) = ( abs ( ( D74 . ( C27 + 1 ) ) . D69 ) ) by L244
.= ( ( D73 . ( C27 + 1 ) ) . D69 ) by L250 , L256 , L255 , ABSVALUE:def 1;
L259: ( C25 . ( D74 . C27 ) ) = ( abs ( ( D74 . C27 ) . D69 ) ) by L244
.= ( ( D73 . C27 ) . D69 ) by L248 , L253 , L252 , ABSVALUE:def 1;
thus L260: thesis by L259 , L253 , L257 , L258 , NAT_1:13;
end;
suppose L261: C27 >= ( R1 . R6 );

thus L262: thesis by L261 , L219 , L223 , L224 , L225 , L248 , L136;
end;
end;
L264:  ProperBodyWhile>0 D69 , D70 , D72 , R4
proof
let C28 being (Element of ( NAT ));
assume L265: ( ( D74 . C28 ) . D69 ) > ( 0 );
L266: ( DataPart ( D74 . C28 ) ) = ( DataPart ( D73 . C28 ) ) by L221 , L226 , SCMFSA9A:34;
L267: ( ( D73 . C28 ) . D69 ) = ( ( D74 . C28 ) . D69 ) by L266 , SCMFSA_M:2;
L268: D70 is_closed_on ( D73 . C28 ) , ( R4 +* D75 ) by L267 , L226 , L265 , SCMFSA9A:def 4;
thus L269: D70 is_closed_on ( D74 . C28 ) , ( R4 +* D75 ) by L268 , L266 , SCMFSA8B:3;
L270: D70 is_halting_on ( D73 . C28 ) , ( R4 +* D75 ) by L226 , L265 , L267 , SCMFSA9A:def 4;
thus L271: thesis by L270 , L266 , L268 , SCMFSA8B:5;
end;
consider C29 being (Element of ( NAT )) such that L272: ( ExitsAtWhile>0 (D69 , D70 , R4 , D72) ) = C29 and L273: ( ( D74 . C29 ) . D69 ) <= ( 0 ) and L274: (for B6 being (Element of ( NAT )) holds (( ( D74 . B6 ) . D69 ) <= ( 0 ) implies C29 <= B6)) and L275: ( DataPart ( Comput (( R4 +* D75 ) , ( Initialize D72 ) , ( LifeSpan (( R4 +* D75 ) , ( Initialize D72 )) )) ) ) = ( DataPart ( D74 . C29 ) ) by L264 , L242 , SCMFSA9A:def 6;
L276: D75 is_closed_on D72 , R4 by L264 , L242 , SCMFSA9A:27;
L277: D75 is_halting_on D72 , R4 by L264 , L242 , SCMFSA9A:27;
L278: D75 is_halting_on D71 , R4 by L277 , L221 , L276 , SCMFSA8B:5;
L279: ( DataPart ( IExec (D75 , R4 , D71) ) ) = ( DataPart ( D74 . ( ExitsAtWhile>0 (D69 , D70 , R4 , D72) ) ) ) by L264 , L242 , SCMFSA9A:36;
L280: ( DataPart ( D74 . C29 ) ) = ( DataPart ( D73 . C29 ) ) by L221 , L226 , SCMFSA9A:34;
L281: ( ( D73 . R12 ) . D69 ) = ( 0 ) by L219 , L223 , L224 , L225 , L136;
L282: ( ( D74 . R12 ) . D69 ) = ( 0 ) by L281 , L241 , SCMFSA_M:2;
L283: C29 <= R12 by L282 , L274;
L284: ( ( ( D73 . C29 ) . D69 ) + C29 ) = R12 by L283 , L219 , L223 , L224 , L225 , L107;
L285: ( C29 - C29 ) <= ( R12 - C29 ) by L283 , XREAL_1:9;
L286: ( ( D74 . C29 ) . D69 ) = ( 0 ) by L285 , L273 , L280 , L284 , SCMFSA_M:2;
L287: ( ( ( D74 . C29 ) . D69 ) + C29 ) = R12 by L280 , L284 , SCMFSA_M:2;
L288:
now
let C30 being Int-Location;
thus L289: ( ( IExec (( times (R6 , D67) ) , R4 , R1) ) . C30 ) = ( ( IExec (D75 , R4 , D71) ) . C30 ) by L221 , L276 , L278 , SCMFSA8B:3 , SFMASTR1:14
.= ( ( D68 . R12 ) . C30 ) by L279 , L272 , L241 , L287 , L286 , SCMFSA_M:2;
end;
L290:
now
let C31 being FinSeq-Location;
thus L291: ( ( IExec (( times (R6 , D67) ) , R4 , R1) ) . C31 ) = ( ( IExec (D75 , R4 , D71) ) . C31 ) by L221 , L276 , L278 , SCMFSA8B:3 , SFMASTR1:15
.= ( ( D68 . R12 ) . C31 ) by L279 , L272 , L241 , L287 , L286 , SCMFSA_M:2;
end;
thus L292: thesis by L290 , L288 , SCMFSA_M:2;
end;
theorem
L293: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R6 being Int-Location holds (for R11 being  good (Program of ( SCM+FSA )) holds ((( R1 . ( intloc ( 0 ) ) ) = 1 & ( ProperTimesBody R6 , R11 , R1 , R4 or R11 is  parahalting)) implies (( times (R6 , R11) ) is_closed_on R1 , R4 & ( times (R6 , R11) ) is_halting_on R1 , R4))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R6 being Int-Location;
let R11 being  good (Program of ( SCM+FSA ));
set D78 = R11;
assume L294: ( R1 . ( intloc ( 0 ) ) ) = 1;
set D79 = ( times (R6 , D78) );
set D80 = ( StepTimes (R6 , D78 , R4 , R1) );
set D81 = ( 1 -stRWNotIn ( { R6 } \/ ( UsedIntLoc D78 ) ) );
set D82 = ( D78 ";" ( SubFrom (D81 , ( intloc ( 0 ) )) ) );
set D83 = ( while>0 (D81 , D82) );
set D84 = ( Exec (( D81 := R6 ) , ( Initialized R1 )) );
set D85 = ( Initialized D84 );
set D86 = ( StepWhile>0 (D81 , D82 , R4 , D84) );
set D87 = ( StepWhile>0 (D81 , D82 , R4 , D85) );
L295: D80 = D86;
L296: (D84 = ( IExec (( Macro ( D81 := R6 ) ) , R4 , R1) ) & ( Macro ( D81 := R6 ) ) is_closed_on ( Initialized R1 ) , R4) by SCMFSA6C:5 , SCMFSA7B:18;
L297: ( Macro ( D81 := R6 ) ) is_halting_on ( Initialized R1 ) , R4 by SCMFSA7B:19;
L298: ( D84 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L299: ( DataPart D85 ) = ( DataPart D84 ) by L298 , SCMFSA_M:19;
assume L300: ( ProperTimesBody R6 , D78 , R1 , R4 or D78 is  parahalting);
L301:  ProperTimesBody R6 , D78 , R1 , R4 by L300 , L89;
L302: ( Macro ( D81 := R6 ) ) is_halting_on ( Initialized R1 ) , R4 by SCMFSA7B:19;
per cases ;
suppose L303: ( R1 . R6 ) < ( 0 );

L304: (R6 = ( intloc ( 0 ) ) or R6 is  read-write) by SCMFSA_M:def 2;
L305: ( D84 . D81 ) = ( ( Initialized R1 ) . R6 ) by SCMFSA_2:63
.= ( R1 . R6 ) by L294 , L304 , SCMFSA_M:9 , SCMFSA_M:37;
L306: D83 is_closed_on D84 , R4 by L305 , L303 , SCMFSA_9:38;
L307: D79 is_closed_on ( Initialized R1 ) , R4 by L306 , L296 , L297 , SFMASTR1:2;
thus L308: ( times (R6 , D78) ) is_closed_on R1 , R4 by L307 , L294 , L28;
L309: D83 is_halting_on D84 , R4 by L303 , L305 , SCMFSA_9:38;
L310: D79 is_halting_on ( Initialized R1 ) , R4 by L309 , L296 , L302 , L306 , SFMASTR1:3;
thus L311: thesis by L310 , L294 , L307 , L32;
end;
suppose L312: ( 0 ) <= ( R1 . R6 );

L313:  ProperBodyWhile>0 D81 , D82 , D84 , R4
proof
let C32 being (Element of ( NAT ));
assume L314: ( ( D86 . C32 ) . D81 ) > ( 0 );
L315: C32 < ( R1 . R6 ) by L314 , L294 , L301 , L295 , L312 , L136;
L316: ( ( D80 . C32 ) . ( intloc ( 0 ) ) ) = 1 by L315 , L300 , L89 , L95;
L317: ( DataPart ( D80 . C32 ) ) = ( DataPart ( Initialized ( D80 . C32 ) ) ) by L316 , SCMFSA_M:19;
L318: D78 is_closed_on ( D80 . C32 ) , ( R4 +* ( times* (R6 , D78) ) ) by L301 , L315 , L87;
L319: D78 is_closed_on ( Initialized ( D80 . C32 ) ) , ( R4 +* ( times* (R6 , D78) ) ) by L318 , L316 , L28;
L320: D78 is_halting_on ( D80 . C32 ) , ( R4 +* ( times* (R6 , D78) ) ) by L301 , L315 , L87;
L321: D78 is_halting_on ( Initialized ( D80 . C32 ) ) , ( R4 +* ( times* (R6 , D78) ) ) by L320 , L318 , L316 , L32;
L322: ( Macro ( SubFrom (D81 , ( intloc ( 0 ) )) ) ) is_closed_on ( IExec (D78 , ( R4 +* ( times* (R6 , D78) ) ) , ( D80 . C32 )) ) , ( R4 +* ( times* (R6 , D78) ) ) by SCMFSA7B:18;
L323: D82 is_closed_on ( Initialized ( D80 . C32 ) ) , ( R4 +* ( times* (R6 , D78) ) ) by L322 , L319 , L321 , SFMASTR1:2;
thus L324: D82 is_closed_on ( D86 . C32 ) , ( R4 +* D83 ) by L323 , L317 , SCMFSA8B:3;
L325: ( Macro ( SubFrom (D81 , ( intloc ( 0 ) )) ) ) is_halting_on ( IExec (D78 , ( R4 +* ( times* (R6 , D78) ) ) , ( D80 . C32 )) ) , ( R4 +* ( times* (R6 , D78) ) ) by SCMFSA7B:19;
L326: D82 is_halting_on ( Initialized ( D80 . C32 ) ) , ( R4 +* ( times* (R6 , D78) ) ) by L325 , L319 , L321 , L322 , SFMASTR1:3;
thus L327: thesis by L326 , L317 , L323 , SCMFSA8B:5;
end;
L328:  WithVariantWhile>0 D81 , D82 , D85 , R4
proof
reconsider D88 = ( R1 . R6 ) as (Element of ( NAT )) by L312 , INT_1:3;
deffunc H2((State of ( SCM+FSA ))) = ( abs ( $1 . D81 ) );
consider C33 being (Function of ( product ( the_Values_of ( SCM+FSA ) ) ) , ( NAT )) such that L329: (for B7 being (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) holds ( C33 . B7 ) = H2(B7)) from FUNCT_2:sch 4;
L330: (for B8 being (State of ( SCM+FSA )) holds ( C33 . B8 ) = H2(B8))
proof
let C34 being (State of ( SCM+FSA ));
reconsider D89 = C34 as (Element of ( product ( the_Values_of ( SCM+FSA ) ) )) by CARD_3:107;
L331: ( C33 . D89 ) = H2(D89) by L329;
thus L332: thesis by L331;
end;
take C33;
let C35 being (Element of ( NAT ));
L333: ( DataPart ( D87 . C35 ) ) = ( DataPart ( D86 . C35 ) ) by L299 , L313 , SCMFSA9A:34;
L334: ( ( D87 . C35 ) . D81 ) = ( ( D86 . C35 ) . D81 ) by L333 , SCMFSA_M:2;
L335: ( DataPart ( D87 . ( C35 + 1 ) ) ) = ( DataPart ( D86 . ( C35 + 1 ) ) ) by L299 , L313 , SCMFSA9A:34;
L336: ( ( D87 . ( C35 + 1 ) ) . D81 ) = ( ( D86 . ( C35 + 1 ) ) . D81 ) by L335 , SCMFSA_M:2;
per cases ;
suppose L337: C35 < ( R1 . R6 );

L338: ( C35 - C35 ) < ( ( R1 . R6 ) - C35 ) by L337 , XREAL_1:9;
L339: ( ( ( D80 . C35 ) . D81 ) + C35 ) = ( R1 . R6 ) by L294 , L301 , L337 , L107;
L340: ( C35 + 1 ) <= D88 by L337 , NAT_1:13;
L341: ( ( C35 + 1 ) - ( C35 + 1 ) ) <= ( ( R1 . R6 ) - ( C35 + 1 ) ) by L340 , XREAL_1:9;
L342: ( ( ( D80 . ( C35 + 1 ) ) . D81 ) + ( C35 + 1 ) ) = ( R1 . R6 ) by L294 , L301 , L340 , L107;
L343: ( R1 . R6 ) = ( ( ( ( D80 . ( C35 + 1 ) ) . D81 ) + 1 ) + C35 ) by L342;
L344: ( C33 . ( D87 . ( C35 + 1 ) ) ) = ( abs ( ( D87 . ( C35 + 1 ) ) . D81 ) ) by L330
.= ( ( D86 . ( C35 + 1 ) ) . D81 ) by L336 , L342 , L341 , ABSVALUE:def 1;
L345: ( C33 . ( D87 . C35 ) ) = ( abs ( ( D87 . C35 ) . D81 ) ) by L330
.= ( ( D86 . C35 ) . D81 ) by L334 , L339 , L338 , ABSVALUE:def 1;
thus L346: thesis by L345 , L339 , L343 , L344 , NAT_1:13;
end;
suppose L347: C35 >= ( R1 . R6 );

thus L348: thesis by L347 , L294 , L301 , L295 , L312 , L334 , L136;
end;
end;
L350:  ProperBodyWhile>0 D81 , D82 , D85 , R4
proof
let C36 being (Element of ( NAT ));
assume L351: ( ( D87 . C36 ) . D81 ) > ( 0 );
L352: ( DataPart ( D87 . C36 ) ) = ( DataPart ( D86 . C36 ) ) by L299 , L313 , SCMFSA9A:34;
L353: ( ( D86 . C36 ) . D81 ) = ( ( D87 . C36 ) . D81 ) by L352 , SCMFSA_M:2;
L354: D82 is_closed_on ( D86 . C36 ) , ( R4 +* ( while>0 (D81 , D82) ) ) by L353 , L313 , L351 , SCMFSA9A:def 4;
thus L355: D82 is_closed_on ( D87 . C36 ) , ( R4 +* D83 ) by L354 , L352 , SCMFSA8B:3;
L356: D82 is_halting_on ( D86 . C36 ) , ( R4 +* ( while>0 (D81 , D82) ) ) by L313 , L351 , L353 , SCMFSA9A:def 4;
thus L357: thesis by L356 , L352 , L354 , SCMFSA8B:5;
end;
L358: D83 is_closed_on D84 , R4 by L350 , L299 , L328 , SCMFSA8B:3 , SCMFSA9A:27;
L359: D79 is_closed_on ( Initialized R1 ) , R4 by L296 , L358 , L297 , SFMASTR1:2;
thus L360: ( times (R6 , D78) ) is_closed_on R1 , R4 by L359 , L294 , L28;
L361: (D83 is_closed_on D85 , R4 & D83 is_halting_on D85 , R4) by L350 , L328 , SCMFSA9A:27;
L362: D83 is_halting_on D84 , R4 by L361 , L299 , SCMFSA8B:5;
L363: D79 is_halting_on ( Initialized R1 ) , R4 by L362 , L296 , L302 , L358 , SFMASTR1:3;
thus L364: thesis by L363 , L294 , L359 , L32;
end;
end;
begin
definition
let C37 being  read-write Int-Location;
func triv-times C37 -> (Program of ( SCM+FSA )) equals 
( times (C37 , ( ( while=0 (C37 , ( Macro ( C37 := C37 ) )) ) ";" ( SubFrom (C37 , ( intloc ( 0 ) )) ) )) );
correctness;
end;
theorem
L367: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R8 being  read-write Int-Location holds (( R1 . R8 ) <= ( 0 ) implies ( ( IExec (( triv-times R8 ) , R4 , R1) ) . R8 ) = ( R1 . R8 )))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R8 being  read-write Int-Location;
set D90 = R8;
assume L368: ( R1 . D90 ) <= ( 0 );
set D91 = ( ( while=0 (D90 , ( Macro ( D90 := D90 ) )) ) ";" ( SubFrom (D90 , ( intloc ( 0 ) )) ) );
set D92 = ( 1 -stRWNotIn ( { D90 } \/ ( UsedIntLoc D91 ) ) );
set D93 = ( while>0 (D92 , ( D91 ";" ( SubFrom (D92 , ( intloc ( 0 ) )) ) )) );
set D94 = ( Exec (( D92 := D90 ) , ( Initialized R1 )) );
L369: ( D94 . D92 ) = ( ( Initialized R1 ) . D90 ) by SCMFSA_2:63
.= ( R1 . D90 ) by SCMFSA_M:37;
L370: D90 in { D90 } by TARSKI:def 1;
L371: D90 in ( { D90 } \/ ( UsedIntLoc D91 ) ) by L370 , XBOOLE_0:def 3;
L372: D92 <> D90 by L371 , SCMFSA_M:25;
L373: ( D94 . ( intloc ( 0 ) ) ) = ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L374: ( DataPart ( IExec (D93 , R4 , D94) ) ) = ( DataPart D94 ) by L373 , L368 , L369 , SCMFSA9A:35;
L375: D94 = ( IExec (( Macro ( D92 := D90 ) ) , R4 , R1) ) by SCMFSA6C:5;
L376: (D93 is_closed_on ( IExec (( Macro ( D92 := D90 ) ) , R4 , R1) ) , R4 & D93 is_halting_on ( IExec (( Macro ( D92 := D90 ) ) , R4 , R1) ) , R4) by L375 , L368 , L369 , SCMFSA_9:38;
thus L377: ( ( IExec (( triv-times D90 ) , R4 , R1) ) . D90 ) = ( ( IExec (D93 , R4 , D94) ) . D90 ) by L376 , L375 , SFMASTR1:14
.= ( D94 . D90 ) by L374 , SCMFSA_M:2
.= ( ( Initialized R1 ) . D90 ) by L372 , SCMFSA_2:63
.= ( R1 . D90 ) by SCMFSA_M:37;
end;
theorem
L378: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for R8 being  read-write Int-Location holds (( 0 ) <= ( R1 . R8 ) implies ( ( IExec (( triv-times R8 ) , R4 , R1) ) . R8 ) = ( 0 )))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let R8 being  read-write Int-Location;
set D95 = R8;
set D96 = ( while=0 (D95 , ( Macro ( D95 := D95 ) )) );
set D97 = ( SubFrom (D95 , ( intloc ( 0 ) )) );
set D98 = ( D96 ";" D97 );
set D99 = ( 1 -stRWNotIn ( { D95 } \/ ( UsedIntLoc D98 ) ) );
set D100 = ( StepTimes (D95 , D98 , R4 , R1) );
defpred S4[ Nat ] means (($1 < ( R1 . D95 ) implies (D98 is_closed_on ( D100 . $1 ) , ( R4 +* ( times* (D95 , D98) ) ) & D98 is_halting_on ( D100 . $1 ) , ( R4 +* ( times* (D95 , D98) ) ) & ( ( D100 . $1 ) . ( intloc ( 0 ) ) ) = 1)) & ($1 <= ( R1 . D95 ) implies (( ( ( D100 . $1 ) . D95 ) + $1 ) = ( R1 . D95 ) & ( ( D100 . $1 ) . D99 ) = ( ( D100 . $1 ) . D95 ))));
L379: D95 in { D95 , ( intloc ( 0 ) ) } by TARSKI:def 2;
L380: D95 in ( UsedIntLoc ( SubFrom (D95 , ( intloc ( 0 ) )) ) ) by L379 , SF_MASTR:14;
L381: D95 in ( ( UsedIntLoc ( while=0 (D95 , ( Macro ( D95 := D95 ) )) ) ) \/ ( UsedIntLoc ( SubFrom (D95 , ( intloc ( 0 ) )) ) ) ) by L380 , XBOOLE_0:def 3;
L382: D95 in ( UsedIntLoc D98 ) by L381 , SF_MASTR:30;
L383: (for R12 being (Element of ( NAT )) holds (S4[ R12 ] implies S4[ ( R12 + 1 ) ]))
proof
let R12 being (Element of ( NAT ));
assume that
L384: (R12 < ( R1 . D95 ) implies (D98 is_closed_on ( D100 . R12 ) , ( R4 +* ( times* (D95 , D98) ) ) & D98 is_halting_on ( D100 . R12 ) , ( R4 +* ( times* (D95 , D98) ) ) & ( ( D100 . R12 ) . ( intloc ( 0 ) ) ) = 1))
and
L385: (R12 <= ( R1 . D95 ) implies (( ( ( D100 . R12 ) . D95 ) + R12 ) = ( R1 . D95 ) & ( ( D100 . R12 ) . D99 ) = ( ( D100 . R12 ) . D95 )));
L386:
now
assume L387: R12 < ( R1 . D95 );
L388: ( ( D100 . R12 ) . D95 ) <> ( 0 ) by L387 , L385;
L389: ( DataPart ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) ) ) = ( DataPart ( D100 . R12 ) ) by L388 , L384 , L387 , SCMFSA9A:22;
L390: D96 is_closed_on ( D100 . R12 ) , ( R4 +* ( times* (D95 , D98) ) ) by L388 , SCMFSA_9:18;
L391: D96 is_closed_on ( Initialized ( D100 . R12 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L390 , L384 , L387 , L28;
L392: D96 is_halting_on ( D100 . R12 ) , ( R4 +* ( times* (D95 , D98) ) ) by L388 , SCMFSA_9:18;
L393: D96 is_halting_on ( Initialized ( D100 . R12 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L392 , L384 , L387 , L390 , L32;
L394: ( R12 - R12 ) < ( ( R1 . D95 ) - R12 ) by L387 , XREAL_1:9;
thus L395: ( ( D100 . R12 ) . D99 ) > ( 0 ) by L394 , L385 , L387;
L396: (D98 is_closed_on ( Initialized ( D100 . R12 ) ) , ( R4 +* ( times* (D95 , D98) ) ) & D98 is_halting_on ( Initialized ( D100 . R12 ) ) , ( R4 +* ( times* (D95 , D98) ) )) by L384 , L387 , L32;
L397: ( ( D100 . ( R12 + 1 ) ) | ( ( UsedIntLoc D98 ) \/ ( FinSeq-Locations ) ) ) = ( ( IExec (D98 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) ) | ( ( UsedIntLoc D98 ) \/ ( FinSeq-Locations ) ) ) by L396 , L384 , L385 , L387 , L394 , L168;
L398: ( ( D100 . ( R12 + 1 ) ) . D95 ) = ( ( IExec (D98 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) ) . D95 ) by L397 , L382 , SCMFSA_M:28
.= ( ( Exec (D97 , ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) )) ) . D95 ) by L391 , L393 , SFMASTR1:11
.= ( ( ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) ) . D95 ) - ( ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) ) . ( intloc ( 0 ) ) ) ) by SCMFSA_2:65
.= ( ( ( D100 . R12 ) . D95 ) - ( ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . R12 )) ) . ( intloc ( 0 ) ) ) ) by L389 , SCMFSA_M:2
.= ( ( ( D100 . R12 ) . D95 ) - 1 ) by L384 , L387 , L389 , SCMFSA_M:2;
thus L399: ( ( ( D100 . ( R12 + 1 ) ) . D95 ) + ( R12 + 1 ) ) = ( R1 . D95 ) by L398 , L385 , L387;
end;
thus L400:now
assume L401: ( R12 + 1 ) < ( R1 . D95 );
reconsider D101 = ( R1 . D95 ) as (Element of ( NAT )) by L401 , INT_1:3;
L402: R12 < D101 by L401 , NAT_1:12;
L403: ( ( D100 . ( R12 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L402 , L384 , L58;
L404: ( ( D100 . ( R12 + 1 ) ) . D95 ) <> ( 0 ) by L386 , L401 , L402;
L405: D96 is_closed_on ( D100 . ( R12 + 1 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L404 , SCMFSA_9:18;
L406: ( Macro D97 ) is_closed_on ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . ( R12 + 1 ) )) ) , ( R4 +* ( times* (D95 , D98) ) ) by SCMFSA7B:18;
L407: D96 is_halting_on ( D100 . ( R12 + 1 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L404 , SCMFSA_9:18;
L408: D96 is_halting_on ( Initialized ( D100 . ( R12 + 1 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L407 , L403 , L405 , L32;
L409: D96 is_closed_on ( Initialized ( D100 . ( R12 + 1 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L403 , L405 , L28;
L410: D98 is_closed_on ( Initialized ( D100 . ( R12 + 1 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L409 , L408 , L406 , SFMASTR1:2;
thus L411: D98 is_closed_on ( D100 . ( R12 + 1 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L410 , L403 , L28;
L412: ( Macro D97 ) is_halting_on ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . ( R12 + 1 ) )) ) , ( R4 +* ( times* (D95 , D98) ) ) by SCMFSA7B:19;
L413: D98 is_halting_on ( Initialized ( D100 . ( R12 + 1 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L412 , L408 , L409 , L406 , SFMASTR1:3;
thus L414: D98 is_halting_on ( D100 . ( R12 + 1 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L413 , L403 , L410 , L32;
thus L415: ( ( D100 . ( R12 + 1 ) ) . ( intloc ( 0 ) ) ) = 1 by L384 , L402 , L58;
end;
L416: R12 < ( R12 + 1 ) by NAT_1:13;
assume L417: ( R12 + 1 ) <= ( R1 . D95 );
thus L418: ( ( ( D100 . ( R12 + 1 ) ) . D95 ) + ( R12 + 1 ) ) = ( R1 . D95 ) by L417 , L386 , L416 , XXREAL_0:2;
L419: ( ( D100 . ( R12 + 1 ) ) . D99 ) = ( ( ( D100 . R12 ) . D95 ) - 1 ) by L384 , L385 , L386 , L417 , L416 , L58 , XXREAL_0:2;
thus L420: thesis by L419 , L385 , L386 , L417 , L416 , XXREAL_0:2;
end;
L421: S4[ ( 0 ) ]
proof
thus L422:now
assume L423: ( 0 ) < ( R1 . D95 );
L424: ( ( D100 . ( 0 ) ) . D95 ) <> ( 0 ) by L423 , L78;
L425: D96 is_closed_on ( D100 . ( 0 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L424 , SCMFSA_9:18;
L426: ( Macro D97 ) is_closed_on ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . ( 0 ) )) ) , ( R4 +* ( times* (D95 , D98) ) ) by SCMFSA7B:18;
L427: ( ( D100 . ( 0 ) ) . ( intloc ( 0 ) ) ) = 1 by L52;
L428: D96 is_halting_on ( D100 . ( 0 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L424 , SCMFSA_9:18;
L429: D96 is_halting_on ( Initialized ( D100 . ( 0 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L428 , L427 , L425 , L32;
L430: D96 is_closed_on ( Initialized ( D100 . ( 0 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L427 , L425 , L28;
L431: D98 is_closed_on ( Initialized ( D100 . ( 0 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L430 , L429 , L426 , SFMASTR1:2;
thus L432: D98 is_closed_on ( D100 . ( 0 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L431 , L427 , L28;
L433: ( Macro D97 ) is_halting_on ( IExec (D96 , ( R4 +* ( times* (D95 , D98) ) ) , ( D100 . ( 0 ) )) ) , ( R4 +* ( times* (D95 , D98) ) ) by SCMFSA7B:19;
L434: D98 is_halting_on ( Initialized ( D100 . ( 0 ) ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L433 , L429 , L430 , L426 , SFMASTR1:3;
thus L435: D98 is_halting_on ( D100 . ( 0 ) ) , ( R4 +* ( times* (D95 , D98) ) ) by L434 , L427 , L431 , L32;
thus L436: ( ( D100 . ( 0 ) ) . ( intloc ( 0 ) ) ) = 1 by L52;
end;
assume L437: ( 0 ) <= ( R1 . D95 );
thus L438: ( ( ( D100 . ( 0 ) ) . D95 ) + ( 0 ) ) = ( R1 . D95 ) by L78;
L439: ( ( D100 . ( 0 ) ) . D95 ) = ( R1 . D95 ) by L78;
thus L440: thesis by L439 , L54;
end;
L441: (for R12 being (Element of ( NAT )) holds S4[ R12 ]) from NAT_1:sch 1(L421 , L383);
L442:  ProperTimesBody D95 , D98 , R1 , R4
proof
let R12 being (Element of ( NAT ));
thus L443: thesis by L441;
end;
assume L444: ( 0 ) <= ( R1 . D95 );
reconsider D102 = ( R1 . D95 ) as (Element of ( NAT )) by L444 , INT_1:3;
L445: ( ( ( ( StepTimes (D95 , D98 , R4 , R1) ) . D102 ) . D95 ) + D102 ) = ( R1 . D95 ) by L441;
L446: ( DataPart ( IExec (( times (D95 , D98) ) , R4 , R1) ) ) = ( DataPart ( ( StepTimes (D95 , D98 , R4 , R1) ) . D102 ) ) by L442 , L218;
thus L447: thesis by L446 , L445 , SCMFSA_M:2;
end;
begin
definition
let C38 , C39 being Int-Location;
func Fib-macro (C38 , C39) -> (Program of ( SCM+FSA )) equals 
( ( ( ( ( ( 1 -stNotUsed ( times (C38 , ( ( AddTo (C39 , ( 1 -stRWNotIn { C38 , C39 } )) ) ";" ( swap (C39 , ( 1 -stRWNotIn { C38 , C39 } )) ) )) ) ) := C38 ) ";" ( SubFrom (C39 , C39) ) ) ";" ( ( 1 -stRWNotIn { C38 , C39 } ) := ( intloc ( 0 ) ) ) ) ";" ( times (C38 , ( ( AddTo (C39 , ( 1 -stRWNotIn { C38 , C39 } )) ) ";" ( swap (C39 , ( 1 -stRWNotIn { C38 , C39 } )) ) )) ) ) ";" ( C38 := ( 1 -stNotUsed ( times (C38 , ( ( AddTo (C39 , ( 1 -stRWNotIn { C38 , C39 } )) ) ";" ( swap (C39 , ( 1 -stRWNotIn { C38 , C39 } )) ) )) ) ) ) );
correctness;
end;
theorem
L449: (for R1 being (State of ( SCM+FSA )) holds (for R4 being (Instruction-Sequence of ( SCM+FSA )) holds (for B9 , B10 being  read-write Int-Location holds (B9 <> B10 implies (for B11 being (Element of ( NAT )) holds (B11 = ( R1 . B9 ) implies (( ( IExec (( Fib-macro (B9 , B10) ) , R4 , R1) ) . B10 ) = ( Fib B11 ) & ( ( IExec (( Fib-macro (B9 , B10) ) , R4 , R1) ) . B9 ) = ( R1 . B9 ))))))))
proof
let R1 being (State of ( SCM+FSA ));
let R4 being (Instruction-Sequence of ( SCM+FSA ));
let C40 , C41 being  read-write Int-Location;
assume that
L450: C40 <> C41;
let C42 being (Element of ( NAT ));
set D103 = ( SubFrom (C41 , C41) );
set D104 = ( 1 -stRWNotIn { C40 , C41 } );
set D105 = ( 1 -stNotUsed ( times (C40 , ( ( AddTo (C41 , D104) ) ";" ( swap (C41 , D104) ) )) ) );
set D106 = ( D105 := C40 );
set D107 = ( D104 := ( intloc ( 0 ) ) );
set D108 = ( AddTo (C41 , D104) );
set D109 = ( swap (C41 , D104) );
set D110 = ( D108 ";" D109 );
set D111 = ( ( D106 ";" D103 ) ";" D107 );
set D112 = ( IExec (D111 , R4 , R1) );
set D113 = ( times (C40 , D110) );
set D114 = ( StepTimes (C40 , D110 , R4 , D112) );
assume L451: C42 = ( R1 . C40 );
L452: (not D104 in { C40 , C41 }) by SCMFSA_M:25;
L453: D104 <> C40 by L452 , TARSKI:def 2;
L454: ( { C40 } \/ ( UsedIntLoc D110 ) ) c= ( UsedIntLoc D113 ) by L39;
L455: D105 = ( 1 -stRWNotIn ( UsedIntLoc D113 ) ) by SFMASTR1:def 4;
L456: (not D105 in ( UsedIntLoc D113 )) by L455 , SCMFSA_M:25;
L457: C40 in { C40 } by TARSKI:def 1;
L458: C40 in ( { C40 } \/ ( UsedIntLoc D110 ) ) by L457 , XBOOLE_0:def 3;
L459: D105 <> C40 by L458 , L455 , L454 , SCMFSA_M:25;
L460: ( D112 . C40 ) = ( ( Exec (D107 , ( IExec (( D106 ";" D103 ) , R4 , R1) )) ) . C40 ) by SCMFSA6C:6
.= ( ( IExec (( D106 ";" D103 ) , R4 , R1) ) . C40 ) by L453 , SCMFSA_2:63
.= ( ( Exec (D103 , ( Exec (D106 , ( Initialized R1 )) )) ) . C40 ) by SCMFSA6C:8
.= ( ( Exec (D106 , ( Initialized R1 )) ) . C40 ) by L450 , SCMFSA_2:65
.= ( ( Initialized R1 ) . C40 ) by L459 , SCMFSA_2:63
.= ( R1 . C40 ) by SCMFSA_M:37;
L461: ( DataPart ( IExec (D113 , R4 , D112) ) ) = ( DataPart ( D114 . C42 ) ) by L460 , L451 , L218;
defpred S5[ Nat ] means ($1 <= ( D112 . C40 ) implies (( ( D114 . $1 ) . C41 ) = ( Fib $1 ) & ( ( D114 . $1 ) . D104 ) = ( Fib ( $1 + 1 ) )));
set D115 = ( ( UsedIntLoc D110 ) \/ ( FinSeq-Locations ) );
set D116 = ( C40 := D105 );
L462: ( UsedIntLoc D110 ) = ( ( UsedIntLoc D108 ) \/ ( UsedIntLoc D109 ) ) by SF_MASTR:29
.= ( { C41 , D104 } \/ ( UsedIntLoc D109 ) ) by SF_MASTR:14;
L463: D104 in { C41 , D104 } by TARSKI:def 2;
L464: D104 in ( UsedIntLoc D110 ) by L463 , L462 , XBOOLE_0:def 3;
L465: D104 in ( { C40 } \/ ( UsedIntLoc D110 ) ) by L464 , XBOOLE_0:def 3;
L466: D105 <> D104 by L465 , L455 , L454 , SCMFSA_M:25;
L467: C41 in { C41 , D104 } by TARSKI:def 2;
L468: C41 in ( UsedIntLoc D110 ) by L467 , L462 , XBOOLE_0:def 3;
L469: C41 in ( { C40 } \/ ( UsedIntLoc D110 ) ) by L468 , XBOOLE_0:def 3;
L470: D105 <> C41 by L469 , L455 , L454 , SCMFSA_M:25;
L471: D104 <> C41 by L452 , TARSKI:def 2;
L472:
now
let C43 being (Element of ( NAT ));
assume that
L473: S5[ C43 ];
thus L474: S5[ ( C43 + 1 ) ]
proof
L475: C43 < ( C43 + 1 ) by NAT_1:13;
assume L476: ( C43 + 1 ) <= ( D112 . C40 );
L477: C43 < ( D112 . C40 ) by L476 , L475 , XXREAL_0:2;
L478: ( ( D114 . ( C43 + 1 ) ) | D115 ) = ( ( IExec (D110 , ( R4 +* ( times* (C40 , D110) ) ) , ( D114 . C43 )) ) | D115 ) by L477 , L184;
thus L479: ( ( D114 . ( C43 + 1 ) ) . C41 ) = ( ( IExec (D110 , ( R4 +* ( times* (C40 , D110) ) ) , ( D114 . C43 )) ) . C41 ) by L478 , L468 , SCMFSA_M:28
.= ( ( IExec (D109 , ( R4 +* ( times* (C40 , D110) ) ) , ( Exec (D108 , ( Initialized ( D114 . C43 ) )) )) ) . C41 ) by SCMFSA8B:9
.= ( ( Exec (D108 , ( Initialized ( D114 . C43 ) )) ) . D104 ) by SCMFSA6C:10
.= ( ( Initialized ( D114 . C43 ) ) . D104 ) by L471 , SCMFSA_2:64
.= ( Fib ( C43 + 1 ) ) by L473 , L476 , L475 , SCMFSA_M:37 , XXREAL_0:2;
thus L480: ( ( D114 . ( C43 + 1 ) ) . D104 ) = ( ( IExec (D110 , ( R4 +* ( times* (C40 , D110) ) ) , ( D114 . C43 )) ) . D104 ) by L464 , L478 , SCMFSA_M:28
.= ( ( IExec (D109 , ( R4 +* ( times* (C40 , D110) ) ) , ( Exec (D108 , ( Initialized ( D114 . C43 ) )) )) ) . D104 ) by SCMFSA8B:9
.= ( ( Exec (D108 , ( Initialized ( D114 . C43 ) )) ) . C41 ) by SCMFSA6C:10
.= ( ( ( Initialized ( D114 . C43 ) ) . C41 ) + ( ( Initialized ( D114 . C43 ) ) . D104 ) ) by SCMFSA_2:64
.= ( ( ( D114 . C43 ) . C41 ) + ( ( Initialized ( D114 . C43 ) ) . D104 ) ) by SCMFSA_M:37
.= ( ( ( D114 . C43 ) . C41 ) + ( ( D114 . C43 ) . D104 ) ) by SCMFSA_M:37
.= ( Fib ( ( C43 + 1 ) + 1 ) ) by L473 , L476 , L475 , PRE_FF:1 , XXREAL_0:2;
end;

end;
L475: ( D112 . D105 ) = ( ( Exec (D107 , ( IExec (( D106 ";" D103 ) , R4 , R1) )) ) . D105 ) by SCMFSA6C:6
.= ( ( IExec (( D106 ";" D103 ) , R4 , R1) ) . D105 ) by L466 , SCMFSA_2:63
.= ( ( Exec (D103 , ( Exec (D106 , ( Initialized R1 )) )) ) . D105 ) by SCMFSA6C:8
.= ( ( Exec (D106 , ( Initialized R1 )) ) . D105 ) by L470 , SCMFSA_2:65
.= ( ( Initialized R1 ) . C40 ) by SCMFSA_2:63
.= ( R1 . C40 ) by SCMFSA_M:37;
L476: (D111 is_halting_on ( Initialized R1 ) , R4 & D111 is_closed_on ( Initialized R1 ) , R4) by SCMFSA7B:18 , SCMFSA7B:19;
reconsider D117 = D111 as  good (Program of ( SCM+FSA ));
L477: ( D112 . D104 ) = ( ( Exec (D107 , ( IExec (( D106 ";" D103 ) , R4 , R1) )) ) . D104 ) by SCMFSA6C:6
.= ( ( IExec (( D106 ";" D103 ) , R4 , R1) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D103 , ( Exec (D106 , ( Initialized R1 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D106 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( Fib ( ( 0 ) + 1 ) ) by PRE_FF:1 , SCMFSA_M:9;
L478: ( D112 . ( intloc ( 0 ) ) ) = ( ( Exec (D107 , ( IExec (( D106 ";" D103 ) , R4 , R1) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:6
.= ( ( IExec (( D106 ";" D103 ) , R4 , R1) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= ( ( Exec (D103 , ( Exec (D106 , ( Initialized R1 )) )) ) . ( intloc ( 0 ) ) ) by SCMFSA6C:8
.= ( ( Exec (D106 , ( Initialized R1 )) ) . ( intloc ( 0 ) ) ) by SCMFSA_2:65
.= ( ( Initialized R1 ) . ( intloc ( 0 ) ) ) by SCMFSA_2:63
.= 1 by SCMFSA_M:9;
L479: D113 is_closed_on D112 , R4 by L478 , L293;
L480: ( D112 . C41 ) = ( ( Exec (D107 , ( IExec (( D106 ";" D103 ) , R4 , R1) )) ) . C41 ) by SCMFSA6C:6
.= ( ( IExec (( D106 ";" D103 ) , R4 , R1) ) . C41 ) by L471 , SCMFSA_2:63
.= ( ( Exec (D103 , ( Exec (D106 , ( Initialized R1 )) )) ) . C41 ) by SCMFSA6C:8
.= ( ( ( Exec (D106 , ( Initialized R1 )) ) . C41 ) - ( ( Exec (D106 , ( Initialized R1 )) ) . C41 ) ) by SCMFSA_2:65
.= ( Fib ( 0 ) ) by PRE_FF:1;
L481: S5[ ( 0 ) ]
proof
assume L482: ( 0 ) <= ( D112 . C40 );
L483: ( ( D114 . ( 0 ) ) | D115 ) = ( D112 | D115 ) by L478 , L157;
thus L484: ( ( D114 . ( 0 ) ) . C41 ) = ( Fib ( 0 ) ) by L483 , L468 , L480 , SCMFSA_M:28;
thus L485: thesis by L464 , L477 , L483 , SCMFSA_M:28;
end;
L486: (for B12 being (Element of ( NAT )) holds S5[ B12 ]) from NAT_1:sch 1(L481 , L472);
L487: D113 is_halting_on D112 , R4 by L478 , L293;
L488: (D113 is_closed_on ( Initialized D112 ) , R4 & D113 is_halting_on ( Initialized D112 ) , R4) by L487 , L478 , L479 , L32;
L489: ( D117 ";" D113 ) is_closed_on ( Initialized R1 ) , R4 by L479 , L476 , SFMASTR1:2;
thus L490: ( ( IExec (( Fib-macro (C40 , C41) ) , R4 , R1) ) . C41 ) = ( ( Exec (D116 , ( IExec (( D117 ";" D113 ) , R4 , R1) )) ) . C41 ) by L489 , L479 , L487 , L476 , SFMASTR1:3 , SFMASTR1:11
.= ( ( IExec (( D117 ";" D113 ) , R4 , R1) ) . C41 ) by L450 , SCMFSA_2:63
.= ( ( IExec (D113 , R4 , D112) ) . C41 ) by L479 , L487 , SFMASTR1:7
.= ( ( D114 . C42 ) . C41 ) by L461 , SCMFSA_M:2
.= ( Fib C42 ) by L460 , L486 , L451;
thus L491: ( ( IExec (( Fib-macro (C40 , C41) ) , R4 , R1) ) . C40 ) = ( ( Exec (D116 , ( IExec (( D117 ";" D113 ) , R4 , R1) )) ) . C40 ) by L479 , L487 , L476 , L489 , SFMASTR1:3 , SFMASTR1:11
.= ( ( IExec (( D117 ";" D113 ) , R4 , R1) ) . D105 ) by SCMFSA_2:63
.= ( ( IExec (D113 , R4 , D112) ) . D105 ) by L479 , L487 , SFMASTR1:7
.= ( R1 . C40 ) by L456 , L475 , L488 , L21;
end;
