:: Free interpretation, quotient interpretation and substitution of a letter
:: with a term for first order languages.
::  by Marco B. Caminati
::
:: Received December 29, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, RELAT_1,
      FUNCT_2, FINSEQ_1, FUNCT_1, ARYTM_3, XCMPLX_0, CARD_1, MONOID_0,
      ORDINAL1, ARYTM_1, XXREAL_0, ORDINAL4, PARTFUN1, FINSEQ_2, EQREL_1,
      COMPLEX1, FUNCT_3, FINSET_1, FUNCT_4, FUNCOP_1, MARGREL1, PRE_POLY,
      RELAT_2, RELSET_2, MATROID0, XBOOLEAN, FOMODEL0, FOMODEL1, FOMODEL2,
      FOMODEL3;
 notations TARSKI, FINSET_1, MARGREL1, PRE_POLY, RELAT_2, MONOID_0,
      XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, RELSET_2, RELAT_1, RELSET_1,
      FUNCT_1, PARTFUN1, FUNCT_2, FUNCOP_1, FUNCT_4, ORDINAL1, CARD_1, NUMBERS,
      XCMPLX_0, XXREAL_0, NAT_1, INT_2, FINSEQ_1, EQREL_1, FINSEQ_2, FINSEQOP,
      XBOOLEAN, FOMODEL0, FOMODEL1, FOMODEL2;
 constructors TARSKI, XBOOLE_0, ZFMISC_1, CARD_1, NAT_1, NUMBERS, INT_1,
      FINSEQ_1, XCMPLX_0, FUNCT_1, MONOID_0, XXREAL_0, RELAT_2, FUNCT_2,
      FUNCT_4, FUNCOP_1, FINSEQ_2, EQREL_1, RELSET_1, MCART_1, PARTFUN1,
      FINSEQOP, MATRIX_2, FUNCT_3, SETFAM_1, FINSET_1, MARGREL1, RELSET_2,
      LEXBFS, BINOP_1, XBOOLEAN, FOMODEL0, FOMODEL1, FOMODEL2, FUNCT_5;
 registrations ORDINAL1, XCMPLX_0, NAT_1, RELAT_1, NUMBERS, FUNCT_1, INT_1,
      FINSEQ_1, XREAL_0, FUNCT_2, FINSEQ_2, SUBSET_1, FUNCOP_1, RELSET_1,
      FUNCT_4, PARTFUN1, EQREL_1, FINSEQ_6, PRE_POLY, CARD_1, XBOOLE_0,
      XXREAL_0, ZFMISC_1, SETFAM_1, MARGREL1, SIMPLEX0, FINSET_1, RAMSEY_1,
      CARD_5, FOMODEL0, FOMODEL1, FOMODEL2;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions FINSEQ_1, XBOOLE_0, RELAT_1, FUNCOP_1, MARGREL1, EQREL_1,
      XBOOLEAN, FOMODEL0, FOMODEL1, FOMODEL2;
 theorems TARSKI, XBOOLE_0, FUNCT_1, FINSEQ_1, RELAT_1, XBOOLE_1, ZFMISC_1,
      FUNCT_2, XXREAL_0, NAT_1, ORDINAL1, EQREL_1, PARTFUN1, FINSEQ_2, XREAL_1,
      FUNCT_4, FUNCOP_1, FUNCT_5, RELAT_2, RELSET_1, RELSET_2,
      GRFUNC_1, ORDERS_1, FOMODEL0, FOMODEL1, FOMODEL2, CARD_1, FINSET_1,
      XTUPLE_0;
 schemes NAT_1, FUNCT_1, FUNCT_2, FRAENKEL, FINSEQ_1, FINSEQ_4, CLASSES1;

begin
definition
let R38 being Language;
let R41 being (Element of R38);
let C1 being (Element of ( ( ( ( AllSymbolsOf R38 ) * ) \ { ( {} ) } ) * ));
func R41 -compound C1 -> (string of R38) equals 
( <* R41 *> ^ ( ( R38 -multiCat ) . C1 ) );
coherence
proof
set D1 = ( AllSymbolsOf R38 );
set D2 = ( R38 -multiCat );
reconsider D3 = <* R41 *> as (Element of ( D1 * ));
reconsider D4 = ( D2 . C1 ) as (FinSequence of D1) by FINSEQ_1:def 11;
reconsider D5 = ( D3 ^ D4 ) as (FinSequence of D1);
L1: (D5 in ( D1 * ) & (not D5 in { ( {} ) })) by FINSEQ_1:def 11;
thus L2: ( <* R41 *> ^ ( D2 . C1 ) ) is (string of R38) by L1 , XBOOLE_0:def 5;
end;
end;
registration
let R38 being Language;
let R30 being (Element of ( NAT ));
let C2 being  termal (Element of R38);
let C3 being ( abs ( ar C2 ) ) -element (Element of ( ( ( R38 -termsOfMaxDepth ) . R30 ) * ));
cluster ( C2 -compound C3 ) -> ( R30 + 1 ) -termal for (string of R38);
coherence
proof
set D6 = ( R38 -multiCat );
set D7 = ( C2 -compound C3 );
set D8 = ( R38 -termsOfMaxDepth );
set D9 = ( LettersOf R38 );
set D10 = ( AllSymbolsOf R38 );
set D11 = ( abs ( ar C2 ) );
set D12 = ( AtomicTermsOf R38 );
set D13 = { ( Compound (B1 , ( D8 . R30 )) ) where B1 is  ofAtomicFormula (Element of R38) : B1 is  operational };
L4: C3 is (FinSequence of ( D8 . R30 )) by FINSEQ_1:def 11;
reconsider D14 = ( ( D10 * ) \ { ( {} ) } ) as (Subset of ( D10 * ));
L5: C3 in ( D14 * );
reconsider D15 = C3 as (Element of ( ( D10 * ) * )) by L5;
L6: (D7 = ( <* C2 *> ^ ( D6 . D15 ) ) & ( rng D15 ) c= ( D8 . R30 )) by L4 , FINSEQ_1:def 4;
L7: D7 in ( Compound (C2 , ( D8 . R30 )) ) by L6;
per cases ;
suppose L8: C2 is  literal;

reconsider D16 = C2 as  literal (Element of R38) by L8;
reconsider D17 = D16 as (Element of D9) by FOMODEL1:def 14;
L9: ( ar D16 ) = ( 0 );
L10: D11 = ( 0 ) by L9;
reconsider D18 = C3 as ( 0 ) -element FinSequence by L10;
L11: D7 = ( <* C2 *> ^ D18 )
.= <* D17 *>;
L12: D7 in ( AtomicTermsOf R38 ) by L11 , FINSEQ_2:98;
L13: (( D8 . ( 0 ) ) c= ( D8 . ( ( 0 ) + ( R30 + 1 ) ) ) & D7 in ( D8 . ( 0 ) )) by L12 , FOMODEL1:4 , FOMODEL1:def 30;
thus L14: thesis by L13 , FOMODEL1:def 33;
end;
suppose L15: (not C2 is  literal);

L16: ( Compound (C2 , ( D8 . R30 )) ) in D13 by L15;
L17: D7 in ( union D13 ) by L16 , L7 , TARSKI:def 4;
L18: D7 in ( ( union D13 ) \/ ( D8 . R30 ) ) by L17 , XBOOLE_0:def 3;
L19: D7 in ( D8 . ( R30 + 1 ) ) by L18 , FOMODEL1:def 30;
thus L20: thesis by L19 , FOMODEL1:def 33;
end;
end;
end;
L23: (for R7 being set holds (for R25 being Nat holds (for R26 being Nat holds (for R38 being Language holds ((not R7 in ( ( R38 -termsOfMaxDepth ) . ( R25 + R26 ) )) implies (not R7 in ( ( R38 -termsOfMaxDepth ) . R25 )))))))
proof
let R7 being set;
let R25 being Nat;
let R26 being Nat;
let R38 being Language;
set D19 = ( R38 -termsOfMaxDepth );
L24: ( D19 . R25 ) c= ( D19 . ( R25 + R26 ) ) by FOMODEL1:4;
assume L25: (not R7 in ( D19 . ( R25 + R26 ) ));
thus L26: thesis by L25 , L24;
end;
L27: (for R7 being set holds (for R26 being Nat holds (for R38 being Language holds (R7 in ( ( R38 -termsOfMaxDepth ) . R26 ) implies { R30 where R30 is (Element of ( NAT )) : (not R7 in ( ( R38 -termsOfMaxDepth ) . R30 )) } c= R26))))
proof
let R7 being set;
let R26 being Nat;
let R38 being Language;
set D20 = ( R38 -termsOfMaxDepth );
set D21 = { R30 where R30 is (Element of ( NAT )) : (not R7 in ( D20 . R30 )) };
assume L28: R7 in ( D20 . R26 );
L29:
now
let R10 being set;
assume L30: R10 in D21;
consider R30 being (Element of ( NAT )) such that L31: (R10 = R30 & (not R7 in ( D20 . R30 ))) by L30;
L32:
now
assume L33: R30 >= R26;
consider R24 being Nat such that L34: R30 = ( R26 + R24 ) by L33 , NAT_1:10;
thus L35: contradiction by L28 , L31 , L34 , L23;
end;
thus L36: R10 in R26 by L32 , L31 , NAT_1:44;
end;
thus L37: thesis by L29 , TARSKI:def 3;
end;
L38: (for R38 being Language holds (for B2 being (Element of ( ( AllTermsOf R38 ) * )) holds (ex B3 being (Element of ( NAT )) st B2 is (Element of ( ( ( R38 -termsOfMaxDepth ) . B3 ) * )))))
proof
let R38 being Language;
set D22 = ( AllTermsOf R38 );
set D23 = ( R38 -termsOfMaxDepth );
let C4 being (Element of ( D22 * ));
deffunc H1(set) = { R30 where R30 is (Element of ( NAT )) : (not ( C4 . $1 ) in ( D23 . R30 )) };
set D24 = { H1(R31) where R31 is (Element of ( NAT )) : R31 in ( dom C4 ) };
L39: ( dom C4 ) is  finite;
reconsider D25 = D23 as Function;
L40:
now
let R7 being set;
assume L41: R7 in D24;
consider R31 being (Element of ( NAT )) such that L42: (R7 = { R30 where R30 is (Element of ( NAT )) : (not ( C4 . R31 ) in ( D23 . R30 )) } & R31 in ( dom C4 )) by L41;
reconsider D26 = ( dom C4 ) as non  empty set by L42;
L43: ( rng C4 ) c= D22 by RELAT_1:def 19;
reconsider D27 = C4 as (Function of D26 , D22) by L43 , FUNCT_2:2;
reconsider D28 = R31 as (Element of D26) by L42;
consider C5 being (Element of ( NAT )) such that L44: ( D27 . D28 ) in ( D25 . C5 ) by FOMODEL1:5;
L45: R7 c= C5 by L27 , L42 , L44;
thus L46: R7 is  finite by L45;
end;
L47: D24 is  finite from FRAENKEL:sch 21(L39);
reconsider D29 = D24 as  finite  finite-membered set by L47 , L40 , FINSET_1:def 6;
reconsider D30 = ( union D29 ) as  finite set;
consider R7 being set such that L48: R7 in ( ( NAT ) \ D30 ) by XBOOLE_0:def 1;
reconsider D31 = R7 as (Element of ( NAT )) by L48;
take D31;
L49:
now
let C6 being set;
assume L50: C6 in ( dom C4 );
reconsider D32 = C6 as (Element of ( NAT )) by L50;
L51: ((not ( C4 . C6 ) in ( D23 . D31 )) implies D31 in D30)
proof
assume L52: (not ( C4 . C6 ) in ( D23 . D31 ));
L53: (D31 in H1(C6) & H1(D32) in D24) by L52 , L50;
thus L54: D31 in D30 by L53 , TARSKI:def 4;
end;
thus L55: ( C4 . C6 ) in ( D23 . D31 ) by L51 , L48 , XBOOLE_0:def 5;
end;
L56: C4 is (Function of ( dom C4 ) , ( D23 . D31 )) by L49 , FUNCT_2:3;
L57: C4 is (FinSequence of ( D23 . D31 )) by L56 , FOMODEL0:26;
thus L58: thesis by L57 , FINSEQ_1:def 11;
end;
registration
let R38 being Language;
let C7 being  termal (Element of R38);
let C8 being ( abs ( ar C7 ) ) -element (Element of ( ( AllTermsOf R38 ) * ));
cluster ( C7 -compound C8 ) ->  termal for (string of R38);
coherence
proof
set D33 = ( R38 -termsOfMaxDepth );
set D34 = ( abs ( ar C7 ) );
consider R30 being (Element of ( NAT )) such that L59: C8 is (Element of ( ( D33 . R30 ) * )) by L38;
reconsider D35 = C8 as D34 -element (Element of ( ( D33 . R30 ) * )) by L59;
L60: ( C7 -compound D35 ) is ( R30 + 1 ) -termal ( R30 + 1 ) -termal ( R30 + 1 ) -termal ( R30 + 1 ) -termal (string of R38);
thus L61: thesis by L60;
end;
end;
registration
let R38 being Language;
let C9 being  relational (Element of R38);
let C10 being ( abs ( ar C9 ) ) -element (Element of ( ( AllTermsOf R38 ) * ));
cluster ( C9 -compound C10 ) ->  0wff for (string of R38);
coherence by FOMODEL1:def 35;
end;
definition
let R38 being Language;
let R41 being (Element of R38);
func R41 -compound -> (Function of ( ( ( ( AllSymbolsOf R38 ) * ) \ { ( {} ) } ) * ) , ( ( ( AllSymbolsOf R38 ) * ) \ { ( {} ) } )) means 
:L64: (for B4 being (Element of ( ( ( ( AllSymbolsOf R38 ) * ) \ { ( {} ) } ) * )) holds ( it . B4 ) = ( R41 -compound B4 ));
existence
proof
set D36 = ( AllSymbolsOf R38 );
deffunc H2((Element of ( ( ( D36 * ) \ { ( {} ) } ) * ))) = ( R41 -compound $1 );
consider C11 being (Function of ( ( ( D36 * ) \ { ( {} ) } ) * ) , ( ( D36 * ) \ { ( {} ) } )) such that L65: (for B5 being (Element of ( ( ( D36 * ) \ { ( {} ) } ) * )) holds ( C11 . B5 ) = H2(B5)) from FUNCT_2:sch 4;
take C11;
thus L66: thesis by L65;
end;
uniqueness
proof
set D37 = ( AllSymbolsOf R38 );
let C12 , C13 being (Function of ( ( ( D37 * ) \ { ( {} ) } ) * ) , ( ( D37 * ) \ { ( {} ) } ));
assume that
L67: (for B6 being (Element of ( ( ( D37 * ) \ { ( {} ) } ) * )) holds ( C12 . B6 ) = ( R41 -compound B6 ))
and
L68: (for B7 being (Element of ( ( ( D37 * ) \ { ( {} ) } ) * )) holds ( C13 . B7 ) = ( R41 -compound B7 ));
L69:
now
let C14 being (Element of ( ( ( D37 * ) \ { ( {} ) } ) * ));
thus L70: ( C12 . C14 ) = ( R41 -compound C14 ) by L67
.= ( C13 . C14 ) by L68;
end;
thus L71: C12 = C13 by L69 , FUNCT_2:def 7;
end;
end;
registration
let R38 being Language;
let C15 being  termal (Element of R38);
cluster ( ( C15 -compound ) | ( ( abs ( ar C15 ) ) -tuples_on ( AllTermsOf R38 ) ) ) -> ( AllTermsOf R38 ) -valued;
coherence
proof
set D38 = ( AllSymbolsOf R38 );
set D39 = ( AllTermsOf R38 );
set D40 = ( abs ( ar C15 ) );
set D41 = ( D40 -tuples_on D39 );
set D42 = ( C15 -compound );
set D43 = ( D42 | D41 );
L73:
now
let R10 being set;
assume L74: R10 in ( rng D43 );
L75: R10 in ( D42 .: D41 ) by L74 , RELAT_1:115;
consider C16 being set such that L76: (C16 in ( dom D42 ) & C16 in D41 & R10 = ( D42 . C16 )) by L75 , FUNCT_1:def 6;
reconsider D44 = C16 as D40 -element (FinSequence of D39) by L76 , FOMODEL0:12;
reconsider D45 = D44 as D40 -element (Element of ( D39 * )) by FINSEQ_1:def 11;
reconsider D46 = ( ( D38 * ) \ { ( {} ) } ) as (Subset of ( D38 * ));
L77: D45 is (Element of ( D46 * ));
L78: (( C15 -compound D45 ) is  termal  termal  termal  termal (string of R38) & D45 is (Element of ( ( D38 * ) * ))) by L77;
L79: ( D42 . D45 ) is  termal  termal  termal  termal (string of R38) by L78 , L64;
thus L80: R10 in D39 by L79 , L76 , FOMODEL1:def 32;
end;
L81: ( rng D43 ) c= D39 by L73 , TARSKI:def 3;
thus L82: thesis by L81 , RELAT_1:def 19;
end;
end;
registration
let R38 being Language;
let C17 being  relational (Element of R38);
cluster ( ( C17 -compound ) | ( ( abs ( ar C17 ) ) -tuples_on ( AllTermsOf R38 ) ) ) -> ( AtomicFormulasOf R38 ) -valued;
coherence
proof
set D47 = ( AllSymbolsOf R38 );
set D48 = ( AllTermsOf R38 );
set D49 = ( abs ( ar C17 ) );
set D50 = ( D49 -tuples_on D48 );
set D51 = ( C17 -compound );
set D52 = ( D51 | D50 );
set D53 = ( AtomicFormulasOf R38 );
L84:
now
let R10 being set;
assume L85: R10 in ( rng D52 );
L86: R10 in ( D51 .: D50 ) by L85 , RELAT_1:115;
consider C18 being set such that L87: (C18 in ( dom D51 ) & C18 in D50 & R10 = ( D51 . C18 )) by L86 , FUNCT_1:def 6;
reconsider D54 = C18 as D49 -element (FinSequence of D48) by L87 , FOMODEL0:12;
reconsider D55 = D54 as D49 -element (Element of ( D48 * )) by FINSEQ_1:def 11;
reconsider D56 = ( ( D47 * ) \ { ( {} ) } ) as (Subset of ( D47 * ));
L88: D55 is (Element of ( D56 * ));
L89: (( C17 -compound D55 ) is  0wff  0wff  0wff  0wff (string of R38) & D55 is (Element of ( ( D47 * ) * ))) by L88;
L90: ( D51 . D55 ) is  0wff  0wff  0wff  0wff (string of R38) by L89 , L64;
thus L91: R10 in D53 by L90 , L87;
end;
L92: ( rng D52 ) c= D53 by L84 , TARSKI:def 3;
thus L93: thesis by L92 , RELAT_1:def 19;
end;
end;
definition
let R38 being Language;
let C19 being  ofAtomicFormula (Element of R38);
let C20 being set;
func C20 -freeInterpreter C19 equals 
:L95: ( ( C19 -compound ) | ( ( abs ( ar C19 ) ) -tuples_on ( AllTermsOf R38 ) ) ) if (not C19 is  relational) otherwise ( ( ( C19 -compound ) | ( ( abs ( ar C19 ) ) -tuples_on ( AllTermsOf R38 ) ) ) * (( chi (C20 , ( AtomicFormulasOf R38 )) ) qua Relation) );
coherence;
consistency;
end;
definition
let R38 being Language;
let C21 being  ofAtomicFormula (Element of R38);
let C22 being set;
redefine func C22 -freeInterpreter C21 -> (Interpreter of C21 , ( AllTermsOf R38 ));

coherence
proof
set D57 = ( AllTermsOf R38 );
set D58 = ( abs ( ar C21 ) );
set D59 = ( AllSymbolsOf R38 );
set D60 = ( C22 -freeInterpreter C21 );
set D61 = ( AtomicFormulasOf R38 );
reconsider D62 = ( ( D59 * ) \ { ( {} ) } ) as (Subset of ( D59 * ));
L97: ( D58 -tuples_on D57 ) c= ( D57 * ) by FINSEQ_2:142;
L98: ( D58 -tuples_on D57 ) c= ( D62 * ) by L97 , XBOOLE_1:1;
reconsider D63 = ( ( C21 -compound ) | ( D58 -tuples_on D57 ) ) as (Function of ( D58 -tuples_on D57 ) , ( ( D59 * ) \ { ( {} ) } )) by L98 , FUNCT_2:32;
per cases ;
suppose L99: C21 is  relational;

reconsider D64 = C21 as  relational (Element of R38) by L99;
L100: ( ( D64 -compound ) | ( ( abs ( ar D64 ) ) -tuples_on D57 ) ) is D61 -valued;
L101: ( rng D63 ) c= D61 by L100 , RELAT_1:def 19;
reconsider D65 = D63 as (Function of ( D58 -tuples_on D57 ) , D61) by L101 , RELSET_1:6;
reconsider D66 = ( chi (C22 , D61) ) as (Function of D61 , ( BOOLEAN ));
L102: ( D66 * D65 ) is (Function of ( D58 -tuples_on D57 ) , ( BOOLEAN ));
L103: D60 is (Function of ( D58 -tuples_on D57 ) , ( BOOLEAN )) by L102 , L99 , L95;
thus L104: thesis by L103 , L99 , FOMODEL2:def 2;
end;
suppose L105: (not C21 is  relational);

reconsider D67 = C21 as non  relational  ofAtomicFormula (Element of R38) by L105;
L106: ( ( D67 -compound ) | ( ( abs ( ar D67 ) ) -tuples_on D57 ) ) is D57 -valued;
L107: ( rng D63 ) c= D57 by L106 , RELAT_1:def 19;
L108: D63 is (Function of ( D58 -tuples_on D57 ) , D57) by L107 , RELSET_1:6;
L109: D60 is (Function of ( D58 -tuples_on D57 ) , D57) by L108 , L105 , L95;
thus L110: thesis by L109 , L105 , FOMODEL2:def 2;
end;
end;
end;
definition
let R38 being Language;
let R4 being set;
func (R38 , R4) -freeInterpreter -> Function means 
:L113: (( dom it ) = ( OwnSymbolsOf R38 ) & (for B8 being  own (Element of R38) holds ( it . B8 ) = ( R4 -freeInterpreter B8 )));
existence
proof
set D68 = ( OwnSymbolsOf R38 );
set D69 = ( AllSymbolsOf R38 );
defpred S1[ set , set ] means (for B9 being  own (Element of R38) holds ($1 = B9 implies $2 = ( R4 -freeInterpreter B9 )));
L114: (for R7 being set holds (R7 in D68 implies (ex R10 being set st S1[ R7 , R10 ])))
proof
let R7 being set;
assume L115: R7 in D68;
reconsider D70 = R7 as  own (Element of R38) by L115 , FOMODEL1:def 19;
take D71 = ( R4 -freeInterpreter D70 );
thus L116: (for B10 being  own (Element of R38) holds (R7 = B10 implies D71 = ( R4 -freeInterpreter B10 )));
end;
consider C23 being Function such that L117: (( dom C23 ) = D68 & (for R7 being set holds (R7 in D68 implies S1[ R7 , ( C23 . R7 ) ]))) from CLASSES1:sch 1(L114);
take C23;
thus L118: ( dom C23 ) = D68 by L117;
thus L119: (for B11 being  own (Element of R38) holds ( C23 . B11 ) = ( R4 -freeInterpreter B11 ))
proof
let C24 being  own (Element of R38);
L120: (C24 in D68 & C24 = C24) by FOMODEL1:def 19;
thus L121: thesis by L120 , L117;
end;

end;
uniqueness
proof
set D72 = ( OwnSymbolsOf R38 );
set D73 = ( AllSymbolsOf R38 );
let C25 , C26 being Function;
assume L120: (( dom C25 ) = D72 & (for B12 being  own (Element of R38) holds ( C25 . B12 ) = ( R4 -freeInterpreter B12 )));
assume L121: (( dom C26 ) = D72 & (for B13 being  own (Element of R38) holds ( C26 . B13 ) = ( R4 -freeInterpreter B13 )));
L122:
now
thus L123: ( dom C25 ) = ( dom C26 ) by L120 , L121;
let R7 being set;
assume L124: R7 in ( dom C25 );
reconsider D74 = R7 as  own (Element of R38) by L124 , L120 , FOMODEL1:def 19;
L125: ( C25 . D74 ) = ( R4 -freeInterpreter D74 ) by L120
.= ( C26 . D74 ) by L121;
thus L126: ( C25 . R7 ) = ( C26 . R7 ) by L125;
end;
thus L127: thesis by L122 , FUNCT_1:2;
end;
end;
registration
let R38 being Language;
let R4 being set;
cluster ( (R38 , R4) -freeInterpreter ) ->  Function-yielding for Function;
coherence
proof
set D75 = ( OwnSymbolsOf R38 );
set D76 = ( (R38 , R4) -freeInterpreter );
L129:
now
let R7 being set;
assume L130: R7 in ( dom D76 );
L131: R7 in D75 by L130 , L113;
reconsider D77 = R7 as  own (Element of R38) by L131 , FOMODEL1:def 19;
L132: ( R4 -freeInterpreter D77 ) is Function;
thus L133: ( D76 . R7 ) is Function by L132 , L113;
end;
thus L134: thesis by L129 , FUNCOP_1:def 6;
end;
end;
definition
let R38 being Language;
let R4 being set;
redefine func (R38 , R4) -freeInterpreter -> (Interpreter of R38 , ( AllTermsOf R38 ));

coherence
proof
set D78 = ( (R38 , R4) -freeInterpreter );
set D79 = ( AllTermsOf R38 );
L136: (for B14 being  own (Element of R38) holds ( D78 . B14 ) is (Interpreter of B14 , D79))
proof
let C27 being  own (Element of R38);
L137: ( R4 -freeInterpreter C27 ) is (Interpreter of C27 , D79);
thus L138: thesis by L137 , L113;
end;
thus L139: thesis by L136 , FOMODEL2:def 3;
end;
end;
registration
let R38 being Language;
let R4 being set;
cluster ( (R38 , R4) -freeInterpreter ) -> (R38 , ( AllTermsOf R38 ))-interpreter-like for Function;
coherence by FOMODEL2:def 4;
end;
definition
let R38 being Language;
let R4 being set;
redefine func (R38 , R4) -freeInterpreter -> (Element of ( ( AllTermsOf R38 ) -InterpretersOf R38 ));

coherence
proof
set D80 = ( (R38 , R4) -freeInterpreter );
set D81 = ( AllTermsOf R38 );
set D82 = ( OwnSymbolsOf R38 );
L142: ( dom D80 ) c= D82 by L113;
L143: ( D80 | D82 ) = D80 by L142 , RELAT_1:68;
thus L144: thesis by L143 , FOMODEL2:2;
end;
end;
definition
let C28 , C29 being non  empty set;
let C30 being (Relation of C28 , C29);
let C31 being Nat;
func C31 -placesOf C30 -> (Relation of ( C31 -tuples_on C28 ) , ( C31 -tuples_on C29 )) equals 
{ [ B15 , B16 ] where B15 is (Element of ( C31 -tuples_on C28 )) , B16 is (Element of ( C31 -tuples_on C29 )) : (for B17 being set holds (B17 in ( Seg C31 ) implies [ ( B15 . B17 ) , ( B16 . B17 ) ] in C30)) };
coherence
proof
set D83 = ( C31 -tuples_on C28 );
set D84 = ( C31 -tuples_on C29 );
set D85 = { [ B18 , B19 ] where B18 is (Element of ( C31 -tuples_on C28 )) , B19 is (Element of ( C31 -tuples_on C29 )) : (for B20 being set holds (B20 in ( Seg C31 ) implies [ ( B18 . B20 ) , ( B19 . B20 ) ] in C30)) };
L146:
now
let C32 being set;
assume L147: C32 in D85;
consider C33 being (Element of D83), C34 being (Element of D84) such that L148: (C32 = [ C33 , C34 ] & (for B21 being set holds (B21 in ( Seg C31 ) implies [ ( C33 . B21 ) , ( C34 . B21 ) ] in C30))) by L147;
thus L149: C32 in [: D83 , D84 :] by L148;
end;
thus L150: thesis by L146 , TARSKI:def 3;
end;
end;
L152: (for B22 being  zero Nat holds (for B23 , B24 being non  empty set holds (for B25 being (Relation of B23 , B24) holds ( B22 -placesOf B25 ) = { [ ( {} ) , ( {} ) ] })))
proof
let C35 being  zero Nat;
let C36 , C37 being non  empty set;
let C38 being (Relation of C36 , C37);
set D86 = ( C35 -placesOf C38 );
L153: [: ( C35 -tuples_on C36 ) , ( C35 -tuples_on C37 ) :] = [: { ( {} ) } , ( ( 0 ) -tuples_on C37 ) :] by FOMODEL0:10
.= [: { ( {} ) } , { ( {} ) } :] by FOMODEL0:10
.= { [ ( {} ) , ( {} ) ] } by ZFMISC_1:29;
L154: ( {} ) in { ( {} ) } by TARSKI:def 1;
reconsider D87 = ( {} ) as (Element of ( C35 -tuples_on C36 )) by L154 , FOMODEL0:10;
L155: ( {} ) in { ( {} ) } by TARSKI:def 1;
reconsider D88 = ( {} ) as (Element of ( C35 -tuples_on C37 )) by L155 , FOMODEL0:10;
L156: (for B26 being set holds (B26 in ( Seg ( 0 ) ) implies [ ( D87 . B26 ) , ( D88 . B26 ) ] in C38));
L157: [ D87 , D88 ] in D86 by L156;
L158: { [ ( {} ) , ( {} ) ] } c= D86 by L157 , ZFMISC_1:31;
thus L159: D86 = { [ ( {} ) , ( {} ) ] } by L158 , L153 , XBOOLE_0:def 10;
end;
registration
let C39 , C40 being non  empty set;
let C41 being  total (Relation of C39 , C40);
let C42 being non  zero Nat;
cluster ( C42 -placesOf C41 ) ->  total for (Relation of ( C42 -tuples_on C39 ) , ( C42 -tuples_on C40 ));
coherence
proof
set D89 = ( C42 -placesOf C41 );
set D90 = ( C42 -tuples_on C39 );
L160: ( dom C41 ) = C39 by PARTFUN1:def 2;
reconsider D91 = C42 as (Element of ( NAT )) by ORDINAL1:def 12;
L161:
now
let C43 being set;
assume L162: C43 in D90;
reconsider D92 = C43 as (Element of D90) by L162;
reconsider D93 = D92 as (Element of ( Funcs (( Seg C42 ) , C39) )) by FOMODEL0:11;
defpred S2[ set , set ] means [ ( D92 . $1 ) , $2 ] in C41;
L163: (for R25 being Nat holds (R25 in ( Seg C42 ) implies (ex B27 being (Element of C40) st S2[ R25 , B27 ])))
proof
let R25 being Nat;
assume L164: R25 in ( Seg C42 );
reconsider D94 = R25 as (Element of ( Seg C42 )) by L164;
L165: ( D93 . D94 ) in ( dom C41 ) by L160;
consider R10 being set such that L166: [ ( D92 . R25 ) , R10 ] in C41 by L165 , XTUPLE_0:def 12;
reconsider D95 = R10 as (Element of C40) by L166 , ZFMISC_1:87;
take D95;
thus L167: thesis by L166;
end;
consider C44 being (FinSequence of C40) such that L168: (( len C44 ) = C42 & (for R25 being Nat holds (R25 in ( Seg C42 ) implies S2[ R25 , ( C44 /. R25 ) ]))) from FINSEQ_4:sch 1(L163);
reconsider D96 = C44 as (Element of ( D91 -tuples_on C40 )) by L168 , FINSEQ_2:133;
reconsider D97 = D96 as (Element of ( Funcs (( Seg D91 ) , C40) )) by FOMODEL0:11;
L169: ( dom D97 ) = ( Seg D91 ) by FUNCT_2:def 1;
L170:
now
let C45 being set;
assume L171: C45 in ( Seg C42 );
reconsider D98 = C45 as (Element of ( NAT )) by L171;
L172: (D98 in ( dom D96 ) & S2[ D98 , ( C44 /. D98 ) ]) by L171 , L168 , L169;
thus L173: [ ( D92 . C45 ) , ( D96 . C45 ) ] in C41 by L172 , PARTFUN1:def 6;
end;
L174: [ D92 , D96 ] in D89 by L170;
thus L175: C43 in ( dom D89 ) by L174 , XTUPLE_0:def 12;
end;
L176: (D90 c= ( dom D89 ) & ( dom D89 ) c= D90) by L161 , TARSKI:def 3;
L177: ( dom D89 ) = ( C42 -tuples_on C39 ) by L176 , XBOOLE_0:def 10;
thus L178: thesis by L177 , PARTFUN1:def 2;
end;
end;
registration
let C46 , C47 being non  empty set;
let C48 being  total (Relation of C46 , C47);
let C49 being Nat;
cluster ( C49 -placesOf C48 ) ->  total for (Relation of ( C49 -tuples_on C46 ) , ( C49 -tuples_on C47 ));
coherence
proof
set D99 = ( C49 -placesOf C48 );
per cases ;
suppose L180: C49 is non  zero;

reconsider D100 = C49 as non  zero Nat by L180;
L181: ( D100 -placesOf C48 ) is  total;
thus L182: thesis by L181;
end;
suppose L183: C49 is  zero;

reconsider D101 = C49 as  zero Nat by L183;
L184: ( D101 -placesOf C48 ) = { [ ( {} ) , ( {} ) ] } by L152;
L185: ( dom D99 ) = { ( {} ) } by L184 , RELAT_1:9
.= ( D101 -tuples_on C46 ) by FOMODEL0:10;
thus L186: thesis by L185 , PARTFUN1:def 2;
end;
end;
end;
registration
let C50 , C51 being non  empty set;
let C52 being (Relation of C50 , C51);
let C53 being  zero Nat;
cluster ( C53 -placesOf C52 ) ->  Function-like for (Relation of ( C53 -tuples_on C50 ) , ( C53 -tuples_on C51 ));
coherence
proof
set D102 = ( C53 -placesOf C52 );
reconsider D103 = { [ ( {} ) , ( {} ) ] } as Function;
L189:
now
let C54 being set;
assume L190: C54 in D102;
consider C55 being (Element of ( C53 -tuples_on C50 )), C56 being (Element of ( C53 -tuples_on C51 )) such that L191: (C54 = [ C55 , C56 ] & (for B28 being set holds (B28 in ( Seg C53 ) implies [ ( C55 . B28 ) , ( C56 . B28 ) ] in C52))) by L190;
L192: (C55 = ( {} ) & C56 = ( {} ));
thus L193: C54 in D103 by L192 , L191 , TARSKI:def 1;
end;
reconsider D104 = D102 as (Subset of D103) by L189 , TARSKI:def 3;
L194: D104 is  Function-like;
thus L195: thesis by L194;
end;
end;
definition
let C57 being non  empty set;
let C58 being (Relation of C57);
let C59 being Nat;
func C59 -placesOf C58 -> (Relation of ( C59 -tuples_on C57 )) equals 
( C59 -placesOf (C58 qua (Relation of C57 , C57)) );
coherence;
end;
definition
let C60 being non  empty set;
let C61 being (Relation of C60);
let C62 being  zero Nat;
redefine func C62 -placesOf C61 -> (Relation of ( C62 -tuples_on C60 )) equals 
{ [ ( {} ) , ( {} ) ] };
coherence;
compatibility by L152;
end;
L199: (for B29 being non  zero Nat holds (for B30 being non  empty set holds (for B31 , B32 being (Element of ( Funcs (( Seg B29 ) , B30) )) holds (for B33 being (Relation of B30) holds ([ B31 , B32 ] in ( B29 -placesOf B33 ) iff (for B34 being (Element of ( Seg B29 )) holds [ ( B31 . B34 ) , ( B32 . B34 ) ] in B33))))))
proof
let C63 being non  zero Nat;
let C64 being non  empty set;
let C65 , C66 being (Element of ( Funcs (( Seg C63 ) , C64) ));
let C67 being (Relation of C64);
reconsider D105 = C65 as (Element of ( C63 -tuples_on C64 )) by FINSEQ_2:93;
reconsider D106 = C66 as (Element of ( C63 -tuples_on C64 )) by FINSEQ_2:93;
thus L200: ([ C65 , C66 ] in ( C63 -placesOf C67 ) implies (for B35 being (Element of ( Seg C63 )) holds [ ( C65 . B35 ) , ( C66 . B35 ) ] in C67))
proof
assume L201: [ C65 , C66 ] in ( C63 -placesOf C67 );
consider C68 , C69 being (Element of ( C63 -tuples_on C64 )) such that L202: ([ C65 , C66 ] = [ C68 , C69 ] & (for B36 being set holds (B36 in ( Seg C63 ) implies [ ( C68 . B36 ) , ( C69 . B36 ) ] in C67))) by L201;
L203: (C65 = C68 & C66 = C69) by L202 , XTUPLE_0:1;
thus L204: thesis by L203 , L202;
end;

thus L205: ((for B37 being (Element of ( Seg C63 )) holds [ ( C65 . B37 ) , ( C66 . B37 ) ] in C67) implies [ C65 , C66 ] in ( C63 -placesOf C67 ))
proof
assume L206: (for B38 being (Element of ( Seg C63 )) holds [ ( C65 . B38 ) , ( C66 . B38 ) ] in C67);
L207: (for B39 being set holds (B39 in ( Seg C63 ) implies [ ( D105 . B39 ) , ( D106 . B39 ) ] in C67)) by L206;
thus L208: thesis by L207;
end;

end;
L206: (for B40 being non  zero Nat holds (for B41 being non  empty set holds (for B42 being  total  symmetric (Relation of B41) holds ( B40 -placesOf B42 ) is  symmetric  total  symmetric  total  symmetric  total  symmetric  total (Relation of ( B40 -tuples_on B41 )))))
proof
let C70 being non  zero Nat;
let C71 being non  empty set;
let C72 being  total  symmetric (Relation of C71);
L207: ( field C72 ) = C71 by ORDERS_1:12;
set D107 = ( C70 -placesOf C72 );
L208: ( field D107 ) = ( C70 -tuples_on C71 ) by ORDERS_1:12;
L209:
now
let C73 , C74 being set;
assume L210: C73 in ( C70 -tuples_on C71 );
reconsider D108 = C73 as (Element of ( Funcs (( Seg C70 ) , C71) )) by L210 , FINSEQ_2:93;
assume L211: C74 in ( C70 -tuples_on C71 );
reconsider D109 = C74 as (Element of ( Funcs (( Seg C70 ) , C71) )) by L211 , FINSEQ_2:93;
assume L212: [ C73 , C74 ] in D107;
L213: C72 is_symmetric_in C71 by L207 , RELAT_2:def 11;
L214:
now
let C75 being (Element of ( Seg C70 ));
L215: (( D108 . C75 ) in C71 & ( D109 . C75 ) in C71 & [ ( D108 . C75 ) , ( D109 . C75 ) ] in C72) by L199 , L212;
thus L216: [ ( D109 . C75 ) , ( D108 . C75 ) ] in C72 by L215 , L213 , RELAT_2:def 3;
end;
thus L217: [ C74 , C73 ] in D107 by L214 , L199;
end;
L218: D107 is_symmetric_in ( C70 -tuples_on C71 ) by L209 , RELAT_2:def 3;
thus L219: thesis by L218 , L208 , RELAT_2:def 11;
end;
L220: (for B43 being non  zero Nat holds (for B44 being non  empty set holds (for B45 being  transitive  total (Relation of B44) holds ( B43 -placesOf B45 ) is  transitive  total  transitive  total  transitive  total  transitive  total (Relation of ( B43 -tuples_on B44 )))))
proof
let C76 being non  zero Nat;
let C77 being non  empty set;
let C78 being  transitive  total (Relation of C77);
L221: ( field C78 ) = C77 by ORDERS_1:12;
set D110 = ( C76 -placesOf C78 );
L222: ( field D110 ) = ( C76 -tuples_on C77 ) by ORDERS_1:12;
L223:
now
let C79 , C80 , C81 being set;
assume L224: C79 in ( C76 -tuples_on C77 );
reconsider D111 = C79 as (Element of ( Funcs (( Seg C76 ) , C77) )) by L224 , FINSEQ_2:93;
assume L225: C80 in ( C76 -tuples_on C77 );
reconsider D112 = C80 as (Element of ( Funcs (( Seg C76 ) , C77) )) by L225 , FINSEQ_2:93;
assume L226: C81 in ( C76 -tuples_on C77 );
reconsider D113 = C81 as (Element of ( Funcs (( Seg C76 ) , C77) )) by L226 , FINSEQ_2:93;
assume L227: [ C79 , C80 ] in D110;
assume L228: [ C80 , C81 ] in D110;
L229: C78 is_transitive_in C77 by L221 , RELAT_2:def 16;
L230:
now
let C82 being (Element of ( Seg C76 ));
L231: (( D111 . C82 ) in C77 & ( D112 . C82 ) in C77 & ( D113 . C82 ) in C77 & [ ( D111 . C82 ) , ( D112 . C82 ) ] in C78 & [ ( D112 . C82 ) , ( D113 . C82 ) ] in C78) by L199 , L227 , L228;
thus L232: [ ( D111 . C82 ) , ( D113 . C82 ) ] in C78 by L231 , L229 , RELAT_2:def 8;
end;
thus L233: [ C79 , C81 ] in D110 by L230 , L199;
end;
L234: D110 is_transitive_in ( C76 -tuples_on C77 ) by L223 , RELAT_2:def 8;
thus L235: thesis by L234 , L222 , RELAT_2:def 16;
end;
L236: (for B46 being  zero Nat holds (for B47 being non  empty set holds (for B48 being (Relation of B47) holds ( B46 -placesOf B48 ) is  total  symmetric  transitive  total  symmetric  transitive  total  symmetric  transitive  total  symmetric  transitive (Relation of ( B46 -tuples_on B47 )))))
proof
let C83 being  zero Nat;
let C84 being non  empty set;
let C85 being (Relation of C84);
set D114 = ( C83 -placesOf C85 );
L237:
now
let C86 being set;
assume L238: C86 in ( C83 -tuples_on C84 );
L239: C86 = ( {} ) by L238;
L240: [ C86 , C86 ] in D114 by L239 , TARSKI:def 1;
thus L241: (ex B49 being set st [ C86 , B49 ] in D114) by L240;
end;
L242: ( dom D114 ) = ( C83 -tuples_on C84 ) by L237 , RELSET_1:9;
L243: D114 is  total by L242 , PARTFUN1:def 2;
L244: ( field D114 ) = ( C83 -tuples_on C84 ) by L243 , ORDERS_1:12;
L245:
now
let C87 , C88 being set;
assume L246: C87 in ( C83 -tuples_on C84 );
L247: C87 = ( {} ) by L246;
assume L248: C88 in ( C83 -tuples_on C84 );
L249: C88 = ( {} ) by L248;
assume L250: [ C87 , C88 ] in D114;
thus L251: [ C88 , C87 ] in D114 by L247 , L249 , TARSKI:def 1;
end;
L252: D114 is_symmetric_in ( C83 -tuples_on C84 ) by L245 , RELAT_2:def 3;
L253: (for B50 , B51 , B52 being set holds ((B50 in ( C83 -tuples_on C84 ) & B51 in ( C83 -tuples_on C84 ) & B52 in ( C83 -tuples_on C84 ) & [ B50 , B51 ] in D114 & [ B51 , B52 ] in D114) implies [ B50 , B52 ] in D114));
L254: D114 is_transitive_in ( C83 -tuples_on C84 ) by L253 , RELAT_2:def 8;
thus L255: thesis by L242 , L252 , L244 , L254 , PARTFUN1:def 2 , RELAT_2:def 11 , RELAT_2:def 16;
end;
registration
let C89 being non  empty set;
let C90 being  symmetric  total (Relation of C89);
let R26 being Nat;
cluster ( R26 -placesOf C90 ) ->  total for (Relation of ( R26 -tuples_on C89 ));
coherence;
end;
registration
let C91 being non  empty set;
let C92 being  symmetric  total (Relation of C91);
let R26 being Nat;
cluster ( R26 -placesOf C92 ) ->  symmetric for (Relation of ( R26 -tuples_on C91 ));
coherence
proof
per cases ;
suppose L257: R26 is  zero;

thus L258: thesis by L257 , L236;
end;
suppose L259: (not R26 is  zero);

thus L260: thesis by L259 , L206;
end;
end;
end;
registration
let C93 being non  empty set;
let C94 being  symmetric  total (Relation of C93);
let R26 being Nat;
cluster ( R26 -placesOf C94 ) ->  symmetric  total for (Relation of ( R26 -tuples_on C93 ));
coherence;
end;
registration
let C95 being non  empty set;
let C96 being  transitive  total (Relation of C95);
let R26 being Nat;
cluster ( R26 -placesOf C96 ) ->  transitive  total for (Relation of ( R26 -tuples_on C95 ));
coherence
proof
per cases ;
suppose L264: R26 is  zero;

thus L265: thesis by L264 , L236;
end;
suppose L266: (not R26 is  zero);

thus L267: thesis by L266 , L220;
end;
end;
end;
registration
let C97 being non  empty set;
let C98 being (Equivalence_Relation of C97);
let R26 being Nat;
cluster ( R26 -placesOf C98 ) ->  total  symmetric  transitive for (Relation of ( R26 -tuples_on C97 ));
coherence;
end;
definition
let C99 , C100 being non  empty set;
let C101 being (Equivalence_Relation of C99);
let C102 being (Equivalence_Relation of C100);
let C103 being Relation;
func C103 quotient (C101 , C102) equals 
{ [ B53 , B54 ] where B53 is (Element of ( Class C101 )) , B54 is (Element of ( Class C102 )) : (ex B55 , B56 being set st (B55 in B53 & B56 in B54 & [ B55 , B56 ] in C103)) };
coherence;
end;
definition
let C104 , C105 being non  empty set;
let C106 being (Equivalence_Relation of C104);
let C107 being (Equivalence_Relation of C105);
let C108 being Relation;
redefine func C108 quotient (C106 , C107) -> (Relation of ( Class C106 ) , ( Class C107 ));

coherence
proof
set D115 = ( C108 quotient (C106 , C107) );
L272:
now
let R7 being set;
assume L273: R7 in D115;
consider C109 being (Element of ( Class C106 )), C110 being (Element of ( Class C107 )) such that L274: (R7 = [ C109 , C110 ] & (ex B57 , B58 being set st (B57 in C109 & B58 in C110 & [ B57 , B58 ] in C108))) by L273;
thus L275: R7 in [: ( Class C106 ) , ( Class C107 ) :] by L274;
end;
thus L276: thesis by L272 , TARSKI:def 3;
end;
end;
definition
let C111 being Relation;
let C112 being Relation;
let C113 being Function;
attr C113 is C111 , C112 -respecting
means
:L278: (for B59 , B60 being set holds ([ B59 , B60 ] in C111 implies [ ( C113 . B59 ) , ( C113 . B60 ) ] in C112));
end;
definition
let R38 being Language;
let R12 being non  empty set;
let C114 being  ofAtomicFormula (Element of R38);
let C115 being (Relation of R12);
let C116 being (Interpreter of C114 , R12);
attr C116 is C115 -respecting
means
:L280: C116 is (( ( abs ( ar C114 ) ) -placesOf C115 ) , C115)-respecting if (not C114 is  relational) otherwise C116 is (( ( abs ( ar C114 ) ) -placesOf C115 ) , ( id ( BOOLEAN ) ))-respecting;
consistency;
end;
registration
let C117 , C118 being non  empty set;
let C119 being (Equivalence_Relation of C117);
let C120 being (Equivalence_Relation of C118);
cluster (C119 , C120)-respecting for (Function of C117 , C118);
existence
proof
consider C121 being set such that L282: C121 in C118 by XBOOLE_0:7;
set D116 = ( C117 --> C121 );
L283: ({ C121 } c= C118 & ( dom D116 ) = C117 & ( rng D116 ) c= { C121 }) by L282 , FUNCOP_1:13 , ZFMISC_1:31;
reconsider D117 = D116 as (Function of C117 , C118) by L283 , FUNCT_2:2 , XBOOLE_1:1;
L284:
now
let C122 , C123 being set;
assume L285: [ C122 , C123 ] in C119;
L286: (C122 in C117 & C123 in C117) by L285 , ZFMISC_1:87;
L287: (( D117 . C122 ) = C121 & ( D117 . C123 ) = C121) by L286 , FUNCOP_1:7;
thus L288: [ ( D117 . C122 ) , ( D117 . C123 ) ] in C120 by L287 , L282 , EQREL_1:5;
end;
L289: D117 is (C119 , C120)-respecting by L284 , L278;
thus L290: thesis by L289;
end;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C124 being  ofAtomicFormula (Element of R38);
let C125 being (Equivalence_Relation of R12);
cluster C125 -respecting for (Interpreter of C124 , R12);
existence
proof
set D118 = ( abs ( ar C124 ) );
reconsider D119 = ( D118 -placesOf C125 ) as (Equivalence_Relation of ( D118 -tuples_on R12 ));
set D120 = the (( D118 -placesOf C125 ) , C125)-respecting (Function of ( D118 -tuples_on R12 ) , R12);
set D121 = the (( D118 -placesOf C125 ) , ( id ( BOOLEAN ) ))-respecting (Function of ( D118 -tuples_on R12 ) , ( BOOLEAN ));
per cases ;
suppose L292: C124 is  relational;

reconsider D122 = D121 as (Interpreter of C124 , R12) by L292 , FOMODEL2:def 2;
L293: D122 is C125 -respecting by L280 , L292;
thus L294: thesis by L293;
end;
suppose L295: (not C124 is  relational);

reconsider D123 = D120 as (Interpreter of C124 , R12) by L295 , FOMODEL2:def 2;
L296: D123 is C125 -respecting by L280 , L295;
thus L297: thesis by L296;
end;
end;
end;
registration
let C126 , C127 being non  empty set;
let C128 being (Equivalence_Relation of C126);
let C129 being (Equivalence_Relation of C127);
cluster (C128 , C129)-respecting for Function;
existence
proof
take the (C128 , C129)-respecting (Function of C126 , C127);
thus L300: thesis;
end;
end;
definition
let C130 being non  empty set;
let C131 being (Equivalence_Relation of C130);
let R26 being Nat;
redefine func R26 -placesOf C131 -> (Equivalence_Relation of ( R26 -tuples_on C130 ));

coherence;
end;
definition
let C132 being non  empty set;
let C133 being (Element of ( SmallestPartition C132 ));
func DeTrivial C133 -> (Element of C132) means 
:L303: C133 = { it };
existence
proof
set D124 = ( SmallestPartition C132 );
consider R10 being set such that L304: (C133 = { R10 } & R10 in C132) by RELSET_2:1;
reconsider D125 = R10 as (Element of C132) by L304;
take D125;
thus L305: thesis by L304;
end;
uniqueness by ZFMISC_1:3;
end;
definition
let C134 being non  empty set;
func peeler C134 -> (Function of {_{ C134 }_} , C134) means 
:L307: (for B61 being (Element of {_{ C134 }_}) holds ( it . B61 ) = ( DeTrivial B61 ));
existence
proof
deffunc H3((Element of {_{ C134 }_})) = ( DeTrivial $1 );
consider C135 being (Function of {_{ C134 }_} , C134) such that L308: (for B62 being (Element of {_{ C134 }_}) holds ( C135 . B62 ) = H3(B62)) from FUNCT_2:sch 4;
take C135;
thus L309: thesis by L308;
end;
uniqueness
proof
let C136 , C137 being (Function of {_{ C134 }_} , C134);
assume that
L310: (for B63 being (Element of {_{ C134 }_}) holds ( C136 . B63 ) = ( DeTrivial B63 ))
and
L311: (for B64 being (Element of {_{ C134 }_}) holds ( C137 . B64 ) = ( DeTrivial B64 ));
L312:
now
let C138 being (Element of {_{ C134 }_});
thus L313: ( C136 . C138 ) = ( DeTrivial C138 ) by L310
.= ( C137 . C138 ) by L311;
end;
thus L314: thesis by L312 , FUNCT_2:63;
end;
end;
registration
let C139 being non  empty set;
let C140 being (Equivalence_Relation of C139);
cluster  -> non  empty for (Element of ( Class C140 ));
coherence;
end;
L317: (for B65 being non  empty set holds (for B66 being (Equivalence_Relation of B65) holds (for B67 , B68 being set holds (for B69 being (Element of ( Class B66 )) holds ((B67 in B69 & B68 in B69) implies [ B67 , B68 ] in B66)))))
proof
let C141 being non  empty set;
let C142 being (Equivalence_Relation of C141);
let C143 , C144 being set;
let C145 being (Element of ( Class C142 ));
assume L318: (C143 in C145 & C144 in C145);
reconsider D126 = C142 as  transitive (Tolerance of C141);
consider C146 being set such that L319: (C146 in C141 & C145 = ( Class (C142 , C146) )) by EQREL_1:def 3;
thus L320: thesis by L318 , L319 , EQREL_1:22;
end;
L321: (for B70 being non  empty set holds (for B71 being (Equivalence_Relation of B70) holds (for B72 , B73 being (Element of ( Class B71 )) holds (for B74 , B75 being set holds ((B74 in B72 & B75 in B73 & [ B74 , B75 ] in B71) implies B72 = B73)))))
proof
let C147 being non  empty set;
let C148 being (Equivalence_Relation of C147);
let C149 , C150 being (Element of ( Class C148 ));
let C151 , C152 being set;
reconsider D127 = C148 as (Tolerance of C147);
assume L322: C151 in C149;
reconsider D128 = C151 as (Element of C147) by L322;
L323: D128 in C147;
L324: C151 in ( Class (D127 , C151) ) by L323 , EQREL_1:20;
L325: C149 meets ( EqClass (C148 , D128) ) by L324 , L322 , XBOOLE_0:3;
L326: C149 = ( EqClass (C148 , D128) ) by L325 , EQREL_1:def 4;
assume L327: C152 in C150;
reconsider D129 = C152 as (Element of C147) by L327;
L328: D129 in C147;
L329: C152 in ( Class (D127 , C152) ) by L328 , EQREL_1:20;
L330: C150 meets ( EqClass (C148 , D129) ) by L329 , L327 , XBOOLE_0:3;
L331: C150 = ( EqClass (C148 , D129) ) by L330 , EQREL_1:def 4;
assume L332: [ C151 , C152 ] in C148;
thus L333: thesis by L332 , L326 , L331 , EQREL_1:35;
end;
registration
let C153 , C154 being non  empty set;
let C155 being (Equivalence_Relation of C153);
let C156 being (Equivalence_Relation of C154);
let C157 being (C155 , C156)-respecting Function;
cluster ( C157 quotient (C155 , C156) ) ->  Function-like for Relation;
coherence
proof
set D130 = ( C157 quotient (C155 , C156) );
reconsider D131 = ( Class C155 ) as (a_partition of C153);
reconsider D132 = C155 as (Relation of C153 , C153);
L334:
now
let C158 , C159 , C160 being set;
assume L335: [ C158 , C159 ] in D130;
consider C161 being (Element of ( Class C155 )), C162 being (Element of ( Class C156 )) such that L336: ([ C158 , C159 ] = [ C161 , C162 ] & (ex B76 , B77 being set st (B76 in C161 & B77 in C162 & [ B76 , B77 ] in C157))) by L335;
consider C163 , C164 being set such that L337: (C163 in C161 & C164 in C162 & [ C163 , C164 ] in C157) by L336;
assume L338: [ C158 , C160 ] in D130;
consider C165 being (Element of ( Class C155 )), C166 being (Element of ( Class C156 )) such that L339: ([ C158 , C160 ] = [ C165 , C166 ] & (ex B78 , B79 being set st (B78 in C165 & B79 in C166 & [ B78 , B79 ] in C157))) by L338;
L340: (C161 = C158 & C165 = C158 & C162 = C159 & C166 = C160) by L336 , L339 , XTUPLE_0:1;
consider C167 , C168 being set such that L341: (C167 in C165 & C168 in C166 & [ C167 , C168 ] in C157) by L339;
L342: [ C163 , C167 ] in C155 by L317 , L337 , L341 , L340;
L343: (C168 = ( C157 . C167 ) & C164 = ( C157 . C163 )) by L341 , L337 , FUNCT_1:1;
L344: [ C164 , C168 ] in C156 by L343 , L278 , L342;
thus L345: C159 = C160 by L344 , L340 , L337 , L341 , L321;
end;
thus L346: thesis by L334 , FUNCT_1:def 1;
end;
end;
registration
let C169 , C170 being non  empty set;
let C171 being (Equivalence_Relation of C169);
let C172 being (Equivalence_Relation of C170);
let C173 being  total (Relation of C169 , C170);
cluster ( C173 quotient (C171 , C172) ) ->  total for (Relation of ( Class C171 ) , ( Class C172 ));
coherence
proof
set D133 = ( C173 quotient (C171 , C172) );
reconsider D134 = ( Class C172 ) as (a_partition of C170);
L348:
now
let C174 being set;
assume L349: C174 in ( Class C171 );
reconsider D135 = C174 as (Element of ( Class C171 )) by L349;
set D136 = the (Element of D135);
reconsider D137 = D136 as (Element of C169);
L350: ( dom C173 ) = C169 by PARTFUN1:def 2;
consider C175 being set such that L351: [ D137 , C175 ] in C173 by L350 , XTUPLE_0:def 12;
reconsider D138 = C175 as (Element of C170) by L351 , ZFMISC_1:87;
reconsider D139 = ( EqClass (D138 , D134) ) as (Element of ( Class C172 )) by EQREL_1:def 6;
L352: ([ C174 , D139 ] = [ C174 , D139 ] & D137 in C174 & C175 in D139 & [ D137 , C175 ] in C173) by L351 , EQREL_1:def 6;
L353: [ C174 , D139 ] in D133 by L352;
thus L354: C174 in ( dom D133 ) by L353 , XTUPLE_0:def 12;
end;
L355: ( Class C171 ) c= ( dom D133 ) by L348 , TARSKI:def 3;
L356: ( Class C171 ) = ( dom D133 ) by L355 , XBOOLE_0:def 10;
thus L357: thesis by L356 , PARTFUN1:def 2;
end;
end;
definition
let C176 , C177 being non  empty set;
let C178 being (Equivalence_Relation of C176);
let C179 being (Equivalence_Relation of C177);
let C180 being (C178 , C179)-respecting (Function of C176 , C177);
redefine func C180 quotient (C178 , C179) -> (Function of ( Class C178 ) , ( Class C179 ));

coherence
proof
thus L359: ( C180 quotient (C178 , C179) ) is (Function of ( Class C178 ) , ( Class C179 ));
end;
end;
definition
let C181 being non  empty set;
let C182 being (Equivalence_Relation of C181);
func C182 -class -> (Function of C181 , ( Class C182 )) means 
:L361: (for B80 being (Element of C181) holds ( it . B80 ) = ( EqClass (C182 , B80) ));
existence
proof
deffunc H4((Element of C181)) = ( EqClass (C182 , $1) );
consider C183 being (Function of C181 , ( Class C182 )) such that L362: (for B81 being (Element of C181) holds ( C183 . B81 ) = H4(B81)) from FUNCT_2:sch 4;
take C183;
thus L363: thesis by L362;
end;
uniqueness
proof
let C184 , C185 being (Function of C181 , ( Class C182 ));
assume L364: (for B82 being (Element of C181) holds ( C184 . B82 ) = ( EqClass (C182 , B82) ));
assume L365: (for B83 being (Element of C181) holds ( C185 . B83 ) = ( EqClass (C182 , B83) ));
L366:
now
let C186 being (Element of C181);
thus L367: ( C184 . C186 ) = ( EqClass (C182 , C186) ) by L364
.= ( C185 . C186 ) by L365;
end;
thus L368: thesis by L366 , FUNCT_2:63;
end;
end;
registration
let C187 being non  empty set;
let C188 being (Equivalence_Relation of C187);
cluster ( C188 -class ) ->  onto for (Function of C187 , ( Class C188 ));
coherence
proof
set D140 = ( C188 -class );
L370:
now
let C189 being set;
assume L371: C189 in ( Class C188 );
reconsider D141 = C189 as (Subset of C187) by L371;
consider C190 being set such that L372: (C190 in C187 & D141 = ( Class (C188 , C190) )) by L371 , EQREL_1:def 3;
reconsider D142 = C190 as (Element of C187) by L372;
L373: ( D140 . D142 ) = D141 by L372 , L361;
thus L374: C189 in ( rng D140 ) by L373 , FUNCT_2:4;
end;
L375: (( Class C188 ) c= ( rng D140 ) & ( rng D140 ) c= ( Class C188 )) by L370 , RELAT_1:def 19 , TARSKI:def 3;
L376: ( Class C188 ) = ( rng D140 ) by L375 , XBOOLE_0:def 10;
thus L377: thesis by L376 , FUNCT_2:def 3;
end;
end;
registration
let C191 , C192 being non  empty set;
cluster  onto for (Relation of C191 , C192);
existence
proof
L379: [: C191 , C192 :] c= [: C191 , C192 :];
reconsider D143 = [: C191 , C192 :] as (Relation of C191 , C192) by L379;
L380: ( rng D143 ) = C192 by RELAT_1:160;
L381: D143 is  onto by L380 , FUNCT_2:def 3;
thus L382: thesis by L381;
end;
end;
registration
let C193 being non  empty set;
cluster  onto for C193 -valued C193 -valued C193 -valued C193 -valued Relation;
existence
proof
take the  onto (Relation of C193 , C193);
thus L384: thesis;
end;
end;
registration
let C194 being non  empty set;
let C195 being C194 -valued Relation;
cluster ( C195 ~ ) -> C194 -defined for Relation;
coherence
proof
L386: (( rng C195 ) c= C194 & ( dom ( C195 ~ ) ) = ( rng C195 )) by RELAT_1:20;
thus L387: thesis by L386 , RELAT_1:def 18;
end;
end;
registration
let C196 being non  empty set;
let C197 being  onto C196 -valued Relation;
cluster ( C197 ~ ) ->  total for C196 -defined C196 -defined C196 -defined C196 -defined Relation;
coherence
proof
L389: ( dom ( C197 ~ ) ) = ( rng C197 ) by RELAT_1:20
.= C196 by FUNCT_2:def 3;
thus L390: thesis by L389 , PARTFUN1:def 2;
end;
end;
registration
let C198 , C199 being non  empty set;
let C200 being  onto (Relation of C198 , C199);
cluster ( C200 ~ ) ->  total for (Relation of C199 , C198);
coherence;
end;
registration
let C201 being non  empty set;
let C202 being  onto C201 -valued Relation;
cluster ( C202 ~ ) ->  total for C201 -defined C201 -defined C201 -defined C201 -defined Relation;
coherence;
end;
L394: (for R12 being non  empty set holds (for B84 being (Equivalence_Relation of R12) holds (for B85 being non  zero Nat holds ( ( B85 -placesOf ( (( B84 -class ) qua (Relation of R12 , ( Class B84 ))) ~ ) ) * ( ( B85 -placesOf B84 ) -class ) ) is  Function-like)))
proof
let R12 being non  empty set;
let C203 being (Equivalence_Relation of R12);
let C204 being non  zero Nat;
set D144 = ( C204 -placesOf C203 );
reconsider D145 = ( C203 -class ) as (Function of R12 , ( Class C203 ));
reconsider D146 = ( C203 -class ) as (Relation of R12 , ( Class C203 ));
reconsider D147 = ( D146 ~ ) as (Relation of ( Class C203 ) , R12);
reconsider D148 = ( C204 -placesOf D147 ) as (Relation of ( C204 -tuples_on ( Class C203 ) ) , ( C204 -tuples_on R12 ));
reconsider D149 = ( D144 -class ) as (Function of ( C204 -tuples_on R12 ) , ( Class ( C204 -placesOf C203 ) ));
reconsider D150 = D149 as (Relation of ( C204 -tuples_on R12 ) , ( Class ( C204 -placesOf C203 ) ));
L395:
now
let C205 , C206 , C207 being set;
assume L396: ([ C205 , C206 ] in ( D148 * D150 ) & [ C205 , C207 ] in ( D148 * D150 ));
consider C208 being set such that L397: ([ C205 , C208 ] in D148 & [ C208 , C206 ] in D150) by L396 , RELAT_1:def 8;
consider C209 being set such that L398: ([ C205 , C209 ] in D148 & [ C209 , C207 ] in D150) by L396 , RELAT_1:def 8;
L399: (( D149 . C208 ) = C206 & ( D149 . C209 ) = C207) by L397 , L398 , FUNCT_1:1;
reconsider D151 = C208 , D152 = C209 as (Element of ( C204 -tuples_on R12 )) by L397 , L398 , ZFMISC_1:87;
consider C210 being (Element of ( C204 -tuples_on ( Class C203 ) )), C211 being (Element of ( C204 -tuples_on R12 )) such that L400: ([ C205 , C208 ] = [ C210 , C211 ] & (for B86 being set holds (B86 in ( Seg C204 ) implies [ ( C210 . B86 ) , ( C211 . B86 ) ] in D147))) by L397;
consider C212 being (Element of ( C204 -tuples_on ( Class C203 ) )), C213 being (Element of ( C204 -tuples_on R12 )) such that L401: ([ C205 , C209 ] = [ C212 , C213 ] & (for B87 being set holds (B87 in ( Seg C204 ) implies [ ( C212 . B87 ) , ( C213 . B87 ) ] in D147))) by L398;
L402: (C205 = C210 & C208 = C211 & C205 = C212 & C209 = C213) by L400 , L401 , XTUPLE_0:1;
reconsider D153 = C211 as (Element of ( Funcs (( Seg C204 ) , R12) )) by FOMODEL0:11;
reconsider D154 = C213 as (Element of ( Funcs (( Seg C204 ) , R12) )) by FOMODEL0:11;
L403:
now
let C214 being set;
assume L404: C214 in ( Seg C204 );
reconsider D155 = C214 as (Element of ( Seg C204 )) by L404;
L405: ([ ( C210 . C214 ) , ( C211 . C214 ) ] in D147 & [ ( C212 . C214 ) , ( C213 . C214 ) ] in D147) by L400 , L401 , L404;
L406: ([ ( C211 . C214 ) , ( C210 . C214 ) ] in D145 & [ ( C213 . C214 ) , ( C212 . C214 ) ] in D145) by L405 , RELAT_1:def 7;
L407: (( D145 . ( C211 . D155 ) ) = ( C210 . D155 ) & ( D145 . ( C213 . D155 ) ) = ( C212 . D155 )) by L406 , FUNCT_1:1;
L408: (( Class (C203 , ( D153 . D155 )) ) = ( C210 . D155 ) & ( Class (C203 , ( D154 . D155 )) ) = ( C212 . D155 )) by L407 , L361;
thus L409: [ ( C211 . C214 ) , ( C213 . C214 ) ] in C203 by L408 , L402 , EQREL_1:35;
end;
L410: [ C208 , C209 ] in ( C204 -placesOf C203 ) by L403 , L402;
L411: (( ( D144 -class ) . D151 ) = ( Class (D144 , D151) ) & ( ( D144 -class ) . D152 ) = ( Class (D144 , D152) )) by L361;
thus L412: C206 = C207 by L411 , L410 , L399 , EQREL_1:35;
end;
thus L413: thesis by L395 , FUNCT_1:def 1;
end;
definition
let R12 being non  empty set;
let R26 being Nat;
let C215 being (Equivalence_Relation of R12);
func R26 -tuple2Class C215 -> (Relation of ( R26 -tuples_on ( Class C215 ) ) , ( Class ( R26 -placesOf C215 ) )) equals 
( ( R26 -placesOf ( (( C215 -class ) qua (Relation of R12 , ( Class C215 ))) ~ ) ) * ( ( R26 -placesOf C215 ) -class ) );
coherence;
end;
registration
let R12 being non  empty set;
let R26 being Nat;
let C216 being (Equivalence_Relation of R12);
cluster ( R26 -tuple2Class C216 ) ->  Function-like for (Relation of ( R26 -tuples_on ( Class C216 ) ) , ( Class ( R26 -placesOf C216 ) ));
coherence
proof
per cases ;
suppose L415: R26 is non  zero;

thus L416: thesis by L415 , L394;
end;
suppose L417: R26 is  zero;

reconsider D156 = R26 as  zero Nat by L417;
set D157 = ( R26 -placesOf C216 );
reconsider D158 = ( C216 -class ) as (Function of R12 , ( Class C216 ));
reconsider D159 = ( C216 -class ) as (Relation of R12 , ( Class C216 ));
reconsider D160 = ( D159 ~ ) as (Relation of ( Class C216 ) , R12);
reconsider D161 = ( D156 -placesOf D160 ) as (PartFunc of ( D156 -tuples_on ( Class C216 ) ) , ( D156 -tuples_on R12 ));
reconsider D162 = ( D157 -class ) as (Function of ( R26 -tuples_on R12 ) , ( Class ( R26 -placesOf C216 ) ));
L418: ( D161 * D162 ) is  Function-like;
thus L419: thesis by L418;
end;
end;
end;
registration
let R12 being non  empty set;
let R26 being Nat;
let C217 being (Equivalence_Relation of R12);
cluster ( R26 -tuple2Class C217 ) ->  total for (Relation of ( R26 -tuples_on ( Class C217 ) ) , ( Class ( R26 -placesOf C217 ) ));
coherence;
end;
definition
let R12 being non  empty set;
let R26 being Nat;
let C218 being (Equivalence_Relation of R12);
redefine func R26 -tuple2Class C218 -> (Function of ( R26 -tuples_on ( Class C218 ) ) , ( Class ( R26 -placesOf C218 ) ));

coherence;
end;
definition
let R38 being Language;
let R12 being non  empty set;
let C219 being  ofAtomicFormula (Element of R38);
let C220 being (Equivalence_Relation of R12);
let C221 being (Interpreter of C219 , R12);
func C221 quotient C220 equals 
:L424: ( ( ( abs ( ar C219 ) ) -tuple2Class C220 ) * ( C221 quotient (( ( abs ( ar C219 ) ) -placesOf C220 ) , C220) ) ) if (not C219 is  relational) otherwise ( ( ( ( abs ( ar C219 ) ) -tuple2Class C220 ) * ( C221 quotient (( ( abs ( ar C219 ) ) -placesOf C220 ) , ( id ( BOOLEAN ) )) ) ) * ( peeler ( BOOLEAN ) ) );
coherence;
consistency;
end;
definition
let R38 being Language;
let R12 being non  empty set;
let C222 being  ofAtomicFormula (Element of R38);
let C223 being (Equivalence_Relation of R12);
let C224 being C223 -respecting (Interpreter of C222 , R12);
redefine func C224 quotient C223 -> (Interpreter of C222 , ( Class C223 ));

coherence
proof
set D163 = ( abs ( ar C222 ) );
set D164 = ( D163 -tuples_on R12 );
set D165 = ( D163 -tuple2Class C223 );
set D166 = ( C224 quotient C223 );
reconsider D167 = ( D163 -placesOf C223 ) as (Equivalence_Relation of D164);
reconsider D168 = D165 as Relation;
per cases ;
suppose L426: (not C222 is  relational);

reconsider D169 = C224 as (D167 , C223)-respecting (Function of D164 , R12) by L426 , L280 , FOMODEL2:def 2;
reconsider D170 = ( D169 quotient (D167 , C223) ) as (Function of ( Class D167 ) , ( Class C223 ));
reconsider D171 = D170 as Relation;
reconsider D172 = D169 as Relation;
L427: D166 = ( D170 * D165 ) by L424 , L426;
thus L428: thesis by L427 , L426 , FOMODEL2:def 2;
end;
suppose L429: C222 is  relational;

reconsider D173 = C224 as (D167 , ( id ( BOOLEAN ) ))-respecting (Function of D164 , ( BOOLEAN )) by L429 , L280 , FOMODEL2:def 2;
reconsider D174 = ( peeler ( BOOLEAN ) ) as Relation;
reconsider D175 = ( D173 quotient (D167 , ( id ( BOOLEAN ) )) ) as (Function of ( Class D167 ) , {_{ ( BOOLEAN ) }_});
reconsider D176 = D175 as Relation;
reconsider D177 = D173 as Relation;
L430: D166 = ( ( peeler ( BOOLEAN ) ) * ( D175 * D165 ) ) by L429 , L424;
thus L431: thesis by L430 , L429 , FOMODEL2:def 2;
end;
end;
end;
theorem
L434: (for B88 being non  empty set holds (for B89 being (Equivalence_Relation of B88) holds (for B90 , B91 being (Element of ( Class B89 )) holds (B90 meets B91 implies B90 = B91)))) by EQREL_1:def 4;
registration
let R38 being Language;
cluster  ->  own for (Element of ( OwnSymbolsOf R38 ));
coherence by FOMODEL1:def 19;
cluster  ->  ofAtomicFormula for (Element of ( OwnSymbolsOf R38 ));
coherence;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C225 being non  relational  ofAtomicFormula (Element of R38);
let C226 being (Relation of R12);
cluster C226 -respecting -> (( ( abs ( ar C225 ) ) -placesOf C226 ) , C226)-respecting for (Interpreter of C225 , R12);
coherence by L280;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C227 being  relational (Element of R38);
let C228 being (Relation of R12);
cluster C228 -respecting -> (( ( abs ( ar C227 ) ) -placesOf C228 ) , ( id ( BOOLEAN ) ))-respecting for (Interpreter of C227 , R12);
coherence by L280;
end;
registration
let R26 being Nat;
let C229 , C230 being non  empty set;
let C231 being  Function-like (Relation of C229 , C230);
cluster ( R26 -placesOf C231 ) ->  Function-like for Relation;
coherence
proof
set D178 = ( R26 -placesOf C231 );
per cases ;
suppose L438: R26 = ( 0 );

thus L439: thesis by L438;
end;
suppose L440: R26 <> ( 0 );

reconsider D179 = R26 as non  zero Nat by L440;
L441:
now
let C232 , C233 , C234 being set;
assume L442: [ C232 , C233 ] in D178;
consider C235 being (Element of ( D179 -tuples_on C229 )), C236 being (Element of ( D179 -tuples_on C230 )) such that L443: ([ C232 , C233 ] = [ C235 , C236 ] & (for B92 being set holds (B92 in ( Seg D179 ) implies [ ( C235 . B92 ) , ( C236 . B92 ) ] in C231))) by L442;
assume L444: [ C232 , C234 ] in D178;
consider C237 being (Element of ( D179 -tuples_on C229 )), C238 being (Element of ( D179 -tuples_on C230 )) such that L445: ([ C232 , C234 ] = [ C237 , C238 ] & (for B93 being set holds (B93 in ( Seg D179 ) implies [ ( C237 . B93 ) , ( C238 . B93 ) ] in C231))) by L444;
L446: (C232 = C235 & C233 = C236 & C232 = C237 & C234 = C238) by L443 , L445 , XTUPLE_0:1;
reconsider D180 = C232 as Function by L445 , XTUPLE_0:1;
reconsider D181 = C236 , D182 = C238 as (Element of ( Funcs (( Seg D179 ) , C230) )) by FOMODEL0:11;
L447:
now
let C239 being (Element of ( Seg D179 ));
L448: ([ ( D180 . C239 ) , ( C236 . C239 ) ] in C231 & [ ( D180 . C239 ) , ( C238 . C239 ) ] in C231) by L443 , L445 , L446;
thus L449: ( D181 . C239 ) = ( D182 . C239 ) by L448 , FUNCT_1:def 1;
end;
thus L450: C233 = C234 by L447 , L446 , FUNCT_2:63;
end;
thus L451: thesis by L441 , FUNCT_1:def 1;
end;
end;
end;
registration
let R13 being non  empty set;
let R14 being non  empty set;
let C240 being  zero Nat;
let C241 being (Relation of R13 , R14);
cluster ( ( C240 -placesOf C241 ) \+\ ( id { ( {} ) } ) ) ->  empty;
coherence
proof
set D183 = { [ ( {} ) , ( {} ) ] };
L454: (( D183 \+\ ( id { ( {} ) } ) ) = ( {} ) & ( C240 -placesOf C241 ) = D183) by L152;
thus L455: thesis by L454;
end;
end;
registration
let R4 being set;
let C242 being  functional set;
cluster ( R4 /\ C242 ) ->  functional;
coherence;
end;
theorem
L458: (for R38 being Language holds (for B94 being (Element of ( ( AllTermsOf R38 ) * )) holds (ex B95 being (Element of ( NAT )) st B94 is (Element of ( ( ( R38 -termsOfMaxDepth ) . B95 ) * ))))) by L38;
definition
let R38 being Language;
let R12 being non  empty set;
let C243 being (Equivalence_Relation of R12);
let C244 being (R38 , R12)-interpreter-like Function;
attr C244 is C243 -respecting
means
:L459: (for B96 being  own (Element of R38) holds (( C244 . B96 ) qua (Interpreter of B96 , R12)) is C243 -respecting);
end;
definition
let R38 being Language;
let R12 being non  empty set;
let C245 being (Equivalence_Relation of R12);
let C246 being (R38 , R12)-interpreter-like Function;
func C246 quotient C245 -> Function means 
:L461: (( dom it ) = ( OwnSymbolsOf R38 ) & (for B97 being (Element of ( OwnSymbolsOf R38 )) holds ( it . B97 ) = ( ( C246 . B97 ) quotient C245 )));
existence
proof
set D184 = ( OwnSymbolsOf R38 );
set D185 = ( AllTermsOf R38 );
deffunc H5((Element of D184)) = ( ( C246 . $1 ) quotient C245 );
consider C247 being Function such that L462: (( dom C247 ) = D184 & (for B98 being (Element of D184) holds ( C247 . B98 ) = H5(B98))) from FUNCT_1:sch 4;
take C247;
thus L463: (( dom C247 ) = D184 & (for B99 being (Element of D184) holds ( C247 . B99 ) = ( ( C246 . B99 ) quotient C245 ))) by L462;
end;
uniqueness
proof
set D186 = ( OwnSymbolsOf R38 );
set D187 = ( AllTermsOf R38 );
let C248 , C249 being Function;
deffunc H6((Element of D186)) = ( ( C246 . $1 ) quotient C245 );
assume L464: (( dom C248 ) = D186 & (for B100 being (Element of D186) holds ( C248 . B100 ) = H6(B100)));
assume L465: (( dom C249 ) = D186 & (for B101 being (Element of D186) holds ( C249 . B101 ) = H6(B101)));
L466: (( dom C248 ) = ( dom C249 ) & (for R7 being set holds (R7 in ( dom C248 ) implies ( C248 . R7 ) = ( C249 . R7 ))))
proof
thus L467: ( dom C248 ) = ( dom C249 ) by L464 , L465;
let R7 being set;
assume L468: R7 in ( dom C248 );
reconsider D188 = R7 as (Element of D186) by L468 , L464;
L469: ( C248 . D188 ) = H6(D188) by L464
.= ( C249 . D188 ) by L465;
thus L470: thesis by L469;
end;
thus L471: thesis by L466 , FUNCT_1:2;
end;
end;
definition
let R38 being Language;
let R12 being non  empty set;
let C250 being (Equivalence_Relation of R12);
let C251 being (R38 , R12)-interpreter-like Function;
redefine func C251 quotient C250 means 
:L473: (( dom it ) = ( OwnSymbolsOf R38 ) & (for B102 being  own (Element of R38) holds ( it . B102 ) = ( ( C251 . B102 ) quotient C250 )));
compatibility
proof
set D189 = ( OwnSymbolsOf R38 );
set D190 = ( C251 quotient C250 );
defpred S3[ Function ] means (( dom $1 ) = D189 & (for B103 being  own (Element of R38) holds ( $1 . B103 ) = ( ( C251 . B103 ) quotient C250 )));
let C252 being Function;
thus L474: (C252 = D190 implies S3[ C252 ])
proof
assume L475: C252 = D190;
thus L476: ( dom C252 ) = D189 by L475 , L461;
L477:
now
let C253 being  own (Element of R38);
reconsider D191 = C253 as (Element of D189) by FOMODEL1:def 19;
L478: ( D190 . D191 ) = ( ( C251 . D191 ) quotient C250 ) by L461;
thus L479: ( C252 . C253 ) = ( ( C251 . C253 ) quotient C250 ) by L478 , L475;
end;
thus L480: thesis by L477;
end;

assume L481: S3[ C252 ];
L482: (for B104 being (Element of D189) holds ( C252 . B104 ) = ( ( C251 . B104 ) quotient C250 )) by L481;
thus L483: C252 = D190 by L482 , L481 , L461;
end;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C254 being (R38 , R12)-interpreter-like Function;
let C255 being (Equivalence_Relation of R12);
cluster ( C254 quotient C255 ) -> ( OwnSymbolsOf R38 ) -defined;
coherence
proof
set D192 = ( C254 quotient C255 );
set D193 = ( OwnSymbolsOf R38 );
L485: ( dom D192 ) c= D193 by L461;
thus L486: thesis by L485 , RELAT_1:def 18;
end;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C256 being (Equivalence_Relation of R12);
cluster C256 -respecting for (Element of ( R12 -InterpretersOf R38 ));
existence
proof
set D194 = ( OwnSymbolsOf R38 );
set D195 = ( PFuncs (( R12 * ) , ( R12 \/ ( BOOLEAN ) )) );
set D196 = ( R12 -InterpretersOf R38 );
deffunc H7((Element of D194)) = the C256 -respecting (Interpreter of $1 , R12);
consider C257 being Function such that L488: (( dom C257 ) = D194 & (for B105 being (Element of D194) holds ( C257 . B105 ) = H7(B105))) from FUNCT_1:sch 4;
L489:
now
let R7 being set;
assume L490: R7 in ( dom C257 );
reconsider D197 = R7 as (Element of D194) by L490 , L488;
L491: ( C257 . D197 ) = H7(D197) by L488;
thus L492: ( C257 . R7 ) is Function by L491;
end;
L493: C257 is  Function-yielding by L489 , FUNCOP_1:def 6;
L494: (for B106 being  own (Element of R38) holds ( C257 . B106 ) is (Interpreter of B106 , R12))
proof
let C258 being  own (Element of R38);
reconsider D198 = C258 as (Element of D194) by FOMODEL1:def 19;
L495: ( C257 . D198 ) = H7(D198) by L488;
thus L496: thesis by L495;
end;
reconsider D199 = C257 as (Interpreter of R38 , R12) by L494 , FOMODEL2:def 3;
reconsider D200 = D199 as (R38 , R12)-interpreter-like Function by L493 , FOMODEL2:def 4;
reconsider D201 = D200 as D194 -defined Function by L488 , RELAT_1:def 18;
L497: (( D200 | D194 ) is D195 -valued & ( D201 | D194 ) = ( D201 null D194 ));
L498: (D200 = D200 & ( dom D200 ) = D194 & ( rng D200 ) c= D195) by L497 , L488 , RELAT_1:def 19;
reconsider D202 = D200 as (Element of ( Funcs (D194 , D195) )) by L498 , FUNCT_2:def 2;
L499: D202 in D196;
reconsider D203 = D202 as (Element of D196) by L499;
take D203;
L500:
now
let C259 being  own (Element of R38);
reconsider D204 = C259 as (Element of D194) by FOMODEL1:def 19;
L501: ( D200 . D204 ) = H7(D204) by L488;
thus L502: ( D203 . C259 ) is C256 -respecting by L501;
end;
thus L503: thesis by L500 , L459;
end;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C260 being (Equivalence_Relation of R12);
cluster C260 -respecting for (R38 , R12)-interpreter-like (R38 , R12)-interpreter-like (R38 , R12)-interpreter-like (R38 , R12)-interpreter-like Function;
existence
proof
take D205 = the C260 -respecting (Element of ( R12 -InterpretersOf R38 ));
thus L505: thesis;
end;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C261 being (Equivalence_Relation of R12);
let C262 being  own (Element of R38);
let C263 being C261 -respecting (R38 , R12)-interpreter-like Function;
cluster ( C263 . C262 ) -> C261 -respecting for (Interpreter of C262 , R12);
coherence by L459;
end;
registration
let R38 being Language;
let R12 being non  empty set;
let C264 being (Equivalence_Relation of R12);
let C265 being C264 -respecting (R38 , R12)-interpreter-like Function;
cluster ( C265 quotient C264 ) -> (R38 , ( Class C264 ))-interpreter-like for Function;
coherence
proof
set D206 = ( C265 quotient C264 );
set D207 = ( OwnSymbolsOf R38 );
L508: (for B107 being (Element of D207) holds (( D206 . B107 ) is (Interpreter of B107 , ( Class C264 )) & ( D206 . B107 ) is Function))
proof
let C266 being (Element of D207);
reconsider D208 = ( C265 . C266 ) as C264 -respecting (Interpreter of C266 , R12);
L509: ( D208 quotient C264 ) is (Interpreter of C266 , ( Class C264 ));
thus L510: ( D206 . C266 ) is (Interpreter of C266 , ( Class C264 )) by L509 , L461;
thus L511: ( D206 . C266 ) is Function by L509 , L461;
end;
L512: (for R7 being set holds (R7 in ( dom D206 ) implies ( D206 . R7 ) is Function)) by L508;
L513: D206 is  Function-yielding by L512 , FUNCOP_1:def 6;
L514:
now
let C267 being  own (Element of R38);
reconsider D209 = C267 as (Element of D207) by FOMODEL1:def 19;
L515: ( D206 . D209 ) is (Interpreter of D209 , ( Class C264 )) by L508;
thus L516: ( D206 . C267 ) is (Interpreter of C267 , ( Class C264 )) by L515;
end;
L517: D206 is (Interpreter of R38 , ( Class C264 )) by L514 , FOMODEL2:def 3;
thus L518: thesis by L517 , L513 , FOMODEL2:def 4;
end;
end;
definition
let R38 being Language;
let R12 being non  empty set;
let C268 being (Equivalence_Relation of R12);
let C269 being C268 -respecting (R38 , R12)-interpreter-like Function;
redefine func C269 quotient C268 -> (Element of ( ( Class C268 ) -InterpretersOf R38 ));

coherence
proof
set D210 = ( C269 quotient C268 );
set D211 = ( OwnSymbolsOf R38 );
set D212 = ( ( Class C268 ) -InterpretersOf R38 );
L520: ( D210 null D211 ) in D212 by FOMODEL2:2;
thus L521: thesis by L520;
end;
end;
L523: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R26 being Nat holds (for B108 being (Relation of R13 , R14) holds ( R26 -placesOf B108 ) = { [ B109 , B110 ] where B109 is (Element of ( R26 -tuples_on R13 )) , B110 is (Element of ( R26 -tuples_on R14 )) : B110 c= ( B109 * B108 ) }))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R26 being Nat;
let C270 being (Relation of R13 , R14);
deffunc H8(set , set) = [ $1 , $2 ];
defpred S4[ Function , Function ] means (for B111 being set holds (B111 in ( Seg R26 ) implies [ ( $1 . B111 ) , ( $2 . B111 ) ] in C270));
defpred S5[ Relation , set ] means $2 c= ( $1 * C270 );
set D213 = ( R26 -tuples_on R13 );
set D214 = ( R26 -tuples_on R14 );
set D215 = ( Seg R26 );
set D216 = { H8(B112 , B113) where B112 is (Element of D213) , B113 is (Element of D214) : S4[ B112 , B113 ] };
set D217 = { H8(B114 , B115) where B114 is (Element of D213) , B115 is (Element of D214) : S5[ B114 , B115 ] };
L524: (for B116 being (Element of D213) holds (for B117 being (Element of D214) holds (S4[ B116 , B117 ] iff S5[ B116 , B117 ])))
proof
let C271 being (Element of D213);
let C272 being (Element of D214);
L525: (( len C271 ) = R26 & ( len C272 ) = R26) by CARD_1:def 7;
L526: (( dom C271 ) = D215 & ( dom C272 ) = D215) by L525 , FINSEQ_1:def 3;
L527: (C271 = { [ B118 , ( C271 . B118 ) ] where B118 is (Element of D215) : B118 in D215 } & C272 = { [ B119 , ( C272 . B119 ) ] where B119 is (Element of D215) : B119 in D215 }) by L526 , FOMODEL0:20;
thus L528: (S4[ C271 , C272 ] implies S5[ C271 , C272 ])
proof
assume L529: S4[ C271 , C272 ];
L530:
now
let R11 being set;
assume L531: R11 in C272;
consider C273 being (Element of D215) such that L532: (R11 = [ C273 , ( C272 . C273 ) ] & C273 in D215) by L531 , L527;
L533: [ ( C271 . C273 ) , ( C272 . C273 ) ] in C270 by L529 , L532;
L534: [ C273 , ( C271 . C273 ) ] in C271 by L527 , L532;
thus L535: R11 in ( C271 * C270 ) by L534 , L532 , L533 , RELAT_1:def 8;
end;
thus L536: thesis by L530 , TARSKI:def 3;
end;

assume L537: S5[ C271 , C272 ];
L538:
now
let C274 being set;
assume L539: C274 in D215;
reconsider D218 = C274 as (Element of D215) by L539;
L540: [ D218 , ( C272 . D218 ) ] in C272 by L527 , L539;
consider R11 being set such that L541: ([ D218 , R11 ] in C271 & [ R11 , ( C272 . D218 ) ] in C270) by L540 , L537 , RELAT_1:def 8;
L542: D218 in ( dom C271 ) by L525 , L539 , FINSEQ_1:def 3;
thus L543: [ ( C271 . C274 ) , ( C272 . C274 ) ] in C270 by L542 , L541 , FUNCT_1:def 2;
end;
thus L544: thesis by L538;
end;
L545: D216 = D217 from FRAENKEL:sch 4(L524);
thus L546: thesis by L545;
end;
L547: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R15 being non  empty set holds (for R26 being Nat holds (for B120 being non  empty (Subset of R14) holds (for B121 being (Relation of R13 , B120) holds (for B122 being (Relation of R14 , R15) holds ( ( R26 -placesOf B121 ) * ( R26 -placesOf B122 ) ) c= ( R26 -placesOf ( B121 * B122 ) ))))))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R15 being non  empty set;
let R26 being Nat;
let C275 being non  empty (Subset of R14);
let C276 being (Relation of R13 , C275);
let C277 being (Relation of R14 , R15);
set D219 = ( C276 * C277 );
set D220 = ( R26 -placesOf D219 );
set D221 = ( R26 -placesOf C276 );
set D222 = ( R26 -placesOf C277 );
set D223 = ( D221 * D222 );
set D224 = ( R26 -tuples_on C275 );
set D225 = ( R26 -tuples_on R13 );
set D226 = ( R26 -tuples_on R14 );
set D227 = ( R26 -tuples_on R15 );
L548: (D220 = { [ B123 , B124 ] where B123 is (Element of D225) , B124 is (Element of D227) : B124 c= ( B123 * D219 ) } & D221 = { [ B125 , B126 ] where B125 is (Element of D225) , B126 is (Element of D224) : B126 c= ( B125 * C276 ) } & D222 = { [ B127 , B128 ] where B127 is (Element of D226) , B128 is (Element of D227) : B128 c= ( B127 * C277 ) }) by L523;
L549:
now
let C278 being set;
assume L550: C278 in D223;
consider R7 being set, R11 being set such that L551: C278 = [ R7 , R11 ] by L550 , RELAT_1:def 1;
consider R10 being set such that L552: ([ R7 , R10 ] in D221 & [ R10 , R11 ] in D222) by L551 , L550 , RELAT_1:def 8;
consider C279 being (Element of D225), C280 being (Element of D224) such that L553: ([ C279 , C280 ] = [ R7 , R10 ] & C280 c= ( C279 * C276 )) by L548 , L552;
consider C281 being (Element of D226), C282 being (Element of D227) such that L554: ([ C281 , C282 ] = [ R10 , R11 ] & C282 c= ( C281 * C277 )) by L548 , L552;
L555: (( C280 * C277 ) c= ( ( C279 * C276 ) * C277 ) & C279 = R7 & C280 = R10 & C281 = R10 & C282 = R11) by L553 , L554 , RELAT_1:30 , XTUPLE_0:1;
L556: C282 c= ( ( C279 * C276 ) * C277 ) by L555 , L554 , XBOOLE_1:1;
L557: ([ C279 , C282 ] = [ C279 , C282 ] & C282 c= ( C279 * D219 )) by L556 , RELAT_1:36;
thus L558: C278 in D220 by L557 , L551 , L555 , L548;
end;
thus L559: thesis by L549 , TARSKI:def 3;
end;
L560: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R15 being non  empty set holds (for R26 being Nat holds (for B129 being non  empty (Subset of R14) holds (for B130 being (Relation of R13 , B129) holds (for B131 being (Relation of R14 , R15) holds ( R26 -placesOf ( B130 * B131 ) ) c= ( ( R26 -placesOf B130 ) * ( R26 -placesOf B131 ) ))))))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R15 being non  empty set;
let R26 being Nat;
let C283 being non  empty (Subset of R14);
let C284 being (Relation of R13 , C283);
let C285 being (Relation of R14 , R15);
set D228 = ( C284 * C285 );
set D229 = ( R26 -placesOf D228 );
set D230 = ( R26 -placesOf C284 );
set D231 = ( R26 -placesOf C285 );
set D232 = ( D230 * D231 );
set D233 = ( R26 -tuples_on C283 );
set D234 = ( R26 -tuples_on R13 );
set D235 = ( R26 -tuples_on R14 );
set D236 = ( R26 -tuples_on R15 );
reconsider D237 = R26 as (Element of ( NAT )) by ORDINAL1:def 12;
L561:
now
let R7 being set;
assume L562: R7 in D229;
consider C286 being (Element of D234), C287 being (Element of D236) such that L563: (R7 = [ C286 , C287 ] & (for B132 being set holds (B132 in ( Seg R26 ) implies [ ( C286 . B132 ) , ( C287 . B132 ) ] in D228))) by L562;
defpred S6[ set , set ] means ([ ( C286 . $1 ) , $2 ] in C284 & [ $2 , ( C287 . $1 ) ] in C285);
L564: (for B133 being Nat holds (B133 in ( Seg R26 ) implies (ex B134 being (Element of C283) st S6[ B133 , B134 ])))
proof
let C288 being Nat;
assume L565: C288 in ( Seg R26 );
L566: [ ( C286 . C288 ) , ( C287 . C288 ) ] in D228 by L565 , L563;
consider R10 being set such that L567: ([ ( C286 . C288 ) , R10 ] in C284 & [ R10 , ( C287 . C288 ) ] in C285) by L566 , RELAT_1:def 8;
L568: (R10 in ( rng C284 ) & ( rng C284 ) c= C283) by L567 , XTUPLE_0:def 13;
reconsider D238 = R10 as (Element of C283) by L568;
take D238;
thus L569: thesis by L567;
end;
consider C289 being (FinSequence of C283) such that L570: (( dom C289 ) = ( Seg R26 ) & (for B135 being Nat holds (B135 in ( Seg R26 ) implies S6[ B135 , ( C289 . B135 ) ]))) from FINSEQ_1:sch 5(L564);
L571: ( len C289 ) = D237 by L570 , FINSEQ_1:def 3;
reconsider D239 = C289 as R26 -element (FinSequence of C283) by L571 , CARD_1:def 7;
reconsider D240 = D239 as (Element of D233) by FOMODEL0:16;
reconsider D241 = D240 as (Element of D235) by FOMODEL0:16;
L572: ([ C286 , D240 ] = [ C286 , D240 ] & (for B136 being set holds (B136 in ( Seg R26 ) implies [ ( C286 . B136 ) , ( D240 . B136 ) ] in C284))) by L570;
L573: [ C286 , D240 ] in D230 by L572;
L574: ([ D241 , C287 ] = [ D241 , C287 ] & (for B137 being set holds (B137 in ( Seg R26 ) implies [ ( D241 . B137 ) , ( C287 . B137 ) ] in C285))) by L570;
L575: [ D241 , C287 ] in D231 by L574;
thus L576: R7 in D232 by L575 , L563 , L573 , RELAT_1:def 8;
end;
thus L577: thesis by L561 , TARSKI:def 3;
end;
L578: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R15 being non  empty set holds (for R26 being Nat holds (for B138 being non  empty (Subset of R14) holds (for B139 being (Relation of R13 , B138) holds (for B140 being (Relation of R14 , R15) holds ( R26 -placesOf ( B139 * B140 ) ) = ( ( R26 -placesOf B139 ) * ( R26 -placesOf B140 ) ))))))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R15 being non  empty set;
let R26 being Nat;
let C290 being non  empty (Subset of R14);
let C291 being (Relation of R13 , C290);
let C292 being (Relation of R14 , R15);
set D242 = ( C291 * C292 );
set D243 = ( R26 -placesOf D242 );
set D244 = ( R26 -placesOf C291 );
set D245 = ( R26 -placesOf C292 );
set D246 = ( D244 * D245 );
L579: (D243 c= D246 & D246 c= D243) by L547 , L560;
thus L580: thesis by L579 , XBOOLE_0:def 10;
end;
L581: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R15 being non  empty set holds (for R26 being Nat holds (for B141 being (Relation of R13 , R14) holds (for B142 being (Relation of R14 , R15) holds ( R26 -placesOf ( B141 * B142 ) ) = ( ( R26 -placesOf B141 ) * ( R26 -placesOf B142 ) )))))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R15 being non  empty set;
let R26 being Nat;
reconsider D247 = ( R14 /\ R14 ) as non  empty (Subset of R14);
let C293 being (Relation of R13 , R14);
let C294 being (Relation of R14 , R15);
reconsider D248 = C293 as (Relation of R13 , D247);
L582: ( R26 -placesOf ( D248 * C294 ) ) = ( ( R26 -placesOf D248 ) * ( R26 -placesOf C294 ) ) by L578;
thus L583: thesis by L582;
end;
L584: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R26 being Nat holds (for B143 being (Relation of R13 , R14) holds ( R26 -placesOf ( B143 ~ ) ) = ( ( R26 -placesOf B143 ) ~ )))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R26 being Nat;
let C295 being (Relation of R13 , R14);
set D249 = ( R26 -tuples_on R13 );
set D250 = ( R26 -tuples_on R14 );
set D251 = { [ B145 , B144 ] where B144 is (Element of D249) , B145 is (Element of D250) : (for B146 being set holds (B146 in ( Seg R26 ) implies [ ( B144 . B146 ) , ( B145 . B146 ) ] in C295)) };
reconsider D252 = ( C295 ~ ) as (Relation of R14 , R13);
reconsider D253 = ( R26 -placesOf C295 ) as (Relation of ( R26 -tuples_on R13 ) , ( R26 -tuples_on R14 ));
reconsider D254 = ( R26 -placesOf D252 ) as (Relation of ( R26 -tuples_on R14 ) , ( R26 -tuples_on R13 ));
reconsider D255 = ( D253 ~ ) as (Relation of ( R26 -tuples_on R14 ) , ( R26 -tuples_on R13 ));
L585:
now
let R7 being set;
assume L586: R7 in D254;
consider C296 being (Element of D250), C297 being (Element of D249) such that L587: (R7 = [ C296 , C297 ] & (for B147 being set holds (B147 in ( Seg R26 ) implies [ ( C296 . B147 ) , ( C297 . B147 ) ] in ( C295 ~ )))) by L586;
L588: (for B148 being set holds (B148 in ( Seg R26 ) implies [ ( C297 . B148 ) , ( C296 . B148 ) ] in C295))
proof
let C298 being set;
assume L589: C298 in ( Seg R26 );
L590: [ ( C296 . C298 ) , ( C297 . C298 ) ] in ( C295 ~ ) by L589 , L587;
thus L591: thesis by L590 , RELAT_1:def 7;
end;
L592: [ C297 , C296 ] in D253 by L588;
thus L593: R7 in D255 by L592 , L587 , RELAT_1:def 7;
end;
L594: D254 c= D255 by L585 , TARSKI:def 3;
L595:
now
let R7 being set;
assume L596: R7 in ( D255 ~ );
consider C299 being (Element of D249), C300 being (Element of D250) such that L597: (R7 = [ C299 , C300 ] & (for B149 being set holds (B149 in ( Seg R26 ) implies [ ( C299 . B149 ) , ( C300 . B149 ) ] in C295))) by L596;
L598: (for B150 being set holds (B150 in ( Seg R26 ) implies [ ( C300 . B150 ) , ( C299 . B150 ) ] in ( C295 ~ )))
proof
let C301 being set;
assume L599: C301 in ( Seg R26 );
L600: [ ( C299 . C301 ) , ( C300 . C301 ) ] in C295 by L599 , L597;
thus L601: thesis by L600 , RELAT_1:def 7;
end;
L602: [ C300 , C299 ] in D254 by L598;
thus L603: R7 in ( D254 ~ ) by L602 , L597 , RELAT_1:def 7;
end;
L604: ( D255 ~ ) c= ( D254 ~ ) by L595 , TARSKI:def 3;
L605: ( ( D255 ~ ) \ ( D254 ~ ) ) = ( {} ) by L604;
L606: ( ( D255 \ D254 ) ~ ) = ( {} ) by L605 , RELAT_1:24;
L607: ( ( ( D255 \ D254 ) ~ ) ~ ) = ( {} ) by L606;
L608: D255 c= D254 by L607 , XBOOLE_1:37;
thus L609: thesis by L608 , L594 , XBOOLE_0:def 10;
end;
L610: (for B151 , B152 being non  empty set holds (for B153 being (Equivalence_Relation of B151) holds (for B154 being (Equivalence_Relation of B152) holds (for B155 being (B153 , B154)-respecting (Function of B151 , B152) holds ( ( B154 -class ) * B155 ) = ( ( B155 quotient (B153 , B154) ) * ( B153 -class ) )))))
proof
let C302 , C303 being non  empty set;
let C304 being (Equivalence_Relation of C302);
let C305 being (Equivalence_Relation of C303);
let C306 being (C304 , C305)-respecting (Function of C302 , C303);
set D256 = ( C306 quotient (C304 , C305) );
L611: ( dom D256 ) = ( Class C304 ) by FUNCT_2:def 1;
reconsider D257 = ( ( C305 -class ) * C306 ) , D258 = ( D256 * ( C304 -class ) ) as (Function of C302 , ( Class C305 ));
L612: (( dom D257 ) = C302 & ( dom D258 ) = C302) by FUNCT_2:def 1;
L613:
now
let C307 being (Element of C302);
reconsider D259 = ( D257 . C307 ) , D260 = ( D258 . C307 ) as (Element of ( Class C305 ));
L614: (D259 = ( ( C305 -class ) . ( C306 . C307 ) ) & D260 = ( D256 . ( ( C304 -class ) . C307 ) )) by L612 , FUNCT_1:12;
L615: D260 = ( D256 . ( EqClass (C304 , C307) ) ) by L614 , L361;
L616: [ ( EqClass (C304 , C307) ) , D260 ] in D256 by L615 , L611 , FUNCT_1:1;
consider C308 being (Element of ( Class C304 )), C309 being (Element of ( Class C305 )) such that L617: ([ ( EqClass (C304 , C307) ) , D260 ] = [ C308 , C309 ] & (ex B156 , B157 being set st (B156 in C308 & B157 in C309 & [ B156 , B157 ] in C306))) by L616;
consider C310 , C311 being set such that L618: (C310 in C308 & C311 in C309 & [ C310 , C311 ] in C306) by L617;
L619: (( EqClass (C304 , C307) ) = C308 & D260 = C309) by L617 , XTUPLE_0:1;
L620: (C310 in ( EqClass (C304 , C307) ) & [ C310 , C307 ] in C304 & C311 in D260) by L619 , L618 , EQREL_1:19;
L621: C310 in C302 by L618;
L622: C310 in ( dom C306 ) by L621 , FUNCT_2:def 1;
L623: C311 = ( C306 . C310 ) by L622 , L618 , FUNCT_1:def 2;
L624: [ C311 , ( C306 . C307 ) ] in C305 by L623 , L620 , L278;
L625: C311 in ( EqClass (C305 , ( C306 . C307 )) ) by L624 , EQREL_1:19;
L626: C311 in D259 by L625 , L614 , L361;
L627: D259 meets D260 by L626 , L618 , L619 , XBOOLE_0:3;
thus L628: ( D257 . C307 ) = ( D258 . C307 ) by L627 , EQREL_1:def 4;
end;
thus L629: thesis by L613 , FUNCT_2:63;
end;
L630: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R25 being Nat holds (for B158 being R25 -element R13 -valued FinSequence holds (for B159 being (Function of R13 , R14) holds ( B159 * B158 ) = ( ( R25 -placesOf B159 ) . B158 ))))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R25 being Nat;
let C312 being R25 -element R13 -valued FinSequence;
let C313 being (Function of R13 , R14);
set D261 = ( R25 -placesOf C313 );
L631: (( dom C313 ) = R13 & ( dom D261 ) = ( R25 -tuples_on R13 ) & C312 in ( R25 -tuples_on R13 ) & ( C313 * C312 ) in ( R25 -tuples_on R14 )) by FOMODEL0:16 , FUNCT_2:def 1;
reconsider D262 = C312 as (Element of ( R25 -tuples_on R13 )) by FOMODEL0:16;
L632: D262 is (Element of ( Funcs (( Seg R25 ) , R13) )) by FOMODEL0:11;
reconsider D263 = D262 as (Function of ( Seg R25 ) , R13) by L632;
reconsider D264 = ( C313 * C312 ) as (Element of ( Funcs (( Seg R25 ) , R14) )) by L631 , FOMODEL0:11;
reconsider D265 = ( D261 . D262 ) as (Element of ( Funcs (( Seg R25 ) , R14) )) by FOMODEL0:11;
reconsider D266 = D264 , D267 = D265 as (Function of ( Seg R25 ) , R14);
reconsider D268 = D264 , D269 = D265 as (Element of ( R25 -tuples_on R14 )) by FOMODEL0:11;
L633: (( dom D263 ) = ( Seg R25 ) & ( rng D263 ) c= R13 & ( dom D264 ) = ( Seg R25 ) & ( dom D264 ) = ( Seg R25 )) by FUNCT_2:def 1 , RELAT_1:def 19;
L634: [ C312 , D264 ] in D261
proof
L635: (for B160 being set holds (B160 in ( Seg R25 ) implies [ ( D262 . B160 ) , ( D268 . B160 ) ] in C313))
proof
let C314 being set;
assume L636: C314 in ( Seg R25 );
L637: ( D264 . C314 ) = ( C313 . ( C312 . C314 ) ) by L636 , L633 , FUNCT_1:12;
L638: ( D263 . C314 ) in ( rng D263 ) by L636 , L633 , FUNCT_1:3;
thus L639: thesis by L638 , L631 , L633 , L637 , FUNCT_1:1;
end;
thus L640: thesis by L635;
end;
thus L641: thesis by L634 , FUNCT_1:1;
end;
L642: (for R12 being non  empty set holds (for R26 being Nat holds (for B161 being (Equivalence_Relation of R12) holds ( ( R26 -placesOf B161 ) -class ) = ( ( R26 -tuple2Class B161 ) * ( R26 -placesOf ( B161 -class ) ) ))))
proof
let R12 being non  empty set;
let R26 being Nat;
let C315 being (Equivalence_Relation of R12);
set D270 = ( R26 -tuples_on R12 );
set D271 = ( R26 -tuple2Class C315 );
set D272 = ( D271 * ( R26 -placesOf ( C315 -class ) ) );
set D273 = ( ( R26 -placesOf C315 ) -class );
reconsider D274 = ( R26 -placesOf ( C315 -class ) ) as (Relation of ( R26 -tuples_on R12 ) , ( R26 -tuples_on ( Class C315 ) ));
reconsider D275 = ( C315 -class ) as (Relation of R12 , ( Class C315 ));
reconsider D276 = ( R26 -placesOf ( D275 ~ ) ) as (Relation of ( R26 -tuples_on ( Class C315 ) ) , ( R26 -tuples_on R12 ));
reconsider D277 = ( ( R26 -placesOf D275 ) ~ ) as (Relation of ( R26 -tuples_on ( Class C315 ) ) , ( R26 -tuples_on R12 ));
L643: (( dom D273 ) = D270 & ( dom D272 ) = D270) by FUNCT_2:def 1;
reconsider D278 = D274 as (Function of D270 , ( R26 -tuples_on ( Class C315 ) ));
reconsider D279 = D274 as  total D270 -defined Relation;
L644: D272 = ( ( D274 * D276 ) * ( ( R26 -placesOf C315 ) -class ) ) by RELAT_1:36
.= ( ( D274 * D277 ) * D273 ) by L584;
L645: ( (( id D270 ) qua Relation) * D273 ) c= D272 by L644 , FOMODEL0:21 , RELAT_1:30;
L646: ( D273 | D270 ) c= D272 by L645 , RELAT_1:65;
thus L647: thesis by L646 , L643 , GRFUNC_1:3;
end;
L648: (for R13 being non  empty set holds (for R14 being non  empty set holds (for R26 being Nat holds (for B162 being (Equivalence_Relation of R13) holds (for B163 being (Equivalence_Relation of R14) holds (for B164 being (( R26 -placesOf B162 ) , B163)-respecting (Function of ( R26 -tuples_on R13 ) , R14) holds ( ( B164 quotient (( R26 -placesOf B162 ) , B163) ) * ( R26 -tuple2Class B162 ) ) = ( ( R26 -placesOf ( (( B162 -class ) qua (Relation of R13 , ( Class B162 ))) ~ ) ) * ( ( B163 -class ) * B164 ) )))))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let R26 being Nat;
set D280 = R13;
set D281 = R14;
let C316 being (Equivalence_Relation of D280);
let C317 being (Equivalence_Relation of D281);
let C318 being (( R26 -placesOf C316 ) , C317)-respecting (Function of ( R26 -tuples_on D280 ) , D281);
reconsider D282 = ( C318 quotient (( R26 -placesOf C316 ) , C317) ) as (Function of ( Class ( R26 -placesOf C316 ) ) , ( Class C317 ));
reconsider D283 = D282 as (Relation of ( Class ( R26 -placesOf C316 ) ) , ( Class C317 ));
reconsider D284 = ( C316 -class ) as (Relation of D280 , ( Class C316 ));
L649: ( D282 * ( R26 -tuple2Class C316 ) ) = ( ( R26 -placesOf ( D284 ~ ) ) * ( ( ( R26 -placesOf C316 ) -class ) * D283 ) ) by RELAT_1:36
.= ( ( R26 -placesOf ( D284 ~ ) ) * ( ( C317 -class ) * C318 ) ) by L610;
thus L650: thesis by L649;
end;
L651: (for R7 being set holds (for R12 being non  empty set holds (for R22 being Function holds (for B165 being  total  reflexive (Relation of R12) holds ((R7 in ( dom R22 ) & R22 is R12 -valued) implies R22 is (( id { R7 } ) , B165)-respecting)))))
proof
let R7 being set;
let R12 being non  empty set;
let R22 being Function;
let C319 being  total  reflexive (Relation of R12);
set D285 = ( id { R7 } );
assume L652: R7 in ( dom R22 );
reconsider D286 = ( dom R22 ) as non  empty set by L652;
L653: ( D285 \+\ { [ R7 , R7 ] } ) = ( {} );
L654: D285 = { [ R7 , R7 ] } by L653 , FOMODEL0:29;
reconsider D287 = R7 as (Element of D286) by L652;
assume L655: R22 is R12 -valued;
L656: ( rng R22 ) c= R12 by L655 , RELAT_1:def 19;
reconsider D288 = R22 as (Function of D286 , R12) by L656 , FUNCT_2:2;
L657:
now
let C320 , C321 being set;
assume L658: [ C320 , C321 ] in D285;
L659: [ C320 , C321 ] = [ R7 , R7 ] by L658 , L654 , TARSKI:def 1;
L660: (C320 = R7 & C321 = R7) by L659 , XTUPLE_0:1;
L661: (( R22 . D287 ) = ( R22 . D287 ) & ( D288 . D287 ) in R12);
thus L662: [ ( R22 . C320 ) , ( R22 . C321 ) ] in C319 by L661 , L660 , EQREL_1:5;
end;
thus L663: thesis by L657 , L278;
end;
L664: (for R12 being non  empty set holds ( ( peeler R12 ) * ( ( id R12 ) -class ) ) = ( id R12 ))
proof
let R12 being non  empty set;
set D289 = R12;
set D290 = ( peeler D289 );
set D291 = ( id D289 );
set D292 = ( D291 -class );
set D293 = ( D290 * D292 );
reconsider D294 = D290 , D295 = D292 as Function;
L665: (( dom D292 ) = D289 & ( dom D291 ) = D289) by FUNCT_2:def 1;
L666: {_{ D289 }_} = { { B166 } where B166 is (Element of D289) : (not contradiction) } by EQREL_1:37;
reconsider D296 = D290 as (Function of ( Class D291 ) , D289);
reconsider D297 = D292 as (Function of D289 , ( Class D291 ));
reconsider D298 = ( D296 * D297 ) , D299 = D291 as (Function of D289 , D289);
L667:
now
let C322 being (Element of D289);
set D300 = C322;
L668: { C322 } in {_{ D289 }_} by L666;
reconsider D301 = { C322 } as (Element of {_{ D289 }_}) by L668;
L669: ( ( D294 * D295 ) . C322 ) = ( D294 . ( D295 . D300 ) ) by L665 , FUNCT_1:13
.= ( D290 . ( Class (( id D289 ) , D300) ) ) by L361
.= ( D290 . D301 ) by EQREL_1:25
.= ( DeTrivial D301 ) by L307
.= D300 by L303
.= ( D291 . C322 ) by FUNCT_1:17;
thus L670: ( D291 . C322 ) = ( ( D296 * D297 ) . C322 ) by L669;
end;
thus L671: thesis by L667 , FUNCT_2:63;
end;
L672: (for R12 being non  empty set holds (for R16 being (Element of R12) holds (for R24 being Nat holds (for R38 being Language holds (for B167 being (Equivalence_Relation of R12) holds (for B168 being B167 -respecting (R38 , R12)-interpreter-like Function holds ( ( (( B168 quotient B167 ) , ( ( B167 -class ) . R16 )) -TermEval ) . R24 ) = ( ( B167 -class ) * ( ( (B168 , R16) -TermEval ) . R24 ) )))))))
proof
let R12 being non  empty set;
let R16 being (Element of R12);
let R24 being Nat;
let R38 being Language;
let C323 being (Equivalence_Relation of R12);
reconsider D302 = ( ( C323 -class ) . R16 ) as (Element of ( Class C323 ));
let C324 being C323 -respecting (R38 , R12)-interpreter-like Function;
set D303 = ( (C324 , R16) -TermEval );
set D304 = ( C324 quotient C323 );
set D305 = ( (D304 , D302) -TermEval );
set D306 = ( R38 -firstChar );
set D307 = ( OwnSymbolsOf R38 );
set D308 = ( AllTermsOf R38 );
defpred S7[ Nat ] means ( D305 . $1 ) = ( ( C323 -class ) * ( D303 . $1 ) );
L673: S7[ ( 0 ) ]
proof
L674: (( D305 . ( 0 ) ) = ( D308 --> D302 ) & ( D303 . ( 0 ) ) = ( D308 --> R16 )) by FOMODEL2:def 8;
L675: ( dom ( C323 -class ) ) = R12 by FUNCT_2:def 1;
thus L676: thesis by L675 , L674 , FUNCOP_1:17;
end;
L677: (for R25 being Nat holds (S7[ R25 ] implies S7[ ( R25 + 1 ) ]))
proof
let R25 being Nat;
assume L678: S7[ R25 ];
reconsider D309 = R25 , D310 = ( R25 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L679: (( D303 . D309 ) is (Element of ( Funcs (D308 , R12) )) & ( D303 . D310 ) is (Element of ( Funcs (D308 , R12) )));
reconsider D311 = ( D303 . D309 ) , D312 = ( D303 . D310 ) as (Function of D308 , R12) by L679;
L680: (( D305 . D309 ) is (Element of ( Funcs (D308 , ( Class C323 )) )) & ( D305 . D310 ) is (Element of ( Funcs (D308 , ( Class C323 )) )));
reconsider D313 = ( D305 . D309 ) , D314 = ( D305 . D310 ) as (Function of D308 , ( Class C323 )) by L680;
L681:
now
let R63 being (Element of ( AllTermsOf R38 ));
reconsider D315 = R63 as  termal (string of R38);
set D316 = ( D306 . D315 );
set D317 = ( C324 . D316 );
set D318 = ( D304 . D316 );
set D319 = ( SubTerms D315 );
set D320 = ( abs ( ar D316 ) );
reconsider D321 = D317 as (( D320 -placesOf C323 ) , C323)-respecting (Function of ( D320 -tuples_on R12 ) , R12) by FOMODEL2:def 2;
L682: ( D317 quotient C323 ) = ( ( D321 quotient (( D320 -placesOf C323 ) , C323) ) * ( D320 -tuple2Class C323 ) ) by L424;
reconsider D322 = ( D321 quotient (( D320 -placesOf C323 ) , C323) ) as Function;
L683: (( D311 * D319 ) is D320 -element R12 -valued D320 -element R12 -valued D320 -element R12 -valued D320 -element R12 -valued FinSequence & ( dom ( D320 -placesOf ( C323 -class ) ) ) = ( D320 -tuples_on R12 ) & ( dom D321 ) = ( D320 -tuples_on R12 ) & ( dom D312 ) = D308) by FUNCT_2:def 1;
thus L684: ( D314 . R63 ) = ( D318 . ( ( D305 . R25 ) * D319 ) ) by FOMODEL2:3
.= ( ( D317 quotient C323 ) . ( ( D305 . R25 ) * D319 ) ) by L473
.= ( ( D317 quotient C323 ) . ( ( C323 -class ) * ( D311 * D319 ) ) ) by L678 , RELAT_1:36
.= ( ( D317 quotient C323 ) . ( ( D320 -placesOf ( C323 -class ) ) . ( D311 * D319 ) ) ) by L630
.= ( ( ( D322 * ( D320 -tuple2Class C323 ) ) * ( D320 -placesOf ( C323 -class ) ) ) . ( D311 * D319 ) ) by L682 , L683 , FOMODEL0:16 , FUNCT_1:13
.= ( ( D322 * ( ( D320 -tuple2Class C323 ) * ( D320 -placesOf ( C323 -class ) ) ) ) . ( D311 * D319 ) ) by RELAT_1:36
.= ( ( D322 * ( ( D320 -placesOf C323 ) -class ) ) . ( D311 * D319 ) ) by L642
.= ( ( ( C323 -class ) * D321 ) . ( D311 * D319 ) ) by L610
.= ( ( C323 -class ) . ( D321 . ( D311 * D319 ) ) ) by L683 , FOMODEL0:16 , FUNCT_1:13
.= ( ( C323 -class ) . ( ( D303 . ( R25 + 1 ) ) . D315 ) ) by FOMODEL2:3
.= ( ( ( C323 -class ) * D312 ) . R63 ) by L683 , FUNCT_1:13;
end;
thus L685: thesis by L681 , FUNCT_2:63;
end;
L686: (for R26 being Nat holds S7[ R26 ]) from NAT_1:sch 2(L673 , L677);
thus L687: thesis by L686;
end;
L688: (for R12 being non  empty set holds (for R38 being Language holds (for B169 being (Equivalence_Relation of R12) holds (for B170 being B169 -respecting (R38 , R12)-interpreter-like Function holds ( ( B170 quotient B169 ) -TermEval ) = ( ( B169 -class ) * ( B170 -TermEval ) )))))
proof
let R12 being non  empty set;
let R38 being Language;
let C325 being (Equivalence_Relation of R12);
set D323 = the (Element of R12);
let C326 being C325 -respecting (R38 , R12)-interpreter-like Function;
reconsider D324 = ( ( C325 -class ) . D323 ) as (Element of ( Class C325 ));
set D325 = ( R38 -firstChar );
set D326 = ( C326 quotient C325 );
set D327 = ( (C326 , D323) -TermEval );
set D328 = ( (D326 , D324) -TermEval );
set D329 = ( OwnSymbolsOf R38 );
set D330 = ( AllTermsOf R38 );
set D331 = ( C326 -TermEval );
set D332 = ( D326 -TermEval );
set D333 = ( R38 -termsOfMaxDepth );
reconsider D334 = D333 as Function;
L689:
now
let C327 being (Element of D330);
consider R30 being (Element of ( NAT )) such that L690: C327 in ( D334 . R30 ) by FOMODEL1:5;
set D335 = ( C326 -TermEval C327 );
set D336 = ( D326 -TermEval C327 );
reconsider D337 = ( R30 + 1 ) as (Element of ( NAT ));
L691: ( D327 . D337 ) is (Element of ( Funcs (D330 , R12) ));
L692: (( dom ( D327 . D337 ) ) = D330 & ( dom D331 ) = D330) by L691 , FUNCT_2:def 1;
thus L693: ( D332 . C327 ) = D336 by FOMODEL2:def 10
.= ( ( D328 . ( R30 + 1 ) ) . C327 ) by L690 , FOMODEL2:def 9
.= ( ( ( C325 -class ) * ( D327 . ( R30 + 1 ) ) ) . C327 ) by L672
.= ( ( C325 -class ) . ( ( D327 . ( R30 + 1 ) ) . C327 ) ) by L692 , FUNCT_1:13
.= ( ( C325 -class ) . D335 ) by L690 , FOMODEL2:def 9
.= ( ( C325 -class ) . ( D331 . C327 ) ) by FOMODEL2:def 10
.= ( ( ( C325 -class ) * D331 ) . C327 ) by L692 , FUNCT_1:13;
end;
thus L694: thesis by L689 , FUNCT_2:63;
end;
L695: (for R13 being non  empty set holds (for R38 being Language holds (for B171 being (Equivalence_Relation of R13) holds (for B172 being  0wff (string of R38) holds (for B173 being B171 -respecting (R38 , R13)-interpreter-like Function holds (( ( R38 -firstChar ) . B172 ) <> ( TheEqSymbOf R38 ) implies ( ( B173 quotient B171 ) -AtomicEval B172 ) = ( B173 -AtomicEval B172 )))))))
proof
let R13 being non  empty set;
let R38 being Language;
let C328 being (Equivalence_Relation of R13);
let C329 being  0wff (string of R38);
let C330 being C328 -respecting (R38 , R13)-interpreter-like Function;
set D338 = ( AllTermsOf R38 );
set D339 = ( TheEqSymbOf R38 );
set D340 = ( SubTerms C329 );
set D341 = ( R38 -firstChar );
set D342 = ( D341 . C329 );
set D343 = ( abs ( ar D342 ) );
set D344 = ( Class C328 );
set D345 = ( C330 quotient C328 );
set D346 = ( D345 -TermEval );
set D347 = ( D343 -tuples_on R13 );
set D348 = ( D345 -AtomicEval C329 );
set D349 = ( C330 -TermEval );
set D350 = ( C330 -AtomicEval C329 );
set D351 = ( ( D345 === ) . D342 );
set D352 = ( D345 . D342 );
set D353 = ( C330 . D342 );
set D354 = ( D344 -deltaInterpreter );
L696: (D340 in ( D343 -tuples_on D338 ) & ( dom ( D343 -placesOf ( ( C328 -class ) * D349 ) ) ) = ( D343 -tuples_on D338 ) & ( dom ( D343 -placesOf D349 ) ) = ( D343 -tuples_on D338 )) by FOMODEL0:16 , FUNCT_2:def 1;
assume L697: D342 <> D339;
L698: D348 = ( D352 . ( D346 * D340 ) ) by L697 , FOMODEL2:14
.= ( D352 . ( ( ( C328 -class ) * D349 ) * D340 ) ) by L688
.= ( D352 . ( ( D343 -placesOf ( ( C328 -class ) * D349 ) ) . D340 ) ) by L630
.= ( ( D352 * ( D343 -placesOf ( ( C328 -class ) * D349 ) ) ) . D340 ) by L696 , FUNCT_1:13;
reconsider D355 = D342 as (Element of ( OwnSymbolsOf R38 )) by L697 , FOMODEL1:15;
set D356 = ( C330 . D355 );
set D357 = ( D345 . D355 );
reconsider D358 = D356 as (( D343 -placesOf C328 ) , ( id ( BOOLEAN ) ))-respecting (Function of ( D343 -tuples_on R13 ) , ( BOOLEAN )) by L280 , FOMODEL2:def 2;
set D359 = ( D358 quotient (( D343 -placesOf C328 ) , ( id ( BOOLEAN ) )) );
reconsider D360 = ( peeler ( BOOLEAN ) ) as Function;
reconsider D361 = D359 , D362 = ( D343 -tuple2Class C328 ) , D363 = D360 as Relation;
reconsider D364 = ( C328 -class ) as (Relation of R13 , ( Class C328 ));
L699: D357 = ( D356 quotient C328 ) by L473
.= ( ( peeler ( BOOLEAN ) ) * ( D359 * ( D343 -tuple2Class C328 ) ) ) by L424;
L700: ( ( D343 -tuple2Class C328 ) * ( D343 -placesOf ( ( C328 -class ) * D349 ) ) ) = ( ( ( D343 -placesOf C328 ) -class ) * ( D343 -placesOf D349 ) )
proof
set D365 = ( D343 -placesOf ( ( C328 -class ) * D349 ) );
L701: ( ( D343 -tuple2Class C328 ) * ( D343 -placesOf ( ( C328 -class ) * D349 ) ) ) = ( ( ( D343 -placesOf D349 ) * ( D343 -placesOf D364 ) ) * ( ( D343 -placesOf ( D364 ~ ) ) * ( ( D343 -placesOf C328 ) -class ) ) ) by L581
.= ( ( D343 -placesOf D349 ) * ( ( D343 -placesOf D364 ) * ( ( D343 -placesOf ( D364 ~ ) ) * ( ( D343 -placesOf C328 ) -class ) ) ) ) by RELAT_1:36
.= ( ( D343 -placesOf D349 ) * ( ( ( D343 -placesOf D364 ) * ( D343 -placesOf ( D364 ~ ) ) ) * ( ( D343 -placesOf C328 ) -class ) ) ) by RELAT_1:36
.= ( ( D343 -placesOf D349 ) * ( ( ( D343 -placesOf D364 ) * ( ( D343 -placesOf D364 ) ~ ) ) * ( ( D343 -placesOf C328 ) -class ) ) ) by L584;
L702: ( ( D343 -placesOf D349 ) * ( ( ( D343 -placesOf D364 ) * ( ( D343 -placesOf D364 ) ~ ) ) * ( ( D343 -placesOf C328 ) -class ) ) ) = ( ( ( D343 -placesOf D349 ) * ( ( D343 -placesOf D364 ) * ( ( D343 -placesOf D364 ) ~ ) ) ) * ( ( D343 -placesOf C328 ) -class ) ) by RELAT_1:36
.= ( ( ( ( D343 -placesOf D349 ) * ( D343 -placesOf D364 ) ) * ( ( D343 -placesOf D364 ) ~ ) ) * ( ( D343 -placesOf C328 ) -class ) ) by RELAT_1:36;
thus L703: thesis by L702 , L701 , FOMODEL0:27;
end;
L704: ( ( D360 * ( D359 * ( D343 -tuple2Class C328 ) ) ) * ( D343 -placesOf ( ( C328 -class ) * D349 ) ) ) = ( D360 * ( ( D359 * ( D343 -tuple2Class C328 ) ) * ( D343 -placesOf ( ( C328 -class ) * D349 ) ) ) ) by RELAT_1:36
.= ( D360 * ( D359 * ( ( ( D343 -placesOf C328 ) -class ) * ( D343 -placesOf D349 ) ) ) ) by L700 , RELAT_1:36;
L705: D348 = ( ( D360 * ( ( D359 * ( ( D343 -placesOf C328 ) -class ) ) * ( D343 -placesOf D349 ) ) ) . D340 ) by L704 , L698 , L699 , RELAT_1:36
.= ( ( ( D360 * ( D359 * ( ( D343 -placesOf C328 ) -class ) ) ) * ( D343 -placesOf D349 ) ) . D340 ) by RELAT_1:36
.= ( ( D360 * ( D359 * ( ( D343 -placesOf C328 ) -class ) ) ) . ( ( D343 -placesOf D349 ) . D340 ) ) by L696 , FUNCT_1:13
.= ( ( D360 * ( D359 * ( ( D343 -placesOf C328 ) -class ) ) ) . ( D349 * D340 ) ) by L630
.= ( ( D360 * ( ( ( id ( BOOLEAN ) ) -class ) * D358 ) ) . ( D349 * D340 ) ) by L610
.= ( ( ( D360 * ( ( id ( BOOLEAN ) ) -class ) ) * D358 ) . ( D349 * D340 ) ) by RELAT_1:36
.= ( ( ( id ( BOOLEAN ) ) * D358 ) . ( D349 * D340 ) ) by L664
.= ( D358 . ( D349 * D340 ) ) by FUNCT_2:17
.= ( C330 -AtomicEval C329 ) by FOMODEL2:14;
thus L706: thesis by L705;
end;
L707: (for R4 being set holds (for R25 being Nat holds (for R38 being Language holds (for R63 being (Element of ( AllTermsOf R38 )) holds (for B174 being ( 0 ) -termal (string of R38) holds ( ( ( (( (R38 , R4) -freeInterpreter ) , R63) -TermEval ) . ( R25 + 1 ) ) . B174 ) = B174)))))
proof
let R4 being set;
let R25 being Nat;
let R38 being Language;
let R63 being (Element of ( AllTermsOf R38 ));
let C331 being ( 0 ) -termal (string of R38);
set D366 = ( (R38 , R4) -freeInterpreter );
set D367 = ( AllTermsOf R38 );
set D368 = ( R38 -firstChar );
set D369 = ( D368 . C331 );
set D370 = ( abs ( ar D369 ) );
set D371 = ( R38 -multiCat );
set D372 = ( (D366 , R63) -TermEval );
set D373 = ( AllSymbolsOf R38 );
set D374 = ( ( D369 -compound ) | ( D370 -tuples_on D367 ) );
reconsider D375 = ( R4 -freeInterpreter D369 ) as (Function of ( D370 -tuples_on D367 ) , D367) by FOMODEL2:def 2;
L708: D374 = D375 by L95;
reconsider D376 = ( {} ) as (Element of ( ( ( D373 * ) \ { ( {} ) } ) * )) by FINSEQ_1:49;
L709: ( dom D375 ) = ( ( 0 ) -tuples_on D367 ) by FUNCT_2:def 1;
L710: ( dom D375 ) = { ( {} ) } by L709 , FOMODEL0:10;
L711: ( {} ) in ( dom D374 ) by L710 , L708 , TARSKI:def 1;
thus L712: ( ( D372 . ( R25 + 1 ) ) . C331 ) = ( ( D366 . D369 ) . ( {} ) ) by FOMODEL2:3
.= ( D375 . ( {} ) ) by L113
.= ( D374 . ( {} ) ) by L95
.= ( ( D369 -compound ) . ( {} ) ) by L711 , FUNCT_1:47
.= ( D369 -compound D376 ) by L64
.= ( <* D369 *> null ( {} ) )
.= C331 by FOMODEL2:1;
end;
L713: (for R4 being set holds (for R25 being Nat holds (for R38 being Language holds (for R63 being (Element of ( AllTermsOf R38 )) holds ( ( ( (( (R38 , R4) -freeInterpreter ) , R63) -TermEval ) . ( R25 + 1 ) ) | ( ( R38 -termsOfMaxDepth ) . R25 ) ) = ( id ( ( R38 -termsOfMaxDepth ) . R25 ) )))))
proof
let R4 being set;
let R25 being Nat;
let R38 being Language;
let R63 being (Element of ( AllTermsOf R38 ));
set D377 = ( (R38 , R4) -freeInterpreter );
set D378 = ( (D377 , R63) -TermEval );
set D379 = ( R38 -termsOfMaxDepth );
set D380 = ( R38 -firstChar );
set D381 = ( AllSymbolsOf R38 );
set D382 = ( AllTermsOf R38 );
defpred S8[ Nat ] means ( ( D378 . ( $1 + 1 ) ) | ( D379 . $1 ) ) = ( id ( D379 . $1 ) );
L714: S8[ ( 0 ) ]
proof
reconsider D383 = ( 0 ) , D384 = 1 as (Element of ( NAT ));
L715: ( D378 . D384 ) is (Element of ( Funcs (D382 , D382) ));
L716: (( D378 . D384 ) is (Function of D382 , D382) & ( D379 . D383 ) c= D382) by L715 , FOMODEL1:2;
reconsider D385 = ( ( D378 . 1 ) | ( D379 . ( 0 ) ) ) as (Function of ( D379 . ( 0 ) ) , D382) by L716 , FUNCT_2:32;
L717: ( dom D385 ) = ( D379 . ( 0 ) ) by FUNCT_2:def 1;
L718:
now
let R7 being set;
assume L719: R7 in ( D379 . ( 0 ) );
reconsider D386 = R7 as (Element of ( D379 . D383 )) by L719;
reconsider D387 = D386 as ( 0 ) -termal (string of R38) by FOMODEL1:def 33;
thus L720: ( D385 . R7 ) = ( ( D378 . ( ( 0 ) + 1 ) ) . D387 ) by L717 , FUNCT_1:47
.= R7 by L707;
end;
thus L721: thesis by L718 , L717 , FUNCT_1:17;
end;
L722: (for R26 being Nat holds (S8[ R26 ] implies S8[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L723: S8[ R26 ];
reconsider D388 = R26 , D389 = ( R26 + 1 ) , D390 = ( ( R26 + 1 ) + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L724: ( D378 . D390 ) is (Element of ( Funcs (D382 , D382) ));
L725: (( D378 . D390 ) is (Function of D382 , D382) & ( D379 . D389 ) c= D382) by L724 , FOMODEL1:2;
reconsider D391 = ( ( D378 . D390 ) | ( D379 . D389 ) ) as (Function of ( D379 . D389 ) , D382) by L725 , FUNCT_2:32;
L726: ( dom D391 ) = ( D379 . D389 ) by FUNCT_2:def 1
.= ( dom ( id ( D379 . D389 ) ) );
L727:
now
let R7 being set;
assume L728: R7 in ( dom D391 );
reconsider D392 = R7 as (Element of ( D379 . ( D388 + 1 ) )) by L728;
reconsider D393 = D392 as ( D388 + 1 ) -termal (string of R38) by FOMODEL1:def 33;
set D394 = ( D380 . D393 );
set D395 = ( abs ( ar D394 ) );
L729: ( dom ( R4 -freeInterpreter D394 ) ) = ( D395 -tuples_on D382 ) by FUNCT_2:def 1;
reconsider D396 = ( SubTerms D393 ) as ( D379 . R26 ) -valued Function;
reconsider D397 = D396 as (Element of ( dom ( R4 -freeInterpreter D394 ) )) by L729 , FOMODEL0:16;
L730: (D397 in ( dom ( R4 -freeInterpreter D394 ) ) & ( R4 -freeInterpreter D394 ) = ( ( D394 -compound ) | ( D395 -tuples_on D382 ) )) by L95;
L731: ( SubTerms D393 ) in ( D382 * );
reconsider D398 = ( SubTerms D393 ) as (Element of ( ( ( D381 * ) \ { ( {} ) } ) * )) by L731;
reconsider D399 = ( D396 null ( D379 . R26 ) ) as Function;
L732: ( { ( ( id ( D379 . ( D388 + 1 ) ) ) . D392 ) } \ { D392 } ) = ( {} );
L733: D392 = ( ( id ( D379 . ( D388 + 1 ) ) ) . D392 ) by L732 , ZFMISC_1:15;
thus L734: ( D391 . R7 ) = ( ( D378 . D390 ) . R7 ) by L728 , FUNCT_1:47
.= ( ( D377 . D394 ) . ( ( D378 . ( R26 + 1 ) ) * ( ( D379 . R26 ) |` D396 ) ) ) by FOMODEL2:3
.= ( ( D377 . D394 ) . ( ( D378 . ( R26 + 1 ) ) * ( ( id ( D379 . R26 ) ) * D396 ) ) ) by RELAT_1:92
.= ( ( D377 . D394 ) . ( ( ( D378 . ( R26 + 1 ) ) * ( id ( D379 . R26 ) ) ) * D396 ) ) by RELAT_1:36
.= ( ( D377 . D394 ) . ( ( ( D378 . ( R26 + 1 ) ) | ( D379 . R26 ) ) * D396 ) ) by RELAT_1:65
.= ( ( D377 . D394 ) . ( ( D379 . R26 ) |` D396 ) ) by L723 , RELAT_1:92
.= ( ( R4 -freeInterpreter D394 ) . D396 ) by L113
.= ( ( D394 -compound ) . D398 ) by L730 , FUNCT_1:47
.= ( D394 -compound D398 ) by L64
.= ( ( id ( D379 . ( R26 + 1 ) ) ) . R7 ) by L733 , FOMODEL1:def 37;
end;
thus L735: thesis by L727 , L726 , FUNCT_1:2;
end;
L736: (for R26 being Nat holds S8[ R26 ]) from NAT_1:sch 2(L714 , L722);
thus L737: thesis by L736;
end;
L738: (for R4 being set holds (for R38 being Language holds ( ( (R38 , R4) -freeInterpreter ) -TermEval ) = ( id ( AllTermsOf R38 ) )))
proof
let R4 being set;
let R38 being Language;
set D400 = the (Element of ( AllTermsOf R38 ));
set D401 = ( (R38 , R4) -freeInterpreter );
set D402 = ( (D401 , D400) -TermEval );
set D403 = ( R38 -termsOfMaxDepth );
set D404 = ( R38 -firstChar );
set D405 = ( AllSymbolsOf R38 );
set D406 = ( AllTermsOf R38 );
reconsider D407 = D403 as Function;
reconsider D408 = ( D401 -TermEval ) , D409 = ( id D406 ) as (Function of D406 , D406);
L739:
now
let C332 being (Element of D406);
consider R30 being (Element of ( NAT )) such that L740: C332 in ( D407 . R30 ) by FOMODEL1:5;
reconsider D410 = C332 as (Element of ( D403 . R30 )) by L740;
reconsider D411 = ( R30 + 1 ) as (Element of ( NAT ));
reconsider D412 = C332 as (Element of ( D403 . R30 )) by L740;
set D413 = ( D401 -TermEval C332 );
L741: ( D402 . D411 ) is (Element of ( Funcs (D406 , D406) ));
reconsider D414 = ( D402 . ( R30 + 1 ) ) as (Function of D406 , D406) by L741;
L742: ( ( ( D414 | ( D403 . R30 ) ) . D410 ) \+\ ( D414 . D410 ) ) = ( {} );
L743: ( ( D414 | ( D403 . R30 ) ) . D410 ) = ( D414 . D410 ) by L742 , FOMODEL0:29;
L744: (( { ( ( id ( D403 . R30 ) ) . D412 ) } \ { D412 } ) = ( {} ) & ( { ( ( id D406 ) . C332 ) } \ { C332 } ) = ( {} ));
L745: (( ( id ( D403 . R30 ) ) . D412 ) = D412 & ( ( id D406 ) . C332 ) = C332) by L744 , ZFMISC_1:15;
thus L746: ( D408 . C332 ) = D413 by FOMODEL2:def 10
.= ( D414 . C332 ) by L740 , FOMODEL2:def 9
.= ( D409 . C332 ) by L745 , L743 , L713;
end;
thus L747: thesis by L739 , FUNCT_2:63;
end;
L748: (for R13 being non  empty set holds (for R14 being non  empty set holds (for B175 being (Relation of R13 , R14) holds ( ( 0 ) -placesOf B175 ) = ( id { ( {} ) } ))))
proof
let R13 being non  empty set;
let R14 being non  empty set;
let C333 being (Relation of R13 , R14);
L749: ( ( ( 0 ) -placesOf C333 ) \+\ ( id { ( {} ) } ) ) = ( {} );
thus L750: thesis by L749 , FOMODEL0:29;
end;
theorem
L751: (for R12 being non  empty set holds (for R38 being Language holds (for B176 being (Equivalence_Relation of R12) holds (for B177 being B176 -respecting (R38 , R12)-interpreter-like Function holds ( ( B177 quotient B176 ) -TermEval ) = ( ( B176 -class ) * ( B177 -TermEval ) ))))) by L688;
theorem
L752: (for R4 being set holds (for R38 being Language holds ( ( (R38 , R4) -freeInterpreter ) -TermEval ) = ( id ( AllTermsOf R38 ) ))) by L738;
theorem
L753: (for R13 being non  empty set holds (for R38 being Language holds (for B178 being (Equivalence_Relation of R13) holds (for B179 being  0wff (string of R38) holds (for B180 being B178 -respecting (R38 , R13)-interpreter-like Function holds (( ( R38 -firstChar ) . B179 ) <> ( TheEqSymbOf R38 ) implies ( ( B180 quotient B178 ) -AtomicEval B179 ) = ( B180 -AtomicEval B179 ))))))) by L695;
L754: (for R25 being Nat holds (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds ( ( R45 SubstWith R46 ) | ( ( R38 -termsOfMaxDepth ) . R25 ) ) is (Function of ( ( R38 -termsOfMaxDepth ) . R25 ) , ( ( R38 -termsOfMaxDepth ) . R25 ))))))
proof
let R25 being Nat;
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
set D415 = ( R38 -termsOfMaxDepth );
set D416 = ( R38 -firstChar );
set D417 = ( R38 -multiCat );
set D418 = ( AllSymbolsOf R38 );
set D419 = ( ( D418 * ) \ { ( {} ) } );
set D420 = ( D418 -concatenation );
set D421 = ( MultPlace D420 );
set D422 = ( R45 SubstWith R46 );
L755: (for B181 being ( 0 ) -termal (string of R38) holds ( D422 . B181 ) in ( D415 . ( 0 ) ))
proof
let C334 being ( 0 ) -termal (string of R38);
set D423 = ( D416 . C334 );
L756: C334 = <* D423 *> by FOMODEL2:1;
L757: (D423 = R45 or D423 <> R45);
L758: (( D422 . <* D423 *> ) = <* R46 *> or ( D422 . <* D423 *> ) = <* D423 *>) by L757 , FOMODEL0:35;
thus L759: thesis by L758 , L756 , FOMODEL1:def 33;
end;
defpred S9[ Nat ] means ( D422 | ( D415 . $1 ) ) is (Function of ( D415 . $1 ) , ( D415 . $1 ));
L760: S9[ ( 0 ) ]
proof
reconsider D424 = ( 0 ) as (Element of ( NAT ));
reconsider D425 = ( D415 . D424 ) as (Subset of ( D418 * )) by XBOOLE_1:1;
set D426 = ( D422 | D425 );
L761: ( dom D426 ) = D425 by PARTFUN1:def 2;
L762:
now
let R7 being set;
assume L763: R7 in D425;
reconsider D427 = R7 as ( 0 ) -termal (string of R38) by L763 , FOMODEL1:def 33;
set D428 = ( D416 . D427 );
reconsider D429 = D427 as (Element of D425) by FOMODEL1:def 33;
L764: ( ( D426 . D429 ) \+\ ( D422 . D429 ) ) = ( {} );
L765: ( D426 . R7 ) = ( D422 . R7 ) by L764 , FOMODEL0:29;
L766: ( D426 . D427 ) in D425 by L765 , L755;
thus L767: ( D426 . R7 ) in D425 by L766;
end;
thus L768: thesis by L762 , L761 , FUNCT_2:3;
end;
L769: (for R25 being Nat holds (S9[ R25 ] implies S9[ ( R25 + 1 ) ]))
proof
let R25 being Nat;
reconsider D430 = R25 , D431 = ( R25 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L770: S9[ R25 ];
reconsider D432 = ( D415 . D430 ) , D433 = ( D415 . D431 ) as (Subset of ( D418 * )) by XBOOLE_1:1;
reconsider D434 = ( D422 | ( D415 . R25 ) ) as (Function of ( D415 . D430 ) , ( D415 . D430 )) by L770;
set D435 = ( D422 | D433 );
L771: ( dom D435 ) = D433 by PARTFUN1:def 2;
L772:
now
let C335 being set;
assume L773: C335 in D433;
reconsider D436 = C335 as (Element of D433) by L773;
reconsider D437 = D436 as ( D430 + 1 ) -termal (string of R38) by FOMODEL1:def 33 , TARSKI:def 3;
set D438 = ( SubTerms D437 );
L774: ( dom D434 ) = ( D415 . D430 ) by FUNCT_2:def 1;
L775: ( rng D438 ) c= ( dom D434 ) by L774 , RELAT_1:def 19;
L776: ( D422 * D438 ) = ( D434 * D438 ) by L775 , RELAT_1:165;
reconsider D439 = ( D416 . D437 ) as  termal (Element of R38);
set D440 = ( abs ( ar D439 ) );
L777: ( D434 * D438 ) is (FinSequence of ( D415 . D430 )) by FOMODEL0:26;
reconsider D441 = ( D434 * D438 ) as D440 -element (Element of ( ( D415 . D430 ) * )) by L777 , FINSEQ_1:def 11;
L778: ( ( D435 . D436 ) \+\ ( D422 . D436 ) ) = ( {} );
L779: ( D435 . C335 ) = ( D422 . C335 ) by L778 , FOMODEL0:29;
L780: ((D439 = R45 implies (( D422 . <* D439 *> ) = <* R46 *> & ( ar D439 ) = ( ar R46 ))) & (D439 <> R45 implies (( D422 . <* D439 *> ) = <* D439 *> & ( ar D439 ) = ( ar D439 )))) by FOMODEL0:35;
consider C336 being  termal (Element of R38) such that L781: (( D422 . <* D439 *> ) = <* C336 *> & ( ar D439 ) = ( ar C336 )) by L780;
reconsider D442 = D441 as ( abs ( ar C336 ) ) -element (Element of ( ( D415 . D430 ) * )) by L781;
L782: ( D422 . D437 ) = ( D422 . ( <* ( D416 . D437 ) *> ^ ( D417 . D438 ) ) ) by FOMODEL1:def 37
.= ( ( D422 . <* D439 *> ) ^ ( D422 . ( D417 . D438 ) ) ) by FOMODEL0:36
.= ( C336 -compound D442 ) by L776 , L781 , FOMODEL0:37;
thus L783: ( D435 . C335 ) in ( D415 . ( D430 + 1 ) ) by L782 , L779 , FOMODEL1:def 33;
end;
thus L784: thesis by L772 , L771 , FUNCT_2:3;
end;
L785: (for R26 being Nat holds S9[ R26 ]) from NAT_1:sch 2(L760 , L769);
thus L786: thesis by L785;
end;
definition
let R38 being Language;
let R7 being set;
let R41 being (Element of R38);
let R49 being (string of R38);
redefine func (R7 , R41) -SymbolSubstIn R49 -> (string of R38);

coherence
proof
L787: ( (R7 , R41) -SymbolSubstIn ( R49 null R49 ) ) is ( ( len R49 ) + ( 0 ) ) -element;
thus L788: thesis by L787 , FOMODEL0:30;
end;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R25 being Nat;
let C337 being R25 -termal (string of R38);
cluster ( (R45 , R46) -SymbolSubstIn C337 ) -> R25 -termal for (string of R38);
coherence
proof
set D443 = ( R45 SubstWith R46 );
set D444 = ( R38 -termsOfMaxDepth );
set D445 = ( AllSymbolsOf R38 );
set D446 = ( (R45 , R46) -SymbolSubstIn C337 );
reconsider D447 = R25 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D448 = ( D443 | ( D444 . R25 ) ) as (Function of ( D444 . R25 ) , ( D444 . R25 )) by L754;
reconsider D449 = C337 as (Element of ( D444 . R25 )) by FOMODEL1:def 33;
L790: ( ( D448 . D449 ) \+\ ( D443 . D449 ) ) = ( {} );
L791: ( D448 . D449 ) = ( D443 . D449 ) by L790 , FOMODEL0:29;
L792: ( D443 . C337 ) in ( D444 . D447 ) by L791;
L793: D446 in ( D444 . D447 ) by L792 , FOMODEL0:def 23;
thus L794: thesis by L793 , FOMODEL1:def 33;
end;
end;
registration
let R38 being Language;
let R52 being  termal (string of R38);
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
cluster ( (R45 , R46) -SymbolSubstIn R52 ) ->  termal for (string of R38);
coherence
proof
set D450 = ( (R45 , R46) -SymbolSubstIn R52 );
set D451 = ( AllTermsOf R38 );
set D452 = ( R38 -termsOfMaxDepth );
reconsider D453 = D452 as Function;
L796: R52 in D451 by FOMODEL1:def 32;
consider R30 being (Element of ( NAT )) such that L797: R52 in ( D453 . R30 ) by L796 , FOMODEL1:5;
reconsider D454 = R52 as R30 -termal (string of R38) by L797 , FOMODEL1:def 33;
L798: ( (R45 , R46) -SymbolSubstIn D454 ) is R30 -termal;
thus L799: thesis by L798;
end;
end;
L801: (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds ( ( R45 SubstWith R46 ) | ( AllTermsOf R38 ) ) is (Function of ( AllTermsOf R38 ) , ( AllTermsOf R38 )))))
proof
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
set D455 = ( R45 SubstWith R46 );
set D456 = ( AllSymbolsOf R38 );
set D457 = ( AllTermsOf R38 );
L802: ( D457 /\ ( ( D456 * ) \ { ( {} ) } ) ) = ( D457 null ( ( D456 * ) \ { ( {} ) } ) )
.= D457;
reconsider D458 = D457 as non  empty (Subset of ( D456 * )) by L802;
set D459 = ( D455 | D458 );
L803: ( dom D459 ) = D458 by PARTFUN1:def 2;
L804:
now
let R7 being set;
assume L805: R7 in D458;
reconsider D460 = R7 as  termal (string of R38) by L805;
reconsider D461 = R7 as (Element of D458) by L805;
L806: ( ( D459 . D461 ) \+\ ( D455 . D461 ) ) = ( {} );
L807: ( D459 . D461 ) = ( D455 . D461 ) by L806 , FOMODEL0:29
.= ( (R45 , R46) -SymbolSubstIn D460 ) by FOMODEL0:def 23;
thus L808: ( D459 . R7 ) in D458 by L807 , FOMODEL1:def 32;
end;
thus L809: thesis by L804 , L803 , FUNCT_2:3;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let C338 being  0wff (string of R38);
cluster ( (R45 , R46) -SymbolSubstIn C338 ) ->  0wff for (string of R38);
coherence
proof
let C339 being (string of R38);
assume that
L810: C339 = ( (R45 , R46) -SymbolSubstIn C338 );
set D462 = ( (R45 , R46) -SymbolSubstIn C338 );
set D463 = ( R45 SubstWith R46 );
set D464 = ( AllSymbolsOf R38 );
set D465 = ( AllTermsOf R38 );
set D466 = ( R38 -multiCat );
L811: ( D465 /\ ( ( D464 * ) \ { ( {} ) } ) ) = ( D465 null ( ( D464 * ) \ { ( {} ) } ) )
.= D465;
reconsider D467 = D465 as non  empty (Subset of ( D464 * )) by L811;
reconsider D468 = ( D463 | D465 ) as (Function of D465 , D465) by L801;
consider C340 being  relational (Element of R38), C341 being ( abs ( ar C340 ) ) -element (Element of ( D465 * )) such that L812: C338 = ( <* C340 *> ^ ( D466 . C341 ) ) by FOMODEL1:def 35;
set D469 = ( abs ( ar C340 ) );
reconsider D470 = C341 as D469 -element (FinSequence of D465) by FOMODEL0:26;
reconsider D471 = ( D468 * D470 ) as D469 -element (Element of ( D465 * )) by FINSEQ_1:def 11;
L813: C341 in ( D467 * );
reconsider D472 = C341 as (Element of ( ( D464 * ) * )) by L813;
L814: (( rng C341 ) c= D465 & ( dom D468 ) = D465) by FUNCT_2:def 1 , RELAT_1:def 19;
L815: D462 = ( D463 . C338 ) by FOMODEL0:def 23
.= ( ( D463 . <* C340 *> ) ^ ( D463 . ( D466 . D472 ) ) ) by L812 , FOMODEL0:36
.= ( <* C340 *> ^ ( D463 . ( D466 . D472 ) ) ) by FOMODEL0:35
.= ( <* C340 *> ^ ( D466 . ( D463 * D472 ) ) ) by FOMODEL0:37
.= ( <* C340 *> ^ ( D466 . D471 ) ) by L814 , RELAT_1:165;
thus L816: C339 is  0wff by L815 , L810 , FOMODEL1:def 35;
end;
end;
registration
let R38 being Language;
let C342 being  zero number;
let C343 being C342 -wff (string of R38);
cluster ( Depth C343 ) ->  zero for number;
coherence by FOMODEL2:def 31;
end;
L819: (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R57 being  wff (string of R38) holds (ex B182 being  wff (string of R38) st (( Depth R57 ) = ( Depth B182 ) & ( ( R45 SubstWith R46 ) . R57 ) = B182))))))
proof
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R57 being  wff (string of R38);
set D473 = ( R45 SubstWith R46 );
set D474 = ( TheNorSymbOf R38 );
set D475 = ( LettersOf R38 );
defpred S10[  wff (string of R38) ] means (ex B183 being  wff (string of R38) st (( Depth B183 ) = ( Depth $1 ) & ( D473 . $1 ) = B183));
defpred S11[ Nat ] means (for R59 being  wff (string of R38) holds (( Depth R59 ) <= $1 implies S10[ R59 ]));
L820: S11[ ( 0 ) ]
proof
thus L821: (for R59 being  wff (string of R38) holds (( Depth R59 ) <= ( 0 ) implies S10[ R59 ]))
proof
let R59 being  wff (string of R38);
set D476 = ( Depth R59 );
assume L822: D476 <= ( 0 );
L823: D476 = ( 0 ) by L822;
reconsider D477 = R59 as ( 0 ) -wff (string of R38) by L823 , FOMODEL2:def 31;
reconsider D478 = ( (R45 , R46) -SymbolSubstIn D477 ) as  0wff (string of R38);
take D478;
thus L824: ( Depth D478 ) = D476;
thus L825: ( D473 . R59 ) = D478 by FOMODEL0:def 23;
end;

end;
L822: (for R26 being Nat holds (S11[ R26 ] implies S11[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
set D479 = ( R38 -formulasOfMaxDepth R26 );
assume L823: S11[ R26 ];
thus L824: (for R59 being  wff (string of R38) holds (( Depth R59 ) <= ( R26 + 1 ) implies S10[ R59 ]))
proof
let R59 being  wff (string of R38);
set D480 = ( Depth R59 );
assume L825: D480 <= ( R26 + 1 );
per cases ;
suppose L826: R59 is  0wff;

reconsider D481 = R59 as  0wff (string of R38) by L826;
reconsider D482 = ( (R45 , R46) -SymbolSubstIn D481 ) as  0wff (string of R38);
take D482;
thus L827: ( Depth D482 ) = D480;
thus L828: ( D473 . R59 ) = D482 by FOMODEL0:def 23;
end;
suppose L829: R59 is  exal;

consider R25 being Nat such that L830: D480 = ( R25 + 1 ) by L829 , NAT_1:6;
L831: R59 in ( R25 -ExFormulasOf R38 ) by L830 , L829 , FOMODEL2:18;
consider C344 being (Element of D475), C345 being (Element of ( R38 -formulasOfMaxDepth R25 )) such that L832: (R59 = ( <* C344 *> ^ C345 ) & (not contradiction)) by L831;
reconsider D483 = C344 as  literal (Element of R38);
reconsider D484 = C345 as R25 -wff (string of R38) by FOMODEL2:def 24;
set D485 = ( Depth D484 );
L833: ( D485 + 1 ) <= ( R26 + 1 ) by L825 , L832 , FOMODEL2:17;
L834: D485 <= R26 by L833 , XREAL_1:6;
consider C346 being  wff (string of R38) such that L835: (( Depth C346 ) = ( Depth D484 ) & ( D473 . D484 ) = C346) by L834 , L823;
L836: (D483 = R45 or D483 <> R45);
L837: (( D473 . <* D483 *> ) = <* R46 *> or ( D473 . <* D483 *> ) = <* D483 *>) by L836 , FOMODEL0:35;
consider C347 being  literal (Element of R38) such that L838: ( D473 . <* D483 *> ) = <* C347 *> by L837;
take D486 = ( <* C347 *> ^ C346 );
thus L839: ( Depth D486 ) = ( ( Depth C346 ) + 1 ) by FOMODEL2:17
.= D480 by L835 , L832 , FOMODEL2:17;
thus L840: ( D473 . R59 ) = D486 by L838 , L835 , L832 , FOMODEL0:36;
end;
suppose L841: (not (R59 is  exal or R59 is  0wff));

consider R25 being Nat such that L842: D480 = ( R25 + 1 ) by L841 , NAT_1:6;
L843: R59 in ( R25 -NorFormulasOf R38 ) by L841 , L842 , FOMODEL2:18;
consider C348 , C349 being (Element of ( R38 -formulasOfMaxDepth R25 )) such that L844: (R59 = ( ( <* D474 *> ^ C348 ) ^ C349 ) & (not contradiction)) by L843;
reconsider D487 = C348 , D488 = C349 as R25 -wff (string of R38) by FOMODEL2:def 24;
set D489 = ( Depth D487 );
set D490 = ( Depth D488 );
set D491 = ( max (D489 , D490) );
L845: (( ( D491 - D489 ) + D489 ) >= ( ( 0 ) + D489 ) & ( ( D491 - D490 ) + D490 ) >= ( ( 0 ) + D490 )) by XREAL_1:6;
L846: ( R26 + 1 ) >= ( D491 + 1 ) by L825 , L844 , FOMODEL2:17;
L847: R26 >= D491 by L846 , XREAL_1:6;
L848: (S10[ D487 ] & S10[ D488 ]) by L847 , L823 , L845 , XXREAL_0:2;
consider C350 , C351 being  wff (string of R38) such that L849: (( Depth C350 ) = ( Depth D487 ) & ( D473 . D487 ) = C350 & ( Depth C351 ) = ( Depth D488 ) & ( D473 . D488 ) = C351) by L848;
take D492 = ( ( <* D474 *> ^ C350 ) ^ C351 );
thus L850: D480 = ( D491 + 1 ) by L844 , FOMODEL2:17
.= ( Depth D492 ) by L849 , FOMODEL2:17;
thus L851: ( D473 . R59 ) = ( ( D473 . ( <* D474 *> ^ D487 ) ) ^ ( D473 . D488 ) ) by L844 , FOMODEL0:36
.= ( ( ( D473 . <* D474 *> ) ^ ( D473 . D487 ) ) ^ C351 ) by L849 , FOMODEL0:36
.= D492 by L849 , FOMODEL0:35;
end;
end;

end;
L825: (for R26 being Nat holds S11[ R26 ]) from NAT_1:sch 2(L820 , L822);
thus L826: thesis by L825;
end;
definition
let R38 being Language;
let R25 being Nat;
let R49 being (string of R38);
redefine func R49 null R25 -> (string of R38);

coherence;
end;
registration
let R38 being Language;
let R59 being  wff (string of R38);
let R25 being Nat;
cluster ( R59 null R25 ) -> ( ( Depth R59 ) + R25 ) -wff for (string of R38);
coherence
proof
set D493 = ( Depth R59 );
L828: R59 is ( D493 + ( ( 0 ) * R25 ) ) -wff by FOMODEL2:def 31;
thus L829: thesis by L828;
end;
end;
registration
let R38 being Language;
let R25 being Nat;
let C352 being R25 -wff (string of R38);
cluster ( R25 - ( Depth C352 ) ) -> non  negative for  ext-real  ext-real  ext-real  ext-real number;
coherence
proof
set D494 = ( Depth C352 );
L831: D494 <= R25 by FOMODEL2:def 31;
L832: ( D494 - D494 ) <= ( R25 - D494 ) by L831 , XREAL_1:9;
thus L833: thesis by L832;
end;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R25 being Nat;
let C353 being R25 -wff (string of R38);
cluster ( (R45 , R46) -SymbolSubstIn C353 ) -> R25 -wff for (string of R38);
coherence
proof
set D495 = ( Depth C353 );
set D496 = ( R45 SubstWith R46 );
reconsider D497 = ( R25 - D495 ) as Nat;
consider C354 being  wff (string of R38) such that L835: (( Depth C354 ) = D495 & ( D496 . C353 ) = C354) by L819;
set D498 = ( Depth C354 );
L836: ( C354 null D497 ) is ( D498 + D497 ) -wff;
thus L837: thesis by L836 , L835 , FOMODEL0:def 23;
end;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R59 being  wff (string of R38);
cluster ( (R45 , R46) -SymbolSubstIn R59 ) ->  wff for (string of R38);
coherence
proof
set D499 = ( (R45 , R46) -SymbolSubstIn R59 );
consider R25 being Nat such that L839: R59 is R25 -wff by FOMODEL2:def 25;
thus L840: thesis by L839;
end;
end;
L842: (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R57 being  wff (string of R38) holds ( Depth R57 ) = ( Depth ( (R45 , R46) -SymbolSubstIn R57 ) )))))
proof
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R57 being  wff (string of R38);
set D500 = ( R45 SubstWith R46 );
set D501 = ( (R45 , R46) -SymbolSubstIn R57 );
consider R58 being  wff (string of R38) such that L843: (( Depth R58 ) = ( Depth R57 ) & R58 = ( D500 . R57 )) by L819;
thus L844: thesis by L843 , FOMODEL0:def 23;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R59 being  wff (string of R38);
cluster ( ( Depth ( (R45 , R46) -SymbolSubstIn R59 ) ) \+\ ( Depth R59 ) ) ->  empty for set;
coherence
proof
L845: ( Depth ( (R45 , R46) -SymbolSubstIn R59 ) ) = ( Depth R59 ) by L842;
thus L846: thesis by L845;
end;
end;
theorem
L848: (for R4 being set holds (for R38 being Language holds (for R47 being  ofAtomicFormula (Element of R38) holds (for B184 being ( abs ( ar R47 ) ) -element (Element of ( ( AllTermsOf R38 ) * )) holds (((not R47 is  relational) implies ( ( R4 -freeInterpreter R47 ) . B184 ) = ( R47 -compound B184 )) & (R47 is  relational implies ( ( R4 -freeInterpreter R47 ) . B184 ) = ( ( chi (R4 , ( AtomicFormulasOf R38 )) ) . ( R47 -compound B184 ) )))))))
proof
let R4 being set;
let R38 being Language;
let R47 being  ofAtomicFormula (Element of R38);
set D502 = ( AllTermsOf R38 );
set D503 = ( AllSymbolsOf R38 );
set D504 = ( R4 -freeInterpreter R47 );
set D505 = ( R47 -compound );
set D506 = ( abs ( ar R47 ) );
set D507 = ( D505 | ( D506 -tuples_on D502 ) );
set D508 = ( AtomicFormulasOf R38 );
set D509 = ( chi (R4 , D508) );
let C355 being D506 -element (Element of ( D502 * ));
L849: ( dom D505 ) = ( ( ( D503 * ) \ { ( {} ) } ) * ) by FUNCT_2:def 1;
L850: C355 in ( D506 -tuples_on D502 ) by FOMODEL0:16;
L851: (( D507 . C355 ) = ( D505 . C355 ) & ( R47 -compound C355 ) = ( D505 . C355 )) by L850 , L64 , FUNCT_1:49;
thus L852: ((not R47 is  relational) implies ( D504 . C355 ) = ( R47 -compound C355 )) by L851 , L95;
assume L853: R47 is  relational;
L854: D504 = ( D509 * D507 ) by L853 , L95
.= ( ( D509 * D505 ) | ( D506 -tuples_on D502 ) ) by RELAT_1:83;
L855: ( D504 . C355 ) = ( ( D509 * D505 ) . C355 ) by L854 , FOMODEL0:16 , FUNCT_1:49
.= ( D509 . ( D505 . C355 ) ) by L849 , FUNCT_1:13;
thus L856: thesis by L855 , L64;
end;
registration
let C356 being Language;
cluster  termal for (string of C356);
existence
proof
take D510 = <* the  literal (Element of C356) *>;
thus L857: thesis;
end;
cluster  0wff for (string of C356);
existence
proof
take the (Element of ( AtomicFormulasOf C356 ));
thus L858: thesis;
end;
end;
theorem
L860: (for R4 being set holds (for R12 being non  empty set holds (for R26 being Nat holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R62 being (R38 , R12)-interpreter-like Function holds (for R64 being (Element of ( AllTermsOf R38 )) holds ( ( ( R62 -TermEval ) * ( ( (( (R44 , R64) ReassignIn ( (R38 , R4) -freeInterpreter ) ) , R64) -TermEval ) . R26 ) ) | ( ( R38 -termsOfMaxDepth ) . R26 ) ) = ( ( ( (( (R44 , ( ( R62 -TermEval ) . R64 )) ReassignIn R62 ) , ( ( R62 -TermEval ) . R64 )) -TermEval ) . R26 ) | ( ( R38 -termsOfMaxDepth ) . R26 ) ))))))))
proof
let R4 being set;
let R12 being non  empty set;
let R26 being Nat;
let R38 being Language;
let R44 being  literal (Element of R38);
let R62 being (R38 , R12)-interpreter-like Function;
let R64 being (Element of ( AllTermsOf R38 ));
set D511 = ( R12 -InterpretersOf R38 );
reconsider D512 = ( ( R62 -TermEval ) . R64 ) as (Element of R12);
set D513 = ( R38 -firstChar );
set D514 = ( (R38 , R4) -freeInterpreter );
set D515 = ( (R44 , R64) ReassignIn D514 );
set D516 = ( AllTermsOf R38 );
set D517 = ( (R62 , D512) -TermEval );
set D518 = ( (D514 , R64) -TermEval );
set D519 = ( (D515 , R64) -TermEval );
set D520 = ( R62 -TermEval );
set D521 = ( (R44 , ( D520 . R64 )) ReassignIn R62 );
set D522 = ( (D521 , D512) -TermEval );
set D523 = ( R38 -multiCat );
set D524 = ( AllSymbolsOf R38 );
set D525 = ( R38 -termsOfMaxDepth );
reconsider D526 = R64 as  termal (string of R38);
set D527 = ( Depth D526 );
reconsider D528 = D526 as D527 -termal (string of R38) by FOMODEL1:def 40;
L861: (R44 in { R44 } & ( dom ( R44 .--> ( ( {} ) .--> R64 ) ) ) = { R44 } & ( dom ( R44 .--> ( ( {} ) .--> ( D520 . R64 ) ) ) ) = { R44 }) by FUNCOP_1:13 , TARSKI:def 1;
L862: (( D515 . R44 ) = ( ( R44 .--> ( ( {} ) .--> R64 ) ) . R44 ) & ( D521 . R44 ) = ( ( R44 .--> ( ( {} ) .--> ( D520 . R64 ) ) ) . R44 )) by L861 , FUNCT_4:13;
L863: (( D515 . R44 ) = ( ( {} ) .--> R64 ) & ( D521 . R44 ) = ( ( {} ) .--> ( D520 . R64 ) )) by L862 , L861 , FUNCOP_1:7;
defpred S12[ Nat ] means ( ( D520 * ( D519 . $1 ) ) | ( D525 . $1 ) ) = ( ( D522 . $1 ) | ( D525 . $1 ) );
L864: S12[ ( 0 ) ]
proof
L865: (( dom ( D516 --> D512 ) ) = D516 & ( dom ( D516 --> R64 ) ) = D516 & ( dom D520 ) = D516) by FUNCT_2:def 1;
L866: (( D517 . ( 0 ) ) = ( D516 --> D512 ) & ( D519 . ( 0 ) ) = ( D516 --> R64 )) by FOMODEL2:def 8;
L867: ( D520 * ( D519 . ( 0 ) ) ) = ( D516 --> ( D520 . R64 ) ) by L866 , L865 , FUNCOP_1:17
.= ( D522 . ( 0 ) ) by FOMODEL2:def 8;
thus L868: thesis by L867;
end;
L869: (for R25 being Nat holds (S12[ R25 ] implies S12[ ( R25 + 1 ) ]))
proof
let R25 being Nat;
reconsider D529 = R25 , D530 = ( R25 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L870: S12[ R25 ];
reconsider D531 = ( D525 . D530 ) , D532 = ( D525 . D529 ) as (Subset of D516) by FOMODEL1:2;
L871: (( D522 . D529 ) is (Element of ( Funcs (D516 , R12) )) & ( D517 . D530 ) is (Element of ( Funcs (D516 , R12) )) & ( D522 . D530 ) is (Element of ( Funcs (D516 , R12) )) & ( D517 . D529 ) is (Element of ( Funcs (D516 , R12) )));
reconsider D533 = ( D522 . D529 ) , D534 = ( D522 . D530 ) , D535 = ( D517 . D530 ) , D536 = ( D517 . D529 ) as (Function of D516 , R12) by L871;
L872: (( D519 . D529 ) is (Element of ( Funcs (D516 , D516) )) & ( D519 . D530 ) is (Element of ( Funcs (D516 , D516) )));
reconsider D537 = ( D519 . D529 ) , D538 = ( D519 . D530 ) as (Function of D516 , D516) by L872;
set D539 = ( ( D520 * D538 ) | D531 );
set D540 = ( D534 | D531 );
L873: (( dom D539 ) = D531 & ( dom D540 ) = D531) by PARTFUN1:def 2;
L874:
now
let R7 being set;
assume L875: R7 in ( dom D539 );
L876: R7 in ( dom ( D520 * D538 ) ) by L875 , RELAT_1:57;
reconsider D541 = R7 as (Element of D516) by L876;
reconsider D542 = R7 as ( D529 + 1 ) -termal (string of R38) by L873 , L875 , FOMODEL1:def 33;
reconsider D543 = R7 as (Element of D531) by L875;
set D544 = ( SubTerms D542 );
set D545 = ( D513 . D542 );
set D546 = ( abs ( ar D545 ) );
L877: (( ( ( ( D535 * D538 ) | D531 ) . D543 ) \+\ ( ( D535 * D538 ) . D543 ) ) = ( {} ) & ( ( ( D534 | D531 ) . D543 ) \+\ ( D534 . D543 ) ) = ( {} ) & ( ( ( ( D520 * D538 ) | D531 ) . D543 ) \+\ ( ( D520 * D538 ) . D543 ) ) = ( {} ));
L878: (( ( ( D535 * D538 ) | D531 ) . R7 ) = ( ( D535 * D538 ) . R7 ) & ( ( D534 | D531 ) . R7 ) = ( D534 . R7 ) & ( ( ( D520 * D538 ) | D531 ) . R7 ) = ( ( D520 * D538 ) . R7 )) by L877 , FOMODEL0:29;
L879: (( ( ( D535 * D538 ) . D541 ) \+\ ( D535 . ( D538 . D541 ) ) ) = ( {} ) & ( ( ( D520 * D538 ) . D541 ) \+\ ( D520 . ( D538 . D541 ) ) ) = ( {} ));
L880: (( ( D535 * D538 ) . D542 ) = ( D535 . ( D538 . D542 ) ) & ( ( D520 * D538 ) . D541 ) = ( D520 . ( D538 . D541 ) )) by L879 , FOMODEL0:29;
reconsider D547 = ( D537 * D544 ) as D546 -element (FinSequence of D516) by FOMODEL0:26;
reconsider D548 = D547 as (Element of ( D546 -tuples_on D516 )) by FOMODEL0:16;
reconsider D549 = D547 as (FinSequence of ( ( D524 * ) \ { ( {} ) } )) by FOMODEL0:26;
L881: ( ( ( ( D545 -compound ) | ( D546 -tuples_on D516 ) ) . D548 ) \+\ ( ( D545 -compound ) . D548 ) ) = ( {} );
L882: ( ( ( D545 -compound ) | ( D546 -tuples_on D516 ) ) . D547 ) = ( ( D545 -compound ) . D547 ) by L881 , FOMODEL0:29;
per cases ;
suppose L883: D545 = R44;

L884: (D545 = R44 & D542 is ( 0 ) -termal) by L883 , FOMODEL1:16;
L885: (( ( D520 * D538 ) . D542 ) = ( D520 . ( ( ( {} ) .--> R64 ) . ( {} ) ) ) & ( D534 . D542 ) = ( ( ( {} ) .--> ( D520 . R64 ) ) . ( {} ) ) & ( {} ) in { ( {} ) }) by L884 , L880 , L863 , FOMODEL2:3 , TARSKI:def 1;
L886: (( ( D520 * D538 ) . D542 ) = ( D520 . R64 ) & ( D534 . D542 ) = ( D520 . R64 )) by L885 , FUNCOP_1:7;
thus L887: ( D539 . R7 ) = ( D540 . R7 ) by L886 , L878;
end;
suppose L888: D545 <> R44;

L889: ((not D545 in ( dom ( R44 .--> ( ( {} ) .--> R64 ) ) )) & (not D545 in ( dom ( R44 .--> ( ( {} ) .--> ( D520 . R64 ) ) ) ))) by L888 , TARSKI:def 1;
L890: ( D514 . D545 ) = ( D515 . D545 ) by L889 , FUNCT_4:11;
L891: ( D515 . D545 ) = ( R4 -freeInterpreter D545 ) by L890 , L113
.= ( ( D545 -compound ) | ( D546 -tuples_on D516 ) ) by L95;
reconsider D550 = D547 as D546 -element (Element of ( D516 * )) by FINSEQ_1:def 11;
L892: ( ( D515 . D545 ) . D547 ) = ( D545 -compound D550 ) by L882 , L64 , L891;
reconsider D551 = ( D545 -compound D550 ) as  termal (string of R38);
set D552 = ( Depth D551 );
reconsider D553 = D552 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D554 = D551 as D552 -termal (string of R38) by FOMODEL1:def 40;
reconsider D555 = D551 as (Element of D516) by FOMODEL1:def 32;
L893: ( D517 . D553 ) is (Element of ( Funcs (D516 , R12) ));
reconsider D556 = ( D517 . D553 ) as (Function of D516 , R12) by L893;
L894: ( D513 . D551 ) = ( D551 . 1 ) by FOMODEL0:6
.= D545 by FINSEQ_1:41;
L895: ( SubTerms D551 ) = D550 by L894 , FOMODEL1:def 37;
L896: (( dom ( D537 | D532 ) ) = D532 & ( dom ( D533 | D532 ) ) = D532 & ( rng D544 ) c= D532) by PARTFUN1:def 2 , RELAT_1:def 19;
L897: ( ( D520 * D538 ) . D542 ) = ( D520 . D551 ) by L892 , L880 , FOMODEL2:3
.= ( ( R62 . D545 ) . ( D520 * ( SubTerms D551 ) ) ) by L894 , FOMODEL2:21
.= ( ( R62 . D545 ) . ( D520 * ( ( D537 | D532 ) * D544 ) ) ) by L896 , L895 , RELAT_1:165
.= ( ( R62 . D545 ) . ( ( D520 * ( D537 | D532 ) ) * D544 ) ) by RELAT_1:36
.= ( ( R62 . D545 ) . ( ( ( D520 * D537 ) | D532 ) * D544 ) ) by RELAT_1:83
.= ( ( R62 . D545 ) . ( D533 * D544 ) ) by L870 , L896 , RELAT_1:165
.= ( ( D521 . D545 ) . ( D533 * D544 ) ) by L889 , FUNCT_4:11
.= ( D534 . D542 ) by FOMODEL2:3;
thus L898: ( D539 . R7 ) = ( D540 . R7 ) by L897 , L878;
end;
end;
thus L900: thesis by L874 , L873 , FUNCT_1:2;
end;
L901: (for R25 being Nat holds S12[ R25 ]) from NAT_1:sch 2(L864 , L869);
thus L902: thesis by L901;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R63 being (Element of ( AllTermsOf R38 ));
let R55 being  0wff (string of R38);
func (R44 , R63) AtomicSubst R55 -> FinSequence equals 
( <* ( ( R38 -firstChar ) . R55 ) *> ^ ( ( R38 -multiCat ) . ( ( ( (R44 , R63) ReassignIn ( (R38 , ( {} )) -freeInterpreter ) ) -TermEval ) * ( SubTerms R55 ) ) ) );
coherence;
end;
L904: (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R55 being  0wff (string of R38) holds (for R63 being (Element of ( AllTermsOf R38 )) holds ( (R44 , R63) AtomicSubst R55 ) is  0wff  0wff  0wff  0wff (string of R38)))))
proof
let R38 being Language;
let R44 being  literal (Element of R38);
let R55 being  0wff (string of R38);
let R63 being (Element of ( AllTermsOf R38 ));
set D557 = ( SubTerms R55 );
set D558 = ( (R38 , ( {} )) -freeInterpreter );
set D559 = ( (R44 , R63) ReassignIn D558 );
set D560 = ( R38 -multiCat );
set D561 = ( R38 -firstChar );
set D562 = ( D561 . R55 );
set D563 = ( abs ( ar D562 ) );
set D564 = ( AllTermsOf R38 );
set D565 = ( D559 -TermEval );
set D566 = ( AllSymbolsOf R38 );
reconsider D567 = D557 as (FinSequence of D564) by FOMODEL0:26;
reconsider D568 = ( D565 * D567 ) as (FinSequence of D564);
L905: D568 is (Element of ( D564 * )) by FINSEQ_1:def 11;
reconsider D569 = D568 as (Element of ( ( D566 * ) * )) by L905 , TARSKI:def 3;
reconsider D570 = ( <* ( D561 . R55 ) *> ^ ( D560 . D569 ) ) as (string of R38) by FOMODEL0:30;
L906: D570 is  0wff by L905 , FOMODEL1:def 35;
thus L907: thesis by L906;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R63 being (Element of ( AllTermsOf R38 ));
let R55 being  0wff (string of R38);
redefine func (R44 , R63) AtomicSubst R55 -> (string of R38);

coherence by L904;
end;
registration
let R38 being Language;
let R44 being  literal (Element of R38);
let R63 being (Element of ( AllTermsOf R38 ));
let R55 being  0wff (string of R38);
cluster ( (R44 , R63) AtomicSubst R55 ) ->  0wff for (string of R38);
coherence by L904;
end;
L910: (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R55 being  0wff (string of R38) holds (for R63 being (Element of ( AllTermsOf R38 )) holds (( ( R38 -firstChar ) . ( (R44 , R63) AtomicSubst R55 ) ) = ( ( R38 -firstChar ) . R55 ) & ( SubTerms ( (R44 , R63) AtomicSubst R55 ) ) = ( ( ( (R44 , R63) ReassignIn ( (R38 , ( {} )) -freeInterpreter ) ) -TermEval ) * ( SubTerms R55 ) ))))))
proof
let R38 being Language;
let R44 being  literal (Element of R38);
let R55 being  0wff (string of R38);
let R63 being (Element of ( AllTermsOf R38 ));
set D571 = ( (R44 , R63) AtomicSubst R55 );
set D572 = ( R38 -firstChar );
set D573 = ( R38 -multiCat );
set D574 = ( AllTermsOf R38 );
set D575 = ( (R38 , ( {} )) -freeInterpreter );
set D576 = ( (R44 , R63) ReassignIn D575 );
set D577 = ( D572 . R55 );
set D578 = ( D572 . D571 );
set D579 = ( abs ( ar D577 ) );
set D580 = ( abs ( ar D578 ) );
thus L911: ( D572 . D571 ) = ( D571 . 1 ) by FOMODEL0:6
.= ( D572 . R55 ) by FINSEQ_1:41;
reconsider D581 = ( SubTerms R55 ) as D579 -element (FinSequence of D574) by FOMODEL0:26;
reconsider D582 = ( ( D576 -TermEval ) * D581 ) as D580 -element (FinSequence of D574) by L911;
L912: D582 is D580 -element D580 -element D580 -element D580 -element (Element of ( D574 * )) by FINSEQ_1:def 11;
thus L913: thesis by L912 , L911 , FOMODEL1:def 38;
end;
L914: (for R4 being set holds (for R12 being non  empty set holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R62 being (R38 , R12)-interpreter-like Function holds (for R63 being (Element of ( AllTermsOf R38 )) holds ( ( R62 -TermEval ) * ( ( (R44 , R63) ReassignIn ( (R38 , R4) -freeInterpreter ) ) -TermEval ) ) = ( ( (R44 , ( ( R62 -TermEval ) . R63 )) ReassignIn R62 ) -TermEval )))))))
proof
let R4 being set;
let R12 being non  empty set;
let R38 being Language;
let R44 being  literal (Element of R38);
let R62 being (R38 , R12)-interpreter-like Function;
let R63 being (Element of ( AllTermsOf R38 ));
set D583 = ( R62 -TermEval );
set D584 = ( D583 . R63 );
set D585 = ( (R44 , D584) ReassignIn R62 );
set D586 = ( D585 -TermEval );
set D587 = ( R38 -firstChar );
set D588 = ( R38 -multiCat );
set D589 = ( (R38 , R4) -freeInterpreter );
set D590 = ( (R44 , R63) ReassignIn D589 );
set D591 = ( D590 -TermEval );
set D592 = ( AllTermsOf R38 );
set D593 = ( R38 -termsOfMaxDepth );
reconsider D594 = ( D583 * D591 ) , D595 = D586 as (Function of D592 , R12);
L915:
now
let C357 being (Element of D592);
reconsider D596 = C357 as  termal (string of R38);
set D597 = ( Depth D596 );
reconsider D598 = D597 , D599 = ( D597 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D600 = D596 as D597 -termal (string of R38) by FOMODEL1:def 40;
L916: D600 is ( D597 + ( ( 0 ) * 1 ) ) -termal;
reconsider D601 = D600 as D599 -termal (string of R38) by L916;
reconsider D602 = ( D593 . D599 ) , D603 = ( D593 . D598 ) as (Subset of D592) by FOMODEL1:2;
reconsider D604 = D600 as (Element of D603) by FOMODEL1:def 33;
reconsider D605 = D601 as (Element of D602) by FOMODEL1:def 33;
L917: ( ( (D590 , R63) -TermEval ) . D599 ) is (Element of ( Funcs (D592 , D592) ));
reconsider D606 = ( ( (D590 , R63) -TermEval ) . D599 ) as (Function of D592 , D592) by L917;
L918: ( ( (D585 , D584) -TermEval ) . D599 ) is (Element of ( Funcs (D592 , R12) ));
reconsider D607 = ( ( (D585 , D584) -TermEval ) . D599 ) as (Function of D592 , R12) by L918;
L919: (( ( D583 . ( D606 . C357 ) ) \+\ ( ( D583 * D606 ) . C357 ) ) = ( {} ) & ( ( ( ( D583 * D606 ) | D602 ) . D605 ) \+\ ( ( D583 * D606 ) . D605 ) ) = ( {} ) & ( ( ( D607 | D602 ) . D605 ) \+\ ( D607 . D605 ) ) = ( {} ));
L920: (( ( D583 * D606 ) . C357 ) = ( D583 . ( D606 . C357 ) ) & ( ( ( D583 * D606 ) | D602 ) . C357 ) = ( ( D583 * D606 ) . C357 ) & ( ( D607 | D602 ) . C357 ) = ( D607 . C357 )) by L919 , FOMODEL0:29;
L921: ( ( D594 . C357 ) \+\ ( D583 . ( D591 . C357 ) ) ) = ( {} );
L922: ( D594 . C357 ) = ( D583 . ( D591 . C357 ) ) by L921 , FOMODEL0:29
.= ( D583 . ( D590 -TermEval C357 ) ) by FOMODEL2:def 10
.= ( D583 . ( D606 . D604 ) ) by FOMODEL2:def 9
.= ( ( ( (D585 , D584) -TermEval ) . D599 ) . D604 ) by L920 , L860
.= ( D585 -TermEval C357 ) by FOMODEL2:def 9
.= ( D586 . C357 ) by FOMODEL2:def 10;
thus L923: ( D594 . C357 ) = ( D595 . C357 ) by L922;
end;
thus L924: thesis by L915 , FUNCT_2:63;
end;
theorem
L925: (for R12 being non  empty set holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R55 being  0wff (string of R38) holds (for R62 being (R38 , R12)-interpreter-like Function holds (for R63 being (Element of ( AllTermsOf R38 )) holds ( R62 -AtomicEval ( (R44 , R63) AtomicSubst R55 ) ) = ( ( (R44 , ( ( R62 -TermEval ) . R63 )) ReassignIn R62 ) -AtomicEval R55 )))))))
proof
let R12 being non  empty set;
let R38 being Language;
let R44 being  literal (Element of R38);
let R55 being  0wff (string of R38);
let R62 being (R38 , R12)-interpreter-like Function;
let R63 being (Element of ( AllTermsOf R38 ));
set D608 = ( (R44 , R63) AtomicSubst R55 );
set D609 = ( ( R62 -TermEval ) . R63 );
set D610 = ( (R44 , D609) ReassignIn R62 );
set D611 = ( R38 -firstChar );
set D612 = ( R38 -multiCat );
set D613 = ( (R38 , ( {} )) -freeInterpreter );
set D614 = ( D611 . R55 );
set D615 = ( D611 . D608 );
set D616 = ( abs ( ar D614 ) );
set D617 = ( abs ( ar D615 ) );
set D618 = ( R62 -TermEval );
set D619 = ( D610 -TermEval );
set D620 = ( TheEqSymbOf R38 );
set D621 = ( (R44 , R63) ReassignIn D613 );
set D622 = ( R12 -deltaInterpreter );
L926: (not D614 in ( dom ( R44 .--> ( ( {} ) .--> D609 ) ) )) by TARSKI:def 1;
L927: (D614 = D615 & ( D610 . D614 ) = ( R62 . D614 )) by L926 , L910 , FUNCT_4:11;
L928: ( D618 * ( SubTerms D608 ) ) = ( D618 * ( ( D621 -TermEval ) * ( SubTerms R55 ) ) ) by L910
.= ( ( D618 * ( D621 -TermEval ) ) * ( SubTerms R55 ) ) by RELAT_1:36
.= ( D619 * ( SubTerms R55 ) ) by L914;
per cases ;
suppose L929: D615 <> D620;

L930: ( R62 -AtomicEval D608 ) = ( ( D610 . D614 ) . ( D619 * ( SubTerms R55 ) ) ) by L929 , L927 , L928 , FOMODEL2:14
.= ( D610 -AtomicEval R55 ) by L929 , L927 , FOMODEL2:14;
thus L931: thesis by L930;
end;
suppose L932: D615 = D620;

L933: ( R62 -AtomicEval D608 ) = ( D622 . ( D618 * ( SubTerms D608 ) ) ) by L932 , FOMODEL2:14
.= ( D610 -AtomicEval R55 ) by L932 , L927 , L928 , FOMODEL2:14;
thus L934: thesis by L933;
end;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R25 being Nat;
cluster ( ( R45 SubstWith R46 ) | ( ( R38 -termsOfMaxDepth ) . R25 ) ) -> ( ( R38 -termsOfMaxDepth ) . R25 ) -valued for Relation;
coherence
proof
set D623 = ( R45 SubstWith R46 );
set D624 = ( R38 -termsOfMaxDepth );
set D625 = ( AllSymbolsOf R38 );
reconsider D626 = ( D624 . R25 ) as (Subset of ( D625 * )) by XBOOLE_1:1;
set D627 = ( D623 | D626 );
L936: ( dom D627 ) = D626 by PARTFUN1:def 2;
L937:
now
let R7 being set;
assume L938: R7 in D626;
reconsider D628 = R7 as (Element of D626) by L938;
reconsider D629 = D628 as R25 -termal (string of R38) by FOMODEL1:def 33 , TARSKI:def 3;
L939: ( ( D627 . D628 ) \+\ ( D623 . D628 ) ) = ( {} );
L940: ( D627 . R7 ) = ( D623 . D629 ) by L939 , FOMODEL0:29
.= ( (R45 , R46) -SymbolSubstIn D629 ) by FOMODEL0:def 23;
thus L941: ( D627 . R7 ) in ( D624 . R25 ) by L940 , FOMODEL1:def 33;
end;
thus L942: thesis by L937 , L936 , FUNCT_2:3;
end;
end;
registration
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
cluster ( ( R45 SubstWith R46 ) | ( AllTermsOf R38 ) ) -> ( AllTermsOf R38 ) -valued for Relation;
coherence
proof
set D630 = ( R45 SubstWith R46 );
set D631 = ( AllSymbolsOf R38 );
set D632 = ( AllTermsOf R38 );
reconsider D633 = D632 as non  empty (Subset of ( D631 * )) by XBOOLE_1:1;
L944: ( dom ( D630 | D633 ) ) = D633 by PARTFUN1:def 2;
L945:
now
let R7 being set;
assume L946: R7 in D633;
reconsider D634 = R7 as (Element of D633) by L946;
reconsider D635 = D634 as  termal (string of R38) by TARSKI:def 3;
L947: ( ( ( D630 | D633 ) . D634 ) \+\ ( D630 . D634 ) ) = ( {} );
L948: ( ( D630 | D633 ) . R7 ) = ( D630 . D635 ) by L947 , FOMODEL0:29
.= ( (R45 , R46) -SymbolSubstIn D635 ) by FOMODEL0:def 23;
thus L949: ( ( D630 | D633 ) . R7 ) in D633 by L948 , FOMODEL1:def 32;
end;
thus L950: thesis by L945 , L944 , FUNCT_2:3;
end;
end;
L952: (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R52 being  termal (string of R38) holds ( SubTerms ( (R45 , R46) -SymbolSubstIn R52 ) ) = ( ( R45 SubstWith R46 ) * ( SubTerms R52 ) )))))
proof
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R52 being  termal (string of R38);
set D636 = ( R45 SubstWith R46 );
set D637 = ( (R45 , R46) -SymbolSubstIn R52 );
set D638 = ( SubTerms R52 );
set D639 = ( R38 -firstChar );
set D640 = ( R38 -multiCat );
set D641 = ( SubTerms D637 );
set D642 = ( AllSymbolsOf R38 );
set D643 = ( AllTermsOf R38 );
reconsider D644 = D643 as (Subset of ( D642 * )) by XBOOLE_1:1;
L953: (( rng D638 ) c= D643 & ( dom ( D636 | D644 ) ) = D644 & ( rng ( D636 | D643 ) ) c= D643) by PARTFUN1:def 2 , RELAT_1:def 19;
reconsider D645 = ( D636 | D643 ) as (Function of D643 , D643) by L953 , FUNCT_2:2;
per cases ;
suppose L954: (not R52 is ( 0 ) -termal);

reconsider D646 = ( D639 . R52 ) as non  literal  ofAtomicFormula (Element of R38) by L954 , FOMODEL1:16;
reconsider D647 = ( (R45 , R46) -SymbolSubstIn <* D646 *> ) as 1 -element D642 -valued FinSequence;
set D648 = ( D639 . D637 );
set D649 = ( abs ( ar D646 ) );
set D650 = ( abs ( ar D648 ) );
L955: ( D645 * D638 ) = ( D636 * D638 ) by L953 , RELAT_1:165;
reconsider D651 = ( D636 * D638 ) as D649 -element (FinSequence of D643) by L955 , FOMODEL0:26;
L956: D637 = ( <* D648 *> ^ ( D640 . D641 ) ) by FOMODEL1:def 37;
L957: R52 = ( <* D646 *> ^ ( D640 . D638 ) ) by FOMODEL1:def 37;
L958: ( D636 . R52 ) = ( ( D636 . <* D646 *> ) ^ ( D636 . ( D640 . D638 ) ) ) by L957 , FOMODEL0:36
.= ( D647 ^ ( D636 . ( D640 . D638 ) ) ) by FOMODEL0:def 23
.= ( D647 ^ ( D640 . ( D636 * D638 ) ) ) by FOMODEL0:37;
L959: D637 = ( D647 ^ ( D640 . D651 ) ) by L958 , FOMODEL0:def 23;
L960: (D647 = <* D648 *> & D647 = <* D646 *>) by L959 , L956 , FOMODEL0:34 , FOMODEL0:41;
L961: (( D647 . 1 ) = D646 & ( D647 . 1 ) = D648) by L960 , FINSEQ_1:40;
reconsider D652 = D651 as D650 -element (Element of ( D643 * )) by L961 , FINSEQ_1:def 11;
L962: D637 = ( <* D648 *> ^ ( D640 . D652 ) ) by L959 , L956 , FOMODEL0:41;
thus L963: thesis by L962 , FOMODEL1:def 37;
end;
suppose L964: R52 is ( 0 ) -termal;

reconsider D653 = R52 as ( 0 ) -termal (string of R38) by L964;
reconsider D654 = ( (R45 , R46) -SymbolSubstIn D653 ) as ( 0 ) -termal (string of R38);
L965: (( SubTerms D654 ) = ( {} ) & ( SubTerms D653 ) = ( {} ));
thus L966: thesis by L965;
end;
end;
L968: (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R55 being  0wff (string of R38) holds ( SubTerms ( (R45 , R46) -SymbolSubstIn R55 ) ) = ( ( R45 SubstWith R46 ) * ( SubTerms R55 ) )))))
proof
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R55 being  0wff (string of R38);
set D655 = ( R45 SubstWith R46 );
set D656 = ( (R45 , R46) -SymbolSubstIn R55 );
set D657 = ( SubTerms R55 );
set D658 = ( R38 -firstChar );
set D659 = ( R38 -multiCat );
set D660 = ( SubTerms D656 );
set D661 = ( AllSymbolsOf R38 );
set D662 = ( AllTermsOf R38 );
reconsider D663 = D662 as (Subset of ( D661 * )) by XBOOLE_1:1;
L969: (( rng D657 ) c= D662 & ( dom ( D655 | D663 ) ) = D663 & ( rng ( D655 | D662 ) ) c= D662) by PARTFUN1:def 2 , RELAT_1:def 19;
reconsider D664 = ( D655 | D662 ) as (Function of D662 , D662) by L969 , FUNCT_2:2;
reconsider D665 = ( D658 . R55 ) , D666 = ( D658 . D656 ) as  relational (Element of R38);
L970: ( R55 . 1 ) = D665 by FOMODEL0:6;
L971: (D665 = ( R55 . 1 ) & ( D656 . 1 ) = ( R55 . 1 )) by L970 , FUNCT_4:105;
L972: D665 = D666 by L971 , FOMODEL0:6;
set D667 = ( abs ( ar D665 ) );
set D668 = ( abs ( ar D666 ) );
L973: ( D655 * D657 ) = ( D664 * D657 ) by L969 , RELAT_1:165;
L974: ( D655 * D657 ) is D668 -element D668 -element D668 -element D668 -element (FinSequence of D662) by L973 , L972 , FOMODEL0:26;
reconsider D669 = ( D655 * D657 ) as D668 -element (Element of ( D662 * )) by L974 , FINSEQ_1:def 11;
reconsider D670 = D657 as ( D661 * ) -valued FinSequence;
L975: R55 = ( <* D665 *> ^ ( D659 . D657 ) ) by FOMODEL1:def 38;
L976: ( D655 . R55 ) = ( ( D655 . <* D665 *> ) ^ ( D655 . ( D659 . D657 ) ) ) by L975 , FOMODEL0:36
.= ( <* D665 *> ^ ( D655 . ( D659 . D657 ) ) ) by FOMODEL0:35
.= ( <* D666 *> ^ ( D659 . D669 ) ) by L972 , FOMODEL0:37;
L977: D656 = ( <* D666 *> ^ ( D659 . D669 ) ) by L976 , FOMODEL0:def 23;
thus L978: thesis by L977 , FOMODEL1:def 38;
end;
L979: (for R12 being non  empty set holds (for R16 being (Element of R12) holds (for R25 being Nat holds (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R62 being (R38 , R12)-interpreter-like Function holds ( ( ( (R45 , R16) ReassignIn R62 ) -TermEval ) | ( ( ( ( AllSymbolsOf R38 ) \ { R46 } ) * ) /\ ( ( R38 -termsOfMaxDepth ) . R25 ) ) ) = ( ( ( ( (R46 , R16) ReassignIn R62 ) -TermEval ) * ( R45 SubstWith R46 ) ) | ( ( ( ( AllSymbolsOf R38 ) \ { R46 } ) * ) /\ ( ( R38 -termsOfMaxDepth ) . R25 ) ) ))))))))
proof
let R12 being non  empty set;
let R16 being (Element of R12);
let R25 being Nat;
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R62 being (R38 , R12)-interpreter-like Function;
set D671 = ( (R45 , R16) ReassignIn R62 );
set D672 = ( (R46 , R16) ReassignIn R62 );
set D673 = ( R45 SubstWith R46 );
set D674 = ( D671 -TermEval );
set D675 = ( D672 -TermEval );
set D676 = ( R38 -termsOfMaxDepth );
set D677 = ( AllTermsOf R38 );
set D678 = ( AllSymbolsOf R38 );
set D679 = ( R38 -firstChar );
set D680 = ( R38 -multiCat );
set D681 = ( R45 .--> ( ( {} ) .--> R16 ) );
set D682 = ( R46 .--> ( ( {} ) .--> R16 ) );
set D683 = ( LettersOf R38 );
reconsider D684 = ( D678 \ { R46 } ) as non  empty (Subset of D678);
set D685 = ( D684 * );
L980: (R45 in { R45 } & R46 in { R46 }) by TARSKI:def 1;
L981: (R45 in ( dom D681 ) & R46 in ( dom D682 )) by L980 , FUNCOP_1:13;
L982: (( D671 . R45 ) = ( D681 . R45 ) & ( D672 . R46 ) = ( D682 . R46 )) by L981 , FUNCT_4:13;
L983: (( D671 . R45 ) = ( ( {} ) .--> R16 ) & ( D672 . R46 ) = ( ( {} ) .--> R16 )) by L982 , FUNCOP_1:72;
defpred S13[ Nat ] means ( D674 | ( ( D676 . $1 ) /\ D685 ) ) = ( ( D675 * D673 ) | ( ( D676 . $1 ) /\ D685 ) );
L984: S13[ ( 0 ) ]
proof
reconsider D686 = ( D676 . ( 0 ) ) as non  empty (Subset of D677) by FOMODEL1:2;
reconsider D687 = D686 as non  empty (Subset of ( D678 * )) by XBOOLE_1:1;
reconsider D688 = ( D673 | ( D676 . ( 0 ) ) ) as ( D676 . ( 0 ) ) -valued Function;
reconsider D689 = ( D686 /\ D685 ) as (Subset of D686);
reconsider D690 = ( D686 /\ D685 ) as (Subset of D677) by XBOOLE_1:1;
L985: ( D688 | D685 ) is D686 -valued;
reconsider D691 = ( D673 | ( D686 /\ D685 ) ) as D687 -valued Function by L985 , RELAT_1:71;
L986: (( dom ( D675 * D691 ) ) = D690 & ( dom ( D674 | D690 ) ) = D690) by PARTFUN1:def 2;
L987: (( rng ( D675 * D691 ) ) c= R12 & ( rng ( D674 | D690 ) ) c= R12) by RELAT_1:def 19;
reconsider D692 = ( D674 | D690 ) , D693 = ( D675 * D691 ) as (Function of D690 , R12) by L987 , L986 , FUNCT_2:2;
L988:
now
let R7 being set;
assume L989: R7 in D690;
reconsider D694 = D689 as non  empty (Subset of D685) by L989;
L990: (( dom D691 ) = D690 & ( rng D691 ) c= D686) by PARTFUN1:def 2 , RELAT_1:def 19;
reconsider D695 = D691 as (Function of D694 , D686) by L990 , FUNCT_2:2;
reconsider D696 = R7 as (Element of D694) by L989;
reconsider D697 = D696 as (Element of D685);
reconsider D698 = R7 as ( 0 ) -termal (string of R38) by L989 , FOMODEL1:def 33 , TARSKI:def 3;
reconsider D699 = D698 as (Element of D686) by FOMODEL1:def 33;
L991: D686 = ( AtomicTermsOf R38 ) by FOMODEL1:def 30;
reconsider D700 = D699 as 1 -element (FinSequence of D683) by L991 , FOMODEL0:12;
reconsider D701 = ( D683 \ { R46 } ) as non  empty (Subset of D683);
L992: (( rng D700 ) c= D683 & ( rng D697 ) c= ( D678 \ { R46 } )) by RELAT_1:def 19;
L993: ( rng D696 ) c= ( D683 /\ ( D678 \ { R46 } ) ) by L992 , XBOOLE_1:19;
L994: ( rng D696 ) c= ( ( D683 null D678 ) \ { R46 } ) by L993 , XBOOLE_1:49;
reconsider D702 = D700 as 1 -element D701 -valued FinSequence by L994 , RELAT_1:def 19;
L995: ( { ( D702 . 1 ) } \ D701 ) = ( {} );
reconsider D703 = ( D702 . 1 ) as (Element of D701) by L995 , ZFMISC_1:60;
L996: (not D703 in { R46 }) by XBOOLE_0:def 5;
L997: (D703 <> R46 & (not D703 in ( dom D682 ))) by L996 , TARSKI:def 1;
L998: ( len D702 ) = 1 by CARD_1:def 7;
reconsider D704 = ( (R45 , R46) -SymbolSubstIn D698 ) as ( 0 ) -termal (string of R38);
reconsider D705 = ( D679 . D698 ) , D706 = ( D679 . D704 ) as  literal (Element of R38);
L999: (D705 = D703 & D706 = ( D704 . 1 )) by FOMODEL0:6;
L1000: (( ( ( D675 * D695 ) . D696 ) \+\ ( D675 . ( D695 . D696 ) ) ) = ( {} ) & ( ( D691 . D696 ) \+\ ( D673 . D696 ) ) = ( {} ) & ( ( D692 . D696 ) \+\ ( D674 . D696 ) ) = ( {} ));
L1001: (( ( D675 * D691 ) . R7 ) = ( D675 . ( D691 . R7 ) ) & ( D691 . R7 ) = ( D673 . R7 ) & ( D692 . R7 ) = ( D674 . R7 )) by L1000 , FOMODEL0:29;
L1002: ( D693 . R7 ) = ( D675 . D704 ) by L1001 , FOMODEL0:def 23
.= ( ( D672 . D706 ) . ( D675 * ( SubTerms D704 ) ) ) by FOMODEL2:21
.= ( ( D672 . D706 ) . ( {} ) );
L1003: ( D692 . R7 ) = ( ( D671 . D705 ) . ( D674 * ( SubTerms D698 ) ) ) by L1001 , FOMODEL2:21
.= ( ( D671 . D705 ) . ( {} ) );
per cases ;
suppose L1004: D703 = R45;

L1005: D698 = <* R45 *> by L998 , L1004 , FINSEQ_1:40;
L1006: D704 = <* R46 *> by L1005 , FOMODEL0:34;
thus L1007: ( D692 . R7 ) = ( D693 . R7 ) by L1006 , L1004 , L1003 , L983 , L1002 , L999 , FINSEQ_1:40;
end;
suppose L1008: D703 <> R45;

L1009: (( D704 . 1 ) = D703 & (not D703 in { R45 })) by L1008 , FUNCT_4:105 , TARSKI:def 1;
L1010: (D706 = D703 & (not D703 in ( dom D681 ))) by L1009 , FOMODEL0:6;
L1011: (( D693 . R7 ) = ( ( R62 . D703 ) . ( {} ) ) & ( D692 . R7 ) = ( ( R62 . D703 ) . ( {} ) )) by L1010 , L999 , L1002 , L1003 , L997 , FUNCT_4:11;
thus L1012: ( D692 . R7 ) = ( D693 . R7 ) by L1011;
end;
end;
L1014: D692 = D693 by L988 , FUNCT_2:12;
thus L1015: thesis by L1014 , RELAT_1:83;
end;
L1016: (for R26 being Nat holds (S13[ R26 ] implies S13[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
reconsider D707 = R26 , D708 = ( R26 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L1017: S13[ R26 ];
reconsider D709 = ( D676 . D707 ) , D710 = ( D676 . D708 ) as non  empty (Subset of D677) by FOMODEL1:2;
reconsider D711 = ( D709 /\ D685 ) , D712 = ( D710 /\ D685 ) as (Subset of D677) by XBOOLE_1:1;
L1018: ( ( D673 | ( D676 . D708 ) ) | D685 ) is D710 -valued;
reconsider D713 = ( D673 | D712 ) as D677 -valued Function by L1018 , RELAT_1:71;
L1019: (( dom ( D673 | D712 ) ) = D712 & ( rng D713 ) c= D677) by PARTFUN1:def 2 , RELAT_1:def 19;
reconsider D714 = D713 as (Function of D712 , D677) by L1019 , FUNCT_2:2;
L1020: ( ( D673 | ( D676 . D707 ) ) | D685 ) is D709 -valued;
reconsider D715 = ( D673 | D711 ) as D677 -valued Function by L1020 , RELAT_1:71;
L1021: (( dom ( D674 | D712 ) ) = D712 & ( dom ( D675 * D713 ) ) = D712 & ( dom ( D675 * D715 ) ) = D711) by PARTFUN1:def 2;
L1022: (( rng ( D674 | D712 ) ) c= R12 & ( rng ( D675 * D713 ) ) c= R12) by RELAT_1:def 19;
reconsider D716 = ( D674 | D712 ) , D717 = ( D675 * D713 ) as (Function of D712 , R12) by L1022 , L1021 , FUNCT_2:2;
L1023:
now
let R7 being set;
assume L1024: R7 in D712;
reconsider D718 = D712 as non  empty (Subset of D710) by L1024;
reconsider D719 = R7 as (Element of D718) by L1024;
reconsider D720 = D719 as (Element of D685) by L1024;
reconsider D721 = R7 as (Element of D710) by L1024;
reconsider D722 = D721 as D708 -termal (string of R38) by FOMODEL1:def 33 , TARSKI:def 3;
reconsider D723 = D722 as (Element of D677);
set D724 = ( Depth D722 );
reconsider D725 = ( rng D720 ) as (Subset of ( D678 \ { R46 } )) by RELAT_1:def 19;
L1025: (( D725 * ) c= D685 & ( rng ( SubTerms D722 ) ) c= ( ( rng D722 ) * )) by RELAT_1:def 19;
L1026: ( rng ( SubTerms D722 ) ) c= D685 by L1025 , XBOOLE_1:1;
reconsider D726 = D722 as ( D707 + 1 ) -termal (string of R38);
reconsider D727 = ( (R45 , R46) -SymbolSubstIn D722 ) as D708 -termal (string of R38);
L1027: ( rng ( SubTerms D726 ) ) c= ( D676 . D707 ) by RELAT_1:def 19;
L1028: (( dom ( D674 | D711 ) ) = D711 & ( dom ( ( D675 * D673 ) | D711 ) ) = D711) by L1021 , PARTFUN1:def 2 , RELAT_1:83;
L1029: (( ( D716 . D719 ) \+\ ( D674 . D719 ) ) = ( {} ) & ( ( ( D673 | D718 ) . D719 ) \+\ ( D673 . D719 ) ) = ( {} ) & ( ( ( D675 * D714 ) . D719 ) \+\ ( D675 . ( D714 . D719 ) ) ) = ( {} ));
L1030: (( D716 . R7 ) = ( D674 . R7 ) & ( D713 . R7 ) = ( D673 . R7 ) & ( D717 . R7 ) = ( D675 . ( D713 . R7 ) )) by L1029 , FOMODEL0:29;
per cases ;
suppose L1031: D724 = ( 0 );

reconsider D728 = D722 as ( 0 ) -termal (string of R38) by L1031 , FOMODEL1:def 40;
reconsider D729 = ( D679 . D728 ) as  literal (Element of R38);
L1032: D728 = ( <* D729 *> ^ ( D680 . ( SubTerms D728 ) ) ) by FOMODEL1:def 37
.= ( <* D729 *> null ( {} ) );
L1033: ( { ( D720 . 1 ) } \ D684 ) = ( {} );
L1034: ( D728 . 1 ) in D684 by L1033 , ZFMISC_1:60;
L1035: D729 in D684 by L1034 , FOMODEL0:6;
L1036: (not D729 in ( dom D682 )) by L1035 , XBOOLE_0:def 5;
L1037: ( D672 . D729 ) = ( R62 . D729 ) by L1036 , FUNCT_4:11;
L1038: ( D716 . D728 ) = ( ( D671 . D729 ) . ( D674 * ( SubTerms D728 ) ) ) by L1030 , FOMODEL2:21
.= ( ( D671 . D729 ) . ( {} ) );
per cases ;
suppose L1039: D729 in ( dom D681 );

L1040: D729 = R45 by L1039 , TARSKI:def 1;
L1041: (( D716 . D728 ) = ( ( D671 . R45 ) . ( {} ) ) & ( D673 . D728 ) = <* R46 *>) by L1040 , L1038 , L1032 , FOMODEL0:35;
L1042: ( D717 . D728 ) = ( ( D672 . ( D679 . <* R46 *> ) ) . ( D675 * ( SubTerms <* R46 *> ) ) ) by L1041 , L1030 , FOMODEL2:21
.= ( ( D672 . ( <* R46 *> . 1 ) ) . ( {} ) ) by FOMODEL0:6
.= ( ( D672 . R46 ) . ( {} ) ) by FINSEQ_1:40;
thus L1043: ( D717 . R7 ) = ( D716 . R7 ) by L1042 , L1039 , L1038 , L983 , TARSKI:def 1;
end;
suppose L1044: (not D729 in ( dom D681 ));

L1045: (( D716 . D728 ) = ( ( R62 . D729 ) . ( {} ) ) & (not D729 in { R45 })) by L1044 , L1038 , FUNCOP_1:13 , FUNCT_4:11;
L1046: D729 <> R45 by L1045 , TARSKI:def 1;
L1047: ( D673 . D728 ) = D728 by L1046 , L1032 , FOMODEL0:35;
L1048: ( D717 . D728 ) = ( ( D672 . D729 ) . ( D675 * ( SubTerms D728 ) ) ) by L1047 , L1030 , FOMODEL2:21
.= ( ( D672 . D729 ) . ( {} ) );
thus L1049: ( D717 . R7 ) = ( D716 . R7 ) by L1048 , L1044 , L1038 , L1037 , FUNCT_4:11;
end;
end;
suppose L1051: D724 <> ( 0 );

L1052: (not D722 is ( 0 ) -termal) by L1051;
reconsider D730 = ( D679 . D722 ) as non  literal  ofAtomicFormula (Element of R38) by L1052 , FOMODEL1:16;
L1053: (( D722 . 1 ) = ( D679 . D722 ) & ( D679 . D722 ) is non  literal) by L1052 , FOMODEL0:6 , FOMODEL1:16;
L1054: ( D727 . 1 ) = D730 by L1053 , FUNCT_4:105;
reconsider D731 = ( D679 . D727 ) as non  literal  ofAtomicFormula (Element of R38) by L1054 , FOMODEL0:6;
L1055: ((not D730 in ( dom D681 )) & (not D731 in ( dom D682 ))) by TARSKI:def 1;
L1056: (( D671 . D730 ) = ( R62 . D730 ) & ( D672 . D731 ) = ( R62 . D731 )) by L1055 , FUNCT_4:11;
L1057: D730 <> R45;
L1058: ( D722 . 1 ) <> R45 by L1057 , FOMODEL0:6;
L1059: ( D727 . 1 ) = ( D722 . 1 ) by L1058 , FUNCT_4:105
.= D730 by FOMODEL0:6;
L1060: D730 = D731 by L1059 , FOMODEL0:6;
thus L1061: ( D717 . R7 ) = ( D675 . D727 ) by L1030 , FOMODEL0:def 23
.= ( ( D672 . D731 ) . ( D675 * ( SubTerms D727 ) ) ) by FOMODEL2:21
.= ( ( D672 . D731 ) . ( D675 * ( D673 * ( SubTerms D722 ) ) ) ) by L952
.= ( ( R62 . D731 ) . ( ( D675 * D673 ) * ( SubTerms D722 ) ) ) by L1056 , RELAT_1:36
.= ( ( R62 . D731 ) . ( ( ( D675 * D673 ) | ( ( D676 . R26 ) /\ D685 ) ) * ( SubTerms D722 ) ) ) by L1027 , L1026 , L1028 , RELAT_1:165 , XBOOLE_1:19
.= ( ( R62 . D731 ) . ( D674 * ( SubTerms D722 ) ) ) by L1027 , L1026 , L1028 , L1017 , RELAT_1:165 , XBOOLE_1:19
.= ( D716 . R7 ) by L1030 , L1056 , L1060 , FOMODEL2:21;
end;
end;
L1063: D716 = D717 by L1023 , FUNCT_2:12;
thus L1064: thesis by L1063 , RELAT_1:83;
end;
L1065: (for R25 being Nat holds S13[ R25 ]) from NAT_1:sch 2(L984 , L1016);
thus L1066: thesis by L1065;
end;
L1067: (for R12 being non  empty set holds (for R16 being (Element of R12) holds (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R55 being  0wff (string of R38) holds (for R62 being (R38 , R12)-interpreter-like Function holds (R55 is ( ( AllSymbolsOf R38 ) \ { R46 } ) -valued implies ( ( (R45 , R16) ReassignIn R62 ) -AtomicEval R55 ) = ( ( (R46 , R16) ReassignIn R62 ) -AtomicEval ( (R45 , R46) -SymbolSubstIn R55 ) )))))))))
proof
let R12 being non  empty set;
let R16 being (Element of R12);
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R55 being  0wff (string of R38);
let R62 being (R38 , R12)-interpreter-like Function;
set D732 = ( (R45 , R16) ReassignIn R62 );
set D733 = ( (R46 , R16) ReassignIn R62 );
set D734 = ( R45 SubstWith R46 );
set D735 = ( D732 -TermEval );
set D736 = ( D733 -TermEval );
set D737 = ( R38 -termsOfMaxDepth );
set D738 = ( AllTermsOf R38 );
set D739 = ( AllSymbolsOf R38 );
set D740 = ( R38 -firstChar );
set D741 = ( R38 -multiCat );
set D742 = ( R45 .--> ( ( {} ) .--> R16 ) );
set D743 = ( R46 .--> ( ( {} ) .--> R16 ) );
set D744 = ( LettersOf R38 );
set D745 = ( TheEqSymbOf R38 );
set D746 = ( R12 -deltaInterpreter );
set D747 = ( D739 \ { R46 } );
reconsider D748 = D747 as non  empty (Subset of D739);
reconsider D749 = ( (R45 , R46) -SymbolSubstIn R55 ) as  0wff (string of R38);
reconsider D750 = ( D740 . R55 ) , D751 = ( D740 . D749 ) as  relational (Element of R38);
L1068: ( R55 . 1 ) = D750 by FOMODEL0:6;
L1069: D750 = ( D749 . 1 ) by L1068 , FUNCT_4:105
.= D751 by FOMODEL0:6;
L1070: ((not D750 in ( dom D742 )) & (not D750 in ( dom D743 ))) by TARSKI:def 1;
L1071: (( D732 . D750 ) = ( R62 . D750 ) & ( D733 . D750 ) = ( R62 . D750 )) by L1070 , FUNCT_4:11;
L1072: (( dom D735 ) = D738 & ( dom D736 ) = D738) by FUNCT_2:def 1;
L1073: (( dom ( D735 | ( D747 * ) ) ) = ( D738 /\ ( D747 * ) ) & ( dom ( D734 | ( D748 * ) ) ) = ( D748 * )) by L1072 , PARTFUN1:def 2 , RELAT_1:61;
reconsider D752 = ( SubTerms R55 ) as (Element of ( D738 * ));
consider R30 being (Element of ( NAT )) such that L1074: ( SubTerms R55 ) is (Element of ( ( D737 . R30 ) * )) by L38;
reconsider D753 = ( D737 . R30 ) as non  empty (Subset of D738) by FOMODEL1:2;
L1075: ( dom ( D735 | ( ( D747 * ) /\ D753 ) ) ) = ( dom ( ( D735 | ( D747 * ) ) | D753 ) ) by RELAT_1:71
.= ( ( dom ( D735 | ( D747 * ) ) ) /\ D753 ) by RELAT_1:61
.= ( ( D753 null D738 ) /\ ( D747 * ) ) by L1073 , XBOOLE_1:16
.= ( ( D747 * ) /\ D753 );
L1076: ( dom ( D734 | ( ( D747 * ) /\ D753 ) ) ) = ( dom ( ( D734 | ( D747 * ) ) | D753 ) ) by RELAT_1:71
.= ( ( D747 * ) /\ D753 ) by L1073 , RELAT_1:61;
assume L1077: R55 is D747 -valued;
reconsider D754 = ( rng R55 ) as non  empty (Subset of D748) by L1077 , RELAT_1:def 19;
L1078: (( rng ( SubTerms R55 ) ) c= ( D754 * ) & ( D754 * ) c= ( D747 * )) by RELAT_1:def 19;
L1079: (( rng ( SubTerms R55 ) ) c= ( D747 * ) & ( rng ( SubTerms R55 ) ) c= D753) by L1078 , L1074 , RELAT_1:def 19;
L1080: ( D735 * ( SubTerms R55 ) ) = ( ( D735 | ( ( D747 * ) /\ D753 ) ) * ( SubTerms R55 ) ) by L1079 , L1075 , RELAT_1:165 , XBOOLE_1:19
.= ( ( ( D736 * D734 ) | ( ( D747 * ) /\ D753 ) ) * ( SubTerms R55 ) ) by L979
.= ( ( D736 * ( D734 | ( ( D747 * ) /\ D753 ) ) ) * ( SubTerms R55 ) ) by RELAT_1:83
.= ( D736 * ( ( D734 | ( ( D747 * ) /\ D753 ) ) * ( SubTerms R55 ) ) ) by RELAT_1:36
.= ( D736 * ( D734 * ( SubTerms R55 ) ) ) by L1079 , L1076 , RELAT_1:165 , XBOOLE_1:19
.= ( D736 * ( SubTerms D749 ) ) by L968;
per cases ;
suppose L1081: D750 <> D745;

L1082: ( D732 -AtomicEval R55 ) = ( ( D733 . D751 ) . ( D736 * ( SubTerms D749 ) ) ) by L1081 , L1080 , L1069 , L1071 , FOMODEL2:14
.= ( D733 -AtomicEval D749 ) by L1081 , L1069 , FOMODEL2:14;
thus L1083: thesis by L1082;
end;
suppose L1084: D750 = D745;

L1085: ( D732 -AtomicEval R55 ) = ( D746 . ( D735 * ( SubTerms R55 ) ) ) by L1084 , FOMODEL2:14
.= ( D733 -AtomicEval D749 ) by L1084 , L1069 , L1080 , FOMODEL2:14;
thus L1086: thesis by L1085;
end;
end;
theorem
L1088: (for R12 being non  empty set holds (for R17 being (Element of R12) holds (for R38 being Language holds (for R45 being  literal (Element of R38) holds (for R46 being  literal (Element of R38) holds (for R56 being  wff (string of R38) holds ((not R46 in ( rng R56 )) implies (for B185 being (Element of ( R12 -InterpretersOf R38 )) holds ( ( (R45 , R17) ReassignIn B185 ) -TruthEval R56 ) = ( ( (R46 , R17) ReassignIn B185 ) -TruthEval ( (R45 , R46) -SymbolSubstIn R56 ) )))))))))
proof
let R12 being non  empty set;
let R17 being (Element of R12);
let R38 being Language;
let R45 being  literal (Element of R38);
let R46 being  literal (Element of R38);
let R56 being  wff (string of R38);
set D755 = ( R12 -InterpretersOf R38 );
set D756 = ( R45 SubstWith R46 );
set D757 = ( AllSymbolsOf R38 );
set D758 = ( D757 \ { R46 } );
set D759 = ( AllTermsOf R38 );
set D760 = ( R38 -termsOfMaxDepth );
set D761 = ( R38 -firstChar );
set D762 = ( TheNorSymbOf R38 );
reconsider D763 = D758 as non  empty (Subset of D757);
defpred S14[ Nat ] means (for B186 being (Element of D755) holds (for R16 being (Element of R12) holds (for R59 being  wff (string of R38) holds ((R59 is $1 -wff & R59 is D758 -valued) implies ( ( (R45 , R16) ReassignIn B186 ) -TruthEval R59 ) = ( ( (R46 , R16) ReassignIn B186 ) -TruthEval ( (R45 , R46) -SymbolSubstIn R59 ) )))));
L1089: S14[ ( 0 ) ]
proof
let C358 being (Element of D755);
let R16 being (Element of R12);
let R59 being  wff (string of R38);
set D764 = ( (R45 , R16) ReassignIn C358 );
set D765 = ( (R46 , R16) ReassignIn C358 );
assume L1090: R59 is ( 0 ) -wff;
reconsider D766 = R59 as  0wff (string of R38) by L1090;
assume L1091: R59 is D758 -valued;
L1092: ( D764 -TruthEval D766 ) = ( D765 -TruthEval ( (R45 , R46) -SymbolSubstIn D766 ) ) by L1091 , L1067;
thus L1093: thesis by L1092;
end;
L1094: (for R26 being Nat holds (S14[ R26 ] implies S14[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L1095: S14[ R26 ];
let C359 being (Element of D755);
let R16 being (Element of R12);
let R59 being  wff (string of R38);
set D767 = ( (R45 , R16) ReassignIn C359 );
set D768 = ( (R46 , R16) ReassignIn C359 );
assume L1096: (R59 is ( R26 + 1 ) -wff & R59 is D758 -valued);
reconsider D769 = R59 as ( R26 + 1 ) -wff (string of R38) by L1096;
reconsider D770 = R59 as non  empty D763 -valued FinSequence by L1096;
L1097: ( { ( D770 . 1 ) } \ D758 ) = ( {} );
L1098: ( D769 . 1 ) in D758 by L1097 , ZFMISC_1:60;
L1099: ( D761 . D769 ) in D758 by L1098 , FOMODEL0:6;
L1100: (not ( D761 . D769 ) in { R46 }) by L1099 , XBOOLE_0:def 5;
L1101: ( D761 . D769 ) <> R46 by L1100 , TARSKI:def 1;
reconsider D771 = ( (R45 , R46) -SymbolSubstIn D769 ) as ( R26 + 1 ) -wff (string of R38);
reconsider D772 = ( head D769 ) as R26 -wff (string of R38);
reconsider D773 = ( (R45 , R46) -SymbolSubstIn D772 ) as R26 -wff (string of R38);
per cases ;
suppose L1102: (R59 is  exal & (not R59 is  0wff));

reconsider D774 = D769 as non  0wff  exal ( R26 + 1 ) -wff (string of R38) by L1102;
set D775 = ( D761 . D774 );
set D776 = ( tail D774 );
L1103: D774 = ( ( <* D775 *> ^ D772 ) ^ D776 ) by FOMODEL2:23
.= ( <* D775 *> ^ D772 );
L1104: ( D756 . D774 ) = ( ( D756 . <* D775 *> ) ^ ( D756 . D772 ) ) by L1103 , FOMODEL0:36
.= ( ( D756 . <* D775 *> ) ^ D773 ) by FOMODEL0:def 23;
L1105: D771 = ( ( D756 . <* D775 *> ) ^ D773 ) by L1104 , FOMODEL0:def 23;
L1106: D770 = ( ( <* D775 *> ^ D772 ) ^ ( {} ) ) by L1103;
L1107: D772 is D763 -valued by L1106 , FOMODEL0:44;
L1108: (( D767 -TruthEval D774 ) = 1 iff ( D768 -TruthEval D771 ) = 1)
proof
per cases ;
suppose L1109: D775 = R45;

L1110: D771 = ( <* R46 *> ^ D773 ) by L1109 , L1105 , FOMODEL0:35;
thus L1111:now
assume L1112: ( D767 -TruthEval D774 ) = 1;
consider R17 being (Element of R12) such that L1113: ( ( (D775 , R17) ReassignIn D767 ) -TruthEval D772 ) = 1 by L1112 , L1103 , FOMODEL2:19;
L1114: 1 = ( ( (R45 , R17) ReassignIn C359 ) -TruthEval D772 ) by L1113 , L1109 , FOMODEL0:43
.= ( ( (R46 , R17) ReassignIn C359 ) -TruthEval D773 ) by L1107 , L1095
.= ( ( (R46 , R17) ReassignIn D768 ) -TruthEval D773 ) by FOMODEL0:43;
thus L1115: ( D768 -TruthEval D771 ) = 1 by L1114 , L1110 , FOMODEL2:19;
end;
assume L1116: ( D768 -TruthEval D771 ) = 1;
consider R18 being (Element of R12) such that L1117: ( ( (R46 , R18) ReassignIn D768 ) -TruthEval D773 ) = 1 by L1116 , L1110 , FOMODEL2:19;
L1118: 1 = ( ( (R46 , R18) ReassignIn C359 ) -TruthEval D773 ) by L1117 , FOMODEL0:43
.= ( ( (R45 , R18) ReassignIn C359 ) -TruthEval D772 ) by L1107 , L1095
.= ( ( (D775 , R18) ReassignIn D767 ) -TruthEval D772 ) by L1109 , FOMODEL0:43;
thus L1119: ( D767 -TruthEval D774 ) = 1 by L1118 , L1103 , FOMODEL2:19;
end;
suppose L1120: D775 <> R45;

L1121: D771 = ( <* D775 *> ^ D773 ) by L1120 , L1105 , FOMODEL0:35;
thus L1122:now
assume L1123: ( D767 -TruthEval D774 ) = 1;
consider R17 being (Element of R12) such that L1124: ( ( (D775 , R17) ReassignIn D767 ) -TruthEval D772 ) = 1 by L1123 , L1103 , FOMODEL2:19;
L1125: 1 = ( ( (R45 , R16) ReassignIn ( (D775 , R17) ReassignIn C359 ) ) -TruthEval D772 ) by L1124 , L1120 , FOMODEL0:43
.= ( ( (R46 , R16) ReassignIn ( (D775 , R17) ReassignIn C359 ) ) -TruthEval D773 ) by L1095 , L1107
.= ( ( (D775 , R17) ReassignIn ( (R46 , R16) ReassignIn C359 ) ) -TruthEval D773 ) by L1101 , FOMODEL0:43;
thus L1126: ( D768 -TruthEval D771 ) = 1 by L1125 , L1121 , FOMODEL2:19;
end;
assume L1127: ( D768 -TruthEval D771 ) = 1;
consider R18 being (Element of R12) such that L1128: ( ( (D775 , R18) ReassignIn D768 ) -TruthEval D773 ) = 1 by L1127 , L1121 , FOMODEL2:19;
L1129: 1 = ( ( (R46 , R16) ReassignIn ( (D775 , R18) ReassignIn C359 ) ) -TruthEval D773 ) by L1101 , L1128 , FOMODEL0:43
.= ( ( (R45 , R16) ReassignIn ( (D775 , R18) ReassignIn C359 ) ) -TruthEval D772 ) by L1095 , L1107
.= ( ( (D775 , R18) ReassignIn ( (R45 , R16) ReassignIn C359 ) ) -TruthEval D772 ) by L1120 , FOMODEL0:43;
thus L1130: ( D767 -TruthEval D774 ) = 1 by L1129 , L1103 , FOMODEL2:19;
end;
end;
L1132: (( D767 -TruthEval D774 ) = 1 iff (not ( D768 -TruthEval D771 ) = ( 0 ))) by L1108 , FOMODEL0:39;
thus L1133: thesis by L1132 , FOMODEL0:39;
end;
suppose L1134: ((not R59 is  exal) & (not R59 is  0wff));

reconsider D777 = D769 as ( R26 + 1 ) -wff non  exal non  0wff (string of R38) by L1134;
reconsider D778 = ( tail D777 ) as R26 -wff (string of R38);
reconsider D779 = ( (R45 , R46) -SymbolSubstIn D778 ) as R26 -wff (string of R38);
L1135: ( ( D761 . D777 ) \+\ D762 ) = ( {} );
L1136: ( D761 . D777 ) = D762 by L1135 , FOMODEL0:29;
L1137: D777 = ( ( <* D762 *> ^ D772 ) ^ D778 ) by L1136 , FOMODEL2:23;
L1138: (D772 is D758 -valued & D778 is D758 -valued & (( D767 -TruthEval D777 ) = 1 iff (( D767 -TruthEval D772 ) = ( 0 ) & ( D767 -TruthEval D778 ) = ( 0 )))) by L1137 , L1096 , FOMODEL0:44 , FOMODEL2:19;
L1139: (( D767 -TruthEval D777 ) = 1 iff (( D768 -TruthEval D773 ) = ( 0 ) & ( D768 -TruthEval D779 ) = ( 0 ))) by L1138 , L1095;
L1140: (( D756 . D777 ) = D771 & ( D756 . D772 ) = D773 & ( D756 . D778 ) = D779) by FOMODEL0:def 23;
L1141: D771 = ( ( D756 . ( <* D762 *> ^ D772 ) ) ^ ( D756 . D778 ) ) by L1140 , L1137 , FOMODEL0:36
.= ( ( ( D756 . <* D762 *> ) ^ ( D756 . D772 ) ) ^ ( D756 . D778 ) ) by FOMODEL0:36
.= ( ( <* D762 *> ^ D773 ) ^ D779 ) by L1140 , FOMODEL0:35;
L1142: (( D768 -TruthEval D771 ) = 1 iff (not ( D767 -TruthEval R59 ) = ( 0 ))) by L1141 , L1139 , FOMODEL0:39 , FOMODEL2:19;
thus L1143: thesis by L1142 , FOMODEL0:39;
end;
suppose L1144: R59 is ( 0 ) -wff;

thus L1145: thesis by L1144 , L1089 , L1096;
end;
end;
L1147: (for R25 being Nat holds S14[ R25 ]) from NAT_1:sch 2(L1089 , L1094);
set D780 = ( Depth R56 );
assume L1148: (not R46 in ( rng R56 ));
L1149: ({ R46 } misses ( rng R56 ) & ( rng R56 ) c= D757) by L1148 , RELAT_1:def 19 , ZFMISC_1:50;
L1150: ( rng R56 ) c= D758 by L1149 , XBOOLE_1:86;
L1151: (R56 is D780 -wff & R56 is D758 -valued) by L1150 , FOMODEL2:def 31 , RELAT_1:def 19;
let C360 being (Element of D755);
thus L1152: thesis by L1147 , L1151;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R26 being Nat;
let C361 being  FinSequence-yielding Function;
let R59 being  wff (string of R38);
func (R44 , R52 , R26 , C361) Subst2 R59 -> FinSequence equals 
:L1153: ( ( <* ( TheNorSymbOf R38 ) *> ^ ( C361 . ( head R59 ) ) ) ^ ( C361 . ( tail R59 ) ) ) if (( Depth R59 ) = ( R26 + 1 ) & (not R59 is  exal)) , ( <* the (Element of ( ( LettersOf R38 ) \ ( ( ( rng R52 ) \/ ( rng ( head R59 ) ) ) \/ { R44 } ) )) *> ^ ( C361 . ( (( ( R38 -firstChar ) . R59 ) , the (Element of ( ( LettersOf R38 ) \ ( ( ( rng R52 ) \/ ( rng ( head R59 ) ) ) \/ { R44 } ) ))) -SymbolSubstIn ( head R59 ) ) ) ) if (( Depth R59 ) = ( R26 + 1 ) & R59 is  exal & ( ( R38 -firstChar ) . R59 ) <> R44) otherwise ( C361 . R59 );
coherence;
consistency;
end;
registration
let R38 being Language;
cluster  ->  FinSequence-yielding for (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));
coherence;
end;
L1156: (for R26 being Nat holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R52 being  termal (string of R38) holds (for R59 being  wff (string of R38) holds (for B187 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) )) holds ( (R44 , R52 , R26 , B187) Subst2 R59 ) is  wff  wff  wff  wff (string of R38)))))))
proof
let R26 being Nat;
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R59 being  wff (string of R38);
set D781 = ( AllFormulasOf R38 );
set D782 = ( head R59 );
set D783 = ( Depth R59 );
set D784 = ( R38 -firstChar );
let C362 being (Element of ( Funcs (D781 , D781) ));
reconsider D785 = C362 as (Function of D781 , D781);
set D786 = ( (R44 , R52 , R26 , C362) Subst2 R59 );
set D787 = ( TheNorSymbOf R38 );
set D788 = ( LettersOf R38 );
set D789 = ( D788 \ ( ( ( rng R52 ) \/ ( rng D782 ) ) \/ { R44 } ) );
set D790 = the (Element of D789);
reconsider D791 = D782 , D792 = R59 as (Element of D781) by FOMODEL2:16;
reconsider D793 = ( D785 . D791 ) as  wff (string of R38) by TARSKI:def 3;
reconsider D794 = D789 as non  empty (Subset of D788);
L1157: D790 is (Element of D794);
reconsider D795 = D790 as  literal (Element of R38) by L1157;
per cases ;
suppose L1158: (D783 = ( R26 + 1 ) & (not R59 is  exal));

L1159: (not R59 is ( 0 ) -wff) by L1158;
reconsider D796 = R59 as non  0wff non  exal  wff (string of R38) by L1159 , L1158;
reconsider D797 = ( tail D796 ) as  wff (string of R38);
reconsider D798 = D797 as (Element of D781) by FOMODEL2:16;
reconsider D799 = ( D785 . D798 ) as  wff (string of R38) by TARSKI:def 3;
L1160: D786 = ( ( <* D787 *> ^ D793 ) ^ D799 ) by L1158 , L1153;
thus L1161: thesis by L1160;
end;
suppose L1162: (D783 = ( R26 + 1 ) & R59 is  exal & ( D784 . R59 ) <> R44);

reconsider D800 = R59 as non  0wff  exal  wff (string of R38) by L1162;
reconsider D801 = ( D784 . D800 ) as  literal (Element of R38);
reconsider D802 = ( (D801 , D795) -SymbolSubstIn D782 ) as  wff (string of R38);
reconsider D803 = D802 as (Element of D781) by FOMODEL2:16;
reconsider D804 = ( D785 . D803 ) as  wff (string of R38) by TARSKI:def 3;
L1163: D786 = ( <* D795 *> ^ D804 ) by L1162 , L1153;
thus L1164: thesis by L1163;
end;
suppose L1165: D783 <> ( R26 + 1 );

L1166: D786 = ( D785 . D792 ) by L1165 , L1153;
thus L1167: thesis by L1166 , TARSKI:def 3;
end;
suppose L1168: ( D784 . R59 ) = R44;

L1169: (( D784 . R59 ) = R44 & R59 is  exal) by L1168 , FOMODEL2:def 32;
L1170: D786 = ( D785 . D792 ) by L1169 , L1153;
thus L1171: thesis by L1170 , TARSKI:def 3;
end;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R26 being Nat;
let C363 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));
let R59 being  wff (string of R38);
redefine func (R44 , R52 , R26 , C363) Subst2 R59 ->  wff (string of R38);

coherence by L1156;
end;
registration
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R26 being Nat;
let C364 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));
let R59 being  wff (string of R38);
cluster ( (R44 , R52 , R26 , C364) Subst2 R59 ) ->  wff for (string of R38);
coherence;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R31 being (Element of ( NAT ));
let C365 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));
let R59 being  wff (string of R38);
redefine func (R44 , R52 , R31 , C365) Subst2 R59 -> (Element of ( AllFormulasOf R38 ));

coherence
proof
L1175: ( (R44 , R52 , R31 , C365) Subst2 R59 ) in ( AllFormulasOf R38 ) by FOMODEL2:16;
thus L1176: thesis by L1175;
end;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R26 being Nat;
let C366 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));
set D805 = ( AllFormulasOf R38 );
set D806 = ( Funcs (D805 , D805) );
func (R44 , R52 , R26 , C366) Subst3 -> (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) )) means 
:L1178: (for R59 being  wff (string of R38) holds ( it . R59 ) = ( (R44 , R52 , R26 , C366) Subst2 R59 ));
existence
proof
reconsider D807 = R26 as (Element of ( NAT )) by ORDINAL1:def 12;
deffunc H9((Element of D805)) = (( (R44 , R52 , D807 , C366) Subst2 $1 ) qua (Element of D805));
consider C367 being (Function of D805 , D805) such that L1179: (for B188 being (Element of D805) holds ( C367 . B188 ) = H9(B188)) from FUNCT_2:sch 4;
reconsider D808 = C367 as (Element of ( Funcs (D805 , D805) )) by FUNCT_2:8;
take D808;
L1180:
now
let R59 being  wff (string of R38);
reconsider D809 = R59 as (Element of D805) by FOMODEL2:16;
L1181: ( C367 . D809 ) = H9(D809) by L1179;
thus L1182: ( D808 . R59 ) = ( (R44 , R52 , D807 , C366) Subst2 R59 ) by L1181;
end;
thus L1183: thesis by L1180;
end;
uniqueness
proof
let C368 , C369 being (Element of D806);
reconsider D810 = C368 , D811 = C369 as (Function of D805 , D805);
assume L1184: (for R59 being  wff (string of R38) holds ( C368 . R59 ) = ( (R44 , R52 , R26 , C366) Subst2 R59 ));
assume L1185: (for R59 being  wff (string of R38) holds ( C369 . R59 ) = ( (R44 , R52 , R26 , C366) Subst2 R59 ));
L1186:
now
let R7 being set;
assume L1187: R7 in D805;
reconsider D812 = R7 as  wff (string of R38) by L1187;
L1188: ( C368 . D812 ) = ( (R44 , R52 , R26 , C366) Subst2 D812 ) by L1184
.= ( C369 . D812 ) by L1185;
thus L1189: ( D810 . R7 ) = ( D811 . R7 ) by L1188;
end;
thus L1190: thesis by L1186 , FUNCT_2:12;
end;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let C370 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));
set D813 = ( AllFormulasOf R38 );
set D814 = ( Funcs (D813 , D813) );
deffunc H10(Nat , (Element of D814)) = ( (R44 , R52 , $1 , $2) Subst3 );
func (R44 , R52) Subst4 C370 -> (Function of ( NAT ) , ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) )) means 
:L1192: (( it . ( 0 ) ) = C370 & (for R25 being Nat holds ( it . ( R25 + 1 ) ) = ( (R44 , R52 , R25 , ( it . R25 )) Subst3 )));
existence
proof
consider C371 being (Function of ( NAT ) , D814) such that L1193: (( C371 . ( 0 ) ) = C370 & (for R25 being Nat holds ( C371 . ( R25 + 1 ) ) = H10(R25 , (( C371 . R25 ) qua (Element of D814))))) from NAT_1:sch 12;
take C371;
thus L1194: thesis by L1193;
end;
uniqueness
proof
let C372 , C373 being (Function of ( NAT ) , D814);
assume that
L1195: ( C372 . ( 0 ) ) = C370
and
L1196: (for R25 being Nat holds ( C372 . ( R25 + 1 ) ) = H10(R25 , (( C372 . R25 ) qua (Element of D814))))
and
L1197: ( C373 . ( 0 ) ) = C370
and
L1198: (for R25 being Nat holds ( C373 . ( R25 + 1 ) ) = H10(R25 , (( C373 . R25 ) qua (Element of D814))));
L1199: C372 = C373 from NAT_1:sch 16(L1195 , L1196 , L1197 , L1198);
thus L1200: thesis by L1199;
end;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
set D815 = ( AtomicFormulasOf R38 );
set D816 = ( AllTermsOf R38 );
func R44 AtomicSubst R52 -> (Function of ( AtomicFormulasOf R38 ) , ( AtomicFormulasOf R38 )) means 
:L1202: (for R55 being  0wff (string of R38) holds (for R63 being (Element of ( AllTermsOf R38 )) holds (R63 = R52 implies ( it . R55 ) = ( (R44 , R63) AtomicSubst R55 ))));
existence
proof
reconsider D817 = R52 as (Element of D816) by FOMODEL1:def 32;
deffunc H11((Element of D815)) = ( (R44 , D817) AtomicSubst $1 );
consider R22 being Function such that L1203: (( dom R22 ) = D815 & (for B189 being (Element of D815) holds ( R22 . B189 ) = H11(B189))) from FUNCT_1:sch 4;
L1204:
now
let R7 being set;
assume L1205: R7 in D815;
reconsider D818 = R7 as (Element of D815) by L1205;
L1206: ( R22 . D818 ) = H11(D818) by L1203;
reconsider D819 = ( R22 . R7 ) as  0wff (string of R38) by L1206;
L1207: D819 in D815;
thus L1208: ( R22 . R7 ) in D815 by L1207;
end;
reconsider D820 = R22 as (Function of D815 , D815) by L1204 , L1203 , FUNCT_2:3;
take D820;
thus L1209:now
let R55 being  0wff (string of R38);
let R65 being (Element of ( AllTermsOf R38 ));
L1210: R55 in D815;
reconsider D821 = R55 as (Element of D815) by L1210;
assume L1211: R65 = R52;
L1212: (R65 = D817 & ( R22 . D821 ) = ( (R44 , D817) AtomicSubst D821 )) by L1211 , L1203;
thus L1213: ( D820 . R55 ) = ( (R44 , R65) AtomicSubst R55 ) by L1212;
end;
end;
uniqueness
proof
reconsider D822 = R52 as (Element of D816) by FOMODEL1:def 32;
let C374 , C375 being (Function of D815 , D815);
assume that
L1210: (for R55 being  0wff (string of R38) holds (for R63 being (Element of ( AllTermsOf R38 )) holds (R63 = R52 implies ( C374 . R55 ) = ( (R44 , R63) AtomicSubst R55 ))))
and
L1211: (for R55 being  0wff (string of R38) holds (for R63 being (Element of ( AllTermsOf R38 )) holds (R63 = R52 implies ( C375 . R55 ) = ( (R44 , R63) AtomicSubst R55 ))));
L1212:
now
let C376 being (Element of D815);
consider R49 being (string of R38) such that L1213: (C376 = R49 & R49 is  0wff);
reconsider D823 = R49 as  0wff (string of R38) by L1213;
L1214: ( C374 . D823 ) = ( (R44 , D822) AtomicSubst D823 ) by L1210
.= ( C375 . D823 ) by L1211;
thus L1215: ( C374 . C376 ) = ( C375 . C376 ) by L1214 , L1213;
end;
thus L1216: thesis by L1212 , FUNCT_2:63;
end;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
func R44 Subst1 R52 -> Function equals 
( ( id ( AllFormulasOf R38 ) ) +* ( R44 AtomicSubst R52 ) );
coherence;
end;
L1219: (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R52 being  termal (string of R38) holds ( R44 Subst1 R52 ) in ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ))))
proof
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
set D824 = ( AllFormulasOf R38 );
set D825 = ( R44 AtomicSubst R52 );
set D826 = ( AtomicFormulasOf R38 );
set D827 = the (Element of D824);
set D828 = ( id D824 );
set D829 = ( D828 +* D825 );
set D830 = ( AllSymbolsOf R38 );
reconsider D831 = D824 as (Subset of ( D830 * )) by XBOOLE_1:1;
L1220: ( D826 \ D824 ) = ( {} );
reconsider D832 = D826 as (Subset of D824) by L1220 , XBOOLE_1:37;
L1221: (( dom D828 ) = D824 & ( dom D825 ) = D832) by FUNCT_2:def 1;
L1222: ( dom D829 ) = ( D824 null D832 ) by L1221 , FUNCT_4:def 1;
reconsider D833 = D825 as D832 -valued Function;
reconsider D834 = D828 as D824 -valued Function;
L1223: (D829 = D829 & ( dom D829 ) = D824 & ( rng D829 ) c= D824) by L1222 , RELAT_1:def 19;
thus L1224: thesis by L1223 , FUNCT_2:def 2;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
redefine func R44 Subst1 R52 -> (Element of ( Funcs (( AllFormulasOf R38 ) , ( ( AllSymbolsOf R38 ) * )) ));

coherence
proof
set D835 = ( AllFormulasOf R38 );
set D836 = ( AllSymbolsOf R38 );
set D837 = ( R44 Subst1 R52 );
L1225: D835 c= ( D836 * ) by XBOOLE_1:1;
L1226: (D837 in ( Funcs (D835 , D835) ) & ( Funcs (D835 , D835) ) c= ( Funcs (D835 , ( D836 * )) )) by L1225 , L1219 , FUNCT_5:56;
thus L1227: thesis by L1226;
end;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
redefine func R44 Subst1 R52 -> (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) ));

coherence by L1219;
end;
definition
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R59 being  wff (string of R38);
func (R44 , R52) SubstIn R59 ->  wff (string of R38) equals 
( ( ( (R44 , R52) Subst4 ( R44 Subst1 R52 ) ) . ( Depth R59 ) ) . R59 );
coherence
proof
set D838 = ( AllFormulasOf R38 );
set D839 = ( Funcs (D838 , D838) );
reconsider D840 = ( Depth R59 ) as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D841 = ( (R44 , R52) Subst4 ( R44 Subst1 R52 ) ) as (Function of ( NAT ) , D839);
L1230: ( D841 . D840 ) is (Element of D839);
reconsider D842 = ( D841 . D840 ) as (Function of D838 , D838) by L1230;
reconsider D843 = R59 as (Element of D838) by FOMODEL2:16;
L1231: ( D842 . D843 ) is  wff  wff  wff  wff (string of R38) by TARSKI:def 3;
thus L1232: thesis by L1231;
end;
end;
registration
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R59 being  wff (string of R38);
cluster ( (R44 , R52) SubstIn R59 ) ->  wff for (string of R38);
coherence;
end;
L1235: (for R25 being Nat holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R52 being  termal (string of R38) holds (for R59 being  wff (string of R38) holds (for B190 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) )) holds ( ( ( (R44 , R52) Subst4 B190 ) . ( R25 + 1 ) ) . R59 ) = ( (R44 , R52 , R25 , ( ( (R44 , R52) Subst4 B190 ) . R25 )) Subst2 R59 )))))))
proof
let R25 being Nat;
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R59 being  wff (string of R38);
set D844 = ( AllFormulasOf R38 );
set D845 = ( Funcs (D844 , D844) );
let C377 being (Element of D845);
reconsider D846 = R25 as (Element of ( NAT )) by ORDINAL1:def 12;
set D847 = ( (R44 , R52) Subst4 C377 );
set D848 = ( (R44 , R52 , R25 , ( D847 . D846 )) Subst3 );
L1236: ( ( D847 . ( D846 + 1 ) ) . R59 ) = ( D848 . R59 ) by L1192
.= ( (R44 , R52 , R25 , ( D847 . D846 )) Subst2 R59 ) by L1178;
thus L1237: thesis by L1236;
end;
L1238: (for R25 being Nat holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R52 being  termal (string of R38) holds (for R59 being  wff (string of R38) holds (for B191 being (Element of ( Funcs (( AllFormulasOf R38 ) , ( AllFormulasOf R38 )) )) holds (( ( ( (R44 , R52) Subst4 B191 ) . ( ( Depth R59 ) + R25 ) ) . R59 ) = ( ( ( (R44 , R52) Subst4 B191 ) . ( Depth R59 ) ) . R59 ) & (( ( R38 -firstChar ) . R59 ) = R44 implies ( ( ( (R44 , R52) Subst4 ( R44 Subst1 R52 ) ) . ( Depth R59 ) ) . R59 ) = R59))))))))
proof
let R25 being Nat;
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R59 being  wff (string of R38);
set D849 = ( AllTermsOf R38 );
set D850 = ( AllFormulasOf R38 );
set D851 = ( R38 -firstChar );
let C378 being (Element of ( Funcs (D850 , D850) ));
reconsider D852 = R52 as (Element of D849) by FOMODEL1:def 32;
set D853 = ( R44 Subst1 R52 );
set D854 = ( (R44 , R52) Subst4 D853 );
set D855 = ( TheNorSymbOf R38 );
set D856 = ( LettersOf R38 );
set D857 = ( head R59 );
set D858 = ( Depth R59 );
set D859 = ( Depth D857 );
set D860 = ( AtomicFormulasOf R38 );
set D861 = ( (R44 , R52) Subst4 C378 );
defpred S15[ Nat ] means (( ( D861 . ( ( Depth R59 ) + $1 ) ) . R59 ) = ( ( D861 . ( Depth R59 ) ) . R59 ) & (( D851 . R59 ) = R44 implies ( ( D854 . $1 ) . R59 ) = R59));
L1239: S15[ ( 0 ) ]
proof
thus L1240: ( ( D861 . ( ( Depth R59 ) + ( 0 ) ) ) . R59 ) = ( ( D861 . ( Depth R59 ) ) . R59 );
assume L1241: ( D851 . R59 ) = R44;
reconsider D862 = R59 as non  0wff  wff (string of R38) by L1241;
reconsider D863 = D862 as (Element of D850) by FOMODEL2:16;
L1242: ( ( D851 . R59 ) \+\ D855 ) <> ( {} ) by L1241 , FOMODEL0:29;
reconsider D864 = D862 as  exal non  0wff  wff (string of R38) by L1242;
L1243: ( ( ( id D850 ) . D863 ) \+\ D863 ) = ( {} );
L1244: (not D864 in ( dom ( R44 AtomicSubst R52 ) ));
L1245: ( D853 . D864 ) = ( ( id D850 ) . D864 ) by L1244 , FUNCT_4:11
.= D864 by L1243 , FOMODEL0:29;
reconsider D865 = ( tail D864 ) as  empty set;
thus L1246: thesis by L1192 , L1245;
end;
L1247: (for R26 being Nat holds (S15[ R26 ] implies S15[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L1248: S15[ R26 ];
L1249: (D858 <> ( D858 + ( R26 + 1 ) ) & S15[ R26 ]) by L1248;
L1250: (D858 <> ( ( D858 + R26 ) + 1 ) & S15[ R26 ]) by L1249;
thus L1251: ( ( D861 . ( D858 + ( R26 + 1 ) ) ) . R59 ) = ( ( D861 . ( ( D858 + R26 ) + 1 ) ) . R59 )
.= ( (R44 , R52 , ( D858 + R26 ) , ( D861 . ( D858 + R26 ) )) Subst2 R59 ) by L1235
.= ( ( D861 . D858 ) . R59 ) by L1250 , L1153;
assume L1252: ( D851 . R59 ) = R44;
L1253: (( ( D851 . R59 ) \+\ D855 ) <> ( {} ) & (not R59 is ( 0 ) -wff)) by L1252 , FOMODEL0:29;
L1254: (R59 is non  0wff & (not R59 is non  exal non  0wff)) by L1253;
reconsider D866 = R59 as non  0wff  exal  wff (string of R38) by L1254;
thus L1255: ( ( D854 . ( R26 + 1 ) ) . R59 ) = ( (R44 , R52 , R26 , ( D854 . R26 )) Subst2 D866 ) by L1235
.= R59 by L1248 , L1252 , L1153;
end;
L1256: (for R26 being Nat holds S15[ R26 ]) from NAT_1:sch 2(L1239 , L1247);
thus L1257: thesis by L1256;
end;
L1258: (for R25 being Nat holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R52 being  termal (string of R38) holds (for R59 being  wff (string of R38) holds (R59 is R25 -wff implies ( (R44 , R52) SubstIn R59 ) = ( ( ( (R44 , R52) Subst4 ( R44 Subst1 R52 ) ) . R25 ) . R59 )))))))
proof
let R25 being Nat;
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let R59 being  wff (string of R38);
set D867 = ( Depth R59 );
set D868 = ( AllFormulasOf R38 );
reconsider D869 = ( R44 Subst1 R52 ) as (Element of ( Funcs (D868 , D868) ));
assume L1259: R59 is R25 -wff;
reconsider D870 = ( R25 - D867 ) as Nat by L1259;
L1260: ( ( ( (R44 , R52) Subst4 D869 ) . ( D867 + D870 ) ) . R59 ) = ( (R44 , R52) SubstIn R59 ) by L1238;
thus L1261: thesis by L1260;
end;
registration
let R38 being Language;
let R44 being  literal (Element of R38);
let R63 being (Element of ( AllTermsOf R38 ));
let R55 being  0wff (string of R38);
identify (R44 , R63) SubstIn R55 with (R44 , R63) AtomicSubst R55;
compatibility
proof
set D871 = ( (R44 , R63) SubstIn R55 );
set D872 = ( (R44 , R63) AtomicSubst R55 );
set D873 = ( R44 Subst1 R63 );
set D874 = ( (R44 , R63) Subst4 D873 );
set D875 = ( R44 AtomicSubst R63 );
set D876 = ( AtomicFormulasOf R38 );
L1262: (R55 in D876 & ( dom D875 ) = D876) by FUNCT_2:def 1;
reconsider D877 = R55 as (Element of ( dom D875 )) by L1262;
thus L1263: D871 = ( D873 . D877 ) by L1192
.= ( D875 . D877 ) by FUNCT_4:13
.= D872 by L1202;
end;
identify (R44 , R63) AtomicSubst R55 with (R44 , R63) SubstIn R55;
compatibility;
end;
theorem
L1265: (for R12 being non  empty set holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for R56 being  wff (string of R38) holds (for R63 being (Element of ( AllTermsOf R38 )) holds (( Depth ( (R44 , R63) SubstIn R56 ) ) = ( Depth R56 ) & (for B192 being (Element of ( R12 -InterpretersOf R38 )) holds ( B192 -TruthEval ( (R44 , R63) SubstIn R56 ) ) = ( ( (R44 , ( ( B192 -TermEval ) . R63 )) ReassignIn B192 ) -TruthEval R56 ))))))))
proof
let R12 being non  empty set;
let R38 being Language;
let R44 being  literal (Element of R38);
let R56 being  wff (string of R38);
let R63 being (Element of ( AllTermsOf R38 ));
set D878 = ( R12 -InterpretersOf R38 );
set D879 = ( AllTermsOf R38 );
set D880 = ( AtomicFormulasOf R38 );
set D881 = ( R38 -firstChar );
set D882 = ( LettersOf R38 );
set D883 = ( R44 AtomicSubst R63 );
set D884 = ( R44 Subst1 R63 );
set D885 = ( (R44 , R63) Subst4 D884 );
set D886 = ( AllFormulasOf R38 );
set D887 = ( TheNorSymbOf R38 );
defpred S16[ Nat ] means (for R59 being  wff (string of R38) holds (( Depth R59 ) <= $1 implies (( Depth ( (R44 , R63) SubstIn R59 ) ) = ( Depth R59 ) & (for B193 being (Element of D878) holds ( B193 -TruthEval ( (R44 , R63) SubstIn R59 ) ) = ( ( (R44 , ( ( B193 -TermEval ) . R63 )) ReassignIn B193 ) -TruthEval R59 )))));
L1266: ( R63 null ( {} ) ) is ( ( {} ) \/ ( rng R63 ) ) -valued ( ( {} ) \/ ( rng R63 ) ) -valued ( ( {} ) \/ ( rng R63 ) ) -valued ( ( {} ) \/ ( rng R63 ) ) -valued FinSequence;
L1267: R63 is (FinSequence of ( rng R63 )) by L1266 , FOMODEL0:26;
reconsider D888 = R63 as (Element of ( ( rng R63 ) * )) by L1267 , FINSEQ_1:def 11;
L1268: S16[ ( 0 ) ]
proof
let R59 being  wff (string of R38);
set D889 = ( Depth R59 );
set D890 = ( (R44 , R63) SubstIn R59 );
assume L1269: D889 <= ( 0 );
reconsider D891 = R59 as  0wff (string of R38) by L1269;
L1270: ( Depth ( (R44 , R63) SubstIn D891 ) ) = ( 0 );
thus L1271: ( Depth D890 ) = D889 by L1270;
let C379 being (Element of D878);
set D892 = ( ( C379 -TermEval ) . R63 );
set D893 = ( (R44 , D892) ReassignIn C379 );
L1272: ( C379 -TruthEval ( (R44 , R63) AtomicSubst D891 ) ) = ( D893 -TruthEval D891 ) by L925;
thus L1273: thesis by L1272;
end;
L1274: (for R26 being Nat holds (S16[ R26 ] implies S16[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L1275: S16[ R26 ];
let R59 being  wff (string of R38);
reconsider D894 = ( D882 \ ( ( ( rng R63 ) \/ ( rng ( head R59 ) ) ) \/ { R44 } ) ) as  infinite (Subset of D882);
reconsider D895 = D894 as non  empty (Subset of D882);
set D896 = the (Element of D894);
reconsider D897 = D896 as  literal (Element of R38) by TARSKI:def 3;
assume L1276: ( Depth R59 ) <= ( R26 + 1 );
L1277: (not D897 in ( ( ( rng R63 ) \/ ( rng ( head R59 ) ) ) \/ { R44 } )) by XBOOLE_0:def 5;
L1278: ((not D897 in ( ( rng R63 ) \/ ( rng ( head R59 ) ) )) & (not D897 in { R44 })) by L1277 , XBOOLE_0:def 3;
L1279: (D897 <> R44 & (not D897 in ( rng R63 )) & (not D897 in ( rng ( head R59 ) ))) by L1278 , TARSKI:def 1 , XBOOLE_0:def 3;
per cases ;
suppose L1280: R59 is  exal;

reconsider D898 = R59 as non  0wff  exal  wff (string of R38) by L1280;
consider R25 being Nat such that L1281: ( Depth D898 ) = ( R25 + 1 ) by NAT_1:6;
reconsider D899 = R25 as (Element of ( NAT )) by ORDINAL1:def 12;
L1282: R25 <= R26 by L1276 , L1281 , XREAL_1:6;
reconsider D900 = D898 as non  0wff  exal ( R25 + 1 ) -wff (string of R38) by L1281 , FOMODEL2:def 31;
set D901 = ( (R44 , R63) SubstIn D900 );
set D902 = ( Depth D900 );
reconsider D903 = ( D881 . D900 ) as  literal (Element of R38);
reconsider D904 = ( head D900 ) as (Element of D886) by FOMODEL2:16;
set D905 = ( Depth D904 );
reconsider D906 = ( tail D900 ) as  empty set;
reconsider D907 = ( (D903 , D897) -SymbolSubstIn R59 ) as ( R25 + 1 ) -wff (string of R38);
reconsider D908 = ( (D903 , D897) -SymbolSubstIn ( head D900 ) ) as R25 -wff (string of R38);
L1283: ( ( Depth D908 ) \+\ D905 ) = ( {} );
L1284: ( Depth D908 ) = ( Depth D904 ) by L1283 , FOMODEL0:29;
reconsider D909 = ( (R44 , R63) SubstIn D908 ) as  wff (string of R38);
L1285: D900 = ( ( <* D903 *> ^ D904 ) ^ D906 ) by FOMODEL2:23
.= ( <* D903 *> ^ D904 );
L1286: D905 <= R25 by FOMODEL2:def 31;
L1287: D905 <= R26 by L1286 , L1282 , XXREAL_0:2;
L1288: ( Depth D909 ) = ( Depth ( head D900 ) ) by L1287 , L1275 , L1284;
reconsider D910 = ( R25 - D905 ) as Nat;
reconsider D911 = ( (R44 , R63) SubstIn D904 ) as  wff (string of R38);
set D912 = ( Depth D911 );
L1289: D901 = ( (R44 , R63 , R25 , ( D885 . D899 )) Subst2 D900 ) by L1281 , L1235;
per cases ;
suppose L1290: D903 <> R44;

L1291: D901 = ( <* D897 *> ^ ( ( D885 . D899 ) . ( (D903 , D897) -SymbolSubstIn D904 ) ) ) by L1290 , L1281 , L1153 , L1289
.= ( <* D897 *> ^ ( (R44 , R63) SubstIn D908 ) ) by L1258;
L1292: ( Depth D901 ) = ( ( Depth D904 ) + 1 ) by L1291 , L1288 , FOMODEL2:17
.= ( Depth R59 ) by L1285 , FOMODEL2:17;
thus L1293: ( Depth ( (R44 , R63) SubstIn R59 ) ) = ( Depth R59 ) by L1292;
let C380 being (Element of D878);
set D913 = ( ( C380 -TermEval ) . R63 );
set D914 = ( (R44 , D913) ReassignIn C380 );
L1294: (( C380 -TruthEval D901 ) = 1 iff ( ( (R44 , D913) ReassignIn C380 ) -TruthEval D900 ) = 1)
proof
thus L1295:now
assume L1296: ( C380 -TruthEval D901 ) = 1;
consider R16 being (Element of R12) such that L1297: ( ( (D897 , R16) ReassignIn C380 ) -TruthEval D909 ) = 1 by L1296 , L1291 , FOMODEL2:19;
set D915 = ( (D897 , R16) ReassignIn C380 );
L1298: 1 = ( ( (R44 , ( ( D915 -TermEval ) . R63 )) ReassignIn D915 ) -TruthEval D908 ) by L1297 , L1284 , L1287 , L1275
.= ( ( (R44 , D913) ReassignIn D915 ) -TruthEval D908 ) by L1279 , FOMODEL2:25
.= ( ( (D897 , R16) ReassignIn ( (R44 , D913) ReassignIn C380 ) ) -TruthEval D908 ) by L1279 , FOMODEL0:43
.= ( ( (D903 , R16) ReassignIn ( (R44 , D913) ReassignIn C380 ) ) -TruthEval ( head D900 ) ) by L1279 , L1088;
thus L1299: 1 = ( ( (R44 , D913) ReassignIn C380 ) -TruthEval D900 ) by L1298 , L1285 , FOMODEL2:19;
end;
assume L1300: ( ( (R44 , D913) ReassignIn C380 ) -TruthEval D900 ) = 1;
consider R17 being (Element of R12) such that L1301: ( ( (D903 , R17) ReassignIn ( (R44 , D913) ReassignIn C380 ) ) -TruthEval ( head D900 ) ) = 1 by L1300 , L1285 , FOMODEL2:19;
L1302: 1 = ( ( (D897 , R17) ReassignIn ( (R44 , D913) ReassignIn C380 ) ) -TruthEval D908 ) by L1301 , L1088 , L1279
.= ( ( (R44 , D913) ReassignIn ( (D897 , R17) ReassignIn C380 ) ) -TruthEval D908 ) by L1279 , FOMODEL0:43
.= ( ( (R44 , ( ( ( (D897 , R17) ReassignIn C380 ) -TermEval ) . R63 )) ReassignIn ( (D897 , R17) ReassignIn C380 ) ) -TruthEval D908 ) by L1279 , FOMODEL2:25
.= ( ( (D897 , R17) ReassignIn C380 ) -TruthEval D909 ) by L1284 , L1287 , L1275;
thus L1303: ( C380 -TruthEval D901 ) = 1 by L1302 , L1291 , FOMODEL2:19;
end;
L1304: (( C380 -TruthEval D901 ) = 1 iff (not ( ( (R44 , D913) ReassignIn C380 ) -TruthEval D900 ) = ( 0 ))) by L1294 , FOMODEL0:39;
thus L1305: thesis by L1304 , FOMODEL0:39;
end;
suppose L1306: D903 = R44;

L1307: R59 = D901 by L1306 , L1238;
thus L1308: ( Depth ( (R44 , R63) SubstIn R59 ) ) = ( Depth R59 ) by L1306 , L1238;
let C381 being (Element of D878);
set D916 = ( ( C381 -TermEval ) . R63 );
set D917 = ( (R44 , D916) ReassignIn C381 );
L1309: (( D917 -TruthEval D900 ) = 1 iff ( C381 -TruthEval D900 ) = 1)
proof
thus L1310:now
assume L1311: ( D917 -TruthEval D900 ) = 1;
consider R16 being (Element of R12) such that L1312: ( ( (D903 , R16) ReassignIn D917 ) -TruthEval D904 ) = 1 by L1311 , L1285 , FOMODEL2:19;
L1313: 1 = ( ( (D903 , R16) ReassignIn C381 ) -TruthEval D904 ) by L1312 , L1306 , FOMODEL0:43;
thus L1314: ( C381 -TruthEval D900 ) = 1 by L1313 , L1285 , FOMODEL2:19;
end;
assume L1315: ( C381 -TruthEval D900 ) = 1;
consider R17 being (Element of R12) such that L1316: ( ( (D903 , R17) ReassignIn C381 ) -TruthEval D904 ) = 1 by L1315 , L1285 , FOMODEL2:19;
L1317: ( ( (D903 , R17) ReassignIn D917 ) -TruthEval D904 ) = 1 by L1306 , L1316 , FOMODEL0:43;
thus L1318: ( D917 -TruthEval D900 ) = 1 by L1317 , L1285 , FOMODEL2:19;
end;
L1319: (( D917 -TruthEval R59 ) = 1 iff (not ( C381 -TruthEval R59 ) = ( 0 ))) by L1309 , FOMODEL0:39;
thus L1320: thesis by L1319 , L1307 , FOMODEL0:39;
end;
end;
suppose L1322: ((not R59 is  exal) & (not R59 is  0wff));

reconsider D918 = R59 as non  0wff non  exal  wff (string of R38) by L1322;
set D919 = ( (R44 , R63) SubstIn D918 );
set D920 = ( Depth D918 );
consider R25 being Nat such that L1323: D920 = ( R25 + 1 ) by NAT_1:6;
reconsider D921 = R25 as (Element of ( NAT )) by ORDINAL1:def 12;
L1324: ( ( R25 + 1 ) + ( - 1 ) ) <= ( ( R26 + 1 ) - 1 ) by L1276 , L1323 , XREAL_1:6;
reconsider D922 = D918 as non  0wff non  exal ( R25 + 1 ) -wff (string of R38) by L1323 , FOMODEL2:def 31;
reconsider D923 = ( head D922 ) , D924 = ( tail D922 ) as (Element of D886) by FOMODEL2:16;
set D925 = ( Depth D923 );
set D926 = ( Depth D924 );
L1325: (( ( D881 . D922 ) \+\ D887 ) = ( {} ) & D922 = ( ( <* ( D881 . D922 ) *> ^ D923 ) ^ D924 )) by FOMODEL2:23;
L1326: D922 = ( ( <* D887 *> ^ D923 ) ^ D924 ) by L1325 , FOMODEL0:29;
L1327: (D925 <= R25 & D926 <= R25) by FOMODEL2:def 31;
reconsider D927 = ( R25 - D925 ) , D928 = ( R25 - D926 ) as Nat;
reconsider D929 = ( (R44 , R63) SubstIn D923 ) , D930 = ( (R44 , R63) SubstIn D924 ) as  wff (string of R38);
set D931 = ( Depth D929 );
set D932 = ( Depth D930 );
L1328: (D925 <= R26 & D926 <= R26) by L1324 , L1327 , XXREAL_0:2;
L1329: D919 = ( (R44 , R63 , R25 , ( D885 . D921 )) Subst2 D922 ) by L1323 , L1235
.= ( ( <* D887 *> ^ ( ( D885 . ( D925 + D927 ) ) . D923 ) ) ^ ( ( D885 . ( D926 + D928 ) ) . D924 ) ) by L1153 , L1323
.= ( ( <* D887 *> ^ D929 ) ^ ( ( D885 . ( D926 + D928 ) ) . D924 ) ) by L1238
.= ( ( <* D887 *> ^ D929 ) ^ D930 ) by L1238;
L1330: ( Depth D919 ) = ( 1 + ( max (D931 , D932) ) ) by L1329 , FOMODEL2:17
.= ( 1 + ( max (D925 , D932) ) ) by L1328 , L1275
.= ( 1 + ( max (D925 , D926) ) ) by L1328 , L1275
.= D920 by L1326 , FOMODEL2:17;
thus L1331: ( Depth ( (R44 , R63) SubstIn R59 ) ) = ( Depth R59 ) by L1330;
let C382 being (Element of D878);
set D933 = ( C382 -TermEval );
set D934 = ( D933 . R63 );
set D935 = ( (R44 , D934) ReassignIn C382 );
set D936 = ( C382 -TruthEval D919 );
set D937 = ( D935 -TruthEval D922 );
L1332: (( C382 -TruthEval D929 ) = ( D935 -TruthEval D923 ) & ( C382 -TruthEval D930 ) = ( D935 -TruthEval D924 )) by L1328 , L1275;
L1333: (( D935 -TruthEval D922 ) = 1 iff (( C382 -TruthEval D929 ) = ( 0 ) & ( C382 -TruthEval D930 ) = ( 0 ))) by L1332 , L1326 , FOMODEL2:19;
L1334: (D936 = 1 iff (not D937 = ( 0 ))) by L1333 , L1329 , FOMODEL0:39 , FOMODEL2:19;
thus L1335: thesis by L1334 , FOMODEL0:39;
end;
suppose L1336: R59 is  0wff;

thus L1337: thesis by L1336 , L1268;
end;
end;
L1339: (for R25 being Nat holds S16[ R25 ]) from NAT_1:sch 2(L1268 , L1274);
set D938 = ( Depth R56 );
thus L1340: ( Depth ( (R44 , R63) SubstIn R56 ) ) = ( Depth R56 ) by L1339;
let C383 being (Element of D878);
thus L1341: thesis by L1339;
end;
registration
let R25 being Nat;
let R38 being Language;
let R44 being  literal (Element of R38);
let R52 being  termal (string of R38);
let C384 being R25 -wff (string of R38);
cluster ( (R44 , R52) SubstIn C384 ) -> R25 -wff for (string of R38);
coherence
proof
set D939 = ( Depth C384 );
set D940 = ( AllTermsOf R38 );
reconsider D941 = R52 as (Element of D940) by FOMODEL1:def 32;
set D942 = ( (R44 , D941) SubstIn C384 );
reconsider D943 = ( R25 - D939 ) as Nat;
L1342: ( Depth D942 ) = D939 by L1265;
reconsider D944 = D942 as D939 -wff (string of R38) by L1342 , FOMODEL2:def 31;
L1343: D944 is ( D939 + ( ( 0 ) * D943 ) ) -wff;
L1344: D944 is ( D939 + D943 ) -wff by L1343;
thus L1345: thesis by L1344;
end;
end;
L1347: (for R4 being set holds (for R12 being non  empty set holds (for R39 being Language holds (for R40 being Language holds (for B194 being (Element of ( R12 -InterpretersOf R39 )) holds (for B195 being (Element of ( R12 -InterpretersOf R40 )) holds ((( B194 | R4 ) = ( B195 | R4 ) & ( (the adicity of R39) | R4 ) = ( (the adicity of R40) | R4 )) implies ( ( B194 -TermEval ) | ( R4 * ) ) c= ( ( B195 -TermEval ) | ( R4 * ) ))))))))
proof
let R4 being set;
let R12 being non  empty set;
let R39 being Language;
let R40 being Language;
set D945 = ( R39 -termsOfMaxDepth );
set D946 = ( OwnSymbolsOf R39 );
set D947 = ( AllTermsOf R39 );
set D948 = ( AllSymbolsOf R39 );
set D949 = ( LettersOf R39 );
set D950 = ( R39 -firstChar );
set D951 = ( R39 -multiCat );
set D952 = ( AtomicTermsOf R39 );
set D953 = ( R12 -InterpretersOf R39 );
set D954 = (the adicity of R39);
set D955 = ( ( D948 * ) \ { ( {} ) } );
set D956 = ( R40 -termsOfMaxDepth );
set D957 = ( OwnSymbolsOf R40 );
set D958 = ( AllTermsOf R40 );
set D959 = ( AllSymbolsOf R40 );
set D960 = ( LettersOf R40 );
set D961 = ( R40 -firstChar );
set D962 = ( R40 -multiCat );
set D963 = ( AtomicTermsOf R40 );
set D964 = ( R12 -InterpretersOf R40 );
set D965 = (the adicity of R40);
set D966 = ( ( D959 * ) \ { ( {} ) } );
let C385 being (Element of D953);
let C386 being (Element of D964);
L1348: (( dom C385 ) = D946 & ( dom C386 ) = D957) by PARTFUN1:def 2;
set D967 = ( C385 -TermEval );
set D968 = ( C386 -TermEval );
set D969 = ( C385 | R4 );
set D970 = ( C386 | R4 );
assume L1349: D969 = D970;
L1350: (( dom D967 ) = D947 & ( dom D968 ) = D958 & D969 = D970) by L1349 , FUNCT_2:def 1;
L1351: ( R4 /\ ( dom C385 ) ) = ( dom D970 ) by L1349 , RELAT_1:61
.= ( R4 /\ ( dom C386 ) ) by RELAT_1:61;
defpred S17[ Nat ] means ( D967 | ( ( R4 * ) /\ ( D945 . $1 ) ) ) c= ( D968 | ( ( R4 * ) /\ ( D956 . $1 ) ) );
deffunc H12(set) = { <* B196 *> where B196 is (Element of $1) : (not contradiction) };
L1352: S17[ ( 0 ) ]
proof
L1353: (( D956 . ( 0 ) ) c= D958 & ( D945 . ( 0 ) ) c= D947) by FOMODEL1:2;
reconsider D971 = ( ( R4 * ) /\ ( D945 . ( 0 ) ) ) as (Subset of D947) by L1353 , XBOOLE_1:1;
reconsider D972 = ( ( R4 * ) /\ ( D956 . ( 0 ) ) ) as (Subset of D958) by L1353 , XBOOLE_1:1;
set D973 = ( D967 | D971 );
set D974 = ( D968 | D972 );
L1354: (( dom D973 ) = D971 & ( dom D974 ) = D972) by PARTFUN1:def 2;
L1355:
now
let R7 being set;
assume L1356: R7 in ( dom D973 );
L1357: R7 in ( ( R4 * ) /\ D952 ) by L1356 , L1354 , FOMODEL1:def 30;
L1358: R7 in ( 1 -tuples_on ( R4 /\ D949 ) ) by L1357 , FOMODEL0:2;
reconsider D975 = ( R4 /\ D949 ) as non  empty set by L1358;
L1359: D975 <> ( {} );
reconsider D976 = R4 as non  empty set by L1359;
reconsider D977 = R7 as (Element of ( R4 * )) by L1356 , L1354;
L1360: R7 in H12(D975) by L1358 , FINSEQ_2:96;
consider C387 being (Element of D975) such that L1361: (R7 = <* C387 *> & (not contradiction)) by L1360;
L1362: C387 in D975;
reconsider D978 = C387 as  literal (Element of R39) by L1362;
L1363: (D978 in R4 & D978 in D946) by FOMODEL1:def 19 , XBOOLE_0:def 4;
L1364: D978 in ( R4 /\ D957 ) by L1363 , L1351 , L1348 , XBOOLE_0:def 4;
reconsider D979 = D978 as  own (Element of R40) by L1364;
reconsider D980 = D979 , D981 = D978 as (Element of D976) by XBOOLE_0:def 4;
L1365: (( ( ( C386 | D976 ) . D980 ) \+\ ( C386 . D980 ) ) = ( {} ) & ( ( ( C385 | D976 ) . D981 ) \+\ ( C385 . D981 ) ) = ( {} ));
L1366: (( D970 . D979 ) = ( C386 . D979 ) & ( D969 . D978 ) = ( C385 . D978 )) by L1365 , FOMODEL0:29;
L1367: ( ( 0 ) -tuples_on R12 ) = ( dom ( C386 . D979 ) ) by L1366 , L1349 , FUNCT_2:def 1
.= ( ( abs ( ar D979 ) ) -tuples_on R12 ) by FUNCT_2:def 1;
L1368: ((not D979 is  relational) & (not D979 is  operational)) by L1367;
reconsider D982 = D979 as  literal (Element of R40) by L1368;
L1369: R7 in D952 by L1357;
L1370: R7 in ( D945 . ( 0 ) ) by L1369 , FOMODEL1:def 30;
reconsider D983 = R7 as ( 0 ) -termal (string of R39) by L1370 , FOMODEL1:def 33;
reconsider D984 = D971 as non  empty (Subset of D947) by L1356;
reconsider D985 = D983 as (Element of D984) by L1356;
L1371: (D981 in D976 & D982 in D960) by FOMODEL1:def 14;
reconsider D986 = ( D976 /\ D960 ) as non  empty set by L1371 , XBOOLE_0:def 4;
reconsider D987 = D982 as (Element of D986) by L1371 , XBOOLE_0:def 4;
L1372: <* D987 *> in H12(D986);
L1373: <* D987 *> in ( 1 -tuples_on D986 ) by L1372 , FINSEQ_2:96;
L1374: R7 in ( ( R4 * ) /\ D963 ) by L1373 , L1361 , FOMODEL0:2;
reconsider D988 = D972 as non  empty (Subset of D958) by L1374 , FOMODEL1:def 30;
reconsider D989 = R7 as (Element of D988) by L1374 , FOMODEL1:def 30;
L1375: ( D983 . 1 ) = C387 by L1361 , FINSEQ_1:40;
reconsider D990 = ( D983 . 1 ) as (Element of D976) by L1375 , XBOOLE_0:def 4;
L1376: (( ( ( C385 | D976 ) . D990 ) \+\ ( C385 . D990 ) ) = ( {} ) & ( ( ( C386 | D976 ) . D990 ) \+\ ( C386 . D990 ) ) = ( {} ) & ( ( ( D968 | D988 ) . D989 ) \+\ ( D968 . D989 ) ) = ( {} ));
L1377: (( D969 . D990 ) = ( C385 . D990 ) & ( D970 . D990 ) = ( C386 . D990 ) & ( D968 . D989 ) = ( ( D968 | D988 ) . D989 )) by L1376 , FOMODEL0:29;
L1378: ( ( ( D967 | D984 ) . D985 ) \+\ ( D967 . D985 ) ) = ( {} );
L1379: ( D973 . R7 ) = ( D967 . D983 ) by L1378 , FOMODEL0:29
.= ( ( C385 . ( D950 . D983 ) ) . ( D967 * ( SubTerms D983 ) ) ) by FOMODEL2:21
.= ( ( C386 . D982 ) . ( {} ) ) by L1375 , L1349 , L1377 , FOMODEL0:6
.= ( ( C386 . ( <* D982 *> . 1 ) ) . ( {} ) ) by FINSEQ_1:40
.= ( ( C386 . ( D961 . <* D982 *> ) ) . ( D968 * ( SubTerms <* D982 *> ) ) ) by FOMODEL0:6
.= ( D974 . R7 ) by L1361 , L1377 , FOMODEL2:21;
thus L1380: (R7 in ( dom D974 ) & ( D974 . R7 ) = ( D973 . R7 )) by L1379 , L1354 , L1374 , FOMODEL1:def 30;
end;
thus L1381: thesis by L1355 , FOMODEL0:51;
end;
assume L1382: ( D954 | R4 ) = ( D965 | R4 );
L1383: (for R26 being Nat holds (S17[ R26 ] implies S17[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L1384: S17[ R26 ];
reconsider D991 = R26 , D992 = ( R26 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L1385: (( D956 . D992 ) c= D958 & ( D945 . D992 ) c= D947 & ( D945 . D991 ) c= D947 & ( D956 . D991 ) c= D958) by FOMODEL1:2;
reconsider D993 = ( ( R4 * ) /\ ( D945 . D992 ) ) , D994 = ( ( R4 * ) /\ ( D945 . D991 ) ) as (Subset of D947) by L1385 , XBOOLE_1:1;
reconsider D995 = ( ( R4 * ) /\ ( D956 . D992 ) ) , D996 = ( ( R4 * ) /\ ( D956 . D991 ) ) as (Subset of D958) by L1385 , XBOOLE_1:1;
set D997 = ( D967 | D993 );
set D998 = ( D968 | D995 );
L1386: (( dom D997 ) = D993 & ( dom D998 ) = D995 & ( dom ( D967 | D994 ) ) = D994 & ( dom ( D968 | D996 ) ) = D996) by PARTFUN1:def 2;
L1387: D994 c= D996 by L1386 , L1384 , GRFUNC_1:2;
reconsider D999 = D994 as (Subset of D996) by L1384 , L1386 , GRFUNC_1:2;
reconsider D1000 = D999 as (Subset of D958) by XBOOLE_1:1;
L1388:
now
let R10 being set;
assume L1389: R10 in ( dom D997 );
reconsider D1001 = D993 as non  empty set by L1389;
reconsider D1002 = R10 as (Element of D1001) by L1389;
L1390: D1002 in ( D945 . D992 ) by XBOOLE_0:def 4;
reconsider D1003 = D1002 as ( D991 + 1 ) -termal (string of R39) by L1390 , FOMODEL1:def 33;
reconsider D1004 = ( D950 . D1003 ) as  termal (Element of R39);
set D1005 = ( abs ( ar D1004 ) );
L1391: (D1003 in ( R4 * ) & D1003 is non  empty) by TARSKI:def 3;
reconsider D1006 = R4 as non  empty set by L1391;
L1392: D1002 in ( D1006 * ) by TARSKI:def 3;
L1393: ( { ( D1003 . 1 ) } \ D1006 ) = ( {} ) by L1392;
L1394: (( D1003 . 1 ) in D1006 & D1004 = ( D1003 . 1 )) by L1393 , FOMODEL0:6 , ZFMISC_1:60;
L1395: (D1004 in D1006 & D1004 in D946) by L1394 , FOMODEL1:def 19;
L1396: D1004 in ( D1006 /\ D957 ) by L1395 , L1351 , L1348 , XBOOLE_0:def 4;
reconsider D1007 = D1004 as  own (Element of R40) by L1396;
reconsider D1008 = D1007 as  ofAtomicFormula (Element of R40);
reconsider D1009 = D1004 as (Element of D1006) by L1394;
L1397: (( ( D954 . D1009 ) \+\ ( ( D954 | D1006 ) . D1009 ) ) = ( {} ) & ( ( D965 . D1009 ) \+\ ( ( D965 | D1006 ) . D1009 ) ) = ( {} ));
L1398: (( D954 . D1004 ) = ( ( D954 | R4 ) . D1004 ) & ( D965 . D1007 ) = ( ( D965 | R4 ) . D1007 )) by L1397 , FOMODEL0:29;
L1399: ( ar D1004 ) = ( ar D1008 ) by L1398 , L1382;
L1400: (not D1008 is  relational) by L1399;
reconsider D1010 = D1007 as  termal (Element of R40) by L1400;
set D1011 = ( abs ( ar D1010 ) );
L1401: (( ( C385 . D1009 ) \+\ ( ( C385 | D1006 ) . D1009 ) ) = ( {} ) & ( ( C386 . D1009 ) \+\ ( ( C386 | D1006 ) . D1009 ) ) = ( {} ));
L1402: ( C385 . D1009 ) = ( ( C385 | D1006 ) . D1004 ) by L1401 , FOMODEL0:29
.= ( C386 . D1009 ) by L1401 , L1349 , FOMODEL0:29;
set D1012 = ( SubTerms D1003 );
reconsider D1013 = ( rng D1003 ) as non  empty (Subset of D1006) by L1392 , RELAT_1:def 19;
L1403: (( rng D1012 ) c= ( ( rng D1003 ) * ) & ( D1013 * ) c= ( D1006 * )) by RELAT_1:def 19;
L1404: ( rng D1012 ) c= ( D1006 * ) by L1403 , XBOOLE_1:1;
L1405: ( rng D1012 ) c= ( D945 . R26 ) by RELAT_1:def 19;
L1406: ( rng D1012 ) c= D994 by L1405 , L1404 , XBOOLE_1:19;
L1407: (( rng D1012 ) c= ( ( D948 * ) \ { ( {} ) } ) & ( rng D1012 ) c= D996) by L1406 , L1387 , XBOOLE_1:1;
L1408: (( rng D1012 ) c= ( ( D948 * ) \ { ( {} ) } ) & ( rng D1012 ) c= ( ( D959 * ) \ { ( {} ) } )) by L1407 , XBOOLE_1:1;
L1409: (( rng D1012 ) c= ( D948 * ) & ( rng D1012 ) c= ( D959 * )) by L1408 , XBOOLE_1:1;
L1410: ( rng D1012 ) c= ( D956 . D991 ) by L1407 , XBOOLE_1:1;
L1411: D1012 is ( D956 . D991 ) -valued by L1410 , RELAT_1:def 19;
L1412: D1012 is D1011 -element D1011 -element D1011 -element D1011 -element (FinSequence of ( D956 . D991 )) by L1411 , L1382 , L1398 , FOMODEL0:26;
reconsider D1014 = D1012 as D1011 -element (Element of ( ( D956 . D991 ) * )) by L1412 , FINSEQ_1:def 11;
reconsider D1015 = ( D956 . D991 ) as non  empty (Subset of D958) by FOMODEL1:2;
L1413: D1014 in ( D1015 * );
reconsider D1016 = D1014 as D1011 -element (Element of ( D958 * )) by L1413;
reconsider D1017 = ( D1010 -compound D1014 ) as ( D991 + 1 ) -termal (string of R40);
per cases ;
suppose L1414: D1003 is ( 0 ) -termal;

reconsider D1018 = D1003 as ( 0 ) -termal (string of R39) by L1414;
L1415: (D1018 in ( R4 * ) & D1018 in ( D945 . ( 0 ) )) by FOMODEL1:def 33 , TARSKI:def 3;
L1416: D1018 in ( ( D1006 * ) /\ ( D945 . ( 0 ) ) ) by L1415 , XBOOLE_0:def 4;
L1417: (( D956 . ( 0 ) ) c= D958 & ( D945 . ( 0 ) ) c= D947) by FOMODEL1:2;
reconsider D1019 = ( ( R4 * ) /\ ( D945 . ( 0 ) ) ) as (Subset of D947) by L1417 , XBOOLE_1:1;
reconsider D1020 = ( ( R4 * ) /\ ( D956 . ( 0 ) ) ) as (Subset of D958) by L1417 , XBOOLE_1:1;
set D1021 = ( D967 | D1019 );
set D1022 = ( D968 | D1020 );
L1418: (( dom D1021 ) = D1019 & ( dom D1022 ) = D1020) by PARTFUN1:def 2;
L1419: D1019 c= D1020 by L1418 , L1352 , GRFUNC_1:2;
L1420: (D1018 in D1020 & D1018 in D1019) by L1419 , L1416;
reconsider D1023 = D1018 as ( 0 ) -termal (string of R40) by L1420 , FOMODEL1:def 33;
L1421: D1023 is ( ( 0 ) + ( ( 0 ) * D992 ) ) -termal;
L1422: D1023 is ( ( 0 ) + D992 ) -termal by L1421;
L1423: (D1023 in ( D1006 * ) & D1023 in ( D956 . D992 )) by L1422 , FOMODEL1:def 33 , TARSKI:def 3;
thus L1424: R10 in ( dom D998 ) by L1386 , L1423 , XBOOLE_0:def 4;
reconsider D1024 = D995 as non  empty set by L1423 , XBOOLE_0:def 4;
reconsider D1025 = D1019 , D1026 = D1020 as non  empty set by L1418 , L1352 , L1415 , XBOOLE_0:def 4;
reconsider D1027 = D1018 as (Element of D1025) by L1415 , XBOOLE_0:def 4;
reconsider D1028 = D1018 as (Element of D1026) by L1419 , L1416;
reconsider D1029 = D1023 as (Element of D1024) by L1423 , XBOOLE_0:def 4;
L1425: (( ( ( D967 | D1001 ) . D1002 ) \+\ ( D967 . D1002 ) ) = ( {} ) & ( ( ( D967 | ( ( R4 * ) /\ ( D945 . ( 0 ) ) ) ) . D1027 ) \+\ ( D967 . D1027 ) ) = ( {} ) & ( ( ( D968 | D1020 ) . D1028 ) \+\ ( D968 . D1028 ) ) = ( {} ) & ( ( ( D968 | D1024 ) . D1029 ) \+\ ( D968 . D1029 ) ) = ( {} ));
L1426: (( D997 . R10 ) = ( D967 . R10 ) & ( ( D967 | ( ( R4 * ) /\ ( D945 . ( 0 ) ) ) ) . R10 ) = ( D967 . R10 ) & ( ( D968 | ( ( R4 * ) /\ ( D956 . ( 0 ) ) ) ) . R10 ) = ( D968 . R10 ) & ( D998 . R10 ) = ( D968 . R10 )) by L1425 , FOMODEL0:29;
thus L1427: ( D997 . R10 ) = ( D998 . R10 ) by L1426 , L1352 , L1418 , L1416 , GRFUNC_1:2;
end;
suppose L1428: (not D1003 is ( 0 ) -termal);

L1429: D1004 is  operational by L1428 , FOMODEL1:16;
consider C388 being Nat such that L1430: D1005 = ( C388 + 1 ) by L1429 , NAT_1:6;
reconsider D1030 = C388 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D1031 = D1012 as ( D1030 + 1 ) -element (Element of ( D947 * )) by L1430;
L1431: (not D1031 is ( ( {} ) * ) -valued);
L1432: D1031 is ( D959 * ) -valued by L1409 , RELAT_1:def 19;
L1433: ( D962 . D1031 ) <> ( {} ) by L1432 , L1431 , FOMODEL0:52;
L1434: ( D951 . D1012 ) = ( D962 . D1012 ) by L1433 , FOMODEL0:52;
L1435: D1003 = D1017 by L1434 , FOMODEL1:def 37;
L1436: (D1003 in ( R4 * ) & D1003 in ( D956 . D992 )) by L1435 , FOMODEL1:def 33 , TARSKI:def 3;
thus L1437: R10 in ( dom D998 ) by L1436 , L1386 , XBOOLE_0:def 4;
L1438: (D1017 in ( D956 . D992 ) & D1017 in ( R4 * )) by L1434 , L1391 , FOMODEL1:def 33 , FOMODEL1:def 37;
reconsider D1032 = D995 as non  empty set by L1438 , XBOOLE_0:def 4;
reconsider D1033 = D1017 as (Element of D1032) by L1438 , XBOOLE_0:def 4;
L1439: ( D961 . D1017 ) = ( D1017 . 1 ) by FOMODEL0:6
.= D1010 by FINSEQ_1:41;
L1440: D1016 = ( SubTerms D1017 ) by L1439 , FOMODEL1:def 37;
L1441: ( D967 | D994 ) = ( ( D968 | D996 ) | D994 ) by L1384 , L1386 , GRFUNC_1:34
.= ( D968 | ( D999 null D996 ) ) by RELAT_1:71;
L1442: (( ( ( D967 | D1001 ) . D1002 ) \+\ ( D967 . D1002 ) ) = ( {} ) & ( ( ( D968 | D1032 ) . D1033 ) \+\ ( D968 . D1033 ) ) = ( {} ));
L1443: (( ( D967 | D993 ) . D1002 ) = ( D967 . D1002 ) & ( ( D968 | D995 ) . D1017 ) = ( D968 . D1017 )) by L1442 , FOMODEL0:29;
thus L1444: ( D997 . R10 ) = ( ( C385 . D1004 ) . ( D967 * D1012 ) ) by L1443 , FOMODEL2:21
.= ( ( C385 . D1004 ) . ( ( D967 | D994 ) * D1012 ) ) by L1386 , L1405 , L1404 , RELAT_1:165 , XBOOLE_1:19
.= ( ( C385 . D1004 ) . ( D968 * D1012 ) ) by L1386 , L1405 , L1404 , L1441 , RELAT_1:165 , XBOOLE_1:19
.= ( D998 . R10 ) by L1435 , L1443 , L1439 , L1440 , L1402 , FOMODEL2:21;
end;
end;
thus L1446: thesis by L1388 , FOMODEL0:51;
end;
L1447: (for R26 being Nat holds S17[ R26 ]) from NAT_1:sch 2(L1352 , L1383);
L1448:
now
set D1034 = ( D967 | ( R4 * ) );
set D1035 = ( D968 | ( R4 * ) );
L1449: (( dom D1034 ) = ( ( R4 * ) /\ D947 ) & ( dom D1035 ) = ( ( R4 * ) /\ D958 )) by L1350 , RELAT_1:61;
let R7 being set;
assume L1450: R7 in ( dom D1034 );
L1451: R7 in ( ( R4 * ) /\ D947 ) by L1450 , L1350 , RELAT_1:61;
reconsider D1036 = R7 as  termal (string of R39) by L1451;
set D1037 = ( Depth D1036 );
reconsider D1038 = D1037 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D1039 = D1036 as D1037 -termal (string of R39) by FOMODEL1:def 40;
L1452: (D1039 in ( D945 . D1037 ) & R7 in ( R4 * )) by L1450 , FOMODEL1:def 33;
L1453: (R7 in ( ( R4 * ) /\ ( D945 . D1037 ) ) & ( D945 . D1038 ) c= D947 & ( D956 . D1038 ) c= D958) by L1452 , FOMODEL1:2 , XBOOLE_0:def 4;
reconsider D1040 = ( ( R4 * ) /\ ( D945 . D1037 ) ) as non  empty (Subset of D947) by L1453 , XBOOLE_1:1;
reconsider D1041 = ( ( R4 * ) /\ ( D956 . D1037 ) ) as (Subset of D958) by L1453 , XBOOLE_1:1;
reconsider D1042 = D1036 as (Element of D1040) by L1452 , XBOOLE_0:def 4;
set D1043 = ( D967 | D1040 );
set D1044 = ( D968 | D1041 );
L1454: (( dom ( D967 | D1040 ) ) = D1040 & ( dom ( D968 | D1041 ) ) = D1041) by PARTFUN1:def 2;
L1455: (R7 in ( dom D1043 ) & D1043 c= D1044) by L1447 , L1453 , PARTFUN1:def 2;
L1456: (R7 in ( dom D1044 ) & ( D1043 . R7 ) = ( D1044 . R7 )) by L1455 , FOMODEL0:51;
L1457: (R7 in ( ( R4 * ) /\ D958 ) & R7 in D1041) by L1456 , L1454 , XBOOLE_0:def 4;
thus L1458: R7 in ( dom D1035 ) by L1457 , L1350 , RELAT_1:61;
thus L1459: ( D1034 . R7 ) = ( D967 . D1042 ) by L1450 , FUNCT_1:47
.= ( D1043 . D1042 ) by L1454 , FUNCT_1:47
.= ( D968 . D1042 ) by L1456 , FUNCT_1:49
.= ( D1035 . R7 ) by L1457 , L1449 , FUNCT_1:47;
end;
thus L1460: thesis by L1448 , FOMODEL0:51;
end;
theorem
L1461: (for R4 being set holds (for R12 being non  empty set holds (for R39 being Language holds (for R40 being Language holds (for B197 being (Element of ( R12 -InterpretersOf R39 )) holds (for B198 being (Element of ( R12 -InterpretersOf R40 )) holds ((( B197 | R4 ) = ( B198 | R4 ) & ( (the adicity of R39) | R4 ) = ( (the adicity of R40) | R4 )) implies ( ( B197 -TermEval ) | ( R4 * ) ) = ( ( B198 -TermEval ) | ( R4 * ) ))))))))
proof
let R4 being set;
let R12 being non  empty set;
let R39 being Language;
let R40 being Language;
set D1045 = ( R12 -InterpretersOf R39 );
set D1046 = ( R12 -InterpretersOf R40 );
let C389 being (Element of D1045);
let C390 being (Element of D1046);
set D1047 = ( C389 -TermEval );
set D1048 = ( C390 -TermEval );
set D1049 = ( R4 * );
set D1050 = ( D1047 | D1049 );
set D1051 = ( D1048 | D1049 );
set D1052 = (the adicity of R39);
set D1053 = (the adicity of R40);
assume L1462: (( C389 | R4 ) = ( C390 | R4 ) & ( D1052 | R4 ) = ( D1053 | R4 ));
L1463: (D1050 c= D1051 & D1051 c= D1050) by L1462 , L1347;
thus L1464: thesis by L1463 , XBOOLE_0:def 10;
end;
L1465: (for R12 being non  empty set holds (for R39 being Language holds (for R40 being Language holds (for B199 being  0wff (string of R39) holds (for B200 being (Element of ( R12 -InterpretersOf R39 )) holds (for B201 being (Element of ( R12 -InterpretersOf R40 )) holds ((( B200 | ( ( rng B199 ) /\ ( OwnSymbolsOf R39 ) ) ) = ( B201 | ( ( rng B199 ) /\ ( OwnSymbolsOf R39 ) ) ) & ( (the adicity of R39) | ( ( rng B199 ) /\ ( OwnSymbolsOf R39 ) ) ) = ( (the adicity of R40) | ( ( rng B199 ) /\ ( OwnSymbolsOf R39 ) ) ) & ( TheEqSymbOf R39 ) = ( TheEqSymbOf R40 )) implies (ex B202 being  0wff (string of R40) st (B202 = B199 & ( B201 -AtomicEval B202 ) = ( B200 -AtomicEval B199 ))))))))))
proof
let R12 being non  empty set;
let R39 being Language;
let R40 being Language;
set D1054 = ( R12 -InterpretersOf R39 );
set D1055 = ( R12 -InterpretersOf R40 );
set D1056 = (the adicity of R40);
set D1057 = ( R40 -firstChar );
set D1058 = ( TheEqSymbOf R39 );
set D1059 = ( TheEqSymbOf R40 );
set D1060 = ( AllTermsOf R39 );
set D1061 = ( AllTermsOf R40 );
set D1062 = ( OwnSymbolsOf R39 );
set D1063 = ( OwnSymbolsOf R40 );
set D1064 = ( R40 -multiCat );
set D1065 = ( R39 -firstChar );
set D1066 = ( TermSymbolsOf R39 );
set D1067 = ( TermSymbolsOf R40 );
set D1068 = (the adicity of R39);
set D1069 = ( R39 -multiCat );
set D1070 = ( AtomicFormulaSymbolsOf R39 );
set D1071 = ( AtomicFormulaSymbolsOf R40 );
set D1072 = ( R12 -deltaInterpreter );
set D1073 = ( RelSymbolsOf R39 );
reconsider D1074 = ( TermSymbolsOf R39 ) as non  empty (Subset of D1062) by FOMODEL1:1;
reconsider D1075 = ( TermSymbolsOf R40 ) as non  empty (Subset of D1063) by FOMODEL1:1;
let C391 being  0wff (string of R39);
let C392 being (Element of D1054);
let C393 being (Element of D1055);
set D1076 = ( C392 -TermEval );
set D1077 = ( C393 -TermEval );
set D1078 = ( ( rng C391 ) /\ D1062 );
assume L1466: (( C392 | D1078 ) = ( C393 | D1078 ) & ( D1068 | D1078 ) = ( D1056 | D1078 ) & D1058 = D1059);
L1467: ( D1076 | ( D1078 * ) ) = ( D1077 | ( D1078 * ) ) by L1466 , L1461;
L1468: ( dom ( D1076 | ( D1078 * ) ) ) = ( ( D1078 * ) /\ ( dom D1077 ) ) by L1467 , RELAT_1:61
.= ( ( D1078 * ) /\ D1061 ) by FUNCT_2:def 1;
L1469: ( ( D1078 * ) /\ D1061 ) = ( ( D1078 * ) /\ ( dom D1076 ) ) by L1468 , RELAT_1:61
.= ( ( D1078 * ) /\ D1060 ) by FUNCT_2:def 1;
reconsider D1079 = ( D1065 . C391 ) as  relational (Element of R39);
set D1080 = ( abs ( ar D1079 ) );
set D1081 = ( D1078 \/ { D1058 } );
set D1082 = ( D1078 \/ { D1059 } );
L1470: ( { ( ( C391 null ( {} ) ) . 1 ) } \ ( ( rng C391 ) \/ ( {} ) ) ) = ( {} );
L1471: ( C391 . 1 ) in ( rng C391 ) by L1470 , ZFMISC_1:60;
L1472: D1079 in ( rng C391 ) by L1471 , FOMODEL0:6;
L1473: (D1079 in { D1058 } or (not D1079 in ( D1073 \ D1062 ))) by FOMODEL1:1;
L1474: (D1079 in { D1058 } or (not D1079 in D1073) or D1079 in D1062) by L1473 , XBOOLE_0:def 5;
L1475: (D1079 in { D1058 } or D1079 in D1078) by L1474 , L1472 , FOMODEL1:def 17 , XBOOLE_0:def 4;
L1476: D1079 in D1081 by L1475 , XBOOLE_0:def 3;
reconsider D1083 = ( SubTerms C391 ) as ( D1080 + ( 0 ) ) -element (FinSequence of D1060) by FOMODEL0:26;
L1477: D1083 is ( D1074 * ) -valued;
L1478: (D1083 in ( D1080 -tuples_on ( D1062 * ) ) & D1083 in ( D1080 -tuples_on ( ( rng C391 ) * ) )) by L1477 , FOMODEL0:16;
L1479: D1083 in ( ( D1080 -tuples_on ( ( rng C391 ) * ) ) /\ ( D1080 -tuples_on ( D1062 * ) ) ) by L1478 , XBOOLE_0:def 4;
L1480: D1083 in ( D1080 -tuples_on ( ( ( rng C391 ) * ) /\ ( D1062 * ) ) ) by L1479 , FOMODEL0:3;
L1481: D1083 in ( D1080 -tuples_on ( D1078 * ) ) by L1480 , FOMODEL0:55;
L1482: (D1083 is ( D1078 * ) -valued & ( rng D1083 ) c= D1060) by L1481 , FOMODEL0:12 , RELAT_1:def 19;
L1483: (( rng D1083 ) c= ( D1078 * ) & ( rng D1083 ) c= D1060) by L1482 , RELAT_1:def 19;
L1484: ( rng D1083 ) c= ( ( D1078 * ) /\ D1060 ) by L1483 , XBOOLE_1:19;
L1485: ( rng D1083 ) c= ( ( D1078 * ) /\ D1061 ) by L1483 , L1469 , XBOOLE_1:19;
reconsider D1084 = ( ( D1078 * ) /\ D1061 ) as non  empty (Subset of D1061) by L1485;
reconsider D1085 = ( ( D1078 * ) /\ D1060 ) as non  empty (Subset of D1060) by L1484;
L1486: D1083 is D1080 -element D1084 -valued D1080 -element D1084 -valued D1080 -element D1084 -valued D1080 -element D1084 -valued FinSequence by L1485 , RELAT_1:def 19;
reconsider D1086 = D1083 as D1080 -element (FinSequence of D1084) by L1486 , FOMODEL0:26;
L1487: D1086 is (Element of ( D1084 * )) by FINSEQ_1:def 11;
reconsider D1087 = D1086 as D1080 -element (Element of ( D1061 * )) by L1487;
reconsider D1088 = D1058 as (Element of D1070) by FOMODEL1:def 20;
reconsider D1089 = { D1088 } as non  empty (Subset of D1070);
reconsider D1090 = D1059 as (Element of D1071) by FOMODEL1:def 20;
reconsider D1091 = { D1090 } as non  empty (Subset of D1071);
set D1092 = ( D1078 \/ D1089 );
set D1093 = ( D1078 \/ D1091 );
set D1094 = ( D1068 | D1089 );
set D1095 = ( D1056 | D1091 );
L1488: (( dom D1094 ) = D1089 & ( dom D1095 ) = D1091) by PARTFUN1:def 2;
L1489:
now
let R7 being set;
assume L1490: R7 in ( dom D1094 );
L1491: (R7 = D1058 & ( D1094 . R7 ) = ( D1068 . R7 )) by L1490 , FUNCT_1:47 , TARSKI:def 1;
L1492: (( D1094 . R7 ) = ( - 2 ) & ( D1056 . R7 ) = ( - 2 )) by L1491 , L1466 , FOMODEL1:def 23;
thus L1493: ( D1094 . R7 ) = ( D1095 . R7 ) by L1492 , L1488 , L1466 , L1490 , FUNCT_1:47;
end;
L1494: D1094 = D1095 by L1489 , L1488 , L1466 , FUNCT_1:2;
L1495: ( ( D1056 | D1078 ) +* D1095 ) = ( D1068 | D1092 ) by L1494 , L1466 , FUNCT_4:78;
L1496: (D1092 = D1093 & ( D1068 | D1092 ) = ( D1056 | D1093 )) by L1495 , L1466 , FUNCT_4:78;
L1497: ( ar D1079 ) = ( ( D1068 | D1092 ) . D1079 ) by L1476 , FUNCT_1:49
.= ( D1056 . D1079 ) by L1476 , L1496 , FUNCT_1:49;
L1498: D1079 in ( dom D1056 ) by L1497 , FUNCT_1:def 2;
L1499: D1079 in D1071 by L1498;
reconsider D1096 = D1079 as  ofAtomicFormula (Element of R40) by L1499 , FOMODEL1:def 20;
L1500: ( ar D1079 ) = ( ar D1096 ) by L1497;
reconsider D1097 = D1096 as  relational (Element of R40) by L1500;
reconsider D1098 = ( D1097 -compound D1087 ) as  0wff (string of R40) by L1500;
take D1098;
thus L1501: C391 = ( <* D1079 *> ^ ( D1069 . D1083 ) ) by FOMODEL1:def 38
.= D1098 by FOMODEL0:52;
L1502: ( D1057 . D1098 ) = ( D1098 . 1 ) by FOMODEL0:6
.= D1097 by FINSEQ_1:41;
reconsider D1099 = D1087 as ( abs ( ar ( D1057 . D1098 ) ) ) -element (Element of ( D1061 * )) by L1502 , L1497;
L1503: D1099 = ( SubTerms D1098 ) by L1502 , FOMODEL1:def 38;
L1504: ( D1076 * D1083 ) = ( ( D1076 | ( D1078 * ) ) * D1083 ) by L1483 , L1469 , L1468 , RELAT_1:165 , XBOOLE_1:19
.= ( D1077 * ( SubTerms D1098 ) ) by L1503 , L1467 , L1483 , L1469 , L1468 , RELAT_1:165 , XBOOLE_1:19;
per cases ;
suppose L1505: D1079 <> D1058;

L1506: D1079 in D1078 by L1505 , L1474 , L1472 , FOMODEL1:def 17 , TARSKI:def 1 , XBOOLE_0:def 4;
L1507: ( C392 . D1079 ) = ( ( C392 | D1078 ) . D1079 ) by L1506 , FUNCT_1:49
.= ( C393 . D1097 ) by L1466 , L1506 , FUNCT_1:49;
L1508: (( C392 -AtomicEval C391 ) = ( ( C392 . D1079 ) . ( D1076 * D1083 ) ) & ( C393 -AtomicEval D1098 ) = ( ( C392 . D1079 ) . ( D1077 * ( SubTerms D1098 ) ) )) by L1507 , L1466 , L1505 , L1502 , FOMODEL2:14;
thus L1509: ( C392 -AtomicEval C391 ) = ( C393 -AtomicEval D1098 ) by L1508 , L1504;
end;
suppose L1510: D1079 = D1058;

L1511: (( C392 -AtomicEval C391 ) = ( D1072 . ( D1076 * D1083 ) ) & ( C393 -AtomicEval D1098 ) = ( D1072 . ( D1077 * ( SubTerms D1098 ) ) )) by L1510 , L1466 , L1502 , FOMODEL2:14;
thus L1512: ( C392 -AtomicEval C391 ) = ( C393 -AtomicEval D1098 ) by L1511 , L1504;
end;
end;
theorem
L1514: (for R12 being non  empty set holds (for R39 being Language holds (for R40 being Language holds ((( TheNorSymbOf R39 ) = ( TheNorSymbOf R40 ) & ( TheEqSymbOf R39 ) = ( TheEqSymbOf R40 ) & ( (the adicity of R39) | ( OwnSymbolsOf R39 ) ) = ( (the adicity of R40) | ( OwnSymbolsOf R39 ) )) implies (for B203 being (Element of ( R12 -InterpretersOf R39 )) holds (for B204 being (Element of ( R12 -InterpretersOf R40 )) holds (for B205 being  wff (string of R39) holds (( B203 | ( OwnSymbolsOf R39 ) ) = ( B204 | ( OwnSymbolsOf R39 ) ) implies (ex B206 being  wff (string of R40) st (B206 = B205 & ( B204 -TruthEval B206 ) = ( B203 -TruthEval B205 )))))))))))
proof
let R12 being non  empty set;
let R39 being Language;
let R40 being Language;
set D1100 = ( R12 -InterpretersOf R39 );
set D1101 = ( R12 -InterpretersOf R40 );
set D1102 = ( TheNorSymbOf R39 );
set D1103 = ( TheNorSymbOf R40 );
set D1104 = ( R39 -firstChar );
set D1105 = ( R40 -firstChar );
set D1106 = (the adicity of R39);
set D1107 = (the adicity of R40);
set D1108 = ( OwnSymbolsOf R39 );
set D1109 = ( OwnSymbolsOf R40 );
set D1110 = ( R12 -deltaInterpreter );
set D1111 = ( TheEqSymbOf R39 );
set D1112 = ( TheEqSymbOf R40 );
set D1113 = ( AtomicFormulaSymbolsOf R39 );
set D1114 = ( AtomicFormulaSymbolsOf R40 );
assume L1515: D1102 = D1103;
assume L1516: (D1111 = D1112 & ( D1106 | D1108 ) = ( D1107 | D1108 ));
defpred S18[ Nat ] means (for B207 being (Element of D1100) holds (for B208 being (Element of D1101) holds (for B209 being $1 -wff (string of R39) holds (( B207 | D1108 ) = ( B208 | D1108 ) implies (ex B210 being $1 -wff (string of R40) st (B209 = B210 & ( B207 -TruthEval B209 ) = ( B208 -TruthEval B210 )))))));
L1517: S18[ ( 0 ) ]
proof
let C394 being (Element of D1100);
let C395 being (Element of D1101);
let C396 being ( 0 ) -wff (string of R39);
set D1115 = ( C394 -TermEval );
set D1116 = ( C395 -TermEval );
set D1117 = ( rng C396 );
reconsider D1118 = ( D1117 /\ D1108 ) as (Subset of D1108);
reconsider D1119 = ( D1104 . C396 ) as  relational (Element of R39);
L1518: ( D1106 | D1118 ) = ( ( D1106 | D1108 ) | D1117 ) by RELAT_1:71
.= ( D1107 | D1118 ) by L1516 , RELAT_1:71;
assume L1519: ( C394 | D1108 ) = ( C395 | D1108 );
L1520: ( ( C395 | D1108 ) | D1117 ) = ( C394 | D1118 ) by L1519 , RELAT_1:71;
L1521: ( C394 | D1118 ) = ( C395 | D1118 ) by L1520 , RELAT_1:71;
consider C397 being  0wff (string of R40) such that L1522: (C397 = C396 & ( C395 -AtomicEval C397 ) = ( C394 -AtomicEval C396 )) by L1521 , L1518 , L1465 , L1516;
reconsider D1120 = C397 as ( 0 ) -wff (string of R40);
take D1120;
set D1121 = ( SubTerms C396 );
set D1122 = ( SubTerms D1120 );
reconsider D1123 = ( D1105 . D1120 ) as  relational (Element of R40);
thus L1523: thesis by L1522;
end;
L1524: (for R26 being Nat holds (S18[ R26 ] implies S18[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L1525: S18[ R26 ];
let C398 being (Element of D1100);
let C399 being (Element of D1101);
let C400 being ( R26 + 1 ) -wff (string of R39);
set D1124 = ( rng C400 );
assume L1526: ( C398 | D1108 ) = ( C399 | D1108 );
reconsider D1125 = ( head C400 ) as R26 -wff (string of R39);
set D1126 = ( tail C400 );
set D1127 = ( D1104 . C400 );
consider C401 being R26 -wff (string of R40) such that L1527: (D1125 = C401 & ( C398 -TruthEval D1125 ) = ( C399 -TruthEval C401 )) by L1525 , L1526;
per cases ;
suppose L1528: C400 is  exal;

reconsider D1128 = C400 as  exal ( R26 + 1 ) -wff (string of R39) by L1528;
reconsider D1129 = ( D1104 . D1128 ) as  literal (Element of R39);
L1529: D1129 in D1108 by FOMODEL1:def 19;
L1530: ( C398 . D1129 ) = ( C399 . D1129 ) by L1526 , L1529 , FUNCT_1:49;
L1531: D1129 in ( dom C399 ) by L1530 , FUNCT_1:def 2;
L1532: D1129 in D1109 by L1531;
reconsider D1130 = D1129 as  own (Element of R40) by L1532;
L1533: ( ( abs ( ar D1130 ) ) -tuples_on R12 ) = ( dom ( C399 . D1130 ) ) by PARTFUN1:def 2
.= ( ( 0 ) -tuples_on R12 ) by L1530 , FUNCT_2:def 1;
L1534: ((not D1130 is  relational) & (not D1130 is  operational)) by L1533;
reconsider D1131 = D1130 as  literal (Element of R40) by L1534;
reconsider D1132 = ( <* D1131 *> ^ C401 ) as ( R26 + 1 ) -wff  exal (string of R40);
take D1132;
L1535: C400 = ( ( <* D1129 *> ^ D1125 ) ^ ( tail D1128 ) ) by FOMODEL2:23
.= ( <* D1129 *> ^ D1125 );
thus L1536: C400 = D1132 by L1535 , L1527;
L1537: (( C398 -TruthEval D1128 ) = 1 iff ( C399 -TruthEval D1132 ) = 1)
proof
thus L1538:now
assume L1539: ( C398 -TruthEval D1128 ) = 1;
consider R16 being (Element of R12) such that L1540: ( ( (D1129 , R16) ReassignIn C398 ) -TruthEval D1125 ) = 1 by L1539 , L1535 , FOMODEL2:19;
reconsider D1133 = ( (D1129 , R16) ReassignIn C398 ) as (Element of D1100);
reconsider D1134 = ( (D1131 , R16) ReassignIn C399 ) as (Element of D1101);
L1541: ( D1133 | D1108 ) = ( ( C398 | D1108 ) +* ( ( D1129 .--> ( ( {} ) .--> R16 ) ) | D1108 ) ) by FUNCT_4:71
.= ( D1134 | D1108 ) by L1526 , FUNCT_4:71;
consider C402 being R26 -wff (string of R40) such that L1542: (C402 = D1125 & ( D1133 -TruthEval D1125 ) = ( D1134 -TruthEval C402 )) by L1541 , L1525;
thus L1543: ( C399 -TruthEval D1132 ) = 1 by L1542 , L1527 , L1540 , FOMODEL2:19;
end;
assume L1544: ( C399 -TruthEval D1132 ) = 1;
consider R18 being (Element of R12) such that L1545: ( ( (D1131 , R18) ReassignIn C399 ) -TruthEval C401 ) = 1 by L1544 , FOMODEL2:19;
reconsider D1135 = ( (D1129 , R18) ReassignIn C398 ) as (Element of D1100);
reconsider D1136 = ( (D1131 , R18) ReassignIn C399 ) as (Element of D1101);
L1546: ( D1135 | D1108 ) = ( ( C398 | D1108 ) +* ( ( D1129 .--> ( ( {} ) .--> R18 ) ) | D1108 ) ) by FUNCT_4:71
.= ( D1136 | D1108 ) by L1526 , FUNCT_4:71;
consider C403 being R26 -wff (string of R40) such that L1547: (C403 = D1125 & ( D1135 -TruthEval D1125 ) = ( D1136 -TruthEval C403 )) by L1546 , L1525;
thus L1548: ( C398 -TruthEval D1128 ) = 1 by L1535 , L1545 , L1547 , L1527 , FOMODEL2:19;
end;
L1549: (( C398 -TruthEval C400 ) = 1 iff (not ( C399 -TruthEval D1132 ) = ( 0 ))) by L1537 , FOMODEL0:39;
thus L1550: ( C398 -TruthEval C400 ) = ( C399 -TruthEval D1132 ) by L1549 , FOMODEL0:39;
end;
suppose L1551: ((not C400 is  0wff) & (not C400 is  exal));

reconsider D1137 = C400 as non  0wff non  exal ( R26 + 1 ) -wff (string of R39) by L1551;
reconsider D1138 = ( tail D1137 ) as R26 -wff (string of R39);
consider C404 being R26 -wff (string of R40) such that L1552: (D1138 = C404 & ( C398 -TruthEval D1138 ) = ( C399 -TruthEval C404 )) by L1525 , L1526;
reconsider D1139 = ( ( <* D1103 *> ^ C401 ) ^ C404 ) as ( R26 + 1 ) -wff non  exal non  0wff (string of R40);
take D1139;
L1553: (( ( D1104 . D1137 ) \+\ D1102 ) = ( {} ) & ( ( D1105 . D1139 ) \+\ D1103 ) = ( {} ));
L1554: (( D1104 . C400 ) = D1102 & ( D1105 . D1139 ) = D1103 & D1137 = ( ( <* ( D1104 . D1137 ) *> ^ D1125 ) ^ D1138 ) & C401 = ( head D1139 ) & C404 = ( tail D1139 )) by L1553 , FOMODEL0:29 , FOMODEL2:23;
thus L1555: C400 = D1139 by L1554 , L1552 , L1527 , L1515;
set D1140 = ( C398 -TruthEval D1125 );
set D1141 = ( C398 -TruthEval D1138 );
set D1142 = ( C399 -TruthEval C401 );
set D1143 = ( C399 -TruthEval C404 );
set D1144 = ( C398 -TruthEval D1137 );
set D1145 = ( C399 -TruthEval D1139 );
L1556: (( D1144 \+\ ( ( C398 -TruthEval ( head D1137 ) ) 'nor' ( C398 -TruthEval ( tail D1137 ) ) ) ) = ( {} ) & ( D1145 \+\ ( ( C399 -TruthEval ( head D1139 ) ) 'nor' ( C399 -TruthEval ( tail D1139 ) ) ) ) = ( {} ));
L1557: (D1144 = ( D1140 'nor' D1141 ) & D1145 = ( D1142 'nor' D1143 )) by L1556 , L1554 , FOMODEL0:29;
thus L1558: thesis by L1557 , L1527 , L1552;
end;
suppose L1559: C400 is  0wff;

consider C405 being ( 0 ) -wff (string of R40) such that L1560: (C400 = C405 & ( C398 -TruthEval C400 ) = ( C399 -TruthEval C405 )) by L1559 , L1517 , L1526;
L1561: C405 is ( ( 0 ) + ( ( 0 ) * ( R26 + 1 ) ) ) -wff;
L1562: C405 is ( ( 0 ) + ( R26 + 1 ) ) -wff by L1561;
reconsider D1146 = C405 as ( R26 + 1 ) -wff (string of R40) by L1562;
take D1146;
thus L1563: thesis by L1560;
end;
end;
L1565: (for R26 being Nat holds S18[ R26 ]) from NAT_1:sch 2(L1517 , L1524);
let C406 being (Element of D1100);
let C407 being (Element of D1101);
let C408 being  wff (string of R39);
set D1147 = ( Depth C408 );
reconsider D1148 = ( C408 null ( 0 ) ) as ( D1147 + ( 0 ) ) -wff (string of R39);
assume L1566: ( C406 | D1108 ) = ( C407 | D1108 );
L1567: (ex B211 being D1147 -wff (string of R40) st (B211 = D1148 & ( C407 -TruthEval B211 ) = ( C406 -TruthEval D1148 ))) by L1566 , L1565;
thus L1568: thesis by L1567;
end;
theorem
L1569: (for R12 being non  empty set holds (for R38 being Language holds (for R59 being  wff (string of R38) holds (for B212 , B213 being (Element of ( R12 -InterpretersOf R38 )) holds (( B212 | ( ( rng R59 ) /\ ( OwnSymbolsOf R38 ) ) ) = ( B213 | ( ( rng R59 ) /\ ( OwnSymbolsOf R38 ) ) ) implies ( B212 -TruthEval R59 ) = ( B213 -TruthEval R59 ))))))
proof
let R12 being non  empty set;
let R38 being Language;
let R59 being  wff (string of R38);
set D1149 = ( OwnSymbolsOf R38 );
set D1150 = ( R12 -InterpretersOf R38 );
set D1151 = (the adicity of R38);
set D1152 = ( TheEqSymbOf R38 );
set D1153 = ( R38 -firstChar );
set D1154 = ( R38 -multiCat );
defpred S19[ Nat ] means (for B214 , B215 being (Element of D1150) holds (for B216 being $1 -wff (string of R38) holds (( B214 | ( ( rng B216 ) /\ D1149 ) ) = ( B215 | ( ( rng B216 ) /\ D1149 ) ) implies ( B214 -TruthEval B216 ) = ( B215 -TruthEval B216 ))));
L1570: S19[ ( 0 ) ]
proof
let C409 , C410 being (Element of D1150);
let C411 being ( 0 ) -wff (string of R38);
reconsider D1155 = C411 as  0wff (string of R38);
assume L1571: ( C409 | ( ( rng C411 ) /\ D1149 ) ) = ( C410 | ( ( rng C411 ) /\ D1149 ) );
L1572: (( C409 | ( ( rng D1155 ) /\ D1149 ) ) = ( C410 | ( ( rng D1155 ) /\ D1149 ) ) & ( D1151 | ( ( rng D1155 ) /\ D1149 ) ) = ( D1151 | ( ( rng D1155 ) /\ D1149 ) ) & D1152 = D1152) by L1571;
consider C412 being  0wff (string of R38) such that L1573: (C412 = D1155 & ( C410 -AtomicEval C412 ) = ( C409 -AtomicEval D1155 )) by L1572 , L1465;
thus L1574: thesis by L1573;
end;
L1575: (for R26 being Nat holds (S19[ R26 ] implies S19[ ( R26 + 1 ) ]))
proof
let R26 being Nat;
assume L1576: S19[ R26 ];
let C413 , C414 being (Element of D1150);
let C415 being ( R26 + 1 ) -wff (string of R38);
assume L1577: ( C413 | ( ( rng C415 ) /\ D1149 ) ) = ( C414 | ( ( rng C415 ) /\ D1149 ) );
per cases ;
suppose L1578: ((not C415 is  0wff) & (not C415 is  exal));

reconsider D1156 = C415 as non  0wff non  exal ( R26 + 1 ) -wff (string of R38) by L1578;
set D1157 = ( ( rng D1156 ) /\ D1149 );
set D1158 = ( D1153 . D1156 );
reconsider D1159 = ( head D1156 ) , D1160 = ( tail D1156 ) as R26 -wff (string of R38);
L1579: D1156 = ( ( <* D1158 *> ^ D1159 ) ^ D1160 ) by FOMODEL2:23
.= ( <* D1158 *> ^ ( D1159 ^ D1160 ) ) by FINSEQ_1:32;
L1580: (( rng ( D1159 ^ D1160 ) ) c= ( rng D1156 ) & ( rng D1160 ) c= ( rng ( D1159 ^ D1160 ) ) & ( rng D1159 ) c= ( rng ( D1159 ^ D1160 ) )) by L1579 , FINSEQ_1:29 , FINSEQ_1:30;
L1581: (( rng D1159 ) c= ( rng D1156 ) & ( rng D1160 ) c= ( rng D1156 )) by L1580 , XBOOLE_1:1;
reconsider D1161 = ( ( rng D1159 ) /\ D1149 ) , D1162 = ( ( rng D1160 ) /\ D1149 ) as (Subset of D1157) by L1581 , XBOOLE_1:26;
set D1163 = ( C413 -TruthEval D1156 );
set D1164 = ( C414 -TruthEval D1156 );
set D1165 = ( C413 -TruthEval D1159 );
set D1166 = ( C414 -TruthEval D1159 );
set D1167 = ( C413 -TruthEval D1160 );
set D1168 = ( C414 -TruthEval D1160 );
L1582: ( C413 | D1161 ) = ( C413 | ( D1161 null D1157 ) )
.= ( ( C413 | D1157 ) | D1161 ) by RELAT_1:71
.= ( C414 | ( D1161 null D1157 ) ) by L1577 , RELAT_1:71;
L1583: ( C413 | D1162 ) = ( C413 | ( D1162 null D1157 ) )
.= ( ( C413 | D1157 ) | D1162 ) by RELAT_1:71
.= ( C414 | ( D1162 null D1157 ) ) by L1577 , RELAT_1:71;
L1584: D1167 = D1168 by L1583 , L1576;
L1585: (( D1163 \+\ ( D1165 'nor' D1167 ) ) = ( {} ) & ( D1164 \+\ ( D1166 'nor' D1168 ) ) = ( {} ));
L1586: (D1163 = ( D1165 'nor' D1167 ) & D1164 = ( D1166 'nor' D1168 )) by L1585 , FOMODEL0:29;
thus L1587: thesis by L1586 , L1576 , L1582 , L1584;
end;
suppose L1588: (C415 is  exal & (not C415 is  0wff));

reconsider D1169 = C415 as  exal  wff (string of R38) by L1588;
set D1170 = ( D1153 . D1169 );
reconsider D1171 = ( head D1169 ) as R26 -wff (string of R38);
L1589: D1169 = ( ( <* D1170 *> ^ D1171 ) ^ ( tail D1169 ) ) by FOMODEL2:23
.= ( <* D1170 *> ^ D1171 );
reconsider D1172 = ( rng D1171 ) as (Subset of ( rng D1169 )) by L1589 , FINSEQ_1:30;
L1590:
now
thus L1591:now
assume L1592: ( C413 -TruthEval D1169 ) = 1;
consider R16 being (Element of R12) such that L1593: ( ( (D1170 , R16) ReassignIn C413 ) -TruthEval D1171 ) = 1 by L1592 , L1589 , FOMODEL2:19;
set D1173 = ( D1170 .--> ( ( {} ) .--> R16 ) );
reconsider D1174 = ( (D1170 , R16) ReassignIn C413 ) , D1175 = ( (D1170 , R16) ReassignIn C414 ) as (Element of D1150);
L1594: ( D1174 | ( ( rng D1171 ) /\ D1149 ) ) = ( ( C413 | ( ( D1172 null ( rng D1169 ) ) /\ D1149 ) ) +* ( D1173 | ( D1172 /\ D1149 ) ) ) by FUNCT_4:71
.= ( ( C413 | ( D1172 /\ ( ( rng D1169 ) /\ D1149 ) ) ) +* ( D1173 | ( D1172 /\ D1149 ) ) ) by XBOOLE_1:16
.= ( ( ( C413 | ( ( rng D1169 ) /\ D1149 ) ) | D1172 ) +* ( D1173 | ( D1172 /\ D1149 ) ) ) by RELAT_1:71
.= ( ( C414 | ( ( ( rng D1169 ) /\ D1149 ) /\ D1172 ) ) +* ( D1173 | ( D1172 /\ D1149 ) ) ) by L1577 , RELAT_1:71
.= ( ( C414 | ( ( ( rng D1169 ) /\ D1172 ) /\ D1149 ) ) +* ( D1173 | ( D1172 /\ D1149 ) ) ) by XBOOLE_1:16
.= ( D1175 | ( ( rng D1171 ) /\ D1149 ) ) by FUNCT_4:71;
L1595: ( D1175 -TruthEval D1171 ) = 1 by L1594 , L1593 , L1576;
thus L1596: ( C414 -TruthEval D1169 ) = 1 by L1595 , L1589 , FOMODEL2:19;
end;
assume L1597: ( C414 -TruthEval D1169 ) = 1;
consider R16 being (Element of R12) such that L1598: ( ( (D1170 , R16) ReassignIn C414 ) -TruthEval D1171 ) = 1 by L1597 , L1589 , FOMODEL2:19;
set D1176 = ( D1170 .--> ( ( {} ) .--> R16 ) );
reconsider D1177 = ( (D1170 , R16) ReassignIn C413 ) , D1178 = ( (D1170 , R16) ReassignIn C414 ) as (Element of D1150);
L1599: ( D1177 | ( ( rng D1171 ) /\ D1149 ) ) = ( ( C413 | ( ( D1172 null ( rng D1169 ) ) /\ D1149 ) ) +* ( D1176 | ( D1172 /\ D1149 ) ) ) by FUNCT_4:71
.= ( ( C413 | ( D1172 /\ ( ( rng D1169 ) /\ D1149 ) ) ) +* ( D1176 | ( D1172 /\ D1149 ) ) ) by XBOOLE_1:16
.= ( ( ( C413 | ( ( rng D1169 ) /\ D1149 ) ) | D1172 ) +* ( D1176 | ( D1172 /\ D1149 ) ) ) by RELAT_1:71
.= ( ( C414 | ( ( ( rng D1169 ) /\ D1149 ) /\ D1172 ) ) +* ( D1176 | ( D1172 /\ D1149 ) ) ) by L1577 , RELAT_1:71
.= ( ( C414 | ( ( ( rng D1169 ) /\ D1172 ) /\ D1149 ) ) +* ( D1176 | ( D1172 /\ D1149 ) ) ) by XBOOLE_1:16
.= ( D1178 | ( ( rng D1171 ) /\ D1149 ) ) by FUNCT_4:71;
L1600: ( D1177 -TruthEval D1171 ) = 1 by L1599 , L1598 , L1576;
thus L1601: ( C413 -TruthEval D1169 ) = 1 by L1600 , L1589 , FOMODEL2:19;
end;
L1602: (( C413 -TruthEval D1169 ) = 1 iff (not ( C414 -TruthEval D1169 ) = ( 0 ))) by L1590 , FOMODEL0:39;
thus L1603: thesis by L1602 , FOMODEL0:39;
end;
suppose L1604: C415 is  0wff;

thus L1605: thesis by L1604 , L1570 , L1577;
end;
end;
L1607: (for R26 being Nat holds S19[ R26 ]) from NAT_1:sch 2(L1570 , L1575);
let C416 , C417 being (Element of D1150);
set D1179 = ( Depth R59 );
L1608: ( R59 null ( 0 ) ) is ( D1179 + ( 0 ) ) -wff;
reconsider D1180 = R59 as D1179 -wff (string of R38) by L1608;
assume L1609: ( C416 | ( ( rng R59 ) /\ D1149 ) ) = ( C417 | ( ( rng R59 ) /\ D1149 ) );
L1610: ( C416 | ( ( rng D1180 ) /\ D1149 ) ) = ( C417 | ( ( rng D1180 ) /\ D1149 ) ) by L1609;
thus L1611: thesis by L1610 , L1607;
end;
theorem
L1612: (for R4 being set holds (for R12 being non  empty set holds (for R16 being (Element of R12) holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for B217 being (Element of ( R12 -InterpretersOf R38 )) holds ((R44 is R4 -absent & R4 is B217 -satisfied) implies R4 is ( (R44 , R16) ReassignIn B217 ) -satisfied)))))))
proof
let R4 being set;
let R12 being non  empty set;
let R16 being (Element of R12);
let R38 being Language;
let R44 being  literal (Element of R38);
set D1181 = ( R12 -InterpretersOf R38 );
let C418 being (Element of D1181);
set D1182 = ( OwnSymbolsOf R38 );
set D1183 = ( (R44 , R16) ReassignIn C418 );
set D1184 = ( R44 .--> ( ( {} ) .--> R16 ) );
assume L1613: (R44 is R4 -absent & R4 is C418 -satisfied);
L1614:
now
let R59 being  wff (string of R38);
reconsider D1185 = ( ( rng R59 ) /\ D1182 ) as (Subset of ( rng R59 ));
assume L1615: R59 in R4;
reconsider D1186 = { R59 } as (Subset of R4) by L1615 , ZFMISC_1:31;
L1616: ( C418 -TruthEval R59 ) = 1 by L1613 , L1615 , FOMODEL2:def 42;
L1617: R44 is ( R4 /\ D1186 ) -absent by L1613;
L1618: (not R44 in D1185) by L1617 , FOMODEL2:28;
L1619: { R44 } misses D1185 by L1618 , ZFMISC_1:50;
L1620: ( dom D1184 ) misses D1185 by L1619 , FUNCOP_1:13;
L1621: ( ( C418 | D1185 ) +* ( D1184 | D1185 ) ) = ( ( C418 | D1185 ) +* ( {} ) ) by L1620 , RELAT_1:66;
L1622: ( D1183 | D1185 ) = ( C418 | D1185 ) by L1621 , FUNCT_4:71;
thus L1623: ( D1183 -TruthEval R59 ) = 1 by L1622 , L1616 , L1569;
end;
thus L1624: thesis by L1614 , FOMODEL2:def 42;
end;
theorem
L1625: (for R12 being non  empty set holds (for R16 being (Element of R12) holds (for R38 being Language holds (for R44 being  literal (Element of R38) holds (for B218 being (Equivalence_Relation of R12) holds (for B219 being B218 -respecting (Element of ( R12 -InterpretersOf R38 )) holds ( (R44 , ( ( B218 -class ) . R16 )) ReassignIn ( B219 quotient B218 ) ) = ( ( (R44 , R16) ReassignIn B219 ) quotient B218 )))))))
proof
let R12 being non  empty set;
let R16 being (Element of R12);
let R38 being Language;
let R44 being  literal (Element of R38);
set D1187 = ( R12 -InterpretersOf R38 );
let C419 being (Equivalence_Relation of R12);
let C420 being C419 -respecting (Element of D1187);
set D1188 = R16;
set D1189 = ( OwnSymbolsOf R38 );
set D1190 = ( Class C419 );
set D1191 = ( D1190 -InterpretersOf R38 );
reconsider D1192 = ( ( C419 -class ) . D1188 ) as (Element of D1190);
reconsider D1193 = ( C420 quotient C419 ) as (Element of D1191);
reconsider D1194 = ( (R44 , D1188) ReassignIn C420 ) as (Element of D1187);
reconsider D1195 = ( (R44 , D1192) ReassignIn (D1193 qua (Element of D1191)) ) as (Element of D1191);
reconsider D1196 = ( D1194 quotient C419 ) as Function;
L1626: (( dom D1195 ) = D1189 & ( dom D1196 ) = D1189) by L461 , PARTFUN1:def 2;
set D1197 = ( (D1194 qua (Element of D1187)) quotient C419 );
set D1198 = ( R44 .--> ( { ( {} ) } --> D1188 ) );
set D1199 = ( { ( {} ) } --> D1188 );
set D1200 = ( R44 .--> ( { ( {} ) } --> D1192 ) );
reconsider D1201 = ( abs ( ar R44 ) ) as Nat;
L1627: ({ ( {} ) } = ( ( 0 ) -tuples_on R12 ) & ( id { ( {} ) } ) is (Equivalence_Relation of { ( {} ) })) by FOMODEL0:10;
reconsider D1202 = ( id { ( {} ) } ) as (Equivalence_Relation of ( ( 0 ) -tuples_on R12 )) by L1627;
set D1203 = ( D1201 -placesOf C419 );
set D1204 = ( D1201 -tuple2Class C419 );
L1628: (( dom D1198 ) = { R44 } & ( dom D1200 ) = { R44 }) by FUNCOP_1:13;
L1629: (( dom D1198 ) = { R44 } & ( dom D1200 ) = { R44 } & R44 in ( dom D1198 ) & R44 in ( dom D1200 )) by L1628 , TARSKI:def 1;
L1630: (D1203 = D1202 & ( dom ( C419 -class ) ) = R12 & ( dom ( { ( {} ) } --> ( ( C419 -class ) . D1188 ) ) ) = { ( {} ) } & ( dom D1199 ) = { ( {} ) } & ( ( id { ( {} ) } ) \+\ ( ( {} ) .--> ( {} ) ) ) = ( {} )) by L748 , FUNCT_2:def 1;
L1631: (D1203 = D1202 & D1188 in ( dom ( C419 -class ) ) & ( {} ) in ( dom ( { ( {} ) } --> ( ( C419 -class ) . D1188 ) ) ) & ( id { ( {} ) } ) = ( ( {} ) .--> ( {} ) )) by L1630 , FOMODEL0:29 , TARSKI:def 1;
L1632: ( {} ) in ( dom D1199 ) by L1630 , TARSKI:def 1;
reconsider D1205 = D1199 as (D1202 , C419)-respecting Function by L1632 , L651;
reconsider D1206 = D1205 as (D1203 , C419)-respecting (Function of ( D1201 -tuples_on R12 ) , R12) by L1627 , L1630;
L1633:
now
let C421 being set;
assume L1634: C421 in D1189;
reconsider D1207 = C421 as  own (Element of R38) by L1634;
per cases ;
suppose L1635: C421 in ( dom D1200 );

L1636: C421 = R44 by L1635 , TARSKI:def 1;
L1637: ( D1197 . C421 ) = ( ( D1194 . R44 ) quotient C419 ) by L1636 , L473
.= ( ( D1201 -tuple2Class C419 ) * ( ( D1194 . R44 ) quotient (( D1201 -placesOf C419 ) , C419) ) ) by L424
.= ( D1204 * ( ( D1198 . R44 ) quotient (D1203 , C419) ) ) by L1629 , FUNCT_4:13
.= ( D1204 * (( D1199 quotient (D1203 , C419) ) qua Relation) ) by FUNCOP_1:72
.= ( ( D1201 -placesOf ( (( C419 -class ) qua (Relation of R12 , ( Class C419 ))) ~ ) ) * ( ( C419 -class ) * D1206 ) ) by L648
.= ( (( id { ( {} ) } ) qua Relation) * ( ( C419 -class ) * D1206 ) ) by L748
.= ( ( { ( {} ) } --> ( ( C419 -class ) . D1188 ) ) * ( { ( {} ) } --> ( {} ) ) ) by L1631 , FUNCOP_1:17
.= ( { ( {} ) } --> ( ( ( {} ) .--> ( ( C419 -class ) . D1188 ) ) . ( {} ) ) ) by L1631 , FUNCOP_1:17
.= ( { ( {} ) } --> D1192 ) by FUNCOP_1:72;
L1638: ( D1195 . C421 ) = ( D1200 . R44 ) by L1635 , L1636 , FUNCT_4:13
.= ( { ( {} ) } --> D1192 ) by FUNCOP_1:72;
thus L1639: ( D1195 . C421 ) = ( D1197 . C421 ) by L1638 , L1637;
end;
suppose L1640: (not C421 in ( dom D1200 ));

L1641: ( D1195 . C421 ) = ( D1193 . C421 ) by L1640 , FUNCT_4:11
.= ( ( C420 . D1207 ) quotient C419 ) by L473
.= ( ( D1194 . D1207 ) quotient C419 ) by L1640 , L1628 , FUNCT_4:11
.= ( D1197 . D1207 ) by L473;
thus L1642: ( D1195 . C421 ) = ( D1197 . C421 ) by L1641;
end;
end;
thus L1644: thesis by L1633 , L1626 , FUNCT_1:2;
end;
