:: Rings and Modules - Part II
::  by Michal Muzalewski
::
:: Received October 18, 1991
:: Copyright (c) 1991-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, FUNCSDOM, VECTSP_1, CLASSES2, FUNCT_5, MCART_1,
      STRUCT_0, VECTSP_2, SUPINF_2, ALGSTR_0, SUBSET_1, ARYTM_3, RLVECT_1,
      RELAT_1, MESFUNC1, FUNCT_1, MSSUBFAM, GRCAT_1, GRAPH_1, CAT_1, MIDSP_1,
      ORDINAL1, CARD_1, ARYTM_1, BINOP_1, LATTICES, FUNCT_2, ZFMISC_1, MOD_2,
      UNIALG_1;
 notations XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, BINOP_1, PARTFUN1, NUMBERS,
      FUNCT_2, FUNCT_5, STRUCT_0, ALGSTR_0, ORDINAL1, RLVECT_1, GROUP_1,
      VECTSP_1, FUNCSDOM, VECTSP_2, CLASSES2, GRCAT_1, FUNCT_3;
 constructors ENUMSET1, PARTFUN1, VECTSP_2, GRCAT_1, FUNCOP_1, ALGSTR_1,
      RELSET_1, CLASSES1, FUNCT_5;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, FUNCT_2, STRUCT_0, VECTSP_1,
      ALGSTR_1, ALGSTR_0, CLASSES2, GRCAT_1;
 requirements SUBSET, BOOLE, NUMERALS;
 definitions RLVECT_1, STRUCT_0, GRCAT_1, VECTSP_1, ALGSTR_0;
 theorems BINOP_1, CLASSES2, ENUMSET1, GRCAT_1, FUNCT_2, ORDINAL1, VECTSP_1,
      RLVECT_1, RELAT_1, GROUP_1, FUNCOP_1, FUNCT_1, STRUCT_0, ALGSTR_0;
 schemes FUNCT_2, BINOP_1;

begin
L1: (for R3 being Ring holds VectSpStr (# 1 , ( op2 ) , ( op0 ) , ( pr2 ((the carrier of R3) , 1) ) #) is  strict  strict  strict  strict (LeftMod of R3))
proof
let R3 being Ring;
set D1 = ( 0. ( Trivial-addLoopStr ) );
set D2 = VectSpStr (# 1 , ( op2 ) , ( op0 ) , ( pr2 ((the carrier of R3) , 1) ) #);
L2: (for B1 , B2 being (Element of D2) holds (for B3 , B4 being (Element of ( Trivial-addLoopStr )) holds ((B3 = B1 & B2 = B4) implies ( B1 + B2 ) = ( B3 + B4 ))));
L3: D2 is  Abelian  add-associative  right_zeroed  right_complementable
proof
thus L4: D2 is  Abelian
proof
let C1 , C2 being (Element of D2);
reconsider D3 = C1 , D4 = C2 as (Element of ( Trivial-addLoopStr ));
thus L5: ( C1 + C2 ) = ( D4 + D3 ) by L2
.= ( C2 + C1 );
end;

thus L6:now
let C3 , C4 , C5 being (Element of D2);
reconsider D5 = C3 , D6 = C4 , D7 = C5 as (Element of ( Trivial-addLoopStr ));
thus L7: ( ( C3 + C4 ) + C5 ) = ( ( D5 + D6 ) + D7 )
.= ( D5 + ( D6 + D7 ) ) by RLVECT_1:def 3
.= ( C3 + ( C4 + C5 ) );
end;
thus L8:now
let C6 being (Element of D2);
reconsider D8 = C6 as (Element of ( Trivial-addLoopStr ));
thus L9: ( C6 + ( 0. D2 ) ) = ( D8 + ( 0. ( Trivial-addLoopStr ) ) )
.= C6 by RLVECT_1:4;
end;
let C7 being (Element of D2);
reconsider D9 = C7 as (Element of ( Trivial-addLoopStr ));
consider C8 being (Element of ( Trivial-addLoopStr )) such that L10: ( D9 + C8 ) = ( 0. ( Trivial-addLoopStr ) ) by ALGSTR_0:def 11;
reconsider D10 = C8 as (Element of D2);
take D10;
thus L11: thesis by L10;
end;
L12:
now
let C9 , C10 being (Scalar of R3);
let C11 , C12 being (Vector of D2);
L13: (( ( C9 * C10 ) * C11 ) = D1 & ( ( 1. R3 ) * C11 ) = D1) by GRCAT_1:4;
L14: (( C9 * ( C11 + C12 ) ) = D1 & ( ( C9 + C10 ) * C11 ) = D1) by GRCAT_1:4;
thus L15: (( C9 * ( C11 + C12 ) ) = ( ( C9 * C11 ) + ( C9 * C12 ) ) & ( ( C9 + C10 ) * C11 ) = ( ( C9 * C11 ) + ( C10 * C11 ) ) & ( ( C9 * C10 ) * C11 ) = ( C9 * ( C10 * C11 ) ) & ( ( 1. R3 ) * C11 ) = C11) by L14 , L13 , GRCAT_1:4;
end;
thus L16: thesis by L12 , L3 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
definition
let R3 being Ring;
func TrivialLMod R3 ->  strict (LeftMod of R3) equals 
VectSpStr (# 1 , ( op2 ) , ( op0 ) , ( pr2 ((the carrier of R3) , 1) ) #);
coherence by L1;
end;
theorem
L18: (for R3 being Ring holds (for B5 being (Vector of ( TrivialLMod R3 )) holds B5 = ( 0. ( TrivialLMod R3 ) ))) by GRCAT_1:4;
definition
let C13 being non  empty multMagma;
let C14 , C15 being non  empty VectSpStr over C13;
let C16 being (Function of C14 , C15);
attr C16 is  homogeneous
means
:L19: (for B6 being (Scalar of C13) holds (for B7 being (Vector of C14) holds ( C16 . ( B6 * B7 ) ) = ( B6 * ( C16 . B7 ) )));
end;
theorem
L21: (for R3 being Ring holds (for R4 being non  empty VectSpStr over R3 holds (for R5 being non  empty VectSpStr over R3 holds (for R6 being non  empty VectSpStr over R3 holds (for B8 being (Function of R4 , R5) holds (for B9 being (Function of R5 , R6) holds ((B8 is  homogeneous & B9 is  homogeneous) implies ( B9 * B8 ) is  homogeneous)))))))
proof
let R3 being Ring;
let R4 being non  empty VectSpStr over R3;
let R5 being non  empty VectSpStr over R3;
let R6 being non  empty VectSpStr over R3;
let C17 being (Function of R4 , R5);
let C18 being (Function of R5 , R6);
assume that
L22: C17 is  homogeneous
and
L23: C18 is  homogeneous;
set D11 = ( C18 * C17 );
let C19 being (Scalar of R3);
let C20 being (Vector of R4);
thus L24: ( D11 . ( C19 * C20 ) ) = ( C18 . ( C17 . ( C19 * C20 ) ) ) by FUNCT_2:15
.= ( C18 . ( C19 * ( C17 . C20 ) ) ) by L22 , L19
.= ( C19 * ( C18 . ( C17 . C20 ) ) ) by L23 , L19
.= ( C19 * ( D11 . C20 ) ) by FUNCT_2:15;
end;
registration
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
cluster ( ZeroMap (R9 , R10) ) ->  homogeneous;
coherence
proof
let C21 being (Scalar of R8);
let C22 being (Vector of R9);
set D12 = ( ZeroMap (R9 , R10) );
L25: (( D12 . ( C21 * C22 ) ) = ( 0. R10 ) & ( D12 . C22 ) = ( 0. R10 )) by FUNCOP_1:7;
thus L26: thesis by L25 , VECTSP_1:14;
end;
end;
definition
let R8 being Ring;
struct LModMorphismStr over R8(# Dom , Cod -> (LeftMod of R8) , Fun -> (Function of the Dom , the Cod) #);
end;
definition
let R8 being Ring;
let R14 being LModMorphismStr over R8;
func dom R14 -> (LeftMod of R8) equals 
(the Dom of R14);
correctness;
func cod R14 -> (LeftMod of R8) equals 
(the Cod of R14);
correctness;
end;
definition
let R8 being Ring;
let R14 being LModMorphismStr over R8;
func fun R14 -> (Function of ( dom R14 ) , ( cod R14 )) equals 
(the Fun of R14);
coherence;
end;
theorem
L31: (for R8 being Ring holds (for R11 being (LeftMod of R8) holds (for R12 being (LeftMod of R8) holds (for R14 being LModMorphismStr over R8 holds (for B10 being (Function of R11 , R12) holds (R14 = LModMorphismStr (# R11 , R12 , B10 #) implies (( dom R14 ) = R11 & ( cod R14 ) = R12 & ( fun R14 ) = B10)))))));
definition
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
func ZERO (R9 , R10) ->  strict LModMorphismStr over R8 equals 
LModMorphismStr (# R9 , R10 , ( ZeroMap (R9 , R10) ) #);
correctness;
end;
definition
let R8 being Ring;
let C23 being LModMorphismStr over R8;
attr C23 is  LModMorphism-like
means
:L33: ( fun C23 ) is  additive  homogeneous;
end;
registration
let R8 being Ring;
cluster  strict  LModMorphism-like for LModMorphismStr over R8;
existence
proof
set D13 = the (LeftMod of R8);
set D14 = ( ZERO (D13 , D13) );
L35: ( fun D14 ) is  additive  homogeneous;
L36: D14 is  LModMorphism-like by L35 , L33;
thus L37: thesis by L36;
end;
end;
definition
let R8 being Ring;
mode LModMorphism of R8
 is  LModMorphism-like LModMorphismStr over R8;
end;
theorem
L40: (for R8 being Ring holds (for B11 being (LModMorphism of R8) holds (the Fun of B11) is  additive  homogeneous))
proof
let R8 being Ring;
let C24 being (LModMorphism of R8);
L41: (the Fun of C24) = ( fun C24 );
thus L42: thesis by L41 , L33;
end;
registration
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
cluster ( ZERO (R9 , R10) ) ->  LModMorphism-like;
coherence
proof
set D15 = ( ZERO (R9 , R10) );
L43: ( fun D15 ) is  additive  homogeneous;
thus L44: thesis by L43 , L33;
end;
end;
definition
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
mode Morphism of R9 , R10
 -> (LModMorphism of R8)
means :L46: (( dom it ) = R9 & ( cod it ) = R10);
existence
proof
take ( ZERO (R9 , R10) );
thus L47: thesis;
end;
end;
registration
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
cluster  strict for (Morphism of R9 , R10);
existence
proof
L49: (( dom ( ZERO (R9 , R10) ) ) = R9 & ( cod ( ZERO (R9 , R10) ) ) = R10);
reconsider D16 = ( ZERO (R9 , R10) ) as (Morphism of R9 , R10) by L49 , L46;
take D16;
thus L50: thesis;
end;
end;
theorem
L52: (for R8 being Ring holds (for R9 being (LeftMod of R8) holds (for R10 being (LeftMod of R8) holds (for B12 being LModMorphismStr over R8 holds ((( dom B12 ) = R9 & ( cod B12 ) = R10 & ( fun B12 ) is  additive  homogeneous) implies B12 is (Morphism of R9 , R10))))))
proof
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
let C25 being LModMorphismStr over R8;
assume that
L53: (( dom C25 ) = R9 & ( cod C25 ) = R10)
and
L54: ( fun C25 ) is  additive  homogeneous;
reconsider D17 = C25 as (LModMorphism of R8) by L54 , L33;
L55: D17 is (Morphism of R9 , R10) by L53 , L46;
thus L56: thesis by L55;
end;
theorem
L57: (for R8 being Ring holds (for R9 being (LeftMod of R8) holds (for R10 being (LeftMod of R8) holds (for B13 being (Function of R9 , R10) holds (B13 is  additive  homogeneous implies LModMorphismStr (# R9 , R10 , B13 #) is  strict  strict  strict  strict (Morphism of R9 , R10))))))
proof
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
let C26 being (Function of R9 , R10);
assume that
L58: C26 is  additive  homogeneous;
set D18 = LModMorphismStr (# R9 , R10 , C26 #);
L59: ( fun D18 ) = C26;
thus L60: thesis by L59 , L58 , L52;
end;
registration
let R8 being Ring;
let R9 being (LeftMod of R8);
cluster ( id R9 ) ->  homogeneous;
coherence
proof
set D19 = ( id R9 );
let C27 being (Scalar of R8);
let C28 being (Vector of R9);
thus L61: ( D19 . ( C27 * C28 ) ) = ( C27 * C28 ) by FUNCT_1:18
.= ( C27 * ( D19 . C28 ) ) by FUNCT_1:18;
end;
end;
definition
let R8 being Ring;
let R9 being (LeftMod of R8);
func ID R9 ->  strict (Morphism of R9 , R9) equals 
LModMorphismStr (# R9 , R9 , ( id R9 ) #);
coherence
proof
set D20 = LModMorphismStr (# R9 , R9 , ( id R9 ) #);
L63: ( fun D20 ) = ( id R9 );
thus L64: thesis by L63 , L52;
end;
end;
definition
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
redefine func ZERO (R9 , R10) ->  strict (Morphism of R9 , R10);

coherence
proof
set D21 = ( ZERO (R9 , R10) );
L66: ( fun D21 ) = ( ZeroMap (R9 , R10) );
thus L67: thesis by L66 , L52;
end;
end;
theorem
L69: (for R8 being Ring holds (for R9 being (LeftMod of R8) holds (for R10 being (LeftMod of R8) holds (for B14 being (Morphism of R9 , R10) holds (ex B15 being (Function of R9 , R10) st (( the LModMorphismStr of B14 ) = LModMorphismStr (# R9 , R10 , B15 #) & B15 is  additive  homogeneous))))))
proof
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
let C29 being (Morphism of R9 , R10);
L70: (the Cod of C29) = ( cod C29 )
.= R10 by L46;
L71: (the Dom of C29) = ( dom C29 )
.= R9 by L46;
reconsider D22 = (the Fun of C29) as (Function of R9 , R10) by L71 , L70;
take D22;
thus L72: thesis by L71 , L70 , L40;
end;
theorem
L73: (for R8 being Ring holds (for R9 being (LeftMod of R8) holds (for R10 being (LeftMod of R8) holds (for B16 being  strict (Morphism of R9 , R10) holds (ex B17 being (Function of R9 , R10) st B16 = LModMorphismStr (# R9 , R10 , B17 #))))))
proof
let R8 being Ring;
let R9 being (LeftMod of R8);
let R10 being (LeftMod of R8);
let C30 being  strict (Morphism of R9 , R10);
consider C31 being (Function of R9 , R10) such that L74: ( the LModMorphismStr of C30 ) = LModMorphismStr (# R9 , R10 , C31 #) and L75: C31 is  additive  homogeneous by L69;
take C31;
thus L76: thesis by L74;
end;
theorem
L77: (for R8 being Ring holds (for B18 being (LModMorphism of R8) holds (ex R9 being (LeftMod of R8) st (ex R10 being (LeftMod of R8) st B18 is (Morphism of R9 , R10)))))
proof
let R8 being Ring;
let C32 being (LModMorphism of R8);
take D23 = (the Dom of C32);
take D24 = (the Cod of C32);
L78: (( dom C32 ) = D23 & ( cod C32 ) = D24);
thus L79: thesis by L78 , L46;
end;
theorem
L80: (for R8 being Ring holds (for B19 being  strict (LModMorphism of R8) holds (ex B20 , B21 being (LeftMod of R8) st (ex B22 being (Function of B20 , B21) st (B19 is  strict  strict  strict  strict (Morphism of B20 , B21) & B19 = LModMorphismStr (# B20 , B21 , B22 #) & B22 is  additive  homogeneous)))))
proof
let R8 being Ring;
let C33 being  strict (LModMorphism of R8);
consider R9 being (LeftMod of R8), R10 being (LeftMod of R8) such that L81: C33 is (Morphism of R9 , R10) by L77;
reconsider D25 = C33 as (Morphism of R9 , R10) by L81;
consider C34 being (Function of R9 , R10) such that L82: (( the LModMorphismStr of D25 ) = LModMorphismStr (# R9 , R10 , C34 #) & C34 is  additive  homogeneous) by L69;
take R9;
take R10;
take C34;
thus L83: thesis by L82;
end;
theorem
L84: (for R8 being Ring holds (for B23 , B24 being (LModMorphism of R8) holds (( dom B23 ) = ( cod B24 ) implies (ex R11 being (LeftMod of R8) st (ex R12 being (LeftMod of R8) st (ex R13 being (LeftMod of R8) st (B23 is (Morphism of R12 , R13) & B24 is (Morphism of R11 , R12))))))))
proof
let R8 being Ring;
defpred S1[ (LModMorphism of R8) , (LModMorphism of R8) ] means ( dom $1 ) = ( cod $2 );
let C35 , C36 being (LModMorphism of R8);
assume that
L85: S1[ C35 , C36 ];
consider R12 being (LeftMod of R8), R13 being (LeftMod of R8) such that L86: C35 is (Morphism of R12 , R13) by L77;
L87: R12 = ( dom C35 ) by L86 , L46;
consider C37 , C38 being (LeftMod of R8) such that L88: C36 is (Morphism of C37 , C38) by L77;
L89: C38 = ( cod C36 ) by L88 , L46;
thus L90: thesis by L89 , L85 , L86 , L87 , L88;
end;
definition
let R8 being Ring;
let C39 , C40 being (LModMorphism of R8);
assume L91: ( dom C39 ) = ( cod C40 );
func C39 * C40 ->  strict (LModMorphism of R8) means 
:L92: (for B25 , B26 , B27 being (LeftMod of R8) holds (for B28 being (Function of B26 , B27) holds (for B29 being (Function of B25 , B26) holds ((( the LModMorphismStr of C39 ) = LModMorphismStr (# B26 , B27 , B28 #) & ( the LModMorphismStr of C40 ) = LModMorphismStr (# B25 , B26 , B29 #)) implies it = LModMorphismStr (# B25 , B27 , ( B28 * B29 ) #)))));
existence
proof
consider C41 , C42 , C43 being (LeftMod of R8) such that L93: C39 is (Morphism of C42 , C43) and L94: C40 is (Morphism of C41 , C42) by L91 , L84;
consider C44 being (Function of C41 , C42) such that L95: ( the LModMorphismStr of C40 ) = LModMorphismStr (# C41 , C42 , C44 #) and L96: C44 is  additive  homogeneous by L94 , L69;
consider C45 being (Function of C42 , C43) such that L97: ( the LModMorphismStr of C39 ) = LModMorphismStr (# C42 , C43 , C45 #) and L98: C45 is  additive  homogeneous by L93 , L69;
L99: ( C45 * C44 ) is  additive  homogeneous by L98 , L96 , L21;
reconsider D26 = LModMorphismStr (# C41 , C43 , ( C45 * C44 ) #) as  strict (LModMorphism of R8) by L99 , L57;
take D26;
thus L100: thesis by L97 , L95;
end;
uniqueness
proof
consider C46 , C47 being (LeftMod of R8) such that L101: C40 is (Morphism of C46 , C47) by L77;
reconsider D27 = C40 as (Morphism of C46 , C47) by L101;
consider C48 , C49 being (LeftMod of R8) such that L102: C39 is (Morphism of C48 , C49) by L77;
L103: C48 = ( dom C39 ) by L102 , L46;
reconsider D28 = D27 as (Morphism of C46 , C48) by L103 , L91 , L46;
consider C50 being (Function of C46 , C48) such that L104: ( the LModMorphismStr of D28 ) = LModMorphismStr (# C46 , C48 , C50 #) and L105: C50 is  additive  homogeneous by L69;
reconsider D29 = C39 as (Morphism of C48 , C49) by L102;
let C51 , C52 being  strict (LModMorphism of R8);
assume that
L106: (for B30 , B31 , B32 being (LeftMod of R8) holds (for B33 being (Function of B31 , B32) holds (for B34 being (Function of B30 , B31) holds ((( the LModMorphismStr of C39 ) = LModMorphismStr (# B31 , B32 , B33 #) & ( the LModMorphismStr of C40 ) = LModMorphismStr (# B30 , B31 , B34 #)) implies C51 = LModMorphismStr (# B30 , B32 , ( B33 * B34 ) #)))))
and
L107: (for B35 , B36 , B37 being (LeftMod of R8) holds (for B38 being (Function of B36 , B37) holds (for B39 being (Function of B35 , B36) holds ((( the LModMorphismStr of C39 ) = LModMorphismStr (# B36 , B37 , B38 #) & ( the LModMorphismStr of C40 ) = LModMorphismStr (# B35 , B36 , B39 #)) implies C52 = LModMorphismStr (# B35 , B37 , ( B38 * B39 ) #)))));
consider C53 being (Function of C48 , C49) such that L108: ( the LModMorphismStr of D29 ) = LModMorphismStr (# C48 , C49 , C53 #) and L109: C53 is  additive  homogeneous by L69;
thus L110: C51 = LModMorphismStr (# C46 , C49 , ( C53 * C50 ) #) by L106 , L108 , L104
.= C52 by L107 , L108 , L104;
end;
end;
theorem
L112: (for R8 being Ring holds (for R11 being (LeftMod of R8) holds (for R12 being (LeftMod of R8) holds (for R13 being (LeftMod of R8) holds (for B40 being (Morphism of R12 , R13) holds (for B41 being (Morphism of R11 , R12) holds ( B40 * B41 ) is  strict  strict  strict  strict (Morphism of R11 , R13)))))))
proof
let R8 being Ring;
let R11 being (LeftMod of R8);
let R12 being (LeftMod of R8);
let R13 being (LeftMod of R8);
let C54 being (Morphism of R12 , R13);
let C55 being (Morphism of R11 , R12);
consider C56 being (Function of R12 , R13) such that L113: ( the LModMorphismStr of C54 ) = LModMorphismStr (# R12 , R13 , C56 #) and L114: C56 is  additive  homogeneous by L69;
consider C57 being (Function of R11 , R12) such that L115: ( the LModMorphismStr of C55 ) = LModMorphismStr (# R11 , R12 , C57 #) and L116: C57 is  additive  homogeneous by L69;
L117: ( dom C54 ) = R12 by L46
.= ( cod C55 ) by L46;
L118: ( C54 * C55 ) = LModMorphismStr (# R11 , R13 , ( C56 * C57 ) #) by L117 , L113 , L115 , L92;
L119: (( dom ( C54 * C55 ) ) = R11 & ( cod ( C54 * C55 ) ) = R13) by L118;
thus L120: thesis by L119 , L46;
end;
definition
let R8 being Ring;
let R11 being (LeftMod of R8);
let R12 being (LeftMod of R8);
let R13 being (LeftMod of R8);
let C58 being (Morphism of R12 , R13);
let C59 being (Morphism of R11 , R12);
func C58 *' C59 ->  strict (Morphism of R11 , R13) equals 
( C58 * C59 );
coherence by L112;
end;
theorem
L122: (for R8 being Ring holds (for R11 being (LeftMod of R8) holds (for R12 being (LeftMod of R8) holds (for R13 being (LeftMod of R8) holds (for B42 being (Morphism of R12 , R13) holds (for B43 being (Morphism of R11 , R12) holds (for B44 being (Function of R12 , R13) holds (for B45 being (Function of R11 , R12) holds ((B42 = LModMorphismStr (# R12 , R13 , B44 #) & B43 = LModMorphismStr (# R11 , R12 , B45 #)) implies (( B42 *' B43 ) = LModMorphismStr (# R11 , R13 , ( B44 * B45 ) #) & ( B42 * B43 ) = LModMorphismStr (# R11 , R13 , ( B44 * B45 ) #)))))))))))
proof
let R8 being Ring;
let R11 being (LeftMod of R8);
let R12 being (LeftMod of R8);
let R13 being (LeftMod of R8);
let C60 being (Morphism of R12 , R13);
let C61 being (Morphism of R11 , R12);
let C62 being (Function of R12 , R13);
let C63 being (Function of R11 , R12);
assume that
L123: (C60 = LModMorphismStr (# R12 , R13 , C62 #) & C61 = LModMorphismStr (# R11 , R12 , C63 #));
L124: ( dom C60 ) = R12 by L46
.= ( cod C61 ) by L46;
thus L125: thesis by L124 , L123 , L92;
end;
theorem
L126: (for R8 being Ring holds (for B46 , B47 being  strict (LModMorphism of R8) holds (( dom B47 ) = ( cod B46 ) implies (ex B48 , B49 , B50 being (LeftMod of R8) st (ex B51 being (Function of B48 , B49) st (ex B52 being (Function of B49 , B50) st (B46 = LModMorphismStr (# B48 , B49 , B51 #) & B47 = LModMorphismStr (# B49 , B50 , B52 #) & ( B47 * B46 ) = LModMorphismStr (# B48 , B50 , ( B52 * B51 ) #))))))))
proof
let R8 being Ring;
let C64 , C65 being  strict (LModMorphism of R8);
assume that
L127: ( dom C65 ) = ( cod C64 );
set D30 = ( dom C64 );
set D31 = ( cod C64 );
set D32 = ( cod C65 );
reconsider D33 = C64 as  strict (Morphism of D30 , D31) by L46;
reconsider D34 = C65 as  strict (Morphism of D31 , D32) by L127 , L46;
consider C66 being (Function of D30 , D31) such that L128: D33 = LModMorphismStr (# D30 , D31 , C66 #);
consider C67 being (Function of D31 , D32) such that L129: D34 = LModMorphismStr (# D31 , D32 , C67 #) by L73;
take D30;
take D31;
take D32;
take C66;
take C67;
thus L130: thesis by L128 , L129 , L122;
end;
theorem
L131: (for R8 being Ring holds (for B53 , B54 being  strict (LModMorphism of R8) holds (( dom B54 ) = ( cod B53 ) implies (( dom ( B54 * B53 ) ) = ( dom B53 ) & ( cod ( B54 * B53 ) ) = ( cod B54 )))))
proof
let R8 being Ring;
let C68 , C69 being  strict (LModMorphism of R8);
assume L132: ( dom C69 ) = ( cod C68 );
L133: (ex B55 , B56 , B57 being (LeftMod of R8) st (ex B58 being (Function of B55 , B56) st (ex B59 being (Function of B56 , B57) st (C68 = LModMorphismStr (# B55 , B56 , B58 #) & C69 = LModMorphismStr (# B56 , B57 , B59 #) & ( C69 * C68 ) = LModMorphismStr (# B55 , B57 , ( B59 * B58 ) #))))) by L132 , L126;
thus L134: ( dom ( C69 * C68 ) ) = ( dom C68 ) by L133;
thus L135: thesis by L133;
end;
theorem
L136: (for R8 being Ring holds (for B60 , B61 , B62 , B63 being (LeftMod of R8) holds (for B64 being  strict (Morphism of B60 , B61) holds (for B65 being  strict (Morphism of B61 , B62) holds (for B66 being  strict (Morphism of B62 , B63) holds ( B66 * ( B65 * B64 ) ) = ( ( B66 * B65 ) * B64 ))))))
proof
let R8 being Ring;
let C70 , C71 , C72 , C73 being (LeftMod of R8);
let C74 being  strict (Morphism of C70 , C71);
let C75 being  strict (Morphism of C71 , C72);
let C76 being  strict (Morphism of C72 , C73);
consider C77 being (Function of C70 , C71) such that L137: C74 = LModMorphismStr (# C70 , C71 , C77 #) by L73;
consider C78 being (Function of C71 , C72) such that L138: C75 = LModMorphismStr (# C71 , C72 , C78 #) by L73;
consider C79 being (Function of C72 , C73) such that L139: C76 = LModMorphismStr (# C72 , C73 , C79 #) by L73;
L140: ( C76 *' C75 ) = LModMorphismStr (# C71 , C73 , ( C79 * C78 ) #) by L138 , L139 , L122;
L141: ( C75 *' C74 ) = LModMorphismStr (# C70 , C72 , ( C78 * C77 ) #) by L137 , L138 , L122;
L142: ( C76 * ( C75 * C74 ) ) = LModMorphismStr (# C70 , C73 , ( C79 * ( C78 * C77 ) ) #) by L141 , L139 , L122
.= LModMorphismStr (# C70 , C73 , ( ( C79 * C78 ) * C77 ) #) by RELAT_1:36
.= ( ( C76 * C75 ) * C74 ) by L137 , L140 , L122;
thus L143: thesis by L142;
end;
theorem
L144: (for R8 being Ring holds (for B67 , B68 , B69 being  strict (LModMorphism of R8) holds ((( dom B69 ) = ( cod B68 ) & ( dom B68 ) = ( cod B67 )) implies ( B69 * ( B68 * B67 ) ) = ( ( B69 * B68 ) * B67 ))))
proof
let R8 being Ring;
let C80 , C81 , C82 being  strict (LModMorphism of R8);
assume that
L145: ( dom C82 ) = ( cod C81 )
and
L146: ( dom C81 ) = ( cod C80 );
set D35 = ( cod C80 );
set D36 = ( cod C81 );
reconsider D37 = C82 as  strict (Morphism of D36 , ( cod C82 )) by L145 , L46;
reconsider D38 = C81 as  strict (Morphism of D35 , D36) by L146 , L46;
reconsider D39 = C80 as  strict (Morphism of ( dom C80 ) , D35) by L46;
L147: ( D37 * ( D38 * D39 ) ) = ( ( D37 * D38 ) * D39 ) by L136;
thus L148: thesis by L147;
end;
theorem
L149: (for R8 being Ring holds (for R9 being (LeftMod of R8) holds (( dom ( ID R9 ) ) = R9 & ( cod ( ID R9 ) ) = R9 & (for B70 being  strict (LModMorphism of R8) holds (( cod B70 ) = R9 implies ( ( ID R9 ) * B70 ) = B70)) & (for B71 being  strict (LModMorphism of R8) holds (( dom B71 ) = R9 implies ( B71 * ( ID R9 ) ) = B71)))))
proof
let R8 being Ring;
let R9 being (LeftMod of R8);
set D40 = ( ID R9 );
thus L150: ( dom D40 ) = R9;
thus L151: ( cod D40 ) = R9;
thus L152: (for B72 being  strict (LModMorphism of R8) holds (( cod B72 ) = R9 implies ( D40 * B72 ) = B72))
proof
let C83 being  strict (LModMorphism of R8);
assume that
L153: ( cod C83 ) = R9;
set D41 = ( dom C83 );
reconsider D42 = C83 as (Morphism of D41 , R9) by L153 , L46;
consider C84 being (Function of D41 , R9) such that L154: D42 = LModMorphismStr (# D41 , R9 , C84 #) by L73;
L155: (( dom D40 ) = R9 & ( ( id R9 ) * C84 ) = C84) by FUNCT_2:17;
thus L156: thesis by L155 , L153 , L154 , L92;
end;

thus L157: (for B73 being  strict (LModMorphism of R8) holds (( dom B73 ) = R9 implies ( B73 * ( ID R9 ) ) = B73))
proof
let C85 being  strict (LModMorphism of R8);
assume that
L158: ( dom C85 ) = R9;
set D43 = ( cod C85 );
reconsider D44 = C85 as (Morphism of R9 , D43) by L158 , L46;
consider C86 being (Function of R9 , D43) such that L159: D44 = LModMorphismStr (# R9 , D43 , C86 #) by L73;
L160: (( cod D40 ) = R9 & ( C86 * ( id R9 ) ) = C86) by FUNCT_2:17;
thus L161: thesis by L160 , L158 , L159 , L92;
end;

end;
theorem
L158: (for R7 being Universe holds (for B74 , B75 , B76 being (Element of R7) holds { B74 , B75 , B76 } is (Element of R7)))
proof
let R7 being Universe;
let C87 , C88 , C89 being (Element of R7);
L159: { C87 , C88 , C89 } = ( { C87 , C88 } \/ { C89 } ) by ENUMSET1:3;
thus L160: thesis by L159;
end;
theorem
L161: (for R7 being Universe holds (for B77 being (Element of R7) holds ( succ B77 ) is (Element of R7)))
proof
let R7 being Universe;
let C90 being (Element of R7);
L162: ( succ C90 ) = ( C90 \/ { C90 } ) by ORDINAL1:def 1;
thus L163: thesis by L162;
end;
theorem
L164: (for R7 being Universe holds (( 0 ) is (Element of R7) & 1 is (Element of R7) & 2 is (Element of R7)))
proof
let R7 being Universe;
thus L165: ( 0 ) is (Element of R7) by CLASSES2:56;
L166: (( {} ) is (Element of R7) & 1 = ( succ ( 0 ) )) by CLASSES2:56;
thus L167: 1 is (Element of R7) by L166 , L161;
L168: 2 = ( succ 1 );
thus L169: thesis by L168 , L167 , L161;
end;
L170: (ex R17 being (Element of { ( 0 ) , 1 , 2 }) st R17 = ( 0 ))
proof
reconsider D45 = ( 0 ) as (Element of { ( 0 ) , 1 , 2 }) by ENUMSET1:def 1;
take D45;
thus L171: thesis;
end;
L172: (ex R17 being (Element of { ( 0 ) , 1 , 2 }) st R17 = 1)
proof
reconsider D46 = 1 as (Element of { ( 0 ) , 1 , 2 }) by ENUMSET1:def 1;
take D46;
thus L173: thesis;
end;
L174: (ex R17 being (Element of { ( 0 ) , 1 , 2 }) st R17 = 2)
proof
reconsider D47 = 2 as (Element of { ( 0 ) , 1 , 2 }) by ENUMSET1:def 1;
take D47;
thus L175: thesis;
end;
definition
let R15 being (Element of { ( 0 ) , 1 , 2 });
func - R15 -> (Element of { ( 0 ) , 1 , 2 }) equals 
:L176: ( 0 ) if R15 = ( 0 ) , 2 if R15 = 1 , 1 if R15 = 2;
coherence by L172 , L174;
consistency;
let R16 being (Element of { ( 0 ) , 1 , 2 });
func R15 + R16 -> (Element of { ( 0 ) , 1 , 2 }) equals 
:L177: R16 if R15 = ( 0 ) , R15 if R16 = ( 0 ) , 2 if (R15 = 1 & R16 = 1) , ( 0 ) if (R15 = 1 & R16 = 2) , ( 0 ) if (R15 = 2 & R16 = 1) , 1 if (R15 = 2 & R16 = 2);
coherence by L170 , L172 , L174;
consistency;
func R15 * R16 -> (Element of { ( 0 ) , 1 , 2 }) equals 
:L178: ( 0 ) if R16 = ( 0 ) , ( 0 ) if R15 = ( 0 ) , R15 if R16 = 1 , R16 if R15 = 1 , 1 if (R15 = 2 & R16 = 2);
coherence by L172;
consistency;
end;
definition
func add3 -> (BinOp of { ( 0 ) , 1 , 2 }) means 
:L180: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds (for R16 being (Element of { ( 0 ) , 1 , 2 }) holds ( it . (R15 , R16) ) = ( R15 + R16 )));
existence
proof
deffunc H1((Element of { ( 0 ) , 1 , 2 }) , (Element of { ( 0 ) , 1 , 2 })) = ( $1 + $2 );
L181: (ex B78 being (BinOp of { ( 0 ) , 1 , 2 }) st (for B79 , B80 being (Element of { ( 0 ) , 1 , 2 }) holds ( B78 . (B79 , B80) ) = H1(B79 , B80))) from BINOP_1:sch 4;
thus L182: thesis by L181;
end;
uniqueness
proof
let C91 , C92 being (BinOp of { ( 0 ) , 1 , 2 });
assume that
L183: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds (for R16 being (Element of { ( 0 ) , 1 , 2 }) holds ( C91 . (R15 , R16) ) = ( R15 + R16 )))
and
L184: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds (for R16 being (Element of { ( 0 ) , 1 , 2 }) holds ( C92 . (R15 , R16) ) = ( R15 + R16 )));
L185:
now
let R15 being (Element of { ( 0 ) , 1 , 2 });
let R16 being (Element of { ( 0 ) , 1 , 2 });
thus L186: ( C91 . (R15 , R16) ) = ( R15 + R16 ) by L183
.= ( C92 . (R15 , R16) ) by L184;
end;
thus L187: thesis by L185 , BINOP_1:2;
end;
func mult3 -> (BinOp of { ( 0 ) , 1 , 2 }) means 
:L188: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds (for R16 being (Element of { ( 0 ) , 1 , 2 }) holds ( it . (R15 , R16) ) = ( R15 * R16 )));
existence
proof
deffunc H2((Element of { ( 0 ) , 1 , 2 }) , (Element of { ( 0 ) , 1 , 2 })) = ( $1 * $2 );
L189: (ex B81 being (BinOp of { ( 0 ) , 1 , 2 }) st (for B82 , B83 being (Element of { ( 0 ) , 1 , 2 }) holds ( B81 . (B82 , B83) ) = H2(B82 , B83))) from BINOP_1:sch 4;
thus L190: thesis by L189;
end;
uniqueness
proof
let C93 , C94 being (BinOp of { ( 0 ) , 1 , 2 });
assume that
L191: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds (for R16 being (Element of { ( 0 ) , 1 , 2 }) holds ( C93 . (R15 , R16) ) = ( R15 * R16 )))
and
L192: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds (for R16 being (Element of { ( 0 ) , 1 , 2 }) holds ( C94 . (R15 , R16) ) = ( R15 * R16 )));
L193:
now
let R15 being (Element of { ( 0 ) , 1 , 2 });
let R16 being (Element of { ( 0 ) , 1 , 2 });
thus L194: ( C93 . (R15 , R16) ) = ( R15 * R16 ) by L191
.= ( C94 . (R15 , R16) ) by L192;
end;
thus L195: thesis by L193 , BINOP_1:2;
end;
func compl3 -> (UnOp of { ( 0 ) , 1 , 2 }) means 
:L196: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds ( it . R15 ) = ( - R15 ));
existence
proof
deffunc H3((Element of { ( 0 ) , 1 , 2 })) = ( - $1 );
L197: (ex B84 being (UnOp of { ( 0 ) , 1 , 2 }) st (for B85 being (Element of { ( 0 ) , 1 , 2 }) holds ( B84 . B85 ) = H3(B85))) from FUNCT_2:sch 4;
thus L198: thesis by L197;
end;
uniqueness
proof
let C95 , C96 being (UnOp of { ( 0 ) , 1 , 2 });
assume that
L199: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds ( C95 . R15 ) = ( - R15 ))
and
L200: (for R15 being (Element of { ( 0 ) , 1 , 2 }) holds ( C96 . R15 ) = ( - R15 ));
L201:
now
let R15 being (Element of { ( 0 ) , 1 , 2 });
thus L202: ( C95 . R15 ) = ( - R15 ) by L199
.= ( C96 . R15 ) by L200;
end;
thus L203: thesis by L201 , FUNCT_2:63;
end;
func unit3 -> (Element of { ( 0 ) , 1 , 2 }) equals 
1;
coherence by ENUMSET1:def 1;
func zero3 -> (Element of { ( 0 ) , 1 , 2 }) equals 
( 0 );
coherence by ENUMSET1:def 1;
end;
definition
func Z_3 ->  strict doubleLoopStr equals 
:L205: doubleLoopStr (# { ( 0 ) , 1 , 2 } , ( add3 ) , ( mult3 ) , ( unit3 ) , ( zero3 ) #);
coherence;
end;
registration
cluster ( Z_3 ) -> non  empty;
coherence;
end;
L208:
now
let C97 , C98 being (Element of ( Z_3 ));
assume L209: C98 = 1;
reconsider D48 = C98 , D49 = C97 as (Element of { ( 0 ) , 1 , 2 });
thus L210: ( C97 * C98 ) = ( D49 * D48 ) by L188
.= C97 by L209 , L178;
thus L211: ( C98 * C97 ) = ( D48 * D49 ) by L188
.= C97 by L209 , L178;
end;
registration
cluster ( Z_3 ) ->  well-unital;
coherence
proof
let C99 being (Element of ( Z_3 ));
thus L212: thesis by L208;
end;
end;
theorem
L214: (( 0. ( Z_3 ) ) = ( 0 ) & ( 1. ( Z_3 ) ) = 1 & ( 0. ( Z_3 ) ) is (Element of { ( 0 ) , 1 , 2 }) & ( 1. ( Z_3 ) ) is (Element of { ( 0 ) , 1 , 2 }) & (the addF of ( Z_3 )) = ( add3 ) & (the multF of ( Z_3 )) = ( mult3 ));
L215: (for B86 , B87 , B88 being (Scalar of ( Z_3 )) holds (for B89 , B90 , B91 being (Element of { ( 0 ) , 1 , 2 }) holds ((B89 = B86 & B90 = B87 & B91 = B88) implies (( ( B86 + B87 ) + B88 ) = ( ( B89 + B90 ) + B91 ) & ( B86 + ( B87 + B88 ) ) = ( B89 + ( B90 + B91 ) ) & ( ( B86 * B87 ) * B88 ) = ( ( B89 * B90 ) * B91 ) & ( B86 * ( B87 * B88 ) ) = ( B89 * ( B90 * B91 ) )))))
proof
let C100 , C101 , C102 being (Scalar of ( Z_3 ));
let C103 , C104 , C105 being (Element of { ( 0 ) , 1 , 2 });
assume that
L216: C103 = C100
and
L217: C104 = C101
and
L218: C105 = C102;
L219: (( C100 * C101 ) = ( C103 * C104 ) & ( C101 * C102 ) = ( C104 * C105 )) by L216 , L217 , L218 , L188;
L220: (( C100 + C101 ) = ( C103 + C104 ) & ( C101 + C102 ) = ( C104 + C105 )) by L216 , L217 , L218 , L180;
thus L221: thesis by L220 , L216 , L218 , L219 , L180 , L188;
end;
L222: (for B92 , B93 , B94 , B95 being (Element of { ( 0 ) , 1 , 2 }) holds (B95 = ( 0 ) implies (( B92 + ( - B92 ) ) = B95 & ( B92 + B95 ) = B92 & ( ( B92 + B93 ) + B94 ) = ( B92 + ( B93 + B94 ) ))))
proof
let C106 , C107 , C108 , C109 being (Element of { ( 0 ) , 1 , 2 });
assume that
L223: C109 = ( 0 );
thus L224: ( C106 + ( - C106 ) ) = C109
proof
L225:
now
per cases  by ENUMSET1:def 1;
suppose L226: C106 = ( 0 );

L227: ( - C106 ) = ( 0 ) by L226 , L176;
thus L228: thesis by L227 , L223 , L226 , L177;
end;
suppose L229: C106 = 1;

L230: ( - C106 ) = 2 by L229 , L176;
thus L231: thesis by L230 , L223 , L229 , L177;
end;
suppose L232: C106 = 2;

L233: ( - C106 ) = 1 by L232 , L176;
thus L234: thesis by L233 , L223 , L232 , L177;
end;
end;
thus L236: thesis by L225;
end;

thus L237: ( C106 + C109 ) = C106 by L223 , L177;
thus L238: ( ( C106 + C107 ) + C108 ) = ( C106 + ( C107 + C108 ) )
proof
L239:
now
per cases  by ENUMSET1:def 1;
suppose L240: C106 = ( 0 );

thus L241: ( ( C106 + C107 ) + C108 ) = ( C107 + C108 ) by L240 , L177
.= ( C106 + ( C107 + C108 ) ) by L240 , L177;
end;
suppose L242: C107 = ( 0 );

L243: ( C106 + C107 ) = C106 by L242 , L177;
thus L244: thesis by L243 , L242 , L177;
end;
suppose L245: C108 = ( 0 );

L246: ( C107 + C108 ) = C107 by L245 , L177;
thus L247: thesis by L246 , L245 , L177;
end;
suppose L248: (C106 = 1 & C107 = 1 & C108 = 1);

thus L249: ( ( C106 + C107 ) + C108 ) = ( 0 ) by L248 , L177
.= ( C106 + ( C107 + C108 ) ) by L248 , L177;
end;
suppose L250: (C106 = 1 & C107 = 1 & C108 = 2);

L251: ( C107 + C108 ) = ( 0 ) by L250 , L177;
L252: ( C106 + C107 ) = 2 by L250 , L177;
thus L253: ( ( C106 + C107 ) + C108 ) = 1 by L252 , L250 , L177
.= ( C106 + ( C107 + C108 ) ) by L250 , L251 , L177;
end;
suppose L254: (C106 = 1 & C107 = 2 & C108 = 1);

L255: ( C107 + C108 ) = ( 0 ) by L254 , L177;
L256: ( C106 + C107 ) = ( 0 ) by L254 , L177;
thus L257: ( ( C106 + C107 ) + C108 ) = 1 by L256 , L254 , L177
.= ( C106 + ( C107 + C108 ) ) by L254 , L255 , L177;
end;
suppose L258: (C106 = 1 & C107 = 2 & C108 = 2);

L259: ( C107 + C108 ) = 1 by L258 , L177;
L260: ( C106 + C107 ) = ( 0 ) by L258 , L177;
thus L261: ( ( C106 + C107 ) + C108 ) = 2 by L260 , L258 , L177
.= ( C106 + ( C107 + C108 ) ) by L258 , L259 , L177;
end;
suppose L262: (C106 = 2 & C107 = 1 & C108 = 1);

L263: ( C107 + C108 ) = 2 by L262 , L177;
L264: ( C106 + C107 ) = ( 0 ) by L262 , L177;
thus L265: ( ( C106 + C107 ) + C108 ) = 1 by L264 , L262 , L177
.= ( C106 + ( C107 + C108 ) ) by L262 , L263 , L177;
end;
suppose L266: (C106 = 2 & C107 = 1 & C108 = 2);

L267: ( C107 + C108 ) = ( 0 ) by L266 , L177;
L268: ( C106 + C107 ) = ( 0 ) by L266 , L177;
thus L269: ( ( C106 + C107 ) + C108 ) = 2 by L268 , L266 , L177
.= ( C106 + ( C107 + C108 ) ) by L266 , L267 , L177;
end;
suppose L270: (C106 = 2 & C107 = 2 & C108 = 1);

L271: ( C107 + C108 ) = ( 0 ) by L270 , L177;
L272: ( C106 + C107 ) = 1 by L270 , L177;
thus L273: ( ( C106 + C107 ) + C108 ) = 2 by L272 , L270 , L177
.= ( C106 + ( C107 + C108 ) ) by L270 , L271 , L177;
end;
suppose L274: (C106 = 2 & C107 = 2 & C108 = 2);

thus L275: ( ( C106 + C107 ) + C108 ) = ( 0 ) by L274 , L177
.= ( C106 + ( C107 + C108 ) ) by L274 , L177;
end;
end;
thus L277: thesis by L239;
end;

end;
registration
cluster ( Z_3 ) ->  add-associative  right_zeroed  right_complementable;
coherence
proof
thus L239: ( Z_3 ) is  add-associative
proof
let C110 , C111 , C112 being (Element of ( Z_3 ));
reconsider D50 = C110 , D51 = C111 , D52 = C112 as (Element of { ( 0 ) , 1 , 2 });
thus L240: ( ( C110 + C111 ) + C112 ) = ( ( D50 + D51 ) + D52 ) by L215
.= ( D50 + ( D51 + D52 ) ) by L222
.= ( C110 + ( C111 + C112 ) ) by L215;
end;

thus L241: ( Z_3 ) is  right_zeroed
proof
let C113 being (Element of ( Z_3 ));
reconsider D53 = C113 , D54 = ( 0 ) as (Element of { ( 0 ) , 1 , 2 }) by L205;
thus L242: ( C113 + ( 0. ( Z_3 ) ) ) = ( D53 + D54 ) by L180
.= C113 by L222;
end;

let C114 being (Element of ( Z_3 ));
reconsider D55 = C114 as (Element of { ( 0 ) , 1 , 2 });
reconsider D56 = ( ( compl3 ) . D55 ) as (Element of ( Z_3 ));
reconsider D57 = D56 as (Element of { ( 0 ) , 1 , 2 });
take D56;
L243: D57 = ( - D55 ) by L196;
thus L244: ( C114 + D56 ) = ( 0. ( Z_3 ) )
proof
per cases  by ENUMSET1:def 1;
suppose L245: C114 = ( 0 );

L246: D57 = ( 0 ) by L245 , L243 , L176;
thus L247: ( C114 + D56 ) = ( D55 + D57 ) by L180
.= ( 0. ( Z_3 ) ) by L245 , L246 , L177;
end;
suppose L248: C114 = 1;

L249: D57 = 2 by L248 , L243 , L176;
thus L250: ( C114 + D56 ) = ( D55 + D57 ) by L180
.= ( 0. ( Z_3 ) ) by L248 , L249 , L177;
end;
suppose L251: C114 = 2;

L252: D57 = 1 by L251 , L243 , L176;
thus L253: ( C114 + D56 ) = ( D55 + D57 ) by L180
.= ( 0. ( Z_3 ) ) by L251 , L252 , L177;
end;
end;

end;
end;
theorem
L246: (for B96 , B97 being (Scalar of ( Z_3 )) holds (for B98 , B99 being (Element of { ( 0 ) , 1 , 2 }) holds ((B98 = B96 & B99 = B97) implies (( B96 + B97 ) = ( B98 + B99 ) & ( B96 * B97 ) = ( B98 * B99 ) & ( - B96 ) = ( - B98 )))))
proof
let C115 , C116 being (Scalar of ( Z_3 ));
let C117 , C118 being (Element of { ( 0 ) , 1 , 2 });
assume that
L247: C117 = C115
and
L248: C118 = C116;
thus L249: ( C115 + C116 ) = ( C117 + C118 ) by L247 , L248 , L180;
thus L250: ( C115 * C116 ) = ( C117 * C118 ) by L247 , L248 , L188;
reconsider D58 = ( - C117 ) as (Element of ( Z_3 ));
L251: ( C115 + D58 ) = ( C117 + ( - C117 ) ) by L247 , L180
.= ( 0. ( Z_3 ) ) by L222;
thus L252: thesis by L251 , RLVECT_1:def 10;
end;
theorem
L253: (for B100 , B101 , B102 being (Scalar of ( Z_3 )) holds (for B103 , B104 , B105 being (Element of { ( 0 ) , 1 , 2 }) holds ((B103 = B100 & B104 = B101 & B105 = B102) implies (( ( B100 + B101 ) + B102 ) = ( ( B103 + B104 ) + B105 ) & ( B100 + ( B101 + B102 ) ) = ( B103 + ( B104 + B105 ) ) & ( ( B100 * B101 ) * B102 ) = ( ( B103 * B104 ) * B105 ) & ( B100 * ( B101 * B102 ) ) = ( B103 * ( B104 * B105 ) )))))
proof
let C119 , C120 , C121 being (Scalar of ( Z_3 ));
let C122 , C123 , C124 being (Element of { ( 0 ) , 1 , 2 });
assume that
L254: C122 = C119
and
L255: C123 = C120
and
L256: C124 = C121;
L257: (( C119 * C120 ) = ( C122 * C123 ) & ( C120 * C121 ) = ( C123 * C124 )) by L254 , L255 , L256 , L246;
L258: (( C119 + C120 ) = ( C122 + C123 ) & ( C120 + C121 ) = ( C123 + C124 )) by L254 , L255 , L256 , L246;
thus L259: thesis by L258 , L254 , L256 , L257 , L246;
end;
theorem
L260: (for B106 , B107 , B108 , B109 , B110 being (Element of { ( 0 ) , 1 , 2 }) holds ((B109 = ( 0 ) & B110 = 1) implies (( B106 + B107 ) = ( B107 + B106 ) & ( ( B106 + B107 ) + B108 ) = ( B106 + ( B107 + B108 ) ) & ( B106 + B109 ) = B106 & ( B106 + ( - B106 ) ) = B109 & ( B106 * B107 ) = ( B107 * B106 ) & ( ( B106 * B107 ) * B108 ) = ( B106 * ( B107 * B108 ) ) & ( B110 * B106 ) = B106 & (B106 <> B109 implies (ex B111 being (Element of { ( 0 ) , 1 , 2 }) st ( B106 * B111 ) = B110)) & B109 <> B110 & ( B106 * ( B107 + B108 ) ) = ( ( B106 * B107 ) + ( B106 * B108 ) ))))
proof
let C125 , C126 , C127 , C128 , C129 being (Element of { ( 0 ) , 1 , 2 });
assume that
L261: C128 = ( 0 )
and
L262: C129 = 1;
thus L263: ( C125 + C126 ) = ( C126 + C125 )
proof
L264:
now
per cases  by ENUMSET1:def 1;
suppose L265: C125 = ( 0 );

thus L266: ( C125 + C126 ) = C126 by L265 , L177
.= ( C126 + C125 ) by L265 , L177;
end;
suppose L267: C126 = ( 0 );

thus L268: ( C125 + C126 ) = C125 by L267 , L177
.= ( C126 + C125 ) by L267 , L177;
end;
suppose L269: (C125 = 1 & C126 = 1);

thus L270: thesis by L269;
end;
suppose L271: (C125 = 1 & C126 = 2);

thus L272: ( C125 + C126 ) = ( 0 ) by L271 , L177
.= ( C126 + C125 ) by L271 , L177;
end;
suppose L273: (C125 = 2 & C126 = 1);

thus L274: ( C125 + C126 ) = ( 0 ) by L273 , L177
.= ( C126 + C125 ) by L273 , L177;
end;
suppose L275: (C125 = 2 & C126 = 2);

thus L276: thesis by L275;
end;
end;
thus L278: thesis by L264;
end;

thus L279: ( ( C125 + C126 ) + C127 ) = ( C125 + ( C126 + C127 ) ) by L261 , L222;
thus L280: ( C125 + C128 ) = C125 by L261 , L177;
thus L281: ( C125 + ( - C125 ) ) = C128 by L261 , L222;
thus L282: ( C125 * C126 ) = ( C126 * C125 )
proof
L283:
now
per cases  by ENUMSET1:def 1;
suppose L284: C126 = ( 0 );

thus L285: ( C125 * C126 ) = ( 0 ) by L284 , L178
.= ( C126 * C125 ) by L284 , L178;
end;
suppose L286: C125 = ( 0 );

thus L287: ( C125 * C126 ) = ( 0 ) by L286 , L178
.= ( C126 * C125 ) by L286 , L178;
end;
suppose L288: C126 = 1;

thus L289: ( C125 * C126 ) = C125 by L288 , L178
.= ( C126 * C125 ) by L288 , L178;
end;
suppose L290: C125 = 1;

thus L291: ( C125 * C126 ) = C126 by L290 , L178
.= ( C126 * C125 ) by L290 , L178;
end;
suppose L292: (C125 = 2 & C126 = 2);

thus L293: thesis by L292;
end;
end;
thus L295: thesis by L283;
end;

thus L296: ( ( C125 * C126 ) * C127 ) = ( C125 * ( C126 * C127 ) )
proof
L297:
now
per cases  by ENUMSET1:def 1;
suppose L298: C127 = ( 0 );

L299: ( C126 * C127 ) = ( 0 ) by L298 , L178;
thus L300: ( ( C125 * C126 ) * C127 ) = ( 0 ) by L298 , L178
.= ( C125 * ( C126 * C127 ) ) by L299 , L178;
end;
suppose L301: C126 = ( 0 );

L302: ( C126 * C127 ) = ( 0 ) by L301 , L178;
L303: ( C125 * C126 ) = ( 0 ) by L301 , L178;
thus L304: ( ( C125 * C126 ) * C127 ) = ( 0 ) by L303 , L178
.= ( C125 * ( C126 * C127 ) ) by L302 , L178;
end;
suppose L305: C125 = ( 0 );

L306: ( C125 * C126 ) = ( 0 ) by L305 , L178;
thus L307: ( ( C125 * C126 ) * C127 ) = ( 0 ) by L306 , L178
.= ( C125 * ( C126 * C127 ) ) by L305 , L178;
end;
suppose L308: C127 = 1;

L309: ( C126 * C127 ) = C126 by L308 , L178;
thus L310: thesis by L309 , L308 , L178;
end;
suppose L311: C126 = 1;

L312: ( C125 * C126 ) = C125 by L311 , L178;
thus L313: thesis by L312 , L311 , L178;
end;
suppose L314: C125 = 1;

thus L315: ( ( C125 * C126 ) * C127 ) = ( C126 * C127 ) by L314 , L178
.= ( C125 * ( C126 * C127 ) ) by L314 , L178;
end;
suppose L316: (C125 = 2 & C126 = 2 & C127 = 2);

L317: ( C126 * C127 ) = 1 by L316 , L178;
L318: ( C125 * C126 ) = 1 by L316 , L178;
thus L319: ( ( C125 * C126 ) * C127 ) = C125 by L318 , L316 , L178
.= ( C125 * ( C126 * C127 ) ) by L317 , L178;
end;
end;
thus L321: thesis by L297;
end;

thus L322: ( C129 * C125 ) = C125 by L262 , L178;
thus L323: (C125 <> C128 implies (ex B112 being (Element of { ( 0 ) , 1 , 2 }) st ( C125 * B112 ) = C129))
proof
L324:
now
per cases  by ENUMSET1:def 1;
case L325: C125 = ( 0 );
thus L326: thesis by L325 , L261;
end;
case L327: C125 = 1;
reconsider D59 = 1 as (Element of { ( 0 ) , 1 , 2 }) by ENUMSET1:def 1;
take D60 = D59;
L328: ( C125 * D60 ) = 1 by L327 , L178;
thus L329: thesis by L328 , L262;
end;
case L330: C125 = 2;
reconsider D61 = 2 as (Element of { ( 0 ) , 1 , 2 }) by ENUMSET1:def 1;
take D62 = D61;
L331: ( C125 * D62 ) = 1 by L330 , L178;
thus L332: thesis by L331 , L262;
end;
end;
thus L334: thesis by L324;
end;

thus L335: C128 <> C129 by L261 , L262;
thus L336: ( C125 * ( C126 + C127 ) ) = ( ( C125 * C126 ) + ( C125 * C127 ) )
proof
L337:
now
per cases  by ENUMSET1:def 1;
suppose L338: C125 = ( 0 );

L339: (( C125 * C126 ) = ( 0 ) & ( C125 * C127 ) = ( 0 )) by L338 , L178;
thus L340: ( C125 * ( C126 + C127 ) ) = ( 0 ) by L338 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L339 , L177;
end;
suppose L341: C126 = ( 0 );

L342: (( C126 + C127 ) = C127 & ( C125 * C126 ) = ( 0 )) by L341 , L177 , L178;
thus L343: thesis by L342 , L177;
end;
suppose L344: C127 = ( 0 );

L345: (( C126 + C127 ) = C126 & ( C125 * C127 ) = ( 0 )) by L344 , L177 , L178;
thus L346: thesis by L345 , L177;
end;
suppose L347: (C125 = 1 & C126 = 1 & C127 = 1);

L348: ( C125 * C126 ) = 1 by L347 , L178;
thus L349: thesis by L348 , L347 , L178;
end;
suppose L350: (C125 = 1 & C126 = 1 & C127 = 2);

L351: (( C125 * C126 ) = 1 & ( C125 * C127 ) = 2) by L350 , L178;
L352: ( C126 + C127 ) = ( 0 ) by L350 , L177;
thus L353: ( C125 * ( C126 + C127 ) ) = ( 0 ) by L352 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L351 , L177;
end;
suppose L354: (C125 = 1 & C126 = 2 & C127 = 1);

L355: (( C125 * C126 ) = 2 & ( C125 * C127 ) = 1) by L354 , L178;
L356: ( C126 + C127 ) = ( 0 ) by L354 , L177;
thus L357: ( C125 * ( C126 + C127 ) ) = ( 0 ) by L356 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L355 , L177;
end;
suppose L358: (C125 = 1 & C126 = 2 & C127 = 2);

L359: ( C125 * C126 ) = 2 by L358 , L178;
thus L360: thesis by L359 , L358 , L178;
end;
suppose L361: (C125 = 2 & C126 = 1 & C127 = 1);

L362: ( C125 * C126 ) = 2 by L361 , L178;
L363: ( C126 + C127 ) = 2 by L361 , L177;
thus L364: ( C125 * ( C126 + C127 ) ) = 1 by L363 , L361 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L361 , L362 , L177;
end;
suppose L365: (C125 = 2 & C126 = 1 & C127 = 2);

L366: (( C125 * C126 ) = 2 & ( C125 * C127 ) = 1) by L365 , L178;
L367: ( C126 + C127 ) = ( 0 ) by L365 , L177;
thus L368: ( C125 * ( C126 + C127 ) ) = ( 0 ) by L367 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L366 , L177;
end;
suppose L369: (C125 = 2 & C126 = 2 & C127 = 1);

L370: (( C125 * C126 ) = 1 & ( C125 * C127 ) = 2) by L369 , L178;
L371: ( C126 + C127 ) = ( 0 ) by L369 , L177;
thus L372: ( C125 * ( C126 + C127 ) ) = ( 0 ) by L371 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L370 , L177;
end;
suppose L373: (C125 = 2 & C126 = 2 & C127 = 2);

L374: ( C125 * C126 ) = 1 by L373 , L178;
L375: ( C126 + C127 ) = 1 by L373 , L177;
thus L376: ( C125 * ( C126 + C127 ) ) = 2 by L375 , L373 , L178
.= ( ( C125 * C126 ) + ( C125 * C127 ) ) by L373 , L374 , L177;
end;
end;
thus L378: thesis by L337;
end;

end;
theorem
L337: (for B113 being non  empty doubleLoopStr holds ((for B114 , B115 , B116 being (Scalar of B113) holds (( B114 + B115 ) = ( B115 + B114 ) & ( ( B114 + B115 ) + B116 ) = ( B114 + ( B115 + B116 ) ) & ( B114 + ( 0. B113 ) ) = B114 & ( B114 + ( - B114 ) ) = ( 0. B113 ) & ( B114 * B115 ) = ( B115 * B114 ) & ( ( B114 * B115 ) * B116 ) = ( B114 * ( B115 * B116 ) ) & ( ( 1. B113 ) * B114 ) = B114 & ( B114 * ( 1. B113 ) ) = B114 & (B114 <> ( 0. B113 ) implies (ex B117 being (Scalar of B113) st ( B114 * B117 ) = ( 1. B113 ))) & ( 0. B113 ) <> ( 1. B113 ) & ( B114 * ( B115 + B116 ) ) = ( ( B114 * B115 ) + ( B114 * B116 ) ))) implies B113 is Field))
proof
let C130 being non  empty doubleLoopStr;
assume that
L338: (for B118 , B119 , B120 being (Scalar of C130) holds (( B118 + B119 ) = ( B119 + B118 ) & ( ( B118 + B119 ) + B120 ) = ( B118 + ( B119 + B120 ) ) & ( B118 + ( 0. C130 ) ) = B118 & ( B118 + ( - B118 ) ) = ( 0. C130 ) & ( B118 * B119 ) = ( B119 * B118 ) & ( ( B118 * B119 ) * B120 ) = ( B118 * ( B119 * B120 ) ) & ( ( 1. C130 ) * B118 ) = B118 & ( B118 * ( 1. C130 ) ) = B118 & (B118 <> ( 0. C130 ) implies (ex B121 being (Scalar of C130) st ( B118 * B121 ) = ( 1. C130 ))) & ( 0. C130 ) <> ( 1. C130 ) & ( B118 * ( B119 + B120 ) ) = ( ( B118 * B119 ) + ( B118 * B120 ) )));
L339: (for B122 being (Scalar of C130) holds (B122 <> ( 0. C130 ) implies (ex B123 being (Scalar of C130) st ( B123 * B122 ) = ( 1. C130 ))))
proof
let C131 being (Scalar of C130);
assume L340: C131 <> ( 0. C130 );
consider C132 being (Scalar of C130) such that L341: ( C131 * C132 ) = ( 1. C130 ) by L340 , L338;
take C132;
thus L342: thesis by L338 , L341;
end;
L343:
now
let C133 , C134 , C135 being (Scalar of C130);
thus L344: (( C133 + C134 ) = ( C134 + C133 ) & ( ( C133 + C134 ) + C135 ) = ( C133 + ( C134 + C135 ) ) & ( C133 + ( 0. C130 ) ) = C133 & ( C133 + ( - C133 ) ) = ( 0. C130 ) & ( C133 * C134 ) = ( C134 * C133 ) & ( ( C133 * C134 ) * C135 ) = ( C133 * ( C134 * C135 ) ) & ( ( 1. C130 ) * C133 ) = C133 & ( C133 * ( 1. C130 ) ) = C133 & (C133 <> ( 0. C130 ) implies (ex B124 being (Scalar of C130) st ( C133 * B124 ) = ( 1. C130 ))) & ( 0. C130 ) <> ( 1. C130 ) & ( C133 * ( C134 + C135 ) ) = ( ( C133 * C134 ) + ( C133 * C135 ) )) by L338;
thus L345: ( ( C134 + C135 ) * C133 ) = ( C133 * ( C134 + C135 ) ) by L338
.= ( ( C133 * C134 ) + ( C133 * C135 ) ) by L338
.= ( ( C134 * C133 ) + ( C133 * C135 ) ) by L338
.= ( ( C134 * C133 ) + ( C135 * C133 ) ) by L338;
end;
L346: C130 is  right_complementable
proof
let C136 being (Element of C130);
take ( - C136 );
thus L347: thesis by L343;
end;
thus L348: thesis by L346 , L339 , L343 , GROUP_1:def 3 , GROUP_1:def 12 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , STRUCT_0:def 8 , VECTSP_1:def 6 , VECTSP_1:def 7 , VECTSP_1:def 9;
end;
theorem
L349: ( Z_3 ) is  Fanoian  Fanoian  Fanoian  Fanoian Field
proof
set D63 = ( Z_3 );
reconsider D64 = ( 0. D63 ) , D65 = ( 1. D63 ) as (Element of { ( 0 ) , 1 , 2 });
L350:
now
let C137 , C138 , C139 being (Scalar of ( Z_3 ));
thus L351: (( C137 + C138 ) = ( C138 + C137 ) & ( ( C137 + C138 ) + C139 ) = ( C137 + ( C138 + C139 ) ) & ( C137 + ( 0. ( Z_3 ) ) ) = C137 & ( C137 + ( - C137 ) ) = ( 0. ( Z_3 ) ) & ( C137 * C138 ) = ( C138 * C137 ) & ( ( C137 * C138 ) * C139 ) = ( C137 * ( C138 * C139 ) ) & ( ( 1. ( Z_3 ) ) * C137 ) = C137 & ( C137 * ( 1. ( Z_3 ) ) ) = C137 & (C137 <> ( 0. ( Z_3 ) ) implies (ex B125 being (Scalar of ( Z_3 )) st ( C137 * B125 ) = ( 1. ( Z_3 ) ))) & ( 0. ( Z_3 ) ) <> ( 1. ( Z_3 ) ) & ( C137 * ( C138 + C139 ) ) = ( ( C137 * C138 ) + ( C137 * C139 ) ))
proof
reconsider D66 = C137 , D67 = C138 , D68 = C139 as (Element of { ( 0 ) , 1 , 2 });
L352: (( C137 * C138 ) = ( D66 * D67 ) & ( C137 * C139 ) = ( D66 * D68 )) by L246;
thus L353: ( C137 + C138 ) = ( D66 + D67 ) by L246
.= ( D67 + D66 ) by L260
.= ( C138 + C137 ) by L246;
thus L354: ( ( C137 + C138 ) + C139 ) = ( ( D66 + D67 ) + D68 ) by L253
.= ( D66 + ( D67 + D68 ) ) by L260
.= ( C137 + ( C138 + C139 ) ) by L253;
thus L355: ( C137 + ( 0. ( Z_3 ) ) ) = ( D66 + D64 ) by L246
.= C137 by L260;
L356: ( - C137 ) = ( - D66 ) by L246;
thus L357: ( C137 + ( - C137 ) ) = ( D66 + ( - D66 ) ) by L356 , L246
.= ( 0. ( Z_3 ) ) by L260;
thus L358: ( C137 * C138 ) = ( D66 * D67 ) by L246
.= ( D67 * D66 ) by L260
.= ( C138 * C137 ) by L246;
thus L359: ( ( C137 * C138 ) * C139 ) = ( ( D66 * D67 ) * D68 ) by L253
.= ( D66 * ( D67 * D68 ) ) by L260
.= ( C137 * ( C138 * C139 ) ) by L253;
thus L360: ( ( 1. ( Z_3 ) ) * C137 ) = ( D65 * D66 ) by L246
.= C137 by L260;
thus L361: ( C137 * ( 1. ( Z_3 ) ) ) = ( D66 * D65 ) by L246
.= ( D65 * D66 ) by L260
.= C137 by L260;
thus L362: (C137 <> ( 0. ( Z_3 ) ) implies (ex B126 being (Scalar of ( Z_3 )) st ( C137 * B126 ) = ( 1. ( Z_3 ) )))
proof
assume L363: C137 <> ( 0. ( Z_3 ) );
consider C140 being (Element of { ( 0 ) , 1 , 2 }) such that L364: ( D66 * C140 ) = D65 by L363 , L260;
reconsider D69 = C140 as (Scalar of ( Z_3 ));
take D69;
thus L365: thesis by L364 , L246;
end;

thus L366: ( 0. ( Z_3 ) ) <> ( 1. ( Z_3 ) );
L367: ( C138 + C139 ) = ( D67 + D68 ) by L246;
thus L368: ( C137 * ( C138 + C139 ) ) = ( D66 * ( D67 + D68 ) ) by L367 , L246
.= ( ( D66 * D67 ) + ( D66 * D68 ) ) by L260
.= ( ( C137 * C138 ) + ( C137 * C139 ) ) by L352 , L246;
end;

end;
reconsider D70 = D63 as Field by L350 , L337;
L352: ( ( 1. D70 ) + ( 1. D70 ) ) = ( D65 + D65 ) by L180
.= 2 by L177;
thus L353: thesis by L352 , L214 , VECTSP_1:def 19;
end;
registration
cluster ( Z_3 ) ->  Fanoian  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive  almost_left_invertible;
coherence by L349;
end;
L355: (for R7 being Universe holds (the carrier of ( Z_3 )) in R7)
proof
let R7 being Universe;
reconsider D71 = ( 0 ) , D72 = 1 , D73 = 2 as (Element of R7) by L164;
L356: { D71 , D72 , D73 } is (Element of R7) by L158;
thus L357: thesis by L356;
end;
theorem
L358: (for R1 being non  empty set holds (for R2 being non  empty set holds (for R7 being Universe holds (for B127 being (Function of R1 , R2) holds ((R1 in R7 & R2 in R7) implies B127 in R7)))))
proof
let R1 being non  empty set;
let R2 being non  empty set;
let R7 being Universe;
let C141 being (Function of R1 , R2);
assume L359: (R1 in R7 & R2 in R7);
L360: ( Funcs (R1 , R2) ) in R7 by L359 , CLASSES2:61;
L361: C141 in ( Funcs (R1 , R2) ) by FUNCT_2:8;
thus L362: thesis by L361 , L360 , ORDINAL1:10;
end;
L363: (for R1 being non  empty set holds (for R7 being Universe holds ((for B128 being (BinOp of R1) holds (R1 in R7 implies B128 in R7)) & (for B129 being (UnOp of R1) holds (R1 in R7 implies B129 in R7)))))
proof
let R1 being non  empty set;
let R7 being Universe;
L364:
now
let C142 being (BinOp of R1);
assume L365: R1 in R7;
L366: [: R1 , R1 :] in R7 by L365 , CLASSES2:61;
L367: ( Funcs ([: R1 , R1 :] , R1) ) in R7 by L366 , L365 , CLASSES2:61;
L368: C142 in ( Funcs ([: R1 , R1 :] , R1) ) by FUNCT_2:8;
thus L369: C142 in R7 by L368 , L367 , ORDINAL1:10;
end;
thus L370: thesis by L364 , L358;
end;
theorem
L371: (for R7 being Universe holds ((the carrier of ( Z_3 )) in R7 & (the addF of ( Z_3 )) in R7 & ( comp ( Z_3 ) ) in R7 & ( 0. ( Z_3 ) ) in R7 & (the multF of ( Z_3 )) in R7 & ( 1. ( Z_3 ) ) in R7))
proof
let R7 being Universe;
thus L372: (the carrier of ( Z_3 )) in R7 by L355;
thus L373: thesis by L372 , L363 , ORDINAL1:10;
end;
