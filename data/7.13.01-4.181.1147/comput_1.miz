:: The set of primitive recursive functions
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received July 27, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, XBOOLE_0, RELAT_1, FUNCT_1, FINSEQ_1, FUNCT_4,
      FINSEQ_3, XXREAL_0, NAT_1, ARYTM_3, CARD_1, FINSEQ_2, PARTFUN1, SETFAM_1,
      FUNCT_6, TARSKI, MSUALG_6, RFUNCT_3, VALUED_0, UNIALG_1, CARD_3,
      FUNCOP_1, FUNCT_2, PRALG_3, ORDINAL1, ORDINAL4, ZFMISC_1, FINSET_1,
      VALUED_2, REALSET1, NEWTON, ARYTM_1, COMPUT_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, XXREAL_0, RELAT_1,
      RELSET_1, FUNCT_1, FINSEQ_1, FINSEQ_2, SETFAM_1, FUNCT_2, MARGREL1,
      FUNCOP_1, XXREAL_2, VALUED_0, FUNCT_4, CARD_3, PROB_1, FINSEQ_3,
      FINSEQ_4, PARTFUN1, RFUNCT_3, FUNCT_6, FUNCT_7, MIDSP_3, FINSET_1,
      NEWTON, NAT_D, ORDINAL1, NAT_1, RECDEF_1;
 constructors DOMAIN_1, FUNCT_4, REAL_1, PROB_1, FINSEQ_3, FINSEQ_4, NEWTON,
      RFUNCT_3, NAT_D, RECDEF_1, XXREAL_2, MIDSP_3, RELSET_1, FUNCT_6,
      MARGREL1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, PARTFUN1,
      FUNCOP_1, FINSET_1, XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1,
      FINSEQ_2, FUNCT_7, FUNCT_2, VALUED_0, XXREAL_2, CARD_1, RELSET_1, CARD_3,
      FINSEQ_3, MARGREL1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions PARTFUN1, RFUNCT_3, FUNCT_1, RELAT_1, TARSKI, FINSEQ_2, FUNCOP_1,
      CARD_3, MARGREL1;
 theorems TARSKI, NAT_1, ZFMISC_1, RELAT_1, RELSET_1, FINSEQ_1, FUNCOP_1,
      PARTFUN1, FINSEQ_2, FINSEQ_4, FUNCT_6, FUNCT_1, RFUNCT_3, FUNCT_2,
      GRFUNC_1, FUNCT_7, FUNCT_4, FINSEQ_3, SUBSET_1, SETFAM_1, CARD_5,
      FUNCT_5, CARD_1, CARD_3, NEWTON, WSIERP_1, XBOOLE_0, XBOOLE_1, ORDINAL1,
      XXREAL_0, VALUED_0, XXREAL_2, XREAL_0, NAT_D, XREAL_1, MARGREL1,
      XTUPLE_0;
 schemes NAT_1, FUNCT_2, RECDEF_1, MONOID_1, PARTFUN2;

begin
theorem
L1: (for R8 being set holds (for R9 being set holds (for R10 being set holds (( <* R8 , R9 *> +* (1 , R10) ) = <* R10 , R9 *> & ( <* R8 , R9 *> +* (2 , R10) ) = <* R8 , R10 *>))))
proof
let R8 being set;
let R9 being set;
let R10 being set;
set D1 = ( <* R8 , R9 *> +* (1 , R10) );
set D2 = ( <* R8 , R9 *> +* (2 , R10) );
L2: ( <* R8 , R9 *> . 1 ) = R8 by FINSEQ_1:44;
L3: ( D2 . 1 ) = R8 by L2 , FUNCT_7:32;
L4: ( <* R8 , R9 *> . 2 ) = R9 by FINSEQ_1:44;
L5: ( D1 . 2 ) = R9 by L4 , FUNCT_7:32;
L6: ( len <* R8 , R9 *> ) = 2 by FINSEQ_1:44;
L7: 1 in ( dom <* R8 , R9 *> ) by L6 , FINSEQ_3:25;
L8: ( D1 . 1 ) = R10 by L7 , FUNCT_7:31;
L9: ( len D1 ) = 2 by L6 , FUNCT_7:97;
thus L10: ( <* R8 , R9 *> +* (1 , R10) ) = <* R10 , R9 *> by L9 , L8 , L5 , FINSEQ_1:44;
L11: 2 in ( dom <* R8 , R9 *> ) by L6 , FINSEQ_3:25;
L12: ( D2 . 2 ) = R10 by L11 , FUNCT_7:31;
L13: ( len D2 ) = 2 by L6 , FUNCT_7:97;
thus L14: thesis by L13 , L3 , L12 , FINSEQ_1:44;
end;
theorem
L15: (for R7 being set holds (for R8 being set holds (for R9 being set holds (for R10 being set holds (for R16 being Function holds (for R17 being Function holds (( R16 +* (R7 , R8) ) = ( R17 +* (R7 , R9) ) implies ( R16 +* (R7 , R10) ) = ( R17 +* (R7 , R10) ))))))))
proof
let R7 being set;
let R8 being set;
let R9 being set;
let R10 being set;
let R16 being Function;
let R17 being Function;
set D3 = R7;
assume L16: ( R16 +* (D3 , R8) ) = ( R17 +* (D3 , R9) );
L17: ( dom ( R17 +* (D3 , R10) ) ) = ( dom R17 ) by FUNCT_7:30;
L18: ( dom ( R17 +* (D3 , R9) ) ) = ( dom R17 ) by FUNCT_7:30;
L19: ( dom ( R16 +* (D3 , R8) ) ) = ( dom R16 ) by FUNCT_7:30;
L20:
now
thus L21: ( dom ( R16 +* (D3 , R10) ) ) = ( dom R16 ) by FUNCT_7:30;
thus L22: ( dom ( R17 +* (D3 , R10) ) ) = ( dom R16 ) by L16 , L18 , L17 , FUNCT_7:30;
let C1 being set;
assume L23: C1 in ( dom R16 );
per cases ;
suppose L24: C1 = D3;

thus L25: ( ( R16 +* (D3 , R10) ) . C1 ) = R10 by L24 , L23 , FUNCT_7:31
.= ( ( R17 +* (D3 , R10) ) . C1 ) by L16 , L19 , L18 , L23 , L24 , FUNCT_7:31;
end;
suppose L26: C1 <> D3;

thus L27: ( ( R16 +* (D3 , R10) ) . C1 ) = ( R16 . C1 ) by L26 , FUNCT_7:32
.= ( ( R17 +* (D3 , R9) ) . C1 ) by L16 , L26 , FUNCT_7:32
.= ( R17 . C1 ) by L26 , FUNCT_7:32
.= ( ( R17 +* (D3 , R10) ) . C1 ) by L26 , FUNCT_7:32;
end;
end;
thus L29: thesis by L20 , FUNCT_1:2;
end;
theorem
L30: (for R1 being (Element of ( NAT )) holds (for R8 being set holds (for R18 being FinSequence holds ( Del (( R18 +* (R1 , R8) ) , R1) ) = ( Del (R18 , R1) ))))
proof
let R1 being (Element of ( NAT ));
let R8 being set;
let R18 being FinSequence;
set D4 = R18;
per cases ;
suppose L31: R1 in ( dom D4 );

L32: R1 <= ( len D4 ) by L31 , FINSEQ_3:25;
L33: 1 <= R1 by L31 , FINSEQ_3:25;
consider C2 being Nat such that L34: ( len D4 ) = ( C2 + 1 ) by L33 , L32 , NAT_1:6;
reconsider D5 = C2 as (Element of ( NAT )) by ORDINAL1:def 12;
L35: ( dom ( D4 +* (R1 , R8) ) ) = ( dom D4 ) by FUNCT_7:30;
L36: ( len ( D4 +* (R1 , R8) ) ) = ( len D4 ) by L35 , FINSEQ_3:29;
L37: ( len ( Del (( D4 +* (R1 , R8) ) , R1) ) ) = D5 by L36 , L31 , L34 , L35 , FINSEQ_3:109;
L38: ( dom ( Del (( D4 +* (R1 , R8) ) , R1) ) ) = ( Seg D5 ) by L37 , FINSEQ_1:def 3;
L39:
now
thus L40: ( len ( Del (( D4 +* (R1 , R8) ) , R1) ) ) = D5 by L31 , L34 , L35 , L36 , FINSEQ_3:109;
thus L41: ( len ( Del (D4 , R1) ) ) = D5 by L31 , L34 , FINSEQ_3:109;
let C3 being Nat;
assume L42: C3 in ( dom ( Del (( D4 +* (R1 , R8) ) , R1) ) );
L43: C3 <= D5 by L42 , L38 , FINSEQ_1:1;
per cases ;
suppose L44: C3 < R1;

thus L45: ( ( Del (( D4 +* (R1 , R8) ) , R1) ) . C3 ) = ( ( D4 +* (R1 , R8) ) . C3 ) by L44 , FINSEQ_3:110
.= ( D4 . C3 ) by L44 , FUNCT_7:32
.= ( ( Del (D4 , R1) ) . C3 ) by L44 , FINSEQ_3:110;
end;
suppose L46: R1 <= C3;

L47: R1 < ( C3 + 1 ) by L46 , NAT_1:13;
thus L48: ( ( Del (( D4 +* (R1 , R8) ) , R1) ) . C3 ) = ( ( D4 +* (R1 , R8) ) . ( C3 + 1 ) ) by L31 , L34 , L35 , L36 , L43 , L46 , FINSEQ_3:111
.= ( D4 . ( C3 + 1 ) ) by L47 , FUNCT_7:32
.= ( ( Del (D4 , R1) ) . C3 ) by L31 , L34 , L43 , L46 , FINSEQ_3:111;
end;
end;
thus L50: thesis by L39 , FINSEQ_2:9;
end;
suppose L51: (not R1 in ( dom D4 ));

thus L52: thesis by L51 , FUNCT_7:def 3;
end;
end;
theorem
L54: (for R1 being (Element of ( NAT )) holds (for R7 being set holds (for R18 being FinSequence holds (for R19 being FinSequence holds (( R18 +* (R1 , R7) ) = ( R19 +* (R1 , R7) ) implies ( Del (R18 , R1) ) = ( Del (R19 , R1) ))))))
proof
let R1 being (Element of ( NAT ));
let R7 being set;
let R18 being FinSequence;
let R19 being FinSequence;
set D6 = R18;
set D7 = R19;
assume L55: ( D6 +* (R1 , R7) ) = ( D7 +* (R1 , R7) );
set D8 = ( D6 +* (R1 , R7) );
set D9 = ( D7 +* (R1 , R7) );
set D10 = ( Del (D6 , R1) );
set D11 = ( Del (D7 , R1) );
L56: ( dom D8 ) = ( dom D6 ) by FUNCT_7:30;
L57: ( dom D9 ) = ( dom D7 ) by FUNCT_7:30;
L58: ( Seg ( len D7 ) ) = ( dom D7 ) by FINSEQ_1:def 3;
L59: ( Seg ( len D6 ) ) = ( dom D6 ) by FINSEQ_1:def 3;
per cases ;
suppose L60: R1 in ( dom D6 );

L61: ( dom ( Del (D6 , R1) ) ) = ( Seg ( len D10 ) ) by FINSEQ_1:def 3;
L62:
now
thus L63: ( len D10 ) = ( len D10 );
L64: D6 <> ( {} ) by L60;
consider C4 being Nat such that L65: ( len D6 ) = ( C4 + 1 ) by L64 , NAT_1:6;
reconsider D12 = C4 as (Element of ( NAT )) by ORDINAL1:def 12;
L66: ( len D10 ) = D12 by L60 , L65 , FINSEQ_3:109;
thus L67: ( len D11 ) = ( len D10 ) by L66 , L55 , L56 , L57 , L59 , L58 , L60 , L65 , FINSEQ_1:6 , FINSEQ_3:109;
let C5 being Nat;
assume L68: C5 in ( dom ( Del (D6 , R1) ) );
L69: C5 <= D12 by L68 , L61 , L66 , FINSEQ_1:1;
per cases ;
suppose L70: C5 < R1;

thus L71: ( D10 . C5 ) = ( D6 . C5 ) by L70 , FINSEQ_3:110
.= ( D9 . C5 ) by L55 , L70 , FUNCT_7:32
.= ( D7 . C5 ) by L70 , FUNCT_7:32
.= ( D11 . C5 ) by L70 , FINSEQ_3:110;
end;
suppose L72: R1 <= C5;

L73: ( C5 + 1 ) > R1 by L72 , NAT_1:13;
thus L74: ( D10 . C5 ) = ( D6 . ( C5 + 1 ) ) by L60 , L65 , L69 , L72 , FINSEQ_3:111
.= ( D9 . ( C5 + 1 ) ) by L55 , L73 , FUNCT_7:32
.= ( D7 . ( C5 + 1 ) ) by L73 , FUNCT_7:32
.= ( D11 . C5 ) by L55 , L56 , L57 , L59 , L58 , L60 , L65 , L69 , L72 , FINSEQ_1:6 , FINSEQ_3:111;
end;
end;
thus L76: thesis by L62 , FINSEQ_2:9;
end;
suppose L77: (not R1 in ( dom D6 ));

L78: D8 = D6 by L77 , FUNCT_7:def 3;
thus L79: thesis by L78 , L55 , L57 , L77 , FUNCT_7:def 3;
end;
end;
theorem
L81: (for R11 being set holds ( ( 0 ) -tuples_on R11 ) = { ( {} ) })
proof
let R11 being set;
set D13 = { B1 where B1 is (Element of ( R11 * )) : ( len B1 ) = ( 0 ) };
L82:
now
let C6 being set;
thus L83:now
assume L84: C6 in D13;
consider C7 being (Element of ( R11 * )) such that L85: C6 = C7 and L86: ( len C7 ) = ( 0 ) by L84;
L87: C7 = ( {} ) by L86;
thus L88: C6 in { ( {} ) } by L87 , L85 , TARSKI:def 1;
end;
assume L89: C6 in { ( {} ) };
L90: C6 = ( {} ) by L89 , TARSKI:def 1;
L91: ( <*> ( R11 * ) ) is (Element of ( R11 * )) by FINSEQ_1:49;
thus L92: C6 in D13 by L91 , L90 , CARD_1:27;
end;
thus L93: thesis by L82 , TARSKI:1;
end;
theorem
L94: (for R6 being (Element of ( NAT )) holds (R6 <> ( 0 ) implies ( R6 -tuples_on ( {} ) ) = ( {} )))
proof
let R6 being (Element of ( NAT ));
assume that
L95: R6 <> ( 0 )
and
L96: ( R6 -tuples_on ( {} ) ) <> ( {} );
consider R8 being set such that L97: R8 in ( R6 -tuples_on ( {} ) ) by L96 , XBOOLE_0:def 1;
L98: (ex B2 being (Element of ( ( {} ) * )) st (B2 = R8 & ( len B2 ) = R6)) by L97;
thus L99: contradiction by L98 , L95;
end;
theorem
L100: (for R16 being Function holds (( {} ) in ( rng R16 ) implies <: R16 :> = ( {} )))
proof
let R16 being Function;
L101: ( dom <: R16 :> ) = ( meet ( doms R16 ) ) by FUNCT_6:29
.= ( meet ( rng ( doms R16 ) ) ) by FUNCT_6:def 4;
assume L102: ( {} ) in ( rng R16 );
consider C8 being set such that L103: C8 in ( dom R16 ) and L104: ( R16 . C8 ) = ( {} ) by L102 , FUNCT_1:def 3;
L105: ( dom ( doms R16 ) ) = ( R16 " ( SubFuncs ( rng R16 ) ) ) by FUNCT_6:def 2;
L106: C8 in ( dom ( doms R16 ) ) by L105 , L103 , L104 , FUNCT_6:19;
L107: ( ( doms R16 ) . C8 ) = ( {} ) by L106 , L104 , L105 , FUNCT_5:8 , FUNCT_6:def 2;
thus L108: thesis by L107 , L101 , L106 , FUNCT_1:3 , SETFAM_1:4;
end;
theorem
L109: (for R13 being non  empty set holds (for R16 being Function holds (( rng R16 ) = R13 implies ( rng <: <* R16 *> :> ) = ( 1 -tuples_on R13 ))))
proof
let R13 being non  empty set;
let R16 being Function;
set D14 = R13;
L110: ( dom <: <* R16 *> :> ) = ( dom R16 ) by FINSEQ_3:141;
assume L111: ( rng R16 ) = D14;
L112:
now
let C9 being set;
thus L113:now
assume L114: C9 in ( rng <: <* R16 *> :> );
consider C10 being set such that L115: C10 in ( dom <: <* R16 *> :> ) and L116: ( <: <* R16 *> :> . C10 ) = C9 by L114 , FUNCT_1:def 3;
reconsider D15 = ( R16 . C10 ) as (Element of D14) by L111 , L110 , L115 , FUNCT_1:3;
L117: <* D15 *> is (Element of ( 1 -tuples_on D14 )) by FINSEQ_2:131;
L118: ( <: <* R16 *> :> . C10 ) = <* ( R16 . C10 ) *> by L110 , L115 , FINSEQ_3:141;
thus L119: C9 in ( 1 -tuples_on D14 ) by L118 , L116 , L117;
end;
assume L120: C9 in ( 1 -tuples_on D14 );
L121: C9 is (Tuple of 1 , D14) by L120 , FINSEQ_2:131;
consider C11 being (Element of D14) such that L122: C9 = <* C11 *> by L121 , FINSEQ_2:97;
consider C12 being set such that L123: C12 in ( dom R16 ) and L124: ( R16 . C12 ) = C11 by L111 , FUNCT_1:def 3;
L125: ( <: <* R16 *> :> . C12 ) = <* C11 *> by L123 , L124 , FINSEQ_3:141;
thus L126: C9 in ( rng <: <* R16 *> :> ) by L125 , L110 , L122 , L123 , FUNCT_1:3;
end;
thus L127: thesis by L112 , TARSKI:1;
end;
theorem
L128: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds (for R13 being non  empty set holds ((1 <= R1 & R1 <= ( R6 + 1 )) implies (for B3 being (Element of ( ( R6 + 1 ) -tuples_on R13 )) holds ( Del (B3 , R1) ) in ( R6 -tuples_on R13 ))))))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
let R13 being non  empty set;
set D16 = R13;
assume that
L129: 1 <= R1
and
L130: R1 <= ( R6 + 1 );
let C13 being (Element of ( ( R6 + 1 ) -tuples_on D16 ));
L131: ( len C13 ) = ( R6 + 1 ) by CARD_1:def 7;
L132: R1 in ( dom C13 ) by L131 , L129 , L130 , FINSEQ_3:25;
L133: ( len ( Del (C13 , R1) ) ) = R6 by L132 , L131 , FINSEQ_3:109;
L134: ( Del (C13 , R1) ) is (FinSequence of D16) by FINSEQ_3:105;
L135: ( Del (C13 , R1) ) is (Element of ( R6 -tuples_on D16 )) by L134 , L133 , FINSEQ_2:92;
thus L136: thesis by L135;
end;
theorem
L137: (for B4 being set holds (for B5 being (FinSequenceSet of B4) holds B5 c= ( B4 * )))
proof
let C14 being set;
let C15 being (FinSequenceSet of C14);
let C16 being set;
assume L138: C16 in C15;
L139: C16 is (FinSequence of C14) by L138 , FINSEQ_2:def 3;
thus L140: thesis by L139 , FINSEQ_1:def 11;
end;
begin
definition
let C17 being set;
attr C17 is  compatible
means
:L141: (for B6 , B7 being Function holds ((B6 in C17 & B7 in C17) implies B6 tolerates B7));
end;
registration
cluster non  empty  functional  compatible for set;
existence
proof
set D17 = { ( {} ) };
take D17;
L143: D17 is  compatible
proof
let C18 , C19 being Function;
assume that
L144: C18 in D17
and
L145: C19 in D17;
L146: C18 = ( {} ) by L144 , TARSKI:def 1;
thus L147: thesis by L146 , PARTFUN1:54 , XBOOLE_1:2;
end;
thus L148: thesis by L143;
end;
end;
registration
let C20 being  functional  compatible set;
cluster ( union C20 ) ->  Function-like  Relation-like;
coherence
proof
thus L150: ( union C20 ) is  Function-like
proof
let C21 , C22 , C23 being set;
assume that
L151: [ C21 , C22 ] in ( union C20 )
and
L152: [ C21 , C23 ] in ( union C20 );
consider C24 being set such that L153: [ C21 , C22 ] in C24 and L154: C24 in C20 by L151 , TARSKI:def 4;
consider C25 being set such that L155: [ C21 , C23 ] in C25 and L156: C25 in C20 by L152 , TARSKI:def 4;
reconsider D18 = C24 , D19 = C25 as Function by L154 , L156;
L157: C21 in ( dom D18 ) by L153 , XTUPLE_0:def 12;
L158: ( D18 . C21 ) = C22 by L157 , L153 , FUNCT_1:def 2;
L159: C21 in ( dom D19 ) by L155 , XTUPLE_0:def 12;
L160: ( D19 . C21 ) = C23 by L159 , L155 , FUNCT_1:def 2;
L161: C21 in ( ( dom D18 ) /\ ( dom D19 ) ) by L157 , L159 , XBOOLE_0:def 4;
L162: D18 tolerates D19 by L154 , L156 , L141;
thus L163: thesis by L162 , L158 , L160 , L161 , PARTFUN1:def 4;
end;

thus L164: ( union C20 ) is  Relation-like
proof
let C26 being set;
assume L165: C26 in ( union C20 );
L166: (ex B8 being set st (C26 in B8 & B8 in C20)) by L165 , TARSKI:def 4;
thus L167: thesis by L166 , RELAT_1:def 1;
end;

end;
end;
theorem
L166: (for R11 being set holds (R11 is  functional  compatible iff ( union R11 ) is Function))
proof
let R11 being set;
L167:
now
assume L168: ( union R11 ) is Function;
thus L169: R11 is  functional
proof
let C27 being set;
assume L170: C27 in R11;
L171: C27 is  Function-like
proof
let C28 , C29 , C30 being set;
assume that
L172: [ C28 , C29 ] in C27
and
L173: [ C28 , C30 ] in C27;
L174: [ C28 , C30 ] in ( union R11 ) by L170 , L173 , TARSKI:def 4;
L175: [ C28 , C29 ] in ( union R11 ) by L170 , L172 , TARSKI:def 4;
thus L176: thesis by L175 , L168 , L174 , FUNCT_1:def 1;
end;
L177: C27 is  Relation-like
proof
let C31 being set;
assume L178: C31 in C27;
L179: C31 in ( union R11 ) by L178 , L170 , TARSKI:def 4;
thus L180: thesis by L179 , L168 , RELAT_1:def 1;
end;
thus L181: thesis by L177 , L171;
end;

thus L182: R11 is  compatible
proof
let C32 , C33 being Function;
assume that
L183: C32 in R11
and
L184: C33 in R11;
let C34 being set;
assume L185: C34 in ( ( dom C32 ) /\ ( dom C33 ) );
L186: C34 in ( dom C33 ) by L185 , XBOOLE_0:def 4;
consider C35 being set such that L187: [ C34 , C35 ] in C33 by L186 , XTUPLE_0:def 12;
L188: [ C34 , C35 ] in ( union R11 ) by L184 , L187 , TARSKI:def 4;
L189: C34 in ( dom C32 ) by L185 , XBOOLE_0:def 4;
consider C36 being set such that L190: [ C34 , C36 ] in C32 by L189 , XTUPLE_0:def 12;
L191: [ C34 , C36 ] in ( union R11 ) by L183 , L190 , TARSKI:def 4;
L192: C36 = C35 by L191 , L168 , L188 , FUNCT_1:def 1;
thus L193: ( C32 . C34 ) = C36 by L189 , L190 , FUNCT_1:def 2
.= ( C33 . C34 ) by L186 , L187 , L192 , FUNCT_1:def 2;
end;

end;
thus L183: thesis by L167;
end;
registration
let C37 , C38 being set;
cluster non  empty  compatible for (PFUNC_DOMAIN of C37 , C38);
existence
proof
set D20 = { ( {} ) };
L184: D20 is  compatible
proof
let C39 , C40 being Function;
assume that
L185: C39 in D20
and
L186: C40 in D20;
L187: C39 = ( {} ) by L185 , TARSKI:def 1;
thus L188: thesis by L187 , PARTFUN1:54 , XBOOLE_1:2;
end;
L189:
now
let C41 being (Element of D20);
L190: C41 = ( {} ) by TARSKI:def 1;
thus L191: C41 is (PartFunc of C37 , C38) by L190 , XBOOLE_1:2;
end;
L192: D20 is (PFUNC_DOMAIN of C37 , C38) by L189 , RFUNCT_3:def 3;
thus L193: thesis by L192 , L184;
end;
end;
theorem
L195: (for B9 being non  empty  functional  compatible set holds ( dom ( union B9 ) ) = ( union { ( dom B10 ) where B10 is (Element of B9) : (not contradiction) } ))
proof
let C42 being non  empty  functional  compatible set;
set D21 = { ( dom B11 ) where B11 is (Element of C42) : (not contradiction) };
L196:
now
let C43 being set;
thus L197:now
assume L198: C43 in ( dom ( union C42 ) );
consider C44 being set such that L199: [ C43 , C44 ] in ( union C42 ) by L198 , XTUPLE_0:def 12;
consider C45 being set such that L200: [ C43 , C44 ] in C45 and L201: C45 in C42 by L199 , TARSKI:def 4;
reconsider D22 = C45 as (Element of C42) by L201;
L202: ( dom D22 ) in D21;
L203: C43 in ( dom D22 ) by L200 , XTUPLE_0:def 12;
thus L204: C43 in ( union D21 ) by L203 , L202 , TARSKI:def 4;
end;
assume L205: C43 in ( union D21 );
consider C46 being set such that L206: C43 in C46 and L207: C46 in D21 by L205 , TARSKI:def 4;
consider C47 being (Element of C42) such that L208: C46 = ( dom C47 ) and L209: (not contradiction) by L207;
consider C48 being set such that L210: [ C43 , C48 ] in C47 by L206 , L208 , XTUPLE_0:def 12;
L211: [ C43 , C48 ] in ( union C42 ) by L210 , TARSKI:def 4;
thus L212: C43 in ( dom ( union C42 ) ) by L211 , XTUPLE_0:def 12;
end;
thus L213: thesis by L196 , TARSKI:1;
end;
theorem
L214: (for B12 being  functional  compatible set holds (for B13 being Function holds (B13 in B12 implies (( dom B13 ) c= ( dom ( union B12 ) ) & (for B14 being set holds (B14 in ( dom B13 ) implies ( ( union B12 ) . B14 ) = ( B13 . B14 )))))))
proof
let C49 being  functional  compatible set;
let C50 being Function;
assume that
L215: C50 in C49;
thus L216: ( dom C50 ) c= ( dom ( union C49 ) )
proof
let C51 being set;
assume L217: C51 in ( dom C50 );
consider C52 being set such that L218: [ C51 , C52 ] in C50 by L217 , XTUPLE_0:def 12;
L219: [ C51 , C52 ] in ( union C49 ) by L215 , L218 , TARSKI:def 4;
thus L220: thesis by L219 , XTUPLE_0:def 12;
end;

let C53 being set;
assume L221: C53 in ( dom C50 );
consider C54 being set such that L222: [ C53 , C54 ] in C50 by L221 , XTUPLE_0:def 12;
L223: [ C53 , C54 ] in ( union C49 ) by L215 , L222 , TARSKI:def 4;
thus L224: ( ( union C49 ) . C53 ) = C54 by L223 , FUNCT_1:1
.= ( C50 . C53 ) by L222 , FUNCT_1:1;
end;
theorem
L225: (for B15 being non  empty  functional  compatible set holds ( rng ( union B15 ) ) = ( union { ( rng B16 ) where B16 is (Element of B15) : (not contradiction) } ))
proof
let C55 being non  empty  functional  compatible set;
set D23 = { ( rng B17 ) where B17 is (Element of C55) : (not contradiction) };
L226:
now
let C56 being set;
thus L227:now
assume L228: C56 in ( rng ( union C55 ) );
consider C57 being set such that L229: [ C57 , C56 ] in ( union C55 ) by L228 , XTUPLE_0:def 13;
consider C58 being set such that L230: [ C57 , C56 ] in C58 and L231: C58 in C55 by L229 , TARSKI:def 4;
reconsider D24 = C58 as (Element of C55) by L231;
L232: ( rng D24 ) in D23;
L233: C56 in ( rng D24 ) by L230 , XTUPLE_0:def 13;
thus L234: C56 in ( union D23 ) by L233 , L232 , TARSKI:def 4;
end;
assume L235: C56 in ( union D23 );
consider C59 being set such that L236: C56 in C59 and L237: C59 in D23 by L235 , TARSKI:def 4;
consider C60 being (Element of C55) such that L238: C59 = ( rng C60 ) and L239: (not contradiction) by L237;
consider C61 being set such that L240: [ C61 , C56 ] in C60 by L236 , L238 , XTUPLE_0:def 13;
L241: [ C61 , C56 ] in ( union C55 ) by L240 , TARSKI:def 4;
thus L242: C56 in ( rng ( union C55 ) ) by L241 , XTUPLE_0:def 13;
end;
thus L243: thesis by L226 , TARSKI:1;
end;
registration
let R11 being set;
let R12 being set;
cluster  ->  functional for (PFUNC_DOMAIN of R11 , R12);
coherence
proof
let C62 being (PFUNC_DOMAIN of R11 , R12);
let C63 being set;
assume L244: C63 in C62;
thus L245: thesis by L244 , RFUNCT_3:def 3;
end;
end;
theorem
L247: (for R11 being set holds (for R12 being set holds (for B18 being  compatible (PFUNC_DOMAIN of R11 , R12) holds ( union B18 ) is (PartFunc of R11 , R12))))
proof
let R11 being set;
let R12 being set;
let C64 being  compatible (PFUNC_DOMAIN of R11 , R12);
set D25 = { ( dom B19 ) where B19 is (Element of C64) : (not contradiction) };
set D26 = { ( rng B20 ) where B20 is (Element of C64) : (not contradiction) };
reconsider D27 = ( union C64 ) as Function;
L248: ( rng D27 ) c= R12
proof
let C65 being set;
assume L249: C65 in ( rng D27 );
L250: C65 in ( union D26 ) by L249 , L225;
consider C66 being set such that L251: C65 in C66 and L252: C66 in D26 by L250 , TARSKI:def 4;
consider C67 being (Element of C64) such that L253: C66 = ( rng C67 ) and L254: (not contradiction) by L252;
L255: ( rng C67 ) c= R12 by RELAT_1:def 19;
thus L256: thesis by L255 , L251 , L253;
end;
L257: ( dom D27 ) c= R11
proof
let C68 being set;
assume L258: C68 in ( dom D27 );
L259: C68 in ( union D25 ) by L258 , L195;
consider C69 being set such that L260: C68 in C69 and L261: C69 in D25 by L259 , TARSKI:def 4;
L262: (ex B21 being (Element of C64) st (C69 = ( dom B21 ) & (not contradiction))) by L261;
thus L263: thesis by L262 , L260;
end;
thus L264: thesis by L257 , L248 , RELSET_1:4;
end;
begin
notation
let C70 being Relation;
synonym C70 is  to-naturals for C70 is  natural-valued;
end;
registration
cluster ( ( NAT ) * ) -defined  to-naturals for Function;
existence
proof
take D28 = ( {} );
thus L266: ( dom D28 ) c= ( ( NAT ) * ) by XBOOLE_1:2;
thus L267: thesis;
end;
end;
definition
let C71 being ( ( NAT ) * ) -defined Relation;
attr C71 is  len-total
means
:L269: (for B22 , B23 being (FinSequence of ( NAT )) holds ((( len B22 ) = ( len B23 ) & B22 in ( dom C71 )) implies B23 in ( dom C71 )));
end;
theorem
L271: (for R6 being (Element of ( NAT )) holds (for R13 being non  empty set holds (for R15 being Relation holds (( dom R15 ) c= ( R6 -tuples_on R13 ) implies R15 is  homogeneous))))
proof
let R6 being (Element of ( NAT ));
let R13 being non  empty set;
let R15 being Relation;
assume L272: ( dom R15 ) c= ( R6 -tuples_on R13 );
thus L273: ( dom R15 ) is  with_common_domain by L272;
end;
registration
cluster  empty ->  homogeneous for Relation;
coherence
proof
let C72 being Relation;
assume that
L274: C72 is  empty;
thus L275: ( dom C72 ) is  with_common_domain by L274;
end;
end;
registration
let C73 being FinSequence;
let C74 being set;
cluster ( C73 .--> C74 ) -> non  empty  homogeneous;
coherence
proof
set D29 = ( C73 .--> C74 );
thus L277: D29 is non  empty;
thus L278: ( dom ( C73 .--> C74 ) ) is  with_common_domain;
end;
end;
registration
cluster non  empty  homogeneous for Function;
existence
proof
set D30 = the FinSequence;
take ( D30 .--> ( 0 ) );
thus L280: thesis;
end;
end;
registration
let C75 being  homogeneous Function;
let C76 being Function;
cluster ( C76 * C75 ) ->  homogeneous;
coherence
proof
L282: ( dom ( C76 * C75 ) ) c= ( dom C75 ) by RELAT_1:25;
thus L283: ( dom ( C76 * C75 ) ) is  with_common_domain by L282;
end;
end;
registration
let C77 , C78 being set;
cluster  homogeneous for (PartFunc of ( C77 * ) , C78);
existence
proof
set D31 = ( {} );
reconsider D32 = D31 as (PartFunc of ( C77 * ) , C78) by XBOOLE_1:2;
take D32;
thus L285: ( dom D32 ) is  with_common_domain;
end;
end;
registration
let C79 , C80 being non  empty set;
cluster non  empty  homogeneous for (PartFunc of ( C79 * ) , C80);
existence
proof
set D33 = the (Element of C80);
reconsider D34 = ( ( 0 ) -tuples_on C79 ) as non  empty (Subset of ( C79 * )) by L137;
reconsider D35 = ( D34 --> D33 ) as (PartFunc of ( C79 * ) , C80);
take D35;
thus L287: D35 is non  empty;
thus L288: ( dom D35 ) is  with_common_domain by FUNCOP_1:13;
end;
end;
registration
let C81 being non  empty set;
cluster non  empty  homogeneous  quasi_total for (PartFunc of ( C81 * ) , C81);
existence
proof
set D36 = the (Element of ( NAT ));
set D37 = the (Element of C81);
reconsider D38 = ( D36 -tuples_on C81 ) as non  empty (Subset of ( C81 * )) by L137;
reconsider D39 = ( D38 --> D37 ) as (PartFunc of ( C81 * ) , C81);
take D39;
thus L290: D39 is non  empty;
L291: ( dom D39 ) = D38 by FUNCOP_1:13;
thus L292: D39 is  homogeneous
proof
thus L293: ( dom D39 ) is  with_common_domain by L291;
end;

let C82 , C83 being (FinSequence of C81);
assume that
L294: ( len C82 ) = ( len C83 )
and
L295: C82 in ( dom D39 );
L296: ( len C83 ) = D36 by L291 , L294 , L295 , CARD_1:def 7;
L297: C83 is (Element of D38) by L296 , FINSEQ_2:92;
thus L298: thesis by L297 , L291;
end;
end;
registration
cluster non  empty  homogeneous  to-naturals  len-total for ( ( NAT ) * ) -defined ( ( NAT ) * ) -defined ( ( NAT ) * ) -defined ( ( NAT ) * ) -defined Function;
existence
proof
reconsider D40 = ( ( 0 ) -tuples_on ( NAT ) ) as non  empty (Subset of ( ( NAT ) * )) by L137;
set D41 = ( D40 --> ( 0 ) );
L300: ( dom D41 ) = D40 by FUNCOP_1:13;
reconsider D42 = D41 as ( ( NAT ) * ) -defined Function;
L301: D42 is  len-total
proof
let C84 , C85 being (FinSequence of ( NAT ));
assume that
L302: ( len C84 ) = ( len C85 )
and
L303: C84 in ( dom D42 );
L304: C85 is (Element of ( ( len C85 ) -tuples_on ( NAT ) )) by FINSEQ_2:92;
L305: ( len C84 ) = ( 0 ) by L300 , L303;
thus L306: thesis by L305 , L300 , L302 , L304;
end;
take D42;
L307: D42 is  homogeneous
proof
thus L308: ( dom D42 ) is  with_common_domain by FUNCOP_1:13;
end;
thus L309: thesis by L307 , L301;
end;
end;
registration
cluster  ->  to-naturals ( ( NAT ) * ) -defined for (PartFunc of ( ( NAT ) * ) , ( NAT ));
coherence;
end;
registration
cluster  quasi_total ->  len-total for (PartFunc of ( ( NAT ) * ) , ( NAT ));
coherence
proof
let C86 being (PartFunc of ( ( NAT ) * ) , ( NAT ));
assume L312: C86 is  quasi_total;
let C87 , C88 being (FinSequence of ( NAT ));
assume that
L313: ( len C87 ) = ( len C88 )
and
L314: C87 in ( dom C86 );
thus L315: C88 in ( dom C86 ) by L312 , L313 , L314 , MARGREL1:def 22;
end;
end;
theorem
L317: (for B24 being  len-total  to-naturals ( ( NAT ) * ) -defined Function holds B24 is  quasi_total  quasi_total  quasi_total  quasi_total (PartFunc of ( ( NAT ) * ) , ( NAT )))
proof
let C89 being  len-total  to-naturals ( ( NAT ) * ) -defined Function;
L318: ( rng C89 ) c= ( NAT ) by VALUED_0:def 6;
L319: ( dom C89 ) c= ( ( NAT ) * );
reconsider D43 = C89 as (PartFunc of ( ( NAT ) * ) , ( NAT )) by L319 , L318 , RELSET_1:4;
L320: (for B25 , B26 being (FinSequence of ( NAT )) holds ((( len B25 ) = ( len B26 ) & B25 in ( dom C89 )) implies B26 in ( dom C89 ))) by L269;
L321: D43 is  quasi_total by L320 , MARGREL1:def 22;
thus L322: thesis by L321;
end;
theorem
L323: ( arity ( {} ) ) = ( 0 )
proof
L324: (not (ex B27 being FinSequence st B27 in ( dom ( {} ) )));
thus L325: thesis by L324 , MARGREL1:def 25;
end;
theorem
L326: (for B28 being  homogeneous Relation holds (( dom B28 ) = { ( {} ) } implies ( arity B28 ) = ( 0 )))
proof
let C90 being  homogeneous Relation;
assume L327: ( dom C90 ) = { ( {} ) };
L328: ( {} ) in ( dom C90 ) by L327 , TARSKI:def 1;
thus L329: thesis by L328 , CARD_1:27 , MARGREL1:def 25;
end;
theorem
L330: (for R11 being set holds (for R12 being set holds (for B29 being  homogeneous (PartFunc of ( R11 * ) , R12) holds ( dom B29 ) c= ( ( arity B29 ) -tuples_on R11 ))))
proof
let R11 being set;
let R12 being set;
let C91 being  homogeneous (PartFunc of ( R11 * ) , R12);
let C92 being set;
assume L331: C92 in ( dom C91 );
per cases ;
suppose L332: R11 is  empty;

L333: C92 = ( <*> ( R11 * ) ) by L332 , L331 , FUNCT_7:17 , TARSKI:def 1;
L334: ( arity C91 ) = ( len ( <*> ( R11 * ) ) ) by L333 , L331 , MARGREL1:def 25;
L335: ( ( 0 ) -tuples_on R11 ) = { ( {} ) } by L81;
thus L336: thesis by L335 , L331 , L332 , L334 , FUNCT_7:17;
end;
suppose L337: R11 is non  empty;

reconsider D44 = R11 as non  empty set by L337;
reconsider D45 = C92 as (FinSequence of D44) by L331 , FINSEQ_1:def 11;
L338: ( len D45 ) = ( arity C91 ) by L331 , MARGREL1:def 25;
L339: D45 is (Element of ( ( arity C91 ) -tuples_on D44 )) by L338 , FINSEQ_2:92;
thus L340: thesis by L339;
end;
end;
theorem
L342: (for B30 being  homogeneous ( ( NAT ) * ) -defined Function holds ( dom B30 ) c= ( ( arity B30 ) -tuples_on ( NAT ) ))
proof
let C93 being  homogeneous ( ( NAT ) * ) -defined Function;
let C94 being set;
assume L343: C94 in ( dom C93 );
reconsider D46 = C94 as (FinSequence of ( NAT )) by L343 , FINSEQ_1:def 11;
L344: ( len D46 ) = ( arity C93 ) by L343 , MARGREL1:def 25;
L345: D46 is (Element of ( ( arity C93 ) -tuples_on ( NAT ) )) by L344 , FINSEQ_2:92;
thus L346: thesis by L345;
end;
L347: (for R13 being non  empty set holds (for B31 being  homogeneous (PartFunc of ( R13 * ) , R13) holds (B31 is  quasi_total non  empty iff ( dom B31 ) = ( ( arity B31 ) -tuples_on R13 ))))
proof
let R13 being non  empty set;
set D47 = R13;
let C95 being  homogeneous (PartFunc of ( D47 * ) , D47);
L348: ( dom C95 ) c= ( ( arity C95 ) -tuples_on D47 ) by L330;
thus L349:now
assume L350: C95 is  quasi_total non  empty;
reconsider D48 = C95 as  quasi_total non  empty  homogeneous (PartFunc of ( D47 * ) , D47) by L350;
consider C96 being set such that L351: C96 in ( dom D48 ) by XBOOLE_0:def 1;
reconsider D49 = C96 as (FinSequence of D47) by L351 , FINSEQ_1:def 11;
L352: ( len D49 ) = ( arity C95 ) by L351 , MARGREL1:def 25;
L353:
now
let C97 being set;
thus L354: (C97 in ( dom C95 ) implies C97 in ( ( arity C95 ) -tuples_on D47 )) by L348;
assume L355: C97 in ( ( arity C95 ) -tuples_on D47 );
reconsider D50 = C97 as (Element of ( ( arity C95 ) -tuples_on D47 )) by L355;
L356: ( len D50 ) = ( arity C95 ) by CARD_1:def 7;
thus L357: C97 in ( dom C95 ) by L356 , L351 , L352 , MARGREL1:def 22;
end;
thus L358: ( dom C95 ) = ( ( arity C95 ) -tuples_on D47 ) by L353 , TARSKI:1;
end;
assume L359: ( dom C95 ) = ( ( arity C95 ) -tuples_on D47 );
thus L360: C95 is  quasi_total
proof
let C98 , C99 being (FinSequence of D47);
assume that
L361: ( len C98 ) = ( len C99 )
and
L362: C98 in ( dom C95 );
L363: ( len C98 ) = ( arity C95 ) by L359 , L362 , CARD_1:def 7;
L364: C99 is (Element of ( ( arity C95 ) -tuples_on D47 )) by L363 , L361 , FINSEQ_2:92;
thus L365: C99 in ( dom C95 ) by L364 , L359;
end;

thus L366: thesis by L359;
end;
theorem
L367: (for R11 being set holds (for B32 being  homogeneous (PartFunc of ( R11 * ) , R11) holds (B32 is  quasi_total non  empty iff ( dom B32 ) = ( ( arity B32 ) -tuples_on R11 ))))
proof
let R11 being set;
let C100 being  homogeneous (PartFunc of ( R11 * ) , R11);
per cases ;
suppose L368: R11 is  empty;

L369: C100 = ( {} ) by L368;
thus L370: thesis by L369 , L81 , L323;
end;
suppose L371: R11 is non  empty;

thus L372: thesis by L371 , L347;
end;
end;
theorem
L374: (for B33 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (B33 is  len-total non  empty iff ( dom B33 ) = ( ( arity B33 ) -tuples_on ( NAT ) )))
proof
let C101 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
L375: ( dom C101 ) c= ( ( arity C101 ) -tuples_on ( NAT ) ) by L342;
thus L376:now
assume L377: C101 is  len-total non  empty;
reconsider D51 = C101 as  quasi_total non  empty  homogeneous (PartFunc of ( ( NAT ) * ) , ( NAT )) by L377 , L317;
consider C102 being set such that L378: C102 in ( dom D51 ) by XBOOLE_0:def 1;
reconsider D52 = C102 as (FinSequence of ( NAT )) by L378 , FINSEQ_1:def 11;
L379: ( len D52 ) = ( arity C101 ) by L378 , MARGREL1:def 25;
L380:
now
let C103 being set;
thus L381: (C103 in ( dom C101 ) implies C103 in ( ( arity C101 ) -tuples_on ( NAT ) )) by L375;
assume L382: C103 in ( ( arity C101 ) -tuples_on ( NAT ) );
reconsider D53 = C103 as (Element of ( ( arity C101 ) -tuples_on ( NAT ) )) by L382;
L383: ( len D53 ) = ( arity C101 ) by CARD_1:def 7;
thus L384: C103 in ( dom C101 ) by L383 , L378 , L379 , MARGREL1:def 22;
end;
thus L385: ( dom C101 ) = ( ( arity C101 ) -tuples_on ( NAT ) ) by L380 , TARSKI:1;
end;
assume L386: ( dom C101 ) = ( ( arity C101 ) -tuples_on ( NAT ) );
thus L387: C101 is  len-total
proof
let C104 , C105 being (FinSequence of ( NAT ));
assume that
L388: ( len C104 ) = ( len C105 )
and
L389: C104 in ( dom C101 );
L390: ( len C104 ) = ( arity C101 ) by L386 , L389 , CARD_1:def 7;
L391: C105 is (Element of ( ( arity C101 ) -tuples_on ( NAT ) )) by L390 , L388 , FINSEQ_2:92;
thus L392: thesis by L391 , L386;
end;

thus L393: thesis by L386;
end;
theorem
L394: (for R13 being non  empty set holds (for B34 being non  empty  homogeneous (PartFunc of ( R13 * ) , R13) holds (for R6 being (Element of ( NAT )) holds (( dom B34 ) c= ( R6 -tuples_on R13 ) implies ( arity B34 ) = R6))))
proof
let R13 being non  empty set;
let C106 being non  empty  homogeneous (PartFunc of ( R13 * ) , R13);
let R6 being (Element of ( NAT ));
consider C107 being set such that L395: C107 in ( dom C106 ) by XBOOLE_0:def 1;
assume L396: ( dom C106 ) c= ( R6 -tuples_on R13 );
L397: (for B35 being FinSequence holds (B35 in ( dom C106 ) implies R6 = ( len B35 ))) by L396 , CARD_1:def 7;
reconsider D54 = C107 as (Element of ( R6 -tuples_on R13 )) by L396 , L395;
L398: D54 in ( dom C106 ) by L395;
thus L399: thesis by L398 , L397 , MARGREL1:def 25;
end;
theorem
L400: (for R13 being non  empty set holds (for B36 being  homogeneous (PartFunc of ( R13 * ) , R13) holds (for R6 being (Element of ( NAT )) holds (( dom B36 ) = ( R6 -tuples_on R13 ) implies ( arity B36 ) = R6))))
proof
let R13 being non  empty set;
let C108 being  homogeneous (PartFunc of ( R13 * ) , R13);
let R6 being (Element of ( NAT ));
consider C109 being set such that L401: C109 in ( R6 -tuples_on R13 ) by XBOOLE_0:def 1;
reconsider D55 = C109 as (Element of ( R6 -tuples_on R13 )) by L401;
assume L402: ( dom C108 ) = ( R6 -tuples_on R13 );
L403: (for B37 being FinSequence holds (B37 in ( dom C108 ) implies ( len B37 ) = R6)) by L402 , CARD_1:def 7;
L404: D55 in ( dom C108 ) by L402;
thus L405: thesis by L404 , L403 , MARGREL1:def 25;
end;
definition
let C110 being Relation;
attr C110 is  with_the_same_arity
means
:L406: (for B38 , B39 being Function holds ((B38 in ( rng C110 ) & B39 in ( rng C110 )) implies ((B38 is  empty implies (B39 is  empty or ( dom B39 ) = { ( {} ) })) & ((B38 is non  empty & B39 is non  empty) implies (ex B40 being (Element of ( NAT )) st (ex B41 being non  empty set st (( dom B38 ) c= ( B40 -tuples_on B41 ) & ( dom B39 ) c= ( B40 -tuples_on B41 ))))))));
end;
registration
cluster  empty ->  with_the_same_arity for Relation;
coherence
proof
let C111 being Relation;
assume that
L408: C111 is  empty;
let C112 , C113 being Function;
thus L409: thesis by L408;
end;
end;
registration
let C114 being set;
cluster  with_the_same_arity for (FinSequence of C114);
existence
proof
take ( <*> C114 );
thus L411: thesis;
end;
cluster  with_the_same_arity for (Element of ( C114 * ));
existence
proof
reconsider D56 = ( <*> C114 ) as (Element of ( C114 * )) by FINSEQ_1:def 11;
take D56;
thus L412: thesis;
end;
end;
definition
let C115 being  with_the_same_arity Relation;
func arity C115 -> (Element of ( NAT )) means 
:L414: (for B42 being  homogeneous Function holds (B42 in ( rng C115 ) implies it = ( arity B42 ))) if (ex B43 being  homogeneous Function st B43 in ( rng C115 )) otherwise it = ( 0 );
existence
proof
thus L415:now
given C116 being  homogeneous Function such that
L416: C116 in ( rng C115 );

take D57 = ( arity C116 );
let C117 being  homogeneous Function;
assume L417: C117 in ( rng C115 );
per cases ;
suppose L418: C116 is  empty;

thus L419: D57 = ( arity C117 )
proof
per cases  by L416 , L417 , L418 , L406;
suppose L420: C117 is  empty;

thus L421: thesis by L420 , L418;
end;
suppose L422: ( dom C117 ) = { ( {} ) };

thus L423: thesis by L422 , L418 , L323 , L326;
end;
end;

end;
suppose L420: C117 is  empty;

thus L421: D57 = ( arity C117 )
proof
per cases  by L416 , L417 , L420 , L406;
suppose L422: C116 is  empty;

thus L423: thesis by L422 , L420;
end;
suppose L424: ( dom C116 ) = { ( {} ) };

thus L425: thesis by L424 , L420 , L323 , L326;
end;
end;

end;
suppose L422: (C116 is non  empty & C117 is non  empty);

set D58 = the (Element of ( dom C116 ));
L423: ( dom C116 ) <> ( {} ) by L422;
L424: D58 in ( dom C116 ) by L423;
consider C118 being (Element of ( NAT )), C119 being non  empty set such that L425: ( dom C116 ) c= ( C118 -tuples_on C119 ) and L426: ( dom C117 ) c= ( C118 -tuples_on C119 ) by L416 , L417 , L422 , L406;
reconsider D59 = D58 as (Element of ( C118 -tuples_on C119 )) by L425 , L424;
L427: ( arity C116 ) = ( len D59 ) by L422 , MARGREL1:def 25
.= C118 by CARD_1:def 7;
set D60 = the (Element of ( dom C117 ));
L428: ( dom C117 ) <> ( {} ) by L422;
L429: D60 in ( dom C117 ) by L428;
reconsider D61 = D60 as (Element of ( C118 -tuples_on C119 )) by L429 , L426;
L430: ( arity C117 ) = ( len D61 ) by L422 , MARGREL1:def 25;
thus L431: D57 = ( arity C117 ) by L430 , L427 , CARD_1:def 7;
end;
end;
thus L433: thesis;
end;
uniqueness
proof
let C120 , C121 being (Element of ( NAT ));
thus L434:now
given C122 being  homogeneous Function such that
L435: C122 in ( rng C115 );

assume L436: (for B44 being  homogeneous Function holds (B44 in ( rng C115 ) implies C120 = ( arity B44 )));
L437: C120 = ( arity C122 ) by L436 , L435;
thus L438: ((for B45 being  homogeneous Function holds (B45 in ( rng C115 ) implies C121 = ( arity B45 ))) implies C120 = C121) by L437 , L435;
end;
thus L439: thesis;
end;
correctness;
end;
theorem
L441: (for B46 being  with_the_same_arity FinSequence holds (( len B46 ) = ( 0 ) implies ( arity B46 ) = ( 0 )))
proof
let C123 being  with_the_same_arity FinSequence;
assume L442: ( len C123 ) = ( 0 );
L443: C123 = ( {} ) by L442;
L444: (for B47 being  homogeneous Function holds (not B47 in ( rng C123 ))) by L443;
thus L445: thesis by L444 , L414;
end;
definition
let C124 being set;
func HFuncs C124 -> (PFUNC_DOMAIN of ( C124 * ) , C124) equals 
{ B48 where B48 is (Element of ( PFuncs (( C124 * ) , C124) )) : B48 is  homogeneous };
coherence
proof
set D62 = { B49 where B49 is (Element of ( PFuncs (( C124 * ) , C124) )) : B49 is  homogeneous };
L446: D62 is non  empty  functional
proof
L447: ( {} ) is (PartFunc of ( C124 * ) , C124) by RELSET_1:12;
L448: ( {} ) in ( PFuncs (( C124 * ) , C124) ) by L447 , PARTFUN1:45;
L449: ( {} ) in D62 by L448;
thus L450: D62 is non  empty by L449;
let C125 being set;
assume L451: C125 in D62;
L452: (ex B50 being (Element of ( PFuncs (( C124 * ) , C124) )) st (C125 = B50 & B50 is  homogeneous)) by L451;
thus L453: thesis by L452;
end;
reconsider D63 = D62 as non  empty  functional set by L446;
L454:
now
let C126 being (Element of D63);
L455: C126 in D63;
L456: (ex B51 being (Element of ( PFuncs (( C124 * ) , C124) )) st (C126 = B51 & B51 is  homogeneous)) by L455;
thus L457: C126 is (PartFunc of ( C124 * ) , C124) by L456;
end;
thus L458: thesis by L454 , RFUNCT_3:def 3;
end;
end;
theorem
L460: (for R11 being set holds ( {} ) in ( HFuncs R11 ))
proof
let R11 being set;
set D64 = ( {} );
reconsider D65 = D64 as (PartFunc of ( R11 * ) , R11) by XBOOLE_1:2;
reconsider D66 = D65 as (Element of ( PFuncs (( R11 * ) , R11) )) by PARTFUN1:45;
L461: D66 in { B52 where B52 is (Element of ( PFuncs (( R11 * ) , R11) )) : B52 is  homogeneous };
thus L462: thesis by L461;
end;
registration
let C127 being non  empty set;
cluster non  empty  homogeneous  quasi_total for (Element of ( HFuncs C127 ));
existence
proof
set D67 = ( <*> C127 );
set D68 = the (Element of C127);
L463: D67 in ( C127 * ) by FINSEQ_1:def 11;
reconsider D69 = { D67 } as (Subset of ( C127 * )) by L463 , ZFMISC_1:31;
L464: ( D69 --> D68 ) in ( PFuncs (( C127 * ) , C127) );
L465: ( D67 .--> D68 ) is  homogeneous;
L466: ( { D67 } --> D68 ) in { B53 where B53 is (Element of ( PFuncs (( C127 * ) , C127) )) : B53 is  homogeneous } by L465 , L464;
reconsider D70 = ( D67 .--> D68 ) as (Element of ( HFuncs C127 )) by L466;
take D70;
L467: ( dom D70 ) = { D67 } by FUNCOP_1:13;
thus L468: D70 is non  empty  homogeneous;
let C128 , C129 being (FinSequence of C127);
assume that
L469: ( len C128 ) = ( len C129 );
assume L470: C128 in ( dom D70 );
L471: C128 = D67 by L470 , L467 , TARSKI:def 1;
L472: C129 = ( {} ) by L471 , L469;
thus L473: thesis by L472 , L467 , TARSKI:def 1;
end;
end;
registration
let C130 being set;
cluster  ->  homogeneous for (Element of ( HFuncs C130 ));
coherence
proof
let C131 being (Element of ( HFuncs C130 ));
L475: C131 in ( HFuncs C130 );
L476: (ex B54 being (Element of ( PFuncs (( C130 * ) , C130) )) st (C131 = B54 & B54 is  homogeneous)) by L475;
thus L477: thesis by L476;
end;
end;
registration
let C132 being non  empty set;
let C133 being non  empty (Subset of ( HFuncs C132 ));
cluster  ->  homogeneous for (Element of C133);
coherence;
end;
theorem
L480: (for B55 being  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds B55 is (Element of ( HFuncs ( NAT ) )))
proof
let C134 being  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
L481: ( rng C134 ) c= ( NAT ) by VALUED_0:def 6;
L482: ( dom C134 ) c= ( ( NAT ) * );
L483: C134 is (PartFunc of ( ( NAT ) * ) , ( NAT )) by L482 , L481 , RELSET_1:4;
reconsider D71 = C134 as (Element of ( PFuncs (( ( NAT ) * ) , ( NAT )) )) by L483 , PARTFUN1:45;
L484: D71 in { B56 where B56 is (Element of ( PFuncs (( ( NAT ) * ) , ( NAT )) )) : B56 is  homogeneous };
thus L485: thesis by L484;
end;
theorem
L486: (for B57 being  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds B57 is  quasi_total  quasi_total  quasi_total  quasi_total (Element of ( HFuncs ( NAT ) )))
proof
let C135 being  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
reconsider D72 = C135 as (Element of ( HFuncs ( NAT ) )) by L480;
L487: D72 is  quasi_total
proof
let C136 , C137 being (FinSequence of ( NAT ));
assume that
L488: ( len C136 ) = ( len C137 )
and
L489: C136 in ( dom D72 );
thus L490: C137 in ( dom D72 ) by L488 , L489 , L269;
end;
thus L491: thesis by L487;
end;
theorem
L492: (for B58 being non  empty set holds (for B59 being Relation holds ((( rng B59 ) c= ( HFuncs B58 ) & (for B60 , B61 being  homogeneous Function holds ((B60 in ( rng B59 ) & B61 in ( rng B59 )) implies ( arity B60 ) = ( arity B61 )))) implies B59 is  with_the_same_arity)))
proof
let C138 being non  empty set;
let C139 being Relation;
assume that
L493: ( rng C139 ) c= ( HFuncs C138 )
and
L494: (for B62 , B63 being  homogeneous Function holds ((B62 in ( rng C139 ) & B63 in ( rng C139 )) implies ( arity B62 ) = ( arity B63 )));
let C140 , C141 being Function;
assume that
L495: C140 in ( rng C139 )
and
L496: C141 in ( rng C139 );
reconsider D73 = C140 , D74 = C141 as (Element of ( HFuncs C138 )) by L493 , L495 , L496;
L497: ( arity D73 ) = ( arity D74 ) by L494 , L495 , L496;
thus L498:now
assume L499: C140 is  empty;
L500: ( dom D74 ) c= ( ( 0 ) -tuples_on C138 ) by L499 , L497 , L323 , L330;
L501: ( dom D74 ) c= { ( <*> C138 ) } by L500 , FINSEQ_2:94;
thus L502: (C141 is  empty or ( dom C141 ) = { ( {} ) }) by L501 , ZFMISC_1:33;
end;
assume that
L503: C140 is non  empty
and
L504: C141 is non  empty;
reconsider D75 = D73 as non  empty (Element of ( HFuncs C138 )) by L503;
take ( arity D75 );
take C138;
thus L505: thesis by L497 , L330;
end;
definition
let C142 , C143 being (Element of ( NAT ));
func C142 const C143 ->  homogeneous  to-naturals ( ( NAT ) * ) -defined Function equals 
( ( C142 -tuples_on ( NAT ) ) --> C143 );
coherence
proof
set D76 = ( NAT );
set D77 = ( ( C142 -tuples_on D76 ) --> C143 );
L506: ( C142 -tuples_on D76 ) c= ( D76 * ) by FINSEQ_2:142;
L507: ( dom D77 ) = ( C142 -tuples_on D76 ) by FUNCOP_1:13;
L508: D77 is  homogeneous
proof
thus L509: ( dom D77 ) is  with_common_domain;
end;
thus L510: thesis by L508 , L506 , L507 , RELAT_1:def 18;
end;
end;
theorem
L512: (for R5 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds ( R6 const R5 ) in ( HFuncs ( NAT ) )))
proof
let R5 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
set D78 = ( NAT );
set D79 = ( R6 const R5 );
L513: ( rng D79 ) c= ( NAT ) by VALUED_0:def 6;
L514: ( dom D79 ) c= ( ( NAT ) * );
L515: D79 is (PartFunc of ( D78 * ) , D78) by L514 , L513 , RELSET_1:4;
L516: D79 is (Element of ( PFuncs (( D78 * ) , D78) )) by L515 , PARTFUN1:45;
thus L517: thesis by L516;
end;
registration
let C144 , C145 being (Element of ( NAT ));
cluster ( C144 const C145 ) ->  len-total non  empty;
coherence
proof
set D80 = ( NAT );
L518: ( dom ( C144 const C145 ) ) = ( C144 -tuples_on D80 ) by FUNCOP_1:13;
L519: ( C144 const C145 ) is  len-total
proof
let C146 , C147 being (FinSequence of D80);
assume that
L520: ( len C146 ) = ( len C147 )
and
L521: C146 in ( dom ( C144 const C145 ) );
L522: ( len C146 ) = C144 by L518 , L521 , CARD_1:def 7;
L523: C147 is (Element of ( C144 -tuples_on D80 )) by L522 , L520 , FINSEQ_2:92;
thus L524: thesis by L523 , L518;
end;
thus L525: thesis by L519;
end;
end;
theorem
L527: (for R5 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds ( arity ( R6 const R5 ) ) = R6))
proof
let R5 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
set D81 = ( NAT );
set D82 = the (Element of ( R6 -tuples_on D81 ));
L528: ( dom ( R6 const R5 ) ) = ( R6 -tuples_on D81 ) by FUNCOP_1:13;
L529: (for B64 being FinSequence holds (B64 in ( dom ( R6 const R5 ) ) implies R6 = ( len B64 ))) by L528 , CARD_1:def 7;
L530: D82 in ( dom ( R6 const R5 ) ) by L528;
thus L531: thesis by L530 , L529 , MARGREL1:def 25;
end;
registration
cluster  ->  homogeneous  to-naturals ( ( NAT ) * ) -defined for (Element of ( HFuncs ( NAT ) ));
coherence;
end;
definition
let C148 , C149 being (Element of ( NAT ));
func C148 succ C149 ->  homogeneous  to-naturals ( ( NAT ) * ) -defined Function means 
:L533: (( dom it ) = ( C148 -tuples_on ( NAT ) ) & (for B65 being (Element of ( C148 -tuples_on ( NAT ) )) holds ( it . B65 ) = ( ( B65 /. C149 ) + 1 )));
existence
proof
deffunc H1((Element of ( ( NAT ) * ))) = ( ( $1 /. C149 ) + 1 );
defpred S1[ set ] means $1 in ( C148 -tuples_on ( NAT ) );
consider C150 being (PartFunc of ( ( NAT ) * ) , ( NAT )) such that L534: (for B66 being (Element of ( ( NAT ) * )) holds (B66 in ( dom C150 ) iff S1[ B66 ])) and L535: (for B67 being (Element of ( ( NAT ) * )) holds (B67 in ( dom C150 ) implies ( C150 /. B67 ) = H1(B67))) from PARTFUN2:sch 2;
L536: ( C148 -tuples_on ( NAT ) ) c= ( ( NAT ) * ) by FINSEQ_2:142;
L537: (for B68 being set holds (B68 in ( dom C150 ) iff B68 in ( C148 -tuples_on ( NAT ) ))) by L536 , L534;
L538: ( dom C150 ) = ( C148 -tuples_on ( NAT ) ) by L537 , TARSKI:1;
reconsider D83 = C150 as (Element of ( PFuncs (( ( NAT ) * ) , ( NAT )) )) by PARTFUN1:45;
L539: D83 is  homogeneous
proof
thus L540: ( dom D83 ) is  with_common_domain by L538;
end;
L541: D83 in { B69 where B69 is (Element of ( PFuncs (( ( NAT ) * ) , ( NAT )) )) : B69 is  homogeneous } by L539;
reconsider D84 = D83 as (Element of ( HFuncs ( NAT ) )) by L541;
take D84;
thus L542: ( dom D84 ) = ( C148 -tuples_on ( NAT ) ) by L537 , TARSKI:1;
let C151 being (Element of ( C148 -tuples_on ( NAT ) ));
L543: C151 in ( C148 -tuples_on ( NAT ) );
reconsider D85 = C151 as (Element of ( ( NAT ) * )) by L543 , L536;
thus L544: ( D84 . C151 ) = ( D84 /. D85 ) by L538 , PARTFUN1:def 6
.= ( ( C151 /. C149 ) + 1 ) by L535 , L538;
end;
uniqueness
proof
let C152 , C153 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L545: ( dom C152 ) = ( C148 -tuples_on ( NAT ) )
and
L546: (for B70 being (Element of ( C148 -tuples_on ( NAT ) )) holds ( C152 . B70 ) = ( ( B70 /. C149 ) + 1 ))
and
L547: ( dom C153 ) = ( C148 -tuples_on ( NAT ) )
and
L548: (for B71 being (Element of ( C148 -tuples_on ( NAT ) )) holds ( C153 . B71 ) = ( ( B71 /. C149 ) + 1 ));
L549:
now
let C154 being set;
assume L550: C154 in ( C148 -tuples_on ( NAT ) );
reconsider D86 = C154 as (Element of ( C148 -tuples_on ( NAT ) )) by L550;
thus L551: ( C152 . C154 ) = ( ( D86 /. C149 ) + 1 ) by L546
.= ( C153 . C154 ) by L548;
end;
thus L552: thesis by L549 , L545 , L547 , FUNCT_1:2;
end;
end;
theorem
L554: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds ( R6 succ R1 ) in ( HFuncs ( NAT ) )))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
set D87 = ( NAT );
set D88 = ( R6 succ R1 );
L555: ( rng D88 ) c= ( NAT ) by VALUED_0:def 6;
L556: ( dom D88 ) c= ( ( NAT ) * );
L557: D88 is (PartFunc of ( D87 * ) , D87) by L556 , L555 , RELSET_1:4;
L558: D88 is (Element of ( PFuncs (( D87 * ) , D87) )) by L557 , PARTFUN1:45;
thus L559: thesis by L558;
end;
registration
let C155 , C156 being (Element of ( NAT ));
cluster ( C155 succ C156 ) ->  len-total non  empty;
coherence
proof
L560: ( dom ( C155 succ C156 ) ) = ( C155 -tuples_on ( NAT ) ) by L533;
L561: ( C155 succ C156 ) is  len-total
proof
let C157 , C158 being (FinSequence of ( NAT ));
assume that
L562: ( len C157 ) = ( len C158 )
and
L563: C157 in ( dom ( C155 succ C156 ) );
L564: ( len C157 ) = C155 by L560 , L563 , CARD_1:def 7;
L565: C158 is (Element of ( C155 -tuples_on ( NAT ) )) by L564 , L562 , FINSEQ_2:92;
thus L566: thesis by L565 , L560;
end;
thus L567: thesis by L561 , L560;
end;
end;
theorem
L569: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds ( arity ( R6 succ R1 ) ) = R6))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
consider C159 being set such that L570: C159 in ( dom ( R6 succ R1 ) ) by XBOOLE_0:def 1;
reconsider D89 = C159 as (Element of ( R6 -tuples_on ( NAT ) )) by L570 , L533;
L571: ( dom ( R6 succ R1 ) ) = ( R6 -tuples_on ( NAT ) ) by L533;
L572: (for B72 being FinSequence holds (B72 in ( dom ( R6 succ R1 ) ) implies R6 = ( len B72 ))) by L571 , CARD_1:def 7;
L573: D89 in ( dom ( R6 succ R1 ) ) by L570;
thus L574: thesis by L573 , L572 , MARGREL1:def 25;
end;
definition
let C160 , C161 being (Element of ( NAT ));
func C160 proj C161 ->  homogeneous  to-naturals ( ( NAT ) * ) -defined Function equals 
( proj (( C160 |-> ( NAT ) ) , C161) );
correctness
proof
L575: ( dom ( proj (( C160 |-> ( NAT ) ) , C161) ) ) = ( product ( C160 |-> ( NAT ) ) ) by CARD_3:def 16
.= ( C160 -tuples_on ( NAT ) ) by FINSEQ_3:131;
L576:
now
set D90 = ( proj (( C160 |-> ( NAT ) ) , C161) );
L577: ( rng D90 ) c= ( NAT )
proof
let C162 being set;
assume L578: C162 in ( rng D90 );
consider C163 being set such that L579: C163 in ( dom D90 ) and L580: C162 = ( D90 . C163 ) by L578 , FUNCT_1:def 3;
reconsider D91 = C163 as (Element of ( C160 -tuples_on ( NAT ) )) by L575 , L579;
reconsider D92 = D91 as (FinSequence of ( NAT ));
L581: ( D90 . D92 ) = ( D92 . C161 ) by L579 , CARD_3:def 16;
thus L582: thesis by L581 , L580;
end;
L583: D90 is  homogeneous
proof
thus L584: ( dom D90 ) is  with_common_domain;
end;
reconsider D93 = D90 as (PartFunc of ( ( NAT ) * ) , ( NAT )) by L575 , L577 , FINSEQ_2:142 , RELSET_1:4;
L585: D93 is (Element of ( PFuncs (( ( NAT ) * ) , ( NAT )) )) by PARTFUN1:45;
L586: D93 in ( HFuncs ( NAT ) ) by L585 , L583;
thus L587: ( proj (( C160 |-> ( NAT ) ) , C161) ) is (Element of ( HFuncs ( NAT ) )) by L586;
end;
thus L588: thesis by L576;
end;
end;
theorem
L590: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds ( R6 proj R1 ) in ( HFuncs ( NAT ) )))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
set D94 = ( NAT );
set D95 = ( R6 proj R1 );
L591: ( rng D95 ) c= ( NAT ) by VALUED_0:def 6;
L592: ( dom D95 ) c= ( ( NAT ) * );
L593: D95 is (PartFunc of ( D94 * ) , D94) by L592 , L591 , RELSET_1:4;
L594: D95 is (Element of ( PFuncs (( D94 * ) , D94) )) by L593 , PARTFUN1:45;
thus L595: thesis by L594;
end;
theorem
L596: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds (( dom ( R6 proj R1 ) ) = ( R6 -tuples_on ( NAT ) ) & ((1 <= R1 & R1 <= R6) implies ( rng ( R6 proj R1 ) ) = ( NAT )))))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
thus L597: ( dom ( R6 proj R1 ) ) = ( product ( R6 |-> ( NAT ) ) ) by CARD_3:def 16
.= ( R6 -tuples_on ( NAT ) ) by FINSEQ_3:131;
assume that
L598: 1 <= R1
and
L599: R1 <= R6;
L600:
now
let C164 being set;
thus L601:now
assume L602: C164 in ( rng ( R6 proj R1 ) );
consider C165 being set such that L603: C165 in ( dom ( R6 proj R1 ) ) and L604: C164 = ( ( R6 proj R1 ) . C165 ) by L602 , FUNCT_1:def 3;
thus L605: C164 in ( NAT ) by L604;
end;
assume L606: C164 in ( NAT );
reconsider D96 = C164 as (Element of ( NAT )) by L606;
reconsider D97 = ( R6 |-> D96 ) as (FinSequence of ( NAT ));
L607: R1 in ( Seg R6 ) by L598 , L599 , FINSEQ_1:1;
L608: ( D97 . R1 ) = D96 by L607 , FUNCOP_1:7;
L609: ( ( R6 proj R1 ) . D97 ) = ( D97 . R1 ) by L597 , CARD_3:def 16;
thus L610: C164 in ( rng ( R6 proj R1 ) ) by L609 , L597 , L608 , FUNCT_1:def 3;
end;
thus L611: thesis by L600 , TARSKI:1;
end;
registration
let C166 , C167 being (Element of ( NAT ));
cluster ( C166 proj C167 ) ->  len-total non  empty;
coherence
proof
L612: ( dom ( C166 proj C167 ) ) = ( C166 -tuples_on ( NAT ) ) by L596;
L613: ( C166 proj C167 ) is  len-total
proof
let C168 , C169 being (FinSequence of ( NAT ));
assume that
L614: ( len C168 ) = ( len C169 )
and
L615: C168 in ( dom ( C166 proj C167 ) );
L616: ( len C168 ) = C166 by L612 , L615 , CARD_1:def 7;
L617: C169 is (Element of ( C166 -tuples_on ( NAT ) )) by L616 , L614 , FINSEQ_2:92;
thus L618: thesis by L617 , L612;
end;
thus L619: thesis by L613 , L612;
end;
end;
theorem
L621: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds ( arity ( R6 proj R1 ) ) = R6))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
consider C170 being set such that L622: C170 in ( R6 -tuples_on ( NAT ) ) by XBOOLE_0:def 1;
reconsider D98 = C170 as (Element of ( R6 -tuples_on ( NAT ) )) by L622;
L623: ( dom ( R6 proj R1 ) ) = ( R6 -tuples_on ( NAT ) ) by L596;
L624: (for B73 being FinSequence holds (B73 in ( dom ( R6 proj R1 ) ) implies R6 = ( len B73 ))) by L623 , CARD_1:def 7;
L625: D98 in ( dom ( R6 proj R1 ) ) by L623;
thus L626: thesis by L625 , L624 , MARGREL1:def 25;
end;
theorem
L627: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds (for B74 being (Element of ( R6 -tuples_on ( NAT ) )) holds ( ( R6 proj R1 ) . B74 ) = ( B74 . R1 ))))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
let C171 being (Element of ( R6 -tuples_on ( NAT ) ));
L628: ( dom ( R6 proj R1 ) ) = ( R6 -tuples_on ( NAT ) ) by L596;
thus L629: thesis by L628 , CARD_3:def 16;
end;
registration
let C172 being set;
cluster ( HFuncs C172 ) ->  functional;
coherence;
end;
theorem
L631: (for R6 being (Element of ( NAT )) holds (for R13 being non  empty set holds (for R14 being non  empty set holds (for B75 being (Function of R13 , ( HFuncs R14 )) holds ((( rng B75 ) is  compatible & (for B76 being (Element of R13) holds ( dom ( B75 . B76 ) ) c= ( R6 -tuples_on R14 ))) implies (ex B77 being (Element of ( HFuncs R14 )) st (B77 = ( Union B75 ) & ( dom B77 ) c= ( R6 -tuples_on R14 ))))))))
proof
let R6 being (Element of ( NAT ));
let R13 being non  empty set;
let R14 being non  empty set;
set D99 = R13;
set D100 = R14;
let C173 being (Function of D99 , ( HFuncs D100 ));
assume L632: ( rng C173 ) is  compatible;
assume L633: (for B78 being (Element of D99) holds ( dom ( C173 . B78 ) ) c= ( R6 -tuples_on D100 ));
L634: ( rng C173 ) is  functional
proof
let C174 being set;
L635: ( rng C173 ) c= ( HFuncs D100 ) by RELAT_1:def 19;
assume L636: C174 in ( rng C173 );
thus L637: thesis by L636 , L635;
end;
reconsider D101 = ( rng C173 ) as non  empty  functional  compatible set by L634 , L632;
set D102 = { ( dom B79 ) where B79 is (Element of D101) : (not contradiction) };
reconsider D103 = ( Union C173 ) as Function by L632 , L634;
L638: ( rng D103 ) c= D100
proof
let C175 being set;
assume L639: C175 in ( rng D103 );
consider C176 being set such that L640: C176 in ( dom D103 ) and L641: ( D103 . C176 ) = C175 by L639 , FUNCT_1:def 3;
L642: C176 in ( union D102 ) by L640 , L195;
consider C177 being set such that L643: C176 in C177 and L644: C177 in D102 by L642 , TARSKI:def 4;
consider C178 being (Element of D101) such that L645: C177 = ( dom C178 ) and L646: (not contradiction) by L644;
L647: C178 in D101;
L648: ( rng C173 ) c= ( HFuncs D100 ) by RELAT_1:def 19;
reconsider D104 = C178 as (Element of ( HFuncs D100 )) by L648 , L647;
L649: ( D104 . C176 ) in ( rng D104 ) by L643 , L645 , FUNCT_1:3;
L650: ( rng D104 ) c= D100 by RELAT_1:def 19;
L651: ( D103 . C176 ) = ( D104 . C176 ) by L643 , L645 , L214;
thus L652: thesis by L651 , L641 , L650 , L649;
end;
L653: ( dom D103 ) c= ( R6 -tuples_on D100 )
proof
let C179 being set;
assume L654: C179 in ( dom D103 );
L655: C179 in ( union D102 ) by L654 , L195;
consider C180 being set such that L656: C179 in C180 and L657: C180 in D102 by L655 , TARSKI:def 4;
consider C181 being (Element of D101) such that L658: C180 = ( dom C181 ) and L659: (not contradiction) by L657;
consider C182 being set such that L660: C182 in ( dom C173 ) and L661: ( C173 . C182 ) = C181 by FUNCT_1:def 3;
reconsider D105 = C182 as (Element of D99) by L660;
L662: ( dom ( C173 . D105 ) ) c= ( R6 -tuples_on D100 ) by L633;
thus L663: thesis by L662 , L656 , L658 , L661;
end;
L664: ( R6 -tuples_on D100 ) c= ( D100 * ) by FINSEQ_2:142;
L665: ( dom D103 ) c= ( D100 * ) by L664 , L653 , XBOOLE_1:1;
reconsider D106 = D103 as (PartFunc of ( D100 * ) , D100) by L665 , L638 , RELSET_1:4;
reconsider D107 = D106 as (Element of ( PFuncs (( D100 * ) , D100) )) by PARTFUN1:45;
L666: D107 is  homogeneous
proof
thus L667: ( dom D107 ) is  with_common_domain by L653;
end;
L668: D107 in { B80 where B80 is (Element of ( PFuncs (( D100 * ) , D100) )) : B80 is  homogeneous } by L666;
reconsider D108 = ( Union C173 ) as (Element of ( HFuncs D100 )) by L668;
take D108;
thus L669: D108 = ( Union C173 );
thus L670: thesis by L653;
end;
theorem
L671: (for R13 being non  empty set holds (for B81 being (Function of ( NAT ) , ( HFuncs R13 )) holds ((for R1 being (Element of ( NAT )) holds ( B81 . R1 ) c= ( B81 . ( R1 + 1 ) )) implies ( Union B81 ) in ( HFuncs R13 ))))
proof
let R13 being non  empty set;
set D109 = R13;
let C183 being (Function of ( NAT ) , ( HFuncs D109 ));
assume that
L672: (for B82 being (Element of ( NAT )) holds ( C183 . B82 ) c= ( C183 . ( B82 + 1 ) ));
L673:
now
let C184 being (Element of ( NAT ));
defpred S2[ (Element of ( NAT )) ] means ( C183 . C184 ) c= ( C183 . ( C184 + $1 ) );
let C185 being (Element of ( NAT ));
L674:
now
let C186 being (Element of ( NAT ));
assume that
L675: S2[ C186 ];
L676: ( C183 . ( C184 + C186 ) ) c= ( C183 . ( ( C184 + C186 ) + 1 ) ) by L672;
thus L677: S2[ ( C186 + 1 ) ] by L676 , L675 , XBOOLE_1:1;
end;
L678: S2[ ( 0 ) ];
L679: (for B83 being (Element of ( NAT )) holds S2[ B83 ]) from NAT_1:sch 1(L678 , L674);
assume L680: C184 <= C185;
consider C187 being Nat such that L681: C185 = ( C184 + C187 ) by L680 , NAT_1:10;
L682: C187 in ( NAT ) by ORDINAL1:def 12;
thus L683: ( C183 . C184 ) c= ( C183 . C185 ) by L682 , L679 , L681;
end;
reconsider D110 = ( rng C183 ) as non  empty (Subset of ( HFuncs D109 )) by RELAT_1:def 19;
L684: D110 is  compatible
proof
let C188 , C189 being Function;
assume L685: C188 in D110;
consider C190 being set such that L686: C190 in ( dom C183 ) and L687: C188 = ( C183 . C190 ) by L685 , FUNCT_1:def 3;
assume L688: C189 in D110;
consider C191 being set such that L689: C191 in ( dom C183 ) and L690: C189 = ( C183 . C191 ) by L688 , FUNCT_1:def 3;
reconsider D111 = C190 , D112 = C191 as (Element of ( NAT )) by L686 , L689;
L691: (D111 <= D112 or D112 <= D111);
thus L692: thesis by L691 , L673 , L687 , L690 , PARTFUN1:54;
end;
L693: D110 is (PartFunc-set of ( D109 * ) , D109)
proof
let C192 being (Element of D110);
L694: C192 is (Element of ( HFuncs D109 ));
thus L695: thesis by L694;
end;
L696: ( Union C183 ) is (PartFunc of ( D109 * ) , D109) by L693 , L684 , L247;
reconsider D113 = ( Union C183 ) as (Element of ( PFuncs (( D109 * ) , D109) )) by L696 , PARTFUN1:45;
L697: ( dom D113 ) = ( union { ( dom B84 ) where B84 is (Element of D110) : (not contradiction) } ) by L684 , L195;
L698: D113 is  homogeneous
proof
thus L699: ( dom D113 ) is  with_common_domain
proof
let C193 , C194 being FinSequence;
assume L700: C193 in ( dom D113 );
consider C195 being set such that L701: C193 in C195 and L702: C195 in { ( dom B85 ) where B85 is (Element of D110) : (not contradiction) } by L700 , L697 , TARSKI:def 4;
consider C196 being (Element of D110) such that L703: C195 = ( dom C196 ) by L702;
assume L704: C194 in ( dom D113 );
consider C197 being set such that L705: C194 in C197 and L706: C197 in { ( dom B86 ) where B86 is (Element of D110) : (not contradiction) } by L704 , L697 , TARSKI:def 4;
consider C198 being (Element of D110) such that L707: C197 = ( dom C198 ) by L706;
consider C199 being set such that L708: C199 in ( dom C183 ) and L709: C196 = ( C183 . C199 ) by FUNCT_1:def 3;
consider C200 being set such that L710: C200 in ( dom C183 ) and L711: C198 = ( C183 . C200 ) by FUNCT_1:def 3;
reconsider D114 = C199 , D115 = C200 as (Element of ( NAT )) by L708 , L710;
L712: (D114 <= D115 or D115 <= D114);
L713: (C196 c= C198 or C198 c= C196) by L712 , L673 , L709 , L711;
L714: (( dom C196 ) c= ( dom C198 ) or ( dom C198 ) c= ( dom C196 )) by L713 , GRFUNC_1:2;
L715: ( dom C193 ) = ( dom C194 ) by L714 , L701 , L703 , L705 , L707 , CARD_3:def 10;
thus L716: ( len C193 ) = ( len C194 ) by L715 , FINSEQ_3:29;
end;

end;
thus L700: thesis by L698;
end;
theorem
L701: (for R13 being non  empty set holds (for B87 being  with_the_same_arity (FinSequence of ( HFuncs R13 )) holds ( dom <: B87 :> ) c= ( ( arity B87 ) -tuples_on R13 )))
proof
let R13 being non  empty set;
set D116 = R13;
let C201 being  with_the_same_arity (FinSequence of ( HFuncs D116 ));
thus L702: ( dom <: C201 :> ) c= ( ( arity C201 ) -tuples_on D116 )
proof
L703: ( dom <: C201 :> ) = ( meet ( doms C201 ) ) by FUNCT_6:29
.= ( meet ( rng ( doms C201 ) ) ) by FUNCT_6:def 4;
let C202 being set;
assume that
L704: C202 in ( dom <: C201 :> );
consider C203 being set such that L705: C203 in ( rng ( doms C201 ) ) by L704 , L703 , SETFAM_1:1 , XBOOLE_0:def 1;
L706: C202 in C203 by L704 , L703 , L705 , SETFAM_1:def 1;
consider C204 being set such that L707: C204 in ( dom ( doms C201 ) ) and L708: ( ( doms C201 ) . C204 ) = C203 by L705 , FUNCT_1:def 3;
L709: ( dom ( doms C201 ) ) = ( C201 " ( SubFuncs ( rng C201 ) ) ) by FUNCT_6:def 2;
L710: C204 in ( dom C201 ) by L709 , L707 , FUNCT_6:19;
L711: ( C201 . C204 ) in ( rng C201 ) by L710 , FUNCT_1:3;
L712: ( rng C201 ) c= ( HFuncs D116 ) by RELAT_1:def 19;
reconsider D117 = ( C201 . C204 ) as (Element of ( HFuncs D116 )) by L712 , L711;
L713: ( dom D117 ) c= ( ( arity D117 ) -tuples_on D116 ) by L330;
L714: ( ( doms C201 ) . C204 ) = ( dom D117 ) by L709 , L707 , FUNCT_6:def 2;
L715: C202 in ( ( arity D117 ) -tuples_on D116 ) by L714 , L708 , L706 , L713;
thus L716: thesis by L715 , L711 , L414;
end;

end;
registration
let C205 being non  empty set;
let C206 being  with_the_same_arity (FinSequence of ( HFuncs C205 ));
cluster <: C206 :> ->  homogeneous;
coherence
proof
L703: ( dom <: C206 :> ) c= ( ( arity C206 ) -tuples_on C205 ) by L701;
thus L704: ( dom <: C206 :> ) is  with_common_domain by L703;
end;
end;
theorem
L706: (for R13 being non  empty set holds (for B88 being (Element of ( HFuncs R13 )) holds (for B89 being  with_the_same_arity (FinSequence of ( HFuncs R13 )) holds (( dom ( B88 * <: B89 :> ) ) c= ( ( arity B89 ) -tuples_on R13 ) & ( rng ( B88 * <: B89 :> ) ) c= R13 & ( B88 * <: B89 :> ) in ( HFuncs R13 )))))
proof
let R13 being non  empty set;
set D118 = R13;
let C207 being (Element of ( HFuncs D118 ));
let C208 being  with_the_same_arity (FinSequence of ( HFuncs D118 ));
L707: ( dom ( C207 * <: C208 :> ) ) c= ( dom <: C208 :> ) by RELAT_1:25;
L708: ( ( arity C208 ) -tuples_on D118 ) c= ( D118 * ) by FINSEQ_2:142;
L709: ( dom <: C208 :> ) c= ( ( arity C208 ) -tuples_on D118 ) by L701;
thus L710: ( dom ( C207 * <: C208 :> ) ) c= ( ( arity C208 ) -tuples_on D118 ) by L709 , L707 , XBOOLE_1:1;
L711: ( dom ( C207 * <: C208 :> ) ) c= ( D118 * ) by L710 , L708 , XBOOLE_1:1;
thus L712: ( rng ( C207 * <: C208 :> ) ) c= D118 by RELAT_1:def 19;
L713: ( C207 * <: C208 :> ) is (PartFunc of ( D118 * ) , D118) by L712 , L711 , RELSET_1:4;
L714: ( C207 * <: C208 :> ) in ( PFuncs (( D118 * ) , D118) ) by L713 , PARTFUN1:45;
thus L715: thesis by L714;
end;
definition
let C209 , C210 being non  empty set;
let C211 being (PFUNC_DOMAIN of C209 , C210);
let C212 being non  empty (Subset of C211);
redefine mode Element of C212
 -> (Element of C211);
coherence
proof
let C213 being (Element of C212);
thus L716: thesis;
end;
end;
registration
let C214 being  homogeneous ( ( NAT ) * ) -defined Function;
cluster <* C214 *> ->  with_the_same_arity;
coherence
proof
let C215 , C216 being Function;
assume that
L718: C215 in ( rng <* C214 *> )
and
L719: C216 in ( rng <* C214 *> );
L720: ( rng <* C214 *> ) = { C214 } by FINSEQ_1:39;
L721: C215 = C214 by L720 , L718 , TARSKI:def 1;
thus L722: (C215 is  empty implies (C216 is  empty or ( dom C216 ) = { ( {} ) })) by L721 , L719 , L720 , TARSKI:def 1;
assume that
L723: C215 is non  empty
and
L724: C216 is non  empty;
take ( arity C214 );
take ( NAT );
L725: C216 = C214 by L719 , L720 , TARSKI:def 1;
thus L726: thesis by L725 , L721 , L342;
end;
end;
theorem
L728: (for B90 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ( arity <* B90 *> ) = ( arity B90 ))
proof
let C217 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
L729: ( rng <* C217 *> ) = { C217 } by FINSEQ_1:38;
L730: C217 in ( rng <* C217 *> ) by L729 , TARSKI:def 1;
thus L731: thesis by L730 , L414;
end;
theorem
L732: (for B91 , B92 being non  empty (Element of ( HFuncs ( NAT ) )) holds (for B93 being  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) holds (B92 = ( B91 * <: B93 :> ) implies ( arity B92 ) = ( arity B93 ))))
proof
let C218 , C219 being non  empty (Element of ( HFuncs ( NAT ) ));
let C220 being  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) ));
assume L733: C219 = ( C218 * <: C220 :> );
L734: ( dom C219 ) c= ( ( arity C220 ) -tuples_on ( NAT ) ) by L733 , L706;
consider C221 being set such that L735: C221 in ( dom C219 ) by XBOOLE_0:def 1;
reconsider D119 = C221 as (Element of ( ( arity C220 ) -tuples_on ( NAT ) )) by L734 , L735;
L736: ( len D119 ) = ( arity C220 ) by CARD_1:def 7;
thus L737: thesis by L736 , L735 , MARGREL1:def 25;
end;
theorem
L738: (for R13 being non  empty set holds (for B94 being non  empty  quasi_total (Element of ( HFuncs R13 )) holds (for B95 being  with_the_same_arity (FinSequence of ( HFuncs R13 )) holds ((( arity B94 ) = ( len B95 ) & B95 is non  empty & (for B96 being (Element of ( HFuncs R13 )) holds (B96 in ( rng B95 ) implies B96 is  quasi_total non  empty))) implies (( B94 * <: B95 :> ) is non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total (Element of ( HFuncs R13 )) & ( dom ( B94 * <: B95 :> ) ) = ( ( arity B95 ) -tuples_on R13 ))))))
proof
let R13 being non  empty set;
set D120 = R13;
let C222 being non  empty  quasi_total (Element of ( HFuncs D120 ));
let C223 being  with_the_same_arity (FinSequence of ( HFuncs D120 ));
assume that
L739: ( arity C222 ) = ( len C223 )
and
L740: C223 is non  empty
and
L741: (for B97 being (Element of ( HFuncs D120 )) holds (B97 in ( rng C223 ) implies B97 is  quasi_total non  empty));
set D121 = ( arity C223 );
set D122 = ( C222 * <: C223 :> );
L742: ( dom D122 ) c= ( D121 -tuples_on D120 ) by L706;
L743: ( D121 -tuples_on D120 ) c= ( dom D122 )
proof
let C224 being set;
L744: ( product ( rngs C223 ) ) c= ( ( len C223 ) -tuples_on D120 )
proof
let C225 being set;
L745: ( dom ( rngs C223 ) ) = ( C223 " ( SubFuncs ( rng C223 ) ) ) by FUNCT_6:def 3;
assume L746: C225 in ( product ( rngs C223 ) );
consider C226 being Function such that L747: C225 = C226 and L748: ( dom C226 ) = ( dom ( rngs C223 ) ) and L749: (for B98 being set holds (B98 in ( dom ( rngs C223 ) ) implies ( C226 . B98 ) in ( ( rngs C223 ) . B98 ))) by L746 , CARD_3:def 5;
L750:
now
let C227 being set;
thus L751:now
assume L752: C227 in ( C223 " ( SubFuncs ( rng C223 ) ) );
L753: C227 in ( dom C223 ) by L752 , FUNCT_6:19;
thus L754: C227 in ( Seg ( len C223 ) ) by L753 , FINSEQ_1:def 3;
end;
assume L755: C227 in ( Seg ( len C223 ) );
L756: C227 in ( dom C223 ) by L755 , FINSEQ_1:def 3;
L757: ( C223 . C227 ) in ( rng C223 ) by L756 , FUNCT_1:3;
thus L758: C227 in ( C223 " ( SubFuncs ( rng C223 ) ) ) by L757 , L756 , FUNCT_6:19;
end;
L759: ( C223 " ( SubFuncs ( rng C223 ) ) ) = ( Seg ( len C223 ) ) by L750 , TARSKI:1;
reconsider D123 = C226 as FinSequence by L759 , L748 , L745 , FINSEQ_1:def 2;
L760: ( rng D123 ) c= D120
proof
let C228 being set;
assume L761: C228 in ( rng D123 );
consider C229 being set such that L762: C229 in ( dom D123 ) and L763: ( D123 . C229 ) = C228 by L761 , FUNCT_1:def 3;
L764: ( D123 . C229 ) in ( ( rngs C223 ) . C229 ) by L748 , L749 , L762;
reconsider D124 = C229 as (Element of ( NAT )) by L762;
L765: ( dom C223 ) = ( Seg ( len C223 ) ) by FINSEQ_1:def 3;
reconsider D125 = ( C223 . D124 ) as (Element of ( HFuncs D120 )) by L765 , L748 , L745 , L759 , L762 , FINSEQ_2:11;
L766: ( rng D125 ) c= D120 by RELAT_1:def 19;
L767: ( ( rngs C223 ) . D124 ) = ( rng D125 ) by L748 , L745 , L762 , FUNCT_6:def 3;
thus L768: thesis by L767 , L763 , L764 , L766;
end;
reconsider D126 = D123 as (FinSequence of D120) by L760 , FINSEQ_1:def 4;
L769: ( len D126 ) = ( len C223 ) by L748 , L745 , L759 , FINSEQ_1:def 3;
L770: C225 is (Element of ( ( len C223 ) -tuples_on D120 )) by L769 , L747 , FINSEQ_2:92;
thus L771: thesis by L770;
end;
L772: ( rng <: C223 :> ) c= ( product ( rngs C223 ) ) by FUNCT_6:29;
L773: ( rng <: C223 :> ) c= ( ( len C223 ) -tuples_on D120 ) by L772 , L744 , XBOOLE_1:1;
L774: ( dom C222 ) = ( ( arity C222 ) -tuples_on D120 ) by L367;
L775: ( D121 -tuples_on D120 ) c= ( dom <: C223 :> )
proof
let C230 being set;
L776: ( dom ( doms C223 ) ) = ( C223 " ( SubFuncs ( rng C223 ) ) ) by FUNCT_6:def 2;
assume L777: C230 in ( D121 -tuples_on D120 );
L778:
now
let C231 being set;
assume L779: C231 in ( rng ( doms C223 ) );
consider C232 being set such that L780: C232 in ( dom ( doms C223 ) ) and L781: ( ( doms C223 ) . C232 ) = C231 by L779 , FUNCT_1:def 3;
L782: C232 in ( dom C223 ) by L776 , L780 , FUNCT_6:19;
reconsider D127 = C232 as (Element of ( NAT )) by L782;
reconsider D128 = ( C223 . D127 ) as (Element of ( HFuncs D120 )) by L782 , FINSEQ_2:11;
L783: ( ( doms C223 ) . D127 ) = ( dom D128 ) by L776 , L780 , FUNCT_6:def 2;
L784: D128 in ( rng C223 ) by L782 , FUNCT_1:3;
L785: D128 is non  empty  quasi_total by L784 , L741;
L786: ( dom D128 ) = ( ( arity D128 ) -tuples_on D120 ) by L785 , L367;
thus L787: C230 in C231 by L786 , L777 , L781 , L783 , L784 , L414;
end;
consider C233 being set such that L788: C233 in ( dom C223 ) by L740 , XBOOLE_0:def 1;
L789: ( C223 . C233 ) in ( rng C223 ) by L788 , FUNCT_1:3;
L790: C233 in ( dom ( doms C223 ) ) by L789 , L788 , L776 , FUNCT_6:19;
L791: ( rng ( doms C223 ) ) <> ( {} ) by L790 , RELAT_1:42;
L792: ( dom <: C223 :> ) = ( meet ( doms C223 ) ) by FUNCT_6:29
.= ( meet ( rng ( doms C223 ) ) ) by FUNCT_6:def 4;
thus L793: thesis by L792 , L791 , L778 , SETFAM_1:def 1;
end;
assume L794: C224 in ( D121 -tuples_on D120 );
L795: ( <: C223 :> . C224 ) in ( rng <: C223 :> ) by L794 , L775 , FUNCT_1:3;
thus L796: thesis by L795 , L739 , L794 , L775 , L774 , L773 , FUNCT_1:11;
end;
L797: ( dom D122 ) = ( D121 -tuples_on D120 ) by L743 , L742 , XBOOLE_0:def 10;
L798: ( rng D122 ) c= D120 by L706;
L799: ( ( arity C223 ) -tuples_on D120 ) c= ( D120 * ) by FINSEQ_2:142;
L800: ( dom D122 ) c= ( D120 * ) by L799 , L742 , XBOOLE_1:1;
L801: D122 is (Relation of ( D120 * ) , D120) by L800 , L798 , RELSET_1:4;
L802: D122 is (Element of ( PFuncs (( D120 * ) , D120) )) by L801 , PARTFUN1:45;
L803: D122 in ( HFuncs D120 ) by L802;
reconsider D129 = D122 as (Element of ( HFuncs D120 )) by L803;
L804: D129 is  quasi_total
proof
let C234 , C235 being (FinSequence of D120);
assume that
L805: ( len C234 ) = ( len C235 )
and
L806: C234 in ( dom D129 );
L807: ( len C234 ) = D121 by L742 , L806 , CARD_1:def 7;
L808: C235 is (Element of ( D121 -tuples_on D120 )) by L807 , L805 , FINSEQ_2:92;
thus L809: C235 in ( dom D129 ) by L808 , L797;
end;
thus L810: ( C222 * <: C223 :> ) is non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total (Element of ( HFuncs D120 )) by L804 , L743;
thus L811: thesis by L742 , L743 , XBOOLE_0:def 10;
end;
theorem
L812: (for R13 being non  empty set holds (for B99 being  quasi_total (Element of ( HFuncs R13 )) holds (for B100 being  with_the_same_arity (FinSequence of ( HFuncs R13 )) holds ((( arity B99 ) = ( len B100 ) & (for B101 being (Element of ( HFuncs R13 )) holds (B101 in ( rng B100 ) implies B101 is  quasi_total))) implies ( B99 * <: B100 :> ) is  quasi_total  quasi_total  quasi_total  quasi_total (Element of ( HFuncs R13 ))))))
proof
let R13 being non  empty set;
set D130 = R13;
let C236 being  quasi_total (Element of ( HFuncs D130 ));
let C237 being  with_the_same_arity (FinSequence of ( HFuncs D130 ));
assume that
L813: ( arity C236 ) = ( len C237 )
and
L814: (for B102 being (Element of ( HFuncs D130 )) holds (B102 in ( rng C237 ) implies B102 is  quasi_total));
reconsider D131 = ( {} ) as (PartFunc of ( D130 * ) , D130) by RELSET_1:12;
L815: D131 is  quasi_total
proof
let C238 , C239 being (FinSequence of D130);
assume that
L816: ( len C238 ) = ( len C239 )
and
L817: C238 in ( dom D131 );
thus L818: C239 in ( dom D131 ) by L817;
end;
L819: D131 in ( PFuncs (( D130 * ) , D130) ) by PARTFUN1:45;
L820: D131 in { B103 where B103 is (Element of ( PFuncs (( D130 * ) , D130) )) : B103 is  homogeneous } by L819;
per cases ;
suppose L821: C236 = ( {} );

thus L822: thesis by L821;
end;
suppose L823: C237 = ( {} );

thus L824: thesis by L823 , L820 , L815 , FUNCT_6:40;
end;
suppose L825: (ex B104 being set st (B104 in ( rng C237 ) & B104 = ( {} )));

L826: <: C237 :> = ( {} ) by L825 , L100;
thus L827: thesis by L826 , L820 , L815;
end;
suppose L828: (C237 <> ( {} ) & C236 <> ( {} ) & (for B105 being set holds (B105 in ( rng C237 ) implies B105 <> ( {} ))));

L829: (for B106 being (Element of ( HFuncs D130 )) holds (B106 in ( rng C237 ) implies B106 is  quasi_total non  empty)) by L828 , L814;
thus L830: thesis by L829 , L813 , L828 , L738;
end;
end;
theorem
L832: (for R13 being non  empty set holds (for B107 , B108 being non  empty  quasi_total (Element of ( HFuncs R13 )) holds ((( arity B107 ) = ( 0 ) & ( arity B108 ) = ( 0 ) & ( B107 . ( {} ) ) = ( B108 . ( {} ) )) implies B107 = B108)))
proof
let R13 being non  empty set;
set D132 = R13;
let C240 , C241 being non  empty  quasi_total (Element of ( HFuncs D132 ));
assume that
L833: ( arity C240 ) = ( 0 )
and
L834: ( arity C241 ) = ( 0 )
and
L835: ( C240 . ( {} ) ) = ( C241 . ( {} ) );
L836:
now
thus L837: ( dom C240 ) = ( ( 0 ) -tuples_on D132 ) by L833 , L367
.= { ( <*> D132 ) } by FINSEQ_2:94;
thus L838: ( dom C241 ) = ( ( 0 ) -tuples_on D132 ) by L834 , L367
.= { ( <*> D132 ) } by FINSEQ_2:94;
let C242 being set;
assume L839: C242 in { ( <*> D132 ) };
L840: C242 = ( {} ) by L839 , TARSKI:def 1;
thus L841: ( C240 . C242 ) = ( C241 . C242 ) by L840 , L835;
end;
thus L842: thesis by L836 , FUNCT_1:2;
end;
theorem
L843: (for B109 , B110 being non  empty  len-total  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ((( arity B109 ) = ( 0 ) & ( arity B110 ) = ( 0 ) & ( B109 . ( {} ) ) = ( B110 . ( {} ) )) implies B109 = B110))
proof
let C243 , C244 being non  empty  len-total  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L844: ( arity C243 ) = ( 0 )
and
L845: ( arity C244 ) = ( 0 )
and
L846: ( C243 . ( {} ) ) = ( C244 . ( {} ) );
L847: C244 is non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total (Element of ( HFuncs ( NAT ) )) by L486;
L848: C243 is non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total non  empty  quasi_total (Element of ( HFuncs ( NAT ) )) by L486;
thus L849: thesis by L848 , L844 , L845 , L846 , L847 , L832;
end;
begin
definition
let C245 , C246 , C247 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C248 being (Element of ( NAT ));
pred C245 is_primitive-recursively_expressed_by C246 , C247 , C248
means
:L850: (ex B111 being (Element of ( NAT )) st (( dom C245 ) c= ( B111 -tuples_on ( NAT ) ) & C248 >= 1 & C248 <= B111 & ( ( arity C246 ) + 1 ) = B111 & ( B111 + 1 ) = ( arity C247 ) & (for B112 being (FinSequence of ( NAT )) holds (( len B112 ) = B111 implies ((( B112 +* (C248 , ( 0 )) ) in ( dom C245 ) iff ( Del (B112 , C248) ) in ( dom C246 )) & (( B112 +* (C248 , ( 0 )) ) in ( dom C245 ) implies ( C245 . ( B112 +* (C248 , ( 0 )) ) ) = ( C246 . ( Del (B112 , C248) ) )) & (for B113 being (Element of ( NAT )) holds ((( B112 +* (C248 , ( B113 + 1 )) ) in ( dom C245 ) iff (( B112 +* (C248 , B113) ) in ( dom C245 ) & ( ( B112 +* (C248 , B113) ) ^ <* ( C245 . ( B112 +* (C248 , B113) ) ) *> ) in ( dom C247 ))) & (( B112 +* (C248 , ( B113 + 1 )) ) in ( dom C245 ) implies ( C245 . ( B112 +* (C248 , ( B113 + 1 )) ) ) = ( C247 . ( ( B112 +* (C248 , B113) ) ^ <* ( C245 . ( B112 +* (C248 , B113) ) ) *> ) )))))))))
;end;
defpred S3[ (Element of ( NAT )) , (Element of ( HFuncs ( NAT ) )) , (Element of ( HFuncs ( NAT ) )) , (FinSequence of ( NAT )) , (Element of ( NAT )) ,  homogeneous Function ] means ((($5 in ( dom $4 ) & ( $4 +* ($5 , $1) ) in ( dom $2 ) & ( ( $4 +* ($5 , $1) ) ^ <* ( $2 . ( $4 +* ($5 , $1) ) ) *> ) in ( dom $6 )) implies $3 = ( $2 +* ( ( $4 +* ($5 , ( $1 + 1 )) ) .--> ( $6 . ( ( $4 +* ($5 , $1) ) ^ <* ( $2 . ( $4 +* ($5 , $1) ) ) *> ) ) ) )) & (((not $5 in ( dom $4 )) or (not ( $4 +* ($5 , $1) ) in ( dom $2 )) or (not ( ( $4 +* ($5 , $1) ) ^ <* ( $2 . ( $4 +* ($5 , $1) ) ) *> ) in ( dom $6 ))) implies $3 = $2));
definition
let C249 , C250 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C251 being (Element of ( NAT ));
let C252 being (FinSequence of ( NAT ));
func primrec (C249 , C250 , C251 , C252) -> (Element of ( HFuncs ( NAT ) )) means 
:L852: (ex B114 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) st (it = ( B114 . ( C252 /. C251 ) ) & ((C251 in ( dom C252 ) & ( Del (C252 , C251) ) in ( dom C249 )) implies ( B114 . ( 0 ) ) = ( ( C252 +* (C251 , ( 0 )) ) .--> ( C249 . ( Del (C252 , C251) ) ) )) & (((not C251 in ( dom C252 )) or (not ( Del (C252 , C251) ) in ( dom C249 ))) implies ( B114 . ( 0 ) ) = ( {} )) & (for B115 being (Element of ( NAT )) holds (((C251 in ( dom C252 ) & ( C252 +* (C251 , B115) ) in ( dom ( B114 . B115 ) ) & ( ( C252 +* (C251 , B115) ) ^ <* ( ( B114 . B115 ) . ( C252 +* (C251 , B115) ) ) *> ) in ( dom C250 )) implies ( B114 . ( B115 + 1 ) ) = ( ( B114 . B115 ) +* ( ( C252 +* (C251 , ( B115 + 1 )) ) .--> ( C250 . ( ( C252 +* (C251 , B115) ) ^ <* ( ( B114 . B115 ) . ( C252 +* (C251 , B115) ) ) *> ) ) ) )) & (((not C251 in ( dom C252 )) or (not ( C252 +* (C251 , B115) ) in ( dom ( B114 . B115 ) )) or (not ( ( C252 +* (C251 , B115) ) ^ <* ( ( B114 . B115 ) . ( C252 +* (C251 , B115) ) ) *> ) in ( dom C250 ))) implies ( B114 . ( B115 + 1 ) ) = ( B114 . B115 ))))));
existence
proof
reconsider D133 = C249 , D134 = C250 as (Element of ( HFuncs ( NAT ) )) by L480;
set D135 = ( len C252 );
reconsider D136 = ( D133 . ( Del (C252 , C251) ) ) as (Element of ( NAT ));
defpred S4[ (Element of ( NAT )) , (Element of ( HFuncs ( NAT ) )) , (Element of ( HFuncs ( NAT ) )) ] means S3[ $1 , $2 , $3 , C252 , C251 , D134 ];
L853: ( C252 +* (C251 , ( 0 )) ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
reconsider D137 = { ( C252 +* (C251 , ( 0 )) ) } as non  empty (Subset of ( ( NAT ) * )) by L853 , ZFMISC_1:31;
L854: ( {} ) is (PartFunc of ( ( NAT ) * ) , ( NAT )) by RELSET_1:12;
L855: ( {} ) in ( PFuncs (( ( NAT ) * ) , ( NAT )) ) by L854 , PARTFUN1:45;
L856: ( {} ) in ( HFuncs ( NAT ) ) by L855;
L857: ( D137 --> D136 ) = ( ( C252 +* (C251 , ( 0 )) ) .--> D136 );
L858: ( D137 --> D136 ) in ( HFuncs ( NAT ) ) by L857;
reconsider D138 = ( D137 --> D136 ) , D139 = ( {} ) as (Element of ( HFuncs ( NAT ) )) by L858 , L856;
L859: ((C251 in ( dom C252 ) & ( Del (C252 , C251) ) in ( dom C249 )) or (not C251 in ( dom C252 )) or (not ( Del (C252 , C251) ) in ( dom C249 )));
consider C253 being (Element of ( HFuncs ( NAT ) )) such that L860: ((C251 in ( dom C252 ) & ( Del (C252 , C251) ) in ( dom C249 )) implies C253 = D138) and L861: (((not C251 in ( dom C252 )) or (not ( Del (C252 , C251) ) in ( dom C249 ))) implies C253 = D139) by L859;
L862: (for B116 being (Element of ( NAT )) holds (for B117 being (Element of ( HFuncs ( NAT ) )) holds (ex B118 being (Element of ( HFuncs ( NAT ) )) st S4[ B116 , B117 , B118 ])))
proof
let C254 being (Element of ( NAT ));
let C255 being (Element of ( HFuncs ( NAT ) ));
set D140 = ( C255 +* ( { ( C252 +* (C251 , ( C254 + 1 )) ) } --> ( C250 . ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) ) ) );
reconsider D141 = ( D134 . ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) ) as (Element of ( NAT ));
L863: ((C251 in ( dom C252 ) & ( C252 +* (C251 , C254) ) in ( dom C255 ) & ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) in ( dom C250 )) or (not C251 in ( dom C252 )) or (not ( C252 +* (C251 , C254) ) in ( dom C255 )) or (not ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) in ( dom C250 )));
consider C256 being Function such that L864: ((C251 in ( dom C252 ) & ( C252 +* (C251 , C254) ) in ( dom C255 ) & ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) in ( dom C250 ) & C256 = ( C255 +* ( { ( C252 +* (C251 , ( C254 + 1 )) ) } --> ( C250 . ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) ) ) )) or (((not C251 in ( dom C252 )) or (not ( C252 +* (C251 , C254) ) in ( dom C255 )) or (not ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) in ( dom C250 ))) & C256 = C255)) by L863;
L865: ( C252 +* (C251 , ( C254 + 1 )) ) in ( ( NAT ) * ) by FINSEQ_1:def 11;
reconsider D142 = { ( C252 +* (C251 , ( C254 + 1 )) ) } as (Subset of ( ( NAT ) * )) by L865 , ZFMISC_1:31;
L866: ( dom ( D142 --> D141 ) ) = D142 by FUNCOP_1:13;
L867: ( dom D140 ) = ( ( dom C255 ) \/ D142 ) by L866 , FUNCT_4:def 1;
L868: ( dom C252 ) = ( dom ( C252 +* (C251 , ( C254 + 1 )) ) ) by FUNCT_7:30;
L869: ( len ( C252 +* (C251 , ( C254 + 1 )) ) ) = D135 by L868 , FINSEQ_3:29;
L870: ( C252 +* (C251 , ( C254 + 1 )) ) is (Element of ( D135 -tuples_on ( NAT ) )) by L869 , FINSEQ_2:92;
L871: D142 c= ( D135 -tuples_on ( NAT ) ) by L870 , ZFMISC_1:31;
L872: D140 = ( C255 +* ( D142 --> D141 ) );
L873:
now
assume L874: ( C252 +* (C251 , C254) ) in ( dom C255 );
L875: ( dom C255 ) c= ( D135 -tuples_on ( NAT ) )
proof
let C257 being set;
L876: ( dom C252 ) = ( dom ( C252 +* (C251 , C254) ) ) by FUNCT_7:30;
assume L877: C257 in ( dom C255 );
reconsider D143 = C257 as (Element of ( ( NAT ) * )) by L877;
L878: ( len D143 ) = ( len ( C252 +* (C251 , C254) ) ) by L874 , L877 , MARGREL1:def 1;
L879: ( len D143 ) = D135 by L878 , L876 , FINSEQ_3:29;
thus L880: thesis by L879;
end;
L881: D140 is  homogeneous by L875 , L871 , L867 , L271 , XBOOLE_1:8;
L882: D140 in ( PFuncs (( ( NAT ) * ) , ( NAT )) ) by L872 , PARTFUN1:45;
thus L883: D140 in ( HFuncs ( NAT ) ) by L882 , L881;
end;
reconsider D144 = C256 as (Element of ( HFuncs ( NAT ) )) by L873 , L864;
take D144;
thus L884: ((C251 in ( dom C252 ) & ( C252 +* (C251 , C254) ) in ( dom C255 ) & ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) in ( dom D134 )) implies D144 = ( C255 +* ( ( C252 +* (C251 , ( C254 + 1 )) ) .--> ( D134 . ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) ) ) )) by L864;
thus L885: (((not C251 in ( dom C252 )) or (not ( C252 +* (C251 , C254) ) in ( dom C255 )) or (not ( ( C252 +* (C251 , C254) ) ^ <* ( C255 . ( C252 +* (C251 , C254) ) ) *> ) in ( dom D134 ))) implies D144 = C255) by L864;
end;
consider C258 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L886: ( C258 . ( 0 ) ) = C253 and L887: (for B119 being (Element of ( NAT )) holds S4[ B119 , (( C258 . B119 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C258 . ( B119 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) ]) from RECDEF_1:sch 2(L862);
take ( C258 . ( C252 /. C251 ) );
take C258;
thus L888: thesis by L860 , L861 , L886 , L887;
end;
uniqueness
proof
reconsider D145 = C250 as (Element of ( HFuncs ( NAT ) )) by L480;
let C259 , C260 being (Element of ( HFuncs ( NAT ) ));
given C261 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that
L889: C259 = ( C261 . ( C252 /. C251 ) )
and
L890: ((C251 in ( dom C252 ) & ( Del (C252 , C251) ) in ( dom C249 )) implies ( C261 . ( 0 ) ) = ( ( C252 +* (C251 , ( 0 )) ) .--> ( C249 . ( Del (C252 , C251) ) ) ))
and
L891: (((not C251 in ( dom C252 )) or (not ( Del (C252 , C251) ) in ( dom C249 ))) implies ( C261 . ( 0 ) ) = ( {} ))
and
L892: (for B120 being (Element of ( NAT )) holds S3[ B120 , (( C261 . B120 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C261 . ( B120 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C252 , C251 , C250 ]);

given C262 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that
L893: C260 = ( C262 . ( C252 /. C251 ) )
and
L894: ((C251 in ( dom C252 ) & ( Del (C252 , C251) ) in ( dom C249 )) implies ( C262 . ( 0 ) ) = ( ( C252 +* (C251 , ( 0 )) ) .--> ( C249 . ( Del (C252 , C251) ) ) ))
and
L895: (((not C251 in ( dom C252 )) or (not ( Del (C252 , C251) ) in ( dom C249 ))) implies ( C262 . ( 0 ) ) = ( {} ))
and
L896: (for B121 being (Element of ( NAT )) holds S3[ B121 , (( C262 . B121 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C262 . ( B121 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C252 , C251 , C250 ]);

defpred S5[ (Element of ( NAT )) ] means ( C261 . $1 ) = ( C262 . $1 );
L897:
now
let C263 being (Element of ( NAT ));
assume L898: S5[ C263 ];
L899: S3[ C263 , (( C261 . C263 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C262 . ( C263 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C252 , C251 , D145 ] by L898 , L896;
L900: S3[ C263 , (( C261 . C263 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C261 . ( C263 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C252 , C251 , C250 ] by L892;
thus L901: S5[ ( C263 + 1 ) ] by L900 , L899;
end;
L902: S5[ ( 0 ) ] by L890 , L891 , L894 , L895;
L903: (for B122 being (Element of ( NAT )) holds S5[ B122 ]) from NAT_1:sch 1(L902 , L897);
thus L904: thesis by L903 , L889 , L893;
end;
end;
theorem
L906: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for B123 , B124 being (FinSequence of ( NAT )) holds (B124 in ( dom ( primrec (R22 , R23 , R1 , B123) ) ) implies (ex R3 being (Element of ( NAT )) st B124 = ( B123 +* (R1 , R3) )))))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D146 = R22;
set D147 = R23;
let C264 , C265 being (FinSequence of ( NAT ));
assume that
L907: C265 in ( dom ( primrec (D146 , D147 , R1 , C264) ) );
consider C266 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L908: ( primrec (D146 , D147 , R1 , C264) ) = ( C266 . ( C264 /. R1 ) ) and L909: ((R1 in ( dom C264 ) & ( Del (C264 , R1) ) in ( dom D146 )) implies ( C266 . ( 0 ) ) = ( ( C264 +* (R1 , ( 0 )) ) .--> ( D146 . ( Del (C264 , R1) ) ) )) and L910: (((not R1 in ( dom C264 )) or (not ( Del (C264 , R1) ) in ( dom D146 ))) implies ( C266 . ( 0 ) ) = ( {} )) and L911: (for B125 being (Element of ( NAT )) holds S3[ B125 , (( C266 . B125 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C266 . ( B125 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C264 , R1 , D147 ]) by L852;
defpred S6[ (Element of ( NAT )) ] means (C265 in ( dom ( C266 . $1 ) ) implies (ex B126 being (Element of ( NAT )) st C265 = ( C264 +* (R1 , B126) )));
L912: (for B127 being (Element of ( NAT )) holds (S6[ B127 ] implies S6[ ( B127 + 1 ) ]))
proof
let C267 being (Element of ( NAT ));
assume that
L913: S6[ C267 ]
and
L914: C265 in ( dom ( C266 . ( C267 + 1 ) ) );
per cases ;
suppose L915: (R1 in ( dom C264 ) & ( C264 +* (R1 , C267) ) in ( dom ( C266 . C267 ) ) & ( ( C264 +* (R1 , C267) ) ^ <* ( ( C266 . C267 ) . ( C264 +* (R1 , C267) ) ) *> ) in ( dom D147 ));

L916: ( C266 . ( C267 + 1 ) ) = ( ( C266 . C267 ) +* ( ( C264 +* (R1 , ( C267 + 1 )) ) .--> ( D147 . ( ( C264 +* (R1 , C267) ) ^ <* ( ( C266 . C267 ) . ( C264 +* (R1 , C267) ) ) *> ) ) ) ) by L915 , L911;
L917: ( dom ( C266 . ( C267 + 1 ) ) ) = ( ( dom ( C266 . C267 ) ) \/ ( dom ( ( C264 +* (R1 , ( C267 + 1 )) ) .--> ( D147 . ( ( C264 +* (R1 , C267) ) ^ <* ( ( C266 . C267 ) . ( C264 +* (R1 , C267) ) ) *> ) ) ) ) ) by L916 , FUNCT_4:def 1;
L918: ( dom ( C266 . ( C267 + 1 ) ) ) = ( ( dom ( C266 . C267 ) ) \/ { ( C264 +* (R1 , ( C267 + 1 )) ) } ) by L917 , FUNCOP_1:13;
thus L919: (ex B128 being (Element of ( NAT )) st C265 = ( C264 +* (R1 , B128) ))
proof
per cases  by L914 , L918 , XBOOLE_0:def 3;
suppose L920: C265 in ( dom ( C266 . C267 ) );

thus L921: thesis by L920 , L913;
end;
suppose L922: C265 in { ( C264 +* (R1 , ( C267 + 1 )) ) };

L923: C265 = ( C264 +* (R1 , ( C267 + 1 )) ) by L922 , TARSKI:def 1;
thus L924: thesis by L923;
end;
end;

end;
suppose L920: ((not R1 in ( dom C264 )) or (not ( C264 +* (R1 , C267) ) in ( dom ( C266 . C267 ) )) or (not ( ( C264 +* (R1 , C267) ) ^ <* ( ( C266 . C267 ) . ( C264 +* (R1 , C267) ) ) *> ) in ( dom D147 )));

thus L921: thesis by L920 , L911 , L913 , L914;
end;
end;
L923: S6[ ( 0 ) ]
proof
assume L924: C265 in ( dom ( C266 . ( 0 ) ) );
per cases ;
suppose L925: (R1 in ( dom C264 ) & ( Del (C264 , R1) ) in ( dom D146 ));

L926: ( dom ( C266 . ( 0 ) ) ) = { ( C264 +* (R1 , ( 0 )) ) } by L925 , L909 , FUNCOP_1:13;
L927: ( C264 +* (R1 , ( 0 )) ) = C265 by L926 , L924 , TARSKI:def 1;
thus L928: thesis by L927;
end;
suppose L929: ((not R1 in ( dom C264 )) or (not ( Del (C264 , R1) ) in ( dom D146 )));

thus L930: thesis by L929 , L910 , L924;
end;
end;
L932: (for B129 being (Element of ( NAT )) holds S6[ B129 ]) from NAT_1:sch 1(L923 , L912);
thus L933: thesis by L932 , L907 , L908;
end;
theorem
L934: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for B130 being (FinSequence of ( NAT )) holds ((not R1 in ( dom B130 )) implies ( primrec (R22 , R23 , R1 , B130) ) = ( {} ))))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D148 = R22;
set D149 = R23;
let C268 being (FinSequence of ( NAT ));
consider C269 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L935: ( primrec (D148 , D149 , R1 , C268) ) = ( C269 . ( C268 /. R1 ) ) and L936: ((R1 in ( dom C268 ) & ( Del (C268 , R1) ) in ( dom D148 )) implies ( C269 . ( 0 ) ) = ( ( C268 +* (R1 , ( 0 )) ) .--> ( D148 . ( Del (C268 , R1) ) ) )) and L937: (((not R1 in ( dom C268 )) or (not ( Del (C268 , R1) ) in ( dom D148 ))) implies ( C269 . ( 0 ) ) = ( {} )) and L938: (for B131 being (Element of ( NAT )) holds S3[ B131 , (( C269 . B131 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C269 . ( B131 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C268 , R1 , D149 ]) by L852;
defpred S7[ (Element of ( NAT )) ] means ( C269 . $1 ) = ( {} );
assume L939: (not R1 in ( dom C268 ));
L940: (for B132 being (Element of ( NAT )) holds (S7[ B132 ] implies S7[ ( B132 + 1 ) ])) by L939 , L938;
L941: S7[ ( 0 ) ] by L939 , L937;
L942: (for B133 being (Element of ( NAT )) holds S7[ B133 ]) from NAT_1:sch 1(L941 , L940);
thus L943: thesis by L942 , L935;
end;
theorem
L944: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for B134 , B135 being (FinSequence of ( NAT )) holds ( primrec (R22 , R23 , R1 , B134) ) tolerates ( primrec (R22 , R23 , R1 , B135) )))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D150 = R22;
set D151 = R23;
let C270 , C271 being (FinSequence of ( NAT ));
per cases ;
suppose L945: ((not R1 in ( dom C270 )) or (not R1 in ( dom C271 )));

L946: (( primrec (D150 , D151 , R1 , C270) ) = ( {} ) or ( primrec (D150 , D151 , R1 , C271) ) = ( {} )) by L945 , L934;
thus L947: thesis by L946 , PARTFUN1:59;
end;
suppose L948: (R1 in ( dom C270 ) & R1 in ( dom C271 ));

reconsider D152 = ( C270 /. R1 ) , D153 = ( C271 /. R1 ) as (Element of ( NAT ));
consider C272 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L949: ( primrec (D150 , D151 , R1 , C271) ) = ( C272 . ( C271 /. R1 ) ) and L950: ((R1 in ( dom C271 ) & ( Del (C271 , R1) ) in ( dom D150 )) implies ( C272 . ( 0 ) ) = ( ( C271 +* (R1 , ( 0 )) ) .--> ( D150 . ( Del (C271 , R1) ) ) )) and L951: (((not R1 in ( dom C271 )) or (not ( Del (C271 , R1) ) in ( dom D150 ))) implies ( C272 . ( 0 ) ) = ( {} )) and L952: (for B136 being (Element of ( NAT )) holds S3[ B136 , (( C272 . B136 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C272 . ( B136 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C271 , R1 , D151 ]) by L852;
consider C273 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L953: ( primrec (D150 , D151 , R1 , C270) ) = ( C273 . ( C270 /. R1 ) ) and L954: ((R1 in ( dom C270 ) & ( Del (C270 , R1) ) in ( dom D150 )) implies ( C273 . ( 0 ) ) = ( ( C270 +* (R1 , ( 0 )) ) .--> ( D150 . ( Del (C270 , R1) ) ) )) and L955: (((not R1 in ( dom C270 )) or (not ( Del (C270 , R1) ) in ( dom D150 ))) implies ( C273 . ( 0 ) ) = ( {} )) and L956: (for B137 being (Element of ( NAT )) holds S3[ B137 , (( C273 . B137 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C273 . ( B137 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C270 , R1 , D151 ]) by L852;
defpred S8[ (Element of ( NAT )) ] means (for B138 being set holds (B138 in ( dom ( C273 . $1 ) ) implies (ex B139 being (Element of ( NAT )) st (B138 = ( C270 +* (R1 , B139) ) & B139 <= $1))));
L957:
now
let C274 being (Element of ( NAT ));
assume that
L958: S8[ C274 ];
thus L959: S8[ ( C274 + 1 ) ]
proof
set D154 = ( ( C270 +* (R1 , C274) ) ^ <* ( ( C273 . C274 ) . ( C270 +* (R1 , C274) ) ) *> );
let C275 being set;
assume that
L960: C275 in ( dom ( C273 . ( C274 + 1 ) ) );
L961: C274 <= ( C274 + 1 ) by NAT_1:11;
per cases ;
suppose L962: (R1 in ( dom C270 ) & ( C270 +* (R1 , C274) ) in ( dom ( C273 . C274 ) ) & D154 in ( dom D151 ));

L963: ( C273 . ( C274 + 1 ) ) = ( ( C273 . C274 ) +* ( ( C270 +* (R1 , ( C274 + 1 )) ) .--> ( D151 . D154 ) ) ) by L962 , L956;
L964: ( dom ( C273 . ( C274 + 1 ) ) ) = ( ( dom ( C273 . C274 ) ) \/ ( dom ( ( C270 +* (R1 , ( C274 + 1 )) ) .--> ( D151 . D154 ) ) ) ) by L963 , FUNCT_4:def 1
.= ( ( dom ( C273 . C274 ) ) \/ { ( C270 +* (R1 , ( C274 + 1 )) ) } ) by FUNCOP_1:13;
L965: (C275 in ( dom ( C273 . C274 ) ) or C275 in { ( C270 +* (R1 , ( C274 + 1 )) ) }) by L964 , L960 , XBOOLE_0:def 3;
thus L966: (ex B140 being (Element of ( NAT )) st (C275 = ( C270 +* (R1 , B140) ) & B140 <= ( C274 + 1 )))
proof
per cases  by L965 , TARSKI:def 1;
suppose L967: C275 in ( dom ( C273 . C274 ) );

L968: (ex B141 being (Element of ( NAT )) st (C275 = ( C270 +* (R1 , B141) ) & B141 <= C274)) by L967 , L958;
thus L969: thesis by L968 , L961 , XXREAL_0:2;
end;
suppose L970: C275 = ( C270 +* (R1 , ( C274 + 1 )) );

thus L971: thesis by L970;
end;
end;

end;
suppose L967: ((not R1 in ( dom C270 )) or (not ( C270 +* (R1 , C274) ) in ( dom ( C273 . C274 ) )) or (not D154 in ( dom D151 )));

L968: ( C273 . ( C274 + 1 ) ) = ( C273 . C274 ) by L967 , L956;
L969: (ex B142 being (Element of ( NAT )) st (C275 = ( C270 +* (R1 , B142) ) & B142 <= C274)) by L968 , L958 , L960;
thus L970: thesis by L969 , L961 , XXREAL_0:2;
end;
end;

end;
L960:
now
defpred S9[ (Element of ( NAT )) ] means ( C273 . $1 ) = ( C272 . $1 );
assume L961: ( C270 +* (R1 , ( 0 )) ) = ( C271 +* (R1 , ( 0 )) );
L962: S9[ ( 0 ) ]
proof
per cases ;
suppose L963: (R1 in ( dom C270 ) & ( Del (C270 , R1) ) in ( dom D150 ));

thus L964: thesis by L963 , L948 , L954 , L950 , L961 , L54;
end;
suppose L965: ((not R1 in ( dom C270 )) or (not ( Del (C270 , R1) ) in ( dom D150 )));

thus L966: thesis by L965 , L948 , L955 , L951 , L961 , L54;
end;
end;
L968:
now
let C276 being (Element of ( NAT ));
assume that
L969: S9[ C276 ];
L970: S3[ C276 , (( C273 . C276 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C273 . ( C276 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C270 , R1 , D151 ] by L956;
L971: S3[ C276 , (( C272 . C276 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C272 . ( C276 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C271 , R1 , D151 ] by L952;
L972: ( C270 +* (R1 , C276) ) = ( C271 +* (R1 , C276) ) by L961 , L15;
thus L973: S9[ ( C276 + 1 ) ] by L972 , L948 , L969 , L970 , L971 , L15;
end;
thus L974: (for B143 being (Element of ( NAT )) holds S9[ B143 ]) from NAT_1:sch 1(L962 , L968);
end;
L975: S8[ ( 0 ) ]
proof
let C277 being set;
assume that
L976: C277 in ( dom ( C273 . ( 0 ) ) );
L977: ( dom ( C273 . ( 0 ) ) ) = { ( C270 +* (R1 , ( 0 )) ) } by L954 , L955 , L976 , FUNCOP_1:13;
L978: C277 = ( C270 +* (R1 , ( 0 )) ) by L977 , L976 , TARSKI:def 1;
thus L979: thesis by L978;
end;
L980: (for B144 being (Element of ( NAT )) holds S8[ B144 ]) from NAT_1:sch 1(L975 , L957);
L981: (for B145 , B146 being (Element of ( NAT )) holds ( C273 . B145 ) c= ( C273 . ( B145 + B146 ) ))
proof
let C278 being (Element of ( NAT ));
defpred S10[ (Element of ( NAT )) ] means ( C273 . C278 ) c= ( C273 . ( C278 + $1 ) );
L982:
now
let C279 being (Element of ( NAT ));
assume that
L983: S10[ C279 ];
set D155 = ( C278 + C279 );
L984: (( C273 . D155 ) qua set) c= (( C273 . ( D155 + 1 ) ) qua set)
proof
set D156 = ( ( C270 +* (R1 , D155) ) ^ <* ( ( C273 . D155 ) . ( C270 +* (R1 , D155) ) ) *> );
let C280 being set;
assume that
L985: C280 in ( C273 . D155 );
per cases ;
suppose L986: (R1 in ( dom C270 ) & ( C270 +* (R1 , D155) ) in ( dom ( C273 . D155 ) ) & D156 in ( dom D151 ));

L987: ( dom ( C273 . D155 ) ) misses ( dom ( ( C270 +* (R1 , ( D155 + 1 )) ) .--> ( D151 . D156 ) ) )
proof
assume L988: (not thesis);
consider C281 being set such that L989: C281 in ( ( dom ( C273 . D155 ) ) /\ ( dom ( { ( C270 +* (R1 , ( D155 + 1 )) ) } --> ( D151 . D156 ) ) ) ) by L988 , XBOOLE_0:4;
L990: C281 in ( dom ( C273 . D155 ) ) by L989 , XBOOLE_0:def 4;
consider C282 being (Element of ( NAT )) such that L991: C281 = ( C270 +* (R1 , C282) ) and L992: C282 <= D155 by L990 , L980;
L993: ( D155 + 1 ) = ( ( C270 +* (R1 , ( D155 + 1 )) ) . R1 ) by L948 , FUNCT_7:31;
L994: C281 = ( C270 +* (R1 , ( D155 + 1 )) ) by L989 , TARSKI:def 1;
L995: C282 = ( ( C270 +* (R1 , C282) ) . R1 ) by L948 , FUNCT_7:31;
thus L996: contradiction by L995 , L994 , L991 , L992 , L993 , NAT_1:13;
end;
L997: ( C273 . ( D155 + 1 ) ) = ( ( C273 . D155 ) +* ( ( C270 +* (R1 , ( D155 + 1 )) ) .--> ( D151 . D156 ) ) ) by L956 , L986;
L998: ( C273 . D155 ) c= ( C273 . ( D155 + 1 ) ) by L997 , L987 , FUNCT_4:32;
thus L999: thesis by L998 , L985;
end;
suppose L1000: ((not R1 in ( dom C270 )) or (not ( C270 +* (R1 , D155) ) in ( dom ( C273 . D155 ) )) or (not D156 in ( dom D151 )));

thus L1001: thesis by L1000 , L956 , L985;
end;
end;
thus L1003: S10[ ( C279 + 1 ) ] by L984 , L983 , XBOOLE_1:1;
end;
L1004: S10[ ( 0 ) ];
thus L1005: (for B147 being (Element of ( NAT )) holds S10[ B147 ]) from NAT_1:sch 1(L1004 , L982);
end;
defpred S11[ (Element of ( NAT )) ] means (for B148 being set holds (B148 in ( dom ( C272 . $1 ) ) implies (ex B149 being (Element of ( NAT )) st (B148 = ( C271 +* (R1 , B149) ) & B149 <= $1))));
L1006:
now
let C283 being (Element of ( NAT ));
assume that
L1007: S11[ C283 ];
thus L1008: S11[ ( C283 + 1 ) ]
proof
set D157 = ( ( C271 +* (R1 , C283) ) ^ <* ( ( C272 . C283 ) . ( C271 +* (R1 , C283) ) ) *> );
let C284 being set;
assume that
L1009: C284 in ( dom ( C272 . ( C283 + 1 ) ) );
L1010: C283 <= ( C283 + 1 ) by NAT_1:11;
per cases ;
suppose L1011: (R1 in ( dom C271 ) & ( C271 +* (R1 , C283) ) in ( dom ( C272 . C283 ) ) & D157 in ( dom D151 ));

L1012: ( C272 . ( C283 + 1 ) ) = ( ( C272 . C283 ) +* ( ( C271 +* (R1 , ( C283 + 1 )) ) .--> ( D151 . D157 ) ) ) by L1011 , L952;
L1013: ( dom ( C272 . ( C283 + 1 ) ) ) = ( ( dom ( C272 . C283 ) ) \/ ( dom ( ( C271 +* (R1 , ( C283 + 1 )) ) .--> ( D151 . D157 ) ) ) ) by L1012 , FUNCT_4:def 1
.= ( ( dom ( C272 . C283 ) ) \/ { ( C271 +* (R1 , ( C283 + 1 )) ) } ) by FUNCOP_1:13;
L1014: (C284 in ( dom ( C272 . C283 ) ) or C284 in { ( C271 +* (R1 , ( C283 + 1 )) ) }) by L1013 , L1009 , XBOOLE_0:def 3;
thus L1015: (ex B150 being (Element of ( NAT )) st (C284 = ( C271 +* (R1 , B150) ) & B150 <= ( C283 + 1 )))
proof
per cases  by L1014 , TARSKI:def 1;
suppose L1016: C284 in ( dom ( C272 . C283 ) );

L1017: (ex B151 being (Element of ( NAT )) st (C284 = ( C271 +* (R1 , B151) ) & B151 <= C283)) by L1016 , L1007;
thus L1018: thesis by L1017 , L1010 , XXREAL_0:2;
end;
suppose L1019: C284 = ( C271 +* (R1 , ( C283 + 1 )) );

thus L1020: thesis by L1019;
end;
end;

end;
suppose L1016: ((not R1 in ( dom C271 )) or (not ( C271 +* (R1 , C283) ) in ( dom ( C272 . C283 ) )) or (not D157 in ( dom D151 )));

L1017: ( C272 . ( C283 + 1 ) ) = ( C272 . C283 ) by L1016 , L952;
L1018: (ex B152 being (Element of ( NAT )) st (C284 = ( C271 +* (R1 , B152) ) & B152 <= C283)) by L1017 , L1007 , L1009;
thus L1019: thesis by L1018 , L1010 , XXREAL_0:2;
end;
end;

end;
L1009: S11[ ( 0 ) ]
proof
let C285 being set;
assume that
L1010: C285 in ( dom ( C272 . ( 0 ) ) );
L1011: ( dom ( C272 . ( 0 ) ) ) = { ( C271 +* (R1 , ( 0 )) ) } by L950 , L951 , L1010 , FUNCOP_1:13;
L1012: C285 = ( C271 +* (R1 , ( 0 )) ) by L1011 , L1010 , TARSKI:def 1;
thus L1013: thesis by L1012;
end;
L1014: (for B153 being (Element of ( NAT )) holds S11[ B153 ]) from NAT_1:sch 1(L1009 , L1006);
L1015: (for B154 , B155 being (Element of ( NAT )) holds ( C272 . B154 ) c= ( C272 . ( B154 + B155 ) ))
proof
let C286 being (Element of ( NAT ));
defpred S12[ (Element of ( NAT )) ] means ( C272 . C286 ) c= ( C272 . ( C286 + $1 ) );
L1016:
now
let C287 being (Element of ( NAT ));
assume that
L1017: S12[ C287 ];
set D158 = ( C286 + C287 );
L1018: ( C272 . D158 ) c= ( C272 . ( D158 + 1 ) )
proof
set D159 = ( ( C271 +* (R1 , D158) ) ^ <* ( ( C272 . D158 ) . ( C271 +* (R1 , D158) ) ) *> );
let C288 being set;
assume that
L1019: C288 in ( C272 . D158 );
per cases ;
suppose L1020: (R1 in ( dom C271 ) & ( C271 +* (R1 , D158) ) in ( dom ( C272 . D158 ) ) & D159 in ( dom D151 ));

L1021: ( dom ( C272 . D158 ) ) misses ( dom ( ( C271 +* (R1 , ( D158 + 1 )) ) .--> ( D151 . D159 ) ) )
proof
assume L1022: (not thesis);
consider C289 being set such that L1023: C289 in ( ( dom ( C272 . D158 ) ) /\ ( dom ( { ( C271 +* (R1 , ( D158 + 1 )) ) } --> ( D151 . D159 ) ) ) ) by L1022 , XBOOLE_0:4;
L1024: C289 in ( dom ( C272 . D158 ) ) by L1023 , XBOOLE_0:def 4;
consider C290 being (Element of ( NAT )) such that L1025: C289 = ( C271 +* (R1 , C290) ) and L1026: C290 <= D158 by L1024 , L1014;
L1027: ( D158 + 1 ) = ( ( C271 +* (R1 , ( D158 + 1 )) ) . R1 ) by L948 , FUNCT_7:31;
L1028: C289 = ( C271 +* (R1 , ( D158 + 1 )) ) by L1023 , TARSKI:def 1;
L1029: C290 = ( ( C271 +* (R1 , C290) ) . R1 ) by L948 , FUNCT_7:31;
thus L1030: contradiction by L1029 , L1028 , L1025 , L1026 , L1027 , NAT_1:13;
end;
L1031: ( C272 . ( D158 + 1 ) ) = ( ( C272 . D158 ) +* ( ( C271 +* (R1 , ( D158 + 1 )) ) .--> ( D151 . D159 ) ) ) by L952 , L1020;
L1032: ( C272 . D158 ) c= ( C272 . ( D158 + 1 ) ) by L1031 , L1021 , FUNCT_4:32;
thus L1033: thesis by L1032 , L1019;
end;
suppose L1034: ((not R1 in ( dom C271 )) or (not ( C271 +* (R1 , D158) ) in ( dom ( C272 . D158 ) )) or (not D159 in ( dom D151 )));

thus L1035: thesis by L1034 , L952 , L1019;
end;
end;
thus L1037: S12[ ( C287 + 1 ) ] by L1018 , L1017 , XBOOLE_1:1;
end;
L1038: S12[ ( 0 ) ];
thus L1039: (for B156 being (Element of ( NAT )) holds S12[ B156 ]) from NAT_1:sch 1(L1038 , L1016);
end;
reconsider D160 = ( C273 . D152 ) , D161 = ( C273 . D153 ) , D162 = ( C272 . D152 ) , D163 = ( C272 . D153 ) as (Element of ( HFuncs ( NAT ) ));
L1040:
now
assume L1041: ( C270 +* (R1 , ( 0 )) ) <> ( C271 +* (R1 , ( 0 )) );
let C291 being (Element of ( NAT ));
assume L1042: ( ( dom ( C273 . C291 ) ) /\ ( dom ( C272 . C291 ) ) ) <> ( {} );
consider C292 being set such that L1043: C292 in ( ( dom ( C273 . C291 ) ) /\ ( dom ( C272 . C291 ) ) ) by L1042 , XBOOLE_0:def 1;
L1044: C292 in ( dom ( C272 . C291 ) ) by L1043 , XBOOLE_0:def 4;
L1045: (ex B157 being (Element of ( NAT )) st (C292 = ( C271 +* (R1 , B157) ) & B157 <= C291)) by L1044 , L1014;
L1046: C292 in ( dom ( C273 . C291 ) ) by L1043 , XBOOLE_0:def 4;
L1047: (ex B158 being (Element of ( NAT )) st (C292 = ( C270 +* (R1 , B158) ) & B158 <= C291)) by L1046 , L980;
thus L1048: contradiction by L1047 , L1041 , L1045 , L15;
end;
thus L1049: thesis
proof
per cases ;
suppose L1050: D152 <= D153;

consider C293 being Nat such that L1051: D153 = ( D152 + C293 ) by L1050 , NAT_1:10;
reconsider D164 = C293 as (Element of ( NAT )) by ORDINAL1:def 12;
L1052: D153 = ( D152 + D164 ) by L1051;
thus L1053: ( primrec (D150 , D151 , R1 , C270) ) tolerates ( primrec (D150 , D151 , R1 , C271) )
proof
per cases  by L960 , L1040;
suppose L1054: D161 = D163;

thus L1055: thesis by L1054 , L953 , L949 , L981 , L1052 , PARTFUN1:58;
end;
suppose L1056: ( ( dom D161 ) /\ ( dom D163 ) ) = ( {} );

L1057: ( dom D161 ) misses ( dom D163 ) by L1056 , XBOOLE_0:def 7;
L1058: D161 tolerates D163 by L1057 , PARTFUN1:56;
thus L1059: thesis by L1058 , L953 , L949 , L981 , L1052 , PARTFUN1:58;
end;
end;

end;
suppose L1054: D152 >= D153;

consider C294 being Nat such that L1055: D152 = ( D153 + C294 ) by L1054 , NAT_1:10;
reconsider D165 = C294 as (Element of ( NAT )) by ORDINAL1:def 12;
L1056: D152 = ( D153 + D165 ) by L1055;
thus L1057: ( primrec (D150 , D151 , R1 , C270) ) tolerates ( primrec (D150 , D151 , R1 , C271) )
proof
per cases  by L960 , L1040;
suppose L1058: D160 = D162;

thus L1059: thesis by L1058 , L953 , L949 , L1015 , L1056 , PARTFUN1:58;
end;
suppose L1060: ( ( dom D160 ) /\ ( dom D162 ) ) = ( {} );

L1061: ( dom D160 ) misses ( dom D162 ) by L1060 , XBOOLE_0:def 7;
L1062: D160 tolerates D162 by L1061 , PARTFUN1:56;
thus L1063: thesis by L1062 , L953 , L949 , L1015 , L1056 , PARTFUN1:58;
end;
end;

end;
end;

end;
end;
theorem
L1051: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for B159 being (FinSequence of ( NAT )) holds ( dom ( primrec (R22 , R23 , R1 , B159) ) ) c= ( ( 1 + ( arity R22 ) ) -tuples_on ( NAT ) )))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D166 = R22;
set D167 = R23;
let C295 being (FinSequence of ( NAT ));
per cases ;
suppose L1052: R1 in ( dom C295 );

consider C296 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1053: ( primrec (D166 , D167 , R1 , C295) ) = ( C296 . ( C295 /. R1 ) ) and L1054: ((R1 in ( dom C295 ) & ( Del (C295 , R1) ) in ( dom D166 )) implies ( C296 . ( 0 ) ) = ( ( C295 +* (R1 , ( 0 )) ) .--> ( D166 . ( Del (C295 , R1) ) ) )) and L1055: (((not R1 in ( dom C295 )) or (not ( Del (C295 , R1) ) in ( dom D166 ))) implies ( C296 . ( 0 ) ) = ( {} )) and L1056: (for B160 being (Element of ( NAT )) holds S3[ B160 , (( C296 . B160 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C296 . ( B160 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , C295 , R1 , D167 ]) by L852;
defpred S13[ (Element of ( NAT )) ] means ( dom ( C296 . $1 ) ) c= ( ( 1 + ( arity D166 ) ) -tuples_on ( NAT ) );
L1057:
now
let C297 being (Element of ( NAT ));
assume that
L1058: S13[ C297 ];
set D168 = ( ( C295 +* (R1 , C297) ) ^ <* ( ( C296 . C297 ) . ( C295 +* (R1 , C297) ) ) *> );
per cases ;
suppose L1059: (( C295 +* (R1 , C297) ) in ( dom ( C296 . C297 ) ) & D168 in ( dom D167 ));

L1060: ( dom ( C295 +* (R1 , C297) ) ) = ( dom C295 ) by FUNCT_7:30
.= ( dom ( C295 +* (R1 , ( C297 + 1 )) ) ) by FUNCT_7:30;
L1061: ( len ( C295 +* (R1 , C297) ) ) = ( len ( C295 +* (R1 , ( C297 + 1 )) ) ) by L1060 , FINSEQ_3:29;
L1062: ( len ( C295 +* (R1 , C297) ) ) = ( 1 + ( arity D166 ) ) by L1058 , L1059 , CARD_1:def 7;
L1063: ( C295 +* (R1 , ( C297 + 1 )) ) is (Element of ( ( 1 + ( arity D166 ) ) -tuples_on ( NAT ) )) by L1062 , L1061 , FINSEQ_2:92;
L1064: { ( C295 +* (R1 , ( C297 + 1 )) ) } c= ( ( 1 + ( arity D166 ) ) -tuples_on ( NAT ) ) by L1063 , ZFMISC_1:31;
L1065: ( C296 . ( C297 + 1 ) ) = ( ( C296 . C297 ) +* ( ( C295 +* (R1 , ( C297 + 1 )) ) .--> ( D167 . D168 ) ) ) by L1052 , L1056 , L1059;
L1066: ( dom ( C296 . ( C297 + 1 ) ) ) = ( ( dom ( C296 . C297 ) ) \/ ( dom ( ( C295 +* (R1 , ( C297 + 1 )) ) .--> ( D167 . D168 ) ) ) ) by L1065 , FUNCT_4:def 1;
L1067: ( dom ( C296 . ( C297 + 1 ) ) ) = ( ( dom ( C296 . C297 ) ) \/ { ( C295 +* (R1 , ( C297 + 1 )) ) } ) by L1066 , FUNCOP_1:13;
thus L1068: S13[ ( C297 + 1 ) ] by L1067 , L1058 , L1064 , XBOOLE_1:8;
end;
suppose L1069: ((not ( C295 +* (R1 , C297) ) in ( dom ( C296 . C297 ) )) or (not D168 in ( dom D167 )));

thus L1070: S13[ ( C297 + 1 ) ] by L1069 , L1056 , L1058;
end;
end;
L1072: S13[ ( 0 ) ]
proof
per cases ;
suppose L1073: ( Del (C295 , R1) ) in ( dom D166 );

L1074: ( dom D166 ) c= ( ( arity D166 ) -tuples_on ( NAT ) ) by L342;
L1075: ( len ( Del (C295 , R1) ) ) = ( arity D166 ) by L1074 , L1073 , CARD_1:def 7;
L1076: ( dom C295 ) = ( dom ( C295 +* (R1 , ( 0 )) ) ) by FUNCT_7:30;
L1077: C295 <> ( <*> ( NAT ) ) by L1052;
consider C298 being Nat such that L1078: ( len C295 ) = ( C298 + 1 ) by L1077 , NAT_1:6;
L1079: ( len ( Del (C295 , R1) ) ) = C298 by L1052 , L1078 , FINSEQ_3:109;
L1080: ( len ( C295 +* (R1 , ( 0 )) ) ) = ( 1 + ( arity D166 ) ) by L1079 , L1075 , L1078 , L1076 , FINSEQ_3:29;
L1081: ( C295 +* (R1 , ( 0 )) ) is (Element of ( ( 1 + ( arity D166 ) ) -tuples_on ( NAT ) )) by L1080 , FINSEQ_2:92;
L1082: ( dom ( C296 . ( 0 ) ) ) = { ( C295 +* (R1 , ( 0 )) ) } by L1052 , L1054 , L1073 , FUNCOP_1:13;
thus L1083: thesis by L1082 , L1081 , ZFMISC_1:31;
end;
suppose L1084: (not ( Del (C295 , R1) ) in ( dom D166 ));

thus L1085: thesis by L1084 , L1055 , RELAT_1:38 , XBOOLE_1:2;
end;
end;
L1087: (for B161 being (Element of ( NAT )) holds S13[ B161 ]) from NAT_1:sch 1(L1072 , L1057);
thus L1088: thesis by L1087 , L1053;
end;
suppose L1089: (not R1 in ( dom C295 ));

L1090: ( primrec (D166 , D167 , R1 , C295) ) = ( {} ) by L1089 , L934;
thus L1091: thesis by L1090 , RELAT_1:38 , XBOOLE_1:2;
end;
end;
theorem
L1093: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for B162 being (FinSequence of ( NAT )) holds (R22 is  empty implies ( primrec (R22 , R23 , R1 , B162) ) is  empty)))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D169 = R22;
set D170 = R23;
let C299 being (FinSequence of ( NAT ));
consider C300 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1094: ( primrec (D169 , D170 , R1 , C299) ) = ( C300 . ( C299 /. R1 ) ) and L1095: ((R1 in ( dom C299 ) & ( Del (C299 , R1) ) in ( dom D169 )) implies ( C300 . ( 0 ) ) = ( ( C299 +* (R1 , ( 0 )) ) .--> ( D169 . ( Del (C299 , R1) ) ) )) and L1096: (((not R1 in ( dom C299 )) or (not ( Del (C299 , R1) ) in ( dom D169 ))) implies ( C300 . ( 0 ) ) = ( {} )) and L1097: (for B163 being (Element of ( NAT )) holds (((R1 in ( dom C299 ) & ( C299 +* (R1 , B163) ) in ( dom ( C300 . B163 ) ) & ( ( C299 +* (R1 , B163) ) ^ <* ( ( C300 . B163 ) . ( C299 +* (R1 , B163) ) ) *> ) in ( dom D170 )) implies ( C300 . ( B163 + 1 ) ) = ( ( C300 . B163 ) +* ( ( C299 +* (R1 , ( B163 + 1 )) ) .--> ( D170 . ( ( C299 +* (R1 , B163) ) ^ <* ( ( C300 . B163 ) . ( C299 +* (R1 , B163) ) ) *> ) ) ) )) & (((not R1 in ( dom C299 )) or (not ( C299 +* (R1 , B163) ) in ( dom ( C300 . B163 ) )) or (not ( ( C299 +* (R1 , B163) ) ^ <* ( ( C300 . B163 ) . ( C299 +* (R1 , B163) ) ) *> ) in ( dom D170 ))) implies ( C300 . ( B163 + 1 ) ) = ( C300 . B163 )))) by L852;
defpred S14[ (Element of ( NAT )) ] means ( C300 . $1 ) = ( {} );
L1098: (for B164 being (Element of ( NAT )) holds (S14[ B164 ] implies S14[ ( B164 + 1 ) ])) by L1097 , RELAT_1:38;
assume L1099: D169 is  empty;
L1100: S14[ ( 0 ) ] by L1099 , L1096;
L1101: (for B165 being (Element of ( NAT )) holds S14[ B165 ]) from NAT_1:sch 1(L1100 , L1098);
thus L1102: thesis by L1101 , L1094;
end;
theorem
L1103: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ((R20 is  len-total & R21 is  len-total & ( ( arity R20 ) + 2 ) = ( arity R21 ) & 1 <= R1 & R1 <= ( 1 + ( arity R20 ) )) implies R24 in ( dom ( primrec (R20 , R21 , R1 , R24) ) ))))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ));
assume that
L1104: R20 is  len-total
and
L1105: R21 is  len-total
and
L1106: ( ( arity R20 ) + 2 ) = ( arity R21 )
and
L1107: 1 <= R1
and
L1108: R1 <= ( 1 + ( arity R20 ) );
L1109: ( len R24 ) = ( 1 + ( arity R20 ) ) by CARD_1:def 7;
L1110: R1 in ( dom R24 ) by L1109 , L1107 , L1108 , FINSEQ_3:25;
L1111: ( R24 /. R1 ) = ( R24 . R1 ) by L1110 , PARTFUN1:def 6;
consider C301 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1112: ( primrec (R20 , R21 , R1 , R24) ) = ( C301 . ( R24 /. R1 ) ) and L1113: ((R1 in ( dom R24 ) & ( Del (R24 , R1) ) in ( dom R20 )) implies ( C301 . ( 0 ) ) = ( ( R24 +* (R1 , ( 0 )) ) .--> ( R20 . ( Del (R24 , R1) ) ) )) and L1114: (((not R1 in ( dom R24 )) or (not ( Del (R24 , R1) ) in ( dom R20 ))) implies ( C301 . ( 0 ) ) = ( {} )) and L1115: (for B166 being (Element of ( NAT )) holds (((R1 in ( dom R24 ) & ( R24 +* (R1 , B166) ) in ( dom ( C301 . B166 ) ) & ( ( R24 +* (R1 , B166) ) ^ <* ( ( C301 . B166 ) . ( R24 +* (R1 , B166) ) ) *> ) in ( dom R21 )) implies ( C301 . ( B166 + 1 ) ) = ( ( C301 . B166 ) +* ( ( R24 +* (R1 , ( B166 + 1 )) ) .--> ( R21 . ( ( R24 +* (R1 , B166) ) ^ <* ( ( C301 . B166 ) . ( R24 +* (R1 , B166) ) ) *> ) ) ) )) & (((not R1 in ( dom R24 )) or (not ( R24 +* (R1 , B166) ) in ( dom ( C301 . B166 ) )) or (not ( ( R24 +* (R1 , B166) ) ^ <* ( ( C301 . B166 ) . ( R24 +* (R1 , B166) ) ) *> ) in ( dom R21 ))) implies ( C301 . ( B166 + 1 ) ) = ( C301 . B166 )))) by L852;
defpred S15[ (Element of ( NAT )) ] means ( R24 +* (R1 , $1) ) in ( dom ( C301 . $1 ) );
L1116: ( R24 +* (R1 , ( R24 . R1 )) ) = R24 by FUNCT_7:35;
L1117:
now
let C302 being (Element of ( NAT ));
assume that
L1118: S15[ C302 ];
reconsider D171 = ( ( C301 . C302 ) . ( R24 +* (R1 , C302) ) ) as (Element of ( NAT ));
set D172 = ( ( R24 +* (R1 , C302) ) ^ <* ( ( C301 . C302 ) . ( R24 +* (R1 , C302) ) ) *> );
reconsider D173 = <* D171 *> as (FinSequence of ( NAT ));
reconsider D174 = ( ( R24 +* (R1 , C302) ) ^ D173 ) as (FinSequence of ( NAT ));
L1119: ( len D173 ) = 1 by CARD_1:def 7;
L1120: ( len ( R24 +* (R1 , C302) ) ) = ( 1 + ( arity R20 ) ) by CARD_1:def 7;
L1121: ( len D174 ) = ( ( ( arity R20 ) + 1 ) + 1 ) by L1120 , L1119 , FINSEQ_1:22
.= ( arity R21 ) by L1106;
L1122: D174 is (Element of ( ( arity R21 ) -tuples_on ( NAT ) )) by L1121 , FINSEQ_2:92;
L1123: ( R24 +* (R1 , ( C302 + 1 )) ) in { ( R24 +* (R1 , ( C302 + 1 )) ) } by TARSKI:def 1;
L1124: ( R24 +* (R1 , ( C302 + 1 )) ) in ( dom ( { ( R24 +* (R1 , ( C302 + 1 )) ) } --> ( R21 . D172 ) ) ) by L1123 , FUNCOP_1:13;
L1125: ( dom R21 ) = ( ( arity R21 ) -tuples_on ( NAT ) ) by L1105 , L374;
L1126: ( C301 . ( C302 + 1 ) ) = ( ( C301 . C302 ) +* ( ( R24 +* (R1 , ( C302 + 1 )) ) .--> ( R21 . D172 ) ) ) by L1125 , L1110 , L1115 , L1118 , L1122;
L1127: ( dom ( C301 . ( C302 + 1 ) ) ) = ( ( dom ( C301 . C302 ) ) \/ ( dom ( { ( R24 +* (R1 , ( C302 + 1 )) ) } --> ( R21 . D172 ) ) ) ) by L1126 , FUNCT_4:def 1;
thus L1128: S15[ ( C302 + 1 ) ] by L1127 , L1124 , XBOOLE_0:def 3;
end;
L1129:
now
reconsider D175 = ( Del (R24 , R1) ) as (FinSequence of ( NAT )) by FINSEQ_3:105;
reconsider D176 = D175 as (Element of ( ( len D175 ) -tuples_on ( NAT ) )) by FINSEQ_2:92;
L1130: ( dom R20 ) = ( ( arity R20 ) -tuples_on ( NAT ) ) by L1104 , L374;
L1131: ( len ( Del (R24 , R1) ) ) = ( arity R20 ) by L1109 , L1110 , FINSEQ_3:109;
L1132: D176 in ( dom R20 ) by L1131 , L1130;
L1133: ( dom ( C301 . ( 0 ) ) ) = { ( R24 +* (R1 , ( 0 )) ) } by L1132 , L1107 , L1108 , L1109 , L1113 , FINSEQ_3:25 , FUNCOP_1:13;
thus L1134: S15[ ( 0 ) ] by L1133 , TARSKI:def 1;
end;
L1135: (for B167 being (Element of ( NAT )) holds S15[ B167 ]) from NAT_1:sch 1(L1129 , L1117);
thus L1136: thesis by L1135 , L1111 , L1112 , L1116;
end;
definition
let C303 , C304 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C305 being (Element of ( NAT ));
func primrec (C303 , C304 , C305) -> (Element of ( HFuncs ( NAT ) )) means 
:L1137: (ex B168 being (Function of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) st (it = ( Union B168 ) & (for B169 being (Element of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) )) holds ( B168 . B169 ) = ( primrec (C303 , C304 , C305 , B169) ))));
existence
proof
deffunc H2((FinSequence of ( NAT ))) = ( primrec (C303 , C304 , C305 , $1) );
reconsider D177 = C303 , D178 = C304 as (Element of ( HFuncs ( NAT ) )) by L480;
set D179 = ( ( arity C303 ) + 1 );
consider C306 being (Function of ( D179 -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that L1138: (for B170 being (Element of ( D179 -tuples_on ( NAT ) )) holds ( C306 . B170 ) = H2(B170)) from FUNCT_2:sch 4;
reconsider D180 = ( rng C306 ) as non  empty (Subset of ( HFuncs ( NAT ) )) by RELAT_1:def 19;
L1139: D180 is (PartFunc-set of ( ( NAT ) * ) , ( NAT ))
proof
let C307 being (Element of D180);
thus L1140: thesis;
end;
reconsider D181 = D180 as (PFUNC_DOMAIN of ( ( NAT ) * ) , ( NAT )) by L1139;
L1141: D181 is  compatible
proof
let C308 , C309 being Function;
assume L1142: C308 in D181;
consider C310 being set such that L1143: C310 in ( dom C306 ) and L1144: C308 = ( C306 . C310 ) by L1142 , FUNCT_1:def 3;
assume L1145: C309 in D181;
consider C311 being set such that L1146: C311 in ( dom C306 ) and L1147: C309 = ( C306 . C311 ) by L1145 , FUNCT_1:def 3;
reconsider D182 = C310 , D183 = C311 as (Element of ( D179 -tuples_on ( NAT ) )) by L1143 , L1146;
L1148: C309 = ( primrec (D177 , D178 , C305 , D183) ) by L1138 , L1147;
L1149: C308 = ( primrec (D177 , D178 , C305 , D182) ) by L1138 , L1144;
thus L1150: thesis by L1149 , L1148 , L944;
end;
L1151:
now
let C312 being (Element of ( D179 -tuples_on ( NAT ) ));
L1152: ( C306 . C312 ) = ( primrec (D177 , D178 , C305 , C312) ) by L1138;
thus L1153: ( dom ( C306 . C312 ) ) c= ( D179 -tuples_on ( NAT ) ) by L1152 , L1051;
end;
consider C313 being (Element of ( HFuncs ( NAT ) )) such that L1154: C313 = ( Union C306 ) and L1155: ( dom C313 ) c= ( D179 -tuples_on ( NAT ) ) by L1151 , L1141 , L631;
take C313;
take C306;
thus L1156: thesis by L1138 , L1154;
end;
uniqueness
proof
let C314 , C315 being (Element of ( HFuncs ( NAT ) ));
given C316 being (Function of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that
L1157: C314 = ( Union C316 )
and
L1158: (for B171 being (Element of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) )) holds ( C316 . B171 ) = ( primrec (C303 , C304 , C305 , B171) ));

given C317 being (Function of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that
L1159: C315 = ( Union C317 )
and
L1160: (for B172 being (Element of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) )) holds ( C317 . B172 ) = ( primrec (C303 , C304 , C305 , B172) ));

L1161:
now
let C318 being (Element of ( ( ( arity C303 ) + 1 ) -tuples_on ( NAT ) ));
thus L1162: ( C316 . C318 ) = ( primrec (C303 , C304 , C305 , C318) ) by L1158
.= ( C317 . C318 ) by L1160;
end;
thus L1163: thesis by L1161 , L1157 , L1159 , FUNCT_2:63;
end;
end;
theorem
L1165: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (R22 is  empty implies ( primrec (R22 , R23 , R1) ) is  empty))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D184 = R22;
set D185 = R23;
assume L1166: D184 is  empty;
consider C319 being (Function of ( ( ( arity D184 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that L1167: ( primrec (D184 , D185 , R1) ) = ( Union C319 ) and L1168: (for B173 being (Element of ( ( ( arity D184 ) + 1 ) -tuples_on ( NAT ) )) holds ( C319 . B173 ) = ( primrec (D184 , D185 , R1 , B173) )) by L1137;
L1169: ( dom C319 ) = ( ( ( arity D184 ) + 1 ) -tuples_on ( NAT ) ) by FUNCT_2:def 1;
L1170:
now
set D186 = the (Element of ( ( ( arity D184 ) + 1 ) -tuples_on ( NAT ) ));
let C320 being set;
thus L1171:now
assume L1172: C320 in ( rng C319 );
consider C321 being set such that L1173: C321 in ( dom C319 ) and L1174: ( C319 . C321 ) = C320 by L1172 , FUNCT_1:def 3;
reconsider D187 = C321 as (Element of ( ( ( arity D184 ) + 1 ) -tuples_on ( NAT ) )) by L1173;
L1175: ( C319 . D187 ) = ( primrec (D184 , D185 , R1 , D187) ) by L1168
.= ( {} ) by L1166 , L1093;
thus L1176: C320 in { ( {} ) } by L1175 , L1174 , TARSKI:def 1;
end;
assume L1177: C320 in { ( {} ) };
L1178: C320 = ( {} ) by L1177 , TARSKI:def 1;
L1179: ( C319 . D186 ) = ( primrec (D184 , D185 , R1 , D186) ) by L1168
.= ( {} ) by L1166 , L1093;
thus L1180: C320 in ( rng C319 ) by L1179 , L1169 , L1178 , FUNCT_1:3;
end;
L1181: ( rng C319 ) = { ( {} ) } by L1170 , TARSKI:1;
L1182: ( Union C319 ) = ( union ( rng C319 ) )
.= ( {} ) by L1181 , ZFMISC_1:25;
thus L1183: thesis by L1182 , L1167;
end;
theorem
L1184: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ( dom ( primrec (R20 , R21 , R1) ) ) c= ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C322 being set;
assume that
L1185: C322 in ( dom ( primrec (R20 , R21 , R1) ) );
consider C323 being (Function of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that L1186: ( primrec (R20 , R21 , R1) ) = ( Union C323 ) and L1187: (for B174 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ( C323 . B174 ) = ( primrec (R20 , R21 , R1 , B174) )) by L1137;
L1188: ( rng C323 ) is  compatible
proof
let C324 , C325 being Function;
assume that
L1189: C324 in ( rng C323 )
and
L1190: C325 in ( rng C323 );
consider C326 being set such that L1191: C326 in ( dom C323 ) and L1192: C324 = ( C323 . C326 ) by L1189 , FUNCT_1:def 3;
reconsider D188 = C326 as (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) by L1191;
consider C327 being set such that L1193: C327 in ( dom C323 ) and L1194: C325 = ( C323 . C327 ) by L1190 , FUNCT_1:def 3;
reconsider D189 = C327 as (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) by L1193;
L1195: ( C323 . D189 ) = ( primrec (R20 , R21 , R1 , D189) ) by L1187;
L1196: ( C323 . D188 ) = ( primrec (R20 , R21 , R1 , D188) ) by L1187;
thus L1197: thesis by L1196 , L1192 , L1194 , L1195 , L944;
end;
L1198:
now
let C328 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ));
L1199: ( C323 . C328 ) = ( primrec (R20 , R21 , R1 , C328) ) by L1187;
thus L1200: ( dom ( C323 . C328 ) ) c= ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) by L1199 , L1051;
end;
L1201: (ex B175 being (Element of ( HFuncs ( NAT ) )) st (B175 = ( Union C323 ) & ( dom B175 ) c= ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ))) by L1198 , L1188 , L631;
thus L1202: thesis by L1201 , L1185 , L1186;
end;
theorem
L1203: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ((R20 is  len-total & R21 is  len-total & ( ( arity R20 ) + 2 ) = ( arity R21 ) & 1 <= R1 & R1 <= ( 1 + ( arity R20 ) )) implies (( dom ( primrec (R20 , R21 , R1) ) ) = ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) & ( arity ( primrec (R20 , R21 , R1) ) ) = ( ( arity R20 ) + 1 ))))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L1204: R20 is  len-total
and
L1205: R21 is  len-total
and
L1206: ( ( arity R20 ) + 2 ) = ( arity R21 )
and
L1207: 1 <= R1
and
L1208: R1 <= ( 1 + ( arity R20 ) );
set D190 = ( ( arity R20 ) + 1 );
L1209: ( D190 -tuples_on ( NAT ) ) c= ( dom ( primrec (R20 , R21 , R1) ) )
proof
let C329 being set;
assume L1210: C329 in ( D190 -tuples_on ( NAT ) );
reconsider D191 = C329 as (Element of ( D190 -tuples_on ( NAT ) )) by L1210;
consider C330 being (Function of ( D190 -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that L1211: ( primrec (R20 , R21 , R1) ) = ( Union C330 ) and L1212: (for B176 being (Element of ( D190 -tuples_on ( NAT ) )) holds ( C330 . B176 ) = ( primrec (R20 , R21 , R1 , B176) )) by L1137;
reconsider D192 = ( rng C330 ) as non  empty  functional  compatible set by L1211 , L166;
L1213: ( dom ( union D192 ) ) = ( union { ( dom B177 ) where B177 is (Element of D192) : (not contradiction) } ) by L195;
L1214: ( dom C330 ) = ( D190 -tuples_on ( NAT ) ) by FUNCT_2:def 1;
L1215: ( C330 . D191 ) in ( rng C330 ) by L1214 , FUNCT_1:3;
L1216: ( dom ( C330 . D191 ) ) in { ( dom B178 ) where B178 is (Element of D192) : (not contradiction) } by L1215;
L1217: D191 in ( dom ( primrec (R20 , R21 , R1 , D191) ) ) by L1204 , L1205 , L1206 , L1207 , L1208 , L1103;
L1218: ( C330 . D191 ) = ( primrec (R20 , R21 , R1 , D191) ) by L1212;
thus L1219: thesis by L1218 , L1211 , L1217 , L1213 , L1216 , TARSKI:def 4;
end;
L1220: ( dom ( primrec (R20 , R21 , R1) ) ) c= ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) by L1184;
thus L1221: ( dom ( primrec (R20 , R21 , R1) ) ) = ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) by L1220 , L1209 , XBOOLE_0:def 10;
thus L1222: thesis by L1221 , L400;
end;
L1223:
now
let C331 , C332 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C333 being (Element of ( ( ( arity C331 ) + 1 ) -tuples_on ( NAT ) ));
let C334 , C335 being (Element of ( NAT ));
set D193 = ( C333 +* (C334 , ( C335 + 1 )) );
set D194 = ( C333 +* (C334 , C335) );
let C336 , C337 being (Function of ( NAT ) , ( HFuncs ( NAT ) ));
assume that
L1224: ((C334 in ( dom D193 ) & ( Del (D193 , C334) ) in ( dom C331 )) implies ( C336 . ( 0 ) ) = ( { ( D193 +* (C334 , ( 0 )) ) } --> ( C331 . ( Del (D193 , C334) ) ) ))
and
L1225: (((not C334 in ( dom D193 )) or (not ( Del (D193 , C334) ) in ( dom C331 ))) implies ( C336 . ( 0 ) ) = ( {} ))
and
L1226: (for B179 being (Element of ( NAT )) holds S3[ B179 , (( C336 . B179 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C336 . ( B179 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D193 , C334 , C332 ])
and
L1227: ((C334 in ( dom D194 ) & ( Del (D194 , C334) ) in ( dom C331 )) implies ( C337 . ( 0 ) ) = ( { ( D194 +* (C334 , ( 0 )) ) } --> ( C331 . ( Del (D194 , C334) ) ) ))
and
L1228: (((not C334 in ( dom D194 )) or (not ( Del (D194 , C334) ) in ( dom C331 ))) implies ( C337 . ( 0 ) ) = ( {} ))
and
L1229: (for B180 being (Element of ( NAT )) holds S3[ B180 , (( C337 . B180 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C337 . ( B180 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D194 , C334 , C332 ]);
L1230: ( dom C333 ) = ( dom D194 ) by FUNCT_7:30;
L1231: ( D194 +* (C334 , ( 0 )) ) = ( C333 +* (C334 , ( 0 )) ) by FUNCT_7:34
.= ( D193 +* (C334 , ( 0 )) ) by FUNCT_7:34;
L1232: ( dom C333 ) = ( dom D193 ) by FUNCT_7:30;
L1233: ( Del (D194 , C334) ) = ( Del (C333 , C334) ) by L30
.= ( Del (D193 , C334) ) by L30;
L1234: (for B181 being set holds (B181 in ( NAT ) implies ( C337 . B181 ) = ( C336 . B181 )))
proof
let C338 being set;
defpred S16[ (Element of ( NAT )) ] means ( C337 . $1 ) = ( C336 . $1 );
L1235: (for B182 being (Element of ( NAT )) holds (S16[ B182 ] implies S16[ ( B182 + 1 ) ]))
proof
let C339 being (Element of ( NAT ));
assume that
L1236: S16[ C339 ];
L1237: ( D194 +* (C334 , ( C339 + 1 )) ) = ( C333 +* (C334 , ( C339 + 1 )) ) by FUNCT_7:34
.= ( D193 +* (C334 , ( C339 + 1 )) ) by FUNCT_7:34;
L1238: ( D194 +* (C334 , C339) ) = ( C333 +* (C334 , C339) ) by FUNCT_7:34
.= ( D193 +* (C334 , C339) ) by FUNCT_7:34;
per cases ;
suppose L1239: (C334 in ( dom D194 ) & ( D194 +* (C334 , C339) ) in ( dom ( C337 . C339 ) ) & ( ( D194 +* (C334 , C339) ) ^ <* ( ( C337 . C339 ) . ( D194 +* (C334 , C339) ) ) *> ) in ( dom C332 ));

thus L1240: ( C337 . ( C339 + 1 ) ) = ( ( C337 . C339 ) +* ( ( D194 +* (C334 , ( C339 + 1 )) ) .--> ( C332 . ( ( D194 +* (C334 , C339) ) ^ <* ( ( C337 . C339 ) . ( D194 +* (C334 , C339) ) ) *> ) ) ) ) by L1239 , L1229
.= ( C336 . ( C339 + 1 ) ) by L1226 , L1230 , L1232 , L1236 , L1238 , L1237 , L1239;
end;
suppose L1241: ((not C334 in ( dom D194 )) or (not ( D194 +* (C334 , C339) ) in ( dom ( C337 . C339 ) )) or (not ( ( D194 +* (C334 , C339) ) ^ <* ( ( C337 . C339 ) . ( D194 +* (C334 , C339) ) ) *> ) in ( dom C332 )));

thus L1242: ( C337 . ( C339 + 1 ) ) = ( C337 . C339 ) by L1241 , L1229
.= ( C336 . ( C339 + 1 ) ) by L1226 , L1230 , L1232 , L1236 , L1238 , L1241;
end;
end;
L1244: S16[ ( 0 ) ] by L1224 , L1225 , L1227 , L1228 , L1230 , L1231 , L1233 , FUNCT_7:30;
L1245: (for B183 being (Element of ( NAT )) holds S16[ B183 ]) from NAT_1:sch 1(L1244 , L1235);
assume L1246: C338 in ( NAT );
thus L1247: thesis by L1246 , L1245;
end;
thus L1248: C336 = C337 by L1234 , FUNCT_2:12;
end;
L1249:
now
let C340 , C341 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C342 being (Element of ( ( ( arity C340 ) + 1 ) -tuples_on ( NAT ) ));
let C343 , C344 being (Element of ( NAT ));
assume that
L1250: C343 in ( dom C342 );
set D195 = ( C342 +* (C343 , C344) );
set D196 = ( C342 +* (C343 , ( C344 + 1 )) );
let C345 being (Function of ( NAT ) , ( HFuncs ( NAT ) ));
assume that
L1251: ((C343 in ( dom D196 ) & ( Del (D196 , C343) ) in ( dom C340 )) implies ( C345 . ( 0 ) ) = ( { ( D196 +* (C343 , ( 0 )) ) } --> ( C340 . ( Del (D196 , C343) ) ) ))
and
L1252: (((not C343 in ( dom D196 )) or (not ( Del (D196 , C343) ) in ( dom C340 ))) implies ( C345 . ( 0 ) ) = ( {} ))
and
L1253: (for B184 being (Element of ( NAT )) holds S3[ B184 , (( C345 . B184 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C345 . ( B184 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D196 , C343 , C341 ]);
thus L1254: ( ( C345 . ( C344 + 1 ) ) . D195 ) = ( ( C345 . C344 ) . D195 )
proof
per cases ;
suppose L1255: (C343 in ( dom D196 ) & ( D196 +* (C343 , C344) ) in ( dom ( C345 . C344 ) ) & ( ( D196 +* (C343 , C344) ) ^ <* ( ( C345 . C344 ) . ( D196 +* (C343 , C344) ) ) *> ) in ( dom C341 ));

L1256: D196 = ( D196 +* (C343 , ( C344 + 1 )) ) by FUNCT_7:34;
L1257: ( D196 . C343 ) = ( C344 + 1 ) by L1250 , FUNCT_7:31;
L1258: ( D195 . C343 ) = C344 by L1250 , FUNCT_7:31;
L1259: D195 <> D196 by L1258 , L1257;
L1260: (not D195 in ( dom ( { ( D196 +* (C343 , ( C344 + 1 )) ) } --> ( C341 . ( ( D196 +* (C343 , C344) ) ^ <* ( ( C345 . C344 ) . ( D196 +* (C343 , C344) ) ) *> ) ) ) )) by L1259 , L1256 , TARSKI:def 1;
L1261: ( C345 . ( C344 + 1 ) ) = ( ( C345 . C344 ) +* ( ( D196 +* (C343 , ( C344 + 1 )) ) .--> ( C341 . ( ( D196 +* (C343 , C344) ) ^ <* ( ( C345 . C344 ) . ( D196 +* (C343 , C344) ) ) *> ) ) ) ) by L1253 , L1255;
thus L1262: thesis by L1261 , L1260 , FUNCT_4:11;
end;
suppose L1263: ((not C343 in ( dom D196 )) or (not ( D196 +* (C343 , C344) ) in ( dom ( C345 . C344 ) )) or (not ( ( D196 +* (C343 , C344) ) ^ <* ( ( C345 . C344 ) . ( D196 +* (C343 , C344) ) ) *> ) in ( dom C341 )));

thus L1264: thesis by L1263 , L1253;
end;
end;

L1266: (for B185 , B186 being (Element of ( NAT )) holds (( C342 +* (C343 , B186) ) in ( dom ( C345 . B185 ) ) implies B186 <= B185))
proof
defpred S17[ (Element of ( NAT )) ] means (for B187 being (Element of ( NAT )) holds (( C342 +* (C343 , B187) ) in ( dom ( C345 . $1 ) ) implies B187 <= $1));
L1267: (for B188 being (Element of ( NAT )) holds (S17[ B188 ] implies S17[ ( B188 + 1 ) ]))
proof
let C346 being (Element of ( NAT ));
assume that
L1268: S17[ C346 ];
let C347 being (Element of ( NAT ));
assume that
L1269: ( C342 +* (C343 , C347) ) in ( dom ( C345 . ( C346 + 1 ) ) );
per cases ;
suppose L1270: (C343 in ( dom D196 ) & ( D196 +* (C343 , C346) ) in ( dom ( C345 . C346 ) ) & ( ( D196 +* (C343 , C346) ) ^ <* ( ( C345 . C346 ) . ( D196 +* (C343 , C346) ) ) *> ) in ( dom C341 ));

L1271: ( C345 . ( C346 + 1 ) ) = ( ( C345 . C346 ) +* ( ( D196 +* (C343 , ( C346 + 1 )) ) .--> ( C341 . ( ( D196 +* (C343 , C346) ) ^ <* ( ( C345 . C346 ) . ( D196 +* (C343 , C346) ) ) *> ) ) ) ) by L1270 , L1253;
L1272: ( dom ( C345 . ( C346 + 1 ) ) ) = ( ( dom ( C345 . C346 ) ) \/ ( dom ( { ( D196 +* (C343 , ( C346 + 1 )) ) } --> ( C341 . ( ( D196 +* (C343 , C346) ) ^ <* ( ( C345 . C346 ) . ( D196 +* (C343 , C346) ) ) *> ) ) ) ) ) by L1271 , FUNCT_4:def 1;
L1273: ( dom ( C345 . ( C346 + 1 ) ) ) = ( ( dom ( C345 . C346 ) ) \/ { ( D196 +* (C343 , ( C346 + 1 )) ) } ) by L1272 , FUNCOP_1:13;
thus L1274: C347 <= ( C346 + 1 )
proof
per cases  by L1269 , L1273 , XBOOLE_0:def 3;
suppose L1275: ( C342 +* (C343 , C347) ) in ( dom ( C345 . C346 ) );

L1276: C346 <= ( C346 + 1 ) by NAT_1:11;
L1277: C347 <= C346 by L1268 , L1275;
thus L1278: thesis by L1277 , L1276 , XXREAL_0:2;
end;
suppose L1279: ( C342 +* (C343 , C347) ) in { ( D196 +* (C343 , ( C346 + 1 )) ) };

L1280: ( C342 +* (C343 , C347) ) = ( D196 +* (C343 , ( C346 + 1 )) ) by L1279 , TARSKI:def 1
.= ( C342 +* (C343 , ( C346 + 1 )) ) by FUNCT_7:34;
L1281: C347 = ( ( C342 +* (C343 , C347) ) . C343 ) by L1250 , FUNCT_7:31
.= ( C346 + 1 ) by L1250 , L1280 , FUNCT_7:31;
thus L1282: thesis by L1281;
end;
end;

end;
suppose L1275: ((not C343 in ( dom D196 )) or (not ( D196 +* (C343 , C346) ) in ( dom ( C345 . C346 ) )) or (not ( ( D196 +* (C343 , C346) ) ^ <* ( ( C345 . C346 ) . ( D196 +* (C343 , C346) ) ) *> ) in ( dom C341 )));

L1276: ( C345 . ( C346 + 1 ) ) = ( C345 . C346 ) by L1275 , L1253;
L1277: C347 <= C346 by L1276 , L1268 , L1269;
L1278: C346 <= ( C346 + 1 ) by NAT_1:11;
thus L1279: thesis by L1278 , L1277 , XXREAL_0:2;
end;
end;
L1281: S17[ ( 0 ) ]
proof
let C348 being (Element of ( NAT ));
assume that
L1282: ( C342 +* (C343 , C348) ) in ( dom ( C345 . ( 0 ) ) );
per cases ;
suppose L1283: (C343 in ( dom D196 ) & ( Del (D196 , C343) ) in ( dom C340 ));

L1284: ( dom ( C345 . ( 0 ) ) ) = { ( D196 +* (C343 , ( 0 )) ) } by L1283 , L1251 , FUNCOP_1:13;
L1285: ( C342 +* (C343 , C348) ) = ( D196 +* (C343 , ( 0 )) ) by L1284 , L1282 , TARSKI:def 1
.= ( C342 +* (C343 , ( 0 )) ) by FUNCT_7:34;
L1286: C348 = ( ( C342 +* (C343 , C348) ) . C343 ) by L1250 , FUNCT_7:31
.= ( 0 ) by L1250 , L1285 , FUNCT_7:31;
thus L1287: thesis by L1286;
end;
suppose L1288: ((not C343 in ( dom D196 )) or (not ( Del (D196 , C343) ) in ( dom C340 )));

thus L1289: thesis by L1288 , L1252 , L1282;
end;
end;
thus L1291: (for B189 being (Element of ( NAT )) holds S17[ B189 ]) from NAT_1:sch 1(L1281 , L1267);
end;
thus L1292: (not D196 in ( dom ( C345 . C344 ) ))
proof
assume L1293: (not thesis);
L1294: ( C344 + 1 ) <= C344 by L1293 , L1266;
thus L1295: contradiction by L1294 , NAT_1:13;
end;

end;
definition
let C349 being Nat;
let C350 being (Element of ( C349 -tuples_on ( NAT ) ));
let C351 , C352 being (Element of ( NAT ));
redefine func C350 +* (C351 , C352) -> (Element of ( C349 -tuples_on ( NAT ) ));

coherence
proof
L1293: ( dom ( C350 +* (C351 , C352) ) ) = ( dom C350 ) by FUNCT_7:30;
L1294: ( len ( C350 +* (C351 , C352) ) ) = ( len C350 ) by L1293 , FINSEQ_3:29
.= C349 by CARD_1:def 7;
thus L1295: ( C350 +* (C351 , C352) ) is (Element of ( C349 -tuples_on ( NAT ) )) by L1294 , FINSEQ_2:92;
end;
end;
L1297:
now
let C353 , C354 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C355 being (Element of ( ( ( arity C353 ) + 1 ) -tuples_on ( NAT ) ));
let C356 , C357 being (Element of ( NAT ));
assume that
L1298: C356 in ( dom C355 );
let C358 being (Function of ( ( ( arity C353 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) ));
assume that
L1299: (for B190 being (Element of ( ( ( arity C353 ) + 1 ) -tuples_on ( NAT ) )) holds ( C358 . B190 ) = ( primrec (C353 , C354 , C356 , B190) ));
thus L1300: (for B191 , B192 being (Element of ( NAT )) holds ( dom ( C358 . ( C355 +* (C356 , B191) ) ) ) c= ( dom ( C358 . ( C355 +* (C356 , ( B191 + B192 )) ) ) ))
proof
let C359 being (Element of ( NAT ));
set D197 = ( C355 +* (C356 , C359) );
defpred S18[ (Element of ( NAT )) ] means ( dom ( C358 . D197 ) ) c= ( dom ( C358 . ( C355 +* (C356 , ( C359 + $1 )) ) ) );
L1301:
now
let C360 being (Element of ( NAT ));
assume that
L1302: S18[ C360 ];
set D198 = ( C359 + C360 );
set D199 = ( C355 +* (C356 , ( ( C359 + C360 ) + 1 )) );
set D200 = ( C355 +* (C356 , ( C359 + C360 )) );
consider C361 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1303: ( primrec (C353 , C354 , C356 , D200) ) = ( C361 . ( D200 /. C356 ) ) and L1304: ((C356 in ( dom D200 ) & ( Del (D200 , C356) ) in ( dom C353 )) implies ( C361 . ( 0 ) ) = ( ( D200 +* (C356 , ( 0 )) ) .--> ( C353 . ( Del (D200 , C356) ) ) )) and L1305: (((not C356 in ( dom D200 )) or (not ( Del (D200 , C356) ) in ( dom C353 ))) implies ( C361 . ( 0 ) ) = ( {} )) and L1306: (for B193 being (Element of ( NAT )) holds S3[ B193 , (( C361 . B193 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C361 . ( B193 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D200 , C356 , C354 ]) by L852;
L1307: ( dom C355 ) = ( dom D199 ) by FUNCT_7:30;
L1308: ( D199 /. C356 ) = ( D199 . C356 ) by L1307 , L1298 , PARTFUN1:def 6
.= ( D198 + 1 ) by L1298 , FUNCT_7:31;
consider C362 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1309: ( primrec (C353 , C354 , C356 , D199) ) = ( C362 . ( D199 /. C356 ) ) and L1310: ((C356 in ( dom D199 ) & ( Del (D199 , C356) ) in ( dom C353 )) implies ( C362 . ( 0 ) ) = ( ( D199 +* (C356 , ( 0 )) ) .--> ( C353 . ( Del (D199 , C356) ) ) )) and L1311: (((not C356 in ( dom D199 )) or (not ( Del (D199 , C356) ) in ( dom C353 ))) implies ( C362 . ( 0 ) ) = ( {} )) and L1312: (for B194 being (Element of ( NAT )) holds S3[ B194 , (( C362 . B194 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C362 . ( B194 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D199 , C356 , C354 ]) by L852;
L1313: C362 = C361 by L1304 , L1305 , L1306 , L1310 , L1311 , L1312 , L1223;
L1314: ( C358 . ( C355 +* (C356 , ( C359 + ( C360 + 1 ) )) ) ) = ( C361 . ( D198 + 1 ) ) by L1313 , L1299 , L1309 , L1308;
L1315: ( dom C355 ) = ( dom D200 ) by FUNCT_7:30;
L1316: ( D200 /. C356 ) = ( D200 . C356 ) by L1315 , L1298 , PARTFUN1:def 6
.= D198 by L1298 , FUNCT_7:31;
L1317: ( C358 . ( C355 +* (C356 , ( C359 + C360 )) ) ) = ( C361 . D198 ) by L1316 , L1299 , L1303;
per cases ;
suppose L1318: (C356 in ( dom D200 ) & ( D200 +* (C356 , D198) ) in ( dom ( C361 . D198 ) ) & ( ( D200 +* (C356 , D198) ) ^ <* ( ( C361 . D198 ) . ( D200 +* (C356 , D198) ) ) *> ) in ( dom C354 ));

L1319: ( C361 . ( D198 + 1 ) ) = ( ( C361 . D198 ) +* ( ( D200 +* (C356 , ( D198 + 1 )) ) .--> ( C354 . ( ( D200 +* (C356 , D198) ) ^ <* ( ( C361 . D198 ) . ( D200 +* (C356 , D198) ) ) *> ) ) ) ) by L1318 , L1306;
L1320: ( dom ( C361 . ( D198 + 1 ) ) ) = ( ( dom ( C361 . D198 ) ) \/ ( dom ( { ( D200 +* (C356 , ( D198 + 1 )) ) } --> ( C354 . ( ( D200 +* (C356 , D198) ) ^ <* ( ( C361 . D198 ) . ( D200 +* (C356 , D198) ) ) *> ) ) ) ) ) by L1319 , FUNCT_4:def 1;
L1321: ( dom ( C361 . D198 ) ) c= ( dom ( C361 . ( D198 + 1 ) ) ) by L1320 , XBOOLE_1:7;
thus L1322: S18[ ( C360 + 1 ) ] by L1321 , L1302 , L1314 , L1317 , XBOOLE_1:1;
end;
suppose L1323: ((not C356 in ( dom D200 )) or (not ( D200 +* (C356 , D198) ) in ( dom ( C361 . D198 ) )) or (not ( ( D200 +* (C356 , D198) ) ^ <* ( ( C361 . D198 ) . ( D200 +* (C356 , D198) ) ) *> ) in ( dom C354 )));

thus L1324: S18[ ( C360 + 1 ) ] by L1323 , L1302 , L1306 , L1314 , L1317;
end;
end;
L1326: S18[ ( 0 ) ];
thus L1327: (for B195 being (Element of ( NAT )) holds S18[ B195 ]) from NAT_1:sch 1(L1326 , L1301);
end;

end;
L1301:
now
let C363 , C364 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let C365 being (Element of ( ( ( arity C363 ) + 1 ) -tuples_on ( NAT ) ));
let C366 , C367 being (Element of ( NAT ));
assume that
L1302: C366 in ( dom C365 );
let C368 being (Function of ( ( ( arity C363 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) ));
assume that
L1303: (for B196 being (Element of ( ( ( arity C363 ) + 1 ) -tuples_on ( NAT ) )) holds ( C368 . B196 ) = ( primrec (C363 , C364 , C366 , B196) ));
thus L1304: (for B197 , B198 being (Element of ( NAT )) holds ((not ( C365 +* (C366 , B197) ) in ( dom ( C368 . ( C365 +* (C366 , B197) ) ) )) implies (not ( C365 +* (C366 , B197) ) in ( dom ( C368 . ( C365 +* (C366 , ( B197 + B198 )) ) ) ))))
proof
let C369 being (Element of ( NAT ));
set D201 = ( C365 +* (C366 , C369) );
defpred S19[ (Element of ( NAT )) ] means ((not D201 in ( dom ( C368 . D201 ) )) implies (not D201 in ( dom ( C368 . ( C365 +* (C366 , ( C369 + $1 )) ) ) )));
L1305: (for B199 being (Element of ( NAT )) holds (S19[ B199 ] implies S19[ ( B199 + 1 ) ]))
proof
let C370 being (Element of ( NAT ));
assume that
L1306: S19[ C370 ]
and
L1307: (not D201 in ( dom ( C368 . D201 ) ));
set D202 = ( C369 + C370 );
set D203 = ( C365 +* (C366 , ( C369 + C370 )) );
consider C371 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1308: ( primrec (C363 , C364 , C366 , D203) ) = ( C371 . ( D203 /. C366 ) ) and L1309: ((C366 in ( dom D203 ) & ( Del (D203 , C366) ) in ( dom C363 )) implies ( C371 . ( 0 ) ) = ( ( D203 +* (C366 , ( 0 )) ) .--> ( C363 . ( Del (D203 , C366) ) ) )) and L1310: (((not C366 in ( dom D203 )) or (not ( Del (D203 , C366) ) in ( dom C363 ))) implies ( C371 . ( 0 ) ) = ( {} )) and L1311: (for B200 being (Element of ( NAT )) holds S3[ B200 , (( C371 . B200 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C371 . ( B200 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D203 , C366 , C364 ]) by L852;
L1312: ( dom C365 ) = ( dom D203 ) by FUNCT_7:30;
L1313: ( D203 /. C366 ) = ( D203 . C366 ) by L1312 , L1302 , PARTFUN1:def 6
.= D202 by L1302 , FUNCT_7:31;
L1314: (not D201 in ( dom ( C371 . D202 ) )) by L1313 , L1303 , L1306 , L1307 , L1308;
set D204 = ( C365 +* (C366 , ( ( C369 + C370 ) + 1 )) );
consider C372 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1315: ( primrec (C363 , C364 , C366 , D204) ) = ( C372 . ( D204 /. C366 ) ) and L1316: ((C366 in ( dom D204 ) & ( Del (D204 , C366) ) in ( dom C363 )) implies ( C372 . ( 0 ) ) = ( ( D204 +* (C366 , ( 0 )) ) .--> ( C363 . ( Del (D204 , C366) ) ) )) and L1317: (((not C366 in ( dom D204 )) or (not ( Del (D204 , C366) ) in ( dom C363 ))) implies ( C372 . ( 0 ) ) = ( {} )) and L1318: (for B201 being (Element of ( NAT )) holds S3[ B201 , (( C372 . B201 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C372 . ( B201 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D204 , C366 , C364 ]) by L852;
L1319: ( dom C365 ) = ( dom D204 ) by FUNCT_7:30;
L1320: ( D204 /. C366 ) = ( D204 . C366 ) by L1319 , L1302 , PARTFUN1:def 6
.= ( D202 + 1 ) by L1302 , FUNCT_7:31;
L1321: C372 = C371 by L1309 , L1310 , L1311 , L1316 , L1317 , L1318 , L1223;
L1322: ( C368 . ( C365 +* (C366 , ( C369 + ( C370 + 1 ) )) ) ) = ( C371 . ( D202 + 1 ) ) by L1321 , L1303 , L1315 , L1320;
per cases ;
suppose L1323: (C366 in ( dom D203 ) & ( D203 +* (C366 , D202) ) in ( dom ( C371 . D202 ) ) & ( ( D203 +* (C366 , D202) ) ^ <* ( ( C371 . D202 ) . ( D203 +* (C366 , D202) ) ) *> ) in ( dom C364 ));

L1324: ( C371 . ( D202 + 1 ) ) = ( ( C371 . D202 ) +* ( ( D203 +* (C366 , ( D202 + 1 )) ) .--> ( C364 . ( ( D203 +* (C366 , D202) ) ^ <* ( ( C371 . D202 ) . ( D203 +* (C366 , D202) ) ) *> ) ) ) ) by L1323 , L1311;
L1325: ( dom ( C371 . ( D202 + 1 ) ) ) = ( ( dom ( C371 . D202 ) ) \/ ( dom ( { ( D203 +* (C366 , ( D202 + 1 )) ) } --> ( C364 . ( ( D203 +* (C366 , D202) ) ^ <* ( ( C371 . D202 ) . ( D203 +* (C366 , D202) ) ) *> ) ) ) ) ) by L1324 , FUNCT_4:def 1;
L1326: ( dom ( C371 . ( D202 + 1 ) ) ) = ( ( dom ( C371 . D202 ) ) \/ { ( D203 +* (C366 , ( D202 + 1 )) ) } ) by L1325 , FUNCOP_1:13;
L1327: C369 <= ( C369 + C370 ) by NAT_1:11;
L1328: C369 <> ( D202 + 1 ) by L1327 , NAT_1:13;
L1329: ( D201 . C366 ) = C369 by L1302 , FUNCT_7:31;
L1330: ( ( D203 +* (C366 , ( D202 + 1 )) ) . C366 ) = ( D202 + 1 ) by L1302 , L1312 , FUNCT_7:31;
L1331: (not D201 in { ( D203 +* (C366 , ( D202 + 1 )) ) }) by L1330 , L1328 , L1329 , TARSKI:def 1;
thus L1332: thesis by L1331 , L1314 , L1322 , L1326 , XBOOLE_0:def 3;
end;
suppose L1333: ((not C366 in ( dom D203 )) or (not ( D203 +* (C366 , D202) ) in ( dom ( C371 . D202 ) )) or (not ( ( D203 +* (C366 , D202) ) ^ <* ( ( C371 . D202 ) . ( D203 +* (C366 , D202) ) ) *> ) in ( dom C364 )));

thus L1334: thesis by L1333 , L1311 , L1314 , L1322;
end;
end;
L1336: S19[ ( 0 ) ];
thus L1337: (for B202 being (Element of ( NAT )) holds S19[ B202 ]) from NAT_1:sch 1(L1336 , L1305);
end;

end;
L1305: (for R1 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds (R1 in ( dom R24 ) implies ((( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) iff ( Del (R24 , R1) ) in ( dom R20 )) & (( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) implies ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (R24 , R1) ) )) & (( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) iff (( R24 +* (R1 , R5) ) in ( dom ( primrec (R20 , R21 , R1) ) ) & ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) in ( dom R21 ))) & (( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) implies ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( R5 + 1 )) ) ) = ( R21 . ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) )))))))))
proof
let R1 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ));
set D205 = ( R24 +* (R1 , ( 0 )) );
consider C373 being (Function of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) , ( HFuncs ( NAT ) )) such that L1306: ( primrec (R20 , R21 , R1) ) = ( Union C373 ) and L1307: (for B203 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ( C373 . B203 ) = ( primrec (R20 , R21 , R1 , B203) )) by L1137;
reconsider D206 = ( rng C373 ) as  functional  compatible set by L1306 , L166;
assume L1308: R1 in ( dom R24 );
L1309:
now
let C374 being (Element of ( NAT ));
assume that
L1310: ( R24 +* (R1 , C374) ) in ( dom ( primrec (R20 , R21 , R1) ) )
and
L1311: (not ( R24 +* (R1 , C374) ) in ( dom ( C373 . ( R24 +* (R1 , C374) ) ) ));
L1312: ( union D206 ) <> ( {} ) by L1306 , L1310;
reconsider D207 = ( rng C373 ) as non  empty  functional  compatible set by L1312;
set D208 = ( R24 +* (R1 , C374) );
L1313: ( dom ( union D207 ) ) = ( union { ( dom B204 ) where B204 is (Element of D207) : (not contradiction) } ) by L195;
consider C375 being set such that L1314: D208 in C375 and L1315: C375 in { ( dom B205 ) where B205 is (Element of D207) : (not contradiction) } by L1313 , L1306 , L1310 , TARSKI:def 4;
consider C376 being (Element of D207) such that L1316: C375 = ( dom C376 ) and L1317: (not contradiction) by L1315;
consider C377 being set such that L1318: C377 in ( dom C373 ) and L1319: C376 = ( C373 . C377 ) by FUNCT_1:def 3;
reconsider D209 = C377 as (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) by L1318;
L1320: ( C373 . D209 ) = ( primrec (R20 , R21 , R1 , D209) ) by L1307;
L1321: (ex B206 being (Element of ( NAT )) st D208 = ( D209 +* (R1 , B206) )) by L1320 , L1314 , L1316 , L1319 , L906;
set D210 = ( D209 . R1 );
L1322: ( R24 +* (R1 , D210) ) = ( D208 +* (R1 , D210) ) by FUNCT_7:34
.= ( D209 +* (R1 , D210) ) by L1321 , FUNCT_7:34
.= D209 by FUNCT_7:35;
per cases  by XXREAL_0:1;
suppose L1323: C374 = D210;

thus L1324: contradiction by L1323 , L1311 , L1314 , L1316 , L1319 , L1322;
end;
suppose L1325: D210 < C374;

consider C378 being Nat such that L1326: C374 = ( D210 + C378 ) by L1325 , NAT_1:10;
reconsider D211 = C378 as (Element of ( NAT )) by ORDINAL1:def 12;
L1327: C374 = ( D210 + D211 ) by L1326;
L1328: ( dom ( C373 . D209 ) ) c= ( dom ( C373 . D208 ) ) by L1327 , L1308 , L1307 , L1322 , L1297;
thus L1329: contradiction by L1328 , L1311 , L1314 , L1316 , L1319;
end;
suppose L1330: D210 > C374;

consider C379 being Nat such that L1331: D210 = ( C374 + C379 ) by L1330 , NAT_1:10;
reconsider D212 = C379 as (Element of ( NAT )) by ORDINAL1:def 12;
L1332: D210 = ( C374 + D212 ) by L1331;
thus L1333: contradiction by L1332 , L1308 , L1307 , L1311 , L1314 , L1316 , L1319 , L1322 , L1301;
end;
end;
L1335: ( dom R24 ) = ( dom D205 ) by FUNCT_7:30;
L1336:
now
L1337: D205 in { D205 } by TARSKI:def 1;
L1338: ( D205 /. R1 ) = ( D205 . R1 ) by L1308 , L1335 , PARTFUN1:def 6
.= ( 0 ) by L1308 , FUNCT_7:31;
consider C380 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1339: ( primrec (R20 , R21 , R1 , D205) ) = ( C380 . ( D205 /. R1 ) ) and L1340: ((R1 in ( dom D205 ) & ( Del (D205 , R1) ) in ( dom R20 )) implies ( C380 . ( 0 ) ) = ( ( D205 +* (R1 , ( 0 )) ) .--> ( R20 . ( Del (D205 , R1) ) ) )) and L1341: (((not R1 in ( dom D205 )) or (not ( Del (D205 , R1) ) in ( dom R20 ))) implies ( C380 . ( 0 ) ) = ( {} )) and L1342: (for B207 being (Element of ( NAT )) holds S3[ B207 , (( C380 . B207 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C380 . ( B207 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D205 , R1 , R21 ]) by L852;
L1343: ( C373 . D205 ) = ( primrec (R20 , R21 , R1 , D205) ) by L1307;
thus L1344: (D205 in ( dom ( C373 . D205 ) ) iff ( Del (R24 , R1) ) in ( dom R20 ))
proof
thus L1345: (D205 in ( dom ( C373 . D205 ) ) implies ( Del (R24 , R1) ) in ( dom R20 )) by L1307 , L1339 , L1341 , L1338 , L30 , RELAT_1:38;
assume L1346: ( Del (R24 , R1) ) in ( dom R20 );
L1347: ( dom ( C380 . ( 0 ) ) ) = { ( D205 +* (R1 , ( 0 )) ) } by L1346 , L1308 , L1340 , L30 , FUNCOP_1:13 , FUNCT_7:30
.= { D205 } by FUNCT_7:34;
thus L1348: thesis by L1347 , L1343 , L1339 , L1338 , TARSKI:def 1;
end;

assume L1349: D205 in ( dom ( C373 . D205 ) );
L1350: ( C380 . ( 0 ) ) = ( { D205 } --> ( R20 . ( Del (D205 , R1) ) ) ) by L1349 , L1307 , L1339 , L1340 , L1341 , L1338 , FUNCT_7:34 , RELAT_1:38;
L1351: ( C380 . ( 0 ) ) = ( { D205 } --> ( R20 . ( Del (R24 , R1) ) ) ) by L1350 , L30;
thus L1352: ( ( C373 . D205 ) . D205 ) = ( R20 . ( Del (R24 , R1) ) ) by L1351 , L1343 , L1339 , L1338 , L1337 , FUNCOP_1:7;
end;
set D213 = ( R24 +* (R1 , ( R5 + 1 )) );
set D214 = ( R24 +* (R1 , R5) );
set D215 = <* ( ( C373 . D213 ) . ( D213 +* (R1 , R5) ) ) *>;
L1353: ( dom C373 ) = ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ) by FUNCT_2:def 1;
L1354: ( C373 . D213 ) in ( rng C373 ) by L1353 , FUNCT_1:def 3;
reconsider D216 = D206 as non  empty  functional  compatible set;
L1355: ( C373 . D205 ) in ( rng C373 ) by L1353 , FUNCT_1:def 3;
thus L1356: (( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) iff ( Del (R24 , R1) ) in ( dom R20 ))
proof
thus L1357: (( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) implies ( Del (R24 , R1) ) in ( dom R20 )) by L1309 , L1336;
assume L1358: ( Del (R24 , R1) ) in ( dom R20 );
L1359: ( dom ( C373 . D205 ) ) in { ( dom B208 ) where B208 is (Element of D216) : (not contradiction) } by L1355;
L1360: D205 in ( union { ( dom B209 ) where B209 is (Element of D216) : (not contradiction) } ) by L1359 , L1336 , L1358 , TARSKI:def 4;
thus L1361: thesis by L1360 , L1306 , L195;
end;

thus L1362:now
assume L1363: ( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) );
L1364: D205 in ( dom ( C373 . D205 ) ) by L1363 , L1309;
L1365: ( ( union D216 ) . D205 ) = ( ( C373 . D205 ) . D205 ) by L1364 , L1355 , L214;
thus L1366: ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (R24 , R1) ) ) by L1365 , L1306 , L1309 , L1336 , L1363;
end;
L1367: ( dom R24 ) = ( dom D213 ) by FUNCT_7:30;
L1368: ( D213 +* (R1 , ( R5 + 1 )) ) = D213 by FUNCT_7:34;
L1369: ( D213 +* (R1 , R5) ) = D214 by FUNCT_7:34;
L1370: ( dom R24 ) = ( dom D214 ) by FUNCT_7:30;
L1371:
now
L1372: ( D214 /. R1 ) = ( D214 . R1 ) by L1308 , L1370 , PARTFUN1:def 6
.= R5 by L1308 , FUNCT_7:31;
consider C381 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1373: ( primrec (R20 , R21 , R1 , D214) ) = ( C381 . ( D214 /. R1 ) ) and L1374: ((R1 in ( dom D214 ) & ( Del (D214 , R1) ) in ( dom R20 )) implies ( C381 . ( 0 ) ) = ( ( D214 +* (R1 , ( 0 )) ) .--> ( R20 . ( Del (D214 , R1) ) ) )) and L1375: (((not R1 in ( dom D214 )) or (not ( Del (D214 , R1) ) in ( dom R20 ))) implies ( C381 . ( 0 ) ) = ( {} )) and L1376: (for B210 being (Element of ( NAT )) holds S3[ B210 , (( C381 . B210 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C381 . ( B210 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D214 , R1 , R21 ]) by L852;
L1377: ( C373 . D213 ) = ( primrec (R20 , R21 , R1 , D213) ) by L1307;
consider C382 being (Function of ( NAT ) , ( HFuncs ( NAT ) )) such that L1378: ( primrec (R20 , R21 , R1 , D213) ) = ( C382 . ( D213 /. R1 ) ) and L1379: ((R1 in ( dom D213 ) & ( Del (D213 , R1) ) in ( dom R20 )) implies ( C382 . ( 0 ) ) = ( ( D213 +* (R1 , ( 0 )) ) .--> ( R20 . ( Del (D213 , R1) ) ) )) and L1380: (((not R1 in ( dom D213 )) or (not ( Del (D213 , R1) ) in ( dom R20 ))) implies ( C382 . ( 0 ) ) = ( {} )) and L1381: (for B211 being (Element of ( NAT )) holds S3[ B211 , (( C382 . B211 ) qua (Element of ( HFuncs ( NAT ) ))) , (( C382 . ( B211 + 1 ) ) qua (Element of ( HFuncs ( NAT ) ))) , D213 , R1 , R21 ]) by L852;
L1382: ( ( C382 . ( R5 + 1 ) ) . D214 ) = ( ( C382 . R5 ) . D214 ) by L1308 , L1379 , L1380 , L1381 , L1249;
L1383: D213 in { D213 } by TARSKI:def 1;
L1384: D213 in ( dom ( { D213 } --> ( R21 . ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) ) ) ) by L1383 , FUNCOP_1:13;
L1385: ( C373 . D214 ) = ( primrec (R20 , R21 , R1 , D214) ) by L1307;
L1386: ( D213 /. R1 ) = ( D213 . R1 ) by L1308 , L1367 , PARTFUN1:def 6
.= ( R5 + 1 ) by L1308 , FUNCT_7:31;
L1387: ( C382 . R5 ) = ( C381 . R5 ) by L1379 , L1380 , L1381 , L1374 , L1375 , L1376 , L1223;
L1388: (not D213 in ( dom ( C382 . R5 ) )) by L1308 , L1379 , L1380 , L1381 , L1249;
thus L1389: (D213 in ( dom ( C373 . D213 ) ) iff (D214 in ( dom ( C373 . D214 ) ) & ( D214 ^ D215 ) in ( dom R21 )))
proof
thus L1390:now
assume L1391: D213 in ( dom ( C373 . D213 ) );
L1392: D213 in ( dom ( C382 . ( R5 + 1 ) ) ) by L1391 , L1307 , L1378 , L1386;
assume L1393: (not (D214 in ( dom ( C373 . D214 ) ) & ( D214 ^ D215 ) in ( dom R21 )));
per cases  by L1393;
suppose L1394: (not D214 in ( dom ( C373 . D214 ) ));

L1395: (not D214 in ( dom ( C382 . R5 ) )) by L1394 , L1307 , L1373 , L1372 , L1387;
thus L1396: contradiction by L1395 , L1369 , L1381 , L1388 , L1392;
end;
suppose L1397: (not ( D214 ^ D215 ) in ( dom R21 ));

thus L1398: contradiction by L1397 , L1369 , L1377 , L1378 , L1381 , L1386 , L1382 , L1388 , L1391;
end;
end;
assume that
L1400: D214 in ( dom ( C373 . D214 ) )
and
L1401: ( D214 ^ D215 ) in ( dom R21 );
L1402: D213 in { D213 } by TARSKI:def 1;
L1403: D213 in ( dom ( { D213 } --> ( R21 . ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) ) ) ) by L1402 , FUNCOP_1:13;
L1404: D213 in ( ( dom ( C382 . R5 ) ) \/ ( dom ( { D213 } --> ( R21 . ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) ) ) ) ) by L1403 , XBOOLE_0:def 3;
L1405: ( C382 . ( R5 + 1 ) ) = ( ( C382 . R5 ) +* ( D213 .--> ( R21 . ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) ) ) ) by L1308 , L1367 , L1369 , L1368 , L1377 , L1385 , L1378 , L1381 , L1373 , L1386 , L1372 , L1387 , L1382 , L1400 , L1401;
thus L1406: thesis by L1405 , L1377 , L1378 , L1386 , L1404 , FUNCT_4:def 1;
end;

assume L1407: D213 in ( dom ( C373 . D213 ) );
L1408: ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) in ( dom R21 ) by L1407 , L1369 , L1377 , L1378 , L1381 , L1386 , L1389;
L1409: ( C382 . ( R5 + 1 ) ) = ( ( C382 . R5 ) +* ( D213 .--> ( R21 . ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) ) ) ) by L1408 , L1308 , L1367 , L1369 , L1368 , L1385 , L1381 , L1373 , L1372 , L1387 , L1389 , L1407;
thus L1410: ( ( C373 . D213 ) . D213 ) = ( ( { D213 } --> ( R21 . ( D214 ^ <* ( ( C382 . R5 ) . D214 ) *> ) ) ) . D213 ) by L1409 , L1377 , L1378 , L1386 , L1384 , FUNCT_4:13
.= ( R21 . ( D214 ^ D215 ) ) by L1369 , L1377 , L1378 , L1386 , L1382 , L1383 , FUNCOP_1:7;
end;
thus L1411: (( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) iff (( R24 +* (R1 , R5) ) in ( dom ( primrec (R20 , R21 , R1) ) ) & ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) in ( dom R21 )))
proof
thus L1412:now
assume L1413: ( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) );
L1414: ( C373 . D214 ) in ( rng C373 ) by L1353 , FUNCT_1:def 3;
L1415: ( dom ( C373 . D214 ) ) in { ( dom B212 ) where B212 is (Element of D216) : (not contradiction) } by L1414;
L1416: D214 in ( union { ( dom B213 ) where B213 is (Element of D216) : (not contradiction) } ) by L1415 , L1309 , L1371 , L1413 , TARSKI:def 4;
thus L1417: ( R24 +* (R1 , R5) ) in ( dom ( primrec (R20 , R21 , R1) ) ) by L1416 , L1306 , L195;
L1418: ( C373 . D213 ) in ( rng C373 ) by L1353 , FUNCT_1:def 3;
L1419: ( dom ( C373 . D214 ) ) c= ( dom ( C373 . D213 ) ) by L1308 , L1307 , L1297;
L1420: ( ( union D216 ) . D214 ) = ( ( C373 . D213 ) . D214 ) by L1419 , L1309 , L1371 , L1413 , L1418 , L214;
thus L1421: ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) in ( dom R21 ) by L1420 , L1306 , L1309 , L1371 , L1413 , FUNCT_7:34;
end;
assume that
L1422: ( R24 +* (R1 , R5) ) in ( dom ( primrec (R20 , R21 , R1) ) )
and
L1423: ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) in ( dom R21 );
L1424: ( C373 . D213 ) in ( rng C373 ) by L1353 , FUNCT_1:def 3;
L1425: ( C373 . D213 ) in ( rng C373 ) by L1353 , FUNCT_1:def 3;
L1426: ( dom ( C373 . D213 ) ) in { ( dom B214 ) where B214 is (Element of D216) : (not contradiction) } by L1425;
L1427: ( dom ( C373 . D214 ) ) c= ( dom ( C373 . D213 ) ) by L1308 , L1307 , L1297;
L1428: D214 in ( dom ( C373 . D214 ) ) by L1309 , L1422;
L1429: D213 in ( union { ( dom B215 ) where B215 is (Element of D216) : (not contradiction) } ) by L1428 , L1306 , L1369 , L1371 , L1423 , L1426 , L1424 , L1427 , L214 , TARSKI:def 4;
thus L1430: thesis by L1429 , L1306 , L195;
end;

assume L1431: ( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) );
L1432: ( dom ( C373 . D214 ) ) c= ( dom ( C373 . D213 ) ) by L1308 , L1307 , L1297;
L1433: ( ( union D216 ) . D213 ) = ( ( C373 . D213 ) . D213 ) by L1432 , L1309 , L1431 , L1354 , L214;
L1434: ( ( union D216 ) . D214 ) = ( ( C373 . D213 ) . D214 ) by L1309 , L1371 , L1431 , L1354 , L1432 , L214;
thus L1435: thesis by L1434 , L1306 , L1309 , L1371 , L1431 , L1433 , FUNCT_7:34;
end;
theorem
L1436: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds (R1 in ( dom R24 ) implies (( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) iff ( Del (R24 , R1) ) in ( dom R20 ))))))) by L1305;
theorem
L1437: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ((R1 in ( dom R24 ) & ( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) )) implies ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (R24 , R1) ) )))))) by L1305;
theorem
L1438: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ((R1 in ( dom R24 ) & R20 is  len-total) implies ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (R24 , R1) ) ))))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ));
assume that
L1439: R1 in ( dom R24 )
and
L1440: R20 is  len-total;
L1441: ( Del (R24 , R1) ) is (FinSequence of ( NAT )) by FINSEQ_3:105;
L1442: ( len R24 ) = ( ( arity R20 ) + 1 ) by CARD_1:def 7;
L1443: ( len ( Del (R24 , R1) ) ) = ( arity R20 ) by L1442 , L1439 , FINSEQ_3:109;
L1444: ( Del (R24 , R1) ) is (Element of ( ( arity R20 ) -tuples_on ( NAT ) )) by L1443 , L1441 , FINSEQ_2:92;
L1445: ( dom R20 ) = ( ( arity R20 ) -tuples_on ( NAT ) ) by L1440 , L374;
L1446: ( R24 +* (R1 , ( 0 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) by L1445 , L1439 , L1444 , L1305;
thus L1447: thesis by L1446 , L1439 , L1305;
end;
theorem
L1448: (for R1 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds (R1 in ( dom R24 ) implies (( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) iff (( R24 +* (R1 , R5) ) in ( dom ( primrec (R20 , R21 , R1) ) ) & ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) in ( dom R21 ))))))))) by L1305;
theorem
L1449: (for R1 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ((R1 in ( dom R24 ) & ( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) )) implies ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( R5 + 1 )) ) ) = ( R21 . ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) ))))))) by L1305;
theorem
L1450: (for R1 being (Element of ( NAT )) holds (for R5 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) holds ((R20 is  len-total & R21 is  len-total & ( ( arity R20 ) + 2 ) = ( arity R21 ) & 1 <= R1 & R1 <= ( 1 + ( arity R20 ) )) implies ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , ( R5 + 1 )) ) ) = ( R21 . ( ( R24 +* (R1 , R5) ) ^ <* ( ( primrec (R20 , R21 , R1) ) . ( R24 +* (R1 , R5) ) ) *> ) )))))))
proof
let R1 being (Element of ( NAT ));
let R5 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R24 being (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) ));
assume that
L1451: R20 is  len-total
and
L1452: R21 is  len-total
and
L1453: ( ( arity R20 ) + 2 ) = ( arity R21 )
and
L1454: 1 <= R1
and
L1455: R1 <= ( 1 + ( arity R20 ) );
L1456: ( len R24 ) = ( ( arity R20 ) + 1 ) by CARD_1:def 7;
L1457: R1 in ( dom R24 ) by L1456 , L1454 , L1455 , FINSEQ_3:25;
L1458: ( R24 +* (R1 , ( R5 + 1 )) ) in ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) );
L1459: ( R24 +* (R1 , ( R5 + 1 )) ) in ( dom ( primrec (R20 , R21 , R1) ) ) by L1458 , L1451 , L1452 , L1453 , L1454 , L1455 , L1203;
thus L1460: thesis by L1459 , L1457 , L1305;
end;
theorem
L1461: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ((( ( arity R20 ) + 2 ) = ( arity R21 ) & 1 <= R1 & R1 <= ( ( arity R20 ) + 1 )) implies ( primrec (R20 , R21 , R1) ) is_primitive-recursively_expressed_by R20 , R21 , R1))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L1462: ( ( arity R20 ) + 2 ) = ( arity R21 )
and
L1463: 1 <= R1
and
L1464: R1 <= ( ( arity R20 ) + 1 );
take D217 = ( ( arity R20 ) + 1 );
set D218 = ( primrec (R20 , R21 , R1) );
thus L1465: ( dom D218 ) c= ( D217 -tuples_on ( NAT ) ) by L1184;
thus L1466: (R1 >= 1 & R1 <= D217) by L1463 , L1464;
thus L1467: ( ( arity R20 ) + 1 ) = D217;
thus L1468: ( D217 + 1 ) = ( arity R21 ) by L1462;
let C383 being (FinSequence of ( NAT ));
assume L1469: ( len C383 ) = D217;
L1470: R1 in ( dom C383 ) by L1469 , L1463 , L1464 , FINSEQ_3:25;
L1471: C383 is (Element of ( D217 -tuples_on ( NAT ) )) by L1469 , FINSEQ_2:92;
thus L1472: (( C383 +* (R1 , ( 0 )) ) in ( dom D218 ) iff ( Del (C383 , R1) ) in ( dom R20 )) by L1471 , L1470 , L1305;
thus L1473: (( C383 +* (R1 , ( 0 )) ) in ( dom D218 ) implies ( D218 . ( C383 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (C383 , R1) ) )) by L1471 , L1470 , L1305;
let C384 being (Element of ( NAT ));
thus L1474: (( C383 +* (R1 , ( C384 + 1 )) ) in ( dom D218 ) iff (( C383 +* (R1 , C384) ) in ( dom D218 ) & ( ( C383 +* (R1 , C384) ) ^ <* ( D218 . ( C383 +* (R1 , C384) ) ) *> ) in ( dom R21 ))) by L1471 , L1470 , L1305;
thus L1475: (( C383 +* (R1 , ( C384 + 1 )) ) in ( dom D218 ) implies ( D218 . ( C383 +* (R1 , ( C384 + 1 )) ) ) = ( R21 . ( ( C383 +* (R1 , C384) ) ^ <* ( D218 . ( C383 +* (R1 , C384) ) ) *> ) )) by L1471 , L1470 , L1305;
end;
theorem
L1476: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ((1 <= R1 & R1 <= ( ( arity R20 ) + 1 )) implies (for B216 being (Element of ( HFuncs ( NAT ) )) holds (B216 is_primitive-recursively_expressed_by R20 , R21 , R1 implies B216 = ( primrec (R20 , R21 , R1) )))))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L1477: R1 >= 1
and
L1478: R1 <= ( ( arity R20 ) + 1 );
let C385 being (Element of ( HFuncs ( NAT ) ));
set D219 = ( ( arity R20 ) + 1 );
set D220 = ( primrec (R20 , R21 , R1) );
given C386 being (Element of ( NAT )) such that
L1479: ( dom C385 ) c= ( C386 -tuples_on ( NAT ) )
and
L1480: R1 >= 1
and
L1481: R1 <= C386
and
L1482: ( ( arity R20 ) + 1 ) = C386
and
L1483: ( C386 + 1 ) = ( arity R21 )
and
L1484: (for B217 being (FinSequence of ( NAT )) holds (( len B217 ) = C386 implies ((( B217 +* (R1 , ( 0 )) ) in ( dom C385 ) iff ( Del (B217 , R1) ) in ( dom R20 )) & (( B217 +* (R1 , ( 0 )) ) in ( dom C385 ) implies ( C385 . ( B217 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (B217 , R1) ) )) & (for B218 being (Element of ( NAT )) holds ((( B217 +* (R1 , ( B218 + 1 )) ) in ( dom C385 ) iff (( B217 +* (R1 , B218) ) in ( dom C385 ) & ( ( B217 +* (R1 , B218) ) ^ <* ( C385 . ( B217 +* (R1 , B218) ) ) *> ) in ( dom R21 ))) & (( B217 +* (R1 , ( B218 + 1 )) ) in ( dom C385 ) implies ( C385 . ( B217 +* (R1 , ( B218 + 1 )) ) ) = ( R21 . ( ( B217 +* (R1 , B218) ) ^ <* ( C385 . ( B217 +* (R1 , B218) ) ) *> ) )))))));

L1485:
now
let C387 being (Element of ( D219 -tuples_on ( NAT ) ));
defpred S20[ (Element of ( NAT )) ] means ((( C387 +* (R1 , $1) ) in ( dom C385 ) iff ( C387 +* (R1 , $1) ) in ( dom D220 )) & (( C387 +* (R1 , $1) ) in ( dom C385 ) implies ( C385 . ( C387 +* (R1 , $1) ) ) = ( D220 . ( C387 +* (R1 , $1) ) )));
set D221 = ( C387 /. R1 );
L1486: C387 = ( C387 +* (R1 , D221) ) by FUNCT_7:38;
L1487: ( len C387 ) = D219 by CARD_1:def 7;
L1488: R1 in ( dom C387 ) by L1487 , L1477 , L1478 , FINSEQ_3:25;
L1489: (for B219 being (Element of ( NAT )) holds (S20[ B219 ] implies S20[ ( B219 + 1 ) ]))
proof
let R5 being (Element of ( NAT ));
assume that
L1490: (( C387 +* (R1 , R5) ) in ( dom C385 ) iff ( C387 +* (R1 , R5) ) in ( dom D220 ))
and
L1491: (( C387 +* (R1 , R5) ) in ( dom C385 ) implies ( C385 . ( C387 +* (R1 , R5) ) ) = ( D220 . ( C387 +* (R1 , R5) ) ));
L1492: (( C387 +* (R1 , ( R5 + 1 )) ) in ( dom C385 ) iff (( C387 +* (R1 , R5) ) in ( dom C385 ) & ( ( C387 +* (R1 , R5) ) ^ <* ( C385 . ( C387 +* (R1 , R5) ) ) *> ) in ( dom R21 ))) by L1482 , L1484 , L1487;
thus L1493: (( C387 +* (R1 , ( R5 + 1 )) ) in ( dom C385 ) iff ( C387 +* (R1 , ( R5 + 1 )) ) in ( dom D220 )) by L1492 , L1488 , L1490 , L1491 , L1305;
L1494: (( C387 +* (R1 , ( R5 + 1 )) ) in ( dom D220 ) iff (( C387 +* (R1 , R5) ) in ( dom D220 ) & ( ( C387 +* (R1 , R5) ) ^ <* ( D220 . ( C387 +* (R1 , R5) ) ) *> ) in ( dom R21 ))) by L1488 , L1305;
assume L1495: ( C387 +* (R1 , ( R5 + 1 )) ) in ( dom C385 );
L1496: ( C385 . ( C387 +* (R1 , ( R5 + 1 )) ) ) = ( R21 . ( ( C387 +* (R1 , R5) ) ^ <* ( C385 . ( C387 +* (R1 , R5) ) ) *> ) ) by L1495 , L1482 , L1484 , L1487;
thus L1497: thesis by L1496 , L1482 , L1484 , L1487 , L1488 , L1490 , L1491 , L1494 , L1495 , L1305;
end;
L1498: (( C387 +* (R1 , ( 0 )) ) in ( dom D220 ) iff ( Del (C387 , R1) ) in ( dom R20 )) by L1488 , L1305;
L1499: (( C387 +* (R1 , ( 0 )) ) in ( dom C385 ) implies (( C385 . ( C387 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (C387 , R1) ) ) & ( D220 . ( C387 +* (R1 , ( 0 )) ) ) = ( R20 . ( Del (C387 , R1) ) ))) by L1498 , L1482 , L1484 , L1487 , L1488 , L1305;
L1500: S20[ ( 0 ) ] by L1499 , L1482 , L1484 , L1487 , L1498;
L1501: (for R5 being (Element of ( NAT )) holds S20[ R5 ]) from NAT_1:sch 1(L1500 , L1489);
thus L1502: ((C387 in ( dom C385 ) iff C387 in ( dom D220 )) & (C387 in ( dom C385 ) implies ( C385 . C387 ) = ( D220 . C387 ))) by L1501 , L1486;
end;
L1503: ( dom D220 ) c= ( D219 -tuples_on ( NAT ) ) by L1184;
L1504: ( dom C385 ) = ( dom D220 ) by L1503 , L1479 , L1482 , L1485 , SUBSET_1:3;
L1505: (for B220 being set holds (B220 in ( dom D220 ) implies ( C385 . B220 ) = ( D220 . B220 ))) by L1503 , L1485;
thus L1506: thesis by L1505 , L1504 , FUNCT_1:2;
end;
begin
definition
let C388 being set;
attr C388 is  composition_closed
means
:L1507: (for B221 being (Element of ( HFuncs ( NAT ) )) holds (for B222 being  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) holds ((B221 in C388 & ( arity B221 ) = ( len B222 ) & ( rng B222 ) c= C388) implies ( B221 * <: B222 :> ) in C388)));
attr C388 is  primitive-recursion_closed
means
:L1508: (for B223 , B224 , B225 being (Element of ( HFuncs ( NAT ) )) holds (for B226 being (Element of ( NAT )) holds ((B223 is_primitive-recursively_expressed_by B224 , B225 , B226 & B224 in C388 & B225 in C388) implies B223 in C388)));
end;
definition
let C389 being set;
attr C389 is  primitive-recursively_closed
means
:L1510: (( ( 0 ) const ( 0 ) ) in C389 & ( 1 succ 1 ) in C389 & (for B227 , B228 being (Element of ( NAT )) holds ((1 <= B228 & B228 <= B227) implies ( B227 proj B228 ) in C389)) & C389 is  composition_closed & C389 is  primitive-recursion_closed);
end;
theorem
L1512: ( HFuncs ( NAT ) ) is  primitive-recursively_closed
proof
set D222 = ( HFuncs ( NAT ) );
thus L1513: (( ( 0 ) const ( 0 ) ) in D222 & ( 1 succ 1 ) in D222 & (for B229 , B230 being (Element of ( NAT )) holds ((1 <= B230 & B230 <= B229) implies ( B229 proj B230 ) in D222))) by L512 , L554 , L590;
thus L1514: (for B231 being (Element of ( HFuncs ( NAT ) )) holds (for B232 being  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) holds ((B231 in D222 & ( arity B231 ) = ( len B232 ) & ( rng B232 ) c= D222) implies ( B231 * <: B232 :> ) in D222))) by L706;
let C390 being (Element of ( HFuncs ( NAT ) ));
thus L1515: thesis;
end;
registration
cluster  primitive-recursively_closed non  empty for (Subset of ( HFuncs ( NAT ) ));
existence
proof
L1516: ( HFuncs ( NAT ) ) c= ( HFuncs ( NAT ) );
reconsider D223 = ( HFuncs ( NAT ) ) as non  empty (Subset of ( HFuncs ( NAT ) )) by L1516;
take D223;
thus L1517: thesis by L1512;
end;
end;
L1519: (for B233 being non  empty set holds (for B234 , B235 being (Element of ( NAT )) holds ((1 <= B235 & B235 <= B234) implies (for B236 being (Element of B233) holds (for B237 being (Element of ( B234 -tuples_on B233 )) holds ( B237 +* (B235 , B236) ) in ( B234 -tuples_on B233 ))))));
theorem
L1520: (for R1 being (Element of ( NAT )) holds (for R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for B238 being (Element of ( HFuncs ( NAT ) )) holds ((R22 = ( {} ) & B238 is_primitive-recursively_expressed_by R22 , R23 , R1) implies B238 = ( {} ))))))
proof
let R1 being (Element of ( NAT ));
let R22 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R23 being  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
set D224 = R22;
set D225 = R23;
let C391 being (Element of ( HFuncs ( NAT ) ));
assume L1521: D224 = ( {} );
assume L1522: C391 is_primitive-recursively_expressed_by D224 , D225 , R1;
consider C392 being (Element of ( NAT )) such that L1523: ( dom C391 ) c= ( C392 -tuples_on ( NAT ) ) and L1524: R1 >= 1 and L1525: R1 <= C392 and L1526: ( ( arity D224 ) + 1 ) = C392 and L1527: ( C392 + 1 ) = ( arity D225 ) and L1528: (for B239 being (FinSequence of ( NAT )) holds (( len B239 ) = C392 implies ((( B239 +* (R1 , ( 0 )) ) in ( dom C391 ) iff ( Del (B239 , R1) ) in ( dom D224 )) & (( B239 +* (R1 , ( 0 )) ) in ( dom C391 ) implies ( C391 . ( B239 +* (R1 , ( 0 )) ) ) = ( D224 . ( Del (B239 , R1) ) )) & (for B240 being (Element of ( NAT )) holds ((( B239 +* (R1 , ( B240 + 1 )) ) in ( dom C391 ) iff (( B239 +* (R1 , B240) ) in ( dom C391 ) & ( ( B239 +* (R1 , B240) ) ^ <* ( C391 . ( B239 +* (R1 , B240) ) ) *> ) in ( dom D225 ))) & (( B239 +* (R1 , ( B240 + 1 )) ) in ( dom C391 ) implies ( C391 . ( B239 +* (R1 , ( B240 + 1 )) ) ) = ( D225 . ( ( B239 +* (R1 , B240) ) ^ <* ( C391 . ( B239 +* (R1 , B240) ) ) *> ) ))))))) by L1522 , L850;
L1529:
now
let C393 being (Element of ( C392 -tuples_on ( NAT ) ));
defpred S21[ (Element of ( NAT )) ] means (not ( C393 +* (R1 , $1) ) in ( dom C391 ));
L1530: ( len C393 ) = C392 by CARD_1:def 7;
L1531: (for B241 being (Element of ( NAT )) holds (S21[ B241 ] implies S21[ ( B241 + 1 ) ])) by L1530 , L1528;
L1532: S21[ ( 0 ) ] by L1521 , L1528 , L1530;
thus L1533: (for B242 being (Element of ( NAT )) holds S21[ B242 ]) from NAT_1:sch 1(L1532 , L1531);
end;
assume L1534: C391 <> ( {} );
consider C394 being set such that L1535: C394 in ( dom C391 ) by L1534 , XBOOLE_0:def 1;
reconsider D226 = C394 as (Element of ( C392 -tuples_on ( NAT ) )) by L1523 , L1535;
set D227 = ( D226 . R1 );
L1536: D226 = ( D226 +* (R1 , D227) ) by FUNCT_7:35;
thus L1537: contradiction by L1536 , L1529 , L1535;
end;
theorem
L1538: (for B243 being (Element of ( HFuncs ( NAT ) )) holds (for B244 , B245 being  quasi_total (Element of ( HFuncs ( NAT ) )) holds (for B246 being (Element of ( NAT )) holds (B243 is_primitive-recursively_expressed_by B244 , B245 , B246 implies (B243 is  quasi_total & (B244 is non  empty implies B243 is non  empty))))))
proof
let C395 being (Element of ( HFuncs ( NAT ) ));
let C396 , C397 being  quasi_total (Element of ( HFuncs ( NAT ) ));
let C398 being (Element of ( NAT ));
assume L1539: C395 is_primitive-recursively_expressed_by C396 , C397 , C398;
consider C399 being (Element of ( NAT )) such that L1540: ( dom C395 ) c= ( C399 -tuples_on ( NAT ) ) and L1541: C398 >= 1 and L1542: C398 <= C399 and L1543: ( ( arity C396 ) + 1 ) = C399 and L1544: ( C399 + 1 ) = ( arity C397 ) and L1545: (for B247 being (FinSequence of ( NAT )) holds (( len B247 ) = C399 implies ((( B247 +* (C398 , ( 0 )) ) in ( dom C395 ) iff ( Del (B247 , C398) ) in ( dom C396 )) & (( B247 +* (C398 , ( 0 )) ) in ( dom C395 ) implies ( C395 . ( B247 +* (C398 , ( 0 )) ) ) = ( C396 . ( Del (B247 , C398) ) )) & (for B248 being (Element of ( NAT )) holds ((( B247 +* (C398 , ( B248 + 1 )) ) in ( dom C395 ) iff (( B247 +* (C398 , B248) ) in ( dom C395 ) & ( ( B247 +* (C398 , B248) ) ^ <* ( C395 . ( B247 +* (C398 , B248) ) ) *> ) in ( dom C397 ))) & (( B247 +* (C398 , ( B248 + 1 )) ) in ( dom C395 ) implies ( C395 . ( B247 +* (C398 , ( B248 + 1 )) ) ) = ( C397 . ( ( B247 +* (C398 , B248) ) ^ <* ( C395 . ( B247 +* (C398 , B248) ) ) *> ) ))))))) by L1539 , L850;
reconsider D228 = C397 as non  empty  quasi_total (Element of ( HFuncs ( NAT ) )) by L1544 , L323;
per cases ;
suppose L1546: C396 is  empty;

thus L1547: thesis by L1546 , L1539 , L1520;
end;
suppose L1548: C396 is non  empty;

L1549: ( dom C396 ) = ( ( arity C396 ) -tuples_on ( NAT ) ) by L1548 , L367;
L1550: C395 is  quasi_total
proof
let C400 , C401 being (FinSequence of ( NAT ));
assume that
L1551: ( len C400 ) = ( len C401 )
and
L1552: C400 in ( dom C395 );
defpred S22[ (Element of ( NAT )) ] means ( C401 +* (C398 , $1) ) in ( dom C395 );
L1553: ( len C400 ) = C399 by L1540 , L1552 , CARD_1:def 7;
L1554:
now
let C402 being (Element of ( NAT ));
assume that
L1555: S22[ C402 ];
L1556: ( dom D228 ) = ( ( arity C397 ) -tuples_on ( NAT ) ) by L367;
L1557: ( len ( ( C401 +* (C398 , C402) ) ^ <* ( C395 . ( C401 +* (C398 , C402) ) ) *> ) ) = ( ( len ( C401 +* (C398 , C402) ) ) + ( len <* ( C395 . ( C401 +* (C398 , C402) ) ) *> ) ) by FINSEQ_1:22
.= ( C399 + ( len <* ( C395 . ( C401 +* (C398 , C402) ) ) *> ) ) by L1551 , L1553 , FUNCT_7:97
.= ( C399 + 1 ) by FINSEQ_1:39;
L1558: ( ( C401 +* (C398 , C402) ) ^ <* ( C395 . ( C401 +* (C398 , C402) ) ) *> ) is (Element of ( dom C397 )) by L1557 , L1544 , L1556 , FINSEQ_2:92;
L1559: ( ( C401 +* (C398 , C402) ) ^ <* ( C395 . ( C401 +* (C398 , C402) ) ) *> ) in ( dom D228 ) by L1558;
thus L1560: S22[ ( C402 + 1 ) ] by L1559 , L1545 , L1551 , L1553 , L1555;
end;
L1561: C401 is (Element of ( ( len C401 ) -tuples_on ( NAT ) )) by FINSEQ_2:92;
L1562: ( Del (C401 , C398) ) in ( ( arity C396 ) -tuples_on ( NAT ) ) by L1561 , L1541 , L1542 , L1543 , L1551 , L1553 , L128;
L1563: S22[ ( 0 ) ] by L1562 , L1545 , L1549 , L1551 , L1553;
L1564: (for B249 being (Element of ( NAT )) holds S22[ B249 ]) from NAT_1:sch 1(L1563 , L1554);
L1565: ( C401 +* (C398 , ( C401 /. C398 )) ) in ( dom C395 ) by L1564;
L1566: C398 in ( dom C401 ) by L1541 , L1542 , L1551 , L1553 , FINSEQ_3:25;
L1567: ( C401 . C398 ) = ( C401 /. C398 ) by L1566 , PARTFUN1:def 6;
thus L1568: C401 in ( dom C395 ) by L1567 , L1565 , FUNCT_7:35;
end;
consider C403 being set such that L1569: C403 in ( C399 -tuples_on ( NAT ) ) by XBOOLE_0:def 1;
L1570: C403 is (Element of ( C399 -tuples_on ( NAT ) )) by L1569;
reconsider D229 = C403 as (FinSequence of ( NAT )) by L1570;
L1571: ( len D229 ) = C399 by L1569 , CARD_1:def 7;
L1572: ( Del (D229 , C398) ) in ( ( arity C396 ) -tuples_on ( NAT ) ) by L1541 , L1542 , L1543 , L1569 , L128;
thus L1573: thesis by L1572 , L1545 , L1571 , L1549 , L1550;
end;
end;
theorem
L1575: (for R4 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds (for R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) )) holds ( R6 const R4 ) in R25)))
proof
let R4 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
let R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) ));
defpred S23[ (Element of ( NAT )) ] means ( ( 0 ) const $1 ) in R25;
defpred S24[ (Element of ( NAT )) ] means (for B250 being (Element of ( NAT )) holds ( $1 const B250 ) in R25);
L1576: R25 is  composition_closed by L1510;
L1577: (for B251 being (Element of ( NAT )) holds (S23[ B251 ] implies S23[ ( B251 + 1 ) ]))
proof
reconsider D230 = ( 1 succ 1 ) as  quasi_total (Element of ( HFuncs ( NAT ) )) by L486;
let C404 being (Element of ( NAT ));
L1578: ( 1 succ 1 ) in R25 by L1510;
L1579: ( <*> ( NAT ) ) is (Element of ( ( 0 ) -tuples_on ( NAT ) )) by FINSEQ_2:131;
L1580: ( ( ( 0 ) const C404 ) . ( {} ) ) = C404 by L1579 , FUNCOP_1:7;
reconsider D231 = ( ( 0 ) const C404 ) as (Element of ( HFuncs ( NAT ) )) by L480;
set D232 = <* ( ( 0 ) const C404 ) *>;
L1581: <* D231 *> is (FinSequence of ( HFuncs ( NAT ) ));
reconsider D233 = D232 as  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) by L1581;
assume L1582: ( ( 0 ) const C404 ) in R25;
L1583: { ( ( 0 ) const C404 ) } c= R25 by L1582 , ZFMISC_1:31;
L1584: ( arity ( 1 succ 1 ) ) = 1 by L569
.= ( len D233 ) by FINSEQ_1:39;
L1585: ( rng D233 ) = { ( ( 0 ) const C404 ) } by FINSEQ_1:39;
L1586:
now
let C405 being (Element of ( HFuncs ( NAT ) ));
assume L1587: C405 in ( rng D233 );
L1588: C405 = ( ( 0 ) const C404 ) by L1587 , L1585 , TARSKI:def 1;
thus L1589: C405 is  quasi_total by L1588 , L486;
end;
reconsider D234 = ( D230 * <: D233 :> ) as  quasi_total (Element of ( HFuncs ( NAT ) )) by L1586 , L1584 , L812;
L1590: ( arity ( ( 0 ) const ( C404 + 1 ) ) ) = ( 0 ) by L527;
L1591: ( ( ( 0 ) const ( C404 + 1 ) ) . ( {} ) ) = ( C404 + 1 ) by L1579 , FUNCOP_1:7;
L1592: ( dom ( 1 succ 1 ) ) = ( 1 -tuples_on ( NAT ) ) by L533;
L1593: ( arity ( ( 0 ) const C404 ) ) = ( 0 ) by L527;
L1594: ( dom ( ( 0 ) const C404 ) ) = ( ( 0 ) -tuples_on ( NAT ) ) by L1593 , L374;
L1595: ( <: D233 :> . ( {} ) ) = <* C404 *> by L1594 , L1579 , L1580 , FINSEQ_3:141;
reconsider D235 = <* C404 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
L1596: ( dom <: <* ( ( 0 ) const C404 ) *> :> ) = ( dom ( ( 0 ) const C404 ) ) by FINSEQ_3:141;
L1597: ( D234 . ( {} ) ) = ( ( 1 succ 1 ) . ( <: D233 :> . ( {} ) ) ) by L1596 , L1579 , L1594 , FUNCT_1:13;
L1598: ( D234 . ( {} ) ) = ( ( D235 /. 1 ) + 1 ) by L1597 , L1595 , L533
.= ( C404 + 1 ) by FINSEQ_4:16;
L1599: ( dom ( ( 0 ) const C404 ) ) = ( ( 0 ) -tuples_on ( NAT ) ) by L1593 , L374;
L1600: ( <: <* ( ( 0 ) const C404 ) *> :> . ( {} ) ) = D235 by L1599 , L1579 , L1580 , FINSEQ_3:141;
L1601: ( {} ) in ( dom D234 ) by L1600 , L1579 , L1596 , L1599 , L1592 , FUNCT_1:11;
L1602: ( ( 0 ) const C404 ) in ( rng D233 ) by L1585 , TARSKI:def 1;
L1603: ( arity D233 ) = ( 0 ) by L1602 , L1593 , L414;
L1604: ( arity D234 ) = ( 0 ) by L1603 , L1601 , L732 , RELAT_1:38;
L1605: ( ( 0 ) const ( C404 + 1 ) ) = ( ( 1 succ 1 ) * <: <* ( ( 0 ) const C404 ) *> :> ) by L1604 , L1590 , L1591 , L1601 , L1598 , L843 , RELAT_1:38;
thus L1606: thesis by L1605 , L1576 , L1583 , L1585 , L1578 , L1584 , L1507;
end;
L1607: R25 is  primitive-recursion_closed by L1510;
L1608:
now
let C406 being (Element of ( NAT ));
assume that
L1609: S24[ C406 ];
thus L1610: S24[ ( C406 + 1 ) ]
proof
let C407 being (Element of ( NAT ));
set D236 = ( ( C406 + 1 ) const C407 );
set D237 = ( C406 const C407 );
set D238 = ( C406 + 1 );
set D239 = ( ( C406 + 2 ) proj ( C406 + 2 ) );
L1611: ( dom D236 ) = ( ( C406 + 1 ) -tuples_on ( NAT ) ) by FUNCOP_1:13;
L1612: ( C406 + ( 1 + 1 ) ) = ( D238 + 1 );
L1613: 1 <= ( C406 + 2 ) by L1612 , NAT_1:11;
L1614: D239 in R25 by L1613 , L1510;
L1615: ( arity D239 ) = ( C406 + 2 ) by L621;
L1616: ( dom D239 ) = ( ( C406 + 2 ) -tuples_on ( NAT ) ) by L596;
L1617: ( arity D237 ) = C406 by L527;
L1618: ( dom D237 ) = ( C406 -tuples_on ( NAT ) ) by FUNCOP_1:13;
L1619: ( arity D236 ) = D238 by L527;
L1620: D236 is_primitive-recursively_expressed_by D237 , D239 , ( C406 + 1 )
proof
take D240 = ( arity D236 );
thus L1621: ( dom D236 ) c= ( D240 -tuples_on ( NAT ) ) by L342;
thus L1622: (D238 >= 1 & D238 <= D240) by L527 , NAT_1:11;
thus L1623: (( ( arity D237 ) + 1 ) = D240 & ( D240 + 1 ) = ( arity D239 )) by L1617 , L1615 , L1612 , L527;
let C408 being (FinSequence of ( NAT ));
assume L1624: ( len C408 ) = D240;
L1625: C408 is (Element of ( D238 -tuples_on ( NAT ) )) by L1624 , L1619 , FINSEQ_2:92;
L1626: D238 >= 1 by NAT_1:11;
thus L1627: (( C408 +* (D238 , ( 0 )) ) in ( dom D236 ) implies ( Del (C408 , D238) ) in ( dom D237 )) by L1626 , L1618 , L1625 , L128;
thus L1628: (( Del (C408 , D238) ) in ( dom D237 ) implies ( C408 +* (D238 , ( 0 )) ) in ( dom D236 )) by L1611 , L1625 , L1626 , L1519;
L1629: ( D237 . ( Del (C408 , D238) ) ) = C407 by L1625 , L1626 , L128 , FUNCOP_1:7;
thus L1630: (( C408 +* (D238 , ( 0 )) ) in ( dom D236 ) implies ( D236 . ( C408 +* (D238 , ( 0 )) ) ) = ( D237 . ( Del (C408 , D238) ) )) by L1629 , L1625 , L1626 , L1519 , FUNCOP_1:7;
let C409 being (Element of ( NAT ));
L1631: ( C408 +* (D238 , C409) ) in ( D238 -tuples_on ( NAT ) ) by L1625 , L1626 , L1519;
L1632: ( ( C408 +* (D238 , C409) ) ^ <* C407 *> ) is (Tuple of ( C406 + 2 ) , ( NAT )) by L1631 , L1612 , FINSEQ_2:107;
L1633: ( ( C408 +* (D238 , C409) ) ^ <* C407 *> ) is (Element of ( ( C406 + 2 ) -tuples_on ( NAT ) )) by L1632 , FINSEQ_2:131;
thus L1634:now
thus L1635:now
assume L1636: ( C408 +* (D238 , ( C409 + 1 )) ) in ( dom D236 );
thus L1637: ( C408 +* (D238 , C409) ) in ( dom D236 ) by L1611 , L1625 , L1626 , L1519;
L1638: ( D236 . ( C408 +* (D238 , C409) ) ) = C407 by L1625 , L1626 , L1519 , FUNCOP_1:7;
thus L1639: ( ( C408 +* (D238 , C409) ) ^ <* ( D236 . ( C408 +* (D238 , C409) ) ) *> ) in ( dom D239 ) by L1638 , L1616 , L1632 , FINSEQ_2:131;
end;
thus L1640: ((( C408 +* (D238 , C409) ) in ( dom D236 ) & ( ( C408 +* (D238 , C409) ) ^ <* ( D236 . ( C408 +* (D238 , C409) ) ) *> ) in ( dom D239 )) implies ( C408 +* (D238 , ( C409 + 1 )) ) in ( dom D236 )) by L1611 , L1625 , L1626 , L1519;
end;
assume L1641: ( C408 +* (D238 , ( C409 + 1 )) ) in ( dom D236 );
L1642: ( len ( C408 +* (D238 , C409) ) ) = D238 by L1631 , CARD_1:def 7;
L1643: ( ( ( C408 +* (D238 , C409) ) ^ <* C407 *> ) . ( D238 + 1 ) ) = C407 by L1642 , FINSEQ_1:42;
thus L1644: ( D236 . ( C408 +* (D238 , ( C409 + 1 )) ) ) = C407 by L1625 , L1626 , L1519 , FUNCOP_1:7
.= ( D239 . ( ( C408 +* (D238 , C409) ) ^ <* C407 *> ) ) by L1643 , L1633 , L627
.= ( D239 . ( ( C408 +* (D238 , C409) ) ^ <* ( D236 . ( C408 +* (D238 , C409) ) ) *> ) ) by L1625 , L1626 , L1519 , FUNCOP_1:7;
end;
L1645: D237 in R25 by L1609;
L1646: ( ( C406 + 1 ) const C407 ) is (Element of ( HFuncs ( NAT ) )) by L480;
thus L1647: thesis by L1646 , L1607 , L1620 , L1645 , L1614 , L1508;
end;

end;
L1611: S23[ ( 0 ) ] by L1510;
L1612: (for B252 being (Element of ( NAT )) holds S23[ B252 ]) from NAT_1:sch 1(L1611 , L1577);
L1613: S24[ ( 0 ) ] by L1612;
L1614: (for R6 being (Element of ( NAT )) holds S24[ R6 ]) from NAT_1:sch 1(L1613 , L1608);
thus L1615: thesis by L1614;
end;
theorem
L1616: (for R1 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds (for R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) )) holds ((1 <= R1 & R1 <= R6) implies ( R6 succ R1 ) in R25))))
proof
let R1 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
let R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) ));
L1617: ( 1 succ 1 ) in R25 by L1510;
L1618: ( arity ( 1 succ 1 ) ) = 1 by L569
.= ( len <* ( R6 proj R1 ) *> ) by FINSEQ_1:39;
reconsider D241 = ( R6 proj R1 ) as (Element of ( HFuncs ( NAT ) )) by L480;
assume that
L1619: 1 <= R1
and
L1620: R1 <= R6;
L1621: <* D241 *> is  with_the_same_arity  with_the_same_arity  with_the_same_arity  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) ));
L1622:
now
L1623: ( rng ( R6 proj R1 ) ) = ( NAT ) by L1619 , L1620 , L596;
L1624: ( rng <: <* ( R6 proj R1 ) *> :> ) = ( 1 -tuples_on ( NAT ) ) by L1623 , L109;
thus L1625: ( dom ( R6 succ R1 ) ) = ( R6 -tuples_on ( NAT ) ) by L533;
L1626: ( dom ( R6 proj R1 ) ) = ( R6 -tuples_on ( NAT ) ) by L596;
L1627: ( dom <: <* ( R6 proj R1 ) *> :> ) = ( R6 -tuples_on ( NAT ) ) by L1626 , FINSEQ_3:141;
L1628: ( dom ( 1 succ 1 ) ) = ( 1 -tuples_on ( NAT ) ) by L533;
thus L1629: ( dom ( ( 1 succ 1 ) * <: <* ( R6 proj R1 ) *> :> ) ) = ( R6 -tuples_on ( NAT ) ) by L1628 , L1627 , L1624 , RELAT_1:27;
let C410 being set;
assume L1630: C410 in ( R6 -tuples_on ( NAT ) );
reconsider D242 = C410 as (Element of ( R6 -tuples_on ( NAT ) )) by L1630;
set D243 = ( D242 . R1 );
L1631: ( len D242 ) = R6 by CARD_1:def 7;
L1632: R1 in ( dom D242 ) by L1631 , L1619 , L1620 , FINSEQ_3:25;
L1633: ( ( R6 succ R1 ) . C410 ) = ( ( D242 /. R1 ) + 1 ) by L533
.= ( D243 + 1 ) by L1632 , PARTFUN1:def 6;
reconsider D244 = <* D243 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
L1634: ( ( ( 1 succ 1 ) * <: <* ( R6 proj R1 ) *> :> ) . D242 ) = ( ( 1 succ 1 ) . ( <: <* ( R6 proj R1 ) *> :> . D242 ) ) by L1627 , FUNCT_1:13
.= ( ( 1 succ 1 ) . <* ( ( R6 proj R1 ) . D242 ) *> ) by L1626 , FINSEQ_3:141
.= ( ( 1 succ 1 ) . <* ( D242 . R1 ) *> ) by L627
.= ( ( D244 /. 1 ) + 1 ) by L533
.= ( D243 + 1 ) by FINSEQ_4:16;
thus L1635: ( ( R6 succ R1 ) . C410 ) = ( ( ( 1 succ 1 ) * <: <* ( R6 proj R1 ) *> :> ) . C410 ) by L1634 , L1633;
end;
L1636: ( R6 succ R1 ) = ( ( 1 succ 1 ) * <: <* ( R6 proj R1 ) *> :> ) by L1622 , FUNCT_1:2;
L1637: ( rng <* ( R6 proj R1 ) *> ) c= R25
proof
let C411 being set;
assume L1638: C411 in ( rng <* ( R6 proj R1 ) *> );
L1639: C411 in { ( R6 proj R1 ) } by L1638 , FINSEQ_1:39;
L1640: C411 = ( R6 proj R1 ) by L1639 , TARSKI:def 1;
thus L1641: thesis by L1640 , L1619 , L1620 , L1510;
end;
L1642: R25 is  composition_closed by L1510;
thus L1643: thesis by L1642 , L1636 , L1617 , L1618 , L1637 , L1621 , L1507;
end;
theorem
L1644: (for R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) )) holds ( {} ) in R25)
proof
let R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) ));
reconsider D245 = ( {} ) as  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) by FINSEQ_1:49;
set D246 = ( ( 0 ) const ( 0 ) );
L1645: ( rng ( {} ) ) c= R25 by XBOOLE_1:2;
L1646: ( arity D246 ) = ( 0 ) by L527;
L1647: R25 is  composition_closed by L1510;
L1648: D246 in R25 by L1575;
L1649: ( D246 * <: D245 :> ) in R25 by L1648 , L1646 , L1645 , L1647 , L1507 , CARD_1:27;
thus L1650: thesis by L1649 , FUNCT_6:40;
end;
theorem
L1651: (for R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) )) holds (for B253 being (Element of R25) holds (for B254 being  with_the_same_arity (FinSequence of R25) holds (( arity B253 ) = ( len B254 ) implies ( B253 * <: B254 :> ) in R25))))
proof
let R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) ));
let C412 being (Element of R25);
let C413 being  with_the_same_arity (FinSequence of R25);
assume L1652: ( arity C412 ) = ( len C413 );
L1653: ( rng C413 ) c= R25 by FINSEQ_1:def 4;
per cases ;
suppose L1654: C412 is  empty;

L1655: ( C412 * <: C413 :> ) = ( {} ) by L1654;
thus L1656: thesis by L1655 , L1644;
end;
suppose L1657: C412 is non  empty;

reconsider D247 = C412 as non  empty (Element of ( HFuncs ( NAT ) )) by L1657;
L1658: ( R25 * ) c= ( ( HFuncs ( NAT ) ) * ) by FINSEQ_1:62;
L1659: C413 in ( R25 * ) by FINSEQ_1:def 11;
reconsider D248 = C413 as  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) by L1659 , L1658;
L1660: R25 is  composition_closed by L1510;
L1661: ( D247 * <: D248 :> ) in R25 by L1660 , L1652 , L1653 , L1507;
thus L1662: thesis by L1661;
end;
end;
theorem
L1664: (for R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) )) holds (for B255 , B256 being (Element of R25) holds (( ( arity B255 ) + 2 ) = ( arity B256 ) implies (for B257 being (Element of ( NAT )) holds ((1 <= B257 & B257 <= ( ( arity B255 ) + 1 )) implies ( primrec (B255 , B256 , B257) ) in R25)))))
proof
let R25 being  primitive-recursively_closed non  empty (Subset of ( HFuncs ( NAT ) ));
let C414 , C415 being (Element of R25);
assume L1665: ( ( arity C414 ) + 2 ) = ( arity C415 );
let C416 being (Element of ( NAT ));
assume that
L1666: 1 <= C416
and
L1667: C416 <= ( ( arity C414 ) + 1 );
L1668: R25 is  primitive-recursion_closed by L1510;
per cases ;
suppose L1669: C414 is  empty;

L1670: ( primrec (C414 , C415 , C416) ) is  empty by L1669 , L1165;
thus L1671: thesis by L1670 , L1644;
end;
suppose L1672: C414 is non  empty;

L1673: ( primrec (C414 , C415 , C416) ) is_primitive-recursively_expressed_by C414 , C415 , C416 by L1672 , L1665 , L1666 , L1667 , L323 , L1461;
thus L1674: thesis by L1673 , L1668 , L1508;
end;
end;
definition
func PrimRec -> (Subset of ( HFuncs ( NAT ) )) equals 
( meet { B258 where B258 is (Subset of ( HFuncs ( NAT ) )) : B258 is  primitive-recursively_closed } );
coherence
proof
set D249 = { B259 where B259 is (Subset of ( HFuncs ( NAT ) )) : B259 is  primitive-recursively_closed };
set D250 = ( meet D249 );
L1676: { ( HFuncs ( NAT ) ) } c= ( bool ( HFuncs ( NAT ) ) ) by ZFMISC_1:68;
L1677: ( HFuncs ( NAT ) ) in { ( HFuncs ( NAT ) ) } by TARSKI:def 1;
L1678: ( HFuncs ( NAT ) ) in D249 by L1677 , L1676 , L1512;
L1679: D250 c= ( HFuncs ( NAT ) )
proof
let C417 being set;
assume L1680: C417 in D250;
thus L1681: thesis by L1680 , L1678 , SETFAM_1:def 1;
end;
thus L1682: thesis by L1679;
end;
end;
theorem
L1684: (for B260 being (Subset of ( HFuncs ( NAT ) )) holds (B260 is  primitive-recursively_closed implies ( PrimRec ) c= B260))
proof
let C418 being (Subset of ( HFuncs ( NAT ) ));
set D251 = { B261 where B261 is (Subset of ( HFuncs ( NAT ) )) : B261 is  primitive-recursively_closed };
assume L1685: C418 is  primitive-recursively_closed;
L1686: C418 in D251 by L1685;
let C419 being set;
assume L1687: C419 in ( PrimRec );
thus L1688: thesis by L1687 , L1686 , SETFAM_1:def 1;
end;
registration
cluster ( PrimRec ) -> non  empty  primitive-recursively_closed;
coherence
proof
set D252 = { B262 where B262 is (Subset of ( HFuncs ( NAT ) )) : B262 is  primitive-recursively_closed };
L1689: { ( HFuncs ( NAT ) ) } c= ( bool ( HFuncs ( NAT ) ) ) by ZFMISC_1:68;
L1690: ( HFuncs ( NAT ) ) in { ( HFuncs ( NAT ) ) } by TARSKI:def 1;
L1691: ( HFuncs ( NAT ) ) in D252 by L1690 , L1689 , L1512;
L1692:
now
let C420 being set;
assume L1693: C420 in D252;
L1694: (ex B263 being (Subset of ( HFuncs ( NAT ) )) st (B263 = C420 & B263 is  primitive-recursively_closed)) by L1693;
thus L1695: ( ( 0 ) const ( 0 ) ) in C420 by L1694 , L1510;
end;
thus L1696: ( PrimRec ) is non  empty by L1692 , L1691 , SETFAM_1:def 1;
thus L1697: ( PrimRec ) is  primitive-recursively_closed
proof
thus L1698: ( ( 0 ) const ( 0 ) ) in ( PrimRec ) by L1691 , L1692 , SETFAM_1:def 1;
L1699:
now
let C421 being set;
assume L1700: C421 in D252;
L1701: (ex B264 being (Subset of ( HFuncs ( NAT ) )) st (B264 = C421 & B264 is  primitive-recursively_closed)) by L1700;
thus L1702: ( 1 succ 1 ) in C421 by L1701 , L1510;
end;
thus L1703: ( 1 succ 1 ) in ( PrimRec ) by L1699 , L1691 , SETFAM_1:def 1;
thus L1704:now
let C422 , C423 being (Element of ( NAT ));
assume that
L1705: 1 <= C423
and
L1706: C423 <= C422;
L1707:
now
let C424 being set;
assume L1708: C424 in D252;
L1709: (ex B265 being (Subset of ( HFuncs ( NAT ) )) st (B265 = C424 & B265 is  primitive-recursively_closed)) by L1708;
thus L1710: ( C422 proj C423 ) in C424 by L1709 , L1705 , L1706 , L1510;
end;
thus L1711: ( C422 proj C423 ) in ( PrimRec ) by L1707 , L1691 , SETFAM_1:def 1;
end;
thus L1712:now
let C425 being (Element of ( HFuncs ( NAT ) ));
let C426 being  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) ));
assume that
L1713: C425 in ( PrimRec )
and
L1714: ( arity C425 ) = ( len C426 )
and
L1715: ( rng C426 ) c= ( PrimRec );
L1716:
now
let C427 being set;
assume L1717: C427 in D252;
consider C428 being (Subset of ( HFuncs ( NAT ) )) such that L1718: C428 = C427 and L1719: C428 is  primitive-recursively_closed by L1717;
L1720: C428 is  composition_closed by L1719 , L1510;
L1721: ( PrimRec ) c= C428 by L1717 , L1718 , SETFAM_1:3;
L1722: ( rng C426 ) c= C428 by L1721 , L1715 , XBOOLE_1:1;
thus L1723: ( C425 * <: C426 :> ) in C427 by L1722 , L1713 , L1714 , L1718 , L1720 , L1721 , L1507;
end;
thus L1724: ( C425 * <: C426 :> ) in ( PrimRec ) by L1716 , L1691 , SETFAM_1:def 1;
end;
thus L1725:now
let C429 , C430 , C431 being (Element of ( HFuncs ( NAT ) ));
let C432 being (Element of ( NAT ));
assume that
L1726: C429 is_primitive-recursively_expressed_by C430 , C431 , C432
and
L1727: C430 in ( PrimRec )
and
L1728: C431 in ( PrimRec );
L1729:
now
let C433 being set;
assume L1730: C433 in D252;
consider C434 being (Subset of ( HFuncs ( NAT ) )) such that L1731: C434 = C433 and L1732: C434 is  primitive-recursively_closed by L1730;
L1733: C431 in C434 by L1728 , L1730 , L1731 , SETFAM_1:def 1;
L1734: C434 is  primitive-recursion_closed by L1732 , L1510;
L1735: C430 in C434 by L1727 , L1730 , L1731 , SETFAM_1:def 1;
thus L1736: C429 in C433 by L1735 , L1726 , L1731 , L1734 , L1733 , L1508;
end;
thus L1737: C429 in ( PrimRec ) by L1729 , L1691 , SETFAM_1:def 1;
end;
end;

end;
end;
registration
cluster  ->  homogeneous for (Element of ( PrimRec ));
coherence;
end;
definition
let C435 being set;
attr C435 is  primitive-recursive
means
:L1700: C435 in ( PrimRec );
end;
registration
cluster  primitive-recursive ->  Relation-like  Function-like for set;
coherence
proof
let C436 being set;
assume L1702: C436 in ( PrimRec );
thus L1703: thesis by L1702;
end;
end;
registration
cluster  primitive-recursive ->  homogeneous  to-naturals ( ( NAT ) * ) -defined for Relation;
coherence
proof
let C437 being Relation;
assume L1705: C437 in ( PrimRec );
thus L1706: thesis by L1705;
end;
end;
registration
cluster  ->  primitive-recursive for (Element of ( PrimRec ));
coherence by L1700;
end;
registration
cluster  primitive-recursive for Function;
existence
proof
set D253 = the (Element of ( PrimRec ));
take D253;
thus L1709: thesis;
end;
cluster  primitive-recursive for (Element of ( HFuncs ( NAT ) ));
existence
proof
set D254 = the (Element of ( PrimRec ));
take D254;
thus L1710: thesis;
end;
end;
definition
func initial-funcs -> (Subset of ( HFuncs ( NAT ) )) equals 
( { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } \/ { ( B266 proj B267 ) where B266 , B267 is (Element of ( NAT )) : (1 <= B267 & B267 <= B266) } );
coherence
proof
set D255 = { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) };
set D256 = { ( B268 proj B269 ) where B268 , B269 is (Element of ( NAT )) : (1 <= B269 & B269 <= B268) };
L1712: D256 c= ( HFuncs ( NAT ) )
proof
let C438 being set;
assume L1713: C438 in D256;
L1714: (ex B270 , B271 being (Element of ( NAT )) st (C438 = ( B270 proj B271 ) & 1 <= B271 & B271 <= B270)) by L1713;
thus L1715: thesis by L1714 , L590;
end;
L1716: D255 c= ( HFuncs ( NAT ) )
proof
let C439 being set;
assume L1717: C439 in D255;
L1718: (C439 = ( ( 0 ) const ( 0 ) ) or C439 = ( 1 succ 1 )) by L1717 , TARSKI:def 2;
thus L1719: thesis by L1718 , L512 , L554;
end;
thus L1720: thesis by L1716 , L1712 , XBOOLE_1:8;
end;
let C440 being (Subset of ( HFuncs ( NAT ) ));
func PR-closure C440 -> (Subset of ( HFuncs ( NAT ) )) equals 
( C440 \/ { B272 where B272 is (Element of ( HFuncs ( NAT ) )) : (ex B273 , B274 being (Element of ( HFuncs ( NAT ) )) st (ex B275 being (Element of ( NAT )) st (B273 in C440 & B274 in C440 & B272 is_primitive-recursively_expressed_by B273 , B274 , B275))) } );
coherence
proof
set D257 = { B276 where B276 is (Element of ( HFuncs ( NAT ) )) : (ex B277 , B278 being (Element of ( HFuncs ( NAT ) )) st (ex B279 being (Element of ( NAT )) st (B277 in C440 & B278 in C440 & B276 is_primitive-recursively_expressed_by B277 , B278 , B279))) };
L1721: D257 c= ( HFuncs ( NAT ) )
proof
let C441 being set;
assume L1722: C441 in D257;
L1723: (ex B280 being (Element of ( HFuncs ( NAT ) )) st (C441 = B280 & (ex B281 , B282 being (Element of ( HFuncs ( NAT ) )) st (ex B283 being (Element of ( NAT )) st (B281 in C440 & B282 in C440 & B280 is_primitive-recursively_expressed_by B281 , B282 , B283))))) by L1722;
thus L1724: thesis by L1723;
end;
thus L1725: thesis by L1721 , XBOOLE_1:8;
end;
func composition-closure C440 -> (Subset of ( HFuncs ( NAT ) )) equals 
( C440 \/ { ( B284 * <: B285 :> ) where B284 is (Element of ( HFuncs ( NAT ) )) , B285 is  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) : (B284 in C440 & ( arity B284 ) = ( len B285 ) & ( rng B285 ) c= C440) } );
coherence
proof
set D258 = { ( B286 * <: B287 :> ) where B286 is (Element of ( HFuncs ( NAT ) )) , B287 is  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) : (B286 in C440 & ( arity B286 ) = ( len B287 ) & ( rng B287 ) c= C440) };
L1726: D258 c= ( HFuncs ( NAT ) )
proof
let C442 being set;
assume L1727: C442 in D258;
L1728: (ex B288 being (Element of ( HFuncs ( NAT ) )) st (ex B289 being  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) st (C442 = ( B288 * <: B289 :> ) & B288 in C440 & ( arity B288 ) = ( len B289 ) & ( rng B289 ) c= C440))) by L1727;
thus L1729: thesis by L1728 , L706;
end;
thus L1730: thesis by L1726 , XBOOLE_1:8;
end;
end;
definition
func PrimRec-Approximation -> (Function of ( NAT ) , ( bool ( HFuncs ( NAT ) ) )) means 
:L1732: (( it . ( 0 ) ) = ( initial-funcs ) & (for B290 being Nat holds ( it . ( B290 + 1 ) ) = ( ( PR-closure ( it . B290 ) ) \/ ( composition-closure ( it . B290 ) ) )));
existence
proof
deffunc H3(set , (Subset of ( HFuncs ( NAT ) ))) = ( ( PR-closure $2 ) \/ ( composition-closure $2 ) );
consider C443 being (Function of ( NAT ) , ( bool ( HFuncs ( NAT ) ) )) such that L1733: ( C443 . ( 0 ) ) = ( initial-funcs ) and L1734: (for B291 being Nat holds ( C443 . ( B291 + 1 ) ) = H3(B291 , ( C443 . B291 ))) from NAT_1:sch 12;
take C443;
thus L1735: ( C443 . ( 0 ) ) = ( initial-funcs ) by L1733;
let C444 being Nat;
thus L1736: thesis by L1734;
end;
uniqueness
proof
deffunc H4(set , (Subset of ( HFuncs ( NAT ) ))) = ( ( PR-closure $2 ) \/ ( composition-closure $2 ) );
let C445 , C446 being (Function of ( NAT ) , ( bool ( HFuncs ( NAT ) ) ));
assume that
L1737: ( C445 . ( 0 ) ) = ( initial-funcs )
and
L1738: (for B292 being Nat holds ( C445 . ( B292 + 1 ) ) = ( ( PR-closure ( C445 . B292 ) ) \/ ( composition-closure ( C445 . B292 ) ) ))
and
L1739: ( C446 . ( 0 ) ) = ( initial-funcs )
and
L1740: (for B293 being Nat holds ( C446 . ( B293 + 1 ) ) = ( ( PR-closure ( C446 . B293 ) ) \/ ( composition-closure ( C446 . B293 ) ) ));
L1741: (for B294 being Nat holds ( C445 . ( B294 + 1 ) ) = H4(B294 , ( C445 . B294 ))) by L1738;
L1742: (for B295 being Nat holds ( C446 . ( B295 + 1 ) ) = H4(B295 , ( C446 . B295 ))) by L1740;
L1743: ( C446 . ( 0 ) ) = ( initial-funcs ) by L1739;
L1744: ( C445 . ( 0 ) ) = ( initial-funcs ) by L1737;
thus L1745: C445 = C446 from NAT_1:sch 16(L1744 , L1741 , L1743 , L1742);
end;
end;
theorem
L1747: (for R5 being (Element of ( NAT )) holds (for R6 being (Element of ( NAT )) holds (R5 <= R6 implies ( ( PrimRec-Approximation ) . R5 ) c= ( ( PrimRec-Approximation ) . R6 ))))
proof
let R5 being (Element of ( NAT ));
let R6 being (Element of ( NAT ));
set D259 = ( PrimRec-Approximation );
defpred S25[ (Element of ( NAT )) ] means (R5 <= $1 implies ( D259 . R5 ) c= ( D259 . $1 ));
L1748: (for B296 being (Element of ( NAT )) holds (S25[ B296 ] implies S25[ ( B296 + 1 ) ]))
proof
let C447 being (Element of ( NAT ));
assume that
L1749: S25[ C447 ]
and
L1750: R5 <= ( C447 + 1 );
L1751: ( D259 . ( C447 + 1 ) ) = ( ( PR-closure ( D259 . C447 ) ) \/ ( composition-closure ( D259 . C447 ) ) ) by L1732;
L1752: ( PR-closure ( D259 . C447 ) ) c= ( D259 . ( C447 + 1 ) ) by L1751 , XBOOLE_1:7;
L1753: ( D259 . C447 ) c= ( PR-closure ( D259 . C447 ) ) by XBOOLE_1:7;
L1754: ( D259 . C447 ) c= ( D259 . ( C447 + 1 ) ) by L1753 , L1752 , XBOOLE_1:1;
per cases  by L1750 , XXREAL_0:1;
suppose L1755: R5 < ( C447 + 1 );

thus L1756: thesis by L1755 , L1749 , L1754 , NAT_1:13 , XBOOLE_1:1;
end;
suppose L1757: R5 = ( C447 + 1 );

thus L1758: thesis by L1757;
end;
end;
L1760: S25[ ( 0 ) ];
L1761: (for B297 being (Element of ( NAT )) holds S25[ B297 ]) from NAT_1:sch 1(L1760 , L1748);
thus L1762: thesis by L1761;
end;
theorem
L1763: ( Union ( PrimRec-Approximation ) ) is  primitive-recursively_closed
proof
set D260 = { ( B298 proj B299 ) where B298 , B299 is (Element of ( NAT )) : (1 <= B299 & B299 <= B298) };
set D261 = ( PrimRec-Approximation );
set D262 = ( Union D261 );
L1764: ( dom D261 ) = ( NAT ) by FUNCT_2:def 1;
L1765: ( D261 . ( 0 ) ) = ( { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } \/ D260 ) by L1732;
L1766: ( ( 0 ) const ( 0 ) ) in { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } by TARSKI:def 2;
L1767: ( ( 0 ) const ( 0 ) ) in ( D261 . ( 0 ) ) by L1766 , L1765 , XBOOLE_0:def 3;
thus L1768: ( ( 0 ) const ( 0 ) ) in D262 by L1767 , L1764 , CARD_5:2;
L1769: ( 1 succ 1 ) in { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } by TARSKI:def 2;
L1770: ( 1 succ 1 ) in ( D261 . ( 0 ) ) by L1769 , L1765 , XBOOLE_0:def 3;
thus L1771: ( 1 succ 1 ) in D262 by L1770 , L1764 , CARD_5:2;
thus L1772:now
let C448 , C449 being (Element of ( NAT ));
assume that
L1773: 1 <= C449
and
L1774: C449 <= C448;
L1775: ( C448 proj C449 ) in D260 by L1773 , L1774;
L1776: ( C448 proj C449 ) in ( D261 . ( 0 ) ) by L1775 , L1765 , XBOOLE_0:def 3;
thus L1777: ( C448 proj C449 ) in D262 by L1776 , L1764 , CARD_5:2;
end;
thus L1778:now
deffunc H5((Element of ( NAT ))) = { ( B300 * <: B301 :> ) where B300 is (Element of ( HFuncs ( NAT ) )) , B301 is  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) : (B300 in ( D261 . $1 ) & ( arity B300 ) = ( len B301 ) & ( rng B301 ) c= ( D261 . $1 )) };
let C450 being (Element of ( HFuncs ( NAT ) ));
let C451 being  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) ));
assume that
L1779: C450 in D262
and
L1780: ( arity C450 ) = ( len C451 )
and
L1781: ( rng C451 ) c= D262;
consider C452 being set such that L1782: C452 in ( dom D261 ) and L1783: C450 in ( D261 . C452 ) by L1779 , CARD_5:2;
reconsider D263 = C452 as (Element of ( NAT )) by L1782;
per cases ;
suppose L1784: ( arity C450 ) = ( 0 );

L1785: C451 = ( {} ) by L1784 , L1780;
L1786: ( rng C451 ) c= ( D261 . D263 ) by L1785 , RELAT_1:38 , XBOOLE_1:2;
L1787: C451 is  with_the_same_arity  with_the_same_arity  with_the_same_arity  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) by FINSEQ_1:def 11;
L1788: ( C450 * <: C451 :> ) in H5(D263) by L1787 , L1780 , L1783 , L1786;
L1789: ( C450 * <: C451 :> ) in ( ( D261 . D263 ) \/ H5(D263) ) by L1788 , XBOOLE_0:def 3;
L1790: ( C450 * <: C451 :> ) in ( ( PR-closure ( D261 . D263 ) ) \/ ( composition-closure ( D261 . D263 ) ) ) by L1789 , XBOOLE_0:def 3;
L1791: ( C450 * <: C451 :> ) in ( D261 . ( D263 + 1 ) ) by L1790 , L1732;
thus L1792: ( C450 * <: C451 :> ) in D262 by L1791 , L1764 , CARD_5:2;
end;
suppose L1793: ( arity C450 ) <> ( 0 );

defpred S26[ set , set ] means (ex B302 being (Element of ( NAT )) st (( C451 . $1 ) in ( D261 . B302 ) & $2 = B302));
L1794: (for R8 being set holds (R8 in ( Seg ( len C451 ) ) implies (ex B303 being (Element of ( NAT )) st S26[ R8 , B303 ])))
proof
let C453 being set;
assume L1795: C453 in ( Seg ( len C451 ) );
L1796: C453 in ( dom C451 ) by L1795 , FINSEQ_1:def 3;
L1797: ( C451 . C453 ) in ( rng C451 ) by L1796 , FUNCT_1:def 3;
consider C454 being set such that L1798: C454 in ( dom D261 ) and L1799: ( C451 . C453 ) in ( D261 . C454 ) by L1797 , L1781 , CARD_5:2;
reconsider D264 = C454 as (Element of ( NAT )) by L1798;
take D264;
take D265 = D264;
thus L1800: ( C451 . C453 ) in ( D261 . D265 ) by L1799;
thus L1801: thesis;
end;
consider C455 being (Function of ( Seg ( len C451 ) ) , ( NAT )) such that L1802: (for B304 being set holds (B304 in ( Seg ( len C451 ) ) implies S26[ B304 , ( C455 . B304 ) ])) from MONOID_1:sch 1(L1794);
set D266 = ( rng C455 );
reconsider D267 = D266 as non  empty  finite (Subset of ( NAT )) by L1780 , L1793 , RELAT_1:def 19;
set D268 = ( max D267 );
set D269 = ( max (D263 , D268) );
reconsider D270 = D269 as (Element of ( NAT )) by ORDINAL1:def 12;
L1803: ( dom C455 ) = ( Seg ( len C451 ) ) by FUNCT_2:def 1;
L1804: ( rng C451 ) c= ( D261 . D270 )
proof
let C456 being set;
L1805: D268 <= D270 by XXREAL_0:25;
assume L1806: C456 in ( rng C451 );
consider C457 being set such that L1807: C457 in ( dom C451 ) and L1808: C456 = ( C451 . C457 ) by L1806 , FUNCT_1:def 3;
L1809: C457 in ( Seg ( len C451 ) ) by L1807 , FINSEQ_1:def 3;
consider C458 being (Element of ( NAT )) such that L1810: ( C451 . C457 ) in ( D261 . C458 ) and L1811: ( C455 . C457 ) = C458 by L1809 , L1802;
L1812: C458 in D267 by L1803 , L1809 , L1811 , FUNCT_1:3;
L1813: C458 <= D268 by L1812 , XXREAL_2:def 8;
L1814: ( D261 . C458 ) c= ( D261 . D270 ) by L1813 , L1805 , L1747 , XXREAL_0:2;
thus L1815: thesis by L1814 , L1808 , L1810;
end;
L1816: C451 is  with_the_same_arity  with_the_same_arity  with_the_same_arity  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) by FINSEQ_1:def 11;
L1817: ( D261 . D263 ) c= ( D261 . D270 ) by L1747 , XXREAL_0:25;
L1818: ( C450 * <: C451 :> ) in H5(D270) by L1817 , L1780 , L1783 , L1804 , L1816;
L1819: ( C450 * <: C451 :> ) in ( ( D261 . D270 ) \/ H5(D270) ) by L1818 , XBOOLE_0:def 3;
L1820: ( C450 * <: C451 :> ) in ( ( PR-closure ( D261 . D270 ) ) \/ ( composition-closure ( D261 . D270 ) ) ) by L1819 , XBOOLE_0:def 3;
L1821: ( C450 * <: C451 :> ) in ( D261 . ( D270 + 1 ) ) by L1820 , L1732;
thus L1822: ( C450 * <: C451 :> ) in D262 by L1821 , L1764 , CARD_5:2;
end;
end;
deffunc H6((Element of ( NAT ))) = { B305 where B305 is (Element of ( HFuncs ( NAT ) )) : (ex B306 , B307 being (Element of ( HFuncs ( NAT ) )) st (ex B308 being (Element of ( NAT )) st (B306 in ( D261 . $1 ) & B307 in ( D261 . $1 ) & B305 is_primitive-recursively_expressed_by B306 , B307 , B308))) };
let C459 , C460 , C461 being (Element of ( HFuncs ( NAT ) ));
let C462 being (Element of ( NAT ));
assume that
L1824: C459 is_primitive-recursively_expressed_by C460 , C461 , C462
and
L1825: C460 in D262
and
L1826: C461 in D262;
consider C463 being set such that L1827: C463 in ( dom D261 ) and L1828: C461 in ( D261 . C463 ) by L1826 , CARD_5:2;
reconsider D271 = C463 as (Element of ( NAT )) by L1827;
consider C464 being set such that L1829: C464 in ( dom D261 ) and L1830: C460 in ( D261 . C464 ) by L1825 , CARD_5:2;
reconsider D272 = C464 as (Element of ( NAT )) by L1829;
per cases ;
suppose L1831: D272 <= D271;

L1832: ( D261 . D272 ) c= ( D261 . D271 ) by L1831 , L1747;
L1833: C459 in H6(D271) by L1832 , L1824 , L1830 , L1828;
L1834: C459 in ( ( D261 . D271 ) \/ H6(D271) ) by L1833 , XBOOLE_0:def 3;
L1835: C459 in ( ( PR-closure ( D261 . D271 ) ) \/ ( composition-closure ( D261 . D271 ) ) ) by L1834 , XBOOLE_0:def 3;
L1836: C459 in ( D261 . ( D271 + 1 ) ) by L1835 , L1732;
thus L1837: thesis by L1836 , L1764 , CARD_5:2;
end;
suppose L1838: D271 <= D272;

L1839: ( D261 . D271 ) c= ( D261 . D272 ) by L1838 , L1747;
L1840: C459 in H6(D272) by L1839 , L1824 , L1830 , L1828;
L1841: C459 in ( ( D261 . D272 ) \/ H6(D272) ) by L1840 , XBOOLE_0:def 3;
L1842: C459 in ( ( PR-closure ( D261 . D272 ) ) \/ ( composition-closure ( D261 . D272 ) ) ) by L1841 , XBOOLE_0:def 3;
L1843: C459 in ( D261 . ( D272 + 1 ) ) by L1842 , L1732;
thus L1844: thesis by L1843 , L1764 , CARD_5:2;
end;
end;
theorem
L1846: ( PrimRec ) = ( Union ( PrimRec-Approximation ) )
proof
set D273 = ( PrimRec-Approximation );
defpred S27[ (Element of ( NAT )) ] means ( D273 . $1 ) c= ( PrimRec );
L1847:
now
let C465 being (Element of ( NAT ));
assume that
L1848: S27[ C465 ];
thus L1849: S27[ ( C465 + 1 ) ]
proof
set D274 = { ( B309 * <: B310 :> ) where B309 is (Element of ( HFuncs ( NAT ) )) , B310 is  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) : (B309 in ( D273 . C465 ) & ( arity B309 ) = ( len B310 ) & ( rng B310 ) c= ( D273 . C465 )) };
set D275 = { B311 where B311 is (Element of ( HFuncs ( NAT ) )) : (ex B312 , B313 being (Element of ( HFuncs ( NAT ) )) st (ex B314 being (Element of ( NAT )) st (B312 in ( D273 . C465 ) & B313 in ( D273 . C465 ) & B311 is_primitive-recursively_expressed_by B312 , B313 , B314))) };
let C466 being set;
L1850: ( D273 . ( C465 + 1 ) ) = ( ( PR-closure ( D273 . C465 ) ) \/ ( composition-closure ( D273 . C465 ) ) ) by L1732;
assume L1851: C466 in ( D273 . ( C465 + 1 ) );
per cases  by L1851 , L1850 , XBOOLE_0:def 3;
suppose L1852: C466 in ( PR-closure ( D273 . C465 ) );

thus L1853: thesis
proof
per cases  by L1852 , XBOOLE_0:def 3;
suppose L1854: C466 in ( D273 . C465 );

thus L1855: thesis by L1854 , L1848;
end;
suppose L1856: C466 in D275;

L1857: ( PrimRec ) is  primitive-recursion_closed by L1510;
L1858: (ex B315 being (Element of ( HFuncs ( NAT ) )) st (C466 = B315 & (ex B316 , B317 being (Element of ( HFuncs ( NAT ) )) st (ex B318 being (Element of ( NAT )) st (B316 in ( D273 . C465 ) & B317 in ( D273 . C465 ) & B315 is_primitive-recursively_expressed_by B316 , B317 , B318))))) by L1856;
thus L1859: thesis by L1858 , L1848 , L1857 , L1508;
end;
end;

end;
suppose L1854: C466 in ( composition-closure ( D273 . C465 ) );

thus L1855: thesis
proof
per cases  by L1854 , XBOOLE_0:def 3;
suppose L1856: C466 in ( D273 . C465 );

thus L1857: thesis by L1856 , L1848;
end;
suppose L1858: C466 in D274;

L1859: ( PrimRec ) is  composition_closed by L1510;
consider C467 being (Element of ( HFuncs ( NAT ) )), C468 being  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) such that L1860: C466 = ( C467 * <: C468 :> ) and L1861: C467 in ( D273 . C465 ) and L1862: ( arity C467 ) = ( len C468 ) and L1863: ( rng C468 ) c= ( D273 . C465 ) by L1858;
L1864: ( rng C468 ) c= ( PrimRec ) by L1848 , L1863 , XBOOLE_1:1;
thus L1865: thesis by L1864 , L1848 , L1860 , L1861 , L1862 , L1859 , L1507;
end;
end;

end;
end;

end;
L1850: S27[ ( 0 ) ]
proof
let C469 being set;
assume L1851: C469 in ( D273 . ( 0 ) );
L1852: ( D273 . ( 0 ) ) = ( { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } \/ { ( B319 proj B320 ) where B319 , B320 is (Element of ( NAT )) : (1 <= B320 & B320 <= B319) } ) by L1732;
L1853: (C469 in { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } or C469 in { ( B321 proj B322 ) where B321 , B322 is (Element of ( NAT )) : (1 <= B322 & B322 <= B321) }) by L1852 , L1851 , XBOOLE_0:def 3;
per cases  by L1853 , TARSKI:def 2;
suppose L1854: C469 = ( ( 0 ) const ( 0 ) );

thus L1855: thesis by L1854 , L1510;
end;
suppose L1856: C469 = ( 1 succ 1 );

thus L1857: thesis by L1856 , L1510;
end;
suppose L1858: C469 in { ( B323 proj B324 ) where B323 , B324 is (Element of ( NAT )) : (1 <= B324 & B324 <= B323) };

L1859: (ex B325 , B326 being (Element of ( NAT )) st (C469 = ( B325 proj B326 ) & 1 <= B326 & B326 <= B325)) by L1858;
thus L1860: thesis by L1859 , L1510;
end;
end;
L1862: (for B327 being (Element of ( NAT )) holds S27[ B327 ]) from NAT_1:sch 1(L1850 , L1847);
L1863: ( Union D273 ) c= ( PrimRec )
proof
let C470 being set;
assume that
L1864: C470 in ( Union D273 )
and
L1865: (not C470 in ( PrimRec ));
consider C471 being set such that L1866: C470 in C471 and L1867: C471 in ( rng D273 ) by L1864 , TARSKI:def 4;
consider C472 being set such that L1868: C472 in ( dom D273 ) and L1869: ( D273 . C472 ) = C471 by L1867 , FUNCT_1:def 3;
reconsider D276 = C472 as (Element of ( NAT )) by L1868;
L1870: ( D273 . D276 ) c= ( PrimRec ) by L1862;
thus L1871: contradiction by L1870 , L1865 , L1866 , L1869;
end;
L1872: ( PrimRec ) c= ( Union D273 ) by L1684 , L1763;
thus L1873: thesis by L1872 , L1863 , XBOOLE_0:def 10;
end;
theorem
L1874: (for R5 being (Element of ( NAT )) holds (for B328 being (Element of ( HFuncs ( NAT ) )) holds (B328 in ( ( PrimRec-Approximation ) . R5 ) implies B328 is  quasi_total)))
proof
let R5 being (Element of ( NAT ));
defpred S28[ (Element of ( NAT )) ] means (for B329 being (Element of ( HFuncs ( NAT ) )) holds (B329 in ( ( PrimRec-Approximation ) . $1 ) implies B329 is  quasi_total));
set D277 = ( PrimRec-Approximation );
L1875: (for B330 being (Element of ( NAT )) holds (S28[ B330 ] implies S28[ ( B330 + 1 ) ]))
proof
let C473 being (Element of ( NAT ));
assume L1876: S28[ C473 ];
let C474 being (Element of ( HFuncs ( NAT ) ));
assume L1877: C474 in ( D277 . ( C473 + 1 ) );
L1878: C474 in ( ( PR-closure ( D277 . C473 ) ) \/ ( composition-closure ( D277 . C473 ) ) ) by L1877 , L1732;
per cases  by L1878 , XBOOLE_0:def 3;
suppose L1879: C474 in ( PR-closure ( D277 . C473 ) );

thus L1880: C474 is  quasi_total
proof
per cases  by L1879 , XBOOLE_0:def 3;
suppose L1881: C474 in ( D277 . C473 );

thus L1882: thesis by L1881 , L1876;
end;
suppose L1883: C474 in { B331 where B331 is (Element of ( HFuncs ( NAT ) )) : (ex B332 , B333 being (Element of ( HFuncs ( NAT ) )) st (ex B334 being (Element of ( NAT )) st (B332 in ( D277 . C473 ) & B333 in ( D277 . C473 ) & B331 is_primitive-recursively_expressed_by B332 , B333 , B334))) };

consider C475 being (Element of ( HFuncs ( NAT ) )) such that L1884: C474 = C475 and L1885: (ex B335 , B336 being (Element of ( HFuncs ( NAT ) )) st (ex B337 being (Element of ( NAT )) st (B335 in ( D277 . C473 ) & B336 in ( D277 . C473 ) & C475 is_primitive-recursively_expressed_by B335 , B336 , B337))) by L1883;
consider C476 , C477 being (Element of ( HFuncs ( NAT ) )), C478 being (Element of ( NAT )) such that L1886: C476 in ( D277 . C473 ) and L1887: C477 in ( D277 . C473 ) and L1888: C475 is_primitive-recursively_expressed_by C476 , C477 , C478 by L1885;
L1889: C477 is  quasi_total by L1876 , L1887;
L1890: C476 is  quasi_total by L1876 , L1886;
thus L1891: thesis by L1890 , L1884 , L1888 , L1889 , L1538;
end;
end;

end;
suppose L1881: C474 in ( composition-closure ( D277 . C473 ) );

thus L1882: C474 is  quasi_total
proof
per cases  by L1881 , XBOOLE_0:def 3;
suppose L1883: C474 in ( D277 . C473 );

thus L1884: thesis by L1883 , L1876;
end;
suppose L1885: C474 in { ( B338 * <: B339 :> ) where B338 is (Element of ( HFuncs ( NAT ) )) , B339 is  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) : (B338 in ( D277 . C473 ) & ( arity B338 ) = ( len B339 ) & ( rng B339 ) c= ( D277 . C473 )) };

consider C479 being (Element of ( HFuncs ( NAT ) )), C480 being  with_the_same_arity (Element of ( ( HFuncs ( NAT ) ) * )) such that L1886: C474 = ( C479 * <: C480 :> ) and L1887: C479 in ( D277 . C473 ) and L1888: ( arity C479 ) = ( len C480 ) and L1889: ( rng C480 ) c= ( D277 . C473 ) by L1885;
L1890: (for B340 being (Element of ( HFuncs ( NAT ) )) holds (B340 in ( rng C480 ) implies B340 is  quasi_total)) by L1876 , L1889;
L1891: C479 is  quasi_total by L1876 , L1887;
thus L1892: thesis by L1891 , L1886 , L1888 , L1890 , L812;
end;
end;

end;
end;
L1884: S28[ ( 0 ) ]
proof
let C481 being (Element of ( HFuncs ( NAT ) ));
assume L1885: C481 in ( D277 . ( 0 ) );
L1886: C481 in ( initial-funcs ) by L1885 , L1732;
L1887: (C481 in { ( ( 0 ) const ( 0 ) ) , ( 1 succ 1 ) } or C481 in { ( B341 proj B342 ) where B341 , B342 is (Element of ( NAT )) : (1 <= B342 & B342 <= B341) }) by L1886 , XBOOLE_0:def 3;
per cases  by L1887 , TARSKI:def 2;
suppose L1888: C481 = ( ( 0 ) const ( 0 ) );

thus L1889: thesis by L1888 , L486;
end;
suppose L1890: C481 = ( 1 succ 1 );

thus L1891: thesis by L1890 , L486;
end;
suppose L1892: C481 in { ( B343 proj B344 ) where B343 , B344 is (Element of ( NAT )) : (1 <= B344 & B344 <= B343) };

L1893: (ex B345 , B346 being (Element of ( NAT )) st (C481 = ( B345 proj B346 ) & 1 <= B346 & B346 <= B345)) by L1892;
thus L1894: thesis by L1893 , L486;
end;
end;
L1896: (for B347 being (Element of ( NAT )) holds S28[ B347 ]) from NAT_1:sch 1(L1884 , L1875);
thus L1897: thesis by L1896;
end;
registration
cluster  ->  quasi_total  homogeneous for (Element of ( PrimRec ));
coherence
proof
set D278 = ( PrimRec-Approximation );
let C482 being (Element of ( PrimRec ));
consider C483 being set such that L1898: C482 in C483 and L1899: C483 in ( rng D278 ) by L1846 , TARSKI:def 4;
L1900: (ex B348 being set st (B348 in ( dom D278 ) & ( D278 . B348 ) = C483)) by L1899 , FUNCT_1:def 3;
thus L1901: thesis by L1900 , L1898 , L1874;
end;
end;
registration
cluster  primitive-recursive ->  quasi_total for (Element of ( HFuncs ( NAT ) ));
coherence
proof
let C484 being (Element of ( HFuncs ( NAT ) ));
assume L1903: C484 in ( PrimRec );
thus L1904: thesis by L1903;
end;
end;
registration
cluster  primitive-recursive ->  len-total for ( ( NAT ) * ) -defined ( ( NAT ) * ) -defined ( ( NAT ) * ) -defined ( ( NAT ) * ) -defined Function;
coherence
proof
let C485 being ( ( NAT ) * ) -defined Function;
assume L1906: C485 in ( PrimRec );
L1907: C485 is (Element of ( PrimRec )) by L1906;
thus L1908: thesis by L1907;
end;
cluster non  empty for (Element of ( PrimRec ));
existence
proof
L1909: ( ( 0 ) const ( 0 ) ) in ( PrimRec ) by L1575;
thus L1910: thesis by L1909;
end;
end;
begin
definition
let C486 being set;
let C487 being  homogeneous Relation;
attr C487 is C486 -ary
means
:L1912: ( arity C487 ) = C486;
end;
registration
cluster 1 -ary -> non  empty for  homogeneous  homogeneous  homogeneous  homogeneous Function;
coherence
proof
let C488 being  homogeneous Function;
assume L1914: ( arity C488 ) = 1;
L1915: (ex B349 being FinSequence st B349 in ( dom C488 )) by L1914 , MARGREL1:def 25;
thus L1916: thesis by L1915;
end;
cluster 2 -ary -> non  empty for  homogeneous  homogeneous  homogeneous  homogeneous Function;
coherence
proof
let C489 being  homogeneous Function;
assume L1917: ( arity C489 ) = 2;
L1918: (ex B350 being FinSequence st B350 in ( dom C489 )) by L1917 , MARGREL1:def 25;
thus L1919: thesis by L1918;
end;
cluster 3 -ary -> non  empty for  homogeneous  homogeneous  homogeneous  homogeneous Function;
coherence
proof
let C490 being  homogeneous Function;
assume L1920: ( arity C490 ) = 3;
L1921: (ex B351 being FinSequence st B351 in ( dom C490 )) by L1920 , MARGREL1:def 25;
thus L1922: thesis by L1921;
end;
end;
registration
let C491 being non  empty (Element of ( NAT ));
cluster ( C491 proj 1 ) ->  primitive-recursive;
coherence
proof
L1924: 1 <= C491 by NAT_1:14;
L1925: ( C491 proj 1 ) in ( PrimRec ) by L1924 , L1510;
thus L1926: thesis by L1925;
end;
end;
registration
cluster ( 2 proj 2 ) ->  primitive-recursive;
coherence
proof
L1928: ( 2 proj 2 ) in ( PrimRec ) by L1510;
thus L1929: thesis by L1928;
end;
cluster ( 1 succ 1 ) ->  primitive-recursive;
coherence
proof
L1930: ( 1 succ 1 ) in ( PrimRec ) by L1616;
thus L1931: thesis by L1930;
end;
cluster ( 3 succ 3 ) ->  primitive-recursive;
coherence
proof
L1932: ( 3 succ 3 ) in ( PrimRec ) by L1616;
thus L1933: thesis by L1932;
end;
let C492 being (Element of ( NAT ));
cluster ( ( 0 ) const C492 ) -> ( 0 ) -ary;
coherence
proof
thus L1934: ( arity ( ( 0 ) const C492 ) ) = ( 0 ) by L527;
end;
cluster ( 1 const C492 ) -> 1 -ary;
coherence
proof
thus L1935: ( arity ( 1 const C492 ) ) = 1 by L527;
end;
cluster ( 2 const C492 ) -> 2 -ary;
coherence
proof
thus L1936: ( arity ( 2 const C492 ) ) = 2 by L527;
end;
cluster ( 3 const C492 ) -> 3 -ary;
coherence
proof
thus L1937: ( arity ( 3 const C492 ) ) = 3 by L527;
end;
cluster ( 1 proj C492 ) -> 1 -ary;
coherence
proof
thus L1938: ( arity ( 1 proj C492 ) ) = 1 by L621;
end;
cluster ( 2 proj C492 ) -> 2 -ary;
coherence
proof
thus L1939: ( arity ( 2 proj C492 ) ) = 2 by L621;
end;
cluster ( 3 proj C492 ) -> 3 -ary;
coherence
proof
thus L1940: ( arity ( 3 proj C492 ) ) = 3 by L621;
end;
cluster ( 1 succ C492 ) -> 1 -ary;
coherence
proof
thus L1941: ( arity ( 1 succ C492 ) ) = 1 by L569;
end;
cluster ( 2 succ C492 ) -> 2 -ary;
coherence
proof
thus L1942: ( arity ( 2 succ C492 ) ) = 2 by L569;
end;
cluster ( 3 succ C492 ) -> 3 -ary;
coherence
proof
thus L1943: ( arity ( 3 succ C492 ) ) = 3 by L569;
end;
let C493 being (Element of ( NAT ));
cluster ( C492 const C493 ) ->  primitive-recursive;
coherence
proof
thus L1944: ( C492 const C493 ) in ( PrimRec ) by L1575;
end;
end;
registration
cluster ( 0 ) -ary  primitive-recursive non  empty for  homogeneous  homogeneous  homogeneous  homogeneous Function;
existence by L1510;
cluster 1 -ary  primitive-recursive for  homogeneous  homogeneous  homogeneous  homogeneous Function;
existence by L1510;
cluster 2 -ary  primitive-recursive for  homogeneous  homogeneous  homogeneous  homogeneous Function;
existence
proof
take D279 = ( 2 proj 1 );
thus L1946: D279 is 2 -ary;
thus L1947: D279 in ( PrimRec ) by L1510;
end;
cluster 3 -ary  primitive-recursive for  homogeneous  homogeneous  homogeneous  homogeneous Function;
existence
proof
take D280 = ( 3 proj 1 );
thus L1948: D280 is 3 -ary;
thus L1949: D280 in ( PrimRec ) by L1510;
end;
end;
registration
cluster non  empty ( 0 ) -ary  len-total  to-naturals for  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined Function;
existence
proof
L1951: ( ( 0 ) const ( 0 ) ) is ( 0 ) -ary;
thus L1952: thesis by L1951;
end;
cluster non  empty 1 -ary  len-total  to-naturals for  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined Function;
existence
proof
L1953: ( 1 const ( 0 ) ) is 1 -ary;
thus L1954: thesis by L1953;
end;
cluster non  empty 2 -ary  len-total  to-naturals for  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined Function;
existence
proof
L1955: ( 2 const ( 0 ) ) is 2 -ary;
thus L1956: thesis by L1955;
end;
cluster non  empty 3 -ary  len-total  to-naturals for  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined  homogeneous ( ( NAT ) * ) -defined Function;
existence
proof
L1957: ( 3 const ( 0 ) ) is 3 -ary;
thus L1958: thesis by L1957;
end;
end;
registration
let C494 being ( 0 ) -ary non  empty  primitive-recursive Function;
let C495 being 2 -ary  primitive-recursive Function;
cluster ( primrec (C494 , C495 , 1) ) ->  primitive-recursive 1 -ary;
coherence
proof
L1960: C495 in ( PrimRec ) by L1700;
L1961: ( arity C494 ) = ( 0 ) by L1912;
L1962: C494 is (Element of ( PrimRec )) by L1700;
L1963: ( dom C494 ) = ( ( 0 ) -tuples_on ( NAT ) ) by L1962 , L1961 , L367
.= { ( <*> ( NAT ) ) } by FINSEQ_2:94;
L1964: ( {} ) in ( dom C494 ) by L1963 , TARSKI:def 1;
L1965: C494 in ( PrimRec ) by L1700;
L1966: 1 <= ( ( 0 ) + 1 );
L1967: ( arity C495 ) = ( ( 0 ) + 2 ) by L1912;
thus L1968: ( primrec (C494 , C495 , 1) ) in ( PrimRec ) by L1967 , L1966 , L1961 , L1965 , L1960 , L1664;
reconsider D281 = <* ( 0 ) *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
L1969: ( dom <* ( 0 ) *> ) = { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
L1970: 1 in ( dom <* ( 0 ) *> ) by L1969 , TARSKI:def 1;
L1971: ( Del (<* ( 0 ) *> , 1) ) = ( {} ) by WSIERP_1:19;
L1972: ( D281 +* (1 , ( 0 )) ) in ( dom ( primrec (C494 , C495 , 1) ) ) by L1971 , L1966 , L1961 , L1964 , L1970 , L1305;
L1973: <* ( 0 ) *> in ( dom ( primrec (C494 , C495 , 1) ) ) by L1972 , FUNCT_7:95;
L1974: ( len <* ( 0 ) *> ) = 1 by FINSEQ_1:39;
thus L1975: ( arity ( primrec (C494 , C495 , 1) ) ) = 1 by L1974 , L1973 , MARGREL1:def 25;
end;
end;
registration
let C496 being 1 -ary  primitive-recursive Function;
let C497 being 3 -ary  primitive-recursive Function;
cluster ( primrec (C496 , C497 , 1) ) ->  primitive-recursive 2 -ary;
coherence
proof
L1977: C497 in ( PrimRec ) by L1700;
L1978: 1 <= ( 1 + 1 );
L1979: ( arity C497 ) = ( 1 + 2 ) by L1912;
L1980: ( arity C496 ) = 1 by L1912;
L1981: C496 in ( PrimRec ) by L1700;
thus L1982: ( primrec (C496 , C497 , 1) ) in ( PrimRec ) by L1981 , L1978 , L1980 , L1979 , L1977 , L1664;
thus L1983: ( arity ( primrec (C496 , C497 , 1) ) ) = 2 by L1978 , L1980 , L1979 , L1203;
end;
cluster ( primrec (C496 , C497 , 2) ) ->  primitive-recursive 2 -ary;
coherence
proof
L1984: C497 in ( PrimRec ) by L1700;
L1985: 2 <= ( 1 + 1 );
L1986: ( arity C497 ) = ( 1 + 2 ) by L1912;
L1987: ( arity C496 ) = 1 by L1912;
L1988: C496 in ( PrimRec ) by L1700;
thus L1989: ( primrec (C496 , C497 , 2) ) in ( PrimRec ) by L1988 , L1985 , L1987 , L1986 , L1984 , L1664;
thus L1990: ( arity ( primrec (C496 , C497 , 2) ) ) = 2 by L1985 , L1987 , L1986 , L1203;
end;
end;
theorem
L1992: (for R1 being (Element of ( NAT )) holds (for B352 being 1 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds (for B353 being non  empty  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds ( ( primrec (B352 , B353 , 2) ) . <* R1 , ( 0 ) *> ) = ( B352 . <* R1 *> ))))
proof
let R1 being (Element of ( NAT ));
let C498 being 1 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
let C499 being non  empty  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
L1993: ( arity C498 ) = 1 by L1912;
reconsider D282 = <* R1 , ( 0 ) *> as (Element of ( ( ( arity C498 ) + 1 ) -tuples_on ( NAT ) )) by L1993 , FINSEQ_2:101;
L1994: ( len D282 ) = 2 by FINSEQ_1:44;
L1995: 2 in ( dom D282 ) by L1994 , FINSEQ_3:25;
L1996: ( D282 +* (2 , ( 0 )) ) = D282 by L1;
thus L1997: ( ( primrec (C498 , C499 , 2) ) . <* R1 , ( 0 ) *> ) = ( C498 . ( Del (D282 , 2) ) ) by L1996 , L1995 , L1438
.= ( C498 . <* R1 *> ) by WSIERP_1:19;
end;
theorem
L1998: (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ((R20 is  len-total & ( arity R20 ) = ( 0 )) implies ( ( primrec (R20 , R21 , 1) ) . <* ( 0 ) *> ) = ( R20 . ( {} ) ))))
proof
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L1999: R20 is  len-total
and
L2000: ( arity R20 ) = ( 0 );
reconsider D283 = <* ( 0 ) *> as (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) by L2000 , FINSEQ_2:131;
L2001: ( len D283 ) = 1 by FINSEQ_1:39;
L2002: 1 in ( dom D283 ) by L2001 , FINSEQ_3:25;
L2003: ( D283 +* (1 , ( 0 )) ) = D283 by FUNCT_7:95;
thus L2004: ( ( primrec (R20 , R21 , 1) ) . <* ( 0 ) *> ) = ( R20 . ( Del (D283 , 1) ) ) by L2003 , L1999 , L2002 , L1438
.= ( R20 . ( {} ) ) by WSIERP_1:19;
end;
theorem
L2005: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for B354 being 1 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds (for B355 being 3 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds ( ( primrec (B354 , B355 , 2) ) . <* R1 , ( R2 + 1 ) *> ) = ( B355 . <* R1 , R2 , ( ( primrec (B354 , B355 , 2) ) . <* R1 , R2 *> ) *> )))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let C500 being 1 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
let C501 being 3 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
L2006: ( arity C500 ) = 1 by L1912;
reconsider D284 = <* R1 , R2 *> as (Element of ( ( ( arity C500 ) + 1 ) -tuples_on ( NAT ) )) by L2006 , FINSEQ_2:101;
L2007: ( D284 +* (2 , ( R2 + 1 )) ) = <* R1 , ( R2 + 1 ) *> by L1;
L2008: ( D284 +* (2 , R2) ) = <* R1 , R2 *> by L1;
L2009: ( ( arity C500 ) + 2 ) = ( arity C501 ) by L2006 , L1912;
thus L2010: ( ( primrec (C500 , C501 , 2) ) . <* R1 , ( R2 + 1 ) *> ) = ( C501 . ( ( D284 +* (2 , R2) ) ^ <* ( ( primrec (C500 , C501 , 2) ) . ( D284 +* (2 , R2) ) ) *> ) ) by L2009 , L2006 , L2007 , L1450
.= ( C501 . <* R1 , R2 , ( ( primrec (C500 , C501 , 2) ) . <* R1 , R2 *> ) *> ) by L2008 , FINSEQ_1:43;
end;
theorem
L2011: (for R1 being (Element of ( NAT )) holds (for R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds (for R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function holds ((R20 is  len-total & R21 is  len-total & ( arity R20 ) = ( 0 ) & ( arity R21 ) = 2) implies ( ( primrec (R20 , R21 , 1) ) . <* ( R1 + 1 ) *> ) = ( R21 . <* R1 , ( ( primrec (R20 , R21 , 1) ) . <* R1 *> ) *> )))))
proof
let R1 being (Element of ( NAT ));
let R20 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
let R21 being non  empty  homogeneous  to-naturals ( ( NAT ) * ) -defined Function;
assume that
L2012: R20 is  len-total
and
L2013: R21 is  len-total
and
L2014: ( arity R20 ) = ( 0 )
and
L2015: ( arity R21 ) = 2;
reconsider D285 = <* R1 *> as (Element of ( ( ( arity R20 ) + 1 ) -tuples_on ( NAT ) )) by L2014 , FINSEQ_2:131;
L2016: ( D285 +* (1 , ( R1 + 1 )) ) = <* ( R1 + 1 ) *> by FUNCT_7:95;
L2017: ( D285 +* (1 , R1) ) = <* R1 *> by FUNCT_7:95;
L2018: ( ( arity R20 ) + 2 ) = ( arity R21 ) by L2014 , L2015;
thus L2019: ( ( primrec (R20 , R21 , 1) ) . <* ( R1 + 1 ) *> ) = ( R21 . ( ( D285 +* (1 , R1) ) ^ <* ( ( primrec (R20 , R21 , 1) ) . ( D285 +* (1 , R1) ) ) *> ) ) by L2018 , L2012 , L2013 , L2014 , L2016 , L1450
.= ( R21 . <* R1 , ( ( primrec (R20 , R21 , 1) ) . <* R1 *> ) *> ) by L2017 , FINSEQ_1:def 9;
end;
L2020:
now
reconsider D286 = <* ( 0 ) , ( 0 ) , ( 0 ) *> as (FinSequence of ( NAT ));
let C502 being  quasi_total  homogeneous non  empty (PartFunc of ( ( NAT ) * ) , ( NAT ));
set D287 = ( C502 * <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> );
L2021: ( rng D287 ) c= ( NAT ) by RELAT_1:def 19;
assume L2022: ( arity C502 ) = 2;
L2023: ( dom C502 ) = ( 2 -tuples_on ( NAT ) ) by L2022 , L367;
thus L2024: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( dom ( 3 proj 1 ) ) /\ ( dom ( 3 proj 3 ) ) ) by FINSEQ_3:142;
thus L2025: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( 3 -tuples_on ( NAT ) ) /\ ( dom ( 3 proj 3 ) ) ) by L2024 , L596
.= ( ( 3 -tuples_on ( NAT ) ) /\ ( 3 -tuples_on ( NAT ) ) ) by L596
.= ( 3 -tuples_on ( NAT ) );
L2026:
now
set D288 = <* ( 3 proj 1 ) , ( 3 proj 3 ) *>;
let C503 being set;
set D289 = <: D288 :>;
L2027: ( product ( rngs D288 ) ) = ( product <* ( rng ( 3 proj 1 ) ) , ( rng ( 3 proj 3 ) ) *> ) by FINSEQ_3:133
.= ( product <* ( NAT ) , ( rng ( 3 proj 3 ) ) *> ) by L596
.= ( product <* ( NAT ) , ( NAT ) *> ) by L596
.= ( 2 -tuples_on ( NAT ) ) by FINSEQ_3:128;
thus L2028:now
L2029: ( rng D289 ) c= ( product ( rngs D288 ) ) by FUNCT_6:29;
assume L2030: C503 in ( rng D289 );
thus L2031: C503 in ( dom C502 ) by L2030 , L2023 , L2027 , L2029;
end;
assume L2032: C503 in ( dom C502 );
L2033: C503 is (Element of ( 2 -tuples_on ( NAT ) )) by L2032 , L2022 , L367;
consider C504 , C505 being (Element of ( NAT )) such that L2034: C503 = <* C504 , C505 *> by L2033 , FINSEQ_2:100;
reconsider D290 = <* C504 , ( 0 ) , C505 *> as (Element of ( 3 -tuples_on ( NAT ) )) by FINSEQ_2:104;
L2035: ( D289 . D290 ) = <* ( ( 3 proj 1 ) . D290 ) , ( ( 3 proj 3 ) . D290 ) *> by L2024 , L2025 , FINSEQ_3:142
.= <* ( D290 . 1 ) , ( ( 3 proj 3 ) . D290 ) *> by L627
.= <* ( D290 . 1 ) , ( D290 . 3 ) *> by L627
.= <* C504 , ( D290 . 3 ) *> by FINSEQ_1:45
.= C503 by L2034 , FINSEQ_1:45;
thus L2036: C503 in ( rng D289 ) by L2035 , L2025 , FUNCT_1:def 3;
end;
L2037: ( rng <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( dom C502 ) by L2026 , TARSKI:1;
thus L2038: ( dom ( C502 * <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) ) = ( 3 -tuples_on ( NAT ) ) by L2037 , L2025 , RELAT_1:27;
reconsider D291 = D287 as (PartFunc of ( ( NAT ) * ) , ( NAT )) by L2038 , L2021 , FINSEQ_2:142 , RELSET_1:4;
reconsider D292 = D291 as  homogeneous (PartFunc of ( ( NAT ) * ) , ( NAT )) by L2038 , MARGREL1:def 21;
take D293 = D292;
thus L2039: D293 = ( C502 * <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> );
L2040: D293 is (Element of ( PFuncs (( ( NAT ) * ) , ( NAT )) )) by PARTFUN1:45;
L2041: D293 in ( HFuncs ( NAT ) ) by L2040;
thus L2042: D293 is (Element of ( HFuncs ( NAT ) )) by L2041;
L2043: ( len D286 ) = 3 by FINSEQ_1:45;
L2044: D286 is (Element of ( 3 -tuples_on ( NAT ) )) by L2043 , FINSEQ_2:92;
L2045: (for B356 being FinSequence holds (B356 in ( dom D293 ) implies 3 = ( len B356 ))) by L2038 , CARD_1:def 7;
thus L2046: ( arity D293 ) = 3 by L2045 , L2044 , L2038 , MARGREL1:def 25;
thus L2047: D293 is  quasi_total non  empty by L2046 , L2038 , L367;
end;
definition
let C506 being Function;
func (1,2)->(1,?,2) C506 -> Function equals 
( C506 * <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> );
coherence;
end;
registration
let C507 being  to-naturals ( ( NAT ) * ) -defined Function;
cluster ( (1,2)->(1,?,2) C507 ) ->  to-naturals ( ( NAT ) * ) -defined;
coherence
proof
set D294 = ( (1,2)->(1,?,2) C507 );
L2049: ( 3 -tuples_on ( NAT ) ) c= ( ( NAT ) * ) by FINSEQ_2:142;
L2050: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( dom ( 3 proj 1 ) ) /\ ( dom ( 3 proj 3 ) ) ) by FINSEQ_3:142;
L2051: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( 3 -tuples_on ( NAT ) ) /\ ( dom ( 3 proj 3 ) ) ) by L2050 , L596
.= ( ( 3 -tuples_on ( NAT ) ) /\ ( 3 -tuples_on ( NAT ) ) ) by L596
.= ( 3 -tuples_on ( NAT ) );
L2052: ( dom D294 ) c= ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) by RELAT_1:25;
L2053: ( dom D294 ) c= ( ( NAT ) * ) by L2052 , L2051 , L2049 , XBOOLE_1:1;
thus L2054: thesis by L2053 , RELAT_1:def 18;
end;
end;
registration
let C508 being  homogeneous Function;
cluster ( (1,2)->(1,?,2) C508 ) ->  homogeneous;
coherence
proof
set D295 = ( (1,2)->(1,?,2) C508 );
L2056: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( dom ( 3 proj 1 ) ) /\ ( dom ( 3 proj 3 ) ) ) by FINSEQ_3:142;
L2057: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( 3 -tuples_on ( NAT ) ) /\ ( dom ( 3 proj 3 ) ) ) by L2056 , L596
.= ( ( 3 -tuples_on ( NAT ) ) /\ ( 3 -tuples_on ( NAT ) ) ) by L596
.= ( 3 -tuples_on ( NAT ) );
L2058: ( dom D295 ) c= ( 3 -tuples_on ( NAT ) ) by L2057 , RELAT_1:25;
thus L2059: ( dom D295 ) is  with_common_domain by L2058;
end;
end;
registration
let C509 being 2 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
cluster ( (1,2)->(1,?,2) C509 ) -> non  empty 3 -ary  len-total;
coherence
proof
L2061: C509 is  quasi_total  homogeneous non  empty  quasi_total  homogeneous non  empty  quasi_total  homogeneous non  empty  quasi_total  homogeneous non  empty (PartFunc of ( ( NAT ) * ) , ( NAT )) by L317;
L2062: ( arity C509 ) = 2 by L1912;
consider C510 being  homogeneous (PartFunc of ( ( NAT ) * ) , ( NAT )) such that L2063: C510 = ( C509 * <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) and L2064: C510 is (Element of ( HFuncs ( NAT ) )) and L2065: ( arity C510 ) = 3 and L2066: C510 is  quasi_total non  empty by L2062 , L2061 , L2020;
reconsider D296 = C510 as  quasi_total non  empty  homogeneous (PartFunc of ( ( NAT ) * ) , ( NAT )) by L2066;
L2067: D296 is non  empty 3 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined non  empty 3 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined non  empty 3 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined non  empty 3 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function by L2065 , L1912;
thus L2068: thesis by L2067 , L2063;
end;
end;
theorem
L2070: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (for R3 being (Element of ( NAT )) holds (for B357 being 2 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function holds ( ( (1,2)->(1,?,2) B357 ) . <* R1 , R2 , R3 *> ) = ( B357 . <* R1 , R3 *> )))))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
let R3 being (Element of ( NAT ));
let C511 being 2 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function;
reconsider D297 = C511 as  quasi_total  homogeneous non  empty (PartFunc of ( ( NAT ) * ) , ( NAT )) by L317;
reconsider D298 = <* R1 , R2 , R3 *> as (Element of ( 3 -tuples_on ( NAT ) )) by FINSEQ_2:104;
L2071: ( arity D297 ) = 2 by L1912;
L2072: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( ( dom ( 3 proj 1 ) ) /\ ( dom ( 3 proj 3 ) ) ) by L2071 , L2020;
L2073: ( dom <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) = ( 3 -tuples_on ( NAT ) ) by L2071 , L2020;
L2074: ( dom ( D297 * <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> ) ) = ( 3 -tuples_on ( NAT ) ) by L2071 , L2020;
thus L2075: ( ( (1,2)->(1,?,2) C511 ) . <* R1 , R2 , R3 *> ) = ( C511 . ( <: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> :> . D298 ) ) by L2074 , FUNCT_1:12
.= ( C511 . <* ( ( 3 proj 1 ) . D298 ) , ( ( 3 proj 3 ) . D298 ) *> ) by L2072 , L2073 , FINSEQ_3:142
.= ( C511 . <* ( D298 . 1 ) , ( ( 3 proj 3 ) . D298 ) *> ) by L627
.= ( C511 . <* ( D298 . 1 ) , ( D298 . 3 ) *> ) by L627
.= ( C511 . <* R1 , ( D298 . 3 ) *> ) by FINSEQ_1:45
.= ( C511 . <* R1 , R3 *> ) by FINSEQ_1:45;
end;
theorem
L2076: (for B358 being 2 -ary  primitive-recursive Function holds ( (1,2)->(1,?,2) B358 ) in ( PrimRec ))
proof
L2077: ( 3 proj 3 ) in ( PrimRec ) by L1510;
L2078: ( 2 -tuples_on ( PrimRec ) ) c= ( ( PrimRec ) * ) by FINSEQ_2:142;
L2079: ( 3 proj 1 ) in ( PrimRec ) by L1510;
L2080: <* ( 3 proj 1 ) , ( 3 proj 3 ) *> in ( 2 -tuples_on ( PrimRec ) ) by L2079 , L2077 , FINSEQ_2:101;
reconsider D299 = <* ( 3 proj 1 ) , ( 3 proj 3 ) *> as (Element of ( ( PrimRec ) * )) by L2080 , L2078;
L2081: D299 is  with_the_same_arity
proof
let C512 , C513 being Function;
assume that
L2082: C512 in ( rng D299 )
and
L2083: C513 in ( rng D299 );
L2084: ( rng D299 ) = { ( 3 proj 1 ) , ( 3 proj 3 ) } by FINSEQ_2:127;
thus L2085: (C512 is  empty implies (C513 is  empty or ( dom C513 ) = { ( {} ) })) by L2084 , L2082 , TARSKI:def 2;
assume that
L2086: C512 is non  empty
and
L2087: C513 is non  empty;
take 3;
take ( NAT );
L2088: (C512 = ( 3 proj 1 ) or C512 = ( 3 proj 3 )) by L2082 , L2084 , TARSKI:def 2;
thus L2089: ( dom C512 ) c= ( 3 -tuples_on ( NAT ) ) by L2088 , L596;
L2090: (C513 = ( 3 proj 1 ) or C513 = ( 3 proj 3 )) by L2083 , L2084 , TARSKI:def 2;
thus L2091: thesis by L2090 , L596;
end;
reconsider D300 = D299 as  with_the_same_arity (Element of ( ( PrimRec ) * )) by L2081;
let C514 being 2 -ary  primitive-recursive Function;
L2092: ( arity C514 ) = 2 by L1912;
L2093: ( arity C514 ) = ( len D300 ) by L2092 , FINSEQ_1:44;
L2094: C514 is (Element of ( PrimRec )) by L1700;
thus L2095: thesis by L2094 , L2093 , L1651;
end;
registration
let C515 being 2 -ary  primitive-recursive  homogeneous Function;
cluster ( (1,2)->(1,?,2) C515 ) ->  primitive-recursive 3 -ary;
coherence
proof
thus L2096: ( (1,2)->(1,?,2) C515 ) in ( PrimRec ) by L2076;
thus L2097: ( arity ( (1,2)->(1,?,2) C515 ) ) = 3 by L1912;
end;
end;
definition
func [+] -> 2 -ary  primitive-recursive Function equals 
( primrec (( 1 proj 1 ) , ( 3 succ 3 ) , 2) );
coherence;
end;
theorem
L2100: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds ( ( [+] ) . <* R1 , R2 *> ) = ( R1 + R2 )))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
reconsider D301 = <* R1 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
defpred S29[ (Element of ( NAT )) ] means ( ( [+] ) . <* R1 , $1 *> ) = ( R1 + $1 );
L2101:
now
let C516 being (Element of ( NAT ));
reconsider D302 = <* R1 , C516 , ( R1 + C516 ) *> as (Element of ( 3 -tuples_on ( NAT ) )) by FINSEQ_2:104;
assume L2102: S29[ C516 ];
L2103: ( ( [+] ) . <* R1 , ( C516 + 1 ) *> ) = ( ( 3 succ 3 ) . D302 ) by L2102 , L2005
.= ( ( D302 /. 3 ) + 1 ) by L533
.= ( ( R1 + C516 ) + 1 ) by FINSEQ_4:18
.= ( R1 + ( C516 + 1 ) );
thus L2104: S29[ ( C516 + 1 ) ] by L2103;
end;
L2105: ( ( [+] ) . <* R1 , ( 0 ) *> ) = ( ( 1 proj 1 ) . D301 ) by L1992
.= ( D301 . 1 ) by L627
.= ( R1 + ( 0 ) ) by FINSEQ_1:40;
L2106: S29[ ( 0 ) ] by L2105;
L2107: (for B359 being (Element of ( NAT )) holds S29[ B359 ]) from NAT_1:sch 1(L2106 , L2101);
thus L2108: thesis by L2107;
end;
definition
func [*] -> 2 -ary  primitive-recursive Function equals 
( primrec (( 1 const ( 0 ) ) , ( (1,2)->(1,?,2) ( [+] ) ) , 2) );
coherence;
end;
theorem
L2110: (for B360 , B361 being (Element of ( NAT )) holds ( ( [*] ) . <* B360 , B361 *> ) = ( B360 * B361 ))
proof
let C517 being (Element of ( NAT ));
defpred S30[ (Element of ( NAT )) ] means ( ( [*] ) . <* C517 , $1 *> ) = ( C517 * $1 );
L2111:
now
let C518 being (Element of ( NAT ));
assume L2112: S30[ C518 ];
L2113: ( ( [*] ) . <* C517 , ( C518 + 1 ) *> ) = ( ( (1,2)->(1,?,2) ( [+] ) ) . <* C517 , C518 , ( C517 * C518 ) *> ) by L2112 , L2005
.= ( ( [+] ) . <* C517 , ( C517 * C518 ) *> ) by L2070
.= ( ( C517 * 1 ) + ( C517 * C518 ) ) by L2100
.= ( C517 * ( C518 + 1 ) );
thus L2114: S30[ ( C518 + 1 ) ] by L2113;
end;
reconsider D303 = <* C517 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:98;
L2115: ( ( [*] ) . <* C517 , ( 0 ) *> ) = ( ( 1 const ( 0 ) ) . D303 ) by L1992
.= ( C517 * ( 0 ) ) by FUNCOP_1:7;
L2116: S30[ ( 0 ) ] by L2115;
thus L2117: (for B362 being (Element of ( NAT )) holds S30[ B362 ]) from NAT_1:sch 1(L2116 , L2111);
end;
registration
let C519 , C520 being 2 -ary  primitive-recursive  homogeneous Function;
cluster <* C519 , C520 *> ->  with_the_same_arity;
coherence
proof
reconsider D304 = C519 , D305 = C520 as (Element of ( PrimRec )) by L1700;
L2118: ( rng <* D304 , D305 *> ) = { D304 , D305 } by FINSEQ_2:127;
L2119:
now
let C521 , C522 being  homogeneous Function;
assume that
L2120: C521 in ( rng <* D304 , D305 *> )
and
L2121: C522 in ( rng <* D304 , D305 *> );
L2122: (C521 = D304 or C521 = D305) by L2118 , L2120 , TARSKI:def 2;
L2123: ( arity C521 ) = 2 by L2122 , L1912;
L2124: (C522 = D304 or C522 = D305) by L2118 , L2121 , TARSKI:def 2;
thus L2125: ( arity C521 ) = ( arity C522 ) by L2124 , L2123 , L1912;
end;
L2126: ( rng <* D304 , D305 *> ) c= ( PrimRec ) by FINSEQ_1:def 4;
thus L2127: thesis by L2126 , L2119 , L492 , XBOOLE_1:1;
end;
end;
registration
let C523 , C524 , C525 being 2 -ary  primitive-recursive Function;
cluster ( C523 * <: <* C524 , C525 *> :> ) ->  primitive-recursive;
coherence
proof
reconsider D306 = C524 , D307 = C525 as (Element of ( PrimRec )) by L1700;
L2129: C523 in ( PrimRec ) by L1700;
L2130: ( rng <* D306 , D307 *> ) c= ( PrimRec ) by FINSEQ_1:def 4;
L2131: ( rng <* C524 , C525 *> ) c= ( HFuncs ( NAT ) ) by L2130 , XBOOLE_1:1;
reconsider D308 = <* C524 , C525 *> as  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) by L2131 , FINSEQ_1:def 4;
L2132: ( PrimRec ) is  composition_closed by L1510;
L2133: ( arity C523 ) = 2 by L1912;
L2134: ( len D308 ) = 2 by FINSEQ_1:44;
thus L2135: ( C523 * <: <* C524 , C525 *> :> ) in ( PrimRec ) by L2134 , L2130 , L2129 , L2132 , L2133 , L1507;
end;
end;
registration
let C526 , C527 , C528 being 2 -ary  primitive-recursive Function;
cluster ( C526 * <: <* C527 , C528 *> :> ) -> 2 -ary;
coherence
proof
set D309 = the (Element of ( 2 -tuples_on ( NAT ) ));
reconsider D310 = C526 , D311 = ( C526 * <: <* C527 , C528 *> :> ) , D312 = C527 , D313 = C528 as (Element of ( PrimRec )) by L1700;
L2137: D310 = C526;
L2138: ( rng <* D312 , D313 *> ) c= ( PrimRec ) by FINSEQ_1:def 4;
L2139: ( rng <* C527 , C528 *> ) c= ( HFuncs ( NAT ) ) by L2138 , XBOOLE_1:1;
reconsider D314 = <* C527 , C528 *> as  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) by L2139 , FINSEQ_1:def 4;
L2140: ( dom <: D314 :> ) = ( ( dom C527 ) /\ ( dom C528 ) ) by FINSEQ_3:142;
L2141: ( arity C527 ) = 2 by L1912;
L2142: ( rng D314 ) = { C527 , C528 } by FINSEQ_2:127;
L2143: C527 in ( rng D314 ) by L2142 , TARSKI:def 2;
L2144: ( arity D314 ) = 2 by L2143 , L2141 , L414;
L2145: ( arity C526 ) = 2 by L1912;
L2146: ( dom D310 ) = ( 2 -tuples_on ( NAT ) ) by L2145 , L347;
L2147: ( arity C528 ) = 2 by L1912;
L2148: ( dom D313 ) = ( 2 -tuples_on ( NAT ) ) by L2147 , L347;
L2149: ( dom D312 ) = ( 2 -tuples_on ( NAT ) ) by L2141 , L347;
L2150: ( <: D314 :> . D309 ) = <* ( D312 . D309 ) , ( D313 . D309 ) *> by L2149 , L2148 , L2140 , FINSEQ_3:142;
L2151: ( <: D314 :> . D309 ) is (Element of ( 2 -tuples_on ( NAT ) )) by L2150 , FINSEQ_2:101;
L2152: D311 is non  empty by L2151 , L2146 , L2149 , L2148 , L2140 , FUNCT_1:11 , RELAT_1:38;
thus L2153: ( arity ( C526 * <: <* C527 , C528 *> :> ) ) = 2 by L2152 , L2137 , L2144 , L732;
end;
end;
registration
let C529 being 1 -ary  primitive-recursive Function;
let C530 being  primitive-recursive Function;
cluster ( C529 * <: <* C530 *> :> ) ->  primitive-recursive;
coherence
proof
reconsider D315 = C530 as (Element of ( PrimRec )) by L1700;
L2155: C529 in ( PrimRec ) by L1700;
L2156: ( rng <* D315 *> ) c= ( PrimRec ) by FINSEQ_1:def 4;
L2157: ( rng <* C530 *> ) c= ( HFuncs ( NAT ) ) by L2156 , XBOOLE_1:1;
reconsider D316 = <* D315 *> as  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) by L2157 , FINSEQ_1:def 4;
L2158: ( PrimRec ) is  composition_closed by L1510;
L2159: ( arity C529 ) = 1 by L1912;
L2160: ( len D316 ) = 1 by FINSEQ_1:39;
thus L2161: ( C529 * <: <* C530 *> :> ) in ( PrimRec ) by L2160 , L2156 , L2155 , L2158 , L2159 , L1507;
end;
end;
registration
let C531 being 1 -ary  primitive-recursive Function;
let C532 being 2 -ary  primitive-recursive Function;
cluster ( C531 * <: <* C532 *> :> ) -> 2 -ary;
coherence
proof
set D317 = the (Element of ( 2 -tuples_on ( NAT ) ));
reconsider D318 = C531 , D319 = ( C531 * <: <* C532 *> :> ) , D320 = C532 as (Element of ( PrimRec )) by L1700;
L2163: D318 = C531;
L2164: ( rng <* D320 *> ) c= ( PrimRec ) by FINSEQ_1:def 4;
L2165: ( rng <* C532 *> ) c= ( HFuncs ( NAT ) ) by L2164 , XBOOLE_1:1;
reconsider D321 = <* D320 *> as  with_the_same_arity (FinSequence of ( HFuncs ( NAT ) )) by L2165 , FINSEQ_1:def 4;
L2166: ( dom <: D321 :> ) = ( dom C532 ) by FINSEQ_3:141;
L2167: ( arity C531 ) = 1 by L1912;
L2168: ( dom D318 ) = ( 1 -tuples_on ( NAT ) ) by L2167 , L347;
L2169: ( arity C532 ) = 2 by L1912;
L2170: ( rng D321 ) = { C532 } by FINSEQ_1:39;
L2171: C532 in ( rng D321 ) by L2170 , TARSKI:def 1;
L2172: ( arity D321 ) = 2 by L2171 , L2169 , L414;
L2173: ( dom D320 ) = ( 2 -tuples_on ( NAT ) ) by L2169 , L347;
L2174: ( <: D321 :> . D317 ) = <* ( D320 . D317 ) *> by L2173 , FINSEQ_3:141;
L2175: ( <: D321 :> . D317 ) in ( 1 -tuples_on ( NAT ) ) by L2174 , FINSEQ_2:98;
L2176: D319 is non  empty by L2175 , L2173 , L2166 , L2168 , FUNCT_1:11 , RELAT_1:38;
thus L2177: ( arity ( C531 * <: <* C532 *> :> ) ) = 2 by L2176 , L2163 , L2172 , L732;
end;
end;
definition
func [!] -> 1 -ary  primitive-recursive Function equals 
( primrec (( ( 0 ) const 1 ) , ( ( [*] ) * <: <* ( ( 1 succ 1 ) * <: <* ( 2 proj 1 ) *> :> ) , ( 2 proj 2 ) *> :> ) , 1) );
coherence;
end;
scheme Primrec1 { F1() -> 1 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function , F2() -> 2 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function , F3(set) -> (Element of ( NAT )) , F4(set , set) -> (Element of ( NAT )) } : (for B363 , B364 being (Element of ( NAT )) holds ( ( F1() * <: <* F2() *> :> ) . <* B363 , B364 *> ) = F3(F4(B363 , B364)))
provided
L2180: (for B365 being (Element of ( NAT )) holds ( F1() . <* B365 *> ) = F3(B365))
and
L2181: (for B366 , B367 being (Element of ( NAT )) holds ( F2() . <* B366 , B367 *> ) = F4(B366 , B367))
proof
let C533 , C534 being (Element of ( NAT ));
L2182: ( arity F2() ) = 2 by L1912;
L2183: ( dom F2() ) = ( 2 -tuples_on ( NAT ) ) by L2182 , L374;
L2184: ( dom <: <* F2() *> :> ) = ( dom F2() ) by FINSEQ_3:141;
thus L2185: ( ( F1() * <: <* F2() *> :> ) . <* C533 , C534 *> ) = ( F1() . ( <: <* F2() *> :> . <* C533 , C534 *> ) ) by L2184 , L2183 , FINSEQ_2:101 , FUNCT_1:13
.= ( F1() . <* ( F2() . <* C533 , C534 *> ) *> ) by L2183 , FINSEQ_2:101 , FINSEQ_3:141
.= ( F1() . <* F4(C533 , C534) *> ) by L2181
.= F3(F4(C533 , C534)) by L2180;
end;
scheme Primrec2 { F5 , F6 , F7() -> 2 -ary  len-total  to-naturals  homogeneous ( ( NAT ) * ) -defined Function , F8 , F9 , F10(set , set) -> (Element of ( NAT )) } : (for B368 , B369 being (Element of ( NAT )) holds ( ( F5() * <: <* F6() , F7() *> :> ) . <* B368 , B369 *> ) = F8(F9(B368 , B369) , F10(B368 , B369)))
provided
L2186: (for B370 , B371 being (Element of ( NAT )) holds ( F5() . <* B370 , B371 *> ) = F8(B370 , B371))
and
L2187: (for B372 , B373 being (Element of ( NAT )) holds ( F6() . <* B372 , B373 *> ) = F9(B372 , B373))
and
L2188: (for B374 , B375 being (Element of ( NAT )) holds ( F7() . <* B374 , B375 *> ) = F10(B374 , B375))
proof
let C535 , C536 being (Element of ( NAT ));
L2189: ( arity F6() ) = 2 by L1912;
L2190: ( dom F6() ) = ( 2 -tuples_on ( NAT ) ) by L2189 , L374;
L2191: ( arity F7() ) = 2 by L1912;
L2192: ( dom F7() ) = ( 2 -tuples_on ( NAT ) ) by L2191 , L374;
L2193: ( dom <: <* F6() , F7() *> :> ) = ( ( dom F6() ) /\ ( dom F7() ) ) by FINSEQ_3:142;
thus L2194: ( ( F5() * <: <* F6() , F7() *> :> ) . <* C535 , C536 *> ) = ( F5() . ( <: <* F6() , F7() *> :> . <* C535 , C536 *> ) ) by L2193 , L2190 , L2192 , FINSEQ_2:101 , FUNCT_1:13
.= ( F5() . <* ( F6() . <* C535 , C536 *> ) , ( F7() . <* C535 , C536 *> ) *> ) by L2193 , L2190 , L2192 , FINSEQ_2:101 , FINSEQ_3:142
.= ( F5() . <* F9(C535 , C536) , ( F7() . <* C535 , C536 *> ) *> ) by L2187
.= ( F5() . <* F9(C535 , C536) , F10(C535 , C536) *> ) by L2188
.= F8(F9(C535 , C536) , F10(C535 , C536)) by L2186;
end;
theorem
L2195: (for R1 being (Element of ( NAT )) holds ( ( [!] ) . <* R1 *> ) = ( R1 ! ))
proof
let R1 being (Element of ( NAT ));
defpred S31[ (Element of ( NAT )) ] means ( ( [!] ) . <* $1 *> ) = ( $1 ! );
deffunc H7((Element of ( NAT )) , (Element of ( NAT ))) = $2;
deffunc H8((Element of ( NAT )) , (Element of ( NAT ))) = ( $1 * $2 );
deffunc H9((Element of ( NAT )) , (Element of ( NAT ))) = $1;
deffunc H10((Element of ( NAT ))) = ( $1 + 1 );
set D322 = ( ( [*] ) * <: <* ( ( 1 succ 1 ) * <: <* ( 2 proj 1 ) *> :> ) , ( 2 proj 2 ) *> :> );
deffunc H11((Element of ( NAT )) , (Element of ( NAT ))) = H10(H9($1 , $2));
L2196: (for B376 , B377 being (Element of ( NAT )) holds ( ( 2 proj 1 ) . <* B376 , B377 *> ) = H9(B376 , B377))
proof
let C537 , C538 being (Element of ( NAT ));
reconsider D323 = <* C537 , C538 *> as (Element of ( 2 -tuples_on ( NAT ) )) by FINSEQ_2:101;
thus L2197: ( ( 2 proj 1 ) . <* C537 , C538 *> ) = ( D323 . 1 ) by L627
.= C537 by FINSEQ_1:44;
end;
L2198: (for B378 being (Element of ( NAT )) holds ( ( 1 succ 1 ) . <* B378 *> ) = H10(B378))
proof
let C539 being (Element of ( NAT ));
reconsider D324 = <* C539 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
thus L2199: ( ( 1 succ 1 ) . <* C539 *> ) = ( ( D324 /. 1 ) + 1 ) by L533
.= ( C539 + 1 ) by FINSEQ_4:16;
end;
L2200: (for B379 , B380 being (Element of ( NAT )) holds ( ( ( 1 succ 1 ) * <: <* ( 2 proj 1 ) *> :> ) . <* B379 , B380 *> ) = H10(H9(B379 , B380))) from Primrec1(L2198 , L2196);
L2201: (for B381 , B382 being (Element of ( NAT )) holds ( ( ( 1 succ 1 ) * <: <* ( 2 proj 1 ) *> :> ) . <* B381 , B382 *> ) = H11(B381 , B382)) by L2200;
L2202: (for B383 , B384 being (Element of ( NAT )) holds ( ( 2 proj 2 ) . <* B383 , B384 *> ) = H7(B383 , B384))
proof
let C540 , C541 being (Element of ( NAT ));
reconsider D325 = <* C540 , C541 *> as (Element of ( 2 -tuples_on ( NAT ) )) by FINSEQ_2:101;
thus L2203: ( ( 2 proj 2 ) . <* C540 , C541 *> ) = ( D325 . 2 ) by L627
.= C541 by FINSEQ_1:44;
end;
L2204: (for B385 , B386 being (Element of ( NAT )) holds ( ( [*] ) . <* B385 , B386 *> ) = H8(B385 , B386)) by L2110;
L2205: (for B387 , B388 being (Element of ( NAT )) holds ( D322 . <* B387 , B388 *> ) = H8(H11(B387 , B388) , H7(B387 , B388))) from Primrec2(L2204 , L2201 , L2202);
L2206: ( arity ( ( 0 ) const 1 ) ) = ( 0 ) by L527;
L2207: ( arity D322 ) = 2 by L1912;
L2208:
now
let C542 being (Element of ( NAT ));
reconsider D326 = ( C542 ! ) as (Element of ( NAT ));
assume L2209: S31[ C542 ];
L2210: ( ( [!] ) . <* ( C542 + 1 ) *> ) = ( D322 . <* C542 , D326 *> ) by L2209 , L2207 , L2206 , L2011
.= ( ( C542 + 1 ) * D326 ) by L2205
.= ( ( C542 + 1 ) ! ) by NEWTON:15;
thus L2211: S31[ ( C542 + 1 ) ] by L2210;
end;
L2212: ( ( 0 ) -tuples_on ( NAT ) ) = { ( {} ) } by L81;
L2213: ( {} ) in ( ( 0 ) -tuples_on ( NAT ) ) by L2212 , TARSKI:def 1;
L2214: ( ( [!] ) . <* ( 0 ) *> ) = ( ( ( 0 ) const 1 ) . ( {} ) ) by L2206 , L1998
.= ( ( 0 ) ! ) by L2213 , FUNCOP_1:7 , NEWTON:12;
L2215: S31[ ( 0 ) ] by L2214;
L2216: (for B389 being (Element of ( NAT )) holds S31[ B389 ]) from NAT_1:sch 1(L2215 , L2208);
thus L2217: thesis by L2216;
end;
definition
func [^] -> 2 -ary  primitive-recursive Function equals 
( primrec (( 1 const 1 ) , ( (1,2)->(1,?,2) ( [*] ) ) , 2) );
coherence;
end;
theorem
L2219: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds ( ( [^] ) . <* R1 , R2 *> ) = ( R1 |^ R2 )))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
defpred S32[ (Element of ( NAT )) ] means ( ( [^] ) . <* R1 , $1 *> ) = ( R1 |^ $1 );
L2220:
now
let C543 being (Element of ( NAT ));
reconsider D327 = ( R1 |^ C543 ) as (Element of ( NAT ));
assume L2221: S32[ C543 ];
L2222: ( ( [^] ) . <* R1 , ( C543 + 1 ) *> ) = ( ( (1,2)->(1,?,2) ( [*] ) ) . <* R1 , C543 , D327 *> ) by L2221 , L2005
.= ( ( [*] ) . <* R1 , D327 *> ) by L2070
.= ( R1 * D327 ) by L2110
.= ( R1 |^ ( C543 + 1 ) ) by NEWTON:6;
thus L2223: S32[ ( C543 + 1 ) ] by L2222;
end;
reconsider D328 = <* R1 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:131;
L2224: ( ( [^] ) . <* R1 , ( 0 ) *> ) = ( ( 1 const 1 ) . D328 ) by L1992
.= 1 by FUNCOP_1:7
.= ( R1 |^ ( 0 ) ) by NEWTON:4;
L2225: S32[ ( 0 ) ] by L2224;
L2226: (for B390 being (Element of ( NAT )) holds S32[ B390 ]) from NAT_1:sch 1(L2225 , L2220);
thus L2227: thesis by L2226;
end;
definition
func [pred] -> 1 -ary  primitive-recursive Function equals 
( primrec (( ( 0 ) const ( 0 ) ) , ( 2 proj 1 ) , 1) );
coherence;
end;
theorem
L2229: (for R1 being (Element of ( NAT )) holds (( ( [pred] ) . <* ( 0 ) *> ) = ( 0 ) & ( ( [pred] ) . <* ( R1 + 1 ) *> ) = R1))
proof
let R1 being (Element of ( NAT ));
L2230: ( ( 0 ) -tuples_on ( NAT ) ) = { ( {} ) } by L81;
L2231: ( {} ) in ( ( 0 ) -tuples_on ( NAT ) ) by L2230 , TARSKI:def 1;
defpred S33[ (Element of ( NAT )) ] means ( ( [pred] ) . <* ( $1 + 1 ) *> ) = $1;
reconsider D329 = <* ( 0 ) , ( 0 ) *> as (Element of ( 2 -tuples_on ( NAT ) )) by FINSEQ_2:101;
L2232: ( arity ( ( 0 ) const ( 0 ) ) ) = ( 0 ) by L527;
L2233: ( arity ( 2 proj 1 ) ) = 2 by L621;
L2234:
now
let C544 being (Element of ( NAT ));
reconsider D330 = <* ( C544 + 1 ) , C544 *> as (Element of ( 2 -tuples_on ( NAT ) )) by FINSEQ_2:101;
assume L2235: S33[ C544 ];
L2236: ( ( [pred] ) . <* ( ( C544 + 1 ) + 1 ) *> ) = ( ( 2 proj 1 ) . D330 ) by L2235 , L2232 , L2233 , L2011
.= ( <* ( C544 + 1 ) , C544 *> . 1 ) by L627
.= ( C544 + 1 ) by FINSEQ_1:44;
thus L2237: S33[ ( C544 + 1 ) ] by L2236;
end;
thus L2238: ( ( [pred] ) . <* ( 0 ) *> ) = ( ( ( 0 ) const ( 0 ) ) . ( {} ) ) by L2232 , L1998
.= ( 0 ) by L2231 , FUNCOP_1:7;
L2239: ( ( [pred] ) . <* ( ( 0 ) + 1 ) *> ) = ( ( 2 proj 1 ) . D329 ) by L2238 , L2232 , L2233 , L2011
.= ( <* ( 0 ) , ( 0 ) *> . 1 ) by L627
.= ( 0 ) by FINSEQ_1:44;
L2240: S33[ ( 0 ) ] by L2239;
L2241: (for R1 being (Element of ( NAT )) holds S33[ R1 ]) from NAT_1:sch 1(L2240 , L2234);
thus L2242: thesis by L2241;
end;
definition
func [-] -> 2 -ary  primitive-recursive Function equals 
( primrec (( 1 proj 1 ) , ( (1,2)->(1,?,2) ( ( [pred] ) * <: <* ( 2 proj 2 ) *> :> ) ) , 2) );
coherence;
end;
theorem
L2244: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds ( ( [-] ) . <* R1 , R2 *> ) = ( R1 -' R2 )))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
set D331 = <* ( 2 proj 2 ) *>;
set D332 = ( ( [pred] ) * <: D331 :> );
L2245: ( rng D331 ) c= ( PrimRec )
proof
let C545 being set;
assume L2246: C545 in ( rng D331 );
L2247: C545 in { ( 2 proj 2 ) } by L2246 , FINSEQ_1:39;
L2248: C545 = ( 2 proj 2 ) by L2247 , TARSKI:def 1;
thus L2249: thesis by L2248 , L1510;
end;
reconsider D333 = D331 as  with_the_same_arity (FinSequence of ( PrimRec )) by L2245 , FINSEQ_1:def 4;
defpred S34[ (Element of ( NAT )) ] means ( ( [-] ) . <* R1 , $1 *> ) = ( R1 -' $1 );
L2250: (for R1 being (Element of ( NAT )) holds (for R2 being (Element of ( NAT )) holds (( D332 . <* R1 , ( 0 ) *> ) = ( 0 ) & ( D332 . <* R1 , ( R2 + 1 ) *> ) = R2)))
proof
let R1 being (Element of ( NAT ));
let R2 being (Element of ( NAT ));
reconsider D334 = <* R1 , ( 0 ) *> as (Element of ( 2 -tuples_on ( NAT ) )) by FINSEQ_2:101;
reconsider D335 = <* R1 , ( R2 + 1 ) *> as (Element of ( 2 -tuples_on ( NAT ) )) by FINSEQ_2:101;
L2251: ( dom ( 2 proj 2 ) ) = ( 2 -tuples_on ( NAT ) ) by L596;
L2252: ( dom <: D333 :> ) = ( dom ( 2 proj 2 ) ) by FINSEQ_3:141;
thus L2253: ( D332 . <* R1 , ( 0 ) *> ) = ( ( [pred] ) . ( <: D333 :> . D334 ) ) by L2252 , L2251 , FUNCT_1:13
.= ( ( [pred] ) . <* ( ( 2 proj 2 ) . D334 ) *> ) by L2251 , FINSEQ_3:141
.= ( ( [pred] ) . <* ( D334 . 2 ) *> ) by L627
.= ( 0 ) by L2229 , FINSEQ_1:44;
thus L2254: ( D332 . <* R1 , ( R2 + 1 ) *> ) = ( ( [pred] ) . ( <: D333 :> . D335 ) ) by L2252 , L2251 , FUNCT_1:13
.= ( ( [pred] ) . <* ( ( 2 proj 2 ) . D335 ) *> ) by L2251 , FINSEQ_3:141
.= ( ( [pred] ) . <* ( D335 . 2 ) *> ) by L627
.= ( ( [pred] ) . <* ( R2 + 1 ) *> ) by FINSEQ_1:44
.= R2 by L2229;
end;
L2255:
now
let R2 being (Element of ( NAT ));
assume L2256: S34[ R2 ];
L2257:
now
per cases  by NAT_1:6;
suppose L2258: ( R1 -' R2 ) = ( 0 );

L2259: R1 <= R2 by L2258 , NAT_D:36;
L2260: R1 < ( R2 + 1 ) by L2259 , NAT_1:13;
L2261: ( R1 - ( R2 + 1 ) ) < ( 0 ) by L2260 , XREAL_1:49;
thus L2262: ( D332 . <* R1 , ( R1 -' R2 ) *> ) = ( 0 ) by L2250 , L2258
.= ( R1 -' ( R2 + 1 ) ) by L2261 , XREAL_0:def 2;
end;
suppose L2263: (ex B391 being Nat st ( R1 -' R2 ) = ( B391 + 1 ));

consider C546 being Nat such that L2264: ( R1 -' R2 ) = ( C546 + 1 ) by L2263;
reconsider D336 = C546 as (Element of ( NAT )) by ORDINAL1:def 12;
L2265: ( R1 - R2 ) = ( D336 + 1 ) by L2264 , XREAL_0:def 2;
L2266: ( R1 - ( R2 + 1 ) ) = D336 by L2265;
thus L2267: ( D332 . <* R1 , ( R1 -' R2 ) *> ) = D336 by L2250 , L2264
.= ( R1 -' ( R2 + 1 ) ) by L2266 , XREAL_0:def 2;
end;
end;
L2269: ( ( [-] ) . <* R1 , ( R2 + 1 ) *> ) = ( ( (1,2)->(1,?,2) D332 ) . <* R1 , R2 , ( ( [-] ) . <* R1 , R2 *> ) *> ) by L2005
.= ( R1 -' ( R2 + 1 ) ) by L2256 , L2257 , L2070;
thus L2270: S34[ ( R2 + 1 ) ] by L2269;
end;
reconsider D337 = <* R1 *> as (Element of ( 1 -tuples_on ( NAT ) )) by FINSEQ_2:98;
L2271: ( ( [-] ) . <* R1 , ( 0 ) *> ) = ( ( 1 proj 1 ) . <* R1 *> ) by L1992
.= ( D337 . 1 ) by L627
.= R1 by FINSEQ_1:40
.= ( ( R1 + ( 0 ) ) -' ( 0 ) ) by NAT_D:34
.= ( R1 -' ( 0 ) );
L2272: S34[ ( 0 ) ] by L2271;
L2273: (for R2 being (Element of ( NAT )) holds S34[ R2 ]) from NAT_1:sch 1(L2272 , L2255);
thus L2274: thesis by L2273;
end;
