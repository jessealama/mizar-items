:: Weighted and Labeled Graphs
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSEQ_1, SUBSET_1, RELAT_1, FUNCT_1, XXREAL_0, TARSKI,
      ORDINAL4, ARYTM_3, CARD_1, CARD_3, REAL_1, XBOOLE_0, NAT_1, ARYTM_1,
      GLIB_000, PBOOLE, PARTFUN1, FINSET_1, ZFMISC_1, RELAT_2, GLIB_002,
      VALUED_0, GRAPH_5, XREAL_0, ORDINAL1, FUNCOP_1, TREES_1, GLIB_001,
      FUNCT_4, FINSEQ_5, GLIB_003;
 notations TARSKI, XBOOLE_0, CARD_1, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0,
      XREAL_0, DOMAIN_1, REAL_1, RELAT_1, PARTFUN1, FUNCT_1, PBOOLE, RELSET_1,
      FUNCT_2, VALUED_0, SEQ_1, GRAPH_5, RVSUM_1, FINSEQ_5, ORDINAL1, FINSEQ_1,
      FINSET_1, NAT_1, FUNCOP_1, FUNCT_4, GLIB_000, GLIB_001, GLIB_002,
      RECDEF_1;
 constructors DOMAIN_1, BINOP_2, FINSOP_1, RVSUM_1, FINSEQ_5, GRAPH_5,
      GLIB_001, GLIB_002, SEQ_1, RECDEF_1, RELSET_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, GLIB_000, GRAPH_2, GLIB_002,
      INT_1, VALUED_0, CARD_1, FUNCT_2, PARTFUN1, RELSET_1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions GLIB_000, FUNCOP_1, RVSUM_1;
 theorems CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_5,
      FINSET_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, GLIB_002,
      GRAPH_2, GRAPH_5, INT_1, NAT_1, POLYNOM3, RELAT_1, RELSET_1, RVSUM_1,
      TARSKI, XBOOLE_0, XBOOLE_1, XREAL_0, ZFMISC_1, XREAL_1, XXREAL_0,
      ENUMSET1, ORDERS_1, ORDINAL1, FINSOP_1, VALUED_0, PARTFUN1, XTUPLE_0;
 schemes NAT_1, FINSEQ_1, FUNCT_1;

begin
definition
let C1 being set;
let C2 being (FinSequence of C1);
let C3 being (Subset of C2);
redefine func Seq C3 -> (FinSequence of C1);

correctness
proof
L1:
now
let C4 being set;
assume L2: C4 in ( rng ( Seq C3 ) );
consider C5 being set such that L3: C5 in ( dom ( Seq C3 ) ) and L4: ( ( Seq C3 ) . C5 ) = C4 by L2 , FUNCT_1:def 3;
reconsider D1 = C5 as (Element of ( NAT )) by L3;
L5: (ex B1 being (Element of ( NAT )) st (B1 in ( dom C2 ) & D1 <= B1 & C4 = ( C2 . B1 ))) by L3 , L4 , GLIB_001:4;
L6: C4 in ( rng C2 ) by L5 , FUNCT_1:def 3;
thus L7: C4 in C1 by L6;
end;
L8: ( rng ( Seq C3 ) ) c= C1 by L1 , TARSKI:def 3;
thus L9: thesis by L8 , FINSEQ_1:def 4;
end;
end;
theorem
L11: (for B2 , B3 , B4 , B5 , B6 , B7 , B8 , B9 , B10 , B11 being set holds (for B12 being FinSequence holds (B12 = ( ( ( ( ( ( ( ( ( <* B2 *> ^ <* B3 *> ) ^ <* B4 *> ) ^ <* B5 *> ) ^ <* B6 *> ) ^ <* B7 *> ) ^ <* B8 *> ) ^ <* B9 *> ) ^ <* B10 *> ) ^ <* B11 *> ) implies (( len B12 ) = 10 & ( B12 . 1 ) = B2 & ( B12 . 2 ) = B3 & ( B12 . 3 ) = B4 & ( B12 . 4 ) = B5 & ( B12 . 5 ) = B6 & ( B12 . 6 ) = B7 & ( B12 . 7 ) = B8 & ( B12 . 8 ) = B9 & ( B12 . 9 ) = B10 & ( B12 . 10 ) = B11))))
proof
let C6 , C7 , C8 , C9 , C10 , C11 , C12 , C13 , C14 , C15 being set;
let C16 being FinSequence;
set D2 = ( ( ( ( ( ( ( ( <* C6 *> ^ <* C7 *> ) ^ <* C8 *> ) ^ <* C9 *> ) ^ <* C10 *> ) ^ <* C11 *> ) ^ <* C12 *> ) ^ <* C13 *> ) ^ <* C14 *> );
L12: (( D2 . 1 ) = C6 & ( D2 . 2 ) = C7) by FINSEQ_1:71;
L13: (( D2 . 5 ) = C10 & ( D2 . 6 ) = C11) by FINSEQ_1:71;
L14: (( D2 . 7 ) = C12 & ( D2 . 8 ) = C13) by FINSEQ_1:71;
L15: ( len D2 ) = 9 by FINSEQ_1:71;
L16: ( dom D2 ) = ( Seg 9 ) by L15 , FINSEQ_1:def 3;
L17: (3 in ( dom D2 ) & 4 in ( dom D2 )) by L16 , FINSEQ_1:1;
L18: (( D2 . 9 ) = C14 & 9 in ( dom D2 )) by L16 , FINSEQ_1:1 , FINSEQ_1:71;
assume L19: C16 = ( ( ( ( ( ( ( ( ( <* C6 *> ^ <* C7 *> ) ^ <* C8 *> ) ^ <* C9 *> ) ^ <* C10 *> ) ^ <* C11 *> ) ^ <* C12 *> ) ^ <* C13 *> ) ^ <* C14 *> ) ^ <* C15 *> );
thus L20: ( len C16 ) = ( ( len D2 ) + ( len <* C15 *> ) ) by L19 , FINSEQ_1:22
.= ( 9 + 1 ) by L15 , FINSEQ_1:40
.= 10;
L21: (( D2 . 3 ) = C8 & ( D2 . 4 ) = C9) by FINSEQ_1:71;
L22: (7 in ( dom D2 ) & 8 in ( dom D2 )) by L16 , FINSEQ_1:1;
L23: (5 in ( dom D2 ) & 6 in ( dom D2 )) by L16 , FINSEQ_1:1;
L24: (1 in ( dom D2 ) & 2 in ( dom D2 )) by L16 , FINSEQ_1:1;
thus L25: (( C16 . 1 ) = C6 & ( C16 . 2 ) = C7 & ( C16 . 3 ) = C8 & ( C16 . 4 ) = C9 & ( C16 . 5 ) = C10 & ( C16 . 6 ) = C11 & ( C16 . 7 ) = C12 & ( C16 . 8 ) = C13 & ( C16 . 9 ) = C14) by L24 , L19 , L12 , L21 , L13 , L14 , L17 , L23 , L22 , L18 , FINSEQ_1:def 7;
thus L26: ( C16 . 10 ) = ( C16 . ( ( len D2 ) + 1 ) ) by L15
.= C15 by L19 , FINSEQ_1:42;
end;
theorem
L27: (for B13 being (FinSequence of ( REAL )) holds (for B14 being (Subset of B13) holds ((for B15 being (Element of ( NAT )) holds (B15 in ( dom B13 ) implies ( 0 ) <= ( B13 . B15 ))) implies ( Sum ( Seq B14 ) ) <= ( Sum B13 ))))
proof
let C17 being (FinSequence of ( REAL ));
let C18 being (Subset of C17);
defpred S1[ (Element of ( NAT )) ] means (for B16 being (FinSequence of ( REAL )) holds (for B17 being (Subset of B16) holds (((for B18 being (Element of ( NAT )) holds (B18 in ( dom B16 ) implies ( 0 ) <= ( B16 . B18 ))) & ( len ( Seq B17 ) ) = $1) implies ( Sum ( Seq B17 ) ) <= ( Sum B16 ))));
assume L28: (for B19 being (Element of ( NAT )) holds (B19 in ( dom C17 ) implies ( 0 ) <= ( C17 . B19 )));
L29: ( len ( Seq C18 ) ) = ( len ( Seq C18 ) );
L30:
now
let C19 being (Element of ( NAT ));
assume L31: S1[ C19 ];
let C20 being (FinSequence of ( REAL ));
let C21 being (Subset of C20);
assume that
L32: (for B20 being (Element of ( NAT )) holds (B20 in ( dom C20 ) implies ( 0 ) <= ( C20 . B20 )))
and
L33: ( len ( Seq C21 ) ) = ( C19 + 1 );
consider C22 being (FinSequence of ( REAL )), C23 being Real such that L34: ( Seq C21 ) = ( C22 ^ <* C23 *> ) by L33 , FINSEQ_2:19;
L35: ( card C21 ) = ( C19 + 1 ) by L33 , GLIB_001:5;
L36: ( dom C21 ) <> ( {} ) by L35 , CARD_1:27 , RELAT_1:41;
consider C24 being set such that L37: C24 in ( dom C21 ) by L36 , XBOOLE_0:def 1;
L38: ( dom C21 ) c= ( dom C20 ) by GRAPH_2:25;
L39: C24 in ( dom C20 ) by L38 , L37;
defpred S2[ Nat ] means $1 in ( dom C21 );
consider C25 being Nat such that L40: ( dom C21 ) c= ( Seg C25 ) by FINSEQ_1:def 12;
L41: (for B21 being Nat holds (S2[ B21 ] implies B21 <= C25)) by L40 , FINSEQ_1:1;
reconsider D3 = C24 as (Element of ( NAT )) by L39;
L42: D3 in ( dom C21 ) by L37;
L43: (ex B22 being Nat st S2[ B22 ]) by L42;
consider C26 being Nat such that L44: (S2[ C26 ] & (for B23 being Nat holds (S2[ B23 ] implies B23 <= C26))) from NAT_1:sch 6(L41 , L43);
set D4 = ( C20 . C26 );
L45: ( len ( Seq C21 ) ) = ( ( len C22 ) + ( len <* C23 *> ) ) by L34 , FINSEQ_1:22;
L46: ( C19 + 1 ) = ( ( len C22 ) + 1 ) by L45 , L33 , FINSEQ_1:39;
L47:
now
set D5 = ( Sgm ( dom C21 ) );
L48: 1 <= ( C19 + 1 ) by NAT_1:12;
L49: ( len ( Seq C21 ) ) in ( dom ( Seq C21 ) ) by L48 , L33 , FINSEQ_3:25;
L50: ( len ( Seq C21 ) ) = ( card C21 ) by GLIB_001:5
.= ( card ( dom C21 ) ) by CARD_1:62
.= ( len ( Sgm ( dom C21 ) ) ) by L40 , FINSEQ_3:39;
L51:
now
set D6 = ( D5 . ( len D5 ) );
assume L52: ( D5 . ( len ( Seq C21 ) ) ) <> C26;
L53: 1 <= ( len D5 ) by L33 , L50 , NAT_1:12;
L54: ( len D5 ) in ( dom D5 ) by L53 , FINSEQ_3:25;
L55: D6 in ( rng D5 ) by L54 , FUNCT_1:def 3;
reconsider D7 = D6 as (Element of ( NAT ));
L56: ( rng D5 ) = ( dom C21 ) by L40 , FINSEQ_1:def 13;
consider C27 being set such that L57: C27 in ( dom D5 ) and L58: ( D5 . C27 ) = C26 by L56 , L44 , FUNCT_1:def 3;
reconsider D8 = C27 as (Element of ( NAT )) by L57;
L59: D8 <= ( len D5 ) by L57 , FINSEQ_3:25;
L60: D8 < ( len D5 ) by L59 , L50 , L52 , L58 , XXREAL_0:1;
L61: 1 <= D8 by L57 , FINSEQ_3:25;
L62: C26 < D7 by L61 , L40 , L58 , L60 , FINSEQ_1:def 13;
thus L63: contradiction by L62 , L44 , L56 , L55;
end;
L64: (( ( Seq C21 ) . ( len ( Seq C21 ) ) ) = C23 & ( Seq C21 ) = ( C21 * ( Sgm ( dom C21 ) ) )) by L33 , L34 , L46 , FINSEQ_1:42 , FINSEQ_1:def 14;
L65: ( C21 . ( ( Sgm ( dom C21 ) ) . ( len ( Seq C21 ) ) ) ) = C23 by L64 , L49 , FUNCT_1:12;
L66: [ C26 , C23 ] in C21 by L65 , L44 , L51 , FUNCT_1:1;
thus L67: D4 = C23 by L66 , FUNCT_1:1;
end;
L68: ( Sum ( Seq C21 ) ) = ( D4 + ( Sum C22 ) ) by L47 , L34 , RVSUM_1:74;
L69: C26 <= ( len C20 ) by L38 , L44 , FINSEQ_3:25;
consider C28 being Nat such that L70: ( C26 + C28 ) = ( len C20 ) by L69 , NAT_1:10;
L71: 1 <= C26 by L38 , L44 , FINSEQ_3:25;
reconsider D9 = ( C26 - 1 ) as (Element of ( NAT )) by L71 , INT_1:5;
set D10 = ( C21 | ( Seg D9 ) );
reconsider D11 = D10 as (Subset of C20) by GRAPH_2:27;
consider C29 , C30 being (FinSequence of ( REAL )) such that L72: ( len C29 ) = C26 and L73: ( len C30 ) = C28 and L74: C20 = ( C29 ^ C30 ) by L70 , FINSEQ_2:23;
L75: ( D9 + 1 ) = C26;
consider C31 , C32 being (FinSequence of ( REAL )) such that L76: ( len C31 ) = D9 and L77: ( len C32 ) = 1 and L78: C29 = ( C31 ^ C32 ) by L75 , L72 , FINSEQ_2:23;
L79: C26 in ( dom C29 ) by L71 , L72 , FINSEQ_3:25;
L80: D4 = ( C29 . C26 ) by L79 , L74 , FINSEQ_1:def 7;
L81:
now
let C33 being set;
assume L82: C33 in D11;
consider C34 , C35 being set such that L83: C33 = [ C34 , C35 ] by L82 , RELAT_1:def 1;
L84: C34 in ( Seg D9 ) by L82 , L83 , RELAT_1:def 11;
reconsider D12 = C34 as (Element of ( NAT )) by L84;
L85: D12 <= D9 by L84 , FINSEQ_1:1;
L86: 1 <= D12 by L84 , FINSEQ_1:1;
L87: D12 in ( dom C31 ) by L86 , L76 , L85 , FINSEQ_3:25;
L88: C35 = ( C20 . D12 ) by L82 , L83 , FUNCT_1:1;
L89: ( D12 + ( 0 ) ) <= C26 by L75 , L85 , XREAL_1:7;
L90: D12 in ( dom C29 ) by L89 , L72 , L86 , FINSEQ_3:25;
L91: C35 = ( C29 . D12 ) by L90 , L74 , L88 , FINSEQ_1:def 7;
L92: C35 = ( C31 . D12 ) by L91 , L78 , L87 , FINSEQ_1:def 7;
thus L93: C33 in C31 by L92 , L83 , L87 , FUNCT_1:1;
end;
reconsider D13 = D11 as (Subset of C31) by L81 , TARSKI:def 3;
L94:
now
L95:
now
let C36 being set;
assume L96: C36 in { [ C26 , D4 ] };
L97: C36 = [ C26 , D4 ] by L96 , TARSKI:def 1;
L98: [ C26 , ( C21 . C26 ) ] in C21 by L44 , FUNCT_1:1;
thus L99: C36 in C21 by L98 , L97 , FUNCT_1:1;
end;
L100:
now
L101: [ C26 , D4 ] in { [ C26 , D4 ] } by TARSKI:def 1;
L102: [ C26 , D4 ] in C21 by L101 , L95;
let C37 being set;
thus L103:now
assume L104: C37 in D13;
consider C38 , C39 being set such that L105: C37 = [ C38 , C39 ] by L104 , RELAT_1:def 1;
L106: C38 in ( Seg D9 ) by L104 , L105 , RELAT_1:def 11;
reconsider D14 = C38 as (Element of ( NAT )) by L106;
L107: D14 <= D9 by L106 , FINSEQ_1:1;
L108: D14 < C26 by L107 , L75 , NAT_1:13;
L109: [ D14 , C39 ] <> [ C26 , D4 ] by L108 , XTUPLE_0:1;
L110: (not C37 in { [ C26 , D4 ] }) by L109 , L105 , TARSKI:def 1;
L111: C37 in C21 by L104 , L105 , RELAT_1:def 11;
thus L112: C37 in ( C21 \ { [ C26 , D4 ] } ) by L111 , L110 , XBOOLE_0:def 5;
end;
assume L113: C37 in ( C21 \ { [ C26 , D4 ] } );
consider C40 , C41 being set such that L114: C37 = [ C40 , C41 ] by L113 , RELAT_1:def 1;
L115: C40 in ( dom C20 ) by L113 , L114 , FUNCT_1:1;
L116: C37 in C21 by L113 , XBOOLE_0:def 5;
L117: C40 in ( dom C21 ) by L116 , L114 , FUNCT_1:1;
reconsider D15 = C40 as (Element of ( NAT )) by L115;
L118: D15 <= C26 by L44 , L117;
L119: (not C37 in { [ C26 , D4 ] }) by L113 , XBOOLE_0:def 5;
L120: (D15 <> C26 or C41 <> D4) by L119 , L114 , TARSKI:def 1;
L121: D15 <> C26 by L120 , L113 , L114 , L102 , FUNCT_1:def 1;
L122: D15 < C26 by L121 , L118 , XXREAL_0:1;
L123: ( D15 + 1 ) <= C26 by L122 , NAT_1:13;
L124: ( ( D15 + 1 ) - 1 ) <= ( C26 - 1 ) by L123 , XREAL_1:13;
L125: 1 <= D15 by L115 , FINSEQ_3:25;
L126: D15 in ( Seg D9 ) by L125 , L124 , FINSEQ_1:1;
thus L127: C37 in D13 by L126 , L114 , L116 , RELAT_1:def 11;
end;
L128: D13 = ( C21 \ { [ C26 , D4 ] } ) by L100 , TARSKI:1;
L129:
now
let C42 being set;
thus L130:now
assume L131: C42 in ( dom C21 );
L132: [ C42 , ( C21 . C42 ) ] in C21 by L131 , FUNCT_1:1;
L133: C42 in ( dom C20 ) by L132 , FUNCT_1:1;
reconsider D16 = C42 as (Element of ( NAT )) by L133;
L134: 1 <= D16 by L133 , FINSEQ_3:25;
L135: D16 <= C26 by L44 , L131;
L136:
now
assume L137: (not C42 in { C26 });
L138: C42 <> C26 by L137 , TARSKI:def 1;
L139: D16 < ( D9 + 1 ) by L138 , L135 , XXREAL_0:1;
L140: D16 <= D9 by L139 , NAT_1:13;
L141: D16 in ( Seg D9 ) by L140 , L134 , FINSEQ_1:1;
L142: [ C42 , ( C21 . C42 ) ] in D13 by L141 , L132 , RELAT_1:def 11;
thus L143: C42 in ( dom D13 ) by L142 , FUNCT_1:1;
end;
thus L144: C42 in ( ( dom D13 ) \/ { C26 } ) by L136 , XBOOLE_0:def 3;
end;
assume L145: C42 in ( ( dom D13 ) \/ { C26 } );
L146:
now
per cases  by L145 , XBOOLE_0:def 3;
suppose L147: C42 in ( dom D13 );

L148: [ C42 , ( D13 . C42 ) ] in D13 by L147 , FUNCT_1:1;
L149: [ C42 , ( D13 . C42 ) ] in C21 by L148 , RELAT_1:def 11;
thus L150: C42 in ( dom C21 ) by L149 , FUNCT_1:1;
end;
suppose L151: C42 in { C26 };

thus L152: C42 in ( dom C21 ) by L151 , L44 , TARSKI:def 1;
end;
end;
thus L154: C42 in ( dom C21 ) by L146;
end;
L155: ( dom C21 ) = ( ( dom D13 ) \/ { C26 } ) by L129 , TARSKI:1;
L156: ( card C21 ) = ( C19 + 1 ) by L33 , GLIB_001:5;
L157:
now
let C43 , C44 being (Element of ( NAT ));
assume that
L158: C43 in ( dom D13 )
and
L159: C44 in { C26 };
L160: [ C43 , ( D13 . C43 ) ] in D13 by L158 , FUNCT_1:1;
L161: C43 in ( Seg D9 ) by L160 , RELAT_1:def 11;
L162: C43 <= D9 by L161 , FINSEQ_1:1;
L163: C44 = C26 by L159 , TARSKI:def 1;
thus L164: C43 < C44 by L163 , L75 , L162 , NAT_1:13;
end;
L165: { [ C26 , D4 ] } c= C21 by L95 , TARSKI:def 3;
L166: ( card D13 ) = ( ( card C21 ) - ( card { [ C26 , D4 ] } ) ) by L165 , L128 , CARD_2:44
.= ( ( C19 + 1 ) - 1 ) by L156 , CARD_1:30
.= C19;
thus L167: ( len C22 ) = ( len ( Seq D13 ) ) by L166 , L46 , GLIB_001:5;
let C45 being Nat;
set D17 = ( ( Sgm ( dom C21 ) ) . C45 );
set D18 = ( ( Sgm ( dom D13 ) ) . C45 );
assume that
L168: 1 <= C45
and
L169: C45 <= ( len C22 );
L170: C45 in ( dom C22 ) by L168 , L169 , FINSEQ_3:25;
L171: ( C22 . C45 ) = ( ( Seq C21 ) . C45 ) by L170 , L34 , FINSEQ_1:def 7;
L172: (ex B24 being Nat st ( dom D13 ) c= ( Seg B24 )) by FINSEQ_1:def 12;
L173: ( len ( Sgm ( dom D13 ) ) ) = ( card ( dom D13 ) ) by L172 , FINSEQ_3:39
.= C19 by L166 , CARD_1:62;
L174: C45 in ( dom ( Sgm ( dom D13 ) ) ) by L173 , L46 , L168 , L169 , FINSEQ_3:25;
L175: D18 in ( rng ( Sgm ( dom D13 ) ) ) by L174 , FUNCT_1:def 3;
L176: D18 in ( dom D13 ) by L175 , L172 , FINSEQ_1:def 13;
L177: [ D18 , ( D13 . D18 ) ] in D13 by L176 , FUNCT_1:1;
L178: [ D18 , ( D13 . D18 ) ] in C21 by L177 , RELAT_1:def 11;
L179: ( C21 . D18 ) = ( D13 . D18 ) by L178 , FUNCT_1:1;
L180: C45 <= ( C19 + 1 ) by L33 , L45 , L169 , NAT_1:12;
L181: C45 in ( dom ( Seq C21 ) ) by L180 , L33 , L168 , FINSEQ_3:25;
L182: ( Seq C21 ) = ( C21 * ( Sgm ( dom C21 ) ) ) by FINSEQ_1:def 14;
L183: ( C22 . C45 ) = ( C21 . D17 ) by L182 , L171 , L181 , FUNCT_1:12;
L184: ( Seq D13 ) = ( D13 * ( Sgm ( dom D13 ) ) ) by FINSEQ_1:def 14;
L185: ( len ( Seq D13 ) ) = ( card D13 ) by GLIB_001:5;
L186: C45 in ( dom ( Seq D13 ) ) by L185 , L46 , L166 , L168 , L169 , FINSEQ_3:25;
L187: ( ( Seq D13 ) . C45 ) = ( D13 . D18 ) by L186 , L184 , FUNCT_1:12;
L188:
now
let C46 being set;
assume L189: C46 in { C26 };
L190: C46 = C26 by L189 , TARSKI:def 1;
thus L191: C46 in ( Seg ( len C20 ) ) by L190 , L71 , L69 , FINSEQ_1:1;
end;
L192: { C26 } c= ( Seg ( len C20 ) ) by L188 , TARSKI:def 3;
L193: ( Sgm ( dom C21 ) ) = ( ( Sgm ( dom D13 ) ) ^ ( Sgm { C26 } ) ) by L192 , L172 , L155 , L157 , FINSEQ_3:42;
thus L194: ( C22 . C45 ) = ( ( Seq D13 ) . C45 ) by L193 , L183 , L187 , L174 , L179 , FINSEQ_1:def 7;
end;
L195: C22 = ( Seq D13 ) by L94 , FINSEQ_1:14;
L196:
now
L197: ( dom C29 ) c= ( dom C20 ) by L74 , FINSEQ_1:26;
let C47 being (Element of ( NAT ));
L198: ( dom C31 ) c= ( dom C29 ) by L78 , FINSEQ_1:26;
assume L199: C47 in ( dom C31 );
L200: ( C31 . C47 ) = ( C29 . C47 ) by L199 , L78 , FINSEQ_1:def 7;
L201: ( C31 . C47 ) = ( C20 . C47 ) by L200 , L74 , L199 , L198 , FINSEQ_1:def 7;
L202: C47 in ( dom C29 ) by L199 , L198;
thus L203: ( 0 ) <= ( C31 . C47 ) by L202 , L32 , L201 , L197;
end;
L204: ( Sum C22 ) <= ( Sum C31 ) by L196 , L31 , L46 , L195;
L205: ( ( Sum ( Seq C21 ) ) + ( Sum C22 ) ) <= ( ( D4 + ( Sum C22 ) ) + ( Sum C31 ) ) by L204 , L68 , XREAL_1:7;
L206: ( ( Sum ( Seq C21 ) ) + ( Sum C22 ) ) <= ( ( D4 + ( Sum C31 ) ) + ( Sum C22 ) ) by L205;
L207: ( Sum ( Seq C21 ) ) <= ( ( Sum C31 ) + D4 ) by L206 , XREAL_1:6;
L208:
now
let C48 being Nat;
assume L209: C48 in ( dom C30 );
L210: (( C20 . ( C26 + C48 ) ) = ( C30 . C48 ) & ( C26 + C48 ) in ( dom C20 )) by L209 , L72 , L74 , FINSEQ_1:28 , FINSEQ_1:def 7;
thus L211: ( 0 ) <= ( C30 . C48 ) by L210 , L32;
end;
L212: ( 0 ) <= ( Sum C30 ) by L208 , RVSUM_1:84;
L213: 1 in ( dom C32 ) by L77 , FINSEQ_3:25;
L214: D4 = ( C32 . 1 ) by L213 , L75 , L76 , L78 , L80 , FINSEQ_1:def 7;
L215: C32 = <* D4 *> by L214 , L77 , FINSEQ_1:40;
L216: ( Sum C20 ) = ( ( Sum C29 ) + ( Sum C30 ) ) by L74 , RVSUM_1:75
.= ( ( ( Sum C31 ) + ( Sum <* D4 *> ) ) + ( Sum C30 ) ) by L78 , L215 , RVSUM_1:75
.= ( ( ( Sum C31 ) + D4 ) + ( Sum C30 ) ) by FINSOP_1:11;
L217: ( ( ( Sum C31 ) + D4 ) + (( 0 ) qua Nat) ) <= ( Sum C20 ) by L216 , L212 , XREAL_1:7;
thus L218: ( Sum ( Seq C21 ) ) <= ( Sum C20 ) by L217 , L207 , XXREAL_0:2;
end;
L219: (for B25 being (Element of ( NAT )) holds (S1[ B25 ] implies S1[ ( B25 + 1 ) ])) by L30;
L220:
now
let C49 being (FinSequence of ( REAL ));
let C50 being (Subset of C49);
assume L221: ((for B26 being (Element of ( NAT )) holds (B26 in ( dom C49 ) implies ( 0 ) <= ( C49 . B26 ))) & ( len ( Seq C50 ) ) = ( 0 ));
L222: ((for B27 being Nat holds (B27 in ( dom C49 ) implies ( 0 ) <= ( C49 . B27 ))) & ( Seq C50 ) = ( <*> ( REAL ) )) by L221;
thus L223: ( Sum ( Seq C50 ) ) <= ( Sum C49 ) by L222 , RVSUM_1:72 , RVSUM_1:84;
end;
L224: S1[ ( 0 ) ] by L220;
L225: (for B28 being (Element of ( NAT )) holds S1[ B28 ]) from NAT_1:sch 1(L224 , L219);
thus L226: thesis by L225 , L28 , L29;
end;
begin
definition
func WeightSelector -> (Element of ( NAT )) equals 
5;
coherence;
func ELabelSelector -> (Element of ( NAT )) equals 
6;
coherence;
func VLabelSelector -> (Element of ( NAT )) equals 
7;
coherence;
end;
definition
let C51 being GraphStruct;
attr C51 is  [Weighted]
means
:L228: (( WeightSelector ) in ( dom C51 ) & ( C51 . ( WeightSelector ) ) is (ManySortedSet of ( the_Edges_of C51 )));
attr C51 is  [ELabeled]
means
:L229: (( ELabelSelector ) in ( dom C51 ) & (ex B29 being Function st (( C51 . ( ELabelSelector ) ) = B29 & ( dom B29 ) c= ( the_Edges_of C51 ))));
attr C51 is  [VLabeled]
means
:L230: (( VLabelSelector ) in ( dom C51 ) & (ex B30 being Function st (( C51 . ( VLabelSelector ) ) = B30 & ( dom B30 ) c= ( the_Vertices_of C51 ))));
end;
registration
cluster  [Graph-like]  [Weighted]  [ELabeled]  [VLabeled] for GraphStruct;
existence
proof
set D19 = { 1 };
set D20 = ( {} );
set D21 = the (Function of D20 , D19);
set D22 = the (ManySortedSet of D20);
set D23 = the (PartFunc of D20 , ( REAL ));
set D24 = the (PartFunc of D19 , ( REAL ));
set D25 = ( ( ( ( ( ( <* D19 *> ^ <* D20 *> ) ^ <* D21 *> ) ^ <* D21 *> ) ^ <* D22 *> ) ^ <* D23 *> ) ^ <* D24 *> );
L232: ( dom D24 ) c= D19;
L233: ( len D25 ) = 7 by FINSEQ_1:69;
reconsider D26 = D25 as GraphStruct;
L234: ( dom D26 ) = ( Seg 7 ) by L233 , FINSEQ_1:def 3;
L235: (( SourceSelector ) in ( dom D26 ) & ( TargetSelector ) in ( dom D26 )) by L234 , FINSEQ_1:1;
L236: (( WeightSelector ) in ( dom D26 ) & ( ELabelSelector ) in ( dom D26 )) by L234 , FINSEQ_1:1;
L237: (( D26 . ( WeightSelector ) ) = D22 & ( D26 . ( ELabelSelector ) ) = D23) by FINSEQ_1:69;
take D26;
L238: (( the_Vertices_of D26 ) = D19 & ( the_Edges_of D26 ) = D20) by FINSEQ_1:69;
L239: (( the_Source_of D26 ) = D21 & ( the_Target_of D26 ) = D21) by FINSEQ_1:69;
L240: ( VLabelSelector ) in ( dom D26 ) by L234 , FINSEQ_1:1;
L241: (( D26 . ( VLabelSelector ) ) = D24 & ( dom D23 ) c= D20) by FINSEQ_1:69;
L242: (( VertexSelector ) in ( dom D26 ) & ( EdgeSelector ) in ( dom D26 )) by L234 , FINSEQ_1:1;
thus L243: thesis by L242 , L235 , L236 , L240 , L238 , L239 , L237 , L241 , L232 , L228 , L229 , L230 , GLIB_000:def 10;
end;
end;
definition
mode WGraph
 is  [Weighted] _Graph;
mode EGraph
 is  [ELabeled] _Graph;
mode VGraph
 is  [VLabeled] _Graph;
mode WEGraph
 is  [Weighted]  [ELabeled] _Graph;
mode WVGraph
 is  [Weighted]  [VLabeled] _Graph;
mode EVGraph
 is  [ELabeled]  [VLabeled] _Graph;
mode WEVGraph
 is  [Weighted]  [ELabeled]  [VLabeled] _Graph;
end;
definition
let C52 being WGraph;
func the_Weight_of C52 -> (ManySortedSet of ( the_Edges_of C52 )) equals 
( C52 . ( WeightSelector ) );
coherence by L228;
end;
definition
let C53 being EGraph;
func the_ELabel_of C53 -> Function equals 
( C53 . ( ELabelSelector ) );
coherence
proof
L247: (ex B31 being Function st (( C53 . ( ELabelSelector ) ) = B31 & ( dom B31 ) c= ( the_Edges_of C53 ))) by L229;
thus L248: thesis by L247;
end;
end;
definition
let C54 being VGraph;
func the_VLabel_of C54 -> Function equals 
( C54 . ( VLabelSelector ) );
coherence
proof
L250: (ex B32 being Function st (( C54 . ( VLabelSelector ) ) = B32 & ( dom B32 ) c= ( the_Vertices_of C54 ))) by L230;
thus L251: thesis by L250;
end;
end;
L253: (for B33 being EGraph holds ( dom ( the_ELabel_of B33 ) ) c= ( the_Edges_of B33 ))
proof
let C55 being EGraph;
L254: (ex B34 being Function st (( C55 . ( ELabelSelector ) ) = B34 & ( dom B34 ) c= ( the_Edges_of C55 ))) by L229;
thus L255: thesis by L254;
end;
L256: (for B35 being VGraph holds ( dom ( the_VLabel_of B35 ) ) c= ( the_Vertices_of B35 ))
proof
let C56 being VGraph;
L257: (ex B36 being Function st (( C56 . ( VLabelSelector ) ) = B36 & ( dom B36 ) c= ( the_Vertices_of C56 ))) by L230;
thus L258: thesis by L257;
end;
registration
let C57 being _Graph;
let C58 being set;
cluster ( C57 .set (( WeightSelector ) , C58) ) ->  [Graph-like];
coherence
proof
L259: (not ( WeightSelector ) in ( _GraphSelectors )) by ENUMSET1:def 2;
thus L260: thesis by L259 , GLIB_000:10;
end;
cluster ( C57 .set (( ELabelSelector ) , C58) ) ->  [Graph-like];
coherence
proof
L261: (not ( ELabelSelector ) in ( _GraphSelectors )) by ENUMSET1:def 2;
thus L262: thesis by L261 , GLIB_000:10;
end;
cluster ( C57 .set (( VLabelSelector ) , C58) ) ->  [Graph-like];
coherence
proof
L263: (not ( VLabelSelector ) in ( _GraphSelectors )) by ENUMSET1:def 2;
thus L264: thesis by L263 , GLIB_000:10;
end;
end;
L266: (for B37 being _Graph holds (for B38 being set holds (( B37 .set (( WeightSelector ) , B38) ) == B37 & ( B37 .set (( ELabelSelector ) , B38) ) == B37 & ( B37 .set (( VLabelSelector ) , B38) ) == B37)))
proof
set D27 = ( _GraphSelectors );
let C59 being _Graph;
let C60 being set;
set D28 = ( C59 .set (( WeightSelector ) , C60) );
L267: (not ( WeightSelector ) in D27) by ENUMSET1:def 2;
L268: (( the_Source_of D28 ) = ( the_Source_of C59 ) & ( the_Target_of D28 ) = ( the_Target_of C59 )) by L267 , GLIB_000:10;
L269: (( the_Vertices_of D28 ) = ( the_Vertices_of C59 ) & ( the_Edges_of D28 ) = ( the_Edges_of C59 )) by L267 , GLIB_000:10;
thus L270: D28 == C59 by L269 , L268 , GLIB_000:def 34;
set D29 = ( C59 .set (( ELabelSelector ) , C60) );
L271: (not ( ELabelSelector ) in D27) by ENUMSET1:def 2;
L272: (( the_Source_of D29 ) = ( the_Source_of C59 ) & ( the_Target_of D29 ) = ( the_Target_of C59 )) by L271 , GLIB_000:10;
L273: (( the_Vertices_of D29 ) = ( the_Vertices_of C59 ) & ( the_Edges_of D29 ) = ( the_Edges_of C59 )) by L271 , GLIB_000:10;
thus L274: D29 == C59 by L273 , L272 , GLIB_000:def 34;
set D30 = ( C59 .set (( VLabelSelector ) , C60) );
L275: (not ( VLabelSelector ) in D27) by ENUMSET1:def 2;
L276: (( the_Source_of D30 ) = ( the_Source_of C59 ) & ( the_Target_of D30 ) = ( the_Target_of C59 )) by L275 , GLIB_000:10;
L277: (( the_Vertices_of D30 ) = ( the_Vertices_of C59 ) & ( the_Edges_of D30 ) = ( the_Edges_of C59 )) by L275 , GLIB_000:10;
thus L278: thesis by L277 , L276 , GLIB_000:def 34;
end;
registration
let C61 being  finite _Graph;
let C62 being set;
cluster ( C61 .set (( WeightSelector ) , C62) ) ->  finite;
coherence
proof
L279: ( C61 .set (( WeightSelector ) , C62) ) == C61 by L266;
thus L280: thesis by L279 , GLIB_000:89;
end;
cluster ( C61 .set (( ELabelSelector ) , C62) ) ->  finite;
coherence
proof
L281: ( C61 .set (( ELabelSelector ) , C62) ) == C61 by L266;
thus L282: thesis by L281 , GLIB_000:89;
end;
cluster ( C61 .set (( VLabelSelector ) , C62) ) ->  finite;
coherence
proof
L283: ( C61 .set (( VLabelSelector ) , C62) ) == C61 by L266;
thus L284: thesis by L283 , GLIB_000:89;
end;
end;
registration
let C63 being  loopless _Graph;
let C64 being set;
cluster ( C63 .set (( WeightSelector ) , C64) ) ->  loopless;
coherence
proof
L286: ( C63 .set (( WeightSelector ) , C64) ) == C63 by L266;
thus L287: thesis by L286 , GLIB_000:89;
end;
cluster ( C63 .set (( ELabelSelector ) , C64) ) ->  loopless;
coherence
proof
L288: ( C63 .set (( ELabelSelector ) , C64) ) == C63 by L266;
thus L289: thesis by L288 , GLIB_000:89;
end;
cluster ( C63 .set (( VLabelSelector ) , C64) ) ->  loopless;
coherence
proof
L290: ( C63 .set (( VLabelSelector ) , C64) ) == C63 by L266;
thus L291: thesis by L290 , GLIB_000:89;
end;
end;
registration
let C65 being  trivial _Graph;
let C66 being set;
cluster ( C65 .set (( WeightSelector ) , C66) ) ->  trivial;
coherence
proof
L293: ( C65 .set (( WeightSelector ) , C66) ) == C65 by L266;
thus L294: thesis by L293 , GLIB_000:89;
end;
cluster ( C65 .set (( ELabelSelector ) , C66) ) ->  trivial;
coherence
proof
L295: ( C65 .set (( ELabelSelector ) , C66) ) == C65 by L266;
thus L296: thesis by L295 , GLIB_000:89;
end;
cluster ( C65 .set (( VLabelSelector ) , C66) ) ->  trivial;
coherence
proof
L297: ( C65 .set (( VLabelSelector ) , C66) ) == C65 by L266;
thus L298: thesis by L297 , GLIB_000:89;
end;
end;
registration
let C67 being non  trivial _Graph;
let C68 being set;
cluster ( C67 .set (( WeightSelector ) , C68) ) -> non  trivial;
coherence
proof
L300: ( C67 .set (( WeightSelector ) , C68) ) == C67 by L266;
thus L301: thesis by L300 , GLIB_000:89;
end;
cluster ( C67 .set (( ELabelSelector ) , C68) ) -> non  trivial;
coherence
proof
L302: ( C67 .set (( ELabelSelector ) , C68) ) == C67 by L266;
thus L303: thesis by L302 , GLIB_000:89;
end;
cluster ( C67 .set (( VLabelSelector ) , C68) ) -> non  trivial;
coherence
proof
L304: ( C67 .set (( VLabelSelector ) , C68) ) == C67 by L266;
thus L305: thesis by L304 , GLIB_000:89;
end;
end;
registration
let C69 being  non-multi _Graph;
let C70 being set;
cluster ( C69 .set (( WeightSelector ) , C70) ) ->  non-multi;
coherence
proof
L307: ( C69 .set (( WeightSelector ) , C70) ) == C69 by L266;
thus L308: thesis by L307 , GLIB_000:89;
end;
cluster ( C69 .set (( ELabelSelector ) , C70) ) ->  non-multi;
coherence
proof
L309: ( C69 .set (( ELabelSelector ) , C70) ) == C69 by L266;
thus L310: thesis by L309 , GLIB_000:89;
end;
cluster ( C69 .set (( VLabelSelector ) , C70) ) ->  non-multi;
coherence
proof
L311: ( C69 .set (( VLabelSelector ) , C70) ) == C69 by L266;
thus L312: thesis by L311 , GLIB_000:89;
end;
end;
registration
let C71 being  non-Dmulti _Graph;
let C72 being set;
cluster ( C71 .set (( WeightSelector ) , C72) ) ->  non-Dmulti;
coherence
proof
L314: ( C71 .set (( WeightSelector ) , C72) ) == C71 by L266;
thus L315: thesis by L314 , GLIB_000:89;
end;
cluster ( C71 .set (( ELabelSelector ) , C72) ) ->  non-Dmulti;
coherence
proof
L316: ( C71 .set (( ELabelSelector ) , C72) ) == C71 by L266;
thus L317: thesis by L316 , GLIB_000:89;
end;
cluster ( C71 .set (( VLabelSelector ) , C72) ) ->  non-Dmulti;
coherence
proof
L318: ( C71 .set (( VLabelSelector ) , C72) ) == C71 by L266;
thus L319: thesis by L318 , GLIB_000:89;
end;
end;
registration
let C73 being  connected _Graph;
let C74 being set;
cluster ( C73 .set (( WeightSelector ) , C74) ) ->  connected;
coherence
proof
L321: ( C73 .set (( WeightSelector ) , C74) ) == C73 by L266;
thus L322: thesis by L321 , GLIB_002:8;
end;
cluster ( C73 .set (( ELabelSelector ) , C74) ) ->  connected;
coherence
proof
L323: ( C73 .set (( ELabelSelector ) , C74) ) == C73 by L266;
thus L324: thesis by L323 , GLIB_002:8;
end;
cluster ( C73 .set (( VLabelSelector ) , C74) ) ->  connected;
coherence
proof
L325: ( C73 .set (( VLabelSelector ) , C74) ) == C73 by L266;
thus L326: thesis by L325 , GLIB_002:8;
end;
end;
registration
let C75 being  acyclic _Graph;
let C76 being set;
cluster ( C75 .set (( WeightSelector ) , C76) ) ->  acyclic;
coherence
proof
L328: ( C75 .set (( WeightSelector ) , C76) ) == C75 by L266;
thus L329: thesis by L328 , GLIB_002:44;
end;
cluster ( C75 .set (( ELabelSelector ) , C76) ) ->  acyclic;
coherence
proof
L330: ( C75 .set (( ELabelSelector ) , C76) ) == C75 by L266;
thus L331: thesis by L330 , GLIB_002:44;
end;
cluster ( C75 .set (( VLabelSelector ) , C76) ) ->  acyclic;
coherence
proof
L332: ( C75 .set (( VLabelSelector ) , C76) ) == C75 by L266;
thus L333: thesis by L332 , GLIB_002:44;
end;
end;
registration
let C77 being WGraph;
let C78 being set;
cluster ( C77 .set (( ELabelSelector ) , C78) ) ->  [Weighted];
coherence
proof
set D31 = ( C77 .set (( ELabelSelector ) , C78) );
L335: (( dom C77 ) c= ( dom D31 ) & ( WeightSelector ) in ( dom C77 )) by L228 , FUNCT_4:10;
thus L336: ( WeightSelector ) in ( dom D31 ) by L335;
L337: C77 == D31 by L266;
L338: ( the_Edges_of D31 ) = ( the_Edges_of C77 ) by L337 , GLIB_000:def 34;
L339: ( D31 . ( WeightSelector ) ) = ( the_Weight_of C77 ) by GLIB_000:9;
thus L340: thesis by L339 , L338;
end;
cluster ( C77 .set (( VLabelSelector ) , C78) ) ->  [Weighted];
coherence
proof
set D32 = ( C77 .set (( VLabelSelector ) , C78) );
L341: (( dom C77 ) c= ( dom D32 ) & ( WeightSelector ) in ( dom C77 )) by L228 , FUNCT_4:10;
thus L342: ( WeightSelector ) in ( dom D32 ) by L341;
L343: C77 == D32 by L266;
L344: ( the_Edges_of D32 ) = ( the_Edges_of C77 ) by L343 , GLIB_000:def 34;
L345: ( D32 . ( WeightSelector ) ) = ( the_Weight_of C77 ) by GLIB_000:9;
thus L346: thesis by L345 , L344;
end;
end;
registration
let C79 being _Graph;
let C80 being (ManySortedSet of ( the_Edges_of C79 ));
cluster ( C79 .set (( WeightSelector ) , C80) ) ->  [Weighted];
coherence
proof
set D33 = ( C79 .set (( WeightSelector ) , C80) );
L348: (( dom D33 ) = ( ( dom C79 ) \/ { ( WeightSelector ) } ) & ( WeightSelector ) in { ( WeightSelector ) }) by GLIB_000:7 , TARSKI:def 1;
thus L349: ( WeightSelector ) in ( dom D33 ) by L348 , XBOOLE_0:def 3;
L350: C79 == D33 by L266;
L351: ( the_Edges_of C79 ) = ( the_Edges_of D33 ) by L350 , GLIB_000:def 34;
thus L352: thesis by L351 , GLIB_000:8;
end;
end;
registration
let C81 being _Graph;
let C82 being non  empty set;
let C83 being (Function of ( the_Edges_of C81 ) , C82);
cluster ( C81 .set (( WeightSelector ) , C83) ) ->  [Weighted];
coherence;
end;
registration
let C84 being EGraph;
let C85 being set;
cluster ( C84 .set (( WeightSelector ) , C85) ) ->  [ELabeled];
coherence
proof
set D34 = ( C84 .set (( WeightSelector ) , C85) );
L355: (( dom C84 ) c= ( dom D34 ) & ( ELabelSelector ) in ( dom C84 )) by L229 , FUNCT_4:10;
thus L356: ( ELabelSelector ) in ( dom D34 ) by L355;
L357: C84 == D34 by L266;
L358: ( the_Edges_of C84 ) = ( the_Edges_of D34 ) by L357 , GLIB_000:def 34;
L359: (( D34 . ( ELabelSelector ) ) = ( the_ELabel_of C84 ) & ( dom ( the_ELabel_of C84 ) ) c= ( the_Edges_of C84 )) by L253 , GLIB_000:9;
thus L360: thesis by L359 , L358;
end;
cluster ( C84 .set (( VLabelSelector ) , C85) ) ->  [ELabeled];
coherence
proof
set D35 = ( C84 .set (( VLabelSelector ) , C85) );
L361: (( dom C84 ) c= ( dom D35 ) & ( ELabelSelector ) in ( dom C84 )) by L229 , FUNCT_4:10;
thus L362: ( ELabelSelector ) in ( dom D35 ) by L361;
L363: C84 == D35 by L266;
L364: ( the_Edges_of C84 ) = ( the_Edges_of D35 ) by L363 , GLIB_000:def 34;
L365: (( D35 . ( ELabelSelector ) ) = ( the_ELabel_of C84 ) & ( dom ( the_ELabel_of C84 ) ) c= ( the_Edges_of C84 )) by L253 , GLIB_000:9;
thus L366: thesis by L365 , L364;
end;
end;
registration
let C86 being _Graph;
let C87 being set;
let C88 being (PartFunc of ( the_Edges_of C86 ) , C87);
cluster ( C86 .set (( ELabelSelector ) , C88) ) ->  [ELabeled];
coherence
proof
set D36 = ( C86 .set (( ELabelSelector ) , C88) );
L368: (( dom D36 ) = ( ( dom C86 ) \/ { ( ELabelSelector ) } ) & ( ELabelSelector ) in { ( ELabelSelector ) }) by GLIB_000:7 , TARSKI:def 1;
thus L369: ( ELabelSelector ) in ( dom D36 ) by L368 , XBOOLE_0:def 3;
L370: C86 == D36 by L266;
L371: ( the_Edges_of C86 ) = ( the_Edges_of D36 ) by L370 , GLIB_000:def 34;
L372: ( dom C88 ) c= ( the_Edges_of C86 );
thus L373: thesis by L372 , L371 , GLIB_000:8;
end;
end;
registration
let C89 being _Graph;
let C90 being (ManySortedSet of ( the_Edges_of C89 ));
cluster ( C89 .set (( ELabelSelector ) , C90) ) ->  [ELabeled];
coherence
proof
set D37 = ( C89 .set (( ELabelSelector ) , C90) );
L375: (( dom D37 ) = ( ( dom C89 ) \/ { ( ELabelSelector ) } ) & ( ELabelSelector ) in { ( ELabelSelector ) }) by GLIB_000:7 , TARSKI:def 1;
thus L376: ( ELabelSelector ) in ( dom D37 ) by L375 , XBOOLE_0:def 3;
L377: C89 == D37 by L266;
L378: ( the_Edges_of C89 ) = ( the_Edges_of D37 ) by L377 , GLIB_000:def 34;
L379: ( dom C90 ) = ( the_Edges_of C89 ) by PARTFUN1:def 2;
thus L380: thesis by L379 , L378 , GLIB_000:8;
end;
end;
registration
let C91 being VGraph;
let C92 being set;
cluster ( C91 .set (( WeightSelector ) , C92) ) ->  [VLabeled];
coherence
proof
set D38 = ( C91 .set (( WeightSelector ) , C92) );
L382: (( dom C91 ) c= ( dom D38 ) & ( VLabelSelector ) in ( dom C91 )) by L230 , FUNCT_4:10;
thus L383: ( VLabelSelector ) in ( dom D38 ) by L382;
L384: C91 == D38 by L266;
L385: ( the_Vertices_of C91 ) = ( the_Vertices_of D38 ) by L384 , GLIB_000:def 34;
L386: (( D38 . ( VLabelSelector ) ) = ( the_VLabel_of C91 ) & ( dom ( the_VLabel_of C91 ) ) c= ( the_Vertices_of C91 )) by L256 , GLIB_000:9;
thus L387: thesis by L386 , L385;
end;
cluster ( C91 .set (( ELabelSelector ) , C92) ) ->  [VLabeled];
coherence
proof
set D39 = ( C91 .set (( ELabelSelector ) , C92) );
L388: (( dom C91 ) c= ( dom D39 ) & ( VLabelSelector ) in ( dom C91 )) by L230 , FUNCT_4:10;
thus L389: ( VLabelSelector ) in ( dom D39 ) by L388;
L390: C91 == D39 by L266;
L391: ( the_Vertices_of C91 ) = ( the_Vertices_of D39 ) by L390 , GLIB_000:def 34;
L392: (( D39 . ( VLabelSelector ) ) = ( the_VLabel_of C91 ) & ( dom ( the_VLabel_of C91 ) ) c= ( the_Vertices_of C91 )) by L256 , GLIB_000:9;
thus L393: thesis by L392 , L391;
end;
end;
registration
let C93 being _Graph;
let C94 being set;
let C95 being (PartFunc of ( the_Vertices_of C93 ) , C94);
cluster ( C93 .set (( VLabelSelector ) , C95) ) ->  [VLabeled];
coherence
proof
set D40 = ( C93 .set (( VLabelSelector ) , C95) );
L395: (( dom D40 ) = ( ( dom C93 ) \/ { ( VLabelSelector ) } ) & ( VLabelSelector ) in { ( VLabelSelector ) }) by GLIB_000:7 , TARSKI:def 1;
thus L396: ( VLabelSelector ) in ( dom D40 ) by L395 , XBOOLE_0:def 3;
L397: C93 == D40 by L266;
L398: ( the_Vertices_of C93 ) = ( the_Vertices_of D40 ) by L397 , GLIB_000:def 34;
L399: ( dom C95 ) c= ( the_Vertices_of C93 );
thus L400: thesis by L399 , L398 , GLIB_000:8;
end;
end;
registration
let C96 being _Graph;
let C97 being (ManySortedSet of ( the_Vertices_of C96 ));
cluster ( C96 .set (( VLabelSelector ) , C97) ) ->  [VLabeled];
coherence
proof
set D41 = ( C96 .set (( VLabelSelector ) , C97) );
L402: (( dom D41 ) = ( ( dom C96 ) \/ { ( VLabelSelector ) } ) & ( VLabelSelector ) in { ( VLabelSelector ) }) by GLIB_000:7 , TARSKI:def 1;
thus L403: ( VLabelSelector ) in ( dom D41 ) by L402 , XBOOLE_0:def 3;
L404: C96 == D41 by L266;
L405: ( the_Vertices_of C96 ) = ( the_Vertices_of D41 ) by L404 , GLIB_000:def 34;
L406: ( dom C97 ) = ( the_Vertices_of C96 ) by PARTFUN1:def 2;
thus L407: thesis by L406 , L405 , GLIB_000:8;
end;
end;
registration
let C98 being _Graph;
cluster ( C98 .set (( ELabelSelector ) , ( {} )) ) ->  [ELabeled];
coherence
proof
reconsider D42 = ( {} ) as (PartFunc of ( the_Edges_of C98 ) , ( {} )) by RELSET_1:12;
L409: ( C98 .set (( ELabelSelector ) , D42) ) is  [ELabeled];
thus L410: thesis by L409;
end;
cluster ( C98 .set (( VLabelSelector ) , ( {} )) ) ->  [VLabeled];
coherence
proof
reconsider D43 = ( {} ) as (PartFunc of ( the_Vertices_of C98 ) , ( {} )) by RELSET_1:12;
L411: ( C98 .set (( VLabelSelector ) , D43) ) is  [VLabeled];
thus L412: thesis by L411;
end;
end;
registration
let C99 being _Graph;
cluster  [Weighted]  [ELabeled]  [VLabeled] for (Subgraph of C99);
existence
proof
set D44 = the (ManySortedSet of ( the_Edges_of C99 ));
set D45 = ( C99 .set (( WeightSelector ) , D44) );
set D46 = the (PartFunc of ( the_Edges_of D45 ) , ( REAL ));
set D47 = ( D45 .set (( ELabelSelector ) , D46) );
set D48 = the (PartFunc of ( the_Vertices_of D47 ) , ( REAL ));
set D49 = ( D47 .set (( VLabelSelector ) , D48) );
L414: (C99 == D45 & D45 == D47) by L266;
L415: C99 == D47 by L414 , GLIB_000:85;
L416: D47 == D49 by L266;
L417: C99 == D49 by L416 , L415 , GLIB_000:85;
L418: D49 is (Subgraph of C99) by L417 , GLIB_000:87;
thus L419: thesis by L418;
end;
end;
definition
let C100 being WGraph;
let C101 being  [Weighted] (Subgraph of C100);
attr C101 is  weight-inheriting
means
:L421: ( the_Weight_of C101 ) = ( ( the_Weight_of C100 ) | ( the_Edges_of C101 ) );
end;
definition
let C102 being EGraph;
let C103 being  [ELabeled] (Subgraph of C102);
attr C103 is  elabel-inheriting
means
:L423: ( the_ELabel_of C103 ) = ( ( the_ELabel_of C102 ) | ( the_Edges_of C103 ) );
end;
definition
let C104 being VGraph;
let C105 being  [VLabeled] (Subgraph of C104);
attr C105 is  vlabel-inheriting
means
:L425: ( the_VLabel_of C105 ) = ( ( the_VLabel_of C104 ) | ( the_Vertices_of C105 ) );
end;
registration
let C106 being WGraph;
cluster  weight-inheriting for  [Weighted]  [Weighted]  [Weighted]  [Weighted] (Subgraph of C106);
existence
proof
reconsider D50 = C106 as  [Weighted] (Subgraph of C106) by GLIB_000:40;
take D50;
L427: ( the_Weight_of C106 ) = ( ( the_Weight_of C106 ) | ( the_Edges_of C106 ) );
thus L428: thesis by L427 , L421;
end;
end;
registration
let C107 being EGraph;
cluster  elabel-inheriting for  [ELabeled]  [ELabeled]  [ELabeled]  [ELabeled] (Subgraph of C107);
existence
proof
reconsider D51 = C107 as  [ELabeled] (Subgraph of C107) by GLIB_000:40;
take D51;
L430: ( dom ( the_ELabel_of C107 ) ) c= ( the_Edges_of C107 ) by L253;
L431: ( the_ELabel_of D51 ) = ( ( the_ELabel_of C107 ) | ( the_Edges_of C107 ) ) by L430 , RELAT_1:68;
thus L432: thesis by L431 , L423;
end;
end;
registration
let C108 being VGraph;
cluster  vlabel-inheriting for  [VLabeled]  [VLabeled]  [VLabeled]  [VLabeled] (Subgraph of C108);
existence
proof
reconsider D52 = C108 as  [VLabeled] (Subgraph of C108) by GLIB_000:40;
take D52;
L434: ( dom ( the_VLabel_of C108 ) ) c= ( the_Vertices_of C108 ) by L256;
L435: ( the_VLabel_of D52 ) = ( ( the_VLabel_of C108 ) | ( the_Vertices_of C108 ) ) by L434 , RELAT_1:68;
thus L436: thesis by L435 , L425;
end;
end;
registration
let C109 being WEGraph;
cluster  weight-inheriting  elabel-inheriting for  [Weighted]  [ELabeled]  [Weighted]  [ELabeled]  [Weighted]  [ELabeled]  [Weighted]  [ELabeled] (Subgraph of C109);
existence
proof
reconsider D53 = C109 as  [Weighted]  [ELabeled] (Subgraph of C109) by GLIB_000:40;
take D53;
L438: ( the_Weight_of C109 ) = ( ( the_Weight_of C109 ) | ( the_Edges_of C109 ) );
thus L439: D53 is  weight-inheriting by L438 , L421;
L440: ( dom ( the_ELabel_of C109 ) ) c= ( the_Edges_of C109 ) by L253;
L441: ( the_ELabel_of D53 ) = ( ( the_ELabel_of C109 ) | ( the_Edges_of C109 ) ) by L440 , RELAT_1:68;
thus L442: thesis by L441 , L423;
end;
end;
registration
let C110 being WVGraph;
cluster  weight-inheriting  vlabel-inheriting for  [Weighted]  [VLabeled]  [Weighted]  [VLabeled]  [Weighted]  [VLabeled]  [Weighted]  [VLabeled] (Subgraph of C110);
existence
proof
reconsider D54 = C110 as  [Weighted]  [VLabeled] (Subgraph of C110) by GLIB_000:40;
take D54;
L444: ( the_Weight_of C110 ) = ( ( the_Weight_of C110 ) | ( the_Edges_of C110 ) );
thus L445: D54 is  weight-inheriting by L444 , L421;
L446: ( dom ( the_VLabel_of C110 ) ) c= ( the_Vertices_of C110 ) by L256;
L447: ( the_VLabel_of D54 ) = ( ( the_VLabel_of C110 ) | ( the_Vertices_of C110 ) ) by L446 , RELAT_1:68;
thus L448: thesis by L447 , L425;
end;
end;
registration
let C111 being EVGraph;
cluster  elabel-inheriting  vlabel-inheriting for  [ELabeled]  [VLabeled]  [ELabeled]  [VLabeled]  [ELabeled]  [VLabeled]  [ELabeled]  [VLabeled] (Subgraph of C111);
existence
proof
reconsider D55 = C111 as  [ELabeled]  [VLabeled] (Subgraph of C111) by GLIB_000:40;
take D55;
L450: ( dom ( the_ELabel_of C111 ) ) c= ( the_Edges_of C111 ) by L253;
L451: ( the_ELabel_of D55 ) = ( ( the_ELabel_of C111 ) | ( the_Edges_of C111 ) ) by L450 , RELAT_1:68;
thus L452: D55 is  elabel-inheriting by L451 , L423;
L453: ( dom ( the_VLabel_of C111 ) ) c= ( the_Vertices_of C111 ) by L256;
L454: ( the_VLabel_of D55 ) = ( ( the_VLabel_of C111 ) | ( the_Vertices_of C111 ) ) by L453 , RELAT_1:68;
thus L455: thesis by L454 , L425;
end;
end;
registration
let C112 being WEVGraph;
cluster  weight-inheriting  elabel-inheriting  vlabel-inheriting for  [Weighted]  [ELabeled]  [VLabeled]  [Weighted]  [ELabeled]  [VLabeled]  [Weighted]  [ELabeled]  [VLabeled]  [Weighted]  [ELabeled]  [VLabeled] (Subgraph of C112);
existence
proof
reconsider D56 = C112 as  [Weighted]  [ELabeled]  [VLabeled] (Subgraph of C112) by GLIB_000:40;
take D56;
L457: ( the_Weight_of C112 ) = ( ( the_Weight_of C112 ) | ( the_Edges_of C112 ) );
thus L458: D56 is  weight-inheriting by L457 , L421;
L459: ( dom ( the_ELabel_of C112 ) ) c= ( the_Edges_of C112 ) by L253;
L460: ( the_ELabel_of D56 ) = ( ( the_ELabel_of C112 ) | ( the_Edges_of C112 ) ) by L459 , RELAT_1:68;
thus L461: D56 is  elabel-inheriting by L460 , L423;
L462: ( dom ( the_VLabel_of C112 ) ) c= ( the_Vertices_of C112 ) by L256;
L463: ( the_VLabel_of D56 ) = ( ( the_VLabel_of C112 ) | ( the_Vertices_of C112 ) ) by L462 , RELAT_1:68;
thus L464: thesis by L463 , L425;
end;
end;
definition
let C113 being WGraph;
mode WSubgraph of C113
 is  weight-inheriting  [Weighted] (Subgraph of C113);
end;
definition
let C114 being EGraph;
mode ESubgraph of C114
 is  elabel-inheriting  [ELabeled] (Subgraph of C114);
end;
definition
let C115 being VGraph;
mode VSubgraph of C115
 is  vlabel-inheriting  [VLabeled] (Subgraph of C115);
end;
definition
let C116 being WEGraph;
mode WESubgraph of C116
 is  weight-inheriting  elabel-inheriting  [Weighted]  [ELabeled] (Subgraph of C116);
end;
definition
let C117 being WVGraph;
mode WVSubgraph of C117
 is  weight-inheriting  vlabel-inheriting  [Weighted]  [VLabeled] (Subgraph of C117);
end;
definition
let C118 being EVGraph;
mode EVSubgraph of C118
 is  elabel-inheriting  vlabel-inheriting  [ELabeled]  [VLabeled] (Subgraph of C118);
end;
definition
let C119 being WEVGraph;
mode WEVSubgraph of C119
 is  weight-inheriting  elabel-inheriting  vlabel-inheriting  [Weighted]  [ELabeled]  [VLabeled] (Subgraph of C119);
end;
registration
let C120 being _Graph;
let C121 , C122 being set;
cluster  [Weighted]  [ELabeled]  [VLabeled] for (inducedSubgraph of C120 , C121 , C122);
existence
proof
L473:
now
per cases ;
suppose L474: (C121 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C120 )) & C122 c= ( C120 .edgesBetween C121 ));

set D57 = the (inducedSubgraph of C120 , C121 , C122);
set D58 = the (ManySortedSet of ( the_Edges_of D57 ));
set D59 = ( D57 .set (( WeightSelector ) , D58) );
set D60 = the (PartFunc of ( the_Edges_of D59 ) , ( REAL ));
set D61 = ( D59 .set (( ELabelSelector ) , D60) );
set D62 = the (PartFunc of ( the_Vertices_of D61 ) , ( REAL ));
set D63 = ( D61 .set (( VLabelSelector ) , D62) );
L475: (D57 == D59 & D59 == D61) by L266;
L476: D57 == D61 by L475 , GLIB_000:85;
L477: D61 == D63 by L266;
L478: D57 == D63 by L477 , L476 , GLIB_000:85;
L479: D63 is (Subgraph of D57) by L478 , GLIB_000:87;
reconsider D64 = D63 as (Subgraph of C120) by L479 , GLIB_000:43;
L480: ( the_Edges_of D57 ) = C122 by L474 , GLIB_000:def 37;
L481: ( the_Edges_of D64 ) = C122 by L480 , L478 , GLIB_000:def 34;
L482: ( the_Vertices_of D57 ) = C121 by L474 , GLIB_000:def 37;
L483: ( the_Vertices_of D64 ) = C121 by L482 , L478 , GLIB_000:def 34;
L484: D64 is (inducedSubgraph of C120 , C121 , C122) by L483 , L474 , L481 , GLIB_000:def 37;
thus L485: thesis by L484;
end;
suppose L486: (not (C121 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C120 )) & C122 c= ( C120 .edgesBetween C121 )));

set D65 = the (ManySortedSet of ( the_Edges_of C120 ));
set D66 = ( C120 .set (( WeightSelector ) , D65) );
set D67 = the (PartFunc of ( the_Edges_of D66 ) , ( REAL ));
set D68 = ( D66 .set (( ELabelSelector ) , D67) );
set D69 = the (PartFunc of ( the_Vertices_of D68 ) , ( REAL ));
set D70 = ( D68 .set (( VLabelSelector ) , D69) );
L487: (C120 == D66 & D66 == D68) by L266;
L488: C120 == D68 by L487 , GLIB_000:85;
L489: D68 == D70 by L266;
L490: C120 == D70 by L489 , L488 , GLIB_000:85;
reconsider D71 = D70 as (Subgraph of C120) by L490 , GLIB_000:87;
L491: D71 is (inducedSubgraph of C120 , C121 , C122) by L486 , L490 , GLIB_000:def 37;
thus L492: thesis by L491;
end;
end;
thus L494: thesis by L473;
end;
end;
registration
let C123 being WGraph;
let C124 , C125 being set;
cluster  weight-inheriting for  [Weighted]  [Weighted]  [Weighted]  [Weighted] (inducedSubgraph of C123 , C124 , C125);
existence
proof
L496:
now
per cases ;
suppose L497: (C124 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C123 )) & C125 c= ( C123 .edgesBetween C124 ));

set D72 = the  [Weighted] (inducedSubgraph of C123 , C124 , C125);
set D73 = ( ( the_Weight_of C123 ) | ( the_Edges_of D72 ) );
L498: ( dom ( the_Weight_of C123 ) ) = ( the_Edges_of C123 ) by PARTFUN1:def 2;
L499: ( dom D73 ) = ( the_Edges_of D72 ) by L498 , RELAT_1:62;
reconsider D74 = D73 as (ManySortedSet of ( the_Edges_of D72 )) by L499 , PARTFUN1:def 2;
set D75 = ( D72 .set (( WeightSelector ) , D74) );
L500: D75 == D72 by L266;
L501: D75 is (Subgraph of D72) by L500 , GLIB_000:87;
reconsider D76 = D75 as (Subgraph of C123) by L501 , GLIB_000:43;
L502: ( the_Vertices_of D76 ) = ( the_Vertices_of D72 ) by L500 , GLIB_000:def 34
.= C124 by L497 , GLIB_000:def 37;
L503: ( the_Edges_of D76 ) = ( the_Edges_of D72 ) by L500 , GLIB_000:def 34
.= C125 by L497 , GLIB_000:def 37;
reconsider D77 = D76 as  [Weighted] (inducedSubgraph of C123 , C124 , C125) by L503 , L497 , L502 , GLIB_000:def 37;
take D78 = D77;
L504: ( the_Weight_of D78 ) = D74 by GLIB_000:8
.= ( ( the_Weight_of C123 ) | ( the_Edges_of D78 ) ) by L500 , GLIB_000:def 34;
thus L505: D78 is  weight-inheriting by L504 , L421;
end;
suppose L506: (not (C124 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C123 )) & C125 c= ( C123 .edgesBetween C124 )));

reconsider D79 = C123 as (Subgraph of C123) by GLIB_000:40;
reconsider D80 = D79 as  [Weighted] (inducedSubgraph of C123 , C124 , C125) by L506 , GLIB_000:def 37;
take D81 = D80;
L507: ( the_Weight_of C123 ) = ( ( the_Weight_of C123 ) | ( the_Edges_of C123 ) );
thus L508: D81 is  weight-inheriting by L507 , L421;
end;
end;
thus L510: thesis by L496;
end;
end;
registration
let C126 being EGraph;
let C127 , C128 being set;
cluster  elabel-inheriting for  [ELabeled]  [ELabeled]  [ELabeled]  [ELabeled] (inducedSubgraph of C126 , C127 , C128);
existence
proof
L512:
now
per cases ;
suppose L513: (C127 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C126 )) & C128 c= ( C126 .edgesBetween C127 ));

set D82 = the  [ELabeled] (inducedSubgraph of C126 , C127 , C128);
set D83 = ( ( the_ELabel_of C126 ) | ( the_Edges_of D82 ) );
reconsider D84 = D83 as (PartFunc of ( dom D83 ) , ( rng D83 )) by RELSET_1:4;
reconsider D85 = D84 as (PartFunc of ( the_Edges_of D82 ) , ( rng D83 )) by RELAT_1:58 , RELSET_1:5;
set D86 = ( D82 .set (( ELabelSelector ) , D85) );
L514: D86 == D82 by L266;
L515: D86 is (Subgraph of D82) by L514 , GLIB_000:87;
reconsider D87 = D86 as (Subgraph of C126) by L515 , GLIB_000:43;
L516: ( the_Vertices_of D87 ) = ( the_Vertices_of D82 ) by L514 , GLIB_000:def 34
.= C127 by L513 , GLIB_000:def 37;
L517: ( the_Edges_of D87 ) = ( the_Edges_of D82 ) by L514 , GLIB_000:def 34
.= C128 by L513 , GLIB_000:def 37;
reconsider D88 = D87 as  [ELabeled] (inducedSubgraph of C126 , C127 , C128) by L517 , L513 , L516 , GLIB_000:def 37;
take D89 = D88;
L518: ( the_ELabel_of D89 ) = D83 by GLIB_000:8
.= ( ( the_ELabel_of C126 ) | ( the_Edges_of D89 ) ) by L514 , GLIB_000:def 34;
thus L519: D89 is  elabel-inheriting by L518 , L423;
end;
suppose L520: (not (C127 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C126 )) & C128 c= ( C126 .edgesBetween C127 )));

reconsider D90 = C126 as (Subgraph of C126) by GLIB_000:40;
reconsider D91 = D90 as  [ELabeled] (inducedSubgraph of C126 , C127 , C128) by L520 , GLIB_000:def 37;
take D92 = D91;
L521: ( dom ( the_ELabel_of C126 ) ) c= ( the_Edges_of C126 ) by L253;
L522: ( the_ELabel_of C126 ) = ( ( the_ELabel_of C126 ) | ( the_Edges_of C126 ) ) by L521 , RELAT_1:68;
thus L523: D92 is  elabel-inheriting by L522 , L423;
end;
end;
thus L525: thesis by L512;
end;
end;
registration
let C129 being VGraph;
let C130 , C131 being set;
cluster  vlabel-inheriting for  [VLabeled]  [VLabeled]  [VLabeled]  [VLabeled] (inducedSubgraph of C129 , C130 , C131);
existence
proof
L527:
now
per cases ;
suppose L528: (C130 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C129 )) & C131 c= ( C129 .edgesBetween C130 ));

set D93 = the  [VLabeled] (inducedSubgraph of C129 , C130 , C131);
set D94 = ( ( the_VLabel_of C129 ) | ( the_Vertices_of D93 ) );
reconsider D95 = D94 as (PartFunc of ( dom D94 ) , ( rng D94 )) by RELSET_1:4;
reconsider D96 = D95 as (PartFunc of ( the_Vertices_of D93 ) , ( rng D94 )) by RELAT_1:58 , RELSET_1:5;
set D97 = ( D93 .set (( VLabelSelector ) , D96) );
L529: D97 == D93 by L266;
L530: D97 is (Subgraph of D93) by L529 , GLIB_000:87;
reconsider D98 = D97 as (Subgraph of C129) by L530 , GLIB_000:43;
L531: ( the_Vertices_of D98 ) = ( the_Vertices_of D93 ) by L529 , GLIB_000:def 34
.= C130 by L528 , GLIB_000:def 37;
L532: ( the_Edges_of D98 ) = ( the_Edges_of D93 ) by L529 , GLIB_000:def 34
.= C131 by L528 , GLIB_000:def 37;
reconsider D99 = D98 as  [VLabeled] (inducedSubgraph of C129 , C130 , C131) by L532 , L528 , L531 , GLIB_000:def 37;
take D100 = D99;
L533: ( the_VLabel_of D100 ) = D94 by GLIB_000:8
.= ( ( the_VLabel_of C129 ) | ( the_Vertices_of D100 ) ) by L529 , GLIB_000:def 34;
thus L534: D100 is  vlabel-inheriting by L533 , L425;
end;
suppose L535: (not (C130 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C129 )) & C131 c= ( C129 .edgesBetween C130 )));

reconsider D101 = C129 as (Subgraph of C129) by GLIB_000:40;
reconsider D102 = D101 as  [VLabeled] (inducedSubgraph of C129 , C130 , C131) by L535 , GLIB_000:def 37;
take D103 = D102;
L536: ( dom ( the_VLabel_of C129 ) ) c= ( the_Vertices_of C129 ) by L256;
L537: ( the_VLabel_of C129 ) = ( ( the_VLabel_of C129 ) | ( the_Vertices_of C129 ) ) by L536 , RELAT_1:68;
thus L538: D103 is  vlabel-inheriting by L537 , L425;
end;
end;
thus L540: thesis by L527;
end;
end;
registration
let C132 being WEGraph;
let C133 , C134 being set;
cluster  weight-inheriting  elabel-inheriting for  [Weighted]  [ELabeled]  [Weighted]  [ELabeled]  [Weighted]  [ELabeled]  [Weighted]  [ELabeled] (inducedSubgraph of C132 , C133 , C134);
existence
proof
L542:
now
per cases ;
suppose L543: (C133 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C132 )) & C134 c= ( C132 .edgesBetween C133 ));

set D104 = the  [Weighted]  [ELabeled] (inducedSubgraph of C132 , C133 , C134);
set D105 = ( ( the_Weight_of C132 ) | ( the_Edges_of D104 ) );
L544: ( dom ( the_Weight_of C132 ) ) = ( the_Edges_of C132 ) by PARTFUN1:def 2;
L545: ( dom D105 ) = ( the_Edges_of D104 ) by L544 , RELAT_1:62;
reconsider D106 = D105 as (ManySortedSet of ( the_Edges_of D104 )) by L545 , PARTFUN1:def 2;
set D107 = ( D104 .set (( WeightSelector ) , D106) );
set D108 = ( ( the_ELabel_of C132 ) | ( the_Edges_of D107 ) );
reconsider D109 = D108 as (PartFunc of ( dom D108 ) , ( rng D108 )) by RELSET_1:4;
reconsider D110 = D109 as (PartFunc of ( the_Edges_of D107 ) , ( rng D108 )) by RELAT_1:58 , RELSET_1:5;
set D111 = ( D107 .set (( ELabelSelector ) , D110) );
L546: D111 == D107 by L266;
L547: D104 == D107 by L266;
L548: D111 == D104 by L547 , L546 , GLIB_000:85;
L549: D111 is (Subgraph of D104) by L548 , GLIB_000:87;
reconsider D112 = D111 as (Subgraph of C132) by L549 , GLIB_000:43;
L550: ( the_Vertices_of D112 ) = ( the_Vertices_of D104 ) by L548 , GLIB_000:def 34
.= C133 by L543 , GLIB_000:def 37;
L551: ( the_Edges_of D112 ) = ( the_Edges_of D104 ) by L548 , GLIB_000:def 34
.= C134 by L543 , GLIB_000:def 37;
reconsider D113 = D112 as  [Weighted]  [ELabeled] (inducedSubgraph of C132 , C133 , C134) by L551 , L543 , L550 , GLIB_000:def 37;
take D114 = D113;
L552: ( the_Weight_of D114 ) = ( D107 . ( WeightSelector ) ) by GLIB_000:9
.= D106 by GLIB_000:8
.= ( ( the_Weight_of C132 ) | ( the_Edges_of D114 ) ) by L548 , GLIB_000:def 34;
thus L553: D114 is  weight-inheriting by L552 , L421;
L554: ( the_ELabel_of D114 ) = D108 by GLIB_000:8
.= ( ( the_ELabel_of C132 ) | ( the_Edges_of D114 ) ) by L546 , GLIB_000:def 34;
thus L555: D114 is  elabel-inheriting by L554 , L423;
end;
suppose L556: (not (C133 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C132 )) & C134 c= ( C132 .edgesBetween C133 )));

reconsider D115 = C132 as (Subgraph of C132) by GLIB_000:40;
reconsider D116 = D115 as  [Weighted]  [ELabeled] (inducedSubgraph of C132 , C133 , C134) by L556 , GLIB_000:def 37;
take D117 = D116;
L557: ( the_Weight_of C132 ) = ( ( the_Weight_of C132 ) | ( the_Edges_of C132 ) );
thus L558: D117 is  weight-inheriting by L557 , L421;
L559: ( dom ( the_ELabel_of C132 ) ) c= ( the_Edges_of C132 ) by L253;
L560: ( the_ELabel_of C132 ) = ( ( the_ELabel_of C132 ) | ( the_Edges_of C132 ) ) by L559 , RELAT_1:68;
thus L561: D117 is  elabel-inheriting by L560 , L423;
end;
end;
thus L563: thesis by L542;
end;
end;
registration
let C135 being WVGraph;
let C136 , C137 being set;
cluster  weight-inheriting  vlabel-inheriting for  [Weighted]  [VLabeled]  [Weighted]  [VLabeled]  [Weighted]  [VLabeled]  [Weighted]  [VLabeled] (inducedSubgraph of C135 , C136 , C137);
existence
proof
L565:
now
per cases ;
suppose L566: (C136 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C135 )) & C137 c= ( C135 .edgesBetween C136 ));

set D118 = the  [Weighted]  [VLabeled] (inducedSubgraph of C135 , C136 , C137);
set D119 = ( ( the_Weight_of C135 ) | ( the_Edges_of D118 ) );
L567: ( dom ( the_Weight_of C135 ) ) = ( the_Edges_of C135 ) by PARTFUN1:def 2;
L568: ( dom D119 ) = ( the_Edges_of D118 ) by L567 , RELAT_1:62;
reconsider D120 = D119 as (ManySortedSet of ( the_Edges_of D118 )) by L568 , PARTFUN1:def 2;
set D121 = ( D118 .set (( WeightSelector ) , D120) );
set D122 = ( ( the_VLabel_of C135 ) | ( the_Vertices_of D121 ) );
reconsider D123 = D122 as (PartFunc of ( dom D122 ) , ( rng D122 )) by RELSET_1:4;
reconsider D124 = D123 as (PartFunc of ( the_Vertices_of D121 ) , ( rng D122 )) by RELAT_1:58 , RELSET_1:5;
set D125 = ( D121 .set (( VLabelSelector ) , D124) );
L569: D125 == D121 by L266;
L570: D118 == D121 by L266;
L571: D125 == D118 by L570 , L569 , GLIB_000:85;
L572: D125 is (Subgraph of D118) by L571 , GLIB_000:87;
reconsider D126 = D125 as (Subgraph of C135) by L572 , GLIB_000:43;
L573: ( the_Vertices_of D126 ) = ( the_Vertices_of D118 ) by L571 , GLIB_000:def 34
.= C136 by L566 , GLIB_000:def 37;
L574: ( the_Edges_of D126 ) = ( the_Edges_of D118 ) by L571 , GLIB_000:def 34
.= C137 by L566 , GLIB_000:def 37;
reconsider D127 = D126 as  [Weighted]  [VLabeled] (inducedSubgraph of C135 , C136 , C137) by L574 , L566 , L573 , GLIB_000:def 37;
take D128 = D127;
L575: ( the_Weight_of D128 ) = ( D121 . ( WeightSelector ) ) by GLIB_000:9
.= D120 by GLIB_000:8
.= ( ( the_Weight_of C135 ) | ( the_Edges_of D128 ) ) by L571 , GLIB_000:def 34;
thus L576: D128 is  weight-inheriting by L575 , L421;
L577: ( the_VLabel_of D128 ) = D122 by GLIB_000:8
.= ( ( the_VLabel_of C135 ) | ( the_Vertices_of D128 ) ) by L569 , GLIB_000:def 34;
thus L578: D128 is  vlabel-inheriting by L577 , L425;
end;
suppose L579: (not (C136 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C135 )) & C137 c= ( C135 .edgesBetween C136 )));

reconsider D129 = C135 as (Subgraph of C135) by GLIB_000:40;
reconsider D130 = D129 as  [Weighted]  [VLabeled] (inducedSubgraph of C135 , C136 , C137) by L579 , GLIB_000:def 37;
take D131 = D130;
L580: ( the_Weight_of C135 ) = ( ( the_Weight_of C135 ) | ( the_Edges_of C135 ) );
thus L581: D131 is  weight-inheriting by L580 , L421;
L582: ( dom ( the_VLabel_of C135 ) ) c= ( the_Vertices_of C135 ) by L256;
L583: ( the_VLabel_of C135 ) = ( ( the_VLabel_of C135 ) | ( the_Vertices_of C135 ) ) by L582 , RELAT_1:68;
thus L584: D131 is  vlabel-inheriting by L583 , L425;
end;
end;
thus L586: thesis by L565;
end;
end;
registration
let C138 being EVGraph;
let C139 , C140 being set;
cluster  elabel-inheriting  vlabel-inheriting for  [ELabeled]  [VLabeled]  [ELabeled]  [VLabeled]  [ELabeled]  [VLabeled]  [ELabeled]  [VLabeled] (inducedSubgraph of C138 , C139 , C140);
existence
proof
L588:
now
per cases ;
suppose L589: (C139 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C138 )) & C140 c= ( C138 .edgesBetween C139 ));

set D132 = the  [ELabeled]  [VLabeled] (inducedSubgraph of C138 , C139 , C140);
set D133 = ( ( the_ELabel_of C138 ) | ( the_Edges_of D132 ) );
reconsider D134 = D133 as (PartFunc of ( dom D133 ) , ( rng D133 )) by RELSET_1:4;
reconsider D135 = D134 as (PartFunc of ( the_Edges_of D132 ) , ( rng D133 )) by RELAT_1:58 , RELSET_1:5;
set D136 = ( D132 .set (( ELabelSelector ) , D135) );
set D137 = ( ( the_VLabel_of C138 ) | ( the_Vertices_of D136 ) );
reconsider D138 = D137 as (PartFunc of ( dom D137 ) , ( rng D137 )) by RELSET_1:4;
reconsider D139 = D138 as (PartFunc of ( the_Vertices_of D136 ) , ( rng D137 )) by RELAT_1:58 , RELSET_1:5;
set D140 = ( D136 .set (( VLabelSelector ) , D139) );
L590: D140 == D136 by L266;
L591: D132 == D136 by L266;
L592: D140 == D132 by L591 , L590 , GLIB_000:85;
L593: D140 is (Subgraph of D132) by L592 , GLIB_000:87;
reconsider D141 = D140 as (Subgraph of C138) by L593 , GLIB_000:43;
L594: ( the_Vertices_of D141 ) = ( the_Vertices_of D132 ) by L592 , GLIB_000:def 34
.= C139 by L589 , GLIB_000:def 37;
L595: ( the_Edges_of D141 ) = ( the_Edges_of D132 ) by L592 , GLIB_000:def 34
.= C140 by L589 , GLIB_000:def 37;
reconsider D142 = D141 as  [ELabeled]  [VLabeled] (inducedSubgraph of C138 , C139 , C140) by L595 , L589 , L594 , GLIB_000:def 37;
take D143 = D142;
L596: ( the_ELabel_of D143 ) = ( D136 . ( ELabelSelector ) ) by GLIB_000:9
.= D135 by GLIB_000:8
.= ( ( the_ELabel_of C138 ) | ( the_Edges_of D143 ) ) by L592 , GLIB_000:def 34;
thus L597: D143 is  elabel-inheriting by L596 , L423;
L598: ( the_VLabel_of D143 ) = D137 by GLIB_000:8
.= ( ( the_VLabel_of C138 ) | ( the_Vertices_of D143 ) ) by L590 , GLIB_000:def 34;
thus L599: D143 is  vlabel-inheriting by L598 , L425;
end;
suppose L600: (not (C139 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C138 )) & C140 c= ( C138 .edgesBetween C139 )));

reconsider D144 = C138 as (Subgraph of C138) by GLIB_000:40;
reconsider D145 = D144 as  [ELabeled]  [VLabeled] (inducedSubgraph of C138 , C139 , C140) by L600 , GLIB_000:def 37;
take D146 = D145;
L601: ( dom ( the_ELabel_of C138 ) ) c= ( the_Edges_of C138 ) by L253;
L602: ( the_ELabel_of C138 ) = ( ( the_ELabel_of C138 ) | ( the_Edges_of C138 ) ) by L601 , RELAT_1:68;
thus L603: D146 is  elabel-inheriting by L602 , L423;
L604: ( dom ( the_VLabel_of C138 ) ) c= ( the_Vertices_of C138 ) by L256;
L605: ( the_VLabel_of C138 ) = ( ( the_VLabel_of C138 ) | ( the_Vertices_of C138 ) ) by L604 , RELAT_1:68;
thus L606: D146 is  vlabel-inheriting by L605 , L425;
end;
end;
thus L608: thesis by L588;
end;
end;
registration
let C141 being WEVGraph;
let C142 , C143 being set;
cluster  weight-inheriting  elabel-inheriting  vlabel-inheriting for  [Weighted]  [ELabeled]  [VLabeled]  [Weighted]  [ELabeled]  [VLabeled]  [Weighted]  [ELabeled]  [VLabeled]  [Weighted]  [ELabeled]  [VLabeled] (inducedSubgraph of C141 , C142 , C143);
existence
proof
L610:
now
per cases ;
suppose L611: (C142 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C141 )) & C143 c= ( C141 .edgesBetween C142 ));

set D147 = the  [Weighted]  [ELabeled]  [VLabeled] (inducedSubgraph of C141 , C142 , C143);
set D148 = ( ( the_Weight_of C141 ) | ( the_Edges_of D147 ) );
L612: ( dom ( the_Weight_of C141 ) ) = ( the_Edges_of C141 ) by PARTFUN1:def 2;
L613: ( dom D148 ) = ( the_Edges_of D147 ) by L612 , RELAT_1:62;
reconsider D149 = D148 as (ManySortedSet of ( the_Edges_of D147 )) by L613 , PARTFUN1:def 2;
set D150 = ( D147 .set (( WeightSelector ) , D149) );
set D151 = ( ( the_ELabel_of C141 ) | ( the_Edges_of D150 ) );
reconsider D152 = D151 as (PartFunc of ( dom D151 ) , ( rng D151 )) by RELSET_1:4;
reconsider D153 = D152 as (PartFunc of ( the_Edges_of D150 ) , ( rng D151 )) by RELAT_1:58 , RELSET_1:5;
set D154 = ( D150 .set (( ELabelSelector ) , D153) );
set D155 = ( ( the_VLabel_of C141 ) | ( the_Vertices_of D154 ) );
reconsider D156 = D155 as (PartFunc of ( dom D155 ) , ( rng D155 )) by RELSET_1:4;
reconsider D157 = D156 as (PartFunc of ( the_Vertices_of D154 ) , ( rng D155 )) by RELAT_1:58 , RELSET_1:5;
set D158 = ( D154 .set (( VLabelSelector ) , D157) );
L614: D154 == D150 by L266;
L615: D158 == D154 by L266;
L616: D147 == D150 by L266;
L617: D154 == D147 by L616 , L614 , GLIB_000:85;
L618: D158 == D147 by L617 , L615 , GLIB_000:85;
L619: D158 is (Subgraph of D147) by L618 , GLIB_000:87;
reconsider D159 = D158 as (Subgraph of C141) by L619 , GLIB_000:43;
L620: ( the_Vertices_of D159 ) = ( the_Vertices_of D147 ) by L618 , GLIB_000:def 34
.= C142 by L611 , GLIB_000:def 37;
L621: ( the_Edges_of D159 ) = ( the_Edges_of D147 ) by L618 , GLIB_000:def 34
.= C143 by L611 , GLIB_000:def 37;
reconsider D160 = D159 as  [Weighted]  [ELabeled]  [VLabeled] (inducedSubgraph of C141 , C142 , C143) by L621 , L611 , L620 , GLIB_000:def 37;
L622: D160 == D150 by L614 , L615 , GLIB_000:85;
take D161 = D160;
L623: ( the_Weight_of D161 ) = ( D154 . ( WeightSelector ) ) by GLIB_000:9
.= ( D150 . ( WeightSelector ) ) by GLIB_000:9
.= D149 by GLIB_000:8
.= ( ( the_Weight_of C141 ) | ( the_Edges_of D161 ) ) by L618 , GLIB_000:def 34;
thus L624: D161 is  weight-inheriting by L623 , L421;
L625: ( the_ELabel_of D161 ) = ( D154 . ( ELabelSelector ) ) by GLIB_000:9
.= D151 by GLIB_000:8
.= ( ( the_ELabel_of C141 ) | ( the_Edges_of D161 ) ) by L622 , GLIB_000:def 34;
thus L626: D161 is  elabel-inheriting by L625 , L423;
L627: ( the_VLabel_of D161 ) = D155 by GLIB_000:8
.= ( ( the_VLabel_of C141 ) | ( the_Vertices_of D161 ) ) by L615 , GLIB_000:def 34;
thus L628: D161 is  vlabel-inheriting by L627 , L425;
end;
suppose L629: (not (C142 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C141 )) & C143 c= ( C141 .edgesBetween C142 )));

reconsider D162 = C141 as (Subgraph of C141) by GLIB_000:40;
reconsider D163 = D162 as  [Weighted]  [ELabeled]  [VLabeled] (inducedSubgraph of C141 , C142 , C143) by L629 , GLIB_000:def 37;
take D164 = D163;
L630: ( the_Weight_of C141 ) = ( ( the_Weight_of C141 ) | ( the_Edges_of C141 ) );
thus L631: D164 is  weight-inheriting by L630 , L421;
L632: ( dom ( the_ELabel_of C141 ) ) c= ( the_Edges_of C141 ) by L253;
L633: ( the_ELabel_of C141 ) = ( ( the_ELabel_of C141 ) | ( the_Edges_of C141 ) ) by L632 , RELAT_1:68;
thus L634: D164 is  elabel-inheriting by L633 , L423;
L635: ( dom ( the_VLabel_of C141 ) ) c= ( the_Vertices_of C141 ) by L256;
L636: ( the_VLabel_of C141 ) = ( ( the_VLabel_of C141 ) | ( the_Vertices_of C141 ) ) by L635 , RELAT_1:68;
thus L637: D164 is  vlabel-inheriting by L636 , L425;
end;
end;
thus L639: thesis by L610;
end;
end;
definition
let C144 being WGraph;
let C145 , C146 being set;
mode inducedWSubgraph of C144 , C145 , C146
 is  weight-inheriting  [Weighted] (inducedSubgraph of C144 , C145 , C146);
end;
definition
let C147 being EGraph;
let C148 , C149 being set;
mode inducedESubgraph of C147 , C148 , C149
 is  elabel-inheriting  [ELabeled] (inducedSubgraph of C147 , C148 , C149);
end;
definition
let C150 being VGraph;
let C151 , C152 being set;
mode inducedVSubgraph of C150 , C151 , C152
 is  vlabel-inheriting  [VLabeled] (inducedSubgraph of C150 , C151 , C152);
end;
definition
let C153 being WEGraph;
let C154 , C155 being set;
mode inducedWESubgraph of C153 , C154 , C155
 is  weight-inheriting  elabel-inheriting  [Weighted]  [ELabeled] (inducedSubgraph of C153 , C154 , C155);
end;
definition
let C156 being WVGraph;
let C157 , C158 being set;
mode inducedWVSubgraph of C156 , C157 , C158
 is  weight-inheriting  vlabel-inheriting  [Weighted]  [VLabeled] (inducedSubgraph of C156 , C157 , C158);
end;
definition
let C159 being EVGraph;
let C160 , C161 being set;
mode inducedEVSubgraph of C159 , C160 , C161
 is  elabel-inheriting  vlabel-inheriting  [ELabeled]  [VLabeled] (inducedSubgraph of C159 , C160 , C161);
end;
definition
let C162 being WEVGraph;
let C163 , C164 being set;
mode inducedWEVSubgraph of C162 , C163 , C164
 is  weight-inheriting  elabel-inheriting  vlabel-inheriting  [Weighted]  [ELabeled]  [VLabeled] (inducedSubgraph of C162 , C163 , C164);
end;
definition
let C165 being WGraph;
let C166 being set;
mode inducedWSubgraph of C165 , C166
 is (inducedWSubgraph of C165 , C166 , ( C165 .edgesBetween C166 ));
end;
definition
let C167 being EGraph;
let C168 being set;
mode inducedESubgraph of C167 , C168
 is (inducedESubgraph of C167 , C168 , ( C167 .edgesBetween C168 ));
end;
definition
let C169 being VGraph;
let C170 being set;
mode inducedVSubgraph of C169 , C170
 is (inducedVSubgraph of C169 , C170 , ( C169 .edgesBetween C170 ));
end;
definition
let C171 being WEGraph;
let C172 being set;
mode inducedWESubgraph of C171 , C172
 is (inducedWESubgraph of C171 , C172 , ( C171 .edgesBetween C172 ));
end;
definition
let C173 being WVGraph;
let C174 being set;
mode inducedWVSubgraph of C173 , C174
 is (inducedWVSubgraph of C173 , C174 , ( C173 .edgesBetween C174 ));
end;
definition
let C175 being EVGraph;
let C176 being set;
mode inducedEVSubgraph of C175 , C176
 is (inducedEVSubgraph of C175 , C176 , ( C175 .edgesBetween C176 ));
end;
definition
let C177 being WEVGraph;
let C178 being set;
mode inducedWEVSubgraph of C177 , C178
 is (inducedWEVSubgraph of C177 , C178 , ( C177 .edgesBetween C178 ));
end;
definition
let C179 being WGraph;
attr C179 is  real-weighted
means
:L655: ( the_Weight_of C179 ) is  real-valued;
end;
definition
let C180 being WGraph;
attr C180 is  nonnegative-weighted
means
:L657: ( rng ( the_Weight_of C180 ) ) c= ( Real>=0 );
end;
registration
cluster  nonnegative-weighted ->  real-weighted for WGraph;
coherence
proof
let C181 being WGraph;
assume L659: C181 is  nonnegative-weighted;
L660: ( rng ( the_Weight_of C181 ) ) c= ( Real>=0 ) by L659 , L657;
L661: ( rng ( the_Weight_of C181 ) ) c= ( REAL ) by L660 , XBOOLE_1:1;
L662: ( the_Weight_of C181 ) is  real-valued by L661 , VALUED_0:def 3;
thus L663: thesis by L662 , L655;
end;
end;
definition
let C182 being EGraph;
attr C182 is  real-elabeled
means
:L665: ( the_ELabel_of C182 ) is  real-valued;
end;
definition
let C183 being VGraph;
attr C183 is  real-vlabeled
means
:L667: ( the_VLabel_of C183 ) is  real-valued;
end;
definition
let C184 being WEVGraph;
attr C184 is  real-WEV
means
:L669: (C184 is  real-weighted & C184 is  real-elabeled & C184 is  real-vlabeled);
end;
registration
cluster  real-WEV ->  real-weighted  real-elabeled  real-vlabeled for WEVGraph;
coherence by L669;
cluster  real-weighted  real-elabeled  real-vlabeled ->  real-WEV for WEVGraph;
coherence by L669;
end;
registration
let C185 being _Graph;
let C186 being (Function of ( the_Edges_of C185 ) , ( REAL ));
cluster ( C185 .set (( WeightSelector ) , C186) ) ->  real-weighted;
coherence
proof
set D165 = ( C185 .set (( WeightSelector ) , C186) );
L672: ( the_Weight_of D165 ) = C186 by GLIB_000:8;
thus L673: thesis by L672 , L655;
end;
end;
registration
let C187 being _Graph;
let C188 being (PartFunc of ( the_Edges_of C187 ) , ( REAL ));
cluster ( C187 .set (( ELabelSelector ) , C188) ) ->  real-elabeled;
coherence
proof
set D166 = ( C187 .set (( ELabelSelector ) , C188) );
L675: ( the_ELabel_of D166 ) = C188 by GLIB_000:8;
thus L676: thesis by L675 , L665;
end;
end;
registration
let C189 being _Graph;
let C190 being  real-valued (ManySortedSet of ( the_Edges_of C189 ));
cluster ( C189 .set (( ELabelSelector ) , C190) ) ->  real-elabeled;
coherence
proof
set D167 = ( C189 .set (( ELabelSelector ) , C190) );
L678: ( the_ELabel_of D167 ) = C190 by GLIB_000:8;
thus L679: thesis by L678 , L665;
end;
end;
registration
let C191 being _Graph;
let C192 being (PartFunc of ( the_Vertices_of C191 ) , ( REAL ));
cluster ( C191 .set (( VLabelSelector ) , C192) ) ->  real-vlabeled;
coherence
proof
set D168 = ( C191 .set (( VLabelSelector ) , C192) );
L681: ( the_VLabel_of D168 ) = C192 by GLIB_000:8;
thus L682: thesis by L681 , L667;
end;
end;
registration
let C193 being _Graph;
let C194 being  real-valued (ManySortedSet of ( the_Vertices_of C193 ));
cluster ( C193 .set (( VLabelSelector ) , C194) ) ->  real-vlabeled;
coherence
proof
set D169 = ( C193 .set (( VLabelSelector ) , C194) );
L684: ( the_VLabel_of D169 ) = C194 by GLIB_000:8;
thus L685: thesis by L684 , L667;
end;
end;
registration
let C195 being _Graph;
cluster ( C195 .set (( ELabelSelector ) , ( {} )) ) ->  real-elabeled;
coherence
proof
reconsider D170 = ( {} ) as (PartFunc of ( the_Edges_of C195 ) , ( REAL )) by RELSET_1:12;
L687: ( C195 .set (( ELabelSelector ) , D170) ) is  real-elabeled;
thus L688: thesis by L687;
end;
cluster ( C195 .set (( VLabelSelector ) , ( {} )) ) ->  real-vlabeled;
coherence
proof
reconsider D171 = ( {} ) as (PartFunc of ( the_Vertices_of C195 ) , ( REAL )) by RELSET_1:12;
L689: ( C195 .set (( VLabelSelector ) , D171) ) is  real-vlabeled;
thus L690: thesis by L689;
end;
end;
registration
let C196 being _Graph;
let C197 being (Vertex of C196);
let C198 being  real number;
cluster ( C196 .set (( VLabelSelector ) , ( C197 .--> C198 )) ) ->  [VLabeled];
coherence
proof
reconsider D172 = ( C197 .--> C198 ) as (PartFunc of { C197 } , { C198 });
L692: ( dom ( C197 .--> C198 ) ) = { C197 } by FUNCOP_1:13;
reconsider D173 = D172 as (PartFunc of ( the_Vertices_of C196 ) , { C198 }) by L692 , RELSET_1:5;
L693: ( rng ( C197 .--> C198 ) ) = { C198 } by FUNCOP_1:8;
reconsider D174 = D173 as (PartFunc of ( the_Vertices_of C196 ) , ( REAL )) by L693 , RELSET_1:6;
L694: ( C196 .set (( VLabelSelector ) , D174) ) is  real-vlabeled;
thus L695: thesis by L694;
end;
end;
registration
let C199 being _Graph;
let C200 being (Vertex of C199);
let C201 being  real number;
cluster ( C199 .set (( VLabelSelector ) , ( C200 .--> C201 )) ) ->  real-vlabeled;
coherence
proof
reconsider D175 = ( C200 .--> C201 ) as (PartFunc of { C200 } , { C201 });
L697: ( dom ( C200 .--> C201 ) ) = { C200 } by FUNCOP_1:13;
reconsider D176 = D175 as (PartFunc of ( the_Vertices_of C199 ) , { C201 }) by L697 , RELSET_1:5;
L698: (for B39 being set holds (B39 in { C201 } implies B39 in ( REAL ))) by XREAL_0:def 1;
L699: { C201 } c= ( REAL ) by L698 , TARSKI:def 3;
reconsider D177 = D176 as (PartFunc of ( the_Vertices_of C199 ) , ( REAL )) by L699 , RELSET_1:7;
L700: ( C199 .set (( VLabelSelector ) , D177) ) is  real-vlabeled;
thus L701: thesis by L700;
end;
end;
registration
cluster  finite  trivial  Tree-like  nonnegative-weighted  real-WEV for WEVGraph;
existence
proof
set D178 = ( {} );
set D179 = { 1 };
reconsider D180 = ( {} ) as (Function of D178 , D179) by RELSET_1:12;
set D181 = ( createGraph (D179 , D178 , D180 , D180) );
set D182 = the (Function of ( the_Edges_of D181 ) , ( REAL ));
set D183 = ( D181 .set (( WeightSelector ) , D182) );
set D184 = the (PartFunc of ( the_Edges_of D183 ) , ( REAL ));
set D185 = ( D183 .set (( ELabelSelector ) , D184) );
set D186 = the (PartFunc of ( the_Vertices_of D185 ) , ( REAL ));
set D187 = ( D185 .set (( VLabelSelector ) , D186) );
take D187;
thus L703: (D187 is  finite & D187 is  trivial & D187 is  Tree-like);
L704: ( the_Weight_of D187 ) = ( D185 . ( WeightSelector ) ) by GLIB_000:9
.= ( D183 . ( WeightSelector ) ) by GLIB_000:9
.= D182 by GLIB_000:8;
L705: ( the_Edges_of D181 ) = ( {} ) by GLIB_000:6;
L706: ( rng ( the_Weight_of D187 ) ) = ( {} ) by L705 , L704;
L707: ( rng ( the_Weight_of D187 ) ) c= ( Real>=0 ) by L706 , XBOOLE_1:2;
thus L708: D187 is  nonnegative-weighted by L707 , L657;
L709: ( the_ELabel_of D187 ) = ( D185 . ( ELabelSelector ) ) by GLIB_000:9
.= D184 by GLIB_000:8;
L710: D187 is  real-elabeled by L709 , L665;
L711: D187 is  real-weighted by L704 , L655;
thus L712: thesis by L711 , L710;
end;
cluster  finite non  trivial  Tree-like  nonnegative-weighted  real-WEV for WEVGraph;
existence
proof
set D188 = the  finite non  trivial  Tree-like _Graph;
set D189 = ( ( the_Edges_of D188 ) --> ( 0 ) );
L713: ( dom D189 ) = ( the_Edges_of D188 ) by FUNCOP_1:13;
L714: ( rng D189 ) c= { ( 0 ) } by FUNCOP_1:13;
reconsider D190 = D189 as (Function of ( the_Edges_of D188 ) , ( REAL )) by L714 , L713 , FUNCT_2:2;
set D191 = ( D188 .set (( WeightSelector ) , D190) );
reconsider D192 = ( {} ) as (PartFunc of ( the_Edges_of D191 ) , ( REAL )) by RELSET_1:12;
set D193 = ( D191 .set (( ELabelSelector ) , D192) );
reconsider D194 = ( {} ) as (PartFunc of ( the_Vertices_of D193 ) , ( REAL )) by RELSET_1:12;
set D195 = ( D193 .set (( VLabelSelector ) , D194) );
take D195;
thus L715: (D195 is  finite & D195 is non  trivial & D195 is  Tree-like);
L716: ( the_Weight_of D195 ) = ( D193 . ( WeightSelector ) ) by GLIB_000:9
.= ( D191 . ( WeightSelector ) ) by GLIB_000:9
.= D190 by GLIB_000:8;
L717:
now
let C202 being set;
assume L718: C202 in { ( 0 ) };
L719: C202 = ( 0 ) by L718 , TARSKI:def 1;
thus L720: C202 in ( Real>=0 ) by L719 , GRAPH_5:def 12;
end;
L721: { ( 0 ) } c= ( Real>=0 ) by L717 , TARSKI:def 3;
L722: ( rng D190 ) c= ( Real>=0 ) by L721 , L714 , XBOOLE_1:1;
thus L723: D195 is  nonnegative-weighted by L722 , L716 , L657;
L724: ( the_ELabel_of D195 ) = ( D193 . ( ELabelSelector ) ) by GLIB_000:9
.= D192 by GLIB_000:8;
L725: D195 is  real-elabeled by L724 , L665;
L726: D195 is  real-weighted by L716 , L655;
thus L727: thesis by L726 , L725;
end;
end;
registration
let C203 being  finite WGraph;
cluster ( the_Weight_of C203 ) ->  finite;
coherence
proof
L729: ( dom ( the_Weight_of C203 ) ) = ( the_Edges_of C203 ) by PARTFUN1:def 2;
L730: ( rng ( the_Weight_of C203 ) ) is  finite by L729 , FINSET_1:8;
thus L731: thesis by L730 , L729 , ORDERS_1:87;
end;
end;
registration
let C204 being  finite EGraph;
cluster ( the_ELabel_of C204 ) ->  finite;
coherence
proof
L733: ( dom ( the_ELabel_of C204 ) ) c= ( the_Edges_of C204 ) by L253;
L734: ( rng ( the_ELabel_of C204 ) ) is  finite by L733 , FINSET_1:8;
thus L735: thesis by L734 , L733 , ORDERS_1:87;
end;
end;
registration
let C205 being  finite VGraph;
cluster ( the_VLabel_of C205 ) ->  finite;
coherence
proof
L737: ( dom ( the_VLabel_of C205 ) ) c= ( the_Vertices_of C205 ) by L256;
L738: ( rng ( the_VLabel_of C205 ) ) is  finite by L737 , FINSET_1:8;
thus L739: thesis by L738 , L737 , ORDERS_1:87;
end;
end;
registration
let C206 being  real-weighted WGraph;
cluster ( the_Weight_of C206 ) ->  real-valued;
coherence by L655;
end;
registration
let C207 being  real-elabeled EGraph;
cluster ( the_ELabel_of C207 ) ->  real-valued;
coherence by L665;
end;
registration
let C208 being  real-vlabeled VGraph;
cluster ( the_VLabel_of C208 ) ->  real-valued;
coherence by L667;
end;
registration
let C209 being  real-weighted WGraph;
let C210 being set;
cluster ( C209 .set (( ELabelSelector ) , C210) ) ->  real-weighted;
coherence
proof
set D196 = ( C209 .set (( ELabelSelector ) , C210) );
L744: ( the_Weight_of D196 ) = ( the_Weight_of C209 ) by GLIB_000:9;
thus L745: thesis by L744 , L655;
end;
cluster ( C209 .set (( VLabelSelector ) , C210) ) ->  real-weighted;
coherence
proof
set D197 = ( C209 .set (( VLabelSelector ) , C210) );
L746: ( the_Weight_of D197 ) = ( the_Weight_of C209 ) by GLIB_000:9;
thus L747: thesis by L746 , L655;
end;
end;
registration
let C211 being  nonnegative-weighted WGraph;
let C212 being set;
cluster ( C211 .set (( ELabelSelector ) , C212) ) ->  nonnegative-weighted;
coherence
proof
set D198 = ( C211 .set (( ELabelSelector ) , C212) );
L749: (( the_Weight_of D198 ) = ( the_Weight_of C211 ) & ( rng ( the_Weight_of C211 ) ) c= ( Real>=0 )) by L657 , GLIB_000:9;
thus L750: thesis by L749 , L657;
end;
cluster ( C211 .set (( VLabelSelector ) , C212) ) ->  nonnegative-weighted;
coherence
proof
set D199 = ( C211 .set (( VLabelSelector ) , C212) );
L751: (( the_Weight_of D199 ) = ( the_Weight_of C211 ) & ( rng ( the_Weight_of C211 ) ) c= ( Real>=0 )) by L657 , GLIB_000:9;
thus L752: thesis by L751 , L657;
end;
end;
registration
let C213 being  real-elabeled EGraph;
let C214 being set;
cluster ( C213 .set (( WeightSelector ) , C214) ) ->  real-elabeled;
coherence
proof
set D200 = ( C213 .set (( WeightSelector ) , C214) );
L754: ( the_ELabel_of D200 ) = ( the_ELabel_of C213 ) by GLIB_000:9;
thus L755: thesis by L754 , L665;
end;
cluster ( C213 .set (( VLabelSelector ) , C214) ) ->  real-elabeled;
coherence
proof
set D201 = ( C213 .set (( VLabelSelector ) , C214) );
L756: ( the_ELabel_of D201 ) = ( the_ELabel_of C213 ) by GLIB_000:9;
thus L757: thesis by L756 , L665;
end;
end;
registration
let C215 being  real-vlabeled VGraph;
let C216 being set;
cluster ( C215 .set (( WeightSelector ) , C216) ) ->  real-vlabeled;
coherence
proof
set D202 = ( C215 .set (( WeightSelector ) , C216) );
L759: ( the_VLabel_of D202 ) = ( the_VLabel_of C215 ) by GLIB_000:9;
thus L760: thesis by L759 , L667;
end;
cluster ( C215 .set (( ELabelSelector ) , C216) ) ->  real-vlabeled;
coherence
proof
set D203 = ( C215 .set (( ELabelSelector ) , C216) );
L761: ( the_VLabel_of D203 ) = ( the_VLabel_of C215 ) by GLIB_000:9;
thus L762: thesis by L761 , L667;
end;
end;
definition
let C217 being WGraph;
let C218 being (Walk of C217);
func C218 .weightSeq() -> FinSequence means 
:L764: (( len it ) = ( len ( C218 .edgeSeq() ) ) & (for B40 being Nat holds ((1 <= B40 & B40 <= ( len it )) implies ( it . B40 ) = ( ( the_Weight_of C217 ) . ( ( C218 .edgeSeq() ) . B40 ) ))));
existence
proof
deffunc H1(Nat) = ( ( the_Weight_of C217 ) . ( ( C218 .edgeSeq() ) . $1 ) );
consider C219 being FinSequence such that L765: (( len C219 ) = ( len ( C218 .edgeSeq() ) ) & (for B41 being Nat holds (B41 in ( dom C219 ) implies ( C219 . B41 ) = H1(B41)))) from FINSEQ_1:sch 2;
take C219;
thus L766: ( len C219 ) = ( len ( C218 .edgeSeq() ) ) by L765;
let C220 being Nat;
assume L767: (1 <= C220 & C220 <= ( len C219 ));
L768: C220 in ( dom C219 ) by L767 , FINSEQ_3:25;
thus L769: thesis by L768 , L765;
end;
uniqueness
proof
let C221 , C222 being FinSequence;
assume that
L770: ( len C221 ) = ( len ( C218 .edgeSeq() ) )
and
L771: (for B42 being Nat holds ((1 <= B42 & B42 <= ( len C221 )) implies ( C221 . B42 ) = ( ( the_Weight_of C217 ) . ( ( C218 .edgeSeq() ) . B42 ) )))
and
L772: ( len C222 ) = ( len ( C218 .edgeSeq() ) )
and
L773: (for B43 being Nat holds ((1 <= B43 & B43 <= ( len C222 )) implies ( C222 . B43 ) = ( ( the_Weight_of C217 ) . ( ( C218 .edgeSeq() ) . B43 ) )));
L774:
now
let C223 being Nat;
assume L775: (1 <= C223 & C223 <= ( len C221 ));
thus L776: ( C221 . C223 ) = ( ( the_Weight_of C217 ) . ( ( C218 .edgeSeq() ) . C223 ) ) by L775 , L771
.= ( C222 . C223 ) by L770 , L772 , L773 , L775;
end;
thus L777: thesis by L774 , L770 , L772 , FINSEQ_1:14;
end;
end;
definition
let C224 being  real-weighted WGraph;
let C225 being (Walk of C224);
redefine func C225 .weightSeq() -> (FinSequence of ( REAL ));

coherence
proof
L779:
now
let C226 being set;
assume L780: C226 in ( rng ( C225 .weightSeq() ) );
consider C227 being Nat such that L781: C227 in ( dom ( C225 .weightSeq() ) ) and L782: C226 = ( ( C225 .weightSeq() ) . C227 ) by L780 , FINSEQ_2:10;
L783: (1 <= C227 & C227 <= ( len ( C225 .weightSeq() ) )) by L781 , FINSEQ_3:25;
L784: C226 = ( ( the_Weight_of C224 ) . ( ( C225 .edgeSeq() ) . C227 ) ) by L783 , L782 , L764;
thus L785: C226 in ( REAL ) by L784;
end;
L786: ( rng ( C225 .weightSeq() ) ) c= ( REAL ) by L779 , TARSKI:def 3;
thus L787: thesis by L786 , FINSEQ_1:def 4;
end;
end;
definition
let C228 being  real-weighted WGraph;
let C229 being (Walk of C228);
func C229 .cost() -> Real equals 
( Sum ( C229 .weightSeq() ) );
coherence;
end;
L790: (for B44 , B45 , B46 , B47 being set holds (for B48 being (PartFunc of B46 , B47) holds ((B44 in B46 & B45 in B47) implies ( B48 +* ( B44 .--> B45 ) ) is (PartFunc of B46 , B47))))
proof
let C230 , C231 , C232 , C233 being set;
let C234 being (PartFunc of C232 , C233);
assume that
L791: C230 in C232
and
L792: C231 in C233;
set D204 = ( C234 +* ( C230 .--> C231 ) );
L793: ( rng D204 ) c= ( ( rng C234 ) \/ ( rng ( C230 .--> C231 ) ) ) by FUNCT_4:17;
L794:
now
let C235 being set;
assume L795: C235 in ( rng D204 );
L796:
now
per cases  by L793 , L795 , XBOOLE_0:def 3;
suppose L797: C235 in ( rng C234 );

thus L798: C235 in C233 by L797;
end;
suppose L799: C235 in ( rng ( C230 .--> C231 ) );

L800: C235 in { C231 } by L799 , FUNCOP_1:8;
thus L801: C235 in C233 by L800 , L792 , TARSKI:def 1;
end;
end;
thus L803: C235 in C233 by L796;
end;
L804: ( rng D204 ) c= C233 by L794 , TARSKI:def 3;
reconsider D205 = D204 as (PartFunc of ( dom D204 ) , C233) by L804 , RELSET_1:4;
L805:
now
let C236 being set;
assume L806: C236 in ( dom D205 );
L807: C236 in ( ( dom C234 ) \/ ( dom ( C230 .--> C231 ) ) ) by L806 , FUNCT_4:def 1;
L808:
now
per cases  by L807 , XBOOLE_0:def 3;
suppose L809: C236 in ( dom C234 );

thus L810: C236 in C232 by L809;
end;
suppose L811: C236 in ( dom ( C230 .--> C231 ) );

L812: C236 in { C230 } by L811;
thus L813: C236 in C232 by L812 , L791 , TARSKI:def 1;
end;
end;
thus L815: C236 in C232 by L808;
end;
L816: ( dom D205 ) c= C232 by L805 , TARSKI:def 3;
thus L817: thesis by L816 , RELSET_1:7;
end;
definition
let C237 being EGraph;
func C237 .labeledE() -> (Subset of ( the_Edges_of C237 )) equals 
( dom ( the_ELabel_of C237 ) );
coherence by L253;
end;
definition
let C238 being EGraph;
let C239 , C240 being set;
func C238 .labelEdge (C239 , C240) -> EGraph equals 
:L819: ( C238 .set (( ELabelSelector ) , ( ( the_ELabel_of C238 ) +* ( C239 .--> C240 ) )) ) if C239 in ( the_Edges_of C238 ) otherwise C238;
coherence
proof
set D206 = ( ( the_ELabel_of C238 ) +* ( C239 .--> C240 ) );
set D207 = ( C238 .set (( ELabelSelector ) , D206) );
L820: C238 == D207 by L266;
L821: ( the_Edges_of C238 ) = ( the_Edges_of D207 ) by L820 , GLIB_000:def 34;
thus L822:now
L823: ( dom D206 ) = ( ( dom ( the_ELabel_of C238 ) ) \/ ( dom ( C239 .--> C240 ) ) ) by FUNCT_4:def 1
.= ( ( dom ( the_ELabel_of C238 ) ) \/ { C239 } ) by FUNCOP_1:13;
assume L824: C239 in ( the_Edges_of C238 );
L825:
now
let C241 being set;
assume L826: C241 in ( dom D206 );
L827:
now
per cases  by L823 , L826 , XBOOLE_0:def 3;
suppose L828: C241 in ( dom ( the_ELabel_of C238 ) );

L829: ( dom ( the_ELabel_of C238 ) ) c= ( the_Edges_of C238 ) by L253;
thus L830: C241 in ( the_Edges_of C238 ) by L829 , L828;
end;
suppose L831: C241 in { C239 };

thus L832: C241 in ( the_Edges_of C238 ) by L831 , L824 , TARSKI:def 1;
end;
end;
thus L834: C241 in ( the_Edges_of C238 ) by L827;
end;
L835: ( dom D206 ) c= ( the_Edges_of D207 ) by L825 , L821 , TARSKI:def 3;
L836: ( D207 . ( ELabelSelector ) ) = D206 by GLIB_000:8;
L837: (( ELabelSelector ) in ( dom C238 ) & ( dom C238 ) c= ( dom D207 )) by L229 , FUNCT_4:10;
thus L838: D207 is EGraph by L837 , L835 , L836 , L229;
end;
thus L839: thesis;
end;
consistency;
end;
registration
let C242 being  finite EGraph;
let C243 , C244 being set;
cluster ( C242 .labelEdge (C243 , C244) ) ->  finite;
coherence
proof
L841:
now
per cases ;
suppose L842: C243 in ( the_Edges_of C242 );

L843: ( C242 .labelEdge (C243 , C244) ) = ( C242 .set (( ELabelSelector ) , ( ( the_ELabel_of C242 ) +* ( C243 .--> C244 ) )) ) by L842 , L819;
thus L844: thesis by L843;
end;
suppose L845: (not C243 in ( the_Edges_of C242 ));

thus L846: thesis by L845 , L819;
end;
end;
thus L848: thesis by L841;
end;
end;
registration
let C245 being  loopless EGraph;
let C246 , C247 being set;
cluster ( C245 .labelEdge (C246 , C247) ) ->  loopless;
coherence
proof
L850:
now
per cases ;
suppose L851: C246 in ( the_Edges_of C245 );

L852: ( C245 .labelEdge (C246 , C247) ) = ( C245 .set (( ELabelSelector ) , ( ( the_ELabel_of C245 ) +* ( C246 .--> C247 ) )) ) by L851 , L819;
thus L853: thesis by L852;
end;
suppose L854: (not C246 in ( the_Edges_of C245 ));

thus L855: thesis by L854 , L819;
end;
end;
thus L857: thesis by L850;
end;
end;
registration
let C248 being  trivial EGraph;
let C249 , C250 being set;
cluster ( C248 .labelEdge (C249 , C250) ) ->  trivial;
coherence
proof
L859:
now
per cases ;
suppose L860: C249 in ( the_Edges_of C248 );

L861: ( C248 .labelEdge (C249 , C250) ) = ( C248 .set (( ELabelSelector ) , ( ( the_ELabel_of C248 ) +* ( C249 .--> C250 ) )) ) by L860 , L819;
thus L862: thesis by L861;
end;
suppose L863: (not C249 in ( the_Edges_of C248 ));

thus L864: thesis by L863 , L819;
end;
end;
thus L866: thesis by L859;
end;
end;
registration
let C251 being non  trivial EGraph;
let C252 , C253 being set;
cluster ( C251 .labelEdge (C252 , C253) ) -> non  trivial;
coherence
proof
L868:
now
per cases ;
suppose L869: C252 in ( the_Edges_of C251 );

L870: ( C251 .labelEdge (C252 , C253) ) = ( C251 .set (( ELabelSelector ) , ( ( the_ELabel_of C251 ) +* ( C252 .--> C253 ) )) ) by L869 , L819;
thus L871: thesis by L870;
end;
suppose L872: (not C252 in ( the_Edges_of C251 ));

thus L873: thesis by L872 , L819;
end;
end;
thus L875: thesis by L868;
end;
end;
registration
let C254 being  non-multi EGraph;
let C255 , C256 being set;
cluster ( C254 .labelEdge (C255 , C256) ) ->  non-multi;
coherence
proof
L877:
now
per cases ;
suppose L878: C255 in ( the_Edges_of C254 );

L879: ( C254 .labelEdge (C255 , C256) ) = ( C254 .set (( ELabelSelector ) , ( ( the_ELabel_of C254 ) +* ( C255 .--> C256 ) )) ) by L878 , L819;
thus L880: thesis by L879;
end;
suppose L881: (not C255 in ( the_Edges_of C254 ));

thus L882: thesis by L881 , L819;
end;
end;
thus L884: thesis by L877;
end;
end;
registration
let C257 being  non-Dmulti EGraph;
let C258 , C259 being set;
cluster ( C257 .labelEdge (C258 , C259) ) ->  non-Dmulti;
coherence
proof
L886:
now
per cases ;
suppose L887: C258 in ( the_Edges_of C257 );

L888: ( C257 .labelEdge (C258 , C259) ) = ( C257 .set (( ELabelSelector ) , ( ( the_ELabel_of C257 ) +* ( C258 .--> C259 ) )) ) by L887 , L819;
thus L889: thesis by L888;
end;
suppose L890: (not C258 in ( the_Edges_of C257 ));

thus L891: thesis by L890 , L819;
end;
end;
thus L893: thesis by L886;
end;
end;
registration
let C260 being  connected EGraph;
let C261 , C262 being set;
cluster ( C260 .labelEdge (C261 , C262) ) ->  connected;
coherence
proof
L895:
now
per cases ;
suppose L896: C261 in ( the_Edges_of C260 );

L897: ( C260 .labelEdge (C261 , C262) ) = ( C260 .set (( ELabelSelector ) , ( ( the_ELabel_of C260 ) +* ( C261 .--> C262 ) )) ) by L896 , L819;
thus L898: thesis by L897;
end;
suppose L899: (not C261 in ( the_Edges_of C260 ));

thus L900: thesis by L899 , L819;
end;
end;
thus L902: thesis by L895;
end;
end;
registration
let C263 being  acyclic EGraph;
let C264 , C265 being set;
cluster ( C263 .labelEdge (C264 , C265) ) ->  acyclic;
coherence
proof
L904:
now
per cases ;
suppose L905: C264 in ( the_Edges_of C263 );

L906: ( C263 .labelEdge (C264 , C265) ) = ( C263 .set (( ELabelSelector ) , ( ( the_ELabel_of C263 ) +* ( C264 .--> C265 ) )) ) by L905 , L819;
thus L907: thesis by L906;
end;
suppose L908: (not C264 in ( the_Edges_of C263 ));

thus L909: thesis by L908 , L819;
end;
end;
thus L911: thesis by L904;
end;
end;
registration
let C266 being WEGraph;
let C267 , C268 being set;
cluster ( C266 .labelEdge (C267 , C268) ) ->  [Weighted];
coherence
proof
L913:
now
per cases ;
suppose L914: C267 in ( the_Edges_of C266 );

L915: ( C266 .labelEdge (C267 , C268) ) = ( C266 .set (( ELabelSelector ) , ( ( the_ELabel_of C266 ) +* ( C267 .--> C268 ) )) ) by L914 , L819;
thus L916: thesis by L915;
end;
suppose L917: (not C267 in ( the_Edges_of C266 ));

thus L918: thesis by L917 , L819;
end;
end;
thus L920: thesis by L913;
end;
end;
registration
let C269 being EVGraph;
let C270 , C271 being set;
cluster ( C269 .labelEdge (C270 , C271) ) ->  [VLabeled];
coherence
proof
L922:
now
per cases ;
suppose L923: C270 in ( the_Edges_of C269 );

L924: ( C269 .labelEdge (C270 , C271) ) = ( C269 .set (( ELabelSelector ) , ( ( the_ELabel_of C269 ) +* ( C270 .--> C271 ) )) ) by L923 , L819;
thus L925: thesis by L924;
end;
suppose L926: (not C270 in ( the_Edges_of C269 ));

thus L927: thesis by L926 , L819;
end;
end;
thus L929: thesis by L922;
end;
end;
registration
let C272 being  real-weighted WEGraph;
let C273 , C274 being set;
cluster ( C272 .labelEdge (C273 , C274) ) ->  real-weighted;
coherence
proof
L931:
now
per cases ;
suppose L932: C273 in ( the_Edges_of C272 );

L933: ( C272 .labelEdge (C273 , C274) ) = ( C272 .set (( ELabelSelector ) , ( ( the_ELabel_of C272 ) +* ( C273 .--> C274 ) )) ) by L932 , L819;
thus L934: thesis by L933;
end;
suppose L935: (not C273 in ( the_Edges_of C272 ));

thus L936: thesis by L935 , L819;
end;
end;
thus L938: thesis by L931;
end;
end;
registration
let C275 being  nonnegative-weighted WEGraph;
let C276 , C277 being set;
cluster ( C275 .labelEdge (C276 , C277) ) ->  nonnegative-weighted;
coherence
proof
L940:
now
per cases ;
suppose L941: C276 in ( the_Edges_of C275 );

L942: ( C275 .labelEdge (C276 , C277) ) = ( C275 .set (( ELabelSelector ) , ( ( the_ELabel_of C275 ) +* ( C276 .--> C277 ) )) ) by L941 , L819;
thus L943: thesis by L942;
end;
suppose L944: (not C276 in ( the_Edges_of C275 ));

thus L945: thesis by L944 , L819;
end;
end;
thus L947: thesis by L940;
end;
end;
registration
let C278 being  real-elabeled EGraph;
let C279 being set;
let C280 being Real;
cluster ( C278 .labelEdge (C279 , C280) ) ->  real-elabeled;
coherence
proof
L949:
now
per cases ;
suppose L950: C279 in ( the_Edges_of C278 );

set D208 = ( ( the_ELabel_of C278 ) +* ( C279 .--> C280 ) );
L951: ( rng ( the_ELabel_of C278 ) ) c= ( REAL );
L952: ( the_ELabel_of C278 ) is (PartFunc of ( dom ( the_ELabel_of C278 ) ) , ( REAL )) by L951 , RELSET_1:4;
L953: ( the_ELabel_of C278 ) is (PartFunc of ( the_Edges_of C278 ) , ( REAL )) by L952 , L253 , RELSET_1:5;
reconsider D209 = D208 as (PartFunc of ( the_Edges_of C278 ) , ( REAL )) by L953 , L950 , L790;
L954: ( C278 .labelEdge (C279 , C280) ) = ( C278 .set (( ELabelSelector ) , D209) ) by L950 , L819;
thus L955: thesis by L954;
end;
suppose L956: (not C279 in ( the_Edges_of C278 ));

thus L957: thesis by L956 , L819;
end;
end;
thus L959: thesis by L949;
end;
end;
registration
let C281 being  real-vlabeled EVGraph;
let C282 , C283 being set;
cluster ( C281 .labelEdge (C282 , C283) ) ->  real-vlabeled;
coherence
proof
L961:
now
per cases ;
suppose L962: C282 in ( the_Edges_of C281 );

L963: ( C281 .labelEdge (C282 , C283) ) = ( C281 .set (( ELabelSelector ) , ( ( the_ELabel_of C281 ) +* ( C282 .--> C283 ) )) ) by L962 , L819;
thus L964: thesis by L963;
end;
suppose L965: (not C282 in ( the_Edges_of C281 ));

thus L966: thesis by L965 , L819;
end;
end;
thus L968: thesis by L961;
end;
end;
definition
let C284 being VGraph;
let C285 , C286 being set;
func C284 .labelVertex (C285 , C286) -> VGraph equals 
:L970: ( C284 .set (( VLabelSelector ) , ( ( the_VLabel_of C284 ) +* ( C285 .--> C286 ) )) ) if C285 in ( the_Vertices_of C284 ) otherwise C284;
coherence
proof
set D210 = ( ( the_VLabel_of C284 ) +* ( C285 .--> C286 ) );
set D211 = ( C284 .set (( VLabelSelector ) , D210) );
thus L971:now
L972: ( dom D210 ) = ( ( dom ( the_VLabel_of C284 ) ) \/ ( dom ( C285 .--> C286 ) ) ) by FUNCT_4:def 1;
assume L973: C285 in ( the_Vertices_of C284 );
L974:
now
let C287 being set;
assume L975: C287 in ( dom D210 );
L976:
now
per cases  by L972 , L975 , XBOOLE_0:def 3;
suppose L977: C287 in ( dom ( the_VLabel_of C284 ) );

L978: ( dom ( the_VLabel_of C284 ) ) c= ( the_Vertices_of C284 ) by L256;
thus L979: C287 in ( the_Vertices_of C284 ) by L978 , L977;
end;
suppose L980: C287 in ( dom ( C285 .--> C286 ) );

L981: C287 in { C285 } by L980;
thus L982: C287 in ( the_Vertices_of C284 ) by L981 , L973 , TARSKI:def 1;
end;
end;
thus L984: C287 in ( the_Vertices_of C284 ) by L976;
end;
L985: ( dom D210 ) c= ( the_Vertices_of C284 ) by L974 , TARSKI:def 3;
reconsider D212 = D210 as (PartFunc of ( the_Vertices_of C284 ) , ( rng D210 )) by L985 , RELSET_1:4;
L986: D211 = ( C284 .set (( VLabelSelector ) , D212) );
thus L987: D211 is VGraph by L986;
end;
thus L988: thesis;
end;
consistency;
end;
definition
let C288 being VGraph;
func C288 .labeledV() -> (Subset of ( the_Vertices_of C288 )) equals 
( dom ( the_VLabel_of C288 ) );
coherence by L256;
end;
registration
let C289 being  finite VGraph;
let C290 , C291 being set;
cluster ( C289 .labelVertex (C290 , C291) ) ->  finite;
coherence
proof
L991:
now
per cases ;
suppose L992: C290 in ( the_Vertices_of C289 );

L993: ( C289 .labelVertex (C290 , C291) ) = ( C289 .set (( VLabelSelector ) , ( ( the_VLabel_of C289 ) +* ( C290 .--> C291 ) )) ) by L992 , L970;
thus L994: thesis by L993;
end;
suppose L995: (not C290 in ( the_Vertices_of C289 ));

thus L996: thesis by L995 , L970;
end;
end;
thus L998: thesis by L991;
end;
end;
registration
let C292 being  loopless VGraph;
let C293 , C294 being set;
cluster ( C292 .labelVertex (C293 , C294) ) ->  loopless;
coherence
proof
L1000:
now
per cases ;
suppose L1001: C293 in ( the_Vertices_of C292 );

L1002: ( C292 .labelVertex (C293 , C294) ) = ( C292 .set (( VLabelSelector ) , ( ( the_VLabel_of C292 ) +* ( C293 .--> C294 ) )) ) by L1001 , L970;
thus L1003: thesis by L1002;
end;
suppose L1004: (not C293 in ( the_Vertices_of C292 ));

thus L1005: thesis by L1004 , L970;
end;
end;
thus L1007: thesis by L1000;
end;
end;
registration
let C295 being  trivial VGraph;
let C296 , C297 being set;
cluster ( C295 .labelVertex (C296 , C297) ) ->  trivial;
coherence
proof
L1009:
now
per cases ;
suppose L1010: C296 in ( the_Vertices_of C295 );

L1011: ( C295 .labelVertex (C296 , C297) ) = ( C295 .set (( VLabelSelector ) , ( ( the_VLabel_of C295 ) +* ( C296 .--> C297 ) )) ) by L1010 , L970;
thus L1012: thesis by L1011;
end;
suppose L1013: (not C296 in ( the_Vertices_of C295 ));

thus L1014: thesis by L1013 , L970;
end;
end;
thus L1016: thesis by L1009;
end;
end;
registration
let C298 being non  trivial VGraph;
let C299 , C300 being set;
cluster ( C298 .labelVertex (C299 , C300) ) -> non  trivial;
coherence
proof
L1018:
now
per cases ;
suppose L1019: C299 in ( the_Vertices_of C298 );

L1020: ( C298 .labelVertex (C299 , C300) ) = ( C298 .set (( VLabelSelector ) , ( ( the_VLabel_of C298 ) +* ( C299 .--> C300 ) )) ) by L1019 , L970;
thus L1021: thesis by L1020;
end;
suppose L1022: (not C299 in ( the_Vertices_of C298 ));

thus L1023: thesis by L1022 , L970;
end;
end;
thus L1025: thesis by L1018;
end;
end;
registration
let C301 being  non-multi VGraph;
let C302 , C303 being set;
cluster ( C301 .labelVertex (C302 , C303) ) ->  non-multi;
coherence
proof
L1027:
now
per cases ;
suppose L1028: C302 in ( the_Vertices_of C301 );

L1029: ( C301 .labelVertex (C302 , C303) ) = ( C301 .set (( VLabelSelector ) , ( ( the_VLabel_of C301 ) +* ( C302 .--> C303 ) )) ) by L1028 , L970;
thus L1030: thesis by L1029;
end;
suppose L1031: (not C302 in ( the_Vertices_of C301 ));

thus L1032: thesis by L1031 , L970;
end;
end;
thus L1034: thesis by L1027;
end;
end;
registration
let C304 being  non-Dmulti VGraph;
let C305 , C306 being set;
cluster ( C304 .labelVertex (C305 , C306) ) ->  non-Dmulti;
coherence
proof
L1036:
now
per cases ;
suppose L1037: C305 in ( the_Vertices_of C304 );

L1038: ( C304 .labelVertex (C305 , C306) ) = ( C304 .set (( VLabelSelector ) , ( ( the_VLabel_of C304 ) +* ( C305 .--> C306 ) )) ) by L1037 , L970;
thus L1039: thesis by L1038;
end;
suppose L1040: (not C305 in ( the_Vertices_of C304 ));

thus L1041: thesis by L1040 , L970;
end;
end;
thus L1043: thesis by L1036;
end;
end;
registration
let C307 being  connected VGraph;
let C308 , C309 being set;
cluster ( C307 .labelVertex (C308 , C309) ) ->  connected;
coherence
proof
L1045:
now
per cases ;
suppose L1046: C308 in ( the_Vertices_of C307 );

L1047: ( C307 .labelVertex (C308 , C309) ) = ( C307 .set (( VLabelSelector ) , ( ( the_VLabel_of C307 ) +* ( C308 .--> C309 ) )) ) by L1046 , L970;
thus L1048: thesis by L1047;
end;
suppose L1049: (not C308 in ( the_Vertices_of C307 ));

thus L1050: thesis by L1049 , L970;
end;
end;
thus L1052: thesis by L1045;
end;
end;
registration
let C310 being  acyclic VGraph;
let C311 , C312 being set;
cluster ( C310 .labelVertex (C311 , C312) ) ->  acyclic;
coherence
proof
L1054:
now
per cases ;
suppose L1055: C311 in ( the_Vertices_of C310 );

L1056: ( C310 .labelVertex (C311 , C312) ) = ( C310 .set (( VLabelSelector ) , ( ( the_VLabel_of C310 ) +* ( C311 .--> C312 ) )) ) by L1055 , L970;
thus L1057: thesis by L1056;
end;
suppose L1058: (not C311 in ( the_Vertices_of C310 ));

thus L1059: thesis by L1058 , L970;
end;
end;
thus L1061: thesis by L1054;
end;
end;
registration
let C313 being WVGraph;
let C314 , C315 being set;
cluster ( C313 .labelVertex (C314 , C315) ) ->  [Weighted];
coherence
proof
L1063:
now
per cases ;
suppose L1064: C314 in ( the_Vertices_of C313 );

L1065: ( C313 .labelVertex (C314 , C315) ) = ( C313 .set (( VLabelSelector ) , ( ( the_VLabel_of C313 ) +* ( C314 .--> C315 ) )) ) by L1064 , L970;
thus L1066: thesis by L1065;
end;
suppose L1067: (not C314 in ( the_Vertices_of C313 ));

thus L1068: thesis by L1067 , L970;
end;
end;
thus L1070: thesis by L1063;
end;
end;
registration
let C316 being EVGraph;
let C317 , C318 being set;
cluster ( C316 .labelVertex (C317 , C318) ) ->  [ELabeled];
coherence
proof
L1072:
now
per cases ;
suppose L1073: C317 in ( the_Vertices_of C316 );

L1074: ( C316 .labelVertex (C317 , C318) ) = ( C316 .set (( VLabelSelector ) , ( ( the_VLabel_of C316 ) +* ( C317 .--> C318 ) )) ) by L1073 , L970;
thus L1075: thesis by L1074;
end;
suppose L1076: (not C317 in ( the_Vertices_of C316 ));

thus L1077: thesis by L1076 , L970;
end;
end;
thus L1079: thesis by L1072;
end;
end;
registration
let C319 being  real-weighted WVGraph;
let C320 , C321 being set;
cluster ( C319 .labelVertex (C320 , C321) ) ->  real-weighted;
coherence
proof
L1081:
now
per cases ;
suppose L1082: C320 in ( the_Vertices_of C319 );

L1083: ( C319 .labelVertex (C320 , C321) ) = ( C319 .set (( VLabelSelector ) , ( ( the_VLabel_of C319 ) +* ( C320 .--> C321 ) )) ) by L1082 , L970;
thus L1084: thesis by L1083;
end;
suppose L1085: (not C320 in ( the_Vertices_of C319 ));

thus L1086: thesis by L1085 , L970;
end;
end;
thus L1088: thesis by L1081;
end;
end;
registration
let C322 being  nonnegative-weighted WVGraph;
let C323 , C324 being set;
cluster ( C322 .labelVertex (C323 , C324) ) ->  nonnegative-weighted;
coherence
proof
L1090:
now
per cases ;
suppose L1091: C323 in ( the_Vertices_of C322 );

L1092: ( C322 .labelVertex (C323 , C324) ) = ( C322 .set (( VLabelSelector ) , ( ( the_VLabel_of C322 ) +* ( C323 .--> C324 ) )) ) by L1091 , L970;
thus L1093: thesis by L1092;
end;
suppose L1094: (not C323 in ( the_Vertices_of C322 ));

thus L1095: thesis by L1094 , L970;
end;
end;
thus L1097: thesis by L1090;
end;
end;
registration
let C325 being  real-elabeled EVGraph;
let C326 , C327 being set;
cluster ( C325 .labelVertex (C326 , C327) ) ->  real-elabeled;
coherence
proof
L1099:
now
per cases ;
suppose L1100: C326 in ( the_Vertices_of C325 );

L1101: ( C325 .labelVertex (C326 , C327) ) = ( C325 .set (( VLabelSelector ) , ( ( the_VLabel_of C325 ) +* ( C326 .--> C327 ) )) ) by L1100 , L970;
thus L1102: thesis by L1101;
end;
suppose L1103: (not C326 in ( the_Vertices_of C325 ));

thus L1104: thesis by L1103 , L970;
end;
end;
thus L1106: thesis by L1099;
end;
end;
registration
let C328 being  real-vlabeled VGraph;
let C329 being set;
let C330 being Real;
cluster ( C328 .labelVertex (C329 , C330) ) ->  real-vlabeled;
coherence
proof
L1108:
now
per cases ;
suppose L1109: C329 in ( the_Vertices_of C328 );

set D213 = ( ( the_VLabel_of C328 ) +* ( C329 .--> C330 ) );
L1110: ( rng ( the_VLabel_of C328 ) ) c= ( REAL );
L1111: ( the_VLabel_of C328 ) is (PartFunc of ( dom ( the_VLabel_of C328 ) ) , ( REAL )) by L1110 , RELSET_1:4;
L1112: ( the_VLabel_of C328 ) is (PartFunc of ( the_Vertices_of C328 ) , ( REAL )) by L1111 , L256 , RELSET_1:5;
reconsider D214 = D213 as (PartFunc of ( the_Vertices_of C328 ) , ( REAL )) by L1112 , L1109 , L790;
L1113: ( C328 .labelVertex (C329 , C330) ) = ( C328 .set (( VLabelSelector ) , D214) ) by L1109 , L970;
thus L1114: thesis by L1113;
end;
suppose L1115: (not C329 in ( the_Vertices_of C328 ));

thus L1116: thesis by L1115 , L970;
end;
end;
thus L1118: thesis by L1108;
end;
end;
registration
let C331 being  real-weighted WGraph;
cluster  ->  real-weighted for (WSubgraph of C331);
coherence
proof
let C332 being (WSubgraph of C331);
set D215 = ( ( the_Weight_of C331 ) | ( the_Edges_of C332 ) );
L1120: ( the_Weight_of C332 ) = D215 by L421;
thus L1121: thesis by L1120 , L655;
end;
end;
registration
let C333 being  nonnegative-weighted WGraph;
cluster  ->  nonnegative-weighted for (WSubgraph of C333);
coherence
proof
let C334 being (WSubgraph of C333);
L1123:
now
let C335 being set;
L1124: ( rng ( the_Weight_of C333 ) ) c= ( Real>=0 ) by L657;
assume L1125: C335 in ( rng ( the_Weight_of C334 ) );
L1126: C335 in ( rng ( ( the_Weight_of C333 ) | ( the_Edges_of C334 ) ) ) by L1125 , L421;
L1127: ( rng ( ( the_Weight_of C333 ) | ( the_Edges_of C334 ) ) ) c= ( rng ( the_Weight_of C333 ) ) by RELAT_1:70;
L1128: C335 in ( rng ( the_Weight_of C333 ) ) by L1127 , L1126;
thus L1129: C335 in ( Real>=0 ) by L1128 , L1124;
end;
thus L1130: ( rng ( the_Weight_of C334 ) ) c= ( Real>=0 ) by L1123 , TARSKI:def 3;
end;
end;
registration
let C336 being  real-elabeled EGraph;
cluster  ->  real-elabeled for (ESubgraph of C336);
coherence
proof
let C337 being (ESubgraph of C336);
L1132: ( the_ELabel_of C337 ) = ( ( the_ELabel_of C336 ) | ( the_Edges_of C337 ) ) by L423;
thus L1133: thesis by L1132 , L665;
end;
end;
registration
let C338 being  real-vlabeled VGraph;
cluster  ->  real-vlabeled for (VSubgraph of C338);
coherence
proof
let C339 being (VSubgraph of C338);
L1135: ( the_VLabel_of C339 ) = ( ( the_VLabel_of C338 ) | ( the_Vertices_of C339 ) ) by L425;
thus L1136: thesis by L1135 , L667;
end;
end;
definition
let C340 being GraphSeq;
attr C340 is  [Weighted]
means
:L1138: (for B49 being Nat holds ( C340 . B49 ) is  [Weighted]);
attr C340 is  [ELabeled]
means
:L1139: (for B50 being Nat holds ( C340 . B50 ) is  [ELabeled]);
attr C340 is  [VLabeled]
means
:L1140: (for B51 being Nat holds ( C340 . B51 ) is  [VLabeled]);
end;
registration
cluster  [Weighted]  [ELabeled]  [VLabeled] for GraphSeq;
existence
proof
set D216 = the  finite  loopless  trivial  non-multi  simple  real-WEV  nonnegative-weighted WEVGraph;
set D217 = ( ( NAT ) --> D216 );
L1142: ( dom D217 ) = ( NAT ) by FUNCOP_1:13;
reconsider D218 = D217 as (ManySortedSet of ( NAT ));
L1143:
now
let C341 being Nat;
L1144: C341 in ( NAT ) by ORDINAL1:def 12;
L1145: ( D218 . C341 ) in ( rng D218 ) by L1144 , L1142 , FUNCT_1:3;
L1146: ( D218 . C341 ) in { D216 } by L1145 , FUNCOP_1:8;
thus L1147: ( D218 . C341 ) is _Graph by L1146 , TARSKI:def 1;
end;
reconsider D219 = D218 as GraphSeq by L1143 , GLIB_000:def 53;
take D219;
L1148:
now
let C342 being Nat;
L1149: C342 in ( NAT ) by ORDINAL1:def 12;
L1150: ( D219 . C342 ) in ( rng D219 ) by L1149 , L1142 , FUNCT_1:3;
L1151: ( D219 . C342 ) in { D216 } by L1150 , FUNCOP_1:8;
thus L1152: (( D219 . C342 ) is  [Weighted] & ( D219 . C342 ) is  [ELabeled] & ( D219 . C342 ) is  [VLabeled]) by L1151 , TARSKI:def 1;
end;
thus L1153: thesis by L1148 , L1138 , L1139 , L1140;
end;
end;
definition
mode WGraphSeq
 is  [Weighted] GraphSeq;
mode EGraphSeq
 is  [ELabeled] GraphSeq;
mode VGraphSeq
 is  [VLabeled] GraphSeq;
mode WEGraphSeq
 is  [Weighted]  [ELabeled] GraphSeq;
mode WVGraphSeq
 is  [Weighted]  [VLabeled] GraphSeq;
mode EVGraphSeq
 is  [ELabeled]  [VLabeled] GraphSeq;
mode WEVGraphSeq
 is  [Weighted]  [ELabeled]  [VLabeled] GraphSeq;
end;
registration
let C343 being WGraphSeq;
let C344 being Nat;
cluster ( C343 . C344 ) ->  [Weighted] for _Graph;
coherence by L1138;
end;
registration
let C345 being EGraphSeq;
let C346 being Nat;
cluster ( C345 . C346 ) ->  [ELabeled] for _Graph;
coherence by L1139;
end;
registration
let C347 being VGraphSeq;
let C348 being Nat;
cluster ( C347 . C348 ) ->  [VLabeled] for _Graph;
coherence by L1140;
end;
definition
let C349 being WGraphSeq;
attr C349 is  real-weighted
means
:L1159: (for B52 being Nat holds ( C349 . B52 ) is  real-weighted);
attr C349 is  nonnegative-weighted
means
:L1160: (for B53 being Nat holds ( C349 . B53 ) is  nonnegative-weighted);
end;
definition
let C350 being EGraphSeq;
attr C350 is  real-elabeled
means
:L1162: (for B54 being Nat holds ( C350 . B54 ) is  real-elabeled);
end;
definition
let C351 being VGraphSeq;
attr C351 is  real-vlabeled
means
:L1164: (for B55 being Nat holds ( C351 . B55 ) is  real-vlabeled);
end;
definition
let C352 being WEVGraphSeq;
attr C352 is  real-WEV
means
:L1166: (for B56 being Nat holds ( C352 . B56 ) is  real-WEV);
end;
registration
cluster  real-WEV ->  real-weighted  real-elabeled  real-vlabeled for WEVGraphSeq;
coherence
proof
let C353 being  [Weighted]  [ELabeled]  [VLabeled] GraphSeq;
assume L1168: (for B57 being Nat holds ( C353 . B57 ) is  real-WEV);
L1169:
now
let C354 being Nat;
reconsider D220 = ( C353 . C354 ) as  real-WEV WEVGraph by L1168;
L1170: D220 is  real-WEV;
thus L1171: ( C353 . C354 ) is  real-weighted by L1170;
end;
thus L1172: C353 is  real-weighted by L1169 , L1159;
L1173:
now
let C355 being Nat;
reconsider D221 = ( C353 . C355 ) as  real-WEV WEVGraph by L1168;
L1174: D221 is  real-WEV;
thus L1175: ( C353 . C355 ) is  real-elabeled by L1174;
end;
thus L1176: C353 is  real-elabeled by L1173 , L1162;
L1177:
now
let C356 being Nat;
reconsider D222 = ( C353 . C356 ) as  real-WEV WEVGraph by L1168;
L1178: D222 is  real-WEV;
thus L1179: ( C353 . C356 ) is  real-vlabeled by L1178;
end;
thus L1180: thesis by L1177 , L1164;
end;
cluster  real-weighted  real-elabeled  real-vlabeled ->  real-WEV for WEVGraphSeq;
coherence
proof
let C357 being  [Weighted]  [ELabeled]  [VLabeled] GraphSeq;
assume L1181: (C357 is  real-weighted & C357 is  real-elabeled & C357 is  real-vlabeled);
let C358 being Nat;
reconsider D223 = ( C357 . C358 ) as  real-weighted  real-elabeled  real-vlabeled WEVGraph by L1181 , L1159 , L1162 , L1164;
L1182: D223 is  real-WEV;
thus L1183: thesis by L1182;
end;
end;
registration
cluster  halting  finite  loopless  trivial  non-multi  simple  real-WEV  nonnegative-weighted  Tree-like for WEVGraphSeq;
existence
proof
set D224 = the  finite  loopless  trivial  non-multi  simple  real-WEV  acyclic  connected  Tree-like  nonnegative-weighted WEVGraph;
set D225 = ( ( NAT ) --> D224 );
L1185: ( dom D225 ) = ( NAT ) by FUNCOP_1:13;
reconsider D226 = D225 as (ManySortedSet of ( NAT ));
L1186:
now
let C359 being Nat;
L1187: C359 in ( NAT ) by ORDINAL1:def 12;
L1188: ( D226 . C359 ) in ( rng D226 ) by L1187 , L1185 , FUNCT_1:3;
L1189: ( D226 . C359 ) in { D224 } by L1188 , FUNCOP_1:8;
thus L1190: ( D226 . C359 ) is _Graph by L1189 , TARSKI:def 1;
end;
reconsider D227 = D226 as GraphSeq by L1186 , GLIB_000:def 53;
L1191:
now
let C360 being Nat;
L1192: C360 in ( NAT ) by ORDINAL1:def 12;
L1193: ( D227 . C360 ) in ( rng D227 ) by L1192 , L1185 , FUNCT_1:3;
L1194: ( D227 . C360 ) in { D224 } by L1193 , FUNCOP_1:8;
thus L1195: (( D227 . C360 ) is  [Weighted] & ( D227 . C360 ) is  [ELabeled] & ( D227 . C360 ) is  [VLabeled]) by L1194 , TARSKI:def 1;
end;
reconsider D228 = D227 as  [Weighted]  [ELabeled]  [VLabeled] GraphSeq by L1191 , L1138 , L1139 , L1140;
L1196: ( D228 . ( 1 + 1 ) ) in ( rng D228 ) by L1185 , FUNCT_1:3;
L1197: ( D228 . ( 1 + 1 ) ) in { D224 } by L1196 , FUNCOP_1:8;
L1198: ( D228 . ( 1 + 1 ) ) = D224 by L1197 , TARSKI:def 1;
take D228;
L1199: ( D228 . 1 ) in ( rng D228 ) by L1185 , FUNCT_1:3;
L1200: ( D228 . 1 ) in { D224 } by L1199 , FUNCOP_1:8;
L1201: ( D228 . 1 ) = D224 by L1200 , TARSKI:def 1;
thus L1202: D228 is  halting by L1201 , L1198 , GLIB_000:def 54;
L1203:
now
let C361 being Nat;
L1204: C361 in ( NAT ) by ORDINAL1:def 12;
L1205: ( D228 . C361 ) in ( rng D228 ) by L1204 , L1185 , FUNCT_1:3;
L1206: ( D228 . C361 ) in { D224 } by L1205 , FUNCOP_1:8;
thus L1207: (( D228 . C361 ) is  finite & ( D228 . C361 ) is  loopless & ( D228 . C361 ) is  trivial & ( D228 . C361 ) is  non-multi & ( D228 . C361 ) is  simple & ( D228 . C361 ) is  real-WEV & ( D228 . C361 ) is  nonnegative-weighted & ( D228 . C361 ) is  Tree-like) by L1206 , TARSKI:def 1;
end;
thus L1208: thesis by L1203 , L1160 , L1166 , GLIB_000:def 57 , GLIB_000:def 58 , GLIB_000:def 59 , GLIB_000:def 61 , GLIB_000:def 63 , GLIB_002:def 14;
end;
end;
registration
let C362 being  real-weighted WGraphSeq;
let C363 being Nat;
cluster ( C362 . C363 ) ->  real-weighted for WGraph;
coherence by L1159;
end;
registration
let C364 being  nonnegative-weighted WGraphSeq;
let C365 being Nat;
cluster ( C364 . C365 ) ->  nonnegative-weighted for WGraph;
coherence by L1160;
end;
registration
let C366 being  real-elabeled EGraphSeq;
let C367 being Nat;
cluster ( C366 . C367 ) ->  real-elabeled for EGraph;
coherence by L1162;
end;
registration
let C368 being  real-vlabeled VGraphSeq;
let C369 being Nat;
cluster ( C368 . C369 ) ->  real-vlabeled for VGraph;
coherence by L1164;
end;
begin
theorem
L1214: (( WeightSelector ) = 5 & ( ELabelSelector ) = 6 & ( VLabelSelector ) = 7);
theorem
L1215: ((for B58 being WGraph holds ( the_Weight_of B58 ) = ( B58 . ( WeightSelector ) )) & (for B59 being EGraph holds ( the_ELabel_of B59 ) = ( B59 . ( ELabelSelector ) )) & (for B60 being VGraph holds ( the_VLabel_of B60 ) = ( B60 . ( VLabelSelector ) )));
theorem
L1216: (for B61 being EGraph holds ( dom ( the_ELabel_of B61 ) ) c= ( the_Edges_of B61 )) by L253;
theorem
L1217: (for B62 being VGraph holds ( dom ( the_VLabel_of B62 ) ) c= ( the_Vertices_of B62 )) by L256;
theorem
L1218: (for B63 being _Graph holds (for B64 being set holds (B63 == ( B63 .set (( WeightSelector ) , B64) ) & B63 == ( B63 .set (( ELabelSelector ) , B64) ) & B63 == ( B63 .set (( VLabelSelector ) , B64) )))) by L266;
theorem
L1219: (for B65 , B66 being WGraph holds (for B67 being WGraph holds ((B65 == B66 & ( the_Weight_of B65 ) = ( the_Weight_of B66 ) & B65 is (WSubgraph of B67)) implies B66 is (WSubgraph of B67))))
proof
let C370 , C371 being WGraph;
let C372 being WGraph;
assume that
L1220: C370 == C371
and
L1221: ( the_Weight_of C370 ) = ( the_Weight_of C371 )
and
L1222: C370 is (WSubgraph of C372);
reconsider D229 = C371 as  [Weighted] (Subgraph of C372) by L1220 , L1222 , GLIB_000:92;
L1223: ( the_Edges_of C370 ) = ( the_Edges_of C371 ) by L1220 , GLIB_000:def 34;
L1224: ( the_Weight_of C371 ) = ( ( the_Weight_of C372 ) | ( the_Edges_of C371 ) ) by L1223 , L1221 , L1222 , L421;
L1225: D229 is  weight-inheriting by L1224 , L421;
thus L1226: thesis by L1225;
end;
theorem
L1227: (for B68 being WGraph holds (for B69 being (WSubgraph of B68) holds (for B70 being (WSubgraph of B69) holds B70 is (WSubgraph of B68))))
proof
let C373 being WGraph;
let C374 being (WSubgraph of C373);
let C375 being (WSubgraph of C374);
reconsider D230 = C375 as  [Weighted] (Subgraph of C373) by GLIB_000:43;
L1228: ( the_Weight_of C375 ) = ( ( the_Weight_of C374 ) | ( the_Edges_of C375 ) ) by L421
.= ( ( ( the_Weight_of C373 ) | ( the_Edges_of C374 ) ) | ( the_Edges_of C375 ) ) by L421
.= ( ( the_Weight_of C373 ) | ( the_Edges_of C375 ) ) by RELAT_1:74;
L1229: D230 is  weight-inheriting by L1228 , L421;
thus L1230: thesis by L1229;
end;
theorem
L1231: (for B71 , B72 being WGraph holds (for B73 being (WSubgraph of B71) holds ((B71 == B72 & ( the_Weight_of B71 ) = ( the_Weight_of B72 )) implies B73 is (WSubgraph of B72))))
proof
let C376 , C377 being WGraph;
let C378 being (WSubgraph of C376);
assume that
L1232: C376 == C377
and
L1233: ( the_Weight_of C376 ) = ( the_Weight_of C377 );
reconsider D231 = C378 as  [Weighted] (Subgraph of C377) by L1232 , GLIB_000:91;
L1234: ( the_Weight_of C378 ) = ( ( the_Weight_of C377 ) | ( the_Edges_of C378 ) ) by L1233 , L421;
L1235: D231 is (WSubgraph of C377) by L1234 , L421;
thus L1236: thesis by L1235;
end;
theorem
L1237: (for B74 being WGraph holds (for B75 being (WSubgraph of B74) holds (for B76 being set holds (B76 in ( the_Edges_of B75 ) implies ( ( the_Weight_of B75 ) . B76 ) = ( ( the_Weight_of B74 ) . B76 )))))
proof
let C379 being WGraph;
let C380 being (WSubgraph of C379);
let C381 being set;
assume L1238: C381 in ( the_Edges_of C380 );
L1239: C381 in ( dom ( the_Weight_of C380 ) ) by L1238 , PARTFUN1:def 2;
L1240: ( the_Weight_of C380 ) = ( ( the_Weight_of C379 ) | ( the_Edges_of C380 ) ) by L421;
thus L1241: thesis by L1240 , L1239 , FUNCT_1:47;
end;
theorem
L1242: (for B77 being WGraph holds (for B78 being (Walk of B77) holds (B78 is  trivial implies ( B78 .weightSeq() ) = ( {} ))))
proof
let C382 being WGraph;
let C383 being (Walk of C382);
assume L1243: C383 is  trivial;
L1244: ( C383 .length() ) = ( 0 ) by L1243 , GLIB_001:def 26;
L1245: ( len ( C383 .edgeSeq() ) ) = ( 0 ) by L1244 , GLIB_001:def 18;
L1246: ( len ( C383 .weightSeq() ) ) = ( 0 ) by L1245 , L764;
thus L1247: thesis by L1246;
end;
theorem
L1248: (for B79 being WGraph holds (for B80 being (Walk of B79) holds ( len ( B80 .weightSeq() ) ) = ( B80 .length() )))
proof
let C384 being WGraph;
let C385 being (Walk of C384);
thus L1249: ( len ( C385 .weightSeq() ) ) = ( len ( C385 .edgeSeq() ) ) by L764
.= ( C385 .length() ) by GLIB_001:def 18;
end;
theorem
L1250: (for B81 being WGraph holds (for B82 , B83 , B84 being set holds (B84 Joins B82 , B83 , B81 implies ( ( B81 .walkOf (B82 , B84 , B83) ) .weightSeq() ) = <* ( ( the_Weight_of B81 ) . B84 ) *>)))
proof
let C386 being WGraph;
let C387 , C388 , C389 being set;
set D232 = ( C386 .walkOf (C387 , C389 , C388) );
assume L1251: C389 Joins C387 , C388 , C386;
L1252: ( D232 .edgeSeq() ) = <* C389 *> by L1251 , GLIB_001:83;
L1253: ( len ( D232 .edgeSeq() ) ) = 1 by L1252 , FINSEQ_1:39;
L1254: ( len ( D232 .weightSeq() ) ) = 1 by L1253 , L764;
L1255:
now
let C390 being Nat;
assume that
L1256: 1 <= C390
and
L1257: C390 <= ( len ( D232 .weightSeq() ) );
L1258: C390 = 1 by L1254 , L1256 , L1257 , XXREAL_0:1;
thus L1259: ( ( D232 .weightSeq() ) . C390 ) = ( ( the_Weight_of C386 ) . ( <* C389 *> . 1 ) ) by L1258 , L1252 , L1257 , L764
.= ( ( the_Weight_of C386 ) . C389 ) by FINSEQ_1:40
.= ( <* ( ( the_Weight_of C386 ) . C389 ) *> . C390 ) by L1258 , FINSEQ_1:40;
end;
L1260: ( len ( D232 .weightSeq() ) ) = ( len <* ( ( the_Weight_of C386 ) . C389 ) *> ) by L1254 , FINSEQ_1:39;
thus L1261: thesis by L1260 , L1255 , FINSEQ_1:14;
end;
theorem
L1262: (for B85 being WGraph holds (for B86 being (Walk of B85) holds ( ( B86 .reverse() ) .weightSeq() ) = ( Rev ( B86 .weightSeq() ) )))
proof
let C391 being WGraph;
let C392 being (Walk of C391);
set D233 = ( ( C392 .reverse() ) .weightSeq() );
set D234 = ( Rev ( C392 .weightSeq() ) );
L1263: ( len ( C392 .reverse() ) ) = ( len C392 ) by GLIB_001:21;
L1264: ( ( C392 .reverse() ) .length() ) = ( C392 .length() ) by L1263 , GLIB_001:113;
L1265: ( len ( ( C392 .reverse() ) .edgeSeq() ) ) = ( C392 .length() ) by L1264 , GLIB_001:def 18
.= ( len ( C392 .edgeSeq() ) ) by GLIB_001:def 18;
L1266: ( len D233 ) = ( len ( C392 .edgeSeq() ) ) by L1265 , L764;
L1267: ( len ( C392 .weightSeq() ) ) = ( len ( C392 .edgeSeq() ) ) by L764;
L1268:
now
let C393 being Nat;
assume that
L1269: 1 <= C393
and
L1270: C393 <= ( len D233 );
L1271: C393 in ( dom ( C392 .edgeSeq() ) ) by L1266 , L1269 , L1270 , FINSEQ_3:25;
set D235 = ( ( ( len ( C392 .weightSeq() ) ) - C393 ) + 1 );
reconsider D236 = D235 as (Element of ( NAT )) by L1266 , L1267 , L1270 , FINSEQ_5:1;
L1272: C393 in ( Seg ( len ( C392 .weightSeq() ) ) ) by L1266 , L1267 , L1269 , L1270 , FINSEQ_1:1;
L1273: D236 in ( Seg ( len ( C392 .weightSeq() ) ) ) by L1272 , FINSEQ_5:2;
L1274: (1 <= D236 & D236 <= ( len ( C392 .weightSeq() ) )) by L1273 , FINSEQ_1:1;
L1275: ( D233 . C393 ) = ( ( the_Weight_of C391 ) . ( ( ( C392 .reverse() ) .edgeSeq() ) . C393 ) ) by L1269 , L1270 , L764
.= ( ( the_Weight_of C391 ) . ( ( Rev ( C392 .edgeSeq() ) ) . C393 ) ) by GLIB_001:84;
L1276: ( D233 . C393 ) = ( ( the_Weight_of C391 ) . ( ( C392 .edgeSeq() ) . ( ( ( len ( C392 .edgeSeq() ) ) - C393 ) + 1 ) ) ) by L1275 , L1271 , FINSEQ_5:58;
L1277: C393 in ( dom ( C392 .weightSeq() ) ) by L1266 , L1267 , L1269 , L1270 , FINSEQ_3:25;
L1278: ( D234 . C393 ) = ( ( C392 .weightSeq() ) . D236 ) by L1277 , FINSEQ_5:58
.= ( ( the_Weight_of C391 ) . ( ( C392 .edgeSeq() ) . D236 ) ) by L1274 , L764;
thus L1279: ( D233 . C393 ) = ( D234 . C393 ) by L1278 , L1276 , L764;
end;
L1280: ( len D233 ) = ( len D234 ) by L1266 , L1267 , FINSEQ_5:def 3;
thus L1281: thesis by L1280 , L1268 , FINSEQ_1:14;
end;
theorem
L1282: (for B87 being WGraph holds (for B88 , B89 being (Walk of B87) holds (( B88 .last() ) = ( B89 .first() ) implies ( ( B88 .append B89 ) .weightSeq() ) = ( ( B88 .weightSeq() ) ^ ( B89 .weightSeq() ) ))))
proof
let C394 being WGraph;
let C395 , C396 being (Walk of C394);
set D237 = ( C395 .append C396 );
set D238 = ( ( C395 .weightSeq() ) ^ ( C396 .weightSeq() ) );
assume L1283: ( C395 .last() ) = ( C396 .first() );
L1284: ( D237 .edgeSeq() ) = ( ( C395 .edgeSeq() ) ^ ( C396 .edgeSeq() ) ) by L1283 , GLIB_001:85;
L1285: ( len ( D237 .edgeSeq() ) ) = ( ( len ( C395 .edgeSeq() ) ) + ( len ( C396 .edgeSeq() ) ) ) by L1284 , FINSEQ_1:22;
L1286: ( len ( D237 .weightSeq() ) ) = ( ( len ( C395 .edgeSeq() ) ) + ( len ( C396 .edgeSeq() ) ) ) by L1285 , L764
.= ( ( len ( C395 .weightSeq() ) ) + ( len ( C396 .edgeSeq() ) ) ) by L764
.= ( ( len ( C395 .weightSeq() ) ) + ( len ( C396 .weightSeq() ) ) ) by L764
.= ( len D238 ) by FINSEQ_1:22;
L1287:
now
let C397 being Nat;
assume L1288: (1 <= C397 & C397 <= ( len ( D237 .weightSeq() ) ));
L1289: ( ( D237 .weightSeq() ) . C397 ) = ( ( the_Weight_of C394 ) . ( ( D237 .edgeSeq() ) . C397 ) ) by L1288 , L764
.= ( ( the_Weight_of C394 ) . ( ( ( C395 .edgeSeq() ) ^ ( C396 .edgeSeq() ) ) . C397 ) ) by L1283 , GLIB_001:85;
L1290: C397 in ( dom D238 ) by L1286 , L1288 , FINSEQ_3:25;
L1291:
now
per cases  by L1290 , FINSEQ_1:25;
suppose L1292: C397 in ( dom ( C395 .weightSeq() ) );

L1293: 1 <= C397 by L1292 , FINSEQ_3:25;
L1294: C397 <= ( len ( C395 .weightSeq() ) ) by L1292 , FINSEQ_3:25;
L1295: C397 <= ( len ( C395 .edgeSeq() ) ) by L1294 , L764;
L1296: C397 in ( dom ( C395 .edgeSeq() ) ) by L1295 , L1293 , FINSEQ_3:25;
L1297: ( D238 . C397 ) = ( ( C395 .weightSeq() ) . C397 ) by L1292 , FINSEQ_1:def 7
.= ( ( the_Weight_of C394 ) . ( ( C395 .edgeSeq() ) . C397 ) ) by L1293 , L1294 , L764;
thus L1298: ( ( D237 .weightSeq() ) . C397 ) = ( D238 . C397 ) by L1297 , L1289 , L1296 , FINSEQ_1:def 7;
end;
suppose L1299: (ex B90 being Nat st (B90 in ( dom ( C396 .weightSeq() ) ) & C397 = ( ( len ( C395 .weightSeq() ) ) + B90 )));

consider C398 being Nat such that L1300: C398 in ( dom ( C396 .weightSeq() ) ) and L1301: C397 = ( ( len ( C395 .weightSeq() ) ) + C398 ) by L1299;
L1302: 1 <= C398 by L1300 , FINSEQ_3:25;
L1303: C398 <= ( len ( C396 .weightSeq() ) ) by L1300 , FINSEQ_3:25;
L1304: C398 <= ( len ( C396 .edgeSeq() ) ) by L1303 , L764;
L1305: C398 in ( dom ( C396 .edgeSeq() ) ) by L1304 , L1302 , FINSEQ_3:25;
L1306: C397 = ( ( len ( C395 .edgeSeq() ) ) + C398 ) by L1301 , L764;
L1307: ( D238 . C397 ) = ( ( C396 .weightSeq() ) . C398 ) by L1300 , L1301 , FINSEQ_1:def 7
.= ( ( the_Weight_of C394 ) . ( ( C396 .edgeSeq() ) . C398 ) ) by L1302 , L1303 , L764;
thus L1308: ( ( D237 .weightSeq() ) . C397 ) = ( D238 . C397 ) by L1307 , L1289 , L1305 , L1306 , FINSEQ_1:def 7;
end;
end;
thus L1310: ( ( D237 .weightSeq() ) . C397 ) = ( D238 . C397 ) by L1291;
end;
thus L1311: thesis by L1287 , L1286 , FINSEQ_1:14;
end;
theorem
L1312: (for B91 being WGraph holds (for B92 being (Walk of B91) holds (for B93 being set holds (B93 in ( ( B92 .last() ) .edgesInOut() ) implies ( ( B92 .addEdge B93 ) .weightSeq() ) = ( ( B92 .weightSeq() ) ^ <* ( ( the_Weight_of B91 ) . B93 ) *> )))))
proof
let C399 being WGraph;
let C400 being (Walk of C399);
let C401 being set;
set D239 = ( C400 .addEdge C401 );
set D240 = ( C399 .walkOf (( C400 .last() ) , C401 , ( ( C400 .last() ) .adj C401 )) );
assume L1313: C401 in ( ( C400 .last() ) .edgesInOut() );
L1314: C401 Joins ( C400 .last() ) , ( ( C400 .last() ) .adj C401 ) , C399 by L1313 , GLIB_000:67;
L1315: (D239 = ( C400 .append D240 ) & ( C400 .last() ) = ( D240 .first() )) by L1314 , GLIB_001:15 , GLIB_001:def 13;
thus L1316: ( D239 .weightSeq() ) = ( ( C400 .weightSeq() ) ^ ( D240 .weightSeq() ) ) by L1315 , L1282
.= ( ( C400 .weightSeq() ) ^ <* ( ( the_Weight_of C399 ) . C401 ) *> ) by L1314 , L1250;
end;
theorem
L1317: (for B94 being  real-weighted WGraph holds (for B95 being (Walk of B94) holds (for B96 being (Subwalk of B95) holds (ex B97 being (Subset of ( B95 .weightSeq() )) st ( B96 .weightSeq() ) = ( Seq B97 )))))
proof
let C402 being  real-weighted WGraph;
let C403 being (Walk of C402);
let C404 being (Subwalk of C403);
consider C405 being (Subset of ( C403 .edgeSeq() )) such that L1318: ( C404 .edgeSeq() ) = ( Seq C405 ) by GLIB_001:def 32;
deffunc H2(set) = ( ( the_Weight_of C402 ) . ( C405 . $1 ) );
consider C406 being Function such that L1319: (( dom C406 ) = ( dom C405 ) & (for B98 being set holds (B98 in ( dom C405 ) implies ( C406 . B98 ) = H2(B98)))) from FUNCT_1:sch 3;
L1320: (ex B99 being Nat st ( dom C406 ) c= ( Seg B99 )) by L1319 , FINSEQ_1:def 12;
reconsider D241 = C406 as FinSubsequence by L1320 , FINSEQ_1:def 12;
L1321:
now
let C407 being set;
assume L1322: C407 in D241;
consider C408 , C409 being set such that L1323: C407 = [ C408 , C409 ] by L1322 , RELAT_1:def 1;
L1324: C408 in ( dom C405 ) by L1319 , L1322 , L1323 , FUNCT_1:1;
L1325: [ C408 , ( C405 . C408 ) ] in C405 by L1324 , FUNCT_1:1;
L1326: C408 in ( dom ( C403 .edgeSeq() ) ) by L1325 , FUNCT_1:1;
L1327: ( D241 . C408 ) = C409 by L1322 , L1323 , FUNCT_1:1;
reconsider D242 = C408 as (Element of ( NAT )) by L1326;
L1328: D242 <= ( len ( C403 .edgeSeq() ) ) by L1326 , FINSEQ_3:25;
L1329: D242 <= ( len ( C403 .weightSeq() ) ) by L1328 , L764;
L1330: 1 <= D242 by L1326 , FINSEQ_3:25;
L1331: ( ( C403 .weightSeq() ) . D242 ) = ( ( the_Weight_of C402 ) . ( ( C403 .edgeSeq() ) . D242 ) ) by L1330 , L1329 , L764;
L1332: D242 in ( dom ( C403 .weightSeq() ) ) by L1330 , L1329 , FINSEQ_3:25;
L1333: [ D242 , ( ( C403 .weightSeq() ) . D242 ) ] in ( C403 .weightSeq() ) by L1332 , FUNCT_1:1;
L1334: C409 = ( ( the_Weight_of C402 ) . ( C405 . D242 ) ) by L1319 , L1324 , L1327;
thus L1335: C407 in ( C403 .weightSeq() ) by L1334 , L1323 , L1325 , L1333 , L1331 , FUNCT_1:1;
end;
reconsider D243 = D241 as (Subset of ( C403 .weightSeq() )) by L1321 , TARSKI:def 3;
take D243;
L1336: ( len ( Seq C405 ) ) = ( card C405 ) by GLIB_001:5
.= ( card ( dom D243 ) ) by L1319 , CARD_1:62
.= ( card D243 ) by CARD_1:62
.= ( len ( Seq D243 ) ) by GLIB_001:5;
L1337: ( len ( C404 .weightSeq() ) ) = ( len ( Seq D243 ) ) by L1336 , L1318 , L764;
L1338:
now
L1339: ( rng ( Sgm ( dom C405 ) ) ) = ( dom C405 ) by L1319 , L1320 , FINSEQ_1:def 13;
let C410 being Nat;
L1340: ( Seq D243 ) = ( D243 * ( Sgm ( dom C405 ) ) ) by L1319 , FINSEQ_1:def 14;
assume L1341: (1 <= C410 & C410 <= ( len ( C404 .weightSeq() ) ));
L1342: (( Seq C405 ) = ( C405 * ( Sgm ( dom C405 ) ) ) & C410 in ( dom ( Seq C405 ) )) by L1341 , L1336 , L1337 , FINSEQ_1:def 14 , FINSEQ_3:25;
L1343: C410 in ( dom ( Seq D243 ) ) by L1337 , L1341 , FINSEQ_3:25;
L1344: C410 in ( dom ( Sgm ( dom C405 ) ) ) by L1343 , L1340 , FUNCT_1:11;
L1345: ( ( Sgm ( dom C405 ) ) . C410 ) in ( dom C405 ) by L1344 , L1339 , FUNCT_1:def 3;
L1346: ( ( Seq D243 ) . C410 ) = ( D243 . ( ( Sgm ( dom C405 ) ) . C410 ) ) by L1340 , L1343 , FUNCT_1:12
.= ( ( the_Weight_of C402 ) . ( C405 . ( ( Sgm ( dom C405 ) ) . C410 ) ) ) by L1319 , L1345
.= ( ( the_Weight_of C402 ) . ( ( Seq C405 ) . C410 ) ) by L1342 , FUNCT_1:12;
thus L1347: ( ( C404 .weightSeq() ) . C410 ) = ( ( Seq D243 ) . C410 ) by L1346 , L1318 , L1341 , L764;
end;
thus L1348: thesis by L1338 , L1337 , FINSEQ_1:14;
end;
theorem
L1349: (for B100 , B101 being WGraph holds (for B102 being (Walk of B100) holds (for B103 being (Walk of B101) holds ((B102 = B103 & ( the_Weight_of B100 ) = ( the_Weight_of B101 )) implies ( B102 .weightSeq() ) = ( B103 .weightSeq() )))))
proof
let C411 , C412 being WGraph;
let C413 being (Walk of C411);
let C414 being (Walk of C412);
assume that
L1350: C413 = C414
and
L1351: ( the_Weight_of C411 ) = ( the_Weight_of C412 );
set D244 = ( C413 .weightSeq() );
set D245 = ( C414 .weightSeq() );
L1352: ( C413 .edgeSeq() ) = ( C414 .edgeSeq() ) by L1350 , GLIB_001:86;
L1353:
now
thus L1354: ( len D244 ) = ( len D244 );
thus L1355: ( len D245 ) = ( len ( C413 .edgeSeq() ) ) by L1352 , L764
.= ( len D244 ) by L764;
let C415 being Nat;
assume L1356: C415 in ( dom D244 );
L1357: 1 <= C415 by L1356 , FINSEQ_3:25;
L1358: C415 <= ( len D244 ) by L1356 , FINSEQ_3:25;
L1359: C415 <= ( len D245 ) by L1355 , L1356 , FINSEQ_3:25;
thus L1360: ( D245 . C415 ) = ( ( the_Weight_of C412 ) . ( ( C414 .edgeSeq() ) . C415 ) ) by L1359 , L1357 , L764
.= ( ( the_Weight_of C411 ) . ( ( C413 .edgeSeq() ) . C415 ) ) by L1350 , L1351 , GLIB_001:86
.= ( D244 . C415 ) by L1357 , L1358 , L764;
end;
thus L1361: thesis by L1353 , FINSEQ_2:9;
end;
theorem
L1362: (for B104 being WGraph holds (for B105 being (WSubgraph of B104) holds (for B106 being (Walk of B104) holds (for B107 being (Walk of B105) holds (B106 = B107 implies ( B106 .weightSeq() ) = ( B107 .weightSeq() ))))))
proof
let C416 being WGraph;
let C417 being (WSubgraph of C416);
let C418 being (Walk of C416);
let C419 being (Walk of C417);
set D246 = ( C418 .weightSeq() );
set D247 = ( C419 .weightSeq() );
assume L1363: C418 = C419;
L1364: ( C418 .edgeSeq() ) = ( C419 .edgeSeq() ) by L1363 , GLIB_001:86;
L1365:
now
thus L1366: ( len D246 ) = ( len D246 );
thus L1367: ( len D247 ) = ( len ( C418 .edgeSeq() ) ) by L1364 , L764
.= ( len D246 ) by L764;
let C420 being Nat;
assume L1368: C420 in ( dom D246 );
L1369: 1 <= C420 by L1368 , FINSEQ_3:25;
L1370: C420 <= ( len D247 ) by L1367 , L1368 , FINSEQ_3:25;
L1371: C420 <= ( len ( C419 .edgeSeq() ) ) by L1370 , L764;
L1372: C420 in ( dom ( C419 .edgeSeq() ) ) by L1371 , L1369 , FINSEQ_3:25;
L1373: C420 <= ( len D246 ) by L1368 , FINSEQ_3:25;
thus L1374: ( D247 . C420 ) = ( ( the_Weight_of C417 ) . ( ( C419 .edgeSeq() ) . C420 ) ) by L1369 , L1370 , L764
.= ( ( ( the_Weight_of C416 ) | ( the_Edges_of C417 ) ) . ( ( C419 .edgeSeq() ) . C420 ) ) by L421
.= ( ( the_Weight_of C416 ) . ( ( C418 .edgeSeq() ) . C420 ) ) by L1364 , L1372 , FUNCT_1:49 , GLIB_001:79
.= ( D246 . C420 ) by L1369 , L1373 , L764;
end;
thus L1375: thesis by L1365 , FINSEQ_2:9;
end;
theorem
L1376: (for B108 being  real-weighted WGraph holds (for B109 being (Walk of B108) holds (B109 is  trivial implies ( B109 .cost() ) = ( 0 )))) by L1242 , RVSUM_1:72;
theorem
L1377: (for B110 being  real-weighted WGraph holds (for B111 , B112 being (Vertex of B110) holds (for B113 being set holds (B113 Joins B111 , B112 , B110 implies ( ( B110 .walkOf (B111 , B113 , B112) ) .cost() ) = ( ( the_Weight_of B110 ) . B113 )))))
proof
let C421 being  real-weighted WGraph;
let C422 , C423 being (Vertex of C421);
let C424 being set;
set D248 = ( C421 .walkOf (C422 , C424 , C423) );
assume L1378: C424 Joins C422 , C423 , C421;
L1379: ( D248 .weightSeq() ) = <* ( ( the_Weight_of C421 ) . C424 ) *> by L1378 , L1250;
thus L1380: thesis by L1379 , FINSOP_1:11;
end;
theorem
L1381: (for B114 being  real-weighted WGraph holds (for B115 being (Walk of B114) holds ( B115 .cost() ) = ( ( B115 .reverse() ) .cost() )))
proof
let C425 being  real-weighted WGraph;
let C426 being (Walk of C425);
thus L1382: ( C426 .cost() ) = ( Sum ( Rev ( C426 .weightSeq() ) ) ) by POLYNOM3:3
.= ( ( C426 .reverse() ) .cost() ) by L1262;
end;
theorem
L1383: (for B116 being  real-weighted WGraph holds (for B117 , B118 being (Walk of B116) holds (( B117 .last() ) = ( B118 .first() ) implies ( ( B117 .append B118 ) .cost() ) = ( ( B117 .cost() ) + ( B118 .cost() ) ))))
proof
let C427 being  real-weighted WGraph;
let C428 , C429 being (Walk of C427);
set D249 = ( C428 .append C429 );
assume L1384: ( C428 .last() ) = ( C429 .first() );
L1385: ( D249 .weightSeq() ) = ( ( C428 .weightSeq() ) ^ ( C429 .weightSeq() ) ) by L1384 , L1282;
thus L1386: thesis by L1385 , RVSUM_1:75;
end;
theorem
L1387: (for B119 being  real-weighted WGraph holds (for B120 being (Walk of B119) holds (for B121 being set holds (B121 in ( ( B120 .last() ) .edgesInOut() ) implies ( ( B120 .addEdge B121 ) .cost() ) = ( ( B120 .cost() ) + ( ( the_Weight_of B119 ) . B121 ) )))))
proof
let C430 being  real-weighted WGraph;
let C431 being (Walk of C430);
let C432 being set;
set D250 = ( C431 .addEdge C432 );
assume L1388: C432 in ( ( C431 .last() ) .edgesInOut() );
L1389: ( D250 .weightSeq() ) = ( ( C431 .weightSeq() ) ^ <* ( ( the_Weight_of C430 ) . C432 ) *> ) by L1388 , L1312;
L1390: ( Sum ( D250 .weightSeq() ) ) = ( ( Sum ( C431 .weightSeq() ) ) + ( Sum <* ( ( the_Weight_of C430 ) . C432 ) *> ) ) by L1389 , RVSUM_1:75;
thus L1391: thesis by L1390 , FINSOP_1:11;
end;
theorem
L1392: (for B122 , B123 being  real-weighted WGraph holds (for B124 being (Walk of B122) holds (for B125 being (Walk of B123) holds ((B124 = B125 & ( the_Weight_of B122 ) = ( the_Weight_of B123 )) implies ( B124 .cost() ) = ( B125 .cost() ))))) by L1349;
theorem
L1393: (for B126 being  real-weighted WGraph holds (for B127 being (WSubgraph of B126) holds (for B128 being (Walk of B126) holds (for B129 being (Walk of B127) holds (B128 = B129 implies ( B128 .cost() ) = ( B129 .cost() )))))) by L1362;
theorem
L1394: (for B130 being  nonnegative-weighted WGraph holds (for B131 being (Walk of B130) holds (for B132 being (Element of ( NAT )) holds (B132 in ( dom ( B131 .weightSeq() ) ) implies ( 0 ) <= ( ( B131 .weightSeq() ) . B132 )))))
proof
let C433 being  nonnegative-weighted WGraph;
let C434 being (Walk of C433);
let C435 being (Element of ( NAT ));
set D251 = ( C434 .weightSeq() );
assume L1395: C435 in ( dom ( C434 .weightSeq() ) );
L1396: 1 <= C435 by L1395 , FINSEQ_3:25;
L1397: C435 <= ( len D251 ) by L1395 , FINSEQ_3:25;
L1398: C435 <= ( len ( C434 .edgeSeq() ) ) by L1397 , L764;
L1399: (( dom ( the_Weight_of C433 ) ) = ( the_Edges_of C433 ) & C435 in ( dom ( C434 .edgeSeq() ) )) by L1398 , L1396 , FINSEQ_3:25 , PARTFUN1:def 2;
L1400: ( ( C434 .edgeSeq() ) . C435 ) in ( dom ( the_Weight_of C433 ) ) by L1399 , GLIB_001:79;
L1401: ( D251 . C435 ) = ( ( the_Weight_of C433 ) . ( ( C434 .edgeSeq() ) . C435 ) ) by L1396 , L1397 , L764;
L1402: ( D251 . C435 ) in ( rng ( the_Weight_of C433 ) ) by L1401 , L1400 , FUNCT_1:def 3;
L1403: ( rng ( the_Weight_of C433 ) ) c= ( Real>=0 ) by L657;
L1404: ( D251 . C435 ) in ( Real>=0 ) by L1403 , L1402;
L1405: (ex B133 being Real st (B133 = ( D251 . C435 ) & B133 >= ( 0 ))) by L1404 , GRAPH_5:def 12;
thus L1406: thesis by L1405;
end;
theorem
L1407: (for B134 being  nonnegative-weighted WGraph holds (for B135 being (Walk of B134) holds ( 0 ) <= ( B135 .cost() )))
proof
let C436 being  nonnegative-weighted WGraph;
let C437 being (Walk of C436);
L1408: (for B136 being Nat holds (B136 in ( dom ( C437 .weightSeq() ) ) implies ( 0 ) <= ( ( C437 .weightSeq() ) . B136 ))) by L1394;
thus L1409: thesis by L1408 , RVSUM_1:84;
end;
theorem
L1410: (for B137 being  nonnegative-weighted WGraph holds (for B138 being (Walk of B137) holds (for B139 being (Subwalk of B138) holds ( B139 .cost() ) <= ( B138 .cost() ))))
proof
let C438 being  nonnegative-weighted WGraph;
let C439 being (Walk of C438);
let C440 being (Subwalk of C439);
L1411: ((ex B140 being (Subset of ( C439 .weightSeq() )) st ( C440 .weightSeq() ) = ( Seq B140 )) & (for B141 being (Element of ( NAT )) holds (B141 in ( dom ( C439 .weightSeq() ) ) implies ( 0 ) <= ( ( C439 .weightSeq() ) . B141 )))) by L1317 , L1394;
thus L1412: thesis by L1411 , L27;
end;
theorem
L1413: (for B142 being  nonnegative-weighted WGraph holds (for B143 being set holds (B143 in ( the_Edges_of B142 ) implies ( 0 ) <= ( ( the_Weight_of B142 ) . B143 ))))
proof
let C441 being  nonnegative-weighted WGraph;
let C442 being set;
assume L1414: C442 in ( the_Edges_of C441 );
L1415: C442 in ( dom ( the_Weight_of C441 ) ) by L1414 , PARTFUN1:def 2;
L1416: ( ( the_Weight_of C441 ) . C442 ) in ( rng ( the_Weight_of C441 ) ) by L1415 , FUNCT_1:3;
L1417: ( rng ( the_Weight_of C441 ) ) c= ( Real>=0 ) by L657;
L1418: ( ( the_Weight_of C441 ) . C442 ) in ( Real>=0 ) by L1417 , L1416;
L1419: (ex B144 being Real st (( ( the_Weight_of C441 ) . C442 ) = B144 & B144 >= ( 0 ))) by L1418 , GRAPH_5:def 12;
thus L1420: thesis by L1419;
end;
theorem
L1421: (for B145 being EGraph holds (for B146 , B147 being set holds (B146 in ( the_Edges_of B145 ) implies ( the_ELabel_of ( B145 .labelEdge (B146 , B147) ) ) = ( ( the_ELabel_of B145 ) +* ( B146 .--> B147 ) ))))
proof
let C443 being EGraph;
let C444 , C445 being set;
assume L1422: C444 in ( the_Edges_of C443 );
L1423: ( the_ELabel_of ( C443 .labelEdge (C444 , C445) ) ) = ( ( C443 .set (( ELabelSelector ) , ( ( the_ELabel_of C443 ) +* ( C444 .--> C445 ) )) ) . ( ELabelSelector ) ) by L1422 , L819;
thus L1424: thesis by L1423 , GLIB_000:8;
end;
theorem
L1425: (for B148 being EGraph holds (for B149 , B150 being set holds (B149 in ( the_Edges_of B148 ) implies ( ( the_ELabel_of ( B148 .labelEdge (B149 , B150) ) ) . B149 ) = B150)))
proof
let C446 being EGraph;
let C447 , C448 being set;
L1426: C447 in { C447 } by TARSKI:def 1;
L1427: C447 in ( dom ( C447 .--> C448 ) ) by L1426 , FUNCOP_1:13;
assume L1428: C447 in ( the_Edges_of C446 );
L1429: ( the_ELabel_of ( C446 .labelEdge (C447 , C448) ) ) = ( ( the_ELabel_of C446 ) +* ( C447 .--> C448 ) ) by L1428 , L1421;
L1430: ( ( the_ELabel_of ( C446 .labelEdge (C447 , C448) ) ) . C447 ) = ( ( C447 .--> C448 ) . C447 ) by L1429 , L1427 , FUNCT_4:13
.= C448 by FUNCOP_1:72;
thus L1431: thesis by L1430;
end;
theorem
L1432: (for B151 being EGraph holds (for B152 , B153 being set holds B151 == ( B151 .labelEdge (B152 , B153) )))
proof
let C449 being EGraph;
let C450 , C451 being set;
L1433:
now
per cases ;
suppose L1434: C450 in ( the_Edges_of C449 );

L1435: (not ( ELabelSelector ) in ( _GraphSelectors )) by ENUMSET1:def 2;
L1436: ( C449 .labelEdge (C450 , C451) ) = ( C449 .set (( ELabelSelector ) , ( ( the_ELabel_of C449 ) +* ( C450 .--> C451 ) )) ) by L1434 , L819;
L1437: (( the_Source_of C449 ) = ( the_Source_of ( C449 .labelEdge (C450 , C451) ) ) & ( the_Target_of C449 ) = ( the_Target_of ( C449 .labelEdge (C450 , C451) ) )) by L1436 , L1435 , GLIB_000:10;
L1438: (( the_Vertices_of C449 ) = ( the_Vertices_of ( C449 .labelEdge (C450 , C451) ) ) & ( the_Edges_of C449 ) = ( the_Edges_of ( C449 .labelEdge (C450 , C451) ) )) by L1436 , L1435 , GLIB_000:10;
thus L1439: thesis by L1438 , L1437 , GLIB_000:def 34;
end;
suppose L1440: (not C450 in ( the_Edges_of C449 ));

thus L1441: thesis by L1440 , L819;
end;
end;
thus L1443: thesis by L1433;
end;
theorem
L1444: (for B154 being WEGraph holds (for B155 , B156 being set holds ( the_Weight_of B154 ) = ( the_Weight_of ( B154 .labelEdge (B155 , B156) ) )))
proof
let C452 being WEGraph;
let C453 , C454 being set;
set D252 = ( C452 .labelEdge (C453 , C454) );
L1445:
now
per cases ;
suppose L1446: C453 in ( the_Edges_of C452 );

L1447: D252 = ( C452 .set (( ELabelSelector ) , ( ( the_ELabel_of C452 ) +* ( C453 .--> C454 ) )) ) by L1446 , L819;
thus L1448: thesis by L1447 , GLIB_000:9;
end;
suppose L1449: (not C453 in ( the_Edges_of C452 ));

thus L1450: thesis by L1449 , L819;
end;
end;
thus L1452: thesis by L1445;
end;
theorem
L1453: (for B157 being EVGraph holds (for B158 , B159 being set holds ( the_VLabel_of B157 ) = ( the_VLabel_of ( B157 .labelEdge (B158 , B159) ) )))
proof
let C455 being EVGraph;
let C456 , C457 being set;
set D253 = ( C455 .labelEdge (C456 , C457) );
L1454:
now
per cases ;
suppose L1455: C456 in ( the_Edges_of C455 );

L1456: D253 = ( C455 .set (( ELabelSelector ) , ( ( the_ELabel_of C455 ) +* ( C456 .--> C457 ) )) ) by L1455 , L819;
thus L1457: thesis by L1456 , GLIB_000:9;
end;
suppose L1458: (not C456 in ( the_Edges_of C455 ));

thus L1459: thesis by L1458 , L819;
end;
end;
thus L1461: thesis by L1454;
end;
theorem
L1462: (for B160 being EGraph holds (for B161 , B162 , B163 being set holds (B161 <> B162 implies ( ( the_ELabel_of ( B160 .labelEdge (B161 , B163) ) ) . B162 ) = ( ( the_ELabel_of B160 ) . B162 ))))
proof
let C458 being EGraph;
let C459 , C460 , C461 being set;
set D254 = ( C458 .labelEdge (C459 , C461) );
assume L1463: C459 <> C460;
L1464:
now
per cases ;
suppose L1465: C459 in ( the_Edges_of C458 );

L1466: (not C460 in { C459 }) by L1463 , TARSKI:def 1;
L1467: (not C460 in ( dom ( C459 .--> C461 ) )) by L1466;
L1468: ( the_ELabel_of D254 ) = ( ( the_ELabel_of C458 ) +* ( C459 .--> C461 ) ) by L1465 , L1421;
thus L1469: thesis by L1468 , L1467 , FUNCT_4:11;
end;
suppose L1470: (not C459 in ( the_Edges_of C458 ));

thus L1471: thesis by L1470 , L819;
end;
end;
thus L1473: thesis by L1464;
end;
theorem
L1474: (for B164 being VGraph holds (for B165 , B166 being set holds (B165 in ( the_Vertices_of B164 ) implies ( the_VLabel_of ( B164 .labelVertex (B165 , B166) ) ) = ( ( the_VLabel_of B164 ) +* ( B165 .--> B166 ) ))))
proof
let C462 being VGraph;
let C463 , C464 being set;
assume L1475: C463 in ( the_Vertices_of C462 );
L1476: ( the_VLabel_of ( C462 .labelVertex (C463 , C464) ) ) = ( ( C462 .set (( VLabelSelector ) , ( ( the_VLabel_of C462 ) +* ( C463 .--> C464 ) )) ) . ( VLabelSelector ) ) by L1475 , L970;
thus L1477: thesis by L1476 , GLIB_000:8;
end;
theorem
L1478: (for B167 being VGraph holds (for B168 , B169 being set holds (B168 in ( the_Vertices_of B167 ) implies ( ( the_VLabel_of ( B167 .labelVertex (B168 , B169) ) ) . B168 ) = B169)))
proof
let C465 being VGraph;
let C466 , C467 being set;
L1479: C466 in { C466 } by TARSKI:def 1;
L1480: C466 in ( dom ( C466 .--> C467 ) ) by L1479 , FUNCOP_1:13;
assume L1481: C466 in ( the_Vertices_of C465 );
L1482: ( the_VLabel_of ( C465 .labelVertex (C466 , C467) ) ) = ( ( the_VLabel_of C465 ) +* ( C466 .--> C467 ) ) by L1481 , L1474;
L1483: ( ( the_VLabel_of ( C465 .labelVertex (C466 , C467) ) ) . C466 ) = ( ( C466 .--> C467 ) . C466 ) by L1482 , L1480 , FUNCT_4:13
.= C467 by FUNCOP_1:72;
thus L1484: thesis by L1483;
end;
theorem
L1485: (for B170 being VGraph holds (for B171 , B172 being set holds B170 == ( B170 .labelVertex (B171 , B172) )))
proof
let C468 being VGraph;
let C469 , C470 being set;
L1486:
now
per cases ;
suppose L1487: C469 in ( the_Vertices_of C468 );

L1488: (not ( VLabelSelector ) in ( _GraphSelectors )) by ENUMSET1:def 2;
L1489: ( C468 .labelVertex (C469 , C470) ) = ( C468 .set (( VLabelSelector ) , ( ( the_VLabel_of C468 ) +* ( C469 .--> C470 ) )) ) by L1487 , L970;
L1490: (( the_Source_of C468 ) = ( the_Source_of ( C468 .labelVertex (C469 , C470) ) ) & ( the_Target_of C468 ) = ( the_Target_of ( C468 .labelVertex (C469 , C470) ) )) by L1489 , L1488 , GLIB_000:10;
L1491: (( the_Vertices_of C468 ) = ( the_Vertices_of ( C468 .labelVertex (C469 , C470) ) ) & ( the_Edges_of C468 ) = ( the_Edges_of ( C468 .labelVertex (C469 , C470) ) )) by L1489 , L1488 , GLIB_000:10;
thus L1492: thesis by L1491 , L1490 , GLIB_000:def 34;
end;
suppose L1493: (not C469 in ( the_Vertices_of C468 ));

thus L1494: thesis by L1493 , L970;
end;
end;
thus L1496: thesis by L1486;
end;
theorem
L1497: (for B173 being WVGraph holds (for B174 , B175 being set holds ( the_Weight_of B173 ) = ( the_Weight_of ( B173 .labelVertex (B174 , B175) ) )))
proof
let C471 being WVGraph;
let C472 , C473 being set;
set D255 = ( C471 .labelVertex (C472 , C473) );
L1498:
now
per cases ;
suppose L1499: C472 in ( the_Vertices_of C471 );

L1500: D255 = ( C471 .set (( VLabelSelector ) , ( ( the_VLabel_of C471 ) +* ( C472 .--> C473 ) )) ) by L1499 , L970;
thus L1501: thesis by L1500 , GLIB_000:9;
end;
suppose L1502: (not C472 in ( the_Vertices_of C471 ));

thus L1503: thesis by L1502 , L970;
end;
end;
thus L1505: thesis by L1498;
end;
theorem
L1506: (for B176 being EVGraph holds (for B177 , B178 being set holds ( the_ELabel_of B176 ) = ( the_ELabel_of ( B176 .labelVertex (B177 , B178) ) )))
proof
let C474 being EVGraph;
let C475 , C476 being set;
set D256 = ( C474 .labelVertex (C475 , C476) );
L1507:
now
per cases ;
suppose L1508: C475 in ( the_Vertices_of C474 );

L1509: D256 = ( C474 .set (( VLabelSelector ) , ( ( the_VLabel_of C474 ) +* ( C475 .--> C476 ) )) ) by L1508 , L970;
thus L1510: thesis by L1509 , GLIB_000:9;
end;
suppose L1511: (not C475 in ( the_Vertices_of C474 ));

thus L1512: thesis by L1511 , L970;
end;
end;
thus L1514: thesis by L1507;
end;
theorem
L1515: (for B179 being VGraph holds (for B180 , B181 , B182 being set holds (B180 <> B181 implies ( ( the_VLabel_of ( B179 .labelVertex (B180 , B182) ) ) . B181 ) = ( ( the_VLabel_of B179 ) . B181 ))))
proof
let C477 being VGraph;
let C478 , C479 , C480 being set;
set D257 = ( C477 .labelVertex (C478 , C480) );
assume L1516: C478 <> C479;
L1517:
now
per cases ;
suppose L1518: C478 in ( the_Vertices_of C477 );

L1519: (not C479 in { C478 }) by L1516 , TARSKI:def 1;
L1520: (not C479 in ( dom ( C478 .--> C480 ) )) by L1519;
L1521: ( the_VLabel_of D257 ) = ( ( the_VLabel_of C477 ) +* ( C478 .--> C480 ) ) by L1518 , L1474;
thus L1522: thesis by L1521 , L1520 , FUNCT_4:11;
end;
suppose L1523: (not C478 in ( the_Vertices_of C477 ));

thus L1524: thesis by L1523 , L970;
end;
end;
thus L1526: thesis by L1517;
end;
theorem
L1527: (for B183 , B184 being EGraph holds (( the_ELabel_of B183 ) = ( the_ELabel_of B184 ) implies ( B183 .labeledE() ) = ( B184 .labeledE() )));
theorem
L1528: (for B185 being EGraph holds (for B186 , B187 being set holds (B186 in ( the_Edges_of B185 ) implies ( ( B185 .labelEdge (B186 , B187) ) .labeledE() ) = ( ( B185 .labeledE() ) \/ { B186 } ))))
proof
let C481 being EGraph;
let C482 , C483 being set;
set D258 = ( C481 .labelEdge (C482 , C483) );
set D259 = ( the_ELabel_of C481 );
set D260 = ( the_ELabel_of D258 );
assume L1529: C482 in ( the_Edges_of C481 );
L1530: D260 = ( D259 +* ( C482 .--> C483 ) ) by L1529 , L1421;
L1531: ( dom D260 ) = ( ( dom D259 ) \/ ( dom ( C482 .--> C483 ) ) ) by L1530 , FUNCT_4:def 1;
thus L1532: thesis by L1531 , FUNCOP_1:13;
end;
theorem
L1533: (for B188 being EGraph holds (for B189 , B190 being set holds (B189 in ( the_Edges_of B188 ) implies ( B188 .labeledE() ) c= ( ( B188 .labelEdge (B189 , B190) ) .labeledE() ))))
proof
let C484 being EGraph;
let C485 , C486 being set;
assume L1534: C485 in ( the_Edges_of C484 );
L1535: ( ( C484 .labelEdge (C485 , C486) ) .labeledE() ) = ( ( C484 .labeledE() ) \/ { C485 } ) by L1534 , L1528;
thus L1536: thesis by L1535 , XBOOLE_1:7;
end;
theorem
L1537: (for B191 being  finite EGraph holds (for B192 , B193 being set holds ((B192 in ( the_Edges_of B191 ) & (not B192 in ( B191 .labeledE() ))) implies ( card ( ( B191 .labelEdge (B192 , B193) ) .labeledE() ) ) = ( ( card ( B191 .labeledE() ) ) + 1 ))))
proof
let C487 being  finite EGraph;
let C488 , C489 being set;
set D261 = ( C487 .labelEdge (C488 , C489) );
set D262 = ( the_ELabel_of C487 );
set D263 = ( the_ELabel_of D261 );
assume L1538: (C488 in ( the_Edges_of C487 ) & (not C488 in ( C487 .labeledE() )));
L1539: (( card ( ( dom D262 ) \/ { C488 } ) ) = ( ( card ( dom D262 ) ) + 1 ) & D263 = ( D262 +* ( C488 .--> C489 ) )) by L1538 , L1421 , CARD_2:41;
L1540: ( dom ( C488 .--> C489 ) ) = { C488 } by FUNCOP_1:13;
thus L1541: thesis by L1540 , L1539 , FUNCT_4:def 1;
end;
theorem
L1542: (for B194 being EGraph holds (for B195 , B196 , B197 being set holds (((not B196 in ( B194 .labeledE() )) & B196 in ( ( B194 .labelEdge (B195 , B197) ) .labeledE() )) implies (B195 = B196 & B195 in ( the_Edges_of B194 )))))
proof
let C490 being EGraph;
let C491 , C492 , C493 being set;
set D264 = ( C490 .labelEdge (C491 , C493) );
assume that
L1543: (not C492 in ( C490 .labeledE() ))
and
L1544: C492 in ( D264 .labeledE() );
L1545: C491 in ( the_Edges_of C490 ) by L1543 , L1544 , L819;
L1546: ( the_ELabel_of D264 ) = ( ( the_ELabel_of C490 ) +* ( C491 .--> C493 ) ) by L1545 , L1421;
L1547: (C492 in ( dom ( the_ELabel_of C490 ) ) or C492 in ( dom ( C491 .--> C493 ) )) by L1546 , L1544 , FUNCT_4:12;
L1548: C492 in { C491 } by L1547 , L1543;
thus L1549: C491 = C492 by L1548 , TARSKI:def 1;
thus L1550: thesis by L1543 , L1544 , L819;
end;
theorem
L1551: (for B198 being EVGraph holds (for B199 , B200 being set holds ( B198 .labeledE() ) = ( ( B198 .labelVertex (B199 , B200) ) .labeledE() ))) by L1506;
theorem
L1552: (for B201 being EGraph holds (for B202 , B203 being set holds (B202 in ( the_Edges_of B201 ) implies B202 in ( ( B201 .labelEdge (B202 , B203) ) .labeledE() ))))
proof
let C494 being EGraph;
let C495 , C496 being set;
assume L1553: C495 in ( the_Edges_of C494 );
L1554: ( ( C494 .labelEdge (C495 , C496) ) .labeledE() ) = ( ( C494 .labeledE() ) \/ { C495 } ) by L1553 , L1528;
L1555: C495 in { C495 } by TARSKI:def 1;
thus L1556: thesis by L1555 , L1554 , XBOOLE_0:def 3;
end;
theorem
L1557: (for B204 , B205 being VGraph holds (( the_VLabel_of B204 ) = ( the_VLabel_of B205 ) implies ( B204 .labeledV() ) = ( B205 .labeledV() )));
theorem
L1558: (for B206 being VGraph holds (for B207 , B208 being set holds (B207 in ( the_Vertices_of B206 ) implies ( ( B206 .labelVertex (B207 , B208) ) .labeledV() ) = ( ( B206 .labeledV() ) \/ { B207 } ))))
proof
let C497 being VGraph;
let C498 , C499 being set;
set D265 = ( C497 .labelVertex (C498 , C499) );
set D266 = ( the_VLabel_of C497 );
set D267 = ( the_VLabel_of D265 );
assume L1559: C498 in ( the_Vertices_of C497 );
L1560: D267 = ( D266 +* ( C498 .--> C499 ) ) by L1559 , L1474;
L1561: ( dom D267 ) = ( ( dom D266 ) \/ ( dom ( C498 .--> C499 ) ) ) by L1560 , FUNCT_4:def 1;
thus L1562: thesis by L1561 , FUNCOP_1:13;
end;
theorem
L1563: (for B209 being VGraph holds (for B210 , B211 being set holds (B210 in ( the_Vertices_of B209 ) implies ( B209 .labeledV() ) c= ( ( B209 .labelVertex (B210 , B211) ) .labeledV() ))))
proof
let C500 being VGraph;
let C501 , C502 being set;
assume L1564: C501 in ( the_Vertices_of C500 );
L1565: ( ( C500 .labelVertex (C501 , C502) ) .labeledV() ) = ( ( C500 .labeledV() ) \/ { C501 } ) by L1564 , L1558;
thus L1566: thesis by L1565 , XBOOLE_1:7;
end;
theorem
L1567: (for B212 being  finite VGraph holds (for B213 , B214 being set holds ((B213 in ( the_Vertices_of B212 ) & (not B213 in ( B212 .labeledV() ))) implies ( card ( ( B212 .labelVertex (B213 , B214) ) .labeledV() ) ) = ( ( card ( B212 .labeledV() ) ) + 1 ))))
proof
let C503 being  finite VGraph;
let C504 , C505 being set;
set D268 = ( C503 .labelVertex (C504 , C505) );
set D269 = ( the_VLabel_of C503 );
set D270 = ( the_VLabel_of D268 );
assume L1568: (C504 in ( the_Vertices_of C503 ) & (not C504 in ( C503 .labeledV() )));
L1569: (( card ( ( dom D269 ) \/ { C504 } ) ) = ( ( card ( dom D269 ) ) + 1 ) & D270 = ( D269 +* ( C504 .--> C505 ) )) by L1568 , L1474 , CARD_2:41;
L1570: ( dom ( C504 .--> C505 ) ) = { C504 } by FUNCOP_1:13;
thus L1571: thesis by L1570 , L1569 , FUNCT_4:def 1;
end;
theorem
L1572: (for B215 being VGraph holds (for B216 , B217 , B218 being set holds (((not B217 in ( B215 .labeledV() )) & B217 in ( ( B215 .labelVertex (B216 , B218) ) .labeledV() )) implies (B216 = B217 & B216 in ( the_Vertices_of B215 )))))
proof
let C506 being VGraph;
let C507 , C508 , C509 being set;
set D271 = ( C506 .labelVertex (C507 , C509) );
assume that
L1573: (not C508 in ( C506 .labeledV() ))
and
L1574: C508 in ( D271 .labeledV() );
L1575: C507 in ( the_Vertices_of C506 ) by L1573 , L1574 , L970;
L1576: ( the_VLabel_of D271 ) = ( ( the_VLabel_of C506 ) +* ( C507 .--> C509 ) ) by L1575 , L1474;
L1577: (C508 in ( dom ( the_VLabel_of C506 ) ) or C508 in ( dom ( C507 .--> C509 ) )) by L1576 , L1574 , FUNCT_4:12;
L1578: C508 in { C507 } by L1577 , L1573;
thus L1579: C507 = C508 by L1578 , TARSKI:def 1;
thus L1580: thesis by L1573 , L1574 , L970;
end;
theorem
L1581: (for B219 being EVGraph holds (for B220 , B221 being set holds ( B219 .labeledV() ) = ( ( B219 .labelEdge (B220 , B221) ) .labeledV() ))) by L1453;
theorem
L1582: (for B222 being VGraph holds (for B223 being (Vertex of B222) holds (for B224 being set holds B223 in ( ( B222 .labelVertex (B223 , B224) ) .labeledV() ))))
proof
let C510 being VGraph;
let C511 being (Vertex of C510);
let C512 being set;
L1583: (( ( C510 .labelVertex (C511 , C512) ) .labeledV() ) = ( ( C510 .labeledV() ) \/ { C511 } ) & C511 in { C511 }) by L1558 , TARSKI:def 1;
thus L1584: thesis by L1583 , XBOOLE_0:def 3;
end;
