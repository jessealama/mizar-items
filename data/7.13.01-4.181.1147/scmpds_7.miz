:: The Construction and Computation of For-loop Programs for SCMPDS
::  by JingChao Chen and Piotr Rudnicki
::
:: Received December 27, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, ARYTM_1,
      COMPLEX1, ARYTM_3, CARD_1, RELAT_1, FUNCT_4, FUNCOP_1, XBOOLE_0,
      CIRCUIT2, FUNCT_1, NAT_1, TARSKI, TURING_1, VALUED_1, SCMPDS_4, AMISTD_2,
      XXREAL_0, AMI_3, SCMFSA_7, UNIALG_2, SCMFSA7B, GRAPHSP, MSUALG_1,
      SCMFSA6B, SCMPDS_5, STRUCT_0, SFMASTR3, SEMI_AF1, SCMP_GCD, FINSEQ_1,
      CARD_3, FINSEQ_3, SCMPDS_7, ORDINAL1, PARTFUN1, EXTPRO_1, SCMFSA6C,
      PBOOLE, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, COMPLEX1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, ORDINAL1,
      NAT_1, FUNCOP_1, AFINSQ_1, VALUED_1, STRUCT_0, MEMSTR_0, COMPOS_0,
      COMPOS_1,
      EXTPRO_1, AMI_2, FUNCT_7, PBOOLE, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMP_GCD, FINSEQ_1, WSIERP_1;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, WSIERP_1, SCM_1, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, SCMP_GCD, SEQ_1, AMI_2, MEMSTR_0, RELSET_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, SCMPDS_2, SCMPDS_4, SCMPDS_5, XBOOLE_0,
      VALUED_0, FINSEQ_1, CARD_1, VALUED_1, FUNCT_4, COMPOS_1, AFINSQ_1,
      RELAT_1, EXTPRO_1, PBOOLE, MEMSTR_0, AMI_3, COMPOS_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_3, SCMPDS_2, SCMP_GCD, SCMPDS_4,
      SCMPDS_5, MEMSTR_0;
 theorems NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, MEMSTR_0, SCMPDS_2,
      ABSVALUE, GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD,
      WSIERP_1, FINSEQ_1, RVSUM_1, RELAT_1, FINSEQ_3, XBOOLE_1, XREAL_1,
      ORDINAL1, XXREAL_0, ZFMISC_1, FINSEQ_2, VALUED_1, PBOOLE, PARTFUN1,
      AFINSQ_1, COMPOS_1, EXTPRO_1, AMI_3, AMI_2, XTUPLE_0;
 schemes NAT_1;

begin
set D1 = ( NAT );
set D2 = ( SCM-Data-Loc );
theorem
L1: (for B1 being (State of ( SCMPDS )) holds (for B2 , B3 being (Element of ( NAT )) holds (( IC B1 ) = B2 implies ( ICplusConst (B1 , ( B3 - B2 )) ) = B3)))
proof
let C1 being (State of ( SCMPDS ));
let C2 , C3 being (Element of ( NAT ));
L2: (ex B4 being (Element of ( NAT )) st (B4 = ( IC C1 ) & ( ICplusConst (C1 , ( C3 - C2 )) ) = ( abs ( B4 + ( C3 - C2 ) ) ))) by SCMPDS_2:def 18;
thus L3: thesis by L2 , ABSVALUE:def 1;
end;
theorem
L4: (for R6 being (Instruction of ( SCMPDS )) holds (for R7 being (Instruction of ( SCMPDS )) holds (for R8 being (Instruction of ( SCMPDS )) holds (for R16 being (Program of ( SCMPDS )) holds ( ( ( R6 ';' R16 ) ';' R7 ) ';' R8 ) = ( R6 ';' ( ( R16 ';' R7 ) ';' R8 ) )))))
proof
let R6 being (Instruction of ( SCMPDS ));
let R7 being (Instruction of ( SCMPDS ));
let R8 being (Instruction of ( SCMPDS ));
let R16 being (Program of ( SCMPDS ));
thus L5: ( ( ( R6 ';' R16 ) ';' R7 ) ';' R8 ) = ( ( R6 ';' ( R16 ';' R7 ) ) ';' R8 ) by SCMPDS_4:15
.= ( R6 ';' ( ( R16 ';' R7 ) ';' R8 ) ) by SCMPDS_4:15;
end;
theorem
L6: (for R16 being (Program of ( SCMPDS )) holds (for R17 being (Program of ( SCMPDS )) holds (for R18 being (Program of ( SCMPDS )) holds ( Shift (R17 , ( card R16 )) ) c= ( ( R16 ';' R17 ) ';' R18 ))))
proof
let R16 being (Program of ( SCMPDS ));
let R17 being (Program of ( SCMPDS ));
let R18 being (Program of ( SCMPDS ));
set D3 = ( R16 ';' R17 );
L7: ( dom D3 ) misses ( dom ( Shift (R18 , ( card D3 )) ) ) by AFINSQ_1:72;
L8: D3 c= ( D3 ';' R18 ) by L7 , FUNCT_4:32;
L9: ( Shift (R17 , ( card R16 )) ) c= D3 by FUNCT_4:25;
thus L10: thesis by L9 , L8 , XBOOLE_1:1;
end;
theorem
L11: (for R16 being (Program of ( SCMPDS )) holds (for R17 being (Program of ( SCMPDS )) holds R16 c= ( stop ( R16 ';' R17 ) )))
proof
let R16 being (Program of ( SCMPDS ));
let R17 being (Program of ( SCMPDS ));
L12: ( stop ( R16 ';' R17 ) ) = ( R16 ';' ( R17 ';' ( Stop ( SCMPDS ) ) ) ) by AFINSQ_1:27;
thus L13: thesis by L12 , AFINSQ_1:74;
end;
canceled 2;
theorem
L14: (for B5 being (State of ( SCMPDS )) holds (for B6 being (Instruction of ( SCMPDS )) holds (( InsCode B6 ) in { ( 0 ) , 4 , 5 , 6 , 14 } implies ( DataPart ( Exec (B6 , B5) ) ) = ( DataPart B5 ))))
proof
let C4 being (State of ( SCMPDS ));
let C5 being (Instruction of ( SCMPDS ));
assume L15: ( InsCode C5 ) in { ( 0 ) , 4 , 5 , 6 , 14 };
L16:
now
let C6 being Int_position;
per cases  by L15 , ENUMSET1:def 3;
suppose L17: ( InsCode C5 ) = ( 0 );

thus L18: ( ( Exec (C5 , C4) ) . C6 ) = ( C4 . C6 ) by L17 , SCMPDS_2:86;
end;
suppose L19: ( InsCode C5 ) = 14;

L20: (ex R12 being Integer st C5 = ( goto R12 )) by L19 , SCMPDS_2:26;
thus L21: ( ( Exec (C5 , C4) ) . C6 ) = ( C4 . C6 ) by L20 , SCMPDS_2:54;
end;
suppose L22: ( InsCode C5 ) = 4;

L23: (ex R5 being Int_position st (ex R12 being Integer st (ex R13 being Integer st C5 = ( (R5 , R12) <>0_goto R13 )))) by L22 , SCMPDS_2:30;
thus L24: ( ( Exec (C5 , C4) ) . C6 ) = ( C4 . C6 ) by L23 , SCMPDS_2:55;
end;
suppose L25: ( InsCode C5 ) = 5;

L26: (ex R5 being Int_position st (ex R12 being Integer st (ex R13 being Integer st C5 = ( (R5 , R12) <=0_goto R13 )))) by L25 , SCMPDS_2:31;
thus L27: ( ( Exec (C5 , C4) ) . C6 ) = ( C4 . C6 ) by L26 , SCMPDS_2:56;
end;
suppose L28: ( InsCode C5 ) = 6;

L29: (ex R5 being Int_position st (ex R12 being Integer st (ex R13 being Integer st C5 = ( (R5 , R12) >=0_goto R13 )))) by L28 , SCMPDS_2:32;
thus L30: ( ( Exec (C5 , C4) ) . C6 ) = ( C4 . C6 ) by L29 , SCMPDS_2:57;
end;
end;
thus L32: thesis by L16 , SCMPDS_4:8;
end;
theorem
L33: (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B7 , B8 being (State of ( SCMPDS )) holds (for B9 being (Program of ( SCMPDS )) holds ((B9 is_closed_on B7 , R20 & ( DataPart B7 ) = ( DataPart B8 )) implies (for B10 being (Element of ( NAT )) holds (( Comput (( R20 +* ( stop B9 ) ) , ( Initialize B7 ) , B10) ) = ( Comput (( R21 +* ( stop B9 ) ) , ( Initialize B8 ) , B10) ) & ( CurInstr (( R20 +* ( stop B9 ) ) , ( Comput (( R20 +* ( stop B9 ) ) , ( Initialize B7 ) , B10) )) ) = ( CurInstr (( R21 +* ( stop B9 ) ) , ( Comput (( R21 +* ( stop B9 ) ) , ( Initialize B8 ) , B10) )) ))))))))
proof
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C7 , C8 being (State of ( SCMPDS ));
let C9 being (Program of ( SCMPDS ));
assume L34: C9 is_closed_on C7 , R20;
set D4 = ( stop C9 );
set D5 = ( Initialize C7 );
set D6 = ( R20 +* ( stop C9 ) );
set D7 = ( Initialize C8 );
set D8 = ( R21 +* ( stop C9 ) );
L35: D4 c= D8 by FUNCT_4:25;
L36: D4 c= D6 by FUNCT_4:25;
assume L37: ( DataPart C7 ) = ( DataPart C8 );
let C10 being (Element of ( NAT ));
L38: ( IC ( Comput (D6 , D5 , C10) ) ) in ( dom D4 ) by L34 , SCMPDS_6:def 2;
L39: C9 is_closed_on C8 , R21 by L34 , L37 , SCMPDS_6:22;
L40: (for R2 being (Element of ( NAT )) holds (R2 < C10 implies ( IC ( Comput (D8 , D7 , R2) ) ) in ( dom D4 ))) by L39 , SCMPDS_6:def 2;
L41: D5 = D7 by L37 , MEMSTR_0:80;
thus L42: ( Comput (D6 , D5 , C10) ) = ( Comput (D8 , D7 , C10) ) by L41 , L36 , L35 , L40 , SCMPDS_4:21;
L43: ( IC ( Comput (D8 , D7 , C10) ) ) in ( dom D4 ) by L39 , SCMPDS_6:def 2;
thus L44: ( CurInstr (D8 , ( Comput (D8 , D7 , C10) )) ) = ( D8 . ( IC ( Comput (D8 , D7 , C10) ) ) ) by PBOOLE:143
.= ( D4 . ( IC ( Comput (D8 , D7 , C10) ) ) ) by L35 , L43 , GRFUNC_1:2
.= ( D6 . ( IC ( Comput (D6 , D5 , C10) ) ) ) by L36 , L42 , L38 , GRFUNC_1:2
.= ( CurInstr (D6 , ( Comput (D6 , D5 , C10) )) ) by PBOOLE:143;
end;
theorem
L45: (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B11 being ( 0 ) -started (State of ( SCMPDS )) holds (for B12 being (Program of ( SCMPDS )) holds ((B12 is_closed_on B11 , R20 & ( stop B12 ) c= R20 & ( stop B12 ) c= R21) implies (for B13 being (Element of ( NAT )) holds (( Comput (R20 , B11 , B13) ) = ( Comput (R21 , B11 , B13) ) & ( CurInstr (R20 , ( Comput (R20 , B11 , B13) )) ) = ( CurInstr (R21 , ( Comput (R21 , B11 , B13) )) ))))))))
proof
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C11 being ( 0 ) -started (State of ( SCMPDS ));
let C12 being (Program of ( SCMPDS ));
set D9 = ( stop C12 );
assume that
L46: C12 is_closed_on C11 , R20
and
L47: ( stop C12 ) c= R20
and
L48: ( stop C12 ) c= R21;
L49: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C11 by MEMSTR_0:29;
L50: C11 = ( Initialize C11 ) by L49 , FUNCT_4:98;
L51: R21 = ( R21 +* D9 ) by L48 , FUNCT_4:98;
L52: ( DataPart C11 ) = ( DataPart C11 );
L53: R20 = ( R20 +* D9 ) by L47 , FUNCT_4:98;
thus L54: thesis by L53 , L46 , L51 , L52 , L33 , L50;
end;
theorem
L55: (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B14 being ( 0 ) -started (State of ( SCMPDS )) holds (for B15 being (Program of ( SCMPDS )) holds ((B15 is_closed_on B14 , R20 & B15 is_halting_on B14 , R20 & ( stop B15 ) c= R20 & ( stop B15 ) c= R21) implies (( LifeSpan (R20 , B14) ) = ( LifeSpan (R21 , B14) ) & ( Result (R20 , B14) ) = ( Result (R21 , B14) )))))))
proof
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C13 being ( 0 ) -started (State of ( SCMPDS ));
let C14 being (Program of ( SCMPDS ));
assume that
L56: C14 is_closed_on C13 , R20
and
L57: C14 is_halting_on C13 , R20
and
L58: ( stop C14 ) c= R20
and
L59: ( stop C14 ) c= R21;
L60: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C13 by MEMSTR_0:29;
L61: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C13 by MEMSTR_0:29;
L62: ( DataPart C13 ) = ( DataPart C13 );
L63: C14 is_halting_on C13 , R21 by L62 , L56 , L57 , SCMPDS_6:23;
L64: ( Initialize C13 ) = C13 by L60 , FUNCT_4:98;
L65: ( Initialize C13 ) = C13 by L61 , FUNCT_4:98;
L66: R21 = ( R21 +* ( stop C14 ) ) by L59 , FUNCT_4:98;
L67: R21 halts_on C13 by L66 , L63 , L65 , SCMPDS_6:def 3;
L68: R20 = ( R20 +* ( stop C14 ) ) by L58 , FUNCT_4:98;
L69: R20 halts_on C13 by L68 , L57 , L64 , SCMPDS_6:def 3;
L70:
now
let C15 being (Element of ( NAT ));
assume L71: ( CurInstr (R21 , ( Comput (R21 , C13 , C15) )) ) = ( halt ( SCMPDS ) );
L72: ( CurInstr (R20 , ( Comput (R20 , C13 , C15) )) ) = ( CurInstr (R21 , ( Comput (R21 , C13 , C15) )) ) by L56 , L58 , L59 , L45;
thus L73: ( LifeSpan (R20 , C13) ) <= C15 by L72 , L69 , L71 , EXTPRO_1:def 15;
end;
L74: ( CurInstr (R21 , ( Comput (R21 , C13 , ( LifeSpan (R20 , C13) )) )) ) = ( CurInstr (R20 , ( Comput (R20 , C13 , ( LifeSpan (R20 , C13) )) )) ) by L56 , L58 , L59 , L45
.= ( halt ( SCMPDS ) ) by L69 , EXTPRO_1:def 15;
thus L75: ( LifeSpan (R20 , C13) ) = ( LifeSpan (R21 , C13) ) by L74 , L70 , L67 , EXTPRO_1:def 15;
L76: ( Result (R21 , C13) ) = ( Comput (R21 , C13 , ( LifeSpan (R20 , C13) )) ) by L75 , L67 , EXTPRO_1:23;
L77: ( Result (R20 , C13) ) = ( Comput (R20 , C13 , ( LifeSpan (R20 , C13) )) ) by L69 , EXTPRO_1:23;
thus L78: thesis by L77 , L56 , L58 , L59 , L76 , L45;
end;
theorem
L79: (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B16 , B17 being (State of ( SCMPDS )) holds (for B18 being (Program of ( SCMPDS )) holds ((B18 is_closed_on B16 , R20 & B18 is_halting_on B16 , R20 & ( DataPart B16 ) = ( DataPart B17 )) implies (( LifeSpan (( R20 +* ( stop B18 ) ) , ( Initialize B16 )) ) = ( LifeSpan (( R21 +* ( stop B18 ) ) , ( Initialize B17 )) ) & ( Result (( R20 +* ( stop B18 ) ) , ( Initialize B16 )) ) = ( Result (( R21 +* ( stop B18 ) ) , ( Initialize B17 )) )))))))
proof
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C16 , C17 being (State of ( SCMPDS ));
let C18 being (Program of ( SCMPDS ));
assume L80: C18 is_closed_on C16 , R20;
set D10 = ( Initialize C16 );
set D11 = ( R20 +* ( stop C18 ) );
set D12 = ( Initialize C17 );
set D13 = ( R21 +* ( stop C18 ) );
assume L81: C18 is_halting_on C16 , R20;
L82: D11 halts_on D10 by L81 , SCMPDS_6:def 3;
L83: ( Result (D11 , D10) ) = ( Comput (D11 , D10 , ( LifeSpan (D11 , D10) )) ) by L82 , EXTPRO_1:23;
assume L84: ( DataPart C16 ) = ( DataPart C17 );
L85: C18 is_halting_on C17 , R21 by L84 , L80 , L81 , SCMPDS_6:23;
L86: D13 halts_on D12 by L85 , SCMPDS_6:def 3;
L87:
now
let C19 being (Element of ( NAT ));
assume L88: ( CurInstr (D13 , ( Comput (D13 , D12 , C19) )) ) = ( halt ( SCMPDS ) );
L89: ( CurInstr (D11 , ( Comput (D11 , D10 , C19) )) ) = ( CurInstr (D13 , ( Comput (D13 , D12 , C19) )) ) by L80 , L84 , L33;
thus L90: ( LifeSpan (D11 , D10) ) <= C19 by L89 , L82 , L88 , EXTPRO_1:def 15;
end;
L91: ( CurInstr (D13 , ( Comput (D13 , D12 , ( LifeSpan (D11 , D10) )) )) ) = ( CurInstr (D11 , ( Comput (D11 , D10 , ( LifeSpan (D11 , D10) )) )) ) by L80 , L84 , L33
.= ( halt ( SCMPDS ) ) by L82 , EXTPRO_1:def 15;
thus L92: ( LifeSpan (D11 , D10) ) = ( LifeSpan (D13 , D12) ) by L91 , L87 , L86 , EXTPRO_1:def 15;
L93: ( Result (D13 , D12) ) = ( Comput (D13 , D12 , ( LifeSpan (D11 , D10) )) ) by L92 , L86 , EXTPRO_1:23;
thus L94: thesis by L93 , L80 , L84 , L83 , L33;
end;
theorem
L95: (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B19 , B20 being ( 0 ) -started (State of ( SCMPDS )) holds (for B21 being (Program of ( SCMPDS )) holds ((B21 is_closed_on B19 , R20 & B21 is_halting_on B19 , R20 & ( stop B21 ) c= R20 & ( stop B21 ) c= R21 & (ex B22 being (Element of ( NAT )) st ( Comput (R20 , B19 , B22) ) = B20)) implies ( Result (R20 , B19) ) = ( Result (R21 , B20) ))))))
proof
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C20 , C21 being ( 0 ) -started (State of ( SCMPDS ));
let C22 being (Program of ( SCMPDS ));
set D14 = ( stop C22 );
assume L96: C22 is_closed_on C20 , R20;
assume L97: C22 is_halting_on C20 , R20;
assume L98: ( stop C22 ) c= R20;
L99: R20 = ( R20 +* ( stop C22 ) ) by L98 , FUNCT_4:98;
assume L100: ( stop C22 ) c= R21;
L101: R21 = ( R21 +* ( stop C22 ) ) by L100 , FUNCT_4:98;
L102: C20 = ( Initialize C20 ) by MEMSTR_0:44;
L103: R20 halts_on C20 by L102 , L97 , L99 , SCMPDS_6:def 3;
consider C23 being (Element of ( NAT )) such that L104: ( CurInstr (R20 , ( Comput (R20 , C20 , C23) )) ) = ( halt ( SCMPDS ) ) by L103 , EXTPRO_1:29;
L105: C21 = ( Initialize C21 ) by MEMSTR_0:44;
given C24 being (Element of ( NAT )) such that
L106: ( Comput (R20 , C20 , C24) ) = C21;

set D15 = ( Comput (R20 , C20 , C24) );
set D16 = R20;
L107: ( IC ( SCMPDS ) ) in ( dom D15 ) by MEMSTR_0:2;
L108: ( IC D15 ) = ( 0 ) by L106 , MEMSTR_0:def 11;
L109: ( Start-At (( 0 ) , ( SCMPDS )) ) c= D15 by L108 , L107 , FUNCOP_1:73;
L110: D15 = ( Initialize D15 ) by L109 , FUNCT_4:98;
L111:
now
let C25 being (Element of ( NAT ));
L112: ( IC ( Comput (R20 , D15 , C25) ) ) = ( IC ( Comput (R20 , C20 , ( C24 + C25 )) ) ) by EXTPRO_1:4;
thus L113: ( IC ( Comput (D16 , D15 , C25) ) ) in ( dom D14 ) by L112 , L96 , L99 , L102 , SCMPDS_6:def 2;
end;
L114: ( CurInstr (D16 , ( Comput (D16 , D15 , C23) )) ) = ( CurInstr (R20 , ( Comput (R20 , C20 , ( C24 + C23 )) )) ) by EXTPRO_1:4
.= ( CurInstr (R20 , ( Comput (R20 , C20 , C23) )) ) by L104 , EXTPRO_1:5 , NAT_1:11;
L115: D16 halts_on D15 by L114 , L104 , EXTPRO_1:29;
L116: C22 is_halting_on D15 , D16 by L115 , L110 , L99 , SCMPDS_6:def 3;
L117: ( DataPart D15 ) = ( DataPart C21 ) by L106;
consider C26 being (Element of ( NAT )) such that L118: ( CurInstr (R20 , ( Comput (R20 , C20 , C26) )) ) = ( halt ( SCMPDS ) ) by L103 , EXTPRO_1:29;
L119: ( R20 . ( IC ( Comput (R20 , C20 , C26) ) ) ) = ( halt ( SCMPDS ) ) by L118 , PBOOLE:143;
L120: C22 is_closed_on D15 , D16 by L110 , L111 , L99 , SCMPDS_6:def 2;
L121: ( Result (D16 , D15) ) = ( Result (R21 , C21) ) by L120 , L105 , L117 , L110 , L116 , L79 , L101 , L99;
thus L122: thesis by L121 , L119 , EXTPRO_1:8;
end;
theorem
L123: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B23 being (State of ( SCMPDS )) holds (for B24 being (Program of ( SCMPDS )) holds (for B25 being Int_position holds (B24 is_halting_on B23 , R19 implies ( ( IExec (B24 , R19 , ( Initialize B23 )) ) . B25 ) = ( ( Comput (( R19 +* ( stop B24 ) ) , ( Initialize B23 ) , ( LifeSpan (( R19 +* ( stop B24 ) ) , ( Initialize B23 )) )) ) . B25 ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C27 being (State of ( SCMPDS ));
let C28 being (Program of ( SCMPDS ));
let C29 being Int_position;
set D17 = ( Initialize C27 );
set D18 = ( R19 +* ( stop C28 ) );
assume L124: C28 is_halting_on C27 , R19;
L125: D18 halts_on D17 by L124 , SCMPDS_6:def 3;
thus L126: ( ( IExec (C28 , R19 , ( Initialize C27 )) ) . C29 ) = ( ( Comput (D18 , D17 , ( LifeSpan (D18 , D17) )) ) . C29 ) by L125 , EXTPRO_1:23;
end;
theorem
L127: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B26 being (State of ( SCMPDS )) holds (for B27 being  parahalting (Program of ( SCMPDS )) holds (for B28 being Int_position holds ( ( IExec (B27 , R19 , ( Initialize B26 )) ) . B28 ) = ( ( Comput (( R19 +* ( stop B27 ) ) , ( Initialize B26 ) , ( LifeSpan (( R19 +* ( stop B27 ) ) , ( Initialize B26 )) )) ) . B28 )))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C30 being (State of ( SCMPDS ));
let C31 being  parahalting (Program of ( SCMPDS ));
let C32 being Int_position;
L128: C31 is_halting_on C30 , R19 by SCMPDS_6:21;
thus L129: ( ( IExec (C31 , R19 , ( Initialize C30 )) ) . C32 ) = ( ( Comput (( R19 +* ( stop C31 ) ) , ( Initialize C30 ) , ( LifeSpan (( R19 +* ( stop C31 ) ) , ( Initialize C30 )) )) ) . C32 ) by L128 , L123;
end;
theorem
L130: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B29 being ( 0 ) -started (State of ( SCMPDS )) holds (for B30 being (Program of ( SCMPDS )) holds (for B31 being (Element of ( NAT )) holds ((( stop B30 ) c= R19 & B30 is_closed_on B29 , R19 & B30 is_halting_on B29 , R19 & B31 < ( LifeSpan (R19 , B29) )) implies ( IC ( Comput (R19 , B29 , B31) ) ) in ( dom B30 ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C33 being ( 0 ) -started (State of ( SCMPDS ));
let C34 being (Program of ( SCMPDS ));
let C35 being (Element of ( NAT ));
set D19 = ( stop C34 );
set D20 = ( Comput (R19 , C33 , C35) );
set D21 = ( IC D20 );
assume that
L131: D19 c= R19
and
L132: C34 is_closed_on C33 , R19
and
L133: C34 is_halting_on C33 , R19
and
L134: C35 < ( LifeSpan (R19 , C33) );
L135: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C33 by MEMSTR_0:29;
L136: ( R19 +* D19 ) = R19 by L131 , FUNCT_4:98;
L137: C33 = ( Initialize C33 ) by L135 , FUNCT_4:98;
L138: D21 in ( dom D19 ) by L137 , L132 , L136 , SCMPDS_6:def 2;
L139: R19 halts_on C33 by L133 , L137 , L136 , SCMPDS_6:def 3;
L140:
now
assume L141: ( D19 . D21 ) = ( halt ( SCMPDS ) );
L142: ( CurInstr (R19 , D20) ) = ( R19 . D21 ) by PBOOLE:143
.= ( halt ( SCMPDS ) ) by L138 , L131 , L141 , GRFUNC_1:2;
thus L143: contradiction by L142 , L134 , L139 , EXTPRO_1:def 15;
end;
thus L144: thesis by L140 , L138 , COMPOS_1:51;
end;
theorem
L145: (for R11 being (State of ( SCMPDS )) holds (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B32 being ( 0 ) -started (State of ( SCMPDS )) holds (for B33 being  shiftable (Program of ( SCMPDS )) holds ((( stop B33 ) c= R20 & B33 is_closed_on B32 , R20 & B33 is_halting_on B32 , R20) implies (for B34 being (Element of ( NAT )) holds ((( Shift (B33 , B34) ) c= R21 & ( IC R11 ) = B34 & ( DataPart B32 ) = ( DataPart R11 )) implies (for B35 being (Element of ( NAT )) holds (B35 < ( LifeSpan (R20 , B32) ) implies (( ( IC ( Comput (R20 , B32 , B35) ) ) + B34 ) = ( IC ( Comput (R21 , R11 , B35) ) ) & ( CurInstr (R20 , ( Comput (R20 , B32 , B35) )) ) = ( CurInstr (R21 , ( Comput (R21 , R11 , B35) )) ) & ( DataPart ( Comput (R20 , B32 , B35) ) ) = ( DataPart ( Comput (R21 , R11 , B35) ) ))))))))))))
proof
let R11 being (State of ( SCMPDS ));
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C36 being ( 0 ) -started (State of ( SCMPDS ));
let C37 being  shiftable (Program of ( SCMPDS ));
set D22 = ( stop C37 );
assume that
L146: D22 c= R20
and
L147: C37 is_closed_on C36 , R20
and
L148: C37 is_halting_on C36 , R20;
L149: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C36 by MEMSTR_0:29;
let C38 being (Element of ( NAT ));
L150: ( card C37 ) > ( 0 );
assume that
L151: ( Shift (C37 , C38) ) c= R21
and
L152: ( IC R11 ) = C38
and
L153: ( DataPart C36 ) = ( DataPart R11 );
defpred S1[ (Element of ( NAT )) ] means ($1 < ( LifeSpan (R20 , C36) ) implies (( ( IC ( Comput (R20 , C36 , $1) ) ) + C38 ) = ( IC ( Comput (R21 , R11 , $1) ) ) & ( CurInstr (R20 , ( Comput (R20 , C36 , $1) )) ) = ( CurInstr (R21 , ( Comput (R21 , R11 , $1) )) ) & ( DataPart ( Comput (R20 , C36 , $1) ) ) = ( DataPart ( Comput (R21 , R11 , $1) ) )));
L154: C36 = ( Initialize C36 ) by L149 , FUNCT_4:98;
L155: (for B36 being (Element of ( NAT )) holds (S1[ B36 ] implies S1[ ( B36 + 1 ) ]))
proof
let C39 being (Element of ( NAT ));
assume L156: S1[ C39 ];
L157:
now
reconsider D23 = ( IC ( Comput (R20 , C36 , C39) ) ) as (Element of ( NAT ));
set D24 = ( CurInstr (R20 , ( Comput (R20 , C36 , C39) )) );
L158: C39 <= ( C39 + 1 ) by NAT_1:11;
reconsider D25 = ( IC ( Comput (R20 , C36 , ( C39 + 1 )) ) ) as (Element of ( NAT ));
L159: ( Comput (R20 , C36 , ( C39 + 1 )) ) = ( Following (R20 , ( Comput (R20 , C36 , C39) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R20 , ( Comput (R20 , C36 , C39) )) ) , ( Comput (R20 , C36 , C39) )) );
assume L160: ( C39 + 1 ) < ( LifeSpan (R20 , C36) );
L161: ( D25 + C38 ) in ( dom ( Shift (C37 , C38) ) ) by L160 , L146 , L147 , L148 , L130 , VALUED_1:24;
L162: ( Comput (R21 , R11 , ( C39 + 1 )) ) = ( Following (R21 , ( Comput (R21 , R11 , C39) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R21 , ( Comput (R21 , R11 , C39) )) ) , ( Comput (R21 , R11 , C39) )) );
L163: ( R20 +* D22 ) = R20 by L146 , FUNCT_4:98;
L164: ( IC ( Comput (R20 , C36 , C39) ) ) in ( dom D22 ) by L163 , L147 , L154 , SCMPDS_6:def 2;
L165: D24 = ( R20 . ( IC ( Comput (R20 , C36 , C39) ) ) ) by PBOOLE:143
.= ( D22 . ( IC ( Comput (R20 , C36 , C39) ) ) ) by L146 , L164 , GRFUNC_1:2;
L166: ( InsCode D24 ) <> 3 by L165 , L164 , SCMPDS_4:def 9;
L167: ( IC ( Comput (R20 , C36 , ( C39 + 1 )) ) ) in ( dom D22 ) by L147 , L154 , L163 , SCMPDS_6:def 2;
L168: D24 valid_at D23 by L164 , L165 , SCMPDS_4:def 9;
L169: ( InsCode D24 ) <> 1 by L164 , L165 , SCMPDS_4:def 9;
thus L170: ( ( IC ( Comput (R20 , C36 , ( C39 + 1 )) ) ) + C38 ) = ( IC ( Comput (R21 , R11 , ( C39 + 1 )) ) ) by L169 , L156 , L160 , L158 , L159 , L162 , L166 , L168 , SCMPDS_4:28 , XXREAL_0:2;
L171: ( CurInstr (R20 , ( Comput (R20 , C36 , ( C39 + 1 )) )) ) = ( R20 . D25 ) by PBOOLE:143
.= ( D22 . D25 ) by L146 , L167 , GRFUNC_1:2;
thus L172: ( CurInstr (R20 , ( Comput (R20 , C36 , ( C39 + 1 )) )) ) = ( ( Shift (D22 , C38) ) . ( D25 + C38 ) ) by L171 , L167 , VALUED_1:def 12
.= ( ( Shift (C37 , C38) ) . ( IC ( Comput (R21 , R11 , ( C39 + 1 )) ) ) ) by L170 , L160 , L146 , L147 , L148 , L130 , COMPOS_1:65
.= ( R21 . ( IC ( Comput (R21 , R11 , ( C39 + 1 )) ) ) ) by L151 , L170 , L161 , GRFUNC_1:2
.= ( CurInstr (R21 , ( Comput (R21 , R11 , ( C39 + 1 )) )) ) by PBOOLE:143;
thus L173: ( DataPart ( Comput (R20 , C36 , ( C39 + 1 )) ) ) = ( DataPart ( Comput (R21 , R11 , ( C39 + 1 )) ) ) by L156 , L160 , L158 , L159 , L162 , L169 , L166 , L168 , SCMPDS_4:28 , XXREAL_0:2;
end;
thus L174: thesis by L157;
end;
let C40 being (Element of ( NAT ));
L175: ( 0 ) in ( dom D22 ) by COMPOS_1:36;
L176: ( 0 ) in ( dom C37 ) by L150 , AFINSQ_1:66;
L177: S1[ ( 0 ) ]
proof
assume L178: ( 0 ) < ( LifeSpan (R20 , C36) );
L179: ( (( 0 ) qua Nat) + C38 ) in ( dom ( Shift (C37 , C38) ) ) by L176 , VALUED_1:24;
L180: ( R20 . ( IC C36 ) ) = ( R20 . ( 0 ) ) by MEMSTR_0:def 11
.= ( D22 . ( 0 ) ) by L146 , L175 , GRFUNC_1:2;
L181: ( IC ( Comput (R20 , C36 , ( 0 )) ) ) = ( IC C36 )
.= ( 0 ) by MEMSTR_0:def 11;
thus L182: ( ( IC ( Comput (R20 , C36 , ( 0 )) ) ) + C38 ) = ( IC ( Comput (R21 , R11 , ( 0 )) ) ) by L181 , L152;
L183: ( R20 /. ( IC C36 ) ) = ( R20 . ( IC C36 ) ) by PBOOLE:143;
L184: ( R21 /. ( IC R11 ) ) = ( R21 . ( IC R11 ) ) by PBOOLE:143;
thus L185: ( CurInstr (R20 , ( Comput (R20 , C36 , ( 0 )) )) ) = ( CurInstr (R20 , C36) )
.= ( ( Shift (D22 , C38) ) . ( (( 0 ) qua Nat) + C38 ) ) by L175 , L180 , L183 , VALUED_1:def 12
.= ( ( Shift (C37 , C38) ) . C38 ) by COMPOS_1:66
.= ( CurInstr (R21 , R11) ) by L151 , L152 , L179 , L184 , GRFUNC_1:2
.= ( CurInstr (R21 , ( Comput (R21 , R11 , ( 0 )) )) );
thus L186: ( DataPart ( Comput (R20 , C36 , ( 0 )) ) ) = ( DataPart R11 ) by L153
.= ( DataPart ( Comput (R21 , R11 , ( 0 )) ) );
end;
L187: (for B37 being (Element of ( NAT )) holds S1[ B37 ]) from NAT_1:sch 1(L177 , L155);
thus L188: thesis by L187;
end;
theorem
L189: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B38 being ( 0 ) -started (State of ( SCMPDS )) holds (for B39 being  halt-free (Program of ( SCMPDS )) holds ((( stop B39 ) c= R19 & B39 is_halting_on B38 , R19) implies ( LifeSpan (R19 , B38) ) > ( 0 )))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C41 being ( 0 ) -started (State of ( SCMPDS ));
let C42 being  halt-free (Program of ( SCMPDS ));
set D26 = ( Initialize C41 );
set D27 = ( R19 +* ( stop C42 ) );
L190: ( card C42 ) > ( 0 );
assume that
L191: ( stop C42 ) c= R19
and
L192: C42 is_halting_on C41 , R19;
L193: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C41 by MEMSTR_0:29;
L194: R19 = ( R19 +* ( stop C42 ) ) by L191 , FUNCT_4:98;
L195: C41 = D26 by L193 , FUNCT_4:98;
assume L196: ( LifeSpan (R19 , C41) ) <= ( 0 );
L197: ( LifeSpan (R19 , C41) ) = ( 0 ) by L196;
L198: C42 c= ( stop C42 ) by AFINSQ_1:74;
L199: ( dom C42 ) c= ( dom ( stop C42 ) ) by L198 , RELAT_1:11;
L200: ( 0 ) in ( dom C42 ) by L190 , AFINSQ_1:66;
L201: ( D27 /. ( IC D26 ) ) = ( D27 . ( IC D26 ) ) by PBOOLE:143;
L202: ( stop C42 ) c= D27 by FUNCT_4:25;
L203: D27 halts_on D26 by L192 , SCMPDS_6:def 3;
L204: ( halt ( SCMPDS ) ) = ( CurInstr (D27 , ( Comput (D27 , D26 , ( 0 )) )) ) by L203 , L195 , L197 , L194 , EXTPRO_1:def 15
.= ( CurInstr (D27 , D26) )
.= ( D27 . ( 0 ) ) by L201 , MEMSTR_0:def 11
.= ( ( stop C42 ) . ( 0 ) ) by L200 , L199 , L202 , GRFUNC_1:2
.= ( C42 . ( 0 ) ) by L200 , L198 , GRFUNC_1:2;
thus L205: contradiction by L204 , L200 , COMPOS_1:def 27;
end;
theorem
L206: (for R11 being (State of ( SCMPDS )) holds (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B40 being ( 0 ) -started (State of ( SCMPDS )) holds (for B41 being  halt-free  shiftable (Program of ( SCMPDS )) holds ((( stop B41 ) c= R20 & B41 is_closed_on B40 , R20 & B41 is_halting_on B40 , R20) implies (for B42 being (Element of ( NAT )) holds ((( Shift (B41 , B42) ) c= R21 & ( IC R11 ) = B42 & ( DataPart B40 ) = ( DataPart R11 )) implies (( IC ( Comput (R21 , R11 , ( LifeSpan (R20 , B40) )) ) ) = ( ( card B41 ) + B42 ) & ( DataPart ( Comput (R20 , B40 , ( LifeSpan (R20 , B40) )) ) ) = ( DataPart ( Comput (R21 , R11 , ( LifeSpan (R20 , B40) )) ) ))))))))))
proof
let R11 being (State of ( SCMPDS ));
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C43 being ( 0 ) -started (State of ( SCMPDS ));
let C44 being  halt-free  shiftable (Program of ( SCMPDS ));
assume that
L207: ( stop C44 ) c= R20
and
L208: C44 is_closed_on C43 , R20
and
L209: C44 is_halting_on C43 , R20;
L210: ( Start-At (( 0 ) , ( SCMPDS )) ) c= C43 by MEMSTR_0:29;
L211: ( R20 +* ( stop C44 ) ) = R20 by L207 , FUNCT_4:98;
let C45 being (Element of ( NAT ));
assume that
L212: ( Shift (C44 , C45) ) c= R21
and
L213: ( IC R11 ) = C45
and
L214: ( DataPart C43 ) = ( DataPart R11 );
L215: ( 1 + (( 0 ) qua Nat) ) <= ( LifeSpan (R20 , C43) ) by L207 , L209 , L189 , INT_1:7;
consider C46 being Nat such that L216: ( 1 + C46 ) = ( LifeSpan (R20 , C43) ) by L215 , NAT_1:10;
L217: ( Initialize C43 ) = C43 by L210 , FUNCT_4:98;
reconsider D28 = C46 as (Element of ( NAT )) by ORDINAL1:def 12;
L218: D28 < ( LifeSpan (R20 , C43) ) by L216 , XREAL_1:29;
L219: ( ( IC ( Comput (R20 , C43 , D28) ) ) + C45 ) = ( IC ( Comput (R21 , R11 , D28) ) ) by L218 , L207 , L208 , L209 , L212 , L213 , L214 , L145;
set D29 = ( IC ( Comput (R20 , C43 , D28) ) );
L220: D29 in ( dom C44 ) by L207 , L208 , L209 , L216 , L130 , XREAL_1:29;
set D30 = ( CurInstr (R21 , ( Comput (R21 , R11 , D28) )) );
L221: ( Comput (R20 , C43 , ( D28 + 1 )) ) = ( Following (R20 , ( Comput (R20 , C43 , D28) )) ) by EXTPRO_1:3
.= ( Exec (D30 , ( Comput (R20 , C43 , D28) )) ) by L207 , L208 , L209 , L212 , L213 , L214 , L218 , L145;
L222: C44 c= ( stop C44 ) by AFINSQ_1:74;
L223: ( dom C44 ) c= ( dom ( stop C44 ) ) by L222 , RELAT_1:11;
L224: ( Comput (R21 , R11 , ( D28 + 1 )) ) = ( Following (R21 , ( Comput (R21 , R11 , D28) )) ) by EXTPRO_1:3
.= ( Exec (D30 , ( Comput (R21 , R11 , D28) )) );
reconsider D31 = D29 as (Element of ( NAT ));
L225: D30 = ( CurInstr (R20 , ( Comput (R20 , C43 , D28) )) ) by L207 , L208 , L209 , L212 , L213 , L214 , L218 , L145;
L226: D30 = ( R20 . D29 ) by L225 , PBOOLE:143
.= ( ( stop C44 ) . D29 ) by L207 , L220 , L223 , GRFUNC_1:2
.= ( C44 . D29 ) by L220 , L222 , GRFUNC_1:2;
L227: ( InsCode D30 ) <> 1 by L226 , L220 , SCMPDS_4:def 9;
L228: ( DataPart ( Comput (R20 , C43 , D28) ) ) = ( DataPart ( Comput (R21 , R11 , D28) ) ) by L207 , L208 , L209 , L212 , L213 , L214 , L218 , L145;
L229: D30 valid_at D31 by L220 , L226 , SCMPDS_4:def 9;
L230: ( InsCode D30 ) <> 3 by L220 , L226 , SCMPDS_4:def 9;
L231: ( IC ( Comput (R20 , C43 , ( D28 + 1 )) ) ) = ( card C44 ) by L208 , L209 , L216 , L211 , L217 , SCMPDS_6:29;
thus L232: ( IC ( Comput (R21 , R11 , ( LifeSpan (R20 , C43) )) ) ) = ( ( card C44 ) + C45 ) by L231 , L216 , L219 , L227 , L230 , L229 , L221 , L228 , L224 , SCMPDS_4:28;
thus L233: thesis by L216 , L219 , L227 , L230 , L229 , L221 , L228 , L224 , SCMPDS_4:28;
end;
theorem
L234: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B43 being (Program of ( SCMPDS )) holds (for B44 being (Program of ( SCMPDS )) holds (for B45 being (Element of ( NAT )) holds ((B43 is_closed_on R9 , R19 & B43 is_halting_on R9 , R19 & B45 <= ( LifeSpan (( R19 +* ( stop B43 ) ) , ( Initialize R9 )) )) implies ( Comput (( R19 +* ( stop B43 ) ) , ( Initialize R9 ) , B45) ) = ( Comput (( R19 +* ( B43 ';' B44 ) ) , ( Initialize R9 ) , B45) )))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C47 being (Program of ( SCMPDS ));
let C48 being (Program of ( SCMPDS ));
let C49 being (Element of ( NAT ));
set D32 = ( stop C47 );
set D33 = ( Initialize R9 );
set D34 = ( R19 +* D32 );
set D35 = ( Initialize R9 );
set D36 = ( R19 +* ( C47 ';' C48 ) );
set D37 = ( LifeSpan (D34 , D33) );
assume that
L235: C47 is_closed_on R9 , R19
and
L236: C47 is_halting_on R9 , R19;
assume L237: C49 <= D37;
defpred S2[ (Element of ( NAT )) ] means ($1 <= D37 implies ( Comput (D34 , D33 , $1) ) = ( Comput (D36 , D35 , $1) ));
L238: (for B46 being (Element of ( NAT )) holds (S2[ B46 ] implies S2[ ( B46 + 1 ) ]))
proof
let C50 being (Element of ( NAT ));
assume L239: (C50 <= D37 implies ( Comput (D34 , D33 , C50) ) = ( Comput (D36 , D35 , C50) ));
L240: ( Comput (D34 , D33 , ( C50 + 1 )) ) = ( Following (D34 , ( Comput (D34 , D33 , C50) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D34 , ( Comput (D34 , D33 , C50) )) ) , ( Comput (D34 , D33 , C50) )) );
L241: ( IC ( Comput (D34 , D33 , C50) ) ) in ( dom D32 ) by L235 , SCMPDS_6:def 2;
L242: ( Comput (D36 , D35 , ( C50 + 1 )) ) = ( Following (D36 , ( Comput (D36 , D35 , C50) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D36 , ( Comput (D36 , D35 , C50) )) ) , ( Comput (D36 , D35 , C50) )) );
assume L243: ( C50 + 1 ) <= D37;
L244: C50 < D37 by L243 , NAT_1:13;
L245: ( IC ( Comput (D34 , D33 , C50) ) ) in ( dom C47 ) by L244 , L235 , L236 , SCMPDS_6:26;
L246: ( IC ( Comput (D34 , D33 , C50) ) ) in ( dom ( C47 ';' C48 ) ) by L245 , FUNCT_4:12;
L247: ( CurInstr (D34 , ( Comput (D34 , D33 , C50) )) ) = ( D34 . ( IC ( Comput (D34 , D33 , C50) ) ) ) by PBOOLE:143
.= ( D32 . ( IC ( Comput (D34 , D33 , C50) ) ) ) by L241 , FUNCT_4:13
.= ( C47 . ( IC ( Comput (D34 , D33 , C50) ) ) ) by L245 , AFINSQ_1:def 3
.= ( ( C47 ';' C48 ) . ( IC ( Comput (D34 , D33 , C50) ) ) ) by L245 , AFINSQ_1:def 3
.= ( D36 . ( IC ( Comput (D34 , D33 , C50) ) ) ) by L246 , FUNCT_4:13
.= ( CurInstr (D36 , ( Comput (D36 , D35 , C50) )) ) by L239 , L243 , NAT_1:13 , PBOOLE:143;
thus L248: thesis by L247 , L239 , L243 , L242 , L240 , NAT_1:13;
end;
L249: S2[ ( 0 ) ];
L250: (for B47 being (Element of ( NAT )) holds S2[ B47 ]) from NAT_1:sch 1(L249 , L238);
thus L251: thesis by L250 , L237;
end;
theorem
L252: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B48 , B49 being (Program of ( SCMPDS )) holds (for B50 being (Element of ( NAT )) holds ((B48 c= B49 & B48 is_closed_on R9 , R19 & B48 is_halting_on R9 , R19 & B50 <= ( LifeSpan (( R19 +* ( stop B48 ) ) , ( Initialize R9 )) )) implies ( Comput (( R19 +* B49 ) , ( Initialize R9 ) , B50) ) = ( Comput (( R19 +* ( stop B48 ) ) , ( Initialize R9 ) , B50) ))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C51 , C52 being (Program of ( SCMPDS ));
let C53 being (Element of ( NAT ));
set D38 = ( LifeSpan (( R19 +* ( stop C51 ) ) , ( Initialize R9 )) );
assume that
L253: C51 c= C52
and
L254: C51 is_closed_on R9 , R19
and
L255: C51 is_halting_on R9 , R19
and
L256: C53 <= D38;
set D39 = ( Initialize R9 );
set D40 = ( Initialize R9 );
set D41 = ( R19 +* C52 );
set D42 = ( R19 +* ( stop C51 ) );
defpred S3[ (Element of ( NAT )) ] means ($1 <= D38 implies ( Comput (D41 , D39 , $1) ) = ( Comput (D42 , D40 , $1) ));
L257:
now
let C54 being (Element of ( NAT ));
assume L258: S3[ C54 ];
L259:
now
L260: ( Comput (D42 , D40 , ( C54 + 1 )) ) = ( Following (D42 , ( Comput (D42 , D40 , C54) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D42 , ( Comput (D42 , D40 , C54) )) ) , ( Comput (D42 , D40 , C54) )) );
L261: ( Comput (D41 , D39 , ( C54 + 1 )) ) = ( Following (D41 , ( Comput (D41 , D39 , C54) )) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D41 , ( Comput (D41 , D39 , C54) )) ) , ( Comput (D41 , D39 , C54) )) );
L262: C54 < ( C54 + 1 ) by XREAL_1:29;
assume L263: ( C54 + 1 ) <= D38;
L264: C54 < D38 by L263 , L262 , XXREAL_0:2;
L265: ( IC ( Comput (D42 , D40 , C54) ) ) in ( dom C51 ) by L264 , L254 , L255 , SCMPDS_6:26;
L266: ( IC ( Comput (D42 , D40 , C54) ) ) in ( dom ( stop C51 ) ) by L265 , FUNCT_4:12;
L267: C52 c= D41 by FUNCT_4:25;
L268: ( dom C51 ) c= ( dom C52 ) by L253 , RELAT_1:11;
L269: ( CurInstr (D41 , ( Comput (D41 , D39 , C54) )) ) = ( D41 . ( IC ( Comput (D42 , D40 , C54) ) ) ) by L258 , L263 , L262 , PBOOLE:143 , XXREAL_0:2
.= ( C52 . ( IC ( Comput (D42 , D40 , C54) ) ) ) by L267 , L268 , L265 , GRFUNC_1:2
.= ( C51 . ( IC ( Comput (D42 , D40 , C54) ) ) ) by L253 , L265 , GRFUNC_1:2
.= ( ( stop C51 ) . ( IC ( Comput (D42 , D40 , C54) ) ) ) by L265 , AFINSQ_1:def 3
.= ( D42 . ( IC ( Comput (D42 , D40 , C54) ) ) ) by L266 , FUNCT_4:13
.= ( CurInstr (D42 , ( Comput (D42 , D40 , C54) )) ) by PBOOLE:143;
thus L270: ( Comput (D41 , D39 , ( C54 + 1 )) ) = ( Comput (D42 , D40 , ( C54 + 1 )) ) by L269 , L258 , L263 , L262 , L261 , L260 , XXREAL_0:2;
end;
thus L271: S3[ ( C54 + 1 ) ] by L259;
end;
L272: S3[ ( 0 ) ];
L273: (for B51 being (Element of ( NAT )) holds S3[ B51 ]) from NAT_1:sch 1(L272 , L257);
thus L274: thesis by L273 , L256;
end;
theorem
L275: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B52 , B53 being (Program of ( SCMPDS )) holds (for B54 being (Element of ( NAT )) holds ((B54 <= ( LifeSpan (( R19 +* ( stop B52 ) ) , ( Initialize R9 )) ) & B52 c= B53 & B52 is_closed_on R9 , R19 & B52 is_halting_on R9 , R19) implies ( IC ( Comput (( R19 +* B53 ) , ( Initialize R9 ) , B54) ) ) in ( dom ( stop B52 ) ))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C55 , C56 being (Program of ( SCMPDS ));
let C57 being (Element of ( NAT ));
set D43 = ( Initialize R9 );
set D44 = ( R19 +* ( stop C55 ) );
set D45 = ( Comput (( R19 +* C56 ) , ( Initialize R9 ) , C57) );
set D46 = ( Comput (D44 , D43 , C57) );
assume that
L276: C57 <= ( LifeSpan (D44 , D43) )
and
L277: C55 c= C56
and
L278: C55 is_closed_on R9 , R19
and
L279: C55 is_halting_on R9 , R19;
L280: D45 = D46 by L276 , L277 , L278 , L279 , L252;
thus L281: thesis by L280 , L278 , SCMPDS_6:def 2;
end;
theorem
L282: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B55 , B56 being (Program of ( SCMPDS )) holds ((B55 c= B56 & B55 is_closed_on R9 , R19 & B55 is_halting_on R9 , R19) implies (( CurInstr (( R19 +* B56 ) , ( Comput (( R19 +* B56 ) , ( Initialize R9 ) , ( LifeSpan (( R19 +* ( stop B55 ) ) , ( Initialize R9 )) )) )) ) = ( halt ( SCMPDS ) ) or ( IC ( Comput (( R19 +* B56 ) , ( Initialize R9 ) , ( LifeSpan (( R19 +* ( stop B55 ) ) , ( Initialize R9 )) )) ) ) = ( card B55 ))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C58 , C59 being (Program of ( SCMPDS ));
set D47 = ( Initialize R9 );
set D48 = ( R19 +* ( stop C58 ) );
set D49 = ( LifeSpan (D48 , D47) );
set D50 = ( Initialize R9 );
set D51 = ( R19 +* C59 );
set D52 = ( Comput (D51 , D50 , D49) );
set D53 = ( Comput (D48 , D47 , D49) );
set D54 = D51;
set D55 = D48;
set D56 = ( IC D53 );
assume that
L283: C58 c= C59
and
L284: C58 is_closed_on R9 , R19
and
L285: C58 is_halting_on R9 , R19;
L286: ( dom C58 ) c= ( dom C59 ) by L283 , GRFUNC_1:2;
reconsider D57 = D56 as (Element of ( NAT ));
L287: ( stop C58 ) c= D55 by FUNCT_4:25;
L288: D48 halts_on D47 by L285 , SCMPDS_6:def 3;
L289: D56 in ( dom ( stop C58 ) ) by L284 , SCMPDS_6:def 2;
L290: ( card ( stop C58 ) ) = ( ( card C58 ) + 1 ) by COMPOS_1:55;
L291: D57 < ( ( card C58 ) + 1 ) by L290 , L289 , AFINSQ_1:66;
L292: D57 <= ( card C58 ) by L291 , INT_1:7;
L293: ( IC D52 ) = D56 by L283 , L284 , L285 , L252;
L294:
now
per cases  by L292 , XXREAL_0:1;
case L295: D57 < ( card C58 );
L296: D57 in ( dom C58 ) by L295 , AFINSQ_1:66;
thus L297: ( halt ( SCMPDS ) ) = ( CurInstr (D55 , D53) ) by L288 , EXTPRO_1:def 15
.= ( D48 . D56 ) by PBOOLE:143
.= ( ( stop C58 ) . D56 ) by L289 , L287 , GRFUNC_1:2
.= ( C58 . D56 ) by L296 , AFINSQ_1:def 3
.= ( C59 . D56 ) by L283 , L296 , GRFUNC_1:2
.= ( D51 . ( IC D52 ) ) by L286 , L293 , L296 , FUNCT_4:13
.= ( CurInstr (D54 , D52) ) by PBOOLE:143;
end;
case L298: D57 = ( card C58 );
thus L299: ( IC D52 ) = ( card C58 ) by L298 , L283 , L284 , L285 , L252;
end;
end;
thus L301: thesis by L294;
end;
theorem
L302: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B57 , B58 being (Program of ( SCMPDS )) holds ((B57 is_halting_on R9 , R19 & B58 is_closed_on ( IExec (B57 , R19 , ( Initialize R9 )) ) , R19 & B58 is_halting_on ( IExec (B57 , R19 , ( Initialize R9 )) ) , R19) implies (B58 is_closed_on ( Comput (( R19 +* ( stop B57 ) ) , ( Initialize R9 ) , ( LifeSpan (( R19 +* ( stop B57 ) ) , ( Initialize R9 )) )) ) , ( R19 +* ( stop B57 ) ) & B58 is_halting_on ( Comput (( R19 +* ( stop B57 ) ) , ( Initialize R9 ) , ( LifeSpan (( R19 +* ( stop B57 ) ) , ( Initialize R9 )) )) ) , ( R19 +* ( stop B57 ) ))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C60 , C61 being (Program of ( SCMPDS ));
set D58 = ( Initialize R9 );
set D59 = ( R19 +* ( stop C60 ) );
set D60 = ( Comput (D59 , D58 , ( LifeSpan (D59 , D58) )) );
set D61 = ( IExec (C60 , R19 , ( Initialize R9 )) );
assume that
L303: C60 is_halting_on R9 , R19
and
L304: C61 is_closed_on D61 , R19
and
L305: C61 is_halting_on D61 , R19;
L306: D59 halts_on D58 by L303 , SCMPDS_6:def 3;
L307: ( DataPart D61 ) = ( DataPart D60 ) by L306 , EXTPRO_1:23;
thus L308: thesis by L307 , L304 , L305 , SCMPDS_6:23;
end;
theorem
L309: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B59 being (Program of ( SCMPDS )) holds (for B60 being  shiftable (Program of ( SCMPDS )) holds ((B59 is_closed_on R9 , R19 & B59 is_halting_on R9 , R19 & B60 is_closed_on ( IExec (B59 , R19 , ( Initialize R9 )) ) , R19 & B60 is_halting_on ( IExec (B59 , R19 , ( Initialize R9 )) ) , R19) implies (( B59 ';' B60 ) is_closed_on R9 , R19 & ( B59 ';' B60 ) is_halting_on R9 , R19))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C62 being (Program of ( SCMPDS ));
let C63 being  shiftable (Program of ( SCMPDS ));
set D62 = ( IExec (C62 , R19 , ( Initialize R9 )) );
assume that
L310: C62 is_closed_on R9 , R19
and
L311: C62 is_halting_on R9 , R19
and
L312: C63 is_closed_on D62 , R19
and
L313: C63 is_halting_on D62 , R19;
set D63 = ( C62 ';' C63 );
set D64 = ( stop D63 );
set D65 = ( stop C62 );
set D66 = ( Initialize R9 );
set D67 = ( R19 +* ( stop D63 ) );
set D68 = ( stop C63 );
set D69 = ( Initialize R9 );
set D70 = ( R19 +* ( stop C62 ) );
set D71 = ( LifeSpan (D70 , D69) );
set D72 = ( Comput (D70 , D69 , D71) );
set D73 = ( Initialize D72 );
set D74 = ( D70 +* D68 );
set D75 = ( LifeSpan (D74 , D73) );
L314: C63 is_halting_on D72 , D70 by L311 , L312 , L313 , L302;
L315: D74 halts_on D73 by L314 , SCMPDS_6:def 3;
L316: C63 is_closed_on D72 , D70 by L311 , L312 , L313 , L302;
L317: C63 is_closed_on D73 , D74 by L316 , SCMPDS_6:24;
set D76 = ( Comput (D67 , D66 , D71) );
set D77 = D67;
L318: D68 c= D74 by FUNCT_4:25;
L319: ( DataPart D72 ) = ( DataPart D73 ) by MEMSTR_0:45;
L320: ( C62 ';' ( C63 ';' ( Stop ( SCMPDS ) ) ) ) = ( stop D63 ) by AFINSQ_1:27;
L321: D72 = D76 by L310 , L311 , L234 , L320;
L322: D64 = ( C62 ';' ( C63 ';' ( Stop ( SCMPDS ) ) ) ) by AFINSQ_1:27
.= ( C62 +* ( Shift (D68 , ( card C62 )) ) );
L323: ( Shift (D68 , ( card C62 )) ) c= D64 by L322 , FUNCT_4:25;
L324: D64 c= D67 by FUNCT_4:25;
L325: ( Shift (D68 , ( card C62 )) ) c= D77 by L324 , L323 , XBOOLE_1:1;
L326: ( dom ( stop C62 ) ) c= ( dom D64 ) by SCMPDS_5:13;
L327:
now
let C64 being (Element of ( NAT ));
per cases ;
suppose L328: C64 <= D71;

L329: ( IC ( Comput (D67 , D66 , C64) ) ) in ( dom ( stop C62 ) ) by L328 , L310 , L311 , L11 , L275;
thus L330: ( IC ( Comput (D67 , D66 , C64) ) ) in ( dom D64 ) by L329 , L326;
end;
suppose L331: C64 > D71;

L332: ( IC D76 ) in ( dom D65 ) by L310 , L311 , L11 , L275;
thus L333:now
per cases  by L310 , L311 , L11 , L282;
suppose L334: ( IC D76 ) = ( card C62 );

consider C65 being Nat such that L335: C64 = ( D71 + C65 ) by L331 , NAT_1:10;
reconsider D78 = C65 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D79 = ( IC ( Comput (D74 , D73 , D78) ) ) as (Element of ( NAT ));
L336: ( ( IC ( Comput (D74 , D73 , D78) ) ) + ( card C62 ) ) = ( IC ( Comput (D77 , D76 , D78) ) ) by L318 , L321 , L319 , L317 , L325 , L334 , SCMPDS_6:31;
L337: ( IC ( Comput (D77 , D66 , C64) ) ) = ( D79 + ( card C62 ) ) by L336 , L335 , EXTPRO_1:4;
L338: D79 in ( dom D68 ) by L316 , SCMPDS_6:def 2;
L339: D79 < ( card D68 ) by L338 , AFINSQ_1:66;
L340: D79 < ( ( card C63 ) + 1 ) by L339 , COMPOS_1:55;
L341: ( ( card C62 ) + D79 ) < ( ( card C62 ) + ( ( card C63 ) + 1 ) ) by L340 , XREAL_1:6;
L342: ( card D64 ) = ( ( card D63 ) + 1 ) by COMPOS_1:55
.= ( ( ( card C62 ) + ( card C63 ) ) + 1 ) by AFINSQ_1:17;
thus L343: ( IC ( Comput (D67 , D66 , C64) ) ) in ( dom D64 ) by L342 , L341 , L337 , AFINSQ_1:66;
end;
suppose L344: ( CurInstr (D77 , D76) ) = ( halt ( SCMPDS ) );

L345: ( IC ( Comput (D67 , D66 , C64) ) ) = ( IC D76 ) by L344 , L331 , EXTPRO_1:5;
thus L346: ( IC ( Comput (D67 , D66 , C64) ) ) in ( dom D64 ) by L345 , L326 , L332;
end;
end;
end;
end;
thus L335: ( C62 ';' C63 ) is_closed_on R9 , R19 by L327 , SCMPDS_6:def 2;
L336: ( Comput (D67 , D66 , ( D71 + D75 )) ) = ( Comput (D67 , ( Comput (D67 , D66 , D71) ) , D75) ) by EXTPRO_1:4;
per cases  by L310 , L311 , L11 , L282;
suppose L337: ( CurInstr (D77 , D76) ) = ( halt ( SCMPDS ) );

L338: D67 halts_on D66 by L337 , EXTPRO_1:29;
thus L339: thesis by L338 , SCMPDS_6:def 3;
end;
suppose L340: ( IC D76 ) = ( card C62 );

L341: ( CurInstr (D67 , ( Comput (D67 , D66 , ( D71 + D75 )) )) ) = ( CurInstr (D74 , ( Comput (D74 , D73 , D75) )) ) by L340 , L336 , L318 , L321 , L319 , L317 , L325 , SCMPDS_6:31
.= ( halt ( SCMPDS ) ) by L315 , EXTPRO_1:def 15;
L342: D67 halts_on D66 by L341 , EXTPRO_1:29;
thus L343: thesis by L342 , SCMPDS_6:def 3;
end;
end;
theorem
L345: (for R9 being (State of ( SCMPDS )) holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B61 being  halt-free (Program of ( SCMPDS )) holds (for B62 being (Program of ( SCMPDS )) holds ((B61 c= B62 & B61 is_closed_on R9 , R19 & B61 is_halting_on R9 , R19) implies ( IC ( Comput (( R19 +* B62 ) , ( Initialize R9 ) , ( LifeSpan (( R19 +* ( stop B61 ) ) , ( Initialize R9 )) )) ) ) = ( card B61 ))))))
proof
let R9 being (State of ( SCMPDS ));
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C66 being  halt-free (Program of ( SCMPDS ));
let C67 being (Program of ( SCMPDS ));
set D80 = ( Initialize R9 );
set D81 = ( R19 +* C67 );
set D82 = ( Initialize R9 );
set D83 = ( R19 +* ( stop C66 ) );
set D84 = ( LifeSpan (D83 , D82) );
assume that
L346: C66 c= C67
and
L347: C66 is_closed_on R9 , R19
and
L348: C66 is_halting_on R9 , R19;
thus L349: ( IC ( Comput (D81 , D80 , D84) ) ) = ( IC ( Comput (D83 , D82 , ( LifeSpan (D83 , D82) )) ) ) by L346 , L347 , L348 , L252
.= ( card C66 ) by L347 , L348 , SCMPDS_6:29;
end;
theorem
L350: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B63 being (Program of ( SCMPDS )) holds (for B64 being (State of ( SCMPDS )) holds (for B65 being (Element of ( NAT )) holds ((B63 is_halting_on B64 , R19 & B65 < ( LifeSpan (( R19 +* ( stop B63 ) ) , ( Initialize B64 )) )) implies ( CurInstr (( R19 +* ( stop B63 ) ) , ( Comput (( R19 +* ( stop B63 ) ) , ( Initialize B64 ) , B65) )) ) <> ( halt ( SCMPDS ) ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C68 being (Program of ( SCMPDS ));
let C69 being (State of ( SCMPDS ));
let C70 being (Element of ( NAT ));
set D85 = ( Initialize C69 );
set D86 = ( R19 +* ( stop C68 ) );
set D87 = ( LifeSpan (D86 , D85) );
assume that
L351: C68 is_halting_on C69 , R19
and
L352: C70 < D87;
assume L353: ( CurInstr (D86 , ( Comput (D86 , D85 , C70) )) ) = ( halt ( SCMPDS ) );
L354: D86 halts_on D85 by L351 , SCMPDS_6:def 3;
thus L355: thesis by L354 , L352 , L353 , EXTPRO_1:def 15;
end;
theorem
L356: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B66 , B67 being (Program of ( SCMPDS )) holds (for B68 being ( 0 ) -started (State of ( SCMPDS )) holds (for B69 being (Element of ( NAT )) holds ((B66 is_closed_on B68 , R19 & B66 is_halting_on B68 , R19 & B69 < ( LifeSpan (( R19 +* ( stop B66 ) ) , B68) )) implies ( CurInstr (( R19 +* ( stop ( B66 ';' B67 ) ) ) , ( Comput (( R19 +* ( stop ( B66 ';' B67 ) ) ) , B68 , B69) )) ) <> ( halt ( SCMPDS ) ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C71 , C72 being (Program of ( SCMPDS ));
let C73 being ( 0 ) -started (State of ( SCMPDS ));
let C74 being (Element of ( NAT ));
set D88 = ( R19 +* ( stop C71 ) );
set D89 = ( R19 +* ( stop ( C71 ';' C72 ) ) );
set D90 = ( LifeSpan (D88 , C73) );
set D91 = ( Comput (D89 , C73 , C74) );
set D92 = D89;
assume that
L357: C71 is_closed_on C73 , R19
and
L358: C71 is_halting_on C73 , R19
and
L359: C74 < D90;
assume L360: ( CurInstr (D92 , D91) ) = ( halt ( SCMPDS ) );
L361: ( CurInstr (D88 , ( Comput (D88 , C73 , C74) )) ) = ( halt ( SCMPDS ) ) by L360 , L357 , L358 , L359 , SCMPDS_6:27;
L362: ( Initialize C73 ) = C73 by MEMSTR_0:44;
L363: D88 halts_on C73 by L362 , L358 , SCMPDS_6:def 3;
thus L364: thesis by L363 , L359 , L361 , EXTPRO_1:def 15;
end;
L365: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for R20 being (Instruction-Sequence of ( SCMPDS )) holds (for R21 being (Instruction-Sequence of ( SCMPDS )) holds (for B70 being  halt-free (Program of ( SCMPDS )) holds (for B71 being  shiftable (Program of ( SCMPDS )) holds (for B72 being ( 0 ) -started (State of ( SCMPDS )) holds ((B70 is_closed_on B72 , R19 & B70 is_halting_on B72 , R19 & B71 is_closed_on ( IExec (B70 , R19 , B72) ) , R19 & B71 is_halting_on ( IExec (B70 , R19 , B72) ) , R19 & R21 = ( R19 +* ( stop ( B70 ';' B71 ) ) ) & R20 = ( R19 +* ( stop B70 ) )) implies (( IC ( Comput (R21 , B72 , ( LifeSpan (R20 , B72) )) ) ) = ( card B70 ) & ( DataPart ( Comput (R21 , B72 , ( LifeSpan (R20 , B72) )) ) ) = ( DataPart ( Initialize ( Comput (R20 , B72 , ( LifeSpan (R20 , B72) )) ) ) ) & ( Shift (( stop B71 ) , ( card B70 )) ) c= R21 & ( LifeSpan (R21 , B72) ) = ( ( LifeSpan (R20 , B72) ) + ( LifeSpan (( R20 +* ( stop B71 ) ) , ( Initialize ( Result (R20 , B72) ) )) ) )))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let R20 being (Instruction-Sequence of ( SCMPDS ));
let R21 being (Instruction-Sequence of ( SCMPDS ));
let C75 being  halt-free (Program of ( SCMPDS ));
let C76 being  shiftable (Program of ( SCMPDS ));
let C77 being ( 0 ) -started (State of ( SCMPDS ));
set D93 = ( stop C76 );
set D94 = ( C75 ';' C76 );
set D95 = ( stop D94 );
set D96 = ( LifeSpan (R20 , C77) );
set D97 = ( Comput (R20 , C77 , D96) );
set D98 = ( Initialize D97 );
set D99 = ( R20 +* D93 );
set D100 = ( LifeSpan (D99 , D98) );
set D101 = ( IExec (C75 , R19 , C77) );
assume that
L366: C75 is_closed_on C77 , R19
and
L367: C75 is_halting_on C77 , R19
and
L368: C76 is_closed_on D101 , R19
and
L369: C76 is_halting_on D101 , R19
and
L370: R21 = ( R19 +* ( stop ( C75 ';' C76 ) ) )
and
L371: R20 = ( R19 +* ( stop C75 ) );
set D102 = ( Comput (R21 , C77 , D96) );
set D103 = R21;
L372: ( Initialize C77 ) = C77 by MEMSTR_0:44;
thus L373: ( IC D102 ) = ( card C75 ) by L372 , L366 , L367 , L11 , L345 , L370 , L371;
L374: D93 c= D99 by FUNCT_4:25;
L375: ( DataPart ( Comput (R20 , C77 , D96) ) ) = ( DataPart D98 ) by MEMSTR_0:45;
L376: ( C75 ';' ( C76 ';' ( Stop ( SCMPDS ) ) ) ) = ( stop D94 ) by AFINSQ_1:27;
thus L377: ( DataPart D102 ) = ( DataPart D98 ) by L376 , L375 , L366 , L367 , L234 , L371 , L372 , L370;
reconsider D104 = ( D96 + D100 ) as (Element of ( NAT ));
L378: D95 = ( C75 ';' ( C76 ';' ( Stop ( SCMPDS ) ) ) ) by AFINSQ_1:27
.= ( C75 +* ( Shift (D93 , ( card C75 )) ) );
L379: ( Shift (D93 , ( card C75 )) ) c= D95 by L378 , FUNCT_4:25;
L380: D95 c= R21 by L370 , FUNCT_4:25;
thus L381: ( Shift (D93 , ( card C75 )) ) c= D103 by L380 , L379 , XBOOLE_1:1;
L382: C76 is_halting_on D97 , R20 by L367 , L368 , L369 , L302 , L371 , L372;
L383: D99 halts_on D98 by L382 , SCMPDS_6:def 3;
L384: ( Comput (R21 , C77 , ( D96 + D100 )) ) = ( Comput (R21 , ( Comput (R21 , C77 , D96) ) , D100) ) by EXTPRO_1:4;
L385: C76 is_closed_on D97 , R20 by L367 , L368 , L369 , L302 , L371 , L372;
L386: C76 is_closed_on D98 , D99 by L385 , SCMPDS_6:24;
L387: ( CurInstr (D99 , ( Comput (D99 , D98 , D100) )) ) = ( CurInstr (R21 , ( Comput (R21 , C77 , ( D96 + D100 )) )) ) by L386 , L384 , L374 , L373 , L377 , L381 , SCMPDS_6:31;
L388: ( CurInstr (R21 , ( Comput (R21 , C77 , D104) )) ) = ( halt ( SCMPDS ) ) by L387 , L383 , EXTPRO_1:def 15;
L389:
now
let C78 being (Element of ( NAT ));
assume L390: ( D96 + C78 ) < D104;
L391: C78 < D100 by L390 , XREAL_1:6;
assume L392: ( CurInstr (R21 , ( Comput (R21 , C77 , ( D96 + C78 )) )) ) = ( halt ( SCMPDS ) );
L393: ( CurInstr (D99 , ( Comput (D99 , D98 , C78) )) ) = ( CurInstr (D103 , ( Comput (D103 , D102 , C78) )) ) by L374 , L386 , L373 , L377 , L381 , SCMPDS_6:31
.= ( halt ( SCMPDS ) ) by L392 , EXTPRO_1:4;
thus L394: contradiction by L393 , L383 , L391 , EXTPRO_1:def 15;
end;
L395:
now
let C79 being (Element of ( NAT ));
assume L396: C79 < D104;
per cases ;
suppose L397: C79 < D96;

thus L398: ( CurInstr (R21 , ( Comput (R21 , C77 , C79) )) ) <> ( halt ( SCMPDS ) ) by L397 , L366 , L367 , L356 , L370 , L371;
end;
suppose L399: D96 <= C79;

consider C80 being Nat such that L400: ( D96 + C80 ) = C79 by L399 , NAT_1:10;
reconsider D105 = C80 as (Element of ( NAT )) by ORDINAL1:def 12;
L401: ( D96 + D105 ) = C79 by L400;
thus L402: ( CurInstr (R21 , ( Comput (R21 , C77 , C79) )) ) <> ( halt ( SCMPDS ) ) by L401 , L389 , L396;
end;
end;
L404: (for B73 being (Element of ( NAT )) holds (( CurInstr (R21 , ( Comput (R21 , C77 , B73) )) ) = ( halt ( SCMPDS ) ) implies D104 <= B73)) by L395;
L405: R20 halts_on C77 by L367 , L371 , L372 , SCMPDS_6:def 3;
L406: ( Result (R20 , C77) ) = ( Comput (R20 , C77 , ( LifeSpan (R20 , C77) )) ) by L405 , EXTPRO_1:23;
L407: D94 is_halting_on C77 , R19 by L366 , L367 , L368 , L369 , L309 , L372;
L408: R21 halts_on C77 by L407 , L370 , L372 , SCMPDS_6:def 3;
thus L409: thesis by L408 , L406 , L388 , L404 , EXTPRO_1:def 15;
end;
theorem
L410: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B74 being ( 0 ) -started (State of ( SCMPDS )) holds (for B75 being  halt-free (Program of ( SCMPDS )) holds (for B76 being  shiftable (Program of ( SCMPDS )) holds ((B75 is_closed_on B74 , R19 & B75 is_halting_on B74 , R19 & B76 is_closed_on ( IExec (B75 , R19 , B74) ) , R19 & B76 is_halting_on ( IExec (B75 , R19 , B74) ) , R19) implies ( LifeSpan (( R19 +* ( stop ( B75 ';' B76 ) ) ) , B74) ) = ( ( LifeSpan (( R19 +* ( stop B75 ) ) , B74) ) + ( LifeSpan (( ( R19 +* ( stop B75 ) ) +* ( stop B76 ) ) , ( Initialize ( Result (( R19 +* ( stop B75 ) ) , B74) ) )) ) )))))) by L365;
theorem
L411: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B77 being ( 0 ) -started (State of ( SCMPDS )) holds (for B78 being  halt-free (Program of ( SCMPDS )) holds (for B79 being  shiftable (Program of ( SCMPDS )) holds ((B78 is_closed_on B77 , R19 & B78 is_halting_on B77 , R19 & B79 is_closed_on ( IExec (B78 , R19 , B77) ) , R19 & B79 is_halting_on ( IExec (B78 , R19 , B77) ) , R19) implies ( IExec (( B78 ';' B79 ) , R19 , B77) ) = ( IncIC (( IExec (B79 , R19 , ( Initialize ( IExec (B78 , R19 , B77) ) )) ) , ( card B78 )) ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C81 being ( 0 ) -started (State of ( SCMPDS ));
let C82 being  halt-free (Program of ( SCMPDS ));
let C83 being  shiftable (Program of ( SCMPDS ));
set D106 = ( C82 ';' C83 );
set D107 = C81;
set D108 = ( R19 +* ( stop C82 ) );
set D109 = ( LifeSpan (D108 , D107) );
set D110 = ( R19 +* ( stop D106 ) );
set D111 = ( Initialize ( Comput (D108 , D107 , D109) ) );
set D112 = ( D108 +* ( stop C83 ) );
set D113 = ( LifeSpan (D112 , D111) );
set D114 = ( IExec (C82 , R19 , C81) );
assume that
L412: C82 is_closed_on C81 , R19
and
L413: C82 is_halting_on C81 , R19
and
L414: C83 is_closed_on D114 , R19
and
L415: C83 is_halting_on D114 , R19;
L416: ( Initialize C81 ) = C81 by MEMSTR_0:44;
L417: ( DataPart ( Comput (D110 , C81 , D109) ) ) = ( DataPart ( Initialize ( Comput (D108 , D107 , D109) ) ) ) by L412 , L413 , L414 , L415 , L365;
L418: C83 is_closed_on ( Comput (D108 , D107 , D109) ) , D108 by L413 , L414 , L415 , L302 , L416;
L419: C83 is_closed_on D111 , D112 by L418 , SCMPDS_6:24;
L420: ( stop C83 ) c= D112 by FUNCT_4:25;
L421: ( Shift (( stop C83 ) , ( card C82 )) ) c= D110 by L412 , L413 , L414 , L415 , L365;
L422: ( IC ( Comput (D110 , C81 , D109) ) ) = ( card C82 ) by L412 , L413 , L414 , L415 , L365;
L423: ( IC ( Comput (D110 , ( Comput (D110 , C81 , D109) ) , D113) ) ) = ( ( IC ( Comput (D112 , D111 , D113) ) ) + ( card C82 ) ) by L422 , L420 , L417 , L421 , L419 , SCMPDS_6:31;
L424: ( DataPart ( Comput (D110 , ( Comput (D110 , C81 , D109) ) , D113) ) ) = ( DataPart ( Comput (D112 , D111 , D113) ) ) by L420 , L422 , L417 , L421 , L419 , SCMPDS_6:31;
set D115 = ( Initialize ( IExec (C82 , R19 , C81) ) );
set D116 = ( Initialize ( Result (D108 , D107) ) );
L425: ( stop C83 ) c= ( R19 +* ( stop C83 ) ) by FUNCT_4:25;
L426: ( stop C83 ) c= ( D108 +* ( stop C83 ) ) by FUNCT_4:25;
L427: D108 halts_on D107 by L413 , L416 , SCMPDS_6:def 3;
L428: D111 = ( Initialize ( Result (D108 , D107) ) ) by L427 , EXTPRO_1:23;
L429: ( DataPart D114 ) = ( DataPart ( Initialize D114 ) ) by MEMSTR_0:45;
L430: C83 is_closed_on ( Initialize D114 ) , ( R19 +* ( stop C83 ) ) by L429 , L414 , L415 , SCMPDS_6:23;
L431: C83 is_halting_on ( Initialize D114 ) , ( R19 +* ( stop C83 ) ) by L414 , L415 , L429 , SCMPDS_6:23;
L432: D106 is_halting_on C81 , R19 by L412 , L413 , L414 , L415 , L309 , L416;
L433: D110 halts_on C81 by L432 , L416 , SCMPDS_6:def 3;
L434: C83 is_halting_on ( Comput (D108 , D107 , D109) ) , D108 by L413 , L414 , L415 , L302 , L416;
L435: D112 halts_on D111 by L434 , SCMPDS_6:def 3;
L436: ( IExec (C82 , R19 , C81) ) = ( Comput (D108 , D107 , D109) ) by L427 , EXTPRO_1:23;
L437: ( Result (( R19 +* ( stop C83 ) ) , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) = ( Result (D112 , D111) ) by L425 , L426 , L430 , L431 , L55 , L436;
L438: ( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) = ( Comput (D112 , D111 , D113) ) by L437 , L435 , EXTPRO_1:23;
L439: ( IC ( IExec (( C82 ';' C83 ) , R19 , C81) ) ) = ( IC ( Comput (D110 , C81 , ( LifeSpan (D110 , C81) )) ) ) by L433 , EXTPRO_1:23
.= ( IC ( Comput (D110 , C81 , ( D109 + D113 )) ) ) by L412 , L413 , L414 , L415 , L428 , L365
.= ( ( IC ( Comput (D112 , D111 , D113) ) ) + ( card C82 ) ) by L423 , EXTPRO_1:4
.= ( ( IC ( Result (D112 , D111) ) ) + ( card C82 ) ) by L435 , EXTPRO_1:23
.= ( ( IC ( Result (( D108 +* ( stop C83 ) ) , ( Initialize ( Result (D108 , D107) ) )) ) ) + ( card C82 ) ) by L427 , EXTPRO_1:23
.= ( ( IC ( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) ) + ( card C82 ) ) by L425 , L426 , L430 , L431 , L55;
L440: ( IExec (( C82 ';' C83 ) , R19 , C81) ) = ( Comput (D110 , C81 , ( LifeSpan (D110 , C81) )) ) by L433 , EXTPRO_1:23
.= ( Comput (D110 , C81 , ( D109 + D113 )) ) by L412 , L413 , L414 , L415 , L428 , L365;
L441: ( DataPart ( IExec (( C82 ';' C83 ) , R19 , C81) ) ) = ( DataPart ( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) ) by L440 , L438 , L424 , EXTPRO_1:4;
thus L442:now
reconsider D117 = ( ( IC ( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) ) + ( card C82 ) ) as (Element of ( NAT ));
L443: ( dom ( Start-At (D117 , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
L444:
now
let C84 being set;
assume L445: C84 in ( dom ( IExec (( C82 ';' C83 ) , R19 , C81) ) );
per cases  by L445 , SCMPDS_4:6;
suppose L446: C84 is Int_position;

L447: C84 <> ( IC ( SCMPDS ) ) by L446 , SCMPDS_2:43;
L448: (not C84 in ( dom ( Start-At (D117 , ( SCMPDS )) ) )) by L447 , L443 , TARSKI:def 1;
L449: ( ( IExec (( C82 ';' C83 ) , R19 , C81) ) . C84 ) = ( ( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) . C84 ) by L441 , L446 , SCMPDS_4:8;
thus L450: ( ( IExec (( C82 ';' C83 ) , R19 , C81) ) . C84 ) = ( ( IncIC (( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) , ( card C82 )) ) . C84 ) by L449 , L448 , FUNCT_4:11;
end;
suppose L451: C84 = ( IC ( SCMPDS ) );

L452: C84 in { ( IC ( SCMPDS ) ) } by L451 , TARSKI:def 1;
L453: C84 in ( dom ( Start-At (D117 , ( SCMPDS )) ) ) by L452 , FUNCOP_1:13;
thus L454: ( ( IExec (( C82 ';' C83 ) , R19 , C81) ) . C84 ) = ( ( Start-At (D117 , ( SCMPDS )) ) . ( IC ( SCMPDS ) ) ) by L439 , L451 , FUNCOP_1:72
.= ( ( IncIC (( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) , ( card C82 )) ) . C84 ) by L451 , L453 , FUNCT_4:13;
end;
end;
L456: ( dom ( IExec (( C82 ';' C83 ) , R19 , C81) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( IncIC (( IExec (C83 , R19 , ( Initialize ( IExec (C82 , R19 , C81) ) )) ) , ( card C82 )) ) ) by PARTFUN1:def 2;
thus L457: thesis by L456 , L444 , FUNCT_1:2;
end;
end;
theorem
L443: (for R4 being Int_position holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B80 being ( 0 ) -started (State of ( SCMPDS )) holds (for B81 being  halt-free (Program of ( SCMPDS )) holds (for B82 being  shiftable (Program of ( SCMPDS )) holds ((B81 is_closed_on B80 , R19 & B81 is_halting_on B80 , R19 & B82 is_closed_on ( IExec (B81 , R19 , B80) ) , R19 & B82 is_halting_on ( IExec (B81 , R19 , B80) ) , R19) implies ( ( IExec (( B81 ';' B82 ) , R19 , B80) ) . R4 ) = ( ( IExec (B82 , R19 , ( Initialize ( IExec (B81 , R19 , B80) ) )) ) . R4 )))))))
proof
let R4 being Int_position;
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C85 being ( 0 ) -started (State of ( SCMPDS ));
let C86 being  halt-free (Program of ( SCMPDS ));
let C87 being  shiftable (Program of ( SCMPDS ));
assume that
L444: C86 is_closed_on C85 , R19
and
L445: C86 is_halting_on C85 , R19
and
L446: C87 is_closed_on ( IExec (C86 , R19 , C85) ) , R19
and
L447: C87 is_halting_on ( IExec (C86 , R19 , C85) ) , R19;
L448: (not R4 in ( dom ( Start-At (( ( IC ( IExec (C87 , R19 , ( Initialize ( IExec (C86 , R19 , C85) ) )) ) ) + ( card C86 ) ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L449: ( IExec (( C86 ';' C87 ) , R19 , C85) ) = ( IncIC (( IExec (C87 , R19 , ( Initialize ( IExec (C86 , R19 , C85) ) )) ) , ( card C86 )) ) by L444 , L445 , L446 , L447 , L411;
thus L450: thesis by L449 , L448 , FUNCT_4:11;
end;
theorem
L451: (for R4 being Int_position holds (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B83 being ( 0 ) -started (State of ( SCMPDS )) holds (for B84 being  halt-free (Program of ( SCMPDS )) holds (for B85 being  parahalting  shiftable (Instruction of ( SCMPDS )) holds ((B84 is_closed_on B83 , R19 & B84 is_halting_on B83 , R19) implies ( ( IExec (( B84 ';' B85 ) , R19 , B83) ) . R4 ) = ( ( Exec (B85 , ( IExec (B84 , R19 , B83) )) ) . R4 )))))))
proof
let R4 being Int_position;
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C88 being ( 0 ) -started (State of ( SCMPDS ));
let C89 being  halt-free (Program of ( SCMPDS ));
let C90 being  parahalting  shiftable (Instruction of ( SCMPDS ));
assume that
L452: C89 is_closed_on C88 , R19
and
L453: C89 is_halting_on C88 , R19;
set D118 = ( Load C90 );
L454: R4 in ( SCM-Data-Loc ) by AMI_2:def 16;
L455: (for R4 being Int_position holds ( ( Initialize ( IExec (C89 , R19 , C88) ) ) . R4 ) = ( ( IExec (C89 , R19 , C88) ) . R4 )) by SCMPDS_5:15;
L456: ( DataPart ( Initialize ( IExec (C89 , R19 , C88) ) ) ) = ( DataPart ( IExec (C89 , R19 , C88) ) ) by L455 , SCMPDS_4:8;
L457: D118 is_halting_on ( IExec (C89 , R19 , C88) ) , R19 by SCMPDS_6:21;
L458: D118 is_closed_on ( IExec (C89 , R19 , C88) ) , R19 by SCMPDS_6:20;
thus L459: ( ( IExec (( C89 ';' C90 ) , R19 , C88) ) . R4 ) = ( ( IExec (D118 , R19 , ( Initialize ( IExec (C89 , R19 , C88) ) )) ) . R4 ) by L458 , L452 , L453 , L457 , L443
.= ( ( Exec (C90 , ( Initialize ( IExec (C89 , R19 , C88) ) )) ) . R4 ) by SCMPDS_5:40
.= ( ( DataPart ( Exec (C90 , ( Initialize ( IExec (C89 , R19 , C88) ) )) ) ) . R4 ) by L454 , FUNCT_1:49 , SCMPDS_2:84
.= ( ( DataPart ( Exec (C90 , ( IExec (C89 , R19 , C88) )) ) ) . R4 ) by L456 , SCMPDS_5:39
.= ( ( Exec (C90 , ( IExec (C89 , R19 , C88) )) ) . R4 ) by L454 , FUNCT_1:49 , SCMPDS_2:84;
end;
begin
definition
let C91 being Int_position;
let C92 being Integer;
let C93 being (Element of ( NAT ));
let C94 being (Program of ( SCMPDS ));
func for-up (C91 , C92 , C93 , C94) -> (Program of ( SCMPDS )) equals 
( ( ( ( (C91 , C92) >=0_goto ( ( card C94 ) + 3 ) ) ';' C94 ) ';' ( AddTo (C91 , C92 , C93) ) ) ';' ( goto ( - ( ( card C94 ) + 2 ) ) ) );
coherence;
end;
begin
theorem
L461: (for B86 being Int_position holds (for B87 being Integer holds (for B88 being (Element of ( NAT )) holds (for B89 being (Program of ( SCMPDS )) holds ( card ( for-up (B86 , B87 , B88 , B89) ) ) = ( ( card B89 ) + 3 )))))
proof
let C95 being Int_position;
let C96 being Integer;
let C97 being (Element of ( NAT ));
let C98 being (Program of ( SCMPDS ));
set D119 = ( (C95 , C96) >=0_goto ( ( card C98 ) + 3 ) );
set D120 = ( AddTo (C95 , C96 , C97) );
set D121 = ( D119 ';' C98 );
set D122 = ( D121 ';' D120 );
L462: ( card D121 ) = ( ( card C98 ) + 1 ) by SCMPDS_6:6;
L463: ( card D122 ) = ( ( ( card C98 ) + 1 ) + 1 ) by L462 , SCMP_GCD:4
.= ( ( card C98 ) + ( 1 + 1 ) );
thus L464: ( card ( for-up (C95 , C96 , C97 , C98) ) ) = ( ( ( card C98 ) + 2 ) + 1 ) by L463 , SCMP_GCD:4
.= ( ( card C98 ) + 3 );
end;
L465: (for B90 being Int_position holds (for B91 being Integer holds (for B92 being (Element of ( NAT )) holds (for B93 being (Program of ( SCMPDS )) holds ( card ( stop ( for-up (B90 , B91 , B92 , B93) ) ) ) = ( ( card B93 ) + 4 )))))
proof
let C99 being Int_position;
let C100 being Integer;
let C101 being (Element of ( NAT ));
let C102 being (Program of ( SCMPDS ));
thus L466: ( card ( stop ( for-up (C99 , C100 , C101 , C102) ) ) ) = ( ( card ( for-up (C99 , C100 , C101 , C102) ) ) + 1 ) by COMPOS_1:55
.= ( ( ( card C102 ) + 3 ) + 1 ) by L461
.= ( ( card C102 ) + 4 );
end;
theorem
L467: (for B94 being Int_position holds (for B95 being Integer holds (for B96 , B97 being (Element of ( NAT )) holds (for B98 being (Program of ( SCMPDS )) holds (B97 < ( ( card B98 ) + 3 ) iff B97 in ( dom ( for-up (B94 , B95 , B96 , B98) ) ))))))
proof
let C103 being Int_position;
let C104 being Integer;
let C105 , C106 being (Element of ( NAT ));
let C107 being (Program of ( SCMPDS ));
L468: ( card ( for-up (C103 , C104 , C105 , C107) ) ) = ( ( card C107 ) + 3 ) by L461;
thus L469: thesis by L468 , AFINSQ_1:66;
end;
theorem
L470: (for B99 being Int_position holds (for B100 being Integer holds (for B101 being (Element of ( NAT )) holds (for B102 being (Program of ( SCMPDS )) holds (( ( for-up (B99 , B100 , B101 , B102) ) . ( 0 ) ) = ( (B99 , B100) >=0_goto ( ( card B102 ) + 3 ) ) & ( ( for-up (B99 , B100 , B101 , B102) ) . ( ( card B102 ) + 1 ) ) = ( AddTo (B99 , B100 , B101) ) & ( ( for-up (B99 , B100 , B101 , B102) ) . ( ( card B102 ) + 2 ) ) = ( goto ( - ( ( card B102 ) + 2 ) ) ))))))
proof
let C108 being Int_position;
let C109 being Integer;
let C110 being (Element of ( NAT ));
let C111 being (Program of ( SCMPDS ));
set D123 = ( (C108 , C109) >=0_goto ( ( card C111 ) + 3 ) );
set D124 = ( AddTo (C108 , C109 , C110) );
set D125 = ( goto ( - ( ( card C111 ) + 2 ) ) );
set D126 = ( D123 ';' C111 );
set D127 = ( D126 ';' D124 );
set D128 = ( D124 ';' D125 );
set D129 = ( C111 ';' D128 );
set D130 = ( for-up (C108 , C109 , C110 , C111) );
L471: D130 = ( D126 ';' D128 ) by SCMPDS_4:13;
L472: D130 = ( D123 ';' D129 ) by L471 , SCMPDS_4:14;
thus L473: ( D130 . ( 0 ) ) = D123 by L472 , SCMPDS_6:7;
L474: ( card D126 ) = ( ( card C111 ) + 1 ) by SCMPDS_6:6;
thus L475: ( D130 . ( ( card C111 ) + 1 ) ) = D124 by L474 , SCMP_GCD:7;
L476: ( card D127 ) = ( ( ( card C111 ) + 1 ) + 1 ) by L474 , SCMP_GCD:4
.= ( ( card C111 ) + ( 1 + 1 ) );
thus L477: thesis by L476 , SCMP_GCD:6;
end;
theorem
L478: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B103 being (State of ( SCMPDS )) holds (for B104 being (Program of ( SCMPDS )) holds (for B105 being Int_position holds (for B106 being Integer holds (for B107 being (Element of ( NAT )) holds (( B103 . ( DataLoc (( B103 . B105 ) , B106) ) ) >= ( 0 ) implies (( for-up (B105 , B106 , B107 , B104) ) is_closed_on B103 , R19 & ( for-up (B105 , B106 , B107 , B104) ) is_halting_on B103 , R19))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C112 being (State of ( SCMPDS ));
let C113 being (Program of ( SCMPDS ));
let C114 being Int_position;
let C115 being Integer;
let C116 being (Element of ( NAT ));
set D131 = ( DataLoc (( C112 . C114 ) , C115) );
assume L479: ( C112 . D131 ) >= ( 0 );
set D132 = ( (C114 , C115) >=0_goto ( ( card C113 ) + 3 ) );
set D133 = ( AddTo (C114 , C115 , C116) );
set D134 = ( goto ( - ( ( card C113 ) + 2 ) ) );
set D135 = ( for-up (C114 , C115 , C116 , C113) );
set D136 = ( stop D135 );
set D137 = ( Initialize C112 );
set D138 = ( R19 +* D136 );
set D139 = ( Comput (D138 , D137 , 1) );
set D140 = D138;
L480: ( IC D137 ) = ( 0 ) by MEMSTR_0:def 11;
L481: (not D131 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L482: (not C114 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L483: ( D137 . ( DataLoc (( D137 . C114 ) , C115) ) ) = ( D137 . D131 ) by L482 , FUNCT_4:11
.= ( C112 . D131 ) by L481 , FUNCT_4:11;
L484: D135 = ( D132 ';' ( ( C113 ';' D133 ) ';' D134 ) ) by L4;
L485: ( Comput (D138 , D137 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D138 , ( Comput (D138 , D137 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D138 , D137) )
.= ( Exec (D132 , D137) ) by L484 , SCMPDS_6:11;
L486: ( IC D139 ) = ( ICplusConst (D137 , ( ( card C113 ) + 3 )) ) by L485 , L479 , L483 , SCMPDS_2:57
.= ( (( 0 ) qua Nat) + ( ( card C113 ) + 3 ) ) by L480 , SCMPDS_6:12;
L487: ( card D135 ) = ( ( card C113 ) + 3 ) by L461;
L488: ( ( card C113 ) + 3 ) in ( dom D136 ) by L487 , COMPOS_1:64;
L489: D136 c= D140 by FUNCT_4:25;
L490: ( D140 . ( ( card C113 ) + 3 ) ) = ( D136 . ( ( card C113 ) + 3 ) ) by L489 , L488 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L487 , COMPOS_1:64;
L491: ( CurInstr (D140 , D139) ) = ( halt ( SCMPDS ) ) by L490 , L486 , PBOOLE:143;
L492:
now
let C117 being (Element of ( NAT ));
per cases ;
suppose L493: ( 0 ) < C117;

L494: ( 1 + (( 0 ) qua Nat) ) <= C117 by L493 , INT_1:7;
thus L495: ( IC ( Comput (D138 , D137 , C117) ) ) in ( dom D136 ) by L494 , L488 , L486 , L491 , EXTPRO_1:5;
end;
suppose L496: C117 = ( 0 );

L497: ( Comput (D138 , D137 , C117) ) = D137 by L496 , EXTPRO_1:2;
thus L498: ( IC ( Comput (D138 , D137 , C117) ) ) in ( dom D136 ) by L497 , L480 , COMPOS_1:36;
end;
end;
thus L500: D135 is_closed_on C112 , R19 by L492 , SCMPDS_6:def 2;
L501: D138 halts_on D137 by L491 , EXTPRO_1:29;
thus L502: thesis by L501 , SCMPDS_6:def 3;
end;
theorem
L503: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B108 being (State of ( SCMPDS )) holds (for B109 being (Program of ( SCMPDS )) holds (for B110 , B111 being Int_position holds (for B112 being Integer holds (for B113 being (Element of ( NAT )) holds (( B108 . ( DataLoc (( B108 . B110 ) , B112) ) ) >= ( 0 ) implies ( IExec (( for-up (B110 , B112 , B113 , B109) ) , R19 , ( Initialize B108 )) ) = ( B108 +* ( Start-At (( ( card B109 ) + 3 ) , ( SCMPDS )) ) ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C118 being (State of ( SCMPDS ));
let C119 being (Program of ( SCMPDS ));
let C120 , C121 being Int_position;
let C122 being Integer;
let C123 being (Element of ( NAT ));
set D141 = ( DataLoc (( C118 . C120 ) , C122) );
set D142 = ( for-up (C120 , C122 , C123 , C119) );
set D143 = ( stop D142 );
set D144 = ( Initialize C118 );
set D145 = ( R19 +* D143 );
set D146 = ( Comput (D145 , D144 , 1) );
set D147 = D145;
set D148 = ( (C120 , C122) >=0_goto ( ( card C119 ) + 3 ) );
set D149 = ( AddTo (C120 , C122 , C123) );
set D150 = ( goto ( - ( ( card C119 ) + 2 ) ) );
set D151 = ( Start-At (( ( card C119 ) + 3 ) , ( SCMPDS )) );
L504: ( IC D144 ) = ( 0 ) by MEMSTR_0:def 11;
L505: (not D141 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L506: D143 c= D147 by FUNCT_4:25;
L507: (not C120 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L508: ( D144 . ( DataLoc (( D144 . C120 ) , C122) ) ) = ( D144 . D141 ) by L507 , FUNCT_4:11
.= ( C118 . D141 ) by L505 , FUNCT_4:11;
L509: D142 = ( D148 ';' ( ( C119 ';' D149 ) ';' D150 ) ) by L4;
L510: ( Comput (D145 , D144 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D145 , ( Comput (D145 , D144 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D145 , D144) )
.= ( Exec (D148 , D144) ) by L509 , SCMPDS_6:11;
assume L511: ( C118 . D141 ) >= ( 0 );
L512: ( IC D146 ) = ( ICplusConst (D144 , ( ( card C119 ) + 3 )) ) by L511 , L510 , L508 , SCMPDS_2:57
.= ( (( 0 ) qua Nat) + ( ( card C119 ) + 3 ) ) by L504 , SCMPDS_6:12;
L513: ( card D142 ) = ( ( card C119 ) + 3 ) by L461;
L514: ( ( card C119 ) + 3 ) in ( dom D143 ) by L513 , COMPOS_1:64;
L515: ( D147 . ( ( card C119 ) + 3 ) ) = ( D143 . ( ( card C119 ) + 3 ) ) by L514 , L506 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L513 , COMPOS_1:64;
L516: ( CurInstr (D147 , D146) ) = ( halt ( SCMPDS ) ) by L515 , L512 , PBOOLE:143;
L517: D145 halts_on D144 by L516 , EXTPRO_1:29;
L518: ( CurInstr (D145 , D144) ) = D148 by L509 , SCMPDS_6:11;
L519:
now
let C124 being (Element of ( NAT ));
assume L520: C124 < ( (( 0 ) qua Nat) + 1 );
L521: C124 = ( 0 ) by L520 , NAT_1:13;
thus L522: ( CurInstr (D145 , ( Comput (D145 , D144 , C124) )) ) <> ( halt ( SCMPDS ) ) by L521 , L518 , EXTPRO_1:2;
end;
L523: (for B114 being (Element of ( NAT )) holds (( CurInstr (D145 , ( Comput (D145 , D144 , B114) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B114)) by L519;
L524: ( LifeSpan (D145 , D144) ) = 1 by L523 , L516 , L517 , EXTPRO_1:def 15;
L525:
now
let C125 being set;
L526: ( dom D151 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L527: C125 in ( dom ( IExec (D142 , R19 , ( Initialize C118 )) ) );
per cases  by L527 , SCMPDS_4:6;
suppose L528: C125 is Int_position;

L529: C125 <> ( IC ( SCMPDS ) ) by L528 , SCMPDS_2:43;
L530: (not C125 in ( dom D151 )) by L529 , L526 , TARSKI:def 1;
L531: (not C125 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L528 , SCMPDS_4:18;
thus L532: ( ( IExec (D142 , R19 , ( Initialize C118 )) ) . C125 ) = ( D146 . C125 ) by L524 , L517 , EXTPRO_1:23
.= ( D144 . C125 ) by L510 , L528 , SCMPDS_2:57
.= ( C118 . C125 ) by L531 , FUNCT_4:11
.= ( ( C118 +* D151 ) . C125 ) by L530 , FUNCT_4:11;
end;
suppose L533: C125 = ( IC ( SCMPDS ) );

thus L534: ( ( IExec (D142 , R19 , ( Initialize C118 )) ) . C125 ) = ( ( card C119 ) + 3 ) by L512 , L524 , L533 , L517 , EXTPRO_1:23
.= ( ( C118 +* D151 ) . C125 ) by L533 , FUNCT_4:113;
end;
end;
L536: ( dom ( IExec (D142 , R19 , ( Initialize C118 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C118 +* D151 ) ) by PARTFUN1:def 2;
thus L537: thesis by L536 , L525 , FUNCT_1:2;
end;
theorem
L538: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B115 being (State of ( SCMPDS )) holds (for B116 being (Program of ( SCMPDS )) holds (for B117 being Int_position holds (for B118 being Integer holds (for B119 being (Element of ( NAT )) holds (( B115 . ( DataLoc (( B115 . B117 ) , B118) ) ) >= ( 0 ) implies ( IC ( IExec (( for-up (B117 , B118 , B119 , B116) ) , R19 , ( Initialize B115 )) ) ) = ( ( card B116 ) + 3 ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C126 being (State of ( SCMPDS ));
let C127 being (Program of ( SCMPDS ));
let C128 being Int_position;
let C129 being Integer;
let C130 being (Element of ( NAT ));
assume L539: ( C126 . ( DataLoc (( C126 . C128 ) , C129) ) ) >= ( 0 );
L540: ( IExec (( for-up (C128 , C129 , C130 , C127) ) , R19 , ( Initialize C126 )) ) = ( C126 +* ( Start-At (( ( card C127 ) + 3 ) , ( SCMPDS )) ) ) by L539 , L503;
thus L541: thesis by L540 , FUNCT_4:113;
end;
theorem
L542: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B120 being (State of ( SCMPDS )) holds (for B121 being (Program of ( SCMPDS )) holds (for B122 , B123 being Int_position holds (for B124 being Integer holds (for B125 being (Element of ( NAT )) holds (( B120 . ( DataLoc (( B120 . B122 ) , B124) ) ) >= ( 0 ) implies ( ( IExec (( for-up (B122 , B124 , B125 , B121) ) , R19 , ( Initialize B120 )) ) . B123 ) = ( B120 . B123 ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C131 being (State of ( SCMPDS ));
let C132 being (Program of ( SCMPDS ));
let C133 , C134 being Int_position;
let C135 being Integer;
let C136 being (Element of ( NAT ));
assume L543: ( C131 . ( DataLoc (( C131 . C133 ) , C135) ) ) >= ( 0 );
L544: ( IExec (( for-up (C133 , C135 , C136 , C132) ) , R19 , ( Initialize C131 )) ) = ( C131 +* ( Start-At (( ( card C132 ) + 3 ) , ( SCMPDS )) ) ) by L543 , L503;
L545: (not C134 in ( dom ( Start-At (( ( card C132 ) + 3 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L546: thesis by L545 , L544 , FUNCT_4:11;
end;
L547: (for B126 being (Program of ( SCMPDS )) holds (for B127 being Int_position holds (for B128 being Integer holds (for B129 being (Element of ( NAT )) holds ( Shift (B126 , 1) ) c= ( for-up (B127 , B128 , B129 , B126) )))))
proof
let C137 being (Program of ( SCMPDS ));
let C138 being Int_position;
let C139 being Integer;
let C140 being (Element of ( NAT ));
set D152 = ( (C138 , C139) >=0_goto ( ( card C137 ) + 3 ) );
set D153 = ( AddTo (C138 , C139 , C140) );
set D154 = ( goto ( - ( ( card C137 ) + 2 ) ) );
L548: ( for-up (C138 , C139 , C140 , C137) ) = ( ( ( Load D152 ) ';' C137 ) ';' ( D153 ';' D154 ) ) by SCMPDS_4:13;
L549: ( card ( Load D152 ) ) = 1 by COMPOS_1:54;
thus L550: thesis by L549 , L548 , L6;
end;
theorem
L551: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B130 being (State of ( SCMPDS )) holds (for B131 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B132 being Int_position holds (for B133 being Integer holds (for B134 being (Element of ( NAT )) holds (for B135 being set holds ((( B130 . ( DataLoc (( B130 . B132 ) , B133) ) ) < ( 0 ) & (not ( DataLoc (( B130 . B132 ) , B133) ) in B135) & B134 > ( 0 ) & B132 <> ( DataLoc (( B130 . B132 ) , B133) ) & (for B136 being (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B137 being Int_position holds (B137 in B135 implies ( B136 . B137 ) = ( B130 . B137 ))) & ( B136 . B132 ) = ( B130 . B132 )) implies (( ( IExec (B131 , R22 , ( Initialize B136 )) ) . B132 ) = ( B136 . B132 ) & ( ( IExec (B131 , R22 , ( Initialize B136 )) ) . ( DataLoc (( B130 . B132 ) , B133) ) ) = ( B136 . ( DataLoc (( B130 . B132 ) , B133) ) ) & B131 is_closed_on B136 , R22 & B131 is_halting_on B136 , R22 & (for B138 being Int_position holds (B138 in B135 implies ( ( IExec (B131 , R22 , ( Initialize B136 )) ) . B138 ) = ( B136 . B138 )))))))) implies (( for-up (B132 , B133 , B134 , B131) ) is_closed_on B130 , R19 & ( for-up (B132 , B133 , B134 , B131) ) is_halting_on B130 , R19)))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C141 being (State of ( SCMPDS ));
let C142 being  halt-free  shiftable (Program of ( SCMPDS ));
let C143 being Int_position;
let C144 being Integer;
let C145 being (Element of ( NAT ));
let C146 being set;
set D155 = ( DataLoc (( C141 . C143 ) , C144) );
set D156 = ( for-up (C143 , C144 , C145 , C142) );
set D157 = ( stop D156 );
set D158 = ( stop C142 );
set D159 = ( (C143 , C144) >=0_goto ( ( card C142 ) + 3 ) );
set D160 = ( AddTo (C143 , C144 , C145) );
set D161 = ( goto ( - ( ( card C142 ) + 2 ) ) );
assume L552: ( C141 . D155 ) < ( 0 );
defpred S4[ (Element of ( NAT )) ] means (for B139 being (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds ((( - ( B139 . D155 ) ) <= $1 & (for B140 being Int_position holds (B140 in C146 implies ( B139 . B140 ) = ( C141 . B140 ))) & ( B139 . C143 ) = ( C141 . C143 )) implies (D156 is_closed_on B139 , R22 & D156 is_halting_on B139 , R22))));
assume L553: (not D155 in C146);
assume L554: C145 > ( 0 );
assume L555: C143 <> D155;
assume L556: (for B141 being (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B142 being Int_position holds (B142 in C146 implies ( B141 . B142 ) = ( C141 . B142 ))) & ( B141 . C143 ) = ( C141 . C143 )) implies (( ( IExec (C142 , R22 , ( Initialize B141 )) ) . C143 ) = ( B141 . C143 ) & ( ( IExec (C142 , R22 , ( Initialize B141 )) ) . D155 ) = ( B141 . D155 ) & C142 is_closed_on B141 , R22 & C142 is_halting_on B141 , R22 & (for B143 being Int_position holds (B143 in C146 implies ( ( IExec (C142 , R22 , ( Initialize B141 )) ) . B143 ) = ( B141 . B143 )))))));
L557: (for B144 being (Element of ( NAT )) holds (S4[ B144 ] implies S4[ ( B144 + 1 ) ]))
proof
let C147 being (Element of ( NAT ));
assume L558: S4[ C147 ];
let C148 being (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
assume L559: ( - ( C148 . D155 ) ) <= ( C147 + 1 );
assume L560: (for B145 being Int_position holds (B145 in C146 implies ( C148 . B145 ) = ( C141 . B145 )));
assume L561: ( C148 . C143 ) = ( C141 . C143 );
per cases ;
suppose L562: ( C148 . D155 ) >= ( 0 );

thus L563: (D156 is_closed_on C148 , R22 & D156 is_halting_on C148 , R22) by L562 , L561 , L478;
end;
suppose L564: ( C148 . D155 ) < ( 0 );

set D162 = ( Initialize C148 );
set D163 = ( Initialize C148 );
set D164 = ( R22 +* ( stop C142 ) );
set D165 = ( R22 +* D157 );
set D166 = ( Comput (D165 , D163 , 1) );
set D167 = D165;
L565: ( stop C142 ) c= D164 by FUNCT_4:25;
L566: D156 = ( D159 ';' ( ( C142 ';' D160 ) ';' D161 ) ) by L4;
L567: ( Comput (D165 , D163 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D165 , ( Comput (D165 , D163 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D165 , D163) )
.= ( Exec (D159 , D163) ) by L566 , SCMPDS_6:11;
L568: (for R4 being Int_position holds ( D162 . R4 ) = ( D166 . R4 )) by L567 , SCMPDS_2:57;
L569: ( DataPart D162 ) = ( DataPart D166 ) by L568 , SCMPDS_4:8;
L570: ( ( IExec (C142 , R22 , ( Initialize C148 )) ) . D155 ) = ( C148 . D155 ) by L556 , L560 , L561;
L571: ( - ( - C145 ) ) > ( 0 ) by L554;
L572: ( - C145 ) < ( 0 ) by L571;
L573: ( - C145 ) <= ( - 1 ) by L572 , INT_1:8;
L574: ( ( - C145 ) - ( C148 . D155 ) ) <= ( ( - 1 ) - ( C148 . D155 ) ) by L573 , XREAL_1:9;
L575: ( ( - ( C148 . D155 ) ) - 1 ) <= C147 by L559 , XREAL_1:20;
L576: ( ( - C145 ) - ( C148 . D155 ) ) <= C147 by L575 , L574 , XXREAL_0:2;
L577: C142 is_closed_on C148 , R22 by L556 , L560 , L561;
L578: C142 is_closed_on D162 , D164 by L577 , SCMPDS_6:24;
L579: (not D155 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
set D168 = ( LifeSpan (D164 , D162) );
set D169 = ( Comput (D167 , D166 , D168) );
set D170 = D167;
set D171 = ( ( card C142 ) + 1 );
L580: ( IC D163 ) = ( 0 ) by MEMSTR_0:def 11;
set D172 = ( D168 + 1 );
set D173 = ( Comput (D165 , D163 , D172) );
set D174 = D165;
L581: ( ( card C142 ) + 1 ) < ( ( card C142 ) + 3 ) by XREAL_1:6;
L582: D171 in ( dom D156 ) by L581 , L467;
set D175 = ( ( D172 + 1 ) + 1 );
set D176 = ( Comput (D165 , D163 , D175) );
set D177 = D165;
set D178 = ( Comput (D165 , D163 , ( D172 + 1 )) );
set D179 = D165;
L583: ( ( IExec (C142 , R22 , ( Initialize C148 )) ) . C143 ) = ( C148 . C143 ) by L556 , L560 , L561;
set D180 = ( ( card C142 ) + 2 );
L584: ( 0 ) in ( dom D157 ) by COMPOS_1:36;
L585: ( ( card C142 ) + 2 ) < ( ( card C142 ) + 3 ) by XREAL_1:6;
L586: D180 in ( dom D156 ) by L585 , L467;
L587: D157 c= D165 by FUNCT_4:25;
L588: D156 c= D157 by AFINSQ_1:74;
L589: D156 c= D165 by L588 , L587 , XBOOLE_1:1;
L590: ( Shift (C142 , 1) ) c= D156 by L547;
L591: ( Shift (C142 , 1) ) c= D167 by L590 , L589 , XBOOLE_1:1;
L592: C142 is_halting_on C148 , R22 by L556 , L560 , L561;
L593: D164 halts_on D162 by L592 , SCMPDS_6:def 3;
L594: ( D164 +* ( stop C142 ) ) halts_on ( Initialize D162 ) by L593;
L595: C142 is_halting_on D162 , D164 by L594 , SCMPDS_6:def 3;
L596: (not C143 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L597: ( D163 . ( DataLoc (( D163 . C143 ) , C144) ) ) = ( D163 . D155 ) by L596 , L561 , FUNCT_4:11
.= ( C148 . D155 ) by L579 , FUNCT_4:11;
L598: ( IC D166 ) = ( succ ( IC D163 ) ) by L597 , L564 , L567 , SCMPDS_2:57
.= ( (( 0 ) qua Nat) + 1 ) by L580;
L599: ( IC D169 ) = D171 by L598 , L565 , L595 , L578 , L569 , L591 , L206;
L600: ( D174 /. ( IC D173 ) ) = ( D174 . ( IC D173 ) ) by PBOOLE:143;
L601: D173 = D169 by EXTPRO_1:4;
L602: ( CurInstr (D174 , D173) ) = ( D165 . D171 ) by L601 , L565 , L595 , L578 , L598 , L569 , L591 , L206 , L600
.= ( D156 . D171 ) by L582 , L589 , GRFUNC_1:2
.= D160 by L470;
L603: D178 = ( Following (D165 , D173) ) by EXTPRO_1:3
.= ( Exec (D160 , D173) ) by L602;
L604: ( IC D178 ) = ( succ ( IC D173 ) ) by L603 , SCMPDS_2:48
.= ( ( ( card C142 ) + 1 ) + 1 ) by L599 , L601 , NAT_1:38
.= ( ( card C142 ) + ( 1 + 1 ) );
L605: ( CurInstr (D179 , D178) ) = ( D165 . D180 ) by L604 , PBOOLE:143
.= ( D156 . D180 ) by L589 , L586 , GRFUNC_1:2
.= D161 by L470;
L606: D176 = ( Following (D165 , D178) ) by EXTPRO_1:3
.= ( Exec (D161 , D178) ) by L605;
L607: ( IC D176 ) = ( ICplusConst (D178 , ( (( 0 ) qua Nat) - ( ( card C142 ) + 2 ) )) ) by L606 , SCMPDS_2:54
.= ( 0 ) by L604 , L1;
L608: ( Initialize D176 ) = D176 by L607 , MEMSTR_0:46;
L609: ( DataPart ( Comput (D164 , D162 , D168) ) ) = ( DataPart D169 ) by L565 , L595 , L578 , L598 , L569 , L591 , L206;
L610: ( D169 . C143 ) = ( ( Comput (D164 , D162 , D168) ) . C143 ) by L609 , SCMPDS_4:8
.= ( C141 . C143 ) by L561 , L583 , L593 , EXTPRO_1:23;
L611: ( DataLoc (( D173 . C143 ) , C144) ) = D155 by L610 , EXTPRO_1:4;
L612: ( D178 . C143 ) = ( D173 . C143 ) by L611 , L555 , L603 , SCMPDS_2:48
.= ( C141 . C143 ) by L610 , EXTPRO_1:4;
L613: ( D176 . C143 ) = ( C141 . C143 ) by L612 , L606 , SCMPDS_2:54;
L614:
now
let C149 being Int_position;
assume L615: C149 in C146;
L616: ( D169 . C149 ) = ( ( Comput (D164 , D162 , D168) ) . C149 ) by L609 , SCMPDS_4:8
.= ( ( IExec (C142 , R22 , ( Initialize C148 )) ) . C149 ) by L593 , EXTPRO_1:23
.= ( C148 . C149 ) by L556 , L560 , L561 , L615
.= ( C141 . C149 ) by L560 , L615;
L617: ( D178 . C149 ) = ( C141 . C149 ) by L616 , L553 , L610 , L601 , L603 , L615 , SCMPDS_2:48;
thus L618: ( D176 . C149 ) = ( C141 . C149 ) by L617 , L606 , SCMPDS_2:54;
end;
L619: ( D169 . D155 ) = ( ( Comput (D164 , D162 , D168) ) . D155 ) by L609 , SCMPDS_4:8
.= ( C148 . D155 ) by L570 , L593 , EXTPRO_1:23;
L620: ( D176 . D155 ) = ( D178 . D155 ) by L606 , SCMPDS_2:54
.= ( ( C148 . D155 ) + C145 ) by L610 , L619 , L601 , L603 , SCMPDS_2:48;
L621: ( - ( D176 . D155 ) ) = ( ( - C145 ) - ( C148 . D155 ) ) by L620;
L622: D156 is_closed_on D176 , D177 by L621 , L558 , L613 , L614 , L576;
L623:
now
let C150 being (Element of ( NAT ));
per cases ;
suppose L624: C150 < D175;

L625: C150 <= ( D172 + 1 ) by L624 , INT_1:7;
L626: (C150 <= D172 or C150 = ( D172 + 1 )) by L625 , NAT_1:8;
thus L627:now
per cases  by L626 , NAT_1:8;
suppose L628: C150 <= D168;

thus L629:now
per cases ;
suppose L630: C150 = ( 0 );

thus L631: ( IC ( Comput (D165 , D163 , C150) ) ) in ( dom D157 ) by L630 , L584 , L580 , EXTPRO_1:2;
end;
suppose L632: C150 <> ( 0 );

consider C151 being Nat such that L633: C150 = ( C151 + 1 ) by L632 , NAT_1:6;
reconsider D181 = C151 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D182 = ( IC ( Comput (D164 , D162 , D181) ) ) as (Element of ( NAT ));
L634: D181 < C150 by L633 , XREAL_1:29;
L635: D181 < D168 by L634 , L628 , XXREAL_0:2;
L636: ( ( IC ( Comput (D164 , D162 , D181) ) ) + 1 ) = ( IC ( Comput (D167 , D166 , D181) ) ) by L635 , L565 , L595 , L578 , L598 , L569 , L591 , L145;
L637: ( IC ( Comput (D165 , D163 , C150) ) ) = ( D182 + 1 ) by L636 , L633 , EXTPRO_1:4;
L638: ( IC ( Comput (D164 , D162 , D181) ) ) in ( dom D158 ) by L577 , SCMPDS_6:def 2;
L639: D182 < ( card D158 ) by L638 , AFINSQ_1:66;
L640: D182 < ( ( card C142 ) + 1 ) by L639 , COMPOS_1:55;
L641: ( D182 + 1 ) <= ( ( card C142 ) + 1 ) by L640 , INT_1:7;
L642: ( ( card C142 ) + 1 ) < ( ( card C142 ) + 4 ) by XREAL_1:6;
L643: ( D182 + 1 ) < ( ( card C142 ) + 4 ) by L642 , L641 , XXREAL_0:2;
L644: ( D182 + 1 ) < ( card D157 ) by L643 , L465;
thus L645: ( IC ( Comput (D165 , D163 , C150) ) ) in ( dom D157 ) by L644 , L637 , AFINSQ_1:66;
end;
end;
end;
suppose L630: C150 = D172;

L631: D171 in ( dom D157 ) by L582 , COMPOS_1:62;
thus L632: ( IC ( Comput (D165 , D163 , C150) ) ) in ( dom D157 ) by L631 , L565 , L595 , L578 , L598 , L569 , L591 , L601 , L630 , L206;
end;
suppose L633: C150 = ( D172 + 1 );

thus L634: ( IC ( Comput (D165 , D163 , C150) ) ) in ( dom D157 ) by L633 , L604 , L586 , COMPOS_1:62;
end;
end;
end;
suppose L628: C150 >= D175;

consider C152 being Nat such that L629: C150 = ( D175 + C152 ) by L628 , NAT_1:10;
reconsider D183 = C152 as (Element of ( NAT )) by ORDINAL1:def 12;
L630: ( Comput (D165 , D163 , C150) ) = ( Comput (( D177 +* D157 ) , ( Initialize D176 ) , D183) ) by L608 , L629 , EXTPRO_1:4;
thus L631: ( IC ( Comput (D165 , D163 , C150) ) ) in ( dom D157 ) by L630 , L622 , SCMPDS_6:def 2;
end;
end;
thus L633: D156 is_closed_on C148 , R22 by L623 , SCMPDS_6:def 2;
L634: ( D177 +* D157 ) = D165;
L635: D156 is_halting_on D176 , D177 by L558 , L613 , L614 , L576 , L621;
L636: D165 halts_on D176 by L635 , L608 , L634 , SCMPDS_6:def 3;
L637: D165 halts_on D163 by L636 , EXTPRO_1:22;
thus L638: D156 is_halting_on C148 , R22 by L637 , SCMPDS_6:def 3;
end;
end;
reconsider D184 = ( - ( C141 . D155 ) ) as (Element of ( NAT )) by L552 , INT_1:3;
L640: S4[ ( 0 ) ]
proof
let C153 being (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
assume L641: ( - ( C153 . D155 ) ) <= ( 0 );
L642: ( - ( C153 . D155 ) ) <= ( - (( 0 ) qua Nat) ) by L641;
L643: ( C153 . D155 ) >= ( 0 ) by L642 , XREAL_1:24;
assume L644: (for B146 being Int_position holds (B146 in C146 implies ( C153 . B146 ) = ( C141 . B146 )));
assume L645: ( C153 . C143 ) = ( C141 . C143 );
thus L646: thesis by L645 , L643 , L478;
end;
L647: (for B147 being (Element of ( NAT )) holds S4[ B147 ]) from NAT_1:sch 1(L640 , L557);
L648: S4[ D184 ] by L647;
L649: (for B148 being Int_position holds (B148 in C146 implies ( C141 . B148 ) = ( C141 . B148 )));
thus L650: (( for-up (C143 , C144 , C145 , C142) ) is_closed_on C141 , R19 & ( for-up (C143 , C144 , C145 , C142) ) is_halting_on C141 , R19) by L649 , L648;
end;
theorem
L651: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B149 being ( 0 ) -started (State of ( SCMPDS )) holds (for B150 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B151 being Int_position holds (for B152 being Integer holds (for B153 being (Element of ( NAT )) holds (for B154 being set holds ((( B149 . ( DataLoc (( B149 . B151 ) , B152) ) ) < ( 0 ) & (not ( DataLoc (( B149 . B151 ) , B152) ) in B154) & B153 > ( 0 ) & B151 <> ( DataLoc (( B149 . B151 ) , B152) ) & (for B155 being (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B156 being Int_position holds (B156 in B154 implies ( B155 . B156 ) = ( B149 . B156 ))) & ( B155 . B151 ) = ( B149 . B151 )) implies (( ( IExec (B150 , R22 , ( Initialize B155 )) ) . B151 ) = ( B155 . B151 ) & ( ( IExec (B150 , R22 , ( Initialize B155 )) ) . ( DataLoc (( B149 . B151 ) , B152) ) ) = ( B155 . ( DataLoc (( B149 . B151 ) , B152) ) ) & B150 is_closed_on B155 , R22 & B150 is_halting_on B155 , R22 & (for B157 being Int_position holds (B157 in B154 implies ( ( IExec (B150 , R22 , ( Initialize B155 )) ) . B157 ) = ( B155 . B157 )))))))) implies ( IExec (( for-up (B151 , B152 , B153 , B150) ) , R19 , B149) ) = ( IExec (( for-up (B151 , B152 , B153 , B150) ) , R19 , ( Initialize ( IExec (( B150 ';' ( AddTo (B151 , B152 , B153) ) ) , R19 , B149) ) )) )))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C154 being ( 0 ) -started (State of ( SCMPDS ));
let C155 being  halt-free  shiftable (Program of ( SCMPDS ));
let C156 being Int_position;
let C157 being Integer;
let C158 being (Element of ( NAT ));
let C159 being set;
set D185 = ( DataLoc (( C154 . C156 ) , C157) );
set D186 = ( for-up (C156 , C157 , C158 , C155) );
set D187 = ( stop D186 );
set D188 = C154;
set D189 = ( R19 +* D187 );
set D190 = ( (C156 , C157) >=0_goto ( ( card C155 ) + 3 ) );
set D191 = ( AddTo (C156 , C157 , C158) );
set D192 = ( goto ( - ( ( card C155 ) + 2 ) ) );
assume L652: ( C154 . D185 ) < ( 0 );
set D193 = ( Comput (D189 , D188 , 1) );
set D194 = D189;
L653: ( IC D188 ) = ( 0 ) by MEMSTR_0:def 11;
set D195 = ( LifeSpan (D189 , D188) );
set D196 = ( ( card C155 ) + 2 );
set D197 = C154;
set D198 = ( R19 +* ( stop C155 ) );
set D199 = ( ( LifeSpan (D198 , D197) ) + 3 );
set D200 = ( C155 ';' ( AddTo (C156 , C157 , C158) ) );
set D201 = C154;
set D202 = ( R19 +* ( stop D200 ) );
set D203 = ( Initialize ( IExec (D200 , R19 , C154) ) );
set D204 = ( R19 +* D187 );
set D205 = ( LifeSpan (D204 , D203) );
set D206 = ( IExec (D200 , R19 , C154) );
set D207 = ( DataLoc (( D206 . C156 ) , C157) );
L654: ( stop C155 ) c= D198 by FUNCT_4:25;
L655: D186 = ( D190 ';' ( ( C155 ';' D191 ) ';' D192 ) ) by L4;
set D208 = ( LifeSpan (D198 , D197) );
set D209 = ( Comput (D194 , D193 , D208) );
set D210 = D194;
set D211 = ( ( card C155 ) + 1 );
set D212 = ( D208 + 1 );
set D213 = ( Comput (D189 , D188 , D212) );
set D214 = D189;
set D215 = ( Comput (D189 , D188 , ( D212 + 1 )) );
set D216 = D189;
L656: D187 c= D189 by FUNCT_4:25;
L657: D186 c= D187 by AFINSQ_1:74;
L658: D186 c= D189 by L657 , L656 , XBOOLE_1:1;
L659: ( Shift (C155 , 1) ) c= D186 by L547;
L660: ( Shift (C155 , 1) ) c= D194 by L659 , L658 , XBOOLE_1:1;
L661: ( ( card C155 ) + 2 ) < ( ( card C155 ) + 3 ) by XREAL_1:6;
L662: D196 in ( dom D186 ) by L661 , L467;
set D217 = ( ( D212 + 1 ) + 1 );
set D218 = ( Comput (D189 , D188 , D217) );
L663: ( ( card C155 ) + 1 ) < ( ( card C155 ) + 3 ) by XREAL_1:6;
L664: D211 in ( dom D186 ) by L663 , L467;
assume L665: (not D185 in C159);
assume L666: C158 > ( 0 );
assume L667: C156 <> D185;
L668: ( Initialize C154 ) = C154 by MEMSTR_0:44;
assume L669: (for B158 being (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B159 being Int_position holds (B159 in C159 implies ( B158 . B159 ) = ( C154 . B159 ))) & ( B158 . C156 ) = ( C154 . C156 )) implies (( ( IExec (C155 , R22 , ( Initialize B158 )) ) . C156 ) = ( B158 . C156 ) & ( ( IExec (C155 , R22 , ( Initialize B158 )) ) . D185 ) = ( B158 . D185 ) & C155 is_closed_on B158 , R22 & C155 is_halting_on B158 , R22 & (for B160 being Int_position holds (B160 in C159 implies ( ( IExec (C155 , R22 , ( Initialize B158 )) ) . B160 ) = ( B158 . B160 )))))));
L670: D186 is_halting_on C154 , R19 by L669 , L652 , L665 , L666 , L667 , L551;
L671: D189 halts_on D188 by L670 , L668 , SCMPDS_6:def 3;
L672: (for B161 being Int_position holds (B161 in C159 implies ( C154 . B161 ) = ( C154 . B161 )));
L673: ( ( IExec (C155 , R19 , C154) ) . D185 ) = ( C154 . D185 ) by L672 , L669 , L668;
L674: ( ( IExec (C155 , R19 , C154) ) . C156 ) = ( C154 . C156 ) by L669 , L672 , L668;
L675: D185 = ( DataLoc (( ( IExec (C155 , R19 , C154) ) . C156 ) , C157) ) by L669 , L672 , L668;
L676: ( ( IExec (C155 , R19 , C154) ) . C156 ) = ( C154 . C156 ) by L669 , L672 , L668;
L677: ( Comput (D189 , D188 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D189 , ( Comput (D189 , D188 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D189 , D188) )
.= ( Exec (D190 , D188) ) by L655 , L668 , SCMPDS_6:11;
L678: ( IC D193 ) = ( succ ( IC D188 ) ) by L652 , L677 , SCMPDS_2:57
.= ( (( 0 ) qua Nat) + 1 ) by L653;
L679: (for R4 being Int_position holds ( D197 . R4 ) = ( D193 . R4 )) by L677 , SCMPDS_2:57;
L680: ( DataPart D197 ) = ( DataPart D193 ) by L679 , SCMPDS_4:8;
L681: C155 is_halting_on C154 , R19 by L669 , L672;
L682: D198 halts_on D197 by L681 , L668 , SCMPDS_6:def 3;
L683: ( D198 +* ( stop C155 ) ) halts_on D197 by L682;
L684: C155 is_halting_on D197 , D198 by L683 , L668 , SCMPDS_6:def 3;
L685: C155 is_closed_on C154 , R19 by L669 , L672;
L686: ( D206 . D185 ) = ( ( Exec (D191 , ( IExec (C155 , R19 , C154) )) ) . D185 ) by L685 , L681 , L451
.= ( ( ( IExec (C155 , R19 , C154) ) . D185 ) + C158 ) by L674 , SCMPDS_2:48
.= ( ( C154 . D185 ) + C158 ) by L669 , L672 , L668;
L687: C155 is_closed_on D197 , D198 by L669 , L672;
L688: ( IC D209 ) = D211 by L687 , L654 , L684 , L678 , L680 , L660 , L206;
L689: ( D214 /. ( IC D213 ) ) = ( D214 . ( IC D213 ) ) by PBOOLE:143;
L690: D213 = D209 by EXTPRO_1:4;
L691: ( CurInstr (D214 , D213) ) = ( D189 . D211 ) by L690 , L654 , L684 , L687 , L678 , L680 , L660 , L206 , L689
.= ( D186 . D211 ) by L664 , L658 , GRFUNC_1:2
.= D191 by L470;
L692: ( DataPart ( Comput (D198 , D197 , D208) ) ) = ( DataPart D209 ) by L654 , L684 , L687 , L678 , L680 , L660 , L206;
L693: ( D209 . C156 ) = ( ( Comput (D198 , D197 , D208) ) . C156 ) by L692 , SCMPDS_4:8
.= ( C154 . C156 ) by L676 , L682 , EXTPRO_1:23;
L694: ( D206 . C156 ) = ( ( Exec (D191 , ( IExec (C155 , R19 , C154) )) ) . C156 ) by L685 , L681 , L451
.= ( C154 . C156 ) by L667 , L674 , SCMPDS_2:48;
L695:
now
per cases ;
suppose L696: ( D206 . D207 ) >= ( 0 );

thus L697: D186 is_halting_on D206 , R19 by L696 , L478;
end;
suppose L698: ( D206 . D207 ) < ( 0 );

L699:
now
let C160 being (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
assume that
L700: (for B162 being Int_position holds (B162 in C159 implies ( C160 . B162 ) = ( D206 . B162 )))
and
L701: ( C160 . C156 ) = ( D206 . C156 );
L702:
now
let C161 being Int_position;
assume L703: C161 in C159;
thus L704: ( C160 . C161 ) = ( D206 . C161 ) by L703 , L700
.= ( ( Exec (D191 , ( IExec (C155 , R19 , C154) )) ) . C161 ) by L685 , L681 , L451
.= ( ( IExec (C155 , R19 , C154) ) . C161 ) by L665 , L674 , L703 , SCMPDS_2:48
.= ( C154 . C161 ) by L669 , L672 , L703 , L668;
end;
thus L705: ( ( IExec (C155 , R22 , ( Initialize C160 )) ) . C156 ) = ( C160 . C156 ) by L702 , L669 , L694 , L701;
thus L706: ( ( IExec (C155 , R22 , ( Initialize C160 )) ) . D207 ) = ( C160 . D207 ) by L669 , L694 , L701 , L702;
thus L707: (C155 is_closed_on C160 , R22 & C155 is_halting_on C160 , R22 & (for B163 being Int_position holds (B163 in C159 implies ( ( IExec (C155 , R22 , ( Initialize C160 )) ) . B163 ) = ( C160 . B163 )))) by L669 , L694 , L701 , L702;
end;
thus L708: D186 is_halting_on D206 , R19 by L699 , L665 , L666 , L667 , L694 , L698 , L551;
end;
end;
L710: D204 halts_on D203 by L695 , SCMPDS_6:def 3;
L711: D215 = ( Following (D189 , D213) ) by EXTPRO_1:3
.= ( Exec (D191 , D213) ) by L691;
L712: ( IC D215 ) = ( succ ( IC D213 ) ) by L711 , SCMPDS_2:48
.= ( ( ( card C155 ) + 1 ) + 1 ) by L688 , L690 , NAT_1:38
.= ( ( card C155 ) + ( 1 + 1 ) );
L713: ( CurInstr (D216 , D215) ) = ( D189 . D196 ) by L712 , PBOOLE:143
.= ( D186 . D196 ) by L658 , L662 , GRFUNC_1:2
.= D192 by L470;
L714: D218 = ( Following (D189 , D215) ) by EXTPRO_1:3
.= ( Exec (D192 , D215) ) by L713;
L715: ( IC D218 ) = ( ICplusConst (D215 , ( (( 0 ) qua Nat) - ( ( card C155 ) + 2 ) )) ) by L714 , SCMPDS_2:54
.= ( 0 ) by L712 , L1;
L716: ( IC D203 ) = ( IC ( Comput (D189 , D188 , D199) ) ) by L715 , MEMSTR_0:def 11;
L717: ( D209 . D185 ) = ( ( Comput (D198 , D197 , D208) ) . D185 ) by L692 , SCMPDS_4:8
.= ( C154 . D185 ) by L673 , L682 , EXTPRO_1:23;
L718: ( D218 . D185 ) = ( D215 . D185 ) by L714 , SCMPDS_2:54
.= ( ( C154 . D185 ) + C158 ) by L693 , L717 , L690 , L711 , SCMPDS_2:48;
L719:
now
let C162 being Int_position;
L720: (not C162 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L721: ( D203 . C162 ) = ( ( IExec (D200 , R19 , C154) ) . C162 ) by L720 , FUNCT_4:11;
per cases ;
suppose L722: C162 = D185;

thus L723: ( D218 . C162 ) = ( D203 . C162 ) by L722 , L718 , L686 , L720 , FUNCT_4:11;
end;
suppose L724: C162 <> D185;

L725: ( D209 . C162 ) = ( ( Comput (D198 , D197 , D208) ) . C162 ) by L692 , SCMPDS_4:8
.= ( ( IExec (C155 , R19 , C154) ) . C162 ) by L682 , EXTPRO_1:23;
L726: ( D215 . C162 ) = ( D209 . C162 ) by L693 , L690 , L711 , L724 , SCMPDS_2:48;
L727: ( D206 . C162 ) = ( ( Exec (D191 , ( IExec (C155 , R19 , C154) )) ) . C162 ) by L685 , L681 , L451
.= ( ( IExec (C155 , R19 , C154) ) . C162 ) by L675 , L724 , SCMPDS_2:48;
thus L728: ( D218 . C162 ) = ( D203 . C162 ) by L727 , L714 , L721 , L725 , L726 , SCMPDS_2:54;
end;
end;
L730: ( DataPart D218 ) = ( DataPart D203 ) by L719 , SCMPDS_4:8;
L731: ( Comput (D189 , D188 , D199) ) = ( Initialize ( IExec (D200 , R19 , C154) ) ) by L730 , L716 , MEMSTR_0:78;
L732: ( CurInstr (D189 , ( Comput (D189 , D188 , D199) )) ) = D190 by L731 , L655 , SCMPDS_6:11;
L733: D195 > D199 by L732 , L671 , EXTPRO_1:36;
consider C163 being Nat such that L734: D195 = ( D199 + C163 ) by L733 , NAT_1:10;
reconsider D219 = C163 as (Element of ( NAT )) by ORDINAL1:def 12;
L735: ( Comput (D189 , D188 , ( D199 + D205 )) ) = ( Comput (D204 , D203 , D205) ) by L731 , EXTPRO_1:4;
L736: ( CurInstr (D189 , ( Comput (D189 , D188 , ( D199 + D205 )) )) ) = ( halt ( SCMPDS ) ) by L735 , L710 , EXTPRO_1:def 15;
L737: ( D199 + D205 ) >= D195 by L736 , L671 , EXTPRO_1:def 15;
L738: D205 >= D219 by L737 , L734 , XREAL_1:6;
L739: ( Comput (D189 , D188 , D195) ) = ( Comput (D204 , D203 , D219) ) by L731 , L734 , EXTPRO_1:4;
L740: ( CurInstr (D204 , ( Comput (D204 , D203 , D219) )) ) = ( halt ( SCMPDS ) ) by L739 , L671 , EXTPRO_1:def 15;
L741: D219 >= D205 by L740 , L710 , EXTPRO_1:def 15;
L742: D219 = D205 by L741 , L738 , XXREAL_0:1;
L743: ( Result (D189 , D188) ) = ( Comput (D204 , D203 , D205) ) by L742 , L671 , L739 , EXTPRO_1:23;
thus L744: thesis by L743 , L710 , EXTPRO_1:23;
end;
registration
let C164 being  shiftable (Program of ( SCMPDS ));
let C165 being Int_position;
let C166 being Integer;
let C167 being (Element of ( NAT ));
cluster ( for-up (C165 , C166 , C167 , C164) ) ->  shiftable;
correctness
proof
set D220 = ( for-up (C165 , C166 , C167 , C164) );
set D221 = ( (C165 , C166) >=0_goto ( ( card C164 ) + 3 ) );
set D222 = ( AddTo (C165 , C166 , C167) );
set D223 = ( ( ( Load D221 ) ';' C164 ) ';' D222 );
L745: ( card D223 ) = ( ( card ( D221 ';' C164 ) ) + 1 ) by SCMP_GCD:4
.= ( ( ( card C164 ) + 1 ) + 1 ) by SCMPDS_6:6
.= ( ( card C164 ) + ( 1 + 1 ) );
L746: ( ( card D223 ) + ( - ( ( card C164 ) + 2 ) ) ) = ( 0 ) by L745;
thus L747: thesis by L746 , SCMPDS_4:23;
end;
end;
registration
let C168 being  halt-free (Program of ( SCMPDS ));
let C169 being Int_position;
let C170 being Integer;
let C171 being (Element of ( NAT ));
cluster ( for-up (C169 , C170 , C171 , C168) ) ->  halt-free;
correctness
proof
reconsider D224 = ( goto ( - ( ( card C168 ) + 2 ) ) ) as  No-StopCode (Instruction of ( SCMPDS )) by SCMPDS_5:21;
L749: ( for-up (C169 , C170 , C171 , C168) ) = ( ( ( ( (C169 , C170) >=0_goto ( ( card C168 ) + 3 ) ) ';' C168 ) ';' ( AddTo (C169 , C170 , C171) ) ) ';' D224 );
thus L750: thesis by L749;
end;
end;
begin
definition
let C172 being Int_position;
let C173 being Integer;
let C174 being (Element of ( NAT ));
let C175 being (Program of ( SCMPDS ));
func for-down (C172 , C173 , C174 , C175) -> (Program of ( SCMPDS )) equals 
( ( ( ( (C172 , C173) <=0_goto ( ( card C175 ) + 3 ) ) ';' C175 ) ';' ( AddTo (C172 , C173 , ( - C174 )) ) ) ';' ( goto ( - ( ( card C175 ) + 2 ) ) ) );
coherence;
end;
begin
theorem
L753: (for B164 being Int_position holds (for B165 being Integer holds (for B166 being (Element of ( NAT )) holds (for B167 being (Program of ( SCMPDS )) holds ( card ( for-down (B164 , B165 , B166 , B167) ) ) = ( ( card B167 ) + 3 )))))
proof
let C176 being Int_position;
let C177 being Integer;
let C178 being (Element of ( NAT ));
let C179 being (Program of ( SCMPDS ));
set D225 = ( (C176 , C177) <=0_goto ( ( card C179 ) + 3 ) );
set D226 = ( AddTo (C176 , C177 , ( - C178 )) );
set D227 = ( D225 ';' C179 );
set D228 = ( D227 ';' D226 );
L754: ( card D227 ) = ( ( card C179 ) + 1 ) by SCMPDS_6:6;
L755: ( card D228 ) = ( ( ( card C179 ) + 1 ) + 1 ) by L754 , SCMP_GCD:4
.= ( ( card C179 ) + ( 1 + 1 ) );
thus L756: ( card ( for-down (C176 , C177 , C178 , C179) ) ) = ( ( ( card C179 ) + 2 ) + 1 ) by L755 , SCMP_GCD:4
.= ( ( card C179 ) + 3 );
end;
L757: (for B168 being Int_position holds (for B169 being Integer holds (for B170 being (Element of ( NAT )) holds (for B171 being (Program of ( SCMPDS )) holds ( card ( stop ( for-down (B168 , B169 , B170 , B171) ) ) ) = ( ( card B171 ) + 4 )))))
proof
let C180 being Int_position;
let C181 being Integer;
let C182 being (Element of ( NAT ));
let C183 being (Program of ( SCMPDS ));
thus L758: ( card ( stop ( for-down (C180 , C181 , C182 , C183) ) ) ) = ( ( card ( for-down (C180 , C181 , C182 , C183) ) ) + 1 ) by COMPOS_1:55
.= ( ( ( card C183 ) + 3 ) + 1 ) by L753
.= ( ( card C183 ) + 4 );
end;
theorem
L759: (for B172 being Int_position holds (for B173 being Integer holds (for B174 , B175 being (Element of ( NAT )) holds (for B176 being (Program of ( SCMPDS )) holds (B175 < ( ( card B176 ) + 3 ) iff B175 in ( dom ( for-down (B172 , B173 , B174 , B176) ) ))))))
proof
let C184 being Int_position;
let C185 being Integer;
let C186 , C187 being (Element of ( NAT ));
let C188 being (Program of ( SCMPDS ));
L760: ( card ( for-down (C184 , C185 , C186 , C188) ) ) = ( ( card C188 ) + 3 ) by L753;
thus L761: thesis by L760 , AFINSQ_1:66;
end;
theorem
L762: (for B177 being Int_position holds (for B178 being Integer holds (for B179 being (Element of ( NAT )) holds (for B180 being (Program of ( SCMPDS )) holds (( ( for-down (B177 , B178 , B179 , B180) ) . ( 0 ) ) = ( (B177 , B178) <=0_goto ( ( card B180 ) + 3 ) ) & ( ( for-down (B177 , B178 , B179 , B180) ) . ( ( card B180 ) + 1 ) ) = ( AddTo (B177 , B178 , ( - B179 )) ) & ( ( for-down (B177 , B178 , B179 , B180) ) . ( ( card B180 ) + 2 ) ) = ( goto ( - ( ( card B180 ) + 2 ) ) ))))))
proof
let C189 being Int_position;
let C190 being Integer;
let C191 being (Element of ( NAT ));
let C192 being (Program of ( SCMPDS ));
set D229 = ( (C189 , C190) <=0_goto ( ( card C192 ) + 3 ) );
set D230 = ( AddTo (C189 , C190 , ( - C191 )) );
set D231 = ( goto ( - ( ( card C192 ) + 2 ) ) );
set D232 = ( D229 ';' C192 );
set D233 = ( D232 ';' D230 );
set D234 = ( D230 ';' D231 );
set D235 = ( C192 ';' D234 );
set D236 = ( for-down (C189 , C190 , C191 , C192) );
L763: D236 = ( D232 ';' D234 ) by SCMPDS_4:13;
L764: D236 = ( D229 ';' D235 ) by L763 , SCMPDS_4:14;
thus L765: ( D236 . ( 0 ) ) = D229 by L764 , SCMPDS_6:7;
L766: ( card D232 ) = ( ( card C192 ) + 1 ) by SCMPDS_6:6;
thus L767: ( D236 . ( ( card C192 ) + 1 ) ) = D230 by L766 , SCMP_GCD:7;
L768: ( card D233 ) = ( ( ( card C192 ) + 1 ) + 1 ) by L766 , SCMP_GCD:4
.= ( ( card C192 ) + ( 1 + 1 ) );
thus L769: thesis by L768 , SCMP_GCD:6;
end;
theorem
L770: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B181 being (State of ( SCMPDS )) holds (for B182 being (Program of ( SCMPDS )) holds (for B183 being Int_position holds (for B184 being Integer holds (for B185 being (Element of ( NAT )) holds (( B181 . ( DataLoc (( B181 . B183 ) , B184) ) ) <= ( 0 ) implies (( for-down (B183 , B184 , B185 , B182) ) is_closed_on B181 , R19 & ( for-down (B183 , B184 , B185 , B182) ) is_halting_on B181 , R19))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C193 being (State of ( SCMPDS ));
let C194 being (Program of ( SCMPDS ));
let C195 being Int_position;
let C196 being Integer;
let C197 being (Element of ( NAT ));
set D237 = ( DataLoc (( C193 . C195 ) , C196) );
assume L771: ( C193 . D237 ) <= ( 0 );
set D238 = ( (C195 , C196) <=0_goto ( ( card C194 ) + 3 ) );
set D239 = ( AddTo (C195 , C196 , ( - C197 )) );
set D240 = ( goto ( - ( ( card C194 ) + 2 ) ) );
set D241 = ( for-down (C195 , C196 , C197 , C194) );
set D242 = ( stop D241 );
set D243 = ( Initialize C193 );
set D244 = ( R19 +* D242 );
set D245 = ( Comput (D244 , D243 , 1) );
set D246 = D244;
L772: ( IC D243 ) = ( 0 ) by MEMSTR_0:def 11;
L773: (not D237 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L774: (not C195 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L775: ( D243 . ( DataLoc (( D243 . C195 ) , C196) ) ) = ( D243 . D237 ) by L774 , FUNCT_4:11
.= ( C193 . D237 ) by L773 , FUNCT_4:11;
L776: D241 = ( D238 ';' ( ( C194 ';' D239 ) ';' D240 ) ) by L4;
L777: ( Comput (D244 , D243 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D244 , ( Comput (D244 , D243 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D244 , D243) )
.= ( Exec (D238 , D243) ) by L776 , SCMPDS_6:11;
L778: ( IC D245 ) = ( ICplusConst (D243 , ( ( card C194 ) + 3 )) ) by L777 , L771 , L775 , SCMPDS_2:56
.= ( (( 0 ) qua Nat) + ( ( card C194 ) + 3 ) ) by L772 , SCMPDS_6:12;
L779: ( card D241 ) = ( ( card C194 ) + 3 ) by L753;
L780: ( ( card C194 ) + 3 ) in ( dom D242 ) by L779 , COMPOS_1:64;
L781: D242 c= D244 by FUNCT_4:25;
L782: ( D246 . ( ( card C194 ) + 3 ) ) = ( D242 . ( ( card C194 ) + 3 ) ) by L781 , L780 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L779 , COMPOS_1:64;
L783: ( CurInstr (D246 , D245) ) = ( halt ( SCMPDS ) ) by L782 , L778 , PBOOLE:143;
L784:
now
let C198 being (Element of ( NAT ));
per cases ;
suppose L785: ( 0 ) < C198;

L786: ( 1 + (( 0 ) qua Nat) ) <= C198 by L785 , INT_1:7;
thus L787: ( IC ( Comput (D244 , D243 , C198) ) ) in ( dom D242 ) by L786 , L780 , L778 , L783 , EXTPRO_1:5;
end;
suppose L788: C198 = ( 0 );

L789: ( Comput (D244 , D243 , C198) ) = D243 by L788 , EXTPRO_1:2;
thus L790: ( IC ( Comput (D244 , D243 , C198) ) ) in ( dom D242 ) by L789 , L772 , COMPOS_1:36;
end;
end;
thus L792: D241 is_closed_on C193 , R19 by L784 , SCMPDS_6:def 2;
L793: D244 halts_on D243 by L783 , EXTPRO_1:29;
thus L794: thesis by L793 , SCMPDS_6:def 3;
end;
theorem
L795: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B186 being (State of ( SCMPDS )) holds (for B187 being (Program of ( SCMPDS )) holds (for B188 , B189 being Int_position holds (for B190 being Integer holds (for B191 being (Element of ( NAT )) holds (( B186 . ( DataLoc (( B186 . B188 ) , B190) ) ) <= ( 0 ) implies ( IExec (( for-down (B188 , B190 , B191 , B187) ) , R19 , ( Initialize B186 )) ) = ( B186 +* ( Start-At (( ( card B187 ) + 3 ) , ( SCMPDS )) ) ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C199 being (State of ( SCMPDS ));
let C200 being (Program of ( SCMPDS ));
let C201 , C202 being Int_position;
let C203 being Integer;
let C204 being (Element of ( NAT ));
set D247 = ( DataLoc (( C199 . C201 ) , C203) );
set D248 = ( for-down (C201 , C203 , C204 , C200) );
set D249 = ( stop D248 );
set D250 = ( Initialize C199 );
set D251 = ( R19 +* D249 );
set D252 = ( Comput (D251 , D250 , 1) );
set D253 = D251;
set D254 = ( (C201 , C203) <=0_goto ( ( card C200 ) + 3 ) );
set D255 = ( AddTo (C201 , C203 , ( - C204 )) );
set D256 = ( goto ( - ( ( card C200 ) + 2 ) ) );
set D257 = ( Start-At (( ( card C200 ) + 3 ) , ( SCMPDS )) );
L796: ( IC D250 ) = ( 0 ) by MEMSTR_0:def 11;
L797: (not D247 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L798: D249 c= D253 by FUNCT_4:25;
L799: (not C201 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L800: ( D250 . ( DataLoc (( D250 . C201 ) , C203) ) ) = ( D250 . D247 ) by L799 , FUNCT_4:11
.= ( C199 . D247 ) by L797 , FUNCT_4:11;
L801: D248 = ( D254 ';' ( ( C200 ';' D255 ) ';' D256 ) ) by L4;
L802: ( Comput (D251 , D250 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D251 , ( Comput (D251 , D250 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D251 , D250) )
.= ( Exec (D254 , D250) ) by L801 , SCMPDS_6:11;
assume L803: ( C199 . D247 ) <= ( 0 );
L804: ( IC D252 ) = ( ICplusConst (D250 , ( ( card C200 ) + 3 )) ) by L803 , L802 , L800 , SCMPDS_2:56
.= ( (( 0 ) qua Nat) + ( ( card C200 ) + 3 ) ) by L796 , SCMPDS_6:12;
L805: ( card D248 ) = ( ( card C200 ) + 3 ) by L753;
L806: ( ( card C200 ) + 3 ) in ( dom D249 ) by L805 , COMPOS_1:64;
L807: ( D253 . ( ( card C200 ) + 3 ) ) = ( D249 . ( ( card C200 ) + 3 ) ) by L806 , L798 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L805 , COMPOS_1:64;
L808: ( CurInstr (D253 , D252) ) = ( halt ( SCMPDS ) ) by L807 , L804 , PBOOLE:143;
L809: D251 halts_on D250 by L808 , EXTPRO_1:29;
L810: ( CurInstr (D251 , D250) ) = D254 by L801 , SCMPDS_6:11;
L811:
now
let C205 being (Element of ( NAT ));
assume L812: C205 < ( (( 0 ) qua Nat) + 1 );
L813: C205 = ( 0 ) by L812 , NAT_1:13;
thus L814: ( CurInstr (D251 , ( Comput (D251 , D250 , C205) )) ) <> ( halt ( SCMPDS ) ) by L813 , L810 , EXTPRO_1:2;
end;
L815: (for B192 being (Element of ( NAT )) holds (( CurInstr (D251 , ( Comput (D251 , D250 , B192) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B192)) by L811;
L816: ( LifeSpan (D251 , D250) ) = 1 by L815 , L808 , L809 , EXTPRO_1:def 15;
L817:
now
let C206 being set;
L818: ( dom D257 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L819: C206 in ( dom ( IExec (D248 , R19 , ( Initialize C199 )) ) );
per cases  by L819 , SCMPDS_4:6;
suppose L820: C206 is Int_position;

L821: C206 <> ( IC ( SCMPDS ) ) by L820 , SCMPDS_2:43;
L822: (not C206 in ( dom D257 )) by L821 , L818 , TARSKI:def 1;
L823: (not C206 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L820 , SCMPDS_4:18;
thus L824: ( ( IExec (D248 , R19 , ( Initialize C199 )) ) . C206 ) = ( D252 . C206 ) by L816 , L809 , EXTPRO_1:23
.= ( D250 . C206 ) by L802 , L820 , SCMPDS_2:56
.= ( C199 . C206 ) by L823 , FUNCT_4:11
.= ( ( C199 +* D257 ) . C206 ) by L822 , FUNCT_4:11;
end;
suppose L825: C206 = ( IC ( SCMPDS ) );

thus L826: ( ( IExec (D248 , R19 , ( Initialize C199 )) ) . C206 ) = ( ( card C200 ) + 3 ) by L804 , L816 , L825 , L809 , EXTPRO_1:23
.= ( ( C199 +* D257 ) . C206 ) by L825 , FUNCT_4:113;
end;
end;
L828: ( dom ( IExec (D248 , R19 , ( Initialize C199 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C199 +* D257 ) ) by PARTFUN1:def 2;
thus L829: thesis by L828 , L817 , FUNCT_1:2;
end;
theorem
L830: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B193 being (State of ( SCMPDS )) holds (for B194 being (Program of ( SCMPDS )) holds (for B195 being Int_position holds (for B196 being Integer holds (for B197 being (Element of ( NAT )) holds (( B193 . ( DataLoc (( B193 . B195 ) , B196) ) ) <= ( 0 ) implies ( IC ( IExec (( for-down (B195 , B196 , B197 , B194) ) , R19 , ( Initialize B193 )) ) ) = ( ( card B194 ) + 3 ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C207 being (State of ( SCMPDS ));
let C208 being (Program of ( SCMPDS ));
let C209 being Int_position;
let C210 being Integer;
let C211 being (Element of ( NAT ));
assume L831: ( C207 . ( DataLoc (( C207 . C209 ) , C210) ) ) <= ( 0 );
L832: ( IExec (( for-down (C209 , C210 , C211 , C208) ) , R19 , ( Initialize C207 )) ) = ( C207 +* ( Start-At (( ( card C208 ) + 3 ) , ( SCMPDS )) ) ) by L831 , L795;
thus L833: thesis by L832 , FUNCT_4:113;
end;
theorem
L834: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B198 being (State of ( SCMPDS )) holds (for B199 being (Program of ( SCMPDS )) holds (for B200 , B201 being Int_position holds (for B202 being Integer holds (for B203 being (Element of ( NAT )) holds (( B198 . ( DataLoc (( B198 . B200 ) , B202) ) ) <= ( 0 ) implies ( ( IExec (( for-down (B200 , B202 , B203 , B199) ) , R19 , ( Initialize B198 )) ) . B201 ) = ( B198 . B201 ))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C212 being (State of ( SCMPDS ));
let C213 being (Program of ( SCMPDS ));
let C214 , C215 being Int_position;
let C216 being Integer;
let C217 being (Element of ( NAT ));
assume L835: ( C212 . ( DataLoc (( C212 . C214 ) , C216) ) ) <= ( 0 );
L836: ( IExec (( for-down (C214 , C216 , C217 , C213) ) , R19 , ( Initialize C212 )) ) = ( C212 +* ( Start-At (( ( card C213 ) + 3 ) , ( SCMPDS )) ) ) by L835 , L795;
L837: (not C215 in ( dom ( Start-At (( ( card C213 ) + 3 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L838: thesis by L837 , L836 , FUNCT_4:11;
end;
L839: (for B204 being (Program of ( SCMPDS )) holds (for B205 being Int_position holds (for B206 being Integer holds (for B207 being (Element of ( NAT )) holds ( Shift (B204 , 1) ) c= ( for-down (B205 , B206 , B207 , B204) )))))
proof
let C218 being (Program of ( SCMPDS ));
let C219 being Int_position;
let C220 being Integer;
let C221 being (Element of ( NAT ));
set D258 = ( (C219 , C220) <=0_goto ( ( card C218 ) + 3 ) );
set D259 = ( AddTo (C219 , C220 , ( - C221 )) );
set D260 = ( goto ( - ( ( card C218 ) + 2 ) ) );
L840: ( for-down (C219 , C220 , C221 , C218) ) = ( ( ( Load D258 ) ';' C218 ) ';' ( D259 ';' D260 ) ) by SCMPDS_4:13;
L841: ( card ( Load D258 ) ) = 1 by COMPOS_1:54;
thus L842: thesis by L841 , L840 , L6;
end;
theorem
L843: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B208 being (State of ( SCMPDS )) holds (for B209 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B210 being Int_position holds (for B211 being Integer holds (for B212 being (Element of ( NAT )) holds (for B213 being set holds ((( B208 . ( DataLoc (( B208 . B210 ) , B211) ) ) > ( 0 ) & (not ( DataLoc (( B208 . B210 ) , B211) ) in B213) & B212 > ( 0 ) & B210 <> ( DataLoc (( B208 . B210 ) , B211) ) & (for B214 being ( 0 ) -started (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B215 being Int_position holds (B215 in B213 implies ( B214 . B215 ) = ( B208 . B215 ))) & ( B214 . B210 ) = ( B208 . B210 )) implies (( ( IExec (B209 , R22 , B214) ) . B210 ) = ( B214 . B210 ) & ( ( IExec (B209 , R22 , B214) ) . ( DataLoc (( B208 . B210 ) , B211) ) ) = ( B214 . ( DataLoc (( B208 . B210 ) , B211) ) ) & B209 is_closed_on B214 , R22 & B209 is_halting_on B214 , R22 & (for B216 being Int_position holds (B216 in B213 implies ( ( IExec (B209 , R22 , B214) ) . B216 ) = ( B214 . B216 )))))))) implies (( for-down (B210 , B211 , B212 , B209) ) is_closed_on B208 , R19 & ( for-down (B210 , B211 , B212 , B209) ) is_halting_on B208 , R19)))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C222 being (State of ( SCMPDS ));
let C223 being  halt-free  shiftable (Program of ( SCMPDS ));
let C224 being Int_position;
let C225 being Integer;
let C226 being (Element of ( NAT ));
let C227 being set;
set D261 = ( DataLoc (( C222 . C224 ) , C225) );
set D262 = ( for-down (C224 , C225 , C226 , C223) );
set D263 = ( stop D262 );
set D264 = ( stop C223 );
set D265 = ( (C224 , C225) <=0_goto ( ( card C223 ) + 3 ) );
set D266 = ( AddTo (C224 , C225 , ( - C226 )) );
set D267 = ( goto ( - ( ( card C223 ) + 2 ) ) );
assume L844: ( C222 . D261 ) > ( 0 );
defpred S5[ (Element of ( NAT )) ] means (for B217 being (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds ((( B217 . D261 ) <= $1 & (for B218 being Int_position holds (B218 in C227 implies ( B217 . B218 ) = ( C222 . B218 ))) & ( B217 . C224 ) = ( C222 . C224 )) implies (D262 is_closed_on B217 , R22 & D262 is_halting_on B217 , R22))));
assume L845: (not D261 in C227);
assume L846: C226 > ( 0 );
assume L847: C224 <> D261;
assume L848: (for B219 being ( 0 ) -started (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B220 being Int_position holds (B220 in C227 implies ( B219 . B220 ) = ( C222 . B220 ))) & ( B219 . C224 ) = ( C222 . C224 )) implies (( ( IExec (C223 , R22 , B219) ) . C224 ) = ( B219 . C224 ) & ( ( IExec (C223 , R22 , B219) ) . D261 ) = ( B219 . D261 ) & C223 is_closed_on B219 , R22 & C223 is_halting_on B219 , R22 & (for B221 being Int_position holds (B221 in C227 implies ( ( IExec (C223 , R22 , B219) ) . B221 ) = ( B219 . B221 )))))));
L849: (for B222 being (Element of ( NAT )) holds (S5[ B222 ] implies S5[ ( B222 + 1 ) ]))
proof
let C228 being (Element of ( NAT ));
assume L850: S5[ C228 ];
let C229 being (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
assume L851: ( C229 . D261 ) <= ( C228 + 1 );
assume L852: (for B223 being Int_position holds (B223 in C227 implies ( C229 . B223 ) = ( C222 . B223 )));
L853: (for B224 being Int_position holds (B224 in C227 implies ( ( Initialize C229 ) . B224 ) = ( C222 . B224 )))
proof
let C230 being Int_position;
assume L854: C230 in C227;
L855: ( C229 . C230 ) = ( C222 . C230 ) by L854 , L852;
thus L856: ( ( Initialize C229 ) . C230 ) = ( C222 . C230 ) by L855 , SCMPDS_5:15;
end;
assume L857: ( C229 . C224 ) = ( C222 . C224 );
L858: ( ( Initialize C229 ) . C224 ) = ( C222 . C224 ) by L857 , SCMPDS_5:15;
per cases ;
suppose L859: ( C229 . D261 ) <= ( 0 );

thus L860: (D262 is_closed_on C229 , R22 & D262 is_halting_on C229 , R22) by L859 , L857 , L770;
end;
suppose L861: ( C229 . D261 ) > ( 0 );

set D268 = ( Initialize C229 );
set D269 = ( Initialize C229 );
set D270 = ( R22 +* ( stop C223 ) );
set D271 = ( R22 +* D263 );
set D272 = ( Comput (D271 , D269 , 1) );
set D273 = D271;
L862: ( stop C223 ) c= D270 by FUNCT_4:25;
L863: D262 = ( D265 ';' ( ( C223 ';' D266 ) ';' D267 ) ) by L4;
L864: ( Comput (D271 , D269 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D271 , ( Comput (D271 , D269 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D271 , D269) )
.= ( Exec (D265 , D269) ) by L863 , SCMPDS_6:11;
L865: (for R4 being Int_position holds ( D268 . R4 ) = ( D272 . R4 )) by L864 , SCMPDS_2:56;
L866: ( DataPart D268 ) = ( DataPart D272 ) by L865 , SCMPDS_4:8;
L867: ( ( IExec (C223 , R22 , ( Initialize C229 )) ) . D261 ) = ( ( Initialize C229 ) . D261 ) by L848 , L853 , L858
.= ( C229 . D261 ) by SCMPDS_5:15;
L868: ( - ( - C226 ) ) > ( 0 ) by L846;
L869: ( - C226 ) < ( 0 ) by L868;
L870: ( - C226 ) <= ( - 1 ) by L869 , INT_1:8;
L871: ( ( - C226 ) + ( C229 . D261 ) ) <= ( ( - 1 ) + ( C229 . D261 ) ) by L870 , XREAL_1:6;
L872: ( ( C229 . D261 ) - 1 ) <= C228 by L851 , XREAL_1:20;
L873: ( ( - C226 ) + ( C229 . D261 ) ) <= C228 by L872 , L871 , XXREAL_0:2;
L874: C223 is_closed_on ( Initialize C229 ) , R22 by L848 , L853 , L858;
L875: C223 is_closed_on C229 , R22 by L874 , SCMPDS_6:125;
L876: C223 is_closed_on D268 , D270 by L875 , SCMPDS_6:24;
L877: (not D261 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
set D274 = ( LifeSpan (D270 , D268) );
set D275 = ( Comput (D273 , D272 , D274) );
set D276 = D273;
set D277 = ( ( card C223 ) + 1 );
L878: ( IC D269 ) = ( 0 ) by MEMSTR_0:def 11;
set D278 = ( D274 + 1 );
set D279 = ( Comput (D271 , D269 , D278) );
set D280 = D271;
L879: ( ( card C223 ) + 1 ) < ( ( card C223 ) + 3 ) by XREAL_1:6;
L880: D277 in ( dom D262 ) by L879 , L759;
set D281 = ( ( D278 + 1 ) + 1 );
set D282 = ( Comput (D271 , D269 , D281) );
set D283 = D271;
set D284 = ( Comput (D271 , D269 , ( D278 + 1 )) );
set D285 = D271;
L881: ( ( IExec (C223 , R22 , ( Initialize C229 )) ) . C224 ) = ( ( Initialize C229 ) . C224 ) by L848 , L853 , L858
.= ( C229 . C224 ) by SCMPDS_5:15;
set D286 = ( ( card C223 ) + 2 );
L882: ( 0 ) in ( dom D263 ) by COMPOS_1:36;
L883: ( ( card C223 ) + 2 ) < ( ( card C223 ) + 3 ) by XREAL_1:6;
L884: D286 in ( dom D262 ) by L883 , L759;
L885: D263 c= D271 by FUNCT_4:25;
L886: D262 c= D263 by AFINSQ_1:74;
L887: D262 c= D271 by L886 , L885 , XBOOLE_1:1;
L888: ( Shift (C223 , 1) ) c= D262 by L839;
L889: ( Shift (C223 , 1) ) c= D273 by L888 , L887 , XBOOLE_1:1;
L890: C223 is_halting_on ( Initialize C229 ) , R22 by L848 , L853 , L858;
L891: C223 is_halting_on C229 , R22 by L890 , SCMPDS_6:126;
L892: D270 halts_on D268 by L891 , SCMPDS_6:def 3;
L893: ( D270 +* ( stop C223 ) ) halts_on ( Initialize D268 ) by L892;
L894: C223 is_halting_on D268 , D270 by L893 , SCMPDS_6:def 3;
L895: (not C224 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L896: ( D269 . ( DataLoc (( D269 . C224 ) , C225) ) ) = ( D269 . D261 ) by L895 , L857 , FUNCT_4:11
.= ( C229 . D261 ) by L877 , FUNCT_4:11;
L897: ( IC D272 ) = ( succ ( IC D269 ) ) by L896 , L861 , L864 , SCMPDS_2:56
.= ( (( 0 ) qua Nat) + 1 ) by L878;
L898: ( IC D275 ) = D277 by L897 , L862 , L894 , L876 , L866 , L889 , L206;
L899: ( D280 /. ( IC D279 ) ) = ( D280 . ( IC D279 ) ) by PBOOLE:143;
L900: D279 = D275 by EXTPRO_1:4;
L901: ( CurInstr (D280 , D279) ) = ( D276 . D277 ) by L900 , L862 , L894 , L876 , L897 , L866 , L889 , L206 , L899
.= ( D262 . D277 ) by L880 , L887 , GRFUNC_1:2
.= D266 by L762;
L902: D284 = ( Following (D271 , D279) ) by EXTPRO_1:3
.= ( Exec (D266 , D279) ) by L901;
L903: ( IC D284 ) = ( succ ( IC D279 ) ) by L902 , SCMPDS_2:48
.= ( ( ( card C223 ) + 1 ) + 1 ) by L898 , L900 , NAT_1:38
.= ( ( card C223 ) + ( 1 + 1 ) );
L904: ( CurInstr (D285 , D284) ) = ( D271 . D286 ) by L903 , PBOOLE:143
.= ( D262 . D286 ) by L887 , L884 , GRFUNC_1:2
.= D267 by L762;
L905: D282 = ( Following (D271 , D284) ) by EXTPRO_1:3
.= ( Exec (D267 , D284) ) by L904;
L906: ( IC D282 ) = ( ICplusConst (D284 , ( (( 0 ) qua Nat) - ( ( card C223 ) + 2 ) )) ) by L905 , SCMPDS_2:54
.= ( 0 ) by L903 , L1;
L907: ( Initialize D282 ) = D282 by L906 , MEMSTR_0:46;
L908: ( DataPart ( Comput (D270 , D268 , D274) ) ) = ( DataPart D275 ) by L862 , L894 , L876 , L897 , L866 , L889 , L206;
L909: ( D275 . C224 ) = ( ( Comput (D270 , D268 , D274) ) . C224 ) by L908 , SCMPDS_4:8
.= ( C222 . C224 ) by L857 , L881 , L892 , EXTPRO_1:23;
L910: ( DataLoc (( D279 . C224 ) , C225) ) = D261 by L909 , EXTPRO_1:4;
L911: ( D284 . C224 ) = ( D279 . C224 ) by L910 , L847 , L902 , SCMPDS_2:48
.= ( C222 . C224 ) by L909 , EXTPRO_1:4;
L912: ( D282 . C224 ) = ( C222 . C224 ) by L911 , L905 , SCMPDS_2:54;
L913:
now
let C231 being Int_position;
assume L914: C231 in C227;
L915: ( D275 . C231 ) = ( ( Comput (D270 , D268 , D274) ) . C231 ) by L908 , SCMPDS_4:8
.= ( ( IExec (C223 , R22 , ( Initialize C229 )) ) . C231 ) by L892 , EXTPRO_1:23
.= ( ( Initialize C229 ) . C231 ) by L848 , L914 , L853 , L858
.= ( C229 . C231 ) by SCMPDS_5:15
.= ( C222 . C231 ) by L852 , L914;
L916: ( D284 . C231 ) = ( C222 . C231 ) by L915 , L845 , L909 , L900 , L902 , L914 , SCMPDS_2:48;
thus L917: ( D282 . C231 ) = ( C222 . C231 ) by L916 , L905 , SCMPDS_2:54;
end;
L918: ( D275 . D261 ) = ( ( Comput (D270 , D268 , D274) ) . D261 ) by L908 , SCMPDS_4:8
.= ( C229 . D261 ) by L867 , L892 , EXTPRO_1:23;
L919: ( D282 . D261 ) = ( D284 . D261 ) by L905 , SCMPDS_2:54
.= ( ( C229 . D261 ) + ( - C226 ) ) by L909 , L918 , L900 , L902 , SCMPDS_2:48;
L920: D262 is_closed_on D282 , D283 by L919 , L850 , L912 , L913 , L873;
L921:
now
let C232 being (Element of ( NAT ));
per cases ;
suppose L922: C232 < D281;

L923: C232 <= ( D278 + 1 ) by L922 , INT_1:7;
L924: (C232 <= D278 or C232 = ( D278 + 1 )) by L923 , NAT_1:8;
thus L925:now
per cases  by L924 , NAT_1:8;
suppose L926: C232 <= D274;

thus L927:now
per cases ;
suppose L928: C232 = ( 0 );

thus L929: ( IC ( Comput (D271 , D269 , C232) ) ) in ( dom D263 ) by L928 , L882 , L878 , EXTPRO_1:2;
end;
suppose L930: C232 <> ( 0 );

consider C233 being Nat such that L931: C232 = ( C233 + 1 ) by L930 , NAT_1:6;
reconsider D287 = C233 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D288 = ( IC ( Comput (D270 , D268 , D287) ) ) as (Element of ( NAT ));
L932: D287 < C232 by L931 , XREAL_1:29;
L933: D287 < D274 by L932 , L926 , XXREAL_0:2;
L934: ( ( IC ( Comput (D270 , D268 , D287) ) ) + 1 ) = ( IC ( Comput (D273 , D272 , D287) ) ) by L933 , L862 , L894 , L876 , L897 , L866 , L889 , L145;
L935: ( IC ( Comput (D271 , D269 , C232) ) ) = ( D288 + 1 ) by L934 , L931 , EXTPRO_1:4;
L936: ( IC ( Comput (D270 , D268 , D287) ) ) in ( dom D264 ) by L875 , SCMPDS_6:def 2;
L937: D288 < ( card D264 ) by L936 , AFINSQ_1:66;
L938: D288 < ( ( card C223 ) + 1 ) by L937 , COMPOS_1:55;
L939: ( D288 + 1 ) <= ( ( card C223 ) + 1 ) by L938 , INT_1:7;
L940: ( ( card C223 ) + 1 ) < ( ( card C223 ) + 4 ) by XREAL_1:6;
L941: ( D288 + 1 ) < ( ( card C223 ) + 4 ) by L940 , L939 , XXREAL_0:2;
L942: ( D288 + 1 ) < ( card D263 ) by L941 , L757;
thus L943: ( IC ( Comput (D271 , D269 , C232) ) ) in ( dom D263 ) by L942 , L935 , AFINSQ_1:66;
end;
end;
end;
suppose L928: C232 = D278;

L929: D277 in ( dom D263 ) by L880 , COMPOS_1:62;
thus L930: ( IC ( Comput (D271 , D269 , C232) ) ) in ( dom D263 ) by L929 , L862 , L894 , L876 , L897 , L866 , L889 , L900 , L928 , L206;
end;
suppose L931: C232 = ( D278 + 1 );

thus L932: ( IC ( Comput (D271 , D269 , C232) ) ) in ( dom D263 ) by L931 , L903 , L884 , COMPOS_1:62;
end;
end;
end;
suppose L926: C232 >= D281;

consider C234 being Nat such that L927: C232 = ( D281 + C234 ) by L926 , NAT_1:10;
reconsider D289 = C234 as (Element of ( NAT )) by ORDINAL1:def 12;
L928: ( Comput (D271 , D269 , C232) ) = ( Comput (( D283 +* D263 ) , ( Initialize D282 ) , D289) ) by L907 , L927 , EXTPRO_1:4;
thus L929: ( IC ( Comput (D271 , D269 , C232) ) ) in ( dom D263 ) by L928 , L920 , SCMPDS_6:def 2;
end;
end;
thus L931: D262 is_closed_on C229 , R22 by L921 , SCMPDS_6:def 2;
L932: D271 = ( D283 +* D263 );
L933: D262 is_halting_on D282 , D283 by L850 , L912 , L913 , L919 , L873;
L934: D283 halts_on D282 by L933 , L907 , L932 , SCMPDS_6:def 3;
L935: D271 halts_on D269 by L934 , EXTPRO_1:22;
thus L936: D262 is_halting_on C229 , R22 by L935 , SCMPDS_6:def 3;
end;
end;
reconsider D290 = ( C222 . D261 ) as (Element of ( NAT )) by L844 , INT_1:3;
L938: S5[ ( 0 ) ] by L770;
L939: (for B225 being (Element of ( NAT )) holds S5[ B225 ]) from NAT_1:sch 1(L938 , L849);
L940: S5[ D290 ] by L939;
L941: (for B226 being Int_position holds (B226 in C227 implies ( C222 . B226 ) = ( C222 . B226 )));
thus L942: thesis by L941 , L940;
end;
theorem
L943: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B227 being ( 0 ) -started (State of ( SCMPDS )) holds (for B228 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B229 being Int_position holds (for B230 being Integer holds (for B231 being (Element of ( NAT )) holds (for B232 being set holds ((( B227 . ( DataLoc (( B227 . B229 ) , B230) ) ) > ( 0 ) & (not ( DataLoc (( B227 . B229 ) , B230) ) in B232) & B231 > ( 0 ) & B229 <> ( DataLoc (( B227 . B229 ) , B230) ) & (for B233 being ( 0 ) -started (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B234 being Int_position holds (B234 in B232 implies ( B233 . B234 ) = ( B227 . B234 ))) & ( B233 . B229 ) = ( B227 . B229 )) implies (( ( IExec (B228 , R22 , B233) ) . B229 ) = ( B233 . B229 ) & ( ( IExec (B228 , R22 , B233) ) . ( DataLoc (( B227 . B229 ) , B230) ) ) = ( B233 . ( DataLoc (( B227 . B229 ) , B230) ) ) & B228 is_closed_on B233 , R22 & B228 is_halting_on B233 , R22 & (for B235 being Int_position holds (B235 in B232 implies ( ( IExec (B228 , R22 , B233) ) . B235 ) = ( B233 . B235 )))))))) implies ( IExec (( for-down (B229 , B230 , B231 , B228) ) , R19 , B227) ) = ( IExec (( for-down (B229 , B230 , B231 , B228) ) , R19 , ( Initialize ( IExec (( B228 ';' ( AddTo (B229 , B230 , ( - B231 )) ) ) , R19 , B227) ) )) )))))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C235 being ( 0 ) -started (State of ( SCMPDS ));
let C236 being  halt-free  shiftable (Program of ( SCMPDS ));
let C237 being Int_position;
let C238 being Integer;
let C239 being (Element of ( NAT ));
let C240 being set;
set D291 = ( DataLoc (( C235 . C237 ) , C238) );
set D292 = ( for-down (C237 , C238 , C239 , C236) );
set D293 = ( stop D292 );
set D294 = ( R19 +* D293 );
set D295 = ( (C237 , C238) <=0_goto ( ( card C236 ) + 3 ) );
set D296 = ( AddTo (C237 , C238 , ( - C239 )) );
set D297 = ( goto ( - ( ( card C236 ) + 2 ) ) );
assume L944: ( C235 . D291 ) > ( 0 );
set D298 = ( Comput (D294 , C235 , 1) );
set D299 = D294;
L945: ( IC C235 ) = ( 0 ) by MEMSTR_0:def 11;
set D300 = ( LifeSpan (D294 , C235) );
set D301 = ( ( card C236 ) + 2 );
set D302 = C235;
set D303 = ( R19 +* ( stop C236 ) );
set D304 = ( ( LifeSpan (D303 , D302) ) + 3 );
set D305 = ( C236 ';' ( AddTo (C237 , C238 , ( - C239 )) ) );
set D306 = C235;
set D307 = ( R19 +* ( stop D305 ) );
set D308 = ( Initialize ( IExec (D305 , R19 , C235) ) );
set D309 = ( R19 +* D293 );
set D310 = ( LifeSpan (D309 , D308) );
set D311 = ( IExec (D305 , R19 , C235) );
set D312 = ( DataLoc (( D311 . C237 ) , C238) );
L946: ( stop C236 ) c= D303 by FUNCT_4:25;
L947: D292 = ( D295 ';' ( ( C236 ';' D296 ) ';' D297 ) ) by L4;
set D313 = ( LifeSpan (D303 , D302) );
set D314 = ( Comput (D299 , D298 , D313) );
set D315 = D299;
set D316 = ( ( card C236 ) + 1 );
set D317 = ( D313 + 1 );
set D318 = ( Comput (D294 , C235 , D317) );
set D319 = D294;
set D320 = ( Comput (D294 , C235 , ( D317 + 1 )) );
set D321 = D294;
L948: D293 c= D294 by FUNCT_4:25;
L949: D292 c= D293 by AFINSQ_1:74;
L950: D292 c= D294 by L949 , L948 , XBOOLE_1:1;
L951: ( Shift (C236 , 1) ) c= D292 by L839;
L952: ( Shift (C236 , 1) ) c= D299 by L951 , L950 , XBOOLE_1:1;
L953: ( ( card C236 ) + 2 ) < ( ( card C236 ) + 3 ) by XREAL_1:6;
L954: D301 in ( dom D292 ) by L953 , L759;
set D322 = ( ( D317 + 1 ) + 1 );
set D323 = ( Comput (D294 , C235 , D322) );
L955: ( ( card C236 ) + 1 ) < ( ( card C236 ) + 3 ) by XREAL_1:6;
L956: D316 in ( dom D292 ) by L955 , L759;
assume L957: (not D291 in C240);
assume L958: C239 > ( 0 );
assume L959: C237 <> D291;
L960: ( Initialize C235 ) = C235 by MEMSTR_0:44;
assume L961: (for B236 being ( 0 ) -started (State of ( SCMPDS )) holds (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (((for B237 being Int_position holds (B237 in C240 implies ( B236 . B237 ) = ( C235 . B237 ))) & ( B236 . C237 ) = ( C235 . C237 )) implies (( ( IExec (C236 , R22 , B236) ) . C237 ) = ( B236 . C237 ) & ( ( IExec (C236 , R22 , B236) ) . D291 ) = ( B236 . D291 ) & C236 is_closed_on B236 , R22 & C236 is_halting_on B236 , R22 & (for B238 being Int_position holds (B238 in C240 implies ( ( IExec (C236 , R22 , B236) ) . B238 ) = ( B236 . B238 )))))));
L962: D292 is_halting_on C235 , R19 by L961 , L944 , L957 , L958 , L959 , L843;
L963: D294 halts_on C235 by L962 , L960 , SCMPDS_6:def 3;
L964: (for B239 being Int_position holds (B239 in C240 implies ( C235 . B239 ) = ( C235 . B239 )));
L965: ( ( IExec (C236 , R19 , C235) ) . D291 ) = ( C235 . D291 ) by L964 , L961;
L966: ( ( IExec (C236 , R19 , C235) ) . C237 ) = ( C235 . C237 ) by L961 , L964;
L967: D291 = ( DataLoc (( ( IExec (C236 , R19 , C235) ) . C237 ) , C238) ) by L961 , L964;
L968: ( ( IExec (C236 , R19 , C235) ) . C237 ) = ( C235 . C237 ) by L961 , L964;
L969: ( Comput (D294 , C235 , ( (( 0 ) qua Nat) + 1 )) ) = ( Following (D294 , ( Comput (D294 , C235 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D294 , C235) )
.= ( Exec (D295 , C235) ) by L947 , L960 , SCMPDS_6:11;
L970: ( IC D298 ) = ( succ ( IC C235 ) ) by L944 , L969 , SCMPDS_2:56
.= ( (( 0 ) qua Nat) + 1 ) by L945;
L971: (for R4 being Int_position holds ( D302 . R4 ) = ( D298 . R4 )) by L969 , SCMPDS_2:56;
L972: ( DataPart D302 ) = ( DataPart D298 ) by L971 , SCMPDS_4:8;
L973: C236 is_halting_on C235 , R19 by L961 , L964;
L974: D303 halts_on D302 by L973 , L960 , SCMPDS_6:def 3;
L975: D303 = ( D303 +* ( stop C236 ) );
L976: C236 is_halting_on D302 , D303 by L975 , L974 , L960 , SCMPDS_6:def 3;
L977: C236 is_closed_on C235 , R19 by L961 , L964;
L978: ( D311 . D291 ) = ( ( Exec (D296 , ( IExec (C236 , R19 , C235) )) ) . D291 ) by L977 , L973 , L451
.= ( ( ( IExec (C236 , R19 , C235) ) . D291 ) + ( - C239 ) ) by L966 , SCMPDS_2:48
.= ( ( C235 . D291 ) + ( - C239 ) ) by L961 , L964;
L979: ( D319 /. ( IC D318 ) ) = ( D319 . ( IC D318 ) ) by PBOOLE:143;
L980: C236 is_closed_on D302 , D303 by L961 , L964;
L981: ( IC D314 ) = D316 by L980 , L946 , L976 , L970 , L972 , L952 , L206;
L982: D318 = D314 by EXTPRO_1:4;
L983: ( CurInstr (D319 , D318) ) = ( D315 . D316 ) by L982 , L946 , L976 , L980 , L970 , L972 , L952 , L206 , L979
.= ( D292 . D316 ) by L956 , L950 , GRFUNC_1:2
.= D296 by L762;
L984: ( DataPart ( Comput (D303 , D302 , D313) ) ) = ( DataPart D314 ) by L946 , L976 , L980 , L970 , L972 , L952 , L206;
L985: ( D314 . C237 ) = ( ( Comput (D303 , D302 , D313) ) . C237 ) by L984 , SCMPDS_4:8
.= ( C235 . C237 ) by L968 , L974 , EXTPRO_1:23;
L986: ( D311 . C237 ) = ( ( Exec (D296 , ( IExec (C236 , R19 , C235) )) ) . C237 ) by L977 , L973 , L451
.= ( C235 . C237 ) by L959 , L966 , SCMPDS_2:48;
L987:
now
per cases ;
suppose L988: ( D311 . D312 ) <= ( 0 );

thus L989: D292 is_halting_on D311 , R19 by L988 , L770;
end;
suppose L990: ( D311 . D312 ) > ( 0 );

L991:
now
let C241 being ( 0 ) -started (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
assume that
L992: (for B240 being Int_position holds (B240 in C240 implies ( C241 . B240 ) = ( D311 . B240 )))
and
L993: ( C241 . C237 ) = ( D311 . C237 );
L994:
now
let C242 being Int_position;
assume L995: C242 in C240;
thus L996: ( C241 . C242 ) = ( D311 . C242 ) by L995 , L992
.= ( ( Exec (D296 , ( IExec (C236 , R19 , C235) )) ) . C242 ) by L977 , L973 , L451
.= ( ( IExec (C236 , R19 , C235) ) . C242 ) by L957 , L966 , L995 , SCMPDS_2:48
.= ( C235 . C242 ) by L961 , L964 , L995;
end;
thus L997: ( ( IExec (C236 , R22 , C241) ) . C237 ) = ( C241 . C237 ) by L994 , L961 , L986 , L993;
thus L998: ( ( IExec (C236 , R22 , C241) ) . D312 ) = ( C241 . D312 ) by L961 , L986 , L993 , L994;
thus L999: (C236 is_closed_on C241 , R22 & C236 is_halting_on C241 , R22 & (for B241 being Int_position holds (B241 in C240 implies ( ( IExec (C236 , R22 , C241) ) . B241 ) = ( C241 . B241 )))) by L961 , L986 , L993 , L994;
end;
thus L1000: D292 is_halting_on D311 , R19 by L991 , L957 , L958 , L959 , L986 , L990 , L843;
end;
end;
L1002: D309 halts_on D308 by L987 , SCMPDS_6:def 3;
L1003: D320 = ( Following (D294 , D318) ) by EXTPRO_1:3
.= ( Exec (D296 , D318) ) by L983;
L1004: ( IC D320 ) = ( succ ( IC D318 ) ) by L1003 , SCMPDS_2:48
.= ( ( ( card C236 ) + 1 ) + 1 ) by L981 , L982 , NAT_1:38
.= ( ( card C236 ) + ( 1 + 1 ) );
L1005: ( CurInstr (D321 , D320) ) = ( D294 . D301 ) by L1004 , PBOOLE:143
.= ( D292 . D301 ) by L950 , L954 , GRFUNC_1:2
.= D297 by L762;
L1006: D323 = ( Following (D294 , D320) ) by EXTPRO_1:3
.= ( Exec (D297 , D320) ) by L1005;
L1007: ( IC D323 ) = ( ICplusConst (D320 , ( (( 0 ) qua Nat) - ( ( card C236 ) + 2 ) )) ) by L1006 , SCMPDS_2:54
.= ( 0 ) by L1004 , L1;
L1008: ( IC D308 ) = ( IC ( Comput (D294 , C235 , D304) ) ) by L1007 , MEMSTR_0:def 11;
L1009: ( D314 . D291 ) = ( ( Comput (D303 , D302 , D313) ) . D291 ) by L984 , SCMPDS_4:8
.= ( C235 . D291 ) by L965 , L974 , EXTPRO_1:23;
L1010: ( D323 . D291 ) = ( D320 . D291 ) by L1006 , SCMPDS_2:54
.= ( ( C235 . D291 ) + ( - C239 ) ) by L985 , L1009 , L982 , L1003 , SCMPDS_2:48;
L1011:
now
let C243 being Int_position;
L1012: (not C243 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1013: ( D308 . C243 ) = ( ( IExec (D305 , R19 , C235) ) . C243 ) by L1012 , FUNCT_4:11;
per cases ;
suppose L1014: C243 = D291;

thus L1015: ( D323 . C243 ) = ( D308 . C243 ) by L1014 , L1010 , L978 , L1012 , FUNCT_4:11;
end;
suppose L1016: C243 <> D291;

L1017: ( D314 . C243 ) = ( ( Comput (D303 , D302 , D313) ) . C243 ) by L984 , SCMPDS_4:8
.= ( ( IExec (C236 , R19 , C235) ) . C243 ) by L974 , EXTPRO_1:23;
L1018: ( D320 . C243 ) = ( D314 . C243 ) by L985 , L982 , L1003 , L1016 , SCMPDS_2:48;
L1019: ( D311 . C243 ) = ( ( Exec (D296 , ( IExec (C236 , R19 , C235) )) ) . C243 ) by L977 , L973 , L451
.= ( ( IExec (C236 , R19 , C235) ) . C243 ) by L967 , L1016 , SCMPDS_2:48;
thus L1020: ( D323 . C243 ) = ( D308 . C243 ) by L1019 , L1006 , L1013 , L1017 , L1018 , SCMPDS_2:54;
end;
end;
L1022: ( DataPart D323 ) = ( DataPart D308 ) by L1011 , SCMPDS_4:8;
L1023: ( Comput (D294 , C235 , D304) ) = D308 by L1022 , L1008 , MEMSTR_0:78;
L1024: ( CurInstr (D294 , ( Comput (D294 , C235 , D304) )) ) = D295 by L1023 , L947 , SCMPDS_6:11;
L1025: D300 > D304 by L1024 , L963 , EXTPRO_1:36;
consider C244 being Nat such that L1026: D300 = ( D304 + C244 ) by L1025 , NAT_1:10;
reconsider D324 = C244 as (Element of ( NAT )) by ORDINAL1:def 12;
L1027: ( Comput (D294 , C235 , ( D304 + D310 )) ) = ( Comput (D309 , D308 , D310) ) by L1023 , EXTPRO_1:4;
L1028: ( CurInstr (D294 , ( Comput (D294 , C235 , ( D304 + D310 )) )) ) = ( halt ( SCMPDS ) ) by L1027 , L1002 , EXTPRO_1:def 15;
L1029: ( D304 + D310 ) >= D300 by L1028 , L963 , EXTPRO_1:def 15;
L1030: D310 >= D324 by L1029 , L1026 , XREAL_1:6;
L1031: ( Comput (D294 , C235 , D300) ) = ( Comput (D309 , D308 , D324) ) by L1023 , L1026 , EXTPRO_1:4;
L1032: ( CurInstr (D309 , ( Comput (D309 , D308 , D324) )) ) = ( halt ( SCMPDS ) ) by L1031 , L963 , EXTPRO_1:def 15;
L1033: D324 >= D310 by L1032 , L1002 , EXTPRO_1:def 15;
L1034: D324 = D310 by L1033 , L1030 , XXREAL_0:1;
L1035: ( Result (D294 , C235) ) = ( Comput (D309 , D308 , D310) ) by L1034 , L963 , L1031 , EXTPRO_1:23;
thus L1036: thesis by L1035 , L1002 , EXTPRO_1:23;
end;
registration
let C245 being  shiftable (Program of ( SCMPDS ));
let C246 being Int_position;
let C247 being Integer;
let C248 being (Element of ( NAT ));
cluster ( for-down (C246 , C247 , C248 , C245) ) ->  shiftable;
correctness
proof
set D325 = ( for-down (C246 , C247 , C248 , C245) );
set D326 = ( (C246 , C247) <=0_goto ( ( card C245 ) + 3 ) );
set D327 = ( AddTo (C246 , C247 , ( - C248 )) );
reconsider D328 = ( ( ( Load D326 ) ';' C245 ) ';' D327 ) as  shiftable (Program of ( SCMPDS ));
L1037: ( card D328 ) = ( ( card ( D326 ';' C245 ) ) + 1 ) by SCMP_GCD:4
.= ( ( ( card C245 ) + 1 ) + 1 ) by SCMPDS_6:6
.= ( ( card C245 ) + ( 1 + 1 ) );
L1038: ( ( card D328 ) + ( - ( ( card C245 ) + 2 ) ) ) = ( 0 ) by L1037;
thus L1039: thesis by L1038 , SCMPDS_4:23;
end;
end;
registration
let C249 being  halt-free (Program of ( SCMPDS ));
let C250 being Int_position;
let C251 being Integer;
let C252 being (Element of ( NAT ));
cluster ( for-down (C250 , C251 , C252 , C249) ) ->  halt-free;
correctness
proof
reconsider D329 = ( goto ( - ( ( card C249 ) + 2 ) ) ) as  No-StopCode (Instruction of ( SCMPDS )) by SCMPDS_5:21;
L1041: ( for-down (C250 , C251 , C252 , C249) ) = ( ( ( ( (C250 , C251) <=0_goto ( ( card C249 ) + 3 ) ) ';' C249 ) ';' ( AddTo (C250 , C251 , ( - C252 )) ) ) ';' D329 );
thus L1042: thesis by L1041;
end;
end;
begin
definition
let C253 being (Element of ( NAT ));
func sum C253 -> (Program of ( SCMPDS )) equals 
( ( ( ( ( GBP ) := ( 0 ) ) ';' ( (( GBP ) , 2) := C253 ) ) ';' ( (( GBP ) , 3) := ( 0 ) ) ) ';' ( for-down (( GBP ) , 2 , 1 , ( Load ( AddTo (( GBP ) , 3 , 1) ) )) ) );
coherence;
end;
theorem
L1045: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B242 being ( 0 ) -started (State of ( SCMPDS )) holds (( B242 . ( GBP ) ) = ( 0 ) implies (( for-down (( GBP ) , 2 , 1 , ( Load ( AddTo (( GBP ) , 3 , 1) ) )) ) is_closed_on B242 , R19 & ( for-down (( GBP ) , 2 , 1 , ( Load ( AddTo (( GBP ) , 3 , 1) ) )) ) is_halting_on B242 , R19))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
set D330 = ( Load ( AddTo (( GBP ) , 3 , 1) ) );
let C254 being ( 0 ) -started (State of ( SCMPDS ));
assume L1046: ( C254 . ( GBP ) ) = ( 0 );
per cases ;
suppose L1047: ( C254 . ( DataLoc (( C254 . ( GBP ) ) , 2) ) ) <= ( 0 );

thus L1048: thesis by L1047 , L770;
end;
suppose L1049: ( C254 . ( DataLoc (( C254 . ( GBP ) ) , 2) ) ) > ( 0 );

L1050:
now
set D331 = ( DataLoc (( C254 . ( GBP ) ) , 2) );
let C255 being ( 0 ) -started (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
L1051: ( Initialize C255 ) = C255 by MEMSTR_0:44;
assume that
L1052: (for B243 being Int_position holds (B243 in { ( GBP ) } implies ( C255 . B243 ) = ( C254 . B243 )))
and
L1053: ( C255 . ( GBP ) ) = ( C254 . ( GBP ) );
set D332 = ( Initialize C255 );
L1054: ( D332 . ( GBP ) ) = ( 0 ) by L1046 , L1053 , SCMPDS_5:15;
L1055: ( DataLoc (( D332 . ( GBP ) ) , 3) ) = ( intpos ( (( 0 ) qua Nat) + 3 ) ) by L1054 , SCMP_GCD:1;
thus L1056: ( ( IExec (D330 , R22 , C255) ) . ( GBP ) ) = ( ( Exec (( AddTo (( GBP ) , 3 , 1) ) , D332) ) . ( GBP ) ) by L1051 , SCMPDS_5:40
.= ( D332 . ( GBP ) ) by L1055 , AMI_3:10 , SCMPDS_2:48
.= ( C255 . ( GBP ) ) by SCMPDS_5:15;
L1057: D331 = ( intpos ( (( 0 ) qua Nat) + 2 ) ) by L1046 , SCMP_GCD:1;
thus L1058: ( ( IExec (D330 , R22 , C255) ) . D331 ) = ( ( Exec (( AddTo (( GBP ) , 3 , 1) ) , D332) ) . D331 ) by L1051 , SCMPDS_5:40
.= ( D332 . D331 ) by L1055 , L1057 , AMI_3:10 , SCMPDS_2:48
.= ( C255 . D331 ) by SCMPDS_5:15;
thus L1059: (D330 is_closed_on C255 , R22 & D330 is_halting_on C255 , R22) by SCMPDS_6:20 , SCMPDS_6:21;
let C256 being Int_position;
assume L1060: C256 in { ( GBP ) };
L1061: C256 = ( GBP ) by L1060 , TARSKI:def 1;
thus L1062: ( ( IExec (D330 , R22 , C255) ) . C256 ) = ( C255 . C256 ) by L1061 , L1056;
end;
L1063: ( DataLoc (( C254 . ( GBP ) ) , 2) ) = ( intpos ( (( 0 ) qua Nat) + 2 ) ) by L1046 , SCMP_GCD:1;
L1064: ( DataLoc (( C254 . ( GBP ) ) , 2) ) <> ( GBP ) by L1063 , AMI_3:10;
L1065: (not ( DataLoc (( C254 . ( GBP ) ) , 2) ) in { ( GBP ) }) by L1064 , TARSKI:def 1;
thus L1066: thesis by L1065 , L1046 , L1049 , L1050 , L843;
end;
end;
theorem
L1068: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B244 being ( 0 ) -started (State of ( SCMPDS )) holds (for B245 being (Element of ( NAT )) holds ((( B244 . ( GBP ) ) = ( 0 ) & ( B244 . ( intpos 2 ) ) = B245 & ( B244 . ( intpos 3 ) ) = ( 0 )) implies ( ( IExec (( for-down (( GBP ) , 2 , 1 , ( Load ( AddTo (( GBP ) , 3 , 1) ) )) ) , R19 , B244) ) . ( intpos 3 ) ) = B245))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
set D333 = ( AddTo (( GBP ) , 3 , 1) );
set D334 = ( Load D333 );
set D335 = ( for-down (( GBP ) , 2 , 1 , D334) );
set D336 = ( intpos 3 );
let C257 being ( 0 ) -started (State of ( SCMPDS ));
let C258 being (Element of ( NAT ));
assume that
L1069: ( C257 . ( GBP ) ) = ( 0 )
and
L1070: ( C257 . ( intpos 2 ) ) = C258
and
L1071: ( C257 . D336 ) = ( 0 );
defpred S6[ (Element of ( NAT )) ] means (for B246 being ( 0 ) -started (State of ( SCMPDS )) holds ((( B246 . ( intpos 2 ) ) = $1 & ( B246 . ( GBP ) ) = ( 0 )) implies ( ( IExec (D335 , R19 , B246) ) . D336 ) = ( $1 + ( B246 . D336 ) )));
L1072:
now
let C259 being (Element of ( NAT ));
assume L1073: S6[ C259 ];
L1074:
now
let C260 being ( 0 ) -started (State of ( SCMPDS ));
assume that
L1075: ( C260 . ( intpos 2 ) ) = ( C259 + 1 )
and
L1076: ( C260 . ( GBP ) ) = ( 0 );
L1077: ( GBP ) <> ( DataLoc (( C260 . ( GBP ) ) , 2) ) by L1075 , L1076 , SCMP_GCD:1;
L1078: (not ( DataLoc (( C260 . ( GBP ) ) , 2) ) in { ( GBP ) }) by L1077 , TARSKI:def 1;
L1079:
now
set D337 = ( DataLoc (( C260 . ( GBP ) ) , 2) );
let C261 being ( 0 ) -started (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
L1080: ( Initialize C261 ) = C261 by MEMSTR_0:44;
assume that
L1081: (for B247 being Int_position holds (B247 in { ( GBP ) } implies ( C261 . B247 ) = ( C260 . B247 )))
and
L1082: ( C261 . ( GBP ) ) = ( C260 . ( GBP ) );
set D338 = ( Initialize C261 );
L1083: ( D338 . ( GBP ) ) = ( 0 ) by L1076 , L1082 , SCMPDS_5:15;
L1084: ( DataLoc (( D338 . ( GBP ) ) , 3) ) = ( intpos ( (( 0 ) qua Nat) + 3 ) ) by L1083 , SCMP_GCD:1;
L1085: D337 <> ( DataLoc (( D338 . ( GBP ) ) , 3) ) by L1084 , L1075 , L1076 , AMI_3:10 , SCMP_GCD:1;
thus L1086: ( ( IExec (D334 , R22 , C261) ) . ( GBP ) ) = ( ( Exec (( AddTo (( GBP ) , 3 , 1) ) , D338) ) . ( GBP ) ) by L1080 , SCMPDS_5:40
.= ( D338 . ( GBP ) ) by L1084 , AMI_3:10 , SCMPDS_2:48
.= ( C261 . ( GBP ) ) by SCMPDS_5:15;
thus L1087: ( ( IExec (D334 , R22 , C261) ) . D337 ) = ( ( Exec (( AddTo (( GBP ) , 3 , 1) ) , D338) ) . D337 ) by L1080 , SCMPDS_5:40
.= ( D338 . D337 ) by L1085 , SCMPDS_2:48
.= ( C261 . D337 ) by SCMPDS_5:15;
thus L1088: (D334 is_closed_on C261 , R22 & D334 is_halting_on C261 , R22) by SCMPDS_6:20 , SCMPDS_6:21;
let C262 being Int_position;
assume L1089: C262 in { ( GBP ) };
L1090: C262 = ( GBP ) by L1089 , TARSKI:def 1;
thus L1091: ( ( IExec (D334 , R22 , C261) ) . C262 ) = ( C261 . C262 ) by L1090 , L1086;
end;
set D339 = ( AddTo (( GBP ) , 2 , ( - 1 )) );
set D340 = C260;
set D341 = ( IExec (D334 , R19 , C260) );
set D342 = ( IExec (( D334 ';' D339 ) , R19 , C260) );
set D343 = ( intpos 2 );
set D344 = R19;
L1092: ( DataLoc (( D340 . ( GBP ) ) , 3) ) = ( intpos ( (( 0 ) qua Nat) + 3 ) ) by L1076 , SCMP_GCD:1;
L1093: ( D341 . ( GBP ) ) = ( ( Exec (D333 , D340) ) . ( GBP ) ) by SCMPDS_5:40
.= ( 0 ) by L1076 , L1092 , AMI_3:10 , SCMPDS_2:48;
L1094: ( DataLoc (( D341 . ( GBP ) ) , 2) ) = ( intpos ( (( 0 ) qua Nat) + 2 ) ) by L1093 , SCMP_GCD:1;
L1095: ( D342 . D343 ) = ( ( Exec (D339 , D341) ) . D343 ) by SCMPDS_5:41
.= ( ( D341 . D343 ) + ( - 1 ) ) by L1094 , SCMPDS_2:48
.= ( ( ( Exec (D333 , D340) ) . D343 ) + ( - 1 ) ) by SCMPDS_5:40
.= ( ( D340 . D343 ) + ( - 1 ) ) by L1092 , AMI_3:10 , SCMPDS_2:48
.= C259 by L1075;
L1096: ( D342 . D336 ) = ( ( Exec (D339 , D341) ) . D336 ) by SCMPDS_5:41
.= ( D341 . D336 ) by L1094 , AMI_3:10 , SCMPDS_2:48
.= ( ( Exec (D333 , D340) ) . D336 ) by SCMPDS_5:40
.= ( ( C260 . D336 ) + 1 ) by L1092 , SCMPDS_2:48;
L1097: ( D342 . ( GBP ) ) = ( ( Exec (D339 , D341) ) . ( GBP ) ) by SCMPDS_5:41
.= ( 0 ) by L1093 , L1094 , AMI_3:10 , SCMPDS_2:48;
L1098: ( ( Initialize D342 ) . ( intpos 2 ) ) = ( D342 . ( intpos 2 ) ) by SCMPDS_5:15;
L1099: ( ( Initialize D342 ) . D336 ) = ( D342 . D336 ) by SCMPDS_5:15;
L1100: ( ( Initialize D342 ) . ( GBP ) ) = ( D342 . ( GBP ) ) by SCMPDS_5:15;
L1101: ( DataLoc (( C260 . ( GBP ) ) , 2) ) = ( intpos ( (( 0 ) qua Nat) + 2 ) ) by L1076 , SCMP_GCD:1;
thus L1102: ( ( IExec (D335 , R19 , C260) ) . D336 ) = ( ( IExec (D335 , D344 , ( Initialize D342 )) ) . D336 ) by L1101 , L1075 , L1076 , L1078 , L1079 , L943
.= ( C259 + ( D342 . D336 ) ) by L1073 , L1095 , L1097 , L1098 , L1099 , L1100
.= ( ( C259 + 1 ) + ( C260 . D336 ) ) by L1096;
end;
thus L1103: S6[ ( C259 + 1 ) ] by L1074;
end;
L1104: S6[ ( 0 ) ]
proof
let C263 being ( 0 ) -started (State of ( SCMPDS ));
assume that
L1105: ( C263 . ( intpos 2 ) ) = ( 0 )
and
L1106: ( C263 . ( GBP ) ) = ( 0 );
L1107: ( Initialize C263 ) = C263 by MEMSTR_0:44;
L1108: ( DataLoc (( C263 . ( GBP ) ) , 2) ) = ( intpos ( (( 0 ) qua Nat) + 2 ) ) by L1106 , SCMP_GCD:1;
thus L1109: thesis by L1108 , L1105 , L834 , L1107;
end;
L1110: (for B248 being (Element of ( NAT )) holds S6[ B248 ]) from NAT_1:sch 1(L1104 , L1072);
thus L1111: ( ( IExec (D335 , R19 , C257) ) . D336 ) = ( C258 + (( 0 ) qua Nat) ) by L1110 , L1069 , L1070 , L1071
.= C258;
end;
theorem
L1112: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B249 being ( 0 ) -started (State of ( SCMPDS )) holds (for B250 being (Element of ( NAT )) holds ( ( IExec (( sum B250 ) , R19 , B249) ) . ( intpos 3 ) ) = B250)))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C264 being ( 0 ) -started (State of ( SCMPDS ));
let C265 being (Element of ( NAT ));
set D345 = ( ( GBP ) := ( 0 ) );
set D346 = ( (( GBP ) , 2) := C265 );
set D347 = ( (( GBP ) , 3) := ( 0 ) );
set D348 = ( AddTo (( GBP ) , 3 , 1) );
set D349 = ( for-down (( GBP ) , 2 , 1 , ( Load D348 )) );
set D350 = ( intpos 3 );
set D351 = ( D345 ';' D346 );
set D352 = ( IExec (D351 , R19 , C264) );
set D353 = ( Exec (D345 , C264) );
set D354 = ( D351 ';' D347 );
set D355 = ( IExec (D354 , R19 , C264) );
set D356 = R19;
L1113: D354 is_closed_on C264 , R19 by SCMPDS_6:20;
L1114: D354 is_halting_on C264 , R19 by SCMPDS_6:21;
L1115: ( D353 . ( GBP ) ) = ( 0 ) by SCMPDS_2:45;
L1116: ( DataLoc (( D353 . ( GBP ) ) , 2) ) = ( intpos ( (( 0 ) qua Nat) + 2 ) ) by L1115 , SCMP_GCD:1;
L1117: ( D352 . ( GBP ) ) = ( ( Exec (D346 , D353) ) . ( GBP ) ) by SCMPDS_5:42
.= ( 0 ) by L1115 , L1116 , AMI_3:10 , SCMPDS_2:46;
L1118: ( DataLoc (( D352 . ( GBP ) ) , 3) ) = ( intpos ( (( 0 ) qua Nat) + 3 ) ) by L1117 , SCMP_GCD:1;
L1119: ( ( Initialize D355 ) . ( GBP ) ) = ( D355 . ( GBP ) ) by SCMPDS_5:15;
L1120: ( D355 . ( GBP ) ) = ( ( Exec (D347 , D352) ) . ( GBP ) ) by SCMPDS_5:41
.= ( 0 ) by L1117 , L1118 , AMI_3:10 , SCMPDS_2:46;
L1121: D349 is_halting_on ( Initialize D355 ) , D356 by L1120 , L1045 , L1119;
L1122: D349 is_halting_on D355 , D356 by L1121 , SCMPDS_6:126;
L1123: ( D355 . ( intpos 2 ) ) = ( ( Exec (D347 , D352) ) . ( intpos 2 ) ) by SCMPDS_5:41
.= ( D352 . ( intpos 2 ) ) by L1118 , AMI_3:10 , SCMPDS_2:46
.= ( ( Exec (D346 , D353) ) . ( intpos 2 ) ) by SCMPDS_5:42
.= C265 by L1116 , SCMPDS_2:46;
L1124: ( D355 . D350 ) = ( ( Exec (D347 , D352) ) . D350 ) by SCMPDS_5:41
.= ( 0 ) by L1118 , SCMPDS_2:46;
L1125: ( ( Initialize D355 ) . ( intpos 2 ) ) = ( D355 . ( intpos 2 ) ) by SCMPDS_5:15;
L1126: ( ( Initialize D355 ) . D350 ) = ( D355 . D350 ) by SCMPDS_5:15;
L1127: ( ( Initialize D355 ) . ( GBP ) ) = ( D355 . ( GBP ) ) by SCMPDS_5:15;
L1128: D349 is_closed_on ( Initialize D355 ) , D356 by L1120 , L1045 , L1127;
L1129: D349 is_closed_on D355 , D356 by L1128 , SCMPDS_6:125;
thus L1130: ( ( IExec (( sum C265 ) , R19 , C264) ) . D350 ) = ( ( IExec (D349 , D356 , ( Initialize D355 )) ) . D350 ) by L1129 , L1113 , L1114 , L1122 , L443
.= C265 by L1124 , L1120 , L1123 , L1068 , L1125 , L1126 , L1127;
end;
definition
let C266 , C267 , C268 , C269 , C270 being (Element of ( NAT ));
func sum (C266 , C267 , C268 , C269 , C270) -> (Program of ( SCMPDS )) equals 
( ( ( (( intpos C266 ) , C268) := ( 0 ) ) ';' ( ( intpos C269 ) := C270 ) ) ';' ( for-down (( intpos C266 ) , C267 , 1 , ( ( AddTo (( intpos C266 ) , C268 , ( intpos C270 ) , ( 0 )) ) ';' ( AddTo (( intpos C269 ) , ( 0 ) , 1) ) )) ) );
coherence;
end;
theorem
L1132: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B251 being ( 0 ) -started (State of ( SCMPDS )) holds (for B252 , B253 , B254 , B255 , B256 being (Element of ( NAT )) holds ((( B251 . ( intpos B252 ) ) > B252 & B253 < B254 & ( B251 . ( intpos B255 ) ) = B256 & ( ( B251 . ( intpos B252 ) ) + B254 ) < B255 & B255 < B256 & B256 < ( B251 . ( intpos B256 ) )) implies (( for-down (( intpos B252 ) , B253 , 1 , ( ( AddTo (( intpos B252 ) , B254 , ( intpos B256 ) , ( 0 )) ) ';' ( AddTo (( intpos B255 ) , ( 0 ) , 1) ) )) ) is_closed_on B251 , R19 & ( for-down (( intpos B252 ) , B253 , 1 , ( ( AddTo (( intpos B252 ) , B254 , ( intpos B256 ) , ( 0 )) ) ';' ( AddTo (( intpos B255 ) , ( 0 ) , 1) ) )) ) is_halting_on B251 , R19)))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C271 being ( 0 ) -started (State of ( SCMPDS ));
let C272 , C273 , C274 , C275 , C276 being (Element of ( NAT ));
set D357 = ( intpos C272 );
set D358 = ( intpos C276 );
set D359 = ( intpos C275 );
assume that
L1133: ( C271 . D357 ) > C272
and
L1134: C273 < C274
and
L1135: ( C271 . D359 ) = C276
and
L1136: ( ( C271 . D357 ) + C274 ) < C275
and
L1137: C275 < C276
and
L1138: C276 < ( C271 . D358 );
set D360 = ( AddTo (D357 , C274 , D358 , ( 0 )) );
set D361 = ( AddTo (D359 , ( 0 ) , 1) );
set D362 = ( D360 ';' D361 );
per cases ;
suppose L1139: ( C271 . ( DataLoc (( C271 . D357 ) , C273) ) ) <= ( 0 );

thus L1140: thesis by L1139 , L770;
end;
suppose L1141: ( C271 . ( DataLoc (( C271 . D357 ) , C273) ) ) > ( 0 );

reconsider D363 = ( C271 . D357 ) as (Element of ( NAT )) by L1133 , INT_1:3;
L1142: ( D363 + C273 ) <> C272 by L1133 , NAT_1:11;
L1143: ( abs ( D363 + C273 ) ) <> C272 by L1142 , ABSVALUE:def 1;
L1144: ( DataLoc (( C271 . D357 ) , C273) ) <> D357 by L1143 , XTUPLE_0:1;
L1145: ( D363 + C274 ) > ( D363 + C273 ) by L1134 , XREAL_1:6;
L1146:
now
set D364 = ( DataLoc (( C271 . D357 ) , C273) );
let C277 being ( 0 ) -started (State of ( SCMPDS ));
let R22 being (Instruction-Sequence of ( SCMPDS ));
L1147: ( Initialize C277 ) = C277 by MEMSTR_0:44;
assume that
L1148: (for B257 being Int_position holds (B257 in { D357 , D359 } implies ( C277 . B257 ) = ( C271 . B257 )))
and
L1149: ( C277 . D357 ) = ( C271 . D357 );
set D365 = ( Initialize C277 );
set D366 = ( Exec (D360 , D365) );
L1150: ( DataLoc (( D365 . D357 ) , C274) ) = ( DataLoc (D363 , C274) ) by L1149 , SCMPDS_5:15
.= ( intpos ( D363 + C274 ) ) by SCMP_GCD:1;
L1151: ( DataLoc (( D365 . D357 ) , C274) ) <> D359 by L1150 , L1136 , XTUPLE_0:1;
L1152: ( D366 . D359 ) = ( D365 . D359 ) by L1151 , SCMPDS_2:49
.= ( C277 . D359 ) by SCMPDS_5:15;
L1153: ( D363 + C274 ) <> C272 by L1133 , NAT_1:11;
L1154: ( DataLoc (( D365 . D357 ) , C274) ) <> D357 by L1153 , L1150 , XTUPLE_0:1;
L1155: ( D366 . D357 ) = ( D365 . D357 ) by L1154 , SCMPDS_2:49
.= ( C277 . D357 ) by SCMPDS_5:15;
L1156: D359 in { D357 , D359 } by TARSKI:def 2;
L1157: ( D366 . D359 ) = C276 by L1156 , L1135 , L1148 , L1152;
L1158: ( DataLoc (( D366 . D359 ) , ( 0 )) ) = ( intpos ( C276 + (( 0 ) qua Nat) ) ) by L1157 , SCMP_GCD:1;
L1159: ( abs ( ( D366 . D359 ) + (( 0 ) qua Nat) ) ) = C276 by L1158 , XTUPLE_0:1;
L1160: D363 <= ( D363 + C274 ) by NAT_1:11;
L1161: C272 < ( D363 + C274 ) by L1160 , L1133 , XXREAL_0:2;
L1162: ( abs ( ( D366 . D359 ) + (( 0 ) qua Nat) ) ) <> C272 by L1161 , L1136 , L1137 , L1159 , XXREAL_0:2;
L1163: ( DataLoc (( D366 . D359 ) , ( 0 )) ) <> D357 by L1162 , XTUPLE_0:1;
L1164: D364 = ( intpos ( D363 + C273 ) ) by SCMP_GCD:1;
L1165: ( abs ( ( C271 . D357 ) + C273 ) ) = ( D363 + C273 ) by L1164 , XTUPLE_0:1;
L1166: ( abs ( ( D366 . D359 ) + (( 0 ) qua Nat) ) ) <> ( abs ( ( C271 . D357 ) + C273 ) ) by L1165 , L1136 , L1137 , L1145 , L1159 , XXREAL_0:2;
L1167: ( DataLoc (( D366 . D359 ) , ( 0 )) ) <> D364 by L1166 , XTUPLE_0:1;
L1168: ( abs ( ( D365 . D357 ) + C274 ) ) = ( D363 + C274 ) by L1150 , XTUPLE_0:1;
L1169: ( abs ( ( D365 . D357 ) + C274 ) ) <> ( abs ( ( C271 . D357 ) + C273 ) ) by L1168 , L1134 , L1165;
L1170: ( DataLoc (( D365 . D357 ) , C274) ) <> D364 by L1169 , XTUPLE_0:1;
thus L1171: ( ( IExec (D362 , R22 , C277) ) . D357 ) = ( ( Exec (D361 , D366) ) . D357 ) by L1147 , SCMPDS_5:42
.= ( C277 . D357 ) by L1155 , L1163 , SCMPDS_2:48;
thus L1172: ( ( IExec (D362 , R22 , C277) ) . D364 ) = ( ( Exec (D361 , D366) ) . D364 ) by L1147 , SCMPDS_5:42
.= ( D366 . D364 ) by L1167 , SCMPDS_2:48
.= ( D365 . D364 ) by L1170 , SCMPDS_2:49
.= ( C277 . D364 ) by SCMPDS_5:15;
thus L1173: (D362 is_closed_on C277 , R22 & D362 is_halting_on C277 , R22) by SCMPDS_6:20 , SCMPDS_6:21;
L1174: ( ( IExec (D362 , R22 , ( Initialize C277 )) ) . D359 ) = ( ( Exec (D361 , D366) ) . D359 ) by SCMPDS_5:42
.= ( C277 . D359 ) by L1135 , L1138 , L1152 , L1158 , SCMPDS_2:48;
thus L1175:now
let C278 being Int_position;
assume L1176: C278 in { D357 , D359 };
per cases  by L1176 , TARSKI:def 2;
suppose L1177: C278 = D357;

thus L1178: ( ( IExec (D362 , R22 , C277) ) . C278 ) = ( C277 . C278 ) by L1177 , L1171;
end;
suppose L1179: C278 = D359;

thus L1180: ( ( IExec (D362 , R22 , C277) ) . C278 ) = ( C277 . C278 ) by L1179 , L1174 , MEMSTR_0:44;
end;
end;
end;
L1176: ( D363 + C273 ) <> C275 by L1134 , L1136 , XREAL_1:6;
L1177: ( abs ( D363 + C273 ) ) <> C275 by L1176 , ABSVALUE:def 1;
L1178: ( DataLoc (( C271 . D357 ) , C273) ) <> D359 by L1177 , XTUPLE_0:1;
L1179: (not ( DataLoc (( C271 . D357 ) , C273) ) in { D357 , D359 }) by L1178 , L1144 , TARSKI:def 2;
thus L1180: thesis by L1179 , L1141 , L1144 , L1146 , L843;
end;
end;
theorem
L1182: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B258 being ( 0 ) -started (State of ( SCMPDS )) holds (for B259 , B260 , B261 , B262 , B263 being (Element of ( NAT )) holds (for B264 being (FinSequence of ( NAT )) holds ((( B258 . ( intpos B259 ) ) > B259 & B260 < B261 & ( B258 . ( intpos B262 ) ) = B263 & ( ( B258 . ( intpos B259 ) ) + B261 ) < B262 & B262 < B263 & B263 < ( B258 . ( intpos B263 ) ) & ( B258 . ( DataLoc (( B258 . ( intpos B259 ) ) , B261) ) ) = ( 0 ) & ( len B264 ) = ( B258 . ( DataLoc (( B258 . ( intpos B259 ) ) , B260) ) ) & (for B265 being (Element of ( NAT )) holds (B265 < ( len B264 ) implies ( B264 . ( B265 + 1 ) ) = ( B258 . ( DataLoc (( B258 . ( intpos B263 ) ) , B265) ) )))) implies ( ( IExec (( for-down (( intpos B259 ) , B260 , 1 , ( ( AddTo (( intpos B259 ) , B261 , ( intpos B263 ) , ( 0 )) ) ';' ( AddTo (( intpos B262 ) , ( 0 ) , 1) ) )) ) , R19 , B258) ) . ( DataLoc (( B258 . ( intpos B259 ) ) , B261) ) ) = ( Sum B264 ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C279 being ( 0 ) -started (State of ( SCMPDS ));
let C280 , C281 , C282 , C283 , C284 being (Element of ( NAT ));
let C285 being (FinSequence of ( NAT ));
set D367 = ( intpos C280 );
set D368 = ( intpos C284 );
set D369 = ( intpos C283 );
assume that
L1183: ( C279 . D367 ) > C280
and
L1184: C281 < C282
and
L1185: ( C279 . D369 ) = C284
and
L1186: ( ( C279 . D367 ) + C282 ) < C283
and
L1187: C283 < C284
and
L1188: C284 < ( C279 . D368 )
and
L1189: ( C279 . ( DataLoc (( C279 . D367 ) , C282) ) ) = ( 0 )
and
L1190: ( len C285 ) = ( C279 . ( DataLoc (( C279 . D367 ) , C281) ) )
and
L1191: (for B266 being (Element of ( NAT )) holds (B266 < ( len C285 ) implies ( C285 . ( B266 + 1 ) ) = ( C279 . ( DataLoc (( C279 . D368 ) , B266) ) )));
reconsider D370 = ( C279 . D367 ) as (Element of ( NAT )) by L1183 , INT_1:3;
L1192: ( D370 + C282 ) < C284 by L1186 , L1187 , XXREAL_0:2;
set D371 = ( AddTo (D367 , C282 , D368 , ( 0 )) );
set D372 = ( AddTo (D369 , ( 0 ) , 1) );
set D373 = ( D371 ';' D372 );
set D374 = ( for-down (D367 , C281 , 1 , D373) );
set D375 = ( DataLoc (( C279 . D367 ) , C282) );
defpred S7[ (Element of ( NAT )) ] means (for R22 being (Instruction-Sequence of ( SCMPDS )) holds (for B267 being ( 0 ) -started (State of ( SCMPDS )) holds (for B268 being (FinSequence of ( NAT )) holds ((( B267 . D367 ) = ( C279 . D367 ) & ( B267 . D369 ) = C284 & C284 < ( B267 . D368 ) & ( len B268 ) = ( B267 . ( DataLoc (( B267 . D367 ) , C281) ) ) & ( len B268 ) = $1 & (for B269 being (Element of ( NAT )) holds (B269 < ( len B268 ) implies ( B268 . ( B269 + 1 ) ) = ( B267 . ( DataLoc (( B267 . D368 ) , B269) ) )))) implies ( ( IExec (D374 , R22 , B267) ) . D375 ) = ( ( Sum B268 ) + ( B267 . D375 ) )))));
L1193: D370 <= ( D370 + C282 ) by NAT_1:11;
L1194: C280 < ( D370 + C282 ) by L1193 , L1183 , XXREAL_0:2;
L1195: ( D370 + C282 ) > ( D370 + C281 ) by L1184 , XREAL_1:6;
L1196: ( D370 + C281 ) < C283 by L1195 , L1186 , XXREAL_0:2;
L1197: ( D370 + C281 ) < C284 by L1196 , L1187 , XXREAL_0:2;
L1198:
now
let C286 being (Element of ( NAT ));
assume L1199: S7[ C286 ];
L1200:
now
let C287 being ( 0 ) -started (State of ( SCMPDS ));
let C288 being (FinSequence of ( NAT ));
let C289 being (Instruction-Sequence of ( SCMPDS ));
assume that
L1201: ( C287 . D367 ) = ( C279 . D367 )
and
L1202: ( C287 . D369 ) = C284
and
L1203: C284 < ( C287 . D368 )
and
L1204: ( len C288 ) = ( C287 . ( DataLoc (( C287 . D367 ) , C281) ) )
and
L1205: ( len C288 ) = ( C286 + 1 )
and
L1206: (for B270 being (Element of ( NAT )) holds (B270 < ( len C288 ) implies ( C288 . ( B270 + 1 ) ) = ( C287 . ( DataLoc (( C287 . D368 ) , B270) ) )));
L1207: C288 is (FinSequence of ( REAL )) by FINSEQ_2:24;
L1208:
now
set D376 = ( DataLoc (( C287 . D367 ) , C281) );
let C290 being ( 0 ) -started (State of ( SCMPDS ));
let C291 being (Instruction-Sequence of ( SCMPDS ));
L1209: ( Initialize C290 ) = C290 by MEMSTR_0:44;
assume that
L1210: (for B271 being Int_position holds (B271 in { D367 , D369 } implies ( C290 . B271 ) = ( C287 . B271 )))
and
L1211: ( C290 . D367 ) = ( C287 . D367 );
set D377 = ( Initialize C290 );
set D378 = ( Exec (D371 , D377) );
L1212: ( DataLoc (( D377 . D367 ) , C282) ) = ( DataLoc (D370 , C282) ) by L1201 , L1211 , SCMPDS_5:15
.= ( intpos ( D370 + C282 ) ) by SCMP_GCD:1;
L1213: ( abs ( ( D377 . D367 ) + C282 ) ) = ( D370 + C282 ) by L1212 , XTUPLE_0:1;
L1214: ( D378 . D369 ) = ( D377 . D369 ) by L1213 , L1185 , L1187 , L1189 , L1212 , SCMPDS_2:49
.= ( C290 . D369 ) by SCMPDS_5:15;
L1215: D369 in { D367 , D369 } by TARSKI:def 2;
L1216: ( D378 . D369 ) = C284 by L1215 , L1202 , L1210 , L1214;
L1217: ( ( D378 . D369 ) + (( 0 ) qua Nat) ) <> C280 by L1216 , L1186 , L1187 , L1194 , XXREAL_0:2;
L1218: ( abs ( ( D378 . D369 ) + (( 0 ) qua Nat) ) ) <> C280 by L1217 , L1216 , ABSVALUE:def 1;
L1219: ( DataLoc (( D378 . D369 ) , ( 0 )) ) <> D367 by L1218 , XTUPLE_0:1;
L1220: ( D378 . D367 ) = ( D377 . D367 ) by L1183 , L1189 , L1212 , L1213 , SCMPDS_2:49
.= ( C290 . D367 ) by SCMPDS_5:15;
thus L1221: ( ( IExec (D373 , C291 , C290) ) . D367 ) = ( ( Exec (D372 , D378) ) . D367 ) by L1209 , SCMPDS_5:42
.= ( C290 . D367 ) by L1220 , L1219 , SCMPDS_2:48;
L1222: D376 = ( intpos ( D370 + C281 ) ) by L1201 , SCMP_GCD:1;
L1223: ( abs ( ( C287 . D367 ) + C281 ) ) = ( D370 + C281 ) by L1222 , XTUPLE_0:1;
L1224: ( abs ( ( D377 . D367 ) + C282 ) ) <> ( abs ( ( C287 . D367 ) + C281 ) ) by L1223 , L1184 , L1213;
L1225: ( DataLoc (( D377 . D367 ) , C282) ) <> D376 by L1224 , XTUPLE_0:1;
L1226: ( DataLoc (( D378 . D369 ) , ( 0 )) ) = ( intpos ( C284 + (( 0 ) qua Nat) ) ) by L1216 , SCMP_GCD:1;
L1227: ( abs ( ( D378 . D369 ) + (( 0 ) qua Nat) ) ) = ( C284 + (( 0 ) qua Nat) ) by L1226 , XTUPLE_0:1;
L1228: ( abs ( ( D378 . D369 ) + (( 0 ) qua Nat) ) ) <> ( abs ( ( C287 . D367 ) + C281 ) ) by L1227 , L1186 , L1187 , L1195 , L1223 , XXREAL_0:2;
L1229: ( DataLoc (( D378 . D369 ) , ( 0 )) ) <> D376 by L1228 , XTUPLE_0:1;
thus L1230: ( ( IExec (D373 , C291 , C290) ) . D376 ) = ( ( Exec (D372 , D378) ) . D376 ) by L1209 , SCMPDS_5:42
.= ( D378 . D376 ) by L1229 , SCMPDS_2:48
.= ( D377 . D376 ) by L1225 , SCMPDS_2:49
.= ( C290 . D376 ) by SCMPDS_5:15;
thus L1231: (D373 is_closed_on C290 , C291 & D373 is_halting_on C290 , C291) by SCMPDS_6:20 , SCMPDS_6:21;
L1232: ( ( IExec (D373 , C291 , ( Initialize C290 )) ) . D369 ) = ( ( Exec (D372 , D378) ) . D369 ) by SCMPDS_5:42
.= ( C290 . D369 ) by L1185 , L1188 , L1214 , L1226 , SCMPDS_2:48;
let C292 being Int_position;
assume L1233: C292 in { D367 , D369 };
per cases  by L1233 , TARSKI:def 2;
suppose L1234: C292 = D367;

thus L1235: ( ( IExec (D373 , C291 , C290) ) . C292 ) = ( C290 . C292 ) by L1234 , L1221;
end;
suppose L1236: C292 = D369;

thus L1237: ( ( IExec (D373 , C291 , C290) ) . C292 ) = ( C290 . C292 ) by L1236 , L1232 , MEMSTR_0:44;
end;
end;
L1239: D375 = ( intpos ( D370 + C282 ) ) by SCMP_GCD:1;
set D379 = C287;
set D380 = ( Exec (D371 , D379) );
set D381 = ( AddTo (D367 , C281 , ( - 1 )) );
set D382 = ( IExec (( D373 ';' D381 ) , C289 , C287) );
set D383 = C289;
set D384 = ( Del (C288 , 1) );
set D385 = ( IExec (D373 , C289 , C287) );
L1240: ( DataLoc (( D379 . D367 ) , C282) ) = ( intpos ( D370 + C282 ) ) by L1201 , SCMP_GCD:1;
L1241: ( abs ( ( D379 . D367 ) + C282 ) ) = ( D370 + C282 ) by L1240 , XTUPLE_0:1;
L1242: ( D380 . D367 ) = ( C287 . D367 ) by L1183 , L1189 , L1201 , SCMPDS_2:49;
L1243: ( D380 . D369 ) = ( C287 . D369 ) by L1185 , L1187 , L1189 , L1201 , SCMPDS_2:49;
L1244: ( DataLoc (( D380 . D369 ) , ( 0 )) ) = ( intpos ( C284 + (( 0 ) qua Nat) ) ) by L1243 , L1202 , SCMP_GCD:1;
L1245: ( abs ( ( D380 . D369 ) + (( 0 ) qua Nat) ) ) = ( C284 + (( 0 ) qua Nat) ) by L1244 , XTUPLE_0:1;
L1246: ( abs ( ( D380 . D369 ) + (( 0 ) qua Nat) ) ) <> C280 by L1245 , L1186 , L1187 , L1194 , XXREAL_0:2;
L1247: ( DataLoc (( D380 . D369 ) , ( 0 )) ) <> D367 by L1246 , XTUPLE_0:1;
L1248: ( D385 . D367 ) = ( ( Exec (D372 , D380) ) . D367 ) by SCMPDS_5:42
.= ( C287 . D367 ) by L1242 , L1247 , SCMPDS_2:48;
L1249: ( DataLoc (( D385 . D367 ) , C281) ) = ( intpos ( D370 + C281 ) ) by L1248 , L1201 , SCMP_GCD:1;
L1250: ( abs ( ( D385 . D367 ) + C281 ) ) = ( D370 + C281 ) by L1249 , XTUPLE_0:1;
L1251: C284 <> ( abs ( ( D385 . D367 ) + C281 ) ) by L1250 , L1186 , L1187 , L1195 , XXREAL_0:2;
L1252: D368 <> ( DataLoc (( D385 . D367 ) , C281) ) by L1251 , XTUPLE_0:1;
L1253: ( C288 . ( (( 0 ) qua Nat) + 1 ) ) = ( D379 . ( DataLoc (( D379 . D368 ) , ( 0 )) ) ) by L1205 , L1206;
L1254: ( D370 + C282 ) <> ( abs ( ( D385 . D367 ) + C281 ) ) by L1184 , L1250;
L1255: D375 <> ( DataLoc (( D385 . D367 ) , C281) ) by L1254 , L1239 , XTUPLE_0:1;
L1256: ( D385 . D375 ) = ( ( Exec (D372 , D380) ) . D375 ) by SCMPDS_5:42
.= ( D380 . D375 ) by L1188 , L1189 , L1244 , SCMPDS_2:48
.= ( ( C287 . D375 ) + ( C288 . 1 ) ) by L1201 , L1253 , SCMPDS_2:49;
L1257: ( D382 . D375 ) = ( ( Exec (D381 , D385) ) . D375 ) by SCMPDS_5:41
.= ( ( C288 . 1 ) + ( C287 . D375 ) ) by L1255 , L1256 , SCMPDS_2:48;
L1258: ( D370 + C281 ) <> C280 by L1183 , NAT_1:11;
L1259: ( abs ( D370 + C281 ) ) <> C280 by L1258 , ABSVALUE:def 1;
L1260: ( DataLoc (( C287 . D367 ) , C281) ) <> D367 by L1259 , L1201 , XTUPLE_0:1;
L1261: ( D382 . D368 ) = ( ( Exec (D381 , D385) ) . D368 ) by SCMPDS_5:41
.= ( D385 . D368 ) by L1252 , SCMPDS_2:48
.= ( ( Exec (D372 , D380) ) . D368 ) by SCMPDS_5:42
.= ( ( D380 . D368 ) + 1 ) by L1244 , SCMPDS_2:48
.= ( ( C287 . D368 ) + 1 ) by L1188 , L1189 , L1201 , SCMPDS_2:49;
L1262: ( C287 . D368 ) < ( D382 . D368 ) by L1261 , XREAL_1:29;
L1263: C284 < ( D382 . D368 ) by L1262 , L1203 , XXREAL_0:2;
L1264: 1 <= ( C286 + 1 ) by NAT_1:11;
L1265: 1 in ( Seg ( C286 + 1 ) ) by L1264 , FINSEQ_1:1;
L1266: 1 in ( dom C288 ) by L1265 , L1205 , FINSEQ_1:def 3;
L1267: ( ( len D384 ) + 1 ) = ( len C288 ) by L1266 , WSIERP_1:def 1;
L1268: ( D382 . D368 ) = ( ( Initialize D382 ) . D368 ) by SCMPDS_5:15;
L1269: ( D382 . ( DataLoc (( D382 . D367 ) , C281) ) ) = ( ( Initialize D382 ) . ( DataLoc (( D382 . D367 ) , C281) ) ) by SCMPDS_5:15;
L1270: ( D382 . D369 ) = ( ( Initialize D382 ) . D369 ) by SCMPDS_5:15;
L1271: ( D382 . D367 ) = ( ( Initialize D382 ) . D367 ) by SCMPDS_5:15;
L1272: (for B272 being (Element of ( NAT )) holds (B272 < ( len D384 ) implies ( D384 . ( B272 + 1 ) ) = ( ( Initialize D382 ) . ( DataLoc (( ( Initialize D382 ) . D368 ) , B272) ) )))
proof
reconsider D386 = ( C287 . D368 ) as (Element of ( NAT )) by L1203 , INT_1:3;
let C293 being (Element of ( NAT ));
set D387 = ( DataLoc (( ( Initialize D382 ) . D368 ) , C293) );
assume L1273: C293 < ( len D384 );
L1274: ( C293 + 1 ) < ( ( len D384 ) + 1 ) by L1273 , XREAL_1:6;
L1275: ( D382 . D387 ) = ( ( Initialize D382 ) . D387 ) by SCMPDS_5:15;
L1276: D387 = ( intpos ( ( D386 + 1 ) + C293 ) ) by L1261 , L1268 , SCMP_GCD:1
.= ( intpos ( D386 + ( 1 + C293 ) ) );
L1277: ( abs ( ( D382 . D368 ) + C293 ) ) = ( D386 + ( 1 + C293 ) ) by L1276 , L1268 , XTUPLE_0:1;
L1278: ( abs ( ( D380 . D369 ) + (( 0 ) qua Nat) ) ) <> ( abs ( ( D382 . D368 ) + C293 ) ) by L1277 , L1203 , L1245 , NAT_1:11;
L1279: ( DataLoc (( D380 . D369 ) , ( 0 )) ) <> D387 by L1278 , L1268 , XTUPLE_0:1;
L1280: D386 <= ( D386 + ( 1 + C293 ) ) by NAT_1:11;
L1281: ( abs ( ( D379 . D367 ) + C282 ) ) <> ( abs ( ( D382 . D368 ) + C293 ) ) by L1280 , L1192 , L1203 , L1241 , L1277 , XXREAL_0:2;
L1282: ( DataLoc (( D379 . D367 ) , C282) ) <> D387 by L1281 , L1268 , XTUPLE_0:1;
L1283: ( D370 + C281 ) < D386 by L1197 , L1203 , XXREAL_0:2;
L1284: ( abs ( ( D382 . D368 ) + C293 ) ) <> ( abs ( ( D385 . D367 ) + C281 ) ) by L1283 , L1250 , L1277 , NAT_1:11;
L1285: D387 <> ( DataLoc (( D385 . D367 ) , C281) ) by L1284 , L1268 , XTUPLE_0:1;
L1286: ( D382 . D387 ) = ( ( Exec (D381 , D385) ) . D387 ) by SCMPDS_5:41
.= ( D385 . D387 ) by L1285 , SCMPDS_2:48
.= ( ( Exec (D372 , D380) ) . D387 ) by SCMPDS_5:42
.= ( D380 . D387 ) by L1279 , SCMPDS_2:48
.= ( C287 . D387 ) by L1282 , SCMPDS_2:49;
L1287: ( (( 0 ) qua Nat) + 1 ) <= ( C293 + 1 ) by XREAL_1:6;
thus L1288: ( D384 . ( C293 + 1 ) ) = ( C288 . ( ( C293 + 1 ) + 1 ) ) by L1287 , L1266 , WSIERP_1:def 1
.= ( C287 . ( DataLoc (( C287 . D368 ) , ( C293 + 1 )) ) ) by L1206 , L1267 , L1274
.= ( ( Initialize D382 ) . D387 ) by L1277 , L1286 , L1275 , SCMPDS_5:15;
end;
L1289: ( abs ( ( D379 . D367 ) + C282 ) ) <> ( D370 + C281 ) by L1184 , L1241;
L1290: ( DataLoc (( D379 . D367 ) , C282) ) <> ( intpos ( D370 + C281 ) ) by L1289 , XTUPLE_0:1;
L1291: ( abs ( ( D380 . D369 ) + (( 0 ) qua Nat) ) ) <> ( D370 + C281 ) by L1186 , L1187 , L1195 , L1245 , XXREAL_0:2;
L1292: ( DataLoc (( D380 . D369 ) , ( 0 )) ) <> ( intpos ( D370 + C281 ) ) by L1291 , XTUPLE_0:1;
L1293: ( D385 . ( intpos ( D370 + C281 ) ) ) = ( ( Exec (D372 , D380) ) . ( intpos ( D370 + C281 ) ) ) by SCMPDS_5:42
.= ( D380 . ( intpos ( D370 + C281 ) ) ) by L1292 , SCMPDS_2:48
.= ( C287 . ( intpos ( D370 + C281 ) ) ) by L1290 , SCMPDS_2:49
.= ( C286 + 1 ) by L1201 , L1204 , L1205 , SCMP_GCD:1;
L1294: ( abs ( ( D385 . D367 ) + C281 ) ) <> C280 by L1183 , L1250 , NAT_1:11;
L1295: ( DataLoc (( D385 . D367 ) , C281) ) <> D367 by L1294 , XTUPLE_0:1;
L1296: ( D382 . D367 ) = ( ( Exec (D381 , D385) ) . D367 ) by SCMPDS_5:41
.= ( C279 . D367 ) by L1201 , L1248 , L1295 , SCMPDS_2:48;
L1297: ( DataLoc (( D382 . D367 ) , C281) ) = ( intpos ( D370 + C281 ) ) by L1296 , SCMP_GCD:1;
L1298: ( D382 . ( DataLoc (( D382 . D367 ) , C281) ) ) = ( ( Exec (D381 , D385) ) . ( intpos ( D370 + C281 ) ) ) by L1297 , SCMPDS_5:41
.= ( ( D385 . ( intpos ( D370 + C281 ) ) ) + ( - 1 ) ) by L1249 , SCMPDS_2:48
.= ( len D384 ) by L1205 , L1267 , L1293;
L1299: C283 <> ( abs ( ( D385 . D367 ) + C281 ) ) by L1184 , L1186 , L1250 , XREAL_1:6;
L1300: D369 <> ( DataLoc (( D385 . D367 ) , C281) ) by L1299 , XTUPLE_0:1;
L1301: ( D382 . D369 ) = ( ( Exec (D381 , D385) ) . D369 ) by SCMPDS_5:41
.= ( D385 . D369 ) by L1300 , SCMPDS_2:48
.= ( ( Exec (D372 , D380) ) . D369 ) by SCMPDS_5:42
.= ( D380 . D369 ) by L1185 , L1188 , L1244 , SCMPDS_2:48
.= C284 by L1202 , L1185 , L1187 , L1189 , L1201 , SCMPDS_2:49;
L1302: 1 <= ( len C288 ) by L1205 , NAT_1:11;
L1303: 1 in ( dom C288 ) by L1302 , FINSEQ_3:25;
L1304: ( D370 + C281 ) <> C283 by L1184 , L1186 , XREAL_1:6;
L1305: ( abs ( D370 + C281 ) ) <> C283 by L1304 , ABSVALUE:def 1;
L1306: ( DataLoc (( C279 . D367 ) , C281) ) <> D369 by L1305 , XTUPLE_0:1;
L1307: (not ( DataLoc (( C287 . D367 ) , C281) ) in { D367 , D369 }) by L1306 , L1201 , L1260 , TARSKI:def 2;
thus L1308: ( ( IExec (D374 , C289 , C287) ) . D375 ) = ( ( IExec (D374 , D383 , ( Initialize D382 )) ) . D375 ) by L1307 , L1204 , L1205 , L1260 , L1208 , L943
.= ( ( Sum D384 ) + ( ( Initialize D382 ) . D375 ) ) by L1199 , L1205 , L1296 , L1267 , L1298 , L1301 , L1263 , L1272 , L1268 , L1269 , L1270 , L1271
.= ( ( Sum D384 ) + ( D382 . D375 ) ) by SCMPDS_5:15
.= ( ( ( Sum D384 ) + ( C288 . 1 ) ) + ( C287 . D375 ) ) by L1257
.= ( ( Sum C288 ) + ( C287 . D375 ) ) by L1303 , L1207 , WSIERP_1:20;
end;
thus L1309: S7[ ( C286 + 1 ) ] by L1200;
end;
L1310:
now
let C294 being ( 0 ) -started (State of ( SCMPDS ));
let C295 being (FinSequence of ( NAT ));
assume that
L1311: ( C294 . D367 ) = ( C279 . D367 )
and
L1312: ( C294 . D369 ) = C284
and
L1313: C284 < ( C294 . D368 )
and
L1314: ( len C295 ) = ( C294 . ( DataLoc (( C294 . D367 ) , C281) ) )
and
L1315: ( len C295 ) = ( 0 )
and
L1316: (for B273 being (Element of ( NAT )) holds (B273 < ( len C295 ) implies ( C295 . ( B273 + 1 ) ) = ( C294 . ( DataLoc (( C294 . D368 ) , B273) ) )));
L1317: ( Initialize C294 ) = C294 by MEMSTR_0:44;
L1318: C295 = ( <*> ( NAT ) ) by L1315;
thus L1319: (for R22 being (Instruction-Sequence of ( SCMPDS )) holds ( ( IExec (D374 , R22 , C294) ) . D375 ) = ( ( Sum C295 ) + ( C294 . D375 ) )) by L1318 , L1314 , L834 , L1317 , RVSUM_1:72;
end;
L1320: S7[ ( 0 ) ] by L1310;
L1321: (for B274 being (Element of ( NAT )) holds S7[ B274 ]) from NAT_1:sch 1(L1320 , L1198);
thus L1322: ( ( IExec (D374 , R19 , C279) ) . D375 ) = ( ( Sum C285 ) + (( 0 ) qua Nat) ) by L1321 , L1185 , L1188 , L1189 , L1190 , L1191
.= ( Sum C285 );
end;
theorem
L1323: (for R19 being (Instruction-Sequence of ( SCMPDS )) holds (for B275 being ( 0 ) -started (State of ( SCMPDS )) holds (for B276 , B277 , B278 , B279 , B280 being (Element of ( NAT )) holds (for B281 being (FinSequence of ( NAT )) holds ((( B275 . ( intpos B276 ) ) > B276 & B277 < B278 & ( ( B275 . ( intpos B276 ) ) + B278 ) < B279 & B279 < B280 & B280 < ( B275 . ( intpos B280 ) ) & ( len B281 ) = ( B275 . ( DataLoc (( B275 . ( intpos B276 ) ) , B277) ) ) & (for B282 being (Element of ( NAT )) holds (B282 < ( len B281 ) implies ( B281 . ( B282 + 1 ) ) = ( B275 . ( DataLoc (( B275 . ( intpos B280 ) ) , B282) ) )))) implies ( ( IExec (( sum (B276 , B277 , B278 , B279 , B280) ) , R19 , B275) ) . ( DataLoc (( B275 . ( intpos B276 ) ) , B278) ) ) = ( Sum B281 ))))))
proof
let R19 being (Instruction-Sequence of ( SCMPDS ));
let C296 being ( 0 ) -started (State of ( SCMPDS ));
let C297 , C298 , C299 , C300 , C301 being (Element of ( NAT ));
let C302 being (FinSequence of ( NAT ));
set D388 = ( intpos C297 );
set D389 = ( intpos C301 );
set D390 = ( intpos C300 );
assume that
L1324: ( C296 . D388 ) > C297
and
L1325: C298 < C299
and
L1326: ( ( C296 . D388 ) + C299 ) < C300
and
L1327: C300 < C301
and
L1328: C301 < ( C296 . D389 )
and
L1329: ( len C302 ) = ( C296 . ( DataLoc (( C296 . D388 ) , C298) ) )
and
L1330: (for B283 being (Element of ( NAT )) holds (B283 < ( len C302 ) implies ( C302 . ( B283 + 1 ) ) = ( C296 . ( DataLoc (( C296 . D389 ) , B283) ) )));
reconsider D391 = ( C296 . D388 ) as (Element of ( NAT )) by L1324 , INT_1:3;
L1331: D389 <> D390 by L1327 , XTUPLE_0:1;
set D392 = ( (D388 , C299) := ( 0 ) );
set D393 = ( D390 := C301 );
set D394 = ( D392 ';' D393 );
set D395 = ( AddTo (D388 , C299 , D389 , ( 0 )) );
set D396 = ( AddTo (D390 , ( 0 ) , 1) );
set D397 = ( for-down (D388 , C298 , 1 , ( D395 ';' D396 )) );
set D398 = ( IExec (D394 , R19 , C296) );
set D399 = R19;
set D400 = C296;
set D401 = ( Exec (D392 , D400) );
set D402 = ( DataLoc (( C296 . D388 ) , C299) );
set D403 = ( DataLoc (( D398 . D388 ) , C299) );
L1332: ( DataLoc (( D400 . D388 ) , C299) ) = ( intpos ( D391 + C299 ) ) by SCMP_GCD:1;
L1333: ( abs ( ( D400 . D388 ) + C299 ) ) = ( D391 + C299 ) by L1332 , XTUPLE_0:1;
L1334: ( abs ( ( D400 . D388 ) + C299 ) ) <> C297 by L1333 , L1324 , NAT_1:12;
L1335: ( DataLoc (( D400 . D388 ) , C299) ) <> D388 by L1334 , XTUPLE_0:1;
L1336: ( DataLoc (( D400 . D388 ) , C299) ) <> D389 by L1326 , L1327 , L1332 , XTUPLE_0:1;
L1337: ( D398 . D389 ) = ( ( Exec (D393 , D401) ) . D389 ) by SCMPDS_5:42
.= ( D401 . D389 ) by L1331 , SCMPDS_2:45
.= ( C296 . D389 ) by L1336 , SCMPDS_2:46;
L1338: D391 <= ( D391 + C299 ) by NAT_1:12;
L1339: C297 <> C300 by L1338 , L1324 , L1326 , XXREAL_0:2;
L1340: D388 <> D390 by L1339 , XTUPLE_0:1;
L1341: ( intpos ( D391 + C299 ) ) <> D390 by L1326 , XTUPLE_0:1;
L1342: ( D398 . D388 ) = ( ( Exec (D393 , D401) ) . D388 ) by SCMPDS_5:42
.= ( D401 . D388 ) by L1340 , SCMPDS_2:45
.= D391 by L1335 , SCMPDS_2:46;
L1343: ( D398 . ( DataLoc (( D398 . D388 ) , C299) ) ) = ( D398 . ( intpos ( D391 + C299 ) ) ) by L1342 , SCMP_GCD:1
.= ( ( Exec (D393 , D401) ) . ( intpos ( D391 + C299 ) ) ) by SCMPDS_5:42
.= ( D401 . ( intpos ( D391 + C299 ) ) ) by L1341 , SCMPDS_2:45
.= ( 0 ) by L1332 , SCMPDS_2:46;
L1344: ( D391 + C299 ) < C301 by L1326 , L1327 , XXREAL_0:2;
L1345:
now
reconsider D404 = ( C296 . D389 ) as (Element of ( NAT )) by L1328 , INT_1:3;
let C303 being (Element of ( NAT ));
assume L1346: C303 < ( len C302 );
L1347: C300 < D404 by L1327 , L1328 , XXREAL_0:2;
L1348: ( D404 + C303 ) <> C300 by L1347 , NAT_1:11;
L1349: ( intpos ( D404 + C303 ) ) <> D390 by L1348 , XTUPLE_0:1;
L1350: D404 <= ( D404 + C303 ) by NAT_1:11;
L1351: ( abs ( ( D400 . D388 ) + C299 ) ) <> ( D404 + C303 ) by L1350 , L1328 , L1333 , L1344 , XXREAL_0:2;
L1352: ( DataLoc (( D400 . D388 ) , C299) ) <> ( intpos ( D404 + C303 ) ) by L1351 , XTUPLE_0:1;
thus L1353: ( ( Initialize D398 ) . ( DataLoc (( D398 . D389 ) , C303) ) ) = ( D398 . ( DataLoc (( D398 . D389 ) , C303) ) ) by SCMPDS_5:15
.= ( D398 . ( intpos ( D404 + C303 ) ) ) by L1337 , SCMP_GCD:1
.= ( ( Exec (D393 , D401) ) . ( intpos ( D404 + C303 ) ) ) by SCMPDS_5:42
.= ( D401 . ( intpos ( D404 + C303 ) ) ) by L1349 , SCMPDS_2:45
.= ( C296 . ( intpos ( D404 + C303 ) ) ) by L1352 , SCMPDS_2:46
.= ( C296 . ( DataLoc (( C296 . D389 ) , C303) ) ) by SCMP_GCD:1
.= ( C302 . ( C303 + 1 ) ) by L1330 , L1346;
end;
L1354: ( abs ( ( D400 . D388 ) + C299 ) ) <> ( D391 + C298 ) by L1325 , L1333;
L1355: ( DataLoc (( D400 . D388 ) , C299) ) <> ( intpos ( D391 + C298 ) ) by L1354 , XTUPLE_0:1;
L1356: ( D391 + C298 ) <> C300 by L1325 , L1326 , XREAL_1:6;
L1357: ( intpos ( D391 + C298 ) ) <> D390 by L1356 , XTUPLE_0:1;
L1358: D394 is_halting_on C296 , R19 by SCMPDS_6:21;
L1359: D394 is_closed_on C296 , R19 by SCMPDS_6:20;
L1360: ( D398 . D390 ) = ( ( Initialize D398 ) . D390 ) by SCMPDS_5:15;
L1361: ( D398 . D388 ) = ( ( Initialize D398 ) . D388 ) by SCMPDS_5:15;
L1362: ( D398 . D389 ) = ( ( Initialize D398 ) . D389 ) by SCMPDS_5:15;
L1363: ( D398 . D390 ) = ( ( Exec (D393 , D401) ) . D390 ) by SCMPDS_5:42
.= C301 by SCMPDS_2:45;
L1364: D397 is_halting_on ( Initialize D398 ) , D399 by L1363 , L1324 , L1325 , L1326 , L1327 , L1328 , L1342 , L1337 , L1132 , L1360 , L1361 , L1362;
L1365: D397 is_halting_on D398 , D399 by L1364 , SCMPDS_6:126;
L1366: ( D398 . ( DataLoc (( D398 . D388 ) , C298) ) ) = ( D398 . ( intpos ( D391 + C298 ) ) ) by L1342 , SCMP_GCD:1
.= ( ( Exec (D393 , D401) ) . ( intpos ( D391 + C298 ) ) ) by SCMPDS_5:42
.= ( D401 . ( intpos ( D391 + C298 ) ) ) by L1357 , SCMPDS_2:45
.= ( C296 . ( intpos ( D391 + C298 ) ) ) by L1355 , SCMPDS_2:46
.= ( len C302 ) by L1329 , SCMP_GCD:1;
L1367: ( D398 . ( DataLoc (( D398 . D388 ) , C299) ) ) = ( ( Initialize D398 ) . ( DataLoc (( D398 . D388 ) , C299) ) ) by SCMPDS_5:15;
L1368: ( D398 . ( DataLoc (( D398 . D388 ) , C298) ) ) = ( ( Initialize D398 ) . ( DataLoc (( D398 . D388 ) , C298) ) ) by SCMPDS_5:15;
L1369: D397 is_closed_on ( Initialize D398 ) , D399 by L1324 , L1325 , L1326 , L1327 , L1328 , L1342 , L1363 , L1337 , L1132 , L1360 , L1361 , L1362;
L1370: D397 is_closed_on D398 , D399 by L1369 , SCMPDS_6:125;
thus L1371: ( ( IExec (( sum (C297 , C298 , C299 , C300 , C301) ) , R19 , C296) ) . D402 ) = ( ( IExec (D397 , D399 , ( Initialize D398 )) ) . D403 ) by L1370 , L1342 , L1359 , L1358 , L1365 , L443
.= ( Sum C302 ) by L1324 , L1325 , L1326 , L1327 , L1328 , L1342 , L1363 , L1337 , L1343 , L1366 , L1345 , L1182 , L1360 , L1361 , L1362 , L1367 , L1368;
end;
