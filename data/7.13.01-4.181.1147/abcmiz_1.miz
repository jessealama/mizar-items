:: Towards the construction of a model of Mizar concepts
::  by Grzegorz Bancerek
::
:: Received April 21, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, NAT_1, SUBSET_1, FUNCT_1, TARSKI, CARD_3, RELAT_1,
      XBOOLE_0, STRUCT_0, CATALG_1, PBOOLE, MSATERM, FACIRC_1, MSUALG_1,
      ZFMISC_1, ZF_MODEL, FUNCOP_1, CARD_1, FINSEQ_1, TREES_3, TREES_4,
      MARGREL1, MSAFREE, CLASSES1, SETFAM_1, FINSET_1, QC_LANG3, ARYTM_3,
      XXREAL_0, ORDINAL1, MCART_1, FINSEQ_2, ORDINAL4, PARTFUN1, ABCMIZ_0,
      FUNCT_2, FUNCT_4, ZF_LANG1, CAT_3, TREES_2, MSUALG_2, MEMBER_1, AOFA_000,
      CARD_5, ORDERS_2, YELLOW_1, ARYTM_0, LATTICE3, EQREL_1, LATTICES,
      YELLOW_0, ORDINAL2, WAYBEL_0, ASYMPT_0, LANG1, TDGROUP, DTCONSTR,
      BINOP_1, MATRIX_7, FUNCT_7, ABCMIZ_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, DOMAIN_1, SETFAM_1, RELAT_1,
      FUNCT_1, RELSET_1, BINOP_1, PARTFUN1, FACIRC_1, ENUMSET1, FUNCT_2,
      PARTIT_2, FUNCT_4, FUNCOP_1, XXREAL_0, ORDINAL1, NAT_1, MCART_1,
      FINSET_1, CARD_1, NUMBERS, CARD_3, FINSEQ_1, FINSEQ_2, TREES_2, TREES_3,
      TREES_4, FUNCT_7, PBOOLE, MATRIX_7, XXREAL_2, STRUCT_0, LANG1, CLASSES1,
      ORDERS_2, LATTICE3, YELLOW_0, WAYBEL_0, YELLOW_1, YELLOW_7, DTCONSTR,
      MSUALG_1, MSUALG_2, MSAFREE, EQUATION, MSATERM, CATALG_1, MSAFREE3,
      AOFA_000, PRE_POLY;
 constructors DOMAIN_1, MATRIX_7, MSAFREE1, FUNCT_7, EQUATION, YELLOW_1,
      CATALG_1, LATTICE3, WAYBEL_0, FACIRC_1, CLASSES1, MSAFREE3, XXREAL_2,
      RELSET_1, PRE_POLY, PARTIT_2, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, XREAL_0, ORDINAL1, RELSET_1, FUNCT_1,
      FINSET_1, STRUCT_0, PBOOLE, MSUALG_1, MSUALG_2, FINSEQ_1, CARD_1,
      MSAFREE, FUNCOP_1, TREES_3, MSAFREE1, PARTFUN1, MSATERM, ORDERS_2,
      TREES_2, DTCONSTR, WAYBEL_0, YELLOW_1, LATTICE3, MEMBERED, RELAT_1,
      INDEX_1, INSTALG1, MSAFREE3, FACIRC_1, XXREAL_2, CLASSES1, FINSEQ_2,
      PARTIT_2, XTUPLE_0;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, RELAT_1, FUNCT_1, FACIRC_1, FINSEQ_1, FINSEQ_2,
      LANG1, LATTICE3, MSAFREE, MSAFREE3, CARD_3, PBOOLE, TREES_3, MSUALG_1,
      WAYBEL_0, XTUPLE_0;
 theorems TARSKI, XBOOLE_0, XBOOLE_1, TREES_1, XXREAL_0, ZFMISC_1, FUNCT_1,
      FUNCT_2, FINSEQ_1, FINSEQ_2, SUBSET_1, ENUMSET1, FUNCT_4, PROB_2, LANG1,
      MATRIX_7, NAT_1, MCART_1, PBOOLE, FINSET_1, RELAT_1, RELSET_1, ORDINAL3,
      CARD_1, CARD_3, CARD_5, CLASSES1, ORDINAL1, SETFAM_1, MSUALG_2, TREES_4,
      FINSEQ_3, FUNCOP_1, MSAFREE, MSATERM, MSAFREE3, PARTFUN1, LATTICE3,
      YELLOW_0, WAYBEL_0, YELLOW_1, YELLOW_7, DTCONSTR, MSAFREE1, FUNCT_7,
      XXREAL_2, CARD_2, XTUPLE_0;
 schemes XBOOLE_0, FUNCT_1, NAT_1, FRAENKEL, PBOOLE, MSATERM, DTCONSTR,
      CLASSES1, FUNCT_2;

begin
theorem
L1: (for R5 being set holds (for B1 being Function holds ( B1 . R5 ) c= ( Union B1 )))
proof
let R5 being set;
let C1 being Function;
L2: (R5 in ( dom C1 ) or (not R5 in ( dom C1 )));
L3: (( C1 . R5 ) in ( rng C1 ) or ( C1 . R5 ) = ( {} )) by L2 , FUNCT_1:3 , FUNCT_1:def 2;
thus L4: thesis by L3 , XBOOLE_1:2 , ZFMISC_1:74;
end;
theorem
L5: (for R5 being set holds (for B2 being Function holds (( Union B2 ) = ( {} ) implies ( B2 . R5 ) = ( {} )))) by L1 , XBOOLE_1:3;
theorem
L6: (for B3 being Function holds (for B4 , B5 being set holds (B3 = [ B4 , B5 ] implies B4 = B5)))
proof
let C2 being Function;
let C3 , C4 being set;
assume L7: C2 = [ C3 , C4 ];
L8: { C3 } in C2 by L7 , TARSKI:def 2;
L9: { C3 , C4 } in C2 by L7 , TARSKI:def 2;
consider C5 , C6 being set such that L10: { C3 } = [ C5 , C6 ] by L8 , RELAT_1:def 1;
L11: { C5 } = { C5 , C6 } by L10 , ZFMISC_1:5;
L12: C3 = { C5 } by L10 , ZFMISC_1:4;
consider C7 , C8 being set such that L13: { C3 , C4 } = [ C7 , C8 ] by L9 , RELAT_1:def 1;
L14: ((C3 = { C7 } & C4 = { C7 , C8 }) or (C3 = { C7 , C8 } & C4 = { C7 })) by L13 , ZFMISC_1:6;
L15: C7 = C5 by L14 , L11 , L12 , ZFMISC_1:4;
thus L16: thesis by L15 , L8 , L9 , L10 , L11 , L13 , L14 , FUNCT_1:def 1;
end;
theorem
L17: (for R3 being set holds (for R4 being set holds ( ( id R3 ) .: R4 ) c= R4))
proof
let R3 being set;
let R4 being set;
let C9 being set;
assume L18: C9 in ( ( id R3 ) .: R4 );
L19: (ex B6 being set st ([ B6 , C9 ] in ( id R3 ) & B6 in R4)) by L18 , RELAT_1:def 13;
thus L20: thesis by L19 , RELAT_1:def 10;
end;
theorem
L21: (for B7 being non  void Signature holds (for B8 being  non-empty (ManySortedSet of (the carrier of B7)) holds (for B9 being (Term of B7 , B8) holds B9 is non  pair)))
proof
let C10 being non  void Signature;
let C11 being  non-empty (ManySortedSet of (the carrier of C10));
let C12 being (Term of C10 , C11);
given C13 , C14 being set such that
L22: C12 = [ C13 , C14 ];

L23: ((ex B10 being (SortSymbol of C10) st (ex B11 being (Element of ( C11 . B10 )) st ( C12 . ( {} ) ) = [ B11 , B10 ])) or ( C12 . ( {} ) ) in [: (the carrier' of C10) , { (the carrier of C10) } :]) by MSATERM:2;
L24: ((ex B12 being (SortSymbol of C10) st (ex B13 being (Element of ( C11 . B12 )) st ( C12 . ( {} ) ) = [ B13 , B12 ])) or (ex B14 , B15 being set st (B14 in (the carrier' of C10) & B15 in { (the carrier of C10) } & ( C12 . ( {} ) ) = [ B14 , B15 ]))) by L23 , ZFMISC_1:def 2;
L25: { ( {} ) } <> { ( {} ) , ( C12 . ( {} ) ) } by L24 , ZFMISC_1:5;
L26: [ ( {} ) , ( C12 . ( {} ) ) ] <> { C13 } by L25 , ZFMISC_1:5;
L27: ( {} ) in ( dom C12 ) by TREES_1:22;
L28: [ ( {} ) , ( C12 . ( {} ) ) ] in C12 by L27 , FUNCT_1:def 2;
L29: [ ( {} ) , ( C12 . ( {} ) ) ] = { C13 , C14 } by L28 , L22 , L26 , TARSKI:def 2;
L30: C13 = C14 by L22 , L6;
thus L31: thesis by L30 , L26 , L29 , ENUMSET1:29;
end;
registration
let C15 being non  void Signature;
let C16 being non  empty-yielding (ManySortedSet of (the carrier of C15));
cluster  -> non  pair for (Element of ( Free (C15 , C16) ));
coherence
proof
let C17 being (Element of ( Free (C15 , C16) ));
L32: C17 is (Term of C15 , ( C16 \/ ( (the carrier of C15) --> { ( 0 ) } ) )) by MSAFREE3:8;
thus L33: thesis by L32 , L21;
end;
end;
theorem
L35: (for B16 , B17 , B18 being set holds ((B16 in ( { B18 } * ) & B17 in ( { B18 } * ) & ( card B16 ) = ( card B17 )) implies B16 = B17))
proof
let C18 , C19 , C20 being set;
assume that
L36: C18 in ( { C20 } * )
and
L37: C19 in ( { C20 } * )
and
L38: ( card C18 ) = ( card C19 );
reconsider D1 = C18 , D2 = C19 as (FinSequence of { C20 }) by L36 , L37 , FINSEQ_1:def 11;
L39: ( dom D1 ) = ( Seg ( len D1 ) ) by FINSEQ_1:def 3
.= ( dom D2 ) by L38 , FINSEQ_1:def 3;
L40:
now
let C21 being Nat;
assume L41: C21 in ( dom D1 );
L42: ( D1 . C21 ) in ( rng D1 ) by L41 , FUNCT_1:def 3;
L43: ( D2 . C21 ) in ( rng D2 ) by L39 , L41 , FUNCT_1:def 3;
thus L44: ( D1 . C21 ) = C20 by L42 , TARSKI:def 1
.= ( D2 . C21 ) by L43 , TARSKI:def 1;
end;
thus L45: thesis by L40 , L39 , FINSEQ_1:13;
end;
definition
let C22 being non  void Signature;
let C23 being MSAlgebra over C22;
mode Subset of C23
 is (Subset of ( Union (the Sorts of C23) ));
mode FinSequence of C23
 is (FinSequence of ( Union (the Sorts of C23) ));
end;
registration
let C24 being non  void Signature;
let C25 being non  empty-yielding (ManySortedSet of C24);
cluster  ->  DTree-yielding for (FinSequence of ( Free (C24 , C25) ));
coherence
proof
let C26 being (FinSequence of ( Free (C24 , C25) ));
let C27 being set;
assume L47: C27 in ( rng C26 );
thus L48: thesis by L47;
end;
end;
theorem
L50: (for B19 being non  void Signature holds (for B20 being non  empty-yielding (ManySortedSet of (the carrier of B19)) holds (for B21 being (Element of ( Free (B19 , B20) )) holds ((ex B22 being (SortSymbol of B19) st (ex B23 being set st (B21 = ( root-tree [ B23 , B22 ] ) & B23 in ( B20 . B22 )))) or (ex B24 being (OperSymbol of B19) st (ex B25 being (FinSequence of ( Free (B19 , B20) )) st (B21 = ( [ B24 , (the carrier of B19) ] -tree B25 ) & ( len B25 ) = ( len ( the_arity_of B24 ) ) & B25 is  DTree-yielding & B25 is (ArgumentSeq of ( Sym (B24 , ( B20 \/ ( (the carrier of B19) --> { ( 0 ) } ) )) )))))))))
proof
let C28 being non  void Signature;
let C29 being non  empty-yielding (ManySortedSet of (the carrier of C28));
let C30 being (Element of ( Free (C28 , C29) ));
set D3 = ( C29 \/ ( (the carrier of C28) --> { ( 0 ) } ) );
reconsider D4 = C30 as (Term of C28 , D3) by MSAFREE3:8;
defpred S1[ set ] means ($1 is (Element of ( Free (C28 , C29) )) implies ((ex B26 being (SortSymbol of C28) st (ex B27 being set st ($1 = ( root-tree [ B27 , B26 ] ) & B27 in ( C29 . B26 )))) or (ex B28 being (OperSymbol of C28) st (ex B29 being (FinSequence of ( Free (C28 , C29) )) st ($1 = ( [ B28 , (the carrier of C28) ] -tree B29 ) & ( len B29 ) = ( len ( the_arity_of B28 ) ) & B29 is  DTree-yielding & B29 is (ArgumentSeq of ( Sym (B28 , D3) )))))));
L51: (for B30 being (SortSymbol of C28) holds (for B31 being (Element of ( D3 . B30 )) holds S1[ ( root-tree [ B31 , B30 ] ) ]))
proof
let C31 being (SortSymbol of C28);
let C32 being (Element of ( D3 . C31 ));
set D5 = ( root-tree [ C32 , C31 ] );
assume L52: D5 is (Element of ( Free (C28 , C29) ));
L53: ( {} ) in ( dom D5 ) by TREES_1:22;
L54: ( D5 . ( {} ) ) in ( rng D5 ) by L53 , FUNCT_1:3;
L55: [ C32 , C31 ] in ( rng D5 ) by L54 , TREES_4:3;
L56: C32 in ( C29 . C31 ) by L55 , L52 , MSAFREE3:35;
thus L57: thesis by L56;
end;
L58: (for B32 being (OperSymbol of C28) holds (for B33 being (ArgumentSeq of ( Sym (B32 , D3) )) holds ((for B34 being (Term of C28 , D3) holds (B34 in ( rng B33 ) implies S1[ B34 ])) implies S1[ ( [ B32 , (the carrier of C28) ] -tree B33 ) ])))
proof
let C33 being (OperSymbol of C28);
let C34 being (ArgumentSeq of ( Sym (C33 , D3) ));
assume that
L59: (for B35 being (Term of C28 , D3) holds (B35 in ( rng C34 ) implies S1[ B35 ]));
set D6 = ( [ C33 , (the carrier of C28) ] -tree C34 );
assume L60: D6 is (Element of ( Free (C28 , C29) ));
consider C35 being set such that L61: C35 in ( dom (the Sorts of ( Free (C28 , C29) )) ) and L62: D6 in ( (the Sorts of ( Free (C28 , C29) )) . C35 ) by L60 , CARD_5:2;
reconsider D7 = C35 as (Element of C28) by L61;
L63: (the Sorts of ( Free (C28 , C29) )) = ( C28 -Terms (C29 , D3) ) by MSAFREE3:24;
L64: ( the_sort_of ( ( Sym (C33 , D3) ) -tree C34 ) ) = ( the_result_sort_of C33 ) by MSATERM:20;
L65: D7 = ( the_result_sort_of C33 ) by L64 , L62 , L63 , MSAFREE3:17;
L66: ( rng C34 ) c= ( Union ( C28 -Terms (C29 , D3) ) ) by L65 , L62 , L63 , MSAFREE3:19;
L67: C34 is (FinSequence of ( Free (C28 , C29) )) by L66 , L63 , FINSEQ_1:def 4;
L68: ( len ( the_arity_of C33 ) ) = ( len C34 ) by MSATERM:22;
thus L69: thesis by L68 , L67;
end;
L70: (for B36 being (Term of C28 , D3) holds S1[ B36 ]) from MSATERM:sch 1(L51 , L58);
L71: S1[ D4 ] by L70;
thus L72: thesis by L71;
end;
definition
let C36 being set;
func varcl C36 means 
:L73: (C36 c= it & (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in it implies R5 c= it))) & (for B37 being set holds ((C36 c= B37 & (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in B37 implies R5 c= B37)))) implies it c= B37)));
uniqueness
proof
let C37 , C38 being set;
assume L74: (not thesis);
L75: C37 c= C38 by L74;
L76: C38 c= C37 by L74;
thus L77: thesis by L76 , L74 , L75 , XBOOLE_0:def 10;
end;
existence
proof
set D8 = { B38 where B38 is (Subset of ( Rank ( the_rank_of C36 ) )) : (C36 c= B38 & (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in B38 implies R5 c= B38)))) };
take D9 = ( meet D8 );
L78: C36 c= ( Rank ( the_rank_of C36 ) ) by CLASSES1:def 8;
L79:
now
let R5 being set;
let R6 being set;
assume L80: [ R5 , R6 ] in ( Rank ( the_rank_of C36 ) );
L81: { R5 } in { { R5 , R6 } , { R5 } } by TARSKI:def 2;
L82: { { R5 , R6 } , { R5 } } c= ( Rank ( the_rank_of C36 ) ) by L80 , ORDINAL1:def 2;
L83: R5 in { R5 } by TARSKI:def 1;
L84: { R5 } c= ( Rank ( the_rank_of C36 ) ) by L81 , L82 , ORDINAL1:def 2;
thus L85: R5 c= ( Rank ( the_rank_of C36 ) ) by L84 , L83 , ORDINAL1:def 2;
end;
L86: ( Rank ( the_rank_of C36 ) ) c= ( Rank ( the_rank_of C36 ) );
L87: ( Rank ( the_rank_of C36 ) ) in D8 by L86 , L78 , L79;
thus L88:now
let R5 being set;
assume L89: R5 in C36;
L90:
now
let C39 being set;
assume L91: C39 in D8;
L92: (ex B39 being (Subset of ( Rank ( the_rank_of C36 ) )) st (C39 = B39 & C36 c= B39 & (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in B39 implies R5 c= B39))))) by L91;
thus L93: R5 in C39 by L92 , L89;
end;
thus L94: R5 in D9 by L90 , L87 , SETFAM_1:def 1;
end;
thus L95:now
let R5 being set;
let R6 being set;
assume L96: [ R5 , R6 ] in D9;
thus L97: R5 c= D9
proof
let R7 being set;
assume L98: R7 in R5;
L99:
now
let R3 being set;
assume L100: R3 in D8;
L101: [ R5 , R6 ] in R3 by L100 , L96 , SETFAM_1:def 1;
L102: (ex B40 being (Subset of ( Rank ( the_rank_of C36 ) )) st (R3 = B40 & C36 c= B40 & (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in B40 implies R5 c= B40))))) by L100;
L103: R5 c= R3 by L102 , L101;
thus L104: R7 in R3 by L103 , L98;
end;
thus L105: thesis by L99 , L87 , SETFAM_1:def 1;
end;

end;
let C40 being set;
assume that
L98: C36 c= C40
and
L99: (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in C40 implies R5 c= C40)));
set D10 = ( C40 /\ ( Rank ( the_rank_of C36 ) ) );
reconsider D11 = D10 as (Subset of ( Rank ( the_rank_of C36 ) )) by XBOOLE_1:17;
L100: C36 c= D11 by L78 , L98 , XBOOLE_1:19;
L101:
now
let R5 being set;
let R6 being set;
assume L102: [ R5 , R6 ] in D11;
L103: [ R5 , R6 ] in C40 by L102 , XBOOLE_0:def 4;
L104: R5 c= C40 by L103 , L99;
L105: R5 c= ( Rank ( the_rank_of C36 ) ) by L79 , L102;
thus L106: R5 c= D11 by L105 , L104 , XBOOLE_1:19;
end;
L107: D11 in D8 by L101 , L100;
L108: D9 c= D11 by L107 , SETFAM_1:3;
L109: D11 c= C40 by XBOOLE_1:17;
thus L110: thesis by L109 , L108 , XBOOLE_1:1;
end;
projectivity
;
end;
theorem
L112: ( varcl ( {} ) ) = ( {} )
proof
L113: (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in ( {} ) implies R5 c= ( {} ))));
L114: (for B41 being set holds ((( {} ) c= B41 & (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in B41 implies R5 c= B41)))) implies ( {} ) c= B41));
thus L115: thesis by L114 , L113 , L73;
end;
theorem
L116: (for B42 , B43 being set holds (B42 c= B43 implies ( varcl B42 ) c= ( varcl B43 )))
proof
let C41 , C42 being set;
assume that
L117: C41 c= C42;
L118: C42 c= ( varcl C42 ) by L73;
L119: C41 c= ( varcl C42 ) by L118 , L117 , XBOOLE_1:1;
L120: (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in ( varcl C42 ) implies R5 c= ( varcl C42 )))) by L73;
thus L121: thesis by L120 , L119 , L73;
end;
theorem
L122: (for B44 being set holds ( varcl ( union B44 ) ) = ( union { ( varcl B45 ) where B45 is (Element of B44) : (not contradiction) } ))
proof
let C43 being set;
set D12 = { ( varcl B46 ) where B46 is (Element of C43) : (not contradiction) };
L123: ( union C43 ) c= ( union D12 )
proof
let R5 being set;
assume L124: R5 in ( union C43 );
consider R4 being set such that L125: R5 in R4 and L126: R4 in C43 by L124 , TARSKI:def 4;
reconsider D13 = R4 as (Element of C43) by L126;
L127: D13 c= ( varcl D13 ) by L73;
L128: ( varcl D13 ) in D12;
thus L129: thesis by L128 , L125 , L127 , TARSKI:def 4;
end;
L130:
now
let C44 , C45 being set;
assume L131: [ C44 , C45 ] in ( union D12 );
consider C46 being set such that L132: [ C44 , C45 ] in C46 and L133: C46 in D12 by L131 , TARSKI:def 4;
L134: (ex B47 being (Element of C43) st C46 = ( varcl B47 )) by L133;
L135: C44 c= C46 by L134 , L132 , L73;
L136: C46 c= ( union D12 ) by L133 , ZFMISC_1:74;
thus L137: C44 c= ( union D12 ) by L136 , L135 , XBOOLE_1:1;
end;
thus L138: ( varcl ( union C43 ) ) c= ( union D12 ) by L130 , L123 , L73;
let R5 being set;
assume L139: R5 in ( union D12 );
consider C47 being set such that L140: R5 in C47 and L141: C47 in D12 by L139 , TARSKI:def 4;
consider C48 being (Element of C43) such that L142: C47 = ( varcl C48 ) by L141;
L143: (C43 is  empty or (not C43 is  empty));
L144: (C48 in C43 or C48 is  empty) by L143 , SUBSET_1:def 1;
L145: C48 c= ( union C43 ) by L144 , XBOOLE_1:2 , ZFMISC_1:74;
L146: C47 c= ( varcl ( union C43 ) ) by L145 , L142 , L116;
thus L147: thesis by L146 , L140;
end;
scheme Sch14 { F1() -> set , F2(set) -> set , P1[set] } : ( varcl ( union { F2(B48) where B48 is (Element of F1()) : P1[ B48 ] } ) ) = ( union { ( varcl F2(B49) ) where B49 is (Element of F1()) : P1[ B49 ] } )
proof
set D14 = { F2(B50) where B50 is (Element of F1()) : P1[ B50 ] };
set D15 = { ( varcl F2(B51) ) where B51 is (Element of F1()) : P1[ B51 ] };
L148: ( union D14 ) c= ( union D15 )
proof
let R5 being set;
assume L149: R5 in ( union D14 );
consider R4 being set such that L150: R5 in R4 and L151: R4 in D14 by L149 , TARSKI:def 4;
L152: (ex B52 being (Element of F1()) st (R4 = F2(B52) & P1[ B52 ])) by L151;
L153: R4 c= ( varcl R4 ) by L73;
L154: ( varcl R4 ) in D15 by L152;
thus L155: thesis by L154 , L150 , L153 , TARSKI:def 4;
end;
L156:
now
let C49 , C50 being set;
assume L157: [ C49 , C50 ] in ( union D15 );
consider C51 being set such that L158: [ C49 , C50 ] in C51 and L159: C51 in D15 by L157 , TARSKI:def 4;
L160: (ex B53 being (Element of F1()) st (C51 = ( varcl F2(B53) ) & P1[ B53 ])) by L159;
L161: C49 c= C51 by L160 , L158 , L73;
L162: C51 c= ( union D15 ) by L159 , ZFMISC_1:74;
thus L163: C49 c= ( union D15 ) by L162 , L161 , XBOOLE_1:1;
end;
thus L164: ( varcl ( union D14 ) ) c= ( union D15 ) by L156 , L148 , L73;
let R5 being set;
assume L165: R5 in ( union D15 );
consider C52 being set such that L166: R5 in C52 and L167: C52 in D15 by L165 , TARSKI:def 4;
consider C53 being (Element of F1()) such that L168: C52 = ( varcl F2(C53) ) and L169: P1[ C53 ] by L167;
L170: F2(C53) in D14 by L169;
L171: C52 c= ( varcl ( union D14 ) ) by L170 , L168 , L116 , ZFMISC_1:74;
thus L172: thesis by L171 , L166;
end;
theorem
L173: (for R3 being set holds (for R4 being set holds ( varcl ( R3 \/ R4 ) ) = ( ( varcl R3 ) \/ ( varcl R4 ) )))
proof
let R3 being set;
let R4 being set;
set D16 = { ( varcl B54 ) where B54 is (Element of { R3 , R4 }) : (not contradiction) };
L174: ( R3 \/ R4 ) = ( union { R3 , R4 } ) by ZFMISC_1:75;
L175: ( varcl ( R3 \/ R4 ) ) = ( union D16 ) by L174 , L122;
L176: D16 = { ( varcl R3 ) , ( varcl R4 ) }
proof
thus L177:now
let R5 being set;
assume L178: R5 in D16;
consider C54 being (Element of { R3 , R4 }) such that L179: R5 = ( varcl C54 ) by L178;
L180: (C54 = R3 or C54 = R4) by TARSKI:def 2;
thus L181: R5 in { ( varcl R3 ) , ( varcl R4 ) } by L180 , L179 , TARSKI:def 2;
end;
let R5 being set;
assume L182: R5 in { ( varcl R3 ) , ( varcl R4 ) };
L183: ((R5 = ( varcl R3 ) & R3 in { R3 , R4 }) or (R5 = ( varcl R4 ) & R4 in { R3 , R4 })) by L182 , TARSKI:def 2;
thus L184: thesis by L183;
end;
thus L185: thesis by L176 , L175 , ZFMISC_1:75;
end;
theorem
L186: (for B55 being non  empty set holds ((for B56 being (Element of B55) holds ( varcl B56 ) = B56) implies ( varcl ( meet B55 ) ) = ( meet B55 )))
proof
let C55 being non  empty set;
set D17 = ( meet C55 );
assume L187: (for B57 being (Element of C55) holds ( varcl B57 ) = B57);
L188:
now
thus L189: D17 c= D17;
let R5 being set;
let R6 being set;
assume L190: [ R5 , R6 ] in D17;
L191:
now
let R4 being set;
assume L192: R4 in C55;
L193: [ R5 , R6 ] in R4 by L192 , L190 , SETFAM_1:def 1;
L194: R4 = ( varcl R4 ) by L187 , L192;
thus L195: R5 c= R4 by L194 , L193 , L73;
end;
thus L196: R5 c= D17 by L191 , SETFAM_1:5;
end;
thus L197: ( varcl D17 ) c= D17 by L188 , L73;
thus L198: thesis by L73;
end;
theorem
L199: (for R3 being set holds (for R4 being set holds ( varcl ( ( varcl R3 ) /\ ( varcl R4 ) ) ) = ( ( varcl R3 ) /\ ( varcl R4 ) )))
proof
let R3 being set;
let R4 being set;
set D18 = ( ( varcl R3 ) /\ ( varcl R4 ) );
L200:
now
thus L201: D18 c= D18;
let R5 being set;
let R6 being set;
assume L202: [ R5 , R6 ] in D18;
L203: [ R5 , R6 ] in ( varcl R3 ) by L202 , XBOOLE_0:def 4;
L204: [ R5 , R6 ] in ( varcl R4 ) by L202 , XBOOLE_0:def 4;
L205: R5 c= ( varcl R3 ) by L203 , L73;
L206: R5 c= ( varcl R4 ) by L204 , L73;
thus L207: R5 c= D18 by L206 , L205 , XBOOLE_1:19;
end;
thus L208: ( varcl ( ( varcl R3 ) /\ ( varcl R4 ) ) ) c= ( ( varcl R3 ) /\ ( varcl R4 ) ) by L200 , L73;
thus L209: thesis by L73;
end;
registration
let C56 being  empty set;
cluster ( varcl C56 ) ->  empty;
coherence by L112;
end;
deffunc H1(set , set) = { [ ( varcl B58 ) , B59 ] where B58 is (Subset of $2) , B59 is (Element of ( NAT )) : B58 is  finite };
definition
func Vars means 
:L211: (ex B60 being (ManySortedSet of ( NAT )) st (it = ( Union B60 ) & ( B60 . ( 0 ) ) = { [ ( {} ) , B61 ] where B61 is (Element of ( NAT )) : (not contradiction) } & (for B62 being Nat holds ( B60 . ( B62 + 1 ) ) = { [ ( varcl B63 ) , B64 ] where B63 is (Subset of ( B60 . B62 )) , B64 is (Element of ( NAT )) : B63 is  finite })));
existence
proof
consider C57 being Function such that L212: ( dom C57 ) = ( NAT ) and L213: ( C57 . ( 0 ) ) = { [ ( {} ) , B65 ] where B65 is (Element of ( NAT )) : (not contradiction) } and L214: (for B66 being Nat holds ( C57 . ( B66 + 1 ) ) = H1(B66 , ( C57 . B66 ))) from NAT_1:sch 11;
reconsider D19 = C57 as (ManySortedSet of ( NAT )) by L212 , PARTFUN1:def 2 , RELAT_1:def 18;
take ( Union D19 );
take D20 = D19;
thus L215: ( Union D19 ) = ( Union D20 );
thus L216: ( D20 . ( 0 ) ) = { [ ( {} ) , B67 ] where B67 is (Element of ( NAT )) : (not contradiction) } by L213;
let C58 being Nat;
thus L217: thesis by L214;
end;
uniqueness
proof
let C59 , C60 being set;
given C61 being (ManySortedSet of ( NAT )) such that
L218: C59 = ( Union C61 )
and
L219: ( C61 . ( 0 ) ) = { [ ( {} ) , B68 ] where B68 is (Element of ( NAT )) : (not contradiction) }
and
L220: (for B69 being Nat holds ( C61 . ( B69 + 1 ) ) = H1(B69 , ( C61 . B69 )));

given C62 being (ManySortedSet of ( NAT )) such that
L221: C60 = ( Union C62 )
and
L222: ( C62 . ( 0 ) ) = { [ ( {} ) , B70 ] where B70 is (Element of ( NAT )) : (not contradiction) }
and
L223: (for B71 being Nat holds ( C62 . ( B71 + 1 ) ) = H1(B71 , ( C62 . B71 )));

L224: ( dom C61 ) = ( NAT ) by PARTFUN1:def 2;
L225: ( dom C62 ) = ( NAT ) by PARTFUN1:def 2;
L226: C61 = C62 from NAT_1:sch 15(L224 , L219 , L220 , L225 , L222 , L223);
thus L227: thesis by L226 , L218 , L221;
end;
end;
theorem
L229: (for B72 being (ManySortedSet of ( NAT )) holds ((( B72 . ( 0 ) ) = { [ ( {} ) , B73 ] where B73 is (Element of ( NAT )) : (not contradiction) } & (for B74 being Nat holds ( B72 . ( B74 + 1 ) ) = { [ ( varcl B75 ) , B76 ] where B75 is (Subset of ( B72 . B74 )) , B76 is (Element of ( NAT )) : B75 is  finite })) implies (for B77 , B78 being (Element of ( NAT )) holds (B77 <= B78 implies ( B72 . B77 ) c= ( B72 . B78 )))))
proof
let C63 being (ManySortedSet of ( NAT ));
assume that
L230: ( C63 . ( 0 ) ) = { [ ( {} ) , B79 ] where B79 is (Element of ( NAT )) : (not contradiction) }
and
L231: (for B80 being Nat holds ( C63 . ( B80 + 1 ) ) = { [ ( varcl B81 ) , B82 ] where B81 is (Subset of ( C63 . B80 )) , B82 is (Element of ( NAT )) : B81 is  finite });
defpred S2[ Nat ] means ( C63 . ( 0 ) ) c= ( C63 . $1 );
L232:
now
let R2 being (Element of ( NAT ));
assume L233: S2[ R2 ];
L234: ( C63 . ( R2 + 1 ) ) = { [ ( varcl B83 ) , B84 ] where B83 is (Subset of ( C63 . R2 )) , B84 is (Element of ( NAT )) : B83 is  finite } by L231;
thus L235: S2[ ( R2 + 1 ) ]
proof
let R5 being set;
assume L236: R5 in ( C63 . ( 0 ) );
L237: (ex B85 being (Element of ( NAT )) st R5 = [ ( {} ) , B85 ]) by L236 , L230;
L238: ( {} ) c= ( C63 . R2 ) by XBOOLE_1:2;
thus L239: thesis by L238 , L234 , L237 , L112;
end;

end;
defpred S3[ Nat ] means (for R1 being Nat holds (R1 <= $1 implies ( C63 . R1 ) c= ( C63 . $1 )));
L236: S3[ ( 0 ) ] by NAT_1:3;
L237:
now
let R2 being (Element of ( NAT ));
assume L238: S3[ R2 ];
L239: ( C63 . R2 ) c= ( C63 . ( R2 + 1 ) )
proof
per cases  by NAT_1:6;
suppose L240: R2 = ( 0 );

thus L241: thesis by L240 , L232;
end;
suppose L242: (ex B86 being Nat st R2 = ( B86 + 1 ));

consider C64 being Nat such that L243: R2 = ( C64 + 1 ) by L242;
reconsider D21 = C64 as (Element of ( NAT )) by ORDINAL1:def 12;
L244: ( C63 . R2 ) = { [ ( varcl B87 ) , B88 ] where B87 is (Subset of ( C63 . D21 )) , B88 is (Element of ( NAT )) : B87 is  finite } by L231 , L243;
L245: ( C63 . ( R2 + 1 ) ) = { [ ( varcl B89 ) , B90 ] where B89 is (Subset of ( C63 . R2 )) , B90 is (Element of ( NAT )) : B89 is  finite } by L231;
L246: ( C63 . D21 ) c= ( C63 . R2 ) by L238 , L243 , NAT_1:11;
let R5 being set;
assume L247: R5 in ( C63 . R2 );
consider C65 being (Subset of ( C63 . D21 )), C66 being (Element of ( NAT )) such that L248: R5 = [ ( varcl C65 ) , C66 ] and L249: C65 is  finite by L247 , L244;
L250: C65 c= ( C63 . R2 ) by L246 , XBOOLE_1:1;
thus L251: thesis by L250 , L245 , L248 , L249;
end;
end;
thus L253: S3[ ( R2 + 1 ) ]
proof
let R1 being Nat;
assume L254: R1 <= ( R2 + 1 );
L255: (R1 = ( R2 + 1 ) or ( C63 . R1 ) c= ( C63 . R2 )) by L254 , L238 , NAT_1:8;
thus L256: thesis by L255 , L239 , XBOOLE_1:1;
end;

end;
L254: (for R2 being (Element of ( NAT )) holds S3[ R2 ]) from NAT_1:sch 1(L236 , L237);
thus L255: thesis by L254;
end;
theorem
L256: (for B91 being (ManySortedSet of ( NAT )) holds ((( B91 . ( 0 ) ) = { [ ( {} ) , B92 ] where B92 is (Element of ( NAT )) : (not contradiction) } & (for B93 being Nat holds ( B91 . ( B93 + 1 ) ) = { [ ( varcl B94 ) , B95 ] where B94 is (Subset of ( B91 . B93 )) , B95 is (Element of ( NAT )) : B94 is  finite })) implies (for B96 being  finite (Subset of ( Vars )) holds (ex B97 being (Element of ( NAT )) st B96 c= ( B91 . B97 )))))
proof
let C67 being (ManySortedSet of ( NAT ));
assume that
L257: ( C67 . ( 0 ) ) = { [ ( {} ) , B98 ] where B98 is (Element of ( NAT )) : (not contradiction) }
and
L258: (for B99 being Nat holds ( C67 . ( B99 + 1 ) ) = { [ ( varcl B100 ) , B101 ] where B100 is (Subset of ( C67 . B99 )) , B101 is (Element of ( NAT )) : B100 is  finite });
let C68 being  finite (Subset of ( Vars ));
L259: ( Vars ) = ( Union C67 ) by L257 , L258 , L211;
defpred S4[ set , set ] means $1 in ( C67 . $2 );
L260:
now
let R5 being set;
assume L261: R5 in C68;
consider R4 being set such that L262: R5 in R4 and L263: R4 in ( rng C67 ) by L261 , L259 , TARSKI:def 4;
consider C69 being set such that L264: C69 in ( dom C67 ) and L265: R4 = ( C67 . C69 ) by L263 , FUNCT_1:def 3;
take D22 = C69;
thus L266: (D22 in ( NAT ) & S4[ R5 , D22 ]) by L262 , L264 , L265;
end;
consider C70 being Function such that L267: (( dom C70 ) = C68 & ( rng C70 ) c= ( NAT )) and L268: (for R5 being set holds (R5 in C68 implies S4[ R5 , ( C70 . R5 ) ])) from FUNCT_1:sch 5(L260);
per cases ;
suppose L269: C68 = ( {} );

L270: C68 c= ( C67 . ( 0 ) ) by L269 , XBOOLE_1:2;
thus L271: thesis by L270;
end;
suppose L272: C68 <> ( {} );

reconsider D23 = ( rng C70 ) as  finite non  empty (Subset of ( NAT )) by L272 , L267 , FINSET_1:8 , RELAT_1:42;
reconsider D24 = ( max D23 ) as (Element of ( NAT )) by ORDINAL1:def 12;
take D24;
let C71 being set;
assume L273: C71 in C68;
L274: ( C70 . C71 ) in D23 by L273 , L267 , FUNCT_1:def 3;
reconsider D25 = ( C70 . C71 ) as (Element of ( NAT )) by L274;
L275: D25 <= D24 by L274 , XXREAL_2:def 8;
L276: ( C67 . D25 ) c= ( C67 . D24 ) by L275 , L257 , L258 , L229;
L277: C71 in ( C67 . D25 ) by L268 , L273;
thus L278: thesis by L277 , L276;
end;
end;
theorem
L280: { [ ( {} ) , B102 ] where B102 is (Element of ( NAT )) : (not contradiction) } c= ( Vars )
proof
consider C72 being (ManySortedSet of ( NAT )) such that L281: ( Vars ) = ( Union C72 ) and L282: ( C72 . ( 0 ) ) = { [ ( {} ) , B103 ] where B103 is (Element of ( NAT )) : (not contradiction) } and L283: (for B104 being Nat holds ( C72 . ( B104 + 1 ) ) = { [ ( varcl B105 ) , B106 ] where B105 is (Subset of ( C72 . B104 )) , B106 is (Element of ( NAT )) : B105 is  finite }) by L211;
L284: ( dom C72 ) = ( NAT ) by PARTFUN1:def 2;
L285: ( C72 . ( 0 ) ) in ( rng C72 ) by L284 , FUNCT_1:def 3;
thus L286: thesis by L285 , L281 , L282 , ZFMISC_1:74;
end;
theorem
L287: (for B107 being  finite (Subset of ( Vars )) holds (for B108 being Nat holds [ ( varcl B107 ) , B108 ] in ( Vars )))
proof
let C73 being  finite (Subset of ( Vars ));
let C74 being Nat;
consider C75 being (ManySortedSet of ( NAT )) such that L288: ( Vars ) = ( Union C75 ) and L289: ( C75 . ( 0 ) ) = { [ ( {} ) , B109 ] where B109 is (Element of ( NAT )) : (not contradiction) } and L290: (for B110 being Nat holds ( C75 . ( B110 + 1 ) ) = { [ ( varcl B111 ) , B112 ] where B111 is (Subset of ( C75 . B110 )) , B112 is (Element of ( NAT )) : B111 is  finite }) by L211;
consider C76 being (Element of ( NAT )) such that L291: C73 c= ( C75 . C76 ) by L289 , L290 , L256;
L292: ( C75 . ( C76 + 1 ) ) = { [ ( varcl B113 ) , B114 ] where B113 is (Subset of ( C75 . C76 )) , B114 is (Element of ( NAT )) : B113 is  finite } by L290;
L293: C74 in ( NAT ) by ORDINAL1:def 12;
L294: [ ( varcl C73 ) , C74 ] in ( C75 . ( C76 + 1 ) ) by L293 , L291 , L292;
L295: ( dom C75 ) = ( NAT ) by PARTFUN1:def 2;
thus L296: thesis by L295 , L288 , L294 , CARD_5:2;
end;
theorem
L297: ( Vars ) = { [ ( varcl B115 ) , B116 ] where B115 is (Subset of ( Vars )) , B116 is (Element of ( NAT )) : B115 is  finite }
proof
consider C77 being (ManySortedSet of ( NAT )) such that L298: ( Vars ) = ( Union C77 ) and L299: ( C77 . ( 0 ) ) = { [ ( {} ) , B117 ] where B117 is (Element of ( NAT )) : (not contradiction) } and L300: (for B118 being Nat holds ( C77 . ( B118 + 1 ) ) = { [ ( varcl B119 ) , B120 ] where B119 is (Subset of ( C77 . B118 )) , B120 is (Element of ( NAT )) : B119 is  finite }) by L211;
set D26 = { [ ( varcl B121 ) , B122 ] where B121 is (Subset of ( Vars )) , B122 is (Element of ( NAT )) : B121 is  finite };
L301: ( dom C77 ) = ( NAT ) by PARTFUN1:def 2;
defpred S5[ Nat ] means ( C77 . $1 ) c= D26;
L302: S5[ ( 0 ) ]
proof
let R5 being set;
assume L303: R5 in ( C77 . ( 0 ) );
L304: ( {} ) c= ( Vars ) by XBOOLE_1:2;
L305: (ex B123 being (Element of ( NAT )) st R5 = [ ( {} ) , B123 ]) by L299 , L303;
thus L306: thesis by L305 , L304 , L112;
end;
L307:
now
let C78 being (Element of ( NAT ));
assume L308: S5[ C78 ];
L309: ( C77 . ( C78 + 1 ) ) = { [ ( varcl B124 ) , B125 ] where B124 is (Subset of ( C77 . C78 )) , B125 is (Element of ( NAT )) : B124 is  finite } by L300;
thus L310: S5[ ( C78 + 1 ) ]
proof
let R5 being set;
assume L311: R5 in ( C77 . ( C78 + 1 ) );
consider C79 being (Subset of ( C77 . C78 )), C80 being (Element of ( NAT )) such that L312: R5 = [ ( varcl C79 ) , C80 ] and L313: C79 is  finite by L311 , L309;
L314: ( C77 . C78 ) in ( rng C77 ) by L301 , FUNCT_1:def 3;
L315: ( C77 . C78 ) c= ( Vars ) by L314 , L298 , ZFMISC_1:74;
L316: C79 c= ( Vars ) by L315 , XBOOLE_1:1;
thus L317: thesis by L316 , L312 , L313;
end;

end;
L311: (for B126 being (Element of ( NAT )) holds S5[ B126 ]) from NAT_1:sch 1(L302 , L307);
L312:
now
let R5 being set;
assume L313: R5 in ( rng C77 );
L314: (ex R6 being set st (R6 in ( NAT ) & R5 = ( C77 . R6 ))) by L313 , L301 , FUNCT_1:def 3;
thus L315: R5 c= D26 by L314 , L311;
end;
thus L316: ( Vars ) c= D26 by L312 , L298 , ZFMISC_1:76;
let R5 being set;
assume L317: R5 in D26;
L318: (ex B127 being (Subset of ( Vars )) st (ex B128 being (Element of ( NAT )) st (R5 = [ ( varcl B127 ) , B128 ] & B127 is  finite))) by L317;
thus L319: thesis by L318 , L287;
end;
theorem
L320: ( varcl ( Vars ) ) = ( Vars )
proof
consider C81 being (ManySortedSet of ( NAT )) such that L321: ( Vars ) = ( Union C81 ) and L322: ( C81 . ( 0 ) ) = { [ ( {} ) , B129 ] where B129 is (Element of ( NAT )) : (not contradiction) } and L323: (for B130 being Nat holds ( C81 . ( B130 + 1 ) ) = { [ ( varcl B131 ) , B132 ] where B131 is (Subset of ( C81 . B130 )) , B132 is (Element of ( NAT )) : B131 is  finite }) by L211;
defpred S6[ Nat ] means ( varcl ( C81 . $1 ) ) = ( C81 . $1 );
L324:
now
let R5 being set;
let R6 being set;
assume L325: [ R5 , R6 ] in ( C81 . ( 0 ) );
L326: (ex B133 being (Element of ( NAT )) st [ R5 , R6 ] = [ ( {} ) , B133 ]) by L325 , L322;
L327: R5 = ( {} ) by L326 , XTUPLE_0:1;
thus L328: R5 c= ( C81 . ( 0 ) ) by L327 , XBOOLE_1:2;
end;
L329: ( varcl ( C81 . ( 0 ) ) ) c= ( C81 . ( 0 ) ) by L324 , L73;
L330: ( C81 . ( 0 ) ) c= ( varcl ( C81 . ( 0 ) ) ) by L73;
L331: S6[ ( 0 ) ] by L330 , L329 , XBOOLE_0:def 10;
L332:
now
let R1 being Nat;
assume L333: S6[ R1 ];
reconsider D27 = R1 as (Element of ( NAT )) by ORDINAL1:def 12;
L334: ( C81 . ( R1 + 1 ) ) = { [ ( varcl B134 ) , B135 ] where B134 is (Subset of ( C81 . R1 )) , B135 is (Element of ( NAT )) : B134 is  finite } by L323;
L335:
now
let R5 being set;
let R6 being set;
assume L336: [ R5 , R6 ] in ( C81 . ( R1 + 1 ) );
consider C82 being (Subset of ( C81 . R1 )), C83 being (Element of ( NAT )) such that L337: [ R5 , R6 ] = [ ( varcl C82 ) , C83 ] and L338: C82 is  finite by L336 , L334;
L339: R5 = ( varcl C82 ) by L337 , XTUPLE_0:1;
L340: R5 c= ( C81 . R1 ) by L339 , L333 , L116;
L341: ( C81 . D27 ) c= ( C81 . ( D27 + 1 ) ) by L322 , L323 , L229 , NAT_1:11;
thus L342: R5 c= ( C81 . ( R1 + 1 ) ) by L341 , L340 , XBOOLE_1:1;
end;
L343: ( varcl ( C81 . ( R1 + 1 ) ) ) c= ( C81 . ( R1 + 1 ) ) by L335 , L73;
L344: ( C81 . ( R1 + 1 ) ) c= ( varcl ( C81 . ( R1 + 1 ) ) ) by L73;
thus L345: S6[ ( R1 + 1 ) ] by L344 , L343 , XBOOLE_0:def 10;
end;
L346: (for R1 being Nat holds S6[ R1 ]) from NAT_1:sch 2(L331 , L332);
L347: ( varcl ( Vars ) ) = ( union { ( varcl B136 ) where B136 is (Element of ( rng C81 )) : (not contradiction) } ) by L321 , L122;
thus L348:now
let R5 being set;
assume L349: R5 in ( varcl ( Vars ) );
consider R4 being set such that L350: R5 in R4 and L351: R4 in { ( varcl B137 ) where B137 is (Element of ( rng C81 )) : (not contradiction) } by L349 , L347 , TARSKI:def 4;
consider C84 being (Element of ( rng C81 )) such that L352: R4 = ( varcl C84 ) by L351;
consider C85 being set such that L353: C85 in ( dom C81 ) and L354: C84 = ( C81 . C85 ) by FUNCT_1:def 3;
reconsider D28 = C85 as (Element of ( NAT )) by L353;
L355: ( varcl ( C81 . D28 ) ) = C84 by L346 , L354;
thus L356: R5 in ( Vars ) by L355 , L321 , L350 , L352 , L353 , L354 , CARD_5:2;
end;
thus L357: thesis by L73;
end;
theorem
L358: (for R3 being set holds (( the_rank_of R3 ) is  finite implies R3 is  finite))
proof
let R3 being set;
assume L359: ( the_rank_of R3 ) is  finite;
L360: ( the_rank_of R3 ) in ( NAT ) by L359 , CARD_1:61;
L361: ( Rank ( the_rank_of R3 ) ) is  finite by L360 , CARD_2:67;
L362: R3 c= ( Rank ( the_rank_of R3 ) ) by CLASSES1:def 8;
thus L363: thesis by L362 , L361;
end;
theorem
L364: (for R3 being set holds ( the_rank_of ( varcl R3 ) ) = ( the_rank_of R3 ))
proof
let R3 being set;
L365: R3 c= ( Rank ( the_rank_of R3 ) ) by CLASSES1:def 8;
set D29 = ( the_rank_of R3 );
L366: D29 c= ( succ D29 ) by ORDINAL3:1;
L367: ( succ D29 ) c= ( succ ( succ D29 ) ) by ORDINAL3:1;
L368: D29 c= ( succ ( succ D29 ) ) by L367 , L366 , XBOOLE_1:1;
L369: ( Rank D29 ) c= ( Rank ( succ ( succ D29 ) ) ) by L368 , CLASSES1:37;
L370:
now
let R5 being set;
let R6 being set;
assume L371: [ R5 , R6 ] in ( Rank ( the_rank_of R3 ) );
L372: R5 in ( Rank D29 ) by L371 , L369 , CLASSES1:45;
thus L373: R5 c= ( Rank ( the_rank_of R3 ) ) by L372 , ORDINAL1:def 2;
end;
L374: ( varcl R3 ) c= ( Rank D29 ) by L370 , L365 , L73;
thus L375: ( the_rank_of ( varcl R3 ) ) c= D29 by L374 , CLASSES1:65;
L376: R3 c= ( varcl R3 ) by L73;
thus L377: thesis by L376 , CLASSES1:67;
end;
theorem
L378: (for B138 being  finite (Subset of ( Rank ( omega ) )) holds B138 in ( Rank ( omega ) ))
proof
let C86 being  finite (Subset of ( Rank ( omega ) ));
deffunc H2(set) = ( the_rank_of $1 );
consider C87 being Function such that L379: ( dom C87 ) = C86 and L380: (for R5 being set holds (R5 in C86 implies ( C87 . R5 ) = H2(R5))) from FUNCT_1:sch 3;
L381: ( rng C87 ) c= ( NAT )
proof
let R6 being set;
assume L382: R6 in ( rng C87 );
consider R5 being set such that L383: R5 in C86 and L384: R6 = ( C87 . R5 ) by L382 , L379 , FUNCT_1:def 3;
L385: ( the_rank_of R5 ) in ( omega ) by L383 , CLASSES1:66;
thus L386: thesis by L385 , L380 , L383 , L384;
end;
per cases ;
suppose L387: C86 = ( {} );

L388: ( the_rank_of C86 ) = ( 0 ) by L387 , CLASSES1:71;
thus L389: thesis by L388 , CLASSES1:66;
end;
suppose L390: C86 <> ( {} );

reconsider D30 = ( rng C87 ) as  finite non  empty (Subset of ( NAT )) by L390 , L379 , L381 , FINSET_1:8 , RELAT_1:42;
reconsider D31 = ( max D30 ) as (Element of ( NAT )) by ORDINAL1:def 12;
set D32 = ( 1 + D31 );
L391: C86 c= ( Rank D32 )
proof
let R5 being set;
assume L392: R5 in C86;
L393: ( C87 . R5 ) in D30 by L392 , L379 , FUNCT_1:def 3;
L394: ( C87 . R5 ) = ( the_rank_of R5 ) by L380 , L392;
reconsider D33 = ( C87 . R5 ) as (Element of ( NAT )) by L393;
L395: D33 <= D31 by L393 , XXREAL_2:def 8;
L396: D33 c= D31 by L395 , NAT_1:39;
L397: D33 in ( succ D31 ) by L396 , ORDINAL1:22;
L398: ( succ D31 ) = D32 by NAT_1:38;
thus L399: thesis by L398 , L394 , L397 , CLASSES1:66;
end;
L400: ( the_rank_of C86 ) c= D32 by L391 , CLASSES1:65;
L401: ( the_rank_of C86 ) in ( succ D32 ) by L400 , ORDINAL1:22;
L402: ( D32 + 1 ) c= ( omega );
L403: ( D32 + 1 ) = ( succ D32 ) by NAT_1:38;
thus L404: thesis by L403 , L401 , L402 , CLASSES1:66;
end;
end;
theorem
L406: ( Vars ) c= ( Rank ( omega ) )
proof
consider C88 being (ManySortedSet of ( NAT )) such that L407: ( Vars ) = ( Union C88 ) and L408: ( C88 . ( 0 ) ) = { [ ( {} ) , B139 ] where B139 is (Element of ( NAT )) : (not contradiction) } and L409: (for B140 being Nat holds ( C88 . ( B140 + 1 ) ) = { [ ( varcl B141 ) , B142 ] where B141 is (Subset of ( C88 . B140 )) , B142 is (Element of ( NAT )) : B141 is  finite }) by L211;
let R5 being set;
assume L410: R5 in ( Vars );
consider C89 being set such that L411: C89 in ( dom C88 ) and L412: R5 in ( C88 . C89 ) by L410 , L407 , CARD_5:2;
reconsider D34 = C89 as (Element of ( NAT )) by L411;
defpred S7[ Nat ] means ( C88 . $1 ) c= ( Rank ( omega ) );
L413: S7[ ( 0 ) ]
proof
let R5 being set;
assume L414: R5 in ( C88 . ( 0 ) );
consider C90 being (Element of ( NAT )) such that L415: R5 = [ ( {} ) , C90 ] by L414 , L408;
L416: ( C90 + 1 ) = ( succ C90 ) by NAT_1:38;
L417: ( {} ) c= C90;
L418: C90 in ( C90 + 1 ) by L416 , ORDINAL1:6;
L419: ( {} ) in ( C90 + 1 ) by L416 , L417 , ORDINAL1:6 , ORDINAL1:12;
L420: ( the_rank_of ( {} ) ) = ( {} ) by CLASSES1:73;
L421: ( the_rank_of C90 ) = C90 by CLASSES1:73;
L422: ( {} ) in ( Rank ( C90 + 1 ) ) by L419 , L420 , CLASSES1:66;
L423: C90 in ( Rank ( C90 + 1 ) ) by L418 , L421 , CLASSES1:66;
L424: R5 in ( Rank ( succ ( succ ( C90 + 1 ) ) ) ) by L423 , L415 , L422 , CLASSES1:45;
L425: ( succ ( succ ( C90 + 1 ) ) ) c= ( omega );
L426: ( Rank ( succ ( succ ( C90 + 1 ) ) ) ) c= ( Rank ( omega ) ) by L425 , CLASSES1:37;
thus L427: thesis by L426 , L424;
end;
L428:
now
let C91 being (Element of ( NAT ));
assume that
L429: S7[ C91 ];
L430: ( C88 . ( C91 + 1 ) ) = { [ ( varcl B143 ) , B144 ] where B143 is (Subset of ( C88 . C91 )) , B144 is (Element of ( NAT )) : B143 is  finite } by L409;
thus L431: S7[ ( C91 + 1 ) ]
proof
let R5 being set;
assume L432: R5 in ( C88 . ( C91 + 1 ) );
consider C92 being (Subset of ( C88 . C91 )), C93 being (Element of ( NAT )) such that L433: R5 = [ ( varcl C92 ) , C93 ] and L434: C92 is  finite by L432 , L430;
L435: C92 c= ( Rank ( omega ) ) by L429 , XBOOLE_1:1;
L436: C92 in ( Rank ( omega ) ) by L435 , L434 , L378;
reconsider D35 = ( the_rank_of C92 ) as (Element of ( NAT )) by L436 , CLASSES1:66;
reconsider D36 = ( C93 \/ D35 ) as (Element of ( NAT )) by ORDINAL3:12;
L437: ( the_rank_of ( varcl C92 ) ) = D35 by L364;
L438: ( the_rank_of C93 ) = C93 by CLASSES1:73;
L439: D36 in ( succ D36 ) by ORDINAL1:6;
L440: D35 in ( succ D36 ) by L439 , ORDINAL1:12 , XBOOLE_1:7;
L441: C93 in ( succ D36 ) by L439 , ORDINAL1:12 , XBOOLE_1:7;
L442: ( succ D36 ) = ( D36 + 1 ) by NAT_1:38;
L443: ( varcl C92 ) in ( Rank ( D36 + 1 ) ) by L442 , L437 , L440 , CLASSES1:66;
L444: C93 in ( Rank ( D36 + 1 ) ) by L438 , L441 , L442 , CLASSES1:66;
L445: R5 in ( Rank ( succ ( succ ( D36 + 1 ) ) ) ) by L444 , L433 , L443 , CLASSES1:45;
L446: ( succ ( succ ( D36 + 1 ) ) ) c= ( omega );
L447: ( Rank ( succ ( succ ( D36 + 1 ) ) ) ) c= ( Rank ( omega ) ) by L446 , CLASSES1:37;
thus L448: thesis by L447 , L445;
end;

end;
L432: (for B145 being (Element of ( NAT )) holds S7[ B145 ]) from NAT_1:sch 1(L413 , L428);
L433: ( C88 . D34 ) c= ( Rank ( omega ) ) by L432;
thus L434: thesis by L433 , L412;
end;
theorem
L435: (for B146 being  finite (Subset of ( Vars )) holds ( varcl B146 ) is  finite  finite  finite  finite (Subset of ( Vars )))
proof
let C94 being  finite (Subset of ( Vars ));
L436: C94 c= ( Rank ( omega ) ) by L406 , XBOOLE_1:1;
L437: C94 in ( Rank ( omega ) ) by L436 , L378;
L438: ( the_rank_of C94 ) in ( omega ) by L437 , CLASSES1:66;
L439: ( the_rank_of ( varcl C94 ) ) is  finite by L438 , L364;
thus L440: thesis by L439 , L116 , L320 , L358;
end;
registration
cluster ( Vars ) -> non  empty;
correctness
proof
L441: [ ( {} ) , ( 0 ) ] in { [ ( {} ) , B147 ] where B147 is (Element of ( NAT )) : (not contradiction) };
thus L442: thesis by L441 , L280;
end;
end;
definition
mode variable
 is (Element of ( Vars ));
end;
registration
let C95 being variable;
cluster ( C95 `1 ) ->  finite;
coherence
proof
L445: C95 in ( Vars );
consider C96 being (Subset of ( Vars )), C97 being (Element of ( NAT )) such that L446: C95 = [ ( varcl C96 ) , C97 ] and L447: C96 is  finite by L445 , L297;
L448: ( C95 `1 ) = ( varcl C96 ) by L446 , MCART_1:7;
thus L449: thesis by L448 , L447 , L435;
end;
end;
notation
let C98 being variable;
synonym vars C98 for C98 `1;
end;
definition
let C99 being variable;
redefine func vars C99 -> (Subset of ( Vars ));

coherence
proof
L452: C99 in ( Vars );
consider C100 being (Subset of ( Vars )), C101 being (Element of ( NAT )) such that L453: C99 = [ ( varcl C100 ) , C101 ] and L454: C100 is  finite by L452 , L297;
L455: ( C99 `1 ) = ( varcl C100 ) by L453 , MCART_1:7;
thus L456: thesis by L455 , L454 , L435;
end;
end;
theorem
L458: (for R1 being Nat holds [ ( {} ) , R1 ] in ( Vars ))
proof
let R1 being Nat;
L459: R1 in ( NAT ) by ORDINAL1:def 12;
L460: [ ( {} ) , R1 ] in { [ ( {} ) , R2 ] where R2 is (Element of ( NAT )) : (not contradiction) } by L459;
thus L461: thesis by L460 , L280;
end;
theorem
L462: (for R2 being (Element of ( NAT )) holds (for B148 being (Subset of ( Vars )) holds ( varcl { [ ( varcl B148 ) , R2 ] } ) = ( ( varcl B148 ) \/ { [ ( varcl B148 ) , R2 ] } )))
proof
let R2 being (Element of ( NAT ));
let C102 being (Subset of ( Vars ));
L463: { [ ( varcl C102 ) , R2 ] } c= ( ( varcl C102 ) \/ { [ ( varcl C102 ) , R2 ] } ) by XBOOLE_1:7;
L464: ( varcl C102 ) c= ( ( varcl C102 ) \/ { [ ( varcl C102 ) , R2 ] } ) by XBOOLE_1:7;
L465:
now
let R5 being set;
let R6 being set;
assume L466: [ R5 , R6 ] in ( ( varcl C102 ) \/ { [ ( varcl C102 ) , R2 ] } );
L467: ([ R5 , R6 ] in ( varcl C102 ) or [ R5 , R6 ] in { [ ( varcl C102 ) , R2 ] }) by L466 , XBOOLE_0:def 3;
L468: ([ R5 , R6 ] in ( varcl C102 ) or [ R5 , R6 ] = [ ( varcl C102 ) , R2 ]) by L467 , TARSKI:def 1;
L469: (R5 c= ( varcl C102 ) or R5 = ( varcl C102 )) by L468 , L73 , XTUPLE_0:1;
thus L470: R5 c= ( ( varcl C102 ) \/ { [ ( varcl C102 ) , R2 ] } ) by L469 , L464 , XBOOLE_1:1;
end;
thus L471: ( varcl { [ ( varcl C102 ) , R2 ] } ) c= ( ( varcl C102 ) \/ { [ ( varcl C102 ) , R2 ] } ) by L465 , L463 , L73;
L472: { [ ( varcl C102 ) , R2 ] } c= ( varcl { [ ( varcl C102 ) , R2 ] } ) by L73;
L473: [ ( varcl C102 ) , R2 ] in { [ ( varcl C102 ) , R2 ] } by TARSKI:def 1;
L474: ( varcl C102 ) c= ( varcl { [ ( varcl C102 ) , R2 ] } ) by L473 , L472 , L73;
thus L475: thesis by L474 , L472 , XBOOLE_1:8;
end;
theorem
L476: (for B149 being variable holds ( varcl { B149 } ) = ( ( vars B149 ) \/ { B149 } ))
proof
let C103 being variable;
L477: C103 in ( Vars );
consider C104 being (Subset of ( Vars )), R2 being (Element of ( NAT )) such that L478: C103 = [ ( varcl C104 ) , R2 ] and L479: C104 is  finite by L477 , L297;
L480: ( varcl { C103 } ) = ( ( varcl C104 ) \/ { C103 } ) by L478 , L462;
thus L481: thesis by L480 , L478 , MCART_1:7;
end;
theorem
L482: (for R1 being Nat holds (for B150 being variable holds [ ( ( vars B150 ) \/ { B150 } ) , R1 ] in ( Vars )))
proof
let R1 being Nat;
let C105 being variable;
L483: C105 in ( Vars );
consider C106 being (Subset of ( Vars )), R2 being (Element of ( NAT )) such that L484: C105 = [ ( varcl C106 ) , R2 ] and L485: C106 is  finite by L483 , L297;
L486: ( varcl { C105 } ) = ( ( varcl C106 ) \/ { C105 } ) by L484 , L462;
L487: ( vars C105 ) = ( varcl C106 ) by L484 , MCART_1:7;
L488: R1 in ( NAT ) by ORDINAL1:def 12;
thus L489: thesis by L488 , L486 , L487 , L297;
end;
begin
notation
let C107 being Relation;
let C108 being set;
synonym C107 dom C108 for C107 | C108;
end;
definition
func QuasiLoci -> (FinSequenceSet of ( Vars )) means 
:L491: (for B151 being (FinSequence of ( Vars )) holds (B151 in it iff (B151 is  one-to-one & (for R1 being Nat holds (R1 in ( dom B151 ) implies ( ( B151 . R1 ) `1 ) c= ( rng ( B151 dom R1 ) ))))));
existence
proof
defpred S8[ set ] means (ex B152 being Function st (B152 = $1 & B152 is  one-to-one & (for R1 being Nat holds (R1 in ( dom B152 ) implies ( ( B152 . R1 ) `1 ) c= ( rng ( B152 | R1 ) )))));
consider C109 being set such that L492: (for R5 being set holds (R5 in C109 iff (R5 in ( ( Vars ) * ) & S8[ R5 ]))) from XBOOLE_0:sch 1;
L493: C109 is (FinSequenceSet of ( Vars ))
proof
let R5 being set;
assume L494: R5 in C109;
L495: R5 in ( ( Vars ) * ) by L494 , L492;
thus L496: thesis by L495 , FINSEQ_1:def 11;
end;
reconsider D37 = C109 as (FinSequenceSet of ( Vars )) by L493;
take D37;
let C110 being (FinSequence of ( Vars ));
L497: (C110 in D37 iff (C110 in ( ( Vars ) * ) & (ex B153 being Function st (B153 = C110 & B153 is  one-to-one & (for R1 being Nat holds (R1 in ( dom B153 ) implies ( ( B153 . R1 ) `1 ) c= ( rng ( B153 | R1 ) ))))))) by L492;
thus L498: thesis by L497 , FINSEQ_1:def 11;
end;
correctness
proof
let C111 , C112 being (FinSequenceSet of ( Vars ));
assume that
L499: (for B154 being (FinSequence of ( Vars )) holds (B154 in C111 iff (B154 is  one-to-one & (for R1 being Nat holds (R1 in ( dom B154 ) implies ( ( B154 . R1 ) `1 ) c= ( rng ( B154 | (R1 qua set) ) ))))))
and
L500: (for B155 being (FinSequence of ( Vars )) holds (B155 in C112 iff (B155 is  one-to-one & (for R1 being Nat holds (R1 in ( dom B155 ) implies ( ( B155 . R1 ) `1 ) c= ( rng ( B155 | (R1 qua set) ) ))))));
thus L501:now
let R5 being set;
assume L502: R5 in C111;
reconsider D38 = R5 as (FinSequence of ( Vars )) by L502 , FINSEQ_2:def 3;
L503: D38 is  one-to-one by L499 , L502;
L504: (for R1 being Nat holds (R1 in ( dom D38 ) implies ( ( D38 . R1 ) `1 ) c= ( rng ( D38 | (R1 qua set) ) ))) by L499 , L502;
thus L505: R5 in C112 by L504 , L500 , L503;
end;
let R5 being set;
assume L506: R5 in C112;
reconsider D39 = R5 as (FinSequence of ( Vars )) by L506 , FINSEQ_2:def 3;
L507: D39 is  one-to-one by L500 , L506;
L508: (for R1 being Nat holds (R1 in ( dom D39 ) implies ( ( D39 . R1 ) `1 ) c= ( rng ( D39 | (R1 qua set) ) ))) by L500 , L506;
thus L509: thesis by L508 , L499 , L507;
end;
end;
theorem
L511: ( <*> ( Vars ) ) in ( QuasiLoci )
proof
reconsider D40 = ( <*> ( Vars ) ) as (FinSequence of ( Vars ));
L512: (D40 is  one-to-one & (for R1 being Nat holds (R1 in ( dom D40 ) implies ( ( D40 . R1 ) `1 ) c= ( rng ( D40 dom R1 ) ))));
thus L513: thesis by L512 , L491;
end;
registration
cluster ( QuasiLoci ) -> non  empty;
correctness by L511;
end;
definition
mode quasi-loci
 is (Element of ( QuasiLoci ));
end;
registration
cluster  ->  one-to-one for quasi-loci;
coherence by L491;
end;
theorem
L517: (for B156 being  one-to-one (FinSequence of ( Vars )) holds (B156 is quasi-loci iff (for B157 being Nat holds (for B158 being variable holds ((B157 in ( dom B156 ) & B158 = ( B156 . B157 )) implies (for B159 being variable holds (B159 in ( vars B158 ) implies (ex B160 being Nat st (B160 in ( dom B156 ) & B160 < B157 & B159 = ( B156 . B160 ))))))))))
proof
let C113 being  one-to-one (FinSequence of ( Vars ));
thus L518:now
assume L519: C113 is quasi-loci;
let C114 being Nat;
let C115 being variable;
assume that
L520: C114 in ( dom C113 )
and
L521: C115 = ( C113 . C114 );
let C116 being variable;
assume that
L522: C116 in ( vars C115 );
L523: ( vars C115 ) c= ( rng ( C113 | (C114 qua set) ) ) by L519 , L520 , L521 , L491;
consider R7 being set such that L524: R7 in ( dom ( C113 dom C114 ) ) and L525: C116 = ( ( C113 dom C114 ) . R7 ) by L523 , L522 , FUNCT_1:def 3;
L526: ( dom ( C113 dom C114 ) ) = ( ( dom C113 ) /\ C114 ) by RELAT_1:61;
reconsider D41 = R7 as (Element of ( NAT )) by L524 , L526;
reconsider D42 = D41 as Nat;
take D43 = D42;
L527: ( card D41 ) = D41 by CARD_1:def 2;
L528: ( card C114 ) = C114 by CARD_1:def 2;
thus L529: (D43 in ( dom C113 ) & D43 < C114 & C116 = ( C113 . D43 )) by L528 , L524 , L525 , L526 , L527 , FUNCT_1:47 , NAT_1:41 , XBOOLE_0:def 4;
end;
assume L530: (for B161 being Nat holds (for B162 being variable holds ((B161 in ( dom C113 ) & B162 = ( C113 . B161 )) implies (for B163 being variable holds (B163 in ( vars B162 ) implies (ex B164 being Nat st (B164 in ( dom C113 ) & B164 < B161 & B163 = ( C113 . B164 ))))))));
L531:
now
let R1 being Nat;
assume L532: R1 in ( dom C113 );
L533: ( C113 . R1 ) in ( rng C113 ) by L532 , FUNCT_1:def 3;
reconsider D44 = ( C113 . R1 ) as variable by L533;
thus L534: ( ( C113 . R1 ) `1 ) c= ( rng ( C113 dom R1 ) )
proof
let R6 being set;
assume L535: R6 in ( ( C113 . R1 ) `1 );
L536: R6 in ( vars D44 ) by L535;
reconsider D45 = R6 as variable by L536;
consider C117 being Nat such that L537: C117 in ( dom C113 ) and L538: C117 < R1 and L539: D45 = ( C113 . C117 ) by L530 , L532 , L536;
L540: ( card R1 ) = R1 by CARD_1:def 2;
L541: ( card C117 ) = C117 by CARD_1:def 2;
L542: C117 in R1 by L541 , L538 , L540 , NAT_1:41;
thus L543: thesis by L542 , L537 , L539 , FUNCT_1:50;
end;

end;
thus L535: thesis by L531 , L491;
end;
theorem
L536: (for B165 being quasi-loci holds (for B166 being variable holds (( B165 ^ <* B166 *> ) is quasi-loci iff ((not B166 in ( rng B165 )) & ( vars B166 ) c= ( rng B165 )))))
proof
let C118 being quasi-loci;
let C119 being variable;
L537: ( ( C118 ^ <* C119 *> ) . ( 1 + ( len C118 ) ) ) = C119 by FINSEQ_1:42;
L538: ( dom ( C118 ^ <* C119 *> ) ) = ( Seg ( ( len C118 ) + ( len <* C119 *> ) ) ) by FINSEQ_1:def 7
.= ( Seg ( ( len C118 ) + 1 ) ) by FINSEQ_1:39;
L539: 1 <= ( 1 + ( len C118 ) ) by NAT_1:11;
L540: ( 1 + ( len C118 ) ) in ( dom ( C118 ^ <* C119 *> ) ) by L539 , L538;
L541: ( dom C118 ) = ( Seg ( len C118 ) ) by FINSEQ_1:def 3;
thus L542:now
assume L543: ( C118 ^ <* C119 *> ) is quasi-loci;
thus L544: (not C119 in ( rng C118 ))
proof
assume L545: C119 in ( rng C118 );
consider C120 being set such that L546: C120 in ( dom C118 ) and L547: C119 = ( C118 . C120 ) by L545 , FUNCT_1:def 3;
reconsider D46 = C120 as (Element of ( NAT )) by L546;
L548: ( ( C118 ^ <* C119 *> ) . D46 ) = C119 by L546 , L547 , FINSEQ_1:def 7;
L549: D46 <= ( len C118 ) by L541 , L546 , FINSEQ_1:1;
L550: ( len C118 ) < ( 1 + ( len C118 ) ) by NAT_1:13;
L551: ( dom C118 ) c= ( dom ( C118 ^ <* C119 *> ) ) by FINSEQ_1:26;
thus L552: thesis by L551 , L537 , L540 , L543 , L546 , L548 , L549 , L550 , FUNCT_1:def 4;
end;

thus L553: ( vars C119 ) c= ( rng C118 )
proof
let C121 being set;
assume L554: C121 in ( vars C119 );
reconsider D47 = C121 as variable by L554;
consider C122 being Nat such that L555: C122 in ( dom ( C118 ^ <* C119 *> ) ) and L556: C122 < ( 1 + ( len C118 ) ) and L557: D47 = ( ( C118 ^ <* C119 *> ) . C122 ) by L537 , L540 , L543 , L554 , L517;
reconsider D48 = C122 as (Element of ( NAT )) by ORDINAL1:def 12;
L558: D48 <= ( len C118 ) by L556 , NAT_1:13;
L559: D48 >= 1 by L538 , L555 , FINSEQ_1:1;
L560: D48 in ( dom C118 ) by L559 , L541 , L558;
L561: D47 = ( C118 . D48 ) by L560 , L557 , FINSEQ_1:def 7;
thus L562: thesis by L561 , L560 , FUNCT_1:def 3;
end;

end;
assume that
L554: (not C119 in ( rng C118 ))
and
L555: ( vars C119 ) c= ( rng C118 );
L556: ( C118 ^ <* C119 *> ) is  one-to-one
proof
let C123 , C124 being set;
assume that
L557: C123 in ( dom ( C118 ^ <* C119 *> ) )
and
L558: C124 in ( dom ( C118 ^ <* C119 *> ) )
and
L559: ( ( C118 ^ <* C119 *> ) . C123 ) = ( ( C118 ^ <* C119 *> ) . C124 );
reconsider D49 = C123 , D50 = C124 as (Element of ( NAT )) by L557 , L558;
L560: D49 >= 1 by L538 , L557 , FINSEQ_1:1;
L561: D50 >= 1 by L538 , L558 , FINSEQ_1:1;
L562: D49 <= ( 1 + ( len C118 ) ) by L538 , L557 , FINSEQ_1:1;
L563: D50 <= ( 1 + ( len C118 ) ) by L538 , L558 , FINSEQ_1:1;
L564: (D49 <= ( len C118 ) or D49 = ( 1 + ( len C118 ) )) by L562 , NAT_1:8;
L565: (D50 <= ( len C118 ) or D50 = ( 1 + ( len C118 ) )) by L563 , NAT_1:8;
L566: (D49 in ( dom C118 ) or D49 = ( 1 + ( len C118 ) )) by L541 , L560 , L564;
L567: (D50 in ( dom C118 ) or D50 = ( 1 + ( len C118 ) )) by L541 , L561 , L565;
L568: ((D49 in ( dom C118 ) & ( C118 . D49 ) = ( ( C118 ^ <* C119 *> ) . D49 ) & ( C118 . D49 ) in ( rng C118 )) or D49 = ( 1 + ( len C118 ) )) by L566 , FINSEQ_1:def 7 , FUNCT_1:def 3;
L569: ((D50 in ( dom C118 ) & ( C118 . D50 ) = ( ( C118 ^ <* C119 *> ) . D50 ) & ( C118 . D50 ) in ( rng C118 )) or D50 = ( 1 + ( len C118 ) )) by L567 , FINSEQ_1:def 7 , FUNCT_1:def 3;
thus L570: thesis by L569 , L554 , L559 , L568 , FINSEQ_1:42 , FUNCT_1:def 4;
end;
L571:
now
let C125 being Nat;
let C126 being variable;
assume that
L572: C125 in ( dom ( C118 ^ <* C119 *> ) )
and
L573: C126 = ( ( C118 ^ <* C119 *> ) . C125 );
L574: C125 >= 1 by L538 , L572 , FINSEQ_1:1;
L575: C125 <= ( 1 + ( len C118 ) ) by L538 , L572 , FINSEQ_1:1;
L576: (C125 <= ( len C118 ) or C125 = ( 1 + ( len C118 ) )) by L575 , NAT_1:8;
L577: (C125 in ( dom C118 ) or (C125 = ( 1 + ( len C118 ) ) & C126 = C119)) by L576 , L541 , L572 , L573 , L574 , FINSEQ_1:42;
let C127 being variable;
assume L578: C127 in ( vars C126 );
thus L579: (ex B167 being Nat st (B167 in ( dom ( C118 ^ <* C119 *> ) ) & B167 < C125 & C127 = ( ( C118 ^ <* C119 *> ) . B167 )))
proof
per cases  by L573 , L577 , FINSEQ_1:def 7;
suppose L580: (C125 = ( 1 + ( len C118 ) ) & C126 = C119);

consider C128 being set such that L581: C128 in ( dom C118 ) and L582: C127 = ( C118 . C128 ) by L580 , L555 , L578 , FUNCT_1:def 3;
reconsider D51 = C128 as (Element of ( NAT )) by L581;
take D51;
L583: ( dom C118 ) c= ( dom ( C118 ^ <* C119 *> ) ) by FINSEQ_1:26;
L584: D51 <= ( len C118 ) by L541 , L581 , FINSEQ_1:1;
thus L585: thesis by L584 , L580 , L581 , L582 , L583 , FINSEQ_1:def 7 , NAT_1:13;
end;
suppose L586: (C125 in ( dom C118 ) & C126 = ( C118 . C125 ));

consider C129 being Nat such that L587: C129 in ( dom C118 ) and L588: C129 < C125 and L589: C127 = ( C118 . C129 ) by L586 , L578 , L517;
take C129;
L590: ( dom C118 ) c= ( dom ( C118 ^ <* C119 *> ) ) by FINSEQ_1:26;
thus L591: thesis by L590 , L587 , L588 , L589 , FINSEQ_1:def 7;
end;
end;

end;
thus L580: thesis by L571 , L556 , L517;
end;
theorem
L581: (for B168 , B169 being FinSequence holds (( B168 ^ B169 ) is quasi-loci implies (B168 is quasi-loci & B169 is (FinSequence of ( Vars )))))
proof
let C130 , C131 being FinSequence;
assume L582: ( C130 ^ C131 ) is quasi-loci;
L583: C130 is  one-to-one  one-to-one  one-to-one  one-to-one (FinSequence of ( Vars )) by L582 , FINSEQ_1:36 , FINSEQ_3:91;
L584:
now
let C132 being Nat;
let C133 being variable;
assume that
L585: C132 in ( dom C130 )
and
L586: C133 = ( C130 . C132 );
let C134 being variable;
assume that
L587: C134 in ( vars C133 );
L588: ( dom C130 ) c= ( dom ( C130 ^ C131 ) ) by FINSEQ_1:26;
L589: C133 = ( ( C130 ^ C131 ) . C132 ) by L585 , L586 , FINSEQ_1:def 7;
consider C135 being Nat such that L590: C135 in ( dom ( C130 ^ C131 ) ) and L591: C135 < C132 and L592: C134 = ( ( C130 ^ C131 ) . C135 ) by L589 , L582 , L585 , L587 , L588 , L517;
take D52 = C135;
L593: ( dom C130 ) = ( Seg ( len C130 ) ) by FINSEQ_1:def 3;
L594: ( dom ( C130 ^ C131 ) ) = ( Seg ( len ( C130 ^ C131 ) ) ) by FINSEQ_1:def 3;
L595: D52 >= 1 by L594 , L590 , FINSEQ_1:1;
L596: C132 <= ( len C130 ) by L585 , L593 , FINSEQ_1:1;
L597: D52 < ( len C130 ) by L596 , L591 , XXREAL_0:2;
thus L598: (D52 in ( dom C130 ) & D52 < C132) by L597 , L590 , L591 , L593 , L595;
thus L599: C134 = ( C130 . D52 ) by L598 , L592 , FINSEQ_1:def 7;
end;
thus L600: thesis by L584 , L582 , L583 , L517 , FINSEQ_1:36;
end;
theorem
L601: (for B170 being quasi-loci holds ( varcl ( rng B170 ) ) = ( rng B170 ))
proof
let C136 being quasi-loci;
L602:
now
let R5 being set;
let R6 being set;
assume L603: [ R5 , R6 ] in ( rng C136 );
reconsider D53 = [ R5 , R6 ] as variable by L603;
consider C137 being set such that L604: C137 in ( dom C136 ) and L605: D53 = ( C136 . C137 ) by L603 , FUNCT_1:def 3;
reconsider D54 = C137 as Nat by L604;
L606: ( vars D53 ) = R5 by MCART_1:7;
thus L607: R5 c= ( rng C136 )
proof
let C138 being set;
assume L608: C138 in R5;
reconsider D55 = C138 as variable by L608 , L606;
L609: (ex B171 being Nat st (B171 in ( dom C136 ) & B171 < D54 & D55 = ( C136 . B171 ))) by L604 , L605 , L606 , L608 , L517;
thus L610: thesis by L609 , FUNCT_1:def 3;
end;

end;
thus L608: ( varcl ( rng C136 ) ) c= ( rng C136 ) by L602 , L73;
thus L609: thesis by L73;
end;
theorem
L610: (for B172 being variable holds (<* B172 *> is quasi-loci iff ( vars B172 ) = ( {} )))
proof
let C139 being variable;
L611: <* C139 *> = ( ( <*> ( Vars ) ) ^ <* C139 *> ) by FINSEQ_1:34;
L612: ( rng ( {} ) ) = ( {} );
L613: (( vars C139 ) c= ( {} ) implies ( vars C139 ) = ( {} ));
thus L614: thesis by L613 , L611 , L612 , L511 , L536;
end;
theorem
L615: (for B173 , B174 being variable holds (<* B173 , B174 *> is quasi-loci iff (( vars B173 ) = ( {} ) & B173 <> B174 & ( vars B174 ) c= { B173 })))
proof
let C140 , C141 being variable;
L616: ( rng <* C140 *> ) = { C140 } by FINSEQ_1:38;
L617: (<* C140 *> is quasi-loci iff ( vars C140 ) = ( {} )) by L610;
L618: (C141 in { C140 } iff C141 = C140) by TARSKI:def 1;
thus L619: thesis by L618 , L616 , L617 , L536 , L581;
end;
theorem
L620: (for B175 , B176 , B177 being variable holds (<* B175 , B176 , B177 *> is quasi-loci iff (( vars B175 ) = ( {} ) & B175 <> B176 & ( vars B176 ) c= { B175 } & B175 <> B177 & B176 <> B177 & ( vars B177 ) c= { B175 , B176 })))
proof
let C142 , C143 , C144 being variable;
L621: ( rng <* C142 , C143 *> ) = { C142 , C143 } by FINSEQ_2:127;
L622: (<* C142 , C143 *> is quasi-loci iff (( vars C142 ) = ( {} ) & C142 <> C143 & ( vars C143 ) c= { C142 })) by L615;
L623: (C144 in { C142 , C143 } iff (C144 = C142 or C144 = C143)) by TARSKI:def 2;
thus L624: thesis by L623 , L621 , L622 , L536 , L581;
end;
definition
let C145 being quasi-loci;
redefine func C145 " -> (PartFunc of ( Vars ) , ( NAT ));

coherence
proof
L625: ( dom ( C145 " ) ) = ( rng C145 ) by FUNCT_1:33;
L626: ( rng ( C145 " ) ) = ( dom C145 ) by FUNCT_1:33;
thus L627: thesis by L626 , L625 , RELSET_1:4;
end;
end;
begin
definition
func a_Type equals 
( 0 );
coherence;
func an_Adj equals 
1;
coherence;
func a_Term equals 
2;
coherence;
func * equals 
( 0 );
coherence;
func non_op equals 
1;
coherence;
end;
definition
let C146 being Signature;
attr C146 is  constructor
means
:L630: ((the carrier of C146) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } & { ( * ) , ( non_op ) } c= (the carrier' of C146) & ( (the Arity of C146) . ( * ) ) = <* ( an_Adj ) , ( a_Type ) *> & ( (the Arity of C146) . ( non_op ) ) = <* ( an_Adj ) *> & ( (the ResultSort of C146) . ( * ) ) = ( a_Type ) & ( (the ResultSort of C146) . ( non_op ) ) = ( an_Adj ) & (for B178 being (Element of (the carrier' of C146)) holds ((B178 <> ( * ) & B178 <> ( non_op )) implies ( (the Arity of C146) . B178 ) in ( { ( a_Term ) } * ))));
end;
registration
cluster  constructor -> non  empty non  void for Signature;
coherence
proof
let C147 being Signature;
assume L632: (the carrier of C147) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) };
assume L633: { ( * ) , ( non_op ) } c= (the carrier' of C147);
thus L634: thesis;
end;
end;
definition
func MinConstrSign ->  strict Signature means 
:L636: (it is  constructor & (the carrier' of it) = { ( * ) , ( non_op ) });
existence
proof
set D56 = { ( a_Type ) , ( an_Adj ) , ( a_Term ) };
reconsider D57 = ( a_Type ) , D58 = ( an_Adj ) as (Element of D56) by ENUMSET1:def 1;
reconsider D59 = <* D58 *> as (Element of ( D56 * ));
set D60 = ManySortedSign (# D56 , { ( * ) , ( non_op ) } , ( (( * ) , ( non_op )) --> (<* D58 , D57 *> , D59) ) , ( (( * ) , ( non_op )) --> (D57 , D58) ) #);
reconsider D61 = D60 as non  void non  empty  strict ManySortedSign;
take D61;
thus L637: ((the carrier of D61) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } & { ( * ) , ( non_op ) } c= (the carrier' of D61));
thus L638: ( (the Arity of D61) . ( * ) ) = <* ( an_Adj ) , ( a_Type ) *> by FUNCT_4:63;
thus L639: ( (the Arity of D61) . ( non_op ) ) = <* ( an_Adj ) *> by FUNCT_4:63;
thus L640: ( (the ResultSort of D61) . ( * ) ) = ( a_Type ) by FUNCT_4:63;
thus L641: ( (the ResultSort of D61) . ( non_op ) ) = ( an_Adj ) by FUNCT_4:63;
thus L642: thesis by TARSKI:def 2;
end;
correctness
proof
let C148 , C149 being  strict Signature;
assume that
L643: C148 is  constructor
and
L644: (the carrier' of C148) = { ( * ) , ( non_op ) }
and
L645: C149 is  constructor
and
L646: (the carrier' of C149) = { ( * ) , ( non_op ) };
set D62 = { ( a_Type ) , ( an_Adj ) , ( a_Term ) };
L647: (the carrier of C148) = D62 by L643 , L630;
L648: (the carrier of C149) = D62 by L645 , L630;
L649: ( (the Arity of C148) . ( * ) ) = <* ( an_Adj ) , ( a_Type ) *> by L643 , L630;
L650: ( (the Arity of C149) . ( * ) ) = <* ( an_Adj ) , ( a_Type ) *> by L645 , L630;
L651: ( (the Arity of C148) . ( non_op ) ) = <* ( an_Adj ) *> by L643 , L630;
L652: ( (the Arity of C149) . ( non_op ) ) = <* ( an_Adj ) *> by L645 , L630;
L653: ( (the ResultSort of C148) . ( * ) ) = ( a_Type ) by L643 , L630;
L654: ( (the ResultSort of C149) . ( * ) ) = ( a_Type ) by L645 , L630;
L655: ( (the ResultSort of C148) . ( non_op ) ) = ( an_Adj ) by L643 , L630;
L656: ( (the ResultSort of C149) . ( non_op ) ) = ( an_Adj ) by L645 , L630;
L657: ( dom (the Arity of C148) ) = { ( * ) , ( non_op ) } by L644 , FUNCT_2:def 1;
L658: ( dom (the Arity of C149) ) = { ( * ) , ( non_op ) } by L646 , FUNCT_2:def 1;
L659: (the Arity of C148) = ( (( * ) , ( non_op )) --> (<* ( an_Adj ) , ( a_Type ) *> , <* ( an_Adj ) *>) ) by L649 , L651 , L657 , FUNCT_4:66;
L660: (the Arity of C149) = ( (( * ) , ( non_op )) --> (<* ( an_Adj ) , ( a_Type ) *> , <* ( an_Adj ) *>) ) by L650 , L652 , L658 , FUNCT_4:66;
L661: ( dom (the ResultSort of C148) ) = { ( * ) , ( non_op ) } by L643 , L644 , FUNCT_2:def 1;
L662: ( dom (the ResultSort of C149) ) = { ( * ) , ( non_op ) } by L645 , L646 , FUNCT_2:def 1;
L663: (the ResultSort of C148) = ( (( * ) , ( non_op )) --> (( a_Type ) , ( an_Adj )) ) by L653 , L655 , L661 , FUNCT_4:66;
thus L664: thesis by L663 , L644 , L646 , L647 , L648 , L654 , L656 , L659 , L660 , L662 , FUNCT_4:66;
end;
end;
registration
cluster ( MinConstrSign ) ->  constructor;
coherence by L636;
end;
registration
cluster  constructor  strict for Signature;
existence
proof
take ( MinConstrSign );
thus L667: thesis;
end;
end;
definition
mode ConstructorSignature
 is  constructor Signature;
end;
definition
let C150 being ConstructorSignature;
let C151 being (OperSymbol of C150);
attr C151 is  constructor
means
:L670: (C151 <> ( * ) & C151 <> ( non_op ));
end;
theorem
L672: (for B179 being ConstructorSignature holds (for B180 being (OperSymbol of B179) holds (B180 is  constructor implies ( the_arity_of B180 ) = ( ( len ( the_arity_of B180 ) ) |-> ( a_Term ) ))))
proof
let C152 being ConstructorSignature;
let C153 being (OperSymbol of C152);
assume that
L673: C153 <> ( * )
and
L674: C153 <> ( non_op );
reconsider D63 = ( a_Term ) as (Element of { ( a_Term ) }) by TARSKI:def 1;
L675: ( len ( ( len ( the_arity_of C153 ) ) |-> ( a_Term ) ) ) = ( len ( the_arity_of C153 ) ) by CARD_1:def 7;
L676: ( the_arity_of C153 ) in ( { ( a_Term ) } * ) by L673 , L674 , L630;
L677: ( ( len ( the_arity_of C153 ) ) |-> D63 ) in ( { ( a_Term ) } * ) by FINSEQ_1:def 11;
thus L678: thesis by L677 , L675 , L676 , L35;
end;
definition
let C154 being non  empty non  void Signature;
attr C154 is  initialized
means
:L679: (ex B181 , B182 being (OperSymbol of C154) st (( the_result_sort_of B181 ) = ( a_Type ) & ( the_arity_of B181 ) = ( {} ) & ( the_result_sort_of B182 ) = ( an_Adj ) & ( the_arity_of B182 ) = ( {} )));
end;
definition
let C155 being ConstructorSignature;
L681: (the carrier of C155) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
func a_Type C155 -> (SortSymbol of C155) equals 
( a_Type );
coherence by L681 , ENUMSET1:def 1;
func an_Adj C155 -> (SortSymbol of C155) equals 
( an_Adj );
coherence by L681 , ENUMSET1:def 1;
func a_Term C155 -> (SortSymbol of C155) equals 
( a_Term );
coherence by L681 , ENUMSET1:def 1;
L682: { ( * ) , ( non_op ) } c= (the carrier' of C155) by L630;
L683: ( * ) in { ( * ) , ( non_op ) } by TARSKI:def 2;
L684: ( non_op ) in { ( * ) , ( non_op ) } by TARSKI:def 2;
func non_op C155 -> (OperSymbol of C155) equals 
( non_op );
coherence by L682 , L684;
func ast C155 -> (OperSymbol of C155) equals 
( * );
coherence by L682 , L683;
end;
theorem
L686: (for B183 being ConstructorSignature holds (( the_arity_of ( non_op B183 ) ) = <* ( an_Adj B183 ) *> & ( the_result_sort_of ( non_op B183 ) ) = ( an_Adj B183 ) & ( the_arity_of ( ast B183 ) ) = <* ( an_Adj B183 ) , ( a_Type B183 ) *> & ( the_result_sort_of ( ast B183 ) ) = ( a_Type B183 ))) by L630;
definition
func Modes equals 
[: { ( a_Type ) } , [: ( QuasiLoci ) , ( NAT ) :] :];
correctness;
func Attrs equals 
[: { ( an_Adj ) } , [: ( QuasiLoci ) , ( NAT ) :] :];
correctness;
func Funcs equals 
[: { ( a_Term ) } , [: ( QuasiLoci ) , ( NAT ) :] :];
correctness;
end;
registration
cluster ( Modes ) -> non  empty;
coherence;
cluster ( Attrs ) -> non  empty;
coherence;
cluster ( Funcs ) -> non  empty;
coherence;
end;
definition
func Constructors -> non  empty set equals 
( ( ( Modes ) \/ ( Attrs ) ) \/ ( Funcs ) );
coherence;
end;
theorem
L690: { ( * ) , ( non_op ) } misses ( Constructors )
proof
assume L691: (not thesis);
consider R5 being set such that L692: R5 in { ( * ) , ( non_op ) } and L693: R5 in ( Constructors ) by L691 , XBOOLE_0:3;
L694: (R5 in ( ( Modes ) \/ ( Attrs ) ) or R5 in ( Funcs )) by L693 , XBOOLE_0:def 3;
L695: (R5 in ( Modes ) or R5 in ( Attrs ) or R5 in ( Funcs )) by L694 , XBOOLE_0:def 3;
consider C156 , C157 being set such that L696: R5 in [: C156 , C157 :] by L695;
L697: (ex R6 being set st (ex R7 being set st (R6 in C156 & R7 in C157 & [ R6 , R7 ] = R5))) by L696 , ZFMISC_1:def 2;
L698: (R5 = ( * ) or R5 = ( non_op )) by L692 , TARSKI:def 2;
L699: (( the_rank_of R5 ) = ( 0 ) or ( the_rank_of R5 ) = 1) by L698 , CLASSES1:73;
L700: ( the_rank_of R5 ) c= 1 by L699;
L701: ( the_rank_of R5 ) in ( succ ( succ ( {} ) ) ) by L700 , ORDINAL1:6 , ORDINAL1:12;
L702: R5 in ( Rank ( succ ( succ ( {} ) ) ) ) by L701 , CLASSES1:66;
thus L703: thesis by L702 , L697 , CLASSES1:29 , CLASSES1:45;
end;
definition
let C158 being (Element of [: ( QuasiLoci ) , ( NAT ) :]);
redefine func C158 `1 -> quasi-loci;

coherence by MCART_1:10;
redefine func C158 `2 -> (Element of ( NAT ));

coherence by MCART_1:10;
end;
notation
let C159 being (Element of ( Constructors ));
synonym kind_of C159 for C159 `1;
end;
definition
let C160 being (Element of ( Constructors ));
redefine func kind_of C160 -> (Element of { ( a_Type ) , ( an_Adj ) , ( a_Term ) });

coherence
proof
L706: (C160 in ( ( Modes ) \/ ( Attrs ) ) or C160 in ( Funcs )) by XBOOLE_0:def 3;
L707: (C160 in ( Modes ) or C160 in ( Attrs ) or C160 in ( Funcs )) by L706 , XBOOLE_0:def 3;
L708: (( C160 `1 ) in { ( a_Type ) } or ( C160 `1 ) in { ( an_Adj ) } or ( C160 `1 ) in { ( a_Term ) }) by L707 , MCART_1:10;
L709: (( C160 `1 ) = ( a_Type ) or ( C160 `1 ) = ( an_Adj ) or ( C160 `1 ) = ( a_Term )) by L708 , TARSKI:def 1;
thus L710: thesis by L709 , ENUMSET1:def 1;
end;
redefine func C160 `2 -> (Element of [: ( QuasiLoci ) , ( NAT ) :]);

coherence
proof
L711: (C160 in ( ( Modes ) \/ ( Attrs ) ) or C160 in ( Funcs )) by XBOOLE_0:def 3;
L712: (C160 in ( Modes ) or C160 in ( Attrs ) or C160 in ( Funcs )) by L711 , XBOOLE_0:def 3;
thus L713: thesis by L712 , MCART_1:10;
end;
end;
definition
let C161 being (Element of ( Constructors ));
func loci_of C161 -> quasi-loci equals 
( ( C161 `2 ) `1 );
coherence;
func index_of C161 -> Nat equals 
( ( C161 `2 ) `2 );
coherence;
end;
theorem
L716: (for B184 being (Element of ( Constructors )) holds ((( kind_of B184 ) = ( a_Type ) iff B184 in ( Modes )) & (( kind_of B184 ) = ( an_Adj ) iff B184 in ( Attrs )) & (( kind_of B184 ) = ( a_Term ) iff B184 in ( Funcs ))))
proof
let C162 being (Element of ( Constructors ));
L717: (C162 in ( ( Modes ) \/ ( Attrs ) ) or C162 in ( Funcs )) by XBOOLE_0:def 3;
L718: (C162 in ( Modes ) implies ( C162 `1 ) in { ( a_Type ) }) by MCART_1:10;
L719: (C162 in ( Attrs ) implies ( C162 `1 ) in { ( an_Adj ) }) by MCART_1:10;
L720: (C162 in ( Funcs ) implies ( C162 `1 ) in { ( a_Term ) }) by MCART_1:10;
thus L721: thesis by L720 , L717 , L718 , L719 , TARSKI:def 1 , XBOOLE_0:def 3;
end;
definition
func MaxConstrSign ->  strict ConstructorSignature means 
:L722: ((the carrier' of it) = ( { ( * ) , ( non_op ) } \/ ( Constructors ) ) & (for B185 being (OperSymbol of it) holds (B185 is  constructor implies (( (the ResultSort of it) . B185 ) = ( B185 `1 ) & ( card ( (the Arity of it) . B185 ) ) = ( card ( ( B185 `2 ) `1 ) )))));
existence
proof
set D64 = { ( a_Type ) , ( an_Adj ) , ( a_Term ) };
set D65 = ( { ( * ) , ( non_op ) } \/ ( Constructors ) );
deffunc H3((Element of ( Constructors ))) = ( ( len ( loci_of $1 ) ) |-> ( a_Term ) );
consider C163 being (ManySortedSet of ( Constructors )) such that L723: (for B186 being (Element of ( Constructors )) holds ( C163 . B186 ) = H3(B186)) from PBOOLE:sch 5;
deffunc H4((Element of ( Constructors ))) = ( kind_of $1 );
consider C164 being (ManySortedSet of ( Constructors )) such that L724: (for B187 being (Element of ( Constructors )) holds ( C164 . B187 ) = H4(B187)) from PBOOLE:sch 5;
reconsider D66 = ( a_Type ) , D67 = ( an_Adj ) , D68 = ( a_Term ) as (Element of D64) by ENUMSET1:def 1;
reconsider D69 = <* D67 *> as (Element of ( D64 * ));
set D70 = ( C163 +* ( (( * ) , ( non_op )) --> (<* D67 , D66 *> , D69) ) );
set D71 = ( C164 +* ( (( * ) , ( non_op )) --> (D66 , D67) ) );
L725: ( dom ( (( * ) , ( non_op )) --> (<* D67 , D66 *> , D69) ) ) = { ( * ) , ( non_op ) } by FUNCT_4:62;
L726: ( dom ( (( * ) , ( non_op )) --> (D66 , D67) ) ) = { ( * ) , ( non_op ) } by FUNCT_4:62;
L727: ( dom C163 ) = ( Constructors ) by PARTFUN1:def 2;
L728: ( dom C164 ) = ( Constructors ) by PARTFUN1:def 2;
L729: ( dom D70 ) = D65 by L725 , L727 , FUNCT_4:def 1;
L730: ( dom D71 ) = D65 by L726 , L728 , FUNCT_4:def 1;
L731: ( rng C163 ) c= ( D64 * )
proof
let R6 being set;
assume L732: R6 in ( rng C163 );
consider R5 being set such that L733: R5 in ( Constructors ) and L734: R6 = ( C163 . R5 ) by L732 , L727 , FUNCT_1:def 3;
reconsider D72 = R5 as (Element of ( Constructors )) by L733;
L735: R6 = ( ( len ( loci_of D72 ) ) |-> D68 ) by L723 , L734;
thus L736: thesis by L735 , FINSEQ_1:def 11;
end;
L737: ( ( rng C163 ) \/ ( rng ( (( * ) , ( non_op )) --> (<* D67 , D66 *> , D69) ) ) ) c= ( ( D64 * ) \/ ( D64 * ) ) by L731 , XBOOLE_1:13;
L738: ( rng C164 ) c= D64
proof
let R6 being set;
assume L739: R6 in ( rng C164 );
consider R5 being set such that L740: R5 in ( Constructors ) and L741: R6 = ( C164 . R5 ) by L739 , L728 , FUNCT_1:def 3;
reconsider D73 = R5 as (Element of ( Constructors )) by L740;
L742: R6 = ( kind_of D73 ) by L724 , L741;
thus L743: thesis by L742;
end;
L744: ( ( rng C164 ) \/ ( rng ( (( * ) , ( non_op )) --> (D66 , D67) ) ) ) c= ( D64 \/ D64 ) by L738 , XBOOLE_1:13;
L745: ( rng D70 ) c= ( ( rng C163 ) \/ ( rng ( (( * ) , ( non_op )) --> (<* D67 , D66 *> , D69) ) ) ) by FUNCT_4:17;
reconsider D74 = D70 as (Function of D65 , ( D64 * )) by L745 , L729 , L737 , FUNCT_2:2 , XBOOLE_1:1;
L746: ( rng D71 ) c= ( ( rng C164 ) \/ ( rng ( (( * ) , ( non_op )) --> (D66 , D67) ) ) ) by FUNCT_4:17;
reconsider D75 = D71 as (Function of D65 , D64) by L746 , L730 , L744 , FUNCT_2:2 , XBOOLE_1:1;
reconsider D76 = ManySortedSign (# D64 , D65 , D74 , D75 #) as non  empty non  void  strict Signature;
L747: D76 is  constructor
proof
thus L748: (the carrier of D76) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) };
thus L749: { ( * ) , ( non_op ) } c= (the carrier' of D76) by XBOOLE_1:7;
L750: ( * ) in { ( * ) , ( non_op ) } by TARSKI:def 2;
L751: ( non_op ) in { ( * ) , ( non_op ) } by TARSKI:def 2;
thus L752: ( (the Arity of D76) . ( * ) ) = ( ( (( * ) , ( non_op )) --> (<* D67 , D66 *> , D69) ) . ( * ) ) by L725 , L750 , FUNCT_4:13
.= <* ( an_Adj ) , ( a_Type ) *> by FUNCT_4:63;
thus L753: ( (the Arity of D76) . ( non_op ) ) = ( ( (( * ) , ( non_op )) --> (<* D67 , D66 *> , D69) ) . ( non_op ) ) by L725 , L751 , FUNCT_4:13
.= <* ( an_Adj ) *> by FUNCT_4:63;
thus L754: ( (the ResultSort of D76) . ( * ) ) = ( ( (( * ) , ( non_op )) --> (D66 , D67) ) . ( * ) ) by L726 , L750 , FUNCT_4:13
.= ( a_Type ) by FUNCT_4:63;
thus L755: ( (the ResultSort of D76) . ( non_op ) ) = ( ( (( * ) , ( non_op )) --> (D66 , D67) ) . ( non_op ) ) by L726 , L751 , FUNCT_4:13
.= ( an_Adj ) by FUNCT_4:63;
let C165 being (Element of (the carrier' of D76));
assume that
L756: C165 <> ( * )
and
L757: C165 <> ( non_op );
L758: (not C165 in { ( * ) , ( non_op ) }) by L756 , L757 , TARSKI:def 2;
reconsider D77 = C165 as (Element of ( Constructors )) by L758 , XBOOLE_0:def 3;
reconsider D78 = D68 as (Element of { ( a_Term ) }) by TARSKI:def 1;
L759: ( (the Arity of D76) . C165 ) = ( C163 . D77 ) by L725 , L727 , L758 , FUNCT_4:def 1
.= ( ( len ( loci_of D77 ) ) |-> D78 ) by L723;
thus L760: ( (the Arity of D76) . C165 ) in ( { ( a_Term ) } * ) by L759 , FINSEQ_1:def 11;
end;
reconsider D79 = D76 as  strict ConstructorSignature by L747;
take D79;
thus L761: (the carrier' of D79) = ( { ( * ) , ( non_op ) } \/ ( Constructors ) );
let C166 being (OperSymbol of D79);
assume that
L762: C166 <> ( * )
and
L763: C166 <> ( non_op );
L764: (not C166 in { ( * ) , ( non_op ) }) by L762 , L763 , TARSKI:def 2;
reconsider D80 = C166 as (Element of ( Constructors )) by L764 , XBOOLE_0:def 3;
thus L765: ( (the ResultSort of D79) . C166 ) = ( C164 . D80 ) by L726 , L728 , L764 , FUNCT_4:def 1
.= ( C166 `1 ) by L724;
thus L766: ( card ( (the Arity of D79) . C166 ) ) = ( card ( C163 . D80 ) ) by L725 , L727 , L764 , FUNCT_4:def 1
.= ( card H3(D80) ) by L723
.= ( card ( ( C166 `2 ) `1 ) ) by CARD_1:def 7;
end;
uniqueness
proof
let C167 , C168 being  strict ConstructorSignature;
assume that
L767: (the carrier' of C167) = ( { ( * ) , ( non_op ) } \/ ( Constructors ) )
and
L768: (for B188 being (OperSymbol of C167) holds (B188 is  constructor implies (( (the ResultSort of C167) . B188 ) = ( B188 `1 ) & ( card ( (the Arity of C167) . B188 ) ) = ( card ( ( B188 `2 ) `1 ) ))))
and
L769: (the carrier' of C168) = ( { ( * ) , ( non_op ) } \/ ( Constructors ) )
and
L770: (for B189 being (OperSymbol of C168) holds (B189 is  constructor implies (( (the ResultSort of C168) . B189 ) = ( B189 `1 ) & ( card ( (the Arity of C168) . B189 ) ) = ( card ( ( B189 `2 ) `1 ) ))));
set D81 = { ( a_Type ) , ( an_Adj ) , ( a_Term ) };
L771: (the carrier of C167) = D81 by L630;
L772: (the carrier of C168) = D81 by L630;
L773:
now
let C169 being (Element of ( Constructors ));
reconsider D82 = C169 as (OperSymbol of C167) by L767 , XBOOLE_0:def 3;
reconsider D83 = D82 as (OperSymbol of C168) by L767 , L769;
assume that
L774: C169 <> ( * )
and
L775: C169 <> ( non_op );
L776: D82 is  constructor by L774 , L775 , L670;
L777: D83 is  constructor by L774 , L775 , L670;
L778: ( card ( (the Arity of C167) . D82 ) ) = ( card ( ( C169 `2 ) `1 ) ) by L768 , L776;
L779: ( card ( (the Arity of C168) . D83 ) ) = ( card ( ( C169 `2 ) `1 ) ) by L770 , L777;
L780: ( (the Arity of C167) . D82 ) in ( { ( a_Term ) } * ) by L774 , L775 , L630;
L781: ( (the Arity of C168) . D83 ) in ( { ( a_Term ) } * ) by L774 , L775 , L630;
reconsider D84 = ( (the Arity of C167) . D82 ) , D85 = ( (the Arity of C168) . D83 ) as (FinSequence of { ( a_Term ) }) by L781 , L780 , FINSEQ_1:def 11;
L782: ( dom D84 ) = ( Seg ( len D84 ) ) by FINSEQ_1:def 3;
L783: ( dom D85 ) = ( Seg ( len D85 ) ) by FINSEQ_1:def 3;
L784:
now
let C170 being Nat;
assume L785: C170 in ( dom D84 );
L786: ( D84 . C170 ) in ( rng D84 ) by L785 , FUNCT_1:def 3;
L787: ( D85 . C170 ) in ( rng D85 ) by L778 , L779 , L782 , L783 , L785 , FUNCT_1:def 3;
L788: ( D84 . C170 ) = ( a_Term ) by L786 , TARSKI:def 1;
thus L789: ( D84 . C170 ) = ( D85 . C170 ) by L788 , L787 , TARSKI:def 1;
end;
thus L790: ( (the Arity of C167) . C169 ) = ( (the Arity of C168) . C169 ) by L784 , L778 , L779 , L782 , L783 , FINSEQ_1:13;
end;
L791:
now
let C171 being (OperSymbol of C167);
L792: (C171 in { ( * ) , ( non_op ) } or (not C171 in { ( * ) , ( non_op ) }));
L793: (C171 = ( * ) or C171 = ( non_op ) or (C171 in ( Constructors ) & C171 <> ( * ) & C171 <> ( non_op ))) by L792 , L767 , TARSKI:def 2 , XBOOLE_0:def 3;
L794: ((( (the Arity of C167) . C171 ) = <* ( an_Adj ) , ( a_Type ) *> & ( (the Arity of C168) . C171 ) = <* ( an_Adj ) , ( a_Type ) *>) or (( (the Arity of C167) . C171 ) = <* ( an_Adj ) *> & ( (the Arity of C168) . C171 ) = <* ( an_Adj ) *>) or ( (the Arity of C167) . C171 ) = ( (the Arity of C168) . C171 )) by L793 , L773 , L630;
thus L795: ( (the Arity of C167) . C171 ) = ( (the Arity of C168) . C171 ) by L794;
end;
L796: (the Arity of C167) = (the Arity of C168) by L791 , L767 , L769 , L771 , L772 , FUNCT_2:63;
L797:
now
let C172 being (OperSymbol of C167);
reconsider D86 = C172 as (OperSymbol of C168) by L767 , L769;
L798: ((not C172 in { ( * ) , ( non_op ) }) or C172 in { ( * ) , ( non_op ) });
L799: (C172 = ( * ) or C172 = ( non_op ) or (C172 in ( Constructors ) & C172 is  constructor & D86 is  constructor)) by L798 , L767 , L670 , TARSKI:def 2 , XBOOLE_0:def 3;
L800: ((( (the ResultSort of C167) . C172 ) = ( a_Type ) & ( (the ResultSort of C168) . C172 ) = ( a_Type )) or (( (the ResultSort of C167) . C172 ) = ( an_Adj ) & ( (the ResultSort of C168) . C172 ) = ( an_Adj )) or (( (the ResultSort of C167) . C172 ) = ( C172 `1 ) & ( (the ResultSort of C168) . C172 ) = ( C172 `1 ))) by L799 , L768 , L770 , L630;
thus L801: ( (the ResultSort of C167) . C172 ) = ( (the ResultSort of C168) . C172 ) by L800;
end;
thus L802: thesis by L797 , L767 , L769 , L771 , L772 , L796 , FUNCT_2:63;
end;
end;
registration
cluster ( MinConstrSign ) -> non  initialized;
correctness
proof
given C173 , C174 being (OperSymbol of ( MinConstrSign )) such that
L804: ( the_result_sort_of C173 ) = ( a_Type )
and
L805: ( the_arity_of C173 ) = ( {} )
and
L806: ( the_result_sort_of C174 ) = ( an_Adj )
and
L807: ( the_arity_of C174 ) = ( {} );

L808: (the carrier' of ( MinConstrSign )) = { ( * ) , ( non_op ) } by L636;
L809: (C173 = ( * ) or C173 = ( non_op )) by L808 , TARSKI:def 2;
thus L810: contradiction by L809 , L805 , L630;
end;
cluster ( MaxConstrSign ) ->  initialized;
correctness
proof
set D87 = [ ( a_Type ) , [ ( {} ) , ( 0 ) ] ];
set D88 = [ ( an_Adj ) , [ ( {} ) , ( 0 ) ] ];
L811: ( a_Type ) in { ( a_Type ) } by TARSKI:def 1;
L812: ( an_Adj ) in { ( an_Adj ) } by TARSKI:def 1;
L813: [ ( <*> ( Vars ) ) , ( 0 ) ] in [: ( QuasiLoci ) , ( NAT ) :] by L511 , ZFMISC_1:def 2;
L814: D87 in ( Modes ) by L813 , L811 , ZFMISC_1:def 2;
L815: D88 in ( Attrs ) by L812 , L813 , ZFMISC_1:def 2;
L816: D87 in ( ( Modes ) \/ ( Attrs ) ) by L814 , XBOOLE_0:def 3;
L817: D88 in ( ( Modes ) \/ ( Attrs ) ) by L815 , XBOOLE_0:def 3;
L818: D87 in ( Constructors ) by L816 , XBOOLE_0:def 3;
L819: D88 in ( Constructors ) by L817 , XBOOLE_0:def 3;
L820: (the carrier' of ( MaxConstrSign )) = ( { ( * ) , ( non_op ) } \/ ( Constructors ) ) by L722;
reconsider D89 = D87 , D90 = D88 as (OperSymbol of ( MaxConstrSign )) by L820 , L818 , L819 , XBOOLE_0:def 3;
L821: D89 is  constructor by L670;
L822: D90 is  constructor by L670;
take D89;
take D90;
thus L823: ( the_result_sort_of D89 ) = ( D89 `1 ) by L821 , L722
.= ( a_Type ) by MCART_1:7;
L824: ( len ( the_arity_of D89 ) ) = ( card ( ( D89 `2 ) `1 ) ) by L821 , L722
.= ( card ( [ ( {} ) , ( 0 ) ] `1 ) ) by MCART_1:7
.= ( 0 );
thus L825: ( the_arity_of D89 ) = ( {} ) by L824;
thus L826: ( the_result_sort_of D90 ) = ( D90 `1 ) by L822 , L722
.= ( an_Adj ) by MCART_1:7;
L827: ( len ( the_arity_of D90 ) ) = ( card ( ( D90 `2 ) `1 ) ) by L822 , L722
.= ( card ( [ ( {} ) , ( 0 ) ] `1 ) ) by MCART_1:7
.= ( 0 );
thus L828: thesis by L827;
end;
end;
registration
cluster  initialized  strict for ConstructorSignature;
correctness
proof
take ( MaxConstrSign );
thus L830: thesis;
end;
end;
registration
let C175 being  initialized ConstructorSignature;
cluster  constructor for (OperSymbol of C175);
existence
proof
consider C176 , C177 being (OperSymbol of C175) such that L832: ( the_result_sort_of C176 ) = ( a_Type ) and L833: ( the_arity_of C176 ) = ( {} ) and L834: ( the_result_sort_of C177 ) = ( an_Adj ) and L835: ( the_arity_of C177 ) = ( {} ) by L679;
take C176;
thus L836: C176 <> ( * ) by L833 , L630;
thus L837: thesis by L832 , L630;
end;
end;
begin
definition
let C178 being ConstructorSignature;
L839: (the carrier of C178) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
func MSVars C178 -> (ManySortedSet of (the carrier of C178)) means 
:L840: (( it . ( a_Type ) ) = ( {} ) & ( it . ( an_Adj ) ) = ( {} ) & ( it . ( a_Term ) ) = ( Vars ));
uniqueness
proof
let C179 , C180 being (ManySortedSet of (the carrier of C178));
assume that
L841: ( C179 . ( a_Type ) ) = ( {} )
and
L842: ( C179 . ( an_Adj ) ) = ( {} )
and
L843: ( C179 . ( a_Term ) ) = ( Vars )
and
L844: ( C180 . ( a_Type ) ) = ( {} )
and
L845: ( C180 . ( an_Adj ) ) = ( {} )
and
L846: ( C180 . ( a_Term ) ) = ( Vars );
L847:
now
let R5 being set;
assume L848: R5 in (the carrier of C178);
L849: (R5 = ( a_Type ) or R5 = ( an_Adj ) or R5 = ( a_Term )) by L848 , L839 , ENUMSET1:def 1;
thus L850: ( C179 . R5 ) = ( C180 . R5 ) by L849 , L841 , L842 , L843 , L844 , L845 , L846;
end;
thus L851: thesis by L847 , PBOOLE:3;
end;
existence
proof
deffunc H5(set) = ( IFEQ ($1 , ( a_Term ) , ( Vars ) , ( {} )) );
consider C181 being (ManySortedSet of (the carrier of C178)) such that L852: (for R5 being set holds (R5 in (the carrier of C178) implies ( C181 . R5 ) = H5(R5))) from PBOOLE:sch 4;
take C181;
L853: ( IFEQ (( a_Type ) , ( a_Term ) , ( Vars ) , ( {} )) ) = ( {} ) by FUNCOP_1:def 8;
L854: ( IFEQ (( an_Adj ) , ( a_Term ) , ( Vars ) , ( {} )) ) = ( {} ) by FUNCOP_1:def 8;
L855: ( IFEQ (( a_Term ) , ( a_Term ) , ( Vars ) , ( {} )) ) = ( Vars ) by FUNCOP_1:def 8;
L856: ( a_Type ) in (the carrier of C178) by L839 , ENUMSET1:def 1;
L857: ( an_Adj ) in (the carrier of C178) by L839 , ENUMSET1:def 1;
L858: ( a_Term ) in (the carrier of C178) by L839 , ENUMSET1:def 1;
thus L859: thesis by L858 , L852 , L853 , L854 , L855 , L856 , L857;
end;
end;
registration
let C182 being ConstructorSignature;
cluster ( MSVars C182 ) -> non  empty-yielding;
coherence
proof
take ( a_Term );
L861: (the carrier of C182) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
thus L862: ( a_Term ) in (the carrier of C182) by L861 , ENUMSET1:def 1;
thus L863: thesis by L840;
end;
end;
registration
let C183 being  initialized ConstructorSignature;
cluster ( Free (C183 , ( MSVars C183 )) ) ->  non-empty;
correctness
proof
set D91 = ( MSVars C183 );
consider C184 , C185 being (OperSymbol of C183) such that L865: ( the_result_sort_of C184 ) = ( a_Type ) and L866: ( the_arity_of C184 ) = ( {} ) and L867: ( the_result_sort_of C185 ) = ( an_Adj ) and L868: ( the_arity_of C185 ) = ( {} ) by L679;
L869: ( root-tree [ C184 , (the carrier of C183) ] ) in ( (the Sorts of ( Free (C183 , D91) )) . ( a_Type ) ) by L865 , L866 , MSAFREE3:5;
L870: ( root-tree [ C185 , (the carrier of C183) ] ) in ( (the Sorts of ( Free (C183 , D91) )) . ( an_Adj ) ) by L867 , L868 , MSAFREE3:5;
set D92 = the variable;
L871: ( a_Term C183 ) = ( a_Term );
L872: ( ( MSVars C183 ) . ( a_Term ) ) = ( Vars ) by L840;
L873: ( root-tree [ D92 , ( a_Term ) ] ) in ( (the Sorts of ( Free (C183 , D91) )) . ( a_Term ) ) by L872 , L871 , MSAFREE3:4;
assume L874: (not (the Sorts of ( Free (C183 , D91) )) is  non-empty);
L875: ( {} ) in ( rng (the Sorts of ( Free (C183 , D91) )) ) by L874 , RELAT_1:def 9;
consider C186 being set such that L876: C186 in ( dom (the Sorts of ( Free (C183 , D91) )) ) and L877: ( {} ) = ( (the Sorts of ( Free (C183 , D91) )) . C186 ) by L875 , FUNCT_1:def 3;
L878: C186 in (the carrier of C183) by L876;
L879: C186 in { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L878 , L630;
thus L880: thesis by L879 , L869 , L870 , L873 , L877 , ENUMSET1:def 1;
end;
end;
definition
let C187 being non  void Signature;
let C188 being non  empty-yielding (ManySortedSet of (the carrier of C187));
let C189 being (Element of ( Free (C187 , C188) ));
attr C189 is  ground
means
( Union ( C187 variables_in C189 ) ) = ( {} );
attr C189 is  compound
means
:L882: ( C189 . ( {} ) ) in [: (the carrier' of C187) , { (the carrier of C187) } :];
end;
definition
let R8 being  initialized ConstructorSignature;
mode expression of R8
 is (Element of ( Free (R8 , ( MSVars R8 )) ));
end;
definition
let R8 being  initialized ConstructorSignature;
let R9 being (SortSymbol of R8);
mode expression of R8 , R9
 -> (expression of R8)
means :L885: it in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . R9 );
existence
proof
set D93 = the (Element of ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . R9 ));
L886: ( dom (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) = (the carrier of R8) by PARTFUN1:def 2;
L887: D93 in ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by L886 , CARD_5:2;
thus L888: thesis by L887;
end;
end;
theorem
L890: (for R7 being set holds (for R8 being  initialized ConstructorSignature holds (for R9 being (SortSymbol of R8) holds (R7 is (expression of R8 , R9) iff R7 in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . R9 )))))
proof
let R7 being set;
let R8 being  initialized ConstructorSignature;
let R9 being (SortSymbol of R8);
L891: ( dom (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) = (the carrier of R8) by PARTFUN1:def 2;
L892: ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . R9 ) c= ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) )
proof
let R5 being set;
thus L893: thesis by L891 , CARD_5:2;
end;
thus L894: thesis by L892 , L885;
end;
definition
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
assume that
L895: ( len ( the_arity_of R11 ) ) = ( 0 );
func R11 term -> (expression of R8) equals 
( [ R11 , (the carrier of R8) ] -tree ( {} ) );
coherence
proof
L896: ( the_arity_of R11 ) = ( {} ) by L895;
L897: ( root-tree [ R11 , (the carrier of R8) ] ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( the_result_sort_of R11 ) ) by L896 , MSAFREE3:5;
L898: ( dom (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) = (the carrier of R8) by PARTFUN1:def 2;
L899: ( root-tree [ R11 , (the carrier of R8) ] ) in ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by L898 , L897 , CARD_5:2;
thus L900: thesis by L899 , TREES_4:20;
end;
end;
theorem
L902: (for R8 being  initialized ConstructorSignature holds (for R10 being (OperSymbol of R8) holds (( len ( the_arity_of R10 ) ) = 1 implies (for B190 being (expression of R8) holds ((ex R9 being (SortSymbol of R8) st (R9 = ( ( the_arity_of R10 ) . 1 ) & B190 is (expression of R8 , R9))) implies ( [ R10 , (the carrier of R8) ] -tree <* B190 *> ) is (expression of R8 , ( the_result_sort_of R10 )))))))
proof
let R8 being  initialized ConstructorSignature;
let C190 being (OperSymbol of R8);
assume that
L903: ( len ( the_arity_of C190 ) ) = 1;
set D94 = ( MSVars R8 );
set D95 = ( D94 \/ ( (the carrier of R8) --> { ( 0 ) } ) );
let C191 being (expression of R8);
given C192 being (SortSymbol of R8) such that
L904: C192 = ( ( the_arity_of C190 ) . 1 )
and
L905: C191 is (expression of R8 , C192);

reconsider D96 = C191 as (Term of R8 , D95) by MSAFREE3:8;
L906: ( dom <* D96 *> ) = ( Seg 1 ) by FINSEQ_1:38;
L907: ( dom <* C192 *> ) = ( Seg 1 ) by FINSEQ_1:38;
L908: ( the_arity_of C190 ) = <* C192 *> by L903 , L904 , FINSEQ_1:40;
L909: (the Sorts of ( Free (R8 , D94) )) = ( R8 -Terms (D94 , D95) ) by MSAFREE3:24;
L910:
now
let C193 being Nat;
assume L911: C193 in ( dom <* D96 *> );
L912: C193 = 1 by L911 , L906 , FINSEQ_1:2 , TARSKI:def 1;
let C194 being (Term of R8 , D95);
assume L913: C194 = ( <* D96 *> . C193 );
L914: (the Sorts of ( Free (R8 , D94) )) c= (the Sorts of ( FreeMSA D95 )) by L909 , PBOOLE:def 18;
L915: C194 = C191 by L912 , L913 , FINSEQ_1:40;
L916: ( (the Sorts of ( Free (R8 , D94) )) . C192 ) c= ( (the Sorts of ( FreeMSA D95 )) . C192 ) by L914 , PBOOLE:def 2;
L917: C194 in ( (the Sorts of ( Free (R8 , D94) )) . C192 ) by L905 , L915 , L890;
thus L918: ( the_sort_of C194 ) = ( ( the_arity_of C190 ) . C193 ) by L917 , L904 , L912 , L916 , MSAFREE3:7;
end;
reconsider D97 = <* D96 *> as (ArgumentSeq of ( Sym (C190 , D95) )) by L910 , L906 , L907 , L908 , MSATERM:25;
L919: ( variables_in ( ( Sym (C190 , D95) ) -tree D97 ) ) c= D94
proof
let C195 being set;
assume L920: C195 in (the carrier of R8);
reconsider D98 = C195 as (SortSymbol of R8) by L920;
let R5 being set;
assume L921: R5 in ( ( variables_in ( ( Sym (C190 , D95) ) -tree D97 ) ) . C195 );
consider C196 being DecoratedTree such that L922: C196 in ( rng D97 ) and L923: R5 in ( ( R8 variables_in C196 ) . D98 ) by L921 , MSAFREE3:11;
L924: ( R8 variables_in C191 ) c= D94 by MSAFREE3:27;
L925: ( rng D97 ) = { C191 } by FINSEQ_1:38;
L926: ( ( R8 variables_in C191 ) . D98 ) c= ( D94 . D98 ) by L924 , PBOOLE:def 2;
L927: C196 = C191 by L922 , L925 , TARSKI:def 1;
thus L928: thesis by L927 , L923 , L926;
end;
set D99 = ( the_result_sort_of C190 );
L929: ( the_sort_of ( ( Sym (C190 , D95) ) -tree D97 ) ) = ( the_result_sort_of C190 ) by MSATERM:20;
L930: ( (the Sorts of ( Free (R8 , D94) )) . D99 ) = { B191 where B191 is (Term of R8 , D95) : (( the_sort_of B191 ) = D99 & ( variables_in B191 ) c= D94) } by L909 , MSAFREE3:def 5;
L931: ( [ C190 , (the carrier of R8) ] -tree <* C191 *> ) in ( (the Sorts of ( Free (R8 , D94) )) . D99 ) by L930 , L919 , L929;
thus L932: thesis by L931 , L890;
end;
definition
let R8 being  initialized ConstructorSignature;
let R10 being (OperSymbol of R8);
assume that
L933: ( len ( the_arity_of R10 ) ) = 1;
let C197 being (expression of R8);
assume that
L934: (ex B192 being (SortSymbol of R8) st (B192 = ( ( the_arity_of R10 ) . 1 ) & C197 is (expression of R8 , B192)));
func R10 term C197 -> (expression of R8) equals 
:L935: ( [ R10 , (the carrier of R8) ] -tree <* C197 *> );
coherence by L933 , L934 , L902;
end;
theorem
L937: (for R8 being  initialized ConstructorSignature holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (( ( non_op R8 ) term R12 ) is (expression of R8 , ( an_Adj R8 )) & ( ( non_op R8 ) term R12 ) = ( [ ( non_op ) , (the carrier of R8) ] -tree <* R12 *> ))))
proof
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
L938: ( the_result_sort_of ( non_op R8 ) ) = ( an_Adj R8 ) by L630;
L939: ( the_arity_of ( non_op R8 ) ) = <* ( an_Adj R8 ) *> by L630;
L940: ( len ( the_arity_of ( non_op R8 ) ) ) = 1 by L939 , FINSEQ_1:40;
L941: ( ( the_arity_of ( non_op R8 ) ) . 1 ) = ( an_Adj R8 ) by L939 , FINSEQ_1:40;
L942: ( ( non_op R8 ) term R12 ) = ( [ ( non_op ) , (the carrier of R8) ] -tree <* R12 *> ) by L941 , L940 , L935;
thus L943: thesis by L942 , L938 , L940 , L941 , L902;
end;
theorem
L944: (for R8 being  initialized ConstructorSignature holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (for R13 being (expression of R8 , ( an_Adj R8 )) holds (( ( non_op R8 ) term R12 ) = ( ( non_op R8 ) term R13 ) implies R12 = R13))))
proof
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
let R13 being (expression of R8 , ( an_Adj R8 ));
assume L945: ( ( non_op R8 ) term R12 ) = ( ( non_op R8 ) term R13 );
L946: ( [ ( non_op ) , (the carrier of R8) ] -tree <* R12 *> ) = ( ( non_op R8 ) term R13 ) by L945 , L937
.= ( [ ( non_op ) , (the carrier of R8) ] -tree <* R13 *> ) by L937;
L947: <* R12 *> = <* R13 *> by L946 , TREES_4:15;
thus L948: thesis by L947 , FINSEQ_1:76;
end;
registration
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
cluster ( ( non_op R8 ) term R12 ) ->  compound;
coherence
proof
L949: ( ( non_op R8 ) term R12 ) = ( [ ( non_op ) , (the carrier of R8) ] -tree <* R12 *> ) by L937;
L950: ( ( ( non_op R8 ) term R12 ) . ( {} ) ) = [ ( non_op R8 ) , (the carrier of R8) ] by L949 , TREES_4:def 4;
thus L951: ( ( ( non_op R8 ) term R12 ) . ( {} ) ) in [: (the carrier' of R8) , { (the carrier of R8) } :] by L950 , ZFMISC_1:106;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  compound for (expression of R8);
existence
proof
set D100 = the (expression of R8 , ( an_Adj R8 ));
L953: ( ( non_op R8 ) term D100 ) is  compound;
thus L954: thesis by L953;
end;
end;
theorem
L956: (for R8 being  initialized ConstructorSignature holds (for R10 being (OperSymbol of R8) holds (( len ( the_arity_of R10 ) ) = 2 implies (for B193 , B194 being (expression of R8) holds ((ex B195 , B196 being (SortSymbol of R8) st (B195 = ( ( the_arity_of R10 ) . 1 ) & B196 = ( ( the_arity_of R10 ) . 2 ) & B193 is (expression of R8 , B195) & B194 is (expression of R8 , B196))) implies ( [ R10 , (the carrier of R8) ] -tree <* B193 , B194 *> ) is (expression of R8 , ( the_result_sort_of R10 )))))))
proof
let R8 being  initialized ConstructorSignature;
let C198 being (OperSymbol of R8);
assume that
L957: ( len ( the_arity_of C198 ) ) = 2;
set D101 = ( MSVars R8 );
set D102 = ( D101 \/ ( (the carrier of R8) --> { ( 0 ) } ) );
let C199 , C200 being (expression of R8);
given C201 , C202 being (SortSymbol of R8) such that
L958: C201 = ( ( the_arity_of C198 ) . 1 )
and
L959: C202 = ( ( the_arity_of C198 ) . 2 )
and
L960: C199 is (expression of R8 , C201)
and
L961: C200 is (expression of R8 , C202);

reconsider D103 = C199 , D104 = C200 as (Term of R8 , D102) by MSAFREE3:8;
L962: ( dom <* D103 , D104 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L963: ( dom <* C201 , C202 *> ) = ( Seg 2 ) by FINSEQ_1:89;
L964: ( the_arity_of C198 ) = <* C201 , C202 *> by L957 , L958 , L959 , FINSEQ_1:44;
L965: (the Sorts of ( Free (R8 , D101) )) = ( R8 -Terms (D101 , D102) ) by MSAFREE3:24;
L966:
now
let C203 being Nat;
assume L967: C203 in ( dom <* D103 , D104 *> );
L968: (C203 = 1 or C203 = 2) by L967 , L962 , FINSEQ_1:2 , TARSKI:def 2;
let C204 being (Term of R8 , D102);
assume L969: C204 = ( <* D103 , D104 *> . C203 );
L970: (the Sorts of ( Free (R8 , D101) )) c= (the Sorts of ( FreeMSA D102 )) by L965 , PBOOLE:def 18;
L971: ((C203 = 1 & C204 = C199) or (C203 = 2 & C204 = C200)) by L968 , L969 , FINSEQ_1:44;
L972: ( (the Sorts of ( Free (R8 , D101) )) . C201 ) c= ( (the Sorts of ( FreeMSA D102 )) . C201 ) by L970 , PBOOLE:def 2;
L973: ( (the Sorts of ( Free (R8 , D101) )) . C202 ) c= ( (the Sorts of ( FreeMSA D102 )) . C202 ) by L970 , PBOOLE:def 2;
L974: ((C203 = 1 & C204 in ( (the Sorts of ( Free (R8 , D101) )) . C201 )) or (C203 = 2 & C204 in ( (the Sorts of ( Free (R8 , D101) )) . C202 ))) by L960 , L961 , L971 , L890;
thus L975: ( the_sort_of C204 ) = ( ( the_arity_of C198 ) . C203 ) by L974 , L958 , L959 , L972 , L973 , MSAFREE3:7;
end;
reconsider D105 = <* D103 , D104 *> as (ArgumentSeq of ( Sym (C198 , D102) )) by L966 , L962 , L963 , L964 , MSATERM:25;
L976: ( variables_in ( ( Sym (C198 , D102) ) -tree D105 ) ) c= D101
proof
let C205 being set;
assume L977: C205 in (the carrier of R8);
reconsider D106 = C205 as (SortSymbol of R8) by L977;
let R5 being set;
assume L978: R5 in ( ( variables_in ( ( Sym (C198 , D102) ) -tree D105 ) ) . C205 );
consider C206 being DecoratedTree such that L979: C206 in ( rng D105 ) and L980: R5 in ( ( R8 variables_in C206 ) . D106 ) by L978 , MSAFREE3:11;
L981: ( R8 variables_in C199 ) c= D101 by MSAFREE3:27;
L982: ( R8 variables_in C200 ) c= D101 by MSAFREE3:27;
L983: ( rng D105 ) = { C199 , C200 } by FINSEQ_2:127;
L984: ( ( R8 variables_in C199 ) . D106 ) c= ( D101 . D106 ) by L981 , PBOOLE:def 2;
L985: ( ( R8 variables_in C200 ) . D106 ) c= ( D101 . D106 ) by L982 , PBOOLE:def 2;
L986: (C206 = C199 or C206 = C200) by L979 , L983 , TARSKI:def 2;
thus L987: thesis by L986 , L980 , L984 , L985;
end;
set D107 = ( the_result_sort_of C198 );
L988: ( the_sort_of ( ( Sym (C198 , D102) ) -tree D105 ) ) = ( the_result_sort_of C198 ) by MSATERM:20;
L989: ( (the Sorts of ( Free (R8 , D101) )) . D107 ) = { B197 where B197 is (Term of R8 , D102) : (( the_sort_of B197 ) = D107 & ( variables_in B197 ) c= D101) } by L965 , MSAFREE3:def 5;
L990: ( [ C198 , (the carrier of R8) ] -tree <* C199 , C200 *> ) in ( (the Sorts of ( Free (R8 , D101) )) . D107 ) by L989 , L976 , L988;
thus L991: thesis by L990 , L890;
end;
definition
let R8 being  initialized ConstructorSignature;
let R10 being (OperSymbol of R8);
assume that
L992: ( len ( the_arity_of R10 ) ) = 2;
let C207 , C208 being (expression of R8);
assume that
L993: (ex B198 , B199 being (SortSymbol of R8) st (B198 = ( ( the_arity_of R10 ) . 1 ) & B199 = ( ( the_arity_of R10 ) . 2 ) & C207 is (expression of R8 , B198) & C208 is (expression of R8 , B199)));
func R10 term (C207 , C208) -> (expression of R8) equals 
:L994: ( [ R10 , (the carrier of R8) ] -tree <* C207 , C208 *> );
coherence by L992 , L993 , L956;
end;
theorem
L996: (for R8 being  initialized ConstructorSignature holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (for R14 being (expression of R8 , ( a_Type R8 )) holds (( ( ast R8 ) term (R12 , R14) ) is (expression of R8 , ( a_Type R8 )) & ( ( ast R8 ) term (R12 , R14) ) = ( [ ( * ) , (the carrier of R8) ] -tree <* R12 , R14 *> )))))
proof
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
let R14 being (expression of R8 , ( a_Type R8 ));
L997: ( the_result_sort_of ( ast R8 ) ) = ( a_Type R8 ) by L630;
L998: ( the_arity_of ( ast R8 ) ) = <* ( an_Adj R8 ) , ( a_Type R8 ) *> by L630;
L999: ( len ( the_arity_of ( ast R8 ) ) ) = 2 by L998 , FINSEQ_1:44;
L1000: ( ( the_arity_of ( ast R8 ) ) . 1 ) = ( an_Adj R8 ) by L998 , FINSEQ_1:44;
L1001: ( ( the_arity_of ( ast R8 ) ) . 2 ) = ( a_Type R8 ) by L998 , FINSEQ_1:44;
L1002: ( ( ast R8 ) term (R12 , R14) ) = ( [ ( * ) , (the carrier of R8) ] -tree <* R12 , R14 *> ) by L1001 , L999 , L1000 , L994;
thus L1003: thesis by L1002 , L997 , L999 , L1000 , L1001 , L956;
end;
theorem
L1004: (for R8 being  initialized ConstructorSignature holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (for R13 being (expression of R8 , ( an_Adj R8 )) holds (for R15 being (expression of R8 , ( a_Type R8 )) holds (for R16 being (expression of R8 , ( a_Type R8 )) holds (( ( ast R8 ) term (R12 , R15) ) = ( ( ast R8 ) term (R13 , R16) ) implies (R12 = R13 & R15 = R16)))))))
proof
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
let R13 being (expression of R8 , ( an_Adj R8 ));
let R15 being (expression of R8 , ( a_Type R8 ));
let R16 being (expression of R8 , ( a_Type R8 ));
assume L1005: ( ( ast R8 ) term (R12 , R15) ) = ( ( ast R8 ) term (R13 , R16) );
L1006: ( [ ( * ) , (the carrier of R8) ] -tree <* R12 , R15 *> ) = ( ( ast R8 ) term (R13 , R16) ) by L1005 , L996
.= ( [ ( * ) , (the carrier of R8) ] -tree <* R13 , R16 *> ) by L996;
L1007: <* R12 , R15 *> = <* R13 , R16 *> by L1006 , TREES_4:15;
thus L1008: thesis by L1007 , FINSEQ_1:77;
end;
registration
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
let R14 being (expression of R8 , ( a_Type R8 ));
cluster ( ( ast R8 ) term (R12 , R14) ) ->  compound;
coherence
proof
L1009: ( ( ast R8 ) term (R12 , R14) ) = ( [ ( * ) , (the carrier of R8) ] -tree <* R12 , R14 *> ) by L996;
L1010: ( ( ( ast R8 ) term (R12 , R14) ) . ( {} ) ) = [ ( ast R8 ) , (the carrier of R8) ] by L1009 , TREES_4:def 4;
thus L1011: ( ( ( ast R8 ) term (R12 , R14) ) . ( {} ) ) in [: (the carrier' of R8) , { (the carrier of R8) } :] by L1010 , ZFMISC_1:106;
end;
end;
definition
let C209 being non  void Signature;
let C210 being (SortSymbol of C209);
assume that
L1013: (ex B200 being (OperSymbol of C209) st ( the_result_sort_of B200 ) = C210);
mode OperSymbol of C210
 -> (OperSymbol of C209)
means ( the_result_sort_of it ) = C210;
existence by L1013;
end;
definition
let C211 being ConstructorSignature;
redefine func non_op C211 -> (OperSymbol of ( an_Adj C211 ));

coherence
proof
L1015: ( the_result_sort_of ( non_op C211 ) ) = ( an_Adj C211 ) by L630;
thus L1016: (ex B201 being (OperSymbol of C211) st ( the_result_sort_of B201 ) = ( an_Adj C211 )) by L1015;
thus L1017: thesis by L630;
end;
redefine func ast C211 -> (OperSymbol of ( a_Type C211 ));

coherence
proof
L1018: ( the_result_sort_of ( ast C211 ) ) = ( a_Type C211 ) by L630;
thus L1019: (ex B202 being (OperSymbol of C211) st ( the_result_sort_of B202 ) = ( a_Type C211 )) by L1018;
thus L1020: thesis by L630;
end;
end;
theorem
L1022: (for R8 being  initialized ConstructorSignature holds (for B203 , B204 being (SortSymbol of R8) holds (B203 <> B204 implies (for B205 being (expression of R8 , B203) holds (for B206 being (expression of R8 , B204) holds B205 <> B206)))))
proof
let R8 being  initialized ConstructorSignature;
set D108 = ( MSVars R8 );
set D109 = ( D108 \/ ( (the carrier of R8) --> { ( 0 ) } ) );
L1023: (ex B207 being (MSSubset of ( FreeMSA D109 )) st (( Free (R8 , D108) ) = ( GenMSAlg B207 ) & B207 = ( ( Reverse D109 ) "" D108 ))) by MSAFREE3:def 1;
let C212 , C213 being (SortSymbol of R8);
L1024: (the Sorts of ( Free (R8 , D108) )) is (MSSubset of ( FreeMSA D109 )) by L1023 , MSUALG_2:def 9;
L1025: (the Sorts of ( Free (R8 , D108) )) c= (the Sorts of ( FreeMSA D109 )) by L1024 , PBOOLE:def 18;
L1026: ( (the Sorts of ( Free (R8 , D108) )) . C212 ) c= ( (the Sorts of ( FreeMSA D109 )) . C212 ) by L1025 , PBOOLE:def 2;
L1027: ( (the Sorts of ( Free (R8 , D108) )) . C213 ) c= ( (the Sorts of ( FreeMSA D109 )) . C213 ) by L1025 , PBOOLE:def 2;
assume L1028: C212 <> C213;
L1029: ( (the Sorts of ( FreeMSA D109 )) . C212 ) misses ( (the Sorts of ( FreeMSA D109 )) . C213 ) by L1028 , PROB_2:def 2;
let C214 being (expression of R8 , C212);
let C215 being (expression of R8 , C213);
L1030: C214 in ( (the Sorts of ( Free (R8 , D108) )) . C212 ) by L885;
L1031: C215 in ( (the Sorts of ( Free (R8 , D108) )) . C213 ) by L885;
thus L1032: thesis by L1031 , L1026 , L1027 , L1029 , L1030 , XBOOLE_0:3;
end;
begin
definition
let R8 being  initialized ConstructorSignature;
L1033: ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Term R8 ) ) c= ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) )
proof
let R5 being set;
L1034: ( dom (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) = (the carrier of R8) by PARTFUN1:def 2;
thus L1035: thesis by L1034 , CARD_5:2;
end;
func QuasiTerms R8 -> (Subset of ( Free (R8 , ( MSVars R8 )) )) equals 
( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Term R8 ) );
coherence by L1033;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster ( QuasiTerms R8 ) -> non  empty  constituted-DTrees;
coherence
proof
thus L1037: ( QuasiTerms R8 ) is non  empty;
let R5 being set;
assume L1038: R5 in ( QuasiTerms R8 );
thus L1039: thesis by L1038;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
mode quasi-term of R8
 is (expression of R8 , ( a_Term R8 ));
end;
theorem
L1042: (for R7 being set holds (for R8 being  initialized ConstructorSignature holds (R7 is (quasi-term of R8) iff R7 in ( QuasiTerms R8 )))) by L890;
definition
let C216 being variable;
let R8 being  initialized ConstructorSignature;
func C216 -term R8 -> (quasi-term of R8) equals 
( root-tree [ C216 , ( a_Term ) ] );
coherence
proof
L1043: ( ( MSVars R8 ) . ( a_Term ) ) = ( Vars ) by L840;
L1044: ( root-tree [ C216 , ( a_Term ) ] ) in ( QuasiTerms R8 ) by L1043 , MSAFREE3:4;
thus L1045: thesis by L1044 , L890;
end;
end;
theorem
L1047: (for B208 , B209 being variable holds (for B210 , B211 being  initialized ConstructorSignature holds (( B208 -term B210 ) = ( B209 -term B211 ) implies B208 = B209)))
proof
let C217 , C218 being variable;
let C219 , C220 being  initialized ConstructorSignature;
assume L1048: ( C217 -term C219 ) = ( C218 -term C220 );
L1049: [ C217 , ( a_Term ) ] = [ C218 , ( a_Term ) ] by L1048 , TREES_4:4;
thus L1050: thesis by L1049 , XTUPLE_0:1;
end;
registration
let C221 being variable;
let R8 being  initialized ConstructorSignature;
cluster ( C221 -term R8 ) -> non  compound;
coherence
proof
L1051: ( a_Term R8 ) in (the carrier of R8);
L1052: ( a_Term R8 ) <> (the carrier of R8) by L1051;
L1053: ( ( C221 -term R8 ) . ( {} ) ) = [ C221 , ( a_Term R8 ) ] by TREES_4:3;
L1054: ( a_Term R8 ) nin { (the carrier of R8) } by L1052 , TARSKI:def 1;
thus L1055: ( ( C221 -term R8 ) . ( {} ) ) nin [: (the carrier' of R8) , { (the carrier of R8) } :] by L1054 , L1053 , ZFMISC_1:87;
end;
end;
theorem
L1057: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for B212 being  DTree-yielding FinSequence holds (( [ R11 , (the carrier of R8) ] -tree B212 ) is (expression of R8) iff (( len B212 ) = ( len ( the_arity_of R11 ) ) & B212 in ( ( QuasiTerms R8 ) * ))))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
set D110 = R11;
L1058: D110 <> ( * ) by L670;
L1059: D110 <> ( non_op ) by L670;
let C222 being  DTree-yielding FinSequence;
set D111 = ( ( MSVars R8 ) \/ ( (the carrier of R8) --> { ( 0 ) } ) );
L1060: (the Sorts of ( Free (R8 , ( MSVars R8 )) )) = ( R8 -Terms (( MSVars R8 ) , D111) ) by MSAFREE3:24;
thus L1061:now
assume L1062: ( [ D110 , (the carrier of R8) ] -tree C222 ) is (expression of R8);
L1063: ( [ D110 , (the carrier of R8) ] -tree C222 ) is (Term of R8 , D111) by L1062 , MSAFREE3:8;
L1064: C222 is (ArgumentSeq of ( Sym (D110 , D111) )) by L1063 , MSATERM:1;
thus L1065: ( len C222 ) = ( len ( the_arity_of D110 ) ) by L1064 , MSATERM:22;
reconsider D112 = C222 as (ArgumentSeq of ( Sym (D110 , D111) )) by L1063 , MSATERM:1;
L1066: ( the_sort_of ( ( Sym (D110 , D111) ) -tree D112 ) ) = ( the_result_sort_of D110 ) by MSATERM:20;
L1067: ( variables_in ( ( Sym (D110 , D111) ) -tree D112 ) ) c= ( MSVars R8 ) by L1062 , MSAFREE3:27;
L1068: ( ( R8 -Terms (( MSVars R8 ) , D111) ) . ( the_result_sort_of D110 ) ) = { B213 where B213 is (Term of R8 , D111) : (( the_sort_of B213 ) = ( the_result_sort_of D110 ) & ( variables_in B213 ) c= ( MSVars R8 )) } by MSAFREE3:def 5;
L1069: ( ( Sym (D110 , D111) ) -tree C222 ) in ( ( R8 -Terms (( MSVars R8 ) , D111) ) . ( the_result_sort_of D110 ) ) by L1068 , L1066 , L1067;
L1070: ( rng C222 ) c= ( Union ( R8 -Terms (( MSVars R8 ) , D111) ) ) by L1069 , L1064 , MSAFREE3:19;
L1071: ( rng C222 ) c= ( QuasiTerms R8 )
proof
let C223 being set;
assume L1072: C223 in ( rng C222 );
reconsider D113 = C223 as (expression of R8) by L1072 , L1070 , MSAFREE3:24;
consider C224 being set such that L1073: C224 in ( dom C222 ) and L1074: C223 = ( C222 . C224 ) by L1072 , FUNCT_1:def 3;
reconsider D114 = C224 as Nat by L1073;
reconsider D115 = ( C222 . D114 ) as (Term of R8 , D111) by L1064 , L1073 , MSATERM:22;
L1075: ( (the Arity of R8) . D110 ) in ( { ( a_Term ) } * ) by L1058 , L1059 , L630;
L1076: ( dom C222 ) = ( dom ( the_arity_of D110 ) ) by L1064 , MSATERM:22;
L1077: ( the_arity_of D110 ) is (FinSequence of { ( a_Term ) }) by L1075 , FINSEQ_1:def 11;
L1078: ( ( the_arity_of D110 ) . D114 ) in ( rng ( the_arity_of D110 ) ) by L1073 , L1076 , FUNCT_1:def 3;
L1079: ( rng ( the_arity_of D110 ) ) c= { ( a_Term R8 ) } by L1077 , FINSEQ_1:def 4;
L1080: ( ( the_arity_of D110 ) . D114 ) = ( a_Term R8 ) by L1079 , L1078 , TARSKI:def 1;
L1081: ( the_sort_of D115 ) = ( a_Term R8 ) by L1080 , L1064 , L1073 , MSATERM:23;
L1082: D115 = D113 by L1074;
L1083: ( variables_in D115 ) c= ( MSVars R8 ) by L1082 , MSAFREE3:27;
L1084: D115 in { B214 where B214 is (Term of R8 , D111) : (( the_sort_of B214 ) = ( a_Term R8 ) & ( variables_in B214 ) c= ( MSVars R8 )) } by L1083 , L1081;
L1085: D115 in ( ( R8 -Terms (( MSVars R8 ) , D111) ) . ( a_Term R8 ) ) by L1084 , MSAFREE3:def 5;
thus L1086: thesis by L1085 , L1074 , MSAFREE3:23;
end;
L1087: C222 is (FinSequence of ( QuasiTerms R8 )) by L1071 , FINSEQ_1:def 4;
thus L1088: C222 in ( ( QuasiTerms R8 ) * ) by L1087 , FINSEQ_1:def 11;
end;
assume L1089: ( len C222 ) = ( len ( the_arity_of D110 ) );
assume L1090: C222 in ( ( QuasiTerms R8 ) * );
L1091: ( Free (R8 , ( MSVars R8 )) ) = ( ( FreeMSA D111 ) | ( R8 -Terms (( MSVars R8 ) , D111) ) ) by MSAFREE3:25;
L1092: (the Sorts of ( Free (R8 , ( MSVars R8 )) )) is (ManySortedSubset of (the Sorts of ( FreeMSA D111 ))) by L1091 , MSUALG_2:def 9;
L1093: (the Sorts of ( Free (R8 , ( MSVars R8 )) )) c= (the Sorts of ( FreeMSA D111 )) by L1092 , PBOOLE:def 18;
L1094: ( QuasiTerms R8 ) c= ( (the Sorts of ( FreeMSA D111 )) . ( a_Term R8 ) ) by L1093 , PBOOLE:def 2;
L1095: C222 is (FinSequence of ( QuasiTerms R8 )) by L1090 , FINSEQ_1:def 11;
L1096: ( rng C222 ) c= ( QuasiTerms R8 ) by L1095 , FINSEQ_1:def 4;
L1097:
now
let C225 being Nat;
assume L1098: C225 in ( dom C222 );
L1099: ( C222 . C225 ) in ( rng C222 ) by L1098 , FUNCT_1:def 3;
L1100: ( C222 . C225 ) in ( QuasiTerms R8 ) by L1099 , L1096;
reconsider D116 = ( C222 . C225 ) as (expression of R8) by L1100;
L1101: ( (the Arity of R8) . D110 ) in ( { ( a_Term ) } * ) by L1058 , L1059 , L630;
L1102: ( dom C222 ) = ( dom ( the_arity_of D110 ) ) by L1089 , FINSEQ_3:29;
L1103: ( the_arity_of D110 ) is (FinSequence of { ( a_Term ) }) by L1101 , FINSEQ_1:def 11;
L1104: ( ( the_arity_of D110 ) . C225 ) in ( rng ( the_arity_of D110 ) ) by L1098 , L1102 , FUNCT_1:def 3;
L1105: ( rng ( the_arity_of D110 ) ) c= { ( a_Term R8 ) } by L1103 , FINSEQ_1:def 4;
L1106: ( ( the_arity_of D110 ) . C225 ) = ( a_Term R8 ) by L1105 , L1104 , TARSKI:def 1;
reconsider D117 = D116 as (Term of R8 , D111) by MSAFREE3:8;
take D118 = D117;
thus L1107: D118 = ( C222 . C225 );
L1108: D118 in ( (the Sorts of ( FreeMSA D111 )) . ( a_Term R8 ) ) by L1094 , L1100;
L1109: D118 in ( FreeSort (D111 , ( a_Term R8 )) ) by L1108 , MSAFREE:def 11;
thus L1110: ( the_sort_of D118 ) = ( ( the_arity_of D110 ) . C225 ) by L1109 , L1106 , MSATERM:def 5;
end;
L1111: C222 is (ArgumentSeq of ( Sym (D110 , D111) )) by L1097 , L1089 , MSATERM:24;
L1112: ( dom (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) = (the carrier of R8) by PARTFUN1:def 2;
L1113: ( rng C222 ) c= ( Union ( R8 -Terms (( MSVars R8 ) , D111) ) ) by L1060 , L1095 , FINSEQ_1:def 4;
L1114: ( ( Sym (D110 , D111) ) -tree C222 ) in ( ( R8 -Terms (( MSVars R8 ) , D111) ) . ( the_result_sort_of D110 ) ) by L1113 , L1111 , MSAFREE3:19;
thus L1115: thesis by L1114 , L1060 , L1112 , CARD_5:2;
end;
definition
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R17 being (FinSequence of ( QuasiTerms R8 ));
assume that
L1116: ( len R17 ) = ( len ( the_arity_of R11 ) );
L1117: R17 in ( ( QuasiTerms R8 ) * ) by FINSEQ_1:def 11;
func R11 -trm R17 ->  compound (expression of R8) equals 
:L1118: ( [ R11 , (the carrier of R8) ] -tree R17 );
coherence
proof
reconsider D119 = ( [ R11 , (the carrier of R8) ] -tree R17 ) as (expression of R8) by L1116 , L1117 , L1057;
L1119: ( D119 . ( {} ) ) = [ R11 , (the carrier of R8) ] by TREES_4:def 4;
L1120: ( D119 . ( {} ) ) in [: (the carrier' of R8) , { (the carrier of R8) } :] by L1119 , ZFMISC_1:106;
thus L1121: thesis by L1120 , L882;
end;
end;
theorem
L1123: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (( len R17 ) = ( len ( the_arity_of R11 ) ) implies ( R11 -trm R17 ) is (expression of R8 , ( the_result_sort_of R11 ))))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R17 being (FinSequence of ( QuasiTerms R8 ));
set D120 = ( MSVars R8 );
set D121 = ( D120 \/ ( (the carrier of R8) --> { ( 0 ) } ) );
assume L1124: ( len R17 ) = ( len ( the_arity_of R11 ) );
L1125: ( ( Sym (R11 , D121) ) -tree R17 ) = ( R11 -trm R17 ) by L1124 , L1118;
L1126: (the Sorts of ( Free (R8 , D120) )) = ( R8 -Terms (D120 , D121) ) by MSAFREE3:24;
L1127: ( R11 -trm R17 ) is (Term of R8 , D121) by MSAFREE3:8;
reconsider D122 = R17 as (ArgumentSeq of ( Sym (R11 , D121) )) by L1127 , L1125 , MSATERM:1;
L1128: ( rng D122 ) c= ( Union (the Sorts of ( Free (R8 , D120) )) ) by FINSEQ_1:def 4;
L1129: ( R11 -trm R17 ) in ( ( R8 -Terms (D120 , D121) ) . ( the_result_sort_of R11 ) ) by L1128 , L1125 , L1126 , MSAFREE3:19;
thus L1130: thesis by L1129 , L1126 , L885;
end;
theorem
L1131: (for R8 being  initialized ConstructorSignature holds (for B215 being (expression of R8) holds ((ex B216 being variable st B215 = ( B216 -term R8 )) or (ex B217 being  constructor (OperSymbol of R8) st (ex B218 being (FinSequence of ( QuasiTerms R8 )) st (( len B218 ) = ( len ( the_arity_of B217 ) ) & B215 = ( B217 -trm B218 )))) or (ex B219 being (expression of R8 , ( an_Adj R8 )) st B215 = ( ( non_op R8 ) term B219 )) or (ex B220 being (expression of R8 , ( an_Adj R8 )) st (ex B221 being (expression of R8 , ( a_Type R8 )) st B215 = ( ( ast R8 ) term (B220 , B221) ))))))
proof
let R8 being  initialized ConstructorSignature;
let C226 being (expression of R8);
set D123 = ( MSVars R8 );
set D124 = ( D123 \/ ( (the carrier of R8) --> { ( 0 ) } ) );
per cases  by L50;
suppose L1132: (ex B222 being (SortSymbol of R8) st (ex B223 being set st (C226 = ( root-tree [ B223 , B222 ] ) & B223 in ( D123 . B222 ))));

consider C227 being (SortSymbol of R8), C228 being set such that L1133: C226 = ( root-tree [ C228 , C227 ] ) and L1134: C228 in ( D123 . C227 ) by L1132;
L1135: (the carrier of R8) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
L1136: (C227 = ( a_Term ) or C227 = ( an_Adj ) or C227 = ( a_Type )) by L1135 , ENUMSET1:def 1;
reconsider D125 = C228 as variable by L1136 , L1134 , L840;
L1137: C226 = ( D125 -term R8 ) by L1133 , L1134 , L1136 , L840;
thus L1138: thesis by L1137;
end;
suppose L1139: (ex B224 being (OperSymbol of R8) st (ex B225 being (FinSequence of ( Free (R8 , D123) )) st (C226 = ( [ B224 , (the carrier of R8) ] -tree B225 ) & ( len B225 ) = ( len ( the_arity_of B224 ) ) & B225 is  DTree-yielding & B225 is (ArgumentSeq of ( Sym (B224 , D124) )))));

consider C229 being (OperSymbol of R8), C230 being (FinSequence of ( Free (R8 , D123) )) such that L1140: C226 = ( [ C229 , (the carrier of R8) ] -tree C230 ) and L1141: ( len C230 ) = ( len ( the_arity_of C229 ) ) and L1142: C230 is  DTree-yielding and L1143: C230 is (ArgumentSeq of ( Sym (C229 , D124) )) by L1139;
per cases  by L670;
suppose L1144: C229 = ( * );

L1145: ( the_arity_of C229 ) = <* ( an_Adj ) , ( a_Type ) *> by L1144 , L630;
L1146: ( dom C230 ) = ( dom ( the_arity_of C229 ) ) by L1143 , MSATERM:22;
L1147: ( dom ( the_arity_of C229 ) ) = ( Seg 2 ) by L1145 , FINSEQ_1:89;
L1148: ( len ( the_arity_of C229 ) ) = 2 by L1145 , FINSEQ_1:44;
L1149: 1 in ( Seg 2 );
L1150: 2 in ( Seg 2 );
L1151: ( C230 . 1 ) in ( rng C230 ) by L1146 , L1147 , L1149 , FUNCT_1:3;
L1152: ( C230 . 2 ) in ( rng C230 ) by L1146 , L1147 , L1150 , FUNCT_1:3;
reconsider D126 = ( C230 . 1 ) , D127 = ( C230 . 2 ) as (expression of R8) by L1152 , L1151;
reconsider D128 = D126 , D129 = D127 as (Term of R8 , D124) by MSAFREE3:8;
L1153: ( R8 variables_in D126 ) c= D123 by MSAFREE3:27;
L1154: ( variables_in D128 ) = ( R8 variables_in D128 );
L1155: ( R8 variables_in D127 ) c= D123 by MSAFREE3:27;
L1156: ( variables_in D129 ) = ( R8 variables_in D129 );
L1157: ( <* ( an_Adj ) , ( a_Type ) *> . 2 ) = ( a_Type R8 ) by FINSEQ_1:44;
L1158: ( <* ( an_Adj ) , ( a_Type ) *> . 1 ) = ( an_Adj R8 ) by FINSEQ_1:44;
L1159: ( the_sort_of D128 ) = ( ( the_arity_of C229 ) . 1 ) by L1143 , L1146 , L1147 , L1149 , MSATERM:23;
L1160: D128 in { B226 where B226 is (Term of R8 , D124) : (( the_sort_of B226 ) = ( an_Adj R8 ) & ( variables_in B226 ) c= D123) } by L1159 , L1145 , L1153 , L1154 , L1158;
L1161: D126 in ( ( R8 -Terms (D123 , D124) ) . ( an_Adj R8 ) ) by L1160 , MSAFREE3:def 5;
L1162: D126 in ( (the Sorts of ( Free (R8 , D123) )) . ( an_Adj R8 ) ) by L1161 , MSAFREE3:24;
reconsider D130 = D126 as (expression of R8 , ( an_Adj R8 )) by L1162 , L885;
L1163: ( the_sort_of D129 ) = ( ( the_arity_of C229 ) . 2 ) by L1143 , L1146 , L1147 , L1150 , MSATERM:23;
L1164: D129 in { B227 where B227 is (Term of R8 , D124) : (( the_sort_of B227 ) = ( a_Type R8 ) & ( variables_in B227 ) c= D123) } by L1163 , L1145 , L1155 , L1156 , L1157;
L1165: D127 in ( ( R8 -Terms (D123 , D124) ) . ( a_Type R8 ) ) by L1164 , MSAFREE3:def 5;
L1166: D127 in ( (the Sorts of ( Free (R8 , D123) )) . ( a_Type R8 ) ) by L1165 , MSAFREE3:24;
reconsider D131 = D127 as (expression of R8 , ( a_Type R8 )) by L1166 , L885;
L1167: C230 = <* D130 , D131 *> by L1141 , L1148 , FINSEQ_1:44;
L1168: C226 = ( ( ast R8 ) term (D130 , D131) ) by L1167 , L1140 , L1144 , L1145 , L1148 , L1157 , L1158 , L994;
thus L1169: thesis by L1168;
end;
suppose L1170: C229 = ( non_op );

L1171: ( the_arity_of C229 ) = <* ( an_Adj ) *> by L1170 , L630;
L1172: ( dom C230 ) = ( dom ( the_arity_of C229 ) ) by L1143 , MSATERM:22;
L1173: ( dom ( the_arity_of C229 ) ) = ( Seg 1 ) by L1171 , FINSEQ_1:38;
L1174: ( len ( the_arity_of C229 ) ) = 1 by L1171 , FINSEQ_1:39;
L1175: 1 in ( Seg 1 );
L1176: ( C230 . 1 ) in ( rng C230 ) by L1175 , L1172 , L1173 , FUNCT_1:3;
reconsider D132 = ( C230 . 1 ) as (expression of R8) by L1176;
reconsider D133 = D132 as (Term of R8 , D124) by MSAFREE3:8;
L1177: ( R8 variables_in D132 ) c= D123 by MSAFREE3:27;
L1178: ( variables_in D133 ) = ( R8 variables_in D133 );
L1179: ( <* ( an_Adj ) *> . 1 ) = ( an_Adj R8 ) by FINSEQ_1:40;
L1180: ( the_sort_of D133 ) = ( ( the_arity_of C229 ) . 1 ) by L1143 , L1172 , L1173 , L1175 , MSATERM:23;
L1181: D133 in { B228 where B228 is (Term of R8 , D124) : (( the_sort_of B228 ) = ( an_Adj R8 ) & ( variables_in B228 ) c= D123) } by L1180 , L1171 , L1177 , L1178 , L1179;
L1182: D132 in ( ( R8 -Terms (D123 , D124) ) . ( an_Adj R8 ) ) by L1181 , MSAFREE3:def 5;
L1183: D132 in ( (the Sorts of ( Free (R8 , D123) )) . ( an_Adj R8 ) ) by L1182 , MSAFREE3:24;
reconsider D134 = D132 as (expression of R8 , ( an_Adj R8 )) by L1183 , L885;
L1184: C230 = <* D134 *> by L1141 , L1174 , FINSEQ_1:40;
L1185: C226 = ( ( non_op R8 ) term D134 ) by L1184 , L1140 , L1170 , L1171 , L1174 , L1179 , L935;
thus L1186: thesis by L1185;
end;
suppose L1187: C229 is  constructor;

reconsider D135 = C229 as  constructor (OperSymbol of R8) by L1187;
L1188: C226 = ( [ D135 , (the carrier of R8) ] -tree C230 ) by L1140;
L1189: C230 in ( ( QuasiTerms R8 ) * ) by L1188 , L1057;
reconsider D136 = C230 as (FinSequence of ( QuasiTerms R8 )) by L1189 , FINSEQ_1:def 11;
L1190: C226 = ( D135 -trm D136 ) by L1140 , L1141 , L1118;
thus L1191: thesis by L1190 , L1141;
end;
end;
end;
theorem
L1194: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (( len R17 ) = ( len ( the_arity_of R11 ) ) implies ( R11 -trm R17 ) <> ( ( non_op R8 ) term R12 ))))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R12 being (expression of R8 , ( an_Adj R8 ));
let R17 being (FinSequence of ( QuasiTerms R8 ));
assume L1195: ( len R17 ) = ( len ( the_arity_of R11 ) );
L1196: ( R11 -trm R17 ) = ( [ R11 , (the carrier of R8) ] -tree R17 ) by L1195 , L1118;
L1197: ( ( R11 -trm R17 ) . ( {} ) ) = [ R11 , (the carrier of R8) ] by L1196 , TREES_4:def 4;
assume L1198: ( R11 -trm R17 ) = ( ( non_op R8 ) term R12 );
L1199: ( R11 -trm R17 ) = ( [ ( non_op ) , (the carrier of R8) ] -tree <* R12 *> ) by L1198 , L937;
L1200: [ R11 , (the carrier of R8) ] = [ ( non_op ) , (the carrier of R8) ] by L1199 , L1197 , TREES_4:def 4;
L1201: R11 = ( non_op ) by L1200 , XTUPLE_0:1;
thus L1202: thesis by L1201 , L670;
end;
theorem
L1203: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (for R14 being (expression of R8 , ( a_Type R8 )) holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (( len R17 ) = ( len ( the_arity_of R11 ) ) implies ( R11 -trm R17 ) <> ( ( ast R8 ) term (R12 , R14) )))))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R12 being (expression of R8 , ( an_Adj R8 ));
let R14 being (expression of R8 , ( a_Type R8 ));
let R17 being (FinSequence of ( QuasiTerms R8 ));
assume L1204: ( len R17 ) = ( len ( the_arity_of R11 ) );
L1205: ( R11 -trm R17 ) = ( [ R11 , (the carrier of R8) ] -tree R17 ) by L1204 , L1118;
L1206: ( ( R11 -trm R17 ) . ( {} ) ) = [ R11 , (the carrier of R8) ] by L1205 , TREES_4:def 4;
assume L1207: ( R11 -trm R17 ) = ( ( ast R8 ) term (R12 , R14) );
L1208: ( R11 -trm R17 ) = ( [ ( * ) , (the carrier of R8) ] -tree <* R12 , R14 *> ) by L1207 , L996;
L1209: [ R11 , (the carrier of R8) ] = [ ( * ) , (the carrier of R8) ] by L1208 , L1206 , TREES_4:def 4;
L1210: R11 = ( * ) by L1209 , XTUPLE_0:1;
thus L1211: thesis by L1210 , L670;
end;
theorem
L1212: (for R8 being  initialized ConstructorSignature holds (for R12 being (expression of R8 , ( an_Adj R8 )) holds (for R13 being (expression of R8 , ( an_Adj R8 )) holds (for R14 being (expression of R8 , ( a_Type R8 )) holds ( ( non_op R8 ) term R12 ) <> ( ( ast R8 ) term (R13 , R14) )))))
proof
let R8 being  initialized ConstructorSignature;
let R12 being (expression of R8 , ( an_Adj R8 ));
let R13 being (expression of R8 , ( an_Adj R8 ));
let R14 being (expression of R8 , ( a_Type R8 ));
assume L1213: ( ( non_op R8 ) term R12 ) = ( ( ast R8 ) term (R13 , R14) );
L1214: ( ( non_op R8 ) term R12 ) = ( [ ( * ) , (the carrier of R8) ] -tree <* R13 , R14 *> ) by L1213 , L996;
L1215: ( ( ( non_op R8 ) term R12 ) . ( {} ) ) = [ ( * ) , (the carrier of R8) ] by L1214 , TREES_4:def 4;
L1216: ( ( [ ( non_op ) , (the carrier of R8) ] -tree <* R12 *> ) . ( {} ) ) = [ ( * ) , (the carrier of R8) ] by L1215 , L937;
L1217: [ ( non_op ) , (the carrier of R8) ] = [ ( * ) , (the carrier of R8) ] by L1216 , TREES_4:def 4;
thus L1218: thesis by L1217 , XTUPLE_0:1;
end;
theorem
L1219: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds (( R18 . ( {} ) ) = [ ( non_op ) , (the carrier of R8) ] implies (ex R12 being (expression of R8 , ( an_Adj R8 )) st R18 = ( ( non_op R8 ) term R12 )))))
proof
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
assume L1220: ( R18 . ( {} ) ) = [ ( non_op ) , (the carrier of R8) ];
L1221: ( non_op R8 ) in (the carrier' of R8);
L1222: ( R18 . ( {} ) ) in [: (the carrier' of R8) , { (the carrier of R8) } :] by L1221 , L1220 , ZFMISC_1:106;
per cases  by L1131;
suppose L1223: (ex B229 being variable st R18 = ( B229 -term R8 ));

thus L1224: thesis by L1223 , L1222 , L882;
end;
suppose L1225: (ex R11 being  constructor (OperSymbol of R8) st (ex R17 being (FinSequence of ( QuasiTerms R8 )) st (( len R17 ) = ( len ( the_arity_of R11 ) ) & R18 = ( R11 -trm R17 ))));

consider C231 being  constructor (OperSymbol of R8), C232 being (FinSequence of ( QuasiTerms R8 )) such that L1226: ( len C232 ) = ( len ( the_arity_of C231 ) ) and L1227: R18 = ( C231 -trm C232 ) by L1225;
L1228: R18 = ( [ C231 , (the carrier of R8) ] -tree C232 ) by L1226 , L1227 , L1118;
L1229: ( R18 . ( {} ) ) = [ C231 , (the carrier of R8) ] by L1228 , TREES_4:def 4;
L1230: ( non_op ) = C231 by L1229 , L1220 , XTUPLE_0:1;
thus L1231: thesis by L1230 , L670;
end;
suppose L1232: (ex R12 being (expression of R8 , ( an_Adj R8 )) st R18 = ( ( non_op R8 ) term R12 ));

thus L1233: thesis by L1232;
end;
suppose L1234: (ex R12 being (expression of R8 , ( an_Adj R8 )) st (ex R14 being (expression of R8 , ( a_Type R8 )) st R18 = ( ( ast R8 ) term (R12 , R14) )));

consider R12 being (expression of R8 , ( an_Adj R8 )), R14 being (expression of R8 , ( a_Type R8 )) such that L1235: R18 = ( ( ast R8 ) term (R12 , R14) ) by L1234;
L1236: R18 = ( [ ( * ) , (the carrier of R8) ] -tree <* R12 , R14 *> ) by L1235 , L996;
L1237: ( R18 . ( {} ) ) = [ ( * ) , (the carrier of R8) ] by L1236 , TREES_4:def 4;
thus L1238: thesis by L1237 , L1220 , XTUPLE_0:1;
end;
end;
theorem
L1240: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds (( R18 . ( {} ) ) = [ ( * ) , (the carrier of R8) ] implies (ex R12 being (expression of R8 , ( an_Adj R8 )) st (ex R14 being (expression of R8 , ( a_Type R8 )) st R18 = ( ( ast R8 ) term (R12 , R14) ))))))
proof
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
assume L1241: ( R18 . ( {} ) ) = [ ( * ) , (the carrier of R8) ];
L1242: ( ast R8 ) in (the carrier' of R8);
L1243: ( R18 . ( {} ) ) in [: (the carrier' of R8) , { (the carrier of R8) } :] by L1242 , L1241 , ZFMISC_1:106;
per cases  by L1131;
suppose L1244: (ex B230 being variable st R18 = ( B230 -term R8 ));

thus L1245: thesis by L1244 , L1243 , L882;
end;
suppose L1246: (ex R11 being  constructor (OperSymbol of R8) st (ex R17 being (FinSequence of ( QuasiTerms R8 )) st (( len R17 ) = ( len ( the_arity_of R11 ) ) & R18 = ( R11 -trm R17 ))));

consider C233 being  constructor (OperSymbol of R8), C234 being (FinSequence of ( QuasiTerms R8 )) such that L1247: ( len C234 ) = ( len ( the_arity_of C233 ) ) and L1248: R18 = ( C233 -trm C234 ) by L1246;
L1249: R18 = ( [ C233 , (the carrier of R8) ] -tree C234 ) by L1247 , L1248 , L1118;
L1250: ( R18 . ( {} ) ) = [ C233 , (the carrier of R8) ] by L1249 , TREES_4:def 4;
L1251: ( * ) = C233 by L1250 , L1241 , XTUPLE_0:1;
thus L1252: thesis by L1251 , L670;
end;
suppose L1253: (ex B231 being (expression of R8 , ( an_Adj R8 )) st R18 = ( ( non_op R8 ) term B231 ));

consider C235 being (expression of R8 , ( an_Adj R8 )) such that L1254: R18 = ( ( non_op R8 ) term C235 ) by L1253;
L1255: R18 = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C235 *> ) by L1254 , L937;
L1256: ( R18 . ( {} ) ) = [ ( non_op ) , (the carrier of R8) ] by L1255 , TREES_4:def 4;
thus L1257: thesis by L1256 , L1241 , XTUPLE_0:1;
end;
suppose L1258: (ex R12 being (expression of R8 , ( an_Adj R8 )) st (ex R14 being (expression of R8 , ( a_Type R8 )) st R18 = ( ( ast R8 ) term (R12 , R14) )));

thus L1259: thesis by L1258;
end;
end;
begin
definition
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
func Non R19 -> (expression of R8 , ( an_Adj R8 )) equals 
:L1261: ( R19 | <* ( 0 ) *> ) if (ex R20 being (expression of R8 , ( an_Adj R8 )) st R19 = ( ( non_op R8 ) term R20 )) otherwise ( ( non_op R8 ) term R19 );
coherence
proof
thus L1262:now
given C236 being (expression of R8 , ( an_Adj R8 )) such that
L1263: R19 = ( ( non_op R8 ) term C236 );

L1264: R19 = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C236 *> ) by L1263 , L937;
L1265: ( len <* C236 *> ) = 1 by FINSEQ_1:40;
L1266: ( R19 | <* ( 0 ) *> ) = ( <* C236 *> . ( ( 0 ) + 1 ) ) by L1265 , L1264 , TREES_4:def 4;
thus L1267: ( R19 | <* ( 0 ) *> ) is (expression of R8 , ( an_Adj R8 )) by L1266 , FINSEQ_1:40;
end;
thus L1268: thesis by L937;
end;
consistency;
end;
definition
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
attr R19 is  positive
means
:L1270: (not (ex R20 being (expression of R8 , ( an_Adj R8 )) st R19 = ( ( non_op R8 ) term R20 )));
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  positive for (expression of R8 , ( an_Adj R8 ));
existence
proof
consider C237 , C238 being (OperSymbol of R8) such that L1272: ( the_result_sort_of C237 ) = ( a_Type ) and L1273: ( the_arity_of C237 ) = ( {} ) and L1274: ( the_result_sort_of C238 ) = ( an_Adj ) and L1275: ( the_arity_of C238 ) = ( {} ) by L679;
set D137 = ( MSVars R8 );
L1276: ( root-tree [ C238 , (the carrier of R8) ] ) in ( (the Sorts of ( Free (R8 , D137) )) . ( an_Adj ) ) by L1274 , L1275 , MSAFREE3:5;
reconsider D138 = ( root-tree [ C238 , (the carrier of R8) ] ) as (expression of R8 , ( an_Adj R8 )) by L1276 , L890;
take D138;
given C239 being (expression of R8 , ( an_Adj R8 )) such that
L1277: D138 = ( ( non_op R8 ) term C239 );

L1278: D138 = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C239 *> ) by L1277 , L937;
L1279: [ ( non_op ) , (the carrier of R8) ] = ( D138 . ( {} ) ) by L1278 , TREES_4:def 4
.= [ C238 , (the carrier of R8) ] by TREES_4:3;
L1280: C238 = ( non_op R8 ) by L1279 , XTUPLE_0:1;
thus L1281: contradiction by L1280 , L1275 , L630;
end;
end;
theorem
L1283: (for R8 being  initialized ConstructorSignature holds (for B232 being  positive (expression of R8 , ( an_Adj R8 )) holds ( Non B232 ) = ( ( non_op R8 ) term B232 )))
proof
let R8 being  initialized ConstructorSignature;
let C240 being  positive (expression of R8 , ( an_Adj R8 ));
L1284: (not (ex B233 being (expression of R8 , ( an_Adj R8 )) st C240 = ( ( non_op R8 ) term B233 ))) by L1270;
thus L1285: thesis by L1284 , L1261;
end;
definition
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
attr R19 is  negative
means
:L1286: (ex R20 being (expression of R8 , ( an_Adj R8 )) st (R20 is  positive & R19 = ( ( non_op R8 ) term R20 )));
end;
registration
let R8 being  initialized ConstructorSignature;
let C241 being  positive (expression of R8 , ( an_Adj R8 ));
cluster ( Non C241 ) ->  negative non  positive;
coherence
proof
thus L1288: ( Non C241 ) is  negative
proof
take C241;
thus L1289: thesis by L1283;
end;

take C241;
thus L1290: thesis by L1283;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  negative non  positive for (expression of R8 , ( an_Adj R8 ));
existence
proof
set D139 = the  positive (expression of R8 , ( an_Adj R8 ));
take ( Non D139 );
thus L1292: thesis;
end;
end;
theorem
L1294: (for R8 being  initialized ConstructorSignature holds (for B234 being non  positive (expression of R8 , ( an_Adj R8 )) holds (ex B235 being (expression of R8 , ( an_Adj R8 )) st (B234 = ( ( non_op R8 ) term B235 ) & ( Non B234 ) = B235))))
proof
let R8 being  initialized ConstructorSignature;
let C242 being non  positive (expression of R8 , ( an_Adj R8 ));
consider C243 being (expression of R8 , ( an_Adj R8 )) such that L1295: C242 = ( ( non_op R8 ) term C243 ) by L1270;
L1296: C242 = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C243 *> ) by L1295 , L937;
take C243;
L1297: ( len <* C243 *> ) = 1 by FINSEQ_1:40;
L1298: ( C242 | <* ( 0 ) *> ) = ( <* C243 *> . ( ( 0 ) + 1 ) ) by L1297 , L1296 , TREES_4:def 4
.= C243 by FINSEQ_1:40;
thus L1299: thesis by L1298 , L1295 , L1261;
end;
theorem
L1300: (for R8 being  initialized ConstructorSignature holds (for B236 being  negative (expression of R8 , ( an_Adj R8 )) holds (ex B237 being  positive (expression of R8 , ( an_Adj R8 )) st (B236 = ( ( non_op R8 ) term B237 ) & ( Non B236 ) = B237))))
proof
let R8 being  initialized ConstructorSignature;
let C244 being  negative (expression of R8 , ( an_Adj R8 ));
consider C245 being (expression of R8 , ( an_Adj R8 )) such that L1301: C245 is  positive and L1302: C244 = ( ( non_op R8 ) term C245 ) by L1286;
L1303: C244 = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C245 *> ) by L1302 , L937;
reconsider D140 = C245 as  positive (expression of R8 , ( an_Adj R8 )) by L1301;
take D140;
L1304: ( len <* D140 *> ) = 1 by FINSEQ_1:40;
L1305: ( C244 | <* ( 0 ) *> ) = ( <* D140 *> . ( ( 0 ) + 1 ) ) by L1304 , L1303 , TREES_4:def 4
.= D140 by FINSEQ_1:40;
thus L1306: thesis by L1305 , L1302 , L1261;
end;
theorem
L1307: (for R8 being  initialized ConstructorSignature holds (for B238 being non  positive (expression of R8 , ( an_Adj R8 )) holds ( ( non_op R8 ) term ( Non B238 ) ) = B238))
proof
let R8 being  initialized ConstructorSignature;
let C246 being non  positive (expression of R8 , ( an_Adj R8 ));
L1308: (ex B239 being (expression of R8 , ( an_Adj R8 )) st (C246 = ( ( non_op R8 ) term B239 ) & ( Non C246 ) = B239)) by L1294;
thus L1309: thesis by L1308;
end;
registration
let R8 being  initialized ConstructorSignature;
let C247 being  negative (expression of R8 , ( an_Adj R8 ));
cluster ( Non C247 ) ->  positive;
coherence
proof
L1310: (ex B240 being  positive (expression of R8 , ( an_Adj R8 )) st (C247 = ( ( non_op R8 ) term B240 ) & ( Non C247 ) = B240)) by L1300;
thus L1311: thesis by L1310;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
attr R19 is  regular
means
:L1313: (R19 is  positive or R19 is  negative);
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  positive ->  regular non  negative for (expression of R8 , ( an_Adj R8 ));
coherence
proof
let C248 being (expression of R8 , ( an_Adj R8 ));
assume L1315: C248 is  positive;
thus L1316: C248 is  regular by L1315 , L1313;
thus L1317: (not (ex B241 being (expression of R8 , ( an_Adj R8 )) st (B241 is  positive & C248 = ( ( non_op R8 ) term B241 )))) by L1315 , L1270;
end;
cluster  negative ->  regular non  positive for (expression of R8 , ( an_Adj R8 ));
coherence by L1313;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  regular for (expression of R8 , ( an_Adj R8 ));
existence
proof
set D141 = the  positive (expression of R8 , ( an_Adj R8 ));
take D141;
thus L1319: thesis;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
set D142 = { R19 where R19 is (expression of R8 , ( an_Adj R8 )) : R19 is  regular };
L1321: D142 c= ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) )
proof
let R5 being set;
assume L1322: R5 in D142;
L1323: (ex R19 being (expression of R8 , ( an_Adj R8 )) st (R5 = R19 & R19 is  regular)) by L1322;
thus L1324: thesis by L1323;
end;
func QuasiAdjs R8 -> (Subset of ( Free (R8 , ( MSVars R8 )) )) equals 
{ R19 where R19 is (expression of R8 , ( an_Adj R8 )) : R19 is  regular };
coherence by L1321;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster ( QuasiAdjs R8 ) -> non  empty  constituted-DTrees;
coherence
proof
set D143 = the  positive (expression of R8 , ( an_Adj R8 ));
L1326: D143 in { R19 where R19 is (expression of R8 , ( an_Adj R8 )) : R19 is  regular };
thus L1327: ( QuasiAdjs R8 ) is non  empty by L1326;
let R5 being set;
assume L1328: R5 in ( QuasiAdjs R8 );
thus L1329: thesis by L1328;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
mode quasi-adjective of R8
 is  regular (expression of R8 , ( an_Adj R8 ));
end;
theorem
L1332: (for R7 being set holds (for R8 being  initialized ConstructorSignature holds (R7 is (quasi-adjective of R8) iff R7 in ( QuasiAdjs R8 ))))
proof
let R7 being set;
let R8 being  initialized ConstructorSignature;
L1333: (R7 in ( QuasiAdjs R8 ) iff (ex R19 being (expression of R8 , ( an_Adj R8 )) st (R7 = R19 & R19 is  regular)));
thus L1334: thesis by L1333;
end;
theorem
L1335: (for R7 being set holds (for R8 being  initialized ConstructorSignature holds (R7 is (quasi-adjective of R8) iff (R7 is  positive  positive  positive  positive (expression of R8 , ( an_Adj R8 )) or R7 is  negative  negative  negative  negative (expression of R8 , ( an_Adj R8 )))))) by L1313;
registration
let R8 being  initialized ConstructorSignature;
cluster non  positive ->  negative for (quasi-adjective of R8);
coherence by L1313;
cluster non  negative ->  positive for (quasi-adjective of R8);
coherence;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  positive for (quasi-adjective of R8);
existence
proof
set D144 = the  positive (expression of R8 , ( an_Adj R8 ));
L1337: D144 is (quasi-adjective of R8);
thus L1338: thesis by L1337;
end;
cluster  negative for (quasi-adjective of R8);
existence
proof
set D145 = the  negative (expression of R8 , ( an_Adj R8 ));
L1339: D145 is (quasi-adjective of R8);
thus L1340: thesis by L1339;
end;
end;
theorem
L1342: (for R8 being  initialized ConstructorSignature holds (for B242 being  positive (quasi-adjective of R8) holds (ex B243 being  constructor (OperSymbol of R8) st (( the_result_sort_of B243 ) = ( an_Adj R8 ) & (ex R17 being (FinSequence of ( QuasiTerms R8 )) st (( len R17 ) = ( len ( the_arity_of B243 ) ) & B242 = ( B243 -trm R17 )))))))
proof
let R8 being  initialized ConstructorSignature;
let C249 being  positive (quasi-adjective of R8);
per cases  by L1131;
suppose L1343: (ex B244 being variable st C249 = ( B244 -term R8 ));

thus L1344: thesis by L1343 , L1022;
end;
suppose L1345: (ex B245 being  constructor (OperSymbol of R8) st (ex B246 being (FinSequence of ( QuasiTerms R8 )) st (( len B246 ) = ( len ( the_arity_of B245 ) ) & C249 = ( B245 -trm B246 ))));

consider C250 being  constructor (OperSymbol of R8), C251 being (FinSequence of ( QuasiTerms R8 )) such that L1346: ( len C251 ) = ( len ( the_arity_of C250 ) ) and L1347: C249 = ( C250 -trm C251 ) by L1345;
take C250;
L1348: C249 is (expression of R8 , ( the_result_sort_of C250 )) by L1346 , L1347 , L1123;
thus L1349: ( the_result_sort_of C250 ) = ( an_Adj R8 ) by L1348 , L1022;
take C251;
thus L1350: thesis by L1346 , L1347;
end;
suppose L1351: (ex R19 being (expression of R8 , ( an_Adj R8 )) st C249 = ( ( non_op R8 ) term R19 ));

thus L1352: thesis by L1351 , L1270;
end;
suppose L1353: (ex R19 being (expression of R8 , ( an_Adj R8 )) st (ex R14 being (expression of R8 , ( a_Type R8 )) st C249 = ( ( ast R8 ) term (R19 , R14) )));

L1354: C249 is (expression of R8 , ( a_Type R8 )) by L1353 , L996;
thus L1355: thesis by L1354 , L1022;
end;
end;
theorem
L1357: (for R8 being  initialized ConstructorSignature holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (for B247 being  constructor (OperSymbol of R8) holds ((( the_result_sort_of B247 ) = ( an_Adj R8 ) & ( len R17 ) = ( len ( the_arity_of B247 ) )) implies ( B247 -trm R17 ) is  positive  positive  positive  positive (quasi-adjective of R8)))))
proof
let R8 being  initialized ConstructorSignature;
let R17 being (FinSequence of ( QuasiTerms R8 ));
let C252 being  constructor (OperSymbol of R8);
assume that
L1358: ( the_result_sort_of C252 ) = ( an_Adj R8 );
assume L1359: ( len R17 ) = ( len ( the_arity_of C252 ) );
reconsider D146 = ( C252 -trm R17 ) as (expression of R8 , ( an_Adj R8 )) by L1359 , L1358 , L1123;
L1360: D146 is  positive
proof
assume L1361: (ex R20 being (expression of R8 , ( an_Adj R8 )) st D146 = ( ( non_op R8 ) term R20 ));
thus L1362: thesis by L1361 , L1359 , L1194;
end;
thus L1363: thesis by L1360;
end;
registration
let R8 being  initialized ConstructorSignature;
let C253 being (quasi-adjective of R8);
cluster ( Non C253 ) ->  regular;
coherence
proof
per cases ;
suppose L1364: C253 is  positive;

reconsider D147 = C253 as  positive (expression of R8 , ( an_Adj R8 )) by L1364;
L1365: ( Non D147 ) is  negative;
thus L1366: thesis by L1365;
end;
suppose L1367: C253 is  negative;

reconsider D148 = C253 as  negative (expression of R8 , ( an_Adj R8 )) by L1367;
L1368: ( Non D148 ) is  positive;
thus L1369: thesis by L1368;
end;
end;
end;
theorem
L1372: (for R8 being  initialized ConstructorSignature holds (for B248 being (quasi-adjective of R8) holds ( Non ( Non B248 ) ) = B248))
proof
let R8 being  initialized ConstructorSignature;
let C254 being (quasi-adjective of R8);
per cases ;
suppose L1373: C254 is  positive;

reconsider D149 = C254 as  positive (expression of R8 , ( an_Adj R8 )) by L1373;
L1374: (ex B249 being  positive (expression of R8 , ( an_Adj R8 )) st (( Non D149 ) = ( ( non_op R8 ) term B249 ) & ( Non ( Non D149 ) ) = B249)) by L1300;
L1375: ( Non D149 ) = ( ( non_op R8 ) term C254 ) by L1283;
thus L1376: thesis by L1375 , L1374 , L944;
end;
suppose L1377: C254 is  negative;

reconsider D150 = C254 as  negative (expression of R8 , ( an_Adj R8 )) by L1377;
L1378: (ex B250 being  positive (expression of R8 , ( an_Adj R8 )) st (D150 = ( ( non_op R8 ) term B250 ) & ( Non D150 ) = B250)) by L1300;
thus L1379: thesis by L1378 , L1283;
end;
end;
theorem
L1381: (for R8 being  initialized ConstructorSignature holds (for B251 , B252 being (quasi-adjective of R8) holds (( Non B251 ) = ( Non B252 ) implies B251 = B252)))
proof
let R8 being  initialized ConstructorSignature;
let C255 , C256 being (quasi-adjective of R8);
L1382: ( Non ( Non C255 ) ) = C255 by L1372;
thus L1383: thesis by L1382 , L1372;
end;
theorem
L1384: (for R8 being  initialized ConstructorSignature holds (for B253 being (quasi-adjective of R8) holds ( Non B253 ) <> B253))
proof
let R8 being  initialized ConstructorSignature;
let C257 being (quasi-adjective of R8);
per cases ;
suppose L1385: C257 is  positive;

reconsider D151 = C257 as  positive (quasi-adjective of R8) by L1385;
L1386: ( Non D151 ) is  negative  negative  negative  negative (quasi-adjective of R8);
thus L1387: thesis by L1386;
end;
suppose L1388: C257 is  negative;

reconsider D152 = C257 as  negative (quasi-adjective of R8) by L1388;
L1389: ( Non D152 ) is  positive  positive  positive  positive (quasi-adjective of R8);
thus L1390: thesis by L1389;
end;
end;
begin
definition
let R8 being  initialized ConstructorSignature;
let C258 being (expression of R8 , ( a_Type R8 ));
attr C258 is  pure
means
:L1392: (not (ex R19 being (expression of R8 , ( an_Adj R8 )) st (ex R14 being (expression of R8 , ( a_Type R8 )) st C258 = ( ( ast R8 ) term (R19 , R14) ))));
end;
theorem
L1394: (for R8 being  initialized ConstructorSignature holds (for B254 being (OperSymbol of R8) holds ((( the_result_sort_of B254 ) = ( a_Type ) & ( the_arity_of B254 ) = ( {} )) implies (ex R14 being (expression of R8 , ( a_Type R8 )) st (R14 = ( root-tree [ B254 , (the carrier of R8) ] ) & R14 is  pure)))))
proof
let R8 being  initialized ConstructorSignature;
let C259 being (OperSymbol of R8);
assume that
L1395: ( the_result_sort_of C259 ) = ( a_Type )
and
L1396: ( the_arity_of C259 ) = ( {} );
set D153 = ( MSVars R8 );
L1397: ( root-tree [ C259 , (the carrier of R8) ] ) in ( (the Sorts of ( Free (R8 , D153) )) . ( a_Type ) ) by L1395 , L1396 , MSAFREE3:5;
reconsider D154 = ( root-tree [ C259 , (the carrier of R8) ] ) as (expression of R8 , ( a_Type R8 )) by L1397 , L890;
take D154;
thus L1398: D154 = ( root-tree [ C259 , (the carrier of R8) ] );
given R19 being (expression of R8 , ( an_Adj R8 )) , R14 being (expression of R8 , ( a_Type R8 )) such that
L1399: D154 = ( ( ast R8 ) term (R19 , R14) );

L1400: D154 = ( [ ( * ) , (the carrier of R8) ] -tree <* R19 , R14 *> ) by L1399 , L996;
L1401: [ ( * ) , (the carrier of R8) ] = ( D154 . ( {} ) ) by L1400 , TREES_4:def 4
.= [ C259 , (the carrier of R8) ] by TREES_4:3;
L1402: C259 = ( ast R8 ) by L1401 , XTUPLE_0:1;
thus L1403: contradiction by L1402 , L1396 , L630;
end;
theorem
L1404: (for R8 being  initialized ConstructorSignature holds (for B255 being (OperSymbol of R8) holds ((( the_result_sort_of B255 ) = ( an_Adj ) & ( the_arity_of B255 ) = ( {} )) implies (ex R19 being (expression of R8 , ( an_Adj R8 )) st (R19 = ( root-tree [ B255 , (the carrier of R8) ] ) & R19 is  positive)))))
proof
let R8 being  initialized ConstructorSignature;
let C260 being (OperSymbol of R8);
assume that
L1405: ( the_result_sort_of C260 ) = ( an_Adj )
and
L1406: ( the_arity_of C260 ) = ( {} );
set D155 = ( MSVars R8 );
L1407: ( root-tree [ C260 , (the carrier of R8) ] ) in ( (the Sorts of ( Free (R8 , D155) )) . ( an_Adj ) ) by L1405 , L1406 , MSAFREE3:5;
reconsider D156 = ( root-tree [ C260 , (the carrier of R8) ] ) as (expression of R8 , ( an_Adj R8 )) by L1407 , L890;
take D156;
thus L1408: D156 = ( root-tree [ C260 , (the carrier of R8) ] );
given C261 being (expression of R8 , ( an_Adj R8 )) such that
L1409: D156 = ( ( non_op R8 ) term C261 );

L1410: D156 = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C261 *> ) by L1409 , L937;
L1411: [ ( non_op ) , (the carrier of R8) ] = ( D156 . ( {} ) ) by L1410 , TREES_4:def 4
.= [ C260 , (the carrier of R8) ] by TREES_4:3;
L1412: C260 = ( non_op ) by L1411 , XTUPLE_0:1;
thus L1413: contradiction by L1412 , L1406 , L630;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  pure for (expression of R8 , ( a_Type R8 ));
existence
proof
consider C262 , C263 being (OperSymbol of R8) such that L1414: ( the_result_sort_of C262 ) = ( a_Type ) and L1415: ( the_arity_of C262 ) = ( {} ) and L1416: ( the_result_sort_of C263 ) = ( an_Adj ) and L1417: ( the_arity_of C263 ) = ( {} ) by L679;
L1418: (ex B256 being (expression of R8 , ( a_Type R8 )) st (B256 = ( root-tree [ C262 , (the carrier of R8) ] ) & B256 is  pure)) by L1414 , L1415 , L1394;
thus L1419: thesis by L1418;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
func QuasiTypes R8 equals 
{ [ R22 , R14 ] where R14 is (expression of R8 , ( a_Type R8 )) , R22 is  finite (Subset of ( QuasiAdjs R8 )) : R14 is  pure };
coherence;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster ( QuasiTypes R8 ) -> non  empty;
coherence
proof
set D157 = the  pure (expression of R8 , ( a_Type R8 ));
L1422: ( {} ) is  finite  finite  finite  finite (Subset of ( QuasiAdjs R8 )) by XBOOLE_1:2;
L1423: [ ( {} ) , D157 ] in { [ R22 , R14 ] where R14 is (expression of R8 , ( a_Type R8 )) , R22 is  finite (Subset of ( QuasiAdjs R8 )) : R14 is  pure } by L1422;
thus L1424: thesis by L1423;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
mode quasi-type of R8
means :L1426: it in ( QuasiTypes R8 );
existence
proof
set D158 = the (Element of ( QuasiTypes R8 ));
take D158;
thus L1427: thesis;
end;
end;
theorem
L1429: (for R7 being set holds (for R8 being  initialized ConstructorSignature holds (R7 is (quasi-type of R8) iff (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (ex R21 being  pure (expression of R8 , ( a_Type R8 )) st R7 = [ R22 , R21 ])))))
proof
let R7 being set;
let R8 being  initialized ConstructorSignature;
L1430: (R7 in ( QuasiTypes R8 ) iff (ex R14 being (expression of R8 , ( a_Type R8 )) st (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (R7 = [ R22 , R14 ] & R14 is  pure))));
thus L1431: thesis by L1430 , L1426;
end;
theorem
L1432: (for R5 being set holds (for R6 being set holds (for R8 being  initialized ConstructorSignature holds ([ R5 , R6 ] is (quasi-type of R8) iff (R5 is  finite  finite  finite  finite (Subset of ( QuasiAdjs R8 )) & R6 is  pure  pure  pure  pure (expression of R8 , ( a_Type R8 )))))))
proof
let R5 being set;
let R6 being set;
let R8 being  initialized ConstructorSignature;
thus L1433:now
assume L1434: [ R5 , R6 ] is (quasi-type of R8);
L1435: (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (ex R21 being  pure (expression of R8 , ( a_Type R8 )) st [ R5 , R6 ] = [ R22 , R21 ])) by L1434 , L1429;
thus L1436: (R5 is  finite  finite  finite  finite (Subset of ( QuasiAdjs R8 )) & R6 is  pure  pure  pure  pure (expression of R8 , ( a_Type R8 ))) by L1435 , XTUPLE_0:1;
end;
thus L1437: thesis by L1429;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  ->  pair for (quasi-type of R8);
coherence
proof
let C264 being (quasi-type of R8);
L1438: (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (ex R21 being  pure (expression of R8 , ( a_Type R8 )) st C264 = [ R22 , R21 ])) by L1429;
thus L1439: thesis by L1438;
end;
end;
theorem
L1441: (for R8 being  initialized ConstructorSignature holds (for R21 being  pure (expression of R8 , ( a_Type R8 )) holds (ex B257 being  constructor (OperSymbol of R8) st (( the_result_sort_of B257 ) = ( a_Type R8 ) & (ex R17 being (FinSequence of ( QuasiTerms R8 )) st (( len R17 ) = ( len ( the_arity_of B257 ) ) & R21 = ( B257 -trm R17 )))))))
proof
let R8 being  initialized ConstructorSignature;
let R21 being  pure (expression of R8 , ( a_Type R8 ));
set D159 = R21;
per cases  by L1131;
suppose L1442: (ex B258 being variable st D159 = ( B258 -term R8 ));

thus L1443: thesis by L1442 , L1022;
end;
suppose L1444: (ex B259 being  constructor (OperSymbol of R8) st (ex B260 being (FinSequence of ( QuasiTerms R8 )) st (( len B260 ) = ( len ( the_arity_of B259 ) ) & D159 = ( B259 -trm B260 ))));

consider C265 being  constructor (OperSymbol of R8), C266 being (FinSequence of ( QuasiTerms R8 )) such that L1445: ( len C266 ) = ( len ( the_arity_of C265 ) ) and L1446: D159 = ( C265 -trm C266 ) by L1444;
take C265;
L1447: D159 is (expression of R8 , ( the_result_sort_of C265 )) by L1445 , L1446 , L1123;
thus L1448: ( the_result_sort_of C265 ) = ( a_Type R8 ) by L1447 , L1022;
take C266;
thus L1449: thesis by L1445 , L1446;
end;
suppose L1450: (ex R19 being (expression of R8 , ( an_Adj R8 )) st D159 = ( ( non_op R8 ) term R19 ));

L1451: D159 is (expression of R8 , ( an_Adj R8 )) by L1450 , L937;
thus L1452: thesis by L1451 , L1022;
end;
suppose L1453: (ex R19 being (expression of R8 , ( an_Adj R8 )) st (ex B261 being (expression of R8 , ( a_Type R8 )) st D159 = ( ( ast R8 ) term (R19 , B261) )));

thus L1454: thesis by L1453 , L1392;
end;
end;
theorem
L1456: (for R8 being  initialized ConstructorSignature holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (for B262 being  constructor (OperSymbol of R8) holds ((( the_result_sort_of B262 ) = ( a_Type R8 ) & ( len R17 ) = ( len ( the_arity_of B262 ) )) implies ( B262 -trm R17 ) is  pure  pure  pure  pure (expression of R8 , ( a_Type R8 ))))))
proof
let R8 being  initialized ConstructorSignature;
let R17 being (FinSequence of ( QuasiTerms R8 ));
let C267 being  constructor (OperSymbol of R8);
assume that
L1457: ( the_result_sort_of C267 ) = ( a_Type R8 );
assume L1458: ( len R17 ) = ( len ( the_arity_of C267 ) );
reconsider D160 = ( C267 -trm R17 ) as (expression of R8 , ( a_Type R8 )) by L1458 , L1457 , L1123;
L1459: D160 is  pure
proof
assume L1460: (ex R20 being (expression of R8 , ( an_Adj R8 )) st (ex R14 being (expression of R8 , ( a_Type R8 )) st D160 = ( ( ast R8 ) term (R20 , R14) )));
thus L1461: thesis by L1460 , L1458 , L1203;
end;
thus L1462: thesis by L1459;
end;
theorem
L1463: (for R8 being  initialized ConstructorSignature holds (( QuasiTerms R8 ) misses ( QuasiAdjs R8 ) & ( QuasiTerms R8 ) misses ( QuasiTypes R8 ) & ( QuasiTypes R8 ) misses ( QuasiAdjs R8 )))
proof
let R8 being  initialized ConstructorSignature;
set D161 = ( MSVars R8 );
set D162 = ( D161 \/ ( (the carrier of R8) --> { ( 0 ) } ) );
L1464: (ex B263 being (MSSubset of ( FreeMSA D162 )) st (( Free (R8 , D161) ) = ( GenMSAlg B263 ) & B263 = ( ( Reverse D162 ) "" D161 ))) by MSAFREE3:def 1;
L1465: (the Sorts of ( Free (R8 , D161) )) is (MSSubset of ( FreeMSA D162 )) by L1464 , MSUALG_2:def 9;
L1466: (the Sorts of ( Free (R8 , D161) )) c= (the Sorts of ( FreeMSA D162 )) by L1465 , PBOOLE:def 18;
L1467: ( QuasiTerms R8 ) c= ( (the Sorts of ( FreeMSA D162 )) . ( a_Term R8 ) ) by L1466 , PBOOLE:def 2;
L1468: ( (the Sorts of ( Free (R8 , D161) )) . ( an_Adj R8 ) ) c= ( (the Sorts of ( FreeMSA D162 )) . ( an_Adj R8 ) ) by L1466 , PBOOLE:def 2;
L1469: ( QuasiAdjs R8 ) c= ( (the Sorts of ( Free (R8 , D161) )) . ( an_Adj R8 ) )
proof
let R5 being set;
assume L1470: R5 in ( QuasiAdjs R8 );
L1471: (ex R19 being (expression of R8 , ( an_Adj R8 )) st (R5 = R19 & R19 is  regular)) by L1470;
thus L1472: thesis by L1471 , L885;
end;
L1473: ( QuasiAdjs R8 ) c= ( (the Sorts of ( FreeMSA D162 )) . ( an_Adj R8 ) ) by L1469 , L1468 , XBOOLE_1:1;
L1474: ( (the Sorts of ( FreeMSA D162 )) . ( a_Term R8 ) ) misses ( (the Sorts of ( FreeMSA D162 )) . ( an_Adj R8 ) ) by PROB_2:def 2;
thus L1475: ( QuasiTerms R8 ) misses ( QuasiAdjs R8 ) by L1474 , L1467 , L1473 , XBOOLE_1:64;
L1476:
now
let C268 being set;
assume that
L1477: C268 in ( QuasiTerms R8 )
and
L1478: C268 in ( QuasiTypes R8 );
L1479: C268 is (quasi-type of R8) by L1478 , L1426;
thus L1480: contradiction by L1479 , L1477;
end;
thus L1481: ( QuasiTerms R8 ) misses ( QuasiTypes R8 ) by L1476 , XBOOLE_0:3;
L1482:
now
let C269 being set;
assume that
L1483: C269 in ( QuasiAdjs R8 )
and
L1484: C269 in ( QuasiTypes R8 );
L1485: C269 is (quasi-type of R8) by L1484 , L1426;
thus L1486: contradiction by L1485 , L1483;
end;
thus L1487: thesis by L1482 , XBOOLE_0:3;
end;
theorem
L1488: (for R8 being  initialized ConstructorSignature holds (for B264 being set holds ((B264 is (quasi-term of R8) implies (not B264 is (quasi-adjective of R8))) & (B264 is (quasi-term of R8) implies (not B264 is (quasi-type of R8))) & (B264 is (quasi-type of R8) implies (not B264 is (quasi-adjective of R8)))))) by L1022;
notation
let R8 being  initialized ConstructorSignature;
let R22 being  finite (Subset of ( QuasiAdjs R8 ));
let R21 being  pure (expression of R8 , ( a_Type R8 ));
synonym R22 ast R21 for [R22 , R21 ];
end;
definition
let R8 being  initialized ConstructorSignature;
let R22 being  finite (Subset of ( QuasiAdjs R8 ));
let R21 being  pure (expression of R8 , ( a_Type R8 ));
redefine func R22 ast R21 -> (quasi-type of R8);

coherence by L1432;
end;
registration
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
cluster ( R23 `1 ) ->  finite;
coherence
proof
L1491: (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (ex R21 being  pure (expression of R8 , ( a_Type R8 )) st R23 = [ R22 , R21 ])) by L1429;
thus L1492: thesis by L1491 , MCART_1:7;
end;
end;
notation
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
synonym adjs R23 for R23 `1;
synonym the_base_of R23 for R23 `2;
end;
definition
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
redefine func adjs R23 -> (Subset of ( QuasiAdjs R8 ));

coherence
proof
L1495: (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (ex R21 being  pure (expression of R8 , ( a_Type R8 )) st R23 = [ R22 , R21 ])) by L1429;
thus L1496: thesis by L1495 , MCART_1:7;
end;
redefine func the_base_of R23 ->  pure (expression of R8 , ( a_Type R8 ));

coherence
proof
L1497: (ex R22 being  finite (Subset of ( QuasiAdjs R8 )) st (ex R21 being  pure (expression of R8 , ( a_Type R8 )) st R23 = [ R22 , R21 ])) by L1429;
thus L1498: thesis by L1497 , MCART_1:7;
end;
end;
theorem
L1500: (for R8 being  initialized ConstructorSignature holds (for R21 being  pure (expression of R8 , ( a_Type R8 )) holds (for R22 being  finite (Subset of ( QuasiAdjs R8 )) holds (( adjs ( R22 ast R21 ) ) = R22 & ( the_base_of ( R22 ast R21 ) ) = R21))));
theorem
L1501: (for R8 being  initialized ConstructorSignature holds (for B265 , B266 being  finite (Subset of ( QuasiAdjs R8 )) holds (for B267 , B268 being  pure (expression of R8 , ( a_Type R8 )) holds (( B265 ast B267 ) = ( B266 ast B268 ) implies (B265 = B266 & B267 = B268))))) by XTUPLE_0:1;
theorem
L1502: (for R8 being  initialized ConstructorSignature holds (for R23 being (quasi-type of R8) holds R23 = ( ( adjs R23 ) ast ( the_base_of R23 ) )))
proof
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
thus L1503: thesis;
end;
theorem
L1504: (for R8 being  initialized ConstructorSignature holds (for B269 , B270 being (quasi-type of R8) holds ((( adjs B269 ) = ( adjs B270 ) & ( the_base_of B269 ) = ( the_base_of B270 )) implies B269 = B270)))
proof
let R8 being  initialized ConstructorSignature;
let C270 , C271 being (quasi-type of R8);
L1505: C270 = ( ( adjs C270 ) ast ( the_base_of C270 ) );
thus L1506: thesis by L1505 , L1502;
end;
definition
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
let C272 being (quasi-adjective of R8);
func C272 ast R23 -> (quasi-type of R8) equals 
[ ( { C272 } \/ ( adjs R23 ) ) , ( the_base_of R23 ) ];
coherence
proof
L1507: C272 in ( QuasiAdjs R8 );
L1508: { C272 } c= ( QuasiAdjs R8 ) by L1507 , ZFMISC_1:31;
L1509: ( { C272 } \/ ( adjs R23 ) ) is (Subset of ( QuasiAdjs R8 )) by L1508 , XBOOLE_1:8;
thus L1510: thesis by L1509 , L1432;
end;
end;
theorem
L1512: (for R8 being  initialized ConstructorSignature holds (for R23 being (quasi-type of R8) holds (for B271 being (quasi-adjective of R8) holds (( adjs ( B271 ast R23 ) ) = ( { B271 } \/ ( adjs R23 ) ) & ( the_base_of ( B271 ast R23 ) ) = ( the_base_of R23 ))))) by MCART_1:7;
theorem
L1513: (for R8 being  initialized ConstructorSignature holds (for R23 being (quasi-type of R8) holds (for B272 being (quasi-adjective of R8) holds ( B272 ast ( B272 ast R23 ) ) = ( B272 ast R23 ))))
proof
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
let C273 being (quasi-adjective of R8);
thus L1514: ( C273 ast ( C273 ast R23 ) ) = [ ( { C273 } \/ ( { C273 } \/ ( adjs R23 ) ) ) , ( the_base_of ( C273 ast R23 ) ) ] by MCART_1:7
.= [ ( ( { C273 } \/ { C273 } ) \/ ( adjs R23 ) ) , ( the_base_of ( C273 ast R23 ) ) ] by XBOOLE_1:4
.= ( C273 ast R23 ) by MCART_1:7;
end;
theorem
L1515: (for R8 being  initialized ConstructorSignature holds (for R23 being (quasi-type of R8) holds (for B273 , B274 being (quasi-adjective of R8) holds ( B273 ast ( B274 ast R23 ) ) = ( B274 ast ( B273 ast R23 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R23 being (quasi-type of R8);
let C274 , C275 being (quasi-adjective of R8);
thus L1516: ( C274 ast ( C275 ast R23 ) ) = [ ( { C274 } \/ ( { C275 } \/ ( adjs R23 ) ) ) , ( the_base_of ( C275 ast R23 ) ) ] by MCART_1:7
.= [ ( { C275 } \/ ( { C274 } \/ ( adjs R23 ) ) ) , ( the_base_of ( C275 ast R23 ) ) ] by XBOOLE_1:4
.= [ ( { C275 } \/ ( { C274 } \/ ( adjs R23 ) ) ) , ( the_base_of R23 ) ] by MCART_1:7
.= [ ( { C275 } \/ ( adjs ( C274 ast R23 ) ) ) , ( the_base_of R23 ) ] by MCART_1:7
.= ( C275 ast ( C274 ast R23 ) ) by MCART_1:7;
end;
begin
registration
let C276 being non  void Signature;
let C277 being (SortSymbol of C276);
let C278 being  non-empty (ManySortedSet of (the carrier of C276));
let C279 being (Term of C276 , C278);
cluster ( ( variables_in C279 ) . C277 ) ->  finite;
coherence
proof
defpred S9[ non  empty Relation ] means (for B275 being (SortSymbol of C276) holds ( ( C276 variables_in $1 ) . B275 ) is  finite);
L1517: (for B276 being (SortSymbol of C276) holds (for B277 being (Element of ( C278 . B276 )) holds S9[ ( root-tree [ B277 , B276 ] ) ]))
proof
let C280 being (SortSymbol of C276);
let C281 being (Element of ( C278 . C280 ));
let C282 being (SortSymbol of C276);
L1518: (C282 = C280 or C282 <> C280);
thus L1519: thesis by L1518 , MSAFREE3:10;
end;
L1520: (for B278 being (OperSymbol of C276) holds (for B279 being (ArgumentSeq of ( Sym (B278 , C278) )) holds ((for B280 being (Term of C276 , C278) holds (B280 in ( rng B279 ) implies S9[ B280 ])) implies S9[ ( [ B278 , (the carrier of C276) ] -tree B279 ) ])))
proof
let C283 being (OperSymbol of C276);
let C284 being (ArgumentSeq of ( Sym (C283 , C278) ));
assume that
L1521: (for B281 being (Term of C276 , C278) holds (B281 in ( rng C284 ) implies (for B282 being (SortSymbol of C276) holds ( ( C276 variables_in B281 ) . B282 ) is  finite)));
let C285 being (SortSymbol of C276);
deffunc H6((Term of C276 , C278)) = ( ( C276 variables_in $1 ) . C285 );
set D163 = { H6(B283) where B283 is (Term of C276 , C278) : B283 in ( rng C284 ) };
L1522: ( rng C284 ) is  finite;
L1523: D163 is  finite from FRAENKEL:sch 21(L1522);
L1524:
now
let C286 being set;
assume L1525: C286 in D163;
L1526: (ex B284 being (Term of C276 , C278) st (C286 = ( ( C276 variables_in B284 ) . C285 ) & B284 in ( rng C284 ))) by L1525;
thus L1527: C286 is  finite by L1526 , L1521;
end;
L1528: ( union D163 ) is  finite by L1524 , L1523 , FINSET_1:7;
L1529: ( ( C276 variables_in ( [ C283 , (the carrier of C276) ] -tree C284 ) ) . C285 ) c= ( union D163 )
proof
let C287 being set;
assume L1530: C287 in ( ( C276 variables_in ( [ C283 , (the carrier of C276) ] -tree C284 ) ) . C285 );
consider C288 being DecoratedTree such that L1531: C288 in ( rng C284 ) and L1532: C287 in ( ( C276 variables_in C288 ) . C285 ) by L1530 , MSAFREE3:11;
consider C289 being set such that L1533: C289 in ( dom C284 ) and L1534: C288 = ( C284 . C289 ) by L1531 , FUNCT_1:def 3;
reconsider D164 = C289 as Nat by L1533;
reconsider D165 = ( C284 . D164 ) as (Term of C276 , C278) by L1533 , MSATERM:22;
L1535: ( ( C276 variables_in D165 ) . C285 ) in D163 by L1531 , L1534;
thus L1536: thesis by L1535 , L1532 , L1534 , TARSKI:def 4;
end;
thus L1537: thesis by L1529 , L1528;
end;
L1538: (for B285 being (Term of C276 , C278) holds S9[ B285 ]) from MSATERM:sch 1(L1517 , L1520);
thus L1539: thesis by L1538;
end;
end;
registration
let C290 being non  void Signature;
let C291 being (SortSymbol of C290);
let C292 being non  empty-yielding (ManySortedSet of (the carrier of C290));
let C293 being (Element of ( Free (C290 , C292) ));
cluster ( ( C290 variables_in C293 ) . C291 ) ->  finite;
coherence
proof
reconsider D166 = C293 as (Term of C290 , ( C292 \/ ( (the carrier of C290) --> { ( 0 ) } ) )) by MSAFREE3:8;
L1541: ( ( C290 variables_in D166 ) . C291 ) = ( ( variables_in D166 ) . C291 );
thus L1542: thesis by L1541;
end;
end;
definition
let C294 being non  void Signature;
let C295 being non  empty-yielding (ManySortedSet of (the carrier of C294));
let C296 being (SortSymbol of C294);
func (C295 , C296) variables_in -> (Function of ( Union (the Sorts of ( Free (C294 , C295) )) ) , ( bool ( C295 . C296 ) )) means 
:L1544: (for B286 being (Element of ( Free (C294 , C295) )) holds ( it . B286 ) = ( ( C294 variables_in B286 ) . C296 ));
uniqueness
proof
let C297 , C298 being (Function of ( Union (the Sorts of ( Free (C294 , C295) )) ) , ( bool ( C295 . C296 ) ));
assume that
L1545: (for B287 being (Element of ( Free (C294 , C295) )) holds ( C297 . B287 ) = ( ( C294 variables_in B287 ) . C296 ))
and
L1546: (for B288 being (Element of ( Free (C294 , C295) )) holds ( C298 . B288 ) = ( ( C294 variables_in B288 ) . C296 ));
L1547:
now
let C299 being (Element of ( Union (the Sorts of ( Free (C294 , C295) )) ));
reconsider D167 = C299 as (Element of ( Free (C294 , C295) ));
thus L1548: ( C297 . C299 ) = ( ( C294 variables_in D167 ) . C296 ) by L1545
.= ( C298 . C299 ) by L1546;
end;
thus L1549: thesis by L1547 , FUNCT_2:63;
end;
existence
proof
defpred S10[ set , set ] means (ex B289 being (Element of ( Free (C294 , C295) )) st (B289 = $1 & $2 = ( ( C294 variables_in B289 ) . C296 )));
L1550:
now
let R5 being set;
assume L1551: R5 in ( Union (the Sorts of ( Free (C294 , C295) )) );
reconsider D168 = R5 as (Element of ( Free (C294 , C295) )) by L1551;
L1552: ( C294 variables_in D168 ) c= C295 by MSAFREE3:27;
L1553: ( ( C294 variables_in D168 ) . C296 ) c= ( C295 . C296 ) by L1552 , PBOOLE:def 2;
thus L1554: (ex R6 being set st (R6 in ( bool ( C295 . C296 ) ) & S10[ R5 , R6 ])) by L1553;
end;
consider C300 being Function such that L1555: (( dom C300 ) = ( Union (the Sorts of ( Free (C294 , C295) )) ) & ( rng C300 ) c= ( bool ( C295 . C296 ) )) and L1556: (for R5 being set holds (R5 in ( Union (the Sorts of ( Free (C294 , C295) )) ) implies S10[ R5 , ( C300 . R5 ) ])) from FUNCT_1:sch 5(L1550);
reconsider D169 = C300 as (Function of ( Union (the Sorts of ( Free (C294 , C295) )) ) , ( bool ( C295 . C296 ) )) by L1555 , FUNCT_2:2;
take D169;
let C301 being (Element of ( Free (C294 , C295) ));
L1557: (ex B290 being (Element of ( Free (C294 , C295) )) st (B290 = C301 & ( D169 . C301 ) = ( ( C294 variables_in B290 ) . C296 ))) by L1556;
thus L1558: thesis by L1557;
end;
end;
definition
let C302 being  initialized ConstructorSignature;
let C303 being (expression of C302);
func variables_in C303 -> (Subset of ( Vars )) equals 
( ( C302 variables_in C303 ) . ( a_Term C302 ) );
coherence
proof
L1560: ( ( MSVars C302 ) . ( a_Term C302 ) ) = ( Vars ) by L840;
L1561: ( C302 variables_in C303 ) c= ( MSVars C302 ) by MSAFREE3:27;
thus L1562: thesis by L1561 , L1560 , PBOOLE:def 2;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
cluster ( variables_in R18 ) ->  finite;
coherence;
end;
definition
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
func vars R18 ->  finite (Subset of ( Vars )) equals 
( varcl ( variables_in R18 ) );
coherence by L435;
end;
theorem
L1566: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds ( varcl ( vars R18 ) ) = ( vars R18 )));
theorem
L1567: (for R8 being  initialized ConstructorSignature holds (for B291 being variable holds ( variables_in ( B291 -term R8 ) ) = { B291 })) by MSAFREE3:10;
theorem
L1568: (for R8 being  initialized ConstructorSignature holds (for B292 being variable holds ( vars ( B292 -term R8 ) ) = ( { B292 } \/ ( vars B292 ) )))
proof
let R8 being  initialized ConstructorSignature;
let C304 being variable;
thus L1569: ( vars ( C304 -term R8 ) ) = ( varcl { C304 } ) by MSAFREE3:10
.= ( { C304 } \/ ( vars C304 ) ) by L476;
end;
theorem
L1570: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R18 being (expression of R8) holds (for B293 being  DTree-yielding FinSequence holds (R18 = ( [ R11 , (the carrier of R8) ] -tree B293 ) implies ( variables_in R18 ) = ( union { ( variables_in B294 ) where B294 is (quasi-term of R8) : B294 in ( rng B293 ) } ))))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R18 being (expression of R8);
let C305 being  DTree-yielding FinSequence;
set D170 = { ( variables_in B295 ) where B295 is (quasi-term of R8) : B295 in ( rng C305 ) };
assume L1571: R18 = ( [ R11 , (the carrier of R8) ] -tree C305 );
L1572: C305 in ( ( QuasiTerms R8 ) * ) by L1571 , L1057;
L1573: C305 is (FinSequence of ( QuasiTerms R8 )) by L1572 , FINSEQ_1:def 11;
L1574: ( rng C305 ) c= ( QuasiTerms R8 ) by L1573 , FINSEQ_1:def 4;
thus L1575: ( variables_in R18 ) c= ( union D170 )
proof
let C306 being set;
assume L1576: C306 in ( variables_in R18 );
consider C307 being DecoratedTree such that L1577: C307 in ( rng C305 ) and L1578: C306 in ( ( R8 variables_in C307 ) . ( a_Term R8 ) ) by L1576 , L1571 , MSAFREE3:11;
reconsider D171 = C307 as (quasi-term of R8) by L1574 , L1577 , L890;
L1579: ( variables_in D171 ) in D170 by L1577;
thus L1580: thesis by L1579 , L1578 , TARSKI:def 4;
end;

let C308 being set;
assume L1581: C308 in ( union D170 );
consider C309 being set such that L1582: C308 in C309 and L1583: C309 in D170 by L1581 , TARSKI:def 4;
L1584: (ex B296 being (quasi-term of R8) st (C309 = ( variables_in B296 ) & B296 in ( rng C305 ))) by L1583;
thus L1585: thesis by L1584 , L1571 , L1582 , MSAFREE3:11;
end;
theorem
L1586: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R18 being (expression of R8) holds (for B297 being  DTree-yielding FinSequence holds (R18 = ( [ R11 , (the carrier of R8) ] -tree B297 ) implies ( vars R18 ) = ( union { ( vars B298 ) where B298 is (quasi-term of R8) : B298 in ( rng B297 ) } ))))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R18 being (expression of R8);
let C310 being  DTree-yielding FinSequence;
assume L1587: R18 = ( [ R11 , (the carrier of R8) ] -tree C310 );
set D172 = { ( variables_in B299 ) where B299 is (quasi-term of R8) : B299 in ( rng C310 ) };
set D173 = { ( vars B300 ) where B300 is (quasi-term of R8) : B300 in ( rng C310 ) };
per cases ;
suppose L1588: D172 = ( {} );

set D174 = the (Element of D173);
L1589:
now
assume L1590: D173 <> ( {} );
L1591: D174 in D173 by L1590;
consider C311 being (quasi-term of R8) such that L1592: D174 = ( vars C311 ) and L1593: C311 in ( rng C310 ) by L1591;
L1594: ( variables_in C311 ) in D172 by L1593;
thus L1595: contradiction by L1594 , L1588;
end;
thus L1596: thesis by L1589 , L1587 , L1588 , L112 , L1570 , ZFMISC_1:2;
end;
suppose L1597: D172 <> ( {} );

reconsider D175 = D172 as non  empty set by L1597;
set D176 = { ( varcl B301 ) where B301 is (Element of D175) : (not contradiction) };
L1598: D173 c= D176
proof
let C312 being set;
assume L1599: C312 in D173;
consider C313 being (quasi-term of R8) such that L1600: C312 = ( vars C313 ) and L1601: C313 in ( rng C310 ) by L1599;
L1602: ( variables_in C313 ) in D175 by L1601;
reconsider D177 = ( variables_in C313 ) as (Element of D175) by L1602;
L1603: C312 = ( varcl D177 ) by L1600;
thus L1604: thesis by L1603;
end;
L1605: D176 c= D173
proof
let C314 being set;
assume L1606: C314 in D176;
consider C315 being (Element of D175) such that L1607: C314 = ( varcl C315 ) by L1606;
L1608: C315 in D175;
consider C316 being (quasi-term of R8) such that L1609: C315 = ( variables_in C316 ) and L1610: C316 in ( rng C310 ) by L1608;
L1611: ( vars C316 ) = C314 by L1607 , L1609;
thus L1612: thesis by L1611 , L1610;
end;
thus L1613: ( vars R18 ) = ( varcl ( union D175 ) ) by L1587 , L1570
.= ( union D176 ) by L122
.= ( union D173 ) by L1598 , L1605 , XBOOLE_0:def 10;
end;
end;
theorem
L1615: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (( len R17 ) = ( len ( the_arity_of R11 ) ) implies ( variables_in ( R11 -trm R17 ) ) = ( union { ( variables_in B302 ) where B302 is (quasi-term of R8) : B302 in ( rng R17 ) } )))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R17 being (FinSequence of ( QuasiTerms R8 ));
assume L1616: ( len R17 ) = ( len ( the_arity_of R11 ) );
L1617: ( R11 -trm R17 ) = ( [ R11 , (the carrier of R8) ] -tree R17 ) by L1616 , L1118;
thus L1618: thesis by L1617 , L1570;
end;
theorem
L1619: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (( len R17 ) = ( len ( the_arity_of R11 ) ) implies ( vars ( R11 -trm R17 ) ) = ( union { ( vars B303 ) where B303 is (quasi-term of R8) : B303 in ( rng R17 ) } )))))
proof
let R8 being  initialized ConstructorSignature;
let R11 being  constructor (OperSymbol of R8);
let R17 being (FinSequence of ( QuasiTerms R8 ));
assume L1620: ( len R17 ) = ( len ( the_arity_of R11 ) );
L1621: ( R11 -trm R17 ) = ( [ R11 , (the carrier of R8) ] -tree R17 ) by L1620 , L1118;
thus L1622: thesis by L1621 , L1586;
end;
theorem
L1623: (for B304 being ManySortedSign holds (for B305 being set holds ( B304 variables_in ( [ B305 , (the carrier of B304) ] -tree ( {} ) ) ) = ( [[0]] (the carrier of B304) )))
proof
let C317 being ManySortedSign;
let C318 being set;
L1624:
now
let C319 being set;
assume L1625: C319 in (the carrier of C317);
L1626:
now
let R5 being set;
L1627: ( rng ( {} ) ) = ( {} );
L1628: (R5 in ( ( C317 variables_in ( [ C318 , (the carrier of C317) ] -tree ( {} ) ) ) . C319 ) iff (ex B306 being DecoratedTree st (B306 in ( {} ) & R5 in ( ( C317 variables_in B306 ) . C319 )))) by L1627 , L1625 , MSAFREE3:11;
thus L1629: (R5 in ( ( C317 variables_in ( [ C318 , (the carrier of C317) ] -tree ( {} ) ) ) . C319 ) iff R5 in ( ( [[0]] (the carrier of C317) ) . C319 )) by L1628;
end;
thus L1630: ( ( C317 variables_in ( [ C318 , (the carrier of C317) ] -tree ( {} ) ) ) . C319 ) = ( ( [[0]] (the carrier of C317) ) . C319 ) by L1626 , TARSKI:1;
end;
thus L1631: thesis by L1624 , PBOOLE:3;
end;
theorem
L1632: (for B307 being ManySortedSign holds (for B308 being set holds (for B309 being DecoratedTree holds ( B307 variables_in ( [ B308 , (the carrier of B307) ] -tree <* B309 *> ) ) = ( B307 variables_in B309 ))))
proof
let C320 being ManySortedSign;
let C321 being set;
let C322 being DecoratedTree;
L1633:
now
let C323 being set;
assume L1634: C323 in (the carrier of C320);
L1635: C322 in { C322 } by TARSKI:def 1;
L1636:
now
let R5 being set;
L1637: ( rng <* C322 *> ) = { C322 } by FINSEQ_1:39;
L1638: (R5 in ( ( C320 variables_in ( [ C321 , (the carrier of C320) ] -tree <* C322 *> ) ) . C323 ) iff (ex B310 being DecoratedTree st (B310 in { C322 } & R5 in ( ( C320 variables_in B310 ) . C323 )))) by L1637 , L1634 , MSAFREE3:11;
thus L1639: (R5 in ( ( C320 variables_in ( [ C321 , (the carrier of C320) ] -tree <* C322 *> ) ) . C323 ) iff R5 in ( ( C320 variables_in C322 ) . C323 )) by L1638 , L1635 , TARSKI:def 1;
end;
thus L1640: ( ( C320 variables_in ( [ C321 , (the carrier of C320) ] -tree <* C322 *> ) ) . C323 ) = ( ( C320 variables_in C322 ) . C323 ) by L1636 , TARSKI:1;
end;
thus L1641: thesis by L1633 , PBOOLE:3;
end;
theorem
L1642: (for R8 being  initialized ConstructorSignature holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( variables_in ( ( non_op R8 ) term R19 ) ) = ( variables_in R19 )))
proof
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
L1643: ( ( non_op R8 ) term R19 ) = ( [ ( non_op ) , (the carrier of R8) ] -tree <* R19 *> ) by L937;
thus L1644: thesis by L1643 , L1632;
end;
theorem
L1645: (for R8 being  initialized ConstructorSignature holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( vars ( ( non_op R8 ) term R19 ) ) = ( vars R19 ))) by L1642;
theorem
L1646: (for B311 being ManySortedSign holds (for B312 being set holds (for B313 , B314 being DecoratedTree holds ( B311 variables_in ( [ B312 , (the carrier of B311) ] -tree <* B313 , B314 *> ) ) = ( ( B311 variables_in B313 ) \/ ( B311 variables_in B314 ) ))))
proof
let C324 being ManySortedSign;
let C325 being set;
let C326 , C327 being DecoratedTree;
L1647:
now
let C328 being set;
assume L1648: C328 in (the carrier of C324);
L1649: C326 in { C326 , C327 } by TARSKI:def 2;
L1650: C327 in { C326 , C327 } by TARSKI:def 2;
L1651:
now
let R5 being set;
L1652: ( rng <* C326 , C327 *> ) = { C326 , C327 } by FINSEQ_2:127;
L1653: (R5 in ( ( C324 variables_in ( [ C325 , (the carrier of C324) ] -tree <* C326 , C327 *> ) ) . C328 ) iff (ex B315 being DecoratedTree st (B315 in { C326 , C327 } & R5 in ( ( C324 variables_in B315 ) . C328 )))) by L1652 , L1648 , MSAFREE3:11;
L1654: (R5 in ( ( C324 variables_in ( [ C325 , (the carrier of C324) ] -tree <* C326 , C327 *> ) ) . C328 ) iff (R5 in ( ( C324 variables_in C326 ) . C328 ) or R5 in ( ( C324 variables_in C327 ) . C328 ))) by L1653 , L1649 , L1650 , TARSKI:def 2;
L1655: (R5 in ( ( C324 variables_in ( [ C325 , (the carrier of C324) ] -tree <* C326 , C327 *> ) ) . C328 ) iff R5 in ( ( ( C324 variables_in C326 ) . C328 ) \/ ( ( C324 variables_in C327 ) . C328 ) )) by L1654 , XBOOLE_0:def 3;
thus L1656: (R5 in ( ( C324 variables_in ( [ C325 , (the carrier of C324) ] -tree <* C326 , C327 *> ) ) . C328 ) iff R5 in ( ( ( C324 variables_in C326 ) \/ ( C324 variables_in C327 ) ) . C328 )) by L1655 , L1648 , PBOOLE:def 4;
end;
thus L1657: ( ( C324 variables_in ( [ C325 , (the carrier of C324) ] -tree <* C326 , C327 *> ) ) . C328 ) = ( ( ( C324 variables_in C326 ) \/ ( C324 variables_in C327 ) ) . C328 ) by L1651 , TARSKI:1;
end;
thus L1658: thesis by L1647 , PBOOLE:3;
end;
theorem
L1659: (for R8 being  initialized ConstructorSignature holds (for R14 being (expression of R8 , ( a_Type R8 )) holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( variables_in ( ( ast R8 ) term (R19 , R14) ) ) = ( ( variables_in R19 ) \/ ( variables_in R14 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R14 being (expression of R8 , ( a_Type R8 ));
let R19 being (expression of R8 , ( an_Adj R8 ));
L1660: ( ( ast R8 ) term (R19 , R14) ) = ( [ ( * ) , (the carrier of R8) ] -tree <* R19 , R14 *> ) by L996;
L1661: ( variables_in ( ( ast R8 ) term (R19 , R14) ) ) = ( ( ( R8 variables_in R19 ) \/ ( R8 variables_in R14 ) ) . ( a_Term ) ) by L1660 , L1646;
thus L1662: thesis by L1661 , PBOOLE:def 4;
end;
theorem
L1663: (for R8 being  initialized ConstructorSignature holds (for R14 being (expression of R8 , ( a_Type R8 )) holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( vars ( ( ast R8 ) term (R19 , R14) ) ) = ( ( vars R19 ) \/ ( vars R14 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R14 being (expression of R8 , ( a_Type R8 ));
let R19 being (expression of R8 , ( an_Adj R8 ));
thus L1664: ( vars ( ( ast R8 ) term (R19 , R14) ) ) = ( varcl ( ( variables_in R19 ) \/ ( variables_in R14 ) ) ) by L1659
.= ( ( vars R19 ) \/ ( vars R14 ) ) by L173;
end;
theorem
L1665: (for R8 being  initialized ConstructorSignature holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( variables_in ( Non R19 ) ) = ( variables_in R19 )))
proof
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
per cases ;
suppose L1666: R19 is non  positive;

consider C329 being (expression of R8 , ( an_Adj R8 )) such that L1667: R19 = ( ( non_op R8 ) term C329 ) and L1668: ( Non R19 ) = C329 by L1666 , L1294;
L1669: ( [ ( non_op R8 ) , (the carrier of R8) ] -tree <* C329 *> ) = R19 by L1667 , L937;
thus L1670: thesis by L1669 , L1668 , L1632;
end;
suppose L1671: R19 is  positive;

L1672: ( Non R19 ) = ( ( non_op R8 ) term R19 ) by L1671 , L1283
.= ( [ ( non_op ) , (the carrier of R8) ] -tree <* R19 *> ) by L937;
thus L1673: thesis by L1672 , L1632;
end;
end;
theorem
L1675: (for R8 being  initialized ConstructorSignature holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( vars ( Non R19 ) ) = ( vars R19 ))) by L1665;
definition
let R8 being  initialized ConstructorSignature;
let C330 being (quasi-type of R8);
func variables_in C330 -> (Subset of ( Vars )) equals 
( ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C330 ) ) ) \/ ( variables_in ( the_base_of C330 ) ) );
coherence
proof
L1676: ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C330 ) ) is (Subset of ( bool ( Vars ) )) by L840;
L1677: ( union ( bool ( Vars ) ) ) = ( Vars ) by ZFMISC_1:81;
L1678: ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C330 ) ) ) c= ( Vars ) by L1677 , L1676 , ZFMISC_1:77;
thus L1679: thesis by L1678 , XBOOLE_1:8;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let C331 being (quasi-type of R8);
cluster ( variables_in C331 ) ->  finite;
coherence
proof
L1681:
now
let C332 being set;
assume L1682: C332 in ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C331 ) );
consider C333 being set such that L1683: C333 in ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) and L1684: C333 in ( adjs C331 ) and L1685: C332 = ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) . C333 ) by L1682 , FUNCT_2:64;
reconsider D178 = C333 as (expression of R8) by L1683;
L1686: C332 = ( ( R8 variables_in D178 ) . ( a_Term R8 ) ) by L1685 , L1544;
thus L1687: C332 is  finite by L1686;
end;
L1688: ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C331 ) ) ) is  finite by L1681 , FINSET_1:7;
thus L1689: thesis by L1688;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let C334 being (quasi-type of R8);
func vars C334 ->  finite (Subset of ( Vars )) equals 
( varcl ( variables_in C334 ) );
coherence by L435;
end;
theorem
L1692: (for R8 being  initialized ConstructorSignature holds (for B316 being (quasi-type of R8) holds ( varcl ( vars B316 ) ) = ( vars B316 )));
theorem
L1693: (for R8 being  initialized ConstructorSignature holds (for B317 being (quasi-type of R8) holds (for B318 being (quasi-adjective of R8) holds ( variables_in ( B318 ast B317 ) ) = ( ( variables_in B318 ) \/ ( variables_in B317 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let C335 being (quasi-type of R8);
let C336 being (quasi-adjective of R8);
L1694: ( dom ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) ) = ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by FUNCT_2:def 1;
thus L1695: ( variables_in ( C336 ast C335 ) ) = ( ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs ( C336 ast C335 ) ) ) ) \/ ( variables_in ( the_base_of C335 ) ) ) by MCART_1:7
.= ( ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( { C336 } \/ ( adjs C335 ) ) ) ) \/ ( variables_in ( the_base_of C335 ) ) ) by MCART_1:7
.= ( ( union ( ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: { C336 } ) \/ ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C335 ) ) ) ) \/ ( variables_in ( the_base_of C335 ) ) ) by RELAT_1:120
.= ( ( ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: { C336 } ) ) \/ ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs C335 ) ) ) ) \/ ( variables_in ( the_base_of C335 ) ) ) by ZFMISC_1:78
.= ( ( union ( Im (( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) , C336) ) ) \/ ( variables_in C335 ) ) by XBOOLE_1:4
.= ( ( union { ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) . C336 ) } ) \/ ( variables_in C335 ) ) by L1694 , FUNCT_1:59
.= ( ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) . C336 ) \/ ( variables_in C335 ) ) by ZFMISC_1:25
.= ( ( variables_in C336 ) \/ ( variables_in C335 ) ) by L1544;
end;
theorem
L1696: (for R8 being  initialized ConstructorSignature holds (for B319 being (quasi-type of R8) holds (for B320 being (quasi-adjective of R8) holds ( vars ( B320 ast B319 ) ) = ( ( vars B320 ) \/ ( vars B319 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let C337 being (quasi-type of R8);
let C338 being (quasi-adjective of R8);
thus L1697: ( vars ( C338 ast C337 ) ) = ( varcl ( ( variables_in C338 ) \/ ( variables_in C337 ) ) ) by L1693
.= ( ( vars C338 ) \/ ( vars C337 ) ) by L173;
end;
theorem
L1698: (for R8 being  initialized ConstructorSignature holds (for R21 being  pure (expression of R8 , ( a_Type R8 )) holds (for R22 being  finite (Subset of ( QuasiAdjs R8 )) holds ( variables_in ( R22 ast R21 ) ) = ( ( union { ( variables_in B321 ) where B321 is (quasi-adjective of R8) : B321 in R22 } ) \/ ( variables_in R21 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R21 being  pure (expression of R8 , ( a_Type R8 ));
let R22 being  finite (Subset of ( QuasiAdjs R8 ));
set D179 = ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: R22 );
set D180 = { ( variables_in B322 ) where B322 is (quasi-adjective of R8) : B322 in R22 };
L1699: D179 c= D180
proof
let C339 being set;
assume L1700: C339 in D179;
consider C340 being set such that L1701: C340 in ( dom ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) ) and L1702: C340 in R22 and L1703: C339 = ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) . C340 ) by L1700 , FUNCT_1:def 6;
reconsider D181 = C340 as (quasi-adjective of R8) by L1702 , L1332;
L1704: C339 = ( variables_in D181 ) by L1703 , L1544;
thus L1705: thesis by L1704 , L1702;
end;
L1706: D180 c= D179
proof
let C341 being set;
assume L1707: C341 in D180;
consider C342 being (quasi-adjective of R8) such that L1708: C341 = ( variables_in C342 ) and L1709: C342 in R22 by L1707;
L1710: C341 = ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) . C342 ) by L1708 , L1544;
L1711: ( dom ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) ) = ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by FUNCT_2:def 1;
thus L1712: thesis by L1711 , L1709 , L1710 , FUNCT_1:def 6;
end;
thus L1713: ( variables_in ( R22 ast R21 ) ) = ( ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: ( adjs ( R22 ast R21 ) ) ) ) \/ ( variables_in R21 ) )
.= ( ( union ( ( (( MSVars R8 ) , ( a_Term R8 )) variables_in ) .: R22 ) ) \/ ( variables_in R21 ) )
.= ( ( union { ( variables_in B323 ) where B323 is (quasi-adjective of R8) : B323 in R22 } ) \/ ( variables_in R21 ) ) by L1699 , L1706 , XBOOLE_0:def 10;
end;
theorem
L1714: (for R8 being  initialized ConstructorSignature holds (for R21 being  pure (expression of R8 , ( a_Type R8 )) holds (for R22 being  finite (Subset of ( QuasiAdjs R8 )) holds ( vars ( R22 ast R21 ) ) = ( ( union { ( vars B324 ) where B324 is (quasi-adjective of R8) : B324 in R22 } ) \/ ( vars R21 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R21 being  pure (expression of R8 , ( a_Type R8 ));
let R22 being  finite (Subset of ( QuasiAdjs R8 ));
set D182 = { ( variables_in B325 ) where B325 is (quasi-adjective of R8) : B325 in R22 };
set D183 = { ( vars B326 ) where B326 is (quasi-adjective of R8) : B326 in R22 };
L1715: ( union D182 ) c= ( union D183 )
proof
let C343 being set;
assume L1716: C343 in ( union D182 );
consider C344 being set such that L1717: C343 in C344 and L1718: C344 in D182 by L1716 , TARSKI:def 4;
consider C345 being (quasi-adjective of R8) such that L1719: C344 = ( variables_in C345 ) and L1720: C345 in R22 by L1718;
L1721: C344 c= ( vars C345 ) by L1719 , L73;
L1722: ( vars C345 ) in D183 by L1720;
thus L1723: thesis by L1722 , L1717 , L1721 , TARSKI:def 4;
end;
L1724: (for R5 being set holds (for R6 being set holds ([ R5 , R6 ] in ( union D183 ) implies R5 c= ( union D183 ))))
proof
let R5 being set;
let R6 being set;
assume L1725: [ R5 , R6 ] in ( union D183 );
consider C346 being set such that L1726: [ R5 , R6 ] in C346 and L1727: C346 in D183 by L1725 , TARSKI:def 4;
L1728: (ex B327 being (quasi-adjective of R8) st (C346 = ( vars B327 ) & B327 in R22)) by L1727;
L1729: R5 c= C346 by L1728 , L1726 , L73;
L1730: C346 c= ( union D183 ) by L1727 , ZFMISC_1:74;
thus L1731: thesis by L1730 , L1729 , XBOOLE_1:1;
end;
L1732: ( varcl ( union D182 ) ) c= ( union D183 ) by L1724 , L1715 , L73;
L1733: ( union D183 ) c= ( varcl ( union D182 ) )
proof
let C347 being set;
assume L1734: C347 in ( union D183 );
consider C348 being set such that L1735: C347 in C348 and L1736: C348 in D183 by L1734 , TARSKI:def 4;
consider C349 being (quasi-adjective of R8) such that L1737: C348 = ( vars C349 ) and L1738: C349 in R22 by L1736;
L1739: ( variables_in C349 ) in D182 by L1738;
L1740: ( vars C349 ) c= ( varcl ( union D182 ) ) by L1739 , L116 , ZFMISC_1:74;
thus L1741: thesis by L1740 , L1735 , L1737;
end;
thus L1742: ( vars ( R22 ast R21 ) ) = ( varcl ( ( union D182 ) \/ ( variables_in R21 ) ) ) by L1698
.= ( ( varcl ( union D182 ) ) \/ ( vars R21 ) ) by L173
.= ( ( union D183 ) \/ ( vars R21 ) ) by L1732 , L1733 , XBOOLE_0:def 10;
end;
theorem
L1743: (for R8 being  initialized ConstructorSignature holds (for R21 being  pure (expression of R8 , ( a_Type R8 )) holds ( variables_in ( ( {} ( QuasiAdjs R8 ) ) ast R21 ) ) = ( variables_in R21 )))
proof
let R8 being  initialized ConstructorSignature;
let R21 being  pure (expression of R8 , ( a_Type R8 ));
set D184 = ( {} ( QuasiAdjs R8 ) );
set D185 = { ( variables_in B328 ) where B328 is (quasi-adjective of R8) : B328 in D184 };
L1744: D185 c= ( {} )
proof
let R5 being set;
assume L1745: R5 in D185;
L1746: (ex B329 being (quasi-adjective of R8) st (R5 = ( variables_in B329 ) & B329 in D184)) by L1745;
thus L1747: thesis by L1746;
end;
L1748: D185 = ( {} ) by L1744;
L1749: ( variables_in ( D184 ast R21 ) ) = ( ( union D185 ) \/ ( variables_in R21 ) ) by L1698;
thus L1750: thesis by L1749 , L1748 , ZFMISC_1:2;
end;
theorem
L1751: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds (R18 is  ground iff ( variables_in R18 ) = ( {} ))))
proof
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
thus L1752: (R18 is  ground implies ( variables_in R18 ) = ( {} ))
proof
assume L1753: ( Union ( R8 variables_in R18 ) ) = ( {} );
thus L1754: thesis by L1753 , L1 , XBOOLE_1:3;
end;

assume that
L1755: ( variables_in R18 ) = ( {} )
and
L1756: ( Union ( R8 variables_in R18 ) ) <> ( {} );
set D186 = the (Element of ( Union ( R8 variables_in R18 ) ));
L1757: (ex R6 being set st (R6 in ( dom ( R8 variables_in R18 ) ) & D186 in ( ( R8 variables_in R18 ) . R6 ))) by L1756 , CARD_5:2;
L1758: ( dom ( R8 variables_in R18 ) ) = (the carrier of R8) by PARTFUN1:def 2
.= { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
L1759: ( R8 variables_in R18 ) c= ( MSVars R8 ) by MSAFREE3:27;
L1760: ( ( MSVars R8 ) . ( an_Adj ) ) = ( {} ) by L840;
L1761: ( ( MSVars R8 ) . ( a_Type ) ) = ( {} ) by L840;
L1762: ( ( R8 variables_in R18 ) . ( an_Adj R8 ) ) c= ( {} ) by L1759 , L1760 , PBOOLE:def 2;
L1763: ( ( R8 variables_in R18 ) . ( a_Type R8 ) ) c= ( {} ) by L1759 , L1761 , PBOOLE:def 2;
thus L1764: thesis by L1763 , L1755 , L1757 , L1758 , L1762 , ENUMSET1:def 1;
end;
definition
let R8 being  initialized ConstructorSignature;
let C350 being (quasi-type of R8);
attr C350 is  ground
means
:L1765: ( variables_in C350 ) = ( {} );
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  ground  pure for (expression of R8 , ( a_Type R8 ));
existence
proof
consider C351 , C352 being (OperSymbol of R8) such that L1767: ( the_result_sort_of C351 ) = ( a_Type ) and L1768: ( the_arity_of C351 ) = ( {} ) and L1769: ( the_result_sort_of C352 ) = ( an_Adj ) and L1770: ( the_arity_of C352 ) = ( {} ) by L679;
L1771: ( root-tree [ C351 , (the carrier of R8) ] ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Type R8 ) ) by L1767 , L1768 , MSAFREE3:5;
reconsider D187 = ( root-tree [ C351 , (the carrier of R8) ] ) as (expression of R8 , ( a_Type R8 )) by L1771 , L890;
take D187;
set D188 = ( <*> ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) );
L1772: D187 = ( [ C351 , (the carrier of R8) ] -tree D188 ) by TREES_4:20;
L1773: C351 <> ( * ) by L1768 , L630;
L1774: C351 <> ( non_op ) by L1767 , L630;
L1775: C351 is  constructor by L1774 , L1773 , L670;
L1776: ( variables_in D187 ) c= ( {} )
proof
let R5 being set;
assume L1777: R5 in ( variables_in D187 );
L1778: R5 in ( union { ( variables_in B330 ) where B330 is (quasi-term of R8) : B330 in ( rng D188 ) } ) by L1777 , L1772 , L1775 , L1570;
consider R4 being set such that L1779: R5 in R4 and L1780: R4 in { ( variables_in B331 ) where B331 is (quasi-term of R8) : B331 in ( rng D188 ) } by L1778 , TARSKI:def 4;
L1781: (ex B332 being (quasi-term of R8) st (R4 = ( variables_in B332 ) & B332 in ( rng D188 ))) by L1780;
thus L1782: thesis by L1781;
end;
L1783: ( variables_in D187 ) = ( {} ) by L1776;
thus L1784: D187 is  ground by L1783 , L1751;
L1785: (ex B333 being (expression of R8 , ( a_Type R8 )) st (B333 = ( root-tree [ C351 , (the carrier of R8) ] ) & B333 is  pure)) by L1767 , L1768 , L1394;
thus L1786: thesis by L1785;
end;
cluster  ground for (quasi-adjective of R8);
existence
proof
consider C353 , C354 being (OperSymbol of R8) such that L1787: ( the_result_sort_of C353 ) = ( a_Type ) and L1788: ( the_arity_of C353 ) = ( {} ) and L1789: ( the_result_sort_of C354 ) = ( an_Adj ) and L1790: ( the_arity_of C354 ) = ( {} ) by L679;
consider C355 being (expression of R8 , ( an_Adj R8 )) such that L1791: C355 = ( root-tree [ C354 , (the carrier of R8) ] ) and L1792: C355 is  positive by L1789 , L1790 , L1404;
reconsider D189 = C355 as (quasi-adjective of R8) by L1792;
take D189;
set D190 = ( <*> ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) );
L1793: D189 = ( [ C354 , (the carrier of R8) ] -tree D190 ) by L1791 , TREES_4:20;
L1794: C354 <> ( * ) by L1789 , L630;
L1795: C354 <> ( non_op ) by L1790 , L630;
L1796: C354 is  constructor by L1795 , L1794 , L670;
L1797: ( variables_in D189 ) c= ( {} )
proof
let R5 being set;
assume L1798: R5 in ( variables_in D189 );
L1799: R5 in ( union { ( variables_in B334 ) where B334 is (quasi-term of R8) : B334 in ( rng D190 ) } ) by L1798 , L1793 , L1796 , L1570;
consider R4 being set such that L1800: R5 in R4 and L1801: R4 in { ( variables_in B335 ) where B335 is (quasi-term of R8) : B335 in ( rng D190 ) } by L1799 , TARSKI:def 4;
L1802: (ex B336 being (quasi-term of R8) st (R4 = ( variables_in B336 ) & B336 in ( rng D190 ))) by L1801;
thus L1803: thesis by L1802;
end;
L1804: ( variables_in D189 ) = ( {} ) by L1797;
thus L1805: thesis by L1804 , L1751;
end;
end;
theorem
L1807: (for R8 being  initialized ConstructorSignature holds (for B337 being  ground  pure (expression of R8 , ( a_Type R8 )) holds ( ( {} ( QuasiAdjs R8 ) ) ast B337 ) is  ground))
proof
let R8 being  initialized ConstructorSignature;
let C356 being  ground  pure (expression of R8 , ( a_Type R8 ));
set D191 = ( ( {} ( QuasiAdjs R8 ) ) ast C356 );
thus L1808: ( variables_in D191 ) = ( variables_in C356 ) by L1743
.= ( {} ) by L1751;
end;
registration
let R8 being  initialized ConstructorSignature;
let C357 being  ground  pure (expression of R8 , ( a_Type R8 ));
cluster ( ( {} ( QuasiAdjs R8 ) ) ast C357 ) ->  ground for (quasi-type of R8);
coherence by L1807;
end;
registration
let R8 being  initialized ConstructorSignature;
cluster  ground for (quasi-type of R8);
existence
proof
set D192 = the  ground  pure (expression of R8 , ( a_Type R8 ));
take ( ( {} ( QuasiAdjs R8 ) ) ast D192 );
thus L1810: thesis;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let C358 being  ground (quasi-type of R8);
let C359 being  ground (quasi-adjective of R8);
cluster ( C359 ast C358 ) ->  ground;
coherence
proof
thus L1812: ( variables_in ( C359 ast C358 ) ) = ( ( variables_in C359 ) \/ ( variables_in C358 ) ) by L1693
.= ( ( {} ) \/ ( variables_in C358 ) ) by L1751
.= ( {} ) by L1765;
end;
end;
begin
definition
func VarPoset ->  strict non  empty Poset equals 
( ( InclPoset { ( varcl B338 ) where B338 is  finite (Subset of ( Vars )) : (not contradiction) } ) opp );
coherence
proof
set D193 = the  finite (Subset of ( Vars ));
set D194 = { ( varcl B339 ) where B339 is  finite (Subset of ( Vars )) : (not contradiction) };
L1814: ( varcl D193 ) in D194;
reconsider D195 = D194 as non  empty set by L1814;
reconsider D196 = ( InclPoset D195 ) as non  empty Poset;
L1815: ( D196 opp ) is non  empty;
thus L1816: thesis by L1815;
end;
end;
theorem
L1818: (for B340 , B341 being (Element of ( VarPoset )) holds (B340 <= B341 iff B341 c= B340))
proof
let C360 , C361 being (Element of ( VarPoset ));
set D197 = { ( varcl B342 ) where B342 is  finite (Subset of ( Vars )) : (not contradiction) };
set D198 = the  finite (Subset of ( Vars ));
L1819: ( varcl D198 ) in D197;
reconsider D199 = D197 as non  empty set by L1819;
reconsider D200 = C360 , D201 = C361 as (Element of ( ( InclPoset D199 ) opp ));
L1820: (C360 <= C361 iff ( ~ D200 ) >= ( ~ D201 )) by YELLOW_7:1;
thus L1821: thesis by L1820 , YELLOW_1:3;
end;
theorem
L1822: (for R5 being set holds (R5 is (Element of ( VarPoset )) iff (R5 is  finite  finite  finite  finite (Subset of ( Vars )) & ( varcl R5 ) = R5)))
proof
let R5 being set;
set D202 = { ( varcl B343 ) where B343 is  finite (Subset of ( Vars )) : (not contradiction) };
set D203 = the  finite (Subset of ( Vars ));
L1823: ( varcl D203 ) in D202;
reconsider D204 = D202 as non  empty set by L1823;
L1824: (the carrier of ( InclPoset D204 )) = D204 by YELLOW_1:1;
L1825: (R5 is (Element of ( VarPoset )) iff R5 in D204) by L1824;
L1826: (R5 is (Element of ( VarPoset )) iff (ex B344 being  finite (Subset of ( Vars )) st R5 = ( varcl B344 ))) by L1825;
thus L1827: thesis by L1826 , L435;
end;
registration
cluster ( VarPoset ) ->  with_infima  with_suprema;
coherence
proof
set D205 = { ( varcl B345 ) where B345 is  finite (Subset of ( Vars )) : (not contradiction) };
set D206 = the  finite (Subset of ( Vars ));
L1828: ( varcl D206 ) in D205;
reconsider D207 = D205 as non  empty set by L1828;
L1829:
now
let R5 being set;
let R6 being set;
assume L1830: R5 in D207;
consider C362 being  finite (Subset of ( Vars )) such that L1831: R5 = ( varcl C362 ) by L1830;
assume L1832: R6 in D207;
consider C363 being  finite (Subset of ( Vars )) such that L1833: R6 = ( varcl C363 ) by L1832;
L1834: ( R5 \/ R6 ) = ( varcl ( C362 \/ C363 ) ) by L1831 , L1833 , L173;
thus L1835: ( R5 \/ R6 ) in D207 by L1834;
end;
L1836: ( InclPoset D207 ) is  with_suprema by L1829 , YELLOW_1:11;
thus L1837: ( VarPoset ) is  with_infima by L1836 , LATTICE3:10;
L1838:
now
let R5 being set;
let R6 being set;
assume L1839: R5 in D207;
consider C364 being  finite (Subset of ( Vars )) such that L1840: R5 = ( varcl C364 ) by L1839;
assume L1841: R6 in D207;
consider C365 being  finite (Subset of ( Vars )) such that L1842: R6 = ( varcl C365 ) by L1841;
reconsider D208 = ( varcl C364 ) , D209 = ( varcl C365 ) as  finite (Subset of ( Vars )) by L435;
L1843: ( R5 /\ R6 ) = ( varcl ( D208 /\ D209 ) ) by L1840 , L1842 , L199;
thus L1844: ( R5 /\ R6 ) in D207 by L1843;
end;
L1845: ( InclPoset D207 ) is  with_infima by L1838 , YELLOW_1:12;
thus L1846: thesis by L1845 , YELLOW_7:16;
end;
end;
theorem
L1848: (for B346 , B347 being (Element of ( VarPoset )) holds (( B346 "\/" B347 ) = ( B346 /\ B347 ) & ( B346 "/\" B347 ) = ( B346 \/ B347 )))
proof
let C366 , C367 being (Element of ( VarPoset ));
set D210 = { ( varcl B348 ) where B348 is  finite (Subset of ( Vars )) : (not contradiction) };
set D211 = the  finite (Subset of ( Vars ));
L1849: ( varcl D211 ) in D210;
reconsider D212 = D210 as non  empty set by L1849;
L1850: ( VarPoset ) = ( ( InclPoset D212 ) opp );
L1851: (the carrier of ( InclPoset D212 )) = D212 by YELLOW_1:1;
reconsider D213 = C366 , D214 = C367 as (Element of ( ( InclPoset D212 ) opp ));
reconsider D215 = C366 , D216 = C367 as (Element of ( InclPoset D212 ));
L1852: C366 in D212 by L1851;
consider C368 being  finite (Subset of ( Vars )) such that L1853: C366 = ( varcl C368 ) by L1852;
L1854: C367 in D212 by L1851;
consider C369 being  finite (Subset of ( Vars )) such that L1855: C367 = ( varcl C369 ) by L1854;
L1856: ( D215 ~ ) = D213;
L1857: ( D216 ~ ) = D214;
L1858: ( InclPoset D212 ) is  with_infima  with_suprema by L1850 , LATTICE3:10 , YELLOW_7:16;
reconsider D217 = C366 , D218 = C367 as  finite (Subset of ( Vars )) by L1853 , L1855 , L435;
L1859: ( C366 /\ C367 ) = ( varcl ( D217 /\ D218 ) ) by L1853 , L1855 , L199;
L1860: ( C366 /\ C367 ) in D212 by L1859;
L1861: ( D215 "/\" D216 ) = ( C366 /\ C367 ) by L1860 , YELLOW_1:9;
thus L1862: ( C366 "\/" C367 ) = ( C366 /\ C367 ) by L1861 , L1856 , L1857 , L1858 , YELLOW_7:21;
L1863: ( C366 \/ C367 ) = ( varcl ( C368 \/ C369 ) ) by L1853 , L1855 , L173;
L1864: ( D215 \/ D216 ) in D212 by L1863;
L1865: ( D215 "\/" D216 ) = ( C366 \/ C367 ) by L1864 , YELLOW_1:8;
thus L1866: thesis by L1865 , L1856 , L1857 , L1858 , YELLOW_7:23;
end;
registration
let C370 , C371 being (Element of ( VarPoset ));
identify C370 "\/" C371 with C370 /\ C371;
compatibility by L1848;
identify C370 "/\" C371 with C370 \/ C371;
compatibility by L1848;
end;
theorem
L1868: (for B349 being non  empty (Subset of ( VarPoset )) holds ( ex_sup_of B349 , ( VarPoset ) & ( sup B349 ) = ( meet B349 )))
proof
let C372 being non  empty (Subset of ( VarPoset ));
set D219 = the (Element of C372);
L1869: ( meet C372 ) c= D219 by SETFAM_1:3;
L1870: D219 is  finite  finite  finite  finite (Subset of ( Vars )) by L1822;
L1871: ( meet C372 ) c= ( Vars ) by L1870 , L1869 , XBOOLE_1:1;
L1872: (for B350 being (Element of C372) holds ( varcl B350 ) = B350) by L1822;
L1873: ( varcl ( meet C372 ) ) = ( meet C372 ) by L1872 , L186;
reconsider D220 = ( meet C372 ) as (Element of ( VarPoset )) by L1873 , L1869 , L1870 , L1871 , L1822;
L1874:
now
thus L1875: C372 is_<=_than D220
proof
let C373 being (Element of ( VarPoset ));
assume L1876: C373 in C372;
L1877: D220 c= C373 by L1876 , SETFAM_1:3;
thus L1878: thesis by L1877 , L1818;
end;

let C374 being (Element of ( VarPoset ));
assume L1879: C372 is_<=_than C374;
L1880:
now
let R4 being set;
assume L1881: R4 in C372;
reconsider D221 = R4 as (Element of ( VarPoset )) by L1881;
L1882: D221 <= C374 by L1879 , L1881 , LATTICE3:def 9;
thus L1883: C374 c= R4 by L1882 , L1818;
end;
L1884: C374 c= D220 by L1880 , SETFAM_1:5;
thus L1885: D220 <= C374 by L1884 , L1818;
end;
thus L1886:  ex_sup_of C372 , ( VarPoset ) by L1874 , YELLOW_0:15;
thus L1887: thesis by L1886 , L1874 , YELLOW_0:def 9;
end;
registration
cluster ( VarPoset ) ->  up-complete;
coherence
proof
L1888: (for B351 being non  empty  directed (Subset of ( VarPoset )) holds  ex_sup_of B351 , ( VarPoset )) by L1868;
thus L1889: thesis by L1888 , WAYBEL_0:75;
end;
end;
theorem
L1891: ( Top ( VarPoset ) ) = ( {} )
proof
set D222 = { ( varcl B352 ) where B352 is  finite (Subset of ( Vars )) : (not contradiction) };
L1892: ( {} ( Vars ) ) in D222 by L112;
L1893: ( ( VarPoset ) opp ) is  lower-bounded by YELLOW_7:31;
L1894: ( ( Bottom ( InclPoset D222 ) ) ~ ) = ( {} ) by L1892 , YELLOW_1:13;
thus L1895: thesis by L1894 , L1893 , YELLOW_7:33;
end;
definition
let R8 being  initialized ConstructorSignature;
func vars-function R8 -> (Function of ( QuasiTypes R8 ) , (the carrier of ( VarPoset ))) means 
(for B353 being (quasi-type of R8) holds ( it . B353 ) = ( vars B353 ));
uniqueness
proof
let C375 , C376 being (Function of ( QuasiTypes R8 ) , (the carrier of ( VarPoset )));
assume that
L1896: (for B354 being (quasi-type of R8) holds ( C375 . B354 ) = ( vars B354 ))
and
L1897: (for B355 being (quasi-type of R8) holds ( C376 . B355 ) = ( vars B355 ));
L1898:
now
let C377 being (Element of ( QuasiTypes R8 ));
reconsider D223 = C377 as (quasi-type of R8) by L1426;
thus L1899: ( C375 . C377 ) = ( vars D223 ) by L1896
.= ( C376 . C377 ) by L1897;
end;
thus L1900: thesis by L1898 , FUNCT_2:63;
end;
existence
proof
defpred S11[ set , set ] means (ex B356 being (quasi-type of R8) st ($1 = B356 & $2 = ( vars B356 )));
L1901: (for R5 being set holds (R5 in ( QuasiTypes R8 ) implies (ex B357 being set st S11[ R5 , B357 ])))
proof
let R5 being set;
assume L1902: R5 in ( QuasiTypes R8 );
reconsider D224 = R5 as (quasi-type of R8) by L1902 , L1426;
take ( vars D224 );
take D224;
thus L1903: thesis;
end;
consider C378 being Function such that L1904: ( dom C378 ) = ( QuasiTypes R8 ) and L1905: (for R5 being set holds (R5 in ( QuasiTypes R8 ) implies S11[ R5 , ( C378 . R5 ) ])) from CLASSES1:sch 1(L1901);
L1906: ( rng C378 ) c= (the carrier of ( VarPoset ))
proof
let R6 being set;
assume L1907: R6 in ( rng C378 );
consider R5 being set such that L1908: R5 in ( dom C378 ) and L1909: R6 = ( C378 . R5 ) by L1907 , FUNCT_1:def 3;
consider C379 being (quasi-type of R8) such that L1910: R5 = C379 and L1911: R6 = ( vars C379 ) by L1904 , L1905 , L1908 , L1909;
L1912: ( varcl ( vars C379 ) ) = ( vars C379 );
L1913: R6 is (Element of ( VarPoset )) by L1912 , L1911 , L1822;
thus L1914: thesis by L1913;
end;
reconsider D225 = C378 as (Function of ( QuasiTypes R8 ) , (the carrier of ( VarPoset ))) by L1906 , L1904 , FUNCT_2:2;
take D225;
let C380 being (quasi-type of R8);
L1915: C380 in ( QuasiTypes R8 ) by L1426;
L1916: (ex B358 being (quasi-type of R8) st (C380 = B358 & ( D225 . C380 ) = ( vars B358 ))) by L1915 , L1905;
thus L1917: thesis by L1916;
end;
end;
definition
let C381 being non  empty Poset;
attr C381 is  smooth
means
(ex B359 being  initialized ConstructorSignature st (ex B360 being (Function of C381 , ( VarPoset )) st ((the carrier of C381) c= ( QuasiTypes B359 ) & B360 = ( ( vars-function B359 ) | (the carrier of C381) ) & (for B361 , B362 being (Element of C381) holds B360 preserves_sup_of { B361 , B362 }))));
end;
registration
let C382 being  initialized ConstructorSignature;
let C383 being  ground (quasi-type of C382);
cluster RelStr (# { C383 } , ( id { C383 } ) #) ->  smooth;
coherence
proof
set D226 = RelStr (# { C383 } , ( id { C383 } ) #);
L1920: C383 in ( QuasiTypes C382 ) by L1426;
L1921: { C383 } c= ( QuasiTypes C382 ) by L1920 , ZFMISC_1:31;
reconsider D227 = ( ( vars-function C382 ) | { C383 } ) as (Function of D226 , ( VarPoset )) by L1921 , FUNCT_2:32;
take C382;
take D227;
thus L1922: (the carrier of D226) c= ( QuasiTypes C382 ) by L1920 , ZFMISC_1:31;
thus L1923: D227 = ( ( vars-function C382 ) | (the carrier of D226) );
let C384 , C385 being (Element of D226);
set D228 = { C384 , C385 };
assume L1924:  ex_sup_of D228 , D226;
L1925: C384 = C383 by TARSKI:def 1;
L1926: C385 = C383 by TARSKI:def 1;
L1927: D228 = { C383 } by L1926 , L1925 , ENUMSET1:29;
L1928: ( dom D227 ) = { C383 } by FUNCT_2:def 1;
L1929: ( Im (D227 , C383) ) = { ( D227 . C384 ) } by L1928 , L1925 , FUNCT_1:59;
thus L1930:  ex_sup_of ( D227 .: D228 ) , ( VarPoset ) by L1929 , L1927 , YELLOW_0:38;
thus L1931: ( sup ( D227 .: D228 ) ) = ( D227 . C384 ) by L1927 , L1929 , YELLOW_0:39
.= ( D227 . ( sup D228 ) ) by L1925 , TARSKI:def 1;
end;
end;
begin
scheme StructInd { F3() ->  initialized ConstructorSignature , P2[set] , F4() -> (expression of F3()) } : P2[ F4() ]
provided
L1933: (for B363 being variable holds P2[ ( B363 -term F3() ) ])
and
L1934: (for B364 being  constructor (OperSymbol of F3()) holds (for B365 being (FinSequence of ( QuasiTerms F3() )) holds ((( len B365 ) = ( len ( the_arity_of B364 ) ) & (for B366 being (quasi-term of F3()) holds (B366 in ( rng B365 ) implies P2[ B366 ]))) implies P2[ ( B364 -trm B365 ) ])))
and
L1935: (for B367 being (expression of F3() , ( an_Adj F3() )) holds (P2[ B367 ] implies P2[ ( ( non_op F3() ) term B367 ) ]))
and
L1936: (for B368 being (expression of F3() , ( an_Adj F3() )) holds (P2[ B368 ] implies (for B369 being (expression of F3() , ( a_Type F3() )) holds (P2[ B369 ] implies P2[ ( ( ast F3() ) term (B368 , B369) ) ]))))
proof
defpred S12[ set ] means ($1 is (expression of F3()) implies P2[ $1 ]);
set D229 = ( MSVars F3() );
set D230 = ( D229 \/ ( (the carrier of F3()) --> { ( 0 ) } ) );
set D231 = F3();
set D232 = F3();
L1937: F4() is (Term of D231 , D230) by MSAFREE3:8;
L1938: (for B370 being (SortSymbol of D231) holds (for B371 being (Element of ( D230 . B370 )) holds S12[ ( root-tree [ B371 , B370 ] ) ]))
proof
let C386 being (SortSymbol of D231);
let C387 being (Element of ( D230 . C386 ));
set D233 = ( root-tree [ C387 , C386 ] );
assume L1939: D233 is (expression of D231);
L1940: ( D233 . ( {} ) ) = [ C387 , C386 ] by TREES_4:3;
L1941: C386 in (the carrier of D232);
L1942: ( ( D233 . ( {} ) ) `2 ) = C386 by L1940 , MCART_1:7;
L1943: C386 <> (the carrier of D232) by L1941;
per cases  by L1939 , L1131;
suppose L1944: (ex B372 being variable st D233 = ( B372 -term D232 ));

thus L1945: thesis by L1944 , L1933;
end;
suppose L1946: (ex B373 being  constructor (OperSymbol of D232) st (ex B374 being (FinSequence of ( QuasiTerms D232 )) st (( len B374 ) = ( len ( the_arity_of B373 ) ) & D233 = ( B373 -trm B374 ))));

consider C388 being  constructor (OperSymbol of D232), C389 being (FinSequence of ( QuasiTerms D232 )) such that L1947: ( len C389 ) = ( len ( the_arity_of C388 ) ) and L1948: D233 = ( C388 -trm C389 ) by L1946;
L1949: D233 = ( [ C388 , (the carrier of D232) ] -tree C389 ) by L1947 , L1948 , L1118;
L1950: ( D233 . ( {} ) ) = [ C388 , (the carrier of D232) ] by L1949 , TREES_4:def 4;
thus L1951: thesis by L1950 , L1942 , L1943 , MCART_1:7;
end;
suppose L1952: (ex B375 being (expression of F3() , ( an_Adj F3() )) st D233 = ( ( non_op D232 ) term B375 ));

consider C390 being (expression of F3() , ( an_Adj F3() )) such that L1953: D233 = ( ( non_op D232 ) term C390 ) by L1952;
L1954: ( the_arity_of ( non_op D232 ) ) = <* ( an_Adj D232 ) *> by L630;
L1955: ( <* ( an_Adj D232 ) *> . 1 ) = ( an_Adj D232 ) by FINSEQ_1:40;
L1956: ( len <* ( an_Adj D232 ) *> ) = 1 by FINSEQ_1:40;
L1957: D233 = ( [ ( non_op D232 ) , (the carrier of D232) ] -tree <* C390 *> ) by L1956 , L1953 , L1954 , L1955 , L935;
L1958: ( D233 . ( {} ) ) = [ ( non_op D232 ) , (the carrier of D232) ] by L1957 , TREES_4:def 4;
thus L1959: thesis by L1958 , L1942 , L1943 , MCART_1:7;
end;
suppose L1960: (ex B376 being (expression of F3() , ( an_Adj F3() )) st (ex B377 being (expression of D232 , ( a_Type D232 )) st D233 = ( ( ast D232 ) term (B376 , B377) )));

consider C391 being (expression of D232 , ( an_Adj D232 )), C392 being (expression of D232 , ( a_Type D232 )) such that L1961: D233 = ( ( ast D232 ) term (C391 , C392) ) by L1960;
L1962: ( the_arity_of ( ast D232 ) ) = <* ( an_Adj D232 ) , ( a_Type D232 ) *> by L630;
L1963: ( <* ( an_Adj D232 ) , ( a_Type D232 ) *> . 1 ) = ( an_Adj D232 ) by FINSEQ_1:44;
L1964: ( <* ( an_Adj D232 ) , ( a_Type D232 ) *> . 2 ) = ( a_Type D232 ) by FINSEQ_1:44;
L1965: ( len <* ( an_Adj D232 ) , ( a_Type D232 ) *> ) = 2 by FINSEQ_1:44;
L1966: D233 = ( [ ( ast D232 ) , (the carrier of D232) ] -tree <* C391 , C392 *> ) by L1965 , L1961 , L1962 , L1963 , L1964 , L994;
L1967: ( D233 . ( {} ) ) = [ ( ast D232 ) , (the carrier of D232) ] by L1966 , TREES_4:def 4;
thus L1968: thesis by L1967 , L1942 , L1943 , MCART_1:7;
end;
end;
L1970: (for B378 being (OperSymbol of D231) holds (for B379 being (ArgumentSeq of ( Sym (B378 , D230) )) holds ((for B380 being (Term of D231 , D230) holds (B380 in ( rng B379 ) implies S12[ B380 ])) implies S12[ ( [ B378 , (the carrier of D231) ] -tree B379 ) ])))
proof
let C393 being (OperSymbol of D231);
let C394 being (ArgumentSeq of ( Sym (C393 , D230) ));
assume that
L1971: (for B381 being (Term of D231 , D230) holds (B381 in ( rng C394 ) implies S12[ B381 ]));
set D234 = ( [ C393 , (the carrier of D231) ] -tree C394 );
assume L1972: D234 is (expression of D231);
per cases  by L1972 , L1131;
suppose L1973: (ex B382 being variable st D234 = ( B382 -term D232 ));

thus L1974: thesis by L1973 , L1933;
end;
suppose L1975: (ex B383 being  constructor (OperSymbol of D232) st (ex B384 being (FinSequence of ( QuasiTerms D232 )) st (( len B384 ) = ( len ( the_arity_of B383 ) ) & D234 = ( B383 -trm B384 ))));

consider C395 being  constructor (OperSymbol of D232), C396 being (FinSequence of ( QuasiTerms D232 )) such that L1976: ( len C396 ) = ( len ( the_arity_of C395 ) ) and L1977: D234 = ( C395 -trm C396 ) by L1975;
L1978: D234 = ( [ C395 , (the carrier of D232) ] -tree C396 ) by L1976 , L1977 , L1118;
L1979: C394 = C396 by L1978 , TREES_4:15;
L1980:
now
let C397 being (quasi-term of D232);
L1981: C397 is (Term of D231 , D230) by MSAFREE3:8;
thus L1982: (C397 in ( rng C396 ) implies P2[ C397 ]) by L1981 , L1971 , L1979;
end;
thus L1983: thesis by L1980 , L1934 , L1976 , L1977;
end;
suppose L1984: (ex B385 being (expression of F3() , ( an_Adj F3() )) st D234 = ( ( non_op D232 ) term B385 ));

consider C398 being (expression of F3() , ( an_Adj F3() )) such that L1985: D234 = ( ( non_op D232 ) term C398 ) by L1984;
L1986: ( the_arity_of ( non_op D232 ) ) = <* ( an_Adj D232 ) *> by L630;
L1987: ( <* ( an_Adj D232 ) *> . 1 ) = ( an_Adj D232 ) by FINSEQ_1:40;
L1988: ( len <* ( an_Adj D232 ) *> ) = 1 by FINSEQ_1:40;
L1989: D234 = ( [ ( non_op D232 ) , (the carrier of D232) ] -tree <* C398 *> ) by L1988 , L1985 , L1986 , L1987 , L935;
L1990: C394 = <* C398 *> by L1989 , TREES_4:15;
L1991: ( rng <* C398 *> ) = { C398 } by FINSEQ_1:39;
L1992: C398 in { C398 } by TARSKI:def 1;
L1993: C398 is (Term of D231 , D230) by MSAFREE3:8;
thus L1994: thesis by L1993 , L1935 , L1971 , L1985 , L1990 , L1991 , L1992;
end;
suppose L1995: (ex B386 being (expression of F3() , ( an_Adj F3() )) st (ex B387 being (expression of D232 , ( a_Type D232 )) st D234 = ( ( ast D232 ) term (B386 , B387) )));

consider C399 being (expression of D232 , ( an_Adj D232 )), C400 being (expression of D232 , ( a_Type D232 )) such that L1996: D234 = ( ( ast D232 ) term (C399 , C400) ) by L1995;
L1997: ( the_arity_of ( ast D232 ) ) = <* ( an_Adj D232 ) , ( a_Type D232 ) *> by L630;
L1998: ( <* ( an_Adj D232 ) , ( a_Type D232 ) *> . 1 ) = ( an_Adj D232 ) by FINSEQ_1:44;
L1999: ( <* ( an_Adj D232 ) , ( a_Type D232 ) *> . 2 ) = ( a_Type D232 ) by FINSEQ_1:44;
L2000: ( len <* ( an_Adj D232 ) , ( a_Type D232 ) *> ) = 2 by FINSEQ_1:44;
L2001: D234 = ( [ ( ast D232 ) , (the carrier of D232) ] -tree <* C399 , C400 *> ) by L2000 , L1996 , L1997 , L1998 , L1999 , L994;
L2002: C394 = <* C399 , C400 *> by L2001 , TREES_4:15;
L2003: ( rng <* C399 , C400 *> ) = { C399 , C400 } by FINSEQ_2:127;
L2004: C399 in { C399 , C400 } by TARSKI:def 2;
L2005: C400 in { C399 , C400 } by TARSKI:def 2;
L2006: C399 is (Term of D231 , D230) by MSAFREE3:8;
L2007: C400 is (Term of D231 , D230) by MSAFREE3:8;
L2008: P2[ C399 ] by L1971 , L2002 , L2003 , L2004 , L2006;
thus L2009: thesis by L2008 , L1936 , L1971 , L1996 , L2002 , L2003 , L2005 , L2007;
end;
end;
L2011: (for B388 being (Term of D231 , D230) holds S12[ B388 ]) from MSATERM:sch 1(L1938 , L1970);
thus L2012: thesis by L2011 , L1937;
end;
definition
let C401 being ManySortedSign;
attr C401 is  with_an_operation_for_each_sort
means
:L2013: (the carrier of C401) c= ( rng (the ResultSort of C401) );
let C402 being (ManySortedSet of (the carrier of C401));
attr C402 is  with_missing_variables
means
:L2014: ( C402 " { ( {} ) } ) c= ( rng (the ResultSort of C401) );
end;
theorem
L2016: (for B389 being non  void Signature holds (for B390 being (ManySortedSet of (the carrier of B389)) holds (B390 is  with_missing_variables iff (for B391 being (SortSymbol of B389) holds (( B390 . B391 ) = ( {} ) implies (ex B392 being (OperSymbol of B389) st ( the_result_sort_of B392 ) = B391))))))
proof
let C403 being non  void Signature;
let C404 being (ManySortedSet of (the carrier of C403));
L2017: ( dom C404 ) = (the carrier of C403) by PARTFUN1:def 2;
thus L2018:now
assume L2019: C404 is  with_missing_variables;
L2020: ( C404 " { ( {} ) } ) c= ( rng (the ResultSort of C403) ) by L2019 , L2014;
let C405 being (SortSymbol of C403);
assume L2021: ( C404 . C405 ) = ( {} );
L2022: ( C404 . C405 ) in { ( {} ) } by L2021 , TARSKI:def 1;
L2023: C405 in ( C404 " { ( {} ) } ) by L2022 , L2017 , FUNCT_1:def 7;
consider C406 being set such that L2024: C406 in (the carrier' of C403) and L2025: ( (the ResultSort of C403) . C406 ) = C405 by L2023 , L2020 , FUNCT_2:11;
reconsider D235 = C406 as (OperSymbol of C403) by L2024;
take D236 = D235;
thus L2026: ( the_result_sort_of D236 ) = C405 by L2025;
end;
assume L2027: (for B393 being (SortSymbol of C403) holds (( C404 . B393 ) = ( {} ) implies (ex B394 being (OperSymbol of C403) st ( the_result_sort_of B394 ) = B393)));
let C407 being set;
assume L2028: C407 in ( C404 " { ( {} ) } );
L2029: ( C404 . C407 ) in { ( {} ) } by L2028 , FUNCT_1:def 7;
reconsider D237 = C407 as (SortSymbol of C403) by L2017 , L2028 , FUNCT_1:def 7;
L2030: ( C404 . D237 ) = ( {} ) by L2029 , TARSKI:def 1;
L2031: (ex B395 being (OperSymbol of C403) st ( the_result_sort_of B395 ) = D237) by L2030 , L2027;
thus L2032: thesis by L2031 , FUNCT_2:4;
end;
registration
cluster ( MaxConstrSign ) ->  with_an_operation_for_each_sort;
coherence
proof
set D238 = ( MaxConstrSign );
set D239 = [ ( a_Type ) , [ ( {} ) , ( 0 ) ] ];
set D240 = [ ( an_Adj ) , [ ( {} ) , ( 0 ) ] ];
set D241 = [ ( a_Term ) , [ ( {} ) , ( 0 ) ] ];
L2033: ( a_Type ) in { ( a_Type ) } by TARSKI:def 1;
L2034: ( an_Adj ) in { ( an_Adj ) } by TARSKI:def 1;
L2035: ( a_Term ) in { ( a_Term ) } by TARSKI:def 1;
L2036: [ ( <*> ( Vars ) ) , ( 0 ) ] in [: ( QuasiLoci ) , ( NAT ) :] by L511 , ZFMISC_1:def 2;
L2037: D239 in ( Modes ) by L2036 , L2033 , ZFMISC_1:def 2;
L2038: D240 in ( Attrs ) by L2034 , L2036 , ZFMISC_1:def 2;
L2039: D241 in ( Funcs ) by L2035 , L2036 , ZFMISC_1:def 2;
L2040: D239 in ( ( Modes ) \/ ( Attrs ) ) by L2037 , XBOOLE_0:def 3;
L2041: D240 in ( ( Modes ) \/ ( Attrs ) ) by L2038 , XBOOLE_0:def 3;
L2042: D239 in ( Constructors ) by L2040 , XBOOLE_0:def 3;
L2043: D240 in ( Constructors ) by L2041 , XBOOLE_0:def 3;
L2044: D241 in ( Constructors ) by L2039 , XBOOLE_0:def 3;
L2045: (the carrier' of ( MaxConstrSign )) = ( { ( * ) , ( non_op ) } \/ ( Constructors ) ) by L722;
reconsider D242 = D239 , D243 = D240 , D244 = D241 as (OperSymbol of ( MaxConstrSign )) by L2045 , L2042 , L2043 , L2044 , XBOOLE_0:def 3;
L2046: D242 is  constructor by L670;
L2047: D243 is  constructor by L670;
L2048: D244 is  constructor by L670;
L2049: ( (the ResultSort of D238) . D242 ) = ( D242 `1 ) by L2046 , L722;
L2050: ( (the ResultSort of D238) . D243 ) = ( D243 `1 ) by L2047 , L722;
L2051: ( (the ResultSort of D238) . D244 ) = ( D244 `1 ) by L2048 , L722;
L2052: ( (the ResultSort of D238) . D242 ) = ( a_Type ) by L2049 , MCART_1:7;
L2053: ( (the ResultSort of D238) . D243 ) = ( an_Adj ) by L2050 , MCART_1:7;
L2054: ( (the ResultSort of D238) . D244 ) = ( a_Term ) by L2051 , MCART_1:7;
L2055: (the carrier of D238) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
let C408 being set;
assume L2056: C408 in (the carrier of D238);
L2057: (C408 = ( a_Type ) or C408 = ( an_Adj ) or C408 = ( a_Term )) by L2056 , L2055 , ENUMSET1:def 1;
thus L2058: thesis by L2057 , L2052 , L2053 , L2054 , FUNCT_2:4;
end;
let C409 being ConstructorSignature;
cluster ( MSVars C409 ) ->  with_missing_variables;
coherence
proof
set D245 = ( MSVars C409 );
let C410 being set;
assume L2059: C410 in ( D245 " { ( {} ) } );
L2060: C410 in ( dom D245 ) by L2059 , FUNCT_1:def 7;
L2061: ( D245 . C410 ) in { ( {} ) } by L2059 , FUNCT_1:def 7;
L2062: C410 in (the carrier of C409) by L2060;
L2063: C410 in { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L2062 , L630;
L2064: (C410 = ( a_Type ) or C410 = ( an_Adj ) or C410 = ( a_Term )) by L2063 , ENUMSET1:def 1;
L2065: ( D245 . C410 ) = ( {} ) by L2061 , TARSKI:def 1;
L2066: ( (the ResultSort of C409) . ( ast C409 ) ) = ( a_Type ) by L630;
L2067: ( (the ResultSort of C409) . ( non_op C409 ) ) = ( an_Adj ) by L630;
thus L2068: thesis by L2067 , L2064 , L2065 , L2066 , L840 , FUNCT_2:4;
end;
end;
registration
let C411 being ManySortedSign;
cluster  non-empty ->  with_missing_variables for (ManySortedSet of (the carrier of C411));
coherence
proof
let C412 being (ManySortedSet of (the carrier of C411));
assume that
L2070: C412 is  non-empty;
let C413 being set;
assume L2071: C413 in ( C412 " { ( {} ) } );
L2072: C413 in ( dom C412 ) by L2071 , FUNCT_1:def 7;
L2073: ( C412 . C413 ) in { ( {} ) } by L2071 , FUNCT_1:def 7;
L2074: ( C412 . C413 ) in ( rng C412 ) by L2072 , FUNCT_1:def 3;
L2075: ( C412 . C413 ) = ( {} ) by L2073 , TARSKI:def 1;
thus L2076: thesis by L2075 , L2070 , L2074 , RELAT_1:def 9;
end;
end;
registration
let C414 being ManySortedSign;
cluster  with_missing_variables for (ManySortedSet of (the carrier of C414));
existence
proof
set D246 = the  non-empty (ManySortedSet of (the carrier of C414));
take D246;
thus L2078: thesis;
end;
end;
registration
cluster  initialized  with_an_operation_for_each_sort  strict for ConstructorSignature;
existence
proof
take ( MaxConstrSign );
thus L2080: thesis;
end;
end;
registration
let C415 being  with_an_operation_for_each_sort ManySortedSign;
cluster  ->  with_missing_variables for (ManySortedSet of (the carrier of C415));
coherence
proof
let C416 being (ManySortedSet of (the carrier of C415));
L2082: ( C416 " { ( {} ) } ) c= ( dom C416 ) by RELAT_1:132;
L2083: ( dom C416 ) = (the carrier of C415) by PARTFUN1:def 2;
L2084: (the carrier of C415) c= ( rng (the ResultSort of C415) ) by L2013;
thus L2085: ( C416 " { ( {} ) } ) c= ( rng (the ResultSort of C415) ) by L2084 , L2082 , L2083 , XBOOLE_1:1;
end;
end;
definition
let C417 being non  empty DTConstrStr;
redefine func Terminals C417 -> (Subset of C417);

coherence
proof
L2087: (the carrier of C417) = ( ( Terminals C417 ) \/ ( NonTerminals C417 ) ) by LANG1:1;
thus L2088: thesis by L2087 , XBOOLE_1:7;
end;
redefine func NonTerminals C417 -> (Subset of C417);

coherence
proof
L2089: (the carrier of C417) = ( ( Terminals C417 ) \/ ( NonTerminals C417 ) ) by LANG1:1;
thus L2090: thesis by L2089 , XBOOLE_1:7;
end;
end;
theorem
L2092: (for B396 , B397 being non  empty DTConstrStr holds ((the Rules of B396) c= (the Rules of B397) implies (( NonTerminals B396 ) c= ( NonTerminals B397 ) & ( (the carrier of B396) /\ ( Terminals B397 ) ) c= ( Terminals B396 ) & (( Terminals B396 ) c= ( Terminals B397 ) implies (the carrier of B396) c= (the carrier of B397)))))
proof
let C418 , C419 being non  empty DTConstrStr;
assume that
L2093: (the Rules of C418) c= (the Rules of C419);
thus L2094: ( NonTerminals C418 ) c= ( NonTerminals C419 )
proof
let C420 being set;
assume L2095: C420 in ( NonTerminals C418 );
L2096: (ex B398 being (Symbol of C418) st (C420 = B398 & (ex B399 being FinSequence st B398 ==> B399))) by L2095;
consider C421 being (Symbol of C418), C422 being FinSequence such that L2097: C420 = C421 and L2098: C421 ==> C422 by L2096;
L2099: [ C421 , C422 ] in (the Rules of C418) by L2098 , LANG1:def 1;
L2100: [ C421 , C422 ] in (the Rules of C419) by L2099 , L2093;
reconsider D247 = C421 as (Symbol of C419) by L2100 , ZFMISC_1:87;
L2101: D247 ==> C422 by L2093 , L2099 , LANG1:def 1;
thus L2102: thesis by L2101 , L2097;
end;

thus L2103:now
let C423 being set;
assume L2104: C423 in ( (the carrier of C418) /\ ( Terminals C419 ) );
L2105: C423 in ( Terminals C419 ) by L2104 , XBOOLE_0:def 4;
reconsider D248 = C423 as (Symbol of C418) by L2104 , XBOOLE_0:def 4;
reconsider D249 = C423 as (Symbol of C419) by L2104;
assume L2106: (not C423 in ( Terminals C418 ));
consider C424 being FinSequence such that L2107: D248 ==> C424 by L2106;
L2108: [ D248 , C424 ] in (the Rules of C418) by L2107 , LANG1:def 1;
L2109: D249 ==> C424 by L2108 , L2093 , LANG1:def 1;
L2110: (not (ex B400 being (Symbol of C419) st (C423 = B400 & (not (ex B401 being FinSequence st B400 ==> B401))))) by L2109;
thus L2111: contradiction by L2110 , L2105;
end;
assume L2112: ( Terminals C418 ) c= ( Terminals C419 );
L2113: ( ( Terminals C418 ) \/ ( NonTerminals C418 ) ) c= ( ( Terminals C419 ) \/ ( NonTerminals C419 ) ) by L2112 , L2094 , XBOOLE_1:13;
L2114: ( ( Terminals C418 ) \/ ( NonTerminals C418 ) ) c= (the carrier of C419) by L2113 , LANG1:1;
thus L2115: thesis by L2114 , LANG1:1;
end;
theorem
L2116: (for B402 , B403 being non  empty DTConstrStr holds ((( Terminals B402 ) c= ( Terminals B403 ) & (the Rules of B402) c= (the Rules of B403)) implies ( TS B402 ) c= ( TS B403 )))
proof
let C425 , C426 being non  empty DTConstrStr;
assume that
L2117: ( Terminals C425 ) c= ( Terminals C426 )
and
L2118: (the Rules of C425) c= (the Rules of C426);
L2119: (the carrier of C426) = ( ( Terminals C426 ) \/ ( NonTerminals C426 ) ) by LANG1:1;
L2120: (the carrier of C425) c= (the carrier of C426) by L2117 , L2118 , L2092;
defpred S13[ set ] means $1 in ( TS C426 );
L2121: (for B404 being (Symbol of C425) holds (B404 in ( Terminals C425 ) implies S13[ ( root-tree B404 ) ]))
proof
let C427 being (Symbol of C425);
assume L2122: C427 in ( Terminals C425 );
reconsider D250 = C427 as (Symbol of C426) by L2122 , L2117 , L2119 , XBOOLE_0:def 3;
L2123: ( root-tree C427 ) = ( root-tree D250 );
thus L2124: thesis by L2123 , L2117 , L2122 , DTCONSTR:def 1;
end;
L2125: (for B405 being (Symbol of C425) holds (for B406 being (FinSequence of ( TS C425 )) holds ((B405 ==> ( roots B406 ) & (for B407 being (DecoratedTree of (the carrier of C425)) holds (B407 in ( rng B406 ) implies S13[ B407 ]))) implies S13[ ( B405 -tree B406 ) ])))
proof
let C428 being (Symbol of C425);
let C429 being (FinSequence of ( TS C425 ));
assume that
L2126: [ C428 , ( roots C429 ) ] in (the Rules of C425)
and
L2127: (for B408 being (DecoratedTree of (the carrier of C425)) holds (B408 in ( rng C429 ) implies S13[ B408 ]));
L2128: ( rng C429 ) c= ( TS C426 )
proof
let C430 being set;
assume L2129: C430 in ( rng C429 );
thus L2130: thesis by L2127 , L2129;
end;
reconsider D251 = C429 as (FinSequence of ( TS C426 )) by L2128 , FINSEQ_1:def 4;
L2131: C428 in (the carrier of C425);
reconsider D252 = C428 as (Symbol of C426) by L2131 , L2120;
L2132: D252 ==> ( roots D251 ) by L2118 , L2126 , LANG1:def 1;
thus L2133: thesis by L2132 , DTCONSTR:def 1;
end;
L2134: (for B409 being (DecoratedTree of (the carrier of C425)) holds (B409 in ( TS C425 ) implies S13[ B409 ])) from DTCONSTR:sch 7(L2121 , L2125);
let C431 being set;
assume L2135: C431 in ( TS C425 );
reconsider D253 = C431 as (Element of ( FinTrees (the carrier of C425) )) by L2135;
L2136: S13[ D253 ] by L2134 , L2135;
thus L2137: thesis by L2136;
end;
theorem
L2138: (for B410 being ManySortedSign holds (for B411 , B412 being (ManySortedSet of (the carrier of B410)) holds (B411 c= B412 implies (B411 is  with_missing_variables implies B412 is  with_missing_variables))))
proof
let C432 being ManySortedSign;
let C433 , C434 being (ManySortedSet of (the carrier of C432));
assume that
L2139: C433 c= C434
and
L2140: ( C433 " { ( {} ) } ) c= ( rng (the ResultSort of C432) );
let C435 being set;
assume L2141: C435 in ( C434 " { ( {} ) } );
L2142: C435 in ( dom C434 ) by L2141 , FUNCT_1:def 7;
L2143: ( C434 . C435 ) in { ( {} ) } by L2141 , FUNCT_1:def 7;
L2144: ( dom C433 ) = (the carrier of C432) by PARTFUN1:def 2;
L2145: ( C434 . C435 ) = ( {} ) by L2143 , TARSKI:def 1;
L2146: ( C433 . C435 ) c= ( C434 . C435 ) by L2139 , L2142 , PBOOLE:def 2;
L2147: ( C433 . C435 ) = ( {} ) by L2146 , L2145;
L2148: ( C433 . C435 ) in { ( {} ) } by L2147 , TARSKI:def 1;
L2149: C435 in ( C433 " { ( {} ) } ) by L2148 , L2142 , L2144 , FUNCT_1:def 7;
thus L2150: thesis by L2149 , L2140;
end;
theorem
L2151: (for B413 being set holds (for B414 , B415 being (ManySortedSet of B413) holds (B414 c= B415 implies ( Union ( coprod B414 ) ) c= ( Union ( coprod B415 ) ))))
proof
let C436 being set;
let C437 , C438 being (ManySortedSet of C436);
assume that
L2152: C437 c= C438;
L2153: ( dom C438 ) = C436 by PARTFUN1:def 2;
let C439 being set;
assume L2154: C439 in ( Union ( coprod C437 ) );
L2155: ( C439 `2 ) in ( dom C437 ) by L2154 , CARD_3:22;
L2156: ( C439 `1 ) in ( C437 . ( C439 `2 ) ) by L2154 , CARD_3:22;
L2157: C439 = [ ( C439 `1 ) , ( C439 `2 ) ] by L2154 , CARD_3:22;
L2158: ( C437 . ( C439 `2 ) ) c= ( C438 . ( C439 `2 ) ) by L2152 , L2155 , PBOOLE:def 2;
thus L2159: thesis by L2158 , L2153 , L2155 , L2156 , L2157 , CARD_3:22;
end;
theorem
L2160: (for B416 being non  void Signature holds (for B417 , B418 being (ManySortedSet of (the carrier of B416)) holds (B417 c= B418 implies (the carrier of ( DTConMSA B417 )) c= (the carrier of ( DTConMSA B418 ))))) by L2151 , XBOOLE_1:9;
theorem
L2161: (for B419 being non  void Signature holds (for B420 being (ManySortedSet of (the carrier of B419)) holds (B420 is  with_missing_variables implies (( NonTerminals ( DTConMSA B420 ) ) = [: (the carrier' of B419) , { (the carrier of B419) } :] & ( Terminals ( DTConMSA B420 ) ) = ( Union ( coprod B420 ) )))))
proof
let C440 being non  void Signature;
let C441 being (ManySortedSet of (the carrier of C440));
assume that
L2162: C441 is  with_missing_variables;
set D254 = ( DTConMSA C441 );
set D255 = ( [: (the carrier' of C440) , { (the carrier of C440) } :] \/ ( Union ( coprod (C441 qua (ManySortedSet of (the carrier of C440))) ) ) );
L2163: ( Union ( coprod C441 ) ) misses [: (the carrier' of C440) , { (the carrier of C440) } :] by MSAFREE:4;
L2164: ( Terminals D254 ) misses ( NonTerminals D254 ) by DTCONSTR:8;
thus L2165: ( NonTerminals ( DTConMSA C441 ) ) c= [: (the carrier' of C440) , { (the carrier of C440) } :] by MSAFREE:6;
thus L2166: [: (the carrier' of C440) , { (the carrier of C440) } :] c= ( NonTerminals D254 )
proof
let C442 , C443 being set;
assume L2167: [ C442 , C443 ] in [: (the carrier' of C440) , { (the carrier of C440) } :];
L2168: C443 in { (the carrier of C440) } by L2167 , ZFMISC_1:87;
reconsider D256 = C442 as (OperSymbol of C440) by L2167 , ZFMISC_1:87;
L2169: (the carrier of C440) = C443 by L2168 , TARSKI:def 1;
reconsider D257 = [ D256 , (the carrier of C440) ] as (Element of (the carrier of D254)) by L2169 , L2167 , XBOOLE_0:def 3;
set D258 = ( the_arity_of D256 );
defpred S14[ set , set ] means ($2 in D255 & (( C441 . ( D258 . $1 ) ) <> ( {} ) implies $2 in ( coprod (( D258 . $1 ) , C441) )) & (( C441 . ( D258 . $1 ) ) = ( {} ) implies (ex B421 being (OperSymbol of C440) st ($2 = [ B421 , (the carrier of C440) ] & ( the_result_sort_of B421 ) = ( D258 . $1 )))));
L2170: (for B422 being set holds (B422 in ( Seg ( len D258 ) ) implies (ex B423 being set st S14[ B422 , B423 ])))
proof
let C444 being set;
assume L2171: C444 in ( Seg ( len D258 ) );
L2172: C444 in ( dom D258 ) by L2171 , FINSEQ_1:def 3;
L2173: ( D258 . C444 ) in ( rng D258 ) by L2172 , FUNCT_1:def 3;
reconsider D259 = ( D258 . C444 ) as (SortSymbol of C440) by L2173;
per cases ;
suppose L2174: ( C441 . ( D258 . C444 ) ) is non  empty;

consider C445 being set such that L2175: C445 in ( C441 . ( D258 . C444 ) ) by L2174 , XBOOLE_0:def 1;
take D260 = [ C445 , ( D258 . C444 ) ];
L2176: D260 in ( coprod (( D258 . C444 ) , C441) ) by L2173 , L2175 , MSAFREE:def 2;
L2177: ( D258 . C444 ) in ( rng D258 ) by L2172 , FUNCT_1:def 3;
L2178: ( dom ( coprod C441 ) ) = (the carrier of C440) by PARTFUN1:def 2;
L2179: ( ( coprod C441 ) . ( D258 . C444 ) ) in ( rng ( coprod C441 ) ) by L2178 , L2177 , FUNCT_1:def 3;
L2180: ( coprod (( D258 . C444 ) , C441) ) in ( rng ( coprod C441 ) ) by L2179 , L2177 , MSAFREE:def 3;
L2181: D260 in ( Union ( coprod C441 ) ) by L2180 , L2176 , TARSKI:def 4;
thus L2182: thesis by L2181 , L2173 , L2175 , MSAFREE:def 2 , XBOOLE_0:def 3;
end;
suppose L2183: ( C441 . ( D258 . C444 ) ) = ( {} );

consider C446 being (OperSymbol of C440) such that L2184: ( the_result_sort_of C446 ) = D259 by L2183 , L2162 , L2016;
take D261 = [ C446 , (the carrier of C440) ];
L2185: (the carrier of C440) in { (the carrier of C440) } by TARSKI:def 1;
L2186: D261 in [: (the carrier' of C440) , { (the carrier of C440) } :] by L2185 , ZFMISC_1:87;
thus L2187: thesis by L2186 , L2183 , L2184 , XBOOLE_0:def 3;
end;
end;
consider C447 being Function such that L2189: (( dom C447 ) = ( Seg ( len D258 ) ) & (for B424 being set holds (B424 in ( Seg ( len D258 ) ) implies S14[ B424 , ( C447 . B424 ) ]))) from CLASSES1:sch 1(L2170);
reconsider D262 = C447 as FinSequence by L2189 , FINSEQ_1:def 2;
L2190: ( rng D262 ) c= D255
proof
let C448 being set;
assume L2191: C448 in ( rng D262 );
L2192: (ex B425 being set st (B425 in ( dom D262 ) & ( D262 . B425 ) = C448)) by L2191 , FUNCT_1:def 3;
thus L2193: thesis by L2192 , L2189;
end;
reconsider D263 = D262 as (FinSequence of D255) by L2190 , FINSEQ_1:def 4;
reconsider D264 = D263 as (Element of ( D255 * )) by FINSEQ_1:def 11;
L2194: ( len D264 ) = ( len D258 ) by L2189 , FINSEQ_1:def 3;
L2195:
now
let C449 being set;
assume L2196: C449 in ( dom D264 );
L2197: S14[ C449 , ( D264 . C449 ) ] by L2196 , L2189;
L2198: ( dom D258 ) = ( Seg ( len D258 ) ) by FINSEQ_1:def 3;
L2199: ( D258 . C449 ) in ( rng D258 ) by L2198 , L2189 , L2196 , FUNCT_1:def 3;
L2200: ( dom ( coprod C441 ) ) = (the carrier of C440) by PARTFUN1:def 2;
L2201: ( ( coprod C441 ) . ( D258 . C449 ) ) in ( rng ( coprod C441 ) ) by L2200 , L2199 , FUNCT_1:def 3;
L2202: ( coprod (( D258 . C449 ) , C441) ) in ( rng ( coprod C441 ) ) by L2201 , L2199 , MSAFREE:def 3;
L2203: (( C441 . ( D258 . C449 ) ) <> ( {} ) implies ( D264 . C449 ) in ( Union ( coprod C441 ) )) by L2202 , L2197 , TARSKI:def 4;
thus L2204: (( D264 . C449 ) in [: (the carrier' of C440) , { (the carrier of C440) } :] implies (for B426 being (OperSymbol of C440) holds ([ B426 , (the carrier of C440) ] = ( D264 . C449 ) implies ( the_result_sort_of B426 ) = ( D258 . C449 )))) by L2203 , L2163 , L2197 , XBOOLE_0:3 , XTUPLE_0:1;
assume L2205: ( D264 . C449 ) in ( Union ( coprod C441 ) );
L2206:
now
assume L2207: ( C441 . ( D258 . C449 ) ) = ( {} );
L2208: (ex B427 being (OperSymbol of C440) st (( D264 . C449 ) = [ B427 , (the carrier of C440) ] & ( the_result_sort_of B427 ) = ( D258 . C449 ))) by L2207 , L2189 , L2196;
L2209: (the carrier of C440) in { (the carrier of C440) } by TARSKI:def 1;
L2210: ( D264 . C449 ) in [: (the carrier' of C440) , { (the carrier of C440) } :] by L2209 , L2208 , ZFMISC_1:87;
thus L2211: contradiction by L2210 , L2163 , L2205 , XBOOLE_0:3;
end;
thus L2212: ( D264 . C449 ) in ( coprod (( D258 . C449 ) , C441) ) by L2206 , L2189 , L2196;
end;
L2213: [ D257 , D264 ] in ( REL C441 ) by L2195 , L2194 , MSAFREE:5;
L2214: D257 ==> D264 by L2213 , LANG1:def 1;
thus L2215: thesis by L2214 , L2169;
end;

thus L2216: ( Terminals D254 ) c= ( Union ( coprod C441 ) )
proof
let C450 being set;
assume L2217: C450 in ( Terminals D254 );
L2218: (not C450 in [: (the carrier' of C440) , { (the carrier of C440) } :]) by L2217 , L2164 , L2166 , XBOOLE_0:3;
thus L2219: thesis by L2218 , L2217 , XBOOLE_0:def 3;
end;

thus L2220: thesis by MSAFREE:6;
end;
theorem
L2221: (for B428 being non  void Signature holds (for B429 , B430 being (ManySortedSet of (the carrier of B428)) holds ((B429 c= B430 & B429 is  with_missing_variables) implies (( Terminals ( DTConMSA B429 ) ) c= ( Terminals ( DTConMSA B430 ) ) & (the Rules of ( DTConMSA B429 )) c= (the Rules of ( DTConMSA B430 )) & ( TS ( DTConMSA B429 ) ) c= ( TS ( DTConMSA B430 ) )))))
proof
let C451 being non  void Signature;
let C452 , C453 being (ManySortedSet of (the carrier of C451));
assume that
L2222: C452 c= C453
and
L2223: C452 is  with_missing_variables;
L2224: C453 is  with_missing_variables by L2222 , L2223 , L2138;
set D265 = ( DTConMSA C452 );
set D266 = ( DTConMSA C453 );
L2225: (the carrier of D265) c= (the carrier of D266) by L2222 , L2151 , XBOOLE_1:9;
L2226: ( Terminals D265 ) = ( Union ( coprod C452 ) ) by L2223 , L2161;
L2227: ( Terminals D266 ) = ( Union ( coprod C453 ) ) by L2224 , L2161;
thus L2228: ( Terminals D265 ) c= ( Terminals D266 ) by L2227 , L2222 , L2226 , L2151;
L2229: ( (the carrier of D265) * ) c= ( (the carrier of D266) * ) by L2225 , FINSEQ_1:62;
thus L2230: (the Rules of D265) c= (the Rules of D266)
proof
let C454 , C455 being set;
assume L2231: [ C454 , C455 ] in (the Rules of D265);
L2232: C454 in [: (the carrier' of C451) , { (the carrier of C451) } :] by L2231 , MSAFREE1:2;
L2233: C455 in ( ( [: (the carrier' of C451) , { (the carrier of C451) } :] \/ ( Union ( coprod C452 ) ) ) * ) by L2231 , MSAFREE1:2;
reconsider D267 = C454 as (Element of ( [: (the carrier' of C451) , { (the carrier of C451) } :] \/ ( Union ( coprod C452 ) ) )) by L2232 , XBOOLE_0:def 3;
reconsider D268 = D267 as (Element of ( [: (the carrier' of C451) , { (the carrier of C451) } :] \/ ( Union ( coprod C453 ) ) )) by L2232 , XBOOLE_0:def 3;
reconsider D269 = C455 as (Element of ( ( [: (the carrier' of C451) , { (the carrier of C451) } :] \/ ( Union ( coprod C452 ) ) ) * )) by L2231 , MSAFREE1:2;
reconsider D270 = D269 as (Element of ( ( [: (the carrier' of C451) , { (the carrier of C451) } :] \/ ( Union ( coprod C453 ) ) ) * )) by L2229 , L2233;
L2234:
now
let C456 being (OperSymbol of C451);
assume L2235: [ C456 , (the carrier of C451) ] = D268;
thus L2236: ( len D270 ) = ( len ( the_arity_of C456 ) ) by L2235 , L2231 , MSAFREE:def 7;
let C457 being set;
assume L2237: C457 in ( dom D270 );
thus L2238: (( D270 . C457 ) in [: (the carrier' of C451) , { (the carrier of C451) } :] implies (for B431 being (OperSymbol of C451) holds ([ B431 , (the carrier of C451) ] = ( D269 . C457 ) implies ( the_result_sort_of B431 ) = ( ( the_arity_of C456 ) . C457 )))) by L2237 , L2231 , L2235 , MSAFREE:def 7;
L2239: ( Union ( coprod C453 ) ) misses [: (the carrier' of C451) , { (the carrier of C451) } :] by MSAFREE:4;
L2240: ( D269 . C457 ) in ( [: (the carrier' of C451) , { (the carrier of C451) } :] \/ ( Union ( coprod C452 ) ) ) by L2237 , DTCONSTR:2;
L2241: ( dom D270 ) = ( Seg ( len D270 ) ) by FINSEQ_1:def 3;
L2242: ( dom ( the_arity_of C456 ) ) = ( Seg ( len D270 ) ) by L2236 , FINSEQ_1:def 3;
L2243: ( ( the_arity_of C456 ) . C457 ) in (the carrier of C451) by L2242 , L2237 , L2241 , DTCONSTR:2;
assume L2244: ( D270 . C457 ) in ( Union ( coprod C453 ) );
L2245: (( D269 . C457 ) in [: (the carrier' of C451) , { (the carrier of C451) } :] or ( D269 . C457 ) in ( Union ( coprod C452 ) )) by L2240 , XBOOLE_0:def 3;
L2246: ( D269 . C457 ) in ( coprod (( ( the_arity_of C456 ) . C457 ) , C452) ) by L2245 , L2231 , L2235 , L2237 , L2239 , L2244 , MSAFREE:def 7 , XBOOLE_0:3;
L2247: (ex B432 being set st (B432 in ( C452 . ( ( the_arity_of C456 ) . C457 ) ) & ( D269 . C457 ) = [ B432 , ( ( the_arity_of C456 ) . C457 ) ])) by L2246 , L2243 , MSAFREE:def 2;
L2248: ( C452 . ( ( the_arity_of C456 ) . C457 ) ) c= ( C453 . ( ( the_arity_of C456 ) . C457 ) ) by L2222 , L2243 , PBOOLE:def 2;
thus L2249: ( D270 . C457 ) in ( coprod (( ( the_arity_of C456 ) . C457 ) , C453) ) by L2248 , L2243 , L2247 , MSAFREE:def 2;
end;
thus L2250: thesis by L2234 , L2232 , MSAFREE:def 7;
end;

thus L2251: thesis by L2230 , L2222 , L2226 , L2227 , L2116 , L2151;
end;
theorem
L2252: (for R8 being  initialized ConstructorSignature holds (for B433 being set holds (B433 in ( Terminals ( DTConMSA ( MSVars R8 ) ) ) iff (ex B434 being variable st B433 = [ B434 , ( a_Term R8 ) ]))))
proof
let R8 being  initialized ConstructorSignature;
let C458 being set;
set D271 = ( MSVars R8 );
L2253: ( Terminals ( DTConMSA D271 ) ) = ( Union ( coprod D271 ) ) by L2161;
L2254: ( dom D271 ) = (the carrier of R8) by PARTFUN1:def 2;
L2255: (the carrier of R8) = { ( a_Type ) , ( an_Adj ) , ( a_Term ) } by L630;
L2256: ( D271 . ( a_Type ) ) = ( {} ) by L840;
L2257: ( D271 . ( an_Adj ) ) = ( {} ) by L840;
L2258: ( D271 . ( a_Term ) ) = ( Vars ) by L840;
thus L2259:now
assume L2260: C458 in ( Terminals ( DTConMSA D271 ) );
L2261: ( C458 `2 ) in ( dom D271 ) by L2260 , L2253 , CARD_3:22;
L2262: ( C458 `1 ) in ( D271 . ( C458 `2 ) ) by L2253 , L2260 , CARD_3:22;
L2263: (( C458 `2 ) = ( a_Type ) or ( C458 `2 ) = ( an_Adj ) or ( C458 `2 ) = ( a_Term )) by L2255 , L2261 , ENUMSET1:def 1;
reconsider D272 = ( C458 `1 ) as variable by L2255 , L2256 , L2257 , L2258 , L2261 , L2262 , ENUMSET1:def 1;
take D273 = D272;
thus L2264: C458 = [ D273 , ( a_Term R8 ) ] by L2253 , L2256 , L2257 , L2260 , L2263 , CARD_3:22;
end;
given C459 being variable such that
L2265: C458 = [ C459 , ( a_Term R8 ) ];

L2266: ( C458 `1 ) = C459 by L2265 , MCART_1:7;
L2267: ( C458 `2 ) = ( a_Term ) by L2265 , MCART_1:7;
thus L2268: thesis by L2267 , L2253 , L2254 , L2258 , L2265 , L2266 , CARD_3:22;
end;
theorem
L2269: (for R8 being  initialized ConstructorSignature holds (for B435 being set holds (B435 in ( NonTerminals ( DTConMSA ( MSVars R8 ) ) ) iff (B435 = [ ( ast R8 ) , (the carrier of R8) ] or B435 = [ ( non_op R8 ) , (the carrier of R8) ] or (ex B436 being  constructor (OperSymbol of R8) st B435 = [ B436 , (the carrier of R8) ])))))
proof
let R8 being  initialized ConstructorSignature;
let C460 being set;
set D274 = ( MSVars R8 );
L2270: ( NonTerminals ( DTConMSA D274 ) ) = [: (the carrier' of R8) , { (the carrier of R8) } :] by L2161;
thus L2271:now
assume L2272: C460 in ( NonTerminals ( DTConMSA ( MSVars R8 ) ) );
consider C461 , C462 being set such that L2273: C461 in (the carrier' of R8) and L2274: C462 in { (the carrier of R8) } and L2275: C460 = [ C461 , C462 ] by L2272 , L2270 , ZFMISC_1:def 2;
reconsider D275 = C461 as (OperSymbol of R8) by L2273;
L2276: C462 = (the carrier of R8) by L2274 , TARSKI:def 1;
L2277: (D275 is  constructor or (not D275 is  constructor));
thus L2278: (C460 = [ ( ast R8 ) , (the carrier of R8) ] or C460 = [ ( non_op R8 ) , (the carrier of R8) ] or (ex B437 being  constructor (OperSymbol of R8) st C460 = [ B437 , (the carrier of R8) ])) by L2277 , L2275 , L2276 , L670;
end;
L2279: (the carrier of R8) in { (the carrier of R8) } by TARSKI:def 1;
thus L2280: thesis by L2279 , L2270 , ZFMISC_1:87;
end;
theorem
L2281: (for B438 being non  void Signature holds (for B439 being  with_missing_variables (ManySortedSet of (the carrier of B438)) holds (for B440 being set holds (B440 in ( Union (the Sorts of ( Free (B438 , B439) )) ) implies B440 is (Term of B438 , ( B439 \/ ( (the carrier of B438) --> { ( 0 ) } ) ))))))
proof
let C463 being non  void Signature;
let C464 being  with_missing_variables (ManySortedSet of (the carrier of C463));
set D276 = ( C464 \/ ( (the carrier of C463) --> { ( 0 ) } ) );
set D277 = ( Free (C463 , C464) );
set D278 = (the Sorts of D277);
L2282: D278 = ( C463 -Terms (C464 , D276) ) by MSAFREE3:24;
let C465 being set;
assume L2283: C465 in ( Union D278 );
consider C466 being set such that L2284: C466 in ( dom D278 ) and L2285: C465 in ( D278 . C466 ) by L2283 , CARD_5:2;
reconsider D279 = C466 as (SortSymbol of C463) by L2284;
L2286: ( D278 . D279 ) = { B441 where B441 is (Term of C463 , D276) : (( the_sort_of B441 ) = D279 & ( variables_in B441 ) c= C464) } by L2282 , MSAFREE3:def 5;
L2287: (ex B442 being (Term of C463 , D276) st (C465 = B442 & ( the_sort_of B442 ) = D279 & ( variables_in B442 ) c= C464)) by L2286 , L2285;
thus L2288: thesis by L2287;
end;
theorem
L2289: (for B443 being non  void Signature holds (for B444 being  with_missing_variables (ManySortedSet of (the carrier of B443)) holds (for B445 being (Term of B443 , ( B444 \/ ( (the carrier of B443) --> { ( 0 ) } ) )) holds (B445 in ( Union (the Sorts of ( Free (B443 , B444) )) ) implies B445 in ( (the Sorts of ( Free (B443 , B444) )) . ( the_sort_of B445 ) )))))
proof
let C467 being non  void Signature;
let C468 being  with_missing_variables (ManySortedSet of (the carrier of C467));
set D280 = ( C468 \/ ( (the carrier of C467) --> { ( 0 ) } ) );
set D281 = ( Free (C467 , C468) );
set D282 = (the Sorts of D281);
L2290: D282 = ( C467 -Terms (C468 , D280) ) by MSAFREE3:24;
let C469 being (Term of C467 , ( C468 \/ ( (the carrier of C467) --> { ( 0 ) } ) ));
assume L2291: C469 in ( Union D282 );
consider C470 being set such that L2292: C470 in ( dom D282 ) and L2293: C469 in ( D282 . C470 ) by L2291 , CARD_5:2;
reconsider D283 = C470 as (SortSymbol of C467) by L2292;
L2294: ( D282 . D283 ) = { B446 where B446 is (Term of C467 , D280) : (( the_sort_of B446 ) = D283 & ( variables_in B446 ) c= C468) } by L2290 , MSAFREE3:def 5;
L2295: (ex B447 being (Term of C467 , D280) st (C469 = B447 & ( the_sort_of B447 ) = D283 & ( variables_in B447 ) c= C468)) by L2294 , L2293;
thus L2296: thesis by L2295 , L2293;
end;
theorem
L2297: (for B448 being non  empty DTConstrStr holds (for B449 being (Element of B448) holds (for B450 being FinSequence holds (B449 ==> B450 implies B450 is (FinSequence of (the carrier of B448))))))
proof
let C471 being non  empty DTConstrStr;
let C472 being (Element of C471);
let C473 being FinSequence;
assume L2298: C472 ==> C473;
L2299: [ C472 , C473 ] in (the Rules of C471) by L2298 , LANG1:def 1;
L2300: C473 in ( (the carrier of C471) * ) by L2299 , ZFMISC_1:87;
thus L2301: thesis by L2300 , FINSEQ_1:def 11;
end;
theorem
L2302: (for B451 being non  void Signature holds (for B452 , B453 being (ManySortedSet of (the carrier of B451)) holds (for B454 being (Symbol of ( DTConMSA B452 )) holds (for B455 being (Symbol of ( DTConMSA B453 )) holds (for B456 being (FinSequence of (the carrier of ( DTConMSA B452 ))) holds (for B457 being (FinSequence of (the carrier of ( DTConMSA B453 ))) holds ((B454 = B455 & B456 = B457 & B454 ==> B456) implies B455 ==> B457)))))))
proof
let C474 being non  void Signature;
let C475 , C476 being (ManySortedSet of (the carrier of C474));
L2303: ( dom C476 ) = (the carrier of C474) by PARTFUN1:def 2;
set D284 = ( DTConMSA C475 );
set D285 = ( DTConMSA C476 );
let C477 being (Symbol of D284);
let C478 being (Symbol of D285);
let C479 being (FinSequence of (the carrier of D284));
let C480 being (FinSequence of (the carrier of D285));
assume that
L2304: C477 = C478
and
L2305: C479 = C480
and
L2306: C477 ==> C479;
L2307: [ C477 , C479 ] in ( REL C475 ) by L2306 , LANG1:def 1;
L2308: C479 in ( ( [: (the carrier' of C474) , { (the carrier of C474) } :] \/ ( Union ( coprod C475 ) ) ) * ) by L2307 , ZFMISC_1:87;
L2309: C477 in [: (the carrier' of C474) , { (the carrier of C474) } :] by L2308 , L2307 , MSAFREE:def 7;
L2310: C480 in ( ( [: (the carrier' of C474) , { (the carrier of C474) } :] \/ ( Union ( coprod C476 ) ) ) * ) by FINSEQ_1:def 11;
L2311:
now
let C481 being (OperSymbol of C474);
assume L2312: [ C481 , (the carrier of C474) ] = C478;
thus L2313: ( len C480 ) = ( len ( the_arity_of C481 ) ) by L2312 , L2304 , L2305 , L2307 , L2308 , MSAFREE:def 7;
let C482 being set;
assume L2314: C482 in ( dom C480 );
thus L2315: (( C480 . C482 ) in [: (the carrier' of C474) , { (the carrier of C474) } :] implies (for B458 being (OperSymbol of C474) holds ([ B458 , (the carrier of C474) ] = ( C480 . C482 ) implies ( the_result_sort_of B458 ) = ( ( the_arity_of C481 ) . C482 )))) by L2314 , L2304 , L2305 , L2307 , L2308 , L2312 , MSAFREE:def 7;
L2316: C482 in ( dom ( the_arity_of C481 ) ) by L2313 , L2314 , FINSEQ_3:29;
L2317: ( ( the_arity_of C481 ) . C482 ) in ( rng ( the_arity_of C481 ) ) by L2316 , FUNCT_1:def 3;
reconsider D286 = ( ( the_arity_of C481 ) . C482 ) as (SortSymbol of C474) by L2317;
assume L2318: ( C480 . C482 ) in ( Union ( coprod C476 ) );
L2319: ( ( C480 . C482 ) `2 ) in ( dom C476 ) by L2318 , CARD_3:22;
L2320: ( ( C480 . C482 ) `1 ) in ( C476 . ( ( C480 . C482 ) `2 ) ) by L2318 , CARD_3:22;
L2321: ( C480 . C482 ) = [ ( ( C480 . C482 ) `1 ) , ( ( C480 . C482 ) `2 ) ] by L2318 , CARD_3:22;
L2322: ( C480 . C482 ) in ( rng C479 ) by L2305 , L2314 , FUNCT_1:def 3;
L2323: (((the carrier of C474) nin (the carrier of C474) & ( C480 . C482 ) in [: (the carrier' of C474) , { (the carrier of C474) } :]) or ( C480 . C482 ) in ( Union ( coprod C475 ) )) by L2322 , XBOOLE_0:def 3;
L2324: ( C480 . C482 ) in ( coprod (D286 , C475) ) by L2323 , L2303 , L2304 , L2305 , L2307 , L2308 , L2312 , L2314 , L2319 , L2321 , MSAFREE:def 7 , ZFMISC_1:106;
L2325: (ex B459 being set st (B459 in ( C475 . D286 ) & ( C480 . C482 ) = [ B459 , D286 ])) by L2324 , MSAFREE:def 2;
L2326: D286 = ( ( C480 . C482 ) `2 ) by L2325 , L2321 , XTUPLE_0:1;
thus L2327: ( C480 . C482 ) in ( coprod (( ( the_arity_of C481 ) . C482 ) , C476) ) by L2326 , L2320 , L2321 , MSAFREE:def 2;
end;
L2328: [ C478 , C480 ] in ( REL C476 ) by L2311 , L2304 , L2309 , L2310 , MSAFREE:def 7;
thus L2329: thesis by L2328 , LANG1:def 1;
end;
theorem
L2330: (for B460 being non  void Signature holds (for B461 being  with_missing_variables (ManySortedSet of (the carrier of B460)) holds ( Union (the Sorts of ( Free (B460 , B461) )) ) = ( TS ( DTConMSA B461 ) )))
proof
let C483 being non  void Signature;
let C484 being  with_missing_variables (ManySortedSet of (the carrier of C483));
set D287 = ( C484 \/ ( (the carrier of C483) --> { ( 0 ) } ) );
set D288 = ( Free (C483 , C484) );
set D289 = (the Sorts of D288);
set D290 = ( DTConMSA C484 );
L2331: D289 = ( C483 -Terms (C484 , D287) ) by MSAFREE3:24;
L2332: ( dom D289 ) = (the carrier of C483) by PARTFUN1:def 2;
defpred S15[ set ] means ($1 in ( Union D289 ) implies $1 in ( TS D290 ));
L2333: (for B462 being (SortSymbol of C483) holds (for B463 being (Element of ( D287 . B462 )) holds S15[ ( root-tree [ B463 , B462 ] ) ]))
proof
let C485 being (SortSymbol of C483);
let C486 being (Element of ( D287 . C485 ));
assume L2334: ( root-tree [ C486 , C485 ] ) in ( Union D289 );
consider C487 being set such that L2335: C487 in ( dom D289 ) and L2336: ( root-tree [ C486 , C485 ] ) in ( D289 . C487 ) by L2334 , CARD_5:2;
reconsider D291 = C487 as (SortSymbol of C483) by L2335;
L2337: ( D289 . D291 ) = { B464 where B464 is (Term of C483 , D287) : (( the_sort_of B464 ) = D291 & ( variables_in B464 ) c= C484) } by L2331 , MSAFREE3:def 5;
consider C488 being (Term of C483 , D287) such that L2338: ( root-tree [ C486 , C485 ] ) = C488 and L2339: ( the_sort_of C488 ) = D291 and L2340: ( variables_in C488 ) c= C484 by L2337 , L2336;
L2341: ( ( variables_in C488 ) . C485 ) = { C486 } by L2338 , MSAFREE3:10;
L2342: { C486 } c= ( C484 . C485 ) by L2341 , L2340 , PBOOLE:def 2;
L2343: C486 in ( C484 . C485 ) by L2342 , ZFMISC_1:31;
L2344: [ C486 , C485 ] in ( Terminals D290 ) by L2343 , MSAFREE:7;
thus L2345: thesis by L2344 , DTCONSTR:def 1;
end;
L2346: (for B465 being (OperSymbol of C483) holds (for B466 being (ArgumentSeq of ( Sym (B465 , D287) )) holds ((for B467 being (Term of C483 , D287) holds (B467 in ( rng B466 ) implies S15[ B467 ])) implies S15[ ( [ B465 , (the carrier of C483) ] -tree B466 ) ])))
proof
let C489 being (OperSymbol of C483);
let C490 being (ArgumentSeq of ( Sym (C489 , D287) ));
assume that
L2347: (for B468 being (Term of C483 , D287) holds (B468 in ( rng C490 ) implies S15[ B468 ]))
and
L2348: ( [ C489 , (the carrier of C483) ] -tree C490 ) in ( Union D289 );
consider C491 being set such that L2349: C491 in ( dom D289 ) and L2350: ( [ C489 , (the carrier of C483) ] -tree C490 ) in ( D289 . C491 ) by L2348 , CARD_5:2;
reconsider D292 = C491 as (SortSymbol of C483) by L2349;
L2351: ( D289 . D292 ) = { B469 where B469 is (Term of C483 , D287) : (( the_sort_of B469 ) = D292 & ( variables_in B469 ) c= C484) } by L2331 , MSAFREE3:def 5;
consider C492 being (Term of C483 , D287) such that L2352: ( [ C489 , (the carrier of C483) ] -tree C490 ) = C492 and L2353: ( the_sort_of C492 ) = D292 and L2354: ( variables_in C492 ) c= C484 by L2351 , L2350;
L2355: ( C492 . ( {} ) ) = [ C489 , (the carrier of C483) ] by L2352 , TREES_4:def 4;
L2356: ( the_result_sort_of C489 ) = D292 by L2355 , L2353 , MSATERM:17;
L2357: ( rng C490 ) c= ( Union D289 ) by L2356 , L2331 , L2350 , MSAFREE3:19;
L2358: ( rng C490 ) c= ( TS D290 )
proof
let C493 being set;
assume L2359: C493 in ( rng C490 );
L2360: C493 is (Term of C483 , D287) by L2359 , L2357 , L2281;
thus L2361: thesis by L2360 , L2347 , L2357 , L2359;
end;
reconsider D293 = C490 as (FinSequence of ( TS D290 )) by L2358 , FINSEQ_1:def 4;
L2362: ( NonTerminals D290 ) = [: (the carrier' of C483) , { (the carrier of C483) } :] by L2161;
L2363: [ C489 , (the carrier of C483) ] in ( NonTerminals D290 ) by L2362 , ZFMISC_1:106;
reconsider D294 = [ C489 , (the carrier of C483) ] as (Symbol of D290) by L2363;
L2364: ( Sym (C489 , D287) ) ==> ( roots C490 ) by MSATERM:21;
L2365: D294 ==> ( roots D293 ) by L2364 , L2302;
thus L2366: thesis by L2365 , DTCONSTR:def 1;
end;
L2367: (for B470 being (Term of C483 , D287) holds S15[ B470 ]) from MSATERM:sch 1(L2333 , L2346);
L2368: ( NonTerminals ( DTConMSA C484 ) ) = [: (the carrier' of C483) , { (the carrier of C483) } :] by L2161;
L2369: ( Terminals ( DTConMSA C484 ) ) = ( Union ( coprod C484 ) ) by L2161;
defpred S16[ set ] means $1 in ( Union D289 );
L2370: (for B471 being (Symbol of D290) holds (B471 in ( Terminals D290 ) implies S16[ ( root-tree B471 ) ]))
proof
let C494 being (Symbol of D290);
assume L2371: C494 in ( Terminals D290 );
L2372: ( C494 `2 ) in ( dom C484 ) by L2371 , L2369 , CARD_3:22;
L2373: ( C494 `1 ) in ( C484 . ( C494 `2 ) ) by L2369 , L2371 , CARD_3:22;
L2374: C494 = [ ( C494 `1 ) , ( C494 `2 ) ] by L2369 , L2371 , CARD_3:22;
L2375: ( dom D289 ) = (the carrier of C483) by PARTFUN1:def 2;
L2376: ( root-tree C494 ) in ( (the Sorts of ( Free (C483 , C484) )) . ( C494 `2 ) ) by L2372 , L2373 , L2374 , MSAFREE3:4;
thus L2377: thesis by L2376 , L2372 , L2375 , CARD_5:2;
end;
L2378: (for B472 being (Symbol of D290) holds (for B473 being (FinSequence of ( TS D290 )) holds ((B472 ==> ( roots B473 ) & (for B474 being (DecoratedTree of (the carrier of D290)) holds (B474 in ( rng B473 ) implies S16[ B474 ]))) implies S16[ ( B472 -tree B473 ) ])))
proof
let C495 being (Symbol of D290);
let C496 being (FinSequence of ( TS D290 ));
assume that
L2379: C495 ==> ( roots C496 )
and
L2380: (for B475 being (DecoratedTree of (the carrier of D290)) holds (B475 in ( rng C496 ) implies S16[ B475 ]));
L2381: C495 in ( NonTerminals D290 ) by L2379;
consider C497 , C498 being set such that L2382: C497 in (the carrier' of C483) and L2383: C498 in { (the carrier of C483) } and L2384: C495 = [ C497 , C498 ] by L2381 , L2368 , ZFMISC_1:def 2;
reconsider D295 = C497 as (OperSymbol of C483) by L2382;
L2385: ( rng C496 ) c= ( Union D289 )
proof
let C499 being set;
assume L2386: C499 in ( rng C496 );
thus L2387: thesis by L2380 , L2386;
end;
L2388: ( rng C496 ) c= ( TS ( DTConMSA D287 ) )
proof
let C500 being set;
assume L2389: C500 in ( rng C496 );
L2390: C500 is (Element of ( C483 -Terms D287 )) by L2389 , L2385 , L2281;
L2391: ( C483 -Terms D287 ) = ( TS ( DTConMSA D287 ) ) by MSATERM:def 1;
thus L2392: thesis by L2391 , L2390;
end;
reconsider D296 = C496 as (FinSequence of ( TS ( DTConMSA D287 ) )) by L2388 , FINSEQ_1:def 4;
reconsider D297 = D296 as (FinSequence of ( C483 -Terms D287 )) by MSATERM:def 1;
L2393: C498 = (the carrier of C483) by L2383 , TARSKI:def 1;
L2394: ( Sym (D295 , D287) ) ==> ( roots D296 ) by L2393 , L2379 , L2384 , L2302;
reconsider D298 = D297 as (ArgumentSeq of ( Sym (D295 , D287) )) by L2394 , MSATERM:21;
set D299 = ( ( Sym (D295 , D287) ) -tree D298 );
L2395: D299 in ( D289 . ( the_result_sort_of D295 ) ) by L2331 , L2385 , MSAFREE3:19;
thus L2396: thesis by L2395 , L2332 , L2384 , L2393 , CARD_5:2;
end;
L2397: (for B476 being (DecoratedTree of (the carrier of D290)) holds (B476 in ( TS D290 ) implies S16[ B476 ])) from DTCONSTR:sch 7(L2370 , L2378);
thus L2398: ( Union D289 ) c= ( TS ( DTConMSA C484 ) )
proof
let C501 being set;
assume L2399: C501 in ( Union D289 );
consider C502 being set such that L2400: C502 in ( dom D289 ) and L2401: C501 in ( D289 . C502 ) by L2399 , CARD_5:2;
reconsider D300 = C502 as (SortSymbol of C483) by L2400;
L2402: C501 in ( D289 . D300 ) by L2401;
L2403: C501 is (Term of C483 , D287) by L2402 , L2331 , MSAFREE3:16;
thus L2404: thesis by L2403 , L2367 , L2399;
end;

let C503 being set;
assume L2405: C503 in ( TS D290 );
reconsider D301 = ( TS D290 ) as non  empty (Subset of ( FinTrees (the carrier of D290) )) by L2405;
L2406: C503 is (Element of D301) by L2405;
thus L2407: thesis by L2406 , L2397;
end;
definition
let C504 being non  void Signature;
let C505 being (ManySortedSet of (the carrier of C504));
mode term-transformation of C504 , C505
 -> (UnOp of ( Union (the Sorts of ( Free (C504 , C505) )) ))
means :L2408: (for B477 being (SortSymbol of C504) holds ( it .: ( (the Sorts of ( Free (C504 , C505) )) . B477 ) ) c= ( (the Sorts of ( Free (C504 , C505) )) . B477 ));
existence
proof
set D302 = ( id ( Union (the Sorts of ( Free (C504 , C505) )) ) );
L2409: ( dom D302 ) = ( Union (the Sorts of ( Free (C504 , C505) )) );
L2410: ( rng D302 ) = ( Union (the Sorts of ( Free (C504 , C505) )) );
reconsider D303 = D302 as (UnOp of ( Union (the Sorts of ( Free (C504 , C505) )) )) by L2410 , L2409 , FUNCT_2:2;
take D303;
thus L2411: thesis by L17;
end;
end;
theorem
L2413: (for B478 being non  void Signature holds (for B479 being non  empty (ManySortedSet of (the carrier of B478)) holds (for B480 being (UnOp of ( Union (the Sorts of ( Free (B478 , B479) )) )) holds (B480 is (term-transformation of B478 , B479) iff (for B481 being (SortSymbol of B478) holds (for B482 being set holds (B482 in ( (the Sorts of ( Free (B478 , B479) )) . B481 ) implies ( B480 . B482 ) in ( (the Sorts of ( Free (B478 , B479) )) . B481 ))))))))
proof
let C506 being non  void Signature;
let C507 being non  empty (ManySortedSet of (the carrier of C506));
L2414: ( dom (the Sorts of ( Free (C506 , C507) )) ) = (the carrier of C506) by PARTFUN1:def 2;
let C508 being (UnOp of ( Union (the Sorts of ( Free (C506 , C507) )) ));
L2415: ( dom C508 ) = ( Union (the Sorts of ( Free (C506 , C507) )) ) by FUNCT_2:52;
thus L2416:now
assume L2417: C508 is (term-transformation of C506 , C507);
let C509 being (SortSymbol of C506);
L2418: ( C508 .: ( (the Sorts of ( Free (C506 , C507) )) . C509 ) ) c= ( (the Sorts of ( Free (C506 , C507) )) . C509 ) by L2417 , L2408;
L2419: ( (the Sorts of ( Free (C506 , C507) )) . C509 ) in ( rng (the Sorts of ( Free (C506 , C507) )) ) by L2414 , FUNCT_1:def 3;
L2420: ( (the Sorts of ( Free (C506 , C507) )) . C509 ) c= ( Union (the Sorts of ( Free (C506 , C507) )) ) by L2419 , ZFMISC_1:74;
let C510 being set;
assume L2421: C510 in ( (the Sorts of ( Free (C506 , C507) )) . C509 );
L2422: ( C508 . C510 ) in ( C508 .: ( (the Sorts of ( Free (C506 , C507) )) . C509 ) ) by L2421 , L2415 , L2420 , FUNCT_1:def 6;
thus L2423: ( C508 . C510 ) in ( (the Sorts of ( Free (C506 , C507) )) . C509 ) by L2422 , L2418;
end;
assume L2424: (for B483 being (SortSymbol of C506) holds (for B484 being set holds (B484 in ( (the Sorts of ( Free (C506 , C507) )) . B483 ) implies ( C508 . B484 ) in ( (the Sorts of ( Free (C506 , C507) )) . B483 ))));
let C511 being (SortSymbol of C506);
let C512 being set;
assume L2425: C512 in ( C508 .: ( (the Sorts of ( Free (C506 , C507) )) . C511 ) );
L2426: (ex B485 being set st (B485 in ( dom C508 ) & B485 in ( (the Sorts of ( Free (C506 , C507) )) . C511 ) & C512 = ( C508 . B485 ))) by L2425 , FUNCT_1:def 6;
thus L2427: thesis by L2426 , L2424;
end;
theorem
L2428: (for B486 being non  void Signature holds (for B487 being non  empty (ManySortedSet of (the carrier of B486)) holds (for B488 being (term-transformation of B486 , B487) holds (for B489 being (SortSymbol of B486) holds (for B490 being (FinSequence of ( (the Sorts of ( Free (B486 , B487) )) . B489 )) holds (( B488 * B490 ) is (FinSequence of ( (the Sorts of ( Free (B486 , B487) )) . B489 )) & ( card ( B488 * B490 ) ) = ( len B490 )))))))
proof
let C513 being non  void Signature;
let C514 being non  empty (ManySortedSet of (the carrier of C513));
set D304 = ( Free (C513 , C514) );
let C515 being (term-transformation of C513 , C514);
let C516 being (SortSymbol of C513);
let C517 being (FinSequence of ( (the Sorts of D304) . C516 ));
L2429: (( Union (the Sorts of D304) ) = ( {} ) or ( Union (the Sorts of D304) ) <> ( {} ));
L2430: ( dom (the Sorts of D304) ) = (the carrier of C513) by PARTFUN1:def 2;
L2431: ( dom C515 ) = ( Union (the Sorts of D304) ) by L2429 , FUNCT_2:def 1;
L2432: ( (the Sorts of D304) . C516 ) in ( rng (the Sorts of D304) ) by L2430 , FUNCT_1:def 3;
L2433: ( (the Sorts of D304) . C516 ) c= ( Union (the Sorts of D304) ) by L2432 , ZFMISC_1:74;
L2434: ( rng C517 ) c= ( dom C515 ) by L2433 , L2431 , XBOOLE_1:1;
L2435: ( dom ( C515 * C517 ) ) = ( dom C517 ) by L2434 , RELAT_1:27;
L2436: ( dom C517 ) = ( Seg ( len C517 ) ) by FINSEQ_1:def 3;
L2437: ( C515 * C517 ) is FinSequence by L2436 , L2435 , FINSEQ_1:def 2;
L2438: ( rng ( C515 * C517 ) ) c= ( (the Sorts of D304) . C516 )
proof
let C518 being set;
assume L2439: C518 in ( rng ( C515 * C517 ) );
consider C519 being set such that L2440: C519 in ( dom ( C515 * C517 ) ) and L2441: C518 = ( ( C515 * C517 ) . C519 ) by L2439 , FUNCT_1:def 3;
L2442: ( C517 . C519 ) in ( rng C517 ) by L2435 , L2440 , FUNCT_1:def 3;
L2443: ( C515 . ( C517 . C519 ) ) in ( (the Sorts of D304) . C516 ) by L2442 , L2413;
thus L2444: thesis by L2443 , L2440 , L2441 , FUNCT_1:12;
end;
thus L2445: ( C515 * C517 ) is (FinSequence of ( (the Sorts of ( Free (C513 , C514) )) . C516 )) by L2438 , L2437 , FINSEQ_1:def 4;
reconsider D305 = ( C515 * C517 ) as (FinSequence of ( (the Sorts of D304) . C516 )) by L2437 , L2438 , FINSEQ_1:def 4;
thus L2446: ( card ( C515 * C517 ) ) = ( len D305 )
.= ( len C517 ) by L2435 , FINSEQ_3:29;
end;
definition
let C520 being non  void Signature;
let C521 being (ManySortedSet of (the carrier of C520));
let C522 being (term-transformation of C520 , C521);
attr C522 is  substitution
means
(for B491 being (OperSymbol of C520) holds (for B492 , B493 being (FinSequence of ( Free (C520 , C521) )) holds ((( [ B491 , (the carrier of C520) ] -tree B492 ) in ( Union (the Sorts of ( Free (C520 , C521) )) ) & B493 = ( C522 * B492 )) implies ( C522 . ( [ B491 , (the carrier of C520) ] -tree B492 ) ) = ( [ B491 , (the carrier of C520) ] -tree B493 ))));
end;
scheme StructDef { F5() ->  initialized ConstructorSignature , F6 , F7(set) -> (expression of F5()) , F8 , F9(set , set) -> (expression of F5()) } : (ex B494 being (term-transformation of F5() , ( MSVars F5() )) st ((for B495 being variable holds ( B494 . ( B495 -term F5() ) ) = F6(B495)) & (for B496 being  constructor (OperSymbol of F5()) holds (for B497 , B498 being (FinSequence of ( QuasiTerms F5() )) holds ((( len B497 ) = ( len ( the_arity_of B496 ) ) & B498 = ( B494 * B497 )) implies ( B494 . ( B496 -trm B497 ) ) = F8(B496 , B498)))) & (for B499 being (expression of F5() , ( an_Adj F5() )) holds ( B494 . ( ( non_op F5() ) term B499 ) ) = F7(( B494 . B499 ))) & (for B500 being (expression of F5() , ( an_Adj F5() )) holds (for B501 being (expression of F5() , ( a_Type F5() )) holds ( B494 . ( ( ast F5() ) term (B500 , B501) ) ) = F9(( B494 . B500 ) , ( B494 . B501 ))))))
provided
L2448: (for B502 being variable holds F6(B502) is (quasi-term of F5()))
and
L2449: (for B503 being  constructor (OperSymbol of F5()) holds (for B504 being (FinSequence of ( QuasiTerms F5() )) holds (( len B504 ) = ( len ( the_arity_of B503 ) ) implies F8(B503 , B504) is (expression of F5() , ( the_result_sort_of B503 )))))
and
L2450: (for B505 being (expression of F5() , ( an_Adj F5() )) holds F7(B505) is (expression of F5() , ( an_Adj F5() )))
and
L2451: (for B506 being (expression of F5() , ( an_Adj F5() )) holds (for B507 being (expression of F5() , ( a_Type F5() )) holds F9(B506 , B507) is (expression of F5() , ( a_Type F5() ))))
proof
set D306 = ( MSVars F5() );
set D307 = ( D306 \/ ( (the carrier of F5()) --> { ( 0 ) } ) );
set D308 = ( Free (F5() , D306) );
set D309 = (the Sorts of D308);
set D310 = ( Union D309 );
set D311 = ( DTConMSA D306 );
deffunc H7((Symbol of D311)) = F6(( $1 `1 ));
deffunc H8((Symbol of D311) , FinSequence , Function) = ( IFEQ (( $1 `1 ) , ( * ) , F9(( $3 . 1 ) , ( $3 . 2 )) , ( IFEQ (( $1 `1 ) , ( non_op ) , F7(( $3 . 1 )) , F8(( $1 `1 ) , $3)) )) );
consider C523 being (Function of ( TS D311 ) , D310) such that L2452: (for B508 being (Symbol of D311) holds (B508 in ( Terminals D311 ) implies ( C523 . ( root-tree B508 ) ) = H7(B508))) and L2453: (for B509 being (Symbol of D311) holds (for B510 being (FinSequence of ( TS D311 )) holds (B509 ==> ( roots B510 ) implies ( C523 . ( B509 -tree B510 ) ) = H8(B509 , ( roots B510 ) , ( C523 * B510 ))))) from DTCONSTR:sch 8;
L2454: D310 = ( TS D311 ) by L2330;
reconsider D312 = C523 as (Function of D310 , D310) by L2454;
L2455: D312 is (term-transformation of F5() , D306)
proof
let C524 being (SortSymbol of F5());
let C525 being set;
assume L2456: C525 in ( D312 .: ( (the Sorts of D308) . C524 ) );
consider C526 being (Element of D310) such that L2457: C526 in ( (the Sorts of D308) . C524 ) and L2458: C525 = ( D312 . C526 ) by L2456 , FUNCT_2:65;
defpred S17[ (expression of F5()) ] means (for B511 being (SortSymbol of F5()) holds ($1 in ( (the Sorts of D308) . B511 ) implies ( D312 . $1 ) in ( (the Sorts of D308) . B511 )));
L2459: (for B512 being variable holds S17[ ( B512 -term F5() ) ])
proof
let C527 being variable;
set D313 = ( C527 -term F5() );
let C528 being (SortSymbol of F5());
assume L2460: D313 in ( (the Sorts of D308) . C528 );
L2461: [ C527 , ( a_Term F5() ) ] in ( Terminals D311 ) by L2252;
reconsider D314 = [ C527 , ( a_Term F5() ) ] as (Symbol of D311) by L2461;
L2462: ( D312 . D313 ) = H7(D314) by L2452 , L2461
.= F6(C527) by MCART_1:7;
L2463: ( D312 . D313 ) is (quasi-term of F5()) by L2462 , L2448;
L2464: D313 is (expression of F5() , C528) by L2460 , L885;
L2465: C528 = ( a_Term F5() ) by L2464 , L1022;
thus L2466: thesis by L2465 , L2463 , L885;
end;
L2467: (for B513 being  constructor (OperSymbol of F5()) holds (for B514 being (FinSequence of ( QuasiTerms F5() )) holds ((( len B514 ) = ( len ( the_arity_of B513 ) ) & (for B515 being (quasi-term of F5()) holds (B515 in ( rng B514 ) implies S17[ B515 ]))) implies S17[ ( B513 -trm B514 ) ])))
proof
let C529 being  constructor (OperSymbol of F5());
let C530 being (FinSequence of ( QuasiTerms F5() ));
assume that
L2468: ( len C530 ) = ( len ( the_arity_of C529 ) )
and
L2469: (for B516 being (quasi-term of F5()) holds (B516 in ( rng C530 ) implies S17[ B516 ]));
set D315 = ( C529 -trm C530 );
set D316 = [ C529 , (the carrier of F5()) ];
let C531 being (SortSymbol of F5());
assume that
L2470: D315 in ( (the Sorts of D308) . C531 );
L2471: D316 in ( NonTerminals D311 ) by L2269;
reconsider D317 = D316 as (Symbol of D311) by L2471;
reconsider D318 = C530 as (FinSequence of ( TS D311 )) by L2330;
L2472: D315 = ( D317 -tree D318 ) by L2468 , L1118;
reconsider D319 = D315 as (Term of F5() , D307) by MSAFREE3:8;
L2473: (the Sorts of D308) = ( F5() -Terms (D306 , D307) ) by MSAFREE3:24;
L2474: (the Sorts of D308) c= (the Sorts of ( FreeMSA D307 )) by L2473 , PBOOLE:def 18;
L2475: ( (the Sorts of D308) . C531 ) c= ( (the Sorts of ( FreeMSA D307 )) . C531 ) by L2474 , PBOOLE:def 2;
L2476: D319 in ( ( FreeSort D307 ) . C531 ) by L2475 , L2470;
L2477: D319 in ( FreeSort (D307 , C531) ) by L2476 , MSAFREE:def 11;
L2478: ( the_sort_of D319 ) = C531 by L2477 , MSATERM:def 5;
L2479: ( D317 `1 ) = C529 by MCART_1:7;
L2480: C529 <> ( * ) by L670;
L2481: C529 <> ( non_op ) by L670;
L2482: ( rng C530 ) c= ( QuasiTerms F5() ) by FINSEQ_1:def 4;
L2483: ( dom D312 ) = D310 by FUNCT_2:def 1;
L2484: ( rng C530 ) c= ( dom D312 ) by L2483;
L2485: ( rng ( D312 * C530 ) ) c= ( QuasiTerms F5() )
proof
let C532 being set;
assume L2486: C532 in ( rng ( D312 * C530 ) );
consider C533 being set such that L2487: C533 in ( dom ( D312 * C530 ) ) and L2488: C532 = ( ( D312 * C530 ) . C533 ) by L2486 , FUNCT_1:def 3;
L2489: C533 in ( dom C530 ) by L2484 , L2487 , RELAT_1:27;
L2490: ( C530 . C533 ) in ( rng C530 ) by L2489 , FUNCT_1:def 3;
reconsider D320 = ( C530 . C533 ) as (quasi-term of F5()) by L2490 , L2482 , L890;
L2491: D320 in ( (the Sorts of D308) . ( a_Term F5() ) ) by L890;
L2492: ( D312 . D320 ) in ( (the Sorts of D308) . ( a_Term F5() ) ) by L2491 , L2469 , L2490;
thus L2493: thesis by L2492 , L2487 , L2488 , FUNCT_1:12;
end;
reconsider D321 = ( D312 * C530 ) as (FinSequence of ( QuasiTerms F5() )) by L2485 , FINSEQ_1:def 4;
L2494: ( rng C530 ) c= ( F5() -Terms D307 )
proof
let C534 being set;
assume L2495: C534 in ( rng C530 );
L2496: C534 is (Element of ( F5() -Terms D307 )) by L2495 , MSAFREE3:8;
thus L2497: thesis by L2496;
end;
reconsider D322 = C530 as (FinSequence of ( F5() -Terms D307 )) by L2494 , FINSEQ_1:def 4;
L2498: ( len D321 ) = ( len C530 ) by L2484 , FINSEQ_2:29;
L2499: D315 is (Term of F5() , D307) by MSAFREE3:8;
L2500: D322 is (ArgumentSeq of ( Sym (C529 , D307) )) by L2499 , L2472 , MSATERM:1;
L2501: ( the_result_sort_of C529 ) = C531 by L2500 , L2472 , L2478 , MSATERM:20;
L2502: ( Sym (C529 , D307) ) ==> ( roots D322 ) by L2500 , MSATERM:21;
L2503: D317 ==> ( roots D318 ) by L2502 , L2302;
L2504: ( D312 . D315 ) = H8(D317 , ( roots D318 ) , ( D312 * D318 )) by L2503 , L2453 , L2472
.= ( IFEQ (C529 , ( non_op ) , F7(( ( D312 * D318 ) . 1 )) , F8(C529 , ( D312 * D318 ))) ) by L2479 , L2480 , FUNCOP_1:def 8
.= F8(C529 , ( D312 * D318 )) by L2481 , FUNCOP_1:def 8;
L2505: ( D312 . D315 ) is (expression of F5() , ( the_result_sort_of C529 )) by L2504 , L2449 , L2468 , L2498;
thus L2506: thesis by L2505 , L2501 , L885;
end;
L2507: (for B517 being (expression of F5() , ( an_Adj F5() )) holds (S17[ B517 ] implies S17[ ( ( non_op F5() ) term B517 ) ]))
proof
let C535 being (expression of F5() , ( an_Adj F5() ));
assume that
L2508: S17[ C535 ];
L2509: C535 in ( D309 . ( an_Adj F5() ) ) by L885;
L2510: ( D312 . C535 ) in ( D309 . ( an_Adj F5() ) ) by L2509 , L2508;
reconsider D323 = ( D312 . C535 ) as (expression of F5() , ( an_Adj F5() )) by L2510 , L885;
let C536 being (SortSymbol of F5());
assume L2511: ( ( non_op F5() ) term C535 ) in ( D309 . C536 );
L2512: ( ( non_op F5() ) term C535 ) is (expression of F5() , ( an_Adj F5() )) by L937;
L2513: ( ( non_op F5() ) term C535 ) is (expression of F5() , C536) by L2511 , L885;
L2514: C536 = ( an_Adj F5() ) by L2513 , L2512 , L1022;
set D324 = ( D309 . ( an_Adj F5() ) );
L2515: ( rng <* C535 *> ) = { C535 } by FINSEQ_1:38;
L2516: ( rng <* C535 *> ) c= D324 by L2515 , L2509 , ZFMISC_1:31;
reconsider D325 = <* C535 *> as (FinSequence of D324) by L2516 , FINSEQ_1:def 4;
set D326 = ( non_op F5() );
set D327 = ( ( non_op F5() ) term C535 );
set D328 = [ D326 , (the carrier of F5()) ];
L2517: D328 in ( NonTerminals D311 ) by L2269;
reconsider D329 = D328 as (Symbol of D311) by L2517;
reconsider D330 = D325 as (FinSequence of ( TS D311 )) by L2330;
L2518: D327 = ( D329 -tree D330 ) by L937;
L2519: ( D329 `1 ) = D326 by MCART_1:7;
L2520: ( dom D312 ) = D310 by FUNCT_2:def 1;
L2521: ( D312 * D325 ) = <* D323 *> by L2520 , FINSEQ_2:34;
L2522: ( rng D325 ) c= ( F5() -Terms D307 )
proof
let C537 being set;
assume L2523: C537 in ( rng D325 );
L2524: C537 is (expression of F5() , ( an_Adj F5() )) by L2523 , L890;
L2525: C537 is (Element of ( F5() -Terms D307 )) by L2524 , MSAFREE3:8;
thus L2526: thesis by L2525;
end;
reconsider D331 = D325 as (FinSequence of ( F5() -Terms D307 )) by L2522 , FINSEQ_1:def 4;
L2527: D327 is (Term of F5() , D307) by MSAFREE3:8;
L2528: D331 is (ArgumentSeq of ( Sym (D326 , D307) )) by L2527 , L2518 , MSATERM:1;
L2529: ( Sym (D326 , D307) ) ==> ( roots D331 ) by L2528 , MSATERM:21;
L2530: D329 ==> ( roots D330 ) by L2529 , L2302;
L2531: ( D312 . D327 ) = H8(D329 , ( roots D330 ) , ( D312 * D330 )) by L2530 , L2453 , L2518
.= ( IFEQ (D326 , ( non_op ) , F7(( ( D312 * D330 ) . 1 )) , F8(D326 , ( D312 * D330 ))) ) by L2519 , FUNCOP_1:def 8
.= F7(( ( D312 * D330 ) . 1 )) by FUNCOP_1:def 8
.= F7(D323) by L2521 , FINSEQ_1:40;
L2532: ( D312 . D327 ) is (expression of F5() , ( an_Adj F5() )) by L2531 , L2450;
thus L2533: thesis by L2532 , L2514 , L885;
end;
L2534: (for B518 being (expression of F5() , ( an_Adj F5() )) holds (S17[ B518 ] implies (for B519 being (expression of F5() , ( a_Type F5() )) holds (S17[ B519 ] implies S17[ ( ( ast F5() ) term (B518 , B519) ) ]))))
proof
let C538 being (expression of F5() , ( an_Adj F5() ));
assume that
L2535: S17[ C538 ];
let C539 being (expression of F5() , ( a_Type F5() ));
assume that
L2536: S17[ C539 ];
L2537: C538 in ( D309 . ( an_Adj F5() ) ) by L885;
L2538: C539 in ( D309 . ( a_Type F5() ) ) by L885;
L2539: ( D312 . C538 ) in ( D309 . ( an_Adj F5() ) ) by L2535 , L2537;
L2540: ( D312 . C539 ) in ( D309 . ( a_Type F5() ) ) by L2536 , L2538;
reconsider D332 = ( D312 . C538 ) as (expression of F5() , ( an_Adj F5() )) by L2539 , L885;
reconsider D333 = ( D312 . C539 ) as (expression of F5() , ( a_Type F5() )) by L2540 , L885;
let C540 being (SortSymbol of F5());
assume L2541: ( ( ast F5() ) term (C538 , C539) ) in ( D309 . C540 );
L2542: ( ( ast F5() ) term (C538 , C539) ) is (expression of F5() , ( a_Type F5() )) by L996;
L2543: ( ( ast F5() ) term (C538 , C539) ) is (expression of F5() , C540) by L2541 , L885;
L2544: C540 = ( a_Type F5() ) by L2543 , L2542 , L1022;
reconsider D334 = <* C538 , C539 *> as (FinSequence of D310);
set D335 = ( ast F5() );
set D336 = ( ( ast F5() ) term (C538 , C539) );
set D337 = [ D335 , (the carrier of F5()) ];
L2545: D337 in ( NonTerminals D311 ) by L2269;
reconsider D338 = D337 as (Symbol of D311) by L2545;
reconsider D339 = D334 as (FinSequence of ( TS D311 )) by L2330;
L2546: D336 = ( D338 -tree D339 ) by L996;
L2547: ( D338 `1 ) = D335 by MCART_1:7;
L2548: ( D312 * D334 ) = <* D332 , D333 *> by FINSEQ_2:36;
L2549: ( rng D334 ) c= ( F5() -Terms D307 )
proof
let C541 being set;
assume L2550: C541 in ( rng D334 );
L2551: C541 is (Element of ( F5() -Terms D307 )) by L2550 , MSAFREE3:8;
thus L2552: thesis by L2551;
end;
reconsider D340 = D334 as (FinSequence of ( F5() -Terms D307 )) by L2549 , FINSEQ_1:def 4;
L2553: D336 is (Term of F5() , D307) by MSAFREE3:8;
L2554: D340 is (ArgumentSeq of ( Sym (D335 , D307) )) by L2553 , L2546 , MSATERM:1;
L2555: ( Sym (D335 , D307) ) ==> ( roots D340 ) by L2554 , MSATERM:21;
L2556: D338 ==> ( roots D339 ) by L2555 , L2302;
L2557: ( D312 . D336 ) = H8(D338 , ( roots D339 ) , ( D312 * D339 )) by L2556 , L2453 , L2546
.= F9(( ( D312 * D339 ) . 1 ) , ( ( D312 * D339 ) . 2 )) by L2547 , FUNCOP_1:def 8
.= F9(D332 , ( ( D312 * D339 ) . 2 )) by L2548 , FINSEQ_1:44
.= F9(D332 , D333) by L2548 , FINSEQ_1:44;
L2558: ( D312 . D336 ) is (expression of F5() , ( a_Type F5() )) by L2557 , L2451;
thus L2559: thesis by L2558 , L2544 , L885;
end;
L2560: S17[ C526 ] from StructInd(L2459 , L2467 , L2507 , L2534);
thus L2561: thesis by L2560 , L2457 , L2458;
end;
reconsider D341 = D312 as (term-transformation of F5() , ( MSVars F5() )) by L2455;
take D341;
thus L2562:now
let C542 being variable;
L2563: C542 in ( Vars );
L2564: C542 in ( D306 . ( a_Term F5() ) ) by L2563 , L840;
reconsider D342 = C542 as (Element of ( D306 . ( a_Term F5() ) )) by L840;
reconsider D343 = [ D342 , ( a_Term F5() ) ] as (Symbol of D311) by L2564 , MSAFREE3:2;
L2565: D343 in ( Terminals D311 ) by L2564 , MSAFREE:7;
thus L2566: ( D341 . ( C542 -term F5() ) ) = F6(( D343 `1 )) by L2565 , L2452
.= F6(C542) by MCART_1:7;
end;
thus L2567:now
let C543 being  constructor (OperSymbol of F5());
let C544 , C545 being (FinSequence of ( QuasiTerms F5() ));
assume that
L2568: ( len C544 ) = ( len ( the_arity_of C543 ) )
and
L2569: C545 = ( D341 * C544 );
set D344 = ( C543 -trm C544 );
set D345 = [ C543 , (the carrier of F5()) ];
L2570: D345 in ( NonTerminals D311 ) by L2269;
reconsider D346 = D345 as (Symbol of D311) by L2570;
reconsider D347 = C544 as (FinSequence of ( TS D311 )) by L2330;
L2571: D344 = ( D346 -tree D347 ) by L2568 , L1118;
L2572: ( D346 `1 ) = C543 by MCART_1:7;
L2573: C543 <> ( * ) by L670;
L2574: C543 <> ( non_op ) by L670;
L2575: ( rng C544 ) c= ( F5() -Terms D307 )
proof
let C546 being set;
assume L2576: C546 in ( rng C544 );
L2577: C546 is (Element of ( F5() -Terms D307 )) by L2576 , MSAFREE3:8;
thus L2578: thesis by L2577;
end;
reconsider D348 = C544 as (FinSequence of ( F5() -Terms D307 )) by L2575 , FINSEQ_1:def 4;
L2579: D344 is (Term of F5() , D307) by MSAFREE3:8;
L2580: D348 is (ArgumentSeq of ( Sym (C543 , D307) )) by L2579 , L2571 , MSATERM:1;
L2581: ( Sym (C543 , D307) ) ==> ( roots D348 ) by L2580 , MSATERM:21;
L2582: D346 ==> ( roots D347 ) by L2581 , L2302;
L2583: ( D341 . D344 ) = H8(D346 , ( roots D347 ) , ( D341 * D347 )) by L2582 , L2453 , L2571
.= ( IFEQ (C543 , ( non_op ) , F7(( ( D341 * D347 ) . 1 )) , F8(C543 , ( D341 * D347 ))) ) by L2572 , L2573 , FUNCOP_1:def 8
.= F8(C543 , ( D341 * D347 )) by L2574 , FUNCOP_1:def 8;
thus L2584: ( D341 . ( C543 -trm C544 ) ) = F8(C543 , C545) by L2583 , L2569;
end;
thus L2585:now
let C547 being (expression of F5() , ( an_Adj F5() ));
L2586: C547 in ( D309 . ( an_Adj F5() ) ) by L885;
L2587: ( D341 . C547 ) in ( D309 . ( an_Adj F5() ) ) by L2586 , L2413;
reconsider D349 = ( D341 . C547 ) as (expression of F5() , ( an_Adj F5() )) by L2587 , L885;
set D350 = ( D309 . ( an_Adj F5() ) );
L2588: ( rng <* C547 *> ) = { C547 } by FINSEQ_1:38;
L2589: ( rng <* C547 *> ) c= D350 by L2588 , L2586 , ZFMISC_1:31;
reconsider D351 = <* C547 *> as (FinSequence of D350) by L2589 , FINSEQ_1:def 4;
set D352 = ( non_op F5() );
set D353 = ( ( non_op F5() ) term C547 );
set D354 = [ D352 , (the carrier of F5()) ];
L2590: D354 in ( NonTerminals D311 ) by L2269;
reconsider D355 = D354 as (Symbol of D311) by L2590;
reconsider D356 = D351 as (FinSequence of ( TS D311 )) by L2330;
L2591: D353 = ( D355 -tree D356 ) by L937;
L2592: ( D355 `1 ) = D352 by MCART_1:7;
L2593: ( dom D341 ) = D310 by FUNCT_2:def 1;
L2594: ( D341 * D351 ) = <* D349 *> by L2593 , FINSEQ_2:34;
L2595: ( rng D351 ) c= ( F5() -Terms D307 )
proof
let C548 being set;
assume L2596: C548 in ( rng D351 );
L2597: C548 is (expression of F5() , ( an_Adj F5() )) by L2596 , L890;
L2598: C548 is (Element of ( F5() -Terms D307 )) by L2597 , MSAFREE3:8;
thus L2599: thesis by L2598;
end;
reconsider D357 = D351 as (FinSequence of ( F5() -Terms D307 )) by L2595 , FINSEQ_1:def 4;
L2600: D353 is (Term of F5() , D307) by MSAFREE3:8;
L2601: D357 is (ArgumentSeq of ( Sym (D352 , D307) )) by L2600 , L2591 , MSATERM:1;
L2602: ( Sym (D352 , D307) ) ==> ( roots D357 ) by L2601 , MSATERM:21;
L2603: D355 ==> ( roots D356 ) by L2602 , L2302;
L2604: ( D341 . D353 ) = H8(D355 , ( roots D356 ) , ( D341 * D356 )) by L2603 , L2453 , L2591
.= ( IFEQ (D352 , ( non_op ) , F7(( ( D341 * D356 ) . 1 )) , F8(D352 , ( D341 * D356 ))) ) by L2592 , FUNCOP_1:def 8
.= F7(( ( D341 * D356 ) . 1 )) by FUNCOP_1:def 8;
thus L2605: ( D341 . ( ( non_op F5() ) term C547 ) ) = F7(( D341 . C547 )) by L2604 , L2594 , FINSEQ_1:40;
end;
let C549 being (expression of F5() , ( an_Adj F5() ));
let C550 being (expression of F5() , ( a_Type F5() ));
L2606: C549 in ( D309 . ( an_Adj F5() ) ) by L885;
L2607: C550 in ( D309 . ( a_Type F5() ) ) by L885;
L2608: ( D341 . C549 ) in ( D309 . ( an_Adj F5() ) ) by L2606 , L2413;
L2609: ( D341 . C550 ) in ( D309 . ( a_Type F5() ) ) by L2607 , L2413;
reconsider D358 = ( D341 . C549 ) as (expression of F5() , ( an_Adj F5() )) by L2608 , L885;
reconsider D359 = ( D341 . C550 ) as (expression of F5() , ( a_Type F5() )) by L2609 , L885;
reconsider D360 = <* C549 , C550 *> as (FinSequence of D310);
set D361 = ( ast F5() );
set D362 = ( ( ast F5() ) term (C549 , C550) );
set D363 = [ D361 , (the carrier of F5()) ];
L2610: D363 in ( NonTerminals D311 ) by L2269;
reconsider D364 = D363 as (Symbol of D311) by L2610;
reconsider D365 = D360 as (FinSequence of ( TS D311 )) by L2330;
L2611: D362 = ( D364 -tree D365 ) by L996;
L2612: ( D364 `1 ) = D361 by MCART_1:7;
L2613: ( D341 * D360 ) = <* D358 , D359 *> by FINSEQ_2:36;
L2614: ( rng D360 ) c= ( F5() -Terms D307 )
proof
let C551 being set;
assume L2615: C551 in ( rng D360 );
L2616: C551 is (Element of ( F5() -Terms D307 )) by L2615 , MSAFREE3:8;
thus L2617: thesis by L2616;
end;
reconsider D366 = D360 as (FinSequence of ( F5() -Terms D307 )) by L2614 , FINSEQ_1:def 4;
L2618: D362 is (Term of F5() , D307) by MSAFREE3:8;
L2619: D366 is (ArgumentSeq of ( Sym (D361 , D307) )) by L2618 , L2611 , MSATERM:1;
L2620: ( Sym (D361 , D307) ) ==> ( roots D366 ) by L2619 , MSATERM:21;
L2621: D364 ==> ( roots D365 ) by L2620 , L2302;
L2622: ( D341 . D362 ) = H8(D364 , ( roots D365 ) , ( D341 * D365 )) by L2621 , L2453 , L2611
.= F9(( ( D341 * D365 ) . 1 ) , ( ( D341 * D365 ) . 2 )) by L2612 , FUNCOP_1:def 8
.= F9(D358 , ( ( D341 * D365 ) . 2 )) by L2613 , FINSEQ_1:44;
thus L2623: thesis by L2622 , L2613 , FINSEQ_1:44;
end;
begin
definition
let C552 being set;
let C553 , C554 being set;
let C555 , C556 being (Element of C552);
redefine func IFIN (C553 , C554 , C555 , C556) -> (Element of C552);

coherence by MATRIX_7:def 1;
end;
definition
let C557 being  initialized ConstructorSignature;
mode valuation of C557
 is (PartFunc of ( Vars ) , ( QuasiTerms C557 ));
end;
definition
let C558 being  initialized ConstructorSignature;
let C559 being (valuation of C558);
attr C559 is  irrelevant
means
:L2626: (for B520 being variable holds (B520 in ( dom C559 ) implies (ex B521 being variable st ( C559 . B520 ) = ( B521 -term C558 ))));
end;
notation
let C560 being  initialized ConstructorSignature;
let C561 being (valuation of C560);
antonym C561 is  relevant for C561 is  irrelevant;
end;
registration
let C562 being  initialized ConstructorSignature;
cluster  empty ->  irrelevant for (valuation of C562);
coherence
proof
let C563 being (valuation of C562);
assume L2629: C563 is  empty;
reconsider D367 = C563 as  empty (valuation of C562) by L2629;
let C564 being variable;
L2630: ( dom D367 ) = ( {} );
thus L2631: thesis by L2630;
end;
end;
registration
let C565 being  initialized ConstructorSignature;
cluster  empty for (valuation of C565);
existence
proof
take ( {} (( Vars ) , ( QuasiTerms C565 )) );
thus L2633: thesis;
end;
end;
definition
let C566 being  initialized ConstructorSignature;
let C567 being (Subset of ( Vars ));
func C566 idval C567 -> (valuation of C566) equals 
{ [ B522 , ( B522 -term C566 ) ] where B522 is variable : B522 in C567 };
coherence
proof
set D368 = { [ B523 , ( B523 -term C566 ) ] where B523 is variable : B523 in C567 };
defpred S18[ variable , set ] means $2 = ( $1 -term C566 );
L2635:
now
let C568 being variable;
reconsider D369 = ( C568 -term C566 ) as (Element of ( QuasiTerms C566 )) by L885;
take D370 = D369;
thus L2636: S18[ C568 , D370 ];
end;
consider C569 being (Function of ( Vars ) , ( QuasiTerms C566 )) such that L2637: (for B524 being variable holds S18[ B524 , ( C569 . B524 ) ]) from FUNCT_2:sch 3(L2635);
L2638: D368 c= C569
proof
let C570 being set;
assume L2639: C570 in D368;
consider C571 being variable such that L2640: C570 = [ C571 , ( C571 -term C566 ) ] and L2641: C571 in C567 by L2639;
L2642: ( C569 . C571 ) = ( C571 -term C566 ) by L2637;
L2643: ( dom C569 ) = ( Vars ) by FUNCT_2:def 1;
thus L2644: thesis by L2643 , L2640 , L2642 , FUNCT_1:1;
end;
thus L2645: thesis by L2638 , RELSET_1:1;
end;
end;
theorem
L2647: (for R8 being  initialized ConstructorSignature holds (for B525 being (Subset of ( Vars )) holds (( dom ( R8 idval B525 ) ) = B525 & (for B526 being variable holds (B526 in B525 implies ( ( R8 idval B525 ) . B526 ) = ( B526 -term R8 ))))))
proof
let R8 being  initialized ConstructorSignature;
let C572 being (Subset of ( Vars ));
set D371 = ( R8 idval C572 );
thus L2648: ( dom D371 ) c= C572
proof
let C573 being set;
assume L2649: C573 in ( dom D371 );
L2650: [ C573 , ( D371 . C573 ) ] in D371 by L2649 , FUNCT_1:def 2;
L2651: (ex B527 being variable st ([ C573 , ( D371 . C573 ) ] = [ B527 , ( B527 -term R8 ) ] & B527 in C572)) by L2650;
thus L2652: thesis by L2651 , XTUPLE_0:1;
end;

thus L2653:now
let C574 being set;
assume L2654: C574 in C572;
reconsider D372 = C574 as variable by L2654;
L2655: [ D372 , ( D372 -term R8 ) ] in D371 by L2654;
thus L2656: C574 in ( dom D371 ) by L2655 , FUNCT_1:1;
end;
let C575 being variable;
assume L2657: C575 in C572;
L2658: [ C575 , ( C575 -term R8 ) ] in ( R8 idval C572 ) by L2657;
thus L2659: thesis by L2658 , FUNCT_1:1;
end;
registration
let C576 being  initialized ConstructorSignature;
let C577 being (Subset of ( Vars ));
cluster ( C576 idval C577 ) ->  irrelevant  one-to-one;
coherence
proof
set D373 = ( C576 idval C577 );
L2660: ( dom D373 ) = C577 by L2647;
thus L2661:now
let C578 being variable;
assume L2662: C578 in ( dom D373 );
take D374 = C578;
thus L2663: ( D373 . C578 ) = ( D374 -term C576 ) by L2660 , L2662 , L2647;
end;
let C579 , C580 being set;
assume that
L2664: C579 in ( dom D373 )
and
L2665: C580 in ( dom D373 );
reconsider D375 = C579 , D376 = C580 as variable by L2664 , L2665;
L2666: ( D373 . D375 ) = ( D375 -term C576 ) by L2660 , L2664 , L2647;
L2667: ( D373 . D376 ) = ( D376 -term C576 ) by L2660 , L2665 , L2647;
thus L2668: thesis by L2667 , L2666 , L1047;
end;
end;
registration
let C581 being  initialized ConstructorSignature;
let C582 being  empty (Subset of ( Vars ));
cluster ( C581 idval C582 ) ->  empty;
coherence
proof
L2670: ( dom ( C581 idval C582 ) ) = C582 by L2647;
thus L2671: thesis by L2670;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let C583 being (valuation of R8);
func C583 # -> (term-transformation of R8 , ( MSVars R8 )) means 
:L2673: ((for B528 being variable holds ((B528 in ( dom C583 ) implies ( it . ( B528 -term R8 ) ) = ( C583 . B528 )) & ((not B528 in ( dom C583 )) implies ( it . ( B528 -term R8 ) ) = ( B528 -term R8 )))) & (for B529 being  constructor (OperSymbol of R8) holds (for B530 , B531 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B530 ) = ( len ( the_arity_of B529 ) ) & B531 = ( it * B530 )) implies ( it . ( B529 -trm B530 ) ) = ( B529 -trm B531 )))) & (for B532 being (expression of R8 , ( an_Adj R8 )) holds ( it . ( ( non_op R8 ) term B532 ) ) = ( ( non_op R8 ) term ( it . B532 ) )) & (for B533 being (expression of R8 , ( an_Adj R8 )) holds (for B534 being (expression of R8 , ( a_Type R8 )) holds ( it . ( ( ast R8 ) term (B533 , B534) ) ) = ( ( ast R8 ) term (( it . B533 ) , ( it . B534 )) ))));
existence
proof
deffunc H9(variable) = ( IFIN ($1 , ( dom C583 ) , ((( C583 /. $1 ) qua (Element of (( QuasiTerms R8 ) qua non  empty (Subset of ( Free (R8 , ( MSVars R8 )) ))))) qua (expression of R8)) , ( $1 -term R8 )) );
deffunc H10( constructor (OperSymbol of R8) , (FinSequence of ( QuasiTerms R8 ))) = ( $1 -trm $2 );
deffunc H11((expression of R8)) = ( ( non_op R8 ) term $1 );
deffunc H12((expression of R8) , (expression of R8)) = ( ( ast R8 ) term ($1 , $2) );
L2674: (for B535 being variable holds H9(B535) is (quasi-term of R8))
proof
let C584 being variable;
L2675: ( C583 /. C584 ) is (quasi-term of R8) by L890;
thus L2676: thesis by L2675 , MATRIX_7:def 1;
end;
L2677: (for B536 being  constructor (OperSymbol of R8) holds (for B537 being (FinSequence of ( QuasiTerms R8 )) holds (( len B537 ) = ( len ( the_arity_of B536 ) ) implies H10(B536 , B537) is (expression of R8 , ( the_result_sort_of B536 ))))) by L1123;
L2678: (for R19 being (expression of R8 , ( an_Adj R8 )) holds H11(R19) is (expression of R8 , ( an_Adj R8 ))) by L937;
L2679: (for R19 being (expression of R8 , ( an_Adj R8 )) holds (for R14 being (expression of R8 , ( a_Type R8 )) holds H12(R19 , R14) is (expression of R8 , ( a_Type R8 )))) by L996;
consider C585 being (term-transformation of R8 , ( MSVars R8 )) such that L2680: ((for B538 being variable holds ( C585 . ( B538 -term R8 ) ) = H9(B538)) & (for B539 being  constructor (OperSymbol of R8) holds (for B540 , B541 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B540 ) = ( len ( the_arity_of B539 ) ) & B541 = ( C585 * B540 )) implies ( C585 . ( B539 -trm B540 ) ) = H10(B539 , B541)))) & (for R19 being (expression of R8 , ( an_Adj R8 )) holds ( C585 . ( ( non_op R8 ) term R19 ) ) = H11(( C585 . R19 ))) & (for R19 being (expression of R8 , ( an_Adj R8 )) holds (for R14 being (expression of R8 , ( a_Type R8 )) holds ( C585 . ( ( ast R8 ) term (R19 , R14) ) ) = H12(( C585 . R19 ) , ( C585 . R14 ))))) from StructDef(L2674 , L2677 , L2678 , L2679);
take C585;
thus L2681:now
let C586 being variable;
L2682: ( C585 . ( C586 -term R8 ) ) = H9(C586) by L2680;
L2683: (C586 in ( dom C583 ) implies ( C583 /. C586 ) = ( C583 . C586 )) by PARTFUN1:def 6;
thus L2684: (C586 in ( dom C583 ) implies ( C585 . ( C586 -term R8 ) ) = ( C583 . C586 )) by L2683 , L2682 , MATRIX_7:def 1;
thus L2685: ((not C586 in ( dom C583 )) implies ( C585 . ( C586 -term R8 ) ) = ( C586 -term R8 )) by L2682 , MATRIX_7:def 1;
end;
thus L2686: thesis by L2680;
end;
correctness
proof
let C587 , C588 being (term-transformation of R8 , ( MSVars R8 ));
assume that
L2687: (for B542 being variable holds ((B542 in ( dom C583 ) implies ( C587 . ( B542 -term R8 ) ) = ( C583 . B542 )) & ((not B542 in ( dom C583 )) implies ( C587 . ( B542 -term R8 ) ) = ( B542 -term R8 ))))
and
L2688: (for B543 being  constructor (OperSymbol of R8) holds (for B544 , B545 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B544 ) = ( len ( the_arity_of B543 ) ) & B545 = ( C587 * B544 )) implies ( C587 . ( B543 -trm B544 ) ) = ( B543 -trm B545 ))))
and
L2689: (for B546 being (expression of R8 , ( an_Adj R8 )) holds ( C587 . ( ( non_op R8 ) term B546 ) ) = ( ( non_op R8 ) term ( C587 . B546 ) ))
and
L2690: (for B547 being (expression of R8 , ( an_Adj R8 )) holds (for B548 being (expression of R8 , ( a_Type R8 )) holds ( C587 . ( ( ast R8 ) term (B547 , B548) ) ) = ( ( ast R8 ) term (( C587 . B547 ) , ( C587 . B548 )) )))
and
L2691: (for B549 being variable holds ((B549 in ( dom C583 ) implies ( C588 . ( B549 -term R8 ) ) = ( C583 . B549 )) & ((not B549 in ( dom C583 )) implies ( C588 . ( B549 -term R8 ) ) = ( B549 -term R8 ))))
and
L2692: (for B550 being  constructor (OperSymbol of R8) holds (for B551 , B552 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B551 ) = ( len ( the_arity_of B550 ) ) & B552 = ( C588 * B551 )) implies ( C588 . ( B550 -trm B551 ) ) = ( B550 -trm B552 ))))
and
L2693: (for B553 being (expression of R8 , ( an_Adj R8 )) holds ( C588 . ( ( non_op R8 ) term B553 ) ) = ( ( non_op R8 ) term ( C588 . B553 ) ))
and
L2694: (for B554 being (expression of R8 , ( an_Adj R8 )) holds (for B555 being (expression of R8 , ( a_Type R8 )) holds ( C588 . ( ( ast R8 ) term (B554 , B555) ) ) = ( ( ast R8 ) term (( C588 . B554 ) , ( C588 . B555 )) )));
set D377 = ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) );
L2695: ( dom C587 ) = D377 by FUNCT_2:def 1;
L2696: ( dom C588 ) = D377 by FUNCT_2:def 1;
defpred S19[ (expression of R8) ] means ( C587 . $1 ) = ( C588 . $1 );
L2697: (for B556 being variable holds S19[ ( B556 -term R8 ) ])
proof
let C589 being variable;
L2698: ((C589 in ( dom C583 ) & ( C587 . ( C589 -term R8 ) ) = ( C583 . C589 )) or (C589 nin ( dom C583 ) & ( C587 . ( C589 -term R8 ) ) = ( C589 -term R8 ))) by L2687;
thus L2699: thesis by L2698 , L2691;
end;
L2700: (for B557 being  constructor (OperSymbol of R8) holds (for B558 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B558 ) = ( len ( the_arity_of B557 ) ) & (for B559 being (quasi-term of R8) holds (B559 in ( rng B558 ) implies S19[ B559 ]))) implies S19[ ( B557 -trm B558 ) ])))
proof
let C590 being  constructor (OperSymbol of R8);
let C591 being (FinSequence of ( QuasiTerms R8 ));
assume that
L2701: ( len C591 ) = ( len ( the_arity_of C590 ) )
and
L2702: (for B560 being (quasi-term of R8) holds (B560 in ( rng C591 ) implies S19[ B560 ]));
L2703: ( rng C591 ) c= ( QuasiTerms R8 ) by FINSEQ_1:def 4;
L2704: ( rng ( C587 * C591 ) ) = ( C587 .: ( rng C591 ) ) by RELAT_1:127;
L2705: ( rng ( C588 * C591 ) ) = ( C588 .: ( rng C591 ) ) by RELAT_1:127;
L2706: ( rng ( C587 * C591 ) ) c= ( C587 .: ( QuasiTerms R8 ) ) by L2703 , L2704 , RELAT_1:123;
L2707: ( rng ( C588 * C591 ) ) c= ( C588 .: ( QuasiTerms R8 ) ) by L2703 , L2705 , RELAT_1:123;
L2708: ( C587 .: ( QuasiTerms R8 ) ) c= ( QuasiTerms R8 ) by L2408;
L2709: ( C588 .: ( QuasiTerms R8 ) ) c= ( QuasiTerms R8 ) by L2408;
L2710: ( rng ( C587 * C591 ) ) c= ( QuasiTerms R8 ) by L2706 , L2708 , XBOOLE_1:1;
L2711: ( rng ( C588 * C591 ) ) c= ( QuasiTerms R8 ) by L2707 , L2709 , XBOOLE_1:1;
reconsider D378 = ( C587 * C591 ) , D379 = ( C588 * C591 ) as (FinSequence of ( QuasiTerms R8 )) by L2711 , L2710 , FINSEQ_1:def 4;
L2712: ( rng C591 ) c= D377;
L2713: ( dom D378 ) = ( dom C591 ) by L2712 , L2695 , RELAT_1:27;
L2714: ( dom D379 ) = ( dom C591 ) by L2696 , L2712 , RELAT_1:27;
L2715:
now
let C592 being Nat;
assume L2716: C592 in ( dom C591 );
L2717: ( D378 . C592 ) = ( C587 . ( C591 . C592 ) ) by L2716 , FUNCT_1:13;
L2718: ( D379 . C592 ) = ( C588 . ( C591 . C592 ) ) by L2716 , FUNCT_1:13;
L2719: ( C591 . C592 ) in ( rng C591 ) by L2716 , FUNCT_1:def 3;
L2720: ( C591 . C592 ) is (quasi-term of R8) by L2719 , L2703 , L890;
thus L2721: ( D378 . C592 ) = ( D379 . C592 ) by L2720 , L2702 , L2717 , L2718 , L2719;
end;
L2722: ( C587 . ( C590 -trm C591 ) ) = ( C590 -trm D379 ) by L2715 , L2688 , L2701 , L2713 , L2714 , FINSEQ_1:13;
thus L2723: thesis by L2722 , L2692 , L2701;
end;
L2724: (for B561 being (expression of R8 , ( an_Adj R8 )) holds (S19[ B561 ] implies S19[ ( ( non_op R8 ) term B561 ) ]))
proof
let C593 being (expression of R8 , ( an_Adj R8 ));
assume L2725: S19[ C593 ];
L2726: ( C587 . ( ( non_op R8 ) term C593 ) ) = ( ( non_op R8 ) term ( C588 . C593 ) ) by L2725 , L2689;
thus L2727: thesis by L2726 , L2693;
end;
L2728: (for B562 being (expression of R8 , ( an_Adj R8 )) holds (S19[ B562 ] implies (for B563 being (expression of R8 , ( a_Type R8 )) holds (S19[ B563 ] implies S19[ ( ( ast R8 ) term (B562 , B563) ) ]))))
proof
let C594 being (expression of R8 , ( an_Adj R8 ));
assume that
L2729: S19[ C594 ];
let C595 being (expression of R8 , ( a_Type R8 ));
assume L2730: S19[ C595 ];
L2731: ( C587 . ( ( ast R8 ) term (C594 , C595) ) ) = ( ( ast R8 ) term (( C588 . C594 ) , ( C588 . C595 )) ) by L2730 , L2690 , L2729;
thus L2732: thesis by L2731 , L2694;
end;
L2733:
now
let C596 being (expression of R8);
thus L2734: S19[ C596 ] from StructInd(L2697 , L2700 , L2724 , L2728);
end;
thus L2735: thesis by L2733 , FUNCT_2:63;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let C597 being (valuation of R8);
cluster ( C597 # ) ->  substitution;
coherence
proof
let C598 being (OperSymbol of R8);
let C599 , C600 being (FinSequence of ( Free (R8 , ( MSVars R8 )) ));
assume that
L2737: ( [ C598 , (the carrier of R8) ] -tree C599 ) in ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) )
and
L2738: C600 = ( ( C597 # ) * C599 );
L2739: ( dom ( C597 # ) ) = ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by FUNCT_2:def 1;
reconsider D380 = ( [ C598 , (the carrier of R8) ] -tree C599 ) as (expression of R8) by L2737;
L2740: ( D380 . ( {} ) ) = [ C598 , (the carrier of R8) ] by TREES_4:def 4;
per cases  by L670;
suppose L2741: C598 is  constructor;

reconsider D381 = C598 as  constructor (OperSymbol of R8) by L2741;
L2742: D380 = ( [ D381 , (the carrier of R8) ] -tree C599 );
L2743: ( len C599 ) = ( len ( the_arity_of D381 ) ) by L2742 , L1057;
L2744: C599 in ( ( QuasiTerms R8 ) * ) by L2742 , L1057;
reconsider D382 = C599 as (FinSequence of ( QuasiTerms R8 )) by L2744 , FINSEQ_1:def 11;
reconsider D383 = ( ( C597 # ) * D382 ) as (FinSequence of ( QuasiTerms R8 )) by L2428;
L2745: ( len D383 ) = ( len C599 ) by L2428;
thus L2746: ( ( C597 # ) . ( [ C598 , (the carrier of R8) ] -tree C599 ) ) = ( ( C597 # ) . ( D381 -trm D382 ) ) by L2743 , L1118
.= ( D381 -trm D383 ) by L2743 , L2673
.= ( [ C598 , (the carrier of R8) ] -tree C600 ) by L2738 , L2743 , L2745 , L1118;
end;
suppose L2747: C598 = ( * );

consider C601 being (expression of R8 , ( an_Adj R8 )), C602 being (expression of R8 , ( a_Type R8 )) such that L2748: D380 = ( ( ast R8 ) term (C601 , C602) ) by L2747 , L2740 , L1240;
L2749: C601 in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( an_Adj R8 ) ) by L885;
L2750: ( ( C597 # ) . C601 ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( an_Adj R8 ) ) by L2749 , L2413;
reconsider D384 = ( ( C597 # ) . C601 ) as (expression of R8 , ( an_Adj R8 )) by L2750 , L890;
L2751: C602 in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Type R8 ) ) by L885;
L2752: ( ( C597 # ) . C602 ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Type R8 ) ) by L2751 , L2413;
reconsider D385 = ( ( C597 # ) . C602 ) as (expression of R8 , ( a_Type R8 )) by L2752 , L890;
L2753: D380 = ( [ ( ast R8 ) , (the carrier of R8) ] -tree <* C601 , C602 *> ) by L2748 , L996;
L2754: C599 = <* C601 , C602 *> by L2753 , TREES_4:15;
L2755: C600 = <* D384 , D385 *> by L2754 , L2738 , L2739 , FINSEQ_2:125;
L2756: ( [ C598 , (the carrier of R8) ] -tree C600 ) = ( ( ast R8 ) term (D384 , D385) ) by L2755 , L2747 , L996;
thus L2757: thesis by L2756 , L2748 , L2673;
end;
suppose L2758: C598 = ( non_op );

consider R19 being (expression of R8 , ( an_Adj R8 )) such that L2759: D380 = ( ( non_op R8 ) term R19 ) by L2758 , L2740 , L1219;
L2760: R19 in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( an_Adj R8 ) ) by L885;
L2761: ( ( C597 # ) . R19 ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( an_Adj R8 ) ) by L2760 , L2413;
reconsider D386 = ( ( C597 # ) . R19 ) as (expression of R8 , ( an_Adj R8 )) by L2761 , L890;
L2762: D380 = ( [ ( non_op R8 ) , (the carrier of R8) ] -tree <* R19 *> ) by L2759 , L937;
L2763: C599 = <* R19 *> by L2762 , TREES_4:15;
L2764: C600 = <* D386 *> by L2763 , L2738 , L2739 , FINSEQ_2:34;
L2765: ( [ C598 , (the carrier of R8) ] -tree C600 ) = ( ( non_op R8 ) term D386 ) by L2764 , L2758 , L937;
thus L2766: thesis by L2765 , L2759 , L2673;
end;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let R18 being (expression of R8);
func R18 at R24 -> (expression of R8) equals 
( ( R24 # ) . R18 );
coherence;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C603 being FinSequence;
assume that
L2770: ( rng C603 ) c= ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) );
func C603 at R24 -> FinSequence equals 
:L2771: ( ( R24 # ) * C603 );
coherence
proof
set D387 = ( Free (R8 , ( MSVars R8 )) );
L2772: ( dom ( R24 # ) ) = ( Union (the Sorts of D387) ) by FUNCT_2:def 1;
L2773: ( dom ( ( R24 # ) * C603 ) ) = ( dom C603 ) by L2772 , L2770 , RELAT_1:27;
L2774: ( dom C603 ) = ( Seg ( len C603 ) ) by FINSEQ_1:def 3;
thus L2775: thesis by L2774 , L2773 , FINSEQ_1:def 2;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C604 being (FinSequence of ( QuasiTerms R8 ));
redefine func C604 at R24 -> (FinSequence of ( QuasiTerms R8 )) equals 
( ( R24 # ) * C604 );
coherence
proof
L2777: ( ( R24 # ) * C604 ) is (FinSequence of ( QuasiTerms R8 )) by L2428;
L2778: ( rng C604 ) c= ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) );
thus L2779: thesis by L2778 , L2777 , L2771;
end;
compatibility
proof
L2780: ( rng C604 ) c= ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) );
thus L2781: thesis by L2780 , L2771;
end;
end;
theorem
L2783: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for R25 being variable holds ((not R25 in ( dom R24 )) implies ( ( R25 -term R8 ) at R24 ) = ( R25 -term R8 ))))) by L2673;
theorem
L2784: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for R25 being variable holds (R25 in ( dom R24 ) implies ( ( R25 -term R8 ) at R24 ) = ( R24 . R25 ))))) by L2673;
theorem
L2785: (for R8 being  initialized ConstructorSignature holds (for R11 being  constructor (OperSymbol of R8) holds (for R17 being (FinSequence of ( QuasiTerms R8 )) holds (for R24 being (valuation of R8) holds (( len R17 ) = ( len ( the_arity_of R11 ) ) implies ( ( R11 -trm R17 ) at R24 ) = ( R11 -trm ( R17 at R24 ) )))))) by L2673;
theorem
L2786: (for R8 being  initialized ConstructorSignature holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds (for R24 being (valuation of R8) holds ( ( ( non_op R8 ) term R19 ) at R24 ) = ( ( non_op R8 ) term ( R19 at R24 ) )))) by L2673;
theorem
L2787: (for R8 being  initialized ConstructorSignature holds (for R14 being (expression of R8 , ( a_Type R8 )) holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds (for R24 being (valuation of R8) holds ( ( ( ast R8 ) term (R19 , R14) ) at R24 ) = ( ( ast R8 ) term (( R19 at R24 ) , ( R14 at R24 )) ))))) by L2673;
theorem
L2788: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds (for B564 being (Subset of ( Vars )) holds ( R18 at ( R8 idval B564 ) ) = R18)))
proof
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
set D388 = R18;
let C605 being (Subset of ( Vars ));
set D389 = ( R8 idval C605 );
defpred S20[ (expression of R8) ] means ( $1 at D389 ) = $1;
L2789: (for B565 being variable holds S20[ ( B565 -term R8 ) ])
proof
let C606 being variable;
L2790: (C606 in C605 or C606 nin C605);
L2791: ( dom D389 ) = C605 by L2647;
L2792: (C606 in C605 implies ( D389 . C606 ) = ( C606 -term R8 )) by L2647;
thus L2793: thesis by L2792 , L2790 , L2791 , L2673;
end;
L2794: (for B566 being  constructor (OperSymbol of R8) holds (for B567 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B567 ) = ( len ( the_arity_of B566 ) ) & (for B568 being (quasi-term of R8) holds (B568 in ( rng B567 ) implies S20[ B568 ]))) implies S20[ ( B566 -trm B567 ) ])))
proof
let C607 being  constructor (OperSymbol of R8);
let C608 being (FinSequence of ( QuasiTerms R8 ));
assume that
L2795: ( len C608 ) = ( len ( the_arity_of C607 ) )
and
L2796: (for B569 being (quasi-term of R8) holds (B569 in ( rng C608 ) implies S20[ B569 ]));
L2797: ( len ( C608 at D389 ) ) = ( len C608 ) by L2428;
L2798: ( dom ( C608 at D389 ) ) = ( dom C608 ) by L2797 , FINSEQ_3:29;
L2799:
now
let C609 being Nat;
assume L2800: C609 in ( dom C608 );
L2801: ( C608 . C609 ) in ( rng C608 ) by L2800 , FUNCT_1:def 3;
L2802: ( rng C608 ) c= ( QuasiTerms R8 ) by FINSEQ_1:def 4;
reconsider D390 = ( C608 . C609 ) as (quasi-term of R8) by L2802 , L2801 , L890;
L2803: ( ( C608 at D389 ) . C609 ) = ( D390 at D389 ) by L2800 , FUNCT_1:13;
thus L2804: ( ( C608 at D389 ) . C609 ) = ( C608 . C609 ) by L2803 , L2796 , L2801;
end;
L2805: ( C608 at D389 ) = C608 by L2799 , L2798 , FINSEQ_1:13;
thus L2806: thesis by L2805 , L2795 , L2673;
end;
L2807: (for B570 being (expression of R8 , ( an_Adj R8 )) holds (S20[ B570 ] implies S20[ ( ( non_op R8 ) term B570 ) ])) by L2673;
L2808: (for B571 being (expression of R8 , ( an_Adj R8 )) holds (S20[ B571 ] implies (for B572 being (expression of R8 , ( a_Type R8 )) holds (S20[ B572 ] implies S20[ ( ( ast R8 ) term (B571 , B572) ) ])))) by L2673;
thus L2809: S20[ D388 ] from StructInd(L2789 , L2794 , L2807 , L2808);
end;
theorem
L2810: (for R8 being  initialized ConstructorSignature holds (for B573 being (Subset of ( Vars )) holds ( ( R8 idval B573 ) # ) = ( id ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) )))
proof
let R8 being  initialized ConstructorSignature;
let C610 being (Subset of ( Vars ));
set D391 = ( R8 idval C610 );
L2811: ( dom ( D391 # ) ) = ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by FUNCT_2:def 1;
L2812:
now
let C611 being set;
assume L2813: C611 in ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) );
reconsider D392 = C611 as (expression of R8) by L2813;
thus L2814: ( ( D391 # ) . C611 ) = ( D392 at D391 )
.= C611 by L2788;
end;
thus L2815: thesis by L2812 , L2811 , FUNCT_1:17;
end;
theorem
L2816: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds (for B574 being  empty (valuation of R8) holds ( R18 at B574 ) = R18)))
proof
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
let C612 being  empty (valuation of R8);
L2817: C612 = ( R8 idval ( {} ( Vars ) ) );
thus L2818: thesis by L2817 , L2788;
end;
theorem
L2819: (for R8 being  initialized ConstructorSignature holds (for B575 being  empty (valuation of R8) holds ( B575 # ) = ( id ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) )))
proof
let R8 being  initialized ConstructorSignature;
let C613 being  empty (valuation of R8);
L2820: ( dom ( C613 # ) ) = ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) ) by FUNCT_2:def 1;
L2821:
now
let C614 being set;
assume L2822: C614 in ( Union (the Sorts of ( Free (R8 , ( MSVars R8 )) )) );
reconsider D393 = C614 as (expression of R8) by L2822;
thus L2823: ( ( C613 # ) . C614 ) = ( D393 at C613 )
.= C614 by L2816;
end;
thus L2824: thesis by L2821 , L2820 , FUNCT_1:17;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C615 being (quasi-term of R8);
redefine func C615 at R24 -> (quasi-term of R8);

coherence
proof
L2825: C615 in ( QuasiTerms R8 ) by L885;
L2826: ( C615 at R24 ) in ( QuasiTerms R8 ) by L2825 , L2413;
thus L2827: thesis by L2826 , L890;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C616 being (expression of R8 , ( an_Adj R8 ));
redefine func C616 at R24 -> (expression of R8 , ( an_Adj R8 ));

coherence
proof
L2829: C616 in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( an_Adj R8 ) ) by L885;
L2830: ( C616 at R24 ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( an_Adj R8 ) ) by L2829 , L2413;
thus L2831: thesis by L2830 , L890;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C617 being  positive (expression of R8 , ( an_Adj R8 ));
cluster ( C617 at R24 ) ->  positive for (expression of R8 , ( an_Adj R8 ));
coherence
proof
consider C618 being  constructor (OperSymbol of R8) such that L2833: ( the_result_sort_of C618 ) = ( an_Adj R8 ) and L2834: (ex B576 being (FinSequence of ( QuasiTerms R8 )) st (( len B576 ) = ( len ( the_arity_of C618 ) ) & C617 = ( C618 -trm B576 ))) by L1342;
consider C619 being (FinSequence of ( QuasiTerms R8 )) such that L2835: ( len C619 ) = ( len ( the_arity_of C618 ) ) and L2836: C617 = ( C618 -trm C619 ) by L2834;
L2837: ( len ( C619 at R24 ) ) = ( len C619 ) by L2428;
L2838: ( C617 at R24 ) = ( C618 -trm ( C619 at R24 ) ) by L2835 , L2836 , L2673;
thus L2839: thesis by L2838 , L2833 , L2835 , L2837 , L1357;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C620 being  negative (expression of R8 , ( an_Adj R8 ));
cluster ( C620 at R24 ) ->  negative for (expression of R8 , ( an_Adj R8 ));
coherence
proof
L2841: ( ( non_op R8 ) term ( Non C620 ) ) = C620 by L1307;
L2842: ( C620 at R24 ) = ( ( non_op R8 ) term ( ( Non C620 ) at R24 ) ) by L2841 , L2673
.= ( Non ( ( Non C620 ) at R24 ) ) by L1283;
thus L2843: thesis by L2842;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C621 being (quasi-adjective of R8);
redefine func C621 at R24 -> (quasi-adjective of R8);

coherence
proof
per cases ;
suppose L2845: C621 is  positive;

reconsider D394 = C621 as  positive (quasi-adjective of R8) by L2845;
L2846: ( D394 at R24 ) is  positive;
thus L2847: thesis by L2846;
end;
suppose L2848: C621 is  negative;

reconsider D395 = C621 as  negative (quasi-adjective of R8) by L2848;
L2849: ( D395 at R24 ) is  negative;
thus L2850: thesis by L2849;
end;
end;
end;
theorem
L2853: (for R8 being  initialized ConstructorSignature holds (for R19 being (expression of R8 , ( an_Adj R8 )) holds (for R24 being (valuation of R8) holds ( ( Non R19 ) at R24 ) = ( Non ( R19 at R24 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R19 being (expression of R8 , ( an_Adj R8 ));
let R24 being (valuation of R8);
per cases ;
suppose L2854: R19 is  positive;

reconsider D396 = R19 as  positive (expression of R8 , ( an_Adj R8 )) by L2854;
reconsider D397 = ( D396 at R24 ) as  positive (expression of R8 , ( an_Adj R8 ));
thus L2855: ( ( Non R19 ) at R24 ) = ( ( ( non_op R8 ) term D396 ) at R24 ) by L1283
.= ( ( non_op R8 ) term D397 ) by L2673
.= ( Non ( R19 at R24 ) ) by L1283;
end;
suppose L2856: R19 is non  positive;

consider C622 being (expression of R8 , ( an_Adj R8 )) such that L2857: R19 = ( ( non_op R8 ) term C622 ) and L2858: ( Non R19 ) = C622 by L2856 , L1294;
L2859: ( R19 at R24 ) = ( ( non_op R8 ) term ( C622 at R24 ) ) by L2857 , L2673;
L2860: ( R19 at R24 ) is non  positive by L2859 , L1270;
L2861: (ex B577 being (expression of R8 , ( an_Adj R8 )) st (( R19 at R24 ) = ( ( non_op R8 ) term B577 ) & ( Non ( R19 at R24 ) ) = B577)) by L2860 , L1294;
thus L2862: thesis by L2861 , L2858 , L2859 , L944;
end;
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C623 being (expression of R8 , ( a_Type R8 ));
redefine func C623 at R24 -> (expression of R8 , ( a_Type R8 ));

coherence
proof
L2864: C623 in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Type R8 ) ) by L885;
L2865: ( C623 at R24 ) in ( (the Sorts of ( Free (R8 , ( MSVars R8 )) )) . ( a_Type R8 ) ) by L2864 , L2413;
thus L2866: thesis by L2865 , L890;
end;
end;
registration
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C624 being  pure (expression of R8 , ( a_Type R8 ));
cluster ( C624 at R24 ) ->  pure for (expression of R8 , ( a_Type R8 ));
coherence
proof
consider C625 being  constructor (OperSymbol of R8) such that L2868: ( the_result_sort_of C625 ) = ( a_Type R8 ) and L2869: (ex B578 being (FinSequence of ( QuasiTerms R8 )) st (( len B578 ) = ( len ( the_arity_of C625 ) ) & C624 = ( C625 -trm B578 ))) by L1441;
consider C626 being (FinSequence of ( QuasiTerms R8 )) such that L2870: ( len C626 ) = ( len ( the_arity_of C625 ) ) and L2871: C624 = ( C625 -trm C626 ) by L2869;
L2872: ( len ( C626 at R24 ) ) = ( len C626 ) by L2428;
L2873: ( C624 at R24 ) = ( C625 -trm ( C626 at R24 ) ) by L2870 , L2871 , L2673;
thus L2874: thesis by L2873 , L2868 , L2870 , L2872 , L1456;
end;
end;
theorem
L2876: (for R8 being  initialized ConstructorSignature holds (for B579 being  irrelevant  one-to-one (valuation of R8) holds (ex B580 being  irrelevant  one-to-one (valuation of R8) st (for B581 , B582 being variable holds ((B581 in ( dom B579 ) & ( B579 . B581 ) = ( B582 -term R8 )) iff (B582 in ( dom B580 ) & ( B580 . B582 ) = ( B581 -term R8 )))))))
proof
let R8 being  initialized ConstructorSignature;
let C627 being  irrelevant  one-to-one (valuation of R8);
set D398 = { B583 where B583 is variable : ( B583 -term R8 ) in ( rng C627 ) };
defpred S21[ set , set ] means (ex B584 being set st (B584 in ( dom C627 ) & ( C627 . B584 ) = ( root-tree [ $1 , ( a_Term ) ] ) & $2 = ( root-tree [ B584 , ( a_Term ) ] )));
L2877: (for B585 being set holds (B585 in D398 implies (ex B586 being set st S21[ B585 , B586 ])))
proof
let C628 being set;
assume L2878: C628 in D398;
L2879: (ex B587 being variable st (C628 = B587 & ( B587 -term R8 ) in ( rng C627 ))) by L2878;
reconsider D399 = C628 as variable by L2879;
consider C629 being set such that L2880: C629 in ( dom C627 ) and L2881: ( D399 -term R8 ) = ( C627 . C629 ) by L2879 , FUNCT_1:def 3;
reconsider D400 = C629 as variable by L2880;
take ( D400 -term R8 );
thus L2882: thesis by L2880 , L2881;
end;
consider C630 being Function such that L2883: ( dom C630 ) = D398 and L2884: (for B588 being set holds (B588 in D398 implies S21[ B588 , ( C630 . B588 ) ])) from CLASSES1:sch 1(L2877);
L2885: D398 c= ( Vars )
proof
let C631 being set;
assume L2886: C631 in D398;
L2887: (ex B589 being variable st (C631 = B589 & ( B589 -term R8 ) in ( rng C627 ))) by L2886;
thus L2888: thesis by L2887;
end;
L2889: ( rng C630 ) c= ( QuasiTerms R8 )
proof
let C632 being set;
assume L2890: C632 in ( rng C630 );
consider C633 being set such that L2891: C633 in ( dom C630 ) and L2892: C632 = ( C630 . C633 ) by L2890 , FUNCT_1:def 3;
reconsider D401 = C633 as variable by L2883 , L2885 , L2891;
consider C634 being set such that L2893: C634 in ( dom C627 ) and L2894: ( C627 . C634 ) = ( D401 -term R8 ) and L2895: ( C630 . D401 ) = ( root-tree [ C634 , ( a_Term ) ] ) by L2883 , L2884 , L2891;
reconsider D402 = C634 as variable by L2893;
L2896: C632 = ( D402 -term R8 ) by L2892 , L2895;
thus L2897: thesis by L2896 , L885;
end;
reconsider D403 = C630 as (valuation of R8) by L2889 , L2883 , L2885 , RELSET_1:4;
L2898: D403 is  irrelevant
proof
let C635 being variable;
assume L2899: C635 in ( dom D403 );
consider C636 being set such that L2900: C636 in ( dom C627 ) and L2901: ( C627 . C636 ) = ( C635 -term R8 ) and L2902: ( D403 . C635 ) = ( root-tree [ C636 , ( a_Term ) ] ) by L2899 , L2883 , L2884;
reconsider D404 = C636 as variable by L2900;
take D404;
thus L2903: thesis by L2902;
end;
L2904: D403 is  one-to-one
proof
let C637 , C638 being set;
assume that
L2905: C637 in ( dom D403 )
and
L2906: C638 in ( dom D403 )
and
L2907: ( D403 . C637 ) = ( D403 . C638 );
reconsider D405 = C637 , D406 = C638 as variable by L2905 , L2906;
consider C639 being set such that L2908: C639 in ( dom C627 ) and L2909: ( C627 . C639 ) = ( D405 -term R8 ) and L2910: ( D403 . D405 ) = ( root-tree [ C639 , ( a_Term ) ] ) by L2883 , L2884 , L2905;
consider C640 being set such that L2911: C640 in ( dom C627 ) and L2912: ( C627 . C640 ) = ( D406 -term R8 ) and L2913: ( D403 . D405 ) = ( root-tree [ C640 , ( a_Term ) ] ) by L2883 , L2884 , L2906 , L2907;
reconsider D407 = C639 , D408 = C640 as variable by L2908 , L2911;
L2914: ( D407 -term R8 ) = ( D408 -term R8 ) by L2910 , L2913;
L2915: D407 = D408 by L2914 , L1047;
thus L2916: thesis by L2915 , L2909 , L2912 , L1047;
end;
reconsider D409 = D403 as  irrelevant  one-to-one (valuation of R8) by L2904 , L2898;
take D409;
let C641 , C642 being variable;
thus L2917:now
assume that
L2918: C641 in ( dom C627 )
and
L2919: ( C627 . C641 ) = ( C642 -term R8 );
L2920: ( C627 . C641 ) in ( rng C627 ) by L2918 , FUNCT_1:def 3;
thus L2921: C642 in ( dom D409 ) by L2920 , L2883 , L2919;
L2922: S21[ C642 , ( D409 . C642 ) ] by L2921 , L2883 , L2884;
thus L2923: ( D409 . C642 ) = ( C641 -term R8 ) by L2922 , L2918 , L2919 , FUNCT_1:def 4;
end;
assume that
L2924: C642 in ( dom D409 )
and
L2925: ( D409 . C642 ) = ( C641 -term R8 );
consider C643 being set such that L2926: C643 in ( dom C627 ) and L2927: ( C627 . C643 ) = ( root-tree [ C642 , ( a_Term ) ] ) and L2928: ( C641 -term R8 ) = ( root-tree [ C643 , ( a_Term ) ] ) by L2883 , L2884 , L2924 , L2925;
reconsider D410 = C643 as variable by L2926;
L2929: ( C641 -term R8 ) = ( D410 -term R8 ) by L2928;
thus L2930: thesis by L2929 , L2926 , L2927 , L1047;
end;
theorem
L2931: (for R8 being  initialized ConstructorSignature holds (for B590 , B591 being  irrelevant  one-to-one (valuation of R8) holds ((for B592 , B593 being variable holds ((B592 in ( dom B590 ) & ( B590 . B592 ) = ( B593 -term R8 )) implies (B593 in ( dom B591 ) & ( B591 . B593 ) = ( B592 -term R8 )))) implies (for R18 being (expression of R8) holds (( variables_in R18 ) c= ( dom B590 ) implies ( ( R18 at B590 ) at B591 ) = R18)))))
proof
let R8 being  initialized ConstructorSignature;
let C644 , C645 being  irrelevant  one-to-one (valuation of R8);
assume that
L2932: (for B594 , B595 being variable holds ((B594 in ( dom C644 ) & ( C644 . B594 ) = ( B595 -term R8 )) implies (B595 in ( dom C645 ) & ( C645 . B595 ) = ( B594 -term R8 ))));
let C646 being (expression of R8);
defpred S22[ (expression of R8) ] means (( variables_in $1 ) c= ( dom C644 ) implies ( ( $1 at C644 ) at C645 ) = $1);
L2933: (for B596 being variable holds S22[ ( B596 -term R8 ) ])
proof
let C647 being variable;
assume L2934: ( variables_in ( C647 -term R8 ) ) c= ( dom C644 );
L2935: { C647 } c= ( dom C644 ) by L2934 , MSAFREE3:10;
L2936: C647 in ( dom C644 ) by L2935 , ZFMISC_1:31;
consider C648 being variable such that L2937: ( C644 . C647 ) = ( C648 -term R8 ) by L2936 , L2626;
L2938: C648 in ( dom C645 ) by L2932 , L2936 , L2937;
L2939: ( C645 . C648 ) = ( C647 -term R8 ) by L2932 , L2936 , L2937;
L2940: ( ( C647 -term R8 ) at C644 ) = ( C648 -term R8 ) by L2936 , L2937 , L2673;
thus L2941: thesis by L2940 , L2938 , L2939 , L2673;
end;
L2942: (for B597 being  constructor (OperSymbol of R8) holds (for B598 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B598 ) = ( len ( the_arity_of B597 ) ) & (for B599 being (quasi-term of R8) holds (B599 in ( rng B598 ) implies S22[ B599 ]))) implies S22[ ( B597 -trm B598 ) ])))
proof
let C649 being  constructor (OperSymbol of R8);
let C650 being (FinSequence of ( QuasiTerms R8 ));
assume that
L2943: ( len C650 ) = ( len ( the_arity_of C649 ) )
and
L2944: (for B600 being (quasi-term of R8) holds (B600 in ( rng C650 ) implies S22[ B600 ]))
and
L2945: ( variables_in ( C649 -trm C650 ) ) c= ( dom C644 );
L2946: ( C649 -trm C650 ) = ( [ C649 , (the carrier of R8) ] -tree C650 ) by L2943 , L1118;
L2947: ( variables_in ( C649 -trm C650 ) ) = ( union { ( variables_in B601 ) where B601 is (quasi-term of R8) : B601 in ( rng C650 ) } ) by L2946 , L1570;
L2948: ( len ( C650 at C644 ) ) = ( len C650 ) by L2428;
L2949: ( len ( ( C650 at C644 ) at C645 ) ) = ( len ( C650 at C644 ) ) by L2428;
L2950: ( dom ( C650 at C644 ) ) = ( dom C650 ) by L2948 , FINSEQ_3:29;
L2951: ( dom ( ( C650 at C644 ) at C645 ) ) = ( dom ( C650 at C644 ) ) by L2949 , FINSEQ_3:29;
L2952:
now
let C651 being Nat;
assume L2953: C651 in ( dom C650 );
L2954: ( ( C650 at C644 ) . C651 ) = ( ( C644 # ) . ( C650 . C651 ) ) by L2953 , FUNCT_1:13;
L2955: ( C650 . C651 ) in ( rng C650 ) by L2953 , FUNCT_1:def 3;
L2956: ( rng C650 ) c= ( QuasiTerms R8 ) by FINSEQ_1:def 4;
reconsider D411 = ( C650 . C651 ) as (quasi-term of R8) by L2956 , L2955 , L890;
L2957: ( variables_in D411 ) in { ( variables_in B602 ) where B602 is (quasi-term of R8) : B602 in ( rng C650 ) } by L2955;
L2958: ( variables_in D411 ) c= ( variables_in ( C649 -trm C650 ) ) by L2957 , L2947 , ZFMISC_1:74;
L2959: ( ( ( C650 at C644 ) at C645 ) . C651 ) = ( ( D411 at C644 ) at C645 ) by L2950 , L2953 , L2954 , FUNCT_1:13;
thus L2960: ( ( ( C650 at C644 ) at C645 ) . C651 ) = ( C650 . C651 ) by L2959 , L2944 , L2945 , L2955 , L2958 , XBOOLE_1:1;
end;
L2961: ( ( C650 at C644 ) at C645 ) = C650 by L2952 , L2950 , L2951 , FINSEQ_1:13;
L2962: ( ( C649 -trm C650 ) at C644 ) = ( C649 -trm ( C650 at C644 ) ) by L2943 , L2673;
thus L2963: thesis by L2962 , L2943 , L2948 , L2961 , L2673;
end;
L2964: (for B603 being (expression of R8 , ( an_Adj R8 )) holds (S22[ B603 ] implies S22[ ( ( non_op R8 ) term B603 ) ]))
proof
let C652 being (expression of R8 , ( an_Adj R8 ));
assume that
L2965: S22[ C652 ]
and
L2966: ( variables_in ( ( non_op R8 ) term C652 ) ) c= ( dom C644 );
L2967: ( ( non_op R8 ) term C652 ) = ( [ ( non_op ) , (the carrier of R8) ] -tree <* C652 *> ) by L937;
thus L2968: ( ( ( ( non_op R8 ) term C652 ) at C644 ) at C645 ) = ( ( ( non_op R8 ) term ( C652 at C644 ) ) at C645 ) by L2673
.= ( ( non_op R8 ) term C652 ) by L2965 , L2966 , L2967 , L2673 , L1632;
end;
L2969: (for B604 being (expression of R8 , ( an_Adj R8 )) holds (S22[ B604 ] implies (for B605 being (expression of R8 , ( a_Type R8 )) holds (S22[ B605 ] implies S22[ ( ( ast R8 ) term (B604 , B605) ) ]))))
proof
let C653 being (expression of R8 , ( an_Adj R8 ));
assume that
L2970: S22[ C653 ];
let C654 being (expression of R8 , ( a_Type R8 ));
assume that
L2971: S22[ C654 ]
and
L2972: ( variables_in ( ( ast R8 ) term (C653 , C654) ) ) c= ( dom C644 );
L2973: ( ( ast R8 ) term (C653 , C654) ) = ( [ ( * ) , (the carrier of R8) ] -tree <* C653 , C654 *> ) by L996;
L2974: ( variables_in ( ( ast R8 ) term (C653 , C654) ) ) = ( ( ( R8 variables_in C653 ) \/ ( R8 variables_in C654 ) ) . ( a_Term ) ) by L2973 , L1646
.= ( ( variables_in C653 ) \/ ( variables_in C654 ) ) by PBOOLE:def 4;
thus L2975: ( ( ( ( ast R8 ) term (C653 , C654) ) at C644 ) at C645 ) = ( ( ( ast R8 ) term (( C653 at C644 ) , ( C654 at C644 )) ) at C645 ) by L2673
.= ( ( ast R8 ) term (C653 , C654) ) by L2970 , L2971 , L2972 , L2974 , L2673 , XBOOLE_1:11;
end;
thus L2976: S22[ C646 ] from StructInd(L2933 , L2942 , L2964 , L2969);
end;
definition
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C655 being (Subset of ( QuasiAdjs R8 ));
func C655 at R24 -> (Subset of ( QuasiAdjs R8 )) equals 
{ ( B606 at R24 ) where B606 is (quasi-adjective of R8) : B606 in C655 };
coherence
proof
set D412 = { ( B607 at R24 ) where B607 is (quasi-adjective of R8) : B607 in C655 };
L2977: D412 c= ( QuasiAdjs R8 )
proof
let C656 being set;
assume L2978: C656 in D412;
L2979: (ex B608 being (quasi-adjective of R8) st (C656 = ( B608 at R24 ) & B608 in C655)) by L2978;
thus L2980: thesis by L2979;
end;
thus L2981: thesis by L2977;
end;
end;
theorem
L2983: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for B609 being (Subset of ( QuasiAdjs R8 )) holds (for B610 being (quasi-adjective of R8) holds (B609 = { B610 } implies ( B609 at R24 ) = { ( B610 at R24 ) })))))
proof
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C657 being (Subset of ( QuasiAdjs R8 ));
let C658 being (quasi-adjective of R8);
assume that
L2984: C657 = { C658 };
thus L2985: ( C657 at R24 ) c= { ( C658 at R24 ) }
proof
let C659 being set;
assume L2986: C659 in ( C657 at R24 );
L2987: (ex B611 being (quasi-adjective of R8) st (C659 = ( B611 at R24 ) & B611 in C657)) by L2986;
L2988: C659 = ( C658 at R24 ) by L2987 , L2984 , TARSKI:def 1;
thus L2989: thesis by L2988 , TARSKI:def 1;
end;

let C660 being set;
assume L2990: C660 in { ( C658 at R24 ) };
L2991: C660 = ( C658 at R24 ) by L2990 , TARSKI:def 1;
L2992: C658 in C657 by L2984 , TARSKI:def 1;
thus L2993: thesis by L2992 , L2991;
end;
theorem
L2994: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for B612 , B613 being (Subset of ( QuasiAdjs R8 )) holds ( ( B612 \/ B613 ) at R24 ) = ( ( B612 at R24 ) \/ ( B613 at R24 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C661 , C662 being (Subset of ( QuasiAdjs R8 ));
thus L2995: ( ( C661 \/ C662 ) at R24 ) c= ( ( C661 at R24 ) \/ ( C662 at R24 ) )
proof
let C663 being set;
assume L2996: C663 in ( ( C661 \/ C662 ) at R24 );
consider C664 being (quasi-adjective of R8) such that L2997: C663 = ( C664 at R24 ) and L2998: C664 in ( C661 \/ C662 ) by L2996;
L2999: (C664 in C661 or C664 in C662) by L2998 , XBOOLE_0:def 3;
L3000: (C663 in ( C661 at R24 ) or C663 in ( C662 at R24 )) by L2999 , L2997;
thus L3001: thesis by L3000 , XBOOLE_0:def 3;
end;

let C665 being set;
assume L3002: C665 in ( ( C661 at R24 ) \/ ( C662 at R24 ) );
L3003: (C665 in ( C661 at R24 ) or C665 in ( C662 at R24 )) by L3002 , XBOOLE_0:def 3;
L3004: ((C661 c= ( C661 \/ C662 ) & (ex B614 being (quasi-adjective of R8) st (C665 = ( B614 at R24 ) & B614 in C661))) or (C662 c= ( C661 \/ C662 ) & (ex B615 being (quasi-adjective of R8) st (C665 = ( B615 at R24 ) & B615 in C662)))) by L3003 , XBOOLE_1:7;
thus L3005: thesis by L3004;
end;
theorem
L3006: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for B616 , B617 being (Subset of ( QuasiAdjs R8 )) holds (B616 c= B617 implies ( B616 at R24 ) c= ( B617 at R24 )))))
proof
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C666 , C667 being (Subset of ( QuasiAdjs R8 ));
assume L3007: C666 c= C667;
L3008: ( C666 \/ C667 ) = C667 by L3007 , XBOOLE_1:12;
L3009: ( C667 at R24 ) = ( ( C666 at R24 ) \/ ( C667 at R24 ) ) by L3008 , L2994;
thus L3010: thesis by L3009 , XBOOLE_1:7;
end;
registration
let C668 being  initialized ConstructorSignature;
let C669 being (valuation of C668);
let C670 being  finite (Subset of ( QuasiAdjs C668 ));
cluster ( C670 at C669 ) ->  finite;
coherence
proof
L3011: C670 is  finite;
deffunc H13((expression of C668)) = ( $1 at C669 );
L3012: { H13(B618) where B618 is (expression of C668) : B618 in C670 } is  finite from FRAENKEL:sch 21(L3011);
L3013: ( C670 at C669 ) c= { H13(B619) where B619 is (expression of C668) : B619 in C670 }
proof
let C671 being set;
assume L3014: C671 in ( C670 at C669 );
L3015: (ex B620 being (quasi-adjective of C668) st (C671 = ( B620 at C669 ) & B620 in C670)) by L3014;
thus L3016: thesis by L3015;
end;
thus L3017: thesis by L3013 , L3012;
end;
end;
definition
let C672 being  initialized ConstructorSignature;
let C673 being (valuation of C672);
let C674 being (quasi-type of C672);
func C674 at C673 -> (quasi-type of C672) equals 
( ( ( adjs C674 ) at C673 ) ast ( ( the_base_of C674 ) at C673 ) );
coherence;
end;
theorem
L3020: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for B621 being (quasi-type of R8) holds (( adjs ( B621 at R24 ) ) = ( ( adjs B621 ) at R24 ) & ( the_base_of ( B621 at R24 ) ) = ( ( the_base_of B621 ) at R24 ))))) by MCART_1:7;
theorem
L3021: (for R8 being  initialized ConstructorSignature holds (for R24 being (valuation of R8) holds (for B622 being (quasi-type of R8) holds (for B623 being (quasi-adjective of R8) holds ( ( B623 ast B622 ) at R24 ) = ( ( B623 at R24 ) ast ( B622 at R24 ) )))))
proof
let R8 being  initialized ConstructorSignature;
let R24 being (valuation of R8);
let C675 being (quasi-type of R8);
let C676 being (quasi-adjective of R8);
L3022: C676 in ( QuasiAdjs R8 );
reconsider D413 = { C676 } as (Subset of ( QuasiAdjs R8 )) by L3022 , ZFMISC_1:31;
thus L3023: ( ( C676 ast C675 ) at R24 ) = [ ( ( adjs ( C676 ast C675 ) ) at R24 ) , ( ( the_base_of C675 ) at R24 ) ] by MCART_1:7
.= [ ( ( D413 \/ ( adjs C675 ) ) at R24 ) , ( ( the_base_of C675 ) at R24 ) ] by MCART_1:7
.= [ ( ( D413 at R24 ) \/ ( ( adjs C675 ) at R24 ) ) , ( ( the_base_of C675 ) at R24 ) ] by L2994
.= [ ( { ( C676 at R24 ) } \/ ( ( adjs C675 ) at R24 ) ) , ( ( the_base_of C675 ) at R24 ) ] by L2983
.= [ ( { ( C676 at R24 ) } \/ ( adjs ( C675 at R24 ) ) ) , ( ( the_base_of C675 ) at R24 ) ] by MCART_1:7
.= ( ( C676 at R24 ) ast ( C675 at R24 ) ) by MCART_1:7;
end;
definition
let C677 being  initialized ConstructorSignature;
let C678 , C679 being (valuation of C677);
func C678 at C679 -> (valuation of C677) means 
:L3024: (( dom it ) = ( ( dom C678 ) \/ ( dom C679 ) ) & (for B624 being variable holds (B624 in ( dom it ) implies ( it . B624 ) = ( ( ( B624 -term C677 ) at C678 ) at C679 ))));
existence
proof
deffunc H14(set) = ( ( ( ( In ($1 , ( Vars )) ) -term C677 ) at C678 ) at C679 );
consider C680 being Function such that L3025: ( dom C680 ) = ( ( dom C678 ) \/ ( dom C679 ) ) and L3026: (for B625 being set holds (B625 in ( ( dom C678 ) \/ ( dom C679 ) ) implies ( C680 . B625 ) = H14(B625))) from FUNCT_1:sch 3;
L3027: ( rng C680 ) c= ( QuasiTerms C677 )
proof
let C681 being set;
assume L3028: C681 in ( rng C680 );
consider C682 being set such that L3029: C682 in ( dom C680 ) and L3030: C681 = ( C680 . C682 ) by L3028 , FUNCT_1:def 3;
L3031: C681 = H14(C682) by L3025 , L3026 , L3029 , L3030;
thus L3032: thesis by L3031 , L885;
end;
reconsider D414 = C680 as (valuation of C677) by L3027 , L3025 , RELSET_1:4;
take D414;
thus L3033: ( dom D414 ) = ( ( dom C678 ) \/ ( dom C679 ) ) by L3025;
let C683 being variable;
assume L3034: C683 in ( dom D414 );
L3035: ( D414 . C683 ) = H14(C683) by L3034 , L3025 , L3026;
thus L3036: thesis by L3035 , FUNCT_7:def 1;
end;
uniqueness
proof
let C684 , C685 being (valuation of C677);
assume that
L3037: ( dom C684 ) = ( ( dom C678 ) \/ ( dom C679 ) )
and
L3038: (for B626 being variable holds (B626 in ( dom C684 ) implies ( C684 . B626 ) = ( ( ( B626 -term C677 ) at C678 ) at C679 )))
and
L3039: ( dom C685 ) = ( ( dom C678 ) \/ ( dom C679 ) )
and
L3040: (for B627 being variable holds (B627 in ( dom C685 ) implies ( C685 . B627 ) = ( ( ( B627 -term C677 ) at C678 ) at C679 )));
L3041:
now
let C686 being variable;
assume L3042: C686 in ( dom C684 );
L3043: ( C684 . C686 ) = ( ( ( C686 -term C677 ) at C678 ) at C679 ) by L3042 , L3038;
thus L3044: ( C684 . C686 ) = ( C685 . C686 ) by L3043 , L3037 , L3039 , L3040 , L3042;
end;
thus L3045: thesis by L3041 , L3037 , L3039 , PARTFUN1:5;
end;
end;
registration
let C687 being  initialized ConstructorSignature;
let C688 , C689 being  irrelevant (valuation of C687);
cluster ( C688 at C689 ) ->  irrelevant;
coherence
proof
let C690 being variable;
assume L3047: C690 in ( dom ( C688 at C689 ) );
L3048: ( ( C688 at C689 ) . C690 ) = ( ( ( C690 -term C687 ) at C688 ) at C689 ) by L3047 , L3024;
L3049: ( dom ( C688 at C689 ) ) = ( ( dom C688 ) \/ ( dom C689 ) ) by L3024;
per cases ;
suppose L3050: C690 in ( dom C688 );

consider C691 being variable such that L3051: ( C688 . C690 ) = ( C691 -term C687 ) by L3050 , L2626;
L3052: ( ( C690 -term C687 ) at C688 ) = ( C691 -term C687 ) by L3050 , L3051 , L2673;
L3053: (C691 in ( dom C689 ) implies ( ( C688 at C689 ) . C690 ) = ( C689 . C691 )) by L3052 , L3048 , L2673;
L3054: (C691 nin ( dom C689 ) implies ( ( C688 at C689 ) . C690 ) = ( C691 -term C687 )) by L3048 , L3052 , L2673;
thus L3055: thesis by L3054 , L3053 , L2626;
end;
suppose L3056: C690 nin ( dom C688 );

L3057: ( ( C690 -term C687 ) at C688 ) = ( C690 -term C687 ) by L3056 , L2673;
L3058: C690 in ( dom C689 ) by L3047 , L3049 , L3056 , XBOOLE_0:def 3;
L3059: ( ( C688 at C689 ) . C690 ) = ( C689 . C690 ) by L3058 , L3048 , L3057 , L2673;
thus L3060: thesis by L3059 , L3058 , L2626;
end;
end;
end;
theorem
L3063: (for R8 being  initialized ConstructorSignature holds (for R18 being (expression of R8) holds (for B628 , B629 being (valuation of R8) holds ( ( R18 at B628 ) at B629 ) = ( R18 at ( B628 at B629 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let R18 being (expression of R8);
set D415 = R18;
let C692 , C693 being (valuation of R8);
L3064: ( dom ( C692 at C693 ) ) = ( ( dom C692 ) \/ ( dom C693 ) ) by L3024;
defpred S23[ (expression of R8) ] means ( ( $1 at C692 ) at C693 ) = ( $1 at ( C692 at C693 ) );
L3065: (for B630 being variable holds S23[ ( B630 -term R8 ) ])
proof
let C694 being variable;
per cases ;
suppose L3066: C694 in ( dom ( C692 at C693 ) );

L3067: ( ( C694 -term R8 ) at ( C692 at C693 ) ) = ( ( C692 at C693 ) . C694 ) by L3066 , L2673;
thus L3068: thesis by L3067 , L3066 , L3024;
end;
suppose L3069: C694 nin ( dom ( C692 at C693 ) );

L3070: C694 nin ( dom C692 ) by L3069 , L3064 , XBOOLE_0:def 3;
L3071: C694 nin ( dom C693 ) by L3064 , L3069 , XBOOLE_0:def 3;
L3072: ( ( C694 -term R8 ) at C692 ) = ( C694 -term R8 ) by L3070 , L2673;
L3073: ( ( C694 -term R8 ) at C693 ) = ( C694 -term R8 ) by L3071 , L2673;
thus L3074: thesis by L3073 , L3069 , L3072 , L2673;
end;
end;
L3076: (for B631 being  constructor (OperSymbol of R8) holds (for B632 being (FinSequence of ( QuasiTerms R8 )) holds ((( len B632 ) = ( len ( the_arity_of B631 ) ) & (for B633 being (quasi-term of R8) holds (B633 in ( rng B632 ) implies S23[ B633 ]))) implies S23[ ( B631 -trm B632 ) ])))
proof
let C695 being  constructor (OperSymbol of R8);
let C696 being (FinSequence of ( QuasiTerms R8 ));
assume that
L3077: ( len C696 ) = ( len ( the_arity_of C695 ) )
and
L3078: (for B634 being (quasi-term of R8) holds (B634 in ( rng C696 ) implies S23[ B634 ]));
L3079: ( len ( C696 at C692 ) ) = ( len C696 ) by L2428;
L3080: ( len ( C696 at ( C692 at C693 ) ) ) = ( len C696 ) by L2428;
L3081: ( len ( ( C696 at C692 ) at C693 ) ) = ( len ( C696 at C692 ) ) by L2428;
L3082: ( dom ( C696 at C692 ) ) = ( dom C696 ) by L3079 , FINSEQ_3:29;
L3083: ( dom ( C696 at ( C692 at C693 ) ) ) = ( dom C696 ) by L3080 , FINSEQ_3:29;
L3084: ( dom ( ( C696 at C692 ) at C693 ) ) = ( dom C696 ) by L3079 , L3081 , FINSEQ_3:29;
L3085:
now
let C697 being Nat;
assume L3086: C697 in ( dom C696 );
L3087: ( ( ( C696 at C692 ) at C693 ) . C697 ) = ( ( C693 # ) . ( ( C696 at C692 ) . C697 ) ) by L3086 , L3082 , FUNCT_1:13;
L3088: ( C696 . C697 ) in ( rng C696 ) by L3086 , FUNCT_1:def 3;
L3089: ( rng C696 ) c= ( QuasiTerms R8 ) by FINSEQ_1:def 4;
reconsider D416 = ( C696 . C697 ) as (quasi-term of R8) by L3089 , L3088 , L890;
thus L3090: ( ( ( C696 at C692 ) at C693 ) . C697 ) = ( ( D416 at C692 ) at C693 ) by L3086 , L3087 , FUNCT_1:13
.= ( D416 at ( C692 at C693 ) ) by L3078 , L3088
.= ( ( C696 at ( C692 at C693 ) ) . C697 ) by L3086 , FUNCT_1:13;
end;
L3091: ( ( C696 at C692 ) at C693 ) = ( C696 at ( C692 at C693 ) ) by L3085 , L3083 , L3084 , FINSEQ_1:13;
thus L3092: ( ( ( C695 -trm C696 ) at C692 ) at C693 ) = ( ( C695 -trm ( C696 at C692 ) ) at C693 ) by L3077 , L2673
.= ( C695 -trm ( C696 at ( C692 at C693 ) ) ) by L3077 , L3079 , L3091 , L2673
.= ( ( C695 -trm C696 ) at ( C692 at C693 ) ) by L3077 , L2673;
end;
L3093: (for B635 being (expression of R8 , ( an_Adj R8 )) holds (S23[ B635 ] implies S23[ ( ( non_op R8 ) term B635 ) ]))
proof
let C698 being (expression of R8 , ( an_Adj R8 ));
assume L3094: S23[ C698 ];
L3095: ( ( ( non_op R8 ) term ( C698 at C692 ) ) at C693 ) = ( ( non_op R8 ) term ( C698 at ( C692 at C693 ) ) ) by L3094 , L2673
.= ( ( ( non_op R8 ) term C698 ) at ( C692 at C693 ) ) by L2673;
thus L3096: thesis by L3095 , L2673;
end;
L3097: (for B636 being (expression of R8 , ( an_Adj R8 )) holds (S23[ B636 ] implies (for B637 being (expression of R8 , ( a_Type R8 )) holds (S23[ B637 ] implies S23[ ( ( ast R8 ) term (B636 , B637) ) ]))))
proof
let C699 being (expression of R8 , ( an_Adj R8 ));
assume that
L3098: S23[ C699 ];
let C700 being (expression of R8 , ( a_Type R8 ));
assume L3099: S23[ C700 ];
L3100: ( ( ( ast R8 ) term (( C699 at C692 ) , ( C700 at C692 )) ) at C693 ) = ( ( ast R8 ) term (( C699 at ( C692 at C693 ) ) , ( C700 at ( C692 at C693 ) )) ) by L3099 , L3098 , L2673
.= ( ( ( ast R8 ) term (C699 , C700) ) at ( C692 at C693 ) ) by L2673;
thus L3101: thesis by L3100 , L2673;
end;
thus L3102: S23[ D415 ] from StructInd(L3065 , L3076 , L3093 , L3097);
end;
theorem
L3103: (for R8 being  initialized ConstructorSignature holds (for B638 being (Subset of ( QuasiAdjs R8 )) holds (for B639 , B640 being (valuation of R8) holds ( ( B638 at B639 ) at B640 ) = ( B638 at ( B639 at B640 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let C701 being (Subset of ( QuasiAdjs R8 ));
let C702 , C703 being (valuation of R8);
thus L3104: ( ( C701 at C702 ) at C703 ) c= ( C701 at ( C702 at C703 ) )
proof
let C704 being set;
assume L3105: C704 in ( ( C701 at C702 ) at C703 );
consider C705 being (quasi-adjective of R8) such that L3106: C704 = ( C705 at C703 ) and L3107: C705 in ( C701 at C702 ) by L3105;
consider C706 being (quasi-adjective of R8) such that L3108: C705 = ( C706 at C702 ) and L3109: C706 in C701 by L3107;
L3110: C704 = ( C706 at ( C702 at C703 ) ) by L3106 , L3108 , L3063;
thus L3111: thesis by L3110 , L3109;
end;

let C707 being set;
assume L3112: C707 in ( C701 at ( C702 at C703 ) );
consider C708 being (quasi-adjective of R8) such that L3113: C707 = ( C708 at ( C702 at C703 ) ) and L3114: C708 in C701 by L3112;
L3115: C707 = ( ( C708 at C702 ) at C703 ) by L3113 , L3063;
L3116: ( C708 at C702 ) in ( C701 at C702 ) by L3114;
thus L3117: thesis by L3116 , L3115;
end;
theorem
L3118: (for R8 being  initialized ConstructorSignature holds (for B641 being (quasi-type of R8) holds (for B642 , B643 being (valuation of R8) holds ( ( B641 at B642 ) at B643 ) = ( B641 at ( B642 at B643 ) ))))
proof
let R8 being  initialized ConstructorSignature;
let C709 being (quasi-type of R8);
let C710 , C711 being (valuation of R8);
thus L3119: ( ( C709 at C710 ) at C711 ) = ( ( ( ( adjs C709 ) at C710 ) at C711 ) ast ( ( the_base_of ( C709 at C710 ) ) at C711 ) ) by MCART_1:7
.= ( ( ( adjs C709 ) at ( C710 at C711 ) ) ast ( ( the_base_of ( C709 at C710 ) ) at C711 ) ) by L3103
.= ( ( ( adjs C709 ) at ( C710 at C711 ) ) ast ( ( ( the_base_of C709 ) at C710 ) at C711 ) ) by MCART_1:7
.= ( C709 at ( C710 at C711 ) ) by L3063;
end;
