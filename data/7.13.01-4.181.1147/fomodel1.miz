:: Definition of first order language with arbitrary alphabet. Syntax of
:: terms, atomic formulas and their subterms.
::  by Marco B. Caminati
::
:: Received December 29, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, INT_1,
      RELAT_1, FINSEQ_1, FUNCT_1, ARYTM_3, XCMPLX_0, CARD_1, MONOID_0,
      ORDINAL1, ARYTM_1, STRUCT_0, XXREAL_0, XREAL_0, ORDINAL4, BINOP_1,
      FINSEQ_2, COMPLEX1, PARTFUN1, FINSET_1, SUPINF_2, MESFUNC1, PRE_POLY,
      SETFAM_1, FUNCT_4, FUNCOP_1, FUNCT_2, CARD_3, FOMODEL0, FOMODEL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NAT_1, CARD_1, NUMBERS, INT_1,
      PRE_POLY, FINSEQ_1, XCMPLX_0, RELAT_1, FUNCT_1, FUNCT_2, MONOID_0,
      XXREAL_0, XREAL_0, BINOP_1, FINSEQ_2, PARTFUN1, INT_2, FINSET_1,
      MATRIX_2, STRUCT_0, RELSET_1, SETFAM_1, FUNCT_4, FUNCOP_1, DOMAIN_1,
      CARD_3, ORDERS_4, FOMODEL0;
 constructors TARSKI, NAT_1, CARD_1, ZFMISC_1, NUMBERS, INT_1, ARYTM_3,
      FINSEQ_1, MONOID_0, STRUCT_0, XXREAL_0, BINOP_1, FINSEQ_2, COMPLEX1,
      RELSET_1, INT_2, FINSEQOP, DOMAIN_1, FINSET_1, MATRIX_2, REAL_1,
      PRE_POLY, SETFAM_1, FUNCT_4, FUNCOP_1, RELAT_1, FUNCT_1, FUNCT_2, CARD_3,
      ORDERS_4, FOMODEL0;
 registrations XCMPLX_0, NAT_1, RELAT_1, NUMBERS, FUNCT_1, INT_1, FINSEQ_1,
      STRUCT_0, FUNCT_2, FINSEQ_2, SUBSET_1, CARD_1, CARD_5, FINSET_1, PRALG_1,
      PRE_POLY, FINSEQ_6, FOMODEL0, XBOOLE_0, XXREAL_0, XREAL_0, FUNCOP_1,
      FUNCT_4, RELSET_1, RAMSEY_1, CARD_3, ORDINAL1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions XBOOLE_0, STRUCT_0, FUNCOP_1, FOMODEL0;
 theorems TARSKI, XBOOLE_0, INT_1, FUNCT_1, FINSEQ_1, RELAT_1, XBOOLE_1,
      STRUCT_0, ZFMISC_1, FUNCT_2, ENUMSET1, XXREAL_0, NAT_1, ORDINAL1,
      FINSEQ_5, FUNCT_4, FINSEQ_2, COMPLEX1, FINSEQ_4, RELSET_1, GRFUNC_1,
      FUNCOP_1, CARD_4, ORDERS_4, FOMODEL0, CARD_1, CARD_2;
 schemes NAT_1, FUNCT_2, DOMAIN_1;

begin
registration
let C1 being  zero  integer number;
cluster ( abs C1 ) ->  zero for  integer  integer  integer  integer number;
coherence by COMPLEX1:47;
end;
registration
cluster  negative  integer for  real  real  real  real number;
existence
proof
take ( - 1 );
thus L2: thesis;
end;
cluster  positive ->  natural for  integer  integer  integer  integer number;
coherence;
end;
registration
let C2 being non  degenerated ZeroOneStr;
cluster ( (the carrier of C2) \ { (the OneF of C2) } ) -> non  empty;
coherence
proof
set D1 = (the ZeroF of C2);
set D2 = (the OneF of C2);
L4: (D1 = ( 0. C2 ) & ( 1. C2 ) <> ( 0. C2 ) & ( 1. C2 ) = D2);
L5: D1 <> D2 by L4;
L6: (D1 in (the carrier of C2) & (not D1 in { D2 })) by L5 , TARSKI:def 1;
thus L7: thesis by L6 , XBOOLE_0:def 5;
end;
end;
definition
struct (ZeroOneStr) Language-like(# carrier -> set , ZeroF , OneF -> (Element of the carrier) , adicity -> (Function of ( the carrier \ { the OneF } ) , ( INT )) #);
end;
definition
let C3 being Language-like;
func AllSymbolsOf C3 equals 
(the carrier of C3);
coherence;
func LettersOf C3 equals 
( (the adicity of C3) " { ( 0 ) } );
coherence;
func OpSymbolsOf C3 equals 
( (the adicity of C3) " ( ( NAT ) \ { ( 0 ) } ) );
coherence;
func RelSymbolsOf C3 equals 
( (the adicity of C3) " ( ( INT ) \ ( NAT ) ) );
coherence;
func TermSymbolsOf C3 equals 
( (the adicity of C3) " ( NAT ) );
coherence;
func LowerCompoundersOf C3 equals 
( (the adicity of C3) " ( ( INT ) \ { ( 0 ) } ) );
coherence;
func TheEqSymbOf C3 equals 
(the ZeroF of C3);
coherence;
func TheNorSymbOf C3 equals 
(the OneF of C3);
coherence;
func OwnSymbolsOf C3 equals 
( (the carrier of C3) \ { (the ZeroF of C3) , (the OneF of C3) } );
coherence;
end;
definition
let C4 being Language-like;
mode Element of C4
 is (Element of ( AllSymbolsOf C4 ));
func AtomicFormulaSymbolsOf C4 equals 
( ( AllSymbolsOf C4 ) \ { ( TheNorSymbOf C4 ) } );
coherence;
func AtomicTermsOf C4 equals 
( 1 -tuples_on ( LettersOf C4 ) );
coherence;
attr C4 is  operational
means
( OpSymbolsOf C4 ) is non  empty;
attr C4 is  relational
means
( ( RelSymbolsOf C4 ) \ { ( TheEqSymbOf C4 ) } ) is non  empty;
end;
definition
let C5 being Language-like;
let C6 being (Element of C5);
attr C6 is  literal
means
:L12: C6 in ( LettersOf C5 );
attr C6 is  low-compounding
means
:L13: C6 in ( LowerCompoundersOf C5 );
attr C6 is  operational
means
:L14: C6 in ( OpSymbolsOf C5 );
attr C6 is  relational
means
:L15: C6 in ( RelSymbolsOf C5 );
attr C6 is  termal
means
:L16: C6 in ( TermSymbolsOf C5 );
attr C6 is  own
means
:L17: C6 in ( OwnSymbolsOf C5 );
attr C6 is  ofAtomicFormula
means
:L18: C6 in ( AtomicFormulaSymbolsOf C5 );
end;
definition
let C7 being ZeroOneStr;
let C8 being (Element of ( (the carrier of C7) \ { (the OneF of C7) } ));
func TrivialArity C8 ->  integer number equals 
:L20: ( - 2 ) if C8 = (the ZeroF of C7) otherwise ( 0 );
coherence;
consistency;
end;
definition
let C9 being ZeroOneStr;
let C10 being (Element of ( (the carrier of C9) \ { (the OneF of C9) } ));
redefine func TrivialArity C10 -> (Element of ( INT ));

coherence by INT_1:def 2;
end;
definition
let C11 being non  degenerated ZeroOneStr;
func C11 TrivialArity -> (Function of ( (the carrier of C11) \ { (the OneF of C11) } ) , ( INT )) means 
:L23: (for B1 being (Element of ( (the carrier of C11) \ { (the OneF of C11) } )) holds ( it . B1 ) = ( TrivialArity B1 ));
existence
proof
set D3 = ( (the carrier of C11) \ { (the OneF of C11) } );
deffunc H1((Element of D3)) = ( TrivialArity $1 );
consider C12 being (Function of D3 , ( INT )) such that L24: (for B2 being (Element of D3) holds ( C12 . B2 ) = H1(B2)) from FUNCT_2:sch 4;
take C12;
thus L25: thesis by L24;
end;
uniqueness
proof
set D4 = ( (the carrier of C11) \ { (the OneF of C11) } );
let C13 , C14 being (Function of D4 , ( INT ));
L26: (( dom C13 ) = D4 & ( dom C14 ) = D4) by FUNCT_2:def 1;
assume L27: (for B3 being (Element of D4) holds ( C13 . B3 ) = ( TrivialArity B3 ));
assume L28: (for B4 being (Element of D4) holds ( C14 . B4 ) = ( TrivialArity B4 ));
L29:
now
let C15 being set;
assume L30: C15 in ( dom C13 );
reconsider D5 = C15 as (Element of D4) by L30;
L31: ( C13 . D5 ) = ( TrivialArity D5 ) by L27
.= ( C14 . D5 ) by L28;
thus L32: ( C13 . C15 ) = ( C14 . C15 ) by L31;
end;
thus L33: thesis by L29 , L26 , FUNCT_1:2;
end;
end;
registration
cluster  infinite for non  degenerated non  degenerated non  degenerated non  degenerated ZeroOneStr;
existence
proof
set D6 = the  infinite set;
set D7 = the (Element of D6);
set D8 = the (Element of ( D6 \ { D7 } ));
reconsider D9 = ( D6 \ { D7 } ) as  infinite set;
L35: (not D8 in { D7 }) by XBOOLE_0:def 5;
L36: D8 <> D7 by L35 , TARSKI:def 1;
reconsider D10 = D8 as (Element of D6);
set D11 = ZeroOneStr (# D6 , D7 , D10 #);
L37: (( 1. D11 ) = D10 & ( 0. D11 ) = D7);
reconsider D12 = D11 as non  degenerated ZeroOneStr by L37 , L36 , STRUCT_0:def 8;
take D12;
thus L38: thesis;
end;
end;
registration
let C16 being  infinite non  degenerated ZeroOneStr;
cluster ( ( C16 TrivialArity ) " { ( 0 ) } ) ->  infinite;
coherence
proof
set D13 = (the carrier of C16);
set D14 = { (the ZeroF of C16) };
set D15 = { (the OneF of C16) };
set D16 = ( D13 \ D15 );
set D17 = ( D16 \ D14 );
set D18 = ( C16 TrivialArity );
L40: ( dom D18 ) = D16 by FUNCT_2:def 1;
L41: (for R9 being set holds (R9 in D17 implies R9 in ( D18 " { ( 0 ) } )))
proof
let R9 being set;
assume L42: R9 in D17;
reconsider D19 = R9 as (Element of D16) by L42;
L43: (not D19 in D14) by L42 , XBOOLE_0:def 5;
L44: D19 <> (the ZeroF of C16) by L43 , TARSKI:def 1;
L45: (( TrivialArity D19 ) = ( 0 ) & ( D18 . D19 ) = ( TrivialArity D19 )) by L44 , L20 , L23;
L46: (D19 in ( dom D18 ) & ( D18 . D19 ) in { ( 0 ) }) by L45 , L40 , TARSKI:def 1;
thus L47: thesis by L46 , FUNCT_1:def 7;
end;
L48: D17 c= ( D18 " { ( 0 ) } ) by L41 , TARSKI:def 3;
reconsider D20 = D16 as  infinite set;
thus L49: thesis by L48;
end;
end;
L51: (for B5 being non  degenerated ZeroOneStr holds ( ( B5 TrivialArity ) . (the ZeroF of B5) ) = ( - 2 ))
proof
let C17 being non  degenerated ZeroOneStr;
set D21 = ( C17 TrivialArity );
set D22 = (the ZeroF of C17);
set D23 = (the OneF of C17);
L52: (D22 = ( 0. C17 ) & D23 = ( 1. C17 ) & ( 0. C17 ) <> ( 1. C17 ));
L53: (not D22 in { D23 }) by L52 , TARSKI:def 1;
reconsider D24 = D22 as (Element of ( (the carrier of C17) \ { (the OneF of C17) } )) by L53 , XBOOLE_0:def 5;
L54: ( D21 . D24 ) = ( TrivialArity D24 ) by L23
.= ( - 2 ) by L20;
thus L55: thesis by L54;
end;
definition
let C18 being Language-like;
attr C18 is  eligible
means
:L56: (( LettersOf C18 ) is  infinite & ( (the adicity of C18) . ( TheEqSymbOf C18 ) ) = ( - 2 ));
end;
L58: (ex B6 being Language-like st (B6 is non  degenerated & B6 is  eligible))
proof
set D25 = the  infinite non  degenerated ZeroOneStr;
L59: ( 0. D25 ) <> ( 1. D25 );
set D26 = ( D25 TrivialArity );
take D27 = Language-like (# (the carrier of D25) , (the ZeroF of D25) , (the OneF of D25) , D26 #);
L60: ( 0. D27 ) <> ( 1. D27 ) by L59;
thus L61: D27 is non  degenerated by L60 , STRUCT_0:def 8;
set D28 = (the adicity of D27);
thus L62: ( LettersOf D27 ) is  infinite;
thus L63: thesis by L51;
end;
registration
cluster non  degenerated for Language-like;
existence by L58;
end;
registration
cluster  eligible for non  degenerated non  degenerated non  degenerated non  degenerated Language-like;
existence by L58;
end;
definition
mode Language
 is  eligible non  degenerated Language-like;
end;
definition
let C19 being non  empty Language-like;
redefine func AllSymbolsOf C19 -> non  empty set;

coherence;
end;
registration
let C20 being  eligible Language-like;
cluster ( LettersOf C20 ) ->  infinite;
coherence by L56;
end;
definition
let C21 being Language;
redefine func LettersOf C21 -> non  empty (Subset of ( AllSymbolsOf C21 ));

coherence by XBOOLE_1:1;
end;
L70: (for B7 being non  degenerated Language-like holds ( TheEqSymbOf B7 ) in ( ( AllSymbolsOf B7 ) \ { ( TheNorSymbOf B7 ) } ))
proof
let C22 being non  degenerated Language-like;
set D29 = ( TheEqSymbOf C22 );
set D30 = ( TheNorSymbOf C22 );
set D31 = ( AllSymbolsOf C22 );
L71: (( 1. C22 ) <> ( 0. C22 ) & D29 = ( 0. C22 ) & D30 = ( 1. C22 ));
L72: (D29 in D31 & (not D29 in { D30 })) by L71 , TARSKI:def 1;
thus L73: thesis by L72 , XBOOLE_0:def 5;
end;
registration
let C23 being Language;
cluster ( TheEqSymbOf C23 ) ->  relational for (Element of C23);
coherence
proof
set D32 = ( TheEqSymbOf C23 );
set D33 = ( RelSymbolsOf C23 );
set D34 = (the adicity of C23);
set D35 = ( ( AllSymbolsOf C23 ) \ { ( TheNorSymbOf C23 ) } );
L74: (( - 2 ) in ( INT ) & (not ( - 2 ) in ( NAT ))) by INT_1:def 2;
L75: ( - 2 ) in ( ( INT ) \ ( NAT ) ) by L74 , XBOOLE_0:def 5;
L76: (D32 in D35 & ( dom D34 ) = D35) by L70 , FUNCT_2:def 1;
L77: (D32 in ( dom D34 ) & ( D34 . D32 ) in ( ( INT ) \ ( NAT ) )) by L76 , L75 , L56;
L78: D32 in D33 by L77 , FUNCT_1:def 7;
thus L79: thesis by L78 , L15;
end;
end;
definition
let C24 being non  degenerated Language-like;
redefine func AtomicFormulaSymbolsOf C24 -> non  empty (Subset of ( AllSymbolsOf C24 ));

coherence;
end;
definition
let C25 being non  degenerated Language-like;
redefine func TheEqSymbOf C25 -> (Element of ( AtomicFormulaSymbolsOf C25 ));

coherence by L70;
end;
theorem
L83: (for B8 being Language holds (( ( LettersOf B8 ) /\ ( OpSymbolsOf B8 ) ) = ( {} ) & ( ( TermSymbolsOf B8 ) /\ ( LowerCompoundersOf B8 ) ) = ( OpSymbolsOf B8 ) & ( ( RelSymbolsOf B8 ) \ ( OwnSymbolsOf B8 ) ) = { ( TheEqSymbOf B8 ) } & ( OwnSymbolsOf B8 ) c= ( AtomicFormulaSymbolsOf B8 ) & ( RelSymbolsOf B8 ) c= ( LowerCompoundersOf B8 ) & ( OpSymbolsOf B8 ) c= ( TermSymbolsOf B8 ) & ( LettersOf B8 ) c= ( TermSymbolsOf B8 ) & ( TermSymbolsOf B8 ) c= ( OwnSymbolsOf B8 ) & ( OpSymbolsOf B8 ) c= ( LowerCompoundersOf B8 ) & ( LowerCompoundersOf B8 ) c= ( AtomicFormulaSymbolsOf B8 )))
proof
let C26 being Language;
set D36 = (the OneF of C26);
set D37 = (the ZeroF of C26);
set D38 = (the adicity of C26);
set D39 = ( RelSymbolsOf C26 );
set D40 = ( OwnSymbolsOf C26 );
set D41 = ( AllSymbolsOf C26 );
set D42 = ( TheEqSymbOf C26 );
set D43 = ( TheNorSymbOf C26 );
set D44 = ( AtomicFormulaSymbolsOf C26 );
set D45 = ( (the carrier of C26) \ { D36 } );
set D46 = ( LowerCompoundersOf C26 );
set D47 = ( TermSymbolsOf C26 );
set D48 = ( OpSymbolsOf C26 );
set D49 = ( LettersOf C26 );
L84: { ( 0 ) } misses ( ( NAT ) \ { ( 0 ) } ) by XBOOLE_1:79;
thus L85: ( D49 /\ D48 ) = ( D38 " ( { ( 0 ) } /\ ( ( NAT ) \ { ( 0 ) } ) ) ) by FUNCT_1:68
.= ( D38 " ( {} ) ) by L84 , XBOOLE_0:def 7
.= ( {} );
thus L86: ( D47 /\ D46 ) = ( D38 " ( ( NAT ) /\ ( ( INT ) \ { ( 0 ) } ) ) ) by FUNCT_1:68
.= ( D38 " ( ( ( NAT ) /\ ( INT ) ) \ { ( 0 ) } ) ) by XBOOLE_1:49
.= D48 by XBOOLE_1:7 , XBOOLE_1:28;
L87: ( TheEqSymbOf C26 ) in D39 by L15;
L88: D40 = ( D41 \ ( { D37 } \/ { D36 } ) ) by ENUMSET1:1
.= ( D45 \ { D37 } ) by XBOOLE_1:41;
L89: ( D39 \ D40 ) = ( ( D39 \ D45 ) \/ ( D39 /\ { D37 } ) ) by L88 , XBOOLE_1:52
.= ( ( {} ) \/ ( D39 /\ { D37 } ) )
.= { D37 } by L87 , ZFMISC_1:46;
thus L90: ( D39 \ D40 ) = { ( TheEqSymbOf C26 ) } by L89;
thus L91: ( OwnSymbolsOf C26 ) c= ( AtomicFormulaSymbolsOf C26 ) by XBOOLE_1:34 , ZFMISC_1:7;
L92: (( D38 " { ( 0 ) } ) c= ( D38 " ( NAT ) ) & ( RelSymbolsOf C26 ) = ( ( D38 " ( INT ) ) \ ( D38 " ( NAT ) ) ) & ( LowerCompoundersOf C26 ) = ( ( D38 " ( INT ) ) \ ( D38 " { ( 0 ) } ) )) by FUNCT_1:69 , RELAT_1:143;
thus L93: ( RelSymbolsOf C26 ) c= ( LowerCompoundersOf C26 ) by L92 , XBOOLE_1:34;
L94: ( OpSymbolsOf C26 ) = ( ( D38 " ( NAT ) ) \ ( D38 " { ( 0 ) } ) ) by FUNCT_1:69;
thus L95: ( OpSymbolsOf C26 ) c= ( TermSymbolsOf C26 ) by L94;
thus L96: ( LettersOf C26 ) c= ( TermSymbolsOf C26 ) by RELAT_1:143;
L97: ( - 2 ) = ( D38 . ( TheEqSymbOf C26 ) ) by L56
.= ( D38 . D37 );
L98: (not ( D38 . D37 ) in ( NAT )) by L97;
L99: (not D37 in ( D38 " ( NAT ) )) by L98 , FUNCT_1:def 7;
L100: (( D38 " ( NAT ) ) misses { D37 } & ( D38 " ( NAT ) ) c= ( (the carrier of C26) \ { D36 } )) by L99 , ZFMISC_1:50;
L101: ( D38 " ( NAT ) ) c= ( ( (the carrier of C26) \ { D36 } ) \ { D37 } ) by L100 , XBOOLE_1:86;
L102: ( TermSymbolsOf C26 ) c= ( (the carrier of C26) \ ( { D36 } \/ { D37 } ) ) by L101 , XBOOLE_1:41;
thus L103: ( TermSymbolsOf C26 ) c= ( OwnSymbolsOf C26 ) by L102 , ENUMSET1:1;
L104: (for R9 being set holds (R9 in ( NAT ) implies R9 in ( INT ))) by INT_1:def 2;
L105: ( NAT ) c= ( INT ) by L104 , TARSKI:def 3;
L106: ( ( NAT ) \ { ( 0 ) } ) c= ( ( INT ) \ { ( 0 ) } ) by L105 , XBOOLE_1:33;
thus L107: ( OpSymbolsOf C26 ) c= ( LowerCompoundersOf C26 ) by L106 , RELAT_1:143;
thus L108: thesis;
end;
registration
let C27 being Language;
cluster ( TermSymbolsOf C27 ) -> non  empty for set;
coherence
proof
L109: ( LettersOf C27 ) c= ( TermSymbolsOf C27 ) by L83;
thus L110: thesis by L109;
end;
cluster  own ->  ofAtomicFormula for (Element of C27);
coherence
proof
let C28 being (Element of C27);
assume L111: C28 is  own;
L112: (C28 in ( OwnSymbolsOf C27 ) & ( OwnSymbolsOf C27 ) c= ( AtomicFormulaSymbolsOf C27 )) by L111 , L83 , L17;
thus L113: thesis by L112 , L18;
end;
cluster  relational ->  low-compounding for (Element of C27);
coherence
proof
let C29 being (Element of C27);
assume L114: C29 is  relational;
L115: (C29 in ( RelSymbolsOf C27 ) & ( RelSymbolsOf C27 ) c= ( LowerCompoundersOf C27 )) by L114 , L15 , L83;
thus L116: C29 is  low-compounding by L115 , L13;
end;
cluster  operational ->  termal for (Element of C27);
coherence
proof
let C30 being (Element of C27);
assume L117: C30 is  operational;
L118: (C30 in ( OpSymbolsOf C27 ) & ( OpSymbolsOf C27 ) c= ( TermSymbolsOf C27 )) by L117 , L83 , L14;
thus L119: thesis by L118 , L16;
end;
cluster  literal ->  termal for (Element of C27);
coherence
proof
let C31 being (Element of C27);
assume L120: C31 is  literal;
L121: (( LettersOf C27 ) c= ( TermSymbolsOf C27 ) & C31 in ( LettersOf C27 )) by L120 , L12 , L83;
thus L122: thesis by L121 , L16;
end;
cluster  termal ->  own for (Element of C27);
coherence
proof
let C32 being (Element of C27);
assume L123: C32 is  termal;
L124: (( TermSymbolsOf C27 ) c= ( OwnSymbolsOf C27 ) & C32 in ( TermSymbolsOf C27 )) by L123 , L16 , L83;
thus L125: thesis by L124 , L17;
end;
cluster  operational ->  low-compounding for (Element of C27);
coherence
proof
let C33 being (Element of C27);
assume L126: C33 is  operational;
L127: (C33 in ( OpSymbolsOf C27 ) & ( OpSymbolsOf C27 ) c= ( LowerCompoundersOf C27 )) by L126 , L14 , L83;
thus L128: thesis by L127 , L13;
end;
cluster  low-compounding ->  ofAtomicFormula for (Element of C27);
coherence
proof
let C34 being (Element of C27);
assume L129: C34 is  low-compounding;
L130: (C34 in ( LowerCompoundersOf C27 ) & ( LowerCompoundersOf C27 ) c= ( AtomicFormulaSymbolsOf C27 )) by L129 , L13;
thus L131: thesis by L130 , L18;
end;
cluster  termal -> non  relational for (Element of C27);
coherence
proof
set D50 = ( TermSymbolsOf C27 );
set D51 = ( RelSymbolsOf C27 );
set D52 = (the adicity of C27);
L132: ( D50 /\ D51 ) = ( D52 " ( ( NAT ) /\ ( ( INT ) \ ( NAT ) ) ) ) by FUNCT_1:68
.= ( D52 " ( ( ( NAT ) /\ ( INT ) ) \ ( ( NAT ) /\ ( NAT ) ) ) )
.= ( D52 " ( {} ) )
.= ( {} );
L133: D50 misses D51 by L132 , XBOOLE_0:def 7;
L134: ( D50 \ D51 ) = D50 by L133 , XBOOLE_1:83;
let C35 being (Element of C27);
assume L135: C35 is  termal;
L136: C35 in ( D50 \ D51 ) by L135 , L134 , L16;
L137: (not C35 in D51) by L136 , XBOOLE_0:def 5;
thus L138: thesis by L137 , L15;
end;
cluster  literal -> non  relational for (Element of C27);
coherence;
cluster  literal -> non  operational for (Element of C27);
coherence
proof
set D53 = ( LettersOf C27 );
set D54 = ( OpSymbolsOf C27 );
let C36 being (Element of C27);
assume L139: C36 is  literal;
assume L140: C36 is  operational;
L141: (C36 in D53 & C36 in D54) by L140 , L139 , L12 , L14;
L142: C36 in ( D53 /\ D54 ) by L141 , XBOOLE_0:def 4;
thus L143: contradiction by L142 , L83;
end;
end;
registration
let C37 being Language;
cluster  relational for (Element of C37);
existence
proof
take D55 = ( TheEqSymbOf C37 );
thus L145: thesis;
end;
cluster  literal for (Element of C37);
existence
proof
take the (Element of ( LettersOf C37 ));
thus L146: thesis by L12;
end;
end;
registration
let C38 being Language;
cluster  termal ->  operational for  low-compounding  low-compounding  low-compounding  low-compounding (Element of C38);
coherence
proof
set D56 = ( LowerCompoundersOf C38 );
set D57 = ( TermSymbolsOf C38 );
set D58 = ( OpSymbolsOf C38 );
let C39 being  low-compounding (Element of C38);
L148: C39 in D56 by L13;
assume L149: C39 is  termal;
L150: C39 in D57 by L149 , L16;
L151: C39 in ( D56 /\ D57 ) by L150 , L148 , XBOOLE_0:def 4;
L152: C39 in D58 by L151 , L83;
thus L153: thesis by L152 , L14;
end;
end;
registration
let C40 being Language;
cluster  ofAtomicFormula for (Element of C40);
existence
proof
take the  literal (Element of C40);
thus L155: thesis;
end;
end;
definition
let C41 being Language;
let C42 being  ofAtomicFormula (Element of C41);
func ar C42 -> (Element of ( INT )) equals 
( (the adicity of C41) . C42 );
coherence
proof
set D59 = (the adicity of C41);
reconsider D60 = D59 as (Function of ( AtomicFormulaSymbolsOf C41 ) , ( INT ));
reconsider D61 = C42 as (Element of ( AtomicFormulaSymbolsOf C41 )) by L18;
L157: ( D60 . D61 ) in ( INT );
thus L158: thesis by L157;
end;
end;
registration
let C43 being Language;
let C44 being  literal (Element of C43);
cluster ( ar C44 ) ->  zero for number;
coherence
proof
set D62 = (the adicity of C43);
L160: C44 in ( LettersOf C43 ) by L12;
L161: ( D62 . C44 ) in { ( 0 ) } by L160 , FUNCT_1:def 7;
thus L162: thesis by L161;
end;
end;
definition
let C45 being Language;
func C45 -cons -> (BinOp of ( ( AllSymbolsOf C45 ) * )) equals 
( ( AllSymbolsOf C45 ) -concatenation );
coherence;
end;
definition
let C46 being Language;
func C46 -multiCat -> (Function of ( ( ( AllSymbolsOf C46 ) * ) * ) , ( ( AllSymbolsOf C46 ) * )) equals 
( ( AllSymbolsOf C46 ) -multiCat );
coherence;
end;
definition
let C47 being Language;
func C47 -firstChar -> (Function of ( ( ( AllSymbolsOf C47 ) * ) \ { ( {} ) } ) , ( AllSymbolsOf C47 )) equals 
( ( AllSymbolsOf C47 ) -firstChar );
coherence;
end;
definition
let C48 being Language;
let C49 being set;
attr C49 is C48 -prefix
means
:L167: C49 is ( AllSymbolsOf C48 ) -prefix;
end;
registration
let C50 being Language;
cluster C50 -prefix -> ( AllSymbolsOf C50 ) -prefix for set;
coherence by L167;
cluster ( AllSymbolsOf C50 ) -prefix -> C50 -prefix for set;
coherence by L167;
end;
definition
let C51 being Language;
mode string of C51
 is (Element of ( ( ( AllSymbolsOf C51 ) * ) \ { ( {} ) } ));
end;
registration
let R12 being Language;
cluster ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } ) -> non  empty for set;
coherence;
end;
registration
let R12 being Language;
cluster  -> non  empty for (string of R12);
coherence by FOMODEL0:5;
end;
registration
cluster  ->  infinite for Language;
coherence
proof
let C52 being Language;
set D63 = ( AllSymbolsOf C52 );
set D64 = ( LettersOf C52 );
reconsider D65 = C52 as 1-sorted;
L173: ( D64 \/ D63 ) = D63 by XBOOLE_1:12;
thus L174: thesis by L173;
end;
end;
registration
let C53 being Language;
cluster ( AllSymbolsOf C53 ) ->  infinite;
coherence;
end;
definition
let C54 being Language;
let C55 being  ofAtomicFormula (Element of C54);
let C56 being set;
func Compound (C55 , C56) equals 
{ ( <* C55 *> ^ ( ( C54 -multiCat ) . B9 ) ) where B9 is (Element of ( ( ( AllSymbolsOf C54 ) * ) * )) : (( rng B9 ) c= C56 & B9 is ( abs ( ar C55 ) ) -element) };
coherence;
end;
definition
let C57 being Language;
let C58 being  ofAtomicFormula (Element of C57);
let C59 being set;
redefine func Compound (C58 , C59) -> (Element of ( bool ( ( ( AllSymbolsOf C57 ) * ) \ { ( {} ) } ) ));

coherence
proof
set D66 = ( Compound (C58 , C59) );
set D67 = ( AllSymbolsOf C57 );
reconsider D68 = C58 as (Element of D67);
L178:
now
let C60 being set;
assume L179: C60 in D66;
consider C61 being (Element of ( ( D67 * ) * )) such that L180: (C60 = ( <* C58 *> ^ ( ( C57 -multiCat ) . C61 ) ) & ( rng C61 ) c= C59 & C61 is ( abs ( ar C58 ) ) -element) by L179;
reconsider D69 = <* D68 *> as non  empty (FinSequence of D67);
reconsider D70 = ( ( C57 -multiCat ) . C61 ) as (FinSequence of D67) by FINSEQ_1:def 11;
L181: (( D69 ^ D70 ) is non  empty non  empty non  empty non  empty (FinSequence of D67) & C60 = ( D69 ^ D70 )) by L180;
thus L182: C60 in ( ( D67 * ) \ { ( {} ) } ) by L181 , FOMODEL0:5;
end;
thus L183: thesis by L178 , TARSKI:def 3;
end;
end;
definition
let C62 being Language;
func C62 -termsOfMaxDepth -> Function means 
:L185: (( dom it ) = ( NAT ) & ( it . ( 0 ) ) = ( AtomicTermsOf C62 ) & (for B10 being Nat holds ( it . ( B10 + 1 ) ) = ( ( union { ( Compound (B11 , ( it . B10 )) ) where B11 is  ofAtomicFormula (Element of C62) : B11 is  operational } ) \/ ( it . B10 ) )));
existence
proof
deffunc H2(set , set) = ( ( union { ( Compound (B12 , $2) ) where B12 is  ofAtomicFormula (Element of C62) : B12 is  operational } ) \/ $2 );
L186: (ex B13 being Function st (( dom B13 ) = ( NAT ) & ( B13 . ( 0 ) ) = ( AtomicTermsOf C62 ) & (for B14 being Nat holds ( B13 . ( B14 + 1 ) ) = H2(B14 , ( B13 . B14 ))))) from NAT_1:sch 11;
thus L187: thesis by L186;
end;
uniqueness
proof
deffunc H3(set , set) = ( ( union { ( Compound (B15 , $2) ) where B15 is  ofAtomicFormula (Element of C62) : B15 is  operational } ) \/ $2 );
let C63 , C64 being Function;
assume L188: (( dom C63 ) = ( NAT ) & ( C63 . ( 0 ) ) = ( AtomicTermsOf C62 ) & (for B16 being Nat holds ( C63 . ( B16 + 1 ) ) = H3(B16 , ( C63 . B16 ))));
L189: ( dom C63 ) = ( NAT ) by L188;
L190: ( C63 . ( 0 ) ) = ( AtomicTermsOf C62 ) by L188;
L191: (for B17 being Nat holds ( C63 . ( B17 + 1 ) ) = H3(B17 , ( C63 . B17 ))) by L188;
assume L192: (( dom C64 ) = ( NAT ) & ( C64 . ( 0 ) ) = ( AtomicTermsOf C62 ) & (for B18 being Nat holds ( C64 . ( B18 + 1 ) ) = H3(B18 , ( C64 . B18 ))));
L193: ( dom C64 ) = ( NAT ) by L192;
L194: ( C64 . ( 0 ) ) = ( AtomicTermsOf C62 ) by L192;
L195: (for B19 being Nat holds ( C64 . ( B19 + 1 ) ) = H3(B19 , ( C64 . B19 ))) by L192;
thus L196: C63 = C64 from NAT_1:sch 15(L189 , L190 , L191 , L193 , L194 , L195);
end;
end;
definition
let R12 being Language;
redefine func AtomicTermsOf R12 -> (Subset of ( ( AllSymbolsOf R12 ) * ));

coherence
proof
set D71 = ( AllSymbolsOf R12 );
set D72 = ( AtomicTermsOf R12 );
reconsider D73 = ( LettersOf R12 ) as (Subset of D71);
L198: D72 c= ( D73 * ) by FINSEQ_2:134;
thus L199: thesis by L198 , XBOOLE_1:1;
end;
end;
L201: (for R2 being Nat holds (for R12 being Language holds ( ( R12 -termsOfMaxDepth ) . R2 ) c= ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } )))
proof
let R2 being Nat;
let R12 being Language;
set D74 = ( R12 -termsOfMaxDepth );
set D75 = ( AllSymbolsOf R12 );
set D76 = ( LettersOf R12 );
defpred S1[ Nat ] means ( D74 . $1 ) c= ( ( D75 * ) \ { ( {} ) } );
L202: S1[ ( 0 ) ]
proof
L203: ( D74 . ( 0 ) ) = ( AtomicTermsOf R12 ) by L185
.= ( ( ( 0 ) + 1 ) -tuples_on D76 );
L204: ( D74 . ( 0 ) ) c= ( ( D76 * ) \ { ( {} ) } ) by L203 , FOMODEL0:9;
L205: ( ( D76 * ) \ { ( {} ) } ) c= ( ( D75 * ) \ { ( {} ) } ) by XBOOLE_1:33;
thus L206: thesis by L205 , L204 , XBOOLE_1:1;
end;
L207: (for B20 being Nat holds (S1[ B20 ] implies S1[ ( B20 + 1 ) ]))
proof
let C65 being Nat;
assume L208: S1[ C65 ];
set D77 = { ( Compound (B21 , ( D74 . C65 )) ) where B21 is  ofAtomicFormula (Element of R12) : B21 is  operational };
L209:
now
let C66 being set;
assume L210: C66 in D77;
consider C67 being  ofAtomicFormula (Element of R12) such that L211: (C66 = ( Compound (C67 , ( D74 . C65 )) ) & C67 is  operational) by L210;
thus L212: C66 c= ( ( D75 * ) \ { ( {} ) } ) by L211;
end;
L213: (( union D77 ) c= ( ( D75 * ) \ { ( {} ) } ) & ( D74 . ( C65 + 1 ) ) = ( ( union D77 ) \/ ( D74 . C65 ) )) by L209 , L185 , ZFMISC_1:76;
thus L214: thesis by L213 , L208 , XBOOLE_1:8;
end;
L215: (for B22 being Nat holds S1[ B22 ]) from NAT_1:sch 2(L202 , L207);
thus L216: thesis by L215;
end;
L217: (for R2 being Nat holds (for R3 being Nat holds (for R12 being Language holds ( ( R12 -termsOfMaxDepth ) . R2 ) c= ( ( R12 -termsOfMaxDepth ) . ( R2 + R3 ) ))))
proof
let R2 being Nat;
let R3 being Nat;
let R12 being Language;
set D78 = ( R12 -termsOfMaxDepth );
defpred S2[ Nat ] means ( D78 . R2 ) c= ( D78 . ( R2 + $1 ) );
L218: S2[ ( 0 ) ];
L219: (for B23 being Nat holds (S2[ B23 ] implies S2[ ( B23 + 1 ) ]))
proof
let C68 being Nat;
assume L220: S2[ C68 ];
L221: ( D78 . ( ( R2 + C68 ) + 1 ) ) = ( ( D78 . ( R2 + C68 ) ) \/ ( union { ( Compound (B24 , ( D78 . ( R2 + C68 ) )) ) where B24 is  ofAtomicFormula (Element of R12) : B24 is  operational } ) ) by L185;
L222: ( D78 . ( R2 + C68 ) ) c= ( D78 . ( ( R2 + C68 ) + 1 ) ) by L221 , XBOOLE_1:7;
thus L223: thesis by L222 , L220 , XBOOLE_1:1;
end;
L224: (for B25 being Nat holds S2[ B25 ]) from NAT_1:sch 2(L218 , L219);
thus L225: thesis by L224;
end;
definition
let C69 being Language;
func AllTermsOf C69 equals 
( union ( rng ( C69 -termsOfMaxDepth ) ) );
coherence;
end;
theorem
L227: (for R5 being (Element of ( NAT )) holds (for R12 being Language holds ( ( R12 -termsOfMaxDepth ) . R5 ) c= ( AllTermsOf R12 )))
proof
let R5 being (Element of ( NAT ));
let R12 being Language;
set D79 = ( R12 -termsOfMaxDepth );
L228: ( dom D79 ) = ( NAT ) by L185;
thus L229: thesis by L228 , FUNCT_1:3 , ZFMISC_1:74;
end;
L230: (for R9 being set holds (for R12 being Language holds (R9 in ( AllTermsOf R12 ) implies (ex R6 being (Element of ( NAT )) st R9 in ( ( R12 -termsOfMaxDepth ) . R6 )))))
proof
let R9 being set;
let R12 being Language;
set D80 = ( R12 -termsOfMaxDepth );
assume L231: R9 in ( AllTermsOf R12 );
consider C70 being set such that L232: (R9 in C70 & C70 in ( rng D80 )) by L231 , TARSKI:def 4;
consider C71 being set such that L233: (C71 in ( dom D80 ) & C70 = ( D80 . C71 )) by L232 , FUNCT_1:def 3;
reconsider D81 = C71 as (Element of ( NAT )) by L233 , L185;
take D82 = D81;
thus L234: thesis by L232 , L233;
end;
definition
let C72 being Language;
let C73 being (string of C72);
attr C73 is  termal
means
:L235: C73 in ( AllTermsOf C72 );
end;
definition
let C74 being Nat;
let C75 being Language;
let C76 being (string of C75);
attr C76 is C74 -termal
means
:L237: C76 in ( ( C75 -termsOfMaxDepth ) . C74 );
end;
registration
let C77 being Nat;
let C78 being Language;
cluster C77 -termal ->  termal for (string of C78);
coherence
proof
reconsider D83 = C77 as (Element of ( NAT )) by ORDINAL1:def 12;
let C79 being (string of C78);
assume L239: C79 is C77 -termal;
L240: (C79 in ( ( C78 -termsOfMaxDepth ) . C77 ) & ( ( C78 -termsOfMaxDepth ) . D83 ) c= ( AllTermsOf C78 )) by L239 , L227 , L237;
thus L241: thesis by L240 , L235;
end;
end;
definition
let R12 being Language;
redefine func R12 -termsOfMaxDepth -> (Function of ( NAT ) , ( bool ( ( AllSymbolsOf R12 ) * ) ));

coherence
proof
set D84 = ( AllSymbolsOf R12 );
set D85 = ( R12 -termsOfMaxDepth );
L243: ( dom D85 ) = ( NAT ) by L185;
L244:
now
let C80 being set;
assume L245: C80 in ( rng D85 );
consider C81 being set such that L246: (C81 in ( dom D85 ) & C80 = ( D85 . C81 )) by L245 , FUNCT_1:def 3;
reconsider D86 = C81 as (Element of ( NAT )) by L185 , L246;
L247: C80 = ( D85 . D86 ) by L246;
L248: (C80 c= ( ( D84 * ) \ { ( {} ) } ) & ( ( D84 * ) \ { ( {} ) } ) c= ( D84 * )) by L247 , L201;
L249: C80 c= ( D84 * ) by L248 , XBOOLE_1:1;
thus L250: C80 in ( bool ( D84 * ) ) by L249;
end;
L251: ( rng D85 ) c= ( bool ( D84 * ) ) by L244 , TARSKI:def 3;
thus L252: thesis by L251 , L243 , FUNCT_2:67 , RELSET_1:4;
end;
end;
definition
let R12 being Language;
redefine func AllTermsOf R12 -> non  empty (Subset of ( ( AllSymbolsOf R12 ) * ));

coherence
proof
set D87 = ( AllTermsOf R12 );
set D88 = ( R12 -termsOfMaxDepth );
set D89 = ( AllSymbolsOf R12 );
L254:
now
let C82 being set;
assume L255: C82 in D87;
consider C83 being (Element of ( NAT )) such that L256: C82 in ( D88 . C83 ) by L255 , L230;
thus L257: C82 in ( D89 * ) by L256;
end;
L258: D87 = ( ( D88 . ( 0 ) ) \/ D87 ) by L227 , XBOOLE_1:12
.= ( ( AtomicTermsOf R12 ) \/ D87 ) by L185;
thus L259: thesis by L258 , L254 , TARSKI:def 3;
end;
end;
registration
let R12 being Language;
cluster ( AllTermsOf R12 ) -> non  empty;
coherence;
end;
registration
let R12 being Language;
let R2 being Nat;
cluster ( ( R12 -termsOfMaxDepth ) . R2 ) -> non  empty;
coherence
proof
set D90 = ( R12 -termsOfMaxDepth );
set D91 = ( AtomicTermsOf R12 );
set D92 = ( AllSymbolsOf R12 );
set D93 = the (Element of D91);
L262: (D93 in D91 & D91 = ( D90 . ( 0 ) )) by L185;
L263: (D93 in ( D90 . ( 0 ) ) & ( D90 . ( 0 ) ) c= ( D90 . ( ( 0 ) + R2 ) )) by L262 , L217;
thus L264: ( D90 . R2 ) is non  empty by L263;
end;
end;
registration
let R12 being Language;
let R2 being Nat;
cluster  -> non  empty for (Element of ( ( R12 -termsOfMaxDepth ) . R2 ));
coherence
proof
set D94 = ( R12 -termsOfMaxDepth );
set D95 = ( AllSymbolsOf R12 );
set D96 = ( AtomicTermsOf R12 );
L266: ( D94 . R2 ) c= ( ( D95 * ) \ { ( {} ) } ) by L201;
let C84 being (Element of ( D94 . R2 ));
L267: C84 in ( ( D95 * ) \ { ( {} ) } ) by L266 , TARSKI:def 3;
thus L268: thesis by L267;
end;
end;
registration
let R12 being Language;
cluster  -> non  empty for (Element of ( AllTermsOf R12 ));
coherence
proof
set D97 = ( R12 -termsOfMaxDepth );
set D98 = ( AllSymbolsOf R12 );
set D99 = ( AtomicTermsOf R12 );
set D100 = ( AllTermsOf R12 );
let C85 being (Element of D100);
consider R5 being (Element of ( NAT )) such that L270: C85 in ( D97 . R5 ) by L230;
reconsider D101 = C85 as (Element of ( D97 . R5 )) by L270;
L271: D101 is non  empty;
thus L272: thesis by L271;
end;
end;
registration
let C86 being Nat;
let C87 being Language;
cluster C86 -termal for (string of C87);
existence
proof
set D102 = ( C87 -termsOfMaxDepth );
set D103 = ( AllSymbolsOf C87 );
set D104 = ( AtomicTermsOf C87 );
set D105 = the (Element of D104);
L274: D105 in D104;
L275: (D105 in ( D102 . ( 0 ) ) & ( D102 . ( 0 ) ) c= ( ( D103 * ) \ { ( {} ) } )) by L274 , L201 , L185;
reconsider D106 = D105 as (string of C87) by L275;
take D106;
L276: (D106 in ( D102 . ( 0 ) ) & ( D102 . ( 0 ) ) c= ( D102 . ( ( 0 ) + C86 ) )) by L217 , L274 , L185;
thus L277: thesis by L276 , L237;
end;
end;
registration
let R12 being Language;
cluster ( 0 ) -termal -> 1 -element for (string of R12);
coherence
proof
set D107 = ( AtomicTermsOf R12 );
set D108 = ( LettersOf R12 );
set D109 = ( R12 -termsOfMaxDepth );
let C88 being (string of R12);
assume L279: C88 is ( 0 ) -termal;
L280: C88 in ( D109 . ( 0 ) ) by L279 , L237;
L281: C88 in D107 by L280 , L185;
reconsider D110 = C88 as (Element of ( 1 -tuples_on D108 )) by L281;
L282: D110 is 1 -element;
thus L283: thesis by L282;
end;
end;
registration
let C89 being Language;
let C90 being ( 0 ) -termal (string of C89);
cluster ( ( C89 -firstChar ) . C90 ) ->  literal for (Element of C89);
coherence
proof
set D111 = ( AllTermsOf C89 );
set D112 = ( C89 -termsOfMaxDepth );
set D113 = ( AtomicTermsOf C89 );
set D114 = ( AllSymbolsOf C89 );
set D115 = ( ( C89 -firstChar ) . C90 );
set D116 = ( ( D114 -firstChar ) . C90 );
set D117 = ( LettersOf C89 );
reconsider D118 = C90 as non  empty (FinSequence of D114) by FOMODEL0:5;
L285: D116 = ( D118 . 1 ) by FOMODEL0:6;
L286: C90 in ( D112 . ( 0 ) ) by L237;
L287: C90 in D113 by L286 , L185;
consider R9 being set such that L288: (R9 in D117 & C90 = <* R9 *>) by L287 , FINSEQ_2:135;
L289: C90 = ( <* R9 *> ^ ( {} ) ) by L288;
L290: D116 in D117 by L289 , L288 , L285 , FINSEQ_1:41;
thus L291: thesis by L290 , L12;
end;
end;
L293: (for R5 being (Element of ( NAT )) holds (for R12 being Language holds (for B26 being ( R5 + 1 ) -termal (string of R12) holds ((not B26 is R5 -termal) implies (ex B27 being  termal (Element of R12) st (ex B28 being (Element of ( ( ( R12 -termsOfMaxDepth ) . R5 ) * )) st (B28 is ( abs ( ar B27 ) ) -element & B26 = ( <* B27 *> ^ ( ( R12 -multiCat ) . B28 ) ))))))))
proof
let R5 being (Element of ( NAT ));
let R12 being Language;
set D119 = { ( Compound (B29 , ( ( R12 -termsOfMaxDepth ) . R5 )) ) where B29 is  ofAtomicFormula (Element of R12) : B29 is  operational };
let C91 being ( R5 + 1 ) -termal (string of R12);
assume L294: (not C91 is R5 -termal);
L295: (C91 in ( ( R12 -termsOfMaxDepth ) . ( R5 + 1 ) ) & (not C91 in ( ( R12 -termsOfMaxDepth ) . R5 ))) by L294 , L237;
L296: (C91 in ( ( union D119 ) \/ ( ( R12 -termsOfMaxDepth ) . R5 ) ) & (not C91 in ( ( R12 -termsOfMaxDepth ) . R5 ))) by L295 , L185;
L297: C91 in ( union D119 ) by L296 , XBOOLE_0:def 3;
consider C92 being set such that L298: (C91 in C92 & C92 in D119) by L297 , TARSKI:def 4;
consider C93 being  ofAtomicFormula (Element of R12) such that L299: (C92 = ( Compound (C93 , ( ( R12 -termsOfMaxDepth ) . R5 )) ) & C93 is  operational) by L298;
reconsider D120 = C93 as  termal (Element of R12) by L299;
take D121 = D120;
consider C94 being (Element of ( ( ( AllSymbolsOf R12 ) * ) * )) such that L300: (C91 = ( <* D121 *> ^ ( ( R12 -multiCat ) . C94 ) ) & ( rng C94 ) c= ( ( R12 -termsOfMaxDepth ) . R5 ) & C94 is ( abs ( ar D120 ) ) -element) by L298 , L299;
reconsider D122 = C94 as (FinSequence of ( ( R12 -termsOfMaxDepth ) . R5 )) by L300 , FINSEQ_1:def 4;
reconsider D123 = D122 as (Element of ( ( ( R12 -termsOfMaxDepth ) . R5 ) * )) by FINSEQ_1:def 11;
take D124 = D123;
thus L301: D124 is ( abs ( ar D121 ) ) -element by L300;
thus L302: thesis by L300;
end;
L303: (for R5 being (Element of ( NAT )) holds (for R12 being Language holds (for B30 being ( R5 + 1 ) -termal (string of R12) holds (ex B31 being  termal (Element of R12) st (ex B32 being (Element of ( ( ( R12 -termsOfMaxDepth ) . R5 ) * )) st (B32 is ( abs ( ar B31 ) ) -element & B30 = ( <* B31 *> ^ ( ( R12 -multiCat ) . B32 ) )))))))
proof
let R5 being (Element of ( NAT ));
let R12 being Language;
set D125 = ( TermSymbolsOf R12 );
set D126 = ( R12 -termsOfMaxDepth );
set D127 = ( R12 -multiCat );
set D128 = ( LettersOf R12 );
defpred S3[ (Element of ( NAT )) ] means (for B33 being ( $1 + 1 ) -termal (string of R12) holds (ex B34 being  termal (Element of R12) st (ex B35 being (Element of ( ( ( R12 -termsOfMaxDepth ) . $1 ) * )) st (B35 is ( abs ( ar B34 ) ) -element & B33 = ( <* B34 *> ^ ( ( R12 -multiCat ) . B35 ) )))));
defpred S4[ Nat ] means (ex B36 being (Element of ( NAT )) st (B36 = $1 & S3[ B36 ]));
L304: S4[ ( 0 ) ]
proof
take ( 0 );
thus L305: ( 0 ) = ( 0 );
thus L306: S3[ ( 0 ) ]
proof
let C95 being ( ( 0 ) + 1 ) -termal (string of R12);
per cases ;
suppose L307: C95 is ( 0 ) -termal;

L308: C95 in ( ( R12 -termsOfMaxDepth ) . ( 0 ) ) by L307 , L237;
L309: C95 in ( AtomicTermsOf R12 ) by L308 , L185;
L310: C95 in { <* B37 *> where B37 is (Element of ( LettersOf R12 )) : (not contradiction) } by L309 , FINSEQ_2:96;
consider C96 being (Element of ( LettersOf R12 )) such that L311: (C95 = <* C96 *> & (not contradiction)) by L310;
reconsider D129 = C96 as  literal (Element of R12) by L12;
reconsider D130 = ( {} ) as FinSequence;
L312: ( rng D130 ) = ( {} );
L313: ( rng D130 ) c= ( ( R12 -termsOfMaxDepth ) . ( 0 ) ) by L312 , XBOOLE_1:2;
reconsider D131 = D130 as (FinSequence of ( ( R12 -termsOfMaxDepth ) . ( 0 ) )) by L313 , FINSEQ_1:def 4;
reconsider D132 = D131 as (Element of ( ( ( R12 -termsOfMaxDepth ) . ( 0 ) ) * )) by FINSEQ_1:def 11;
take D133 = D129;
take D134 = D132;
thus L314: D134 is ( abs ( ar D133 ) ) -element;
reconsider D135 = D129 as (Element of D125) by L16;
L315: (( ( R12 -multiCat ) . ( {} ) ) = ( {} ) & ( <* D129 *> ^ ( {} ) ) = <* D129 *>);
thus L316: thesis by L315 , L311;
end;
suppose L317: C95 is non ( 0 ) -termal;

thus L318: thesis by L317 , L293;
end;
end;

end;
L307: (for B38 being Nat holds (S4[ B38 ] implies S4[ ( B38 + 1 ) ]))
proof
let C97 being Nat;
reconsider D136 = C97 , D137 = ( C97 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L308: S4[ C97 ];
take D137;
thus L309: D137 = ( C97 + 1 );
let C98 being ( D137 + 1 ) -termal (string of R12);
per cases ;
suppose L310: (not C98 is D137 -termal);

thus L311: thesis by L310 , L293;
end;
suppose L312: C98 is D137 -termal;

consider C99 being  termal (Element of R12), C100 being (Element of ( ( ( R12 -termsOfMaxDepth ) . D136 ) * )) such that L313: (C100 is ( abs ( ar C99 ) ) -element & C98 = ( <* C99 *> ^ ( ( R12 -multiCat ) . C100 ) )) by L312 , L308;
set D138 = ( ( R12 -termsOfMaxDepth ) . D137 );
reconsider D139 = ( ( R12 -termsOfMaxDepth ) . D136 ) as (Subset of D138) by L217;
L314: (C100 in ( D139 * ) & ( D139 * ) is (Subset of ( D138 * )));
reconsider D140 = C100 as (Element of ( D138 * )) by L314;
take C99;
take D140;
thus L315: thesis by L313;
end;
end;
L317: (for B39 being Nat holds S4[ B39 ]) from NAT_1:sch 2(L304 , L307);
L318:
now
let C101 being (Element of ( NAT ));
reconsider D141 = C101 as Nat;
consider C102 being (Element of ( NAT )) such that L319: (C102 = D141 & S3[ C102 ]) by L317;
thus L320: S3[ C101 ] by L319;
end;
thus L321: thesis by L318;
end;
registration
let R12 being Language;
let C103 being  termal (string of R12);
cluster ( ( R12 -firstChar ) . C103 ) ->  termal for (Element of R12);
coherence
proof
set D142 = ( AllTermsOf R12 );
set D143 = ( R12 -termsOfMaxDepth );
set D144 = ( AtomicTermsOf R12 );
set D145 = ( AllSymbolsOf R12 );
set D146 = ( ( R12 -firstChar ) . C103 );
set D147 = ( ( D145 -firstChar ) . C103 );
set D148 = ( LettersOf R12 );
L322: C103 in D142 by L235;
consider R5 being (Element of ( NAT )) such that L323: C103 in ( D143 . R5 ) by L322 , L230;
reconsider D149 = C103 as non  empty (FinSequence of D145) by FOMODEL0:5;
L324: D147 = ( D149 . 1 ) by FOMODEL0:6;
per cases ;
suppose L325: R5 = ( 0 );

reconsider D150 = C103 as ( 0 ) -termal (string of R12) by L325 , L237 , L323;
L326: ( ( R12 -firstChar ) . D150 ) is  literal;
thus L327: thesis by L326;
end;
suppose L328: R5 <> ( 0 );

consider C104 being Nat such that L329: R5 = ( C104 + 1 ) by L328 , NAT_1:6;
reconsider D151 = C104 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D152 = C103 as ( D151 + 1 ) -termal (string of R12) by L329 , L323 , L237;
consider C105 being  termal (Element of R12), C106 being (Element of ( ( D143 . D151 ) * )) such that L330: (C106 is ( abs ( ar C105 ) ) -element & D152 = ( <* C105 *> ^ ( ( R12 -multiCat ) . C106 ) )) by L303;
thus L331: thesis by L330 , L324 , FINSEQ_1:41;
end;
end;
end;
definition
let R12 being Language;
let C107 being  termal (string of R12);
func ar C107 -> (Element of ( INT )) equals 
( ar ( ( R12 -firstChar ) . C107 ) );
coherence;
end;
theorem
L335: (for R5 being (Element of ( NAT )) holds (for R12 being Language holds (for B40 being ( R5 + 1 ) -termal (string of R12) holds (ex B41 being (Element of ( ( ( R12 -termsOfMaxDepth ) . R5 ) * )) st (B41 is ( abs ( ar ( ( R12 -firstChar ) . B40 ) ) ) -element & B40 = ( <* ( ( R12 -firstChar ) . B40 ) *> ^ ( ( R12 -multiCat ) . B41 ) ))))))
proof
let R5 being (Element of ( NAT ));
let R12 being Language;
let C108 being ( R5 + 1 ) -termal (string of R12);
consider C109 being  termal (Element of R12), C110 being (Element of ( ( ( R12 -termsOfMaxDepth ) . R5 ) * )) such that L336: (C110 is ( abs ( ar C109 ) ) -element & C108 = ( <* C109 *> ^ ( ( R12 -multiCat ) . C110 ) )) by L303;
reconsider D153 = C108 as non  empty (FinSequence of ( AllSymbolsOf R12 )) by FINSEQ_1:def 11;
L337: C109 = ( C108 . 1 ) by L336 , FINSEQ_1:41
.= ( ( R12 -firstChar ) . C108 ) by FOMODEL0:6;
thus L338: thesis by L337 , L336;
end;
L339: (for R2 being Nat holds (for R12 being Language holds ( ( R12 -termsOfMaxDepth ) . R2 ) is R12 -prefix))
proof
let R2 being Nat;
let R12 being Language;
set D154 = ( R12 -termsOfMaxDepth );
set D155 = ( AllSymbolsOf R12 );
set D156 = ( LettersOf R12 );
set D157 = ( 1 -tuples_on D155 );
set D158 = ( R12 -cons );
set D159 = ( R12 -multiCat );
set D160 = ( D155 -concatenation );
set D161 = ( D155 -multiCat );
L340: ( dom D161 ) = ( ( D155 * ) * ) by FUNCT_2:def 1;
reconsider D162 = D156 as non  empty (Subset of D155);
set D163 = ( 1 -tuples_on D162 );
defpred S5[ Nat ] means ( D154 . $1 ) is R12 -prefix;
L341: S5[ ( 0 ) ]
proof
L342: ( D163 /\ D157 ) = ( 1 -tuples_on ( D162 /\ D155 ) ) by FOMODEL0:3
.= ( 1 -tuples_on D162 ) by XBOOLE_1:28;
reconsider D164 = ( 1 -tuples_on D162 ) as (Subset of D157) by L342;
L343: ( D154 . ( 0 ) ) = ( AtomicTermsOf R12 ) by L185
.= D164;
thus L344: thesis by L343;
end;
L345: (for B42 being Nat holds (S5[ B42 ] implies S5[ ( B42 + 1 ) ]))
proof
let C111 being Nat;
assume L346: S5[ C111 ];
reconsider D165 = C111 , D166 = ( C111 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
L347:
now
let C112 , C113 , C114 , C115 being set;
assume L348: (C112 in ( ( D154 . ( C111 + 1 ) ) /\ ( D155 * ) ) & C113 in ( ( D154 . ( C111 + 1 ) ) /\ ( D155 * ) ) & C114 in ( D155 * ) & C115 in ( D155 * ));
L349: (C112 in ( D154 . D166 ) & (not C112 in { ( {} ) }) & C113 in ( D154 . D166 ) & (not C113 in { ( {} ) })) by L348;
reconsider D167 = C112 , D168 = C113 as ( D165 + 1 ) -termal (string of R12) by L349 , L237 , XBOOLE_0:def 5;
reconsider D169 = D167 , D170 = D168 as (FinSequence of D155) by FINSEQ_1:def 11;
consider C116 being (Element of ( ( D154 . D165 ) * )) such that L350: (C116 is ( abs ( ar ( ( R12 -firstChar ) . D167 ) ) ) -element & D167 = ( <* ( ( R12 -firstChar ) . D167 ) *> ^ ( D159 . C116 ) )) by L335;
consider C117 being (Element of ( ( D154 . D165 ) * )) such that L351: (C117 is ( abs ( ar ( ( R12 -firstChar ) . D168 ) ) ) -element & D168 = ( <* ( ( R12 -firstChar ) . D168 ) *> ^ ( D159 . C117 ) )) by L335;
reconsider D171 = C116 , D172 = C117 as (FinSequence of ( D154 . D165 )) by FINSEQ_1:def 11;
reconsider D173 = C114 , D174 = C115 as (Element of ( D155 * )) by L348;
reconsider D175 = ( D159 . C116 ) , D176 = ( D159 . C117 ) , D177 = D173 , D178 = D174 as (FinSequence of D155) by FINSEQ_1:def 11;
assume L352: ( D158 . (C112 , C114) ) = ( D158 . (C113 , C115) );
L353: ( D169 ^ D173 ) = ( D158 . (D170 , D174) ) by L352 , FOMODEL0:4;
L354: ( ( <* ( ( R12 -firstChar ) . D167 ) *> ^ ( D159 . C116 ) ) ^ D173 ) = ( D170 ^ D174 ) by L353 , L350 , FOMODEL0:4;
L355: ( <* ( ( R12 -firstChar ) . D167 ) *> ^ ( ( D159 . C116 ) ^ D173 ) ) = ( ( <* ( ( R12 -firstChar ) . D168 ) *> ^ ( D159 . C117 ) ) ^ D174 ) by L354 , L351 , FINSEQ_1:32;
L356: ( <* ( ( R12 -firstChar ) . D167 ) *> ^ ( D175 ^ D177 ) ) = ( <* ( ( R12 -firstChar ) . D168 ) *> ^ ( D176 ^ D178 ) ) by L355 , FINSEQ_1:32;
L357: ( D158 . (<* ( ( R12 -firstChar ) . D167 ) *> , ( D175 ^ D177 )) ) = ( <* ( ( R12 -firstChar ) . D168 ) *> ^ ( D176 ^ D178 ) ) by L356 , FOMODEL0:4;
L358: ( 1 -tuples_on D155 ) c= ( 1 -tuples_on D155 );
reconsider D179 = ( 1 -tuples_on D155 ) as (Subset of ( 1 -tuples_on D155 )) by L358;
L359: D179 is D158 -unambiguous by FOMODEL0:def 3;
L360: ( D179 /\ ( D155 * ) ) = D179 by FINSEQ_2:134 , XBOOLE_1:28;
L361: (<* ( ( R12 -firstChar ) . D167 ) *> in ( D179 /\ ( D155 * ) ) & <* ( ( R12 -firstChar ) . D168 ) *> in ( D179 /\ ( D155 * ) ) & ( D175 ^ D177 ) in ( D155 * ) & ( D176 ^ D178 ) in ( D155 * ) & ( D158 . (<* ( ( R12 -firstChar ) . D167 ) *> , ( D175 ^ D177 )) ) = ( D158 . (<* ( ( R12 -firstChar ) . D168 ) *> , ( D176 ^ D178 )) )) by L360 , L357 , FOMODEL0:4;
L362: (<* ( ( R12 -firstChar ) . D167 ) *> = <* ( ( R12 -firstChar ) . D168 ) *> & ( D175 ^ D177 ) = ( D176 ^ D178 ) & ( D175 ^ D177 ) = ( D160 . (D175 , D177) )) by L361 , L359 , FOMODEL0:4 , FOMODEL0:def 9;
L363: ( ( R12 -firstChar ) . D167 ) = ( ( R12 -firstChar ) . D168 ) by L362 , FINSEQ_1:76;
set D180 = ( abs ( ar ( ( R12 -firstChar ) . D167 ) ) );
L364: (( len D171 ) = D180 & ( len D172 ) = D180) by L350 , L363 , L351 , CARD_1:def 7;
L365: (D171 in ( D180 -tuples_on ( D154 . C111 ) ) & D172 in ( D180 -tuples_on ( D154 . C111 ) ) & D171 in ( dom D161 ) & D172 in ( dom D161 )) by L364 , L340 , FINSEQ_2:133;
L366: (( D161 . D171 ) in ( D161 .: ( D180 -tuples_on ( D154 . C111 ) ) ) & ( D161 . D172 ) in ( D161 .: ( D180 -tuples_on ( D154 . C111 ) ) ) & ( D161 . C116 ) in ( D155 * ) & ( D161 . C117 ) in ( D155 * )) by L365 , FUNCT_1:def 6;
L367: (( D161 . C116 ) in ( ( D161 .: ( D180 -tuples_on ( D154 . C111 ) ) ) /\ ( D155 * ) ) & ( D161 . C117 ) in ( ( D161 .: ( D180 -tuples_on ( D154 . C111 ) ) ) /\ ( D155 * ) ) & D173 in ( D155 * ) & D174 in ( D155 * ) & ( D160 . (( D161 . C116 ) , D173) ) = ( D160 . (( D161 . C117 ) , D174) )) by L366 , L362 , FOMODEL0:4 , XBOOLE_0:def 4;
L368: (( D154 . C111 ) is D155 -prefix & (( D154 . C111 ) is D155 -prefix implies ( ( D155 -multiCat ) .: ( D180 -tuples_on ( D154 . C111 ) ) ) is D155 -prefix)) by L346 , L167;
L369: ( ( D155 -multiCat ) .: ( D180 -tuples_on ( D154 . C111 ) ) ) is D160 -unambiguous by L368 , FOMODEL0:def 3;
thus L370: (C112 = C113 & C114 = C115) by L369 , L350 , L351 , L362 , L367 , FOMODEL0:def 9;
end;
L371: ( D154 . ( C111 + 1 ) ) is D160 -unambiguous by L347 , FOMODEL0:def 9;
L372: ( D154 . ( C111 + 1 ) ) is D155 -prefix by L371 , FOMODEL0:def 3;
thus L373: thesis by L372;
end;
L374: (for B43 being Nat holds S5[ B43 ]) from NAT_1:sch 2(L341 , L345);
thus L375: thesis by L374;
end;
registration
let R12 being Language;
let R2 being Nat;
cluster ( ( R12 -termsOfMaxDepth ) . R2 ) -> R12 -prefix;
coherence by L339;
end;
registration
let R12 being Language;
let C118 being (Element of ( ( AllTermsOf R12 ) * ));
cluster ( ( R12 -multiCat ) . C118 ) ->  Relation-like;
coherence;
end;
registration
let R12 being Language;
let C119 being (Element of ( ( AllTermsOf R12 ) * ));
cluster ( ( R12 -multiCat ) . C119 ) ->  Function-like for Relation;
coherence;
end;
definition
let R12 being Language;
let C120 being (string of R12);
attr C120 is  0wff
means
:L379: (ex B44 being  relational (Element of R12) st (ex B45 being ( abs ( ar B44 ) ) -element (Element of ( ( AllTermsOf R12 ) * )) st C120 = ( <* B44 *> ^ ( ( R12 -multiCat ) . B45 ) )));
end;
registration
let R12 being Language;
cluster  0wff for (string of R12);
existence
proof
set D181 = ( AllSymbolsOf R12 );
set D182 = the  relational (Element of R12);
set D183 = the ( abs ( ar D182 ) ) -element (Element of ( ( AllTermsOf R12 ) * ));
reconsider D184 = D182 as (Element of D181);
reconsider D185 = ( ( R12 -multiCat ) . D183 ) as (FinSequence of D181) by FINSEQ_1:def 11;
reconsider D186 = ( <* D184 *> ^ D185 ) as (Element of ( ( D181 * ) \ { ( {} ) } )) by FOMODEL0:5;
take D186;
thus L381: thesis by L379;
end;
end;
registration
let R12 being Language;
let C121 being  0wff (string of R12);
cluster ( ( R12 -firstChar ) . C121 ) ->  relational for (Element of R12);
coherence
proof
set D187 = ( AllSymbolsOf R12 );
set D188 = ( AllTermsOf R12 );
set D189 = ( R12 -multiCat );
set D190 = ( R12 -firstChar );
consider C122 being  relational (Element of R12), C123 being ( abs ( ar C122 ) ) -element (Element of ( D188 * )) such that L383: C121 = ( <* C122 *> ^ ( D189 . C123 ) ) by L379;
reconsider D191 = C122 as (Element of D187);
reconsider D192 = <* D191 *> as (FinSequence of D187);
reconsider D193 = ( D189 . C123 ) as (FinSequence of D187) by FINSEQ_1:def 11;
L384: ( D190 . C121 ) = ( ( D192 ^ D193 ) . 1 ) by L383 , FOMODEL0:6
.= C122 by FINSEQ_1:41;
thus L385: thesis by L384;
end;
end;
definition
let R12 being Language;
func AtomicFormulasOf R12 equals 
{ B46 where B46 is (string of R12) : B46 is  0wff };
coherence;
end;
definition
let R12 being Language;
redefine func AtomicFormulasOf R12 -> (Subset of ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } ));

coherence
proof
set D194 = ( AllSymbolsOf R12 );
set D195 = ( AtomicFormulasOf R12 );
defpred S6[ (Element of ( ( D194 * ) \ { ( {} ) } )) ] means $1 is  0wff;
L388: { B47 where B47 is (Element of ( ( D194 * ) \ { ( {} ) } )) : S6[ B47 ] } is (Subset of ( ( D194 * ) \ { ( {} ) } )) from DOMAIN_1:sch 7;
thus L389: thesis by L388;
end;
end;
registration
let R12 being Language;
cluster ( AtomicFormulasOf R12 ) -> non  empty;
coherence
proof
set D196 = ( AtomicFormulasOf R12 );
set D197 = the  0wff (string of R12);
L391: D197 in D196;
thus L392: thesis by L391;
end;
end;
registration
let R12 being Language;
cluster  ->  0wff for (Element of ( AtomicFormulasOf R12 ));
coherence
proof
set D198 = ( AtomicFormulasOf R12 );
let C124 being (Element of D198);
L394: C124 in D198;
consider C125 being (string of R12) such that L395: (C124 = C125 & C125 is  0wff) by L394;
thus L396: thesis by L395;
end;
end;
L398: (for R12 being Language holds ( AllTermsOf R12 ) is R12 -prefix)
proof
let R12 being Language;
set D199 = ( AllSymbolsOf R12 );
set D200 = ( D199 -concatenation );
set D201 = ( D199 -multiCat );
set D202 = ( AllTermsOf R12 );
set D203 = ( R12 -termsOfMaxDepth );
L399:
now
let C126 , C127 , C128 , C129 being set;
assume L400: (C126 in ( D202 /\ ( D199 * ) ) & C127 in ( D202 /\ ( D199 * ) ) & C128 in ( D199 * ) & C129 in ( D199 * ) & ( D200 . (C126 , C128) ) = ( D200 . (C127 , C129) ));
consider C130 being (Element of ( NAT )) such that L401: C126 in ( D203 . C130 ) by L230 , L400;
consider C131 being (Element of ( NAT )) such that L402: C127 in ( D203 . C131 ) by L230 , L400;
set D204 = ( C130 + C131 );
L403: ( D203 . D204 ) is D200 -unambiguous by FOMODEL0:def 3;
L404: (( D203 . C130 ) c= ( D203 . D204 ) & ( D203 . C131 ) c= ( D203 . D204 )) by L217;
L405: (C126 in ( ( D203 . D204 ) /\ ( D199 * ) ) & C127 in ( ( D203 . D204 ) /\ ( D199 * ) ) & C128 in ( D199 * ) & C129 in ( D199 * ) & ( D200 . (C126 , C128) ) = ( D200 . (C127 , C129) )) by L404 , L400 , L401 , L402 , XBOOLE_0:def 4;
thus L406: (C126 = C127 & C128 = C129) by L405 , L403 , FOMODEL0:def 9;
end;
L407: D202 is D200 -unambiguous by L399 , FOMODEL0:def 9;
L408: D202 is D199 -prefix by L407 , FOMODEL0:def 3;
thus L409: thesis by L408;
end;
registration
let R12 being Language;
cluster ( AllTermsOf R12 ) -> R12 -prefix;
coherence by L398;
end;
definition
let R12 being Language;
let C132 being  termal (string of R12);
func SubTerms C132 -> (Element of ( ( AllTermsOf R12 ) * )) means 
:L411: (it is ( abs ( ar ( ( R12 -firstChar ) . C132 ) ) ) -element & C132 = ( <* ( ( R12 -firstChar ) . C132 ) *> ^ ( ( R12 -multiCat ) . it ) ));
existence
proof
set D205 = ( AllSymbolsOf R12 );
set D206 = ( R12 -termsOfMaxDepth );
set D207 = ( AllTermsOf R12 );
set D208 = ( ( R12 -firstChar ) . C132 );
set D209 = ( abs ( ar D208 ) );
L412: C132 in D207 by L235;
consider C133 being (Element of ( NAT )) such that L413: C132 in ( D206 . C133 ) by L412 , L230;
reconsider D210 = C132 as C133 -termal (string of R12) by L413 , L237;
reconsider D211 = C132 as non  empty (FinSequence of D205) by FOMODEL0:5;
per cases ;
suppose L414: C133 = ( 0 );

reconsider D212 = D210 as ( 0 ) -termal (string of R12) by L414;
reconsider D213 = ( {} ) as (Element of ( ( AllTermsOf R12 ) * )) by FINSEQ_1:49;
take D213;
L415: ( abs ( ar ( ( R12 -firstChar ) . D212 ) ) ) is  zero;
thus L416: D213 is D209 -element by L415;
L417: ( len D212 ) = 1 by CARD_1:def 7;
L418: D211 = <* ( D211 /. 1 ) *> by L417 , FINSEQ_5:14
.= <* ( D211 . 1 ) *> by L417 , FINSEQ_4:15
.= ( <* ( ( D205 -firstChar ) . C132 ) *> ^ ( {} ) ) by FOMODEL0:6
.= ( <* ( ( D205 -firstChar ) . C132 ) *> ^ ( ( R12 -multiCat ) . D213 ) );
thus L419: thesis by L418;
end;
suppose L420: C133 <> ( 0 );

consider C134 being Nat such that L421: C133 = ( C134 + 1 ) by L420 , NAT_1:6;
reconsider D214 = C134 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D215 = D210 as ( D214 + 1 ) -termal (string of R12) by L421;
consider C135 being (Element of ( ( D206 . D214 ) * )) such that L422: (C135 is D209 -element & D215 = ( <* ( ( R12 -firstChar ) . D215 ) *> ^ ( ( R12 -multiCat ) . C135 ) )) by L335;
reconsider D216 = ( D206 . D214 ) as (Subset of D207) by L227;
L423: (C135 in ( D216 * ) & ( D216 * ) c= ( D207 * ));
reconsider D217 = C135 as (Element of ( D207 * )) by L423;
take D217;
thus L424: thesis by L422;
end;
end;
uniqueness
proof
set D218 = ( AllSymbolsOf R12 );
set D219 = ( R12 -termsOfMaxDepth );
set D220 = ( AllTermsOf R12 );
set D221 = ( ( R12 -firstChar ) . C132 );
set D222 = ( abs ( ar D221 ) );
L426: ( D218 -multiCat ) is ( D222 -tuples_on D220 ) -one-to-one by FOMODEL0:8;
L427: ( dom ( D218 -multiCat ) ) = ( ( D218 * ) * ) by FUNCT_2:def 1;
let C136 , C137 being (Element of ( D220 * ));
reconsider D223 = C136 , D224 = C137 as (FinSequence of D220) by FINSEQ_1:def 11;
assume L428: (C136 is D222 -element & C132 = ( <* D221 *> ^ ( ( R12 -multiCat ) . C136 ) ));
L429: ( len D223 ) = D222 by L428 , CARD_1:def 7;
reconsider D225 = D223 as (Element of ( D222 -tuples_on D220 )) by L429 , FINSEQ_2:133;
assume L430: (C137 is D222 -element & C132 = ( <* D221 *> ^ ( ( R12 -multiCat ) . C137 ) ));
L431: ( len D224 ) = D222 by L430 , CARD_1:def 7;
reconsider D226 = D224 as (Element of ( D222 -tuples_on D220 )) by L431 , FINSEQ_2:133;
L432: ( ( D218 -multiCat ) . D225 ) = ( ( D218 -multiCat ) . D226 ) by L428 , L430 , FINSEQ_1:33;
L433: (D225 in ( ( D222 -tuples_on D220 ) /\ ( dom ( D218 -multiCat ) ) ) & D226 in ( ( D222 -tuples_on D220 ) /\ ( dom ( D218 -multiCat ) ) )) by L427 , XBOOLE_0:def 4;
thus L434: thesis by L433 , L432 , L426 , FOMODEL0:def 5;
end;
end;
registration
let R12 being Language;
let C138 being  termal (string of R12);
cluster ( SubTerms C138 ) -> ( abs ( ar C138 ) ) -element for (Element of ( ( AllTermsOf R12 ) * ));
coherence by L411;
end;
registration
let R12 being Language;
let C139 being ( 0 ) -termal (string of R12);
cluster ( SubTerms C139 ) ->  empty for (Element of ( ( AllTermsOf R12 ) * ));
coherence
proof
L437: ( abs ( ar C139 ) ) = ( 0 );
thus L438: thesis by L437;
end;
end;
registration
let R5 being (Element of ( NAT ));
let R12 being Language;
let C140 being ( R5 + 1 ) -termal (string of R12);
cluster ( SubTerms C140 ) -> ( ( R12 -termsOfMaxDepth ) . R5 ) -valued for (Element of ( ( AllTermsOf R12 ) * ));
coherence
proof
set D227 = ( R12 -termsOfMaxDepth );
set D228 = ( R12 -firstChar );
set D229 = ( R12 -multiCat );
set D230 = ( AllTermsOf R12 );
set D231 = ( AllSymbolsOf R12 );
consider C141 being (Element of ( ( D227 . R5 ) * )) such that L440: (C141 is ( abs ( ar C140 ) ) -element & C140 = ( <* ( D228 . C140 ) *> ^ ( D229 . C141 ) )) by L335;
reconsider D232 = ( D227 . R5 ) as (Subset of D230) by L227;
reconsider D233 = ( D232 * ) as non  empty (Subset of ( D230 * ));
reconsider D234 = C141 as (Element of D233);
reconsider D235 = D234 as (Element of ( D230 * ));
L441: D235 = ( SubTerms C140 ) by L411 , L440;
thus L442: thesis by L441;
end;
end;
definition
let R12 being Language;
let C142 being  0wff (string of R12);
func SubTerms C142 -> ( abs ( ar ( ( R12 -firstChar ) . C142 ) ) ) -element (Element of ( ( AllTermsOf R12 ) * )) means 
:L444: C142 = ( <* ( ( R12 -firstChar ) . C142 ) *> ^ ( ( R12 -multiCat ) . it ) );
existence
proof
set D236 = ( AllSymbolsOf R12 );
set D237 = ( AllTermsOf R12 );
set D238 = ( R12 -multiCat );
set D239 = ( R12 -firstChar );
consider C143 being  relational (Element of R12), C144 being ( abs ( ar C143 ) ) -element (Element of ( D237 * )) such that L445: C142 = ( <* C143 *> ^ ( D238 . C144 ) ) by L379;
reconsider D240 = C143 as (Element of D236);
reconsider D241 = <* D240 *> as (FinSequence of D236);
reconsider D242 = ( D238 . C144 ) as (FinSequence of D236) by FINSEQ_1:def 11;
L446: ( D239 . C142 ) = ( ( D241 ^ D242 ) . 1 ) by L445 , FOMODEL0:6
.= C143 by FINSEQ_1:41;
reconsider D243 = C144 as ( abs ( ar ( D239 . C142 ) ) ) -element (Element of ( D237 * )) by L446;
take D243;
thus L447: thesis by L446 , L445;
end;
uniqueness
proof
set D244 = ( AllSymbolsOf R12 );
set D245 = ( AllTermsOf R12 );
set D246 = ( R12 -multiCat );
set D247 = ( R12 -firstChar );
set D248 = ( abs ( ar ( ( R12 -firstChar ) . C142 ) ) );
L448: (( dom D246 ) = ( ( D244 * ) * ) & ( D245 * ) c= ( ( D244 * ) * )) by FUNCT_2:def 1;
reconsider D249 = ( D247 . C142 ) as (Element of D244);
reconsider D250 = <* D249 *> as (FinSequence of D244);
let C145 , C146 being D248 -element (Element of ( D245 * ));
reconsider D251 = C145 , D252 = C146 as (FinSequence of D245) by FINSEQ_1:def 11;
L449: (( len C145 ) = D248 & ( len C146 ) = D248) by CARD_1:def 7;
reconsider D253 = D251 , D254 = D252 as (Element of ( D248 -tuples_on D245 )) by L449 , FINSEQ_2:133;
reconsider D255 = ( D246 . C145 ) , D256 = ( D246 . C146 ) as (FinSequence of D244) by FINSEQ_1:def 11;
assume L450: (C142 = ( <* ( D247 . C142 ) *> ^ ( D246 . C145 ) ) & C142 = ( <* ( D247 . C142 ) *> ^ ( D246 . C146 ) ));
L451: (C145 in ( dom D246 ) & D253 in ( D248 -tuples_on D245 ) & C146 in ( dom D246 ) & D254 in ( D248 -tuples_on D245 )) by L448;
L452: (C145 in ( ( D248 -tuples_on D245 ) /\ ( dom D246 ) ) & C146 in ( ( D248 -tuples_on D245 ) /\ ( dom D246 ) ) & ( D246 . C145 ) = ( D246 . C146 )) by L451 , L450 , FINSEQ_1:33 , XBOOLE_0:def 4;
L453: D246 is ( D248 -tuples_on D245 ) -one-to-one by FOMODEL0:8;
thus L454: thesis by L453 , L452 , FOMODEL0:def 5;
end;
end;
registration
let R12 being Language;
let C147 being  0wff (string of R12);
cluster ( SubTerms C147 ) -> ( abs ( ar ( ( R12 -firstChar ) . C147 ) ) ) -element for FinSequence;
coherence;
end;
definition
let R12 being Language;
redefine func AllTermsOf R12 -> (Element of ( bool ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } ) ));

coherence
proof
set D257 = ( AllSymbolsOf R12 );
set D258 = ( AllTermsOf R12 );
L457:
now
let C148 being set;
assume L458: C148 in D258;
reconsider D259 = C148 as (Element of D258) by L458;
L459: ((not C148 in { ( {} ) }) & C148 in ( D257 * )) by L458;
thus L460: C148 in ( ( D257 * ) \ { ( {} ) } ) by L459 , XBOOLE_0:def 5;
end;
thus L461: thesis by L457 , TARSKI:def 3;
end;
end;
registration
let R12 being Language;
cluster  ->  termal for (Element of ( AllTermsOf R12 ));
coherence by L235;
end;
definition
let R12 being Language;
func R12 -subTerms -> (Function of ( AllTermsOf R12 ) , ( ( AllTermsOf R12 ) * )) means 
(for B48 being (Element of ( AllTermsOf R12 )) holds ( it . B48 ) = ( SubTerms B48 ));
existence
proof
set D260 = ( AllSymbolsOf R12 );
set D261 = ( AllTermsOf R12 );
deffunc H4((Element of D261)) = ( SubTerms $1 );
consider C149 being (Function of D261 , ( D261 * )) such that L464: (for B49 being (Element of D261) holds ( C149 . B49 ) = H4(B49)) from FUNCT_2:sch 4;
take C149;
thus L465: thesis by L464;
end;
uniqueness
proof
set D262 = ( AllTermsOf R12 );
let C150 , C151 being (Function of D262 , ( D262 * ));
assume L466: (for B50 being (Element of D262) holds ( C150 . B50 ) = ( SubTerms B50 ));
assume L467: (for B51 being (Element of D262) holds ( C151 . B51 ) = ( SubTerms B51 ));
L468:
now
let C152 being (Element of D262);
thus L469: ( C150 . C152 ) = ( SubTerms C152 ) by L466
.= ( C151 . C152 ) by L467;
end;
thus L470: thesis by L468 , FUNCT_2:63;
end;
end;
theorem
L472: (for R2 being Nat holds (for R3 being Nat holds (for R12 being Language holds ( ( R12 -termsOfMaxDepth ) . R2 ) c= ( ( R12 -termsOfMaxDepth ) . ( R2 + R3 ) )))) by L217;
theorem
L473: (for R9 being set holds (for R12 being Language holds (R9 in ( AllTermsOf R12 ) implies (ex R6 being (Element of ( NAT )) st R9 in ( ( R12 -termsOfMaxDepth ) . R6 ))))) by L230;
theorem
L474: (for R12 being Language holds ( AllTermsOf R12 ) c= ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } ));
theorem
L475: (for R12 being Language holds ( AllTermsOf R12 ) is R12 -prefix);
theorem
L476: (for R9 being set holds (for R12 being Language holds (R9 in ( AllTermsOf R12 ) implies R9 is (string of R12))));
theorem
L477: (for R12 being Language holds ( ( AtomicFormulaSymbolsOf R12 ) \ ( OwnSymbolsOf R12 ) ) = { ( TheEqSymbOf R12 ) })
proof
let R12 being Language;
set D263 = (the OneF of R12);
set D264 = (the ZeroF of R12);
set D265 = (the adicity of R12);
set D266 = ( RelSymbolsOf R12 );
set D267 = ( OwnSymbolsOf R12 );
set D268 = ( AllSymbolsOf R12 );
set D269 = ( TheEqSymbOf R12 );
set D270 = ( TheNorSymbOf R12 );
set D271 = ( AtomicFormulaSymbolsOf R12 );
set D272 = ( (the carrier of R12) \ { D263 } );
L478: D269 in D271;
L479: ( D271 \ D267 ) = ( D271 \ ( D268 \ ( { D264 } \/ { D263 } ) ) ) by ENUMSET1:1
.= ( D271 \ ( D271 \ { D264 } ) ) by XBOOLE_1:41
.= ( ( D271 \ D271 ) \/ ( D271 /\ { D264 } ) ) by XBOOLE_1:52
.= { D264 } by L478 , ZFMISC_1:46;
thus L480: thesis by L479;
end;
theorem
L481: (for R12 being Language holds ( ( TermSymbolsOf R12 ) \ ( LettersOf R12 ) ) = ( OpSymbolsOf R12 )) by FUNCT_1:69;
theorem
L482: (for R12 being Language holds ( ( AtomicFormulaSymbolsOf R12 ) \ ( RelSymbolsOf R12 ) ) = ( TermSymbolsOf R12 ))
proof
let R12 being Language;
set D273 = ( RelSymbolsOf R12 );
set D274 = ( AtomicFormulaSymbolsOf R12 );
set D275 = (the adicity of R12);
L483: ( D275 " ( INT ) ) = D274 by FUNCT_2:40;
thus L484: ( D274 \ D273 ) = ( D275 " ( ( INT ) \ ( ( INT ) \ ( NAT ) ) ) ) by L483 , FUNCT_1:69
.= ( D275 " ( ( ( INT ) \ ( INT ) ) \/ ( ( INT ) /\ ( NAT ) ) ) ) by XBOOLE_1:52
.= ( TermSymbolsOf R12 ) by XBOOLE_1:7 , XBOOLE_1:28;
end;
registration
let R12 being Language;
cluster non  relational ->  termal for  ofAtomicFormula  ofAtomicFormula  ofAtomicFormula  ofAtomicFormula (Element of R12);
coherence
proof
set D276 = ( RelSymbolsOf R12 );
set D277 = ( AtomicFormulaSymbolsOf R12 );
set D278 = ( TermSymbolsOf R12 );
let C153 being  ofAtomicFormula (Element of R12);
assume L485: C153 is non  relational;
L486: (C153 in D277 & (not C153 in D276)) by L485 , L15 , L18;
L487: C153 in ( D277 \ D276 ) by L486 , XBOOLE_0:def 5;
L488: C153 in D278 by L487 , L482;
thus L489: thesis by L488 , L16;
end;
end;
definition
let R12 being Language;
redefine func OwnSymbolsOf R12 -> (Subset of ( AllSymbolsOf R12 ));

coherence;
end;
registration
let R12 being Language;
cluster non  literal ->  operational for  termal  termal  termal  termal (Element of R12);
coherence
proof
set D279 = ( LettersOf R12 );
set D280 = ( OpSymbolsOf R12 );
set D281 = ( TermSymbolsOf R12 );
set D282 = (the adicity of R12);
let C154 being  termal (Element of R12);
L492: C154 in D281 by L16;
assume L493: (not C154 is  literal);
L494: (not C154 in D279) by L493 , L12;
L495: (C154 in ( D281 \ D279 ) & ( D281 \ D279 ) = D280) by L494 , L492 , FUNCT_1:69 , XBOOLE_0:def 5;
thus L496: thesis by L495 , L14;
end;
end;
theorem
L498: (for R9 being set holds (for R12 being Language holds (R9 is (string of R12) iff R9 is non  empty non  empty non  empty non  empty (Element of ( ( AllSymbolsOf R12 ) * )))))
proof
let R9 being set;
let R12 being Language;
set D283 = ( AllSymbolsOf R12 );
L499: (R9 is (string of R12) iff (R9 in ( D283 * ) & (not R9 in { ( {} ) }))) by XBOOLE_0:def 5;
thus L500: thesis by L499;
end;
theorem
L501: (for R9 being set holds (for R12 being Language holds (R9 is (string of R12) iff R9 is non  empty non  empty non  empty non  empty (FinSequence of ( AllSymbolsOf R12 )))))
proof
let R9 being set;
let R12 being Language;
L502: (R9 is non  empty non  empty non  empty non  empty (FinSequence of ( AllSymbolsOf R12 )) iff R9 is non  empty non  empty non  empty non  empty (Element of ( ( AllSymbolsOf R12 ) * ))) by FINSEQ_1:def 11;
thus L503: thesis by L502 , L498;
end;
theorem
L504: (for R12 being Language holds ( R12 -termsOfMaxDepth ) is (Function of ( NAT ) , ( bool ( ( AllSymbolsOf R12 ) * ) )));
registration
let R12 being Language;
cluster  ->  literal for (Element of ( LettersOf R12 ));
coherence by L12;
end;
registration
let R12 being Language;
cluster ( TheNorSymbOf R12 ) -> non  low-compounding for (Element of R12);
coherence
proof
set D284 = ( TheNorSymbOf R12 );
set D285 = (the adicity of R12);
set D286 = ( LowerCompoundersOf R12 );
set D287 = ( AllSymbolsOf R12 );
L506: (( dom D285 ) = ( D287 \ { D284 } ) & D284 in { D284 }) by FUNCT_2:def 1 , TARSKI:def 1;
L507: (not D284 in D286) by L506 , XBOOLE_0:def 5;
thus L508: thesis by L507 , L13;
end;
end;
registration
let R12 being Language;
cluster ( TheNorSymbOf R12 ) -> non  own for (Element of R12);
coherence
proof
set D288 = ( TheNorSymbOf R12 );
set D289 = (the adicity of R12);
set D290 = ( OwnSymbolsOf R12 );
set D291 = ( AllSymbolsOf R12 );
L510: D288 in { (the ZeroF of R12) , D288 } by TARSKI:def 2;
L511: (not D288 in D290) by L510 , XBOOLE_0:def 5;
thus L512: thesis by L511 , L17;
end;
end;
theorem
L514: (for R12 being Language holds (for R15 being (Element of R12) holds ((R15 <> ( TheNorSymbOf R12 ) & R15 <> ( TheEqSymbOf R12 )) implies R15 in ( OwnSymbolsOf R12 ))))
proof
let R12 being Language;
let R15 being (Element of R12);
set D292 = ( OwnSymbolsOf R12 );
set D293 = ( RelSymbolsOf R12 );
set D294 = ( TheEqSymbOf R12 );
set D295 = ( D293 \ D292 );
set D296 = ( TheNorSymbOf R12 );
set D297 = ( AllSymbolsOf R12 );
assume L515: (R15 <> D296 & R15 <> D294);
L516: ((not R15 in { D296 }) & (not R15 in { D294 })) by L515 , TARSKI:def 1;
L517: (not R15 in ( { D296 } \/ { D294 } )) by L516 , XBOOLE_0:def 3;
L518: (not R15 in { D296 , D294 }) by L517 , ENUMSET1:1;
thus L519: thesis by L518 , XBOOLE_0:def 5;
end;
definition
let R12 being Language;
let R26 being  termal (string of R12);
func Depth R26 -> Nat means 
:L520: (R26 is it -termal & (for R3 being Nat holds (R26 is R3 -termal implies it <= R3)));
existence
proof
defpred S7[ Nat ] means R26 is $1 -termal;
set D298 = ( AllTermsOf R12 );
set D299 = ( R12 -termsOfMaxDepth );
reconsider D300 = D299 as Function;
L521: R26 in D298 by L235;
consider R5 being (Element of ( NAT )) such that L522: R26 in ( D300 . R5 ) by L521 , L230;
L523: R26 is R5 -termal by L237 , L522;
L524: (ex B52 being Nat st S7[ B52 ]) by L523;
consider C155 being Nat such that L525: (S7[ C155 ] & (for R3 being Nat holds (S7[ R3 ] implies C155 <= R3))) from NAT_1:sch 5(L524);
take C155;
thus L526: thesis by L525;
end;
uniqueness
proof
let C156 , C157 being Nat;
set D301 = R26;
assume L527: (D301 is C156 -termal & (for R3 being Nat holds (D301 is R3 -termal implies C156 <= R3)));
assume L528: (D301 is C157 -termal & (for R3 being Nat holds (D301 is R3 -termal implies C157 <= R3)));
L529: C157 <= C156 by L528 , L527;
L530: C156 <= C157 by L527 , L528;
thus L531: thesis by L530 , L529 , XXREAL_0:1;
end;
end;
registration
let R12 being Language;
let C158 being  zero number;
let C159 being C158 -termal (string of R12);
cluster ( Depth C159 ) ->  zero for number;
coherence by L520;
end;
registration
let R12 being Language;
let C160 being  low-compounding (Element of R12);
cluster ( ar C160 ) -> non  zero for number;
coherence
proof
set D302 = (the adicity of R12);
set D303 = ( AllSymbolsOf R12 );
set D304 = ( TheNorSymbOf R12 );
L534: C160 in ( LowerCompoundersOf R12 ) by L13;
L535: (C160 in ( dom D302 ) & ( D302 . C160 ) in ( ( INT ) \ { ( 0 ) } )) by L534 , FUNCT_1:def 7;
L536: (not ( D302 . C160 ) in { ( 0 ) }) by L535 , XBOOLE_0:def 5;
thus L537: thesis by L536 , TARSKI:def 1;
end;
end;
registration
let R12 being Language;
let C161 being  termal (Element of R12);
cluster ( ar C161 ) -> non  negative  ext-real;
coherence
proof
set D305 = (the adicity of R12);
set D306 = ( TermSymbolsOf R12 );
L539: C161 in D306 by L16;
reconsider D307 = ( ar C161 ) as (Element of ( NAT )) by L539 , FUNCT_1:def 7;
L540: D307 is non  negative;
thus L541: thesis by L540;
end;
end;
registration
let R12 being Language;
let C162 being  relational (Element of R12);
cluster ( ar C162 ) ->  negative  ext-real;
coherence
proof
set D308 = (the adicity of R12);
set D309 = ( RelSymbolsOf R12 );
L543: C162 in D309 by L15;
L544: (C162 in ( dom D308 ) & ( D308 . C162 ) in ( ( INT ) \ ( NAT ) )) by L543 , FUNCT_1:def 7;
L545: (( ar C162 ) in ( INT ) & (not ( ar C162 ) in ( NAT ))) by L544 , XBOOLE_0:def 5;
reconsider D310 = ( ar C162 ) as (Element of ( INT ));
thus L546: thesis by L545 , INT_1:3;
end;
end;
theorem
L548: (for R12 being Language holds (for R26 being  termal (string of R12) holds (R26 is non ( 0 ) -termal implies (( ( R12 -firstChar ) . R26 ) is  operational & ( SubTerms R26 ) <> ( {} )))))
proof
let R12 being Language;
let R26 being  termal (string of R12);
set D311 = ( R12 -termsOfMaxDepth );
set D312 = ( Depth R26 );
set D313 = ( SubTerms R26 );
set D314 = ( AllTermsOf R12 );
assume L549: R26 is non ( 0 ) -termal;
L550: D312 <> ( 0 ) by L549 , L520;
consider R3 being Nat such that L551: D312 = ( R3 + 1 ) by L550 , NAT_1:6;
set D315 = ( R12 -firstChar );
set D316 = ( R12 -multiCat );
set D317 = { ( Compound (B53 , ( D311 . R3 )) ) where B53 is  ofAtomicFormula (Element of R12) : B53 is  operational };
L552: R3 < D312 by L551 , NAT_1:16;
L553: ((not R26 is R3 -termal) & R26 is D312 -termal) by L552 , L520;
L554: ((not R26 in ( D311 . R3 )) & R26 in ( D311 . ( R3 + 1 ) )) by L553 , L551 , L237;
L555: (R26 in ( ( union D317 ) \/ ( D311 . R3 ) ) & (not R26 in ( D311 . R3 ))) by L554 , L185;
L556: R26 in ( union D317 ) by L555 , XBOOLE_0:def 3;
consider C163 being set such that L557: (R26 in C163 & C163 in D317) by L556 , TARSKI:def 4;
consider C164 being  ofAtomicFormula (Element of R12) such that L558: (C163 = ( Compound (C164 , ( D311 . R3 )) ) & C164 is  operational) by L557;
set D318 = ( abs ( ar C164 ) );
consider C165 being (Element of ( ( ( AllSymbolsOf R12 ) * ) * )) such that L559: (R26 = ( <* C164 *> ^ ( D316 . C165 ) ) & ( rng C165 ) c= ( D311 . R3 ) & C165 is ( abs ( ar C164 ) ) -element) by L557 , L558;
L560: ( D315 . R26 ) = ( ( <* C164 *> ^ ( D316 . C165 ) ) . 1 ) by L559 , FOMODEL0:6
.= ( <* C164 *> . 1 ) by FOMODEL0:28
.= C164 by FINSEQ_1:40;
thus L561: ( D315 . R26 ) is  operational by L560 , L558;
reconsider D319 = D318 as non  zero Nat by L558;
reconsider D320 = D313 as ( D319 + ( 0 ) ) -element (Element of ( D314 * )) by L560;
L562: D320 <> ( {} );
thus L563: thesis by L562;
end;
registration
let R12 being Language;
cluster ( R12 -multiCat ) ->  FinSequence-yielding for Function;
coherence;
end;
registration
let R12 being Language;
let C166 being non  empty ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } ) -valued FinSequence;
cluster ( ( R12 -multiCat ) . C166 ) -> non  empty for set;
coherence
proof
set D321 = ( R12 -multiCat );
set D322 = ( AllSymbolsOf R12 );
set D323 = ( D322 -concatenation );
set D324 = ( MultPlace D323 );
consider R2 being Nat such that L565: ( R2 + 1 ) = ( len C166 ) by NAT_1:6;
reconsider D325 = C166 as ( ( R2 + 1 ) + ( 0 ) ) -element FinSequence by L565 , CARD_1:def 7;
L566: ( { ( D325 . ( R2 + 1 ) ) } \ ( ( D322 * ) \ { ( {} ) } ) ) = ( {} );
L567: ( D325 . ( R2 + 1 ) ) in ( ( D322 * ) \ { ( {} ) } ) by L566 , ZFMISC_1:60;
reconsider D326 = ( D325 . ( R2 + 1 ) ) as (string of R12) by L566 , ZFMISC_1:60;
reconsider D327 = ( D325 . ( R2 + 1 ) ) as (Element of ( D322 * )) by L567;
set D328 = ( D325 | ( Seg R2 ) );
reconsider D329 = D328 as ( D322 * ) -valued FinSequence;
L568: ( ( D328 ^ <* ( D325 . ( R2 + 1 ) ) *> ) \+\ D325 ) = ( {} );
L569: ( D324 . C166 ) = ( D324 . ( D329 ^ <* D327 *> ) ) by L568 , FOMODEL0:29;
per cases ;
suppose L570: D329 is  empty;

L571: ( D324 . C166 ) = ( D324 . <* D327 *> ) by L570 , L569 , FINSEQ_1:34
.= D326 by FOMODEL0:31;
thus L572: thesis by L571 , FOMODEL0:32;
end;
suppose L573: D329 is non  empty;

reconsider D330 = D329 as (Element of ( ( ( D322 * ) * ) \ { ( {} ) } )) by L573 , FOMODEL0:30;
L574: ( D324 . C166 ) = ( D323 . (( D324 . D329 ) , D327) ) by L573 , L569 , FOMODEL0:31
.= ( ( D324 . D330 ) ^ D326 ) by FOMODEL0:4;
thus L575: thesis by L574 , FOMODEL0:32;
end;
end;
end;
registration
let R12 being Language;
let R18 being  literal (Element of R12);
cluster <* R18 *> -> ( 0 ) -termal for (string of R12);
coherence
proof
set D331 = <* R18 *>;
set D332 = ( LettersOf R12 );
set D333 = ( AtomicTermsOf R12 );
set D334 = ( R12 -termsOfMaxDepth );
reconsider D335 = R18 as (Element of D332) by L12;
L578: D331 = <* D335 *>;
L579: D331 in D333 by L578;
L580: D331 in ( D334 . ( 0 ) ) by L579 , L185;
thus L581: thesis by L580 , L237;
end;
end;
registration
let R12 being Language;
let R2 being Nat;
let R3 being Nat;
cluster ( R2 + ( ( 0 ) * R3 ) ) -termal -> ( R2 + R3 ) -termal for (string of R12);
coherence
proof
set D336 = ( R12 -termsOfMaxDepth );
let C167 being (string of R12);
assume L583: C167 is ( R2 + ( ( 0 ) * R3 ) ) -termal;
L584: (C167 in ( D336 . R2 ) & ( D336 . R2 ) c= ( D336 . ( R2 + R3 ) )) by L583 , L237 , L217;
thus L585: thesis by L584 , L237;
end;
end;
registration
let R12 being Language;
cluster non  low-compounding ->  literal for  own  own  own  own (Element of R12);
coherence
proof
set D337 = ( LettersOf R12 );
set D338 = ( OpSymbolsOf R12 );
set D339 = ( OwnSymbolsOf R12 );
set D340 = ( TermSymbolsOf R12 );
L587: ( D340 \ D337 ) = D338 by FUNCT_1:69;
let C168 being  own (Element of R12);
reconsider D341 = C168 as  ofAtomicFormula (Element of R12);
assume L588: C168 is non  low-compounding;
L589: (not D341 is  relational) by L588;
reconsider D342 = D341 as  termal  ofAtomicFormula (Element of R12) by L589;
assume L590: (not C168 is  literal);
L591: (D342 in D340 & (not C168 in D337)) by L590 , L16;
L592: C168 in ( D340 \ D337 ) by L591 , XBOOLE_0:def 5;
L593: (C168 is  operational & (not C168 is  operational)) by L592 , L588 , L587 , L14;
thus L594: contradiction by L593;
end;
end;
registration
let R12 being Language;
let R26 being  termal (string of R12);
cluster ( SubTerms R26 ) -> ( ( rng R26 ) * ) -valued for Relation;
coherence
proof
set D343 = ( AllSymbolsOf R12 );
set D344 = ( R12 -multiCat );
set D345 = ( R12 -firstChar );
set D346 = ( SubTerms R26 );
set D347 = ( R12 -termsOfMaxDepth );
set D348 = ( AllTermsOf R12 );
reconsider D349 = D348 as (Subset of ( D343 * )) by XBOOLE_1:1;
L596: R26 = ( <* ( D345 . R26 ) *> ^ ( D344 . D346 ) ) by L411;
L597: ( rng ( D344 . D346 ) ) c= ( rng R26 ) by L596 , FINSEQ_1:30;
L598: ( D344 . D346 ) is ( rng R26 ) -valued by L597 , RELAT_1:def 19;
thus L599: thesis by L598 , FOMODEL0:42;
end;
end;
registration
let R12 being Language;
let C169 being  0wff (string of R12);
cluster ( SubTerms C169 ) -> ( ( rng C169 ) * ) -valued for Relation;
coherence
proof
set D350 = ( AllSymbolsOf R12 );
set D351 = ( R12 -multiCat );
set D352 = ( R12 -firstChar );
set D353 = ( SubTerms C169 );
set D354 = ( R12 -termsOfMaxDepth );
set D355 = ( AllTermsOf R12 );
reconsider D356 = D355 as non  empty (Subset of ( D350 * )) by XBOOLE_1:1;
L601: C169 = ( <* ( D352 . C169 ) *> ^ ( D351 . D353 ) ) by L444;
L602: ( rng ( D351 . D353 ) ) c= ( rng C169 ) by L601 , FINSEQ_1:30;
L603: ( D351 . D353 ) is ( rng C169 ) -valued by L602 , RELAT_1:def 19;
thus L604: thesis by L603 , FOMODEL0:42;
end;
end;
definition
let R12 being Language;
redefine func R12 -termsOfMaxDepth -> (Function of ( NAT ) , ( bool ( ( ( AllSymbolsOf R12 ) * ) \ { ( {} ) } ) ));

coherence
proof
set D357 = ( R12 -termsOfMaxDepth );
set D358 = ( AllSymbolsOf R12 );
L606:
now
let R10 being set;
assume L607: R10 in ( rng D357 );
consider R9 being set such that L608: (R9 in ( dom D357 ) & ( D357 . R9 ) = R10) by L607 , FUNCT_1:def 3;
reconsider D359 = R9 as (Element of ( NAT )) by L608;
L609: ( D357 . D359 ) misses { ( {} ) }
proof
assume L610: ( D357 . D359 ) meets { ( {} ) };
L611: ( ( D357 . D359 ) /\ { ( {} ) } ) <> ( {} ) by L610 , XBOOLE_0:def 7;
consider R11 being set such that L612: R11 in ( ( D357 . D359 ) /\ { ( {} ) } ) by L611 , XBOOLE_0:def 1;
thus L613: contradiction by L612;
end;
L614: ( D357 . D359 ) c= ( ( D358 * ) \ { ( {} ) } ) by L609 , XBOOLE_1:86;
thus L615: R10 in ( bool ( ( D358 * ) \ { ( {} ) } ) ) by L614 , L608;
end;
L616: ( rng D357 ) c= ( bool ( ( D358 * ) \ { ( {} ) } ) ) by L606 , TARSKI:def 3;
thus L617: thesis by L616 , FUNCT_2:6;
end;
end;
registration
let R12 being Language;
let R5 being (Element of ( NAT ));
cluster ( ( R12 -termsOfMaxDepth ) . R5 ) ->  with_non-empty_elements;
coherence;
end;
L620: (for R2 being Nat holds (for R12 being Language holds ( ( R12 -termsOfMaxDepth ) . R2 ) c= ( ( TermSymbolsOf R12 ) * )))
proof
let R2 being Nat;
let R12 being Language;
set D360 = ( TermSymbolsOf R12 );
set D361 = ( R12 -firstChar );
set D362 = ( R12 -multiCat );
set D363 = ( OpSymbolsOf R12 );
set D364 = ( R12 -termsOfMaxDepth );
set D365 = ( AllSymbolsOf R12 );
set D366 = ( D360 -multiCat );
defpred S8[ Nat ] means ( D364 . $1 ) c= ( D360 * );
L621: S8[ ( 0 ) ]
proof
L622:
now
let R9 being set;
assume L623: R9 in ( D364 . ( 0 ) );
reconsider D367 = R9 as ( 0 ) -termal (string of R12) by L623 , L237;
reconsider D368 = ( D361 . D367 ) as  termal (Element of R12);
set D369 = ( SubTerms D367 );
reconsider D370 = D368 as (Element of D360) by L16;
L624: D367 = ( <* D368 *> ^ ( D362 . D369 ) ) by L411
.= ( <* D368 *> ^ ( {} ) )
.= <* D370 *>;
L625: D367 is (FinSequence of D360) by L624;
thus L626: R9 in ( D360 * ) by L625 , FINSEQ_1:def 11;
end;
thus L627: thesis by L622 , TARSKI:def 3;
end;
L628: (for R3 being Nat holds (S8[ R3 ] implies S8[ ( R3 + 1 ) ]))
proof
let R3 being Nat;
reconsider D371 = R3 , D372 = ( R3 + 1 ) as (Element of ( NAT )) by ORDINAL1:def 12;
assume L629: S8[ R3 ];
reconsider D373 = ( D364 . D371 ) as non  empty (Subset of ( D360 * )) by L629;
L630:
now
let R9 being set;
assume L631: R9 in ( D364 . ( R3 + 1 ) );
L632: R9 in ( D364 . D372 ) by L631;
reconsider D374 = R9 as ( R3 + 1 ) -termal (string of R12) by L632 , L237;
set D375 = ( D361 . D374 );
set D376 = ( abs ( ar D375 ) );
reconsider D377 = D374 as ( D371 + 1 ) -termal (string of R12);
per cases ;
suppose L633: (not D374 is ( 0 ) -termal);

L634: D375 is  operational by L633 , L548;
L635: (D375 in D363 & D363 c= D360) by L634 , L14 , L83;
reconsider D378 = D375 as (Element of D360) by L635;
reconsider D379 = D376 as non  zero Nat by L634;
L636: ( SubTerms D377 ) is ( D364 . D371 ) -valued;
reconsider D380 = ( SubTerms D374 ) as ( D379 + ( 0 ) ) -element (FinSequence of D373) by L636 , FOMODEL0:26;
L637: (D380 in ( D373 * ) & ( D373 * ) c= ( ( D360 * ) * )) by FINSEQ_1:def 11;
reconsider D381 = D380 as ( D379 + ( 0 ) ) -element (Element of ( ( D360 * ) * )) by L637;
L638: (D380 is D373 -valued & D373 c= ( D360 * ) & D360 c= D365) by XBOOLE_1:1;
L639: ( <* D378 *> ^ ( D366 . D381 ) ) = ( <* ( D361 . D374 ) *> ^ ( D362 . ( SubTerms D374 ) ) ) by L638 , FOMODEL0:53
.= D374 by L411;
reconsider D382 = D374 as (FinSequence of D360) by L639 , FOMODEL0:26;
L640: D382 in ( D360 * ) by FINSEQ_1:def 11;
thus L641: R9 in ( D360 * ) by L640;
end;
suppose L642: D374 is ( 0 ) -termal;

L643: R9 in ( D364 . ( 0 ) ) by L642 , L237;
thus L644: R9 in ( D360 * ) by L643 , L621;
end;
end;
thus L646: thesis by L630 , TARSKI:def 3;
end;
L647: (for R3 being Nat holds S8[ R3 ]) from NAT_1:sch 2(L621 , L628);
thus L648: thesis by L647;
end;
registration
let R12 being Language;
let R2 being Nat;
let C170 being  termal (string of R12);
cluster ( C170 null R2 ) -> ( ( Depth C170 ) + R2 ) -termal for (string of R12);
coherence
proof
set D383 = ( Depth C170 );
L649: C170 is ( D383 + ( ( 0 ) * R2 ) ) -termal by L520;
thus L650: thesis by L649;
end;
end;
registration
let R12 being Language;
cluster  termal -> ( TermSymbolsOf R12 ) -valued for (string of R12);
coherence
proof
set D384 = ( R12 -termsOfMaxDepth );
set D385 = ( TermSymbolsOf R12 );
let R23 being (string of R12);
assume L652: R23 is  termal;
reconsider D386 = R23 as  termal (string of R12) by L652;
set D387 = ( Depth D386 );
reconsider D388 = ( D386 null ( 0 ) ) as ( D387 + ( 0 ) ) -termal (string of R12);
L653: (D388 in ( D384 . D387 ) & ( D384 . D387 ) c= ( D385 * )) by L620 , L237;
thus L654: thesis by L653;
end;
end;
registration
let R12 being Language;
cluster ( ( AllTermsOf R12 ) \ ( ( TermSymbolsOf R12 ) * ) ) ->  empty for set;
coherence
proof
set D389 = ( AllTermsOf R12 );
set D390 = ( TermSymbolsOf R12 );
L656:
now
let R9 being set;
assume L657: R9 in D389;
reconsider D391 = R9 as  termal (string of R12) by L657;
L658: D391 is (FinSequence of D390) by FOMODEL0:26;
thus L659: R9 in ( D390 * ) by L658 , FINSEQ_1:def 11;
end;
L660: D389 c= ( D390 * ) by L656 , TARSKI:def 3;
thus L661: thesis by L660;
end;
end;
registration
let R12 being Language;
let C171 being  0wff (string of R12);
cluster ( SubTerms C171 ) -> ( ( TermSymbolsOf R12 ) * ) -valued;
coherence
proof
set D392 = ( SubTerms C171 );
set D393 = ( TermSymbolsOf R12 );
set D394 = ( AllTermsOf R12 );
L663: ( D394 \ ( D393 * ) ) = ( {} );
reconsider D395 = D394 as non  empty (Subset of ( D393 * )) by L663 , XBOOLE_1:37;
L664: D392 is D395 -valued;
thus L665: thesis by L664;
end;
end;
registration
let R12 being Language;
cluster  0wff -> ( AtomicFormulaSymbolsOf R12 ) -valued for (string of R12);
coherence
proof
set D396 = ( TermSymbolsOf R12 );
set D397 = ( AtomicFormulaSymbolsOf R12 );
set D398 = ( R12 -firstChar );
set D399 = ( R12 -multiCat );
set D400 = ( AllTermsOf R12 );
set D401 = ( D396 -multiCat );
set D402 = ( AllSymbolsOf R12 );
let R23 being (string of R12);
assume L667: R23 is  0wff;
reconsider D403 = R23 as  0wff (string of R12) by L667;
reconsider D404 = ( D398 . D403 ) as  relational (Element of R12);
set D405 = ( abs ( ar D404 ) );
reconsider D406 = D404 as (Element of D397) by L18;
reconsider D407 = ( SubTerms D403 ) as ( D405 + ( 0 ) ) -element (Element of ( D400 * ));
L668: ( D400 \ ( D396 * ) ) = ( {} );
L669: (D396 c= D402 & D400 c= ( D396 * ) & D407 is D400 -valued) by L668 , XBOOLE_1:1 , XBOOLE_1:37;
L670: ( <* D406 *> ^ ( D401 . D407 ) ) = ( <* D404 *> ^ ( D399 . D407 ) ) by L669 , FOMODEL0:53
.= D403 by L444;
thus L671: thesis by L670;
end;
end;
registration
let R12 being Language;
cluster ( OwnSymbolsOf R12 ) -> non  empty for set;
coherence;
end;
theorem
L674: (for R12 being Language holds (for R32 being  0wff (string of R12) holds (( ( R12 -firstChar ) . R32 ) <> ( TheEqSymbOf R12 ) implies R32 is ( OwnSymbolsOf R12 ) -valued)))
proof
let R12 being Language;
let R32 being  0wff (string of R12);
set D408 = ( OwnSymbolsOf R12 );
set D409 = ( R12 -firstChar );
set D410 = ( D409 . R32 );
set D411 = ( R12 -multiCat );
set D412 = ( SubTerms R32 );
set D413 = ( TheEqSymbOf R12 );
set D414 = ( RelSymbolsOf R12 );
reconsider D415 = ( TermSymbolsOf R12 ) as non  empty (Subset of D408) by L83;
assume L675: D410 <> D413;
L676: (not D410 in { D413 }) by L675 , TARSKI:def 1;
L677: (not D410 in ( D414 \ D408 )) by L676 , L83;
L678: (D410 in D408 or (not D410 in D414)) by L677 , XBOOLE_0:def 5;
reconsider D416 = D410 as (Element of D408) by L678 , L15;
L679: ( D411 . D412 ) is D415 -valued by FOMODEL0:54;
reconsider D417 = ( D411 . D412 ) as D408 -valued FinSequence by L679;
L680: R32 = ( <* D416 *> ^ D417 ) by L444;
thus L681: thesis by L680;
end;
registration
cluster  strict non  empty for Language-like;
existence
proof
set D418 = the (Function of ( ( NAT ) \ { ( 0 ) } ) , ( INT ));
take D419 = Language-like (# ( NAT ) , ( 0 ) , ( 0 ) , D418 #);
thus L682: thesis;
end;
end;
definition
let C172 , C173 being Language-like;
attr C173 is C172 -extending
means
:L684: ((the adicity of C172) c= (the adicity of C173) & ( TheEqSymbOf C172 ) = ( TheEqSymbOf C173 ) & ( TheNorSymbOf C172 ) = ( TheNorSymbOf C173 ));
end;
registration
let R12 being Language;
cluster ( R12 null ) -> R12 -extending for Language-like;
coherence
proof
set D420 = ( TheEqSymbOf R12 );
set D421 = ( TheNorSymbOf R12 );
set D422 = (the adicity of R12);
L686: (D422 c= D422 & D420 = D420 & D421 = D421);
thus L687: thesis by L686 , L684;
end;
end;
registration
let R12 being Language;
cluster R12 -extending for Language;
existence
proof
reconsider D423 = ( R12 null ) as Language;
take D423;
thus L689: thesis;
end;
end;
registration
let R13 being Language;
let C174 being R13 -extending Language;
cluster ( ( OwnSymbolsOf R13 ) \ ( OwnSymbolsOf C174 ) ) ->  empty;
coherence
proof
set D424 = ( OwnSymbolsOf R13 );
set D425 = ( OwnSymbolsOf C174 );
set D426 = (the adicity of R13);
set D427 = (the adicity of C174);
set D428 = ( AtomicFormulaSymbolsOf R13 );
set D429 = ( AllSymbolsOf R13 );
set D430 = ( AllSymbolsOf C174 );
set D431 = (the ZeroF of R13);
set D432 = (the OneF of R13);
set D433 = (the ZeroF of C174);
set D434 = (the OneF of C174);
set D435 = ( TheEqSymbOf R13 );
set D436 = ( TheEqSymbOf C174 );
set D437 = ( TheNorSymbOf R13 );
set D438 = ( TheNorSymbOf C174 );
L691: (( dom D426 ) = ( D429 \ { D432 } ) & ( dom D427 ) = ( D430 \ { D434 } )) by FUNCT_2:def 1;
L692: D426 c= D427 by L684;
L693: ( D429 \ { D432 } ) c= ( D430 \ { D434 } ) by L692 , L691 , GRFUNC_1:2;
L694: ( ( D429 \ { D437 } ) \ { D435 } ) c= ( ( D430 \ { D438 } ) \ { D435 } ) by L693 , XBOOLE_1:33;
L695: ( D429 \ ( { D437 } \/ { D435 } ) ) c= ( ( D430 \ { D438 } ) \ { D435 } ) by L694 , XBOOLE_1:41;
L696: ( D429 \ { D437 , D435 } ) c= ( ( D430 \ { D438 } ) \ { D435 } ) by L695 , ENUMSET1:1;
L697: ( D429 \ { D437 , D435 } ) c= ( D430 \ ( { D438 } \/ { D435 } ) ) by L696 , XBOOLE_1:41;
L698: ( D429 \ { D437 , D435 } ) c= ( D430 \ ( { D438 } \/ { D436 } ) ) by L697 , L684;
L699: ( D429 \ { D437 , D435 } ) c= ( D430 \ { D438 , D436 } ) by L698 , ENUMSET1:1;
thus L700: thesis by L699;
end;
end;
definition
let C175 being ( INT ) -valued Function;
let C176 being non  empty Language-like;
set D439 = (the carrier of C176);
set D440 = (the ZeroF of C176);
set D441 = (the OneF of C176);
set D442 = (the adicity of C176);
set D443 = ( dom C175 );
set D444 = ( C175 | ( D443 \ { D441 } ) );
set D445 = ( D444 +* D442 );
set D446 = ( D439 \/ D443 );
func C176 extendWith C175 ->  strict non  empty Language-like means 
:L702: ((the adicity of it) = ( ( C175 | ( ( dom C175 ) \ { (the OneF of C176) } ) ) +* (the adicity of C176) ) & (the ZeroF of it) = (the ZeroF of C176) & (the OneF of it) = (the OneF of C176));
existence
proof
L703: D440 is (Element of ( D439 null D443 ));
reconsider D447 = D440 as (Element of D446) by L703 , TARSKI:def 3;
L704: D441 is (Element of ( D439 null D443 ));
reconsider D448 = D441 as (Element of D446) by L704 , TARSKI:def 3;
L705: ( dom D442 ) = ( D439 \ { D441 } ) by FUNCT_2:def 1;
L706: ( dom D444 ) = ( D443 /\ ( D443 \ { D441 } ) ) by RELAT_1:61
.= ( D443 \ ( { D441 } null D443 ) );
L707: ( dom D445 ) = ( ( D443 \ { D441 } ) \/ ( D439 \ { D441 } ) ) by L705 , L706 , FUNCT_4:def 1
.= ( ( D443 \/ D439 ) \ { D441 } ) by XBOOLE_1:42;
L708: (( dom D445 ) = ( D446 \ { D448 } ) & ( rng D445 ) c= ( INT )) by L707;
L709: D445 is (Element of ( Funcs (( D446 \ { D448 } ) , ( INT )) )) by L708 , FUNCT_2:def 2;
reconsider D449 = D445 as (Function of ( D446 \ { D448 } ) , ( INT )) by L709;
set D450 = Language-like (# D446 , D447 , D448 , D449 #);
reconsider D451 = D450 as  strict non  empty Language-like;
take D451;
thus L710: thesis;
end;
uniqueness
proof
let C177 , C178 being  strict non  empty Language-like;
set D452 = (the carrier of C177);
set D453 = (the ZeroF of C177);
set D454 = (the OneF of C177);
set D455 = (the adicity of C177);
set D456 = (the carrier of C178);
set D457 = (the ZeroF of C178);
set D458 = (the OneF of C178);
set D459 = (the adicity of C178);
set D460 = Language-like (# D452 , D453 , D454 , D455 #);
set D461 = Language-like (# D456 , D457 , D458 , D459 #);
reconsider D462 = D460 , D463 = D461 as non  empty Language-like;
defpred S9[ Language-like ] means ((the adicity of $1) = ( ( C175 | ( ( dom C175 ) \ { D441 } ) ) +* D442 ) & (the ZeroF of $1) = D440 & (the OneF of $1) = D441);
assume L711: (S9[ C177 ] & S9[ C178 ]);
L712: ( dom D455 ) = ( D456 \ { D454 } ) by L711 , FUNCT_2:def 1;
L713: ( ( D452 \ { D454 } ) \/ ( { D454 } null D452 ) ) = ( ( D456 \ { D458 } ) \/ ( { D458 } null D456 ) ) by L712 , L711 , FUNCT_2:def 1
.= D456 by FOMODEL0:48;
thus L714: thesis by L713 , L711 , FOMODEL0:48;
end;
end;
registration
let C179 being non  empty Language-like;
let C180 being ( INT ) -valued Function;
cluster ( C179 extendWith C180 ) -> C179 -extending;
coherence
proof
set D464 = C179;
set D465 = ( D464 extendWith C180 );
set D466 = (the adicity of D464);
set D467 = (the adicity of D465);
set D468 = (the OneF of D464);
L716: (( TheEqSymbOf D464 ) = ( TheEqSymbOf D465 ) & ( TheNorSymbOf D464 ) = ( TheNorSymbOf D465 )) by L702;
L717: D467 = ( ( C180 | ( ( dom C180 ) \ { D468 } ) ) +* D466 ) by L702;
L718: D466 c= D467 by L717 , FUNCT_4:25;
thus L719: thesis by L718 , L716 , L684;
end;
end;
registration
let C181 being non  degenerated Language-like;
cluster C181 -extending -> non  degenerated for Language-like;
coherence
proof
set D469 = C181;
let C182 being Language-like;
assume L721: C182 is C181 -extending;
L722: (( TheEqSymbOf D469 ) = ( TheEqSymbOf C182 ) & ( TheNorSymbOf D469 ) = ( TheNorSymbOf C182 )) by L721 , L684;
L723: (( 0. D469 ) = ( 0. C182 ) & ( 1. D469 ) = ( 1. C182 )) by L722;
thus L724: thesis by L723 , STRUCT_0:def 8;
end;
end;
registration
let C183 being  eligible Language-like;
cluster C183 -extending ->  eligible for Language-like;
coherence
proof
set D470 = C183;
let C184 being Language-like;
set D471 = ( LettersOf D470 );
set D472 = ( LettersOf C184 );
set D473 = ( AtomicFormulaSymbolsOf D470 );
set D474 = ( AtomicFormulaSymbolsOf C184 );
set D475 = (the adicity of D470);
set D476 = (the adicity of C184);
set D477 = ( TheEqSymbOf D470 );
set D478 = ( TheEqSymbOf C184 );
assume L726: C184 is D470 -extending;
L727: (( dom D475 ) = D473 & ( dom D476 ) = D474 & D477 = D478 & D475 c= D476) by L726 , L684 , FUNCT_2:def 1;
reconsider D479 = D475 as (Subset of D476) by L726 , L684;
L728: ( D479 " { ( 0 ) } ) c= ( D476 " { ( 0 ) } ) by RELAT_1:144;
reconsider D480 = D471 as (Subset of D472) by L728;
L729: ( D472 null D480 ) is  infinite;
thus L730: D472 is  infinite by L729;
L731: ( D475 . D477 ) = ( - 2 ) by L56;
L732: D477 in ( dom D475 ) by L731 , FUNCT_1:def 2;
L733: ( D475 . D477 ) = ( ( D476 +* D479 ) . D477 ) by L732 , FUNCT_4:13
.= ( D476 . D478 ) by L727 , FUNCT_4:98;
thus L734: ( D476 . D478 ) = ( - 2 ) by L733 , L56;
end;
end;
registration
let C185 being  empty Relation;
let R7 being set;
cluster ( R7 |` C185 ) ->  empty;
coherence by RELAT_1:107;
end;
L737: (for B54 being non  empty Language-like holds (for B55 being ( INT ) -valued Function holds (( LettersOf ( B54 extendWith B55 ) ) = ( ( ( B55 | ( ( dom B55 ) \ ( AllSymbolsOf B54 ) ) ) " { ( 0 ) } ) \/ ( LettersOf B54 ) ) & ( (the adicity of ( B54 extendWith B55 )) | ( OwnSymbolsOf B54 ) ) = ( (the adicity of B54) | ( OwnSymbolsOf B54 ) ))))
proof
let C186 being non  empty Language-like;
let C187 being ( INT ) -valued Function;
set D481 = ( C186 extendWith C187 );
set D482 = ( LettersOf C186 );
set D483 = (the adicity of C186);
set D484 = (the adicity of D481);
set D485 = (the ZeroF of C186);
set D486 = (the OneF of C186);
set D487 = ( ( dom C187 ) \ { D486 } );
set D488 = (the carrier of C186);
set D489 = ( OwnSymbolsOf C186 );
set D490 = ( LettersOf D481 );
set D491 = ( C187 | ( D487 \ ( dom D483 ) ) );
set D492 = ( AllSymbolsOf C186 );
L738: D488 = ( ( D488 \ { D486 } ) \/ ( { D486 } null D488 ) ) by FOMODEL0:48
.= ( ( dom D483 ) \/ { D486 } ) by FUNCT_2:def 1;
L739: D491 = ( C187 | ( ( dom C187 ) \ D488 ) ) by L738 , XBOOLE_1:41;
L740: ( ( C187 | ( ( dom C187 ) \ D488 ) ) \/ D483 ) = ( ( C187 | D487 ) +* D483 ) by L739 , FOMODEL0:57
.= D484 by L702;
thus L741: D490 = ( ( ( C187 | ( ( dom C187 ) \ D492 ) ) " { ( 0 ) } ) \/ D482 ) by L740 , FOMODEL0:23;
reconsider D493 = ( D489 /\ ( dom C187 ) ) as (Subset of D488) by XBOOLE_1:1;
thus L742: ( D484 | D489 ) = ( ( D483 | D489 ) \/ ( ( C187 | ( ( dom C187 ) \ D488 ) ) | D489 ) ) by L740 , FOMODEL0:56
.= ( ( D483 | D489 ) \/ ( C187 | ( D489 /\ ( ( dom C187 ) \ D488 ) ) ) ) by RELAT_1:71
.= ( ( D483 | D489 ) \/ ( C187 | ( ( D489 /\ ( dom C187 ) ) \ D488 ) ) ) by XBOOLE_1:49
.= ( ( D483 | D489 ) \/ ( C187 | ( D493 \ D488 ) ) )
.= ( D483 | D489 );
end;
registration
let R7 being set;
let C188 being  integer number;
cluster ( R7 --> C188 ) -> ( INT ) -valued;
coherence
proof
reconsider D494 = C188 as (Element of ( INT )) by INT_1:def 2;
L743: ( R7 --> C188 ) is { D494 } -valued;
thus L744: thesis by L743;
end;
end;
definition
let R12 being Language;
let C189 being  functional set;
func R12 addLettersNotIn C189 -> R12 -extending Language equals 
( R12 extendWith (( ( ( ( AllSymbolsOf R12 ) \/ ( SymbolsOf C189 ) ) -freeCountableSet ) --> ( 0 ) ) qua ( INT ) -valued Function) );
coherence;
end;
registration
let R13 being Language;
let C190 being  functional set;
cluster ( ( LettersOf ( R13 addLettersNotIn C190 ) ) \ ( SymbolsOf C190 ) ) ->  infinite;
coherence
proof
set D495 = ( LettersOf R13 );
set D496 = ( R13 addLettersNotIn C190 );
set D497 = ( SymbolsOf C190 );
set D498 = ( LettersOf D496 );
set D499 = ( D498 \ D497 );
set D500 = (the adicity of R13);
set D501 = (the adicity of D496);
set D502 = ( AllSymbolsOf R13 );
set D503 = ( ( D502 \/ D497 ) -freeCountableSet );
reconsider D504 = ( D503 --> ( 0 ) ) as ( INT ) -valued Function;
L747: (( 0 ) in { ( 0 ) } & ( dom ( D503 --> ( 0 ) ) ) = D503) by FUNCT_2:def 1 , TARSKI:def 1;
L748: ( D503 /\ ( D502 \/ D497 ) ) = ( {} );
L749: D503 misses ( D502 \/ D497 ) by L748 , XBOOLE_0:def 7;
L750: (D503 misses ( D502 null D497 ) & D503 misses ( D497 null D502 )) by L749 , XBOOLE_1:63;
L751: (( D503 \ D502 ) = D503 & ( D503 \ D497 ) = D503) by L750 , XBOOLE_1:83;
L752: D498 = ( ( ( D504 | ( ( dom D504 ) \ D502 ) ) " { ( 0 ) } ) \/ D495 ) by L737;
L753: D499 = ( ( ( ( ( D504 null ( {} ) ) | ( ( {} ) \/ ( dom D504 ) ) ) " { ( 0 ) } ) \ D497 ) \/ ( D495 \ D497 ) ) by L752 , L751 , L747 , XBOOLE_1:42
.= ( D503 \/ ( D495 \ D497 ) ) by L747 , L751 , FUNCOP_1:14;
thus L754: thesis by L753;
end;
end;
registration
cluster  countable for Language;
existence
proof
reconsider D505 = ( 0 ) , D506 = 1 as (Element of ( NAT ));
set D507 = ( ( NAT ) \ { D506 } );
L756: (D505 in ( NAT ) & (not D505 in { D506 })) by TARSKI:def 1;
reconsider D508 = D505 as (Element of D507) by L756 , XBOOLE_0:def 5;
reconsider D509 = ( D507 --> ( 0 ) ) , D510 = ( D508 .--> ( - 2 ) ) as ( INT ) -valued Function;
set D511 = ( D509 +* D510 );
L757: (D508 in { D508 } & ( dom D510 ) = { D508 } & ( dom D509 ) = D507) by FUNCOP_1:13 , TARSKI:def 1;
L758: ( dom D511 ) = ( D507 null { D508 } ) by L757 , FUNCT_4:def 1;
L759: (( rng D511 ) c= ( INT ) & ( dom D511 ) = D507) by L758;
L760: D511 is (Element of ( Funcs (D507 , ( INT )) )) by L759 , FUNCT_2:def 2;
reconsider D512 = D511 as (Function of D507 , ( INT )) by L760;
set D513 = Language-like (# ( NAT ) , D505 , D506 , D512 #);
L761: ( 0. D513 ) <> ( 1. D513 );
L762: ( D512 . D505 ) = ( D510 . D508 ) by L757 , FUNCT_4:13
.= ( - 2 ) by L757 , FUNCOP_1:7;
L763: ( D512 . ( TheEqSymbOf D513 ) ) = ( - 2 ) by L762;
L764:
now
let R9 being set;
assume L765: R9 in ( D507 \ { D505 } );
L766: (R9 in D507 & (not R9 in { D508 })) by L765 , XBOOLE_0:def 5;
L767: (R9 in ( dom D512 ) & (not R9 in ( dom D510 ))) by L766 , FUNCT_2:def 1;
L768: ( D512 . R9 ) = ( D509 . R9 ) by L767 , FUNCT_4:11
.= ( 0 ) by L765 , FUNCOP_1:7;
L769: (R9 in ( dom D512 ) & ( D512 . R9 ) in { ( 0 ) }) by L768 , L766 , FUNCT_2:def 1 , TARSKI:def 1;
thus L770: R9 in ( D512 " { ( 0 ) } ) by L769 , FUNCT_1:def 7;
end;
reconsider D514 = ( D507 \ { D505 } ) as (Subset of ( D512 " { ( 0 ) } )) by L764 , TARSKI:def 3;
L771: (D514 is  infinite & ( ( D512 " { ( 0 ) } ) \/ D514 ) = ( ( D512 " { ( 0 ) } ) null D514 ));
L772: ( LettersOf D513 ) is  infinite by L771;
reconsider D515 = D513 as Language by L772 , L761 , L763 , L56 , STRUCT_0:def 8;
take D515;
thus L773: thesis by ORDERS_4:def 2;
end;
end;
registration
let C191 being  countable Language;
cluster ( AllSymbolsOf C191 ) ->  countable;
coherence by ORDERS_4:def 2;
end;
registration
let C192 being  countable Language;
cluster ( ( ( AllSymbolsOf C192 ) * ) \ { ( {} ) } ) ->  countable;
coherence
proof
set D516 = ( AllSymbolsOf C192 );
reconsider D517 = ( D516 * ) as  countable set by CARD_4:13;
reconsider D518 = ( D517 \ { ( {} ) } ) as (Subset of D517);
L776: D518 is  countable;
thus L777: thesis by L776;
end;
end;
registration
let C193 being non  empty Language-like;
let C194 being ( INT ) -valued Function;
cluster ( ( AllSymbolsOf ( C193 extendWith C194 ) ) \+\ ( ( dom C194 ) \/ ( AllSymbolsOf C193 ) ) ) ->  empty for set;
coherence
proof
set D519 = C193;
set D520 = (the adicity of D519);
set D521 = ( AllSymbolsOf D519 );
set D522 = ( C193 extendWith C194 );
set D523 = ( AllSymbolsOf D522 );
set D524 = (the adicity of D522);
set D525 = ( dom C194 );
set D526 = ( TheEqSymbOf D519 );
set D527 = ( TheNorSymbOf D519 );
set D528 = ( TheEqSymbOf D522 );
set D529 = ( TheNorSymbOf D522 );
reconsider D530 = ( D525 \ { D527 } ) as (Subset of D525);
L779: ( dom ( C194 | ( D525 \ { D527 } ) ) ) = ( D525 /\ D530 ) by RELAT_1:61
.= D530;
L780: D524 = ( ( C194 | ( D525 \ { D527 } ) ) +* D520 ) by L702;
L781: ( dom D524 ) = ( ( dom ( C194 | D530 ) ) \/ ( dom D520 ) ) by L780 , FUNCT_4:def 1;
L782: ( D523 \ { D529 } ) = ( D530 \/ ( dom D520 ) ) by L781 , L779 , FUNCT_2:def 1
.= ( D530 \/ ( D521 \ { D527 } ) ) by FUNCT_2:def 1;
reconsider D531 = { D527 } as non  empty (Subset of D521) by ZFMISC_1:31;
reconsider D532 = { D529 } as non  empty (Subset of D523) by ZFMISC_1:31;
L783: (D531 c= D521 & ( D521 null D525 ) c= ( D521 \/ D525 ));
reconsider D533 = D531 as non  empty (Subset of ( D521 \/ D525 )) by L783 , XBOOLE_1:1;
L784: (D523 = ( D532 \/ ( D523 \ D532 ) ) & D521 = ( D531 \/ ( D521 \ D531 ) )) by XBOOLE_1:45;
L785: D523 = ( ( D532 \/ ( D521 \ D531 ) ) \/ D530 ) by L784 , L782 , XBOOLE_1:4
.= ( ( D531 \/ ( D521 \ D531 ) ) \/ D530 ) by L684
.= ( D531 \/ ( ( D521 \ D531 ) \/ D530 ) ) by XBOOLE_1:4
.= ( D533 \/ ( ( D521 \/ D525 ) \ D533 ) ) by XBOOLE_1:42
.= ( D521 \/ D525 ) by XBOOLE_1:45;
thus L786: thesis by L785;
end;
end;
registration
let C195 being  countable Language;
let C196 being  functional set;
cluster ( C195 addLettersNotIn C196 ) ->  countable for 1-sorted;
coherence
proof
set D534 = C195;
set D535 = ( AllSymbolsOf D534 );
set D536 = ( SymbolsOf C196 );
set D537 = ( ( D535 \/ D536 ) -freeCountableSet );
set D538 = ( D537 --> ( 0 ) );
set D539 = ( D534 extendWith D538 );
set D540 = ( AllSymbolsOf D539 );
L788: ( D540 \+\ ( ( dom D538 ) \/ D535 ) ) = ( {} );
L789: D540 = ( ( dom D538 ) \/ D535 ) by L788 , FOMODEL0:29
.= ( D537 \/ D535 ) by FUNCOP_1:13;
L790: D540 is  countable by L789 , CARD_2:85;
thus L791: thesis by L790 , ORDERS_4:def 2;
end;
end;
