:: Memory handling for SCM+FSA
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 18, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SCMFSA_2, XBOOLE_0, AMI_1, GRAPHSP, AMI_3, FINSEQ_1, FUNCT_1,
      SUBSET_1, FINSUB_1, SETWISEO, CARD_1, TARSKI, CARD_3, RELAT_1, ZFMISC_1,
      FINSET_1, NUMBERS, FUNCT_4, VALUED_1, ARYTM_3, AMISTD_2,
      XXREAL_0, SCMFSA6A, TURING_1, FSM_1, CIRCUIT2, STRUCT_0, ARYTM_1, INT_1,
      COMPLEX1, PARTFUN1, FINSEQ_2, NAT_1, SF_MASTR, ORDINAL1, RELOC, AMI_2,
      PBOOLE, SCMFSA6C, COMPOS_1, SCMPDS_4, EXTPRO_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, FINSET_1, FINSUB_1, ORDINAL1, NAT_1, INT_1, VALUED_1, STRUCT_0,
      SETWISEO, SEQ_4, CARD_3, FINSEQ_1, FINSEQ_2, RELAT_1, FUNCT_1, RELSET_1,
      PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE, FUNCT_7, MEMSTR_0, COMPOS_0,
      COMPOS_1, AMI_2, EXTPRO_1, AMI_3, SCMFSA_2, AMISTD_2, SCMFSA6A, INT_2,
      XXREAL_0, SCMFSA_M;
 constructors SETWISEO, INT_2, SEQ_4, AMI_3, SCMFSA6A, RELSET_1, VALUED_1,
      AMISTD_2, AMISTD_1, AMI_2, SCMFSA_1, CARD_5, PRE_POLY, DOMAIN_1, PBOOLE,
      FUNCT_7, MEMSTR_0, SCMFSA_M;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2, FINSET_1,
      FINSUB_1, NUMBERS, XREAL_0, INT_1, MEMBERED, CARD_3, SCMFSA_2, XBOOLE_0,
      XXREAL_2, VALUED_1, FINSEQ_1, AMISTD_2, AMI_3, SCMFSA10, COMPOS_1,
      EXTPRO_1, CARD_5, ZFMISC_1, AMI_2, CARD_1, PBOOLE, SCMFSA_4, MEMSTR_0,
      CARD_2, COMPOS_0, SCM_INST, SCMFSA_M;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions XBOOLE_0, FUNCOP_1, MEMSTR_0, EXTPRO_1, COMPOS_1, AMI_3, SCMFSA_2,
      SCMFSA6A, AMISTD_2, COMPOS_0;
 theorems TARSKI, ENUMSET1, ZFMISC_1, FINSEQ_1, FINSUB_1, SETWISEO, NAT_1,
      RELAT_1, GRFUNC_1, FUNCT_1, FUNCT_2, FUNCT_4, FUNCT_7, CARD_3, SCMFSA_2,
      SCMFSA_4, XBOOLE_0, XBOOLE_1, ORDINAL1, AMI_2, MEMSTR_0, AMI_3, VALUED_1,
      XXREAL_2, PARTFUN1, MCART_1, COMPOS_1, EXTPRO_1, COMPOS_0, SCM_INST,
      SCMFSA_M, XTUPLE_0;
 schemes NAT_1, DOMAIN_1, FUNCT_2;

begin
theorem
L1: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (( R4 := R6 ) = ( R5 := R7 ) implies (R4 = R5 & R6 = R7))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
assume L2: ( R4 := R6 ) = ( R5 := R7 );
consider C1 , C2 being Data-Location such that L3: (R4 = C1 & R6 = C2 & ( R4 := R6 ) = ( C1 := C2 )) by SCMFSA_2:def 8;
consider C3 , C4 being Data-Location such that L4: (R5 = C3 & R7 = C4 & ( R5 := R7 ) = ( C3 := C4 )) by SCMFSA_2:def 8;
L5: (( <* C3 , C4 *> . 1 ) = C3 & ( <* C3 , C4 *> . 2 ) = C4) by FINSEQ_1:44;
L6: (( <* C1 , C2 *> . 1 ) = C1 & ( <* C1 , C2 *> . 2 ) = C2) by FINSEQ_1:44;
thus L7: thesis by L6 , L2 , L3 , L4 , L5 , XTUPLE_0:3;
end;
theorem
L8: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (( AddTo (R4 , R6) ) = ( AddTo (R5 , R7) ) implies (R4 = R5 & R6 = R7))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
assume L9: ( AddTo (R4 , R6) ) = ( AddTo (R5 , R7) );
consider C5 , C6 being Data-Location such that L10: (R4 = C5 & R6 = C6 & ( AddTo (R4 , R6) ) = ( AddTo (C5 , C6) )) by SCMFSA_2:def 9;
consider C7 , C8 being Data-Location such that L11: (R5 = C7 & R7 = C8 & ( AddTo (R5 , R7) ) = ( AddTo (C7 , C8) )) by SCMFSA_2:def 9;
L12: (( <* C7 , C8 *> . 1 ) = C7 & ( <* C7 , C8 *> . 2 ) = C8) by FINSEQ_1:44;
L13: (( <* C5 , C6 *> . 1 ) = C5 & ( <* C5 , C6 *> . 2 ) = C6) by FINSEQ_1:44;
thus L14: thesis by L13 , L9 , L10 , L11 , L12 , XTUPLE_0:3;
end;
theorem
L15: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (( SubFrom (R4 , R6) ) = ( SubFrom (R5 , R7) ) implies (R4 = R5 & R6 = R7))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
assume L16: ( SubFrom (R4 , R6) ) = ( SubFrom (R5 , R7) );
consider C9 , C10 being Data-Location such that L17: (R4 = C9 & R6 = C10 & ( SubFrom (R4 , R6) ) = ( SubFrom (C9 , C10) )) by SCMFSA_2:def 10;
consider C11 , C12 being Data-Location such that L18: (R5 = C11 & R7 = C12 & ( SubFrom (R5 , R7) ) = ( SubFrom (C11 , C12) )) by SCMFSA_2:def 10;
L19: (( <* C11 , C12 *> . 1 ) = C11 & ( <* C11 , C12 *> . 2 ) = C12) by FINSEQ_1:44;
L20: (( <* C9 , C10 *> . 1 ) = C9 & ( <* C9 , C10 *> . 2 ) = C10) by FINSEQ_1:44;
thus L21: thesis by L20 , L16 , L17 , L18 , L19 , XTUPLE_0:3;
end;
theorem
L22: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (( MultBy (R4 , R6) ) = ( MultBy (R5 , R7) ) implies (R4 = R5 & R6 = R7))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
assume L23: ( MultBy (R4 , R6) ) = ( MultBy (R5 , R7) );
consider C13 , C14 being Data-Location such that L24: (R4 = C13 & R6 = C14 & ( MultBy (R4 , R6) ) = ( MultBy (C13 , C14) )) by SCMFSA_2:def 11;
consider C15 , C16 being Data-Location such that L25: (R5 = C15 & R7 = C16 & ( MultBy (R5 , R7) ) = ( MultBy (C15 , C16) )) by SCMFSA_2:def 11;
L26: (( <* C15 , C16 *> . 1 ) = C15 & ( <* C15 , C16 *> . 2 ) = C16) by FINSEQ_1:44;
L27: (( <* C13 , C14 *> . 1 ) = C13 & ( <* C13 , C14 *> . 2 ) = C14) by FINSEQ_1:44;
thus L28: thesis by L27 , L23 , L24 , L25 , L26 , XTUPLE_0:3;
end;
theorem
L29: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (( Divide (R4 , R6) ) = ( Divide (R5 , R7) ) implies (R4 = R5 & R6 = R7))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
assume L30: ( Divide (R4 , R6) ) = ( Divide (R5 , R7) );
consider C17 , C18 being Data-Location such that L31: (R4 = C17 & R6 = C18 & ( Divide (R4 , R6) ) = ( Divide (C17 , C18) )) by SCMFSA_2:def 12;
consider C19 , C20 being Data-Location such that L32: (R5 = C19 & R7 = C20 & ( Divide (R5 , R7) ) = ( Divide (C19 , C20) )) by SCMFSA_2:def 12;
L33: (( <* C19 , C20 *> . 1 ) = C19 & ( <* C19 , C20 *> . 2 ) = C20) by FINSEQ_1:44;
L34: (( <* C17 , C18 *> . 1 ) = C17 & ( <* C17 , C18 *> . 2 ) = C18) by FINSEQ_1:44;
thus L35: thesis by L34 , L30 , L31 , L32 , L33 , XTUPLE_0:3;
end;
theorem
L36: (for R9 being (Element of ( NAT )) holds (for R10 being (Element of ( NAT )) holds (( goto R9 ) = ( goto R10 ) implies R9 = R10)))
proof
let R9 being (Element of ( NAT ));
let R10 being (Element of ( NAT ));
assume L37: ( goto R9 ) = ( goto R10 );
L38: (( <* R9 *> . 1 ) = R9 & ( <* R10 *> . 1 ) = R10) by FINSEQ_1:40;
thus L39: thesis by L38 , L37 , XTUPLE_0:3;
end;
theorem
L40: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being (Element of ( NAT )) holds (for R10 being (Element of ( NAT )) holds (( R4 =0_goto R9 ) = ( R5 =0_goto R10 ) implies (R4 = R5 & R9 = R10))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being (Element of ( NAT ));
let R10 being (Element of ( NAT ));
assume L41: ( R4 =0_goto R9 ) = ( R5 =0_goto R10 );
consider C21 being Data-Location such that L42: (R4 = C21 & ( R4 =0_goto R9 ) = ( C21 =0_goto R9 )) by SCMFSA_2:def 14;
consider C22 being Data-Location such that L43: (R5 = C22 & ( R5 =0_goto R10 ) = ( C22 =0_goto R10 )) by SCMFSA_2:def 14;
L44: (( <* R10 *> . 1 ) = R10 & ( <* C22 *> . 1 ) = C22) by FINSEQ_1:40;
L45: (( <* R9 *> . 1 ) = R9 & ( <* C21 *> . 1 ) = C21) by FINSEQ_1:40;
thus L46: thesis by L45 , L41 , L42 , L43 , L44 , XTUPLE_0:3;
end;
theorem
L47: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R9 being (Element of ( NAT )) holds (for R10 being (Element of ( NAT )) holds (( R4 >0_goto R9 ) = ( R5 >0_goto R10 ) implies (R4 = R5 & R9 = R10))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R9 being (Element of ( NAT ));
let R10 being (Element of ( NAT ));
assume L48: ( R4 >0_goto R9 ) = ( R5 >0_goto R10 );
consider C23 being Data-Location such that L49: (R4 = C23 & ( R4 >0_goto R9 ) = ( C23 >0_goto R9 )) by SCMFSA_2:def 15;
consider C24 being Data-Location such that L50: (R5 = C24 & ( R5 >0_goto R10 ) = ( C24 >0_goto R10 )) by SCMFSA_2:def 15;
L51: (( <* R10 *> . 1 ) = R10 & ( <* C24 *> . 1 ) = C24) by FINSEQ_1:40;
L52: (( <* R9 *> . 1 ) = R9 & ( <* C23 *> . 1 ) = C23) by FINSEQ_1:40;
thus L53: thesis by L52 , L48 , L49 , L50 , L51 , XTUPLE_0:3;
end;
theorem
L54: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (for R13 being FinSeq-Location holds (for R14 being FinSeq-Location holds (( R6 := (R13 , R4) ) = ( R7 := (R14 , R5) ) implies (R4 = R5 & R6 = R7 & R13 = R14))))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
let R13 being FinSeq-Location;
let R14 being FinSeq-Location;
L55: (( <* R6 , R13 , R4 *> . 1 ) = R6 & ( <* R6 , R13 , R4 *> . 2 ) = R13) by FINSEQ_1:45;
L56: (( <* R6 , R13 , R4 *> . 3 ) = R4 & ( <* R7 , R14 , R5 *> . 1 ) = R7) by FINSEQ_1:45;
L57: (( <* R7 , R14 , R5 *> . 2 ) = R14 & ( <* R7 , R14 , R5 *> . 3 ) = R5) by FINSEQ_1:45;
assume L58: ( R6 := (R13 , R4) ) = ( R7 := (R14 , R5) );
thus L59: thesis by L58 , L55 , L56 , L57 , XTUPLE_0:3;
end;
theorem
L60: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R6 being Int-Location holds (for R7 being Int-Location holds (for R13 being FinSeq-Location holds (for R14 being FinSeq-Location holds (( (R13 , R4) := R6 ) = ( (R14 , R5) := R7 ) implies (R4 = R5 & R6 = R7 & R13 = R14))))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R6 being Int-Location;
let R7 being Int-Location;
let R13 being FinSeq-Location;
let R14 being FinSeq-Location;
L61: (( <* R6 , R13 , R4 *> . 1 ) = R6 & ( <* R6 , R13 , R4 *> . 2 ) = R13) by FINSEQ_1:45;
L62: (( <* R6 , R13 , R4 *> . 3 ) = R4 & ( <* R7 , R14 , R5 *> . 1 ) = R7) by FINSEQ_1:45;
L63: (( <* R7 , R14 , R5 *> . 2 ) = R14 & ( <* R7 , R14 , R5 *> . 3 ) = R5) by FINSEQ_1:45;
assume L64: ( (R13 , R4) := R6 ) = ( (R14 , R5) := R7 );
thus L65: thesis by L64 , L61 , L62 , L63 , XTUPLE_0:3;
end;
theorem
L66: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R13 being FinSeq-Location holds (for R14 being FinSeq-Location holds (( R4 :=len R13 ) = ( R5 :=len R14 ) implies (R4 = R5 & R13 = R14))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R13 being FinSeq-Location;
let R14 being FinSeq-Location;
L67: (( <* R4 , R13 *> . 1 ) = R4 & ( <* R4 , R13 *> . 2 ) = R13) by FINSEQ_1:44;
L68: (( <* R5 , R14 *> . 1 ) = R5 & ( <* R5 , R14 *> . 2 ) = R14) by FINSEQ_1:44;
assume L69: ( R4 :=len R13 ) = ( R5 :=len R14 );
thus L70: thesis by L69 , L67 , L68 , XTUPLE_0:3;
end;
theorem
L71: (for R4 being Int-Location holds (for R5 being Int-Location holds (for R13 being FinSeq-Location holds (for R14 being FinSeq-Location holds (( R13 :=<0,...,0> R4 ) = ( R14 :=<0,...,0> R5 ) implies (R4 = R5 & R13 = R14))))))
proof
let R4 being Int-Location;
let R5 being Int-Location;
let R13 being FinSeq-Location;
let R14 being FinSeq-Location;
L72: (( <* R4 , R13 *> . 1 ) = R4 & ( <* R4 , R13 *> . 2 ) = R13) by FINSEQ_1:44;
L73: (( <* R5 , R14 *> . 1 ) = R5 & ( <* R5 , R14 *> . 2 ) = R14) by FINSEQ_1:44;
assume L74: ( R13 :=<0,...,0> R4 ) = ( R14 :=<0,...,0> R5 );
thus L75: thesis by L74 , L72 , L73 , XTUPLE_0:3;
end;
begin
definition
let C25 being (Instruction of ( SCM+FSA ));
func UsedIntLoc C25 -> (Element of ( Fin ( Int-Locations ) )) means 
:L76: (ex B1 , B2 being Int-Location st ((C25 = ( B1 := B2 ) or C25 = ( AddTo (B1 , B2) ) or C25 = ( SubFrom (B1 , B2) ) or C25 = ( MultBy (B1 , B2) ) or C25 = ( Divide (B1 , B2) )) & it = { B1 , B2 })) if ( InsCode C25 ) in { 1 , 2 , 3 , 4 , 5 } , (ex B3 being Int-Location st (ex B4 being (Element of ( NAT )) st ((C25 = ( B3 =0_goto B4 ) or C25 = ( B3 >0_goto B4 )) & it = { B3 }))) if (( InsCode C25 ) = 7 or ( InsCode C25 ) = 8) , (ex B5 , B6 being Int-Location st (ex B7 being FinSeq-Location st ((C25 = ( B6 := (B7 , B5) ) or C25 = ( (B7 , B5) := B6 )) & it = { B5 , B6 }))) if (( InsCode C25 ) = 9 or ( InsCode C25 ) = 10) , (ex B8 being Int-Location st (ex B9 being FinSeq-Location st ((C25 = ( B8 :=len B9 ) or C25 = ( B9 :=<0,...,0> B8 )) & it = { B8 }))) if (( InsCode C25 ) = 11 or ( InsCode C25 ) = 12) otherwise it = ( {} );
existence
proof
thus L77:now
assume L78: ( InsCode C25 ) in { 1 , 2 , 3 , 4 , 5 };
L79: (( InsCode C25 ) = 1 or ( InsCode C25 ) = 2 or ( InsCode C25 ) = 3 or ( InsCode C25 ) = 4 or ( InsCode C25 ) = 5) by L78 , ENUMSET1:def 3;
consider C26 , C27 being Int-Location such that L80: (C25 = ( C26 := C27 ) or C25 = ( AddTo (C26 , C27) ) or C25 = ( SubFrom (C26 , C27) ) or C25 = ( MultBy (C26 , C27) ) or C25 = ( Divide (C26 , C27) )) by L79 , SCMFSA_2:30 , SCMFSA_2:31 , SCMFSA_2:32 , SCMFSA_2:33 , SCMFSA_2:34;
reconsider D1 = C26 , D2 = C27 as (Element of ( Int-Locations )) by AMI_2:def 16;
reconsider D3 = {. D1 , D2 .} as (Element of ( Fin ( Int-Locations ) ));
take D4 = D3;
take D5 = C26;
take D6 = C27;
thus L81: ((C25 = ( D5 := D6 ) or C25 = ( AddTo (D5 , D6) ) or C25 = ( SubFrom (D5 , D6) ) or C25 = ( MultBy (D5 , D6) ) or C25 = ( Divide (D5 , D6) )) & D4 = { D5 , D6 }) by L80;
end;
thus L82:now
assume L83: (( InsCode C25 ) = 7 or ( InsCode C25 ) = 8);
consider C28 being (Element of ( NAT )), C29 being Int-Location such that L84: (C25 = ( C29 =0_goto C28 ) or C25 = ( C29 >0_goto C28 )) by L83 , SCMFSA_2:36 , SCMFSA_2:37;
reconsider D7 = C29 as (Element of ( Int-Locations )) by AMI_2:def 16;
reconsider D8 = {. D7 .} as (Element of ( Fin ( Int-Locations ) ));
take D9 = D8;
take D10 = C29;
take D11 = C28;
thus L85: ((C25 = ( D10 =0_goto D11 ) or C25 = ( D10 >0_goto D11 )) & D9 = { D10 }) by L84;
end;
thus L86:now
assume L87: (( InsCode C25 ) = 9 or ( InsCode C25 ) = 10);
consider C30 , C31 being Int-Location, C32 being FinSeq-Location such that L88: (C25 = ( C31 := (C32 , C30) ) or C25 = ( (C32 , C30) := C31 )) by L87 , SCMFSA_2:38 , SCMFSA_2:39;
reconsider D12 = C30 , D13 = C31 as (Element of ( Int-Locations )) by AMI_2:def 16;
reconsider D14 = {. D12 , D13 .} as (Element of ( Fin ( Int-Locations ) ));
take D15 = D14;
take D16 = C30;
take D17 = C31;
take D18 = C32;
thus L89: ((C25 = ( D17 := (D18 , D16) ) or C25 = ( (D18 , D16) := D17 )) & D15 = { D16 , D17 }) by L88;
end;
thus L90:now
assume L91: (( InsCode C25 ) = 11 or ( InsCode C25 ) = 12);
consider C33 being Int-Location, C34 being FinSeq-Location such that L92: (C25 = ( C33 :=len C34 ) or C25 = ( C34 :=<0,...,0> C33 )) by L91 , SCMFSA_2:40 , SCMFSA_2:41;
reconsider D19 = C33 as (Element of ( Int-Locations )) by AMI_2:def 16;
reconsider D20 = {. D19 .} as (Element of ( Fin ( Int-Locations ) ));
take D21 = D20;
take D22 = C33;
take D23 = C34;
thus L93: ((C25 = ( D22 :=len D23 ) or C25 = ( D23 :=<0,...,0> D22 )) & D21 = { D22 }) by L92;
end;
L94: ( {} ) in ( Fin ( Int-Locations ) ) by FINSUB_1:7;
thus L95: thesis by L94;
end;
uniqueness
proof
let C35 , C36 being (Element of ( Fin ( Int-Locations ) ));
thus L96:now
assume L97: ( InsCode C25 ) in { 1 , 2 , 3 , 4 , 5 };
given C37 , C38 being Int-Location such that
L98: (C25 = ( C37 := C38 ) or C25 = ( AddTo (C37 , C38) ) or C25 = ( SubFrom (C37 , C38) ) or C25 = ( MultBy (C37 , C38) ) or C25 = ( Divide (C37 , C38) ))
and
L99: C35 = { C37 , C38 };

given C39 , C40 being Int-Location such that
L100: (C25 = ( C39 := C40 ) or C25 = ( AddTo (C39 , C40) ) or C25 = ( SubFrom (C39 , C40) ) or C25 = ( MultBy (C39 , C40) ) or C25 = ( Divide (C39 , C40) ))
and
L101: C36 = { C39 , C40 };

L102: ((C25 = ( AddTo (C37 , C38) ) or C25 = ( AddTo (C39 , C40) )) implies ( InsCode C25 ) = 2) by SCMFSA_2:19;
L103: ((C25 = ( Divide (C37 , C38) ) or C25 = ( Divide (C39 , C40) )) implies ( InsCode C25 ) = 5) by SCMFSA_2:22;
L104: ((C25 = ( MultBy (C37 , C38) ) or C25 = ( MultBy (C39 , C40) )) implies ( InsCode C25 ) = 4) by SCMFSA_2:21;
L105: ((C25 = ( SubFrom (C37 , C38) ) or C25 = ( SubFrom (C39 , C40) )) implies ( InsCode C25 ) = 3) by SCMFSA_2:20;
per cases  by L98 , L100 , L102 , L105 , L104 , L103 , SCMFSA_2:18;
suppose L106: (C25 = ( C37 := C38 ) & C25 = ( C39 := C40 ));

L107: C37 = C39 by L106 , L1;
thus L108: C35 = C36 by L107 , L99 , L101 , L106 , L1;
end;
suppose L109: (C25 = ( AddTo (C37 , C38) ) & C25 = ( AddTo (C39 , C40) ));

L110: C37 = C39 by L109 , L8;
thus L111: C35 = C36 by L110 , L99 , L101 , L109 , L8;
end;
suppose L112: (C25 = ( SubFrom (C37 , C38) ) & C25 = ( SubFrom (C39 , C40) ));

L113: C37 = C39 by L112 , L15;
thus L114: C35 = C36 by L113 , L99 , L101 , L112 , L15;
end;
suppose L115: (C25 = ( MultBy (C37 , C38) ) & C25 = ( MultBy (C39 , C40) ));

L116: C37 = C39 by L115 , L22;
thus L117: C35 = C36 by L116 , L99 , L101 , L115 , L22;
end;
suppose L118: (C25 = ( Divide (C37 , C38) ) & C25 = ( Divide (C39 , C40) ));

L119: C37 = C39 by L118 , L29;
thus L120: C35 = C36 by L119 , L99 , L101 , L118 , L29;
end;
end;
thus L122:now
assume L123: (( InsCode C25 ) = 7 or ( InsCode C25 ) = 8);
given C41 being Int-Location , C42 being (Element of ( NAT )) such that
L124: (C25 = ( C41 =0_goto C42 ) or C25 = ( C41 >0_goto C42 ))
and
L125: C35 = { C41 };

given C43 being Int-Location , C44 being (Element of ( NAT )) such that
L126: (C25 = ( C43 =0_goto C44 ) or C25 = ( C43 >0_goto C44 ))
and
L127: C36 = { C43 };

L128: ((C25 = ( C41 >0_goto C42 ) or C25 = ( C43 >0_goto C44 )) implies ( InsCode C25 ) = 8) by SCMFSA_2:25;
per cases  by L124 , L126 , L128 , SCMFSA_2:24;
suppose L129: (C25 = ( C41 =0_goto C42 ) & C25 = ( C43 =0_goto C44 ));

thus L130: C35 = C36 by L129 , L125 , L127 , L40;
end;
suppose L131: (C25 = ( C41 >0_goto C42 ) & C25 = ( C43 >0_goto C44 ));

thus L132: C35 = C36 by L131 , L125 , L127 , L47;
end;
end;
thus L134:now
assume L135: (( InsCode C25 ) = 9 or ( InsCode C25 ) = 10);
given C45 , C46 being Int-Location , C47 being FinSeq-Location such that
L136: (C25 = ( C46 := (C47 , C45) ) or C25 = ( (C47 , C45) := C46 ))
and
L137: C35 = { C45 , C46 };

given C48 , C49 being Int-Location , C50 being FinSeq-Location such that
L138: (C25 = ( C49 := (C50 , C48) ) or C25 = ( (C50 , C48) := C49 ))
and
L139: C36 = { C48 , C49 };

L140: ((C25 = ( (C47 , C45) := C46 ) or C25 = ( (C50 , C48) := C49 )) implies ( InsCode C25 ) = 10) by SCMFSA_2:27;
per cases  by L136 , L138 , L140 , SCMFSA_2:26;
suppose L141: (C25 = ( C46 := (C47 , C45) ) & C25 = ( C49 := (C50 , C48) ));

L142: C45 = C48 by L141 , L54;
thus L143: C35 = C36 by L142 , L137 , L139 , L141 , L54;
end;
suppose L144: (C25 = ( (C47 , C45) := C46 ) & C25 = ( (C50 , C48) := C49 ));

L145: C45 = C48 by L144 , L60;
thus L146: C35 = C36 by L145 , L137 , L139 , L144 , L60;
end;
end;
thus L148:now
assume L149: (( InsCode C25 ) = 11 or ( InsCode C25 ) = 12);
given C51 being Int-Location , C52 being FinSeq-Location such that
L150: (C25 = ( C51 :=len C52 ) or C25 = ( C52 :=<0,...,0> C51 ))
and
L151: C35 = { C51 };

given C53 being Int-Location , C54 being FinSeq-Location such that
L152: (C25 = ( C53 :=len C54 ) or C25 = ( C54 :=<0,...,0> C53 ))
and
L153: C36 = { C53 };

L154: ((C25 = ( C52 :=<0,...,0> C51 ) or C25 = ( C54 :=<0,...,0> C53 )) implies ( InsCode C25 ) = 12) by SCMFSA_2:29;
per cases  by L150 , L152 , L154 , SCMFSA_2:28;
suppose L155: (C25 = ( C51 :=len C52 ) & C25 = ( C53 :=len C54 ));

thus L156: C35 = C36 by L155 , L151 , L153 , L66;
end;
suppose L157: (C25 = ( C52 :=<0,...,0> C51 ) & C25 = ( C54 :=<0,...,0> C53 ));

thus L158: C35 = C36 by L157 , L151 , L153 , L71;
end;
end;
thus L160: thesis;
end;
consistency by ENUMSET1:def 3;
end;
theorem
L162: ( UsedIntLoc ( halt ( SCM+FSA ) ) ) = ( {} )
proof
L163: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L164: (not ( 0 ) in { 1 , 2 , 3 , 4 , 5 });
thus L165: thesis by L164 , L76 , L163;
end;
theorem
L166: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( R1 := R2 ) or R15 = ( AddTo (R1 , R2) ) or R15 = ( SubFrom (R1 , R2) ) or R15 = ( MultBy (R1 , R2) ) or R15 = ( Divide (R1 , R2) )) implies ( UsedIntLoc R15 ) = { R1 , R2 }))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R15 being (Instruction of ( SCM+FSA ));
reconsider D24 = { R1 , R2 } as (Element of ( Fin ( Int-Locations ) )) by FINSUB_1:def 5;
assume L167: (R15 = ( R1 := R2 ) or R15 = ( AddTo (R1 , R2) ) or R15 = ( SubFrom (R1 , R2) ) or R15 = ( MultBy (R1 , R2) ) or R15 = ( Divide (R1 , R2) ));
L168: (( InsCode R15 ) = 1 or ( InsCode R15 ) = 2 or ( InsCode R15 ) = 3 or ( InsCode R15 ) = 4 or ( InsCode R15 ) = 5) by L167 , SCMFSA_2:18 , SCMFSA_2:19 , SCMFSA_2:20 , SCMFSA_2:21 , SCMFSA_2:22;
L169: ( InsCode R15 ) in { 1 , 2 , 3 , 4 , 5 } by L168 , ENUMSET1:def 3;
L170: ( UsedIntLoc R15 ) = D24 by L169 , L167 , L76;
thus L171: thesis by L170;
end;
theorem
L172: (for R8 being (Element of ( NAT )) holds ( UsedIntLoc ( goto R8 ) ) = ( {} ))
proof
let R8 being (Element of ( NAT ));
L173: (( InsCode ( goto R8 ) ) = 6 & (not 6 in { 1 , 2 , 3 , 4 , 5 })) by ENUMSET1:def 3 , SCMFSA_2:23;
thus L174: thesis by L173 , L76;
end;
theorem
L175: (for R1 being Int-Location holds (for R8 being (Element of ( NAT )) holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( R1 =0_goto R8 ) or R15 = ( R1 >0_goto R8 )) implies ( UsedIntLoc R15 ) = { R1 }))))
proof
let R1 being Int-Location;
let R8 being (Element of ( NAT ));
let R15 being (Instruction of ( SCM+FSA ));
reconsider D25 = { R1 } as (Element of ( Fin ( Int-Locations ) )) by FINSUB_1:def 5;
assume L176: (R15 = ( R1 =0_goto R8 ) or R15 = ( R1 >0_goto R8 ));
L177: (( InsCode R15 ) = 7 or ( InsCode R15 ) = 8) by L176 , SCMFSA_2:24 , SCMFSA_2:25;
L178: ( UsedIntLoc R15 ) = D25 by L177 , L176 , L76;
thus L179: thesis by L178;
end;
theorem
L180: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R11 being FinSeq-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( R2 := (R11 , R1) ) or R15 = ( (R11 , R1) := R2 )) implies ( UsedIntLoc R15 ) = { R1 , R2 })))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R11 being FinSeq-Location;
let R15 being (Instruction of ( SCM+FSA ));
reconsider D26 = { R1 , R2 } as (Element of ( Fin ( Int-Locations ) )) by FINSUB_1:def 5;
assume L181: (R15 = ( R2 := (R11 , R1) ) or R15 = ( (R11 , R1) := R2 ));
L182: (( InsCode R15 ) = 9 or ( InsCode R15 ) = 10) by L181 , SCMFSA_2:26 , SCMFSA_2:27;
L183: ( UsedIntLoc R15 ) = D26 by L182 , L181 , L76;
thus L184: thesis by L183;
end;
theorem
L185: (for R1 being Int-Location holds (for R11 being FinSeq-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( R1 :=len R11 ) or R15 = ( R11 :=<0,...,0> R1 )) implies ( UsedIntLoc R15 ) = { R1 }))))
proof
let R1 being Int-Location;
let R11 being FinSeq-Location;
let R15 being (Instruction of ( SCM+FSA ));
reconsider D27 = { R1 } as (Element of ( Fin ( Int-Locations ) )) by FINSUB_1:def 5;
assume L186: (R15 = ( R1 :=len R11 ) or R15 = ( R11 :=<0,...,0> R1 ));
L187: (( InsCode R15 ) = 11 or ( InsCode R15 ) = 12) by L186 , SCMFSA_2:28 , SCMFSA_2:29;
L188: ( UsedIntLoc R15 ) = D27 by L187 , L186 , L76;
thus L189: thesis by L188;
end;
definition
let C55 being Function;
func UsedIntLoc C55 -> (Subset of ( Int-Locations )) means 
:L190: (ex B10 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) st ((for B11 being (Instruction of ( SCM+FSA )) holds ( B10 . B11 ) = ( UsedIntLoc B11 )) & it = ( Union ( B10 * C55 ) )));
existence
proof
defpred S1[ set , set ] means (ex B12 being (Instruction of ( SCM+FSA )) st ($1 = B12 & $2 = ( UsedIntLoc B12 )));
L191: (for B13 being (Element of (the InstructionsF of ( SCM+FSA ))) holds (ex B14 being (Element of ( Fin ( Int-Locations ) )) st S1[ B13 , B14 ]))
proof
let C56 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D28 = C56 as (Instruction of ( SCM+FSA ));
reconsider D29 = ( UsedIntLoc D28 ) as (Element of ( Fin ( Int-Locations ) ));
take D29;
take D28;
thus L192: thesis;
end;
consider C57 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L193: (for B15 being (Element of (the InstructionsF of ( SCM+FSA ))) holds S1[ B15 , ( C57 . B15 ) ]) from FUNCT_2:sch 3(L191);
set D30 = ( Union ( C57 * C55 ) );
set D31 = ( dom C55 );
set D32 = ( C57 * C55 );
take D30;
L194: ( Fin ( Int-Locations ) ) c= ( bool ( Int-Locations ) ) by FINSUB_1:13;
L195: (( rng D32 ) c= ( rng C57 ) & ( rng C57 ) c= ( bool ( Int-Locations ) )) by L194 , RELAT_1:26 , XBOOLE_1:1;
L196: ( rng D32 ) c= ( bool ( Int-Locations ) ) by L195 , XBOOLE_1:1;
L197: (D30 = ( union ( rng D32 ) ) & ( union ( rng D32 ) ) c= ( union ( bool ( Int-Locations ) ) )) by L196 , CARD_3:def 4 , ZFMISC_1:77;
thus L198: D30 is (Subset of ( Int-Locations )) by L197 , ZFMISC_1:81;
take C57;
thus L199:now
let C58 being (Instruction of ( SCM+FSA ));
L200: S1[ C58 , ( C57 . C58 ) ] by L193;
thus L201: ( C57 . C58 ) = ( UsedIntLoc C58 ) by L200;
end;
thus L202: thesis;
end;
uniqueness
proof
let C59 , C60 being (Subset of ( Int-Locations ));
given C61 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that
L203: (for B16 being (Instruction of ( SCM+FSA )) holds ( C61 . B16 ) = ( UsedIntLoc B16 ))
and
L204: C59 = ( Union ( C61 * C55 ) );

given C62 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that
L205: (for B17 being (Instruction of ( SCM+FSA )) holds ( C62 . B17 ) = ( UsedIntLoc B17 ))
and
L206: C60 = ( Union ( C62 * C55 ) );

L207: (for B18 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C61 . B18 ) = ( C62 . B18 ))
proof
let C63 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D33 = C63 as (Instruction of ( SCM+FSA ));
thus L208: ( C61 . C63 ) = ( UsedIntLoc D33 ) by L203
.= ( C62 . C63 ) by L205;
end;
thus L209: thesis by L207 , L204 , L206 , FUNCT_2:63;
end;
end;
registration
let C64 being (preProgram of ( SCM+FSA ));
cluster ( UsedIntLoc C64 ) ->  finite;
coherence
proof
reconsider D34 = ( dom C64 ) as  finite set;
consider C65 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L211: (for B19 being (Instruction of ( SCM+FSA )) holds ( C65 . B19 ) = ( UsedIntLoc B19 )) and L212: ( UsedIntLoc C64 ) = ( Union ( C65 * C64 ) ) by L190;
L213: ( rng C64 ) c= (the InstructionsF of ( SCM+FSA ));
reconsider D35 = C64 as (Function of D34 , (the InstructionsF of ( SCM+FSA ))) by L213 , FUNCT_2:2;
reconsider D36 = ( C65 * D35 ) as (Function of D34 , ( Fin ( Int-Locations ) ));
L214: ( Union D36 ) is  finite;
thus L215: thesis by L214 , L212;
end;
end;
theorem
L217: (for R15 being (Instruction of ( SCM+FSA )) holds (for R17 being (preProgram of ( SCM+FSA )) holds (R15 in ( rng R17 ) implies ( UsedIntLoc R15 ) c= ( UsedIntLoc R17 ))))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R17 being (preProgram of ( SCM+FSA ));
assume L218: R15 in ( rng R17 );
consider C66 being set such that L219: (C66 in ( dom R17 ) & R15 = ( R17 . C66 )) by L218 , FUNCT_1:def 3;
consider C67 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L220: (for B20 being (Instruction of ( SCM+FSA )) holds ( C67 . B20 ) = ( UsedIntLoc B20 )) and L221: ( UsedIntLoc R17 ) = ( Union ( C67 * R17 ) ) by L190;
L222: ( UsedIntLoc R17 ) = ( union ( rng ( C67 * R17 ) ) ) by L221 , CARD_3:def 4;
L223: ( dom C67 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L224: C66 in ( dom ( C67 * R17 ) ) by L223 , L219 , FUNCT_1:11;
L225: ( ( C67 * R17 ) . C66 ) in ( rng ( C67 * R17 ) ) by L224 , FUNCT_1:def 3;
L226: ( ( C67 * R17 ) . C66 ) = ( C67 . R15 ) by L219 , FUNCT_1:13
.= ( UsedIntLoc R15 ) by L220;
thus L227: thesis by L226 , L225 , L222 , ZFMISC_1:74;
end;
theorem
L228: (for R17 being (preProgram of ( SCM+FSA )) holds (for R18 being (preProgram of ( SCM+FSA )) holds ( UsedIntLoc ( R17 +* R18 ) ) c= ( ( UsedIntLoc R17 ) \/ ( UsedIntLoc R18 ) )))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R18 being (preProgram of ( SCM+FSA ));
consider C68 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L229: (for B21 being (Instruction of ( SCM+FSA )) holds ( C68 . B21 ) = ( UsedIntLoc B21 )) and L230: ( UsedIntLoc ( R17 +* R18 ) ) = ( Union ( C68 * ( R17 +* R18 ) ) ) by L190;
consider C69 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L231: (for B22 being (Instruction of ( SCM+FSA )) holds ( C69 . B22 ) = ( UsedIntLoc B22 )) and L232: ( UsedIntLoc R17 ) = ( Union ( C69 * R17 ) ) by L190;
L233: (for B23 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C68 . B23 ) = ( C69 . B23 ))
proof
let C70 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D37 = C70 as (Instruction of ( SCM+FSA ));
thus L234: ( C68 . C70 ) = ( UsedIntLoc D37 ) by L229
.= ( C69 . C70 ) by L231;
end;
L235: C68 = C69 by L233 , FUNCT_2:63;
consider C71 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L236: (for B24 being (Instruction of ( SCM+FSA )) holds ( C71 . B24 ) = ( UsedIntLoc B24 )) and L237: ( UsedIntLoc R18 ) = ( Union ( C71 * R18 ) ) by L190;
L238: (for B25 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C68 . B25 ) = ( C71 . B25 ))
proof
let C72 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D38 = C72 as (Instruction of ( SCM+FSA ));
thus L239: ( C68 . C72 ) = ( UsedIntLoc D38 ) by L229
.= ( C71 . C72 ) by L236;
end;
L240: C68 = C71 by L238 , FUNCT_2:63;
L241: ( dom C68 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L242: ( rng R18 ) c= ( dom C68 ) by L241;
L243: ( C68 * ( R17 +* R18 ) ) = ( ( C68 * R17 ) +* ( C68 * R18 ) ) by L242 , FUNCT_7:9;
L244: (( Union ( C68 * R18 ) ) = ( union ( rng ( C68 * R18 ) ) ) & ( union ( rng ( C68 * ( R17 +* R18 ) ) ) ) c= ( union ( ( rng ( C68 * R17 ) ) \/ ( rng ( C68 * R18 ) ) ) )) by L243 , CARD_3:def 4 , FUNCT_4:17 , ZFMISC_1:77;
L245: (( Union ( C68 * ( R17 +* R18 ) ) ) = ( union ( rng ( C68 * ( R17 +* R18 ) ) ) ) & ( Union ( C68 * R17 ) ) = ( union ( rng ( C68 * R17 ) ) )) by CARD_3:def 4;
thus L246: thesis by L245 , L230 , L232 , L237 , L235 , L240 , L244 , ZFMISC_1:78;
end;
theorem
L247: (for R17 being (preProgram of ( SCM+FSA )) holds (for R18 being (preProgram of ( SCM+FSA )) holds (( dom R17 ) misses ( dom R18 ) implies ( UsedIntLoc ( R17 +* R18 ) ) = ( ( UsedIntLoc R17 ) \/ ( UsedIntLoc R18 ) ))))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R18 being (preProgram of ( SCM+FSA ));
consider C73 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L248: (for B26 being (Instruction of ( SCM+FSA )) holds ( C73 . B26 ) = ( UsedIntLoc B26 )) and L249: ( UsedIntLoc ( R17 +* R18 ) ) = ( Union ( C73 * ( R17 +* R18 ) ) ) by L190;
assume L250: ( dom R17 ) misses ( dom R18 );
L251: (( dom ( C73 * R17 ) ) c= ( dom R17 ) & ( dom R17 ) misses ( dom ( C73 * R18 ) )) by L250 , RELAT_1:25 , XBOOLE_1:63;
L252: ( ( C73 * R17 ) +* ( C73 * R18 ) ) = ( ( C73 * R17 ) \/ ( C73 * R18 ) ) by L251 , FUNCT_4:31 , XBOOLE_1:63;
L253: ( dom C73 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L254: ( rng R18 ) c= ( dom C73 ) by L253;
L255: ( C73 * ( R17 +* R18 ) ) = ( ( C73 * R17 ) +* ( C73 * R18 ) ) by L254 , FUNCT_7:9;
L256: (( Union ( C73 * R18 ) ) = ( union ( rng ( C73 * R18 ) ) ) & ( union ( rng ( C73 * ( R17 +* R18 ) ) ) ) = ( union ( ( rng ( C73 * R17 ) ) \/ ( rng ( C73 * R18 ) ) ) )) by L255 , L252 , CARD_3:def 4 , RELAT_1:12;
consider C74 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L257: (for B27 being (Instruction of ( SCM+FSA )) holds ( C74 . B27 ) = ( UsedIntLoc B27 )) and L258: ( UsedIntLoc R17 ) = ( Union ( C74 * R17 ) ) by L190;
L259: (for B28 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C73 . B28 ) = ( C74 . B28 ))
proof
let C75 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D39 = C75 as (Instruction of ( SCM+FSA ));
thus L260: ( C73 . C75 ) = ( UsedIntLoc D39 ) by L248
.= ( C74 . C75 ) by L257;
end;
L261: C73 = C74 by L259 , FUNCT_2:63;
consider C76 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L262: (for B29 being (Instruction of ( SCM+FSA )) holds ( C76 . B29 ) = ( UsedIntLoc B29 )) and L263: ( UsedIntLoc R18 ) = ( Union ( C76 * R18 ) ) by L190;
L264: (for B30 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C73 . B30 ) = ( C76 . B30 ))
proof
let C77 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D40 = C77 as (Instruction of ( SCM+FSA ));
thus L265: ( C73 . C77 ) = ( UsedIntLoc D40 ) by L248
.= ( C76 . C77 ) by L262;
end;
L266: C73 = C76 by L264 , FUNCT_2:63;
L267: (( Union ( C73 * ( R17 +* R18 ) ) ) = ( union ( rng ( C73 * ( R17 +* R18 ) ) ) ) & ( Union ( C73 * R17 ) ) = ( union ( rng ( C73 * R17 ) ) )) by CARD_3:def 4;
thus L268: thesis by L267 , L249 , L258 , L263 , L261 , L266 , L256 , ZFMISC_1:78;
end;
theorem
L269: (for R17 being (preProgram of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedIntLoc R17 ) = ( UsedIntLoc ( Shift (R17 , R21) ) )))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
set D41 = ( Shift (R17 , R21) );
consider C78 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L270: (for B31 being (Instruction of ( SCM+FSA )) holds ( C78 . B31 ) = ( UsedIntLoc B31 )) and L271: ( UsedIntLoc R17 ) = ( Union ( C78 * R17 ) ) by L190;
consider C79 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L272: (for B32 being (Instruction of ( SCM+FSA )) holds ( C79 . B32 ) = ( UsedIntLoc B32 )) and L273: ( UsedIntLoc ( Shift (R17 , R21) ) ) = ( Union ( C79 * ( Shift (R17 , R21) ) ) ) by L190;
L274: (for B33 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C78 . B33 ) = ( C79 . B33 ))
proof
let C80 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D42 = C80 as (Instruction of ( SCM+FSA ));
thus L275: ( C78 . C80 ) = ( UsedIntLoc D42 ) by L270
.= ( C79 . C80 ) by L272;
end;
L276: C78 = C79 by L274 , FUNCT_2:63;
L277: ( dom D41 ) = { ( B34 + R21 ) where B34 is (Element of ( NAT )) : B34 in ( dom R17 ) } by VALUED_1:def 12;
L278:
now
let C81 being set;
thus L279:now
assume L280: C81 in ( rng D41 );
consider C82 being set such that L281: C82 in ( dom D41 ) and L282: C81 = ( D41 . C82 ) by L280 , FUNCT_1:def 3;
consider C83 being (Element of ( NAT )) such that L283: C82 = ( C83 + R21 ) and L284: C83 in ( dom R17 ) by L277 , L281;
L285: ( D41 . C82 ) = ( R17 . C83 ) by L283 , L284 , VALUED_1:def 12;
thus L286: C81 in ( rng R17 ) by L285 , L282 , L284 , FUNCT_1:def 3;
end;
assume L287: C81 in ( rng R17 );
consider C84 being set such that L288: C84 in ( dom R17 ) and L289: C81 = ( R17 . C84 ) by L287 , FUNCT_1:def 3;
reconsider D43 = C84 as (Element of ( NAT )) by L288;
reconsider D44 = D43 as (Element of ( NAT ));
L290: (( D44 + R21 ) in ( dom D41 ) & ( D41 . ( D44 + R21 ) ) = ( R17 . D44 )) by L277 , L288 , VALUED_1:def 12;
thus L291: C81 in ( rng D41 ) by L290 , L289 , FUNCT_1:def 3;
end;
L292: ( rng D41 ) = ( rng R17 ) by L278 , TARSKI:1;
L293: ( Union ( C78 * D41 ) ) = ( union ( rng ( C78 * D41 ) ) ) by CARD_3:def 4;
L294: ( rng ( C78 * D41 ) ) = ( C78 .: ( rng D41 ) ) by RELAT_1:127
.= ( rng ( C78 * R17 ) ) by L292 , RELAT_1:127;
thus L295: thesis by L294 , L271 , L273 , L276 , L293 , CARD_3:def 4;
end;
theorem
L296: (for R15 being (Instruction of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedIntLoc R15 ) = ( UsedIntLoc ( IncAddr (R15 , R21) ) )))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
L297: ( InsCode R15 ) <= 12 by SCMFSA_2:16;
per cases  by L297 , NAT_1:36;
suppose L298: ( InsCode R15 ) = ( 0 );

L299: R15 = ( halt ( SCM+FSA ) ) by L298 , SCMFSA_2:95;
thus L300: thesis by L299 , COMPOS_0:4;
end;
suppose L301: ( InsCode R15 ) = 1;

L302: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( R1 := R2 ))) by L301 , SCMFSA_2:30;
thus L303: thesis by L302 , COMPOS_0:4;
end;
suppose L304: ( InsCode R15 ) = 2;

L305: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( AddTo (R1 , R2) ))) by L304 , SCMFSA_2:31;
thus L306: thesis by L305 , COMPOS_0:4;
end;
suppose L307: ( InsCode R15 ) = 3;

L308: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( SubFrom (R1 , R2) ))) by L307 , SCMFSA_2:32;
thus L309: thesis by L308 , COMPOS_0:4;
end;
suppose L310: ( InsCode R15 ) = 4;

L311: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( MultBy (R1 , R2) ))) by L310 , SCMFSA_2:33;
thus L312: thesis by L311 , COMPOS_0:4;
end;
suppose L313: ( InsCode R15 ) = 5;

L314: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( Divide (R1 , R2) ))) by L313 , SCMFSA_2:34;
thus L315: thesis by L314 , COMPOS_0:4;
end;
suppose L316: ( InsCode R15 ) = 6;

consider R8 being (Element of ( NAT )) such that L317: R15 = ( goto R8 ) by L316 , SCMFSA_2:35;
L318: ( IncAddr (R15 , R21) ) = ( goto ( R8 + R21 ) ) by L317 , SCMFSA_4:1;
thus L319: ( UsedIntLoc ( IncAddr (R15 , R21) ) ) = ( {} ) by L318 , L172
.= ( UsedIntLoc R15 ) by L317 , L172;
end;
suppose L320: ( InsCode R15 ) = 7;

consider R8 being (Element of ( NAT )), R1 being Int-Location such that L321: R15 = ( R1 =0_goto R8 ) by L320 , SCMFSA_2:36;
L322: ( IncAddr (R15 , R21) ) = ( R1 =0_goto ( R8 + R21 ) ) by L321 , SCMFSA_4:2;
thus L323: ( UsedIntLoc ( IncAddr (R15 , R21) ) ) = { R1 } by L322 , L175
.= ( UsedIntLoc R15 ) by L321 , L175;
end;
suppose L324: ( InsCode R15 ) = 8;

consider R8 being (Element of ( NAT )), R1 being Int-Location such that L325: R15 = ( R1 >0_goto R8 ) by L324 , SCMFSA_2:37;
L326: ( IncAddr (R15 , R21) ) = ( R1 >0_goto ( R8 + R21 ) ) by L325 , SCMFSA_4:3;
thus L327: ( UsedIntLoc ( IncAddr (R15 , R21) ) ) = { R1 } by L326 , L175
.= ( UsedIntLoc R15 ) by L325 , L175;
end;
suppose L328: ( InsCode R15 ) = 9;

L329: (ex R1 being Int-Location st (ex R2 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R2 := (R11 , R1) )))) by L328 , SCMFSA_2:38;
thus L330: thesis by L329 , COMPOS_0:4;
end;
suppose L331: ( InsCode R15 ) = 10;

L332: (ex R1 being Int-Location st (ex R2 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( (R11 , R1) := R2 )))) by L331 , SCMFSA_2:39;
thus L333: thesis by L332 , COMPOS_0:4;
end;
suppose L334: ( InsCode R15 ) = 11;

L335: (ex R1 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R1 :=len R11 ))) by L334 , SCMFSA_2:40;
thus L336: thesis by L335 , COMPOS_0:4;
end;
suppose L337: ( InsCode R15 ) = 12;

L338: (ex R1 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R11 :=<0,...,0> R1 ))) by L337 , SCMFSA_2:41;
thus L339: thesis by L338 , COMPOS_0:4;
end;
end;
theorem
L341: (for R17 being (preProgram of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedIntLoc R17 ) = ( UsedIntLoc ( IncAddr (R17 , R21) ) )))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
set D45 = ( IncAddr (R17 , R21) );
consider C85 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L342: (for B35 being (Instruction of ( SCM+FSA )) holds ( C85 . B35 ) = ( UsedIntLoc B35 )) and L343: ( UsedIntLoc R17 ) = ( Union ( C85 * R17 ) ) by L190;
set D46 = ( C85 * R17 );
set D47 = ( C85 * D45 );
consider C86 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L344: (for B36 being (Instruction of ( SCM+FSA )) holds ( C86 . B36 ) = ( UsedIntLoc B36 )) and L345: ( UsedIntLoc ( IncAddr (R17 , R21) ) ) = ( Union ( C86 * ( IncAddr (R17 , R21) ) ) ) by L190;
L346: (for B37 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C85 . B37 ) = ( C86 . B37 ))
proof
let C87 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D48 = C87 as (Instruction of ( SCM+FSA ));
thus L347: ( C85 . C87 ) = ( UsedIntLoc D48 ) by L342
.= ( C86 . C87 ) by L344;
end;
L348: C85 = C86 by L346 , FUNCT_2:63;
L349:
now
L350: ( dom C85 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L351: ( rng R17 ) c= ( dom C85 ) by L350;
L352: ( rng D45 ) c= ( dom C85 ) by L350;
L353: ( dom D47 ) = ( dom D45 ) by L352 , RELAT_1:27;
L354: ( dom D45 ) = ( dom R17 ) by COMPOS_1:def 21;
thus L355: ( dom D47 ) = ( dom D46 ) by L354 , L351 , L353 , RELAT_1:27;
let C88 being set;
assume L356: C88 in ( dom D47 );
L357: ( R17 . C88 ) in ( rng R17 ) by L356 , L354 , L353 , FUNCT_1:def 3;
reconsider D49 = ( R17 . C88 ) as (Instruction of ( SCM+FSA )) by L357;
reconsider D50 = C88 as (Element of ( NAT )) by L353 , L356;
reconsider D51 = D50 as (Element of ( NAT ));
L358: ( D45 . C88 ) = ( IncAddr (( R17 /. D51 ) , R21) ) by L354 , L353 , L356 , COMPOS_1:def 21
.= ( IncAddr (D49 , R21) ) by L354 , L353 , L356 , PARTFUN1:def 6;
L359: ( D45 . C88 ) in ( rng D45 ) by L353 , L356 , FUNCT_1:def 3;
reconsider D52 = ( D45 . C88 ) as (Instruction of ( SCM+FSA )) by L359;
thus L360: ( D47 . C88 ) = ( C85 . D52 ) by L356 , FUNCT_1:12
.= ( UsedIntLoc D52 ) by L342
.= ( UsedIntLoc D49 ) by L358 , L296
.= ( C85 . D49 ) by L344 , L348
.= ( D46 . C88 ) by L354 , L353 , L356 , FUNCT_1:13;
end;
thus L361: thesis by L349 , L343 , L345 , L348 , FUNCT_1:2;
end;
theorem
L362: (for R19 being (Program of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedIntLoc R19 ) = ( UsedIntLoc ( Reloc (R19 , R21) ) )))
proof
let R19 being (Program of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
L363: ( Reloc (R19 , R21) ) = ( IncAddr (( Shift (R19 , R21) ) , R21) ) by COMPOS_1:34;
L364: ( UsedIntLoc ( Reloc (R19 , R21) ) ) = ( UsedIntLoc ( Reloc (R19 , R21) ) )
.= ( UsedIntLoc ( Shift (R19 , R21) ) ) by L341 , L363
.= ( UsedIntLoc R19 ) by L269;
thus L365: thesis by L364;
end;
theorem
L366: (for R19 being (Program of ( SCM+FSA )) holds ( UsedIntLoc R19 ) = ( UsedIntLoc ( Directed R19 ) ))
proof
let R19 being (Program of ( SCM+FSA ));
consider C89 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L367: (for B38 being (Instruction of ( SCM+FSA )) holds ( C89 . B38 ) = ( UsedIntLoc B38 )) and L368: ( UsedIntLoc R19 ) = ( Union ( C89 * R19 ) ) by L190;
L369: (( dom C89 ) = (the InstructionsF of ( SCM+FSA )) & ( C89 . ( halt ( SCM+FSA ) ) ) = ( {} )) by L367 , L162 , FUNCT_2:def 1;
consider C90 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L370: (for B39 being (Instruction of ( SCM+FSA )) holds ( C90 . B39 ) = ( UsedIntLoc B39 )) and L371: ( UsedIntLoc ( Directed R19 ) ) = ( Union ( C90 * ( Directed R19 ) ) ) by L190;
L372: (for B40 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C89 . B40 ) = ( C90 . B40 ))
proof
let C91 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D53 = C91 as (Instruction of ( SCM+FSA ));
thus L373: ( C89 . C91 ) = ( UsedIntLoc D53 ) by L367
.= ( C90 . C91 ) by L370;
end;
L374: ( C89 . ( goto ( card R19 ) ) ) = ( UsedIntLoc ( goto ( card R19 ) ) ) by L367
.= ( {} ) by L172;
L375: ( rng R19 ) c= (the InstructionsF of ( SCM+FSA ));
L376: ( C89 * ( Directed R19 ) ) = ( C89 * ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( card R19 ) )) ) * R19 ) ) by L375 , FUNCT_7:116
.= ( ( C89 * ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( card R19 ) )) ) ) * R19 ) by RELAT_1:36
.= ( C89 * R19 ) by L369 , L374 , FUNCT_7:108;
thus L377: thesis by L376 , L368 , L371 , L372 , FUNCT_2:63;
end;
theorem
L378: (for R19 being (Program of ( SCM+FSA )) holds (for R20 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( R19 ";" R20 ) ) = ( ( UsedIntLoc R19 ) \/ ( UsedIntLoc R20 ) )))
proof
let R19 being (Program of ( SCM+FSA ));
let R20 being (Program of ( SCM+FSA ));
L379: ( dom R19 ) = ( dom ( Directed R19 ) ) by FUNCT_4:99;
L380: ( dom ( Directed R19 ) ) misses ( dom ( Reloc (R20 , ( card R19 )) ) ) by L379 , COMPOS_1:48;
thus L381: ( UsedIntLoc ( R19 ";" R20 ) ) = ( ( UsedIntLoc ( Directed R19 ) ) \/ ( UsedIntLoc ( Reloc (R20 , ( card R19 )) ) ) ) by L380 , L247
.= ( ( UsedIntLoc R19 ) \/ ( UsedIntLoc ( Reloc (R20 , ( card R19 )) ) ) ) by L366
.= ( ( UsedIntLoc R19 ) \/ ( UsedIntLoc R20 ) ) by L362;
end;
theorem
L382: (for R15 being (Instruction of ( SCM+FSA )) holds ( UsedIntLoc ( Macro R15 ) ) = ( UsedIntLoc R15 ))
proof
let R15 being (Instruction of ( SCM+FSA ));
consider C92 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( Int-Locations ) )) such that L383: (for B41 being (Instruction of ( SCM+FSA )) holds ( C92 . B41 ) = ( UsedIntLoc B41 )) and L384: ( UsedIntLoc ( Macro R15 ) ) = ( Union ( C92 * ( Macro R15 ) ) ) by L190;
L385: (( rng ( Macro R15 ) ) = { R15 , ( halt ( SCM+FSA ) ) } & ( dom C92 ) = (the InstructionsF of ( SCM+FSA ))) by COMPOS_1:67 , FUNCT_2:def 1;
thus L386: ( UsedIntLoc ( Macro R15 ) ) = ( union ( rng ( C92 * ( Macro R15 ) ) ) ) by L384 , CARD_3:def 4
.= ( union ( C92 .: ( rng ( Macro R15 ) ) ) ) by RELAT_1:127
.= ( union { ( C92 . R15 ) , ( C92 . ( halt ( SCM+FSA ) ) ) } ) by L385 , FUNCT_1:60
.= ( ( C92 . R15 ) \/ ( C92 . ( halt ( SCM+FSA ) ) ) ) by ZFMISC_1:75
.= ( ( UsedIntLoc R15 ) \/ ( C92 . ( halt ( SCM+FSA ) ) ) ) by L383
.= ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc ( halt ( SCM+FSA ) ) ) ) by L383
.= ( UsedIntLoc R15 ) by L162;
end;
theorem
L387: (for R15 being (Instruction of ( SCM+FSA )) holds (for R20 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( R15 ";" R20 ) ) = ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc R20 ) )))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R20 being (Program of ( SCM+FSA ));
thus L388: ( UsedIntLoc ( R15 ";" R20 ) ) = ( ( UsedIntLoc ( Macro R15 ) ) \/ ( UsedIntLoc R20 ) ) by L378
.= ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc R20 ) ) by L382;
end;
theorem
L389: (for R16 being (Instruction of ( SCM+FSA )) holds (for R19 being (Program of ( SCM+FSA )) holds ( UsedIntLoc ( R19 ";" R16 ) ) = ( ( UsedIntLoc R19 ) \/ ( UsedIntLoc R16 ) )))
proof
let R16 being (Instruction of ( SCM+FSA ));
let R19 being (Program of ( SCM+FSA ));
thus L390: ( UsedIntLoc ( R19 ";" R16 ) ) = ( ( UsedIntLoc R19 ) \/ ( UsedIntLoc ( Macro R16 ) ) ) by L378
.= ( ( UsedIntLoc R19 ) \/ ( UsedIntLoc R16 ) ) by L382;
end;
theorem
L391: (for R15 being (Instruction of ( SCM+FSA )) holds (for R16 being (Instruction of ( SCM+FSA )) holds ( UsedIntLoc ( R15 ";" R16 ) ) = ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc R16 ) )))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R16 being (Instruction of ( SCM+FSA ));
thus L392: ( UsedIntLoc ( R15 ";" R16 ) ) = ( ( UsedIntLoc ( Macro R15 ) ) \/ ( UsedIntLoc ( Macro R16 ) ) ) by L378
.= ( ( UsedIntLoc ( Macro R15 ) ) \/ ( UsedIntLoc R16 ) ) by L382
.= ( ( UsedIntLoc R15 ) \/ ( UsedIntLoc R16 ) ) by L382;
end;
begin
definition
let C93 being (Instruction of ( SCM+FSA ));
func UsedInt*Loc C93 -> (Element of ( Fin ( FinSeq-Locations ) )) means 
:L393: (ex B42 , B43 being Int-Location st (ex B44 being FinSeq-Location st ((C93 = ( B43 := (B44 , B42) ) or C93 = ( (B44 , B42) := B43 )) & it = { B44 }))) if (( InsCode C93 ) = 9 or ( InsCode C93 ) = 10) , (ex B45 being Int-Location st (ex B46 being FinSeq-Location st ((C93 = ( B45 :=len B46 ) or C93 = ( B46 :=<0,...,0> B45 )) & it = { B46 }))) if (( InsCode C93 ) = 11 or ( InsCode C93 ) = 12) otherwise it = ( {} );
existence
proof
thus L394:now
assume L395: (( InsCode C93 ) = 9 or ( InsCode C93 ) = 10);
consider C94 , C95 being Int-Location, C96 being FinSeq-Location such that L396: (C93 = ( C95 := (C96 , C94) ) or C93 = ( (C96 , C94) := C95 )) by L395 , SCMFSA_2:38 , SCMFSA_2:39;
reconsider D54 = C96 as (Element of ( FinSeq-Locations )) by SCMFSA_2:def 5;
reconsider D55 = {. D54 .} as (Element of ( Fin ( FinSeq-Locations ) ));
take D56 = D55;
take D57 = C94;
take D58 = C95;
take D59 = C96;
thus L397: ((C93 = ( D58 := (D59 , D57) ) or C93 = ( (D59 , D57) := D58 )) & D56 = { D59 }) by L396;
end;
thus L398:now
assume L399: (( InsCode C93 ) = 11 or ( InsCode C93 ) = 12);
consider C97 being Int-Location, C98 being FinSeq-Location such that L400: (C93 = ( C97 :=len C98 ) or C93 = ( C98 :=<0,...,0> C97 )) by L399 , SCMFSA_2:40 , SCMFSA_2:41;
reconsider D60 = C98 as (Element of ( FinSeq-Locations )) by SCMFSA_2:def 5;
reconsider D61 = {. D60 .} as (Element of ( Fin ( FinSeq-Locations ) ));
take D62 = D61;
take D63 = C97;
take D64 = C98;
thus L401: ((C93 = ( D63 :=len D64 ) or C93 = ( D64 :=<0,...,0> D63 )) & D62 = { D64 }) by L400;
end;
L402: ( {} ) in ( Fin ( FinSeq-Locations ) ) by FINSUB_1:7;
thus L403: thesis by L402;
end;
uniqueness
proof
let C99 , C100 being (Element of ( Fin ( FinSeq-Locations ) ));
thus L404:now
assume L405: (( InsCode C93 ) = 9 or ( InsCode C93 ) = 10);
given C101 , C102 being Int-Location , C103 being FinSeq-Location such that
L406: (C93 = ( C102 := (C103 , C101) ) or C93 = ( (C103 , C101) := C102 ))
and
L407: C99 = { C103 };

given C104 , C105 being Int-Location , C106 being FinSeq-Location such that
L408: (C93 = ( C105 := (C106 , C104) ) or C93 = ( (C106 , C104) := C105 ))
and
L409: C100 = { C106 };

L410: ((C93 = ( (C103 , C101) := C102 ) or C93 = ( (C106 , C104) := C105 )) implies ( InsCode C93 ) = 10) by SCMFSA_2:27;
per cases  by L406 , L408 , L410 , SCMFSA_2:26;
suppose L411: (C93 = ( C102 := (C103 , C101) ) & C93 = ( C105 := (C106 , C104) ));

thus L412: C99 = C100 by L411 , L407 , L409 , L54;
end;
suppose L413: (C93 = ( (C103 , C101) := C102 ) & C93 = ( (C106 , C104) := C105 ));

thus L414: C99 = C100 by L413 , L407 , L409 , L60;
end;
end;
thus L416:now
assume L417: (( InsCode C93 ) = 11 or ( InsCode C93 ) = 12);
given C107 being Int-Location , C108 being FinSeq-Location such that
L418: (C93 = ( C107 :=len C108 ) or C93 = ( C108 :=<0,...,0> C107 ))
and
L419: C99 = { C108 };

given C109 being Int-Location , C110 being FinSeq-Location such that
L420: (C93 = ( C109 :=len C110 ) or C93 = ( C110 :=<0,...,0> C109 ))
and
L421: C100 = { C110 };

L422: ((C93 = ( C108 :=<0,...,0> C107 ) or C93 = ( C110 :=<0,...,0> C109 )) implies ( InsCode C93 ) = 12) by SCMFSA_2:29;
per cases  by L418 , L420 , L422 , SCMFSA_2:28;
suppose L423: (C93 = ( C107 :=len C108 ) & C93 = ( C109 :=len C110 ));

thus L424: C99 = C100 by L423 , L419 , L421 , L66;
end;
suppose L425: (C93 = ( C108 :=<0,...,0> C107 ) & C93 = ( C110 :=<0,...,0> C109 ));

thus L426: C99 = C100 by L425 , L419 , L421 , L71;
end;
end;
thus L428: thesis;
end;
consistency;
end;
theorem
L430: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R8 being (Element of ( NAT )) holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( halt ( SCM+FSA ) ) or R15 = ( R1 := R2 ) or R15 = ( AddTo (R1 , R2) ) or R15 = ( SubFrom (R1 , R2) ) or R15 = ( MultBy (R1 , R2) ) or R15 = ( Divide (R1 , R2) ) or R15 = ( goto R8 ) or R15 = ( R1 =0_goto R8 ) or R15 = ( R1 >0_goto R8 )) implies ( UsedInt*Loc R15 ) = ( {} ))))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R8 being (Element of ( NAT ));
let R15 being (Instruction of ( SCM+FSA ));
assume L431: (R15 = ( halt ( SCM+FSA ) ) or R15 = ( R1 := R2 ) or R15 = ( AddTo (R1 , R2) ) or R15 = ( SubFrom (R1 , R2) ) or R15 = ( MultBy (R1 , R2) ) or R15 = ( Divide (R1 , R2) ) or R15 = ( goto R8 ) or R15 = ( R1 =0_goto R8 ) or R15 = ( R1 >0_goto R8 ));
L432: (( InsCode R15 ) = ( 0 ) or ( InsCode R15 ) = 1 or ( InsCode R15 ) = 2 or ( InsCode R15 ) = 3 or ( InsCode R15 ) = 4 or ( InsCode R15 ) = 5 or ( InsCode R15 ) = 6 or ( InsCode R15 ) = 7 or ( InsCode R15 ) = 8) by L431 , COMPOS_1:70 , SCMFSA_2:18 , SCMFSA_2:19 , SCMFSA_2:20 , SCMFSA_2:21 , SCMFSA_2:22 , SCMFSA_2:23 , SCMFSA_2:24 , SCMFSA_2:25;
thus L433: thesis by L432 , L393;
end;
theorem
L434: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R11 being FinSeq-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( R2 := (R11 , R1) ) or R15 = ( (R11 , R1) := R2 )) implies ( UsedInt*Loc R15 ) = { R11 })))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R11 being FinSeq-Location;
let R15 being (Instruction of ( SCM+FSA ));
L435: R11 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L436: { R11 } c= ( FinSeq-Locations ) by L435 , ZFMISC_1:31;
reconsider D65 = { R11 } as (Element of ( Fin ( FinSeq-Locations ) )) by L436 , FINSUB_1:def 5;
assume L437: (R15 = ( R2 := (R11 , R1) ) or R15 = ( (R11 , R1) := R2 ));
L438: (( InsCode R15 ) = 9 or ( InsCode R15 ) = 10) by L437 , SCMFSA_2:26 , SCMFSA_2:27;
L439: ( UsedInt*Loc R15 ) = D65 by L438 , L437 , L393;
thus L440: thesis by L439;
end;
theorem
L441: (for R1 being Int-Location holds (for R11 being FinSeq-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds ((R15 = ( R1 :=len R11 ) or R15 = ( R11 :=<0,...,0> R1 )) implies ( UsedInt*Loc R15 ) = { R11 }))))
proof
let R1 being Int-Location;
let R11 being FinSeq-Location;
let R15 being (Instruction of ( SCM+FSA ));
L442: R11 in ( FinSeq-Locations ) by SCMFSA_2:def 5;
L443: { R11 } c= ( FinSeq-Locations ) by L442 , ZFMISC_1:31;
reconsider D66 = { R11 } as (Element of ( Fin ( FinSeq-Locations ) )) by L443 , FINSUB_1:def 5;
assume L444: (R15 = ( R1 :=len R11 ) or R15 = ( R11 :=<0,...,0> R1 ));
L445: (( InsCode R15 ) = 11 or ( InsCode R15 ) = 12) by L444 , SCMFSA_2:28 , SCMFSA_2:29;
L446: ( UsedInt*Loc R15 ) = D66 by L445 , L444 , L393;
thus L447: thesis by L446;
end;
definition
let C111 being Function;
func UsedInt*Loc C111 -> (Subset of ( FinSeq-Locations )) means 
:L448: (ex B47 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) st ((for B48 being (Instruction of ( SCM+FSA )) holds ( B47 . B48 ) = ( UsedInt*Loc B48 )) & it = ( Union ( B47 * C111 ) )));
existence
proof
defpred S2[ set , set ] means (ex B49 being (Instruction of ( SCM+FSA )) st ($1 = B49 & $2 = ( UsedInt*Loc B49 )));
L449: (for B50 being (Element of (the InstructionsF of ( SCM+FSA ))) holds (ex B51 being (Element of ( Fin ( FinSeq-Locations ) )) st S2[ B50 , B51 ]))
proof
let C112 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D67 = C112 as (Instruction of ( SCM+FSA ));
reconsider D68 = ( UsedInt*Loc D67 ) as (Element of ( Fin ( FinSeq-Locations ) ));
take D68;
take D67;
thus L450: thesis;
end;
consider C113 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L451: (for B52 being (Element of (the InstructionsF of ( SCM+FSA ))) holds S2[ B52 , ( C113 . B52 ) ]) from FUNCT_2:sch 3(L449);
set D69 = ( Union ( C113 * C111 ) );
set D70 = ( dom C111 );
set D71 = ( C113 * C111 );
take D69;
L452: ( Fin ( FinSeq-Locations ) ) c= ( bool ( FinSeq-Locations ) ) by FINSUB_1:13;
L453: (( rng D71 ) c= ( rng C113 ) & ( rng C113 ) c= ( bool ( FinSeq-Locations ) )) by L452 , RELAT_1:26 , XBOOLE_1:1;
L454: ( rng D71 ) c= ( bool ( FinSeq-Locations ) ) by L453 , XBOOLE_1:1;
L455: (D69 = ( union ( rng D71 ) ) & ( union ( rng D71 ) ) c= ( union ( bool ( FinSeq-Locations ) ) )) by L454 , CARD_3:def 4 , ZFMISC_1:77;
thus L456: D69 is (Subset of ( FinSeq-Locations )) by L455 , ZFMISC_1:81;
take C113;
thus L457:now
let C114 being (Instruction of ( SCM+FSA ));
L458: S2[ C114 , ( C113 . C114 ) ] by L451;
thus L459: ( C113 . C114 ) = ( UsedInt*Loc C114 ) by L458;
end;
thus L460: thesis;
end;
uniqueness
proof
let C115 , C116 being (Subset of ( FinSeq-Locations ));
given C117 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that
L461: (for B53 being (Instruction of ( SCM+FSA )) holds ( C117 . B53 ) = ( UsedInt*Loc B53 ))
and
L462: C115 = ( Union ( C117 * C111 ) );

given C118 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that
L463: (for B54 being (Instruction of ( SCM+FSA )) holds ( C118 . B54 ) = ( UsedInt*Loc B54 ))
and
L464: C116 = ( Union ( C118 * C111 ) );

L465: (for B55 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C117 . B55 ) = ( C118 . B55 ))
proof
let C119 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D72 = C119 as (Instruction of ( SCM+FSA ));
thus L466: ( C117 . C119 ) = ( UsedInt*Loc D72 ) by L461
.= ( C118 . C119 ) by L463;
end;
thus L467: thesis by L465 , L462 , L464 , FUNCT_2:63;
end;
end;
registration
let C120 being (preProgram of ( SCM+FSA ));
cluster ( UsedInt*Loc C120 ) ->  finite;
coherence
proof
reconsider D73 = ( dom C120 ) as  finite set;
consider C121 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L469: (for B56 being (Instruction of ( SCM+FSA )) holds ( C121 . B56 ) = ( UsedInt*Loc B56 )) and L470: ( UsedInt*Loc C120 ) = ( Union ( C121 * C120 ) ) by L448;
L471: ( rng C120 ) c= (the InstructionsF of ( SCM+FSA ));
reconsider D74 = C120 as (Function of D73 , (the InstructionsF of ( SCM+FSA ))) by L471 , FUNCT_2:2;
reconsider D75 = ( C121 * D74 ) as (Function of D73 , ( Fin ( FinSeq-Locations ) ));
L472: ( Union D75 ) is  finite;
thus L473: thesis by L472 , L470;
end;
end;
theorem
L475: (for R15 being (Instruction of ( SCM+FSA )) holds (for R17 being (preProgram of ( SCM+FSA )) holds (R15 in ( rng R17 ) implies ( UsedInt*Loc R15 ) c= ( UsedInt*Loc R17 ))))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R17 being (preProgram of ( SCM+FSA ));
assume L476: R15 in ( rng R17 );
consider C122 being set such that L477: (C122 in ( dom R17 ) & R15 = ( R17 . C122 )) by L476 , FUNCT_1:def 3;
consider C123 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L478: (for B57 being (Instruction of ( SCM+FSA )) holds ( C123 . B57 ) = ( UsedInt*Loc B57 )) and L479: ( UsedInt*Loc R17 ) = ( Union ( C123 * R17 ) ) by L448;
L480: ( UsedInt*Loc R17 ) = ( union ( rng ( C123 * R17 ) ) ) by L479 , CARD_3:def 4;
L481: ( dom C123 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L482: C122 in ( dom ( C123 * R17 ) ) by L481 , L477 , FUNCT_1:11;
L483: ( ( C123 * R17 ) . C122 ) in ( rng ( C123 * R17 ) ) by L482 , FUNCT_1:def 3;
L484: ( ( C123 * R17 ) . C122 ) = ( C123 . R15 ) by L477 , FUNCT_1:13
.= ( UsedInt*Loc R15 ) by L478;
thus L485: thesis by L484 , L483 , L480 , ZFMISC_1:74;
end;
theorem
L486: (for R17 being (preProgram of ( SCM+FSA )) holds (for R18 being (preProgram of ( SCM+FSA )) holds ( UsedInt*Loc ( R17 +* R18 ) ) c= ( ( UsedInt*Loc R17 ) \/ ( UsedInt*Loc R18 ) )))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R18 being (preProgram of ( SCM+FSA ));
consider C124 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L487: (for B58 being (Instruction of ( SCM+FSA )) holds ( C124 . B58 ) = ( UsedInt*Loc B58 )) and L488: ( UsedInt*Loc ( R17 +* R18 ) ) = ( Union ( C124 * ( R17 +* R18 ) ) ) by L448;
consider C125 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L489: (for B59 being (Instruction of ( SCM+FSA )) holds ( C125 . B59 ) = ( UsedInt*Loc B59 )) and L490: ( UsedInt*Loc R17 ) = ( Union ( C125 * R17 ) ) by L448;
L491: (for B60 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C124 . B60 ) = ( C125 . B60 ))
proof
let C126 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D76 = C126 as (Instruction of ( SCM+FSA ));
thus L492: ( C124 . C126 ) = ( UsedInt*Loc D76 ) by L487
.= ( C125 . C126 ) by L489;
end;
L493: C124 = C125 by L491 , FUNCT_2:63;
consider C127 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L494: (for B61 being (Instruction of ( SCM+FSA )) holds ( C127 . B61 ) = ( UsedInt*Loc B61 )) and L495: ( UsedInt*Loc R18 ) = ( Union ( C127 * R18 ) ) by L448;
L496: (for B62 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C124 . B62 ) = ( C127 . B62 ))
proof
let C128 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D77 = C128 as (Instruction of ( SCM+FSA ));
thus L497: ( C124 . C128 ) = ( UsedInt*Loc D77 ) by L487
.= ( C127 . C128 ) by L494;
end;
L498: C124 = C127 by L496 , FUNCT_2:63;
L499: ( dom C124 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L500: ( rng R18 ) c= ( dom C124 ) by L499;
L501: ( C124 * ( R17 +* R18 ) ) = ( ( C124 * R17 ) +* ( C124 * R18 ) ) by L500 , FUNCT_7:9;
L502: (( Union ( C124 * R18 ) ) = ( union ( rng ( C124 * R18 ) ) ) & ( union ( rng ( C124 * ( R17 +* R18 ) ) ) ) c= ( union ( ( rng ( C124 * R17 ) ) \/ ( rng ( C124 * R18 ) ) ) )) by L501 , CARD_3:def 4 , FUNCT_4:17 , ZFMISC_1:77;
L503: (( Union ( C124 * ( R17 +* R18 ) ) ) = ( union ( rng ( C124 * ( R17 +* R18 ) ) ) ) & ( Union ( C124 * R17 ) ) = ( union ( rng ( C124 * R17 ) ) )) by CARD_3:def 4;
thus L504: thesis by L503 , L488 , L490 , L495 , L493 , L498 , L502 , ZFMISC_1:78;
end;
theorem
L505: (for R17 being (preProgram of ( SCM+FSA )) holds (for R18 being (preProgram of ( SCM+FSA )) holds (( dom R17 ) misses ( dom R18 ) implies ( UsedInt*Loc ( R17 +* R18 ) ) = ( ( UsedInt*Loc R17 ) \/ ( UsedInt*Loc R18 ) ))))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R18 being (preProgram of ( SCM+FSA ));
consider C129 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L506: (for B63 being (Instruction of ( SCM+FSA )) holds ( C129 . B63 ) = ( UsedInt*Loc B63 )) and L507: ( UsedInt*Loc ( R17 +* R18 ) ) = ( Union ( C129 * ( R17 +* R18 ) ) ) by L448;
assume L508: ( dom R17 ) misses ( dom R18 );
L509: (( dom ( C129 * R17 ) ) c= ( dom R17 ) & ( dom R17 ) misses ( dom ( C129 * R18 ) )) by L508 , RELAT_1:25 , XBOOLE_1:63;
L510: ( ( C129 * R17 ) +* ( C129 * R18 ) ) = ( ( C129 * R17 ) \/ ( C129 * R18 ) ) by L509 , FUNCT_4:31 , XBOOLE_1:63;
L511: ( dom C129 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L512: ( rng R18 ) c= ( dom C129 ) by L511;
L513: ( C129 * ( R17 +* R18 ) ) = ( ( C129 * R17 ) +* ( C129 * R18 ) ) by L512 , FUNCT_7:9;
L514: (( Union ( C129 * R18 ) ) = ( union ( rng ( C129 * R18 ) ) ) & ( union ( rng ( C129 * ( R17 +* R18 ) ) ) ) = ( union ( ( rng ( C129 * R17 ) ) \/ ( rng ( C129 * R18 ) ) ) )) by L513 , L510 , CARD_3:def 4 , RELAT_1:12;
consider C130 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L515: (for B64 being (Instruction of ( SCM+FSA )) holds ( C130 . B64 ) = ( UsedInt*Loc B64 )) and L516: ( UsedInt*Loc R17 ) = ( Union ( C130 * R17 ) ) by L448;
L517: (for B65 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C129 . B65 ) = ( C130 . B65 ))
proof
let C131 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D78 = C131 as (Instruction of ( SCM+FSA ));
thus L518: ( C129 . C131 ) = ( UsedInt*Loc D78 ) by L506
.= ( C130 . C131 ) by L515;
end;
L519: C129 = C130 by L517 , FUNCT_2:63;
consider C132 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L520: (for B66 being (Instruction of ( SCM+FSA )) holds ( C132 . B66 ) = ( UsedInt*Loc B66 )) and L521: ( UsedInt*Loc R18 ) = ( Union ( C132 * R18 ) ) by L448;
L522: (for B67 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C129 . B67 ) = ( C132 . B67 ))
proof
let C133 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D79 = C133 as (Instruction of ( SCM+FSA ));
thus L523: ( C129 . C133 ) = ( UsedInt*Loc D79 ) by L506
.= ( C132 . C133 ) by L520;
end;
L524: C129 = C132 by L522 , FUNCT_2:63;
L525: (( Union ( C129 * ( R17 +* R18 ) ) ) = ( union ( rng ( C129 * ( R17 +* R18 ) ) ) ) & ( Union ( C129 * R17 ) ) = ( union ( rng ( C129 * R17 ) ) )) by CARD_3:def 4;
thus L526: thesis by L525 , L507 , L516 , L521 , L519 , L524 , L514 , ZFMISC_1:78;
end;
theorem
L527: (for R17 being (preProgram of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedInt*Loc R17 ) = ( UsedInt*Loc ( Shift (R17 , R21) ) )))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
set D80 = ( Shift (R17 , R21) );
consider C134 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L528: (for B68 being (Instruction of ( SCM+FSA )) holds ( C134 . B68 ) = ( UsedInt*Loc B68 )) and L529: ( UsedInt*Loc R17 ) = ( Union ( C134 * R17 ) ) by L448;
consider C135 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L530: (for B69 being (Instruction of ( SCM+FSA )) holds ( C135 . B69 ) = ( UsedInt*Loc B69 )) and L531: ( UsedInt*Loc ( Shift (R17 , R21) ) ) = ( Union ( C135 * ( Shift (R17 , R21) ) ) ) by L448;
L532: (for B70 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C134 . B70 ) = ( C135 . B70 ))
proof
let C136 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D81 = C136 as (Instruction of ( SCM+FSA ));
thus L533: ( C134 . C136 ) = ( UsedInt*Loc D81 ) by L528
.= ( C135 . C136 ) by L530;
end;
L534: C134 = C135 by L532 , FUNCT_2:63;
L535: ( dom D80 ) = { ( B71 + R21 ) where B71 is (Element of ( NAT )) : B71 in ( dom R17 ) } by VALUED_1:def 12;
L536:
now
let C137 being set;
thus L537:now
assume L538: C137 in ( rng D80 );
consider C138 being set such that L539: C138 in ( dom D80 ) and L540: C137 = ( D80 . C138 ) by L538 , FUNCT_1:def 3;
consider C139 being (Element of ( NAT )) such that L541: C138 = ( C139 + R21 ) and L542: C139 in ( dom R17 ) by L535 , L539;
L543: ( D80 . C138 ) = ( R17 . C139 ) by L541 , L542 , VALUED_1:def 12;
thus L544: C137 in ( rng R17 ) by L543 , L540 , L542 , FUNCT_1:def 3;
end;
assume L545: C137 in ( rng R17 );
consider C140 being set such that L546: C140 in ( dom R17 ) and L547: C137 = ( R17 . C140 ) by L545 , FUNCT_1:def 3;
reconsider D82 = C140 as (Element of ( NAT )) by L546;
reconsider D83 = D82 as (Element of ( NAT ));
L548: (( D83 + R21 ) in ( dom D80 ) & ( D80 . ( D83 + R21 ) ) = ( R17 . D83 )) by L535 , L546 , VALUED_1:def 12;
thus L549: C137 in ( rng D80 ) by L548 , L547 , FUNCT_1:def 3;
end;
L550: ( rng D80 ) = ( rng R17 ) by L536 , TARSKI:1;
L551: ( Union ( C134 * D80 ) ) = ( union ( rng ( C134 * D80 ) ) ) by CARD_3:def 4;
L552: ( rng ( C134 * D80 ) ) = ( C134 .: ( rng D80 ) ) by RELAT_1:127
.= ( rng ( C134 * R17 ) ) by L550 , RELAT_1:127;
thus L553: thesis by L552 , L529 , L531 , L534 , L551 , CARD_3:def 4;
end;
theorem
L554: (for R15 being (Instruction of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedInt*Loc R15 ) = ( UsedInt*Loc ( IncAddr (R15 , R21) ) )))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
L555: ( InsCode R15 ) <= 12 by SCMFSA_2:16;
per cases  by L555 , NAT_1:36;
suppose L556: ( InsCode R15 ) = ( 0 );

L557: R15 = ( halt ( SCM+FSA ) ) by L556 , SCMFSA_2:95;
thus L558: thesis by L557 , COMPOS_0:4;
end;
suppose L559: ( InsCode R15 ) = 1;

L560: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( R1 := R2 ))) by L559 , SCMFSA_2:30;
thus L561: thesis by L560 , COMPOS_0:4;
end;
suppose L562: ( InsCode R15 ) = 2;

L563: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( AddTo (R1 , R2) ))) by L562 , SCMFSA_2:31;
thus L564: thesis by L563 , COMPOS_0:4;
end;
suppose L565: ( InsCode R15 ) = 3;

L566: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( SubFrom (R1 , R2) ))) by L565 , SCMFSA_2:32;
thus L567: thesis by L566 , COMPOS_0:4;
end;
suppose L568: ( InsCode R15 ) = 4;

L569: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( MultBy (R1 , R2) ))) by L568 , SCMFSA_2:33;
thus L570: thesis by L569 , COMPOS_0:4;
end;
suppose L571: ( InsCode R15 ) = 5;

L572: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( Divide (R1 , R2) ))) by L571 , SCMFSA_2:34;
thus L573: thesis by L572 , COMPOS_0:4;
end;
suppose L574: ( InsCode R15 ) = 6;

consider R8 being (Element of ( NAT )) such that L575: R15 = ( goto R8 ) by L574 , SCMFSA_2:35;
L576: ( IncAddr (R15 , R21) ) = ( goto ( R8 + R21 ) ) by L575 , SCMFSA_4:1;
thus L577: ( UsedInt*Loc ( IncAddr (R15 , R21) ) ) = ( {} ) by L576 , L430
.= ( UsedInt*Loc R15 ) by L575 , L430;
end;
suppose L578: ( InsCode R15 ) = 7;

consider R8 being (Element of ( NAT )), R1 being Int-Location such that L579: R15 = ( R1 =0_goto R8 ) by L578 , SCMFSA_2:36;
L580: ( IncAddr (R15 , R21) ) = ( R1 =0_goto ( R8 + R21 ) ) by L579 , SCMFSA_4:2;
thus L581: ( UsedInt*Loc ( IncAddr (R15 , R21) ) ) = ( {} ) by L580 , L430
.= ( UsedInt*Loc R15 ) by L579 , L430;
end;
suppose L582: ( InsCode R15 ) = 8;

consider R8 being (Element of ( NAT )), R1 being Int-Location such that L583: R15 = ( R1 >0_goto R8 ) by L582 , SCMFSA_2:37;
L584: ( IncAddr (R15 , R21) ) = ( R1 >0_goto ( R8 + R21 ) ) by L583 , SCMFSA_4:3;
thus L585: ( UsedInt*Loc ( IncAddr (R15 , R21) ) ) = ( {} ) by L584 , L430
.= ( UsedInt*Loc R15 ) by L583 , L430;
end;
suppose L586: ( InsCode R15 ) = 9;

L587: (ex R1 being Int-Location st (ex R2 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R2 := (R11 , R1) )))) by L586 , SCMFSA_2:38;
thus L588: thesis by L587 , COMPOS_0:4;
end;
suppose L589: ( InsCode R15 ) = 10;

L590: (ex R1 being Int-Location st (ex R2 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( (R11 , R1) := R2 )))) by L589 , SCMFSA_2:39;
thus L591: thesis by L590 , COMPOS_0:4;
end;
suppose L592: ( InsCode R15 ) = 11;

L593: (ex R1 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R1 :=len R11 ))) by L592 , SCMFSA_2:40;
thus L594: thesis by L593 , COMPOS_0:4;
end;
suppose L595: ( InsCode R15 ) = 12;

L596: (ex R1 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R11 :=<0,...,0> R1 ))) by L595 , SCMFSA_2:41;
thus L597: thesis by L596 , COMPOS_0:4;
end;
end;
theorem
L599: (for R17 being (preProgram of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedInt*Loc R17 ) = ( UsedInt*Loc ( IncAddr (R17 , R21) ) )))
proof
let R17 being (preProgram of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
set D84 = ( IncAddr (R17 , R21) );
consider C141 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L600: (for B72 being (Instruction of ( SCM+FSA )) holds ( C141 . B72 ) = ( UsedInt*Loc B72 )) and L601: ( UsedInt*Loc R17 ) = ( Union ( C141 * R17 ) ) by L448;
set D85 = ( C141 * R17 );
set D86 = ( C141 * D84 );
consider C142 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L602: (for B73 being (Instruction of ( SCM+FSA )) holds ( C142 . B73 ) = ( UsedInt*Loc B73 )) and L603: ( UsedInt*Loc ( IncAddr (R17 , R21) ) ) = ( Union ( C142 * ( IncAddr (R17 , R21) ) ) ) by L448;
L604: (for B74 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C141 . B74 ) = ( C142 . B74 ))
proof
let C143 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D87 = C143 as (Instruction of ( SCM+FSA ));
thus L605: ( C141 . C143 ) = ( UsedInt*Loc D87 ) by L600
.= ( C142 . C143 ) by L602;
end;
L606: C141 = C142 by L604 , FUNCT_2:63;
L607:
now
L608: ( dom C141 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L609: ( rng R17 ) c= ( dom C141 ) by L608;
L610: ( rng D84 ) c= ( dom C141 ) by L608;
L611: ( dom D86 ) = ( dom D84 ) by L610 , RELAT_1:27;
L612: ( dom D84 ) = ( dom R17 ) by COMPOS_1:def 21;
thus L613: ( dom D86 ) = ( dom D85 ) by L612 , L609 , L611 , RELAT_1:27;
let C144 being set;
assume L614: C144 in ( dom D86 );
L615: ( R17 . C144 ) in ( rng R17 ) by L614 , L612 , L611 , FUNCT_1:def 3;
reconsider D88 = ( R17 . C144 ) as (Instruction of ( SCM+FSA )) by L615;
reconsider D89 = C144 as (Element of ( NAT )) by L611 , L614;
reconsider D90 = D89 as (Element of ( NAT ));
L616: ( D84 . C144 ) = ( IncAddr (( R17 /. D90 ) , R21) ) by L612 , L611 , L614 , COMPOS_1:def 21
.= ( IncAddr (D88 , R21) ) by L612 , L611 , L614 , PARTFUN1:def 6;
L617: ( D84 . C144 ) in ( rng D84 ) by L611 , L614 , FUNCT_1:def 3;
reconsider D91 = ( D84 . C144 ) as (Instruction of ( SCM+FSA )) by L617;
thus L618: ( D86 . C144 ) = ( C141 . D91 ) by L614 , FUNCT_1:12
.= ( UsedInt*Loc D91 ) by L600
.= ( UsedInt*Loc D88 ) by L616 , L554
.= ( C141 . D88 ) by L602 , L606
.= ( D85 . C144 ) by L612 , L611 , L614 , FUNCT_1:13;
end;
thus L619: thesis by L607 , L601 , L603 , L606 , FUNCT_1:2;
end;
theorem
L620: (for R19 being (Program of ( SCM+FSA )) holds (for R21 being (Element of ( NAT )) holds ( UsedInt*Loc R19 ) = ( UsedInt*Loc ( Reloc (R19 , R21) ) )))
proof
let R19 being (Program of ( SCM+FSA ));
let R21 being (Element of ( NAT ));
L621: ( Reloc (R19 , R21) ) = ( IncAddr (( Shift (R19 , R21) ) , R21) ) by COMPOS_1:34;
L622: ( UsedInt*Loc ( Reloc (R19 , R21) ) ) = ( UsedInt*Loc ( Reloc (R19 , R21) ) )
.= ( UsedInt*Loc ( Shift (R19 , R21) ) ) by L599 , L621
.= ( UsedInt*Loc R19 ) by L527;
thus L623: thesis by L622;
end;
theorem
L624: (for R19 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc R19 ) = ( UsedInt*Loc ( Directed R19 ) ))
proof
let R19 being (Program of ( SCM+FSA ));
consider C145 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L625: (for B75 being (Instruction of ( SCM+FSA )) holds ( C145 . B75 ) = ( UsedInt*Loc B75 )) and L626: ( UsedInt*Loc R19 ) = ( Union ( C145 * R19 ) ) by L448;
L627: ( C145 . ( halt ( SCM+FSA ) ) ) = ( UsedInt*Loc ( halt ( SCM+FSA ) ) ) by L625
.= ( {} ) by L430;
consider C146 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L628: (for B76 being (Instruction of ( SCM+FSA )) holds ( C146 . B76 ) = ( UsedInt*Loc B76 )) and L629: ( UsedInt*Loc ( Directed R19 ) ) = ( Union ( C146 * ( Directed R19 ) ) ) by L448;
L630: (for B77 being (Element of (the InstructionsF of ( SCM+FSA ))) holds ( C145 . B77 ) = ( C146 . B77 ))
proof
let C147 being (Element of (the InstructionsF of ( SCM+FSA )));
reconsider D92 = C147 as (Instruction of ( SCM+FSA ));
thus L631: ( C145 . C147 ) = ( UsedInt*Loc D92 ) by L625
.= ( C146 . C147 ) by L628;
end;
L632: ( C145 . ( goto ( card R19 ) ) ) = ( UsedInt*Loc ( goto ( card R19 ) ) ) by L625
.= ( {} ) by L430;
L633: ( dom C145 ) = (the InstructionsF of ( SCM+FSA )) by FUNCT_2:def 1;
L634: ( rng R19 ) c= (the InstructionsF of ( SCM+FSA ));
L635: ( C145 * ( Directed R19 ) ) = ( C145 * ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( card R19 ) )) ) * R19 ) ) by L634 , FUNCT_7:116
.= ( ( C145 * ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( card R19 ) )) ) ) * R19 ) by RELAT_1:36
.= ( C145 * R19 ) by L633 , L627 , L632 , FUNCT_7:108;
thus L636: thesis by L635 , L626 , L629 , L630 , FUNCT_2:63;
end;
theorem
L637: (for R19 being (Program of ( SCM+FSA )) holds (for R20 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( R19 ";" R20 ) ) = ( ( UsedInt*Loc R19 ) \/ ( UsedInt*Loc R20 ) )))
proof
let R19 being (Program of ( SCM+FSA ));
let R20 being (Program of ( SCM+FSA ));
L638: ( dom R19 ) = ( dom ( Directed R19 ) ) by FUNCT_4:99;
L639: ( dom ( Directed R19 ) ) misses ( dom ( Reloc (R20 , ( card R19 )) ) ) by L638 , COMPOS_1:48;
thus L640: ( UsedInt*Loc ( R19 ";" R20 ) ) = ( ( UsedInt*Loc ( Directed R19 ) ) \/ ( UsedInt*Loc ( Reloc (R20 , ( card R19 )) ) ) ) by L639 , L505
.= ( ( UsedInt*Loc R19 ) \/ ( UsedInt*Loc ( Reloc (R20 , ( card R19 )) ) ) ) by L624
.= ( ( UsedInt*Loc R19 ) \/ ( UsedInt*Loc R20 ) ) by L620;
end;
theorem
L641: (for R15 being (Instruction of ( SCM+FSA )) holds ( UsedInt*Loc ( Macro R15 ) ) = ( UsedInt*Loc R15 ))
proof
let R15 being (Instruction of ( SCM+FSA ));
consider C148 being (Function of (the InstructionsF of ( SCM+FSA )) , ( Fin ( FinSeq-Locations ) )) such that L642: (for B78 being (Instruction of ( SCM+FSA )) holds ( C148 . B78 ) = ( UsedInt*Loc B78 )) and L643: ( UsedInt*Loc ( Macro R15 ) ) = ( Union ( C148 * ( Macro R15 ) ) ) by L448;
L644: (( rng ( Macro R15 ) ) = { R15 , ( halt ( SCM+FSA ) ) } & ( dom C148 ) = (the InstructionsF of ( SCM+FSA ))) by COMPOS_1:67 , FUNCT_2:def 1;
thus L645: ( UsedInt*Loc ( Macro R15 ) ) = ( union ( rng ( C148 * ( Macro R15 ) ) ) ) by L643 , CARD_3:def 4
.= ( union ( C148 .: ( rng ( Macro R15 ) ) ) ) by RELAT_1:127
.= ( union { ( C148 . R15 ) , ( C148 . ( halt ( SCM+FSA ) ) ) } ) by L644 , FUNCT_1:60
.= ( ( C148 . R15 ) \/ ( C148 . ( halt ( SCM+FSA ) ) ) ) by ZFMISC_1:75
.= ( ( UsedInt*Loc R15 ) \/ ( C148 . ( halt ( SCM+FSA ) ) ) ) by L642
.= ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc ( halt ( SCM+FSA ) ) ) ) by L642
.= ( ( UsedInt*Loc R15 ) \/ ( {} ) ) by L430
.= ( UsedInt*Loc R15 );
end;
theorem
L646: (for R15 being (Instruction of ( SCM+FSA )) holds (for R20 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( R15 ";" R20 ) ) = ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R20 ) )))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R20 being (Program of ( SCM+FSA ));
thus L647: ( UsedInt*Loc ( R15 ";" R20 ) ) = ( ( UsedInt*Loc ( Macro R15 ) ) \/ ( UsedInt*Loc R20 ) ) by L637
.= ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R20 ) ) by L641;
end;
theorem
L648: (for R16 being (Instruction of ( SCM+FSA )) holds (for R19 being (Program of ( SCM+FSA )) holds ( UsedInt*Loc ( R19 ";" R16 ) ) = ( ( UsedInt*Loc R19 ) \/ ( UsedInt*Loc R16 ) )))
proof
let R16 being (Instruction of ( SCM+FSA ));
let R19 being (Program of ( SCM+FSA ));
thus L649: ( UsedInt*Loc ( R19 ";" R16 ) ) = ( ( UsedInt*Loc R19 ) \/ ( UsedInt*Loc ( Macro R16 ) ) ) by L637
.= ( ( UsedInt*Loc R19 ) \/ ( UsedInt*Loc R16 ) ) by L641;
end;
theorem
L650: (for R15 being (Instruction of ( SCM+FSA )) holds (for R16 being (Instruction of ( SCM+FSA )) holds ( UsedInt*Loc ( R15 ";" R16 ) ) = ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R16 ) )))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R16 being (Instruction of ( SCM+FSA ));
thus L651: ( UsedInt*Loc ( R15 ";" R16 ) ) = ( ( UsedInt*Loc ( Macro R15 ) ) \/ ( UsedInt*Loc ( Macro R16 ) ) ) by L637
.= ( ( UsedInt*Loc ( Macro R15 ) ) \/ ( UsedInt*Loc R16 ) ) by L641
.= ( ( UsedInt*Loc R15 ) \/ ( UsedInt*Loc R16 ) ) by L641;
end;
begin
definition
canceled 1;
end;
theorem
L653: (for R24 being  finite (Subset of ( Int-Locations )) holds (not ( FirstNotIn R24 ) in R24)) by SCMFSA_M:14;
theorem
L654: (for R22 being (Element of ( NAT )) holds (for R23 being (Element of ( NAT )) holds (for R24 being  finite (Subset of ( Int-Locations )) holds ((( FirstNotIn R24 ) = ( intloc R22 ) & (not ( intloc R23 ) in R24)) implies R22 <= R23)))) by SCMFSA_M:15;
definition
let C149 being (preProgram of ( SCM+FSA ));
func FirstNotUsed C149 -> Int-Location means 
:L655: (ex B79 being  finite (Subset of ( Int-Locations )) st (B79 = ( ( UsedIntLoc C149 ) \/ { ( intloc ( 0 ) ) } ) & it = ( FirstNotIn B79 )));
existence
proof
reconsider D93 = { ( intloc ( 0 ) ) } as  finite (Subset of ( Int-Locations ));
reconsider D94 = ( ( UsedIntLoc C149 ) \/ D93 ) as  finite (Subset of ( Int-Locations ));
take ( FirstNotIn D94 );
take D94;
thus L656: thesis;
end;
uniqueness;
end;
registration
let C150 being (preProgram of ( SCM+FSA ));
cluster ( FirstNotUsed C150 ) ->  read-write;
coherence
proof
consider C151 being  finite (Subset of ( Int-Locations )) such that L658: C151 = ( ( UsedIntLoc C150 ) \/ { ( intloc ( 0 ) ) } ) and L659: ( FirstNotUsed C150 ) = ( FirstNotIn C151 ) by L655;
L660:
now
assume L661: ( FirstNotIn C151 ) = ( intloc ( 0 ) );
L662: (not ( intloc ( 0 ) ) in C151) by L661 , SCMFSA_M:14;
thus L663: contradiction by L662 , L658 , ZFMISC_1:136;
end;
thus L664: thesis by L660 , L659 , SCMFSA_M:def 2;
end;
end;
theorem
L666: (for R17 being (preProgram of ( SCM+FSA )) holds (not ( FirstNotUsed R17 ) in ( UsedIntLoc R17 )))
proof
let R17 being (preProgram of ( SCM+FSA ));
consider C152 being  finite (Subset of ( Int-Locations )) such that L667: C152 = ( ( UsedIntLoc R17 ) \/ { ( intloc ( 0 ) ) } ) and L668: ( FirstNotUsed R17 ) = ( FirstNotIn C152 ) by L655;
L669: (not ( FirstNotUsed R17 ) in C152) by L668 , SCMFSA_M:14;
thus L670: thesis by L669 , L667 , XBOOLE_0:def 3;
end;
theorem
L671: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R17 being (preProgram of ( SCM+FSA )) holds ((( R1 := R2 ) in ( rng R17 ) or ( AddTo (R1 , R2) ) in ( rng R17 ) or ( SubFrom (R1 , R2) ) in ( rng R17 ) or ( MultBy (R1 , R2) ) in ( rng R17 ) or ( Divide (R1 , R2) ) in ( rng R17 )) implies (( FirstNotUsed R17 ) <> R1 & ( FirstNotUsed R17 ) <> R2)))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R17 being (preProgram of ( SCM+FSA ));
assume L672: (( R1 := R2 ) in ( rng R17 ) or ( AddTo (R1 , R2) ) in ( rng R17 ) or ( SubFrom (R1 , R2) ) in ( rng R17 ) or ( MultBy (R1 , R2) ) in ( rng R17 ) or ( Divide (R1 , R2) ) in ( rng R17 ));
consider C153 being (Instruction of ( SCM+FSA )) such that L673: C153 in ( rng R17 ) and L674: (C153 = ( R1 := R2 ) or C153 = ( AddTo (R1 , R2) ) or C153 = ( SubFrom (R1 , R2) ) or C153 = ( MultBy (R1 , R2) ) or C153 = ( Divide (R1 , R2) )) by L672;
L675: ( UsedIntLoc C153 ) = { R1 , R2 } by L674 , L166;
L676: { R1 , R2 } c= ( UsedIntLoc R17 ) by L675 , L673 , L217;
L677: (not ( FirstNotUsed R17 ) in ( UsedIntLoc R17 )) by L666;
thus L678: thesis by L677 , L676 , ZFMISC_1:32;
end;
theorem
L679: (for R1 being Int-Location holds (for R8 being (Element of ( NAT )) holds (for R17 being (preProgram of ( SCM+FSA )) holds ((( R1 =0_goto R8 ) in ( rng R17 ) or ( R1 >0_goto R8 ) in ( rng R17 )) implies ( FirstNotUsed R17 ) <> R1))))
proof
let R1 being Int-Location;
let R8 being (Element of ( NAT ));
let R17 being (preProgram of ( SCM+FSA ));
assume L680: (( R1 =0_goto R8 ) in ( rng R17 ) or ( R1 >0_goto R8 ) in ( rng R17 ));
consider C154 being (Instruction of ( SCM+FSA )) such that L681: C154 in ( rng R17 ) and L682: (C154 = ( R1 =0_goto R8 ) or C154 = ( R1 >0_goto R8 )) by L680;
L683: ( UsedIntLoc C154 ) = { R1 } by L682 , L175;
L684: { R1 } c= ( UsedIntLoc R17 ) by L683 , L681 , L217;
L685: (not ( FirstNotUsed R17 ) in ( UsedIntLoc R17 )) by L666;
thus L686: thesis by L685 , L684 , ZFMISC_1:31;
end;
theorem
L687: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R11 being FinSeq-Location holds (for R17 being (preProgram of ( SCM+FSA )) holds ((( R2 := (R11 , R1) ) in ( rng R17 ) or ( (R11 , R1) := R2 ) in ( rng R17 )) implies (( FirstNotUsed R17 ) <> R1 & ( FirstNotUsed R17 ) <> R2))))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R11 being FinSeq-Location;
let R17 being (preProgram of ( SCM+FSA ));
assume L688: (( R2 := (R11 , R1) ) in ( rng R17 ) or ( (R11 , R1) := R2 ) in ( rng R17 ));
consider C155 being (Instruction of ( SCM+FSA )) such that L689: C155 in ( rng R17 ) and L690: (C155 = ( R2 := (R11 , R1) ) or C155 = ( (R11 , R1) := R2 )) by L688;
L691: ( UsedIntLoc C155 ) = { R1 , R2 } by L690 , L180;
L692: { R1 , R2 } c= ( UsedIntLoc R17 ) by L691 , L689 , L217;
L693: (not ( FirstNotUsed R17 ) in ( UsedIntLoc R17 )) by L666;
thus L694: thesis by L693 , L692 , ZFMISC_1:32;
end;
theorem
L695: (for R1 being Int-Location holds (for R11 being FinSeq-Location holds (for R17 being (preProgram of ( SCM+FSA )) holds ((( R1 :=len R11 ) in ( rng R17 ) or ( R11 :=<0,...,0> R1 ) in ( rng R17 )) implies ( FirstNotUsed R17 ) <> R1))))
proof
let R1 being Int-Location;
let R11 being FinSeq-Location;
let R17 being (preProgram of ( SCM+FSA ));
assume L696: (( R1 :=len R11 ) in ( rng R17 ) or ( R11 :=<0,...,0> R1 ) in ( rng R17 ));
consider C156 being (Instruction of ( SCM+FSA )) such that L697: C156 in ( rng R17 ) and L698: (C156 = ( R1 :=len R11 ) or C156 = ( R11 :=<0,...,0> R1 )) by L696;
L699: ( UsedIntLoc C156 ) = { R1 } by L698 , L185;
L700: { R1 } c= ( UsedIntLoc R17 ) by L699 , L697 , L217;
L701: (not ( FirstNotUsed R17 ) in ( UsedIntLoc R17 )) by L666;
thus L702: thesis by L701 , L700 , ZFMISC_1:31;
end;
begin
definition
canceled 1;
end;
theorem
L704: (for R25 being  finite (Subset of ( FinSeq-Locations )) holds (not ( First*NotIn R25 ) in R25)) by SCMFSA_M:16;
theorem
L705: (for R22 being (Element of ( NAT )) holds (for R23 being (Element of ( NAT )) holds (for R25 being  finite (Subset of ( FinSeq-Locations )) holds ((( First*NotIn R25 ) = ( fsloc R22 ) & (not ( fsloc R23 ) in R25)) implies R22 <= R23)))) by SCMFSA_M:17;
definition
let C157 being (preProgram of ( SCM+FSA ));
func First*NotUsed C157 -> FinSeq-Location means 
:L706: (ex B80 being  finite (Subset of ( FinSeq-Locations )) st (B80 = ( UsedInt*Loc C157 ) & it = ( First*NotIn B80 )));
existence
proof
take ( First*NotIn ( UsedInt*Loc C157 ) );
take ( UsedInt*Loc C157 );
thus L707: thesis;
end;
uniqueness;
end;
theorem
L709: (for R17 being (preProgram of ( SCM+FSA )) holds (not ( First*NotUsed R17 ) in ( UsedInt*Loc R17 )))
proof
let R17 being (preProgram of ( SCM+FSA ));
L710: (ex B81 being  finite (Subset of ( FinSeq-Locations )) st (B81 = ( UsedInt*Loc R17 ) & ( First*NotUsed R17 ) = ( First*NotIn B81 ))) by L706;
thus L711: thesis by L710 , SCMFSA_M:16;
end;
theorem
L712: (for R1 being Int-Location holds (for R2 being Int-Location holds (for R11 being FinSeq-Location holds (for R17 being (preProgram of ( SCM+FSA )) holds ((( R2 := (R11 , R1) ) in ( rng R17 ) or ( (R11 , R1) := R2 ) in ( rng R17 )) implies ( First*NotUsed R17 ) <> R11)))))
proof
let R1 being Int-Location;
let R2 being Int-Location;
let R11 being FinSeq-Location;
let R17 being (preProgram of ( SCM+FSA ));
assume L713: (( R2 := (R11 , R1) ) in ( rng R17 ) or ( (R11 , R1) := R2 ) in ( rng R17 ));
consider C158 being (Instruction of ( SCM+FSA )) such that L714: C158 in ( rng R17 ) and L715: (C158 = ( R2 := (R11 , R1) ) or C158 = ( (R11 , R1) := R2 )) by L713;
L716: ( UsedInt*Loc C158 ) = { R11 } by L715 , L434;
L717: { R11 } c= ( UsedInt*Loc R17 ) by L716 , L714 , L475;
L718: (not ( First*NotUsed R17 ) in ( UsedInt*Loc R17 )) by L709;
thus L719: thesis by L718 , L717 , ZFMISC_1:31;
end;
theorem
L720: (for R1 being Int-Location holds (for R11 being FinSeq-Location holds (for R17 being (preProgram of ( SCM+FSA )) holds ((( R1 :=len R11 ) in ( rng R17 ) or ( R11 :=<0,...,0> R1 ) in ( rng R17 )) implies ( First*NotUsed R17 ) <> R11))))
proof
let R1 being Int-Location;
let R11 being FinSeq-Location;
let R17 being (preProgram of ( SCM+FSA ));
assume L721: (( R1 :=len R11 ) in ( rng R17 ) or ( R11 :=<0,...,0> R1 ) in ( rng R17 ));
consider C159 being (Instruction of ( SCM+FSA )) such that L722: C159 in ( rng R17 ) and L723: (C159 = ( R1 :=len R11 ) or C159 = ( R11 :=<0,...,0> R1 )) by L721;
L724: ( UsedInt*Loc C159 ) = { R11 } by L723 , L441;
L725: { R11 } c= ( UsedInt*Loc R17 ) by L724 , L722 , L475;
L726: (not ( First*NotUsed R17 ) in ( UsedInt*Loc R17 )) by L709;
thus L727: thesis by L726 , L725 , ZFMISC_1:31;
end;
begin
theorem
L728: (for R3 being Int-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds (for R26 being (State of ( SCM+FSA )) holds ((not R3 in ( UsedIntLoc R15 )) implies ( ( Exec (R15 , R26) ) . R3 ) = ( R26 . R3 )))))
proof
let R3 being Int-Location;
let R15 being (Instruction of ( SCM+FSA ));
let R26 being (State of ( SCM+FSA ));
assume L729: (not R3 in ( UsedIntLoc R15 ));
L730: ( InsCode R15 ) <= 12 by SCMFSA_2:16;
per cases  by L730 , NAT_1:36;
suppose L731: ( InsCode R15 ) = ( 0 );

L732: R15 = ( halt ( SCM+FSA ) ) by L731 , SCMFSA_2:95;
thus L733: thesis by L732 , EXTPRO_1:def 3;
end;
suppose L734: ( InsCode R15 ) = 1;

consider R1 being Int-Location, R2 being Int-Location such that L735: R15 = ( R1 := R2 ) by L734 , SCMFSA_2:30;
L736: ( UsedIntLoc R15 ) = { R1 , R2 } by L735 , L166;
L737: R3 <> R1 by L736 , L729 , TARSKI:def 2;
thus L738: thesis by L737 , L735 , SCMFSA_2:63;
end;
suppose L739: ( InsCode R15 ) = 2;

consider R1 being Int-Location, R2 being Int-Location such that L740: R15 = ( AddTo (R1 , R2) ) by L739 , SCMFSA_2:31;
L741: ( UsedIntLoc R15 ) = { R1 , R2 } by L740 , L166;
L742: R3 <> R1 by L741 , L729 , TARSKI:def 2;
thus L743: thesis by L742 , L740 , SCMFSA_2:64;
end;
suppose L744: ( InsCode R15 ) = 3;

consider R1 being Int-Location, R2 being Int-Location such that L745: R15 = ( SubFrom (R1 , R2) ) by L744 , SCMFSA_2:32;
L746: ( UsedIntLoc R15 ) = { R1 , R2 } by L745 , L166;
L747: R3 <> R1 by L746 , L729 , TARSKI:def 2;
thus L748: thesis by L747 , L745 , SCMFSA_2:65;
end;
suppose L749: ( InsCode R15 ) = 4;

consider R1 being Int-Location, R2 being Int-Location such that L750: R15 = ( MultBy (R1 , R2) ) by L749 , SCMFSA_2:33;
L751: ( UsedIntLoc R15 ) = { R1 , R2 } by L750 , L166;
L752: R3 <> R1 by L751 , L729 , TARSKI:def 2;
thus L753: thesis by L752 , L750 , SCMFSA_2:66;
end;
suppose L754: ( InsCode R15 ) = 5;

consider R1 being Int-Location, R2 being Int-Location such that L755: R15 = ( Divide (R1 , R2) ) by L754 , SCMFSA_2:34;
L756: ( UsedIntLoc R15 ) = { R1 , R2 } by L755 , L166;
L757: (R3 <> R1 & R3 <> R2) by L756 , L729 , TARSKI:def 2;
thus L758: thesis by L757 , L755 , SCMFSA_2:67;
end;
suppose L759: ( InsCode R15 ) = 6;

L760: (ex R8 being (Element of ( NAT )) st R15 = ( goto R8 )) by L759 , SCMFSA_2:35;
thus L761: thesis by L760 , SCMFSA_2:69;
end;
suppose L762: ( InsCode R15 ) = 7;

L763: (ex R8 being (Element of ( NAT )) st (ex R1 being Int-Location st R15 = ( R1 =0_goto R8 ))) by L762 , SCMFSA_2:36;
thus L764: thesis by L763 , SCMFSA_2:70;
end;
suppose L765: ( InsCode R15 ) = 8;

L766: (ex R8 being (Element of ( NAT )) st (ex R1 being Int-Location st R15 = ( R1 >0_goto R8 ))) by L765 , SCMFSA_2:37;
thus L767: thesis by L766 , SCMFSA_2:71;
end;
suppose L768: ( InsCode R15 ) = 9;

consider R1 being Int-Location, R2 being Int-Location, R11 being FinSeq-Location such that L769: R15 = ( R2 := (R11 , R1) ) by L768 , SCMFSA_2:38;
L770: ( UsedIntLoc R15 ) = { R1 , R2 } by L769 , L180;
L771: R3 <> R2 by L770 , L729 , TARSKI:def 2;
thus L772: thesis by L771 , L769 , SCMFSA_2:72;
end;
suppose L773: ( InsCode R15 ) = 10;

L774: (ex R1 being Int-Location st (ex R2 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( (R11 , R1) := R2 )))) by L773 , SCMFSA_2:39;
thus L775: thesis by L774 , SCMFSA_2:73;
end;
suppose L776: ( InsCode R15 ) = 11;

consider R1 being Int-Location, R11 being FinSeq-Location such that L777: R15 = ( R1 :=len R11 ) by L776 , SCMFSA_2:40;
L778: ( UsedIntLoc R15 ) = { R1 } by L777 , L185;
L779: R3 <> R1 by L778 , L729 , TARSKI:def 1;
thus L780: thesis by L779 , L777 , SCMFSA_2:74;
end;
suppose L781: ( InsCode R15 ) = 12;

L782: (ex R1 being Int-Location st (ex R11 being FinSeq-Location st R15 = ( R11 :=<0,...,0> R1 ))) by L781 , SCMFSA_2:41;
thus L783: thesis by L782 , SCMFSA_2:75;
end;
end;
theorem
L785: (for R1 being Int-Location holds (for R19 being (Program of ( SCM+FSA )) holds (for R23 being (Element of ( NAT )) holds (for R26 being (State of ( SCM+FSA )) holds (for R28 being (Instruction-Sequence of ( SCM+FSA )) holds ((R19 c= R28 & (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (R28 , R26 , R22) ) ) in ( dom R19 ))) & (not R1 in ( UsedIntLoc R19 ))) implies ( ( Comput (R28 , R26 , R23) ) . R1 ) = ( R26 . R1 )))))))
proof
let R1 being Int-Location;
let R19 being (Program of ( SCM+FSA ));
let R23 being (Element of ( NAT ));
let R26 being (State of ( SCM+FSA ));
let R28 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L786: R19 c= R28
and
L787: (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (R28 , R26 , R22) ) ) in ( dom R19 )))
and
L788: (not R1 in ( UsedIntLoc R19 ));
defpred S3[ Nat ] means ($1 <= R23 implies ( ( Comput (R28 , R26 , $1) ) . R1 ) = ( R26 . R1 ));
L789: (for R22 being (Element of ( NAT )) holds (S3[ R22 ] implies S3[ ( R22 + 1 ) ]))
proof
let R22 being (Element of ( NAT ));
set D95 = ( Comput (R28 , R26 , R22) );
assume L790: (R22 <= R23 implies ( D95 . R1 ) = ( R26 . R1 ));
assume L791: ( R22 + 1 ) <= R23;
L792: R22 < R23 by L791 , NAT_1:13;
L793: ( IC D95 ) in ( dom R19 ) by L792 , L787;
L794: ( R19 . ( IC D95 ) ) in ( rng R19 ) by L793 , FUNCT_1:def 3;
L795: ( dom R28 ) = ( NAT ) by PARTFUN1:def 2;
L796: ( R28 /. ( IC D95 ) ) = ( R28 . ( IC D95 ) ) by L795 , PARTFUN1:def 6;
L797: ( R19 . ( IC D95 ) ) = ( R28 . ( IC D95 ) ) by L793 , L786 , GRFUNC_1:2;
L798: ( UsedIntLoc ( R28 . ( IC D95 ) ) ) c= ( UsedIntLoc R19 ) by L797 , L794 , L217;
L799: (not R1 in ( UsedIntLoc ( R28 . ( IC D95 ) ) )) by L798 , L788;
thus L800: ( ( Comput (R28 , R26 , ( R22 + 1 )) ) . R1 ) = ( ( Following (R28 , D95) ) . R1 ) by EXTPRO_1:3
.= ( R26 . R1 ) by L790 , L791 , L799 , L728 , L796 , NAT_1:13;
end;
L801: S3[ ( 0 ) ];
L802: (for R22 being (Element of ( NAT )) holds S3[ R22 ]) from NAT_1:sch 1(L801 , L789);
thus L803: thesis by L802;
end;
theorem
L804: (for R11 being FinSeq-Location holds (for R15 being (Instruction of ( SCM+FSA )) holds (for R26 being (State of ( SCM+FSA )) holds ((not R11 in ( UsedInt*Loc R15 )) implies ( ( Exec (R15 , R26) ) . R11 ) = ( R26 . R11 )))))
proof
let R11 being FinSeq-Location;
let R15 being (Instruction of ( SCM+FSA ));
let R26 being (State of ( SCM+FSA ));
assume L805: (not R11 in ( UsedInt*Loc R15 ));
L806: ( InsCode R15 ) <= 12 by SCMFSA_2:16;
per cases  by L806 , NAT_1:36;
suppose L807: ( InsCode R15 ) = ( 0 );

L808: R15 = ( halt ( SCM+FSA ) ) by L807 , SCMFSA_2:95;
thus L809: thesis by L808 , EXTPRO_1:def 3;
end;
suppose L810: ( InsCode R15 ) = 1;

L811: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( R1 := R2 ))) by L810 , SCMFSA_2:30;
thus L812: thesis by L811 , SCMFSA_2:63;
end;
suppose L813: ( InsCode R15 ) = 2;

L814: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( AddTo (R1 , R2) ))) by L813 , SCMFSA_2:31;
thus L815: thesis by L814 , SCMFSA_2:64;
end;
suppose L816: ( InsCode R15 ) = 3;

L817: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( SubFrom (R1 , R2) ))) by L816 , SCMFSA_2:32;
thus L818: thesis by L817 , SCMFSA_2:65;
end;
suppose L819: ( InsCode R15 ) = 4;

L820: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( MultBy (R1 , R2) ))) by L819 , SCMFSA_2:33;
thus L821: thesis by L820 , SCMFSA_2:66;
end;
suppose L822: ( InsCode R15 ) = 5;

L823: (ex R1 being Int-Location st (ex R2 being Int-Location st R15 = ( Divide (R1 , R2) ))) by L822 , SCMFSA_2:34;
thus L824: thesis by L823 , SCMFSA_2:67;
end;
suppose L825: ( InsCode R15 ) = 6;

L826: (ex R8 being (Element of ( NAT )) st R15 = ( goto R8 )) by L825 , SCMFSA_2:35;
thus L827: thesis by L826 , SCMFSA_2:69;
end;
suppose L828: ( InsCode R15 ) = 7;

L829: (ex R8 being (Element of ( NAT )) st (ex R1 being Int-Location st R15 = ( R1 =0_goto R8 ))) by L828 , SCMFSA_2:36;
thus L830: thesis by L829 , SCMFSA_2:70;
end;
suppose L831: ( InsCode R15 ) = 8;

L832: (ex R8 being (Element of ( NAT )) st (ex R1 being Int-Location st R15 = ( R1 >0_goto R8 ))) by L831 , SCMFSA_2:37;
thus L833: thesis by L832 , SCMFSA_2:71;
end;
suppose L834: ( InsCode R15 ) = 9;

L835: (ex R1 being Int-Location st (ex R2 being Int-Location st (ex R12 being FinSeq-Location st R15 = ( R2 := (R12 , R1) )))) by L834 , SCMFSA_2:38;
thus L836: thesis by L835 , SCMFSA_2:72;
end;
suppose L837: ( InsCode R15 ) = 10;

consider R1 being Int-Location, R2 being Int-Location, R12 being FinSeq-Location such that L838: R15 = ( (R12 , R1) := R2 ) by L837 , SCMFSA_2:39;
L839: ( UsedInt*Loc R15 ) = { R12 } by L838 , L434;
L840: R11 <> R12 by L839 , L805 , TARSKI:def 1;
thus L841: thesis by L840 , L838 , SCMFSA_2:73;
end;
suppose L842: ( InsCode R15 ) = 11;

L843: (ex R1 being Int-Location st (ex R12 being FinSeq-Location st R15 = ( R1 :=len R12 ))) by L842 , SCMFSA_2:40;
thus L844: thesis by L843 , SCMFSA_2:74;
end;
suppose L845: ( InsCode R15 ) = 12;

consider R1 being Int-Location, R12 being FinSeq-Location such that L846: R15 = ( R12 :=<0,...,0> R1 ) by L845 , SCMFSA_2:41;
L847: ( UsedInt*Loc R15 ) = { R12 } by L846 , L441;
L848: R11 <> R12 by L847 , L805 , TARSKI:def 1;
thus L849: thesis by L848 , L846 , SCMFSA_2:75;
end;
end;
theorem
L851: (for R11 being FinSeq-Location holds (for R19 being (Program of ( SCM+FSA )) holds (for R23 being (Element of ( NAT )) holds (for R26 being (State of ( SCM+FSA )) holds (for R28 being (Instruction-Sequence of ( SCM+FSA )) holds ((R19 c= R28 & (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (R28 , R26 , R22) ) ) in ( dom R19 ))) & (not R11 in ( UsedInt*Loc R19 ))) implies ( ( Comput (R28 , R26 , R23) ) . R11 ) = ( R26 . R11 )))))))
proof
let R11 being FinSeq-Location;
let R19 being (Program of ( SCM+FSA ));
let R23 being (Element of ( NAT ));
let R26 being (State of ( SCM+FSA ));
let R28 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L852: R19 c= R28
and
L853: (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (R28 , R26 , R22) ) ) in ( dom R19 )))
and
L854: (not R11 in ( UsedInt*Loc R19 ));
defpred S4[ Nat ] means ($1 <= R23 implies ( ( Comput (R28 , R26 , $1) ) . R11 ) = ( R26 . R11 ));
L855: (for R22 being (Element of ( NAT )) holds (S4[ R22 ] implies S4[ ( R22 + 1 ) ]))
proof
let R22 being (Element of ( NAT ));
set D96 = ( Comput (R28 , R26 , R22) );
assume L856: (R22 <= R23 implies ( D96 . R11 ) = ( R26 . R11 ));
assume L857: ( R22 + 1 ) <= R23;
L858: R22 < R23 by L857 , NAT_1:13;
L859: ( IC D96 ) in ( dom R19 ) by L858 , L853;
L860: ( R19 . ( IC D96 ) ) in ( rng R19 ) by L859 , FUNCT_1:def 3;
L861: ( dom R28 ) = ( NAT ) by PARTFUN1:def 2;
L862: ( R28 /. ( IC D96 ) ) = ( R28 . ( IC D96 ) ) by L861 , PARTFUN1:def 6;
L863: ( R19 . ( IC D96 ) ) = ( R28 . ( IC D96 ) ) by L859 , L852 , GRFUNC_1:2;
L864: ( UsedInt*Loc ( R28 . ( IC D96 ) ) ) c= ( UsedInt*Loc R19 ) by L863 , L860 , L475;
L865: (not R11 in ( UsedInt*Loc ( R28 . ( IC D96 ) ) )) by L864 , L854;
thus L866: ( ( Comput (R28 , R26 , ( R22 + 1 )) ) . R11 ) = ( ( Following (R28 , D96) ) . R11 ) by EXTPRO_1:3
.= ( R26 . R11 ) by L856 , L857 , L865 , L804 , L862 , NAT_1:13;
end;
L867: S4[ ( 0 ) ];
L868: (for R22 being (Element of ( NAT )) holds S4[ R22 ]) from NAT_1:sch 1(L867 , L855);
thus L869: thesis by L868;
end;
theorem
L870: (for R15 being (Instruction of ( SCM+FSA )) holds (for R26 being (State of ( SCM+FSA )) holds (for R27 being (State of ( SCM+FSA )) holds ((( R26 | ( UsedIntLoc R15 ) ) = ( R27 | ( UsedIntLoc R15 ) ) & ( R26 | ( UsedInt*Loc R15 ) ) = ( R27 | ( UsedInt*Loc R15 ) ) & ( IC R26 ) = ( IC R27 )) implies (( IC ( Exec (R15 , R26) ) ) = ( IC ( Exec (R15 , R27) ) ) & ( ( Exec (R15 , R26) ) | ( UsedIntLoc R15 ) ) = ( ( Exec (R15 , R27) ) | ( UsedIntLoc R15 ) ) & ( ( Exec (R15 , R26) ) | ( UsedInt*Loc R15 ) ) = ( ( Exec (R15 , R27) ) | ( UsedInt*Loc R15 ) ))))))
proof
let R15 being (Instruction of ( SCM+FSA ));
let R26 being (State of ( SCM+FSA ));
let R27 being (State of ( SCM+FSA ));
assume that
L871: ( R26 | ( UsedIntLoc R15 ) ) = ( R27 | ( UsedIntLoc R15 ) )
and
L872: ( R26 | ( UsedInt*Loc R15 ) ) = ( R27 | ( UsedInt*Loc R15 ) )
and
L873: ( IC R26 ) = ( IC R27 );
set D97 = ( UsedInt*Loc R15 );
set D98 = ( UsedIntLoc R15 );
set D99 = ( Exec (R15 , R27) );
set D100 = ( Exec (R15 , R26) );
L874: ( dom D100 ) = (the carrier of ( SCM+FSA )) by PARTFUN1:def 2
.= ( dom D99 ) by PARTFUN1:def 2;
L875: ( InsCode R15 ) <= 12 by SCMFSA_2:16;
per cases  by L875 , NAT_1:36;
suppose L876: ( InsCode R15 ) = ( 0 );

L877: R15 = ( halt ( SCM+FSA ) ) by L876 , SCMFSA_2:95;
L878: ( Exec (R15 , R26) ) = R26 by L877 , EXTPRO_1:def 3;
thus L879: thesis by L878 , L871 , L872 , L873 , L877 , EXTPRO_1:def 3;
end;
suppose L880: ( InsCode R15 ) = 1;

consider R1 being Int-Location, R2 being Int-Location such that L881: R15 = ( R1 := R2 ) by L880 , SCMFSA_2:30;
L882: D98 = { R1 , R2 } by L881 , L166;
L883: R2 in D98 by L882 , TARSKI:def 2;
L884: ( R26 . R2 ) = ( ( R26 | D98 ) . R2 ) by L883 , FUNCT_1:49;
L885: ( R26 . R2 ) = ( R27 . R2 ) by L884 , L871 , L883 , FUNCT_1:49;
thus L886: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L881 , SCMFSA_2:63
.= ( IC D99 ) by L881 , SCMFSA_2:63;
L887: (R1 = R2 or R1 <> R2);
L888: (( D100 . R2 ) = ( R26 . R2 ) & ( D99 . R2 ) = ( R27 . R2 )) by L887 , L881 , SCMFSA_2:63;
L889: (( D100 . R1 ) = ( R26 . R2 ) & ( D99 . R1 ) = ( R27 . R2 )) by L881 , SCMFSA_2:63;
thus L890: ( D100 | D98 ) = ( D99 | D98 ) by L889 , L874 , L882 , L885 , L888 , GRFUNC_1:30;
L891: D97 = ( {} ) by L881 , L430;
thus L892: ( D100 | D97 ) = ( {} ) by L891 , RELAT_1:81
.= ( D99 | D97 ) by L891 , RELAT_1:81;
end;
suppose L893: ( InsCode R15 ) = 2;

consider R1 being Int-Location, R2 being Int-Location such that L894: R15 = ( AddTo (R1 , R2) ) by L893 , SCMFSA_2:31;
thus L895: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L894 , SCMFSA_2:64
.= ( IC D99 ) by L894 , SCMFSA_2:64;
L896: D98 = { R1 , R2 } by L894 , L166;
L897: R1 in D98 by L896 , TARSKI:def 2;
L898: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L897 , FUNCT_1:49;
L899: ( R26 . R1 ) = ( R27 . R1 ) by L898 , L871 , L897 , FUNCT_1:49;
L900:
now
per cases ;
case L901: R1 = R2;
thus L902: (( D100 . R2 ) = ( ( R26 . R1 ) + ( R26 . R2 ) ) & ( D99 . R2 ) = ( ( R27 . R1 ) + ( R27 . R2 ) )) by L901 , L894 , SCMFSA_2:64;
end;
case L903: R1 <> R2;
thus L904: (( D100 . R2 ) = ( R26 . R2 ) & ( D99 . R2 ) = ( R27 . R2 )) by L903 , L894 , SCMFSA_2:64;
end;
end;
L906: R2 in D98 by L896 , TARSKI:def 2;
L907: ( R26 . R2 ) = ( ( R26 | D98 ) . R2 ) by L906 , FUNCT_1:49;
L908: ( R26 . R2 ) = ( R27 . R2 ) by L907 , L871 , L906 , FUNCT_1:49;
L909: (( D100 . R1 ) = ( ( R26 . R1 ) + ( R26 . R2 ) ) & ( D99 . R1 ) = ( ( R27 . R1 ) + ( R27 . R2 ) )) by L894 , SCMFSA_2:64;
thus L910: ( D100 | D98 ) = ( D99 | D98 ) by L909 , L874 , L896 , L899 , L908 , L900 , GRFUNC_1:30;
L911: D97 = ( {} ) by L894 , L430;
thus L912: ( D100 | D97 ) = ( {} ) by L911 , RELAT_1:81
.= ( D99 | D97 ) by L911 , RELAT_1:81;
end;
suppose L913: ( InsCode R15 ) = 3;

consider R1 being Int-Location, R2 being Int-Location such that L914: R15 = ( SubFrom (R1 , R2) ) by L913 , SCMFSA_2:32;
thus L915: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L914 , SCMFSA_2:65
.= ( IC D99 ) by L914 , SCMFSA_2:65;
L916: D98 = { R1 , R2 } by L914 , L166;
L917: R1 in D98 by L916 , TARSKI:def 2;
L918: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L917 , FUNCT_1:49;
L919: ( R26 . R1 ) = ( R27 . R1 ) by L918 , L871 , L917 , FUNCT_1:49;
L920:
now
per cases ;
case L921: R1 = R2;
thus L922: (( D100 . R2 ) = ( ( R26 . R1 ) - ( R26 . R2 ) ) & ( D99 . R2 ) = ( ( R27 . R1 ) - ( R27 . R2 ) )) by L921 , L914 , SCMFSA_2:65;
end;
case L923: R1 <> R2;
thus L924: (( D100 . R2 ) = ( R26 . R2 ) & ( D99 . R2 ) = ( R27 . R2 )) by L923 , L914 , SCMFSA_2:65;
end;
end;
L926: R2 in D98 by L916 , TARSKI:def 2;
L927: ( R26 . R2 ) = ( ( R26 | D98 ) . R2 ) by L926 , FUNCT_1:49;
L928: ( R26 . R2 ) = ( R27 . R2 ) by L927 , L871 , L926 , FUNCT_1:49;
L929: (( D100 . R1 ) = ( ( R26 . R1 ) - ( R26 . R2 ) ) & ( D99 . R1 ) = ( ( R27 . R1 ) - ( R27 . R2 ) )) by L914 , SCMFSA_2:65;
thus L930: ( D100 | D98 ) = ( D99 | D98 ) by L929 , L874 , L916 , L919 , L928 , L920 , GRFUNC_1:30;
L931: D97 = ( {} ) by L914 , L430;
thus L932: ( D100 | D97 ) = ( {} ) by L931 , RELAT_1:81
.= ( D99 | D97 ) by L931 , RELAT_1:81;
end;
suppose L933: ( InsCode R15 ) = 4;

consider R1 being Int-Location, R2 being Int-Location such that L934: R15 = ( MultBy (R1 , R2) ) by L933 , SCMFSA_2:33;
thus L935: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L934 , SCMFSA_2:66
.= ( IC D99 ) by L934 , SCMFSA_2:66;
L936: D98 = { R1 , R2 } by L934 , L166;
L937: R1 in D98 by L936 , TARSKI:def 2;
L938: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L937 , FUNCT_1:49;
L939: ( R26 . R1 ) = ( R27 . R1 ) by L938 , L871 , L937 , FUNCT_1:49;
L940:
now
per cases ;
case L941: R1 = R2;
thus L942: (( D100 . R2 ) = ( ( R26 . R1 ) * ( R26 . R2 ) ) & ( D99 . R2 ) = ( ( R27 . R1 ) * ( R27 . R2 ) )) by L941 , L934 , SCMFSA_2:66;
end;
case L943: R1 <> R2;
thus L944: (( D100 . R2 ) = ( R26 . R2 ) & ( D99 . R2 ) = ( R27 . R2 )) by L943 , L934 , SCMFSA_2:66;
end;
end;
L946: R2 in D98 by L936 , TARSKI:def 2;
L947: ( R26 . R2 ) = ( ( R26 | D98 ) . R2 ) by L946 , FUNCT_1:49;
L948: ( R26 . R2 ) = ( R27 . R2 ) by L947 , L871 , L946 , FUNCT_1:49;
L949: (( D100 . R1 ) = ( ( R26 . R1 ) * ( R26 . R2 ) ) & ( D99 . R1 ) = ( ( R27 . R1 ) * ( R27 . R2 ) )) by L934 , SCMFSA_2:66;
thus L950: ( D100 | D98 ) = ( D99 | D98 ) by L949 , L874 , L936 , L939 , L948 , L940 , GRFUNC_1:30;
L951: D97 = ( {} ) by L934 , L430;
thus L952: ( D100 | D97 ) = ( {} ) by L951 , RELAT_1:81
.= ( D99 | D97 ) by L951 , RELAT_1:81;
end;
suppose L953: ( InsCode R15 ) = 5;

consider R1 being Int-Location, R2 being Int-Location such that L954: R15 = ( Divide (R1 , R2) ) by L953 , SCMFSA_2:34;
L955: D98 = { R1 , R2 } by L954 , L166;
L956: R1 in D98 by L955 , TARSKI:def 2;
L957: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L956 , FUNCT_1:49;
L958: ( R26 . R1 ) = ( R27 . R1 ) by L957 , L871 , L956 , FUNCT_1:49;
L959: D97 = ( {} ) by L954 , L430;
L960: R2 in D98 by L955 , TARSKI:def 2;
L961: ( R26 . R2 ) = ( ( R26 | D98 ) . R2 ) by L960 , FUNCT_1:49;
L962: ( R26 . R2 ) = ( R27 . R2 ) by L961 , L871 , L960 , FUNCT_1:49;
thus L963:now
per cases ;
suppose L964: R1 = R2;

thus L965: ( IC D100 ) = ( succ ( IC R27 ) ) by L964 , L873 , L954 , SCMFSA_2:68
.= ( IC D99 ) by L954 , L964 , SCMFSA_2:68;
L966: (( D100 . R1 ) = ( ( R26 . R1 ) mod ( R26 . R1 ) ) & ( D99 . R1 ) = ( ( R27 . R1 ) mod ( R27 . R2 ) )) by L954 , L964 , SCMFSA_2:68;
thus L967: ( D100 | D98 ) = ( D99 | D98 ) by L966 , L874 , L955 , L958 , L964 , GRFUNC_1:30;
thus L968: ( D100 | D97 ) = ( {} ) by L959 , RELAT_1:81
.= ( D99 | D97 ) by L959 , RELAT_1:81;
end;
suppose L969: R1 <> R2;

thus L970: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L954 , SCMFSA_2:67
.= ( IC D99 ) by L954 , SCMFSA_2:67;
L971: (( D100 . R2 ) = ( ( R26 . R1 ) mod ( R26 . R2 ) ) & ( D99 . R2 ) = ( ( R27 . R1 ) mod ( R27 . R2 ) )) by L954 , SCMFSA_2:67;
L972: (( D100 . R1 ) = ( ( R26 . R1 ) div ( R26 . R2 ) ) & ( D99 . R1 ) = ( ( R27 . R1 ) div ( R27 . R2 ) )) by L954 , L969 , SCMFSA_2:67;
thus L973: ( D100 | D98 ) = ( D99 | D98 ) by L972 , L874 , L955 , L958 , L962 , L971 , GRFUNC_1:30;
thus L974: ( D100 | D97 ) = ( {} ) by L959 , RELAT_1:81
.= ( D99 | D97 ) by L959 , RELAT_1:81;
end;
end;
end;
suppose L964: ( InsCode R15 ) = 6;

consider R8 being (Element of ( NAT )) such that L965: R15 = ( goto R8 ) by L964 , SCMFSA_2:35;
thus L966: ( IC D100 ) = R8 by L965 , SCMFSA_2:69
.= ( IC D99 ) by L965 , SCMFSA_2:69;
L967: D98 = ( {} ) by L965 , L172;
thus L968: ( D100 | D98 ) = ( {} ) by L967 , RELAT_1:81
.= ( D99 | D98 ) by L967 , RELAT_1:81;
L969: D97 = ( {} ) by L965 , L430;
thus L970: ( D100 | D97 ) = ( {} ) by L969 , RELAT_1:81
.= ( D99 | D97 ) by L969 , RELAT_1:81;
end;
suppose L971: ( InsCode R15 ) = 7;

consider R8 being (Element of ( NAT )), R1 being Int-Location such that L972: R15 = ( R1 =0_goto R8 ) by L971 , SCMFSA_2:36;
L973: D98 = { R1 } by L972 , L175;
L974: R1 in D98 by L973 , TARSKI:def 1;
L975: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L974 , FUNCT_1:49;
L976: ( R26 . R1 ) = ( R27 . R1 ) by L975 , L871 , L974 , FUNCT_1:49;
thus L977:now
per cases ;
suppose L978: ( R26 . R1 ) = ( 0 );

thus L979: ( IC D100 ) = R8 by L978 , L972 , SCMFSA_2:70
.= ( IC D99 ) by L972 , L976 , L978 , SCMFSA_2:70;
end;
suppose L980: ( R26 . R1 ) <> ( 0 );

thus L981: ( IC D100 ) = ( succ ( IC R26 ) ) by L980 , L972 , SCMFSA_2:70
.= ( IC D99 ) by L873 , L972 , L976 , L980 , SCMFSA_2:70;
end;
end;
L983: (( D100 . R1 ) = ( R26 . R1 ) & ( D99 . R1 ) = ( R27 . R1 )) by L972 , SCMFSA_2:70;
thus L984: ( D100 | D98 ) = ( D99 | D98 ) by L983 , L871 , L874 , L973 , L974 , L975 , FUNCT_1:49 , GRFUNC_1:29;
L985: D97 = ( {} ) by L972 , L430;
thus L986: ( D100 | D97 ) = ( {} ) by L985 , RELAT_1:81
.= ( D99 | D97 ) by L985 , RELAT_1:81;
end;
suppose L987: ( InsCode R15 ) = 8;

consider R8 being (Element of ( NAT )), R1 being Int-Location such that L988: R15 = ( R1 >0_goto R8 ) by L987 , SCMFSA_2:37;
L989: D98 = { R1 } by L988 , L175;
L990: R1 in D98 by L989 , TARSKI:def 1;
L991: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L990 , FUNCT_1:49;
L992: ( R26 . R1 ) = ( R27 . R1 ) by L991 , L871 , L990 , FUNCT_1:49;
thus L993:now
per cases ;
suppose L994: ( R26 . R1 ) > ( 0 );

thus L995: ( IC D100 ) = R8 by L994 , L988 , SCMFSA_2:71
.= ( IC D99 ) by L988 , L992 , L994 , SCMFSA_2:71;
end;
suppose L996: ( R26 . R1 ) <= ( 0 );

thus L997: ( IC D100 ) = ( succ ( IC R26 ) ) by L996 , L988 , SCMFSA_2:71
.= ( IC D99 ) by L873 , L988 , L992 , L996 , SCMFSA_2:71;
end;
end;
L999: (( D100 . R1 ) = ( R26 . R1 ) & ( D99 . R1 ) = ( R27 . R1 )) by L988 , SCMFSA_2:71;
thus L1000: ( D100 | D98 ) = ( D99 | D98 ) by L999 , L871 , L874 , L989 , L990 , L991 , FUNCT_1:49 , GRFUNC_1:29;
L1001: D97 = ( {} ) by L988 , L430;
thus L1002: ( D100 | D97 ) = ( {} ) by L1001 , RELAT_1:81
.= ( D99 | D97 ) by L1001 , RELAT_1:81;
end;
suppose L1003: ( InsCode R15 ) = 9;

consider R1 being Int-Location, R2 being Int-Location, R11 being FinSeq-Location such that L1004: R15 = ( R2 := (R11 , R1) ) by L1003 , SCMFSA_2:38;
L1005: D98 = { R1 , R2 } by L1004 , L180;
L1006: R1 in D98 by L1005 , TARSKI:def 2;
L1007: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L1006 , FUNCT_1:49;
L1008: ( R26 . R1 ) = ( R27 . R1 ) by L1007 , L871 , L1006 , FUNCT_1:49;
thus L1009: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L1004 , SCMFSA_2:72
.= ( IC D99 ) by L1004 , SCMFSA_2:72;
L1010: D97 = { R11 } by L1004 , L434;
L1011: R11 in D97 by L1010 , TARSKI:def 1;
L1012: ( R26 . R11 ) = ( ( R26 | D97 ) . R11 ) by L1011 , FUNCT_1:49;
L1013: ((ex R22 being (Element of ( NAT )) st (R22 = ( abs ( R26 . R1 ) ) & ( D100 . R2 ) = ( ( R26 . R11 ) /. R22 ))) & (ex R23 being (Element of ( NAT )) st (R23 = ( abs ( R27 . R1 ) ) & ( D99 . R2 ) = ( ( R27 . R11 ) /. R23 )))) by L1004 , SCMFSA_2:72;
L1014:
now
per cases ;
case L1015: R1 = R2;
thus L1016: ( D100 . R2 ) = ( D99 . R2 ) by L872 , L1011 , L1012 , L1008 , L1013 , FUNCT_1:49;
end;
case L1017: R1 <> R2;
thus L1018: (( D100 . R1 ) = ( R26 . R1 ) & ( D99 . R1 ) = ( R27 . R1 )) by L1017 , L1004 , SCMFSA_2:72;
end;
end;
L1020: ( R26 . R11 ) = ( R27 . R11 ) by L872 , L1011 , L1012 , FUNCT_1:49;
thus L1021: ( D100 | D98 ) = ( D99 | D98 ) by L1020 , L874 , L1005 , L1008 , L1013 , L1014 , GRFUNC_1:30;
L1022: (( D100 . R11 ) = ( R26 . R11 ) & ( D99 . R11 ) = ( R27 . R11 )) by L1004 , SCMFSA_2:72;
thus L1023: thesis by L1022 , L872 , L874 , L1010 , L1011 , L1012 , FUNCT_1:49 , GRFUNC_1:29;
end;
suppose L1024: ( InsCode R15 ) = 10;

consider R1 being Int-Location, R2 being Int-Location, R11 being FinSeq-Location such that L1025: R15 = ( (R11 , R1) := R2 ) by L1024 , SCMFSA_2:39;
thus L1026: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L1025 , SCMFSA_2:73
.= ( IC D99 ) by L1025 , SCMFSA_2:73;
L1027: (( D99 . R1 ) = ( R27 . R1 ) & ( D99 . R2 ) = ( R27 . R2 )) by L1025 , SCMFSA_2:73;
L1028: D98 = { R1 , R2 } by L1025 , L180;
L1029: R1 in D98 by L1028 , TARSKI:def 2;
L1030: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L1029 , FUNCT_1:49;
L1031: ( R26 . R1 ) = ( R27 . R1 ) by L1030 , L871 , L1029 , FUNCT_1:49;
L1032: R2 in D98 by L1028 , TARSKI:def 2;
L1033: ( R26 . R2 ) = ( ( R26 | D98 ) . R2 ) by L1032 , FUNCT_1:49;
L1034: ( R26 . R2 ) = ( R27 . R2 ) by L1033 , L871 , L1032 , FUNCT_1:49;
L1035: D97 = { R11 } by L1025 , L434;
L1036: R11 in D97 by L1035 , TARSKI:def 1;
L1037: ( R26 . R11 ) = ( ( R26 | D97 ) . R11 ) by L1036 , FUNCT_1:49;
L1038: ( R26 . R11 ) = ( R27 . R11 ) by L1037 , L872 , L1036 , FUNCT_1:49;
L1039: (( D100 . R1 ) = ( R26 . R1 ) & ( D100 . R2 ) = ( R26 . R2 )) by L1025 , SCMFSA_2:73;
thus L1040: ( D100 | D98 ) = ( D99 | D98 ) by L1039 , L874 , L1028 , L1031 , L1034 , L1027 , GRFUNC_1:30;
L1041: ((ex R22 being (Element of ( NAT )) st (R22 = ( abs ( R26 . R1 ) ) & ( D100 . R11 ) = ( ( R26 . R11 ) +* (R22 , ( R26 . R2 )) ))) & (ex R23 being (Element of ( NAT )) st (R23 = ( abs ( R27 . R1 ) ) & ( D99 . R11 ) = ( ( R27 . R11 ) +* (R23 , ( R27 . R2 )) )))) by L1025 , SCMFSA_2:73;
thus L1042: thesis by L1041 , L874 , L1035 , L1031 , L1034 , L1038 , GRFUNC_1:29;
end;
suppose L1043: ( InsCode R15 ) = 11;

consider R1 being Int-Location, R11 being FinSeq-Location such that L1044: R15 = ( R1 :=len R11 ) by L1043 , SCMFSA_2:40;
thus L1045: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L1044 , SCMFSA_2:74
.= ( IC D99 ) by L1044 , SCMFSA_2:74;
L1046: ( D99 . R1 ) = ( len ( R27 . R11 ) ) by L1044 , SCMFSA_2:74;
L1047: (D98 = { R1 } & ( D100 . R1 ) = ( len ( R26 . R11 ) )) by L1044 , L185 , SCMFSA_2:74;
L1048: D97 = { R11 } by L1044 , L441;
L1049: R11 in D97 by L1048 , TARSKI:def 1;
L1050: ( R26 . R11 ) = ( ( R26 | D97 ) . R11 ) by L1049 , FUNCT_1:49;
L1051: ( R26 . R11 ) = ( R27 . R11 ) by L1050 , L872 , L1049 , FUNCT_1:49;
thus L1052: ( D100 | D98 ) = ( D99 | D98 ) by L1051 , L874 , L1047 , L1046 , GRFUNC_1:29;
L1053: (( D100 . R11 ) = ( R26 . R11 ) & ( D99 . R11 ) = ( R27 . R11 )) by L1044 , SCMFSA_2:74;
thus L1054: thesis by L1053 , L872 , L874 , L1048 , L1049 , L1050 , FUNCT_1:49 , GRFUNC_1:29;
end;
suppose L1055: ( InsCode R15 ) = 12;

consider R1 being Int-Location, R11 being FinSeq-Location such that L1056: R15 = ( R11 :=<0,...,0> R1 ) by L1055 , SCMFSA_2:41;
thus L1057: ( IC D100 ) = ( succ ( IC R27 ) ) by L873 , L1056 , SCMFSA_2:75
.= ( IC D99 ) by L1056 , SCMFSA_2:75;
L1058: D98 = { R1 } by L1056 , L185;
L1059: R1 in D98 by L1058 , TARSKI:def 1;
L1060: ( R26 . R1 ) = ( ( R26 | D98 ) . R1 ) by L1059 , FUNCT_1:49;
L1061: (D97 = { R11 } & (ex R22 being (Element of ( NAT )) st (R22 = ( abs ( R26 . R1 ) ) & ( D100 . R11 ) = ( R22 |-> ( 0 ) )))) by L1056 , L441 , SCMFSA_2:75;
L1062: (( D100 . R1 ) = ( R26 . R1 ) & ( D99 . R1 ) = ( R27 . R1 )) by L1056 , SCMFSA_2:75;
thus L1063: ( D100 | D98 ) = ( D99 | D98 ) by L1062 , L871 , L874 , L1058 , L1059 , L1060 , FUNCT_1:49 , GRFUNC_1:29;
L1064: (ex R23 being (Element of ( NAT )) st (R23 = ( abs ( R27 . R1 ) ) & ( D99 . R11 ) = ( R23 |-> ( 0 ) ))) by L1056 , SCMFSA_2:75;
L1065: ( R26 . R1 ) = ( R27 . R1 ) by L871 , L1059 , L1060 , FUNCT_1:49;
thus L1066: thesis by L1065 , L874 , L1061 , L1064 , GRFUNC_1:29;
end;
end;
theorem
L1068: (for R19 being (Program of ( SCM+FSA )) holds (for R23 being (Element of ( NAT )) holds (for R26 being (State of ( SCM+FSA )) holds (for R27 being (State of ( SCM+FSA )) holds (for B82 , B83 being (Instruction-Sequence of ( SCM+FSA )) holds ((R19 c= B82 & R19 c= B83 & ( Start-At (( 0 ) , ( SCM+FSA )) ) c= R26 & ( Start-At (( 0 ) , ( SCM+FSA )) ) c= R27 & ( R26 | ( UsedIntLoc R19 ) ) = ( R27 | ( UsedIntLoc R19 ) ) & ( R26 | ( UsedInt*Loc R19 ) ) = ( R27 | ( UsedInt*Loc R19 ) ) & (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (B82 , R26 , R22) ) ) in ( dom R19 )))) implies ((for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (B83 , R27 , R22) ) ) in ( dom R19 ))) & (for R22 being (Element of ( NAT )) holds (R22 <= R23 implies (( IC ( Comput (B82 , R26 , R22) ) ) = ( IC ( Comput (B83 , R27 , R22) ) ) & (for R1 being Int-Location holds (R1 in ( UsedIntLoc R19 ) implies ( ( Comput (B82 , R26 , R22) ) . R1 ) = ( ( Comput (B83 , R27 , R22) ) . R1 ))) & (for R11 being FinSeq-Location holds (R11 in ( UsedInt*Loc R19 ) implies ( ( Comput (B82 , R26 , R22) ) . R11 ) = ( ( Comput (B83 , R27 , R22) ) . R11 )))))))))))))
proof
let R19 being (Program of ( SCM+FSA ));
let R23 being (Element of ( NAT ));
let R26 being (State of ( SCM+FSA ));
let R27 being (State of ( SCM+FSA ));
let C160 , C161 being (Instruction-Sequence of ( SCM+FSA ));
assume that
L1069: (R19 c= C160 & R19 c= C161);
assume that
L1070: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= R26
and
L1071: ( Start-At (( 0 ) , ( SCM+FSA )) ) c= R27
and
L1072: ( R26 | ( UsedIntLoc R19 ) ) = ( R27 | ( UsedIntLoc R19 ) )
and
L1073: ( R26 | ( UsedInt*Loc R19 ) ) = ( R27 | ( UsedInt*Loc R19 ) )
and
L1074: (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (C160 , R26 , R22) ) ) in ( dom R19 )));
defpred S5[ Nat ] means ($1 < R23 implies (( IC ( Comput (C161 , R27 , $1) ) ) in ( dom R19 ) & ( IC ( Comput (C160 , R26 , $1) ) ) = ( IC ( Comput (C161 , R27 , $1) ) ) & (for R1 being Int-Location holds (R1 in ( UsedIntLoc R19 ) implies ( ( Comput (C160 , R26 , $1) ) . R1 ) = ( ( Comput (C161 , R27 , $1) ) . R1 ))) & (for R11 being FinSeq-Location holds (R11 in ( UsedInt*Loc R19 ) implies ( ( Comput (C160 , R26 , $1) ) . R11 ) = ( ( Comput (C161 , R27 , $1) ) . R11 )))));
L1075:
now
let R22 being (Element of ( NAT ));
assume L1076: S5[ R22 ];
thus L1077: S5[ ( R22 + 1 ) ]
proof
set D101 = ( C160 . ( IC ( Comput (C160 , R26 , R22) ) ) );
L1078: ( dom C160 ) = ( NAT ) by PARTFUN1:def 2;
L1079: ( C160 /. ( IC ( Comput (C160 , R26 , R22) ) ) ) = ( C160 . ( IC ( Comput (C160 , R26 , R22) ) ) ) by L1078 , PARTFUN1:def 6;
set D102 = ( R22 + 1 );
L1080: ( Comput (C160 , R26 , D102) ) = ( Following (C160 , ( Comput (C160 , R26 , R22) )) ) by EXTPRO_1:3
.= ( Exec (( C160 . ( IC ( Comput (C160 , R26 , R22) ) ) ) , ( Comput (C160 , R26 , R22) )) ) by L1079;
assume L1081: D102 < R23;
L1082:
now
thus L1083: ( dom ( ( Comput (C160 , R26 , R22) ) | ( UsedInt*Loc R19 ) ) ) = ( ( dom ( Comput (C160 , R26 , R22) ) ) /\ ( UsedInt*Loc R19 ) ) by RELAT_1:61
.= ( (the carrier of ( SCM+FSA )) /\ ( UsedInt*Loc R19 ) ) by PARTFUN1:def 2
.= ( ( dom ( Comput (C161 , R27 , R22) ) ) /\ ( UsedInt*Loc R19 ) ) by PARTFUN1:def 2;
let C162 being set;
assume L1084: C162 in ( dom ( ( Comput (C160 , R26 , R22) ) | ( UsedInt*Loc R19 ) ) );
L1085: C162 in ( UsedInt*Loc R19 ) by L1084 , RELAT_1:57;
L1086: C162 in ( FinSeq-Locations ) by L1085;
reconsider D103 = C162 as FinSeq-Location by L1086 , SCMFSA_2:def 5;
thus L1087: ( ( ( Comput (C160 , R26 , R22) ) | ( UsedInt*Loc R19 ) ) . C162 ) = ( ( Comput (C160 , R26 , R22) ) . D103 ) by L1085 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , R22) ) . C162 ) by L1076 , L1081 , L1085 , NAT_1:13;
end;
L1088: ( ( Comput (C160 , R26 , R22) ) | ( UsedInt*Loc R19 ) ) = ( ( Comput (C161 , R27 , R22) ) | ( UsedInt*Loc R19 ) ) by L1082 , FUNCT_1:46;
L1089: ( C160 . ( IC ( Comput (C160 , R26 , R22) ) ) ) = ( R19 . ( IC ( Comput (C160 , R26 , R22) ) ) ) by L1076 , L1081 , L1069 , GRFUNC_1:2 , NAT_1:13;
L1090: ( C160 . ( IC ( Comput (C160 , R26 , R22) ) ) ) = ( C161 . ( IC ( Comput (C161 , R27 , R22) ) ) ) by L1089 , L1076 , L1081 , L1069 , GRFUNC_1:2 , NAT_1:13;
L1091:
now
thus L1092: ( dom ( ( Comput (C160 , R26 , R22) ) | ( UsedIntLoc R19 ) ) ) = ( ( dom ( Comput (C160 , R26 , R22) ) ) /\ ( UsedIntLoc R19 ) ) by RELAT_1:61
.= ( (the carrier of ( SCM+FSA )) /\ ( UsedIntLoc R19 ) ) by PARTFUN1:def 2
.= ( ( dom ( Comput (C161 , R27 , R22) ) ) /\ ( UsedIntLoc R19 ) ) by PARTFUN1:def 2;
let C163 being set;
assume L1093: C163 in ( dom ( ( Comput (C160 , R26 , R22) ) | ( UsedIntLoc R19 ) ) );
L1094: C163 in ( UsedIntLoc R19 ) by L1093 , RELAT_1:57;
L1095: C163 in ( Int-Locations ) by L1094;
reconsider D104 = C163 as Int-Location by L1095 , AMI_2:def 16;
thus L1096: ( ( ( Comput (C160 , R26 , R22) ) | ( UsedIntLoc R19 ) ) . C163 ) = ( ( Comput (C160 , R26 , R22) ) . D104 ) by L1094 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , R22) ) . C163 ) by L1076 , L1081 , L1094 , NAT_1:13;
end;
L1097: ( ( Comput (C160 , R26 , R22) ) | ( UsedIntLoc R19 ) ) = ( ( Comput (C161 , R27 , R22) ) | ( UsedIntLoc R19 ) ) by L1091 , FUNCT_1:46;
L1098: ( dom C161 ) = ( NAT ) by PARTFUN1:def 2;
L1099: ( C161 /. ( IC ( Comput (C161 , R27 , R22) ) ) ) = ( C161 . ( IC ( Comput (C161 , R27 , R22) ) ) ) by L1098 , PARTFUN1:def 6;
L1100: ( Comput (C161 , R27 , D102) ) = ( Following (C161 , ( Comput (C161 , R27 , R22) )) ) by EXTPRO_1:3
.= ( Exec (( C161 . ( IC ( Comput (C161 , R27 , R22) ) ) ) , ( Comput (C161 , R27 , R22) )) ) by L1099;
L1101: R22 < R23 by L1081 , NAT_1:13;
L1102: ( IC ( Comput (C160 , R26 , R22) ) ) in ( dom R19 ) by L1101 , L1074;
L1103: D101 in ( rng R19 ) by L1102 , L1089 , FUNCT_1:def 3;
L1104: ( ( Comput (C160 , R26 , R22) ) | ( UsedInt*Loc D101 ) ) = ( ( ( Comput (C160 , R26 , R22) ) | ( UsedInt*Loc R19 ) ) | ( UsedInt*Loc D101 ) ) by L1103 , L475 , RELAT_1:74
.= ( ( Comput (C161 , R27 , R22) ) | ( UsedInt*Loc D101 ) ) by L1103 , L1088 , L475 , RELAT_1:74;
L1105: ( ( Comput (C160 , R26 , R22) ) | ( UsedIntLoc D101 ) ) = ( ( ( Comput (C160 , R26 , R22) ) | ( UsedIntLoc R19 ) ) | ( UsedIntLoc D101 ) ) by L1103 , L217 , RELAT_1:74
.= ( ( Comput (C161 , R27 , R22) ) | ( UsedIntLoc D101 ) ) by L1103 , L1097 , L217 , RELAT_1:74;
L1106: ( ( Exec (D101 , ( Comput (C160 , R26 , R22) )) ) | ( UsedInt*Loc D101 ) ) = ( ( Exec (D101 , ( Comput (C161 , R27 , R22) )) ) | ( UsedInt*Loc D101 ) ) by L1105 , L1076 , L1081 , L1104 , L870 , NAT_1:13;
L1107: ( IC ( Exec (D101 , ( Comput (C160 , R26 , R22) )) ) ) = ( IC ( Exec (D101 , ( Comput (C161 , R27 , R22) )) ) ) by L1076 , L1081 , L1105 , L1104 , L870 , NAT_1:13;
thus L1108: ( IC ( Comput (C161 , R27 , D102) ) ) in ( dom R19 ) by L1107 , L1074 , L1081 , L1080 , L1100 , L1090;
thus L1109: ( IC ( Comput (C160 , R26 , D102) ) ) = ( IC ( Comput (C161 , R27 , D102) ) ) by L1076 , L1081 , L1080 , L1100 , L1089 , L1107 , L1069 , GRFUNC_1:2 , NAT_1:13;
L1110: ( ( Exec (D101 , ( Comput (C160 , R26 , R22) )) ) | ( UsedIntLoc D101 ) ) = ( ( Exec (D101 , ( Comput (C161 , R27 , R22) )) ) | ( UsedIntLoc D101 ) ) by L1076 , L1081 , L1105 , L1104 , L870 , NAT_1:13;
thus L1111:now
let R1 being Int-Location;
assume L1112: R1 in ( UsedIntLoc R19 );
per cases ;
suppose L1113: R1 in ( UsedIntLoc D101 );

thus L1114: ( ( Comput (C160 , R26 , D102) ) . R1 ) = ( ( ( Exec (D101 , ( Comput (C160 , R26 , R22) )) ) | ( UsedIntLoc D101 ) ) . R1 ) by L1113 , L1080 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , D102) ) . R1 ) by L1100 , L1090 , L1110 , L1113 , FUNCT_1:49;
end;
suppose L1115: (not R1 in ( UsedIntLoc D101 ));

thus L1116: ( ( Comput (C160 , R26 , D102) ) . R1 ) = ( ( Comput (C160 , R26 , R22) ) . R1 ) by L1115 , L1080 , L728
.= ( ( Comput (C161 , R27 , R22) ) . R1 ) by L1076 , L1081 , L1112 , NAT_1:13
.= ( ( Comput (C161 , R27 , D102) ) . R1 ) by L1100 , L1090 , L1115 , L728;
end;
end;
let R11 being FinSeq-Location;
assume L1118: R11 in ( UsedInt*Loc R19 );
per cases ;
suppose L1119: R11 in ( UsedInt*Loc D101 );

thus L1120: ( ( Comput (C160 , R26 , D102) ) . R11 ) = ( ( ( Exec (D101 , ( Comput (C160 , R26 , R22) )) ) | ( UsedInt*Loc D101 ) ) . R11 ) by L1119 , L1080 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , D102) ) . R11 ) by L1100 , L1090 , L1106 , L1119 , FUNCT_1:49;
end;
suppose L1121: (not R11 in ( UsedInt*Loc D101 ));

thus L1122: ( ( Comput (C160 , R26 , D102) ) . R11 ) = ( ( Comput (C160 , R26 , R22) ) . R11 ) by L1121 , L1080 , L804
.= ( ( Comput (C161 , R27 , R22) ) . R11 ) by L1076 , L1081 , L1118 , NAT_1:13
.= ( ( Comput (C161 , R27 , D102) ) . R11 ) by L1100 , L1090 , L1121 , L804;
end;
end;

end;
L1078: S5[ ( 0 ) ]
proof
L1079: ( IC ( Comput (C161 , R27 , ( 0 )) ) ) = ( IC R27 )
.= ( 0 ) by L1071 , MEMSTR_0:39;
L1080: ( IC ( Comput (C160 , R26 , ( 0 )) ) ) = ( IC R26 )
.= ( 0 ) by L1070 , MEMSTR_0:39;
assume L1081: ( 0 ) < R23;
thus L1082: ( IC ( Comput (C161 , R27 , ( 0 )) ) ) in ( dom R19 ) by L1081 , L1074 , L1080 , L1079;
thus L1083: ( IC ( Comput (C160 , R26 , ( 0 )) ) ) = ( IC ( Comput (C161 , R27 , ( 0 )) ) ) by L1080 , L1079;
thus L1084:now
let R1 being Int-Location;
assume L1085: R1 in ( UsedIntLoc R19 );
thus L1086: ( ( Comput (C160 , R26 , ( 0 )) ) . R1 ) = ( R26 . R1 )
.= ( ( R26 | ( UsedIntLoc R19 ) ) . R1 ) by L1085 , FUNCT_1:49
.= ( R27 . R1 ) by L1072 , L1085 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , ( 0 )) ) . R1 );
end;
let R11 being FinSeq-Location;
assume L1087: R11 in ( UsedInt*Loc R19 );
thus L1088: ( ( Comput (C160 , R26 , ( 0 )) ) . R11 ) = ( R26 . R11 )
.= ( ( R26 | ( UsedInt*Loc R19 ) ) . R11 ) by L1087 , FUNCT_1:49
.= ( R27 . R11 ) by L1073 , L1087 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , ( 0 )) ) . R11 );
end;
L1089: (for R22 being (Element of ( NAT )) holds S5[ R22 ]) from NAT_1:sch 1(L1078 , L1075);
thus L1090: (for R22 being (Element of ( NAT )) holds (R22 < R23 implies ( IC ( Comput (C161 , R27 , R22) ) ) in ( dom R19 ))) by L1089;
let R22 being (Element of ( NAT ));
assume L1091: R22 <= R23;
per cases  by NAT_1:6;
suppose L1092: R22 = ( 0 );

L1093: ( IC ( Comput (C161 , R27 , ( 0 )) ) ) = ( IC R27 )
.= ( 0 ) by L1071 , MEMSTR_0:39;
L1094: ( IC ( Comput (C160 , R26 , ( 0 )) ) ) = ( IC R26 )
.= ( 0 ) by L1070 , MEMSTR_0:39;
thus L1095: ( IC ( Comput (C160 , R26 , R22) ) ) = ( IC ( Comput (C161 , R27 , R22) ) ) by L1094 , L1092 , L1093;
thus L1096:now
let R1 being Int-Location;
assume L1097: R1 in ( UsedIntLoc R19 );
thus L1098: ( ( Comput (C160 , R26 , R22) ) . R1 ) = ( R26 . R1 ) by L1092 , EXTPRO_1:2
.= ( ( R26 | ( UsedIntLoc R19 ) ) . R1 ) by L1097 , FUNCT_1:49
.= ( R27 . R1 ) by L1072 , L1097 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , R22) ) . R1 ) by L1092 , EXTPRO_1:2;
end;
let R11 being FinSeq-Location;
assume L1099: R11 in ( UsedInt*Loc R19 );
thus L1100: ( ( Comput (C160 , R26 , R22) ) . R11 ) = ( R26 . R11 ) by L1092 , EXTPRO_1:2
.= ( ( R26 | ( UsedInt*Loc R19 ) ) . R11 ) by L1099 , FUNCT_1:49
.= ( R27 . R11 ) by L1073 , L1099 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , R22) ) . R11 ) by L1092 , EXTPRO_1:2;
end;
suppose L1101: (ex B84 being Nat st R22 = ( B84 + 1 ));

consider C164 being Nat such that L1102: R22 = ( C164 + 1 ) by L1101;
reconsider D105 = C164 as (Element of ( NAT )) by ORDINAL1:def 12;
L1103: D105 < R23 by L1091 , L1102 , NAT_1:13;
L1104: ( IC ( Comput (C160 , R26 , D105) ) ) in ( dom R19 ) by L1103 , L1074;
L1105:
now
thus L1106: ( dom ( ( Comput (C160 , R26 , D105) ) | ( UsedInt*Loc R19 ) ) ) = ( ( dom ( Comput (C160 , R26 , D105) ) ) /\ ( UsedInt*Loc R19 ) ) by RELAT_1:61
.= ( (the carrier of ( SCM+FSA )) /\ ( UsedInt*Loc R19 ) ) by PARTFUN1:def 2
.= ( ( dom ( Comput (C161 , R27 , D105) ) ) /\ ( UsedInt*Loc R19 ) ) by PARTFUN1:def 2;
let C165 being set;
assume L1107: C165 in ( dom ( ( Comput (C160 , R26 , D105) ) | ( UsedInt*Loc R19 ) ) );
L1108: C165 in ( UsedInt*Loc R19 ) by L1107 , RELAT_1:57;
L1109: C165 in ( FinSeq-Locations ) by L1108;
reconsider D106 = C165 as FinSeq-Location by L1109 , SCMFSA_2:def 5;
thus L1110: ( ( ( Comput (C160 , R26 , D105) ) | ( UsedInt*Loc R19 ) ) . C165 ) = ( ( Comput (C160 , R26 , D105) ) . D106 ) by L1108 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , D105) ) . C165 ) by L1089 , L1103 , L1108;
end;
L1111: ( ( Comput (C160 , R26 , D105) ) | ( UsedInt*Loc R19 ) ) = ( ( Comput (C161 , R27 , D105) ) | ( UsedInt*Loc R19 ) ) by L1105 , FUNCT_1:46;
set D107 = ( C160 . ( IC ( Comput (C160 , R26 , D105) ) ) );
set D108 = ( D105 + 1 );
L1112: ( dom C160 ) = ( NAT ) by PARTFUN1:def 2;
L1113: ( C160 /. ( IC ( Comput (C160 , R26 , D105) ) ) ) = ( C160 . ( IC ( Comput (C160 , R26 , D105) ) ) ) by L1112 , PARTFUN1:def 6;
L1114: ( Comput (C160 , R26 , D108) ) = ( Following (C160 , ( Comput (C160 , R26 , D105) )) ) by EXTPRO_1:3
.= ( Exec (( C160 . ( IC ( Comput (C160 , R26 , D105) ) ) ) , ( Comput (C160 , R26 , D105) )) ) by L1113;
L1115:
now
thus L1116: ( dom ( ( Comput (C160 , R26 , D105) ) | ( UsedIntLoc R19 ) ) ) = ( ( dom ( Comput (C160 , R26 , D105) ) ) /\ ( UsedIntLoc R19 ) ) by RELAT_1:61
.= ( (the carrier of ( SCM+FSA )) /\ ( UsedIntLoc R19 ) ) by PARTFUN1:def 2
.= ( ( dom ( Comput (C161 , R27 , D105) ) ) /\ ( UsedIntLoc R19 ) ) by PARTFUN1:def 2;
let C166 being set;
assume L1117: C166 in ( dom ( ( Comput (C160 , R26 , D105) ) | ( UsedIntLoc R19 ) ) );
L1118: C166 in ( UsedIntLoc R19 ) by L1117 , RELAT_1:57;
L1119: C166 in ( Int-Locations ) by L1118;
reconsider D109 = C166 as Int-Location by L1119 , AMI_2:def 16;
thus L1120: ( ( ( Comput (C160 , R26 , D105) ) | ( UsedIntLoc R19 ) ) . C166 ) = ( ( Comput (C160 , R26 , D105) ) . D109 ) by L1118 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , D105) ) . C166 ) by L1089 , L1103 , L1118;
end;
L1121: ( ( Comput (C160 , R26 , D105) ) | ( UsedIntLoc R19 ) ) = ( ( Comput (C161 , R27 , D105) ) | ( UsedIntLoc R19 ) ) by L1115 , FUNCT_1:46;
L1122: ( IC ( Comput (C160 , R26 , D105) ) ) = ( IC ( Comput (C161 , R27 , D105) ) ) by L1089 , L1103;
L1123: ( C160 . ( IC ( Comput (C160 , R26 , D105) ) ) ) = ( R19 . ( IC ( Comput (C160 , R26 , D105) ) ) ) by L1104 , L1069 , GRFUNC_1:2;
L1124: ( dom C161 ) = ( NAT ) by PARTFUN1:def 2;
L1125: ( C161 /. ( IC ( Comput (C161 , R27 , D105) ) ) ) = ( C161 . ( IC ( Comput (C161 , R27 , D105) ) ) ) by L1124 , PARTFUN1:def 6;
L1126: ( Comput (C161 , R27 , D108) ) = ( Following (C161 , ( Comput (C161 , R27 , D105) )) ) by EXTPRO_1:3
.= ( Exec (( C161 . ( IC ( Comput (C161 , R27 , D105) ) ) ) , ( Comput (C161 , R27 , D105) )) ) by L1125;
L1127: ( C160 . ( IC ( Comput (C160 , R26 , D105) ) ) ) = ( C161 . ( IC ( Comput (C161 , R27 , D105) ) ) ) by L1122 , L1104 , L1123 , L1069 , GRFUNC_1:2;
L1128: ( IC ( Comput (C160 , R26 , D105) ) ) in ( dom R19 ) by L1074 , L1103;
L1129: D107 in ( rng R19 ) by L1128 , L1123 , FUNCT_1:def 3;
L1130: ( ( Comput (C160 , R26 , D105) ) | ( UsedInt*Loc D107 ) ) = ( ( ( Comput (C160 , R26 , D105) ) | ( UsedInt*Loc R19 ) ) | ( UsedInt*Loc D107 ) ) by L1129 , L475 , RELAT_1:74
.= ( ( Comput (C161 , R27 , D105) ) | ( UsedInt*Loc D107 ) ) by L1129 , L1111 , L475 , RELAT_1:74;
L1131: ( ( Comput (C160 , R26 , D105) ) | ( UsedIntLoc D107 ) ) = ( ( ( Comput (C160 , R26 , D105) ) | ( UsedIntLoc R19 ) ) | ( UsedIntLoc D107 ) ) by L1129 , L217 , RELAT_1:74
.= ( ( Comput (C161 , R27 , D105) ) | ( UsedIntLoc D107 ) ) by L1129 , L1121 , L217 , RELAT_1:74;
thus L1132: ( IC ( Comput (C160 , R26 , R22) ) ) = ( IC ( Comput (C161 , R27 , R22) ) ) by L1131 , L1102 , L1114 , L1126 , L1122 , L1127 , L1130 , L870;
L1133: ( ( Exec (D107 , ( Comput (C160 , R26 , D105) )) ) | ( UsedIntLoc D107 ) ) = ( ( Exec (D107 , ( Comput (C161 , R27 , D105) )) ) | ( UsedIntLoc D107 ) ) by L1122 , L1131 , L1130 , L870;
thus L1134:now
let R1 being Int-Location;
assume L1135: R1 in ( UsedIntLoc R19 );
per cases ;
suppose L1136: R1 in ( UsedIntLoc D107 );

thus L1137: ( ( Comput (C160 , R26 , R22) ) . R1 ) = ( ( ( Exec (D107 , ( Comput (C160 , R26 , D105) )) ) | ( UsedIntLoc D107 ) ) . R1 ) by L1136 , L1102 , L1114 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , R22) ) . R1 ) by L1102 , L1126 , L1127 , L1133 , L1136 , FUNCT_1:49;
end;
suppose L1138: (not R1 in ( UsedIntLoc D107 ));

thus L1139: ( ( Comput (C160 , R26 , R22) ) . R1 ) = ( ( Comput (C160 , R26 , D105) ) . R1 ) by L1138 , L1102 , L1114 , L728
.= ( ( Comput (C161 , R27 , D105) ) . R1 ) by L1089 , L1103 , L1135
.= ( ( Comput (C161 , R27 , R22) ) . R1 ) by L1102 , L1126 , L1127 , L1138 , L728;
end;
end;
L1141: ( ( Exec (D107 , ( Comput (C160 , R26 , D105) )) ) | ( UsedInt*Loc D107 ) ) = ( ( Exec (D107 , ( Comput (C161 , R27 , D105) )) ) | ( UsedInt*Loc D107 ) ) by L1122 , L1131 , L1130 , L870;
thus L1142:now
let R11 being FinSeq-Location;
assume L1143: R11 in ( UsedInt*Loc R19 );
per cases ;
suppose L1144: R11 in ( UsedInt*Loc D107 );

thus L1145: ( ( Comput (C160 , R26 , R22) ) . R11 ) = ( ( ( Exec (D107 , ( Comput (C160 , R26 , D105) )) ) | ( UsedInt*Loc D107 ) ) . R11 ) by L1144 , L1102 , L1114 , FUNCT_1:49
.= ( ( Comput (C161 , R27 , R22) ) . R11 ) by L1102 , L1126 , L1127 , L1141 , L1144 , FUNCT_1:49;
end;
suppose L1146: (not R11 in ( UsedInt*Loc D107 ));

thus L1147: ( ( Comput (C160 , R26 , R22) ) . R11 ) = ( ( Comput (C160 , R26 , D105) ) . R11 ) by L1146 , L1102 , L1114 , L804
.= ( ( Comput (C161 , R27 , D105) ) . R11 ) by L1089 , L1103 , L1143
.= ( ( Comput (C161 , R27 , R22) ) . R11 ) by L1102 , L1126 , L1127 , L1146 , L804;
end;
end;
end;
end;
