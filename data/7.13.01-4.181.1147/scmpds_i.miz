:: The Instructions for the SCMPDS computer
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, CARD_1, AMI_2, INT_1, XBOOLE_0, FINSEQ_1,
      TARSKI, RELAT_1, FUNCT_1, AMI_1, PARTFUN1, XXREAL_0, ZFMISC_1, SCMPDS_1,
      RECDEF_2, UNIALG_1, AMISTD_2, VALUED_0, COMPOS_0;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1,
      XTUPLE_0, SUBSET_1, RELAT_1, FUNCT_1,
      CARD_1, PARTFUN1, MCART_1, NUMBERS, VALUED_0, INT_1, FINSEQ_1, FINSEQ_4,
      XXREAL_0, RECDEF_2, COMPOS_0, SCM_INST;
 constructors FINSEQ_4, AMI_2, DOMAIN_1, COMPOS_0, VALUED_0, XTUPLE_0;
 registrations XBOOLE_0, ORDINAL1, NUMBERS, INT_1, FINSEQ_1, XXREAL_0, FUNCT_1,
      COMPOS_0, SCM_INST, VALUED_0, RELAT_1, GR_CY_1, FINSEQ_4, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE;
 definitions MCART_1, TARSKI, FINSEQ_1, COMPOS_0, XTUPLE_0;
 theorems FINSEQ_1, RELAT_1, COMPOS_0, FINSEQ_4, FUNCT_1, MCART_1, TARSKI,
      ZFMISC_1, INT_1, XBOOLE_0, XBOOLE_1, RECDEF_2, ENUMSET1, NAT_1, XTUPLE_0;

begin
theorem
L1: (for B1 being Integer holds B1 in ( ( SCM-Data-Loc ) \/ ( INT ) ))
proof
let C1 being Integer;
L2: (C1 in ( INT ) & ( INT ) c= ( ( SCM-Data-Loc ) \/ ( INT ) )) by INT_1:def 2 , XBOOLE_1:7;
thus L3: thesis by L2;
end;
begin
definition
func SCMPDS-Instr equals 
( ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B2 *> ] where B2 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B3 *> ] where B3 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B4 , ( {} ) , <* B5 , B6 *> ] where B4 is (Element of ( Segm 15 )) , B5 is (Element of ( SCM-Data-Loc )) , B6 is (Element of ( INT )) : B4 in { 2 , 3 } } ) \/ { [ B7 , ( {} ) , <* B8 , B9 , B10 *> ] where B7 is (Element of ( Segm 15 )) , B8 is (Element of ( SCM-Data-Loc )) , B9 , B10 is (Element of ( INT )) : B7 in { 4 , 5 , 6 , 7 , 8 } } ) \/ { [ B11 , ( {} ) , <* B12 , B13 , B14 , B15 *> ] where B11 is (Element of ( Segm 15 )) , B12 , B13 is (Element of ( SCM-Data-Loc )) , B14 , B15 is (Element of ( INT )) : B11 in { 9 , 10 , 11 , 12 , 13 } } );
coherence;
end;
L5: [ ( 0 ) , ( {} ) , ( {} ) ] in ( SCMPDS-Instr )
proof
set D1 = { [ 14 , ( {} ) , <* B16 *> ] where B16 is (Element of ( INT )) : (not contradiction) };
set D2 = { [ 1 , ( {} ) , <* R9 *> ] where R9 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
set D3 = { [ B17 , ( {} ) , <* B18 , B19 *> ] where B17 is (Element of ( Segm 15 )) , B18 is (Element of ( SCM-Data-Loc )) , B19 is (Element of ( INT )) : B17 in { 2 , 3 } };
L6: [ ( 0 ) , ( {} ) , ( {} ) ] in { [ ( 0 ) , ( {} ) , ( {} ) ] } by TARSKI:def 1;
L7: [ ( 0 ) , ( {} ) , ( {} ) ] in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D1 ) by L6 , XBOOLE_0:def 3;
L8: [ ( 0 ) , ( {} ) , ( {} ) ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D1 ) \/ D2 ) by L7 , XBOOLE_0:def 3;
L9: [ ( 0 ) , ( {} ) , ( {} ) ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D1 ) \/ D2 ) \/ D3 ) by L8 , XBOOLE_0:def 3;
L10: [ ( 0 ) , ( {} ) , ( {} ) ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D1 ) \/ D2 ) \/ D3 ) \/ { [ B20 , ( {} ) , <* B21 , B22 , B23 *> ] where B20 is (Element of ( Segm 15 )) , B21 is (Element of ( SCM-Data-Loc )) , B22 , B23 is (Element of ( INT )) : B20 in { 4 , 5 , 6 , 7 , 8 } } ) by L9 , XBOOLE_0:def 3;
thus L11: thesis by L10 , XBOOLE_0:def 3;
end;
theorem
L12: [ 14 , ( {} ) , <* ( 0 ) *> ] in ( SCMPDS-Instr )
proof
set D4 = { [ 14 , ( {} ) , <* B24 *> ] where B24 is (Element of ( INT )) : (not contradiction) };
set D5 = { [ 1 , ( {} ) , <* R9 *> ] where R9 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
set D6 = { [ B25 , ( {} ) , <* B26 , B27 *> ] where B25 is (Element of ( Segm 15 )) , B26 is (Element of ( SCM-Data-Loc )) , B27 is (Element of ( INT )) : B25 in { 2 , 3 } };
L13: ( 0 ) is (Element of ( INT )) by INT_1:def 2;
L14: [ 14 , ( {} ) , <* ( 0 ) *> ] in D4 by L13;
L15: [ 14 , ( {} ) , <* ( 0 ) *> ] in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D4 ) by L14 , XBOOLE_0:def 3;
L16: [ 14 , ( {} ) , <* ( 0 ) *> ] in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D4 ) \/ D5 ) by L15 , XBOOLE_0:def 3;
L17: [ 14 , ( {} ) , <* ( 0 ) *> ] in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D4 ) \/ D5 ) \/ D6 ) by L16 , XBOOLE_0:def 3;
L18: [ 14 , ( {} ) , <* ( 0 ) *> ] in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ D4 ) \/ D5 ) \/ D6 ) \/ { [ B28 , ( {} ) , <* B29 , B30 , B31 *> ] where B28 is (Element of ( Segm 15 )) , B29 is (Element of ( SCM-Data-Loc )) , B30 , B31 is (Element of ( INT )) : B28 in { 4 , 5 , 6 , 7 , 8 } } ) by L17 , XBOOLE_0:def 3;
thus L19: thesis by L18 , XBOOLE_0:def 3;
end;
registration
cluster ( SCMPDS-Instr ) -> non  empty;
coherence;
end;
definition
let C2 being (Element of ( SCM-Data-Loc ));
let C3 being Integer;
redefine func <*C2 , C3 *> -> (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) ));

coherence
proof
let C4 being set;
L21: ( dom <* C2 , C3 *> ) = { 1 , 2 } by FINSEQ_1:2 , FINSEQ_1:89;
assume L22: C4 in ( rng <* C2 , C3 *> );
consider C5 being set such that L23: C5 in ( dom <* C2 , C3 *> ) and L24: ( <* C2 , C3 *> . C5 ) = C4 by L22 , FUNCT_1:def 3;
per cases  by L23 , L21 , TARSKI:def 2;
suppose L25: C5 = 1;

L26: C4 = C2 by L25 , L24 , FINSEQ_1:44;
thus L27: thesis by L26 , XBOOLE_0:def 3;
end;
suppose L28: C5 = 2;

L29: C3 in ( INT ) by INT_1:def 2;
L30: C4 = C3 by L24 , L28 , FINSEQ_1:44;
thus L31: thesis by L30 , L29 , XBOOLE_0:def 3;
end;
end;
end;
definition
let C6 being (Element of ( SCMPDS-Instr ));
given C7 being (Element of ( SCM-Data-Loc )) , R4 being (Element of ( Segm 15 )) such that
L34: C6 = [ R4 , ( {} ) , <* C7 *> ];

func C6 address_1 -> (Element of ( SCM-Data-Loc )) means 
:L35: (ex B32 being (FinSequence of ( SCM-Data-Loc )) st (B32 = ( C6 `3_3 ) & it = ( B32 /. 1 )));
existence
proof
take C7;
take <* C7 *>;
thus L36: thesis by L34 , FINSEQ_4:16 , RECDEF_2:def 3;
end;
uniqueness;
end;
theorem
L38: (for R4 being (Element of ( Segm 15 )) holds (for B33 being (Element of ( SCMPDS-Instr )) holds (for B34 being (Element of ( SCM-Data-Loc )) holds (B33 = [ R4 , ( {} ) , <* B34 *> ] implies ( B33 address_1 ) = B34))))
proof
let R4 being (Element of ( Segm 15 ));
let C8 being (Element of ( SCMPDS-Instr ));
let C9 being (Element of ( SCM-Data-Loc ));
assume L39: C8 = [ R4 , ( {} ) , <* C9 *> ];
consider C10 being (FinSequence of ( SCM-Data-Loc )) such that L40: C10 = ( C8 `3_3 ) and L41: ( C8 address_1 ) = ( C10 /. 1 ) by L39 , L35;
L42: C10 = <* C9 *> by L39 , L40 , RECDEF_2:def 3;
thus L43: thesis by L42 , L41 , FINSEQ_4:16;
end;
definition
let C11 being (Element of ( SCMPDS-Instr ));
given C12 being Integer , R4 being (Element of ( Segm 15 )) such that
L44: C11 = [ R4 , ( {} ) , <* C12 *> ];

func C11 const_INT -> Integer means 
:L45: (ex B35 being (FinSequence of ( INT )) st (B35 = ( C11 `3_3 ) & it = ( B35 /. 1 )));
existence
proof
reconsider D7 = C12 as (Element of ( INT )) by INT_1:def 2;
take C12;
take <* D7 *>;
thus L46: thesis by L44 , FINSEQ_4:16 , RECDEF_2:def 3;
end;
uniqueness;
end;
theorem
L48: (for R4 being (Element of ( Segm 15 )) holds (for B36 being (Element of ( SCMPDS-Instr )) holds (for B37 being Integer holds (B36 = [ R4 , ( {} ) , <* B37 *> ] implies ( B36 const_INT ) = B37))))
proof
let R4 being (Element of ( Segm 15 ));
let C13 being (Element of ( SCMPDS-Instr ));
let C14 being Integer;
assume L49: C13 = [ R4 , ( {} ) , <* C14 *> ];
consider C15 being (FinSequence of ( INT )) such that L50: C15 = ( C13 `3_3 ) and L51: ( C13 const_INT ) = ( C15 /. 1 ) by L49 , L45;
L52: (C14 is (Element of ( INT )) & C15 = <* C14 *>) by L49 , L50 , INT_1:def 2 , RECDEF_2:def 3;
thus L53: thesis by L52 , L51 , FINSEQ_4:16;
end;
definition
let C16 being (Element of ( SCMPDS-Instr ));
given C17 being (Element of ( SCM-Data-Loc )) , C18 being Integer , R4 being (Element of ( Segm 15 )) such that
L54: C16 = [ R4 , ( {} ) , <* C17 , C18 *> ];

func C16 P21address -> (Element of ( SCM-Data-Loc )) means 
:L55: (ex B38 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B38 = ( C16 `3_3 ) & it = ( B38 /. 1 )));
existence
proof
take C17;
take <* C17 , C18 *>;
L56: C18 in ( INT ) by INT_1:def 2;
L57: (C17 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) & C18 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) ))) by L56 , XBOOLE_0:def 3;
thus L58: thesis by L57 , L54 , FINSEQ_4:17 , RECDEF_2:def 3;
end;
uniqueness;
func C16 P22const -> Integer means 
:L59: (ex B39 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B39 = ( C16 `3_3 ) & it = ( B39 /. 2 )));
existence
proof
take C18;
take <* C17 , C18 *>;
L60: C18 in ( INT ) by INT_1:def 2;
L61: (C17 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) & C18 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) ))) by L60 , XBOOLE_0:def 3;
thus L62: thesis by L61 , L54 , FINSEQ_4:17 , RECDEF_2:def 3;
end;
uniqueness;
end;
theorem
L64: (for R4 being (Element of ( Segm 15 )) holds (for B40 being (Element of ( SCMPDS-Instr )) holds (for B41 being (Element of ( SCM-Data-Loc )) holds (for B42 being Integer holds (B40 = [ R4 , ( {} ) , <* B41 , B42 *> ] implies (( B40 P21address ) = B41 & ( B40 P22const ) = B42))))))
proof
let R4 being (Element of ( Segm 15 ));
let C19 being (Element of ( SCMPDS-Instr ));
let C20 being (Element of ( SCM-Data-Loc ));
let C21 being Integer;
L65: C21 in ( INT ) by INT_1:def 2;
L66: (C20 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) & C21 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) ))) by L65 , XBOOLE_0:def 3;
assume L67: C19 = [ R4 , ( {} ) , <* C20 , C21 *> ];
consider C22 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L68: C22 = ( C19 `3_3 ) and L69: ( C19 P21address ) = ( C22 /. 1 ) by L67 , L55;
L70: C22 = <* C20 , C21 *> by L67 , L68 , RECDEF_2:def 3;
thus L71: ( C19 P21address ) = C20 by L70 , L69 , L66 , FINSEQ_4:17;
consider C23 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L72: C23 = ( C19 `3_3 ) and L73: ( C19 P22const ) = ( C23 /. 2 ) by L67 , L59;
L74: C23 = <* C20 , C21 *> by L67 , L72 , RECDEF_2:def 3;
thus L75: thesis by L74 , L66 , L73 , FINSEQ_4:17;
end;
definition
let C24 being (Element of ( SCMPDS-Instr ));
given C25 being (Element of ( SCM-Data-Loc )) , C26 , C27 being Integer , R4 being (Element of ( Segm 15 )) such that
L76: C24 = [ R4 , ( {} ) , <* C25 , C26 , C27 *> ];

func C24 P31address -> (Element of ( SCM-Data-Loc )) means 
:L77: (ex B43 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B43 = ( C24 `3_3 ) & it = ( B43 /. 1 )));
existence
proof
reconsider D8 = C25 , D9 = C26 , D10 = C27 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C25;
take D11 = <* D8 , D9 , D10 *>;
thus L78: D11 = ( C24 `3_3 ) by L76 , RECDEF_2:def 3;
thus L79: thesis by FINSEQ_4:18;
end;
uniqueness;
func C24 P32const -> Integer means 
:L80: (ex B44 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B44 = ( C24 `3_3 ) & it = ( B44 /. 2 )));
existence
proof
reconsider D12 = C25 , D13 = C26 , D14 = C27 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C26;
take D15 = <* D12 , D13 , D14 *>;
thus L81: D15 = ( C24 `3_3 ) by L76 , RECDEF_2:def 3;
thus L82: thesis by FINSEQ_4:18;
end;
uniqueness;
func C24 P33const -> Integer means 
:L83: (ex B45 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B45 = ( C24 `3_3 ) & it = ( B45 /. 3 )));
existence
proof
reconsider D16 = C25 , D17 = C26 , D18 = C27 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C27;
take D19 = <* D16 , D17 , D18 *>;
thus L84: D19 = ( C24 `3_3 ) by L76 , RECDEF_2:def 3;
thus L85: thesis by FINSEQ_4:18;
end;
uniqueness;
end;
theorem
L87: (for R4 being (Element of ( Segm 15 )) holds (for B46 being (Element of ( SCMPDS-Instr )) holds (for B47 being (Element of ( SCM-Data-Loc )) holds (for B48 , B49 being Integer holds (B46 = [ R4 , ( {} ) , <* B47 , B48 , B49 *> ] implies (( B46 P31address ) = B47 & ( B46 P32const ) = B48 & ( B46 P33const ) = B49))))))
proof
let R4 being (Element of ( Segm 15 ));
let C28 being (Element of ( SCMPDS-Instr ));
let C29 being (Element of ( SCM-Data-Loc ));
let C30 , C31 being Integer;
L88: C30 in ( INT ) by INT_1:def 2;
L89: (C29 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) & C30 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) ))) by L88 , XBOOLE_0:def 3;
L90: C31 in ( INT ) by INT_1:def 2;
L91: C31 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L90 , XBOOLE_0:def 3;
assume L92: C28 = [ R4 , ( {} ) , <* C29 , C30 , C31 *> ];
consider C32 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L93: C32 = ( C28 `3_3 ) and L94: ( C28 P31address ) = ( C32 /. 1 ) by L92 , L77;
L95: C32 = <* C29 , C30 , C31 *> by L92 , L93 , RECDEF_2:def 3;
thus L96: ( C28 P31address ) = C29 by L95 , L89 , L91 , L94 , FINSEQ_4:18;
consider C33 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L97: C33 = ( C28 `3_3 ) and L98: ( C28 P32const ) = ( C33 /. 2 ) by L92 , L80;
L99: C33 = <* C29 , C30 , C31 *> by L92 , L97 , RECDEF_2:def 3;
thus L100: ( C28 P32const ) = C30 by L99 , L89 , L91 , L98 , FINSEQ_4:18;
consider C34 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L101: C34 = ( C28 `3_3 ) and L102: ( C28 P33const ) = ( C34 /. 3 ) by L92 , L83;
L103: C34 = <* C29 , C30 , C31 *> by L92 , L101 , RECDEF_2:def 3;
thus L104: thesis by L103 , L89 , L91 , L102 , FINSEQ_4:18;
end;
definition
let C35 being (Element of ( SCMPDS-Instr ));
given C36 , C37 being (Element of ( SCM-Data-Loc )) , C38 , C39 being Integer , R4 being (Element of ( Segm 15 )) such that
L105: C35 = [ R4 , ( {} ) , <* C36 , C37 , C38 , C39 *> ];

func C35 P41address -> (Element of ( SCM-Data-Loc )) means 
:L106: (ex B50 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B50 = ( C35 `3_3 ) & it = ( B50 /. 1 )));
existence
proof
reconsider D20 = C36 , D21 = C37 , D22 = C38 , D23 = C39 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C36;
take D24 = <* D20 , D21 , D22 , D23 *>;
thus L107: D24 = ( C35 `3_3 ) by L105 , RECDEF_2:def 3;
thus L108: thesis by FINSEQ_4:80;
end;
uniqueness;
func C35 P42address -> (Element of ( SCM-Data-Loc )) means 
:L109: (ex B51 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B51 = ( C35 `3_3 ) & it = ( B51 /. 2 )));
existence
proof
reconsider D25 = C36 , D26 = C37 , D27 = C38 , D28 = C39 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C37;
take D29 = <* D25 , D26 , D27 , D28 *>;
thus L110: D29 = ( C35 `3_3 ) by L105 , RECDEF_2:def 3;
thus L111: thesis by FINSEQ_4:80;
end;
uniqueness;
func C35 P43const -> Integer means 
:L112: (ex B52 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B52 = ( C35 `3_3 ) & it = ( B52 /. 3 )));
existence
proof
reconsider D30 = C36 , D31 = C37 , D32 = C38 , D33 = C39 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C38;
take D34 = <* D30 , D31 , D32 , D33 *>;
thus L113: D34 = ( C35 `3_3 ) by L105 , RECDEF_2:def 3;
thus L114: thesis by FINSEQ_4:80;
end;
uniqueness;
func C35 P44const -> Integer means 
:L115: (ex B53 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) st (B53 = ( C35 `3_3 ) & it = ( B53 /. 4 )));
existence
proof
reconsider D35 = C36 , D36 = C37 , D37 = C38 , D38 = C39 as (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L1 , XBOOLE_0:def 3;
take C39;
take D39 = <* D35 , D36 , D37 , D38 *>;
thus L116: D39 = ( C35 `3_3 ) by L105 , RECDEF_2:def 3;
thus L117: thesis by FINSEQ_4:80;
end;
uniqueness;
end;
theorem
L119: (for R4 being (Element of ( Segm 15 )) holds (for B54 being (Element of ( SCMPDS-Instr )) holds (for B55 , B56 being (Element of ( SCM-Data-Loc )) holds (for B57 , B58 being Integer holds (B54 = [ R4 , ( {} ) , <* B55 , B56 , B57 , B58 *> ] implies (( B54 P41address ) = B55 & ( B54 P42address ) = B56 & ( B54 P43const ) = B57 & ( B54 P44const ) = B58))))))
proof
let R4 being (Element of ( Segm 15 ));
let C40 being (Element of ( SCMPDS-Instr ));
let C41 , C42 being (Element of ( SCM-Data-Loc ));
let C43 , C44 being Integer;
L120: (C41 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) & C42 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) ))) by XBOOLE_0:def 3;
L121: C43 in ( INT ) by INT_1:def 2;
L122: C43 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L121 , XBOOLE_0:def 3;
L123: C44 in ( INT ) by INT_1:def 2;
L124: C44 is (Element of ( ( SCM-Data-Loc ) \/ ( INT ) )) by L123 , XBOOLE_0:def 3;
assume L125: C40 = [ R4 , ( {} ) , <* C41 , C42 , C43 , C44 *> ];
consider C45 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L126: C45 = ( C40 `3_3 ) and L127: ( C40 P41address ) = ( C45 /. 1 ) by L125 , L106;
L128: C45 = <* C41 , C42 , C43 , C44 *> by L125 , L126 , RECDEF_2:def 3;
thus L129: ( C40 P41address ) = C41 by L128 , L120 , L122 , L124 , L127 , FINSEQ_4:80;
consider C46 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L130: C46 = ( C40 `3_3 ) and L131: ( C40 P42address ) = ( C46 /. 2 ) by L125 , L109;
L132: C46 = <* C41 , C42 , C43 , C44 *> by L125 , L130 , RECDEF_2:def 3;
thus L133: ( C40 P42address ) = C42 by L132 , L120 , L122 , L124 , L131 , FINSEQ_4:80;
consider C47 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L134: C47 = ( C40 `3_3 ) and L135: ( C40 P43const ) = ( C47 /. 3 ) by L125 , L112;
L136: C47 = <* C41 , C42 , C43 , C44 *> by L125 , L134 , RECDEF_2:def 3;
thus L137: ( C40 P43const ) = C43 by L136 , L120 , L122 , L124 , L135 , FINSEQ_4:80;
consider C48 being (FinSequence of ( ( SCM-Data-Loc ) \/ ( INT ) )) such that L138: C48 = ( C40 `3_3 ) and L139: ( C40 P44const ) = ( C48 /. 4 ) by L125 , L115;
L140: C48 = <* C41 , C42 , C43 , C44 *> by L125 , L138 , RECDEF_2:def 3;
thus L141: thesis by L140 , L120 , L122 , L124 , L139 , FINSEQ_4:80;
end;
definition
func RetSP -> (Element of ( NAT )) equals 
( 0 );
coherence;
func RetIC -> (Element of ( NAT )) equals 
1;
coherence;
end;
theorem
L143: (for B59 being (Element of ( SCMPDS-Instr )) holds ((B59 in { [ ( 0 ) , ( {} ) , ( {} ) ] } & ( InsCode B59 ) = ( 0 )) or (B59 in { [ 14 , ( {} ) , <* B60 *> ] where B60 is (Element of ( INT )) : (not contradiction) } & ( InsCode B59 ) = 14) or (B59 in { [ 1 , ( {} ) , <* B61 *> ] where B61 is (Element of ( SCM-Data-Loc )) : (not contradiction) } & ( InsCode B59 ) = 1) or (B59 in { [ B62 , ( {} ) , <* B63 , B64 *> ] where B62 is (Element of ( Segm 15 )) , B63 is (Element of ( SCM-Data-Loc )) , B64 is (Element of ( INT )) : B62 in { 2 , 3 } } & (( InsCode B59 ) = 2 or ( InsCode B59 ) = 3)) or (B59 in { [ B65 , ( {} ) , <* B66 , B67 , B68 *> ] where B65 is (Element of ( Segm 15 )) , B66 is (Element of ( SCM-Data-Loc )) , B67 , B68 is (Element of ( INT )) : B65 in { 4 , 5 , 6 , 7 , 8 } } & (( InsCode B59 ) = 4 or ( InsCode B59 ) = 5 or ( InsCode B59 ) = 6 or ( InsCode B59 ) = 7 or ( InsCode B59 ) = 8)) or (B59 in { [ B69 , ( {} ) , <* B70 , B71 , B72 , B73 *> ] where B69 is (Element of ( Segm 15 )) , B70 , B71 is (Element of ( SCM-Data-Loc )) , B72 , B73 is (Element of ( INT )) : B69 in { 9 , 10 , 11 , 12 , 13 } } & (( InsCode B59 ) = 9 or ( InsCode B59 ) = 10 or ( InsCode B59 ) = 11 or ( InsCode B59 ) = 12 or ( InsCode B59 ) = 13))))
proof
let C49 being (Element of ( SCMPDS-Instr ));
L144: (C49 in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B74 *> ] where B74 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B75 *> ] where B75 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B76 , ( {} ) , <* B77 , B78 *> ] where B76 is (Element of ( Segm 15 )) , B77 is (Element of ( SCM-Data-Loc )) , B78 is (Element of ( INT )) : B76 in { 2 , 3 } } ) \/ { [ B79 , ( {} ) , <* B80 , B81 , B82 *> ] where B79 is (Element of ( Segm 15 )) , B80 is (Element of ( SCM-Data-Loc )) , B81 , B82 is (Element of ( INT )) : B79 in { 4 , 5 , 6 , 7 , 8 } } ) or C49 in { [ B83 , ( {} ) , <* B84 , B85 , B86 , B87 *> ] where B83 is (Element of ( Segm 15 )) , B84 , B85 is (Element of ( SCM-Data-Loc )) , B86 , B87 is (Element of ( INT )) : B83 in { 9 , 10 , 11 , 12 , 13 } }) by XBOOLE_0:def 3;
L145: (C49 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B88 *> ] where B88 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B89 *> ] where B89 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B90 , ( {} ) , <* B91 , B92 *> ] where B90 is (Element of ( Segm 15 )) , B91 is (Element of ( SCM-Data-Loc )) , B92 is (Element of ( INT )) : B90 in { 2 , 3 } } ) or C49 in { [ B93 , ( {} ) , <* B94 , B95 , B96 *> ] where B93 is (Element of ( Segm 15 )) , B94 is (Element of ( SCM-Data-Loc )) , B95 , B96 is (Element of ( INT )) : B93 in { 4 , 5 , 6 , 7 , 8 } } or C49 in { [ B97 , ( {} ) , <* B98 , B99 , B100 , B101 *> ] where B97 is (Element of ( Segm 15 )) , B98 , B99 is (Element of ( SCM-Data-Loc )) , B100 , B101 is (Element of ( INT )) : B97 in { 9 , 10 , 11 , 12 , 13 } }) by L144 , XBOOLE_0:def 3;
L146: (C49 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B102 *> ] where B102 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B103 *> ] where B103 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) or C49 in { [ B104 , ( {} ) , <* B105 , B106 *> ] where B104 is (Element of ( Segm 15 )) , B105 is (Element of ( SCM-Data-Loc )) , B106 is (Element of ( INT )) : B104 in { 2 , 3 } } or C49 in { [ B107 , ( {} ) , <* B108 , B109 , B110 *> ] where B107 is (Element of ( Segm 15 )) , B108 is (Element of ( SCM-Data-Loc )) , B109 , B110 is (Element of ( INT )) : B107 in { 4 , 5 , 6 , 7 , 8 } } or C49 in { [ B111 , ( {} ) , <* B112 , B113 , B114 , B115 *> ] where B111 is (Element of ( Segm 15 )) , B112 , B113 is (Element of ( SCM-Data-Loc )) , B114 , B115 is (Element of ( INT )) : B111 in { 9 , 10 , 11 , 12 , 13 } }) by L145 , XBOOLE_0:def 3;
L147: (C49 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B116 *> ] where B116 is (Element of ( INT )) : (not contradiction) } ) or C49 in { [ 1 , ( {} ) , <* B117 *> ] where B117 is (Element of ( SCM-Data-Loc )) : (not contradiction) } or C49 in { [ B118 , ( {} ) , <* B119 , B120 *> ] where B118 is (Element of ( Segm 15 )) , B119 is (Element of ( SCM-Data-Loc )) , B120 is (Element of ( INT )) : B118 in { 2 , 3 } } or C49 in { [ B121 , ( {} ) , <* B122 , B123 , B124 *> ] where B121 is (Element of ( Segm 15 )) , B122 is (Element of ( SCM-Data-Loc )) , B123 , B124 is (Element of ( INT )) : B121 in { 4 , 5 , 6 , 7 , 8 } } or C49 in { [ B125 , ( {} ) , <* B126 , B127 , B128 , B129 *> ] where B125 is (Element of ( Segm 15 )) , B126 , B127 is (Element of ( SCM-Data-Loc )) , B128 , B129 is (Element of ( INT )) : B125 in { 9 , 10 , 11 , 12 , 13 } }) by L146 , XBOOLE_0:def 3;
per cases  by L147 , XBOOLE_0:def 3;
case L148: C49 in { [ ( 0 ) , ( {} ) , ( {} ) ] };
L149: C49 = [ ( 0 ) , ( {} ) , ( {} ) ] by L148 , TARSKI:def 1;
thus L150: thesis by L149 , RECDEF_2:def 1;
end;
case L151: C49 in { [ 14 , ( {} ) , <* B130 *> ] where B130 is (Element of ( INT )) : (not contradiction) };
L152: (ex B131 being (Element of ( INT )) st C49 = [ 14 , ( {} ) , <* B131 *> ]) by L151;
thus L153: thesis by L152 , RECDEF_2:def 1;
end;
case L154: C49 in { [ 1 , ( {} ) , <* B132 *> ] where B132 is (Element of ( SCM-Data-Loc )) : (not contradiction) };
L155: (ex B133 being (Element of ( SCM-Data-Loc )) st C49 = [ 1 , ( {} ) , <* B133 *> ]) by L154;
thus L156: thesis by L155 , RECDEF_2:def 1;
end;
case L157: C49 in { [ B134 , ( {} ) , <* B135 , B136 *> ] where B134 is (Element of ( Segm 15 )) , B135 is (Element of ( SCM-Data-Loc )) , B136 is (Element of ( INT )) : B134 in { 2 , 3 } };
consider C50 being (Element of ( Segm 15 )), C51 being (Element of ( SCM-Data-Loc )), C52 being (Element of ( INT )) such that L158: C49 = [ C50 , ( {} ) , <* C51 , C52 *> ] and L159: C50 in { 2 , 3 } by L157;
L160: ( InsCode C49 ) = C50 by L158 , RECDEF_2:def 1;
thus L161: thesis by L160 , L159 , TARSKI:def 2;
end;
case L162: C49 in { [ B137 , ( {} ) , <* B138 , B139 , B140 *> ] where B137 is (Element of ( Segm 15 )) , B138 is (Element of ( SCM-Data-Loc )) , B139 , B140 is (Element of ( INT )) : B137 in { 4 , 5 , 6 , 7 , 8 } };
consider C53 being (Element of ( Segm 15 )), C54 being (Element of ( SCM-Data-Loc )), C55 , C56 being (Element of ( INT )) such that L163: C49 = [ C53 , ( {} ) , <* C54 , C55 , C56 *> ] and L164: C53 in { 4 , 5 , 6 , 7 , 8 } by L162;
L165: ( InsCode C49 ) = C53 by L163 , RECDEF_2:def 1;
thus L166: thesis by L165 , L164 , ENUMSET1:def 3;
end;
case L167: C49 in { [ B141 , ( {} ) , <* B142 , B143 , B144 , B145 *> ] where B141 is (Element of ( Segm 15 )) , B142 , B143 is (Element of ( SCM-Data-Loc )) , B144 , B145 is (Element of ( INT )) : B141 in { 9 , 10 , 11 , 12 , 13 } };
consider C57 being (Element of ( Segm 15 )), C58 , C59 being (Element of ( SCM-Data-Loc )), C60 , C61 being (Element of ( INT )) such that L168: C49 = [ C57 , ( {} ) , <* C58 , C59 , C60 , C61 *> ] and L169: C57 in { 9 , 10 , 11 , 12 , 13 } by L167;
L170: ( InsCode C49 ) = C57 by L168 , RECDEF_2:def 1;
thus L171: thesis by L170 , L169 , ENUMSET1:def 3;
end;
end;
begin
registration
cluster ( proj2 ( SCMPDS-Instr ) ) ->  FinSequence-membered;
coherence
proof
let C62 being set;
assume L173: C62 in ( proj2 ( SCMPDS-Instr ) );
consider C63 being set such that L174: [ C63 , C62 ] in ( SCMPDS-Instr ) by L173 , XTUPLE_0:def 13;
set D40 = [ C63 , C62 ];
per cases  by L174 , XBOOLE_0:def 3;
suppose L175: D40 in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B146 *> ] where B146 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B147 *> ] where B147 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B148 , ( {} ) , <* B149 , B150 *> ] where B148 is (Element of ( Segm 15 )) , B149 is (Element of ( SCM-Data-Loc )) , B150 is (Element of ( INT )) : B148 in { 2 , 3 } } ) \/ { [ B151 , ( {} ) , <* B152 , B153 , B154 *> ] where B151 is (Element of ( Segm 15 )) , B152 is (Element of ( SCM-Data-Loc )) , B153 , B154 is (Element of ( INT )) : B151 in { 4 , 5 , 6 , 7 , 8 } } );

per cases  by L175 , XBOOLE_0:def 3;
suppose L176: D40 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B155 *> ] where B155 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B156 *> ] where B156 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B157 , ( {} ) , <* B158 , B159 *> ] where B157 is (Element of ( Segm 15 )) , B158 is (Element of ( SCM-Data-Loc )) , B159 is (Element of ( INT )) : B157 in { 2 , 3 } } );

L177: D40 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ ( { [ 14 , ( {} ) , <* B160 *> ] where B160 is (Element of ( INT )) : (not contradiction) } \/ { [ 1 , ( {} ) , <* B161 *> ] where B161 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) ) \/ { [ B162 , ( {} ) , <* B163 , B164 *> ] where B162 is (Element of ( Segm 15 )) , B163 is (Element of ( SCM-Data-Loc )) , B164 is (Element of ( INT )) : B162 in { 2 , 3 } } ) by L176 , XBOOLE_1:4;
L178: (D40 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ ( { [ 14 , ( {} ) , <* B165 *> ] where B165 is (Element of ( INT )) : (not contradiction) } \/ { [ 1 , ( {} ) , <* B166 *> ] where B166 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) ) or D40 in { [ B167 , ( {} ) , <* B168 , B169 *> ] where B167 is (Element of ( Segm 15 )) , B168 is (Element of ( SCM-Data-Loc )) , B169 is (Element of ( INT )) : B167 in { 2 , 3 } }) by L177 , XBOOLE_0:def 3;
per cases  by L178 , XBOOLE_0:def 3;
suppose L179: D40 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

L180: D40 = [ ( 0 ) , ( {} ) , ( {} ) ] by L179 , TARSKI:def 1;
thus L181: C62 is FinSequence by L180 , XTUPLE_0:1;
end;
suppose L182: D40 in ( { [ 14 , ( {} ) , <* B170 *> ] where B170 is (Element of ( INT )) : (not contradiction) } \/ { [ 1 , ( {} ) , <* B171 *> ] where B171 is (Element of ( SCM-Data-Loc )) : (not contradiction) } );

per cases  by L182 , XBOOLE_0:def 3;
suppose L183: D40 in { [ 14 , ( {} ) , <* B172 *> ] where B172 is (Element of ( INT )) : (not contradiction) };

L184: (ex B173 being (Element of ( INT )) st D40 = [ 14 , ( {} ) , <* B173 *> ]) by L183;
thus L185: C62 is FinSequence by L184 , XTUPLE_0:1;
end;
suppose L186: D40 in { [ 1 , ( {} ) , <* B174 *> ] where B174 is (Element of ( SCM-Data-Loc )) : (not contradiction) };

L187: (ex B175 being (Element of ( SCM-Data-Loc )) st D40 = [ 1 , ( {} ) , <* B175 *> ]) by L186;
thus L188: C62 is FinSequence by L187 , XTUPLE_0:1;
end;
end;
suppose L190: D40 in { [ B176 , ( {} ) , <* B177 , B178 *> ] where B176 is (Element of ( Segm 15 )) , B177 is (Element of ( SCM-Data-Loc )) , B178 is (Element of ( INT )) : B176 in { 2 , 3 } };

L191: (ex B179 being (Element of ( Segm 15 )) st (ex B180 being (Element of ( SCM-Data-Loc )) st (ex B181 being (Element of ( INT )) st (D40 = [ B179 , ( {} ) , <* B180 , B181 *> ] & B179 in { 2 , 3 })))) by L190;
thus L192: C62 is FinSequence by L191 , XTUPLE_0:1;
end;
end;
suppose L194: D40 in { [ B182 , ( {} ) , <* B183 , B184 , B185 *> ] where B182 is (Element of ( Segm 15 )) , B183 is (Element of ( SCM-Data-Loc )) , B184 , B185 is (Element of ( INT )) : B182 in { 4 , 5 , 6 , 7 , 8 } };

L195: (ex B186 being (Element of ( Segm 15 )) st (ex B187 being (Element of ( SCM-Data-Loc )) st (ex B188 , B189 being (Element of ( INT )) st (D40 = [ B186 , ( {} ) , <* B187 , B188 , B189 *> ] & B186 in { 4 , 5 , 6 , 7 , 8 })))) by L194;
thus L196: C62 is FinSequence by L195 , XTUPLE_0:1;
end;
end;
suppose L198: D40 in { [ B190 , ( {} ) , <* B191 , B192 , B193 , B194 *> ] where B190 is (Element of ( Segm 15 )) , B191 , B192 is (Element of ( SCM-Data-Loc )) , B193 , B194 is (Element of ( INT )) : B190 in { 9 , 10 , 11 , 12 , 13 } };

L199: (ex B195 being (Element of ( Segm 15 )) st (ex B196 , B197 being (Element of ( SCM-Data-Loc )) st (ex B198 , B199 being (Element of ( INT )) st (D40 = [ B195 , ( {} ) , <* B196 , B197 , B198 , B199 *> ] & B195 in { 9 , 10 , 11 , 12 , 13 })))) by L198;
thus L200: C62 is FinSequence by L199 , XTUPLE_0:1;
end;
end;
end;
registration
cluster ( SCMPDS-Instr ) ->  standard-ins;
coherence
proof
consider C64 being non  empty set such that L203: ( proj2 ( SCMPDS-Instr ) ) c= ( C64 * ) by FINSEQ_1:85;
take C64;
let R16 being set;
assume L204: R16 in ( SCMPDS-Instr );
L205: ( {} ) in ( ( NAT ) * ) by FINSEQ_1:49;
per cases  by L204 , XBOOLE_0:def 3;
suppose L206: R16 in ( ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B200 *> ] where B200 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B201 *> ] where B201 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B202 , ( {} ) , <* B203 , B204 *> ] where B202 is (Element of ( Segm 15 )) , B203 is (Element of ( SCM-Data-Loc )) , B204 is (Element of ( INT )) : B202 in { 2 , 3 } } ) \/ { [ B205 , ( {} ) , <* B206 , B207 , B208 *> ] where B205 is (Element of ( Segm 15 )) , B206 is (Element of ( SCM-Data-Loc )) , B207 , B208 is (Element of ( INT )) : B205 in { 4 , 5 , 6 , 7 , 8 } } );

per cases  by L206 , XBOOLE_0:def 3;
suppose L207: R16 in ( ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B209 *> ] where B209 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B210 *> ] where B210 is (Element of ( SCM-Data-Loc )) : (not contradiction) } ) \/ { [ B211 , ( {} ) , <* B212 , B213 *> ] where B211 is (Element of ( Segm 15 )) , B212 is (Element of ( SCM-Data-Loc )) , B213 is (Element of ( INT )) : B211 in { 2 , 3 } } );

per cases  by L207 , XBOOLE_0:def 3;
suppose L208: R16 in ( ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B214 *> ] where B214 is (Element of ( INT )) : (not contradiction) } ) \/ { [ 1 , ( {} ) , <* B215 *> ] where B215 is (Element of ( SCM-Data-Loc )) : (not contradiction) } );

per cases  by L208 , XBOOLE_0:def 3;
suppose L209: R16 in ( { [ ( 0 ) , ( {} ) , ( {} ) ] } \/ { [ 14 , ( {} ) , <* B216 *> ] where B216 is (Element of ( INT )) : (not contradiction) } );

per cases  by L209 , XBOOLE_0:def 3;
suppose L210: R16 in { [ ( 0 ) , ( {} ) , ( {} ) ] };

L211: R16 = [ ( 0 ) , ( {} ) , ( {} ) ] by L210 , TARSKI:def 1;
L212: ( {} ) in ( C64 * ) by FINSEQ_1:49;
thus L213: R16 in [: ( NAT ) , ( ( NAT ) * ) , ( C64 * ) :] by L212 , L211 , L205 , MCART_1:69;
end;
suppose L214: R16 in { [ 14 , ( {} ) , <* B217 *> ] where B217 is (Element of ( INT )) : (not contradiction) };

consider C65 being (Element of ( INT )) such that L215: R16 = [ 14 , ( {} ) , <* C65 *> ] by L214;
L216: <* C65 *> in ( proj2 ( SCMPDS-Instr ) ) by L204 , L215 , XTUPLE_0:def 13;
thus L217: R16 in [: ( NAT ) , ( ( NAT ) * ) , ( C64 * ) :] by L216 , L203 , L215 , L205 , MCART_1:69;
end;
end;
suppose L219: R16 in { [ 1 , ( {} ) , <* B218 *> ] where B218 is (Element of ( SCM-Data-Loc )) : (not contradiction) };

consider C66 being (Element of ( SCM-Data-Loc )) such that L220: R16 = [ 1 , ( {} ) , <* C66 *> ] by L219;
L221: <* C66 *> in ( proj2 ( SCMPDS-Instr ) ) by L204 , L220 , XTUPLE_0:def 13;
thus L222: R16 in [: ( NAT ) , ( ( NAT ) * ) , ( C64 * ) :] by L221 , L203 , L220 , L205 , MCART_1:69;
end;
end;
suppose L224: R16 in { [ B219 , ( {} ) , <* B220 , B221 *> ] where B219 is (Element of ( Segm 15 )) , B220 is (Element of ( SCM-Data-Loc )) , B221 is (Element of ( INT )) : B219 in { 2 , 3 } };

consider C67 being (Element of ( Segm 15 )), C68 being (Element of ( SCM-Data-Loc )), C69 being (Element of ( INT )) such that L225: (R16 = [ C67 , ( {} ) , <* C68 , C69 *> ] & C67 in { 2 , 3 }) by L224;
L226: <* C68 , C69 *> in ( proj2 ( SCMPDS-Instr ) ) by L204 , L225 , XTUPLE_0:def 13;
thus L227: R16 in [: ( NAT ) , ( ( NAT ) * ) , ( C64 * ) :] by L226 , L203 , L225 , L205 , MCART_1:69;
end;
end;
suppose L229: R16 in { [ B222 , ( {} ) , <* B223 , B224 , B225 *> ] where B222 is (Element of ( Segm 15 )) , B223 is (Element of ( SCM-Data-Loc )) , B224 , B225 is (Element of ( INT )) : B222 in { 4 , 5 , 6 , 7 , 8 } };

consider C70 being (Element of ( Segm 15 )), C71 being (Element of ( SCM-Data-Loc )), C72 , C73 being (Element of ( INT )) such that L230: (R16 = [ C70 , ( {} ) , <* C71 , C72 , C73 *> ] & C70 in { 4 , 5 , 6 , 7 , 8 }) by L229;
L231: <* C71 , C72 , C73 *> in ( proj2 ( SCMPDS-Instr ) ) by L204 , L230 , XTUPLE_0:def 13;
thus L232: R16 in [: ( NAT ) , ( ( NAT ) * ) , ( C64 * ) :] by L231 , L203 , L230 , L205 , MCART_1:69;
end;
end;
suppose L234: R16 in { [ B226 , ( {} ) , <* B227 , B228 , B229 , B230 *> ] where B226 is (Element of ( Segm 15 )) , B227 , B228 is (Element of ( SCM-Data-Loc )) , B229 , B230 is (Element of ( INT )) : B226 in { 9 , 10 , 11 , 12 , 13 } };

consider C74 being (Element of ( Segm 15 )), C75 , C76 being (Element of ( SCM-Data-Loc )), C77 , C78 being (Element of ( INT )) such that L235: (R16 = [ C74 , ( {} ) , <* C75 , C76 , C77 , C78 *> ] & C74 in { 9 , 10 , 11 , 12 , 13 }) by L234;
L236: <* C75 , C76 , C77 , C78 *> in ( proj2 ( SCMPDS-Instr ) ) by L204 , L235 , XTUPLE_0:def 13;
thus L237: R16 in [: ( NAT ) , ( ( NAT ) * ) , ( C64 * ) :] by L236 , L203 , L235 , L205 , MCART_1:69;
end;
end;
end;
L240: (for B231 being (Element of ( SCMPDS-Instr )) holds ( InsCode B231 ) <= 14)
proof
let C79 being (Element of ( SCMPDS-Instr ));
L241: (( InsCode C79 ) = ( 0 ) or ( InsCode C79 ) = 1 or ( InsCode C79 ) = 2 or ( InsCode C79 ) = 3 or ( InsCode C79 ) = 4 or ( InsCode C79 ) = 5 or ( InsCode C79 ) = 6 or ( InsCode C79 ) = 7 or ( InsCode C79 ) = 8 or ( InsCode C79 ) = 9 or ( InsCode C79 ) = 10 or ( InsCode C79 ) = 11 or ( InsCode C79 ) = 12 or ( InsCode C79 ) = 13 or ( InsCode C79 ) = 14) by L143;
thus L242: thesis by L241;
end;
L243: (for B232 being (Element of ( SCMPDS-Instr )) holds (( InsCode B232 ) = ( 0 ) implies ( JumpPart B232 ) = ( {} )))
proof
let C80 being (Element of ( SCMPDS-Instr ));
assume L244: ( InsCode C80 ) = ( 0 );
L245: C80 in { [ ( 0 ) , ( {} ) , ( {} ) ] } by L244 , L143;
L246: C80 = [ ( 0 ) , ( {} ) , ( {} ) ] by L245 , TARSKI:def 1;
thus L247: thesis by L246 , RECDEF_2:def 2;
end;
L248: (for B233 being (Element of ( SCMPDS-Instr )) holds (( InsCode B233 ) = 14 implies ( JumpPart B233 ) = ( {} )))
proof
let C81 being (Element of ( SCMPDS-Instr ));
assume L249: ( InsCode C81 ) = 14;
L250: C81 in { [ 14 , ( {} ) , <* B234 *> ] where B234 is (Element of ( INT )) : (not contradiction) } by L249 , L143;
L251: (ex B235 being (Element of ( INT )) st C81 = [ 14 , ( {} ) , <* B235 *> ]) by L250;
thus L252: thesis by L251 , RECDEF_2:def 2;
end;
L253: (for B236 being (Element of ( SCMPDS-Instr )) holds (( InsCode B236 ) = 1 implies ( JumpPart B236 ) = ( {} )))
proof
let C82 being (Element of ( SCMPDS-Instr ));
assume L254: ( InsCode C82 ) = 1;
L255: C82 in { [ 1 , ( {} ) , <* B237 *> ] where B237 is (Element of ( SCM-Data-Loc )) : (not contradiction) } by L254 , L143;
L256: (ex B238 being (Element of ( SCM-Data-Loc )) st C82 = [ 1 , ( {} ) , <* B238 *> ]) by L255;
thus L257: thesis by L256 , RECDEF_2:def 2;
end;
L258: (for B239 being (Element of ( SCMPDS-Instr )) holds ((( InsCode B239 ) = 2 or ( InsCode B239 ) = 3) implies ( JumpPart B239 ) = ( {} )))
proof
let C83 being (Element of ( SCMPDS-Instr ));
assume L259: (( InsCode C83 ) = 2 or ( InsCode C83 ) = 3);
L260: C83 in { [ B240 , ( {} ) , <* B241 , B242 *> ] where B240 is (Element of ( Segm 15 )) , B241 is (Element of ( SCM-Data-Loc )) , B242 is (Element of ( INT )) : B240 in { 2 , 3 } } by L259 , L143;
L261: (ex B243 being (Element of ( Segm 15 )) st (ex B244 being (Element of ( SCM-Data-Loc )) st (ex B245 being (Element of ( INT )) st (C83 = [ B243 , ( {} ) , <* B244 , B245 *> ] & B243 in { 2 , 3 })))) by L260;
thus L262: thesis by L261 , RECDEF_2:def 2;
end;
L263: (for B246 being (Element of ( SCMPDS-Instr )) holds ((( InsCode B246 ) = 4 or ( InsCode B246 ) = 5 or ( InsCode B246 ) = 6 or ( InsCode B246 ) = 7 or ( InsCode B246 ) = 8) implies ( JumpPart B246 ) = ( {} )))
proof
let C84 being (Element of ( SCMPDS-Instr ));
assume L264: (( InsCode C84 ) = 4 or ( InsCode C84 ) = 5 or ( InsCode C84 ) = 6 or ( InsCode C84 ) = 7 or ( InsCode C84 ) = 8);
L265: C84 in { [ B247 , ( {} ) , <* B248 , B249 , B250 *> ] where B247 is (Element of ( Segm 15 )) , B248 is (Element of ( SCM-Data-Loc )) , B249 , B250 is (Element of ( INT )) : B247 in { 4 , 5 , 6 , 7 , 8 } } by L264 , L143;
L266: (ex B251 being (Element of ( Segm 15 )) st (ex B252 being (Element of ( SCM-Data-Loc )) st (ex B253 , B254 being (Element of ( INT )) st (C84 = [ B251 , ( {} ) , <* B252 , B253 , B254 *> ] & B251 in { 4 , 5 , 6 , 7 , 8 })))) by L265;
thus L267: thesis by L266 , RECDEF_2:def 2;
end;
L268: (for B255 being (Element of ( SCMPDS-Instr )) holds ((( InsCode B255 ) = 9 or ( InsCode B255 ) = 10 or ( InsCode B255 ) = 11 or ( InsCode B255 ) = 12 or ( InsCode B255 ) = 13) implies ( JumpPart B255 ) = ( {} )))
proof
let C85 being (Element of ( SCMPDS-Instr ));
assume L269: (( InsCode C85 ) = 9 or ( InsCode C85 ) = 10 or ( InsCode C85 ) = 11 or ( InsCode C85 ) = 12 or ( InsCode C85 ) = 13);
L270: C85 in { [ B256 , ( {} ) , <* B257 , B258 , B259 , B260 *> ] where B256 is (Element of ( Segm 15 )) , B257 , B258 is (Element of ( SCM-Data-Loc )) , B259 , B260 is (Element of ( INT )) : B256 in { 9 , 10 , 11 , 12 , 13 } } by L269 , L143;
L271: (ex B261 being (Element of ( Segm 15 )) st (ex B262 , B263 being (Element of ( SCM-Data-Loc )) st (ex B264 , B265 being (Element of ( INT )) st (C85 = [ B261 , ( {} ) , <* B262 , B263 , B264 , B265 *> ] & B261 in { 9 , 10 , 11 , 12 , 13 })))) by L270;
thus L272: thesis by L271 , RECDEF_2:def 2;
end;
registration
cluster ( SCMPDS-Instr ) ->  homogeneous;
coherence
proof
let C86 , C87 being (Element of ( SCMPDS-Instr ));
assume L273: ( InsCode C86 ) = ( InsCode C87 );
per cases  by L240 , NAT_1:60;
suppose L274: ( InsCode C86 ) = ( 0 );

L275: (( JumpPart C86 ) = ( {} ) & ( JumpPart C87 ) = ( {} )) by L274 , L273 , L243;
thus L276: thesis by L275;
end;
suppose L277: ( InsCode C86 ) = 14;

L278: (( JumpPart C86 ) = ( {} ) & ( JumpPart C87 ) = ( {} )) by L277 , L273 , L248;
thus L279: thesis by L278;
end;
suppose L280: ( InsCode C86 ) = 1;

L281: (( JumpPart C86 ) = ( {} ) & ( JumpPart C87 ) = ( {} )) by L280 , L273 , L253;
thus L282: thesis by L281;
end;
suppose L283: (( InsCode C86 ) = 2 or ( InsCode C86 ) = 3);

L284: (( JumpPart C86 ) = ( {} ) & ( JumpPart C87 ) = ( {} )) by L283 , L273 , L258;
thus L285: thesis by L284;
end;
suppose L286: (( InsCode C86 ) = 4 or ( InsCode C86 ) = 5 or ( InsCode C86 ) = 6 or ( InsCode C86 ) = 7 or ( InsCode C86 ) = 8);

L287: (( JumpPart C86 ) = ( {} ) & ( JumpPart C87 ) = ( {} )) by L286 , L273 , L263;
thus L288: thesis by L287;
end;
suppose L289: (( InsCode C86 ) = 9 or ( InsCode C86 ) = 10 or ( InsCode C86 ) = 11 or ( InsCode C86 ) = 12 or ( InsCode C86 ) = 13);

L290: (( JumpPart C86 ) = ( {} ) & ( JumpPart C87 ) = ( {} )) by L289 , L273 , L268;
thus L291: thesis by L290;
end;
end;
end;
registration
cluster ( SCMPDS-Instr ) ->  J/A-independent;
coherence
proof
let C88 being (InsType of ( SCMPDS-Instr ));
let C89 , C90 being  natural-valued Function;
assume that
L294: C89 in ( JumpParts C88 )
and
L295: ( dom C89 ) = ( dom C90 );
let C91 being set;
assume that
L296: [ C88 , C89 , C91 ] in ( SCMPDS-Instr );
reconsider D41 = [ C88 , C89 , C91 ] as (Element of ( SCMPDS-Instr )) by L296;
L297: (( InsCode D41 ) = ( 0 ) or ( InsCode D41 ) = 1 or ( InsCode D41 ) = 2 or ( InsCode D41 ) = 3 or ( InsCode D41 ) = 4 or ( InsCode D41 ) = 5 or ( InsCode D41 ) = 6 or ( InsCode D41 ) = 7 or ( InsCode D41 ) = 8 or ( InsCode D41 ) = 9 or ( InsCode D41 ) = 10 or ( InsCode D41 ) = 11 or ( InsCode D41 ) = 12 or ( InsCode D41 ) = 13 or ( InsCode D41 ) = 14) by L240 , NAT_1:60;
L298: ( JumpPart D41 ) = ( {} ) by L297 , L248 , L253 , L258 , L263 , L268 , L243;
L299: C88 = ( InsCode D41 ) by RECDEF_2:def 1;
L300: ( JumpParts C88 ) = { ( 0 ) } by L299 , L298 , COMPOS_0:11;
L301: C89 = ( 0 ) by L300 , L294 , TARSKI:def 1;
L302: C89 = C90 by L301 , L295;
thus L303: [ C88 , C90 , C91 ] in ( SCMPDS-Instr ) by L302 , L296;
end;
end;
registration
cluster ( SCMPDS-Instr ) ->  with_halt;
coherence
proof
thus L305: [ ( 0 ) , ( {} ) , ( {} ) ] in ( SCMPDS-Instr ) by L5;
end;
end;
