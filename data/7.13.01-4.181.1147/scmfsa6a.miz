:: On the compositions of macro instructions
::  by Andrzej Trybulec , Yatsuka Nakamura and Noriko Asamoto
::
:: Received June 20, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, EXTPRO_1, FUNCT_4, AMI_3,
      FUNCOP_1, RELAT_1, FUNCT_1, TARSKI, XBOOLE_0, CARD_1, CAT_1, NAT_1,
      ARYTM_3, FINSET_1, XXREAL_0, AMISTD_2, VALUED_1, FSM_1, GRAPHSP,
      ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, SCMFSA6A,
      ORDINAL1, RELOC, SCMFSA6C, MEMSTR_0, SCMPDS_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      ORDINAL1, NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1,
      FINSEQ_2, FINSET_1, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0,
      MEMSTR_0, COMPOS_0, COMPOS_1,
      EXTPRO_1, FUNCT_7, SCMFSA_2, AMISTD_2, FUNCOP_1,
      XXREAL_0, SCMFSA_M;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, INT_2, AMISTD_2, SCMFSA_2,
      RELSET_1, VALUED_1, AMI_3, PRE_POLY, AMISTD_1, FUNCT_7, MEMSTR_0,
      SCMFSA_1, SCMFSA_M;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, STRUCT_0, SCMFSA_2, FUNCT_4, RELAT_1,
      VALUED_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, SCMFSA_4, MEMSTR_0,
      FINSEQ_1, AMI_3, COMPOS_0, SCMFSA_M;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCT_1, FUNCOP_1, SCMFSA_2, FUNCT_7, XBOOLE_0, TARSKI, COMPOS_1,
      EXTPRO_1, FUNCT_4, AFINSQ_1, AMISTD_2, MEMSTR_0, PARTFUN1, COMPOS_0,
      SCMFSA_M;
 theorems FUNCT_2, RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_4, SCMFSA_2, CARD_1, CARD_2, ENUMSET1, GRFUNC_1,
      RELSET_1, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, VALUED_1, AFINSQ_1,
      COMPOS_1, EXTPRO_1, COMPOS_0, SCMFSA_M;

begin
definition
let C1 being ( NAT ) -defined (the InstructionsF of ( SCM+FSA )) -valued  finite Function;
let C2 being (Element of ( NAT ));
func Directed (C1 , C2) -> (preProgram of ( SCM+FSA )) equals 
( C1 +~ (( halt ( SCM+FSA ) ) , ( goto C2 )) );
coherence;
end;
definition
let C3 being ( NAT ) -defined (the InstructionsF of ( SCM+FSA )) -valued  finite Function;
func Directed C3 -> (preProgram of ( SCM+FSA )) equals 
( Directed (C3 , ( card C3 )) );
coherence;
end;
registration
let C4 being (Program of ( SCM+FSA ));
cluster ( Directed C4 ) ->  initial non  empty;
coherence
proof
thus L3: ( Directed C4 ) is  initial
proof
let C5 , C6 being Nat;
assume that
L4: C6 in ( dom ( Directed C4 ) )
and
L5: C5 < C6;
L6: C6 in ( dom C4 ) by L4 , FUNCT_4:99;
L7: C5 in ( dom C4 ) by L6 , L5 , AFINSQ_1:def 12;
thus L8: thesis by L7 , FUNCT_4:99;
end;

thus L9: ( Directed C4 ) is non  empty;
end;
end;
theorem
L11: (for R7 being (Program of ( SCM+FSA )) holds (not ( halt ( SCM+FSA ) ) in ( rng ( Directed R7 ) ))) by FUNCT_4:100;
theorem
L12: (for R2 being (Element of ( NAT )) holds (for R7 being (Program of ( SCM+FSA )) holds ( Reloc (( Directed R7 ) , R2) ) = ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto ( R2 + ( card R7 ) ) ) ) ) * ( Reloc (R7 , R2) ) )))
proof
let R2 being (Element of ( NAT ));
let R7 being (Program of ( SCM+FSA ));
L13: ( rng ( ( halt ( SCM+FSA ) ) .--> ( goto ( card R7 ) ) ) ) = { ( goto ( card R7 ) ) } by FUNCOP_1:8;
L14: ( rng ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto ( card R7 ) ) ) ) ) c= ( ( rng ( id (the InstructionsF of ( SCM+FSA )) ) ) \/ { ( goto ( card R7 ) ) } ) by L13 , FUNCT_4:17;
L15: ( ( rng ( id (the InstructionsF of ( SCM+FSA )) ) ) \/ { ( goto ( card R7 ) ) } ) = (the InstructionsF of ( SCM+FSA )) by ZFMISC_1:40;
L16: ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto ( card R7 ) ) ) ) = { ( halt ( SCM+FSA ) ) } by FUNCOP_1:13;
L17: ( dom ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto ( card R7 ) ) ) ) ) = ( ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) \/ { ( halt ( SCM+FSA ) ) } ) by L16 , FUNCT_4:def 1
.= (the InstructionsF of ( SCM+FSA )) by ZFMISC_1:40;
reconsider D1 = ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto ( card R7 ) ) ) ) as (Function of (the InstructionsF of ( SCM+FSA )) , (the InstructionsF of ( SCM+FSA ))) by L17 , L14 , L15 , FUNCT_2:def 1 , RELSET_1:4;
L18: ( IncAddr (( goto ( card R7 ) ) , R2) ) = ( goto ( R2 + ( card R7 ) ) ) by SCMFSA_4:1;
L19: ( dom ( id (the InstructionsF of ( SCM+FSA )) ) ) = (the InstructionsF of ( SCM+FSA ));
L20: D1 = ( ( id (the InstructionsF of ( SCM+FSA )) ) +* (( halt ( SCM+FSA ) ) , ( goto ( card R7 ) )) ) by L19 , FUNCT_7:def 3;
L21: ( rng R7 ) c= (the InstructionsF of ( SCM+FSA )) by RELAT_1:def 19;
L22: ( Reloc (( Directed R7 ) , R2) ) = ( IncAddr (( Shift (( Directed R7 ) , R2) ) , R2) ) by COMPOS_1:34;
L23: ( Reloc (R7 , R2) ) = ( IncAddr (( Shift (R7 , R2) ) , R2) ) by COMPOS_1:34;
L24: ( Directed R7 ) = ( Directed R7 )
.= ( D1 * R7 ) by L20 , L21 , FUNCT_7:116;
thus L25: ( Reloc (( Directed R7 ) , R2) ) = ( IncAddr (( D1 * ( Shift (R7 , R2) ) ) , R2) ) by L24 , VALUED_1:22 , L22
.= ( ( ( id (the InstructionsF of ( SCM+FSA )) ) +* ( ( halt ( SCM+FSA ) ) .--> ( goto ( R2 + ( card R7 ) ) ) ) ) * ( Reloc (R7 , R2) ) ) by L18 , COMPOS_1:47 , L23;
end;
set D2 = ( ( intloc ( 0 ) ) .--> 1 );
set D3 = ( the_Values_of ( SCM+FSA ) );
theorem
L26: (for R4 being (Instruction of ( SCM+FSA )) holds (for R13 being (State of ( SCM+FSA )) holds (( InsCode R4 ) in { ( 0 ) , 6 , 7 , 8 } or ( ( Exec (R4 , R13) ) . ( IC ( SCM+FSA ) ) ) = ( succ ( IC R13 ) ))))
proof
let R4 being (Instruction of ( SCM+FSA ));
let R13 being (State of ( SCM+FSA ));
L27: ( InsCode R4 ) <= 12 by SCMFSA_2:16;
assume L28: (not ( InsCode R4 ) in { ( 0 ) , 6 , 7 , 8 });
L29: (( InsCode R4 ) <> ( 0 ) & ( InsCode R4 ) <> 6) by L28 , ENUMSET1:def 2;
L30: (( InsCode R4 ) <> 7 & ( InsCode R4 ) <> 8) by L28 , ENUMSET1:def 2;
per cases  by L29 , L30 , SCMFSA_2:16 , NAT_1:36;
suppose L31: ( InsCode R4 ) = 1;

L32: (ex R10 being Int-Location st (ex R11 being Int-Location st R4 = ( R10 := R11 ))) by L31 , SCMFSA_2:30;
thus L33: thesis by L32 , SCMFSA_2:63;
end;
suppose L34: ( InsCode R4 ) = 2;

L35: (ex R10 being Int-Location st (ex R11 being Int-Location st R4 = ( AddTo (R10 , R11) ))) by L34 , SCMFSA_2:31;
thus L36: thesis by L35 , SCMFSA_2:64;
end;
suppose L37: ( InsCode R4 ) = 3;

L38: (ex R10 being Int-Location st (ex R11 being Int-Location st R4 = ( SubFrom (R10 , R11) ))) by L37 , SCMFSA_2:32;
thus L39: thesis by L38 , SCMFSA_2:65;
end;
suppose L40: ( InsCode R4 ) = 4;

L41: (ex R10 being Int-Location st (ex R11 being Int-Location st R4 = ( MultBy (R10 , R11) ))) by L40 , SCMFSA_2:33;
thus L42: thesis by L41 , SCMFSA_2:66;
end;
suppose L43: ( InsCode R4 ) = 5;

L44: (ex R10 being Int-Location st (ex R11 being Int-Location st R4 = ( Divide (R10 , R11) ))) by L43 , SCMFSA_2:34;
thus L45: thesis by L44 , SCMFSA_2:67;
end;
suppose L46: ( InsCode R4 ) = 9;

L47: (ex R10 being Int-Location st (ex R11 being Int-Location st (ex R12 being FinSeq-Location st R4 = ( R11 := (R12 , R10) )))) by L46 , SCMFSA_2:38;
thus L48: thesis by L47 , SCMFSA_2:72;
end;
suppose L49: ( InsCode R4 ) = 10;

L50: (ex R10 being Int-Location st (ex R11 being Int-Location st (ex R12 being FinSeq-Location st R4 = ( (R12 , R10) := R11 )))) by L49 , SCMFSA_2:39;
thus L51: thesis by L50 , SCMFSA_2:73;
end;
suppose L52: ( InsCode R4 ) = 11;

L53: (ex R10 being Int-Location st (ex R12 being FinSeq-Location st R4 = ( R10 :=len R12 ))) by L52 , SCMFSA_2:40;
thus L54: thesis by L53 , SCMFSA_2:74;
end;
suppose L55: ( InsCode R4 ) = 12;

L56: (ex R10 being Int-Location st (ex R12 being FinSeq-Location st R4 = ( R12 :=<0,...,0> R10 ))) by L55 , SCMFSA_2:41;
thus L57: thesis by L56 , SCMFSA_2:75;
end;
end;
canceled 4;
theorem
L59: (for B1 , B2 being (State of ( SCM+FSA )) holds (for B3 being (Element of ( NAT )) holds (for B4 being (Instruction of ( SCM+FSA )) holds ((( ( IC B1 ) + B3 ) = ( IC B2 ) & ( DataPart B1 ) = ( DataPart B2 )) implies (( ( IC ( Exec (B4 , B1) ) ) + B3 ) = ( IC ( Exec (( IncAddr (B4 , B3) ) , B2) ) ) & ( DataPart ( Exec (B4 , B1) ) ) = ( DataPart ( Exec (( IncAddr (B4 , B3) ) , B2) ) ))))))
proof
set D4 = ( Data-Locations ( SCM+FSA ) );
let C7 , C8 being (State of ( SCM+FSA ));
let C9 being (Element of ( NAT ));
let C10 being (Instruction of ( SCM+FSA ));
assume that
L60: ( ( IC C7 ) + C9 ) = ( IC C8 )
and
L61: ( DataPart C7 ) = ( DataPart C8 );
reconsider D5 = ( IC C7 ) as (Element of ( NAT ));
L62: ( ( succ ( IC C7 ) ) + C9 ) = ( ( D5 + 1 ) + C9 ) by NAT_1:38
.= ( ( D5 + C9 ) + 1 )
.= ( succ ( IC C8 ) ) by L60 , NAT_1:38;
L63:
now
set D6 = ( InsCode C10 );
assume that
L64: (D6 < 6 or 8 < D6)
and
L65: D6 <> ( 0 );
L66: (not (D6 = 6 or D6 = 7 or D6 = 8)) by L64;
L67: (not D6 in { 6 , 7 , 8 }) by L66 , ENUMSET1:def 1;
L68: ( IncAddr (C10 , C9) ) = C10 by L67 , SCMFSA_4:4;
L69: (not (D6 = ( 0 ) or D6 = 6 or D6 = 7 or D6 = 8)) by L64 , L65;
L70: (not D6 in { ( 0 ) , 6 , 7 , 8 }) by L69 , ENUMSET1:def 2;
L71: ( IC ( Exec (C10 , C7) ) ) = ( succ ( IC C7 ) ) by L70 , L26;
thus L72: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L71 , L62 , L70 , L68 , L26;
end;
L73: ( InsCode C10 ) <= 12 by SCMFSA_2:16;
per cases  by SCMFSA_2:16 , NAT_1:36;
suppose L74: ( InsCode C10 ) = ( 0 );

L75: C10 = ( halt ( SCM+FSA ) ) by L74 , SCMFSA_2:95;
L76: (( Exec (C10 , C7) ) = C7 & ( Exec (C10 , C8) ) = C8) by L75 , EXTPRO_1:def 3;
thus L77: thesis by L76 , L60 , L61 , L75 , COMPOS_0:4;
end;
suppose L78: ( InsCode C10 ) = 1;

thus L79: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L78 , L63;
consider C11 , C12 being Int-Location such that L80: C10 = ( C11 := C12 ) by L78 , SCMFSA_2:30;
L81: ( IncAddr (C10 , C9) ) = C10 by L80 , COMPOS_0:4;
L82:
now
let C13 being Int-Location;
per cases ;
suppose L83: C13 = C11;

thus L84: ( ( Exec (C10 , C7) ) . C13 ) = ( C7 . C12 ) by L83 , L80 , SCMFSA_2:63
.= ( C8 . C12 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C13 ) by L80 , L81 , L83 , SCMFSA_2:63;
end;
suppose L85: C13 <> C11;

thus L86: ( ( Exec (C10 , C7) ) . C13 ) = ( C7 . C13 ) by L85 , L80 , SCMFSA_2:63
.= ( C8 . C13 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C13 ) by L80 , L81 , L85 , SCMFSA_2:63;
end;
end;
L88:
now
let C14 being FinSeq-Location;
thus L89: ( ( Exec (C10 , C7) ) . C14 ) = ( C7 . C14 ) by L80 , SCMFSA_2:63
.= ( C8 . C14 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C14 ) by L80 , L81 , SCMFSA_2:63;
end;
thus L90: thesis by L88 , L82 , SCMFSA_M:2;
end;
suppose L91: ( InsCode C10 ) = 2;

thus L92: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L91 , L63;
consider C15 , C16 being Int-Location such that L93: C10 = ( AddTo (C15 , C16) ) by L91 , SCMFSA_2:31;
L94: ( IncAddr (C10 , C9) ) = C10 by L93 , COMPOS_0:4;
L95:
now
let C17 being Int-Location;
per cases ;
suppose L96: C17 = C15;

L97: (( C7 . C15 ) = ( C8 . C15 ) & ( C7 . C16 ) = ( C8 . C16 )) by L61 , SCMFSA_M:2;
thus L98: ( ( Exec (C10 , C7) ) . C17 ) = ( ( C8 . C15 ) + ( C8 . C16 ) ) by L97 , L93 , L96 , SCMFSA_2:64
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C17 ) by L93 , L94 , L96 , SCMFSA_2:64;
end;
suppose L99: C17 <> C15;

thus L100: ( ( Exec (C10 , C7) ) . C17 ) = ( C7 . C17 ) by L99 , L93 , SCMFSA_2:64
.= ( C8 . C17 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C17 ) by L93 , L94 , L99 , SCMFSA_2:64;
end;
end;
L102:
now
let C18 being FinSeq-Location;
thus L103: ( ( Exec (C10 , C7) ) . C18 ) = ( C7 . C18 ) by L93 , SCMFSA_2:64
.= ( C8 . C18 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C18 ) by L93 , L94 , SCMFSA_2:64;
end;
thus L104: thesis by L102 , L95 , SCMFSA_M:2;
end;
suppose L105: ( InsCode C10 ) = 3;

thus L106: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L105 , L63;
consider C19 , C20 being Int-Location such that L107: C10 = ( SubFrom (C19 , C20) ) by L105 , SCMFSA_2:32;
L108: ( IncAddr (C10 , C9) ) = C10 by L107 , COMPOS_0:4;
L109:
now
let C21 being Int-Location;
per cases ;
suppose L110: C21 = C19;

L111: (( C7 . C19 ) = ( C8 . C19 ) & ( C7 . C20 ) = ( C8 . C20 )) by L61 , SCMFSA_M:2;
thus L112: ( ( Exec (C10 , C7) ) . C21 ) = ( ( C8 . C19 ) - ( C8 . C20 ) ) by L111 , L107 , L110 , SCMFSA_2:65
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C21 ) by L107 , L108 , L110 , SCMFSA_2:65;
end;
suppose L113: C21 <> C19;

thus L114: ( ( Exec (C10 , C7) ) . C21 ) = ( C7 . C21 ) by L113 , L107 , SCMFSA_2:65
.= ( C8 . C21 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C21 ) by L107 , L108 , L113 , SCMFSA_2:65;
end;
end;
L116:
now
let C22 being FinSeq-Location;
thus L117: ( ( Exec (C10 , C7) ) . C22 ) = ( C7 . C22 ) by L107 , SCMFSA_2:65
.= ( C8 . C22 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C22 ) by L107 , L108 , SCMFSA_2:65;
end;
thus L118: thesis by L116 , L109 , SCMFSA_M:2;
end;
suppose L119: ( InsCode C10 ) = 4;

thus L120: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L119 , L63;
consider C23 , C24 being Int-Location such that L121: C10 = ( MultBy (C23 , C24) ) by L119 , SCMFSA_2:33;
L122: ( IncAddr (C10 , C9) ) = C10 by L121 , COMPOS_0:4;
L123:
now
let C25 being Int-Location;
per cases ;
suppose L124: C25 = C23;

L125: (( C7 . C23 ) = ( C8 . C23 ) & ( C7 . C24 ) = ( C8 . C24 )) by L61 , SCMFSA_M:2;
thus L126: ( ( Exec (C10 , C7) ) . C25 ) = ( ( C8 . C23 ) * ( C8 . C24 ) ) by L125 , L121 , L124 , SCMFSA_2:66
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C25 ) by L121 , L122 , L124 , SCMFSA_2:66;
end;
suppose L127: C25 <> C23;

thus L128: ( ( Exec (C10 , C7) ) . C25 ) = ( C7 . C25 ) by L127 , L121 , SCMFSA_2:66
.= ( C8 . C25 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C25 ) by L121 , L122 , L127 , SCMFSA_2:66;
end;
end;
L130:
now
let C26 being FinSeq-Location;
thus L131: ( ( Exec (C10 , C7) ) . C26 ) = ( C7 . C26 ) by L121 , SCMFSA_2:66
.= ( C8 . C26 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C26 ) by L121 , L122 , SCMFSA_2:66;
end;
thus L132: thesis by L130 , L123 , SCMFSA_M:2;
end;
suppose L133: ( InsCode C10 ) = 5;

thus L134: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L133 , L63;
consider C27 , C28 being Int-Location such that L135: C10 = ( Divide (C27 , C28) ) by L133 , SCMFSA_2:34;
L136: ( IncAddr (C10 , C9) ) = C10 by L135 , COMPOS_0:4;
L137:
now
let C29 being Int-Location;
per cases ;
suppose L138: C29 = C28;

L139: (( C7 . C27 ) = ( C8 . C27 ) & ( C7 . C28 ) = ( C8 . C28 )) by L61 , SCMFSA_M:2;
thus L140: ( ( Exec (C10 , C7) ) . C29 ) = ( ( C8 . C27 ) mod ( C8 . C28 ) ) by L139 , L135 , L138 , SCMFSA_2:67
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C29 ) by L135 , L136 , L138 , SCMFSA_2:67;
end;
suppose L141: (C29 = C27 & C29 <> C28);

L142: (( C7 . C27 ) = ( C8 . C27 ) & ( C7 . C28 ) = ( C8 . C28 )) by L61 , SCMFSA_M:2;
thus L143: ( ( Exec (C10 , C7) ) . C29 ) = ( ( C8 . C27 ) div ( C8 . C28 ) ) by L142 , L135 , L141 , SCMFSA_2:67
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C29 ) by L135 , L136 , L141 , SCMFSA_2:67;
end;
suppose L144: (C29 <> C27 & C29 <> C28);

thus L145: ( ( Exec (C10 , C7) ) . C29 ) = ( C7 . C29 ) by L144 , L135 , SCMFSA_2:67
.= ( C8 . C29 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C29 ) by L135 , L136 , L144 , SCMFSA_2:67;
end;
end;
L147:
now
let C30 being FinSeq-Location;
thus L148: ( ( Exec (C10 , C7) ) . C30 ) = ( C7 . C30 ) by L135 , SCMFSA_2:67
.= ( C8 . C30 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C30 ) by L135 , L136 , SCMFSA_2:67;
end;
thus L149: thesis by L147 , L137 , SCMFSA_M:2;
end;
suppose L150: ( InsCode C10 ) = 6;

consider C31 being (Element of ( NAT )) such that L151: C10 = ( goto C31 ) by L150 , SCMFSA_2:35;
L152: ( IncAddr (C10 , C9) ) = ( goto ( C31 + C9 ) ) by L151 , SCMFSA_4:1;
L153:
now
let C32 being FinSeq-Location;
thus L154: ( ( Exec (C10 , C7) ) . C32 ) = ( C7 . C32 ) by L151 , SCMFSA_2:69
.= ( C8 . C32 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C32 ) by L152 , SCMFSA_2:69;
end;
L155: ( IC ( Exec (C10 , C7) ) ) = C31 by L151 , SCMFSA_2:69;
thus L156: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L155 , L152 , SCMFSA_2:69;
L157:
now
let C33 being Int-Location;
thus L158: ( ( Exec (C10 , C7) ) . C33 ) = ( C7 . C33 ) by L151 , SCMFSA_2:69
.= ( C8 . C33 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C33 ) by L152 , SCMFSA_2:69;
end;
thus L159: thesis by L157 , L153 , SCMFSA_M:2;
end;
suppose L160: ( InsCode C10 ) = 7;

consider C34 being (Element of ( NAT )), C35 being Int-Location such that L161: C10 = ( C35 =0_goto C34 ) by L160 , SCMFSA_2:36;
L162: ( IncAddr (C10 , C9) ) = ( C35 =0_goto ( C34 + C9 ) ) by L161 , SCMFSA_4:2;
L163:
now
let C36 being FinSeq-Location;
thus L164: ( ( Exec (C10 , C7) ) . C36 ) = ( C7 . C36 ) by L161 , SCMFSA_2:70
.= ( C8 . C36 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C36 ) by L162 , SCMFSA_2:70;
end;
thus L165:now
per cases ;
suppose L166: ( C7 . C35 ) = ( 0 );

L167: (( C8 . C35 ) = ( 0 ) & ( IC ( Exec (C10 , C7) ) ) = C34) by L166 , L61 , L161 , SCMFSA_M:2 , SCMFSA_2:70;
thus L168: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L167 , L162 , SCMFSA_2:70;
end;
suppose L169: ( C7 . C35 ) <> ( 0 );

L170: (( C8 . C35 ) <> ( 0 ) & ( IC ( Exec (C10 , C7) ) ) = ( succ ( IC C7 ) )) by L169 , L61 , L161 , SCMFSA_M:2 , SCMFSA_2:70;
thus L171: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L170 , L62 , L162 , SCMFSA_2:70;
end;
end;
L173:
now
let C37 being Int-Location;
thus L174: ( ( Exec (C10 , C7) ) . C37 ) = ( C7 . C37 ) by L161 , SCMFSA_2:70
.= ( C8 . C37 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C37 ) by L162 , SCMFSA_2:70;
end;
thus L175: thesis by L173 , L163 , SCMFSA_M:2;
end;
suppose L176: ( InsCode C10 ) = 8;

consider C38 being (Element of ( NAT )), C39 being Int-Location such that L177: C10 = ( C39 >0_goto C38 ) by L176 , SCMFSA_2:37;
L178: ( IncAddr (C10 , C9) ) = ( C39 >0_goto ( C38 + C9 ) ) by L177 , SCMFSA_4:3;
L179:
now
let C40 being FinSeq-Location;
thus L180: ( ( Exec (C10 , C7) ) . C40 ) = ( C7 . C40 ) by L177 , SCMFSA_2:71
.= ( C8 . C40 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C40 ) by L178 , SCMFSA_2:71;
end;
thus L181:now
per cases ;
suppose L182: ( C7 . C39 ) > ( 0 );

L183: (( C8 . C39 ) > ( 0 ) & ( IC ( Exec (C10 , C7) ) ) = C38) by L182 , L61 , L177 , SCMFSA_M:2 , SCMFSA_2:71;
thus L184: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L183 , L178 , SCMFSA_2:71;
end;
suppose L185: ( C7 . C39 ) <= ( 0 );

L186: (( C8 . C39 ) <= ( 0 ) & ( IC ( Exec (C10 , C7) ) ) = ( succ ( IC C7 ) )) by L185 , L61 , L177 , SCMFSA_M:2 , SCMFSA_2:71;
thus L187: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L186 , L62 , L178 , SCMFSA_2:71;
end;
end;
L189:
now
let C41 being Int-Location;
thus L190: ( ( Exec (C10 , C7) ) . C41 ) = ( C7 . C41 ) by L177 , SCMFSA_2:71
.= ( C8 . C41 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C41 ) by L178 , SCMFSA_2:71;
end;
thus L191: thesis by L189 , L179 , SCMFSA_M:2;
end;
suppose L192: ( InsCode C10 ) = 9;

thus L193: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L192 , L63;
consider C42 , C43 being Int-Location, C44 being FinSeq-Location such that L194: C10 = ( C43 := (C44 , C42) ) by L192 , SCMFSA_2:38;
L195: ( IncAddr (C10 , C9) ) = C10 by L194 , COMPOS_0:4;
L196:
now
let C45 being Int-Location;
per cases ;
suppose L197: C45 = C43;

consider C46 being (Element of ( NAT )) such that L198: C46 = ( abs ( C7 . C42 ) ) and L199: ( ( Exec (( C43 := (C44 , C42) ) , C7) ) . C45 ) = ( ( C7 . C44 ) /. C46 ) by L197 , SCMFSA_2:72;
L200: ( C7 . C44 ) = ( C8 . C44 ) by L61 , SCMFSA_M:2;
consider C47 being (Element of ( NAT )) such that L201: C47 = ( abs ( C8 . C42 ) ) and L202: ( ( Exec (( C43 := (C44 , C42) ) , C8) ) . C45 ) = ( ( C8 . C44 ) /. C47 ) by L197 , SCMFSA_2:72;
L203: C46 = C47 by L61 , L198 , L201 , SCMFSA_M:2;
thus L204: ( ( Exec (C10 , C7) ) . C45 ) = ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C45 ) by L203 , L194 , L199 , L202 , L200 , COMPOS_0:4;
end;
suppose L205: C45 <> C43;

thus L206: ( ( Exec (C10 , C7) ) . C45 ) = ( C7 . C45 ) by L205 , L194 , SCMFSA_2:72
.= ( C8 . C45 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C45 ) by L194 , L195 , L205 , SCMFSA_2:72;
end;
end;
L208:
now
let C48 being FinSeq-Location;
thus L209: ( ( Exec (C10 , C7) ) . C48 ) = ( C7 . C48 ) by L194 , SCMFSA_2:72
.= ( C8 . C48 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C48 ) by L194 , L195 , SCMFSA_2:72;
end;
thus L210: thesis by L208 , L196 , SCMFSA_M:2;
end;
suppose L211: ( InsCode C10 ) = 10;

thus L212: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L211 , L63;
consider C49 , C50 being Int-Location, C51 being FinSeq-Location such that L213: C10 = ( (C51 , C49) := C50 ) by L211 , SCMFSA_2:39;
L214: ( IncAddr (C10 , C9) ) = C10 by L213 , COMPOS_0:4;
L215:
now
let C52 being FinSeq-Location;
per cases ;
suppose L216: C52 = C51;

L217: (( C7 . C50 ) = ( C8 . C50 ) & ( C7 . C51 ) = ( C8 . C51 )) by L61 , SCMFSA_M:2;
consider C53 being (Element of ( NAT )) such that L218: C53 = ( abs ( C8 . C49 ) ) and L219: ( ( Exec (( (C51 , C49) := C50 ) , C8) ) . C51 ) = ( ( C8 . C51 ) +* (C53 , ( C8 . C50 )) ) by SCMFSA_2:73;
consider C54 being (Element of ( NAT )) such that L220: C54 = ( abs ( C7 . C49 ) ) and L221: ( ( Exec (( (C51 , C49) := C50 ) , C7) ) . C51 ) = ( ( C7 . C51 ) +* (C54 , ( C7 . C50 )) ) by SCMFSA_2:73;
L222: C54 = C53 by L61 , L220 , L218 , SCMFSA_M:2;
thus L223: ( ( Exec (C10 , C7) ) . C52 ) = ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C52 ) by L222 , L213 , L216 , L221 , L219 , L217 , COMPOS_0:4;
end;
suppose L224: C52 <> C51;

thus L225: ( ( Exec (C10 , C7) ) . C52 ) = ( C7 . C52 ) by L224 , L213 , SCMFSA_2:73
.= ( C8 . C52 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C52 ) by L213 , L214 , L224 , SCMFSA_2:73;
end;
end;
L227:
now
let C55 being Int-Location;
thus L228: ( ( Exec (C10 , C7) ) . C55 ) = ( C7 . C55 ) by L213 , SCMFSA_2:73
.= ( C8 . C55 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C55 ) by L213 , L214 , SCMFSA_2:73;
end;
thus L229: thesis by L227 , L215 , SCMFSA_M:2;
end;
suppose L230: ( InsCode C10 ) = 11;

thus L231: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L230 , L63;
consider C56 being Int-Location, C57 being FinSeq-Location such that L232: C10 = ( C56 :=len C57 ) by L230 , SCMFSA_2:40;
L233: ( IncAddr (C10 , C9) ) = C10 by L232 , COMPOS_0:4;
L234:
now
let C58 being Int-Location;
per cases ;
suppose L235: C58 = C56;

thus L236: ( ( Exec (C10 , C7) ) . C58 ) = ( len ( C7 . C57 ) ) by L235 , L232 , SCMFSA_2:74
.= ( len ( C8 . C57 ) ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C58 ) by L232 , L233 , L235 , SCMFSA_2:74;
end;
suppose L237: C58 <> C56;

thus L238: ( ( Exec (C10 , C7) ) . C58 ) = ( C7 . C58 ) by L237 , L232 , SCMFSA_2:74
.= ( C8 . C58 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C58 ) by L232 , L233 , L237 , SCMFSA_2:74;
end;
end;
L240:
now
let C59 being FinSeq-Location;
thus L241: ( ( Exec (C10 , C7) ) . C59 ) = ( C7 . C59 ) by L232 , SCMFSA_2:74
.= ( C8 . C59 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C59 ) by L232 , L233 , SCMFSA_2:74;
end;
thus L242: thesis by L240 , L234 , SCMFSA_M:2;
end;
suppose L243: ( InsCode C10 ) = 12;

thus L244: ( ( IC ( Exec (C10 , C7) ) ) + C9 ) = ( IC ( Exec (( IncAddr (C10 , C9) ) , C8) ) ) by L243 , L63;
consider C60 being Int-Location, C61 being FinSeq-Location such that L245: C10 = ( C61 :=<0,...,0> C60 ) by L243 , SCMFSA_2:41;
L246: ( IncAddr (C10 , C9) ) = C10 by L245 , COMPOS_0:4;
L247:
now
let C62 being FinSeq-Location;
per cases ;
suppose L248: C62 = C61;

L249: ((ex B5 being (Element of ( NAT )) st (B5 = ( abs ( C7 . C60 ) ) & ( ( Exec (( C61 :=<0,...,0> C60 ) , C7) ) . C61 ) = ( B5 |-> ( 0 ) ))) & (ex B6 being (Element of ( NAT )) st (B6 = ( abs ( C8 . C60 ) ) & ( ( Exec (( C61 :=<0,...,0> C60 ) , C8) ) . C61 ) = ( B6 |-> ( 0 ) )))) by SCMFSA_2:75;
thus L250: ( ( Exec (C10 , C7) ) . C62 ) = ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C62 ) by L249 , L61 , L245 , L246 , L248 , SCMFSA_M:2;
end;
suppose L251: C62 <> C61;

thus L252: ( ( Exec (C10 , C7) ) . C62 ) = ( C7 . C62 ) by L251 , L245 , SCMFSA_2:75
.= ( C8 . C62 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C62 ) by L245 , L246 , L251 , SCMFSA_2:75;
end;
end;
L254:
now
let C63 being Int-Location;
thus L255: ( ( Exec (C10 , C7) ) . C63 ) = ( C7 . C63 ) by L245 , SCMFSA_2:75
.= ( C8 . C63 ) by L61 , SCMFSA_M:2
.= ( ( Exec (( IncAddr (C10 , C9) ) , C8) ) . C63 ) by L245 , L246 , SCMFSA_2:75;
end;
thus L256: thesis by L254 , L247 , SCMFSA_M:2;
end;
end;
canceled 6;
begin
definition
canceled 1;
let C64 , C65 being (Program of ( SCM+FSA ));
func C64 ";" C65 -> (Program of ( SCM+FSA )) equals 
( ( Directed ( CutLastLoc ( stop C64 ) ) ) +* ( Reloc (C65 , ( card C64 )) ) );
coherence
proof
set D7 = ( ( Directed C64 ) +* ( Reloc (C65 , ( card C64 )) ) );
L258: D7 is  initial
proof
set D8 = { ( R1 + ( card C64 ) ) where R1 is (Element of ( NAT )) : R1 in ( dom C65 ) };
let C66 , C67 being Nat;
assume that
L259: C67 in ( dom D7 )
and
L260: C66 < C67;
L261: (( dom ( Directed C64 ) ) = ( dom C64 ) & ( dom ( Reloc (C65 , ( card C64 )) ) ) = D8) by COMPOS_1:33 , FUNCT_4:99;
L262: ( dom D7 ) = ( ( dom C64 ) \/ D8 ) by L261 , FUNCT_4:def 1;
per cases  by L259 , L262 , XBOOLE_0:def 3;
suppose L263: C67 in ( dom C64 );

L264: C66 in ( dom C64 ) by L263 , L260 , AFINSQ_1:def 12;
thus L265: thesis by L264 , L262 , XBOOLE_0:def 3;
end;
suppose L266: C67 in D8;

consider R1 being (Element of ( NAT )) such that L267: C67 = ( R1 + ( card C64 ) ) and L268: R1 in ( dom C65 ) by L266;
L269:
now
per cases ;
case L270: C66 < ( card C64 );
L271: C66 in ( dom C64 ) by L270 , AFINSQ_1:66;
thus L272: C66 in ( dom D7 ) by L271 , L262 , XBOOLE_0:def 3;
end;
case L273: C66 >= ( card C64 );
consider C68 being Nat such that L274: C66 = ( ( card C64 ) + C68 ) by L273 , NAT_1:10;
reconsider D9 = C68 as (Element of ( NAT )) by ORDINAL1:def 12;
L275: D9 < R1 by L260 , L267 , L274 , XREAL_1:6;
L276: D9 in ( dom C65 ) by L275 , L268 , AFINSQ_1:def 12;
thus L277: C66 in D8 by L276 , L274;
end;
end;
thus L279: thesis by L269 , L262 , XBOOLE_0:def 3;
end;
end;
thus L281: thesis by L258;
end;
correctness;
end;
registration
let C69 being (Program of ( SCM+FSA ));
let C70 being non  halt-free (Program of ( SCM+FSA ));
cluster ( C69 ";" C70 ) -> non  halt-free;
coherence;
end;
theorem
L284: (for B7 , B8 being (Program of ( SCM+FSA )) holds (for B9 being (Element of ( NAT )) holds ((B9 in ( dom B7 ) & ( B7 . B9 ) <> ( halt ( SCM+FSA ) )) implies ( ( B7 ";" B8 ) . B9 ) = ( B7 . B9 ))))
proof
let C71 , C72 being (Program of ( SCM+FSA ));
let C73 being (Element of ( NAT ));
assume that
L285: C73 in ( dom C71 )
and
L286: ( C71 . C73 ) <> ( halt ( SCM+FSA ) );
L287: ( Reloc (C72 , ( card C71 )) ) = ( IncAddr (( Shift (C72 , ( card C71 )) ) , ( card C71 )) ) by COMPOS_1:34;
L288: ( dom ( Reloc (C72 , ( card C71 )) ) ) = ( dom ( Shift (C72 , ( card C71 )) ) ) by L287 , COMPOS_1:def 21;
L289:
now
assume L290: C73 in ( dom ( Reloc (C72 , ( card C71 )) ) );
L291: C73 in { ( R2 + ( card C71 ) ) where R2 is (Element of ( NAT )) : R2 in ( dom C72 ) } by L290 , L288 , VALUED_1:def 12;
consider R2 being (Element of ( NAT )) such that L292: C73 = ( R2 + ( card C71 ) ) and L293: R2 in ( dom C72 ) by L291;
L294: ( R2 + ( card C71 ) ) < ( card C71 ) by L285 , L292 , AFINSQ_1:66;
thus L295: contradiction by L294 , NAT_1:11;
end;
thus L296: ( ( C71 ";" C72 ) . C73 ) = ( ( Directed C71 ) . C73 ) by L289 , FUNCT_4:11
.= ( C71 . C73 ) by L286 , FUNCT_4:105;
end;
theorem
L297: (for B10 , B11 being (Program of ( SCM+FSA )) holds ( Directed B10 ) c= ( B10 ";" B11 ))
proof
let C74 , C75 being (Program of ( SCM+FSA ));
L298:
now
let C76 being set;
assume L299: C76 in ( dom ( Directed C74 ) );
L300: C76 in ( dom C74 ) by L299 , FUNCT_4:99;
L301: ( dom C74 ) misses ( dom ( Reloc (C75 , ( card C74 )) ) ) by COMPOS_1:48;
L302: (not C76 in ( dom ( Reloc (C75 , ( card C74 )) ) )) by L301 , L300 , XBOOLE_0:3;
thus L303: ( ( Directed C74 ) . C76 ) = ( ( C74 ";" C75 ) . C76 ) by L302 , FUNCT_4:11;
end;
L304: ( dom ( C74 ";" C75 ) ) = ( ( dom ( Directed C74 ) ) \/ ( dom ( Reloc (C75 , ( card C74 )) ) ) ) by FUNCT_4:def 1;
L305: ( dom ( Directed C74 ) ) c= ( dom ( C74 ";" C75 ) ) by L304 , XBOOLE_1:7;
thus L306: thesis by L305 , L298 , GRFUNC_1:2;
end;
theorem
L307: (for B12 , B13 being (Program of ( SCM+FSA )) holds ( dom B12 ) c= ( dom ( B12 ";" B13 ) ))
proof
let C77 , C78 being (Program of ( SCM+FSA ));
L308: ( dom ( C77 ";" C78 ) ) = ( ( dom ( Directed C77 ) ) \/ ( dom ( Reloc (C78 , ( card C77 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom C77 ) \/ ( dom ( Reloc (C78 , ( card C77 )) ) ) ) by FUNCT_4:99;
thus L309: thesis by L308 , XBOOLE_1:7;
end;
theorem
L310: (for B14 , B15 being (Program of ( SCM+FSA )) holds ( B14 +* ( B14 ";" B15 ) ) = ( B14 ";" B15 ))
proof
let C79 , C80 being (Program of ( SCM+FSA ));
L311: (for B16 being set holds (B16 in ( dom ( C79 ";" C80 ) ) implies ( ( C79 +* ( C79 ";" C80 ) ) . B16 ) = ( ( C79 ";" C80 ) . B16 ))) by FUNCT_4:13;
L312: ( dom ( C79 +* ( C79 ";" C80 ) ) ) = ( ( dom C79 ) \/ ( dom ( C79 ";" C80 ) ) ) by FUNCT_4:def 1
.= ( dom ( C79 ";" C80 ) ) by L307 , XBOOLE_1:12;
thus L313: thesis by L312 , L311 , FUNCT_1:2;
end;
begin
definition
let R4 being (Instruction of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
func R4 ";" R8 -> (Program of ( SCM+FSA )) equals 
( ( Macro R4 ) ";" R8 );
correctness;
end;
definition
let R7 being (Program of ( SCM+FSA ));
let R5 being (Instruction of ( SCM+FSA ));
func R7 ";" R5 -> (Program of ( SCM+FSA )) equals 
( R7 ";" ( Macro R5 ) );
correctness;
end;
definition
let R4 being (Instruction of ( SCM+FSA ));
let R5 being (Instruction of ( SCM+FSA ));
func R4 ";" R5 -> (Program of ( SCM+FSA )) equals 
( ( Macro R4 ) ";" ( Macro R5 ) );
correctness;
end;
theorem
L317: (for R4 being (Instruction of ( SCM+FSA )) holds (for R5 being (Instruction of ( SCM+FSA )) holds ( R4 ";" R5 ) = ( ( Macro R4 ) ";" R5 )));
theorem
L318: (for R4 being (Instruction of ( SCM+FSA )) holds (for R5 being (Instruction of ( SCM+FSA )) holds ( R4 ";" R5 ) = ( R4 ";" ( Macro R5 ) )));
theorem
L319: (for R7 being (Program of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds ( card ( R7 ";" R8 ) ) = ( ( card R7 ) + ( card R8 ) )))
proof
let R7 being (Program of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
L320: (( card ( dom ( R7 ";" R8 ) ) ) = ( card ( R7 ";" R8 ) ) & ( card ( dom R7 ) ) = ( card R7 )) by CARD_1:62;
L321: ( card ( dom R8 ) ) = ( card R8 ) by CARD_1:62;
L322: ( dom ( R7 ";" R8 ) ) = ( ( dom ( Directed R7 ) ) \/ ( dom ( Reloc (R8 , ( card R7 )) ) ) ) by FUNCT_4:def 1
.= ( ( dom R7 ) \/ ( dom ( Reloc (R8 , ( card R7 )) ) ) ) by FUNCT_4:99;
L323: ( card ( dom ( Reloc (R8 , ( card R7 )) ) ) ) = ( card ( Reloc (R8 , ( card R7 )) ) ) by CARD_1:62
.= ( card R8 ) by COMPOS_1:49
.= ( card ( dom R8 ) ) by CARD_1:62;
thus L324: thesis by L323 , L320 , L321 , L322 , CARD_2:40 , COMPOS_1:48;
end;
registration
let C81 being (preProgram of ( SCM+FSA ));
let C82 being (Element of ( NAT ));
cluster ( Directed (C81 , C82) ) ->  halt-free;
correctness
proof
L325: (not ( halt ( SCM+FSA ) ) in ( rng ( Directed (C81 , C82) ) )) by FUNCT_4:100;
thus L326: thesis by L325 , COMPOS_1:def 11;
end;
end;
registration
let C83 being (preProgram of ( SCM+FSA ));
cluster ( Directed C83 ) ->  halt-free;
correctness;
end;
theorem
L329: (for B17 being (preProgram of ( SCM+FSA )) holds (for B18 being (Element of ( NAT )) holds (B17 is  halt-free implies ( Directed (B17 , B18) ) = B17)))
proof
let C84 being (preProgram of ( SCM+FSA ));
let C85 being (Element of ( NAT ));
assume L330: C84 is  halt-free;
L331: (not ( halt ( SCM+FSA ) ) in ( rng C84 )) by L330 , COMPOS_1:def 11;
thus L332: thesis by L331 , FUNCT_4:103;
end;
theorem
L333: (for B19 being (preProgram of ( SCM+FSA )) holds (for B20 being (Element of ( NAT )) holds ( Reloc (( Directed B19 ) , B20) ) = ( Directed (( Reloc (B19 , B20) ) , ( ( card B19 ) + B20 )) )))
proof
let C86 being (preProgram of ( SCM+FSA ));
let C87 being (Element of ( NAT ));
L334: ( dom ( Reloc (C86 , C87) ) ) = { ( R2 + C87 ) where R2 is (Element of ( NAT )) : R2 in ( dom C86 ) } by COMPOS_1:33;
L335: ( dom ( Directed C86 ) ) = ( dom C86 ) by FUNCT_4:99;
L336: ( dom ( Reloc (( Directed C86 ) , C87) ) ) = { ( R2 + C87 ) where R2 is (Element of ( NAT )) : R2 in ( dom C86 ) } by L335 , COMPOS_1:33;
L337:
now
let C88 being set;
assume L338: C88 in { ( R2 + C87 ) where R2 is (Element of ( NAT )) : R2 in ( dom C86 ) };
consider C89 being (Element of ( NAT )) such that L339: C88 = ( C89 + C87 ) and L340: C89 in ( dom C86 ) by L338;
L341: ( dom ( Directed C86 ) ) = ( dom C86 ) by FUNCT_4:99;
reconsider D10 = ( ( Directed C86 ) . C89 ) as (Instruction of ( SCM+FSA )) by L341 , L340 , FUNCT_1:106;
reconsider D11 = ( C86 . C89 ) as (Instruction of ( SCM+FSA )) by L340 , FUNCT_1:106;
L342:
now
per cases ;
suppose L343: D11 = ( halt ( SCM+FSA ) );

L344: D10 = ( goto ( card C86 ) ) by L343 , L340 , FUNCT_4:106;
L345: ( ( Reloc (C86 , C87) ) . C88 ) = ( IncAddr (D11 , C87) ) by L339 , L340 , COMPOS_1:35
.= ( halt ( SCM+FSA ) ) by L343 , COMPOS_0:4;
L346: ( ( Reloc (C86 , C87) ) . C88 ) in { ( halt ( SCM+FSA ) ) } by L345 , TARSKI:def 1;
L347: ( ( Reloc (C86 , C87) ) . C88 ) in ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto ( ( card C86 ) + C87 ) ) ) ) by L346 , FUNCOP_1:13;
L348: C88 in ( dom ( ( ( halt ( SCM+FSA ) ) .--> ( goto ( ( card C86 ) + C87 ) ) ) * ( Reloc (C86 , C87) ) ) ) by L347 , L334 , L338 , FUNCT_1:11;
thus L349: ( ( Directed (( Reloc (C86 , C87) ) , ( ( card C86 ) + C87 )) ) . C88 ) = ( ( ( ( halt ( SCM+FSA ) ) .--> ( goto ( ( card C86 ) + C87 ) ) ) * ( Reloc (C86 , C87) ) ) . C88 ) by L348 , FUNCT_4:13
.= ( ( ( halt ( SCM+FSA ) ) .--> ( goto ( ( card C86 ) + C87 ) ) ) . ( ( Reloc (C86 , C87) ) . C88 ) ) by L334 , L338 , FUNCT_1:13
.= ( goto ( ( card C86 ) + C87 ) ) by L345 , FUNCOP_1:72
.= ( IncAddr (D10 , C87) ) by L344 , SCMFSA_4:1;
end;
suppose L350: D11 <> ( halt ( SCM+FSA ) );

L351: ( ( Reloc (C86 , C87) ) . C88 ) = ( IncAddr (D11 , C87) ) by L339 , L340 , COMPOS_1:35;
L352: ( InsCode ( halt ( SCM+FSA ) ) ) = ( 0 ) by COMPOS_1:70;
L353: ( InsCode D11 ) <> ( 0 ) by L350 , SCMFSA_2:95;
L354: ( IncAddr (D11 , C87) ) <> ( halt ( SCM+FSA ) ) by L353 , COMPOS_0:def 9 , L352;
L355: (not ( ( Reloc (C86 , C87) ) . C88 ) in { ( halt ( SCM+FSA ) ) }) by L354 , L351 , TARSKI:def 1;
L356: (not ( ( Reloc (C86 , C87) ) . C88 ) in ( dom ( ( halt ( SCM+FSA ) ) .--> ( goto ( ( card C86 ) + C87 ) ) ) )) by L355 , FUNCOP_1:13;
L357: (not C88 in ( dom ( ( ( halt ( SCM+FSA ) ) .--> ( goto ( ( card C86 ) + C87 ) ) ) * ( Reloc (C86 , C87) ) ) )) by L356 , FUNCT_1:11;
thus L358: ( ( Directed (( Reloc (C86 , C87) ) , ( ( card C86 ) + C87 )) ) . C88 ) = ( ( Reloc (C86 , C87) ) . C88 ) by L357 , FUNCT_4:11
.= ( IncAddr (D10 , C87) ) by L350 , L351 , FUNCT_4:105;
end;
end;
thus L360: ( ( Reloc (( Directed C86 ) , C87) ) . C88 ) = ( ( Directed (( Reloc (C86 , C87) ) , ( ( card C86 ) + C87 )) ) . C88 ) by L342 , L335 , L339 , L340 , COMPOS_1:35;
end;
L361: ( dom ( Directed (( Reloc (C86 , C87) ) , ( ( card C86 ) + C87 )) ) ) = { ( R2 + C87 ) where R2 is (Element of ( NAT )) : R2 in ( dom C86 ) } by L334 , FUNCT_4:99;
thus L362: thesis by L361 , L336 , L337 , FUNCT_1:2;
end;
theorem
L363: (for B21 , B22 being (Program of ( SCM+FSA )) holds ( Directed ( B21 ";" B22 ) ) = ( B21 ";" ( Directed B22 ) ))
proof
let C90 , C91 being (Program of ( SCM+FSA ));
thus L364: ( C90 ";" ( Directed C91 ) ) = ( ( Directed C90 ) +* ( Directed (( Reloc (C91 , ( card C90 )) ) , ( ( card C90 ) + ( card C91 ) )) ) ) by L333
.= ( ( Directed C90 ) +* ( Directed (( Reloc (C91 , ( card C90 )) ) , ( card ( C90 ";" C91 ) )) ) ) by L319
.= ( ( Directed (( Directed C90 ) , ( card ( C90 ";" C91 ) )) ) +* ( Directed (( Reloc (C91 , ( card C90 )) ) , ( card ( C90 ";" C91 ) )) ) ) by L329
.= ( Directed ( C90 ";" C91 ) ) by FUNCT_7:117;
end;
theorem
L365: (for R7 being (Program of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being (Program of ( SCM+FSA )) holds ( ( R7 ";" R8 ) ";" R9 ) = ( R7 ";" ( R8 ";" R9 ) ))))
proof
let R7 being (Program of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
let R9 being (Program of ( SCM+FSA ));
L366: ( Reloc (( R8 ";" R9 ) , ( card R7 )) ) = ( ( Reloc (( Directed R8 ) , ( card R7 )) ) +* ( Reloc (( Reloc (R9 , ( card R8 )) ) , ( card R7 )) ) ) by COMPOS_1:42
.= ( ( Reloc (( Directed R8 ) , ( card R7 )) ) +* ( Reloc (R9 , ( ( card R8 ) + ( card R7 ) )) ) ) by COMPOS_1:43;
thus L367: ( ( R7 ";" R8 ) ";" R9 ) = ( ( R7 ";" ( Directed R8 ) ) +* ( Reloc (R9 , ( card ( R7 ";" R8 ) )) ) ) by L363
.= ( ( Directed R7 ) +* ( ( Reloc (( Directed R8 ) , ( card R7 )) ) +* ( Reloc (R9 , ( card ( R7 ";" R8 ) )) ) ) ) by FUNCT_4:14
.= ( R7 ";" ( R8 ";" R9 ) ) by L366 , L319;
end;
theorem
L368: (for R6 being (Instruction of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds ( ( R7 ";" R8 ) ";" R6 ) = ( R7 ";" ( R8 ";" R6 ) )))) by L365;
theorem
L369: (for R5 being (Instruction of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds (for R9 being (Program of ( SCM+FSA )) holds ( ( R7 ";" R5 ) ";" R9 ) = ( R7 ";" ( R5 ";" R9 ) )))) by L365;
theorem
L370: (for R5 being (Instruction of ( SCM+FSA )) holds (for R6 being (Instruction of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds ( ( R7 ";" R5 ) ";" R6 ) = ( R7 ";" ( R5 ";" R6 ) )))) by L365;
theorem
L371: (for R4 being (Instruction of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds (for R9 being (Program of ( SCM+FSA )) holds ( ( R4 ";" R8 ) ";" R9 ) = ( R4 ";" ( R8 ";" R9 ) )))) by L365;
theorem
L372: (for R4 being (Instruction of ( SCM+FSA )) holds (for R6 being (Instruction of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds ( ( R4 ";" R8 ) ";" R6 ) = ( R4 ";" ( R8 ";" R6 ) )))) by L365;
theorem
L373: (for R4 being (Instruction of ( SCM+FSA )) holds (for R5 being (Instruction of ( SCM+FSA )) holds (for R9 being (Program of ( SCM+FSA )) holds ( ( R4 ";" R5 ) ";" R9 ) = ( R4 ";" ( R5 ";" R9 ) )))) by L365;
theorem
L374: (for R4 being (Instruction of ( SCM+FSA )) holds (for R5 being (Instruction of ( SCM+FSA )) holds (for R6 being (Instruction of ( SCM+FSA )) holds ( ( R4 ";" R5 ) ";" R6 ) = ( R4 ";" ( R5 ";" R6 ) )))) by L365;
theorem
L375: (for R4 being (Instruction of ( SCM+FSA )) holds (for R8 being (Program of ( SCM+FSA )) holds ( card ( R4 ";" R8 ) ) = ( ( card R8 ) + 2 )))
proof
let R4 being (Instruction of ( SCM+FSA ));
let R8 being (Program of ( SCM+FSA ));
thus L376: ( card ( R4 ";" R8 ) ) = ( ( card ( Macro R4 ) ) + ( card R8 ) ) by L319
.= ( ( card R8 ) + 2 ) by COMPOS_1:56;
end;
theorem
L377: (for R5 being (Instruction of ( SCM+FSA )) holds (for R7 being (Program of ( SCM+FSA )) holds ( card ( R7 ";" R5 ) ) = ( ( card R7 ) + 2 )))
proof
let R5 being (Instruction of ( SCM+FSA ));
let R7 being (Program of ( SCM+FSA ));
thus L378: ( card ( R7 ";" R5 ) ) = ( ( card ( Macro R5 ) ) + ( card R7 ) ) by L319
.= ( ( card R7 ) + 2 ) by COMPOS_1:56;
end;
theorem
L379: (for R4 being (Instruction of ( SCM+FSA )) holds (for R5 being (Instruction of ( SCM+FSA )) holds ( card ( R4 ";" R5 ) ) = 4))
proof
let R4 being (Instruction of ( SCM+FSA ));
let R5 being (Instruction of ( SCM+FSA ));
thus L380: ( card ( R4 ";" R5 ) ) = ( ( card ( Macro R4 ) ) + ( card ( Macro R5 ) ) ) by L319
.= ( ( card ( Macro R4 ) ) + 2 ) by COMPOS_1:56
.= ( 2 + 2 ) by COMPOS_1:56
.= 4;
end;
