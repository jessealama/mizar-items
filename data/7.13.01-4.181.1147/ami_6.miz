:: On the Instructions of { \bf SCM }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AMI_3, AMI_1, FSM_1, ORDINAL1, CAT_1, XBOOLE_0, FUNCT_1,
      RELAT_1, FINSEQ_1, CARD_1, AMISTD_2, GRAPHSP, CARD_3, AMISTD_1, SUBSET_1,
      CIRCUIT2, FUNCT_4, FUNCOP_1, SETFAM_1, XXREAL_0, TARSKI, ARYTM_3,
      GOBOARD5, FRECHET, ARYTM_1, INT_1, PARTFUN1, NAT_1, COMPOS_1, GOBRD13,
      MEMSTR_0;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, CARD_1,
      ORDINAL1, NUMBERS, XCMPLX_0, INT_1, FUNCOP_1, PARTFUN1, FINSEQ_1,
      FUNCT_4, XXREAL_0, VALUED_1, CARD_3, FUNCT_7, MEMSTR_0,
      COMPOS_0, COMPOS_1, EXTPRO_1, AMI_3, AMISTD_1, AMISTD_2;
 constructors NAT_D, AMI_3, AMISTD_2, RELSET_1, AMISTD_1, PRE_POLY, FUNCT_7,
      DOMAIN_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, XREAL_0, NAT_1,
      INT_1, FINSEQ_1, CARD_3, AMI_3, AMISTD_2, FUNCT_4, VALUED_0, EXTPRO_1,
      FUNCT_7, PRE_POLY, MEMSTR_0, CARD_1, COMPOS_0, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions TARSKI, AMISTD_1, AMISTD_2, XBOOLE_0, AMI_3, FUNCOP_1, COMPOS_1,
      EXTPRO_1, NAT_1, MCART_1, MEMSTR_0, COMPOS_0, XTUPLE_0;
 theorems TARSKI, NAT_1, AMI_3, FUNCT_4, AMI_5, FUNCT_1, FUNCOP_1, SETFAM_1,
      AMISTD_1, FINSEQ_1, MEMSTR_0, FUNCT_7, CARD_3, XBOOLE_0, XBOOLE_1, NAT_D,
      ORDINAL1, PARTFUN1, PBOOLE, RECDEF_2, VALUED_1, EXTPRO_1, AMI_2,
      COMPOS_0, COMPOS_1, XTUPLE_0;

begin
theorem
L1: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = ( 0 ) or R12 = 1 or R12 = 2 or R12 = 3 or R12 = 4 or R12 = 5 or R12 = 6 or R12 = 7 or R12 = 8))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
consider C1 being set such that L2: [ R12 , C1 ] in ( proj1 (the InstructionsF of ( SCM )) ) by XTUPLE_0:def 12;
consider C2 being set such that L3: [ [ R12 , C1 ] , C2 ] in (the InstructionsF of ( SCM )) by L2 , XTUPLE_0:def 12;
reconsider D1 = [ R12 , C1 , C2 ] as (Instruction of ( SCM )) by L3;
L4: R12 = ( InsCode D1 ) by RECDEF_2:def 1;
thus L5: thesis by L4 , AMI_5:5 , NAT_1:32;
end;
theorem
L6: ( JumpPart ( halt ( SCM ) ) ) = ( {} );
theorem
L7: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = ( 0 ) implies ( JumpParts R12 ) = { ( 0 ) }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
assume L8: R12 = ( 0 );
thus L9:now
let C3 being set;
assume L10: C3 in ( JumpParts R12 );
consider R8 being (Instruction of ( SCM )) such that L11: C3 = ( JumpPart R8 ) and L12: ( InsCode R8 ) = R12 by L10;
L13: R8 = ( halt ( SCM ) ) by L8 , L12 , AMI_5:7;
thus L14: C3 in { ( 0 ) } by L13 , L11 , L6 , TARSKI:def 1;
end;
let C4 being set;
assume L15: C4 in { ( 0 ) };
L16: C4 = ( 0 ) by L15 , TARSKI:def 1;
L17: ( InsCode ( halt ( SCM ) ) ) = ( 0 ) by COMPOS_1:70;
thus L18: thesis by L17 , L8 , L6 , L16;
end;
theorem
L19: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 1 implies ( JumpParts R12 ) = { ( {} ) }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
assume L20: R12 = 1;
thus L21:now
let C5 being set;
assume L22: C5 in ( JumpParts R12 );
consider C6 being (Instruction of ( SCM )) such that L23: C5 = ( JumpPart C6 ) and L24: ( InsCode C6 ) = R12 by L22;
consider R1 being Data-Location, R2 being Data-Location such that L25: C6 = ( R1 := R2 ) by L20 , L24 , AMI_5:8;
L26: C5 = ( {} ) by L23 , L25 , RECDEF_2:def 2;
thus L27: C5 in { ( {} ) } by L26 , TARSKI:def 1;
end;
set D2 = the Data-Location;
let C7 being set;
assume L28: C7 in { ( {} ) };
L29: C7 = ( {} ) by L28 , TARSKI:def 1;
L30: C7 = ( JumpPart ( D2 := D2 ) ) by L29 , RECDEF_2:def 2;
L31: ( InsCode ( D2 := D2 ) ) = 1 by RECDEF_2:def 1;
thus L32: thesis by L31 , L30 , L20;
end;
theorem
L33: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 2 implies ( JumpParts R12 ) = { ( {} ) }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
assume L34: R12 = 2;
thus L35:now
let C8 being set;
assume L36: C8 in ( JumpParts R12 );
consider C9 being (Instruction of ( SCM )) such that L37: C8 = ( JumpPart C9 ) and L38: ( InsCode C9 ) = R12 by L36;
consider R1 being Data-Location, R2 being Data-Location such that L39: C9 = ( AddTo (R1 , R2) ) by L34 , L38 , AMI_5:9;
L40: C8 = ( {} ) by L37 , L39 , RECDEF_2:def 2;
thus L41: C8 in { ( {} ) } by L40 , TARSKI:def 1;
end;
set D3 = the Data-Location;
let C10 being set;
assume L42: C10 in { ( {} ) };
L43: C10 = ( {} ) by L42 , TARSKI:def 1;
L44: C10 = ( JumpPart ( AddTo (D3 , D3) ) ) by L43 , RECDEF_2:def 2;
L45: ( InsCode ( AddTo (D3 , D3) ) ) = 2 by RECDEF_2:def 1;
thus L46: thesis by L45 , L44 , L34;
end;
theorem
L47: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 3 implies ( JumpParts R12 ) = { ( {} ) }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
assume L48: R12 = 3;
thus L49:now
let C11 being set;
assume L50: C11 in ( JumpParts R12 );
consider C12 being (Instruction of ( SCM )) such that L51: C11 = ( JumpPart C12 ) and L52: ( InsCode C12 ) = R12 by L50;
consider R1 being Data-Location, R2 being Data-Location such that L53: C12 = ( SubFrom (R1 , R2) ) by L48 , L52 , AMI_5:10;
L54: C11 = ( {} ) by L51 , L53 , RECDEF_2:def 2;
thus L55: C11 in { ( {} ) } by L54 , TARSKI:def 1;
end;
set D4 = the Data-Location;
let C13 being set;
assume L56: C13 in { ( {} ) };
L57: C13 = ( {} ) by L56 , TARSKI:def 1;
L58: C13 = ( JumpPart ( SubFrom (D4 , D4) ) ) by L57 , RECDEF_2:def 2;
L59: ( InsCode ( SubFrom (D4 , D4) ) ) = 3 by RECDEF_2:def 1;
thus L60: thesis by L59 , L58 , L48;
end;
theorem
L61: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 4 implies ( JumpParts R12 ) = { ( {} ) }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
assume L62: R12 = 4;
thus L63:now
let C14 being set;
assume L64: C14 in ( JumpParts R12 );
consider C15 being (Instruction of ( SCM )) such that L65: C14 = ( JumpPart C15 ) and L66: ( InsCode C15 ) = R12 by L64;
consider R1 being Data-Location, R2 being Data-Location such that L67: C15 = ( MultBy (R1 , R2) ) by L62 , L66 , AMI_5:11;
L68: C14 = ( {} ) by L65 , L67 , RECDEF_2:def 2;
thus L69: C14 in { ( {} ) } by L68 , TARSKI:def 1;
end;
set D5 = the Data-Location;
let C16 being set;
assume L70: C16 in { ( {} ) };
L71: C16 = ( {} ) by L70 , TARSKI:def 1;
L72: C16 = ( JumpPart ( MultBy (D5 , D5) ) ) by L71 , RECDEF_2:def 2;
L73: ( InsCode ( MultBy (D5 , D5) ) ) = 4 by RECDEF_2:def 1;
thus L74: thesis by L73 , L72 , L62;
end;
theorem
L75: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 5 implies ( JumpParts R12 ) = { ( {} ) }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
assume L76: R12 = 5;
thus L77:now
let C17 being set;
assume L78: C17 in ( JumpParts R12 );
consider C18 being (Instruction of ( SCM )) such that L79: C17 = ( JumpPart C18 ) and L80: ( InsCode C18 ) = R12 by L78;
consider R1 being Data-Location, R2 being Data-Location such that L81: C18 = ( Divide (R1 , R2) ) by L76 , L80 , AMI_5:12;
L82: C17 = ( {} ) by L79 , L81 , RECDEF_2:def 2;
thus L83: C17 in { ( {} ) } by L82 , TARSKI:def 1;
end;
set D6 = the Data-Location;
let C19 being set;
assume L84: C19 in { ( {} ) };
L85: C19 = ( {} ) by L84 , TARSKI:def 1;
L86: C19 = ( JumpPart ( Divide (D6 , D6) ) ) by L85 , RECDEF_2:def 2;
L87: ( InsCode ( Divide (D6 , D6) ) ) = 5 by RECDEF_2:def 1;
thus L88: thesis by L87 , L86 , L76;
end;
theorem
L89: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 6 implies ( dom ( product" ( JumpParts R12 ) ) ) = { 1 }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
set D7 = the (Element of ( NAT ));
assume L90: R12 = 6;
L91: ( JumpPart ( SCM-goto D7 ) ) = <* D7 *> by RECDEF_2:def 2;
thus L92:now
let C20 being set;
L93: ( InsCode ( SCM-goto D7 ) ) = 6 by RECDEF_2:def 1;
L94: ( JumpPart ( SCM-goto D7 ) ) in ( JumpParts R12 ) by L93 , L90;
assume L95: C20 in ( dom ( product" ( JumpParts R12 ) ) );
L96: C20 in ( DOM ( JumpParts R12 ) ) by L95 , CARD_3:def 12;
L97: C20 in ( dom ( JumpPart ( SCM-goto D7 ) ) ) by L96 , L94 , CARD_3:108;
thus L98: C20 in { 1 } by L97 , L91 , FINSEQ_1:2 , FINSEQ_1:def 8;
end;
let C21 being set;
assume L99: C21 in { 1 };
L100: (for B1 being Function holds (B1 in ( JumpParts R12 ) implies C21 in ( dom B1 )))
proof
let C22 being Function;
assume L101: C22 in ( JumpParts R12 );
consider C23 being (Instruction of ( SCM )) such that L102: C22 = ( JumpPart C23 ) and L103: ( InsCode C23 ) = R12 by L101;
consider R6 being (Element of ( NAT )) such that L104: C23 = ( SCM-goto R6 ) by L90 , L103 , AMI_5:13;
L105: C22 = <* R6 *> by L102 , L104 , RECDEF_2:def 2;
thus L106: thesis by L105 , L99 , FINSEQ_1:2 , FINSEQ_1:def 8;
end;
L107: C21 in ( DOM ( JumpParts R12 ) ) by L100 , CARD_3:109;
thus L108: thesis by L107 , CARD_3:def 12;
end;
theorem
L109: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 7 implies ( dom ( product" ( JumpParts R12 ) ) ) = { 1 }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
set D8 = the (Element of ( NAT ));
set D9 = the Data-Location;
assume L110: R12 = 7;
L111: ( JumpPart ( D9 =0_goto D8 ) ) = <* D8 *> by RECDEF_2:def 2;
thus L112:now
let C24 being set;
L113: ( InsCode ( D9 =0_goto D8 ) ) = 7 by RECDEF_2:def 1;
L114: ( JumpPart ( D9 =0_goto D8 ) ) in ( JumpParts R12 ) by L113 , L110;
assume L115: C24 in ( dom ( product" ( JumpParts R12 ) ) );
L116: C24 in ( DOM ( JumpParts R12 ) ) by L115 , CARD_3:def 12;
L117: C24 in ( dom ( JumpPart ( D9 =0_goto D8 ) ) ) by L116 , L114 , CARD_3:108;
thus L118: C24 in { 1 } by L117 , L111 , FINSEQ_1:2 , FINSEQ_1:38;
end;
let C25 being set;
assume L119: C25 in { 1 };
L120: (for B2 being Function holds (B2 in ( JumpParts R12 ) implies C25 in ( dom B2 )))
proof
let C26 being Function;
assume L121: C26 in ( JumpParts R12 );
consider C27 being (Instruction of ( SCM )) such that L122: C26 = ( JumpPart C27 ) and L123: ( InsCode C27 ) = R12 by L121;
consider R6 being (Element of ( NAT )), R1 being Data-Location such that L124: C27 = ( R1 =0_goto R6 ) by L110 , L123 , AMI_5:14;
L125: C26 = <* R6 *> by L122 , L124 , RECDEF_2:def 2;
thus L126: thesis by L125 , L119 , FINSEQ_1:2 , FINSEQ_1:38;
end;
L127: C25 in ( DOM ( JumpParts R12 ) ) by L120 , CARD_3:109;
thus L128: thesis by L127 , CARD_3:def 12;
end;
theorem
L129: (for R12 being (InsType of (the InstructionsF of ( SCM ))) holds (R12 = 8 implies ( dom ( product" ( JumpParts R12 ) ) ) = { 1 }))
proof
let R12 being (InsType of (the InstructionsF of ( SCM )));
set D10 = the (Element of ( NAT ));
set D11 = the Data-Location;
assume L130: R12 = 8;
L131: ( JumpPart ( D11 >0_goto D10 ) ) = <* D10 *> by RECDEF_2:def 2;
thus L132:now
let C28 being set;
L133: ( InsCode ( D11 >0_goto D10 ) ) = 8 by RECDEF_2:def 1;
L134: ( JumpPart ( D11 >0_goto D10 ) ) in ( JumpParts R12 ) by L133 , L130;
assume L135: C28 in ( dom ( product" ( JumpParts R12 ) ) );
L136: C28 in ( DOM ( JumpParts R12 ) ) by L135 , CARD_3:def 12;
L137: C28 in ( dom ( JumpPart ( D11 >0_goto D10 ) ) ) by L136 , L134 , CARD_3:108;
thus L138: C28 in { 1 } by L137 , L131 , FINSEQ_1:2 , FINSEQ_1:38;
end;
let C29 being set;
assume L139: C29 in { 1 };
L140: (for B3 being Function holds (B3 in ( JumpParts R12 ) implies C29 in ( dom B3 )))
proof
let C30 being Function;
assume L141: C30 in ( JumpParts R12 );
consider C31 being (Instruction of ( SCM )) such that L142: C30 = ( JumpPart C31 ) and L143: ( InsCode C31 ) = R12 by L141;
consider R6 being (Element of ( NAT )), R1 being Data-Location such that L144: C31 = ( R1 >0_goto R6 ) by L130 , L143 , AMI_5:15;
L145: C30 = <* R6 *> by L142 , L144 , RECDEF_2:def 2;
thus L146: thesis by L145 , L139 , FINSEQ_1:2 , FINSEQ_1:38;
end;
L147: C29 in ( DOM ( JumpParts R12 ) ) by L140 , CARD_3:109;
thus L148: thesis by L147 , CARD_3:def 12;
end;
theorem
L149: (for R14 being Nat holds ( ( product" ( JumpParts ( InsCode ( SCM-goto R14 ) ) ) ) . 1 ) = ( NAT ))
proof
let R14 being Nat;
L150: ( InsCode ( SCM-goto R14 ) ) = 6 by RECDEF_2:def 1;
L151: ( dom ( product" ( JumpParts ( InsCode ( SCM-goto R14 ) ) ) ) ) = { 1 } by L150 , L89;
L152: 1 in ( dom ( product" ( JumpParts ( InsCode ( SCM-goto R14 ) ) ) ) ) by L151 , TARSKI:def 1;
thus L153:now
let C32 being set;
assume L154: C32 in ( ( product" ( JumpParts ( InsCode ( SCM-goto R14 ) ) ) ) . 1 );
L155: C32 in ( pi (( JumpParts ( InsCode ( SCM-goto R14 ) ) ) , 1) ) by L154 , L152 , CARD_3:def 12;
consider C33 being Function such that L156: C33 in ( JumpParts ( InsCode ( SCM-goto R14 ) ) ) and L157: C32 = ( C33 . 1 ) by L155 , CARD_3:def 6;
consider C34 being (Instruction of ( SCM )) such that L158: C33 = ( JumpPart C34 ) and L159: ( InsCode C34 ) = ( InsCode ( SCM-goto R14 ) ) by L156;
L160: ( InsCode C34 ) = 6 by L159 , RECDEF_2:def 1;
consider R7 being (Element of ( NAT )) such that L161: C34 = ( SCM-goto R7 ) by L160 , AMI_5:13;
L162: C33 = <* R7 *> by L158 , L161 , RECDEF_2:def 2;
L163: C32 = R7 by L162 , L157 , FINSEQ_1:def 8;
thus L164: C32 in ( NAT ) by L163;
end;
let C35 being set;
assume L165: C35 in ( NAT );
reconsider D12 = C35 as (Element of ( NAT )) by L165;
L166: ( InsCode ( SCM-goto R14 ) ) = 6 by RECDEF_2:def 1;
L167: (( JumpPart ( SCM-goto D12 ) ) = <* D12 *> & ( InsCode ( SCM-goto R14 ) ) = ( InsCode ( SCM-goto D12 ) )) by L166 , RECDEF_2:def 1 , RECDEF_2:def 2;
L168: <* D12 *> in ( JumpParts ( InsCode ( SCM-goto R14 ) ) ) by L167;
L169: ( <* D12 *> . 1 ) = D12 by FINSEQ_1:def 8;
L170: D12 in ( pi (( JumpParts ( InsCode ( SCM-goto R14 ) ) ) , 1) ) by L169 , L168 , CARD_3:def 6;
thus L171: thesis by L170 , L152 , CARD_3:def 12;
end;
theorem
L172: (for R1 being Data-Location holds (for R14 being Nat holds ( ( product" ( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) ) . 1 ) = ( NAT )))
proof
let R1 being Data-Location;
let R14 being Nat;
L173: ( InsCode ( R1 =0_goto R14 ) ) = 7 by RECDEF_2:def 1;
L174: ( dom ( product" ( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) ) ) = { 1 } by L173 , L109;
L175: 1 in ( dom ( product" ( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) ) ) by L174 , TARSKI:def 1;
thus L176:now
let C36 being set;
assume L177: C36 in ( ( product" ( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) ) . 1 );
L178: C36 in ( pi (( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) , 1) ) by L177 , L175 , CARD_3:def 12;
consider C37 being Function such that L179: C37 in ( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) and L180: C36 = ( C37 . 1 ) by L178 , CARD_3:def 6;
consider C38 being (Instruction of ( SCM )) such that L181: C37 = ( JumpPart C38 ) and L182: ( InsCode C38 ) = ( InsCode ( R1 =0_goto R14 ) ) by L179;
L183: ( InsCode C38 ) = 7 by L182 , RECDEF_2:def 1;
consider R7 being (Element of ( NAT )), R2 being Data-Location such that L184: C38 = ( R2 =0_goto R7 ) by L183 , AMI_5:14;
L185: C37 = <* R7 *> by L181 , L184 , RECDEF_2:def 2;
L186: C36 = R7 by L185 , L180 , FINSEQ_1:40;
thus L187: C36 in ( NAT ) by L186;
end;
let C39 being set;
assume L188: C39 in ( NAT );
reconsider D13 = C39 as (Element of ( NAT )) by L188;
L189: ( InsCode ( R1 =0_goto R14 ) ) = 7 by RECDEF_2:def 1;
L190: (( JumpPart ( R1 =0_goto D13 ) ) = <* D13 *> & ( InsCode ( R1 =0_goto R14 ) ) = ( InsCode ( R1 =0_goto D13 ) )) by L189 , RECDEF_2:def 1 , RECDEF_2:def 2;
L191: <* D13 *> in ( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) by L190;
L192: ( <* D13 *> . 1 ) = D13 by FINSEQ_1:40;
L193: D13 in ( pi (( JumpParts ( InsCode ( R1 =0_goto R14 ) ) ) , 1) ) by L192 , L191 , CARD_3:def 6;
thus L194: thesis by L193 , L175 , CARD_3:def 12;
end;
theorem
L195: (for R1 being Data-Location holds (for R14 being Nat holds ( ( product" ( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) ) . 1 ) = ( NAT )))
proof
let R1 being Data-Location;
let R14 being Nat;
L196: ( InsCode ( R1 >0_goto R14 ) ) = 8 by RECDEF_2:def 1;
L197: ( dom ( product" ( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) ) ) = { 1 } by L196 , L129;
L198: 1 in ( dom ( product" ( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) ) ) by L197 , TARSKI:def 1;
thus L199:now
let C40 being set;
assume L200: C40 in ( ( product" ( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) ) . 1 );
L201: C40 in ( pi (( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) , 1) ) by L200 , L198 , CARD_3:def 12;
consider C41 being Function such that L202: C41 in ( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) and L203: C40 = ( C41 . 1 ) by L201 , CARD_3:def 6;
consider C42 being (Instruction of ( SCM )) such that L204: C41 = ( JumpPart C42 ) and L205: ( InsCode C42 ) = ( InsCode ( R1 >0_goto R14 ) ) by L202;
L206: ( InsCode C42 ) = 8 by L205 , RECDEF_2:def 1;
consider R7 being (Element of ( NAT )), R2 being Data-Location such that L207: C42 = ( R2 >0_goto R7 ) by L206 , AMI_5:15;
L208: C41 = <* R7 *> by L204 , L207 , RECDEF_2:def 2;
L209: C40 = R7 by L208 , L203 , FINSEQ_1:40;
thus L210: C40 in ( NAT ) by L209;
end;
let C43 being set;
assume L211: C43 in ( NAT );
reconsider D14 = C43 as (Element of ( NAT )) by L211;
L212: ( InsCode ( R1 >0_goto R14 ) ) = 8 by RECDEF_2:def 1;
L213: (( JumpPart ( R1 >0_goto D14 ) ) = <* D14 *> & ( InsCode ( R1 >0_goto R14 ) ) = ( InsCode ( R1 >0_goto D14 ) )) by L212 , RECDEF_2:def 1 , RECDEF_2:def 2;
L214: <* D14 *> in ( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) by L213;
L215: ( <* D14 *> . 1 ) = D14 by FINSEQ_1:40;
L216: D14 in ( pi (( JumpParts ( InsCode ( R1 >0_goto R14 ) ) ) , 1) ) by L215 , L214 , CARD_3:def 6;
thus L217: thesis by L216 , L198 , CARD_3:def 12;
end;
L218: (for B4 being (Instruction of ( SCM )) holds ((for B5 being (Element of ( NAT )) holds ( NIC (B4 , B5) ) = { ( succ B5 ) }) implies ( JUMP B4 ) is  empty))
proof
set D15 = 1;
set D16 = 2;
let C44 being (Instruction of ( SCM ));
assume L219: (for B6 being (Element of ( NAT )) holds ( NIC (C44 , B6) ) = { ( succ B6 ) });
set D17 = { ( NIC (C44 , B7) ) where B7 is (Element of ( NAT )) : (not contradiction) };
reconsider D18 = D15 , D19 = D16 as (Element of ( NAT ));
assume L220: (not thesis);
consider C45 being set such that L221: C45 in ( meet D17 ) by L220 , XBOOLE_0:def 1;
L222: ( NIC (C44 , D18) ) = { ( succ D18 ) } by L219;
L223: { ( succ D18 ) } in D17 by L222;
L224: C45 in { ( succ D18 ) } by L223 , L221 , SETFAM_1:def 1;
L225: C45 = ( succ D18 ) by L224 , TARSKI:def 1;
L226: ( NIC (C44 , D19) ) = { ( succ D19 ) } by L219;
L227: { ( succ D19 ) } in D17 by L226;
L228: C45 in { ( succ D19 ) } by L227 , L221 , SETFAM_1:def 1;
thus L229: contradiction by L228 , L225 , TARSKI:def 1;
end;
registration
cluster ( JUMP ( halt ( SCM ) ) ) ->  empty;
coherence;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( R1 := R2 ) ->  sequential;
coherence
proof
let C46 being (State of ( SCM ));
thus L231: thesis by AMI_3:2;
end;
cluster ( AddTo (R1 , R2) ) ->  sequential;
coherence
proof
let C47 being (State of ( SCM ));
thus L232: thesis by AMI_3:3;
end;
cluster ( SubFrom (R1 , R2) ) ->  sequential;
coherence
proof
let C48 being (State of ( SCM ));
thus L233: thesis by AMI_3:4;
end;
cluster ( MultBy (R1 , R2) ) ->  sequential;
coherence
proof
let C49 being (State of ( SCM ));
thus L234: thesis by AMI_3:5;
end;
cluster ( Divide (R1 , R2) ) ->  sequential;
coherence
proof
let C50 being (State of ( SCM ));
thus L235: thesis by AMI_3:6;
end;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( JUMP ( R1 := R2 ) ) ->  empty;
coherence
proof
L237: (for B8 being (Element of ( NAT )) holds ( NIC (( R1 := R2 ) , B8) ) = { ( succ B8 ) }) by AMISTD_1:12;
thus L238: thesis by L237 , L218;
end;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( JUMP ( AddTo (R1 , R2) ) ) ->  empty;
coherence
proof
L240: (for B9 being (Element of ( NAT )) holds ( NIC (( AddTo (R1 , R2) ) , B9) ) = { ( succ B9 ) }) by AMISTD_1:12;
thus L241: thesis by L240 , L218;
end;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( JUMP ( SubFrom (R1 , R2) ) ) ->  empty;
coherence
proof
L243: (for B10 being (Element of ( NAT )) holds ( NIC (( SubFrom (R1 , R2) ) , B10) ) = { ( succ B10 ) }) by AMISTD_1:12;
thus L244: thesis by L243 , L218;
end;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( JUMP ( MultBy (R1 , R2) ) ) ->  empty;
coherence
proof
L246: (for B11 being (Element of ( NAT )) holds ( NIC (( MultBy (R1 , R2) ) , B11) ) = { ( succ B11 ) }) by AMISTD_1:12;
thus L247: thesis by L246 , L218;
end;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( JUMP ( Divide (R1 , R2) ) ) ->  empty;
coherence
proof
L249: (for B12 being (Element of ( NAT )) holds ( NIC (( Divide (R1 , R2) ) , B12) ) = { ( succ B12 ) }) by AMISTD_1:12;
thus L250: thesis by L249 , L218;
end;
end;
theorem
L252: (for R5 being (Element of ( NAT )) holds (for R13 being Nat holds ( NIC (( SCM-goto R13 ) , R5) ) = { R13 }))
proof
let R5 being (Element of ( NAT ));
let R13 being Nat;
L253:
now
let C51 being set;
L254:
now
reconsider D20 = R5 as (Element of ( Values ( IC ( SCM ) ) )) by MEMSTR_0:def 6;
set D21 = ( SCM-goto R13 );
set D22 = the (State of ( SCM ));
set D23 = the (Instruction-Sequence of ( SCM ));
assume L255: C51 = R13;
reconsider D24 = R5 as (Element of ( NAT ));
reconsider D25 = ( D22 +* (( IC ( SCM ) ) , D20) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
reconsider D26 = ( D23 +* (R5 , D21) ) as (Instruction-Sequence of ( SCM ));
L256: ( D26 /. R5 ) = ( D26 . R5 ) by PBOOLE:143;
L257: ( IC ( SCM ) ) in ( dom D22 ) by MEMSTR_0:2;
L258: ( IC D25 ) = D24 by L257 , FUNCT_7:31;
L259: R5 in ( NAT );
L260: R5 in ( dom D23 ) by L259 , PARTFUN1:def 2;
L261: ( D26 . D24 ) = D21 by L260 , FUNCT_7:31;
L262: ( IC ( Following (D26 , D25) ) ) = R13 by L261 , L256 , L258 , AMI_3:7;
thus L263: C51 in { ( IC ( Exec (( SCM-goto R13 ) , B13) ) ) where B13 is (Element of ( product ( the_Values_of ( SCM ) ) )) : ( IC B13 ) = R5 } by L262 , L255 , L258 , L256 , L261;
end;
L264:
now
assume L265: C51 in { ( IC ( Exec (( SCM-goto R13 ) , B14) ) ) where B14 is (Element of ( product ( the_Values_of ( SCM ) ) )) : ( IC B14 ) = R5 };
L266: (ex B15 being (Element of ( product ( the_Values_of ( SCM ) ) )) st (C51 = ( IC ( Exec (( SCM-goto R13 ) , B15) ) ) & ( IC B15 ) = R5)) by L265;
thus L267: C51 = R13 by L266 , AMI_3:7;
end;
thus L268: (C51 in { R13 } iff C51 in { ( IC ( Exec (( SCM-goto R13 ) , B16) ) ) where B16 is (Element of ( product ( the_Values_of ( SCM ) ) )) : ( IC B16 ) = R5 }) by L264 , L254 , TARSKI:def 1;
end;
thus L269: thesis by L253 , TARSKI:1;
end;
theorem
L270: (for R13 being Nat holds ( JUMP ( SCM-goto R13 ) ) = { R13 })
proof
let R13 being Nat;
set D27 = { ( NIC (( SCM-goto R13 ) , R5) ) where R5 is (Element of ( NAT )) : (not contradiction) };
L271:
now
let C52 being set;
thus L272:now
set D28 = 1;
L273: ( NIC (( SCM-goto R13 ) , D28) ) in D27;
assume L274: C52 in ( meet D27 );
L275: C52 in ( NIC (( SCM-goto R13 ) , D28) ) by L274 , L273 , SETFAM_1:def 1;
thus L276: C52 in { R13 } by L275 , L252;
end;
assume L277: C52 in { R13 };
L278: C52 = R13 by L277 , TARSKI:def 1;
L279:
now
let C53 being set;
assume L280: C53 in D27;
consider C54 being (Element of ( NAT )) such that L281: C53 = ( NIC (( SCM-goto R13 ) , C54) ) by L280;
L282: ( NIC (( SCM-goto R13 ) , C54) ) = { R13 } by L252;
thus L283: R13 in C53 by L282 , L281 , TARSKI:def 1;
end;
reconsider D29 = R13 as (Element of ( NAT )) by ORDINAL1:def 12;
L284: ( NIC (( SCM-goto D29 ) , D29) ) in D27;
thus L285: C52 in ( meet D27 ) by L284 , L278 , L279 , SETFAM_1:def 1;
end;
thus L286: thesis by L271 , TARSKI:1;
end;
registration
let R6 being (Element of ( NAT ));
cluster ( JUMP ( SCM-goto R6 ) ) -> 1 -element;
coherence
proof
L287: ( JUMP ( SCM-goto R6 ) ) = { R6 } by L270;
thus L288: thesis by L287;
end;
end;
theorem
L290: (for R1 being Data-Location holds (for R5 being (Element of ( NAT )) holds (for R13 being Nat holds ( NIC (( R1 =0_goto R13 ) , R5) ) = { R13 , ( succ R5 ) })))
proof
let R1 being Data-Location;
let R5 being (Element of ( NAT ));
let R13 being Nat;
set D30 = the (State of ( SCM ));
set D31 = the (Instruction-Sequence of ( SCM ));
thus L291:now
let C55 being set;
assume L292: C55 in ( NIC (( R1 =0_goto R13 ) , R5) );
consider C56 being (Element of ( product ( the_Values_of ( SCM ) ) )) such that L293: (C55 = ( IC ( Exec (( R1 =0_goto R13 ) , C56) ) ) & ( IC C56 ) = R5) by L292;
per cases ;
suppose L294: ( C56 . R1 ) = ( 0 );

L295: C55 = R13 by L294 , L293 , AMI_3:8;
thus L296: C55 in { R13 , ( succ R5 ) } by L295 , TARSKI:def 2;
end;
suppose L297: ( C56 . R1 ) <> ( 0 );

L298: C55 = ( succ R5 ) by L297 , L293 , AMI_3:8;
thus L299: C55 in { R13 , ( succ R5 ) } by L298 , TARSKI:def 2;
end;
end;
let C57 being set;
set D32 = ( R1 =0_goto R13 );
L301: ( IC ( SCM ) ) <> R1 by AMI_5:2;
reconsider D33 = R5 as (Element of ( Values ( IC ( SCM ) ) )) by MEMSTR_0:def 6;
reconsider D34 = R5 as (Element of ( NAT ));
reconsider D35 = ( D30 +* (( IC ( SCM ) ) , D33) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
reconsider D36 = ( D31 +* (R5 , D32) ) as (Instruction-Sequence of ( SCM ));
assume L302: C57 in { R13 , ( succ R5 ) };
per cases  by L302 , TARSKI:def 2;
suppose L303: C57 = R13;

reconsider D37 = ( D35 +* ( R1 .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
L304: ( IC ( SCM ) ) in ( dom D30 ) by MEMSTR_0:2;
L305: ( dom ( R1 .--> ( 0 ) ) ) = { R1 } by FUNCOP_1:13;
L306: (not ( IC ( SCM ) ) in ( dom ( R1 .--> ( 0 ) ) )) by L305 , L301 , TARSKI:def 1;
L307: ( IC D37 ) = ( IC D35 ) by L306 , FUNCT_4:11
.= D34 by L304 , FUNCT_7:31;
L308: ( D36 /. R5 ) = ( D36 . R5 ) by PBOOLE:143;
L309: R5 in ( NAT );
L310: R5 in ( dom D31 ) by L309 , PARTFUN1:def 2;
L311: ( D36 . R5 ) = D32 by L310 , FUNCT_7:31;
L312: R1 in ( dom ( R1 .--> ( 0 ) ) ) by L305 , TARSKI:def 1;
L313: ( D37 . R1 ) = ( ( R1 .--> ( 0 ) ) . R1 ) by L312 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L314: ( IC ( Following (D36 , D37) ) ) = R13 by L313 , L307 , L311 , L308 , AMI_3:8;
thus L315: thesis by L314 , L303 , L307 , L311 , L308;
end;
suppose L316: C57 = ( succ R5 );

reconsider D38 = ( D35 +* ( R1 .--> 1 ) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
L317: ( IC ( SCM ) ) in ( dom D30 ) by MEMSTR_0:2;
L318: ( dom ( R1 .--> 1 ) ) = { R1 } by FUNCOP_1:13;
L319: (not ( IC ( SCM ) ) in ( dom ( R1 .--> 1 ) )) by L318 , L301 , TARSKI:def 1;
L320: ( IC D38 ) = ( IC D35 ) by L319 , FUNCT_4:11
.= D34 by L317 , FUNCT_7:31;
L321: ( D36 /. R5 ) = ( D36 . R5 ) by PBOOLE:143;
L322: R5 in ( NAT );
L323: R5 in ( dom D31 ) by L322 , PARTFUN1:def 2;
L324: ( D36 . R5 ) = D32 by L323 , FUNCT_7:31;
L325: R1 in ( dom ( R1 .--> 1 ) ) by L318 , TARSKI:def 1;
L326: ( D38 . R1 ) = ( ( R1 .--> 1 ) . R1 ) by L325 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L327: ( IC ( Following (D36 , D38) ) ) = ( succ R5 ) by L326 , L320 , L324 , L321 , AMI_3:8;
thus L328: thesis by L327 , L316 , L320 , L324 , L321;
end;
end;
theorem
L330: (for R1 being Data-Location holds (for R13 being Nat holds ( JUMP ( R1 =0_goto R13 ) ) = { R13 }))
proof
let R1 being Data-Location;
let R13 being Nat;
set D39 = { ( NIC (( R1 =0_goto R13 ) , R5) ) where R5 is (Element of ( NAT )) : (not contradiction) };
L331:
now
let C58 being set;
L332:
now
let C59 being set;
assume L333: C59 in D39;
consider C60 being (Element of ( NAT )) such that L334: C59 = ( NIC (( R1 =0_goto R13 ) , C60) ) by L333;
L335: ( NIC (( R1 =0_goto R13 ) , C60) ) = { R13 , ( succ C60 ) } by L290;
thus L336: R13 in C59 by L335 , L334 , TARSKI:def 2;
end;
thus L337:now
set D40 = 1;
set D41 = 2;
assume L338: C58 in ( meet D39 );
L339: ( NIC (( R1 =0_goto R13 ) , D41) ) = { R13 , ( succ D41 ) } by L290;
L340: ( NIC (( R1 =0_goto R13 ) , D41) ) in D39;
L341: C58 in ( NIC (( R1 =0_goto R13 ) , D41) ) by L340 , L338 , SETFAM_1:def 1;
L342: (C58 = R13 or C58 = ( succ D41 )) by L341 , L339 , TARSKI:def 2;
L343: ( NIC (( R1 =0_goto R13 ) , D40) ) = { R13 , ( succ D40 ) } by L290;
L344: ( NIC (( R1 =0_goto R13 ) , D40) ) in D39;
L345: C58 in ( NIC (( R1 =0_goto R13 ) , D40) ) by L344 , L338 , SETFAM_1:def 1;
L346: (C58 = R13 or C58 = ( succ D40 )) by L345 , L343 , TARSKI:def 2;
thus L347: C58 in { R13 } by L346 , L342 , TARSKI:def 1;
end;
assume L348: C58 in { R13 };
L349: C58 = R13 by L348 , TARSKI:def 1;
reconsider D42 = R13 as (Element of ( NAT )) by ORDINAL1:def 12;
L350: ( NIC (( R1 =0_goto D42 ) , D42) ) in D39;
thus L351: C58 in ( meet D39 ) by L350 , L349 , L332 , SETFAM_1:def 1;
end;
thus L352: thesis by L331 , TARSKI:1;
end;
registration
let R1 being Data-Location;
let R6 being (Element of ( NAT ));
cluster ( JUMP ( R1 =0_goto R6 ) ) -> 1 -element;
coherence
proof
L353: ( JUMP ( R1 =0_goto R6 ) ) = { R6 } by L330;
thus L354: thesis by L353;
end;
end;
theorem
L356: (for R1 being Data-Location holds (for R5 being (Element of ( NAT )) holds (for R13 being Nat holds ( NIC (( R1 >0_goto R13 ) , R5) ) = { R13 , ( succ R5 ) })))
proof
let R1 being Data-Location;
let R5 being (Element of ( NAT ));
let R13 being Nat;
set D43 = the (State of ( SCM ));
set D44 = the (Instruction-Sequence of ( SCM ));
thus L357:now
let C61 being set;
assume L358: C61 in ( NIC (( R1 >0_goto R13 ) , R5) );
consider C62 being (Element of ( product ( the_Values_of ( SCM ) ) )) such that L359: (C61 = ( IC ( Exec (( R1 >0_goto R13 ) , C62) ) ) & ( IC C62 ) = R5) by L358;
per cases ;
suppose L360: ( C62 . R1 ) > ( 0 );

L361: C61 = R13 by L360 , L359 , AMI_3:9;
thus L362: C61 in { R13 , ( succ R5 ) } by L361 , TARSKI:def 2;
end;
suppose L363: ( C62 . R1 ) <= ( 0 );

L364: C61 = ( succ R5 ) by L363 , L359 , AMI_3:9;
thus L365: C61 in { R13 , ( succ R5 ) } by L364 , TARSKI:def 2;
end;
end;
let C63 being set;
set D45 = ( R1 >0_goto R13 );
L367: ( IC ( SCM ) ) <> R1 by AMI_5:2;
reconsider D46 = R5 as (Element of ( Values ( IC ( SCM ) ) )) by MEMSTR_0:def 6;
reconsider D47 = ( D43 +* (( IC ( SCM ) ) , D46) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
reconsider D48 = ( D44 +* (R5 , D45) ) as (Instruction-Sequence of ( SCM ));
reconsider D49 = D46 as (Element of ( NAT ));
assume L368: C63 in { R13 , ( succ R5 ) };
per cases  by L368 , TARSKI:def 2;
suppose L369: C63 = R13;

reconsider D50 = ( D47 +* ( R1 .--> 1 ) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
L370: ( IC ( SCM ) ) in ( dom D43 ) by MEMSTR_0:2;
L371: ( dom ( R1 .--> 1 ) ) = { R1 } by FUNCOP_1:13;
L372: (not ( IC ( SCM ) ) in ( dom ( R1 .--> 1 ) )) by L371 , L367 , TARSKI:def 1;
L373: ( IC D50 ) = ( IC D47 ) by L372 , FUNCT_4:11
.= D49 by L370 , FUNCT_7:31;
L374: ( D48 /. R5 ) = ( D48 . R5 ) by PBOOLE:143;
L375: R5 in ( NAT );
L376: R5 in ( dom D44 ) by L375 , PARTFUN1:def 2;
L377: ( D48 . R5 ) = D45 by L376 , FUNCT_7:31;
L378: R1 in ( dom ( R1 .--> 1 ) ) by L371 , TARSKI:def 1;
L379: ( D50 . R1 ) = ( ( R1 .--> 1 ) . R1 ) by L378 , FUNCT_4:13
.= 1 by FUNCOP_1:72;
L380: ( IC ( Following (D48 , D50) ) ) = R13 by L379 , L373 , L377 , L374 , AMI_3:9;
thus L381: thesis by L380 , L369 , L373 , L377 , L374;
end;
suppose L382: C63 = ( succ R5 );

reconsider D51 = ( D47 +* ( R1 .--> ( 0 ) ) ) as (Element of ( product ( the_Values_of ( SCM ) ) )) by CARD_3:107;
L383: ( IC ( SCM ) ) in ( dom D43 ) by MEMSTR_0:2;
L384: ( dom ( R1 .--> ( 0 ) ) ) = { R1 } by FUNCOP_1:13;
L385: (not ( IC ( SCM ) ) in ( dom ( R1 .--> ( 0 ) ) )) by L384 , L367 , TARSKI:def 1;
L386: ( IC D51 ) = ( IC D47 ) by L385 , FUNCT_4:11
.= D49 by L383 , FUNCT_7:31;
L387: ( D48 /. R5 ) = ( D48 . R5 ) by PBOOLE:143;
L388: R5 in ( NAT );
L389: R5 in ( dom D44 ) by L388 , PARTFUN1:def 2;
L390: ( D48 . R5 ) = D45 by L389 , FUNCT_7:31;
L391: R1 in ( dom ( R1 .--> ( 0 ) ) ) by L384 , TARSKI:def 1;
L392: ( D51 . R1 ) = ( ( R1 .--> ( 0 ) ) . R1 ) by L391 , FUNCT_4:13
.= ( 0 ) by FUNCOP_1:72;
L393: ( IC ( Following (D48 , D51) ) ) = ( succ R5 ) by L392 , L386 , L390 , L387 , AMI_3:9;
thus L394: thesis by L393 , L382 , L386 , L390 , L387;
end;
end;
theorem
L396: (for R1 being Data-Location holds (for R13 being Nat holds ( JUMP ( R1 >0_goto R13 ) ) = { R13 }))
proof
let R1 being Data-Location;
let R13 being Nat;
set D52 = { ( NIC (( R1 >0_goto R13 ) , R5) ) where R5 is (Element of ( NAT )) : (not contradiction) };
L397:
now
let C64 being set;
L398:
now
let C65 being set;
assume L399: C65 in D52;
consider C66 being (Element of ( NAT )) such that L400: C65 = ( NIC (( R1 >0_goto R13 ) , C66) ) by L399;
L401: ( NIC (( R1 >0_goto R13 ) , C66) ) = { R13 , ( succ C66 ) } by L356;
thus L402: R13 in C65 by L401 , L400 , TARSKI:def 2;
end;
thus L403:now
set D53 = 1;
set D54 = 2;
assume L404: C64 in ( meet D52 );
L405: ( NIC (( R1 >0_goto R13 ) , D54) ) = { R13 , ( succ D54 ) } by L356;
L406: ( NIC (( R1 >0_goto R13 ) , D54) ) in D52;
L407: C64 in ( NIC (( R1 >0_goto R13 ) , D54) ) by L406 , L404 , SETFAM_1:def 1;
L408: (C64 = R13 or C64 = ( succ D54 )) by L407 , L405 , TARSKI:def 2;
L409: ( NIC (( R1 >0_goto R13 ) , D53) ) = { R13 , ( succ D53 ) } by L356;
L410: ( NIC (( R1 >0_goto R13 ) , D53) ) in D52;
L411: C64 in ( NIC (( R1 >0_goto R13 ) , D53) ) by L410 , L404 , SETFAM_1:def 1;
L412: (C64 = R13 or C64 = ( succ D53 )) by L411 , L409 , TARSKI:def 2;
thus L413: C64 in { R13 } by L412 , L408 , TARSKI:def 1;
end;
assume L414: C64 in { R13 };
L415: C64 = R13 by L414 , TARSKI:def 1;
reconsider D55 = R13 as (Element of ( NAT )) by ORDINAL1:def 12;
L416: ( NIC (( R1 >0_goto D55 ) , D55) ) in D52;
thus L417: C64 in ( meet D52 ) by L416 , L415 , L398 , SETFAM_1:def 1;
end;
thus L418: thesis by L397 , TARSKI:1;
end;
registration
let R1 being Data-Location;
let R6 being (Element of ( NAT ));
cluster ( JUMP ( R1 >0_goto R6 ) ) -> 1 -element;
coherence
proof
L419: ( JUMP ( R1 >0_goto R6 ) ) = { R6 } by L396;
thus L420: thesis by L419;
end;
end;
theorem
L422: (for R5 being (Element of ( NAT )) holds ( SUCC (R5 , ( SCM )) ) = { R5 , ( succ R5 ) })
proof
let R5 being (Element of ( NAT ));
set D56 = { ( ( NIC (B17 , R5) ) \ ( JUMP B17 ) ) where B17 is (Element of (the InstructionsF of ( SCM ))) : (not contradiction) };
set D57 = { R5 , ( succ R5 ) };
L423:
now
let C67 being set;
thus L424:now
assume L425: C67 in ( union D56 );
consider C68 being set such that L426: C67 in C68 and L427: C68 in D56 by L425 , TARSKI:def 4;
consider C69 being (Element of (the InstructionsF of ( SCM ))) such that L428: C68 = ( ( NIC (C69 , R5) ) \ ( JUMP C69 ) ) by L427;
per cases  by AMI_3:24;
suppose L429: C69 = [ ( 0 ) , ( {} ) , ( {} ) ];

L430: C67 in ( { R5 } \ ( JUMP ( halt ( SCM ) ) ) ) by L429 , L426 , L428 , AMISTD_1:2;
L431: C67 = R5 by L430 , TARSKI:def 1;
thus L432: C67 in D57 by L431 , TARSKI:def 2;
end;
suppose L433: (ex R1 being Data-Location st (ex R2 being Data-Location st C69 = ( R1 := R2 )));

consider R1 being Data-Location, R2 being Data-Location such that L434: C69 = ( R1 := R2 ) by L433;
L435: C67 in ( { ( succ R5 ) } \ ( JUMP ( R1 := R2 ) ) ) by L426 , L428 , L434 , AMISTD_1:12;
L436: C67 = ( succ R5 ) by L435 , TARSKI:def 1;
thus L437: C67 in D57 by L436 , TARSKI:def 2;
end;
suppose L438: (ex R1 being Data-Location st (ex R2 being Data-Location st C69 = ( AddTo (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L439: C69 = ( AddTo (R1 , R2) ) by L438;
L440: C67 in ( { ( succ R5 ) } \ ( JUMP ( AddTo (R1 , R2) ) ) ) by L426 , L428 , L439 , AMISTD_1:12;
L441: C67 = ( succ R5 ) by L440 , TARSKI:def 1;
thus L442: C67 in D57 by L441 , TARSKI:def 2;
end;
suppose L443: (ex R1 being Data-Location st (ex R2 being Data-Location st C69 = ( SubFrom (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L444: C69 = ( SubFrom (R1 , R2) ) by L443;
L445: C67 in ( { ( succ R5 ) } \ ( JUMP ( SubFrom (R1 , R2) ) ) ) by L426 , L428 , L444 , AMISTD_1:12;
L446: C67 = ( succ R5 ) by L445 , TARSKI:def 1;
thus L447: C67 in D57 by L446 , TARSKI:def 2;
end;
suppose L448: (ex R1 being Data-Location st (ex R2 being Data-Location st C69 = ( MultBy (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L449: C69 = ( MultBy (R1 , R2) ) by L448;
L450: C67 in ( { ( succ R5 ) } \ ( JUMP ( MultBy (R1 , R2) ) ) ) by L426 , L428 , L449 , AMISTD_1:12;
L451: C67 = ( succ R5 ) by L450 , TARSKI:def 1;
thus L452: C67 in D57 by L451 , TARSKI:def 2;
end;
suppose L453: (ex R1 being Data-Location st (ex R2 being Data-Location st C69 = ( Divide (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L454: C69 = ( Divide (R1 , R2) ) by L453;
L455: C67 in ( { ( succ R5 ) } \ ( JUMP ( Divide (R1 , R2) ) ) ) by L426 , L428 , L454 , AMISTD_1:12;
L456: C67 = ( succ R5 ) by L455 , TARSKI:def 1;
thus L457: C67 in D57 by L456 , TARSKI:def 2;
end;
suppose L458: (ex R13 being Nat st C69 = ( SCM-goto R13 ));

consider R13 being Nat such that L459: C69 = ( SCM-goto R13 ) by L458;
L460: C67 in ( { R13 } \ ( JUMP C69 ) ) by L426 , L428 , L459 , L252;
L461: C67 in ( { R13 } \ { R13 } ) by L460 , L459 , L270;
thus L462: C67 in D57 by L461 , XBOOLE_1:37;
end;
suppose L463: (ex R1 being Data-Location st (ex R13 being Nat st C69 = ( R1 =0_goto R13 )));

consider R1 being Data-Location, R13 being Nat such that L464: C69 = ( R1 =0_goto R13 ) by L463;
L465: ( NIC (C69 , R5) ) = { R13 , ( succ R5 ) } by L464 , L290;
L466: C67 in ( NIC (C69 , R5) ) by L426 , L428 , XBOOLE_0:def 5;
L467: (C67 = R13 or C67 = ( succ R5 )) by L466 , L465 , TARSKI:def 2;
L468: C67 in ( ( NIC (C69 , R5) ) \ { R13 } ) by L426 , L428 , L464 , L330;
L469: (not C67 in { R13 }) by L468 , XBOOLE_0:def 5;
thus L470: C67 in D57 by L469 , L467 , TARSKI:def 1 , TARSKI:def 2;
end;
suppose L471: (ex R1 being Data-Location st (ex R13 being Nat st C69 = ( R1 >0_goto R13 )));

consider R1 being Data-Location, R13 being Nat such that L472: C69 = ( R1 >0_goto R13 ) by L471;
L473: ( NIC (C69 , R5) ) = { R13 , ( succ R5 ) } by L472 , L356;
L474: C67 in ( NIC (C69 , R5) ) by L426 , L428 , XBOOLE_0:def 5;
L475: (C67 = R13 or C67 = ( succ R5 )) by L474 , L473 , TARSKI:def 2;
L476: C67 in ( ( NIC (C69 , R5) ) \ { R13 } ) by L426 , L428 , L472 , L396;
L477: (not C67 in { R13 }) by L476 , XBOOLE_0:def 5;
thus L478: C67 in D57 by L477 , L475 , TARSKI:def 1 , TARSKI:def 2;
end;
end;
assume L480: C67 in { R5 , ( succ R5 ) };
per cases  by L480 , TARSKI:def 2;
suppose L481: C67 = R5;

set D58 = ( halt ( SCM ) );
L482: ( ( NIC (D58 , R5) ) \ ( JUMP D58 ) ) = { R5 } by AMISTD_1:2;
L483: { R5 } in D56 by L482;
L484: C67 in { R5 } by L481 , TARSKI:def 1;
thus L485: C67 in ( union D56 ) by L484 , L483 , TARSKI:def 4;
end;
suppose L486: C67 = ( succ R5 );

set D59 = the Data-Location;
set D60 = ( AddTo (D59 , D59) );
L487: ( ( NIC (D60 , R5) ) \ ( JUMP D60 ) ) = { ( succ R5 ) } by AMISTD_1:12;
L488: { ( succ R5 ) } in D56 by L487;
L489: C67 in { ( succ R5 ) } by L486 , TARSKI:def 1;
thus L490: C67 in ( union D56 ) by L489 , L488 , TARSKI:def 4;
end;
end;
thus L492: thesis by L423 , TARSKI:1;
end;
theorem
L493: (for B18 being (Element of ( NAT )) holds (( B18 + 1 ) in ( SUCC (B18 , ( SCM )) ) & (for B19 being (Element of ( NAT )) holds (B19 in ( SUCC (B18 , ( SCM )) ) implies B18 <= B19))))
proof
let C70 being (Element of ( NAT ));
reconsider D61 = C70 as (Element of ( NAT ));
L494: ( SUCC (C70 , ( SCM )) ) = { C70 , ( succ D61 ) } by L422;
thus L495: ( C70 + 1 ) in ( SUCC (C70 , ( SCM )) ) by L494 , TARSKI:def 2;
let C71 being (Element of ( NAT ));
assume L496: C71 in ( SUCC (C70 , ( SCM )) );
reconsider D62 = C70 as (Element of ( NAT ));
per cases  by L494 , L496 , TARSKI:def 2;
suppose L497: C71 = C70;

thus L498: thesis by L497;
end;
suppose L499: C71 = ( succ D62 );

thus L500: thesis by L499 , NAT_1:11;
end;
end;
registration
cluster ( SCM ) ->  standard;
coherence by L493 , AMISTD_1:3;
end;
registration
cluster ( InsCode ( halt ( SCM ) ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
L503:
now
let C72 being (State of ( SCM ));
let C73 being (Object of ( SCM ));
let C74 being (Instruction of ( SCM ));
assume that
L504: ( InsCode C74 ) = ( InsCode ( halt ( SCM ) ) )
and
L505: C73 in ( Data-Locations ( SCM ) );
L506: C74 = ( halt ( SCM ) ) by L504 , AMI_5:7 , COMPOS_1:70;
thus L507: ( ( Exec (C74 , C72) ) . C73 ) = ( C72 . C73 ) by L506 , EXTPRO_1:def 3;
end;
thus L508: thesis by L503 , AMISTD_1:def 1;
end;
end;
registration
cluster ( halt ( SCM ) ) ->  jump-only;
coherence
proof
thus L510: ( InsCode ( halt ( SCM ) ) ) is  jump-only;
end;
end;
registration
let R6 being (Element of ( NAT ));
cluster ( InsCode ( SCM-goto R6 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
let C75 being (InsType of (the InstructionsF of ( SCM )));
assume that
L512: C75 = ( InsCode ( SCM-goto R6 ) );
let C76 being (State of ( SCM ));
let C77 being (Object of ( SCM ));
let C78 being (Instruction of ( SCM ));
assume that
L513: ( InsCode C78 ) = C75
and
L514: C77 in ( Data-Locations ( SCM ) );
L515: ( InsCode C78 ) = 6 by L513 , L512 , RECDEF_2:def 1;
L516: (ex R7 being (Element of ( NAT )) st C78 = ( SCM-goto R7 )) by L515 , AMI_5:13;
L517: C77 is Data-Location by L514 , AMI_2:def 16 , AMI_3:27;
thus L518: ( ( Exec (C78 , C76) ) . C77 ) = ( C76 . C77 ) by L517 , L516 , AMI_3:7;
end;
end;
registration
let R6 being (Element of ( NAT ));
cluster ( SCM-goto R6 ) ->  jump-only non  sequential non  ins-loc-free;
coherence
proof
thus L520: ( InsCode ( SCM-goto R6 ) ) is  jump-only;
L521: ( JUMP ( SCM-goto R6 ) ) <> ( {} );
thus L522: ( SCM-goto R6 ) is non  sequential by L521 , AMISTD_1:13;
L523: ( dom ( JumpPart ( SCM-goto R6 ) ) ) = ( dom <* R6 *> ) by RECDEF_2:def 2
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:def 8;
thus L524: (not ( JumpPart ( SCM-goto R6 ) ) is  empty) by L523;
end;
end;
registration
let R1 being Data-Location;
let R6 being (Element of ( NAT ));
cluster ( InsCode ( R1 =0_goto R6 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D63 = ( SCM );
L526:
now
let C79 being (State of D63);
let C80 being (Object of D63);
let C81 being (Instruction of D63);
assume that
L527: ( InsCode C81 ) = ( InsCode ( R1 =0_goto R6 ) )
and
L528: C80 in ( Data-Locations ( SCM ) );
L529: ( InsCode C81 ) = 7 by L527 , RECDEF_2:def 1;
L530: (ex R7 being (Element of ( NAT )) st (ex R2 being Data-Location st C81 = ( R2 =0_goto R7 ))) by L529 , AMI_5:14;
L531: C80 is Data-Location by L528 , AMI_2:def 16 , AMI_3:27;
thus L532: ( ( Exec (C81 , C79) ) . C80 ) = ( C79 . C80 ) by L531 , L530 , AMI_3:8;
end;
thus L533: thesis by L526 , AMISTD_1:def 1;
end;
cluster ( InsCode ( R1 >0_goto R6 ) ) ->  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D64 = ( SCM );
L534:
now
let C82 being (State of D64);
let C83 being (Object of D64);
let C84 being (Instruction of D64);
assume that
L535: ( InsCode C84 ) = ( InsCode ( R1 >0_goto R6 ) )
and
L536: C83 in ( Data-Locations ( SCM ) );
L537: ( InsCode C84 ) = 8 by L535 , RECDEF_2:def 1;
L538: (ex R7 being (Element of ( NAT )) st (ex R2 being Data-Location st C84 = ( R2 >0_goto R7 ))) by L537 , AMI_5:15;
L539: C83 is Data-Location by L536 , AMI_2:def 16 , AMI_3:27;
thus L540: ( ( Exec (C84 , C82) ) . C83 ) = ( C82 . C83 ) by L539 , L538 , AMI_3:9;
end;
thus L541: thesis by L534 , AMISTD_1:def 1;
end;
end;
registration
let R1 being Data-Location;
let R6 being (Element of ( NAT ));
cluster ( R1 =0_goto R6 ) ->  jump-only non  sequential non  ins-loc-free;
coherence
proof
thus L543: ( InsCode ( R1 =0_goto R6 ) ) is  jump-only;
L544: ( JUMP ( R1 =0_goto R6 ) ) <> ( {} );
thus L545: ( R1 =0_goto R6 ) is non  sequential by L544 , AMISTD_1:13;
L546: ( dom ( JumpPart ( R1 =0_goto R6 ) ) ) = ( dom <* R6 *> ) by RECDEF_2:def 2
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
thus L547: (not ( JumpPart ( R1 =0_goto R6 ) ) is  empty) by L546;
end;
cluster ( R1 >0_goto R6 ) ->  jump-only non  sequential non  ins-loc-free;
coherence
proof
thus L548: ( InsCode ( R1 >0_goto R6 ) ) is  jump-only;
L549: ( JUMP ( R1 >0_goto R6 ) ) <> ( {} );
thus L550: ( R1 >0_goto R6 ) is non  sequential by L549 , AMISTD_1:13;
L551: ( dom ( JumpPart ( R1 >0_goto R6 ) ) ) = ( dom <* R6 *> ) by RECDEF_2:def 2
.= { 1 } by FINSEQ_1:2 , FINSEQ_1:38;
thus L552: (not ( JumpPart ( R1 >0_goto R6 ) ) is  empty) by L551;
end;
end;
L554: ( dl. ( 0 ) ) <> ( dl. 1 ) by AMI_3:10;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( InsCode ( R1 := R2 ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D65 = the (State of ( SCM ));
set D66 = ( D65 +* ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) );
L555: ( InsCode ( R1 := R2 ) ) = 1 by RECDEF_2:def 1
.= ( InsCode ( ( dl. ( 0 ) ) := ( dl. 1 ) ) ) by RECDEF_2:def 1;
L556: ( dl. ( 0 ) ) in ( Data-Locations ( SCM ) ) by AMI_3:28;
L557: ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) = { ( dl. ( 0 ) ) , ( dl. 1 ) } by FUNCT_4:62;
L558: ( dl. 1 ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) by L557 , TARSKI:def 2;
L559: ( dl. ( 0 ) ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) by L557 , TARSKI:def 2;
L560: ( D66 . ( dl. ( 0 ) ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) . ( dl. ( 0 ) ) ) by L559 , FUNCT_4:13
.= ( 0 ) by AMI_3:10 , FUNCT_4:63;
L561: ( ( Exec (( ( dl. ( 0 ) ) := ( dl. 1 ) ) , D66) ) . ( dl. ( 0 ) ) ) = ( D66 . ( dl. 1 ) ) by AMI_3:2
.= ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) . ( dl. 1 ) ) by L558 , FUNCT_4:13
.= 1 by FUNCT_4:63;
thus L562: thesis by L561 , L555 , L556 , L560 , AMISTD_1:def 1;
end;
cluster ( InsCode ( AddTo (R1 , R2) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D67 = the (State of ( SCM ));
set D68 = ( D67 +* ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) );
L563: ( InsCode ( AddTo (R1 , R2) ) ) = 2 by RECDEF_2:def 1
.= ( InsCode ( AddTo (( dl. ( 0 ) ) , ( dl. 1 )) ) ) by RECDEF_2:def 1;
L564: ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) = { ( dl. ( 0 ) ) , ( dl. 1 ) } by FUNCT_4:62;
L565: ( dl. ( 0 ) ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) by L564 , TARSKI:def 2;
L566: ( D68 . ( dl. ( 0 ) ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) . ( dl. ( 0 ) ) ) by L565 , FUNCT_4:13
.= ( 0 ) by AMI_3:10 , FUNCT_4:63;
L567: ( dl. ( 0 ) ) in ( Data-Locations ( SCM ) ) by AMI_3:28;
L568: ( dl. 1 ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) by L564 , TARSKI:def 2;
L569: ( D68 . ( dl. 1 ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) . ( dl. 1 ) ) by L568 , FUNCT_4:13
.= 1 by FUNCT_4:63;
L570: (( dl. ( 0 ) ) <> ( IC ( SCM ) ) & ( ( Exec (( AddTo (( dl. ( 0 ) ) , ( dl. 1 )) ) , D68) ) . ( dl. ( 0 ) ) ) = ( (( 0 ) qua Nat) + 1 )) by L569 , L566 , AMI_3:3 , AMI_3:13;
thus L571: thesis by L570 , L563 , L566 , L567 , AMISTD_1:def 1;
end;
cluster ( InsCode ( SubFrom (R1 , R2) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D69 = the (State of ( SCM ));
set D70 = ( D69 +* ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) );
L572: ( InsCode ( SubFrom (R1 , R2) ) ) = 3 by RECDEF_2:def 1
.= ( InsCode ( SubFrom (( dl. ( 0 ) ) , ( dl. 1 )) ) ) by RECDEF_2:def 1;
L573: ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) = { ( dl. ( 0 ) ) , ( dl. 1 ) } by FUNCT_4:62;
L574: ( dl. ( 0 ) ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) by L573 , TARSKI:def 2;
L575: ( D70 . ( dl. ( 0 ) ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) . ( dl. ( 0 ) ) ) by L574 , FUNCT_4:13
.= ( 0 ) by AMI_3:10 , FUNCT_4:63;
L576: ( dl. ( 0 ) ) in ( Data-Locations ( SCM ) ) by AMI_3:28;
L577: ( dl. 1 ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) ) by L573 , TARSKI:def 2;
L578: ( D70 . ( dl. 1 ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (( 0 ) , 1) ) . ( dl. 1 ) ) by L577 , FUNCT_4:13
.= 1 by FUNCT_4:63;
L579: ( ( Exec (( SubFrom (( dl. ( 0 ) ) , ( dl. 1 )) ) , D70) ) . ( dl. ( 0 ) ) ) = ( ( D70 . ( dl. ( 0 ) ) ) - ( D70 . ( dl. 1 ) ) ) by AMI_3:4
.= ( - 1 ) by L575 , L578;
thus L580: thesis by L579 , L572 , L575 , L576 , AMISTD_1:def 1;
end;
cluster ( InsCode ( MultBy (R1 , R2) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D71 = the (State of ( SCM ));
set D72 = ( D71 +* ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (1 , ( 0 )) ) );
L581: ( InsCode ( MultBy (R1 , R2) ) ) = 4 by RECDEF_2:def 1
.= ( InsCode ( MultBy (( dl. ( 0 ) ) , ( dl. 1 )) ) ) by RECDEF_2:def 1;
L582: ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (1 , ( 0 )) ) ) = { ( dl. ( 0 ) ) , ( dl. 1 ) } by FUNCT_4:62;
L583: ( dl. ( 0 ) ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (1 , ( 0 )) ) ) by L582 , TARSKI:def 2;
L584: ( D72 . ( dl. ( 0 ) ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (1 , ( 0 )) ) . ( dl. ( 0 ) ) ) by L583 , FUNCT_4:13
.= 1 by AMI_3:10 , FUNCT_4:63;
L585: ( dl. ( 0 ) ) in ( Data-Locations ( SCM ) ) by AMI_3:28;
L586: ( dl. 1 ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (1 , ( 0 )) ) ) by L582 , TARSKI:def 2;
L587: ( D72 . ( dl. 1 ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (1 , ( 0 )) ) . ( dl. 1 ) ) by L586 , FUNCT_4:13
.= ( 0 ) by FUNCT_4:63;
L588: ( ( Exec (( MultBy (( dl. ( 0 ) ) , ( dl. 1 )) ) , D72) ) . ( dl. ( 0 ) ) ) = ( ( D72 . ( dl. ( 0 ) ) ) * ( D72 . ( dl. 1 ) ) ) by AMI_3:5
.= ( 0 ) by L587;
thus L589: thesis by L588 , L581 , L584 , L585 , AMISTD_1:def 1;
end;
cluster ( InsCode ( Divide (R1 , R2) ) ) -> non  jump-only for (InsType of (the InstructionsF of ( SCM )));
coherence
proof
set D73 = the (State of ( SCM ));
set D74 = ( D73 +* ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (7 , 3) ) );
L590: ( InsCode ( Divide (R1 , R2) ) ) = 5 by RECDEF_2:def 1
.= ( InsCode ( Divide (( dl. ( 0 ) ) , ( dl. 1 )) ) ) by RECDEF_2:def 1;
L591: ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (7 , 3) ) ) = { ( dl. ( 0 ) ) , ( dl. 1 ) } by FUNCT_4:62;
L592: ( dl. ( 0 ) ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (7 , 3) ) ) by L591 , TARSKI:def 2;
L593: ( D74 . ( dl. ( 0 ) ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (7 , 3) ) . ( dl. ( 0 ) ) ) by L592 , FUNCT_4:13
.= 7 by AMI_3:10 , FUNCT_4:63;
L594: 7 = ( ( 2 * 3 ) + 1 );
L595: ( dl. ( 0 ) ) in ( Data-Locations ( SCM ) ) by AMI_3:28;
L596: ( dl. 1 ) in ( dom ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (7 , 3) ) ) by L591 , TARSKI:def 2;
L597: ( D74 . ( dl. 1 ) ) = ( ( (( dl. ( 0 ) ) , ( dl. 1 )) --> (7 , 3) ) . ( dl. 1 ) ) by L596 , FUNCT_4:13
.= 3 by FUNCT_4:63;
L598: ( ( Exec (( Divide (( dl. ( 0 ) ) , ( dl. 1 )) ) , D74) ) . ( dl. ( 0 ) ) ) = ( 7 div (3 qua (Element of ( NAT ))) ) by L597 , L593 , L554 , AMI_3:6
.= 2 by L594 , NAT_D:def 1;
thus L599: thesis by L598 , L590 , L593 , L595 , AMISTD_1:def 1;
end;
end;
registration
let R1 being Data-Location;
let R2 being Data-Location;
cluster ( R1 := R2 ) -> non  jump-only;
coherence
proof
thus L601: (not ( InsCode ( R1 := R2 ) ) is  jump-only);
end;
cluster ( AddTo (R1 , R2) ) -> non  jump-only;
coherence
proof
thus L602: (not ( InsCode ( AddTo (R1 , R2) ) ) is  jump-only);
end;
cluster ( SubFrom (R1 , R2) ) -> non  jump-only;
coherence
proof
thus L603: (not ( InsCode ( SubFrom (R1 , R2) ) ) is  jump-only);
end;
cluster ( MultBy (R1 , R2) ) -> non  jump-only;
coherence
proof
thus L604: (not ( InsCode ( MultBy (R1 , R2) ) ) is  jump-only);
end;
cluster ( Divide (R1 , R2) ) -> non  jump-only;
coherence
proof
thus L605: (not ( InsCode ( Divide (R1 , R2) ) ) is  jump-only);
end;
end;
registration
cluster ( SCM ) ->  with_explicit_jumps;
coherence
proof
let C85 being (Instruction of ( SCM ));
thus L607: ( JUMP C85 ) c= ( rng ( JumpPart C85 ) )
proof
let C86 being set;
assume that
L608: C86 in ( JUMP C85 );
per cases  by AMI_3:24;
suppose L609: C85 = [ ( 0 ) , ( {} ) , ( {} ) ];

thus L610: thesis by L609 , L608 , AMI_3:26;
end;
suppose L611: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( R1 := R2 )));

thus L612: thesis by L611 , L608;
end;
suppose L613: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( AddTo (R1 , R2) )));

thus L614: thesis by L613 , L608;
end;
suppose L615: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( SubFrom (R1 , R2) )));

thus L616: thesis by L615 , L608;
end;
suppose L617: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( MultBy (R1 , R2) )));

thus L618: thesis by L617 , L608;
end;
suppose L619: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( Divide (R1 , R2) )));

thus L620: thesis by L619 , L608;
end;
suppose L621: (ex R13 being Nat st C85 = ( SCM-goto R13 ));

consider R14 being Nat such that L622: C85 = ( SCM-goto R14 ) by L621;
L623: ( JumpPart ( SCM-goto R14 ) ) = <* R14 *> by RECDEF_2:def 2;
L624: ( rng <* R14 *> ) = { R14 } by FINSEQ_1:39;
L625: ( JUMP ( SCM-goto R14 ) ) = { R14 } by L270;
thus L626: thesis by L625 , L608 , L622 , L623 , L624;
end;
suppose L627: (ex R1 being Data-Location st (ex R14 being Nat st C85 = ( R1 =0_goto R14 )));

consider R1 being Data-Location, R14 being Nat such that L628: C85 = ( R1 =0_goto R14 ) by L627;
L629: ( JumpPart ( R1 =0_goto R14 ) ) = <* R14 *> by RECDEF_2:def 2;
L630: ( rng <* R14 *> ) = { R14 } by FINSEQ_1:39;
L631: ( JUMP ( R1 =0_goto R14 ) ) = { R14 } by L330;
thus L632: thesis by L631 , L608 , L628 , L629 , L630;
end;
suppose L633: (ex R1 being Data-Location st (ex R14 being Nat st C85 = ( R1 >0_goto R14 )));

consider R1 being Data-Location, R14 being Nat such that L634: C85 = ( R1 >0_goto R14 ) by L633;
L635: ( JumpPart ( R1 >0_goto R14 ) ) = <* R14 *> by RECDEF_2:def 2;
L636: ( rng <* R14 *> ) = { R14 } by FINSEQ_1:39;
L637: ( JUMP ( R1 >0_goto R14 ) ) = { R14 } by L396;
thus L638: thesis by L637 , L608 , L634 , L635 , L636;
end;
end;

let C87 being set;
assume L640: C87 in ( rng ( JumpPart C85 ) );
consider C88 being set such that L641: C88 in ( dom ( JumpPart C85 ) ) and L642: C87 = ( ( JumpPart C85 ) . C88 ) by L640 , FUNCT_1:def 3;
per cases  by AMI_3:24;
suppose L643: C85 = [ ( 0 ) , ( {} ) , ( {} ) ];

L644: ( dom ( JumpPart C85 ) ) = ( dom ( {} ) ) by L643 , RECDEF_2:def 2;
thus L645: thesis by L644 , L641;
end;
suppose L646: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( R1 := R2 )));

consider R1 being Data-Location, R2 being Data-Location such that L647: C85 = ( R1 := R2 ) by L646;
L648: C88 in ( dom ( {} ) ) by L641 , L647 , RECDEF_2:def 2;
thus L649: thesis by L648;
end;
suppose L650: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( AddTo (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L651: C85 = ( AddTo (R1 , R2) ) by L650;
L652: C88 in ( dom ( {} ) ) by L641 , L651 , RECDEF_2:def 2;
thus L653: thesis by L652;
end;
suppose L654: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( SubFrom (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L655: C85 = ( SubFrom (R1 , R2) ) by L654;
L656: C88 in ( dom ( {} ) ) by L641 , L655 , RECDEF_2:def 2;
thus L657: thesis by L656;
end;
suppose L658: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( MultBy (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L659: C85 = ( MultBy (R1 , R2) ) by L658;
L660: C88 in ( dom ( {} ) ) by L641 , L659 , RECDEF_2:def 2;
thus L661: thesis by L660;
end;
suppose L662: (ex R1 being Data-Location st (ex R2 being Data-Location st C85 = ( Divide (R1 , R2) )));

consider R1 being Data-Location, R2 being Data-Location such that L663: C85 = ( Divide (R1 , R2) ) by L662;
L664: C88 in ( dom ( {} ) ) by L641 , L663 , RECDEF_2:def 2;
thus L665: thesis by L664;
end;
suppose L666: (ex R13 being Nat st C85 = ( SCM-goto R13 ));

consider R14 being Nat such that L667: C85 = ( SCM-goto R14 ) by L666;
L668: ( JumpPart C85 ) = <* R14 *> by L667 , RECDEF_2:def 2;
L669: C88 = 1 by L668 , L641 , FINSEQ_1:90;
L670: C87 = R14 by L669 , L668 , L642 , FINSEQ_1:def 8;
L671: ( JUMP C85 ) = { R14 } by L667 , L270;
thus L672: thesis by L671 , L670 , TARSKI:def 1;
end;
suppose L673: (ex R1 being Data-Location st (ex R13 being Nat st C85 = ( R1 =0_goto R13 )));

consider R1 being Data-Location, R14 being Nat such that L674: C85 = ( R1 =0_goto R14 ) by L673;
L675: ( JumpPart C85 ) = <* R14 *> by L674 , RECDEF_2:def 2;
L676: C88 = 1 by L675 , L641 , FINSEQ_1:90;
L677: C87 = R14 by L676 , L675 , L642 , FINSEQ_1:40;
L678: ( JUMP C85 ) = { R14 } by L674 , L330;
thus L679: thesis by L678 , L677 , TARSKI:def 1;
end;
suppose L680: (ex R1 being Data-Location st (ex R14 being Nat st C85 = ( R1 >0_goto R14 )));

consider R1 being Data-Location, R14 being Nat such that L681: C85 = ( R1 >0_goto R14 ) by L680;
L682: ( JumpPart C85 ) = <* R14 *> by L681 , RECDEF_2:def 2;
L683: C88 = 1 by L682 , L641 , FINSEQ_1:90;
L684: C87 = R14 by L683 , L682 , L642 , FINSEQ_1:40;
L685: ( JUMP C85 ) = { R14 } by L681 , L396;
thus L686: thesis by L685 , L684 , TARSKI:def 1;
end;
end;
end;
theorem
L689: (for R6 being (Element of ( NAT )) holds (for R13 being Nat holds ( IncAddr (( SCM-goto R6 ) , R13) ) = ( SCM-goto ( R6 + R13 ) )))
proof
let R6 being (Element of ( NAT ));
let R13 being Nat;
L690: ( JumpPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) = ( R13 + ( JumpPart ( SCM-goto R6 ) ) ) by COMPOS_0:def 9;
L691: ( dom ( JumpPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) ) = ( dom ( JumpPart ( SCM-goto R6 ) ) ) by L690 , VALUED_1:def 2;
L692: ( dom ( JumpPart ( SCM-goto ( R6 + R13 ) ) ) ) = ( dom <* ( R6 + R13 ) *> ) by RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:def 8
.= ( dom <* R6 *> ) by FINSEQ_1:def 8
.= ( dom ( JumpPart ( SCM-goto R6 ) ) ) by RECDEF_2:def 2;
L693: (for B20 being set holds (B20 in ( dom ( JumpPart ( SCM-goto R6 ) ) ) implies ( ( JumpPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) . B20 ) = ( ( JumpPart ( SCM-goto ( R6 + R13 ) ) ) . B20 )))
proof
let C89 being set;
assume L694: C89 in ( dom ( JumpPart ( SCM-goto R6 ) ) );
L695: C89 in ( dom <* R6 *> ) by L694 , RECDEF_2:def 2;
L696: C89 = 1 by L695 , FINSEQ_1:90;
set D75 = ( ( JumpPart ( SCM-goto R6 ) ) . C89 );
L697: ( ( JumpPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) . C89 ) = ( R13 + D75 ) by L694 , L691 , L690 , VALUED_1:def 2;
L698: D75 = ( <* R6 *> . C89 ) by RECDEF_2:def 2
.= R6 by L696 , FINSEQ_1:def 8;
thus L699: ( ( JumpPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) . C89 ) = ( <* ( R6 + R13 ) *> . C89 ) by L698 , L696 , L697 , FINSEQ_1:def 8
.= ( ( JumpPart ( SCM-goto ( R6 + R13 ) ) ) . C89 ) by RECDEF_2:def 2;
end;
L700: ( AddressPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) = ( AddressPart ( SCM-goto R6 ) ) by COMPOS_0:def 9
.= ( {} ) by RECDEF_2:def 3
.= ( AddressPart ( SCM-goto ( R6 + R13 ) ) ) by RECDEF_2:def 3;
L701: ( InsCode ( IncAddr (( SCM-goto R6 ) , R13) ) ) = ( InsCode ( SCM-goto R6 ) ) by COMPOS_0:def 9
.= 6 by RECDEF_2:def 1
.= ( InsCode ( SCM-goto ( R6 + R13 ) ) ) by RECDEF_2:def 1;
L702: ( JumpPart ( IncAddr (( SCM-goto R6 ) , R13) ) ) = ( JumpPart ( SCM-goto ( R6 + R13 ) ) ) by L691 , L692 , L693 , FUNCT_1:2;
thus L703: thesis by L702 , L700 , L701 , COMPOS_0:1;
end;
theorem
L704: (for R1 being Data-Location holds (for R6 being (Element of ( NAT )) holds (for R13 being Nat holds ( IncAddr (( R1 =0_goto R6 ) , R13) ) = ( R1 =0_goto ( R6 + R13 ) ))))
proof
let R1 being Data-Location;
let R6 being (Element of ( NAT ));
let R13 being Nat;
L705: ( JumpPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) = ( R13 + ( JumpPart ( R1 =0_goto R6 ) ) ) by COMPOS_0:def 9;
L706: ( dom ( JumpPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) ) = ( dom ( JumpPart ( R1 =0_goto R6 ) ) ) by L705 , VALUED_1:def 2;
L707: ( dom ( JumpPart ( R1 =0_goto ( R6 + R13 ) ) ) ) = ( dom <* ( R6 + R13 ) *> ) by RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* R6 *> ) by FINSEQ_1:38
.= ( dom ( JumpPart ( R1 =0_goto R6 ) ) ) by RECDEF_2:def 2;
L708: (for B21 being set holds (B21 in ( dom ( JumpPart ( R1 =0_goto R6 ) ) ) implies ( ( JumpPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) . B21 ) = ( ( JumpPart ( R1 =0_goto ( R6 + R13 ) ) ) . B21 )))
proof
let C90 being set;
assume L709: C90 in ( dom ( JumpPart ( R1 =0_goto R6 ) ) );
L710: C90 in ( dom <* R6 *> ) by L709 , RECDEF_2:def 2;
L711: C90 = 1 by L710 , FINSEQ_1:90;
set D76 = ( ( JumpPart ( R1 =0_goto R6 ) ) . C90 );
L712: ( ( JumpPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) . C90 ) = ( R13 + D76 ) by L705 , L706 , L709 , VALUED_1:def 2;
L713: D76 = ( <* R6 *> . C90 ) by RECDEF_2:def 2
.= R6 by L711 , FINSEQ_1:40;
thus L714: ( ( JumpPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) . C90 ) = ( <* ( R6 + R13 ) *> . C90 ) by L713 , L711 , L712 , FINSEQ_1:40
.= ( ( JumpPart ( R1 =0_goto ( R6 + R13 ) ) ) . C90 ) by RECDEF_2:def 2;
end;
L715: ( AddressPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) = ( AddressPart ( R1 =0_goto R6 ) ) by COMPOS_0:def 9
.= <* R1 *> by RECDEF_2:def 3
.= ( AddressPart ( R1 =0_goto ( R6 + R13 ) ) ) by RECDEF_2:def 3;
L716: ( InsCode ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) = ( InsCode ( R1 =0_goto R6 ) ) by COMPOS_0:def 9
.= 7 by RECDEF_2:def 1
.= ( InsCode ( R1 =0_goto ( R6 + R13 ) ) ) by RECDEF_2:def 1;
L717: ( JumpPart ( IncAddr (( R1 =0_goto R6 ) , R13) ) ) = ( JumpPart ( R1 =0_goto ( R6 + R13 ) ) ) by L706 , L707 , L708 , FUNCT_1:2;
thus L718: thesis by L717 , L715 , L716 , COMPOS_0:1;
end;
theorem
L719: (for R1 being Data-Location holds (for R6 being (Element of ( NAT )) holds (for R13 being Nat holds ( IncAddr (( R1 >0_goto R6 ) , R13) ) = ( R1 >0_goto ( R6 + R13 ) ))))
proof
let R1 being Data-Location;
let R6 being (Element of ( NAT ));
let R13 being Nat;
L720: ( JumpPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) = ( R13 + ( JumpPart ( R1 >0_goto R6 ) ) ) by COMPOS_0:def 9;
L721: ( dom ( JumpPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) ) = ( dom ( JumpPart ( R1 >0_goto R6 ) ) ) by L720 , VALUED_1:def 2;
L722: ( dom ( JumpPart ( R1 >0_goto ( R6 + R13 ) ) ) ) = ( dom <* ( R6 + R13 ) *> ) by RECDEF_2:def 2
.= ( Seg 1 ) by FINSEQ_1:38
.= ( dom <* R6 *> ) by FINSEQ_1:38
.= ( dom ( JumpPart ( R1 >0_goto R6 ) ) ) by RECDEF_2:def 2;
L723: (for B22 being set holds (B22 in ( dom ( JumpPart ( R1 >0_goto R6 ) ) ) implies ( ( JumpPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) . B22 ) = ( ( JumpPart ( R1 >0_goto ( R6 + R13 ) ) ) . B22 )))
proof
let C91 being set;
assume L724: C91 in ( dom ( JumpPart ( R1 >0_goto R6 ) ) );
L725: C91 in ( dom <* R6 *> ) by L724 , RECDEF_2:def 2;
L726: C91 = 1 by L725 , FINSEQ_1:90;
set D77 = ( ( JumpPart ( R1 >0_goto R6 ) ) . C91 );
L727: ( ( JumpPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) . C91 ) = ( R13 + D77 ) by L720 , L721 , L724 , VALUED_1:def 2;
L728: D77 = ( <* R6 *> . C91 ) by RECDEF_2:def 2
.= R6 by L726 , FINSEQ_1:40;
thus L729: ( ( JumpPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) . C91 ) = ( <* ( R6 + R13 ) *> . C91 ) by L728 , L726 , L727 , FINSEQ_1:40
.= ( ( JumpPart ( R1 >0_goto ( R6 + R13 ) ) ) . C91 ) by RECDEF_2:def 2;
end;
L730: ( AddressPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) = ( AddressPart ( R1 >0_goto R6 ) ) by COMPOS_0:def 9
.= <* R1 *> by RECDEF_2:def 3
.= ( AddressPart ( R1 >0_goto ( R6 + R13 ) ) ) by RECDEF_2:def 3;
L731: ( InsCode ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) = ( InsCode ( R1 >0_goto R6 ) ) by COMPOS_0:def 9
.= 8 by RECDEF_2:def 1
.= ( InsCode ( R1 >0_goto ( R6 + R13 ) ) ) by RECDEF_2:def 1;
L732: ( JumpPart ( IncAddr (( R1 >0_goto R6 ) , R13) ) ) = ( JumpPart ( R1 >0_goto ( R6 + R13 ) ) ) by L721 , L722 , L723 , FUNCT_1:2;
thus L733: thesis by L732 , L730 , L731 , COMPOS_0:1;
end;
registration
cluster ( SCM ) ->  IC-relocable;
coherence
proof
thus L734: ( SCM ) is  IC-relocable
proof
let C92 being (Instruction of ( SCM ));
per cases  by AMI_3:24;
suppose L735: C92 = [ ( 0 ) , ( {} ) , ( {} ) ];

thus L736: thesis by L735 , AMI_3:26;
end;
suppose L737: (ex R1 being Data-Location st (ex R2 being Data-Location st C92 = ( R1 := R2 )));

thus L738: thesis by L737;
end;
suppose L739: (ex R1 being Data-Location st (ex R2 being Data-Location st C92 = ( AddTo (R1 , R2) )));

thus L740: thesis by L739;
end;
suppose L741: (ex R1 being Data-Location st (ex R2 being Data-Location st C92 = ( SubFrom (R1 , R2) )));

thus L742: thesis by L741;
end;
suppose L743: (ex R1 being Data-Location st (ex R2 being Data-Location st C92 = ( MultBy (R1 , R2) )));

thus L744: thesis by L743;
end;
suppose L745: (ex R1 being Data-Location st (ex R2 being Data-Location st C92 = ( Divide (R1 , R2) )));

thus L746: thesis by L745;
end;
suppose L747: (ex R13 being Nat st C92 = ( SCM-goto R13 ));

let C93 , C94 being Nat;
let C95 being (State of ( SCM ));
set D78 = ( IncIC (C95 , C94) );
consider R14 being Nat such that L748: C92 = ( SCM-goto R14 ) by L747;
reconsider D79 = R14 as (Element of ( NAT )) by ORDINAL1:def 12;
L749: ( IC ( Exec (C92 , C95) ) ) = R14 by L748 , AMI_3:7;
thus L750: ( ( IC ( Exec (( IncAddr (C92 , C93) ) , C95) ) ) + C94 ) = ( ( IC ( Exec (( SCM-goto ( C93 + R14 ) ) , C95) ) ) + C94 ) by L749 , L748 , L689
.= ( ( C93 + R14 ) + C94 ) by AMI_3:7
.= ( IC ( Exec (( SCM-goto ( ( C93 + D79 ) + C94 ) ) , D78) ) ) by AMI_3:7
.= ( IC ( Exec (( SCM-goto ( ( C93 + C94 ) + D79 ) ) , D78) ) )
.= ( IC ( Exec (( IncAddr (C92 , ( C93 + C94 )) ) , D78) ) ) by L748 , L689;
end;
suppose L751: (ex R1 being Data-Location st (ex R13 being Nat st C92 = ( R1 =0_goto R13 )));

consider R1 being Data-Location, R14 being Nat such that L752: C92 = ( R1 =0_goto R14 ) by L751;
reconsider D80 = R14 as (Element of ( NAT )) by ORDINAL1:def 12;
let C96 , C97 being Nat;
let C98 being (State of ( SCM ));
set D81 = ( IncIC (C98 , C97) );
L753: (R1 <> ( IC ( SCM ) ) & ( dom ( ( IC ( SCM ) ) .--> ( ( IC C98 ) + C97 ) ) ) = { ( IC ( SCM ) ) }) by AMI_5:2 , FUNCOP_1:13;
L754: (not R1 in ( dom ( ( IC ( SCM ) ) .--> ( ( IC C98 ) + C97 ) ) )) by L753 , TARSKI:def 1;
L755: ( C98 . R1 ) = ( D81 . R1 ) by L754 , FUNCT_4:11;
L756:
now
per cases ;
suppose L757: ( C98 . R1 ) = ( 0 );

L758: ( IC ( Exec (C92 , C98) ) ) = R14 by L757 , L752 , AMI_3:8;
thus L759: ( ( IC ( Exec (( IncAddr (C92 , C96) ) , C98) ) ) + C97 ) = ( ( IC ( Exec (( R1 =0_goto ( C96 + R14 ) ) , C98) ) ) + C97 ) by L758 , L752 , L704
.= ( ( C96 + R14 ) + C97 ) by L757 , AMI_3:8
.= ( IC ( Exec (( R1 =0_goto ( ( C96 + D80 ) + C97 ) ) , D81) ) ) by L755 , L757 , AMI_3:8
.= ( IC ( Exec (( R1 =0_goto ( ( C96 + C97 ) + D80 ) ) , D81) ) )
.= ( IC ( Exec (( IncAddr (C92 , ( C96 + C97 )) ) , D81) ) ) by L752 , L704;
end;
suppose L760: ( C98 . R1 ) <> ( 0 );

L761: ( IncAddr (C92 , C96) ) = ( R1 =0_goto ( D80 + C96 ) ) by L752 , L704;
L762: ( IncAddr (C92 , ( C96 + C97 )) ) = ( R1 =0_goto ( D80 + ( C96 + C97 ) ) ) by L752 , L704;
L763: ( dom ( ( IC ( SCM ) ) .--> ( ( IC C98 ) + C97 ) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
L764: ( IC ( SCM ) ) in ( dom ( ( IC ( SCM ) ) .--> ( ( IC C98 ) + C97 ) ) ) by L763 , TARSKI:def 1;
L765: ( IC D81 ) = ( ( ( IC ( SCM ) ) .--> ( ( IC C98 ) + C97 ) ) . ( IC ( SCM ) ) ) by L764 , FUNCT_4:13
.= ( ( IC C98 ) + C97 ) by FUNCOP_1:72;
thus L766: ( ( IC ( Exec (( IncAddr (C92 , C96) ) , C98) ) ) + C97 ) = ( ( succ ( IC C98 ) ) + C97 ) by L761 , L760 , AMI_3:8
.= ( ( ( IC C98 ) + 1 ) + C97 )
.= ( succ ( IC D81 ) ) by L765
.= ( IC ( Exec (( IncAddr (C92 , ( C96 + C97 )) ) , D81) ) ) by L762 , L760 , L755 , AMI_3:8;
end;
end;
thus L768: thesis by L756;
end;
suppose L769: (ex R1 being Data-Location st (ex R13 being Nat st C92 = ( R1 >0_goto R13 )));

consider R1 being Data-Location, R14 being Nat such that L770: C92 = ( R1 >0_goto R14 ) by L769;
reconsider D82 = R14 as (Element of ( NAT )) by ORDINAL1:def 12;
let C99 , C100 being Nat;
let C101 being (State of ( SCM ));
set D83 = ( IncIC (C101 , C100) );
L771: (R1 <> ( IC ( SCM ) ) & ( dom ( ( IC ( SCM ) ) .--> ( ( IC C101 ) + C100 ) ) ) = { ( IC ( SCM ) ) }) by AMI_5:2 , FUNCOP_1:13;
L772: (not R1 in ( dom ( ( IC ( SCM ) ) .--> ( ( IC C101 ) + C100 ) ) )) by L771 , TARSKI:def 1;
L773: ( C101 . R1 ) = ( D83 . R1 ) by L772 , FUNCT_4:11;
per cases ;
suppose L774: ( C101 . R1 ) > ( 0 );

L775: ( IC ( Exec (C92 , C101) ) ) = R14 by L774 , L770 , AMI_3:9;
thus L776: ( ( IC ( Exec (( IncAddr (C92 , C99) ) , C101) ) ) + C100 ) = ( ( IC ( Exec (( R1 >0_goto ( C99 + R14 ) ) , C101) ) ) + C100 ) by L775 , L770 , L719
.= ( ( C99 + R14 ) + C100 ) by L774 , AMI_3:9
.= ( IC ( Exec (( R1 >0_goto ( ( C99 + D82 ) + C100 ) ) , D83) ) ) by L773 , L774 , AMI_3:9
.= ( IC ( Exec (( R1 >0_goto ( ( C99 + C100 ) + D82 ) ) , D83) ) )
.= ( IC ( Exec (( IncAddr (C92 , ( C99 + C100 )) ) , D83) ) ) by L770 , L719;
end;
suppose L777: ( C101 . R1 ) <= ( 0 );

L778: ( IncAddr (C92 , C99) ) = ( R1 >0_goto ( D82 + C99 ) ) by L770 , L719;
L779: ( IncAddr (C92 , ( C99 + C100 )) ) = ( R1 >0_goto ( D82 + ( C99 + C100 ) ) ) by L770 , L719;
L780: ( dom ( ( IC ( SCM ) ) .--> ( ( IC C101 ) + C100 ) ) ) = { ( IC ( SCM ) ) } by FUNCOP_1:13;
L781: ( IC ( SCM ) ) in ( dom ( ( IC ( SCM ) ) .--> ( ( IC C101 ) + C100 ) ) ) by L780 , TARSKI:def 1;
L782: ( IC D83 ) = ( ( ( IC ( SCM ) ) .--> ( ( IC C101 ) + C100 ) ) . ( IC ( SCM ) ) ) by L781 , FUNCT_4:13
.= ( ( IC C101 ) + C100 ) by FUNCOP_1:72;
thus L783: ( ( IC ( Exec (( IncAddr (C92 , C99) ) , C101) ) ) + C100 ) = ( ( succ ( IC C101 ) ) + C100 ) by L778 , L777 , AMI_3:9
.= ( ( ( IC C101 ) + 1 ) + C100 )
.= ( succ ( IC D83 ) ) by L782
.= ( IC ( Exec (( IncAddr (C92 , ( C99 + C100 )) ) , D83) ) ) by L779 , L777 , L773 , AMI_3:9;
end;
end;
end;

end;
end;
