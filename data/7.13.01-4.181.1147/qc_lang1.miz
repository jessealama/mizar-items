:: A First Order Language
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received August 8, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ZFMISC_1, TARSKI, XXREAL_0,
      MARGREL1, MCART_1, ARYTM_3, NAT_1, FINSEQ_1, RELAT_1, ORDINAL4, CARD_1,
      REALSET1, XBOOLEAN, BVFUNC_2, ZF_LANG, CLASSES2, FUNCT_1, FUNCOP_1,
      RCOMP_1, QC_LANG1, WELLORD1, RELAT_2, MEMBER_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1,
      XTUPLE_0, SUBSET_1, CARD_1, NUMBERS, ORDINAL1,
      XXREAL_0, MCART_1, NAT_1, RELAT_1, FUNCT_1, RELSET_1, FUNCT_2, FUNCOP_1,
      FINSEQ_1, WELLORD1, WELLORD2, RELAT_2;
 constructors ENUMSET1, FUNCOP_1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, RELSET_1,
      WELLORD1, WELLORD2, RELAT_2, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, XREAL_0,
      FINSEQ_1, CARD_1, WELLORD2, XTUPLE_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, XBOOLE_0, FINSEQ_1, CARD_1, XTUPLE_0;
 theorems ZFMISC_1, SUBSET_1, TARSKI, FINSEQ_1, MCART_1, NAT_1, FUNCT_1,
      FUNCT_2, RELSET_1, XBOOLE_0, XBOOLE_1, FUNCOP_1, XXREAL_0, ORDINAL1,
      CARD_1, RELAT_1, WELLORD1, WELLORD2, RELAT_2, ORDERS_1;
 schemes NAT_1, FUNCT_2, CLASSES1, XBOOLE_0;

begin
theorem
L1: (for B1 being non  empty set holds (for B2 being set holds (for B3 being (Element of B1) holds [: { B3 } , B2 :] c= [: B1 , B2 :])))
proof
let C1 being non  empty set;
let C2 being set;
let C3 being (Element of C1);
L2: { C3 } is (Subset of C1) by SUBSET_1:41;
thus L3: thesis by L2 , ZFMISC_1:95;
end;
theorem
L4: (for B4 being non  empty set holds (for B5 being set holds (for B6 , B7 , B8 being (Element of B4) holds [: { B6 , B7 , B8 } , B5 :] c= [: B4 , B5 :])))
proof
let C4 being non  empty set;
let C5 being set;
let C6 , C7 , C8 being (Element of C4);
L5: { C6 , C7 , C8 } is (Subset of C4) by SUBSET_1:35;
thus L6: thesis by L5 , ZFMISC_1:95;
end;
definition
mode QC-alphabet
means :L7: (it is non  empty non  empty non  empty non  empty set & (ex B9 being set st (( NAT ) c= B9 & it = [: ( NAT ) , B9 :])));
existence
proof
L8: [: ( NAT ) , ( NAT ) :] = [: ( NAT ) , ( NAT ) :];
thus L9: thesis by L8;
end;
end;
registration
cluster  -> non  empty  Relation-like for QC-alphabet;
coherence
proof
let C9 being QC-alphabet;
L11: (ex B10 being set st (( NAT ) c= B10 & C9 = [: ( NAT ) , B10 :])) by L7;
thus L12: thesis by L11 , L7;
end;
end;
definition
let C10 being QC-alphabet;
func QC-symbols C10 -> non  empty set equals 
( rng C10 );
coherence;
end;
definition
let C11 being QC-alphabet;
mode QC-symbol of C11
 is (Element of ( QC-symbols C11 ));
end;
theorem
L16: (for R1 being QC-alphabet holds (( NAT ) c= ( QC-symbols R1 ) & ( 0 ) in ( QC-symbols R1 )))
proof
let R1 being QC-alphabet;
consider C12 being set such that L17: (( NAT ) c= C12 & R1 = [: ( NAT ) , C12 :]) by L7;
L18: C12 <> ( {} ) by L17;
thus L19: ( NAT ) c= ( QC-symbols R1 ) by L17 , L18 , RELAT_1:160;
L20: ( 0 ) in ( NAT );
thus L21: ( 0 ) in ( QC-symbols R1 ) by L20 , L19;
end;
registration
let C13 being QC-alphabet;
cluster ( QC-symbols C13 ) -> non  empty;
coherence;
end;
definition
let C14 being QC-alphabet;
func QC-variables C14 -> set equals 
( [: { 6 } , ( NAT ) :] \/ [: { 4 , 5 } , ( QC-symbols C14 ) :] );
coherence;
end;
registration
let C15 being QC-alphabet;
cluster ( QC-variables C15 ) -> non  empty;
coherence;
end;
L25: (for R1 being QC-alphabet holds ([: { 4 } , ( QC-symbols R1 ) :] c= ( QC-variables R1 ) & [: { 5 } , ( QC-symbols R1 ) :] c= ( QC-variables R1 ) & [: { 6 } , ( NAT ) :] c= ( QC-variables R1 )))
proof
let R1 being QC-alphabet;
L26: { 5 } c= { 4 , 5 } by ZFMISC_1:7;
L27: [: { 5 } , ( QC-symbols R1 ) :] c= [: { 4 , 5 } , ( QC-symbols R1 ) :] by L26 , ZFMISC_1:96;
L28: { 4 } c= { 4 , 5 } by ZFMISC_1:7;
L29: [: { 4 } , ( QC-symbols R1 ) :] c= [: { 4 , 5 } , ( QC-symbols R1 ) :] by L28 , ZFMISC_1:96;
thus L30: thesis by L29 , L27 , XBOOLE_1:10;
end;
theorem
L31: (for R1 being QC-alphabet holds ( QC-variables R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :])
proof
let R1 being QC-alphabet;
L32: ({ 6 } c= ( NAT ) & ( NAT ) c= ( QC-symbols R1 )) by L16 , ZFMISC_1:31;
L33: [: { 6 } , ( NAT ) :] c= [: ( NAT ) , ( QC-symbols R1 ) :] by L32 , ZFMISC_1:96;
L34: ({ 4 , 5 } c= ( NAT ) & ( QC-symbols R1 ) c= ( QC-symbols R1 )) by ZFMISC_1:32;
L35: [: { 4 , 5 } , ( QC-symbols R1 ) :] c= [: ( NAT ) , ( QC-symbols R1 ) :] by L34 , ZFMISC_1:96;
thus L36: thesis by L35 , L33 , XBOOLE_1:8;
end;
definition
let C16 being QC-alphabet;
mode QC-variable of C16
 is (Element of ( QC-variables C16 ));
func bound_QC-variables C16 -> (Subset of ( QC-variables C16 )) equals 
[: { 4 } , ( QC-symbols C16 ) :];
coherence by L25;
func fixed_QC-variables C16 -> (Subset of ( QC-variables C16 )) equals 
[: { 5 } , ( QC-symbols C16 ) :];
coherence by L25;
func free_QC-variables C16 -> (Subset of ( QC-variables C16 )) equals 
[: { 6 } , ( NAT ) :];
coherence by L25;
func QC-pred_symbols C16 -> set equals 
{ [ R3 , B11 ] where R3 is (Element of ( NAT )) , B11 is (QC-symbol of C16) : 7 <= R3 };
coherence;
end;
registration
let C17 being QC-alphabet;
cluster ( bound_QC-variables C17 ) -> non  empty;
coherence;
cluster ( fixed_QC-variables C17 ) -> non  empty;
coherence;
cluster ( free_QC-variables C17 ) -> non  empty;
coherence;
cluster ( QC-pred_symbols C17 ) -> non  empty;
coherence
proof
L38: ( 0 ) is (QC-symbol of C17) by L16;
L39: [ 7 , ( 0 ) ] in { [ R3 , B12 ] where R3 is (Element of ( NAT )) , B12 is (QC-symbol of C17) : 7 <= R3 } by L38;
thus L40: thesis by L39;
end;
end;
theorem
L42: (for R1 being QC-alphabet holds R1 = [: ( NAT ) , ( QC-symbols R1 ) :])
proof
let R1 being QC-alphabet;
consider C18 being set such that L43: (( NAT ) c= C18 & R1 = [: ( NAT ) , C18 :]) by L7;
L44: C18 <> ( {} ) by L43;
thus L45: R1 = [: ( NAT ) , ( QC-symbols R1 ) :] by L44 , L43 , RELAT_1:160;
end;
theorem
L46: (for R1 being QC-alphabet holds ( QC-pred_symbols R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :])
proof
let R1 being QC-alphabet;
let C19 being set;
assume L47: C19 in ( QC-pred_symbols R1 );
L48: (ex B13 being (Element of ( NAT )) st (ex B14 being (QC-symbol of R1) st (C19 = [ B13 , B14 ] & 7 <= B13))) by L47;
thus L49: thesis by L48 , ZFMISC_1:def 2;
end;
definition
let C20 being QC-alphabet;
mode QC-pred_symbol of C20
 is (Element of ( QC-pred_symbols C20 ));
end;
definition
let C21 being QC-alphabet;
let C22 being (Element of ( QC-pred_symbols C21 ));
func the_arity_of C22 -> (Element of ( NAT )) means 
:L51: ( C22 `1 ) = ( 7 + it );
existence
proof
L52: C22 in { [ R2 , B15 ] where R2 is (Element of ( NAT )) , B15 is (QC-symbol of C21) : 7 <= R2 };
consider C23 being (Element of ( NAT )), C24 being (QC-symbol of C21) such that L53: C22 = [ C23 , C24 ] and L54: 7 <= C23 by L52;
consider C25 being Nat such that L55: C23 = ( 7 + C25 ) by L54 , NAT_1:10;
L56: C25 in ( NAT ) by ORDINAL1:def 12;
thus L57: thesis by L56 , L53 , L55 , MCART_1:7;
end;
uniqueness;
end;
definition
let R1 being QC-alphabet;
let R2 being (Element of ( NAT ));
func R2 -ary_QC-pred_symbols R1 -> (Subset of ( QC-pred_symbols R1 )) equals 
{ R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 };
coherence
proof
set D1 = { ( 7 + R2 ) };
L59: [: { ( 7 + R2 ) } , ( QC-symbols R1 ) :] c= ( QC-pred_symbols R1 )
proof
let C26 being set;
assume L60: C26 in [: { ( 7 + R2 ) } , ( QC-symbols R1 ) :];
reconsider D2 = ( C26 `1 ) as (Element of ( NAT )) by L60 , MCART_1:12;
reconsider D3 = ( C26 `2 ) as (QC-symbol of R1) by L60 , MCART_1:12;
L61: ( C26 `1 ) = ( 7 + R2 ) by L60 , MCART_1:12;
L62: 7 <= D2 by L61 , NAT_1:12;
L63: [ D2 , D3 ] in { [ R4 , B16 ] where R4 is (Element of ( NAT )) , B16 is (QC-symbol of R1) : 7 <= R4 } by L62;
thus L64: thesis by L63 , L60 , MCART_1:21;
end;
reconsider D4 = [: D1 , ( QC-symbols R1 ) :] as (Subset of ( QC-pred_symbols R1 )) by L59;
L65: D4 = { R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 }
proof
thus L66: D4 c= { R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 }
proof
let C27 being set;
assume L67: C27 in D4;
reconsider D5 = C27 as (QC-pred_symbol of R1) by L67;
L68: ( C27 `1 ) in D1 by L67 , MCART_1:10;
L69: ( C27 `1 ) = ( 7 + R2 ) by L68 , TARSKI:def 1;
L70: ( the_arity_of D5 ) = R2 by L69 , L51;
thus L71: thesis by L70;
end;

let C28 being set;
assume L72: C28 in { R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 };
consider R5 being (QC-pred_symbol of R1) such that L73: C28 = R5 and L74: ( the_arity_of R5 ) = R2 by L72;
L75: ( R5 `1 ) = ( 7 + R2 ) by L74 , L51;
L76: ( R5 `1 ) in D1 by L75 , TARSKI:def 1;
L77: ( QC-pred_symbols R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L46;
L78: R5 in [: ( NAT ) , ( QC-symbols R1 ) :] by L77 , TARSKI:def 3;
L79: ( R5 `2 ) in ( QC-symbols R1 ) by L78 , MCART_1:10;
L80: [ ( R5 `1 ) , ( R5 `2 ) ] in D4 by L79 , L76 , ZFMISC_1:87;
thus L81: thesis by L80 , L73 , L77 , MCART_1:21;
end;
thus L82: thesis by L65;
end;
end;
registration
let R2 being (Element of ( NAT ));
let R1 being QC-alphabet;
cluster ( R2 -ary_QC-pred_symbols R1 ) -> non  empty;
coherence
proof
set D6 = { ( 7 + R2 ) };
L84: [: { ( 7 + R2 ) } , ( QC-symbols R1 ) :] c= ( QC-pred_symbols R1 )
proof
let C29 being set;
assume L85: C29 in [: { ( 7 + R2 ) } , ( QC-symbols R1 ) :];
reconsider D7 = ( C29 `1 ) as (Element of ( NAT )) by L85 , MCART_1:12;
reconsider D8 = ( C29 `2 ) as (QC-symbol of R1) by MCART_1:12 , L85;
L86: ( C29 `1 ) = ( 7 + R2 ) by L85 , MCART_1:12;
L87: 7 <= D7 by L86 , NAT_1:12;
L88: [ D7 , D8 ] in { [ R4 , B17 ] where R4 is (Element of ( NAT )) , B17 is (QC-symbol of R1) : 7 <= R4 } by L87;
thus L89: thesis by L88 , L85 , MCART_1:21;
end;
reconsider D9 = [: D6 , ( QC-symbols R1 ) :] as non  empty (Subset of ( QC-pred_symbols R1 )) by L84;
L90: D9 = { R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 }
proof
thus L91: D9 c= { R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 }
proof
let C30 being set;
assume L92: C30 in D9;
reconsider D10 = C30 as (QC-pred_symbol of R1) by L92;
L93: ( C30 `1 ) in D6 by L92 , MCART_1:10;
L94: ( C30 `1 ) = ( 7 + R2 ) by L93 , TARSKI:def 1;
L95: ( the_arity_of D10 ) = R2 by L94 , L51;
thus L96: thesis by L95;
end;

let C31 being set;
assume L97: C31 in { R5 where R5 is (QC-pred_symbol of R1) : ( the_arity_of R5 ) = R2 };
consider R5 being (QC-pred_symbol of R1) such that L98: C31 = R5 and L99: ( the_arity_of R5 ) = R2 by L97;
L100: ( R5 `1 ) = ( 7 + R2 ) by L99 , L51;
L101: ( R5 `1 ) in D6 by L100 , TARSKI:def 1;
L102: ( QC-pred_symbols R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L46;
L103: R5 in [: ( NAT ) , ( QC-symbols R1 ) :] by L102 , TARSKI:def 3;
L104: ( R5 `2 ) in ( QC-symbols R1 ) by L103 , MCART_1:10;
L105: [ ( R5 `1 ) , ( R5 `2 ) ] in D9 by L104 , L101 , ZFMISC_1:87;
thus L106: thesis by L105 , L98 , L102 , MCART_1:21;
end;
thus L107: thesis by L90;
end;
end;
definition
let C32 being QC-alphabet;
mode bound_QC-variable of C32
 is (Element of ( bound_QC-variables C32 ));
mode fixed_QC-variable of C32
 is (Element of ( fixed_QC-variables C32 ));
mode free_QC-variable of C32
 is (Element of ( free_QC-variables C32 ));
let R2 being (Element of ( NAT ));
mode QC-pred_symbol of R2 , C32
 is (Element of ( R2 -ary_QC-pred_symbols C32 ));
end;
registration
let C33 being (Element of ( NAT ));
let C34 being QC-alphabet;
cluster C33 -element for (FinSequence of ( QC-variables C34 ));
existence
proof
consider C35 being (FinSequence of ( QC-variables C34 )) such that L110: ( len C35 ) = C33 by FINSEQ_1:19;
take C35;
thus L111: ( len C35 ) = C33 by L110;
end;
end;
definition
let C36 being (Element of ( NAT ));
let C37 being QC-alphabet;
mode QC-variable_list of C36 , C37
 is C36 -element (FinSequence of ( QC-variables C37 ));
end;
definition
let C38 being QC-alphabet;
let C39 being set;
attr C39 is C38 -closed
means
:L114: (C39 is (Subset of ( [: ( NAT ) , ( QC-symbols C38 ) :] * )) & (for B18 being (Element of ( NAT )) holds (for B19 being (QC-pred_symbol of B18 , C38) holds (for B20 being (QC-variable_list of B18 , C38) holds ( <* B19 *> ^ B20 ) in C39))) & <* [ ( 0 ) , ( 0 ) ] *> in C39 & (for B21 being (FinSequence of [: ( NAT ) , ( QC-symbols C38 ) :]) holds (B21 in C39 implies ( <* [ 1 , ( 0 ) ] *> ^ B21 ) in C39)) & (for B22 , B23 being (FinSequence of [: ( NAT ) , ( QC-symbols C38 ) :]) holds ((B22 in C39 & B23 in C39) implies ( ( <* [ 2 , ( 0 ) ] *> ^ B22 ) ^ B23 ) in C39)) & (for B24 being (bound_QC-variable of C38) holds (for B25 being (FinSequence of [: ( NAT ) , ( QC-symbols C38 ) :]) holds (B25 in C39 implies ( ( <* [ 3 , ( 0 ) ] *> ^ <* B24 *> ) ^ B25 ) in C39))));
end;
L116: (for R1 being QC-alphabet holds (for B26 being (Element of ( NAT )) holds (for B27 being (QC-symbol of R1) holds <* [ B26 , B27 ] *> is (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]))))
proof
let R1 being QC-alphabet;
let R2 being (Element of ( NAT ));
let C40 being (QC-symbol of R1);
L117: [ R2 , C40 ] in [: ( NAT ) , ( QC-symbols R1 ) :] by ZFMISC_1:def 2;
L118: (( rng <* [ R2 , C40 ] *> ) = { [ R2 , C40 ] } & { [ R2 , C40 ] } c= [: ( NAT ) , ( QC-symbols R1 ) :]) by L117 , FINSEQ_1:39 , ZFMISC_1:31;
thus L119: thesis by L118 , FINSEQ_1:def 4;
end;
L120: (for R1 being QC-alphabet holds (for B28 being (Element of ( NAT )) holds (for B29 being (QC-pred_symbol of B28 , R1) holds (for B30 being (QC-variable_list of B28 , R1) holds ( <* B29 *> ^ B30 ) is (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :])))))
proof
let R1 being QC-alphabet;
let C41 being (Element of ( NAT ));
let C42 being (QC-pred_symbol of C41 , R1);
let C43 being (QC-variable_list of C41 , R1);
L121: ( QC-variables R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L31;
L122: ( rng C43 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L121 , XBOOLE_1:1;
L123: ( QC-pred_symbols R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L46;
L124: ( C41 -ary_QC-pred_symbols R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L123 , XBOOLE_1:1;
L125: ( rng <* C42 *> ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L124 , XBOOLE_1:1;
L126: ( ( rng <* C42 *> ) \/ ( rng C43 ) ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L125 , L122 , XBOOLE_1:8;
L127: ( rng ( <* C42 *> ^ C43 ) ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L126 , FINSEQ_1:31;
thus L128: thesis by L127 , FINSEQ_1:def 4;
end;
L129: (for R1 being QC-alphabet holds (for B31 being (bound_QC-variable of R1) holds (for B32 being (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]) holds ( ( <* [ 3 , ( 0 ) ] *> ^ <* B31 *> ) ^ B32 ) is (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]))))
proof
let R1 being QC-alphabet;
L130: ( 0 ) is (QC-symbol of R1) by L16;
reconsider D11 = <* [ 3 , ( 0 ) ] *> as (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]) by L130 , L116;
let C44 being (bound_QC-variable of R1);
let C45 being (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]);
L131: ( QC-variables R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L31;
L132: ( bound_QC-variables R1 ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L131 , XBOOLE_1:1;
L133: ( rng <* C44 *> ) c= [: ( NAT ) , ( QC-symbols R1 ) :] by L132 , XBOOLE_1:1;
reconsider D12 = <* C44 *> as (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]) by L133 , FINSEQ_1:def 4;
L134: ( ( D11 ^ D12 ) ^ C45 ) is (FinSequence of [: ( NAT ) , ( QC-symbols R1 ) :]);
thus L135: thesis by L134;
end;
definition
let C46 being QC-alphabet;
func QC-WFF C46 -> non  empty set means 
:L136: (it is C46 -closed & (for B33 being non  empty set holds (B33 is C46 -closed implies it c= B33)));
existence
proof
L137: ( 0 ) is (QC-symbol of C46) by L16;
L138: <* [ ( 0 ) , ( 0 ) ] *> is (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) by L137 , L116;
L139: <* [ ( 0 ) , ( 0 ) ] *> in ( [: ( NAT ) , ( QC-symbols C46 ) :] * ) by L138 , FINSEQ_1:def 11;
defpred S1[ set ] means (for B34 being non  empty set holds (B34 is C46 -closed implies $1 in B34));
consider C47 being set such that L140: (for B35 being set holds (B35 in C47 iff (B35 in ( [: ( NAT ) , ( QC-symbols C46 ) :] * ) & S1[ B35 ]))) from XBOOLE_0:sch 1;
L141: (for B36 being non  empty set holds (B36 is C46 -closed implies <* [ ( 0 ) , ( 0 ) ] *> in B36)) by L114;
reconsider D13 = C47 as non  empty set by L141 , L140 , L139;
take D13;
L142: D13 c= ( [: ( NAT ) , ( QC-symbols C46 ) :] * )
proof
let C48 being set;
thus L143: thesis by L140;
end;
thus L144: D13 is (Subset of ( [: ( NAT ) , ( QC-symbols C46 ) :] * )) by L142;
thus L145: (for B37 being (Element of ( NAT )) holds (for B38 being (QC-pred_symbol of B37 , C46) holds (for B39 being (QC-variable_list of B37 , C46) holds ( <* B38 *> ^ B39 ) in D13)))
proof
let C49 being (Element of ( NAT ));
let C50 being (QC-pred_symbol of C49 , C46);
let C51 being (QC-variable_list of C49 , C46);
L146: ( <* C50 *> ^ C51 ) is (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) by L120;
L147: ( <* C50 *> ^ C51 ) in ( [: ( NAT ) , ( QC-symbols C46 ) :] * ) by L146 , FINSEQ_1:def 11;
L148: (for B40 being non  empty set holds (B40 is C46 -closed implies ( <* C50 *> ^ C51 ) in B40)) by L114;
thus L149: thesis by L148 , L140 , L147;
end;

thus L150: <* [ ( 0 ) , ( 0 ) ] *> in D13 by L140 , L139 , L141;
thus L151: (for B41 being (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) holds (B41 in D13 implies ( <* [ 1 , ( 0 ) ] *> ^ B41 ) in D13))
proof
L152: ( 0 ) is (QC-symbol of C46) by L16;
reconsider D14 = <* [ 1 , ( 0 ) ] *> as (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) by L116 , L152;
let C52 being (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]);
assume L153: C52 in D13;
L154: (for B42 being non  empty set holds (B42 is C46 -closed implies ( <* [ 1 , ( 0 ) ] *> ^ C52 ) in B42))
proof
let C53 being non  empty set;
assume L155: C53 is C46 -closed;
L156: C52 in C53 by L155 , L140 , L153;
thus L157: thesis by L156 , L155 , L114;
end;
L158: ( D14 ^ C52 ) is (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]);
L159: ( <* [ 1 , ( 0 ) ] *> ^ C52 ) in ( [: ( NAT ) , ( QC-symbols C46 ) :] * ) by L158 , FINSEQ_1:def 11;
thus L160: thesis by L159 , L140 , L154;
end;

thus L161: (for B43 , B44 being (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) holds ((B43 in D13 & B44 in D13) implies ( ( <* [ 2 , ( 0 ) ] *> ^ B43 ) ^ B44 ) in D13))
proof
L162: ( 0 ) is (QC-symbol of C46) by L16;
reconsider D15 = <* [ 2 , ( 0 ) ] *> as (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) by L162 , L116;
let C54 , C55 being (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]);
assume that
L163: (C54 in D13 & C55 in D13);
L164: (for B45 being non  empty set holds (B45 is C46 -closed implies ( ( <* [ 2 , ( 0 ) ] *> ^ C54 ) ^ C55 ) in B45))
proof
let C56 being non  empty set;
assume L165: C56 is C46 -closed;
L166: (C54 in C56 & C55 in C56) by L165 , L140 , L163;
thus L167: thesis by L166 , L165 , L114;
end;
L168: ( ( D15 ^ C54 ) ^ C55 ) is (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]);
L169: ( ( <* [ 2 , ( 0 ) ] *> ^ C54 ) ^ C55 ) in ( [: ( NAT ) , ( QC-symbols C46 ) :] * ) by L168 , FINSEQ_1:def 11;
thus L170: thesis by L169 , L140 , L164;
end;

thus L171: (for B46 being (bound_QC-variable of C46) holds (for B47 being (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) holds (B47 in D13 implies ( ( <* [ 3 , ( 0 ) ] *> ^ <* B46 *> ) ^ B47 ) in D13)))
proof
let C57 being (bound_QC-variable of C46);
let C58 being (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]);
assume L172: C58 in D13;
L173: (for B48 being non  empty set holds (B48 is C46 -closed implies ( ( <* [ 3 , ( 0 ) ] *> ^ <* C57 *> ) ^ C58 ) in B48))
proof
let C59 being non  empty set;
assume L174: C59 is C46 -closed;
L175: C58 in C59 by L174 , L140 , L172;
thus L176: thesis by L175 , L174 , L114;
end;
L177: ( ( <* [ 3 , ( 0 ) ] *> ^ <* C57 *> ) ^ C58 ) is (FinSequence of [: ( NAT ) , ( QC-symbols C46 ) :]) by L129;
L178: ( ( <* [ 3 , ( 0 ) ] *> ^ <* C57 *> ) ^ C58 ) in ( [: ( NAT ) , ( QC-symbols C46 ) :] * ) by L177 , FINSEQ_1:def 11;
thus L179: thesis by L178 , L140 , L173;
end;

let C60 being non  empty set;
assume that
L180: C60 is C46 -closed;
let C61 being set;
assume L181: C61 in D13;
thus L182: thesis by L181 , L140 , L180;
end;
uniqueness
proof
let C62 , C63 being non  empty set;
assume L183: (C62 is C46 -closed & (for B49 being non  empty set holds (B49 is C46 -closed implies C62 c= B49)) & C63 is C46 -closed & (for B50 being non  empty set holds (B50 is C46 -closed implies C63 c= B50)));
L184: (C62 c= C63 & C63 c= C62) by L183;
thus L185: thesis by L184 , XBOOLE_0:def 10;
end;
end;
theorem
L187: (for R1 being QC-alphabet holds ( QC-WFF R1 ) is R1 -closed) by L136;
registration
let C64 being QC-alphabet;
cluster C64 -closed non  empty for set;
existence
proof
L188: ( QC-WFF C64 ) is C64 -closed by L136;
thus L189: thesis by L188;
end;
end;
definition
let C65 being QC-alphabet;
mode QC-formula of C65
 is (Element of ( QC-WFF C65 ));
end;
definition
let C66 being QC-alphabet;
let C67 being (QC-pred_symbol of C66);
let C68 being (FinSequence of ( QC-variables C66 ));
assume L192: ( the_arity_of C67 ) = ( len C68 );
func C67 ! C68 -> (Element of ( QC-WFF C66 )) equals 
:L193: ( <* C67 *> ^ C68 );
coherence
proof
set D16 = ( len C68 );
set D17 = { B51 where B51 is (QC-pred_symbol of C66) : ( the_arity_of B51 ) = D16 };
L194: C67 in D17 by L192;
reconsider D18 = C67 as (QC-pred_symbol of D16 , C66) by L194;
reconsider D19 = C68 as (QC-variable_list of D16 , C66) by CARD_1:def 7;
L195: ( QC-WFF C66 ) is C66 -closed non  empty C66 -closed non  empty C66 -closed non  empty C66 -closed non  empty set by L136;
L196: (for B52 being C66 -closed non  empty set holds ((not contradiction) implies ( <* D18 *> ^ D19 ) in B52)) by L114;
thus L197: thesis by L196 , L195;
end;
end;
theorem
L199: (for R1 being QC-alphabet holds (for B53 being (Element of ( NAT )) holds (for B54 being (QC-pred_symbol of B53 , R1) holds (for B55 being (QC-variable_list of B53 , R1) holds ( B54 ! B55 ) = ( <* B54 *> ^ B55 )))))
proof
let R1 being QC-alphabet;
let C69 being (Element of ( NAT ));
let C70 being (QC-pred_symbol of C69 , R1);
let C71 being (QC-variable_list of C69 , R1);
set D20 = { B56 where B56 is (QC-pred_symbol of R1) : ( the_arity_of B56 ) = C69 };
L200: C70 in D20;
L201: (ex B57 being (QC-pred_symbol of R1) st (C70 = B57 & ( the_arity_of B57 ) = C69)) by L200;
L202: ( len C71 ) = C69 by CARD_1:def 7;
thus L203: thesis by L202 , L201 , L193;
end;
L204: (for R1 being QC-alphabet holds ( QC-WFF R1 ) is (Subset of ( [: ( NAT ) , ( QC-symbols R1 ) :] * )))
proof
let R1 being QC-alphabet;
L205: ( QC-WFF R1 ) is R1 -closed non  empty R1 -closed non  empty R1 -closed non  empty R1 -closed non  empty set by L136;
thus L206: thesis by L205 , L114;
end;
definition
let C72 being QC-alphabet;
let C73 being (Element of ( QC-WFF C72 ));
func @ C73 -> (FinSequence of [: ( NAT ) , ( QC-symbols C72 ) :]) equals 
C73;
coherence
proof
L207: (( QC-WFF C72 ) is (Subset of ( [: ( NAT ) , ( QC-symbols C72 ) :] * )) & C73 in ( QC-WFF C72 )) by L204;
thus L208: thesis by L207 , FINSEQ_1:def 11;
end;
end;
definition
let C74 being QC-alphabet;
func VERUM C74 -> (QC-formula of C74) equals 
<* [ ( 0 ) , ( 0 ) ] *>;
coherence
proof
L210: ( QC-WFF C74 ) is C74 -closed non  empty C74 -closed non  empty C74 -closed non  empty C74 -closed non  empty set by L136;
thus L211: thesis by L210 , L114;
end;
let C75 being (Element of ( QC-WFF C74 ));
func 'not' C75 -> (QC-formula of C74) equals 
( <* [ 1 , ( 0 ) ] *> ^ ( @ C75 ) );
coherence
proof
L212: ( QC-WFF C74 ) is C74 -closed non  empty C74 -closed non  empty C74 -closed non  empty C74 -closed non  empty set by L136;
thus L213: thesis by L212 , L114;
end;
let C76 being (Element of ( QC-WFF C74 ));
func C75 '&' C76 -> (QC-formula of C74) equals 
( ( <* [ 2 , ( 0 ) ] *> ^ ( @ C75 ) ) ^ ( @ C76 ) );
coherence
proof
L214: ( QC-WFF C74 ) is C74 -closed non  empty C74 -closed non  empty C74 -closed non  empty C74 -closed non  empty set by L136;
thus L215: thesis by L214 , L114;
end;
end;
definition
let C77 being QC-alphabet;
let C78 being (bound_QC-variable of C77);
let C79 being (Element of ( QC-WFF C77 ));
func All (C78 , C79) -> (QC-formula of C77) equals 
( ( <* [ 3 , ( 0 ) ] *> ^ <* C78 *> ) ^ ( @ C79 ) );
coherence
proof
L217: ( QC-WFF C77 ) is C77 -closed non  empty C77 -closed non  empty C77 -closed non  empty C77 -closed non  empty set by L136;
thus L218: thesis by L217 , L114;
end;
end;
scheme QCInd { F1() -> QC-alphabet , P1[(Element of ( QC-WFF F1() ))] } : (for B58 being (Element of ( QC-WFF F1() )) holds P1[ B58 ])
provided
L220: (for B59 being (Element of ( NAT )) holds (for B60 being (QC-pred_symbol of B59 , F1()) holds (for B61 being (QC-variable_list of B59 , F1()) holds P1[ ( B60 ! B61 ) ])))
and
L221: P1[ ( VERUM F1() ) ]
and
L222: (for B62 being (Element of ( QC-WFF F1() )) holds (P1[ B62 ] implies P1[ ( 'not' B62 ) ]))
and
L223: (for B63 , B64 being (Element of ( QC-WFF F1() )) holds ((P1[ B63 ] & P1[ B64 ]) implies P1[ ( B63 '&' B64 ) ]))
and
L224: (for B65 being (bound_QC-variable of F1()) holds (for B66 being (Element of ( QC-WFF F1() )) holds (P1[ B66 ] implies P1[ ( All (B65 , B66) ) ])))
proof
L225: ( VERUM F1() ) in { B67 where B67 is (Element of ( QC-WFF F1() )) : P1[ B67 ] } by L221;
reconsider D21 = { B68 where B68 is (Element of ( QC-WFF F1() )) : P1[ B68 ] } as non  empty set by L225;
L226: (for B69 being (Element of ( NAT )) holds (for B70 being (QC-pred_symbol of B69 , F1()) holds (for B71 being (QC-variable_list of B69 , F1()) holds ( <* B70 *> ^ B71 ) in D21)))
proof
let C80 being (Element of ( NAT ));
let C81 being (QC-pred_symbol of C80 , F1());
let C82 being (QC-variable_list of C80 , F1());
L227: P1[ ( C81 ! C82 ) ] by L220;
L228: ( C81 ! C82 ) in D21 by L227;
thus L229: thesis by L228 , L199;
end;
L230: (for B72 being (bound_QC-variable of F1()) holds (for B73 being (FinSequence of [: ( NAT ) , ( QC-symbols F1() ) :]) holds (B73 in D21 implies ( ( <* [ 3 , ( 0 ) ] *> ^ <* B72 *> ) ^ B73 ) in D21)))
proof
let C83 being (bound_QC-variable of F1());
let C84 being (FinSequence of [: ( NAT ) , ( QC-symbols F1() ) :]);
assume L231: C84 in D21;
consider C85 being (Element of ( QC-WFF F1() )) such that L232: C84 = C85 and L233: P1[ C85 ] by L231;
L234: P1[ ( All (C83 , C85) ) ] by L224 , L233;
thus L235: thesis by L234 , L232;
end;
L236: (for B74 , B75 being (FinSequence of [: ( NAT ) , ( QC-symbols F1() ) :]) holds ((B74 in D21 & B75 in D21) implies ( ( <* [ 2 , ( 0 ) ] *> ^ B74 ) ^ B75 ) in D21))
proof
let C86 , C87 being (FinSequence of [: ( NAT ) , ( QC-symbols F1() ) :]);
assume L237: C86 in D21;
consider C88 being (Element of ( QC-WFF F1() )) such that L238: C86 = C88 and L239: P1[ C88 ] by L237;
assume L240: C87 in D21;
consider C89 being (Element of ( QC-WFF F1() )) such that L241: C87 = C89 and L242: P1[ C89 ] by L240;
L243: P1[ ( C88 '&' C89 ) ] by L223 , L239 , L242;
thus L244: thesis by L243 , L238 , L241;
end;
L245: (for B76 being (FinSequence of [: ( NAT ) , ( QC-symbols F1() ) :]) holds (B76 in D21 implies ( <* [ 1 , ( 0 ) ] *> ^ B76 ) in D21))
proof
let C90 being (FinSequence of [: ( NAT ) , ( QC-symbols F1() ) :]);
assume L246: C90 in D21;
consider C91 being (Element of ( QC-WFF F1() )) such that L247: C90 = C91 and L248: P1[ C91 ] by L246;
L249: P1[ ( 'not' C91 ) ] by L222 , L248;
thus L250: thesis by L249 , L247;
end;
let C92 being (Element of ( QC-WFF F1() ));
L251: D21 c= ( [: ( NAT ) , ( QC-symbols F1() ) :] * )
proof
let C93 being set;
assume L252: C93 in D21;
consider C94 being (Element of ( QC-WFF F1() )) such that L253: C93 = C94 and L254: P1[ C94 ] by L252;
L255: C94 = ( @ C94 );
thus L256: thesis by L255 , L253 , FINSEQ_1:def 11;
end;
L257: <* [ ( 0 ) , ( 0 ) ] *> in D21 by L221;
L258: D21 is F1() -closed by L226 , L251 , L257 , L245 , L236 , L230 , L114;
L259: ( QC-WFF F1() ) c= D21 by L258 , L136;
L260: C92 in D21 by L259 , TARSKI:def 3;
L261: (ex B77 being (Element of ( QC-WFF F1() )) st (C92 = B77 & P1[ B77 ])) by L260;
thus L262: thesis by L261;
end;
definition
let C95 being QC-alphabet;
let C96 being (Element of ( QC-WFF C95 ));
attr C96 is  atomic
means
:L263: (ex B78 being (Element of ( NAT )) st (ex B79 being (QC-pred_symbol of B78 , C95) st (ex B80 being (QC-variable_list of B78 , C95) st C96 = ( B79 ! B80 ))));
attr C96 is  negative
means
:L264: (ex B81 being (Element of ( QC-WFF C95 )) st C96 = ( 'not' B81 ));
attr C96 is  conjunctive
means
:L265: (ex B82 , B83 being (Element of ( QC-WFF C95 )) st C96 = ( B82 '&' B83 ));
attr C96 is  universal
means
:L266: (ex B84 being (bound_QC-variable of C95) st (ex B85 being (Element of ( QC-WFF C95 )) st C96 = ( All (B84 , B85) )));
end;
theorem
L268: (for R1 being QC-alphabet holds (for B86 being (Element of ( QC-WFF R1 )) holds (B86 = ( VERUM R1 ) or B86 is  atomic or B86 is  negative or B86 is  conjunctive or B86 is  universal)))
proof
let R1 being QC-alphabet;
defpred S2[ (Element of ( QC-WFF R1 )) ] means ($1 = ( VERUM R1 ) or $1 is  atomic or $1 is  negative or $1 is  conjunctive or $1 is  universal);
L269: S2[ ( VERUM R1 ) ];
L270: (for B87 being (Element of ( QC-WFF R1 )) holds (S2[ B87 ] implies S2[ ( 'not' B87 ) ])) by L264;
L271: (for B88 being (bound_QC-variable of R1) holds (for B89 being (Element of ( QC-WFF R1 )) holds (S2[ B89 ] implies S2[ ( All (B88 , B89) ) ]))) by L266;
L272: (for B90 , B91 being (Element of ( QC-WFF R1 )) holds ((S2[ B90 ] & S2[ B91 ]) implies S2[ ( B90 '&' B91 ) ])) by L265;
L273: (for B92 being (Element of ( NAT )) holds (for B93 being (QC-pred_symbol of B92 , R1) holds (for B94 being (QC-variable_list of B92 , R1) holds S2[ ( B93 ! B94 ) ]))) by L263;
thus L274: (for B95 being (Element of ( QC-WFF R1 )) holds S2[ B95 ]) from QCInd(L273 , L269 , L270 , L272 , L271);
end;
theorem
L275: (for R1 being QC-alphabet holds (for B96 being (Element of ( QC-WFF R1 )) holds 1 <= ( len ( @ B96 ) )))
proof
let R1 being QC-alphabet;
let C97 being (Element of ( QC-WFF R1 ));
L276:
now
per cases  by L268;
suppose L277: C97 = ( VERUM R1 );

thus L278: thesis by L277 , FINSEQ_1:39;
end;
suppose L279: C97 is  atomic;

consider C98 being (Element of ( NAT )), C99 being (QC-pred_symbol of C98 , R1), C100 being (QC-variable_list of C98 , R1) such that L280: C97 = ( C99 ! C100 ) by L279 , L263;
L281: ( @ C97 ) = ( <* C99 *> ^ C100 ) by L280 , L199;
L282: ( len ( @ C97 ) ) = ( ( len <* C99 *> ) + ( len C100 ) ) by L281 , FINSEQ_1:22
.= ( 1 + ( len C100 ) ) by FINSEQ_1:39;
thus L283: thesis by L282 , NAT_1:11;
end;
suppose L284: C97 is  negative;

consider C101 being (Element of ( QC-WFF R1 )) such that L285: C97 = ( 'not' C101 ) by L284 , L264;
L286: ( len ( @ C97 ) ) = ( ( len <* [ 1 , ( 0 ) ] *> ) + ( len ( @ C101 ) ) ) by L285 , FINSEQ_1:22
.= ( 1 + ( len ( @ C101 ) ) ) by FINSEQ_1:39;
thus L287: thesis by L286 , NAT_1:11;
end;
suppose L288: C97 is  conjunctive;

consider C102 , C103 being (Element of ( QC-WFF R1 )) such that L289: C97 = ( C102 '&' C103 ) by L288 , L265;
L290: ( @ C97 ) = ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C102 ) ^ ( @ C103 ) ) ) by L289 , FINSEQ_1:32;
L291: ( len ( @ C97 ) ) = ( ( len <* [ 2 , ( 0 ) ] *> ) + ( len ( ( @ C102 ) ^ ( @ C103 ) ) ) ) by L290 , FINSEQ_1:22
.= ( 1 + ( len ( ( @ C102 ) ^ ( @ C103 ) ) ) ) by FINSEQ_1:39;
thus L292: thesis by L291 , NAT_1:11;
end;
suppose L293: C97 is  universal;

consider C104 being (bound_QC-variable of R1), C105 being (Element of ( QC-WFF R1 )) such that L294: C97 = ( All (C104 , C105) ) by L293 , L266;
L295: ( @ C97 ) = ( <* [ 3 , ( 0 ) ] *> ^ ( <* C104 *> ^ ( @ C105 ) ) ) by L294 , FINSEQ_1:32;
L296: ( len ( @ C97 ) ) = ( ( len <* [ 3 , ( 0 ) ] *> ) + ( len ( <* C104 *> ^ ( @ C105 ) ) ) ) by L295 , FINSEQ_1:22
.= ( 1 + ( len ( <* C104 *> ^ ( @ C105 ) ) ) ) by FINSEQ_1:39;
thus L297: thesis by L296 , NAT_1:11;
end;
end;
thus L299: thesis by L276;
end;
theorem
L300: (for R1 being QC-alphabet holds (for B97 being (Element of ( NAT )) holds (for B98 being (QC-pred_symbol of B97 , R1) holds ( the_arity_of B98 ) = B97)))
proof
let R1 being QC-alphabet;
let C106 being (Element of ( NAT ));
let C107 being (QC-pred_symbol of C106 , R1);
reconsider D22 = C107 as (Element of ( C106 -ary_QC-pred_symbols R1 ));
L301: D22 in { R7 where R7 is (QC-pred_symbol of R1) : ( the_arity_of R7 ) = C106 };
L302: (ex R7 being (QC-pred_symbol of R1) st (D22 = R7 & ( the_arity_of R7 ) = C106)) by L301;
thus L303: thesis by L302;
end;
theorem
L304: (for R1 being QC-alphabet holds (for R8 being (Element of ( QC-WFF R1 )) holds ((( ( ( @ R8 ) . 1 ) `1 ) = ( 0 ) implies R8 = ( VERUM R1 )) & (( ( ( @ R8 ) . 1 ) `1 ) = 1 implies R8 is  negative) & (( ( ( @ R8 ) . 1 ) `1 ) = 2 implies R8 is  conjunctive) & (( ( ( @ R8 ) . 1 ) `1 ) = 3 implies R8 is  universal) & ((ex B99 being (Element of ( NAT )) st ( ( @ R8 ) . 1 ) is (QC-pred_symbol of B99 , R1)) implies R8 is  atomic))))
proof
let R1 being QC-alphabet;
let R8 being (Element of ( QC-WFF R1 ));
L305:
now
per cases  by L268;
case L306: R8 is  atomic;
consider C108 being (Element of ( NAT )), C109 being (QC-pred_symbol of C108 , R1), C110 being (QC-variable_list of C108 , R1) such that L307: R8 = ( C109 ! C110 ) by L306 , L263;
L308: ( @ R8 ) = ( <* C109 *> ^ C110 ) by L307 , L199;
L309: ( ( @ R8 ) . 1 ) = C109 by L308 , FINSEQ_1:41;
thus L310: (ex B100 being (Element of ( NAT )) st ( ( @ R8 ) . 1 ) is (QC-pred_symbol of B100 , R1)) by L309;
end;
case L311: R8 = ( VERUM R1 );
thus L312: ( ( ( @ R8 ) . 1 ) `1 ) = ( [ ( 0 ) , ( 0 ) ] `1 ) by L311 , FINSEQ_1:def 8
.= ( 0 );
end;
case L313: R8 is  negative;
L314: (ex B101 being (Element of ( QC-WFF R1 )) st R8 = ( 'not' B101 )) by L313 , L264;
L315: ( ( @ R8 ) . 1 ) = [ 1 , ( 0 ) ] by L314 , FINSEQ_1:41;
thus L316: ( ( ( @ R8 ) . 1 ) `1 ) = 1 by L315 , MCART_1:7;
end;
case L317: R8 is  conjunctive;
consider C111 , C112 being (Element of ( QC-WFF R1 )) such that L318: R8 = ( C111 '&' C112 ) by L317 , L265;
L319: ( @ R8 ) = ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C111 ) ^ ( @ C112 ) ) ) by L318 , FINSEQ_1:32;
L320: ( ( @ R8 ) . 1 ) = [ 2 , ( 0 ) ] by L319 , FINSEQ_1:41;
thus L321: ( ( ( @ R8 ) . 1 ) `1 ) = 2 by L320 , MCART_1:7;
end;
case L322: R8 is  universal;
consider C113 being (bound_QC-variable of R1), C114 being (Element of ( QC-WFF R1 )) such that L323: R8 = ( All (C113 , C114) ) by L322 , L266;
L324: ( @ R8 ) = ( <* [ 3 , ( 0 ) ] *> ^ ( <* C113 *> ^ ( @ C114 ) ) ) by L323 , FINSEQ_1:32;
L325: ( ( @ R8 ) . 1 ) = [ 3 , ( 0 ) ] by L324 , FINSEQ_1:41;
thus L326: ( ( ( @ R8 ) . 1 ) `1 ) = 3 by L325 , MCART_1:7;
end;
end;
L328:
now
let C115 being (Element of ( NAT ));
let C116 being (QC-pred_symbol of C115 , R1);
reconsider D23 = C116 as (QC-pred_symbol of R1);
L329: ( D23 `1 ) = ( 7 + ( the_arity_of D23 ) ) by L51;
thus L330: (( C116 `1 ) <> ( 0 ) & ( C116 `1 ) <> 1 & ( C116 `1 ) <> 2 & ( C116 `1 ) <> 3) by L329 , NAT_1:11;
end;
thus L331: thesis by L328 , L305;
end;
theorem
L332: (for R1 being QC-alphabet holds (for R8 being (Element of ( QC-WFF R1 )) holds (for R9 being (Element of ( QC-WFF R1 )) holds (for R10 being FinSequence holds (( @ R8 ) = ( ( @ R9 ) ^ R10 ) implies ( @ R8 ) = ( @ R9 ))))))
proof
let R1 being QC-alphabet;
let R8 being (Element of ( QC-WFF R1 ));
let R9 being (Element of ( QC-WFF R1 ));
let R10 being FinSequence;
defpred S3[ set ] means (for R8 being (Element of ( QC-WFF R1 )) holds (for R9 being (Element of ( QC-WFF R1 )) holds (for R10 being FinSequence holds ((( len ( @ R8 ) ) = $1 & ( @ R8 ) = ( ( @ R9 ) ^ R10 )) implies ( @ R8 ) = ( @ R9 )))));
L333: (for B102 being Nat holds ((for B103 being Nat holds (B103 < B102 implies S3[ B103 ])) implies S3[ B102 ]))
proof
let C117 being Nat;
assume that
L334: (for B104 being Nat holds (B104 < C117 implies (for R8 being (Element of ( QC-WFF R1 )) holds (for R9 being (Element of ( QC-WFF R1 )) holds (for R10 being FinSequence holds ((( len ( @ R8 ) ) = B104 & ( @ R8 ) = ( ( @ R9 ) ^ R10 )) implies ( @ R8 ) = ( @ R9 )))))));
let C118 , C119 being (Element of ( QC-WFF R1 ));
let C120 being FinSequence;
assume that
L335: ( len ( @ C118 ) ) = C117
and
L336: ( @ C118 ) = ( ( @ C119 ) ^ C120 );
L337: (( dom ( @ C119 ) ) = ( Seg ( len ( @ C119 ) ) ) & 1 <= ( len ( @ C119 ) )) by L275 , FINSEQ_1:def 3;
L338: 1 in ( dom ( @ C119 ) ) by L337;
L339: ( ( @ C118 ) . 1 ) = ( ( @ C119 ) . 1 ) by L338 , L336 , FINSEQ_1:def 7;
L340: ( len ( ( @ C119 ) ^ C120 ) ) = ( ( len ( @ C119 ) ) + ( len C120 ) ) by FINSEQ_1:22;
L341:
now
per cases  by L268;
suppose L342: C118 = ( VERUM R1 );

L343: 1 <= ( len ( @ C119 ) ) by L275;
L344: ( len ( @ C118 ) ) = 1 by L342 , FINSEQ_1:39;
L345: ( len ( @ C119 ) ) <= 1 by L344 , L336 , L340 , NAT_1:11;
L346: ( 1 + ( 0 ) ) = ( 1 + ( len C120 ) ) by L345 , L336 , L340 , L344 , L343 , XXREAL_0:1;
L347: C120 = ( {} ) by L346;
thus L348: thesis by L347 , L336 , FINSEQ_1:34;
end;
suppose L349: C118 is  atomic;

consider C121 being (Element of ( NAT )), C122 being (QC-pred_symbol of C121 , R1), C123 being (QC-variable_list of C121 , R1) such that L350: C118 = ( C122 ! C123 ) by L349 , L263;
L351: ( @ C118 ) = ( <* C122 *> ^ C123 ) by L350 , L199;
L352: ( ( @ C119 ) . 1 ) = C122 by L351 , L339 , FINSEQ_1:41;
L353: C119 is  atomic by L352 , L304;
consider C124 being (Element of ( NAT )), C125 being (QC-pred_symbol of C124 , R1), C126 being (QC-variable_list of C124 , R1) such that L354: C119 = ( C125 ! C126 ) by L353 , L263;
L355: ( @ C119 ) = ( <* C125 *> ^ C126 ) by L354 , L199;
L356: ( ( @ C119 ) . 1 ) = C125 by L355 , FINSEQ_1:41;
L357: ( <* C122 *> ^ C123 ) = ( <* C122 *> ^ ( C126 ^ C120 ) ) by L356 , L336 , L351 , L352 , L355 , FINSEQ_1:32;
L358: C123 = ( C126 ^ C120 ) by L357 , FINSEQ_1:33;
L359: ( ( len C123 ) + ( 0 ) ) = ( ( len C126 ) + ( len C120 ) ) by L358 , FINSEQ_1:22;
L360: ( len C126 ) = C124 by CARD_1:def 7
.= ( the_arity_of C122 ) by L352 , L356 , L300
.= C121 by L300
.= ( len C123 ) by CARD_1:def 7;
L361: C120 = ( {} ) by L360 , L359;
thus L362: thesis by L361 , L336 , FINSEQ_1:34;
end;
suppose L363: C118 is  negative;

consider C127 being (Element of ( QC-WFF R1 )) such that L364: C118 = ( 'not' C127 ) by L363 , L264;
L365: ( ( @ C118 ) . 1 ) = [ 1 , ( 0 ) ] by L364 , FINSEQ_1:41;
L366: ( ( ( @ C119 ) . 1 ) `1 ) = 1 by L365 , L339 , MCART_1:7;
L367: C119 is  negative by L366 , L304;
consider C128 being (Element of ( QC-WFF R1 )) such that L368: C119 = ( 'not' C128 ) by L367 , L264;
L369: ( <* [ 1 , ( 0 ) ] *> ^ ( @ C127 ) ) = ( <* [ 1 , ( 0 ) ] *> ^ ( ( @ C128 ) ^ C120 ) ) by L336 , L364 , L368 , FINSEQ_1:32;
L370: ( @ C127 ) = ( ( @ C128 ) ^ C120 ) by L369 , FINSEQ_1:33;
L371: ( len ( @ C118 ) ) = ( ( len ( @ C127 ) ) + ( len <* [ 1 , ( 0 ) ] *> ) ) by L364 , FINSEQ_1:22
.= ( ( len ( @ C127 ) ) + 1 ) by FINSEQ_1:40;
L372: ( len ( @ C127 ) ) < ( len ( @ C118 ) ) by L371 , NAT_1:13;
L373: ( @ C127 ) = ( @ C128 ) by L372 , L334 , L335 , L370;
L374: ( ( @ C128 ) ^ ( {} ) ) = ( ( @ C128 ) ^ C120 ) by L373 , L370 , FINSEQ_1:34;
L375: C120 = ( {} ) by L374 , FINSEQ_1:33;
thus L376: thesis by L375 , L336 , FINSEQ_1:34;
end;
suppose L377: C118 is  conjunctive;

consider C129 , C130 being (Element of ( QC-WFF R1 )) such that L378: C118 = ( C129 '&' C130 ) by L377 , L265;
L379: ( @ C118 ) = ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C129 ) ^ ( @ C130 ) ) ) by L378 , FINSEQ_1:32;
L380: ( len ( @ C118 ) ) = ( ( len ( ( @ C129 ) ^ ( @ C130 ) ) ) + ( len <* [ 2 , ( 0 ) ] *> ) ) by L379 , FINSEQ_1:22
.= ( ( len ( ( @ C129 ) ^ ( @ C130 ) ) ) + 1 ) by FINSEQ_1:40;
L381: ( len ( @ C118 ) ) = ( ( ( len ( @ C129 ) ) + ( len ( @ C130 ) ) ) + 1 ) by L380 , FINSEQ_1:22;
L382: ( ( @ C118 ) . 1 ) = [ 2 , ( 0 ) ] by L379 , FINSEQ_1:41;
L383: ( ( ( @ C119 ) . 1 ) `1 ) = 2 by L382 , L339 , MCART_1:7;
L384: C119 is  conjunctive by L383 , L304;
consider C131 , C132 being (Element of ( QC-WFF R1 )) such that L385: C119 = ( C131 '&' C132 ) by L384 , L265;
L386: ( len ( @ C131 ) ) <= ( ( len ( @ C131 ) ) + ( len ( ( @ C132 ) ^ C120 ) ) ) by NAT_1:11;
L387: ( @ C119 ) = ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C131 ) ^ ( @ C132 ) ) ) by L385 , FINSEQ_1:32;
L388: ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C129 ) ^ ( @ C130 ) ) ) = ( <* [ 2 , ( 0 ) ] *> ^ ( ( ( @ C131 ) ^ ( @ C132 ) ) ^ C120 ) ) by L387 , L336 , L379 , FINSEQ_1:32;
L389: ( ( @ C129 ) ^ ( @ C130 ) ) = ( ( ( @ C131 ) ^ ( @ C132 ) ) ^ C120 ) by L388 , FINSEQ_1:33
.= ( ( @ C131 ) ^ ( ( @ C132 ) ^ C120 ) ) by FINSEQ_1:32;
L390: ( len ( @ C118 ) ) = ( ( ( len ( @ C131 ) ) + ( len ( ( @ C132 ) ^ C120 ) ) ) + 1 ) by L389 , L380 , FINSEQ_1:22;
L391: ( len ( @ C131 ) ) < ( len ( @ C118 ) ) by L390 , L386 , NAT_1:13;
L392: ( len ( @ C130 ) ) <= ( ( len ( @ C129 ) ) + ( len ( @ C130 ) ) ) by NAT_1:11;
L393: ( len ( @ C130 ) ) < ( len ( @ C118 ) ) by L392 , L381 , NAT_1:13;
L394: ( len ( @ C129 ) ) <= ( ( len ( @ C129 ) ) + ( len ( @ C130 ) ) ) by NAT_1:11;
L395: ( len ( @ C129 ) ) < ( len ( @ C118 ) ) by L394 , L381 , NAT_1:13;
L396: (( len ( @ C129 ) ) <= ( len ( @ C131 ) ) or ( len ( @ C131 ) ) <= ( len ( @ C129 ) ));
consider C133 , C134 , C135 , C136 being FinSequence such that L397: ((C133 = ( @ C129 ) & C134 = ( @ C131 )) or (C133 = ( @ C131 ) & C134 = ( @ C129 ))) and L398: (( len C133 ) <= ( len C134 ) & ( C133 ^ C135 ) = ( C134 ^ C136 )) by L396 , L389;
L399: (ex B105 being FinSequence st ( C133 ^ B105 ) = C134) by L398 , FINSEQ_1:47;
L400: ( @ C129 ) = ( @ C131 ) by L399 , L334 , L335 , L397 , L395 , L391;
L401: ( @ C130 ) = ( ( @ C132 ) ^ C120 ) by L400 , L389 , FINSEQ_1:33;
thus L402: thesis by L401 , L334 , L335 , L379 , L387 , L400 , L393;
end;
suppose L403: C118 is  universal;

consider C137 being (bound_QC-variable of R1), C138 being (Element of ( QC-WFF R1 )) such that L404: C118 = ( All (C137 , C138) ) by L403 , L266;
L405: ( @ C118 ) = ( <* [ 3 , ( 0 ) ] *> ^ ( <* C137 *> ^ ( @ C138 ) ) ) by L404 , FINSEQ_1:32;
L406: ( len ( @ C118 ) ) = ( ( len ( <* C137 *> ^ ( @ C138 ) ) ) + ( len <* [ 3 , ( 0 ) ] *> ) ) by L405 , FINSEQ_1:22
.= ( ( len ( <* C137 *> ^ ( @ C138 ) ) ) + 1 ) by FINSEQ_1:40
.= ( ( ( len <* C137 *> ) + ( len ( @ C138 ) ) ) + 1 ) by FINSEQ_1:22
.= ( ( 1 + ( len ( @ C138 ) ) ) + 1 ) by FINSEQ_1:40;
L407: ( ( len ( @ C138 ) ) + 1 ) <= ( len ( @ C118 ) ) by L406 , NAT_1:13;
L408: ( len ( @ C138 ) ) < ( len ( @ C118 ) ) by L407 , NAT_1:13;
L409: ( ( @ C118 ) . 1 ) = [ 3 , ( 0 ) ] by L405 , FINSEQ_1:41;
L410: ( ( ( @ C119 ) . 1 ) `1 ) = 3 by L409 , L339 , MCART_1:7;
L411: C119 is  universal by L410 , L304;
consider C139 being (bound_QC-variable of R1), C140 being (Element of ( QC-WFF R1 )) such that L412: C119 = ( All (C139 , C140) ) by L411 , L266;
L413: ( ( <* [ 3 , ( 0 ) ] *> ^ <* C137 *> ) ^ ( @ C138 ) ) = ( ( <* [ 3 , ( 0 ) ] *> ^ ( <* C139 *> ^ ( @ C140 ) ) ) ^ C120 ) by L336 , L404 , L412 , FINSEQ_1:32
.= ( <* [ 3 , ( 0 ) ] *> ^ ( ( <* C139 *> ^ ( @ C140 ) ) ^ C120 ) ) by FINSEQ_1:32;
L414: ( <* C137 *> ^ ( @ C138 ) ) = ( ( <* C139 *> ^ ( @ C140 ) ) ^ C120 ) by L413 , L404 , L405 , FINSEQ_1:33
.= ( <* C139 *> ^ ( ( @ C140 ) ^ C120 ) ) by FINSEQ_1:32;
L415: C137 = ( ( <* C139 *> ^ ( ( @ C140 ) ^ C120 ) ) . 1 ) by L414 , FINSEQ_1:41
.= C139 by FINSEQ_1:41;
L416: ( @ C138 ) = ( ( @ C140 ) ^ C120 ) by L415 , L414 , FINSEQ_1:33;
thus L417: thesis by L416 , L334 , L335 , L404 , L412 , L415 , L408;
end;
end;
thus L419: thesis by L341;
end;
L420: (for B106 being Nat holds S3[ B106 ]) from NAT_1:sch 4(L333);
L421: ( len ( @ R8 ) ) = ( len ( @ R8 ) );
thus L422: thesis by L421 , L420;
end;
definition
let C141 being QC-alphabet;
let C142 being (Element of ( QC-WFF C141 ));
assume that
L423: C142 is  atomic;
func the_pred_symbol_of C142 -> (QC-pred_symbol of C141) means 
:L424: (ex B107 being (Element of ( NAT )) st (ex B108 being (QC-variable_list of B107 , C141) st (ex B109 being (QC-pred_symbol of B107 , C141) st (it = B109 & C142 = ( B109 ! B108 )))));
existence
proof
L425: (ex B110 being (Element of ( NAT )) st (ex B111 being (QC-pred_symbol of B110 , C141) st (ex B112 being (QC-variable_list of B110 , C141) st C142 = ( B111 ! B112 )))) by L423 , L263;
thus L426: thesis by L425;
end;
uniqueness
proof
let C143 , C144 being (QC-pred_symbol of C141);
given C145 being (Element of ( NAT )) , C146 being (QC-variable_list of C145 , C141) , C147 being (QC-pred_symbol of C145 , C141) such that
L427: (C143 = C147 & C142 = ( C147 ! C146 ));

given C148 being (Element of ( NAT )) , C149 being (QC-variable_list of C148 , C141) , C150 being (QC-pred_symbol of C148 , C141) such that
L428: (C144 = C150 & C142 = ( C150 ! C149 ));

L429: ( <* C143 *> ^ C146 ) = C142 by L427 , L199
.= ( <* C144 *> ^ C149 ) by L428 , L199;
thus L430: C143 = ( ( <* C143 *> ^ C146 ) . 1 ) by FINSEQ_1:41
.= C144 by L429 , FINSEQ_1:41;
end;
end;
definition
let C151 being QC-alphabet;
let C152 being (Element of ( QC-WFF C151 ));
assume that
L432: C152 is  atomic;
func the_arguments_of C152 -> (FinSequence of ( QC-variables C151 )) means 
:L433: (ex B113 being (Element of ( NAT )) st (ex B114 being (QC-pred_symbol of B113 , C151) st (ex B115 being (QC-variable_list of B113 , C151) st (it = B115 & C152 = ( B114 ! B115 )))));
existence
proof
consider C153 being (Element of ( NAT )), C154 being (QC-pred_symbol of C153 , C151), C155 being (QC-variable_list of C153 , C151) such that L434: C152 = ( C154 ! C155 ) by L432 , L263;
reconsider D24 = C155 as (FinSequence of ( QC-variables C151 ));
take D24;
thus L435: thesis by L434;
end;
uniqueness
proof
let C156 , C157 being (FinSequence of ( QC-variables C151 ));
given C158 being (Element of ( NAT )) , C159 being (QC-pred_symbol of C158 , C151) , C160 being (QC-variable_list of C158 , C151) such that
L436: C156 = C160
and
L437: C152 = ( C159 ! C160 );

L438: C152 = ( <* C159 *> ^ C160 ) by L437 , L199;
given C161 being (Element of ( NAT )) , C162 being (QC-pred_symbol of C161 , C151) , C163 being (QC-variable_list of C161 , C151) such that
L439: C157 = C163
and
L440: C152 = ( C162 ! C163 );

L441: C152 = ( <* C162 *> ^ C163 ) by L440 , L199;
L442: C159 = ( the_pred_symbol_of C152 ) by L432 , L437 , L424
.= C162 by L432 , L440 , L424;
thus L443: thesis by L442 , L436 , L439 , L438 , L441 , FINSEQ_1:33;
end;
end;
definition
let C164 being QC-alphabet;
let C165 being (Element of ( QC-WFF C164 ));
assume that
L445: C165 is  negative;
func the_argument_of C165 -> (QC-formula of C164) means 
:L446: C165 = ( 'not' it );
existence by L445 , L264;
uniqueness by FINSEQ_1:33;
end;
definition
let C166 being QC-alphabet;
let C167 being (Element of ( QC-WFF C166 ));
assume that
L448: C167 is  conjunctive;
func the_left_argument_of C167 -> (QC-formula of C166) means 
:L449: (ex B116 being (Element of ( QC-WFF C166 )) st C167 = ( it '&' B116 ));
existence by L448 , L265;
uniqueness
proof
let C168 , C169 being (QC-formula of C166);
given C170 being (Element of ( QC-WFF C166 )) such that
L450: C167 = ( C168 '&' C170 );

given C171 being (Element of ( QC-WFF C166 )) such that
L451: C167 = ( C169 '&' C171 );

L452: ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C168 ) ^ ( @ C170 ) ) ) = ( C169 '&' C171 ) by L450 , L451 , FINSEQ_1:32
.= ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C169 ) ^ ( @ C171 ) ) ) by FINSEQ_1:32;
L453: ( ( @ C168 ) ^ ( @ C170 ) ) = ( ( @ C169 ) ^ ( @ C171 ) ) by L452 , FINSEQ_1:33;
L454: (( len ( @ C168 ) ) <= ( len ( @ C169 ) ) or ( len ( @ C169 ) ) <= ( len ( @ C168 ) ));
consider C172 , C173 , C174 , C175 being FinSequence such that L455: ((C172 = ( @ C168 ) & C173 = ( @ C169 )) or (C172 = ( @ C169 ) & C173 = ( @ C168 ))) and L456: (( len C172 ) <= ( len C173 ) & ( C172 ^ C174 ) = ( C173 ^ C175 )) by L454 , L453;
L457: (ex B117 being FinSequence st ( C172 ^ B117 ) = C173) by L456 , FINSEQ_1:47;
thus L458: thesis by L457 , L455 , L332;
end;
end;
definition
let C176 being QC-alphabet;
let C177 being (Element of ( QC-WFF C176 ));
assume that
L460: C177 is  conjunctive;
func the_right_argument_of C177 -> (QC-formula of C176) means 
:L461: (ex B118 being (Element of ( QC-WFF C176 )) st C177 = ( B118 '&' it ));
existence
proof
L462: (ex B119 , B120 being (Element of ( QC-WFF C176 )) st C177 = ( B119 '&' B120 )) by L460 , L265;
thus L463: thesis by L462;
end;
uniqueness
proof
let C178 , C179 being (QC-formula of C176);
given C180 being (Element of ( QC-WFF C176 )) such that
L464: C177 = ( C180 '&' C178 );

given C181 being (Element of ( QC-WFF C176 )) such that
L465: C177 = ( C181 '&' C179 );

L466: ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C180 ) ^ ( @ C178 ) ) ) = ( C181 '&' C179 ) by L464 , L465 , FINSEQ_1:32
.= ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C181 ) ^ ( @ C179 ) ) ) by FINSEQ_1:32;
L467: ( ( @ C180 ) ^ ( @ C178 ) ) = ( ( @ C181 ) ^ ( @ C179 ) ) by L466 , FINSEQ_1:33;
L468: C180 = ( the_left_argument_of C177 ) by L460 , L464 , L449
.= C181 by L460 , L465 , L449;
thus L469: thesis by L468 , L467 , FINSEQ_1:33;
end;
end;
definition
let C182 being QC-alphabet;
let C183 being (Element of ( QC-WFF C182 ));
assume that
L471: C183 is  universal;
func bound_in C183 -> (bound_QC-variable of C182) means 
:L472: (ex B121 being (Element of ( QC-WFF C182 )) st C183 = ( All (it , B121) ));
existence by L471 , L266;
uniqueness
proof
let C184 , C185 being (bound_QC-variable of C182);
given C186 being (Element of ( QC-WFF C182 )) such that
L473: C183 = ( All (C184 , C186) );

given C187 being (Element of ( QC-WFF C182 )) such that
L474: C183 = ( All (C185 , C187) );

L475: ( <* [ 3 , ( 0 ) ] *> ^ ( <* C184 *> ^ ( @ C186 ) ) ) = ( All (C185 , C187) ) by L473 , L474 , FINSEQ_1:32
.= ( <* [ 3 , ( 0 ) ] *> ^ ( <* C185 *> ^ ( @ C187 ) ) ) by FINSEQ_1:32;
L476: ( <* C184 *> ^ ( @ C186 ) ) = ( <* C185 *> ^ ( @ C187 ) ) by L475 , FINSEQ_1:33;
thus L477: C184 = ( ( <* C184 *> ^ ( @ C186 ) ) . 1 ) by FINSEQ_1:41
.= C185 by L476 , FINSEQ_1:41;
end;
func the_scope_of C183 -> (QC-formula of C182) means 
:L478: (ex B122 being (bound_QC-variable of C182) st C183 = ( All (B122 , it) ));
existence
proof
L479: (ex B123 being (bound_QC-variable of C182) st (ex B124 being (Element of ( QC-WFF C182 )) st C183 = ( All (B123 , B124) ))) by L471 , L266;
thus L480: thesis by L479;
end;
uniqueness
proof
let C188 , C189 being (QC-formula of C182);
given C190 being (bound_QC-variable of C182) such that
L481: C183 = ( All (C190 , C188) );

given C191 being (bound_QC-variable of C182) such that
L482: C183 = ( All (C191 , C189) );

L483: ( <* [ 3 , ( 0 ) ] *> ^ ( <* C190 *> ^ ( @ C188 ) ) ) = ( All (C191 , C189) ) by L481 , L482 , FINSEQ_1:32
.= ( <* [ 3 , ( 0 ) ] *> ^ ( <* C191 *> ^ ( @ C189 ) ) ) by FINSEQ_1:32;
L484: ( <* C190 *> ^ ( @ C188 ) ) = ( <* C191 *> ^ ( @ C189 ) ) by L483 , FINSEQ_1:33;
L485: C190 = ( ( <* C190 *> ^ ( @ C188 ) ) . 1 ) by FINSEQ_1:41
.= C191 by L484 , FINSEQ_1:41;
thus L486: thesis by L485 , L484 , FINSEQ_1:33;
end;
end;
theorem
L488: (for R1 being QC-alphabet holds (for R11 being (Element of ( QC-WFF R1 )) holds (R11 is  negative implies ( len ( @ ( the_argument_of R11 ) ) ) < ( len ( @ R11 ) ))))
proof
let R1 being QC-alphabet;
let R11 being (Element of ( QC-WFF R1 ));
assume L489: R11 is  negative;
consider C192 being (Element of ( QC-WFF R1 )) such that L490: R11 = ( 'not' C192 ) by L489 , L264;
L491: ( len ( @ R11 ) ) = ( ( len <* [ 1 , ( 0 ) ] *> ) + ( len ( @ C192 ) ) ) by L490 , FINSEQ_1:22
.= ( ( len ( @ C192 ) ) + 1 ) by FINSEQ_1:40;
L492: ( len ( @ C192 ) ) < ( len ( @ R11 ) ) by L491 , NAT_1:13;
thus L493: thesis by L492 , L489 , L490 , L446;
end;
theorem
L494: (for R1 being QC-alphabet holds (for R11 being (Element of ( QC-WFF R1 )) holds (R11 is  conjunctive implies (( len ( @ ( the_left_argument_of R11 ) ) ) < ( len ( @ R11 ) ) & ( len ( @ ( the_right_argument_of R11 ) ) ) < ( len ( @ R11 ) )))))
proof
let R1 being QC-alphabet;
let R11 being (Element of ( QC-WFF R1 ));
assume L495: R11 is  conjunctive;
consider C193 , C194 being (Element of ( QC-WFF R1 )) such that L496: R11 = ( C193 '&' C194 ) by L495 , L265;
L497: R11 = ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C193 ) ^ ( @ C194 ) ) ) by L496 , FINSEQ_1:32;
L498: ( len ( @ R11 ) ) = ( ( len <* [ 2 , ( 0 ) ] *> ) + ( len ( ( @ C193 ) ^ ( @ C194 ) ) ) ) by L497 , FINSEQ_1:22
.= ( ( len ( ( @ C193 ) ^ ( @ C194 ) ) ) + 1 ) by FINSEQ_1:40;
L499: ( ( len ( @ C194 ) ) + ( len ( @ C193 ) ) ) = ( len ( ( @ C193 ) ^ ( @ C194 ) ) ) by FINSEQ_1:22;
L500: ( len ( @ C194 ) ) <= ( len ( ( @ C193 ) ^ ( @ C194 ) ) ) by L499 , NAT_1:11;
L501: ( len ( @ C194 ) ) < ( len ( @ R11 ) ) by L500 , L498 , NAT_1:13;
L502: ( len ( @ C193 ) ) <= ( len ( ( @ C193 ) ^ ( @ C194 ) ) ) by L499 , NAT_1:11;
L503: ( len ( @ C193 ) ) < ( len ( @ R11 ) ) by L502 , L498 , NAT_1:13;
thus L504: thesis by L503 , L495 , L496 , L501 , L449 , L461;
end;
theorem
L505: (for R1 being QC-alphabet holds (for R11 being (Element of ( QC-WFF R1 )) holds (R11 is  universal implies ( len ( @ ( the_scope_of R11 ) ) ) < ( len ( @ R11 ) ))))
proof
let R1 being QC-alphabet;
let R11 being (Element of ( QC-WFF R1 ));
assume L506: R11 is  universal;
consider C195 being (bound_QC-variable of R1), C196 being (Element of ( QC-WFF R1 )) such that L507: R11 = ( All (C195 , C196) ) by L506 , L266;
L508: ( ( len ( @ C196 ) ) + ( len <* C195 *> ) ) = ( len ( <* C195 *> ^ ( @ C196 ) ) ) by FINSEQ_1:22;
L509: ( len ( @ C196 ) ) <= ( len ( <* C195 *> ^ ( @ C196 ) ) ) by L508 , NAT_1:11;
L510: R11 = ( <* [ 3 , ( 0 ) ] *> ^ ( <* C195 *> ^ ( @ C196 ) ) ) by L507 , FINSEQ_1:32;
L511: ( len ( @ R11 ) ) = ( ( len <* [ 3 , ( 0 ) ] *> ) + ( len ( <* C195 *> ^ ( @ C196 ) ) ) ) by L510 , FINSEQ_1:22
.= ( ( len ( <* C195 *> ^ ( @ C196 ) ) ) + 1 ) by FINSEQ_1:40;
L512: ( len ( @ C196 ) ) < ( len ( @ R11 ) ) by L511 , L509 , NAT_1:13;
thus L513: thesis by L512 , L506 , L507 , L478;
end;
scheme QCInd2 { F2() -> QC-alphabet , P2[(Element of ( QC-WFF F2() ))] } : (for B125 being (Element of ( QC-WFF F2() )) holds P2[ B125 ])
provided
L514: (for B126 being (Element of ( QC-WFF F2() )) holds ((B126 is  atomic implies P2[ B126 ]) & P2[ ( VERUM F2() ) ] & ((B126 is  negative & P2[ ( the_argument_of B126 ) ]) implies P2[ B126 ]) & ((B126 is  conjunctive & P2[ ( the_left_argument_of B126 ) ] & P2[ ( the_right_argument_of B126 ) ]) implies P2[ B126 ]) & ((B126 is  universal & P2[ ( the_scope_of B126 ) ]) implies P2[ B126 ])))
proof
L515:
now
let C197 being (bound_QC-variable of F2());
let C198 being (Element of ( QC-WFF F2() ));
assume that
L516: P2[ C198 ];
L517: ( All (C197 , C198) ) is  universal by L266;
L518: C198 = ( the_scope_of ( All (C197 , C198) ) ) by L517 , L478;
thus L519: P2[ ( All (C197 , C198) ) ] by L518 , L514 , L516 , L517;
end;
L520:
now
let C199 being (Element of ( QC-WFF F2() ));
assume that
L521: P2[ C199 ];
L522: ( 'not' C199 ) is  negative by L264;
L523: C199 = ( the_argument_of ( 'not' C199 ) ) by L522 , L446;
thus L524: P2[ ( 'not' C199 ) ] by L523 , L514 , L521 , L522;
end;
L525:
now
let C200 , C201 being (Element of ( QC-WFF F2() ));
assume that
L526: (P2[ C200 ] & P2[ C201 ]);
L527: ( C200 '&' C201 ) is  conjunctive by L265;
L528: (C200 = ( the_left_argument_of ( C200 '&' C201 ) ) & C201 = ( the_right_argument_of ( C200 '&' C201 ) )) by L527 , L449 , L461;
thus L529: P2[ ( C200 '&' C201 ) ] by L528 , L514 , L526 , L527;
end;
L530:
now
let C202 being (Element of ( NAT ));
let C203 being (QC-pred_symbol of C202 , F2());
let C204 being (QC-variable_list of C202 , F2());
L531: ( C203 ! C204 ) is  atomic by L263;
thus L532: P2[ ( C203 ! C204 ) ] by L531 , L514;
end;
L533: P2[ ( VERUM F2() ) ] by L514;
thus L534: (for B127 being (Element of ( QC-WFF F2() )) holds P2[ B127 ]) from QCInd(L530 , L533 , L520 , L525 , L515);
end;
theorem
L535: (for R1 being QC-alphabet holds (for B128 being (Element of ( NAT )) holds (for B129 being (QC-pred_symbol of B128 , R1) holds (( B129 `1 ) <> ( 0 ) & ( B129 `1 ) <> 1 & ( B129 `1 ) <> 2 & ( B129 `1 ) <> 3))))
proof
let R1 being QC-alphabet;
let C205 being (Element of ( NAT ));
let C206 being (QC-pred_symbol of C205 , R1);
reconsider D25 = C206 as (QC-pred_symbol of R1);
L536: ( D25 `1 ) = ( 7 + ( the_arity_of D25 ) ) by L51;
thus L537: thesis by L536 , NAT_1:11;
end;
theorem
L538: (for R1 being QC-alphabet holds (for R12 being (Element of ( QC-WFF R1 )) holds (( ( ( @ ( VERUM R1 ) ) . 1 ) `1 ) = ( 0 ) & (R12 is  atomic implies (ex B130 being (Element of ( NAT )) st ( ( @ R12 ) . 1 ) is (QC-pred_symbol of B130 , R1))) & (R12 is  negative implies ( ( ( @ R12 ) . 1 ) `1 ) = 1) & (R12 is  conjunctive implies ( ( ( @ R12 ) . 1 ) `1 ) = 2) & (R12 is  universal implies ( ( ( @ R12 ) . 1 ) `1 ) = 3))))
proof
let R1 being QC-alphabet;
let R12 being (Element of ( QC-WFF R1 ));
thus L539: ( ( ( @ ( VERUM R1 ) ) . 1 ) `1 ) = ( [ ( 0 ) , ( 0 ) ] `1 ) by FINSEQ_1:def 8
.= ( 0 );
thus L540: (R12 is  atomic implies (ex B131 being (Element of ( NAT )) st ( ( @ R12 ) . 1 ) is (QC-pred_symbol of B131 , R1)))
proof
assume L541: R12 is  atomic;
consider C207 being (Element of ( NAT )), C208 being (QC-pred_symbol of C207 , R1), C209 being (QC-variable_list of C207 , R1) such that L542: R12 = ( C208 ! C209 ) by L541 , L263;
L543: ( @ R12 ) = ( <* C208 *> ^ C209 ) by L542 , L199;
L544: ( ( @ R12 ) . 1 ) = C208 by L543 , FINSEQ_1:41;
thus L545: thesis by L544;
end;

thus L546: (R12 is  negative implies ( ( ( @ R12 ) . 1 ) `1 ) = 1)
proof
assume L547: R12 is  negative;
L548: (ex B132 being (Element of ( QC-WFF R1 )) st R12 = ( 'not' B132 )) by L547 , L264;
L549: ( ( @ R12 ) . 1 ) = [ 1 , ( 0 ) ] by L548 , FINSEQ_1:41;
thus L550: thesis by L549 , MCART_1:7;
end;

thus L551: (R12 is  conjunctive implies ( ( ( @ R12 ) . 1 ) `1 ) = 2)
proof
assume L552: R12 is  conjunctive;
consider C210 , C211 being (Element of ( QC-WFF R1 )) such that L553: R12 = ( C210 '&' C211 ) by L552 , L265;
L554: ( @ R12 ) = ( <* [ 2 , ( 0 ) ] *> ^ ( ( @ C210 ) ^ ( @ C211 ) ) ) by L553 , FINSEQ_1:32;
L555: ( ( @ R12 ) . 1 ) = [ 2 , ( 0 ) ] by L554 , FINSEQ_1:41;
thus L556: thesis by L555 , MCART_1:7;
end;

thus L557: (R12 is  universal implies ( ( ( @ R12 ) . 1 ) `1 ) = 3)
proof
assume L558: R12 is  universal;
consider C212 being (bound_QC-variable of R1), C213 being (Element of ( QC-WFF R1 )) such that L559: R12 = ( All (C212 , C213) ) by L558 , L266;
L560: ( @ R12 ) = ( <* [ 3 , ( 0 ) ] *> ^ ( <* C212 *> ^ ( @ C213 ) ) ) by L559 , FINSEQ_1:32;
L561: ( ( @ R12 ) . 1 ) = [ 3 , ( 0 ) ] by L560 , FINSEQ_1:41;
thus L562: thesis by L561 , MCART_1:7;
end;

end;
theorem
L558: (for R1 being QC-alphabet holds (for R12 being (Element of ( QC-WFF R1 )) holds (R12 is  atomic implies (( ( ( @ R12 ) . 1 ) `1 ) <> ( 0 ) & ( ( ( @ R12 ) . 1 ) `1 ) <> 1 & ( ( ( @ R12 ) . 1 ) `1 ) <> 2 & ( ( ( @ R12 ) . 1 ) `1 ) <> 3))))
proof
let R1 being QC-alphabet;
let R12 being (Element of ( QC-WFF R1 ));
assume L559: R12 is  atomic;
L560: (ex B133 being (Element of ( NAT )) st ( ( @ R12 ) . 1 ) is (QC-pred_symbol of B133 , R1)) by L559 , L538;
thus L561: thesis by L560 , L535;
end;
theorem
L562: (for R1 being QC-alphabet holds ((not (( VERUM R1 ) is  atomic or ( VERUM R1 ) is  negative or ( VERUM R1 ) is  conjunctive or ( VERUM R1 ) is  universal)) & (not (ex R13 being (Element of ( QC-WFF R1 )) st ((R13 is  atomic & R13 is  negative) or (R13 is  atomic & R13 is  conjunctive) or (R13 is  atomic & R13 is  universal) or (R13 is  negative & R13 is  conjunctive) or (R13 is  negative & R13 is  universal) or (R13 is  conjunctive & R13 is  universal))))))
proof
let R1 being QC-alphabet;
L563: ( ( ( @ ( VERUM R1 ) ) . 1 ) `1 ) = ( 0 ) by L538;
thus L564: (not (( VERUM R1 ) is  atomic or ( VERUM R1 ) is  negative or ( VERUM R1 ) is  conjunctive or ( VERUM R1 ) is  universal)) by L563 , L538 , L558;
let C214 being (Element of ( QC-WFF R1 ));
L565: (C214 is  conjunctive implies ( ( ( @ C214 ) . 1 ) `1 ) = 2) by L538;
L566: (C214 is  universal implies ( ( ( @ C214 ) . 1 ) `1 ) = 3) by L538;
L567: (C214 is  negative implies ( ( ( @ C214 ) . 1 ) `1 ) = 1) by L538;
thus L568: thesis by L567 , L565 , L566 , L558;
end;
scheme QCFuncEx { F3() -> QC-alphabet , F4() -> non  empty set , F5() -> (Element of F4()) , F6((Element of ( QC-WFF F3() ))) -> (Element of F4()) , F7((Element of F4())) -> (Element of F4()) , F8((Element of F4()) , (Element of F4())) -> (Element of F4()) , F9((Element of ( QC-WFF F3() )) , (Element of F4())) -> (Element of F4()) } : (ex B134 being (Function of ( QC-WFF F3() ) , F4()) st (( B134 . ( VERUM F3() ) ) = F5() & (for B135 being (Element of ( QC-WFF F3() )) holds ((B135 is  atomic implies ( B134 . B135 ) = F6(B135)) & (B135 is  negative implies ( B134 . B135 ) = F7(( B134 . ( the_argument_of B135 ) ))) & (B135 is  conjunctive implies ( B134 . B135 ) = F8(( B134 . ( the_left_argument_of B135 ) ) , ( B134 . ( the_right_argument_of B135 ) ))) & (B135 is  universal implies ( B134 . B135 ) = F9(B135 , ( B134 . ( the_scope_of B135 ) )))))))
proof
defpred S4[ (Function of ( QC-WFF F3() ) , F4()) , (Element of ( NAT )) ] means (( $1 . ( VERUM F3() ) ) = F5() & (for B136 being (Element of ( QC-WFF F3() )) holds (( len ( @ B136 ) ) <= $2 implies ((B136 is  atomic implies ( $1 . B136 ) = F6(B136)) & (B136 is  negative implies ( $1 . B136 ) = F7(( $1 . ( the_argument_of B136 ) ))) & (B136 is  conjunctive implies ( $1 . B136 ) = F8(( $1 . ( the_left_argument_of B136 ) ) , ( $1 . ( the_right_argument_of B136 ) ))) & (B136 is  universal implies ( $1 . B136 ) = F9(B136 , ( $1 . ( the_scope_of B136 ) )))))));
defpred S5[ (Element of F4()) , (Function of ( QC-WFF F3() ) , F4()) , (Element of ( QC-WFF F3() )) ] means (($3 = ( VERUM F3() ) implies $1 = F5()) & ($3 is  atomic implies $1 = F6($3)) & ($3 is  negative implies $1 = F7(( $2 . ( the_argument_of $3 ) ))) & ($3 is  conjunctive implies $1 = F8(( $2 . ( the_left_argument_of $3 ) ) , ( $2 . ( the_right_argument_of $3 ) ))) & ($3 is  universal implies $1 = F9($3 , ( $2 . ( the_scope_of $3 ) ))));
defpred S6[ (Element of ( NAT )) ] means (ex B137 being (Function of ( QC-WFF F3() ) , F4()) st S4[ B137 , $1 ]);
defpred S7[ set , set ] means (ex B138 being (Element of ( QC-WFF F3() )) st (B138 = $1 & (for B139 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B139 , (( len ( @ B138 ) ) qua (Element of ( NAT ))) ] implies $2 = ( B139 . B138 )))));
L569: (for B140 being (Element of ( NAT )) holds (S6[ B140 ] implies S6[ ( B140 + 1 ) ]))
proof
let C215 being (Element of ( NAT ));
given C216 being (Function of ( QC-WFF F3() ) , F4()) such that
L570: S4[ C216 , C215 ];

defpred S8[ (Element of ( QC-WFF F3() )) , (Element of F4()) ] means ((( len ( @ $1 ) ) <> ( C215 + 1 ) implies $2 = ( C216 . $1 )) & (( len ( @ $1 ) ) = ( C215 + 1 ) implies S5[ $2 , C216 , $1 ]));
L571: (for B141 being (Element of ( QC-WFF F3() )) holds (ex B142 being (Element of F4()) st S8[ B141 , B142 ]))
proof
let C217 being (Element of ( QC-WFF F3() ));
L572:
now
per cases  by L268;
case L573: ( len ( @ C217 ) ) <> ( C215 + 1 );
take D26 = ( C216 . C217 );
thus L574: D26 = ( C216 . C217 );
end;
case L575: (( len ( @ C217 ) ) = ( C215 + 1 ) & C217 = ( VERUM F3() ));
take D27 = F5();
thus L576: S5[ D27 , C216 , C217 ] by L575 , L562;
end;
case L577: (( len ( @ C217 ) ) = ( C215 + 1 ) & C217 is  atomic);
take D28 = F6(C217);
thus L578: S5[ D28 , C216 , C217 ] by L577 , L562;
end;
case L579: (( len ( @ C217 ) ) = ( C215 + 1 ) & C217 is  negative);
take D29 = F7(( C216 . ( the_argument_of C217 ) ));
thus L580: S5[ D29 , C216 , C217 ] by L579 , L562;
end;
case L581: (( len ( @ C217 ) ) = ( C215 + 1 ) & C217 is  conjunctive);
take D30 = F8(( C216 . ( the_left_argument_of C217 ) ) , ( C216 . ( the_right_argument_of C217 ) ));
thus L582: S5[ D30 , C216 , C217 ] by L581 , L562;
end;
case L583: (( len ( @ C217 ) ) = ( C215 + 1 ) & C217 is  universal);
take D31 = F9(C217 , ( C216 . ( the_scope_of C217 ) ));
thus L584: S5[ D31 , C216 , C217 ] by L583 , L562;
end;
end;
thus L586: thesis by L572;
end;
consider C218 being (Function of ( QC-WFF F3() ) , F4()) such that L587: (for B143 being (Element of ( QC-WFF F3() )) holds S8[ B143 , ( C218 . B143 ) ]) from FUNCT_2:sch 3(L571);
take D32 = C218;
thus L588: S4[ D32 , ( C215 + 1 ) ]
proof
thus L589: ( D32 . ( VERUM F3() ) ) = F5()
proof
per cases ;
suppose L590: ( len ( @ ( VERUM F3() ) ) ) <> ( C215 + 1 );

thus L591: thesis by L590 , L570 , L587;
end;
suppose L592: ( len ( @ ( VERUM F3() ) ) ) = ( C215 + 1 );

thus L593: thesis by L592 , L587;
end;
end;

let C219 being (Element of ( QC-WFF F3() ));
assume that
L595: ( len ( @ C219 ) ) <= ( C215 + 1 );
thus L596: (C219 is  atomic implies ( D32 . C219 ) = F6(C219))
proof
L597:
now
per cases ;
suppose L598: ( len ( @ C219 ) ) <> ( C215 + 1 );

L599: (( len ( @ C219 ) ) <= C215 & ( D32 . C219 ) = ( C216 . C219 )) by L598 , L587 , L595 , NAT_1:8;
thus L600: thesis by L599 , L570;
end;
suppose L601: ( len ( @ C219 ) ) = ( C215 + 1 );

thus L602: thesis by L601 , L587;
end;
end;
thus L604: thesis by L597;
end;

thus L605: (C219 is  negative implies ( D32 . C219 ) = F7(( D32 . ( the_argument_of C219 ) )))
proof
assume L606: C219 is  negative;
L607: ( len ( @ ( the_argument_of C219 ) ) ) <> ( C215 + 1 ) by L606 , L595 , L488;
L608: ( D32 . ( the_argument_of C219 ) ) = ( C216 . ( the_argument_of C219 ) ) by L607 , L587;
L609:
now
per cases ;
suppose L610: ( len ( @ C219 ) ) <> ( C215 + 1 );

L611: (( len ( @ C219 ) ) <= C215 & ( D32 . C219 ) = ( C216 . C219 )) by L610 , L587 , L595 , NAT_1:8;
thus L612: thesis by L611 , L570 , L606 , L608;
end;
suppose L613: ( len ( @ C219 ) ) = ( C215 + 1 );

thus L614: thesis by L613 , L587 , L606 , L608;
end;
end;
thus L616: thesis by L609;
end;

thus L617: (C219 is  conjunctive implies ( D32 . C219 ) = F8(( D32 . ( the_left_argument_of C219 ) ) , ( D32 . ( the_right_argument_of C219 ) )))
proof
assume L618: C219 is  conjunctive;
L619: ( len ( @ ( the_right_argument_of C219 ) ) ) <> ( C215 + 1 ) by L618 , L595 , L494;
L620: ( D32 . ( the_right_argument_of C219 ) ) = ( C216 . ( the_right_argument_of C219 ) ) by L619 , L587;
L621: ( len ( @ ( the_left_argument_of C219 ) ) ) <> ( C215 + 1 ) by L595 , L618 , L494;
L622: ( D32 . ( the_left_argument_of C219 ) ) = ( C216 . ( the_left_argument_of C219 ) ) by L621 , L587;
L623:
now
per cases ;
suppose L624: ( len ( @ C219 ) ) <> ( C215 + 1 );

L625: (( len ( @ C219 ) ) <= C215 & ( D32 . C219 ) = ( C216 . C219 )) by L624 , L587 , L595 , NAT_1:8;
thus L626: thesis by L625 , L570 , L618 , L622 , L620;
end;
suppose L627: ( len ( @ C219 ) ) = ( C215 + 1 );

thus L628: thesis by L627 , L587 , L618 , L622 , L620;
end;
end;
thus L630: thesis by L623;
end;

thus L631: (C219 is  universal implies ( D32 . C219 ) = F9(C219 , ( D32 . ( the_scope_of C219 ) )))
proof
assume L632: C219 is  universal;
L633: ( len ( @ ( the_scope_of C219 ) ) ) <> ( C215 + 1 ) by L632 , L595 , L505;
L634: ( D32 . ( the_scope_of C219 ) ) = ( C216 . ( the_scope_of C219 ) ) by L633 , L587;
L635:
now
per cases ;
suppose L636: ( len ( @ C219 ) ) <> ( C215 + 1 );

L637: (( len ( @ C219 ) ) <= C215 & ( D32 . C219 ) = ( C216 . C219 )) by L636 , L587 , L595 , NAT_1:8;
thus L638: thesis by L637 , L570 , L632 , L634;
end;
suppose L639: ( len ( @ C219 ) ) = ( C215 + 1 );

thus L640: thesis by L639 , L587 , L632 , L634;
end;
end;
thus L642: thesis by L635;
end;

end;

end;
L589: S6[ ( 0 ) ]
proof
reconsider D33 = ( ( QC-WFF F3() ) --> F5() ) as (Function of ( QC-WFF F3() ) , F4());
take D33;
thus L590: ( D33 . ( VERUM F3() ) ) = F5() by FUNCOP_1:7;
let C220 being (Element of ( QC-WFF F3() ));
assume that
L591: ( len ( @ C220 ) ) <= ( 0 );
L592: 1 <= ( len ( @ C220 ) ) by L275;
thus L593: thesis by L592 , L591 , XXREAL_0:2;
end;
L594: (for B144 being (Element of ( NAT )) holds S6[ B144 ]) from NAT_1:sch 1(L589 , L569);
L595: (ex B145 being (Function of ( QC-WFF F3() ) , F4()) st S4[ B145 , (( len ( @ ( VERUM F3() ) ) ) qua (Element of ( NAT ))) ]) by L594;
L596: (for B146 being set holds (B146 in ( QC-WFF F3() ) implies (ex B147 being set st S7[ B146 , B147 ])))
proof
let C221 being set;
assume L597: C221 in ( QC-WFF F3() );
reconsider D34 = C221 as (Element of ( QC-WFF F3() )) by L597;
consider C222 being (Function of ( QC-WFF F3() ) , F4()) such that L598: S4[ C222 , (( len ( @ D34 ) ) qua (Element of ( NAT ))) ] by L594;
take ( C222 . C221 );
take D34;
thus L599: C221 = D34;
let C223 being (Function of ( QC-WFF F3() ) , F4());
assume that
L600: S4[ C223 , (( len ( @ D34 ) ) qua (Element of ( NAT ))) ];
defpred S9[ (Element of ( QC-WFF F3() )) ] means (( len ( @ $1 ) ) <= ( len ( @ D34 ) ) implies ( C222 . $1 ) = ( C223 . $1 ));
L601:
now
let C224 being (Element of ( QC-WFF F3() ));
thus L602: (C224 is  atomic implies S9[ C224 ])
proof
assume L603: (C224 is  atomic & ( len ( @ C224 ) ) <= ( len ( @ D34 ) ));
thus L604: ( C222 . C224 ) = F6(C224) by L603 , L598
.= ( C223 . C224 ) by L600 , L603;
end;

thus L605: S9[ ( VERUM F3() ) ] by L598 , L600;
thus L606: ((C224 is  negative & S9[ ( the_argument_of C224 ) ]) implies S9[ C224 ])
proof
assume that
L607: C224 is  negative
and
L608: S9[ ( the_argument_of C224 ) ]
and
L609: ( len ( @ C224 ) ) <= ( len ( @ D34 ) );
L610: ( len ( @ ( the_argument_of C224 ) ) ) < ( len ( @ C224 ) ) by L607 , L488;
thus L611: ( C222 . C224 ) = F7(( C223 . ( the_argument_of C224 ) )) by L610 , L598 , L607 , L608 , L609 , XXREAL_0:2
.= ( C223 . C224 ) by L600 , L607 , L609;
end;

thus L612: ((C224 is  conjunctive & S9[ ( the_left_argument_of C224 ) ] & S9[ ( the_right_argument_of C224 ) ]) implies S9[ C224 ])
proof
assume that
L613: C224 is  conjunctive
and
L614: (S9[ ( the_left_argument_of C224 ) ] & S9[ ( the_right_argument_of C224 ) ])
and
L615: ( len ( @ C224 ) ) <= ( len ( @ D34 ) );
L616: (( len ( @ ( the_left_argument_of C224 ) ) ) < ( len ( @ C224 ) ) & ( len ( @ ( the_right_argument_of C224 ) ) ) < ( len ( @ C224 ) )) by L613 , L494;
thus L617: ( C222 . C224 ) = F8(( C223 . ( the_left_argument_of C224 ) ) , ( C223 . ( the_right_argument_of C224 ) )) by L616 , L598 , L613 , L614 , L615 , XXREAL_0:2
.= ( C223 . C224 ) by L600 , L613 , L615;
end;

thus L618: ((C224 is  universal & S9[ ( the_scope_of C224 ) ]) implies S9[ C224 ])
proof
assume that
L619: C224 is  universal
and
L620: S9[ ( the_scope_of C224 ) ]
and
L621: ( len ( @ C224 ) ) <= ( len ( @ D34 ) );
L622: ( len ( @ ( the_scope_of C224 ) ) ) < ( len ( @ C224 ) ) by L619 , L505;
thus L623: ( C222 . C224 ) = F9(C224 , ( C223 . ( the_scope_of C224 ) )) by L622 , L598 , L619 , L620 , L621 , XXREAL_0:2
.= ( C223 . C224 ) by L600 , L619 , L621;
end;

end;
L619: (for B148 being (Element of ( QC-WFF F3() )) holds S9[ B148 ]) from QCInd2(L601);
thus L620: thesis by L619;
end;
consider C225 being Function such that L621: ( dom C225 ) = ( QC-WFF F3() ) and L622: (for B149 being set holds (B149 in ( QC-WFF F3() ) implies S7[ B149 , ( C225 . B149 ) ])) from CLASSES1:sch 1(L596);
L623: ( rng C225 ) c= F4()
proof
let C226 being set;
assume L624: C226 in ( rng C225 );
consider C227 being set such that L625: (C227 in ( QC-WFF F3() ) & C226 = ( C225 . C227 )) by L624 , L621 , FUNCT_1:def 3;
consider C228 being (Element of ( QC-WFF F3() )) such that L626: C228 = C227 and L627: (for B150 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B150 , (( len ( @ C228 ) ) qua (Element of ( NAT ))) ] implies C226 = ( B150 . C228 ))) by L622 , L625;
consider C229 being (Function of ( QC-WFF F3() ) , F4()) such that L628: S4[ C229 , (( len ( @ C228 ) ) qua (Element of ( NAT ))) ] by L594;
L629: C226 = ( C229 . C228 ) by L627 , L628;
thus L630: thesis by L629;
end;
reconsider D35 = C225 as (Function of ( QC-WFF F3() ) , F4()) by L623 , L621 , FUNCT_2:def 1 , RELSET_1:4;
take D35;
L631: S7[ ( VERUM F3() ) , ( D35 . ( VERUM F3() ) ) ] by L622;
thus L632: ( D35 . ( VERUM F3() ) ) = F5() by L631 , L595;
let C230 being (Element of ( QC-WFF F3() ));
consider C231 being (Element of ( QC-WFF F3() )) such that L633: C231 = C230 and L634: (for B151 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B151 , (( len ( @ C231 ) ) qua (Element of ( NAT ))) ] implies ( D35 . C230 ) = ( B151 . C231 ))) by L622;
consider C232 being (Function of ( QC-WFF F3() ) , F4()) such that L635: S4[ C232 , (( len ( @ C231 ) ) qua (Element of ( NAT ))) ] by L594;
set D36 = ( the_scope_of C230 );
L636: (ex B152 being (Element of ( QC-WFF F3() )) st (B152 = D36 & (for B153 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B153 , (( len ( @ B152 ) ) qua (Element of ( NAT ))) ] implies ( D35 . D36 ) = ( B153 . B152 ))))) by L622;
L637: ( D35 . C230 ) = ( C232 . C230 ) by L633 , L634 , L635;
thus L638: (C230 is  atomic implies ( D35 . C230 ) = F6(C230)) by L637 , L633 , L635;
L639: (for B154 being (Element of ( NAT )) holds (B154 < ( len ( @ C230 ) ) implies S4[ C232 , B154 ]))
proof
let C233 being (Element of ( NAT ));
assume L640: C233 < ( len ( @ C230 ) );
thus L641: ( C232 . ( VERUM F3() ) ) = F5() by L635;
let C234 being (Element of ( QC-WFF F3() ));
assume L642: ( len ( @ C234 ) ) <= C233;
L643: ( len ( @ C234 ) ) <= ( len ( @ C230 ) ) by L642 , L640 , XXREAL_0:2;
thus L644: thesis by L643 , L633 , L635;
end;
thus L645: (C230 is  negative implies ( D35 . C230 ) = F7(( D35 . ( the_argument_of C230 ) )))
proof
set D37 = ( the_argument_of C230 );
set D38 = ( len ( @ D37 ) );
L646: (ex B155 being (Element of ( QC-WFF F3() )) st (B155 = D37 & (for B156 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B156 , (( len ( @ B155 ) ) qua (Element of ( NAT ))) ] implies ( D35 . D37 ) = ( B156 . B155 ))))) by L622;
assume L647: C230 is  negative;
L648: D38 < ( len ( @ C230 ) ) by L647 , L488;
L649: S4[ C232 , (D38 qua (Element of ( NAT ))) ] by L648 , L639;
L650: ( D35 . D37 ) = ( C232 . D37 ) by L649 , L646;
thus L651: thesis by L650 , L633 , L635 , L637 , L647;
end;

thus L652: (C230 is  conjunctive implies ( D35 . C230 ) = F8(( D35 . ( the_left_argument_of C230 ) ) , ( D35 . ( the_right_argument_of C230 ) )))
proof
set D39 = ( the_right_argument_of C230 );
set D40 = ( the_left_argument_of C230 );
set D41 = ( len ( @ D40 ) );
set D42 = ( len ( @ D39 ) );
L653: (ex B157 being (Element of ( QC-WFF F3() )) st (B157 = D39 & (for B158 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B158 , (( len ( @ B157 ) ) qua (Element of ( NAT ))) ] implies ( D35 . D39 ) = ( B158 . B157 ))))) by L622;
assume L654: C230 is  conjunctive;
L655: D41 < ( len ( @ C230 ) ) by L654 , L494;
L656: S4[ C232 , (D41 qua (Element of ( NAT ))) ] by L655 , L639;
L657: D42 < ( len ( @ C230 ) ) by L654 , L494;
L658: S4[ C232 , (D42 qua (Element of ( NAT ))) ] by L657 , L639;
L659: ( D35 . D39 ) = ( C232 . D39 ) by L658 , L653;
L660: (ex B159 being (Element of ( QC-WFF F3() )) st (B159 = D40 & (for B160 being (Function of ( QC-WFF F3() ) , F4()) holds (S4[ B160 , (( len ( @ B159 ) ) qua (Element of ( NAT ))) ] implies ( D35 . D40 ) = ( B160 . B159 ))))) by L622;
L661: ( D35 . D40 ) = ( C232 . D40 ) by L660 , L656;
thus L662: thesis by L661 , L633 , L635 , L637 , L654 , L659;
end;

set D43 = ( len ( @ D36 ) );
assume L663: C230 is  universal;
L664: D43 < ( len ( @ C230 ) ) by L663 , L505;
L665: S4[ C232 , (D43 qua (Element of ( NAT ))) ] by L664 , L639;
L666: ( D35 . D36 ) = ( C232 . D36 ) by L665 , L636;
thus L667: thesis by L666 , L633 , L635 , L637 , L663;
end;
definition
let C235 being QC-alphabet;
let C236 being (FinSequence of ( QC-variables C235 ));
func still_not-bound_in C236 -> (Subset of ( bound_QC-variables C235 )) equals 
{ ( C236 . R15 ) where R15 is (Element of ( NAT )) : (1 <= R15 & R15 <= ( len C236 ) & ( C236 . R15 ) in ( bound_QC-variables C235 )) };
coherence
proof
set D44 = { ( C236 . R15 ) where R15 is (Element of ( NAT )) : (1 <= R15 & R15 <= ( len C236 ) & ( C236 . R15 ) in ( bound_QC-variables C235 )) };
L668:
now
let C237 being set;
assume L669: C237 in D44;
L670: (ex B161 being (Element of ( NAT )) st (C237 = ( C236 . B161 ) & 1 <= B161 & B161 <= ( len C236 ) & ( C236 . B161 ) in ( bound_QC-variables C235 ))) by L669;
thus L671: C237 in ( bound_QC-variables C235 ) by L670;
end;
thus L672: thesis by L668 , TARSKI:def 3;
end;
end;
definition
let C238 being QC-alphabet;
let C239 being (QC-formula of C238);
func still_not-bound_in C239 -> (Subset of ( bound_QC-variables C238 )) means 
(ex B162 being (Function of ( QC-WFF C238 ) , ( bool ( bound_QC-variables C238 ) )) st (it = ( B162 . C239 ) & (for B163 being (Element of ( QC-WFF C238 )) holds (( B162 . ( VERUM C238 ) ) = ( {} ) & (B163 is  atomic implies ( B162 . B163 ) = { ( ( the_arguments_of B163 ) . R16 ) where R16 is (Element of ( NAT )) : (1 <= R16 & R16 <= ( len ( the_arguments_of B163 ) ) & ( ( the_arguments_of B163 ) . R16 ) in ( bound_QC-variables C238 )) }) & (B163 is  negative implies ( B162 . B163 ) = ( B162 . ( the_argument_of B163 ) )) & (B163 is  conjunctive implies ( B162 . B163 ) = ( ( B162 . ( the_left_argument_of B163 ) ) \/ ( B162 . ( the_right_argument_of B163 ) ) )) & (B163 is  universal implies ( B162 . B163 ) = ( ( B162 . ( the_scope_of B163 ) ) \ { ( bound_in B163 ) } ))))));
existence
proof
deffunc H1((Element of ( QC-WFF C238 )) , (Subset of ( bound_QC-variables C238 ))) = ( $2 \ { ( bound_in $1 ) } );
deffunc H2((Subset of ( bound_QC-variables C238 )) , (Subset of ( bound_QC-variables C238 ))) = ( $1 \/ $2 );
deffunc H3((Subset of ( bound_QC-variables C238 ))) = $1;
deffunc H4((Element of ( QC-WFF C238 ))) = ( still_not-bound_in ( the_arguments_of $1 ) );
reconsider D45 = ( {} ) as (Subset of ( bound_QC-variables C238 )) by XBOOLE_1:2;
consider C240 being (Function of ( QC-WFF C238 ) , ( bool ( bound_QC-variables C238 ) )) such that L674: (( C240 . ( VERUM C238 ) ) = D45 & (for B164 being (Element of ( QC-WFF C238 )) holds ((B164 is  atomic implies ( C240 . B164 ) = H4(B164)) & (B164 is  negative implies ( C240 . B164 ) = H3(( C240 . ( the_argument_of B164 ) ))) & (B164 is  conjunctive implies ( C240 . B164 ) = H2(( C240 . ( the_left_argument_of B164 ) ) , ( C240 . ( the_right_argument_of B164 ) ))) & (B164 is  universal implies ( C240 . B164 ) = H1(B164 , ( C240 . ( the_scope_of B164 ) )))))) from QCFuncEx;
take ( C240 . C239 );
take C240;
thus L675: ( C240 . C239 ) = ( C240 . C239 );
let C241 being (Element of ( QC-WFF C238 ));
thus L676: ( C240 . ( VERUM C238 ) ) = ( {} ) by L674;
thus L677: (C241 is  atomic implies ( C240 . C241 ) = { ( ( the_arguments_of C241 ) . R16 ) where R16 is (Element of ( NAT )) : (1 <= R16 & R16 <= ( len ( the_arguments_of C241 ) ) & ( ( the_arguments_of C241 ) . R16 ) in ( bound_QC-variables C238 )) })
proof
assume L678: C241 is  atomic;
L679: ( C240 . C241 ) = ( still_not-bound_in ( the_arguments_of C241 ) ) by L678 , L674;
thus L680: thesis by L679;
end;

thus L681: (C241 is  negative implies ( C240 . C241 ) = ( C240 . ( the_argument_of C241 ) )) by L674;
thus L682: (C241 is  conjunctive implies ( C240 . C241 ) = ( ( C240 . ( the_left_argument_of C241 ) ) \/ ( C240 . ( the_right_argument_of C241 ) ) )) by L674;
assume L683: C241 is  universal;
thus L684: thesis by L683 , L674;
end;
uniqueness
proof
let C242 , C243 being (Subset of ( bound_QC-variables C238 ));
given C244 being (Function of ( QC-WFF C238 ) , ( bool ( bound_QC-variables C238 ) )) such that
L685: C242 = ( C244 . C239 )
and
L686: (for B165 being (Element of ( QC-WFF C238 )) holds (( C244 . ( VERUM C238 ) ) = ( {} ) & (B165 is  atomic implies ( C244 . B165 ) = { ( ( the_arguments_of B165 ) . R16 ) where R16 is (Element of ( NAT )) : (1 <= R16 & R16 <= ( len ( the_arguments_of B165 ) ) & ( ( the_arguments_of B165 ) . R16 ) in ( bound_QC-variables C238 )) }) & (B165 is  negative implies ( C244 . B165 ) = ( C244 . ( the_argument_of B165 ) )) & (B165 is  conjunctive implies ( C244 . B165 ) = ( ( C244 . ( the_left_argument_of B165 ) ) \/ ( C244 . ( the_right_argument_of B165 ) ) )) & (B165 is  universal implies ( C244 . B165 ) = ( ( C244 . ( the_scope_of B165 ) ) \ { ( bound_in B165 ) } ))));

given C245 being (Function of ( QC-WFF C238 ) , ( bool ( bound_QC-variables C238 ) )) such that
L687: C243 = ( C245 . C239 )
and
L688: (for B166 being (Element of ( QC-WFF C238 )) holds (( C245 . ( VERUM C238 ) ) = ( {} ) & (B166 is  atomic implies ( C245 . B166 ) = { ( ( the_arguments_of B166 ) . R16 ) where R16 is (Element of ( NAT )) : (1 <= R16 & R16 <= ( len ( the_arguments_of B166 ) ) & ( ( the_arguments_of B166 ) . R16 ) in ( bound_QC-variables C238 )) }) & (B166 is  negative implies ( C245 . B166 ) = ( C245 . ( the_argument_of B166 ) )) & (B166 is  conjunctive implies ( C245 . B166 ) = ( ( C245 . ( the_left_argument_of B166 ) ) \/ ( C245 . ( the_right_argument_of B166 ) ) )) & (B166 is  universal implies ( C245 . B166 ) = ( ( C245 . ( the_scope_of B166 ) ) \ { ( bound_in B166 ) } ))));

defpred S10[ (Element of ( QC-WFF C238 )) ] means ( C244 . $1 ) = ( C245 . $1 );
L689: (for B167 being (Element of ( NAT )) holds (for B168 being (QC-pred_symbol of B167 , C238) holds (for B169 being (QC-variable_list of B167 , C238) holds S10[ ( B168 ! B169 ) ])))
proof
let C246 being (Element of ( NAT ));
let C247 being (QC-pred_symbol of C246 , C238);
let C248 being (QC-variable_list of C246 , C238);
L690: ( C247 ! C248 ) is  atomic by L263;
L691: ( the_arguments_of ( C247 ! C248 ) ) = C248 by L690 , L433;
thus L692: ( C244 . ( C247 ! C248 ) ) = { ( C248 . R14 ) where R14 is (Element of ( NAT )) : (1 <= R14 & R14 <= ( len C248 ) & ( C248 . R14 ) in ( bound_QC-variables C238 )) } by L691 , L686 , L690
.= ( C245 . ( C247 ! C248 ) ) by L688 , L690 , L691;
end;
L693: (for B170 being (Element of ( QC-WFF C238 )) holds (S10[ B170 ] implies S10[ ( 'not' B170 ) ]))
proof
let C249 being (Element of ( QC-WFF C238 ));
assume that
L694: ( C244 . C249 ) = ( C245 . C249 );
L695: ( 'not' C249 ) is  negative by L264;
L696: ( the_argument_of ( 'not' C249 ) ) = C249 by L695 , L446;
thus L697: ( C244 . ( 'not' C249 ) ) = ( C245 . C249 ) by L696 , L686 , L694 , L695
.= ( C245 . ( 'not' C249 ) ) by L688 , L695 , L696;
end;
L698: (for B171 being (bound_QC-variable of C238) holds (for B172 being (Element of ( QC-WFF C238 )) holds (S10[ B172 ] implies S10[ ( All (B171 , B172) ) ])))
proof
let C250 being (bound_QC-variable of C238);
let C251 being (Element of ( QC-WFF C238 ));
assume that
L699: ( C244 . C251 ) = ( C245 . C251 );
L700: ( All (C250 , C251) ) is  universal by L266;
L701: (( the_scope_of ( All (C250 , C251) ) ) = C251 & ( bound_in ( All (C250 , C251) ) ) = C250) by L700 , L472 , L478;
thus L702: ( C244 . ( All (C250 , C251) ) ) = ( ( C245 . C251 ) \ { C250 } ) by L701 , L686 , L699 , L700
.= ( C245 . ( All (C250 , C251) ) ) by L688 , L700 , L701;
end;
L703: (for B173 , B174 being (Element of ( QC-WFF C238 )) holds ((S10[ B173 ] & S10[ B174 ]) implies S10[ ( B173 '&' B174 ) ]))
proof
let C252 , C253 being (Element of ( QC-WFF C238 ));
assume that
L704: (( C244 . C252 ) = ( C245 . C252 ) & ( C244 . C253 ) = ( C245 . C253 ));
L705: ( C252 '&' C253 ) is  conjunctive by L265;
L706: (( the_left_argument_of ( C252 '&' C253 ) ) = C252 & ( the_right_argument_of ( C252 '&' C253 ) ) = C253) by L705 , L449 , L461;
thus L707: ( C244 . ( C252 '&' C253 ) ) = ( ( C245 . C252 ) \/ ( C245 . C253 ) ) by L706 , L686 , L704 , L705
.= ( C245 . ( C252 '&' C253 ) ) by L688 , L705 , L706;
end;
L708: S10[ ( VERUM C238 ) ] by L686 , L688;
L709: (for B175 being (Element of ( QC-WFF C238 )) holds S10[ B175 ]) from QCInd(L689 , L708 , L693 , L703 , L698);
thus L710: thesis by L709 , L685 , L687;
end;
end;
definition
let C254 being QC-alphabet;
let C255 being (QC-formula of C254);
attr C255 is  closed
means
( still_not-bound_in C255 ) = ( {} );
end;
definition
let R1 being QC-alphabet;
mode Relation of R1
 -> Relation
means :L713: it well_orders ( ( QC-symbols R1 ) \ ( NAT ) );
existence by WELLORD2:17;
end;
definition
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
pred R17 <= R18
means
:L715: (ex R3 being (Element of ( NAT )) st (ex R4 being (Element of ( NAT )) st (R3 = R17 & R4 = R18 & R3 <= R4))) if (R17 in ( NAT ) & R18 in ( NAT )) , [ R17 , R18 ] in the (Relation of R1) if ((not R17 in ( NAT )) & (not R18 in ( NAT ))) otherwise R18 in ( NAT )
;consistency;
end;
definition
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
pred R17 < R18
means
:L717: (R17 <= R18 & R17 <> R18)
;end;
theorem
L719: (for R1 being QC-alphabet holds (for R17 being (QC-symbol of R1) holds (for R18 being (QC-symbol of R1) holds (for R19 being (QC-symbol of R1) holds ((R17 <= R18 & R18 <= R19) implies R17 <= R19)))))
proof
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
let R19 being (QC-symbol of R1);
set D46 = the (Relation of R1);
L720: D46 well_orders ( ( QC-symbols R1 ) \ ( NAT ) ) by L713;
L721: D46 is_transitive_in ( ( QC-symbols R1 ) \ ( NAT ) ) by L720 , WELLORD1:def 5;
assume L722: (R17 <= R18 & R18 <= R19);
per cases ;
suppose L723: R17 in ( NAT );

L724: R18 in ( NAT ) by L723 , L722 , L715;
L725: R19 in ( NAT ) by L724 , L722 , L715;
consider R4 being (Element of ( NAT )), R3 being (Element of ( NAT )) such that L726: (R17 = R4 & R18 = R3 & R4 <= R3) by L722 , L723 , L724 , L715;
consider R16 being (Element of ( NAT )), R14 being (Element of ( NAT )) such that L727: (R18 = R16 & R19 = R14 & R16 <= R14) by L722 , L724 , L725 , L715;
L728: R4 <= R14 by L726 , L727 , XXREAL_0:2;
thus L729: thesis by L728 , L726 , L727 , L715;
end;
suppose L730: (not R17 in ( NAT ));

per cases ;
suppose L731: R18 in ( NAT );

L732: R19 in ( NAT ) by L731 , L722 , L715;
thus L733: thesis by L732 , L730 , L715;
end;
suppose L734: (not R18 in ( NAT ));

per cases ;
suppose L735: R19 in ( NAT );

thus L736: thesis by L735 , L730 , L715;
end;
suppose L737: (not R19 in ( NAT ));

L738: (R17 in ( ( QC-symbols R1 ) \ ( NAT ) ) & R18 in ( ( QC-symbols R1 ) \ ( NAT ) ) & R19 in ( ( QC-symbols R1 ) \ ( NAT ) )) by L737 , L730 , L734 , XBOOLE_0:def 5;
L739: ([ R17 , R18 ] in D46 & [ R18 , R19 ] in D46) by L722 , L730 , L734 , L737 , L715;
L740: [ R17 , R19 ] in D46 by L739 , L721 , L738 , RELAT_2:def 8;
thus L741: thesis by L740 , L730 , L737 , L715;
end;
end;
end;
end;
theorem
L745: (for R1 being QC-alphabet holds (for R18 being (QC-symbol of R1) holds R18 <= R18))
proof
let R1 being QC-alphabet;
let R18 being (QC-symbol of R1);
set D47 = the (Relation of R1);
L746: D47 well_orders ( ( QC-symbols R1 ) \ ( NAT ) ) by L713;
L747: D47 is_reflexive_in ( ( QC-symbols R1 ) \ ( NAT ) ) by L746 , WELLORD1:def 5;
per cases ;
suppose L748: R18 in ( NAT );

thus L749: thesis by L748 , L715;
end;
suppose L750: (not R18 in ( NAT ));

L751: R18 in ( ( QC-symbols R1 ) \ ( NAT ) ) by L750 , XBOOLE_0:def 5;
L752: [ R18 , R18 ] in the (Relation of R1) by L751 , L747 , RELAT_2:def 1;
thus L753: thesis by L752 , L750 , L715;
end;
end;
theorem
L755: (for R1 being QC-alphabet holds (for R18 being (QC-symbol of R1) holds (for R19 being (QC-symbol of R1) holds ((R18 <= R19 & R19 <= R18) implies R19 = R18))))
proof
let R1 being QC-alphabet;
let R18 being (QC-symbol of R1);
let R19 being (QC-symbol of R1);
set D48 = the (Relation of R1);
L756: D48 well_orders ( ( QC-symbols R1 ) \ ( NAT ) ) by L713;
L757: D48 is_antisymmetric_in ( ( QC-symbols R1 ) \ ( NAT ) ) by L756 , WELLORD1:def 5;
assume L758: (R18 <= R19 & R19 <= R18);
per cases ;
suppose L759: (R18 in ( NAT ) & R19 in ( NAT ));

consider R3 being (Element of ( NAT )), R4 being (Element of ( NAT )) such that L760: (R18 = R3 & R19 = R4 & R3 <= R4) by L759 , L758 , L715;
consider R16 being (Element of ( NAT )), R14 being (Element of ( NAT )) such that L761: (R19 = R16 & R18 = R14 & R16 <= R14) by L758 , L759 , L715;
thus L762: thesis by L760 , L761 , XXREAL_0:1;
end;
suppose L763: ((not R18 in ( NAT )) or (not R19 in ( NAT )));

per cases  by L763;
suppose L764: (not R18 in ( NAT ));

L765: ((not R18 in ( NAT )) & (not R19 in ( NAT ))) by L764 , L758 , L715;
L766: (R18 in ( ( QC-symbols R1 ) \ ( NAT ) ) & R19 in ( ( QC-symbols R1 ) \ ( NAT ) )) by L765 , XBOOLE_0:def 5;
L767: ([ R18 , R19 ] in D48 & [ R19 , R18 ] in D48) by L758 , L765 , L715;
thus L768: R19 = R18 by L767 , L757 , L766 , RELAT_2:def 4;
end;
suppose L769: (not R19 in ( NAT ));

L770: ((not R18 in ( NAT )) & (not R19 in ( NAT ))) by L769 , L758 , L715;
L771: (R18 in ( ( QC-symbols R1 ) \ ( NAT ) ) & R19 in ( ( QC-symbols R1 ) \ ( NAT ) )) by L770 , XBOOLE_0:def 5;
L772: ([ R18 , R19 ] in D48 & [ R19 , R18 ] in D48) by L758 , L770 , L715;
thus L773: R19 = R18 by L772 , L757 , L771 , RELAT_2:def 4;
end;
end;
end;
theorem
L776: (for R1 being QC-alphabet holds (for R18 being (QC-symbol of R1) holds (for R19 being (QC-symbol of R1) holds (R18 <= R19 or R19 <= R18))))
proof
let R1 being QC-alphabet;
let R18 being (QC-symbol of R1);
let R19 being (QC-symbol of R1);
set D49 = the (Relation of R1);
L777: D49 well_orders ( ( QC-symbols R1 ) \ ( NAT ) ) by L713;
L778: (D49 is_connected_in ( ( QC-symbols R1 ) \ ( NAT ) ) & D49 is_reflexive_in ( ( QC-symbols R1 ) \ ( NAT ) )) by L777 , WELLORD1:def 5;
L779: D49 is_strongly_connected_in ( ( QC-symbols R1 ) \ ( NAT ) ) by L778 , ORDERS_1:7;
per cases ;
suppose L780: (R18 in ( NAT ) & R19 in ( NAT ));

consider R3 being (Element of ( NAT )), R4 being (Element of ( NAT )) such that L781: (R3 = R18 & R4 = R19) by L780;
L782: (R3 <= R4 or R4 <= R3);
thus L783: thesis by L782 , L781 , L715;
end;
suppose L784: ((not R18 in ( NAT )) or (not R19 in ( NAT )));

per cases  by L784;
suppose L785: (not R18 in ( NAT ));

per cases ;
suppose L786: R19 in ( NAT );

thus L787: thesis by L786 , L785 , L715;
end;
suppose L788: (not R19 in ( NAT ));

L789: (R18 in ( ( QC-symbols R1 ) \ ( NAT ) ) & R19 in ( ( QC-symbols R1 ) \ ( NAT ) )) by L788 , L785 , XBOOLE_0:def 5;
L790: ([ R18 , R19 ] in D49 or [ R19 , R18 ] in D49) by L789 , L779 , RELAT_2:def 7;
thus L791: thesis by L790 , L785 , L788 , L715;
end;
end;
suppose L793: (not R19 in ( NAT ));

per cases ;
suppose L794: R18 in ( NAT );

thus L795: thesis by L794 , L793 , L715;
end;
suppose L796: (not R18 in ( NAT ));

L797: (R18 in ( ( QC-symbols R1 ) \ ( NAT ) ) & R19 in ( ( QC-symbols R1 ) \ ( NAT ) )) by L796 , L793 , XBOOLE_0:def 5;
L798: ([ R19 , R18 ] in D49 or [ R18 , R19 ] in D49) by L797 , L779 , RELAT_2:def 7;
thus L799: thesis by L798 , L793 , L796 , L715;
end;
end;
end;
end;
theorem
L803: (for R1 being QC-alphabet holds (for R17 being (QC-symbol of R1) holds (for R18 being (QC-symbol of R1) holds (R17 < R18 iff (not R18 <= R17)))))
proof
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
thus L804: (R17 < R18 implies (not R18 <= R17))
proof
assume L805: R17 < R18;
L806: (R17 <= R18 & (not R17 = R18)) by L805 , L717;
assume L807: R18 <= R17;
thus L808: contradiction by L807 , L806 , L755;
end;

assume L809: (not R18 <= R17);
L810: (R17 <= R18 & (not R18 = R17)) by L809 , L776;
thus L811: thesis by L810 , L717;
end;
theorem
L812: (for R1 being QC-alphabet holds (for R17 being (QC-symbol of R1) holds (for R18 being (QC-symbol of R1) holds (R17 < R18 or R17 = R18 or R18 < R17))))
proof
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
assume L813: ((not R17 < R18) & (not R17 = R18));
L814: (R18 <= R17 & (not R17 = R18)) by L813 , L803;
thus L815: R18 < R17 by L814 , L717;
end;
definition
let R1 being QC-alphabet;
let C256 being non  empty (Subset of ( QC-symbols R1 ));
func min C256 -> (QC-symbol of R1) means 
:L816: (it in C256 & (for R18 being (QC-symbol of R1) holds (R18 in C256 implies it <= R18)));
existence
proof
per cases ;
suppose L817: C256 c= ( NAT );

reconsider D50 = C256 as non  empty (Subset of ( NAT )) by L817;
set D51 = ( min* D50 );
L818: ( NAT ) c= ( QC-symbols R1 ) by L16;
reconsider D52 = D51 as (QC-symbol of R1) by L818 , TARSKI:def 3;
take D52;
L819: (for R18 being (QC-symbol of R1) holds (R18 in D50 implies D52 <= R18))
proof
let R18 being (QC-symbol of R1);
assume L820: R18 in D50;
reconsider D53 = R18 as Nat by L820;
L821: D51 <= D53 by L820 , NAT_1:def 1;
thus L822: thesis by L821 , L820 , L715;
end;
thus L823: thesis by L819 , NAT_1:def 1;
end;
suppose L824: (not C256 c= ( NAT ));

consider C257 being set such that L825: (C257 in C256 & (not C257 in ( NAT ))) by L824 , TARSKI:def 3;
set D54 = the (Relation of R1);
L826: (D54 well_orders ( ( QC-symbols R1 ) \ ( NAT ) ) & ( C256 \ ( NAT ) ) <> ( {} )) by L825 , XBOOLE_0:def 5 , L713;
consider C258 being set such that L827: (C258 in ( C256 \ ( NAT ) ) & (for B176 being set holds (B176 in ( C256 \ ( NAT ) ) implies [ C258 , B176 ] in D54))) by L826 , XBOOLE_1:33 , WELLORD1:5;
reconsider D55 = C258 as (QC-symbol of R1) by L827;
L828: ((not D55 in ( NAT )) & D55 in C256) by L827 , XBOOLE_0:def 5;
L829: (for R17 being (QC-symbol of R1) holds (R17 in C256 implies D55 <= R17))
proof
let R17 being (QC-symbol of R1);
assume L830: R17 in C256;
per cases ;
suppose L831: R17 in ( NAT );

thus L832: thesis by L831 , L828 , L715;
end;
suppose L833: (not R17 in ( NAT ));

L834: R17 in ( C256 \ ( NAT ) ) by L833 , L830 , XBOOLE_0:def 5;
L835: [ D55 , R17 ] in D54 by L834 , L827;
thus L836: thesis by L835 , L828 , L833 , L715;
end;
end;
thus L838: thesis by L829 , L828;
end;
end;
uniqueness
proof
let R18 being (QC-symbol of R1);
let R19 being (QC-symbol of R1);
assume that
L840: (R18 in C256 & (for R17 being (QC-symbol of R1) holds (R17 in C256 implies R18 <= R17)) & R19 in C256 & (for R17 being (QC-symbol of R1) holds (R17 in C256 implies R19 <= R17)));
L841: (R18 <= R19 & R19 <= R18) by L840;
thus L842: thesis by L841 , L755;
end;
end;
definition
let R1 being QC-alphabet;
func 0 R1 -> (QC-symbol of R1) means 
(for R18 being (QC-symbol of R1) holds it <= R18);
existence
proof
L844: ( QC-symbols R1 ) c= ( QC-symbols R1 );
reconsider D56 = ( QC-symbols R1 ) as non  empty (Subset of ( QC-symbols R1 )) by L844;
set D57 = ( min D56 );
take D57;
thus L845: thesis by L816;
end;
uniqueness
proof
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
assume that
L846: ((for R19 being (QC-symbol of R1) holds R17 <= R19) & (for R19 being (QC-symbol of R1) holds R18 <= R19));
L847: (R17 <= R18 & R18 <= R17) by L846;
thus L848: thesis by L847 , L755;
end;
end;
definition
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
func Seg R17 -> non  empty (Subset of ( QC-symbols R1 )) equals 
{ R18 where R18 is (QC-symbol of R1) : R17 < R18 };
coherence
proof
set D58 = { R18 where R18 is (QC-symbol of R1) : R17 < R18 };
L850: D58 c= ( QC-symbols R1 )
proof
let C259 being set;
assume L851: C259 in D58;
consider R18 being (QC-symbol of R1) such that L852: (C259 = R18 & R17 < R18) by L851;
thus L853: thesis by L852;
end;
L854: (ex B177 being set st B177 in D58)
proof
per cases ;
suppose L855: R17 in ( NAT );

consider R3 being (Element of ( NAT )) such that L856: R17 = R3 by L855;
reconsider D59 = ( R3 + 1 ) as (Element of ( NAT ));
L857: ( NAT ) c= ( QC-symbols R1 ) by L16;
reconsider D60 = D59 as (QC-symbol of R1) by L857 , TARSKI:def 3;
L858: ((not R3 = D59) & R3 <= D59) by NAT_1:19;
L859: (R17 <= D60 & (not R17 = D60)) by L858 , L856 , L715;
L860: R17 < D60 by L859 , L717;
L861: D60 in { R18 where R18 is (QC-symbol of R1) : R17 < R18 } by L860;
thus L862: thesis by L861;
end;
suppose L863: (not R17 in ( NAT ));

reconsider D61 = ( 0 ) as (QC-symbol of R1) by L16;
L864: ((not R17 = D61) & R17 <= D61) by L863 , L715;
L865: R17 < D61 by L864 , L717;
L866: D61 in D58 by L865;
thus L867: thesis by L866;
end;
end;
thus L869: thesis by L854 , L850;
end;
end;
definition
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
func R17 ++ -> (QC-symbol of R1) equals 
( min ( Seg R17 ) );
coherence;
end;
theorem
L872: (for R1 being QC-alphabet holds (for R17 being (QC-symbol of R1) holds R17 < ( R17 ++ )))
proof
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
L873: ( R17 ++ ) in ( Seg R17 ) by L816;
consider R18 being (QC-symbol of R1) such that L874: (R18 = ( R17 ++ ) & R17 < R18) by L873;
thus L875: thesis by L874;
end;
theorem
L876: (for R1 being QC-alphabet holds (for B178 , B179 being non  empty (Subset of ( QC-symbols R1 )) holds (B178 c= B179 implies ( min B179 ) <= ( min B178 ))))
proof
let R1 being QC-alphabet;
let C260 , C261 being non  empty (Subset of ( QC-symbols R1 ));
assume that
L877: C260 c= C261;
L878: ( min C260 ) in C260 by L816;
thus L879: ( min C261 ) <= ( min C260 ) by L878 , L877 , L816;
end;
theorem
L880: (for R1 being QC-alphabet holds (for R17 being (QC-symbol of R1) holds (for R18 being (QC-symbol of R1) holds (for R20 being (QC-symbol of R1) holds ((R17 <= R18 & R18 < R20) implies R17 < R20)))))
proof
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
let R20 being (QC-symbol of R1);
assume L881: (R17 <= R18 & R18 < R20);
L882: (R17 <= R18 & R18 <= R20) by L881 , L717;
L883: R17 <= R20 by L882 , L719;
L884: (not R17 = R20) by L881 , L803;
thus L885: thesis by L884 , L883 , L717;
end;
theorem
L886: (for R1 being QC-alphabet holds (for R17 being (QC-symbol of R1) holds (for R18 being (QC-symbol of R1) holds (for R20 being (QC-symbol of R1) holds ((R17 < R18 & R18 <= R20) implies R17 < R20)))))
proof
let R1 being QC-alphabet;
let R17 being (QC-symbol of R1);
let R18 being (QC-symbol of R1);
let R20 being (QC-symbol of R1);
assume L887: (R17 < R18 & R18 <= R20);
L888: (R17 <= R18 & R18 <= R20) by L887 , L717;
L889: R17 <= R20 by L888 , L719;
L890: (not R17 = R20) by L887 , L803;
thus L891: thesis by L890 , L889 , L717;
end;
definition
let R1 being QC-alphabet;
let C262 being set;
func C262 @ R1 -> (QC-symbol of R1) equals 
:L892: C262 if C262 is (QC-symbol of R1) otherwise ( 0 );
correctness by L16;
end;
definition
let R1 being QC-alphabet;
let R18 being (QC-symbol of R1);
let R3 being (Element of ( NAT ));
func R18 + R3 -> (QC-symbol of R1) means 
:L894: (ex B180 being (Function of ( NAT ) , ( QC-symbols R1 )) st (it = ( B180 . R3 ) & ( B180 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( B180 . ( R16 + 1 ) ) = ( ( B180 . R16 ) ++ ))));
existence
proof
deffunc H5(set , set) = ( ( $2 @ R1 ) ++ );
consider C263 being (Function of ( NAT ) , ( QC-symbols R1 )) such that L895: (( C263 . ( 0 ) ) = R18 & (for B181 being Nat holds ( C263 . ( B181 + 1 ) ) = H5(B181 , ( C263 . B181 )))) from NAT_1:sch 12;
take ( C263 . R3 );
L896: (for R16 being (Element of ( NAT )) holds ( C263 . ( R16 + 1 ) ) = ( ( C263 . R16 ) ++ ))
proof
let R16 being (Element of ( NAT ));
L897: (( ( C263 . R16 ) ++ ) = H5(R16 , ( C263 . R16 )) & H5(R16 , ( C263 . R16 )) = ( C263 . ( R16 + 1 ) )) by L895 , L892;
thus L898: thesis by L897;
end;
thus L899: thesis by L896 , L895;
end;
uniqueness
proof
let R19 being (QC-symbol of R1);
let R20 being (QC-symbol of R1);
assume that
L900: ((ex B182 being (Function of ( NAT ) , ( QC-symbols R1 )) st (( B182 . R3 ) = R19 & ( B182 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( B182 . ( R16 + 1 ) ) = ( ( B182 . R16 ) ++ )))) & (ex B183 being (Function of ( NAT ) , ( QC-symbols R1 )) st (( B183 . R3 ) = R20 & ( B183 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( B183 . ( R16 + 1 ) ) = ( ( B183 . R16 ) ++ )))));
consider C264 being (Function of ( NAT ) , ( QC-symbols R1 )) such that L901: (( C264 . R3 ) = R19 & ( C264 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( C264 . ( R16 + 1 ) ) = ( ( C264 . R16 ) ++ ))) by L900;
consider C265 being (Function of ( NAT ) , ( QC-symbols R1 )) such that L902: (( C265 . R3 ) = R20 & ( C265 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( C265 . ( R16 + 1 ) ) = ( ( C265 . R16 ) ++ ))) by L900;
defpred S11[ (Element of ( NAT )) ] means ( C264 . $1 ) = ( C265 . $1 );
L903: S11[ ( 0 ) ] by L901 , L902;
L904: (for R16 being (Element of ( NAT )) holds (S11[ R16 ] implies S11[ ( R16 + 1 ) ]))
proof
let R16 being (Element of ( NAT ));
assume L905: S11[ R16 ];
thus L906: ( C264 . ( R16 + 1 ) ) = ( ( C264 . R16 ) ++ ) by L901
.= ( C265 . ( R16 + 1 ) ) by L902 , L905;
end;
L907: (for R16 being (Element of ( NAT )) holds S11[ R16 ]) from NAT_1:sch 1(L903 , L904);
thus L908: thesis by L907 , L901 , L902;
end;
end;
theorem
L910: (for R1 being QC-alphabet holds (for R3 being (Element of ( NAT )) holds (for R18 being (QC-symbol of R1) holds R18 <= ( R18 + R3 ))))
proof
let R1 being QC-alphabet;
let R3 being (Element of ( NAT ));
let R18 being (QC-symbol of R1);
defpred S12[ (Element of ( NAT )) ] means R18 <= ( R18 + $1 );
L911: S12[ ( 0 ) ]
proof
consider C266 being (Function of ( NAT ) , ( QC-symbols R1 )) such that L912: (( R18 + ( 0 ) ) = ( C266 . ( 0 ) ) & ( C266 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( C266 . ( R16 + 1 ) ) = ( ( C266 . R16 ) ++ ))) by L894;
thus L913: thesis by L912 , L745;
end;
L914: (for R16 being (Element of ( NAT )) holds (S12[ R16 ] implies S12[ ( R16 + 1 ) ]))
proof
let R16 being (Element of ( NAT ));
assume that
L915: R18 <= ( R18 + R16 );
consider C267 being (Function of ( NAT ) , ( QC-symbols R1 )) such that L916: (( R18 + ( R16 + 1 ) ) = ( C267 . ( R16 + 1 ) ) & ( C267 . ( 0 ) ) = R18 & (for R16 being (Element of ( NAT )) holds ( C267 . ( R16 + 1 ) ) = ( ( C267 . R16 ) ++ ))) by L894;
L917: ( C267 . R16 ) = ( R18 + R16 ) by L916 , L894;
L918: ( C267 . ( R16 + 1 ) ) = ( ( R18 + R16 ) ++ ) by L917 , L916;
L919: R18 < ( R18 + ( R16 + 1 ) ) by L918 , L916 , L915 , L872 , L880;
thus L920: thesis by L919 , L717;
end;
L921: (for R3 being (Element of ( NAT )) holds S12[ R3 ]) from NAT_1:sch 1(L911 , L914);
thus L922: thesis by L921;
end;
definition
let R1 being QC-alphabet;
let C268 being set;
func R1 -one_in C268 -> (QC-symbol of R1) equals 
the (Element of C268) if C268 is non  empty non  empty non  empty non  empty (Subset of ( QC-symbols R1 )) otherwise ( 0 R1 );
coherence
proof
thus L923: (C268 is non  empty non  empty non  empty non  empty (Subset of ( QC-symbols R1 )) implies the (Element of C268) is (QC-symbol of R1))
proof
assume L924: C268 is non  empty non  empty non  empty non  empty (Subset of ( QC-symbols R1 ));
consider C269 being set such that L925: C269 = the (Element of C268);
L926: C269 in C268 by L924 , L925;
L927: C269 is (QC-symbol of R1) by L924 , L926;
thus L928: thesis by L927 , L925;
end;

thus L929: ((not C268 is non  empty non  empty non  empty non  empty (Subset of ( QC-symbols R1 ))) implies ( 0 R1 ) is (QC-symbol of R1));
end;
consistency;
end;
