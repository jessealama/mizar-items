:: Atlas of Midpoint Algebra
::  by Micha{\l} Muzalewski
::
:: Received June 21, 1991
:: Copyright (c) 1991-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ALGSTR_0, SUBSET_1, MIDSP_1, PRE_TOPC, FUNCT_1,
      ZFMISC_1, STRUCT_0, ROBBINS1, ARYTM_3, QC_LANG1, RLVECT_1, SUPINF_2,
      ARYTM_1, VECTSP_1, RLVECT_2, BINOP_1, MIDSP_2, NAT_1;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, FUNCT_2, BINOP_1, DOMAIN_1, STRUCT_0,
      ALGSTR_0, PRE_TOPC, RLVECT_1, VECTSP_1, MIDSP_1;
 constructors BINOP_1, DOMAIN_1, VECTSP_1, MIDSP_1, RLVECT_1;
 registrations XBOOLE_0, RELSET_1, STRUCT_0, VECTSP_1, MIDSP_1;
 requirements SUBSET, BOOLE;
 definitions STRUCT_0, VECTSP_1;
 theorems BINOP_1, MIDSP_1, RLVECT_1, VECTSP_1;
 schemes BINOP_1;

begin
definition
let R1 being non  empty addLoopStr;
let R2 being (Element of R1);
func Double R2 -> (Element of R1) equals 
( R2 + R2 );
coherence;
end;
definition
let R3 being non  empty MidStr;
let R1 being non  empty addLoopStr;
let R7 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R1));
attr R7 is  associating
means
:L2: (for R4 being (Point of R3) holds (for R5 being (Point of R3) holds (for R6 being (Point of R3) holds (( R4 @ R5 ) = R6 iff ( R7 . (R4 , R6) ) = ( R7 . (R6 , R5) )))));
end;
theorem
L4: (for R1 being non  empty addLoopStr holds (for R3 being non  empty MidStr holds (for R4 being (Point of R3) holds (for R7 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R1)) holds (R7 is  associating implies ( R4 @ R4 ) = R4)))))
proof
let R1 being non  empty addLoopStr;
let R3 being non  empty MidStr;
let R4 being (Point of R3);
let R7 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R1));
L5: ( R7 . (R4 , R4) ) = ( R7 . (R4 , R4) );
assume L6: R7 is  associating;
thus L7: thesis by L6 , L5 , L2;
end;
definition
let R8 being non  empty set;
let R1 being non  empty addLoopStr;
let R15 being (Function of [: R8 , R8 :] , (the carrier of R1));
pred R15 is_atlas_of R8 , R1
means
:L8: ((for R9 being (Element of R8) holds (for R2 being (Element of R1) holds (ex R10 being (Element of R8) st ( R15 . (R9 , R10) ) = R2))) & (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds (( R15 . (R9 , R10) ) = ( R15 . (R9 , R12) ) implies R10 = R12)))) & (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds ( ( R15 . (R9 , R10) ) + ( R15 . (R10 , R12) ) ) = ( R15 . (R9 , R12) )))))
;end;
definition
let R8 being non  empty set;
let R1 being non  empty addLoopStr;
let R15 being (Function of [: R8 , R8 :] , (the carrier of R1));
let R9 being (Element of R8);
let R2 being (Element of R1);
assume L10: R15 is_atlas_of R8 , R1;
func (R9 , R2) . R15 -> (Element of R8) means 
:L11: ( R15 . (R9 , it) ) = R2;
existence by L10 , L8;
uniqueness by L10 , L8;
end;
theorem
L13: (for R8 being non  empty set holds (for R9 being (Element of R8) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R18 being (Function of [: R8 , R8 :] , (the carrier of R16)) holds (R18 is_atlas_of R8 , R16 implies ( R18 . (R9 , R9) ) = ( 0. R16 ))))))
proof
let R8 being non  empty set;
let R9 being (Element of R8);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R18 being (Function of [: R8 , R8 :] , (the carrier of R16));
assume L14: R18 is_atlas_of R8 , R16;
L15: ( ( R18 . (R9 , R9) ) + ( R18 . (R9 , R9) ) ) = ( R18 . (R9 , R9) ) by L14 , L8;
thus L16: thesis by L15 , RLVECT_1:9;
end;
theorem
L17: (for R8 being non  empty set holds (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R18 being (Function of [: R8 , R8 :] , (the carrier of R16)) holds ((R18 is_atlas_of R8 , R16 & ( R18 . (R9 , R10) ) = ( 0. R16 )) implies R9 = R10))))))
proof
let R8 being non  empty set;
let R9 being (Element of R8);
let R10 being (Element of R8);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R18 being (Function of [: R8 , R8 :] , (the carrier of R16));
assume that
L18: R18 is_atlas_of R8 , R16
and
L19: ( R18 . (R9 , R10) ) = ( 0. R16 );
L20: ( R18 . (R9 , R10) ) = ( R18 . (R9 , R9) ) by L18 , L19 , L13;
thus L21: thesis by L20 , L18 , L8;
end;
theorem
L22: (for R8 being non  empty set holds (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R18 being (Function of [: R8 , R8 :] , (the carrier of R16)) holds (R18 is_atlas_of R8 , R16 implies ( R18 . (R9 , R10) ) = ( - ( R18 . (R10 , R9) ) )))))))
proof
let R8 being non  empty set;
let R9 being (Element of R8);
let R10 being (Element of R8);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R18 being (Function of [: R8 , R8 :] , (the carrier of R16));
assume L23: R18 is_atlas_of R8 , R16;
L24: ( ( R18 . (R10 , R9) ) + ( R18 . (R9 , R10) ) ) = ( R18 . (R10 , R10) ) by L23 , L8
.= ( 0. R16 ) by L23 , L13;
L25: ( - ( R18 . (R10 , R9) ) ) = ( - ( - ( R18 . (R9 , R10) ) ) ) by L24 , RLVECT_1:6;
thus L26: thesis by L25 , RLVECT_1:17;
end;
theorem
L27: (for R8 being non  empty set holds (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds (for R14 being (Element of R8) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R18 being (Function of [: R8 , R8 :] , (the carrier of R16)) holds ((R18 is_atlas_of R8 , R16 & ( R18 . (R9 , R10) ) = ( R18 . (R12 , R14) )) implies ( R18 . (R10 , R9) ) = ( R18 . (R14 , R12) )))))))))
proof
let R8 being non  empty set;
let R9 being (Element of R8);
let R10 being (Element of R8);
let R12 being (Element of R8);
let R14 being (Element of R8);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R18 being (Function of [: R8 , R8 :] , (the carrier of R16));
assume that
L28: R18 is_atlas_of R8 , R16
and
L29: ( R18 . (R9 , R10) ) = ( R18 . (R12 , R14) );
thus L30: ( R18 . (R10 , R9) ) = ( - ( R18 . (R12 , R14) ) ) by L28 , L29 , L22
.= ( R18 . (R14 , R12) ) by L28 , L22;
end;
theorem
L31: (for R8 being non  empty set holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R18 being (Function of [: R8 , R8 :] , (the carrier of R16)) holds (R18 is_atlas_of R8 , R16 implies (for R10 being (Element of R8) holds (for R17 being (Element of R16) holds (ex R9 being (Element of R8) st ( R18 . (R9 , R10) ) = R17)))))))
proof
let R8 being non  empty set;
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R18 being (Function of [: R8 , R8 :] , (the carrier of R16));
assume L32: R18 is_atlas_of R8 , R16;
let R10 being (Element of R8);
let R17 being (Element of R16);
consider R9 being (Element of R8) such that L33: ( R18 . (R10 , R9) ) = ( - R17 ) by L32 , L8;
take R9;
L34: ( R18 . (R9 , R10) ) = ( - ( - R17 ) ) by L32 , L33 , L22
.= R17 by RLVECT_1:17;
thus L35: thesis by L34;
end;
theorem
L36: (for R8 being non  empty set holds (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R18 being (Function of [: R8 , R8 :] , (the carrier of R16)) holds ((R18 is_atlas_of R8 , R16 & ( R18 . (R10 , R9) ) = ( R18 . (R12 , R9) )) implies R10 = R12)))))))
proof
let R8 being non  empty set;
let R9 being (Element of R8);
let R10 being (Element of R8);
let R12 being (Element of R8);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R18 being (Function of [: R8 , R8 :] , (the carrier of R16));
assume that
L37: R18 is_atlas_of R8 , R16
and
L38: ( R18 . (R10 , R9) ) = ( R18 . (R12 , R9) );
L39: ( R18 . (R9 , R10) ) = ( R18 . (R9 , R12) ) by L37 , L38 , L27;
thus L40: thesis by L39 , L37 , L8;
end;
theorem
L41: (for R3 being non  empty MidStr holds (for R4 being (Point of R3) holds (for R5 being (Point of R3) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B1 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R16)) holds ((B1 is_atlas_of (the carrier of R3) , R16 & B1 is  associating) implies ( R4 @ R5 ) = ( R5 @ R4 )))))))
proof
let R3 being non  empty MidStr;
let R4 being (Point of R3);
let R5 being (Point of R3);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C1 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R16));
assume that
L42: C1 is_atlas_of (the carrier of R3) , R16
and
L43: C1 is  associating;
set D1 = ( R4 @ R5 );
L44: ( C1 . (R4 , D1) ) = ( C1 . (D1 , R5) ) by L43 , L2;
L45: ( C1 . (D1 , R4) ) = ( C1 . (R5 , D1) ) by L44 , L42 , L27;
thus L46: thesis by L45 , L43 , L2;
end;
theorem
L47: (for R3 being non  empty MidStr holds (for R4 being (Point of R3) holds (for R5 being (Point of R3) holds (for R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B2 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R16)) holds ((B2 is_atlas_of (the carrier of R3) , R16 & B2 is  associating) implies (ex R6 being (Point of R3) st ( R6 @ R4 ) = R5)))))))
proof
let R3 being non  empty MidStr;
let R4 being (Point of R3);
let R5 being (Point of R3);
let R16 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C2 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R16));
assume that
L48: C2 is_atlas_of (the carrier of R3) , R16
and
L49: C2 is  associating;
consider R6 being (Point of R3) such that L50: ( C2 . (R6 , R5) ) = ( C2 . (R5 , R4) ) by L48 , L31;
take R6;
thus L51: thesis by L49 , L50 , L2;
end;
theorem
L52: (for B3 being  add-associative  Abelian non  empty addLoopStr holds (for B4 , B5 , B6 , B7 being (Element of B3) holds ( ( B4 + B5 ) + ( B6 + B7 ) ) = ( ( B4 + B6 ) + ( B5 + B7 ) )))
proof
let C3 being  add-associative  Abelian non  empty addLoopStr;
let C4 , C5 , C6 , C7 being (Element of C3);
thus L53: ( ( C4 + C5 ) + ( C6 + C7 ) ) = ( C4 + ( C5 + ( C6 + C7 ) ) ) by RLVECT_1:def 3
.= ( C4 + ( C6 + ( C5 + C7 ) ) ) by RLVECT_1:def 3
.= ( ( C4 + C6 ) + ( C5 + C7 ) ) by RLVECT_1:def 3;
end;
theorem
L54: (for B8 being  add-associative  Abelian non  empty addLoopStr holds (for B9 , B10 being (Element of B8) holds ( Double ( B9 + B10 ) ) = ( ( Double B9 ) + ( Double B10 ) ))) by L52;
theorem
L55: (for R19 being  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R20 being (Element of R19) holds ( Double ( - R20 ) ) = ( - ( Double R20 ) )))
proof
let R19 being  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R20 being (Element of R19);
L56: ( 0. R19 ) = ( Double ( 0. R19 ) ) by RLVECT_1:def 4
.= ( Double ( R20 + ( - R20 ) ) ) by RLVECT_1:def 10
.= ( ( Double R20 ) + ( Double ( - R20 ) ) ) by L52;
thus L57: thesis by L56 , RLVECT_1:6;
end;
theorem
L58: (for R3 being non  empty MidStr holds (for R19 being  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for B11 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R19)) holds ((B11 is_atlas_of (the carrier of R3) , R19 & B11 is  associating) implies (for B12 , B13 , B14 , B15 being (Point of R3) holds (( B12 @ B13 ) = ( B14 @ B15 ) iff ( B11 . (B12 , B15) ) = ( B11 . (B14 , B13) )))))))
proof
let R3 being non  empty MidStr;
let R19 being  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let C8 being (Function of [: (the carrier of R3) , (the carrier of R3) :] , (the carrier of R19));
assume that
L59: C8 is_atlas_of (the carrier of R3) , R19
and
L60: C8 is  associating;
let C9 , C10 , C11 , C12 being (Point of R3);
thus L61: (( C9 @ C10 ) = ( C11 @ C12 ) implies ( C8 . (C9 , C12) ) = ( C8 . (C11 , C10) ))
proof
set D2 = ( C9 @ C10 );
assume L62: ( C9 @ C10 ) = ( C11 @ C12 );
L63: ( C8 . (C11 , D2) ) = ( C8 . (D2 , C12) ) by L62 , L60 , L2;
L64: ( C8 . (C9 , D2) ) = ( C8 . (D2 , C10) ) by L60 , L2;
thus L65: ( C8 . (C9 , C12) ) = ( ( C8 . (C11 , D2) ) + ( C8 . (D2 , C10) ) ) by L64 , L59 , L63 , L8
.= ( C8 . (C11 , C10) ) by L59 , L8;
end;

thus L66: (( C8 . (C9 , C12) ) = ( C8 . (C11 , C10) ) implies ( C9 @ C10 ) = ( C11 @ C12 ))
proof
set D3 = ( C9 @ C10 );
assume L67: ( C8 . (C9 , C12) ) = ( C8 . (C11 , C10) );
L68: ( ( C8 . (D3 , C10) ) + ( C8 . (D3 , C12) ) ) = ( ( C8 . (C9 , D3) ) + ( C8 . (D3 , C12) ) ) by L60 , L2
.= ( C8 . (C9 , C12) ) by L59 , L8
.= ( ( C8 . (D3 , C10) ) + ( C8 . (C11 , D3) ) ) by L59 , L67 , L8;
L69: ( C8 . (D3 , C12) ) = ( C8 . (C11 , D3) ) by L68 , RLVECT_1:8;
thus L70: thesis by L69 , L60 , L2;
end;

end;
theorem
L67: (for R8 being non  empty set holds (for R19 being  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R21 being (Function of [: R8 , R8 :] , (the carrier of R19)) holds (R21 is_atlas_of R8 , R19 implies (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R11 being (Element of R8) holds (for R12 being (Element of R8) holds (for R13 being (Element of R8) holds ((( R21 . (R9 , R10) ) = ( R21 . (R10 , R12) ) & ( R21 . (R9 , R11) ) = ( R21 . (R11 , R13) )) implies ( R21 . (R12 , R13) ) = ( Double ( R21 . (R10 , R11) ) )))))))))))
proof
let R8 being non  empty set;
let R19 being  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R21 being (Function of [: R8 , R8 :] , (the carrier of R19));
assume L68: R21 is_atlas_of R8 , R19;
let R9 being (Element of R8);
let R10 being (Element of R8);
let R11 being (Element of R8);
let R12 being (Element of R8);
let R13 being (Element of R8);
assume L69: (( R21 . (R9 , R10) ) = ( R21 . (R10 , R12) ) & ( R21 . (R9 , R11) ) = ( R21 . (R11 , R13) ));
thus L70: ( R21 . (R12 , R13) ) = ( ( R21 . (R12 , R11) ) + ( R21 . (R11 , R13) ) ) by L68 , L8
.= ( ( ( R21 . (R12 , R9) ) + ( R21 . (R9 , R11) ) ) + ( R21 . (R11 , R13) ) ) by L68 , L8
.= ( ( ( ( R21 . (R12 , R10) ) + ( R21 . (R10 , R9) ) ) + ( R21 . (R9 , R11) ) ) + ( R21 . (R11 , R13) ) ) by L68 , L8
.= ( ( ( Double ( R21 . (R10 , R9) ) ) + ( R21 . (R9 , R11) ) ) + ( R21 . (R9 , R11) ) ) by L68 , L69 , L27
.= ( ( Double ( R21 . (R10 , R9) ) ) + ( Double ( R21 . (R9 , R11) ) ) ) by RLVECT_1:def 3
.= ( Double ( ( R21 . (R10 , R9) ) + ( R21 . (R9 , R11) ) ) ) by L52
.= ( Double ( R21 . (R10 , R11) ) ) by L68 , L8;
end;
registration
let R22 being MidSp;
cluster ( vectgroup R22 ) ->  Abelian  add-associative  right_zeroed  right_complementable;
coherence by MIDSP_1:56;
end;
theorem
L72: (for R22 being MidSp holds ((for B16 being set holds (B16 is (Element of ( vectgroup R22 )) iff B16 is (Vector of R22))) & ( 0. ( vectgroup R22 ) ) = ( ID R22 ) & (for B17 , B18 being (Element of ( vectgroup R22 )) holds (for B19 , B20 being (Vector of R22) holds ((B17 = B19 & B18 = B20) implies ( B17 + B18 ) = ( B19 + B20 ))))))
proof
let R22 being MidSp;
set D4 = ( vectgroup R22 );
thus L73: (for B21 being set holds (B21 is (Element of D4) iff B21 is (Vector of R22)))
proof
let C13 being set;
L74: (C13 is (Element of D4) iff C13 is (Element of ( setvect R22 ))) by MIDSP_1:53;
thus L75: thesis by L74 , MIDSP_1:48;
end;

thus L76: ( 0. D4 ) = ( zerovect R22 ) by MIDSP_1:55
.= ( ID R22 ) by MIDSP_1:def 16;
thus L77: (for B22 , B23 being (Element of D4) holds (for B24 , B25 being (Vector of R22) holds ((B22 = B24 & B23 = B25) implies ( B22 + B23 ) = ( B24 + B25 ))))
proof
let C14 , C15 being (Element of D4);
let C16 , C17 being (Vector of R22);
assume that
L78: (C14 = C16 & C15 = C17);
reconsider D5 = C16 , D6 = C17 as (Element of ( setvect R22 )) by MIDSP_1:48;
thus L79: ( C14 + C15 ) = ( (the addF of D4) . (C14 , C15) ) by RLVECT_1:2
.= ( ( addvect R22 ) . (D5 , D6) ) by L78 , MIDSP_1:54
.= ( D5 + D6 ) by MIDSP_1:def 14
.= ( C16 + C17 ) by MIDSP_1:def 13;
end;

end;
L78: (for R22 being MidSp holds ((for B26 being (Element of ( vectgroup R22 )) holds (ex B27 being (Element of ( vectgroup R22 )) st ( Double B27 ) = B26)) & (for B28 being (Element of ( vectgroup R22 )) holds (( Double B28 ) = ( 0. ( vectgroup R22 ) ) implies B28 = ( 0. ( vectgroup R22 ) )))))
proof
let R22 being MidSp;
set D7 = ( vectgroup R22 );
set D8 = the (Point of R22);
thus L79: (for B29 being (Element of D7) holds (ex B30 being (Element of D7) st ( Double B30 ) = B29))
proof
set D9 = the (Point of R22);
let C18 being (Element of D7);
reconsider D10 = C18 as (Vector of R22) by L72;
consider C19 being (Point of R22) such that L80: D10 = ( vect (D9 , C19) ) by MIDSP_1:35;
set D11 = ( vect (D9 , ( D9 @ C19 )) );
reconsider D12 = D11 as (Element of D7) by L72;
take D12;
L81: ( D11 + D11 ) = D10 by L80 , MIDSP_1:42;
thus L82: thesis by L81 , L72;
end;

let C20 being (Element of D7);
reconsider D13 = C20 as (Vector of R22) by L72;
consider C21 being (Point of R22) such that L83: D13 = ( vect (D8 , C21) ) by MIDSP_1:35;
consider C22 being (Point of R22) such that L84: D13 = ( vect (C21 , C22) ) by MIDSP_1:35;
assume L85: ( Double C20 ) = ( 0. D7 );
L86: ( D13 + D13 ) = ( 0. D7 ) by L85 , L72
.= ( ID R22 ) by L72;
L87: ( ( vect (D8 , C21) ) + ( vect (C21 , C22) ) ) = ( vect (D8 , D8) ) by L86 , L83 , L84 , MIDSP_1:38;
L88: ( vect (D8 , C22) ) = ( vect (D8 , D8) ) by L87 , MIDSP_1:40;
L89: ( vect (D8 , C21) ) = ( vect (C21 , D8) ) by L88 , L83 , L84 , MIDSP_1:39;
L90: ( D8 @ D8 ) = ( C21 @ C21 ) by L89 , MIDSP_1:37;
L91: D8 = ( D8 @ D8 ) by MIDSP_1:def 3
.= C21 by L90 , MIDSP_1:def 3;
thus L92: C20 = ( ID R22 ) by L91 , L83 , MIDSP_1:38
.= ( 0. D7 ) by L72;
end;
definition
let C23 being non  empty addLoopStr;
attr C23 is  midpoint_operator
means
:L93: ((for B31 being (Element of C23) holds (ex B32 being (Element of C23) st ( Double B32 ) = B31)) & (for B33 being (Element of C23) holds (( Double B33 ) = ( 0. C23 ) implies B33 = ( 0. C23 ))));
end;
registration
cluster  midpoint_operator ->  Fanoian for non  empty non  empty non  empty non  empty addLoopStr;
coherence
proof
let C24 being non  empty addLoopStr;
assume L95: C24 is  midpoint_operator;
let C25 being (Element of C24);
assume L96: ( C25 + C25 ) = ( 0. C24 );
L97: ( Double C25 ) = ( 0. C24 ) by L96;
thus L98: thesis by L97 , L95 , L93;
end;
end;
registration
cluster  strict  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian for non  empty non  empty non  empty non  empty addLoopStr;
existence
proof
set D14 = the MidSp;
set D15 = ( vectgroup D14 );
L100: ((for B34 being (Element of D15) holds (ex B35 being (Element of D15) st ( Double B35 ) = B34)) & (for B36 being (Element of D15) holds (( Double B36 ) = ( 0. D15 ) implies B36 = ( 0. D15 )))) by L78;
L101: D15 is  midpoint_operator by L100 , L93;
thus L102: thesis by L101;
end;
end;
theorem
L104: (for B37 being  Fanoian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B38 being (Element of B37) holds (B38 = ( - B38 ) implies B38 = ( 0. B37 ))))
proof
let C26 being  Fanoian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C27 being (Element of C26);
L105: ( ( - C27 ) + C27 ) = ( 0. C26 ) by RLVECT_1:5;
assume L106: C27 = ( - C27 );
thus L107: thesis by L106 , L105 , VECTSP_1:def 18;
end;
theorem
L108: (for B39 being  Fanoian  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for B40 , B41 being (Element of B39) holds (( Double B40 ) = ( Double B41 ) implies B40 = B41)))
proof
let C28 being  Fanoian  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let C29 , C30 being (Element of C28);
assume L109: ( Double C29 ) = ( Double C30 );
L110: ( 0. C28 ) = ( ( C29 + C29 ) + ( - ( C30 + C30 ) ) ) by L109 , RLVECT_1:def 10
.= ( ( C29 + C29 ) + ( ( - C30 ) + ( - C30 ) ) ) by RLVECT_1:31
.= ( C29 + ( C29 + ( ( - C30 ) + ( - C30 ) ) ) ) by RLVECT_1:def 3
.= ( C29 + ( ( C29 + ( - C30 ) ) + ( - C30 ) ) ) by RLVECT_1:def 3
.= ( ( C29 + ( - C30 ) ) + ( C29 + ( - C30 ) ) ) by RLVECT_1:def 3;
L111: ( ( - C30 ) + C29 ) = ( 0. C28 ) by L110 , VECTSP_1:def 18;
thus L112: C29 = ( - ( - C30 ) ) by L111 , RLVECT_1:6
.= C30 by RLVECT_1:17;
end;
definition
let C31 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let C32 being (Element of C31);
func Half C32 -> (Element of C31) means 
:L113: ( Double it ) = C32;
existence by L93;
uniqueness by L108;
end;
theorem
L115: (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R28 being (Element of R27) holds (for R29 being (Element of R27) holds (( Half ( 0. R27 ) ) = ( 0. R27 ) & ( Half ( R28 + R29 ) ) = ( ( Half R28 ) + ( Half R29 ) ) & (( Half R28 ) = ( Half R29 ) implies R28 = R29) & ( Half ( Double R28 ) ) = R28))))
proof
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R28 being (Element of R27);
let R29 being (Element of R27);
L116: ( Double ( 0. R27 ) ) = ( 0. R27 ) by RLVECT_1:def 4;
thus L117: ( Half ( 0. R27 ) ) = ( 0. R27 ) by L116 , L113;
L118: ( Double ( ( Half R28 ) + ( Half R29 ) ) ) = ( ( Double ( Half R28 ) ) + ( Double ( Half R29 ) ) ) by L52
.= ( R28 + ( Double ( Half R29 ) ) ) by L113
.= ( R28 + R29 ) by L113;
thus L119: ( Half ( R28 + R29 ) ) = ( ( Half R28 ) + ( Half R29 ) ) by L118 , L113;
thus L120: (( Half R28 ) = ( Half R29 ) implies R28 = R29)
proof
assume L121: ( Half R28 ) = ( Half R29 );
thus L122: R28 = ( Double ( Half R29 ) ) by L121 , L113
.= R29 by L113;
end;

thus L123: thesis by L113;
end;
theorem
L124: (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for B42 being non  empty MidStr holds (for B43 being (Function of [: (the carrier of B42) , (the carrier of B42) :] , (the carrier of R27)) holds ((B43 is_atlas_of (the carrier of B42) , R27 & B43 is  associating) implies (for B44 , B45 , B46 , B47 being (Point of B42) holds ( ( B44 @ B45 ) @ ( B46 @ B47 ) ) = ( ( B44 @ B46 ) @ ( B45 @ B47 ) ))))))
proof
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let C33 being non  empty MidStr;
let C34 being (Function of [: (the carrier of C33) , (the carrier of C33) :] , (the carrier of R27));
assume that
L125: C34 is_atlas_of (the carrier of C33) , R27
and
L126: C34 is  associating;
let C35 , C36 , C37 , C38 being (Point of C33);
L127: ( C34 . (C36 , ( C35 @ C36 )) ) = ( C34 . (C36 , ( C36 @ C35 )) ) by L125 , L126 , L41
.= ( C34 . (( C36 @ C35 ) , C35) ) by L126 , L2
.= ( C34 . (( C35 @ C36 ) , C35) ) by L125 , L126 , L41;
set D16 = ( ( C35 @ C36 ) @ ( C37 @ C38 ) );
L128: ( C34 . (C37 , ( C37 @ C38 )) ) = ( C34 . (( C37 @ C38 ) , C38) ) by L126 , L2;
L129: ( C34 . (C36 , ( C36 @ C38 )) ) = ( C34 . (( C36 @ C38 ) , C38) ) by L126 , L2;
L130: ( C34 . (C37 , ( C35 @ C37 )) ) = ( C34 . (C37 , ( C37 @ C35 )) ) by L125 , L126 , L41
.= ( C34 . (( C37 @ C35 ) , C35) ) by L126 , L2
.= ( C34 . (( C35 @ C37 ) , C35) ) by L125 , L126 , L41;
L131: ( Double ( C34 . (( C35 @ C37 ) , ( C37 @ C38 )) ) ) = ( C34 . (C35 , C38) ) by L130 , L125 , L128 , L67
.= ( - ( C34 . (C38 , C35) ) ) by L125 , L22
.= ( - ( Double ( C34 . (( C36 @ C38 ) , ( C35 @ C36 )) ) ) ) by L125 , L129 , L127 , L67
.= ( Double ( - ( C34 . (( C36 @ C38 ) , ( C35 @ C36 )) ) ) ) by L55
.= ( Double ( C34 . (( C35 @ C36 ) , ( C36 @ C38 )) ) ) by L125 , L22;
L132: ( C34 . (( C35 @ C37 ) , ( C37 @ C38 )) ) = ( C34 . (( C35 @ C36 ) , ( C36 @ C38 )) ) by L131 , L108;
L133: ( ( C34 . (( C35 @ C37 ) , D16) ) + ( C34 . (D16 , ( C37 @ C38 )) ) ) = ( C34 . (( C35 @ C36 ) , ( C36 @ C38 )) ) by L132 , L125 , L8
.= ( ( C34 . (D16 , ( C36 @ C38 )) ) + ( C34 . (( C35 @ C36 ) , D16) ) ) by L125 , L8;
L134: ( C34 . (( C35 @ C36 ) , D16) ) = ( C34 . (D16 , ( C37 @ C38 )) ) by L126 , L2;
L135: ( C34 . (( C35 @ C37 ) , D16) ) = ( C34 . (D16 , ( C36 @ C38 )) ) by L134 , L133 , RLVECT_1:8;
thus L136: thesis by L135 , L126 , L2;
end;
theorem
L137: (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for B48 being non  empty MidStr holds (for B49 being (Function of [: (the carrier of B48) , (the carrier of B48) :] , (the carrier of R27)) holds ((B49 is_atlas_of (the carrier of B48) , R27 & B49 is  associating) implies B48 is MidSp))))
proof
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let C39 being non  empty MidStr;
let C40 being (Function of [: (the carrier of C39) , (the carrier of C39) :] , (the carrier of R27));
assume L138: (C40 is_atlas_of (the carrier of C39) , R27 & C40 is  associating);
L139: (for B50 , B51 , B52 , B53 being (Point of C39) holds (( B50 @ B50 ) = B50 & ( B50 @ B51 ) = ( B51 @ B50 ) & ( ( B50 @ B51 ) @ ( B52 @ B53 ) ) = ( ( B50 @ B52 ) @ ( B51 @ B53 ) ) & (ex B54 being (Point of C39) st ( B54 @ B50 ) = B51))) by L138 , L4 , L41 , L47 , L124;
thus L140: thesis by L139 , MIDSP_1:def 3;
end;
registration
let R22 being MidSp;
cluster ( vectgroup R22 ) ->  midpoint_operator;
coherence
proof
set D17 = ( vectgroup R22 );
L141: ((for R30 being (Element of ( vectgroup R22 )) holds (ex R31 being (Element of ( vectgroup R22 )) st ( Double R31 ) = R30)) & (for R30 being (Element of ( vectgroup R22 )) holds (( Double R30 ) = ( 0. D17 ) implies R30 = ( 0. D17 )))) by L78;
thus L142: thesis by L141 , L93;
end;
end;
definition
let R22 being MidSp;
let R23 being (Point of R22);
let R24 being (Point of R22);
func vector (R23 , R24) -> (Element of ( vectgroup R22 )) equals 
( vect (R23 , R24) );
coherence by L72;
end;
definition
let R22 being MidSp;
func vect R22 -> (Function of [: (the carrier of R22) , (the carrier of R22) :] , (the carrier of ( vectgroup R22 ))) means 
:L145: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds ( it . (R23 , R24) ) = ( vect (R23 , R24) )));
existence
proof
deffunc H1((Point of R22) , (Point of R22)) = ( vector ($1 , $2) );
consider C41 being (Function of [: (the carrier of R22) , (the carrier of R22) :] , (the carrier of ( vectgroup R22 ))) such that L146: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds ( C41 . (R23 , R24) ) = H1(R23 , R24))) from BINOP_1:sch 4;
take C41;
L147: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds ( C41 . (R23 , R24) ) = ( vect (R23 , R24) )))
proof
let R23 being (Point of R22);
let R24 being (Point of R22);
thus L148: ( C41 . (R23 , R24) ) = ( vector (R23 , R24) ) by L146
.= ( vect (R23 , R24) );
end;
thus L149: thesis by L147;
end;
uniqueness
proof
let C42 , C43 being (Function of [: (the carrier of R22) , (the carrier of R22) :] , (the carrier of ( vectgroup R22 )));
assume that
L150: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds ( C42 . (R23 , R24) ) = ( vect (R23 , R24) )))
and
L151: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds ( C43 . (R23 , R24) ) = ( vect (R23 , R24) )));
L152: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds ( C42 . (R23 , R24) ) = ( C43 . (R23 , R24) )))
proof
let R23 being (Point of R22);
let R24 being (Point of R22);
thus L153: ( C42 . (R23 , R24) ) = ( vect (R23 , R24) ) by L150
.= ( C43 . (R23 , R24) ) by L151;
end;
thus L154: C42 = C43 by L152 , BINOP_1:2;
end;
end;
theorem
L156: (for R22 being MidSp holds ( vect R22 ) is_atlas_of (the carrier of R22) , ( vectgroup R22 ))
proof
let R22 being MidSp;
set D18 = ( vect R22 );
L157: (for R23 being (Point of R22) holds (for R30 being (Element of ( vectgroup R22 )) holds (ex R24 being (Point of R22) st ( D18 . (R23 , R24) ) = R30)))
proof
let R23 being (Point of R22);
let R30 being (Element of ( vectgroup R22 ));
reconsider D19 = R30 as (Vector of R22) by L72;
consider R24 being (Point of R22) such that L158: D19 = ( vect (R23 , R24) ) by MIDSP_1:35;
take R24;
thus L159: thesis by L158 , L145;
end;
L160: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds (for R25 being (Point of R22) holds (( D18 . (R23 , R24) ) = ( D18 . (R23 , R25) ) implies R24 = R25))))
proof
let R23 being (Point of R22);
let R24 being (Point of R22);
let R25 being (Point of R22);
assume L161: ( D18 . (R23 , R24) ) = ( D18 . (R23 , R25) );
L162: ( vect (R23 , R24) ) = ( D18 . (R23 , R25) ) by L161 , L145
.= ( vect (R23 , R25) ) by L145;
thus L163: thesis by L162 , MIDSP_1:39;
end;
L164: (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds (for R25 being (Point of R22) holds ( ( D18 . (R23 , R24) ) + ( D18 . (R24 , R25) ) ) = ( D18 . (R23 , R25) ))))
proof
let R23 being (Point of R22);
let R24 being (Point of R22);
let R25 being (Point of R22);
L165: (( D18 . (R23 , R24) ) = ( vect (R23 , R24) ) & ( D18 . (R24 , R25) ) = ( vect (R24 , R25) )) by L145;
thus L166: ( ( D18 . (R23 , R24) ) + ( D18 . (R24 , R25) ) ) = ( ( vect (R23 , R24) ) + ( vect (R24 , R25) ) ) by L165 , L72
.= ( vect (R23 , R25) ) by MIDSP_1:40
.= ( D18 . (R23 , R25) ) by L145;
end;
thus L167: thesis by L164 , L157 , L160 , L8;
end;
theorem
L168: (for R22 being MidSp holds (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds (for R25 being (Point of R22) holds (for R26 being (Point of R22) holds (( vect (R23 , R24) ) = ( vect (R25 , R26) ) iff ( R23 @ R26 ) = ( R24 @ R25 )))))))
proof
let R22 being MidSp;
let R23 being (Point of R22);
let R24 being (Point of R22);
let R25 being (Point of R22);
let R26 being (Point of R22);
thus L169: (( vect (R23 , R24) ) = ( vect (R25 , R26) ) implies ( R23 @ R26 ) = ( R24 @ R25 )) by MIDSP_1:37;
thus L170: (( R23 @ R26 ) = ( R24 @ R25 ) implies ( vect (R23 , R24) ) = ( vect (R25 , R26) ))
proof
assume L171: ( R23 @ R26 ) = ( R24 @ R25 );
L172: R23 , R24 @@ R25 , R26 by L171 , MIDSP_1:def 4;
L173: [ R23 , R24 ] ## [ R25 , R26 ] by L172 , MIDSP_1:19;
thus L174: thesis by L173 , MIDSP_1:36;
end;

end;
theorem
L171: (for R22 being MidSp holds (for R23 being (Point of R22) holds (for R24 being (Point of R22) holds (for R25 being (Point of R22) holds (( R23 @ R24 ) = R25 iff ( vect (R23 , R25) ) = ( vect (R25 , R24) ))))))
proof
let R22 being MidSp;
let R23 being (Point of R22);
let R24 being (Point of R22);
let R25 being (Point of R22);
L172: (( R23 @ R24 ) = R25 iff ( R23 @ R24 ) = ( R25 @ R25 )) by MIDSP_1:def 3;
thus L173: thesis by L172 , L168;
end;
canceled 1;
L174: (for R22 being MidSp holds ( vect R22 ) is  associating)
proof
let R22 being MidSp;
let R23 being (Point of R22);
let R24 being (Point of R22);
let R25 being (Point of R22);
set D20 = ( vect R22 );
L175: (( D20 . (R23 , R25) ) = ( vect (R23 , R25) ) & ( D20 . (R25 , R24) ) = ( vect (R25 , R24) )) by L145;
thus L176: thesis by L175 , L171;
end;
registration
let R22 being MidSp;
cluster ( vect R22 ) ->  associating;
coherence by L174;
end;
definition
let R8 being non  empty set;
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R32 being (Function of [: R8 , R8 :] , (the carrier of R27));
assume L178: R32 is_atlas_of R8 , R27;
func @ R32 -> (BinOp of R8) means 
:L179: (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds ( R32 . (R9 , ( it . (R9 , R10) )) ) = ( R32 . (( it . (R9 , R10) ) , R10) )));
existence
proof
defpred S1[ (Element of R8) , (Element of R8) , (Element of R8) ] means ( R32 . ($1 , $3) ) = ( R32 . ($3 , $2) );
L180: (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (ex R12 being (Element of R8) st S1[ R9 , R10 , R12 ])))
proof
let R9 being (Element of R8);
let R10 being (Element of R8);
set D21 = ( Half ( R32 . (R9 , R10) ) );
consider R12 being (Element of R8) such that L181: ( R32 . (R9 , R12) ) = D21 by L178 , L8;
take R12;
L182: ( D21 + D21 ) = ( Double D21 )
.= ( R32 . (R9 , R10) ) by L113
.= ( D21 + ( R32 . (R12 , R10) ) ) by L178 , L181 , L8;
thus L183: thesis by L182 , L181 , RLVECT_1:8;
end;
consider C44 being (BinOp of R8) such that L184: (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds S1[ R9 , R10 , ( C44 . (R9 , R10) ) ])) from BINOP_1:sch 3(L180);
take C44;
thus L185: thesis by L184;
end;
uniqueness
proof
defpred S2[ (Element of R8) , (Element of R8) , (Element of R8) ] means ( R32 . ($1 , $3) ) = ( R32 . ($3 , $2) );
L186: (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds (for R13 being (Element of R8) holds ((S2[ R9 , R10 , R12 ] & S2[ R9 , R10 , R13 ]) implies R12 = R13)))))
proof
let R9 being (Element of R8);
let R10 being (Element of R8);
let R12 being (Element of R8);
let R13 being (Element of R8);
assume that
L187: (S2[ R9 , R10 , R12 ] & S2[ R9 , R10 , R13 ]);
L188: ( R32 . (R12 , R13) ) = ( ( R32 . (R12 , R9) ) + ( R32 . (R9 , R13) ) ) by L178 , L8
.= ( ( R32 . (R13 , R10) ) + ( R32 . (R10 , R12) ) ) by L178 , L187 , L27
.= ( R32 . (R13 , R12) ) by L178 , L8
.= ( - ( R32 . (R12 , R13) ) ) by L178 , L22;
L189: ( R32 . (R12 , R13) ) = ( 0. R27 ) by L188 , L104;
thus L190: thesis by L189 , L178 , L17;
end;
let C45 , C46 being (BinOp of R8);
assume that
L191: ((for R9 being (Element of R8) holds (for R10 being (Element of R8) holds ( R32 . (R9 , ( C45 . (R9 , R10) )) ) = ( R32 . (( C45 . (R9 , R10) ) , R10) ))) & (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds ( R32 . (R9 , ( C46 . (R9 , R10) )) ) = ( R32 . (( C46 . (R9 , R10) ) , R10) ))));
L192: (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds ( C45 . (R9 , R10) ) = ( C46 . (R9 , R10) )))
proof
let R9 being (Element of R8);
let R10 being (Element of R8);
L193: (( R32 . (R9 , ( C45 . (R9 , R10) )) ) = ( R32 . (( C45 . (R9 , R10) ) , R10) ) & ( R32 . (R9 , ( C46 . (R9 , R10) )) ) = ( R32 . (( C46 . (R9 , R10) ) , R10) )) by L191;
thus L194: thesis by L193 , L186;
end;
thus L195: C45 = C46 by L192 , BINOP_1:2;
end;
end;
theorem
L197: (for R8 being non  empty set holds (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R32 being (Function of [: R8 , R8 :] , (the carrier of R27)) holds (R32 is_atlas_of R8 , R27 implies (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds (( ( @ R32 ) . (R9 , R10) ) = R12 iff ( R32 . (R9 , R12) ) = ( R32 . (R12 , R10) )))))))))
proof
let R8 being non  empty set;
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R32 being (Function of [: R8 , R8 :] , (the carrier of R27));
assume L198: R32 is_atlas_of R8 , R27;
let R9 being (Element of R8);
let R10 being (Element of R8);
let R12 being (Element of R8);
thus L199: (( ( @ R32 ) . (R9 , R10) ) = R12 implies ( R32 . (R9 , R12) ) = ( R32 . (R12 , R10) )) by L198 , L179;
thus L200: (( R32 . (R9 , R12) ) = ( R32 . (R12 , R10) ) implies ( ( @ R32 ) . (R9 , R10) ) = R12)
proof
defpred S3[ (Element of R8) , (Element of R8) , (Element of R8) ] means ( R32 . ($1 , $3) ) = ( R32 . ($3 , $2) );
assume L201: ( R32 . (R9 , R12) ) = ( R32 . (R12 , R10) );
L202: (for R9 being (Element of R8) holds (for R10 being (Element of R8) holds (for R12 being (Element of R8) holds (for R13 being (Element of R8) holds ((S3[ R9 , R10 , R12 ] & S3[ R9 , R10 , R13 ]) implies R12 = R13)))))
proof
let R9 being (Element of R8);
let R10 being (Element of R8);
let R12 being (Element of R8);
let R13 being (Element of R8);
assume that
L203: (S3[ R9 , R10 , R12 ] & S3[ R9 , R10 , R13 ]);
L204: ( R32 . (R12 , R13) ) = ( ( R32 . (R12 , R9) ) + ( R32 . (R9 , R13) ) ) by L198 , L8
.= ( ( R32 . (R13 , R10) ) + ( R32 . (R10 , R12) ) ) by L198 , L203 , L27
.= ( R32 . (R13 , R12) ) by L198 , L8
.= ( - ( R32 . (R12 , R13) ) ) by L198 , L22;
L205: ( R32 . (R12 , R13) ) = ( 0. R27 ) by L204 , L104;
thus L206: thesis by L205 , L198 , L17;
end;
set D22 = ( ( @ R32 ) . (R9 , R10) );
L207: S3[ R9 , R10 , D22 ] by L198 , L179;
thus L208: thesis by L207 , L201 , L202;
end;

end;
registration
let C47 being non  empty set;
let C48 being (BinOp of C47);
cluster MidStr (# C47 , C48 #) -> non  empty;
coherence;
end;
definition
let R8 being non  empty set;
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R32 being (Function of [: R8 , R8 :] , (the carrier of R27));
func Atlas R32 -> (Function of [: (the carrier of MidStr (# R8 , ( @ R32 ) #)) , (the carrier of MidStr (# R8 , ( @ R32 ) #)) :] , (the carrier of R27)) equals 
R32;
coherence;
end;
theorem
L203: (for R8 being non  empty set holds (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R32 being (Function of [: R8 , R8 :] , (the carrier of R27)) holds (R32 is_atlas_of R8 , R27 implies ( Atlas R32 ) is  associating))))
proof
let R8 being non  empty set;
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R32 being (Function of [: R8 , R8 :] , (the carrier of R27));
assume L204: R32 is_atlas_of R8 , R27;
L205: (for R33 being (Point of MidStr (# R8 , ( @ R32 ) #)) holds (for R34 being (Point of MidStr (# R8 , ( @ R32 ) #)) holds (for R35 being (Point of MidStr (# R8 , ( @ R32 ) #)) holds (( R33 @ R34 ) = R35 iff ( ( Atlas R32 ) . (R33 , R35) ) = ( ( Atlas R32 ) . (R35 , R34) )))))
proof
let R33 being (Point of MidStr (# R8 , ( @ R32 ) #));
let R34 being (Point of MidStr (# R8 , ( @ R32 ) #));
let R35 being (Point of MidStr (# R8 , ( @ R32 ) #));
L206: (( ( @ R32 ) . (R33 , R34) ) = R35 iff ( R32 . (R33 , R35) ) = ( R32 . (R35 , R34) )) by L204 , L197;
thus L207: thesis by L206 , MIDSP_1:def 1;
end;
thus L208: thesis by L205 , L2;
end;
definition
let R8 being non  empty set;
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R32 being (Function of [: R8 , R8 :] , (the carrier of R27));
assume L209: R32 is_atlas_of R8 , R27;
func MidSp. R32 ->  strict MidSp equals 
MidStr (# R8 , ( @ R32 ) #);
coherence
proof
set D23 = MidStr (# R8 , ( @ R32 ) #);
set D24 = ( Atlas R32 );
L210: D24 is  associating by L209 , L203;
thus L211: thesis by L210 , L209 , L137;
end;
end;
theorem
L213: (for R36 being non  empty MidStr holds (R36 is MidSp iff (ex R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr st (ex R37 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of R27)) st (R37 is_atlas_of (the carrier of R36) , R27 & R37 is  associating)))))
proof
let R36 being non  empty MidStr;
thus L214:now
assume L215: R36 is MidSp;
thus L216: (ex R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr st (ex R37 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of R27)) st (R37 is_atlas_of (the carrier of R36) , R27 & R37 is  associating)))
proof
reconsider D25 = R36 as MidSp by L215;
set D26 = ( vectgroup D25 );
take D26;
L217: (ex B55 being (Function of [: (the carrier of D25) , (the carrier of D25) :] , (the carrier of D26)) st (B55 is_atlas_of (the carrier of D25) , D26 & B55 is  associating))
proof
take ( vect D25 );
thus L218: thesis by L156;
end;
thus L219: thesis by L217;
end;

end;
given C49 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr , C50 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of C49)) such that
L217: (C50 is_atlas_of (the carrier of R36) , C49 & C50 is  associating);

thus L218: thesis by L217 , L137;
end;
definition
let C51 being non  empty MidStr;
struct AtlasStr over C51(# algebra -> non  empty addLoopStr , function -> (Function of [: (the carrier of C51) , (the carrier of C51) :] , (the carrier of the algebra)) #);
end;
definition
let C52 being non  empty MidStr;
let C53 being AtlasStr over C52;
attr C53 is  ATLAS-like
means
:L220: ((the algebra of C53) is  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian & (the function of C53) is  associating & (the function of C53) is_atlas_of (the carrier of C52) , (the algebra of C53));
end;
registration
let C54 being MidSp;
cluster  ATLAS-like for AtlasStr over C54;
existence
proof
consider C55 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr, C56 being (Function of [: (the carrier of C54) , (the carrier of C54) :] , (the carrier of C55)) such that L222: (C56 is_atlas_of (the carrier of C54) , C55 & C56 is  associating) by L213;
take AtlasStr (# C55 , C56 #);
thus L223: thesis by L222 , L220;
end;
end;
definition
let C57 being non  empty MidSp;
mode ATLAS of C57
 is  ATLAS-like AtlasStr over C57;
end;
definition
let C58 being non  empty MidStr;
let C59 being AtlasStr over C58;
mode Vector of C59
 is (Element of (the algebra of C59));
end;
definition
let C60 being MidSp;
let C61 being AtlasStr over C60;
let C62 , C63 being (Point of C60);
func C61 . (C62 , C63) -> (Element of (the algebra of C61)) equals 
( (the function of C61) . (C62 , C63) );
coherence;
end;
definition
let C64 being MidSp;
let C65 being AtlasStr over C64;
let C66 being (Point of C64);
let C67 being (Vector of C65);
func (C66 , C67) . C65 -> (Point of C64) equals 
( (C66 , C67) . (the function of C65) );
coherence;
end;
definition
let C68 being MidSp;
let C69 being (ATLAS of C68);
func 0. C69 -> (Vector of C69) equals 
( 0. (the algebra of C69) );
coherence;
end;
theorem
L230: (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R36 being non  empty MidStr holds (for R37 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of R27)) holds (for R38 being (Point of R36) holds (for R40 being (Point of R36) holds (for R41 being (Point of R36) holds (for R42 being (Point of R36) holds ((R37 is_atlas_of (the carrier of R36) , R27 & R37 is  associating) implies (( R38 @ R42 ) = ( R40 @ R41 ) iff ( R37 . (R38 , R42) ) = ( ( R37 . (R38 , R40) ) + ( R37 . (R38 , R41) ) ))))))))))
proof
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R36 being non  empty MidStr;
let R37 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of R27));
let R38 being (Point of R36);
let R40 being (Point of R36);
let R41 being (Point of R36);
let R42 being (Point of R36);
assume that
L231: R37 is_atlas_of (the carrier of R36) , R27
and
L232: R37 is  associating;
L233: (( R38 @ R42 ) = ( R40 @ R41 ) iff ( R37 . (R38 , R41) ) = ( R37 . (R40 , R42) )) by L231 , L232 , L58;
thus L234: (( R38 @ R42 ) = ( R40 @ R41 ) implies ( R37 . (R38 , R42) ) = ( ( R37 . (R38 , R40) ) + ( R37 . (R38 , R41) ) )) by L233 , L231 , L8;
L235: ( R37 . (R38 , R42) ) = ( ( R37 . (R38 , R40) ) + ( R37 . (R40 , R42) ) ) by L231 , L8;
thus L236: thesis by L235 , L233 , RLVECT_1:8;
end;
theorem
L237: (for R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr holds (for R36 being non  empty MidStr holds (for R37 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of R27)) holds (for R38 being (Point of R36) holds (for R39 being (Point of R36) holds (for R42 being (Point of R36) holds ((R37 is_atlas_of (the carrier of R36) , R27 & R37 is  associating) implies (( R38 @ R42 ) = R39 iff ( R37 . (R38 , R42) ) = ( Double ( R37 . (R38 , R39) ) )))))))))
proof
let R27 being  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian non  empty addLoopStr;
let R36 being non  empty MidStr;
let R37 being (Function of [: (the carrier of R36) , (the carrier of R36) :] , (the carrier of R27));
let R38 being (Point of R36);
let R39 being (Point of R36);
let R42 being (Point of R36);
assume L238: (R37 is_atlas_of (the carrier of R36) , R27 & R37 is  associating);
reconsider D27 = R36 as MidSp by L238 , L137;
reconsider D28 = R39 as (Point of D27);
L239: ( D28 @ D28 ) = D28 by MIDSP_1:def 3;
thus L240: thesis by L239 , L238 , L230;
end;
theorem
L241: (for R43 being MidSp holds (for R44 being (ATLAS of R43) holds (for R45 being (Point of R43) holds (for R47 being (Point of R43) holds (for R48 being (Point of R43) holds (for R49 being (Point of R43) holds (( R45 @ R49 ) = ( R47 @ R48 ) iff ( R44 . (R45 , R49) ) = ( ( R44 . (R45 , R47) ) + ( R44 . (R45 , R48) ) ))))))))
proof
let R43 being MidSp;
let R44 being (ATLAS of R43);
let R45 being (Point of R43);
let R47 being (Point of R43);
let R48 being (Point of R43);
let R49 being (Point of R43);
set D29 = (the function of R44);
set D30 = (the algebra of R44);
L242: D30 is  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian by L220;
L243: (D29 is_atlas_of (the carrier of R43) , D30 & D29 is  associating) by L220;
thus L244: thesis by L243 , L242 , L230;
end;
theorem
L245: (for R43 being MidSp holds (for R44 being (ATLAS of R43) holds (for R45 being (Point of R43) holds (for R46 being (Point of R43) holds (for R49 being (Point of R43) holds (( R45 @ R49 ) = R46 iff ( R44 . (R45 , R49) ) = ( Double ( R44 . (R45 , R46) ) )))))))
proof
let R43 being MidSp;
let R44 being (ATLAS of R43);
let R45 being (Point of R43);
let R46 being (Point of R43);
let R49 being (Point of R43);
set D31 = (the function of R44);
set D32 = (the algebra of R44);
L246: D32 is  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian by L220;
L247: (D31 is_atlas_of (the carrier of R43) , D32 & D31 is  associating) by L220;
thus L248: thesis by L247 , L246 , L237;
end;
theorem
L249: (for R43 being MidSp holds (for R44 being (ATLAS of R43) holds ((for R45 being (Point of R43) holds (for R51 being (Vector of R44) holds (ex R46 being (Point of R43) st ( R44 . (R45 , R46) ) = R51))) & (for R45 being (Point of R43) holds (for R46 being (Point of R43) holds (for R49 being (Point of R43) holds (( R44 . (R45 , R46) ) = ( R44 . (R45 , R49) ) implies R46 = R49)))) & (for R45 being (Point of R43) holds (for R46 being (Point of R43) holds (for R49 being (Point of R43) holds ( ( R44 . (R45 , R46) ) + ( R44 . (R46 , R49) ) ) = ( R44 . (R45 , R49) )))))))
proof
let R43 being MidSp;
let R44 being (ATLAS of R43);
set D33 = (the function of R44);
thus L250: (for R45 being (Point of R43) holds (for R51 being (Vector of R44) holds (ex R46 being (Point of R43) st ( R44 . (R45 , R46) ) = R51)))
proof
set D34 = (the function of R44);
let R45 being (Point of R43);
let R51 being (Vector of R44);
L251: D34 is_atlas_of (the carrier of R43) , (the algebra of R44) by L220;
consider R46 being (Point of R43) such that L252: ( D34 . (R45 , R46) ) = R51 by L251 , L8;
take R46;
thus L253: thesis by L252;
end;

thus L254: (for R45 being (Point of R43) holds (for R46 being (Point of R43) holds (for R49 being (Point of R43) holds (( R44 . (R45 , R46) ) = ( R44 . (R45 , R49) ) implies R46 = R49))))
proof
set D35 = (the function of R44);
L255: D35 is_atlas_of (the carrier of R43) , (the algebra of R44) by L220;
let R45 being (Point of R43);
let R46 being (Point of R43);
let R49 being (Point of R43);
assume L256: ( R44 . (R45 , R46) ) = ( R44 . (R45 , R49) );
thus L257: thesis by L256 , L255 , L8;
end;

let R45 being (Point of R43);
let R46 being (Point of R43);
let R49 being (Point of R43);
L258: D33 is_atlas_of (the carrier of R43) , (the algebra of R44) by L220;
thus L259: thesis by L258 , L8;
end;
theorem
L260: (for R43 being MidSp holds (for R44 being (ATLAS of R43) holds (for R45 being (Point of R43) holds (for R46 being (Point of R43) holds (for R49 being (Point of R43) holds (for R50 being (Point of R43) holds (for R51 being (Vector of R44) holds (( R44 . (R45 , R45) ) = ( 0. R44 ) & (( R44 . (R45 , R46) ) = ( 0. R44 ) implies R45 = R46) & ( R44 . (R45 , R46) ) = ( - ( R44 . (R46 , R45) ) ) & (( R44 . (R45 , R46) ) = ( R44 . (R49 , R50) ) implies ( R44 . (R46 , R45) ) = ( R44 . (R50 , R49) )) & (for R46 being (Point of R43) holds (for R51 being (Vector of R44) holds (ex R45 being (Point of R43) st ( R44 . (R45 , R46) ) = R51))) & (( R44 . (R46 , R45) ) = ( R44 . (R49 , R45) ) implies R46 = R49) & (( R45 @ R46 ) = R49 iff ( R44 . (R45 , R49) ) = ( R44 . (R49 , R46) )) & (( R45 @ R46 ) = ( R49 @ R50 ) iff ( R44 . (R45 , R50) ) = ( R44 . (R49 , R46) )) & (( R44 . (R45 , R46) ) = R51 iff ( (R45 , R51) . R44 ) = R46)))))))))
proof
let R43 being MidSp;
let R44 being (ATLAS of R43);
let R45 being (Point of R43);
let R46 being (Point of R43);
let R49 being (Point of R43);
let R50 being (Point of R43);
let R51 being (Vector of R44);
set D36 = (the function of R44);
set D37 = (the algebra of R44);
L261: D36 is_atlas_of (the carrier of R43) , D37 by L220;
L262: D37 is  midpoint_operator  add-associative  right_zeroed  right_complementable  Abelian by L220;
thus L263: ( R44 . (R45 , R45) ) = ( 0. R44 ) by L262 , L261 , L13;
thus L264: (( R44 . (R45 , R46) ) = ( 0. R44 ) implies R45 = R46) by L262 , L261 , L17;
thus L265: ( R44 . (R45 , R46) ) = ( - ( R44 . (R46 , R45) ) ) by L262 , L261 , L22;
thus L266: (( R44 . (R45 , R46) ) = ( R44 . (R49 , R50) ) implies ( R44 . (R46 , R45) ) = ( R44 . (R50 , R49) )) by L262 , L261 , L27;
thus L267: (for R46 being (Point of R43) holds (for R51 being (Vector of R44) holds (ex R45 being (Point of R43) st ( R44 . (R45 , R46) ) = R51)))
proof
let R46 being (Point of R43);
let R51 being (Vector of R44);
consider R45 being (Point of R43) such that L268: ( D36 . (R45 , R46) ) = R51 by L262 , L261 , L31;
take R45;
thus L269: thesis by L268;
end;

thus L270: (( R44 . (R46 , R45) ) = ( R44 . (R49 , R45) ) implies R46 = R49) by L262 , L261 , L36;
L271: D36 is  associating by L220;
thus L272: (( R45 @ R46 ) = R49 iff ( R44 . (R45 , R49) ) = ( R44 . (R49 , R46) )) by L271 , L2;
thus L273: (( R45 @ R46 ) = ( R49 @ R50 ) iff ( R44 . (R45 , R50) ) = ( R44 . (R49 , R46) )) by L262 , L271 , L261 , L58;
thus L274: thesis by L261 , L11;
end;
theorem
L275: (for R43 being MidSp holds (for R44 being (ATLAS of R43) holds (for R45 being (Point of R43) holds ( (R45 , ( 0. R44 )) . R44 ) = R45)))
proof
let R43 being MidSp;
let R44 being (ATLAS of R43);
let R45 being (Point of R43);
L276: ( R44 . (R45 , R45) ) = ( 0. R44 ) by L260;
thus L277: thesis by L276 , L260;
end;
