:: Externally Programmed Machines
::  by Yatsuka Nakamura and Andrzej Trybulec
::
:: Received June 30, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies STRUCT_0, SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, ORDINAL1,
      CARD_1, FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FSM_1, SETFAM_1,
      GLIB_000, FINSET_1, CIRCUIT2, NAT_1, ARYTM_3, XXREAL_0, MSUALG_1,
      TURING_1, PARTFUN1, MCART_1, ZFMISC_1, GRAPHSP, ARYTM_1, FUNCT_7, AMI_1,
      PBOOLE, EXTPRO_1, GROUP_9, RECDEF_2, COMPOS_1, AMISTD_2, CARD_5,
      UNIALG_1,
      MEMSTR_0, GOBRD13, QUANTAL1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      CARD_1, PBOOLE, NUMBERS, FUNCT_7, CARD_3, XCMPLX_0, RELAT_1, FUNCT_1,
      PARTFUN1, FINSET_1, NAT_1, FUNCOP_1, FUNCT_4, FINSEQ_1, FUNCT_2,
      DOMAIN_1, RECDEF_2, MEASURE6,
      STRUCT_0, XXREAL_0, MEMSTR_0, COMPOS_0, COMPOS_1;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, FUNCT_7, GRAPH_2,
      RELSET_1, PRE_POLY, PBOOLE, COMPOS_1, MEMSTR_0, MEASURE6,
      XTUPLE_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, COMPOS_1, MEMSTR_0, ZFMISC_1,
      CARD_1, MEASURE6, COMPOS_0, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, FUNCOP_1, ORDINAL1, RELAT_1, PBOOLE, FUNCT_1,
      PARTFUN1, MCART_1, ZFMISC_1, COMPOS_1, MEMSTR_0, CARD_3, COMPOS_0,
      XTUPLE_0;
 theorems ZFMISC_1, FUNCT_2, TARSKI, NAT_1, CQC_LANG, CARD_3, FINSEQ_1,
      FUNCT_4, FUNCOP_1, FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1,
      XBOOLE_0, XBOOLE_1, ORDINAL1, MCART_1, ENUMSET1, SUBSET_1, XXREAL_0,
      FUNCT_7, INT_1, PARTFUN1, PBOOLE, RECDEF_2, FUNCT_5, COMPOS_1, MEMSTR_0,
      STRUCT_0, MEASURE6;
 schemes NAT_1, FRAENKEL;

begin
definition
let C1 being set;
struct (Mem-Struct over C1 , COM-Struct) AMI-Struct over C1(# carrier -> set , ZeroF -> (Element of the carrier) , InstructionsF -> Instructions , Object-Kind -> (Function of the carrier , C1) , ValuesF -> (ManySortedSet of C1) , Execution -> (Action of the InstructionsF , ( product ( the ValuesF * the Object-Kind ) )) #);
end;
definition
let R1 being  with_zero set;
func Trivial-AMI R1 ->  strict AMI-Struct over R1 means 
:L2: ((the carrier of it) = { ( 0 ) } & (the ZeroF of it) = ( 0 ) & (the InstructionsF of it) = { [ ( 0 ) , ( {} ) , ( {} ) ] } & (the Object-Kind of it) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of it) = ( R1 --> ( NAT ) ) & (the Execution of it) = ( [ ( 0 ) , ( {} ) , ( {} ) ] .--> ( id ( product ( ( R1 --> ( NAT ) ) * ( ( 0 ) .--> ( 0 ) ) ) ) ) ));
existence
proof
set D1 = { [ ( 0 ) , ( {} ) , ( {} ) ] };
reconsider D2 = [ ( 0 ) , ( {} ) , ( {} ) ] as (Element of D1) by TARSKI:def 1;
set D3 = ( ( 0 ) .--> ( 0 ) );
L3: ( dom D3 ) = ( dom ( ( 0 ) .--> ( 0 ) ) )
.= { ( 0 ) } by FUNCOP_1:13;
L4: ( rng D3 ) c= { ( 0 ) } by FUNCOP_1:13;
L5: ( 0 ) in R1 by MEASURE6:def 2;
L6: { ( 0 ) } c= R1 by L5 , ZFMISC_1:31;
L7: ( rng D3 ) c= R1 by L6 , L4 , XBOOLE_1:1;
reconsider D4 = D3 as (Function of { ( 0 ) } , R1) by L7 , L3 , RELSET_1:4;
reconsider D5 = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
reconsider D6 = ( D1 --> ( id ( product ( ( R1 --> ( NAT ) ) * D4 ) ) ) ) as (Action of D1 , ( product ( ( R1 --> ( NAT ) ) * D4 ) )) by FUNCOP_1:45 , FUNCT_2:9;
take D7 = AMI-Struct (# { ( 0 ) } , D5 , D1 , D4 , ( R1 --> ( NAT ) ) , D6 #);
thus L8: thesis;
end;
uniqueness;
end;
registration
let R1 being  with_zero set;
cluster ( Trivial-AMI R1 ) -> 1 -element;
coherence
proof
set D8 = ( Trivial-AMI R1 );
thus L10: (the carrier of D8) is 1 -element by L2;
end;
end;
registration
let R1 being  with_zero set;
cluster non  empty for AMI-Struct over R1;
existence
proof
take ( Trivial-AMI R1 );
thus L12: thesis;
end;
end;
registration
let R1 being  with_zero set;
cluster ( Trivial-AMI R1 ) ->  with_non-empty_values;
coherence
proof
let C2 being set;
set D9 = ( Trivial-AMI R1 );
set D10 = ( the_Values_of D9 );
assume L14: C2 in ( dom D10 );
L15: ( (the Object-Kind of D9) . C2 ) in ( dom (the ValuesF of D9) ) by L14 , FUNCT_1:11;
L16: (the ValuesF of D9) = ( R1 --> ( NAT ) ) by L2;
L17: ( (the Object-Kind of D9) . C2 ) in R1 by L16 , L15 , FUNCOP_1:13;
L18: ( D10 . C2 ) = ( (the ValuesF of D9) . ( (the Object-Kind of D9) . C2 ) ) by L14 , FUNCT_1:12
.= ( NAT ) by L17 , L16 , FUNCOP_1:7;
thus L19: ( D10 . C2 ) is non  empty by L18;
end;
end;
registration
let R1 being  with_zero set;
cluster  with_non-empty_values 1 -element for AMI-Struct over R1;
existence
proof
take ( Trivial-AMI R1 );
thus L21: thesis;
end;
end;
definition
let R1 being  with_zero set;
let C3 being  with_non-empty_values AMI-Struct over R1;
let C4 being (Instruction of C3);
let C5 being (State of C3);
func Exec (C4 , C5) -> (State of C3) equals 
( ( (the Execution of C3) . C4 ) . C5 );
coherence
proof
consider C6 being Function such that L23: (( (the Execution of C3) . C4 ) = C6 & ( dom C6 ) = ( product ( the_Values_of C3 ) )) and L24: ( rng C6 ) c= ( product ( the_Values_of C3 ) ) by FUNCT_2:def 2;
reconsider D11 = C5 as (Element of ( product ( the_Values_of C3 ) )) by CARD_3:107;
L25: ( ( (the Execution of C3) . C4 ) . D11 ) in ( rng C6 ) by L23 , FUNCT_1:def 3;
thus L26: thesis by L25 , L24;
end;
end;
definition
let R2 being  with_zero set;
let C7 being  with_non-empty_values AMI-Struct over R2;
let C8 being (Instruction of C7);
attr C8 is  halting
means
:L28: (for B1 being (State of C7) holds ( Exec (C8 , B1) ) = B1);
end;
definition
let R2 being  with_zero set;
let C9 being  with_non-empty_values AMI-Struct over R2;
attr C9 is  halting
means
:L30: ( halt C9 ) is  halting;
end;
registration
let R2 being  with_zero set;
cluster ( Trivial-AMI R2 ) ->  halting;
coherence
proof
set D12 = ( Trivial-AMI R2 );
set D13 = ( ( R2 --> ( NAT ) ) * ( ( 0 ) .--> ( 0 ) ) );
L32: ((the Object-Kind of D12) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of D12) = ( R2 --> ( NAT ) )) by L2;
set D14 = ( halt D12 );
let C10 being (State of D12);
reconsider D15 = C10 as (Element of ( product ( the_Values_of D12 ) )) by CARD_3:107;
L33: ( ( D14 .--> ( id ( product D13 ) ) ) . D14 ) = ( id ( product D13 ) ) by FUNCOP_1:72;
thus L34: ( Exec (D14 , C10) ) = ( ( id ( product D13 ) ) . D15 ) by L33 , L2
.= C10 by L32 , FUNCT_1:18;
end;
end;
registration
let R2 being  with_zero set;
cluster  halting for  with_non-empty_values non  empty  with_non-empty_values non  empty  with_non-empty_values non  empty  with_non-empty_values non  empty AMI-Struct over R2;
existence
proof
take ( Trivial-AMI R2 );
thus L36: thesis;
end;
end;
registration
let R2 being  with_zero set;
let C11 being  halting  with_non-empty_values AMI-Struct over R2;
cluster ( halt C11 ) ->  halting;
coherence by L30;
end;
registration
let R2 being  with_zero set;
let C12 being  halting  with_non-empty_values AMI-Struct over R2;
cluster  halting for (Instruction of C12);
existence
proof
take ( halt C12 );
thus L39: thesis;
end;
end;
theorem
L41: (for R2 being  with_zero set holds (for B2 being (State of ( Trivial-AMI R2 )) holds (for B3 being (Instruction of ( Trivial-AMI R2 )) holds ( Exec (B3 , B2) ) = B2)))
proof
let R2 being  with_zero set;
set D16 = ( Trivial-AMI R2 );
let C13 being (State of ( Trivial-AMI R2 ));
let C14 being (Instruction of ( Trivial-AMI R2 ));
set D17 = ( ( R2 --> ( NAT ) ) * ( ( 0 ) .--> ( 0 ) ) );
L42: ((the Object-Kind of D16) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of D16) = ( R2 --> ( NAT ) )) by L2;
reconsider D18 = C13 as (Element of ( product ( the_Values_of D16 ) )) by CARD_3:107;
L43: (the InstructionsF of D16) = { [ ( 0 ) , ( {} ) , ( {} ) ] } by L2;
L44: (( ( C14 .--> ( id ( product D17 ) ) ) . C14 ) = ( id ( product D17 ) ) & C14 = [ ( 0 ) , ( {} ) , ( {} ) ]) by L43 , FUNCOP_1:72 , TARSKI:def 1;
thus L45: ( Exec (C14 , C13) ) = ( ( id ( product D17 ) ) . D18 ) by L44 , L2
.= C13 by L42 , FUNCT_1:18;
end;
registration
let C15 being  with_zero set;
cluster ( Trivial-AMI C15 ) ->  IC-Ins-separated;
coherence
proof
set D19 = ( Trivial-AMI C15 );
L46: ((the Object-Kind of ( Trivial-AMI C15 )) = ( ( 0 ) .--> ( 0 ) ) & (the ValuesF of ( Trivial-AMI C15 )) = ( C15 --> ( NAT ) )) by L2;
L47: ( 0 ) in C15 by MEASURE6:def 2;
L48: ( 0 ) in ( dom ( ( 0 ) .--> ( 0 ) ) ) by FUNCOP_1:73;
thus L49: ( Values ( IC ( Trivial-AMI C15 ) ) ) = ( ( the_Values_of ( Trivial-AMI C15 ) ) . ( 0 ) ) by L2
.= ( ( ( C15 --> ( NAT ) ) * ( ( 0 ) .--> ( 0 ) ) ) . ( 0 ) ) by L46
.= ( ( C15 --> ( NAT ) ) . ( ( ( 0 ) .--> ( 0 ) ) . ( 0 ) ) ) by L48 , FUNCT_1:13
.= ( ( C15 --> ( NAT ) ) . ( 0 ) ) by FUNCOP_1:72
.= ( NAT ) by L47 , FUNCOP_1:7;
end;
end;
registration
let C16 being  with_zero set;
cluster  IC-Ins-separated  strict  trivial for non  empty  with_non-empty_values non  empty  with_non-empty_values non  empty  with_non-empty_values non  empty  with_non-empty_values AMI-Struct over C16;
existence
proof
take ( Trivial-AMI C16 );
thus L51: thesis;
end;
end;
registration
let R2 being  with_zero set;
cluster  IC-Ins-separated  halting  strict for 1 -element  with_non-empty_values 1 -element  with_non-empty_values 1 -element  with_non-empty_values 1 -element  with_non-empty_values AMI-Struct over R2;
existence
proof
take ( Trivial-AMI R2 );
thus L53: thesis;
end;
end;
begin
definition
let R2 being  with_zero set;
let R14 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C17 being (the InstructionsF of R14) -valued Function;
let C18 being (State of R14);
func CurInstr (C17 , C18) -> (Instruction of R14) equals 
( C17 /. ( IC C18 ) );
coherence;
end;
definition
let R2 being  with_zero set;
let R14 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C19 being (State of R14);
let C20 being (the InstructionsF of R14) -valued Function;
func Following (C20 , C19) -> (State of R14) equals 
( Exec (( CurInstr (C20 , C19) ) , C19) );
correctness;
end;
definition
let R2 being  with_zero set;
let R14 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C21 being ( NAT ) -defined (the InstructionsF of R14) -valued Function;
deffunc H1(set , (State of R14)) = ( down ( Following (C21 , $2) ) );
let C22 being (State of R14);
let C23 being Nat;
func Comput (C21 , C22 , C23) -> (State of R14) means 
:L57: (ex B4 being (Function of ( NAT ) , ( product ( the_Values_of R14 ) )) st (it = ( B4 . C23 ) & ( B4 . ( 0 ) ) = C22 & (for B5 being Nat holds ( B4 . ( B5 + 1 ) ) = ( Following (C21 , ( B4 . B5 )) ))));
existence
proof
reconsider D20 = C22 as (Element of ( product ( the_Values_of R14 ) )) by CARD_3:107;
consider C24 being (Function of ( NAT ) , ( product ( the_Values_of R14 ) )) such that L58: ( C24 . ( 0 ) ) = D20 and L59: (for B6 being Nat holds ( C24 . ( B6 + 1 ) ) = H1(B6 , ( C24 . B6 ))) from NAT_1:sch 12;
take ( C24 . C23 );
take C24;
thus L60: ( C24 . C23 ) = ( C24 . C23 );
thus L61: ( C24 . ( 0 ) ) = C22 by L58;
let C25 being Nat;
thus L62: ( C24 . ( C25 + 1 ) ) = H1(C25 , ( C24 . C25 )) by L59
.= ( Following (C21 , ( C24 . C25 )) );
end;
uniqueness
proof
let C26 , C27 being (State of R14);
given C28 being (Function of ( NAT ) , ( product ( the_Values_of R14 ) )) such that
L63: C26 = ( C28 . C23 )
and
L64: ( C28 . ( 0 ) ) = C22
and
L65: (for B7 being Nat holds ( C28 . ( B7 + 1 ) ) = ( Following (C21 , ( C28 . B7 )) ));

given C29 being (Function of ( NAT ) , ( product ( the_Values_of R14 ) )) such that
L66: C27 = ( C29 . C23 )
and
L67: ( C29 . ( 0 ) ) = C22
and
L68: (for B8 being Nat holds ( C29 . ( B8 + 1 ) ) = ( Following (C21 , ( C29 . B8 )) ));

reconsider D21 = C22 as (Element of ( product ( the_Values_of R14 ) )) by CARD_3:107;
L69: ( C28 . ( 0 ) ) = D21 by L64;
L70: (for B9 being Nat holds ( C28 . ( B9 + 1 ) ) = H1(B9 , ( C28 . B9 ))) by L65;
L71: ( C29 . ( 0 ) ) = D21 by L67;
L72: (for B10 being Nat holds ( C29 . ( B10 + 1 ) ) = H1(B10 , ( C29 . B10 ))) by L68;
L73: C28 = C29 from NAT_1:sch 16(L69 , L70 , L71 , L72);
thus L74: thesis by L73 , L63 , L66;
end;
end;
definition
let R2 being  with_zero set;
let C30 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C31 being ( NAT ) -defined (the InstructionsF of C30) -valued Function;
let C32 being (State of C30);
pred C31 halts_on C32
means
:L76: (ex B11 being Nat st (( IC ( Comput (C31 , C32 , B11) ) ) in ( dom C31 ) & ( CurInstr (C31 , ( Comput (C31 , C32 , B11) )) ) = ( halt C30 )))
;end;
registration
let C33 being non  empty  with_zero set;
let C34 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over C33;
let C35 being ( NAT ) -defined (the InstructionsF of C34) -valued Function;
let C36 being (State of C34);
reduce ( Comput (C35 , C36 , ( 0 )) ) to C36;
reducibility
proof
L78: (ex B12 being (Function of ( NAT ) , ( product ( the_Values_of C34 ) )) st (( Comput (C35 , C36 , ( 0 )) ) = ( B12 . ( 0 ) ) & ( B12 . ( 0 ) ) = C36 & (for B13 being Nat holds ( B12 . ( B13 + 1 ) ) = ( Following (C35 , ( B12 . B13 )) )))) by L57;
thus L79: thesis by L78;
end;
end;
theorem
L81: (for B14 being non  empty  with_zero set holds (for B15 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B14 holds (for B16 being ( NAT ) -defined (the InstructionsF of B15) -valued Function holds (for B17 being (State of B15) holds ( Comput (B16 , B17 , ( 0 )) ) = B17))));
theorem
L82: (for B18 being non  empty  with_zero set holds (for B19 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B18 holds (for B20 being ( NAT ) -defined (the InstructionsF of B19) -valued Function holds (for B21 being (State of B19) holds (for B22 being Nat holds ( Comput (B20 , B21 , ( B22 + 1 )) ) = ( Following (B20 , ( Comput (B20 , B21 , B22) )) ))))))
proof
let R2 being  with_zero set;
let C37 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R2;
let C38 being ( NAT ) -defined (the InstructionsF of C37) -valued Function;
let C39 being (State of C37);
let C40 being Nat;
deffunc H2(set , (State of C37)) = ( down ( Following (C38 , $2) ) );
reconsider D22 = C39 as (Element of ( product ( the_Values_of C37 ) )) by CARD_3:107;
consider C41 being (Function of ( NAT ) , ( product ( the_Values_of C37 ) )) such that L83: ( Comput (C38 , D22 , ( C40 + 1 )) ) = ( C41 . ( C40 + 1 ) ) and L84: ( C41 . ( 0 ) ) = D22 and L85: (for B23 being Nat holds ( C41 . ( B23 + 1 ) ) = ( Following (C38 , ( C41 . B23 )) )) by L57;
consider C42 being (Function of ( NAT ) , ( product ( the_Values_of C37 ) )) such that L86: ( Comput (C38 , D22 , C40) ) = ( C42 . C40 ) and L87: ( C42 . ( 0 ) ) = D22 and L88: (for B24 being Nat holds ( C42 . ( B24 + 1 ) ) = ( Following (C38 , ( C42 . B24 )) )) by L57;
L89: (for B25 being Nat holds ( C41 . ( B25 + 1 ) ) = H2(B25 , ( C41 . B25 ))) by L85;
L90: (for B26 being Nat holds ( C42 . ( B26 + 1 ) ) = H2(B26 , ( C42 . B26 ))) by L88;
L91: C41 = C42 from NAT_1:sch 16(L84 , L89 , L87 , L90);
thus L92: thesis by L91 , L83 , L86 , L88;
end;
theorem
L93: (for R11 being (Element of ( NAT )) holds (for R16 being non  empty  with_zero set holds (for R17 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for R18 being (State of R17) holds (for B27 being ( NAT ) -defined (the InstructionsF of R17) -valued Function holds (for R13 being (Element of ( NAT )) holds ( Comput (B27 , R18 , ( R11 + R13 )) ) = ( Comput (B27 , ( Comput (B27 , R18 , R11) ) , R13) )))))))
proof
let R11 being (Element of ( NAT ));
let R16 being non  empty  with_zero set;
let R17 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let R18 being (State of R17);
let C43 being ( NAT ) -defined (the InstructionsF of R17) -valued Function;
defpred S1[ (Element of ( NAT )) ] means ( Comput (C43 , R18 , ( R11 + $1 )) ) = ( Comput (C43 , ( Comput (C43 , R18 , R11) ) , $1) );
L94:
now
let R13 being (Element of ( NAT ));
assume L95: S1[ R13 ];
L96: ( Comput (C43 , R18 , ( R11 + ( R13 + 1 ) )) ) = ( Comput (C43 , R18 , ( ( R11 + R13 ) + 1 )) )
.= ( Following (C43 , ( Comput (C43 , R18 , ( R11 + R13 )) )) ) by L82
.= ( Comput (C43 , ( Comput (C43 , R18 , R11) ) , ( R13 + 1 )) ) by L95 , L82;
thus L97: S1[ ( R13 + 1 ) ] by L96;
end;
L98: S1[ ( 0 ) ];
thus L99: (for R13 being (Element of ( NAT )) holds S1[ R13 ]) from NAT_1:sch 1(L98 , L94);
end;
theorem
L100: (for R11 being (Element of ( NAT )) holds (for R12 being (Element of ( NAT )) holds (R11 <= R12 implies (for R16 being non  empty  with_zero set holds (for B28 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B29 being ( NAT ) -defined (the InstructionsF of B28) -valued Function holds (for B30 being (State of B28) holds (( CurInstr (B29 , ( Comput (B29 , B30 , R11) )) ) = ( halt B28 ) implies ( Comput (B29 , B30 , R12) ) = ( Comput (B29 , B30 , R11) )))))))))
proof
let R11 being (Element of ( NAT ));
let R12 being (Element of ( NAT ));
assume L101: R11 <= R12;
consider C44 being Nat such that L102: R12 = ( R11 + C44 ) by L101 , NAT_1:10;
reconsider D23 = C44 as (Element of ( NAT )) by ORDINAL1:def 12;
L103: R12 = ( R11 + D23 ) by L102;
let R16 being non  empty  with_zero set;
let C45 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C46 being ( NAT ) -defined (the InstructionsF of C45) -valued Function;
let C47 being (State of C45);
assume that
L104: ( CurInstr (C46 , ( Comput (C46 , C47 , R11) )) ) = ( halt C45 );
defpred S2[ (Element of ( NAT )) ] means ( Comput (C46 , C47 , ( R11 + $1 )) ) = ( Comput (C46 , C47 , R11) );
L105:
now
let R13 being (Element of ( NAT ));
assume L106: S2[ R13 ];
L107: ( Comput (C46 , C47 , ( R11 + ( R13 + 1 ) )) ) = ( Comput (C46 , C47 , ( ( R11 + R13 ) + 1 )) )
.= ( Following (C46 , ( Comput (C46 , C47 , ( R11 + R13 )) )) ) by L82
.= ( Comput (C46 , C47 , R11) ) by L104 , L106 , L28;
thus L108: S2[ ( R13 + 1 ) ] by L107;
end;
L109: S2[ ( 0 ) ];
L110: (for R13 being (Element of ( NAT )) holds S2[ R13 ]) from NAT_1:sch 1(L109 , L105);
thus L111: thesis by L110 , L103;
end;
definition
let R16 being non  empty  with_zero set;
let C48 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C49 being ( NAT ) -defined (the InstructionsF of C48) -valued Function;
let C50 being (State of C48);
assume that
L112: C49 halts_on C50;
func Result (C49 , C50) -> (State of C48) means 
:L113: (ex R13 being (Element of ( NAT )) st (it = ( Comput (C49 , C50 , R13) ) & ( CurInstr (C49 , it) ) = ( halt C48 )));
uniqueness
proof
let C51 , C52 being (State of C48);
given C53 being (Element of ( NAT )) such that
L114: (C51 = ( Comput (C49 , C50 , C53) ) & ( CurInstr (C49 , C51) ) = ( halt C48 ));

given C54 being (Element of ( NAT )) such that
L115: (C52 = ( Comput (C49 , C50 , C54) ) & ( CurInstr (C49 , C52) ) = ( halt C48 ));

L116: (C53 <= C54 or C54 <= C53);
thus L117: thesis by L116 , L114 , L115 , L100;
end;
correctness
proof
consider C55 being Nat such that L118: ( IC ( Comput (C49 , C50 , C55) ) ) in ( dom C49 ) and L119: ( CurInstr (C49 , ( Comput (C49 , C50 , C55) )) ) = ( halt C48 ) by L112 , L76;
L120: C55 in ( NAT ) by ORDINAL1:def 12;
thus L121: thesis by L120 , L119;
end;
end;
theorem
L123: (for R13 being (Element of ( NAT )) holds (for R16 being non  empty  with_zero set holds (for B31 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B32 being (Instruction-Sequence of B31) holds (for B33 being (State of B31) holds ( Comput (B32 , B33 , ( R13 + 1 )) ) = ( Exec (( B32 . ( IC ( Comput (B32 , B33 , R13) ) ) ) , ( Comput (B32 , B33 , R13) )) ))))))
proof
let R13 being (Element of ( NAT ));
let R16 being non  empty  with_zero set;
let C56 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C57 being (Instruction-Sequence of C56);
let C58 being (State of C56);
L124: ( dom C57 ) = ( NAT ) by PARTFUN1:def 2;
thus L125: ( Comput (C57 , C58 , ( R13 + 1 )) ) = ( Following (C57 , ( Comput (C57 , C58 , R13) )) ) by L82
.= ( Exec (( C57 . ( IC ( Comput (C57 , C58 , R13) ) ) ) , ( Comput (C57 , C58 , R13) )) ) by L124 , PARTFUN1:def 6;
end;
theorem
L126: (for R16 being non  empty  with_zero set holds (for B34 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R16 holds (for B35 being (Instruction-Sequence of B34) holds (for B36 being (State of B34) holds (for R13 being (Element of ( NAT )) holds (( B35 . ( IC ( Comput (B35 , B36 , R13) ) ) ) = ( halt B34 ) implies ( Result (B35 , B36) ) = ( Comput (B35 , B36 , R13) )))))))
proof
let R16 being non  empty  with_zero set;
let C59 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R16;
let C60 being (Instruction-Sequence of C59);
let C61 being (State of C59);
let R13 being (Element of ( NAT ));
L127: ( dom C60 ) = ( NAT ) by PARTFUN1:def 2;
assume L128: ( C60 . ( IC ( Comput (C60 , C61 , R13) ) ) ) = ( halt C59 );
L129: ( CurInstr (C60 , ( Comput (C60 , C61 , R13) )) ) = ( halt C59 ) by L128 , L127 , PARTFUN1:def 6;
L130: C60 halts_on C61 by L129 , L76 , L127;
thus L131: thesis by L130 , L129 , L113;
end;
theorem
L132: (for R16 being non  empty  with_zero set holds (for B37 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R16 holds (for B38 being (Instruction-Sequence of B37) holds (for B39 being (State of B37) holds ((ex R13 being (Element of ( NAT )) st ( B38 . ( IC ( Comput (B38 , B39 , R13) ) ) ) = ( halt B37 )) implies (for R11 being (Element of ( NAT )) holds ( Result (B38 , B39) ) = ( Result (B38 , ( Comput (B38 , B39 , R11) )) )))))))
proof
let R16 being non  empty  with_zero set;
let C62 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R16;
let C63 being (Instruction-Sequence of C62);
let C64 being (State of C62);
given R13 being (Element of ( NAT )) such that
L133: ( C63 . ( IC ( Comput (C63 , C64 , R13) ) ) ) = ( halt C62 );

let R11 being (Element of ( NAT ));
L134: ( dom C63 ) = ( NAT ) by PARTFUN1:def 2;
set D24 = ( Comput (C63 , C64 , R13) );
L135: ( CurInstr (C63 , D24) ) = ( halt C62 ) by L133 , L134 , PARTFUN1:def 6;
L136:
now
per cases ;
suppose L137: R11 <= R13;

consider C65 being Nat such that L138: R13 = ( R11 + C65 ) by L137 , NAT_1:10;
reconsider D25 = C65 as (Element of ( NAT )) by ORDINAL1:def 12;
L139: ( Comput (C63 , C64 , R13) ) = ( Comput (C63 , ( Comput (C63 , C64 , R11) ) , D25) ) by L138 , L93;
L140: C63 halts_on ( Comput (C63 , C64 , R11) ) by L135 , L139 , L76 , L134;
thus L141: ( Result (C63 , C64) ) = D24 by L133 , L126
.= ( Result (C63 , ( Comput (C63 , C64 , R11) )) ) by L135 , L139 , L140 , L113;
end;
suppose L142: R11 >= R13;

L143: ( Comput (C63 , ( Comput (C63 , C64 , R13) ) , ( 0 )) ) = ( Comput (C63 , C64 , R13) );
L144: ( Comput (C63 , C64 , R11) ) = D24 by L135 , L142 , L100;
L145: C63 halts_on ( Comput (C63 , C64 , R11) ) by L76 , L134 , L144 , L135 , L143;
thus L146: ( Result (C63 , C64) ) = D24 by L133 , L126
.= ( Result (C63 , ( Comput (C63 , C64 , R11) )) ) by L135 , L144 , L143 , L145 , L113;
end;
end;
thus L148: thesis by L136;
end;
definition
let R16 being non  empty  with_zero set;
let C66 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C67 being (the InstructionsF of C66) -valued ( NAT ) -defined Function;
let C68 being (PartState of C66);
attr C68 is C67 -autonomic
means
:L149: (for B40 , B41 being (Instruction-Sequence of C66) holds ((C67 c= B40 & C67 c= B41) implies (for B42 , B43 being (State of C66) holds ((C68 c= B42 & C68 c= B43) implies (for R11 being (Element of ( NAT )) holds ( ( Comput (B40 , B42 , R11) ) | ( dom C68 ) ) = ( ( Comput (B41 , B43 , R11) ) | ( dom C68 ) ))))));
end;
definition
let R16 being non  empty  with_zero set;
let C69 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C70 being (the InstructionsF of C69) -valued ( NAT ) -defined Function;
let C71 being (PartState of C69);
attr C71 is C70 -halted
means
:L151: (for B44 being (State of C69) holds (C71 c= B44 implies (for B45 being (Instruction-Sequence of C69) holds (C70 c= B45 implies B45 halts_on B44))));
end;
registration
let R16 being non  empty  with_zero set;
cluster  halting  strict for  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
existence
proof
take ( Trivial-AMI R16 );
thus L153: thesis;
end;
end;
begin
theorem
L155: (for R16 being non  empty  with_zero set holds (for B46 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B47 being (Element of ( NAT )) holds (for B48 being (Instruction of B46) holds (for B49 being ( NAT ) -defined (the InstructionsF of B46) -valued Function holds (( B47 .--> B48 ) c= B49 implies (for B50 being (State of B46) holds (( ( IC B46 ) .--> B47 ) c= B50 implies ( CurInstr (B49 , B50) ) = B48))))))))
proof
let R16 being non  empty  with_zero set;
let C72 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C73 being (Element of ( NAT ));
let C74 being (Instruction of C72);
let C75 being ( NAT ) -defined (the InstructionsF of C72) -valued Function;
assume that
L156: ( C73 .--> C74 ) c= C75;
let C76 being (State of C72);
assume that
L157: ( ( IC C72 ) .--> C73 ) c= C76;
L158: ( dom ( ( IC C72 ) .--> C73 ) ) = { ( IC C72 ) } by FUNCOP_1:13;
L159: ( IC C72 ) in ( dom ( ( IC C72 ) .--> C73 ) ) by L158 , TARSKI:def 1;
L160: ( IC C76 ) = ( ( ( IC C72 ) .--> C73 ) . ( IC C72 ) ) by L159 , L157 , GRFUNC_1:2
.= C73 by FUNCOP_1:72;
L161: ( dom ( C73 .--> C74 ) ) = { C73 } by FUNCOP_1:13;
L162: ( IC C76 ) in ( dom ( C73 .--> C74 ) ) by L161 , L160 , TARSKI:def 1;
L163: ( dom ( C73 .--> C74 ) ) c= ( dom C75 ) by L156 , RELAT_1:11;
thus L164: ( CurInstr (C75 , C76) ) = ( C75 . ( IC C76 ) ) by L163 , L162 , PARTFUN1:def 6
.= ( ( C73 .--> C74 ) . ( IC C76 ) ) by L162 , L156 , GRFUNC_1:2
.= C74 by L160 , FUNCOP_1:72;
end;
theorem
L165: (for R16 being non  empty  with_zero set holds (for B51 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B52 being (Element of ( NAT )) holds (for B53 being ( NAT ) -defined (the InstructionsF of B51) -valued Function holds (( B52 .--> ( halt B51 ) ) c= B53 implies (for B54 being B52 -started (PartState of B51) holds B54 is B53 -halted))))))
proof
let R16 being non  empty  with_zero set;
let C77 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C78 being (Element of ( NAT ));
let C79 being ( NAT ) -defined (the InstructionsF of C77) -valued Function;
assume that
L166: ( C78 .--> ( halt C77 ) ) c= C79;
let C80 being C78 -started (PartState of C77);
set D26 = ( halt C77 );
set D27 = ( C80 +* C79 );
let C81 being (State of C77);
assume that
L167: C80 c= C81;
let C82 being (Instruction-Sequence of C77);
assume that
L168: C79 c= C82;
take ( 0 );
L169: ( dom C82 ) = ( NAT ) by PARTFUN1:def 2;
thus L170: ( IC ( Comput (C82 , C81 , ( 0 )) ) ) in ( dom C82 ) by L169;
L171: ( Start-At (C78 , C77) ) c= C80 by MEMSTR_0:29;
L172: ( Start-At (C78 , C77) ) c= C81 by L171 , L167 , XBOOLE_1:1;
L173: ( C78 .--> D26 ) c= C82 by L166 , L168 , XBOOLE_1:1;
L174: ( dom ( C78 .--> D26 ) ) = { C78 } by FUNCOP_1:13;
L175: ( IC C77 ) in ( dom ( Start-At (C78 , C77) ) ) by MEMSTR_0:15;
L176: ( IC C81 ) = ( IC ( Start-At (C78 , C77) ) ) by L175 , L172 , GRFUNC_1:2
.= C78 by FUNCOP_1:72;
L177: ( IC C81 ) in ( dom ( C78 .--> D26 ) ) by L174 , L176 , TARSKI:def 1;
L178: ( dom ( C78 .--> D26 ) ) c= ( dom C82 ) by L173 , RELAT_1:11;
thus L179: ( CurInstr (C82 , ( Comput (C82 , C81 , ( 0 )) )) ) = ( CurInstr (C82 , C81) )
.= ( C82 . ( IC C81 ) ) by L178 , L177 , PARTFUN1:def 6
.= ( ( C78 .--> D26 ) . ( IC C81 ) ) by L177 , L173 , GRFUNC_1:2
.= ( CurInstr (( C78 .--> D26 ) , C81) ) by L177 , PARTFUN1:def 6
.= ( halt C77 ) by L172 , L155;
end;
theorem
L180: (for R16 being non  empty  with_zero set holds (for B55 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B56 being (Element of ( NAT )) holds (for B57 being ( NAT ) -defined (the InstructionsF of B55) -valued Function holds (( B56 .--> ( halt B55 ) ) c= B57 implies (for B58 being B56 -started (PartState of B55) holds (for B59 being (State of B55) holds (B58 c= B59 implies (for R11 being (Element of ( NAT )) holds ( Comput (B57 , B59 , R11) ) = B59)))))))))
proof
let R16 being non  empty  with_zero set;
let C83 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C84 being (Element of ( NAT ));
let C85 being ( NAT ) -defined (the InstructionsF of C83) -valued Function;
assume that
L181: ( C84 .--> ( halt C83 ) ) c= C85;
let C86 being C84 -started (PartState of C83);
set D28 = ( halt C83 );
let C87 being (State of C83);
assume that
L182: C86 c= C87;
L183: ( Start-At (C84 , C83) ) c= C86 by MEMSTR_0:29;
defpred S3[ (Element of ( NAT )) ] means ( Comput (C85 , C87 , $1) ) = C87;
L184: ( Start-At (C84 , C83) ) c= C87 by L183 , L182 , XBOOLE_1:1;
L185:
now
let R11 being (Element of ( NAT ));
assume L186: S3[ R11 ];
L187: ( Comput (C85 , C87 , ( R11 + 1 )) ) = ( Following (C85 , C87) ) by L186 , L82
.= ( Exec (( halt C83 ) , C87) ) by L184 , L181 , L155
.= C87 by L28;
thus L188: S3[ ( R11 + 1 ) ] by L187;
end;
L189: S3[ ( 0 ) ];
thus L190: (for R11 being (Element of ( NAT )) holds S3[ R11 ]) from NAT_1:sch 1(L189 , L185);
end;
theorem
L191: (for R16 being non  empty  with_zero set holds (for B60 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B61 being (Element of ( NAT )) holds (for B62 being ( NAT ) -defined (the InstructionsF of B60) -valued Function holds (( B61 .--> ( halt B60 ) ) c= B62 implies (for B63 being B61 -started (PartState of B60) holds B63 is B62 -autonomic))))))
proof
let R16 being non  empty  with_zero set;
let C88 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C89 being (Element of ( NAT ));
set D29 = ( halt C88 );
set D30 = ( Start-At (C89 , C88) );
let C90 being ( NAT ) -defined (the InstructionsF of C88) -valued Function;
assume that
L192: ( C89 .--> ( halt C88 ) ) c= C90;
let C91 being C89 -started (PartState of C88);
set D31 = ( C91 +* C90 );
let C92 , C93 being (Instruction-Sequence of C88);
assume that
L193: (C90 c= C92 & C90 c= C93);
let C94 , C95 being (State of C88);
assume that
L194: C91 c= C94
and
L195: C91 c= C95;
let R11 being (Element of ( NAT ));
L196: (( C89 .--> ( halt C88 ) ) c= C92 & ( C89 .--> ( halt C88 ) ) c= C93) by L192 , L193 , XBOOLE_1:1;
thus L197: ( ( Comput (C92 , C94 , R11) ) | ( dom C91 ) ) = ( C94 | ( dom C91 ) ) by L196 , L194 , L180
.= C91 by L194 , GRFUNC_1:23
.= ( C95 | ( dom C91 ) ) by L195 , GRFUNC_1:23
.= ( ( Comput (C93 , C95 , R11) ) | ( dom C91 ) ) by L195 , L180 , L196;
end;
registration
let R16 being non  empty  with_zero set;
let C96 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C97 being non  halt-free (the InstructionsF of C96) -valued ( NAT ) -defined Function;
cluster C97 -autonomic C97 -halted non  empty for (FinPartState of C96);
existence
proof
L198: ( halt C96 ) in ( rng C97 ) by COMPOS_1:def 11;
consider C98 being set such that L199: C98 in ( dom C97 ) and L200: ( C97 . C98 ) = ( halt C96 ) by L198 , FUNCT_1:def 3;
L201: ( dom C97 ) c= ( NAT ) by RELAT_1:def 18;
reconsider D32 = C98 as (Element of ( NAT )) by L201 , L199;
take D33 = ( Start-At (D32 , C96) );
L202: ( D32 .--> ( halt C96 ) ) c= C97 by L199 , L200 , FUNCT_4:85;
thus L203: thesis by L202 , L165 , L191;
end;
end;
definition
let R16 being non  empty  with_zero set;
let C99 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C100 being non  halt-free ( NAT ) -defined (the InstructionsF of C99) -valued Function;
mode Autonomy of C100
 -> (FinPartState of C99)
means :L205: it is C100 -autonomic C100 -halted;
existence
proof
L206: ( halt C99 ) in ( rng C100 ) by COMPOS_1:def 11;
consider R3 being set such that L207: R3 in ( dom C100 ) and L208: ( C100 . R3 ) = ( halt C99 ) by L206 , FUNCT_1:def 3;
L209: ( dom C100 ) c= ( NAT ) by RELAT_1:def 18;
reconsider D34 = R3 as (Element of ( NAT )) by L209 , L207;
L210: [ D34 , ( halt C99 ) ] in C100 by L207 , L208 , FUNCT_1:def 2;
L211: { [ D34 , ( halt C99 ) ] } c= C100 by L210 , ZFMISC_1:31;
L212: ( D34 .--> ( halt C99 ) ) c= C100 by L211 , FUNCT_4:82;
take D35 = ( Start-At (D34 , C99) );
thus L213: D35 is C100 -autonomic by L212 , L191;
thus L214: D35 is C100 -halted by L212 , L165;
end;
end;
definition
let R16 being non  empty  with_zero set;
let C101 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C102 being non  halt-free ( NAT ) -defined (the InstructionsF of C101) -valued Function;
let C103 being (FinPartState of C101);
assume L216: C103 is (Autonomy of C102);
func Result (C102 , C103) -> (FinPartState of C101) means 
(for B64 being (Instruction-Sequence of C101) holds (C102 c= B64 implies (for B65 being (State of C101) holds (C103 c= B65 implies it = ( ( Result (B64 , B65) ) | ( dom C103 ) )))));
existence
proof
consider C104 being (State of C101) such that L217: C103 c= C104 by PBOOLE:141;
consider C105 being (Instruction-Sequence of C101) such that L218: C102 c= C105 by PBOOLE:145;
L219: C103 is C102 -halted C102 -autonomic by L216 , L205;
L220: C105 halts_on C104 by L219 , L151 , L218 , L217;
consider C106 being (Element of ( NAT )) such that L221: ( Result (C105 , C104) ) = ( Comput (C105 , C104 , C106) ) and L222: ( CurInstr (C105 , ( Result (C105 , C104) )) ) = ( halt C101 ) by L220 , L113;
reconsider D36 = ( ( Result (C105 , C104) ) | ( dom C103 ) ) as (FinPartState of C101);
take D36;
let C107 being (Instruction-Sequence of C101);
assume that
L223: C102 c= C107;
let C108 being (State of C101);
assume L224: C103 c= C108;
L225: C107 halts_on C108 by L224 , L151 , L219 , L223;
consider C109 being (Element of ( NAT )) such that L226: ( Result (C107 , C108) ) = ( Comput (C107 , C108 , C109) ) and L227: ( CurInstr (C107 , ( Result (C107 , C108) )) ) = ( halt C101 ) by L225 , L113;
per cases ;
suppose L228: C106 <= C109;

L229: ( Result (C105 , C104) ) = ( Comput (C105 , C104 , C109) ) by L228 , L221 , L222 , L100;
thus L230: D36 = ( ( Result (C107 , C108) ) | ( dom C103 ) ) by L229 , L226 , L149 , L219 , L218 , L223 , L224 , L217;
end;
suppose L231: C106 >= C109;

L232: ( Result (C107 , C108) ) = ( Comput (C107 , C108 , C106) ) by L231 , L226 , L227 , L100;
thus L233: thesis by L232 , L221 , L149 , L219 , L218 , L223 , L224 , L217;
end;
end;
correctness
proof
consider C110 being (State of C101) such that L235: C103 c= C110 by PBOOLE:141;
consider C111 being (Instruction-Sequence of C101) such that L236: C102 c= C111 by PBOOLE:145;
let C112 , C113 being (FinPartState of C101);
assume that
L237: (for B66 being (Instruction-Sequence of C101) holds (C102 c= B66 implies (for B67 being (State of C101) holds (C103 c= B67 implies C112 = ( ( Result (B66 , B67) ) | ( dom C103 ) )))))
and
L238: (for B68 being (Instruction-Sequence of C101) holds (C102 c= B68 implies (for B69 being (State of C101) holds (C103 c= B69 implies C113 = ( ( Result (B68 , B69) ) | ( dom C103 ) )))));
thus L239: C112 = ( ( Result (C111 , C110) ) | ( dom C103 ) ) by L237 , L235 , L236
.= C113 by L238 , L235 , L236;
end;
end;
begin
definition
let R16 being non  empty  with_zero set;
let C114 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C115 being non  halt-free ( NAT ) -defined (the InstructionsF of C114) -valued Function;
let C116 being (FinPartState of C114);
let C117 being Function;
pred C115 , C116 computes C117
means
:L241: (for B70 being set holds (B70 in ( dom C117 ) implies (ex B71 being (FinPartState of C114) st (B70 = B71 & ( C116 +* B71 ) is (Autonomy of C115) & ( C117 . B71 ) c= ( Result (C115 , ( C116 +* B71 )) )))))
;end;
theorem
L243: (for R16 being non  empty  with_zero set holds (for B72 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B73 being non  halt-free ( NAT ) -defined (the InstructionsF of B72) -valued Function holds (for B74 being (FinPartState of B72) holds B73 , B74 computes ( {} )))))
proof
let R16 being non  empty  with_zero set;
let C118 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C119 being non  halt-free ( NAT ) -defined (the InstructionsF of C118) -valued Function;
let C120 being (FinPartState of C118);
let C121 being set;
assume L244: C121 in ( dom ( {} ) );
reconsider D37 = C121 as (FinPartState of C118) by L244;
take D37;
thus L245: thesis by L244;
end;
theorem
L246: (for R16 being non  empty  with_zero set holds (for B75 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B76 being non  halt-free ( NAT ) -defined (the InstructionsF of B75) -valued Function holds (for B77 being (FinPartState of B75) holds (B77 is (Autonomy of B76) iff B76 , B77 computes ( ( {} ) .--> ( Result (B76 , B77) ) ))))))
proof
let R16 being non  empty  with_zero set;
let C122 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C123 being non  halt-free ( NAT ) -defined (the InstructionsF of C122) -valued Function;
let C124 being (FinPartState of C122);
thus L247: (C124 is (Autonomy of C123) implies C123 , C124 computes ( ( {} ) .--> ( Result (C123 , C124) ) ))
proof
L248: ( dom ( ( {} ) .--> ( Result (C123 , C124) ) ) ) = { ( {} ) } by FUNCOP_1:13;
assume L249: C124 is (Autonomy of C123);
let C125 being set;
assume L250: C125 in ( dom ( ( {} ) .--> ( Result (C123 , C124) ) ) );
L251: C125 = ( {} ) by L250 , L248 , TARSKI:def 1;
reconsider D38 = C125 as (FinPartState of C122) by L251 , FUNCT_1:104 , RELAT_1:171;
take D38;
thus L252: C125 = D38;
L253: ( C124 +* ( {} ) ) = C124;
thus L254: ( C124 +* D38 ) is (Autonomy of C123) by L253 , L249 , L250 , L248 , TARSKI:def 1;
L255: ( C124 +* D38 ) = C124 by L250 , L248 , TARSKI:def 1 , L253;
thus L256: thesis by L255 , FUNCOP_1:72 , L251;
end;

L257: ( dom ( ( {} ) .--> ( Result (C123 , C124) ) ) ) = { ( {} ) } by FUNCOP_1:13;
L258: ( {} ) in ( dom ( ( {} ) .--> ( Result (C123 , C124) ) ) ) by L257 , TARSKI:def 1;
L259: ( C124 +* ( {} ) ) = C124;
assume L260: C123 , C124 computes ( ( {} ) .--> ( Result (C123 , C124) ) );
L261: (ex B78 being (FinPartState of C122) st (( {} ) = B78 & ( C124 +* B78 ) is (Autonomy of C123) & ( ( ( {} ) .--> ( Result (C123 , C124) ) ) . B78 ) c= ( Result (C123 , ( C124 +* B78 )) ))) by L260 , L258 , L241;
thus L262: thesis by L261 , L259;
end;
theorem
L263: (for R16 being non  empty  with_zero set holds (for B79 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16 holds (for B80 being non  halt-free ( NAT ) -defined (the InstructionsF of B79) -valued Function holds (for B81 being (FinPartState of B79) holds (B81 is (Autonomy of B80) iff B80 , B81 computes ( ( {} ) .--> ( {} ) ))))))
proof
let R16 being non  empty  with_zero set;
let C126 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R16;
let C127 being non  halt-free ( NAT ) -defined (the InstructionsF of C126) -valued Function;
let C128 being (FinPartState of C126);
thus L264: (C128 is (Autonomy of C127) implies C127 , C128 computes ( ( {} ) .--> ( {} ) ))
proof
L265: ( dom ( ( {} ) .--> ( {} ) ) ) = { ( {} ) } by FUNCOP_1:13;
assume L266: C128 is (Autonomy of C127);
let C129 being set;
assume L267: C129 in ( dom ( ( {} ) .--> ( {} ) ) );
L268: C129 = ( {} ) by L267 , L265 , TARSKI:def 1;
reconsider D39 = C129 as (FinPartState of C126) by L268 , FUNCT_1:104 , RELAT_1:171;
take D39;
L269: ( C128 +* ( {} ) ) = C128;
thus L270: C129 = D39;
thus L271: ( C128 +* D39 ) is (Autonomy of C127) by L266 , L267 , L269 , L265 , TARSKI:def 1;
L272: ( ( ( {} ) .--> ( {} ) ) . D39 ) = ( {} ) by L268 , FUNCOP_1:72;
thus L273: thesis by L272 , XBOOLE_1:2;
end;

L274: ( dom ( ( {} ) .--> ( {} ) ) ) = { ( {} ) } by FUNCOP_1:13;
L275: ( {} ) in ( dom ( ( {} ) .--> ( {} ) ) ) by L274 , TARSKI:def 1;
L276: ( C128 +* ( {} ) ) = C128;
assume L277: C127 , C128 computes ( ( {} ) .--> ( {} ) );
L278: (ex B82 being (FinPartState of C126) st (( {} ) = B82 & ( C128 +* B82 ) is (Autonomy of C127) & ( ( ( {} ) .--> ( {} ) ) . B82 ) c= ( Result (C127 , ( C128 +* B82 )) ))) by L277 , L275 , L241;
thus L279: thesis by L278 , L276;
end;
begin
registration
let R16 being non  empty  with_zero set;
cluster  IC-Ins-separated for non  empty non  empty non  empty non  empty AMI-Struct over R16;
existence
proof
take ( Trivial-AMI R16 );
thus L280: thesis;
end;
end;
begin
theorem
L282: (for R20 being  with_zero non  empty set holds (for B83 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R20 holds (for B84 being ( NAT ) -defined (the InstructionsF of B83) -valued Function holds (for B85 being (State of B83) holds (B84 halts_on B85 iff (ex R11 being (Element of ( NAT )) st B84 halts_at ( IC ( Comput (B84 , B85 , R11) ) )))))))
proof
let R20 being  with_zero non  empty set;
let C130 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R20;
let C131 being ( NAT ) -defined (the InstructionsF of C130) -valued Function;
let C132 being (State of C130);
thus L283:now
assume L284: C131 halts_on C132;
consider C133 being Nat such that L285: ( IC ( Comput (C131 , C132 , C133) ) ) in ( dom C131 ) and L286: ( CurInstr (C131 , ( Comput (C131 , C132 , C133) )) ) = ( halt C130 ) by L284 , L76;
reconsider D40 = C133 as (Element of ( NAT )) by ORDINAL1:def 12;
take D41 = D40;
L287: ( C131 . ( IC ( Comput (C131 , C132 , D41) ) ) ) = ( halt C130 ) by L285 , L286 , PARTFUN1:def 6;
thus L288: C131 halts_at ( IC ( Comput (C131 , C132 , D41) ) ) by L287 , L285 , COMPOS_1:def 12;
end;
given C134 being (Element of ( NAT )) such that
L289: C131 halts_at ( IC ( Comput (C131 , C132 , C134) ) );

L290: ( IC ( Comput (C131 , C132 , C134) ) ) in ( dom C131 ) by L289 , COMPOS_1:def 12;
L291: ( C131 . ( IC ( Comput (C131 , C132 , C134) ) ) ) = ( halt C130 ) by L289 , COMPOS_1:def 12;
take C134;
thus L292: ( IC ( Comput (C131 , C132 , C134) ) ) in ( dom C131 ) by L289 , COMPOS_1:def 12;
thus L293: ( CurInstr (C131 , ( Comput (C131 , C132 , C134) )) ) = ( halt C130 ) by L290 , L291 , PARTFUN1:def 6;
end;
theorem
L294: (for R20 being  with_zero non  empty set holds (for B86 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20 holds (for B87 being ( NAT ) -defined (the InstructionsF of B86) -valued Function holds (for B88 being (State of B86) holds (for B89 being Nat holds (B87 halts_on B88 implies (( Result (B87 , B88) ) = ( Comput (B87 , B88 , B89) ) iff B87 halts_at ( IC ( Comput (B87 , B88 , B89) ) ))))))))
proof
let R20 being  with_zero non  empty set;
let C135 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let C136 being ( NAT ) -defined (the InstructionsF of C135) -valued Function;
let C137 being (State of C135);
let C138 being Nat;
assume L295: C136 halts_on C137;
consider C139 being Nat such that L296: ( IC ( Comput (C136 , C137 , C139) ) ) in ( dom C136 ) and L297: ( CurInstr (C136 , ( Comput (C136 , C137 , C139) )) ) = ( halt C135 ) by L295 , L76;
thus L298:now
assume L299: ( Result (C136 , C137) ) = ( Comput (C136 , C137 , C138) );
consider C140 being (Element of ( NAT )) such that L300: ( Result (C136 , C137) ) = ( Comput (C136 , C137 , C140) ) and L301: ( CurInstr (C136 , ( Result (C136 , C137) )) ) = ( halt C135 ) by L295 , L113;
reconsider D42 = C140 , D43 = C139 as (Element of ( NAT )) by ORDINAL1:def 12;
L302:
now
per cases ;
suppose L303: D42 <= D43;

thus L304: ( Comput (C136 , C137 , D42) ) = ( Comput (C136 , C137 , D43) ) by L303 , L300 , L301 , L100;
end;
suppose L305: D43 <= D42;

thus L306: ( Comput (C136 , C137 , D42) ) = ( Comput (C136 , C137 , D43) ) by L305 , L297 , L100;
end;
end;
L308: ( C136 . ( IC ( Comput (C136 , C137 , C138) ) ) ) = ( halt C135 ) by L302 , L301 , L299 , L296 , L300 , PARTFUN1:def 6;
thus L309: C136 halts_at ( IC ( Comput (C136 , C137 , C138) ) ) by L308 , L302 , L296 , L300 , L299 , COMPOS_1:def 12;
end;
assume that
L310: ( IC ( Comput (C136 , C137 , C138) ) ) in ( dom C136 )
and
L311: ( C136 . ( IC ( Comput (C136 , C137 , C138) ) ) ) = ( halt C135 );
L312: ( CurInstr (C136 , ( Comput (C136 , C137 , C138) )) ) = ( halt C135 ) by L310 , L311 , PARTFUN1:def 6;
reconsider D44 = C138 , D45 = C139 as (Element of ( NAT )) by ORDINAL1:def 12;
L313:
now
per cases ;
suppose L314: D45 <= D44;

thus L315: ( Comput (C136 , C137 , D44) ) = ( Comput (C136 , C137 , D45) ) by L314 , L297 , L100;
end;
suppose L316: D44 <= D45;

thus L317: ( Comput (C136 , C137 , D44) ) = ( Comput (C136 , C137 , D45) ) by L316 , L312 , L100;
end;
end;
thus L319: thesis by L313 , L297 , L113 , L295;
end;
theorem
L320: (for R20 being  with_zero non  empty set holds (for B90 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20 holds (for B91 being (the InstructionsF of B90) -valued ( NAT ) -defined Function holds (for B92 being (State of B90) holds (for R13 being (Element of ( NAT )) holds (B91 halts_at ( IC ( Comput (B91 , B92 , R13) ) ) implies ( Result (B91 , B92) ) = ( Comput (B91 , B92 , R13) )))))))
proof
let R20 being  with_zero non  empty set;
let C141 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let C142 being (the InstructionsF of C141) -valued ( NAT ) -defined Function;
let C143 being (State of C141);
let R13 being (Element of ( NAT ));
assume L321: C142 halts_at ( IC ( Comput (C142 , C143 , R13) ) );
L322: C142 halts_on C143 by L321 , L282;
thus L323: thesis by L322 , L321 , L294;
end;
theorem
L324: (for R11 being (Element of ( NAT )) holds (for R12 being (Element of ( NAT )) holds (for R20 being  with_zero non  empty set holds (R11 <= R12 implies (for B93 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20 holds (for B94 being (the InstructionsF of B93) -valued ( NAT ) -defined Function holds (for B95 being (State of B93) holds (B94 halts_at ( IC ( Comput (B94 , B95 , R11) ) ) implies B94 halts_at ( IC ( Comput (B94 , B95 , R12) ) )))))))))
proof
let R11 being (Element of ( NAT ));
let R12 being (Element of ( NAT ));
let R20 being  with_zero non  empty set;
assume L325: R11 <= R12;
let C144 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let C145 being ( NAT ) -defined (the InstructionsF of C144) -valued Function;
let C146 being (State of C144);
assume that
L326: ( IC ( Comput (C145 , C146 , R11) ) ) in ( dom C145 )
and
L327: ( C145 . ( IC ( Comput (C145 , C146 , R11) ) ) ) = ( halt C144 );
L328: ( CurInstr (C145 , ( Comput (C145 , C146 , R11) )) ) = ( halt C144 ) by L326 , L327 , PARTFUN1:def 6;
thus L329: ( IC ( Comput (C145 , C146 , R12) ) ) in ( dom C145 ) by L328 , L326 , L325 , L100;
thus L330: ( C145 . ( IC ( Comput (C145 , C146 , R12) ) ) ) = ( halt C144 ) by L325 , L327 , L328 , L100;
end;
theorem
L331: (for R11 being (Element of ( NAT )) holds (for R12 being (Element of ( NAT )) holds (for R20 being  with_zero non  empty set holds (R11 <= R12 implies (for B96 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20 holds (for B97 being (the InstructionsF of B96) -valued ( NAT ) -defined Function holds (for B98 being (State of B96) holds (B97 halts_at ( IC ( Comput (B97 , B98 , R11) ) ) implies ( Comput (B97 , B98 , R12) ) = ( Comput (B97 , B98 , R11) )))))))))
proof
let R11 being (Element of ( NAT ));
let R12 being (Element of ( NAT ));
let R20 being  with_zero non  empty set;
assume L332: R11 <= R12;
let C147 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let C148 being (the InstructionsF of C147) -valued ( NAT ) -defined Function;
let C149 being (State of C147);
assume L333: C148 halts_at ( IC ( Comput (C148 , C149 , R11) ) );
L334: C148 halts_at ( IC ( Comput (C148 , C149 , R12) ) ) by L333 , L332 , L324;
thus L335: ( Comput (C148 , C149 , R12) ) = ( Result (C148 , C149) ) by L334 , L320
.= ( Comput (C148 , C149 , R11) ) by L333 , L320;
end;
theorem
L336: (for R20 being  with_zero non  empty set holds (for B99 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R20 holds (for B100 being (Instruction-Sequence of B99) holds (for B101 being (State of B99) holds ((ex R13 being (Element of ( NAT )) st B100 halts_at ( IC ( Comput (B100 , B101 , R13) ) )) implies (for R11 being (Element of ( NAT )) holds ( Result (B100 , B101) ) = ( Result (B100 , ( Comput (B100 , B101 , R11) )) )))))))
proof
let R20 being  with_zero non  empty set;
let C150 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R20;
let C151 being (Instruction-Sequence of C150);
let C152 being (State of C150);
given R13 being (Element of ( NAT )) such that
L337: C151 halts_at ( IC ( Comput (C151 , C152 , R13) ) );

let R11 being (Element of ( NAT ));
L338: ( C151 . ( IC ( Comput (C151 , C152 , R13) ) ) ) = ( halt C150 ) by L337 , COMPOS_1:def 12;
thus L339: thesis by L338 , L132;
end;
definition
let R20 being  with_zero non  empty set;
let C153 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R20;
let C154 being ( NAT ) -defined (the InstructionsF of C153) -valued Function;
let C155 being (State of C153);
assume that
L340: C154 halts_on C155;
func LifeSpan (C154 , C155) -> (Element of ( NAT )) means 
:L341: (( CurInstr (C154 , ( Comput (C154 , C155 , it) )) ) = ( halt C153 ) & (for B102 being (Element of ( NAT )) holds (( CurInstr (C154 , ( Comput (C154 , C155 , B102) )) ) = ( halt C153 ) implies it <= B102)));
existence
proof
defpred S4[ Nat ] means ( CurInstr (C154 , ( Comput (C154 , C155 , $1) )) ) = ( halt C153 );
consider C156 being Nat such that L342: ( IC ( Comput (C154 , C155 , C156) ) ) in ( dom C154 ) and L343: ( CurInstr (C154 , ( Comput (C154 , C155 , C156) )) ) = ( halt C153 ) by L340 , L76;
L344: (ex B103 being Nat st S4[ B103 ]) by L343;
consider C157 being Nat such that L345: (S4[ C157 ] & (for B104 being Nat holds (S4[ B104 ] implies C157 <= B104))) from NAT_1:sch 5(L344);
reconsider D46 = C157 as (Element of ( NAT )) by ORDINAL1:def 12;
take D46;
thus L346: thesis by L345;
end;
uniqueness
proof
let C158 , C159 being (Element of ( NAT ));
assume L347: (not thesis);
L348: (C158 <= C159 & C159 <= C158) by L347;
thus L349: contradiction by L348 , L347 , XXREAL_0:1;
end;
end;
theorem
L351: (for B105 being non  empty  with_zero set holds (for B106 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over B105 holds (for B107 being ( NAT ) -defined (the InstructionsF of B106) -valued Function holds (for B108 being (State of B106) holds (for B109 being (Element of ( NAT )) holds (B107 halts_on B108 iff B107 halts_on ( Comput (B107 , B108 , B109) )))))))
proof
let R20 being  with_zero non  empty set;
let C160 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R20;
let C161 being ( NAT ) -defined (the InstructionsF of C160) -valued Function;
let C162 being (State of C160);
let C163 being (Element of ( NAT ));
thus L352:now
assume L353: C161 halts_on C162;
consider C164 being Nat such that L354: ( IC ( Comput (C161 , C162 , C164) ) ) in ( dom C161 ) and L355: ( CurInstr (C161 , ( Comput (C161 , C162 , C164) )) ) = ( halt C160 ) by L353 , L76;
reconsider D47 = C164 as (Element of ( NAT )) by ORDINAL1:def 12;
per cases ;
suppose L356: D47 <= C163;

L357: ( Comput (C161 , C162 , D47) ) = ( Comput (C161 , C162 , ( C163 + ( 0 ) )) ) by L356 , L355 , L100
.= ( Comput (C161 , ( Comput (C161 , C162 , C163) ) , ( 0 )) );
thus L358: C161 halts_on ( Comput (C161 , C162 , C163) ) by L357 , L76 , L355 , L354;
end;
suppose L359: D47 >= C163;

reconsider D48 = ( D47 - C163 ) as (Element of ( NAT )) by L359 , INT_1:5;
L360: ( Comput (C161 , ( Comput (C161 , C162 , C163) ) , D48) ) = ( Comput (C161 , C162 , ( C163 + D48 )) ) by L93
.= ( Comput (C161 , C162 , D47) );
thus L361: C161 halts_on ( Comput (C161 , C162 , C163) ) by L360 , L76 , L354 , L355;
end;
end;
given C165 being Nat such that
L363: ( IC ( Comput (C161 , ( Comput (C161 , C162 , C163) ) , C165) ) ) in ( dom C161 )
and
L364: ( CurInstr (C161 , ( Comput (C161 , ( Comput (C161 , C162 , C163) ) , C165) )) ) = ( halt C160 );

reconsider D49 = C165 as (Element of ( NAT )) by ORDINAL1:def 12;
take ( C163 + D49 );
thus L365: (( IC ( Comput (C161 , C162 , ( C163 + D49 )) ) ) in ( dom C161 ) & ( CurInstr (C161 , ( Comput (C161 , C162 , ( C163 + D49 )) )) ) = ( halt C160 )) by L363 , L364 , L93;
end;
theorem
L366: (for R21 being  with_zero non  empty set holds (for B110 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21 holds (for B111 being ( NAT ) -defined (the InstructionsF of B110) -valued Function holds (for B112 being (State of B110) holds (B111 halts_on B112 implies ( Result (B111 , B112) ) = ( Comput (B111 , B112 , ( LifeSpan (B111 , B112) )) ))))))
proof
let R21 being  with_zero non  empty set;
let C166 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let C167 being ( NAT ) -defined (the InstructionsF of C166) -valued Function;
let C168 being (State of C166);
assume L367: C167 halts_on C168;
L368: ( CurInstr (C167 , ( Comput (C167 , C168 , ( LifeSpan (C167 , C168) )) )) ) = ( halt C166 ) by L367 , L341;
consider R23 being (Element of ( NAT )) such that L369: ( Result (C167 , C168) ) = ( Comput (C167 , C168 , R23) ) and L370: ( CurInstr (C167 , ( Result (C167 , C168) )) ) = ( halt C166 ) by L367 , L113;
L371: ( LifeSpan (C167 , C168) ) <= R23 by L367 , L369 , L370 , L341;
thus L372: thesis by L371 , L368 , L369 , L100;
end;
theorem
L373: (for B113 being non  empty  with_zero set holds (for B114 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B113 holds (for B115 being (Instruction-Sequence of B114) holds (for B116 being (State of B114) holds (for B117 being (Element of ( NAT )) holds (( CurInstr (B115 , ( Comput (B115 , B116 , B117) )) ) = ( halt B114 ) implies ( Comput (B115 , B116 , ( LifeSpan (B115 , B116) )) ) = ( Comput (B115 , B116 , B117) )))))))
proof
let R21 being  with_zero non  empty set;
let C169 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let C170 being (Instruction-Sequence of C169);
let C171 being (State of C169);
let C172 being (Element of ( NAT ));
assume that
L374: ( CurInstr (C170 , ( Comput (C170 , C171 , C172) )) ) = ( halt C169 );
L375: ( dom C170 ) = ( NAT ) by PARTFUN1:def 2;
L376: C170 halts_on C171 by L76 , L375 , L374;
set D50 = ( LifeSpan (C170 , C171) );
L377: ( CurInstr (C170 , ( Comput (C170 , C171 , D50) )) ) = ( halt C169 ) by L376 , L341;
L378: D50 <= C172 by L374 , L376 , L341;
thus L379: thesis by L378 , L377 , L100;
end;
theorem
L380: (for R12 being (Element of ( NAT )) holds (for B118 being non  empty  with_zero set holds (for B119 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B118 holds (for B120 being ( NAT ) -defined (the InstructionsF of B119) -valued Function holds (for B121 being (State of B119) holds ((( LifeSpan (B120 , B121) ) <= R12 & B120 halts_on B121) implies ( Comput (B120 , B121 , R12) ) = ( Comput (B120 , B121 , ( LifeSpan (B120 , B121) )) )))))))
proof
let R12 being (Element of ( NAT ));
let R21 being  with_zero non  empty set;
let C173 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let C174 being ( NAT ) -defined (the InstructionsF of C173) -valued Function;
let C175 being (State of C173);
assume that
L381: ( LifeSpan (C174 , C175) ) <= R12
and
L382: C174 halts_on C175;
L383: ( CurInstr (C174 , ( Comput (C174 , C175 , ( LifeSpan (C174 , C175) )) )) ) = ( halt C173 ) by L382 , L341;
thus L384: thesis by L383 , L381 , L100;
end;
theorem
L385: (for B122 being  with_zero non  empty set holds (for B123 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B122 holds (for B124 being Nat holds (for B125 being (Instruction of B123) holds (for B126 being B124 -started (State of B123) holds (for B127 being (Instruction-Sequence of B123) holds (( B124 .--> B125 ) c= B127 implies ( Following (B127 , B126) ) = ( Exec (B125 , B126) ))))))))
proof
let R21 being  with_zero non  empty set;
let C176 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let C177 being Nat;
let C178 being (Instruction of C176);
let C179 being C177 -started (State of C176);
let C180 being (Instruction-Sequence of C176);
assume that
L386: ( C177 .--> C178 ) c= C180;
L387: ( dom ( C177 .--> C178 ) ) = { C177 } by FUNCOP_1:13;
L388: C177 in ( dom ( C177 .--> C178 ) ) by L387 , TARSKI:def 1;
L389: ( IC C179 ) = C177 by MEMSTR_0:def 11;
L390: ( CurInstr (C180 , C179) ) = ( C180 . C177 ) by L389 , PBOOLE:143
.= ( ( C177 .--> C178 ) . C177 ) by L386 , L388 , GRFUNC_1:2
.= C178 by FUNCOP_1:72;
thus L391: thesis by L390;
end;
theorem
L392: (for R21 being  with_zero non  empty set holds (for B128 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21 holds (for B129 being (Instruction-Sequence of B128) holds (for B130 being (State of B128) holds (B130 = ( Following (B129 , B130) ) implies (for R24 being (Element of ( NAT )) holds ( Comput (B129 , B130 , R24) ) = B130))))))
proof
let R21 being  with_zero non  empty set;
let C181 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let C182 being (Instruction-Sequence of C181);
let C183 being (State of C181);
defpred S5[ (Element of ( NAT )) ] means ( Comput (C182 , C183 , $1) ) = C183;
assume L393: C183 = ( Following (C182 , C183) );
L394: (for R24 being (Element of ( NAT )) holds (S5[ R24 ] implies S5[ ( R24 + 1 ) ])) by L393 , L82;
L395: S5[ ( 0 ) ];
thus L396: (for R24 being (Element of ( NAT )) holds S5[ R24 ]) from NAT_1:sch 1(L395 , L394);
end;
theorem
L397: (for B131 being  with_zero non  empty set holds (for B132 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over B131 holds (for B133 being (Instruction-Sequence of B132) holds (for B134 being (State of B132) holds (for B135 being (Instruction of B132) holds ( ( Exec (( B133 . ( IC B134 ) ) , B134) ) . ( IC B132 ) ) = ( IC ( Following (B133 , B134) ) ))))))
proof
let R21 being  with_zero non  empty set;
let C184 being  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let C185 being (Instruction-Sequence of C184);
let C186 being (State of C184);
let C187 being (Instruction of C184);
L398: ( NAT ) = ( dom C185 ) by PARTFUN1:def 2;
thus L399: ( ( Exec (( C185 . ( IC C186 ) ) , C186) ) . ( IC C184 ) ) = ( IC ( Following (C185 , C186) ) ) by L398 , PARTFUN1:def 6;
end;
theorem
L400: (for R21 being  with_zero non  empty set holds (for B136 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B137 being (Instruction-Sequence of B136) holds (for B138 being (State of B136) holds (B137 halts_on B138 iff (ex R13 being (Element of ( NAT )) st ( CurInstr (B137 , ( Comput (B137 , B138 , R13) )) ) = ( halt B136 )))))))
proof
let R21 being  with_zero non  empty set;
let C188 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C189 being (Instruction-Sequence of C188);
let C190 being (State of C188);
thus L401: (C189 halts_on C190 implies (ex R13 being (Element of ( NAT )) st ( CurInstr (C189 , ( Comput (C189 , C190 , R13) )) ) = ( halt C188 )))
proof
given C191 being Nat such that
L402: ( IC ( Comput (C189 , C190 , C191) ) ) in ( dom C189 )
and
L403: ( CurInstr (C189 , ( Comput (C189 , C190 , C191) )) ) = ( halt C188 );

reconsider D51 = C191 as (Element of ( NAT )) by ORDINAL1:def 12;
take D51;
thus L404: ( CurInstr (C189 , ( Comput (C189 , C190 , D51) )) ) = ( halt C188 ) by L403;
end;

given R13 being (Element of ( NAT )) such that
L405: ( CurInstr (C189 , ( Comput (C189 , C190 , R13) )) ) = ( halt C188 );

take R13;
L406: ( IC ( Comput (C189 , C190 , R13) ) ) in ( NAT );
thus L407: ( IC ( Comput (C189 , C190 , R13) ) ) in ( dom C189 ) by L406 , PARTFUN1:def 2;
thus L408: ( CurInstr (C189 , ( Comput (C189 , C190 , R13) )) ) = ( halt C188 ) by L405;
end;
theorem
L409: (for R21 being  with_zero non  empty set holds (for R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B139 being (Instruction-Sequence of R25) holds (for B140 being (State of R25) holds ((ex B141 being (Element of ( NAT )) st ( B139 . ( IC ( Comput (B139 , B140 , B141) ) ) ) = ( halt R25 )) implies B139 halts_on B140)))))
proof
let R21 being  with_zero non  empty set;
let R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C192 being (Instruction-Sequence of R25);
let C193 being (State of R25);
given C194 being (Element of ( NAT )) such that
L410: ( C192 . ( IC ( Comput (C192 , C193 , C194) ) ) ) = ( halt R25 );

take C194;
L411: ( dom C192 ) = ( NAT ) by PARTFUN1:def 2;
thus L412: ( IC ( Comput (C192 , C193 , C194) ) ) in ( dom C192 ) by L411;
thus L413: ( CurInstr (C192 , ( Comput (C192 , C193 , C194) )) ) = ( halt R25 ) by L410 , L411 , PARTFUN1:def 6;
end;
theorem
L414: (for R21 being  with_zero non  empty set holds (for R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B142 being (Instruction-Sequence of R25) holds (for B143 being (State of R25) holds (for B144 being (Element of ( NAT )) holds (( B142 . ( IC ( Comput (B142 , B143 , B144) ) ) ) = ( halt R25 ) implies ( Result (B142 , B143) ) = ( Comput (B142 , B143 , B144) )))))))
proof
let R21 being  with_zero non  empty set;
let R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C195 being (Instruction-Sequence of R25);
let C196 being (State of R25);
let C197 being (Element of ( NAT ));
assume L415: ( C195 . ( IC ( Comput (C195 , C196 , C197) ) ) ) = ( halt R25 );
L416: C195 halts_on C196 by L415 , L409;
L417: ( dom C195 ) = ( NAT ) by PARTFUN1:def 2;
L418: ( CurInstr (C195 , ( Comput (C195 , C196 , C197) )) ) = ( halt R25 ) by L417 , L415 , PARTFUN1:def 6;
thus L419: thesis by L418 , L416 , L113;
end;
theorem
L420: (for R21 being  with_zero non  empty set holds (for R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B145 being (Instruction-Sequence of R25) holds (for B146 being (State of R25) holds (for B147 being (Element of ( NAT )) holds ((( B145 . ( IC ( Comput (B145 , B146 , B147) ) ) ) <> ( halt R25 ) & ( B145 . ( IC ( Comput (B145 , B146 , ( B147 + 1 )) ) ) ) = ( halt R25 )) iff (( LifeSpan (B145 , B146) ) = ( B147 + 1 ) & B145 halts_on B146)))))))
proof
let R21 being  with_zero non  empty set;
let R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C198 being (Instruction-Sequence of R25);
let C199 being (State of R25);
let C200 being (Element of ( NAT ));
L421: ( dom C198 ) = ( NAT ) by PARTFUN1:def 2;
thus L422:now
assume that
L423: ( C198 . ( IC ( Comput (C198 , C199 , C200) ) ) ) <> ( halt R25 )
and
L424: ( C198 . ( IC ( Comput (C198 , C199 , ( C200 + 1 )) ) ) ) = ( halt R25 );
L425: ( CurInstr (C198 , ( Comput (C198 , C199 , C200) )) ) <> ( halt R25 ) by L423 , L421 , PARTFUN1:def 6;
L426:
now
let C201 being (Element of ( NAT ));
assume that
L427: ( CurInstr (C198 , ( Comput (C198 , C199 , C201) )) ) = ( halt R25 )
and
L428: ( C200 + 1 ) > C201;
L429: C201 <= C200 by L428 , NAT_1:13;
thus L430: contradiction by L429 , L425 , L427 , L100;
end;
L431: C198 halts_on C199 by L424 , L409;
L432: ( CurInstr (C198 , ( Comput (C198 , C199 , ( C200 + 1 )) )) ) = ( halt R25 ) by L424 , L421 , PARTFUN1:def 6;
thus L433: (( LifeSpan (C198 , C199) ) = ( C200 + 1 ) & C198 halts_on C199) by L432 , L426 , L341 , L431;
end;
assume L434: (( LifeSpan (C198 , C199) ) = ( C200 + 1 ) & C198 halts_on C199);
L435:
now
assume L436: ( CurInstr (C198 , ( Comput (C198 , C199 , C200) )) ) = ( halt R25 );
L437: ( C200 + 1 ) <= C200 by L436 , L434 , L341;
thus L438: contradiction by L437 , NAT_1:13;
end;
L439: ( CurInstr (C198 , ( Comput (C198 , C199 , ( C200 + 1 )) )) ) = ( halt R25 ) by L434 , L341;
thus L440: thesis by L439 , L435 , L421 , PARTFUN1:def 6;
end;
theorem
L441: (for R21 being  with_zero non  empty set holds (for R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B148 being (Instruction-Sequence of R25) holds (for B149 being (State of R25) holds (for B150 being (Element of ( NAT )) holds ((( IC ( Comput (B148 , B149 , B150) ) ) <> ( IC ( Comput (B148 , B149 , ( B150 + 1 )) ) ) & ( B148 . ( IC ( Comput (B148 , B149 , ( B150 + 1 )) ) ) ) = ( halt R25 )) implies ( LifeSpan (B148 , B149) ) = ( B150 + 1 )))))))
proof
let R21 being  with_zero non  empty set;
let R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C202 being (Instruction-Sequence of R25);
let C203 being (State of R25);
let C204 being (Element of ( NAT ));
assume that
L442: ( IC ( Comput (C202 , C203 , C204) ) ) <> ( IC ( Comput (C202 , C203 , ( C204 + 1 )) ) )
and
L443: ( C202 . ( IC ( Comput (C202 , C203 , ( C204 + 1 )) ) ) ) = ( halt R25 );
L444: ( dom C202 ) = ( NAT ) by PARTFUN1:def 2;
L445:
now
assume L446: ( C202 . ( IC ( Comput (C202 , C203 , C204) ) ) ) = ( halt R25 );
L447: ( CurInstr (C202 , ( Comput (C202 , C203 , C204) )) ) = ( halt R25 ) by L446 , L444 , PARTFUN1:def 6;
thus L448: contradiction by L447 , L442 , L100 , NAT_1:11;
end;
thus L449: thesis by L445 , L443 , L420;
end;
theorem
L450: (for R21 being  with_zero non  empty set holds (for R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B151 being (Instruction-Sequence of R25) holds (for B152 being (State of R25) holds (for B153 being (Element of ( NAT )) holds ((B151 halts_on ( Comput (B151 , B152 , B153) ) & ( 0 ) < ( LifeSpan (B151 , ( Comput (B151 , B152 , B153) )) )) implies ( LifeSpan (B151 , B152) ) = ( B153 + ( LifeSpan (B151 , ( Comput (B151 , B152 , B153) )) ) )))))))
proof
let R21 being  with_zero non  empty set;
let R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C205 being (Instruction-Sequence of R25);
let C206 being (State of R25);
let C207 being (Element of ( NAT ));
set D52 = ( Comput (C205 , C206 , C207) );
set D53 = ( LifeSpan (C205 , ( Comput (C205 , C206 , C207) )) );
assume that
L451: C205 halts_on D52
and
L452: ( 0 ) < D53;
consider C208 being Nat such that L453: D53 = ( C208 + 1 ) by L452 , NAT_1:6;
reconsider D54 = C208 as (Element of ( NAT )) by ORDINAL1:def 12;
L454: ( C205 . ( IC ( Comput (C205 , D52 , ( D54 + 1 )) ) ) ) = ( halt R25 ) by L451 , L453 , L420;
L455: ( C205 . ( IC ( Comput (C205 , C206 , ( C207 + ( D54 + 1 ) )) ) ) ) = ( halt R25 ) by L454 , L93;
L456: ( C205 . ( IC ( Comput (C205 , D52 , D54) ) ) ) <> ( halt R25 ) by L451 , L453 , L420;
L457: ( C205 . ( IC ( Comput (C205 , C206 , ( C207 + D54 )) ) ) ) <> ( halt R25 ) by L456 , L93;
thus L458: ( LifeSpan (C205 , C206) ) = ( ( C207 + D54 ) + 1 ) by L457 , L455 , L420
.= ( C207 + D53 ) by L453;
end;
theorem
L459: (for R21 being  with_zero non  empty set holds (for R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21 holds (for B154 being (Instruction-Sequence of R25) holds (for B155 being (State of R25) holds (for B156 being (Element of ( NAT )) holds (B154 halts_on ( Comput (B154 , B155 , B156) ) implies ( Result (B154 , ( Comput (B154 , B155 , B156) )) ) = ( Result (B154 , B155) )))))))
proof
let R21 being  with_zero non  empty set;
let R25 being  IC-Ins-separated  halting non  empty  with_non-empty_values AMI-Struct over R21;
let C209 being (Instruction-Sequence of R25);
let C210 being (State of R25);
let C211 being (Element of ( NAT ));
set D55 = ( Comput (C209 , C210 , C211) );
assume L460: C209 halts_on D55;
consider C212 being (Element of ( NAT )) such that L461: (( Result (C209 , D55) ) = ( Comput (C209 , D55 , C212) ) & ( CurInstr (C209 , ( Result (C209 , D55) )) ) = ( halt R25 )) by L460 , L113;
L462: C209 halts_on C210 by L460 , L351;
L463: ( Comput (C209 , ( Comput (C209 , C210 , C211) ) , C212) ) = ( Comput (C209 , C210 , ( C211 + C212 )) ) by L93;
thus L464: thesis by L463 , L462 , L461 , L113;
end;
theorem
L465: (for R21 being  with_zero non  empty set holds (for R26 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21 holds (for R27 being (Instruction-Sequence of R26) holds (for B157 being (State of R26) holds (R27 halts_on B157 implies (for B158 being (Element of ( NAT )) holds (( LifeSpan (R27 , B157) ) <= B158 implies ( CurInstr (R27 , ( Comput (R27 , B157 , B158) )) ) = ( halt R26 ))))))))
proof
let R21 being  with_zero non  empty set;
let R26 being  halting  IC-Ins-separated non  empty  with_non-empty_values AMI-Struct over R21;
let R27 being (Instruction-Sequence of R26);
let C213 being (State of R26);
assume L466: R27 halts_on C213;
L467: ( CurInstr (R27 , ( Comput (R27 , C213 , ( LifeSpan (R27 , C213) )) )) ) = ( halt R26 ) by L466 , L341;
let C214 being (Element of ( NAT ));
assume L468: ( LifeSpan (R27 , C213) ) <= C214;
thus L469: thesis by L468 , L467 , L100;
end;
