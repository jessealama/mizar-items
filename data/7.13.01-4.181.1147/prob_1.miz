:: $\sigma$-Fields and Probability
::  by Andrzej N\c{e}dzusiak
::
:: Received October 16, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, FUNCT_1, XREAL_0, ORDINAL1, SEQ_1,
      XXREAL_0, SEQ_2, ORDINAL2, CARD_1, ARYTM_3, COMPLEX1, ARYTM_1, SETFAM_1,
      FINSUB_1, ZFMISC_1, TARSKI, RELAT_1, CARD_3, EQREL_1, FUNCT_7, FUNCOP_1,
      NAT_1, RPR_1, REAL_1, VALUED_0, XXREAL_1, PROB_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, FINSUB_1, RELAT_1, FUNCT_1,
      REAL_1, FUNCT_2, FUNCOP_1, FUNCT_7, ORDINAL1, CARD_3, NUMBERS, VALUED_0,
      XREAL_0, COMPLEX1, NAT_1, SEQ_1, COMSEQ_2,
      SEQ_2, SETFAM_1, XXREAL_0, XXREAL_1;
 constructors SETFAM_1, FINSUB_1, XXREAL_1, COMPLEX1, REAL_1, SEQ_2, CARD_3,
      MEMBERED, SEQ_1, FUNCT_7, RELSET_1, COMSEQ_2;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, NUMBERS, XXREAL_0,
      XREAL_0, MEMBERED, XXREAL_1, RELAT_1, VALUED_0, RELSET_1, COMSEQ_2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FINSUB_1, TARSKI, SUBSET_1, MEMBERED, CARD_3, FUNCT_2, VALUED_0;
 theorems TARSKI, ZFMISC_1, FUNCT_1, FUNCT_2, ABSVALUE, SEQ_2, SETFAM_1,
      SUBSET_1, RELAT_1, RELSET_1, FINSUB_1, FUNCOP_1, XBOOLE_0, XBOOLE_1,
      XREAL_1, XXREAL_0, XXREAL_1, FUNCT_7, NAT_1, ORDINAL1;
 schemes FUNCT_2, PARTFUN1;

begin
theorem
L1: (for R14 being  real number holds (for R16 being Real_Sequence holds ((ex R13 being (Element of ( NAT )) st (for R12 being (Element of ( NAT )) holds (R13 <= R12 implies ( R16 . R12 ) = R14))) implies (R16 is  convergent & ( lim R16 ) = R14))))
proof
let R14 being  real number;
let R16 being Real_Sequence;
assume that
L2: (ex R13 being (Element of ( NAT )) st (for R12 being (Element of ( NAT )) holds (R13 <= R12 implies ( R16 . R12 ) = R14)));
L3: (for R15 being  real number holds (( 0 ) < R15 implies (ex R13 being (Element of ( NAT )) st (for R12 being (Element of ( NAT )) holds (R13 <= R12 implies ( abs ( ( R16 . R12 ) - R14 ) ) < R15)))))
proof
consider R13 being (Element of ( NAT )) such that L4: (for R12 being (Element of ( NAT )) holds (R13 <= R12 implies ( R16 . R12 ) = R14)) by L2;
let R15 being  real number;
assume that
L5: ( 0 ) < R15;
take R13;
let R12 being (Element of ( NAT ));
assume L6: R13 <= R12;
L7: ( R16 . R12 ) = R14 by L6 , L4;
thus L8: thesis by L7 , L5 , ABSVALUE:2;
end;
L9: R16 is  convergent by L3 , SEQ_2:def 6;
thus L10: thesis by L9 , L3 , SEQ_2:def 7;
end;
definition
let C1 being set;
let C2 being (Subset-Family of C1);
attr C2 is  compl-closed
means
:L11: (for B1 being (Subset of C1) holds (B1 in C2 implies ( B1 ` ) in C2));
end;
registration
let C3 being set;
cluster ( bool C3 ) ->  cap-closed;
coherence
proof
let C4 , C5 being set;
assume that
L13: C4 in ( bool C3 )
and
L14: C5 in ( bool C3 );
L15: ( C4 /\ C5 ) c= C3 by L13 , XBOOLE_1:108;
thus L16: thesis by L15;
end;
end;
registration
let C6 being set;
cluster ( bool C6 ) ->  compl-closed for (Subset-Family of C6);
coherence
proof
L18: ( bool C6 ) is  compl-closed
proof
let C7 being (Subset of C6);
thus L19: thesis;
end;
thus L20: thesis by L18;
end;
end;
registration
let C8 being set;
cluster non  empty  compl-closed  cap-closed for (Subset-Family of C8);
existence
proof
take ( bool C8 );
thus L22: thesis;
end;
end;
definition
let C9 being set;
mode Field_Subset of C9
 is non  empty  compl-closed  cap-closed (Subset-Family of C9);
end;
theorem
L25: (for R2 being set holds (for B2 , B3 being (Subset of R2) holds { B2 , B3 } is (Subset-Family of R2)))
proof
let R2 being set;
let C10 , C11 being (Subset of R2);
set D1 = { C10 , C11 };
L26: D1 c= ( bool R2 )
proof
let C12 being set;
assume L27: C12 in D1;
L28: (C12 = C10 or C12 = C11) by L27 , TARSKI:def 2;
thus L29: thesis by L28;
end;
thus L30: thesis by L26;
end;
theorem
L31: (for R2 being set holds (for R17 being (Field_Subset of R2) holds (for B4 , B5 being set holds ((B4 in R17 & B5 in R17) implies ( B4 \/ B5 ) in R17))))
proof
let R2 being set;
let R17 being (Field_Subset of R2);
let C13 , C14 being set;
assume L32: (C13 in R17 & C14 in R17);
reconsider D2 = C13 , D3 = C14 as (Subset of R2) by L32;
L33: (( D2 ` ) in R17 & ( D3 ` ) in R17) by L32 , L11;
L34: ( ( D2 ` ) /\ ( D3 ` ) ) in R17 by L33 , FINSUB_1:def 2;
L35: ( ( D2 \/ D3 ) ` ) in R17 by L34 , XBOOLE_1:53;
L36: ( ( ( D2 \/ D3 ) ` ) ` ) in R17 by L35 , L11;
thus L37: thesis by L36;
end;
theorem
L38: (for R2 being set holds (for R17 being (Field_Subset of R2) holds ( {} ) in R17))
proof
let R2 being set;
let R17 being (Field_Subset of R2);
consider C15 being (Subset of R2) such that L39: C15 in R17 by SUBSET_1:4;
L40: C15 misses ( C15 ` ) by XBOOLE_1:79;
L41: ( C15 /\ ( C15 ` ) ) = ( {} ) by L40 , XBOOLE_0:def 7;
L42: ( C15 ` ) in R17 by L39 , L11;
thus L43: thesis by L42 , L39 , L41 , FINSUB_1:def 2;
end;
theorem
L44: (for R2 being set holds (for R17 being (Field_Subset of R2) holds R2 in R17))
proof
let R2 being set;
let R17 being (Field_Subset of R2);
consider C16 being (Subset of R2) such that L45: C16 in R17 by SUBSET_1:4;
L46: ( C16 \/ ( C16 ` ) ) = ( [#] R2 ) by SUBSET_1:10
.= R2;
L47: ( C16 ` ) in R17 by L45 , L11;
thus L48: thesis by L47 , L45 , L46 , L31;
end;
theorem
L49: (for R2 being set holds (for R17 being (Field_Subset of R2) holds (for B6 , B7 being (Subset of R2) holds ((B6 in R17 & B7 in R17) implies ( B6 \ B7 ) in R17))))
proof
let R2 being set;
let R17 being (Field_Subset of R2);
let C17 , C18 being (Subset of R2);
assume L50: C17 in R17;
assume L51: C18 in R17;
L52: ( C18 ` ) in R17 by L51 , L11;
L53: ( C17 /\ ( C18 ` ) ) in R17 by L52 , L50 , FINSUB_1:def 2;
thus L54: thesis by L53 , SUBSET_1:13;
end;
theorem
L55: (for R2 being set holds (for R17 being (Field_Subset of R2) holds (for B8 , B9 being set holds ((B8 in R17 & B9 in R17) implies ( ( B8 \ B9 ) \/ B9 ) in R17))))
proof
let R2 being set;
let R17 being (Field_Subset of R2);
let C19 , C20 being set;
L56: ( C19 \/ C20 ) = ( ( C19 \ C20 ) \/ C20 ) by XBOOLE_1:39;
thus L57: thesis by L56 , L31;
end;
registration
let C21 being set;
cluster { ( {} ) , C21 } ->  cap-closed;
coherence
proof
let C22 , C23 being set;
L58: ((C22 = ( {} ) or C23 = ( {} )) implies ( C22 /\ C23 ) = ( {} ));
L59: ((C22 = C21 & C23 = C21) implies ( C22 /\ C23 ) = C21);
thus L60: thesis by L59 , L58 , TARSKI:def 2;
end;
end;
theorem
L62: (for R2 being set holds { ( {} ) , R2 } is (Field_Subset of R2))
proof
let R2 being set;
L63: (( {} ) c= R2 & R2 in ( bool R2 )) by XBOOLE_1:2 , ZFMISC_1:def 1;
reconsider D4 = { ( {} ) , R2 } as (Subset-Family of R2) by L63 , L25;
L64:
now
let C24 being (Subset of R2);
L65: (C24 = ( {} ) implies ( C24 ` ) = R2);
L66: (C24 = R2 implies ( C24 ` ) = ( {} R2 )) by XBOOLE_1:37;
thus L67: (C24 in D4 implies ( C24 ` ) in D4) by L66 , L65 , TARSKI:def 2;
end;
thus L68: thesis by L64 , L11;
end;
theorem
L69: (for R2 being set holds ( bool R2 ) is (Field_Subset of R2));
theorem
L70: (for R2 being set holds (for R17 being (Field_Subset of R2) holds ({ ( {} ) , R2 } c= R17 & R17 c= ( bool R2 ))))
proof
let R2 being set;
let R17 being (Field_Subset of R2);
L71: (( {} ) in R17 & R2 in R17) by L38 , L44;
L72: (for R6 being set holds (R6 in { ( {} ) , R2 } implies R6 in R17)) by L71 , TARSKI:def 2;
thus L73: thesis by L72 , TARSKI:def 3;
end;
definition
let C25 being set;
mode SetSequence of C25
 is (sequence of ( bool C25 ));
end;
theorem
L75: (for R2 being set holds (for R20 being (SetSequence of R2) holds ( union ( rng R20 ) ) is (Subset of R2)))
proof
let R2 being set;
let R20 being (SetSequence of R2);
L76: (for R3 being set holds (R3 in ( rng R20 ) implies R3 c= R2))
proof
let R3 being set;
assume L77: R3 in ( rng R20 );
consider R7 being set such that L78: R7 in ( dom R20 ) and L79: R3 = ( R20 . R7 ) by L77 , FUNCT_1:def 3;
reconsider D5 = R7 as (Element of ( NAT )) by L78 , FUNCT_2:def 1;
L80: R3 = ( R20 . D5 ) by L79;
thus L81: thesis by L80;
end;
thus L82: thesis by L76 , ZFMISC_1:76;
end;
definition
let C26 being set;
let C27 being (SetSequence of C26);
redefine func Union C27 -> (Subset of C26);

coherence by L75;
end;
theorem
L84: (for R2 being set holds (for R6 being set holds (for R20 being (SetSequence of R2) holds (R6 in ( Union R20 ) iff (ex R13 being (Element of ( NAT )) st R6 in ( R20 . R13 ))))))
proof
let R2 being set;
let R6 being set;
let R20 being (SetSequence of R2);
set D6 = ( union ( rng R20 ) );
L85: (for R6 being set holds (R6 in D6 iff (ex R13 being (Element of ( NAT )) st R6 in ( R20 . R13 ))))
proof
let R6 being set;
thus L86: (R6 in D6 implies (ex R13 being (Element of ( NAT )) st R6 in ( R20 . R13 )))
proof
assume L87: R6 in D6;
consider R3 being set such that L88: R6 in R3 and L89: R3 in ( rng R20 ) by L87 , TARSKI:def 4;
consider R5 being set such that L90: R5 in ( dom R20 ) and L91: R3 = ( R20 . R5 ) by L89 , FUNCT_1:def 3;
L92: R5 in ( NAT ) by L90 , FUNCT_2:def 1;
thus L93: thesis by L92 , L88 , L91;
end;

thus L94: ((ex R13 being (Element of ( NAT )) st R6 in ( R20 . R13 )) implies R6 in D6)
proof
given R13 being (Element of ( NAT )) such that
L95: R6 in ( R20 . R13 );

L96: R13 in ( NAT );
L97: R13 in ( dom R20 ) by L96 , FUNCT_2:def 1;
L98: ( R20 . R13 ) in ( rng R20 ) by L97 , FUNCT_1:def 3;
thus L99: thesis by L98 , L95 , TARSKI:def 4;
end;

end;
thus L95: thesis by L85;
end;
definition
let C28 being set;
let C29 being (SetSequence of C28);
func Complement C29 -> (SetSequence of C28) means 
:L96: (for R13 being (Element of ( NAT )) holds ( it . R13 ) = ( ( C29 . R13 ) ` ));
existence
proof
deffunc H1((Element of ( NAT ))) = ( ( C29 . $1 ) ` );
L97: (ex B10 being (Function of ( NAT ) , ( bool C28 )) st (for B11 being (Element of ( NAT )) holds ( B10 . B11 ) = H1(B11))) from FUNCT_2:sch 4;
consider C30 being (Function of ( NAT ) , ( bool C28 )) such that L98: (for B12 being (Element of ( NAT )) holds ( C30 . B12 ) = ( ( C29 . B12 ) ` )) by L97;
take C30;
thus L99: thesis by L98;
end;
uniqueness
proof
let C31 , C32 being (SetSequence of C28);
assume that
L100: (for R13 being (Element of ( NAT )) holds ( C31 . R13 ) = ( ( C29 . R13 ) ` ))
and
L101: (for R12 being (Element of ( NAT )) holds ( C32 . R12 ) = ( ( C29 . R12 ) ` ));
L102: (for R6 being set holds (R6 in ( NAT ) implies ( C31 . R6 ) = ( C32 . R6 )))
proof
let R6 being set;
assume L103: R6 in ( NAT );
reconsider D7 = R6 as (Element of ( NAT )) by L103;
L104: ( C31 . D7 ) = ( ( C29 . D7 ) ` ) by L100
.= ( C32 . D7 ) by L101;
thus L105: thesis by L104;
end;
L106: (( NAT ) = ( dom C31 ) & ( NAT ) = ( dom C32 )) by FUNCT_2:def 1;
thus L107: thesis by L106 , L102 , FUNCT_1:2;
end;
involutiveness
proof
let C33 , C34 being (SetSequence of C28);
assume L108: (for R13 being (Element of ( NAT )) holds ( C33 . R13 ) = ( ( C34 . R13 ) ` ));
let R13 being (Element of ( NAT ));
thus L109: ( C34 . R13 ) = ( ( ( C34 . R13 ) ` ) ` )
.= ( ( C33 . R13 ) ` ) by L108;
end;
end;
definition
let C35 being set;
let C36 being (SetSequence of C35);
func Intersection C36 -> (Subset of C35) equals 
( ( Union ( Complement C36 ) ) ` );
correctness;
end;
theorem
L112: (for R2 being set holds (for R6 being set holds (for R20 being (SetSequence of R2) holds (R6 in ( Intersection R20 ) iff (for R13 being (Element of ( NAT )) holds R6 in ( R20 . R13 ))))))
proof
let R2 being set;
let R6 being set;
let R20 being (SetSequence of R2);
L113: (for R13 being (Element of ( NAT )) holds ( R2 \ ( ( Complement R20 ) . R13 ) ) = ( R20 . R13 ))
proof
let R13 being (Element of ( NAT ));
L114: ( R2 \ ( ( Complement R20 ) . R13 ) ) = ( ( ( R20 . R13 ) ` ) ` ) by L96
.= ( R20 . R13 );
thus L115: thesis by L114;
end;
L116: ((for R13 being (Element of ( NAT )) holds (R6 in R2 & (not R6 in ( ( Complement R20 ) . R13 )))) iff (for R13 being (Element of ( NAT )) holds R6 in ( R20 . R13 )))
proof
thus L117: ((for R13 being (Element of ( NAT )) holds (R6 in R2 & (not R6 in ( ( Complement R20 ) . R13 )))) implies (for R13 being (Element of ( NAT )) holds R6 in ( R20 . R13 )))
proof
assume L118: (for R13 being (Element of ( NAT )) holds (R6 in R2 & (not R6 in ( ( Complement R20 ) . R13 ))));
let R13 being (Element of ( NAT ));
L119: (not R6 in ( ( Complement R20 ) . R13 )) by L118;
L120: R6 in ( R2 \ ( ( Complement R20 ) . R13 ) ) by L119 , L118 , XBOOLE_0:def 5;
thus L121: thesis by L120 , L113;
end;

assume L122: (for R13 being (Element of ( NAT )) holds R6 in ( R20 . R13 ));
let R13 being (Element of ( NAT ));
L123: R6 in ( R20 . R13 ) by L122;
L124: R6 in ( R2 \ ( ( Complement R20 ) . R13 ) ) by L123 , L113;
thus L125: thesis by L124 , XBOOLE_0:def 5;
end;
L126: ((R6 in R2 & (not R6 in ( Union ( Complement R20 ) ))) iff (R6 in R2 & (for R13 being (Element of ( NAT )) holds (not R6 in ( ( Complement R20 ) . R13 ))))) by L84;
thus L127: thesis by L126 , L116 , XBOOLE_0:def 5;
end;
L128: (for R2 being set holds (for B13 , B14 being (Subset of R2) holds ( Complement ( B13 followed_by B14 ) ) = ( ( B13 ` ) followed_by ( B14 ` ) )))
proof
let R2 being set;
let C37 , C38 being (Subset of R2);
let C39 being (Element of ( NAT ));
per cases  by NAT_1:3;
suppose L129: C39 = ( 0 );

thus L130: ( ( Complement ( C37 followed_by C38 ) ) . C39 ) = ( ( ( C37 followed_by C38 ) . C39 ) ` ) by L96
.= ( C37 ` ) by L129 , FUNCT_7:119
.= ( ( ( C37 ` ) followed_by ( C38 ` ) ) . C39 ) by L129 , FUNCT_7:119;
end;
suppose L131: C39 > ( 0 );

thus L132: ( ( Complement ( C37 followed_by C38 ) ) . C39 ) = ( ( ( C37 followed_by C38 ) . C39 ) ` ) by L96
.= ( C38 ` ) by L131 , FUNCT_7:120
.= ( ( ( C37 ` ) followed_by ( C38 ` ) ) . C39 ) by L131 , FUNCT_7:120;
end;
end;
theorem
L134: (for R2 being set holds (for B15 , B16 being (Subset of R2) holds ( Intersection ( B15 followed_by B16 ) ) = ( B15 /\ B16 )))
proof
let R2 being set;
let C40 , C41 being (Subset of R2);
set D8 = ( C40 followed_by C41 );
L135: ( Complement D8 ) = ( ( C40 ` ) followed_by ( C41 ` ) ) by L128;
L136: ( rng ( Complement D8 ) ) = { ( C40 ` ) , ( C41 ` ) } by L135 , FUNCT_7:126;
L137: ( Union ( Complement D8 ) ) = ( ( C40 ` ) \/ ( C41 ` ) ) by L136 , ZFMISC_1:75;
L138: ( ( Union ( Complement D8 ) ) ` ) = ( ( ( C40 ` ) ` ) /\ ( ( C41 ` ) ` ) ) by L137 , XBOOLE_1:53;
thus L139: thesis by L138;
end;
definition
let C42 being Function;
attr C42 is  non-ascending
means
:L140: (for R13 being (Element of ( NAT )) holds (for R12 being (Element of ( NAT )) holds (R13 <= R12 implies ( C42 . R12 ) c= ( C42 . R13 ))));
attr C42 is  non-descending
means
(for R13 being (Element of ( NAT )) holds (for R12 being (Element of ( NAT )) holds (R13 <= R12 implies ( C42 . R13 ) c= ( C42 . R12 ))));
end;
definition
let C43 being set;
let C44 being (Subset-Family of C43);
attr C44 is  sigma-multiplicative
means
:L142: (for B17 being (SetSequence of C43) holds (( rng B17 ) c= C44 implies ( Intersection B17 ) in C44));
end;
registration
let C45 being set;
cluster ( bool C45 ) ->  sigma-multiplicative for (Subset-Family of C45);
coherence
proof
L144: (for B18 being (SetSequence of C45) holds (( rng B18 ) c= ( bool C45 ) implies ( Intersection B18 ) in ( bool C45 )));
thus L145: thesis by L144 , L142;
end;
end;
registration
let C46 being set;
cluster  compl-closed  sigma-multiplicative non  empty for (Subset-Family of C46);
existence
proof
take ( bool C46 );
thus L147: thesis;
end;
end;
definition
let C47 being set;
mode SigmaField of C47
 is  compl-closed  sigma-multiplicative non  empty (Subset-Family of C47);
end;
theorem
L150: (for R2 being set holds (for B19 being non  empty set holds (B19 is (SigmaField of R2) iff (B19 c= ( bool R2 ) & (for B20 being (SetSequence of R2) holds (( rng B20 ) c= B19 implies ( Intersection B20 ) in B19)) & (for B21 being (Subset of R2) holds (B21 in B19 implies ( B21 ` ) in B19)))))) by L11 , L142;
theorem
L151: (for R2 being set holds (for R3 being set holds (R3 is (SigmaField of R2) implies R3 is (Field_Subset of R2))))
proof
let R2 being set;
let R3 being set;
assume L152: R3 is (SigmaField of R2);
L153: R3 is  cap-closed
proof
let C48 , C49 being set;
assume L154: (C48 in R3 & C49 in R3);
reconsider D9 = C48 , D10 = C49 as (Subset of R2) by L154 , L152;
set D11 = ( D9 followed_by D10 );
L155: ( rng D11 ) = { D9 , D10 } by FUNCT_7:126;
L156: ( rng D11 ) c= R3 by L155 , L154 , ZFMISC_1:32;
L157: ( Intersection D11 ) = ( C48 /\ C49 ) by L134;
thus L158: thesis by L157 , L152 , L156 , L142;
end;
thus L159: thesis by L153 , L152;
end;
registration
let C50 being set;
cluster  ->  cap-closed  compl-closed for (SigmaField of C50);
coherence by L151;
end;
registration
let C51 being set;
let C52 being non  empty (Subset-Family of C51);
cluster C52 -valued for (SetSequence of C51);
existence
proof
set D12 = ( ( NAT ) --> the (Element of C52) );
reconsider D13 = D12 as (SetSequence of C51) by FUNCOP_1:45;
take D13;
thus L161: thesis;
end;
end;
definition
let C53 being set;
let C54 being non  empty (Subset-Family of C53);
mode SetSequence of C54
 is C54 -valued (SetSequence of C53);
end;
theorem
L164: (for R2 being set holds (for R22 being (SigmaField of R2) holds (for B22 being (SetSequence of R22) holds ( Union B22 ) in R22)))
proof
let R2 being set;
let R22 being (SigmaField of R2);
let C55 being (SetSequence of R22);
L165: (for R20 being (SetSequence of R2) holds (( rng R20 ) c= R22 implies (for B23 being Nat holds ( ( Complement R20 ) . B23 ) in R22)))
proof
let R20 being (SetSequence of R2);
assume L166: ( rng R20 ) c= R22;
let C56 being Nat;
L167: ( R20 . C56 ) in ( rng R20 ) by NAT_1:51;
L168: (C56 in ( NAT ) & ( ( R20 . C56 ) ` ) in R22) by L167 , L166 , L11 , ORDINAL1:def 12;
thus L169: thesis by L168 , L96;
end;
L170: (for R20 being (SetSequence of R2) holds (( rng R20 ) c= R22 implies ( Union ( Complement ( Complement R20 ) ) ) in R22))
proof
let R20 being (SetSequence of R2);
assume L171: ( rng R20 ) c= R22;
L172: (for B24 being Nat holds ( ( Complement R20 ) . B24 ) in R22) by L171 , L165;
L173: ( rng ( Complement R20 ) ) c= R22 by L172 , NAT_1:52;
L174: ( Intersection ( Complement R20 ) ) in R22 by L173 , L142;
L175: ( ( ( Union ( Complement ( Complement R20 ) ) ) ` ) ` ) in R22 by L174 , L11;
thus L176: thesis by L175;
end;
L177: (for R20 being (SetSequence of R2) holds (( rng R20 ) c= R22 implies ( Union R20 ) in R22))
proof
let R20 being (SetSequence of R2);
assume L178: ( rng R20 ) c= R22;
L179: ( Union ( Complement ( Complement R20 ) ) ) in R22 by L178 , L170;
thus L180: thesis by L179;
end;
L181: ( rng C55 ) c= R22 by RELAT_1:def 19;
thus L182: thesis by L181 , L177;
end;
notation
let C57 being set;
let C58 being (SigmaField of C57);
synonym Event of C58 for Element of C58;
end;
definition
let C59 being set;
let C60 being (SigmaField of C59);
redefine mode Event of C60
 -> (Subset of C59);
coherence
proof
let C61 being (Event of C60);
L184: C61 in C60;
thus L185: thesis by L184;
end;
end;
theorem
L187: (for R2 being set holds (for R6 being set holds (for R22 being (SigmaField of R2) holds (R6 in R22 implies R6 is (Event of R22)))));
theorem
L188: (for R2 being set holds (for R22 being (SigmaField of R2) holds (for B25 , B26 being (Event of R22) holds ( B25 /\ B26 ) is (Event of R22)))) by FINSUB_1:def 2;
theorem
L189: (for R2 being set holds (for R22 being (SigmaField of R2) holds (for B27 being (Event of R22) holds ( B27 ` ) is (Event of R22)))) by L11;
theorem
L190: (for R2 being set holds (for R22 being (SigmaField of R2) holds (for B28 , B29 being (Event of R22) holds ( B28 \/ B29 ) is (Event of R22)))) by L31;
theorem
L191: (for R2 being set holds (for R22 being (SigmaField of R2) holds ( {} ) is (Event of R22))) by L38;
theorem
L192: (for R2 being set holds (for R22 being (SigmaField of R2) holds R2 is (Event of R22))) by L44;
theorem
L193: (for R2 being set holds (for R22 being (SigmaField of R2) holds (for B30 , B31 being (Event of R22) holds ( B30 \ B31 ) is (Event of R22)))) by L49;
registration
let R2 being set;
let R22 being (SigmaField of R2);
cluster  empty for (Event of R22);
existence
proof
L194: ( {} ) is (Event of R22) by L38;
thus L195: thesis by L194;
end;
end;
definition
let R2 being set;
let R22 being (SigmaField of R2);
func [#] R22 -> (Event of R22) equals 
R2;
coherence by L44;
end;
definition
let R2 being set;
let R22 being (SigmaField of R2);
let C62 , C63 being (Event of R22);
redefine func C62 /\ C63 -> (Event of R22);

coherence by FINSUB_1:def 2;
redefine func C62 \/ C63 -> (Event of R22);

coherence by L31;
redefine func C62 \ C63 -> (Event of R22);

coherence by L49;
end;
theorem
L199: (for R2 being set holds (for R20 being (SetSequence of R2) holds (for R22 being (SigmaField of R2) holds (R20 is (SetSequence of R22) iff (for R13 being (Element of ( NAT )) holds ( R20 . R13 ) is (Event of R22))))))
proof
let R2 being set;
let R20 being (SetSequence of R2);
let R22 being (SigmaField of R2);
thus L200: (R20 is (SetSequence of R22) implies (for R13 being (Element of ( NAT )) holds ( R20 . R13 ) is (Event of R22)))
proof
assume L201: R20 is (SetSequence of R22);
L202: ( rng R20 ) c= R22 by L201 , RELAT_1:def 19;
L203: (for R13 being (Element of ( NAT )) holds ( R20 . R13 ) is (Event of R22))
proof
let R13 being (Element of ( NAT ));
L204: ( R20 . R13 ) in ( rng R20 ) by NAT_1:51;
thus L205: thesis by L204 , L202;
end;
thus L206: thesis by L203;
end;

assume L207: (for R13 being (Element of ( NAT )) holds ( R20 . R13 ) is (Event of R22));
L208: (for B32 being Nat holds ( R20 . B32 ) in R22)
proof
let C64 being Nat;
L209: C64 in ( NAT ) by ORDINAL1:def 12;
L210: ( R20 . C64 ) is (Event of R22) by L209 , L207;
thus L211: thesis by L210;
end;
L212: ( rng R20 ) c= R22 by L208 , NAT_1:52;
thus L213: thesis by L212 , RELAT_1:def 19;
end;
theorem
L214: (for R1 being set holds (for R18 being (SetSequence of R1) holds (for R21 being (SigmaField of R1) holds (R18 is (SetSequence of R21) implies ( Union R18 ) is (Event of R21))))) by L164;
theorem
L215: (for R1 being set holds (for R5 being set holds (for R21 being (SigmaField of R1) holds (ex R11 being Function st (( dom R11 ) = R21 & (for R9 being (Subset of R1) holds (R9 in R21 implies ((R5 in R9 implies ( R11 . R9 ) = 1) & ((not R5 in R9) implies ( R11 . R9 ) = ( 0 ))))))))))
proof
let R1 being set;
let R5 being set;
let R21 being (SigmaField of R1);
deffunc H2(set) = ( 0 );
deffunc H3(set) = 1;
defpred S1[ set ] means R5 in $1;
L216: (ex B33 being Function st (( dom B33 ) = R21 & (for B34 being set holds (B34 in R21 implies ((S1[ B34 ] implies ( B33 . B34 ) = H3(B34)) & ((not S1[ B34 ]) implies ( B33 . B34 ) = H2(B34))))))) from PARTFUN1:sch 1;
consider C65 being Function such that L217: ( dom C65 ) = R21 and L218: (for B35 being set holds (B35 in R21 implies ((S1[ B35 ] implies ( C65 . B35 ) = 1) & ((not S1[ B35 ]) implies ( C65 . B35 ) = ( 0 ))))) by L216;
take C65;
thus L219: ( dom C65 ) = R21 by L217;
let R9 being (Subset of R1);
assume L220: R9 in R21;
thus L221: (R5 in R9 implies ( C65 . R9 ) = 1) by L220 , L218;
assume L222: (not R5 in R9);
thus L223: thesis by L222 , L218 , L220;
end;
theorem
L224: (for R1 being set holds (for R5 being set holds (for R21 being (SigmaField of R1) holds (ex R26 being (Function of R21 , ( REAL )) st (for R9 being (Subset of R1) holds (R9 in R21 implies ((R5 in R9 implies ( R26 . R9 ) = 1) & ((not R5 in R9) implies ( R26 . R9 ) = ( 0 )))))))))
proof
let R1 being set;
let R5 being set;
let R21 being (SigmaField of R1);
consider R11 being Function such that L225: ( dom R11 ) = R21 and L226: (for R9 being (Subset of R1) holds (R9 in R21 implies ((R5 in R9 implies ( R11 . R9 ) = 1) & ((not R5 in R9) implies ( R11 . R9 ) = ( 0 ))))) by L215;
L227: ( rng R11 ) c= ( REAL )
proof
let R7 being set;
assume L228: R7 in ( rng R11 );
consider R6 being set such that L229: R6 in ( dom R11 ) and L230: R7 = ( R11 . R6 ) by L228 , FUNCT_1:def 3;
reconsider D14 = R6 as (Subset of R1) by L225 , L229;
L231: ((not R5 in D14) implies R7 = ( 0 )) by L225 , L226 , L229 , L230;
L232: (R5 in D14 implies R7 = 1) by L225 , L226 , L229 , L230;
thus L233: thesis by L232 , L231;
end;
reconsider D15 = R11 as (Function of R21 , ( REAL )) by L227 , L225 , FUNCT_2:def 1 , RELSET_1:4;
take D15;
thus L234: thesis by L226;
end;
theorem
L235: (for R1 being set holds (for R21 being (SigmaField of R1) holds (for R25 being (SetSequence of R21) holds (for R26 being (Function of R21 , ( REAL )) holds ( R26 * R25 ) is Real_Sequence))))
proof
let R1 being set;
let R21 being (SigmaField of R1);
let R25 being (SetSequence of R21);
let R26 being (Function of R21 , ( REAL ));
L236: ( rng R25 ) c= R21 by RELAT_1:def 19;
L237: ( rng R25 ) c= ( dom R26 ) by L236 , FUNCT_2:def 1;
L238: ( dom ( R26 * R25 ) ) = ( dom R25 ) by L237 , RELAT_1:27
.= ( NAT ) by FUNCT_2:def 1;
L239: ( rng ( R26 * R25 ) ) c= ( REAL ) by RELAT_1:def 19;
thus L240: thesis by L239 , L238 , FUNCT_2:def 1 , RELSET_1:4;
end;
definition
let R1 being set;
let R21 being (SigmaField of R1);
let R25 being (SetSequence of R21);
let R26 being (Function of R21 , ( REAL ));
redefine func R26 * R25 -> Real_Sequence;

coherence by L235;
end;
definition
let R27 being non  empty set;
let R28 being (SigmaField of R27);
mode Probability of R28
 -> (Function of R28 , ( REAL ))
means :L242: ((for R29 being (Event of R28) holds ( 0 ) <= ( it . R29 )) & ( it . R27 ) = 1 & (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (R29 misses R30 implies ( it . ( R29 \/ R30 ) ) = ( ( it . R29 ) + ( it . R30 ) )))) & (for R31 being (SetSequence of R28) holds (R31 is  non-ascending implies (( it * R31 ) is  convergent & ( lim ( it * R31 ) ) = ( it . ( Intersection R31 ) )))));
existence
proof
set D16 = the (Element of R27);
consider R32 being (Function of R28 , ( REAL )) such that L243: (for R33 being (Subset of R27) holds (R33 in R28 implies ((D16 in R33 implies ( R32 . R33 ) = 1) & ((not D16 in R33) implies ( R32 . R33 ) = ( 0 ))))) by L224;
take R32;
thus L244: (for R29 being (Event of R28) holds ( 0 ) <= ( R32 . R29 )) by L243;
L245: ( [#] R28 ) in R28;
thus L246: ( R32 . R27 ) = 1 by L245 , L243;
thus L247: (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (R29 misses R30 implies ( R32 . ( R29 \/ R30 ) ) = ( ( R32 . R29 ) + ( R32 . R30 ) ))))
proof
let R29 being (Event of R28);
let R30 being (Event of R28);
assume that
L248: R29 misses R30;
L249: ((D16 in R29 & (not D16 in R30)) implies D16 in ( R29 \/ R30 )) by XBOOLE_0:def 3;
L250: (((not D16 in R29) & D16 in R30) implies (( R32 . R29 ) = ( 0 ) & ( R32 . R30 ) = 1)) by L243;
L251: (((not D16 in R29) & D16 in R30) implies D16 in ( R29 \/ R30 )) by XBOOLE_0:def 3;
L252: (((not D16 in R29) & (not D16 in R30)) implies (( R32 . R29 ) = ( 0 ) & ( R32 . R30 ) = ( 0 ))) by L243;
L253: (((not D16 in R29) & (not D16 in R30)) implies (not D16 in ( R29 \/ R30 ))) by XBOOLE_0:def 3;
L254: ((D16 in R29 & (not D16 in R30)) implies (( R32 . R29 ) = 1 & ( R32 . R30 ) = ( 0 ))) by L243;
thus L255: thesis by L254 , L243 , L248 , L249 , L250 , L251 , L252 , L253 , XBOOLE_0:3;
end;

let R31 being (SetSequence of R28);
L256: (for R13 being (Element of ( NAT )) holds ( ( R32 * R31 ) . R13 ) = ( R32 . ( R31 . R13 ) ))
proof
let R13 being (Element of ( NAT ));
L257: ( dom ( R32 * R31 ) ) = ( NAT ) by FUNCT_2:def 1;
thus L258: thesis by L257 , FUNCT_1:12;
end;
L259: ((for R13 being (Element of ( NAT )) holds D16 in ( R31 . R13 )) implies (for R13 being (Element of ( NAT )) holds ( ( R32 * R31 ) . R13 ) = 1))
proof
assume L260: (for R13 being (Element of ( NAT )) holds D16 in ( R31 . R13 ));
L261: (for R13 being (Element of ( NAT )) holds ( ( R32 * R31 ) . R13 ) = 1)
proof
let R13 being (Element of ( NAT ));
L262: (( rng R31 ) c= R28 & ( R31 . R13 ) in ( rng R31 )) by NAT_1:51 , RELAT_1:def 19;
L263: D16 in ( R31 . R13 ) by L260;
L264: ( R32 . ( R31 . R13 ) ) = 1 by L263 , L243 , L262;
thus L265: thesis by L264 , L256;
end;
thus L266: thesis by L261;
end;
assume L267: R31 is  non-ascending;
L268: ((not (for R13 being (Element of ( NAT )) holds D16 in ( R31 . R13 ))) implies (ex R12 being (Element of ( NAT )) st (for R13 being (Element of ( NAT )) holds (R12 <= R13 implies ( ( R32 * R31 ) . R13 ) = ( 0 )))))
proof
assume L269: (not (for R13 being (Element of ( NAT )) holds D16 in ( R31 . R13 )));
consider R12 being (Element of ( NAT )) such that L270: (not D16 in ( R31 . R12 )) by L269;
take R12;
L271: (for R13 being (Element of ( NAT )) holds (R12 <= R13 implies ( ( R32 * R31 ) . R13 ) = ( 0 )))
proof
let R13 being (Element of ( NAT ));
assume L272: R12 <= R13;
L273: ( R31 . R13 ) c= ( R31 . R12 ) by L272 , L267 , L140;
L274: (not D16 in ( R31 . R13 )) by L273 , L270;
L275: (( rng R31 ) c= R28 & ( R31 . R13 ) in ( rng R31 )) by NAT_1:51 , RELAT_1:def 19;
L276: ( R32 . ( R31 . R13 ) ) = ( 0 ) by L275 , L243 , L274;
thus L277: thesis by L276 , L256;
end;
thus L278: thesis by L271;
end;
L279: ((ex R12 being (Element of ( NAT )) st (for R13 being (Element of ( NAT )) holds (R12 <= R13 implies ( ( R32 * R31 ) . R13 ) = ( 0 )))) implies (( R32 * R31 ) is  convergent & ( lim ( R32 * R31 ) ) = ( 0 ))) by L1;
L280: ( rng R31 ) c= R28 by RELAT_1:def 19;
L281: ( Intersection R31 ) in R28 by L280 , L142;
reconsider D17 = 1 as Real;
L282: ((for R13 being (Element of ( NAT )) holds ( ( R32 * R31 ) . R13 ) = 1) implies (( R32 * R31 ) is  convergent & ( lim ( R32 * R31 ) ) = 1))
proof
assume L283: (for R13 being (Element of ( NAT )) holds ( ( R32 * R31 ) . R13 ) = 1);
L284: (ex R12 being (Element of ( NAT )) st (for R13 being (Element of ( NAT )) holds (R12 <= R13 implies ( ( R32 * R31 ) . R13 ) = D17)))
proof
take ( 0 );
thus L285: thesis by L283;
end;
thus L286: thesis by L284 , L1;
end;
per cases ;
suppose L287: (not (for R13 being (Element of ( NAT )) holds D16 in ( R31 . R13 )));

L288: (not D16 in ( Intersection R31 )) by L287 , L112;
thus L289: thesis by L288 , L243 , L268 , L279 , L287 , L281;
end;
suppose L290: (for R13 being (Element of ( NAT )) holds D16 in ( R31 . R13 ));

L291: D16 in ( Intersection R31 ) by L290 , L112;
thus L292: thesis by L291 , L243 , L259 , L282 , L290 , L281;
end;
end;
end;
registration
let R27 being non  empty set;
let R28 being (SigmaField of R27);
cluster  ->  zeroed for (Probability of R28);
coherence
proof
reconsider D18 = ( {} ) as (Event of R28) by L38;
let C66 being (Probability of R28);
L295: (( {} ) misses ( [#] R28 ) & ( ( {} ) \/ ( [#] R28 ) ) = ( [#] R28 )) by XBOOLE_1:65;
L296: 1 = ( C66 . ( [#] R28 ) ) by L242;
L297: 1 = ( ( C66 . D18 ) + 1 ) by L296 , L295 , L242;
thus L298: ( C66 . ( {} ) ) = ( 0 ) by L297;
end;
end;
theorem
L300: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R36 being (Probability of R28) holds ( R36 . ( [#] R28 ) ) = 1))) by L242;
theorem
L301: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R36 being (Probability of R28) holds ( ( R36 . ( ( [#] R28 ) \ R29 ) ) + ( R36 . R29 ) ) = 1))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R36 being (Probability of R28);
L302: ( ( ( [#] R28 ) \ R29 ) \/ R29 ) = ( ( R29 ` ) \/ R29 )
.= ( [#] R27 ) by SUBSET_1:10
.= R27;
L303: ( ( [#] R28 ) \ R29 ) misses R29 by XBOOLE_1:79;
L304: ( ( R36 . ( ( [#] R28 ) \ R29 ) ) + ( R36 . R29 ) ) = ( R36 . R27 ) by L303 , L302 , L242
.= 1 by L242;
thus L305: thesis by L304;
end;
theorem
L306: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R36 being (Probability of R28) holds ( R36 . ( ( [#] R28 ) \ R29 ) ) = ( 1 - ( R36 . R29 ) )))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R36 being (Probability of R28);
L307: ( ( R36 . ( ( [#] R28 ) \ R29 ) ) + ( R36 . R29 ) ) = 1 by L301;
thus L308: thesis by L307;
end;
theorem
L309: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (for R36 being (Probability of R28) holds (R29 c= R30 implies ( R36 . ( R30 \ R29 ) ) = ( ( R36 . R30 ) - ( R36 . R29 ) )))))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R30 being (Event of R28);
let R36 being (Probability of R28);
assume L310: R29 c= R30;
L311: R29 misses ( R30 \ R29 ) by XBOOLE_1:79;
L312: ( ( R36 . R29 ) + ( R36 . ( R30 \ R29 ) ) ) = ( R36 . ( R29 \/ ( R30 \ R29 ) ) ) by L311 , L242
.= ( R36 . R30 ) by L310 , XBOOLE_1:45;
thus L313: thesis by L312;
end;
theorem
L314: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (for R36 being (Probability of R28) holds (R29 c= R30 implies ( R36 . R29 ) <= ( R36 . R30 )))))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R30 being (Event of R28);
let R36 being (Probability of R28);
assume L315: R29 c= R30;
L316: ( R36 . ( R30 \ R29 ) ) = ( ( R36 . R30 ) - ( R36 . R29 ) ) by L315 , L309;
L317: ( 0 ) <= ( ( R36 . R30 ) - ( R36 . R29 ) ) by L316 , L242;
L318: ( ( 0 ) + ( R36 . R29 ) ) <= ( R36 . R30 ) by L317 , XREAL_1:19;
thus L319: thesis by L318;
end;
theorem
L320: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R36 being (Probability of R28) holds ( R36 . R29 ) <= 1))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R36 being (Probability of R28);
L321: ( R36 . ( [#] R28 ) ) = 1 by L242;
thus L322: thesis by L321 , L314;
end;
theorem
L323: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (for R36 being (Probability of R28) holds ( R36 . ( R29 \/ R30 ) ) = ( ( R36 . R29 ) + ( R36 . ( R30 \ R29 ) ) ))))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R30 being (Event of R28);
let R36 being (Probability of R28);
L324: R29 misses ( R30 \ R29 ) by XBOOLE_1:79;
L325: ( R36 . ( R29 \/ R30 ) ) = ( R36 . ( R29 \/ ( R30 \ R29 ) ) ) by XBOOLE_1:39
.= ( ( R36 . R29 ) + ( R36 . ( R30 \ R29 ) ) ) by L324 , L242;
thus L326: thesis by L325;
end;
theorem
L327: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (for R36 being (Probability of R28) holds ( R36 . ( R29 \/ R30 ) ) = ( ( R36 . R29 ) + ( R36 . ( R30 \ ( R29 /\ R30 ) ) ) ))))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R30 being (Event of R28);
let R36 being (Probability of R28);
thus L328: ( R36 . ( R29 \/ R30 ) ) = ( ( R36 . R29 ) + ( R36 . ( R30 \ R29 ) ) ) by L323
.= ( ( R36 . R29 ) + ( R36 . ( R30 \ ( R29 /\ R30 ) ) ) ) by XBOOLE_1:47;
end;
theorem
L329: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (for R36 being (Probability of R28) holds ( R36 . ( R29 \/ R30 ) ) = ( ( ( R36 . R29 ) + ( R36 . R30 ) ) - ( R36 . ( R29 /\ R30 ) ) ))))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R30 being (Event of R28);
let R36 being (Probability of R28);
L330: ( R36 . ( R29 \/ R30 ) ) = ( ( R36 . R29 ) + ( R36 . ( R30 \ ( R29 /\ R30 ) ) ) ) by L327
.= ( ( R36 . R29 ) + ( ( R36 . R30 ) - ( R36 . ( R29 /\ R30 ) ) ) ) by L309 , XBOOLE_1:17;
thus L331: thesis by L330;
end;
theorem
L332: (for R27 being non  empty set holds (for R28 being (SigmaField of R27) holds (for R29 being (Event of R28) holds (for R30 being (Event of R28) holds (for R36 being (Probability of R28) holds ( R36 . ( R29 \/ R30 ) ) <= ( ( R36 . R29 ) + ( R36 . R30 ) ))))))
proof
let R27 being non  empty set;
let R28 being (SigmaField of R27);
let R29 being (Event of R28);
let R30 being (Event of R28);
let R36 being (Probability of R28);
L333: (( 0 ) <= ( R36 . ( R29 /\ R30 ) ) & ( R36 . ( R29 \/ R30 ) ) = ( ( ( R36 . R29 ) + ( R36 . R30 ) ) - ( R36 . ( R29 /\ R30 ) ) )) by L242 , L329;
thus L334: thesis by L333 , XREAL_1:43;
end;
theorem
L335: (for R2 being set holds ( bool R2 ) is (SigmaField of R2));
definition
let R27 being non  empty set;
let C67 being (Subset-Family of R27);
func sigma C67 -> (SigmaField of R27) means 
(C67 c= it & (for R4 being set holds ((C67 c= R4 & R4 is (SigmaField of R27)) implies it c= R4)));
existence
proof
set D19 = { R38 where R38 is (Subset-Family of R27) : (C67 c= R38 & R38 is (SigmaField of R27)) };
set D20 = ( meet D19 );
L336:
now
let R4 being set;
assume L337: R4 in D19;
L338: (ex R38 being (Subset-Family of R27) st (R4 = R38 & C67 c= R38 & R38 is (SigmaField of R27))) by L337;
thus L339: C67 c= R4 by L338;
end;
L340: ( bool R27 ) in D19;
L341: (for R34 being (Subset of R27) holds (R34 in D20 implies ( R34 ` ) in D20))
proof
let R34 being (Subset of R27);
assume that
L342: R34 in D20;
L343:
now
let R4 being set;
assume L344: R4 in D19;
L345: (R34 in R4 & (ex R38 being (Subset-Family of R27) st (R4 = R38 & C67 c= R38 & R38 is (SigmaField of R27)))) by L344 , L342 , SETFAM_1:def 1;
thus L346: ( R34 ` ) in R4 by L345 , L11;
end;
thus L347: thesis by L343 , L340 , SETFAM_1:def 1;
end;
L348: (for R35 being (SetSequence of R27) holds (( rng R35 ) c= D20 implies ( Intersection R35 ) in D20))
proof
let R35 being (SetSequence of R27);
assume that
L349: ( rng R35 ) c= D20;
L350:
now
let R4 being set;
assume L351: R4 in D19;
L352:
now
let C68 being Nat;
L353: ( R35 . C68 ) in ( rng R35 ) by NAT_1:51;
thus L354: ( R35 . C68 ) in R4 by L353 , L349 , L351 , SETFAM_1:def 1;
end;
L355: ( rng R35 ) c= R4 by L352 , NAT_1:52;
L356: (ex R38 being (Subset-Family of R27) st (R4 = R38 & C67 c= R38 & R38 is (SigmaField of R27))) by L351;
thus L357: ( Intersection R35 ) in R4 by L356 , L355 , L142;
end;
thus L358: thesis by L350 , L340 , SETFAM_1:def 1;
end;
L359:
now
let R4 being set;
assume L360: R4 in D19;
L361: (ex R38 being (Subset-Family of R27) st (R4 = R38 & C67 c= R38 & R38 is (SigmaField of R27))) by L360;
thus L362: ( {} ) in R4 by L361 , L38;
end;
reconsider D21 = D20 as (SigmaField of R27) by L359 , L340 , L348 , L341 , L11 , L142 , SETFAM_1:3 , SETFAM_1:def 1;
take D21;
L363: (for R4 being set holds ((C67 c= R4 & R4 is (SigmaField of R27)) implies D21 c= R4))
proof
let R4 being set;
assume that
L364: C67 c= R4
and
L365: R4 is (SigmaField of R27);
reconsider D22 = R4 as (Subset-Family of R27) by L365;
L366: D22 in D19 by L364 , L365;
thus L367: thesis by L366 , SETFAM_1:3;
end;
thus L368: thesis by L363 , L340 , L336 , SETFAM_1:5;
end;
uniqueness
proof
let C69 , C70 being (SigmaField of R27);
assume L369: (C67 c= C69 & (for R4 being set holds ((C67 c= R4 & R4 is (SigmaField of R27)) implies C69 c= R4)) & C67 c= C70 & (for R4 being set holds ((C67 c= R4 & R4 is (SigmaField of R27)) implies C70 c= R4)));
L370: (C69 c= C70 & C70 c= C69) by L369;
thus L371: thesis by L370 , XBOOLE_0:def 10;
end;
end;
definition
let C71 being  ext-real number;
func halfline C71 -> (Subset of ( REAL )) equals 
]. ( -infty ) , C71 .[;
coherence
proof
L373: ]. ( -infty ) , C71 .[ c= ( REAL )
proof
let C72 being  real number;
assume L374: C72 in ]. ( -infty ) , C71 .[;
L375: (( -infty ) < C72 & C72 < C71) by L374 , XXREAL_1:4;
thus L376: thesis by L375 , XXREAL_0:48;
end;
thus L377: thesis by L373;
end;
end;
definition
func Family_of_halflines -> (Subset-Family of ( REAL )) equals 
{ ( halfline B36 ) where B36 is (Element of ( REAL )) : (not contradiction) };
coherence
proof
L379: { ( halfline B37 ) where B37 is (Element of ( REAL )) : (not contradiction) } c= ( bool ( REAL ) )
proof
let R5 being set;
assume L380: R5 in { ( halfline B38 ) where B38 is (Element of ( REAL )) : (not contradiction) };
L381: (ex B39 being (Element of ( REAL )) st R5 = ( halfline B39 )) by L380;
thus L382: R5 in ( bool ( REAL ) ) by L381;
end;
thus L383: thesis by L379;
end;
end;
definition
func Borel_Sets -> (SigmaField of ( REAL )) equals 
( sigma ( Family_of_halflines ) );
correctness;
end;
theorem
L386: (for R2 being set holds (for B40 , B41 being (Subset of R2) holds ( Complement ( B40 followed_by B41 ) ) = ( ( B40 ` ) followed_by ( B41 ` ) ))) by L128;
definition
let C73 , C74 being set;
let C75 being (Subset-Family of C73);
let C76 being (Function of C74 , ( bool C75 ));
let C77 being set;
redefine func C76 . C77 -> (Subset-Family of C73);

coherence
proof
per cases ;
suppose L387: C77 in ( dom C76 );

L388: ( rng C76 ) c= ( bool C75 ) by RELAT_1:def 19;
L389: ( bool C75 ) c= ( bool ( bool C73 ) ) by ZFMISC_1:67;
L390: ( C76 . C77 ) in ( rng C76 ) by L387 , FUNCT_1:def 3;
L391: ( C76 . C77 ) in ( bool C75 ) by L390 , L388;
thus L392: thesis by L391 , L389;
end;
suppose L393: (not C77 in ( dom C76 ));

L394: ( C76 . C77 ) = ( {} ) by L393 , FUNCT_1:def 2;
thus L395: thesis by L394 , XBOOLE_1:2;
end;
end;
end;
