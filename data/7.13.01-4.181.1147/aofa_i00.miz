:: Mizar Analysis of Algorithms: Algorithms over Integers
::  by Grzegorz Bancerek
::
:: Received March 18, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FUNCT_1, FUNCOP_1, RELAT_1, AOFA_000, FUNCT_4, XBOOLE_0,
      SUBSET_1, TARSKI, ZFMISC_1, FUNCT_2, ZF_LANG, VALUED_0, XREAL_0,
      ORDINAL1, VALUED_1, INT_1, XXREAL_0, CARD_1, ARYTM_3, ARYTM_1, FINSET_1,
      ORDINAL2, MEMBER_1, CARD_3, NAT_1, POWER, ORDINAL4, EUCLMETR, FREEALG,
      TREES_4, LANG1, MCART_1, STRUCT_0, GRAPHSP, ABIAN, FUNCT_7, REALSET1,
      NEWTON, PRE_FF, INT_2, COMPLEX1, AOFA_I00;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XTUPLE_0, MCART_1, ORDINAL1,
      RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, FINSET_1, LANG1, BINOP_1,
      CARD_1, CARD_2, CARD_3, VALUED_0, PRE_FF, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, POWER, INT_1, INT_2, NAT_1, NAT_D, NEWTON, ABIAN, FUNCOP_1,
      FUNCT_4, FUNCT_7, STRUCT_0, FREEALG, TREES_4, AOFA_000, VALUED_1;
 constructors REAL_1, BORSUK_1, PREPOWER, POWER, NAT_D, NEWTON, ABIAN,
      SQUARE_1, PRE_FF, WSIERP_1, WELLORD2, CARD_2, CAT_2, AOFA_000, XTUPLE_0;
 registrations RELSET_1, FUNCT_1, FUNCOP_1, FUNCT_2, NUMBERS, NAT_1, STRUCT_0,
      FREEALG, INT_1, CARD_5, CARD_1, CARD_3, VALUED_0, VALUED_1, MEMBERED,
      XREAL_0, XCMPLX_0, XXREAL_0, XBOOLE_0, FINSET_1, POWER, AOFA_000, ABIAN,
      XTUPLE_0;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions XCMPLX_0, CARD_2, TARSKI, XBOOLE_0, RELAT_1, FUNCT_1, FUNCT_2,
      FREEALG, BINOP_1, AOFA_000, FUNCOP_1, VALUED_1, XTUPLE_0;
 theorems XBOOLE_1, ZFMISC_1, RELAT_1, FUNCT_2, FUNCOP_1, TARSKI, NEWTON,
      XREAL_1, INT_1, FUNCT_7, NAT_1, ORDINAL1, FUNCT_4, FREEALG, PRE_FF,
      INT_2, ABSVALUE, WSIERP_1, TREES_4, NUMBERS, FUNCT_1, CARD_2, CARD_1,
      WELLORD2, FUNCT_5, AOFA_000, MCART_1, XXREAL_0, POWER, FIB_NUM2,
      ORDINAL3, NAT_D, PREPOWER, VALUED_1, CARD_3, XTUPLE_0;
 schemes FUNCT_1, FUNCT_2, XBOOLE_0, AOFA_000, TARSKI, CLASSES1;

begin
theorem
L1: (for B1 , B2 , B3 , B4 , B5 , B6 being set holds ((B4 <> B5 & B5 <> B6 & B6 <> B4) implies (ex B7 being Function st (( B7 . B4 ) = B1 & ( B7 . B5 ) = B2 & ( B7 . B6 ) = B3))))
proof
let C1 , C2 , C3 , C4 , C5 , C6 being set;
assume that
L2: C4 <> C5
and
L3: C5 <> C6
and
L4: C6 <> C4;
set D1 = ( C5 .--> C2 );
L5: ( dom D1 ) = { C5 } by FUNCOP_1:13;
L6: C4 nin ( dom D1 ) by L2 , TARSKI:def 1;
L7: C5 in ( dom D1 ) by L5 , TARSKI:def 1;
set D2 = ( C6 .--> C3 );
set D3 = ( C4 .--> C1 );
take D4 = ( ( D3 +* D1 ) +* D2 );
L8: ( dom D2 ) = { C6 } by FUNCOP_1:13;
L9: C4 nin ( dom D2 ) by L4 , TARSKI:def 1;
thus L10: ( D4 . C4 ) = ( ( D3 +* D1 ) . C4 ) by L9 , FUNCT_4:11
.= ( D3 . C4 ) by L6 , FUNCT_4:11
.= C1 by FUNCOP_1:72;
L11: C5 nin ( dom D2 ) by L3 , TARSKI:def 1;
thus L12: ( D4 . C5 ) = ( ( D3 +* D1 ) . C5 ) by L11 , FUNCT_4:11
.= ( D1 . C5 ) by L7 , FUNCT_4:13
.= C2 by FUNCOP_1:72;
L13: C6 in ( dom D2 ) by L8 , TARSKI:def 1;
thus L14: ( D4 . C6 ) = ( D2 . C6 ) by L13 , FUNCT_4:13
.= C3 by FUNCOP_1:72;
end;
definition
let C7 being non  empty  functional set;
let C8 being set;
let C9 being set;
func C7 \ (C8 , C9) -> (Subset of C7) equals 
{ B8 where B8 is (Element of C7) : ( B8 . C8 ) <> C9 };
coherence
proof
set D5 = { B9 where B9 is (Element of C7) : ( B9 . C8 ) <> C9 };
L15: D5 c= C7
proof
let C10 being set;
assume L16: C10 in D5;
L17: (ex B10 being (Element of C7) st (B10 = C10 & ( B10 . C8 ) <> C9)) by L16;
thus L18: thesis by L17;
end;
thus L19: thesis by L15;
end;
end;
theorem
L21: (for B11 being non  empty  functional set holds (for B12 , B13 being set holds (for B14 being (Element of B11) holds (B14 in ( B11 \ (B12 , B13) ) iff ( B14 . B12 ) <> B13))))
proof
let C11 being non  empty  functional set;
let C12 , C13 being set;
let C14 being (Element of C11);
L22: (C14 in ( C11 \ (C12 , C13) ) iff (ex B15 being (Element of C11) st (C14 = B15 & ( B15 . C12 ) <> C13)));
thus L23: thesis by L22;
end;
definition
let C15 being set;
let C16 , C17 being set;
let C18 being (Function of [: ( Funcs (C15 , ( INT )) ) , C16 :] , C17);
mode Variable of C18
 -> (Element of C15)
means :L24: (not contradiction);
existence;
end;
notation
let C19 being  real-valued Function;
let C20 being  real number;
synonym C19 * C20 for C20 (#) C19;
end;
definition
let C21 , C22 being ( INT ) -valued Function;
func C21 div C22 -> ( INT ) -valued Function means 
:L27: (( dom it ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B16 being set holds (B16 in ( dom it ) implies ( it . B16 ) = ( ( C21 . B16 ) div ( C22 . B16 ) ))));
correctness
proof
deffunc H1(set) = ( ( C21 . $1 ) div ( C22 . $1 ) );
consider C23 being Function such that L28: (( dom C23 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B17 being set holds (B17 in ( ( dom C21 ) /\ ( dom C22 ) ) implies ( C23 . B17 ) = H1(B17)))) from FUNCT_1:sch 3;
L29: C23 is ( INT ) -valued
proof
let C24 being set;
assume L30: C24 in ( rng C23 );
consider C25 being set such that L31: C25 in ( dom C23 ) and L32: ( C23 . C25 ) = C24 by L30 , FUNCT_1:def 3;
L33: ( C23 . C25 ) = H1(C25) by L28 , L31;
thus L34: thesis by L33 , L32 , INT_1:def 2;
end;
thus L35: (ex B18 being ( INT ) -valued Function st (( dom B18 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B19 being set holds (B19 in ( dom B18 ) implies ( B18 . B19 ) = H1(B19))))) by L29 , L28;
let C26 , C27 being ( INT ) -valued Function;
assume that
L36: ( dom C26 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L37: (for B20 being set holds (B20 in ( dom C26 ) implies ( C26 . B20 ) = H1(B20)))
and
L38: ( dom C27 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L39: (for B21 being set holds (B21 in ( dom C27 ) implies ( C27 . B21 ) = H1(B21)));
L40:
now
let C28 being set;
assume L41: C28 in ( ( dom C21 ) /\ ( dom C22 ) );
thus L42: ( C26 . C28 ) = H1(C28) by L41 , L36 , L37
.= ( C27 . C28 ) by L38 , L39 , L41;
end;
thus L43: thesis by L40 , L36 , L38 , FUNCT_1:2;
end;
func C21 mod C22 -> ( INT ) -valued Function means 
:L44: (( dom it ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B22 being set holds (B22 in ( dom it ) implies ( it . B22 ) = ( ( C21 . B22 ) mod ( C22 . B22 ) ))));
correctness
proof
deffunc H2(set) = ( ( C21 . $1 ) mod ( C22 . $1 ) );
consider C29 being Function such that L45: (( dom C29 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B23 being set holds (B23 in ( ( dom C21 ) /\ ( dom C22 ) ) implies ( C29 . B23 ) = H2(B23)))) from FUNCT_1:sch 3;
L46: C29 is ( INT ) -valued
proof
let C30 being set;
assume L47: C30 in ( rng C29 );
consider C31 being set such that L48: C31 in ( dom C29 ) and L49: ( C29 . C31 ) = C30 by L47 , FUNCT_1:def 3;
L50: ( C29 . C31 ) = H2(C31) by L45 , L48;
thus L51: thesis by L50 , L49 , INT_1:def 2;
end;
thus L52: (ex B24 being ( INT ) -valued Function st (( dom B24 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B25 being set holds (B25 in ( dom B24 ) implies ( B24 . B25 ) = H2(B25))))) by L46 , L45;
let C32 , C33 being ( INT ) -valued Function;
assume that
L53: ( dom C32 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L54: (for B26 being set holds (B26 in ( dom C32 ) implies ( C32 . B26 ) = H2(B26)))
and
L55: ( dom C33 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L56: (for B27 being set holds (B27 in ( dom C33 ) implies ( C33 . B27 ) = H2(B27)));
L57:
now
let C34 being set;
assume L58: C34 in ( ( dom C21 ) /\ ( dom C22 ) );
thus L59: ( C32 . C34 ) = H2(C34) by L58 , L53 , L54
.= ( C33 . C34 ) by L55 , L56 , L58;
end;
thus L60: thesis by L57 , L53 , L55 , FUNCT_1:2;
end;
func leq (C21 , C22) -> ( INT ) -valued Function means 
:L61: (( dom it ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B28 being set holds (B28 in ( dom it ) implies ( it . B28 ) = ( IFGT (( C21 . B28 ) , ( C22 . B28 ) , ( 0 ) , 1) ))));
correctness
proof
deffunc H3(set) = ( IFGT (( C21 . $1 ) , ( C22 . $1 ) , ( 0 ) , 1) );
consider C35 being Function such that L62: (( dom C35 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B29 being set holds (B29 in ( ( dom C21 ) /\ ( dom C22 ) ) implies ( C35 . B29 ) = H3(B29)))) from FUNCT_1:sch 3;
L63: C35 is ( INT ) -valued
proof
let C36 being set;
assume L64: C36 in ( rng C35 );
consider C37 being set such that L65: C37 in ( dom C35 ) and L66: ( C35 . C37 ) = C36 by L64 , FUNCT_1:def 3;
L67: ( C35 . C37 ) = H3(C37) by L62 , L65;
thus L68: thesis by L67 , L66 , INT_1:def 2;
end;
thus L69: (ex B30 being ( INT ) -valued Function st (( dom B30 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B31 being set holds (B31 in ( dom B30 ) implies ( B30 . B31 ) = H3(B31))))) by L63 , L62;
let C38 , C39 being ( INT ) -valued Function;
assume that
L70: ( dom C38 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L71: (for B32 being set holds (B32 in ( dom C38 ) implies ( C38 . B32 ) = H3(B32)))
and
L72: ( dom C39 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L73: (for B33 being set holds (B33 in ( dom C39 ) implies ( C39 . B33 ) = H3(B33)));
L74:
now
let C40 being set;
assume L75: C40 in ( ( dom C21 ) /\ ( dom C22 ) );
thus L76: ( C38 . C40 ) = H3(C40) by L75 , L70 , L71
.= ( C39 . C40 ) by L72 , L73 , L75;
end;
thus L77: thesis by L74 , L70 , L72 , FUNCT_1:2;
end;
func gt (C21 , C22) -> ( INT ) -valued Function means 
:L78: (( dom it ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B34 being set holds (B34 in ( dom it ) implies ( it . B34 ) = ( IFGT (( C21 . B34 ) , ( C22 . B34 ) , 1 , ( 0 )) ))));
correctness
proof
deffunc H4(set) = ( IFGT (( C21 . $1 ) , ( C22 . $1 ) , 1 , ( 0 )) );
consider C41 being Function such that L79: (( dom C41 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B35 being set holds (B35 in ( ( dom C21 ) /\ ( dom C22 ) ) implies ( C41 . B35 ) = H4(B35)))) from FUNCT_1:sch 3;
L80: C41 is ( INT ) -valued
proof
let C42 being set;
assume L81: C42 in ( rng C41 );
consider C43 being set such that L82: C43 in ( dom C41 ) and L83: ( C41 . C43 ) = C42 by L81 , FUNCT_1:def 3;
L84: ( C41 . C43 ) = H4(C43) by L79 , L82;
thus L85: thesis by L84 , L83 , INT_1:def 2;
end;
thus L86: (ex B36 being ( INT ) -valued Function st (( dom B36 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B37 being set holds (B37 in ( dom B36 ) implies ( B36 . B37 ) = H4(B37))))) by L80 , L79;
let C44 , C45 being ( INT ) -valued Function;
assume that
L87: ( dom C44 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L88: (for B38 being set holds (B38 in ( dom C44 ) implies ( C44 . B38 ) = H4(B38)))
and
L89: ( dom C45 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L90: (for B39 being set holds (B39 in ( dom C45 ) implies ( C45 . B39 ) = H4(B39)));
L91:
now
let C46 being set;
assume L92: C46 in ( ( dom C21 ) /\ ( dom C22 ) );
thus L93: ( C44 . C46 ) = H4(C46) by L92 , L87 , L88
.= ( C45 . C46 ) by L89 , L90 , L92;
end;
thus L94: thesis by L91 , L87 , L89 , FUNCT_1:2;
end;
func eq (C21 , C22) -> ( INT ) -valued Function means 
:L95: (( dom it ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B40 being set holds (B40 in ( dom it ) implies ( it . B40 ) = ( IFEQ (( C21 . B40 ) , ( C22 . B40 ) , 1 , ( 0 )) ))));
correctness
proof
deffunc H5(set) = ( IFEQ (( C21 . $1 ) , ( C22 . $1 ) , 1 , ( 0 )) );
consider C47 being Function such that L96: (( dom C47 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B41 being set holds (B41 in ( ( dom C21 ) /\ ( dom C22 ) ) implies ( C47 . B41 ) = H5(B41)))) from FUNCT_1:sch 3;
L97: C47 is ( INT ) -valued
proof
let C48 being set;
assume L98: C48 in ( rng C47 );
consider C49 being set such that L99: C49 in ( dom C47 ) and L100: ( C47 . C49 ) = C48 by L98 , FUNCT_1:def 3;
L101: ( C47 . C49 ) = H5(C49) by L96 , L99;
thus L102: thesis by L101 , L100 , INT_1:def 2;
end;
thus L103: (ex B42 being ( INT ) -valued Function st (( dom B42 ) = ( ( dom C21 ) /\ ( dom C22 ) ) & (for B43 being set holds (B43 in ( dom B42 ) implies ( B42 . B43 ) = H5(B43))))) by L97 , L96;
let C50 , C51 being ( INT ) -valued Function;
assume that
L104: ( dom C50 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L105: (for B44 being set holds (B44 in ( dom C50 ) implies ( C50 . B44 ) = H5(B44)))
and
L106: ( dom C51 ) = ( ( dom C21 ) /\ ( dom C22 ) )
and
L107: (for B45 being set holds (B45 in ( dom C51 ) implies ( C51 . B45 ) = H5(B45)));
L108:
now
let C52 being set;
assume L109: C52 in ( ( dom C21 ) /\ ( dom C22 ) );
thus L110: ( C50 . C52 ) = H5(C52) by L109 , L104 , L105
.= ( C51 . C52 ) by L106 , L107 , L109;
end;
thus L111: thesis by L108 , L104 , L106 , FUNCT_1:2;
end;
end;
definition
let C53 being non  empty set;
let C54 being (Function of C53 , ( INT ));
let C55 being  integer number;
redefine func C54 + C55 -> (Function of C53 , ( INT )) means 
:L113: (for B46 being (Element of C53) holds ( it . B46 ) = ( ( C54 . B46 ) + C55 ));
compatibility
proof
let C56 being (Function of C53 , ( INT ));
L114: ( dom C54 ) = C53 by FUNCT_2:def 1;
L115: ( dom ( C54 + C55 ) ) = ( dom C54 ) by VALUED_1:def 2;
thus L116: (C56 = ( C54 + C55 ) implies (for B47 being (Element of C53) holds ( C56 . B47 ) = ( ( C54 . B47 ) + C55 ))) by L115 , L114 , VALUED_1:def 2;
L117: ( dom C56 ) = C53 by FUNCT_2:def 1;
assume L118: (for B48 being (Element of C53) holds ( C56 . B48 ) = ( ( C54 . B48 ) + C55 ));
L119: (for B49 being set holds (B49 in C53 implies ( C56 . B49 ) = ( C55 + ( C54 . B49 ) ))) by L118;
thus L120: thesis by L119 , L114 , L117 , VALUED_1:def 2;
end;
coherence
proof
L121: ( C55 + C54 ) is (Function of C53 , ( INT ));
thus L122: thesis by L121;
end;
redefine func C54 - C55 -> (Function of C53 , ( INT )) means 
(for B50 being (Element of C53) holds ( it . B50 ) = ( ( C54 . B50 ) - C55 ));
compatibility
proof
let C57 being (Function of C53 , ( INT ));
L123: ( dom C57 ) = C53 by FUNCT_2:def 1;
L124: ( dom C54 ) = C53 by FUNCT_2:def 1;
thus L125: (C57 = ( C54 - C55 ) implies (for B51 being (Element of C53) holds ( C57 . B51 ) = ( ( C54 . B51 ) - C55 ))) by L124 , VALUED_1:3;
assume L126: (for B52 being (Element of C53) holds ( C57 . B52 ) = ( ( C54 . B52 ) - C55 ));
L127:
now
let C58 being set;
assume L128: C58 in ( dom C57 );
thus L129: ( C57 . C58 ) = ( ( C54 . C58 ) - C55 ) by L128 , L126
.= ( ( C54 - C55 ) . C58 ) by L124 , L128 , VALUED_1:3;
end;
L130: ( dom ( C54 - C55 ) ) = ( dom C54 ) by VALUED_1:3;
thus L131: C57 = ( C54 - C55 ) by L130 , L124 , L123 , L127 , FUNCT_1:2;
end;
coherence
proof
thus L132: ( C54 - C55 ) is (Function of C53 , ( INT ));
end;
redefine func C54 * C55 -> (Function of C53 , ( INT )) means 
:L133: (for B53 being (Element of C53) holds ( it . B53 ) = ( ( C54 . B53 ) * C55 ));
compatibility
proof
let C59 being (Function of C53 , ( INT ));
L134: ( dom ( C54 * C55 ) ) = ( dom C54 ) by VALUED_1:def 5;
L135: ( dom C54 ) = C53 by FUNCT_2:def 1;
thus L136: (C59 = ( C54 * C55 ) implies (for B54 being (Element of C53) holds ( C59 . B54 ) = ( ( C54 . B54 ) * C55 ))) by L135 , L134 , VALUED_1:def 5;
L137: ( dom C59 ) = C53 by FUNCT_2:def 1;
assume L138: (for B55 being (Element of C53) holds ( C59 . B55 ) = ( ( C54 . B55 ) * C55 ));
L139: (for B56 being set holds (B56 in ( dom ( C54 * C55 ) ) implies ( C59 . B56 ) = ( C55 * ( C54 . B56 ) ))) by L138;
thus L140: thesis by L139 , L134 , L135 , L137 , VALUED_1:def 5;
end;
coherence
proof
L141: ( C55 (#) C54 ) is (Function of C53 , ( INT ));
thus L142: thesis by L141;
end;
end;
definition
let C60 being set;
let C61 , C62 being (Function of C60 , ( INT ));
redefine func C61 div C62 -> (Function of C60 , ( INT ));

coherence
proof
L144: ( dom C62 ) = C60 by FUNCT_2:def 1;
L145: ( dom ( C61 div C62 ) ) = ( ( dom C61 ) /\ ( dom C62 ) ) by L27;
L146: ( dom C61 ) = C60 by FUNCT_2:def 1;
L147: ( rng ( C61 div C62 ) ) c= ( INT );
thus L148: thesis by L147 , L145 , L146 , L144 , FUNCT_2:2;
end;
redefine func C61 mod C62 -> (Function of C60 , ( INT ));

coherence
proof
L149: ( dom C62 ) = C60 by FUNCT_2:def 1;
L150: ( dom ( C61 mod C62 ) ) = ( ( dom C61 ) /\ ( dom C62 ) ) by L44;
L151: ( dom C61 ) = C60 by FUNCT_2:def 1;
L152: ( rng ( C61 mod C62 ) ) c= ( INT );
thus L153: thesis by L152 , L150 , L151 , L149 , FUNCT_2:2;
end;
redefine func leq (C61 , C62) -> (Function of C60 , ( INT ));

coherence
proof
L154: ( dom C62 ) = C60 by FUNCT_2:def 1;
L155: ( dom ( leq (C61 , C62) ) ) = ( ( dom C61 ) /\ ( dom C62 ) ) by L61;
L156: ( dom C61 ) = C60 by FUNCT_2:def 1;
L157: ( rng ( leq (C61 , C62) ) ) c= ( INT );
thus L158: thesis by L157 , L155 , L156 , L154 , FUNCT_2:2;
end;
redefine func gt (C61 , C62) -> (Function of C60 , ( INT ));

coherence
proof
L159: ( dom C62 ) = C60 by FUNCT_2:def 1;
L160: ( dom ( gt (C61 , C62) ) ) = ( ( dom C61 ) /\ ( dom C62 ) ) by L78;
L161: ( dom C61 ) = C60 by FUNCT_2:def 1;
L162: ( rng ( gt (C61 , C62) ) ) c= ( INT );
thus L163: thesis by L162 , L160 , L161 , L159 , FUNCT_2:2;
end;
redefine func eq (C61 , C62) -> (Function of C60 , ( INT ));

coherence
proof
L164: ( dom C62 ) = C60 by FUNCT_2:def 1;
L165: ( dom ( eq (C61 , C62) ) ) = ( ( dom C61 ) /\ ( dom C62 ) ) by L95;
L166: ( dom C61 ) = C60 by FUNCT_2:def 1;
L167: ( rng ( eq (C61 , C62) ) ) c= ( INT );
thus L168: thesis by L167 , L165 , L166 , L164 , FUNCT_2:2;
end;
end;
definition
let C63 being non  empty set;
let C64 , C65 being (Function of C63 , ( INT ));
redefine func C64 - C65 -> (Function of C63 , ( INT )) means 
:L170: (for B57 being (Element of C63) holds ( it . B57 ) = ( ( C64 . B57 ) - ( C65 . B57 ) ));
compatibility
proof
let C66 being (Function of C63 , ( INT ));
L171: ( dom C64 ) = C63 by FUNCT_2:def 1;
thus L172: (C66 = ( C64 - C65 ) implies (for B58 being (Element of C63) holds ( C66 . B58 ) = ( ( C64 . B58 ) - ( C65 . B58 ) ))) by VALUED_1:15;
L173: ( dom C66 ) = C63 by FUNCT_2:def 1;
assume L174: (for B59 being (Element of C63) holds ( C66 . B59 ) = ( ( C64 . B59 ) - ( C65 . B59 ) ));
L175:
now
let C67 being set;
assume L176: C67 in C63;
thus L177: ( C66 . C67 ) = ( ( C64 . C67 ) - ( C65 . C67 ) ) by L176 , L174
.= ( ( C64 - C65 ) . C67 ) by L176 , VALUED_1:15;
end;
L178: ( dom C65 ) = C63 by FUNCT_2:def 1;
L179: ( dom ( C64 - C65 ) ) = ( ( dom C64 ) /\ ( dom C65 ) ) by VALUED_1:12;
thus L180: C66 = ( C64 - C65 ) by L179 , L171 , L178 , L173 , L175 , FUNCT_1:2;
end;
coherence
proof
thus L181: ( C64 - C65 ) is (Function of C63 , ( INT ));
end;
redefine func C64 + C65 -> (Function of C63 , ( INT )) means 
(for B60 being (Element of C63) holds ( it . B60 ) = ( ( C64 . B60 ) + ( C65 . B60 ) ));
compatibility
proof
let C68 being (Function of C63 , ( INT ));
L182: ( dom C64 ) = C63 by FUNCT_2:def 1;
L183: ( dom C65 ) = C63 by FUNCT_2:def 1;
L184: ( dom ( C64 + C65 ) ) = ( ( dom C64 ) /\ ( dom C65 ) ) by VALUED_1:def 1;
thus L185: (C68 = ( C64 + C65 ) implies (for B61 being (Element of C63) holds ( C68 . B61 ) = ( ( C64 . B61 ) + ( C65 . B61 ) ))) by L184 , L182 , L183 , VALUED_1:def 1;
L186: ( dom C68 ) = C63 by FUNCT_2:def 1;
assume L187: (for B62 being (Element of C63) holds ( C68 . B62 ) = ( ( C64 . B62 ) + ( C65 . B62 ) ));
L188: (for B63 being set holds (B63 in C63 implies ( C68 . B63 ) = ( ( C64 . B63 ) + ( C65 . B63 ) ))) by L187;
thus L189: C68 = ( C64 + C65 ) by L188 , L184 , L182 , L183 , L186 , VALUED_1:def 1;
end;
coherence
proof
thus L190: ( C64 + C65 ) is (Function of C63 , ( INT ));
end;
end;
registration
let C69 being non  empty set;
let C70 being  infinite set;
cluster ( Funcs (C69 , C70) ) ->  infinite;
coherence
proof
L192: ( card ( card C70 ) ) = ( card C70 );
L193: ( card C69 ) = ( card ( card C69 ) );
L194: ( card ( Funcs (C69 , C70) ) ) = ( exp (( card C70 ) , ( card C69 )) ) by L193 , L192 , FUNCT_5:61;
set D6 = the (Element of C69);
L195: ( card { D6 } ) = 1 by CARD_1:30;
L196: { D6 } c= C69 by ZFMISC_1:31;
L197: 1 c= ( card C69 ) by L196 , L195 , CARD_1:11;
L198: ( exp (( card C70 ) , 1) ) c= ( card ( Funcs (C69 , C70) ) ) by L197 , L194 , CARD_2:93;
thus L199: thesis by L198 , CARD_2:27;
end;
end;
definition
let C71 being set;
let C72 being Function;
let C73 being Function;
func C72 ** (C73 , C71) -> Function means 
:L201: ((ex B64 being set st ((for B65 being set holds (B65 in B64 iff (ex B66 being Function st (B66 in ( dom C72 ) & B65 in ( rng B66 ))))) & (for B67 being set holds (B67 in ( dom it ) iff (B67 in ( Funcs (C71 , B64) ) & (ex B68 being Function st (B67 = B68 & ( B68 * C73 ) in ( dom C72 )))))))) & (for B69 being Function holds (B69 in ( dom it ) implies ( it . B69 ) = ( C72 . ( B69 * C73 ) ))));
uniqueness
proof
let C74 , C75 being Function;
given C76 being set such that
L202: (for B70 being set holds (B70 in C76 iff (ex B71 being Function st (B71 in ( dom C72 ) & B70 in ( rng B71 )))))
and
L203: (for B72 being set holds (B72 in ( dom C74 ) iff (B72 in ( Funcs (C71 , C76) ) & (ex B73 being Function st (B72 = B73 & ( B73 * C73 ) in ( dom C72 ))))));

assume L204: (for B74 being Function holds (B74 in ( dom C74 ) implies ( C74 . B74 ) = ( C72 . ( B74 * C73 ) )));
given C77 being set such that
L205: (for B75 being set holds (B75 in C77 iff (ex B76 being Function st (B76 in ( dom C72 ) & B75 in ( rng B76 )))))
and
L206: (for B77 being set holds (B77 in ( dom C75 ) iff (B77 in ( Funcs (C71 , C77) ) & (ex B78 being Function st (B77 = B78 & ( B78 * C73 ) in ( dom C72 ))))));

L207:
now
let C78 being set;
L208: (C78 in C76 iff (ex B79 being Function st (B79 in ( dom C72 ) & C78 in ( rng B79 )))) by L202;
thus L209: (C78 in C76 iff C78 in C77) by L208 , L205;
end;
L210: C76 = C77 by L207 , TARSKI:1;
L211:
now
let C79 being set;
L212: (C79 in ( dom C74 ) iff (C79 in ( Funcs (C71 , C76) ) & (ex B80 being Function st (C79 = B80 & ( B80 * C73 ) in ( dom C72 ))))) by L203;
thus L213: (C79 in ( dom C74 ) iff C79 in ( dom C75 )) by L212 , L206 , L210;
end;
L214: ( dom C74 ) = ( dom C75 ) by L211 , TARSKI:1;
assume L215: (for B81 being Function holds (B81 in ( dom C75 ) implies ( C75 . B81 ) = ( C72 . ( B81 * C73 ) )));
L216:
now
let C80 being set;
assume L217: C80 in ( dom C74 );
consider C81 being Function such that L218: C80 = C81 and L219: ( C81 * C73 ) in ( dom C72 ) by L217 , L203;
thus L220: ( C74 . C80 ) = ( C72 . ( C81 * C73 ) ) by L204 , L217 , L218
.= ( C75 . C80 ) by L215 , L214 , L217 , L218;
end;
thus L221: thesis by L216 , L214 , FUNCT_1:2;
end;
existence
proof
defpred S1[ set , set ] means (ex B82 being Function st (B82 = $1 & $2 = ( C72 . ( B82 * C73 ) )));
defpred S2[ set ] means (ex B83 being Function st (B83 = $1 & ( B83 * C73 ) in ( dom C72 )));
defpred S3[ set , set ] means (ex B84 being Function st ($1 = B84 & $2 = ( rng B84 )));
L222: (for B85 , B86 , B87 being set holds ((S3[ B85 , B86 ] & S3[ B85 , B87 ]) implies B86 = B87));
consider C82 being set such that L223: (for B88 being set holds (B88 in C82 iff (ex B89 being set st (B89 in ( dom C72 ) & S3[ B89 , B88 ])))) from TARSKI:sch 1(L222);
set D7 = ( union C82 );
consider C83 being set such that L224: (for B90 being set holds (B90 in C83 iff (B90 in ( Funcs (C71 , D7) ) & S2[ B90 ]))) from XBOOLE_0:sch 1;
L225: (for B91 being set holds (B91 in C83 implies (ex B92 being set st S1[ B91 , B92 ])))
proof
let C84 being set;
assume L226: C84 in C83;
consider C85 being Function such that L227: C85 = C84 and L228: ( C85 * C73 ) in ( dom C72 ) by L226 , L224;
take ( C72 . ( C85 * C73 ) );
thus L229: thesis by L227;
end;
consider C86 being Function such that L230: (( dom C86 ) = C83 & (for B93 being set holds (B93 in C83 implies S1[ B93 , ( C86 . B93 ) ]))) from CLASSES1:sch 1(L225);
take C86;
thus L231:now
take D8 = D7;
thus L232:now
let C87 being set;
thus L233:now
assume L234: C87 in D8;
consider C88 being set such that L235: C87 in C88 and L236: C88 in C82 by L234 , TARSKI:def 4;
L237: (ex B94 being set st (B94 in ( dom C72 ) & S3[ B94 , C88 ])) by L223 , L236;
thus L238: (ex B95 being Function st (B95 in ( dom C72 ) & C87 in ( rng B95 ))) by L237 , L235;
end;
given C89 being Function such that
L239: C89 in ( dom C72 )
and
L240: C87 in ( rng C89 );

L241: ( rng C89 ) in C82 by L223 , L239;
thus L242: C87 in D8 by L241 , L240 , TARSKI:def 4;
end;
let C90 being set;
thus L243: (C90 in ( dom C86 ) iff (C90 in ( Funcs (C71 , D8) ) & (ex B96 being Function st (C90 = B96 & ( B96 * C73 ) in ( dom C72 ))))) by L224 , L230;
end;
let C91 being Function;
assume L244: C91 in ( dom C86 );
L245: S1[ C91 , ( C86 . C91 ) ] by L244 , L230;
thus L246: thesis by L245;
end;
end;
definition
let C92 , C93 , C94 , C95 being non  empty set;
let C96 being (Element of ( Funcs (( Funcs (C92 , C93) ) , C94) ));
let C97 being (Function of C92 , C95);
redefine func C96 ** (C97 , C95) -> (Element of ( Funcs (( Funcs (C95 , C93) ) , C94) ));

coherence
proof
consider C98 being set such that L248: (for B97 being set holds (B97 in C98 iff (ex B98 being Function st (B98 in ( dom C96 ) & B97 in ( rng B98 ))))) and L249: (for B99 being set holds (B99 in ( dom ( C96 ** (C97 , C95) ) ) iff (B99 in ( Funcs (C95 , C98) ) & (ex B100 being Function st (B99 = B100 & ( B100 * C97 ) in ( dom C96 )))))) by L201;
L250: ( dom C96 ) = ( Funcs (C92 , C93) ) by FUNCT_2:def 1;
L251: C98 = C93
proof
thus L252: C98 c= C93
proof
let C99 being set;
assume L253: C99 in C98;
consider C100 being Function such that L254: C100 in ( dom C96 ) and L255: C99 in ( rng C100 ) by L253 , L248;
L256: ( rng C100 ) c= C93 by L254 , FUNCT_2:92;
thus L257: thesis by L256 , L255;
end;

let C101 being set;
assume L258: C101 in C93;
reconsider D9 = C101 as (Element of C93) by L258;
reconsider D10 = ( C92 --> D9 ) as (Function of C92 , C93);
L259: ( rng D10 ) = { D9 } by FUNCOP_1:8;
L260: D10 in ( Funcs (C92 , C93) ) by FUNCT_2:8;
L261: D9 in { D9 } by TARSKI:def 1;
thus L262: thesis by L261 , L250 , L248 , L259 , L260;
end;
L263: ( dom ( C96 ** (C97 , C95) ) ) = ( Funcs (C95 , C93) )
proof
thus L264: ( dom ( C96 ** (C97 , C95) ) ) c= ( Funcs (C95 , C93) )
proof
let C102 being set;
thus L265: thesis by L249 , L251;
end;

let C103 being set;
assume L266: C103 in ( Funcs (C95 , C93) );
reconsider D11 = C103 as (Function of C95 , C93) by L266 , FUNCT_2:66;
L267: ( D11 * C97 ) in ( Funcs (C92 , C93) ) by FUNCT_2:8;
thus L268: thesis by L267 , L250 , L249 , L251 , L266;
end;
L269: ( rng ( C96 ** (C97 , C95) ) ) c= C94
proof
let C104 being set;
assume L270: C104 in ( rng ( C96 ** (C97 , C95) ) );
consider C105 being set such that L271: C105 in ( dom ( C96 ** (C97 , C95) ) ) and L272: C104 = ( ( C96 ** (C97 , C95) ) . C105 ) by L270 , FUNCT_1:def 3;
reconsider D12 = C105 as (Element of ( Funcs (C95 , C93) )) by L263 , L271;
reconsider D13 = ( D12 * C97 ) as (Element of ( Funcs (C92 , C93) )) by FUNCT_2:8;
L273: C104 = ( C96 . D13 ) by L271 , L272 , L201;
thus L274: thesis by L273;
end;
thus L275: thesis by L269 , L263 , FUNCT_2:def 2;
end;
end;
theorem
L277: (for B101 , B102 , B103 being Function holds (( rng B103 ) c= ( dom B102 ) implies ( ( B101 +* B102 ) * B103 ) = ( B102 * B103 )))
proof
let C106 , C107 , C108 being Function;
assume L278: ( rng C108 ) c= ( dom C107 );
L279:
now
let C109 being set;
assume L280: C109 in ( dom C108 );
L281: ( ( C107 * C108 ) . C109 ) = ( C107 . ( C108 . C109 ) ) by L280 , FUNCT_1:13;
L282: ( C108 . C109 ) in ( rng C108 ) by L280 , FUNCT_1:3;
L283: ( ( ( C106 +* C107 ) * C108 ) . C109 ) = ( ( C106 +* C107 ) . ( C108 . C109 ) ) by L280 , FUNCT_1:13;
thus L284: ( ( ( C106 +* C107 ) * C108 ) . C109 ) = ( ( C107 * C108 ) . C109 ) by L283 , L278 , L281 , L282 , FUNCT_4:13;
end;
L285: ( dom ( C106 +* C107 ) ) = ( ( dom C106 ) \/ ( dom C107 ) ) by FUNCT_4:def 1;
L286: ( dom ( ( C106 +* C107 ) * C108 ) ) = ( dom C108 ) by L285 , L278 , RELAT_1:27 , XBOOLE_1:10;
L287: ( dom ( C107 * C108 ) ) = ( dom C108 ) by L278 , RELAT_1:27;
thus L288: thesis by L287 , L286 , L279 , FUNCT_1:2;
end;
theorem
L289: (for B104 , B105 , B106 being non  empty set holds (for B107 being (Function of B104 , B106) holds (for B108 being (Function of B104 , B105) holds (B108 is  one-to-one implies (for B109 being (Element of B106) holds ( ( B105 --> B109 ) +* ( B107 * ( B108 " ) ) ) is (Function of B105 , B106))))))
proof
let C110 , C111 , C112 being non  empty set;
let C113 being (Function of C110 , C112);
let C114 being (Function of C110 , C111);
assume L290: C114 is  one-to-one;
L291: ( dom ( C114 " ) ) = ( rng C114 ) by L290 , FUNCT_1:33;
let C115 being (Element of C112);
set D14 = ( C111 --> C115 );
set D15 = ( C113 * ( C114 " ) );
L292: ( dom D15 ) c= ( dom ( C114 " ) ) by RELAT_1:25;
L293: ( rng D15 ) c= ( rng C113 ) by RELAT_1:26;
L294: ( rng D15 ) c= C112 by L293 , XBOOLE_1:1;
L295: ( ( rng D14 ) \/ ( rng D15 ) ) c= C112 by L294 , XBOOLE_1:8;
L296: ( dom D14 ) = C111 by FUNCOP_1:13;
L297: ( rng ( D14 +* D15 ) ) c= ( ( rng D14 ) \/ ( rng D15 ) ) by FUNCT_4:17;
L298: ( dom ( D14 +* D15 ) ) = ( ( dom D14 ) \/ ( dom D15 ) ) by FUNCT_4:def 1;
L299: ( dom ( D14 +* D15 ) ) = C111 by L298 , L292 , L296 , L291 , XBOOLE_1:1 , XBOOLE_1:12;
thus L300: thesis by L299 , L297 , L295 , FUNCT_2:2 , XBOOLE_1:1;
end;
theorem
L301: (for B110 , B111 , B112 being non  empty set holds (for B113 , B114 being Function holds ((( dom B113 ) = ( dom B114 ) & ( dom B113 ) = ( Funcs (B111 , B112) )) implies (for B115 being (Function of B111 , B110) holds ((B115 is  one-to-one & ( B113 ** (B115 , B110) ) = ( B114 ** (B115 , B110) )) implies B113 = B114)))))
proof
let C116 , C117 , C118 being non  empty set;
let C119 , C120 being Function;
assume that
L302: ( dom C119 ) = ( dom C120 )
and
L303: ( dom C119 ) = ( Funcs (C117 , C118) );
reconsider D16 = ( rng C119 ) , D17 = ( rng C120 ) as non  empty set by L302 , L303 , RELAT_1:42;
reconsider D18 = ( D16 \/ D17 ) as non  empty set;
L304: ( rng C120 ) c= D18 by XBOOLE_1:7;
L305: ( rng C119 ) c= D18 by XBOOLE_1:7;
reconsider D19 = C119 , D20 = C120 as (Element of ( Funcs (( Funcs (C117 , C118) ) , D18) )) by L305 , L302 , L303 , L304 , FUNCT_2:def 2;
let C121 being (Function of C117 , C116);
assume that
L306: C121 is  one-to-one
and
L307: ( C119 ** (C121 , C116) ) = ( C120 ** (C121 , C116) );
L308: ( dom ( D20 ** (C121 , C116) ) ) = ( Funcs (C116 , C118) ) by FUNCT_2:def 1;
L309: ( dom ( D19 ** (C121 , C116) ) ) = ( Funcs (C116 , C118) ) by FUNCT_2:def 1;
L310:
now
set D21 = the (Element of C118);
let C122 being set;
L311: ( dom C121 ) = C117 by FUNCT_2:def 1;
assume L312: C122 in ( Funcs (C117 , C118) );
reconsider D22 = C122 as (Element of ( Funcs (C117 , C118) )) by L312;
set D23 = ( ( C116 --> D21 ) +* ( D22 * ( C121 " ) ) );
L313: ( dom D22 ) = C117 by FUNCT_2:def 1;
L314: ( rng ( C121 " ) ) = ( dom C121 ) by L306 , FUNCT_1:33;
L315: ( dom ( D22 * ( C121 " ) ) ) = ( dom ( C121 " ) ) by L314 , L313 , RELAT_1:27
.= ( rng C121 ) by L306 , FUNCT_1:33;
L316: ( D23 * C121 ) = ( ( D22 * ( C121 " ) ) * C121 ) by L315 , L277
.= ( D22 * ( ( C121 " ) * C121 ) ) by RELAT_1:36
.= ( D22 * ( id C117 ) ) by L306 , L311 , FUNCT_1:39
.= C122 by L313 , RELAT_1:52;
L317: D23 is (Function of C116 , C118) by L306 , L289;
L318: D23 in ( Funcs (C116 , C118) ) by L317 , FUNCT_2:8;
L319: ( ( C119 ** (C121 , C116) ) . D23 ) = ( C119 . C122 ) by L318 , L309 , L316 , L201;
thus L320: ( C119 . C122 ) = ( C120 . C122 ) by L319 , L307 , L308 , L318 , L316 , L201;
end;
thus L321: thesis by L310 , L302 , L303 , FUNCT_1:2;
end;
registration
let C123 being set;
cluster  one-to-one  onto for (Function of C123 , ( card C123 ));
existence
proof
L322: C123 , ( card C123 ) are_equipotent  by CARD_1:def 2;
consider C124 being Function such that L323: C124 is  one-to-one and L324: ( dom C124 ) = C123 and L325: ( rng C124 ) = ( card C123 ) by L322 , WELLORD2:def 4;
reconsider D24 = C124 as (Function of C123 , ( card C123 )) by L324 , L325 , FUNCT_2:2;
take D24;
thus L326: D24 is  one-to-one by L323;
thus L327: ( rng D24 ) = ( card C123 ) by L325;
end;
cluster  one-to-one  onto for (Function of ( card C123 ) , C123);
existence
proof
L328: C123 , ( card C123 ) are_equipotent  by CARD_1:def 2;
consider C125 being Function such that L329: C125 is  one-to-one and L330: ( dom C125 ) = ( card C123 ) and L331: ( rng C125 ) = C123 by L328 , WELLORD2:def 4;
reconsider D25 = C125 as (Function of ( card C123 ) , C123) by L330 , L331 , FUNCT_2:2;
take D25;
thus L332: D25 is  one-to-one by L329;
thus L333: ( rng D25 ) = C123 by L331;
end;
end;
definition
let C126 being set;
mode Enumeration of C126
 is  one-to-one  onto (Function of C126 , ( card C126 ));
mode Denumeration of C126
 is  one-to-one  onto (Function of ( card C126 ) , C126);
end;
theorem
L336: (for B116 being set holds (for B117 being Function holds (B117 is (Enumeration of B116) iff (( dom B117 ) = B116 & ( rng B117 ) = ( card B116 ) & B117 is  one-to-one))))
proof
let C127 being set;
let C128 being Function;
L337: (( card C127 ) = ( {} ) implies C127 = ( {} ));
thus L338: thesis by L337 , FUNCT_2:2 , FUNCT_2:def 1 , FUNCT_2:def 3;
end;
theorem
L339: (for B118 being set holds (for B119 being Function holds (B119 is (Denumeration of B118) iff (( dom B119 ) = ( card B118 ) & ( rng B119 ) = B118 & B119 is  one-to-one))))
proof
let C129 being set;
let C130 being Function;
L340: (C129 = ( {} ) implies ( card C129 ) = ( {} ));
thus L341: thesis by L340 , FUNCT_2:2 , FUNCT_2:def 1 , FUNCT_2:def 3;
end;
theorem
L342: (for B120 being non  empty set holds (for B121 , B122 being (Element of B120) holds (for B123 being (Enumeration of B120) holds ( ( B123 +* (B121 , ( B123 . B122 )) ) +* (B122 , ( B123 . B121 )) ) is (Enumeration of B120))))
proof
let C131 being non  empty set;
let C132 , C133 being (Element of C131);
let C134 being (Enumeration of C131);
set D26 = ( ( C134 +* (C132 , ( C134 . C133 )) ) +* (C133 , ( C134 . C132 )) );
set D27 = ( dom D26 );
L343: ( dom ( C134 +* (C132 , ( C134 . C133 )) ) ) = ( dom C134 ) by FUNCT_7:30;
L344: D27 = ( dom ( C134 +* (C132 , ( C134 . C133 )) ) ) by FUNCT_7:30;
L345: ( dom C134 ) = C131 by L336;
L346: ( rng C134 ) = ( card C131 ) by L336;
L347: ( rng ( ( C134 +* (C132 , ( C134 . C133 )) ) +* (C133 , ( C134 . C132 )) ) ) = ( rng C134 )
proof
L348: { ( C134 . C132 ) } c= ( rng C134 ) by L346 , ZFMISC_1:31;
L349: ( ( rng C134 ) \/ { ( C134 . C132 ) } ) = ( rng C134 ) by L348 , XBOOLE_1:12;
L350: ( rng D26 ) c= ( ( rng ( C134 +* (C132 , ( C134 . C133 )) ) ) \/ { ( C134 . C132 ) } ) by FUNCT_7:100;
L351: { ( C134 . C133 ) } c= ( rng C134 ) by L346 , ZFMISC_1:31;
L352: ( ( rng C134 ) \/ { ( C134 . C133 ) } ) = ( rng C134 ) by L351 , XBOOLE_1:12;
L353: ( ( rng ( C134 +* (C132 , ( C134 . C133 )) ) ) \/ { ( C134 . C132 ) } ) c= ( rng C134 ) by L352 , L349 , FUNCT_7:100 , XBOOLE_1:9;
thus L354: ( rng D26 ) c= ( rng C134 ) by L353 , L350 , XBOOLE_1:1;
let C135 being set;
assume L355: C135 in ( rng C134 );
consider C136 being set such that L356: C136 in ( dom C134 ) and L357: C135 = ( C134 . C136 ) by L355 , FUNCT_1:def 3;
per cases ;
suppose L358: (C136 <> C132 & C136 <> C133);

L359: ( D26 . C136 ) = ( ( C134 +* (C132 , ( C134 . C133 )) ) . C136 ) by L358 , FUNCT_7:32;
L360: ( ( C134 +* (C132 , ( C134 . C133 )) ) . C136 ) = C135 by L357 , L358 , FUNCT_7:32;
thus L361: thesis by L360 , L343 , L344 , L356 , L359 , FUNCT_1:def 3;
end;
suppose L362: C136 = C132;

L363: ( D26 . C133 ) = C135 by L362 , L343 , L345 , L357 , FUNCT_7:31;
thus L364: thesis by L363 , L343 , L344 , L345 , FUNCT_1:def 3;
end;
suppose L365: C136 = C133;

L366: (C132 <> C133 implies ( D26 . C132 ) = ( ( C134 +* (C132 , C135) ) . C132 )) by L365 , L357 , FUNCT_7:32;
L367: ( ( C134 +* (C132 , C135) ) . C132 ) = C135 by L345 , FUNCT_7:31;
L368: (C132 = C133 implies ( D26 . C132 ) = C135) by L343 , L345 , L357 , L365 , FUNCT_7:31;
thus L369: thesis by L368 , L343 , L344 , L345 , L367 , L366 , FUNCT_1:def 3;
end;
end;
L371: ( ( C134 +* (C132 , ( C134 . C133 )) ) +* (C133 , ( C134 . C132 )) ) is  one-to-one
proof
let C137 , C138 being set;
L372: (C137 <> C133 implies ( D26 . C137 ) = ( ( C134 +* (C132 , ( C134 . C133 )) ) . C137 )) by FUNCT_7:32;
L373: (C137 <> C132 implies ( ( C134 +* (C132 , ( C134 . C133 )) ) . C137 ) = ( C134 . C137 )) by FUNCT_7:32;
L374: (C138 = C133 implies ( D26 . C138 ) = ( C134 . C132 )) by L343 , L345 , FUNCT_7:31;
L375: (C138 <> C133 implies ( D26 . C138 ) = ( ( C134 +* (C132 , ( C134 . C133 )) ) . C138 )) by FUNCT_7:32;
L376: (C138 = C132 implies ( ( C134 +* (C132 , ( C134 . C133 )) ) . C138 ) = ( C134 . C133 )) by L345 , FUNCT_7:31;
L377: (C137 = C132 implies ( ( C134 +* (C132 , ( C134 . C133 )) ) . C137 ) = ( C134 . C133 )) by L345 , FUNCT_7:31;
L378: (C138 <> C132 implies ( ( C134 +* (C132 , ( C134 . C133 )) ) . C138 ) = ( C134 . C138 )) by FUNCT_7:32;
L379: (C137 = C133 implies ( D26 . C137 ) = ( C134 . C132 )) by L343 , L345 , FUNCT_7:31;
thus L380: thesis by L379 , L344 , L345 , L372 , L377 , L373 , L374 , L375 , L376 , L378 , FUNCT_1:def 4;
end;
thus L381: thesis by L371 , L343 , L344 , L345 , L346 , L347 , L336;
end;
theorem
L382: (for B124 being non  empty set holds (for B125 being (Element of B124) holds (ex B126 being (Enumeration of B124) st ( B126 . B125 ) = ( 0 ))))
proof
let C139 being non  empty set;
let C140 being (Element of C139);
set D28 = the (Enumeration of C139);
L383: ( 0 ) in ( card C139 ) by ORDINAL3:8;
L384: ( rng D28 ) = ( card C139 ) by L336;
L385: ( dom D28 ) = C139 by L336;
consider C141 being set such that L386: C141 in C139 and L387: ( 0 ) = ( D28 . C141 ) by L385 , L383 , L384 , FUNCT_1:def 3;
reconsider D29 = C141 as (Element of C139) by L386;
reconsider D30 = ( ( D28 +* (D29 , ( D28 . C140 )) ) +* (C140 , ( 0 )) ) as (Enumeration of C139) by L387 , L342;
take D30;
L388: ( dom D28 ) = C139 by L336;
L389: ( dom ( D28 +* (D29 , ( D28 . C140 )) ) ) = C139 by L388 , FUNCT_7:30;
thus L390: thesis by L389 , FUNCT_7:31;
end;
theorem
L391: (for B127 being non  empty set holds (for B128 being (Denumeration of B127) holds ( B128 . ( 0 ) ) in B127)) by FUNCT_2:5 , ORDINAL3:8;
theorem
L392: (for B129 being  countable set holds (for B130 being (Enumeration of B129) holds ( rng B130 ) c= ( NAT )))
proof
let C142 being  countable set;
let C143 being (Enumeration of C142);
L393: ( card C142 ) c= ( NAT ) by CARD_3:def 14;
thus L394: thesis by L393 , L336;
end;
definition
let C144 being set;
let C145 being (Enumeration of C144);
redefine func C145 " -> (Denumeration of C144);

coherence
proof
L395: ( rng C145 ) = ( card C144 ) by L336;
L396: ( dom ( C145 " ) ) = ( card C144 ) by L395 , FUNCT_1:33;
L397: ( dom C145 ) = C144 by L336;
L398: ( rng ( C145 " ) ) = C144 by L397 , FUNCT_1:33;
thus L399: thesis by L398 , L396 , L339;
end;
end;
definition
let C146 being set;
let C147 being (Denumeration of C146);
redefine func C147 " -> (Enumeration of C146);

coherence
proof
L401: ( rng C147 ) = C146 by L339;
L402: ( dom ( C147 " ) ) = C146 by L401 , FUNCT_1:33;
L403: ( dom C147 ) = ( card C146 ) by L339;
L404: ( rng ( C147 " ) ) = ( card C146 ) by L403 , FUNCT_1:33;
thus L405: thesis by L404 , L402 , L336;
end;
end;
theorem
L407: (for B131 , B132 being Nat holds ( ( 0 ) to_power ( B131 + B132 ) ) = ( ( ( 0 ) to_power B131 ) * ( ( 0 ) to_power B132 ) ))
proof
let C148 , C149 being Nat;
per cases ;
suppose L408: (C148 > ( 0 ) or C149 > ( 0 ));

L409: (( ( 0 ) to_power C148 ) = ( 0 ) or ( ( 0 ) to_power C149 ) = ( 0 )) by L408 , POWER:def 2;
thus L410: thesis by L409 , L408 , POWER:def 2;
end;
suppose L411: (C148 = ( 0 ) & C149 = ( 0 ));

L412: ( ( 0 ) to_power ( C148 + C149 ) ) = 1 by L411 , POWER:24;
thus L413: thesis by L412 , L411;
end;
end;
theorem
L415: (for B133 being  real number holds (for B134 , B135 being Nat holds ( ( B133 to_power B134 ) to_power B135 ) = ( B133 to_power ( B134 * B135 ) ))) by NEWTON:9;
begin
definition
let C150 being non  empty set;
mode INT-Variable of C150
 is (Function of ( Funcs (C150 , ( INT )) ) , C150);
mode INT-Expression of C150
 is (Function of ( Funcs (C150 , ( INT )) ) , ( INT ));
mode INT-Array of C150
 is (Function of ( INT ) , C150);
end;
definition
let R1 being preIfWhileAlgebra;
let C151 being (Element of R1);
let C152 being non  empty set;
let C153 being (Subset of ( Funcs (C152 , ( INT )) ));
let C154 being (ExecutionFunction of R1 , ( Funcs (C152 , ( INT )) ) , C153);
pred C151 is_assignment_wrt R1 , C152 , C154
means
:L417: (C151 in ( ElementaryInstructions R1 ) & (ex B136 being (INT-Variable of C152) st (ex B137 being (INT-Expression of C152) st (for B138 being (Element of ( Funcs (C152 , ( INT )) )) holds ( C154 . (B138 , C151) ) = ( B138 +* (( B136 . B138 ) , ( B137 . B138 )) )))))
;end;
definition
let R1 being preIfWhileAlgebra;
let C155 being non  empty set;
let C156 being (Subset of ( Funcs (C155 , ( INT )) ));
let C157 being (ExecutionFunction of R1 , ( Funcs (C155 , ( INT )) ) , C156);
let C158 being (INT-Variable of C155);
let C159 being (INT-Expression of C155);
pred C158 , C159 form_assignment_wrt C157
means
:L419: (ex B139 being (Element of R1) st (B139 in ( ElementaryInstructions R1 ) & (for B140 being (Element of ( Funcs (C155 , ( INT )) )) holds ( C157 . (B140 , B139) ) = ( B140 +* (( C158 . B140 ) , ( C159 . B140 )) ))))
;end;
definition
let R1 being preIfWhileAlgebra;
let C160 being non  empty set;
let C161 being (Subset of ( Funcs (C160 , ( INT )) ));
let C162 being (ExecutionFunction of R1 , ( Funcs (C160 , ( INT )) ) , C161);
assume that
L421: (ex B141 being (Element of R1) st B141 is_assignment_wrt R1 , C160 , C162);
mode INT-Variable of R1 , C162
 -> (INT-Variable of C160)
means (ex B142 being (INT-Expression of C160) st it , B142 form_assignment_wrt C162);
existence
proof
consider C163 being (Element of R1) such that L422: C163 is_assignment_wrt R1 , C160 , C162 by L421;
consider C164 being (INT-Variable of C160), C165 being (INT-Expression of C160) such that L423: (for B143 being (Element of ( Funcs (C160 , ( INT )) )) holds ( C162 . (B143 , C163) ) = ( B143 +* (( C164 . B143 ) , ( C165 . B143 )) )) by L422 , L417;
take C164;
take C165;
take C163;
thus L424: thesis by L422 , L423 , L417;
end;
end;
definition
let R1 being preIfWhileAlgebra;
let C166 being non  empty set;
let C167 being (Subset of ( Funcs (C166 , ( INT )) ));
let C168 being (ExecutionFunction of R1 , ( Funcs (C166 , ( INT )) ) , C167);
assume that
L426: (ex B144 being (Element of R1) st B144 is_assignment_wrt R1 , C166 , C168);
mode INT-Expression of R1 , C168
 -> (INT-Expression of C166)
means (ex B145 being (INT-Variable of C166) st B145 , it form_assignment_wrt C168);
existence
proof
consider C169 being (Element of R1) such that L427: C169 is_assignment_wrt R1 , C166 , C168 by L426;
consider C170 being (INT-Variable of C166), C171 being (INT-Expression of C166) such that L428: (for B146 being (Element of ( Funcs (C166 , ( INT )) )) holds ( C168 . (B146 , C169) ) = ( B146 +* (( C170 . B146 ) , ( C171 . B146 )) )) by L427 , L417;
take C171;
take C170;
take C169;
thus L429: thesis by L427 , L428 , L417;
end;
end;
definition
let C172 , C173 being non  empty set;
let C174 being (Element of ( Funcs (C172 , C173) ));
let C175 being (Element of C172);
redefine func C174 . C175 -> (Element of C173);

coherence
proof
L431: ( C174 . C175 ) in ( rng C174 ) by FUNCT_2:4;
thus L432: thesis by L431;
end;
end;
definition
let C176 being non  empty set;
let C177 being (Element of C176);
func . C177 -> (INT-Expression of C176) means 
:L434: (for B147 being (Element of ( Funcs (C176 , ( INT )) )) holds ( it . B147 ) = ( B147 . C177 ));
correctness
proof
deffunc H6((Element of ( Funcs (C176 , ( INT )) ))) = ( $1 . C177 );
thus L435: (ex B148 being (Function of ( Funcs (C176 , ( INT )) ) , ( INT )) st (for B149 being (Element of ( Funcs (C176 , ( INT )) )) holds ( B148 . B149 ) = H6(B149))) from FUNCT_2:sch 4;
let C178 , C179 being (INT-Expression of C176);
assume that
L436: (for B150 being (Element of ( Funcs (C176 , ( INT )) )) holds ( C178 . B150 ) = ( B150 . C177 ))
and
L437: (for B151 being (Element of ( Funcs (C176 , ( INT )) )) holds ( C179 . B151 ) = ( B151 . C177 ));
L438:
now
let C180 being (Element of ( Funcs (C176 , ( INT )) ));
thus L439: ( C178 . C180 ) = ( C180 . C177 ) by L436
.= ( C179 . C180 ) by L437;
end;
thus L440: thesis by L438 , FUNCT_2:63;
end;
end;
definition
let C181 being non  empty set;
let C182 being (INT-Variable of C181);
func . C182 -> (INT-Expression of C181) means 
:L442: (for B152 being (Element of ( Funcs (C181 , ( INT )) )) holds ( it . B152 ) = ( B152 . ( C182 . B152 ) ));
correctness
proof
deffunc H7((Element of ( Funcs (C181 , ( INT )) ))) = ( $1 . ( C182 . $1 ) );
thus L443: (ex B153 being (Function of ( Funcs (C181 , ( INT )) ) , ( INT )) st (for B154 being (Element of ( Funcs (C181 , ( INT )) )) holds ( B153 . B154 ) = H7(B154))) from FUNCT_2:sch 4;
let C183 , C184 being (INT-Expression of C181);
assume that
L444: (for B155 being (Element of ( Funcs (C181 , ( INT )) )) holds ( C183 . B155 ) = ( B155 . ( C182 . B155 ) ))
and
L445: (for B156 being (Element of ( Funcs (C181 , ( INT )) )) holds ( C184 . B156 ) = ( B156 . ( C182 . B156 ) ));
L446:
now
let C185 being (Element of ( Funcs (C181 , ( INT )) ));
thus L447: ( C183 . C185 ) = ( C185 . ( C182 . C185 ) ) by L444
.= ( C184 . C185 ) by L445;
end;
thus L448: thesis by L446 , FUNCT_2:63;
end;
end;
definition
let C186 being non  empty set;
let C187 being (Element of C186);
func ^ C187 -> (INT-Variable of C186) equals 
( ( Funcs (C186 , ( INT )) ) --> C187 );
correctness;
end;
theorem
L451: (for B157 being non  empty set holds (for B158 being (Element of B157) holds ( . B158 ) = ( . ( ^ B158 ) )))
proof
let C188 being non  empty set;
let C189 being (Element of C188);
L452: (for B159 being (Element of ( Funcs (C188 , ( INT )) )) holds ( ( . ( ^ C189 ) ) . B159 ) = ( B159 . C189 ))
proof
let C190 being (Element of ( Funcs (C188 , ( INT )) ));
thus L453: ( ( . ( ^ C189 ) ) . C190 ) = ( C190 . ( ( ^ C189 ) . C190 ) ) by L442
.= ( C190 . C189 ) by FUNCOP_1:7;
end;
thus L454: thesis by L452 , L434;
end;
definition
let C191 being non  empty set;
let C192 being  integer number;
func . (C192 , C191) -> (INT-Expression of C191) equals 
( ( Funcs (C191 , ( INT )) ) --> C192 );
correctness
proof
L455: C192 in ( INT ) by INT_1:def 2;
thus L456: thesis by L455 , FUNCOP_1:45;
end;
end;
theorem
L458: (for B160 being non  empty set holds (for B161 being (INT-Expression of B160) holds (( B161 + ( . (( 0 ) , B160) ) ) = B161 & ( B161 (#) ( . (1 , B160) ) ) = B161)))
proof
let C193 being non  empty set;
let C194 being (INT-Expression of C193);
L459:
now
let C195 being (Element of ( Funcs (C193 , ( INT )) ));
L460: ( ( . (( 0 ) , C193) ) . C195 ) = ( 0 ) by FUNCOP_1:7;
L461: ( dom ( C194 + ( . (( 0 ) , C193) ) ) ) = ( Funcs (C193 , ( INT )) ) by FUNCT_2:def 1;
thus L462: ( ( C194 + ( . (( 0 ) , C193) ) ) . C195 ) = ( ( C194 . C195 ) + ( ( . (( 0 ) , C193) ) . C195 ) ) by L461 , VALUED_1:def 1
.= ( C194 . C195 ) by L460;
end;
thus L463: ( C194 + ( . (( 0 ) , C193) ) ) = C194 by L459 , FUNCT_2:63;
L464:
now
let C196 being (Element of ( Funcs (C193 , ( INT )) ));
L465: ( dom ( C194 (#) ( . (1 , C193) ) ) ) = ( Funcs (C193 , ( INT )) ) by FUNCT_2:def 1;
thus L466: ( ( C194 (#) ( . (1 , C193) ) ) . C196 ) = ( ( C194 . C196 ) * ( ( . (1 , C193) ) . C196 ) ) by L465 , VALUED_1:def 4
.= ( ( C194 . C196 ) * 1 ) by FUNCOP_1:7
.= ( C194 . C196 );
end;
thus L467: thesis by L464 , FUNCT_2:63;
end;
definition
let R1 being preIfWhileAlgebra;
let C197 being non  empty set;
let C198 being (Subset of ( Funcs (C197 , ( INT )) ));
let C199 being (ExecutionFunction of R1 , ( Funcs (C197 , ( INT )) ) , C198);
attr C199 is  Euclidean
means
:L468: ((for B162 being (INT-Variable of R1 , C199) holds (for B163 being (INT-Expression of R1 , C199) holds B162 , B163 form_assignment_wrt C199)) & (for B164 being  integer number holds ( . (B164 , C197) ) is (INT-Expression of R1 , C199)) & (for B165 being (INT-Variable of R1 , C199) holds ( . B165 ) is (INT-Expression of R1 , C199)) & (for B166 being (Element of C197) holds ( ^ B166 ) is (INT-Variable of R1 , C199)) & (ex B167 being (INT-Array of C197) st (( B167 | ( card C197 ) ) is  one-to-one & (for B168 being (INT-Expression of R1 , C199) holds ( B167 * B168 ) is (INT-Variable of R1 , C199)))) & (for B169 being (INT-Expression of R1 , C199) holds ( - B169 ) is (INT-Expression of R1 , C199)) & (for B170 , B171 being (INT-Expression of R1 , C199) holds (( B170 (#) B171 ) is (INT-Expression of R1 , C199) & ( B170 + B171 ) is (INT-Expression of R1 , C199) & ( B170 div B171 ) is (INT-Expression of R1 , C199) & ( B170 mod B171 ) is (INT-Expression of R1 , C199) & ( leq (B170 , B171) ) is (INT-Expression of R1 , C199) & ( gt (B170 , B171) ) is (INT-Expression of R1 , C199))));
end;
definition
let R1 being preIfWhileAlgebra;
attr R1 is  Euclidean
means
:L470: (for B172 being non  empty  countable set holds (for B173 being (Subset of ( Funcs (B172 , ( INT )) )) holds (ex B174 being (ExecutionFunction of R1 , ( Funcs (B172 , ( INT )) ) , B173) st B174 is  Euclidean)));
end;
definition
func INT-ElemIns ->  infinite  disjoint_with_NAT set equals 
[: ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( NAT )) ) , ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( INT )) ) :];
coherence;
end;
definition
mode INT-Exec
 -> (ExecutionFunction of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) , ( Funcs (( NAT ) , ( INT )) ) , ( ( Funcs (( NAT ) , ( INT )) ) \ (( 0 ) , ( 0 )) ))
means :L473: (for B175 being (Element of ( Funcs (( NAT ) , ( INT )) )) holds (for B176 being (Element of ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( NAT )) )) holds (for B177 being (Element of ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( INT )) )) holds ( it . (B175 , ( root-tree [ B176 , B177 ] )) ) = ( B175 +* (( B176 . B175 ) , ( B177 . B175 )) ))));
existence
proof
reconsider D31 = ( 0 ) as (Element of ( INT )) by INT_1:def 1;
set D32 = ( Funcs (( NAT ) , ( INT )) );
set D33 = ( D32 \ (( 0 ) , ( 0 )) );
set D34 = ( ECIW-signature );
set D35 = ( INT-ElemIns );
set D36 = ( FreeUnivAlgNSG (D34 , D35) );
L474: ( Terminals ( DTConUA (D34 , D35) ) ) = D35 by FREEALG:3;
reconsider D37 = ( ( NAT ) --> D31 ) as (Element of D32) by FUNCT_2:8;
defpred S4[ set , set ] means (ex B178 being (Element of D32) st (ex B179 being (Element of ( Funcs (D32 , ( NAT )) )) st (ex B180 being (Element of ( Funcs (D32 , ( INT )) )) st ($1 = [ B178 , ( root-tree [ B179 , B180 ] ) ] & $2 = ( B178 +* (( B179 . B178 ) , ( B180 . B178 )) )))));
L475: ( ElementaryInstructions D36 ) = ( FreeGenSetNSG (D34 , D35) ) by AOFA_000:70;
L476: (for B181 being set holds (B181 in [: D32 , ( ElementaryInstructions D36 ) :] implies (ex B182 being set st (B182 in D32 & S4[ B181 , B182 ]))))
proof
let C200 being set;
assume L477: C200 in [: D32 , ( ElementaryInstructions D36 ) :];
consider C201 , C202 being set such that L478: C201 in D32 and L479: C202 in ( ElementaryInstructions D36 ) and L480: C200 = [ C201 , C202 ] by L477 , ZFMISC_1:def 2;
reconsider D38 = C201 as (Element of D32) by L478;
consider C203 being (Symbol of ( DTConUA (D34 , D35) )) such that L481: C202 = ( root-tree C203 ) and L482: C203 in ( Terminals ( DTConUA (D34 , D35) ) ) by L475 , L479;
consider C204 , C205 being set such that L483: C204 in ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( NAT )) ) and L484: C205 in ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( INT )) ) and L485: C203 = [ C204 , C205 ] by L474 , L482 , ZFMISC_1:def 2;
reconsider D39 = C205 as (Element of ( Funcs (D32 , ( INT )) )) by L484;
reconsider D40 = C204 as (Element of ( Funcs (D32 , ( NAT )) )) by L483;
take D41 = ( D38 +* (( D40 . D38 ) , ( D39 . D38 )) );
thus L486: D41 in D32 by FUNCT_2:8;
take D38;
take D40;
take D39;
thus L487: (C200 = [ D38 , ( root-tree [ D40 , D39 ] ) ] & D41 = ( D38 +* (( D40 . D38 ) , ( D39 . D38 )) )) by L480 , L481 , L485;
end;
consider C206 being Function such that L488: (( dom C206 ) = [: D32 , ( ElementaryInstructions D36 ) :] & ( rng C206 ) c= D32) and L489: (for B183 being set holds (B183 in [: D32 , ( ElementaryInstructions D36 ) :] implies S4[ B183 , ( C206 . B183 ) ])) from FUNCT_1:sch 5(L476);
reconsider D42 = C206 as (Function of [: D32 , ( ElementaryInstructions D36 ) :] , D32) by L488 , FUNCT_2:2;
consider C207 being (ExecutionFunction of D36 , D32 , D33) such that L490: ( C207 | [: D32 , ( ElementaryInstructions D36 ) :] ) = D42 and L491: (for B184 being (Element of D32) holds (for B185 , B186 being (Element of D36) holds ((not C207 iteration_terminates_for ( B186 \; B185 ) , ( C207 . (B184 , B185) )) implies ( C207 . (B184 , ( while (B185 , B186) )) ) = D37))) by AOFA_000:91;
take C207;
let C208 being (Element of ( Funcs (( NAT ) , ( INT )) ));
let C209 being (Element of ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( NAT )) ));
let C210 being (Element of ( Funcs (( Funcs (( NAT ) , ( INT )) ) , ( INT )) ));
set D43 = ( root-tree [ C209 , C210 ] );
L492: [ C209 , C210 ] in D35 by ZFMISC_1:87;
L493: D43 in ( ElementaryInstructions D36 ) by L492 , L475 , L474;
L494: [ C208 , D43 ] in [: D32 , ( ElementaryInstructions D36 ) :] by L493 , ZFMISC_1:87;
consider C211 being (Element of D32), C212 being (Element of ( Funcs (D32 , ( NAT )) )), C213 being (Element of ( Funcs (D32 , ( INT )) )) such that L495: [ C208 , D43 ] = [ C211 , ( root-tree [ C212 , C213 ] ) ] and L496: ( D42 . [ C208 , D43 ] ) = ( C211 +* (( C212 . C211 ) , ( C213 . C211 )) ) by L494 , L489;
L497: D43 = ( root-tree [ C212 , C213 ] ) by L495 , XTUPLE_0:1;
L498: [ C209 , C210 ] = [ C212 , C213 ] by L497 , TREES_4:4;
L499: C209 = C212 by L498 , XTUPLE_0:1;
L500: C210 = C213 by L498 , XTUPLE_0:1;
L501: C208 = C211 by L495 , XTUPLE_0:1;
thus L502: thesis by L501 , L490 , L494 , L496 , L499 , L500 , FUNCT_1:49;
end;
end;
definition
let C214 being non  empty set;
func INT-ElemIns C214 ->  infinite  disjoint_with_NAT set equals 
[: ( Funcs (( Funcs (C214 , ( INT )) ) , C214) ) , ( Funcs (( Funcs (C214 , ( INT )) ) , ( INT )) ) :];
coherence;
end;
definition
let C215 being non  empty set;
let C216 being (Element of C215);
mode INT-Exec of C216
 -> (ExecutionFunction of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns C215 )) ) , ( Funcs (C215 , ( INT )) ) , ( ( Funcs (C215 , ( INT )) ) \ (C216 , ( 0 )) ))
means (for B187 being (Element of ( Funcs (C215 , ( INT )) )) holds (for B188 being (Element of ( Funcs (( Funcs (C215 , ( INT )) ) , C215) )) holds (for B189 being (Element of ( Funcs (( Funcs (C215 , ( INT )) ) , ( INT )) )) holds ( it . (B187 , ( root-tree [ B188 , B189 ] )) ) = ( B187 +* (( B188 . B187 ) , ( B189 . B187 )) ))));
existence
proof
reconsider D44 = ( 0 ) as (Element of ( INT )) by INT_1:def 1;
set D45 = ( Funcs (C215 , ( INT )) );
set D46 = ( D45 \ (C216 , ( 0 )) );
set D47 = ( ECIW-signature );
set D48 = ( INT-ElemIns C215 );
set D49 = ( FreeUnivAlgNSG (D47 , D48) );
L505: ( Terminals ( DTConUA (D47 , D48) ) ) = D48 by FREEALG:3;
reconsider D50 = ( C215 --> D44 ) as (Element of D45) by FUNCT_2:8;
defpred S5[ set , set ] means (ex B190 being (Element of D45) st (ex B191 being (Element of ( Funcs (D45 , C215) )) st (ex B192 being (Element of ( Funcs (D45 , ( INT )) )) st ($1 = [ B190 , ( root-tree [ B191 , B192 ] ) ] & $2 = ( B190 +* (( B191 . B190 ) , ( B192 . B190 )) )))));
L506: ( ElementaryInstructions D49 ) = ( FreeGenSetNSG (D47 , D48) ) by AOFA_000:70;
L507: (for B193 being set holds (B193 in [: D45 , ( ElementaryInstructions D49 ) :] implies (ex B194 being set st (B194 in D45 & S5[ B193 , B194 ]))))
proof
let C217 being set;
assume L508: C217 in [: D45 , ( ElementaryInstructions D49 ) :];
consider C218 , C219 being set such that L509: C218 in D45 and L510: C219 in ( ElementaryInstructions D49 ) and L511: C217 = [ C218 , C219 ] by L508 , ZFMISC_1:def 2;
reconsider D51 = C218 as (Element of D45) by L509;
consider C220 being (Symbol of ( DTConUA (D47 , D48) )) such that L512: C219 = ( root-tree C220 ) and L513: C220 in ( Terminals ( DTConUA (D47 , D48) ) ) by L506 , L510;
consider C221 , C222 being set such that L514: C221 in ( Funcs (( Funcs (C215 , ( INT )) ) , C215) ) and L515: C222 in ( Funcs (( Funcs (C215 , ( INT )) ) , ( INT )) ) and L516: C220 = [ C221 , C222 ] by L505 , L513 , ZFMISC_1:def 2;
reconsider D52 = C222 as (Element of ( Funcs (D45 , ( INT )) )) by L515;
reconsider D53 = C221 as (Element of ( Funcs (D45 , C215) )) by L514;
take D54 = ( D51 +* (( D53 . D51 ) , ( D52 . D51 )) );
thus L517: D54 in D45 by FUNCT_2:8;
take D51;
take D53;
take D52;
thus L518: (C217 = [ D51 , ( root-tree [ D53 , D52 ] ) ] & D54 = ( D51 +* (( D53 . D51 ) , ( D52 . D51 )) )) by L511 , L512 , L516;
end;
consider C223 being Function such that L519: (( dom C223 ) = [: D45 , ( ElementaryInstructions D49 ) :] & ( rng C223 ) c= D45) and L520: (for B195 being set holds (B195 in [: D45 , ( ElementaryInstructions D49 ) :] implies S5[ B195 , ( C223 . B195 ) ])) from FUNCT_1:sch 5(L507);
reconsider D55 = C223 as (Function of [: D45 , ( ElementaryInstructions D49 ) :] , D45) by L519 , FUNCT_2:2;
consider C224 being (ExecutionFunction of D49 , D45 , D46) such that L521: ( C224 | [: D45 , ( ElementaryInstructions D49 ) :] ) = D55 and L522: (for B196 being (Element of D45) holds (for B197 , B198 being (Element of D49) holds ((not C224 iteration_terminates_for ( B198 \; B197 ) , ( C224 . (B196 , B197) )) implies ( C224 . (B196 , ( while (B197 , B198) )) ) = D50))) by AOFA_000:91;
take C224;
let C225 being (Element of ( Funcs (C215 , ( INT )) ));
let C226 being (Element of ( Funcs (( Funcs (C215 , ( INT )) ) , C215) ));
let C227 being (Element of ( Funcs (( Funcs (C215 , ( INT )) ) , ( INT )) ));
set D56 = ( root-tree [ C226 , C227 ] );
L523: [ C226 , C227 ] in D48 by ZFMISC_1:87;
L524: D56 in ( ElementaryInstructions D49 ) by L523 , L506 , L505;
L525: [ C225 , D56 ] in [: D45 , ( ElementaryInstructions D49 ) :] by L524 , ZFMISC_1:87;
consider C228 being (Element of D45), C229 being (Element of ( Funcs (D45 , C215) )), C230 being (Element of ( Funcs (D45 , ( INT )) )) such that L526: [ C225 , D56 ] = [ C228 , ( root-tree [ C229 , C230 ] ) ] and L527: ( D55 . [ C225 , D56 ] ) = ( C228 +* (( C229 . C228 ) , ( C230 . C228 )) ) by L525 , L520;
L528: D56 = ( root-tree [ C229 , C230 ] ) by L526 , XTUPLE_0:1;
L529: [ C226 , C227 ] = [ C229 , C230 ] by L528 , TREES_4:4;
L530: C226 = C229 by L529 , XTUPLE_0:1;
L531: C227 = C230 by L529 , XTUPLE_0:1;
L532: C225 = C228 by L526 , XTUPLE_0:1;
thus L533: thesis by L532 , L521 , L525 , L527 , L530 , L531 , FUNCT_1:49;
end;
end;
definition
let C231 being non  empty set;
let C232 being (Subset of ( Funcs (C231 , ( INT )) ));
let C233 being (Enumeration of C231);
assume that
L535: ( rng C233 ) c= ( NAT );
mode INT-Exec of C233 , C232
 -> (ExecutionFunction of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) , ( Funcs (C231 , ( INT )) ) , C232)
means :L536: (for B199 being (Element of ( Funcs (C231 , ( INT )) )) holds (for B200 being (Element of ( Funcs (( Funcs (C231 , ( INT )) ) , C231) )) holds (for B201 being (Element of ( Funcs (( Funcs (C231 , ( INT )) ) , ( INT )) )) holds ( it . (B199 , ( root-tree [ ( ( C233 * B200 ) ** (C233 , ( NAT )) ) , ( B201 ** (C233 , ( NAT )) ) ] )) ) = ( B199 +* (( B200 . B199 ) , ( B201 . B199 )) ))));
existence
proof
L537: ( dom C233 ) = C231 by L336;
reconsider D57 = C233 as (Function of C231 , ( NAT )) by L537 , L535 , FUNCT_2:2;
reconsider D58 = ( 0 ) as (Element of ( INT )) by INT_1:def 1;
set D59 = ( Funcs (C231 , ( INT )) );
set D60 = ( ECIW-signature );
set D61 = ( INT-ElemIns );
set D62 = ( FreeUnivAlgNSG (D60 , D61) );
reconsider D63 = ( C231 --> D58 ) as (Element of D59) by FUNCT_2:8;
L538: ( Terminals ( DTConUA (D60 , D61) ) ) = D61 by FREEALG:3;
defpred S6[ set , set ] means (ex B202 being (Element of D59) st (( $1 `1 ) = B202 & (($2 = B202 & (not (ex B203 being (Element of ( Funcs (D59 , C231) )) st (ex B204 being (Element of ( Funcs (D59 , ( INT )) )) st ( $1 `2 ) = ( root-tree [ ( ( C233 * B203 ) ** (D57 , ( NAT )) ) , ( B204 ** (D57 , ( NAT )) ) ] ))))) or (ex B205 being (Element of ( Funcs (D59 , C231) )) st (ex B206 being (Element of ( Funcs (D59 , ( INT )) )) st (( $1 `2 ) = ( root-tree [ ( ( C233 * B205 ) ** (D57 , ( NAT )) ) , ( B206 ** (D57 , ( NAT )) ) ] ) & $2 = ( B202 +* (( B205 . B202 ) , ( B206 . B202 )) )))))));
L539: ( ElementaryInstructions D62 ) = ( FreeGenSetNSG (D60 , D61) ) by AOFA_000:70;
L540: (for B207 being set holds (B207 in [: D59 , ( ElementaryInstructions D62 ) :] implies (ex B208 being set st (B208 in D59 & S6[ B207 , B208 ]))))
proof
let C234 being set;
assume L541: C234 in [: D59 , ( ElementaryInstructions D62 ) :];
consider C235 , C236 being set such that L542: C235 in D59 and L543: C236 in ( ElementaryInstructions D62 ) and L544: C234 = [ C235 , C236 ] by L541 , ZFMISC_1:def 2;
L545: ( C234 `1 ) = C235 by L544 , MCART_1:7;
reconsider D64 = C235 as (Element of D59) by L542;
L546: ( C234 `2 ) = C236 by L544 , MCART_1:7;
consider C237 being (Symbol of ( DTConUA (D60 , D61) )) such that L547: C236 = ( root-tree C237 ) and L548: C237 in ( Terminals ( DTConUA (D60 , D61) ) ) by L539 , L543;
per cases ;
suppose L549: (ex B209 being (Element of ( Funcs (D59 , C231) )) st (ex B210 being (Element of ( Funcs (D59 , ( INT )) )) st C237 = [ ( ( C233 * B209 ) ** (D57 , ( NAT )) ) , ( B210 ** (D57 , ( NAT )) ) ]));

consider C238 being (Element of ( Funcs (D59 , C231) )), C239 being (Element of ( Funcs (D59 , ( INT )) )) such that L550: C237 = [ ( ( C233 * C238 ) ** (D57 , ( NAT )) ) , ( C239 ** (D57 , ( NAT )) ) ] by L549;
take D65 = ( D64 +* (( C238 . D64 ) , ( C239 . D64 )) );
thus L551: D65 in D59 by FUNCT_2:8;
thus L552: thesis by L545 , L546 , L547 , L550;
end;
suppose L553: (not (ex B211 being (Element of ( Funcs (D59 , C231) )) st (ex B212 being (Element of ( Funcs (D59 , ( INT )) )) st C237 = [ ( ( C233 * B211 ) ** (D57 , ( NAT )) ) , ( B212 ** (D57 , ( NAT )) ) ])));

take D66 = D64;
thus L554: D66 in D59;
L555: (not (ex B213 being (Element of ( Funcs (D59 , C231) )) st (ex B214 being (Element of ( Funcs (D59 , ( INT )) )) st ( C234 `2 ) = ( root-tree [ ( ( C233 * B213 ) ** (D57 , ( NAT )) ) , ( B214 ** (D57 , ( NAT )) ) ] )))) by L546 , L547 , L553 , TREES_4:4;
thus L556: thesis by L555 , L545;
end;
end;
consider C240 being Function such that L558: (( dom C240 ) = [: D59 , ( ElementaryInstructions D62 ) :] & ( rng C240 ) c= D59) and L559: (for B215 being set holds (B215 in [: D59 , ( ElementaryInstructions D62 ) :] implies S6[ B215 , ( C240 . B215 ) ])) from FUNCT_1:sch 5(L540);
reconsider D67 = C240 as (Function of [: D59 , ( ElementaryInstructions D62 ) :] , D59) by L558 , FUNCT_2:2;
consider C241 being (ExecutionFunction of D62 , D59 , C232) such that L560: ( C241 | [: D59 , ( ElementaryInstructions D62 ) :] ) = D67 and L561: (for B216 being (Element of D59) holds (for B217 , B218 being (Element of D62) holds ((not C241 iteration_terminates_for ( B218 \; B217 ) , ( C241 . (B216 , B217) )) implies ( C241 . (B216 , ( while (B217 , B218) )) ) = D63))) by AOFA_000:91;
take C241;
let C242 being (Element of ( Funcs (C231 , ( INT )) ));
let C243 being (Element of ( Funcs (( Funcs (C231 , ( INT )) ) , C231) ));
let C244 being (Element of ( Funcs (( Funcs (C231 , ( INT )) ) , ( INT )) ));
reconsider D68 = C243 as (Function of ( Funcs (C231 , ( INT )) ) , C231);
reconsider D69 = ( D57 * D68 ) as (Element of ( Funcs (( Funcs (C231 , ( INT )) ) , ( NAT )) )) by FUNCT_2:8;
set D70 = ( D69 ** (D57 , ( NAT )) );
set D71 = ( C244 ** (D57 , ( NAT )) );
set D72 = ( root-tree [ D70 , D71 ] );
L562: [ D70 , D71 ] in D61 by ZFMISC_1:87;
L563: D72 in ( ElementaryInstructions D62 ) by L562 , L539 , L538;
L564: [ C242 , D72 ] in [: D59 , ( ElementaryInstructions D62 ) :] by L563 , ZFMISC_1:87;
L565: S6[ [ C242 , D72 ] , ( D67 . [ C242 , D72 ] ) ] by L564 , L559;
consider C245 being (Element of ( Funcs (D59 , C231) )), C246 being (Element of ( Funcs (D59 , ( INT )) )) such that L566: ( [ C242 , D72 ] `2 ) = ( root-tree [ ( ( C233 * C245 ) ** (D57 , ( NAT )) ) , ( C246 ** (D57 , ( NAT )) ) ] ) and L567: ( D67 . [ C242 , D72 ] ) = ( C242 +* (( C245 . C242 ) , ( C246 . C242 )) ) by L565;
L568: ( dom ( D57 * C245 ) ) = D59 by FUNCT_2:def 1;
L569: ( dom C244 ) = D59 by FUNCT_2:def 1;
L570: ( dom C243 ) = D59 by FUNCT_2:def 1;
L571: ( dom D69 ) = D59 by FUNCT_2:def 1;
L572: ( dom D57 ) = C231 by FUNCT_2:def 1;
L573: ( rng C243 ) c= C231;
L574: ( dom C246 ) = D59 by FUNCT_2:def 1;
L575: ( dom C245 ) = D59 by FUNCT_2:def 1;
L576: [ D70 , D71 ] = [ ( ( C233 * C245 ) ** (D57 , ( NAT )) ) , ( C246 ** (D57 , ( NAT )) ) ] by L566 , TREES_4:4;
L577: D70 = ( ( C233 * C245 ) ** (D57 , ( NAT )) ) by L576 , XTUPLE_0:1;
L578: D69 = ( C233 * C245 ) by L577 , L571 , L568 , L301;
L579: D71 = ( C246 ** (D57 , ( NAT )) ) by L576 , XTUPLE_0:1;
L580: C244 = C246 by L579 , L569 , L574 , L301;
L581: ( rng C245 ) c= C231;
L582: C243 = C245 by L581 , L573 , L572 , L575 , L570 , L578 , FUNCT_1:27;
thus L583: thesis by L582 , L560 , L564 , L567 , L580 , FUNCT_1:49;
end;
end;
theorem
L585: (for B219 being INT-Exec holds (for B220 being (INT-Variable of ( NAT )) holds (for B221 being (INT-Expression of ( NAT )) holds B220 , B221 form_assignment_wrt B219)))
proof
let C247 being INT-Exec;
set D73 = ( ECIW-signature );
set D74 = ( INT-ElemIns );
set D75 = ( NAT );
set D76 = ( FreeUnivAlgNSG (D73 , D74) );
let C248 being (INT-Variable of ( NAT ));
let C249 being (INT-Expression of ( NAT ));
reconsider D77 = C248 as (Element of ( Funcs (( Funcs (D75 , ( INT )) ) , D75) )) by FUNCT_2:8;
reconsider D78 = C249 as (Element of ( Funcs (( Funcs (D75 , ( INT )) ) , ( INT )) )) by FUNCT_2:8;
L586: ( Terminals ( DTConUA (D73 , D74) ) ) = D74 by FREEALG:3;
L587: [ D77 , D78 ] in D74 by ZFMISC_1:87;
L588: ( ElementaryInstructions D76 ) = ( FreeGenSetNSG (D73 , D74) ) by AOFA_000:70;
L589: ( root-tree [ D77 , D78 ] ) in ( ElementaryInstructions D76 ) by L588 , L586 , L587;
reconsider D79 = ( root-tree [ D77 , D78 ] ) as (Element of D76) by L589;
take D79;
thus L590: D79 in ( ElementaryInstructions D76 ) by L588 , L586 , L587;
thus L591: thesis by L473;
end;
theorem
L592: (for B222 being INT-Exec holds (for B223 being (INT-Variable of ( NAT )) holds B223 is (INT-Variable of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) , B222)))
proof
set D80 = the (INT-Expression of ( NAT ));
let C250 being INT-Exec;
set D81 = ( ECIW-signature );
set D82 = ( INT-ElemIns );
set D83 = ( NAT );
set D84 = ( FreeUnivAlgNSG (D81 , D82) );
let C251 being (INT-Variable of ( NAT ));
L593: ( Terminals ( DTConUA (D81 , D82) ) ) = D82 by FREEALG:3;
reconsider D85 = D80 as (Element of ( Funcs (( Funcs (D83 , ( INT )) ) , ( INT )) )) by FUNCT_2:8;
reconsider D86 = C251 as (Element of ( Funcs (( Funcs (D83 , ( INT )) ) , D83) )) by FUNCT_2:8;
L594: [ D86 , D85 ] in D82 by ZFMISC_1:87;
L595: ( ElementaryInstructions D84 ) = ( FreeGenSetNSG (D81 , D82) ) by AOFA_000:70;
L596: ( root-tree [ D86 , D85 ] ) in ( ElementaryInstructions D84 ) by L595 , L593 , L594;
reconsider D87 = ( root-tree [ D86 , D85 ] ) as (Element of D84) by L596;
thus L597:now
take D88 = D87;
thus L598: D88 is_assignment_wrt D84 , D83 , C250
proof
thus L599: D88 in ( ElementaryInstructions D84 ) by L595 , L593 , L594;
take C251;
take D80;
thus L600: thesis by L473;
end;

end;
take D80;
thus L599: thesis by L585;
end;
theorem
L600: (for B224 being INT-Exec holds (for B225 being (INT-Expression of ( NAT )) holds B225 is (INT-Expression of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) , B224)))
proof
set D89 = the (INT-Variable of ( NAT ));
let C252 being INT-Exec;
set D90 = ( ECIW-signature );
set D91 = ( INT-ElemIns );
set D92 = ( NAT );
set D93 = ( FreeUnivAlgNSG (D90 , D91) );
let C253 being (INT-Expression of ( NAT ));
L601: ( Terminals ( DTConUA (D90 , D91) ) ) = D91 by FREEALG:3;
reconsider D94 = C253 as (Element of ( Funcs (( Funcs (D92 , ( INT )) ) , ( INT )) )) by FUNCT_2:8;
reconsider D95 = D89 as (Element of ( Funcs (( Funcs (D92 , ( INT )) ) , D92) )) by FUNCT_2:8;
L602: [ D95 , D94 ] in D91 by ZFMISC_1:87;
L603: ( ElementaryInstructions D93 ) = ( FreeGenSetNSG (D90 , D91) ) by AOFA_000:70;
L604: ( root-tree [ D95 , D94 ] ) in ( ElementaryInstructions D93 ) by L603 , L601 , L602;
reconsider D96 = ( root-tree [ D95 , D94 ] ) as (Element of D93) by L604;
thus L605:now
take D97 = D96;
thus L606: D97 is_assignment_wrt D93 , D92 , C252
proof
thus L607: D97 in ( ElementaryInstructions D93 ) by L603 , L601 , L602;
take D89;
take C253;
thus L608: thesis by L473;
end;

end;
take D89;
thus L607: thesis by L585;
end;
registration
cluster  ->  Euclidean for INT-Exec;
coherence
proof
set D98 = ( NAT );
set D99 = ( ( ( INT ) --> ( 0 ) ) +* ( id D98 ) );
L608: ( dom ( id D98 ) ) = D98 by RELAT_1:45;
L609: ( ( INT ) \/ D98 ) = ( INT ) by NUMBERS:17 , XBOOLE_1:12;
L610: ( dom ( ( INT ) --> ( 0 ) ) ) = ( INT ) by FUNCOP_1:13;
L611: ( dom D99 ) = ( INT ) by L610 , L608 , L609 , FUNCT_4:def 1;
L612: ( rng ( id D98 ) ) = D98 by RELAT_1:45;
L613: { ( 0 ) } c= D98 by ZFMISC_1:31;
L614: ( { ( 0 ) } \/ D98 ) = D98 by L613 , XBOOLE_1:12;
L615: ( rng ( ( INT ) --> ( 0 ) ) ) = { ( 0 ) } by FUNCOP_1:8;
L616: ( rng D99 ) c= ( NAT ) by L615 , L612 , L614 , FUNCT_4:17;
reconsider D100 = D99 as (INT-Array of D98) by L616 , L611 , FUNCT_2:2;
let C254 being INT-Exec;
set D101 = ( ECIW-signature );
set D102 = ( INT-ElemIns );
set D103 = ( FreeUnivAlgNSG (D101 , D102) );
thus L617: (for B226 being (INT-Variable of D103 , C254) holds (for B227 being (INT-Expression of D103 , C254) holds B226 , B227 form_assignment_wrt C254)) by L585;
thus L618: (for B228 being  integer number holds ( . (B228 , D98) ) is (INT-Expression of D103 , C254)) by L600;
thus L619: (for B229 being (INT-Variable of D103 , C254) holds ( . B229 ) is (INT-Expression of D103 , C254)) by L600;
thus L620: (for B230 being (Element of D98) holds ( ^ B230 ) is (INT-Variable of D103 , C254)) by L592;
thus L621:now
take D104 = D100;
L622: ( dom ( id D98 ) ) = D98 by RELAT_1:45;
thus L623: ( D104 | ( card D98 ) ) is  one-to-one by L622 , CARD_1:47 , FUNCT_4:23;
thus L624: (for B231 being (INT-Expression of D103 , C254) holds ( D104 * B231 ) is (INT-Variable of D103 , C254)) by L592;
end;
thus L625: thesis by L600;
end;
end;
theorem
L627: (for B232 being non  empty  countable set holds (for B233 being (Subset of ( Funcs (B232 , ( INT )) )) holds (for B234 being (Enumeration of B232) holds (for B235 being (INT-Exec of B234 , B233) holds (for B236 being (INT-Variable of B232) holds (for B237 being (INT-Expression of B232) holds B236 , B237 form_assignment_wrt B235))))))
proof
set D105 = ( ECIW-signature );
set D106 = ( INT-ElemIns );
let C255 being non  empty  countable set;
let C256 being (Subset of ( Funcs (C255 , ( INT )) ));
let C257 being (Enumeration of C255);
set D107 = ( FreeUnivAlgNSG (D105 , D106) );
let C258 being (INT-Exec of C257 , C256);
let C259 being (INT-Variable of C255);
let C260 being (INT-Expression of C255);
reconsider D108 = C259 as (Element of ( Funcs (( Funcs (C255 , ( INT )) ) , C255) )) by FUNCT_2:8;
reconsider D109 = C260 as (Element of ( Funcs (( Funcs (C255 , ( INT )) ) , ( INT )) )) by FUNCT_2:8;
L628: ( ElementaryInstructions D107 ) = ( FreeGenSetNSG (D105 , D106) ) by AOFA_000:70;
L629: ( rng C257 ) c= ( NAT ) by L392;
L630: ( dom C257 ) = C255 by L336;
reconsider D110 = C257 as (Function of C255 , ( NAT )) by L630 , L629 , FUNCT_2:2;
reconsider D111 = ( D110 * C259 ) as (Element of ( Funcs (( Funcs (C255 , ( INT )) ) , ( NAT )) )) by FUNCT_2:8;
set D112 = ( D111 ** (D110 , ( NAT )) );
set D113 = ( D109 ** (D110 , ( NAT )) );
L631: ( Terminals ( DTConUA (D105 , D106) ) ) = D106 by FREEALG:3;
L632: [ D112 , D113 ] in D106 by ZFMISC_1:87;
L633: ( root-tree [ D112 , D113 ] ) in ( ElementaryInstructions D107 ) by L632 , L628 , L631;
reconsider D114 = ( root-tree [ D112 , D113 ] ) as (Element of D107) by L633;
take D114;
L634: (for B238 being (Element of ( Funcs (C255 , ( INT )) )) holds ( C258 . (B238 , ( root-tree [ ( ( C257 * D108 ) ** (C257 , ( NAT )) ) , ( D109 ** (C257 , ( NAT )) ) ] )) ) = ( B238 +* (( D108 . B238 ) , ( D109 . B238 )) )) by L629 , L536;
thus L635: thesis by L634 , L628 , L631 , L632;
end;
theorem
L636: (for B239 being non  empty  countable set holds (for B240 being (Subset of ( Funcs (B239 , ( INT )) )) holds (for B241 being (Enumeration of B239) holds (for B242 being (INT-Exec of B241 , B240) holds (for B243 being (INT-Variable of B239) holds B243 is (INT-Variable of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) , B242))))))
proof
set D115 = ( ECIW-signature );
set D116 = ( INT-ElemIns );
let C261 being non  empty  countable set;
let C262 being (Subset of ( Funcs (C261 , ( INT )) ));
let C263 being (Enumeration of C261);
set D117 = ( FreeUnivAlgNSG (D115 , D116) );
let C264 being (INT-Exec of C263 , C262);
let C265 being (INT-Variable of C261);
set D118 = the (INT-Expression of C261);
L637: ( ElementaryInstructions D117 ) = ( FreeGenSetNSG (D115 , D116) ) by AOFA_000:70;
L638: ( rng C263 ) c= ( NAT ) by L392;
L639: ( dom C263 ) = C261 by L336;
reconsider D119 = C263 as (Function of C261 , ( NAT )) by L639 , L638 , FUNCT_2:2;
reconsider D120 = ( D119 * C265 ) as (Element of ( Funcs (( Funcs (C261 , ( INT )) ) , ( NAT )) )) by FUNCT_2:8;
reconsider D121 = C265 as (Element of ( Funcs (( Funcs (C261 , ( INT )) ) , C261) )) by FUNCT_2:8;
reconsider D122 = D118 as (Element of ( Funcs (( Funcs (C261 , ( INT )) ) , ( INT )) )) by FUNCT_2:8;
L640: ( Terminals ( DTConUA (D115 , D116) ) ) = D116 by FREEALG:3;
set D123 = ( D120 ** (D119 , ( NAT )) );
set D124 = ( D122 ** (D119 , ( NAT )) );
L641: [ D123 , D124 ] in D116 by ZFMISC_1:87;
L642: ( root-tree [ D123 , D124 ] ) in ( ElementaryInstructions D117 ) by L641 , L637 , L640;
reconsider D125 = ( root-tree [ D123 , D124 ] ) as (Element of D117) by L642;
thus L643:now
take D126 = D125;
thus L644: D126 is_assignment_wrt D117 , C261 , C264
proof
thus L645: D126 in ( ElementaryInstructions D117 ) by L637 , L640 , L641;
take C265;
take D118;
L646: (for B244 being (Element of ( Funcs (C261 , ( INT )) )) holds ( C264 . (B244 , ( root-tree [ ( ( C263 * D121 ) ** (C263 , ( NAT )) ) , ( D122 ** (C263 , ( NAT )) ) ] )) ) = ( B244 +* (( D121 . B244 ) , ( D122 . B244 )) )) by L638 , L536;
thus L647: thesis by L646;
end;

end;
take D118;
thus L645: thesis by L627;
end;
theorem
L646: (for B245 being non  empty  countable set holds (for B246 being (Subset of ( Funcs (B245 , ( INT )) )) holds (for B247 being (Enumeration of B245) holds (for B248 being (INT-Exec of B247 , B246) holds (for B249 being (INT-Expression of B245) holds B249 is (INT-Expression of ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) , B248))))))
proof
set D127 = ( ECIW-signature );
set D128 = ( INT-ElemIns );
let C266 being non  empty  countable set;
let C267 being (Subset of ( Funcs (C266 , ( INT )) ));
let C268 being (Enumeration of C266);
set D129 = ( FreeUnivAlgNSG (D127 , D128) );
let C269 being (INT-Exec of C268 , C267);
set D130 = the (INT-Variable of C266);
let C270 being (INT-Expression of C266);
L647: ( ElementaryInstructions D129 ) = ( FreeGenSetNSG (D127 , D128) ) by AOFA_000:70;
L648: ( rng C268 ) c= ( NAT ) by L392;
L649: ( dom C268 ) = C266 by L336;
reconsider D131 = C268 as (Function of C266 , ( NAT )) by L649 , L648 , FUNCT_2:2;
reconsider D132 = ( D131 * D130 ) as (Element of ( Funcs (( Funcs (C266 , ( INT )) ) , ( NAT )) )) by FUNCT_2:8;
reconsider D133 = D130 as (Element of ( Funcs (( Funcs (C266 , ( INT )) ) , C266) )) by FUNCT_2:8;
reconsider D134 = C270 as (Element of ( Funcs (( Funcs (C266 , ( INT )) ) , ( INT )) )) by FUNCT_2:8;
L650: ( Terminals ( DTConUA (D127 , D128) ) ) = D128 by FREEALG:3;
set D135 = ( D132 ** (D131 , ( NAT )) );
set D136 = ( D134 ** (D131 , ( NAT )) );
L651: [ D135 , D136 ] in D128 by ZFMISC_1:87;
L652: ( root-tree [ D135 , D136 ] ) in ( ElementaryInstructions D129 ) by L651 , L647 , L650;
reconsider D137 = ( root-tree [ D135 , D136 ] ) as (Element of D129) by L652;
thus L653:now
take D138 = D137;
thus L654: D138 is_assignment_wrt D129 , C266 , C269
proof
thus L655: D138 in ( ElementaryInstructions D129 ) by L647 , L650 , L651;
take D130;
take C270;
L656: (for B250 being (Element of ( Funcs (C266 , ( INT )) )) holds ( C269 . (B250 , ( root-tree [ ( ( C268 * D133 ) ** (C268 , ( NAT )) ) , ( D134 ** (C268 , ( NAT )) ) ] )) ) = ( B250 +* (( D133 . B250 ) , ( D134 . B250 )) )) by L648 , L536;
thus L657: thesis by L656;
end;

end;
take D130;
thus L655: thesis by L627;
end;
registration
let C271 being  countable non  empty set;
let C272 being (Subset of ( Funcs (C271 , ( INT )) ));
let C273 being (Enumeration of C271);
cluster  ->  Euclidean for (INT-Exec of C273 , C272);
coherence
proof
L656: ( rng C273 ) c= ( NAT ) by L392;
L657: ( card C271 ) = ( rng C273 ) by L336;
L658: ( ( INT ) \/ ( card C271 ) ) = ( INT ) by L657 , L656 , NUMBERS:17 , XBOOLE_1:1 , XBOOLE_1:12;
set D139 = ( ( C273 " ) . ( 0 ) );
set D140 = ( ( ( INT ) --> D139 ) +* ( C273 " ) );
L659: ( dom ( ( INT ) --> D139 ) ) = ( INT ) by FUNCOP_1:13;
L660: ( rng ( ( INT ) --> D139 ) ) = { D139 } by FUNCOP_1:8;
L661: D139 in C271 by FUNCT_2:5 , ORDINAL3:8;
L662: { D139 } c= C271 by L661 , ZFMISC_1:31;
L663: ( { D139 } \/ C271 ) = C271 by L662 , XBOOLE_1:12;
L664: ( rng ( C273 " ) ) = C271 by L339;
L665: ( rng D140 ) c= C271 by L664 , L660 , L663 , FUNCT_4:17;
L666: ( dom ( C273 " ) ) = ( card C271 ) by L339;
L667: ( dom D140 ) = ( INT ) by L666 , L659 , L658 , FUNCT_4:def 1;
reconsider D141 = D140 as (INT-Array of C271) by L667 , L665 , FUNCT_2:2;
let C274 being (INT-Exec of C273 , C272);
set D142 = ( ECIW-signature );
set D143 = ( INT-ElemIns );
set D144 = ( FreeUnivAlgNSG (D142 , D143) );
thus L668: (for B251 being (INT-Variable of D144 , C274) holds (for B252 being (INT-Expression of D144 , C274) holds B251 , B252 form_assignment_wrt C274)) by L627;
thus L669: (for B253 being  integer number holds ( . (B253 , C271) ) is (INT-Expression of D144 , C274)) by L646;
thus L670: (for B254 being (INT-Variable of D144 , C274) holds ( . B254 ) is (INT-Expression of D144 , C274)) by L646;
thus L671: (for B255 being (Element of C271) holds ( ^ B255 ) is (INT-Variable of D144 , C274)) by L636;
thus L672:now
take D145 = D141;
L673: ( dom ( C273 " ) ) = ( card C271 ) by L339;
thus L674: ( D145 | ( card C271 ) ) is  one-to-one by L673 , FUNCT_4:23;
thus L675: (for B256 being (INT-Expression of D144 , C274) holds ( D145 * B256 ) is (INT-Variable of D144 , C274)) by L636;
end;
thus L676: thesis by L646;
end;
end;
registration
cluster ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) ) ->  Euclidean;
coherence
proof
let C275 being non  empty  countable set;
let C276 being (Subset of ( Funcs (C275 , ( INT )) ));
set D146 = the (Enumeration of C275);
set D147 = the (INT-Exec of D146 , C276);
take D147;
thus L678: thesis;
end;
end;
registration
cluster  Euclidean non  degenerated for preIfWhileAlgebra;
existence
proof
take ( FreeUnivAlgNSG (( ECIW-signature ) , ( INT-ElemIns )) );
thus L680: thesis;
end;
end;
registration
let C277 being  Euclidean preIfWhileAlgebra;
let C278 being non  empty  countable set;
let C279 being (Subset of ( Funcs (C278 , ( INT )) ));
cluster  Euclidean for (ExecutionFunction of C277 , ( Funcs (C278 , ( INT )) ) , C279);
existence by L470;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C280 being (INT-Expression of R2 , R5);
redefine func - C280 -> (INT-Expression of R2 , R5);

coherence by L468;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C281 being (INT-Expression of R2 , R5);
let C282 being  integer number;
redefine func C281 + C282 -> (INT-Expression of R2 , R5);

coherence
proof
L684: ( dom ( C281 + ( . (C282 , R3) ) ) ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L685:
now
let C283 being set;
assume L686: C283 in ( Funcs (R3 , ( INT )) );
reconsider D148 = C283 as (Element of ( Funcs (R3 , ( INT )) )) by L686;
thus L687: ( ( C281 + ( . (C282 , R3) ) ) . C283 ) = ( ( C281 . D148 ) + ( ( . (C282 , R3) ) . D148 ) ) by L684 , VALUED_1:def 1
.= ( C282 + ( C281 . C283 ) ) by FUNCOP_1:7;
end;
L688: ( . (C282 , R3) ) is (INT-Expression of R2 , R5) by L468;
L689: ( C281 + ( . (C282 , R3) ) ) is (INT-Expression of R2 , R5) by L688 , L468;
L690: ( dom C281 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
thus L691: thesis by L690 , L689 , L684 , L685 , VALUED_1:def 2;
end;
redefine func C281 - C282 -> (INT-Expression of R2 , R5);

coherence
proof
L692: ( . (C282 , R3) ) is (INT-Expression of R2 , R5) by L468;
L693: ( - ( . (C282 , R3) ) ) is (INT-Expression of R2 , R5) by L692 , L468;
L694: ( C281 + ( - ( . (C282 , R3) ) ) ) is (INT-Expression of R2 , R5) by L693 , L468;
L695: ( dom C281 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L696: ( dom ( C281 + ( - ( . (C282 , R3) ) ) ) ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L697:
now
let C284 being set;
assume L698: C284 in ( Funcs (R3 , ( INT )) );
reconsider D149 = C284 as (Element of ( Funcs (R3 , ( INT )) )) by L698;
thus L699: ( ( C281 + ( - ( . (C282 , R3) ) ) ) . C284 ) = ( ( C281 . D149 ) + ( ( - ( . (C282 , R3) ) ) . D149 ) ) by L696 , VALUED_1:def 1
.= ( ( C281 . D149 ) + ( - ( ( . (C282 , R3) ) . D149 ) ) ) by VALUED_1:8
.= ( ( C281 . D149 ) - C282 ) by FUNCOP_1:7
.= ( ( C281 - C282 ) . C284 ) by L695 , VALUED_1:3;
end;
L700: ( dom ( C281 - C282 ) ) = ( dom C281 ) by VALUED_1:3;
thus L701: thesis by L700 , L694 , L696 , L695 , L697 , FUNCT_1:2;
end;
redefine func C281 * C282 -> (INT-Expression of R2 , R5);

coherence
proof
L702: ( dom ( C281 (#) ( . (C282 , R3) ) ) ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L703:
now
let C285 being set;
assume L704: C285 in ( Funcs (R3 , ( INT )) );
reconsider D150 = C285 as (Element of ( Funcs (R3 , ( INT )) )) by L704;
thus L705: ( ( C281 (#) ( . (C282 , R3) ) ) . C285 ) = ( ( C281 . D150 ) * ( ( . (C282 , R3) ) . D150 ) ) by L702 , VALUED_1:def 4
.= ( C282 * ( C281 . C285 ) ) by FUNCOP_1:7;
end;
L706: ( . (C282 , R3) ) is (INT-Expression of R2 , R5) by L468;
L707: ( C281 (#) ( . (C282 , R3) ) ) is (INT-Expression of R2 , R5) by L706 , L468;
L708: ( dom C281 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
thus L709: thesis by L708 , L707 , L702 , L703 , VALUED_1:def 5;
end;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C286 , C287 being (INT-Expression of R2 , R5);
redefine func C286 - C287 -> (INT-Expression of R2 , R5);

coherence
proof
L711: ( - C287 ) is (INT-Expression of R2 , R5);
thus L712: thesis by L711 , L468;
end;
redefine func C286 + C287 -> (INT-Expression of R2 , R5);

coherence by L468;
redefine func C286 (#) C287 -> (INT-Expression of R2 , R5);

coherence by L468;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C288 , C289 being (INT-Expression of R2 , R5);
redefine func C288 div C289 -> (INT-Expression of R2 , R5) means 
:L714: (for B257 being (Element of ( Funcs (R3 , ( INT )) )) holds ( it . B257 ) = ( ( C288 . B257 ) div ( C289 . B257 ) ));
coherence by L468;
compatibility
proof
let C290 being (INT-Expression of R2 , R5);
L715: ( dom C288 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L716: ( dom C289 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L717: ( dom ( C288 div C289 ) ) = ( ( dom C288 ) /\ ( dom C289 ) ) by L27;
thus L718: (C290 = ( C288 div C289 ) implies (for B258 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C290 . B258 ) = ( ( C288 . B258 ) div ( C289 . B258 ) ))) by L717 , L715 , L716 , L27;
L719: ( dom C290 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
assume L720: (for B259 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C290 . B259 ) = ( ( C288 . B259 ) div ( C289 . B259 ) ));
L721: (for B260 being set holds (B260 in ( Funcs (R3 , ( INT )) ) implies ( C290 . B260 ) = ( ( C288 . B260 ) div ( C289 . B260 ) ))) by L720;
thus L722: C290 = ( C288 div C289 ) by L721 , L717 , L715 , L716 , L719 , L27;
end;
redefine func C288 mod C289 -> (INT-Expression of R2 , R5) means 
:L723: (for B261 being (Element of ( Funcs (R3 , ( INT )) )) holds ( it . B261 ) = ( ( C288 . B261 ) mod ( C289 . B261 ) ));
coherence by L468;
compatibility
proof
let C291 being (INT-Expression of R2 , R5);
L724: ( dom C288 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L725: ( dom C289 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L726: ( dom ( C288 mod C289 ) ) = ( ( dom C288 ) /\ ( dom C289 ) ) by L44;
thus L727: (C291 = ( C288 mod C289 ) implies (for B262 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C291 . B262 ) = ( ( C288 . B262 ) mod ( C289 . B262 ) ))) by L726 , L724 , L725 , L44;
L728: ( dom C291 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
assume L729: (for B263 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C291 . B263 ) = ( ( C288 . B263 ) mod ( C289 . B263 ) ));
L730: (for B264 being set holds (B264 in ( Funcs (R3 , ( INT )) ) implies ( C291 . B264 ) = ( ( C288 . B264 ) mod ( C289 . B264 ) ))) by L729;
thus L731: C291 = ( C288 mod C289 ) by L730 , L726 , L724 , L725 , L728 , L44;
end;
redefine func leq (C288 , C289) -> (INT-Expression of R2 , R5) means 
:L732: (for B265 being (Element of ( Funcs (R3 , ( INT )) )) holds ( it . B265 ) = ( IFGT (( C288 . B265 ) , ( C289 . B265 ) , ( 0 ) , 1) ));
compatibility
proof
let C292 being (INT-Expression of R2 , R5);
L733: ( dom C288 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L734: ( dom C289 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L735: ( dom ( leq (C288 , C289) ) ) = ( ( dom C288 ) /\ ( dom C289 ) ) by L61;
thus L736: (C292 = ( leq (C288 , C289) ) implies (for B266 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C292 . B266 ) = ( IFGT (( C288 . B266 ) , ( C289 . B266 ) , ( 0 ) , 1) ))) by L735 , L733 , L734 , L61;
L737: ( dom C292 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
assume L738: (for B267 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C292 . B267 ) = ( IFGT (( C288 . B267 ) , ( C289 . B267 ) , ( 0 ) , 1) ));
L739: (for B268 being set holds (B268 in ( Funcs (R3 , ( INT )) ) implies ( C292 . B268 ) = ( IFGT (( C288 . B268 ) , ( C289 . B268 ) , ( 0 ) , 1) ))) by L738;
thus L740: C292 = ( leq (C288 , C289) ) by L739 , L735 , L733 , L734 , L737 , L61;
end;
coherence by L468;
redefine func gt (C288 , C289) -> (INT-Expression of R2 , R5) means 
:L741: (for B269 being (Element of ( Funcs (R3 , ( INT )) )) holds ( it . B269 ) = ( IFGT (( C288 . B269 ) , ( C289 . B269 ) , 1 , ( 0 )) ));
coherence by L468;
compatibility
proof
let C293 being (INT-Expression of R2 , R5);
L742: ( dom C288 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L743: ( dom C289 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L744: ( dom ( gt (C288 , C289) ) ) = ( ( dom C288 ) /\ ( dom C289 ) ) by L78;
thus L745: (C293 = ( gt (C288 , C289) ) implies (for B270 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C293 . B270 ) = ( IFGT (( C288 . B270 ) , ( C289 . B270 ) , 1 , ( 0 )) ))) by L744 , L742 , L743 , L78;
L746: ( dom C293 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
assume L747: (for B271 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C293 . B271 ) = ( IFGT (( C288 . B271 ) , ( C289 . B271 ) , 1 , ( 0 )) ));
L748: (for B272 being set holds (B272 in ( Funcs (R3 , ( INT )) ) implies ( C293 . B272 ) = ( IFGT (( C288 . B272 ) , ( C289 . B272 ) , 1 , ( 0 )) ))) by L747;
thus L749: C293 = ( gt (C288 , C289) ) by L748 , L744 , L742 , L743 , L746 , L78;
end;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C294 , C295 being (INT-Expression of R2 , R5);
redefine func eq (C294 , C295) -> (INT-Expression of R2 , R5) means 
(for B273 being (Element of ( Funcs (R3 , ( INT )) )) holds ( it . B273 ) = ( IFEQ (( C294 . B273 ) , ( C295 . B273 ) , 1 , ( 0 )) ));
compatibility
proof
let C296 being (INT-Expression of R2 , R5);
L751: ( dom C294 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L752: ( dom C295 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L753: ( dom ( eq (C294 , C295) ) ) = ( ( dom C294 ) /\ ( dom C295 ) ) by L95;
thus L754: (C296 = ( eq (C294 , C295) ) implies (for B274 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C296 . B274 ) = ( IFEQ (( C294 . B274 ) , ( C295 . B274 ) , 1 , ( 0 )) ))) by L753 , L751 , L752 , L95;
L755: ( dom C296 ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
assume L756: (for B275 being (Element of ( Funcs (R3 , ( INT )) )) holds ( C296 . B275 ) = ( IFEQ (( C294 . B275 ) , ( C295 . B275 ) , 1 , ( 0 )) ));
L757: (for B276 being set holds (B276 in ( Funcs (R3 , ( INT )) ) implies ( C296 . B276 ) = ( IFEQ (( C294 . B276 ) , ( C295 . B276 ) , 1 , ( 0 )) ))) by L756;
thus L758: C296 = ( eq (C294 , C295) ) by L757 , L753 , L751 , L752 , L755 , L95;
end;
coherence
proof
reconsider D151 = ( leq (C294 , C295) ) , D152 = ( leq (C295 , C294) ) as (INT-Expression of R2 , R5);
L759: ( dom ( D151 (#) D152 ) ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L760: ( dom ( eq (C294 , C295) ) ) = ( Funcs (R3 , ( INT )) ) by FUNCT_2:def 1;
L761:
now
let C297 being set;
assume L762: C297 in ( Funcs (R3 , ( INT )) );
reconsider D153 = C297 as (Element of ( Funcs (R3 , ( INT )) )) by L762;
L763: (( C294 . D153 ) = ( C295 . D153 ) or ( C294 . D153 ) < ( C295 . D153 ) or ( C295 . D153 ) < ( C294 . D153 )) by XXREAL_0:1;
L764: ( D152 . D153 ) = ( IFGT (( C295 . D153 ) , ( C294 . D153 ) , ( 0 ) , 1) ) by L732;
L765: ( ( D151 (#) D152 ) . D153 ) = ( ( D151 . D153 ) * ( D152 . D153 ) ) by L759 , VALUED_1:def 4;
L766: ( D151 . D153 ) = ( IFGT (( C294 . D153 ) , ( C295 . D153 ) , ( 0 ) , 1) ) by L732;
L767: ( ( eq (C294 , C295) ) . D153 ) = ( IFEQ (( C294 . D153 ) , ( C295 . D153 ) , 1 , ( 0 )) ) by L760 , L95;
L768: ((( ( eq (C294 , C295) ) . D153 ) = 1 & ( D151 . D153 ) = 1 & ( D152 . D153 ) = 1) or (( ( eq (C294 , C295) ) . D153 ) = ( 0 ) & ( D151 . D153 ) = ( 0 ) & ( D152 . D153 ) = 1) or (( ( eq (C294 , C295) ) . D153 ) = ( 0 ) & ( D151 . D153 ) = 1 & ( D152 . D153 ) = ( 0 ))) by L767 , L764 , L766 , L763 , FUNCOP_1:def 8 , XXREAL_0:def 11;
thus L769: ( ( eq (C294 , C295) ) . C297 ) = ( ( D151 (#) D152 ) . C297 ) by L768 , L765;
end;
thus L770: thesis by L761 , L760 , L759 , FUNCT_1:2;
end;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C298 being (INT-Variable of R2 , R5);
func . C298 -> (INT-Expression of R2 , R5) equals 
( . C298 );
coherence by L468;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C299 being (Element of R3);
func C299 ^ (R2 , R5) -> (INT-Variable of R2 , R5) equals 
( ^ C299 );
coherence by L468;
end;
notation
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C300 being (Variable of R5);
synonym ^ C300 for C300 ^ (R2 , R5);
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C301 being (Variable of R5);
func . C301 -> (INT-Expression of R2 , R5) equals 
( . ( ^ C301 ) );
coherence;
end;
theorem
L776: (for R2 being  Euclidean preIfWhileAlgebra holds (for R3 being non  empty  countable set holds (for R4 being (Subset of ( Funcs (R3 , ( INT )) )) holds (for R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4) holds (for B277 being (Variable of R5) holds (for B278 being (Element of ( Funcs (R3 , ( INT )) )) holds ( ( . B277 ) . B278 ) = ( B278 . B277 )))))))
proof
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C302 being (Variable of R5);
let C303 being (Element of ( Funcs (R3 , ( INT )) ));
thus L777: ( ( . C302 ) . C303 ) = ( C303 . ( ( C302 ^ (R2 , R5) ) . C303 ) ) by L442
.= ( C303 . C302 ) by FUNCOP_1:7;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C304 being  integer number;
func . (C304 , R2 , R5) -> (INT-Expression of R2 , R5) equals 
( . (C304 , R3) );
coherence by L468;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C305 being (INT-Variable of R2 , R5);
let C306 being (INT-Expression of R2 , R5);
func C305 := C306 -> (Element of R2) equals 
( choose { B279 where B279 is (Element of R2) : (B279 in ( ElementaryInstructions R2 ) & (for B280 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B280 , B279) ) = ( B280 +* (( C305 . B280 ) , ( C306 . B280 )) ))) } );
coherence
proof
set D154 = { B281 where B281 is (Element of R2) : (B281 in ( ElementaryInstructions R2 ) & (for B282 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B282 , B281) ) = ( B282 +* (( C305 . B282 ) , ( C306 . B282 )) ))) };
L779: D154 c= (the carrier of R2)
proof
let C307 being set;
assume L780: C307 in D154;
L781: (ex B283 being (Element of R2) st (C307 = B283 & B283 in ( ElementaryInstructions R2 ) & (for B284 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B284 , B283) ) = ( B284 +* (( C305 . B284 ) , ( C306 . B284 )) )))) by L780;
thus L782: thesis by L781;
end;
L783: C305 , C306 form_assignment_wrt R5 by L468;
consider C308 being (Element of R2) such that L784: C308 in ( ElementaryInstructions R2 ) and L785: (for B285 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B285 , C308) ) = ( B285 +* (( C305 . B285 ) , ( C306 . B285 )) )) by L783 , L419;
L786: C308 in D154 by L784 , L785;
L787: ( choose D154 ) in D154 by L786;
thus L788: thesis by L787 , L779;
end;
end;
theorem
L790: (for R2 being  Euclidean preIfWhileAlgebra holds (for R3 being non  empty  countable set holds (for R4 being (Subset of ( Funcs (R3 , ( INT )) )) holds (for R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4) holds (for B286 being (INT-Variable of R2 , R5) holds (for B287 being (INT-Expression of R2 , R5) holds ( B286 := B287 ) in ( ElementaryInstructions R2 )))))))
proof
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C309 being (INT-Variable of R2 , R5);
let C310 being (INT-Expression of R2 , R5);
set D155 = { B288 where B288 is (Element of R2) : (B288 in ( ElementaryInstructions R2 ) & (for B289 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B289 , B288) ) = ( B289 +* (( C309 . B289 ) , ( C310 . B289 )) ))) };
L791: C309 , C310 form_assignment_wrt R5 by L468;
consider C311 being (Element of R2) such that L792: C311 in ( ElementaryInstructions R2 ) and L793: (for B290 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B290 , C311) ) = ( B290 +* (( C309 . B290 ) , ( C310 . B290 )) )) by L791 , L419;
L794: C311 in D155 by L792 , L793;
L795: ( C309 := C310 ) in D155 by L794;
L796: (ex B291 being (Element of R2) st (( C309 := C310 ) = B291 & B291 in ( ElementaryInstructions R2 ) & (for B292 being (Element of ( Funcs (R3 , ( INT )) )) holds ( R5 . (B292 , B291) ) = ( B292 +* (( C309 . B292 ) , ( C310 . B292 )) )))) by L795;
thus L797: thesis by L796;
end;
registration
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C312 being (INT-Variable of R2 , R5);
let C313 being (INT-Expression of R2 , R5);
cluster ( C312 := C313 ) ->  absolutely-terminating;
coherence by L790 , AOFA_000:95;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C314 being (INT-Variable of R2 , R5);
let C315 being (INT-Expression of R2 , R5);
func C314 += C315 ->  absolutely-terminating (Element of R2) equals 
( C314 := ( ( . C314 ) + C315 ) );
coherence;
func C314 *= C315 ->  absolutely-terminating (Element of R2) equals 
( C314 := ( ( . C314 ) (#) C315 ) );
coherence;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C316 being (Element of R3);
let C317 being (INT-Expression of R2 , R5);
func C316 := C317 ->  absolutely-terminating (Element of R2) equals 
( ( C316 ^ (R2 , R5) ) := C317 );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C318 being (Element of R3);
let C319 being (Variable of R5);
func C318 := C319 ->  absolutely-terminating (Element of R2) equals 
( C318 := ( . C319 ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C320 being (Element of R3);
let C321 being (INT-Variable of R2 , R5);
func C320 := C321 ->  absolutely-terminating (Element of R2) equals 
( C320 := ( . C321 ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C322 , C323 being (INT-Variable of R2 , R5);
func C322 := C323 ->  absolutely-terminating (Element of R2) equals 
( C322 := ( . C323 ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C324 being (Variable of R5);
let C325 being  integer number;
func C324 := C325 ->  absolutely-terminating (Element of R2) equals 
( C324 := ( . (C325 , R2 , R5) ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C326 , C327 being (INT-Variable of R2 , R5);
let C328 being (Variable of R5);
func swap (C326 , C328 , C327) ->  absolutely-terminating (Element of R2) equals 
( ( ( C328 := C326 ) \; ( C326 := C327 ) ) \; ( C327 := ( . C328 ) ) );
coherence;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C329 being (Variable of R5);
let C330 being (INT-Expression of R2 , R5);
func C329 += C330 ->  absolutely-terminating (Element of R2) equals 
( C329 := ( ( . C329 ) + C330 ) );
correctness;
func C329 *= C330 ->  absolutely-terminating (Element of R2) equals 
( C329 := ( ( . C329 ) (#) C330 ) );
correctness;
func C329 %= C330 ->  absolutely-terminating (Element of R2) equals 
( C329 := ( ( . C329 ) mod C330 ) );
correctness;
func C329 /= C330 ->  absolutely-terminating (Element of R2) equals 
( C329 := ( ( . C329 ) div C330 ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C331 being (Variable of R5);
let C332 being  integer number;
func C331 += C332 ->  absolutely-terminating (Element of R2) equals 
( C331 := ( ( . C331 ) + C332 ) );
correctness;
func C331 *= C332 ->  absolutely-terminating (Element of R2) equals 
( C331 := ( ( . C331 ) * C332 ) );
correctness;
func C331 %= C332 ->  absolutely-terminating (Element of R2) equals 
( C331 := ( ( . C331 ) mod ( . (C332 , R2 , R5) ) ) );
correctness;
func C331 /= C332 ->  absolutely-terminating (Element of R2) equals 
( C331 := ( ( . C331 ) div ( . (C332 , R2 , R5) ) ) );
correctness;
func C331 div C332 -> (INT-Expression of R2 , R5) equals 
( ( . C331 ) div ( . (C332 , R2 , R5) ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C333 being (INT-Variable of R2 , R5);
let C334 being  integer number;
func C333 := C334 ->  absolutely-terminating (Element of R2) equals 
( C333 := ( . (C334 , R2 , R5) ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C335 being (INT-Variable of R2 , R5);
let C336 being  integer number;
func C335 += C336 ->  absolutely-terminating (Element of R2) equals 
( C335 := ( ( . C335 ) + C336 ) );
correctness;
func C335 *= C336 ->  absolutely-terminating (Element of R2) equals 
( C335 := ( ( . C335 ) * C336 ) );
correctness;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C337 being (Element of R3);
let C338 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C337 , ( 0 )) ));
let C339 being (INT-Expression of R2 , C338);
func C339 is_odd ->  absolutely-terminating (Element of R2) equals 
( C337 := ( C339 mod ( . (2 , R2 , C338) ) ) );
coherence;
func C339 is_even ->  absolutely-terminating (Element of R2) equals 
( C337 := ( ( C339 + 1 ) mod ( . (2 , R2 , C338) ) ) );
coherence;
let C340 being (INT-Expression of R2 , C338);
func C339 leq C340 ->  absolutely-terminating (Element of R2) equals 
( C337 := ( leq (C339 , C340) ) );
coherence;
func C339 gt C340 ->  absolutely-terminating (Element of R2) equals 
( C337 := ( gt (C339 , C340) ) );
coherence;
func C339 eq C340 ->  absolutely-terminating (Element of R2) equals 
( C337 := ( eq (C339 , C340) ) );
coherence;
end;
notation
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C341 being (Element of R3);
let C342 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C341 , ( 0 )) ));
let C343 , C344 being (INT-Expression of R2 , C342);
synonym C344 geq C343 for C343 leq C344;
synonym C344 lt C343 for C343 gt C344;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C345 being (Element of R3);
let C346 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C345 , ( 0 )) ));
let C347 , C348 being (INT-Variable of R2 , C346);
func C347 leq C348 ->  absolutely-terminating (Element of R2) equals 
( ( . C347 ) leq ( . C348 ) );
coherence;
func C347 gt C348 ->  absolutely-terminating (Element of R2) equals 
( ( . C347 ) gt ( . C348 ) );
coherence;
end;
notation
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C349 being (Element of R3);
let C350 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C349 , ( 0 )) ));
let C351 , C352 being (INT-Variable of R2 , C350);
synonym C352 geq C351 for C351 leq C352;
synonym C352 lt C351 for C351 gt C352;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C353 being (Element of R3);
let C354 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C353 , ( 0 )) ));
let C355 being (Variable of C354);
func C355 is_odd ->  absolutely-terminating (Element of R2) equals 
( ( . C355 ) is_odd );
coherence;
func C355 is_even ->  absolutely-terminating (Element of R2) equals 
( ( . C355 ) is_even );
coherence;
let C356 being (Variable of C354);
func C355 leq C356 ->  absolutely-terminating (Element of R2) equals 
( ( . C355 ) leq ( . C356 ) );
coherence;
func C355 gt C356 ->  absolutely-terminating (Element of R2) equals 
( ( . C355 ) gt ( . C356 ) );
coherence;
end;
notation
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C357 being (Element of R3);
let C358 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C357 , ( 0 )) ));
let C359 , C360 being (Variable of C358);
synonym C360 geq C359 for C359 leq C360;
synonym C360 lt C359 for C359 gt C360;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let C361 being (Element of R3);
let C362 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , ( ( Funcs (R3 , ( INT )) ) \ (C361 , ( 0 )) ));
let C363 being (Variable of C362);
let C364 being  integer number;
func C363 leq C364 ->  absolutely-terminating (Element of R2) equals 
( ( . C363 ) leq ( . (C364 , R2 , C362) ) );
coherence;
func C363 geq C364 ->  absolutely-terminating (Element of R2) equals 
( ( . C363 ) geq ( . (C364 , R2 , C362) ) );
coherence;
func C363 gt C364 ->  absolutely-terminating (Element of R2) equals 
( ( . C363 ) gt ( . (C364 , R2 , C362) ) );
coherence;
func C363 lt C364 ->  absolutely-terminating (Element of R2) equals 
( ( . C363 ) lt ( . (C364 , R2 , C362) ) );
coherence;
func C363 / C364 -> (INT-Expression of R2 , C362) equals 
( ( . C363 ) div ( . (C364 , R2 , C362) ) );
coherence;
end;
definition
let R2 being  Euclidean preIfWhileAlgebra;
let R3 being non  empty  countable set;
let R4 being (Subset of ( Funcs (R3 , ( INT )) ));
let R5 being  Euclidean (ExecutionFunction of R2 , ( Funcs (R3 , ( INT )) ) , R4);
let C365 , C366 being (Variable of R5);
func C365 += C366 ->  absolutely-terminating (Element of R2) equals 
( C365 += ( . C366 ) );
coherence;
func C365 *= C366 ->  absolutely-terminating (Element of R2) equals 
( C365 *= ( . C366 ) );
coherence;
func C365 %= C366 ->  absolutely-terminating (Element of R2) equals 
( C365 := ( ( . C365 ) mod ( . C366 ) ) );
coherence;
func C365 /= C366 ->  absolutely-terminating (Element of R2) equals 
( C365 := ( ( . C365 ) div ( . C366 ) ) );
coherence;
func C365 + C366 -> (INT-Expression of R2 , R5) equals 
( ( . C365 ) + ( . C366 ) );
coherence;
func C365 * C366 -> (INT-Expression of R2 , R5) equals 
( ( . C365 ) (#) ( . C366 ) );
coherence;
func C365 mod C366 -> (INT-Expression of R2 , R5) equals 
( ( . C365 ) mod ( . C366 ) );
coherence;
func C365 div C366 -> (INT-Expression of R2 , R5) equals 
( ( . C365 ) div ( . C366 ) );
coherence;
end;
theorem
L818: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R13 being (INT-Variable of R6 , R12) holds (for R14 being (INT-Expression of R6 , R12) holds (( ( R12 . (R9 , ( R13 := R14 )) ) . ( R13 . R9 ) ) = ( R14 . R9 ) & (for R8 being (Element of R7) holds (R8 <> ( R13 . R9 ) implies ( ( R12 . (R9 , ( R13 := R14 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R13 being (INT-Variable of R6 , R12);
let R14 being (INT-Expression of R6 , R12);
set D156 = { B293 where B293 is (Element of R6) : (B293 in ( ElementaryInstructions R6 ) & (for B294 being (Element of ( Funcs (R7 , ( INT )) )) holds ( R12 . (B294 , B293) ) = ( B294 +* (( R13 . B294 ) , ( R14 . B294 )) ))) };
L819: R13 , R14 form_assignment_wrt R12 by L468;
consider C367 being (Element of R6) such that L820: C367 in ( ElementaryInstructions R6 ) and L821: (for B295 being (Element of ( Funcs (R7 , ( INT )) )) holds ( R12 . (B295 , C367) ) = ( B295 +* (( R13 . B295 ) , ( R14 . B295 )) )) by L819 , L419;
L822: C367 in D156 by L820 , L821;
L823: ( R13 := R14 ) in D156 by L822;
L824: (ex B296 being (Element of R6) st (( R13 := R14 ) = B296 & B296 in ( ElementaryInstructions R6 ) & (for B297 being (Element of ( Funcs (R7 , ( INT )) )) holds ( R12 . (B297 , B296) ) = ( B297 +* (( R13 . B297 ) , ( R14 . B297 )) )))) by L823;
L825: ( R12 . (R9 , ( R13 := R14 )) ) = ( R9 +* (( R13 . R9 ) , ( R14 . R9 )) ) by L824;
L826: ( dom R9 ) = R7 by FUNCT_2:def 1;
thus L827: thesis by L826 , L825 , FUNCT_7:31 , FUNCT_7:32;
end;
theorem
L828: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B298 being (Variable of R12) holds (for B299 being  integer number holds (( ( R12 . (R9 , ( B298 := B299 )) ) . B298 ) = B299 & (for R8 being (Element of R7) holds (R8 <> B298 implies ( ( R12 . (R9 , ( B298 := B299 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C368 being (Variable of R12);
let C369 being  integer number;
L829: ( ( . (C369 , R6 , R12) ) . R9 ) = C369 by FUNCOP_1:7;
L830: ( ( ^ C368 ) . R9 ) = C368 by FUNCOP_1:7;
thus L831: thesis by L830 , L829 , L818;
end;
theorem
L832: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B300 being (Variable of R12) holds (for B301 being (INT-Expression of R6 , R12) holds (( ( R12 . (R9 , ( B300 := B301 )) ) . B300 ) = ( B301 . R9 ) & (for R8 being (Element of R7) holds (R8 <> B300 implies ( ( R12 . (R9 , ( B300 := B301 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C370 being (Variable of R12);
let C371 being (INT-Expression of R6 , R12);
L833: ( ( ^ C370 ) . R9 ) = C370 by FUNCOP_1:7;
thus L834: thesis by L833 , L818;
end;
theorem
L835: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B302 , B303 being (Variable of R12) holds (( ( R12 . (R9 , ( B302 := B303 )) ) . B302 ) = ( R9 . B303 ) & (for R8 being (Element of R7) holds (R8 <> B302 implies ( ( R12 . (R9 , ( B302 := B303 )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C372 , C373 being (Variable of R12);
L836: ( ( . C373 ) . R9 ) = ( R9 . C373 ) by L776;
thus L837: thesis by L836 , L832;
end;
theorem
L838: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R15 being  integer number holds (for B304 being (Variable of R12) holds (( ( R12 . (R9 , ( B304 += R15 )) ) . B304 ) = ( ( R9 . B304 ) + R15 ) & (for R8 being (Element of R7) holds (R8 <> B304 implies ( ( R12 . (R9 , ( B304 += R15 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R15 being  integer number;
let C374 being (Variable of R12);
L839: ( ( ^ C374 ) . R9 ) = C374 by FUNCOP_1:7;
L840: ( ( . ( ^ (C374 qua (Element of R7)) ) ) . R9 ) = ( R9 . ( ( ^ (C374 qua (Element of R7)) ) . R9 ) ) by L442;
L841: ( ( ( . C374 ) + R15 ) . R9 ) = ( ( ( . C374 ) . R9 ) + R15 ) by L113;
thus L842: thesis by L841 , L839 , L840 , L818;
end;
theorem
L843: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B305 being (Variable of R12) holds (for B306 being (INT-Expression of R6 , R12) holds (( ( R12 . (R9 , ( B305 += B306 )) ) . B305 ) = ( ( R9 . B305 ) + ( B306 . R9 ) ) & (for R8 being (Element of R7) holds (R8 <> B305 implies ( ( R12 . (R9 , ( B305 += B306 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C375 being (Variable of R12);
let C376 being (INT-Expression of R6 , R12);
L844: ( ( ^ C375 ) . R9 ) = C375 by FUNCOP_1:7;
L845: ( dom ( ( . C375 ) + C376 ) ) = ( Funcs (R7 , ( INT )) ) by FUNCT_2:def 1;
L846: ( ( ( . C375 ) + C376 ) . R9 ) = ( ( ( . C375 ) . R9 ) + ( C376 . R9 ) ) by L845 , VALUED_1:def 1;
L847: ( ( . C375 ) . R9 ) = ( R9 . C375 ) by L776;
thus L848: thesis by L847 , L844 , L846 , L818;
end;
theorem
L849: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B307 , B308 being (Variable of R12) holds (( ( R12 . (R9 , ( B307 += B308 )) ) . B307 ) = ( ( R9 . B307 ) + ( R9 . B308 ) ) & (for R8 being (Element of R7) holds (R8 <> B307 implies ( ( R12 . (R9 , ( B307 += B308 )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C377 , C378 being (Variable of R12);
L850: ( ( . C378 ) . R9 ) = ( R9 . C378 ) by L776;
thus L851: thesis by L850 , L843;
end;
theorem
L852: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R15 being  integer number holds (for B309 being (Variable of R12) holds (( ( R12 . (R9 , ( B309 *= R15 )) ) . B309 ) = ( ( R9 . B309 ) * R15 ) & (for R8 being (Element of R7) holds (R8 <> B309 implies ( ( R12 . (R9 , ( B309 *= R15 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R15 being  integer number;
let C379 being (Variable of R12);
L853: ( ( ^ C379 ) . R9 ) = C379 by FUNCOP_1:7;
L854: ( ( . ( ^ (C379 qua (Element of R7)) ) ) . R9 ) = ( R9 . ( ( ^ (C379 qua (Element of R7)) ) . R9 ) ) by L442;
L855: ( ( ( . C379 ) * R15 ) . R9 ) = ( ( ( . C379 ) . R9 ) * R15 ) by L133;
thus L856: thesis by L855 , L853 , L854 , L818;
end;
theorem
L857: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B310 being (Variable of R12) holds (for B311 being (INT-Expression of R6 , R12) holds (( ( R12 . (R9 , ( B310 *= B311 )) ) . B310 ) = ( ( R9 . B310 ) * ( B311 . R9 ) ) & (for R8 being (Element of R7) holds (R8 <> B310 implies ( ( R12 . (R9 , ( B310 *= B311 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C380 being (Variable of R12);
let C381 being (INT-Expression of R6 , R12);
L858: ( ( ^ C380 ) . R9 ) = C380 by FUNCOP_1:7;
L859: ( dom ( ( . C380 ) (#) C381 ) ) = ( Funcs (R7 , ( INT )) ) by FUNCT_2:def 1;
L860: ( ( ( . C380 ) (#) C381 ) . R9 ) = ( ( ( . C380 ) . R9 ) * ( C381 . R9 ) ) by L859 , VALUED_1:def 4;
L861: ( ( . C380 ) . R9 ) = ( R9 . C380 ) by L776;
thus L862: thesis by L861 , L858 , L860 , L818;
end;
theorem
L863: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B312 , B313 being (Variable of R12) holds (( ( R12 . (R9 , ( B312 *= B313 )) ) . B312 ) = ( ( R9 . B312 ) * ( R9 . B313 ) ) & (for R8 being (Element of R7) holds (R8 <> B312 implies ( ( R12 . (R9 , ( B312 *= B313 )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C382 , C383 being (Variable of R12);
L864: ( dom ( ( . C382 ) (#) ( . C383 ) ) ) = ( Funcs (R7 , ( INT )) ) by FUNCT_2:def 1;
L865: ( ( ^ C382 ) . R9 ) = C382 by FUNCOP_1:7;
thus L866: ( ( R12 . (R9 , ( C382 *= C383 )) ) . C382 ) = ( ( ( . C382 ) (#) ( . C383 ) ) . R9 ) by L865 , L818
.= ( ( ( . C382 ) . R9 ) * ( ( . C383 ) . R9 ) ) by L864 , VALUED_1:def 4
.= ( ( R9 . C382 ) * ( ( . C383 ) . R9 ) ) by L776
.= ( ( R9 . C382 ) * ( R9 . C383 ) ) by L776;
thus L867: thesis by L832;
end;
theorem
L868: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B314 being (Element of R7) holds (for B315 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B314 , ( 0 )) )) holds (for B316 being (Variable of B315) holds (for B317 being  integer number holds ((( R9 . B316 ) <= B317 implies ( ( B315 . (R9 , ( B316 leq B317 )) ) . B314 ) = 1) & (( R9 . B316 ) > B317 implies ( ( B315 . (R9 , ( B316 leq B317 )) ) . B314 ) = ( 0 )) & (( R9 . B316 ) >= B317 implies ( ( B315 . (R9 , ( B316 geq B317 )) ) . B314 ) = 1) & (( R9 . B316 ) < B317 implies ( ( B315 . (R9 , ( B316 geq B317 )) ) . B314 ) = ( 0 )) & (for R8 being (Element of R7) holds (R8 <> B314 implies (( ( B315 . (R9 , ( B316 leq B317 )) ) . R8 ) = ( R9 . R8 ) & ( ( B315 . (R9 , ( B316 geq B317 )) ) . R8 ) = ( R9 . R8 ))))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C384 being (Element of R7);
let C385 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C384 , ( 0 )) ));
reconsider D157 = C384 as (Variable of C385) by L24;
let C386 being (Variable of C385);
let C387 being  integer number;
set D158 = ( ^ D157 );
L869: ( ( . (C387 , R6 , C385) ) . R9 ) = C387 by FUNCOP_1:7;
L870: ( D158 . R9 ) = C384 by FUNCOP_1:7;
L871: (( ( . C386 ) . R9 ) < C387 implies ( IFGT (C387 , ( ( . C386 ) . R9 ) , ( 0 ) , 1) ) = ( 0 )) by XXREAL_0:def 11;
L872: (( ( . C386 ) . R9 ) >= C387 implies ( IFGT (C387 , ( ( . C386 ) . R9 ) , ( 0 ) , 1) ) = 1) by XXREAL_0:def 11;
L873: ( ( leq (( . (C387 , R6 , C385) ) , ( . C386 )) ) . R9 ) = ( IFGT (( ( . (C387 , R6 , C385) ) . R9 ) , ( ( . C386 ) . R9 ) , ( 0 ) , 1) ) by L732;
L874: (( ( . C386 ) . R9 ) > C387 implies ( IFGT (( ( . C386 ) . R9 ) , C387 , ( 0 ) , 1) ) = ( 0 )) by XXREAL_0:def 11;
L875: ( ( leq (( . C386 ) , ( . (C387 , R6 , C385) )) ) . R9 ) = ( IFGT (( ( . C386 ) . R9 ) , ( ( . (C387 , R6 , C385) ) . R9 ) , ( 0 ) , 1) ) by L732;
L876: (( ( . C386 ) . R9 ) <= C387 implies ( IFGT (( ( . C386 ) . R9 ) , C387 , ( 0 ) , 1) ) = 1) by XXREAL_0:def 11;
L877: ( ( . C386 ) . R9 ) = ( R9 . ( ( ^ C386 ) . R9 ) ) by L442;
thus L878: thesis by L877 , L869 , L870 , L876 , L874 , L872 , L871 , L875 , L873 , L818 , FUNCOP_1:7;
end;
theorem
L879: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B318 being (Element of R7) holds (for B319 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B318 , ( 0 )) )) holds (for B320 , B321 being (Variable of B319) holds ((( R9 . B320 ) <= ( R9 . B321 ) implies ( ( B319 . (R9 , ( B320 leq B321 )) ) . B318 ) = 1) & (( R9 . B320 ) > ( R9 . B321 ) implies ( ( B319 . (R9 , ( B320 leq B321 )) ) . B318 ) = ( 0 )) & (for R8 being (Element of R7) holds (R8 <> B318 implies ( ( B319 . (R9 , ( B320 leq B321 )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C388 being (Element of R7);
let C389 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C388 , ( 0 )) ));
reconsider D159 = C388 as (Variable of C389) by L24;
let C390 , C391 being (Variable of C389);
set D160 = ( ^ D159 );
L880: ( D160 . R9 ) = C388 by FUNCOP_1:7;
L881: (( ( . C390 ) . R9 ) <= ( ( . C391 ) . R9 ) implies ( IFGT (( ( . C390 ) . R9 ) , ( ( . C391 ) . R9 ) , ( 0 ) , 1) ) = 1) by XXREAL_0:def 11;
L882: ( ( . C390 ) . R9 ) = ( R9 . ( ( ^ C390 ) . R9 ) ) by L442;
L883: ( R9 . C390 ) = ( ( . C390 ) . R9 ) by L882 , FUNCOP_1:7;
L884: (( ( . C390 ) . R9 ) > ( ( . C391 ) . R9 ) implies ( IFGT (( ( . C390 ) . R9 ) , ( ( . C391 ) . R9 ) , ( 0 ) , 1) ) = ( 0 )) by XXREAL_0:def 11;
L885: ( ( leq (( . C390 ) , ( . C391 )) ) . R9 ) = ( IFGT (( ( . C390 ) . R9 ) , ( ( . C391 ) . R9 ) , ( 0 ) , 1) ) by L732;
L886: ( ( . C391 ) . R9 ) = ( R9 . ( ( ^ C391 ) . R9 ) ) by L442;
thus L887: thesis by L886 , L883 , L880 , L881 , L884 , L885 , L818 , FUNCOP_1:7;
end;
theorem
L888: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B322 being (Element of R7) holds (for B323 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B322 , ( 0 )) )) holds (for B324 being (Variable of B323) holds (for B325 being  integer number holds ((( R9 . B324 ) <= B325 iff ( B323 . (R9 , ( B324 leq B325 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B322 , ( 0 )) )) & (( R9 . B324 ) >= B325 iff ( B323 . (R9 , ( B324 geq B325 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B322 , ( 0 )) ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C392 being (Element of R7);
let C393 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C392 , ( 0 )) ));
let C394 being (Variable of C393);
let C395 being  integer number;
L889: (( C393 . (R9 , ( C394 leq C395 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C392 , ( 0 )) ) iff ( ( C393 . (R9 , ( C394 leq C395 )) ) . C392 ) <> ( 0 )) by L21;
thus L890: (( R9 . C394 ) <= C395 iff ( C393 . (R9 , ( C394 leq C395 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C392 , ( 0 )) )) by L889 , L868;
L891: (( C393 . (R9 , ( C394 geq C395 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C392 , ( 0 )) ) iff ( ( C393 . (R9 , ( C394 geq C395 )) ) . C392 ) <> ( 0 )) by L21;
thus L892: thesis by L891 , L868;
end;
theorem
L893: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B326 being (Element of R7) holds (for B327 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B326 , ( 0 )) )) holds (for B328 , B329 being (Variable of B327) holds ((( R9 . B328 ) <= ( R9 . B329 ) iff ( B327 . (R9 , ( B328 leq B329 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B326 , ( 0 )) )) & (( R9 . B328 ) >= ( R9 . B329 ) iff ( B327 . (R9 , ( B328 geq B329 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B326 , ( 0 )) )))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C396 being (Element of R7);
let C397 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C396 , ( 0 )) ));
let C398 , C399 being (Variable of C397);
L894: (( C397 . (R9 , ( C398 leq C399 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C396 , ( 0 )) ) iff ( ( C397 . (R9 , ( C398 leq C399 )) ) . C396 ) <> ( 0 )) by L21;
thus L895: (( R9 . C398 ) <= ( R9 . C399 ) iff ( C397 . (R9 , ( C398 leq C399 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C396 , ( 0 )) )) by L894 , L879;
L896: (( C397 . (R9 , ( C398 geq C399 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C396 , ( 0 )) ) iff ( ( C397 . (R9 , ( C398 geq C399 )) ) . C396 ) <> ( 0 )) by L21;
thus L897: thesis by L896 , L879;
end;
theorem
L898: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B330 being (Element of R7) holds (for B331 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B330 , ( 0 )) )) holds (for B332 being (Variable of B331) holds (for B333 being  integer number holds ((( R9 . B332 ) > B333 implies ( ( B331 . (R9 , ( B332 gt B333 )) ) . B330 ) = 1) & (( R9 . B332 ) <= B333 implies ( ( B331 . (R9 , ( B332 gt B333 )) ) . B330 ) = ( 0 )) & (( R9 . B332 ) < B333 implies ( ( B331 . (R9 , ( B332 lt B333 )) ) . B330 ) = 1) & (( R9 . B332 ) >= B333 implies ( ( B331 . (R9 , ( B332 lt B333 )) ) . B330 ) = ( 0 )) & (for R8 being (Element of R7) holds (R8 <> B330 implies (( ( B331 . (R9 , ( B332 gt B333 )) ) . R8 ) = ( R9 . R8 ) & ( ( B331 . (R9 , ( B332 lt B333 )) ) . R8 ) = ( R9 . R8 ))))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C400 being (Element of R7);
let C401 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C400 , ( 0 )) ));
reconsider D161 = C400 as (Variable of C401) by L24;
let C402 being (Variable of C401);
let C403 being  integer number;
set D162 = ( ^ D161 );
L899: ( ( . (C403 , R6 , C401) ) . R9 ) = C403 by FUNCOP_1:7;
L900: ( D162 . R9 ) = C400 by FUNCOP_1:7;
L901: (( ( . C402 ) . R9 ) >= C403 implies ( IFGT (C403 , ( ( . C402 ) . R9 ) , 1 , ( 0 )) ) = ( 0 )) by XXREAL_0:def 11;
L902: (( ( . C402 ) . R9 ) < C403 implies ( IFGT (C403 , ( ( . C402 ) . R9 ) , 1 , ( 0 )) ) = 1) by XXREAL_0:def 11;
L903: ( ( gt (( . (C403 , R6 , C401) ) , ( . C402 )) ) . R9 ) = ( IFGT (( ( . (C403 , R6 , C401) ) . R9 ) , ( ( . C402 ) . R9 ) , 1 , ( 0 )) ) by L741;
L904: (( ( . C402 ) . R9 ) <= C403 implies ( IFGT (( ( . C402 ) . R9 ) , C403 , 1 , ( 0 )) ) = ( 0 )) by XXREAL_0:def 11;
L905: ( ( gt (( . C402 ) , ( . (C403 , R6 , C401) )) ) . R9 ) = ( IFGT (( ( . C402 ) . R9 ) , ( ( . (C403 , R6 , C401) ) . R9 ) , 1 , ( 0 )) ) by L741;
L906: (( ( . C402 ) . R9 ) > C403 implies ( IFGT (( ( . C402 ) . R9 ) , C403 , 1 , ( 0 )) ) = 1) by XXREAL_0:def 11;
L907: ( ( . C402 ) . R9 ) = ( R9 . ( ( ^ C402 ) . R9 ) ) by L442;
thus L908: thesis by L907 , L899 , L900 , L906 , L904 , L902 , L901 , L905 , L903 , L818 , FUNCOP_1:7;
end;
theorem
L909: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B334 being (Element of R7) holds (for B335 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B334 , ( 0 )) )) holds (for B336 , B337 being (Variable of B335) holds ((( R9 . B336 ) > ( R9 . B337 ) implies ( ( B335 . (R9 , ( B336 gt B337 )) ) . B334 ) = 1) & (( R9 . B336 ) <= ( R9 . B337 ) implies ( ( B335 . (R9 , ( B336 gt B337 )) ) . B334 ) = ( 0 )) & (( R9 . B336 ) < ( R9 . B337 ) implies ( ( B335 . (R9 , ( B336 lt B337 )) ) . B334 ) = 1) & (( R9 . B336 ) >= ( R9 . B337 ) implies ( ( B335 . (R9 , ( B336 lt B337 )) ) . B334 ) = ( 0 )) & (for R8 being (Element of R7) holds (R8 <> B334 implies (( ( B335 . (R9 , ( B336 gt B337 )) ) . R8 ) = ( R9 . R8 ) & ( ( B335 . (R9 , ( B336 lt B337 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C404 being (Element of R7);
let C405 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C404 , ( 0 )) ));
reconsider D163 = C404 as (Variable of C405) by L24;
let C406 , C407 being (Variable of C405);
set D164 = ( ^ D163 );
L910: ( D164 . R9 ) = C404 by FUNCOP_1:7;
L911: (( ( . C406 ) . R9 ) > ( ( . C407 ) . R9 ) implies ( IFGT (( ( . C406 ) . R9 ) , ( ( . C407 ) . R9 ) , 1 , ( 0 )) ) = 1) by XXREAL_0:def 11;
L912: ( ( gt (( . C406 ) , ( . C407 )) ) . R9 ) = ( IFGT (( ( . C406 ) . R9 ) , ( ( . C407 ) . R9 ) , 1 , ( 0 )) ) by L741;
L913: (( ( . C406 ) . R9 ) < ( ( . C407 ) . R9 ) implies ( IFGT (( ( . C407 ) . R9 ) , ( ( . C406 ) . R9 ) , 1 , ( 0 )) ) = 1) by XXREAL_0:def 11;
L914: ( ( . C406 ) . R9 ) = ( R9 . ( ( ^ C406 ) . R9 ) ) by L442;
L915: ( R9 . C406 ) = ( ( . C406 ) . R9 ) by L914 , FUNCOP_1:7;
L916: (( ( . C406 ) . R9 ) <= ( ( . C407 ) . R9 ) implies ( IFGT (( ( . C406 ) . R9 ) , ( ( . C407 ) . R9 ) , 1 , ( 0 )) ) = ( 0 )) by XXREAL_0:def 11;
L917: ( ( gt (( . C407 ) , ( . C406 )) ) . R9 ) = ( IFGT (( ( . C407 ) . R9 ) , ( ( . C406 ) . R9 ) , 1 , ( 0 )) ) by L741;
L918: (( ( . C406 ) . R9 ) >= ( ( . C407 ) . R9 ) implies ( IFGT (( ( . C407 ) . R9 ) , ( ( . C406 ) . R9 ) , 1 , ( 0 )) ) = ( 0 )) by XXREAL_0:def 11;
L919: ( ( . C407 ) . R9 ) = ( R9 . ( ( ^ C407 ) . R9 ) ) by L442;
thus L920: thesis by L919 , L915 , L910 , L911 , L916 , L913 , L918 , L912 , L917 , L818 , FUNCOP_1:7;
end;
theorem
L921: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B338 being (Element of R7) holds (for B339 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B338 , ( 0 )) )) holds (for B340 being (Variable of B339) holds (for B341 being  integer number holds ((( R9 . B340 ) > B341 iff ( B339 . (R9 , ( B340 gt B341 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B338 , ( 0 )) )) & (( R9 . B340 ) < B341 iff ( B339 . (R9 , ( B340 lt B341 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B338 , ( 0 )) ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C408 being (Element of R7);
let C409 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C408 , ( 0 )) ));
let C410 being (Variable of C409);
let C411 being  integer number;
L922: (( C409 . (R9 , ( C410 gt C411 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C408 , ( 0 )) ) iff ( ( C409 . (R9 , ( C410 gt C411 )) ) . C408 ) <> ( 0 )) by L21;
thus L923: (( R9 . C410 ) > C411 iff ( C409 . (R9 , ( C410 gt C411 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C408 , ( 0 )) )) by L922 , L898;
L924: (( C409 . (R9 , ( C410 lt C411 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C408 , ( 0 )) ) iff ( ( C409 . (R9 , ( C410 lt C411 )) ) . C408 ) <> ( 0 )) by L21;
thus L925: thesis by L924 , L898;
end;
theorem
L926: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B342 being (Element of R7) holds (for B343 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B342 , ( 0 )) )) holds (for B344 , B345 being (Variable of B343) holds ((( R9 . B344 ) > ( R9 . B345 ) iff ( B343 . (R9 , ( B344 gt B345 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B342 , ( 0 )) )) & (( R9 . B344 ) < ( R9 . B345 ) iff ( B343 . (R9 , ( B344 lt B345 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B342 , ( 0 )) )))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C412 being (Element of R7);
let C413 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C412 , ( 0 )) ));
let C414 , C415 being (Variable of C413);
L927: (( C413 . (R9 , ( C414 gt C415 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C412 , ( 0 )) ) iff ( ( C413 . (R9 , ( C414 gt C415 )) ) . C412 ) <> ( 0 )) by L21;
thus L928: (( R9 . C414 ) > ( R9 . C415 ) iff ( C413 . (R9 , ( C414 gt C415 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C412 , ( 0 )) )) by L927 , L909;
L929: (( C413 . (R9 , ( C414 lt C415 )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C412 , ( 0 )) ) iff ( ( C413 . (R9 , ( C414 lt C415 )) ) . C412 ) <> ( 0 )) by L21;
thus L930: thesis by L929 , L909;
end;
theorem
L931: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R15 being  integer number holds (for B346 being (Variable of R12) holds (( ( R12 . (R9 , ( B346 %= R15 )) ) . B346 ) = ( ( R9 . B346 ) mod R15 ) & (for R8 being (Element of R7) holds (R8 <> B346 implies ( ( R12 . (R9 , ( B346 %= R15 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R15 being  integer number;
let C416 being (Variable of R12);
L932: ( ( . (R15 , R6 , R12) ) . R9 ) = R15 by FUNCOP_1:7;
L933: ( ( ^ C416 ) . R9 ) = C416 by FUNCOP_1:7;
L934: ( ( . ( ^ (C416 qua (Element of R7)) ) ) . R9 ) = ( R9 . ( ( ^ (C416 qua (Element of R7)) ) . R9 ) ) by L442;
L935: ( ( ( . C416 ) mod ( . (R15 , R6 , R12) ) ) . R9 ) = ( ( ( . C416 ) . R9 ) mod ( ( . (R15 , R6 , R12) ) . R9 ) ) by L723;
thus L936: thesis by L935 , L932 , L933 , L934 , L818;
end;
theorem
L937: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B347 being (Variable of R12) holds (for B348 being (INT-Expression of R6 , R12) holds (( ( R12 . (R9 , ( B347 %= B348 )) ) . B347 ) = ( ( R9 . B347 ) mod ( B348 . R9 ) ) & (for R8 being (Element of R7) holds (R8 <> B347 implies ( ( R12 . (R9 , ( B347 %= B348 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C417 being (Variable of R12);
let C418 being (INT-Expression of R6 , R12);
L938: ( ( ^ C417 ) . R9 ) = C417 by FUNCOP_1:7;
L939: ( ( . C417 ) . R9 ) = ( R9 . C417 ) by L776;
L940: ( ( ( . C417 ) mod C418 ) . R9 ) = ( ( ( . C417 ) . R9 ) mod ( C418 . R9 ) ) by L723;
thus L941: thesis by L940 , L938 , L939 , L818;
end;
theorem
L942: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B349 , B350 being (Variable of R12) holds (( ( R12 . (R9 , ( B349 %= B350 )) ) . B349 ) = ( ( R9 . B349 ) mod ( R9 . B350 ) ) & (for R8 being (Element of R7) holds (R8 <> B349 implies ( ( R12 . (R9 , ( B349 %= B350 )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C419 , C420 being (Variable of R12);
L943: ( C419 %= C420 ) = ( C419 %= ( . C420 ) );
L944: ( ( . C420 ) . R9 ) = ( R9 . C420 ) by L776;
thus L945: thesis by L944 , L943 , L937;
end;
theorem
L946: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R15 being  integer number holds (for B351 being (Variable of R12) holds (( ( R12 . (R9 , ( B351 /= R15 )) ) . B351 ) = ( ( R9 . B351 ) div R15 ) & (for R8 being (Element of R7) holds (R8 <> B351 implies ( ( R12 . (R9 , ( B351 /= R15 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R15 being  integer number;
let C421 being (Variable of R12);
L947: ( ( . (R15 , R6 , R12) ) . R9 ) = R15 by FUNCOP_1:7;
L948: ( ( ^ C421 ) . R9 ) = C421 by FUNCOP_1:7;
L949: ( ( . ( ^ (C421 qua (Element of R7)) ) ) . R9 ) = ( R9 . ( ( ^ (C421 qua (Element of R7)) ) . R9 ) ) by L442;
L950: ( ( ( . C421 ) div ( . (R15 , R6 , R12) ) ) . R9 ) = ( ( ( . C421 ) . R9 ) div ( ( . (R15 , R6 , R12) ) . R9 ) ) by L714;
thus L951: thesis by L950 , L947 , L948 , L949 , L818;
end;
theorem
L952: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B352 being (Variable of R12) holds (for B353 being (INT-Expression of R6 , R12) holds (( ( R12 . (R9 , ( B352 /= B353 )) ) . B352 ) = ( ( R9 . B352 ) div ( B353 . R9 ) ) & (for R8 being (Element of R7) holds (R8 <> B352 implies ( ( R12 . (R9 , ( B352 /= B353 )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C422 being (Variable of R12);
let C423 being (INT-Expression of R6 , R12);
L953: ( ( ^ C422 ) . R9 ) = C422 by FUNCOP_1:7;
L954: ( ( . C422 ) . R9 ) = ( R9 . C422 ) by L776;
L955: ( ( ( . C422 ) div C423 ) . R9 ) = ( ( ( . C422 ) . R9 ) div ( C423 . R9 ) ) by L714;
thus L956: thesis by L955 , L953 , L954 , L818;
end;
theorem
L957: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for B354 , B355 being (Variable of R12) holds (( ( R12 . (R9 , ( B354 /= B355 )) ) . B354 ) = ( ( R9 . B354 ) div ( R9 . B355 ) ) & (for R8 being (Element of R7) holds (R8 <> B354 implies ( ( R12 . (R9 , ( B354 /= B355 )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let C424 , C425 being (Variable of R12);
L958: ( C424 /= C425 ) = ( C424 /= ( . C425 ) );
L959: ( ( . C425 ) . R9 ) = ( R9 . C425 ) by L776;
thus L960: thesis by L959 , L958 , L952;
end;
theorem
L961: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B356 being (Element of R7) holds (for B357 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B356 , ( 0 )) )) holds (for B358 being (INT-Expression of R6 , B357) holds (( ( B357 . (R9 , ( B358 is_odd )) ) . B356 ) = ( ( B358 . R9 ) mod 2 ) & ( ( B357 . (R9 , ( B358 is_even )) ) . B356 ) = ( ( ( B358 . R9 ) + 1 ) mod 2 ) & (for R8 being (Element of R7) holds (R8 <> B356 implies (( ( B357 . (R9 , ( B358 is_odd )) ) . R8 ) = ( R9 . R8 ) & ( ( B357 . (R9 , ( B358 is_even )) ) . R8 ) = ( R9 . R8 )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C426 being (Element of R7);
let C427 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C426 , ( 0 )) ));
let C428 being (INT-Expression of R6 , C427);
reconsider D165 = C426 as (Variable of C427) by L24;
L962: ( C428 is_odd ) = ( D165 := ( C428 mod ( . (2 , R6 , C427) ) ) );
L963: ( dom ( C428 + 1 ) ) = ( Funcs (R7 , ( INT )) ) by FUNCT_2:def 1;
L964: ( ( C428 + 1 ) . R9 ) = ( 1 + ( C428 . R9 ) ) by L963 , VALUED_1:def 2;
L965: ( ( . (2 , R6 , C427) ) . R9 ) = 2 by FUNCOP_1:7;
L966: ( ( ( C428 + 1 ) mod ( . (2 , R6 , C427) ) ) . R9 ) = ( ( ( C428 + 1 ) . R9 ) mod 2 ) by L965 , L723;
L967: ( ( C428 mod ( . (2 , R6 , C427) ) ) . R9 ) = ( ( C428 . R9 ) mod 2 ) by L965 , L723;
thus L968: thesis by L967 , L962 , L964 , L966 , L832;
end;
theorem
L969: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B359 being (Element of R7) holds (for B360 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B359 , ( 0 )) )) holds (for B361 being (Variable of B360) holds (( ( B360 . (R9 , ( B361 is_odd )) ) . B359 ) = ( ( R9 . B361 ) mod 2 ) & ( ( B360 . (R9 , ( B361 is_even )) ) . B359 ) = ( ( ( R9 . B361 ) + 1 ) mod 2 ) & (for R8 being (Element of R7) holds (R8 <> B359 implies ( ( B360 . (R9 , ( B361 is_odd )) ) . R8 ) = ( R9 . R8 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C429 being (Element of R7);
let C430 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C429 , ( 0 )) ));
let C431 being (Variable of C430);
L970: ( ( . C431 ) . R9 ) = ( R9 . C431 ) by L776;
thus L971: thesis by L970 , L961;
end;
theorem
L972: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B362 being (Element of R7) holds (for B363 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B362 , ( 0 )) )) holds (for B364 being (INT-Expression of R6 , B363) holds ((( B364 . R9 ) is  odd iff ( B363 . (R9 , ( B364 is_odd )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B362 , ( 0 )) )) & (( B364 . R9 ) is  even iff ( B363 . (R9 , ( B364 is_even )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B362 , ( 0 )) )))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C432 being (Element of R7);
let C433 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C432 , ( 0 )) ));
let C434 being (INT-Expression of R6 , C433);
L973: (( ( C434 . R9 ) mod 2 ) = ( 0 ) or ( ( C434 . R9 ) mod 2 ) = 1) by PRE_FF:6;
L974: ( C434 . R9 ) = ( ( ( ( C434 . R9 ) div 2 ) * 2 ) + ( ( C434 . R9 ) mod 2 ) ) by INT_1:59;
L975: ( ( C433 . (R9 , ( C434 is_odd )) ) . C432 ) = ( ( C434 . R9 ) mod 2 ) by L961;
thus L976: (( C434 . R9 ) is  odd iff ( C433 . (R9 , ( C434 is_odd )) ) in ( ( Funcs (R7 , ( INT )) ) \ (C432 , ( 0 )) )) by L975 , L973 , L974 , L21;
L977: (( ( ( C434 . R9 ) + 1 ) mod 2 ) = ( 0 ) or ( ( ( C434 . R9 ) + 1 ) mod 2 ) = 1) by PRE_FF:6;
L978: ( ( C434 . R9 ) + 1 ) = ( ( ( ( ( C434 . R9 ) + 1 ) div 2 ) * 2 ) + ( ( ( C434 . R9 ) + 1 ) mod 2 ) ) by INT_1:59;
L979: ( ( C433 . (R9 , ( C434 is_even )) ) . C432 ) = ( ( ( C434 . R9 ) + 1 ) mod 2 ) by L961;
thus L980: thesis by L979 , L977 , L978 , L21;
end;
theorem
L981: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B365 being (Element of R7) holds (for B366 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (B365 , ( 0 )) )) holds (for B367 being (Variable of B366) holds ((( R9 . B367 ) is  odd iff ( B366 . (R9 , ( B367 is_odd )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B365 , ( 0 )) )) & (( R9 . B367 ) is  even iff ( B366 . (R9 , ( B367 is_even )) ) in ( ( Funcs (R7 , ( INT )) ) \ (B365 , ( 0 )) )))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C435 being (Element of R7);
let C436 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (C435 , ( 0 )) ));
let C437 being (Variable of C436);
L982: ( ( . C437 ) . R9 ) = ( R9 . C437 ) by L776;
thus L983: thesis by L982 , L972;
end;
scheme ForToIteration { F1() ->  Euclidean preIfWhileAlgebra , F2() ->  countable non  empty set , F3() -> (Element of F2()) , F4 , F5() -> (Element of F1()) , F6() ->  Euclidean (ExecutionFunction of F1() , ( Funcs (F2() , ( INT )) ) , ( ( Funcs (F2() , ( INT )) ) \ (F3() , ( 0 )) )) , F7 , F8() -> (Variable of F6()) , F9() -> (Element of ( Funcs (F2() , ( INT )) )) , F10() -> (INT-Expression of F1() , F6()) , P1[set] } : (P1[ ( F6() . (F9() , F5()) ) ] & (( F10() . F9() ) <= ( F9() . F8() ) implies ( ( F6() . (F9() , F5()) ) . F7() ) = ( ( F9() . F8() ) + 1 )) & (( F10() . F9() ) > ( F9() . F8() ) implies ( ( F6() . (F9() , F5()) ) . F7() ) = ( F10() . F9() )) & ( ( F6() . (F9() , F5()) ) . F8() ) = ( F9() . F8() ))
provided
L984: F5() = ( for-do (( F7() := F10() ) , ( F7() leq F8() ) , ( F7() += 1 ) , F4()) )
and
L985: P1[ ( F6() . (F9() , ( F7() := F10() )) ) ]
and
L986: (for B368 being (Element of ( Funcs (F2() , ( INT )) )) holds (P1[ B368 ] implies (P1[ ( F6() . (B368 , ( F4() \; ( F7() += 1 ) )) ) ] & P1[ ( F6() . (B368 , ( F7() leq F8() )) ) ])))
and
L987: (for B369 being (Element of ( Funcs (F2() , ( INT )) )) holds (P1[ B369 ] implies (( ( F6() . (B369 , F4()) ) . F7() ) = ( B369 . F7() ) & ( ( F6() . (B369 , F4()) ) . F8() ) = ( B369 . F8() ))))
and
L988: (F8() <> F7() & F8() <> F3() & F7() <> F3())
proof
set D166 = ( F7() leq F8() );
set D167 = ( Funcs (F2() , ( INT )) );
reconsider D168 = ( F6() . (F9() , ( F7() := F10() )) ) as (Element of D167);
reconsider D169 = ( F6() . (D168 , D166) ) as (Element of D167);
L989: P1[ D169 ] by L985 , L986;
defpred S7[ (Element of D167) ] means (P1[ $1 ] & (( F10() . F9() ) <= ( F9() . F8() ) implies ( ( $1 . F7() ) - 1 ) <= ( F9() . F8() )) & ( $1 . F8() ) = ( F9() . F8() ));
L990: ( D168 . F7() ) = ( F10() . F9() ) by L832;
L991: ( D169 . F7() ) = ( F10() . F9() ) by L990 , L988 , L879;
defpred S8[ (Element of D167) ] means ( $1 . F7() ) <= ( $1 . F8() );
set D170 = ( D167 \ (F3() , ( 0 )) );
L992: F6() complies_with_while_wrt D170 by AOFA_000:def 32;
set D171 = ( F4() \; ( F7() += 1 ) );
L993: ( F6() . (F9() , F5()) ) = ( F6() . (D168 , ( while (D166 , D171) )) ) by L984 , AOFA_000:def 29;
L994: ( ( F10() . F9() ) - 1 ) < ( F10() . F9() ) by XREAL_1:44;
L995: S7[ D168 ] by L994 , L985 , L988 , L990 , L832 , XXREAL_0:2;
L996: ( D168 . F8() ) = ( F9() . F8() ) by L988 , L832;
L997: ( D169 . F8() ) = ( F9() . F8() ) by L996 , L988 , L879;
per cases ;
suppose L998: ( F10() . F9() ) <= ( F9() . F8() );

deffunc H8((Element of D167)) = ( In (( ( ( $1 . F8() ) + 1 ) - ( $1 . F7() ) ) , ( NAT )) );
defpred S9[ (Element of D167) ] means (P1[ $1 ] & S8[ $1 ]);
L999: (for B370 being (Element of D167) holds ((S7[ B370 ] & B370 in D170 & S8[ B370 ]) implies S7[ (( F6() . (B370 , D171) ) qua (Element of D167)) ]))
proof
let C438 being (Element of D167);
assume that
L1000: S7[ C438 ]
and
L1001: C438 in D170
and
L1002: S8[ C438 ];
thus L1003: P1[ ( F6() . (C438 , D171) ) ] by L986 , L1000;
reconsider D172 = ( F6() . (C438 , F4()) ) as (Element of D167);
reconsider D173 = ( F6() . (D172 , ( F7() += 1 )) ) as (Element of D167);
L1004: D173 = ( F6() . (C438 , D171) ) by AOFA_000:def 29;
L1005: ( D173 . F7() ) = ( ( D172 . F7() ) + 1 ) by L838;
L1006: ( D172 . F8() ) = ( C438 . F8() ) by L987 , L1000;
thus L1007: thesis by L1006 , L987 , L988 , L1000 , L1002 , L1005 , L1004 , L838;
end;
L1008: (for B371 being (Element of D167) holds (S9[ B371 ] implies ((S9[ (( F6() . (B371 , ( D171 \; D166 )) ) qua (Element of D167)) ] iff ( F6() . (B371 , ( D171 \; D166 )) ) in D170) & H8((( F6() . (B371 , ( D171 \; D166 )) ) qua (Element of D167))) < H8(B371))))
proof
let C439 being (Element of D167);
reconsider D174 = ( F6() . (C439 , F4()) ) as (Element of D167);
reconsider D175 = ( F6() . (D174 , ( F7() += 1 )) ) as (Element of D167);
reconsider D176 = ( F6() . (D175 , D166) ) as (Element of D167);
L1009: ( F6() . (C439 , ( D171 \; D166 )) ) = ( F6() . (( F6() . (C439 , D171) ) , D166) ) by AOFA_000:def 29;
L1010: ( D175 . F8() ) = ( D174 . F8() ) by L988 , L838;
L1011: (( D175 . F7() ) <= ( D175 . F8() ) implies ( D176 . F3() ) = 1) by L879;
L1012: (( D175 . F7() ) > ( D175 . F8() ) implies ( D176 . F3() ) = ( 0 )) by L879;
assume L1013: S9[ C439 ];
reconsider D177 = ( ( C439 . F8() ) - ( C439 . F7() ) ) as (Element of ( NAT )) by L1013 , INT_1:5;
L1014: ( D176 . F7() ) = ( D175 . F7() ) by L988 , L879;
L1015: D175 = ( F6() . (C439 , D171) ) by AOFA_000:def 29;
L1016: P1[ D175 ] by L1015 , L986 , L1013;
thus L1017: (S9[ (( F6() . (C439 , ( D171 \; D166 )) ) qua (Element of D167)) ] iff ( F6() . (C439 , ( D171 \; D166 )) ) in D170) by L1016 , L986 , L988 , L1009 , L1015 , L1014 , L1012 , L1011 , L21 , L879;
L1018: ( D175 . F7() ) = ( ( D174 . F7() ) + 1 ) by L838;
L1019: ( D174 . F8() ) = ( C439 . F8() ) by L987 , L1013;
L1020: ( D174 . F7() ) = ( C439 . F7() ) by L987 , L1013;
L1021: ( D176 . F8() ) = ( D175 . F8() ) by L988 , L879;
L1022: H8(D176) = D177 by L1021 , L1014 , L1020 , L1019 , L1018 , L1010 , FUNCT_7:def 1;
L1023: ( H8(D176) + 1 ) = H8(C439) by L1022 , FUNCT_7:def 1;
thus L1024: thesis by L1023 , L1009 , L1015 , NAT_1:13;
end;
L1025: (for B372 being (Element of D167) holds (S7[ B372 ] implies (S7[ (( F6() . (B372 , D166) ) qua (Element of D167)) ] & (( F6() . (B372 , D166) ) in D170 iff S8[ (( F6() . (B372 , D166) ) qua (Element of D167)) ]))))
proof
let C440 being (Element of D167);
L1026: (( C440 . F7() ) > ( C440 . F8() ) implies ( ( F6() . (C440 , D166) ) . F3() ) = ( 0 )) by L879;
assume L1027: S7[ C440 ];
thus L1028: P1[ ( F6() . (C440 , D166) ) ] by L1027 , L986;
L1029: (( C440 . F7() ) <= ( C440 . F8() ) implies ( ( F6() . (C440 , D166) ) . F3() ) = 1) by L879;
L1030: ( ( F6() . (C440 , D166) ) . F7() ) = ( C440 . F7() ) by L988 , L879;
thus L1031: thesis by L1030 , L988 , L1027 , L1026 , L1029 , L21 , L879;
end;
L1032: ( D169 . F3() ) = 1 by L990 , L996 , L998 , L879;
L1033: (( F6() . (D168 , D166) ) in D170 iff S9[ (( F6() . (D168 , D166) ) qua (Element of D167)) ]) by L1032 , L985 , L986 , L988 , L996 , L991 , L998 , L879;
L1034: F6() iteration_terminates_for ( D171 \; D166 ) , ( F6() . (D168 , D166) ) from AOFA_000:sch 3(L1033 , L1008);
L1035: (S7[ (( F6() . (D168 , ( while (D166 , D171) )) ) qua (Element of D167)) ] & (not S8[ (( F6() . (D168 , ( while (D166 , D171) )) ) qua (Element of D167)) ])) from AOFA_000:sch 5(L995 , L1034 , L999 , L1025);
L1036: ( (( F6() . (F9() , F5()) ) qua (Element of D167)) . F7() ) >= ( ( F9() . F8() ) + 1 ) by L1035 , L993 , INT_1:7;
L1037: ( ( (( F6() . (F9() , F5()) ) qua (Element of D167)) . F7() ) - 1 ) >= ( ( ( F9() . F8() ) + 1 ) - 1 ) by L1036 , XREAL_1:13;
L1038: ( ( (( F6() . (F9() , F5()) ) qua (Element of D167)) . F7() ) - 1 ) = ( F9() . F8() ) by L1037 , L993 , L998 , L1035 , XXREAL_0:1;
thus L1039: thesis by L1038 , L984 , L998 , L1035 , AOFA_000:def 29;
end;
suppose L1040: ( F10() . F9() ) > ( F9() . F8() );

L1041: ( D169 . F3() ) = ( 0 ) by L1040 , L990 , L996 , L879;
L1042: D169 nin D170 by L1041 , L21;
thus L1043: thesis by L1042 , L992 , L991 , L997 , L993 , L989 , L1040 , AOFA_000:def 31;
end;
end;
scheme ForDowntoIteration { F11() ->  Euclidean preIfWhileAlgebra , F12() ->  countable non  empty set , F13() -> (Element of F12()) , F14 , F15() -> (Element of F11()) , F16() ->  Euclidean (ExecutionFunction of F11() , ( Funcs (F12() , ( INT )) ) , ( ( Funcs (F12() , ( INT )) ) \ (F13() , ( 0 )) )) , F17 , F18() -> (Variable of F16()) , F19() -> (Element of ( Funcs (F12() , ( INT )) )) , F20() -> (INT-Expression of F11() , F16()) , P2[set] } : (P2[ ( F16() . (F19() , F15()) ) ] & (( F20() . F19() ) >= ( F19() . F18() ) implies ( ( F16() . (F19() , F15()) ) . F17() ) = ( ( F19() . F18() ) - 1 )) & (( F20() . F19() ) < ( F19() . F18() ) implies ( ( F16() . (F19() , F15()) ) . F17() ) = ( F20() . F19() )) & ( ( F16() . (F19() , F15()) ) . F18() ) = ( F19() . F18() ))
provided
L1045: F15() = ( for-do (( F17() := F20() ) , ( ( . F18() ) leq ( . F17() ) ) , ( F17() += ( - 1 ) ) , F14()) )
and
L1046: P2[ ( F16() . (F19() , ( F17() := F20() )) ) ]
and
L1047: (for B373 being (Element of ( Funcs (F12() , ( INT )) )) holds (P2[ B373 ] implies (P2[ ( F16() . (B373 , ( F14() \; ( F17() += ( - 1 ) ) )) ) ] & P2[ ( F16() . (B373 , ( F18() leq F17() )) ) ])))
and
L1048: (for B374 being (Element of ( Funcs (F12() , ( INT )) )) holds (P2[ B374 ] implies (( ( F16() . (B374 , F14()) ) . F17() ) = ( B374 . F17() ) & ( ( F16() . (B374 , F14()) ) . F18() ) = ( B374 . F18() ))))
and
L1049: (F18() <> F17() & F18() <> F13() & F17() <> F13())
proof
set D178 = ( Funcs (F12() , ( INT )) );
reconsider D179 = ( F16() . (F19() , ( F17() := F20() )) ) as (Element of D178);
set D180 = ( F18() leq F17() );
reconsider D181 = ( F16() . (D179 , D180) ) as (Element of D178);
L1050: P2[ D181 ] by L1046 , L1047;
defpred S10[ (Element of D178) ] means (P2[ $1 ] & (( F20() . F19() ) >= ( F19() . F18() ) implies ( ( $1 . F17() ) + 1 ) >= ( F19() . F18() )) & ( $1 . F18() ) = ( F19() . F18() ));
L1051: ( D179 . F17() ) = ( F20() . F19() ) by L832;
L1052: S10[ D179 ] by L1051 , L1046 , L1049 , L832 , XREAL_1:39;
L1053: ( D181 . F17() ) = ( F20() . F19() ) by L1049 , L1051 , L879;
defpred S11[ (Element of D178) ] means ( $1 . F17() ) >= ( $1 . F18() );
set D182 = ( D178 \ (F13() , ( 0 )) );
L1054: F16() complies_with_while_wrt D182 by AOFA_000:def 32;
set D183 = ( F14() \; ( F17() += ( - 1 ) ) );
L1055: ( F16() . (F19() , F15()) ) = ( F16() . (D179 , ( while (D180 , D183) )) ) by L1045 , AOFA_000:def 29;
L1056: ( D179 . F18() ) = ( F19() . F18() ) by L1049 , L832;
L1057: ( D181 . F18() ) = ( F19() . F18() ) by L1056 , L1049 , L879;
per cases ;
suppose L1058: ( F20() . F19() ) >= ( F19() . F18() );

deffunc H9((Element of D178)) = ( In (( ( ( $1 . F17() ) + 1 ) - ( $1 . F18() ) ) , ( NAT )) );
defpred S12[ (Element of D178) ] means (P2[ $1 ] & S11[ $1 ]);
L1059: (for B375 being (Element of D178) holds ((S10[ B375 ] & B375 in D182 & S11[ B375 ]) implies S10[ (( F16() . (B375 , D183) ) qua (Element of D178)) ]))
proof
let C441 being (Element of D178);
assume that
L1060: S10[ C441 ]
and
L1061: C441 in D182
and
L1062: S11[ C441 ];
thus L1063: P2[ ( F16() . (C441 , D183) ) ] by L1047 , L1060;
reconsider D184 = ( F16() . (C441 , F14()) ) as (Element of D178);
reconsider D185 = ( F16() . (D184 , ( F17() += ( - 1 ) )) ) as (Element of D178);
L1064: D185 = ( F16() . (C441 , D183) ) by AOFA_000:def 29;
L1065: ( D185 . F17() ) = ( ( D184 . F17() ) - 1 ) by L838;
L1066: ( D184 . F18() ) = ( C441 . F18() ) by L1048 , L1060;
thus L1067: thesis by L1066 , L1048 , L1049 , L1060 , L1062 , L1065 , L1064 , L838;
end;
L1068: (for B376 being (Element of D178) holds (S12[ B376 ] implies ((S12[ (( F16() . (B376 , ( D183 \; D180 )) ) qua (Element of D178)) ] iff ( F16() . (B376 , ( D183 \; D180 )) ) in D182) & H9((( F16() . (B376 , ( D183 \; D180 )) ) qua (Element of D178))) < H9(B376))))
proof
let C442 being (Element of D178);
reconsider D186 = ( F16() . (C442 , F14()) ) as (Element of D178);
reconsider D187 = ( F16() . (D186 , ( F17() += ( - 1 ) )) ) as (Element of D178);
reconsider D188 = ( F16() . (D187 , D180) ) as (Element of D178);
L1069: ( F16() . (C442 , ( D183 \; D180 )) ) = ( F16() . (( F16() . (C442 , D183) ) , D180) ) by AOFA_000:def 29;
L1070: ( D187 . F18() ) = ( D186 . F18() ) by L1049 , L838;
L1071: (( D187 . F17() ) >= ( D187 . F18() ) implies ( D188 . F13() ) = 1) by L879;
L1072: (( D187 . F17() ) < ( D187 . F18() ) implies ( D188 . F13() ) = ( 0 )) by L879;
assume L1073: S12[ C442 ];
reconsider D189 = ( ( C442 . F17() ) - ( C442 . F18() ) ) as (Element of ( NAT )) by L1073 , INT_1:5;
L1074: ( D188 . F17() ) = ( D187 . F17() ) by L1049 , L879;
L1075: D187 = ( F16() . (C442 , D183) ) by AOFA_000:def 29;
L1076: P2[ D187 ] by L1075 , L1047 , L1073;
thus L1077: (S12[ (( F16() . (C442 , ( D183 \; D180 )) ) qua (Element of D178)) ] iff ( F16() . (C442 , ( D183 \; D180 )) ) in D182) by L1076 , L1047 , L1049 , L1069 , L1075 , L1074 , L1072 , L1071 , L21 , L879;
L1078: ( D187 . F17() ) = ( ( D186 . F17() ) - 1 ) by L838;
L1079: ( D186 . F18() ) = ( C442 . F18() ) by L1048 , L1073;
L1080: ( D186 . F17() ) = ( C442 . F17() ) by L1048 , L1073;
L1081: ( D188 . F18() ) = ( D187 . F18() ) by L1049 , L879;
L1082: H9(D188) = D189 by L1081 , L1074 , L1080 , L1079 , L1078 , L1070 , FUNCT_7:def 1;
L1083: ( H9(D188) + 1 ) = H9(C442) by L1082 , FUNCT_7:def 1;
thus L1084: thesis by L1083 , L1069 , L1075 , NAT_1:13;
end;
L1085: (for B377 being (Element of D178) holds (S10[ B377 ] implies (S10[ (( F16() . (B377 , D180) ) qua (Element of D178)) ] & (( F16() . (B377 , D180) ) in D182 iff S11[ (( F16() . (B377 , D180) ) qua (Element of D178)) ]))))
proof
let C443 being (Element of D178);
L1086: (( C443 . F17() ) < ( C443 . F18() ) implies ( ( F16() . (C443 , D180) ) . F13() ) = ( 0 )) by L879;
assume L1087: S10[ C443 ];
thus L1088: P2[ ( F16() . (C443 , D180) ) ] by L1087 , L1047;
L1089: (( C443 . F17() ) >= ( C443 . F18() ) implies ( ( F16() . (C443 , D180) ) . F13() ) = 1) by L879;
L1090: ( ( F16() . (C443 , D180) ) . F17() ) = ( C443 . F17() ) by L1049 , L879;
thus L1091: thesis by L1090 , L1049 , L1087 , L1086 , L1089 , L21 , L879;
end;
L1092: ( D181 . F13() ) = 1 by L1051 , L1056 , L1058 , L879;
L1093: (( F16() . (D179 , D180) ) in D182 iff S12[ (( F16() . (D179 , D180) ) qua (Element of D178)) ]) by L1092 , L1046 , L1047 , L1049 , L1056 , L1053 , L1058 , L879;
L1094: F16() iteration_terminates_for ( D183 \; D180 ) , ( F16() . (D179 , D180) ) from AOFA_000:sch 3(L1093 , L1068);
L1095: (S10[ (( F16() . (D179 , ( while (D180 , D183) )) ) qua (Element of D178)) ] & (not S11[ (( F16() . (D179 , ( while (D180 , D183) )) ) qua (Element of D178)) ])) from AOFA_000:sch 5(L1052 , L1094 , L1059 , L1085);
L1096: ( ( (( F16() . (F19() , F15()) ) qua (Element of D178)) . F17() ) + 1 ) <= ( ( ( F19() . F18() ) + 1 ) - 1 ) by L1095 , L1055 , INT_1:7;
L1097: ( ( (( F16() . (F19() , F15()) ) qua (Element of D178)) . F17() ) + 1 ) = ( F19() . F18() ) by L1096 , L1055 , L1058 , L1095 , XXREAL_0:1;
thus L1098: thesis by L1097 , L1045 , L1058 , L1095 , AOFA_000:def 29;
end;
suppose L1099: ( F20() . F19() ) < ( F19() . F18() );

L1100: ( D181 . F13() ) = ( 0 ) by L1099 , L1051 , L1056 , L879;
L1101: D181 nin D182 by L1100 , L21;
thus L1102: thesis by L1101 , L1054 , L1053 , L1057 , L1055 , L1050 , L1099 , AOFA_000:def 31;
end;
end;
begin
theorem
L1104: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B378 being (Element of R6) holds (for B379 , B380 being (Variable of R17) holds (((ex B381 being Function st (( B381 . R16 ) = ( 0 ) & ( B381 . B380 ) = 1 & ( B381 . B379 ) = 2)) & (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (( ( R17 . (R9 , B378) ) . B380 ) = ( R9 . B380 ) & ( ( R17 . (R9 , B378) ) . B379 ) = ( R9 . B379 )))) implies R17 iteration_terminates_for ( ( B378 \; ( B379 += 1 ) ) \; ( B379 leq B380 ) ) , ( R17 . (R9 , ( B379 leq B380 )) )))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
let C444 being (Element of R6);
let C445 , C446 being (Variable of R17);
given C447 being Function such that
L1105: ( C447 . R16 ) = ( 0 )
and
L1106: ( C447 . C446 ) = 1
and
L1107: ( C447 . C445 ) = 2;

set D190 = ( C445 += 1 );
set D191 = ( C445 leq C446 );
set D192 = ( Funcs (R7 , ( INT )) );
set D193 = R17;
assume L1108: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (( ( R17 . (R9 , C444) ) . C446 ) = ( R9 . C446 ) & ( ( R17 . (R9 , C444) ) . C445 ) = ( R9 . C445 )));
deffunc H10((Element of D192)) = ( In (( ( ( $1 . C446 ) + 1 ) - ( $1 . C445 ) ) , ( NAT )) );
defpred S13[ (Element of D192) ] means ( $1 . C445 ) <= ( $1 . C446 );
set D194 = ( D192 \ (R16 , ( 0 )) );
L1109: C445 <> C446 by L1106 , L1107;
L1110: (for B382 being (Element of D192) holds (S13[ B382 ] implies ((S13[ (( D193 . (B382 , ( ( C444 \; D190 ) \; D191 )) ) qua (Element of D192)) ] iff ( D193 . (B382 , ( ( C444 \; D190 ) \; D191 )) ) in D194) & H10((( D193 . (B382 , ( ( C444 \; D190 ) \; D191 )) ) qua (Element of D192))) < H10(B382))))
proof
let C448 being (Element of D192);
set D195 = ( D193 . (C448 , C444) );
set D196 = ( D193 . (C448 , ( C444 \; D190 )) );
set D197 = ( D193 . (D196 , D191) );
L1111: D196 = ( D193 . (D195 , D190) ) by AOFA_000:def 29;
L1112: ( D195 . C445 ) = ( C448 . C445 ) by L1108;
L1113: ( D196 . C445 ) = ( ( C448 . C445 ) + 1 ) by L1112 , L1111 , L838;
L1114: ( D197 . C445 ) = ( ( C448 . C445 ) + 1 ) by L1113 , L1105 , L1107 , L879;
L1115: (( D196 . C445 ) > ( D196 . C446 ) implies ( D197 . R16 ) = ( 0 )) by L879;
assume L1116: S13[ C448 ];
reconsider D198 = ( ( C448 . C446 ) - ( C448 . C445 ) ) as (Element of ( NAT )) by L1116 , INT_1:3 , XREAL_1:48;
L1117: D197 = ( D193 . (C448 , ( ( C444 \; D190 ) \; D191 )) ) by AOFA_000:def 29;
L1118: (( D196 . C445 ) <= ( D196 . C446 ) implies ( D197 . R16 ) = 1) by L879;
L1119: ( D197 . C445 ) = ( D196 . C445 ) by L1105 , L1107 , L879;
thus L1120: (S13[ (( D193 . (C448 , ( ( C444 \; D190 ) \; D191 )) ) qua (Element of D192)) ] iff ( D193 . (C448 , ( ( C444 \; D190 ) \; D191 )) ) in D194) by L1119 , L1105 , L1106 , L1115 , L1118 , L1117 , L21 , L879;
L1121: H10(C448) = ( D198 + 1 ) by FUNCT_7:def 1;
L1122: ( D195 . C446 ) = ( C448 . C446 ) by L1108;
L1123: ( D196 . C446 ) = ( C448 . C446 ) by L1122 , L1109 , L1111 , L838;
L1124: ( D197 . C446 ) = ( C448 . C446 ) by L1123 , L1105 , L1106 , L879;
L1125: H10((D197 qua (Element of D192))) = D198 by L1124 , L1114 , FUNCT_7:def 1;
thus L1126: thesis by L1125 , L1117 , L1121 , NAT_1:13;
end;
reconsider D199 = ( D193 . (R9 , D191) ) as (Element of D192);
L1127: (( R9 . C445 ) > ( R9 . C446 ) implies ( D199 . R16 ) = ( 0 )) by L879;
L1128: (( R9 . C445 ) <= ( R9 . C446 ) implies ( D199 . R16 ) = 1) by L879;
L1129: ( D199 . C445 ) = ( R9 . C445 ) by L1105 , L1107 , L879;
L1130: (D199 in D194 iff S13[ D199 ]) by L1129 , L1105 , L1106 , L1127 , L1128 , L21 , L879;
L1131: D193 iteration_terminates_for ( ( C444 \; D190 ) \; D191 ) , D199 from AOFA_000:sch 3(L1130 , L1110);
thus L1132: thesis by L1131;
end;
theorem
L1133: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B383 being set holds (for B384 being (Element of R6) holds (for B385 , B386 being (Variable of R17) holds (((ex B387 being Function st (( B387 . R16 ) = ( 0 ) & ( B387 . B386 ) = 1 & ( B387 . B385 ) = 2)) & (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (R9 in B383 implies (( ( R17 . (R9 , B384) ) . B386 ) = ( R9 . B386 ) & ( ( R17 . (R9 , B384) ) . B385 ) = ( R9 . B385 ) & ( R17 . (R9 , B384) ) in B383 & ( R17 . (R9 , ( B385 leq B386 )) ) in B383 & ( R17 . (R9 , ( B385 += 1 )) ) in B383)))) implies (R9 in B383 implies R17 iteration_terminates_for ( ( B384 \; ( B385 += 1 ) ) \; ( B385 leq B386 ) ) , ( R17 . (R9 , ( B385 leq B386 )) )))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
let C449 being set;
let C450 being (Element of R6);
let C451 , C452 being (Variable of R17);
given C453 being Function such that
L1134: ( C453 . R16 ) = ( 0 )
and
L1135: ( C453 . C452 ) = 1
and
L1136: ( C453 . C451 ) = 2;

set D200 = ( C451 += 1 );
set D201 = ( C451 leq C452 );
set D202 = ( Funcs (R7 , ( INT )) );
set D203 = R17;
assume that
L1137: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (R9 in C449 implies (( ( R17 . (R9 , C450) ) . C452 ) = ( R9 . C452 ) & ( ( R17 . (R9 , C450) ) . C451 ) = ( R9 . C451 ) & ( R17 . (R9 , C450) ) in C449 & ( R17 . (R9 , ( C451 leq C452 )) ) in C449 & ( R17 . (R9 , ( C451 += 1 )) ) in C449)))
and
L1138: R9 in C449;
defpred S14[ (Element of D202) ] means $1 in C449;
reconsider D204 = ( D203 . (R9 , D201) ) as (Element of D202);
L1139: S14[ D204 ] by L1137 , L1138;
deffunc H11((Element of D202)) = ( In (( ( ( $1 . C452 ) + 1 ) - ( $1 . C451 ) ) , ( NAT )) );
defpred S15[ (Element of D202) ] means ( $1 . C451 ) <= ( $1 . C452 );
set D205 = ( D202 \ (R16 , ( 0 )) );
L1140: C451 <> C452 by L1135 , L1136;
L1141: (for B388 being (Element of D202) holds ((S14[ B388 ] & B388 in D205 & S15[ B388 ]) implies (S14[ (( D203 . (B388 , ( ( C450 \; D200 ) \; D201 )) ) qua (Element of D202)) ] & (S15[ (( D203 . (B388 , ( ( C450 \; D200 ) \; D201 )) ) qua (Element of D202)) ] iff ( D203 . (B388 , ( ( C450 \; D200 ) \; D201 )) ) in D205) & H11((( D203 . (B388 , ( ( C450 \; D200 ) \; D201 )) ) qua (Element of D202))) < H11(B388))))
proof
let C454 being (Element of D202);
assume that
L1142: S14[ C454 ]
and
L1143: C454 in D205
and
L1144: S15[ C454 ];
set D206 = ( D203 . (C454 , ( C450 \; D200 )) );
set D207 = ( D203 . (C454 , C450) );
set D208 = ( D203 . (D206 , D201) );
L1145: D206 = ( D203 . (D207 , D200) ) by AOFA_000:def 29;
L1146: ( D207 . C451 ) = ( C454 . C451 ) by L1137 , L1142;
L1147: ( D206 . C451 ) = ( ( C454 . C451 ) + 1 ) by L1146 , L1145 , L838;
L1148: ( D208 . C451 ) = ( ( C454 . C451 ) + 1 ) by L1147 , L1134 , L1136 , L879;
reconsider D209 = ( ( C454 . C452 ) - ( C454 . C451 ) ) as (Element of ( NAT )) by L1144 , INT_1:3 , XREAL_1:48;
L1149: H11(C454) = ( D209 + 1 ) by FUNCT_7:def 1;
L1150: (( D206 . C451 ) <= ( D206 . C452 ) implies ( D208 . R16 ) = 1) by L879;
L1151: D208 = ( D203 . (C454 , ( ( C450 \; D200 ) \; D201 )) ) by AOFA_000:def 29;
L1152: S14[ (D207 qua (Element of D202)) ] by L1137 , L1142;
L1153: S14[ (D206 qua (Element of D202)) ] by L1152 , L1137 , L1145;
thus L1154: S14[ (( D203 . (C454 , ( ( C450 \; D200 ) \; D201 )) ) qua (Element of D202)) ] by L1153 , L1137 , L1151;
L1155: (( D206 . C451 ) > ( D206 . C452 ) implies ( D208 . R16 ) = ( 0 )) by L879;
L1156: ( D208 . C451 ) = ( D206 . C451 ) by L1134 , L1136 , L879;
thus L1157: (S15[ (( D203 . (C454 , ( ( C450 \; D200 ) \; D201 )) ) qua (Element of D202)) ] iff ( D203 . (C454 , ( ( C450 \; D200 ) \; D201 )) ) in D205) by L1156 , L1134 , L1135 , L1155 , L1150 , L1151 , L21 , L879;
L1158: ( D207 . C452 ) = ( C454 . C452 ) by L1137 , L1142;
L1159: ( D206 . C452 ) = ( C454 . C452 ) by L1158 , L1140 , L1145 , L838;
L1160: ( D208 . C452 ) = ( C454 . C452 ) by L1159 , L1134 , L1135 , L879;
L1161: H11((D208 qua (Element of D202))) = D209 by L1160 , L1148 , FUNCT_7:def 1;
thus L1162: thesis by L1161 , L1151 , L1149 , NAT_1:13;
end;
L1163: (( R9 . C451 ) > ( R9 . C452 ) implies ( D204 . R16 ) = ( 0 )) by L879;
L1164: (( R9 . C451 ) <= ( R9 . C452 ) implies ( D204 . R16 ) = 1) by L879;
L1165: ( D204 . C451 ) = ( R9 . C451 ) by L1134 , L1136 , L879;
L1166: (D204 in D205 iff S15[ D204 ]) by L1165 , L1134 , L1135 , L1163 , L1164 , L21 , L879;
L1167: D203 iteration_terminates_for ( ( C450 \; D200 ) \; D201 ) , D204 from AOFA_000:sch 4(L1139 , L1166 , L1141);
thus L1168: thesis by L1167;
end;
theorem
L1169: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R14 being (INT-Expression of R6 , R12) holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B389 being (Element of R6) holds (B389 is_terminating_wrt R17 implies (for B390 , B391 being (Variable of R17) holds (((ex B392 being Function st (( B392 . R16 ) = ( 0 ) & ( B392 . B391 ) = 1 & ( B392 . B390 ) = 2)) & (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (( ( R17 . (R9 , B389) ) . B391 ) = ( R9 . B391 ) & ( ( R17 . (R9 , B389) ) . B390 ) = ( R9 . B390 )))) implies ( for-do (( B390 := R14 ) , ( B390 leq B391 ) , ( B390 += 1 ) , B389) ) is_terminating_wrt R17)))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R14 being (INT-Expression of R6 , R12);
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D210 = ( Funcs (R7 , ( INT )) );
set D211 = ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) );
let C455 being (Element of R6);
assume that
L1170: C455 is_terminating_wrt R17;
let C456 , C457 being (Variable of R17);
L1171: ( C456 += 1 ) is_terminating_wrt R17 by AOFA_000:104;
L1172: ( C455 \; ( C456 += 1 ) ) is_terminating_wrt R17 by L1171 , L1170 , AOFA_000:110;
set D212 = ( while (( C456 leq C457 ) , ( C455 \; ( C456 += 1 ) )) );
given C458 being Function such that
L1173: ( C458 . R16 ) = ( 0 )
and
L1174: ( C458 . C457 ) = 1
and
L1175: ( C458 . C456 ) = 2;

assume L1176: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (( ( R17 . (R9 , C455) ) . C457 ) = ( R9 . C457 ) & ( ( R17 . (R9 , C455) ) . C456 ) = ( R9 . C456 )));
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
L1177: [ R9 , ( C456 := R14 ) ] in ( TerminatingPrograms (R6 , D210 , D211 , R17) ) by AOFA_000:def 36;
L1178: ( C456 leq C457 ) is_terminating_wrt R17 by AOFA_000:104;
L1179: R17 iteration_terminates_for ( ( C455 \; ( C456 += 1 ) ) \; ( C456 leq C457 ) ) , ( R17 . (( R17 . (R9 , ( C456 := R14 )) ) , ( C456 leq C457 )) ) by L1173 , L1174 , L1175 , L1176 , L1104;
L1180: [ ( R17 . (R9 , ( C456 := R14 )) ) , D212 ] in ( TerminatingPrograms (R6 , D210 , D211 , R17) ) by L1179 , L1178 , L1172 , AOFA_000:114;
thus L1181: thesis by L1180 , L1177 , AOFA_000:def 35;
end;
theorem
L1182: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R11 being (Subset of ( Funcs (R7 , ( INT )) )) holds (for R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11) holds (for R14 being (INT-Expression of R6 , R12) holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B393 being set holds (for B394 being (Element of R6) holds (B394 is_terminating_wrt R17 , B393 implies (for B395 , B396 being (Variable of R17) holds (((ex B397 being Function st (( B397 . R16 ) = ( 0 ) & ( B397 . B396 ) = 1 & ( B397 . B395 ) = 2)) & (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (R9 in B393 implies (( ( R17 . (R9 , B394) ) . B396 ) = ( R9 . B396 ) & ( ( R17 . (R9 , B394) ) . B395 ) = ( R9 . B395 )))) & B393 is_invariant_wrt ( B395 := R14 ) , R17 & B393 is_invariant_wrt B394 , R17 & B393 is_invariant_wrt ( B395 leq B396 ) , R17 & B393 is_invariant_wrt ( B395 += 1 ) , R17) implies ( for-do (( B395 := R14 ) , ( B395 leq B396 ) , ( B395 += 1 ) , B394) ) is_terminating_wrt R17 , B393))))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R14 being (INT-Expression of R6 , R12);
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D213 = ( Funcs (R7 , ( INT )) );
set D214 = ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) );
let C459 being set;
let C460 being (Element of R6);
assume L1183: C460 is_terminating_wrt R17 , C459;
let C461 , C462 being (Variable of R17);
given C463 being Function such that
L1184: ( C463 . R16 ) = ( 0 )
and
L1185: ( C463 . C462 ) = 1
and
L1186: ( C463 . C461 ) = 2;

set D215 = ( C461 leq C462 );
set D216 = ( C460 \; ( C461 += 1 ) );
assume that
L1187: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (R9 in C459 implies (( ( R17 . (R9 , C460) ) . C462 ) = ( R9 . C462 ) & ( ( R17 . (R9 , C460) ) . C461 ) = ( R9 . C461 ))))
and
L1188: C459 is_invariant_wrt ( C461 := R14 ) , R17
and
L1189: C459 is_invariant_wrt C460 , R17
and
L1190: C459 is_invariant_wrt ( C461 leq C462 ) , R17
and
L1191: C459 is_invariant_wrt ( C461 += 1 ) , R17;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
assume L1192: R9 in C459;
L1193: ( R17 . (R9 , ( C461 := R14 )) ) in C459 by L1192 , L1188 , AOFA_000:def 39;
L1194: (for B398 being (Element of D213) holds (B398 in C459 implies (( ( R17 . (B398 , C460) ) . C462 ) = ( B398 . C462 ) & ( ( R17 . (B398 , C460) ) . C461 ) = ( B398 . C461 ) & ( R17 . (B398 , C460) ) in C459 & ( R17 . (B398 , ( C461 leq C462 )) ) in C459 & ( R17 . (B398 , ( C461 += 1 )) ) in C459))) by L1187 , L1189 , L1190 , L1191 , AOFA_000:def 39;
L1195: R17 iteration_terminates_for ( D216 \; D215 ) , ( R17 . (( R17 . (R9 , ( C461 := R14 )) ) , D215) ) by L1194 , L1184 , L1185 , L1186 , L1193 , L1133;
set D217 = ( while (D215 , D216) );
L1196: D215 is_terminating_wrt R17 by AOFA_000:104;
L1197: [ R9 , ( C461 := R14 ) ] in ( TerminatingPrograms (R6 , D213 , D214 , R17) ) by AOFA_000:def 36;
L1198: C459 is_invariant_wrt D216 , R17 by L1189 , L1191 , AOFA_000:109;
L1199: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds ((R9 in C459 & ( R17 . (( R17 . (R9 , D216) ) , D215) ) in D214) implies ( R17 . (R9 , D216) ) in C459)) by L1198 , AOFA_000:def 39;
L1200: ( C461 += 1 ) is_terminating_wrt R17 , C459 by AOFA_000:107;
L1201: [ ( R17 . (R9 , ( C461 := R14 )) ) , D217 ] in ( TerminatingPrograms (R6 , D213 , D214 , R17) ) by L1200 , L1183 , L1189 , L1190 , L1193 , L1195 , L1196 , L1199 , AOFA_000:111 , AOFA_000:116;
thus L1202: thesis by L1201 , L1197 , AOFA_000:def 35;
end;
begin
definition
let R7 being non  empty  countable set;
let R6 being  Euclidean preIfWhileAlgebra;
let R11 being (Subset of ( Funcs (R7 , ( INT )) ));
let R12 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , R11);
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
let C464 being (Element of R6);
redefine func R12 . (R9 , C464) -> (Element of ( Funcs (R7 , ( INT )) ));

coherence
proof
L1203: ( R12 . (R9 , C464) ) is (Element of ( Funcs (R7 , ( INT )) ));
thus L1204: thesis by L1203;
end;
end;
theorem
L1206: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B399 , B400 , B401 being (Variable of R17) holds ((ex B402 being Function st (( B402 . B399 ) = 1 & ( B402 . B400 ) = 2 & ( B402 . B401 ) = 3 & ( B402 . R16 ) = 4)) implies ( ( B400 := 1 ) \; ( for-do (( B401 := 2 ) , ( B401 leq B399 ) , ( B401 += 1 ) , ( B400 *= B401 )) ) ) is_terminating_wrt R17))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D218 = ( Funcs (R7 , ( INT )) );
set D219 = ( D218 \ (R16 , ( 0 )) );
let C465 , C466 , C467 being (Variable of R17);
given C468 being Function such that
L1207: ( C468 . C465 ) = 1
and
L1208: ( C468 . C466 ) = 2
and
L1209: ( C468 . C467 ) = 3
and
L1210: ( C468 . R16 ) = 4;

L1211: C466 <> C465 by L1207 , L1208;
L1212: C466 <> C467 by L1208 , L1209;
L1213: (for B403 being (Element of D218) holds (( ( R17 . (B403 , ( C466 *= C467 )) ) . C465 ) = ( B403 . C465 ) & ( ( R17 . (B403 , ( C466 *= C467 )) ) . C467 ) = ( B403 . C467 ))) by L1212 , L1211 , L863;
L1214: C465 <> R16 by L1207 , L1210;
L1215: R16 <> C467 by L1209 , L1210;
let C469 being (Element of D218);
set D220 = ( . (2 , R6 , R17) );
L1216: C467 <> C465 by L1207 , L1209;
L1217: (ex B404 being Function st (( B404 . R16 ) = ( 0 ) & ( B404 . C465 ) = 1 & ( B404 . C467 ) = 2)) by L1216 , L1215 , L1214 , L1;
L1218: ( for-do (( C467 := D220 ) , ( C467 leq C465 ) , ( C467 += 1 ) , ( C466 *= C467 )) ) is_terminating_wrt R17 by L1217 , L1213 , L1169 , AOFA_000:104;
L1219: [ (( R17 . (C469 , ( C466 := 1 )) ) qua (Element of D218)) , ( for-do (( C467 := D220 ) , ( C467 leq C465 ) , ( C467 += 1 ) , ( C466 *= C467 )) ) ] in ( TerminatingPrograms (R6 , D218 , D219 , R17) ) by L1218 , AOFA_000:def 37;
L1220: [ C469 , ( C466 := 1 ) ] in ( TerminatingPrograms (R6 , D218 , D219 , R17) ) by AOFA_000:def 36;
thus L1221: thesis by L1220 , L1219 , AOFA_000:def 35;
end;
theorem
L1222: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B405 , B406 , B407 being (Variable of R17) holds ((ex B408 being Function st (( B408 . B405 ) = 1 & ( B408 . B406 ) = 2 & ( B408 . B407 ) = 3 & ( B408 . R16 ) = 4)) implies (for B409 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B410 being Nat holds (B410 = ( B409 . B405 ) implies ( ( R17 . (B409 , ( ( B406 := 1 ) \; ( for-do (( B407 := 2 ) , ( B407 leq B405 ) , ( B407 += 1 ) , ( B406 *= B407 )) ) )) ) . B406 ) = ( B410 ! ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D221 = R17;
let C470 , C471 , C472 being (Variable of D221);
given C473 being Function such that
L1223: ( C473 . C470 ) = 1
and
L1224: ( C473 . C471 ) = 2
and
L1225: ( C473 . C472 ) = 3
and
L1226: ( C473 . R16 ) = 4;

L1227: (C470 <> C472 & C470 <> R16 & C472 <> R16) by L1223 , L1225 , L1226;
set D222 = ( Funcs (R7 , ( INT )) );
let C474 being (Element of ( Funcs (R7 , ( INT )) ));
reconsider D223 = ( D221 . (C474 , ( C471 := 1 )) ) as (Element of D222);
defpred S16[ (Element of D222) ] means (ex B411 being Nat st (B411 = ( ( $1 . C472 ) - 1 ) & ( $1 . C471 ) = ( B411 ! )));
reconsider D224 = ( . (2 , R6 , D221) ) as (INT-Expression of R6 , R17);
reconsider D225 = ( D221 . (D223 , ( C472 := 2 )) ) as (Element of D222);
L1228: ( D225 . C472 ) = 2 by L828;
L1229: C471 <> C472 by L1224 , L1225;
L1230: ( D225 . C471 ) = ( D223 . C471 ) by L1229 , L828;
L1231: S16[ ( D221 . (D223 , ( C472 := D224 )) ) ] by L1230 , L1228 , L828 , NEWTON:13;
set D226 = ( C471 *= C472 );
L1232: ( D224 . D223 ) = 2 by FUNCOP_1:7;
L1233: C471 <> R16 by L1224 , L1226;
L1234: (for B412 being (Element of ( Funcs (R7 , ( INT )) )) holds (S16[ B412 ] implies (S16[ ( D221 . (B412 , ( D226 \; ( C472 += 1 ) )) ) ] & S16[ ( D221 . (B412 , ( C472 leq C470 )) ) ])))
proof
let C475 being (Element of ( Funcs (R7 , ( INT )) ));
given C476 being Nat such that
L1235: C476 = ( ( C475 . C472 ) - 1 )
and
L1236: ( C475 . C471 ) = ( C476 ! );

reconsider D227 = ( D221 . (C475 , D226) ) as (Element of D222);
reconsider D228 = ( D221 . (D227 , ( C472 += 1 )) ) as (Element of D222);
L1237: ( D227 . C471 ) = ( ( C475 . C471 ) * ( C475 . C472 ) ) by L863;
L1238: ( D228 . C471 ) = ( D227 . C471 ) by L1229 , L838;
L1239: ( D228 . C471 ) = ( ( C476 + 1 ) ! ) by L1238 , L1235 , L1236 , L1237 , NEWTON:15;
L1240: D228 = ( D221 . (C475 , ( D226 \; ( C472 += 1 ) )) ) by AOFA_000:def 29;
L1241: ( D228 . C472 ) = ( ( D227 . C472 ) + 1 ) by L838;
L1242: ( C476 + 1 ) = ( ( D228 . C472 ) - 1 ) by L1241 , L1229 , L1235 , L863;
thus L1243: S16[ (( D221 . (C475 , ( D226 \; ( C472 += 1 ) )) ) qua (Element of D222)) ] by L1242 , L1240 , L1239;
reconsider D229 = ( D221 . (C475 , ( C472 leq C470 )) ) as (Element of D222);
L1244: ( D229 . C472 ) = ( C475 . C472 ) by L1227 , L879;
L1245: ( D229 . C471 ) = ( C475 . C471 ) by L1233 , L879;
thus L1246: thesis by L1245 , L1235 , L1236 , L1244;
end;
reconsider D230 = ( for-do (( C472 := D224 ) , ( C472 leq C470 ) , ( C472 += 1 ) , D226) ) as (Element of R6);
let C477 being Nat;
assume L1247: C477 = ( C474 . C470 );
L1248: D230 = ( for-do (( C472 := D224 ) , ( C472 leq C470 ) , ( C472 += 1 ) , D226) );
L1249: C471 <> C470 by L1223 , L1224;
L1250: ( D223 . C470 ) = ( C474 . C470 ) by L1249 , L828;
L1251: (for B413 being (Element of ( Funcs (R7 , ( INT )) )) holds (S16[ B413 ] implies (( ( D221 . (B413 , D226) ) . C472 ) = ( B413 . C472 ) & ( ( D221 . (B413 , D226) ) . C470 ) = ( B413 . C470 )))) by L1249 , L1229 , L857;
L1252: (S16[ ( D221 . (D223 , D230) ) ] & (( D224 . D223 ) <= ( D223 . C470 ) implies ( ( D221 . (D223 , D230) ) . C472 ) = ( ( D223 . C470 ) + 1 )) & (( D224 . D223 ) > ( D223 . C470 ) implies ( ( D221 . (D223 , D230) ) . C472 ) = ( D224 . D223 )) & ( ( D221 . (D223 , D230) ) . C470 ) = ( D223 . C470 )) from ForToIteration(L1248 , L1231 , L1234 , L1251 , L1227);
thus L1253: ( ( D221 . (C474 , ( ( C471 := 1 ) \; ( for-do (( C472 := 2 ) , ( C472 leq C470 ) , ( C472 += 1 ) , ( C471 *= C472 )) ) )) ) . C471 ) = ( ( D221 . (D223 , D230) ) . C471 ) by AOFA_000:def 29
.= ( C477 ! ) by L1247 , L1250 , L1252 , L1232 , NAT_1:26 , NEWTON:12 , NEWTON:13;
end;
theorem
L1254: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B414 , B415 , B416 , B417 being (Variable of R17) holds ((ex B418 being Function st (( B418 . B415 ) = 1 & ( B418 . B416 ) = 2 & ( B418 . B417 ) = 3 & ( B418 . R16 ) = 4)) implies ( ( B416 := 1 ) \; ( for-do (( B417 := 1 ) , ( B417 leq B415 ) , ( B417 += 1 ) , ( B416 *= B414 )) ) ) is_terminating_wrt R17))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D231 = ( Funcs (R7 , ( INT )) );
set D232 = ( D231 \ (R16 , ( 0 )) );
let C478 , C479 , C480 , C481 being (Variable of R17);
given C482 being Function such that
L1255: ( C482 . C479 ) = 1
and
L1256: ( C482 . C480 ) = 2
and
L1257: ( C482 . C481 ) = 3
and
L1258: ( C482 . R16 ) = 4;

L1259: C480 <> C479 by L1255 , L1256;
L1260: C480 <> C481 by L1256 , L1257;
L1261: (for B419 being (Element of D231) holds (( ( R17 . (B419 , ( C480 *= C478 )) ) . C479 ) = ( B419 . C479 ) & ( ( R17 . (B419 , ( C480 *= C478 )) ) . C481 ) = ( B419 . C481 ))) by L1260 , L1259 , L863;
L1262: C479 <> R16 by L1255 , L1258;
L1263: R16 <> C481 by L1257 , L1258;
let C483 being (Element of D231);
set D233 = ( . (1 , R6 , R17) );
L1264: C481 <> C479 by L1255 , L1257;
L1265: (ex B420 being Function st (( B420 . R16 ) = ( 0 ) & ( B420 . C479 ) = 1 & ( B420 . C481 ) = 2)) by L1264 , L1263 , L1262 , L1;
L1266: ( for-do (( C481 := D233 ) , ( C481 leq C479 ) , ( C481 += 1 ) , ( C480 *= C478 )) ) is_terminating_wrt R17 by L1265 , L1261 , L1169 , AOFA_000:104;
L1267: [ (( R17 . (C483 , ( C480 := 1 )) ) qua (Element of D231)) , ( for-do (( C481 := D233 ) , ( C481 leq C479 ) , ( C481 += 1 ) , ( C480 *= C478 )) ) ] in ( TerminatingPrograms (R6 , D231 , D232 , R17) ) by L1266 , AOFA_000:def 37;
L1268: [ C483 , ( C480 := 1 ) ] in ( TerminatingPrograms (R6 , D231 , D232 , R17) ) by AOFA_000:def 36;
thus L1269: thesis by L1268 , L1267 , AOFA_000:def 35;
end;
theorem
L1270: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B421 , B422 , B423 , B424 being (Variable of R17) holds ((ex B425 being Function st (( B425 . B421 ) = ( 0 ) & ( B425 . B422 ) = 1 & ( B425 . B423 ) = 2 & ( B425 . B424 ) = 3 & ( B425 . R16 ) = 4)) implies (for B426 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B427 being Nat holds (B427 = ( B426 . B422 ) implies ( ( R17 . (B426 , ( ( B423 := 1 ) \; ( for-do (( B424 := 1 ) , ( B424 leq B422 ) , ( B424 += 1 ) , ( B423 *= B421 )) ) )) ) . B423 ) = ( ( B426 . B421 ) |^ B427 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D234 = R17;
let C484 , C485 , C486 , C487 being (Variable of D234);
given C488 being Function such that
L1271: ( C488 . C484 ) = ( 0 )
and
L1272: ( C488 . C485 ) = 1
and
L1273: ( C488 . C486 ) = 2
and
L1274: ( C488 . C487 ) = 3
and
L1275: ( C488 . R16 ) = 4;

L1276: (C485 <> C487 & C485 <> R16 & C487 <> R16) by L1272 , L1274 , L1275;
set D235 = ( Funcs (R7 , ( INT )) );
let C489 being (Element of ( Funcs (R7 , ( INT )) ));
reconsider D236 = ( D234 . (C489 , ( C486 := 1 )) ) as (Element of D235);
reconsider D237 = ( D234 . (D236 , ( C487 := 1 )) ) as (Element of D235);
L1277: C486 <> C487 by L1273 , L1274;
L1278: ( D237 . C486 ) = ( D236 . C486 ) by L1277 , L828;
defpred S17[ (Element of D235) ] means (ex B428 being Nat st (B428 = ( ( $1 . C487 ) - 1 ) & ( $1 . C486 ) = ( ( C489 . C484 ) |^ B428 ) & ( $1 . C484 ) = ( C489 . C484 )));
set D238 = ( C486 *= C484 );
set D239 = C489;
L1279: ( ( C489 . C484 ) |^ ( 0 ) ) = 1 by NEWTON:4;
L1280: C486 <> C485 by L1272 , L1273;
L1281: (for B429 being (Element of ( Funcs (R7 , ( INT )) )) holds (S17[ B429 ] implies (( ( D234 . (B429 , D238) ) . C487 ) = ( B429 . C487 ) & ( ( D234 . (B429 , D238) ) . C485 ) = ( B429 . C485 )))) by L1280 , L1277 , L857;
L1282: C486 <> R16 by L1273 , L1275;
L1283: (for B430 being (Element of ( Funcs (R7 , ( INT )) )) holds (S17[ B430 ] implies (S17[ ( D234 . (B430 , ( D238 \; ( C487 += 1 ) )) ) ] & S17[ ( D234 . (B430 , ( C487 leq C485 )) ) ])))
proof
let C490 being (Element of ( Funcs (R7 , ( INT )) ));
given C491 being Nat such that
L1284: C491 = ( ( C490 . C487 ) - 1 )
and
L1285: ( C490 . C486 ) = ( ( D239 . C484 ) |^ C491 )
and
L1286: ( C490 . C484 ) = ( D239 . C484 );

reconsider D240 = ( D234 . (C490 , D238) ) as (Element of D235);
reconsider D241 = ( D234 . (D240 , ( C487 += 1 )) ) as (Element of D235);
L1287: ( D240 . C486 ) = ( ( C490 . C486 ) * ( C490 . C484 ) ) by L863;
L1288: ( D241 . C486 ) = ( D240 . C486 ) by L1277 , L838;
L1289: ( D241 . C486 ) = ( ( D239 . C484 ) |^ ( C491 + 1 ) ) by L1288 , L1285 , L1286 , L1287 , NEWTON:6;
L1290: D241 = ( D234 . (C490 , ( D238 \; ( C487 += 1 ) )) ) by AOFA_000:def 29;
L1291: ( D240 . C484 ) = ( C490 . C484 ) by L1271 , L1273 , L863;
L1292: ( D241 . C487 ) = ( ( D240 . C487 ) + 1 ) by L838;
L1293: ( C491 + 1 ) = ( ( D241 . C487 ) - 1 ) by L1292 , L1277 , L1284 , L863;
thus L1294: S17[ (( D234 . (C490 , ( D238 \; ( C487 += 1 ) )) ) qua (Element of D235)) ] by L1293 , L1271 , L1274 , L1286 , L1290 , L1291 , L1289 , L838;
reconsider D242 = ( D234 . (C490 , ( C487 leq C485 )) ) as (Element of D235);
L1295: ( D242 . C486 ) = ( C490 . C486 ) by L1282 , L879;
L1296: ( D242 . C487 ) = ( C490 . C487 ) by L1276 , L879;
L1297: ( D242 . C484 ) = ( C490 . C484 ) by L1271 , L1275 , L879;
thus L1298: thesis by L1297 , L1284 , L1285 , L1286 , L1295 , L1296;
end;
reconsider D243 = ( . (1 , R6 , D234) ) as (INT-Expression of R6 , R17);
reconsider D244 = ( for-do (( C487 := D243 ) , ( C487 leq C485 ) , ( C487 += 1 ) , D238) ) as (Element of R6);
L1299: D244 = ( for-do (( C487 := D243 ) , ( C487 leq C485 ) , ( C487 += 1 ) , D238) );
L1300: ( D237 . C487 ) = 1 by L828;
L1301: ( D237 . C484 ) = ( D236 . C484 ) by L1271 , L1274 , L828;
L1302: ( D236 . C486 ) = 1 by L828;
L1303: ( D236 . C484 ) = ( C489 . C484 ) by L1271 , L1273 , L828;
L1304: S17[ ( D234 . (D236 , ( C487 := D243 )) ) ] by L1303 , L1302 , L1278 , L1300 , L1301 , L1279;
L1305: (S17[ ( D234 . (D236 , D244) ) ] & (( D243 . D236 ) <= ( D236 . C485 ) implies ( ( D234 . (D236 , D244) ) . C487 ) = ( ( D236 . C485 ) + 1 )) & (( D243 . D236 ) > ( D236 . C485 ) implies ( ( D234 . (D236 , D244) ) . C487 ) = ( D243 . D236 )) & ( ( D234 . (D236 , D244) ) . C485 ) = ( D236 . C485 )) from ForToIteration(L1299 , L1304 , L1283 , L1281 , L1276);
L1306: ( ( ( C489 . C485 ) + 1 ) - 1 ) = ( C489 . C485 );
L1307: ( D236 . C485 ) = ( C489 . C485 ) by L1280 , L828;
let C492 being Nat;
assume L1308: C492 = ( C489 . C485 );
L1309: (C492 = ( 0 ) or C492 >= 1) by NAT_1:25;
thus L1310: ( ( D234 . (C489 , ( ( C486 := 1 ) \; ( for-do (( C487 := 1 ) , ( C487 leq C485 ) , ( C487 += 1 ) , ( C486 *= C484 )) ) )) ) . C486 ) = ( ( D234 . (D236 , D244) ) . C486 ) by AOFA_000:def 29
.= ( ( C489 . C484 ) |^ C492 ) by L1308 , L1307 , L1306 , L1305 , L1309 , FUNCOP_1:7;
end;
theorem
L1311: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B431 , B432 , B433 , B434 , B435 being (Variable of R17) holds ((ex B436 being Function st (( B436 . R16 ) = ( 0 ) & ( B436 . B431 ) = 1 & ( B436 . B432 ) = 2 & ( B436 . B433 ) = 3 & ( B436 . B434 ) = 4 & ( B436 . B435 ) = 5)) implies ( ( ( B432 := ( 0 ) ) \; ( B433 := 1 ) ) \; ( for-do (( B435 := 1 ) , ( B435 leq B431 ) , ( B435 += 1 ) , ( ( ( B434 := B432 ) \; ( B432 := B433 ) ) \; ( B433 += B434 ) )) ) ) is_terminating_wrt R17))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D245 = ( Funcs (R7 , ( INT )) );
set D246 = ( D245 \ (R16 , ( 0 )) );
let C493 , C494 , C495 , C496 , C497 being (Variable of R17);
given C498 being Function such that
L1312: ( C498 . R16 ) = ( 0 )
and
L1313: ( C498 . C493 ) = 1
and
L1314: ( C498 . C494 ) = 2
and
L1315: ( C498 . C495 ) = 3
and
L1316: ( C498 . C496 ) = 4
and
L1317: ( C498 . C497 ) = 5;

L1318: C497 <> C495 by L1315 , L1317;
L1319: C493 <> C496 by L1313 , L1316;
L1320: C493 <> C495 by L1313 , L1315;
L1321: C493 <> C494 by L1313 , L1314;
L1322: C497 <> C496 by L1316 , L1317;
set D247 = ( ( ( C496 := C494 ) \; ( C494 := C495 ) ) \; ( C495 += C496 ) );
set D248 = ( C496 := C494 );
set D249 = ( C494 := C495 );
set D250 = ( C495 += C496 );
L1323: C497 <> C494 by L1314 , L1317;
L1324: (for B437 being (Element of D245) holds (( ( R17 . (B437 , D247) ) . C493 ) = ( B437 . C493 ) & ( ( R17 . (B437 , D247) ) . C497 ) = ( B437 . C497 )))
proof
let C499 being (Element of D245);
thus L1325: ( ( R17 . (C499 , D247) ) . C493 ) = ( ( R17 . (( R17 . (C499 , ( D248 \; D249 )) ) , D250) ) . C493 ) by AOFA_000:def 29
.= ( ( R17 . (C499 , ( D248 \; D249 )) ) . C493 ) by L1320 , L849
.= ( ( R17 . (( R17 . (C499 , D248) ) , D249) ) . C493 ) by AOFA_000:def 29
.= ( ( R17 . (C499 , D248) ) . C493 ) by L1321 , L835
.= ( C499 . C493 ) by L1319 , L835;
thus L1326: ( ( R17 . (C499 , D247) ) . C497 ) = ( ( R17 . (( R17 . (C499 , ( D248 \; D249 )) ) , D250) ) . C497 ) by AOFA_000:def 29
.= ( ( R17 . (C499 , ( D248 \; D249 )) ) . C497 ) by L1318 , L849
.= ( ( R17 . (( R17 . (C499 , D248) ) , D249) ) . C497 ) by AOFA_000:def 29
.= ( ( R17 . (C499 , D248) ) . C497 ) by L1323 , L835
.= ( C499 . C497 ) by L1322 , L835;
end;
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
set D251 = ( R17 . (R9 , ( ( C494 := ( 0 ) ) \; ( C495 := 1 ) )) );
L1327: C497 <> C493 by L1313 , L1317;
L1328: (ex B438 being Function st (( B438 . R16 ) = ( 0 ) & ( B438 . C493 ) = 1 & ( B438 . C497 ) = 2)) by L1327 , L1312 , L1313 , L1317 , L1;
L1329: ( for-do (( C497 := 1 ) , ( C497 leq C493 ) , ( C497 += 1 ) , ( ( ( C496 := C494 ) \; ( C494 := C495 ) ) \; ( C495 += C496 ) )) ) is_terminating_wrt R17 by L1328 , L1324 , L1169 , AOFA_000:104;
L1330: [ D251 , ( for-do (( C497 := 1 ) , ( C497 leq C493 ) , ( C497 += 1 ) , ( ( ( C496 := C494 ) \; ( C494 := C495 ) ) \; ( C495 += C496 ) )) ) ] in ( TerminatingPrograms (R6 , D245 , D246 , R17) ) by L1329 , AOFA_000:def 37;
L1331: [ R9 , ( ( C494 := ( 0 ) ) \; ( C495 := 1 ) ) ] in ( TerminatingPrograms (R6 , D245 , D246 , R17) ) by AOFA_000:def 36;
thus L1332: thesis by L1331 , L1330 , AOFA_000:def 35;
end;
theorem
L1333: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B439 , B440 , B441 , B442 , B443 being (Variable of R17) holds ((ex B444 being Function st (( B444 . R16 ) = ( 0 ) & ( B444 . B439 ) = 1 & ( B444 . B440 ) = 2 & ( B444 . B441 ) = 3 & ( B444 . B442 ) = 4 & ( B444 . B443 ) = 5)) implies (for B445 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B446 being (Element of ( NAT )) holds (B446 = ( B445 . B439 ) implies ( ( R17 . (B445 , ( ( ( B440 := ( 0 ) ) \; ( B441 := 1 ) ) \; ( for-do (( B443 := 1 ) , ( B443 leq B439 ) , ( B443 += 1 ) , ( ( ( B442 := B440 ) \; ( B440 := B441 ) ) \; ( B441 += B442 ) )) ) )) ) . B440 ) = ( Fib B446 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
L1334: ( (( 0 ) qua (Element of ( NAT ))) + 1 ) = 1;
set D252 = ( Funcs (R7 , ( INT )) );
let C500 , C501 , C502 , C503 , C504 being (Variable of R17);
given C505 being Function such that
L1335: ( C505 . R16 ) = ( 0 )
and
L1336: ( C505 . C500 ) = 1
and
L1337: ( C505 . C501 ) = 2
and
L1338: ( C505 . C502 ) = 3
and
L1339: ( C505 . C503 ) = 4
and
L1340: ( C505 . C504 ) = 5;

L1341: C500 <> C501 by L1336 , L1337;
L1342: C502 <> C503 by L1338 , L1339;
L1343: C501 <> C503 by L1337 , L1339;
L1344: C504 <> C503 by L1339 , L1340;
L1345: C500 <> C502 by L1336 , L1338;
let C506 being (Element of ( Funcs (R7 , ( INT )) ));
reconsider D253 = ( R17 . (C506 , ( C501 := ( 0 ) )) ) as (Element of D252);
reconsider D254 = ( R17 . (D253 , ( C502 := 1 )) ) as (Element of D252);
reconsider D255 = ( R17 . (D254 , ( C504 := 1 )) ) as (Element of D252);
L1346: ( D255 . C504 ) = 1 by L828;
L1347: C504 <> C502 by L1338 , L1340;
L1348: ( D255 . C502 ) = ( D254 . C502 ) by L1347 , L828;
set D256 = ( ( ( C503 := C501 ) \; ( C501 := C502 ) ) \; ( C502 += C503 ) );
L1349: ( D254 . C502 ) = 1 by L828;
L1350: C504 <> C501 by L1337 , L1340;
L1351: ( D255 . C501 ) = ( D254 . C501 ) by L1350 , L828;
defpred S18[ (Element of D252) ] means (ex B447 being (Element of ( NAT )) st (B447 = ( ( $1 . C504 ) - 1 ) & ( $1 . C501 ) = ( Fib B447 ) & ( $1 . C502 ) = ( Fib ( B447 + 1 ) )));
reconsider D257 = ( . (1 , R6 , R17) ) as (INT-Expression of R6 , R17);
L1352: ( D253 . C501 ) = ( 0 ) by L828;
L1353: C501 <> C502 by L1337 , L1338;
L1354: ( D254 . C501 ) = ( D253 . C501 ) by L1353 , L828;
L1355: S18[ ( R17 . (D254 , ( C504 := D257 )) ) ] by L1354 , L1352 , L1349 , L1348 , L1351 , L1346 , L1334 , PRE_FF:1;
L1356: C500 <> C503 by L1336 , L1339;
L1357:
now
let C507 being (Element of D252);
reconsider D258 = ( R17 . (C507 , ( C503 := C501 )) ) as (Element of D252);
reconsider D259 = ( R17 . (D258 , ( C501 := C502 )) ) as (Element of D252);
reconsider D260 = ( R17 . (D259 , ( C502 += C503 )) ) as (Element of D252);
L1358: ( R17 . (C507 , D256) ) = ( R17 . (( R17 . (C507 , ( ( C503 := C501 ) \; ( C501 := C502 ) )) ) , ( C502 += C503 )) ) by AOFA_000:def 29
.= D260 by AOFA_000:def 29;
L1359: ( D258 . C503 ) = ( C507 . C501 ) by L835;
L1360: ( D259 . C500 ) = ( D258 . C500 ) by L1341 , L835;
L1361: ( D258 . C504 ) = ( C507 . C504 ) by L1344 , L835;
L1362: ( D259 . C503 ) = ( D258 . C503 ) by L1343 , L835;
L1363: ( D259 . C502 ) = ( D258 . C502 ) by L1353 , L835;
L1364: ( D259 . C504 ) = ( D258 . C504 ) by L1350 , L835;
L1365: ( D258 . C502 ) = ( C507 . C502 ) by L1342 , L835;
L1366: ( D259 . C501 ) = ( D258 . C502 ) by L835;
L1367: ( D258 . C500 ) = ( C507 . C500 ) by L1356 , L835;
thus L1368: (( ( R17 . (C507 , D256) ) . C504 ) = ( C507 . C504 ) & ( ( R17 . (C507 , D256) ) . C500 ) = ( C507 . C500 ) & ( ( R17 . (C507 , D256) ) . C501 ) = ( C507 . C502 ) & ( ( R17 . (C507 , D256) ) . C502 ) = ( ( C507 . C501 ) + ( C507 . C502 ) )) by L1367 , L1345 , L1347 , L1353 , L1365 , L1359 , L1361 , L1360 , L1366 , L1363 , L1362 , L1364 , L1358 , L849;
end;
L1369: (for B448 being (Element of ( Funcs (R7 , ( INT )) )) holds (S18[ B448 ] implies (S18[ ( R17 . (B448 , ( D256 \; ( C504 += 1 ) )) ) ] & S18[ ( R17 . (B448 , ( C504 leq C500 )) ) ])))
proof
let C508 being (Element of ( Funcs (R7 , ( INT )) ));
given C509 being (Element of ( NAT )) such that
L1370: C509 = ( ( C508 . C504 ) - 1 )
and
L1371: ( C508 . C501 ) = ( Fib C509 )
and
L1372: ( C508 . C502 ) = ( Fib ( C509 + 1 ) );

reconsider D261 = ( R17 . (C508 , D256) ) as (Element of D252);
reconsider D262 = ( R17 . (D261 , ( C504 += 1 )) ) as (Element of D252);
L1373: ( D261 . C501 ) = ( C508 . C502 ) by L1357;
L1374: ( D262 . C504 ) = ( ( D261 . C504 ) + 1 ) by L838;
L1375: ( D261 . C502 ) = ( ( C508 . C501 ) + ( C508 . C502 ) ) by L1357;
L1376: ( D262 . C502 ) = ( D261 . C502 ) by L1347 , L838;
thus L1377: S18[ (( R17 . (C508 , ( D256 \; ( C504 += 1 ) )) ) qua (Element of D252)) ]
proof
take ( C509 + 1 );
L1378: ( R17 . (C508 , ( D256 \; ( C504 += 1 ) )) ) = D262 by AOFA_000:def 29;
thus L1379: thesis by L1378 , L1350 , L1357 , L1370 , L1371 , L1372 , L1373 , L1375 , L1376 , L1374 , L838 , PRE_FF:1;
end;

take C509;
thus L1380: thesis by L1335 , L1337 , L1338 , L1340 , L1370 , L1371 , L1372 , L879;
end;
reconsider D263 = ( for-do (( C504 := D257 ) , ( C504 leq C500 ) , ( C504 += 1 ) , D256) ) as (Element of R6);
reconsider D264 = ( R17 . (D254 , ( for-do (( C504 := 1 ) , ( C504 leq C500 ) , ( C504 += 1 ) , ( ( ( C503 := C501 ) \; ( C501 := C502 ) ) \; ( C502 += C503 ) )) )) ) as (Element of D252);
let C510 being (Element of ( NAT ));
assume L1381: C510 = ( C506 . C500 );
L1382: D263 = ( for-do (( C504 := D257 ) , ( C504 leq C500 ) , ( C504 += 1 ) , D256) );
L1383: ( R17 . (C506 , ( ( C501 := ( 0 ) ) \; ( C502 := 1 ) )) ) = D254 by AOFA_000:def 29;
L1384: ( R17 . (C506 , ( ( ( C501 := ( 0 ) ) \; ( C502 := 1 ) ) \; D263 )) ) = D264 by L1383 , AOFA_000:def 29;
L1385: ((( 0 ) <= C510 & C510 <= ( 0 )) or C510 >= ( (( 0 ) qua (Element of ( NAT ))) + 1 )) by NAT_1:13;
L1386: (C500 <> C504 & C500 <> R16 & C504 <> R16) by L1335 , L1336 , L1340;
L1387: ( D257 . D254 ) = 1 by FUNCOP_1:7;
L1388: (for B449 being (Element of ( Funcs (R7 , ( INT )) )) holds (S18[ B449 ] implies (( ( R17 . (B449 , D256) ) . C504 ) = ( B449 . C504 ) & ( ( R17 . (B449 , D256) ) . C500 ) = ( B449 . C500 )))) by L1357;
L1389: (S18[ ( R17 . (D254 , D263) ) ] & (( D257 . D254 ) <= ( D254 . C500 ) implies ( ( R17 . (D254 , D263) ) . C504 ) = ( ( D254 . C500 ) + 1 )) & (( D257 . D254 ) > ( D254 . C500 ) implies ( ( R17 . (D254 , D263) ) . C504 ) = ( D257 . D254 )) & ( ( R17 . (D254 , D263) ) . C500 ) = ( D254 . C500 )) from ForToIteration(L1382 , L1355 , L1369 , L1388 , L1386);
L1390: ( D254 . C500 ) = ( D253 . C500 ) by L1345 , L828;
thus L1391: thesis by L1390 , L1381 , L1384 , L1341 , L1389 , L1385 , L1387 , L828;
end;
L1392: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B450 , B451 , B452 being (Variable of R17) holds ((ex B453 being Function st (( B453 . R16 ) = ( 0 ) & ( B453 . B450 ) = 1 & ( B453 . B451 ) = 2 & ( B453 . B452 ) = 3)) implies (for B454 being (Element of ( Funcs (R7 , ( INT )) )) holds (( ( R17 . (B454 , ( ( ( ( B452 := B450 ) \; ( B452 %= B451 ) ) \; ( B450 := B451 ) ) \; ( B451 := B452 ) )) ) . B450 ) = ( B454 . B451 ) & ( ( R17 . (B454 , ( ( ( ( B452 := B450 ) \; ( B452 %= B451 ) ) \; ( B450 := B451 ) ) \; ( B451 := B452 ) )) ) . B451 ) = ( ( B454 . B450 ) mod ( B454 . B451 ) ) & (for B455 , B456 being (Element of ( NAT )) holds ((B456 = ( B454 . B451 ) & (B454 in ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ) iff B456 > ( 0 ))) implies R17 iteration_terminates_for ( ( ( ( ( B452 := B450 ) \; ( B452 %= B451 ) ) \; ( B450 := B451 ) ) \; ( B451 := B452 ) ) \; ( B451 gt ( 0 ) ) ) , B454))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D265 = R17;
set D266 = ( Funcs (R7 , ( INT )) );
set D267 = ( D266 \ (R16 , ( 0 )) );
let C511 , C512 , C513 being (Variable of D265);
given C514 being Function such that
L1393: ( C514 . R16 ) = ( 0 )
and
L1394: ( C514 . C511 ) = 1
and
L1395: ( C514 . C512 ) = 2
and
L1396: ( C514 . C513 ) = 3;

L1397: C513 <> C511 by L1394 , L1396;
let C515 being (Element of ( Funcs (R7 , ( INT )) ));
set D268 = ( ( ( ( C513 := C511 ) \; ( C513 %= C512 ) ) \; ( C511 := C512 ) ) \; ( C512 := C513 ) );
L1398: C512 <> C513 by L1395 , L1396;
L1399: C511 <> C512 by L1394 , L1395;
L1400:
now
let C516 being (Element of D266);
reconsider D269 = ( D265 . (C516 , ( C513 := C511 )) ) as (Element of D266);
reconsider D270 = ( D265 . (D269 , ( C513 %= C512 )) ) as (Element of D266);
reconsider D271 = ( D265 . (D270 , ( C511 := C512 )) ) as (Element of D266);
reconsider D272 = ( D265 . (D271 , ( C512 := C513 )) ) as (Element of D266);
L1401: ( D265 . (C516 , D268) ) = ( D265 . (( D265 . (C516 , ( ( ( C513 := C511 ) \; ( C513 %= C512 ) ) \; ( C511 := C512 ) )) ) , ( C512 := C513 )) ) by AOFA_000:def 29
.= ( D265 . (( D265 . (( D265 . (C516 , ( ( C513 := C511 ) \; ( C513 %= C512 ) )) ) , ( C511 := C512 )) ) , ( C512 := C513 )) ) by AOFA_000:def 29
.= D272 by AOFA_000:def 29;
L1402: ( D269 . C513 ) = ( C516 . C511 ) by L835;
L1403: ( D270 . C512 ) = ( D269 . C512 ) by L1398 , L942;
L1404: ( D270 . C513 ) = ( ( D269 . C513 ) mod ( D269 . C512 ) ) by L942;
L1405: ( D271 . C513 ) = ( D270 . C513 ) by L1397 , L835;
L1406: ( D271 . C511 ) = ( D270 . C512 ) by L835;
L1407: ( D269 . C512 ) = ( C516 . C512 ) by L1398 , L835;
thus L1408: (( ( D265 . (C516 , D268) ) . C511 ) = ( C516 . C512 ) & ( ( D265 . (C516 , D268) ) . C512 ) = ( ( C516 . C511 ) mod ( C516 . C512 ) )) by L1407 , L1399 , L1401 , L1402 , L1403 , L1404 , L1406 , L1405 , L835;
end;
thus L1409: (( ( R17 . (C515 , D268) ) . C511 ) = ( C515 . C512 ) & ( ( D265 . (C515 , D268) ) . C512 ) = ( ( C515 . C511 ) mod ( C515 . C512 ) )) by L1400;
deffunc H12((Element of D266)) = ( In (( $1 . C512 ) , ( NAT )) );
defpred S19[ (Element of D266) ] means ( $1 . C512 ) > ( 0 );
set D273 = ( C512 gt ( 0 ) );
L1410: (for B457 being (Element of D266) holds (S19[ B457 ] implies ((S19[ (( D265 . (B457 , ( D268 \; D273 )) ) qua (Element of D266)) ] iff ( D265 . (B457 , ( D268 \; D273 )) ) in D267) & H12((( D265 . (B457 , ( D268 \; D273 )) ) qua (Element of D266))) < H12(B457))))
proof
let C517 being (Element of D266);
assume L1411: ( C517 . C512 ) > ( 0 );
reconsider D274 = ( D265 . (C517 , D268) ) as (Element of D266);
L1412: ( D274 . C512 ) = ( ( C517 . C511 ) mod ( C517 . C512 ) ) by L1400;
L1413: ( 0 ) <= ( D274 . C512 ) by L1412 , L1411 , NEWTON:64;
reconsider D275 = ( D265 . (D274 , D273) ) as (Element of D266);
L1414: ( D265 . (C517 , ( D268 \; D273 )) ) = D275 by AOFA_000:def 29;
L1415: (( D274 . C512 ) <= ( 0 ) implies ( D275 . R16 ) = ( 0 )) by L898;
L1416: (( D274 . C512 ) > ( 0 ) implies ( D275 . R16 ) = 1) by L898;
thus L1417: (S19[ (( D265 . (C517 , ( D268 \; D273 )) ) qua (Element of D266)) ] iff ( D265 . (C517 , ( D268 \; D273 )) ) in D267) by L1416 , L1414 , L1415 , L21 , L898;
L1418: ( D275 . C512 ) = ( D274 . C512 ) by L1393 , L1395 , L898;
L1419: H12(D275) = ( D274 . C512 ) by L1418 , L1413 , FUNCT_7:def 1 , INT_1:3;
L1420: ( D274 . C512 ) < ( C517 . C512 ) by L1411 , L1412 , NEWTON:65;
L1421: H12(C517) = ( C517 . C512 ) by L1420 , L1413 , FUNCT_7:def 1 , INT_1:3;
thus L1422: thesis by L1421 , L1420 , L1419 , AOFA_000:def 29;
end;
let C518 , C519 being (Element of ( NAT ));
assume that
L1423: C519 = ( C515 . C512 );
assume L1424: (C515 in D267 iff C519 > ( 0 ));
L1425: (C515 in D267 iff S19[ C515 ]) by L1424 , L1423;
L1426: D265 iteration_terminates_for ( D268 \; D273 ) , C515 from AOFA_000:sch 3(L1425 , L1410);
thus L1427: thesis by L1426;
end;
theorem
L1428: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B458 , B459 , B460 being (Variable of R17) holds ((ex B461 being Function st (( B461 . R16 ) = ( 0 ) & ( B461 . B458 ) = 1 & ( B461 . B459 ) = 2 & ( B461 . B460 ) = 3)) implies ( while (( B459 gt ( 0 ) ) , ( ( ( ( B460 := B458 ) \; ( B460 %= B459 ) ) \; ( B458 := B459 ) ) \; ( B459 := B460 ) )) ) is_terminating_wrt R17 , { R9 where R9 is (Element of ( Funcs (R7 , ( INT )) )) : (( R9 . B458 ) > ( R9 . B459 ) & ( R9 . B459 ) >= ( 0 )) }))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D276 = ( Funcs (R7 , ( INT )) );
set D277 = ( D276 \ (R16 , ( 0 )) );
let C520 , C521 , C522 being (Variable of R17);
set D278 = { R9 where R9 is (Element of ( Funcs (R7 , ( INT )) )) : (( R9 . C520 ) > ( R9 . C521 ) & ( R9 . C521 ) >= ( 0 )) };
given C523 being Function such that
L1429: ( C523 . R16 ) = ( 0 )
and
L1430: ( C523 . C520 ) = 1
and
L1431: ( C523 . C521 ) = 2
and
L1432: ( C523 . C522 ) = 3;

set D279 = ( C521 gt ( 0 ) );
set D280 = ( ( ( ( C522 := C520 ) \; ( C522 %= C521 ) ) \; ( C520 := C521 ) ) \; ( C521 := C522 ) );
L1433: D278 is_invariant_wrt D279 , R17
proof
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
set D281 = ( R17 . (R9 , D279) );
assume L1434: R9 in D278;
L1435: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R10 = R9 & ( R10 . C520 ) > ( R10 . C521 ) & ( R10 . C521 ) >= ( 0 ))) by L1434;
L1436: ( D281 . C521 ) = ( R9 . C521 ) by L1429 , L1431 , L898;
L1437: ( D281 . C520 ) = ( R9 . C520 ) by L1429 , L1430 , L898;
thus L1438: thesis by L1437 , L1435 , L1436;
end;
L1439:
now
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
assume L1440: R9 in D278;
L1441: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R10 = R9 & ( R10 . C520 ) > ( R10 . C521 ) & ( R10 . C521 ) >= ( 0 ))) by L1440;
reconsider D282 = ( R9 . C521 ) as (Element of ( NAT )) by L1441 , INT_1:3;
assume L1442: ( R17 . (( R17 . (R9 , D280) ) , D279) ) in D277;
L1443: ( ( R17 . (( R17 . (R9 , D280) ) , D279) ) . R16 ) <> ( 0 ) by L1442 , L21;
L1444: ( ( R17 . (R9 , D280) ) . C521 ) > ( 0 ) by L1443 , L898;
L1445: ( ( R17 . (R9 , D280) ) . C520 ) = ( R9 . C521 ) by L1429 , L1430 , L1431 , L1432 , L1392;
L1446: ( ( R17 . (R9 , D280) ) . C521 ) = ( ( R9 . C520 ) mod ( R9 . C521 ) ) by L1429 , L1430 , L1431 , L1432 , L1392;
L1447: D282 <> ( 0 ) by L1446 , L1444 , INT_1:def 10;
L1448: ( ( R17 . (R9 , D280) ) . C520 ) > ( ( R17 . (R9 , D280) ) . C521 ) by L1447 , L1446 , L1445 , NEWTON:65;
thus L1449: ( R17 . (R9 , D280) ) in D278 by L1448 , L1444;
end;
L1450:
now
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
set D283 = ( R17 . (R9 , D279) );
L1451: (( R9 . C521 ) <= ( 0 ) implies ( D283 . R16 ) = ( 0 )) by L898;
assume L1452: ( R17 . (R9 , D279) ) in D278;
L1453: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R10 = ( R17 . (R9 , D279) ) & ( R10 . C520 ) > ( R10 . C521 ) & ( R10 . C521 ) >= ( 0 ))) by L1452;
reconsider D284 = ( D283 . C521 ) as (Element of ( NAT )) by L1453 , INT_1:3;
L1454: (( R9 . C521 ) > ( 0 ) implies ( D283 . R16 ) = 1) by L898;
L1455: (D283 in D277 iff D284 > ( 0 )) by L1454 , L1451 , L21 , L898;
thus L1456: R17 iteration_terminates_for ( D280 \; D279 ) , ( R17 . (R9 , D279) ) by L1455 , L1429 , L1430 , L1431 , L1432 , L1392;
end;
L1457: D279 is_terminating_wrt R17 by AOFA_000:104;
thus L1458: thesis by L1457 , L1433 , L1439 , L1450 , AOFA_000:107 , AOFA_000:118;
end;
theorem
L1459: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B462 , B463 , B464 being (Variable of R17) holds ((ex B465 being Function st (( B465 . R16 ) = ( 0 ) & ( B465 . B462 ) = 1 & ( B465 . B463 ) = 2 & ( B465 . B464 ) = 3)) implies (for B466 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B467 , B468 being (Element of ( NAT )) holds ((B467 = ( B466 . B462 ) & B468 = ( B466 . B463 ) & B467 > B468) implies ( ( R17 . (B466 , ( while (( B463 gt ( 0 ) ) , ( ( ( ( B464 := B462 ) \; ( B464 %= B463 ) ) \; ( B462 := B463 ) ) \; ( B463 := B464 ) )) )) ) . B462 ) = ( B467 gcd B468 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D285 = R17;
set D286 = ( Funcs (R7 , ( INT )) );
set D287 = ( D286 \ (R16 , ( 0 )) );
let C524 , C525 , C526 being (Variable of D285);
given C527 being Function such that
L1460: ( C527 . R16 ) = ( 0 )
and
L1461: ( C527 . C524 ) = 1
and
L1462: ( C527 . C525 ) = 2
and
L1463: ( C527 . C526 ) = 3;

set D288 = ( C525 gt ( 0 ) );
set D289 = ( ( ( ( C526 := C524 ) \; ( C526 %= C525 ) ) \; ( C524 := C525 ) ) \; ( C525 := C526 ) );
let C528 being (Element of ( Funcs (R7 , ( INT )) ));
reconsider D290 = ( D285 . (C528 , ( while (D288 , D289) )) ) as (Element of D286);
defpred S20[ (Element of D286) ] means (( D290 . C524 ) divides ( $1 . C524 ) & ( D290 . C524 ) divides ( $1 . C525 ));
L1464: (for B469 being (Element of D286) holds (S20[ (( D285 . (B469 , D288) ) qua (Element of D286)) ] implies S20[ B469 ])) by L1460 , L1461 , L1462 , L898;
L1465: (for B470 being (Element of D286) holds ((S20[ (( D285 . (( D285 . (B470 , D288) ) , D289) ) qua (Element of D286)) ] & ( D285 . (B470 , D288) ) in D287) implies S20[ (( D285 . (B470 , D288) ) qua (Element of D286)) ]))
proof
let C529 being (Element of D286);
assume L1466: S20[ (( D285 . (( D285 . (C529 , D288) ) , D289) ) qua (Element of D286)) ];
reconsider D291 = ( D285 . (C529 , D288) ) as (Element of D286);
reconsider D292 = ( D285 . (D291 , D289) ) as (Element of D286);
L1467: (( C529 . C525 ) <= ( 0 ) implies ( D291 . R16 ) = ( 0 )) by L898;
L1468: ( D291 . C524 ) = ( C529 . C524 ) by L1460 , L1461 , L898;
L1469: ( D292 . C525 ) = ( ( D291 . C524 ) mod ( D291 . C525 ) ) by L1460 , L1461 , L1462 , L1463 , L1392;
L1470: ( D292 . C524 ) = ( D291 . C525 ) by L1460 , L1461 , L1462 , L1463 , L1392;
L1471: ( D291 . C525 ) = ( C529 . C525 ) by L1460 , L1462 , L898;
assume L1472: ( D285 . (C529 , D288) ) in D287;
L1473: ( C529 . C524 ) = ( ( ( ( C529 . C524 ) div ( C529 . C525 ) ) * ( D292 . C524 ) ) + ( ( D292 . C525 ) * 1 ) ) by L1472 , L1468 , L1471 , L1467 , L1470 , L1469 , L21 , NEWTON:66;
thus L1474: thesis by L1473 , L1460 , L1461 , L1462 , L1463 , L1466 , L1468 , L1392 , WSIERP_1:5;
end;
reconsider D293 = ( D285 . (C528 , D288) ) as (Element of D286);
L1475: ( D293 . C525 ) = ( C528 . C525 ) by L1460 , L1462 , L898;
L1476: (( C528 . C525 ) <= ( 0 ) implies ( D293 . R16 ) = ( 0 )) by L898;
let C530 , C531 being (Element of ( NAT ));
defpred S21[ (Element of D286) ] means (( C530 gcd C531 ) divides ( $1 . C524 ) & ( C530 gcd C531 ) divides ( $1 . C525 ) & ( $1 . C524 ) > ( $1 . C525 ) & ( $1 . C525 ) >= ( 0 ));
defpred S22[ (Element of D286) ] means ( $1 . C525 ) > ( 0 );
assume that
L1477: C530 = ( C528 . C524 )
and
L1478: C531 = ( C528 . C525 )
and
L1479: C530 > C531;
L1480: (( C528 . C525 ) > ( 0 ) implies ( D293 . R16 ) = 1) by L898;
L1481: (D293 in D287 iff C531 > ( 0 )) by L1480 , L1478 , L1476 , L21;
L1482: D285 iteration_terminates_for ( D289 \; D288 ) , ( D285 . (C528 , D288) ) by L1481 , L1460 , L1461 , L1462 , L1463 , L1478 , L1475 , L1392;
L1483: (for B471 being (Element of D286) holds ((S21[ B471 ] & B471 in D287 & S22[ B471 ]) implies S21[ ( D285 . (B471 , D289) ) ]))
proof
let C532 being (Element of D286);
reconsider D294 = ( D285 . (C532 , D289) ) as (Element of D286);
assume L1484: S21[ C532 ];
reconsider D295 = ( C532 . C524 ) , D296 = ( C532 . C525 ) as (Element of ( NAT )) by L1484 , INT_1:3;
assume that
L1485: C532 in D287
and
L1486: S22[ C532 ];
L1487: ( D294 . C524 ) = ( C532 . C525 ) by L1460 , L1461 , L1462 , L1463 , L1392;
L1488: ( D294 . C525 ) = ( ( C532 . C524 ) mod ( C532 . C525 ) ) by L1460 , L1461 , L1462 , L1463 , L1392;
L1489: ( C530 gcd C531 ) divides ( D295 mod D296 ) by L1484 , NAT_D:11;
thus L1490: thesis by L1489 , L1484 , L1486 , L1487 , L1488 , NEWTON:65;
end;
L1491: (for B472 being (Element of D286) holds (S21[ B472 ] implies (S21[ (( D285 . (B472 , D288) ) qua (Element of D286)) ] & (( D285 . (B472 , D288) ) in D287 iff S22[ (( D285 . (B472 , D288) ) qua (Element of D286)) ]))))
proof
let C533 being (Element of D286);
assume L1492: S21[ C533 ];
reconsider D297 = ( D285 . (C533 , D288) ) as (Element of D286);
L1493: ( D297 . C525 ) = ( C533 . C525 ) by L1460 , L1462 , L898;
thus L1494: S21[ (( D285 . (C533 , D288) ) qua (Element of D286)) ] by L1493 , L1460 , L1461 , L1492 , L898;
L1495: (( C533 . C525 ) <= ( 0 ) implies ( D297 . R16 ) = ( 0 )) by L898;
L1496: (( C533 . C525 ) > ( 0 ) implies ( D297 . R16 ) = 1) by L898;
thus L1497: thesis by L1496 , L1495 , L21 , L898;
end;
L1498: S21[ C528 ] by L1477 , L1478 , L1479 , NAT_D:def 5;
L1499: (S21[ (( D285 . (C528 , ( while (D288 , D289) )) ) qua (Element of D286)) ] & (not S22[ (( D285 . (C528 , ( while (D288 , D289) )) ) qua (Element of D286)) ])) from AOFA_000:sch 5(L1498 , L1482 , L1483 , L1491);
L1500: ( D290 . C525 ) = ( 0 ) by L1499;
L1501: S20[ (( D285 . (C528 , ( while (D288 , D289) )) ) qua (Element of D286)) ] by L1500 , INT_2:12;
L1502: S20[ C528 ] from AOFA_000:sch 6(L1501 , L1482 , L1465 , L1464);
L1503: ( D290 . C524 ) divides ( C530 gcd C531 ) by L1502 , L1477 , L1478 , INT_2:22;
L1504: (( D290 . C524 ) = ( C530 gcd C531 ) or ( D290 . C524 ) = ( - ( C530 gcd C531 ) )) by L1503 , L1499 , INT_2:11;
thus L1505: thesis by L1504 , L1499;
end;
L1506: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B473 , B474 , B475 being (Variable of R17) holds ((ex B476 being Function st (( B476 . R16 ) = ( 0 ) & ( B476 . B473 ) = 1 & ( B476 . B474 ) = 2 & ( B476 . B475 ) = 3)) implies (for B477 being (Element of ( Funcs (R7 , ( INT )) )) holds (( ( R17 . (B477 , ( ( ( ( B475 := ( ( . B473 ) - ( . B474 ) ) ) \; ( if-then (( B475 lt ( 0 ) ) , ( B475 *= ( - 1 ) )) ) ) \; ( B473 := B474 ) ) \; ( B474 := B475 ) )) ) . B473 ) = ( B477 . B474 ) & ( ( R17 . (B477 , ( ( ( ( B475 := ( ( . B473 ) - ( . B474 ) ) ) \; ( if-then (( B475 lt ( 0 ) ) , ( B475 *= ( - 1 ) )) ) ) \; ( B473 := B474 ) ) \; ( B474 := B475 ) )) ) . B474 ) = ( abs ( ( B477 . B473 ) - ( B477 . B474 ) ) ) & (for B478 , B479 being (Element of ( NAT )) holds ((B478 = ( B477 . B473 ) & B479 = ( B477 . B474 ) & (B477 in ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ) iff B479 > ( 0 ))) implies R17 iteration_terminates_for ( ( ( ( ( B475 := ( ( . B473 ) - ( . B474 ) ) ) \; ( if-then (( B475 lt ( 0 ) ) , ( B475 *= ( - 1 ) )) ) ) \; ( B473 := B474 ) ) \; ( B474 := B475 ) ) \; ( B474 gt ( 0 ) ) ) , B477))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D298 = ( Funcs (R7 , ( INT )) );
set D299 = ( D298 \ (R16 , ( 0 )) );
let C534 , C535 , C536 being (Variable of R17);
given C537 being Function such that
L1507: ( C537 . R16 ) = ( 0 )
and
L1508: ( C537 . C534 ) = 1
and
L1509: ( C537 . C535 ) = 2
and
L1510: ( C537 . C536 ) = 3;

L1511: C535 <> C536 by L1509 , L1510;
let C538 being (Element of ( Funcs (R7 , ( INT )) ));
set D300 = ( if-then (( C536 lt ( 0 ) ) , ( C536 *= ( - 1 ) )) );
L1512: R17 complies_with_if_wrt D299 by AOFA_000:def 32;
L1513: C536 <> C534 by L1508 , L1510;
set D301 = ( ( ( ( C536 := ( ( . C534 ) - ( . C535 ) ) ) \; D300 ) \; ( C534 := C535 ) ) \; ( C535 := C536 ) );
L1514: C534 <> C535 by L1508 , L1509;
L1515:
now
let C539 being (Element of D298);
set D302 = ( R17 . (C539 , ( C536 := ( ( . C534 ) - ( . C535 ) ) )) );
set D303 = ( R17 . (D302 , ( C536 lt ( 0 ) )) );
set D304 = ( R17 . (D302 , D300) );
set D305 = ( R17 . (D303 , ( C536 *= ( - 1 ) )) );
L1516: ( ( D303 . C536 ) * ( - 1 ) ) = ( - ( D303 . C536 ) );
set D306 = ( R17 . (D304 , ( C534 := C535 )) );
set D307 = ( R17 . (D306 , ( C535 := C536 )) );
L1517: ( R17 . (C539 , D301) ) = ( R17 . (( R17 . (C539 , ( ( ( C536 := ( ( . C534 ) - ( . C535 ) ) ) \; D300 ) \; ( C534 := C535 ) )) ) , ( C535 := C536 )) ) by AOFA_000:def 29
.= ( R17 . (( R17 . (( R17 . (C539 , ( ( C536 := ( ( . C534 ) - ( . C535 ) ) ) \; D300 )) ) , ( C534 := C535 )) ) , ( C535 := C536 )) ) by AOFA_000:def 29
.= D307 by AOFA_000:def 29;
L1518: (( D303 . R16 ) = 1 implies D303 in D299);
L1519: (( D303 . R16 ) = 1 implies D304 = D305) by L1518 , L1512 , AOFA_000:def 30;
L1520: ( ( . C534 ) . C539 ) = ( C539 . C534 ) by L776;
L1521: ( D305 . C535 ) = ( D303 . C535 ) by L1511 , L852;
L1522: ( ( . C535 ) . C539 ) = ( C539 . C535 ) by L776;
L1523: ( ( ( . C534 ) - ( . C535 ) ) . C539 ) = ( ( ( . C534 ) . C539 ) - ( ( . C535 ) . C539 ) ) by L170;
L1524: ( D302 . C536 ) = ( ( C539 . C534 ) - ( C539 . C535 ) ) by L1523 , L1520 , L1522 , L832;
L1525: (( D302 . C536 ) < ( 0 ) implies ( D303 . R16 ) = 1) by L898;
L1526: ( D303 . C536 ) = ( D302 . C536 ) by L1507 , L1510 , L898;
L1527: ( D305 . C536 ) = ( ( D303 . C536 ) * ( - 1 ) ) by L852;
L1528: ( D306 . C536 ) = ( D304 . C536 ) by L1513 , L835;
L1529: ( D307 . C535 ) = ( D306 . C536 ) by L835;
L1530: (( D303 . R16 ) = ( 0 ) implies D303 nin D299) by L21;
L1531: (( D303 . R16 ) = ( 0 ) implies D304 = D303) by L1530 , L1512 , AOFA_000:80;
L1532: (( D302 . C536 ) >= ( 0 ) implies ( D303 . R16 ) = ( 0 )) by L898;
L1533: ( D302 . C535 ) = ( C539 . C535 ) by L1511 , L832;
L1534: ( D306 . C534 ) = ( D304 . C535 ) by L835;
L1535: ( D303 . C535 ) = ( D302 . C535 ) by L1507 , L1509 , L898;
thus L1536: (( ( R17 . (C539 , D301) ) . C534 ) = ( C539 . C535 ) & ( ( R17 . (C539 , D301) ) . C535 ) = ( abs ( ( C539 . C534 ) - ( C539 . C535 ) ) )) by L1535 , L1514 , L1531 , L1519 , L1526 , L1525 , L1532 , L1521 , L1527 , L1516 , L1517 , L1533 , L1524 , L1534 , L1528 , L1529 , L835 , ABSVALUE:def 1;
end;
thus L1537: (( ( R17 . (C538 , D301) ) . C534 ) = ( C538 . C535 ) & ( ( R17 . (C538 , D301) ) . C535 ) = ( abs ( ( C538 . C534 ) - ( C538 . C535 ) ) )) by L1515;
deffunc H13((Element of D298)) = ( IFEQ (( $1 . C535 ) , ( 0 ) , ( 0 ) , ( IFEQ (( $1 . C534 ) , ( 0 ) , 2 , ( IFEQ (( $1 . C534 ) , ( $1 . C535 ) , 1 , ( In (( max (( 2 * ( $1 . C534 ) ) , ( ( 2 * ( $1 . C535 ) ) + 1 )) ) , ( NAT )) )) )) )) );
defpred S23[ (Element of D298) ] means (( $1 . C534 ) >= ( 0 ) & ( $1 . C535 ) > ( 0 ));
set D308 = ( C535 gt ( 0 ) );
L1538: (for B480 being (Element of D298) holds (S23[ B480 ] implies ((S23[ (( R17 . (B480 , ( D301 \; D308 )) ) qua (Element of D298)) ] iff ( R17 . (B480 , ( D301 \; D308 )) ) in D299) & H13((( R17 . (B480 , ( D301 \; D308 )) ) qua (Element of D298))) < H13(B480))))
proof
let C540 being (Element of D298);
assume that
L1539: ( C540 . C534 ) >= ( 0 )
and
L1540: ( C540 . C535 ) > ( 0 );
reconsider D309 = ( R17 . (C540 , D301) ) as (Element of D298);
reconsider D310 = ( R17 . (D309 , D308) ) as (Element of D298);
L1541: ( D309 . C535 ) = ( abs ( ( C540 . C534 ) - ( C540 . C535 ) ) ) by L1515;
reconsider D311 = ( C540 . C534 ) , D312 = ( C540 . C535 ) , D313 = ( D310 . C535 ) as (Element of ( NAT )) by L1541 , L1507 , L1509 , L1539 , L1540 , L898 , INT_1:3;
L1542: ( R17 . (C540 , ( D301 \; D308 )) ) = D310 by AOFA_000:def 29;
L1543: ( D310 . C534 ) = ( D309 . C534 ) by L1507 , L1508 , L898;
L1544: (( D309 . C535 ) <= ( 0 ) implies ( D310 . R16 ) = ( 0 )) by L898;
L1545: (( D309 . C535 ) > ( 0 ) implies ( D310 . R16 ) = 1) by L898;
thus L1546: (S23[ (( R17 . (C540 , ( D301 \; D308 )) ) qua (Element of D298)) ] iff ( R17 . (C540 , ( D301 \; D308 )) ) in D299) by L1545 , L1515 , L1540 , L1542 , L1543 , L1544 , L21 , L898;
L1547: ( D309 . C534 ) = ( C540 . C535 ) by L1515;
L1548: H13(D310) = ( IFEQ (D313 , ( 0 ) , ( 0 ) , ( IFEQ (D312 , ( 0 ) , 2 , ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) )) )) ) by L1543 , L1547 , FUNCT_7:def 1;
L1549: ( ( 2 * D312 ) + 1 ) > ( 2 * D312 ) by NAT_1:13;
L1550: ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) ) > ( 2 * D312 ) by L1549 , XXREAL_0:30;
L1551: ( D310 . C535 ) = ( D309 . C535 ) by L1507 , L1509 , L898;
L1552: H13(C540) = ( IFEQ (D312 , ( 0 ) , ( 0 ) , ( IFEQ (D311 , ( 0 ) , 2 , ( IFEQ (D311 , D312 , 1 , ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) )) )) )) ) by FUNCT_7:def 1
.= ( IFEQ (D311 , ( 0 ) , 2 , ( IFEQ (D311 , D312 , 1 , ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) )) )) ) by L1540 , FUNCOP_1:def 8;
per cases  by XXREAL_0:1;
suppose L1553: D311 = D312;

L1554: ( IFEQ (D311 , D312 , 1 , ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) )) ) = 1 by L1553 , FUNCOP_1:def 8;
L1555: D313 = ( 0 ) by L1551 , L1541 , L1553 , ABSVALUE:2;
L1556: H13(C540) = ( IFEQ (D311 , D312 , 1 , ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) )) ) by L1540 , L1552 , L1553 , FUNCOP_1:def 8;
thus L1557: thesis by L1556 , L1542 , L1554 , L1555 , FUNCOP_1:def 8;
end;
suppose L1558: D311 > D312;

L1559: ( IFEQ (D311 , D312 , 1 , ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) )) ) = ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) ) by L1558 , FUNCOP_1:def 8;
L1560: H13(C540) = ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) ) by L1559 , L1552 , L1558 , FUNCOP_1:def 8;
L1561: ( D311 - D312 ) > ( 0 ) by L1558 , XREAL_1:50;
L1562: H13(D310) = ( IFEQ (D312 , ( 0 ) , 2 , ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) )) ) by L1561 , L1551 , L1545 , L1544 , L1541 , L1548 , ABSVALUE:def 1 , FUNCOP_1:def 8
.= ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) ) by L1540 , FUNCOP_1:def 8;
L1563: (D312 = D313 implies H13(D310) = 1) by L1562 , FUNCOP_1:def 8;
L1564: D313 = ( D311 - D312 ) by L1551 , L1541 , L1561 , ABSVALUE:def 1;
L1565: D313 < D311 by L1564 , L1540 , XREAL_1:44;
L1566: ( D313 + 1 ) <= D311 by L1565 , NAT_1:13;
L1567: ( 2 * ( D313 + 1 ) ) <= ( 2 * D311 ) by L1566 , XREAL_1:64;
L1568: 1 <= ( ( 2 * D313 ) + 1 ) by NAT_1:11;
L1569: (D312 <> D313 implies H13(D310) = ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) by L1562 , FUNCOP_1:def 8;
L1570: ( ( 2 * D313 ) + 2 ) = ( ( ( 2 * D313 ) + 1 ) + 1 );
L1571: ( ( 2 * D313 ) + 1 ) < ( 2 * D311 ) by L1570 , L1567 , NAT_1:13;
L1572: ( ( 2 * D313 ) + 1 ) < H13(C540) by L1571 , L1560 , XXREAL_0:30;
thus L1573: thesis by L1572 , L1542 , L1550 , L1560 , L1563 , L1569 , L1568 , XXREAL_0:2 , XXREAL_0:29;
end;
suppose L1574: (D311 < D312 & D311 > ( 0 ));

L1575: ( - ( D311 - D312 ) ) = ( D312 - D311 );
L1576: ( D311 - D312 ) < ( 0 ) by L1574 , XREAL_1:49;
L1577: D313 = ( - ( D311 - D312 ) ) by L1576 , L1551 , L1541 , ABSVALUE:def 1;
L1578: D313 < D312 by L1577 , L1574 , L1575 , XREAL_1:44;
L1579: ( 2 * D313 ) < ( 2 * D312 ) by L1574 , L1577 , L1575 , XREAL_1:44 , XREAL_1:68;
L1580: ( ( 2 * D313 ) + 1 ) < ( ( 2 * D312 ) + 1 ) by L1579 , XREAL_1:6;
L1581: ( ( 2 * D313 ) + 1 ) < ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) ) by L1580 , XXREAL_0:30;
L1582: D313 > ( 0 ) by L1551 , L1541 , L1576 , L1575 , ABSVALUE:def 1;
L1583: H13(D310) = ( IFEQ (D312 , ( 0 ) , 2 , ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) )) ) by L1582 , L1548 , FUNCOP_1:def 8
.= ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) ) by L1540 , FUNCOP_1:def 8
.= ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) ) by L1578 , FUNCOP_1:def 8;
L1584: H13(C540) = ( IFEQ (D311 , D312 , 1 , ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) )) ) by L1552 , L1574 , FUNCOP_1:def 8
.= ( max (( 2 * D311 ) , ( ( 2 * D312 ) + 1 )) ) by L1574 , FUNCOP_1:def 8;
thus L1585: thesis by L1584 , L1542 , L1550 , L1581 , L1583 , XXREAL_0:29;
end;
suppose L1586: D311 = ( 0 );

L1587: H13(C540) = 2 by L1586 , L1552 , FUNCOP_1:def 8;
L1588: D313 = ( - ( D311 - D312 ) ) by L1540 , L1551 , L1541 , L1586 , ABSVALUE:def 1
.= D312 by L1586;
L1589: H13(D310) = ( IFEQ (D312 , ( 0 ) , 2 , ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) )) ) by L1588 , L1540 , L1548 , FUNCOP_1:def 8
.= ( IFEQ (D312 , D313 , 1 , ( max (( 2 * D312 ) , ( ( 2 * D313 ) + 1 )) )) ) by L1540 , FUNCOP_1:def 8
.= 1 by L1588 , FUNCOP_1:def 8;
thus L1590: thesis by L1589 , L1542 , L1587;
end;
end;
let C541 , C542 being (Element of ( NAT ));
assume that
L1592: C541 = ( C538 . C534 )
and
L1593: C542 = ( C538 . C535 );
assume L1594: (C538 in D299 iff C542 > ( 0 ));
L1595: (C538 in D299 iff S23[ C538 ]) by L1594 , L1592 , L1593;
L1596: R17 iteration_terminates_for ( D301 \; D308 ) , C538 from AOFA_000:sch 3(L1595 , L1538);
thus L1597: thesis by L1596;
end;
theorem
L1598: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B481 , B482 , B483 being (Variable of R17) holds ((ex B484 being Function st (( B484 . R16 ) = ( 0 ) & ( B484 . B481 ) = 1 & ( B484 . B482 ) = 2 & ( B484 . B483 ) = 3)) implies ( while (( B482 gt ( 0 ) ) , ( ( ( ( B483 := ( ( . B481 ) - ( . B482 ) ) ) \; ( if-then (( B483 lt ( 0 ) ) , ( B483 *= ( - 1 ) )) ) ) \; ( B481 := B482 ) ) \; ( B482 := B483 ) )) ) is_terminating_wrt R17 , { R9 where R9 is (Element of ( Funcs (R7 , ( INT )) )) : (( R9 . B481 ) >= ( 0 ) & ( R9 . B482 ) >= ( 0 )) }))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D314 = ( Funcs (R7 , ( INT )) );
set D315 = ( D314 \ (R16 , ( 0 )) );
let C543 , C544 , C545 being (Variable of R17);
set D316 = { R9 where R9 is (Element of ( Funcs (R7 , ( INT )) )) : (( R9 . C543 ) >= ( 0 ) & ( R9 . C544 ) >= ( 0 )) };
given C546 being Function such that
L1599: ( C546 . R16 ) = ( 0 )
and
L1600: ( C546 . C543 ) = 1
and
L1601: ( C546 . C544 ) = 2
and
L1602: ( C546 . C545 ) = 3;

set D317 = ( C544 gt ( 0 ) );
set D318 = ( ( ( ( C545 := ( ( . C543 ) - ( . C544 ) ) ) \; ( if-then (( C545 lt ( 0 ) ) , ( C545 *= ( - 1 ) )) ) ) \; ( C543 := C544 ) ) \; ( C544 := C545 ) );
L1603:
now
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
assume L1604: R9 in D316;
L1605: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R10 = R9 & ( R10 . C543 ) >= ( 0 ) & ( R10 . C544 ) >= ( 0 ))) by L1604;
reconsider D319 = ( R9 . C544 ) as (Element of ( NAT )) by L1605 , INT_1:3;
assume L1606: ( R17 . (( R17 . (R9 , D318) ) , D317) ) in D315;
L1607: ( ( R17 . (R9 , D318) ) . C543 ) = D319 by L1599 , L1600 , L1601 , L1602 , L1506;
L1608: ( ( R17 . (R9 , D318) ) . C544 ) = ( abs ( ( R9 . C543 ) - ( R9 . C544 ) ) ) by L1599 , L1600 , L1601 , L1602 , L1506;
thus L1609: ( R17 . (R9 , D318) ) in D316 by L1608 , L1607;
end;
L1610:
now
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
set D320 = ( R17 . (R9 , D317) );
L1611: (( R9 . C544 ) <= ( 0 ) implies ( D320 . R16 ) = ( 0 )) by L898;
assume L1612: ( R17 . (R9 , D317) ) in D316;
L1613: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R10 = ( R17 . (R9 , D317) ) & ( R10 . C543 ) >= ( 0 ) & ( R10 . C544 ) >= ( 0 ))) by L1612;
reconsider D321 = ( D320 . C543 ) , D322 = ( D320 . C544 ) as (Element of ( NAT )) by L1613 , INT_1:3;
L1614: D321 = D321;
L1615: (( R9 . C544 ) > ( 0 ) implies ( D320 . R16 ) = 1) by L898;
L1616: (D320 in D315 iff D322 > ( 0 )) by L1615 , L1611 , L21 , L898;
thus L1617: R17 iteration_terminates_for ( D318 \; D317 ) , ( R17 . (R9 , D317) ) by L1616 , L1599 , L1600 , L1601 , L1602 , L1614 , L1506;
end;
L1618: D316 is_invariant_wrt D317 , R17
proof
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
set D323 = ( R17 . (R9 , D317) );
assume L1619: R9 in D316;
L1620: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R10 = R9 & ( R10 . C543 ) >= ( 0 ) & ( R10 . C544 ) >= ( 0 ))) by L1619;
L1621: ( D323 . C544 ) = ( R9 . C544 ) by L1599 , L1601 , L898;
L1622: ( D323 . C543 ) = ( R9 . C543 ) by L1599 , L1600 , L898;
thus L1623: thesis by L1622 , L1620 , L1621;
end;
L1624: D317 is_terminating_wrt R17 by AOFA_000:104;
thus L1625: thesis by L1624 , L1618 , L1603 , L1610 , AOFA_000:107 , AOFA_000:118;
end;
theorem
L1626: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B485 , B486 , B487 being (Variable of R17) holds ((ex B488 being Function st (( B488 . R16 ) = ( 0 ) & ( B488 . B485 ) = 1 & ( B488 . B486 ) = 2 & ( B488 . B487 ) = 3)) implies (for B489 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B490 , B491 being (Element of ( NAT )) holds ((B490 = ( B489 . B485 ) & B491 = ( B489 . B486 ) & B490 > ( 0 )) implies ( ( R17 . (B489 , ( while (( B486 gt ( 0 ) ) , ( ( ( ( B487 := ( ( . B485 ) - ( . B486 ) ) ) \; ( if-then (( B487 lt ( 0 ) ) , ( B487 *= ( - 1 ) )) ) ) \; ( B485 := B486 ) ) \; ( B486 := B487 ) )) )) ) . B485 ) = ( B490 gcd B491 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D324 = R17;
set D325 = ( Funcs (R7 , ( INT )) );
set D326 = ( D325 \ (R16 , ( 0 )) );
L1627: D324 complies_with_if_wrt D326 by AOFA_000:def 32;
let C547 , C548 , C549 being (Variable of D324);
given C550 being Function such that
L1628: ( C550 . R16 ) = ( 0 )
and
L1629: ( C550 . C547 ) = 1
and
L1630: ( C550 . C548 ) = 2
and
L1631: ( C550 . C549 ) = 3;

set D327 = ( C548 gt ( 0 ) );
let C551 being (Element of ( Funcs (R7 , ( INT )) ));
L1632: C548 <> C549 by L1630 , L1631;
reconsider D328 = ( D324 . (C551 , D327) ) as (Element of D325);
L1633: ( D328 . C547 ) = ( C551 . C547 ) by L1628 , L1629 , L898;
L1634: ( D328 . C548 ) = ( C551 . C548 ) by L1628 , L1630 , L898;
L1635: (( C551 . C548 ) <= ( 0 ) implies ( D328 . R16 ) = ( 0 )) by L898;
defpred S24[ (Element of D325) ] means (( $1 . C547 ) > ( 0 ) & ( $1 . C548 ) > ( 0 ));
let C552 , C553 being (Element of ( NAT ));
defpred S25[ (Element of D325) ] means (( C552 gcd C553 ) divides ( $1 . C547 ) & ( C552 gcd C553 ) divides ( $1 . C548 ) & ( $1 . C547 ) > ( 0 ) & ( $1 . C548 ) >= ( 0 ) & (for B492 being Nat holds ((B492 divides ( $1 . C547 ) & B492 divides ( $1 . C548 )) implies B492 divides ( C552 gcd C553 ))));
set D329 = ( if-then (( C549 lt ( 0 ) ) , ( C549 *= ( - 1 ) )) );
set D330 = ( ( ( ( C549 := ( ( . C547 ) - ( . C548 ) ) ) \; D329 ) \; ( C547 := C548 ) ) \; ( C548 := C549 ) );
assume that
L1636: C552 = ( C551 . C547 )
and
L1637: C553 = ( C551 . C548 )
and
L1638: C552 > ( 0 );
L1639: (( C551 . C548 ) > ( 0 ) implies ( D328 . R16 ) = 1) by L898;
L1640: (D328 in D326 iff S24[ D328 ]) by L1639 , L1636 , L1638 , L1635 , L21 , L898;
L1641: D324 iteration_terminates_for ( D330 \; D327 ) , ( D324 . (C551 , D327) ) by L1640 , L1628 , L1629 , L1630 , L1631 , L1636 , L1637 , L1638 , L1633 , L1634 , L1506;
L1642: C549 <> C547 by L1629 , L1631;
L1643: C547 <> C548 by L1629 , L1630;
L1644:
now
let C554 being (Element of D325);
set D331 = ( D324 . (C554 , ( C549 := ( ( . C547 ) - ( . C548 ) ) )) );
set D332 = ( D324 . (D331 , ( C549 lt ( 0 ) )) );
set D333 = ( D324 . (D331 , D329) );
set D334 = ( D324 . (D332 , ( C549 *= ( - 1 ) )) );
L1645: ( ( D332 . C549 ) * ( - 1 ) ) = ( - ( D332 . C549 ) );
set D335 = ( D324 . (D333 , ( C547 := C548 )) );
set D336 = ( D324 . (D335 , ( C548 := C549 )) );
L1646: ( D324 . (C554 , D330) ) = ( D324 . (( D324 . (C554 , ( ( ( C549 := ( ( . C547 ) - ( . C548 ) ) ) \; D329 ) \; ( C547 := C548 ) )) ) , ( C548 := C549 )) ) by AOFA_000:def 29
.= ( D324 . (( D324 . (( D324 . (C554 , ( ( C549 := ( ( . C547 ) - ( . C548 ) ) ) \; D329 )) ) , ( C547 := C548 )) ) , ( C548 := C549 )) ) by AOFA_000:def 29
.= D336 by AOFA_000:def 29;
L1647: (( D332 . R16 ) = 1 implies D332 in D326);
L1648: (( D332 . R16 ) = 1 implies D333 = D334) by L1647 , L1627 , AOFA_000:def 30;
L1649: ( ( . C547 ) . C554 ) = ( C554 . C547 ) by L776;
L1650: ( D334 . C548 ) = ( D332 . C548 ) by L1632 , L852;
L1651: ( ( . C548 ) . C554 ) = ( C554 . C548 ) by L776;
L1652: ( ( ( . C547 ) - ( . C548 ) ) . C554 ) = ( ( ( . C547 ) . C554 ) - ( ( . C548 ) . C554 ) ) by L170;
L1653: ( D331 . C549 ) = ( ( C554 . C547 ) - ( C554 . C548 ) ) by L1652 , L1649 , L1651 , L832;
L1654: (( D331 . C549 ) < ( 0 ) implies ( D332 . R16 ) = 1) by L898;
L1655: ( D332 . C549 ) = ( D331 . C549 ) by L1628 , L1631 , L898;
L1656: ( D334 . C549 ) = ( ( D332 . C549 ) * ( - 1 ) ) by L852;
L1657: ( D335 . C549 ) = ( D333 . C549 ) by L1642 , L835;
L1658: ( D336 . C548 ) = ( D335 . C549 ) by L835;
L1659: (( D332 . R16 ) = ( 0 ) implies D332 nin D326) by L21;
L1660: (( D332 . R16 ) = ( 0 ) implies D333 = D332) by L1659 , L1627 , AOFA_000:80;
L1661: (( D331 . C549 ) >= ( 0 ) implies ( D332 . R16 ) = ( 0 )) by L898;
L1662: ( D331 . C548 ) = ( C554 . C548 ) by L1632 , L832;
L1663: ( D335 . C547 ) = ( D333 . C548 ) by L835;
L1664: ( D332 . C548 ) = ( D331 . C548 ) by L1628 , L1630 , L898;
thus L1665: (( ( D324 . (C554 , D330) ) . C547 ) = ( C554 . C548 ) & ( ( D324 . (C554 , D330) ) . C548 ) = ( abs ( ( C554 . C547 ) - ( C554 . C548 ) ) )) by L1664 , L1643 , L1660 , L1648 , L1655 , L1654 , L1661 , L1650 , L1656 , L1645 , L1646 , L1662 , L1653 , L1663 , L1657 , L1658 , L835 , ABSVALUE:def 1;
end;
L1666: (for B493 being (Element of D325) holds ((S25[ B493 ] & B493 in D326 & S24[ B493 ]) implies S25[ ( D324 . (B493 , D330) ) ]))
proof
let C555 being (Element of D325);
reconsider D337 = ( D324 . (C555 , D330) ) as (Element of D325);
L1667: ( abs ( C552 gcd C553 ) ) = ( C552 gcd C553 ) by ABSVALUE:def 1;
L1668: ( D337 . C548 ) = ( abs ( ( C555 . C547 ) - ( C555 . C548 ) ) ) by L1644;
assume L1669: S25[ C555 ];
reconsider D338 = ( C555 . C547 ) , D339 = ( C555 . C548 ) as (Element of ( NAT )) by L1669 , INT_1:3;
assume that
L1670: C555 in D326
and
L1671: S24[ C555 ];
L1672: ( C552 gcd C553 ) divides ( D338 - D339 ) by L1669 , PREPOWER:94;
thus L1673: (( C552 gcd C553 ) divides ( ( D324 . (C555 , D330) ) . C547 ) & ( C552 gcd C553 ) divides ( ( D324 . (C555 , D330) ) . C548 ) & ( ( D324 . (C555 , D330) ) . C547 ) > ( 0 ) & ( ( D324 . (C555 , D330) ) . C548 ) >= ( 0 )) by L1672 , L1644 , L1669 , L1671 , L1668 , L1667 , INT_2:16;
let C556 being Nat;
reconsider D340 = C556 as (Element of ( NAT )) by ORDINAL1:def 12;
assume that
L1674: C556 divides ( ( D324 . (C555 , D330) ) . C547 )
and
L1675: C556 divides ( ( D324 . (C555 , D330) ) . C548 );
L1676: ( abs C556 ) = C556 by ABSVALUE:def 1;
L1677: ( D337 . C547 ) = ( C555 . C548 ) by L1644;
L1678: D340 divides ( abs ( D338 - D339 ) ) by L1644 , L1675;
L1679: C556 divides ( D338 - D339 ) by L1678 , L1676 , INT_2:16;
L1680: (C556 qua Integer) divides D339 by L1644 , L1674;
L1681: C556 divides ( ( D338 - D339 ) + D339 ) by L1680 , L1679 , WSIERP_1:4;
thus L1682: thesis by L1681 , L1669 , L1677 , L1674;
end;
L1683: (for B494 being (Element of D325) holds (S25[ B494 ] implies (S25[ (( D324 . (B494 , D327) ) qua (Element of D325)) ] & (( D324 . (B494 , D327) ) in D326 iff S24[ (( D324 . (B494 , D327) ) qua (Element of D325)) ]))))
proof
let C557 being (Element of D325);
assume L1684: S25[ C557 ];
reconsider D341 = ( D324 . (C557 , D327) ) as (Element of D325);
L1685: ( D341 . C548 ) = ( C557 . C548 ) by L1628 , L1630 , L898;
L1686: ( D341 . C547 ) = ( C557 . C547 ) by L1628 , L1629 , L898;
thus L1687: S25[ (( D324 . (C557 , D327) ) qua (Element of D325)) ] by L1686 , L1684 , L1685;
L1688: (( C557 . C548 ) <= ( 0 ) implies ( D341 . R16 ) = ( 0 )) by L898;
L1689: (( C557 . C548 ) > ( 0 ) implies ( D341 . R16 ) = 1) by L898;
thus L1690: thesis by L1689 , L1684 , L1688 , L21 , L898;
end;
reconsider D342 = ( D324 . (C551 , ( while (D327 , D330) )) ) as (Element of D325);
L1691: S25[ C551 ] by L1636 , L1637 , L1638 , NAT_D:def 5;
L1692: (S25[ (( D324 . (C551 , ( while (D327 , D330) )) ) qua (Element of D325)) ] & (not S24[ (( D324 . (C551 , ( while (D327 , D330) )) ) qua (Element of D325)) ])) from AOFA_000:sch 5(L1691 , L1641 , L1666 , L1683);
reconsider D343 = ( D342 . C547 ) as (Element of ( NAT )) by L1692 , INT_1:3;
L1693: D343 divides ( 0 ) by NAT_D:6;
L1694: ( D342 . C548 ) = ( 0 ) by L1692;
L1695: D343 divides ( C552 gcd C553 ) by L1694 , L1692 , L1693;
thus L1696: thesis by L1695 , L1692 , NAT_D:5;
end;
theorem
L1697: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B495 , B496 , B497 being (Variable of R17) holds ((ex B498 being Function st (( B498 . R16 ) = ( 0 ) & ( B498 . B495 ) = 1 & ( B498 . B496 ) = 2 & ( B498 . B497 ) = 3)) implies ( ( B496 := 1 ) \; ( while (( B497 gt ( 0 ) ) , ( ( ( if-then (( B497 is_odd ) , ( B496 *= B495 )) ) \; ( B497 /= 2 ) ) \; ( B495 *= B495 ) )) ) ) is_terminating_wrt R17 , { R9 where R9 is (Element of ( Funcs (R7 , ( INT )) )) : ( R9 . B497 ) >= ( 0 ) }))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D344 = ( Funcs (R7 , ( INT )) );
set D345 = ( D344 \ (R16 , ( 0 )) );
let C558 , C559 , C560 being (Variable of R17);
set D346 = { R9 where R9 is (Element of ( Funcs (R7 , ( INT )) )) : ( R9 . C560 ) >= ( 0 ) };
given C561 being Function such that
L1698: ( C561 . R16 ) = ( 0 )
and
L1699: ( C561 . C558 ) = 1
and
L1700: ( C561 . C559 ) = 2
and
L1701: ( C561 . C560 ) = 3;

set D347 = ( C560 gt ( 0 ) );
L1702: ( C559 := 1 ) is_terminating_wrt R17 , D346 by AOFA_000:107;
deffunc H14((Element of D344)) = ( In (( $1 . C560 ) , ( NAT )) );
defpred S26[ (Element of D344) ] means ( $1 . C560 ) > ( 0 );
set D348 = ( if-then (( C560 is_odd ) , ( C559 *= C558 )) );
set D349 = ( ( D348 \; ( C560 /= 2 ) ) \; ( C558 *= C558 ) );
L1703: R17 complies_with_if_wrt D345 by AOFA_000:def 32;
L1704: D346 is_invariant_wrt D347 , R17
proof
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
assume L1705: R9 in D346;
L1706: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R9 = R10 & ( R10 . C560 ) >= ( 0 ))) by L1705;
L1707: ( ( R17 . (R9 , D347) ) . C560 ) = ( R9 . C560 ) by L1698 , L1701 , L898;
thus L1708: ( R17 . (R9 , D347) ) in D346 by L1707 , L1706;
end;
L1709: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds ((R9 in D346 & ( R17 . (( R17 . (R9 , D349) ) , D347) ) in D345) implies ( R17 . (R9 , D349) ) in D346))
proof
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
assume that
L1710: R9 in D346;
assume L1711: ( R17 . (( R17 . (R9 , D349) ) , D347) ) in D345;
L1712: ( ( R17 . (R9 , D349) ) . C560 ) > ( 0 ) by L1711 , L921;
thus L1713: thesis by L1712;
end;
L1714: C560 <> C559 by L1700 , L1701;
L1715: D346 is_invariant_wrt ( C559 := 1 ) , R17
proof
let R9 being (Element of ( Funcs (R7 , ( INT )) ));
assume L1716: R9 in D346;
L1717: (ex R10 being (Element of ( Funcs (R7 , ( INT )) )) st (R9 = R10 & ( R10 . C560 ) >= ( 0 ))) by L1716;
L1718: ( ( R17 . (R9 , ( C559 := 1 )) ) . C560 ) = ( R9 . C560 ) by L1714 , L828;
thus L1719: ( R17 . (R9 , ( C559 := 1 )) ) in D346 by L1718 , L1717;
end;
L1720: C560 <> C558 by L1699 , L1701;
L1721: (for R9 being (Element of ( Funcs (R7 , ( INT )) )) holds (( R17 . (R9 , D347) ) in D346 implies R17 iteration_terminates_for ( D349 \; D347 ) , ( R17 . (R9 , D347) )))
proof
L1722: (for B499 being (Element of D344) holds (S26[ B499 ] implies ((S26[ ( R17 . (B499 , ( D349 \; D347 )) ) ] iff ( R17 . (B499 , ( D349 \; D347 )) ) in D345) & H14(( R17 . (B499 , ( D349 \; D347 )) )) < H14(B499))))
proof
let C562 being (Element of D344);
assume that
L1723: ( C562 . C560 ) > ( 0 );
L1724: H14(C562) = ( C562 . C560 ) by L1723 , FUNCT_7:def 1 , INT_1:3;
set D350 = ( R17 . (C562 , D348) );
set D351 = ( R17 . (C562 , ( C560 is_odd )) );
set D352 = ( R17 . (C562 , D349) );
set D353 = ( R17 . (D352 , D347) );
L1725: ( R17 . (C562 , ( D349 \; D347 )) ) = D353 by AOFA_000:def 29;
L1726: (( D352 . C560 ) <= ( 0 ) implies ( D353 . R16 ) = ( 0 )) by L898;
L1727: (( D352 . C560 ) > ( 0 ) implies ( D353 . R16 ) = 1) by L898;
thus L1728: (S26[ ( R17 . (C562 , ( D349 \; D347 )) ) ] iff ( R17 . (C562 , ( D349 \; D347 )) ) in D345) by L1727 , L1726 , L1725 , L21 , L898;
set D354 = ( R17 . (D350 , ( C560 /= 2 )) );
set D355 = ( R17 . (D354 , ( C558 *= C558 )) );
L1729: (D350 = ( R17 . (D351 , ( C559 *= C558 )) ) or D350 = ( R17 . (D351 , ( EmptyIns R6 )) )) by L1703 , AOFA_000:def 30;
L1730: D354 = ( R17 . (C562 , ( D348 \; ( C560 /= 2 ) )) ) by AOFA_000:def 29;
L1731: D355 = ( R17 . (C562 , D349) ) by L1730 , AOFA_000:def 29;
L1732: ( D352 . C560 ) = ( D354 . C560 ) by L1731 , L1720 , L863
.= ( ( D350 . C560 ) div 2 ) by L946
.= ( ( D351 . C560 ) div 2 ) by L1714 , L1729 , L863 , AOFA_000:def 28
.= ( ( C562 . C560 ) div 2 ) by L1698 , L1701 , L969;
L1733: ( D353 . C560 ) = ( D352 . C560 ) by L1698 , L1701 , L898;
L1734: ( D353 . C560 ) in ( NAT ) by L1733 , L1723 , L1732 , INT_1:3 , INT_1:61;
L1735: H14(D353) = ( D353 . C560 ) by L1734 , FUNCT_7:def 1;
thus L1736: thesis by L1735 , L1723 , L1733 , L1725 , L1732 , L1724 , INT_1:56;
end;
let C563 being (Element of D344);
assume that
L1737: ( R17 . (C563 , D347) ) in D346;
set D356 = ( R17 . (C563 , D347) );
L1738: (( C563 . C560 ) <= ( 0 ) implies ( D356 . R16 ) = ( 0 )) by L898;
L1739: (( C563 . C560 ) > ( 0 ) implies ( D356 . R16 ) = 1) by L898;
L1740: (( R17 . (C563 , D347) ) in D345 iff S26[ ( R17 . (C563 , D347) ) ]) by L1739 , L1738 , L21 , L898;
thus L1741: R17 iteration_terminates_for ( D349 \; D347 ) , ( R17 . (C563 , D347) ) from AOFA_000:sch 3(L1740 , L1722);
end;
L1742: D349 is_terminating_wrt R17 , D346 by AOFA_000:107;
L1743: ( while (( C560 gt ( 0 ) ) , ( ( ( if-then (( C560 is_odd ) , ( C559 *= C558 )) ) \; ( C560 /= 2 ) ) \; ( C558 *= C558 ) )) ) is_terminating_wrt R17 , D346 by L1742 , L1704 , L1709 , L1721 , AOFA_000:104 , AOFA_000:118;
thus L1744: thesis by L1743 , L1702 , L1715 , AOFA_000:111;
end;
::$N Correctness of the algorithm of exponentiation by squaring
theorem
L1745: (for R6 being  Euclidean preIfWhileAlgebra holds (for R7 being non  empty  countable set holds (for R16 being (Element of R7) holds (for R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) )) holds (for B500 , B501 , B502 being (Variable of R17) holds ((ex B503 being Function st (( B503 . R16 ) = ( 0 ) & ( B503 . B500 ) = 1 & ( B503 . B501 ) = 2 & ( B503 . B502 ) = 3)) implies (for B504 being (Element of ( Funcs (R7 , ( INT )) )) holds (for B505 being Nat holds (B505 = ( B504 . B502 ) implies ( ( R17 . (B504 , ( ( B501 := 1 ) \; ( while (( B502 gt ( 0 ) ) , ( ( ( if-then (( B502 is_odd ) , ( B501 *= B500 )) ) \; ( B502 /= 2 ) ) \; ( B500 *= B500 ) )) ) )) ) . B501 ) = ( ( B504 . B500 ) |^ B505 ))))))))))
proof
let R6 being  Euclidean preIfWhileAlgebra;
let R7 being non  empty  countable set;
let R16 being (Element of R7);
let R17 being  Euclidean (ExecutionFunction of R6 , ( Funcs (R7 , ( INT )) ) , ( ( Funcs (R7 , ( INT )) ) \ (R16 , ( 0 )) ));
set D357 = ( Funcs (R7 , ( INT )) );
set D358 = ( D357 \ (R16 , ( 0 )) );
L1746: R17 complies_with_if_wrt D358 by AOFA_000:def 32;
let C564 , C565 , C566 being (Variable of R17);
given C567 being Function such that
L1747: ( C567 . R16 ) = ( 0 )
and
L1748: ( C567 . C564 ) = 1
and
L1749: ( C567 . C565 ) = 2
and
L1750: ( C567 . C566 ) = 3;

defpred S27[ (Element of D357) ] means ( $1 . C566 ) > ( 0 );
set D359 = ( C566 gt ( 0 ) );
let C568 being (Element of ( Funcs (R7 , ( INT )) ));
let C569 being Nat;
defpred S28[ (Element of D357) ] means (( ( C568 . C564 ) |^ C569 ) = ( ( $1 . C565 ) * ( ( $1 . C564 ) to_power ( $1 . C566 ) ) ) & ( $1 . C566 ) >= ( 0 ));
deffunc H15((Element of D357)) = ( In (( $1 . C566 ) , ( NAT )) );
set D360 = ( if-then (( C566 is_odd ) , ( C565 *= C564 )) );
set D361 = ( ( D360 \; ( C566 /= 2 ) ) \; ( C564 *= C564 ) );
set D362 = ( R17 . (C568 , ( C565 := 1 )) );
L1751: C566 <> C565 by L1749 , L1750;
L1752: ( D362 . C566 ) = ( C568 . C566 ) by L1751 , L828;
L1753: (for B506 being (Element of D357) holds (S28[ B506 ] implies (S28[ ( R17 . (B506 , D359) ) ] & (( R17 . (B506 , D359) ) in D358 iff S27[ ( R17 . (B506 , D359) ) ]))))
proof
let C570 being (Element of D357);
assume that
L1754: S28[ C570 ];
set D363 = ( R17 . (C570 , D359) );
L1755: ( D363 . C564 ) = ( C570 . C564 ) by L1747 , L1748 , L898;
L1756: ( D363 . C566 ) = ( C570 . C566 ) by L1747 , L1750 , L898;
thus L1757: S28[ ( R17 . (C570 , D359) ) ] by L1756 , L1747 , L1749 , L1754 , L1755 , L898;
L1758: (( C570 . C566 ) <= ( 0 ) implies ( D363 . R16 ) = ( 0 )) by L898;
L1759: (( C570 . C566 ) > ( 0 ) implies ( D363 . R16 ) = 1) by L898;
thus L1760: thesis by L1759 , L1758 , L21 , L898;
end;
L1761: ( D362 . C565 ) = 1 by L828;
set D364 = ( R17 . (D362 , ( while (D359 , D361) )) );
set D365 = ( R17 . (D362 , D359) );
assume L1762: C569 = ( C568 . C566 );
L1763: ( ( D364 . C564 ) to_power ( 0 ) ) = 1 by POWER:24;
L1764: C566 <> C564 by L1748 , L1750;
L1765: (for B507 being (Element of D357) holds (S27[ B507 ] implies ((S27[ ( R17 . (B507 , ( D361 \; D359 )) ) ] iff ( R17 . (B507 , ( D361 \; D359 )) ) in D358) & H15(( R17 . (B507 , ( D361 \; D359 )) )) < H15(B507))))
proof
let C571 being (Element of D357);
assume that
L1766: ( C571 . C566 ) > ( 0 );
L1767: H15(C571) = ( C571 . C566 ) by L1766 , FUNCT_7:def 1 , INT_1:3;
set D366 = ( R17 . (C571 , D360) );
set D367 = ( R17 . (C571 , ( C566 is_odd )) );
set D368 = ( R17 . (C571 , D361) );
set D369 = ( R17 . (D368 , D359) );
L1768: ( R17 . (C571 , ( D361 \; D359 )) ) = D369 by AOFA_000:def 29;
L1769: (( D368 . C566 ) <= ( 0 ) implies ( D369 . R16 ) = ( 0 )) by L898;
L1770: (( D368 . C566 ) > ( 0 ) implies ( D369 . R16 ) = 1) by L898;
thus L1771: (S27[ ( R17 . (C571 , ( D361 \; D359 )) ) ] iff ( R17 . (C571 , ( D361 \; D359 )) ) in D358) by L1770 , L1769 , L1768 , L21 , L898;
set D370 = ( R17 . (D366 , ( C566 /= 2 )) );
set D371 = ( R17 . (D370 , ( C564 *= C564 )) );
L1772: (D366 = ( R17 . (D367 , ( C565 *= C564 )) ) or D366 = ( R17 . (D367 , ( EmptyIns R6 )) )) by L1746 , AOFA_000:def 30;
L1773: D370 = ( R17 . (C571 , ( D360 \; ( C566 /= 2 ) )) ) by AOFA_000:def 29;
L1774: D371 = ( R17 . (C571 , D361) ) by L1773 , AOFA_000:def 29;
L1775: ( D368 . C566 ) = ( D370 . C566 ) by L1774 , L1764 , L863
.= ( ( D366 . C566 ) div 2 ) by L946
.= ( ( D367 . C566 ) div 2 ) by L1751 , L1772 , L863 , AOFA_000:def 28
.= ( ( C571 . C566 ) div 2 ) by L1747 , L1750 , L969;
L1776: ( D369 . C566 ) = ( D368 . C566 ) by L1747 , L1750 , L898;
L1777: ( D369 . C566 ) in ( NAT ) by L1776 , L1766 , L1775 , INT_1:3 , INT_1:61;
L1778: H15(D369) = ( D369 . C566 ) by L1777 , FUNCT_7:def 1;
thus L1779: thesis by L1778 , L1766 , L1776 , L1768 , L1775 , L1767 , INT_1:56;
end;
set D372 = C568;
L1780: C564 <> C565 by L1748 , L1749;
L1781: (for B508 being (Element of D357) holds ((S28[ B508 ] & B508 in D358 & S27[ B508 ]) implies S28[ ( R17 . (B508 , D361) ) ]))
proof
let C572 being (Element of D357);
assume that
L1782: S28[ C572 ]
and
L1783: C572 in D358
and
L1784: S27[ C572 ];
reconsider D373 = ( C572 . C566 ) as (Element of ( NAT )) by L1782 , INT_1:3;
L1785: ( C572 . C566 ) = ( ( ( ( C572 . C566 ) div 2 ) * 2 ) + ( ( C572 . C566 ) mod 2 ) ) by NEWTON:66;
L1786: ( ( D372 . C564 ) |^ C569 ) = ( ( C572 . C565 ) * ( ( ( C572 . C564 ) to_power ( ( D373 div 2 ) * 2 ) ) * ( ( C572 . C564 ) to_power ( D373 mod 2 ) ) ) ) by L1785 , L1782 , FIB_NUM2:5
.= ( ( ( C572 . C565 ) * ( ( C572 . C564 ) to_power ( D373 mod 2 ) ) ) * ( ( C572 . C564 ) to_power ( ( D373 div 2 ) * 2 ) ) )
.= ( ( ( C572 . C565 ) * ( ( C572 . C564 ) to_power ( D373 mod 2 ) ) ) * ( ( ( C572 . C564 ) to_power 2 ) to_power ( D373 div 2 ) ) ) by NEWTON:9
.= ( ( ( C572 . C565 ) * ( ( C572 . C564 ) to_power ( D373 mod 2 ) ) ) * ( ( ( C572 . C564 ) * ( C572 . C564 ) ) to_power ( D373 div 2 ) ) ) by NEWTON:81;
set D374 = ( R17 . (C572 , D360) );
set D375 = ( R17 . (C572 , ( C566 is_odd )) );
set D376 = ( R17 . (C572 , D361) );
set D377 = ( R17 . (D374 , ( C566 /= 2 )) );
set D378 = ( R17 . (D377 , ( C564 *= C564 )) );
L1787: (D374 = ( R17 . (D375 , ( C565 *= C564 )) ) or D374 = ( R17 . (D375 , ( EmptyIns R6 )) )) by L1746 , AOFA_000:def 30;
L1788: ( D377 . C564 ) = ( D374 . C564 ) by L1764 , L946
.= ( D375 . C564 ) by L1780 , L1787 , L863 , AOFA_000:def 28;
L1789: ( D377 . C565 ) = ( D374 . C565 ) by L1751 , L946;
L1790: ( D375 . C565 ) = ( C572 . C565 ) by L1747 , L1749 , L969;
L1791: ( D375 . C564 ) = ( C572 . C564 ) by L1747 , L1748 , L969;
L1792: D377 = ( R17 . (C572 , ( D360 \; ( C566 /= 2 ) )) ) by AOFA_000:def 29;
L1793: D378 = ( R17 . (C572 , D361) ) by L1792 , AOFA_000:def 29;
L1794: ( D376 . C565 ) = ( D377 . C565 ) by L1793 , L1780 , L863;
L1795: ( D373 div 2 ) = ( ( C572 . C566 ) div 2 );
L1796:
now
L1797: ( D375 . R16 ) = ( ( C572 . C566 ) mod 2 ) by L969;
per cases  by L1795 , L1797 , NAT_D:12;
suppose L1798: ( D375 . R16 ) = ( 0 );

L1799: D375 nin D358 by L1798 , L21;
L1800: D374 = ( R17 . (D375 , ( EmptyIns R6 )) ) by L1799 , L1746 , AOFA_000:def 30;
L1801: ( D374 . C565 ) = ( D375 . C565 ) by L1800 , AOFA_000:def 28;
L1802: ( ( C572 . C565 ) * 1 ) = ( C572 . C565 );
L1803: ( ( C572 . C564 ) to_power ( 0 ) ) = 1 by POWER:24;
thus L1804: ( ( C572 . C565 ) * ( ( C572 . C564 ) to_power ( D373 mod 2 ) ) ) = ( D376 . C565 ) by L1803 , L1794 , L1789 , L1790 , L1798 , L1801 , L1802 , L969;
end;
suppose L1805: ( D375 . R16 ) = 1;

L1806: D375 in D358 by L1805;
L1807: D374 = ( R17 . (D375 , ( C565 *= C564 )) ) by L1806 , L1746 , AOFA_000:def 30;
L1808: ( D374 . C565 ) = ( ( D375 . C565 ) * ( D375 . C564 ) ) by L1807 , L863;
L1809: ( ( C572 . C564 ) to_power 1 ) = ( C572 . C564 ) by POWER:25;
thus L1810: ( ( C572 . C565 ) * ( ( C572 . C564 ) to_power ( D373 mod 2 ) ) ) = ( D376 . C565 ) by L1809 , L1791 , L1794 , L1789 , L1790 , L1805 , L1808 , L969;
end;
end;
L1812: ( D376 . C566 ) = ( D377 . C566 ) by L1764 , L1793 , L863
.= ( ( D374 . C566 ) div 2 ) by L946
.= ( ( D375 . C566 ) div 2 ) by L1751 , L1787 , L863 , AOFA_000:def 28
.= ( ( C572 . C566 ) div 2 ) by L1747 , L1750 , L969;
thus L1813: thesis by L1812 , L1793 , L1788 , L1791 , L1796 , L1786 , L863;
end;
L1814: (( D362 . C566 ) <= ( 0 ) implies ( D365 . R16 ) = ( 0 )) by L898;
L1815: (( D362 . C566 ) > ( 0 ) implies ( D365 . R16 ) = 1) by L898;
L1816: (( R17 . (D362 , D359) ) in D358 iff S27[ ( R17 . (D362 , D359) ) ]) by L1815 , L1814 , L21 , L898;
L1817: R17 iteration_terminates_for ( D361 \; D359 ) , ( R17 . (D362 , D359) ) from AOFA_000:sch 3(L1816 , L1765);
L1818: ( D362 . C564 ) = ( C568 . C564 ) by L1780 , L828;
L1819: S28[ D362 ] by L1818 , L1762 , L1752 , L1761 , POWER:41;
L1820: (S28[ ( R17 . (D362 , ( while (D359 , D361) )) ) ] & (not S27[ ( R17 . (D362 , ( while (D359 , D361) )) ) ])) from AOFA_000:sch 5(L1819 , L1817 , L1781 , L1753);
L1821: ( D364 . C566 ) = ( 0 ) by L1820;
thus L1822: thesis by L1821 , L1820 , L1763 , AOFA_000:def 29;
end;
