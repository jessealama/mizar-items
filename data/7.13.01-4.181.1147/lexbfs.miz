:: Recognizing Chordal Graphs: Lex BFS and MCS
::  by Broderick Arneson and Piotr Rudnicki
::
:: Received November 17, 2006
:: Copyright (c) 2006-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FUNCT_1, CARD_1, RELAT_1, TARSKI, FUNCT_4, FUNCOP_1,
      XBOOLE_0, SUBSET_1, XXREAL_0, ARYTM_3, FINSET_1, XREAL_0, ORDINAL1,
      ARYTM_1, NAT_1, ZFMISC_1, FINSEQ_1, UPROOTS, VALUED_0, RELAT_2, BAGORDER,
      PRE_POLY, WELLORD1, GLIB_000, GLIB_001, ORDINAL4, PBOOLE, PARTFUN1,
      MCART_1, FUNCT_2, FINSUB_1, CHORD, TOPGEN_1, RCOMP_1, FINSEQ_4, GRAPH_1,
      MEMBERED, ABIAN, LEXBFS, MATROID0;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, MCART_1, CARD_1, NUMBERS, SUBSET_1,
      XXREAL_0, VALUED_0, XREAL_0, RELAT_1, RELAT_2, WELLORD1, MEMBERED,
      XXREAL_2, PARTFUN1, FUNCT_1, FUNCT_2, PBOOLE, ORDINAL1, FINSET_1,
      XCMPLX_0, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, GLIB_000, GLIB_001, BAGORDER,
      TERMORD, UPROOTS, CHORD, FINSEQ_1, DOMAIN_1, ABIAN, RELSET_1, RECDEF_1,
      FINSUB_1, RFUNCT_3, PRE_POLY;
 constructors DOMAIN_1, FUNCT_4, XXREAL_2, BAGORDER, TERMORD, UPROOTS, CHORD,
      RECDEF_1, RFUNCT_3, RELSET_1, PBOOLE, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XXREAL_0, XREAL_0, XXREAL_2, NAT_1, INT_1, MEMBERED, FINSEQ_1,
      CARD_1, UPROOTS, GLIB_000, ABIAN, BAGORDER, TERMORD, GLIB_001, CHORD,
      VALUED_0, FINSUB_1, PARTFUN1, RELSET_1, PRE_POLY, XTUPLE_0;
 requirements NUMERALS, SUBSET, BOOLE, REAL, ARITHM;
 definitions GLIB_000, GLIB_001, FUNCOP_1, TARSKI, XTUPLE_0;
 theorems AXIOMS, CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSET_1, FUNCT_1, FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, INT_1, NAT_1,
      BAGORDER, TERMORD, ORDINAL1, PARTFUN1, PBOOLE, NAT_D, XREAL_0, RELAT_1,
      RELSET_1, TARSKI, XBOOLE_0, XBOOLE_1, XREAL_1, ZFMISC_1, ENUMSET1, CHORD,
      NECKLACE, FINSEQ_4, WELLORD1, UPROOTS, CARD_FIN, TREES_1, NAT_2,
      XXREAL_0, XXREAL_2, VALUED_0, MCART_1, FINSUB_1, SYSREL, GRFUNC_1;
 schemes NAT_1, FUNCT_1, RECDEF_1, FRAENKEL, PBOOLE, FUNCT_2, CLASSES1;

begin
L1: (for B1 being Function holds (for B2 , B3 being set holds ( dom ( B1 +* ( B2 .--> B3 ) ) ) = ( ( dom B1 ) \/ { B2 } )))
proof
let C1 being Function;
let C2 , C3 being set;
thus L2: ( dom ( C1 +* ( C2 .--> C3 ) ) ) = ( ( dom C1 ) \/ ( dom ( C2 .--> C3 ) ) ) by FUNCT_4:def 1
.= ( ( dom C1 ) \/ { C2 } ) by FUNCOP_1:13;
end;
L3: (for B4 being  one-to-one Function holds (for B5 , B6 being set holds (B5 c= B6 implies (for B7 being set holds (B7 in ( dom ( ( B4 | B5 ) " ) ) implies ( ( ( B4 | B5 ) " ) . B7 ) = ( ( ( B4 | B6 ) " ) . B7 ))))))
proof
let C4 being  one-to-one Function;
let C5 , C6 being set;
assume L4: C5 c= C6;
L5: ( C4 | C5 ) c= ( C4 | C6 ) by L4 , RELAT_1:75;
L6: ( (( C4 | C5 ) qua Relation) ~ ) c= ( (( C4 | C6 ) qua Relation) ~ ) by L5 , SYSREL:11;
L7: ( C4 | C5 ) is  one-to-one by FUNCT_1:52;
L8: ( (( C4 | C5 ) qua Relation) ~ ) = ( ( C4 | C5 ) " ) by L7 , FUNCT_1:def 5;
L9: ( C4 | C6 ) is  one-to-one by FUNCT_1:52;
L10: ( (( C4 | C6 ) qua Relation) ~ ) = ( ( C4 | C6 ) " ) by L9 , FUNCT_1:def 5;
let C7 being set;
assume L11: C7 in ( dom ( ( C4 | C5 ) " ) );
thus L12: thesis by L11 , L6 , L8 , L10 , GRFUNC_1:2;
end;
theorem
L13: (for B8 , B9 being (Element of ( NAT )) holds (for B10 being non  empty set holds (for B11 being (Function of ( NAT ) , B10) holds (B11 is  one-to-one implies ( card { ( B11 . B12 ) where B12 is (Element of ( NAT )) : (B8 <= B12 & B12 <= ( B8 + B9 )) } ) = ( B9 + 1 )))))
proof
let C8 , C9 being (Element of ( NAT ));
let C10 being non  empty set;
let C11 being (Function of ( NAT ) , C10);
assume that
L14: C11 is  one-to-one;
defpred S1[ (Element of ( NAT )) ] means ( card { ( C11 . B13 ) where B13 is (Element of ( NAT )) : (C8 <= B13 & B13 <= ( C8 + $1 )) } ) = ( $1 + 1 );
L15: ( dom C11 ) = ( NAT ) by FUNCT_2:def 1;
L16: (for B14 being (Element of ( NAT )) holds (S1[ B14 ] implies S1[ ( B14 + 1 ) ]))
proof
let C12 being (Element of ( NAT ));
assume that
L17: S1[ C12 ];
set D1 = { ( C11 . B15 ) where B15 is (Element of ( NAT )) : (C8 <= B15 & B15 <= ( C8 + C12 )) };
reconsider D2 = D1 as  finite set by L17;
set D3 = { ( C11 . B16 ) where B16 is (Element of ( NAT )) : (C8 <= B16 & B16 <= ( ( C8 + C12 ) + 1 )) };
L18:
now
let C13 being set;
thus L19:now
assume L20: C13 in D3;
consider C14 being (Element of ( NAT )) such that L21: C13 = ( C11 . C14 ) and L22: C8 <= C14 and L23: C14 <= ( ( C8 + C12 ) + 1 ) by L20;
L24: (C14 = ( ( C8 + C12 ) + 1 ) or C14 < ( ( C8 + C12 ) + 1 )) by L23 , XXREAL_0:1;
per cases  by L24 , NAT_1:13;
suppose L25: C14 = ( ( C8 + C12 ) + 1 );

L26: C13 in { ( C11 . ( ( C8 + C12 ) + 1 ) ) } by L25 , L21 , TARSKI:def 1;
thus L27: C13 in ( D2 \/ { ( C11 . ( ( C8 + C12 ) + 1 ) ) } ) by L26 , XBOOLE_0:def 3;
end;
suppose L28: C14 <= ( C8 + C12 );

L29: C13 in D2 by L28 , L21 , L22;
thus L30: C13 in ( D2 \/ { ( C11 . ( ( C8 + C12 ) + 1 ) ) } ) by L29 , XBOOLE_0:def 3;
end;
end;
assume L32: C13 in ( D2 \/ { ( C11 . ( ( C8 + C12 ) + 1 ) ) } );
per cases  by L32 , XBOOLE_0:def 3;
suppose L33: C13 in D2;

consider C15 being (Element of ( NAT )) such that L34: C13 = ( C11 . C15 ) and L35: C8 <= C15 and L36: C15 <= ( C8 + C12 ) by L33;
L37: C15 <= ( ( C8 + C12 ) + 1 ) by L36 , NAT_1:13;
thus L38: C13 in D3 by L37 , L34 , L35;
end;
suppose L39: C13 in { ( C11 . ( ( C8 + C12 ) + 1 ) ) };

L40: C8 <= ( C8 + ( C12 + 1 ) ) by NAT_1:11;
L41: C13 = ( C11 . ( ( C8 + C12 ) + 1 ) ) by L39 , TARSKI:def 1;
thus L42: C13 in D3 by L41 , L40;
end;
end;
L44:
now
assume L45: ( C11 . ( ( C8 + C12 ) + 1 ) ) in D2;
consider C16 being (Element of ( NAT )) such that L46: ( C11 . ( ( C8 + C12 ) + 1 ) ) = ( C11 . C16 ) and L47: C8 <= C16 and L48: C16 <= ( C8 + C12 ) by L45;
L49: ( ( C8 + C12 ) + 1 ) = C16 by L14 , L15 , L46 , FUNCT_1:def 4;
thus L50: contradiction by L49 , L48 , NAT_1:13;
end;
L51: ( card ( D2 \/ { ( C11 . ( ( C8 + C12 ) + 1 ) ) } ) ) = ( ( C12 + 1 ) + 1 ) by L44 , L17 , CARD_2:41;
thus L52: thesis by L51 , L18 , TARSKI:1;
end;
L53:
now
let C17 being set;
thus L54:now
assume L55: C17 in { ( C11 . B17 ) where B17 is (Element of ( NAT )) : (C8 <= B17 & B17 <= ( C8 + ( 0 ) )) };
consider C18 being (Element of ( NAT )) such that L56: ( C11 . C18 ) = C17 and L57: C8 <= C18 and L58: C18 <= ( C8 + ( 0 ) ) by L55;
L59: C18 = C8 by L57 , L58 , XXREAL_0:1;
thus L60: C17 in { ( C11 . C8 ) } by L59 , L56 , TARSKI:def 1;
end;
assume L61: C17 in { ( C11 . C8 ) };
L62: C17 = ( C11 . C8 ) by L61 , TARSKI:def 1;
thus L63: C17 in { ( C11 . B18 ) where B18 is (Element of ( NAT )) : (C8 <= B18 & B18 <= ( C8 + ( 0 ) )) } by L62;
end;
L64: { ( C11 . B19 ) where B19 is (Element of ( NAT )) : (C8 <= B19 & B19 <= ( C8 + ( 0 ) )) } = { ( C11 . C8 ) } by L53 , TARSKI:1;
L65: S1[ ( 0 ) ] by L64 , CARD_1:30;
L66: (for B20 being (Element of ( NAT )) holds S1[ B20 ]) from NAT_1:sch 1(L65 , L16);
thus L67: thesis by L66;
end;
L68: (for B21 , B22 , B23 being  real number holds (B21 < B22 implies ( ( B23 - B22 ) + 1 ) < ( ( B23 - B21 ) + 1 )))
proof
let C19 , C20 , C21 being  real number;
assume L69: C19 < C20;
L70: ( C21 - C20 ) < ( C21 - C19 ) by L69 , XREAL_1:10;
thus L71: thesis by L70 , XREAL_1:6;
end;
theorem
L72: (for B24 , B25 , B26 being Nat holds ((B25 <= B26 & B24 < B25) implies ( B26 -' B25 ) < ( B26 -' B24 )))
proof
let C22 , C23 , C24 being Nat;
assume that
L73: C23 <= C24
and
L74: C22 < C23;
L75: ( C24 - C23 ) < ( C24 - C22 ) by L74 , XREAL_1:15;
L76: ( C24 -' C22 ) = ( C24 - C22 ) by L73 , L74 , XREAL_1:233 , XXREAL_0:2;
thus L77: thesis by L76 , L73 , L75 , XREAL_1:233;
end;
notation
let C25 being set;
synonym C25 is  with_finite-elements for C25 is  finite-membered;
end;
registration
cluster non  empty  finite  with_finite-elements for (Subset of ( bool ( NAT ) ));
existence
proof
set D4 = { { 1 } };
reconsider D5 = D4 as (Subset of ( bool ( NAT ) ));
take D5;
thus L79: D5 is non  empty;
thus L80: D5 is  finite;
thus L81: thesis;
end;
end;
definition
canceled 1;
let C26 , C27 being Function;
func C26 .\/ C27 -> Function means 
:L83: (( dom it ) = ( ( dom C26 ) \/ ( dom C27 ) ) & (for B27 being set holds (B27 in ( ( dom C26 ) \/ ( dom C27 ) ) implies ( it . B27 ) = ( ( C26 . B27 ) \/ ( C27 . B27 ) ))));
existence
proof
defpred S2[ set , set ] means ( ( C26 . $1 ) \/ ( C27 . $1 ) ) = $2;
set D6 = ( ( dom C26 ) \/ ( dom C27 ) );
L84: (for B28 being set holds (B28 in D6 implies (ex B29 being set st S2[ B28 , B29 ])));
L85: (ex B30 being Function st (( dom B30 ) = D6 & (for B31 being set holds (B31 in D6 implies S2[ B31 , ( B30 . B31 ) ])))) from CLASSES1:sch 1(L84);
consider C28 being Function such that L86: ( dom C28 ) = D6 and L87: (for B32 being set holds (B32 in D6 implies S2[ B32 , ( C28 . B32 ) ])) by L85;
take C28;
thus L88: ( dom C28 ) = ( ( dom C26 ) \/ ( dom C27 ) ) by L86;
thus L89: thesis by L87;
end;
uniqueness
proof
let C29 , C30 being Function;
assume that
L90: ( dom C29 ) = ( ( dom C26 ) \/ ( dom C27 ) )
and
L91: (for B33 being set holds (B33 in ( ( dom C26 ) \/ ( dom C27 ) ) implies ( C29 . B33 ) = ( ( C26 . B33 ) \/ ( C27 . B33 ) )))
and
L92: ( dom C30 ) = ( ( dom C26 ) \/ ( dom C27 ) )
and
L93: (for B34 being set holds (B34 in ( ( dom C26 ) \/ ( dom C27 ) ) implies ( C30 . B34 ) = ( ( C26 . B34 ) \/ ( C27 . B34 ) )));
L94:
now
let C31 being set;
assume that
L95: C31 in ( dom C29 );
L96: ( C29 . C31 ) = ( ( C26 . C31 ) \/ ( C27 . C31 ) ) by L90 , L91 , L95;
thus L97: ( C29 . C31 ) = ( C30 . C31 ) by L96 , L90 , L93 , L95;
end;
thus L98: thesis by L94 , L90 , L92 , FUNCT_1:2;
end;
end;
theorem
L100: (for B35 , B36 , B37 being Nat holds (B35 in ( ( Seg B37 ) \ ( Seg ( B37 -' B36 ) ) ) iff (( B37 -' B36 ) < B35 & B35 <= B37)))
proof
let C32 , C33 , C34 being Nat;
thus L101:now
assume L102: C32 in ( ( Seg C34 ) \ ( Seg ( C34 -' C33 ) ) );
L103: (not C32 in ( Seg ( C34 -' C33 ) )) by L102 , XBOOLE_0:def 5;
L104: C32 in ( Seg C34 ) by L102 , XBOOLE_0:def 5;
L105: 1 <= C32 by L104 , FINSEQ_1:1;
thus L106: (( C34 -' C33 ) < C32 & C32 <= C34) by L105 , L104 , L103 , FINSEQ_1:1;
end;
assume that
L107: ( C34 -' C33 ) < C32
and
L108: C32 <= C34;
L109: ( ( 0 ) + 1 ) <= C32 by L107 , NAT_1:13;
L110: C32 in ( Seg C34 ) by L109 , L108 , FINSEQ_1:1;
L111: (not C32 in ( Seg ( C34 -' C33 ) )) by L107 , FINSEQ_1:1;
thus L112: thesis by L111 , L110 , XBOOLE_0:def 5;
end;
theorem
L113: (for B38 , B39 , B40 being Nat holds (B38 <= B40 implies ( ( Seg B39 ) \ ( Seg ( B39 -' B38 ) ) ) c= ( ( Seg B39 ) \ ( Seg ( B39 -' B40 ) ) )))
proof
let C35 , C36 , C37 being Nat;
assume that
L114: C35 <= C37;
per cases ;
suppose L115: C36 < C37;

L116: (for B41 being set holds (B41 in ( ( Seg C36 ) \ ( Seg ( C36 -' C35 ) ) ) implies B41 in ( Seg C36 ))) by XBOOLE_0:def 5;
L117: ( C36 -' C37 ) = ( 0 ) by L115 , NAT_2:8;
L118: ( Seg ( C36 -' C37 ) ) = ( {} ) by L117;
thus L119: thesis by L118 , L116 , TARSKI:def 3;
end;
suppose L120: C37 <= C36;

L121:
now
let C38 being set;
assume that
L122: C38 in ( ( Seg C36 ) \ ( Seg ( C36 -' C35 ) ) );
reconsider D7 = C38 as (Element of ( NAT )) by L122;
L123: ( C36 -' C35 ) < D7 by L122 , L100;
per cases  by L114 , XXREAL_0:1;
suppose L124: C37 = C35;

thus L125: C38 in ( ( Seg C36 ) \ ( Seg ( C36 -' C37 ) ) ) by L124 , L122;
end;
suppose L126: C35 < C37;

L127: ( C36 -' C37 ) < ( C36 -' C35 ) by L126 , L120 , L72;
L128: ( C36 -' C37 ) < D7 by L127 , L123 , XXREAL_0:2;
L129: D7 <= C36 by L122 , L100;
thus L130: C38 in ( ( Seg C36 ) \ ( Seg ( C36 -' C37 ) ) ) by L129 , L128 , L100;
end;
end;
thus L132: thesis by L121 , TARSKI:def 3;
end;
end;
theorem
L134: (for B42 , B43 being Nat holds (B42 < B43 implies ( ( ( Seg B43 ) \ ( Seg ( B43 -' B42 ) ) ) \/ { ( B43 -' B42 ) } ) = ( ( Seg B43 ) \ ( Seg ( B43 -' ( B42 + 1 ) ) ) )))
proof
let C39 , C40 being Nat;
assume that
L135: C39 < C40;
set D8 = ( ( Seg C40 ) \ ( Seg ( C40 -' ( C39 + 1 ) ) ) );
set D9 = ( ( Seg C40 ) \ ( Seg ( C40 -' C39 ) ) );
L136:
now
let C41 being set;
assume that
L137: C41 in ( D9 \/ { ( C40 -' C39 ) } );
per cases  by L137 , XBOOLE_0:def 3;
suppose L138: C41 in D9;

L139: C39 <= ( C39 + 1 ) by NAT_1:13;
L140: D9 c= D8 by L139 , L113;
thus L141: C41 in D8 by L140 , L138;
end;
suppose L142: C41 in { ( C40 -' C39 ) };

reconsider D10 = C41 as Nat by L142;
L143: C39 < ( C39 + 1 ) by NAT_1:13;
L144: ( C39 + 1 ) <= C40 by L135 , NAT_1:13;
L145: ( C40 -' ( C39 + 1 ) ) < ( C40 -' C39 ) by L144 , L143 , L72;
L146: C41 = ( C40 -' C39 ) by L142 , TARSKI:def 1;
L147: D10 <= C40 by L146 , NAT_D:35;
thus L148: C41 in D8 by L147 , L146 , L145 , L100;
end;
end;
L150: ( D9 \/ { ( C40 -' C39 ) } ) c= D8 by L136 , TARSKI:def 3;
L151:
now
let C42 being set;
assume that
L152: C42 in D8;
reconsider D11 = C42 as (Element of ( NAT )) by L152;
L153: D11 <= C40 by L152 , L100;
L154: ( ( C40 -' ( C39 + 1 ) ) + 1 ) = ( C40 -' C39 ) by L135 , NAT_D:59;
L155: ( C40 -' ( C39 + 1 ) ) < D11 by L152 , L100;
L156: ( C40 -' C39 ) <= D11 by L155 , L154 , NAT_1:13;
per cases  by L156 , XXREAL_0:1;
suppose L157: ( C40 -' C39 ) = D11;

L158: D11 in { ( C40 -' C39 ) } by L157 , TARSKI:def 1;
thus L159: C42 in ( D9 \/ { ( C40 -' C39 ) } ) by L158 , XBOOLE_0:def 3;
end;
suppose L160: ( C40 -' C39 ) < D11;

L161: D11 in D9 by L160 , L153 , L100;
thus L162: C42 in ( D9 \/ { ( C40 -' C39 ) } ) by L161 , XBOOLE_0:def 3;
end;
end;
L164: D8 c= ( D9 \/ { ( C40 -' C39 ) } ) by L151 , TARSKI:def 3;
thus L165: thesis by L164 , L150 , XBOOLE_0:def 10;
end;
definition
let C43 being Relation;
attr C43 is  natsubset-yielding
means
:L166: ( rng C43 ) c= ( bool ( NAT ) );
end;
registration
cluster  finite-yielding  natsubset-yielding for Function;
existence
proof
set D12 = ( ( NAT ) --> ( {} ) );
take D12;
L168: (for B44 being set holds (B44 in ( rng D12 ) implies B44 is  finite));
thus L169: D12 is  finite-yielding by L168 , FINSET_1:def 2;
L170:
now
let C44 being set;
assume L171: C44 in ( rng D12 );
L172: C44 = ( {} ) by L171 , TARSKI:def 1;
L173: C44 c= ( NAT ) by L172 , XBOOLE_1:2;
thus L174: C44 in ( bool ( NAT ) ) by L173;
end;
L175: ( rng D12 ) c= ( bool ( NAT ) ) by L170 , TARSKI:def 3;
thus L176: thesis by L175 , L166;
end;
end;
definition
let C45 being  finite-yielding  natsubset-yielding Function;
let C46 being set;
redefine func C45 . C46 ->  finite (Subset of ( NAT ));

coherence
proof
per cases ;
suppose L178: C46 in ( dom C45 );

L179: ( rng C45 ) c= ( bool ( NAT ) ) by L166;
L180: ( C45 . C46 ) in ( rng C45 ) by L178 , FUNCT_1:3;
thus L181: thesis by L180 , L179;
end;
suppose L182: (not C46 in ( dom C45 ));

L183: ( C45 . C46 ) = ( {} ) by L182 , FUNCT_1:def 2;
thus L184: thesis by L183 , XBOOLE_1:2;
end;
end;
end;
theorem
L187: (for B45 being Ordinal holds (for B46 , B47 being  finite (Subset of B45) holds (B46 <> B47 implies ( (B46 , 1) -bag ) <> ( (B47 , 1) -bag ))))
proof
let C47 being Ordinal;
let C48 , C49 being  finite (Subset of C47);
assume that
L188: C48 <> C49;
assume L189: ( (C48 , 1) -bag ) = ( (C49 , 1) -bag );
L190:
now
let C50 being set;
L191: (C50 in C48 iff ( ( (C49 , 1) -bag ) . C50 ) = 1) by L189 , UPROOTS:6 , UPROOTS:7;
thus L192: (C50 in C48 iff C50 in C49) by L191 , UPROOTS:6 , UPROOTS:7;
end;
thus L193: contradiction by L190 , L188 , TARSKI:1;
end;
definition
let C51 being  natural-valued Function;
let C52 being set;
let C53 being Nat;
func C51 .incSubset (C52 , C53) ->  natural-valued Function means 
:L194: (( dom it ) = ( dom C51 ) & (for B48 being set holds (((B48 in C52 & B48 in ( dom C51 )) implies ( it . B48 ) = ( ( C51 . B48 ) + C53 )) & ((not B48 in C52) implies ( it . B48 ) = ( C51 . B48 )))));
existence
proof
deffunc H1(set) = ( ( C51 . $1 ) + C53 );
consider C54 being Function such that L195: ( dom C54 ) = ( C52 /\ ( dom C51 ) ) and L196: (for B49 being set holds (B49 in ( C52 /\ ( dom C51 ) ) implies ( C54 . B49 ) = H1(B49))) from FUNCT_1:sch 3;
L197:
now
let C55 being set;
assume L198: C55 in ( rng C54 );
consider C56 being set such that L199: C56 in ( dom C54 ) and L200: ( C54 . C56 ) = C55 by L198 , FUNCT_1:def 3;
L201: ( C54 . C56 ) = ( ( C51 . C56 ) + C53 ) by L195 , L196 , L199;
thus L202: C55 in ( NAT ) by L201 , L200;
end;
L203: ( rng C54 ) c= ( NAT ) by L197 , TARSKI:def 3;
L204: ( rng ( C51 +* C54 ) ) c= ( ( rng C51 ) \/ ( rng C54 ) ) by FUNCT_4:17;
L205: ( rng C51 ) c= ( NAT ) by VALUED_0:def 6;
L206: ( ( rng C51 ) \/ ( rng C54 ) ) c= ( NAT ) by L205 , L203 , XBOOLE_1:8;
L207: ( rng ( C51 +* C54 ) ) c= ( NAT ) by L206 , L204 , XBOOLE_1:1;
reconsider D13 = ( C51 +* C54 ) as  natural-valued Function by L207 , VALUED_0:def 6;
take D13;
L208: ( dom D13 ) = ( ( dom C51 ) \/ ( C52 /\ ( dom C51 ) ) ) by L195 , FUNCT_4:def 1;
thus L209: ( dom D13 ) = ( dom C51 ) by L208 , XBOOLE_1:22;
L210:
now
let C57 being set;
L211:
now
assume that
L212: C57 in C52
and
L213: C57 in ( dom C51 );
L214: C57 in ( dom C54 ) by L195 , L212 , L213 , XBOOLE_0:def 4;
L215: ( D13 . C57 ) = ( C54 . C57 ) by L214 , FUNCT_4:13;
L216: C57 in ( C52 /\ ( dom C51 ) ) by L212 , L213 , XBOOLE_0:def 4;
thus L217: ( D13 . C57 ) = ( ( C51 . C57 ) + C53 ) by L216 , L196 , L215;
end;
L218:
now
assume L219: (not C57 in C52);
L220: (not C57 in ( dom C54 )) by L219 , L195 , XBOOLE_0:def 4;
thus L221: ( D13 . C57 ) = ( C51 . C57 ) by L220 , FUNCT_4:11;
end;
thus L222: (((C57 in C52 & C57 in ( dom C51 )) implies ( D13 . C57 ) = ( ( C51 . C57 ) + C53 )) & ((not C57 in C52) implies ( D13 . C57 ) = ( C51 . C57 ))) by L218 , L211;
end;
thus L223: thesis by L210;
end;
uniqueness
proof
let C58 , C59 being  natural-valued Function;
assume that
L224: ( dom C58 ) = ( dom C51 )
and
L225: (for B50 being set holds (((B50 in C52 & B50 in ( dom C51 )) implies ( C58 . B50 ) = ( ( C51 . B50 ) + C53 )) & ((not B50 in C52) implies ( C58 . B50 ) = ( C51 . B50 ))))
and
L226: ( dom C59 ) = ( dom C51 )
and
L227: (for B51 being set holds (((B51 in C52 & B51 in ( dom C51 )) implies ( C59 . B51 ) = ( ( C51 . B51 ) + C53 )) & ((not B51 in C52) implies ( C59 . B51 ) = ( C51 . B51 ))));
L228:
now
let C60 being set;
assume that
L229: C60 in ( dom C58 );
per cases  by L224 , L229;
suppose L230: (C60 in C52 & C60 in ( dom C51 ));

L231: ( C58 . C60 ) = ( ( C51 . C60 ) + C53 ) by L230 , L225;
thus L232: ( C58 . C60 ) = ( C59 . C60 ) by L231 , L227 , L230;
end;
suppose L233: (not C60 in C52);

L234: ( C58 . C60 ) = ( C51 . C60 ) by L233 , L225;
thus L235: ( C58 . C60 ) = ( C59 . C60 ) by L234 , L227 , L233;
end;
end;
thus L237: thesis by L228 , L224 , L226 , FUNCT_1:2;
end;
end;
definition
let C61 being Ordinal;
let C62 being  connected (TermOrder of C61);
let C63 being non  empty  finite (Subset of ( Bags C61 ));
func max (C63 , C62) -> (bag of C61) means 
:L239: (it in C63 & (for B52 being (bag of C61) holds (B52 in C63 implies B52 <= it , C62)));
existence
proof
consider C64 being FinSequence such that L240: ( rng C64 ) = C63 by FINSEQ_1:52;
defpred S3[ Nat ] means ($1 <= ( len C64 ) implies (ex B53 being Nat st (ex B54 being (bag of C61) st (B53 in ( dom C64 ) & B53 <= $1 & ( C64 . B53 ) = B54 & (for B55 being Nat holds (for B56 being (bag of C61) holds ((B55 in ( dom C64 ) & B55 <= $1 & ( C64 . B55 ) = B56) implies B56 <= B54 , C62)))))));
L241: (for B57 being non  empty Nat holds (S3[ B57 ] implies S3[ ( B57 + 1 ) ]))
proof
let C65 being non  empty Nat;
assume that
L242: S3[ C65 ];
per cases ;
suppose L243: C65 < ( len C64 );

L244: 1 <= ( C65 + 1 ) by CHORD:1;
L245: ( C65 + 1 ) <= ( len C64 ) by L243 , NAT_1:13;
L246: ( C65 + 1 ) in ( dom C64 ) by L245 , L244 , FINSEQ_3:25;
L247: ( C64 . ( C65 + 1 ) ) in C63 by L246 , L240 , FUNCT_1:def 3;
reconsider D14 = ( C64 . ( C65 + 1 ) ) as (bag of C61) by L247;
consider C66 being Nat, C67 being (bag of C61) such that L248: C66 in ( dom C64 ) and L249: C66 <= C65 and L250: ( C64 . C66 ) = C67 and L251: (for B58 being Nat holds (for B59 being (bag of C61) holds ((B58 in ( dom C64 ) & B58 <= C65 & ( C64 . B58 ) = B59) implies B59 <= C67 , C62))) by L242 , L243;
set D15 = ( max (C67 , D14 , C62) );
L252: C67 <= D15 , C62 by TERMORD:14;
per cases  by TERMORD:12;
suppose L253: D15 = C67;

L254:
now
let C68 being Nat;
let C69 being (bag of C61);
assume that
L255: C68 in ( dom C64 )
and
L256: C68 <= ( C65 + 1 )
and
L257: ( C64 . C68 ) = C69;
per cases  by L256 , XXREAL_0:1;
suppose L258: C68 = ( C65 + 1 );

thus L259: C69 <= D15 , C62 by L258 , L257 , TERMORD:14;
end;
suppose L260: C68 < ( C65 + 1 );

L261: C68 <= C65 by L260 , NAT_1:13;
L262: C69 <= C67 , C62 by L261 , L251 , L255 , L257;
thus L263: C69 <= D15 , C62 by L262 , L252 , TERMORD:8;
end;
end;
L265: C66 <= ( C65 + 1 ) by L249 , NAT_1:13;
thus L266: thesis by L265 , L248 , L250 , L253 , L254;
end;
suppose L267: D15 = D14;

L268:
now
let C70 being Nat;
let C71 being (bag of C61);
assume that
L269: C70 in ( dom C64 )
and
L270: C70 <= ( C65 + 1 )
and
L271: ( C64 . C70 ) = C71;
per cases  by L270 , XXREAL_0:1;
suppose L272: C70 = ( C65 + 1 );

thus L273: C71 <= D15 , C62 by L272 , L271 , TERMORD:14;
end;
suppose L274: C70 < ( C65 + 1 );

L275: C70 <= C65 by L274 , NAT_1:13;
L276: C71 <= C67 , C62 by L275 , L251 , L269 , L271;
thus L277: C71 <= D15 , C62 by L276 , L252 , TERMORD:8;
end;
end;
thus L279: thesis by L268 , L246 , L267;
end;
end;
suppose L281: C65 >= ( len C64 );

thus L282: thesis by L281 , NAT_1:13;
end;
end;
L284: C64 <> ( {} ) by L240;
L285: S3[ 1 ]
proof
L286: 1 in ( dom C64 ) by L240 , FINSEQ_3:32;
L287: ( C64 . 1 ) in C63 by L286 , L240 , FUNCT_1:def 3;
reconsider D16 = ( C64 . 1 ) as (bag of C61) by L287;
L288:
now
let C72 being Nat;
let C73 being (bag of C61);
assume that
L289: C72 in ( dom C64 )
and
L290: C72 <= 1
and
L291: ( C64 . C72 ) = C73;
L292: 1 <= C72 by L289 , FINSEQ_3:25;
L293: C73 = D16 by L292 , L290 , L291 , XXREAL_0:1;
thus L294: C73 <= D16 , C62 by L293 , TERMORD:6;
end;
thus L295: thesis by L288 , L286;
end;
L296: (for B60 being non  empty Nat holds S3[ B60 ]) from NAT_1:sch 10(L285 , L241);
consider C74 being Nat, C75 being (bag of C61) such that L297: C74 in ( dom C64 ) and L298: C74 <= ( len C64 ) and L299: ( C64 . C74 ) = C75 and L300: (for B61 being Nat holds (for B62 being (bag of C61) holds ((B61 in ( dom C64 ) & B61 <= ( len C64 ) & ( C64 . B61 ) = B62) implies B62 <= C75 , C62))) by L296 , L284;
take C75;
thus L301: C75 in C63 by L240 , L297 , L299 , FUNCT_1:def 3;
L302:
now
let C76 being (bag of C61);
assume L303: C76 in C63;
consider C77 being Nat such that L304: C77 in ( dom C64 ) and L305: ( C64 . C77 ) = C76 by L303 , L240 , FINSEQ_2:10;
L306: C77 <= ( len C64 ) by L304 , FINSEQ_3:25;
thus L307: C76 <= C75 , C62 by L306 , L300 , L304 , L305;
end;
thus L308: thesis by L302;
end;
uniqueness
proof
let C78 , C79 being (bag of C61);
assume that
L309: C78 in C63
and
L310: (for B63 being (bag of C61) holds (B63 in C63 implies B63 <= C78 , C62))
and
L311: C79 in C63
and
L312: (for B64 being (bag of C61) holds (B64 in C63 implies B64 <= C79 , C62));
L313: C78 <= C79 , C62 by L309 , L312;
L314: C79 <= C78 , C62 by L310 , L311;
thus L315: C78 = C79 by L314 , L313 , TERMORD:7;
end;
end;
registration
let C80 being Ordinal;
cluster ( InvLexOrder C80 ) ->  connected;
coherence
proof
L317: ( InvLexOrder C80 ) is  well-ordering by BAGORDER:25;
thus L318: thesis by L317 , WELLORD1:def 4;
end;
end;
L320: (for B65 being _Graph holds (for B66 being (Walk of B65) holds (for B67 , B68 being set holds (B67 Joins ( B66 .last() ) , B68 , B65 implies ( ( B66 .addEdge B67 ) .length() ) = ( ( B66 .length() ) + 1 )))))
proof
let C81 being _Graph;
let C82 being (Walk of C81);
let C83 , C84 being set;
assume L321: C83 Joins ( C82 .last() ) , C84 , C81;
L322: ( ( C82 .addEdge C83 ) .edgeSeq() ) = ( ( C82 .edgeSeq() ) ^ <* C83 *> ) by L321 , GLIB_001:82;
L323: ( len <* C83 *> ) = 1 by FINSEQ_1:39;
thus L324: thesis by L323 , L322 , FINSEQ_1:22;
end;
L325: (for B69 being _Graph holds (for B70 being (Walk of B69) holds ( B70 .length() ) = ( ( B70 .reverse() ) .length() )))
proof
let C85 being _Graph;
let C86 being (Walk of C85);
L326: ( len C86 ) = ( ( 2 * ( C86 .length() ) ) + 1 ) by GLIB_001:112;
L327: ( len C86 ) = ( len ( C86 .reverse() ) ) by GLIB_001:21;
L328: ( ( ( 2 * ( C86 .length() ) ) + 1 ) - 1 ) = ( ( ( 2 * ( ( C86 .reverse() ) .length() ) ) + 1 ) - 1 ) by L327 , L326 , GLIB_001:112;
thus L329: thesis by L328;
end;
L330: (for B71 being _Graph holds (for B72 being (Walk of B71) holds (for B73 , B74 being set holds (B73 Joins ( B72 .last() ) , B74 , B71 implies (for B75 being Nat holds (B75 in ( dom B72 ) implies (( ( B72 .addEdge B73 ) . B75 ) = ( B72 . B75 ) & B75 in ( dom ( B72 .addEdge B73 ) ))))))))
proof
let C87 being _Graph;
let C88 being (Walk of C87);
let C89 , C90 being set;
assume that
L331: C89 Joins ( C88 .last() ) , C90 , C87;
let C91 being Nat;
assume that
L332: C91 in ( dom C88 );
thus L333: ( ( C88 .addEdge C89 ) . C91 ) = ( C88 . C91 ) by L331 , L332 , GLIB_001:65;
L334: 1 <= C91 by L332 , FINSEQ_3:25;
L335: ( len C88 ) < ( ( len C88 ) + 2 ) by XREAL_1:29;
L336: C91 <= ( len C88 ) by L332 , FINSEQ_3:25;
L337: C91 <= ( ( len C88 ) + 2 ) by L336 , L335 , XXREAL_0:2;
L338: ( len ( C88 .addEdge C89 ) ) = ( ( len C88 ) + 2 ) by L331 , GLIB_001:64;
thus L339: thesis by L338 , L334 , L337 , FINSEQ_3:25;
end;
begin
definition
let C92 being (ManySortedSet of ( NAT ));
attr C92 is  iterative
means
:L340: (for B76 , B77 being Nat holds (( C92 . B76 ) = ( C92 . B77 ) implies ( C92 . ( B76 + 1 ) ) = ( C92 . ( B77 + 1 ) )));
end;
definition
let C93 being (ManySortedSet of ( NAT ));
attr C93 is  eventually-constant
means
:L342: (ex B78 being Nat st (for B79 being Nat holds (B78 <= B79 implies ( C93 . B78 ) = ( C93 . B79 ))));
end;
registration
cluster  halting  iterative  eventually-constant for (ManySortedSet of ( NAT ));
existence
proof
set D17 = ( ( NAT ) --> 1 );
reconsider D18 = D17 as (ManySortedSet of ( NAT ));
take D18;
L344: ( D18 . ( 0 ) ) = 1 by FUNCOP_1:7;
L345: ( D18 . ( 0 ) ) = ( D18 . ( ( 0 ) + 1 ) ) by L344 , FUNCOP_1:7;
thus L346: D18 is  halting by L345 , GLIB_000:def 54;
L347:
now
let C94 , C95 being Nat;
assume that
L348: ( D18 . C94 ) = ( D18 . C95 );
L349: ( D18 . ( C94 + 1 ) ) = 1 by FUNCOP_1:7;
thus L350: ( D18 . ( C94 + 1 ) ) = ( D18 . ( C95 + 1 ) ) by L349 , FUNCOP_1:7;
end;
thus L351: D18 is  iterative by L347 , L340;
L352:
now
let C96 being Nat;
assume that
L353: ( 0 ) <= C96;
L354: ( D18 . ( 0 ) ) = 1 by FUNCOP_1:7;
L355: C96 in ( NAT ) by ORDINAL1:def 12;
thus L356: ( D18 . ( 0 ) ) = ( D18 . C96 ) by L355 , L354 , FUNCOP_1:7;
end;
thus L357: thesis by L352 , L342;
end;
end;
theorem
L359: (for B80 being (ManySortedSet of ( NAT )) holds ((B80 is  halting & B80 is  iterative) implies B80 is  eventually-constant))
proof
let C97 being (ManySortedSet of ( NAT ));
assume that
L360: C97 is  halting
and
L361: C97 is  iterative;
set D19 = ( C97 .Lifespan() );
defpred S4[ Nat ] means ( C97 . D19 ) = ( C97 . ( D19 + $1 ) );
L362: (for B81 being Nat holds (S4[ B81 ] implies S4[ ( B81 + 1 ) ]))
proof
let C98 being Nat;
assume L363: S4[ C98 ];
L364: ( C97 . ( D19 + 1 ) ) = ( C97 . ( ( D19 + C98 ) + 1 ) ) by L363 , L361 , L340;
thus L365: thesis by L364 , L360 , GLIB_000:def 55;
end;
L366: S4[ ( 0 ) ];
L367: (for B82 being Nat holds S4[ B82 ]) from NAT_1:sch 2(L366 , L362);
L368:
now
let C99 being Nat;
assume L369: D19 <= C99;
L370: (ex B83 being Nat st ( D19 + B83 ) = C99) by L369 , NAT_1:10;
thus L371: ( C97 . D19 ) = ( C97 . C99 ) by L370 , L367;
end;
thus L372: thesis by L368 , L342;
end;
registration
cluster  halting  iterative ->  eventually-constant for (ManySortedSet of ( NAT ));
coherence by L359;
end;
theorem
L374: (for B84 being (ManySortedSet of ( NAT )) holds (B84 is  eventually-constant implies B84 is  halting))
proof
let C100 being (ManySortedSet of ( NAT ));
assume L375: C100 is  eventually-constant;
consider C101 being Nat such that L376: (for B85 being Nat holds (C101 <= B85 implies ( C100 . C101 ) = ( C100 . B85 ))) by L375 , L342;
L377: C101 <= ( C101 + 1 ) by NAT_1:13;
L378: ( C100 . C101 ) = ( C100 . ( C101 + 1 ) ) by L377 , L376;
thus L379: thesis by L378 , GLIB_000:def 54;
end;
registration
cluster  eventually-constant ->  halting for (ManySortedSet of ( NAT ));
coherence by L374;
end;
theorem
L381: (for B86 being  iterative  eventually-constant (ManySortedSet of ( NAT )) holds (for B87 being Nat holds (( B86 .Lifespan() ) <= B87 implies ( B86 . ( B86 .Lifespan() ) ) = ( B86 . B87 ))))
proof
let C102 being  iterative  eventually-constant (ManySortedSet of ( NAT ));
set D20 = ( C102 .Lifespan() );
defpred S5[ Nat ] means ( C102 . D20 ) = ( C102 . ( D20 + $1 ) );
let C103 being Nat;
assume L382: D20 <= C103;
L383: (ex B88 being Nat st ( D20 + B88 ) = C103) by L382 , NAT_1:10;
L384: (for B89 being Nat holds (S5[ B89 ] implies S5[ ( B89 + 1 ) ]))
proof
let C104 being Nat;
assume L385: S5[ C104 ];
L386: ( C102 . ( D20 + 1 ) ) = ( C102 . ( ( D20 + C104 ) + 1 ) ) by L385 , L340;
thus L387: thesis by L386 , GLIB_000:def 55;
end;
L388: S5[ ( 0 ) ];
L389: (for B90 being Nat holds S5[ B90 ]) from NAT_1:sch 2(L388 , L384);
thus L390: thesis by L389 , L383;
end;
theorem
L391: (for B91 being  iterative  eventually-constant (ManySortedSet of ( NAT )) holds (for B92 , B93 being Nat holds ((( B91 .Lifespan() ) <= B92 & B92 <= B93) implies ( B91 . B93 ) = ( B91 . B92 ))))
proof
let C105 being  iterative  eventually-constant (ManySortedSet of ( NAT ));
let C106 , C107 being Nat;
assume that
L392: ( C105 .Lifespan() ) <= C106
and
L393: C106 <= C107;
L394: ( C105 . ( C105 .Lifespan() ) ) = ( C105 . C107 ) by L392 , L393 , L381 , XXREAL_0:2;
thus L395: thesis by L394 , L392 , L381;
end;
begin
definition
let C108 being  finite _Graph;
mode preVNumberingSeq of C108
 -> (ManySortedSet of ( NAT ))
means :L396: (for B94 being Nat holds ( it . B94 ) is (PartFunc of ( the_Vertices_of C108 ) , ( NAT )));
existence
proof
deffunc H2(set) = ( {} );
consider C109 being (ManySortedSet of ( NAT )) such that L397: (for B95 being set holds (B95 in ( NAT ) implies ( C109 . B95 ) = H2(B95))) from PBOOLE:sch 4;
take C109;
let C110 being Nat;
L398: C110 in ( NAT ) by ORDINAL1:def 12;
L399: ( C109 . C110 ) = ( {} ) by L398 , L397;
thus L400: thesis by L399 , RELSET_1:12;
end;
end;
definition
let C111 being  finite _Graph;
let C112 being (preVNumberingSeq of C111);
let C113 being Nat;
redefine func C112 . C113 -> (PartFunc of ( the_Vertices_of C111 ) , ( NAT ));

coherence by L396;
end;
definition
let C114 being  finite _Graph;
let C115 being (preVNumberingSeq of C114);
attr C115 is  vertex-numbering
means
:L403: (( C115 . ( 0 ) ) = ( {} ) & C115 is  iterative & C115 is  halting & ( C115 .Lifespan() ) = ( C114 .order() ) & (for B96 being Nat holds (B96 < ( C115 .Lifespan() ) implies (ex B97 being (Vertex of C114) st ((not B97 in ( dom ( C115 . B96 ) )) & ( C115 . ( B96 + 1 ) ) = ( ( C115 . B96 ) +* ( B97 .--> ( ( C115 .Lifespan() ) -' B96 ) ) ))))));
end;
registration
let C116 being  finite _Graph;
cluster  vertex-numbering for (preVNumberingSeq of C116);
existence
proof
set D21 = ( card ( the_Vertices_of C116 ) );
set D22 = ( canFS ( the_Vertices_of C116 ) );
deffunc H3((Element of ( NAT ))) = ( ( D21 -' $1 ) + 1 );
consider C117 being (Function of ( NAT ) , ( NAT )) such that L405: (for B98 being (Element of ( NAT )) holds ( C117 . B98 ) = H3(B98)) from FUNCT_2:sch 4;
defpred S6[ set , set ] means (ex B99 being Nat st ($1 = B99 & $2 = ( C117 * ( ( D22 | ( Seg B99 ) ) " ) )));
L406: (for B100 being set holds (B100 in ( NAT ) implies (ex B101 being set st S6[ B100 , B101 ])))
proof
let C118 being set;
assume L407: C118 in ( NAT );
reconsider D23 = C118 as Nat by L407;
take ( C117 * ( ( D22 | ( Seg D23 ) ) " ) );
thus L408: thesis;
end;
consider C119 being (ManySortedSet of ( NAT )) such that L409: (for B102 being set holds (B102 in ( NAT ) implies S6[ B102 , ( C119 . B102 ) ])) from PBOOLE:sch 3(L406);
L410: (for B103 being Nat holds ( C119 . B103 ) = ( C117 * ( ( D22 | ( Seg B103 ) ) " ) ))
proof
let C120 being Nat;
L411: C120 in ( NAT ) by ORDINAL1:def 12;
L412: (ex B104 being Nat st (C120 = B104 & ( C119 . C120 ) = ( C117 * ( ( D22 | ( Seg B104 ) ) " ) ))) by L411 , L409;
thus L413: thesis by L412;
end;
L414: (for B105 being Nat holds (B105 >= ( len D22 ) implies ( C119 . B105 ) = ( C117 * ( D22 " ) )))
proof
L415: ( dom D22 ) = ( Seg ( len D22 ) ) by FINSEQ_1:def 3;
let C121 being Nat;
assume L416: C121 >= ( len D22 );
L417: ( dom D22 ) c= ( Seg C121 ) by L416 , L415 , FINSEQ_1:5;
L418: ( D22 | ( Seg C121 ) ) = D22 by L417 , RELAT_1:68;
thus L419: thesis by L418 , L410;
end;
L420:
now
let C122 being Nat;
set D24 = ( C117 * ( ( D22 | ( Seg C122 ) ) " ) );
L421:
now
let C123 being set;
assume L422: C123 in ( rng D24 );
L423: C123 in ( rng C117 ) by L422 , FUNCT_1:14;
thus L424: C123 in ( NAT ) by L423;
end;
L425: ( rng D24 ) c= ( NAT ) by L421 , TARSKI:def 3;
L426: ( D22 | ( Seg C122 ) ) is  one-to-one by FUNCT_1:52;
L427: ( ( D22 | ( Seg C122 ) ) ~ ) = ( ( D22 | ( Seg C122 ) ) " ) by L426 , FUNCT_1:def 5;
L428:
now
let C124 being set;
assume L429: C124 in ( dom D24 );
L430: C124 in ( dom ( ( D22 | ( Seg C122 ) ) " ) ) by L429 , FUNCT_1:11;
L431: C124 in ( rng ( D22 | ( Seg C122 ) ) ) by L430 , L427 , RELAT_1:20;
thus L432: C124 in ( the_Vertices_of C116 ) by L431;
end;
L433: ( dom D24 ) c= ( the_Vertices_of C116 ) by L428 , TARSKI:def 3;
L434: ( C119 . C122 ) = ( C117 * ( ( D22 | ( Seg C122 ) ) " ) ) by L410;
thus L435: ( C119 . C122 ) is (PartFunc of ( the_Vertices_of C116 ) , ( NAT )) by L434 , L433 , L425 , RELSET_1:4;
end;
L436: ( dom C117 ) = ( NAT ) by FUNCT_2:def 1;
L437: (for B106 being Nat holds (B106 <= ( len D22 ) implies ( card ( C119 . B106 ) ) = B106))
proof
let C125 being Nat;
assume L438: C125 <= ( len D22 );
L439: ( Seg C125 ) c= ( Seg ( len D22 ) ) by L438 , FINSEQ_1:5;
L440: ( D22 | ( Seg C125 ) ) is  one-to-one by FUNCT_1:52;
L441: ( C119 . C125 ) = ( C117 * ( ( D22 | ( Seg C125 ) ) " ) ) by L410;
L442: ( card ( Seg C125 ) ) = C125 by FINSEQ_1:57;
L443: ( dom D22 ) = ( Seg ( len D22 ) ) by FINSEQ_1:def 3;
L444: ( dom ( D22 | ( Seg C125 ) ) ) = ( Seg C125 ) by L443 , L439 , RELAT_1:62;
L445: ( rng ( ( D22 | ( Seg C125 ) ) " ) ) = ( Seg C125 ) by L444 , L440 , FUNCT_1:33;
L446: ( dom ( C117 * ( ( D22 | ( Seg C125 ) ) " ) ) ) = ( dom ( ( D22 | ( Seg C125 ) ) " ) ) by L445 , L436 , RELAT_1:27
.= ( rng ( D22 | ( Seg C125 ) ) ) by L440 , FUNCT_1:33;
L447: ( card ( dom ( C117 * ( ( D22 | ( Seg C125 ) ) " ) ) ) ) = C125 by L446 , L440 , L444 , L442 , CARD_1:70;
thus L448: thesis by L447 , L441 , CARD_1:62;
end;
reconsider D25 = C119 as (preVNumberingSeq of C116) by L420 , L396;
L449: ( len D22 ) = D21 by UPROOTS:3;
L450: D25 is  iterative
proof
L451: (for B107 , B108 being Nat holds ((B107 < B108 & ( D25 . B107 ) = ( D25 . B108 )) implies ( D25 . ( B107 + 1 ) ) = ( D25 . ( B108 + 1 ) )))
proof
let C126 , C127 being Nat;
assume that
L452: C126 < C127
and
L453: ( D25 . C126 ) = ( D25 . C127 );
per cases ;
suppose L454: C127 < D21;

L455: ( card ( D25 . C127 ) ) = C127 by L454 , L449 , L437;
thus L456: thesis by L455 , L449 , L437 , L452 , L453 , L454 , XXREAL_0:2;
end;
suppose L457: D21 <= C127;

per cases ;
suppose L458: C126 < D21;

L459: ( rng ( D22 " ) ) c= ( dom C117 )
proof
let C128 being set;
assume L460: C128 in ( rng ( D22 " ) );
L461: C128 in ( rng ( (D22 qua Relation) ~ ) ) by L460 , FUNCT_1:def 5;
L462: C128 in ( dom D22 ) by L461 , RELAT_1:20;
L463: C128 in ( NAT ) by L462;
thus L464: thesis by L463 , FUNCT_2:def 1;
end;
L465: ( D25 . C127 ) = ( (( D22 " ) qua Relation) * C117 ) by L449 , L414 , L457;
L466: ( card ( D25 . C127 ) ) = ( card ( dom ( D25 . C127 ) ) ) by CARD_1:62
.= ( card ( dom ( D22 " ) ) ) by L465 , L459 , RELAT_1:27
.= ( card ( rng D22 ) ) by FUNCT_1:33
.= ( card ( dom D22 ) ) by CARD_1:70
.= ( len D22 ) by CARD_1:62;
thus L467: thesis by L466 , L449 , L437 , L453 , L458;
end;
suppose L468: C126 >= D21;

L469: ( C127 + 1 ) >= D21 by L457 , NAT_1:13;
L470: ( C126 + 1 ) >= D21 by L468 , NAT_1:13;
thus L471: ( D25 . ( C126 + 1 ) ) = ( C117 * ( D22 " ) ) by L470 , L449 , L414
.= ( D25 . ( C127 + 1 ) ) by L449 , L414 , L469;
end;
end;
end;
let C129 , C130 being Nat;
assume that
L474: ( D25 . C129 ) = ( D25 . C130 );
per cases  by XXREAL_0:1;
suppose L475: C129 < C130;

thus L476: ( D25 . ( C129 + 1 ) ) = ( D25 . ( C130 + 1 ) ) by L475 , L451 , L474;
end;
suppose L477: C129 > C130;

thus L478: ( D25 . ( C129 + 1 ) ) = ( D25 . ( C130 + 1 ) ) by L477 , L451 , L474;
end;
suppose L479: C129 = C130;

thus L480: thesis by L479;
end;
end;
reconsider D26 = D21 as (Element of ( NAT ));
L482: D26 <= ( D26 + 1 ) by NAT_1:11;
L483: D26 >= ( len D22 ) by UPROOTS:3;
L484: ( D25 . D26 ) = ( C117 * ( D22 " ) ) by L483 , L414
.= ( D25 . ( D26 + 1 ) ) by L414 , L483 , L482 , XXREAL_0:2;
L485: D25 is  halting by L484 , GLIB_000:def 54;
L486: (for B109 being Nat holds (( D25 . B109 ) = ( D25 . ( B109 + 1 ) ) implies D26 <= B109))
proof
let C131 being Nat;
assume that
L487: ( D25 . C131 ) = ( D25 . ( C131 + 1 ) )
and
L488: D26 > C131;
L489: ( C131 + 1 ) <= D26 by L488 , NAT_1:13;
L490: C131 = ( card ( D25 . ( C131 + 1 ) ) ) by L449 , L437 , L487 , L488
.= ( C131 + 1 ) by L449 , L437 , L489;
thus L491: thesis by L490;
end;
L492: ( D25 .Lifespan() ) = ( C116 .order() ) by L486 , L484 , L485 , GLIB_000:def 55;
L493:
now
let C132 being Nat;
assume that
L494: C132 < ( D25 .Lifespan() );
L495: C132 < D26 by L484 , L485 , L486 , L494 , GLIB_000:def 55;
L496: ( C132 + 1 ) <= D26 by L495 , NAT_1:13;
set D27 = ( D22 . ( C132 + 1 ) );
L497: ( ( 0 ) + 1 ) <= ( C132 + 1 ) by NAT_1:13;
L498: ( C132 + 1 ) <= ( len D22 ) by L496 , UPROOTS:3;
L499: ( C132 + 1 ) in ( dom D22 ) by L498 , L497 , FINSEQ_3:25;
L500: D27 in ( rng D22 ) by L499 , FUNCT_1:3;
reconsider D28 = D27 as (Vertex of C116) by L500;
take D29 = D28;
L501: ( D22 | ( Seg C132 ) ) is  one-to-one by FUNCT_1:52;
thus L502:now
assume L503: D29 in ( dom ( D25 . C132 ) );
L504: D29 in ( dom ( C117 * ( ( D22 | ( Seg C132 ) ) " ) ) ) by L503 , L410;
L505: D29 in ( dom ( ( D22 | ( Seg C132 ) ) " ) ) by L504 , FUNCT_1:11;
L506: D29 in ( rng ( D22 | ( Seg C132 ) ) ) by L505 , L501 , FUNCT_1:33;
consider C133 being set such that L507: C133 in ( dom ( D22 | ( Seg C132 ) ) ) and L508: D29 = ( ( D22 | ( Seg C132 ) ) . C133 ) by L506 , FUNCT_1:def 3;
L509: D29 = ( D22 . C133 ) by L507 , L508 , FUNCT_1:47;
L510: C133 in ( Seg C132 ) by L507 , RELAT_1:57;
L511: C133 in ( dom D22 ) by L507 , RELAT_1:57;
reconsider D30 = C133 as Nat by L507;
L512: D30 <= C132 by L510 , FINSEQ_1:1;
L513: D30 <> ( C132 + 1 ) by L512 , NAT_1:13;
thus L514: contradiction by L513 , L499 , L509 , L511 , FUNCT_1:def 4;
end;
L515: ( D22 | ( Seg ( C132 + 1 ) ) ) is  one-to-one by FUNCT_1:52;
L516: C132 <= ( C132 + 1 ) by NAT_1:11;
L517: ( Seg C132 ) c= ( Seg ( C132 + 1 ) ) by L516 , FINSEQ_1:5;
L518:
now
L519:
now
let C134 being set;
thus L520:now
assume L521: C134 in ( dom ( D25 . ( C132 + 1 ) ) );
L522: C134 in ( dom ( C117 * ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) ) by L521 , L410;
L523: C134 in ( dom ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) by L522 , FUNCT_1:11;
L524: C134 in ( rng ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L523 , L515 , FUNCT_1:33;
consider C135 being set such that L525: C135 in ( dom ( D22 | ( Seg ( C132 + 1 ) ) ) ) and L526: C134 = ( ( D22 | ( Seg ( C132 + 1 ) ) ) . C135 ) by L524 , FUNCT_1:def 3;
L527: C135 in ( Seg ( C132 + 1 ) ) by L525 , RELAT_1:57;
L528: ( dom ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) = ( ( dom ( D25 . C132 ) ) \/ ( dom ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) by FUNCT_4:def 1;
reconsider D31 = C135 as Nat by L525;
L529: D31 in ( dom D22 ) by L525 , RELAT_1:57;
L530: D31 <= ( C132 + 1 ) by L527 , FINSEQ_1:1;
L531: 1 <= D31 by L527 , FINSEQ_1:1;
per cases  by L530 , NAT_1:8;
suppose L532: D31 <= C132;

L533: D31 in ( Seg C132 ) by L532 , L531 , FINSEQ_1:1;
L534: D31 in ( dom ( D22 | ( Seg C132 ) ) ) by L533 , L529 , RELAT_1:57;
L535: ( ( D22 | ( Seg C132 ) ) . D31 ) = ( D22 . D31 ) by L533 , FUNCT_1:49
.= C134 by L526 , L527 , FUNCT_1:49;
L536: C134 in ( rng ( D22 | ( Seg C132 ) ) ) by L535 , L534 , FUNCT_1:3;
L537: C134 in ( dom ( ( D22 | ( Seg C132 ) ) " ) ) by L536 , L501 , FUNCT_1:33;
L538: ( ( ( D22 | ( Seg C132 ) ) " ) . C134 ) = D31 by L501 , L534 , L535 , FUNCT_1:32;
L539: ( ( ( D22 | ( Seg C132 ) ) " ) . C134 ) in ( dom C117 ) by L538 , L436 , ORDINAL1:def 12;
L540: C134 in ( dom ( C117 * ( ( D22 | ( Seg C132 ) ) " ) ) ) by L539 , L537 , FUNCT_1:11;
L541: C134 in ( dom ( D25 . C132 ) ) by L540 , L410;
thus L542: C134 in ( dom ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) by L541 , L528 , XBOOLE_0:def 3;
end;
suppose L543: D31 = ( C132 + 1 );

L544: C134 = D29 by L543 , L525 , L526 , FUNCT_1:47;
L545: C134 in ( dom ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) by L544 , FUNCOP_1:74;
thus L546: C134 in ( dom ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) by L545 , L528 , XBOOLE_0:def 3;
end;
end;
assume L548: C134 in ( dom ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) );
L549: C134 in ( ( dom ( D25 . C132 ) ) \/ ( dom ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) by L548 , FUNCT_4:def 1;
per cases  by L549 , XBOOLE_0:def 3;
suppose L550: C134 in ( dom ( D25 . C132 ) );

L551: ( D22 | ( Seg C132 ) ) c= ( D22 | ( Seg ( C132 + 1 ) ) ) by L517 , RELAT_1:75;
L552: ( rng ( D22 | ( Seg C132 ) ) ) c= ( rng ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L551 , RELAT_1:11;
L553: C134 in ( dom ( C117 * ( ( D22 | ( Seg C132 ) ) " ) ) ) by L410 , L550;
L554: C134 in ( dom ( ( D22 | ( Seg C132 ) ) " ) ) by L553 , FUNCT_1:11;
L555: C134 in ( rng ( D22 | ( Seg C132 ) ) ) by L554 , L501 , FUNCT_1:33;
L556: C134 in ( rng ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L555 , L552;
L557: C134 in ( dom ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) by L556 , L515 , FUNCT_1:33;
L558: ( ( ( D22 | ( Seg C132 ) ) " ) . C134 ) in ( dom C117 ) by L553 , FUNCT_1:11;
L559: ( ( ( D22 | ( Seg C132 ) ) " ) . C134 ) = ( ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) . C134 ) by L517 , L554 , L3;
L560: C134 in ( dom ( C117 * ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) ) by L559 , L558 , L557 , FUNCT_1:11;
thus L561: C134 in ( dom ( D25 . ( C132 + 1 ) ) ) by L560 , L410;
end;
suppose L562: C134 in ( dom ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) );

L563: ( rng ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) = ( dom ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L515 , FUNCT_1:33;
L564: C134 = D29 by L562 , FUNCOP_1:75;
L565: C134 in ( rng ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L564 , L499 , FINSEQ_1:4 , FUNCT_1:50;
L566: C134 in ( dom ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) by L565 , L515 , FUNCT_1:33;
L567: ( ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) . C134 ) in ( rng ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) by L566 , FUNCT_1:3;
L568: C134 in ( dom ( C117 * ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) ) by L567 , L436 , L566 , L563 , FUNCT_1:11;
thus L569: C134 in ( dom ( D25 . ( C132 + 1 ) ) ) by L568 , L410;
end;
end;
thus L571: ( dom ( D25 . ( C132 + 1 ) ) ) = ( dom ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) by L519 , TARSKI:1;
let C136 being set;
assume that
L572: C136 in ( dom ( D25 . ( C132 + 1 ) ) );
L573: C136 in ( ( dom ( D25 . C132 ) ) \/ ( dom ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) ) by L571 , L572 , FUNCT_4:def 1;
L574: ( D25 . ( C132 + 1 ) ) = ( C117 * ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) by L410;
L575: ( D25 . C132 ) = ( C117 * ( ( D22 | ( Seg C132 ) ) " ) ) by L410;
per cases  by L573 , XBOOLE_0:def 3;
suppose L576: C136 in ( dom ( D25 . C132 ) );

L577: C136 in ( dom ( ( D22 | ( Seg C132 ) ) " ) ) by L576 , L575 , FUNCT_1:11;
L578: C136 in ( rng ( D22 | ( Seg C132 ) ) ) by L577 , L501 , FUNCT_1:33;
consider C137 being set such that L579: C137 in ( dom ( D22 | ( Seg C132 ) ) ) and L580: ( ( D22 | ( Seg C132 ) ) . C137 ) = C136 by L578 , FUNCT_1:def 3;
L581: C137 in ( Seg C132 ) by L579 , RELAT_1:57;
reconsider D32 = C137 as Nat by L579;
L582: D32 in ( dom D22 ) by L579 , RELAT_1:57;
L583: D32 <= C132 by L581 , FINSEQ_1:1;
L584: D32 < ( C132 + 1 ) by L583 , NAT_1:13;
L585: ( D22 . D32 ) = C136 by L579 , L580 , FUNCT_1:47;
L586: C136 <> D29 by L585 , L499 , L582 , L584 , FUNCT_1:def 4;
thus L587: ( ( D25 . ( C132 + 1 ) ) . C136 ) = ( C117 . ( ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) . C136 ) ) by L572 , L574 , FUNCT_1:12
.= ( C117 . ( ( ( D22 | ( Seg C132 ) ) " ) . C136 ) ) by L517 , L577 , L3
.= ( ( D25 . C132 ) . C136 ) by L575 , L576 , FUNCT_1:12
.= ( ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) . C136 ) by L586 , FUNCT_4:83;
end;
suppose L588: C136 in ( dom ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) );

L589: ( C132 + 1 ) in ( Seg ( C132 + 1 ) ) by FINSEQ_1:4;
L590: ( C132 + 1 ) in ( dom ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L589 , L499 , RELAT_1:57;
L591: ( ( D22 | ( Seg ( C132 + 1 ) ) ) . ( C132 + 1 ) ) = D29 by L590 , FUNCT_1:47;
L592: C136 = D29 by L588 , FUNCOP_1:75;
L593: C136 in ( rng ( D22 | ( Seg ( C132 + 1 ) ) ) ) by L592 , L499 , FINSEQ_1:4 , FUNCT_1:50;
L594: C136 in ( dom ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) by L593 , L515 , FUNCT_1:33;
L595: ( ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) . C136 ) = ( ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) . C136 ) by L588 , FUNCT_4:13
.= ( ( D25 .Lifespan() ) -' C132 ) by L592 , FUNCOP_1:72;
L596: ( ( D25 . ( C132 + 1 ) ) . C136 ) = ( ( C117 * ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) ) . C136 ) by L410
.= ( C117 . ( ( ( D22 | ( Seg ( C132 + 1 ) ) ) " ) . C136 ) ) by L594 , FUNCT_1:13
.= ( C117 . ( C132 + 1 ) ) by L515 , L592 , L590 , L591 , FUNCT_1:32
.= ( ( D26 -' ( C132 + 1 ) ) + 1 ) by L405
.= ( ( D26 - ( C132 + 1 ) ) + 1 ) by L496 , XREAL_1:233
.= ( D26 - C132 )
.= ( ( D25 .Lifespan() ) -' C132 ) by L492 , L494 , XREAL_1:233;
thus L597: ( ( D25 . ( C132 + 1 ) ) . C136 ) = ( ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) . C136 ) by L596 , L595;
end;
end;
thus L599: ( D25 . ( C132 + 1 ) ) = ( ( D25 . C132 ) +* ( D29 .--> ( ( D25 .Lifespan() ) -' C132 ) ) ) by L518 , FUNCT_1:2;
end;
take D25;
L600: ( card ( D25 . ( 0 ) ) ) = ( 0 ) by L437;
L601: ( D25 . ( 0 ) ) = ( {} ) by L600;
thus L602: thesis by L601 , L450 , L485 , L492 , L493 , L403;
end;
end;
registration
let C138 being  finite _Graph;
cluster  vertex-numbering ->  halting  iterative for (preVNumberingSeq of C138);
correctness by L403;
end;
definition
let C139 being  finite _Graph;
mode VNumberingSeq of C139
 is  vertex-numbering (preVNumberingSeq of C139);
end;
definition
let C140 being  finite _Graph;
let C141 being (VNumberingSeq of C140);
let C142 being Nat;
func C141 .PickedAt C142 -> set means 
:L606: it = ( choose ( the_Vertices_of C140 ) ) if C142 >= ( C141 .Lifespan() ) otherwise ((not it in ( dom ( C141 . C142 ) )) & ( C141 . ( C142 + 1 ) ) = ( ( C141 . C142 ) +* ( it .--> ( ( C141 .Lifespan() ) -' C142 ) ) ));
existence
proof
per cases ;
suppose L607: C142 >= ( C141 .Lifespan() );

thus L608: thesis by L607;
end;
suppose L609: C142 < ( C141 .Lifespan() );

L610: (ex B110 being (Vertex of C140) st ((not B110 in ( dom ( C141 . C142 ) )) & ( C141 . ( C142 + 1 ) ) = ( ( C141 . C142 ) +* ( B110 .--> ( ( C141 .Lifespan() ) -' C142 ) ) ))) by L609 , L403;
thus L611: thesis by L610;
end;
end;
uniqueness
proof
set D33 = ( C141 . ( C142 + 1 ) );
set D34 = ( C141 . C142 );
let C143 , C144 being set;
thus L613: ((C142 >= ( C141 .Lifespan() ) & C143 = ( choose ( the_Vertices_of C140 ) ) & C144 = ( choose ( the_Vertices_of C140 ) )) implies C143 = C144);
assume L614: C142 < ( C141 .Lifespan() );
assume that
L615: (not C143 in ( dom D34 ))
and
L616: D33 = ( D34 +* ( C143 .--> ( ( C141 .Lifespan() ) -' C142 ) ) );
set D35 = ( C144 .--> ( ( C141 .Lifespan() ) -' C142 ) );
set D36 = ( C143 .--> ( ( C141 .Lifespan() ) -' C142 ) );
assume that
L617: (not C144 in ( dom D34 ))
and
L618: D33 = ( D34 +* ( C144 .--> ( ( C141 .Lifespan() ) -' C142 ) ) );
L619: ( dom D35 ) = { C144 } by FUNCOP_1:13;
L620: ( dom D33 ) = ( ( dom D34 ) \/ { C144 } ) by L619 , L618 , FUNCT_4:def 1;
L621: ( dom D36 ) = { C143 } by FUNCOP_1:13;
L622: ( dom D33 ) = ( ( dom D34 ) \/ { C143 } ) by L621 , L616 , FUNCT_4:def 1;
L623:
now
assume L624: C143 <> C144;
L625: (not C143 in { C144 }) by L624 , TARSKI:def 1;
L626: (not C143 in ( dom D33 )) by L625 , L615 , L620 , XBOOLE_0:def 3;
L627: C143 in { C143 } by TARSKI:def 1;
thus L628: contradiction by L627 , L622 , L626 , XBOOLE_0:def 3;
end;
thus L629: thesis by L623;
end;
consistency;
end;
theorem
L631: (for B111 being  finite _Graph holds (for B112 being (VNumberingSeq of B111) holds (for B113 being Nat holds (B113 < ( B112 .Lifespan() ) implies (( B112 .PickedAt B113 ) in ( dom ( B112 . ( B113 + 1 ) ) ) & ( dom ( B112 . ( B113 + 1 ) ) ) = ( ( dom ( B112 . B113 ) ) \/ { ( B112 .PickedAt B113 ) } ))))))
proof
let C145 being  finite _Graph;
let C146 being (VNumberingSeq of C145);
let C147 being Nat;
assume that
L632: C147 < ( C146 .Lifespan() );
set D37 = ( ( C146 .PickedAt C147 ) .--> ( ( C146 .Lifespan() ) -' C147 ) );
set D38 = ( C146 . ( C147 + 1 ) );
set D39 = ( C146 . C147 );
set D40 = D39;
set D41 = D38;
L633: ( dom D37 ) = { ( C146 .PickedAt C147 ) } by FUNCOP_1:13;
L634: ( C146 .PickedAt C147 ) in { ( C146 .PickedAt C147 ) } by TARSKI:def 1;
L635: D41 = ( D40 +* ( ( C146 .PickedAt C147 ) .--> ( ( C146 .Lifespan() ) -' C147 ) ) ) by L632 , L606;
L636: ( dom D41 ) = ( ( dom D40 ) \/ { ( C146 .PickedAt C147 ) } ) by L635 , L633 , FUNCT_4:def 1;
thus L637: ( C146 .PickedAt C147 ) in ( dom D38 ) by L636 , L634 , XBOOLE_0:def 3;
thus L638: thesis by L635 , L633 , FUNCT_4:def 1;
end;
theorem
L639: (for B114 being  finite _Graph holds (for B115 being (VNumberingSeq of B114) holds (for B116 being Nat holds (B116 < ( B115 .Lifespan() ) implies ( ( B115 . ( B116 + 1 ) ) . ( B115 .PickedAt B116 ) ) = ( ( B115 .Lifespan() ) -' B116 )))))
proof
let C148 being  finite _Graph;
let C149 being (VNumberingSeq of C148);
let C150 being Nat;
assume that
L640: C150 < ( C149 .Lifespan() );
set D42 = ( C149 .PickedAt C150 );
set D43 = ( C149 . ( C150 + 1 ) );
set D44 = ( C149 . C150 );
set D45 = D44;
set D46 = D43;
set D47 = ( D42 .--> ( ( C149 .Lifespan() ) -' C150 ) );
L641: ( D47 . D42 ) = ( ( C149 .Lifespan() ) -' C150 ) by FUNCOP_1:72;
L642: ( dom D47 ) = { D42 } by FUNCOP_1:13;
L643: D42 in ( dom D47 ) by L642 , TARSKI:def 1;
L644: D46 = ( D45 +* ( D42 .--> ( ( C149 .Lifespan() ) -' C150 ) ) ) by L640 , L606;
thus L645: thesis by L644 , L643 , L641 , FUNCT_4:13;
end;
theorem
L646: (for B117 being  finite _Graph holds (for B118 being (VNumberingSeq of B117) holds (for B119 being Nat holds (B119 <= ( B118 .Lifespan() ) implies ( card ( dom ( B118 . B119 ) ) ) = B119))))
proof
let C151 being  finite _Graph;
let C152 being (VNumberingSeq of C151);
let C153 being Nat;
assume that
L647: C153 <= ( C152 .Lifespan() );
defpred S7[ Nat ] means ($1 <= ( C152 .Lifespan() ) implies ( card ( dom ( C152 . $1 ) ) ) = $1);
L648: (for B120 being Nat holds ((B120 < ( C152 .Lifespan() ) & ( card ( dom ( C152 . B120 ) ) ) = B120) implies ( card ( dom ( C152 . ( B120 + 1 ) ) ) ) = ( B120 + 1 )))
proof
let C154 being Nat;
assume that
L649: C154 < ( C152 .Lifespan() )
and
L650: ( card ( dom ( C152 . C154 ) ) ) = C154;
set D48 = ( C152 .PickedAt C154 );
set D49 = ( C152 . ( C154 + 1 ) );
set D50 = ( C152 . C154 );
set D51 = D50;
set D52 = D49;
set D53 = ( D48 .--> ( ( C152 .Lifespan() ) -' C154 ) );
L651: ( dom D53 ) = { D48 } by FUNCOP_1:13;
L652: D52 = ( D51 +* ( D48 .--> ( ( C152 .Lifespan() ) -' C154 ) ) ) by L649 , L606;
L653: ( dom D52 ) = ( ( dom D51 ) \/ { D48 } ) by L652 , L651 , FUNCT_4:def 1;
L654: (not D48 in ( dom D51 )) by L649 , L606;
thus L655: thesis by L654 , L650 , L653 , CARD_2:41;
end;
L656: (for B121 being Nat holds (S7[ B121 ] implies S7[ ( B121 + 1 ) ]))
proof
let C155 being Nat;
assume that
L657: S7[ C155 ];
per cases ;
suppose L658: C155 < ( C152 .Lifespan() );

thus L659: thesis by L658 , L648 , L657;
end;
suppose L660: C155 >= ( C152 .Lifespan() );

thus L661: thesis by L660 , NAT_1:13;
end;
end;
L663: S7[ ( 0 ) ] by L403 , CARD_1:27 , RELAT_1:38;
L664: (for B122 being Nat holds S7[ B122 ]) from NAT_1:sch 2(L663 , L656);
thus L665: thesis by L664 , L647;
end;
theorem
L666: (for B123 being  finite _Graph holds (for B124 being (VNumberingSeq of B123) holds (for B125 being Nat holds ( rng ( B124 . B125 ) ) = ( ( Seg ( B124 .Lifespan() ) ) \ ( Seg ( ( B124 .Lifespan() ) -' B125 ) ) ))))
proof
let C156 being  finite _Graph;
let C157 being (VNumberingSeq of C156);
let C158 being Nat;
set D54 = ( C157 . C158 );
set D55 = ( C157 . ( C157 .Lifespan() ) );
set D56 = ( C157 .Lifespan() );
defpred S8[ Nat ] means ($1 <= D56 implies ( rng ( C157 . $1 ) ) = ( ( Seg D56 ) \ ( Seg ( D56 -' $1 ) ) ));
L667: (for B126 being Nat holds (S8[ B126 ] implies S8[ ( B126 + 1 ) ]))
proof
let C159 being Nat;
assume that
L668: S8[ C159 ];
set D57 = ( C157 . ( C159 + 1 ) );
set D58 = ( C157 . C159 );
set D59 = D58;
set D60 = D57;
per cases ;
suppose L669: ( C159 + 1 ) <= D56;

set D61 = ( C157 .PickedAt C159 );
set D62 = ( D61 .--> ( D56 -' C159 ) );
L670: ( dom D62 ) = { D61 } by FUNCOP_1:13;
L671: C159 < D56 by L669 , NAT_1:13;
L672: (not D61 in ( dom D59 )) by L671 , L606;
L673: ( dom D62 ) misses ( dom D59 ) by L672 , L670 , ZFMISC_1:50;
L674: ( rng D62 ) = { ( D56 -' C159 ) } by FUNCOP_1:8;
L675: D60 = ( D59 +* ( D61 .--> ( D56 -' C159 ) ) ) by L671 , L606;
L676: ( rng D60 ) = ( ( rng D59 ) \/ { ( D56 -' C159 ) } ) by L675 , L674 , L673 , NECKLACE:6;
thus L677: thesis by L676 , L668 , L671 , L134;
end;
suppose L678: D56 < ( C159 + 1 );

thus L679: thesis by L678;
end;
end;
L681: S8[ ( 0 ) ]
proof
set D63 = ( C157 . ( 0 ) );
set D64 = D63;
L682: ( D56 -' ( 0 ) ) = ( D56 - ( 0 ) ) by XREAL_1:233;
L683: ( rng D64 ) = ( {} ) by L403 , RELAT_1:38;
thus L684: thesis by L683 , L682 , XBOOLE_1:37;
end;
L685: (for B127 being Nat holds S8[ B127 ]) from NAT_1:sch 2(L681 , L667);
per cases ;
suppose L686: C158 <= D56;

thus L687: thesis by L686 , L685;
end;
suppose L688: D56 < C158;

L689: ( D56 - C158 ) < ( C158 - C158 ) by L688 , XREAL_1:9;
L690: ( D56 -' C158 ) = ( 0 ) by L689 , XREAL_0:def 2;
L691: ( D56 -' D56 ) = ( D56 -' C158 ) by L690 , XREAL_1:232;
L692: D55 = D54 by L688 , L381;
thus L693: thesis by L692 , L685 , L691;
end;
end;
theorem
L695: (for B128 being  finite _Graph holds (for B129 being (VNumberingSeq of B128) holds (for B130 being Nat holds (for B131 being set holds (( ( B129 . B130 ) . B131 ) <= ( B129 .Lifespan() ) & (B131 in ( dom ( B129 . B130 ) ) implies 1 <= ( ( B129 . B130 ) . B131 )))))))
proof
let C160 being  finite _Graph;
let C161 being (VNumberingSeq of C160);
let C162 being Nat;
let C163 being set;
set D65 = ( C161 . C162 );
set D66 = D65;
L696:
now
per cases ;
suppose L697: (not C163 in ( dom D66 ));

thus L698: ( D66 . C163 ) <= ( C161 .Lifespan() ) by L697 , FUNCT_1:def 2;
end;
suppose L699: C163 in ( dom D66 );

L700: ( D66 . C163 ) in ( rng D66 ) by L699 , FUNCT_1:def 3;
L701: ( D66 . C163 ) in ( ( Seg ( C161 .Lifespan() ) ) \ ( Seg ( ( C161 .Lifespan() ) -' C162 ) ) ) by L700 , L666;
thus L702: ( D66 . C163 ) <= ( C161 .Lifespan() ) by L701 , L100;
end;
end;
L704:
now
assume L705: C163 in ( dom ( C161 . C162 ) );
L706: ( D66 . C163 ) in ( rng D66 ) by L705 , FUNCT_1:def 3;
L707: ( D66 . C163 ) in ( ( Seg ( C161 .Lifespan() ) ) \ ( Seg ( ( C161 .Lifespan() ) -' C162 ) ) ) by L706 , L666;
L708: ( ( C161 .Lifespan() ) -' C162 ) < ( D66 . C163 ) by L707 , L100;
L709: ( ( 0 ) + 1 ) <= ( D66 . C163 ) by L708 , NAT_1:13;
thus L710: 1 <= ( D66 . C163 ) by L709;
end;
thus L711: thesis by L704 , L696;
end;
theorem
L712: (for B132 being  finite _Graph holds (for B133 being (VNumberingSeq of B132) holds (for B134 , B135 being Nat holds ((( ( B133 .Lifespan() ) -' B134 ) < B135 & B135 <= ( B133 .Lifespan() )) implies (ex B136 being (Vertex of B132) st (B136 in ( dom ( B133 . B134 ) ) & ( ( B133 . B134 ) . B136 ) = B135))))))
proof
let C164 being  finite _Graph;
let C165 being (VNumberingSeq of C164);
let C166 , C167 being Nat;
assume that
L713: ( ( C165 .Lifespan() ) -' C166 ) < C167
and
L714: C167 <= ( C165 .Lifespan() );
set D67 = ( C165 . C166 );
set D68 = D67;
L715: C167 in ( ( Seg ( C165 .Lifespan() ) ) \ ( Seg ( ( C165 .Lifespan() ) -' C166 ) ) ) by L713 , L714 , L100;
L716: C167 in ( rng D68 ) by L715 , L666;
consider C168 being set such that L717: C168 in ( dom D68 ) and L718: C167 = ( D68 . C168 ) by L716 , FUNCT_1:def 3;
take C168;
thus L719: C168 is (Vertex of C164) by L717;
thus L720: C168 in ( dom D67 ) by L717;
thus L721: thesis by L718;
end;
theorem
L722: (for B137 being  finite _Graph holds (for B138 being (VNumberingSeq of B137) holds (for B139 , B140 being Nat holds (B139 <= B140 implies ( B138 . B139 ) c= ( B138 . B140 )))))
proof
let C169 being  finite _Graph;
let C170 being (VNumberingSeq of C169);
let C171 , C172 being Nat;
assume L723: C171 <= C172;
L724: (ex B141 being Nat st C172 = ( C171 + B141 )) by L723 , NAT_1:10;
set D69 = ( C170 . C171 );
set D70 = D69;
defpred S9[ Nat ] means D70 c= ( C170 . ( C171 + $1 ) );
L725:
now
let C173 being Nat;
set D71 = ( C170 . C173 );
set D72 = D71;
set D73 = ( C170 . ( C173 + 1 ) );
set D74 = D73;
per cases ;
suppose L726: C173 < ( C170 .Lifespan() );

set D75 = ( C170 .PickedAt C173 );
set D76 = ( D75 .--> ( ( C170 .Lifespan() ) -' C173 ) );
L727: ( dom D76 ) = { D75 } by FUNCOP_1:13;
L728: (not D75 in ( dom D72 )) by L726 , L606;
L729: ( dom D76 ) misses ( dom D72 ) by L728 , L727 , ZFMISC_1:50;
L730: D74 = ( D72 +* ( D75 .--> ( ( C170 .Lifespan() ) -' C173 ) ) ) by L726 , L606;
thus L731: D72 c= D74 by L730 , L729 , FUNCT_4:32;
end;
suppose L732: ( C170 .Lifespan() ) <= C173;

L733: C173 <= ( C173 + 1 ) by NAT_1:13;
thus L734: D72 c= D74 by L733 , L732 , L391;
end;
end;
L736: (for B142 being Nat holds (S9[ B142 ] implies S9[ ( B142 + 1 ) ]))
proof
let C174 being Nat;
assume that
L737: S9[ C174 ];
L738: ( C170 . ( C171 + C174 ) ) c= ( C170 . ( ( C171 + C174 ) + 1 ) ) by L725;
thus L739: thesis by L738 , L737 , XBOOLE_1:1;
end;
L740: S9[ ( 0 ) ];
L741: (for B143 being Nat holds S9[ B143 ]) from NAT_1:sch 2(L740 , L736);
thus L742: thesis by L741 , L724;
end;
theorem
L743: (for B144 being  finite _Graph holds (for B145 being (VNumberingSeq of B144) holds (for B146 being Nat holds ( B145 . B146 ) is  one-to-one)))
proof
let C175 being  finite _Graph;
let C176 being (VNumberingSeq of C175);
let C177 being Nat;
defpred S10[ Nat ] means ( C176 . $1 ) is  one-to-one;
L744: (for B147 being Nat holds (S10[ B147 ] implies S10[ ( B147 + 1 ) ]))
proof
set D77 = ( C176 .Lifespan() );
let C178 being Nat;
assume that
L745: S10[ C178 ];
set D78 = ( C176 .PickedAt C178 );
set D79 = ( C176 . ( C178 + 1 ) );
set D80 = ( C176 . C178 );
set D81 = D80;
set D82 = D79;
per cases ;
suppose L746: C178 < D77;

set D83 = ( D78 .--> ( D77 -' C178 ) );
L747:
now
assume L748: ( D77 -' C178 ) in ( rng D81 );
L749: ( rng D81 ) = ( ( Seg D77 ) \ ( Seg ( D77 -' C178 ) ) ) by L666;
thus L750: contradiction by L749 , L748 , L100;
end;
L751: ( rng D83 ) = { ( D77 -' C178 ) } by FUNCOP_1:8;
L752: ( rng D83 ) misses ( rng D81 ) by L751 , L747 , ZFMISC_1:50;
L753: D82 = ( D81 +* ( D78 .--> ( D77 -' C178 ) ) ) by L746 , L606;
thus L754: thesis by L753 , L745 , L752 , FUNCT_4:92;
end;
suppose L755: C178 >= D77;

L756: C178 <= ( C178 + 1 ) by NAT_1:13;
thus L757: thesis by L756 , L745 , L755 , L391;
end;
end;
L759: S10[ ( 0 ) ] by L403;
L760: (for B148 being Nat holds S10[ B148 ]) from NAT_1:sch 2(L759 , L744);
thus L761: thesis by L760;
end;
theorem
L762: (for B149 being  finite _Graph holds (for B150 being (VNumberingSeq of B149) holds (for B151 , B152 being Nat holds (for B153 being set holds ((B153 in ( dom ( B150 . B151 ) ) & B153 in ( dom ( B150 . B152 ) )) implies ( ( B150 . B151 ) . B153 ) = ( ( B150 . B152 ) . B153 ))))))
proof
let C179 being  finite _Graph;
let C180 being (VNumberingSeq of C179);
let C181 , C182 being Nat;
let C183 being set;
assume that
L763: C183 in ( dom ( C180 . C181 ) )
and
L764: C183 in ( dom ( C180 . C182 ) );
set D84 = ( C180 . C181 );
L765: [ C183 , ( D84 . C183 ) ] in D84 by L763 , FUNCT_1:def 2;
set D85 = ( C180 . C182 );
L766: [ C183 , ( D85 . C183 ) ] in D85 by L764 , FUNCT_1:def 2;
per cases ;
suppose L767: C181 <= C182;

L768: D84 c= D85 by L767 , L722;
thus L769: thesis by L768 , L764 , L765 , FUNCT_1:def 2;
end;
suppose L770: C181 > C182;

L771: D85 c= D84 by L770 , L722;
thus L772: thesis by L771 , L763 , L766 , FUNCT_1:def 2;
end;
end;
theorem
L774: (for B154 being  finite _Graph holds (for B155 being (VNumberingSeq of B154) holds (for B156 , B157 being Nat holds (for B158 being set holds ((B158 in ( dom ( B155 . B156 ) ) & ( ( B155 . B156 ) . B158 ) = B157) implies ( B155 .PickedAt ( ( B155 .Lifespan() ) -' B157 ) ) = B158)))))
proof
let C184 being  finite _Graph;
let C185 being (VNumberingSeq of C184);
let C186 , C187 being Nat;
let C188 being set;
set D86 = ( C185 . C186 );
set D87 = D86;
set D88 = ( ( C185 .Lifespan() ) -' C187 );
set D89 = ( C185 . ( D88 + 1 ) );
set D90 = D89;
assume that
L775: C188 in ( dom D86 )
and
L776: ( D87 . C188 ) = C187;
set D91 = ( C185 .PickedAt D88 );
L777: C187 <= ( C185 .Lifespan() ) by L776 , L695;
L778: ( ( C185 .Lifespan() ) -' C187 ) = ( ( C185 .Lifespan() ) - C187 ) by L777 , XREAL_1:233;
L779: ( 0 ) < C187 by L775 , L776 , L695;
L780: D88 < ( C185 .Lifespan() ) by L779 , L778 , XREAL_1:44;
L781: ( ( C185 .Lifespan() ) -' D88 ) = ( ( C185 .Lifespan() ) - ( ( C185 .Lifespan() ) - C187 ) ) by L780 , L778 , XREAL_1:233;
L782: ( D90 . D91 ) = C187 by L781 , L779 , L778 , L639 , XREAL_1:44;
L783: D87 is  one-to-one by L743;
L784: D91 in ( dom D89 ) by L780 , L631;
per cases ;
suppose L785: C186 <= D88;

L786: ( C186 + C187 ) <= ( ( ( C185 .Lifespan() ) - C187 ) + C187 ) by L785 , L778 , XREAL_1:6;
L787: ( ( C187 + C186 ) - C186 ) <= ( ( C185 .Lifespan() ) - C186 ) by L786 , XREAL_1:9;
L788: ( rng D87 ) = ( ( Seg ( C185 .Lifespan() ) ) \ ( Seg ( ( C185 .Lifespan() ) -' C186 ) ) ) by L666;
L789: C187 in ( rng D87 ) by L775 , L776 , FUNCT_1:def 3;
L790: ( ( C185 .Lifespan() ) - C186 ) = ( ( C185 .Lifespan() ) -' C186 ) by L780 , L785 , XREAL_1:233 , XXREAL_0:2;
thus L791: thesis by L790 , L787 , L789 , L788 , L100;
end;
suppose L792: D88 < C186;

L793: ( D88 + 1 ) <= C186 by L792 , NAT_1:13;
L794: D90 c= D87 by L793 , L722;
L795: ( dom D90 ) c= ( dom D87 ) by L794 , RELAT_1:11;
L796: [ D91 , C187 ] in D90 by L784 , L782 , FUNCT_1:def 2;
L797: ( D87 . D91 ) = C187 by L796 , L784 , L794 , L795 , FUNCT_1:def 2;
thus L798: thesis by L797 , L775 , L776 , L784 , L783 , L795 , FUNCT_1:def 4;
end;
end;
theorem
L800: (for B159 being  finite _Graph holds (for B160 being (VNumberingSeq of B159) holds (for B161 , B162 being Nat holds ((B162 < ( B160 .Lifespan() ) & B162 < B161) implies (( B160 .PickedAt B162 ) in ( dom ( B160 . B161 ) ) & ( ( B160 . B161 ) . ( B160 .PickedAt B162 ) ) = ( ( B160 .Lifespan() ) -' B162 ))))))
proof
let C189 being  finite _Graph;
let C190 being (VNumberingSeq of C189);
let C191 , C192 being Nat;
assume that
L801: C192 < ( C190 .Lifespan() )
and
L802: C192 < C191;
set D92 = ( C190 . ( C192 + 1 ) );
set D93 = D92;
set D94 = ( C190 .PickedAt C192 );
L803: ( D93 . D94 ) = ( ( C190 .Lifespan() ) -' C192 ) by L801 , L639;
set D95 = ( C190 . C191 );
set D96 = D95;
L804: ( C192 + 1 ) <= C191 by L802 , NAT_1:13;
L805: D93 c= D96 by L804 , L722;
L806: ( dom D93 ) c= ( dom D96 ) by L805 , RELAT_1:11;
L807: D94 in ( dom D92 ) by L801 , L631;
thus L808: thesis by L807 , L803 , L806 , L762;
end;
theorem
L809: (for B163 being  finite _Graph holds (for B164 being (VNumberingSeq of B163) holds (for B165 being Nat holds (for B166 being set holds (B166 in ( dom ( B164 . B165 ) ) implies (( ( B164 .Lifespan() ) -' ( ( B164 . B165 ) . B166 ) ) < B165 & ( ( B164 .Lifespan() ) -' B165 ) < ( ( B164 . B165 ) . B166 )))))))
proof
let C193 being  finite _Graph;
let C194 being (VNumberingSeq of C193);
let C195 being Nat;
let C196 being set;
set D97 = ( C194 . C195 );
set D98 = ( ( C194 .Lifespan() ) -' ( D97 . C196 ) );
set D99 = ( C194 . D98 );
assume L810: C196 in ( dom D97 );
L811: ( C194 .PickedAt D98 ) = C196 by L810 , L774;
L812: ( 0 ) < ( D97 . C196 ) by L810 , L695;
L813: ( D97 . C196 ) <= ( C194 .Lifespan() ) by L695;
L814: D98 = ( ( C194 .Lifespan() ) - ( D97 . C196 ) ) by L813 , XREAL_1:233;
L815: D98 < ( C194 .Lifespan() ) by L814 , L812 , XREAL_1:44;
L816:
now
per cases ;
suppose L817: C195 <= D98;

L818: D97 c= D99 by L817 , L722;
L819: ( dom D97 ) c= ( dom D99 ) by L818 , RELAT_1:11;
thus L820: ( ( C194 .Lifespan() ) -' ( D97 . C196 ) ) < C195 by L819 , L810 , L811 , L815 , L606;
end;
suppose L821: C195 > D98;

thus L822: ( ( C194 .Lifespan() ) -' ( D97 . C196 ) ) < C195 by L821;
end;
end;
L824:
now
per cases ;
suppose L825: ( ( C194 .Lifespan() ) - C195 ) >= ( 0 );

L826: ( ( C194 .Lifespan() ) - ( D97 . C196 ) ) < C195 by L813 , L816 , XREAL_1:233;
L827: ( ( ( C194 .Lifespan() ) - ( D97 . C196 ) ) + ( D97 . C196 ) ) < ( C195 + ( D97 . C196 ) ) by L826 , XREAL_1:6;
L828: ( ( C194 .Lifespan() ) - C195 ) < ( ( ( D97 . C196 ) + C195 ) - C195 ) by L827 , XREAL_1:9;
thus L829: ( ( C194 .Lifespan() ) -' C195 ) < ( D97 . C196 ) by L828 , L825 , XREAL_0:def 2;
end;
suppose L830: ( ( C194 .Lifespan() ) - C195 ) < ( 0 );

thus L831: ( ( C194 .Lifespan() ) -' C195 ) < ( D97 . C196 ) by L830 , L812 , XREAL_0:def 2;
end;
end;
thus L833: thesis by L824 , L816;
end;
theorem
L834: (for B167 being  finite _Graph holds (for B168 being (VNumberingSeq of B167) holds (for B169 being Nat holds (for B170 , B171 being set holds ((B170 in ( dom ( B168 . B169 ) ) & B171 in ( dom ( B168 . B169 ) ) & ( ( B168 . B169 ) . B170 ) < ( ( B168 . B169 ) . B171 )) implies B171 in ( dom ( B168 . ( ( B168 .Lifespan() ) -' ( ( B168 . B169 ) . B170 ) ) ) ))))))
proof
let C197 being  finite _Graph;
let C198 being (VNumberingSeq of C197);
let C199 being Nat;
let C200 , C201 being set;
assume that
L835: C200 in ( dom ( C198 . C199 ) )
and
L836: C201 in ( dom ( C198 . C199 ) )
and
L837: ( ( C198 . C199 ) . C200 ) < ( ( C198 . C199 ) . C201 );
set D100 = ( C198 .Lifespan() );
set D101 = ( C198 . C199 );
set D102 = D101;
set D103 = ( ( C198 .Lifespan() ) -' ( D102 . C200 ) );
set D104 = ( C198 . D103 );
set D105 = D104;
L838: ( D102 . C200 ) <= D100 by L695;
L839: ( D100 -' ( D102 . C200 ) ) = ( D100 - ( D102 . C200 ) ) by L838 , XREAL_1:233;
L840: ( D100 -' D103 ) = ( D100 - ( D100 - ( D102 . C200 ) ) ) by L839 , NAT_D:35 , XREAL_1:233;
consider C202 being (Vertex of C197) such that L841: C202 in ( dom D104 ) and L842: ( D105 . C202 ) = ( D102 . C201 ) by L840 , L837 , L695 , L712;
L843:
now
assume L844: D103 >= C199;
L845: D102 c= D105 by L844 , L722;
L846: ( dom D102 ) c= ( dom D105 ) by L845 , RELAT_1:11;
L847: ( 0 ) < ( D102 . C200 ) by L835 , L695;
L848: D103 < D100 by L847 , L839 , XREAL_1:44;
L849: C200 = ( C198 .PickedAt D103 ) by L835 , L774;
thus L850: contradiction by L849 , L835 , L846 , L848 , L606;
end;
L851: D105 c= D102 by L843 , L722;
L852: [ C202 , ( D102 . C201 ) ] in D105 by L841 , L842 , FUNCT_1:1;
L853: ( D102 . C202 ) = ( D102 . C201 ) by L852 , L851 , FUNCT_1:1;
L854: D102 is  one-to-one by L743;
L855: C202 in ( dom D102 ) by L851 , L852 , FUNCT_1:1;
thus L856: thesis by L855 , L836 , L841 , L853 , L854 , FUNCT_1:def 4;
end;
theorem
L857: (for B172 being  finite _Graph holds (for B173 being (VNumberingSeq of B172) holds (for B174 being Nat holds (for B175 , B176 being set holds ((B175 in ( dom ( B173 . B174 ) ) & ( ( B173 . B174 ) . B175 ) < ( ( B173 . B174 ) . B176 )) implies (not B175 in ( dom ( B173 . ( ( B173 .Lifespan() ) -' ( ( B173 . B174 ) . B176 ) ) ) )))))))
proof
let C203 being  finite _Graph;
let C204 being (VNumberingSeq of C203);
let C205 being Nat;
let C206 , C207 being set;
assume that
L858: C206 in ( dom ( C204 . C205 ) )
and
L859: ( ( C204 . C205 ) . C206 ) < ( ( C204 . C205 ) . C207 );
set D106 = ( C204 .Lifespan() );
set D107 = ( C204 . C205 );
set D108 = D107;
set D109 = ( D106 -' ( D108 . C206 ) );
L860: ( D108 . C206 ) <= D106 by L695;
L861: D109 = ( D106 - ( D108 . C206 ) ) by L860 , XREAL_1:233;
set D110 = ( C204 . D109 );
set D111 = ( D106 -' ( D108 . C207 ) );
set D112 = ( C204 . D111 );
set D113 = D112;
set D114 = D110;
L862: ( D108 . C207 ) <= D106 by L695;
L863: D111 = ( D106 - ( D108 . C207 ) ) by L862 , XREAL_1:233;
L864: D111 < D109 by L863 , L859 , L861 , XREAL_1:15;
L865: D113 c= D114 by L864 , L722;
L866: ( dom D113 ) c= ( dom D114 ) by L865 , RELAT_1:11;
assume L867: C206 in ( dom D112 );
L868: 1 <= ( D108 . C206 ) by L858 , L695;
L869: D109 < D106 by L868 , L861 , XREAL_1:44;
L870: ( C204 .PickedAt D109 ) = C206 by L858 , L774;
thus L871: contradiction by L870 , L869 , L867 , L866 , L606;
end;
begin
definition
let C208 , C209 being set;
let C210 being non  empty set;
let C211 being (Element of [: ( PFuncs (C208 , C209) ) , C210 :]);
redefine func C211 `1 -> (Element of ( PFuncs (C208 , C209) ));

coherence by MCART_1:10;
end;
definition
let C212 , C213 being non  empty set;
let C214 being set;
let C215 being (Element of [: C212 , ( Funcs (C214 , C213) ) :]);
redefine func C215 `2 -> (Element of ( Funcs (C214 , C213) ));

coherence by MCART_1:10;
end;
definition
let C216 being _Graph;
mode LexBFS:Labeling of C216
 is (Element of [: ( PFuncs (( the_Vertices_of C216 ) , ( NAT )) ) , ( Funcs (( the_Vertices_of C216 ) , ( Fin ( NAT ) )) ) :]);
end;
registration
let C217 being  finite _Graph;
let C218 being (LexBFS:Labeling of C217);
cluster ( C218 `1 ) ->  finite;
coherence
proof
L875: ( dom ( C218 `1 ) ) c= ( the_Vertices_of C217 );
thus L876: thesis by L875 , FINSET_1:10;
end;
cluster ( C218 `2 ) ->  finite;
coherence;
end;
definition
let C219 being _Graph;
func LexBFS:Init C219 -> (LexBFS:Labeling of C219) equals 
[ ( {} ) , ( ( the_Vertices_of C219 ) --> ( {} ) ) ];
coherence
proof
set D115 = ( ( the_Vertices_of C219 ) --> ( {} ) );
L878: ( rng ( {} ) ) c= ( NAT );
L879: ( {} ) c= ( NAT );
L880: ( {} ) in ( Fin ( NAT ) ) by L879 , FINSUB_1:def 5;
L881: { ( {} ) } c= ( Fin ( NAT ) ) by L880 , ZFMISC_1:31;
L882: ( rng D115 ) c= ( Fin ( NAT ) ) by L881 , XBOOLE_1:1;
L883: ( dom D115 ) = ( the_Vertices_of C219 ) by FUNCOP_1:13;
L884: D115 in ( Funcs (( the_Vertices_of C219 ) , ( Fin ( NAT ) )) ) by L883 , L882 , FUNCT_2:def 2;
L885: ( dom ( {} ) ) c= ( the_Vertices_of C219 ) by XBOOLE_1:2;
L886: ( {} ) in ( PFuncs (( the_Vertices_of C219 ) , ( NAT )) ) by L885 , L878 , PARTFUN1:def 3;
thus L887: thesis by L886 , L884 , ZFMISC_1:def 2;
end;
end;
definition
let C220 being  finite _Graph;
let C221 being (LexBFS:Labeling of C220);
func LexBFS:PickUnnumbered C221 -> (Vertex of C220) means 
:L889: it = ( choose ( the_Vertices_of C220 ) ) if ( dom ( C221 `1 ) ) = ( the_Vertices_of C220 ) otherwise (ex B177 being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B178 being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex B179 being Function st (B177 = ( rng B179 ) & B179 = ( ( C221 `2 ) | ( ( the_Vertices_of C220 ) \ ( dom ( C221 `1 ) ) ) ) & (for B180 being  finite (Subset of ( NAT )) holds (B180 in B177 implies ( (B180 , 1) -bag ) in B178)) & (for B181 being set holds (B181 in B178 implies (ex B182 being  finite (Subset of ( NAT )) st (B182 in B177 & B181 = ( (B182 , 1) -bag ))))) & it = ( choose ( B179 " { ( support ( max (B178 , ( InvLexOrder ( NAT ) )) ) ) } ) )))));
existence
proof
set D116 = ( the_Vertices_of C220 );
set D117 = ( C221 `2 );
set D118 = ( C221 `1 );
set D119 = ( D117 | ( D116 \ ( dom D118 ) ) );
set D120 = ( rng D119 );
L890: (ex B183 being Function st (( C221 `2 ) = B183 & ( dom B183 ) = D116 & ( rng B183 ) c= ( Fin ( NAT ) ))) by FUNCT_2:def 2;
per cases ;
suppose L891: ( dom D118 ) = D116;

thus L892: thesis by L891;
end;
suppose L893: ( dom D118 ) <> D116;

L894: ( dom D119 ) = ( ( dom D117 ) /\ ( D116 \ ( dom D118 ) ) ) by RELAT_1:61;
L895: ( dom D119 ) = ( ( D116 /\ D116 ) \ ( dom D118 ) ) by L894 , L890 , XBOOLE_1:49;
L896:
now
assume L897: ( dom D119 ) = ( {} );
L898: D116 c= ( dom D118 ) by L897 , L895 , XBOOLE_1:37;
thus L899: contradiction by L898 , L893 , XBOOLE_0:def 10;
end;
L900: (for B184 being set holds (B184 in D120 implies B184 is  finite));
L901: ( rng D119 ) c= ( rng D117 ) by RELAT_1:70;
L902:
now
L903: ( rng D117 ) c= ( bool ( NAT ) )
proof
let C222 being set;
assume L904: C222 in ( rng D117 );
L905: C222 c= ( NAT ) by L904 , FINSUB_1:def 5;
thus L906: thesis by L905;
end;
let C223 being set;
assume that
L907: C223 in D120;
L908: C223 in ( rng D117 ) by L901 , L907;
thus L909: C223 in ( bool ( NAT ) ) by L908 , L903;
thus L910: C223 is  finite by L907;
end;
L911: (for B185 being set holds (B185 in D120 implies B185 in ( bool ( NAT ) ))) by L902;
reconsider D121 = D120 as non  empty  finite  with_finite-elements (Subset of ( bool ( NAT ) )) by L911 , L896 , L900 , FINSET_1:def 6 , RELAT_1:42 , TARSKI:def 3;
deffunc H4( finite (Subset of ( NAT ))) = ( ($1 , 1) -bag );
set D122 = { H4(B186) where B186 is (Element of D121) : B186 in D121 };
consider C224 being set such that L912: C224 in D121 by XBOOLE_0:def 1;
reconsider D123 = C224 as  finite (Subset of ( NAT )) by L912;
L913: ( (D123 , 1) -bag ) in D122 by L912;
L914: D121 is  finite;
L915: D122 is  finite from FRAENKEL:sch 21(L914);
L916:
now
let C225 being set;
assume L917: C225 in D122;
L918: (ex B187 being (Element of D121) st (C225 = ( (B187 , 1) -bag ) & B187 in D121)) by L917;
thus L919: C225 in ( Bags ( NAT ) ) by L918;
end;
reconsider D124 = D122 as non  empty  finite (Subset of ( Bags ( NAT ) )) by L916 , L915 , L913 , TARSKI:def 3;
L920: (for B188 being set holds (B188 in D124 implies (ex B189 being  finite (Subset of ( NAT )) st (B189 in D121 & B188 = ( (B189 , 1) -bag )))))
proof
let C226 being set;
assume L921: C226 in D124;
L922: (ex B190 being (Element of D121) st (C226 = ( (B190 , 1) -bag ) & B190 in D121)) by L921;
thus L923: thesis by L922;
end;
set D125 = ( max (D124 , ( InvLexOrder ( NAT ) )) );
L924: D125 in D124 by L239;
consider C227 being  finite (Subset of ( NAT )) such that L925: C227 in D121 and L926: D125 = ( (C227 , 1) -bag ) by L924 , L920;
set D126 = ( choose ( D119 " { ( support D125 ) } ) );
L927: C227 = ( support D125 ) by L926 , UPROOTS:8;
L928: ( D119 " { ( support D125 ) } ) is non  empty by L927 , L925 , FUNCT_1:72;
L929: D126 in ( dom D119 ) by L928 , FUNCT_1:def 7;
L930: D126 in ( dom D117 ) by L929 , RELAT_1:57;
reconsider D127 = D126 as (Vertex of C220) by L930;
L931: (for B191 being  finite (Subset of ( NAT )) holds (B191 in D121 implies ( (B191 , 1) -bag ) in D124));
L932: (ex B192 being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B193 being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex B194 being Function st (B192 = ( rng B194 ) & B194 = ( D117 | ( D116 \ ( dom D118 ) ) ) & (for B195 being  finite (Subset of ( NAT )) holds (B195 in B192 implies ( (B195 , 1) -bag ) in B193)) & (for B196 being set holds (B196 in B193 implies (ex B197 being  finite (Subset of ( NAT )) st (B197 in B192 & B196 = ( (B197 , 1) -bag ))))) & D127 = ( choose ( B194 " { ( support ( max (B193 , ( InvLexOrder ( NAT ) )) ) ) } ) ) & D127 is (Vertex of C220))))) by L931 , L920;
thus L933: thesis by L932;
end;
end;
uniqueness
proof
let C228 , C229 being (Vertex of C220);
set D128 = ( the_Vertices_of C220 );
set D129 = ( C221 `2 );
set D130 = ( C221 `1 );
thus L935: ((( dom D130 ) = D128 & C228 = ( choose D128 ) & C229 = ( choose D128 )) implies C228 = C229);
assume L936: ( dom D130 ) <> D128;
assume L937: (ex B198 being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B199 being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex B200 being Function st (B198 = ( rng B200 ) & B200 = ( D129 | ( D128 \ ( dom D130 ) ) ) & (for B201 being  finite (Subset of ( NAT )) holds (B201 in B198 implies ( (B201 , 1) -bag ) in B199)) & (for B202 being set holds (B202 in B199 implies (ex B203 being  finite (Subset of ( NAT )) st (B203 in B198 & B202 = ( (B203 , 1) -bag ))))) & C228 = ( choose ( B200 " { ( support ( max (B199 , ( InvLexOrder ( NAT ) )) ) ) } ) )))));
consider C230 being non  empty  finite (Subset of ( bool ( NAT ) )), C231 being non  empty  finite (Subset of ( Bags ( NAT ) )), C232 being Function such that L938: C230 = ( rng C232 ) and L939: C232 = ( D129 | ( D128 \ ( dom D130 ) ) ) and L940: (for B204 being  finite (Subset of ( NAT )) holds (B204 in C230 implies ( (B204 , 1) -bag ) in C231)) and L941: (for B205 being set holds (B205 in C231 implies (ex B206 being  finite (Subset of ( NAT )) st (B206 in C230 & B205 = ( (B206 , 1) -bag ))))) and L942: C228 = ( choose ( C232 " { ( support ( max (C231 , ( InvLexOrder ( NAT ) )) ) ) } ) ) by L937;
assume L943: (ex B207 being non  empty  finite (Subset of ( bool ( NAT ) )) st (ex B208 being non  empty  finite (Subset of ( Bags ( NAT ) )) st (ex B209 being Function st (B207 = ( rng B209 ) & B209 = ( D129 | ( D128 \ ( dom D130 ) ) ) & (for B210 being  finite (Subset of ( NAT )) holds (B210 in B207 implies ( (B210 , 1) -bag ) in B208)) & (for B211 being set holds (B211 in B208 implies (ex B212 being  finite (Subset of ( NAT )) st (B212 in B207 & B211 = ( (B212 , 1) -bag ))))) & C229 = ( choose ( B209 " { ( support ( max (B208 , ( InvLexOrder ( NAT ) )) ) ) } ) )))));
consider C233 being non  empty  finite (Subset of ( bool ( NAT ) )), C234 being non  empty  finite (Subset of ( Bags ( NAT ) )), C235 being Function such that L944: C233 = ( rng C235 ) and L945: C235 = ( D129 | ( D128 \ ( dom D130 ) ) ) and L946: (for B213 being  finite (Subset of ( NAT )) holds (B213 in C233 implies ( (B213 , 1) -bag ) in C234)) and L947: (for B214 being set holds (B214 in C234 implies (ex B215 being  finite (Subset of ( NAT )) st (B215 in C233 & B214 = ( (B215 , 1) -bag ))))) and L948: C229 = ( choose ( C235 " { ( support ( max (C234 , ( InvLexOrder ( NAT ) )) ) ) } ) ) by L943;
L949:
now
let C236 being set;
assume L950: C236 in C234;
L951: (ex B216 being  finite (Subset of ( NAT )) st (B216 in C233 & C236 = ( (B216 , 1) -bag ))) by L950 , L947;
thus L952: C236 in C231 by L951 , L938 , L939 , L940 , L944 , L945;
end;
L953: C234 c= C231 by L949 , TARSKI:def 3;
L954:
now
let C237 being set;
assume L955: C237 in C231;
L956: (ex B217 being  finite (Subset of ( NAT )) st (B217 in C230 & C237 = ( (B217 , 1) -bag ))) by L955 , L941;
thus L957: C237 in C234 by L956 , L938 , L939 , L944 , L945 , L946;
end;
L958: C231 c= C234 by L954 , TARSKI:def 3;
thus L959: thesis by L958 , L939 , L942 , L945 , L948 , L953 , XBOOLE_0:def 10;
end;
consistency;
end;
definition
let C238 being  finite _Graph;
let C239 being (LexBFS:Labeling of C238);
let C240 being (Vertex of C238);
let C241 being Nat;
func LexBFS:Update (C239 , C240 , C241) -> (LexBFS:Labeling of C238) equals 
[ ( ( C239 `1 ) +* ( C240 .--> ( ( C238 .order() ) -' C241 ) ) ) , ( ( C239 `2 ) .\/ ( ( ( C238 .AdjacentSet { C240 } ) \ ( dom ( C239 `1 ) ) ) --> { ( ( C238 .order() ) -' C241 ) } ) ) ];
coherence
proof
set D131 = ( ( ( C238 .AdjacentSet { C240 } ) \ ( dom ( C239 `1 ) ) ) --> { ( ( C238 .order() ) -' C241 ) } );
reconsider D132 = ( ( C238 .order() ) -' C241 ) as (Element of ( NAT ));
set D133 = ( ( C239 `2 ) .\/ ( ( ( C238 .AdjacentSet { C240 } ) \ ( dom ( C239 `1 ) ) ) --> { ( ( C238 .order() ) -' C241 ) } ) );
set D134 = ( C240 .--> ( ( C238 .order() ) -' C241 ) );
set D135 = ( ( C239 `1 ) +* D134 );
L961: ( dom D134 ) = { C240 } by FUNCOP_1:13;
L962: ( rng D134 ) c= { ( ( C238 .order() ) -' C241 ) } by FUNCOP_1:13;
L963: ( rng D134 ) c= ( NAT ) by L962 , XBOOLE_1:1;
L964: ( ( rng ( C239 `1 ) ) \/ ( rng D134 ) ) c= ( NAT ) by L963 , XBOOLE_1:8;
L965: ( rng D135 ) c= ( ( rng ( C239 `1 ) ) \/ ( rng D134 ) ) by FUNCT_4:17;
L966: ( rng D135 ) c= ( NAT ) by L965 , L964 , XBOOLE_1:1;
L967: ( dom D135 ) = ( ( dom ( C239 `1 ) ) \/ ( dom D134 ) ) by FUNCT_4:def 1;
L968: ( dom D135 ) c= ( the_Vertices_of C238 ) by L967 , L961 , XBOOLE_1:8;
L969: D135 in ( PFuncs (( the_Vertices_of C238 ) , ( NAT )) ) by L968 , L966 , PARTFUN1:def 3;
L970: { D132 } in ( Fin ( NAT ) ) by FINSUB_1:def 5;
L971: { { D132 } } c= ( Fin ( NAT ) ) by L970 , ZFMISC_1:31;
consider C242 being Function such that L972: ( C239 `2 ) = C242 and L973: ( dom C242 ) = ( the_Vertices_of C238 ) and L974: ( rng C242 ) c= ( Fin ( NAT ) ) by FUNCT_2:def 2;
L975: ( rng D131 ) c= { { D132 } } by FUNCOP_1:13;
L976: ( rng D131 ) c= ( Fin ( NAT ) ) by L975 , L971 , XBOOLE_1:1;
L977: ( dom D133 ) = ( ( dom C242 ) \/ ( dom D131 ) ) by L972 , L83;
L978: ( rng D133 ) c= ( Fin ( NAT ) )
proof
let C243 being set;
assume L979: C243 in ( rng D133 );
consider C244 being set such that L980: C244 in ( dom D133 ) and L981: C243 = ( D133 . C244 ) by L979 , FUNCT_1:def 3;
L982: C243 = ( ( C242 . C244 ) \/ ( D131 . C244 ) ) by L972 , L980 , L981 , L83 , L977;
per cases  by L980 , L977 , XBOOLE_0:def 3;
suppose that L983: C244 in ( dom C242 )
and
L984: (not C244 in ( dom D131 ));
L985: ( D131 . C244 ) = ( {} ) by L984 , FUNCT_1:def 2;
L986: ( C242 . C244 ) in ( rng C242 ) by L983 , FUNCT_1:3;
thus L987: thesis by L986 , L974 , L982 , L985;
end;
suppose that L988: (not C244 in ( dom C242 ))
and
L989: C244 in ( dom D131 );
L990: ( C242 . C244 ) = ( {} ) by L988 , FUNCT_1:def 2;
L991: ( D131 . C244 ) in ( rng D131 ) by L989 , FUNCT_1:3;
thus L992: thesis by L991 , L976 , L982 , L990;
end;
suppose that L993: C244 in ( dom C242 )
and
L994: C244 in ( dom D131 );
L995: ( D131 . C244 ) in ( rng D131 ) by L994 , FUNCT_1:3;
L996: ( C242 . C244 ) in ( rng C242 ) by L993 , FUNCT_1:3;
thus L997: thesis by L996 , L974 , L976 , L982 , L995 , FINSUB_1:def 1;
end;
end;
L999: ( dom D131 ) = ( ( C238 .AdjacentSet { C240 } ) \ ( dom ( C239 `1 ) ) ) by FUNCOP_1:13;
L1000: ( dom D131 ) c= ( the_Vertices_of C238 ) by L999;
L1001: ( dom D133 ) = ( ( dom C242 ) \/ ( dom D131 ) ) by L977;
L1002: ( dom D133 ) = ( the_Vertices_of C238 ) by L1001 , L973 , L1000 , XBOOLE_1:12;
L1003: D133 in ( Funcs (( the_Vertices_of C238 ) , ( Fin ( NAT ) )) ) by L1002 , L978 , FUNCT_2:def 2;
thus L1004: thesis by L1003 , L969 , ZFMISC_1:def 2;
end;
end;
theorem
L1006: (for B218 being  finite _Graph holds (for B219 being (LexBFS:Labeling of B218) holds (for B220 being (Vertex of B218) holds (for B221 being set holds (for B222 being Nat holds ((not B221 in ( B218 .AdjacentSet { B220 } )) implies ( ( B219 `2 ) . B221 ) = ( ( ( LexBFS:Update (B219 , B220 , B222) ) `2 ) . B221 )))))))
proof
let C245 being  finite _Graph;
let C246 being (LexBFS:Labeling of C245);
let C247 being (Vertex of C245);
let C248 being set;
let C249 being Nat;
assume that
L1007: (not C248 in ( C245 .AdjacentSet { C247 } ));
set D136 = ( ( ( C245 .AdjacentSet { C247 } ) \ ( dom ( C246 `1 ) ) ) --> { ( ( C245 .order() ) -' C249 ) } );
L1008: (not C248 in ( dom D136 )) by L1007 , XBOOLE_0:def 5;
L1009: ( D136 . C248 ) = ( {} ) by L1008 , FUNCT_1:def 2;
set D137 = ( ( LexBFS:Update (C246 , C247 , C249) ) `2 );
L1010: D137 = ( ( C246 `2 ) .\/ D136 ) by MCART_1:7;
per cases ;
suppose L1011: C248 in ( dom ( C246 `2 ) );

L1012: C248 in ( ( dom ( C246 `2 ) ) \/ ( dom D136 ) ) by L1011 , XBOOLE_0:def 3;
thus L1013: ( D137 . C248 ) = ( ( ( C246 `2 ) . C248 ) \/ ( D136 . C248 ) ) by L1012 , L1010 , L83
.= ( ( C246 `2 ) . C248 ) by L1009;
end;
suppose L1014: (not C248 in ( dom ( C246 `2 ) ));

L1015: (not C248 in ( ( dom ( C246 `2 ) ) \/ ( dom D136 ) )) by L1014 , L1008 , XBOOLE_0:def 3;
L1016: (not C248 in ( dom D137 )) by L1015 , L1010 , L83;
thus L1017: ( D137 . C248 ) = ( {} ) by L1016 , FUNCT_1:def 2
.= ( ( C246 `2 ) . C248 ) by L1014 , FUNCT_1:def 2;
end;
end;
theorem
L1019: (for B223 being  finite _Graph holds (for B224 being (LexBFS:Labeling of B223) holds (for B225 being (Vertex of B223) holds (for B226 being set holds (for B227 being Nat holds (B226 in ( dom ( B224 `1 ) ) implies ( ( ( LexBFS:Update (B224 , B225 , B227) ) `2 ) . B226 ) = ( ( B224 `2 ) . B226 )))))))
proof
let C250 being  finite _Graph;
let C251 being (LexBFS:Labeling of C250);
let C252 being (Vertex of C250);
let C253 being set;
let C254 being Nat;
assume that
L1020: C253 in ( dom ( C251 `1 ) );
set D138 = ( ( ( C250 .AdjacentSet { C252 } ) \ ( dom ( C251 `1 ) ) ) --> { ( ( C250 .order() ) -' C254 ) } );
L1021: (not C253 in ( dom D138 )) by L1020 , XBOOLE_0:def 5;
L1022: ( D138 . C253 ) = ( {} ) by L1021 , FUNCT_1:def 2;
set D139 = ( ( LexBFS:Update (C251 , C252 , C254) ) `2 );
L1023: D139 = ( ( C251 `2 ) .\/ D138 ) by MCART_1:7;
per cases ;
suppose L1024: C253 in ( dom ( C251 `2 ) );

L1025: C253 in ( ( dom ( C251 `2 ) ) \/ ( dom D138 ) ) by L1024 , XBOOLE_0:def 3;
thus L1026: ( D139 . C253 ) = ( ( ( C251 `2 ) . C253 ) \/ ( D138 . C253 ) ) by L1025 , L1023 , L83
.= ( ( C251 `2 ) . C253 ) by L1022;
end;
suppose L1027: (not C253 in ( dom ( C251 `2 ) ));

L1028: (not C253 in ( ( dom ( C251 `2 ) ) \/ ( dom D138 ) )) by L1027 , L1021 , XBOOLE_0:def 3;
L1029: (not C253 in ( dom D139 )) by L1028 , L1023 , L83;
thus L1030: ( D139 . C253 ) = ( {} ) by L1029 , FUNCT_1:def 2
.= ( ( C251 `2 ) . C253 ) by L1027 , FUNCT_1:def 2;
end;
end;
theorem
L1032: (for B228 being  finite _Graph holds (for B229 being (LexBFS:Labeling of B228) holds (for B230 being (Vertex of B228) holds (for B231 being set holds (for B232 being Nat holds ((B231 in ( B228 .AdjacentSet { B230 } ) & (not B231 in ( dom ( B229 `1 ) ))) implies ( ( ( LexBFS:Update (B229 , B230 , B232) ) `2 ) . B231 ) = ( ( ( B229 `2 ) . B231 ) \/ { ( ( B228 .order() ) -' B232 ) } )))))))
proof
let C255 being  finite _Graph;
let C256 being (LexBFS:Labeling of C255);
let C257 being (Vertex of C255);
let C258 being set;
let C259 being Nat;
assume that
L1033: C258 in ( C255 .AdjacentSet { C257 } )
and
L1034: (not C258 in ( dom ( C256 `1 ) ));
L1035: C258 in ( ( C255 .AdjacentSet { C257 } ) \ ( dom ( C256 `1 ) ) ) by L1033 , L1034 , XBOOLE_0:def 5;
L1036: C258 in ( dom ( ( ( C255 .AdjacentSet { C257 } ) \ ( dom ( C256 `1 ) ) ) --> { ( ( C255 .order() ) -' C259 ) } ) ) by L1035 , FUNCOP_1:13;
L1037: C258 in ( ( dom ( C256 `2 ) ) \/ ( dom ( ( ( C255 .AdjacentSet { C257 } ) \ ( dom ( C256 `1 ) ) ) --> { ( ( C255 .order() ) -' C259 ) } ) ) ) by L1036 , XBOOLE_0:def 3;
set D140 = ( ( LexBFS:Update (C256 , C257 , C259) ) `2 );
L1038: D140 = ( ( C256 `2 ) .\/ ( ( ( C255 .AdjacentSet { C257 } ) \ ( dom ( C256 `1 ) ) ) --> { ( ( C255 .order() ) -' C259 ) } ) ) by MCART_1:7;
L1039: ( ( ( ( C255 .AdjacentSet { C257 } ) \ ( dom ( C256 `1 ) ) ) --> { ( ( C255 .order() ) -' C259 ) } ) . C258 ) = { ( ( C255 .order() ) -' C259 ) } by L1035 , FUNCOP_1:7;
thus L1040: thesis by L1039 , L1038 , L1037 , L83;
end;
definition
let C260 being  finite _Graph;
let C261 being (LexBFS:Labeling of C260);
func LexBFS:Step C261 -> (LexBFS:Labeling of C260) equals 
:L1041: C261 if ( C260 .order() ) <= ( card ( dom ( C261 `1 ) ) ) otherwise ( LexBFS:Update (C261 , ( LexBFS:PickUnnumbered C261 ) , ( card ( dom ( C261 `1 ) ) )) );
coherence;
consistency;
end;
definition
let C262 being _Graph;
mode LexBFS:LabelingSeq of C262
 -> (ManySortedSet of ( NAT ))
means :L1043: (for B233 being Nat holds ( it . B233 ) is (LexBFS:Labeling of C262));
existence
proof
set D141 = the (LexBFS:Labeling of C262);
deffunc H5(set) = D141;
consider C263 being (ManySortedSet of ( NAT )) such that L1044: (for B234 being set holds (B234 in ( NAT ) implies ( C263 . B234 ) = H5(B234))) from PBOOLE:sch 4;
take C263;
let C264 being Nat;
L1045: C264 in ( NAT ) by ORDINAL1:def 12;
thus L1046: thesis by L1045 , L1044;
end;
end;
definition
let C265 being _Graph;
let C266 being (LexBFS:LabelingSeq of C265);
let C267 being Nat;
redefine func C266 . C267 -> (LexBFS:Labeling of C265);

coherence by L1043;
end;
definition
let C268 being _Graph;
let C269 being (LexBFS:LabelingSeq of C268);
redefine func C269 .Result() -> (LexBFS:Labeling of C268);

coherence by L1043;
end;
definition
let C270 being  finite _Graph;
let C271 being (LexBFS:LabelingSeq of C270);
func C271 ``1 -> (preVNumberingSeq of C270) means 
:L1050: (for B235 being Nat holds ( it . B235 ) = ( ( C271 . B235 ) `1 ));
existence
proof
deffunc H6(set) = ( ( C271 . $1 ) `1 );
consider C272 being (ManySortedSet of ( NAT )) such that L1051: (for B236 being set holds (B236 in ( NAT ) implies ( C272 . B236 ) = H6(B236))) from PBOOLE:sch 4;
L1052:
now
let C273 being Nat;
L1053: C273 in ( NAT ) by ORDINAL1:def 12;
L1054: ( C272 . C273 ) = ( ( C271 . C273 ) `1 ) by L1053 , L1051;
thus L1055: ( C272 . C273 ) is (PartFunc of ( the_Vertices_of C270 ) , ( NAT )) by L1054;
end;
reconsider D142 = C272 as (preVNumberingSeq of C270) by L1052 , L396;
take D142;
let C274 being Nat;
L1056: C274 in ( NAT ) by ORDINAL1:def 12;
thus L1057: thesis by L1056 , L1051;
end;
uniqueness
proof
let C275 , C276 being (preVNumberingSeq of C270);
assume that
L1058: (for B237 being Nat holds ( C275 . B237 ) = ( ( C271 . B237 ) `1 ))
and
L1059: (for B238 being Nat holds ( C276 . B238 ) = ( ( C271 . B238 ) `1 ));
L1060:
now
let C277 being set;
assume L1061: C277 in ( NAT );
reconsider D143 = C277 as Nat by L1061;
thus L1062: ( C275 . C277 ) = ( ( C271 . D143 ) `1 ) by L1058
.= ( C276 . C277 ) by L1059;
end;
thus L1063: C275 = C276 by L1060 , PBOOLE:3;
end;
end;
definition
let C278 being  finite _Graph;
func LexBFS:CSeq C278 -> (LexBFS:LabelingSeq of C278) means 
:L1065: (( it . ( 0 ) ) = ( LexBFS:Init C278 ) & (for B239 being Nat holds ( it . ( B239 + 1 ) ) = ( LexBFS:Step ( it . B239 ) )));
existence
proof
defpred S11[ (Element of ( NAT )) , set , set ] means (($2 is (LexBFS:Labeling of C278) implies (ex B240 being (LexBFS:Labeling of C278) st ($2 = B240 & $3 = ( LexBFS:Step B240 )))) & ((not $2 is (LexBFS:Labeling of C278)) implies $3 = $2));
L1066:
now
let C279 being (Element of ( NAT ));
let C280 being set;
L1067:
now
per cases ;
suppose L1068: C280 is (LexBFS:Labeling of C278);

reconsider D144 = C280 as (LexBFS:Labeling of C278) by L1068;
L1069: ( LexBFS:Step D144 ) = ( LexBFS:Step D144 );
thus L1070: (ex B241 being set st S11[ C279 , C280 , B241 ]) by L1069;
end;
suppose L1071: (not C280 is (LexBFS:Labeling of C278));

thus L1072: (ex B242 being set st S11[ C279 , C280 , B242 ]) by L1071;
end;
end;
thus L1074: (ex B243 being set st S11[ C279 , C280 , B243 ]) by L1067;
end;
L1075: (for B244 being (Element of ( NAT )) holds (for B245 being set holds (ex B246 being set st S11[ B244 , B245 , B246 ]))) by L1066;
consider C281 being Function such that L1076: (( dom C281 ) = ( NAT ) & ( C281 . ( 0 ) ) = ( LexBFS:Init C278 ) & (for B247 being (Element of ( NAT )) holds S11[ B247 , ( C281 . B247 ) , ( C281 . ( B247 + 1 ) ) ])) from RECDEF_1:sch 1(L1075);
reconsider D145 = C281 as (ManySortedSet of ( NAT )) by L1076 , PARTFUN1:def 2 , RELAT_1:def 18;
defpred S12[ Nat ] means ( D145 . $1 ) is (LexBFS:Labeling of C278);
L1077:
now
let C282 being Nat;
assume L1078: S12[ C282 ];
L1079: C282 in ( NAT ) by ORDINAL1:def 12;
L1080: (ex B248 being (LexBFS:Labeling of C278) st (( D145 . C282 ) = B248 & ( D145 . ( C282 + 1 ) ) = ( LexBFS:Step B248 ))) by L1079 , L1076 , L1078;
thus L1081: S12[ ( C282 + 1 ) ] by L1080;
end;
L1082: S12[ ( 0 ) ] by L1076;
L1083: (for B249 being Nat holds S12[ B249 ]) from NAT_1:sch 2(L1082 , L1077);
reconsider D146 = D145 as (LexBFS:LabelingSeq of C278) by L1083 , L1043;
take D146;
thus L1084: ( D146 . ( 0 ) ) = ( LexBFS:Init C278 ) by L1076;
let C283 being Nat;
L1085: C283 in ( NAT ) by ORDINAL1:def 12;
L1086: (ex B250 being (LexBFS:Labeling of C278) st (( D146 . C283 ) = B250 & ( D146 . ( C283 + 1 ) ) = ( LexBFS:Step B250 ))) by L1085 , L1076;
thus L1087: thesis by L1086;
end;
uniqueness
proof
let C284 , C285 being (LexBFS:LabelingSeq of C278);
assume that
L1088: ( C284 . ( 0 ) ) = ( LexBFS:Init C278 )
and
L1089: (for B251 being Nat holds ( C284 . ( B251 + 1 ) ) = ( LexBFS:Step ( C284 . B251 ) ))
and
L1090: ( C285 . ( 0 ) ) = ( LexBFS:Init C278 )
and
L1091: (for B252 being Nat holds ( C285 . ( B252 + 1 ) ) = ( LexBFS:Step ( C285 . B252 ) ));
defpred S13[ Nat ] means ( C284 . $1 ) = ( C285 . $1 );
L1092:
now
let C286 being Nat;
assume L1093: S13[ C286 ];
L1094: ( C284 . ( C286 + 1 ) ) = ( LexBFS:Step ( C285 . C286 ) ) by L1093 , L1089
.= ( C285 . ( C286 + 1 ) ) by L1091;
thus L1095: S13[ ( C286 + 1 ) ] by L1094;
end;
L1096: (for B253 being (Element of ( NAT )) holds (S13[ B253 ] implies S13[ ( B253 + 1 ) ])) by L1092;
L1097: S13[ ( 0 ) ] by L1088 , L1090;
L1098: (for B254 being (Element of ( NAT )) holds S13[ B254 ]) from NAT_1:sch 1(L1097 , L1096);
L1099: (for B255 being set holds (B255 in ( NAT ) implies ( C284 . B255 ) = ( C285 . B255 ))) by L1098;
thus L1100: C284 = C285 by L1099 , PBOOLE:3;
end;
end;
theorem
L1102: (for B256 being  finite _Graph holds ( LexBFS:CSeq B256 ) is  iterative)
proof
let C287 being  finite _Graph;
set D147 = ( LexBFS:CSeq C287 );
let C288 , C289 being Nat;
assume that
L1103: ( D147 . C288 ) = ( D147 . C289 );
L1104: ( D147 . ( C288 + 1 ) ) = ( LexBFS:Step ( D147 . C288 ) ) by L1065;
thus L1105: ( D147 . ( C288 + 1 ) ) = ( D147 . ( C289 + 1 ) ) by L1104 , L1103 , L1065;
end;
registration
let C290 being  finite _Graph;
cluster ( LexBFS:CSeq C290 ) ->  iterative;
coherence by L1102;
end;
L1107: (for B257 being _Graph holds (for B258 being set holds (( dom ( ( LexBFS:Init B257 ) `2 ) ) = ( the_Vertices_of B257 ) & ( ( ( LexBFS:Init B257 ) `2 ) . B258 ) = ( {} ))))
proof
let C291 being _Graph;
let C292 being set;
set D148 = ( ( the_Vertices_of C291 ) --> ( {} ) );
set D149 = D148;
thus L1108: ( dom ( ( LexBFS:Init C291 ) `2 ) ) = ( the_Vertices_of C291 ) by FUNCT_2:def 1;
L1109:
now
let C293 being set;
per cases ;
suppose L1110: C293 in ( dom D149 );

thus L1111: ( D149 . C293 ) = ( {} ) by L1110 , FUNCOP_1:7;
end;
suppose L1112: (not C293 in ( dom D149 ));

thus L1113: ( D149 . C293 ) = ( {} ) by L1112 , FUNCT_1:def 2;
end;
end;
L1115: ( ( LexBFS:Init C291 ) `2 ) = D148 by MCART_1:7;
thus L1116: thesis by L1115 , L1109;
end;
definition
let C294 , C295 being set;
let C296 being (Function of C294 , ( Fin C295 ));
let C297 being set;
redefine func C296 . C297 ->  finite (Subset of C295);

coherence
proof
L1117: ( dom C296 ) = C294 by FUNCT_2:def 1;
per cases ;
suppose L1118: C297 in C294;

L1119: ( C296 . C297 ) in ( Fin C295 ) by L1118 , FUNCT_2:5;
thus L1120: thesis by L1119 , FINSUB_1:def 5;
end;
suppose L1121: (not C297 in C294);

L1122: ( C296 . C297 ) = ( {} ) by L1121 , L1117 , FUNCT_1:def 2;
thus L1123: thesis by L1122 , XBOOLE_1:2;
end;
end;
end;
theorem
L1126: (for B259 being  finite _Graph holds (for B260 being (LexBFS:Labeling of B259) holds (for B261 being set holds (((not B261 in ( dom ( B260 `1 ) )) & ( dom ( B260 `1 ) ) <> ( the_Vertices_of B259 )) implies ( (( ( B260 `2 ) . B261 ) , 1) -bag ) <= ( (( ( B260 `2 ) . ( LexBFS:PickUnnumbered B260 ) ) , 1) -bag ) , ( InvLexOrder ( NAT ) )))))
proof
let C298 being  finite _Graph;
let C299 being (LexBFS:Labeling of C298);
let C300 being set;
assume that
L1127: (not C300 in ( dom ( C299 `1 ) ))
and
L1128: ( dom ( C299 `1 ) ) <> ( the_Vertices_of C298 );
set D150 = ( the_Vertices_of C298 );
set D151 = ( C299 `2 );
set D152 = ( C299 `1 );
set D153 = ( LexBFS:PickUnnumbered C299 );
consider C301 being non  empty  finite (Subset of ( bool ( NAT ) )), C302 being non  empty  finite (Subset of ( Bags ( NAT ) )), C303 being Function such that L1129: C301 = ( rng C303 ) and L1130: C303 = ( D151 | ( D150 \ ( dom D152 ) ) ) and L1131: (for B262 being  finite (Subset of ( NAT )) holds (B262 in C301 implies ( (B262 , 1) -bag ) in C302)) and L1132: (for B263 being set holds (B263 in C302 implies (ex B264 being  finite (Subset of ( NAT )) st (B264 in C301 & B263 = ( (B264 , 1) -bag ))))) and L1133: D153 = ( choose ( C303 " { ( support ( max (C302 , ( InvLexOrder ( NAT ) )) ) ) } ) ) by L1128 , L889;
L1134: ( dom C303 ) = ( ( dom D151 ) /\ ( D150 \ ( dom D152 ) ) ) by L1130 , RELAT_1:61;
set D154 = ( max (C302 , ( InvLexOrder ( NAT ) )) );
L1135: D154 in C302 by L239;
consider C304 being  finite (Subset of ( NAT )) such that L1136: C304 in C301 and L1137: D154 = ( (C304 , 1) -bag ) by L1135 , L1132;
L1138: C304 = ( support D154 ) by L1137 , UPROOTS:8;
L1139: ( C303 " { ( support D154 ) } ) is non  empty by L1138 , L1129 , L1136 , FUNCT_1:72;
L1140: D153 in ( dom C303 ) by L1139 , L1133 , FUNCT_1:def 7;
L1141: ( D151 . D153 ) = ( C303 . D153 ) by L1140 , L1130 , FUNCT_1:47;
L1142: ( C303 . D153 ) in { ( support D154 ) } by L1133 , L1139 , FUNCT_1:def 7;
L1143: ( (( D151 . D153 ) , 1) -bag ) = D154 by L1142 , L1137 , L1138 , L1141 , TARSKI:def 1;
L1144: ( dom D151 ) = ( the_Vertices_of C298 ) by FUNCT_2:def 1;
per cases ;
suppose L1145: C300 in ( the_Vertices_of C298 );

L1146: C300 in ( D150 \ ( dom D152 ) ) by L1145 , L1127 , XBOOLE_0:def 5;
L1147: C300 in ( dom C303 ) by L1146 , L1144 , L1134 , XBOOLE_0:def 4;
L1148: ( C303 . C300 ) in C301 by L1147 , L1129 , FUNCT_1:def 3;
L1149: ( C303 . C300 ) = ( D151 . C300 ) by L1130 , L1147 , FUNCT_1:47;
L1150: ( (( D151 . C300 ) , 1) -bag ) in C302 by L1149 , L1131 , L1148;
thus L1151: thesis by L1150 , L1143 , L239;
end;
suppose L1152: (not C300 in ( the_Vertices_of C298 ));

L1153: ( D151 . C300 ) = ( {} ) by L1152 , L1144 , FUNCT_1:def 2;
L1154: ( (( D151 . C300 ) , 1) -bag ) = ( EmptyBag ( NAT ) ) by L1153 , UPROOTS:9;
thus L1155: thesis by L1154 , TERMORD:9;
end;
end;
theorem
L1157: (for B265 being  finite _Graph holds (for B266 being (LexBFS:Labeling of B265) holds (( dom ( B266 `1 ) ) <> ( the_Vertices_of B265 ) implies (not ( LexBFS:PickUnnumbered B266 ) in ( dom ( B266 `1 ) )))))
proof
let C305 being  finite _Graph;
let C306 being (LexBFS:Labeling of C305);
assume that
L1158: ( dom ( C306 `1 ) ) <> ( the_Vertices_of C305 );
set D155 = ( the_Vertices_of C305 );
set D156 = ( C306 `2 );
set D157 = ( C306 `1 );
set D158 = ( LexBFS:PickUnnumbered C306 );
consider C307 being non  empty  finite (Subset of ( bool ( NAT ) )), C308 being non  empty  finite (Subset of ( Bags ( NAT ) )), C309 being Function such that L1159: C307 = ( rng C309 ) and L1160: C309 = ( D156 | ( D155 \ ( dom D157 ) ) ) and L1161: (for B267 being  finite (Subset of ( NAT )) holds (B267 in C307 implies ( (B267 , 1) -bag ) in C308)) and L1162: (for B268 being set holds (B268 in C308 implies (ex B269 being  finite (Subset of ( NAT )) st (B269 in C307 & B268 = ( (B269 , 1) -bag ))))) and L1163: D158 = ( choose ( C309 " { ( support ( max (C308 , ( InvLexOrder ( NAT ) )) ) ) } ) ) by L1158 , L889;
set D159 = ( max (C308 , ( InvLexOrder ( NAT ) )) );
L1164: D159 in C308 by L239;
consider C310 being  finite (Subset of ( NAT )) such that L1165: C310 in C307 and L1166: D159 = ( (C310 , 1) -bag ) by L1164 , L1162;
L1167: C310 = ( support D159 ) by L1166 , UPROOTS:8;
L1168: ( C309 " { ( support D159 ) } ) is non  empty by L1167 , L1159 , L1165 , FUNCT_1:72;
L1169: D158 in ( dom C309 ) by L1168 , L1163 , FUNCT_1:def 7;
assume L1170: D158 in ( dom D157 );
L1171: (not D158 in ( D155 \ ( dom D157 ) )) by L1170 , XBOOLE_0:def 5;
L1172: ( dom C309 ) = ( ( dom D156 ) /\ ( D155 \ ( dom D157 ) ) ) by L1160 , RELAT_1:61;
thus L1173: contradiction by L1172 , L1169 , L1171 , XBOOLE_0:def 4;
end;
theorem
L1174: (for B270 being  finite _Graph holds (for B271 being Nat holds (( card ( dom ( ( ( LexBFS:CSeq B270 ) . B271 ) `1 ) ) ) < ( B270 .order() ) implies ( ( ( LexBFS:CSeq B270 ) . ( B271 + 1 ) ) `1 ) = ( ( ( ( LexBFS:CSeq B270 ) . B271 ) `1 ) +* ( ( LexBFS:PickUnnumbered ( ( LexBFS:CSeq B270 ) . B271 ) ) .--> ( ( B270 .order() ) -' ( card ( dom ( ( ( LexBFS:CSeq B270 ) . B271 ) `1 ) ) ) ) ) ))))
proof
let C311 being  finite _Graph;
let C312 being Nat;
set D160 = ( LexBFS:CSeq C311 );
assume L1175: ( card ( dom ( ( D160 . C312 ) `1 ) ) ) < ( C311 .order() );
set D161 = ( D160 . ( C312 + 1 ) );
set D162 = ( D160 . C312 );
set D163 = ( D162 `1 );
set D164 = ( LexBFS:PickUnnumbered D162 );
L1176: D161 = ( LexBFS:Step D162 ) by L1065;
L1177: D161 = ( LexBFS:Update (D162 , D164 , ( card ( dom D163 ) )) ) by L1176 , L1175 , L1041;
thus L1178: thesis by L1177 , MCART_1:7;
end;
theorem
L1179: (for B272 being  finite _Graph holds (for B273 being Nat holds (B273 <= ( B272 .order() ) implies ( card ( dom ( ( ( LexBFS:CSeq B272 ) . B273 ) `1 ) ) ) = B273)))
proof
let C313 being  finite _Graph;
let C314 being Nat;
assume that
L1180: C314 <= ( C313 .order() );
set D165 = ( LexBFS:CSeq C313 );
defpred S14[ Nat ] means ($1 <= ( C313 .order() ) implies ( card ( dom ( ( D165 . $1 ) `1 ) ) ) = $1);
L1181: (for B274 being Nat holds ((B274 < ( C313 .order() ) & ( card ( dom ( ( D165 . B274 ) `1 ) ) ) = B274) implies ( card ( dom ( ( D165 . ( B274 + 1 ) ) `1 ) ) ) = ( B274 + 1 )))
proof
let C315 being Nat;
assume that
L1182: C315 < ( C313 .order() )
and
L1183: ( card ( dom ( ( D165 . C315 ) `1 ) ) ) = C315;
set D166 = ( D165 . ( C315 + 1 ) );
set D167 = ( D165 . C315 );
set D168 = ( D167 `1 );
set D169 = ( D166 `1 );
set D170 = ( LexBFS:PickUnnumbered D167 );
set D171 = ( D170 .--> ( ( C313 .order() ) -' C315 ) );
L1184: ( dom D171 ) = { D170 } by FUNCOP_1:13;
L1185: D169 = ( D168 +* ( D170 .--> ( ( C313 .order() ) -' C315 ) ) ) by L1182 , L1183 , L1174;
L1186: ( dom D169 ) = ( ( dom D168 ) \/ { D170 } ) by L1185 , L1184 , FUNCT_4:def 1;
thus L1187: thesis by L1186 , L1182 , L1183 , L1157 , CARD_2:41;
end;
L1188: (for B275 being Nat holds (S14[ B275 ] implies S14[ ( B275 + 1 ) ]))
proof
let C316 being Nat;
assume that
L1189: S14[ C316 ];
per cases ;
suppose L1190: C316 < ( C313 .order() );

thus L1191: thesis by L1190 , L1181 , L1189;
end;
suppose L1192: C316 >= ( C313 .order() );

thus L1193: thesis by L1192 , NAT_1:13;
end;
end;
L1195: ( D165 . ( 0 ) ) = ( LexBFS:Init C313 ) by L1065;
L1196: S14[ ( 0 ) ] by L1195 , CARD_1:27 , MCART_1:7 , RELAT_1:38;
L1197: (for B276 being Nat holds S14[ B276 ]) from NAT_1:sch 2(L1196 , L1188);
thus L1198: thesis by L1197 , L1180;
end;
theorem
L1199: (for B277 being  finite _Graph holds (for B278 being Nat holds (( B277 .order() ) <= B278 implies ( ( LexBFS:CSeq B277 ) . ( B277 .order() ) ) = ( ( LexBFS:CSeq B277 ) . B278 ))))
proof
let C317 being  finite _Graph;
let C318 being Nat;
assume L1200: ( C317 .order() ) <= C318;
L1201: (ex B279 being Nat st ( ( C317 .order() ) + B279 ) = C318) by L1200 , NAT_1:10;
set D172 = ( LexBFS:CSeq C317 );
defpred S15[ Nat ] means ( C317 .order() ) = ( card ( dom ( ( D172 . ( ( C317 .order() ) + $1 ) ) `1 ) ) );
defpred S16[ Nat ] means ( D172 . ( C317 .order() ) ) = ( D172 . ( ( C317 .order() ) + $1 ) );
L1202: (for B280 being Nat holds (S15[ B280 ] implies S15[ ( B280 + 1 ) ]))
proof
let C319 being Nat;
assume that
L1203: S15[ C319 ];
set D173 = ( D172 . ( ( ( C317 .order() ) + C319 ) + 1 ) );
set D174 = ( D172 . ( ( C317 .order() ) + C319 ) );
L1204: D173 = ( LexBFS:Step D174 ) by L1065;
thus L1205: thesis by L1204 , L1203 , L1041;
end;
L1206: S15[ ( 0 ) ] by L1179;
L1207: (for B281 being Nat holds S15[ B281 ]) from NAT_1:sch 2(L1206 , L1202);
L1208: (for B282 being Nat holds (S16[ B282 ] implies S16[ ( B282 + 1 ) ]))
proof
let C320 being Nat;
assume that
L1209: S16[ C320 ];
set D175 = ( D172 . ( ( ( C317 .order() ) + C320 ) + 1 ) );
set D176 = ( D172 . ( ( C317 .order() ) + C320 ) );
set D177 = ( D176 `1 );
L1210: D175 = ( LexBFS:Step D176 ) by L1065;
L1211: ( card ( dom D177 ) ) = ( C317 .order() ) by L1207;
thus L1212: thesis by L1211 , L1209 , L1210 , L1041;
end;
L1213: S16[ ( 0 ) ];
L1214: (for B283 being Nat holds S16[ B283 ]) from NAT_1:sch 2(L1213 , L1208);
thus L1215: thesis by L1214 , L1201;
end;
theorem
L1216: (for B284 being  finite _Graph holds (for B285 , B286 being Nat holds ((( B284 .order() ) <= B285 & B285 <= B286) implies ( ( LexBFS:CSeq B284 ) . B285 ) = ( ( LexBFS:CSeq B284 ) . B286 ))))
proof
let C321 being  finite _Graph;
let C322 , C323 being Nat;
assume that
L1217: ( C321 .order() ) <= C322
and
L1218: C322 <= C323;
L1219: ( ( LexBFS:CSeq C321 ) . C322 ) = ( ( LexBFS:CSeq C321 ) . ( C321 .order() ) ) by L1217 , L1199;
thus L1220: thesis by L1219 , L1217 , L1218 , L1199 , XXREAL_0:2;
end;
theorem
L1221: (for B287 being  finite _Graph holds ( LexBFS:CSeq B287 ) is  eventually-constant)
proof
let C324 being  finite _Graph;
take ( C324 .order() );
let C325 being Nat;
assume L1222: ( C324 .order() ) <= C325;
thus L1223: ( ( LexBFS:CSeq C324 ) . ( C324 .order() ) ) = ( ( LexBFS:CSeq C324 ) . C325 ) by L1222 , L1199;
end;
registration
let C326 being  finite _Graph;
cluster ( LexBFS:CSeq C326 ) ->  eventually-constant;
coherence by L1221;
end;
theorem
L1225: (for B288 being  finite _Graph holds (for B289 being Nat holds (( dom ( ( ( LexBFS:CSeq B288 ) . B289 ) `1 ) ) = ( the_Vertices_of B288 ) iff ( B288 .order() ) <= B289)))
proof
let C327 being  finite _Graph;
let C328 being Nat;
set D178 = ( LexBFS:CSeq C327 );
set D179 = ( D178 . C328 );
set D180 = ( D179 `1 );
set D181 = ( D178 . ( C327 .order() ) );
set D182 = ( D181 `1 );
thus L1226: ((not ( dom D180 ) = ( the_Vertices_of C327 )) or (not C328 < ( C327 .order() ))) by L1179;
L1227: ( card ( dom D182 ) ) = ( card ( the_Vertices_of C327 ) ) by L1179;
L1228: ( dom D182 ) = ( the_Vertices_of C327 ) by L1227 , CARD_FIN:1;
assume L1229: ( C327 .order() ) <= C328;
thus L1230: thesis by L1229 , L1228 , L1216;
end;
theorem
L1231: (for B290 being  finite _Graph holds ( ( LexBFS:CSeq B290 ) .Lifespan() ) = ( B290 .order() ))
proof
let C329 being  finite _Graph;
set D183 = ( LexBFS:CSeq C329 );
L1232: (for B291 being Nat holds (( D183 . B291 ) = ( D183 . ( B291 + 1 ) ) implies ( C329 .order() ) <= B291))
proof
let C330 being Nat;
assume that
L1233: ( D183 . C330 ) = ( D183 . ( C330 + 1 ) );
set D184 = ( LexBFS:PickUnnumbered ( D183 . C330 ) );
set D185 = ( ( D183 . ( C330 + 1 ) ) `1 );
set D186 = ( ( D183 . C330 ) `1 );
set D187 = ( card ( dom D186 ) );
set D188 = ( D184 .--> ( ( C329 .order() ) -' D187 ) );
assume L1234: C330 < ( C329 .order() );
L1235: ( dom D186 ) <> ( the_Vertices_of C329 ) by L1234 , L1225;
L1236: (not D184 in ( dom D186 )) by L1235 , L1157;
L1237: D187 < ( C329 .order() ) by L1234 , L1179;
L1238: D185 = ( D186 +* ( D184 .--> ( ( C329 .order() ) -' D187 ) ) ) by L1237 , L1174;
L1239: ( dom D188 ) = { D184 } by FUNCOP_1:13;
L1240: ( dom D185 ) = ( ( dom D186 ) \/ { D184 } ) by L1239 , L1238 , FUNCT_4:def 1;
L1241: D184 in { D184 } by TARSKI:def 1;
thus L1242: contradiction by L1241 , L1233 , L1236 , L1240 , XBOOLE_0:def 3;
end;
L1243: ( C329 .order() ) <= ( ( C329 .order() ) + 1 ) by NAT_1:13;
L1244: ( D183 . ( C329 .order() ) ) = ( D183 . ( ( C329 .order() ) + 1 ) ) by L1243 , L1199;
thus L1245: thesis by L1244 , L1232 , GLIB_000:def 55;
end;
theorem
L1246: (for B292 being  finite _Graph holds ( ( LexBFS:CSeq B292 ) ``1 ) is  eventually-constant)
proof
let C331 being  finite _Graph;
set D189 = ( LexBFS:CSeq C331 );
set D190 = ( ( LexBFS:CSeq C331 ) ``1 );
L1247:
now
consider C332 being Nat such that L1248: (for B293 being Nat holds (C332 <= B293 implies ( D189 . C332 ) = ( D189 . B293 ))) by L342;
take D191 = C332;
let C333 being Nat;
assume that
L1249: D191 <= C333;
thus L1250: ( D190 . D191 ) = ( ( D189 . D191 ) `1 ) by L1050
.= ( ( D189 . C333 ) `1 ) by L1248 , L1249
.= ( D190 . C333 ) by L1050;
end;
thus L1251: thesis by L1247 , L342;
end;
theorem
L1252: (for B294 being  finite _Graph holds ( ( ( LexBFS:CSeq B294 ) ``1 ) .Lifespan() ) = ( ( LexBFS:CSeq B294 ) .Lifespan() ))
proof
let C334 being  finite _Graph;
set D192 = ( LexBFS:CSeq C334 );
set D193 = ( D192 ``1 );
set D194 = ( C334 .order() );
L1253: D193 is  eventually-constant by L1246;
L1254: ( ( D192 . ( D194 + 1 ) ) `1 ) = ( ( D192 ``1 ) . ( D194 + 1 ) ) by L1050;
L1255:
now
let C335 being Nat;
assume that
L1256: ( D193 . C335 ) = ( D193 . ( C335 + 1 ) )
and
L1257: D194 > C335;
L1258: ( C335 + 1 ) <= D194 by L1257 , NAT_1:13;
L1259: ( card ( dom ( ( D192 . ( C335 + 1 ) ) `1 ) ) ) = ( C335 + 1 ) by L1258 , L1179;
L1260: ( ( D192 . ( C335 + 1 ) ) `1 ) = ( D193 . ( C335 + 1 ) ) by L1050;
L1261: ( ( D192 . C335 ) `1 ) = ( D193 . C335 ) by L1050;
L1262: ( card ( dom ( ( D192 . C335 ) `1 ) ) ) = C335 by L1257 , L1179;
thus L1263: contradiction by L1262 , L1256 , L1259 , L1261 , L1260;
end;
L1264: ( ( D192 . D194 ) `1 ) = ( ( D192 ``1 ) . D194 ) by L1050;
L1265: ( D193 . D194 ) = ( D193 . ( D194 + 1 ) ) by L1264 , L1254 , L1199 , NAT_1:11;
L1266: ( D192 .Lifespan() ) = D194 by L1231;
thus L1267: thesis by L1266 , L1253 , L1265 , L1255 , GLIB_000:def 55;
end;
registration
let C336 being  finite _Graph;
cluster ( ( LexBFS:CSeq C336 ) ``1 ) ->  vertex-numbering;
correctness
proof
set D195 = ( ( LexBFS:CSeq C336 ) ``1 );
set D196 = ( LexBFS:CSeq C336 );
L1268: ( D195 .Lifespan() ) = ( D196 .Lifespan() ) by L1252;
thus L1269: ( D195 . ( 0 ) ) = ( ( D196 . ( 0 ) ) `1 ) by L1050
.= ( ( LexBFS:Init C336 ) `1 ) by L1065
.= ( {} ) by MCART_1:7;
L1270:
now
let C337 , C338 being Nat;
assume that
L1271: ( D195 . C337 ) = ( D195 . C338 );
L1272: ( D195 . ( C337 + 1 ) ) = ( ( D196 . ( C337 + 1 ) ) `1 ) by L1050;
L1273: ( D195 . C337 ) = ( ( D196 . C337 ) `1 ) by L1050;
L1274: ( D195 . ( C338 + 1 ) ) = ( ( D196 . ( C338 + 1 ) ) `1 ) by L1050;
L1275: ( D195 . C338 ) = ( ( D196 . C338 ) `1 ) by L1050;
per cases ;
suppose L1276: (C337 <= ( C336 .order() ) & C338 <= ( C336 .order() ));

L1277: ( card ( dom ( ( D196 . C338 ) `1 ) ) ) = C338 by L1276 , L1179;
thus L1278: ( D195 . ( C337 + 1 ) ) = ( D195 . ( C338 + 1 ) ) by L1277 , L1271 , L1273 , L1275 , L1276 , L1179;
end;
suppose L1279: (C337 <= ( C336 .order() ) & C338 >= ( C336 .order() ));

L1280: ( D196 . C338 ) = ( D196 . ( C336 .order() ) ) by L1279 , L1199;
L1281: ( card ( dom ( ( D196 . ( C336 .order() ) ) `1 ) ) ) = ( C336 .order() ) by L1179;
L1282: ( C338 + 1 ) >= ( C336 .order() ) by L1279 , NAT_1:13;
L1283: ( card ( dom ( ( D196 . C337 ) `1 ) ) ) = C337 by L1279 , L1179;
L1284: ( C337 + 1 ) >= ( C336 .order() ) by L1283 , L1271 , L1273 , L1275 , L1280 , L1281 , NAT_1:13;
thus L1285: ( D195 . ( C337 + 1 ) ) = ( ( D196 . ( C336 .order() ) ) `1 ) by L1284 , L1272 , L1199
.= ( D195 . ( C338 + 1 ) ) by L1274 , L1282 , L1199;
end;
suppose L1286: (C337 >= ( C336 .order() ) & C338 <= ( C336 .order() ));

L1287: ( D196 . C337 ) = ( D196 . ( C336 .order() ) ) by L1286 , L1199;
L1288: ( card ( dom ( ( D196 . ( C336 .order() ) ) `1 ) ) ) = ( C336 .order() ) by L1179;
L1289: ( card ( dom ( ( D196 . C338 ) `1 ) ) ) = C338 by L1286 , L1179;
L1290: ( C338 + 1 ) >= ( C336 .order() ) by L1289 , L1271 , L1273 , L1275 , L1287 , L1288 , NAT_1:13;
L1291: ( C337 + 1 ) >= ( C336 .order() ) by L1286 , NAT_1:13;
thus L1292: ( D195 . ( C337 + 1 ) ) = ( ( D196 . ( C336 .order() ) ) `1 ) by L1291 , L1272 , L1199
.= ( D195 . ( C338 + 1 ) ) by L1274 , L1290 , L1199;
end;
suppose L1293: (C337 >= ( C336 .order() ) & C338 >= ( C336 .order() ));

L1294: ( C338 + 1 ) >= ( C336 .order() ) by L1293 , NAT_1:13;
L1295: ( C337 + 1 ) >= ( C336 .order() ) by L1293 , NAT_1:13;
thus L1296: ( D195 . ( C337 + 1 ) ) = ( ( D196 . ( C337 + 1 ) ) `1 ) by L1050
.= ( ( D196 . ( C336 .order() ) ) `1 ) by L1295 , L1199
.= ( ( D196 . ( C338 + 1 ) ) `1 ) by L1294 , L1199
.= ( D195 . ( C338 + 1 ) ) by L1050;
end;
end;
thus L1298: D195 is  iterative by L1270 , L340;
L1299: D195 is  eventually-constant by L1246;
thus L1300: D195 is  halting by L1299;
L1301: ( D196 .Lifespan() ) = ( C336 .order() ) by L1231;
thus L1302: ( D195 .Lifespan() ) = ( C336 .order() ) by L1301 , L1252;
let C339 being Nat;
assume that
L1303: C339 < ( D195 .Lifespan() );
L1304: C339 < ( C336 .order() ) by L1301 , L1303 , L1252;
take D197 = ( LexBFS:PickUnnumbered ( D196 . C339 ) );
L1305: ( D195 . C339 ) = ( ( D196 . C339 ) `1 ) by L1050;
L1306: ( card ( dom ( ( D196 . C339 ) `1 ) ) ) = C339 by L1304 , L1179;
thus L1307: (not D197 in ( dom ( D195 . C339 ) )) by L1306 , L1304 , L1305 , L1157;
L1308: ( D195 . ( C339 + 1 ) ) = ( ( D196 . ( C339 + 1 ) ) `1 ) by L1050;
thus L1309: thesis by L1308 , L1268 , L1301 , L1303 , L1305 , L1306 , L1174;
end;
end;
theorem
L1311: (for B295 being  finite _Graph holds ( ( ( LexBFS:CSeq B295 ) ``1 ) .Result() ) = ( ( ( LexBFS:CSeq B295 ) .Result() ) `1 ))
proof
let C340 being  finite _Graph;
set D198 = ( LexBFS:CSeq C340 );
thus L1312: ( ( D198 ``1 ) .Result() ) = ( ( D198 ``1 ) . ( D198 .Lifespan() ) ) by L1252
.= ( ( D198 .Result() ) `1 ) by L1050;
end;
theorem
L1313: (for B296 being  finite _Graph holds (for B297 being Nat holds (B297 < ( B296 .order() ) implies ( ( ( LexBFS:CSeq B296 ) ``1 ) .PickedAt B297 ) = ( LexBFS:PickUnnumbered ( ( LexBFS:CSeq B296 ) . B297 ) ))))
proof
let C341 being  finite _Graph;
let C342 being Nat;
assume that
L1314: C342 < ( C341 .order() );
set D199 = ( LexBFS:CSeq C341 );
set D200 = ( D199 . C342 );
set D201 = ( D199 . ( C342 + 1 ) );
set D202 = ( D200 `1 );
set D203 = ( D201 `1 );
L1315: ( D199 .Lifespan() ) = ( C341 .order() ) by L1231;
set D204 = ( LexBFS:PickUnnumbered D200 );
set D205 = ( D204 .--> ( ( D199 .Lifespan() ) -' C342 ) );
L1316: ( dom D205 ) = { D204 } by FUNCOP_1:13;
L1317: C342 = ( card ( dom D202 ) ) by L1314 , L1179;
L1318: D203 = ( D202 +* ( D204 .--> ( ( D199 .Lifespan() ) -' C342 ) ) ) by L1317 , L1314 , L1315 , L1174;
L1319: ( dom D203 ) = ( ( dom D202 ) \/ { D204 } ) by L1318 , L1316 , FUNCT_4:def 1;
L1320: ( D200 `1 ) = ( ( D199 ``1 ) . C342 ) by L1050;
set D206 = ( ( D199 ``1 ) .PickedAt C342 );
set D207 = ( D206 .--> ( ( D199 .Lifespan() ) -' C342 ) );
L1321: ( dom D207 ) = { D206 } by FUNCOP_1:13;
L1322: ( D199 .Lifespan() ) = ( ( D199 ``1 ) .Lifespan() ) by L1252;
L1323: ( D201 `1 ) = ( ( D199 ``1 ) . ( C342 + 1 ) ) by L1050;
L1324: D203 = ( D202 +* ( D206 .--> ( ( D199 .Lifespan() ) -' C342 ) ) ) by L1323 , L1314 , L1315 , L1322 , L1320 , L606;
L1325: ( dom D203 ) = ( ( dom D202 ) \/ { D206 } ) by L1324 , L1321 , FUNCT_4:def 1;
L1326: (not D206 in ( dom D202 )) by L1314 , L1315 , L1322 , L1320 , L606;
L1327:
now
assume L1328: D206 <> D204;
L1329: (not D206 in { D204 }) by L1328 , TARSKI:def 1;
L1330: (not D206 in ( dom D203 )) by L1329 , L1326 , L1319 , XBOOLE_0:def 3;
L1331: D206 in { D206 } by TARSKI:def 1;
thus L1332: contradiction by L1331 , L1325 , L1330 , XBOOLE_0:def 3;
end;
thus L1333: thesis by L1327;
end;
theorem
L1334: (for B298 being  finite _Graph holds (for B299 being Nat holds (B299 < ( B298 .order() ) implies (ex B300 being (Vertex of B298) st (B300 = ( LexBFS:PickUnnumbered ( ( LexBFS:CSeq B298 ) . B299 ) ) & (for B301 being set holds (((B301 in ( B298 .AdjacentSet { B300 } ) & (not B301 in ( dom ( ( ( LexBFS:CSeq B298 ) . B299 ) `1 ) ))) implies ( ( ( ( LexBFS:CSeq B298 ) . ( B299 + 1 ) ) `2 ) . B301 ) = ( ( ( ( ( LexBFS:CSeq B298 ) . B299 ) `2 ) . B301 ) \/ { ( ( B298 .order() ) -' B299 ) } )) & (((not B301 in ( B298 .AdjacentSet { B300 } )) or B301 in ( dom ( ( ( LexBFS:CSeq B298 ) . B299 ) `1 ) )) implies ( ( ( ( LexBFS:CSeq B298 ) . ( B299 + 1 ) ) `2 ) . B301 ) = ( ( ( ( LexBFS:CSeq B298 ) . B299 ) `2 ) . B301 )))))))))
proof
let C343 being  finite _Graph;
let C344 being Nat;
assume that
L1335: C344 < ( C343 .order() );
set D208 = ( LexBFS:CSeq C343 );
set D209 = ( D208 . C344 );
set D210 = ( D209 `1 );
set D211 = ( D209 `2 );
set D212 = ( D208 . ( C344 + 1 ) );
set D213 = ( D212 `2 );
set D214 = ( LexBFS:PickUnnumbered D209 );
take D214;
L1336: D212 = ( LexBFS:Step D209 ) by L1065;
L1337: ( card ( dom D210 ) ) = C344 by L1335 , L1179;
L1338: D212 = ( LexBFS:Update (D209 , D214 , C344) ) by L1337 , L1335 , L1336 , L1041;
L1339:
now
let C345 being set;
assume L1340: ((not C345 in ( C343 .AdjacentSet { D214 } )) or C345 in ( dom D210 ));
per cases  by L1340;
suppose L1341: (not C345 in ( C343 .AdjacentSet { D214 } ));

thus L1342: ( D213 . C345 ) = ( D211 . C345 ) by L1341 , L1338 , L1006;
end;
suppose L1343: C345 in ( dom D210 );

thus L1344: ( D213 . C345 ) = ( D211 . C345 ) by L1343 , L1338 , L1019;
end;
end;
thus L1346: thesis by L1339 , L1338 , L1032;
end;
theorem
L1347: (for B302 being  finite _Graph holds (for B303 being Nat holds (for B304 being set holds ( ( ( ( LexBFS:CSeq B302 ) . B303 ) `2 ) . B304 ) c= ( ( Seg ( B302 .order() ) ) \ ( Seg ( ( B302 .order() ) -' B303 ) ) ))))
proof
let C346 being  finite _Graph;
let C347 being Nat;
let C348 being set;
set D215 = ( LexBFS:CSeq C346 );
set D216 = ( D215 . C347 );
set D217 = ( D216 `2 );
set D218 = ( D215 . ( C346 .order() ) );
set D219 = ( D218 `2 );
defpred S17[ Nat ] means ($1 <= ( C346 .order() ) implies ( ( ( ( LexBFS:CSeq C346 ) . $1 ) `2 ) . C348 ) c= ( ( Seg ( C346 .order() ) ) \ ( Seg ( ( C346 .order() ) -' $1 ) ) ));
L1348: (for B305 being Nat holds (S17[ B305 ] implies S17[ ( B305 + 1 ) ]))
proof
let C349 being Nat;
assume that
L1349: S17[ C349 ];
set D220 = ( D215 . ( C349 + 1 ) );
set D221 = ( D215 . C349 );
set D222 = ( D221 `2 );
set D223 = ( D221 `1 );
set D224 = ( D220 `2 );
per cases ;
suppose L1350: ( C349 + 1 ) <= ( C346 .order() );

L1351: C349 < ( C346 .order() ) by L1350 , NAT_1:13;
consider C350 being (Vertex of C346) such that L1352: C350 = ( LexBFS:PickUnnumbered D221 ) and L1353: (for B306 being set holds (((B306 in ( C346 .AdjacentSet { C350 } ) & (not B306 in ( dom D223 ))) implies ( D224 . B306 ) = ( ( D222 . B306 ) \/ { ( ( C346 .order() ) -' C349 ) } )) & (((not B306 in ( C346 .AdjacentSet { C350 } )) or B306 in ( dom D223 )) implies ( D224 . B306 ) = ( D222 . B306 )))) by L1351 , L1334;
per cases ;
suppose L1354: (C348 in ( C346 .AdjacentSet { C350 } ) & (not C348 in ( dom D223 )));

L1355: ( ( ( Seg ( C346 .order() ) ) \ ( Seg ( ( C346 .order() ) -' C349 ) ) ) \/ { ( ( C346 .order() ) -' C349 ) } ) = ( ( Seg ( C346 .order() ) ) \ ( Seg ( ( C346 .order() ) -' ( C349 + 1 ) ) ) ) by L1351 , L134;
L1356: ( D224 . C348 ) = ( ( D222 . C348 ) \/ { ( ( C346 .order() ) -' C349 ) } ) by L1353 , L1354;
thus L1357: thesis by L1356 , L1349 , L1355 , NAT_1:13 , XBOOLE_1:9;
end;
suppose L1358: ((not C348 in ( C346 .AdjacentSet { C350 } )) or C348 in ( dom D223 ));

L1359: C349 <= ( C349 + 1 ) by NAT_1:13;
L1360: ( ( Seg ( C346 .order() ) ) \ ( Seg ( ( C346 .order() ) -' C349 ) ) ) c= ( ( Seg ( C346 .order() ) ) \ ( Seg ( ( C346 .order() ) -' ( C349 + 1 ) ) ) ) by L1359 , L113;
L1361: ( D224 . C348 ) = ( D222 . C348 ) by L1353 , L1358;
thus L1362: thesis by L1361 , L1349 , L1360 , NAT_1:13 , XBOOLE_1:1;
end;
end;
suppose L1364: ( C346 .order() ) < ( C349 + 1 );

thus L1365: thesis by L1364;
end;
end;
L1367: ( D215 . ( 0 ) ) = ( LexBFS:Init C346 ) by L1065;
L1368: ( ( ( D215 . ( 0 ) ) `2 ) . C348 ) = ( {} ) by L1367 , L1107;
L1369: S17[ ( 0 ) ] by L1368 , XBOOLE_1:2;
L1370: (for B307 being Nat holds S17[ B307 ]) from NAT_1:sch 2(L1369 , L1348);
per cases ;
suppose L1371: C347 <= ( C346 .order() );

thus L1372: thesis by L1371 , L1370;
end;
suppose L1373: C347 > ( C346 .order() );

L1374: ( ( C346 .order() ) - C347 ) < ( C347 - C347 ) by L1373 , XREAL_1:9;
L1375: ( ( C346 .order() ) -' C347 ) = ( 0 ) by L1374 , XREAL_0:def 2;
L1376: ( ( C346 .order() ) -' ( C346 .order() ) ) = ( ( C346 .order() ) -' C347 ) by L1375 , XREAL_1:232;
L1377: D219 = D217 by L1373 , L1216;
thus L1378: thesis by L1377 , L1370 , L1376;
end;
end;
theorem
L1380: (for B308 being  finite _Graph holds (for B309 being set holds (for B310 , B311 being Nat holds (B310 <= B311 implies ( ( ( ( LexBFS:CSeq B308 ) . B310 ) `2 ) . B309 ) c= ( ( ( ( LexBFS:CSeq B308 ) . B311 ) `2 ) . B309 )))))
proof
let C351 being  finite _Graph;
let C352 being set;
let C353 , C354 being Nat;
assume L1381: C353 <= C354;
L1382: (ex B312 being Nat st C354 = ( C353 + B312 )) by L1381 , NAT_1:10;
set D225 = ( LexBFS:CSeq C351 );
set D226 = ( D225 . C353 );
set D227 = ( D226 `2 );
defpred S18[ Nat ] means ( D227 . C352 ) c= ( ( ( D225 . ( C353 + $1 ) ) `2 ) . C352 );
L1383: (for B313 being Nat holds (S18[ B313 ] implies S18[ ( B313 + 1 ) ]))
proof
let C355 being Nat;
assume that
L1384: S18[ C355 ];
set D228 = ( D225 . ( ( C353 + C355 ) + 1 ) );
set D229 = ( D225 . ( C353 + C355 ) );
set D230 = ( D229 `2 );
set D231 = ( D229 `1 );
set D232 = ( D228 `2 );
per cases ;
suppose L1385: ( ( C353 + C355 ) + 1 ) <= ( C351 .order() );

L1386: ( C353 + C355 ) < ( C351 .order() ) by L1385 , NAT_1:13;
consider C356 being (Vertex of C351) such that L1387: C356 = ( LexBFS:PickUnnumbered D229 ) and L1388: (for B314 being set holds (((B314 in ( C351 .AdjacentSet { C356 } ) & (not B314 in ( dom D231 ))) implies ( D232 . B314 ) = ( ( D230 . B314 ) \/ { ( ( C351 .order() ) -' ( C353 + C355 ) ) } )) & (((not B314 in ( C351 .AdjacentSet { C356 } )) or B314 in ( dom D231 )) implies ( D232 . B314 ) = ( D230 . B314 )))) by L1386 , L1334;
per cases ;
suppose L1389: (C352 in ( C351 .AdjacentSet { C356 } ) & (not C352 in ( dom D231 )));

L1390: ( D232 . C352 ) = ( ( D230 . C352 ) \/ { ( ( C351 .order() ) -' ( C353 + C355 ) ) } ) by L1389 , L1388;
L1391: ( D230 . C352 ) c= ( D232 . C352 ) by L1390 , XBOOLE_1:7;
thus L1392: thesis by L1391 , L1384 , XBOOLE_1:1;
end;
suppose L1393: ((not C352 in ( C351 .AdjacentSet { C356 } )) or C352 in ( dom D231 ));

thus L1394: thesis by L1393 , L1384 , L1388;
end;
end;
suppose L1396: ( C351 .order() ) < ( ( C353 + C355 ) + 1 );

L1397: ( C353 + C355 ) <= ( ( C353 + C355 ) + 1 ) by NAT_1:13;
L1398: ( C351 .order() ) <= ( C353 + C355 ) by L1396 , NAT_1:13;
thus L1399: thesis by L1398 , L1384 , L1397 , L1216;
end;
end;
L1401: S18[ ( 0 ) ];
L1402: (for B315 being Nat holds S18[ B315 ]) from NAT_1:sch 2(L1401 , L1383);
thus L1403: thesis by L1402 , L1382;
end;
theorem
L1404: (for B316 being  finite _Graph holds (for B317 , B318 being Nat holds (for B319 , B320 being set holds ((B318 < ( B316 .order() ) & B318 < B317 & B320 = ( LexBFS:PickUnnumbered ( ( LexBFS:CSeq B316 ) . B318 ) ) & (not B319 in ( dom ( ( ( LexBFS:CSeq B316 ) . B318 ) `1 ) )) & B319 in ( B316 .AdjacentSet { B320 } )) implies ( ( B316 .order() ) -' B318 ) in ( ( ( ( LexBFS:CSeq B316 ) . B317 ) `2 ) . B319 )))))
proof
let C357 being  finite _Graph;
let C358 , C359 being Nat;
let C360 , C361 being set;
assume that
L1405: C359 < ( C357 .order() )
and
L1406: C359 < C358;
set D233 = ( LexBFS:CSeq C357 );
set D234 = ( D233 . C358 );
set D235 = ( D234 `2 );
set D236 = ( D233 . ( C359 + 1 ) );
set D237 = ( D236 `2 );
L1407: ( C359 + 1 ) <= C358 by L1406 , NAT_1:13;
L1408: ( D237 . C360 ) c= ( D235 . C360 ) by L1407 , L1380;
L1409: ( ( C357 .order() ) -' C359 ) in { ( ( C357 .order() ) -' C359 ) } by TARSKI:def 1;
set D238 = ( D233 . C359 );
set D239 = ( D238 `1 );
set D240 = ( D238 `2 );
assume that
L1410: C361 = ( LexBFS:PickUnnumbered D238 )
and
L1411: (not C360 in ( dom D239 ))
and
L1412: C360 in ( C357 .AdjacentSet { C361 } );
L1413: (ex B321 being (Vertex of C357) st (B321 = ( LexBFS:PickUnnumbered D238 ) & (for B322 being set holds (((B322 in ( C357 .AdjacentSet { B321 } ) & (not B322 in ( dom D239 ))) implies ( D237 . B322 ) = ( ( D240 . B322 ) \/ { ( ( C357 .order() ) -' C359 ) } )) & (((not B322 in ( C357 .AdjacentSet { B321 } )) or B322 in ( dom D239 )) implies ( D237 . B322 ) = ( D240 . B322 )))))) by L1405 , L1334;
L1414: ( D237 . C360 ) = ( ( D240 . C360 ) \/ { ( ( C357 .order() ) -' C359 ) } ) by L1413 , L1410 , L1411 , L1412;
L1415: ( ( C357 .order() ) -' C359 ) in ( D237 . C360 ) by L1414 , L1409 , XBOOLE_0:def 3;
thus L1416: thesis by L1415 , L1408;
end;
theorem
L1417: (for B323 being  finite _Graph holds (for B324 , B325 being Nat holds (B324 < B325 implies (for B326 being set holds ((not ( ( B323 .order() ) -' B324 ) in ( ( ( ( LexBFS:CSeq B323 ) . ( B324 + 1 ) ) `2 ) . B326 )) implies (not ( ( B323 .order() ) -' B324 ) in ( ( ( ( LexBFS:CSeq B323 ) . B325 ) `2 ) . B326 )))))))
proof
let C362 being  finite _Graph;
let C363 , C364 being Nat;
assume L1418: C363 < C364;
L1419: ( C363 + 1 ) <= C364 by L1418 , NAT_1:13;
L1420: (ex B327 being Nat st ( ( C363 + 1 ) + B327 ) = C364) by L1419 , NAT_1:10;
set D241 = ( LexBFS:CSeq C362 );
set D242 = ( D241 . ( C363 + 1 ) );
set D243 = ( D242 `2 );
let C365 being set;
assume that
L1421: (not ( ( C362 .order() ) -' C363 ) in ( D243 . C365 ));
defpred S19[ Nat ] means (not ( ( C362 .order() ) -' C363 ) in ( ( ( ( LexBFS:CSeq C362 ) . ( ( C363 + 1 ) + $1 ) ) `2 ) . C365 ));
L1422: (for B328 being Nat holds (S19[ B328 ] implies S19[ ( B328 + 1 ) ]))
proof
let C366 being Nat;
assume that
L1423: S19[ C366 ];
set D244 = ( D241 . ( ( C363 + 1 ) + C366 ) );
set D245 = ( D244 `1 );
set D246 = ( D244 `2 );
set D247 = ( D241 . ( ( ( C363 + 1 ) + C366 ) + 1 ) );
set D248 = ( D247 `2 );
L1424:
now
per cases ;
suppose L1425: ( ( C363 + 1 ) + C366 ) < ( C362 .order() );

consider C367 being (Vertex of C362) such that L1426: C367 = ( LexBFS:PickUnnumbered D244 ) and L1427: (for B329 being set holds (((B329 in ( C362 .AdjacentSet { C367 } ) & (not B329 in ( dom D245 ))) implies ( D248 . B329 ) = ( ( D246 . B329 ) \/ { ( ( C362 .order() ) -' ( ( C363 + 1 ) + C366 ) ) } )) & (((not B329 in ( C362 .AdjacentSet { C367 } )) or B329 in ( dom D245 )) implies ( D248 . B329 ) = ( D246 . B329 )))) by L1425 , L1334;
per cases ;
suppose L1428: (C365 in ( C362 .AdjacentSet { C367 } ) & (not C365 in ( dom D245 )));

L1429: ( C363 + 1 ) <= ( ( C363 + 1 ) + C366 ) by NAT_1:11;
L1430: C363 < ( ( C363 + 1 ) + C366 ) by L1429 , XREAL_1:39;
L1431: ( ( C362 .order() ) -' C363 ) > ( ( C362 .order() ) -' ( ( C363 + 1 ) + C366 ) ) by L1430 , L1425 , L72;
L1432: (not ( ( C362 .order() ) -' C363 ) in { ( ( C362 .order() ) -' ( ( C363 + 1 ) + C366 ) ) }) by L1431 , TARSKI:def 1;
L1433: ( D248 . C365 ) = ( ( D246 . C365 ) \/ { ( ( C362 .order() ) -' ( ( C363 + 1 ) + C366 ) ) } ) by L1427 , L1428;
thus L1434: (not ( ( C362 .order() ) -' C363 ) in ( D248 . C365 )) by L1433 , L1423 , L1432 , XBOOLE_0:def 3;
end;
suppose L1435: ((not C365 in ( C362 .AdjacentSet { C367 } )) or C365 in ( dom D245 ));

thus L1436: (not ( ( C362 .order() ) -' C363 ) in ( D248 . C365 )) by L1435 , L1423 , L1427;
end;
end;
suppose L1438: ( C362 .order() ) <= ( ( C363 + 1 ) + C366 );

L1439: ( ( C363 + 1 ) + C366 ) <= ( ( ( C363 + 1 ) + C366 ) + 1 ) by NAT_1:13;
thus L1440: (not ( ( C362 .order() ) -' C363 ) in ( D248 . C365 )) by L1439 , L1423 , L1438 , L1216;
end;
end;
thus L1442: thesis by L1424;
end;
L1443: S19[ ( 0 ) ] by L1421;
L1444: (for B330 being Nat holds S19[ B330 ]) from NAT_1:sch 2(L1443 , L1422);
thus L1445: thesis by L1444 , L1420;
end;
theorem
L1446: (for B331 being  finite _Graph holds (for B332 , B333 , B334 being Nat holds ((B334 < B333 & B333 <= B332) implies (for B335 being set holds ((not ( ( B331 .order() ) -' B334 ) in ( ( ( ( LexBFS:CSeq B331 ) . B333 ) `2 ) . B335 )) implies (not ( ( B331 .order() ) -' B334 ) in ( ( ( ( LexBFS:CSeq B331 ) . B332 ) `2 ) . B335 )))))))
proof
let C368 being  finite _Graph;
let C369 , C370 , C371 being Nat;
assume that
L1447: C371 < C370
and
L1448: C370 <= C369;
set D249 = ( LexBFS:CSeq C368 );
set D250 = ( D249 . C370 );
set D251 = ( D250 `2 );
let C372 being set;
assume that
L1449: (not ( ( C368 .order() ) -' C371 ) in ( D251 . C372 ));
set D252 = ( D249 . ( C371 + 1 ) );
set D253 = ( D252 `2 );
L1450: ( C371 + 1 ) <= C370 by L1447 , NAT_1:13;
L1451: ( D253 . C372 ) c= ( D251 . C372 ) by L1450 , L1380;
L1452: (not ( ( C368 .order() ) -' C371 ) in ( D253 . C372 )) by L1451 , L1449;
L1453: C371 < C369 by L1447 , L1448 , XXREAL_0:2;
thus L1454: thesis by L1453 , L1452 , L1417;
end;
theorem
L1455: (for B336 being  finite _Graph holds (for B337 , B338 being Nat holds (for B339 being (Vertex of B336) holds (B338 in ( ( ( ( LexBFS:CSeq B336 ) . B337 ) `2 ) . B339 ) implies (ex B340 being (Vertex of B336) st (( LexBFS:PickUnnumbered ( ( LexBFS:CSeq B336 ) . ( ( B336 .order() ) -' B338 ) ) ) = B340 & (not B340 in ( dom ( ( ( LexBFS:CSeq B336 ) . ( ( B336 .order() ) -' B338 ) ) `1 ) )) & B339 in ( B336 .AdjacentSet { B340 } )))))))
proof
let C373 being  finite _Graph;
let C374 , C375 being Nat;
set D254 = ( LexBFS:CSeq C373 );
set D255 = ( D254 . C374 );
set D256 = ( D255 `2 );
set D257 = ( D254 . ( ( C373 .order() ) -' C375 ) );
set D258 = ( D257 `1 );
set D259 = ( D257 `2 );
set D260 = ( ( ( C373 .order() ) -' C375 ) + 1 );
set D261 = ( D254 . D260 );
set D262 = ( D261 `2 );
let C376 being (Vertex of C373);
assume that
L1456: C375 in ( D256 . C376 );
L1457: ( D256 . C376 ) c= ( ( Seg ( C373 .order() ) ) \ ( Seg ( ( C373 .order() ) -' C374 ) ) ) by L1347;
L1458: ( ( C373 .order() ) -' C374 ) < C375 by L1457 , L1456 , L100;
L1459: C375 <= ( C373 .order() ) by L1456 , L1457 , L100;
L1460: ( ( C373 .order() ) -' C375 ) = ( ( C373 .order() ) - C375 ) by L1459 , XREAL_1:233;
L1461: ( ( C373 .order() ) -' C375 ) < ( C373 .order() ) by L1460 , L1458 , XREAL_1:44;
L1462: ( ( C373 .order() ) -' ( ( C373 .order() ) -' C375 ) ) = ( ( C373 .order() ) - ( ( C373 .order() ) - C375 ) ) by L1461 , L1460 , XREAL_1:233;
consider C377 being (Vertex of C373) such that L1463: C377 = ( LexBFS:PickUnnumbered D257 ) and L1464: (for B341 being set holds (((B341 in ( C373 .AdjacentSet { C377 } ) & (not B341 in ( dom D258 ))) implies ( D262 . B341 ) = ( ( D259 . B341 ) \/ { C375 } )) & (((not B341 in ( C373 .AdjacentSet { C377 } )) or B341 in ( dom D258 )) implies ( D262 . B341 ) = ( D259 . B341 )))) by L1462 , L1458 , L1460 , L1334 , XREAL_1:44;
L1465: ( D259 . C376 ) c= ( ( Seg ( C373 .order() ) ) \ ( Seg ( ( C373 .order() ) -' ( ( C373 .order() ) -' C375 ) ) ) ) by L1347;
L1466: (not C375 in ( D259 . C376 )) by L1465 , L1462 , L100;
L1467:
now
per cases ;
suppose L1468: C374 <= ( C373 .order() );

L1469: ( ( C373 .order() ) -' C374 ) = ( ( C373 .order() ) - C374 ) by L1468 , XREAL_1:233;
L1470: ( ( ( C373 .order() ) - C374 ) + C374 ) < ( C375 + C374 ) by L1469 , L1458 , XREAL_1:6;
L1471: ( ( C373 .order() ) - C375 ) < ( ( C374 + C375 ) - C375 ) by L1470 , XREAL_1:9;
thus L1472: D260 <= C374 by L1471 , L1460 , NAT_1:13;
end;
suppose L1473: ( C373 .order() ) < C374;

L1474: ( ( C373 .order() ) -' C375 ) < C374 by L1473 , L1461 , XXREAL_0:2;
thus L1475: D260 <= C374 by L1474 , NAT_1:13;
end;
end;
L1477: ( ( C373 .order() ) -' C375 ) < D260 by XREAL_1:39;
assume L1478: (not (ex B342 being (Vertex of C373) st (( LexBFS:PickUnnumbered D257 ) = B342 & (not B342 in ( dom D258 )) & C376 in ( C373 .AdjacentSet { B342 } ))));
L1479: ( dom D258 ) <> ( the_Vertices_of C373 ) by L1461 , L1225;
L1480: (not C376 in ( C373 .AdjacentSet { C377 } )) by L1479 , L1478 , L1463 , L1157;
L1481: (not C375 in ( D262 . C376 )) by L1480 , L1466 , L1464;
thus L1482: contradiction by L1481 , L1456 , L1462 , L1467 , L1477 , L1446;
end;
theorem
L1483: (for B343 being  finite _Graph holds ( dom ( ( ( LexBFS:CSeq B343 ) .Result() ) `1 ) ) = ( the_Vertices_of B343 ))
proof
let C378 being  finite _Graph;
set D263 = ( LexBFS:CSeq C378 );
set D264 = ( D263 . ( C378 .order() ) );
L1484: ( D263 .Result() ) = D264 by L1231;
thus L1485: thesis by L1484 , L1225;
end;
::$N Lexicographic_breadth-first_search
theorem
L1486: (for B344 being  finite _Graph holds ( ( ( ( LexBFS:CSeq B344 ) .Result() ) `1 ) " ) is (VertexScheme of B344))
proof
let C379 being  finite _Graph;
set D265 = ( LexBFS:CSeq C379 );
set D266 = ( D265 . ( C379 .order() ) );
set D267 = ( D266 `1 );
set D268 = ( D265 ``1 );
L1487: D266 = ( ( LexBFS:CSeq C379 ) .Result() ) by L1231;
L1488: ( D265 .Lifespan() ) = ( C379 .order() ) by L1231;
L1489: D267 = ( D268 . ( C379 .order() ) ) by L1050;
L1490: D267 is  one-to-one by L1489 , L743;
L1491: ( dom D267 ) = ( the_Vertices_of C379 ) by L1225;
L1492: ( rng ( D267 " ) ) = ( the_Vertices_of C379 ) by L1491 , L1490 , FUNCT_1:33;
L1493: ( D265 .Lifespan() ) = ( D268 .Lifespan() ) by L1252;
L1494: ( rng ( D268 . ( C379 .order() ) ) ) = ( ( Seg ( C379 .order() ) ) \ ( Seg ( ( C379 .order() ) -' ( C379 .order() ) ) ) ) by L1493 , L1488 , L666
.= ( ( Seg ( C379 .order() ) ) \ ( Seg ( 0 ) ) ) by XREAL_1:232
.= ( Seg ( C379 .order() ) );
L1495: ( dom ( D267 " ) ) = ( Seg ( C379 .order() ) ) by L1494 , L1489 , L1490 , FUNCT_1:33;
L1496: ( D267 " ) is FinSequence by L1495 , FINSEQ_1:def 2;
L1497: ( D267 " ) is (FinSequence of ( the_Vertices_of C379 )) by L1496 , L1492 , FINSEQ_1:def 4;
thus L1498: thesis by L1497 , L1487 , L1490 , L1492 , CHORD:def 12;
end;
theorem
L1499: (for B345 being  finite _Graph holds (for B346 , B347 being Nat holds (for B348 , B349 being (Vertex of B345) holds ((B348 in ( dom ( ( ( LexBFS:CSeq B345 ) . B346 ) `1 ) ) & B349 in ( dom ( ( ( LexBFS:CSeq B345 ) . B346 ) `1 ) ) & ( ( ( ( LexBFS:CSeq B345 ) . B346 ) `1 ) . B348 ) < ( ( ( ( LexBFS:CSeq B345 ) . B346 ) `1 ) . B349 ) & B347 = ( ( B345 .order() ) -' ( ( ( ( LexBFS:CSeq B345 ) . B346 ) `1 ) . B349 ) )) implies ( (( ( ( ( LexBFS:CSeq B345 ) . B347 ) `2 ) . B348 ) , 1) -bag ) <= ( (( ( ( ( LexBFS:CSeq B345 ) . B347 ) `2 ) . B349 ) , 1) -bag ) , ( InvLexOrder ( NAT ) )))))
proof
let C380 being  finite _Graph;
let C381 , C382 being Nat;
let C383 , C384 being (Vertex of C380);
assume that
L1500: C383 in ( dom ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) )
and
L1501: C384 in ( dom ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) )
and
L1502: ( ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) . C383 ) < ( ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) . C384 )
and
L1503: C382 = ( ( C380 .order() ) -' ( ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) . C384 ) );
set D269 = ( ( LexBFS:CSeq C380 ) ``1 );
set D270 = ( ( LexBFS:CSeq C380 ) . C382 );
set D271 = ( D269 . C381 );
set D272 = ( D269 . C382 );
L1504: ( ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) . C384 ) = ( ( ( ( LexBFS:CSeq C380 ) ``1 ) . C381 ) . C384 ) by L1050;
L1505: C383 in ( the_Vertices_of C380 );
L1506: ( ( ( LexBFS:CSeq C380 ) . C381 ) `1 ) = ( ( ( LexBFS:CSeq C380 ) ``1 ) . C381 ) by L1050;
L1507: ( ( LexBFS:CSeq C380 ) .Lifespan() ) = ( D269 .Lifespan() ) by L1252;
L1508: ( C380 .order() ) = ( ( LexBFS:CSeq C380 ) .Lifespan() ) by L1231;
L1509: ( D271 . C384 ) <= ( C380 .order() ) by L1508 , L1507 , L695;
L1510: ( ( C380 .order() ) -' ( D271 . C384 ) ) = ( ( C380 .order() ) - ( D271 . C384 ) ) by L1509 , XREAL_1:233;
L1511: ( ( C380 .order() ) -' C382 ) = ( ( C380 .order() ) - ( ( C380 .order() ) - ( D271 . C384 ) ) ) by L1510 , L1503 , L1504 , NAT_D:35 , XREAL_1:233;
L1512:
now
assume L1513: C383 in ( dom ( D270 `1 ) );
L1514: C383 in ( dom D272 ) by L1513 , L1050;
L1515: ( D271 . C384 ) < ( D272 . C383 ) by L1514 , L1508 , L1507 , L1511 , L809;
thus L1516: contradiction by L1515 , L1500 , L1502 , L1506 , L1514 , L762;
end;
L1517: ( D269 .PickedAt C382 ) = C384 by L1501 , L1503 , L1506 , L1508 , L1507 , L774;
L1518: ( LexBFS:PickUnnumbered D270 ) = C384 by L1517 , L1502 , L1503 , L1504 , L1510 , L1313 , XREAL_1:44;
thus L1519: thesis by L1518 , L1505 , L1512 , L1126;
end;
theorem
L1520: (for B350 being  finite _Graph holds (for B351 , B352 being Nat holds (for B353 being (Vertex of B350) holds (B352 in ( ( ( ( LexBFS:CSeq B350 ) . B351 ) `2 ) . B353 ) implies (ex B354 being (Vertex of B350) st (B354 in ( dom ( ( ( LexBFS:CSeq B350 ) . B351 ) `1 ) ) & ( ( ( ( LexBFS:CSeq B350 ) . B351 ) `1 ) . B354 ) = B352 & B353 in ( B350 .AdjacentSet { B354 } )))))))
proof
let C385 being  finite _Graph;
let C386 , C387 being Nat;
let C388 being (Vertex of C385);
set D273 = ( ( LexBFS:CSeq C385 ) . C386 );
set D274 = ( ( ( LexBFS:CSeq C385 ) ``1 ) . C386 );
set D275 = ( D273 `2 );
set D276 = ( ( C385 .order() ) -' C387 );
set D277 = ( ( LexBFS:CSeq C385 ) . D276 );
set D278 = ( D277 `1 );
L1521: ( C385 .order() ) = ( ( LexBFS:CSeq C385 ) .Lifespan() ) by L1231;
L1522: ( ( LexBFS:CSeq C385 ) .Lifespan() ) = ( ( ( LexBFS:CSeq C385 ) ``1 ) .Lifespan() ) by L1252;
assume L1523: C387 in ( D275 . C388 );
consider C389 being (Vertex of C385) such that L1524: ( LexBFS:PickUnnumbered D277 ) = C389 and L1525: (not C389 in ( dom D278 )) and L1526: C388 in ( C385 .AdjacentSet { C389 } ) by L1523 , L1455;
L1527: ( D275 . C388 ) c= ( ( Seg ( C385 .order() ) ) \ ( Seg ( ( C385 .order() ) -' C386 ) ) ) by L1347;
L1528: ( ( C385 .order() ) -' C386 ) < C387 by L1527 , L1523 , L100;
L1529: C387 <= ( C385 .order() ) by L1523 , L1527 , L100;
L1530: ( ( C385 .order() ) -' C387 ) = ( ( C385 .order() ) - C387 ) by L1529 , XREAL_1:233;
L1531: D276 < ( C385 .order() ) by L1530 , L1528 , XREAL_1:44;
L1532: ( ( C385 .order() ) - D276 ) = ( ( C385 .order() ) - ( ( C385 .order() ) - C387 ) ) by L1529 , XREAL_1:233;
L1533: ( ( C385 .order() ) - C386 ) < ( ( C385 .order() ) - D276 ) by L1532 , L1528 , XREAL_0:def 2;
L1534: ( ( ( C385 .order() ) - C386 ) + C386 ) < ( ( ( C385 .order() ) - D276 ) + C386 ) by L1533 , XREAL_1:6;
L1535: ( ( C385 .order() ) + D276 ) < ( ( ( ( C385 .order() ) + C386 ) - D276 ) + D276 ) by L1534 , XREAL_1:6;
L1536: ( ( D276 + ( C385 .order() ) ) - ( C385 .order() ) ) < ( ( C386 + ( C385 .order() ) ) - ( C385 .order() ) ) by L1535 , XREAL_1:9;
L1537: C389 = ( ( ( LexBFS:CSeq C385 ) ``1 ) .PickedAt D276 ) by L1524 , L1528 , L1530 , L1313 , XREAL_1:44;
L1538: ( D274 . C389 ) = ( ( C385 .order() ) -' D276 ) by L1537 , L1531 , L1521 , L1522 , L1536 , L800;
L1539: ( D273 `1 ) = D274 by L1050;
L1540: C389 in ( dom ( D273 `1 ) ) by L1539 , L1531 , L1521 , L1522 , L1537 , L1536 , L800;
thus L1541: thesis by L1540 , L1539 , L1526 , L1531 , L1532 , L1538 , XREAL_1:233;
end;
definition
let C390 being _Graph;
let C391 being (PartFunc of ( the_Vertices_of C390 ) , ( NAT ));
attr C391 is  with_property_L3
means
:L1542: (for B355 , B356 , B357 being (Vertex of C390) holds ((B355 in ( dom C391 ) & B356 in ( dom C391 ) & B357 in ( dom C391 ) & ( C391 . B355 ) < ( C391 . B356 ) & ( C391 . B356 ) < ( C391 . B357 ) & B355 , B357 are_adjacent  & (not B356 , B357 are_adjacent )) implies (ex B358 being (Vertex of C390) st (B358 in ( dom C391 ) & ( C391 . B357 ) < ( C391 . B358 ) & B356 , B358 are_adjacent  & (not B355 , B358 are_adjacent ) & (for B359 being (Vertex of C390) holds ((B359 <> B358 & B359 , B356 are_adjacent  & (not B359 , B355 are_adjacent )) implies ( C391 . B359 ) < ( C391 . B358 )))))));
end;
theorem
L1544: (for B360 being  finite _Graph holds (for B361 being Nat holds ( ( ( LexBFS:CSeq B360 ) . B361 ) `1 ) is  with_property_L3))
proof
let C392 being  finite _Graph;
let C393 being Nat;
set D279 = ( ( LexBFS:CSeq C392 ) . C393 );
set D280 = ( ( ( LexBFS:CSeq C392 ) ``1 ) . C393 );
L1545: ( D279 `1 ) = D280 by L1050;
L1546:
now
L1547: ( ( LexBFS:CSeq C392 ) .Lifespan() ) = ( ( ( LexBFS:CSeq C392 ) ``1 ) .Lifespan() ) by L1252;
L1548: ( ( LexBFS:CSeq C392 ) .Lifespan() ) = ( C392 .order() ) by L1231;
let C394 , C395 , C396 being (Vertex of C392);
assume that
L1549: C394 in ( dom D280 )
and
L1550: C395 in ( dom D280 )
and
L1551: C396 in ( dom D280 )
and
L1552: ( D280 . C394 ) < ( D280 . C395 )
and
L1553: ( D280 . C395 ) < ( D280 . C396 )
and
L1554: C394 , C396 are_adjacent 
and
L1555: (not C395 , C396 are_adjacent );
defpred S20[ Nat ] means (ex B362 being (Vertex of C392) st (B362 in ( dom D280 ) & C395 , B362 are_adjacent  & (not C394 , B362 are_adjacent ) & ( D280 . C396 ) < ( D280 . B362 ) & ( D280 . B362 ) = $1));
L1556: ( D280 . C394 ) < ( D280 . C396 ) by L1552 , L1553 , XXREAL_0:2;
L1557:
now
set D281 = ( ( C392 .order() ) -' ( D280 . C396 ) );
set D282 = ( ( C392 .order() ) -' ( D280 . C395 ) );
assume L1558: (for B363 being (Vertex of C392) holds ((B363 in ( dom D280 ) & ( D280 . C396 ) < ( D280 . B363 ) & B363 , C395 are_adjacent ) implies B363 , C394 are_adjacent ));
set D283 = ( ( ( LexBFS:CSeq C392 ) ``1 ) . D281 );
set D284 = ( ( LexBFS:CSeq C392 ) . D281 );
set D285 = ( ( ( LexBFS:CSeq C392 ) ``1 ) . D282 );
set D286 = ( ( LexBFS:CSeq C392 ) . D282 );
reconsider D287 = ( ( D286 `2 ) . C395 ) , D288 = ( ( D286 `2 ) . C394 ) as  finite (Subset of ( NAT ));
L1559: ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' D282 ) ) ) c= ( Seg ( C392 .order() ) ) by XBOOLE_1:36;
L1560: D287 c= ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' D282 ) ) ) by L1347;
L1561: D287 c= ( Seg ( C392 .order() ) ) by L1560 , L1559 , XBOOLE_1:1;
L1562: ( D284 `1 ) = D283 by L1050;
L1563: D288 c= ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' D282 ) ) ) by L1347;
L1564: D288 c= ( Seg ( C392 .order() ) ) by L1563 , L1559 , XBOOLE_1:1;
L1565: C396 in ( dom D285 ) by L1550 , L1551 , L1553 , L1548 , L1547 , L834;
L1566: ( D280 . C396 ) <= ( C392 .order() ) by L1548 , L1547 , L695;
L1567: ( ( C392 .order() ) -' ( D280 . C396 ) ) = ( ( C392 .order() ) - ( D280 . C396 ) ) by L1566 , XREAL_1:233;
L1568: D281 < ( C392 .order() ) by L1567 , L1553 , XREAL_1:44;
L1569: ( ( C392 .order() ) -' D281 ) = ( ( C392 .order() ) - ( ( C392 .order() ) - ( D280 . C396 ) ) ) by L1568 , L1567 , XREAL_1:233;
L1570:
now
L1571: ( rng D283 ) = ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' D281 ) ) ) by L1548 , L1547 , L666;
L1572: ( D280 . C394 ) < ( D280 . C396 ) by L1552 , L1553 , XXREAL_0:2;
assume L1573: C394 in ( dom D283 );
L1574: ( D283 . C394 ) in ( rng D283 ) by L1573 , FUNCT_1:def 3;
L1575: ( D280 . C396 ) < ( D283 . C394 ) by L1574 , L1569 , L1571 , L100;
thus L1576: contradiction by L1575 , L1549 , L1573 , L1572 , L762;
end;
L1577: ( ( ( LexBFS:CSeq C392 ) ``1 ) .PickedAt D281 ) = C396 by L1551 , L1548 , L1547 , L774;
L1578: C396 = ( LexBFS:PickUnnumbered D284 ) by L1577 , L1553 , L1567 , L1313 , XREAL_1:44;
L1579: D281 < D282 by L1553 , L1566 , L72;
set D289 = ( D285 . C396 );
L1580: ( D286 `1 ) = D285 by L1050;
L1581: C394 in ( C392 .AdjacentSet { C396 } ) by L1552 , L1553 , L1554 , CHORD:52;
L1582: ( D280 . C396 ) in D288 by L1581 , L1562 , L1568 , L1579 , L1578 , L1569 , L1570 , L1404;
L1583: ( D285 . C396 ) in D288 by L1582 , L1551 , L1565 , L762;
L1584: (not C395 in ( C392 .AdjacentSet { C396 } )) by L1555 , CHORD:52;
L1585:
now
assume L1586: ( D285 . C396 ) in D287;
L1587: (ex B364 being (Vertex of C392) st (B364 in ( dom D285 ) & ( D285 . B364 ) = ( D285 . C396 ) & C395 in ( C392 .AdjacentSet { B364 } ))) by L1586 , L1580 , L1520;
L1588: D285 is  one-to-one by L743;
thus L1589: contradiction by L1588 , L1584 , L1565 , L1587 , FUNCT_1:def 4;
end;
L1590: ( ( (D287 , 1) -bag ) . D289 ) = ( 0 ) by L1585 , UPROOTS:6;
L1591: ( ( (D287 , 1) -bag ) . D289 ) < ( ( (D288 , 1) -bag ) . D289 ) by L1590 , L1583 , UPROOTS:7;
L1592: [ ( (D287 , 1) -bag ) , ( (D288 , 1) -bag ) ] in ( InvLexOrder ( NAT ) )
proof
per cases ;
suppose L1593: (for B365 being Ordinal holds ((D289 in B365 & B365 in ( NAT )) implies ( ( (D287 , 1) -bag ) . B365 ) = ( ( (D288 , 1) -bag ) . B365 )));

thus L1594: thesis by L1593 , L1591 , BAGORDER:def 6;
end;
suppose L1595: (not (for B366 being Ordinal holds ((D289 in B366 & B366 in ( NAT )) implies ( ( (D287 , 1) -bag ) . B366 ) = ( ( (D288 , 1) -bag ) . B366 ))));

defpred S21[ Nat ] means (D289 in $1 & ( ( (D287 , 1) -bag ) . $1 ) <> ( ( (D288 , 1) -bag ) . $1 ));
L1596: (for B367 being Nat holds (S21[ B367 ] implies B367 <= ( C392 .order() )))
proof
let C397 being Nat;
assume that
L1597: S21[ C397 ];
L1598: (( ( (D288 , 1) -bag ) . C397 ) = 1 or ( ( (D288 , 1) -bag ) . C397 ) = ( 0 )) by UPROOTS:6 , UPROOTS:7;
L1599: C397 in ( NAT ) by ORDINAL1:def 12;
consider C398 being Ordinal such that L1600: C398 = C397 and L1601: D289 in C398 and L1602: C398 in ( NAT ) and L1603: ( ( (D287 , 1) -bag ) . C398 ) <> ( ( (D288 , 1) -bag ) . C398 ) by L1599 , L1597;
per cases ;
suppose L1604: (not C398 in D287);

L1605: C398 in D288 by L1604 , L1600 , L1603 , L1598 , UPROOTS:6;
thus L1606: thesis by L1605 , L1564 , L1600 , FINSEQ_1:1;
end;
suppose L1607: C398 in D287;

thus L1608: thesis by L1607 , L1561 , L1600 , FINSEQ_1:1;
end;
end;
L1610: (ex B368 being Nat st S21[ B368 ]) by L1595;
consider C399 being Nat such that L1611: S21[ C399 ] and L1612: (for B369 being Nat holds (S21[ B369 ] implies B369 <= C399)) from NAT_1:sch 6(L1596 , L1610);
reconsider D290 = C399 as (Element of ( NAT )) by ORDINAL1:def 12;
L1613:
now
let C400 being Ordinal;
assume that
L1614: D290 in C400
and
L1615: C400 in ( NAT );
reconsider D291 = C400 as (Element of ( NAT )) by L1615;
L1616: D290 in { B370 where B370 is (Element of ( NAT )) : B370 < D291 } by L1614 , AXIOMS:4;
L1617: (ex B371 being (Element of ( NAT )) st (B371 = D290 & B371 < D291)) by L1616;
assume L1618: ( ( (D287 , 1) -bag ) . C400 ) <> ( ( (D288 , 1) -bag ) . C400 );
thus L1619: contradiction by L1618 , L1611 , L1612 , L1614 , L1617 , ORDINAL1:10;
end;
L1620: D289 in { B372 where B372 is (Element of ( NAT )) : B372 < D290 } by L1611 , AXIOMS:4;
L1621: (ex B373 being (Element of ( NAT )) st (B373 = D289 & B373 < D290)) by L1620;
L1622:
now
assume L1623: ( ( (D287 , 1) -bag ) . D290 ) = 1;
L1624: D290 in D287 by L1623 , UPROOTS:6;
consider C401 being (Vertex of C392) such that L1625: C401 in ( dom ( D286 `1 ) ) and L1626: ( ( D286 `1 ) . C401 ) = D290 and L1627: C395 in ( C392 .AdjacentSet { C401 } ) by L1624 , L1520;
set D292 = ( ( C392 .order() ) -' ( D280 . C401 ) );
L1628: ( D280 . C401 ) <= ( C392 .order() ) by L1548 , L1547 , L695;
L1629: ( ( C392 .order() ) -' ( D280 . C401 ) ) = ( ( C392 .order() ) - ( D280 . C401 ) ) by L1628 , XREAL_1:233;
L1630: D282 < C393 by L1550 , L1548 , L1547 , L809;
L1631: ( D286 `1 ) c= ( D279 `1 ) by L1630 , L1545 , L1580 , L722;
L1632: ( dom ( D286 `1 ) ) c= ( dom ( D279 `1 ) ) by L1631 , RELAT_1:11;
L1633: ( 0 ) < ( D280 . C401 ) by L1632 , L1545 , L1625 , L695;
L1634: D292 < ( C392 .order() ) by L1633 , L1629 , XREAL_1:44;
L1635: ( ( C392 .order() ) -' D292 ) = ( ( C392 .order() ) - ( ( C392 .order() ) - ( D280 . C401 ) ) ) by L1634 , L1629 , XREAL_1:233;
set D293 = ( ( ( LexBFS:CSeq C392 ) ``1 ) . D292 );
set D294 = ( ( LexBFS:CSeq C392 ) . D292 );
L1636: C401 = ( ( ( LexBFS:CSeq C392 ) ``1 ) .PickedAt D292 ) by L1545 , L1548 , L1547 , L1625 , L1632 , L774;
L1637: C401 = ( LexBFS:PickUnnumbered D294 ) by L1636 , L1633 , L1629 , L1313 , XREAL_1:44;
L1638: [ C401 , D290 ] in ( D286 `1 ) by L1625 , L1626 , FUNCT_1:def 2;
L1639: ( D280 . C401 ) = D290 by L1638 , L1545 , L1625 , L1631 , L1632 , FUNCT_1:def 2;
L1640: [ C396 , D289 ] in ( D286 `1 ) by L1580 , L1565 , FUNCT_1:def 2;
L1641: ( D280 . C396 ) = D289 by L1640 , L1545 , L1551 , L1631 , FUNCT_1:def 2;
L1642: ( D280 . C395 ) < ( D280 . C401 ) by L1641 , L1553 , L1621 , L1639 , XXREAL_0:2;
L1643: D292 < D282 by L1642 , L1628 , L72;
L1644: ( D280 . C396 ) < ( D280 . C401 ) by L1545 , L1621 , L1625 , L1631 , L1632 , L1638 , L1641 , FUNCT_1:def 2;
L1645:
now
L1646: ( D280 . C394 ) < ( D280 . C396 ) by L1552 , L1553 , XXREAL_0:2;
L1647: ( D280 . C394 ) < ( D280 . C401 ) by L1646 , L1644 , XXREAL_0:2;
L1648: ( rng D293 ) = ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' D292 ) ) ) by L1548 , L1547 , L666;
assume L1649: C394 in ( dom D293 );
L1650: ( D293 . C394 ) in ( rng D293 ) by L1649 , FUNCT_1:def 3;
L1651: ( D280 . C401 ) < ( D293 . C394 ) by L1650 , L1635 , L1648 , L100;
thus L1652: contradiction by L1651 , L1549 , L1649 , L1647 , L762;
end;
L1653: ( D280 . C396 ) < ( D280 . C401 ) by L1545 , L1551 , L1621 , L1631 , L1639 , L1640 , FUNCT_1:def 2;
L1654: C395 , C401 are_adjacent  by L1627 , CHORD:52;
L1655: C401 , C394 are_adjacent  by L1654 , L1545 , L1558 , L1621 , L1625 , L1632 , L1639 , L1641;
L1656: C394 in ( C392 .AdjacentSet { C401 } ) by L1655 , L1556 , L1653 , CHORD:52;
L1657: ( D294 `1 ) = D293 by L1050;
L1658: ( ( C392 .order() ) -' D292 ) in ( ( D286 `2 ) . C394 ) by L1657 , L1656 , L1634 , L1643 , L1637 , L1645 , L1404;
thus L1659: contradiction by L1658 , L1611 , L1623 , L1639 , L1635 , UPROOTS:7;
end;
L1660: (( ( (D287 , 1) -bag ) . D290 ) = ( 0 ) or ( ( (D287 , 1) -bag ) . D290 ) = 1) by UPROOTS:6 , UPROOTS:7;
thus L1661: thesis by L1660 , L1611 , L1622 , L1613 , BAGORDER:def 6;
end;
end;
L1663: ( (D287 , 1) -bag ) <= ( (D288 , 1) -bag ) , ( InvLexOrder ( NAT ) ) by L1592 , TERMORD:def 2;
L1664: ( (D287 , 1) -bag ) <> ( (D288 , 1) -bag ) by L1583 , L1585 , L187;
L1665: ( (D287 , 1) -bag ) < ( (D288 , 1) -bag ) , ( InvLexOrder ( NAT ) ) by L1664 , L1663 , TERMORD:def 3;
L1666: ( (D288 , 1) -bag ) <= ( (D287 , 1) -bag ) , ( InvLexOrder ( NAT ) ) by L1545 , L1549 , L1550 , L1552 , L1499;
thus L1667: contradiction by L1666 , L1665 , TERMORD:5;
end;
L1668: (ex B374 being Nat st S20[ B374 ]) by L1557;
L1669: (for B375 being Nat holds (S20[ B375 ] implies B375 <= ( C392 .order() )))
proof
let C402 being Nat;
assume L1670: S20[ C402 ];
L1671: C402 in ( rng D280 ) by L1670 , FUNCT_1:def 3;
L1672: C402 in ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' C393 ) ) ) by L1671 , L1548 , L1547 , L666;
L1673: ( ( Seg ( C392 .order() ) ) \ ( Seg ( ( C392 .order() ) -' C393 ) ) ) c= ( Seg ( C392 .order() ) ) by XBOOLE_1:36;
thus L1674: thesis by L1673 , L1672 , FINSEQ_1:1;
end;
L1675: (ex B376 being Nat st (S20[ B376 ] & (for B377 being Nat holds (S20[ B377 ] implies B377 <= B376)))) from NAT_1:sch 6(L1669 , L1668);
consider C403 being Nat such that L1676: S20[ C403 ] and L1677: (for B378 being Nat holds (S20[ B378 ] implies B378 <= C403)) by L1675;
consider C404 being (Vertex of C392) such that L1678: C404 in ( dom D280 ) and L1679: C395 , C404 are_adjacent  and L1680: (not C394 , C404 are_adjacent ) and L1681: ( D280 . C396 ) < ( D280 . C404 ) and L1682: ( D280 . C404 ) = C403 by L1676;
L1683: (for B379 being (Vertex of C392) holds ((B379 <> C404 & B379 , C395 are_adjacent  & (not B379 , C394 are_adjacent )) implies ( D280 . B379 ) < ( D280 . C404 )))
proof
let C405 being (Vertex of C392);
assume that
L1684: C405 <> C404
and
L1685: C405 , C395 are_adjacent 
and
L1686: (not C405 , C394 are_adjacent );
per cases ;
suppose L1687: ( D280 . C405 ) <= ( D280 . C396 );

thus L1688: thesis by L1687 , L1681 , XXREAL_0:2;
end;
suppose L1689: ( D280 . C396 ) < ( D280 . C405 );

L1690: C405 in ( dom D280 ) by L1689 , FUNCT_1:def 2;
L1691: D280 is  one-to-one by L743;
L1692: ( D280 . C405 ) <> ( D280 . C404 ) by L1691 , L1678 , L1684 , L1690 , FUNCT_1:def 4;
L1693: ( D280 . C405 ) <= C403 by L1677 , L1685 , L1686 , L1689 , L1690;
thus L1694: thesis by L1693 , L1682 , L1692 , XXREAL_0:1;
end;
end;
thus L1696: (ex B380 being (Vertex of C392) st (B380 in ( dom D280 ) & ( D280 . C396 ) < ( D280 . B380 ) & C395 , B380 are_adjacent  & (not C394 , B380 are_adjacent ) & (for B381 being (Vertex of C392) holds ((B381 <> B380 & B381 , C395 are_adjacent  & (not B381 , C394 are_adjacent )) implies ( D280 . B381 ) < ( D280 . B380 ))))) by L1683 , L1678 , L1679 , L1680 , L1681;
end;
thus L1697: thesis by L1546 , L1545 , L1542;
end;
theorem
L1698: (for B382 being  finite  chordal _Graph holds (for B383 being (PartFunc of ( the_Vertices_of B382 ) , ( NAT )) holds ((B383 is  with_property_L3 & ( dom B383 ) = ( the_Vertices_of B382 )) implies (for B384 being (VertexScheme of B382) holds (( B384 " ) = B383 implies B384 is  perfect)))))
proof
let C406 being  finite  chordal _Graph;
let C407 being (PartFunc of ( the_Vertices_of C406 ) , ( NAT ));
assume that
L1699: C407 is  with_property_L3
and
L1700: ( dom C407 ) = ( the_Vertices_of C406 );
let C408 being (VertexScheme of C406);
assume that
L1701: ( C408 " ) = C407;
L1702: C408 is  one-to-one by CHORD:def 12;
L1703: (for B385 , B386 being (Vertex of C406) holds (for B387 , B388 being Nat holds ((B387 in ( dom C408 ) & B388 in ( dom C408 ) & ( C408 /. B387 ) = B385 & ( C408 /. B388 ) = B386) implies (B387 < B388 iff ( C407 . B385 ) < ( C407 . B386 )))))
proof
let C409 , C410 being (Vertex of C406);
let C411 , C412 being Nat;
assume that
L1704: C411 in ( dom C408 )
and
L1705: C412 in ( dom C408 )
and
L1706: ( C408 /. C411 ) = C409
and
L1707: ( C408 /. C412 ) = C410;
L1708: ( C408 . C412 ) = C410 by L1705 , L1707 , PARTFUN1:def 6;
L1709: ( C407 . C410 ) = C412 by L1708 , L1701 , L1702 , L1705 , FUNCT_1:34;
L1710: ( C408 . C411 ) = C409 by L1704 , L1706 , PARTFUN1:def 6;
thus L1711: (C411 < C412 implies ( C407 . C409 ) < ( C407 . C410 )) by L1710 , L1701 , L1702 , L1704 , L1709 , FUNCT_1:34;
thus L1712: thesis by L1701 , L1702 , L1704 , L1710 , L1709 , FUNCT_1:34;
end;
defpred S22[ Nat ] means (ex B389 being (Walk of C406) st (ex B390 , B391 , B392 , B393 being (Vertex of C406) st (B389 is  Path-like & B389 is  open & B389 is  chordless & ( B389 .length() ) = ( $1 - 1 ) & B390 = ( B389 . ( ( len B389 ) - 2 ) ) & B391 = ( B389 . 3 ) & B392 = ( B389 .last() ) & B393 = ( B389 .first() ) & ( C407 . B393 ) > ( C407 . B392 ) & ( C407 . B392 ) > ( C407 . B391 ) & ( C407 . B391 ) > ( C407 . B390 ) & (for B394 being set holds (B394 in ( B389 .vertices() ) implies ( C407 . B394 ) <= ( C407 . B393 ))) & (for B395 being (Vertex of C406) holds ((B395 <> B393 & B395 , B391 are_adjacent  & (not B395 , B390 are_adjacent )) implies ( C407 . B395 ) < ( C407 . B393 ))))));
L1713: (for B396 being Nat holds ((4 <= B396 & S22[ B396 ]) implies S22[ ( B396 + 1 ) ]))
proof
L1714: ( ( 2 * ( 0 ) ) + 1 ) < ( ( 2 * 1 ) + 1 );
let C413 being Nat;
assume that
L1715: 4 <= C413
and
L1716: S22[ C413 ];
reconsider D295 = C413 as non  empty Nat by L1715;
consider C414 being (Walk of C406), C415 , C416 , C417 , C418 being (Vertex of C406) such that L1717: C414 is  Path-like and L1718: C414 is  open and L1719: C414 is  chordless and L1720: ( C414 .length() ) = ( D295 - 1 ) and L1721: C415 = ( C414 . ( ( len C414 ) - 2 ) ) and L1722: C416 = ( C414 . 3 ) and L1723: C417 = ( C414 .last() ) and L1724: C418 = ( C414 .first() ) and L1725: ( C407 . C418 ) > ( C407 . C417 ) and L1726: ( C407 . C417 ) > ( C407 . C416 ) and L1727: ( C407 . C416 ) > ( C407 . C415 ) and L1728: (for B397 being set holds (B397 in ( C414 .vertices() ) implies ( C407 . B397 ) <= ( C407 . C418 ))) and L1729: (for B398 being (Vertex of C406) holds ((B398 <> C418 & B398 , C416 are_adjacent  & (not B398 , C415 are_adjacent )) implies ( C407 . B398 ) < ( C407 . C418 ))) by L1716;
L1730: ( len C414 ) = ( ( 2 * ( D295 - 1 ) ) + 1 ) by L1720 , GLIB_001:112;
L1731: ( 2 * D295 ) >= ( 2 * 4 ) by L1715 , XREAL_1:64;
L1732: ( ( 2 * D295 ) - 1 ) >= ( 8 - 1 ) by L1731 , XREAL_1:9;
L1733: 1 <= ( len C414 ) by L1732 , L1730 , XXREAL_0:2;
L1734: ( len C414 ) in ( dom C414 ) by L1733 , FINSEQ_3:25;
L1735:
now
L1736: ( ( 2 * ( 0 ) ) + 1 ) < ( len C414 ) by L1730 , L1732 , XXREAL_0:2;
let C419 being set;
assume L1737: C419 Joins C418 , C417 , C406;
L1738: ( 1 + 2 ) = ( len C414 ) by L1737 , L1717 , L1718 , L1719 , L1723 , L1724 , L1736 , CHORD:92;
thus L1739: contradiction by L1738 , L1715 , L1730;
end;
L1740: (not C418 , C417 are_adjacent ) by L1735 , CHORD:def 3;
L1741: 3 < ( len C414 ) by L1730 , L1732 , XXREAL_0:2;
L1742: (ex B399 being set st B399 Joins ( C414 . 1 ) , ( C414 . 3 ) , C406) by L1741 , L1717 , L1718 , L1719 , L1714 , CHORD:92;
L1743: C418 , C416 are_adjacent  by L1742 , L1722 , L1724 , CHORD:def 3;
consider C420 being (Vertex of C406) such that L1744: C420 in ( dom C407 ) and L1745: ( C407 . C418 ) < ( C407 . C420 ) and L1746: C420 , C417 are_adjacent  and L1747: (not C420 , C416 are_adjacent ) and L1748: (for B400 being (Vertex of C406) holds ((B400 <> C420 & B400 , C417 are_adjacent  & (not B400 , C416 are_adjacent )) implies ( C407 . B400 ) < ( C407 . C420 ))) by L1743 , L1699 , L1700 , L1725 , L1726 , L1740 , L1542;
consider C421 being set such that L1749: C421 Joins ( C414 .last() ) , C420 , C406 by L1723 , L1746 , CHORD:def 3;
L1750:
now
L1751: ( C407 . C416 ) < ( C407 . C418 ) by L1725 , L1726 , XXREAL_0:2;
L1752: ( C407 . C416 ) < ( C407 . C420 ) by L1751 , L1745 , XXREAL_0:2;
assume L1753: C420 , C415 are_adjacent ;
consider C422 being (Vertex of C406) such that L1754: C422 in ( dom C407 ) and L1755: ( C407 . C420 ) < ( C407 . C422 ) and L1756: C422 , C416 are_adjacent  and L1757: (not C422 , C415 are_adjacent ) and L1758: (for B401 being (Vertex of C406) holds ((B401 <> C422 & B401 , C416 are_adjacent  & (not B401 , C415 are_adjacent )) implies ( C407 . B401 ) < ( C407 . C422 ))) by L1753 , L1699 , L1700 , L1727 , L1747 , L1752 , L1542;
thus L1759: contradiction by L1729 , L1745 , L1755 , L1756 , L1757 , XXREAL_0:2;
end;
L1760: (not (ex B402 being set st B402 Joins ( C414 . ( ( len C414 ) - 2 ) ) , C420 , C406)) by L1750 , L1721 , CHORD:def 3;
set D296 = ( C414 .addEdge C421 );
set D297 = ( D296 .reverse() );
L1761: ( len D297 ) = ( len D296 ) by GLIB_001:21;
L1762: (not C420 in ( C414 .vertices() )) by L1728 , L1745;
L1763: D296 is  open by L1762 , L1717 , L1718 , L1719 , L1749 , L1760 , CHORD:97;
L1764: D297 is  open by L1763 , GLIB_001:120;
L1765: 3 <= ( len C414 ) by L1730 , L1732 , XXREAL_0:2;
L1766: 3 in ( dom C414 ) by L1765 , FINSEQ_3:25;
L1767: 3 in ( dom D296 ) by L1766 , L1749 , L330;
L1768: C416 = ( D296 . 3 ) by L1722 , L1749 , L1766 , L330;
L1769: C416 = ( D297 . ( ( ( len D297 ) - 3 ) + 1 ) ) by L1768 , L1767 , L1761 , GLIB_001:24;
L1770: C418 = ( D296 .first() ) by L1724 , L1749 , GLIB_001:63;
L1771: C418 = ( D297 .last() ) by L1770 , GLIB_001:22;
L1772: ( len D296 ) = ( ( len C414 ) + 2 ) by L1749 , GLIB_001:64;
L1773: ( ( len D296 ) - 2 ) in ( dom D296 ) by L1772 , L1749 , L1734 , L330;
L1774: C417 = ( D296 . ( ( len D296 ) - 2 ) ) by L1723 , L1749 , L1772 , L1734 , L330;
L1775: C417 = ( D297 . ( ( ( len D297 ) - ( ( len D296 ) - 2 ) ) + 1 ) ) by L1774 , L1773 , L1761 , GLIB_001:24;
L1776: C420 = ( D296 .last() ) by L1749 , GLIB_001:63;
L1777: C420 = ( D297 .first() ) by L1776 , GLIB_001:22;
L1778: D296 is  chordless by L1717 , L1718 , L1719 , L1749 , L1762 , L1760 , CHORD:97;
L1779: D297 is  chordless by L1778 , CHORD:91;
L1780: ( D296 .length() ) = ( ( D295 - 1 ) + 1 ) by L1720 , L1749 , L320;
L1781: ( D297 .length() ) = ( ( D295 + 1 ) - 1 ) by L1780 , L325;
L1782:
now
let C423 being set;
assume L1783: C423 in ( D297 .vertices() );
L1784: C423 in ( D296 .vertices() ) by L1783 , GLIB_001:92;
L1785: C423 in ( ( C414 .vertices() ) \/ { C420 } ) by L1784 , L1749 , GLIB_001:95;
per cases  by L1785 , XBOOLE_0:def 3;
suppose L1786: C423 in ( C414 .vertices() );

L1787: ( C407 . C423 ) <= ( C407 . C418 ) by L1786 , L1728;
thus L1788: ( C407 . C423 ) <= ( C407 . C420 ) by L1787 , L1745 , XXREAL_0:2;
end;
suppose L1789: C423 in { C420 };

thus L1790: ( C407 . C423 ) <= ( C407 . C420 ) by L1789 , TARSKI:def 1;
end;
end;
L1792: D296 is  Path-like by L1717 , L1718 , L1719 , L1749 , L1762 , L1760 , CHORD:97;
thus L1793: thesis by L1792 , L1725 , L1726 , L1745 , L1748 , L1764 , L1779 , L1781 , L1761 , L1769 , L1775 , L1771 , L1777 , L1782;
end;
L1794: 11 <= ( 11 + ( C406 .order() ) ) by NAT_1:11;
assume L1795: (not C408 is  perfect);
consider C424 being non  empty Nat such that L1796: C424 <= ( len C408 ) and L1797: (not (for B403 being (inducedSubgraph of C406 , ( C408 .followSet C424 )) holds (for B404 being (Vertex of B403) holds (B404 = ( C408 . C424 ) implies B404 is  simplicial)))) by L1795 , CHORD:def 13;
consider C425 being (inducedSubgraph of C406 , ( C408 .followSet C424 )), C426 being (Vertex of C425) such that L1798: C426 = ( C408 . C424 ) and L1799: (not C426 is  simplicial) by L1797;
consider C427 , C428 being (Vertex of C425) such that L1800: C427 <> C428 and L1801: C426 <> C427 and L1802: C426 <> C428 and L1803: C426 , C427 are_adjacent  and L1804: C426 , C428 are_adjacent  and L1805: (not C427 , C428 are_adjacent ) by L1799 , CHORD:69;
L1806: C426 in ( the_Vertices_of C425 );
L1807: C428 in ( the_Vertices_of C425 );
L1808: C427 in ( the_Vertices_of C425 );
reconsider D298 = C426 , D299 = C427 , D300 = C428 as (Vertex of C406) by L1808 , L1806 , L1807;
L1809: ( C408 .followSet C424 ) is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of C406 )) by L1796 , CHORD:107;
L1810: ( the_Vertices_of C425 ) = ( C408 .followSet C424 ) by L1809 , GLIB_000:def 37;
L1811:
now
L1812: ( C407 . D299 ) <> ( C407 . D300 ) by L1700 , L1701 , L1702 , L1800 , FUNCT_1:def 4;
per cases  by L1812 , XXREAL_0:1;
suppose L1813: ( C407 . D299 ) < ( C407 . D300 );

take D301 = D299;
take D302 = D300;
thus L1814: D301 in ( C408 .followSet C424 ) by L1810;
thus L1815: ( C407 . D301 ) < ( C407 . D302 ) by L1813;
thus L1816: D298 , D301 are_adjacent  by L1803 , L1809 , CHORD:45;
thus L1817: D298 , D302 are_adjacent  by L1804 , L1809 , CHORD:45;
thus L1818: (not D301 , D302 are_adjacent ) by L1805 , L1809 , CHORD:45;
end;
suppose L1819: ( C407 . D299 ) > ( C407 . D300 );

take D303 = D300;
take D304 = D299;
thus L1820: D303 in ( C408 .followSet C424 ) by L1810;
thus L1821: ( C407 . D304 ) > ( C407 . D303 ) by L1819;
thus L1822: D298 , D303 are_adjacent  by L1804 , L1809 , CHORD:45;
thus L1823: D298 , D304 are_adjacent  by L1803 , L1809 , CHORD:45;
thus L1824: (not D303 , D304 are_adjacent ) by L1805 , L1809 , CHORD:45;
end;
end;
consider C429 , C430 being (Vertex of C406) such that L1826: C429 in ( C408 .followSet C424 ) and L1827: ( C407 . C429 ) < ( C407 . C430 ) and L1828: D298 , C429 are_adjacent  and L1829: D298 , C430 are_adjacent  and L1830: (not C429 , C430 are_adjacent ) by L1811;
defpred S23[ Nat ] means ($1 in ( dom C408 ) & ( C407 . C429 ) < ( C407 . ( C408 /. $1 ) ) & C429 <> ( C408 /. $1 ) & D298 , ( C408 /. $1 ) are_adjacent  & (not C429 , ( C408 /. $1 ) are_adjacent ));
L1831: ( rng C408 ) = ( the_Vertices_of C406 ) by CHORD:def 12;
L1832: (ex B405 being Nat st S23[ B405 ])
proof
consider C431 being set such that L1833: C431 in ( dom C408 ) and L1834: C430 = ( C408 . C431 ) by L1831 , FUNCT_1:def 3;
reconsider D305 = C431 as (Element of ( NAT )) by L1833;
take D305;
thus L1835: D305 in ( dom C408 ) by L1833;
thus L1836: ( C407 . C429 ) < ( C407 . ( C408 /. D305 ) ) by L1827 , L1833 , L1834 , PARTFUN1:def 6;
thus L1837: C429 <> ( C408 /. D305 ) by L1827 , L1833 , L1834 , PARTFUN1:def 6;
thus L1838: D298 , ( C408 /. D305 ) are_adjacent  by L1829 , L1833 , L1834 , PARTFUN1:def 6;
thus L1839: thesis by L1830 , L1833 , L1834 , PARTFUN1:def 6;
end;
L1840: (for B406 being Nat holds (S23[ B406 ] implies B406 <= ( len C408 ))) by FINSEQ_3:25;
consider C432 being Nat such that L1841: S23[ C432 ] and L1842: (for B407 being Nat holds (S23[ B407 ] implies B407 <= C432)) from NAT_1:sch 6(L1840 , L1832);
reconsider D306 = D298 , D307 = C429 , D308 = ( C408 /. C432 ) as (Vertex of C406);
consider C433 being set such that L1843: C433 in ( dom C408 ) and L1844: D307 = ( C408 . C433 ) by L1831 , FUNCT_1:def 3;
reconsider D309 = C433 as (Element of ( NAT )) by L1843;
L1845: D307 = ( C408 /. D309 ) by L1843 , L1844 , PARTFUN1:def 6;
L1846: ( ( 0 ) + 1 ) <= C424 by NAT_1:13;
L1847: C424 in ( dom C408 ) by L1846 , L1796 , FINSEQ_3:25;
L1848:
now
assume L1849: D309 <= C424;
L1850: D309 < C424 by L1849 , L1798 , L1829 , L1830 , L1844 , XXREAL_0:1;
L1851: D307 in ( the_Vertices_of C406 );
L1852: D307 in ( rng C408 ) by L1851 , CHORD:def 12;
L1853: C408 is  one-to-one by CHORD:def 12;
L1854: ( D307 .. C408 ) >= C424 by L1853 , L1826 , L1847 , L1852 , CHORD:16;
L1855: ( D307 .. C408 ) > D309 by L1854 , L1850 , XXREAL_0:2;
thus L1856: contradiction by L1855 , L1843 , L1844 , FINSEQ_4:24;
end;
L1857: D306 = ( C408 /. C424 ) by L1798 , L1847 , PARTFUN1:def 6;
L1858: ( C407 . D306 ) < ( C407 . D307 ) by L1857 , L1703 , L1847 , L1843 , L1845 , L1848;
L1859: D306 <> D308 by L1828 , L1841;
L1860: S22[ 4 ]
proof
L1861: ( C407 . D307 ) > ( C407 . D306 ) by L1703 , L1847 , L1857 , L1843 , L1845 , L1848;
consider C434 being (Vertex of C406) such that L1862: C434 in ( dom C407 ) and L1863: ( C407 . D308 ) < ( C407 . C434 ) and L1864: C434 , D307 are_adjacent  and L1865: (not C434 , D306 are_adjacent ) and L1866: (for B408 being (Vertex of C406) holds ((B408 <> C434 & B408 , D307 are_adjacent  & (not B408 , D306 are_adjacent )) implies ( C407 . B408 ) < ( C407 . C434 ))) by L1699 , L1700 , L1841 , L1858 , L1542;
consider C435 being (Path of C406), C436 , C437 being set such that L1867: C435 is  open and L1868: ( len C435 ) = 5 and L1869: ( C435 .length() ) = 2 and L1870: C436 Joins D308 , D306 , C406 and L1871: C437 Joins D306 , D307 , C406 and L1872: ( C435 .edges() ) = { C436 , C437 } and L1873: ( C435 .vertices() ) = { D308 , D306 , D307 } and L1874: ( C435 . 1 ) = D308 and L1875: ( C435 . 3 ) = D306 and L1876: ( C435 . 5 ) = D307 by L1828 , L1841 , L1859 , CHORD:47;
consider C438 being set such that L1877: C438 Joins ( C435 .last() ) , C434 , C406 by L1864 , L1868 , L1876 , CHORD:def 3;
set D310 = ( C435 .addEdge C438 );
set D311 = ( D310 .reverse() );
L1878: ( D310 .last() ) = C434 by L1877 , GLIB_001:63;
L1879: ( len D310 ) = ( 5 + 2 ) by L1868 , L1877 , GLIB_001:64;
L1880: 1 in ( dom D310 ) by L1879 , FINSEQ_3:25;
L1881: 5 in ( dom C435 ) by L1868 , FINSEQ_3:25;
L1882: ( D310 . 5 ) = D307 by L1881 , L1876 , L1877 , GLIB_001:65;
L1883: 5 in ( dom D310 ) by L1879 , FINSEQ_3:25;
L1884: D307 = ( D311 . ( ( 7 - 5 ) + 1 ) ) by L1883 , L1879 , L1882 , GLIB_001:24;
L1885: 7 in ( dom D310 ) by L1879 , FINSEQ_3:25;
L1886: C434 = ( D311 . ( ( 7 - 7 ) + 1 ) ) by L1885 , L1879 , L1878 , GLIB_001:24;
L1887: C434 = ( D311 .first() ) by L1886;
L1888: 3 in ( dom C435 ) by L1868 , FINSEQ_3:25;
L1889: ( D310 . 3 ) = D306 by L1888 , L1875 , L1877 , GLIB_001:65;
L1890: ( D310 .length() ) = ( 2 + 1 ) by L1869 , L1877 , L320;
L1891: ( D311 .length() ) = ( ( 3 + 1 ) - 1 ) by L1890 , L325;
L1892: 1 in ( dom C435 ) by L1868 , FINSEQ_3:25;
L1893: ( D310 . 1 ) = D308 by L1892 , L1874 , L1877 , GLIB_001:65;
L1894: D308 = ( D311 . ( ( ( len D310 ) - 1 ) + 1 ) ) by L1893 , L1880 , GLIB_001:24;
L1895: D308 = ( D311 .last() ) by L1894 , GLIB_001:21;
L1896: ( len D311 ) = ( len D310 ) by GLIB_001:21;
L1897: ( C435 .first() ) = D308 by L1874;
L1898: ( C435 .last() ) = D307 by L1868 , L1876;
L1899: C435 is  chordless by L1898 , L1841 , L1868 , L1897 , CHORD:90;
L1900:
now
let C439 being set;
assume that
L1901: C439 in ( C435 .vertices() );
per cases  by L1873 , L1901 , ENUMSET1:def 1;
suppose L1902: C439 = D308;

thus L1903: ( C407 . C439 ) <= ( C407 . D308 ) by L1902;
end;
suppose L1904: C439 = D306;

thus L1905: ( C407 . C439 ) <= ( C407 . D308 ) by L1904 , L1841 , L1858 , XXREAL_0:2;
end;
suppose L1906: C439 = D307;

thus L1907: ( C407 . C439 ) <= ( C407 . D308 ) by L1906 , L1841;
end;
end;
L1909: (not C434 in ( C435 .vertices() )) by L1900 , L1863;
L1910: (not (ex B409 being set st B409 Joins ( C435 . ( ( len C435 ) - 2 ) ) , C434 , C406)) by L1865 , L1868 , L1875 , CHORD:def 3;
L1911: D310 is  open by L1910 , L1867 , L1899 , L1877 , L1909 , CHORD:97;
L1912: D311 is  open by L1911 , GLIB_001:120;
L1913:
now
let C440 being set;
assume L1914: C440 in ( D311 .vertices() );
L1915: C440 in ( D310 .vertices() ) by L1914 , GLIB_001:92;
L1916: C440 in ( ( C435 .vertices() ) \/ { C434 } ) by L1915 , L1877 , GLIB_001:95;
per cases  by L1916 , XBOOLE_0:def 3;
suppose L1917: C440 in ( C435 .vertices() );

L1918: ( C407 . C440 ) <= ( C407 . D308 ) by L1917 , L1900;
thus L1919: ( C407 . C440 ) <= ( C407 . C434 ) by L1918 , L1863 , XXREAL_0:2;
end;
suppose L1920: C440 in { C434 };

thus L1921: ( C407 . C440 ) <= ( C407 . C434 ) by L1920 , TARSKI:def 1;
end;
end;
L1923: 3 in ( dom D310 ) by L1879 , FINSEQ_3:25;
L1924: D306 = ( D311 . ( ( 7 - 3 ) + 1 ) ) by L1923 , L1879 , L1889 , GLIB_001:24;
L1925: D306 = ( D311 . ( ( len D311 ) - 2 ) ) by L1924 , L1879 , L1896;
L1926: D310 is  chordless by L1867 , L1899 , L1877 , L1909 , L1910 , CHORD:97;
L1927: D311 is  chordless by L1926 , CHORD:91;
L1928: D310 is  Path-like by L1867 , L1899 , L1877 , L1909 , L1910 , CHORD:97;
thus L1929: thesis by L1928 , L1841 , L1863 , L1866 , L1912 , L1927 , L1891 , L1884 , L1925 , L1895 , L1887 , L1861 , L1913;
end;
L1930: (for B410 being Nat holds (4 <= B410 implies S22[ B410 ])) from NAT_1:sch 8(L1860 , L1713);
L1931: S22[ ( ( C406 .order() ) + 11 ) ] by L1930 , L1794 , XXREAL_0:2;
consider C441 being (Walk of C406), C442 , C443 , C444 , C445 being (Vertex of C406) such that L1932: C441 is  Path-like and L1933: C441 is  open and L1934: C441 is  chordless and L1935: ( C441 .length() ) = ( ( ( C406 .order() ) + 11 ) - 1 ) and L1936: C442 = ( C441 . ( ( len C441 ) - 2 ) ) and L1937: C443 = ( C441 . 3 ) and L1938: C444 = ( C441 .last() ) and L1939: C445 = ( C441 .first() ) and L1940: ( C407 . C445 ) > ( C407 . C444 ) and L1941: ( C407 . C444 ) > ( C407 . C443 ) and L1942: ( C407 . C443 ) > ( C407 . C442 ) and L1943: (for B411 being (Vertex of C406) holds ((B411 <> C445 & B411 , C443 are_adjacent  & (not B411 , C442 are_adjacent )) implies ( C407 . B411 ) < ( C407 . C445 ))) by L1931;
L1944: ( len C441 ) = ( ( 2 * ( ( C406 .order() ) + 10 ) ) + 1 ) by L1935 , GLIB_001:112;
L1945: ( ( ( 2 * ( C406 .order() ) ) + 21 ) + 1 ) = ( 2 * ( len ( C441 .vertexSeq() ) ) ) by L1944 , GLIB_001:def 14;
L1946: ( ( C406 .order() ) + 11 ) <= ( ( C406 .order() ) + 1 ) by L1945 , L1932 , GLIB_001:154;
thus L1947: contradiction by L1946 , XREAL_1:8;
end;
theorem
L1948: (for B412 being  finite  chordal _Graph holds ( ( ( ( LexBFS:CSeq B412 ) .Result() ) `1 ) " ) is  perfect  perfect  perfect  perfect (VertexScheme of B412))
proof
let C446 being  finite  chordal _Graph;
set D312 = ( ( ( LexBFS:CSeq C446 ) .Result() ) `1 );
reconsider D313 = ( D312 " ) as (VertexScheme of C446) by L1486;
L1949: ( dom D312 ) = ( the_Vertices_of C446 ) by L1483;
L1950: D312 = ( ( ( LexBFS:CSeq C446 ) ``1 ) .Result() ) by L1311;
L1951: D312 is  one-to-one by L1950 , L743;
L1952: ( D313 " ) = D312 by L1951 , FUNCT_1:43;
L1953: D312 is  with_property_L3 by L1544;
thus L1954: thesis by L1953 , L1949 , L1952 , L1698;
end;
begin
definition
let C447 being _Graph;
mode MCS:Labeling of C447
 is (Element of [: ( PFuncs (( the_Vertices_of C447 ) , ( NAT )) ) , ( Funcs (( the_Vertices_of C447 ) , ( NAT )) ) :]);
end;
definition
let C448 being  finite _Graph;
func MCS:Init C448 -> (MCS:Labeling of C448) equals 
[ ( {} ) , ( ( the_Vertices_of C448 ) --> ( 0 ) ) ];
coherence
proof
set D314 = ( ( the_Vertices_of C448 ) --> ( 0 ) );
L1956: ( rng ( {} ) ) c= ( NAT );
L1957: ( rng D314 ) c= ( NAT ) by RELAT_1:def 19;
L1958: ( dom D314 ) = ( the_Vertices_of C448 ) by FUNCOP_1:13;
L1959: D314 in ( Funcs (( the_Vertices_of C448 ) , ( NAT )) ) by L1958 , L1957 , FUNCT_2:def 2;
L1960: ( dom ( {} ) ) c= ( the_Vertices_of C448 ) by XBOOLE_1:2;
L1961: ( {} ) in ( PFuncs (( the_Vertices_of C448 ) , ( NAT )) ) by L1960 , L1956 , PARTFUN1:def 3;
thus L1962: thesis by L1961 , L1959 , ZFMISC_1:def 2;
end;
end;
definition
let C449 being  finite _Graph;
let C450 being (MCS:Labeling of C449);
func MCS:PickUnnumbered C450 -> (Vertex of C449) means 
:L1964: it = ( choose ( the_Vertices_of C449 ) ) if ( dom ( C450 `1 ) ) = ( the_Vertices_of C449 ) otherwise (ex B413 being  finite non  empty  natural-membered set st (ex B414 being Function st (B413 = ( rng B414 ) & B414 = ( ( C450 `2 ) | ( ( the_Vertices_of C449 ) \ ( dom ( C450 `1 ) ) ) ) & it = ( choose ( B414 " { ( max B413 ) } ) ))));
existence
proof
set D315 = ( the_Vertices_of C449 );
set D316 = ( C450 `2 );
set D317 = ( C450 `1 );
set D318 = ( D316 | ( D315 \ ( dom D317 ) ) );
set D319 = ( rng D318 );
per cases ;
suppose L1965: ( dom D317 ) = D315;

thus L1966: thesis by L1965;
end;
suppose L1967: ( dom D317 ) <> D315;

L1968: ( dom D318 ) = ( ( dom D316 ) /\ ( D315 \ ( dom D317 ) ) ) by RELAT_1:61;
L1969: ( dom D316 ) = D315 by FUNCT_2:def 1;
L1970: ( dom D318 ) = ( ( D315 /\ D315 ) \ ( dom D317 ) ) by L1969 , L1968 , XBOOLE_1:49;
L1971:
now
assume L1972: ( dom D318 ) = ( {} );
L1973: D315 c= ( dom D317 ) by L1972 , L1970 , XBOOLE_1:37;
thus L1974: contradiction by L1973 , L1967 , XBOOLE_0:def 10;
end;
reconsider D320 = D319 as non  empty  finite  natural-membered set by L1971 , RELAT_1:42;
set D321 = ( max D320 );
set D322 = ( choose ( D318 " { ( max D320 ) } ) );
L1975: D321 in D320 by XXREAL_2:def 8;
L1976: ( D318 " { ( max D320 ) } ) is non  empty by L1975 , FUNCT_1:72;
L1977: D322 in ( dom D318 ) by L1976 , FUNCT_1:def 7;
L1978: D322 in ( dom D316 ) by L1977 , RELAT_1:57;
reconsider D323 = D322 as (Vertex of C449) by L1978;
L1979: (ex B415 being  finite non  empty  natural-membered set st (ex B416 being Function st (B415 = ( rng B416 ) & B416 = ( ( C450 `2 ) | ( ( the_Vertices_of C449 ) \ ( dom ( C450 `1 ) ) ) ) & D323 = ( choose ( B416 " { ( max B415 ) } ) ) & D323 is (Vertex of C449))));
thus L1980: thesis by L1979;
end;
end;
uniqueness;
consistency;
end;
definition
let C451 being  finite _Graph;
let C452 being (MCS:Labeling of C451);
let C453 being set;
func MCS:LabelAdjacent (C452 , C453) -> (MCS:Labeling of C451) equals 
[ ( C452 `1 ) , ( ( C452 `2 ) .incSubset (( ( C451 .AdjacentSet { C453 } ) \ ( dom ( C452 `1 ) ) ) , 1) ) ];
coherence
proof
set D324 = ( C452 `2 );
set D325 = ( C452 `1 );
set D326 = ( D324 .incSubset (( ( C451 .AdjacentSet { C453 } ) \ ( dom D325 ) ) , 1) );
L1983:
now
let C454 being set;
assume L1984: C454 in ( rng D326 );
L1985: (ex B417 being set st (B417 in ( dom D326 ) & ( D326 . B417 ) = C454)) by L1984 , FUNCT_1:def 3;
thus L1986: C454 in ( NAT ) by L1985;
end;
L1987: ( rng D326 ) c= ( NAT ) by L1983 , TARSKI:def 3;
L1988: ( dom D326 ) = ( dom D324 ) by L194;
L1989: ( dom D326 ) = ( the_Vertices_of C451 ) by L1988 , FUNCT_2:def 1;
L1990: D326 is (Function of ( the_Vertices_of C451 ) , ( NAT )) by L1989 , L1987 , FUNCT_2:2;
L1991: D326 in ( Funcs (( the_Vertices_of C451 ) , ( NAT )) ) by L1990 , FUNCT_2:8;
thus L1992: thesis by L1991 , ZFMISC_1:87;
end;
end;
definition
let C455 being  finite _Graph;
let C456 being (MCS:Labeling of C455);
let C457 being (Vertex of C455);
let C458 being Nat;
func MCS:Update (C456 , C457 , C458) -> (MCS:Labeling of C455) means 
:L1994: (ex B418 being (MCS:Labeling of C455) st (B418 = [ ( ( C456 `1 ) +* ( C457 .--> ( ( C455 .order() ) -' C458 ) ) ) , ( C456 `2 ) ] & it = ( MCS:LabelAdjacent (B418 , C457) )));
existence
proof
set D327 = ( ( C455 .order() ) -' C458 );
set D328 = ( ( C456 `1 ) +* ( C457 .--> D327 ) );
L1995: ( dom D328 ) = ( ( dom ( C456 `1 ) ) \/ { C457 } ) by L1;
L1996: ( rng ( C457 .--> D327 ) ) c= { D327 } by FUNCOP_1:13;
L1997: ( rng ( C457 .--> D327 ) ) c= ( NAT ) by L1996 , XBOOLE_1:1;
L1998: ( ( rng ( C456 `1 ) ) \/ ( rng ( C457 .--> D327 ) ) ) c= ( NAT ) by L1997 , XBOOLE_1:8;
L1999: ( rng D328 ) c= ( ( rng ( C456 `1 ) ) \/ ( rng ( C457 .--> D327 ) ) ) by FUNCT_4:17;
L2000: ( rng D328 ) c= ( NAT ) by L1999 , L1998 , XBOOLE_1:1;
L2001: D328 in ( PFuncs (( the_Vertices_of C455 ) , ( NAT )) ) by L2000 , L1995 , PARTFUN1:def 3;
reconsider D329 = [ D328 , ( C456 `2 ) ] as (MCS:Labeling of C455) by L2001 , ZFMISC_1:87;
L2002: ( MCS:LabelAdjacent (D329 , C457) ) is (MCS:Labeling of C455);
thus L2003: thesis by L2002;
end;
uniqueness;
end;
definition
let C459 being  finite _Graph;
let C460 being (MCS:Labeling of C459);
func MCS:Step C460 -> (MCS:Labeling of C459) equals 
:L2005: C460 if ( C459 .order() ) <= ( card ( dom ( C460 `1 ) ) ) otherwise ( MCS:Update (C460 , ( MCS:PickUnnumbered C460 ) , ( card ( dom ( C460 `1 ) ) )) );
coherence;
consistency;
end;
definition
let C461 being _Graph;
mode MCS:LabelingSeq of C461
 -> (ManySortedSet of ( NAT ))
means :L2007: (for B419 being Nat holds ( it . B419 ) is (MCS:Labeling of C461));
existence
proof
set D330 = the (MCS:Labeling of C461);
deffunc H7(set) = D330;
consider C462 being (ManySortedSet of ( NAT )) such that L2008: (for B420 being set holds (B420 in ( NAT ) implies ( C462 . B420 ) = H7(B420))) from PBOOLE:sch 4;
take C462;
let C463 being Nat;
L2009: C463 in ( NAT ) by ORDINAL1:def 12;
thus L2010: thesis by L2009 , L2008;
end;
end;
definition
let C464 being _Graph;
let C465 being (MCS:LabelingSeq of C464);
let C466 being Nat;
redefine func C465 . C466 -> (MCS:Labeling of C464);

coherence by L2007;
end;
definition
let C467 being _Graph;
let C468 being (MCS:LabelingSeq of C467);
redefine func C468 .Result() -> (MCS:Labeling of C467);

coherence by L2007;
end;
definition
let C469 being  finite _Graph;
let C470 being (MCS:LabelingSeq of C469);
func C470 ``1 -> (preVNumberingSeq of C469) means 
:L2014: (for B421 being Nat holds ( it . B421 ) = ( ( C470 . B421 ) `1 ));
existence
proof
deffunc H8(set) = ( ( C470 . $1 ) `1 );
consider C471 being (ManySortedSet of ( NAT )) such that L2015: (for B422 being set holds (B422 in ( NAT ) implies ( C471 . B422 ) = H8(B422))) from PBOOLE:sch 4;
L2016:
now
let C472 being Nat;
L2017: C472 in ( NAT ) by ORDINAL1:def 12;
L2018: ( C471 . C472 ) = ( ( C470 . C472 ) `1 ) by L2017 , L2015;
thus L2019: ( C471 . C472 ) is (PartFunc of ( the_Vertices_of C469 ) , ( NAT )) by L2018;
end;
reconsider D331 = C471 as (preVNumberingSeq of C469) by L2016 , L396;
take D331;
let C473 being Nat;
L2020: C473 in ( NAT ) by ORDINAL1:def 12;
thus L2021: thesis by L2020 , L2015;
end;
uniqueness
proof
let C474 , C475 being (preVNumberingSeq of C469);
assume that
L2022: (for B423 being Nat holds ( C474 . B423 ) = ( ( C470 . B423 ) `1 ))
and
L2023: (for B424 being Nat holds ( C475 . B424 ) = ( ( C470 . B424 ) `1 ));
L2024:
now
let C476 being set;
assume L2025: C476 in ( NAT );
reconsider D332 = C476 as Nat by L2025;
thus L2026: ( C474 . C476 ) = ( ( C470 . D332 ) `1 ) by L2022
.= ( C475 . C476 ) by L2023;
end;
thus L2027: C474 = C475 by L2024 , PBOOLE:3;
end;
end;
definition
let C477 being  finite _Graph;
func MCS:CSeq C477 -> (MCS:LabelingSeq of C477) means 
:L2029: (( it . ( 0 ) ) = ( MCS:Init C477 ) & (for B425 being Nat holds ( it . ( B425 + 1 ) ) = ( MCS:Step ( it . B425 ) )));
existence
proof
defpred S24[ set , set , set ] means (($2 is (MCS:Labeling of C477) & $1 is Nat & (ex B426 being Nat st (ex B427 , B428 being (MCS:Labeling of C477) st ($1 = B426 & $2 = B427 & $3 = B428 & B428 = ( MCS:Step B427 ))))) or (((not $2 is (MCS:Labeling of C477)) or (not $1 is Nat)) & $2 = $3));
L2030:
now
let C478 , C479 being set;
L2031:
now
per cases ;
suppose L2032: (C479 is (MCS:Labeling of C477) & C478 is Nat);

reconsider D333 = C479 as (MCS:Labeling of C477) by L2032;
L2033: (ex B429 being (MCS:Labeling of C477) st B429 = ( MCS:Step D333 ));
thus L2034: (ex B430 being set st S24[ C478 , C479 , B430 ]) by L2033 , L2032;
end;
suppose L2035: ((not C479 is (MCS:Labeling of C477)) or (not C478 is Nat));

thus L2036: (ex B431 being set st S24[ C478 , C479 , B431 ]) by L2035;
end;
end;
thus L2038: (ex B432 being set st S24[ C478 , C479 , B432 ]) by L2031;
end;
L2039: (for B433 being (Element of ( NAT )) holds (for B434 being set holds (ex B435 being set st S24[ B433 , B434 , B435 ]))) by L2030;
consider C480 being Function such that L2040: (( dom C480 ) = ( NAT ) & ( C480 . ( 0 ) ) = ( MCS:Init C477 ) & (for B436 being (Element of ( NAT )) holds S24[ B436 , ( C480 . B436 ) , ( C480 . ( B436 + 1 ) ) ])) from RECDEF_1:sch 1(L2039);
reconsider D334 = C480 as (ManySortedSet of ( NAT )) by L2040 , PARTFUN1:def 2 , RELAT_1:def 18;
defpred S25[ Nat ] means ( D334 . $1 ) is (MCS:Labeling of C477);
L2041:
now
let C481 being Nat;
assume L2042: S25[ C481 ];
L2043: C481 in ( NAT ) by ORDINAL1:def 12;
L2044: (ex B437 being Nat st (ex B438 , B439 being (MCS:Labeling of C477) st (C481 = B437 & ( D334 . C481 ) = B438 & ( D334 . ( C481 + 1 ) ) = B439 & B439 = ( MCS:Step B438 )))) by L2043 , L2040 , L2042;
thus L2045: S25[ ( C481 + 1 ) ] by L2044;
end;
L2046: S25[ ( 0 ) ] by L2040;
L2047: (for B440 being Nat holds S25[ B440 ]) from NAT_1:sch 2(L2046 , L2041);
reconsider D335 = D334 as (MCS:LabelingSeq of C477) by L2047 , L2007;
take D335;
thus L2048: ( D335 . ( 0 ) ) = ( MCS:Init C477 ) by L2040;
let C482 being Nat;
L2049: C482 in ( NAT ) by ORDINAL1:def 12;
L2050: (ex B441 being Nat st (ex B442 , B443 being (MCS:Labeling of C477) st (C482 = B441 & ( D335 . C482 ) = B442 & ( D335 . ( C482 + 1 ) ) = B443 & B443 = ( MCS:Step B442 )))) by L2049 , L2040;
thus L2051: thesis by L2050;
end;
uniqueness
proof
let C483 , C484 being (MCS:LabelingSeq of C477);
assume that
L2052: ( C483 . ( 0 ) ) = ( MCS:Init C477 )
and
L2053: (for B444 being Nat holds ( C483 . ( B444 + 1 ) ) = ( MCS:Step ( C483 . B444 ) ))
and
L2054: ( C484 . ( 0 ) ) = ( MCS:Init C477 )
and
L2055: (for B445 being Nat holds ( C484 . ( B445 + 1 ) ) = ( MCS:Step ( C484 . B445 ) ));
defpred S26[ Nat ] means ( C483 . $1 ) = ( C484 . $1 );
L2056:
now
let C485 being Nat;
assume L2057: S26[ C485 ];
L2058: ( C483 . ( C485 + 1 ) ) = ( MCS:Step ( C484 . C485 ) ) by L2057 , L2053
.= ( C484 . ( C485 + 1 ) ) by L2055;
thus L2059: S26[ ( C485 + 1 ) ] by L2058;
end;
L2060: (for B446 being (Element of ( NAT )) holds (S26[ B446 ] implies S26[ ( B446 + 1 ) ])) by L2056;
L2061: S26[ ( 0 ) ] by L2052 , L2054;
L2062: (for B447 being (Element of ( NAT )) holds S26[ B447 ]) from NAT_1:sch 1(L2061 , L2060);
L2063: (for B448 being set holds (B448 in ( NAT ) implies ( C483 . B448 ) = ( C484 . B448 ))) by L2062;
thus L2064: C483 = C484 by L2063 , PBOOLE:3;
end;
end;
theorem
L2066: (for B449 being  finite _Graph holds ( MCS:CSeq B449 ) is  iterative)
proof
let C486 being  finite _Graph;
set D336 = ( MCS:CSeq C486 );
let C487 , C488 being Nat;
L2067: ( D336 . ( C487 + 1 ) ) = ( MCS:Step ( D336 . C487 ) ) by L2029;
thus L2068: thesis by L2067 , L2029;
end;
registration
let C489 being  finite _Graph;
cluster ( MCS:CSeq C489 ) ->  iterative;
coherence by L2066;
end;
theorem
L2070: (for B450 being  finite _Graph holds (for B451 being set holds ( ( ( MCS:Init B450 ) `2 ) . B451 ) = ( 0 )))
proof
let C490 being  finite _Graph;
let C491 being set;
set D337 = ( ( the_Vertices_of C490 ) --> ( {} ) );
L2071: ( [ ( {} ) , D337 ] `2 ) = D337;
L2072: ( ( MCS:Init C490 ) `2 ) = D337 by L2071;
L2073: ( dom ( ( MCS:Init C490 ) `2 ) ) = ( the_Vertices_of C490 ) by L2072 , FUNCOP_1:13;
reconsider D338 = D337 as (PartFunc of ( the_Vertices_of C490 ) , ( rng D337 )) by L2073 , L2072 , RELSET_1:4;
L2074:
now
let C492 being set;
per cases ;
suppose L2075: C492 in ( dom D338 );

thus L2076: ( D338 . C492 ) = ( {} ) by L2075 , FUNCOP_1:7;
end;
suppose L2077: (not C492 in ( dom D338 ));

thus L2078: ( D338 . C492 ) = ( {} ) by L2077 , FUNCT_1:def 2;
end;
end;
thus L2080: thesis by L2074 , L2072;
end;
theorem
L2081: (for B452 being  finite _Graph holds (for B453 being (MCS:Labeling of B452) holds (for B454 being set holds (((not B454 in ( dom ( B453 `1 ) )) & ( dom ( B453 `1 ) ) <> ( the_Vertices_of B452 )) implies ( ( B453 `2 ) . B454 ) <= ( ( B453 `2 ) . ( MCS:PickUnnumbered B453 ) )))))
proof
let C493 being  finite _Graph;
let C494 being (MCS:Labeling of C493);
let C495 being set;
assume that
L2082: (not C495 in ( dom ( C494 `1 ) ))
and
L2083: ( dom ( C494 `1 ) ) <> ( the_Vertices_of C493 );
set D339 = ( the_Vertices_of C493 );
set D340 = ( C494 `2 );
set D341 = ( C494 `1 );
set D342 = ( MCS:PickUnnumbered C494 );
consider C496 being  finite non  empty  natural-membered set, C497 being Function such that L2084: C496 = ( rng C497 ) and L2085: C497 = ( D340 | ( D339 \ ( dom D341 ) ) ) and L2086: D342 = ( choose ( C497 " { ( max C496 ) } ) ) by L2083 , L1964;
L2087: ( dom C497 ) = ( ( dom D340 ) /\ ( D339 \ ( dom D341 ) ) ) by L2085 , RELAT_1:61;
set D343 = ( max C496 );
L2088: D343 in ( rng C497 ) by L2084 , XXREAL_2:def 8;
L2089: ( C497 " { ( max C496 ) } ) is non  empty by L2088 , FUNCT_1:72;
L2090: D342 in ( dom C497 ) by L2089 , L2086 , FUNCT_1:def 7;
L2091: ( D340 . D342 ) = ( C497 . D342 ) by L2090 , L2085 , FUNCT_1:47;
L2092: ( C497 . D342 ) in { ( max C496 ) } by L2086 , L2089 , FUNCT_1:def 7;
L2093: ( D340 . D342 ) = D343 by L2092 , L2091 , TARSKI:def 1;
L2094: ( dom ( C494 `2 ) ) = ( the_Vertices_of C493 ) by FUNCT_2:def 1;
per cases ;
suppose L2095: C495 in ( the_Vertices_of C493 );

L2096: C495 in ( D339 \ ( dom D341 ) ) by L2095 , L2082 , XBOOLE_0:def 5;
L2097: C495 in ( dom C497 ) by L2096 , L2094 , L2087 , XBOOLE_0:def 4;
L2098: ( C497 . C495 ) in C496 by L2097 , L2084 , FUNCT_1:def 3;
L2099: ( C497 . C495 ) = ( D340 . C495 ) by L2085 , L2097 , FUNCT_1:47;
thus L2100: thesis by L2099 , L2093 , L2098 , XXREAL_2:def 8;
end;
suppose L2101: (not C495 in ( the_Vertices_of C493 ));

thus L2102: thesis by L2101 , L2094 , FUNCT_1:def 2;
end;
end;
theorem
L2104: (for B455 being  finite _Graph holds (for B456 being (MCS:Labeling of B455) holds (( dom ( B456 `1 ) ) <> ( the_Vertices_of B455 ) implies (not ( MCS:PickUnnumbered B456 ) in ( dom ( B456 `1 ) )))))
proof
let C498 being  finite _Graph;
let C499 being (MCS:Labeling of C498);
assume that
L2105: ( dom ( C499 `1 ) ) <> ( the_Vertices_of C498 );
set D344 = ( the_Vertices_of C498 );
set D345 = ( C499 `2 );
set D346 = ( C499 `1 );
set D347 = ( MCS:PickUnnumbered C499 );
consider C500 being  finite non  empty  natural-membered set, C501 being Function such that L2106: C500 = ( rng C501 ) and L2107: C501 = ( D345 | ( D344 \ ( dom D346 ) ) ) and L2108: D347 = ( choose ( C501 " { ( max C500 ) } ) ) by L2105 , L1964;
set D348 = ( max C500 );
L2109: D348 in ( rng C501 ) by L2106 , XXREAL_2:def 8;
L2110: ( C501 " { ( max C500 ) } ) is non  empty by L2109 , FUNCT_1:72;
L2111: D347 in ( dom C501 ) by L2110 , L2108 , FUNCT_1:def 7;
assume L2112: D347 in ( dom D346 );
L2113: (not D347 in ( D344 \ ( dom D346 ) )) by L2112 , XBOOLE_0:def 5;
L2114: ( dom C501 ) = ( ( dom D345 ) /\ ( D344 \ ( dom D346 ) ) ) by L2107 , RELAT_1:61;
thus L2115: contradiction by L2114 , L2111 , L2113 , XBOOLE_0:def 4;
end;
theorem
L2116: (for B457 being  finite _Graph holds (for B458 being (MCS:Labeling of B457) holds (for B459 , B460 being set holds ((not B460 in ( B457 .AdjacentSet { B459 } )) implies ( ( B458 `2 ) . B460 ) = ( ( ( MCS:LabelAdjacent (B458 , B459) ) `2 ) . B460 )))))
proof
let C502 being  finite _Graph;
let C503 being (MCS:Labeling of C502);
let C504 , C505 being set;
assume that
L2117: (not C505 in ( C502 .AdjacentSet { C504 } ));
set D349 = ( C503 `2 );
set D350 = ( C503 `1 );
set D351 = ( MCS:LabelAdjacent (C503 , C504) );
set D352 = ( D351 `2 );
L2118: ( [ ( C503 `1 ) , ( ( C503 `2 ) .incSubset (( ( C502 .AdjacentSet { C504 } ) \ ( dom ( C503 `1 ) ) ) , 1) ) ] `2 ) = ( ( C503 `2 ) .incSubset (( ( C502 .AdjacentSet { C504 } ) \ ( dom ( C503 `1 ) ) ) , 1) );
L2119: D352 = ( D349 .incSubset (( ( C502 .AdjacentSet { C504 } ) \ ( dom D350 ) ) , 1) ) by L2118;
L2120: (not C505 in ( ( C502 .AdjacentSet { C504 } ) \ ( dom D350 ) )) by L2117 , XBOOLE_0:def 5;
thus L2121: thesis by L2120 , L2119 , L194;
end;
theorem
L2122: (for B461 being  finite _Graph holds (for B462 being (MCS:Labeling of B461) holds (for B463 , B464 being set holds (B464 in ( dom ( B462 `1 ) ) implies ( ( B462 `2 ) . B464 ) = ( ( ( MCS:LabelAdjacent (B462 , B463) ) `2 ) . B464 )))))
proof
let C506 being  finite _Graph;
let C507 being (MCS:Labeling of C506);
let C508 , C509 being set;
assume that
L2123: C509 in ( dom ( C507 `1 ) );
set D353 = ( C507 `2 );
set D354 = ( C507 `1 );
set D355 = ( MCS:LabelAdjacent (C507 , C508) );
set D356 = ( D355 `2 );
L2124: ( [ ( C507 `1 ) , ( ( C507 `2 ) .incSubset (( ( C506 .AdjacentSet { C508 } ) \ ( dom ( C507 `1 ) ) ) , 1) ) ] `2 ) = ( ( C507 `2 ) .incSubset (( ( C506 .AdjacentSet { C508 } ) \ ( dom ( C507 `1 ) ) ) , 1) );
L2125: D356 = ( D353 .incSubset (( ( C506 .AdjacentSet { C508 } ) \ ( dom D354 ) ) , 1) ) by L2124;
L2126: (not C509 in ( ( C506 .AdjacentSet { C508 } ) \ ( dom D354 ) )) by L2123 , XBOOLE_0:def 5;
thus L2127: thesis by L2126 , L2125 , L194;
end;
theorem
L2128: (for B465 being  finite _Graph holds (for B466 being (MCS:Labeling of B465) holds (for B467 , B468 being set holds ((B468 in ( dom ( B466 `2 ) ) & B468 in ( B465 .AdjacentSet { B467 } ) & (not B468 in ( dom ( B466 `1 ) ))) implies ( ( ( MCS:LabelAdjacent (B466 , B467) ) `2 ) . B468 ) = ( ( ( B466 `2 ) . B468 ) + 1 )))))
proof
let C510 being  finite _Graph;
let C511 being (MCS:Labeling of C510);
let C512 , C513 being set;
assume that
L2129: C513 in ( dom ( C511 `2 ) )
and
L2130: C513 in ( C510 .AdjacentSet { C512 } )
and
L2131: (not C513 in ( dom ( C511 `1 ) ));
set D357 = ( C511 `2 );
set D358 = ( C511 `1 );
set D359 = ( MCS:LabelAdjacent (C511 , C512) );
set D360 = ( D359 `2 );
L2132: ( [ ( C511 `1 ) , ( ( C511 `2 ) .incSubset (( ( C510 .AdjacentSet { C512 } ) \ ( dom ( C511 `1 ) ) ) , 1) ) ] `2 ) = ( ( C511 `2 ) .incSubset (( ( C510 .AdjacentSet { C512 } ) \ ( dom ( C511 `1 ) ) ) , 1) );
L2133: D360 = ( D357 .incSubset (( ( C510 .AdjacentSet { C512 } ) \ ( dom D358 ) ) , 1) ) by L2132;
L2134: C513 in ( ( C510 .AdjacentSet { C512 } ) \ ( dom D358 ) ) by L2130 , L2131 , XBOOLE_0:def 5;
thus L2135: thesis by L2134 , L2129 , L2133 , L194;
end;
theorem
L2136: (for B469 being  finite _Graph holds (for B470 being (MCS:Labeling of B469) holds (for B471 being set holds (( dom ( B470 `2 ) ) = ( the_Vertices_of B469 ) implies ( dom ( ( MCS:LabelAdjacent (B470 , B471) ) `2 ) ) = ( the_Vertices_of B469 )))))
proof
let C514 being  finite _Graph;
let C515 being (MCS:Labeling of C514);
let C516 being set;
assume that
L2137: ( dom ( C515 `2 ) ) = ( the_Vertices_of C514 );
set D361 = ( C515 `2 );
set D362 = ( C515 `1 );
set D363 = ( MCS:LabelAdjacent (C515 , C516) );
set D364 = ( D363 `2 );
L2138: ( [ ( C515 `1 ) , ( ( C515 `2 ) .incSubset (( ( C514 .AdjacentSet { C516 } ) \ ( dom ( C515 `1 ) ) ) , 1) ) ] `2 ) = ( ( C515 `2 ) .incSubset (( ( C514 .AdjacentSet { C516 } ) \ ( dom ( C515 `1 ) ) ) , 1) );
L2139: D364 = ( D361 .incSubset (( ( C514 .AdjacentSet { C516 } ) \ ( dom D362 ) ) , 1) ) by L2138;
thus L2140: thesis by L2139 , L2137 , L194;
end;
theorem
L2141: (for B472 being  finite _Graph holds (for B473 being Nat holds (( card ( dom ( ( ( MCS:CSeq B472 ) . B473 ) `1 ) ) ) < ( B472 .order() ) implies ( ( ( MCS:CSeq B472 ) . ( B473 + 1 ) ) `1 ) = ( ( ( ( MCS:CSeq B472 ) . B473 ) `1 ) +* ( ( MCS:PickUnnumbered ( ( MCS:CSeq B472 ) . B473 ) ) .--> ( ( B472 .order() ) -' ( card ( dom ( ( ( MCS:CSeq B472 ) . B473 ) `1 ) ) ) ) ) ))))
proof
let C517 being  finite _Graph;
let C518 being Nat;
assume that
L2142: ( card ( dom ( ( ( MCS:CSeq C517 ) . C518 ) `1 ) ) ) < ( C517 .order() );
set D365 = ( ( MCS:CSeq C517 ) . ( C518 + 1 ) );
set D366 = ( ( MCS:CSeq C517 ) . C518 );
set D367 = ( D366 `1 );
set D368 = ( MCS:PickUnnumbered D366 );
set D369 = ( ( C517 .order() ) -' ( card ( dom D367 ) ) );
L2143: D365 = ( MCS:Step D366 ) by L2029;
L2144: D365 = ( MCS:Update (D366 , D368 , ( card ( dom D367 ) )) ) by L2143 , L2142 , L2005;
consider C519 being (MCS:Labeling of C517) such that L2145: C519 = [ ( ( D366 `1 ) +* ( D368 .--> D369 ) ) , ( D366 `2 ) ] and L2146: D365 = ( MCS:LabelAdjacent (C519 , D368) ) by L2144 , L1994;
L2147: ( [ ( C519 `1 ) , ( ( C519 `2 ) .incSubset (( ( C517 .AdjacentSet { D368 } ) \ ( dom ( C519 `1 ) ) ) , 1) ) ] `1 ) = ( C519 `1 );
L2148: ( D365 `1 ) = ( [ ( ( D366 `1 ) +* ( D368 .--> D369 ) ) , ( D366 `2 ) ] `1 ) by L2147 , L2146 , L2145;
thus L2149: thesis by L2148;
end;
theorem
L2150: (for B474 being  finite _Graph holds (for B475 being Nat holds (B475 <= ( B474 .order() ) implies ( card ( dom ( ( ( MCS:CSeq B474 ) . B475 ) `1 ) ) ) = B475)))
proof
let C520 being  finite _Graph;
let C521 being Nat;
assume that
L2151: C521 <= ( C520 .order() );
defpred S27[ Nat ] means ($1 <= ( C520 .order() ) implies ( card ( dom ( ( ( MCS:CSeq C520 ) . $1 ) `1 ) ) ) = $1);
L2152: (for B476 being (Element of ( NAT )) holds ((B476 < ( C520 .order() ) & ( card ( dom ( ( ( MCS:CSeq C520 ) . B476 ) `1 ) ) ) = B476) implies ( card ( dom ( ( ( MCS:CSeq C520 ) . ( B476 + 1 ) ) `1 ) ) ) = ( B476 + 1 )))
proof
let C522 being (Element of ( NAT ));
assume that
L2153: C522 < ( C520 .order() )
and
L2154: ( card ( dom ( ( ( MCS:CSeq C520 ) . C522 ) `1 ) ) ) = C522;
set D370 = ( ( MCS:CSeq C520 ) . ( C522 + 1 ) );
set D371 = ( ( MCS:CSeq C520 ) . C522 );
set D372 = ( D371 `1 );
set D373 = ( D370 `1 );
set D374 = ( MCS:PickUnnumbered D371 );
set D375 = ( D374 .--> ( ( C520 .order() ) -' C522 ) );
L2155: ( dom D375 ) = { D374 } by FUNCOP_1:13;
L2156: D373 = ( D372 +* ( D374 .--> ( ( C520 .order() ) -' C522 ) ) ) by L2153 , L2154 , L2141;
L2157: ( dom D373 ) = ( ( dom D372 ) \/ { D374 } ) by L2156 , L2155 , FUNCT_4:def 1;
thus L2158: thesis by L2157 , L2153 , L2154 , L2104 , CARD_2:41;
end;
L2159: (for B477 being Nat holds (S27[ B477 ] implies S27[ ( B477 + 1 ) ]))
proof
let C523 being Nat;
assume that
L2160: S27[ C523 ];
per cases ;
suppose L2161: C523 < ( C520 .order() );

thus L2162: thesis by L2161 , L2152 , L2160;
end;
suppose L2163: C523 >= ( C520 .order() );

thus L2164: thesis by L2163 , NAT_1:13;
end;
end;
L2166: ( [ ( {} ) , ( ( the_Vertices_of C520 ) --> ( 0 ) ) ] `1 ) = ( {} );
L2167: ( ( MCS:CSeq C520 ) . ( 0 ) ) = ( MCS:Init C520 ) by L2029;
L2168: S27[ ( 0 ) ] by L2167 , L2166;
L2169: (for B478 being Nat holds S27[ B478 ]) from NAT_1:sch 2(L2168 , L2159);
thus L2170: thesis by L2169 , L2151;
end;
theorem
L2171: (for B479 being  finite _Graph holds (for B480 being Nat holds (( B479 .order() ) <= B480 implies ( ( MCS:CSeq B479 ) . ( B479 .order() ) ) = ( ( MCS:CSeq B479 ) . B480 ))))
proof
let C524 being  finite _Graph;
let C525 being Nat;
assume L2172: ( C524 .order() ) <= C525;
L2173: (ex B481 being Nat st ( ( C524 .order() ) + B481 ) = C525) by L2172 , NAT_1:10;
set D376 = ( MCS:CSeq C524 );
defpred S28[ Nat ] means ( C524 .order() ) = ( card ( dom ( ( D376 . ( ( C524 .order() ) + $1 ) ) `1 ) ) );
defpred S29[ Nat ] means ( D376 . ( C524 .order() ) ) = ( D376 . ( ( C524 .order() ) + $1 ) );
L2174: (for B482 being Nat holds (S28[ B482 ] implies S28[ ( B482 + 1 ) ]))
proof
let C526 being Nat;
assume that
L2175: S28[ C526 ];
set D377 = ( ( MCS:CSeq C524 ) . ( ( ( C524 .order() ) + C526 ) + 1 ) );
set D378 = ( ( MCS:CSeq C524 ) . ( ( C524 .order() ) + C526 ) );
L2176: D377 = ( MCS:Step D378 ) by L2029;
thus L2177: thesis by L2176 , L2175 , L2005;
end;
L2178: S28[ ( 0 ) ] by L2150;
L2179: (for B483 being Nat holds S28[ B483 ]) from NAT_1:sch 2(L2178 , L2174);
L2180: (for B484 being Nat holds (S29[ B484 ] implies S29[ ( B484 + 1 ) ]))
proof
let C527 being Nat;
assume that
L2181: S29[ C527 ];
set D379 = ( ( MCS:CSeq C524 ) . ( ( ( C524 .order() ) + C527 ) + 1 ) );
set D380 = ( ( MCS:CSeq C524 ) . ( ( C524 .order() ) + C527 ) );
set D381 = ( D380 `1 );
L2182: D379 = ( MCS:Step D380 ) by L2029;
L2183: ( card ( dom D381 ) ) = ( C524 .order() ) by L2179;
thus L2184: thesis by L2183 , L2181 , L2182 , L2005;
end;
L2185: S29[ ( 0 ) ];
L2186: (for B485 being Nat holds S29[ B485 ]) from NAT_1:sch 2(L2185 , L2180);
thus L2187: thesis by L2186 , L2173;
end;
theorem
L2188: (for B486 being  finite _Graph holds (for B487 , B488 being Nat holds ((( B486 .order() ) <= B487 & B487 <= B488) implies ( ( MCS:CSeq B486 ) . B487 ) = ( ( MCS:CSeq B486 ) . B488 ))))
proof
let C528 being  finite _Graph;
let C529 , C530 being Nat;
assume that
L2189: ( C528 .order() ) <= C529
and
L2190: C529 <= C530;
L2191: ( ( MCS:CSeq C528 ) . C529 ) = ( ( MCS:CSeq C528 ) . ( C528 .order() ) ) by L2189 , L2171;
thus L2192: thesis by L2191 , L2189 , L2190 , L2171 , XXREAL_0:2;
end;
theorem
L2193: (for B489 being  finite _Graph holds ( MCS:CSeq B489 ) is  eventually-constant)
proof
let C531 being  finite _Graph;
take ( C531 .order() );
let C532 being Nat;
assume L2194: ( C531 .order() ) <= C532;
thus L2195: ( ( MCS:CSeq C531 ) . ( C531 .order() ) ) = ( ( MCS:CSeq C531 ) . C532 ) by L2194 , L2171;
end;
registration
let C533 being  finite _Graph;
cluster ( MCS:CSeq C533 ) ->  eventually-constant;
coherence by L2193;
end;
theorem
L2197: (for B490 being  finite _Graph holds (for B491 being Nat holds (( dom ( ( ( MCS:CSeq B490 ) . B491 ) `1 ) ) = ( the_Vertices_of B490 ) iff ( B490 .order() ) <= B491)))
proof
let C534 being  finite _Graph;
let C535 being Nat;
set D382 = ( ( ( MCS:CSeq C534 ) . C535 ) `1 );
set D383 = ( ( MCS:CSeq C534 ) . ( C534 .order() ) );
set D384 = ( D383 `1 );
thus L2198: (( dom D382 ) = ( the_Vertices_of C534 ) implies (not C535 < ( C534 .order() ))) by L2150;
L2199: ( card ( dom D384 ) ) = ( card ( the_Vertices_of C534 ) ) by L2150;
L2200: ( dom D384 ) = ( the_Vertices_of C534 ) by L2199 , CARD_FIN:1;
assume L2201: ( C534 .order() ) <= C535;
thus L2202: thesis by L2201 , L2200 , L2188;
end;
theorem
L2203: (for B492 being  finite _Graph holds ( ( MCS:CSeq B492 ) .Lifespan() ) = ( B492 .order() ))
proof
let C536 being  finite _Graph;
set D385 = ( MCS:CSeq C536 );
L2204: (for B493 being Nat holds (( D385 . B493 ) = ( D385 . ( B493 + 1 ) ) implies ( C536 .order() ) <= B493))
proof
let C537 being Nat;
assume that
L2205: ( D385 . C537 ) = ( D385 . ( C537 + 1 ) );
set D386 = ( MCS:PickUnnumbered ( D385 . C537 ) );
set D387 = ( ( D385 . ( C537 + 1 ) ) `1 );
set D388 = ( ( D385 . C537 ) `1 );
set D389 = ( card ( dom D388 ) );
set D390 = ( D386 .--> ( ( C536 .order() ) -' D389 ) );
assume L2206: C537 < ( C536 .order() );
L2207: ( dom D388 ) <> ( the_Vertices_of C536 ) by L2206 , L2197;
L2208: (not D386 in ( dom D388 )) by L2207 , L2104;
L2209: D389 < ( C536 .order() ) by L2206 , L2150;
L2210: D387 = ( D388 +* ( D386 .--> ( ( C536 .order() ) -' D389 ) ) ) by L2209 , L2141;
L2211: ( dom D390 ) = { D386 } by FUNCOP_1:13;
L2212: ( dom D387 ) = ( ( dom D388 ) \/ { D386 } ) by L2211 , L2210 , FUNCT_4:def 1;
L2213: D386 in { D386 } by TARSKI:def 1;
thus L2214: contradiction by L2213 , L2205 , L2208 , L2212 , XBOOLE_0:def 3;
end;
L2215: ( C536 .order() ) <= ( ( C536 .order() ) + 1 ) by NAT_1:13;
L2216: ( D385 . ( C536 .order() ) ) = ( D385 . ( ( C536 .order() ) + 1 ) ) by L2215 , L2171;
thus L2217: thesis by L2216 , L2204 , GLIB_000:def 55;
end;
theorem
L2218: (for B494 being  finite _Graph holds ( ( MCS:CSeq B494 ) ``1 ) is  eventually-constant)
proof
let C538 being  finite _Graph;
set D391 = ( MCS:CSeq C538 );
set D392 = ( D391 ``1 );
L2219:
now
consider C539 being Nat such that L2220: (for B495 being Nat holds (C539 <= B495 implies ( D391 . C539 ) = ( D391 . B495 ))) by L342;
take D393 = C539;
let C540 being Nat;
assume that
L2221: D393 <= C540;
thus L2222: ( D392 . D393 ) = ( ( D391 . D393 ) `1 ) by L2014
.= ( ( D391 . C540 ) `1 ) by L2220 , L2221
.= ( D392 . C540 ) by L2014;
end;
thus L2223: thesis by L2219 , L342;
end;
theorem
L2224: (for B496 being  finite _Graph holds ( ( ( MCS:CSeq B496 ) ``1 ) .Lifespan() ) = ( ( MCS:CSeq B496 ) .Lifespan() ))
proof
let C541 being  finite _Graph;
set D394 = ( MCS:CSeq C541 );
set D395 = ( D394 ``1 );
set D396 = ( C541 .order() );
L2225: D395 is  eventually-constant by L2218;
L2226: ( ( D394 . ( D396 + 1 ) ) `1 ) = ( ( D394 ``1 ) . ( D396 + 1 ) ) by L2014;
L2227:
now
let C542 being Nat;
assume that
L2228: ( D395 . C542 ) = ( D395 . ( C542 + 1 ) )
and
L2229: D396 > C542;
L2230: ( C542 + 1 ) <= D396 by L2229 , NAT_1:13;
L2231: ( card ( dom ( ( D394 . ( C542 + 1 ) ) `1 ) ) ) = ( C542 + 1 ) by L2230 , L2150;
L2232: ( ( D394 . ( C542 + 1 ) ) `1 ) = ( D395 . ( C542 + 1 ) ) by L2014;
L2233: ( ( D394 . C542 ) `1 ) = ( D395 . C542 ) by L2014;
L2234: ( card ( dom ( ( D394 . C542 ) `1 ) ) ) = C542 by L2229 , L2150;
thus L2235: contradiction by L2234 , L2228 , L2231 , L2233 , L2232;
end;
L2236: ( ( D394 . D396 ) `1 ) = ( ( D394 ``1 ) . D396 ) by L2014;
L2237: ( D395 . D396 ) = ( D395 . ( D396 + 1 ) ) by L2236 , L2226 , L2171 , NAT_1:11;
L2238: ( D394 .Lifespan() ) = D396 by L2203;
thus L2239: thesis by L2238 , L2225 , L2237 , L2227 , GLIB_000:def 55;
end;
theorem
L2240: (for B497 being  finite _Graph holds ( ( MCS:CSeq B497 ) ``1 ) is  vertex-numbering)
proof
let C543 being  finite _Graph;
set D397 = ( MCS:CSeq C543 );
set D398 = ( D397 ``1 );
L2241: ( D397 . ( 0 ) ) = ( MCS:Init C543 ) by L2029;
L2242: ( [ ( {} ) , ( ( the_Vertices_of C543 ) --> ( 0 ) ) ] `1 ) = ( {} );
L2243: ( D398 . ( 0 ) ) = ( ( D397 . ( 0 ) ) `1 ) by L2014;
thus L2244: ( D398 . ( 0 ) ) = ( {} ) by L2243 , L2241 , L2242;
L2245:
now
let C544 , C545 being Nat;
assume that
L2246: ( D398 . C544 ) = ( D398 . C545 );
L2247: ( D398 . ( C544 + 1 ) ) = ( ( D397 . ( C544 + 1 ) ) `1 ) by L2014;
L2248: ( D398 . C544 ) = ( ( D397 . C544 ) `1 ) by L2014;
L2249: ( D398 . ( C545 + 1 ) ) = ( ( D397 . ( C545 + 1 ) ) `1 ) by L2014;
L2250: ( D398 . C545 ) = ( ( D397 . C545 ) `1 ) by L2014;
per cases ;
suppose L2251: (C544 <= ( C543 .order() ) & C545 <= ( C543 .order() ));

L2252: ( card ( dom ( ( D397 . C545 ) `1 ) ) ) = C545 by L2251 , L2150;
thus L2253: ( D398 . ( C544 + 1 ) ) = ( D398 . ( C545 + 1 ) ) by L2252 , L2246 , L2248 , L2250 , L2251 , L2150;
end;
suppose L2254: (C544 <= ( C543 .order() ) & C545 >= ( C543 .order() ));

L2255: ( D397 . C545 ) = ( D397 . ( C543 .order() ) ) by L2254 , L2171;
L2256: ( card ( dom ( ( D397 . ( C543 .order() ) ) `1 ) ) ) = ( C543 .order() ) by L2150;
L2257: ( C545 + 1 ) >= ( C543 .order() ) by L2254 , NAT_1:13;
L2258: ( card ( dom ( ( D397 . C544 ) `1 ) ) ) = C544 by L2254 , L2150;
L2259: ( C544 + 1 ) >= ( C543 .order() ) by L2258 , L2246 , L2248 , L2250 , L2255 , L2256 , NAT_1:13;
thus L2260: ( D398 . ( C544 + 1 ) ) = ( ( D397 . ( C543 .order() ) ) `1 ) by L2259 , L2247 , L2171
.= ( D398 . ( C545 + 1 ) ) by L2249 , L2257 , L2171;
end;
suppose L2261: (C544 >= ( C543 .order() ) & C545 <= ( C543 .order() ));

L2262: ( D397 . C544 ) = ( D397 . ( C543 .order() ) ) by L2261 , L2171;
L2263: ( card ( dom ( ( D397 . ( C543 .order() ) ) `1 ) ) ) = ( C543 .order() ) by L2150;
L2264: ( card ( dom ( ( D397 . C545 ) `1 ) ) ) = C545 by L2261 , L2150;
L2265: ( C545 + 1 ) >= ( C543 .order() ) by L2264 , L2246 , L2248 , L2250 , L2262 , L2263 , NAT_1:13;
L2266: ( C544 + 1 ) >= ( C543 .order() ) by L2261 , NAT_1:13;
thus L2267: ( D398 . ( C544 + 1 ) ) = ( ( D397 . ( C543 .order() ) ) `1 ) by L2266 , L2247 , L2171
.= ( D398 . ( C545 + 1 ) ) by L2249 , L2265 , L2171;
end;
suppose L2268: (C544 >= ( C543 .order() ) & C545 >= ( C543 .order() ));

L2269: ( C545 + 1 ) >= ( C543 .order() ) by L2268 , NAT_1:13;
L2270: ( C544 + 1 ) >= ( C543 .order() ) by L2268 , NAT_1:13;
thus L2271: ( D398 . ( C544 + 1 ) ) = ( ( D397 . ( C544 + 1 ) ) `1 ) by L2014
.= ( ( D397 . ( C543 .order() ) ) `1 ) by L2270 , L2171
.= ( ( D397 . ( C545 + 1 ) ) `1 ) by L2269 , L2171
.= ( D398 . ( C545 + 1 ) ) by L2014;
end;
end;
thus L2273: D398 is  iterative by L2245 , L340;
L2274: D398 is  eventually-constant by L2218;
thus L2275: D398 is  halting by L2274;
L2276: ( D397 .Lifespan() ) = ( D398 .Lifespan() ) by L2224;
thus L2277: ( D398 .Lifespan() ) = ( C543 .order() ) by L2276 , L2203;
let C546 being Nat;
assume that
L2278: C546 < ( D398 .Lifespan() );
take D399 = ( MCS:PickUnnumbered ( D397 . C546 ) );
L2279: ( ( D397 . C546 ) `1 ) = ( D398 . C546 ) by L2014;
L2280: ( dom ( D398 . C546 ) ) <> ( the_Vertices_of C543 ) by L2279 , L2277 , L2278 , L2197;
thus L2281: (not D399 in ( dom ( D398 . C546 ) )) by L2280 , L2279 , L2104;
L2282: ( ( D397 . ( C546 + 1 ) ) `1 ) = ( D398 . ( C546 + 1 ) ) by L2014;
L2283: C546 = ( card ( dom ( D398 . C546 ) ) ) by L2277 , L2278 , L2279 , L2150;
thus L2284: thesis by L2283 , L2277 , L2278 , L2279 , L2282 , L2141;
end;
registration
let C547 being  finite _Graph;
cluster ( ( MCS:CSeq C547 ) ``1 ) ->  vertex-numbering;
coherence by L2240;
end;
theorem
L2286: (for B498 being  finite _Graph holds (for B499 being Nat holds (B499 < ( B498 .order() ) implies ( ( ( MCS:CSeq B498 ) ``1 ) .PickedAt B499 ) = ( MCS:PickUnnumbered ( ( MCS:CSeq B498 ) . B499 ) ))))
proof
let C548 being  finite _Graph;
let C549 being Nat;
assume that
L2287: C549 < ( C548 .order() );
set D400 = ( MCS:CSeq C548 );
set D401 = ( D400 . C549 );
set D402 = ( D400 . ( C549 + 1 ) );
set D403 = ( D401 `1 );
set D404 = ( D402 `1 );
L2288: ( D400 .Lifespan() ) = ( C548 .order() ) by L2203;
set D405 = ( MCS:PickUnnumbered D401 );
set D406 = ( D405 .--> ( ( D400 .Lifespan() ) -' C549 ) );
L2289: ( dom D406 ) = { D405 } by FUNCOP_1:13;
L2290: C549 = ( card ( dom D403 ) ) by L2287 , L2150;
L2291: D404 = ( D403 +* ( D405 .--> ( ( D400 .Lifespan() ) -' C549 ) ) ) by L2290 , L2287 , L2288 , L2141;
L2292: ( dom D404 ) = ( ( dom D403 ) \/ { D405 } ) by L2291 , L2289 , FUNCT_4:def 1;
L2293: ( ( D400 ``1 ) .Lifespan() ) = ( D400 .Lifespan() ) by L2224;
set D407 = ( ( D400 ``1 ) .PickedAt C549 );
set D408 = ( D407 .--> ( ( D400 .Lifespan() ) -' C549 ) );
L2294: ( dom D408 ) = { D407 } by FUNCOP_1:13;
L2295: D403 = ( ( D400 ``1 ) . C549 ) by L2014;
L2296: D404 = ( ( D400 ``1 ) . ( C549 + 1 ) ) by L2014;
L2297: D404 = ( D403 +* ( D407 .--> ( ( D400 .Lifespan() ) -' C549 ) ) ) by L2296 , L2287 , L2288 , L2295 , L2293 , L606;
L2298: ( dom D404 ) = ( ( dom D403 ) \/ { D407 } ) by L2297 , L2294 , FUNCT_4:def 1;
L2299: (not D407 in ( dom D403 )) by L2287 , L2288 , L2295 , L2293 , L606;
L2300:
now
assume L2301: D407 <> D405;
L2302: (not D407 in { D405 }) by L2301 , TARSKI:def 1;
L2303: (not D407 in ( dom D404 )) by L2302 , L2299 , L2292 , XBOOLE_0:def 3;
L2304: D407 in { D407 } by TARSKI:def 1;
thus L2305: contradiction by L2304 , L2298 , L2303 , XBOOLE_0:def 3;
end;
thus L2306: thesis by L2300;
end;
theorem
L2307: (for B500 being  finite _Graph holds (for B501 being Nat holds (B501 < ( B500 .order() ) implies (ex B502 being (Vertex of B500) st (B502 = ( MCS:PickUnnumbered ( ( MCS:CSeq B500 ) . B501 ) ) & (for B503 being set holds (((B503 in ( B500 .AdjacentSet { B502 } ) & (not B503 in ( dom ( ( ( MCS:CSeq B500 ) . B501 ) `1 ) ))) implies ( ( ( ( MCS:CSeq B500 ) . ( B501 + 1 ) ) `2 ) . B503 ) = ( ( ( ( ( MCS:CSeq B500 ) . B501 ) `2 ) . B503 ) + 1 )) & (((not B503 in ( B500 .AdjacentSet { B502 } )) or B503 in ( dom ( ( ( MCS:CSeq B500 ) . B501 ) `1 ) )) implies ( ( ( ( MCS:CSeq B500 ) . ( B501 + 1 ) ) `2 ) . B503 ) = ( ( ( ( MCS:CSeq B500 ) . B501 ) `2 ) . B503 )))))))))
proof
let C550 being  finite _Graph;
let C551 being Nat;
assume that
L2308: C551 < ( C550 .order() );
set D409 = ( ( MCS:CSeq C550 ) . C551 );
set D410 = ( D409 `1 );
L2309: C551 = ( card ( dom D410 ) ) by L2308 , L2150;
set D411 = ( ( C550 .order() ) -' C551 );
set D412 = ( MCS:PickUnnumbered D409 );
set D413 = ( ( MCS:CSeq C550 ) . ( C551 + 1 ) );
set D414 = [ ( ( D409 `1 ) +* ( D412 .--> D411 ) ) , ( D409 `2 ) ];
set D415 = ( ( D409 `1 ) +* ( D412 .--> D411 ) );
L2310: ( dom D415 ) = ( ( dom ( D409 `1 ) ) \/ { D412 } ) by L1;
L2311: ( rng ( D412 .--> D411 ) ) = { D411 } by FUNCOP_1:8;
L2312: ( ( rng ( D409 `1 ) ) \/ ( rng ( D412 .--> D411 ) ) ) c= ( NAT ) by L2311 , XBOOLE_1:8;
L2313: ( rng D415 ) c= ( ( rng ( D409 `1 ) ) \/ ( rng ( D412 .--> D411 ) ) ) by FUNCT_4:17;
L2314: ( rng D415 ) c= ( NAT ) by L2313 , L2312 , XBOOLE_1:1;
L2315: D415 in ( PFuncs (( the_Vertices_of C550 ) , ( NAT )) ) by L2314 , L2310 , PARTFUN1:def 3;
reconsider D416 = D414 as (MCS:Labeling of C550) by L2315 , ZFMISC_1:def 2;
L2316: D413 = ( MCS:Step D409 ) by L2029
.= ( MCS:Update (D409 , D412 , C551) ) by L2308 , L2309 , L2005
.= ( MCS:LabelAdjacent (D416 , D412) ) by L1994;
take D412;
set D417 = ( D416 `2 );
set D418 = ( D416 `1 );
set D419 = ( D413 `2 );
set D420 = ( D409 `2 );
L2317: (( [ ( ( D409 `1 ) +* ( D412 .--> D411 ) ) , ( D409 `2 ) ] `1 ) = ( ( D409 `1 ) +* ( D412 .--> D411 ) ) & ( [ ( ( D409 `1 ) +* ( D412 .--> D411 ) ) , ( D409 `2 ) ] `2 ) = ( D409 `2 ));
L2318: D417 = D420 by L2317;
L2319: D418 = ( ( D409 `1 ) +* ( D412 .--> D411 ) ) by L2317;
L2320: ( dom D418 ) = ( ( dom ( D409 `1 ) ) \/ { D412 } ) by L2319 , L1;
L2321: ( dom D410 ) c= ( dom D418 ) by L2320 , XBOOLE_1:7;
L2322:
now
let C552 being set;
assume L2323: ((not C552 in ( C550 .AdjacentSet { D412 } )) or C552 in ( dom D410 ));
per cases  by L2323;
suppose L2324: (not C552 in ( C550 .AdjacentSet { D412 } ));

thus L2325: ( D419 . C552 ) = ( D420 . C552 ) by L2324 , L2316 , L2318 , L2116;
end;
suppose L2326: C552 in ( dom D410 );

thus L2327: ( D419 . C552 ) = ( D420 . C552 ) by L2326 , L2316 , L2318 , L2321 , L2122;
end;
end;
L2329: ( dom D420 ) = ( the_Vertices_of C550 ) by FUNCT_2:def 1;
L2330:
now
let C553 being set;
assume that
L2331: C553 in ( C550 .AdjacentSet { D412 } )
and
L2332: (not C553 in ( dom D410 ));
L2333: (not C553 in { D412 }) by L2331 , CHORD:49;
L2334: (not C553 in ( dom D418 )) by L2333 , L2320 , L2332 , XBOOLE_0:def 3;
thus L2335: ( D419 . C553 ) = ( ( D420 . C553 ) + 1 ) by L2334 , L2316 , L2318 , L2329 , L2331 , L2128;
end;
thus L2336: thesis by L2330 , L2322;
end;
theorem
L2337: (for B504 being  finite _Graph holds (for B505 being Nat holds (for B506 being set holds ((not B506 in ( dom ( ( ( MCS:CSeq B504 ) . B505 ) `1 ) )) implies ( ( ( ( MCS:CSeq B504 ) . B505 ) `2 ) . B506 ) = ( card ( ( B504 .AdjacentSet { B506 } ) /\ ( dom ( ( ( MCS:CSeq B504 ) . B505 ) `1 ) ) ) )))))
proof
let C554 being  finite _Graph;
let C555 being Nat;
set D421 = ( ( MCS:CSeq C554 ) . C555 );
set D422 = ( D421 `1 );
defpred S30[ Nat ] means (for B507 being set holds ((not B507 in ( dom ( ( ( MCS:CSeq C554 ) . $1 ) `1 ) )) implies ( ( ( ( MCS:CSeq C554 ) . $1 ) `2 ) . B507 ) = ( card ( ( C554 .AdjacentSet { B507 } ) /\ ( dom ( ( ( MCS:CSeq C554 ) . $1 ) `1 ) ) ) )));
L2338: (for B508 being Nat holds (S30[ B508 ] implies S30[ ( B508 + 1 ) ]))
proof
let C556 being Nat;
assume that
L2339: S30[ C556 ];
set D423 = ( ( MCS:CSeq C554 ) . ( C556 + 1 ) );
set D424 = ( ( MCS:CSeq C554 ) . C556 );
set D425 = ( D424 `1 );
set D426 = ( D424 `2 );
set D427 = ( D423 `1 );
set D428 = ( D423 `2 );
L2340: C556 <= ( C556 + 1 ) by XREAL_1:38;
per cases ;
suppose L2341: ( C554 .order() ) <= C556;

L2342: D426 = D428 by L2341 , L2340 , L2188;
L2343: D425 = D427 by L2340 , L2341 , L2188;
thus L2344: thesis by L2343 , L2339 , L2342;
end;
suppose L2345: C556 < ( C554 .order() );

set D429 = ( ( MCS:CSeq C554 ) ``1 );
L2346: ( C554 .order() ) = ( ( MCS:CSeq C554 ) .Lifespan() ) by L2203;
L2347: D425 = ( D429 . C556 ) by L2014;
L2348: ( ( MCS:CSeq C554 ) .Lifespan() ) = ( D429 .Lifespan() ) by L2224;
L2349: D427 = ( D429 . ( C556 + 1 ) ) by L2014;
consider C557 being (Vertex of C554) such that L2350: C557 = ( MCS:PickUnnumbered D424 ) and L2351: (for B509 being set holds (((B509 in ( C554 .AdjacentSet { C557 } ) & (not B509 in ( dom D425 ))) implies ( D428 . B509 ) = ( ( D426 . B509 ) + 1 )) & (((not B509 in ( C554 .AdjacentSet { C557 } )) or B509 in ( dom D425 )) implies ( D428 . B509 ) = ( D426 . B509 )))) by L2345 , L2307;
L2352: C557 = ( ( ( MCS:CSeq C554 ) ``1 ) .PickedAt C556 ) by L2345 , L2350 , L2286;
L2353: ( dom ( D423 `1 ) ) = ( ( dom ( D424 `1 ) ) \/ { C557 } ) by L2352 , L2345 , L2346 , L2347 , L2349 , L2348 , L631;
L2354:
now
let C558 being set;
assume that
L2355: (not C558 in ( dom D427 ));
L2356: (not C558 in ( dom D425 )) by L2353 , L2355 , XBOOLE_0:def 3;
L2357: ( card ( ( C554 .AdjacentSet { C558 } ) /\ ( dom D425 ) ) ) = ( D426 . C558 ) by L2356 , L2339;
per cases ;
suppose L2358: (C558 in ( C554 .AdjacentSet { C557 } ) & (not C558 in ( dom D425 )));

set D430 = ( C554 .AdjacentSet { C558 } );
L2359: C557 in D430 by L2358 , CHORD:53;
L2360: { C557 } c= D430 by L2359 , ZFMISC_1:31;
L2361: ( D430 /\ ( dom D427 ) ) = ( ( D430 /\ ( dom D425 ) ) \/ ( D430 /\ { C557 } ) ) by L2353 , XBOOLE_1:23
.= ( ( D430 /\ ( dom D425 ) ) \/ { C557 } ) by L2360 , XBOOLE_1:28;
L2362: ( dom D425 ) <> ( the_Vertices_of C554 ) by L2345 , L2197;
L2363: (not C557 in ( dom D425 )) by L2362 , L2350 , L2104;
L2364: (not C557 in ( D430 /\ ( dom D425 ) )) by L2363 , XBOOLE_0:def 4;
L2365: ( D428 . C558 ) = ( ( D426 . C558 ) + 1 ) by L2351 , L2358;
thus L2366: ( card ( ( C554 .AdjacentSet { C558 } ) /\ ( dom D427 ) ) ) = ( D428 . C558 ) by L2365 , L2357 , L2364 , L2361 , CARD_2:41;
end;
suppose L2367: ((not C558 in ( C554 .AdjacentSet { C557 } )) or C558 in ( dom D425 ));

set D431 = ( C554 .AdjacentSet { C558 } );
L2368: (not C557 in D431) by L2353 , L2355 , L2367 , CHORD:53 , XBOOLE_0:def 3;
L2369:
now
assume L2370: ( D431 /\ { C557 } ) = { C557 };
L2371: C557 in ( D431 /\ { C557 } ) by L2370 , TARSKI:def 1;
thus L2372: contradiction by L2371 , L2368 , XBOOLE_0:def 4;
end;
L2373: ( D431 /\ { C557 } ) c= { C557 } by XBOOLE_1:17;
L2374: ( D431 /\ { C557 } ) in ( bool { C557 } ) by L2373;
L2375: ( D431 /\ { C557 } ) in { ( {} ) , { C557 } } by L2374 , ZFMISC_1:24;
L2376: ( D428 . C558 ) = ( D426 . C558 ) by L2351 , L2367;
L2377: ( D431 /\ ( dom D427 ) ) = ( ( D431 /\ ( dom D425 ) ) \/ ( D431 /\ { C557 } ) ) by L2353 , XBOOLE_1:23
.= ( ( D431 /\ ( dom D425 ) ) \/ ( {} ) ) by L2375 , L2369 , TARSKI:def 2
.= ( D431 /\ ( dom D425 ) );
thus L2378: ( card ( ( C554 .AdjacentSet { C558 } ) /\ ( dom D427 ) ) ) = ( D428 . C558 ) by L2377 , L2339 , L2356 , L2376;
end;
end;
thus L2380: thesis by L2354;
end;
end;
L2382:
now
set D432 = ( ( MCS:CSeq C554 ) . ( 0 ) );
let C559 being set;
set D433 = ( D432 `1 );
set D434 = ( D432 `2 );
assume L2383: (not C559 in ( dom D433 ));
L2384: D432 = ( MCS:Init C554 ) by L2029;
L2385: ( [ ( {} ) , ( ( the_Vertices_of C554 ) --> ( 0 ) ) ] `1 ) = ( {} );
L2386: ( dom D433 ) = ( {} ) by L2385 , L2384;
thus L2387: ( D434 . C559 ) = ( card ( ( C554 .AdjacentSet { C559 } ) /\ ( dom D433 ) ) ) by L2386 , L2384 , L2070 , CARD_1:27;
end;
L2388: S30[ ( 0 ) ] by L2382;
L2389: (for B510 being Nat holds S30[ B510 ]) from NAT_1:sch 2(L2388 , L2338);
let C560 being set;
assume L2390: (not C560 in ( dom D422 ));
thus L2391: thesis by L2390 , L2389;
end;
definition
let C561 being _Graph;
let C562 being (PartFunc of ( the_Vertices_of C561 ) , ( NAT ));
attr C562 is  with_property_T
means
:L2392: (for B511 , B512 , B513 being (Vertex of C561) holds ((B511 in ( dom C562 ) & B512 in ( dom C562 ) & B513 in ( dom C562 ) & ( C562 . B511 ) < ( C562 . B512 ) & ( C562 . B512 ) < ( C562 . B513 ) & B511 , B513 are_adjacent  & (not B512 , B513 are_adjacent )) implies (ex B514 being (Vertex of C561) st (B514 in ( dom C562 ) & ( C562 . B512 ) < ( C562 . B514 ) & B512 , B514 are_adjacent  & (not B511 , B514 are_adjacent )))));
end;
theorem
L2394: (for B515 being  finite _Graph holds (for B516 being Nat holds ( ( ( MCS:CSeq B515 ) . B516 ) `1 ) is  with_property_T))
proof
let C563 being  finite _Graph;
let C564 being Nat;
set D435 = ( ( MCS:CSeq C563 ) . C564 );
set D436 = ( D435 `1 );
set D437 = ( ( MCS:CSeq C563 ) ``1 );
L2395:
now
L2396: ( ( MCS:CSeq C563 ) .Lifespan() ) = ( D437 .Lifespan() ) by L2224;
L2397: D436 = ( D437 . C564 ) by L2014;
let C565 , C566 , C567 being (Vertex of C563);
assume that
L2398: C565 in ( dom D436 )
and
L2399: C566 in ( dom D436 )
and
L2400: C567 in ( dom D436 )
and
L2401: ( D436 . C565 ) < ( D436 . C566 )
and
L2402: ( D436 . C566 ) < ( D436 . C567 )
and
L2403: C565 , C567 are_adjacent 
and
L2404: (not C566 , C567 are_adjacent );
L2405: ( C563 .order() ) = ( ( MCS:CSeq C563 ) .Lifespan() ) by L2203;
L2406:
now
set D438 = ( ( C563 .order() ) -' ( D436 . C566 ) );
set D439 = ( ( MCS:CSeq C563 ) . D438 );
set D440 = ( D439 `1 );
set D441 = ( D439 `2 );
L2407: (not C567 in ( C563 .AdjacentSet { C566 } )) by L2404 , CHORD:52;
L2408: (not C567 in ( ( C563 .AdjacentSet { C566 } ) /\ ( dom D440 ) )) by L2407 , XBOOLE_0:def 4;
L2409: C566 = ( ( ( MCS:CSeq C563 ) ``1 ) .PickedAt D438 ) by L2399 , L2405 , L2397 , L2396 , L774;
L2410: C567 in ( C563 .AdjacentSet { C565 } ) by L2401 , L2402 , L2403 , CHORD:52;
L2411: D440 = ( D437 . D438 ) by L2014;
L2412: (not C565 in ( dom D440 )) by L2411 , L2398 , L2401 , L2405 , L2397 , L2396 , L857;
L2413: ( D441 . C565 ) = ( card ( ( C563 .AdjacentSet { C565 } ) /\ ( dom D440 ) ) ) by L2412 , L2337;
L2414: D438 < C564 by L2399 , L2405 , L2397 , L2396 , L809;
L2415: D440 c= D436 by L2414 , L2397 , L2411 , L722;
L2416: ( dom D440 ) c= ( dom D436 ) by L2415 , RELAT_1:11;
L2417: ( D436 . C566 ) <= ( C563 .order() ) by L2405 , L2397 , L2396 , L695;
L2418: ( ( C563 .order() ) -' ( D436 . C566 ) ) = ( ( C563 .order() ) - ( D436 . C566 ) ) by L2417 , XREAL_1:233;
L2419: ( D436 . C566 ) = ( ( C563 .order() ) - ( ( C563 .order() ) -' ( D436 . C566 ) ) ) by L2418;
L2420: ( D436 . C566 ) = ( ( C563 .order() ) -' ( ( C563 .order() ) -' ( D436 . C566 ) ) ) by L2419 , NAT_D:35 , XREAL_1:233;
L2421:
now
assume L2422: C565 in ( dom D440 );
L2423: ( D436 . C566 ) < ( D440 . C565 ) by L2422 , L2405 , L2396 , L2411 , L2420 , L809;
thus L2424: contradiction by L2423 , L2398 , L2401 , L2397 , L2411 , L2422 , L762;
end;
L2425: 1 <= ( D436 . C566 ) by L2399 , L2397 , L695;
L2426: D438 < ( C563 .order() ) by L2425 , L2418 , XREAL_1:44;
L2427: ( dom D440 ) <> ( the_Vertices_of C563 ) by L2426 , L2197;
assume L2428: (for B517 being (Vertex of C563) holds ((B517 in ( dom D436 ) & ( D436 . C566 ) < ( D436 . B517 ) & C566 , B517 are_adjacent ) implies C565 , B517 are_adjacent ));
L2429:
now
set D442 = ( ( MCS:CSeq C563 ) . ( D438 + 1 ) );
set D443 = ( D442 `1 );
let C568 being set;
assume that
L2430: C568 in ( ( C563 .AdjacentSet { C566 } ) /\ ( dom D440 ) );
reconsider D444 = C568 as (Vertex of C563) by L2430;
L2431: C568 in ( dom D440 ) by L2430 , XBOOLE_0:def 4;
L2432: C568 in ( dom D440 ) by L2430 , XBOOLE_0:def 4;
L2433: ( D436 . D444 ) = ( D440 . D444 ) by L2432 , L2397 , L2411 , L2416 , L762;
L2434: D443 = ( D437 . ( D438 + 1 ) ) by L2014;
L2435: C566 in ( dom D443 ) by L2434 , L2405 , L2396 , L2426 , L2409 , L631;
L2436: ( D436 . C566 ) = ( D443 . C566 ) by L2435 , L2399 , L2397 , L2434 , L762;
L2437: D438 < ( D438 + 1 ) by XREAL_1:39;
L2438: D440 c= D443 by L2437 , L2411 , L2434 , L722;
L2439: ( dom D440 ) c= ( dom D443 ) by L2438 , RELAT_1:11;
L2440: ( D440 . D444 ) = ( D443 . D444 ) by L2439 , L2411 , L2431 , L2434 , L762;
L2441: ( D440 . D444 ) in ( rng D440 ) by L2431 , FUNCT_1:def 3;
L2442: ( D440 . D444 ) in ( ( Seg ( C563 .order() ) ) \ ( Seg ( ( C563 .order() ) -' D438 ) ) ) by L2441 , L2405 , L2396 , L2411 , L666;
L2443: ( ( C563 .order() ) -' D438 ) < ( D443 . D444 ) by L2442 , L2440 , L100;
L2444: ( D436 . C566 ) < ( D436 . D444 ) by L2443 , L2405 , L2396 , L2418 , L2425 , L2409 , L2434 , L2436 , L2433 , L2440 , L639 , XREAL_1:44;
L2445: D444 in ( C563 .AdjacentSet { C566 } ) by L2430 , XBOOLE_0:def 4;
L2446: C566 , D444 are_adjacent  by L2445 , CHORD:52;
L2447: C565 , D444 are_adjacent  by L2446 , L2428 , L2416 , L2431 , L2444;
L2448: D444 in ( C563 .AdjacentSet { C565 } ) by L2447 , L2401 , L2444 , CHORD:52;
thus L2449: C568 in ( ( C563 .AdjacentSet { C565 } ) /\ ( dom D440 ) ) by L2448 , L2431 , XBOOLE_0:def 4;
end;
L2450: ( ( C563 .AdjacentSet { C566 } ) /\ ( dom D440 ) ) c= ( ( C563 .AdjacentSet { C565 } ) /\ ( dom D440 ) ) by L2429 , TARSKI:def 3;
L2451: C567 in ( dom D440 ) by L2399 , L2400 , L2402 , L2405 , L2397 , L2396 , L2411 , L834;
L2452: C567 in ( ( C563 .AdjacentSet { C565 } ) /\ ( dom D440 ) ) by L2451 , L2410 , XBOOLE_0:def 4;
L2453: ( ( C563 .AdjacentSet { C566 } ) /\ ( dom D440 ) ) c< ( ( C563 .AdjacentSet { C565 } ) /\ ( dom D440 ) ) by L2452 , L2408 , L2450 , XBOOLE_0:def 8;
L2454: C566 = ( MCS:PickUnnumbered D439 ) by L2418 , L2425 , L2409 , L2286 , XREAL_1:44;
L2455: ( D441 . C566 ) = ( card ( ( C563 .AdjacentSet { C566 } ) /\ ( dom D440 ) ) ) by L2454 , L2427 , L2104 , L2337;
thus L2456: contradiction by L2455 , L2427 , L2454 , L2421 , L2413 , L2453 , L2081 , TREES_1:6;
end;
thus L2457: (ex B518 being (Vertex of C563) st (B518 in ( dom D436 ) & ( D436 . C566 ) < ( D436 . B518 ) & C566 , B518 are_adjacent  & (not C565 , B518 are_adjacent ))) by L2406;
end;
thus L2458: thesis by L2395 , L2392;
end;
theorem
L2459: (for B519 being  finite _Graph holds ( ( ( LexBFS:CSeq B519 ) .Result() ) `1 ) is  with_property_T)
proof
let C569 being  finite _Graph;
set D445 = ( LexBFS:CSeq C569 );
set D446 = ( ( D445 .Result() ) `1 );
L2460: D446 is  with_property_L3 by L1544;
L2461:
now
let C570 , C571 , C572 being (Vertex of C569);
assume that
L2462: C570 in ( dom D446 )
and
L2463: C571 in ( dom D446 )
and
L2464: C572 in ( dom D446 )
and
L2465: ( D446 . C570 ) < ( D446 . C571 )
and
L2466: ( D446 . C571 ) < ( D446 . C572 )
and
L2467: C570 , C572 are_adjacent 
and
L2468: (not C571 , C572 are_adjacent );
consider C573 being (Vertex of C569) such that L2469: C573 in ( dom D446 ) and L2470: ( D446 . C572 ) < ( D446 . C573 ) and L2471: C571 , C573 are_adjacent  and L2472: (not C570 , C573 are_adjacent ) and L2473: (for B520 being (Vertex of C569) holds ((B520 <> C573 & B520 , C571 are_adjacent  & (not B520 , C570 are_adjacent )) implies ( D446 . B520 ) < ( D446 . C573 ))) by L2460 , L2462 , L2463 , L2464 , L2465 , L2466 , L2467 , L2468 , L1542;
take D447 = C573;
thus L2474: D447 in ( dom D446 ) by L2469;
thus L2475: ( D446 . C571 ) < ( D446 . D447 ) by L2466 , L2470 , XXREAL_0:2;
thus L2476: C571 , D447 are_adjacent  by L2471;
thus L2477: (not C570 , D447 are_adjacent ) by L2472;
end;
thus L2478: thesis by L2461 , L2392;
end;
theorem
L2479: (for B521 being  finite  chordal _Graph holds (for B522 being (PartFunc of ( the_Vertices_of B521 ) , ( NAT )) holds ((B522 is  with_property_T & ( dom B522 ) = ( the_Vertices_of B521 )) implies (for B523 being (VertexScheme of B521) holds (( B523 " ) = B522 implies B523 is  perfect)))))
proof
let C574 being  finite  chordal _Graph;
let C575 being (PartFunc of ( the_Vertices_of C574 ) , ( NAT ));
assume that
L2480: C575 is  with_property_T
and
L2481: ( dom C575 ) = ( the_Vertices_of C574 );
defpred S31[ (Path of C574) ] means (( len $1 ) >= 5 & $1 is  open & $1 is  chordless & ( C575 . ( $1 .first() ) ) > ( C575 . ( $1 .last() ) ) & ( C575 . ( $1 .last() ) ) > ( C575 . ( $1 . 3 ) ) & (ex B524 being  odd (Element of ( NAT )) st (1 < B524 & B524 < ( len $1 ) & (for B525 , B526 being  odd (Element of ( NAT )) holds ((B524 <= B525 & B525 < B526 & B526 <= ( len $1 )) implies ( C575 . ( $1 . B525 ) ) < ( C575 . ( $1 . B526 ) ))) & (for B527 , B528 being  odd (Element of ( NAT )) holds ((1 <= B527 & B527 < B528 & B528 <= B524) implies ( C575 . ( $1 . B527 ) ) > ( C575 . ( $1 . B528 ) ))))));
let C576 being (VertexScheme of C574);
assume that
L2482: ( C576 " ) = C575;
L2483: C576 is  one-to-one by CHORD:def 12;
L2484: ( len C576 ) = ( card ( the_Vertices_of C574 ) ) by CHORD:104;
L2485: ( dom C576 ) = ( Seg ( C574 .order() ) ) by L2484 , FINSEQ_1:def 3;
L2486: ( rng C575 ) = ( Seg ( C574 .order() ) ) by L2485 , L2482 , L2483 , FUNCT_1:33;
L2487:
now
defpred S32[ Nat ] means (ex B529 being (Path of C574) st (S31[ B529 ] & ( C575 . ( B529 .last() ) ) = $1));
L2488: (for B530 being Nat holds (S32[ B530 ] implies B530 <= ( C574 .order() )))
proof
let C577 being Nat;
assume L2489: S32[ C577 ];
consider C578 being (Path of C574) such that L2490: S31[ C578 ] and L2491: ( C575 . ( C578 .last() ) ) = C577 by L2489;
L2492: ( C575 . ( C578 .last() ) ) in ( Seg ( C574 .order() ) ) by L2481 , L2486 , FUNCT_1:def 3;
thus L2493: thesis by L2492 , L2491 , FINSEQ_1:1;
end;
let C579 being (Path of C574);
assume L2494: S31[ C579 ];
L2495: (ex B531 being Nat st S32[ B531 ]) by L2494;
consider C580 being Nat such that L2496: S32[ C580 ] and L2497: (for B532 being Nat holds (S32[ B532 ] implies B532 <= C580)) from NAT_1:sch 6(L2488 , L2495);
consider C581 being (Path of C574) such that L2498: S31[ C581 ] and L2499: ( C575 . ( C581 .last() ) ) = C580 by L2496;
L2500: 3 <= ( len C581 ) by L2498 , XXREAL_0:2;
L2501: ( C581 . 3 ) = ( C581 .vertexAt ( ( 2 * 1 ) + 1 ) ) by L2500 , GLIB_001:def 8;
reconsider D448 = ( C581 . 3 ) as (Vertex of C574) by L2501;
L2502: 3 < ( len C581 ) by L2498 , XXREAL_0:2;
reconsider D449 = ( C581 .last() ) as (Vertex of C574);
reconsider D450 = ( C581 .first() ) as (Vertex of C574);
L2503:
now
L2504: ( ( 2 * ( 0 ) ) + 1 ) < ( len C581 ) by L2498 , XXREAL_0:2;
L2505: ((ex B533 being set st B533 Joins ( C581 . 1 ) , ( C581 . ( len C581 ) ) , C574) iff ( 1 + 2 ) = ( len C581 )) by L2504 , L2498 , CHORD:92;
let C582 being set;
assume L2506: C582 Joins D450 , D449 , C574;
thus L2507: contradiction by L2506 , L2498 , L2505;
end;
L2508: (not D449 , D450 are_adjacent ) by L2503 , CHORD:def 3;
L2509: ( ( 2 * ( 0 ) ) + 1 ) < ( ( 2 * 1 ) + 1 );
L2510: (ex B534 being set st B534 Joins ( C581 . 1 ) , ( C581 . 3 ) , C574) by L2509 , L2498 , L2502 , CHORD:92;
L2511: D450 , D448 are_adjacent  by L2510 , CHORD:def 3;
consider C583 being (Vertex of C574) such that L2512: C583 in ( dom C575 ) and L2513: ( C575 . D449 ) < ( C575 . C583 ) and L2514: D449 , C583 are_adjacent  and L2515: (not D448 , C583 are_adjacent ) by L2511 , L2480 , L2481 , L2498 , L2508 , L2392;
L2516: ( C575 . C583 ) <> ( C575 . D450 ) by L2481 , L2482 , L2483 , L2508 , L2514 , FUNCT_1:def 4;
consider C584 being  odd (Element of ( NAT )) such that L2517: 1 < C584 and L2518: C584 < ( len C581 ) and L2519: (for B535 , B536 being  odd (Element of ( NAT )) holds ((C584 <= B535 & B535 < B536 & B536 <= ( len C581 )) implies ( C575 . ( C581 . B535 ) ) < ( C575 . ( C581 . B536 ) ))) and L2520: (for B537 , B538 being  odd (Element of ( NAT )) holds ((1 <= B537 & B537 < B538 & B538 <= C584) implies ( C575 . ( C581 . B537 ) ) > ( C575 . ( C581 . B538 ) ))) by L2498;
L2521: ( C575 . D448 ) < ( C575 . C583 ) by L2498 , L2513 , XXREAL_0:2;
L2522:
now
assume L2523: C583 in ( C581 .vertices() );
consider C585 being  odd (Element of ( NAT )) such that L2524: C585 <= ( len C581 ) and L2525: ( C581 . C585 ) = C583 by L2523 , GLIB_001:87;
L2526: 1 <= C585 by CHORD:2;
L2527: C585 <> 1 by L2503 , L2514 , L2525 , CHORD:def 3;
L2528: ( ( 2 * ( 0 ) ) + 1 ) < C585 by L2527 , L2526 , XXREAL_0:1;
L2529: ( 1 + 2 ) <= C585 by L2528 , CHORD:4;
L2530: ( ( 2 * 1 ) + 1 ) < C585 by L2529 , L2498 , L2513 , L2525 , XXREAL_0:1;
L2531: C585 < ( len C581 ) by L2513 , L2524 , L2525 , XXREAL_0:1;
per cases ;
suppose L2532: C584 <= C585;

thus L2533: contradiction by L2532 , L2519 , L2513 , L2525 , L2531;
end;
suppose L2534: C585 < C584;

thus L2535: contradiction by L2534 , L2520 , L2521 , L2525 , L2530;
end;
end;
defpred S33[ Nat ] means ($1 is  odd & 3 < $1 & $1 <= ( len C581 ) & (ex B539 being set st B539 Joins ( C581 . $1 ) , C583 , C574));
L2537: (ex B540 being set st B540 Joins ( C581 .last() ) , C583 , C574) by L2514 , CHORD:def 3;
L2538: (ex B541 being Nat st S33[ B541 ]) by L2537 , L2502;
L2539: (ex B542 being Nat st (S33[ B542 ] & (for B543 being Nat holds (S33[ B543 ] implies B542 <= B543)))) from NAT_1:sch 5(L2538);
consider C586 being Nat such that L2540: C586 is  odd and L2541: 3 < C586 and L2542: C586 <= ( len C581 ) and L2543: (ex B544 being set st B544 Joins ( C581 . C586 ) , C583 , C574) and L2544: (for B545 being Nat holds (S33[ B545 ] implies C586 <= B545)) by L2539;
reconsider D451 = C586 as  odd (Element of ( NAT )) by L2540 , ORDINAL1:def 12;
reconsider D452 = ( C581 .cut (1 , D451) ) as (Path of C574);
consider C587 being set such that L2545: C587 Joins ( C581 . D451 ) , C583 , C574 by L2543;
L2546: ( ( 2 * ( 0 ) ) + 1 ) < D451 by L2541 , XXREAL_0:2;
L2547: D452 is  open  chordless by L2546 , L2498 , L2542 , CHORD:93;
L2548: ( ( 2 * ( 0 ) ) + 1 ) <= D451 by CHORD:2;
L2549: ( ( len D452 ) + 1 ) = ( D451 + 1 ) by L2548 , L2542 , GLIB_001:36;
L2550:
now
let C588 being  odd (Element of ( NAT ));
assume that
L2551: C588 <= D451;
L2552: 1 <= C588 by CHORD:2;
L2553: C588 in ( dom D452 ) by L2552 , L2549 , L2551 , FINSEQ_3:25;
L2554: ( D452 . C588 ) = ( C581 . ( ( 1 + C588 ) - 1 ) ) by L2553 , L2542 , L2548 , GLIB_001:47;
thus L2555: ( D452 . C588 ) = ( C581 . C588 ) by L2554;
end;
L2556: ( ( 2 * 1 ) + 1 ) < D451 by L2541;
L2557: ( D452 . 3 ) = D448 by L2556 , L2550;
L2558:
now
L2559: ( len D452 ) > ( ( 2 * 1 ) + 1 ) by L2541 , L2549;
L2560: ( len D452 ) >= ( 3 + 2 ) by L2559 , CHORD:4;
let C589 being set;
assume that
L2561: C589 Joins ( D452 . ( ( len D452 ) - 2 ) ) , C583 , C574;
L2562: ( len D452 ) <> 5 by L2515 , L2557 , L2561 , CHORD:def 3;
L2563: ( len D452 ) > 5 by L2562 , L2560 , XXREAL_0:1;
L2564: ( ( 3 + 2 ) - 2 ) < ( ( len D452 ) - 2 ) by L2563 , XREAL_1:9;
L2565: ( 0 ) < ( ( len D452 ) - ( 2 * 1 ) ) by L2564;
reconsider D453 = ( ( len D452 ) - 2 ) as  odd (Element of ( NAT )) by L2565 , INT_1:3;
L2566: D453 < ( len D452 ) by XREAL_1:44;
L2567: D453 < ( len C581 ) by L2566 , L2542 , L2549 , XXREAL_0:2;
L2568: C589 Joins ( C581 . D453 ) , C583 , C574 by L2549 , L2550 , L2561 , L2566;
thus L2569: contradiction by L2568 , L2544 , L2549 , L2564 , L2566 , L2567;
end;
L2570: C587 Joins ( D452 .last() ) , C583 , C574 by L2542 , L2545 , L2548 , GLIB_001:37;
L2571: ( D452 .vertices() ) c= ( C581 .vertices() ) by L2542 , L2548 , GLIB_001:94;
L2572: (not C583 in ( D452 .vertices() )) by L2571 , L2522;
reconsider D454 = ( D452 .addEdge C587 ) as (Path of C574) by L2572 , L2570 , L2547 , L2558 , CHORD:97;
reconsider D455 = ( D454 .reverse() ) as (Path of C574);
L2573: ( D452 .last() ) = ( C581 . D451 ) by L2542 , L2548 , GLIB_001:37;
L2574: ( len D454 ) = ( ( len D452 ) + 2 ) by L2573 , L2545 , GLIB_001:64;
L2575:
now
per cases ;
suppose L2576: C584 < D451;

L2577:
now
per cases  by L2542 , XXREAL_0:1;
suppose L2578: D451 = ( len C581 );

thus L2579: ( C575 . ( C581 . D451 ) ) <= ( C575 . D449 ) by L2578;
end;
suppose L2580: D451 < ( len C581 );

thus L2581: ( C575 . ( C581 . D451 ) ) <= ( C575 . D449 ) by L2580 , L2519 , L2576;
end;
end;
thus L2583: ( C575 . ( C581 . D451 ) ) < ( C575 . D450 ) by L2577 , L2498 , XXREAL_0:2;
end;
suppose L2584: C584 >= D451;

L2585: 1 < ( ( 2 * 1 ) + 1 );
L2586: ( C575 . ( C581 . D451 ) ) < ( C575 . ( C581 . 3 ) ) by L2585 , L2520 , L2541 , L2584;
L2587: ( C575 . ( C581 . D451 ) ) < ( C575 . D449 ) by L2586 , L2498 , XXREAL_0:2;
thus L2588: ( C575 . ( C581 . D451 ) ) < ( C575 . D450 ) by L2587 , L2498 , XXREAL_0:2;
end;
end;
L2590: ( D452 .first() ) = ( C581 .first() ) by L2542 , L2548 , GLIB_001:37;
L2591: ( D454 .first() ) = D450 by L2590 , L2545 , L2573 , GLIB_001:63;
L2592: ( D455 .last() ) = D450 by L2591 , GLIB_001:22;
L2593: 3 in ( dom D452 ) by L2541 , L2549 , FINSEQ_3:25;
L2594: ( D454 . 3 ) = D448 by L2593 , L2545 , L2573 , L2557 , GLIB_001:65;
L2595: D454 is  chordless by L2572 , L2570 , L2547 , L2558 , CHORD:97;
L2596: ( D454 .last() ) = C583 by L2545 , L2573 , GLIB_001:63;
L2597: ( D455 .first() ) = C583 by L2596 , GLIB_001:22;
L2598: (for B546 being  odd (Element of ( NAT )) holds (B546 <= ( len D455 ) implies (( D455 . B546 ) = ( D454 . ( ( ( len D454 ) - B546 ) + 1 ) ) & ( ( ( len D454 ) - B546 ) + 1 ) is (Element of ( NAT )))))
proof
let C590 being  odd (Element of ( NAT ));
assume that
L2599: C590 <= ( len D455 );
L2600: 1 <= C590 by CHORD:2;
L2601: C590 in ( dom D455 ) by L2600 , L2599 , FINSEQ_3:25;
thus L2602: ( D455 . C590 ) = ( D454 . ( ( ( len D454 ) - C590 ) + 1 ) ) by L2601 , GLIB_001:25;
L2603: ( ( ( len D454 ) - C590 ) + 1 ) in ( dom D454 ) by L2601 , GLIB_001:25;
thus L2604: thesis by L2603;
end;
L2605:
now
let C591 being  odd Nat;
assume that
L2606: C591 <= D451;
L2607: 1 <= C591 by CHORD:2;
L2608: C591 in ( dom D452 ) by L2607 , L2549 , L2606 , FINSEQ_3:25;
thus L2609: ( D452 . C591 ) = ( D454 . C591 ) by L2608 , L2570 , GLIB_001:65;
end;
L2610: (ex B547 being  odd (Element of ( NAT )) st (1 < B547 & B547 < ( len D454 ) & (for B548 , B549 being  odd (Element of ( NAT )) holds ((B547 <= B548 & B548 < B549 & B549 <= ( len D454 )) implies ( C575 . ( D454 . B548 ) ) < ( C575 . ( D454 . B549 ) ))) & (for B550 , B551 being  odd (Element of ( NAT )) holds ((1 <= B550 & B550 < B551 & B551 <= B547) implies ( C575 . ( D454 . B550 ) ) > ( C575 . ( D454 . B551 ) )))))
proof
per cases ;
suppose L2611: D451 <= C584;

L2612:
now
L2613: 1 < ( ( 2 * 1 ) + 1 );
L2614: ( C575 . ( C581 . 3 ) ) > ( C575 . ( C581 . D451 ) ) by L2613 , L2520 , L2541 , L2611;
let C592 , C593 being  odd (Element of ( NAT ));
assume that
L2615: D451 <= C592
and
L2616: C592 < C593
and
L2617: C593 <= ( len D454 );
L2618: C592 < ( D451 + ( 2 * 1 ) ) by L2549 , L2574 , L2616 , L2617 , XXREAL_0:2;
L2619: C592 <= ( ( D451 + 2 ) - 2 ) by L2618 , CHORD:3;
L2620: C592 = D451 by L2619 , L2615 , XXREAL_0:1;
L2621: ( D454 . C592 ) = ( D452 . D451 ) by L2620 , L2605;
L2622: ( D454 . C592 ) = ( C581 . D451 ) by L2621 , L2550;
L2623: ( ( len D452 ) + 2 ) <= C593 by L2549 , L2616 , L2620 , CHORD:4;
L2624: ( D454 . C593 ) = C583 by L2623 , L2574 , L2596 , L2617 , XXREAL_0:1;
thus L2625: ( C575 . ( D454 . C592 ) ) < ( C575 . ( D454 . C593 ) ) by L2624 , L2521 , L2622 , L2614 , XXREAL_0:2;
end;
take D451;
L2626:
now
let C594 , C595 being  odd (Element of ( NAT ));
assume that
L2627: 1 <= C594
and
L2628: C594 < C595
and
L2629: C595 <= D451;
L2630: ( D454 . C594 ) = ( D452 . C594 ) by L2605 , L2628 , L2629 , XXREAL_0:2;
L2631: ( D454 . C594 ) = ( C581 . C594 ) by L2630 , L2550 , L2628 , L2629 , XXREAL_0:2;
L2632: ( D454 . C595 ) = ( D452 . C595 ) by L2605 , L2629;
L2633: ( D454 . C595 ) = ( C581 . C595 ) by L2632 , L2550 , L2629;
L2634: C595 <= C584 by L2611 , L2629 , XXREAL_0:2;
thus L2635: ( C575 . ( D454 . C594 ) ) > ( C575 . ( D454 . C595 ) ) by L2634 , L2520 , L2627 , L2628 , L2631 , L2633;
end;
thus L2636: thesis by L2626 , L2541 , L2549 , L2574 , L2612 , XREAL_1:29 , XXREAL_0:2;
end;
suppose L2637: C584 < D451;

take C584;
L2638:
now
let C596 , C597 being  odd (Element of ( NAT ));
assume that
L2639: C584 <= C596
and
L2640: C596 < C597
and
L2641: C597 <= ( len D454 );
L2642: C596 < ( D451 + ( 2 * 1 ) ) by L2549 , L2574 , L2640 , L2641 , XXREAL_0:2;
L2643: C596 <= ( ( D451 + 2 ) - 2 ) by L2642 , CHORD:3;
L2644: C596 <= ( len C581 ) by L2643 , L2542 , XXREAL_0:2;
L2645: ( D454 . C596 ) = ( D452 . C596 ) by L2605 , L2643;
L2646: ( D454 . C596 ) = ( C581 . C596 ) by L2645 , L2550 , L2643;
per cases  by L2641 , XXREAL_0:1;
suppose L2647: C597 = ( len D454 );

L2648:
now
per cases  by L2644 , XXREAL_0:1;
suppose L2649: C596 = ( len C581 );

thus L2650: ( C575 . ( D454 . C596 ) ) <= ( C575 . D449 ) by L2649 , L2550 , L2643 , L2645;
end;
suppose L2651: C596 < ( len C581 );

thus L2652: ( C575 . ( D454 . C596 ) ) <= ( C575 . D449 ) by L2651 , L2519 , L2639 , L2646;
end;
end;
thus L2654: ( C575 . ( D454 . C596 ) ) < ( C575 . ( D454 . C597 ) ) by L2648 , L2513 , L2596 , L2647 , XXREAL_0:2;
end;
suppose L2655: C597 < ( len D454 );

L2656: C597 <= ( ( D451 + 2 ) - 2 ) by L2655 , L2549 , L2574 , CHORD:3;
L2657: ( D454 . C597 ) = ( D452 . C597 ) by L2656 , L2605;
L2658: ( D454 . C597 ) = ( C581 . C597 ) by L2657 , L2550 , L2656;
L2659: C597 <= ( len C581 ) by L2542 , L2656 , XXREAL_0:2;
thus L2660: ( C575 . ( D454 . C596 ) ) < ( C575 . ( D454 . C597 ) ) by L2659 , L2519 , L2639 , L2640 , L2646 , L2658;
end;
end;
L2662:
now
let C598 , C599 being  odd (Element of ( NAT ));
assume that
L2663: 1 <= C598
and
L2664: C598 < C599
and
L2665: C599 <= C584;
L2666: ( D454 . C599 ) = ( D452 . C599 ) by L2605 , L2637 , L2665 , XXREAL_0:2;
L2667: ( D454 . C599 ) = ( C581 . C599 ) by L2666 , L2550 , L2637 , L2665 , XXREAL_0:2;
L2668: C598 <= C584 by L2664 , L2665 , XXREAL_0:2;
L2669: ( D454 . C598 ) = ( D452 . C598 ) by L2668 , L2605 , L2637 , XXREAL_0:2;
L2670: ( D454 . C598 ) = ( C581 . C598 ) by L2669 , L2550 , L2637 , L2668 , XXREAL_0:2;
thus L2671: ( C575 . ( D454 . C598 ) ) > ( C575 . ( D454 . C599 ) ) by L2670 , L2520 , L2663 , L2664 , L2665 , L2667;
end;
L2672: ( len D454 ) > D451 by L2549 , L2574 , XREAL_1:29;
thus L2673: thesis by L2672 , L2517 , L2637 , L2638 , L2662 , XXREAL_0:2;
end;
end;
L2675: (ex B552 being  odd (Element of ( NAT )) st (1 < B552 & B552 < ( len D455 ) & (for B553 , B554 being  odd (Element of ( NAT )) holds ((B552 <= B553 & B553 < B554 & B554 <= ( len D455 )) implies ( C575 . ( D455 . B553 ) ) < ( C575 . ( D455 . B554 ) ))) & (for B555 , B556 being  odd (Element of ( NAT )) holds ((1 <= B555 & B555 < B556 & B556 <= B552) implies ( C575 . ( D455 . B555 ) ) > ( C575 . ( D455 . B556 ) )))))
proof
consider C600 being  odd (Element of ( NAT )) such that L2676: 1 < C600 and L2677: C600 < ( len D454 ) and L2678: (for B557 , B558 being  odd (Element of ( NAT )) holds ((C600 <= B557 & B557 < B558 & B558 <= ( len D454 )) implies ( C575 . ( D454 . B557 ) ) < ( C575 . ( D454 . B558 ) ))) and L2679: (for B559 , B560 being  odd (Element of ( NAT )) holds ((1 <= B559 & B559 < B560 & B560 <= C600) implies ( C575 . ( D454 . B559 ) ) > ( C575 . ( D454 . B560 ) ))) by L2610;
set D456 = ( ( ( len D454 ) - C600 ) + 1 );
L2680: ( ( len D454 ) - 1 ) > ( ( len D454 ) - C600 ) by L2676 , XREAL_1:15;
L2681: ( ( ( len D454 ) - 1 ) + 1 ) > ( ( ( len D454 ) - C600 ) + 1 ) by L2680 , XREAL_1:8;
L2682: D456 < ( len D455 ) by L2681 , GLIB_001:21;
L2683: ( ( len D454 ) - ( len D454 ) ) < ( ( len D454 ) - C600 ) by L2677 , XREAL_1:15;
reconsider D457 = D456 as  odd (Element of ( NAT )) by L2683 , INT_1:3;
L2684:
now
let C601 , C602 being  odd (Element of ( NAT ));
assume that
L2685: 1 <= C601
and
L2686: C601 < C602
and
L2687: C602 <= D457;
set D458 = ( ( ( len D454 ) - C601 ) + 1 );
L2688: C602 <= ( len D455 ) by L2682 , L2687 , XXREAL_0:2;
L2689: C601 <= ( len D455 ) by L2688 , L2686 , XXREAL_0:2;
L2690: ( D455 . C601 ) = ( D454 . D458 ) by L2689 , L2598;
L2691: ( C600 + C602 ) <= ( ( ( ( len D454 ) - C600 ) + 1 ) + C600 ) by L2687 , XREAL_1:7;
L2692: ( ( C600 + C602 ) - C602 ) <= ( ( ( len D454 ) + 1 ) - C602 ) by L2691 , XREAL_1:9;
set D459 = ( ( ( len D454 ) - C602 ) + 1 );
L2693: D459 < D458 by L2686 , L68;
reconsider D460 = D458 as  odd (Element of ( NAT )) by L2598 , L2689;
reconsider D461 = D459 as  odd (Element of ( NAT )) by L2598 , L2688;
L2694: ( ( len D454 ) - C601 ) <= ( ( len D454 ) - 1 ) by L2685 , XREAL_1:10;
L2695: D460 <= ( ( ( len D454 ) - 1 ) + 1 ) by L2694 , XREAL_1:7;
L2696: ( C575 . ( D454 . D461 ) ) < ( C575 . ( D454 . D460 ) ) by L2695 , L2678 , L2692 , L2693;
thus L2697: ( C575 . ( D455 . C601 ) ) > ( C575 . ( D455 . C602 ) ) by L2696 , L2598 , L2688 , L2690;
end;
take D457;
L2698:
now
let C603 , C604 being  odd (Element of ( NAT ));
assume that
L2699: D457 <= C603
and
L2700: C603 < C604
and
L2701: C604 <= ( len D455 );
set D462 = ( ( ( len D454 ) - C604 ) + 1 );
L2702: ( D455 . C604 ) = ( D454 . D462 ) by L2598 , L2701;
set D463 = ( ( ( len D454 ) - C603 ) + 1 );
L2703: C603 <= ( len D455 ) by L2700 , L2701 , XXREAL_0:2;
L2704: ( D455 . C603 ) = ( D454 . D463 ) by L2703 , L2598;
reconsider D464 = D462 as  odd (Element of ( NAT )) by L2598 , L2701;
L2705: ( C600 + C603 ) >= ( ( ( ( len D454 ) - C600 ) + 1 ) + C600 ) by L2699 , XREAL_1:7;
L2706: ( ( C600 + C603 ) - C603 ) >= ( ( ( len D454 ) + 1 ) - C603 ) by L2705 , XREAL_1:9;
reconsider D465 = D463 as  odd (Element of ( NAT )) by L2598 , L2703;
L2707: D464 < D465 by L2700 , L68;
thus L2708: ( C575 . ( D455 . C603 ) ) < ( C575 . ( D455 . C604 ) ) by L2707 , L2679 , L2704 , L2702 , L2706 , CHORD:2;
end;
L2709: ( ( 0 ) + 1 ) < ( ( ( len D454 ) - C600 ) + 1 ) by L2683 , XREAL_1:8;
thus L2710: thesis by L2709 , L2681 , L2698 , L2684 , GLIB_001:21;
end;
L2711: ( len D454 ) >= ( 3 + 2 ) by L2541 , L2549 , L2574 , XREAL_1:7;
L2712: ( len D455 ) >= ( 3 + 2 ) by L2711 , GLIB_001:21;
L2713: 3 <= ( len D455 ) by L2712 , XXREAL_0:2;
L2714: 3 in ( dom D455 ) by L2713 , FINSEQ_3:25;
L2715: ( D455 . 3 ) = ( D454 . ( ( ( len D454 ) - 3 ) + 1 ) ) by L2714 , GLIB_001:25;
L2716: ( D455 . 3 ) = ( D452 . D451 ) by L2715 , L2549 , L2574 , L2605;
L2717: ( C575 . ( D455 .last() ) ) > ( C575 . ( D455 . 3 ) ) by L2716 , L2550 , L2592 , L2575;
L2718: C583 <> D450 by L2503 , L2514 , CHORD:def 3;
L2719: D455 is  open by L2718 , L2597 , L2592 , GLIB_001:def 24;
L2720: D454 is  open by L2572 , L2570 , L2547 , L2558 , CHORD:97;
L2721: ( C575 . D450 ) <= ( C575 . C583 ) by L2720 , L2497 , L2499 , L2513 , L2521 , L2595 , L2711 , L2591 , L2596 , L2594 , L2610;
L2722: ( C575 . D450 ) < ( C575 . C583 ) by L2721 , L2516 , XXREAL_0:1;
L2723: D455 is  chordless by L2595 , CHORD:91;
thus L2724: contradiction by L2723 , L2497 , L2498 , L2499 , L2722 , L2597 , L2592 , L2719 , L2712 , L2717 , L2675;
end;
L2725: ( C575 " ) = C576 by L2482 , L2483 , FUNCT_1:43;
L2726:
now
let C605 , C606 , C607 being (Vertex of C574);
assume that
L2727: C606 <> C607
and
L2728: C605 , C606 are_adjacent 
and
L2729: C605 , C607 are_adjacent ;
let C608 , C609 , C610 being Nat;
assume that
L2730: C608 in ( dom C576 )
and
L2731: C609 in ( dom C576 )
and
L2732: C610 in ( dom C576 )
and
L2733: ( C576 . C608 ) = C605
and
L2734: ( C576 . C609 ) = C606
and
L2735: ( C576 . C610 ) = C607
and
L2736: C608 < C609
and
L2737: C608 < C610;
L2738: ( C575 . C605 ) = C608 by L2482 , L2483 , L2730 , L2733 , FUNCT_1:34;
L2739: C607 = ( C576 . ( C575 . C607 ) ) by L2481 , L2482 , L2483 , L2725 , FUNCT_1:34;
L2740: C606 = ( C576 . ( C575 . C606 ) ) by L2481 , L2482 , L2483 , L2725 , FUNCT_1:34;
assume L2741: (not C606 , C607 are_adjacent );
L2742: ( C575 . C606 ) = C609 by L2482 , L2483 , L2731 , L2734 , FUNCT_1:34;
L2743: ( C575 . C607 ) = C610 by L2482 , L2483 , L2732 , L2735 , FUNCT_1:34;
per cases  by L2727 , L2740 , L2739 , XXREAL_0:1;
suppose L2744: ( C575 . C606 ) < ( C575 . C607 );

L2745: ( ( 2 * 1 ) + 1 ) is  odd;
consider C611 being (Path of C574), C612 , C613 being set such that L2746: C611 is  open and L2747: ( len C611 ) = 5 and L2748: ( C611 .length() ) = 2 and L2749: C612 Joins C607 , C605 , C574 and L2750: C613 Joins C605 , C606 , C574 and L2751: ( C611 .edges() ) = { C612 , C613 } and L2752: ( C611 .vertices() ) = { C607 , C605 , C606 } and L2753: ( C611 . 1 ) = C607 and L2754: ( C611 . 3 ) = C605 and L2755: ( C611 . 5 ) = C606 by L2727 , L2728 , L2729 , L2736 , L2737 , L2738 , L2742 , L2743 , CHORD:47;
L2756: ( C611 .first() ) = C607 by L2753;
L2757:
now
let C614 , C615 being  odd (Element of ( NAT ));
assume that
L2758: 1 <= C614
and
L2759: C614 < C615
and
L2760: C615 <= 3;
L2761: C614 < 3 by L2759 , L2760 , XXREAL_0:2;
L2762: C614 = 1 by L2761 , CHORD:7 , XXREAL_0:2;
thus L2763: ( C575 . ( C611 . C614 ) ) > ( C575 . ( C611 . C615 ) ) by L2762 , L2737 , L2738 , L2743 , L2753 , L2754 , L2759 , L2760 , CHORD:7 , XXREAL_0:2;
end;
L2764:
now
let C616 , C617 being  odd (Element of ( NAT ));
assume that
L2765: 3 <= C616
and
L2766: C616 < C617
and
L2767: C617 <= ( len C611 );
L2768: C616 < 5 by L2747 , L2766 , L2767 , XXREAL_0:2;
L2769: (C616 = 1 or C616 = 3 or C616 = 5) by L2768 , CHORD:8 , XXREAL_0:2;
thus L2770: ( C575 . ( C611 . C616 ) ) < ( C575 . ( C611 . C617 ) ) by L2769 , L2736 , L2737 , L2738 , L2742 , L2743 , L2747 , L2753 , L2754 , L2755 , L2765 , L2766 , L2767 , CHORD:8 , XXREAL_0:2;
end;
L2771: ( C611 .last() ) = C606 by L2747 , L2755;
L2772: S31[ C611 ] by L2771 , L2741 , L2744 , L2746 , L2747 , L2756 , L2764 , L2757 , L2745 , CHORD:90;
thus L2773: contradiction by L2772 , L2487;
end;
suppose L2774: ( C575 . C607 ) < ( C575 . C606 );

L2775: ( ( 2 * 1 ) + 1 ) is  odd;
consider C618 being (Path of C574), C619 , C620 being set such that L2776: C618 is  open and L2777: ( len C618 ) = 5 and L2778: ( C618 .length() ) = 2 and L2779: C619 Joins C606 , C605 , C574 and L2780: C620 Joins C605 , C607 , C574 and L2781: ( C618 .edges() ) = { C619 , C620 } and L2782: ( C618 .vertices() ) = { C606 , C605 , C607 } and L2783: ( C618 . 1 ) = C606 and L2784: ( C618 . 3 ) = C605 and L2785: ( C618 . 5 ) = C607 by L2727 , L2728 , L2729 , L2736 , L2737 , L2738 , L2742 , L2743 , CHORD:47;
L2786: ( C618 .first() ) = C606 by L2783;
L2787:
now
let C621 , C622 being  odd (Element of ( NAT ));
assume that
L2788: 1 <= C621
and
L2789: C621 < C622
and
L2790: C622 <= 3;
L2791: C621 < 3 by L2789 , L2790 , XXREAL_0:2;
L2792: C621 = 1 by L2791 , CHORD:7 , XXREAL_0:2;
thus L2793: ( C575 . ( C618 . C621 ) ) > ( C575 . ( C618 . C622 ) ) by L2792 , L2736 , L2738 , L2742 , L2783 , L2784 , L2789 , L2790 , CHORD:7 , XXREAL_0:2;
end;
L2794:
now
let C623 , C624 being  odd (Element of ( NAT ));
assume that
L2795: 3 <= C623
and
L2796: C623 < C624
and
L2797: C624 <= ( len C618 );
L2798: C623 < 5 by L2777 , L2796 , L2797 , XXREAL_0:2;
L2799: (C623 = 1 or C623 = 3 or C623 = 5) by L2798 , CHORD:8 , XXREAL_0:2;
thus L2800: ( C575 . ( C618 . C623 ) ) < ( C575 . ( C618 . C624 ) ) by L2799 , L2736 , L2737 , L2738 , L2742 , L2743 , L2777 , L2783 , L2784 , L2785 , L2795 , L2796 , L2797 , CHORD:8 , XXREAL_0:2;
end;
L2801: ( C618 .last() ) = C607 by L2777 , L2785;
L2802: S31[ C618 ] by L2801 , L2741 , L2774 , L2776 , L2777 , L2786 , L2794 , L2787 , L2775 , CHORD:90;
thus L2803: contradiction by L2802 , L2487;
end;
end;
thus L2805: thesis by L2726 , CHORD:109;
end;
