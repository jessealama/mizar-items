:: Basic Operations on Preordered Coherent Spaces
::  by Klaus E. Grue and Artur Korni{\l}owicz
::
:: Received August 28, 2007
:: Copyright (c) 2007-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies CARD_1, SUBSET_1, RELAT_1, XBOOLE_0, PARTFUN1, RELAT_2, PRALG_1,
      PBOOLE, RLVECT_2, FUNCT_1, STRUCT_0, ZFMISC_1, TARSKI, ORDERS_2,
      YELLOW16, YELLOW_1, MSUALG_4, EQREL_1, FUNCOP_1, MCART_1, XXREAL_0,
      WAYBEL_3, CARD_3, YELLOW_3, SETFAM_1, PCS_0, AFINSQ_1, FINSEQ_1;
 notations TARSKI, XBOOLE_0,
      XTUPLE_0, SUBSET_1, ZFMISC_1, MCART_1, DOMAIN_1, RELAT_1,
      FUNCT_1, PARTFUN1, RELSET_1, RELAT_2, EQREL_1, CARD_3, PARTIT_2, FUNCT_4,
      NUMBERS, PBOOLE, FUNCOP_1, AFINSQ_1, STRUCT_0, TSEP_1, ORDERS_2, PRALG_1,
      YELLOW_1, WAYBEL_3, YELLOW16, YELLOW_3;
 constructors PRALG_1, PARTIT_2, TSEP_1, YELLOW16, YELLOW_3, DOMAIN_1,
      RELSET_1, FUNCT_4, AFINSQ_1, XTUPLE_0;
 registrations EQREL_1, PARTFUN1, SUBSET_1, XBOOLE_0, WAYBEL_3, RELAT_1,
      TOLER_1, ORDERS_2, PRALG_1, STRUCT_0, YELLOW16, YELLOW_3, RELSET_1,
      FUNCOP_1, AFINSQ_1, RELAT_2, XTUPLE_0;
 requirements BOOLE, SUBSET;
 definitions SUBSET_1, RELAT_1, PARTFUN1, RELAT_2, EQREL_1, CARD_3, ORDERS_2,
      PARTIT_2, STRUCT_0, TSEP_1, PRALG_1, YELLOW_1, WAYBEL_3, TARSKI,
      XBOOLE_0, FUNCOP_1, XTUPLE_0;
 theorems ZFMISC_1, ORDERS_2, RELSET_1, PARTFUN1, RELAT_1, RELAT_2, XBOOLE_0,
      TARSKI, FUNCT_1, PBOOLE, FUNCOP_1, PRALG_1, XBOOLE_1, ORDERS_1, FUNCT_4,
      YELLOW16, YELLOW_0, WAYBEL_8, YELLOW_3, MCART_1, SETFAM_1, AFINSQ_1,
      CARD_1, XTUPLE_0;
 schemes RELSET_1, CLASSES1, RELAT_1;

begin
reconsider D1 = ( 0 ) , D2 = 1 as (Element of { ( 0 ) , 1 }) by TARSKI:def 2;
definition
let C1 , C2 being set;
let C3 being (Relation of C1 , C2);
redefine func field C3 -> (Subset of ( C1 \/ C2 ));

coherence by RELSET_1:8;
end;
definition
let C4 , C5 , C6 , C7 being set;
let C8 being (Relation of C4 , C5);
let C9 being (Relation of C6 , C7);
redefine func C8 \/ C9 -> (Relation of ( C4 \/ C6 ) , ( C5 \/ C7 ));

coherence by ZFMISC_1:119;
end;
registration
let C10 , C11 being set;
let C12 being  total (Relation of C10);
let C13 being  total (Relation of C11);
cluster ( C12 \/ C13 ) ->  total for (Relation of ( C10 \/ C11 ));
coherence
proof
L3: ( dom ( C12 \/ C13 ) ) = ( ( dom C12 ) \/ ( dom C13 ) ) by RELAT_1:1
.= ( C10 \/ ( dom C13 ) ) by PARTFUN1:def 2
.= ( C10 \/ C11 ) by PARTFUN1:def 2;
thus L4: thesis by L3 , PARTFUN1:def 2;
end;
end;
registration
let C14 , C15 being set;
let C16 being  reflexive (Relation of C14);
let C17 being  reflexive (Relation of C15);
cluster ( C16 \/ C17 ) ->  reflexive for (Relation of ( C14 \/ C15 ));
coherence;
end;
registration
let C18 , C19 being set;
let C20 being  symmetric (Relation of C18);
let C21 being  symmetric (Relation of C19);
cluster ( C20 \/ C21 ) ->  symmetric for (Relation of ( C18 \/ C19 ));
coherence;
end;
L8:
now
let C22 , C23 being set;
let C24 being (Relation of C22);
let C25 being (Relation of C23);
assume that
L9: C22 misses C23;
let C26 , C27 being set;
assume that
L10: [ C26 , C27 ] in ( C24 \/ C25 )
and
L11: C27 in C23;
L12: ([ C26 , C27 ] in C24 or [ C26 , C27 ] in C25) by L10 , XBOOLE_0:def 3;
L13:
now
assume L14: [ C26 , C27 ] in C24;
L15: C27 in C22 by L14 , ZFMISC_1:87;
thus L16: contradiction by L15 , L9 , L11 , XBOOLE_0:3;
end;
thus L17: ([ C26 , C27 ] in C25 & C26 in C23) by L13 , L12 , ZFMISC_1:87;
end;
theorem
L18: (for B1 , B2 being set holds (for B3 being  transitive (Relation of B1) holds (for B4 being  transitive (Relation of B2) holds (B1 misses B2 implies ( B3 \/ B4 ) is  transitive))))
proof
let C28 , C29 being set;
let C30 being  transitive (Relation of C28);
let C31 being  transitive (Relation of C29);
assume that
L19: C28 misses C29;
let C32 , C33 , C34 being set;
set D3 = ( C30 \/ C31 );
set D4 = ( field D3 );
assume that
L20: C32 in D4
and
L21: C33 in D4
and
L22: C34 in D4
and
L23: [ C32 , C33 ] in D3
and
L24: [ C33 , C34 ] in D3;
per cases  by L22 , XBOOLE_0:def 3;
suppose L25: C34 in C28;

L26: C33 in C28 by L25 , L19 , L24 , L8;
L27: [ C32 , C33 ] in C30 by L26 , L19 , L23 , L8;
L28: [ C33 , C34 ] in C30 by L19 , L24 , L25 , L8;
L29: [ C32 , C34 ] in C30 by L28 , L27 , RELAT_2:31;
thus L30: thesis by L29 , XBOOLE_0:def 3;
end;
suppose L31: C34 in C29;

L32: C33 in C29 by L31 , L19 , L24 , L8;
L33: [ C32 , C33 ] in C31 by L32 , L19 , L23 , L8;
L34: [ C33 , C34 ] in C31 by L19 , L24 , L31 , L8;
L35: [ C32 , C34 ] in C31 by L34 , L33 , RELAT_2:31;
thus L36: thesis by L35 , XBOOLE_0:def 3;
end;
end;
definition
let C35 being non  empty set;
let C36 being  1-sorted-yielding (ManySortedSet of C35);
redefine func Carrier C36 means 
:L38: (for B5 being (Element of C35) holds ( it . B5 ) = (the carrier of ( C36 . B5 )));
compatibility
proof
let C37 being (ManySortedSet of C35);
thus L39: (C37 = ( Carrier C36 ) implies (for B6 being (Element of C35) holds ( C37 . B6 ) = (the carrier of ( C36 . B6 ))))
proof
assume L40: C37 = ( Carrier C36 );
let C38 being (Element of C35);
L41: (ex B7 being 1-sorted st (B7 = ( C36 . C38 ) & ( C37 . C38 ) = (the carrier of B7))) by L40 , PRALG_1:def 13;
thus L42: thesis by L41;
end;

assume L43: (for B8 being (Element of C35) holds ( C37 . B8 ) = (the carrier of ( C36 . B8 )));
L44: (for B9 being set holds (B9 in C35 implies (ex B10 being 1-sorted st (B10 = ( C36 . B9 ) & ( C37 . B9 ) = (the carrier of B10)))))
proof
let C39 being set;
assume L45: C39 in C35;
reconsider D5 = C39 as (Element of C35) by L45;
take ( C36 . D5 );
thus L46: thesis by L43;
end;
thus L47: thesis by L44 , PRALG_1:def 13;
end;
end;
definition
let C40 , C41 , C42 , C43 being set;
let C44 being (Relation of C40 , C41);
let C45 being (Relation of C42 , C43);
defpred S1[ set , set ] means (ex B11 , B12 , B13 , B14 being set st ($1 = [ B11 , B12 ] & $2 = [ B13 , B14 ] & B11 in C40 & B12 in C42 & B13 in C41 & B14 in C43 & ([ B11 , B13 ] in C44 or [ B12 , B14 ] in C45)));
func [^C44 , C45 ^] -> (Relation of [: C40 , C42 :] , [: C41 , C43 :]) means 
:L49: (for B15 , B16 being set holds ([ B15 , B16 ] in it iff (ex B17 , B18 , B19 , B20 being set st (B15 = [ B17 , B18 ] & B16 = [ B19 , B20 ] & B17 in C40 & B18 in C42 & B19 in C41 & B20 in C43 & ([ B17 , B19 ] in C44 or [ B18 , B20 ] in C45)))));
existence
proof
consider C46 being (Relation of [: C40 , C42 :] , [: C41 , C43 :]) such that L50: (for B21 , B22 being set holds ([ B21 , B22 ] in C46 iff (B21 in [: C40 , C42 :] & B22 in [: C41 , C43 :] & S1[ B21 , B22 ]))) from RELSET_1:sch 1;
take C46;
let C47 , C48 being set;
thus L51: ([ C47 , C48 ] in C46 implies S1[ C47 , C48 ]) by L50;
given C49 , C50 , C51 , C52 being set such that
L52: C47 = [ C49 , C50 ]
and
L53: C48 = [ C51 , C52 ]
and
L54: C49 in C40
and
L55: C50 in C42
and
L56: C51 in C41
and
L57: C52 in C43
and
L58: ([ C49 , C51 ] in C44 or [ C50 , C52 ] in C45);

L59: C47 in [: C40 , C42 :] by L52 , L54 , L55 , ZFMISC_1:87;
L60: C48 in [: C41 , C43 :] by L53 , L56 , L57 , ZFMISC_1:87;
thus L61: thesis by L60 , L50 , L52 , L53 , L54 , L55 , L56 , L57 , L58 , L59;
end;
uniqueness
proof
let C53 , C54 being (Relation of [: C40 , C42 :] , [: C41 , C43 :]);
assume that
L62: (for B23 , B24 being set holds ([ B23 , B24 ] in C53 iff S1[ B23 , B24 ]))
and
L63: (for B25 , B26 being set holds ([ B25 , B26 ] in C54 iff S1[ B25 , B26 ]));
thus L64: C53 = C54 from RELAT_1:sch 2(L62 , L63);
end;
end;
definition
let C55 , C56 , C57 , C58 being non  empty set;
let C59 being (Relation of C55 , C56);
let C60 being (Relation of C57 , C58);
redefine func [^C59 , C60 ^] means 
:L66: (for B27 being (Element of C55) holds (for B28 being (Element of C56) holds (for B29 being (Element of C57) holds (for B30 being (Element of C58) holds ([ [ B27 , B29 ] , [ B28 , B30 ] ] in it iff ([ B27 , B28 ] in C59 or [ B29 , B30 ] in C60))))));
compatibility
proof
let C61 being (Relation of [: C55 , C57 :] , [: C56 , C58 :]);
thus L67: (C61 = [^ C59 , C60 ^] implies (for B31 being (Element of C55) holds (for B32 being (Element of C56) holds (for B33 being (Element of C57) holds (for B34 being (Element of C58) holds ([ [ B31 , B33 ] , [ B32 , B34 ] ] in C61 iff ([ B31 , B32 ] in C59 or [ B33 , B34 ] in C60)))))))
proof
assume L68: C61 = [^ C59 , C60 ^];
let C62 being (Element of C55);
let C63 being (Element of C56);
let C64 being (Element of C57);
let C65 being (Element of C58);
thus L69:now
assume L70: [ [ C62 , C64 ] , [ C63 , C65 ] ] in C61;
consider C66 , C67 , C68 , C69 being set such that L71: [ C62 , C64 ] = [ C66 , C67 ] and L72: [ C63 , C65 ] = [ C68 , C69 ] and L73: C66 in C55 and L74: C67 in C57 and L75: C68 in C56 and L76: C69 in C58 and L77: ([ C66 , C68 ] in C59 or [ C67 , C69 ] in C60) by L70 , L68 , L49;
L78: C62 = C66 by L71 , XTUPLE_0:1;
L79: C64 = C67 by L71 , XTUPLE_0:1;
thus L80: ([ C62 , C63 ] in C59 or [ C64 , C65 ] in C60) by L79 , L72 , L77 , L78 , XTUPLE_0:1;
end;
thus L81: thesis by L68 , L49;
end;

assume L82: (for B35 being (Element of C55) holds (for B36 being (Element of C56) holds (for B37 being (Element of C57) holds (for B38 being (Element of C58) holds ([ [ B35 , B37 ] , [ B36 , B38 ] ] in C61 iff ([ B35 , B36 ] in C59 or [ B37 , B38 ] in C60))))));
L83: (for B39 , B40 being set holds ([ B39 , B40 ] in C61 iff [ B39 , B40 ] in [^ C59 , C60 ^]))
proof
let C70 , C71 being set;
thus L84: ([ C70 , C71 ] in C61 implies [ C70 , C71 ] in [^ C59 , C60 ^])
proof
assume L85: [ C70 , C71 ] in C61;
L86: C70 in ( dom C61 ) by L85 , XTUPLE_0:def 12;
consider C72 , C73 being set such that L87: C72 in C55 and L88: C73 in C57 and L89: C70 = [ C72 , C73 ] by L86 , ZFMISC_1:def 2;
L90: C71 in ( rng C61 ) by L85 , XTUPLE_0:def 13;
consider C74 , C75 being set such that L91: C74 in C56 and L92: C75 in C58 and L93: C71 = [ C74 , C75 ] by L90 , ZFMISC_1:def 2;
L94: ([ C72 , C74 ] in C59 or [ C73 , C75 ] in C60) by L82 , L85 , L87 , L88 , L89 , L91 , L92 , L93;
thus L95: thesis by L94 , L87 , L88 , L89 , L91 , L92 , L93 , L49;
end;

assume L96: [ C70 , C71 ] in [^ C59 , C60 ^];
L97: (ex B41 , B42 , B43 , B44 being set st (C70 = [ B41 , B42 ] & C71 = [ B43 , B44 ] & B41 in C55 & B42 in C57 & B43 in C56 & B44 in C58 & ([ B41 , B43 ] in C59 or [ B42 , B44 ] in C60))) by L96 , L49;
thus L98: thesis by L97 , L82;
end;
thus L99: thesis by L83 , RELAT_1:def 2;
end;
end;
registration
let C76 , C77 being set;
let C78 being  total (Relation of C76);
let C79 being  total (Relation of C77);
cluster [^ C78 , C79 ^] ->  total;
coherence
proof
thus L101: ( dom [^ C78 , C79 ^] ) c= [: C76 , C77 :];
let C80 being set;
assume L102: C80 in [: C76 , C77 :];
consider C81 , C82 being set such that L103: C81 in C76 and L104: C82 in C77 and L105: C80 = [ C81 , C82 ] by L102 , ZFMISC_1:def 2;
L106: ( dom C78 ) = C76 by PARTFUN1:def 2;
consider C83 being set such that L107: [ C81 , C83 ] in C78 by L106 , L103 , XTUPLE_0:def 12;
L108: ( dom C79 ) = C77 by PARTFUN1:def 2;
consider C84 being set such that L109: [ C82 , C84 ] in C79 by L108 , L104 , XTUPLE_0:def 12;
L110: C83 in C76 by L107 , ZFMISC_1:87;
L111: C84 in C77 by L109 , ZFMISC_1:87;
L112: [ [ C81 , C82 ] , [ C83 , C84 ] ] in [^ C78 , C79 ^] by L111 , L103 , L104 , L107 , L110 , L49;
thus L113: thesis by L112 , L105 , XTUPLE_0:def 12;
end;
end;
registration
let C85 , C86 being set;
let C87 being  reflexive (Relation of C85);
let C88 being  reflexive (Relation of C86);
cluster [^ C87 , C88 ^] ->  reflexive;
coherence
proof
let C89 being set;
assume L115: C89 in ( field [^ C87 , C88 ^] );
L116: C87 is_reflexive_in ( field C87 ) by RELAT_2:def 9;
L117: C88 is_reflexive_in ( field C88 ) by RELAT_2:def 9;
per cases  by L115 , XBOOLE_0:def 3;
suppose L118: C89 in ( dom [^ C87 , C88 ^] );

consider C90 being set such that L119: [ C89 , C90 ] in [^ C87 , C88 ^] by L118 , XTUPLE_0:def 12;
consider C91 , C92 , C93 , C94 being set such that L120: C89 = [ C91 , C92 ] and L121: C90 = [ C93 , C94 ] and L122: C91 in C85 and L123: C92 in C86 and L124: C93 in C85 and L125: C94 in C86 and L126: ([ C91 , C93 ] in C87 or [ C92 , C94 ] in C88) by L119 , L49;
per cases  by L126;
suppose L127: [ C91 , C93 ] in C87;

L128: C91 in ( field C87 ) by L127 , RELAT_1:15;
L129: [ C91 , C91 ] in C87 by L128 , L116 , RELAT_2:def 1;
thus L130: thesis by L129 , L120 , L122 , L123 , L49;
end;
suppose L131: [ C92 , C94 ] in C88;

L132: C92 in ( field C88 ) by L131 , RELAT_1:15;
L133: [ C92 , C92 ] in C88 by L132 , L117 , RELAT_2:def 1;
thus L134: thesis by L133 , L120 , L122 , L123 , L49;
end;
end;
suppose L136: C89 in ( rng [^ C87 , C88 ^] );

consider C95 being set such that L137: [ C95 , C89 ] in [^ C87 , C88 ^] by L136 , XTUPLE_0:def 13;
consider C96 , C97 , C98 , C99 being set such that L138: C95 = [ C96 , C97 ] and L139: C89 = [ C98 , C99 ] and L140: C96 in C85 and L141: C97 in C86 and L142: C98 in C85 and L143: C99 in C86 and L144: ([ C96 , C98 ] in C87 or [ C97 , C99 ] in C88) by L137 , L49;
per cases  by L144;
suppose L145: [ C96 , C98 ] in C87;

L146: C98 in ( field C87 ) by L145 , RELAT_1:15;
L147: [ C98 , C98 ] in C87 by L146 , L116 , RELAT_2:def 1;
thus L148: thesis by L147 , L139 , L142 , L143 , L49;
end;
suppose L149: [ C97 , C99 ] in C88;

L150: C99 in ( field C88 ) by L149 , RELAT_1:15;
L151: [ C99 , C99 ] in C88 by L150 , L117 , RELAT_2:def 1;
thus L152: thesis by L151 , L139 , L142 , L143 , L49;
end;
end;
end;
end;
registration
let C100 , C101 being set;
let C102 being (Relation of C100);
let C103 being  total  reflexive (Relation of C101);
cluster [^ C102 , C103 ^] ->  reflexive;
coherence
proof
let C104 being set;
assume L156: C104 in ( field [^ C102 , C103 ^] );
consider C105 , C106 being set such that L157: C105 in C100 and L158: C106 in C101 and L159: C104 = [ C105 , C106 ] by L156 , ZFMISC_1:def 2;
L160: C101 = ( field C103 ) by ORDERS_1:12;
L161: C103 is_reflexive_in C101 by L160 , RELAT_2:def 9;
L162: [ C106 , C106 ] in C103 by L161 , L158 , RELAT_2:def 1;
thus L163: thesis by L162 , L157 , L158 , L159 , L66;
end;
end;
registration
let C107 , C108 being set;
let C109 being  total  reflexive (Relation of C107);
let C110 being (Relation of C108);
cluster [^ C109 , C110 ^] ->  reflexive;
coherence
proof
let C111 being set;
assume L165: C111 in ( field [^ C109 , C110 ^] );
consider C112 , C113 being set such that L166: C112 in C107 and L167: C113 in C108 and L168: C111 = [ C112 , C113 ] by L165 , ZFMISC_1:def 2;
L169: C107 = ( field C109 ) by ORDERS_1:12;
L170: C109 is_reflexive_in C107 by L169 , RELAT_2:def 9;
L171: [ C112 , C112 ] in C109 by L170 , L166 , RELAT_2:def 1;
thus L172: thesis by L171 , L166 , L167 , L168 , L66;
end;
end;
registration
let C114 , C115 being set;
let C116 being  symmetric (Relation of C114);
let C117 being  symmetric (Relation of C115);
cluster [^ C116 , C117 ^] ->  symmetric;
coherence
proof
let C118 , C119 being set;
assume that
L174: C118 in ( field [^ C116 , C117 ^] )
and
L175: C119 in ( field [^ C116 , C117 ^] );
assume L176: [ C118 , C119 ] in [^ C116 , C117 ^];
consider C120 , C121 , C122 , C123 being set such that L177: C118 = [ C120 , C121 ] and L178: C119 = [ C122 , C123 ] and L179: C120 in C114 and L180: C121 in C115 and L181: C122 in C114 and L182: C123 in C115 and L183: ([ C120 , C122 ] in C116 or [ C121 , C123 ] in C117) by L176 , L49;
L184: C116 is_symmetric_in ( field C116 ) by RELAT_2:def 11;
L185: C117 is_symmetric_in ( field C117 ) by RELAT_2:def 11;
per cases  by L183;
suppose L186: [ C120 , C122 ] in C116;

L187: C120 in ( field C116 ) by L186 , RELAT_1:15;
L188: C122 in ( field C116 ) by L186 , RELAT_1:15;
L189: [ C122 , C120 ] in C116 by L188 , L184 , L186 , L187 , RELAT_2:def 3;
thus L190: thesis by L189 , L177 , L178 , L179 , L180 , L181 , L182 , L49;
end;
suppose L191: [ C121 , C123 ] in C117;

L192: C121 in ( field C117 ) by L191 , RELAT_1:15;
L193: C123 in ( field C117 ) by L191 , RELAT_1:15;
L194: [ C123 , C121 ] in C117 by L193 , L185 , L191 , L192 , RELAT_2:def 3;
thus L195: thesis by L194 , L177 , L178 , L179 , L180 , L181 , L182 , L49;
end;
end;
end;
begin
registration
cluster  empty ->  total for RelStr;
coherence
proof
let C124 being RelStr;
assume L198: (the carrier of C124) is  empty;
thus L199: ( dom (the InternalRel of C124) ) = (the carrier of C124) by L198;
end;
end;
definition
let C125 being Relation;
attr C125 is  transitive-yielding
means
:L201: (for B45 being RelStr holds (B45 in ( rng C125 ) implies B45 is  transitive));
end;
registration
cluster  Poset-yielding ->  transitive-yielding for Relation;
coherence
proof
let C126 being Relation;
assume L203: C126 is  Poset-yielding;
let C127 being RelStr;
thus L204: thesis by L203 , YELLOW16:def 5;
end;
end;
registration
cluster  Poset-yielding for Function;
existence
proof
set D6 = the  Poset-yielding (ManySortedSet of ( 0 ));
take D6;
thus L206: thesis;
end;
end;
registration
let C128 being set;
cluster  Poset-yielding for (ManySortedSet of C128);
existence
proof
set D7 = the  Poset-yielding (ManySortedSet of C128);
take D7;
thus L208: thesis;
end;
end;
definition
let C129 being set;
let C130 being  RelStr-yielding (ManySortedSet of C129);
func pcs-InternalRels C130 -> (ManySortedSet of C129) means 
:L210: (for B46 being set holds (B46 in C129 implies (ex B47 being RelStr st (B47 = ( C130 . B46 ) & ( it . B46 ) = (the InternalRel of B47)))));
existence
proof
defpred S2[ set , set ] means (ex B48 being RelStr st (B48 = ( C130 . $1 ) & $2 = (the InternalRel of B48)));
L211: (for B49 being set holds (B49 in C129 implies (ex B50 being set st S2[ B49 , B50 ])))
proof
let C131 being set;
assume L212: C131 in C129;
reconsider D8 = C129 as non  empty set by L212;
reconsider D9 = C130 as  RelStr-yielding (ManySortedSet of D8);
reconsider D10 = C131 as (Element of D8) by L212;
take (the InternalRel of ( D9 . D10 ));
take ( D9 . D10 );
thus L213: thesis;
end;
consider C132 being Function such that L214: ( dom C132 ) = C129 and L215: (for B51 being set holds (B51 in C129 implies S2[ B51 , ( C132 . B51 ) ])) from CLASSES1:sch 1(L211);
L216: C132 is (ManySortedSet of C129) by L214 , PARTFUN1:def 2 , RELAT_1:def 18;
thus L217: thesis by L216 , L215;
end;
uniqueness
proof
let C133 , C134 being (ManySortedSet of C129);
assume that
L218: (for B52 being set holds (B52 in C129 implies (ex B53 being RelStr st (B53 = ( C130 . B52 ) & ( C133 . B52 ) = (the InternalRel of B53)))))
and
L219: (for B54 being set holds (B54 in C129 implies (ex B55 being RelStr st (B55 = ( C130 . B54 ) & ( C134 . B54 ) = (the InternalRel of B55)))));
L220: (for B56 being set holds (B56 in C129 implies ( C133 . B56 ) = ( C134 . B56 )))
proof
let C135 being set;
assume L221: C135 in C129;
L222: (ex B57 being RelStr st (B57 = ( C130 . C135 ) & ( C133 . C135 ) = (the InternalRel of B57))) by L221 , L218;
L223: (ex B58 being RelStr st (B58 = ( C130 . C135 ) & ( C134 . C135 ) = (the InternalRel of B58))) by L219 , L221;
thus L224: thesis by L223 , L222;
end;
thus L225: thesis by L220 , PBOOLE:3;
end;
end;
definition
let C136 being non  empty set;
let C137 being  RelStr-yielding (ManySortedSet of C136);
redefine func pcs-InternalRels C137 means 
:L227: (for B59 being (Element of C136) holds ( it . B59 ) = (the InternalRel of ( C137 . B59 )));
compatibility
proof
let C138 being (ManySortedSet of C136);
thus L228: (C138 = ( pcs-InternalRels C137 ) implies (for B60 being (Element of C136) holds ( C138 . B60 ) = (the InternalRel of ( C137 . B60 ))))
proof
assume L229: C138 = ( pcs-InternalRels C137 );
let C139 being (Element of C136);
L230: (ex B61 being RelStr st (B61 = ( C137 . C139 ) & ( C138 . C139 ) = (the InternalRel of B61))) by L229 , L210;
thus L231: thesis by L230;
end;

assume L232: (for B62 being (Element of C136) holds ( C138 . B62 ) = (the InternalRel of ( C137 . B62 )));
L233: (for B63 being set holds (B63 in C136 implies (ex B64 being RelStr st (B64 = ( C137 . B63 ) & ( C138 . B63 ) = (the InternalRel of B64)))))
proof
let C140 being set;
assume L234: C140 in C136;
reconsider D11 = C140 as (Element of C136) by L234;
take ( C137 . D11 );
thus L235: thesis by L232;
end;
thus L236: thesis by L233 , L210;
end;
end;
registration
let C141 being set;
let C142 being  RelStr-yielding (ManySortedSet of C141);
cluster ( pcs-InternalRels C142 ) ->  Relation-yielding;
coherence
proof
set D12 = ( pcs-InternalRels C142 );
let C143 being set;
assume L238: C143 in ( dom D12 );
L239: (ex B65 being RelStr st (B65 = ( C142 . C143 ) & ( D12 . C143 ) = (the InternalRel of B65))) by L238 , L210;
thus L240: thesis by L239;
end;
end;
registration
let C144 being non  empty set;
let C145 being  transitive-yielding  RelStr-yielding (ManySortedSet of C144);
let C146 being (Element of C144);
cluster ( C145 . C146 ) ->  transitive for RelStr;
coherence
proof
L242: ( dom C145 ) = C144 by PARTFUN1:def 2;
L243: ( C145 . C146 ) in ( rng C145 ) by L242 , FUNCT_1:3;
thus L244: thesis by L243 , L201;
end;
end;
begin
definition
struct (1-sorted) TolStr(# carrier -> set , ToleranceRel -> (Relation of the carrier) #);
end;
definition
let C147 being TolStr;
let C148 , C149 being (Element of C147);
pred C148 (--) C149
means
:L247: [ C148 , C149 ] in (the ToleranceRel of C147)
;end;
definition
let C150 being TolStr;
attr C150 is  pcs-tol-total
means
:L249: (the ToleranceRel of C150) is  total;
attr C150 is  pcs-tol-reflexive
means
:L250: (the ToleranceRel of C150) is_reflexive_in (the carrier of C150);
attr C150 is  pcs-tol-irreflexive
means
:L251: (the ToleranceRel of C150) is_irreflexive_in (the carrier of C150);
attr C150 is  pcs-tol-symmetric
means
:L252: (the ToleranceRel of C150) is_symmetric_in (the carrier of C150);
end;
definition
func emptyTolStr -> TolStr equals 
TolStr (# ( {} ) , ( {} (( {} ) , ( {} )) ) #);
coherence;
end;
registration
cluster ( emptyTolStr ) ->  empty  strict;
coherence;
end;
theorem
L256: (for B66 being TolStr holds (B66 is  empty implies ( the TolStr of B66 ) = ( emptyTolStr )))
proof
let C151 being TolStr;
assume L257: C151 is  empty;
L258: (the carrier of C151) = ( {} ) by L257;
thus L259: thesis by L258;
end;
registration
cluster  pcs-tol-reflexive ->  pcs-tol-total for TolStr;
coherence
proof
let C152 being TolStr;
assume L260: C152 is  pcs-tol-reflexive;
L261: (the ToleranceRel of C152) is_reflexive_in (the carrier of C152) by L260 , L250;
L262: ( dom (the ToleranceRel of C152) ) = (the carrier of C152) by L261 , ORDERS_1:13;
thus L263: (the ToleranceRel of C152) is  total by L262 , PARTFUN1:def 2;
end;
end;
registration
cluster  empty ->  pcs-tol-reflexive  pcs-tol-irreflexive  pcs-tol-symmetric for TolStr;
coherence
proof
let C153 being TolStr;
assume L265: C153 is  empty;
L266: ( the TolStr of C153 ) = ( emptyTolStr ) by L265 , L256;
L267: (the carrier of C153) = ( field (the ToleranceRel of C153) ) by L266;
thus L268: (the ToleranceRel of C153) is_reflexive_in (the carrier of C153) by L267 , L265 , RELAT_2:def 9;
thus L269: (the ToleranceRel of C153) is_irreflexive_in (the carrier of C153) by L265 , L267 , RELAT_2:def 10;
thus L270: (the ToleranceRel of C153) is_symmetric_in (the carrier of C153) by L265 , L267 , RELAT_2:def 11;
end;
end;
registration
cluster  empty  strict for TolStr;
existence
proof
take ( emptyTolStr );
thus L272: thesis;
end;
end;
registration
let C154 being  pcs-tol-total TolStr;
cluster (the ToleranceRel of C154) ->  total;
coherence by L249;
end;
registration
let C155 being  pcs-tol-reflexive TolStr;
cluster (the ToleranceRel of C155) ->  reflexive;
coherence
proof
set D13 = (the ToleranceRel of C155);
L275: ( field D13 ) = (the carrier of C155) by ORDERS_1:12;
L276: D13 is_reflexive_in (the carrier of C155) by L250;
thus L277: thesis by L276 , L275 , RELAT_2:def 9;
end;
end;
registration
let C156 being  pcs-tol-irreflexive TolStr;
cluster (the ToleranceRel of C156) ->  irreflexive;
coherence
proof
set D14 = (the ToleranceRel of C156);
L279: D14 is_irreflexive_in (the carrier of C156) by L251;
let C157 being set;
assume L280: C157 in ( field D14 );
assume L281: [ C157 , C157 ] in D14;
L282: C157 in ( dom D14 ) by L281 , XTUPLE_0:def 12;
thus L283: thesis by L282 , L279 , L281 , RELAT_2:def 2;
end;
end;
registration
let C158 being  pcs-tol-symmetric TolStr;
cluster (the ToleranceRel of C158) ->  symmetric;
coherence
proof
set D15 = (the ToleranceRel of C158);
L285: D15 is_symmetric_in (the carrier of C158) by L252;
let C159 , C160 being set;
assume that
L286: C159 in ( field D15 )
and
L287: C160 in ( field D15 );
assume L288: [ C159 , C160 ] in D15;
L289: C159 in ( dom D15 ) by L288 , XTUPLE_0:def 12;
L290: C160 in ( rng D15 ) by L288 , XTUPLE_0:def 13;
thus L291: thesis by L290 , L285 , L288 , L289 , RELAT_2:def 3;
end;
end;
registration
let C161 being  pcs-tol-total TolStr;
cluster ( the TolStr of C161 ) ->  pcs-tol-total;
coherence by L249;
end;
definition
let C162 being  pcs-tol-symmetric TolStr;
let C163 , C164 being (Element of C162);
redefine pred C163 (--) C164
;
symmetry
proof
let C165 , C166 being (Element of C162);
assume L294: [ C165 , C166 ] in (the ToleranceRel of C162);
L295: C165 in (the carrier of C162) by L294 , ZFMISC_1:87;
L296: (the ToleranceRel of C162) is_symmetric_in (the carrier of C162) by L252;
thus L297: [ C166 , C165 ] in (the ToleranceRel of C162) by L296 , L294 , L295 , RELAT_2:def 3;
end;
end;
registration
let C167 being set;
cluster TolStr (# C167 , ( nabla C167 ) #) ->  pcs-tol-reflexive  pcs-tol-symmetric;
coherence
proof
set D16 = TolStr (# C167 , ( nabla C167 ) #);
set D17 = (the ToleranceRel of D16);
L299: ( field D17 ) = (the carrier of D16) by ORDERS_1:12;
thus L300: D17 is_reflexive_in (the carrier of D16) by L299 , RELAT_2:def 9;
thus L301: D17 is_symmetric_in (the carrier of D16) by L299 , RELAT_2:def 11;
end;
end;
registration
let C168 being set;
cluster TolStr (# C168 , ( {} (C168 , C168) ) #) ->  pcs-tol-irreflexive  pcs-tol-symmetric;
coherence
proof
set D18 = TolStr (# C168 , ( {} (C168 , C168) ) #);
thus L303: (the ToleranceRel of D18) is_irreflexive_in (the carrier of D18)
proof
let C169 being set;
thus L304: thesis;
end;

let C170 being set;
thus L305: thesis;
end;
end;
registration
cluster  strict non  empty  pcs-tol-reflexive  pcs-tol-symmetric for TolStr;
existence
proof
take D19 = TolStr (# { ( {} ) } , ( nabla { ( {} ) } ) #);
thus L307: D19 is  strict;
thus L308: (the carrier of D19) is non  empty;
thus L309: thesis;
end;
end;
registration
cluster  strict non  empty  pcs-tol-irreflexive  pcs-tol-symmetric for TolStr;
existence
proof
take D20 = TolStr (# { ( {} ) } , ( {} ({ ( {} ) } , { ( {} ) }) ) #);
thus L311: D20 is  strict;
thus L312: (the carrier of D20) is non  empty;
thus L313: thesis;
end;
end;
definition
let C171 being Relation;
attr C171 is  TolStr-yielding
means
:L315: (for B67 being set holds (B67 in ( rng C171 ) implies B67 is TolStr));
end;
definition
let C172 being Function;
redefine attr C172 is  TolStr-yielding
means
:L317: (for B68 being set holds (B68 in ( dom C172 ) implies ( C172 . B68 ) is TolStr));
compatibility
proof
thus L318:now
assume L319: C172 is  TolStr-yielding;
let C173 being set;
assume L320: C173 in ( dom C172 );
L321: ( C172 . C173 ) in ( rng C172 ) by L320 , FUNCT_1:3;
thus L322: ( C172 . C173 ) is TolStr by L321 , L319 , L315;
end;
assume L323: (for B69 being set holds (B69 in ( dom C172 ) implies ( C172 . B69 ) is TolStr));
let C174 being set;
assume L324: C174 in ( rng C172 );
L325: (ex B70 being set st (B70 in ( dom C172 ) & ( C172 . B70 ) = C174)) by L324 , FUNCT_1:def 3;
thus L326: thesis by L325 , L323;
end;
end;
definition
let C175 being set;
let C176 being (ManySortedSet of C175);
L328: ( dom C176 ) = C175 by PARTFUN1:def 2;
redefine attr C176 is  TolStr-yielding
means
(for B71 being set holds (B71 in C175 implies ( C176 . B71 ) is TolStr));
compatibility by L328 , L317;
end;
definition
let C177 being Relation;
attr C177 is  pcs-tol-reflexive-yielding
means
:L330: (for B72 being TolStr holds (B72 in ( rng C177 ) implies B72 is  pcs-tol-reflexive));
attr C177 is  pcs-tol-irreflexive-yielding
means
:L331: (for B73 being TolStr holds (B73 in ( rng C177 ) implies B73 is  pcs-tol-irreflexive));
attr C177 is  pcs-tol-symmetric-yielding
means
:L332: (for B74 being TolStr holds (B74 in ( rng C177 ) implies B74 is  pcs-tol-symmetric));
end;
registration
cluster  empty ->  pcs-tol-reflexive-yielding  pcs-tol-irreflexive-yielding  pcs-tol-symmetric-yielding for Relation;
coherence
proof
let C178 being Relation;
assume L334: C178 is  empty;
thus L335: C178 is  pcs-tol-reflexive-yielding
proof
let C179 being set;
thus L336: thesis by L334;
end;

thus L337: C178 is  pcs-tol-irreflexive-yielding
proof
let C180 being set;
thus L338: thesis by L334;
end;

let C181 being set;
thus L339: thesis by L334;
end;
end;
registration
let C182 being set;
let C183 being TolStr;
cluster ( C182 --> C183 ) ->  TolStr-yielding for (ManySortedSet of C182);
coherence
proof
L341: ( C182 --> C183 ) is  TolStr-yielding
proof
let C184 being set;
thus L342: thesis by FUNCOP_1:7;
end;
thus L343: thesis by L341;
end;
end;
registration
let C185 being set;
let C186 being  pcs-tol-reflexive TolStr;
cluster ( C185 --> C186 ) ->  pcs-tol-reflexive-yielding for (ManySortedSet of C185);
coherence
proof
set D21 = ( C185 --> C186 );
L345: D21 is  pcs-tol-reflexive-yielding
proof
let C187 being TolStr;
assume L346: C187 in ( rng D21 );
thus L347: thesis by L346 , TARSKI:def 1;
end;
thus L348: thesis by L345;
end;
end;
registration
let C188 being set;
let C189 being  pcs-tol-irreflexive TolStr;
cluster ( C188 --> C189 ) ->  pcs-tol-irreflexive-yielding for (ManySortedSet of C188);
coherence
proof
set D22 = ( C188 --> C189 );
L350: D22 is  pcs-tol-irreflexive-yielding
proof
let C190 being TolStr;
assume L351: C190 in ( rng D22 );
thus L352: thesis by L351 , TARSKI:def 1;
end;
thus L353: thesis by L350;
end;
end;
registration
let C191 being set;
let C192 being  pcs-tol-symmetric TolStr;
cluster ( C191 --> C192 ) ->  pcs-tol-symmetric-yielding for (ManySortedSet of C191);
coherence
proof
set D23 = ( C191 --> C192 );
L355: D23 is  pcs-tol-symmetric-yielding
proof
let C193 being TolStr;
assume L356: C193 in ( rng D23 );
thus L357: thesis by L356 , TARSKI:def 1;
end;
thus L358: thesis by L355;
end;
end;
registration
cluster  TolStr-yielding ->  1-sorted-yielding for Function;
coherence
proof
let C194 being Function;
assume L360: C194 is  TolStr-yielding;
let C195 being set;
thus L361: thesis by L360 , L317;
end;
end;
registration
let C196 being set;
cluster  pcs-tol-reflexive-yielding  pcs-tol-symmetric-yielding  TolStr-yielding for (ManySortedSet of C196);
existence
proof
take ( C196 --> TolStr (# ( 0 ) , ( nabla ( 0 ) ) #) );
thus L363: thesis;
end;
end;
registration
let C197 being set;
cluster  pcs-tol-irreflexive-yielding  pcs-tol-symmetric-yielding  TolStr-yielding for (ManySortedSet of C197);
existence
proof
take ( C197 --> TolStr (# ( 0 ) , ( {} (( 0 ) , ( 0 )) ) #) );
thus L365: thesis;
end;
end;
registration
let C198 being set;
cluster  TolStr-yielding for (ManySortedSet of C198);
existence
proof
set D24 = the TolStr;
take ( C198 --> D24 );
thus L367: thesis;
end;
end;
definition
let C199 being non  empty set;
let C200 being  TolStr-yielding (ManySortedSet of C199);
let C201 being (Element of C199);
redefine func C200 . C201 -> TolStr;

coherence
proof
L369: ( dom C200 ) = C199 by PARTFUN1:def 2;
thus L370: thesis by L369 , L317;
end;
end;
definition
let C202 being set;
let C203 being  TolStr-yielding (ManySortedSet of C202);
func pcs-ToleranceRels C203 -> (ManySortedSet of C202) means 
:L372: (for B75 being set holds (B75 in C202 implies (ex B76 being TolStr st (B76 = ( C203 . B75 ) & ( it . B75 ) = (the ToleranceRel of B76)))));
existence
proof
defpred S3[ set , set ] means (ex B77 being TolStr st (B77 = ( C203 . $1 ) & $2 = (the ToleranceRel of B77)));
L373: (for B78 being set holds (B78 in C202 implies (ex B79 being set st S3[ B78 , B79 ])))
proof
let C204 being set;
assume L374: C204 in C202;
reconsider D25 = C202 as non  empty set by L374;
reconsider D26 = C203 as  TolStr-yielding (ManySortedSet of D25);
reconsider D27 = C204 as (Element of D25) by L374;
take (the ToleranceRel of ( D26 . D27 ));
take ( D26 . D27 );
thus L375: thesis;
end;
consider C205 being Function such that L376: ( dom C205 ) = C202 and L377: (for B80 being set holds (B80 in C202 implies S3[ B80 , ( C205 . B80 ) ])) from CLASSES1:sch 1(L373);
L378: C205 is (ManySortedSet of C202) by L376 , PARTFUN1:def 2 , RELAT_1:def 18;
thus L379: thesis by L378 , L377;
end;
uniqueness
proof
let C206 , C207 being (ManySortedSet of C202);
assume that
L380: (for B81 being set holds (B81 in C202 implies (ex B82 being TolStr st (B82 = ( C203 . B81 ) & ( C206 . B81 ) = (the ToleranceRel of B82)))))
and
L381: (for B83 being set holds (B83 in C202 implies (ex B84 being TolStr st (B84 = ( C203 . B83 ) & ( C207 . B83 ) = (the ToleranceRel of B84)))));
L382: (for B85 being set holds (B85 in C202 implies ( C206 . B85 ) = ( C207 . B85 )))
proof
let C208 being set;
assume L383: C208 in C202;
L384: (ex B86 being TolStr st (B86 = ( C203 . C208 ) & ( C206 . C208 ) = (the ToleranceRel of B86))) by L383 , L380;
L385: (ex B87 being TolStr st (B87 = ( C203 . C208 ) & ( C207 . C208 ) = (the ToleranceRel of B87))) by L381 , L383;
thus L386: thesis by L385 , L384;
end;
thus L387: thesis by L382 , PBOOLE:3;
end;
end;
definition
let C209 being non  empty set;
let C210 being  TolStr-yielding (ManySortedSet of C209);
redefine func pcs-ToleranceRels C210 means 
:L389: (for B88 being (Element of C209) holds ( it . B88 ) = (the ToleranceRel of ( C210 . B88 )));
compatibility
proof
let C211 being (ManySortedSet of C209);
thus L390: (C211 = ( pcs-ToleranceRels C210 ) implies (for B89 being (Element of C209) holds ( C211 . B89 ) = (the ToleranceRel of ( C210 . B89 ))))
proof
assume L391: C211 = ( pcs-ToleranceRels C210 );
let C212 being (Element of C209);
L392: (ex B90 being TolStr st (B90 = ( C210 . C212 ) & ( C211 . C212 ) = (the ToleranceRel of B90))) by L391 , L372;
thus L393: thesis by L392;
end;

assume L394: (for B91 being (Element of C209) holds ( C211 . B91 ) = (the ToleranceRel of ( C210 . B91 )));
L395: (for B92 being set holds (B92 in C209 implies (ex B93 being TolStr st (B93 = ( C210 . B92 ) & ( C211 . B92 ) = (the ToleranceRel of B93)))))
proof
let C213 being set;
assume L396: C213 in C209;
reconsider D28 = C213 as (Element of C209) by L396;
take ( C210 . D28 );
thus L397: thesis by L394;
end;
thus L398: thesis by L395 , L372;
end;
end;
registration
let C214 being set;
let C215 being  TolStr-yielding (ManySortedSet of C214);
cluster ( pcs-ToleranceRels C215 ) ->  Relation-yielding;
coherence
proof
set D29 = ( pcs-ToleranceRels C215 );
let C216 being set;
assume L400: C216 in ( dom D29 );
L401: (ex B94 being TolStr st (B94 = ( C215 . C216 ) & ( D29 . C216 ) = (the ToleranceRel of B94))) by L400 , L372;
thus L402: thesis by L401;
end;
end;
registration
let C217 being non  empty set;
let C218 being  pcs-tol-reflexive-yielding  TolStr-yielding (ManySortedSet of C217);
let C219 being (Element of C217);
cluster ( C218 . C219 ) ->  pcs-tol-reflexive for TolStr;
coherence
proof
L404: ( dom C218 ) = C217 by PARTFUN1:def 2;
L405: ( C218 . C219 ) in ( rng C218 ) by L404 , FUNCT_1:3;
thus L406: thesis by L405 , L330;
end;
end;
registration
let C220 being non  empty set;
let C221 being  pcs-tol-irreflexive-yielding  TolStr-yielding (ManySortedSet of C220);
let C222 being (Element of C220);
cluster ( C221 . C222 ) ->  pcs-tol-irreflexive for TolStr;
coherence
proof
L408: ( dom C221 ) = C220 by PARTFUN1:def 2;
L409: ( C221 . C222 ) in ( rng C221 ) by L408 , FUNCT_1:3;
thus L410: thesis by L409 , L331;
end;
end;
registration
let C223 being non  empty set;
let C224 being  pcs-tol-symmetric-yielding  TolStr-yielding (ManySortedSet of C223);
let C225 being (Element of C223);
cluster ( C224 . C225 ) ->  pcs-tol-symmetric for TolStr;
coherence
proof
L412: ( dom C224 ) = C223 by PARTFUN1:def 2;
L413: ( C224 . C225 ) in ( rng C224 ) by L412 , FUNCT_1:3;
thus L414: thesis by L413 , L332;
end;
end;
theorem
L416: (for B95 , B96 being TolStr holds ((( the TolStr of B95 ) = ( the TolStr of B96 ) & B95 is  pcs-tol-reflexive) implies B96 is  pcs-tol-reflexive))
proof
let C226 , C227 being TolStr;
assume that
L417: ( the TolStr of C226 ) = ( the TolStr of C227 )
and
L418: (the ToleranceRel of C226) is_reflexive_in (the carrier of C226);
let C228 being set;
assume L419: C228 in (the carrier of C227);
thus L420: thesis by L419 , L417 , L418 , RELAT_2:def 1;
end;
theorem
L421: (for B97 , B98 being TolStr holds ((( the TolStr of B97 ) = ( the TolStr of B98 ) & B97 is  pcs-tol-irreflexive) implies B98 is  pcs-tol-irreflexive))
proof
let C229 , C230 being TolStr;
assume that
L422: ( the TolStr of C229 ) = ( the TolStr of C230 )
and
L423: (the ToleranceRel of C229) is_irreflexive_in (the carrier of C229);
let C231 being set;
assume L424: C231 in (the carrier of C230);
thus L425: thesis by L424 , L422 , L423 , RELAT_2:def 2;
end;
theorem
L426: (for B99 , B100 being TolStr holds ((( the TolStr of B99 ) = ( the TolStr of B100 ) & B99 is  pcs-tol-symmetric) implies B100 is  pcs-tol-symmetric))
proof
let C232 , C233 being TolStr;
assume that
L427: ( the TolStr of C232 ) = ( the TolStr of C233 )
and
L428: (the ToleranceRel of C232) is_symmetric_in (the carrier of C232);
let C234 , C235 being set;
assume L429: C234 in (the carrier of C233);
thus L430: thesis by L429 , L427 , L428 , RELAT_2:def 3;
end;
definition
let C236 , C237 being TolStr;
func [^C236 , C237 ^] -> TolStr equals 
TolStr (# [: (the carrier of C236) , (the carrier of C237) :] , [^ (the ToleranceRel of C236) , (the ToleranceRel of C237) ^] #);
coherence;
end;
notation
let C238 , C239 being TolStr;
let C240 being (Element of C238);
let C241 being (Element of C239);
synonym [^C240 , C241 ^] for [C240 , C241 ];
end;
definition
let C242 , C243 being non  empty TolStr;
let C244 being (Element of C242);
let C245 being (Element of C243);
redefine func [^C244 , C245 ^] -> (Element of [^ C242 , C243 ^]);

coherence
proof
L433: [ C244 , C245 ] is (Element of [^ C242 , C243 ^]);
thus L434: thesis by L433;
end;
end;
notation
let C246 , C247 being TolStr;
let C248 being (Element of [^ C246 , C247 ^]);
synonym C248 ^`1 for C248 `1;
synonym C248 ^`2 for C248 `2;
end;
definition
let C249 , C250 being non  empty TolStr;
let C251 being (Element of [^ C249 , C250 ^]);
redefine func C251 ^`1 -> (Element of C249);

coherence by MCART_1:10;
redefine func C251 ^`2 -> (Element of C250);

coherence by MCART_1:10;
end;
theorem
L438: (for B101 , B102 being non  empty TolStr holds (for B103 , B104 being (Element of B101) holds (for B105 , B106 being (Element of B102) holds ([^ B103 , B105 ^] (--) [^ B104 , B106 ^] iff (B103 (--) B104 or B105 (--) B106)))))
proof
let C252 , C253 being non  empty TolStr;
let C254 , C255 being (Element of C252);
let C256 , C257 being (Element of C253);
set D30 = (the ToleranceRel of C252);
set D31 = (the ToleranceRel of C253);
set D32 = [ [ C254 , C256 ] , [ C255 , C257 ] ];
thus L439: ([^ C254 , C256 ^] (--) [^ C255 , C257 ^] implies (C254 (--) C255 or C256 (--) C257))
proof
assume L440: [^ C254 , C256 ^] (--) [^ C255 , C257 ^];
L441: D32 in (the ToleranceRel of [^ C252 , C253 ^]) by L440 , L247;
L442: ([ C254 , C255 ] in D30 or [ C256 , C257 ] in D31) by L441 , L66;
thus L443: thesis by L442 , L247;
end;

assume L444: (C254 (--) C255 or C256 (--) C257);
L445: ([ ( ( D32 `1 ) `1 ) , ( ( D32 `2 ) `1 ) ] in D30 or [ ( ( D32 `1 ) `2 ) , ( ( D32 `2 ) `2 ) ] in D31) by L444 , L247;
thus L446: [ [ C254 , C256 ] , [ C255 , C257 ] ] in (the ToleranceRel of [^ C252 , C253 ^]) by L445 , L66;
end;
theorem
L447: (for B107 , B108 being non  empty TolStr holds (for B109 , B110 being (Element of [^ B107 , B108 ^]) holds (B109 (--) B110 iff (( B109 ^`1 ) (--) ( B110 ^`1 ) or ( B109 ^`2 ) (--) ( B110 ^`2 )))))
proof
let C258 , C259 being non  empty TolStr;
let C260 , C261 being (Element of [^ C258 , C259 ^]);
L448: (ex B111 , B112 being set st (B111 in (the carrier of C258) & B112 in (the carrier of C259) & C260 = [ B111 , B112 ])) by ZFMISC_1:def 2;
L449: (ex B113 , B114 being set st (B113 in (the carrier of C258) & B114 in (the carrier of C259) & C261 = [ B113 , B114 ])) by ZFMISC_1:def 2;
L450: C260 = [ ( C260 ^`1 ) , ( C260 ^`2 ) ] by L448 , MCART_1:8;
L451: C261 = [ ( C261 ^`1 ) , ( C261 ^`2 ) ] by L449 , MCART_1:8;
thus L452: thesis by L451 , L450 , L438;
end;
registration
let C262 being TolStr;
let C263 being  pcs-tol-reflexive TolStr;
cluster [^ C262 , C263 ^] ->  pcs-tol-reflexive;
coherence
proof
let C264 being set;
assume L453: C264 in (the carrier of [^ C262 , C263 ^]);
consider C265 , C266 being set such that L454: C265 in (the carrier of C262) and L455: C266 in (the carrier of C263) and L456: C264 = [ C265 , C266 ] by L453 , ZFMISC_1:def 2;
reconsider D33 = (the carrier of C263) as non  empty set by L455;
reconsider D34 = (the ToleranceRel of C263) as (Relation of D33);
L457: D33 = ( field D34 ) by ORDERS_1:12;
L458: D34 is_reflexive_in D33 by L457 , RELAT_2:def 9;
L459: [ C266 , C266 ] in D34 by L458 , L455 , RELAT_2:def 1;
thus L460: thesis by L459 , L454 , L455 , L456 , L66;
end;
end;
registration
let C267 being  pcs-tol-reflexive TolStr;
let C268 being TolStr;
cluster [^ C267 , C268 ^] ->  pcs-tol-reflexive;
coherence
proof
let C269 being set;
assume L462: C269 in (the carrier of [^ C267 , C268 ^]);
consider C270 , C271 being set such that L463: C270 in (the carrier of C267) and L464: C271 in (the carrier of C268) and L465: C269 = [ C270 , C271 ] by L462 , ZFMISC_1:def 2;
reconsider D35 = (the carrier of C267) as non  empty set by L463;
reconsider D36 = (the ToleranceRel of C267) as (Relation of D35);
L466: D35 = ( field D36 ) by ORDERS_1:12;
L467: D36 is_reflexive_in D35 by L466 , RELAT_2:def 9;
L468: [ C270 , C270 ] in D36 by L467 , L463 , RELAT_2:def 1;
thus L469: thesis by L468 , L463 , L464 , L465 , L66;
end;
end;
registration
let C272 , C273 being  pcs-tol-symmetric TolStr;
cluster [^ C272 , C273 ^] ->  pcs-tol-symmetric;
coherence
proof
set D37 = [^ C272 , C273 ^];
set D38 = (the ToleranceRel of D37);
L471: D38 is_symmetric_in ( field D38 ) by RELAT_2:def 11;
let C274 , C275 being set;
assume that
L472: C274 in (the carrier of D37)
and
L473: C275 in (the carrier of D37);
assume L474: [ C274 , C275 ] in D38;
L475: C274 in ( field D38 ) by L474 , RELAT_1:15;
L476: C275 in ( field D38 ) by L474 , RELAT_1:15;
thus L477: thesis by L476 , L471 , L474 , L475 , RELAT_2:def 3;
end;
end;
begin
definition
struct (RelStr , TolStr) pcs-Str(# carrier -> set , InternalRel -> (Relation of the carrier) , ToleranceRel -> (Relation of the carrier) #);
end;
definition
let C276 being pcs-Str;
attr C276 is  pcs-compatible
means
:L480: (for B115 , B116 , B117 , B118 being (Element of C276) holds ((B115 (--) B117 & B116 <= B115 & B118 <= B117) implies B116 (--) B118));
end;
definition
let C277 being pcs-Str;
attr C277 is  pcs-like
means
:L482: C277 is  reflexive  transitive  pcs-tol-reflexive  pcs-tol-symmetric  pcs-compatible;
attr C277 is  anti-pcs-like
means
:L483: C277 is  reflexive  transitive  pcs-tol-irreflexive  pcs-tol-symmetric  pcs-compatible;
end;
registration
cluster  pcs-like ->  reflexive  transitive  pcs-tol-reflexive  pcs-tol-symmetric  pcs-compatible for pcs-Str;
coherence by L482;
cluster  reflexive  transitive  pcs-tol-reflexive  pcs-tol-symmetric  pcs-compatible ->  pcs-like for pcs-Str;
coherence by L482;
cluster  anti-pcs-like ->  reflexive  transitive  pcs-tol-irreflexive  pcs-tol-symmetric  pcs-compatible for pcs-Str;
coherence by L483;
cluster  reflexive  transitive  pcs-tol-irreflexive  pcs-tol-symmetric  pcs-compatible ->  anti-pcs-like for pcs-Str;
coherence by L483;
end;
definition
let C278 being set;
func pcs-total C278 -> pcs-Str equals 
pcs-Str (# C278 , ( nabla C278 ) , ( nabla C278 ) #);
coherence;
end;
registration
let C279 being set;
cluster ( pcs-total C279 ) ->  strict;
coherence;
end;
registration
let C280 being non  empty set;
cluster ( pcs-total C280 ) -> non  empty;
coherence;
end;
registration
let C281 being set;
cluster ( pcs-total C281 ) ->  reflexive  transitive  pcs-tol-reflexive  pcs-tol-symmetric;
coherence
proof
set D39 = ( pcs-total C281 );
set D40 = (the InternalRel of D39);
set D41 = (the ToleranceRel of D39);
L489: ( field D40 ) = (the carrier of D39) by ORDERS_1:12;
thus L490: D40 is_reflexive_in (the carrier of D39) by L489 , RELAT_2:def 9;
thus L491: D40 is_transitive_in (the carrier of D39) by L489 , RELAT_2:def 16;
thus L492: D41 is_reflexive_in (the carrier of D39) by L489 , RELAT_2:def 9;
thus L493: D41 is_symmetric_in (the carrier of D39) by L489 , RELAT_2:def 11;
end;
end;
registration
let C282 being set;
cluster ( pcs-total C282 ) ->  pcs-like;
coherence
proof
set D42 = ( pcs-total C282 );
thus L495: D42 is  reflexive  transitive;
thus L496: D42 is  pcs-tol-reflexive  pcs-tol-symmetric;
let C283 , C284 , C285 , C286 being (Element of D42);
assume that
L497: C283 (--) C285;
assume that
L498: C284 <= C283
and
L499: C286 <= C285;
L500: [ C284 , C283 ] in [: C282 , C282 :] by L498 , ORDERS_2:def 5;
L501: C284 in (the carrier of D42) by L500 , ZFMISC_1:87;
thus L502: [ C284 , C286 ] in (the ToleranceRel of D42) by L501 , ZFMISC_1:87;
end;
end;
registration
let C287 being set;
cluster pcs-Str (# C287 , ( nabla C287 ) , ( {} (C287 , C287) ) #) ->  anti-pcs-like;
coherence
proof
set D43 = pcs-Str (# C287 , ( nabla C287 ) , ( {} (C287 , C287) ) #);
L504: ( the RelStr of D43 ) = ( the RelStr of RelStr (# C287 , ( nabla C287 ) #) );
thus L505: D43 is  reflexive by L504 , WAYBEL_8:12;
thus L506: D43 is  transitive by L504 , WAYBEL_8:13;
L507: ( the TolStr of D43 ) = ( the TolStr of TolStr (# C287 , ( {} (C287 , C287) ) #) );
thus L508: D43 is  pcs-tol-irreflexive by L507 , L421;
thus L509: D43 is  pcs-tol-symmetric by L507 , L426;
let C288 being (Element of D43);
thus L510: thesis by L247;
end;
end;
registration
cluster  strict non  empty  pcs-like for pcs-Str;
existence
proof
take D44 = ( pcs-total { ( {} ) } );
thus L512: D44 is  strict;
thus L513: (the carrier of D44) is non  empty;
thus L514: thesis;
end;
cluster  strict non  empty  anti-pcs-like for pcs-Str;
existence
proof
take D45 = pcs-Str (# { ( {} ) } , ( nabla { ( {} ) } ) , ( {} ({ ( {} ) } , { ( {} ) }) ) #);
thus L515: D45 is  strict;
thus L516: (the carrier of D45) is non  empty;
thus L517: thesis;
end;
end;
definition
mode pcs
 is  pcs-like pcs-Str;
mode anti-pcs
 is  anti-pcs-like pcs-Str;
end;
definition
func pcs-empty -> pcs-Str equals 
( pcs-total ( 0 ) );
coherence;
end;
registration
cluster ( pcs-empty ) ->  strict  empty  pcs-like;
coherence;
end;
definition
let C289 being set;
func pcs-singleton C289 -> pcs-Str equals 
( pcs-total { C289 } );
coherence;
end;
registration
let C290 being set;
cluster ( pcs-singleton C290 ) ->  strict non  empty  pcs-like;
coherence;
end;
definition
let C291 being Relation;
attr C291 is  pcs-Str-yielding
means
:L524: (for B119 being set holds (B119 in ( rng C291 ) implies B119 is pcs-Str));
attr C291 is  pcs-yielding
means
:L525: (for B120 being set holds (B120 in ( rng C291 ) implies B120 is pcs));
end;
definition
let C292 being Function;
redefine attr C292 is  pcs-Str-yielding
means
:L527: (for B121 being set holds (B121 in ( dom C292 ) implies ( C292 . B121 ) is pcs-Str));
compatibility
proof
thus L528:now
assume L529: C292 is  pcs-Str-yielding;
let C293 being set;
assume L530: C293 in ( dom C292 );
L531: ( C292 . C293 ) in ( rng C292 ) by L530 , FUNCT_1:3;
thus L532: ( C292 . C293 ) is pcs-Str by L531 , L529 , L524;
end;
assume L533: (for B122 being set holds (B122 in ( dom C292 ) implies ( C292 . B122 ) is pcs-Str));
let C294 being set;
assume L534: C294 in ( rng C292 );
L535: (ex B123 being set st (B123 in ( dom C292 ) & ( C292 . B123 ) = C294)) by L534 , FUNCT_1:def 3;
thus L536: thesis by L535 , L533;
end;
redefine attr C292 is  pcs-yielding
means
:L537: (for B124 being set holds (B124 in ( dom C292 ) implies ( C292 . B124 ) is pcs));
compatibility
proof
thus L538:now
assume L539: C292 is  pcs-yielding;
let C295 being set;
assume L540: C295 in ( dom C292 );
L541: ( C292 . C295 ) in ( rng C292 ) by L540 , FUNCT_1:3;
thus L542: ( C292 . C295 ) is pcs by L541 , L539 , L525;
end;
assume L543: (for B125 being set holds (B125 in ( dom C292 ) implies ( C292 . B125 ) is pcs));
let C296 being set;
assume L544: C296 in ( rng C292 );
L545: (ex B126 being set st (B126 in ( dom C292 ) & ( C292 . B126 ) = C296)) by L544 , FUNCT_1:def 3;
thus L546: thesis by L545 , L543;
end;
end;
definition
let C297 being set;
let C298 being (ManySortedSet of C297);
L548: ( dom C298 ) = C297 by PARTFUN1:def 2;
redefine attr C298 is  pcs-Str-yielding
means
:L549: (for B127 being set holds (B127 in C297 implies ( C298 . B127 ) is pcs-Str));
compatibility by L548 , L527;
redefine attr C298 is  pcs-yielding
means
:L550: (for B128 being set holds (B128 in C297 implies ( C298 . B128 ) is pcs));
compatibility by L548 , L537;
end;
registration
cluster  pcs-Str-yielding ->  TolStr-yielding  RelStr-yielding for Relation;
coherence
proof
let C299 being Relation;
assume L552: C299 is  pcs-Str-yielding;
thus L553: C299 is  TolStr-yielding
proof
let C300 being set;
thus L554: thesis by L552 , L524;
end;

let C301 being set;
thus L555: thesis by L552 , L524;
end;
cluster  pcs-yielding ->  pcs-Str-yielding for Relation;
coherence
proof
let C302 being Relation;
assume L556: C302 is  pcs-yielding;
let C303 being set;
thus L557: thesis by L556 , L525;
end;
cluster  pcs-yielding ->  reflexive-yielding  transitive-yielding  pcs-tol-reflexive-yielding  pcs-tol-symmetric-yielding for Relation;
coherence
proof
let C304 being Relation;
assume L558: C304 is  pcs-yielding;
thus L559: C304 is  reflexive-yielding
proof
let C305 being RelStr;
thus L560: thesis by L558 , L525;
end;

thus L561: C304 is  transitive-yielding
proof
let C306 being RelStr;
thus L562: thesis by L558 , L525;
end;

thus L563: C304 is  pcs-tol-reflexive-yielding
proof
let C307 being TolStr;
thus L564: thesis by L558 , L525;
end;

let C308 being TolStr;
thus L565: thesis by L558 , L525;
end;
end;
registration
let C309 being set;
let C310 being pcs;
cluster ( C309 --> C310 ) ->  pcs-yielding for (ManySortedSet of C309);
coherence
proof
L567: ( C309 --> C310 ) is  pcs-yielding
proof
let C311 being set;
thus L568: thesis by FUNCOP_1:7;
end;
thus L569: thesis by L567;
end;
end;
registration
let C312 being set;
cluster  pcs-yielding for (ManySortedSet of C312);
existence
proof
take ( C312 --> ( pcs-empty ) );
thus L571: thesis;
end;
end;
definition
let C313 being non  empty set;
let C314 being  pcs-Str-yielding (ManySortedSet of C313);
let C315 being (Element of C313);
redefine func C314 . C315 -> pcs-Str;

coherence by L549;
end;
definition
let C316 being non  empty set;
let C317 being  pcs-yielding (ManySortedSet of C316);
let C318 being (Element of C316);
redefine func C317 . C318 -> pcs;

coherence by L550;
end;
definition
let C319 , C320 being pcs-Str;
pred C319 c= C320
means
:L575: ((the carrier of C319) c= (the carrier of C320) & (the InternalRel of C319) c= (the InternalRel of C320) & (the ToleranceRel of C319) c= (the ToleranceRel of C320))
;reflexivity
;
end;
theorem
L577: (for B129 , B130 being RelStr holds (for B131 , B132 being (Element of B129) holds (for B133 , B134 being (Element of B130) holds (((the InternalRel of B129) c= (the InternalRel of B130) & B131 = B133 & B132 = B134 & B131 <= B132) implies B133 <= B134))))
proof
let C321 , C322 being RelStr;
let C323 , C324 being (Element of C321);
let C325 , C326 being (Element of C322);
assume that
L578: (the InternalRel of C321) c= (the InternalRel of C322)
and
L579: C323 = C325
and
L580: C324 = C326
and
L581: [ C323 , C324 ] in (the InternalRel of C321);
thus L582: [ C325 , C326 ] in (the InternalRel of C322) by L578 , L579 , L580 , L581;
end;
theorem
L583: (for B135 , B136 being TolStr holds (for B137 , B138 being (Element of B135) holds (for B139 , B140 being (Element of B136) holds (((the ToleranceRel of B135) c= (the ToleranceRel of B136) & B137 = B139 & B138 = B140 & B137 (--) B138) implies B139 (--) B140))))
proof
let C327 , C328 being TolStr;
let C329 , C330 being (Element of C327);
let C331 , C332 being (Element of C328);
assume that
L584: (the ToleranceRel of C327) c= (the ToleranceRel of C328)
and
L585: C329 = C331
and
L586: C330 = C332
and
L587: [ C329 , C330 ] in (the ToleranceRel of C327);
thus L588: [ C331 , C332 ] in (the ToleranceRel of C328) by L584 , L585 , L586 , L587;
end;
L589: (for B141 , B142 being pcs-Str holds (for B143 being set holds ((B143 in (the carrier of B141) & B141 c= B142) implies B143 is (Element of B142))))
proof
let C333 , C334 being pcs-Str;
let C335 being set;
assume that
L590: C335 in (the carrier of C333);
assume L591: C333 c= C334;
L592: (the carrier of C333) c= (the carrier of C334) by L591 , L575;
thus L593: thesis by L592 , L590;
end;
definition
let C336 being Relation;
attr C336 is  pcs-chain-like
means
:L594: (for B144 , B145 being pcs-Str holds ((B144 in ( rng C336 ) & B145 in ( rng C336 )) implies (B144 c= B145 or B145 c= B144)));
end;
registration
let C337 being set;
let C338 being pcs-Str;
cluster ( C337 --> C338 ) ->  pcs-chain-like for (ManySortedSet of C337);
coherence
proof
set D46 = ( C337 --> C338 );
L596: D46 is  pcs-chain-like
proof
let C339 , C340 being pcs-Str;
assume that
L597: C339 in ( rng D46 )
and
L598: C340 in ( rng D46 );
L599: ((C338 = C339 & C338 = C340) or ( rng D46 ) = ( {} )) by L597 , L598 , TARSKI:def 1;
thus L600: thesis by L599 , L597;
end;
thus L601: thesis by L596;
end;
end;
registration
cluster  pcs-chain-like  pcs-yielding for Function;
existence
proof
set D47 = the pcs;
take ( ( 0 ) --> D47 );
thus L603: thesis;
end;
end;
registration
let C341 being set;
cluster  pcs-chain-like  pcs-yielding for (ManySortedSet of C341);
existence
proof
set D48 = the pcs;
take ( C341 --> D48 );
thus L605: thesis;
end;
end;
definition
let C342 being set;
mode pcs-Chain of C342
 is  pcs-chain-like  pcs-yielding (ManySortedSet of C342);
end;
definition
let C343 being set;
let C344 being  pcs-Str-yielding (ManySortedSet of C343);
func pcs-union C344 ->  strict pcs-Str means 
:L608: ((the carrier of it) = ( Union ( Carrier C344 ) ) & (the InternalRel of it) = ( Union ( pcs-InternalRels C344 ) ) & (the ToleranceRel of it) = ( Union ( pcs-ToleranceRels C344 ) ));
existence
proof
set D49 = ( Carrier C344 );
set D50 = ( pcs-InternalRels C344 );
set D51 = ( pcs-ToleranceRels C344 );
set D52 = ( Union D49 );
set D53 = ( Union D50 );
set D54 = ( Union D51 );
L609: ( dom D49 ) = C343 by PARTFUN1:def 2;
L610: D53 c= [: D52 , D52 :]
proof
let C345 being set;
assume L611: C345 in D53;
consider C346 being set such that L612: C345 in C346 and L613: C346 in ( rng D50 ) by L611 , TARSKI:def 4;
consider C347 being set such that L614: C347 in ( dom D50 ) and L615: ( D50 . C347 ) = C346 by L613 , FUNCT_1:def 3;
consider C348 being RelStr such that L616: C348 = ( C344 . C347 ) and L617: ( D50 . C347 ) = (the InternalRel of C348) by L614 , L210;
consider C349 , C350 being set such that L618: C345 = [ C349 , C350 ] and L619: C349 in (the carrier of C348) and L620: C350 in (the carrier of C348) by L612 , L615 , L617 , RELSET_1:2;
L621: (ex B146 being 1-sorted st (B146 = ( C344 . C347 ) & ( D49 . C347 ) = (the carrier of B146))) by L614 , PRALG_1:def 13;
L622: (the carrier of C348) in ( rng D49 ) by L621 , L609 , L614 , L616 , FUNCT_1:def 3;
L623: C349 in ( union ( rng D49 ) ) by L622 , L619 , TARSKI:def 4;
L624: C350 in ( union ( rng D49 ) ) by L620 , L622 , TARSKI:def 4;
thus L625: thesis by L624 , L618 , L623 , ZFMISC_1:87;
end;
reconsider D55 = D53 as (Relation of D52) by L610;
L626: D54 c= [: D52 , D52 :]
proof
let C351 being set;
assume L627: C351 in D54;
consider C352 being set such that L628: C351 in C352 and L629: C352 in ( rng D51 ) by L627 , TARSKI:def 4;
consider C353 being set such that L630: C353 in ( dom D51 ) and L631: ( D51 . C353 ) = C352 by L629 , FUNCT_1:def 3;
consider C354 being TolStr such that L632: C354 = ( C344 . C353 ) and L633: ( D51 . C353 ) = (the ToleranceRel of C354) by L630 , L372;
consider C355 , C356 being set such that L634: C351 = [ C355 , C356 ] and L635: C355 in (the carrier of C354) and L636: C356 in (the carrier of C354) by L628 , L631 , L633 , RELSET_1:2;
L637: (ex B147 being 1-sorted st (B147 = ( C344 . C353 ) & ( D49 . C353 ) = (the carrier of B147))) by L630 , PRALG_1:def 13;
L638: (the carrier of C354) in ( rng D49 ) by L637 , L609 , L630 , L632 , FUNCT_1:def 3;
L639: C355 in ( union ( rng D49 ) ) by L638 , L635 , TARSKI:def 4;
L640: C356 in ( union ( rng D49 ) ) by L636 , L638 , TARSKI:def 4;
thus L641: thesis by L640 , L634 , L639 , ZFMISC_1:87;
end;
reconsider D56 = D54 as (Relation of D52) by L626;
take pcs-Str (# D52 , D55 , D56 #);
thus L642: thesis;
end;
uniqueness;
end;
theorem
L644: (for B148 being set holds (for B149 being  pcs-Str-yielding (ManySortedSet of B148) holds (for B150 , B151 being (Element of ( pcs-union B149 )) holds (B150 <= B151 iff (ex B152 being set st (ex B153 being pcs-Str st (ex B154 , B155 being (Element of B153) st (B152 in B148 & B153 = ( B149 . B152 ) & B154 = B150 & B155 = B151 & B154 <= B155))))))))
proof
let C357 being set;
let C358 being  pcs-Str-yielding (ManySortedSet of C357);
set D57 = ( pcs-union C358 );
let C359 , C360 being (Element of D57);
L645: ( dom ( pcs-InternalRels C358 ) ) = C357 by PARTFUN1:def 2;
thus L646: (C359 <= C360 implies (ex B156 being set st (ex B157 being pcs-Str st (ex B158 , B159 being (Element of B157) st (B156 in C357 & B157 = ( C358 . B156 ) & B158 = C359 & B159 = C360 & B158 <= B159)))))
proof
assume L647: C359 <= C360;
L648: [ C359 , C360 ] in (the InternalRel of D57) by L647 , ORDERS_2:def 5;
L649: [ C359 , C360 ] in ( Union ( pcs-InternalRels C358 ) ) by L648 , L608;
consider C361 being set such that L650: [ C359 , C360 ] in C361 and L651: C361 in ( rng ( pcs-InternalRels C358 ) ) by L649 , TARSKI:def 4;
consider C362 being set such that L652: C362 in ( dom ( pcs-InternalRels C358 ) ) and L653: ( ( pcs-InternalRels C358 ) . C362 ) = C361 by L651 , FUNCT_1:def 3;
reconsider D58 = C357 as non  empty set by L652;
reconsider D59 = C358 as  pcs-Str-yielding (ManySortedSet of D58);
reconsider D60 = C362 as (Element of D58) by L652;
reconsider D61 = ( D59 . D60 ) as pcs-Str;
take C362;
take D61;
L654: C361 = (the InternalRel of ( D59 . D60 )) by L653 , L227;
reconsider D62 = C359 , D63 = C360 as (Element of D61) by L654 , L650 , ZFMISC_1:87;
take D62;
take D63;
thus L655: C362 in C357 by L652;
thus L656: (D61 = ( C358 . C362 ) & D62 = C359 & D63 = C360);
thus L657: [ D62 , D63 ] in (the InternalRel of D61) by L650 , L653 , L227;
end;

given C363 being set , C364 being pcs-Str , C365 , C366 being (Element of C364) such that
L658: C363 in C357
and
L659: C364 = ( C358 . C363 )
and
L660: C365 = C359
and
L661: C366 = C360
and
L662: C365 <= C366;

L663: [ C365 , C366 ] in (the InternalRel of C364) by L662 , ORDERS_2:def 5;
reconsider D64 = C357 as non  empty set by L658;
reconsider D65 = C363 as (Element of D64) by L658;
reconsider D66 = C358 as  pcs-Str-yielding (ManySortedSet of D64);
L664: ( ( pcs-InternalRels D66 ) . D65 ) = (the InternalRel of ( D66 . D65 )) by L227;
L665: (the InternalRel of ( D66 . D65 )) in ( rng ( pcs-InternalRels C358 ) ) by L664 , L645 , FUNCT_1:3;
L666: [ C359 , C360 ] in ( Union ( pcs-InternalRels C358 ) ) by L665 , L659 , L660 , L661 , L663 , TARSKI:def 4;
thus L667: [ C359 , C360 ] in (the InternalRel of D57) by L666 , L608;
end;
theorem
L668: (for B160 being non  empty set holds (for B161 being  pcs-Str-yielding (ManySortedSet of B160) holds (for B162 , B163 being (Element of ( pcs-union B161 )) holds (B162 <= B163 iff (ex B164 being (Element of B160) st (ex B165 , B166 being (Element of ( B161 . B164 )) st (B165 = B162 & B166 = B163 & B165 <= B166)))))))
proof
let C367 being non  empty set;
let C368 being  pcs-Str-yielding (ManySortedSet of C367);
let C369 , C370 being (Element of ( pcs-union C368 ));
thus L669: (C369 <= C370 implies (ex B167 being (Element of C367) st (ex B168 , B169 being (Element of ( C368 . B167 )) st (B168 = C369 & B169 = C370 & B168 <= B169))))
proof
assume L670: C369 <= C370;
L671: (ex B170 being set st (ex B171 being pcs-Str st (ex B172 , B173 being (Element of B171) st (B170 in C367 & B171 = ( C368 . B170 ) & B172 = C369 & B173 = C370 & B172 <= B173)))) by L670 , L644;
thus L672: thesis by L671;
end;

thus L673: thesis by L644;
end;
theorem
L674: (for B174 being set holds (for B175 being  pcs-Str-yielding (ManySortedSet of B174) holds (for B176 , B177 being (Element of ( pcs-union B175 )) holds (B176 (--) B177 iff (ex B178 being set st (ex B179 being pcs-Str st (ex B180 , B181 being (Element of B179) st (B178 in B174 & B179 = ( B175 . B178 ) & B180 = B176 & B181 = B177 & B180 (--) B181))))))))
proof
let C371 being set;
let C372 being  pcs-Str-yielding (ManySortedSet of C371);
set D67 = ( pcs-union C372 );
let C373 , C374 being (Element of D67);
L675: ( dom ( pcs-ToleranceRels C372 ) ) = C371 by PARTFUN1:def 2;
thus L676: (C373 (--) C374 implies (ex B182 being set st (ex B183 being pcs-Str st (ex B184 , B185 being (Element of B183) st (B182 in C371 & B183 = ( C372 . B182 ) & B184 = C373 & B185 = C374 & B184 (--) B185)))))
proof
assume L677: C373 (--) C374;
L678: [ C373 , C374 ] in (the ToleranceRel of D67) by L677 , L247;
L679: [ C373 , C374 ] in ( Union ( pcs-ToleranceRels C372 ) ) by L678 , L608;
consider C375 being set such that L680: [ C373 , C374 ] in C375 and L681: C375 in ( rng ( pcs-ToleranceRels C372 ) ) by L679 , TARSKI:def 4;
consider C376 being set such that L682: C376 in ( dom ( pcs-ToleranceRels C372 ) ) and L683: ( ( pcs-ToleranceRels C372 ) . C376 ) = C375 by L681 , FUNCT_1:def 3;
reconsider D68 = C371 as non  empty set by L682;
reconsider D69 = C372 as  pcs-Str-yielding (ManySortedSet of D68);
reconsider D70 = C376 as (Element of D68) by L682;
reconsider D71 = ( D69 . D70 ) as pcs-Str;
take C376;
take D71;
L684: C375 = (the ToleranceRel of ( D69 . D70 )) by L683 , L389;
reconsider D72 = C373 , D73 = C374 as (Element of D71) by L684 , L680 , ZFMISC_1:87;
take D72;
take D73;
thus L685: C376 in C371 by L682;
thus L686: (D71 = ( C372 . C376 ) & D72 = C373 & D73 = C374);
thus L687: [ D72 , D73 ] in (the ToleranceRel of D71) by L680 , L683 , L389;
end;

given C377 being set , C378 being pcs-Str , C379 , C380 being (Element of C378) such that
L688: C377 in C371
and
L689: C378 = ( C372 . C377 )
and
L690: C379 = C373
and
L691: C380 = C374
and
L692: C379 (--) C380;

L693: [ C379 , C380 ] in (the ToleranceRel of C378) by L692 , L247;
reconsider D74 = C371 as non  empty set by L688;
reconsider D75 = C377 as (Element of D74) by L688;
reconsider D76 = C372 as  pcs-Str-yielding (ManySortedSet of D74);
L694: ( ( pcs-ToleranceRels D76 ) . D75 ) = (the ToleranceRel of ( D76 . D75 )) by L389;
L695: (the ToleranceRel of ( D76 . D75 )) in ( rng ( pcs-ToleranceRels C372 ) ) by L694 , L675 , FUNCT_1:3;
L696: [ C373 , C374 ] in ( Union ( pcs-ToleranceRels C372 ) ) by L695 , L689 , L690 , L691 , L693 , TARSKI:def 4;
thus L697: [ C373 , C374 ] in (the ToleranceRel of D67) by L696 , L608;
end;
theorem
L698: (for B186 being non  empty set holds (for B187 being  pcs-Str-yielding (ManySortedSet of B186) holds (for B188 , B189 being (Element of ( pcs-union B187 )) holds (B188 (--) B189 iff (ex B190 being (Element of B186) st (ex B191 , B192 being (Element of ( B187 . B190 )) st (B191 = B188 & B192 = B189 & B191 (--) B192)))))))
proof
let C381 being non  empty set;
let C382 being  pcs-Str-yielding (ManySortedSet of C381);
let C383 , C384 being (Element of ( pcs-union C382 ));
thus L699: (C383 (--) C384 implies (ex B193 being (Element of C381) st (ex B194 , B195 being (Element of ( C382 . B193 )) st (B194 = C383 & B195 = C384 & B194 (--) B195))))
proof
assume L700: C383 (--) C384;
L701: (ex B196 being set st (ex B197 being pcs-Str st (ex B198 , B199 being (Element of B197) st (B196 in C381 & B197 = ( C382 . B196 ) & B198 = C383 & B199 = C384 & B198 (--) B199)))) by L700 , L674;
thus L702: thesis by L701;
end;

thus L703: thesis by L674;
end;
registration
let C385 being set;
let C386 being  reflexive-yielding  pcs-Str-yielding (ManySortedSet of C385);
cluster ( pcs-union C386 ) ->  reflexive;
coherence
proof
set D77 = ( pcs-union C386 );
set D78 = (the InternalRel of D77);
set D79 = (the carrier of D77);
set D80 = ( Carrier C386 );
L704: D79 = ( Union D80 ) by L608;
L705: D78 = ( Union ( pcs-InternalRels C386 ) ) by L608;
L706: ( dom ( pcs-InternalRels C386 ) ) = C385 by PARTFUN1:def 2;
let C387 being set;
assume L707: C387 in D79;
consider C388 being set such that L708: C387 in C388 and L709: C388 in ( rng D80 ) by L707 , L704 , TARSKI:def 4;
consider C389 being set such that L710: C389 in ( dom D80 ) and L711: ( D80 . C389 ) = C388 by L709 , FUNCT_1:def 3;
L712: (ex B200 being 1-sorted st (B200 = ( C386 . C389 ) & ( D80 . C389 ) = (the carrier of B200))) by L710 , PRALG_1:def 13;
reconsider D81 = C385 as non  empty set by L710;
reconsider D82 = C389 as (Element of D81) by L710;
reconsider D83 = C386 as  reflexive-yielding  pcs-Str-yielding (ManySortedSet of D81);
L713: ( ( pcs-InternalRels D83 ) . D82 ) = (the InternalRel of ( D83 . D82 )) by L227;
L714: (the InternalRel of ( D83 . D82 )) is_reflexive_in (the carrier of ( D83 . D82 )) by ORDERS_2:def 2;
L715: [ C387 , C387 ] in (the InternalRel of ( D83 . D82 )) by L714 , L708 , L711 , L712 , RELAT_2:def 1;
L716: (the InternalRel of ( D83 . D82 )) in ( rng ( pcs-InternalRels D83 ) ) by L706 , L713 , FUNCT_1:3;
thus L717: thesis by L716 , L705 , L715 , TARSKI:def 4;
end;
end;
registration
let C390 being set;
let C391 being  pcs-tol-reflexive-yielding  pcs-Str-yielding (ManySortedSet of C390);
cluster ( pcs-union C391 ) ->  pcs-tol-reflexive;
coherence
proof
set D84 = ( pcs-union C391 );
set D85 = (the ToleranceRel of D84);
set D86 = (the carrier of D84);
set D87 = ( Carrier C391 );
L719: D86 = ( Union D87 ) by L608;
L720: D85 = ( Union ( pcs-ToleranceRels C391 ) ) by L608;
L721: ( dom ( pcs-ToleranceRels C391 ) ) = C390 by PARTFUN1:def 2;
let C392 being set;
assume L722: C392 in D86;
consider C393 being set such that L723: C392 in C393 and L724: C393 in ( rng D87 ) by L722 , L719 , TARSKI:def 4;
consider C394 being set such that L725: C394 in ( dom D87 ) and L726: ( D87 . C394 ) = C393 by L724 , FUNCT_1:def 3;
L727: (ex B201 being 1-sorted st (B201 = ( C391 . C394 ) & ( D87 . C394 ) = (the carrier of B201))) by L725 , PRALG_1:def 13;
reconsider D88 = C390 as non  empty set by L725;
reconsider D89 = C394 as (Element of D88) by L725;
reconsider D90 = C391 as  pcs-tol-reflexive-yielding  pcs-Str-yielding (ManySortedSet of D88);
L728: ( ( pcs-ToleranceRels D90 ) . D89 ) = (the ToleranceRel of ( D90 . D89 )) by L389;
L729: (the ToleranceRel of ( D90 . D89 )) is_reflexive_in (the carrier of ( D90 . D89 )) by L250;
L730: [ C392 , C392 ] in (the ToleranceRel of ( D90 . D89 )) by L729 , L723 , L726 , L727 , RELAT_2:def 1;
L731: (the ToleranceRel of ( D90 . D89 )) in ( rng ( pcs-ToleranceRels D90 ) ) by L721 , L728 , FUNCT_1:3;
thus L732: thesis by L731 , L720 , L730 , TARSKI:def 4;
end;
end;
registration
let C395 being set;
let C396 being  pcs-tol-symmetric-yielding  pcs-Str-yielding (ManySortedSet of C395);
cluster ( pcs-union C396 ) ->  pcs-tol-symmetric;
coherence
proof
set D91 = ( pcs-union C396 );
set D92 = (the ToleranceRel of D91);
set D93 = (the carrier of D91);
L734: D92 = ( Union ( pcs-ToleranceRels C396 ) ) by L608;
let C397 , C398 being set;
assume that
L735: C397 in D93
and
L736: C398 in D93;
assume L737: [ C397 , C398 ] in D92;
consider C399 being set such that L738: [ C397 , C398 ] in C399 and L739: C399 in ( rng ( pcs-ToleranceRels C396 ) ) by L737 , L734 , TARSKI:def 4;
consider C400 being set such that L740: C400 in ( dom ( pcs-ToleranceRels C396 ) ) and L741: ( ( pcs-ToleranceRels C396 ) . C400 ) = C399 by L739 , FUNCT_1:def 3;
reconsider D94 = C395 as non  empty set by L740;
reconsider D95 = C396 as  pcs-tol-symmetric-yielding  pcs-Str-yielding (ManySortedSet of D94);
reconsider D96 = C400 as (Element of D94) by L740;
L742: ( ( pcs-ToleranceRels D95 ) . D96 ) = (the ToleranceRel of ( D95 . D96 )) by L389;
L743: C397 in (the carrier of ( D95 . D96 )) by L742 , L738 , L741 , ZFMISC_1:87;
L744: C398 in (the carrier of ( D95 . D96 )) by L738 , L741 , L742 , ZFMISC_1:87;
L745: (the ToleranceRel of ( D95 . D96 )) is_symmetric_in (the carrier of ( D95 . D96 )) by L252;
L746: [ C398 , C397 ] in (the ToleranceRel of ( D95 . D96 )) by L745 , L738 , L741 , L742 , L743 , L744 , RELAT_2:def 3;
L747: (the ToleranceRel of ( D95 . D96 )) in ( rng ( pcs-ToleranceRels D95 ) ) by L740 , L742 , FUNCT_1:3;
thus L748: thesis by L747 , L734 , L746 , TARSKI:def 4;
end;
end;
registration
let C401 being set;
let C402 being (pcs-Chain of C401);
cluster ( pcs-union C402 ) ->  transitive  pcs-compatible;
coherence
proof
set D97 = ( pcs-union C402 );
set D98 = (the InternalRel of D97);
set D99 = (the ToleranceRel of D97);
set D100 = (the carrier of D97);
L750: D98 = ( Union ( pcs-InternalRels C402 ) ) by L608;
L751: D99 = ( Union ( pcs-ToleranceRels C402 ) ) by L608;
L752: ( dom C402 ) = C401 by PARTFUN1:def 2;
thus L753: D97 is  transitive
proof
let C403 , C404 , C405 being set;
assume that
L754: C403 in D100
and
L755: C404 in D100
and
L756: C405 in D100;
assume L757: [ C403 , C404 ] in D98;
consider C406 being set such that L758: [ C403 , C404 ] in C406 and L759: C406 in ( rng ( pcs-InternalRels C402 ) ) by L757 , L750 , TARSKI:def 4;
consider C407 being set such that L760: C407 in ( dom ( pcs-InternalRels C402 ) ) and L761: ( ( pcs-InternalRels C402 ) . C407 ) = C406 by L759 , FUNCT_1:def 3;
assume L762: [ C404 , C405 ] in D98;
consider C408 being set such that L763: [ C404 , C405 ] in C408 and L764: C408 in ( rng ( pcs-InternalRels C402 ) ) by L762 , L750 , TARSKI:def 4;
consider C409 being set such that L765: C409 in ( dom ( pcs-InternalRels C402 ) ) and L766: ( ( pcs-InternalRels C402 ) . C409 ) = C408 by L764 , FUNCT_1:def 3;
reconsider D101 = C401 as non  empty set by L760;
reconsider D102 = C402 as (pcs-Chain of D101);
reconsider D103 = C407 , D104 = C409 as (Element of D101) by L760 , L765;
L767: ( ( pcs-InternalRels D102 ) . D103 ) = (the InternalRel of ( D102 . D103 )) by L227;
L768: C403 in (the carrier of ( D102 . D103 )) by L767 , L758 , L761 , ZFMISC_1:87;
L769: C404 in (the carrier of ( D102 . D103 )) by L758 , L761 , L767 , ZFMISC_1:87;
L770: ( ( pcs-InternalRels D102 ) . D104 ) = (the InternalRel of ( D102 . D104 )) by L227;
L771: ( D102 . D103 ) in ( rng D102 ) by L752 , FUNCT_1:3;
L772: ( D102 . D104 ) in ( rng D102 ) by L752 , FUNCT_1:3;
L773: (the InternalRel of ( D102 . D103 )) is_transitive_in (the carrier of ( D102 . D103 )) by ORDERS_2:def 3;
L774: (the InternalRel of ( D102 . D104 )) is_transitive_in (the carrier of ( D102 . D104 )) by ORDERS_2:def 3;
per cases  by L771 , L772 , L594;
suppose L775: ( D102 . D103 ) c= ( D102 . D104 );

L776: (the InternalRel of ( D102 . D103 )) c= (the InternalRel of ( D102 . D104 )) by L775 , L575;
L777: [ C403 , C404 ] in (the InternalRel of ( D102 . D104 )) by L776 , L758 , L761 , L767;
L778: C403 in (the carrier of ( D102 . D104 )) by L777 , ZFMISC_1:87;
L779: C404 in (the carrier of ( D102 . D104 )) by L777 , ZFMISC_1:87;
L780: C405 in (the carrier of ( D102 . D104 )) by L763 , L766 , L770 , ZFMISC_1:87;
L781: [ C403 , C405 ] in (the InternalRel of ( D102 . D104 )) by L780 , L758 , L761 , L763 , L766 , L767 , L770 , L774 , L776 , L778 , L779 , RELAT_2:def 8;
L782: (the InternalRel of ( D102 . D104 )) c= D98 by L750 , L764 , L766 , L770 , ZFMISC_1:74;
thus L783: thesis by L782 , L781;
end;
suppose L784: ( D102 . D104 ) c= ( D102 . D103 );

L785: (the InternalRel of ( D102 . D104 )) c= (the InternalRel of ( D102 . D103 )) by L784 , L575;
L786: [ C404 , C405 ] in (the InternalRel of ( D102 . D103 )) by L785 , L763 , L766 , L770;
L787: C405 in (the carrier of ( D102 . D103 )) by L786 , ZFMISC_1:87;
L788: [ C403 , C405 ] in (the InternalRel of ( D102 . D103 )) by L787 , L758 , L761 , L763 , L766 , L767 , L768 , L769 , L770 , L773 , L785 , RELAT_2:def 8;
L789: (the InternalRel of ( D102 . D103 )) c= D98 by L750 , L759 , L761 , L767 , ZFMISC_1:74;
thus L790: thesis by L789 , L788;
end;
end;

let C410 , C411 , C412 , C413 being (Element of D97);
assume that
L792: C410 (--) C412
and
L793: C411 <= C410
and
L794: C413 <= C412;
L795: [ C411 , C410 ] in D98 by L793 , ORDERS_2:def 5;
consider C414 being set such that L796: [ C411 , C410 ] in C414 and L797: C414 in ( rng ( pcs-InternalRels C402 ) ) by L795 , L750 , TARSKI:def 4;
consider C415 being set such that L798: C415 in ( dom ( pcs-InternalRels C402 ) ) and L799: ( ( pcs-InternalRels C402 ) . C415 ) = C414 by L797 , FUNCT_1:def 3;
reconsider D105 = C401 as non  empty set by L798;
reconsider D106 = C402 as (pcs-Chain of D105);
reconsider D107 = C415 as (Element of D105) by L798;
L800: ( ( pcs-ToleranceRels D106 ) . D107 ) = (the ToleranceRel of ( D106 . D107 )) by L389;
L801: ( ( pcs-InternalRels D106 ) . D107 ) = (the InternalRel of ( D106 . D107 )) by L227;
reconsider D108 = C410 , D109 = C411 as (Element of ( D106 . D107 )) by L801 , L796 , L799 , ZFMISC_1:87;
L802: [ C413 , C412 ] in D98 by L794 , ORDERS_2:def 5;
consider C416 being set such that L803: [ C413 , C412 ] in C416 and L804: C416 in ( rng ( pcs-InternalRels D106 ) ) by L802 , L750 , TARSKI:def 4;
consider C417 being set such that L805: C417 in ( dom ( pcs-InternalRels D106 ) ) and L806: ( ( pcs-InternalRels D106 ) . C417 ) = C416 by L804 , FUNCT_1:def 3;
reconsider D110 = C417 as (Element of D105) by L805;
L807: ( ( pcs-ToleranceRels D106 ) . D110 ) = (the ToleranceRel of ( D106 . D110 )) by L389;
L808: ( ( pcs-InternalRels D106 ) . D110 ) = (the InternalRel of ( D106 . D110 )) by L227;
L809: C413 in (the carrier of ( D106 . D110 )) by L808 , L803 , L806 , ZFMISC_1:87;
L810: C412 in (the carrier of ( D106 . D110 )) by L803 , L806 , L808 , ZFMISC_1:87;
reconsider D111 = C412 as (Element of ( D106 . D110 )) by L803 , L806 , L808 , ZFMISC_1:87;
L811: [ C410 , C412 ] in D99 by L792 , L247;
consider C418 being set such that L812: [ C410 , C412 ] in C418 and L813: C418 in ( rng ( pcs-ToleranceRels D106 ) ) by L811 , L751 , TARSKI:def 4;
consider C419 being set such that L814: C419 in ( dom ( pcs-ToleranceRels D106 ) ) and L815: ( ( pcs-ToleranceRels D106 ) . C419 ) = C418 by L813 , FUNCT_1:def 3;
reconsider D112 = C419 as (Element of D105) by L814;
L816: ( ( pcs-ToleranceRels D106 ) . D112 ) = (the ToleranceRel of ( D106 . D112 )) by L389;
reconsider D113 = C410 , D114 = C412 as (Element of ( D106 . D112 )) by L816 , L812 , L815 , ZFMISC_1:87;
L817: ( D106 . D107 ) in ( rng D106 ) by L752 , FUNCT_1:3;
L818: ( D106 . D110 ) in ( rng D106 ) by L752 , FUNCT_1:3;
L819: ( D106 . D112 ) in ( rng D106 ) by L752 , FUNCT_1:3;
L820: ( dom ( pcs-ToleranceRels D106 ) ) = D105 by PARTFUN1:def 2;
L821: (the ToleranceRel of ( D106 . D107 )) c= D99 by L820 , L751 , L800 , FUNCT_1:3 , ZFMISC_1:74;
L822: (the ToleranceRel of ( D106 . D110 )) c= D99 by L751 , L807 , L820 , FUNCT_1:3 , ZFMISC_1:74;
L823: (the ToleranceRel of ( D106 . D112 )) c= D99 by L751 , L813 , L815 , L816 , ZFMISC_1:74;
per cases  by L817 , L818 , L819 , L594;
suppose that L824: ( D106 . D107 ) c= ( D106 . D110 )
and
L825: ( D106 . D110 ) c= ( D106 . D112 );
L826: (the InternalRel of ( D106 . D110 )) c= (the InternalRel of ( D106 . D112 )) by L825 , L575;
L827: (the InternalRel of ( D106 . D107 )) c= (the InternalRel of ( D106 . D110 )) by L824 , L575;
L828: [ C411 , C410 ] in (the InternalRel of ( D106 . D110 )) by L827 , L796 , L799 , L801;
L829: [ C411 , C410 ] in (the InternalRel of ( D106 . D112 )) by L828 , L826;
reconsider D115 = C411 as (Element of ( D106 . D112 )) by L829 , ZFMISC_1:87;
L830: [ C413 , C412 ] in (the InternalRel of ( D106 . D112 )) by L803 , L806 , L808 , L826;
reconsider D116 = C413 as (Element of ( D106 . D112 )) by L830 , ZFMISC_1:87;
L831: D115 <= D113 by L826 , L828 , ORDERS_2:def 5;
L832: D116 <= D114 by L803 , L806 , L808 , L826 , ORDERS_2:def 5;
L833: D113 (--) D114 by L812 , L815 , L816 , L247;
L834: D115 (--) D116 by L833 , L831 , L832 , L480;
L835: [ D115 , D116 ] in (the ToleranceRel of ( D106 . D112 )) by L834 , L247;
thus L836: [ C411 , C413 ] in D99 by L835 , L823;
end;
suppose that L837: ( D106 . D110 ) c= ( D106 . D107 )
and
L838: ( D106 . D107 ) c= ( D106 . D112 );
L839: (the InternalRel of ( D106 . D107 )) c= (the InternalRel of ( D106 . D112 )) by L838 , L575;
L840: (the InternalRel of ( D106 . D110 )) c= (the InternalRel of ( D106 . D107 )) by L837 , L575;
L841: [ C411 , C410 ] in (the InternalRel of ( D106 . D112 )) by L796 , L799 , L801 , L839;
reconsider D117 = C411 as (Element of ( D106 . D112 )) by L841 , ZFMISC_1:87;
L842: [ C413 , C412 ] in (the InternalRel of ( D106 . D107 )) by L803 , L806 , L808 , L840;
L843: [ C413 , C412 ] in (the InternalRel of ( D106 . D112 )) by L842 , L839;
reconsider D118 = C413 as (Element of ( D106 . D112 )) by L843 , ZFMISC_1:87;
L844: D117 <= D113 by L796 , L799 , L801 , L839 , ORDERS_2:def 5;
L845: D118 <= D114 by L839 , L842 , ORDERS_2:def 5;
L846: D113 (--) D114 by L812 , L815 , L816 , L247;
L847: D117 (--) D118 by L846 , L844 , L845 , L480;
L848: [ D117 , D118 ] in (the ToleranceRel of ( D106 . D112 )) by L847 , L247;
thus L849: [ C411 , C413 ] in D99 by L848 , L823;
end;
suppose that L850: ( D106 . D107 ) c= ( D106 . D112 )
and
L851: ( D106 . D112 ) c= ( D106 . D110 );
L852: (the InternalRel of ( D106 . D112 )) c= (the InternalRel of ( D106 . D110 )) by L851 , L575;
L853: (the ToleranceRel of ( D106 . D112 )) c= (the ToleranceRel of ( D106 . D110 )) by L851 , L575;
L854: (the InternalRel of ( D106 . D107 )) c= (the InternalRel of ( D106 . D112 )) by L850 , L575;
L855: [ C411 , C410 ] in (the InternalRel of ( D106 . D112 )) by L854 , L796 , L799 , L801;
L856: [ C411 , C410 ] in (the InternalRel of ( D106 . D110 )) by L855 , L852;
reconsider D119 = C411 as (Element of ( D106 . D110 )) by L856 , ZFMISC_1:87;
reconsider D120 = C413 as (Element of ( D106 . D110 )) by L803 , L806 , L808 , ZFMISC_1:87;
reconsider D121 = C410 as (Element of ( D106 . D110 )) by L856 , ZFMISC_1:87;
L857: D119 <= D121 by L852 , L855 , ORDERS_2:def 5;
L858: D120 <= D111 by L803 , L806 , L808 , ORDERS_2:def 5;
L859: D121 (--) D111 by L812 , L815 , L816 , L853 , L247;
L860: D119 (--) D120 by L859 , L857 , L858 , L480;
L861: [ D119 , D120 ] in (the ToleranceRel of ( D106 . D110 )) by L860 , L247;
thus L862: [ C411 , C413 ] in D99 by L861 , L822;
end;
suppose that L863: ( D106 . D112 ) c= ( D106 . D107 )
and
L864: ( D106 . D107 ) c= ( D106 . D110 );
L865: (the InternalRel of ( D106 . D107 )) c= (the InternalRel of ( D106 . D110 )) by L864 , L575;
L866: (the ToleranceRel of ( D106 . D107 )) c= (the ToleranceRel of ( D106 . D110 )) by L864 , L575;
L867: (the ToleranceRel of ( D106 . D112 )) c= (the ToleranceRel of ( D106 . D107 )) by L863 , L575;
L868: [ C411 , C410 ] in (the InternalRel of ( D106 . D110 )) by L796 , L799 , L801 , L865;
reconsider D122 = C411 as (Element of ( D106 . D110 )) by L868 , ZFMISC_1:87;
reconsider D123 = C413 as (Element of ( D106 . D110 )) by L803 , L806 , L808 , ZFMISC_1:87;
reconsider D124 = C410 as (Element of ( D106 . D110 )) by L868 , ZFMISC_1:87;
L869: C412 in (the carrier of ( D106 . D112 )) by L812 , L815 , L816 , ZFMISC_1:87;
reconsider D125 = C412 as (Element of ( D106 . D107 )) by L869 , L863 , L589;
L870: D122 <= D124 by L796 , L799 , L801 , L865 , ORDERS_2:def 5;
L871: D123 <= D111 by L803 , L806 , L808 , ORDERS_2:def 5;
L872: D108 (--) D125 by L812 , L815 , L816 , L867 , L247;
L873: D124 (--) D111 by L872 , L866 , L583;
L874: D122 (--) D123 by L873 , L870 , L871 , L480;
L875: [ D122 , D123 ] in (the ToleranceRel of ( D106 . D110 )) by L874 , L247;
thus L876: [ C411 , C413 ] in D99 by L875 , L822;
end;
suppose that L877: ( D106 . D112 ) c= ( D106 . D110 )
and
L878: ( D106 . D110 ) c= ( D106 . D107 );
L879: (the ToleranceRel of ( D106 . D110 )) c= (the ToleranceRel of ( D106 . D107 )) by L878 , L575;
L880: (the ToleranceRel of ( D106 . D112 )) c= (the ToleranceRel of ( D106 . D110 )) by L877 , L575;
L881: (the InternalRel of ( D106 . D110 )) c= (the InternalRel of ( D106 . D107 )) by L878 , L575;
reconsider D126 = C413 as (Element of ( D106 . D107 )) by L809 , L878 , L589;
reconsider D127 = C412 as (Element of ( D106 . D107 )) by L810 , L878 , L589;
L882: C410 in (the carrier of ( D106 . D112 )) by L812 , L815 , L816 , ZFMISC_1:87;
reconsider D128 = C410 as (Element of ( D106 . D110 )) by L882 , L877 , L589;
L883: D109 <= D108 by L796 , L799 , L801 , ORDERS_2:def 5;
L884: D126 <= D127 by L803 , L806 , L808 , L881 , ORDERS_2:def 5;
L885: D128 (--) D111 by L812 , L815 , L816 , L880 , L247;
L886: D108 (--) D127 by L885 , L879 , L583;
L887: D109 (--) D126 by L886 , L883 , L884 , L480;
L888: [ D109 , D126 ] in (the ToleranceRel of ( D106 . D107 )) by L887 , L247;
thus L889: [ C411 , C413 ] in D99 by L888 , L821;
end;
suppose that L890: ( D106 . D110 ) c= ( D106 . D112 )
and
L891: ( D106 . D112 ) c= ( D106 . D107 );
L892: (the ToleranceRel of ( D106 . D112 )) c= (the ToleranceRel of ( D106 . D107 )) by L891 , L575;
L893: (the InternalRel of ( D106 . D112 )) c= (the InternalRel of ( D106 . D107 )) by L891 , L575;
L894: (the InternalRel of ( D106 . D110 )) c= (the InternalRel of ( D106 . D112 )) by L890 , L575;
reconsider D129 = C413 as (Element of ( D106 . D112 )) by L809 , L890 , L589;
L895: (the carrier of ( D106 . D110 )) c= (the carrier of ( D106 . D112 )) by L890 , L575;
reconsider D130 = C413 as (Element of ( D106 . D107 )) by L895 , L809 , L891 , L589;
reconsider D131 = C412 as (Element of ( D106 . D107 )) by L810 , L891 , L895 , L589;
L896: D129 <= D114 by L803 , L806 , L808 , L894 , ORDERS_2:def 5;
L897: D109 <= D108 by L796 , L799 , L801 , ORDERS_2:def 5;
L898: D130 <= D131 by L893 , L896 , L577;
L899: D108 (--) D131 by L812 , L815 , L816 , L892 , L247;
L900: D109 (--) D130 by L899 , L897 , L898 , L480;
L901: [ D109 , D130 ] in (the ToleranceRel of ( D106 . D107 )) by L900 , L247;
thus L902: [ C411 , C413 ] in D99 by L901 , L821;
end;
end;
end;
registration
let C420 , C421 being set;
cluster <% C420 , C421 %> -> { ( 0 ) , 1 } -defined;
coherence
proof
L905: ( len <% C420 , C421 %> ) = { ( 0 ) , 1 } by AFINSQ_1:38 , CARD_1:50;
thus L906: thesis by L905 , RELAT_1:def 18;
end;
cluster <% C420 , C421 %> ->  total;
coherence
proof
L907: ( len <% C420 , C421 %> ) = { ( 0 ) , 1 } by AFINSQ_1:38 , CARD_1:50;
thus L908: thesis by L907 , PARTFUN1:def 2;
end;
end;
registration
let C422 , C423 being 1-sorted;
cluster <% C422 , C423 %> ->  1-sorted-yielding;
coherence
proof
let C424 being set;
assume L910: C424 in ( dom <% C422 , C423 %> );
L911: C424 in ( len <% C422 , C423 %> ) by L910;
L912: C424 in 2 by L911 , AFINSQ_1:38;
L913: (C424 = ( 0 ) or C424 = 1) by L912 , CARD_1:50 , TARSKI:def 2;
thus L914: thesis by L913 , AFINSQ_1:38;
end;
end;
L916:
now
let C425 , C426 being set;
L917: <% C425 , C426 %> = ( (( 0 ) , 1) --> (C425 , C426) ) by AFINSQ_1:76;
thus L918: ( rng <% C425 , C426 %> ) = { C425 , C426 } by L917 , FUNCT_4:64;
end;
registration
let C427 , C428 being RelStr;
cluster <% C427 , C428 %> ->  RelStr-yielding;
coherence
proof
let C429 being set;
assume L919: C429 in ( rng <% C427 , C428 %> );
L920: C429 in { C427 , C428 } by L919 , L916;
thus L921: thesis by L920 , TARSKI:def 2;
end;
end;
registration
let C430 , C431 being TolStr;
cluster <% C430 , C431 %> ->  TolStr-yielding;
coherence
proof
let C432 being set;
assume L923: C432 in { ( 0 ) , 1 };
L924: (C432 = ( 0 ) or C432 = 1) by L923 , TARSKI:def 2;
thus L925: thesis by L924 , AFINSQ_1:38;
end;
end;
registration
let C433 , C434 being pcs-Str;
cluster <% C433 , C434 %> ->  pcs-Str-yielding;
coherence
proof
let C435 being set;
assume L927: C435 in { ( 0 ) , 1 };
L928: (C435 = ( 0 ) or C435 = 1) by L927 , TARSKI:def 2;
thus L929: thesis by L928 , AFINSQ_1:38;
end;
end;
registration
let C436 , C437 being  reflexive pcs-Str;
cluster <% C436 , C437 %> ->  reflexive-yielding;
coherence
proof
let C438 being RelStr;
assume L931: C438 in ( rng <% C436 , C437 %> );
L932: C438 in { C436 , C437 } by L931 , L916;
thus L933: thesis by L932 , TARSKI:def 2;
end;
end;
registration
let C439 , C440 being  transitive pcs-Str;
cluster <% C439 , C440 %> ->  transitive-yielding;
coherence
proof
let C441 being RelStr;
assume L935: C441 in ( rng <% C439 , C440 %> );
L936: C441 in { C439 , C440 } by L935 , L916;
thus L937: thesis by L936 , TARSKI:def 2;
end;
end;
registration
let C442 , C443 being  pcs-tol-reflexive pcs-Str;
cluster <% C442 , C443 %> ->  pcs-tol-reflexive-yielding;
coherence
proof
let C444 being TolStr;
assume L939: C444 in ( rng <% C442 , C443 %> );
L940: C444 in { C442 , C443 } by L939 , L916;
thus L941: thesis by L940 , TARSKI:def 2;
end;
end;
registration
let C445 , C446 being  pcs-tol-symmetric pcs-Str;
cluster <% C445 , C446 %> ->  pcs-tol-symmetric-yielding;
coherence
proof
let C447 being TolStr;
assume L943: C447 in ( rng <% C445 , C446 %> );
L944: C447 in { C445 , C446 } by L943 , L916;
thus L945: thesis by L944 , TARSKI:def 2;
end;
end;
registration
let C448 , C449 being pcs;
cluster <% C448 , C449 %> ->  pcs-yielding;
coherence
proof
let C450 being set;
assume L947: C450 in { ( 0 ) , 1 };
L948: (C450 = ( 0 ) or C450 = 1) by L947 , TARSKI:def 2;
thus L949: thesis by L948 , AFINSQ_1:38;
end;
end;
definition
canceled 1;
let C451 , C452 being pcs-Str;
func pcs-sum (C451 , C452) -> pcs-Str equals 
( pcs-union <% C451 , C452 %> );
coherence;
end;
deffunc H1(pcs-Str , pcs-Str) = pcs-Str (# ( (the carrier of $1) \/ (the carrier of $2) ) , ( (the InternalRel of $1) \/ (the InternalRel of $2) ) , ( (the ToleranceRel of $1) \/ (the ToleranceRel of $2) ) #);
theorem
L952: (for B202 , B203 being pcs-Str holds ((the carrier of ( pcs-sum (B202 , B203) )) = ( (the carrier of B202) \/ (the carrier of B203) ) & (the InternalRel of ( pcs-sum (B202 , B203) )) = ( (the InternalRel of B202) \/ (the InternalRel of B203) ) & (the ToleranceRel of ( pcs-sum (B202 , B203) )) = ( (the ToleranceRel of B202) \/ (the ToleranceRel of B203) )))
proof
let C453 , C454 being pcs-Str;
set D132 = H1(C453 , C454);
set D133 = <% C453 , C454 %>;
L953: ( dom ( Carrier D133 ) ) = { ( 0 ) , 1 } by PARTFUN1:def 2;
L954: ( dom ( pcs-InternalRels D133 ) ) = { ( 0 ) , 1 } by PARTFUN1:def 2;
L955: ( dom ( pcs-ToleranceRels D133 ) ) = { ( 0 ) , 1 } by PARTFUN1:def 2;
L956: ( D133 . ( 0 ) ) = C453 by AFINSQ_1:38;
L957: ( D133 . 1 ) = C454 by AFINSQ_1:38;
L958: (the carrier of D132) = ( Union ( Carrier D133 ) )
proof
thus L959: (the carrier of D132) c= ( Union ( Carrier D133 ) )
proof
let C455 being set;
assume L960: C455 in (the carrier of D132);
L961: (C455 in (the carrier of C453) or C455 in (the carrier of C454)) by L960 , XBOOLE_0:def 3;
L962: ( ( Carrier D133 ) . D1 ) = (the carrier of ( D133 . D1 )) by L38;
L963: ( ( Carrier D133 ) . D2 ) = (the carrier of ( D133 . D2 )) by L38;
L964: (the carrier of C453) in ( rng ( Carrier D133 ) ) by L953 , L956 , L962 , FUNCT_1:3;
L965: (the carrier of C454) in ( rng ( Carrier D133 ) ) by L953 , L957 , L963 , FUNCT_1:3;
thus L966: thesis by L965 , L961 , L964 , TARSKI:def 4;
end;

let C456 being set;
assume L967: C456 in ( Union ( Carrier D133 ) );
consider C457 being set such that L968: C456 in C457 and L969: C457 in ( rng ( Carrier D133 ) ) by L967 , TARSKI:def 4;
consider C458 being set such that L970: C458 in ( dom ( Carrier D133 ) ) and L971: ( ( Carrier D133 ) . C458 ) = C457 by L969 , FUNCT_1:def 3;
L972: (C458 = ( 0 ) or C458 = 1) by L970 , TARSKI:def 2;
L973: (C457 = (the carrier of ( D133 . D1 )) or C457 = (the carrier of ( D133 . D2 ))) by L972 , L971 , L38;
thus L974: thesis by L973 , L956 , L957 , L968 , XBOOLE_0:def 3;
end;
L975: (the InternalRel of D132) = ( Union ( pcs-InternalRels D133 ) )
proof
thus L976: (the InternalRel of D132) c= ( Union ( pcs-InternalRels D133 ) )
proof
let C459 being set;
assume L977: C459 in (the InternalRel of D132);
L978: (C459 in (the InternalRel of C453) or C459 in (the InternalRel of C454)) by L977 , XBOOLE_0:def 3;
L979: ( ( pcs-InternalRels D133 ) . D1 ) = (the InternalRel of ( D133 . D1 )) by L227;
L980: ( ( pcs-InternalRels D133 ) . D2 ) = (the InternalRel of ( D133 . D2 )) by L227;
L981: (the InternalRel of C453) in ( rng ( pcs-InternalRels D133 ) ) by L954 , L956 , L979 , FUNCT_1:3;
L982: (the InternalRel of C454) in ( rng ( pcs-InternalRels D133 ) ) by L954 , L957 , L980 , FUNCT_1:3;
thus L983: thesis by L982 , L978 , L981 , TARSKI:def 4;
end;

let C460 being set;
assume L984: C460 in ( Union ( pcs-InternalRels D133 ) );
consider C461 being set such that L985: C460 in C461 and L986: C461 in ( rng ( pcs-InternalRels D133 ) ) by L984 , TARSKI:def 4;
consider C462 being set such that L987: C462 in ( dom ( pcs-InternalRels D133 ) ) and L988: ( ( pcs-InternalRels D133 ) . C462 ) = C461 by L986 , FUNCT_1:def 3;
L989: (C462 = ( 0 ) or C462 = 1) by L987 , TARSKI:def 2;
L990: (C461 = (the InternalRel of ( D133 . D1 )) or C461 = (the InternalRel of ( D133 . D2 ))) by L989 , L988 , L227;
thus L991: thesis by L990 , L956 , L957 , L985 , XBOOLE_0:def 3;
end;
L992: (the ToleranceRel of D132) = ( Union ( pcs-ToleranceRels D133 ) )
proof
thus L993: (the ToleranceRel of D132) c= ( Union ( pcs-ToleranceRels D133 ) )
proof
let C463 being set;
assume L994: C463 in (the ToleranceRel of D132);
L995: (C463 in (the ToleranceRel of C453) or C463 in (the ToleranceRel of C454)) by L994 , XBOOLE_0:def 3;
L996: ( ( pcs-ToleranceRels D133 ) . D1 ) = (the ToleranceRel of ( D133 . D1 )) by L389;
L997: ( ( pcs-ToleranceRels D133 ) . D2 ) = (the ToleranceRel of ( D133 . D2 )) by L389;
L998: (the ToleranceRel of C453) in ( rng ( pcs-ToleranceRels D133 ) ) by L955 , L956 , L996 , FUNCT_1:3;
L999: (the ToleranceRel of C454) in ( rng ( pcs-ToleranceRels D133 ) ) by L955 , L957 , L997 , FUNCT_1:3;
thus L1000: thesis by L999 , L995 , L998 , TARSKI:def 4;
end;

let C464 being set;
assume L1001: C464 in ( Union ( pcs-ToleranceRels D133 ) );
consider C465 being set such that L1002: C464 in C465 and L1003: C465 in ( rng ( pcs-ToleranceRels D133 ) ) by L1001 , TARSKI:def 4;
consider C466 being set such that L1004: C466 in ( dom ( pcs-ToleranceRels D133 ) ) and L1005: ( ( pcs-ToleranceRels D133 ) . C466 ) = C465 by L1003 , FUNCT_1:def 3;
L1006: (C466 = ( 0 ) or C466 = 1) by L1004 , TARSKI:def 2;
L1007: (C465 = (the ToleranceRel of ( D133 . D1 )) or C465 = (the ToleranceRel of ( D133 . D2 ))) by L1006 , L1005 , L389;
thus L1008: thesis by L1007 , L956 , L957 , L1002 , XBOOLE_0:def 3;
end;
thus L1009: thesis by L992 , L958 , L975 , L608;
end;
theorem
L1010: (for B204 , B205 being pcs-Str holds ( pcs-sum (B204 , B205) ) = pcs-Str (# ( (the carrier of B204) \/ (the carrier of B205) ) , ( (the InternalRel of B204) \/ (the InternalRel of B205) ) , ( (the ToleranceRel of B204) \/ (the ToleranceRel of B205) ) #))
proof
let C467 , C468 being pcs-Str;
L1011: (the carrier of ( pcs-sum (C467 , C468) )) = ( (the carrier of C467) \/ (the carrier of C468) ) by L952;
L1012: (the InternalRel of ( pcs-sum (C467 , C468) )) = ( (the InternalRel of C467) \/ (the InternalRel of C468) ) by L952;
thus L1013: thesis by L1012 , L1011 , L952;
end;
theorem
L1014: (for B206 , B207 being pcs-Str holds (for B208 , B209 being (Element of ( pcs-sum (B206 , B207) )) holds (B208 <= B209 iff ((ex B210 , B211 being (Element of B206) st (B210 = B208 & B211 = B209 & B210 <= B211)) or (ex B212 , B213 being (Element of B207) st (B212 = B208 & B213 = B209 & B212 <= B213))))))
proof
let C469 , C470 being pcs-Str;
set D134 = ( pcs-sum (C469 , C470) );
let C471 , C472 being (Element of D134);
L1015: (the InternalRel of D134) = ( (the InternalRel of C469) \/ (the InternalRel of C470) ) by L952;
thus L1016: (C471 <= C472 implies ((ex B214 , B215 being (Element of C469) st (B214 = C471 & B215 = C472 & B214 <= B215)) or (ex B216 , B217 being (Element of C470) st (B216 = C471 & B217 = C472 & B216 <= B217))))
proof
assume L1017: [ C471 , C472 ] in (the InternalRel of D134);
per cases  by L1015 , L1017 , XBOOLE_0:def 3;
suppose L1018: [ C471 , C472 ] in (the InternalRel of C469);

reconsider D135 = C471 , D136 = C472 as (Element of C469) by L1018 , ZFMISC_1:87;
L1019: D135 <= D136 by L1018 , ORDERS_2:def 5;
thus L1020: thesis by L1019;
end;
suppose L1021: [ C471 , C472 ] in (the InternalRel of C470);

reconsider D137 = C471 , D138 = C472 as (Element of C470) by L1021 , ZFMISC_1:87;
L1022: D137 <= D138 by L1021 , ORDERS_2:def 5;
thus L1023: thesis by L1022;
end;
end;

assume L1025: ((ex B218 , B219 being (Element of C469) st (B218 = C471 & B219 = C472 & B218 <= B219)) or (ex B220 , B221 being (Element of C470) st (B220 = C471 & B221 = C472 & B220 <= B221)));
per cases  by L1025;
suppose L1026: (ex B222 , B223 being (Element of C469) st (B222 = C471 & B223 = C472 & B222 <= B223));

consider C473 , C474 being (Element of C469) such that L1027: C473 = C471 and L1028: C474 = C472 and L1029: C473 <= C474 by L1026;
L1030: [ C473 , C474 ] in (the InternalRel of C469) by L1029 , ORDERS_2:def 5;
thus L1031: [ C471 , C472 ] in (the InternalRel of D134) by L1030 , L1015 , L1027 , L1028 , XBOOLE_0:def 3;
end;
suppose L1032: (ex B224 , B225 being (Element of C470) st (B224 = C471 & B225 = C472 & B224 <= B225));

consider C475 , C476 being (Element of C470) such that L1033: C475 = C471 and L1034: C476 = C472 and L1035: C475 <= C476 by L1032;
L1036: [ C475 , C476 ] in (the InternalRel of C470) by L1035 , ORDERS_2:def 5;
thus L1037: [ C471 , C472 ] in (the InternalRel of D134) by L1036 , L1015 , L1033 , L1034 , XBOOLE_0:def 3;
end;
end;
theorem
L1039: (for B226 , B227 being pcs-Str holds (for B228 , B229 being (Element of ( pcs-sum (B226 , B227) )) holds (B228 (--) B229 iff ((ex B230 , B231 being (Element of B226) st (B230 = B228 & B231 = B229 & B230 (--) B231)) or (ex B232 , B233 being (Element of B227) st (B232 = B228 & B233 = B229 & B232 (--) B233))))))
proof
let C477 , C478 being pcs-Str;
set D139 = ( pcs-sum (C477 , C478) );
let C479 , C480 being (Element of D139);
L1040: (the ToleranceRel of D139) = ( (the ToleranceRel of C477) \/ (the ToleranceRel of C478) ) by L952;
thus L1041: (C479 (--) C480 implies ((ex B234 , B235 being (Element of C477) st (B234 = C479 & B235 = C480 & B234 (--) B235)) or (ex B236 , B237 being (Element of C478) st (B236 = C479 & B237 = C480 & B236 (--) B237))))
proof
assume L1042: [ C479 , C480 ] in (the ToleranceRel of D139);
per cases  by L1040 , L1042 , XBOOLE_0:def 3;
suppose L1043: [ C479 , C480 ] in (the ToleranceRel of C477);

reconsider D140 = C479 , D141 = C480 as (Element of C477) by L1043 , ZFMISC_1:87;
L1044: D140 (--) D141 by L1043 , L247;
thus L1045: thesis by L1044;
end;
suppose L1046: [ C479 , C480 ] in (the ToleranceRel of C478);

reconsider D142 = C479 , D143 = C480 as (Element of C478) by L1046 , ZFMISC_1:87;
L1047: D142 (--) D143 by L1046 , L247;
thus L1048: thesis by L1047;
end;
end;

assume L1050: ((ex B238 , B239 being (Element of C477) st (B238 = C479 & B239 = C480 & B238 (--) B239)) or (ex B240 , B241 being (Element of C478) st (B240 = C479 & B241 = C480 & B240 (--) B241)));
per cases  by L1050;
suppose L1051: (ex B242 , B243 being (Element of C477) st (B242 = C479 & B243 = C480 & B242 (--) B243));

consider C481 , C482 being (Element of C477) such that L1052: C481 = C479 and L1053: C482 = C480 and L1054: C481 (--) C482 by L1051;
L1055: [ C481 , C482 ] in (the ToleranceRel of C477) by L1054 , L247;
thus L1056: [ C479 , C480 ] in (the ToleranceRel of D139) by L1055 , L1040 , L1052 , L1053 , XBOOLE_0:def 3;
end;
suppose L1057: (ex B244 , B245 being (Element of C478) st (B244 = C479 & B245 = C480 & B244 (--) B245));

consider C483 , C484 being (Element of C478) such that L1058: C483 = C479 and L1059: C484 = C480 and L1060: C483 (--) C484 by L1057;
L1061: [ C483 , C484 ] in (the ToleranceRel of C478) by L1060 , L247;
thus L1062: [ C479 , C480 ] in (the ToleranceRel of D139) by L1061 , L1040 , L1058 , L1059 , XBOOLE_0:def 3;
end;
end;
registration
let C485 , C486 being  reflexive pcs-Str;
cluster ( pcs-sum (C485 , C486) ) ->  reflexive;
coherence;
end;
registration
let C487 , C488 being  pcs-tol-reflexive pcs-Str;
cluster ( pcs-sum (C487 , C488) ) ->  pcs-tol-reflexive;
coherence;
end;
registration
let C489 , C490 being  pcs-tol-symmetric pcs-Str;
cluster ( pcs-sum (C489 , C490) ) ->  pcs-tol-symmetric;
coherence;
end;
theorem
L1067: (for B246 , B247 being pcs holds (B246 misses B247 implies (the InternalRel of ( pcs-sum (B246 , B247) )) is  transitive))
proof
let C491 , C492 being pcs;
assume L1068: (the carrier of C491) misses (the carrier of C492);
L1069: ( pcs-sum (C491 , C492) ) = H1(C491 , C492) by L1010;
thus L1070: thesis by L1069 , L1068 , L18;
end;
theorem
L1071: (for B248 , B249 being pcs holds (B248 misses B249 implies ( pcs-sum (B248 , B249) ) is  pcs-compatible))
proof
let C493 , C494 being pcs;
set D144 = (the carrier of C493);
set D145 = (the carrier of C494);
set D146 = (the InternalRel of C493);
set D147 = (the InternalRel of C494);
set D148 = (the ToleranceRel of C493);
set D149 = (the ToleranceRel of C494);
set D150 = ( D146 \/ D147 );
set D151 = ( D148 \/ D149 );
assume L1072: D144 misses D145;
let C495 , C496 , C497 , C498 being (Element of ( pcs-sum (C493 , C494) ));
assume that
L1073: C495 (--) C497
and
L1074: C496 <= C495
and
L1075: C498 <= C497;
L1076: ( pcs-sum (C493 , C494) ) = H1(C493 , C494) by L1010;
L1077: [ C495 , C497 ] in D151 by L1076 , L1073 , L247;
per cases  by L1077 , XBOOLE_0:def 3;
suppose L1078: [ C495 , C497 ] in D148;

L1079: C495 in D144 by L1078 , ZFMISC_1:87;
L1080: C497 in D144 by L1078 , ZFMISC_1:87;
reconsider D152 = C495 , D153 = C497 as (Element of C493) by L1078 , ZFMISC_1:87;
L1081: D152 (--) D153 by L1078 , L247;
L1082: [ C496 , C495 ] in D150 by L1074 , L1076 , ORDERS_2:def 5;
L1083: [ C498 , C497 ] in D150 by L1075 , L1076 , ORDERS_2:def 5;
reconsider D154 = C496 , D155 = C498 as (Element of C493) by L1083 , L1072 , L1079 , L1080 , L1082 , L8;
L1084: [ C496 , C495 ] in D146 by L1072 , L1079 , L1082 , L8;
L1085: [ C498 , C497 ] in D146 by L1072 , L1080 , L1083 , L8;
L1086: D154 <= D152 by L1084 , ORDERS_2:def 5;
L1087: D155 <= D153 by L1085 , ORDERS_2:def 5;
L1088: D154 (--) D155 by L1087 , L1081 , L1086 , L480;
L1089: [ D154 , D155 ] in D148 by L1088 , L247;
L1090: [ D154 , D155 ] in D151 by L1089 , XBOOLE_0:def 3;
thus L1091: C496 (--) C498 by L1090 , L1076 , L247;
end;
suppose L1092: [ C495 , C497 ] in D149;

L1093: C495 in D145 by L1092 , ZFMISC_1:87;
L1094: C497 in D145 by L1092 , ZFMISC_1:87;
reconsider D156 = C495 , D157 = C497 as (Element of C494) by L1092 , ZFMISC_1:87;
L1095: D156 (--) D157 by L1092 , L247;
L1096: [ C496 , C495 ] in D150 by L1074 , L1076 , ORDERS_2:def 5;
L1097: [ C498 , C497 ] in D150 by L1075 , L1076 , ORDERS_2:def 5;
reconsider D158 = C496 , D159 = C498 as (Element of C494) by L1097 , L1072 , L1093 , L1094 , L1096 , L8;
L1098: [ C496 , C495 ] in D147 by L1072 , L1093 , L1096 , L8;
L1099: [ C498 , C497 ] in D147 by L1072 , L1094 , L1097 , L8;
L1100: D158 <= D156 by L1098 , ORDERS_2:def 5;
L1101: D159 <= D157 by L1099 , ORDERS_2:def 5;
L1102: D158 (--) D159 by L1101 , L1095 , L1100 , L480;
L1103: [ D158 , D159 ] in D149 by L1102 , L247;
L1104: [ D158 , D159 ] in D151 by L1103 , XBOOLE_0:def 3;
thus L1105: C496 (--) C498 by L1104 , L1076 , L247;
end;
end;
theorem
L1107: (for B250 , B251 being pcs holds (B250 misses B251 implies ( pcs-sum (B250 , B251) ) is pcs))
proof
let C499 , C500 being pcs;
assume L1108: C499 misses C500;
set D160 = ( pcs-sum (C499 , C500) );
L1109: ( field (the InternalRel of D160) ) = (the carrier of D160) by ORDERS_1:12;
L1110: (the InternalRel of D160) is  transitive by L1108 , L1067;
L1111: (the InternalRel of D160) is_transitive_in (the carrier of D160) by L1110 , L1109 , RELAT_2:def 16;
L1112: D160 is  transitive by L1111 , ORDERS_2:def 3;
L1113: D160 is  pcs-compatible by L1108 , L1071;
thus L1114: thesis by L1113 , L1112;
end;
definition
let C501 being pcs-Str;
let C502 being set;
func pcs-extension (C501 , C502) ->  strict pcs-Str means 
:L1115: ((the carrier of it) = ( { C502 } \/ (the carrier of C501) ) & (the InternalRel of it) = ( [: { C502 } , (the carrier of it) :] \/ (the InternalRel of C501) ) & (the ToleranceRel of it) = ( ( [: { C502 } , (the carrier of it) :] \/ [: (the carrier of it) , { C502 } :] ) \/ (the ToleranceRel of C501) ));
existence
proof
set D161 = ( { C502 } \/ (the carrier of C501) );
set D162 = ( [: { C502 } , D161 :] \/ (the InternalRel of C501) );
set D163 = ( ( [: D161 , { C502 } :] \/ [: { C502 } , D161 :] ) \/ (the ToleranceRel of C501) );
L1116: { C502 } c= D161 by XBOOLE_1:7;
L1117: [: { C502 } , D161 :] c= [: D161 , D161 :] by L1116 , ZFMISC_1:95;
L1118: (the carrier of C501) c= D161 by XBOOLE_1:7;
L1119: [: (the carrier of C501) , (the carrier of C501) :] c= [: D161 , D161 :] by L1118 , ZFMISC_1:96;
L1120: (the InternalRel of C501) c= [: D161 , D161 :] by L1119 , XBOOLE_1:1;
reconsider D164 = D162 as (Relation of D161) by L1120 , L1117 , XBOOLE_1:8;
L1121: [: D161 , { C502 } :] c= [: D161 , D161 :] by L1116 , ZFMISC_1:95;
L1122: ( [: D161 , { C502 } :] \/ [: { C502 } , D161 :] ) c= [: D161 , D161 :] by L1121 , L1117 , XBOOLE_1:8;
L1123: (the ToleranceRel of C501) c= [: D161 , D161 :] by L1119 , XBOOLE_1:1;
reconsider D165 = D163 as (Relation of D161) by L1123 , L1122 , XBOOLE_1:8;
take pcs-Str (# D161 , D164 , D165 #);
thus L1124: thesis;
end;
uniqueness;
end;
registration
let C503 being pcs-Str;
let C504 being set;
cluster ( pcs-extension (C503 , C504) ) -> non  empty;
coherence
proof
L1126: (the carrier of ( pcs-extension (C503 , C504) )) = ( { C504 } \/ (the carrier of C503) ) by L1115;
thus L1127: (the carrier of ( pcs-extension (C503 , C504) )) is non  empty by L1126;
end;
end;
theorem
L1129: (for B252 being pcs-Str holds (for B253 being set holds ((the carrier of B252) c= (the carrier of ( pcs-extension (B252 , B253) )) & (the InternalRel of B252) c= (the InternalRel of ( pcs-extension (B252 , B253) )) & (the ToleranceRel of B252) c= (the ToleranceRel of ( pcs-extension (B252 , B253) )))))
proof
let C505 being pcs-Str;
let C506 being set;
set D166 = ( pcs-extension (C505 , C506) );
L1130: (the carrier of D166) = ( { C506 } \/ (the carrier of C505) ) by L1115;
L1131: (the InternalRel of D166) = ( [: { C506 } , (the carrier of D166) :] \/ (the InternalRel of C505) ) by L1115;
L1132: (the ToleranceRel of D166) = ( ( [: { C506 } , (the carrier of D166) :] \/ [: (the carrier of D166) , { C506 } :] ) \/ (the ToleranceRel of C505) ) by L1115;
thus L1133: thesis by L1132 , L1130 , L1131 , XBOOLE_1:7;
end;
theorem
L1134: (for B254 being pcs-Str holds (for B255 being set holds (for B256 , B257 being (Element of ( pcs-extension (B254 , B255) )) holds (B256 = B255 implies B256 <= B257))))
proof
let C507 being pcs-Str;
let C508 being set;
set D167 = ( pcs-extension (C507 , C508) );
let C509 , C510 being (Element of D167);
assume that
L1135: C509 = C508;
L1136: (the InternalRel of D167) = ( [: { C508 } , (the carrier of D167) :] \/ (the InternalRel of C507) ) by L1115;
L1137: [ C508 , C510 ] in [: { C508 } , (the carrier of D167) :] by ZFMISC_1:105;
thus L1138: [ C509 , C510 ] in (the InternalRel of D167) by L1137 , L1135 , L1136 , XBOOLE_0:def 3;
end;
theorem
L1139: (for B258 being pcs-Str holds (for B259 being set holds (for B260 , B261 being (Element of B258) holds (for B262 , B263 being (Element of ( pcs-extension (B258 , B259) )) holds ((B260 = B262 & B261 = B263 & B260 <= B261) implies B262 <= B263)))))
proof
let C511 being pcs-Str;
let C512 being set;
let C513 , C514 being (Element of C511);
let C515 , C516 being (Element of ( pcs-extension (C511 , C512) ));
assume that
L1140: C513 = C515
and
L1141: C514 = C516
and
L1142: [ C513 , C514 ] in (the InternalRel of C511);
L1143: (the InternalRel of C511) c= (the InternalRel of ( pcs-extension (C511 , C512) )) by L1129;
thus L1144: [ C515 , C516 ] in (the InternalRel of ( pcs-extension (C511 , C512) )) by L1143 , L1140 , L1141 , L1142;
end;
theorem
L1145: (for B264 being pcs-Str holds (for B265 being set holds (for B266 being (Element of B264) holds (for B267 , B268 being (Element of ( pcs-extension (B264 , B265) )) holds ((B266 = B267 & B266 <> B265 & B267 <= B268 & (not B265 in (the carrier of B264))) implies (B268 in (the carrier of B264) & B268 <> B265))))))
proof
let C517 being pcs-Str;
let C518 being set;
let C519 being (Element of C517);
let C520 , C521 being (Element of ( pcs-extension (C517 , C518) ));
assume that
L1146: C519 = C520
and
L1147: C519 <> C518
and
L1148: C520 <= C521
and
L1149: (not C518 in (the carrier of C517));
set D168 = ( pcs-extension (C517 , C518) );
L1150: (the InternalRel of D168) = ( [: { C518 } , (the carrier of D168) :] \/ (the InternalRel of C517) ) by L1115;
L1151: [ C520 , C521 ] in (the InternalRel of D168) by L1148 , ORDERS_2:def 5;
L1152: ([ C520 , C521 ] in [: { C518 } , (the carrier of D168) :] or [ C520 , C521 ] in (the InternalRel of C517)) by L1151 , L1150 , XBOOLE_0:def 3;
thus L1153: thesis by L1152 , L1146 , L1147 , L1149 , ZFMISC_1:87 , ZFMISC_1:105;
end;
theorem
L1154: (for B269 being pcs-Str holds (for B270 being set holds (for B271 being (Element of ( pcs-extension (B269 , B270) )) holds (B271 <> B270 implies B271 in (the carrier of B269)))))
proof
let C522 being pcs-Str;
let C523 being set;
let C524 being (Element of ( pcs-extension (C522 , C523) ));
assume that
L1155: C524 <> C523;
L1156: (the carrier of ( pcs-extension (C522 , C523) )) = ( { C523 } \/ (the carrier of C522) ) by L1115;
L1157: (C524 in { C523 } or C524 in (the carrier of C522)) by L1156 , XBOOLE_0:def 3;
thus L1158: thesis by L1157 , L1155 , TARSKI:def 1;
end;
theorem
L1159: (for B272 being pcs-Str holds (for B273 being set holds (for B274 , B275 being (Element of B272) holds (for B276 , B277 being (Element of ( pcs-extension (B272 , B273) )) holds ((B274 = B276 & B275 = B277 & B274 <> B273 & B276 <= B277) implies B274 <= B275)))))
proof
let C525 being pcs-Str;
let C526 being set;
let C527 , C528 being (Element of C525);
let C529 , C530 being (Element of ( pcs-extension (C525 , C526) ));
assume that
L1160: C527 = C529
and
L1161: C528 = C530
and
L1162: C527 <> C526
and
L1163: C529 <= C530;
set D169 = ( pcs-extension (C525 , C526) );
L1164: (the InternalRel of D169) = ( [: { C526 } , (the carrier of D169) :] \/ (the InternalRel of C525) ) by L1115;
L1165: [ C529 , C530 ] in (the InternalRel of D169) by L1163 , ORDERS_2:def 5;
L1166: ([ C529 , C530 ] in [: { C526 } , (the carrier of D169) :] or [ C529 , C530 ] in (the InternalRel of C525)) by L1165 , L1164 , XBOOLE_0:def 3;
thus L1167: [ C527 , C528 ] in (the InternalRel of C525) by L1166 , L1160 , L1161 , L1162 , ZFMISC_1:105;
end;
theorem
L1168: (for B278 being pcs-Str holds (for B279 being set holds (for B280 , B281 being (Element of ( pcs-extension (B278 , B279) )) holds (B280 = B279 implies (B280 (--) B281 & B281 (--) B280)))))
proof
let C531 being pcs-Str;
let C532 being set;
set D170 = ( pcs-extension (C531 , C532) );
let C533 , C534 being (Element of D170);
assume that
L1169: C533 = C532;
L1170: (the ToleranceRel of D170) = ( ( [: { C532 } , (the carrier of D170) :] \/ [: (the carrier of D170) , { C532 } :] ) \/ (the ToleranceRel of C531) ) by L1115;
L1171: (the ToleranceRel of D170) = ( [: { C532 } , (the carrier of D170) :] \/ ( [: (the carrier of D170) , { C532 } :] \/ (the ToleranceRel of C531) ) ) by L1170 , XBOOLE_1:4;
L1172: [ C532 , C534 ] in [: { C532 } , (the carrier of D170) :] by ZFMISC_1:105;
L1173: [ C534 , C532 ] in [: (the carrier of D170) , { C532 } :] by ZFMISC_1:106;
L1174: [ C534 , C532 ] in ( [: (the carrier of D170) , { C532 } :] \/ (the ToleranceRel of C531) ) by L1173 , XBOOLE_0:def 3;
thus L1175: ([ C533 , C534 ] in (the ToleranceRel of D170) & [ C534 , C533 ] in (the ToleranceRel of D170)) by L1174 , L1169 , L1171 , L1172 , XBOOLE_0:def 3;
end;
theorem
L1176: (for B282 being pcs-Str holds (for B283 being set holds (for B284 , B285 being (Element of B282) holds (for B286 , B287 being (Element of ( pcs-extension (B282 , B283) )) holds ((B284 = B286 & B285 = B287 & B284 (--) B285) implies B286 (--) B287)))))
proof
let C535 being pcs-Str;
let C536 being set;
let C537 , C538 being (Element of C535);
let C539 , C540 being (Element of ( pcs-extension (C535 , C536) ));
assume that
L1177: C537 = C539
and
L1178: C538 = C540
and
L1179: [ C537 , C538 ] in (the ToleranceRel of C535);
L1180: (the ToleranceRel of C535) c= (the ToleranceRel of ( pcs-extension (C535 , C536) )) by L1129;
thus L1181: [ C539 , C540 ] in (the ToleranceRel of ( pcs-extension (C535 , C536) )) by L1180 , L1177 , L1178 , L1179;
end;
theorem
L1182: (for B288 being pcs-Str holds (for B289 being set holds (for B290 , B291 being (Element of B288) holds (for B292 , B293 being (Element of ( pcs-extension (B288 , B289) )) holds ((B290 = B292 & B291 = B293 & B290 <> B289 & B291 <> B289 & B292 (--) B293) implies B290 (--) B291)))))
proof
let C541 being pcs-Str;
let C542 being set;
let C543 , C544 being (Element of C541);
let C545 , C546 being (Element of ( pcs-extension (C541 , C542) ));
assume that
L1183: C543 = C545
and
L1184: C544 = C546
and
L1185: C543 <> C542
and
L1186: C544 <> C542
and
L1187: C545 (--) C546;
set D171 = ( pcs-extension (C541 , C542) );
L1188: (the ToleranceRel of D171) = ( ( [: { C542 } , (the carrier of D171) :] \/ [: (the carrier of D171) , { C542 } :] ) \/ (the ToleranceRel of C541) ) by L1115;
L1189: [ C545 , C546 ] in (the ToleranceRel of D171) by L1187 , L247;
L1190: ([ C545 , C546 ] in ( [: { C542 } , (the carrier of D171) :] \/ [: (the carrier of D171) , { C542 } :] ) or [ C545 , C546 ] in (the ToleranceRel of C541)) by L1189 , L1188 , XBOOLE_0:def 3;
L1191: ([ C545 , C546 ] in [: { C542 } , (the carrier of D171) :] or [ C545 , C546 ] in [: (the carrier of D171) , { C542 } :] or [ C545 , C546 ] in (the ToleranceRel of C541)) by L1190 , XBOOLE_0:def 3;
thus L1192: [ C543 , C544 ] in (the ToleranceRel of C541) by L1191 , L1183 , L1184 , L1185 , L1186 , ZFMISC_1:105 , ZFMISC_1:106;
end;
registration
let C547 being  reflexive pcs-Str;
let C548 being set;
cluster ( pcs-extension (C547 , C548) ) ->  reflexive;
coherence
proof
set D172 = ( pcs-extension (C547 , C548) );
L1193: (the carrier of D172) = ( { C548 } \/ (the carrier of C547) ) by L1115;
L1194: (the InternalRel of D172) = ( [: { C548 } , (the carrier of D172) :] \/ (the InternalRel of C547) ) by L1115;
let C549 being set;
assume L1195: C549 in (the carrier of D172);
per cases  by L1193 , L1195 , XBOOLE_0:def 3;
suppose L1196: C549 in { C548 };

L1197: C549 = C548 by L1196 , TARSKI:def 1;
L1198: [ C549 , C549 ] in [: { C548 } , (the carrier of D172) :] by L1197 , L1195 , ZFMISC_1:105;
thus L1199: thesis by L1198 , L1194 , XBOOLE_0:def 3;
end;
suppose L1200: C549 in (the carrier of C547);

L1201: (the InternalRel of C547) is_reflexive_in (the carrier of C547) by ORDERS_2:def 2;
L1202: [ C549 , C549 ] in (the InternalRel of C547) by L1201 , L1200 , RELAT_2:def 1;
thus L1203: thesis by L1202 , L1194 , XBOOLE_0:def 3;
end;
end;
end;
theorem
L1206: (for B294 being  transitive pcs-Str holds (for B295 being set holds ((not B295 in (the carrier of B294)) implies ( pcs-extension (B294 , B295) ) is  transitive)))
proof
let C550 being  transitive pcs-Str;
let C551 being set;
assume that
L1207: (not C551 in (the carrier of C550));
set D173 = ( pcs-extension (C550 , C551) );
L1208: (the InternalRel of D173) = ( [: { C551 } , (the carrier of D173) :] \/ (the InternalRel of C550) ) by L1115;
let C552 , C553 , C554 being set;
assume that
L1209: C552 in (the carrier of D173)
and
L1210: C553 in (the carrier of D173)
and
L1211: C554 in (the carrier of D173)
and
L1212: [ C552 , C553 ] in (the InternalRel of D173)
and
L1213: [ C553 , C554 ] in (the InternalRel of D173);
L1214: [ C551 , C554 ] in [: { C551 } , (the carrier of D173) :] by L1211 , ZFMISC_1:105;
reconsider D174 = C552 , D175 = C553 , D176 = C554 as (Element of D173) by L1209 , L1210 , L1211;
L1215: D174 <= D175 by L1212 , ORDERS_2:def 5;
L1216: D175 <= D176 by L1213 , ORDERS_2:def 5;
per cases ;
suppose L1217: D174 = C551;

thus L1218: thesis by L1217 , L1208 , L1214 , XBOOLE_0:def 3;
end;
suppose L1219: D174 <> C551;

reconsider D177 = D174 as (Element of C550) by L1219 , L1154;
L1220: D177 <> C551 by L1219;
reconsider D178 = D175 as (Element of C550) by L1220 , L1207 , L1215 , L1145;
L1221: D178 <> C551 by L1207 , L1215 , L1220 , L1145;
reconsider D179 = D176 as (Element of C550) by L1221 , L1207 , L1216 , L1145;
L1222: D175 <> C551 by L1207 , L1215 , L1220 , L1145;
L1223: D177 <= D178 by L1215 , L1219 , L1159;
L1224: D178 <= D179 by L1216 , L1222 , L1159;
L1225: D177 <= D179 by L1224 , L1223 , YELLOW_0:def 2;
L1226: D174 <= D176 by L1225 , L1139;
thus L1227: thesis by L1226 , ORDERS_2:def 5;
end;
end;
registration
let C555 being  pcs-tol-reflexive pcs-Str;
let C556 being set;
cluster ( pcs-extension (C555 , C556) ) ->  pcs-tol-reflexive;
coherence
proof
set D180 = ( pcs-extension (C555 , C556) );
L1229: (the carrier of D180) = ( { C556 } \/ (the carrier of C555) ) by L1115;
L1230: (the ToleranceRel of D180) = ( ( [: { C556 } , (the carrier of D180) :] \/ [: (the carrier of D180) , { C556 } :] ) \/ (the ToleranceRel of C555) ) by L1115;
L1231: (the ToleranceRel of D180) = ( [: { C556 } , (the carrier of D180) :] \/ ( [: (the carrier of D180) , { C556 } :] \/ (the ToleranceRel of C555) ) ) by L1230 , XBOOLE_1:4;
let C557 being set;
assume L1232: C557 in (the carrier of D180);
per cases  by L1229 , L1232 , XBOOLE_0:def 3;
suppose L1233: C557 in { C556 };

L1234: C557 = C556 by L1233 , TARSKI:def 1;
L1235: [ C557 , C557 ] in [: { C556 } , (the carrier of D180) :] by L1234 , L1232 , ZFMISC_1:105;
thus L1236: thesis by L1235 , L1231 , XBOOLE_0:def 3;
end;
suppose L1237: C557 in (the carrier of C555);

L1238: (the ToleranceRel of C555) is_reflexive_in (the carrier of C555) by L250;
L1239: [ C557 , C557 ] in (the ToleranceRel of C555) by L1238 , L1237 , RELAT_2:def 1;
thus L1240: thesis by L1239 , L1230 , XBOOLE_0:def 3;
end;
end;
end;
registration
let C558 being  pcs-tol-symmetric pcs-Str;
let C559 being set;
cluster ( pcs-extension (C558 , C559) ) ->  pcs-tol-symmetric;
coherence
proof
set D181 = ( pcs-extension (C558 , C559) );
L1243: (the ToleranceRel of D181) = ( ( [: { C559 } , (the carrier of D181) :] \/ [: (the carrier of D181) , { C559 } :] ) \/ (the ToleranceRel of C558) ) by L1115;
let C560 , C561 being set;
assume that
L1244: C560 in (the carrier of D181)
and
L1245: C561 in (the carrier of D181)
and
L1246: [ C560 , C561 ] in (the ToleranceRel of D181);
L1247: (the ToleranceRel of C558) is_symmetric_in (the carrier of C558) by L252;
per cases  by L1243 , L1246 , XBOOLE_0:def 3;
suppose L1248: [ C560 , C561 ] in ( [: { C559 } , (the carrier of D181) :] \/ [: (the carrier of D181) , { C559 } :] );

per cases  by L1248 , XBOOLE_0:def 3;
suppose L1249: [ C560 , C561 ] in [: { C559 } , (the carrier of D181) :];

L1250: C560 = C559 by L1249 , ZFMISC_1:105;
L1251: C561 in (the carrier of D181) by L1249 , ZFMISC_1:105;
L1252: [ C561 , C560 ] in [: (the carrier of D181) , { C559 } :] by L1251 , L1250 , ZFMISC_1:106;
L1253: [ C561 , C560 ] in ( [: { C559 } , (the carrier of D181) :] \/ [: (the carrier of D181) , { C559 } :] ) by L1252 , XBOOLE_0:def 3;
thus L1254: thesis by L1253 , L1243 , XBOOLE_0:def 3;
end;
suppose L1255: [ C560 , C561 ] in [: (the carrier of D181) , { C559 } :];

L1256: C561 = C559 by L1255 , ZFMISC_1:106;
L1257: C560 in (the carrier of D181) by L1255 , ZFMISC_1:106;
L1258: [ C561 , C560 ] in [: { C559 } , (the carrier of D181) :] by L1257 , L1256 , ZFMISC_1:105;
L1259: [ C561 , C560 ] in ( [: { C559 } , (the carrier of D181) :] \/ [: (the carrier of D181) , { C559 } :] ) by L1258 , XBOOLE_0:def 3;
thus L1260: thesis by L1259 , L1243 , XBOOLE_0:def 3;
end;
end;
suppose L1262: [ C560 , C561 ] in (the ToleranceRel of C558);

L1263: C560 in (the carrier of C558) by L1262 , ZFMISC_1:87;
L1264: C561 in (the carrier of C558) by L1262 , ZFMISC_1:87;
L1265: [ C561 , C560 ] in (the ToleranceRel of C558) by L1264 , L1247 , L1262 , L1263 , RELAT_2:def 3;
thus L1266: thesis by L1265 , L1243 , XBOOLE_0:def 3;
end;
end;
end;
theorem
L1269: (for B296 being  pcs-compatible pcs-Str holds (for B297 being set holds ((not B297 in (the carrier of B296)) implies ( pcs-extension (B296 , B297) ) is  pcs-compatible)))
proof
let C562 being  pcs-compatible pcs-Str;
let C563 being set;
assume that
L1270: (not C563 in (the carrier of C562));
set D182 = ( pcs-extension (C562 , C563) );
let C564 , C565 , C566 , C567 being (Element of D182);
assume that
L1271: C564 (--) C566
and
L1272: C565 <= C564
and
L1273: C567 <= C566;
per cases ;
suppose L1274: (C565 = C563 or C567 = C563);

thus L1275: thesis by L1274 , L1168;
end;
suppose that L1276: C565 <> C563
and
L1277: C567 <> C563;
reconsider D183 = C565 , D184 = C567 as (Element of C562) by L1276 , L1277 , L1154;
L1278: D183 <> C563 by L1276;
L1279: D184 <> C563 by L1277;
L1280: C564 <> C563 by L1270 , L1272 , L1278 , L1145;
L1281: C566 <> C563 by L1270 , L1273 , L1279 , L1145;
reconsider D185 = C564 , D186 = C566 as (Element of C562) by L1270 , L1272 , L1273 , L1278 , L1279 , L1145;
L1282: D185 (--) D186 by L1271 , L1280 , L1281 , L1182;
L1283: D183 <= D185 by L1272 , L1276 , L1159;
L1284: D184 <= D186 by L1273 , L1277 , L1159;
L1285: D183 (--) D184 by L1284 , L1282 , L1283 , L480;
thus L1286: thesis by L1285 , L1176;
end;
end;
theorem
L1288: (for B298 being pcs holds (for B299 being set holds ((not B299 in (the carrier of B298)) implies ( pcs-extension (B298 , B299) ) is pcs)))
proof
let C568 being pcs;
let C569 being set;
assume that
L1289: (not C569 in (the carrier of C568));
set D187 = ( pcs-extension (C568 , C569) );
L1290: D187 is  reflexive  transitive  pcs-tol-reflexive  pcs-tol-symmetric  pcs-compatible by L1289 , L1206 , L1269;
thus L1291: thesis by L1290;
end;
definition
let C570 being pcs-Str;
func pcs-reverse C570 ->  strict pcs-Str means 
:L1292: ((the carrier of it) = (the carrier of C570) & (the InternalRel of it) = ( (the InternalRel of C570) ~ ) & (the ToleranceRel of it) = ( (the ToleranceRel of C570) ` ));
existence
proof
reconsider D188 = ( (the ToleranceRel of C570) ` ) as (Relation of (the carrier of C570));
take pcs-Str (# (the carrier of C570) , ( (the InternalRel of C570) ~ ) , D188 #);
thus L1293: thesis;
end;
uniqueness;
end;
registration
let C571 being non  empty pcs-Str;
cluster ( pcs-reverse C571 ) -> non  empty;
coherence
proof
L1295: (the carrier of ( pcs-reverse C571 )) = (the carrier of C571) by L1292;
thus L1296: (the carrier of ( pcs-reverse C571 )) is non  empty by L1295;
end;
end;
theorem
L1298: (for B300 being pcs-Str holds (for B301 , B302 being (Element of B300) holds (for B303 , B304 being (Element of ( pcs-reverse B300 )) holds ((B301 = B303 & B302 = B304) implies (B301 <= B302 iff B304 <= B303)))))
proof
let C572 being pcs-Str;
let C573 , C574 being (Element of C572);
set D189 = ( pcs-reverse C572 );
let C575 , C576 being (Element of D189);
assume that
L1299: C573 = C575
and
L1300: C574 = C576;
L1301: (the InternalRel of D189) = ( (the InternalRel of C572) ~ ) by L1292;
thus L1302: (C573 <= C574 implies C576 <= C575)
proof
assume L1303: [ C573 , C574 ] in (the InternalRel of C572);
thus L1304: [ C576 , C575 ] in (the InternalRel of D189) by L1303 , L1299 , L1300 , L1301 , RELAT_1:def 7;
end;

assume L1305: [ C576 , C575 ] in (the InternalRel of D189);
thus L1306: [ C573 , C574 ] in (the InternalRel of C572) by L1305 , L1299 , L1300 , L1301 , RELAT_1:def 7;
end;
theorem
L1307: (for B305 being pcs-Str holds (for B306 , B307 being (Element of B305) holds (for B308 , B309 being (Element of ( pcs-reverse B305 )) holds ((B306 = B308 & B307 = B309) implies (B306 (--) B307 implies (not B308 (--) B309))))))
proof
let C577 being pcs-Str;
let C578 , C579 being (Element of C577);
set D190 = ( pcs-reverse C577 );
let C580 , C581 being (Element of D190);
assume that
L1308: C578 = C580
and
L1309: C579 = C581;
L1310: (the ToleranceRel of D190) = ( (the ToleranceRel of C577) ` ) by L1292;
assume L1311: [ C578 , C579 ] in (the ToleranceRel of C577);
thus L1312: (not [ C580 , C581 ] in (the ToleranceRel of D190)) by L1311 , L1308 , L1309 , L1310 , XBOOLE_0:def 5;
end;
theorem
L1313: (for B310 being non  empty pcs-Str holds (for B311 , B312 being (Element of B310) holds (for B313 , B314 being (Element of ( pcs-reverse B310 )) holds ((B311 = B313 & B312 = B314) implies ((not B313 (--) B314) implies B311 (--) B312)))))
proof
let C582 being non  empty pcs-Str;
let C583 , C584 being (Element of C582);
set D191 = ( pcs-reverse C582 );
let C585 , C586 being (Element of D191);
assume that
L1314: C583 = C585
and
L1315: C584 = C586;
L1316: (the ToleranceRel of D191) = ( (the ToleranceRel of C582) ` ) by L1292;
assume L1317: (not [ C585 , C586 ] in (the ToleranceRel of D191));
L1318: [ C583 , C584 ] in [: (the carrier of C582) , (the carrier of C582) :] by ZFMISC_1:87;
thus L1319: [ C583 , C584 ] in (the ToleranceRel of C582) by L1318 , L1314 , L1315 , L1316 , L1317 , XBOOLE_0:def 5;
end;
registration
let C587 being  reflexive pcs-Str;
cluster ( pcs-reverse C587 ) ->  reflexive;
coherence
proof
set D192 = ( pcs-reverse C587 );
L1320: (the carrier of D192) = (the carrier of C587) by L1292;
L1321: (the InternalRel of D192) = ( (the InternalRel of C587) ~ ) by L1292;
L1322: (the InternalRel of C587) is_reflexive_in (the carrier of C587) by ORDERS_2:def 2;
thus L1323: (the InternalRel of D192) is_reflexive_in (the carrier of D192) by L1322 , L1320 , L1321 , ORDERS_1:79;
end;
end;
registration
let C588 being  transitive pcs-Str;
cluster ( pcs-reverse C588 ) ->  transitive;
coherence
proof
set D193 = ( pcs-reverse C588 );
L1325: (the carrier of D193) = (the carrier of C588) by L1292;
L1326: (the InternalRel of D193) = ( (the InternalRel of C588) ~ ) by L1292;
L1327: (the InternalRel of C588) is_transitive_in (the carrier of C588) by ORDERS_2:def 3;
thus L1328: (the InternalRel of D193) is_transitive_in (the carrier of D193) by L1327 , L1325 , L1326 , ORDERS_1:80;
end;
end;
registration
let C589 being  pcs-tol-reflexive pcs-Str;
cluster ( pcs-reverse C589 ) ->  pcs-tol-irreflexive;
coherence
proof
set D194 = ( pcs-reverse C589 );
L1330: (the carrier of D194) = (the carrier of C589) by L1292;
L1331: (the ToleranceRel of D194) = ( (the ToleranceRel of C589) ` ) by L1292;
L1332: (the ToleranceRel of C589) is_reflexive_in (the carrier of C589) by L250;
let C590 being set;
assume L1333: C590 in (the carrier of D194);
L1334: [ C590 , C590 ] in (the ToleranceRel of C589) by L1333 , L1330 , L1332 , RELAT_2:def 1;
thus L1335: thesis by L1334 , L1331 , XBOOLE_0:def 5;
end;
end;
registration
let C591 being  pcs-tol-irreflexive pcs-Str;
cluster ( pcs-reverse C591 ) ->  pcs-tol-reflexive;
coherence
proof
set D195 = ( pcs-reverse C591 );
L1337: (the carrier of D195) = (the carrier of C591) by L1292;
L1338: (the ToleranceRel of D195) = ( (the ToleranceRel of C591) ` ) by L1292;
L1339: (the ToleranceRel of C591) is_irreflexive_in (the carrier of C591) by L251;
let C592 being set;
assume L1340: C592 in (the carrier of D195);
L1341: (not [ C592 , C592 ] in (the ToleranceRel of C591)) by L1340 , L1337 , L1339 , RELAT_2:def 2;
L1342: [ C592 , C592 ] in [: (the carrier of D195) , (the carrier of D195) :] by L1340 , ZFMISC_1:87;
thus L1343: thesis by L1342 , L1337 , L1338 , L1341 , XBOOLE_0:def 5;
end;
end;
registration
let C593 being  pcs-tol-symmetric pcs-Str;
cluster ( pcs-reverse C593 ) ->  pcs-tol-symmetric;
coherence
proof
set D196 = ( pcs-reverse C593 );
L1345: (the carrier of D196) = (the carrier of C593) by L1292;
L1346: (the ToleranceRel of D196) = ( (the ToleranceRel of C593) ` ) by L1292;
L1347: (the ToleranceRel of C593) is_symmetric_in (the carrier of C593) by L252;
let C594 , C595 being set;
assume that
L1348: C594 in (the carrier of D196)
and
L1349: C595 in (the carrier of D196);
assume L1350: [ C594 , C595 ] in (the ToleranceRel of D196);
L1351: (not [ C594 , C595 ] in (the ToleranceRel of C593)) by L1350 , L1346 , XBOOLE_0:def 5;
L1352: (not [ C595 , C594 ] in (the ToleranceRel of C593)) by L1351 , L1345 , L1347 , L1348 , L1349 , RELAT_2:def 3;
L1353: [ C595 , C594 ] in [: (the carrier of C593) , (the carrier of C593) :] by L1345 , L1348 , L1349 , ZFMISC_1:87;
thus L1354: thesis by L1353 , L1346 , L1352 , XBOOLE_0:def 5;
end;
end;
registration
let C596 being  pcs-compatible pcs-Str;
cluster ( pcs-reverse C596 ) ->  pcs-compatible;
coherence
proof
set D197 = ( pcs-reverse C596 );
L1356: (the carrier of D197) = (the carrier of C596) by L1292;
L1357: (the InternalRel of D197) = ( (the InternalRel of C596) ~ ) by L1292;
L1358: (the ToleranceRel of D197) = ( (the ToleranceRel of C596) ` ) by L1292;
let C597 , C598 , C599 , C600 being (Element of D197);
assume that
L1359: [ C597 , C599 ] in (the ToleranceRel of D197)
and
L1360: [ C598 , C597 ] in (the InternalRel of D197)
and
L1361: [ C600 , C599 ] in (the InternalRel of D197);
L1362: C598 in (the carrier of D197) by L1360 , ZFMISC_1:87;
reconsider D198 = C598 , D199 = C600 , D200 = C597 , D201 = C599 as (Element of C596) by L1292;
L1363: (not [ D200 , D201 ] in (the ToleranceRel of C596)) by L1358 , L1359 , XBOOLE_0:def 5;
L1364: (not D200 (--) D201) by L1363 , L247;
L1365: [ D200 , D198 ] in (the InternalRel of C596) by L1357 , L1360 , RELAT_1:def 7;
L1366: [ D201 , D199 ] in (the InternalRel of C596) by L1357 , L1361 , RELAT_1:def 7;
L1367: D200 <= D198 by L1365 , ORDERS_2:def 5;
L1368: D201 <= D199 by L1366 , ORDERS_2:def 5;
L1369: (not D198 (--) D199) by L1368 , L1364 , L1367 , L480;
L1370: (not [ D198 , D199 ] in (the ToleranceRel of C596)) by L1369 , L247;
L1371: [ C598 , C600 ] in [: (the carrier of C596) , (the carrier of C596) :] by L1356 , L1362 , ZFMISC_1:87;
thus L1372: [ C598 , C600 ] in (the ToleranceRel of D197) by L1371 , L1358 , L1370 , XBOOLE_0:def 5;
end;
end;
definition
let C601 , C602 being pcs-Str;
func C601 pcs-times C602 -> pcs-Str equals 
pcs-Str (# [: (the carrier of C601) , (the carrier of C602) :] , [" (the InternalRel of C601) , (the InternalRel of C602) "] , [^ (the ToleranceRel of C601) , (the ToleranceRel of C602) ^] #);
coherence;
end;
registration
let C603 , C604 being pcs-Str;
cluster ( C603 pcs-times C604 ) ->  strict;
coherence;
end;
registration
let C605 , C606 being non  empty pcs-Str;
cluster ( C605 pcs-times C606 ) -> non  empty;
coherence;
end;
theorem
L1377: (for B315 , B316 being pcs-Str holds (for B317 , B318 being (Element of ( B315 pcs-times B316 )) holds (for B319 , B320 being (Element of B315) holds (for B321 , B322 being (Element of B316) holds ((B317 = [ B319 , B321 ] & B318 = [ B320 , B322 ]) implies (B317 <= B318 iff (B319 <= B320 & B321 <= B322)))))))
proof
let C607 , C608 being pcs-Str;
let C609 , C610 being (Element of ( C607 pcs-times C608 ));
let C611 , C612 being (Element of C607);
let C613 , C614 being (Element of C608);
assume that
L1378: C609 = [ C611 , C613 ]
and
L1379: C610 = [ C612 , C614 ];
thus L1380: (C609 <= C610 implies (C611 <= C612 & C613 <= C614))
proof
assume L1381: C609 <= C610;
L1382: [ C609 , C610 ] in [" (the InternalRel of C607) , (the InternalRel of C608) "] by L1381 , ORDERS_2:def 5;
consider C615 , C616 , C617 , C618 being set such that L1383: C609 = [ C615 , C616 ] and L1384: C610 = [ C617 , C618 ] and L1385: [ C615 , C617 ] in (the InternalRel of C607) and L1386: [ C616 , C618 ] in (the InternalRel of C608) by L1382 , YELLOW_3:def 1;
L1387: C615 = C611 by L1378 , L1383 , XTUPLE_0:1;
L1388: C616 = C613 by L1378 , L1383 , XTUPLE_0:1;
thus L1389: [ C611 , C612 ] in (the InternalRel of C607) by L1379 , L1384 , L1385 , L1387 , XTUPLE_0:1;
thus L1390: [ C613 , C614 ] in (the InternalRel of C608) by L1379 , L1384 , L1386 , L1388 , XTUPLE_0:1;
end;

assume that
L1391: C611 <= C612
and
L1392: C613 <= C614;
L1393: [ C611 , C612 ] in (the InternalRel of C607) by L1391 , ORDERS_2:def 5;
L1394: [ C613 , C614 ] in (the InternalRel of C608) by L1392 , ORDERS_2:def 5;
thus L1395: [ C609 , C610 ] in (the InternalRel of ( C607 pcs-times C608 )) by L1394 , L1378 , L1379 , L1393 , YELLOW_3:def 1;
end;
theorem
L1396: (for B323 , B324 being pcs-Str holds (for B325 , B326 being (Element of ( B323 pcs-times B324 )) holds (for B327 , B328 being (Element of B323) holds (for B329 , B330 being (Element of B324) holds ((B325 = [ B327 , B329 ] & B326 = [ B328 , B330 ]) implies (B325 (--) B326 implies (B327 (--) B328 or B329 (--) B330)))))))
proof
let C619 , C620 being pcs-Str;
let C621 , C622 being (Element of ( C619 pcs-times C620 ));
let C623 , C624 being (Element of C619);
let C625 , C626 being (Element of C620);
assume that
L1397: C621 = [ C623 , C625 ]
and
L1398: C622 = [ C624 , C626 ];
assume L1399: C621 (--) C622;
L1400: [ C621 , C622 ] in [^ (the ToleranceRel of C619) , (the ToleranceRel of C620) ^] by L1399 , L247;
consider C627 , C628 , C629 , C630 being set such that L1401: C621 = [ C627 , C628 ] and L1402: C622 = [ C629 , C630 ] and L1403: C627 in (the carrier of C619) and L1404: C628 in (the carrier of C620) and L1405: C629 in (the carrier of C619) and L1406: C630 in (the carrier of C620) and L1407: ([ C627 , C629 ] in (the ToleranceRel of C619) or [ C628 , C630 ] in (the ToleranceRel of C620)) by L1400 , L49;
L1408: C627 = C623 by L1397 , L1401 , XTUPLE_0:1;
L1409: C628 = C625 by L1397 , L1401 , XTUPLE_0:1;
L1410: C629 = C624 by L1398 , L1402 , XTUPLE_0:1;
L1411: C630 = C626 by L1398 , L1402 , XTUPLE_0:1;
thus L1412: thesis by L1411 , L1407 , L1408 , L1409 , L1410 , L247;
end;
theorem
L1413: (for B331 , B332 being non  empty pcs-Str holds (for B333 , B334 being (Element of ( B331 pcs-times B332 )) holds (for B335 , B336 being (Element of B331) holds (for B337 , B338 being (Element of B332) holds ((B333 = [ B335 , B337 ] & B334 = [ B336 , B338 ]) implies ((B335 (--) B336 or B337 (--) B338) implies B333 (--) B334))))))
proof
let C631 , C632 being non  empty pcs-Str;
let C633 , C634 being (Element of ( C631 pcs-times C632 ));
let C635 , C636 being (Element of C631);
let C637 , C638 being (Element of C632);
assume that
L1414: C633 = [ C635 , C637 ]
and
L1415: C634 = [ C636 , C638 ];
assume L1416: (C635 (--) C636 or C637 (--) C638);
L1417: ([ C635 , C636 ] in (the ToleranceRel of C631) or [ C637 , C638 ] in (the ToleranceRel of C632)) by L1416 , L247;
thus L1418: [ C633 , C634 ] in (the ToleranceRel of ( C631 pcs-times C632 )) by L1417 , L1414 , L1415 , L49;
end;
registration
let C639 , C640 being  reflexive pcs-Str;
cluster ( C639 pcs-times C640 ) ->  reflexive;
coherence
proof
L1419: ( the RelStr of ( C639 pcs-times C640 ) ) = [: C639 , C640 :] by YELLOW_3:def 2;
thus L1420: thesis by L1419 , WAYBEL_8:12;
end;
end;
registration
let C641 , C642 being  transitive pcs-Str;
cluster ( C641 pcs-times C642 ) ->  transitive;
coherence
proof
L1422: ( the RelStr of ( C641 pcs-times C642 ) ) = [: C641 , C642 :] by YELLOW_3:def 2;
thus L1423: thesis by L1422 , WAYBEL_8:13;
end;
end;
registration
let C643 being pcs-Str;
let C644 being  pcs-tol-reflexive pcs-Str;
cluster ( C643 pcs-times C644 ) ->  pcs-tol-reflexive;
coherence
proof
L1425: ( the TolStr of ( C643 pcs-times C644 ) ) = [^ C643 , C644 ^];
thus L1426: thesis by L1425 , L416;
end;
end;
registration
let C645 being  pcs-tol-reflexive pcs-Str;
let C646 being pcs-Str;
cluster ( C645 pcs-times C646 ) ->  pcs-tol-reflexive;
coherence
proof
L1428: ( the TolStr of ( C645 pcs-times C646 ) ) = [^ C645 , C646 ^];
thus L1429: thesis by L1428 , L416;
end;
end;
registration
let C647 , C648 being  pcs-tol-symmetric pcs-Str;
cluster ( C647 pcs-times C648 ) ->  pcs-tol-symmetric;
coherence
proof
L1431: ( the TolStr of ( C647 pcs-times C648 ) ) = [^ C647 , C648 ^];
thus L1432: thesis by L1431 , L426;
end;
end;
registration
let C649 , C650 being  pcs-compatible pcs-Str;
cluster ( C649 pcs-times C650 ) ->  pcs-compatible;
coherence
proof
set D202 = ( C649 pcs-times C650 );
set D203 = (the ToleranceRel of D202);
set D204 = (the carrier of C649);
set D205 = (the carrier of C650);
let C651 , C652 , C653 , C654 being (Element of D202);
assume that
L1434: C651 (--) C653
and
L1435: C652 <= C651
and
L1436: C654 <= C653;
L1437: [ C651 , C653 ] in D203 by L1434 , L247;
consider C655 , C656 , C657 , C658 being set such that L1438: C651 = [ C655 , C656 ] and L1439: C653 = [ C657 , C658 ] and L1440: C655 in D204 and L1441: C656 in D205 and L1442: C657 in D204 and L1443: C658 in D205 and L1444: ([ C655 , C657 ] in (the ToleranceRel of C649) or [ C656 , C658 ] in (the ToleranceRel of C650)) by L1437 , L49;
L1445: [ C652 , C651 ] in (the InternalRel of D202) by L1435 , ORDERS_2:def 5;
L1446: C652 in (the carrier of D202) by L1445 , ZFMISC_1:87;
consider C659 , C660 being set such that L1447: C659 in D204 and L1448: C660 in D205 and L1449: C652 = [ C659 , C660 ] by L1446 , ZFMISC_1:def 2;
L1450: [ C654 , C653 ] in (the InternalRel of D202) by L1436 , ORDERS_2:def 5;
L1451: C654 in (the carrier of D202) by L1450 , ZFMISC_1:87;
consider C661 , C662 being set such that L1452: C661 in D204 and L1453: C662 in D205 and L1454: C654 = [ C661 , C662 ] by L1451 , ZFMISC_1:def 2;
reconsider D206 = C649 , D207 = C650 as non  empty  pcs-compatible pcs-Str by L1440 , L1441;
reconsider D208 = C655 , D209 = C657 , D210 = C659 , D211 = C661 as (Element of D206) by L1440 , L1442 , L1447 , L1452;
reconsider D212 = C656 , D213 = C658 , D214 = C660 , D215 = C662 as (Element of D207) by L1441 , L1443 , L1448 , L1453;
L1455: [^ D208 , D212 ^] (--) [^ D209 , D213 ^] by L1437 , L1438 , L1439 , L247;
L1456: (D208 (--) D209 or D212 (--) D213) by L1455 , L438;
L1457: ( the RelStr of ( D206 pcs-times D207 ) ) = [: D206 , D207 :] by YELLOW_3:def 2;
L1458: [ D210 , D214 ] <= [ D208 , D212 ] by L1457 , L1438 , L1445 , L1449 , ORDERS_2:def 5;
L1459: D210 <= D208 by L1458 , YELLOW_3:11;
L1460: D214 <= D212 by L1458 , YELLOW_3:11;
L1461: [ D211 , D215 ] <= [ D209 , D213 ] by L1439 , L1450 , L1454 , L1457 , ORDERS_2:def 5;
L1462: D211 <= D209 by L1461 , YELLOW_3:11;
L1463: D215 <= D213 by L1461 , YELLOW_3:11;
L1464: (D210 (--) D211 or D214 (--) D215) by L1463 , L1456 , L1459 , L1460 , L1462 , L480;
L1465: ([ D210 , D211 ] in (the ToleranceRel of D206) or [ D214 , D215 ] in (the ToleranceRel of D207)) by L1464 , L247;
L1466: C652 = [ D210 , D214 ] by L1449;
L1467: C654 = [ D211 , D215 ] by L1454;
thus L1468: [ C652 , C654 ] in D203 by L1467 , L1465 , L1466 , L66;
end;
end;
definition
let C663 , C664 being pcs-Str;
func C663 --> C664 -> pcs-Str equals 
( ( pcs-reverse C663 ) pcs-times C664 );
coherence;
end;
registration
let C665 , C666 being pcs-Str;
cluster ( C665 --> C666 ) ->  strict;
coherence;
end;
registration
let C667 , C668 being non  empty pcs-Str;
cluster ( C667 --> C668 ) -> non  empty;
coherence;
end;
theorem
L1473: (for B339 , B340 being pcs-Str holds (for B341 , B342 being (Element of ( B339 --> B340 )) holds (for B343 , B344 being (Element of B339) holds (for B345 , B346 being (Element of B340) holds ((B341 = [ B343 , B345 ] & B342 = [ B344 , B346 ]) implies (B341 <= B342 iff (B344 <= B343 & B345 <= B346)))))))
proof
let C669 , C670 being pcs-Str;
let C671 , C672 being (Element of ( C669 --> C670 ));
let C673 , C674 being (Element of C669);
let C675 , C676 being (Element of C670);
assume that
L1474: C671 = [ C673 , C675 ]
and
L1475: C672 = [ C674 , C676 ];
reconsider D216 = C673 , D217 = C674 as (Element of ( pcs-reverse C669 )) by L1292;
thus L1476: (C671 <= C672 implies (C674 <= C673 & C675 <= C676))
proof
assume L1477: C671 <= C672;
L1478: [ C671 , C672 ] in [" (the InternalRel of ( pcs-reverse C669 )) , (the InternalRel of C670) "] by L1477 , ORDERS_2:def 5;
consider C677 , C678 , C679 , C680 being set such that L1479: C671 = [ C677 , C678 ] and L1480: C672 = [ C679 , C680 ] and L1481: [ C677 , C679 ] in (the InternalRel of ( pcs-reverse C669 )) and L1482: [ C678 , C680 ] in (the InternalRel of C670) by L1478 , YELLOW_3:def 1;
L1483: C677 = C673 by L1474 , L1479 , XTUPLE_0:1;
L1484: C678 = C675 by L1474 , L1479 , XTUPLE_0:1;
L1485: C679 = C674 by L1475 , L1480 , XTUPLE_0:1;
L1486: D216 <= D217 by L1485 , L1481 , L1483 , ORDERS_2:def 5;
thus L1487: C674 <= C673 by L1486 , L1298;
thus L1488: [ C675 , C676 ] in (the InternalRel of C670) by L1475 , L1480 , L1482 , L1484 , XTUPLE_0:1;
end;

assume that
L1489: C674 <= C673
and
L1490: C675 <= C676;
L1491: D216 <= D217 by L1489 , L1298;
L1492: [ D216 , D217 ] in (the InternalRel of ( pcs-reverse C669 )) by L1491 , ORDERS_2:def 5;
L1493: [ C675 , C676 ] in (the InternalRel of C670) by L1490 , ORDERS_2:def 5;
thus L1494: [ C671 , C672 ] in (the InternalRel of ( C669 --> C670 )) by L1493 , L1474 , L1475 , L1492 , YELLOW_3:def 1;
end;
theorem
L1495: (for B347 , B348 being pcs-Str holds (for B349 , B350 being (Element of ( B347 --> B348 )) holds (for B351 , B352 being (Element of B347) holds (for B353 , B354 being (Element of B348) holds ((B349 = [ B351 , B353 ] & B350 = [ B352 , B354 ]) implies (B349 (--) B350 implies ((not B351 (--) B352) or B353 (--) B354)))))))
proof
let C681 , C682 being pcs-Str;
let C683 , C684 being (Element of ( C681 --> C682 ));
let C685 , C686 being (Element of C681);
let C687 , C688 being (Element of C682);
assume that
L1496: C683 = [ C685 , C687 ]
and
L1497: C684 = [ C686 , C688 ];
reconsider D218 = C685 , D219 = C686 as (Element of ( pcs-reverse C681 )) by L1292;
assume L1498: [ C683 , C684 ] in (the ToleranceRel of ( C681 --> C682 ));
consider C689 , C690 , C691 , C692 being set such that L1499: C683 = [ C689 , C690 ] and L1500: C684 = [ C691 , C692 ] and L1501: C689 in (the carrier of ( pcs-reverse C681 )) and L1502: C690 in (the carrier of C682) and L1503: C691 in (the carrier of ( pcs-reverse C681 )) and L1504: C692 in (the carrier of C682) and L1505: ([ C689 , C691 ] in (the ToleranceRel of ( pcs-reverse C681 )) or [ C690 , C692 ] in (the ToleranceRel of C682)) by L1498 , L49;
L1506: C689 = C685 by L1496 , L1499 , XTUPLE_0:1;
L1507: C690 = C687 by L1496 , L1499 , XTUPLE_0:1;
L1508: C691 = C686 by L1497 , L1500 , XTUPLE_0:1;
L1509: C692 = C688 by L1497 , L1500 , XTUPLE_0:1;
L1510: (D218 (--) D219 or C687 (--) C688) by L1509 , L1505 , L1506 , L1507 , L1508 , L247;
thus L1511: thesis by L1510 , L1307;
end;
theorem
L1512: (for B355 , B356 being non  empty pcs-Str holds (for B357 , B358 being (Element of ( B355 --> B356 )) holds (for B359 , B360 being (Element of B355) holds (for B361 , B362 being (Element of B356) holds ((B357 = [ B359 , B361 ] & B358 = [ B360 , B362 ]) implies (((not B359 (--) B360) or B361 (--) B362) implies B357 (--) B358))))))
proof
let C693 , C694 being non  empty pcs-Str;
let C695 , C696 being (Element of ( C693 --> C694 ));
let C697 , C698 being (Element of C693);
let C699 , C700 being (Element of C694);
assume that
L1513: C695 = [ C697 , C699 ]
and
L1514: C696 = [ C698 , C700 ];
reconsider D220 = C697 , D221 = C698 as (Element of ( pcs-reverse C693 )) by L1292;
reconsider D222 = [ D220 , C699 ] , D223 = [ D221 , C700 ] as (Element of ( ( pcs-reverse C693 ) pcs-times C694 )) by L1513 , L1514;
assume L1515: ((not C697 (--) C698) or C699 (--) C700);
L1516: (D220 (--) D221 or C699 (--) C700) by L1515 , L1313;
L1517: D222 (--) D223 by L1516 , L1413;
thus L1518: thesis by L1517 , L1513 , L1514;
end;
registration
let C701 , C702 being  reflexive pcs-Str;
cluster ( C701 --> C702 ) ->  reflexive;
coherence;
end;
registration
let C703 , C704 being  transitive pcs-Str;
cluster ( C703 --> C704 ) ->  transitive;
coherence;
end;
registration
let C705 being pcs-Str;
let C706 being  pcs-tol-reflexive pcs-Str;
cluster ( C705 --> C706 ) ->  pcs-tol-reflexive;
coherence;
end;
registration
let C707 being  pcs-tol-irreflexive pcs-Str;
let C708 being pcs-Str;
cluster ( C707 --> C708 ) ->  pcs-tol-reflexive;
coherence;
end;
registration
let C709 , C710 being  pcs-tol-symmetric pcs-Str;
cluster ( C709 --> C710 ) ->  pcs-tol-symmetric;
coherence;
end;
registration
let C711 , C712 being  pcs-compatible pcs-Str;
cluster ( C711 --> C712 ) ->  pcs-compatible;
coherence;
end;
registration
let C713 , C714 being pcs;
cluster ( C713 --> C714 ) ->  pcs-like;
coherence;
end;
definition
let C715 being TolStr;
let C716 being (Subset of C715);
attr C716 is  pcs-self-coherent
means
:L1526: (for B363 , B364 being (Element of C715) holds ((B363 in C716 & B364 in C716) implies B363 (--) B364));
end;
registration
let C717 being TolStr;
cluster  empty ->  pcs-self-coherent for (Subset of C717);
coherence
proof
let C718 being (Subset of C717);
assume L1528: C718 is  empty;
let C719 being (Element of C717);
thus L1529: thesis by L1528;
end;
end;
definition
let C720 being TolStr;
let C721 being (Subset-Family of C720);
attr C721 is  pcs-self-coherent-membered
means
:L1531: (for B365 being (Subset of C720) holds (B365 in C721 implies B365 is  pcs-self-coherent));
end;
registration
let C722 being TolStr;
cluster non  empty  pcs-self-coherent-membered for (Subset-Family of C722);
existence
proof
reconsider D224 = { ( {} ) } as (Subset-Family of C722) by SETFAM_1:46;
take D224;
thus L1533: D224 is non  empty;
let C723 being (Subset of C722);
assume L1534: C723 in D224;
L1535: C723 = ( {} C722 ) by L1534 , TARSKI:def 1;
thus L1536: thesis by L1535;
end;
end;
definition
let C724 being RelStr;
let C725 being set;
defpred S4[ set , set ] means ($1 in C725 & $2 in C725 & (for B366 being set holds (B366 in $1 implies (ex B367 being set st (B367 in $2 & [ B366 , B367 ] in (the InternalRel of C724))))));
func pcs-general-power-IR (C724 , C725) -> (Relation of C725) means 
:L1538: (for B368 , B369 being set holds ([ B368 , B369 ] in it iff (B368 in C725 & B369 in C725 & (for B370 being set holds (B370 in B368 implies (ex B371 being set st (B371 in B369 & [ B370 , B371 ] in (the InternalRel of C724))))))));
existence
proof
consider C726 being (Relation of C725) such that L1539: (for B372 , B373 being set holds ([ B372 , B373 ] in C726 iff (B372 in C725 & B373 in C725 & S4[ B372 , B373 ]))) from RELSET_1:sch 1;
take C726;
thus L1540: thesis by L1539;
end;
uniqueness
proof
let C727 , C728 being (Relation of C725);
assume that
L1541: (for B374 , B375 being set holds ([ B374 , B375 ] in C727 iff (B374 in C725 & B375 in C725 & (for B376 being set holds (B376 in B374 implies (ex B377 being set st (B377 in B375 & [ B376 , B377 ] in (the InternalRel of C724))))))))
and
L1542: (for B378 , B379 being set holds ([ B378 , B379 ] in C728 iff (B378 in C725 & B379 in C725 & (for B380 being set holds (B380 in B378 implies (ex B381 being set st (B381 in B379 & [ B380 , B381 ] in (the InternalRel of C724))))))));
L1543: (for B382 , B383 being set holds ([ B382 , B383 ] in C727 iff S4[ B382 , B383 ])) by L1541;
L1544: (for B384 , B385 being set holds ([ B384 , B385 ] in C728 iff S4[ B384 , B385 ])) by L1542;
thus L1545: C727 = C728 from RELAT_1:sch 2(L1543 , L1544);
end;
end;
definition
let C729 being TolStr;
let C730 being set;
defpred S5[ set , set ] means ($1 in C730 & $2 in C730 & (for B386 , B387 being set holds ((B386 in $1 & B387 in $2) implies [ B386 , B387 ] in (the ToleranceRel of C729))));
func pcs-general-power-TR (C729 , C730) -> (Relation of C730) means 
:L1547: (for B388 , B389 being set holds ([ B388 , B389 ] in it iff (B388 in C730 & B389 in C730 & (for B390 , B391 being set holds ((B390 in B388 & B391 in B389) implies [ B390 , B391 ] in (the ToleranceRel of C729))))));
existence
proof
consider C731 being (Relation of C730) such that L1548: (for B392 , B393 being set holds ([ B392 , B393 ] in C731 iff (B392 in C730 & B393 in C730 & S5[ B392 , B393 ]))) from RELSET_1:sch 1;
take C731;
thus L1549: thesis by L1548;
end;
uniqueness
proof
let C732 , C733 being (Relation of C730);
assume that
L1550: (for B394 , B395 being set holds ([ B394 , B395 ] in C732 iff (B394 in C730 & B395 in C730 & (for B396 , B397 being set holds ((B396 in B394 & B397 in B395) implies [ B396 , B397 ] in (the ToleranceRel of C729))))))
and
L1551: (for B398 , B399 being set holds ([ B398 , B399 ] in C733 iff (B398 in C730 & B399 in C730 & (for B400 , B401 being set holds ((B400 in B398 & B401 in B399) implies [ B400 , B401 ] in (the ToleranceRel of C729))))));
L1552: (for B402 , B403 being set holds ([ B402 , B403 ] in C732 iff S5[ B402 , B403 ])) by L1550;
L1553: (for B404 , B405 being set holds ([ B404 , B405 ] in C733 iff S5[ B404 , B405 ])) by L1551;
thus L1554: C732 = C733 from RELAT_1:sch 2(L1552 , L1553);
end;
end;
theorem
L1556: (for B406 being RelStr holds (for B407 being (Subset-Family of B406) holds (for B408 , B409 being set holds ([ B408 , B409 ] in ( pcs-general-power-IR (B406 , B407) ) iff (B408 in B407 & B409 in B407 & (for B410 being (Element of B406) holds (B410 in B408 implies (ex B411 being (Element of B406) st (B411 in B409 & B410 <= B411)))))))))
proof
let C734 being RelStr;
let C735 being (Subset-Family of C734);
let C736 , C737 being set;
thus L1557: ([ C736 , C737 ] in ( pcs-general-power-IR (C734 , C735) ) implies (C736 in C735 & C737 in C735 & (for B412 being (Element of C734) holds (B412 in C736 implies (ex B413 being (Element of C734) st (B413 in C737 & B412 <= B413))))))
proof
assume L1558: [ C736 , C737 ] in ( pcs-general-power-IR (C734 , C735) );
thus L1559: (C736 in C735 & C737 in C735) by L1558 , L1538;
let C738 being (Element of C734);
assume L1560: C738 in C736;
consider C739 being set such that L1561: C739 in C737 and L1562: [ C738 , C739 ] in (the InternalRel of C734) by L1560 , L1558 , L1538;
reconsider D225 = C739 as (Element of C734) by L1559 , L1561;
take D225;
thus L1563: thesis by L1561 , L1562 , ORDERS_2:def 5;
end;

assume that
L1564: C736 in C735
and
L1565: C737 in C735
and
L1566: (for B414 being (Element of C734) holds (B414 in C736 implies (ex B415 being (Element of C734) st (B415 in C737 & B414 <= B415))));
L1567: (for B416 being set holds (B416 in C736 implies (ex B417 being set st (B417 in C737 & [ B416 , B417 ] in (the InternalRel of C734)))))
proof
let C740 being set;
assume L1568: C740 in C736;
reconsider D226 = C740 as (Element of C734) by L1568 , L1564;
consider C741 being (Element of C734) such that L1569: C741 in C737 and L1570: D226 <= C741 by L1566 , L1568;
take C741;
thus L1571: thesis by L1569 , L1570 , ORDERS_2:def 5;
end;
thus L1572: thesis by L1567 , L1564 , L1565 , L1538;
end;
theorem
L1573: (for B418 being TolStr holds (for B419 being (Subset-Family of B418) holds (for B420 , B421 being set holds ([ B420 , B421 ] in ( pcs-general-power-TR (B418 , B419) ) iff (B420 in B419 & B421 in B419 & (for B422 , B423 being (Element of B418) holds ((B422 in B420 & B423 in B421) implies B422 (--) B423)))))))
proof
let C742 being TolStr;
let C743 being (Subset-Family of C742);
let C744 , C745 being set;
thus L1574: ([ C744 , C745 ] in ( pcs-general-power-TR (C742 , C743) ) implies (C744 in C743 & C745 in C743 & (for B424 , B425 being (Element of C742) holds ((B424 in C744 & B425 in C745) implies B424 (--) B425))))
proof
assume L1575: [ C744 , C745 ] in ( pcs-general-power-TR (C742 , C743) );
thus L1576: (C744 in C743 & C745 in C743) by L1575 , L1547;
let C746 , C747 being (Element of C742);
assume that
L1577: C746 in C744
and
L1578: C747 in C745;
L1579: [ C746 , C747 ] in (the ToleranceRel of C742) by L1575 , L1577 , L1578 , L1547;
thus L1580: thesis by L1579 , L247;
end;

assume that
L1581: C744 in C743
and
L1582: C745 in C743
and
L1583: (for B426 , B427 being (Element of C742) holds ((B426 in C744 & B427 in C745) implies B426 (--) B427));
L1584: (for B428 , B429 being set holds ((B428 in C744 & B429 in C745) implies [ B428 , B429 ] in (the ToleranceRel of C742)))
proof
let C748 , C749 being set;
assume that
L1585: C748 in C744
and
L1586: C749 in C745;
reconsider D227 = C748 , D228 = C749 as (Element of C742) by L1581 , L1582 , L1585 , L1586;
L1587: D227 (--) D228 by L1583 , L1585 , L1586;
thus L1588: thesis by L1587 , L247;
end;
thus L1589: thesis by L1584 , L1581 , L1582 , L1547;
end;
definition
let C750 being pcs-Str;
let C751 being set;
func pcs-general-power (C750 , C751) -> pcs-Str equals 
pcs-Str (# C751 , ( pcs-general-power-IR (C750 , C751) ) , ( pcs-general-power-TR (C750 , C751) ) #);
coherence;
end;
notation
let C752 being pcs-Str;
let C753 being (Subset-Family of C752);
synonym pcs-general-power C753 for pcs-general-power (C752 , C753);
end;
registration
let C754 being pcs-Str;
let C755 being non  empty set;
cluster ( pcs-general-power (C754 , C755) ) -> non  empty;
coherence;
end;
theorem
L1593: (for B430 being pcs-Str holds (for B431 being set holds (for B432 , B433 being (Element of ( pcs-general-power (B430 , B431) )) holds (B432 <= B433 implies (for B434 being (Element of B430) holds (B434 in B432 implies (ex B435 being (Element of B430) st (B435 in B433 & B434 <= B435))))))))
proof
let C756 being pcs-Str;
let C757 being set;
set D229 = ( pcs-general-power (C756 , C757) );
let C758 , C759 being (Element of D229);
assume L1594: [ C758 , C759 ] in (the InternalRel of D229);
let C760 being (Element of C756);
assume L1595: C760 in C758;
consider C761 being set such that L1596: C761 in C759 and L1597: [ C760 , C761 ] in (the InternalRel of C756) by L1595 , L1594 , L1538;
reconsider D230 = C761 as (Element of C756) by L1597 , ZFMISC_1:87;
take D230;
thus L1598: (D230 in C759 & [ C760 , D230 ] in (the InternalRel of C756)) by L1596 , L1597;
end;
theorem
L1599: (for B436 being pcs-Str holds (for B437 being non  empty (Subset-Family of B436) holds (for B438 , B439 being (Element of ( pcs-general-power B437 )) holds ((for B440 being (Element of B436) holds (B440 in B438 implies (ex B441 being (Element of B436) st (B441 in B439 & B440 <= B441)))) implies B438 <= B439))))
proof
let C762 being pcs-Str;
let C763 being non  empty (Subset-Family of C762);
set D231 = ( pcs-general-power C763 );
let C764 , C765 being (Element of D231);
assume L1600: (for B442 being (Element of C762) holds (B442 in C764 implies (ex B443 being (Element of C762) st (B443 in C765 & B442 <= B443))));
L1601: C764 in C763;
L1602: (for B444 being set holds (B444 in C764 implies (ex B445 being set st (B445 in C765 & [ B444 , B445 ] in (the InternalRel of C762)))))
proof
let C766 being set;
assume L1603: C766 in C764;
reconsider D232 = C766 as (Element of C762) by L1603 , L1601;
consider C767 being (Element of C762) such that L1604: C767 in C765 and L1605: D232 <= C767 by L1600 , L1603;
take C767;
thus L1606: thesis by L1604 , L1605 , ORDERS_2:def 5;
end;
thus L1607: [ C764 , C765 ] in (the InternalRel of D231) by L1602 , L1538;
end;
theorem
L1608: (for B446 being pcs-Str holds (for B447 being set holds (for B448 , B449 being (Element of ( pcs-general-power (B446 , B447) )) holds (B448 (--) B449 implies (for B450 , B451 being (Element of B446) holds ((B450 in B448 & B451 in B449) implies B450 (--) B451))))))
proof
let C768 being pcs-Str;
let C769 being set;
set D233 = ( pcs-general-power (C768 , C769) );
let C770 , C771 being (Element of D233);
assume L1609: [ C770 , C771 ] in (the ToleranceRel of D233);
let C772 , C773 being (Element of C768);
assume that
L1610: C772 in C770
and
L1611: C773 in C771;
thus L1612: [ C772 , C773 ] in (the ToleranceRel of C768) by L1609 , L1610 , L1611 , L1547;
end;
theorem
L1613: (for B452 being pcs-Str holds (for B453 being non  empty (Subset-Family of B452) holds (for B454 , B455 being (Element of ( pcs-general-power B453 )) holds ((for B456 , B457 being (Element of B452) holds ((B456 in B454 & B457 in B455) implies B456 (--) B457)) implies B454 (--) B455))))
proof
let C774 being pcs-Str;
let C775 being non  empty (Subset-Family of C774);
set D234 = ( pcs-general-power C775 );
let C776 , C777 being (Element of D234);
assume L1614: (for B458 , B459 being (Element of C774) holds ((B458 in C776 & B459 in C777) implies B458 (--) B459));
L1615: C776 in C775;
L1616: C777 in C775;
L1617:
now
let C778 , C779 being set;
assume that
L1618: C778 in C776
and
L1619: C779 in C777;
reconsider D235 = C778 , D236 = C779 as (Element of C774) by L1615 , L1616 , L1618 , L1619;
L1620: D235 (--) D236 by L1614 , L1618 , L1619;
thus L1621: [ C778 , C779 ] in (the ToleranceRel of C774) by L1620 , L247;
end;
thus L1622: [ C776 , C777 ] in (the ToleranceRel of D234) by L1617 , L1547;
end;
registration
let C780 being pcs-Str;
let C781 being set;
cluster ( pcs-general-power (C780 , C781) ) ->  strict;
coherence;
end;
registration
let C782 being  reflexive pcs-Str;
let C783 being (Subset-Family of C782);
cluster ( pcs-general-power C783 ) ->  reflexive;
coherence
proof
set D237 = ( pcs-general-power C783 );
let C784 being set;
assume L1624: C784 in (the carrier of D237);
L1625: (for B460 being set holds (B460 in C784 implies (ex B461 being set st (B461 in C784 & [ B460 , B461 ] in (the InternalRel of C782)))))
proof
let C785 being set;
assume that
L1626: C785 in C784;
take C785;
thus L1627: C785 in C784 by L1626;
L1628: ( field (the InternalRel of C782) ) = (the carrier of C782) by ORDERS_1:12;
L1629: (the InternalRel of C782) is_reflexive_in (the carrier of C782) by L1628 , RELAT_2:def 9;
thus L1630: thesis by L1629 , L1624 , L1626 , RELAT_2:def 1;
end;
thus L1631: thesis by L1625 , L1624 , L1538;
end;
end;
registration
let C786 being  transitive pcs-Str;
let C787 being set;
cluster ( pcs-general-power (C786 , C787) ) ->  transitive;
coherence
proof
set D238 = ( pcs-general-power (C786 , C787) );
set D239 = (the InternalRel of D238);
let C788 , C789 , C790 being set;
assume that
L1633: C788 in (the carrier of D238)
and
L1634: C789 in (the carrier of D238)
and
L1635: C790 in (the carrier of D238)
and
L1636: [ C788 , C789 ] in D239
and
L1637: [ C789 , C790 ] in D239;
L1638: (for B462 being set holds (B462 in C788 implies (ex B463 being set st (B463 in C790 & [ B462 , B463 ] in (the InternalRel of C786)))))
proof
let C791 being set;
assume L1639: C791 in C788;
consider C792 being set such that L1640: C792 in C789 and L1641: [ C791 , C792 ] in (the InternalRel of C786) by L1639 , L1636 , L1538;
consider C793 being set such that L1642: C793 in C790 and L1643: [ C792 , C793 ] in (the InternalRel of C786) by L1637 , L1640 , L1538;
take C793;
thus L1644: C793 in C790 by L1642;
L1645: (the InternalRel of C786) is_transitive_in (the carrier of C786) by ORDERS_2:def 3;
L1646: C791 in (the carrier of C786) by L1641 , ZFMISC_1:87;
L1647: C792 in (the carrier of C786) by L1641 , ZFMISC_1:87;
L1648: C793 in (the carrier of C786) by L1643 , ZFMISC_1:87;
thus L1649: thesis by L1648 , L1641 , L1643 , L1645 , L1646 , L1647 , RELAT_2:def 8;
end;
thus L1650: thesis by L1638 , L1633 , L1635 , L1538;
end;
end;
registration
let C794 being  pcs-tol-reflexive pcs-Str;
let C795 being  pcs-self-coherent-membered (Subset-Family of C794);
cluster ( pcs-general-power C795 ) ->  pcs-tol-reflexive;
coherence
proof
let C796 being set;
assume L1652: C796 in (the carrier of ( pcs-general-power C795 ));
reconsider D240 = C796 as (Subset of C794) by L1652;
L1653: D240 is  pcs-self-coherent by L1652 , L1531;
L1654:
now
let C797 , C798 being set;
assume that
L1655: C797 in D240
and
L1656: C798 in D240;
reconsider D241 = C797 , D242 = C798 as (Element of C794) by L1655 , L1656;
L1657: D241 (--) D242 by L1653 , L1655 , L1656 , L1526;
thus L1658: [ C797 , C798 ] in (the ToleranceRel of C794) by L1657 , L247;
end;
thus L1659: thesis by L1654 , L1652 , L1547;
end;
end;
registration
let C799 being  pcs-tol-symmetric pcs-Str;
let C800 being (Subset-Family of C799);
cluster ( pcs-general-power C800 ) ->  pcs-tol-symmetric;
coherence
proof
set D243 = ( pcs-general-power C800 );
let C801 , C802 being set;
assume L1661: C801 in (the carrier of D243);
assume L1662: C802 in (the carrier of D243);
assume L1663: [ C801 , C802 ] in (the ToleranceRel of D243);
L1664:
now
let C803 , C804 being set;
assume that
L1665: C803 in C802
and
L1666: C804 in C801;
reconsider D244 = C803 , D245 = C804 as (Element of C799) by L1661 , L1662 , L1665 , L1666;
L1667: [ C804 , C803 ] in (the ToleranceRel of C799) by L1663 , L1665 , L1666 , L1547;
L1668: D245 (--) D244 by L1667 , L247;
thus L1669: [ C803 , C804 ] in (the ToleranceRel of C799) by L1668 , L247;
end;
thus L1670: thesis by L1664 , L1661 , L1662 , L1547;
end;
end;
registration
let C805 being  pcs-compatible pcs-Str;
let C806 being (Subset-Family of C805);
cluster ( pcs-general-power C806 ) ->  pcs-compatible;
coherence
proof
set D246 = ( pcs-general-power C806 );
let C807 , C808 , C809 , C810 being (Element of D246);
assume that
L1672: C807 (--) C809
and
L1673: C808 <= C807
and
L1674: C810 <= C809;
L1675: [ C808 , C807 ] in (the InternalRel of D246) by L1673 , ORDERS_2:def 5;
L1676: [ C810 , C809 ] in (the InternalRel of D246) by L1674 , ORDERS_2:def 5;
L1677: C808 in (the carrier of D246) by L1675 , ZFMISC_1:87;
L1678: C810 in (the carrier of D246) by L1676 , ZFMISC_1:87;
L1679:
now
let C811 , C812 being set;
assume that
L1680: C811 in C808
and
L1681: C812 in C810;
reconsider D247 = C811 , D248 = C812 as (Element of C805) by L1677 , L1678 , L1680 , L1681;
consider C813 being (Element of C805) such that L1682: C813 in C807 and L1683: D247 <= C813 by L1673 , L1680 , L1593;
consider C814 being (Element of C805) such that L1684: C814 in C809 and L1685: D248 <= C814 by L1674 , L1681 , L1593;
L1686: C813 (--) C814 by L1672 , L1682 , L1684 , L1608;
L1687: D247 (--) D248 by L1686 , L1683 , L1685 , L480;
thus L1688: [ C811 , C812 ] in (the ToleranceRel of C805) by L1687 , L247;
end;
thus L1689: [ C808 , C810 ] in (the ToleranceRel of D246) by L1679 , L1677 , L1547;
end;
end;
definition
let C815 being pcs-Str;
func pcs-coherent-power C815 -> set equals 
{ B464 where B464 is (Subset of C815) : B464 is  pcs-self-coherent };
coherence;
end;
registration
let C816 being pcs-Str;
cluster  pcs-self-coherent for (Subset of C816);
existence
proof
take ( {} C816 );
thus L1692: thesis;
end;
end;
theorem
L1694: (for B465 being pcs-Str holds (for B466 being set holds (B466 in ( pcs-coherent-power B465 ) implies B466 is  pcs-self-coherent  pcs-self-coherent  pcs-self-coherent  pcs-self-coherent (Subset of B465))))
proof
let C817 being pcs-Str;
let C818 being set;
assume L1695: C818 in ( pcs-coherent-power C817 );
L1696: (ex B467 being (Subset of C817) st (C818 = B467 & B467 is  pcs-self-coherent)) by L1695;
thus L1697: thesis by L1696;
end;
registration
let C819 being pcs-Str;
cluster ( pcs-coherent-power C819 ) -> non  empty;
coherence
proof
L1698: ( {} C819 ) in ( pcs-coherent-power C819 );
thus L1699: thesis by L1698;
end;
end;
definition
let C820 being pcs-Str;
redefine func pcs-coherent-power C820 -> (Subset-Family of C820);

coherence
proof
L1701: ( pcs-coherent-power C820 ) c= ( bool (the carrier of C820) )
proof
let C821 being set;
assume L1702: C821 in ( pcs-coherent-power C820 );
L1703: C821 is (Subset of C820) by L1702 , L1694;
thus L1704: thesis by L1703;
end;
thus L1705: thesis by L1701;
end;
end;
registration
let C822 being pcs-Str;
cluster ( pcs-coherent-power C822 ) ->  pcs-self-coherent-membered for (Subset-Family of C822);
coherence
proof
L1707: ( pcs-coherent-power C822 ) is  pcs-self-coherent-membered
proof
let C823 being (Subset of C822);
thus L1708: thesis by L1694;
end;
thus L1709: thesis by L1707;
end;
end;
definition
let C824 being pcs-Str;
func pcs-power C824 -> pcs-Str equals 
( pcs-general-power ( pcs-coherent-power C824 ) );
coherence;
end;
registration
let C825 being pcs-Str;
cluster ( pcs-power C825 ) ->  strict;
coherence;
end;
registration
let C826 being pcs-Str;
cluster ( pcs-power C826 ) -> non  empty;
coherence;
end;
registration
let C827 being  reflexive pcs-Str;
cluster ( pcs-power C827 ) ->  reflexive;
coherence;
end;
registration
let C828 being  transitive pcs-Str;
cluster ( pcs-power C828 ) ->  transitive;
coherence;
end;
registration
let C829 being  pcs-tol-reflexive pcs-Str;
cluster ( pcs-power C829 ) ->  pcs-tol-reflexive;
coherence;
end;
registration
let C830 being  pcs-tol-symmetric pcs-Str;
cluster ( pcs-power C830 ) ->  pcs-tol-symmetric;
coherence;
end;
registration
let C831 being  pcs-compatible pcs-Str;
cluster ( pcs-power C831 ) ->  pcs-compatible;
coherence;
end;
registration
let C832 being pcs;
cluster ( pcs-power C832 ) ->  pcs-like;
coherence;
end;
