:: Order Sorted Algebras
::  by Josef Urban
::
:: Received September 19, 2002
:: Copyright (c) 2002-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies PBOOLE, FINSEQ_1, RELAT_1, TARSKI, XBOOLE_0, MSUALG_1, SUBSET_1,
      STRUCT_0, EQREL_1, FUNCT_1, ORDERS_2, ORDERS_1, RELAT_2, NATTRA_1,
      MARGREL1, XXREAL_0, SEQM_3, CARD_5, CARD_LAR, FUNCOP_1, CARD_3, SETFAM_1,
      OSALG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, RELAT_2, FUNCT_1, RELSET_1,
      ORDERS_1, FUNCT_2, EQREL_1, SETFAM_1, PARTFUN1, FINSEQ_1, FUNCOP_1,
      FINSEQ_2, CARD_3, PBOOLE, ORDERS_2, STRUCT_0, MSUALG_1, ORDERS_3;
 constructors EQREL_1, ORDERS_3, RELSET_1, MSAFREE;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELSET_1, PARTFUN1, EQREL_1,
      STRUCT_0, MSUALG_1, ORDERS_3, ORDINAL1, RELAT_1, PBOOLE, FINSEQ_1;
 requirements BOOLE, SUBSET;
 definitions TARSKI;
 theorems FUNCT_1, PARTFUN1, FINSEQ_1, FUNCOP_1, PBOOLE, FUNCT_2, CARD_3,
      FINSEQ_3, FINSEQ_2, RELAT_1, RELSET_1, EQREL_1, ZFMISC_1, ORDERS_3,
      MSUALG_1, ORDERS_2, RELAT_2, GRFUNC_1, FUNCT_4, ORDERS_1, XTUPLE_0;
 schemes FUNCT_1;

begin
registration
let C1 being set;
let C2 being (ManySortedSet of C1);
let C3 being (FinSequence of C1);
cluster ( C2 * C3 ) ->  FinSequence-like;
coherence
proof
L1: ( rng C3 ) c= C1;
L2: ( rng C3 ) c= ( dom C2 ) by L1 , PARTFUN1:def 2;
L3: ( dom ( C2 * C3 ) ) = ( dom C3 ) by L2 , RELAT_1:27
.= ( Seg ( len C3 ) ) by FINSEQ_1:def 3;
thus L4: thesis by L3 , FINSEQ_1:def 2;
end;
end;
L6: (for B1 being set holds (for B2 being (ManySortedSet of B1) holds (for B3 being (FinSequence of B1) holds (( dom ( B2 * B3 ) ) = ( dom B3 ) & ( len ( B2 * B3 ) ) = ( len B3 )))))
proof
let C4 being set;
let C5 being (ManySortedSet of C4);
let C6 being (FinSequence of C4);
reconsider D1 = ( C5 * C6 ) as FinSequence;
L7: ( rng C6 ) c= C4;
L8: ( rng C6 ) c= ( dom C5 ) by L7 , PARTFUN1:def 2;
L9: ( len D1 ) = ( len C6 ) by L8 , FINSEQ_2:29;
thus L10: thesis by L9 , FINSEQ_3:29;
end;
definition
let C7 being non  empty ManySortedSign;
mode SortSymbol of C7
 is (Element of C7);
end;
definition
let C8 being non  empty ManySortedSign;
mode OperSymbol of C8
 is (Element of (the carrier' of C8));
end;
definition
struct (ManySortedSign) OverloadedMSSign(# carrier -> set , carrier' -> set , Overloading -> (Equivalence_Relation of the carrier') , Arity -> (Function of the carrier' , ( the carrier * )) , ResultSort -> (Function of the carrier' , the carrier) #);
end;
definition
struct (ManySortedSign , RelStr) RelSortedSign(# carrier -> set , InternalRel -> (Relation of the carrier) , carrier' -> set , Arity -> (Function of the carrier' , ( the carrier * )) , ResultSort -> (Function of the carrier' , the carrier) #);
end;
definition
struct (OverloadedMSSign , RelSortedSign) OverloadedRSSign(# carrier -> set , InternalRel -> (Relation of the carrier) , carrier' -> set , Overloading -> (Equivalence_Relation of the carrier') , Arity -> (Function of the carrier' , ( the carrier * )) , ResultSort -> (Function of the carrier' , the carrier) #);
end;
theorem
L16: (for R1 being non  empty set holds (for R2 being non  empty set holds (for R3 being (Order of R1) holds (for R4 being (Equivalence_Relation of R2) holds (for R5 being (Function of R2 , ( R1 * )) holds (for R6 being (Function of R2 , R1) holds OverloadedRSSign (# R1 , R3 , R2 , R4 , R5 , R6 #) is non  empty non  void  reflexive  transitive  antisymmetric))))))
proof
let R1 being non  empty set;
let R2 being non  empty set;
let R3 being (Order of R1);
let R4 being (Equivalence_Relation of R2);
let R5 being (Function of R2 , ( R1 * ));
let R6 being (Function of R2 , R1);
set D2 = OverloadedRSSign (# R1 , R3 , R2 , R4 , R5 , R6 #);
L17: ( field (the InternalRel of D2) ) = (the carrier of D2) by ORDERS_1:12;
L18: (the InternalRel of D2) is_antisymmetric_in (the carrier of D2) by L17 , RELAT_2:def 12;
L19: ((the InternalRel of D2) is_reflexive_in (the carrier of D2) & (the InternalRel of D2) is_transitive_in (the carrier of D2)) by L17 , RELAT_2:def 9 , RELAT_2:def 16;
thus L20: thesis by L19 , L18 , ORDERS_2:def 2 , ORDERS_2:def 3 , ORDERS_2:def 4;
end;
registration
let R1 being non  empty set;
let R3 being (Order of R1);
let R2 being non  empty set;
let R4 being (Equivalence_Relation of R2);
let R5 being (Function of R2 , ( R1 * ));
let R6 being (Function of R2 , R1);
cluster OverloadedRSSign (# R1 , R3 , R2 , R4 , R5 , R6 #) ->  strict non  empty  reflexive  transitive  antisymmetric;
coherence by L16;
end;
begin
definition
let R7 being OverloadedRSSign;
attr R7 is  order-sorted
means
:L22: R7 is  reflexive  transitive  antisymmetric;
end;
registration
cluster  order-sorted ->  reflexive  transitive  antisymmetric for OverloadedRSSign;
coherence by L22;
cluster  strict non  empty non  void  order-sorted for OverloadedRSSign;
existence
proof
set D3 = the non  empty set;
set D4 = the (Order of D3);
set D5 = the non  empty set;
set D6 = the (Equivalence_Relation of D5);
set D7 = the (Function of D5 , ( D3 * ));
set D8 = the (Function of D5 , D3);
take OverloadedRSSign (# D3 , D4 , D5 , D6 , D7 , D8 #);
thus L24: thesis by L22;
end;
end;
registration
cluster non  empty non  void for OverloadedMSSign;
existence
proof
set D9 = the non  empty non  void OverloadedRSSign;
take D9;
thus L26: thesis;
end;
end;
definition
let C9 being non  empty non  void OverloadedMSSign;
let C10 , C11 being (OperSymbol of C9);
pred C10 ~= C11
means
:L28: [ C10 , C11 ] in (the Overloading of C9)
;symmetry
proof
let C12 , C13 being (OperSymbol of C9);
L29: ( field (the Overloading of C9) ) = (the carrier' of C9) by ORDERS_1:12;
L30: (the Overloading of C9) is_symmetric_in (the carrier' of C9) by L29 , RELAT_2:def 11;
thus L31: thesis by L30 , RELAT_2:def 3;
end;
reflexivity
proof
let C14 being (OperSymbol of C9);
L32: ( field (the Overloading of C9) ) = (the carrier' of C9) by ORDERS_1:12;
L33: (the Overloading of C9) is_reflexive_in (the carrier' of C9) by L32 , RELAT_2:def 9;
thus L34: thesis by L33 , RELAT_2:def 1;
end;
end;
theorem
L36: (for B4 being non  empty non  void OverloadedMSSign holds (for B5 , B6 , B7 being (OperSymbol of B4) holds ((B5 ~= B6 & B6 ~= B7) implies B5 ~= B7)))
proof
let C15 being non  empty non  void OverloadedMSSign;
let C16 , C17 , C18 being (OperSymbol of C15);
L37: ( field (the Overloading of C15) ) = (the carrier' of C15) by ORDERS_1:12;
L38: (the Overloading of C15) is_transitive_in (the carrier' of C15) by L37 , RELAT_2:def 16;
assume L39: (C16 ~= C17 & C17 ~= C18);
L40: ([ C16 , C17 ] in (the Overloading of C15) & [ C17 , C18 ] in (the Overloading of C15)) by L39 , L28;
L41: [ C16 , C18 ] in (the Overloading of C15) by L40 , L38 , RELAT_2:def 8;
thus L42: thesis by L41 , L28;
end;
definition
let C19 being non  empty non  void OverloadedMSSign;
attr C19 is  discernable
means
:L43: (for B8 , B9 being (OperSymbol of C19) holds ((B8 ~= B9 & ( the_arity_of B8 ) = ( the_arity_of B9 ) & ( the_result_sort_of B8 ) = ( the_result_sort_of B9 )) implies B8 = B9));
attr C19 is  op-discrete
means
:L44: (the Overloading of C19) = ( id (the carrier' of C19) );
end;
theorem
L46: (for B10 being non  empty non  void OverloadedMSSign holds (B10 is  op-discrete iff (for B11 , B12 being (OperSymbol of B10) holds (B11 ~= B12 implies B11 = B12))))
proof
let C20 being non  empty non  void OverloadedMSSign;
set D10 = ( id (the carrier' of C20) );
set D11 = (the carrier' of C20);
set D12 = (the Overloading of C20);
thus L47: (C20 is  op-discrete implies (for B13 , B14 being (OperSymbol of C20) holds (B13 ~= B14 implies B13 = B14)))
proof
assume L48: C20 is  op-discrete;
let C21 , C22 being (OperSymbol of C20);
assume L49: C21 ~= C22;
L50: [ C21 , C22 ] in (the Overloading of C20) by L49 , L28;
L51: [ C21 , C22 ] in D10 by L50 , L48 , L44;
thus L52: thesis by L51 , RELAT_1:def 10;
end;

assume L53: (for B15 , B16 being (OperSymbol of C20) holds (B15 ~= B16 implies B15 = B16));
L54:
now
let C23 , C24 being set;
thus L55: ([ C23 , C24 ] in D12 implies (C23 in D11 & C23 = C24))
proof
assume L56: [ C23 , C24 ] in D12;
L57: (ex B17 , B18 being set st ([ C23 , C24 ] = [ B17 , B18 ] & B17 in D11 & B18 in D11)) by L56 , RELSET_1:2;
reconsider D13 = C23 , D14 = C24 as (OperSymbol of C20) by L57 , XTUPLE_0:1;
L58: D13 ~= D14 by L56 , L28;
thus L59: thesis by L58 , L53;
end;

assume L60: (C23 in D11 & C23 = C24);
thus L61: [ C23 , C24 ] in D12 by L60 , L28;
end;
thus L62: (the Overloading of C20) = D10 by L54 , RELAT_1:def 10;
end;
theorem
L63: (for B19 being non  empty non  void OverloadedMSSign holds (B19 is  op-discrete implies B19 is  discernable))
proof
let C25 being non  empty non  void OverloadedMSSign;
assume L64: C25 is  op-discrete;
let C26 , C27 being (OperSymbol of C25);
thus L65: thesis by L64 , L46;
end;
begin
definition
let R8 being non  empty non  void ManySortedSign;
func OSSign R8 ->  strict non  empty non  void  order-sorted OverloadedRSSign means 
:L66: ((the carrier of R8) = (the carrier of it) & ( id (the carrier of R8) ) = (the InternalRel of it) & (the carrier' of R8) = (the carrier' of it) & ( id (the carrier' of R8) ) = (the Overloading of it) & (the Arity of R8) = (the Arity of it) & (the ResultSort of R8) = (the ResultSort of it));
existence
proof
set D15 = OverloadedRSSign (# (the carrier of R8) , ( id (the carrier of R8) ) , (the carrier' of R8) , ( id (the carrier' of R8) ) , (the Arity of R8) , (the ResultSort of R8) #);
reconsider D16 = D15 as  strict non  empty non  void  order-sorted OverloadedRSSign by L22;
take D16;
thus L67: thesis;
end;
uniqueness;
end;
theorem
L69: (for R8 being non  empty non  void ManySortedSign holds ( OSSign R8 ) is  discrete  op-discrete)
proof
let R8 being non  empty non  void ManySortedSign;
set D17 = ( OSSign R8 );
set D18 = (the Overloading of D17);
L70: ((the carrier of R8) = (the carrier of ( OSSign R8 )) & ( id (the carrier of R8) ) = (the InternalRel of ( OSSign R8 ))) by L66;
thus L71: ( OSSign R8 ) is  discrete by L70 , ORDERS_3:def 1;
L72: (the Overloading of ( OSSign R8 )) = ( id (the carrier' of R8) ) by L66;
L73:
now
let C28 , C29 being (OperSymbol of D17);
assume L74: C28 ~= C29;
L75: [ C28 , C29 ] in D18 by L74 , L28;
thus L76: C28 = C29 by L75 , L72 , RELAT_1:def 10;
end;
thus L77: thesis by L73 , L46;
end;
registration
cluster  discrete  op-discrete  discernable for  strict non  empty non  void  order-sorted  strict non  empty non  void  order-sorted  strict non  empty non  void  order-sorted  strict non  empty non  void  order-sorted OverloadedRSSign;
existence
proof
set D19 = the non  empty non  void ManySortedSign;
take D20 = ( OSSign D19 );
thus L78: D20 is  discrete  op-discrete by L69;
thus L79: thesis by L78 , L63;
end;
end;
registration
cluster  op-discrete ->  discernable for non  empty non  void non  empty non  void non  empty non  void non  empty non  void OverloadedRSSign;
coherence by L63;
end;
registration
let R8 being non  empty non  void ManySortedSign;
cluster ( OSSign R8 ) ->  discrete  op-discrete;
coherence by L69;
end;
definition
mode OrderSortedSign
 is  discernable non  empty non  void  order-sorted OverloadedRSSign;
end;
definition
let R9 being non  empty Poset;
let C30 , C31 being (Element of ( (the carrier of R9) * ));
pred C30 <= C31
means
:L84: (( len C30 ) = ( len C31 ) & (for B20 being set holds (B20 in ( dom C30 ) implies (for R10 being (Element of R9) holds (for R11 being (Element of R9) holds ((R10 = ( C30 . B20 ) & R11 = ( C31 . B20 )) implies R10 <= R11))))))
;reflexivity
;
end;
theorem
L86: (for R9 being non  empty Poset holds (for B21 , B22 being (Element of ( (the carrier of R9) * )) holds ((B21 <= B22 & B22 <= B21) implies B21 = B22)))
proof
let R9 being non  empty Poset;
let C32 , C33 being (Element of ( (the carrier of R9) * ));
assume that
L87: C32 <= C33
and
L88: C33 <= C32;
L89: ( len C32 ) = ( len C33 ) by L87 , L84;
L90: ( dom C32 ) = ( dom C33 ) by L89 , FINSEQ_3:29;
L91: (for B23 being set holds (B23 in ( dom C32 ) implies ( C32 . B23 ) = ( C33 . B23 )))
proof
let C34 being set;
assume that
L92: C34 in ( dom C32 );
reconsider D21 = ( C32 . C34 ) , D22 = ( C33 . C34 ) as (Element of R9) by L90 , L92 , PARTFUN1:4;
L93: (D21 <= D22 & D22 <= D21) by L87 , L88 , L90 , L92 , L84;
thus L94: thesis by L93 , ORDERS_2:2;
end;
thus L95: thesis by L91 , L90 , FUNCT_1:2;
end;
theorem
L96: (for R9 being non  empty Poset holds (for R12 being (Element of ( (the carrier of R9) * )) holds (for R13 being (Element of ( (the carrier of R9) * )) holds ((R9 is  discrete & R12 <= R13) implies R12 = R13))))
proof
let R9 being non  empty Poset;
let R12 being (Element of ( (the carrier of R9) * ));
let R13 being (Element of ( (the carrier of R9) * ));
assume that
L97: R9 is  discrete
and
L98: R12 <= R13;
reconsider D23 = R9 as  discrete non  empty Poset by L97;
L99: ( len R12 ) = ( len R13 ) by L98 , L84;
L100: ( dom R12 ) = ( dom R13 ) by L99 , FINSEQ_3:29;
L101: (for B24 being set holds (B24 in ( dom R12 ) implies ( R12 . B24 ) = ( R13 . B24 )))
proof
let C35 being set;
assume that
L102: C35 in ( dom R12 );
reconsider D24 = ( R12 . C35 ) , D25 = ( R13 . C35 ) as (Element of R9) by L100 , L102 , PARTFUN1:4;
reconsider D26 = D24 , D27 = D25 as (Element of D23);
L103: D24 <= D25 by L98 , L102 , L84;
L104: D26 = D27 by L103 , ORDERS_3:1;
thus L105: thesis by L104;
end;
thus L106: thesis by L101 , L100 , FUNCT_1:2;
end;
theorem
L107: (for R14 being OrderSortedSign holds (for R16 being (OperSymbol of R14) holds (for R17 being (OperSymbol of R14) holds ((R14 is  discrete & R16 ~= R17 & ( the_arity_of R16 ) <= ( the_arity_of R17 ) & ( the_result_sort_of R16 ) <= ( the_result_sort_of R17 )) implies R16 = R17))))
proof
let R14 being OrderSortedSign;
let R16 being (OperSymbol of R14);
let R17 being (OperSymbol of R14);
assume L108: R14 is  discrete;
reconsider D28 = R14 as  discrete OrderSortedSign by L108;
reconsider D29 = ( the_result_sort_of R16 ) , D30 = ( the_result_sort_of R17 ) as (SortSymbol of D28);
assume that
L109: R16 ~= R17
and
L110: ( the_arity_of R16 ) <= ( the_arity_of R17 )
and
L111: ( the_result_sort_of R16 ) <= ( the_result_sort_of R17 );
L112: D29 = D30 by L111 , ORDERS_3:1;
L113: ( the_arity_of R16 ) = ( the_arity_of R17 ) by L108 , L110 , L96;
thus L114: thesis by L113 , L109 , L112 , L43;
end;
definition
let R14 being OrderSortedSign;
let R15 being (OperSymbol of R14);
attr R15 is  monotone
means
:L115: (for R17 being (OperSymbol of R14) holds ((R15 ~= R17 & ( the_arity_of R15 ) <= ( the_arity_of R17 )) implies ( the_result_sort_of R15 ) <= ( the_result_sort_of R17 )));
end;
definition
let R14 being OrderSortedSign;
attr R14 is  monotone
means
:L117: (for B25 being (OperSymbol of R14) holds B25 is  monotone);
end;
theorem
L119: (for R14 being OrderSortedSign holds (R14 is  op-discrete implies R14 is  monotone))
proof
let R14 being OrderSortedSign;
set D31 = (the Overloading of R14);
assume L120: R14 is  op-discrete;
L121: D31 = ( id (the carrier' of R14) ) by L120 , L44;
let C36 being (OperSymbol of R14);
let C37 being (OperSymbol of R14);
assume L122: C36 ~= C37;
L123: [ C36 , C37 ] in D31 by L122 , L28;
thus L124: thesis by L123 , L121 , RELAT_1:def 10;
end;
registration
cluster  monotone for OrderSortedSign;
existence
proof
set D32 = the  op-discrete OrderSortedSign;
take D32;
thus L125: thesis by L119;
end;
end;
registration
let C38 being  monotone OrderSortedSign;
cluster  monotone for (OperSymbol of C38);
existence
proof
set D33 = the (OperSymbol of C38);
take D33;
thus L127: thesis by L117;
end;
end;
registration
let C39 being  monotone OrderSortedSign;
cluster  ->  monotone for (OperSymbol of C39);
coherence by L117;
end;
registration
cluster  op-discrete ->  monotone for OrderSortedSign;
coherence by L119;
end;
theorem
L131: (for R14 being OrderSortedSign holds (for R16 being (OperSymbol of R14) holds (for R17 being (OperSymbol of R14) holds ((R14 is  monotone & ( the_arity_of R16 ) = ( {} ) & R16 ~= R17 & ( the_arity_of R17 ) = ( {} )) implies R16 = R17))))
proof
let R14 being OrderSortedSign;
let R16 being (OperSymbol of R14);
let R17 being (OperSymbol of R14);
assume that
L132: R14 is  monotone
and
L133: (( the_arity_of R16 ) = ( {} ) & R16 ~= R17 & ( the_arity_of R17 ) = ( {} ));
L134: (( the_result_sort_of R16 ) <= ( the_result_sort_of R17 ) & ( the_result_sort_of R17 ) <= ( the_result_sort_of R16 )) by L132 , L133 , L115;
L135: ( the_result_sort_of R16 ) = ( the_result_sort_of R17 ) by L134 , ORDERS_2:2;
thus L136: thesis by L135 , L133 , L43;
end;
definition
let R14 being OrderSortedSign;
let R15 being (OperSymbol of R14);
let R16 being (OperSymbol of R14);
let R18 being (Element of ( (the carrier of R14) * ));
pred R16 has_least_args_for R15 , R18
means
:L137: (R15 ~= R16 & R18 <= ( the_arity_of R16 ) & (for R17 being (OperSymbol of R14) holds ((R15 ~= R17 & R18 <= ( the_arity_of R17 )) implies ( the_arity_of R16 ) <= ( the_arity_of R17 ))))
;pred R16 has_least_sort_for R15 , R18
means
:L138: (R15 ~= R16 & R18 <= ( the_arity_of R16 ) & (for R17 being (OperSymbol of R14) holds ((R15 ~= R17 & R18 <= ( the_arity_of R17 )) implies ( the_result_sort_of R16 ) <= ( the_result_sort_of R17 ))))
;end;
definition
let R14 being OrderSortedSign;
let R15 being (OperSymbol of R14);
let R16 being (OperSymbol of R14);
let R18 being (Element of ( (the carrier of R14) * ));
pred R16 has_least_rank_for R15 , R18
means
:L140: (R16 has_least_args_for R15 , R18 & R16 has_least_sort_for R15 , R18)
;end;
definition
let R14 being OrderSortedSign;
let R15 being (OperSymbol of R14);
attr R15 is  regular
means
:L142: (R15 is  monotone & (for R18 being (Element of ( (the carrier of R14) * )) holds (R18 <= ( the_arity_of R15 ) implies (ex R16 being (OperSymbol of R14) st R16 has_least_args_for R15 , R18))));
end;
definition
let C40 being  monotone OrderSortedSign;
attr C40 is  regular
means
:L144: (for B26 being (OperSymbol of C40) holds B26 is  regular);
end;
theorem
L146: (for R19 being  monotone OrderSortedSign holds (R19 is  regular iff (for R20 being (OperSymbol of R19) holds (for R23 being (Element of ( (the carrier of R19) * )) holds (R23 <= ( the_arity_of R20 ) implies (ex R21 being (OperSymbol of R19) st R21 has_least_rank_for R20 , R23))))))
proof
let R19 being  monotone OrderSortedSign;
thus L147:now
assume L148: R19 is  regular;
let R20 being (OperSymbol of R19);
let R23 being (Element of ( (the carrier of R19) * ));
assume L149: R23 <= ( the_arity_of R20 );
L150: R20 is  regular by L148 , L144;
consider R21 being (OperSymbol of R19) such that L151: R21 has_least_args_for R20 , R23 by L150 , L149 , L142;
take D34 = R21;
L152: D34 has_least_sort_for R20 , R23
proof
thus L153: (R20 ~= D34 & R23 <= ( the_arity_of D34 )) by L151 , L137;
let R22 being (OperSymbol of R19);
assume that
L154: R20 ~= R22
and
L155: R23 <= ( the_arity_of R22 );
L156: D34 ~= R22 by L153 , L154 , L36;
L157: ( the_arity_of D34 ) <= ( the_arity_of R22 ) by L151 , L154 , L155 , L137;
thus L158: thesis by L157 , L156 , L115;
end;
thus L159: D34 has_least_rank_for R20 , R23 by L152 , L151 , L140;
end;
assume L160: (for R20 being (OperSymbol of R19) holds (for R23 being (Element of ( (the carrier of R19) * )) holds (R23 <= ( the_arity_of R20 ) implies (ex R21 being (OperSymbol of R19) st R21 has_least_rank_for R20 , R23))));
let R20 being (OperSymbol of R19);
thus L161: R20 is  monotone;
let R23 being (Element of ( (the carrier of R19) * ));
assume L162: R23 <= ( the_arity_of R20 );
consider R21 being (OperSymbol of R19) such that L163: R21 has_least_rank_for R20 , R23 by L162 , L160;
take R21;
thus L164: thesis by L163 , L140;
end;
theorem
L165: (for B27 being  monotone OrderSortedSign holds (B27 is  op-discrete implies B27 is  regular))
proof
let C41 being  monotone OrderSortedSign;
assume L166: C41 is  op-discrete;
let C42 being (OperSymbol of C41);
thus L167: C42 is  monotone;
let C43 being (Element of ( (the carrier of C41) * ));
assume that
L168: C43 <= ( the_arity_of C42 );
L169: C42 has_least_args_for C42 , C43
proof
thus L170: (C42 ~= C42 & C43 <= ( the_arity_of C42 )) by L168;
let C44 being (OperSymbol of C41);
assume that
L171: C42 ~= C44
and
L172: C43 <= ( the_arity_of C44 );
thus L173: thesis by L166 , L171 , L46;
end;
thus L174: thesis by L169;
end;
registration
cluster  regular for  monotone  monotone  monotone  monotone OrderSortedSign;
existence
proof
set D35 = the  op-discrete OrderSortedSign;
take D35;
thus L175: thesis by L165;
end;
end;
registration
cluster  op-discrete ->  regular for  monotone  monotone  monotone  monotone OrderSortedSign;
coherence by L165;
end;
registration
let C45 being  regular  monotone OrderSortedSign;
cluster  ->  regular for (OperSymbol of C45);
coherence by L144;
end;
theorem
L179: (for R24 being  regular  monotone OrderSortedSign holds (for R25 being (OperSymbol of R24) holds (for R27 being (OperSymbol of R24) holds (for R28 being (OperSymbol of R24) holds (for R29 being (Element of ( (the carrier of R24) * )) holds ((R27 has_least_args_for R25 , R29 & R28 has_least_args_for R25 , R29) implies R27 = R28))))))
proof
let R24 being  regular  monotone OrderSortedSign;
let R25 being (OperSymbol of R24);
let R27 being (OperSymbol of R24);
let R28 being (OperSymbol of R24);
let R29 being (Element of ( (the carrier of R24) * ));
assume that
L180: R27 has_least_args_for R25 , R29
and
L181: R28 has_least_args_for R25 , R29;
L182: R25 ~= R27 by L180 , L137;
L183: R25 ~= R28 by L181 , L137;
L184: R27 ~= R28 by L183 , L182 , L36;
L185: R29 <= ( the_arity_of R27 ) by L180 , L137;
L186: ( the_arity_of R28 ) <= ( the_arity_of R27 ) by L185 , L181 , L182 , L137;
L187: ( the_result_sort_of R28 ) <= ( the_result_sort_of R27 ) by L186 , L184 , L115;
L188: R29 <= ( the_arity_of R28 ) by L181 , L137;
L189: ( the_arity_of R27 ) <= ( the_arity_of R28 ) by L188 , L180 , L183 , L137;
L190: ( the_arity_of R27 ) = ( the_arity_of R28 ) by L189 , L186 , L86;
L191: ( the_result_sort_of R27 ) <= ( the_result_sort_of R28 ) by L184 , L189 , L115;
L192: ( the_result_sort_of R27 ) = ( the_result_sort_of R28 ) by L191 , L187 , ORDERS_2:2;
thus L193: thesis by L192 , L184 , L190 , L43;
end;
definition
let R24 being  regular  monotone OrderSortedSign;
let R25 being (OperSymbol of R24);
let R29 being (Element of ( (the carrier of R24) * ));
assume L194: R29 <= ( the_arity_of R25 );
func LBound (R25 , R29) -> (OperSymbol of R24) means 
:L195: it has_least_args_for R25 , R29;
existence by L194 , L142;
uniqueness by L179;
end;
theorem
L197: (for R24 being  regular  monotone OrderSortedSign holds (for R25 being (OperSymbol of R24) holds (for R29 being (Element of ( (the carrier of R24) * )) holds (R29 <= ( the_arity_of R25 ) implies ( LBound (R25 , R29) ) has_least_rank_for R25 , R29))))
proof
let R24 being  regular  monotone OrderSortedSign;
let R25 being (OperSymbol of R24);
let R29 being (Element of ( (the carrier of R24) * ));
assume L198: R29 <= ( the_arity_of R25 );
consider R26 being (OperSymbol of R24) such that L199: R26 has_least_rank_for R25 , R29 by L198 , L146;
L200: R26 has_least_args_for R25 , R29 by L199 , L140;
thus L201: thesis by L200 , L198 , L199 , L195;
end;
definition
let R30 being non  empty Poset;
let R31 being non  empty set;
func ConstOSSet (R30 , R31) -> (ManySortedSet of (the carrier of R30)) equals 
( (the carrier of R30) --> R31 );
correctness
proof
L202: (the carrier of R30) = ( dom ( (the carrier of R30) --> R31 ) ) by FUNCT_2:def 1;
thus L203: thesis by L202 , PARTFUN1:def 2;
end;
end;
theorem
L205: (for R30 being non  empty Poset holds (for R31 being non  empty set holds (( ConstOSSet (R30 , R31) ) is  non-empty & (for B28 , B29 being (Element of R30) holds (B28 <= B29 implies ( ( ConstOSSet (R30 , R31) ) . B28 ) c= ( ( ConstOSSet (R30 , R31) ) . B29 ))))))
proof
let R30 being non  empty Poset;
let R31 being non  empty set;
set D36 = ( ConstOSSet (R30 , R31) );
set D37 = ( (the carrier of R30) --> R31 );
L206: (for B30 being set holds (B30 in (the carrier of R30) implies ( D36 . B30 ) is non  empty)) by FUNCOP_1:7;
thus L207: D36 is  non-empty by L206 , PBOOLE:def 13;
let C46 , C47 being (Element of R30);
L208: ( D37 . C46 ) = R31 by FUNCOP_1:7
.= ( D37 . C47 ) by FUNCOP_1:7;
thus L209: thesis by L208;
end;
definition
let R30 being non  empty Poset;
let C48 being (ManySortedSet of R30);
attr C48 is  order-sorted
means
:L210: (for B31 , B32 being (Element of R30) holds (B31 <= B32 implies ( C48 . B31 ) c= ( C48 . B32 )));
end;
theorem
L212: (for R30 being non  empty Poset holds (for R31 being non  empty set holds ( ConstOSSet (R30 , R31) ) is  order-sorted))
proof
let R30 being non  empty Poset;
let R31 being non  empty set;
set D38 = ( ConstOSSet (R30 , R31) );
L213: (for B33 , B34 being (Element of R30) holds (B33 <= B34 implies ( D38 . B33 ) c= ( D38 . B34 ))) by L205;
thus L214: thesis by L213 , L210;
end;
registration
let R30 being non  empty Poset;
cluster  order-sorted for (ManySortedSet of R30);
existence
proof
set D39 = the non  empty set;
take ( ConstOSSet (R30 , D39) );
thus L215: thesis by L212;
end;
end;
registration
let R30 being non  empty Poset;
let R31 being non  empty set;
cluster ( ConstOSSet (R30 , R31) ) ->  order-sorted;
coherence by L212;
end;
definition
let C49 being non  empty Poset;
mode OrderSortedSet of C49
 is  order-sorted (ManySortedSet of C49);
end;
registration
let C50 being non  empty Poset;
cluster  non-empty for (OrderSortedSet of C50);
existence
proof
take ( ConstOSSet (C50 , 1) );
thus L219: thesis by L205;
end;
end;
definition
let R14 being OrderSortedSign;
let C51 being MSAlgebra over R14;
attr C51 is  order-sorted
means
:L221: (for R32 being (SortSymbol of R14) holds (for R33 being (SortSymbol of R14) holds (R32 <= R33 implies ( (the Sorts of C51) . R32 ) c= ( (the Sorts of C51) . R33 ))));
end;
theorem
L223: (for R14 being OrderSortedSign holds (for B35 being MSAlgebra over R14 holds (B35 is  order-sorted iff (the Sorts of B35) is (OrderSortedSet of R14))))
proof
let R14 being OrderSortedSign;
let C52 being MSAlgebra over R14;
set D40 = (the Sorts of C52);
reconsider D41 = D40 as (ManySortedSet of R14);
thus L224: (C52 is  order-sorted implies D40 is (OrderSortedSet of R14))
proof
assume L225: C52 is  order-sorted;
L226: D41 is  order-sorted
proof
let R32 being (SortSymbol of R14);
let R33 being (SortSymbol of R14);
thus L227: thesis by L225 , L221;
end;
thus L228: thesis by L226;
end;

assume L229: D40 is (OrderSortedSet of R14);
let R32 being (SortSymbol of R14);
let R33 being (SortSymbol of R14);
thus L230: thesis by L229 , L210;
end;
definition
let R14 being OrderSortedSign;
let R31 being non  empty set;
let R40 being (ManySortedFunction of ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) , ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) ));
func ConstOSA (R14 , R31 , R40) ->  strict  non-empty MSAlgebra over R14 means 
:L231: ((the Sorts of it) = ( ConstOSSet (R14 , R31) ) & (the Charact of it) = R40);
existence
proof
L232: (for B36 being set holds (B36 in (the carrier of R14) implies ( ( ConstOSSet (R14 , R31) ) . B36 ) is non  empty)) by FUNCOP_1:7;
L233: ( ConstOSSet (R14 , R31) ) is  non-empty by L232 , PBOOLE:def 13;
reconsider D42 = MSAlgebra (# ( ConstOSSet (R14 , R31) ) , R40 #) as  strict  non-empty MSAlgebra over R14 by L233 , MSUALG_1:def 3;
take D42;
thus L234: thesis;
end;
uniqueness;
end;
theorem
L236: (for R14 being OrderSortedSign holds (for R31 being non  empty set holds (for R40 being (ManySortedFunction of ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) , ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) )) holds ( ConstOSA (R14 , R31 , R40) ) is  order-sorted)))
proof
let R14 being OrderSortedSign;
let R31 being non  empty set;
let R40 being (ManySortedFunction of ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) , ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) ));
L237: (the Sorts of ( ConstOSA (R14 , R31 , R40) )) = ( ConstOSSet (R14 , R31) ) by L231;
thus L238: thesis by L237 , L223;
end;
registration
let R14 being OrderSortedSign;
cluster  strict  non-empty  order-sorted for MSAlgebra over R14;
existence
proof
set D43 = the non  empty set;
set D44 = the (ManySortedFunction of ( ( ( ConstOSSet (R14 , D43) ) # ) * (the Arity of R14) ) , ( ( ConstOSSet (R14 , D43) ) * (the ResultSort of R14) ));
take ( ConstOSA (R14 , D43 , D44) );
thus L239: thesis by L236;
end;
end;
registration
let R14 being OrderSortedSign;
let R31 being non  empty set;
let R40 being (ManySortedFunction of ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) , ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) ));
cluster ( ConstOSA (R14 , R31 , R40) ) ->  order-sorted;
coherence by L236;
end;
definition
let R14 being OrderSortedSign;
mode OSAlgebra of R14
 is  order-sorted MSAlgebra over R14;
end;
theorem
L243: (for B37 being  discrete OrderSortedSign holds (for B38 being MSAlgebra over B37 holds B38 is  order-sorted))
proof
let C53 being  discrete OrderSortedSign;
let C54 being MSAlgebra over C53;
let C55 , C56 being (SortSymbol of C53);
assume L244: C55 <= C56;
thus L245: thesis by L244 , ORDERS_3:1;
end;
registration
let C57 being  discrete OrderSortedSign;
cluster  ->  order-sorted for MSAlgebra over C57;
coherence by L243;
end;
theorem
L247: (for R14 being OrderSortedSign holds (for R38 being (Element of ( (the carrier of R14) * )) holds (for R39 being (Element of ( (the carrier of R14) * )) holds (for R41 being (OSAlgebra of R14) holds (R38 <= R39 implies ( ( (the Sorts of R41) # ) . R38 ) c= ( ( (the Sorts of R41) # ) . R39 ))))))
proof
let R14 being OrderSortedSign;
let R38 being (Element of ( (the carrier of R14) * ));
let R39 being (Element of ( (the carrier of R14) * ));
let R41 being (OSAlgebra of R14);
set D45 = ( (the Sorts of R41) * R38 );
set D46 = ( (the Sorts of R41) * R39 );
assume L248: R38 <= R39;
L249: ( len R38 ) = ( len R39 ) by L248 , L84;
let C58 being set;
assume L250: C58 in ( ( (the Sorts of R41) # ) . R38 );
L251: C58 in ( product D45 ) by L250 , FINSEQ_2:def 5;
consider C59 being Function such that L252: C58 = C59 and L253: ( dom C59 ) = ( dom D45 ) and L254: (for B39 being set holds (B39 in ( dom D45 ) implies ( C59 . B39 ) in ( D45 . B39 ))) by L251 , CARD_3:def 5;
L255: ( dom D45 ) = ( dom R38 ) by L6
.= ( dom R39 ) by L249 , FINSEQ_3:29
.= ( dom D46 ) by L6;
L256: (for B40 being set holds (B40 in ( dom D46 ) implies ( C59 . B40 ) in ( D46 . B40 )))
proof
let C60 being set;
assume that
L257: C60 in ( dom D46 );
L258: C60 in ( dom R38 ) by L255 , L257 , L6;
L259: ( D45 . C60 ) = ( (the Sorts of R41) . ( R38 . C60 ) ) by L258 , FUNCT_1:13;
L260: C60 in ( dom R39 ) by L257 , L6;
L261: ( D46 . C60 ) = ( (the Sorts of R41) . ( R39 . C60 ) ) by L260 , FUNCT_1:13;
reconsider D47 = ( R38 . C60 ) , D48 = ( R39 . C60 ) as (SortSymbol of R14) by L258 , L260 , PARTFUN1:4;
L262: D47 <= D48 by L248 , L258 , L84;
L263: ( (the Sorts of R41) . ( R38 . C60 ) ) c= ( (the Sorts of R41) . ( R39 . C60 ) ) by L262 , L221;
L264: ( C59 . C60 ) in ( D45 . C60 ) by L254 , L255 , L257;
thus L265: thesis by L264 , L259 , L261 , L263;
end;
L266: C59 in ( product D46 ) by L256 , L253 , L255 , CARD_3:def 5;
thus L267: thesis by L266 , L252 , FINSEQ_2:def 5;
end;
definition
let R8 being non  empty non  void ManySortedSign;
let R42 being MSAlgebra over R8;
func OSAlg R42 ->  strict (OSAlgebra of ( OSSign R8 )) means 
((the Sorts of it) = (the Sorts of R42) & (the Charact of it) = (the Charact of R42));
uniqueness;
existence
proof
set D49 = ( OSSign R8 );
set D50 = (the Sorts of R42);
set D51 = (the Charact of R42);
L268: (the carrier of R8) = (the carrier of D49) by L66;
reconsider D52 = D50 as (ManySortedSet of D49) by L268;
L269: ((the Arity of R8) = (the Arity of D49) & (the ResultSort of D49) = (the ResultSort of R8)) by L66;
reconsider D53 = D51 as (ManySortedFunction of ( ( D52 # ) * (the Arity of D49) ) , ( D52 * (the ResultSort of D49) )) by L269 , L268 , L66;
L270: MSAlgebra (# D52 , D53 #) is  order-sorted;
thus L271: thesis by L270;
end;
end;
theorem
L273: (for R14 being OrderSortedSign holds (for B41 , B42 , B43 being (Element of ( (the carrier of R14) * )) holds ((B41 <= B42 & B42 <= B43) implies B41 <= B43)))
proof
let R14 being OrderSortedSign;
let C61 , C62 , C63 being (Element of ( (the carrier of R14) * ));
assume that
L274: C61 <= C62
and
L275: C62 <= C63;
L276: ( len C61 ) = ( len C62 ) by L274 , L84;
L277: ( dom C61 ) = ( dom C62 ) by L276 , FINSEQ_3:29;
L278: ( len C62 ) = ( len C63 ) by L275 , L84;
L279: ( dom C62 ) = ( dom C63 ) by L278 , FINSEQ_3:29;
L280: (for B44 being set holds (B44 in ( dom C61 ) implies (for R32 being (SortSymbol of R14) holds (for R33 being (SortSymbol of R14) holds ((R32 = ( C61 . B44 ) & R33 = ( C63 . B44 )) implies R32 <= R33)))))
proof
let C64 being set;
assume that
L281: C64 in ( dom C61 );
reconsider D54 = ( C61 . C64 ) , D55 = ( C62 . C64 ) , D56 = ( C63 . C64 ) as (SortSymbol of R14) by L277 , L279 , L281 , PARTFUN1:4;
L282: (D54 <= D55 & D55 <= D56) by L274 , L275 , L277 , L281 , L84;
let R32 being (SortSymbol of R14);
let R33 being (SortSymbol of R14);
assume L283: (R32 = ( C61 . C64 ) & R33 = ( C63 . C64 ));
thus L284: thesis by L283 , L282 , ORDERS_2:3;
end;
thus L285: thesis by L280 , L276 , L278 , L84;
end;
definition
let R14 being OrderSortedSign;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
pred R35 <= R36
means
:L286: (R35 ~= R36 & ( the_arity_of R35 ) <= ( the_arity_of R36 ) & ( the_result_sort_of R35 ) <= ( the_result_sort_of R36 ))
;reflexivity
;
end;
theorem
L288: (for R14 being OrderSortedSign holds (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds ((R35 <= R36 & R36 <= R35) implies R35 = R36))))
proof
let R14 being OrderSortedSign;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
assume that
L289: R35 <= R36
and
L290: R36 <= R35;
L291: (( the_result_sort_of R35 ) <= ( the_result_sort_of R36 ) & ( the_result_sort_of R36 ) <= ( the_result_sort_of R35 )) by L289 , L290 , L286;
L292: ( the_result_sort_of R35 ) = ( the_result_sort_of R36 ) by L291 , ORDERS_2:2;
L293: (( the_arity_of R35 ) <= ( the_arity_of R36 ) & ( the_arity_of R36 ) <= ( the_arity_of R35 )) by L289 , L290 , L286;
L294: ( the_arity_of R35 ) = ( the_arity_of R36 ) by L293 , L86;
L295: R35 ~= R36 by L289 , L286;
thus L296: thesis by L295 , L294 , L292 , L43;
end;
theorem
L297: (for R14 being OrderSortedSign holds (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (for R37 being (OperSymbol of R14) holds ((R35 <= R36 & R36 <= R37) implies R35 <= R37)))))
proof
let R14 being OrderSortedSign;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
let R37 being (OperSymbol of R14);
assume L298: (R35 <= R36 & R36 <= R37);
L299: (R35 ~= R36 & R36 ~= R37) by L298 , L286;
thus L300: R35 ~= R37 by L299 , L36;
L301: (( the_arity_of R35 ) <= ( the_arity_of R36 ) & ( the_arity_of R36 ) <= ( the_arity_of R37 )) by L298 , L286;
thus L302: ( the_arity_of R35 ) <= ( the_arity_of R37 ) by L301 , L273;
L303: (( the_result_sort_of R35 ) <= ( the_result_sort_of R36 ) & ( the_result_sort_of R36 ) <= ( the_result_sort_of R37 )) by L298 , L286;
thus L304: thesis by L303 , ORDERS_2:3;
end;
theorem
L305: (for R14 being OrderSortedSign holds (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (for R43 being (OSAlgebra of R14) holds (( the_result_sort_of R35 ) <= ( the_result_sort_of R36 ) implies ( Result (R35 , R43) ) c= ( Result (R36 , R43) ))))))
proof
let R14 being OrderSortedSign;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
let R43 being (OSAlgebra of R14);
reconsider D57 = (the Sorts of R43) as (OrderSortedSet of R14) by L223;
L306: ( Result (R36 , R43) ) = ( ( (the Sorts of R43) * (the ResultSort of R14) ) . R36 ) by MSUALG_1:def 5
.= ( (the Sorts of R43) . ( (the ResultSort of R14) . R36 ) ) by FUNCT_2:15
.= ( (the Sorts of R43) . ( the_result_sort_of R36 ) ) by MSUALG_1:def 2;
assume L307: ( the_result_sort_of R35 ) <= ( the_result_sort_of R36 );
L308: ( D57 . ( the_result_sort_of R35 ) ) c= ( D57 . ( the_result_sort_of R36 ) ) by L307 , L210;
L309: ( Result (R35 , R43) ) = ( ( (the Sorts of R43) * (the ResultSort of R14) ) . R35 ) by MSUALG_1:def 5
.= ( (the Sorts of R43) . ( (the ResultSort of R14) . R35 ) ) by FUNCT_2:15
.= ( (the Sorts of R43) . ( the_result_sort_of R35 ) ) by MSUALG_1:def 2;
thus L310: thesis by L309 , L308 , L306;
end;
theorem
L311: (for R14 being OrderSortedSign holds (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (for R43 being (OSAlgebra of R14) holds (( the_arity_of R35 ) <= ( the_arity_of R36 ) implies ( Args (R35 , R43) ) c= ( Args (R36 , R43) ))))))
proof
let R14 being OrderSortedSign;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
let R43 being (OSAlgebra of R14);
reconsider D58 = (the Sorts of R43) as (OrderSortedSet of R14) by L223;
L312: ( ( D58 # ) . ( the_arity_of R35 ) ) = ( ( D58 # ) . ( (the Arity of R14) . R35 ) ) by MSUALG_1:def 1
.= ( ( ( D58 # ) * (the Arity of R14) ) . R35 ) by FUNCT_2:15
.= ( Args (R35 , R43) ) by MSUALG_1:def 4;
L313: ( ( D58 # ) . ( the_arity_of R36 ) ) = ( ( D58 # ) . ( (the Arity of R14) . R36 ) ) by MSUALG_1:def 1
.= ( ( ( D58 # ) * (the Arity of R14) ) . R36 ) by FUNCT_2:15
.= ( Args (R36 , R43) ) by MSUALG_1:def 4;
assume L314: ( the_arity_of R35 ) <= ( the_arity_of R36 );
thus L315: thesis by L314 , L312 , L313 , L247;
end;
theorem
L316: (for R14 being OrderSortedSign holds (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (for R43 being (OSAlgebra of R14) holds (R35 <= R36 implies (( Args (R35 , R43) ) c= ( Args (R36 , R43) ) & ( Result (R35 , R43) ) c= ( Result (R36 , R43) )))))))
proof
let R14 being OrderSortedSign;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
let R43 being (OSAlgebra of R14);
assume L317: R35 <= R36;
L318: (( the_arity_of R35 ) <= ( the_arity_of R36 ) & ( the_result_sort_of R35 ) <= ( the_result_sort_of R36 )) by L317 , L286;
thus L319: thesis by L318 , L305 , L311;
end;
definition
let R14 being OrderSortedSign;
let R43 being (OSAlgebra of R14);
attr R43 is  monotone
means
:L320: (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (R35 <= R36 implies ( ( Den (R36 , R43) ) | ( Args (R35 , R43) ) ) = ( Den (R35 , R43) ))));
end;
theorem
L322: (for R14 being OrderSortedSign holds (for B45 being  non-empty (OSAlgebra of R14) holds (B45 is  monotone iff (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (R35 <= R36 implies ( Den (R35 , B45) ) c= ( Den (R36 , B45) )))))))
proof
let R14 being OrderSortedSign;
let C65 being  non-empty (OSAlgebra of R14);
thus L323:now
assume L324: C65 is  monotone;
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
assume L325: R35 <= R36;
L326: ( ( Den (R36 , C65) ) | ( Args (R35 , C65) ) ) = ( Den (R35 , C65) ) by L325 , L324 , L320;
thus L327: ( Den (R35 , C65) ) c= ( Den (R36 , C65) ) by L326 , RELAT_1:59;
end;
assume L328: (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (R35 <= R36 implies ( Den (R35 , C65) ) c= ( Den (R36 , C65) ))));
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
assume that
L329: R35 <= R36;
L330: ( dom ( Den (R35 , C65) ) ) = ( Args (R35 , C65) ) by FUNCT_2:def 1;
thus L331: ( ( Den (R36 , C65) ) | ( Args (R35 , C65) ) ) = ( ( Den (R35 , C65) ) | ( Args (R35 , C65) ) ) by L330 , L328 , L329 , GRFUNC_1:27
.= ( Den (R35 , C65) );
end;
theorem
L332: (for R14 being OrderSortedSign holds (for R43 being (OSAlgebra of R14) holds ((R14 is  discrete or R14 is  op-discrete) implies R43 is  monotone)))
proof
let R14 being OrderSortedSign;
let R43 being (OSAlgebra of R14);
assume L333: (R14 is  discrete or R14 is  op-discrete);
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
assume that
L334: R35 ~= R36
and
L335: (( the_arity_of R35 ) <= ( the_arity_of R36 ) & ( the_result_sort_of R35 ) <= ( the_result_sort_of R36 ));
L336: R35 = R36
proof
per cases  by L333;
suppose L337: R14 is  discrete;

thus L338: thesis by L337 , L334 , L335 , L107;
end;
suppose L339: R14 is  op-discrete;

thus L340: thesis by L339 , L334 , L46;
end;
end;
thus L342: thesis by L336 , RELSET_1:19;
end;
definition
let R14 being OrderSortedSign;
let R31 being non  empty set;
let C66 being (Element of R31);
func TrivialOSA (R14 , R31 , C66) ->  strict (OSAlgebra of R14) means 
:L343: ((the Sorts of it) = ( ConstOSSet (R14 , R31) ) & (for R34 being (OperSymbol of R14) holds ( Den (R34 , it) ) = ( ( Args (R34 , it) ) --> C66 )));
existence
proof
set D59 = ( ConstOSSet (R14 , R31) );
deffunc H1((Element of (the carrier' of R14))) = ( ( ( ( D59 # ) * (the Arity of R14) ) . $1 ) --> (C66 qua set) );
consider C67 being Function such that L344: (( dom C67 ) = (the carrier' of R14) & (for B46 being (Element of (the carrier' of R14)) holds ( C67 . B46 ) = H1(B46))) from FUNCT_1:sch 4;
reconsider D60 = C67 as (ManySortedSet of (the carrier' of R14)) by L344 , PARTFUN1:def 2 , RELAT_1:def 18;
L345: (for B47 being set holds (B47 in (the carrier' of R14) implies ( D60 . B47 ) is (Function of ( ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) . B47 ) , ( ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) ) . B47 ))))
proof
let C68 being set;
assume L346: C68 in (the carrier' of R14);
reconsider D61 = C68 as (OperSymbol of R14) by L346;
L347: ( (the ResultSort of R14) . D61 ) in (the carrier of R14);
L348: D61 in ( (the ResultSort of R14) " (the carrier of R14) ) by L347 , FUNCT_2:38;
L349: ( ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) ) . D61 ) = ( ( ( (the ResultSort of R14) " (the carrier of R14) ) --> R31 ) . D61 ) by FUNCOP_1:19
.= R31 by L348 , FUNCOP_1:7;
L350: { C66 } c= ( ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) ) . C68 ) by L349 , ZFMISC_1:31;
L351: ( D60 . C68 ) = H1(D61) by L344;
thus L352: thesis by L351 , L350 , FUNCT_2:7;
end;
reconsider D62 = D60 as (ManySortedFunction of ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) , ( ( ConstOSSet (R14 , R31) ) * (the ResultSort of R14) )) by L345 , PBOOLE:def 15;
take D63 = ( ConstOSA (R14 , R31 , D62) );
thus L353: (the Sorts of D63) = ( ConstOSSet (R14 , R31) ) by L231;
let R34 being (OperSymbol of R14);
L354: ( Den (R34 , D63) ) = ( (the Charact of D63) . R34 ) by MSUALG_1:def 6
.= ( D62 . R34 ) by L231
.= ( ( ( ( D59 # ) * (the Arity of R14) ) . R34 ) --> C66 ) by L344
.= ( ( Args (R34 , D63) ) --> C66 ) by L353 , MSUALG_1:def 4;
thus L355: thesis by L354;
end;
uniqueness
proof
let C69 , C70 being  strict (OSAlgebra of R14);
assume that
L356: (the Sorts of C69) = ( ConstOSSet (R14 , R31) )
and
L357: (for R34 being (OperSymbol of R14) holds ( Den (R34 , C69) ) = ( ( Args (R34 , C69) ) --> C66 ));
assume that
L358: (the Sorts of C70) = ( ConstOSSet (R14 , R31) )
and
L359: (for R34 being (OperSymbol of R14) holds ( Den (R34 , C70) ) = ( ( Args (R34 , C70) ) --> C66 ));
L360:
now
let C71 being set;
assume L361: C71 in (the carrier' of R14);
reconsider D64 = C71 as (OperSymbol of R14) by L361;
thus L362: ( (the Charact of C69) . C71 ) = ( Den (D64 , C69) ) by MSUALG_1:def 6
.= ( ( Args (D64 , C69) ) --> C66 ) by L357
.= ( ( ( ( ( ConstOSSet (R14 , R31) ) # ) * (the Arity of R14) ) . D64 ) --> C66 ) by L356 , MSUALG_1:def 4
.= ( ( Args (D64 , C70) ) --> C66 ) by L358 , MSUALG_1:def 4
.= ( Den (D64 , C70) ) by L359
.= ( (the Charact of C70) . C71 ) by MSUALG_1:def 6;
end;
thus L363: thesis by L360 , L356 , L358 , PBOOLE:3;
end;
end;
theorem
L365: (for R14 being OrderSortedSign holds (for R31 being non  empty set holds (for B48 being (Element of R31) holds (( TrivialOSA (R14 , R31 , B48) ) is  non-empty & ( TrivialOSA (R14 , R31 , B48) ) is  monotone))))
proof
let R14 being OrderSortedSign;
let R31 being non  empty set;
let C72 being (Element of R31);
set D65 = ( TrivialOSA (R14 , R31 , C72) );
L366: (the Sorts of D65) = ( ConstOSSet (R14 , R31) ) by L343;
L367: (the Sorts of D65) is  non-empty by L366 , L205;
thus L368: D65 is  non-empty by L367 , MSUALG_1:def 3;
reconsider D66 = D65 as  non-empty (OSAlgebra of R14) by L367 , MSUALG_1:def 3;
L369: (for R35 being (OperSymbol of R14) holds (for R36 being (OperSymbol of R14) holds (R35 <= R36 implies ( Den (R35 , D66) ) c= ( Den (R36 , D66) ))))
proof
let R35 being (OperSymbol of R14);
let R36 being (OperSymbol of R14);
L370: ( Args (R35 , D65) ) = ( ( ( (the Sorts of D65) # ) * (the Arity of R14) ) . R35 ) by MSUALG_1:def 4
.= ( ( (the Sorts of D65) # ) . ( (the Arity of R14) . R35 ) ) by FUNCT_2:15
.= ( ( (the Sorts of D65) # ) . ( the_arity_of R35 ) ) by MSUALG_1:def 1;
L371: ( Args (R36 , D65) ) = ( ( ( (the Sorts of D65) # ) * (the Arity of R14) ) . R36 ) by MSUALG_1:def 4
.= ( ( (the Sorts of D65) # ) . ( (the Arity of R14) . R36 ) ) by FUNCT_2:15
.= ( ( (the Sorts of D65) # ) . ( the_arity_of R36 ) ) by MSUALG_1:def 1;
assume L372: R35 <= R36;
L373: ( the_arity_of R35 ) <= ( the_arity_of R36 ) by L372 , L286;
L374: (( Den (R35 , D65) ) = ( ( Args (R35 , D65) ) --> C72 ) & ( Den (R36 , D65) ) = ( ( Args (R36 , D65) ) --> C72 )) by L343;
thus L375: thesis by L374 , L373 , L370 , L371 , L247 , FUNCT_4:4;
end;
thus L376: thesis by L369 , L322;
end;
registration
let R14 being OrderSortedSign;
cluster  monotone  strict  non-empty for (OSAlgebra of R14);
existence
proof
set D67 = the non  empty set;
set D68 = the (Element of D67);
take ( TrivialOSA (R14 , D67 , D68) );
thus L377: thesis by L365;
end;
end;
registration
let R14 being OrderSortedSign;
let R31 being non  empty set;
let C73 being (Element of R31);
cluster ( TrivialOSA (R14 , R31 , C73) ) ->  monotone  non-empty;
coherence by L365;
end;
definition
let R14 being OrderSortedSign;
func OperNames R14 -> non  empty (Subset-Family of (the carrier' of R14)) equals 
( Class (the Overloading of R14) );
coherence;
end;
registration
let R14 being OrderSortedSign;
cluster  -> non  empty for (Element of ( OperNames R14 ));
coherence
proof
let C74 being (Element of ( OperNames R14 ));
L381: (ex B49 being set st (B49 in (the carrier' of R14) & C74 = ( Class ((the Overloading of R14) , B49) ))) by EQREL_1:def 3;
thus L382: thesis by L381 , EQREL_1:20;
end;
end;
definition
let R14 being OrderSortedSign;
mode OperName of R14
 is (Element of ( OperNames R14 ));
end;
definition
let R14 being OrderSortedSign;
let R44 being (OperSymbol of R14);
func Name R44 -> (OperName of R14) equals 
( Class ((the Overloading of R14) , R44) );
coherence by EQREL_1:def 3;
end;
theorem
L386: (for R14 being OrderSortedSign holds (for R44 being (OperSymbol of R14) holds (for R45 being (OperSymbol of R14) holds (R44 ~= R45 iff R45 in ( Class ((the Overloading of R14) , R44) )))))
proof
let R14 being OrderSortedSign;
let R44 being (OperSymbol of R14);
let R45 being (OperSymbol of R14);
L387: (R44 ~= R45 iff [ R45 , R44 ] in (the Overloading of R14)) by L28;
thus L388: thesis by L387 , EQREL_1:19;
end;
theorem
L389: (for R14 being OrderSortedSign holds (for R44 being (OperSymbol of R14) holds (for R45 being (OperSymbol of R14) holds (R44 ~= R45 iff ( Name R44 ) = ( Name R45 )))))
proof
let R14 being OrderSortedSign;
let R44 being (OperSymbol of R14);
let R45 being (OperSymbol of R14);
L390: (R45 in ( Class ((the Overloading of R14) , R44) ) iff ( Class ((the Overloading of R14) , R44) ) = ( Class ((the Overloading of R14) , R45) )) by EQREL_1:23;
thus L391: thesis by L390 , L386;
end;
theorem
L392: (for R14 being OrderSortedSign holds (for B50 being set holds (B50 is (OperName of R14) iff (ex R44 being (OperSymbol of R14) st B50 = ( Name R44 )))))
proof
let R14 being OrderSortedSign;
let C75 being set;
thus L393:now
assume L394: C75 is (OperName of R14);
consider C76 being set such that L395: C76 in (the carrier' of R14) and L396: C75 = ( Class ((the Overloading of R14) , C76) ) by L394 , EQREL_1:def 3;
reconsider D69 = C76 as (OperSymbol of R14) by L395;
take D70 = D69;
thus L397: C75 = ( Name D70 ) by L396;
end;
given R44 being (OperSymbol of R14) such that
L398: C75 = ( Name R44 );

thus L399: thesis by L398;
end;
definition
let R14 being OrderSortedSign;
let C77 being (OperName of R14);
redefine mode Element of C77
 -> (OperSymbol of R14);
coherence
proof
let C78 being (Element of C77);
thus L400: thesis;
end;
end;
theorem
L402: (for R14 being OrderSortedSign holds (for B51 being (OperName of R14) holds (for B52 being (OperSymbol of R14) holds (B52 is (Element of B51) iff ( Name B52 ) = B51))))
proof
let R14 being OrderSortedSign;
let C79 being (OperName of R14);
let C80 being (OperSymbol of R14);
thus L403:now
assume L404: C80 is (Element of C79);
reconsider D71 = C80 as (Element of C79) by L404;
L405: ((ex B53 being set st (B53 in (the carrier' of R14) & C79 = ( Class ((the Overloading of R14) , B53) ))) & ( Name D71 ) = ( Class ((the Overloading of R14) , D71) )) by EQREL_1:def 3;
thus L406: ( Name C80 ) = C79 by L405 , EQREL_1:23;
end;
assume L407: ( Name C80 ) = C79;
thus L408: thesis by L407 , EQREL_1:20;
end;
theorem
L409: (for B54 being  regular  monotone OrderSortedSign holds (for B55 , B56 being (OperSymbol of B54) holds (for B57 being (Element of ( (the carrier of B54) * )) holds ((B55 ~= B56 & B57 <= ( the_arity_of B55 ) & B57 <= ( the_arity_of B56 )) implies ( LBound (B55 , B57) ) = ( LBound (B56 , B57) )))))
proof
let C81 being  regular  monotone OrderSortedSign;
let C82 , C83 being (OperSymbol of C81);
let C84 being (Element of ( (the carrier of C81) * ));
assume that
L410: C82 ~= C83
and
L411: C84 <= ( the_arity_of C82 )
and
L412: C84 <= ( the_arity_of C83 );
set D72 = ( LBound (C82 , C84) );
set D73 = ( LBound (C83 , C84) );
L413: ( LBound (C82 , C84) ) has_least_args_for C82 , C84 by L411 , L195;
L414: C82 ~= D72 by L413 , L137;
L415: ( LBound (C83 , C84) ) has_least_args_for C83 , C84 by L412 , L195;
L416: (for B58 being (OperSymbol of C81) holds ((C83 ~= B58 & C84 <= ( the_arity_of B58 )) implies ( the_arity_of D73 ) <= ( the_arity_of B58 ))) by L415 , L137;
L417: C83 ~= D73 by L415 , L137;
L418: C82 ~= D73 by L417 , L410 , L36;
L419: D72 ~= D73 by L418 , L414 , L36;
L420: C84 <= ( the_arity_of D72 ) by L413 , L137;
L421: ( the_arity_of D73 ) <= ( the_arity_of D72 ) by L420 , L410 , L414 , L416 , L36;
L422: ( the_result_sort_of D73 ) <= ( the_result_sort_of D72 ) by L421 , L419 , L115;
L423: C84 <= ( the_arity_of D73 ) by L415 , L137;
L424: ( the_arity_of D72 ) <= ( the_arity_of D73 ) by L423 , L413 , L418 , L137;
L425: ( the_arity_of D72 ) = ( the_arity_of D73 ) by L424 , L421 , L86;
L426: ( the_result_sort_of D72 ) <= ( the_result_sort_of D73 ) by L419 , L424 , L115;
L427: ( the_result_sort_of D72 ) = ( the_result_sort_of D73 ) by L426 , L422 , ORDERS_2:2;
thus L428: thesis by L427 , L419 , L425 , L43;
end;
definition
let C85 being  regular  monotone OrderSortedSign;
let C86 being (OperName of C85);
let C87 being (Element of ( (the carrier of C85) * ));
assume L429: (ex B59 being (Element of C86) st C87 <= ( the_arity_of B59 ));
func LBound (C86 , C87) -> (Element of C86) means 
(for B60 being (Element of C86) holds (C87 <= ( the_arity_of B60 ) implies it = ( LBound (B60 , C87) )));
existence
proof
consider C88 being (Element of C86) such that L430: C87 <= ( the_arity_of C88 ) by L429;
set D74 = ( LBound (C88 , C87) );
L431: ( LBound (C88 , C87) ) has_least_args_for C88 , C87 by L430 , L195;
L432: C88 ~= D74 by L431 , L137;
L433: ( Name C88 ) = ( Name D74 ) by L432 , L389;
L434: ( Name D74 ) = C86 by L433 , L402;
reconsider D75 = D74 as (Element of C86) by L434 , L402;
take D75;
let C89 being (Element of C86);
assume that
L435: C87 <= ( the_arity_of C89 );
L436: ( Name C89 ) = C86 by L402;
L437: C89 ~= C88 by L436 , L433 , L434 , L389;
thus L438: thesis by L437 , L430 , L435 , L409;
end;
uniqueness
proof
let C90 , C91 being (Element of C86);
assume that
L439: (for B61 being (Element of C86) holds (C87 <= ( the_arity_of B61 ) implies C90 = ( LBound (B61 , C87) )))
and
L440: (for B62 being (Element of C86) holds (C87 <= ( the_arity_of B62 ) implies C91 = ( LBound (B62 , C87) )));
consider C92 being (Element of C86) such that L441: C87 <= ( the_arity_of C92 ) by L429;
L442: C90 = ( LBound (C92 , C87) ) by L441 , L439;
thus L443: thesis by L442 , L441 , L440;
end;
end;
theorem
L445: (for B63 being  regular  monotone OrderSortedSign holds (for B64 being (OperSymbol of B63) holds (for B65 being (Element of ( (the carrier of B63) * )) holds (B65 <= ( the_arity_of B64 ) implies ( LBound (B64 , B65) ) <= B64))))
proof
let C93 being  regular  monotone OrderSortedSign;
let C94 being (OperSymbol of C93);
let C95 being (Element of ( (the carrier of C93) * ));
assume that
L446: C95 <= ( the_arity_of C94 );
set D76 = ( LBound (C94 , C95) );
L447: D76 has_least_rank_for C94 , C95 by L446 , L197;
L448: D76 has_least_sort_for C94 , C95 by L447 , L140;
L449: ( the_result_sort_of D76 ) <= ( the_result_sort_of C94 ) by L448 , L446 , L138;
L450: D76 has_least_args_for C94 , C95 by L447 , L140;
L451: C94 ~= D76 by L450 , L137;
L452: ( the_arity_of D76 ) <= ( the_arity_of C94 ) by L446 , L450 , L137;
thus L453: thesis by L452 , L451 , L449 , L286;
end;
