:: Construction of Rings and Left-, Right-, and Bi-Modules over a Ring
::  by Micha{\l} Muzalewski
::
:: Received June 20, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, ALGSTR_0, VECTSP_1, MESFUNC1, GROUP_1, SUBSET_1,
      RELAT_1, STRUCT_0, RLVECT_1, LATTICES, FUNCSDOM, BINOP_1, SUPINF_2,
      ARYTM_3, ARYTM_1, FUNCT_1, ZFMISC_1, FUNCT_5, MCART_1, VECTSP_2;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, FUNCT_2, BINOP_1, FUNCT_5, STRUCT_0,
      ALGSTR_0, RLVECT_1, GROUP_1, VECTSP_1, FUNCSDOM, FUNCT_3;
 constructors FUNCT_3, VECTSP_1, FUNCSDOM, FUNCT_5;
 registrations XBOOLE_0, STRUCT_0, VECTSP_1, ALGSTR_0;
 requirements SUBSET, BOOLE;
 definitions VECTSP_1, RLVECT_1, STRUCT_0, GROUP_1, ALGSTR_0;
 theorems VECTSP_1, TARSKI, RLVECT_1, GROUP_1, CARD_1, ALGSTR_0;

begin
L1: (for B1 being non  empty multLoopStr holds (B1 is  well-unital implies ( 1. B1 ) = ( 1_ B1 )))
proof
let C1 being non  empty multLoopStr;
assume L2: C1 is  well-unital;
L3: (for B2 being (Element of C1) holds (( B2 * ( 1. C1 ) ) = B2 & ( ( 1. C1 ) * B2 ) = B2)) by L2 , VECTSP_1:def 6;
thus L4: thesis by L3 , L2 , GROUP_1:def 4;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  unital  distributive for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
set D1 = the  strict Field;
L5: D1 is  unital  distributive;
thus L6: thesis by L5;
end;
end;
definition
let C2 being non  empty multLoopStr_0;
attr C2 is  domRing-like
means
:L8: (for B3 , B4 being (Element of C2) holds (( B3 * B4 ) = ( 0. C2 ) implies (B3 = ( 0. C2 ) or B4 = ( 0. C2 ))));
end;
registration
cluster  strict non  degenerated  commutative  almost_left_invertible  domRing-like for Ring;
existence
proof
set D2 = the  strict Field;
L10: (for B5 , B6 being (Scalar of D2) holds (( B5 * B6 ) = ( 0. D2 ) implies (B5 = ( 0. D2 ) or B6 = ( 0. D2 )))) by VECTSP_1:12;
L11: D2 is  domRing-like by L10 , L8;
reconsider D3 = D2 as Ring;
thus L12: thesis by L11;
end;
end;
definition
mode comRing
 is  commutative Ring;
end;
definition
mode domRing
 is  domRing-like non  degenerated comRing;
end;
theorem
L16: (for R2 being Field holds R2 is domRing)
proof
let R2 being Field;
L17: (for B7 , B8 being (Scalar of R2) holds (( B7 * B8 ) = ( 0. R2 ) implies (B7 = ( 0. R2 ) or B8 = ( 0. R2 )))) by VECTSP_1:12;
thus L18: thesis by L17 , L8;
end;
definition
mode Skew-Field
 is non  degenerated  almost_left_invertible Ring;
end;
registration
cluster  commutative  left_unital ->  well-unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence
proof
let C3 being non  empty multLoopStr;
assume L20: C3 is  commutative  left_unital;
let C4 being (Scalar of C3);
L21: (for B9 being  commutative non  empty multMagma holds (for B10 , B11 being (Element of B9) holds ( B10 * B11 ) = ( B11 * B10 )));
L22: ( C4 * ( 1. C3 ) ) = ( ( 1. C3 ) * C4 ) by L21 , L20;
thus L23: thesis by L22 , L20 , VECTSP_1:def 8;
end;
cluster  commutative  right_unital ->  well-unital for non  empty non  empty non  empty non  empty multLoopStr;
coherence
proof
let C5 being non  empty multLoopStr;
assume L24: C5 is  commutative  right_unital;
let C6 being (Element of C5);
L25: (for B12 being  commutative non  empty multMagma holds (for B13 , B14 being (Element of B12) holds ( B13 * B14 ) = ( B14 * B13 )));
L26: ( C6 * ( 1. C5 ) ) = ( ( 1. C5 ) * C6 ) by L25 , L24;
thus L27: thesis by L26 , L24 , VECTSP_1:def 4;
end;
end;
L29: (for R3 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R4 being (Scalar of R3) holds (for R5 being (Scalar of R3) holds (for R6 being (Scalar of R3) holds (( R4 + R5 ) = R6 implies R4 = ( R6 - R5 ))))))
proof
let R3 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R4 being (Scalar of R3);
let R5 being (Scalar of R3);
let R6 being (Scalar of R3);
assume L30: ( R4 + R5 ) = R6;
thus L31: R4 = ( R4 + ( 0. R3 ) ) by RLVECT_1:4
.= ( R4 + ( R5 + ( - R5 ) ) ) by RLVECT_1:def 10
.= ( R6 - R5 ) by L30 , RLVECT_1:def 3;
end;
L32: (for R3 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R4 being (Scalar of R3) holds (for R5 being (Scalar of R3) holds (for R6 being (Scalar of R3) holds (R4 = ( R6 - R5 ) implies ( R4 + R5 ) = R6)))))
proof
let R3 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let R4 being (Scalar of R3);
let R5 being (Scalar of R3);
let R6 being (Scalar of R3);
assume L33: R4 = ( R6 - R5 );
L34: ( R4 + R5 ) = ( R6 + ( R5 + ( - R5 ) ) ) by L33 , RLVECT_1:def 3
.= ( R6 + ( 0. R3 ) ) by RLVECT_1:def 10
.= R6 by RLVECT_1:4;
thus L35: thesis by L34;
end;
theorem
L36: (for R3 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for R4 being (Scalar of R3) holds (for R5 being (Scalar of R3) holds (for R6 being (Scalar of R3) holds ((( R4 + R5 ) = R6 iff R4 = ( R6 - R5 )) & (( R4 + R5 ) = R6 iff R5 = ( R6 - R4 ))))))) by L29 , L32;
theorem
L37: (for B15 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr holds (for B16 being (Element of B15) holds (B16 = ( 0. B15 ) iff ( - B16 ) = ( 0. B15 ))))
proof
let C7 being  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
let C8 being (Element of C7);
thus L38: (C8 = ( 0. C7 ) implies ( - C8 ) = ( 0. C7 )) by RLVECT_1:12;
assume L39: ( - C8 ) = ( 0. C7 );
L40: ( - ( - C8 ) ) = ( 0. C7 ) by L39 , RLVECT_1:12;
thus L41: thesis by L40 , RLVECT_1:17;
end;
theorem
L42: (for B17 being  add-associative  right_zeroed  Abelian  right_complementable non  empty addLoopStr holds (for B18 , B19 being (Element of B17) holds (ex B20 being (Element of B17) st (B18 = ( B19 + B20 ) & B18 = ( B20 + B19 )))))
proof
let C9 being  add-associative  right_zeroed  Abelian  right_complementable non  empty addLoopStr;
let C10 , C11 being (Element of C9);
take D4 = ( ( - C11 ) + C10 );
L43: ( D4 + C11 ) = ( C10 + ( ( - C11 ) + C11 ) ) by RLVECT_1:def 3
.= ( C10 + ( 0. C9 ) ) by RLVECT_1:5
.= C10 by RLVECT_1:4;
thus L44: thesis by L43;
end;
theorem
L45: (for B21 being  add-associative  right_zeroed  right_complementable  distributive non  degenerated non  empty doubleLoopStr holds (for B22 , B23 being (Element of B21) holds (( B22 * B23 ) = ( 1. B21 ) implies (B22 <> ( 0. B21 ) & B23 <> ( 0. B21 ))))) by VECTSP_1:6 , VECTSP_1:7;
theorem
L46: (for B24 being non  degenerated  almost_left_invertible  associative  add-associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr holds (for B25 being (Element of B24) holds (B25 <> ( 0. B24 ) implies (ex B26 being (Element of B24) st ( B25 * B26 ) = ( 1. B24 )))))
proof
let C12 being non  degenerated  almost_left_invertible  associative  add-associative  right_zeroed  right_complementable  well-unital  right_unital  distributive non  empty doubleLoopStr;
let C13 being (Element of C12);
assume L47: C13 <> ( 0. C12 );
consider C14 being (Element of C12) such that L48: ( C14 * C13 ) = ( 1. C12 ) by L47 , VECTSP_1:def 9;
take C14;
L49: C14 <> ( 0. C12 ) by L48 , VECTSP_1:7;
consider C15 being (Element of C12) such that L50: ( C15 * C14 ) = ( 1. C12 ) by L49 , VECTSP_1:def 9;
L51: C15 = ( C15 * ( C14 * C13 ) ) by L48 , VECTSP_1:def 6
.= ( ( 1. C12 ) * C13 ) by L50 , GROUP_1:def 3
.= C13 by VECTSP_1:def 6;
thus L52: thesis by L51 , L50;
end;
theorem
L53: (for B27 being  add-associative  right_zeroed  right_complementable  distributive non  degenerated  almost_left_invertible  associative  well-unital non  empty doubleLoopStr holds (for B28 , B29 being (Element of B27) holds (( B29 * B28 ) = ( 1. B27 ) implies ( B28 * B29 ) = ( 1. B27 ))))
proof
let C16 being non  degenerated  almost_left_invertible  associative  add-associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr;
let C17 , C18 being (Element of C16);
assume L54: ( C18 * C17 ) = ( 1. C16 );
L55: C17 <> ( 0. C16 ) by L54 , VECTSP_1:6;
consider C19 being (Element of C16) such that L56: ( C17 * C19 ) = ( 1_ C16 ) by L55 , L46;
L57: C18 = ( C18 * ( C17 * C19 ) ) by L56 , VECTSP_1:def 4
.= ( ( 1_ C16 ) * C19 ) by L54 , GROUP_1:def 3
.= C19 by VECTSP_1:def 8;
thus L58: thesis by L57 , L56;
end;
theorem
L59: (for B30 being non  degenerated  almost_left_invertible  associative  Abelian  add-associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr holds (for B31 , B32 , B33 being (Element of B30) holds ((( B31 * B32 ) = ( B31 * B33 ) & B31 <> ( 0. B30 )) implies B32 = B33)))
proof
let C20 being non  degenerated  almost_left_invertible  associative  Abelian  add-associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr;
let C21 , C22 , C23 being (Element of C20);
assume that
L60: ( C21 * C22 ) = ( C21 * C23 )
and
L61: C21 <> ( 0. C20 );
consider C24 being (Element of C20) such that L62: ( C21 * C24 ) = ( 1_ C20 ) by L61 , L46;
L63: ( C24 * C21 ) = ( 1_ C20 ) by L62 , L53;
L64: C22 = ( ( C24 * C21 ) * C22 ) by L63 , VECTSP_1:def 8
.= ( C24 * ( C21 * C23 ) ) by L60 , GROUP_1:def 3
.= ( ( 1_ C20 ) * C23 ) by L63 , GROUP_1:def 3
.= C23 by VECTSP_1:def 8;
thus L65: thesis by L64;
end;
definition
let C25 being non  degenerated  almost_left_invertible  associative  add-associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr;
let C26 being (Element of C25);
assume L66: C26 <> ( 0. C25 );
redefine func C26 " means 
:L67: ( it * C26 ) = ( 1. C25 );
compatibility
proof
let C27 being (Element of C25);
L68: C26 is  left_invertible by L66 , ALGSTR_0:def 39;
consider C28 being (Element of C25) such that L69: ( C28 * C26 ) = ( 1. C25 ) by L68 , ALGSTR_0:def 27;
L70: C26 is  right_invertible
proof
take C28;
thus L71: thesis by L69 , L53;
end;
consider C29 being (Element of C25) such that L72: ( C26 * C29 ) = ( 1. C25 ) by L70 , ALGSTR_0:def 28;
L73: C26 is  right_mult-cancelable
proof
let C30 , C31 being (Element of C25);
assume L74: ( C30 * C26 ) = ( C31 * C26 );
thus L75: C30 = ( C30 * ( 1. C25 ) ) by VECTSP_1:def 6
.= ( ( C31 * C26 ) * C29 ) by L72 , L74 , GROUP_1:def 3
.= ( C31 * ( 1. C25 ) ) by L72 , GROUP_1:def 3
.= C31 by VECTSP_1:def 6;
end;
thus L76: thesis by L73 , L68 , ALGSTR_0:def 35;
end;
end;
definition
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
func R8 / R9 -> (Scalar of R7) equals 
( R8 * ( R9 " ) );
correctness;
end;
theorem
L79: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (R8 <> ( 0. R7 ) implies (( R8 * ( R8 " ) ) = ( 1. R7 ) & ( ( R8 " ) * R8 ) = ( 1. R7 )))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
assume L80: R8 <> ( 0. R7 );
L81: ( ( R8 " ) * R8 ) = ( 1_ R7 ) by L80 , L67;
thus L82: thesis by L81 , L53;
end;
theorem
L83: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (( R9 * R8 ) = ( 1_ R7 ) implies (R8 = ( R9 " ) & R9 = ( R8 " ))))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
L84: (( R9 * R8 ) = ( 1_ R7 ) implies R9 = ( R8 " ))
proof
assume L85: ( R9 * R8 ) = ( 1_ R7 );
L86: R8 <> ( 0. R7 ) by L85 , VECTSP_1:6;
thus L87: thesis by L86 , L85 , L67;
end;
L88: (( R9 * R8 ) = ( 1_ R7 ) implies R8 = ( R9 " ))
proof
assume L89: ( R9 * R8 ) = ( 1_ R7 );
L90: (R9 <> ( 0. R7 ) & ( R8 * R9 ) = ( 1_ R7 )) by L89 , L53 , VECTSP_1:7;
thus L91: thesis by L90 , L67;
end;
thus L92: thesis by L88 , L84;
end;
theorem
L93: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds ((R8 <> ( 0. R7 ) & R9 <> ( 0. R7 )) implies ( ( R8 " ) * ( R9 " ) ) = ( ( R9 * R8 ) " )))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
assume L94: R8 <> ( 0. R7 );
assume L95: R9 <> ( 0. R7 );
L96: ( ( ( R8 " ) * ( R9 " ) ) * ( R9 * R8 ) ) = ( ( R8 " ) * ( ( R9 " ) * ( R9 * R8 ) ) ) by GROUP_1:def 3
.= ( ( R8 " ) * ( ( ( R9 " ) * R9 ) * R8 ) ) by GROUP_1:def 3
.= ( ( R8 " ) * ( ( 1_ R7 ) * R8 ) ) by L95 , L79
.= ( ( R8 " ) * R8 ) by VECTSP_1:def 8
.= ( 1_ R7 ) by L94 , L79;
thus L97: thesis by L96 , L83;
end;
theorem
L98: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (( R8 * R9 ) = ( 0. R7 ) implies (R8 = ( 0. R7 ) or R9 = ( 0. R7 ))))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
L99:
now
assume that
L100: ( R8 * R9 ) = ( 0. R7 )
and
L101: R8 <> ( 0. R7 );
L102: ( R8 * R9 ) = ( R8 * ( 0. R7 ) ) by L100 , VECTSP_1:6;
thus L103: R9 = ( 0. R7 ) by L102 , L101 , L59;
end;
thus L104: thesis by L99;
end;
theorem
L105: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (R8 <> ( 0. R7 ) implies ( R8 " ) <> ( 0. R7 ))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
assume L106: R8 <> ( 0. R7 );
assume L107: ( R8 " ) = ( 0. R7 );
L108: ( R8 * ( R8 " ) ) = ( 0. R7 ) by L107 , VECTSP_1:6;
L109: ( 1. R7 ) = ( 0. R7 ) by L108 , L106 , L79;
thus L110: contradiction by L109;
end;
theorem
L111: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (R8 <> ( 0. R7 ) implies ( ( R8 " ) " ) = R8)))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
assume L112: R8 <> ( 0. R7 );
L113: ( R8 " ) <> ( 0. R7 ) by L112 , L105;
L114: ( ( R8 " ) " ) = ( ( ( R8 " ) " ) * ( 1_ R7 ) ) by VECTSP_1:def 4
.= ( ( ( R8 " ) " ) * ( ( R8 " ) * R8 ) ) by L112 , L79
.= ( ( ( ( R8 " ) " ) * ( R8 " ) ) * R8 ) by GROUP_1:def 3;
L115: ( ( R8 " ) " ) = ( ( 1_ R7 ) * R8 ) by L114 , L113 , L79;
thus L116: thesis by L115 , VECTSP_1:def 8;
end;
theorem
L117: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (R8 <> ( 0. R7 ) implies (( ( 1_ R7 ) / R8 ) = ( R8 " ) & ( ( 1_ R7 ) / ( R8 " ) ) = R8))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
L118: (R8 <> ( 0. R7 ) implies ( ( 1_ R7 ) / ( R8 " ) ) = R8)
proof
assume L119: R8 <> ( 0. R7 );
L120: ( ( 1_ R7 ) / ( R8 " ) ) = ( ( R8 " ) " ) by VECTSP_1:def 8
.= R8 by L119 , L111;
thus L121: thesis by L120;
end;
thus L122: thesis by L118 , VECTSP_1:def 8;
end;
theorem
L123: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (R8 <> ( 0. R7 ) implies (( R8 * ( ( 1_ R7 ) / R8 ) ) = ( 1_ R7 ) & ( ( ( 1_ R7 ) / R8 ) * R8 ) = ( 1_ R7 )))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
assume L124: R8 <> ( 0. R7 );
thus L125: ( R8 * ( ( 1_ R7 ) / R8 ) ) = ( R8 * ( R8 " ) ) by L124 , L117
.= ( 1_ R7 ) by L124 , L79;
thus L126: ( ( ( 1_ R7 ) / R8 ) * R8 ) = ( ( R8 " ) * R8 ) by L124 , L117
.= ( 1_ R7 ) by L124 , L79;
end;
theorem
L127: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (R8 <> ( 0. R7 ) implies ( R8 / R8 ) = ( 1_ R7 )))) by L79;
theorem
L128: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (for R10 being (Scalar of R7) holds ((R9 <> ( 0. R7 ) & R10 <> ( 0. R7 )) implies ( R8 / R9 ) = ( ( R8 * R10 ) / ( R9 * R10 ) ))))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
let R10 being (Scalar of R7);
assume L129: R9 <> ( 0. R7 );
assume L130: R10 <> ( 0. R7 );
thus L131: ( R8 / R9 ) = ( ( R8 * ( 1_ R7 ) ) * ( R9 " ) ) by VECTSP_1:def 4
.= ( ( R8 * ( R10 * ( R10 " ) ) ) * ( R9 " ) ) by L130 , L79
.= ( ( ( R8 * R10 ) * ( R10 " ) ) * ( R9 " ) ) by GROUP_1:def 3
.= ( ( R8 * R10 ) * ( ( R10 " ) * ( R9 " ) ) ) by GROUP_1:def 3
.= ( ( R8 * R10 ) / ( R9 * R10 ) ) by L129 , L130 , L93;
end;
theorem
L132: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (R9 <> ( 0. R7 ) implies (( - ( R8 / R9 ) ) = ( ( - R8 ) / R9 ) & ( R8 / ( - R9 ) ) = ( - ( R8 / R9 ) ))))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
assume L133: R9 <> ( 0. R7 );
L134: ( - R9 ) <> ( 0. R7 ) by L133 , L37;
thus L135: ( - ( R8 / R9 ) ) = ( ( - R8 ) / R9 ) by VECTSP_1:9;
L136: ( - ( 1. R7 ) ) <> ( 0. R7 ) by L37;
L137: ( R8 / ( - R9 ) ) = ( ( R8 * ( - ( 1_ R7 ) ) ) / ( ( - R9 ) * ( - ( 1_ R7 ) ) ) ) by L136 , L134 , L128;
L138: ( R8 / ( - R9 ) ) = ( ( - ( R8 * ( 1_ R7 ) ) ) / ( ( - R9 ) * ( - ( 1_ R7 ) ) ) ) by L137 , VECTSP_1:8
.= ( ( - R8 ) / ( ( - R9 ) * ( - ( 1_ R7 ) ) ) ) by VECTSP_1:def 4
.= ( ( - R8 ) / ( - ( ( - R9 ) * ( 1_ R7 ) ) ) ) by VECTSP_1:8
.= ( ( - R8 ) / ( ( - ( - R9 ) ) * ( 1_ R7 ) ) ) by VECTSP_1:9
.= ( ( - R8 ) / ( R9 * ( 1_ R7 ) ) ) by RLVECT_1:17
.= ( - ( R8 / R9 ) ) by L135 , VECTSP_1:def 4;
thus L139: thesis by L138;
end;
theorem
L140: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (for R10 being (Scalar of R7) holds (R10 <> ( 0. R7 ) implies (( ( R8 / R10 ) + ( R9 / R10 ) ) = ( ( R8 + R9 ) / R10 ) & ( ( R8 / R10 ) - ( R9 / R10 ) ) = ( ( R8 - R9 ) / R10 )))))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
let R10 being (Scalar of R7);
L141: (R10 <> ( 0. R7 ) implies ( ( R8 / R10 ) - ( R9 / R10 ) ) = ( ( R8 - R9 ) / R10 ))
proof
assume L142: R10 <> ( 0. R7 );
thus L143: ( ( R8 / R10 ) - ( R9 / R10 ) ) = ( ( R8 / R10 ) + ( ( - R9 ) / R10 ) ) by L142 , L132
.= ( ( R8 - R9 ) / R10 ) by VECTSP_1:def 7;
end;
thus L144: thesis by L141 , VECTSP_1:def 7;
end;
theorem
L145: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (for R10 being (Scalar of R7) holds ((R9 <> ( 0. R7 ) & R10 <> ( 0. R7 )) implies ( R8 / ( R9 / R10 ) ) = ( ( R8 * R10 ) / R9 ))))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
let R10 being (Scalar of R7);
assume L146: R9 <> ( 0. R7 );
assume L147: R10 <> ( 0. R7 );
L148: ( R10 " ) <> ( 0. R7 ) by L147 , L105;
thus L149: ( R8 / ( R9 / R10 ) ) = ( R8 * ( ( ( R10 " ) " ) * ( R9 " ) ) ) by L148 , L146 , L93
.= ( R8 * ( R10 * ( R9 " ) ) ) by L147 , L111
.= ( ( R8 * R10 ) / R9 ) by GROUP_1:def 3;
end;
theorem
L150: (for R7 being Skew-Field holds (for R8 being (Scalar of R7) holds (for R9 being (Scalar of R7) holds (R9 <> ( 0. R7 ) implies ( ( R8 / R9 ) * R9 ) = R8))))
proof
let R7 being Skew-Field;
let R8 being (Scalar of R7);
let R9 being (Scalar of R7);
assume L151: R9 <> ( 0. R7 );
thus L152: ( ( R8 / R9 ) * R9 ) = ( R8 * ( ( R9 " ) * R9 ) ) by GROUP_1:def 3
.= ( R8 * ( 1_ R7 ) ) by L151 , L79
.= R8 by VECTSP_1:def 4;
end;
definition
let C32 being 1-sorted;
struct (addLoopStr) RightModStr over C32(# carrier -> set , addF -> (BinOp of the carrier) , ZeroF -> (Element of the carrier) , rmult -> (Function of [: the carrier , (the carrier of C32) :] , the carrier) #);
end;
registration
let C33 being 1-sorted;
cluster non  empty for RightModStr over C33;
existence
proof
set D5 = the non  empty set;
set D6 = the (BinOp of D5);
set D7 = the (Element of D5);
set D8 = the (Function of [: D5 , (the carrier of C33) :] , D5);
take RightModStr (# D5 , D6 , D7 , D8 #);
thus L154: (the carrier of RightModStr (# D5 , D6 , D7 , D8 #)) is non  empty;
end;
end;
registration
let C34 being 1-sorted;
let C35 being non  empty set;
let C36 being (BinOp of C35);
let C37 being (Element of C35);
let C38 being (Function of [: C35 , (the carrier of C34) :] , C35);
cluster RightModStr (# C35 , C36 , C37 , C38 #) -> non  empty;
coherence;
end;
definition
let R1 being non  empty doubleLoopStr;
let C39 being non  empty RightModStr over R1;
mode Scalar of C39
 is (Element of R1);
mode Vector of C39
 is (Element of C39);
end;
definition
let C40 , C41 being 1-sorted;
struct (VectSpStr over C40 , RightModStr over C41) BiModStr over C40 , C41(# carrier -> set , addF -> (BinOp of the carrier) , ZeroF -> (Element of the carrier) , lmult -> (Function of [: (the carrier of C40) , the carrier :] , the carrier) , rmult -> (Function of [: the carrier , (the carrier of C41) :] , the carrier) #);
end;
registration
let C42 , C43 being 1-sorted;
cluster non  empty for BiModStr over C42 , C43;
existence
proof
set D9 = the non  empty set;
set D10 = the (BinOp of D9);
set D11 = the (Element of D9);
set D12 = the (Function of [: (the carrier of C42) , D9 :] , D9);
set D13 = the (Function of [: D9 , (the carrier of C43) :] , D9);
take BiModStr (# D9 , D10 , D11 , D12 , D13 #);
thus L159: (the carrier of BiModStr (# D9 , D10 , D11 , D12 , D13 #)) is non  empty;
end;
end;
registration
let C44 , C45 being 1-sorted;
let C46 being non  empty set;
let C47 being (BinOp of C46);
let C48 being (Element of C46);
let C49 being (Function of [: (the carrier of C44) , C46 :] , C46);
let C50 being (Function of [: C46 , (the carrier of C45) :] , C46);
cluster BiModStr (# C46 , C47 , C48 , C49 , C50 #) -> non  empty;
coherence;
end;
definition
let C51 being  Abelian  add-associative  right_zeroed  right_complementable non  empty addLoopStr;
func AbGr C51 ->  strict AbGroup equals 
addLoopStr (# (the carrier of C51) , (the addF of C51) , ( 0. C51 ) #);
coherence
proof
reconsider D14 = addLoopStr (# (the carrier of C51) , (the addF of C51) , ( 0. C51 ) #) as non  empty addLoopStr;
L162: (for B34 , B35 , B36 being (Element of D14) holds (( B34 + B35 ) = ( B35 + B34 ) & ( ( B34 + B35 ) + B36 ) = ( B34 + ( B35 + B36 ) ) & ( B34 + ( 0. D14 ) ) = B34 & (ex B37 being (Element of D14) st ( B34 + B37 ) = ( 0. D14 ))))
proof
let C52 , C53 , C54 being (Element of D14);
reconsider D15 = C52 , D16 = C53 , D17 = C54 as (Scalar of C51);
thus L163: ( C52 + C53 ) = ( D16 + D15 ) by RLVECT_1:2
.= ( C53 + C52 );
thus L164: ( ( C52 + C53 ) + C54 ) = ( ( D15 + D16 ) + D17 )
.= ( D15 + ( D16 + D17 ) ) by RLVECT_1:def 3
.= ( C52 + ( C53 + C54 ) );
thus L165: ( C52 + ( 0. D14 ) ) = ( D15 + ( 0. C51 ) )
.= C52 by RLVECT_1:4;
consider C55 being (Scalar of C51) such that L166: ( D15 + C55 ) = ( 0. C51 ) by ALGSTR_0:def 11;
reconsider D18 = C55 as (Element of D14);
take D18;
thus L167: thesis by L166;
end;
L168: D14 is  right_complementable
proof
let C56 being (Element of D14);
reconsider D19 = C56 as (Scalar of C51);
consider C57 being (Scalar of C51) such that L169: ( D19 + C57 ) = ( 0. C51 ) by ALGSTR_0:def 11;
reconsider D20 = C57 as (Element of D14);
take D20;
thus L170: thesis by L169;
end;
thus L171: thesis by L168 , L162 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
end;
end;
deffunc H1(Ring) = VectSpStr (# (the carrier of $1) , (the addF of $1) , ( 0. $1 ) , (the multF of $1) #);
L173: (for R11 being Ring holds H1(R11) is  Abelian  add-associative  right_zeroed  right_complementable)
proof
let R11 being Ring;
L174: (for B38 , B39 , B40 being (Scalar of R11) holds (for B41 , B42 , B43 being (Element of H1(R11)) holds ((B38 = B41 & B39 = B42 & B40 = B43) implies ( B38 + B39 ) = ( B41 + B42 ))));
thus L175: H1(R11) is  Abelian
proof
let C58 , C59 being (Element of H1(R11));
reconsider D21 = C58 , D22 = C59 as (Scalar of R11);
thus L176: ( C58 + C59 ) = ( D22 + D21 ) by L174
.= ( C59 + C58 );
end;

thus L177: H1(R11) is  add-associative
proof
let C60 , C61 , C62 being (Element of H1(R11));
reconsider D23 = C60 , D24 = C61 , D25 = C62 as (Scalar of R11);
thus L178: ( ( C60 + C61 ) + C62 ) = ( ( D23 + D24 ) + D25 )
.= ( D23 + ( D24 + D25 ) ) by RLVECT_1:def 3
.= ( C60 + ( C61 + C62 ) );
end;

thus L179: H1(R11) is  right_zeroed
proof
let C63 being (Element of H1(R11));
reconsider D26 = C63 as (Scalar of R11);
thus L180: ( C63 + ( 0. H1(R11) ) ) = ( D26 + ( 0. R11 ) )
.= C63 by RLVECT_1:4;
end;

let C64 being (Element of H1(R11));
reconsider D27 = C64 as (Scalar of R11);
consider C65 being (Scalar of R11) such that L181: ( D27 + C65 ) = ( 0. R11 ) by ALGSTR_0:def 11;
reconsider D28 = C65 as (Element of H1(R11));
take D28;
thus L182: thesis by L181;
end;
registration
let R11 being Ring;
cluster  Abelian  add-associative  right_zeroed  right_complementable  strict for non  empty non  empty non  empty non  empty VectSpStr over R11;
existence
proof
L183: H1(R11) is  Abelian  add-associative  right_zeroed  right_complementable by L173;
thus L184: thesis by L183;
end;
end;
definition
let R11 being Ring;
func LeftModule R11 ->  Abelian  add-associative  right_zeroed  right_complementable  strict non  empty VectSpStr over R11 equals 
VectSpStr (# (the carrier of R11) , (the addF of R11) , ( 0. R11 ) , (the multF of R11) #);
coherence by L173;
end;
deffunc H2(Ring) = RightModStr (# (the carrier of $1) , (the addF of $1) , ( 0. $1 ) , (the multF of $1) #);
L187: (for R11 being Ring holds H2(R11) is  Abelian  add-associative  right_zeroed  right_complementable)
proof
let R11 being Ring;
L188: (for B44 , B45 , B46 being (Scalar of R11) holds (for B47 , B48 , B49 being (Element of H2(R11)) holds ((B44 = B47 & B45 = B48 & B46 = B49) implies ( B44 + B45 ) = ( B47 + B48 ))));
thus L189: H2(R11) is  Abelian
proof
let C66 , C67 being (Element of H2(R11));
reconsider D29 = C66 , D30 = C67 as (Scalar of R11);
thus L190: ( C66 + C67 ) = ( D30 + D29 ) by L188
.= ( C67 + C66 );
end;

thus L191: H2(R11) is  add-associative
proof
let C68 , C69 , C70 being (Element of H2(R11));
reconsider D31 = C68 , D32 = C69 , D33 = C70 as (Scalar of R11);
thus L192: ( ( C68 + C69 ) + C70 ) = ( ( D31 + D32 ) + D33 )
.= ( D31 + ( D32 + D33 ) ) by RLVECT_1:def 3
.= ( C68 + ( C69 + C70 ) );
end;

thus L193: H2(R11) is  right_zeroed
proof
let C71 being (Element of H2(R11));
reconsider D34 = C71 as (Scalar of R11);
thus L194: ( C71 + ( 0. H2(R11) ) ) = ( D34 + ( 0. R11 ) )
.= C71 by RLVECT_1:4;
end;

let C72 being (Element of H2(R11));
reconsider D35 = C72 as (Scalar of R11);
consider C73 being (Scalar of R11) such that L195: ( D35 + C73 ) = ( 0. R11 ) by ALGSTR_0:def 11;
reconsider D36 = C73 as (Element of H2(R11));
take D36;
thus L196: thesis by L195;
end;
registration
let R11 being Ring;
cluster  Abelian  add-associative  right_zeroed  right_complementable  strict for non  empty non  empty non  empty non  empty RightModStr over R11;
existence
proof
L197: H2(R11) is  Abelian  add-associative  right_zeroed  right_complementable by L187;
thus L198: thesis by L197;
end;
end;
definition
let R11 being Ring;
func RightModule R11 ->  Abelian  add-associative  right_zeroed  right_complementable  strict non  empty RightModStr over R11 equals 
RightModStr (# (the carrier of R11) , (the addF of R11) , ( 0. R11 ) , (the multF of R11) #);
coherence by L187;
end;
definition
let C74 being non  empty 1-sorted;
let C75 being non  empty RightModStr over C74;
let C76 being (Element of C74);
let C77 being (Element of C75);
func C77 * C76 -> (Element of C75) equals 
( (the rmult of C75) . (C77 , C76) );
coherence;
end;
deffunc H3(Ring , Ring) = BiModStr (# 1 , ( op2 ) , ( op0 ) , ( pr2 ((the carrier of $1) , 1) ) , ( pr1 (1 , (the carrier of $2)) ) #);
L202: (for R12 being Ring holds (for R13 being Ring holds H3(R12 , R13) is  Abelian  add-associative  right_zeroed  right_complementable))
proof
let R12 being Ring;
let R13 being Ring;
set D37 = BiModStr (# 1 , ( op2 ) , ( op0 ) , ( pr2 ((the carrier of R12) , 1) ) , ( pr1 (1 , (the carrier of R13)) ) #);
L203:
now
let C78 , C79 , C80 being (Element of D37);
L204: ( C78 + ( 0. D37 ) ) = ( {} ) by CARD_1:49 , TARSKI:def 1;
L205: (( C78 + C79 ) = ( {} ) & ( ( C78 + C79 ) + C80 ) = ( {} )) by CARD_1:49 , TARSKI:def 1;
thus L206: (( C78 + C79 ) = ( C79 + C78 ) & ( ( C78 + C79 ) + C80 ) = ( C78 + ( C79 + C80 ) ) & ( C78 + ( 0. D37 ) ) = C78 & (ex B50 being (Element of D37) st ( C78 + B50 ) = ( 0. D37 ))) by L205 , L204 , CARD_1:49 , TARSKI:def 1;
end;
L207: D37 is  right_complementable
proof
let C81 being (Element of D37);
take C81;
thus L208: thesis by CARD_1:49 , TARSKI:def 1;
end;
thus L209: thesis by L207 , L203 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
end;
registration
let R12 being Ring;
let R13 being Ring;
cluster  Abelian  add-associative  right_zeroed  right_complementable  strict for non  empty non  empty non  empty non  empty BiModStr over R12 , R13;
existence
proof
L210: H3(R12 , R13) is  Abelian  add-associative  right_zeroed  right_complementable by L202;
thus L211: thesis by L210;
end;
end;
definition
let R12 being Ring;
let R13 being Ring;
func BiModule (R12 , R13) ->  Abelian  add-associative  right_zeroed  right_complementable  strict non  empty BiModStr over R12 , R13 equals 
BiModStr (# 1 , ( op2 ) , ( op0 ) , ( pr2 ((the carrier of R12) , 1) ) , ( pr1 (1 , (the carrier of R13)) ) #);
coherence by L202;
end;
theorem
L214: (for R11 being Ring holds (for B51 , B52 being (Scalar of R11) holds (for B53 , B54 being (Vector of ( LeftModule R11 )) holds (( B51 * ( B53 + B54 ) ) = ( ( B51 * B53 ) + ( B51 * B54 ) ) & ( ( B51 + B52 ) * B53 ) = ( ( B51 * B53 ) + ( B52 * B53 ) ) & ( ( B51 * B52 ) * B53 ) = ( B51 * ( B52 * B53 ) ) & ( ( 1. R11 ) * B53 ) = B53))))
proof
let R11 being Ring;
set D38 = (the multF of R11);
set D39 = VectSpStr (# (the carrier of R11) , (the addF of R11) , ( 0. R11 ) , D38 #);
L215: (for B55 , B56 being (Scalar of R11) holds (for B57 , B58 being (Vector of D39) holds (( B55 * ( B57 + B58 ) ) = ( ( B55 * B57 ) + ( B55 * B58 ) ) & ( ( B55 + B56 ) * B57 ) = ( ( B55 * B57 ) + ( B56 * B57 ) ) & ( ( B55 * B56 ) * B57 ) = ( B55 * ( B56 * B57 ) ) & ( ( 1_ R11 ) * B57 ) = B57)))
proof
let C82 , C83 being (Scalar of R11);
let C84 , C85 being (Vector of D39);
reconsider D40 = C84 , D41 = C85 as (Scalar of R11);
thus L216: ( C82 * ( C84 + C85 ) ) = ( C82 * ( D40 + D41 ) )
.= ( ( C82 * D40 ) + ( C82 * D41 ) ) by VECTSP_1:def 7
.= ( ( C82 * C84 ) + ( C82 * C85 ) );
thus L217: ( ( C82 + C83 ) * C84 ) = ( ( C82 + C83 ) * D40 )
.= ( ( C82 * D40 ) + ( C83 * D40 ) ) by VECTSP_1:def 7
.= ( ( C82 * C84 ) + ( C83 * C84 ) );
thus L218: ( ( C82 * C83 ) * C84 ) = ( ( C82 * C83 ) * D40 )
.= ( C82 * ( C83 * D40 ) ) by GROUP_1:def 3
.= ( C82 * ( C83 * C84 ) );
thus L219: ( ( 1_ R11 ) * C84 ) = ( ( 1_ R11 ) * D40 )
.= C84 by VECTSP_1:def 8;
end;
thus L220: thesis by L215;
end;
registration
let R11 being Ring;
cluster  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  Abelian  add-associative  right_zeroed  right_complementable  strict for non  empty non  empty non  empty non  empty VectSpStr over R11;
existence
proof
take ( LeftModule R11 );
thus L221: (for B59 being (Scalar of R11) holds (for B60 , B61 being (Vector of ( LeftModule R11 )) holds ( B59 * ( B60 + B61 ) ) = ( ( B59 * B60 ) + ( B59 * B61 ) ))) by L214;
thus L222: (for B62 , B63 being (Scalar of R11) holds (for B64 being (Vector of ( LeftModule R11 )) holds ( ( B62 + B63 ) * B64 ) = ( ( B62 * B64 ) + ( B63 * B64 ) ))) by L214;
thus L223: (for B65 , B66 being (Scalar of R11) holds (for B67 being (Vector of ( LeftModule R11 )) holds ( ( B65 * B66 ) * B67 ) = ( B65 * ( B66 * B67 ) ))) by L214;
thus L224: (for B68 being (Vector of ( LeftModule R11 )) holds ( ( 1. R11 ) * B68 ) = B68) by L214;
thus L225: thesis;
end;
end;
definition
let R11 being Ring;
mode LeftMod of R11
 is  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R11;
end;
L228: (for R11 being Ring holds ( LeftModule R11 ) is  vector-distributive  scalar-distributive  scalar-associative  scalar-unital)
proof
let R11 being Ring;
thus L229: (for B69 being (Scalar of R11) holds (for B70 , B71 being (Vector of ( LeftModule R11 )) holds ( B69 * ( B70 + B71 ) ) = ( ( B69 * B70 ) + ( B69 * B71 ) ))) by L214;
thus L230: (for B72 , B73 being (Scalar of R11) holds (for B74 being (Vector of ( LeftModule R11 )) holds ( ( B72 + B73 ) * B74 ) = ( ( B72 * B74 ) + ( B73 * B74 ) ))) by L214;
thus L231: (for B75 , B76 being (Scalar of R11) holds (for B77 being (Vector of ( LeftModule R11 )) holds ( ( B75 * B76 ) * B77 ) = ( B75 * ( B76 * B77 ) ))) by L214;
thus L232: (for B78 being (Vector of ( LeftModule R11 )) holds ( ( 1. R11 ) * B78 ) = B78) by L214;
end;
registration
let R11 being Ring;
cluster ( LeftModule R11 ) ->  Abelian  add-associative  right_zeroed  right_complementable  strict  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence by L228;
end;
theorem
L234: (for R11 being Ring holds (for B79 , B80 being (Scalar of R11) holds (for B81 , B82 being (Vector of ( RightModule R11 )) holds (( ( B81 + B82 ) * B79 ) = ( ( B81 * B79 ) + ( B82 * B79 ) ) & ( B81 * ( B79 + B80 ) ) = ( ( B81 * B79 ) + ( B81 * B80 ) ) & ( B81 * ( B80 * B79 ) ) = ( ( B81 * B80 ) * B79 ) & ( B81 * ( 1_ R11 ) ) = B81))))
proof
let R11 being Ring;
set D42 = (the multF of R11);
set D43 = RightModStr (# (the carrier of R11) , (the addF of R11) , ( 0. R11 ) , D42 #);
L235: (for B83 , B84 being (Scalar of R11) holds (for B85 , B86 being (Vector of D43) holds (( ( B85 + B86 ) * B83 ) = ( ( B85 * B83 ) + ( B86 * B83 ) ) & ( B85 * ( B83 + B84 ) ) = ( ( B85 * B83 ) + ( B85 * B84 ) ) & ( B85 * ( B84 * B83 ) ) = ( ( B85 * B84 ) * B83 ) & ( B85 * ( 1_ R11 ) ) = B85)))
proof
let C86 , C87 being (Scalar of R11);
let C88 , C89 being (Vector of D43);
reconsider D44 = C88 , D45 = C89 as (Scalar of R11);
thus L236: ( ( C88 + C89 ) * C86 ) = ( ( D44 + D45 ) * C86 )
.= ( ( D44 * C86 ) + ( D45 * C86 ) ) by VECTSP_1:def 7
.= ( ( C88 * C86 ) + ( C89 * C86 ) );
thus L237: ( C88 * ( C86 + C87 ) ) = ( D44 * ( C86 + C87 ) )
.= ( ( D44 * C86 ) + ( D44 * C87 ) ) by VECTSP_1:def 7
.= ( ( C88 * C86 ) + ( C88 * C87 ) );
thus L238: ( C88 * ( C87 * C86 ) ) = ( D44 * ( C87 * C86 ) )
.= ( ( D44 * C87 ) * C86 ) by GROUP_1:def 3
.= ( ( C88 * C87 ) * C86 );
thus L239: ( C88 * ( 1_ R11 ) ) = ( D44 * ( 1_ R11 ) )
.= C88 by VECTSP_1:def 4;
end;
thus L240: thesis by L235;
end;
definition
let C90 being non  empty doubleLoopStr;
let C91 being non  empty RightModStr over C90;
attr C91 is  RightMod-like
means
:L241: (for B87 , B88 being (Scalar of C90) holds (for B89 , B90 being (Vector of C91) holds (( ( B89 + B90 ) * B87 ) = ( ( B89 * B87 ) + ( B90 * B87 ) ) & ( B89 * ( B87 + B88 ) ) = ( ( B89 * B87 ) + ( B89 * B88 ) ) & ( B89 * ( B88 * B87 ) ) = ( ( B89 * B88 ) * B87 ) & ( B89 * ( 1_ C90 ) ) = B89)));
end;
registration
let R11 being Ring;
cluster  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like  strict for non  empty non  empty non  empty non  empty RightModStr over R11;
existence
proof
take ( RightModule R11 );
thus L243: ( RightModule R11 ) is  Abelian  add-associative  right_zeroed  right_complementable;
thus L244: (for B91 , B92 being (Scalar of R11) holds (for B93 , B94 being (Vector of ( RightModule R11 )) holds (( ( B93 + B94 ) * B91 ) = ( ( B93 * B91 ) + ( B94 * B91 ) ) & ( B93 * ( B91 + B92 ) ) = ( ( B93 * B91 ) + ( B93 * B92 ) ) & ( B93 * ( B92 * B91 ) ) = ( ( B93 * B92 ) * B91 ) & ( B93 * ( 1_ R11 ) ) = B93))) by L234;
thus L245: thesis;
end;
end;
definition
let R11 being Ring;
mode RightMod of R11
 is  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R11;
end;
L248: (for R11 being Ring holds ( RightModule R11 ) is  RightMod-like)
proof
let R11 being Ring;
let C92 , C93 being (Scalar of R11);
let C94 , C95 being (Vector of ( RightModule R11 ));
thus L249: thesis by L234;
end;
registration
let R11 being Ring;
cluster ( RightModule R11 ) ->  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like;
coherence by L248;
end;
L251: (for R12 being Ring holds (for R13 being Ring holds (for B95 , B96 being (Scalar of R12) holds (for B97 , B98 being (Scalar of R13) holds (for B99 , B100 being (Vector of ( BiModule (R12 , R13) )) holds (( B95 * ( B99 + B100 ) ) = ( ( B95 * B99 ) + ( B95 * B100 ) ) & ( ( B95 + B96 ) * B99 ) = ( ( B95 * B99 ) + ( B96 * B99 ) ) & ( ( B95 * B96 ) * B99 ) = ( B95 * ( B96 * B99 ) ) & ( ( 1_ R12 ) * B99 ) = B99 & ( ( B99 + B100 ) * B97 ) = ( ( B99 * B97 ) + ( B100 * B97 ) ) & ( B99 * ( B97 + B98 ) ) = ( ( B99 * B97 ) + ( B99 * B98 ) ) & ( B99 * ( B98 * B97 ) ) = ( ( B99 * B98 ) * B97 ) & ( B99 * ( 1_ R13 ) ) = B99 & ( B95 * ( B99 * B97 ) ) = ( ( B95 * B99 ) * B97 )))))))
proof
let R12 being Ring;
let R13 being Ring;
set D46 = ( {} );
set D47 = ( BiModule (R12 , R13) );
let C96 , C97 being (Scalar of R12);
let C98 , C99 being (Scalar of R13);
let C100 , C101 being (Vector of D47);
L252: (( ( C96 * C97 ) * C100 ) = D46 & ( ( 1_ R12 ) * C100 ) = D46) by CARD_1:49 , TARSKI:def 1;
L253: (( C96 * ( C100 + C101 ) ) = D46 & ( ( C96 + C97 ) * C100 ) = D46) by CARD_1:49 , TARSKI:def 1;
thus L254: (( C96 * ( C100 + C101 ) ) = ( ( C96 * C100 ) + ( C96 * C101 ) ) & ( ( C96 + C97 ) * C100 ) = ( ( C96 * C100 ) + ( C97 * C100 ) ) & ( ( C96 * C97 ) * C100 ) = ( C96 * ( C97 * C100 ) ) & ( ( 1_ R12 ) * C100 ) = C100) by L253 , L252 , CARD_1:49 , TARSKI:def 1;
L255: (( C100 * ( C99 * C98 ) ) = D46 & ( C100 * ( 1_ R13 ) ) = D46) by CARD_1:49 , TARSKI:def 1;
L256: ( C96 * ( C100 * C98 ) ) = D46 by CARD_1:49 , TARSKI:def 1;
L257: (( ( C100 + C101 ) * C98 ) = D46 & ( C100 * ( C98 + C99 ) ) = D46) by CARD_1:49 , TARSKI:def 1;
thus L258: thesis by L257 , L255 , L256 , CARD_1:49 , TARSKI:def 1;
end;
definition
let R12 being Ring;
let R13 being Ring;
let C102 being non  empty BiModStr over R12 , R13;
attr C102 is  BiMod-like
means
:L259: (for B101 being (Scalar of R12) holds (for B102 being (Scalar of R13) holds (for B103 being (Vector of C102) holds ( B101 * ( B103 * B102 ) ) = ( ( B101 * B103 ) * B102 ))));
end;
registration
let R12 being Ring;
let R13 being Ring;
cluster  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  BiMod-like  strict for non  empty non  empty non  empty non  empty BiModStr over R12 , R13;
existence
proof
take ( BiModule (R12 , R13) );
thus L261: ( BiModule (R12 , R13) ) is  Abelian  add-associative  right_zeroed  right_complementable;
L262: (for B104 , B105 being (Scalar of R12) holds (for B106 , B107 being (Scalar of R13) holds (for B108 , B109 being (Vector of ( BiModule (R12 , R13) )) holds (( B104 * ( B108 + B109 ) ) = ( ( B104 * B108 ) + ( B104 * B109 ) ) & ( ( B104 + B105 ) * B108 ) = ( ( B104 * B108 ) + ( B105 * B108 ) ) & ( ( B104 * B105 ) * B108 ) = ( B104 * ( B105 * B108 ) ) & ( ( 1_ R12 ) * B108 ) = B108 & ( ( B108 + B109 ) * B106 ) = ( ( B108 * B106 ) + ( B109 * B106 ) ) & ( B108 * ( B106 + B107 ) ) = ( ( B108 * B106 ) + ( B108 * B107 ) ) & ( B108 * ( B107 * B106 ) ) = ( ( B108 * B107 ) * B106 ) & ( B108 * ( 1_ R13 ) ) = B108 & ( B104 * ( B108 * B106 ) ) = ( ( B104 * B108 ) * B106 ))))) by L251;
thus L263: thesis by L262 , L241 , L259 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
end;
definition
let R12 being Ring;
let R13 being Ring;
mode BiMod of R12 , R13
 is  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  BiMod-like non  empty BiModStr over R12 , R13;
end;
theorem
L266: (for R12 being Ring holds (for R13 being Ring holds (for B110 being non  empty BiModStr over R12 , R13 holds ((for B111 , B112 being (Scalar of R12) holds (for B113 , B114 being (Scalar of R13) holds (for B115 , B116 being (Vector of B110) holds (( B111 * ( B115 + B116 ) ) = ( ( B111 * B115 ) + ( B111 * B116 ) ) & ( ( B111 + B112 ) * B115 ) = ( ( B111 * B115 ) + ( B112 * B115 ) ) & ( ( B111 * B112 ) * B115 ) = ( B111 * ( B112 * B115 ) ) & ( ( 1_ R12 ) * B115 ) = B115 & ( ( B115 + B116 ) * B113 ) = ( ( B115 * B113 ) + ( B116 * B113 ) ) & ( B115 * ( B113 + B114 ) ) = ( ( B115 * B113 ) + ( B115 * B114 ) ) & ( B115 * ( B114 * B113 ) ) = ( ( B115 * B114 ) * B113 ) & ( B115 * ( 1_ R13 ) ) = B115 & ( B111 * ( B115 * B113 ) ) = ( ( B111 * B115 ) * B113 ))))) iff B110 is  RightMod-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  BiMod-like)))) by L241 , L259 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
theorem
L267: (for R12 being Ring holds (for R13 being Ring holds ( BiModule (R12 , R13) ) is (BiMod of R12 , R13)))
proof
let R12 being Ring;
let R13 being Ring;
L268: (for B117 , B118 being (Scalar of R12) holds (for B119 , B120 being (Scalar of R13) holds (for B121 , B122 being (Vector of ( BiModule (R12 , R13) )) holds (( B117 * ( B121 + B122 ) ) = ( ( B117 * B121 ) + ( B117 * B122 ) ) & ( ( B117 + B118 ) * B121 ) = ( ( B117 * B121 ) + ( B118 * B121 ) ) & ( ( B117 * B118 ) * B121 ) = ( B117 * ( B118 * B121 ) ) & ( ( 1_ R12 ) * B121 ) = B121 & ( ( B121 + B122 ) * B119 ) = ( ( B121 * B119 ) + ( B122 * B119 ) ) & ( B121 * ( B119 + B120 ) ) = ( ( B121 * B119 ) + ( B121 * B120 ) ) & ( B121 * ( B120 * B119 ) ) = ( ( B121 * B120 ) * B119 ) & ( B121 * ( 1_ R13 ) ) = B121 & ( B117 * ( B121 * B119 ) ) = ( ( B117 * B121 ) * B119 ))))) by L251;
thus L269: thesis by L268 , L241 , L259 , VECTSP_1:def 14 , VECTSP_1:def 15 , VECTSP_1:def 16 , VECTSP_1:def 17;
end;
registration
let R12 being Ring;
let R13 being Ring;
cluster ( BiModule (R12 , R13) ) ->  Abelian  add-associative  right_zeroed  right_complementable  RightMod-like  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  BiMod-like;
coherence by L267;
end;
theorem
L271: (for B123 being non  empty multLoopStr holds (B123 is  well-unital implies ( 1. B123 ) = ( 1_ B123 ))) by L1;
begin
theorem
L272: (for B124 being  add-associative  right_zeroed  right_complementable  right-distributive  right_unital non  empty doubleLoopStr holds (for B125 being (Element of B124) holds ( B125 * ( - ( 1. B124 ) ) ) = ( - B125 )))
proof
let C103 being  add-associative  right_zeroed  right_complementable  right-distributive  right_unital non  empty doubleLoopStr;
let C104 being (Element of C103);
thus L273: ( C104 * ( - ( 1. C103 ) ) ) = ( C104 * ( ( 0. C103 ) - ( 1. C103 ) ) ) by RLVECT_1:14
.= ( ( C104 * ( 0. C103 ) ) - ( C104 * ( 1. C103 ) ) ) by VECTSP_1:11
.= ( ( 0. C103 ) - ( C104 * ( 1. C103 ) ) ) by VECTSP_1:6
.= ( - ( C104 * ( 1. C103 ) ) ) by RLVECT_1:14
.= ( - C104 ) by VECTSP_1:def 4;
end;
theorem
L274: (for B126 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr holds (for B127 being (Element of B126) holds ( ( - ( 1. B126 ) ) * B127 ) = ( - B127 )))
proof
let C105 being  add-associative  right_zeroed  right_complementable  left-distributive  left_unital non  empty doubleLoopStr;
let C106 being (Element of C105);
thus L275: ( ( - ( 1. C105 ) ) * C106 ) = ( ( ( 0. C105 ) - ( 1. C105 ) ) * C106 ) by RLVECT_1:14
.= ( ( ( 0. C105 ) * C106 ) - ( ( 1. C105 ) * C106 ) ) by VECTSP_1:13
.= ( ( 0. C105 ) - ( ( 1. C105 ) * C106 ) ) by VECTSP_1:7
.= ( - ( ( 1. C105 ) * C106 ) ) by RLVECT_1:14
.= ( - C106 ) by VECTSP_1:def 8;
end;
theorem
L276: (for R15 being non  degenerated  almost_left_invertible Ring holds (for R16 being (Scalar of R15) holds (for R17 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R15 holds (for R18 being (Vector of R17) holds (( R16 * R18 ) = ( 0. R17 ) iff (R16 = ( 0. R15 ) or R18 = ( 0. R17 )))))))
proof
let R15 being non  degenerated  almost_left_invertible Ring;
let R16 being (Scalar of R15);
let R17 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R15;
let R18 being (Vector of R17);
L277: (( R16 * R18 ) = ( 0. R17 ) implies (R16 = ( 0. R15 ) or R18 = ( 0. R17 )))
proof
assume L278: ( R16 * R18 ) = ( 0. R17 );
L279: ( ( ( R16 " ) * R16 ) * R18 ) = ( ( R16 " ) * ( 0. R17 ) ) by L278 , VECTSP_1:def 16
.= ( 0. R17 ) by VECTSP_1:14;
assume L280: R16 <> ( 0. R15 );
L281: ( 0. R17 ) = ( ( 1_ R15 ) * R18 ) by L280 , L279 , L79;
thus L282: thesis by L281 , VECTSP_1:def 17;
end;
thus L283: thesis by L277 , VECTSP_1:14;
end;
theorem
L284: (for R15 being non  degenerated  almost_left_invertible Ring holds (for R16 being (Scalar of R15) holds (for R17 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R15 holds (for R18 being (Vector of R17) holds (R16 <> ( 0. R15 ) implies ( ( R16 " ) * ( R16 * R18 ) ) = R18)))))
proof
let R15 being non  degenerated  almost_left_invertible Ring;
let R16 being (Scalar of R15);
let R17 being  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R15;
let R18 being (Vector of R17);
assume L285: R16 <> ( 0. R15 );
L286: ( ( R16 " ) * ( R16 * R18 ) ) = ( ( ( R16 " ) * R16 ) * R18 ) by VECTSP_1:def 16
.= ( ( 1_ R15 ) * R18 ) by L285 , L79
.= R18 by VECTSP_1:def 17;
thus L287: thesis by L286;
end;
theorem
L288: (for R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr holds (for R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14 holds (for R20 being (Scalar of R14) holds (for R21 being (Vector of R19) holds (( R21 * ( 0. R14 ) ) = ( 0. R19 ) & ( R21 * ( - ( 1_ R14 ) ) ) = ( - R21 ) & ( ( 0. R19 ) * R20 ) = ( 0. R19 ))))))
proof
let R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr;
let R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14;
let R20 being (Scalar of R14);
let R21 being (Vector of R19);
L289: ( R21 + ( R21 * ( 0. R14 ) ) ) = ( ( R21 * ( 1_ R14 ) ) + ( R21 * ( 0. R14 ) ) ) by L241
.= ( R21 * ( ( 1_ R14 ) + ( 0. R14 ) ) ) by L241
.= ( R21 * ( 1_ R14 ) ) by RLVECT_1:4
.= R21 by L241
.= ( R21 + ( 0. R19 ) ) by RLVECT_1:4;
thus L290: ( R21 * ( 0. R14 ) ) = ( 0. R19 ) by L289 , RLVECT_1:8;
L291: ( ( R21 * ( - ( 1_ R14 ) ) ) + R21 ) = ( ( R21 * ( - ( 1_ R14 ) ) ) + ( R21 * ( 1_ R14 ) ) ) by L241
.= ( R21 * ( ( - ( 1_ R14 ) ) + ( 1_ R14 ) ) ) by L241
.= ( 0. R19 ) by L290 , RLVECT_1:5;
L292: ( ( R21 * ( - ( 1_ R14 ) ) ) + ( R21 + ( - R21 ) ) ) = ( ( 0. R19 ) + ( - R21 ) ) by L291 , RLVECT_1:def 3;
L293: ( ( 0. R19 ) + ( - R21 ) ) = ( ( R21 * ( - ( 1_ R14 ) ) ) + ( 0. R19 ) ) by L292 , RLVECT_1:5
.= ( R21 * ( - ( 1_ R14 ) ) ) by RLVECT_1:4;
thus L294: ( R21 * ( - ( 1_ R14 ) ) ) = ( - R21 ) by L293 , RLVECT_1:4;
L295: ( ( 0. R19 ) * R20 ) = ( R21 * ( ( 0. R14 ) * R20 ) ) by L290 , L241
.= ( 0. R19 ) by L290 , VECTSP_1:7;
thus L296: thesis by L295;
end;
theorem
L297: (for R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr holds (for R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14 holds (for R20 being (Scalar of R14) holds (for R21 being (Vector of R19) holds (for R22 being (Vector of R19) holds (( - ( R21 * R20 ) ) = ( R21 * ( - R20 ) ) & ( R22 - ( R21 * R20 ) ) = ( R22 + ( R21 * ( - R20 ) ) )))))))
proof
let R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr;
let R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14;
let R20 being (Scalar of R14);
let R21 being (Vector of R19);
let R22 being (Vector of R19);
L298: ( - ( R21 * R20 ) ) = ( ( R21 * R20 ) * ( - ( 1_ R14 ) ) ) by L288
.= ( R21 * ( R20 * ( - ( 1_ R14 ) ) ) ) by L241
.= ( R21 * ( - ( R20 * ( 1_ R14 ) ) ) ) by VECTSP_1:8;
thus L299: ( - ( R21 * R20 ) ) = ( R21 * ( - R20 ) ) by L298 , VECTSP_1:def 4;
thus L300: thesis by L298 , VECTSP_1:def 4;
end;
theorem
L301: (for R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr holds (for R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14 holds (for R20 being (Scalar of R14) holds (for R21 being (Vector of R19) holds ( ( - R21 ) * R20 ) = ( - ( R21 * R20 ) )))))
proof
let R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr;
let R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14;
let R20 being (Scalar of R14);
let R21 being (Vector of R19);
L302: ( ( - R21 ) * R20 ) = ( ( R21 * ( - ( 1_ R14 ) ) ) * R20 ) by L288
.= ( R21 * ( ( - ( 1_ R14 ) ) * R20 ) ) by L241
.= ( R21 * ( - ( ( 1_ R14 ) * R20 ) ) ) by VECTSP_1:9
.= ( R21 * ( - R20 ) ) by VECTSP_1:def 8;
thus L303: thesis by L302 , L297;
end;
theorem
L304: (for R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr holds (for R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14 holds (for R20 being (Scalar of R14) holds (for R21 being (Vector of R19) holds (for R22 being (Vector of R19) holds ( ( R21 - R22 ) * R20 ) = ( ( R21 * R20 ) - ( R22 * R20 ) ))))))
proof
let R14 being  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  right_unital  distributive non  empty doubleLoopStr;
let R19 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R14;
let R20 being (Scalar of R14);
let R21 being (Vector of R19);
let R22 being (Vector of R19);
L305: ( ( R21 - R22 ) * R20 ) = ( ( R21 + ( - R22 ) ) * R20 )
.= ( ( R21 * R20 ) + ( ( - R22 ) * R20 ) ) by L241
.= ( ( R21 * R20 ) + ( - ( R22 * R20 ) ) ) by L301;
thus L306: thesis by L305;
end;
theorem
L307: (for R23 being non  degenerated  almost_left_invertible Ring holds (for R24 being (Scalar of R23) holds (for R25 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R23 holds (for R26 being (Vector of R25) holds (( R26 * R24 ) = ( 0. R25 ) iff (R24 = ( 0. R23 ) or R26 = ( 0. R25 )))))))
proof
let R23 being non  degenerated  almost_left_invertible Ring;
let R24 being (Scalar of R23);
let R25 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R23;
let R26 being (Vector of R25);
L308: (( R26 * R24 ) = ( 0. R25 ) implies (R24 = ( 0. R23 ) or R26 = ( 0. R25 )))
proof
assume L309: ( R26 * R24 ) = ( 0. R25 );
L310: ( R26 * ( R24 * ( R24 " ) ) ) = ( ( 0. R25 ) * ( R24 " ) ) by L309 , L241
.= ( 0. R25 ) by L288;
assume L311: R24 <> ( 0. R23 );
L312: ( 0. R25 ) = ( R26 * ( 1_ R23 ) ) by L311 , L310 , L79;
thus L313: thesis by L312 , L241;
end;
thus L314: thesis by L308 , L288;
end;
theorem
L315: (for R23 being non  degenerated  almost_left_invertible Ring holds (for R24 being (Scalar of R23) holds (for R25 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R23 holds (for R26 being (Vector of R25) holds (R24 <> ( 0. R23 ) implies ( ( R26 * R24 ) * ( R24 " ) ) = R26)))))
proof
let R23 being non  degenerated  almost_left_invertible Ring;
let R24 being (Scalar of R23);
let R25 being  add-associative  right_zeroed  right_complementable  RightMod-like non  empty RightModStr over R23;
let R26 being (Vector of R25);
assume L316: R24 <> ( 0. R23 );
L317: ( ( R26 * R24 ) * ( R24 " ) ) = ( R26 * ( R24 * ( R24 " ) ) ) by L241
.= ( R26 * ( 1_ R23 ) ) by L316 , L79
.= R26 by L241;
thus L318: thesis by L317;
end;
