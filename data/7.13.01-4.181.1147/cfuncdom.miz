:: Complex Valued Function's Space
::  by Noboru Endou
::
:: Received March 18, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, SUBSET_1, FUNCT_2, NUMBERS, BINOP_1, FUNCT_1, BINOP_2,
      RELAT_1, ZFMISC_1, CFUNCT_1, FUNCOP_1, CARD_1, COMPLEX1, ARYTM_3,
      RLVECT_1, CLVECT_1, ARYTM_1, ALGSTR_0, SUPINF_2, CLOPBAN1, STRUCT_0,
      GROUP_1, MESFUNC1, FUNCSDOM, VECTSP_1, CFUNCDOM;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      FUNCT_2, BINOP_1, DOMAIN_1, FUNCOP_1, BINOP_2, STRUCT_0, ALGSTR_0,
      RLVECT_1, COMPLEX1, CFUNCT_1, GROUP_1, VECTSP_1, FUNCSDOM, CLVECT_1;
 constructors DOMAIN_1, BINOP_2, COMPLEX1, FUNCSDOM, CLVECT_1, VECTSP_1,
      RELSET_1;
 registrations XBOOLE_0, RELSET_1, NUMBERS, VECTSP_1, CLVECT_1, ALGSTR_0,
      XCMPLX_0;
 requirements SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, STRUCT_0, GROUP_1, CLVECT_1, BINOP_1, ALGSTR_0,
      VECTSP_1;
 theorems FUNCT_2, BINOP_1, FUNCOP_1, RLVECT_1, VECTSP_1, TARSKI, COMPLEX1,
      BINOP_2, GROUP_1, ALGSTR_0, XCMPLX_0;
 schemes BINOP_1, FUNCT_2;

begin
definition
let R4 being non  empty set;
func ComplexFuncAdd R4 -> (BinOp of ( Funcs (R4 , ( COMPLEX )) )) means 
:L1: (for B1 , B2 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( it . (B1 , B2) ) = ( ( addcomplex ) .: (B1 , B2) ));
existence
proof
deffunc H1((Element of ( Funcs (R4 , ( COMPLEX )) )) , (Element of ( Funcs (R4 , ( COMPLEX )) ))) = ( ( addcomplex ) .: ($1 , $2) );
consider C1 being (BinOp of ( Funcs (R4 , ( COMPLEX )) )) such that L2: (for B3 , B4 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C1 . (B3 , B4) ) = H1(B3 , B4)) from BINOP_1:sch 4;
take C1;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L3: thesis by L2;
end;
uniqueness
proof
let C2 , C3 being (BinOp of ( Funcs (R4 , ( COMPLEX )) ));
assume that
L4: (for B5 , B6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C2 . (B5 , B6) ) = ( ( addcomplex ) .: (B5 , B6) ))
and
L5: (for B7 , B8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C3 . (B7 , B8) ) = ( ( addcomplex ) .: (B7 , B8) ));
L6:
now
let C4 , C5 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L7: ( C2 . (C4 , C5) ) = ( ( addcomplex ) .: (C4 , C5) ) by L4
.= ( C3 . (C4 , C5) ) by L5;
end;
thus L8: thesis by L6 , BINOP_1:2;
end;
end;
definition
let R4 being non  empty set;
func ComplexFuncMult R4 -> (BinOp of ( Funcs (R4 , ( COMPLEX )) )) means 
:L10: (for B9 , B10 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( it . (B9 , B10) ) = ( ( multcomplex ) .: (B9 , B10) ));
existence
proof
deffunc H2((Element of ( Funcs (R4 , ( COMPLEX )) )) , (Element of ( Funcs (R4 , ( COMPLEX )) ))) = ( ( multcomplex ) .: ($1 , $2) );
consider C6 being (BinOp of ( Funcs (R4 , ( COMPLEX )) )) such that L11: (for B11 , B12 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C6 . (B11 , B12) ) = H2(B11 , B12)) from BINOP_1:sch 4;
take C6;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L12: thesis by L11;
end;
uniqueness
proof
let C7 , C8 being (BinOp of ( Funcs (R4 , ( COMPLEX )) ));
assume that
L13: (for B13 , B14 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C7 . (B13 , B14) ) = ( ( multcomplex ) .: (B13 , B14) ))
and
L14: (for B15 , B16 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C8 . (B15 , B16) ) = ( ( multcomplex ) .: (B15 , B16) ));
L15:
now
let C9 , C10 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L16: ( C7 . (C9 , C10) ) = ( ( multcomplex ) .: (C9 , C10) ) by L13
.= ( C8 . (C9 , C10) ) by L14;
end;
thus L17: thesis by L15 , BINOP_1:2;
end;
end;
definition
let R4 being non  empty set;
func ComplexFuncExtMult R4 -> (Function of [: ( COMPLEX ) , ( Funcs (R4 , ( COMPLEX )) ) :] , ( Funcs (R4 , ( COMPLEX )) )) means 
:L19: (for B17 being (Element of ( COMPLEX )) holds (for B18 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for B19 being (Element of R4) holds ( ( it . [ B17 , B18 ] ) . B19 ) = ( B17 * ( B18 . B19 ) ))));
existence
proof
deffunc H3((Element of ( COMPLEX )) , (Element of ( Funcs (R4 , ( COMPLEX )) ))) = ( ( multcomplex ) [;] ($1 , $2) );
consider C11 being (Function of [: ( COMPLEX ) , ( Funcs (R4 , ( COMPLEX )) ) :] , ( Funcs (R4 , ( COMPLEX )) )) such that L20: (for B20 being (Element of ( COMPLEX )) holds (for B21 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( C11 . (B20 , B21) ) = H3(B20 , B21))) from BINOP_1:sch 4;
take C11;
let C12 being (Element of ( COMPLEX ));
let C13 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let C14 being (Element of R4);
L21: ( C11 . (C12 , C13) ) = ( ( multcomplex ) [;] (C12 , C13) ) by L20;
thus L22: ( ( C11 . [ C12 , C13 ] ) . C14 ) = ( ( multcomplex ) . (C12 , ( C13 . C14 )) ) by L21 , FUNCOP_1:53
.= ( C12 * ( C13 . C14 ) ) by BINOP_2:def 5;
end;
uniqueness
proof
let C15 , C16 being (Function of [: ( COMPLEX ) , ( Funcs (R4 , ( COMPLEX )) ) :] , ( Funcs (R4 , ( COMPLEX )) ));
assume that
L23: (for B22 being (Element of ( COMPLEX )) holds (for B23 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for B24 being (Element of R4) holds ( ( C15 . [ B22 , B23 ] ) . B24 ) = ( B22 * ( B23 . B24 ) ))))
and
L24: (for B25 being (Element of ( COMPLEX )) holds (for B26 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for B27 being (Element of R4) holds ( ( C16 . [ B25 , B26 ] ) . B27 ) = ( B25 * ( B26 . B27 ) ))));
L25:
now
let C17 being (Element of ( COMPLEX ));
let C18 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L26:
now
let C19 being (Element of R4);
thus L27: ( ( C15 . [ C17 , C18 ] ) . C19 ) = ( C17 * ( C18 . C19 ) ) by L23
.= ( ( C16 . [ C17 , C18 ] ) . C19 ) by L24;
end;
thus L28: ( C15 . (C17 , C18) ) = ( C16 . (C17 , C18) ) by L26 , FUNCT_2:63;
end;
thus L29: thesis by L25 , BINOP_1:2;
end;
end;
definition
let R4 being non  empty set;
func ComplexFuncZero R4 -> (Element of ( Funcs (R4 , ( COMPLEX )) )) equals 
( R4 --> ( 0 ) );
coherence
proof
L31: ( R4 --> ( 0c ) ) is (Function of R4 , ( COMPLEX ));
thus L32: thesis by L31 , FUNCT_2:8;
end;
end;
definition
let R4 being non  empty set;
func ComplexFuncUnit R4 -> (Element of ( Funcs (R4 , ( COMPLEX )) )) equals 
( R4 --> ( 1r ) );
coherence by FUNCT_2:8;
end;
L35: (for R4 being non  empty set holds (for R5 being non  empty set holds (for B28 being (Element of R4) holds (for B29 being (Function of R4 , R5) holds B28 in ( dom B29 )))))
proof
let R4 being non  empty set;
let R5 being non  empty set;
let C20 being (Element of R4);
let C21 being (Function of R4 , R5);
L36: C20 in R4;
thus L37: thesis by L36 , FUNCT_2:def 1;
end;
theorem
L38: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (R8 = ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) iff (for B30 being (Element of R4) holds ( R8 . B30 ) = ( ( R6 . B30 ) + ( R7 . B30 ) )))))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L39:
now
assume L40: (for B31 being (Element of R4) holds ( R8 . B31 ) = ( ( R6 . B31 ) + ( R7 . B31 ) ));
L41:
now
let C22 being (Element of R4);
L42: C22 in ( dom ( ( addcomplex ) .: (R6 , R7) ) ) by L35;
thus L43: ( ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) . C22 ) = ( ( ( addcomplex ) .: (R6 , R7) ) . C22 ) by L1
.= ( ( addcomplex ) . (( R6 . C22 ) , ( R7 . C22 )) ) by L42 , FUNCOP_1:22
.= ( ( R6 . C22 ) + ( R7 . C22 ) ) by BINOP_2:def 3
.= ( R8 . C22 ) by L40;
end;
thus L44: R8 = ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) by L41 , FUNCT_2:63;
end;
L45:
now
assume L46: R8 = ( ( ComplexFuncAdd R4 ) . (R6 , R7) );
let C23 being (Element of R4);
L47: C23 in ( dom ( ( addcomplex ) .: (R6 , R7) ) ) by L35;
thus L48: ( R8 . C23 ) = ( ( ( addcomplex ) .: (R6 , R7) ) . C23 ) by L46 , L1
.= ( ( addcomplex ) . (( R6 . C23 ) , ( R7 . C23 )) ) by L47 , FUNCOP_1:22
.= ( ( R6 . C23 ) + ( R7 . C23 ) ) by BINOP_2:def 3;
end;
thus L49: thesis by L45 , L39;
end;
theorem
L50: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (R8 = ( ( ComplexFuncMult R4 ) . (R6 , R7) ) iff (for B32 being (Element of R4) holds ( R8 . B32 ) = ( ( R6 . B32 ) * ( R7 . B32 ) )))))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L51:
now
assume L52: (for B33 being (Element of R4) holds ( R8 . B33 ) = ( ( R6 . B33 ) * ( R7 . B33 ) ));
L53:
now
let C24 being (Element of R4);
L54: C24 in ( dom ( ( multcomplex ) .: (R6 , R7) ) ) by L35;
thus L55: ( ( ( ComplexFuncMult R4 ) . (R6 , R7) ) . C24 ) = ( ( ( multcomplex ) .: (R6 , R7) ) . C24 ) by L10
.= ( ( multcomplex ) . (( R6 . C24 ) , ( R7 . C24 )) ) by L54 , FUNCOP_1:22
.= ( ( R6 . C24 ) * ( R7 . C24 ) ) by BINOP_2:def 5
.= ( R8 . C24 ) by L52;
end;
thus L56: R8 = ( ( ComplexFuncMult R4 ) . (R6 , R7) ) by L53 , FUNCT_2:63;
end;
L57:
now
assume L58: R8 = ( ( ComplexFuncMult R4 ) . (R6 , R7) );
let C25 being (Element of R4);
L59: C25 in ( dom ( ( multcomplex ) .: (R6 , R7) ) ) by L35;
thus L60: ( R8 . C25 ) = ( ( ( multcomplex ) .: (R6 , R7) ) . C25 ) by L58 , L10
.= ( ( multcomplex ) . (( R6 . C25 ) , ( R7 . C25 )) ) by L59 , FUNCOP_1:22
.= ( ( R6 . C25 ) * ( R7 . C25 ) ) by BINOP_2:def 5;
end;
thus L61: thesis by L57 , L51;
end;
theorem
L62: (for R4 being non  empty set holds ( ComplexFuncZero R4 ) <> ( ComplexFuncUnit R4 ))
proof
let R4 being non  empty set;
set D1 = the (Element of R4);
L63: ( ( ComplexFuncZero R4 ) . D1 ) = ( 0c ) by FUNCOP_1:7;
thus L64: thesis by L63 , COMPLEX1:def 4 , FUNCOP_1:7;
end;
theorem
L65: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R9 being (Element of ( COMPLEX )) holds (R8 = ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) iff (for B34 being (Element of R4) holds ( R8 . B34 ) = ( R9 * ( R6 . B34 ) )))))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R9 being (Element of ( COMPLEX ));
thus L66: (R8 = ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) implies (for B35 being (Element of R4) holds ( R8 . B35 ) = ( R9 * ( R6 . B35 ) ))) by L19;
L67:
now
assume L68: (for B36 being (Element of R4) holds ( R8 . B36 ) = ( R9 * ( R6 . B36 ) ));
L69: (for B37 being (Element of R4) holds ( R8 . B37 ) = ( ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) . B37 ))
proof
let C26 being (Element of R4);
thus L70: ( R8 . C26 ) = ( R9 * ( R6 . C26 ) ) by L68
.= ( ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) . C26 ) by L19;
end;
thus L71: R8 = ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) by L69 , FUNCT_2:63;
end;
thus L72: thesis by L67;
end;
theorem
L73: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) = ( ( ComplexFuncAdd R4 ) . (R7 , R6) ))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L74:
now
let C27 being (Element of R4);
thus L75: ( ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) . C27 ) = ( ( R7 . C27 ) + ( R6 . C27 ) ) by L38
.= ( ( ( ComplexFuncAdd R4 ) . (R7 , R6) ) . C27 ) by L38;
end;
thus L76: thesis by L74 , FUNCT_2:63;
end;
theorem
L77: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncAdd R4 ) . (R6 , ( ( ComplexFuncAdd R4 ) . (R7 , R8) )) ) = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncAdd R4 ) . (R6 , R7) ) , R8) )))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L78:
now
let C28 being (Element of R4);
thus L79: ( ( ( ComplexFuncAdd R4 ) . (R6 , ( ( ComplexFuncAdd R4 ) . (R7 , R8) )) ) . C28 ) = ( ( R6 . C28 ) + ( ( ( ComplexFuncAdd R4 ) . (R7 , R8) ) . C28 ) ) by L38
.= ( ( R6 . C28 ) + ( ( R7 . C28 ) + ( R8 . C28 ) ) ) by L38
.= ( ( ( R6 . C28 ) + ( R7 . C28 ) ) + ( R8 . C28 ) )
.= ( ( ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) . C28 ) + ( R8 . C28 ) ) by L38
.= ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncAdd R4 ) . (R6 , R7) ) , R8) ) . C28 ) by L38;
end;
thus L80: thesis by L78 , FUNCT_2:63;
end;
theorem
L81: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncMult R4 ) . (R6 , R7) ) = ( ( ComplexFuncMult R4 ) . (R7 , R6) ))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L82:
now
let C29 being (Element of R4);
thus L83: ( ( ( ComplexFuncMult R4 ) . (R6 , R7) ) . C29 ) = ( ( R7 . C29 ) * ( R6 . C29 ) ) by L50
.= ( ( ( ComplexFuncMult R4 ) . (R7 , R6) ) . C29 ) by L50;
end;
thus L84: thesis by L82 , FUNCT_2:63;
end;
theorem
L85: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncMult R4 ) . (R6 , ( ( ComplexFuncMult R4 ) . (R7 , R8) )) ) = ( ( ComplexFuncMult R4 ) . (( ( ComplexFuncMult R4 ) . (R6 , R7) ) , R8) )))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L86:
now
let C30 being (Element of R4);
thus L87: ( ( ( ComplexFuncMult R4 ) . (R6 , ( ( ComplexFuncMult R4 ) . (R7 , R8) )) ) . C30 ) = ( ( R6 . C30 ) * ( ( ( ComplexFuncMult R4 ) . (R7 , R8) ) . C30 ) ) by L50
.= ( ( R6 . C30 ) * ( ( R7 . C30 ) * ( R8 . C30 ) ) ) by L50
.= ( ( ( R6 . C30 ) * ( R7 . C30 ) ) * ( R8 . C30 ) )
.= ( ( ( ( ComplexFuncMult R4 ) . (R6 , R7) ) . C30 ) * ( R8 . C30 ) ) by L50
.= ( ( ( ComplexFuncMult R4 ) . (( ( ComplexFuncMult R4 ) . (R6 , R7) ) , R8) ) . C30 ) by L50;
end;
thus L88: thesis by L86 , FUNCT_2:63;
end;
theorem
L89: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncMult R4 ) . (( ComplexFuncUnit R4 ) , R6) ) = R6))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L90:
now
let C31 being (Element of R4);
thus L91: ( ( ( ComplexFuncMult R4 ) . (( ComplexFuncUnit R4 ) , R6) ) . C31 ) = ( ( ( ComplexFuncUnit R4 ) . C31 ) * ( R6 . C31 ) ) by L50
.= ( ( 1r ) * ( R6 . C31 ) ) by FUNCOP_1:7
.= ( R6 . C31 ) by COMPLEX1:def 4;
end;
thus L92: thesis by L90 , FUNCT_2:63;
end;
theorem
L93: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncAdd R4 ) . (( ComplexFuncZero R4 ) , R6) ) = R6))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L94:
now
let C32 being (Element of R4);
thus L95: ( ( ( ComplexFuncAdd R4 ) . (( ComplexFuncZero R4 ) , R6) ) . C32 ) = ( ( ( ComplexFuncZero R4 ) . C32 ) + ( R6 . C32 ) ) by L38
.= ( ( 0c ) + ( R6 . C32 ) ) by FUNCOP_1:7
.= ( R6 . C32 );
end;
thus L96: thesis by L94 , FUNCT_2:63;
end;
theorem
L97: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncAdd R4 ) . (R6 , ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , R6 ] )) ) = ( ComplexFuncZero R4 )))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L98:
now
let C33 being (Element of R4);
set D2 = ( R6 . C33 );
thus L99: ( ( ( ComplexFuncAdd R4 ) . (R6 , ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , R6 ] )) ) . C33 ) = ( ( R6 . C33 ) + ( ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , R6 ] ) . C33 ) ) by L38
.= ( ( R6 . C33 ) + ( ( - ( 1r ) ) * D2 ) ) by L65
.= ( ( ComplexFuncZero R4 ) . C33 ) by COMPLEX1:def 4 , FUNCOP_1:7;
end;
thus L100: thesis by L98 , FUNCT_2:63;
end;
theorem
L101: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncExtMult R4 ) . [ ( 1r ) , R6 ] ) = R6))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L102:
now
let C34 being (Element of R4);
thus L103: ( ( ( ComplexFuncExtMult R4 ) . [ ( 1r ) , R6 ] ) . C34 ) = ( ( 1r ) * ( R6 . C34 ) ) by L65
.= ( R6 . C34 ) by COMPLEX1:def 4;
end;
thus L104: thesis by L102 , FUNCT_2:63;
end;
theorem
L105: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for B38 , B39 being Complex holds ( ( ComplexFuncExtMult R4 ) . [ B38 , ( ( ComplexFuncExtMult R4 ) . [ B39 , R6 ] ) ] ) = ( ( ComplexFuncExtMult R4 ) . [ ( B38 * B39 ) , R6 ] ))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let C35 , C36 being Complex;
reconsider D3 = C35 , D4 = C36 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
L106:
now
let C37 being (Element of R4);
thus L107: ( ( ( ComplexFuncExtMult R4 ) . [ D3 , ( ( ComplexFuncExtMult R4 ) . [ D4 , R6 ] ) ] ) . C37 ) = ( D3 * ( ( ( ComplexFuncExtMult R4 ) . [ D4 , R6 ] ) . C37 ) ) by L65
.= ( D3 * ( D4 * ( R6 . C37 ) ) ) by L65
.= ( ( D3 * D4 ) * ( R6 . C37 ) )
.= ( ( ( ComplexFuncExtMult R4 ) . [ ( D3 * D4 ) , R6 ] ) . C37 ) by L65;
end;
thus L108: thesis by L106 , FUNCT_2:63;
end;
theorem
L109: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for B40 , B41 being Complex holds ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ B40 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ B41 , R6 ] )) ) = ( ( ComplexFuncExtMult R4 ) . [ ( B40 + B41 ) , R6 ] ))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let C38 , C39 being Complex;
reconsider D5 = C38 , D6 = C39 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
L110:
now
let C40 being (Element of R4);
thus L111: ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ D5 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ D6 , R6 ] )) ) . C40 ) = ( ( ( ( ComplexFuncExtMult R4 ) . [ D5 , R6 ] ) . C40 ) + ( ( ( ComplexFuncExtMult R4 ) . [ D6 , R6 ] ) . C40 ) ) by L38
.= ( ( D5 * ( R6 . C40 ) ) + ( ( ( ComplexFuncExtMult R4 ) . [ D6 , R6 ] ) . C40 ) ) by L65
.= ( ( D5 * ( R6 . C40 ) ) + ( D6 * ( R6 . C40 ) ) ) by L65
.= ( ( D5 + D6 ) * ( R6 . C40 ) )
.= ( ( ( ComplexFuncExtMult R4 ) . [ ( D5 + D6 ) , R6 ] ) . C40 ) by L65;
end;
thus L112: thesis by L110 , FUNCT_2:63;
end;
L113: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for B42 being Complex holds ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ B42 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ B42 , R7 ] )) ) = ( ( ComplexFuncExtMult R4 ) . [ B42 , ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) ] )))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let C41 being Complex;
reconsider D7 = C41 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
L114:
now
let C42 being (Element of R4);
thus L115: ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ D7 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ D7 , R7 ] )) ) . C42 ) = ( ( ( ( ComplexFuncExtMult R4 ) . [ D7 , R6 ] ) . C42 ) + ( ( ( ComplexFuncExtMult R4 ) . [ D7 , R7 ] ) . C42 ) ) by L38
.= ( ( D7 * ( R6 . C42 ) ) + ( ( ( ComplexFuncExtMult R4 ) . [ D7 , R7 ] ) . C42 ) ) by L65
.= ( ( D7 * ( R6 . C42 ) ) + ( D7 * ( R7 . C42 ) ) ) by L65
.= ( D7 * ( ( R6 . C42 ) + ( R7 . C42 ) ) )
.= ( D7 * ( ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) . C42 ) ) by L38
.= ( ( ( ComplexFuncExtMult R4 ) . [ D7 , ( ( ComplexFuncAdd R4 ) . (R6 , R7) ) ] ) . C42 ) by L65;
end;
thus L116: thesis by L114 , FUNCT_2:63;
end;
theorem
L117: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ( ( ComplexFuncMult R4 ) . (R6 , ( ( ComplexFuncAdd R4 ) . (R7 , R8) )) ) = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncMult R4 ) . (R6 , R7) ) , ( ( ComplexFuncMult R4 ) . (R6 , R8) )) )))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
L118:
now
let C43 being (Element of R4);
thus L119: ( ( ( ComplexFuncMult R4 ) . (R6 , ( ( ComplexFuncAdd R4 ) . (R7 , R8) )) ) . C43 ) = ( ( R6 . C43 ) * ( ( ( ComplexFuncAdd R4 ) . (R7 , R8) ) . C43 ) ) by L50
.= ( ( R6 . C43 ) * ( ( R7 . C43 ) + ( R8 . C43 ) ) ) by L38
.= ( ( ( R6 . C43 ) * ( R7 . C43 ) ) + ( ( R6 . C43 ) * ( R8 . C43 ) ) )
.= ( ( ( ( ComplexFuncMult R4 ) . (R6 , R7) ) . C43 ) + ( ( R6 . C43 ) * ( R8 . C43 ) ) ) by L50
.= ( ( ( ( ComplexFuncMult R4 ) . (R6 , R7) ) . C43 ) + ( ( ( ComplexFuncMult R4 ) . (R6 , R8) ) . C43 ) ) by L50
.= ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncMult R4 ) . (R6 , R7) ) , ( ( ComplexFuncMult R4 ) . (R6 , R8) )) ) . C43 ) by L38;
end;
thus L120: thesis by L118 , FUNCT_2:63;
end;
theorem
L121: (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R9 being (Element of ( COMPLEX )) holds ( ( ComplexFuncMult R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , R7) ) = ( ( ComplexFuncExtMult R4 ) . [ R9 , ( ( ComplexFuncMult R4 ) . (R6 , R7) ) ] )))))
proof
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R9 being (Element of ( COMPLEX ));
L122:
now
let C44 being (Element of R4);
thus L123: ( ( ( ComplexFuncMult R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , R7) ) . C44 ) = ( ( ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) . C44 ) * ( R7 . C44 ) ) by L50
.= ( ( R9 * ( R6 . C44 ) ) * ( R7 . C44 ) ) by L65
.= ( R9 * ( ( R6 . C44 ) * ( R7 . C44 ) ) )
.= ( R9 * ( ( ( ComplexFuncMult R4 ) . (R6 , R7) ) . C44 ) ) by L50
.= ( ( ( ComplexFuncExtMult R4 ) . [ R9 , ( ( ComplexFuncMult R4 ) . (R6 , R7) ) ] ) . C44 ) by L65;
end;
thus L124: thesis by L122 , FUNCT_2:63;
end;
begin
theorem
L125: (for R1 being set holds (for R4 being non  empty set holds (ex R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st (ex R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r ))))))))))
proof
let R1 being set;
let R4 being non  empty set;
deffunc H4(set) = ( 1r );
deffunc H5(set) = ( 0c );
defpred S1[ set ] means $1 = R1;
L126: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies H4(R3) in ( COMPLEX )) & ((not S1[ R3 ]) implies H5(R3) in ( COMPLEX )))));
consider C45 being (Function of R4 , ( COMPLEX )) such that L127: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies ( C45 . R3 ) = H4(R3)) & ((not S1[ R3 ]) implies ( C45 . R3 ) = H5(R3))))) from FUNCT_2:sch 5(L126);
L128: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies H5(R3) in ( COMPLEX )) & ((not S1[ R3 ]) implies H4(R3) in ( COMPLEX )))));
consider C46 being (Function of R4 , ( COMPLEX )) such that L129: (for R3 being set holds (R3 in R4 implies ((S1[ R3 ] implies ( C46 . R3 ) = H5(R3)) & ((not S1[ R3 ]) implies ( C46 . R3 ) = H4(R3))))) from FUNCT_2:sch 5(L128);
reconsider D8 = C45 , D9 = C46 as (Element of ( Funcs (R4 , ( COMPLEX )) )) by FUNCT_2:8;
take D8;
take D9;
thus L130: thesis by L127 , L129;
end;
theorem
L131: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ((R1 in R4 & R2 in R4 & R1 <> R2 & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r )))))) implies (for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( ComplexFuncZero R4 ) implies (R9 = ( 0c ) & R10 = ( 0c )))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
assume that
L132: R1 in R4
and
L133: R2 in R4
and
L134: R1 <> R2
and
L135: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r ))))));
L136: (( R6 . R2 ) = ( 0c ) & ( R7 . R2 ) = ( 1r )) by L133 , L134 , L135;
L137: (( R6 . R1 ) = ( 1r ) & ( R7 . R1 ) = ( 0c )) by L132 , L135;
let R9 being (Element of ( COMPLEX ));
let R10 being (Element of ( COMPLEX ));
reconsider D10 = R1 , D11 = R2 as (Element of R4) by L132 , L133;
assume L138: ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( ComplexFuncZero R4 );
L139: ( 0c ) = ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) . D11 ) by L138 , FUNCOP_1:7
.= ( ( ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) . D11 ) + ( ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] ) . D11 ) ) by L38
.= ( ( R9 * ( R6 . D11 ) ) + ( ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] ) . D11 ) ) by L65
.= ( ( 0c ) + ( R10 * ( 1r ) ) ) by L136 , L65
.= R10 by COMPLEX1:def 4;
L140: ( 0c ) = ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) . D10 ) by L138 , FUNCOP_1:7
.= ( ( ( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) . D10 ) + ( ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] ) . D10 ) ) by L38
.= ( ( R9 * ( R6 . D10 ) ) + ( ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] ) . D10 ) ) by L65
.= ( R9 + ( R10 * ( 0c ) ) ) by L137 , L65 , COMPLEX1:def 4
.= R9;
thus L141: thesis by L140 , L139;
end;
theorem
L142: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds ((R1 in R4 & R2 in R4 & R1 <> R2) implies (ex R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st (ex R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st (for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( ComplexFuncZero R4 ) implies (R9 = ( 0 ) & R10 = ( 0 )))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
assume L143: (R1 in R4 & R2 in R4 & R1 <> R2);
consider R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )), R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) such that L144: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0c ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0c )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r )))))) by L125;
take R6;
take R7;
let R9 being (Element of ( COMPLEX ));
let R10 being (Element of ( COMPLEX ));
assume L145: ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( ComplexFuncZero R4 );
thus L146: thesis by L145 , L143 , L144 , L131;
end;
theorem
L147: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds (for R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (for R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds ((R4 = { R1 , R2 } & R1 <> R2 & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r )))))) implies (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (ex R9 being (Element of ( COMPLEX )) st (ex R10 being (Element of ( COMPLEX )) st R8 = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
let R6 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
let R7 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
assume that
L148: R4 = { R1 , R2 }
and
L149: R1 <> R2
and
L150: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0 ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0 )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r ))))));
L151: R2 in R4 by L148 , TARSKI:def 2;
L152: (( R6 . R2 ) = ( 0c ) & ( R7 . R2 ) = ( 1r )) by L151 , L149 , L150;
L153: R1 in R4 by L148 , TARSKI:def 2;
L154: (( R6 . R1 ) = ( 1r ) & ( R7 . R1 ) = ( 0c )) by L153 , L150;
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
reconsider D12 = R1 , D13 = R2 as (Element of R4) by L148 , TARSKI:def 2;
take D14 = ( R8 . D12 );
take D15 = ( R8 . D13 );
L155:
now
let C47 being (Element of R4);
L156: (C47 = D12 or C47 = D13) by L148 , TARSKI:def 2;
L157: ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ D14 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] )) ) . D13 ) = ( ( ( ( ComplexFuncExtMult R4 ) . [ D14 , R6 ] ) . D13 ) + ( ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] ) . D13 ) ) by L38
.= ( ( D14 * ( R6 . D13 ) ) + ( ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] ) . D13 ) ) by L65
.= ( ( 0c ) + ( D15 * ( 1r ) ) ) by L152 , L65
.= ( R8 . D13 ) by COMPLEX1:def 4;
L158: ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ D14 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] )) ) . D12 ) = ( ( ( ( ComplexFuncExtMult R4 ) . [ D14 , R6 ] ) . D12 ) + ( ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] ) . D12 ) ) by L38
.= ( ( D14 * ( R6 . D12 ) ) + ( ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] ) . D12 ) ) by L65
.= ( D14 + ( D15 * ( 0c ) ) ) by L154 , L65 , COMPLEX1:def 4
.= ( R8 . D12 );
thus L159: ( R8 . C47 ) = ( ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ D14 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ D15 , R7 ] )) ) . C47 ) by L158 , L156 , L157;
end;
thus L160: thesis by L155 , FUNCT_2:63;
end;
theorem
L161: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds ((R4 = { R1 , R2 } & R1 <> R2) implies (ex R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st (ex R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (ex R9 being (Element of ( COMPLEX )) st (ex R10 being (Element of ( COMPLEX )) st R8 = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
assume L162: (R4 = { R1 , R2 } & R1 <> R2);
consider R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )), R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) such that L163: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0c ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0c )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r )))))) by L125;
take R6;
take R7;
let R8 being (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L164: thesis by L162 , L163 , L147;
end;
theorem
L165: (for R1 being set holds (for R2 being set holds (for R4 being non  empty set holds ((R4 = { R1 , R2 } & R1 <> R2) implies (ex R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st (ex R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) st ((for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( ComplexFuncZero R4 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) & (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (ex R9 being (Element of ( COMPLEX )) st (ex R10 being (Element of ( COMPLEX )) st R8 = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) )))))))))))
proof
let R1 being set;
let R2 being set;
let R4 being non  empty set;
assume that
L166: R4 = { R1 , R2 }
and
L167: R1 <> R2;
consider R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )), R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) such that L168: ((for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R6 . R3 ) = ( 1r )) & (R3 <> R1 implies ( R6 . R3 ) = ( 0c ))))) & (for R3 being set holds (R3 in R4 implies ((R3 = R1 implies ( R7 . R3 ) = ( 0c )) & (R3 <> R1 implies ( R7 . R3 ) = ( 1r )))))) by L125;
take R6;
take R7;
L169: (R1 in R4 & R2 in R4) by L166 , TARSKI:def 2;
thus L170: thesis by L169 , L166 , L167 , L168 , L131 , L147;
end;
definition
let R4 being non  empty set;
func ComplexVectSpace R4 ->  strict non  empty CLSStruct equals 
CLSStruct (# ( Funcs (R4 , ( COMPLEX )) ) , ( ComplexFuncZero R4 ) , ( ComplexFuncAdd R4 ) , ( ComplexFuncExtMult R4 ) #);
coherence;
end;
registration
let R4 being non  empty set;
cluster ( ComplexVectSpace R4 ) ->  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital for  strict non  empty  strict non  empty  strict non  empty  strict non  empty CLSStruct;
coherence
proof
let R11 being  strict non  empty CLSStruct;
assume that
L172: R11 = ( ComplexVectSpace R4 );
thus L173: (for R12 being (Element of R11) holds (for R13 being (Element of R11) holds ( R12 + R13 ) = ( R13 + R12 ))) by L73 , L172;
thus L174: (for R12 being (Element of R11) holds (for R13 being (Element of R11) holds (for R14 being (Element of R11) holds ( ( R12 + R13 ) + R14 ) = ( R12 + ( R13 + R14 ) )))) by L77 , L172;
thus L175: (for R12 being (Element of R11) holds ( R12 + ( 0. R11 ) ) = R12)
proof
let R12 being (Element of R11);
reconsider D16 = R12 as (Element of ( Funcs (R4 , ( COMPLEX )) )) by L172;
thus L176: ( R12 + ( 0. R11 ) ) = ( ( ComplexFuncAdd R4 ) . (( ComplexFuncZero R4 ) , D16) ) by L73 , L172
.= R12 by L93;
end;

thus L177: (for R12 being (Element of R11) holds R12 is  right_complementable)
proof
let R12 being (Element of R11);
reconsider D17 = R12 as (Element of ( Funcs (R4 , ( COMPLEX )) )) by L172;
reconsider D18 = ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , D17 ] ) as (VECTOR of R11) by L172;
take D18;
thus L178: thesis by L97 , L172;
end;

thus L179: (for B43 being Complex holds (for B44 , B45 being (VECTOR of R11) holds ( B43 * ( B44 + B45 ) ) = ( ( B43 * B44 ) + ( B43 * B45 ) ))) by L113 , L172;
thus L180: (for B46 , B47 being Complex holds (for B48 being (VECTOR of R11) holds ( ( B46 + B47 ) * B48 ) = ( ( B46 * B48 ) + ( B47 * B48 ) ))) by L109 , L172;
thus L181: (for B49 , B50 being Complex holds (for B51 being (VECTOR of R11) holds ( ( B49 * B50 ) * B51 ) = ( B49 * ( B50 * B51 ) ))) by L105 , L172;
thus L182: (for R13 being (Element of R11) holds ( ( 1r ) * R13 ) = R13) by L101 , L172;
end;
end;
L184: (ex R4 being non  empty set st (ex R1 being set st (ex R2 being set st (R4 = { R1 , R2 } & R1 <> R2))))
proof
reconsider D19 = { 1 , 2 } as non  empty set;
take D19;
thus L185: thesis;
end;
theorem
L186: (ex B52 being  strict ComplexLinearSpace st (ex B53 , B54 being (VECTOR of B52) st ((for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( ( R9 * B53 ) + ( R10 * B54 ) ) = ( 0. B52 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) & (for B55 being (VECTOR of B52) holds (ex R9 being (Element of ( COMPLEX )) st (ex R10 being (Element of ( COMPLEX )) st B55 = ( ( R9 * B53 ) + ( R10 * B54 ) )))))))
proof
consider R4 being non  empty set, R1 being set, R2 being set such that L187: (R4 = { R1 , R2 } & R1 <> R2) by L184;
take D20 = ( ComplexVectSpace R4 );
consider R6 being (Element of ( Funcs (R4 , ( COMPLEX )) )), R7 being (Element of ( Funcs (R4 , ( COMPLEX )) )) such that L188: (for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) = ( ComplexFuncZero R4 ) implies (R9 = ( 0c ) & R10 = ( 0c ))))) and L189: (for R8 being (Element of ( Funcs (R4 , ( COMPLEX )) )) holds (ex R9 being (Element of ( COMPLEX )) st (ex R10 being (Element of ( COMPLEX )) st R8 = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) )))) by L187 , L165;
reconsider D21 = R6 , D22 = R7 as (VECTOR of D20);
take D21;
take D22;
thus L190: (for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( ( R9 * D21 ) + ( R10 * D22 ) ) = ( 0. D20 ) implies (R9 = ( 0 ) & R10 = ( 0 ))))) by L188;
thus L191: (for B56 being (VECTOR of D20) holds (ex R9 being (Element of ( COMPLEX )) st (ex R10 being (Element of ( COMPLEX )) st B56 = ( ( R9 * D21 ) + ( R10 * D22 ) ))))
proof
let C48 being (VECTOR of D20);
reconsider D23 = C48 as (Element of ( Funcs (R4 , ( COMPLEX )) ));
consider R9 being (Element of ( COMPLEX )), R10 being (Element of ( COMPLEX )) such that L192: D23 = ( ( ComplexFuncAdd R4 ) . (( ( ComplexFuncExtMult R4 ) . [ R9 , R6 ] ) , ( ( ComplexFuncExtMult R4 ) . [ R10 , R7 ] )) ) by L189;
L193: D23 = ( ( R9 * D21 ) + ( R10 * D22 ) ) by L192;
thus L194: thesis by L193;
end;

end;
definition
let R4 being non  empty set;
func CRing R4 -> doubleLoopStr equals 
doubleLoopStr (# ( Funcs (R4 , ( COMPLEX )) ) , ( ComplexFuncAdd R4 ) , ( ComplexFuncMult R4 ) , ( ComplexFuncUnit R4 ) , ( ComplexFuncZero R4 ) #);
correctness;
end;
registration
let R4 being non  empty set;
cluster ( CRing R4 ) -> non  empty  strict;
coherence;
end;
L194:
now
let R4 being non  empty set;
let C49 , C50 being (Element of ( CRing R4 ));
assume L195: C50 = ( ComplexFuncUnit R4 );
thus L196: ( C50 * C49 ) = C49 by L195 , L89;
thus L197: ( C49 * C50 ) = C49 by L196 , L81;
end;
registration
let R4 being non  empty set;
cluster ( CRing R4 ) ->  unital;
coherence
proof
reconsider D24 = ( ComplexFuncUnit R4 ) as (Element of ( CRing R4 ));
take D24;
thus L198: thesis by L194;
end;
end;
theorem
L200: (for R4 being non  empty set holds (for B57 , B58 , B59 being (Element of ( CRing R4 )) holds (( B57 + B58 ) = ( B58 + B57 ) & ( ( B57 + B58 ) + B59 ) = ( B57 + ( B58 + B59 ) ) & ( B57 + ( 0. ( CRing R4 ) ) ) = B57 & B57 is  right_complementable & ( B57 * B58 ) = ( B58 * B57 ) & ( ( B57 * B58 ) * B59 ) = ( B57 * ( B58 * B59 ) ) & ( B57 * ( 1. ( CRing R4 ) ) ) = B57 & ( ( 1. ( CRing R4 ) ) * B57 ) = B57 & ( B57 * ( B58 + B59 ) ) = ( ( B57 * B58 ) + ( B57 * B59 ) ) & ( ( B58 + B59 ) * B57 ) = ( ( B58 * B57 ) + ( B59 * B57 ) ))))
proof
let R4 being non  empty set;
let C51 , C52 , C53 being (Element of ( CRing R4 ));
set D25 = ( CRing R4 );
reconsider D26 = C51 as (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L201: ( C51 + C52 ) = ( C52 + C51 ) by L73;
thus L202: ( ( C51 + C52 ) + C53 ) = ( C51 + ( C52 + C53 ) ) by L77;
thus L203: ( C51 + ( 0. ( CRing R4 ) ) ) = ( ( ComplexFuncAdd R4 ) . (( ComplexFuncZero R4 ) , D26) ) by L73
.= C51 by L93;
thus L204: (ex B60 being (Element of ( CRing R4 )) st ( C51 + B60 ) = ( 0. ( CRing R4 ) ))
proof
set D27 = ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , D26 ] );
reconsider D28 = D27 as (Element of D25);
take D28;
thus L205: thesis by L97;
end;

thus L206: ( C51 * C52 ) = ( C52 * C51 ) by L81;
thus L207: ( ( C51 * C52 ) * C53 ) = ( C51 * ( C52 * C53 ) ) by L85;
thus L208: ( C51 * ( 1. ( CRing R4 ) ) ) = ( ( ComplexFuncMult R4 ) . (( ComplexFuncUnit R4 ) , D26) ) by L81
.= C51 by L89;
thus L209: ( ( 1. ( CRing R4 ) ) * C51 ) = C51 by L208 , L81;
thus L210: ( C51 * ( C52 + C53 ) ) = ( ( C51 * C52 ) + ( C51 * C53 ) ) by L117;
thus L211: ( ( C52 + C53 ) * C51 ) = ( ( C51 * C52 ) + ( C51 * C53 ) ) by L210 , L81
.= ( ( C52 * C51 ) + ( C51 * C53 ) ) by L81
.= ( ( C52 * C51 ) + ( C53 * C51 ) ) by L81;
end;
theorem
L212: (for R4 being non  empty set holds ( CRing R4 ) is  commutative  commutative  commutative  commutative Ring)
proof
let R4 being non  empty set;
L213: (for B61 , B62 , B63 being (Element of ( CRing R4 )) holds (( B61 + B62 ) = ( B62 + B61 ) & ( ( B61 + B62 ) + B63 ) = ( B61 + ( B62 + B63 ) ) & ( B61 + ( 0. ( CRing R4 ) ) ) = B61 & B61 is  right_complementable & ( B61 * B62 ) = ( B62 * B61 ) & ( ( B61 * B62 ) * B63 ) = ( B61 * ( B62 * B63 ) ) & ( B61 * ( 1. ( CRing R4 ) ) ) = B61 & ( ( 1. ( CRing R4 ) ) * B61 ) = B61 & ( B61 * ( B62 + B63 ) ) = ( ( B61 * B62 ) + ( B61 * B63 ) ) & ( ( B62 + B63 ) * B61 ) = ( ( B62 * B61 ) + ( B63 * B61 ) ))) by L200;
thus L214: thesis by L213 , ALGSTR_0:def 16 , GROUP_1:def 3 , GROUP_1:def 12 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , VECTSP_1:def 6 , VECTSP_1:def 7;
end;
definition
struct (doubleLoopStr , CLSStruct) ComplexAlgebraStr(# carrier -> set , multF , addF -> (BinOp of the carrier) , Mult -> (Function of [: ( COMPLEX ) , the carrier :] , the carrier) , OneF , ZeroF -> (Element of the carrier) #);
end;
registration
cluster non  empty for ComplexAlgebraStr;
existence
proof
set D29 = the non  empty set;
set D30 = the (BinOp of D29);
set D31 = the (Function of [: ( COMPLEX ) , D29 :] , D29);
set D32 = the (Element of D29);
take ComplexAlgebraStr (# D29 , D30 , D30 , D31 , D32 , D32 #);
thus L216: (the carrier of ComplexAlgebraStr (# D29 , D30 , D30 , D31 , D32 , D32 #)) is non  empty;
end;
end;
definition
let R4 being non  empty set;
func CAlgebra R4 ->  strict ComplexAlgebraStr equals 
ComplexAlgebraStr (# ( Funcs (R4 , ( COMPLEX )) ) , ( ComplexFuncMult R4 ) , ( ComplexFuncAdd R4 ) , ( ComplexFuncExtMult R4 ) , ( ComplexFuncUnit R4 ) , ( ComplexFuncZero R4 ) #);
correctness;
end;
registration
let R4 being non  empty set;
cluster ( CAlgebra R4 ) -> non  empty;
coherence
proof
thus L219: (the carrier of ( CAlgebra R4 )) is non  empty;
end;
end;
L221:
now
let R4 being non  empty set;
let C54 , C55 being (Element of ( CAlgebra R4 ));
assume L222: C55 = ( ComplexFuncUnit R4 );
thus L223: ( C55 * C54 ) = C54 by L222 , L89;
thus L224: ( C54 * C55 ) = C54 by L223 , L81;
end;
registration
let R4 being non  empty set;
cluster ( CAlgebra R4 ) ->  unital;
coherence
proof
reconsider D33 = ( ComplexFuncUnit R4 ) as (Element of ( CAlgebra R4 ));
take D33;
thus L225: thesis by L221;
end;
end;
theorem
L227: (for R4 being non  empty set holds (for B64 , B65 , B66 being (Element of ( CAlgebra R4 )) holds (for R9 being (Element of ( COMPLEX )) holds (for R10 being (Element of ( COMPLEX )) holds (( B64 + B65 ) = ( B65 + B64 ) & ( ( B64 + B65 ) + B66 ) = ( B64 + ( B65 + B66 ) ) & ( B64 + ( 0. ( CAlgebra R4 ) ) ) = B64 & B64 is  right_complementable & ( B64 * B65 ) = ( B65 * B64 ) & ( ( B64 * B65 ) * B66 ) = ( B64 * ( B65 * B66 ) ) & ( B64 * ( 1. ( CAlgebra R4 ) ) ) = B64 & ( B64 * ( B65 + B66 ) ) = ( ( B64 * B65 ) + ( B64 * B66 ) ) & ( R9 * ( B64 * B65 ) ) = ( ( R9 * B64 ) * B65 ) & ( R9 * ( B64 + B65 ) ) = ( ( R9 * B64 ) + ( R9 * B65 ) ) & ( ( R9 + R10 ) * B64 ) = ( ( R9 * B64 ) + ( R10 * B64 ) ) & ( ( R9 * R10 ) * B64 ) = ( R9 * ( R10 * B64 ) ))))))
proof
let R4 being non  empty set;
let C56 , C57 , C58 being (Element of ( CAlgebra R4 ));
let R9 being (Element of ( COMPLEX ));
let R10 being (Element of ( COMPLEX ));
set D34 = ( CAlgebra R4 );
reconsider D35 = C56 as (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L228: ( C56 + C57 ) = ( C57 + C56 ) by L73;
thus L229: ( ( C56 + C57 ) + C58 ) = ( C56 + ( C57 + C58 ) ) by L77;
thus L230: ( C56 + ( 0. ( CAlgebra R4 ) ) ) = ( ( ComplexFuncAdd R4 ) . (( ComplexFuncZero R4 ) , D35) ) by L73
.= C56 by L93;
thus L231: (ex B67 being (Element of ( CAlgebra R4 )) st ( C56 + B67 ) = ( 0. ( CAlgebra R4 ) ))
proof
set D36 = ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , D35 ] );
reconsider D37 = D36 as (Element of D34);
take D37;
thus L232: thesis by L97;
end;

thus L233: ( C56 * C57 ) = ( C57 * C56 ) by L81;
thus L234: ( ( C56 * C57 ) * C58 ) = ( C56 * ( C57 * C58 ) ) by L85;
thus L235: ( C56 * ( 1. ( CAlgebra R4 ) ) ) = ( ( ComplexFuncMult R4 ) . (( ComplexFuncUnit R4 ) , D35) ) by L81
.= C56 by L89;
thus L236: ( C56 * ( C57 + C58 ) ) = ( ( C56 * C57 ) + ( C56 * C58 ) ) by L117;
thus L237: ( R9 * ( C56 * C57 ) ) = ( ( R9 * C56 ) * C57 ) by L121;
thus L238: ( R9 * ( C56 + C57 ) ) = ( ( R9 * C56 ) + ( R9 * C57 ) ) by L113;
thus L239: ( ( R9 + R10 ) * C56 ) = ( ( R9 * C56 ) + ( R10 * C56 ) ) by L109;
thus L240: thesis by L105;
end;
definition
let C59 being non  empty ComplexAlgebraStr;
attr C59 is  vector-associative
means
(for B68 , B69 being (Element of C59) holds (for R9 being (Element of ( COMPLEX )) holds ( R9 * ( B68 * B69 ) ) = ( ( R9 * B68 ) * B69 )));
end;
registration
let R4 being non  empty set;
cluster ( CAlgebra R4 ) ->  strict  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative;
coherence
proof
set D38 = ( CAlgebra R4 );
thus L242: D38 is  strict;
thus L243: D38 is  Abelian
proof
let C60 , C61 being (Element of D38);
thus L244: ( C60 + C61 ) = ( C61 + C60 ) by L73;
end;

thus L245: D38 is  add-associative
proof
let C62 , C63 , C64 being (Element of D38);
thus L246: ( ( C62 + C63 ) + C64 ) = ( C62 + ( C63 + C64 ) ) by L77;
end;

thus L247: D38 is  right_zeroed
proof
let C65 being (Element of D38);
reconsider D39 = C65 as (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L248: ( C65 + ( 0. D38 ) ) = ( ( ComplexFuncAdd R4 ) . (( ComplexFuncZero R4 ) , D39) ) by L73
.= C65 by L93;
end;

thus L249: D38 is  right_complementable
proof
let C66 being (Element of D38);
reconsider D40 = C66 as (Element of ( Funcs (R4 , ( COMPLEX )) ));
reconsider D41 = ( ( ComplexFuncExtMult R4 ) . [ ( - ( 1r ) ) , D40 ] ) as (Element of D38);
take D41;
thus L250: thesis by L97;
end;

thus L251: D38 is  commutative
proof
let C67 , C68 being (Element of D38);
thus L252: ( C67 * C68 ) = ( C68 * C67 ) by L81;
end;

thus L253: D38 is  associative
proof
let C69 , C70 , C71 being (Element of D38);
thus L254: ( ( C69 * C70 ) * C71 ) = ( C69 * ( C70 * C71 ) ) by L85;
end;

thus L255: D38 is  right_unital
proof
let C72 being (Element of D38);
reconsider D42 = C72 as (Element of ( Funcs (R4 , ( COMPLEX )) ));
thus L256: ( C72 * ( 1. D38 ) ) = ( ( ComplexFuncMult R4 ) . (( ComplexFuncUnit R4 ) , D42) ) by L81
.= C72 by L89;
end;

thus L257: D38 is  right-distributive
proof
let C73 , C74 , C75 being (Element of D38);
thus L258: ( C73 * ( C74 + C75 ) ) = ( ( C73 * C74 ) + ( C73 * C75 ) ) by L117;
end;

thus L259: D38 is  vector-distributive
proof
let C76 being Complex;
let C77 , C78 being (Element of D38);
thus L260: ( C76 * ( C77 + C78 ) ) = ( ( C76 * C77 ) + ( C76 * C78 ) ) by L113;
end;

thus L261: D38 is  scalar-distributive
proof
let C79 , C80 being Complex;
let C81 being (Element of D38);
thus L262: ( ( C79 + C80 ) * C81 ) = ( ( C79 * C81 ) + ( C80 * C81 ) ) by L109;
end;

thus L263: D38 is  scalar-associative
proof
let C82 , C83 being Complex;
let C84 being (Element of D38);
thus L264: ( C82 * ( C83 * C84 ) ) = ( ( C82 * C83 ) * C84 ) by L105;
end;

let C85 , C86 being (Element of D38);
let R9 being (Element of ( COMPLEX ));
thus L265: thesis by L121;
end;
end;
registration
cluster  strict  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative for non  empty non  empty non  empty non  empty ComplexAlgebraStr;
existence
proof
take ( CAlgebra 1 );
thus L267: thesis;
end;
end;
definition
mode ComplexAlgebra
 is  Abelian  add-associative  right_zeroed  right_complementable  commutative  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative non  empty ComplexAlgebraStr;
end;
theorem
L270: (for R4 being non  empty set holds ( CAlgebra R4 ) is ComplexAlgebra);
theorem
L271: (for R4 being non  empty set holds ( 1. ( CRing R4 ) ) = ( ComplexFuncUnit R4 ));
theorem
L272: (for R4 being non  empty set holds ( 1. ( CAlgebra R4 ) ) = ( ComplexFuncUnit R4 ));
