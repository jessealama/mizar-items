:: Category Ens
::  by Czes{\l}aw Byli\'nski
::
:: Received August 1, 1991
:: Copyright (c) 1991-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, SUBSET_1, FUNCT_2, TARSKI, FUNCT_1, RELAT_1, ZFMISC_1,
      MCART_1, GRAPH_1, PARTFUN1, CAT_1, STRUCT_0, QC_LANG1, CLASSES2,
      FUNCOP_1, FUNCT_4, CAT_2, OPPCAT_1, FUNCT_5, ARYTM_0, ENS_1, MONOID_0,
      RELAT_2, BINOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, MCART_1, DOMAIN_1, RELAT_1,
      FUNCT_1, FUNCT_2, BINOP_1, PARTFUN1, FUNCT_4, CLASSES2,
      FUNCOP_1, FUNCT_5, STRUCT_0, GRAPH_1, CAT_1, CAT_2, OPPCAT_1;
 constructors PARTFUN1, DOMAIN_1, CLASSES2, CAT_2, OPPCAT_1, FUNCOP_1,
      RELSET_1, FUNCT_5, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, FUNCT_2, RELSET_1, STRUCT_0,
      PARTFUN1, RELAT_1, CAT_1, XTUPLE_0, OPPCAT_1, CAT_2;
 requirements SUBSET, BOOLE;
 definitions TARSKI, FUNCT_1, CAT_1, CAT_2, BINOP_1, RELAT_1, GRAPH_1,
      OPPCAT_1, XTUPLE_0;
 theorems TARSKI, ENUMSET1, ZFMISC_1, MCART_1, DOMAIN_1, FUNCT_1, FUNCT_2,
      PARTFUN1, FUNCOP_1, FUNCT_4, CLASSES2, CAT_1, CAT_2, OPPCAT_1, GRFUNC_1,
      RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1, BINOP_1, FUNCT_5, XTUPLE_0;
 schemes FUNCT_2, BINOP_1, FUNCT_1;

begin
definition
let R1 being non  empty set;
func Funcs R1 -> set equals 
( union { ( Funcs (R2 , R3) ) where R2 is (Element of R1) , R3 is (Element of R1) : (not contradiction) } );
coherence;
end;
registration
let R1 being non  empty set;
cluster ( Funcs R1 ) ->  functional non  empty;
coherence
proof
set D1 = { ( Funcs (R2 , R3) ) where R2 is (Element of R1) , R3 is (Element of R1) : (not contradiction) };
set D2 = the (Element of R1);
L2: (( id D2 ) in ( Funcs (D2 , D2) ) & ( Funcs (D2 , D2) ) in D1) by FUNCT_2:9;
reconsider D3 = ( union D1 ) as non  empty set by L2 , TARSKI:def 4;
L3:
now
let C1 being set;
assume L4: C1 in D3;
consider C2 being set such that L5: C1 in C2 and L6: C2 in D1 by L4 , TARSKI:def 4;
L7: (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st C2 = ( Funcs (R2 , R3) ))) by L6;
thus L8: C1 is Function by L7 , L5;
end;
thus L9: thesis by L3 , FUNCT_1:def 13;
end;
end;
theorem
L11: (for R1 being non  empty set holds (for B1 being set holds (B1 in ( Funcs R1 ) iff (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st ((R3 = ( {} ) implies R2 = ( {} )) & B1 is (Function of R2 , R3)))))))
proof
let R1 being non  empty set;
let C3 being set;
set D4 = { ( Funcs (R2 , R3) ) where R2 is (Element of R1) , R3 is (Element of R1) : (not contradiction) };
thus L12: (C3 in ( Funcs R1 ) implies (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st ((R3 = ( {} ) implies R2 = ( {} )) & C3 is (Function of R2 , R3)))))
proof
assume L13: C3 in ( Funcs R1 );
consider C4 being set such that L14: C3 in C4 and L15: C4 in D4 by L13 , TARSKI:def 4;
consider R2 being (Element of R1), R3 being (Element of R1) such that L16: C4 = ( Funcs (R2 , R3) ) by L15;
take R2;
take R3;
thus L17: thesis by L14 , L16 , FUNCT_2:66;
end;

given R2 being (Element of R1) , R3 being (Element of R1) such that
L18: ((R3 = ( {} ) implies R2 = ( {} )) & C3 is (Function of R2 , R3));

L19: ( Funcs (R2 , R3) ) in D4;
L20: C3 in ( Funcs (R2 , R3) ) by L18 , FUNCT_2:8;
thus L21: thesis by L20 , L19 , TARSKI:def 4;
end;
theorem
L22: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( Funcs (R2 , R3) ) c= ( Funcs R1 ))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let C5 being set;
assume L23: C5 in ( Funcs (R2 , R3) );
L24: C5 is (Function of R2 , R3) by L23 , FUNCT_2:66;
L25: (R3 = ( {} ) implies R2 = ( {} )) by L23;
thus L26: thesis by L25 , L24 , L11;
end;
theorem
L27: (for R1 being non  empty set holds (for B2 being non  empty (Subset of R1) holds ( Funcs B2 ) c= ( Funcs R1 )))
proof
let R1 being non  empty set;
let C6 being non  empty (Subset of R1);
let C7 being set;
assume L28: C7 in ( Funcs C6 );
L29: (ex B3 , B4 being (Element of C6) st ((B4 = ( {} ) implies B3 = ( {} )) & C7 is (Function of B3 , B4))) by L28 , L11;
thus L30: thesis by L29 , L11;
end;
definition
let R1 being non  empty set;
func Maps R1 -> set equals 
{ [ [ R2 , R3 ] , R6 ] where R2 is (Element of R1) , R3 is (Element of R1) , R6 is (Element of ( Funcs R1 )) : ((R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3)) };
coherence;
end;
registration
let R1 being non  empty set;
cluster ( Maps R1 ) -> non  empty;
coherence
proof
set D5 = { [ [ R2 , R3 ] , R6 ] where R2 is (Element of R1) , R3 is (Element of R1) , R6 is (Element of ( Funcs R1 )) : ((R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3)) };
set D6 = the (Element of R1);
L32:
now
set D7 = ( id D6 );
take D8 = [ [ D6 , D6 ] , D7 ];
L33: (D6 = ( {} ) implies D6 = ( {} ));
L34: D7 in ( Funcs R1 ) by L11;
thus L35: D8 in D5 by L34 , L33;
end;
thus L36: thesis by L32;
end;
end;
theorem
L38: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds (ex R6 being (Element of ( Funcs R1 )) st (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st (R8 = [ [ R2 , R3 ] , R6 ] & (R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3)))))))
proof
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
L39: R8 in { [ [ R2 , R3 ] , R6 ] where R2 is (Element of R1) , R3 is (Element of R1) , R6 is (Element of ( Funcs R1 )) : ((R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3)) };
L40: (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st (ex R6 being (Element of ( Funcs R1 )) st (R8 = [ [ R2 , R3 ] , R6 ] & (R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3))))) by L39;
thus L41: thesis by L40;
end;
theorem
L42: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for B5 being (Function of R2 , R3) holds ((R3 = ( {} ) implies R2 = ( {} )) implies [ [ R2 , R3 ] , B5 ] in ( Maps R1 ))))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let C8 being (Function of R2 , R3);
assume L43: (R3 = ( {} ) implies R2 = ( {} ));
L44: C8 in ( Funcs R1 ) by L43 , L11;
thus L45: thesis by L44 , L43;
end;
theorem
L46: (for R1 being non  empty set holds ( Maps R1 ) c= [: [: R1 , R1 :] , ( Funcs R1 ) :])
proof
let R1 being non  empty set;
let C9 being set;
assume L47: C9 in ( Maps R1 );
L48: (ex R2 being (Element of R1) st (ex R3 being (Element of R1) st (ex R6 being (Element of ( Funcs R1 )) st (C9 = [ [ R2 , R3 ] , R6 ] & (R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3))))) by L47;
thus L49: thesis by L48;
end;
theorem
L50: (for R1 being non  empty set holds (for B6 being non  empty (Subset of R1) holds ( Maps B6 ) c= ( Maps R1 )))
proof
let R1 being non  empty set;
let C10 being non  empty (Subset of R1);
let C11 being set;
assume L51: C11 in ( Maps C10 );
consider C12 , C13 being (Element of C10), C14 being (Element of ( Funcs C10 )) such that L52: (C11 = [ [ C12 , C13 ] , C14 ] & (C13 = ( {} ) implies C12 = ( {} )) & C14 is (Function of C12 , C13)) by L51;
L53: (( Funcs C10 ) c= ( Funcs R1 ) & C14 in ( Funcs C10 )) by L27;
thus L54: thesis by L53 , L52;
end;
L55: (for B7 , B8 , B9 , B10 , B11 , B12 being set holds ([ [ B7 , B9 ] , B11 ] = [ [ B8 , B10 ] , B12 ] implies (B7 = B8 & B9 = B10)))
proof
let C15 , C16 , C17 , C18 , C19 , C20 being set;
assume L56: [ [ C15 , C17 ] , C19 ] = [ [ C16 , C18 ] , C20 ];
L57: [ C15 , C17 ] = [ C16 , C18 ] by L56 , XTUPLE_0:1;
thus L58: thesis by L57 , XTUPLE_0:1;
end;
registration
let C21 being non  empty set;
let C22 being (Element of ( Maps C21 ));
cluster ( C22 `2 ) ->  Function-like  Relation-like;
coherence
proof
L59: (ex B13 being (Element of ( Funcs C21 )) st (ex B14 , B15 being (Element of C21) st (C22 = [ [ B14 , B15 ] , B13 ] & (B15 = ( {} ) implies B14 = ( {} )) & B13 is (Function of B14 , B15)))) by L38;
thus L60: thesis by L59 , MCART_1:7;
end;
end;
definition
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
func dom R8 -> (Element of R1) equals 
( ( R8 `1 ) `1 );
coherence
proof
consider R6 being (Element of ( Funcs R1 )), R2 being (Element of R1), R3 being (Element of R1) such that L62: R8 = [ [ R2 , R3 ] , R6 ] and L63: (R3 = ( {} ) implies R2 = ( {} )) and L64: R6 is (Function of R2 , R3) by L38;
L65: [ R2 , R3 ] = ( R8 `1 ) by L62 , MCART_1:7;
thus L66: thesis by L65 , MCART_1:7;
end;
func cod R8 -> (Element of R1) equals 
( ( R8 `1 ) `2 );
coherence
proof
consider R6 being (Element of ( Funcs R1 )), R2 being (Element of R1), R3 being (Element of R1) such that L67: R8 = [ [ R2 , R3 ] , R6 ] and L68: (R3 = ( {} ) implies R2 = ( {} )) and L69: R6 is (Function of R2 , R3) by L38;
L70: [ R2 , R3 ] = ( R8 `1 ) by L67 , MCART_1:7;
thus L71: thesis by L70 , MCART_1:7;
end;
end;
theorem
L73: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds R8 = [ [ ( dom R8 ) , ( cod R8 ) ] , ( R8 `2 ) ]))
proof
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
consider R6 being (Element of ( Funcs R1 )), R2 being (Element of R1), R3 being (Element of R1) such that L74: (R8 = [ [ R2 , R3 ] , R6 ] & (R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3)) by L38;
L75: ( R8 `1 ) = [ R2 , R3 ] by L74 , MCART_1:7;
L76: ( R8 `1 ) = [ ( dom R8 ) , ( cod R8 ) ] by L75 , MCART_1:8;
thus L77: thesis by L76 , L74 , MCART_1:8;
end;
L78: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds (for R12 being (Element of ( Maps R1 )) holds ((( R8 `2 ) = ( R12 `2 ) & ( dom R8 ) = ( dom R12 ) & ( cod R8 ) = ( cod R12 )) implies R8 = R12))))
proof
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
let R12 being (Element of ( Maps R1 ));
L79: R8 = [ [ ( dom R8 ) , ( cod R8 ) ] , ( R8 `2 ) ] by L73;
thus L80: thesis by L79 , L73;
end;
theorem
L81: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds ((( cod R8 ) <> ( {} ) or ( dom R8 ) = ( {} )) & ( R8 `2 ) is (Function of ( dom R8 ) , ( cod R8 )))))
proof
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
consider R6 being (Element of ( Funcs R1 )), R2 being (Element of R1), R3 being (Element of R1) such that L82: R8 = [ [ R2 , R3 ] , R6 ] and L83: ((R3 = ( {} ) implies R2 = ( {} )) & R6 is (Function of R2 , R3)) by L38;
L84: R8 = [ [ ( dom R8 ) , ( cod R8 ) ] , ( R8 `2 ) ] by L73;
L85: (R6 = ( R8 `2 ) & R2 = ( dom R8 )) by L84 , L82 , L55 , XTUPLE_0:1;
thus L86: thesis by L85 , L82 , L83 , L84 , L55;
end;
L87: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds (( dom ( R8 `2 ) ) = ( dom R8 ) & ( rng ( R8 `2 ) ) c= ( cod R8 ))))
proof
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
L88: ( R8 `2 ) is (Function of ( dom R8 ) , ( cod R8 )) by L81;
L89: (( cod R8 ) <> ( {} ) or ( dom R8 ) = ( {} )) by L81;
thus L90: thesis by L89 , L88 , FUNCT_2:def 1 , RELAT_1:def 19;
end;
theorem
L91: (for R1 being non  empty set holds (for B16 being Function holds (for B17 , B18 being set holds ([ [ B17 , B18 ] , B16 ] in ( Maps R1 ) implies ((B18 = ( {} ) implies B17 = ( {} )) & B16 is (Function of B17 , B18))))))
proof
let R1 being non  empty set;
let C23 being Function;
let C24 , C25 being set;
assume L92: [ [ C24 , C25 ] , C23 ] in ( Maps R1 );
consider R7 being (Element of ( Funcs R1 )), R4 being (Element of R1), R5 being (Element of R1) such that L93: [ [ C24 , C25 ] , C23 ] = [ [ R4 , R5 ] , R7 ] and L94: ((R5 = ( {} ) implies R4 = ( {} )) & R7 is (Function of R4 , R5)) by L92 , L38;
L95: (C23 = R7 & C24 = R4) by L93 , L55 , XTUPLE_0:1;
thus L96: thesis by L95 , L93 , L94 , L55;
end;
definition
let R1 being non  empty set;
let R2 being (Element of R1);
func id$ R2 -> (Element of ( Maps R1 )) equals 
[ [ R2 , R2 ] , ( id R2 ) ];
coherence by L42;
end;
theorem
L98: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (( ( id$ R2 ) `2 ) = ( id R2 ) & ( dom ( id$ R2 ) ) = R2 & ( cod ( id$ R2 ) ) = R2)))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
L99: [ [ ( dom ( id$ R2 ) ) , ( cod ( id$ R2 ) ) ] , ( ( id$ R2 ) `2 ) ] = [ [ R2 , R2 ] , ( id R2 ) ] by L73;
thus L100: thesis by L99 , L55 , XTUPLE_0:1;
end;
definition
let R1 being non  empty set;
let R9 being (Element of ( Maps R1 ));
let R10 being (Element of ( Maps R1 ));
assume L101: ( cod R9 ) = ( dom R10 );
func R10 * R9 -> (Element of ( Maps R1 )) equals 
:L102: [ [ ( dom R9 ) , ( cod R10 ) ] , ( ( R10 `2 ) * ( R9 `2 ) ) ];
coherence
proof
L103: (( cod R10 ) <> ( {} ) or ( dom R10 ) = ( {} )) by L81;
L104: (( cod R9 ) <> ( {} ) or ( dom R9 ) = ( {} )) by L81;
L105: (( R9 `2 ) is (Function of ( dom R9 ) , ( cod R9 )) & ( R10 `2 ) is (Function of ( dom R10 ) , ( cod R10 ))) by L81;
L106: ( ( R10 `2 ) * ( R9 `2 ) ) is (Function of ( dom R9 ) , ( cod R10 )) by L105 , L101 , L104 , FUNCT_2:13;
thus L107: thesis by L106 , L101 , L104 , L103 , L42;
end;
end;
theorem
L109: (for R1 being non  empty set holds (for R9 being (Element of ( Maps R1 )) holds (for R10 being (Element of ( Maps R1 )) holds (( dom R10 ) = ( cod R9 ) implies (( ( R10 * R9 ) `2 ) = ( ( R10 `2 ) * ( R9 `2 ) ) & ( dom ( R10 * R9 ) ) = ( dom R9 ) & ( cod ( R10 * R9 ) ) = ( cod R10 ))))))
proof
let R1 being non  empty set;
let R9 being (Element of ( Maps R1 ));
let R10 being (Element of ( Maps R1 ));
assume L110: ( dom R10 ) = ( cod R9 );
L111: [ [ ( dom R9 ) , ( cod R10 ) ] , ( ( R10 `2 ) * ( R9 `2 ) ) ] = ( R10 * R9 ) by L110 , L102
.= [ [ ( dom ( R10 * R9 ) ) , ( cod ( R10 * R9 ) ) ] , ( ( R10 * R9 ) `2 ) ] by L73;
thus L112: thesis by L111 , L55 , XTUPLE_0:1;
end;
theorem
L113: (for R1 being non  empty set holds (for R9 being (Element of ( Maps R1 )) holds (for R10 being (Element of ( Maps R1 )) holds (for R11 being (Element of ( Maps R1 )) holds ((( dom R10 ) = ( cod R9 ) & ( dom R11 ) = ( cod R10 )) implies ( R11 * ( R10 * R9 ) ) = ( ( R11 * R10 ) * R9 ))))))
proof
let R1 being non  empty set;
let R9 being (Element of ( Maps R1 ));
let R10 being (Element of ( Maps R1 ));
let R11 being (Element of ( Maps R1 ));
assume that
L114: ( dom R10 ) = ( cod R9 )
and
L115: ( dom R11 ) = ( cod R10 );
L116: ( cod ( R10 * R9 ) ) = ( cod R10 ) by L114 , L109;
L117: ( ( R10 * R9 ) `2 ) = ( ( R10 `2 ) * ( R9 `2 ) ) by L114 , L109;
L118: ( ( R11 * ( R10 * R9 ) ) `2 ) = ( ( R11 `2 ) * ( ( R10 `2 ) * ( R9 `2 ) ) ) by L117 , L115 , L116 , L109;
L119: ( dom ( R11 * R10 ) ) = ( dom R10 ) by L115 , L109;
L120: ( dom ( ( R11 * R10 ) * R9 ) ) = ( dom R9 ) by L119 , L114 , L109;
L121: ( dom ( R10 * R9 ) ) = ( dom R9 ) by L114 , L109;
L122: ( dom ( R11 * ( R10 * R9 ) ) ) = ( dom R9 ) by L121 , L115 , L116 , L109;
L123: ( cod ( R11 * R10 ) ) = ( cod R11 ) by L115 , L109;
L124: ( cod ( ( R11 * R10 ) * R9 ) ) = ( cod R11 ) by L123 , L114 , L119 , L109;
L125: ( ( R11 * R10 ) `2 ) = ( ( R11 `2 ) * ( R10 `2 ) ) by L115 , L109;
L126: ( ( ( R11 * R10 ) * R9 ) `2 ) = ( ( ( R11 `2 ) * ( R10 `2 ) ) * ( R9 `2 ) ) by L125 , L114 , L119 , L109;
L127: ( cod ( R11 * ( R10 * R9 ) ) ) = ( cod R11 ) by L115 , L116 , L109;
thus L128: thesis by L127 , L118 , L122 , L126 , L120 , L124 , L78 , RELAT_1:36;
end;
theorem
L129: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds (( R8 * ( id$ ( dom R8 ) ) ) = R8 & ( ( id$ ( cod R8 ) ) * R8 ) = R8)))
proof
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
set D9 = ( id$ ( dom R8 ) );
set D10 = ( id$ ( cod R8 ) );
L130: (( D9 `2 ) = ( id ( dom R8 ) ) & ( dom D9 ) = ( dom R8 )) by L98;
L131: ( R8 `2 ) is (Function of ( dom R8 ) , ( cod R8 )) by L81;
L132: ( rng ( R8 `2 ) ) c= ( cod R8 ) by L131 , RELAT_1:def 19;
L133: (( cod R8 ) <> ( {} ) or ( dom R8 ) = ( {} )) by L81;
L134: ( dom ( R8 `2 ) ) = ( dom R8 ) by L133 , L131 , FUNCT_2:def 1;
L135: ( cod D9 ) = ( dom R8 ) by L98;
L136: ( cod ( R8 * D9 ) ) = ( cod R8 ) by L135 , L109;
L137: (( ( R8 * D9 ) `2 ) = ( ( R8 `2 ) * ( D9 `2 ) ) & ( dom ( R8 * D9 ) ) = ( dom D9 )) by L135 , L109;
thus L138: ( R8 * D9 ) = R8 by L137 , L134 , L130 , L136 , L78 , RELAT_1:52;
L139: (( D10 `2 ) = ( id ( cod R8 ) ) & ( cod D10 ) = ( cod R8 )) by L98;
L140: ( dom D10 ) = ( cod R8 ) by L98;
L141: ( cod ( D10 * R8 ) ) = ( cod D10 ) by L140 , L109;
L142: (( ( D10 * R8 ) `2 ) = ( ( D10 `2 ) * ( R8 `2 ) ) & ( dom ( D10 * R8 ) ) = ( dom R8 )) by L140 , L109;
thus L143: thesis by L142 , L132 , L139 , L141 , L78 , RELAT_1:53;
end;
definition
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
func Maps (R2 , R3) -> set equals 
{ [ [ R2 , R3 ] , B19 ] where B19 is (Element of ( Funcs R1 )) : [ [ R2 , R3 ] , B19 ] in ( Maps R1 ) };
correctness;
end;
theorem
L145: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for B20 being (Function of R2 , R3) holds ((R3 = ( {} ) implies R2 = ( {} )) implies [ [ R2 , R3 ] , B20 ] in ( Maps (R2 , R3) ))))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let C26 being (Function of R2 , R3);
assume L146: (R3 = ( {} ) implies R2 = ( {} ));
L147: (C26 in ( Funcs R1 ) & [ [ R2 , R3 ] , C26 ] in ( Maps R1 )) by L146 , L11 , L42;
thus L148: thesis by L147;
end;
theorem
L149: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R8 being (Element of ( Maps R1 )) holds (R8 in ( Maps (R2 , R3) ) implies R8 = [ [ R2 , R3 ] , ( R8 `2 ) ])))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R8 being (Element of ( Maps R1 ));
assume L150: R8 in ( Maps (R2 , R3) );
L151: (ex B21 being (Element of ( Funcs R1 )) st (R8 = [ [ R2 , R3 ] , B21 ] & [ [ R2 , R3 ] , B21 ] in ( Maps R1 ))) by L150;
L152: R8 = [ [ ( dom R8 ) , ( cod R8 ) ] , ( R8 `2 ) ] by L73;
thus L153: thesis by L152 , L151 , XTUPLE_0:1;
end;
theorem
L154: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds ( Maps (R2 , R3) ) c= ( Maps R1 ))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let C27 being set;
assume L155: C27 in ( Maps (R2 , R3) );
L156: (ex B22 being (Element of ( Funcs R1 )) st (C27 = [ [ R2 , R3 ] , B22 ] & [ [ R2 , R3 ] , B22 ] in ( Maps R1 ))) by L155;
thus L157: thesis by L156;
end;
L158: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for B23 being Function holds ([ [ R2 , R3 ] , B23 ] in ( Maps (R2 , R3) ) implies ((R3 = ( {} ) implies R2 = ( {} )) & B23 is (Function of R2 , R3)))))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
L159: ( Maps (R2 , R3) ) c= ( Maps R1 ) by L154;
let C28 being Function;
assume L160: [ [ R2 , R3 ] , C28 ] in ( Maps (R2 , R3) );
thus L161: thesis by L160 , L159 , L91;
end;
theorem
L162: (for R1 being non  empty set holds ( Maps R1 ) = ( union { ( Maps (R2 , R3) ) where R2 is (Element of R1) , R3 is (Element of R1) : (not contradiction) } ))
proof
let R1 being non  empty set;
set D11 = { ( Maps (R2 , R3) ) where R2 is (Element of R1) , R3 is (Element of R1) : (not contradiction) };
L163:
now
let C29 being set;
thus L164: (C29 in ( Maps R1 ) implies C29 in ( union D11 ))
proof
assume L165: C29 in ( Maps R1 );
consider C30 being (Element of ( Funcs R1 )), C31 , C32 being (Element of R1) such that L166: (C29 = [ [ C31 , C32 ] , C30 ] & (C32 = ( {} ) implies C31 = ( {} )) & C30 is (Function of C31 , C32)) by L165 , L38;
L167: ( Maps (C31 , C32) ) in D11;
L168: C29 in ( Maps (C31 , C32) ) by L166 , L145;
thus L169: thesis by L168 , L167 , TARSKI:def 4;
end;

assume L170: C29 in ( union D11 );
consider C33 being set such that L171: C29 in C33 and L172: C33 in D11 by L170 , TARSKI:def 4;
consider R2 being (Element of R1), R3 being (Element of R1) such that L173: C33 = ( Maps (R2 , R3) ) by L172;
L174: (ex B24 being (Element of ( Funcs R1 )) st (C29 = [ [ R2 , R3 ] , B24 ] & [ [ R2 , R3 ] , B24 ] in ( Maps R1 ))) by L171 , L173;
thus L175: C29 in ( Maps R1 ) by L174;
end;
thus L176: thesis by L163 , TARSKI:1;
end;
theorem
L177: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R8 being (Element of ( Maps R1 )) holds (R8 in ( Maps (R2 , R3) ) iff (( dom R8 ) = R2 & ( cod R8 ) = R3))))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R8 being (Element of ( Maps R1 ));
L178: ( R8 `2 ) is (Function of ( dom R8 ) , ( cod R8 )) by L81;
thus L179: (R8 in ( Maps (R2 , R3) ) implies (( dom R8 ) = R2 & ( cod R8 ) = R3))
proof
assume L180: R8 in ( Maps (R2 , R3) );
L181: R8 = [ [ R2 , R3 ] , ( R8 `2 ) ] by L180 , L149;
L182: R8 = [ [ ( dom R8 ) , ( cod R8 ) ] , ( R8 `2 ) ] by L73;
thus L183: thesis by L182 , L181 , L55;
end;

L184: (( cod R8 ) <> ( {} ) or ( dom R8 ) = ( {} )) by L81;
L185: [ [ ( dom R8 ) , ( cod R8 ) ] , ( R8 `2 ) ] in ( Maps (( dom R8 ) , ( cod R8 )) ) by L184 , L178 , L145;
thus L186: thesis by L185 , L73;
end;
theorem
L187: (for R1 being non  empty set holds (for R2 being (Element of R1) holds (for R3 being (Element of R1) holds (for R8 being (Element of ( Maps R1 )) holds (R8 in ( Maps (R2 , R3) ) implies ( R8 `2 ) in ( Funcs (R2 , R3) ))))))
proof
let R1 being non  empty set;
let R2 being (Element of R1);
let R3 being (Element of R1);
let R8 being (Element of ( Maps R1 ));
assume L188: R8 in ( Maps (R2 , R3) );
L189: R8 = [ [ R2 , R3 ] , ( R8 `2 ) ] by L188 , L149;
L190: ( R8 `2 ) is (Function of R2 , R3) by L189 , L188 , L158;
L191: (R3 = ( {} ) implies R2 = ( {} )) by L188 , L189 , L158;
thus L192: thesis by L191 , L190 , FUNCT_2:8;
end;
L193: (for R1 being non  empty set holds (for B25 being non  empty (Subset of R1) holds (for B26 , B27 being (Element of B25) holds (for B28 , B29 being (Element of R1) holds ((B26 = B28 & B27 = B29) implies ( Maps (B26 , B27) ) = ( Maps (B28 , B29) ))))))
proof
let R1 being non  empty set;
let C34 being non  empty (Subset of R1);
let C35 , C36 being (Element of C34);
let C37 , C38 being (Element of R1);
assume that
L194: (C35 = C37 & C36 = C38);
L195:
now
let C39 being set;
thus L196: (C39 in ( Maps (C35 , C36) ) implies C39 in ( Maps (C37 , C38) ))
proof
L197: ( Maps C34 ) c= ( Maps R1 ) by L50;
assume L198: C39 in ( Maps (C35 , C36) );
L199: ( Maps (C35 , C36) ) c= ( Maps C34 ) by L154;
reconsider D12 = C39 as (Element of ( Maps C34 )) by L199 , L198;
L200: D12 = [ [ ( dom D12 ) , ( cod D12 ) ] , ( D12 `2 ) ] by L73;
L201: C39 in ( Maps C34 ) by L198 , L199;
reconsider D13 = C39 as (Element of ( Maps R1 )) by L201 , L197;
L202: (( dom D12 ) = ( dom D13 ) & ( cod D12 ) = ( cod D13 ));
L203: D12 = [ [ C35 , C36 ] , ( D12 `2 ) ] by L198 , L149;
L204: (( dom D12 ) = C35 & ( cod D12 ) = C36) by L203 , L200 , L55;
thus L205: thesis by L204 , L194 , L202 , L177;
end;

assume L206: C39 in ( Maps (C37 , C38) );
L207: ( Maps (C37 , C38) ) c= ( Maps R1 ) by L154;
reconsider D14 = C39 as (Element of ( Maps R1 )) by L207 , L206;
L208: D14 = [ [ C37 , C38 ] , ( D14 `2 ) ] by L206 , L149;
L209: ( D14 `2 ) is (Function of C37 , C38) by L208 , L206 , L158;
L210: (C38 = ( {} ) implies C37 = ( {} )) by L206 , L208 , L158;
thus L211: C39 in ( Maps (C35 , C36) ) by L210 , L194 , L208 , L209 , L145;
end;
thus L212: thesis by L195 , TARSKI:1;
end;
definition
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
attr R8 is  surjective
means
( rng ( R8 `2 ) ) = ( cod R8 );
end;
begin
definition
let R1 being non  empty set;
func fDom R1 -> (Function of ( Maps R1 ) , R1) means 
:L214: (for R8 being (Element of ( Maps R1 )) holds ( it . R8 ) = ( dom R8 ));
existence
proof
deffunc H1((Element of ( Maps R1 ))) = ( dom $1 );
L215: (ex B30 being (Function of ( Maps R1 ) , R1) st (for R8 being (Element of ( Maps R1 )) holds ( B30 . R8 ) = H1(R8))) from FUNCT_2:sch 4;
thus L216: thesis by L215;
end;
uniqueness
proof
let C40 , C41 being (Function of ( Maps R1 ) , R1);
assume that
L217: (for R8 being (Element of ( Maps R1 )) holds ( C40 . R8 ) = ( dom R8 ))
and
L218: (for R8 being (Element of ( Maps R1 )) holds ( C41 . R8 ) = ( dom R8 ));
L219:
now
let R8 being (Element of ( Maps R1 ));
thus L220: ( C40 . R8 ) = ( dom R8 ) by L217
.= ( C41 . R8 ) by L218;
end;
thus L221: thesis by L219 , FUNCT_2:63;
end;
func fCod R1 -> (Function of ( Maps R1 ) , R1) means 
:L222: (for R8 being (Element of ( Maps R1 )) holds ( it . R8 ) = ( cod R8 ));
existence
proof
deffunc H2((Element of ( Maps R1 ))) = ( cod $1 );
L223: (ex B31 being (Function of ( Maps R1 ) , R1) st (for R8 being (Element of ( Maps R1 )) holds ( B31 . R8 ) = H2(R8))) from FUNCT_2:sch 4;
thus L224: thesis by L223;
end;
uniqueness
proof
let C42 , C43 being (Function of ( Maps R1 ) , R1);
assume that
L225: (for R8 being (Element of ( Maps R1 )) holds ( C42 . R8 ) = ( cod R8 ))
and
L226: (for R8 being (Element of ( Maps R1 )) holds ( C43 . R8 ) = ( cod R8 ));
L227:
now
let R8 being (Element of ( Maps R1 ));
thus L228: ( C42 . R8 ) = ( cod R8 ) by L225
.= ( C43 . R8 ) by L226;
end;
thus L229: thesis by L227 , FUNCT_2:63;
end;
func fComp R1 -> (PartFunc of [: ( Maps R1 ) , ( Maps R1 ) :] , ( Maps R1 )) means 
:L230: ((for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds ([ R10 , R9 ] in ( dom it ) iff ( dom R10 ) = ( cod R9 )))) & (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds (( dom R10 ) = ( cod R9 ) implies ( it . [ R10 , R9 ] ) = ( R10 * R9 )))));
existence
proof
defpred S1[ set , set , set ] means (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds ((R10 = $1 & R9 = $2) implies (( dom R10 ) = ( cod R9 ) & $3 = ( R10 * R9 )))));
L231: (for B32 , B33 , B34 , B35 being set holds ((B32 in ( Maps R1 ) & B33 in ( Maps R1 ) & S1[ B32 , B33 , B34 ] & S1[ B32 , B33 , B35 ]) implies B34 = B35))
proof
let C44 , C45 , C46 , C47 being set;
assume L232: (C44 in ( Maps R1 ) & C45 in ( Maps R1 ));
reconsider D15 = C44 , D16 = C45 as (Element of ( Maps R1 )) by L232;
assume that
L233: S1[ C44 , C45 , C46 ]
and
L234: S1[ C44 , C45 , C47 ];
L235: C46 = ( D15 * D16 ) by L233;
thus L236: thesis by L235 , L234;
end;
L237: (for B36 , B37 , B38 being set holds ((B36 in ( Maps R1 ) & B37 in ( Maps R1 ) & S1[ B36 , B37 , B38 ]) implies B38 in ( Maps R1 )))
proof
let C48 , C49 , C50 being set;
assume L238: (C48 in ( Maps R1 ) & C49 in ( Maps R1 ));
reconsider D17 = C48 , D18 = C49 as (Element of ( Maps R1 )) by L238;
assume L239: S1[ C48 , C49 , C50 ];
L240: C50 = ( D17 * D18 ) by L239;
thus L241: thesis by L240;
end;
consider C51 being (PartFunc of [: ( Maps R1 ) , ( Maps R1 ) :] , ( Maps R1 )) such that L242: (for B39 , B40 being set holds ([ B39 , B40 ] in ( dom C51 ) iff (B39 in ( Maps R1 ) & B40 in ( Maps R1 ) & (ex B41 being set st S1[ B39 , B40 , B41 ])))) and L243: (for B42 , B43 being set holds ([ B42 , B43 ] in ( dom C51 ) implies S1[ B42 , B43 , ( C51 . (B42 , B43) ) ])) from BINOP_1:sch 5(L237 , L231);
take C51;
thus L244: (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds ([ R10 , R9 ] in ( dom C51 ) iff ( dom R10 ) = ( cod R9 ))))
proof
let R10 being (Element of ( Maps R1 ));
let R9 being (Element of ( Maps R1 ));
thus L245: ([ R10 , R9 ] in ( dom C51 ) implies ( dom R10 ) = ( cod R9 ))
proof
assume L246: [ R10 , R9 ] in ( dom C51 );
L247: (ex B44 being set st S1[ R10 , R9 , B44 ]) by L246 , L242;
thus L248: thesis by L247;
end;

assume L249: ( dom R10 ) = ( cod R9 );
L250: S1[ R10 , R9 , ( R10 * R9 ) ] by L249;
thus L251: thesis by L250 , L242;
end;

let R10 being (Element of ( Maps R1 ));
let R9 being (Element of ( Maps R1 ));
assume L252: ( dom R10 ) = ( cod R9 );
L253: [ R10 , R9 ] in ( dom C51 ) by L252 , L244;
L254: S1[ R10 , R9 , ( C51 . (R10 , R9) ) ] by L253 , L243;
thus L255: thesis by L254;
end;
uniqueness
proof
let C52 , C53 being (PartFunc of [: ( Maps R1 ) , ( Maps R1 ) :] , ( Maps R1 ));
assume that
L256: (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds ([ R10 , R9 ] in ( dom C52 ) iff ( dom R10 ) = ( cod R9 ))))
and
L257: (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds (( dom R10 ) = ( cod R9 ) implies ( C52 . [ R10 , R9 ] ) = ( R10 * R9 ))))
and
L258: (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds ([ R10 , R9 ] in ( dom C53 ) iff ( dom R10 ) = ( cod R9 ))))
and
L259: (for R10 being (Element of ( Maps R1 )) holds (for R9 being (Element of ( Maps R1 )) holds (( dom R10 ) = ( cod R9 ) implies ( C53 . [ R10 , R9 ] ) = ( R10 * R9 ))));
L260: ( dom C53 ) c= [: ( Maps R1 ) , ( Maps R1 ) :] by RELAT_1:def 18;
L261: ( dom C52 ) c= [: ( Maps R1 ) , ( Maps R1 ) :] by RELAT_1:def 18;
L262: ( dom C52 ) = ( dom C53 )
proof
let C54 , C55 being set;
thus L263: ([ C54 , C55 ] in ( dom C52 ) implies [ C54 , C55 ] in ( dom C53 ))
proof
assume L264: [ C54 , C55 ] in ( dom C52 );
reconsider D19 = C54 , D20 = C55 as (Element of ( Maps R1 )) by L264 , L261 , ZFMISC_1:87;
L265: ( dom D19 ) = ( cod D20 ) by L256 , L264;
thus L266: thesis by L265 , L258;
end;

assume L267: [ C54 , C55 ] in ( dom C53 );
reconsider D21 = C54 , D22 = C55 as (Element of ( Maps R1 )) by L267 , L260 , ZFMISC_1:87;
L268: ( dom D21 ) = ( cod D22 ) by L258 , L267;
thus L269: thesis by L268 , L256;
end;
L270:
now
let C56 being (Element of [: ( Maps R1 ) , ( Maps R1 ) :]);
consider R10 being (Element of ( Maps R1 )), R9 being (Element of ( Maps R1 )) such that L271: C56 = [ R10 , R9 ] by DOMAIN_1:1;
assume L272: C56 in ( dom C52 );
L273: ( dom R10 ) = ( cod R9 ) by L272 , L256 , L271;
L274: ( C52 . [ R10 , R9 ] ) = ( R10 * R9 ) by L273 , L257;
thus L275: ( C52 . C56 ) = ( C53 . C56 ) by L274 , L259 , L271 , L273;
end;
thus L276: thesis by L270 , L262 , PARTFUN1:5;
end;
end;
definition
canceled 1;
let R1 being non  empty set;
func Ens R1 -> non  empty non  void  strict CatStr equals 
CatStr (# R1 , ( Maps R1 ) , ( fDom R1 ) , ( fCod R1 ) , ( fComp R1 ) #);
coherence;
end;
registration
let R1 being non  empty set;
cluster ( Ens R1 ) ->  Category-like  reflexive  transitive  associative  with_identities;
coherence
proof
set D23 = ( Maps R1 );
set D24 = ( fDom R1 );
set D25 = ( fCod R1 );
set D26 = ( fComp R1 );
reconsider D27 = CatStr (# R1 , D23 , D24 , D25 , D26 #) as non  empty non  void CatStr;
L279: D27 is  Category-like
proof
let C57 , C58 being (Morphism of D27);
reconsider D28 = C57 , D29 = C58 as (Element of D23);
L280: (( D24 . D29 ) = ( dom D29 ) & ( D25 . D28 ) = ( cod D28 )) by L214 , L222;
thus L281: thesis by L280 , L230;
end;
L282: D27 is  transitive
proof
let C59 , C60 being (Morphism of D27);
assume that
L283: ( dom C60 ) = ( cod C59 );
L284: [ C60 , C59 ] in ( dom (the Comp of D27) ) by L283 , L279 , CAT_1:def 6;
L285: ( (the Comp of D27) . (C60 , C59) ) = ( C60 (*) C59 ) by L284 , CAT_1:def 1;
reconsider D30 = C59 , D31 = C60 as (Element of D23);
L286: (( D24 . D31 ) = ( dom D31 ) & ( D25 . D30 ) = ( cod D30 )) by L214 , L222;
L287: ( D26 . [ D31 , D30 ] ) = ( D31 * D30 ) by L286 , L283 , L230;
L288: (( D24 . D30 ) = ( dom D30 ) & ( D25 . D31 ) = ( cod D31 )) by L214 , L222;
L289: (( dom ( D31 * D30 ) ) = ( dom D30 ) & ( cod ( D31 * D30 ) ) = ( cod D31 )) by L283 , L286 , L109;
thus L290: thesis by L289 , L287 , L288 , L214 , L222 , L285;
end;
L291: D27 is  associative
proof
let C61 , C62 , C63 being (Morphism of D27);
assume that
L292: ( dom C63 ) = ( cod C62 )
and
L293: ( dom C62 ) = ( cod C61 );
reconsider D32 = C61 , D33 = C62 , D34 = C63 as (Element of D23);
L294: (( dom D34 ) = ( D24 . D34 ) & ( cod D33 ) = ( D25 . D33 )) by L214 , L222;
L295: ( dom ( D34 * D33 ) ) = ( dom D33 ) by L294 , L292 , L109;
L296: (( dom D33 ) = ( D24 . D33 ) & ( cod D32 ) = ( D25 . D32 )) by L214 , L222;
L297: ( cod ( D33 * D32 ) ) = ( dom D34 ) by L296 , L292 , L293 , L294 , L109;
L298: [ C63 , C62 ] in ( dom (the Comp of D27) ) by L292 , L279 , CAT_1:def 6;
L299: ( C63 (*) C62 ) = ( (the Comp of D27) . (C63 , C62) ) by L298 , CAT_1:def 1;
L300: ( dom ( C63 (*) C62 ) ) = ( dom C62 ) by L282 , CAT_1:def 7 , L292;
L301: [ ( C63 (*) C62 ) , C61 ] in ( dom (the Comp of D27) ) by L300 , L279 , CAT_1:def 6 , L293;
L302: [ C62 , C61 ] in ( dom (the Comp of D27) ) by L293 , L279 , CAT_1:def 6;
L303: ( C62 (*) C61 ) = ( (the Comp of D27) . (C62 , C61) ) by L302 , CAT_1:def 1;
L304: ( cod ( C62 (*) C61 ) ) = ( cod C62 ) by L282 , CAT_1:def 7 , L293;
L305: [ C63 , ( C62 (*) C61 ) ] in ( dom (the Comp of D27) ) by L304 , L279 , CAT_1:def 6 , L292;
thus L306: ( C63 (*) ( C62 (*) C61 ) ) = ( (the Comp of D27) . (C63 , ( (the Comp of D27) . (C62 , C61) )) ) by L305 , L303 , CAT_1:def 1
.= ( D26 . [ D34 , ( D33 * D32 ) ] ) by L293 , L296 , L230
.= ( D34 * ( D33 * D32 ) ) by L297 , L230
.= ( ( D34 * D33 ) * D32 ) by L292 , L293 , L294 , L296 , L113
.= ( D26 . [ ( D34 * D33 ) , D32 ] ) by L293 , L296 , L295 , L230
.= ( (the Comp of D27) . (( (the Comp of D27) . (C63 , C62) ) , C61) ) by L292 , L294 , L230
.= ( ( C63 (*) C62 ) (*) C61 ) by L301 , L299 , CAT_1:def 1;
end;
L307: D27 is  reflexive
proof
let C64 being (Element of D27);
reconsider D35 = C64 as (Element of R1);
reconsider D36 = ( id$ D35 ) as (Morphism of D27);
L308: ( cod D36 ) = ( cod ( id$ D35 ) ) by L222
.= C64 by L98;
L309: ( dom D36 ) = ( dom ( id$ D35 ) ) by L214
.= C64 by L98;
L310: D36 in ( Hom (C64 , C64) ) by L309 , L308;
thus L311: ( Hom (C64 , C64) ) <> ( {} ) by L310;
end;
L312: D27 is  with_identities
proof
let C65 being (Element of D27);
reconsider D37 = C65 as (Element of R1);
reconsider D38 = ( id$ D37 ) as (Morphism of D27);
L313: ( cod D38 ) = ( cod ( id$ D37 ) ) by L222
.= C65 by L98;
L314: ( dom D38 ) = ( dom ( id$ D37 ) ) by L214
.= C65 by L98;
reconsider D39 = D38 as (Morphism of C65 , C65) by L314 , L313 , CAT_1:4;
take D39;
let C66 being (Element of D27);
thus L315: (( Hom (C65 , C66) ) <> ( {} ) implies (for B45 being (Morphism of C65 , C66) holds ( B45 (*) D39 ) = B45))
proof
assume L316: ( Hom (C65 , C66) ) <> ( {} );
let C67 being (Morphism of C65 , C66);
reconsider D40 = C67 as (Element of ( Maps R1 ));
L317: ( dom D40 ) = ( dom C67 ) by L214
.= D37 by L316 , CAT_1:5;
L318: ( cod ( id$ D37 ) ) = ( dom D40 ) by L317 , L98;
L319: ( dom C67 ) = C65 by L316 , CAT_1:5;
L320: [ C67 , D39 ] in ( dom D26 ) by L319 , L313 , L279 , CAT_1:def 6;
thus L321: ( C67 (*) D39 ) = ( D26 . (C67 , D39) ) by L320 , CAT_1:def 1
.= ( D40 * ( id$ D37 ) ) by L318 , L230
.= C67 by L317 , L129;
end;

assume L322: ( Hom (C66 , C65) ) <> ( {} );
let C68 being (Morphism of C66 , C65);
reconsider D41 = C68 as (Element of ( Maps R1 ));
L323: ( cod D41 ) = ( cod C68 ) by L222
.= D37 by L322 , CAT_1:5;
L324: ( dom ( id$ D37 ) ) = ( cod D41 ) by L323 , L98;
L325: ( cod C68 ) = C65 by L322 , CAT_1:5;
L326: [ D39 , C68 ] in ( dom D26 ) by L325 , L314 , L279 , CAT_1:def 6;
thus L327: ( D39 (*) C68 ) = ( D26 . (D39 , C68) ) by L326 , CAT_1:def 1
.= ( ( id$ D37 ) * D41 ) by L324 , L230
.= C68 by L323 , L129;
end;
thus L328: thesis by L312 , L279 , L282 , L291 , L307;
end;
end;
canceled 1;
theorem
L330: (for R1 being non  empty set holds (for R2 being (Element of R1) holds R2 is (Object of ( Ens R1 ))));
definition
let R1 being non  empty set;
let R2 being (Element of R1);
func @ R2 -> (Object of ( Ens R1 )) equals 
R2;
coherence;
end;
theorem
L332: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds R13 is (Element of R1)));
definition
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
func @ R13 -> (Element of R1) equals 
R13;
coherence;
end;
theorem
L334: (for R1 being non  empty set holds (for R8 being (Element of ( Maps R1 )) holds R8 is (Morphism of ( Ens R1 ))));
definition
let R1 being non  empty set;
let R8 being (Element of ( Maps R1 ));
func @ R8 -> (Morphism of ( Ens R1 )) equals 
R8;
coherence;
end;
theorem
L336: (for R1 being non  empty set holds (for R15 being (Morphism of ( Ens R1 )) holds R15 is (Element of ( Maps R1 ))));
definition
let R1 being non  empty set;
let R15 being (Morphism of ( Ens R1 ));
func @ R15 -> (Element of ( Maps R1 )) equals 
R15;
coherence;
end;
theorem
L338: (for R1 being non  empty set holds (for R15 being (Morphism of ( Ens R1 )) holds (( dom R15 ) = ( dom ( @ R15 ) ) & ( cod R15 ) = ( cod ( @ R15 ) )))) by L214 , L222;
theorem
L339: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds (for R14 being (Object of ( Ens R1 )) holds ( Hom (R13 , R14) ) = ( Maps (( @ R13 ) , ( @ R14 )) ))))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
let R14 being (Object of ( Ens R1 ));
L340:
now
let C69 being set;
thus L341: (C69 in ( Hom (R13 , R14) ) implies C69 in ( Maps (( @ R13 ) , ( @ R14 )) ))
proof
assume L342: C69 in ( Hom (R13 , R14) );
reconsider D42 = C69 as (Morphism of ( Ens R1 )) by L342;
L343: ( cod D42 ) = R14 by L342 , CAT_1:1;
L344: ( cod ( @ D42 ) ) = ( @ R14 ) by L343 , L222;
L345: ( dom D42 ) = R13 by L342 , CAT_1:1;
L346: ( dom ( @ D42 ) ) = ( @ R13 ) by L345 , L214;
thus L347: thesis by L346 , L344 , L177;
end;

assume L348: C69 in ( Maps (( @ R13 ) , ( @ R14 )) );
L349: ( Maps (( @ R13 ) , ( @ R14 )) ) c= ( Maps R1 ) by L154;
reconsider D43 = C69 as (Element of ( Maps R1 )) by L349 , L348;
L350: ( cod D43 ) = ( @ R14 ) by L348 , L177;
L351: ( cod ( @ D43 ) ) = R14 by L350 , L222;
L352: ( dom D43 ) = ( @ R13 ) by L348 , L177;
L353: ( dom ( @ D43 ) ) = R13 by L352 , L214;
thus L354: C69 in ( Hom (R13 , R14) ) by L353 , L351;
end;
thus L355: thesis by L340 , TARSKI:1;
end;
L356: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds (for R14 being (Object of ( Ens R1 )) holds (( Hom (R13 , R14) ) <> ( {} ) implies ( Funcs (( @ R13 ) , ( @ R14 )) ) <> ( {} )))))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
let R14 being (Object of ( Ens R1 ));
set D44 = the (Element of ( Maps (( @ R13 ) , ( @ R14 )) ));
assume L357: ( Hom (R13 , R14) ) <> ( {} );
L358: ( Maps (( @ R13 ) , ( @ R14 )) ) <> ( {} ) by L357 , L339;
reconsider D45 = D44 as (Element of ( Maps R1 )) by L358 , TARSKI:def 3 , L154;
L359: ( D45 `2 ) in ( Funcs (( @ R13 ) , ( @ R14 )) ) by L358 , L187;
thus L360: thesis by L359;
end;
theorem
L361: (for R1 being non  empty set holds (for R15 being (Morphism of ( Ens R1 )) holds (for R16 being (Morphism of ( Ens R1 )) holds (( dom R16 ) = ( cod R15 ) implies ( R16 (*) R15 ) = ( ( @ R16 ) * ( @ R15 ) )))))
proof
let R1 being non  empty set;
let R15 being (Morphism of ( Ens R1 ));
let R16 being (Morphism of ( Ens R1 ));
assume L362: ( dom R16 ) = ( cod R15 );
L363: ( dom ( @ R16 ) ) = ( cod R15 ) by L362 , L214;
L364: ( dom ( @ R16 ) ) = ( cod ( @ R15 ) ) by L363 , L222;
thus L365: ( R16 (*) R15 ) = ( (the Comp of ( Ens R1 )) . (( @ R16 ) , R15) ) by L362 , CAT_1:16
.= ( ( @ R16 ) * ( @ R15 ) ) by L364 , L230;
end;
theorem
L366: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds ( id R13 ) = ( id$ ( @ R13 ) )))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
reconsider D46 = R13 as (Element of R1);
reconsider D47 = ( id$ D46 ) as (Morphism of ( Ens R1 ));
L367: ( cod D47 ) = ( cod ( id$ D46 ) ) by L222
.= R13 by L98;
L368: ( dom D47 ) = ( dom ( id$ D46 ) ) by L214
.= R13 by L98;
reconsider D48 = D47 as (Morphism of R13 , R13) by L368 , L367 , CAT_1:4;
L369: (for B46 being (Object of ( Ens R1 )) holds ((( Hom (R13 , B46) ) <> ( {} ) implies (for B47 being (Morphism of R13 , B46) holds ( B47 (*) D48 ) = B47)) & (( Hom (B46 , R13) ) <> ( {} ) implies (for B48 being (Morphism of B46 , R13) holds ( D48 (*) B48 ) = B48))))
proof
let C70 being (Element of ( Ens R1 ));
set D49 = (the Comp of ( Ens R1 ));
thus L370: (( Hom (R13 , C70) ) <> ( {} ) implies (for B49 being (Morphism of R13 , C70) holds ( B49 (*) D48 ) = B49))
proof
assume L371: ( Hom (R13 , C70) ) <> ( {} );
let C71 being (Morphism of R13 , C70);
reconsider D50 = C71 as (Element of ( Maps R1 ));
L372: ( dom D50 ) = ( dom C71 ) by L214
.= D46 by L371 , CAT_1:5;
L373: ( cod ( id$ D46 ) ) = ( dom D50 ) by L372 , L98;
L374: ( dom C71 ) = R13 by L371 , CAT_1:5;
L375: [ C71 , D48 ] in ( dom D49 ) by L374 , L367 , CAT_1:def 6;
thus L376: ( C71 (*) D48 ) = ( D49 . (C71 , D48) ) by L375 , CAT_1:def 1
.= ( D50 * ( id$ D46 ) ) by L373 , L230
.= C71 by L372 , L129;
end;

assume L377: ( Hom (C70 , R13) ) <> ( {} );
let C72 being (Morphism of C70 , R13);
reconsider D51 = C72 as (Element of ( Maps R1 ));
L378: ( cod D51 ) = ( cod C72 ) by L222
.= D46 by L377 , CAT_1:5;
L379: ( dom ( id$ D46 ) ) = ( cod D51 ) by L378 , L98;
L380: ( cod C72 ) = R13 by L377 , CAT_1:5;
L381: [ D48 , C72 ] in ( dom D49 ) by L380 , L368 , CAT_1:def 6;
thus L382: ( D48 (*) C72 ) = ( D49 . (D48 , C72) ) by L381 , CAT_1:def 1
.= ( ( id$ D46 ) * D51 ) by L379 , L230
.= C72 by L378 , L129;
end;
thus L383: thesis by L369 , CAT_1:def 12;
end;
theorem
L384: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds (R13 = ( {} ) implies R13 is  initial)))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
assume L385: R13 = ( {} );
let R14 being (Object of ( Ens R1 ));
L386: ( Maps (( @ R13 ) , ( @ R14 )) ) <> ( {} ) by L385 , L145;
thus L387: ( Hom (R13 , R14) ) <> ( {} ) by L386 , L339;
set D52 = [ [ ( @ R13 ) , ( @ R14 ) ] , ( {} ) ];
L388: ( {} ) is (Function of ( @ R13 ) , ( @ R14 )) by L385 , RELSET_1:12;
L389: D52 in ( Maps (( @ R13 ) , ( @ R14 )) ) by L388 , L385 , L145;
L390: D52 in ( Hom (R13 , R14) ) by L389 , L339;
reconsider D53 = D52 as (Morphism of R13 , R14) by L390 , CAT_1:def 5;
take D53;
let C73 being (Morphism of R13 , R14);
reconsider D54 = C73 as (Element of ( Maps R1 ));
L391: C73 in ( Hom (R13 , R14) ) by L387 , CAT_1:def 5;
L392: C73 in ( Maps (( @ R13 ) , ( @ R14 )) ) by L391 , L339;
L393: D54 = [ [ ( @ R13 ) , ( @ R14 ) ] , ( D54 `2 ) ] by L392 , L149;
L394: ( D54 `2 ) is (Function of ( @ R13 ) , ( @ R14 )) by L393 , L392 , L158;
thus L395: thesis by L394 , L385 , L393;
end;
theorem
L396: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds ((( {} ) in R1 & R13 is  initial) implies R13 = ( {} ))))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
assume L397: ( {} ) in R1;
reconsider D55 = ( {} ) as (Element of R1) by L397;
set D56 = ( @ D55 );
assume L398: R13 is  initial;
L399: ( Hom (R13 , D56) ) <> ( {} ) by L398 , CAT_1:def 19;
L400: ( Funcs (( @ R13 ) , ( @ D56 )) ) <> ( {} ) by L399 , L356;
thus L401: thesis by L400;
end;
theorem
L402: (for B50 being Universe holds (for B51 being (Object of ( Ens B50 )) holds (B51 is  initial implies B51 = ( {} )))) by L396 , CLASSES2:56;
theorem
L403: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds ((ex B52 being set st R13 = { B52 }) implies R13 is  terminal)))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
given C74 being set such that
L404: R13 = { C74 };

let R14 being (Object of ( Ens R1 ));
set D57 = the (Function of ( @ R14 ) , ( @ R13 ));
set D58 = [ [ ( @ R14 ) , ( @ R13 ) ] , D57 ];
L405: D58 in ( Maps (( @ R14 ) , ( @ R13 )) ) by L404 , L145;
thus L406: ( Hom (R14 , R13) ) <> ( {} ) by L405 , L339;
L407: D58 in ( Hom (R14 , R13) ) by L405 , L339;
reconsider D59 = D58 as (Morphism of R14 , R13) by L407 , CAT_1:def 5;
take D59;
let C75 being (Morphism of R14 , R13);
reconsider D60 = C75 as (Element of ( Maps R1 ));
L408: C75 in ( Hom (R14 , R13) ) by L406 , CAT_1:def 5;
L409: C75 in ( Maps (( @ R14 ) , ( @ R13 )) ) by L408 , L339;
L410: D60 = [ [ ( @ R14 ) , ( @ R13 ) ] , ( D60 `2 ) ] by L409 , L149;
L411: ( D60 `2 ) is (Function of ( @ R14 ) , ( @ R13 )) by L410 , L409 , L158;
thus L412: thesis by L411 , L404 , L410 , FUNCT_2:51;
end;
theorem
L413: (for R1 being non  empty set holds (for R13 being (Object of ( Ens R1 )) holds ((R1 <> { ( {} ) } & R13 is  terminal) implies (ex B53 being set st R13 = { B53 }))))
proof
let R1 being non  empty set;
let R13 being (Object of ( Ens R1 ));
assume that
L414: R1 <> { ( {} ) }
and
L415: R13 is  terminal;
set D61 = the (Element of ( @ R13 ));
L416:
now
assume L417: ( @ R13 ) = ( {} );
L418:
now
consider C76 being set such that L419: C76 in R1 and L420: C76 <> ( {} ) by L414 , ZFMISC_1:35;
reconsider D62 = C76 as (Element of R1) by L419;
set D63 = ( @ D62 );
L421: ( Hom (D63 , R13) ) <> ( {} ) by L415 , CAT_1:def 18;
L422: ( Funcs (( @ D63 ) , ( @ R13 )) ) <> ( {} ) by L421 , L356;
thus L423: contradiction by L422 , L417 , L420;
end;
thus L424: contradiction by L418;
end;
L425:
now
assume L426: R13 <> { D61 };
consider C77 being set such that L427: C77 in ( @ R13 ) and L428: C77 <> D61 by L426 , L416 , ZFMISC_1:35;
reconsider D64 = ( ( @ R13 ) --> C77 ) as (Function of ( @ R13 ) , ( @ R13 )) by L427 , FUNCOP_1:45;
reconsider D65 = ( ( @ R13 ) --> D61 ) as (Function of ( @ R13 ) , ( @ R13 )) by L427 , FUNCOP_1:45;
L429: ( D65 . C77 ) = D61 by L427 , FUNCOP_1:7;
L430: D65 <> D64 by L429 , L427 , L428 , FUNCOP_1:7;
L431: [ [ ( @ R13 ) , ( @ R13 ) ] , D65 ] in ( Maps (( @ R13 ) , ( @ R13 )) ) by L145;
L432: [ [ ( @ R13 ) , ( @ R13 ) ] , D64 ] in ( Maps (( @ R13 ) , ( @ R13 )) ) by L145;
L433: ( Maps (( @ R13 ) , ( @ R13 )) ) c= ( Maps R1 ) by L154;
reconsider D66 = [ [ ( @ R13 ) , ( @ R13 ) ] , D65 ] , D67 = [ [ ( @ R13 ) , ( @ R13 ) ] , D64 ] as (Element of ( Maps R1 )) by L433 , L431 , L432;
L434: D67 in ( Hom (R13 , R13) ) by L432 , L339;
L435: D66 in ( Hom (R13 , R13) ) by L431 , L339;
reconsider D68 = ( @ D66 ) , D69 = ( @ D67 ) as (Morphism of R13 , R13) by L435 , L434 , CAT_1:def 5;
consider C78 being (Morphism of R13 , R13) such that L436: (for B54 being (Morphism of R13 , R13) holds C78 = B54) by L415 , CAT_1:def 18;
L437: D68 = C78 by L436
.= D69 by L436;
thus L438: contradiction by L437 , L430 , XTUPLE_0:1;
end;
thus L439: thesis by L425;
end;
theorem
L440: (for B55 being Universe holds (for B56 being (Object of ( Ens B55 )) holds (B56 is  terminal implies (ex B57 being set st B56 = { B57 }))))
proof
let C79 being Universe;
let C80 being (Object of ( Ens C79 ));
L441:
now
L442: { ( {} ) } in C79 by CLASSES2:56 , CLASSES2:57;
assume L443: C79 = { ( {} ) };
thus L444: contradiction by L443 , L442;
end;
thus L445: thesis by L441 , L413;
end;
theorem
L446: (for R1 being non  empty set holds (for B58 , B59 being (Object of ( Ens R1 )) holds (for B60 being (Morphism of B58 , B59) holds (( Hom (B58 , B59) ) <> ( {} ) implies (B60 is  monic iff ( ( @ B60 ) `2 ) is  one-to-one)))))
proof
let R1 being non  empty set;
let C81 , C82 being (Object of ( Ens R1 ));
let C83 being (Morphism of C81 , C82);
assume that
L447: ( Hom (C81 , C82) ) <> ( {} );
set D70 = ( @ C83 );
L448: ( dom D70 ) = ( dom C83 ) by L214;
L449: ( dom ( D70 `2 ) ) = ( dom C83 ) by L448 , L87;
thus L450: (C83 is  monic implies ( ( @ C83 ) `2 ) is  one-to-one)
proof
set D71 = ( dom ( ( @ C83 ) `2 ) );
assume L451: C83 is  monic;
let C84 , C85 being set;
assume that
L452: C84 in D71
and
L453: C85 in D71
and
L454: ( ( ( @ C83 ) `2 ) . C84 ) = ( ( ( @ C83 ) `2 ) . C85 );
L455: D71 = ( dom ( @ C83 ) ) by L87;
reconsider D72 = D71 as (Element of R1) by L455;
L456: ( dom C83 ) = D72 by L455 , L214;
reconsider D73 = ( D72 --> C84 ) , D74 = ( D72 --> C85 ) as (Function of D72 , D72) by L452 , L453 , FUNCOP_1:45;
reconsider D75 = [ [ D72 , D72 ] , D73 ] , D76 = [ [ D72 , D72 ] , D74 ] as (Element of ( Maps R1 )) by L42;
set D77 = ( @ D75 );
set D78 = ( @ D76 );
set D79 = ( ( ( @ C83 ) `2 ) * ( ( @ D77 ) `2 ) );
set D80 = ( ( ( @ C83 ) `2 ) * ( ( @ D78 ) `2 ) );
set D81 = ( ( @ C83 ) * ( @ D77 ) );
set D82 = ( ( @ C83 ) * ( @ D78 ) );
L457: D76 = [ [ ( dom D76 ) , ( cod D76 ) ] , ( D76 `2 ) ] by L73;
L458: ( dom D76 ) = D72 by L457 , L55;
L459: ( cod D76 ) = D72 by L457 , L55;
L460: (( D82 `2 ) = D80 & ( dom D82 ) = ( dom ( @ D78 ) )) by L459 , L455 , L109;
L461: ( cod D82 ) = ( cod ( @ C83 ) ) by L455 , L459 , L109;
L462: D82 = [ [ ( dom ( @ D78 ) ) , ( cod ( @ C83 ) ) ] , D80 ] by L461 , L460 , L73;
L463: ( dom ( @ D78 ) ) = D72 by L457 , L55;
L464: ( dom D78 ) = D72 by L463 , L214;
L465: ( cod ( @ D78 ) ) = D72 by L457 , L55;
L466: ( cod D78 ) = D72 by L465 , L222;
L467: ( C83 (*) D78 ) = D82 by L466 , L456 , L361;
L468: D75 = [ [ ( dom D75 ) , ( cod D75 ) ] , ( D75 `2 ) ] by L73;
L469: ( cod D75 ) = D72 by L468 , L55;
L470: (( D81 `2 ) = D79 & ( dom D81 ) = ( dom ( @ D77 ) )) by L469 , L455 , L109;
L471: ( dom D75 ) = D72 by L468 , L55;
L472:
now
thus L473: (( dom D79 ) = D72 & ( dom D80 ) = D72) by L471 , L458 , L470 , L460 , L87;
let C86 being set;
assume L474: C86 in D72;
L475: D73 = ( D75 `2 ) by L468 , XTUPLE_0:1;
L476: ( ( ( @ D77 ) `2 ) . C86 ) = C84 by L475 , L474 , FUNCOP_1:7;
L477: ( D79 . C86 ) = ( ( ( @ C83 ) `2 ) . C84 ) by L476 , L473 , L474 , FUNCT_1:12;
L478: D74 = ( D76 `2 ) by L457 , XTUPLE_0:1;
L479: ( ( ( @ D78 ) `2 ) . C86 ) = C85 by L478 , L474 , FUNCOP_1:7;
thus L480: ( D79 . C86 ) = ( D80 . C86 ) by L479 , L454 , L473 , L474 , L477 , FUNCT_1:12;
end;
L481: D79 = D80 by L472 , FUNCT_1:2;
L482: ( cod D81 ) = ( cod ( @ C83 ) ) by L455 , L469 , L109;
L483: D81 = [ [ ( dom ( @ D77 ) ) , ( cod ( @ C83 ) ) ] , D79 ] by L482 , L470 , L73;
L484: ( dom ( @ D77 ) ) = D72 by L468 , L55;
L485: ( dom D77 ) = D72 by L484 , L214;
L486: ( cod ( @ D77 ) ) = D72 by L468 , L55;
L487: ( cod D77 ) = D72 by L486 , L222;
reconsider D83 = D72 as (Object of ( Ens R1 ));
L488: ( dom C83 ) = C81 by L447 , CAT_1:5;
L489: (D77 in ( Hom (D83 , C81) ) & D78 in ( Hom (D83 , C81) )) by L488 , L485 , L456 , L487 , L464 , L466;
reconsider D84 = D77 , D85 = D78 as (Morphism of D83 , C81) by L489 , CAT_1:def 5;
L490: ( C83 * D84 ) = ( C83 (*) D84 ) by L447 , L489 , CAT_1:def 13
.= ( C83 (*) D85 ) by L471 , L458 , L483 , L462 , L481 , L467 , L487 , L456 , L361
.= ( C83 * D85 ) by L447 , L489 , CAT_1:def 13;
L491: ( Hom (D83 , C81) ) <> ( {} ) by L488 , L456;
L492: D84 = D85 by L491 , L451 , L490 , CAT_1:def 14;
L493: D73 = D74 by L492 , XTUPLE_0:1;
thus L494: C84 = ( D74 . C84 ) by L493 , L452 , FUNCOP_1:7
.= C85 by L452 , FUNCOP_1:7;
end;

assume L495: ( D70 `2 ) is  one-to-one;
thus L496: ( Hom (C81 , C82) ) <> ( {} ) by L447;
let C87 being (Object of ( Ens R1 ));
assume that
L497: ( Hom (C87 , C81) ) <> ( {} );
let C88 , C89 being (Morphism of C87 , C81);
L498: ( dom C88 ) = C87 by L497 , CAT_1:5
.= ( dom C89 ) by L497 , CAT_1:5;
L499: ( cod C88 ) = C81 by L497 , CAT_1:5
.= ( dom C83 ) by L447 , CAT_1:5;
L500: ( cod C89 ) = C81 by L497 , CAT_1:5
.= ( dom C83 ) by L447 , CAT_1:5;
assume L501: ( C83 * C88 ) = ( C83 * C89 );
set D86 = ( @ C88 );
set D87 = ( @ C89 );
L502: ( D70 * D86 ) = ( C83 (*) C88 ) by L499 , L361
.= ( C83 * C88 ) by L497 , L447 , CAT_1:def 13;
L503: ( D70 * D87 ) = ( C83 (*) C89 ) by L500 , L361
.= ( C83 * C89 ) by L497 , L447 , CAT_1:def 13;
L504: D86 = [ [ ( dom D86 ) , ( cod D86 ) ] , ( D86 `2 ) ] by L73;
L505: ( dom D87 ) = ( dom C89 ) by L214;
L506: ( dom ( D87 `2 ) ) = ( dom C89 ) by L505 , L87;
L507: ( cod D86 ) = ( cod C88 ) by L222;
L508: ( rng ( D86 `2 ) ) c= ( cod C88 ) by L507 , L87;
L509: ( cod D87 ) = ( cod C89 ) by L222;
L510: ( rng ( D87 `2 ) ) c= ( cod C89 ) by L509 , L87;
L511: ( D70 * D87 ) = [ [ ( dom D87 ) , ( cod D70 ) ] , ( ( D70 `2 ) * ( D87 `2 ) ) ] by L500 , L509 , L448 , L102;
L512: ( D70 * D86 ) = [ [ ( dom D86 ) , ( cod D70 ) ] , ( ( D70 `2 ) * ( D86 `2 ) ) ] by L499 , L507 , L448 , L102;
L513: ( ( D70 `2 ) * ( D86 `2 ) ) = ( ( D70 `2 ) * ( D87 `2 ) ) by L512 , L503 , L501 , L502 , L511 , XTUPLE_0:1;
L514: ( dom D86 ) = ( dom C88 ) by L214;
L515: ( dom ( D86 `2 ) ) = ( dom C88 ) by L514 , L87;
L516: ( D86 `2 ) = ( D87 `2 ) by L515 , L495 , L498 , L499 , L500 , L506 , L449 , L508 , L510 , L513 , FUNCT_1:27;
thus L517: thesis by L516 , L498 , L499 , L500 , L514 , L505 , L507 , L509 , L504 , L73;
end;
theorem
L518: (for R1 being non  empty set holds (for B61 , B62 being (Object of ( Ens R1 )) holds (for B63 being (Morphism of B61 , B62) holds (( Hom (B61 , B62) ) <> ( {} ) implies ((B63 is  epi & (ex R2 being (Element of R1) st (ex B64 , B65 being set st (B64 in R2 & B65 in R2 & B64 <> B65)))) implies ( @ B63 ) is  surjective)))))
proof
let R1 being non  empty set;
let C90 , C91 being (Object of ( Ens R1 ));
let C92 being (Morphism of C90 , C91);
assume that
L519: ( Hom (C90 , C91) ) <> ( {} );
assume L520: C92 is  epi;
given C93 being (Element of R1) , C94 , C95 being set such that
L521: C94 in C93
and
L522: C95 in C93
and
L523: C94 <> C95;

L524: ( cod ( @ C92 ) ) c= ( rng ( ( @ C92 ) `2 ) )
proof
set D88 = ( cod ( @ C92 ) );
reconsider D89 = ( D88 --> C94 ) as (Function of D88 , C93) by L521 , FUNCOP_1:45;
let C96 being set;
assume that
L525: C96 in D88
and
L526: (not C96 in ( rng ( ( @ C92 ) `2 ) ));
set D90 = ( { C96 } --> C95 );
set D91 = ( D89 +* D90 );
L527: ( dom D90 ) = { C96 } by FUNCOP_1:13;
L528: ( rng D90 ) = { C95 } by FUNCOP_1:8;
L529: ( rng D89 ) = { C94 } by L525 , FUNCOP_1:8;
L530: ( rng D91 ) c= ( { C94 } \/ { C95 } ) by L529 , L528 , FUNCT_4:17;
L531: ( rng D91 ) c= { C94 , C95 } by L530 , ENUMSET1:1;
L532: { C94 , C95 } c= C93 by L521 , L522 , ZFMISC_1:32;
L533: ( rng D91 ) c= C93 by L532 , L531 , XBOOLE_1:1;
L534: ( dom D89 ) = D88 by FUNCOP_1:13;
L535: ( dom D91 ) = ( D88 \/ { C96 } ) by L534 , L527 , FUNCT_4:def 1
.= D88 by L525 , ZFMISC_1:40;
reconsider D92 = D91 as (Function of D88 , C93) by L535 , L521 , L533 , FUNCT_2:def 1 , RELSET_1:4;
L536: ( cod C92 ) = D88 by L222;
L537: C96 in { C96 } by TARSKI:def 1;
L538: ( D90 . C96 ) = C95 by L537 , FUNCOP_1:7;
L539: ( D92 . C96 ) = C95 by L538 , L537 , L527 , FUNCT_4:13;
L540: ( D89 . C96 ) = C94 by L525 , FUNCOP_1:7;
reconsider D93 = [ [ D88 , C93 ] , D89 ] , D94 = [ [ D88 , C93 ] , D92 ] as (Element of ( Maps R1 )) by L521 , L42;
set D95 = ( @ D93 );
set D96 = ( @ D94 );
set D97 = ( ( ( @ D95 ) `2 ) * ( ( @ C92 ) `2 ) );
set D98 = ( ( ( @ D96 ) `2 ) * ( ( @ C92 ) `2 ) );
set D99 = ( ( @ D95 ) * ( @ C92 ) );
set D100 = ( ( @ D96 ) * ( @ C92 ) );
L541: D93 = [ [ ( dom D93 ) , ( cod D93 ) ] , ( D93 `2 ) ] by L73;
L542: D89 = ( D93 `2 ) by L541 , XTUPLE_0:1;
L543: ( dom D93 ) = D88 by L541 , L55;
L544: (( D99 `2 ) = D97 & ( dom D99 ) = ( dom ( @ C92 ) )) by L543 , L109;
L545: D94 = [ [ ( dom D94 ) , ( cod D94 ) ] , ( D94 `2 ) ] by L73;
L546: ( dom D94 ) = D88 by L545 , L55;
L547: (( D100 `2 ) = D98 & ( dom D100 ) = ( dom ( @ C92 ) )) by L546 , L109;
L548: ( cod ( @ D96 ) ) = C93 by L545 , L55;
L549: ( cod D96 ) = C93 by L548 , L222;
L550: ( dom ( @ D96 ) ) = D88 by L545 , L55;
L551: ( dom D96 ) = D88 by L550 , L214;
L552: ( D96 (*) C92 ) = D100 by L551 , L536 , L361;
L553: D92 = ( D94 `2 ) by L545 , XTUPLE_0:1;
L554:
now
thus L555: (( dom D97 ) = ( dom ( @ C92 ) ) & ( dom D98 ) = ( dom ( @ C92 ) )) by L544 , L547 , L87;
let C97 being set;
set D101 = ( ( ( @ C92 ) `2 ) . C97 );
assume L556: C97 in ( dom ( @ C92 ) );
L557: C97 in ( dom ( ( @ C92 ) `2 ) ) by L556 , L87;
L558: D101 in ( rng ( ( @ C92 ) `2 ) ) by L557 , FUNCT_1:def 3;
L559: (not D101 in { C96 }) by L558 , L526 , TARSKI:def 1;
L560: (( D97 . C97 ) = ( D89 . D101 ) & ( D98 . C97 ) = ( D92 . D101 )) by L542 , L553 , L555 , L556 , FUNCT_1:12;
thus L561: ( D97 . C97 ) = ( D98 . C97 ) by L560 , L527 , L559 , FUNCT_4:11;
end;
L562: D97 = D98 by L554 , FUNCT_1:2;
L563: ( cod D99 ) = ( cod ( @ D95 ) ) by L543 , L109;
L564: D99 = [ [ ( dom ( @ C92 ) ) , ( cod ( @ D95 ) ) ] , D97 ] by L563 , L544 , L73;
L565: ( cod D100 ) = ( cod ( @ D96 ) ) by L546 , L109;
L566: D100 = [ [ ( dom ( @ C92 ) ) , ( cod ( @ D96 ) ) ] , D98 ] by L565 , L547 , L73;
L567: ( cod D93 ) = C93 by L541 , L55;
L568: D99 = D100 by L567 , L545 , L564 , L566 , L562 , L55;
L569: ( cod ( @ D95 ) ) = C93 by L541 , L55;
L570: ( cod D95 ) = C93 by L569 , L222;
L571: ( dom ( @ D95 ) ) = D88 by L541 , L55;
L572: ( dom D95 ) = D88 by L571 , L214;
reconsider D102 = C93 as (Object of ( Ens R1 ));
L573: ( cod C92 ) = C91 by L519 , CAT_1:5;
L574: D95 in ( Hom (C91 , D102) ) by L573 , L536 , L570 , L572;
reconsider D103 = D95 as (Morphism of C91 , D102) by L574 , CAT_1:def 5;
L575: D96 in ( Hom (C91 , D102) ) by L536 , L549 , L551 , L573;
reconsider D104 = D96 as (Morphism of C91 , D102) by L575 , CAT_1:def 5;
L576: ( D103 * C92 ) = ( D103 (*) C92 ) by L519 , L574 , CAT_1:def 13
.= ( D104 (*) C92 ) by L568 , L552 , L572 , L536 , L361
.= ( D104 * C92 ) by L519 , L574 , CAT_1:def 13;
L577: D103 = D104 by L576 , L520 , L574 , CAT_1:def 15;
thus L578: contradiction by L577 , L523 , L540 , L539 , XTUPLE_0:1;
end;
L579: ( rng ( ( @ C92 ) `2 ) ) c= ( cod ( @ C92 ) ) by L87;
thus L580: ( rng ( ( @ C92 ) `2 ) ) = ( cod ( @ C92 ) ) by L579 , L524 , XBOOLE_0:def 10;
end;
theorem
L581: (for R1 being non  empty set holds (for B66 , B67 being (Object of ( Ens R1 )) holds (( Hom (B66 , B67) ) <> ( {} ) implies (for B68 being (Morphism of B66 , B67) holds (( @ B68 ) is  surjective implies B68 is  epi)))))
proof
let R1 being non  empty set;
let C98 , C99 being (Object of ( Ens R1 ));
assume that
L582: ( Hom (C98 , C99) ) <> ( {} );
let C100 being (Morphism of C98 , C99);
set D105 = ( @ C100 );
assume L583: ( rng ( D105 `2 ) ) = ( cod D105 );
thus L584: ( Hom (C98 , C99) ) <> ( {} ) by L582;
let C101 being (Object of ( Ens R1 ));
assume that
L585: ( Hom (C99 , C101) ) <> ( {} );
let C102 , C103 being (Morphism of C99 , C101);
L586: ( dom C102 ) = C99 by L585 , CAT_1:5
.= ( cod C100 ) by L582 , CAT_1:5;
L587: ( dom C103 ) = C99 by L585 , CAT_1:5
.= ( cod C100 ) by L582 , CAT_1:5;
L588: ( cod C102 ) = C101 by L585 , CAT_1:5
.= ( cod C103 ) by L585 , CAT_1:5;
assume L589: ( C102 * C100 ) = ( C103 * C100 );
set D106 = ( @ C102 );
set D107 = ( @ C103 );
L590: ( D106 * D105 ) = ( C102 (*) C100 ) by L586 , L361
.= ( C102 * C100 ) by L582 , L585 , CAT_1:def 13;
L591: ( D107 * D105 ) = ( C103 (*) C100 ) by L587 , L361
.= ( C103 * C100 ) by L582 , L585 , CAT_1:def 13;
L592: D106 = [ [ ( dom D106 ) , ( cod D106 ) ] , ( D106 `2 ) ] by L73;
L593: (( cod D106 ) = ( cod C102 ) & ( cod D107 ) = ( cod C103 )) by L222;
L594: ( dom D107 ) = ( dom C103 ) by L214;
L595: ( dom ( D107 `2 ) ) = ( dom C103 ) by L594 , L87;
L596: ( cod D105 ) = ( cod C100 ) by L222;
L597: ( D107 * D105 ) = [ [ ( dom D105 ) , ( cod D107 ) ] , ( ( D107 `2 ) * ( D105 `2 ) ) ] by L596 , L587 , L594 , L102;
L598: ( dom D106 ) = ( dom C102 ) by L214;
L599: ( D106 * D105 ) = [ [ ( dom D105 ) , ( cod D106 ) ] , ( ( D106 `2 ) * ( D105 `2 ) ) ] by L598 , L586 , L596 , L102;
L600: ( ( D106 `2 ) * ( D105 `2 ) ) = ( ( D107 `2 ) * ( D105 `2 ) ) by L599 , L589 , L590 , L597 , L591 , XTUPLE_0:1;
L601: ( dom ( D106 `2 ) ) = ( dom C102 ) by L598 , L87;
L602: ( D106 `2 ) = ( D107 `2 ) by L601 , L583 , L586 , L587 , L596 , L600 , L595 , FUNCT_1:86;
thus L603: thesis by L602 , L586 , L587 , L588 , L598 , L594 , L593 , L592 , L73;
end;
theorem
L604: (for B69 being Universe holds (for B70 , B71 being (Object of ( Ens B69 )) holds (( Hom (B70 , B71) ) <> ( {} ) implies (for B72 being (Morphism of B70 , B71) holds (B72 is  epi implies ( @ B72 ) is  surjective)))))
proof
let C104 being Universe;
let C105 , C106 being (Object of ( Ens C104 ));
assume that
L605: ( Hom (C105 , C106) ) <> ( {} );
let C107 being (Morphism of C105 , C106);
L606: (( {} ) in C104 & { ( {} ) } in C104) by CLASSES2:56 , CLASSES2:57;
L607: { ( {} ) , { ( {} ) } } in C104 by L606 , CLASSES2:58;
L608: (( {} ) in { ( {} ) , { ( {} ) } } & { ( {} ) } in { ( {} ) , { ( {} ) } }) by TARSKI:def 2;
thus L609: thesis by L608 , L607 , L518 , L605;
end;
L610: (for R1 being non  empty set holds (for B73 being non  empty (Subset of R1) holds ( Ens B73 ) is (Subcategory of ( Ens R1 ))))
proof
let R1 being non  empty set;
let C108 being non  empty (Subset of R1);
L611: (for B74 , B75 being (Object of ( Ens C108 )) holds (for B76 , B77 being (Object of ( Ens R1 )) holds ((B74 = B76 & B75 = B77) implies ( Hom (B74 , B75) ) = ( Hom (B76 , B77) ))))
proof
let C109 , C110 being (Object of ( Ens C108 ));
let C111 , C112 being (Object of ( Ens R1 ));
assume L612: (C109 = C111 & C110 = C112);
L613: (( Hom (C109 , C110) ) = ( Maps (( @ C109 ) , ( @ C110 )) ) & ( Hom (C111 , C112) ) = ( Maps (( @ C111 ) , ( @ C112 )) )) by L339;
thus L614: thesis by L613 , L612 , L193;
end;
set D108 = (the Comp of ( Ens C108 ));
set D109 = (the Comp of ( Ens R1 ));
thus L615: (the carrier of ( Ens C108 )) c= (the carrier of ( Ens R1 ));
thus L616: (for B78 , B79 being (Object of ( Ens C108 )) holds (for B80 , B81 being (Object of ( Ens R1 )) holds ((B78 = B80 & B79 = B81) implies ( Hom (B78 , B79) ) c= ( Hom (B80 , B81) )))) by L611;
L617:
now
L618: ( dom D108 ) c= [: ( Maps C108 ) , ( Maps C108 ) :] by RELAT_1:def 18;
thus L619: ( dom D108 ) c= ( dom D109 )
proof
let C113 , C114 being set;
assume L620: [ C113 , C114 ] in ( dom D108 );
consider C115 , C116 being (Element of ( Maps C108 )) such that L621: [ C113 , C114 ] = [ C115 , C116 ] by L620 , L618 , DOMAIN_1:1;
reconsider D110 = C116 , D111 = C115 as (Element of ( Maps R1 )) by L50 , TARSKI:def 3;
L622: (( dom D111 ) = ( dom C115 ) & ( cod D110 ) = ( cod C116 ));
L623: ( dom C115 ) = ( cod C116 ) by L620 , L621 , L230;
thus L624: thesis by L623 , L621 , L622 , L230;
end;

let C117 being set;
assume L625: C117 in ( dom D108 );
consider C118 , C119 being (Element of ( Maps C108 )) such that L626: C117 = [ C118 , C119 ] by L625 , L618 , DOMAIN_1:1;
reconsider D112 = C119 , D113 = C118 as (Element of ( Maps R1 )) by L50 , TARSKI:def 3;
L627: ( dom D113 ) = ( cod D112 ) by L619 , L625 , L626 , L230;
L628: ( dom C118 ) = ( cod C119 ) by L625 , L626 , L230;
L629: ( C118 * C119 ) = [ [ ( dom C119 ) , ( cod C118 ) ] , ( ( C118 `2 ) * ( C119 `2 ) ) ] by L628 , L102;
L630: (( dom C119 ) = ( dom D112 ) & ( cod C118 ) = ( cod D113 ));
L631: ( D113 * D112 ) = [ [ ( dom C119 ) , ( cod C118 ) ] , ( ( C118 `2 ) * ( C119 `2 ) ) ] by L630 , L627 , L102;
thus L632: ( D108 . C117 ) = ( D113 * D112 ) by L631 , L626 , L628 , L629 , L230
.= ( D109 . C117 ) by L626 , L627 , L230;
end;
thus L633: (the Comp of ( Ens C108 )) c= (the Comp of ( Ens R1 )) by L617 , GRFUNC_1:2;
let C120 being (Object of ( Ens C108 ));
let C121 being (Object of ( Ens R1 ));
L634: ( id$ ( @ C120 ) ) = [ [ ( @ C120 ) , ( @ C120 ) ] , ( id ( @ C120 ) ) ];
assume L635: C120 = C121;
thus L636: ( id C120 ) = ( id$ ( @ C121 ) ) by L635 , L634 , L366
.= ( id C121 ) by L366;
end;
theorem
L637: (for R1 being non  empty set holds (for B82 being non  empty (Subset of R1) holds ( Ens B82 ) is  full  full  full  full (Subcategory of ( Ens R1 ))))
proof
let R1 being non  empty set;
let C122 being non  empty (Subset of R1);
reconsider D114 = ( Ens C122 ) as (Subcategory of ( Ens R1 )) by L610;
L638: (for B83 , B84 being (Object of D114) holds (for B85 , B86 being (Object of ( Ens R1 )) holds ((B83 = B85 & B84 = B86) implies ( Hom (B83 , B84) ) = ( Hom (B85 , B86) ))))
proof
let C123 , C124 being (Object of D114);
let C125 , C126 being (Object of ( Ens R1 ));
assume L639: (C123 = C125 & C124 = C126);
reconsider D115 = C123 , D116 = C124 as (Element of ( Ens C122 ));
L640: (( Hom (D115 , D116) ) = ( Maps (( @ D115 ) , ( @ D116 )) ) & ( Hom (C125 , C126) ) = ( Maps (( @ C125 ) , ( @ C126 )) )) by L339;
thus L641: thesis by L640 , L639 , L193;
end;
thus L642: thesis by L638 , CAT_2:def 6;
end;
begin
definition
let R19 being Category;
func Hom R19 -> set equals 
{ ( Hom (R20 , R21) ) where R20 is (Object of R19) , R21 is (Object of R19) : (not contradiction) };
coherence;
end;
registration
let R19 being Category;
cluster ( Hom R19 ) -> non  empty;
coherence
proof
set D117 = the (Object of R19);
L644: ( Hom (D117 , D117) ) in { ( Hom (R22 , R23) ) where R22 is (Object of R19) , R23 is (Object of R19) : (not contradiction) };
thus L645: thesis by L644;
end;
end;
theorem
L647: (for R19 being Category holds (for R20 being (Object of R19) holds (for R21 being (Object of R19) holds ( Hom (R20 , R21) ) in ( Hom R19 ))));
theorem
L648: (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds ((( Hom (R20 , ( cod R25 )) ) = ( {} ) implies ( Hom (R20 , ( dom R25 )) ) = ( {} )) & (( Hom (( dom R25 ) , R20) ) = ( {} ) implies ( Hom (( cod R25 ) , R20) ) = ( {} ))))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
L649: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
thus L650: thesis by L649 , CAT_1:24;
end;
definition
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
func hom (R20 , R25) -> (Function of ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) )) means 
:L651: (for R26 being (Morphism of R19) holds (R26 in ( Hom (R20 , ( dom R25 )) ) implies ( it . R26 ) = ( R25 (*) R26 )));
existence
proof
defpred S2[ set , set ] means (for R26 being (Morphism of R19) holds (R26 = $1 implies $2 = ( R25 (*) R26 )));
set D118 = ( Hom (R20 , ( dom R25 )) );
set D119 = ( Hom (R20 , ( cod R25 )) );
L652: (for B87 being set holds (B87 in D118 implies (ex B88 being set st (B88 in D119 & S2[ B87 , B88 ]))))
proof
let C127 being set;
assume L653: C127 in D118;
reconsider D120 = C127 as (Morphism of R20 , ( dom R25 )) by L653 , CAT_1:def 5;
take ( R25 (*) D120 );
L654: (( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) & R25 is (Morphism of ( dom R25 ) , ( cod R25 ))) by CAT_1:1 , CAT_1:4;
thus L655: thesis by L654 , L653 , CAT_1:23;
end;
consider C128 being Function such that L656: (( dom C128 ) = D118 & ( rng C128 ) c= D119) and L657: (for B89 being set holds (B89 in D118 implies S2[ B89 , ( C128 . B89 ) ])) from FUNCT_1:sch 5(L652);
L658: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L659: (D119 = ( {} ) implies D118 = ( {} )) by L658 , CAT_1:24;
reconsider D121 = C128 as (Function of D118 , D119) by L659 , L656 , FUNCT_2:def 1 , RELSET_1:4;
take D121;
thus L660: thesis by L657;
end;
uniqueness
proof
set D122 = ( Hom (R20 , ( dom R25 )) );
set D123 = ( Hom (R20 , ( cod R25 )) );
let C129 , C130 being (Function of D122 , D123);
assume that
L661: (for R26 being (Morphism of R19) holds (R26 in D122 implies ( C129 . R26 ) = ( R25 (*) R26 )))
and
L662: (for R26 being (Morphism of R19) holds (R26 in D122 implies ( C130 . R26 ) = ( R25 (*) R26 )));
L663:
now
let C131 being set;
assume L664: C131 in D122;
reconsider D124 = C131 as (Morphism of R19) by L664;
thus L665: ( C129 . C131 ) = ( R25 (*) D124 ) by L661 , L664
.= ( C130 . C131 ) by L662 , L664;
end;
thus L666: thesis by L663 , FUNCT_2:12;
end;
func hom (R25 , R20) -> (Function of ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) )) means 
:L667: (for R26 being (Morphism of R19) holds (R26 in ( Hom (( cod R25 ) , R20) ) implies ( it . R26 ) = ( R26 (*) R25 )));
existence
proof
defpred S3[ set , set ] means (for R26 being (Morphism of R19) holds (R26 = $1 implies $2 = ( R26 (*) R25 )));
set D125 = ( Hom (( cod R25 ) , R20) );
set D126 = ( Hom (( dom R25 ) , R20) );
L668: (for B90 being set holds (B90 in D125 implies (ex B91 being set st (B91 in D126 & S3[ B90 , B91 ]))))
proof
let C132 being set;
assume L669: C132 in D125;
reconsider D127 = C132 as (Morphism of ( cod R25 ) , R20) by L669 , CAT_1:def 5;
take ( D127 (*) R25 );
L670: (( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) & R25 is (Morphism of ( dom R25 ) , ( cod R25 ))) by CAT_1:2 , CAT_1:4;
thus L671: thesis by L670 , L669 , CAT_1:23;
end;
consider C133 being Function such that L672: (( dom C133 ) = D125 & ( rng C133 ) c= D126) and L673: (for B92 being set holds (B92 in D125 implies S3[ B92 , ( C133 . B92 ) ])) from FUNCT_1:sch 5(L668);
L674: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L675: (D126 = ( {} ) implies D125 = ( {} )) by L674 , CAT_1:24;
reconsider D128 = C133 as (Function of D125 , D126) by L675 , L672 , FUNCT_2:def 1 , RELSET_1:4;
take D128;
thus L676: thesis by L673;
end;
uniqueness
proof
set D129 = ( Hom (( cod R25 ) , R20) );
set D130 = ( Hom (( dom R25 ) , R20) );
let C134 , C135 being (Function of D129 , D130);
assume that
L677: (for R26 being (Morphism of R19) holds (R26 in D129 implies ( C134 . R26 ) = ( R26 (*) R25 )))
and
L678: (for R26 being (Morphism of R19) holds (R26 in D129 implies ( C135 . R26 ) = ( R26 (*) R25 )));
L679:
now
let C136 being set;
assume L680: C136 in D129;
reconsider D131 = C136 as (Morphism of R19) by L680;
thus L681: ( C134 . C136 ) = ( D131 (*) R25 ) by L677 , L680
.= ( C135 . C136 ) by L678 , L680;
end;
thus L682: thesis by L679 , FUNCT_2:12;
end;
end;
theorem
L684: (for R19 being Category holds (for R20 being (Object of R19) holds (for R24 being (Object of R19) holds ( hom (R20 , ( id R24 )) ) = ( id ( Hom (R20 , R24) ) ))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R24 being (Object of R19);
set D132 = ( Hom (R20 , R24) );
L685:
now
L686: (D132 = ( {} ) implies D132 = ( {} ));
thus L687: ( dom ( hom (R20 , ( id R24 )) ) ) = D132 by L686 , FUNCT_2:def 1;
let C137 being set;
assume L688: C137 in D132;
reconsider D133 = C137 as (Morphism of R19) by L688;
L689: ( cod D133 ) = R24 by L688 , CAT_1:1;
thus L690: ( ( hom (R20 , ( id R24 )) ) . C137 ) = ( ( id R24 ) (*) D133 ) by L688 , L651
.= C137 by L689 , CAT_1:21;
end;
thus L691: thesis by L685 , FUNCT_1:17;
end;
theorem
L692: (for R19 being Category holds (for R20 being (Object of R19) holds (for R24 being (Object of R19) holds ( hom (( id R24 ) , R20) ) = ( id ( Hom (R24 , R20) ) ))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R24 being (Object of R19);
set D134 = ( Hom (R24 , R20) );
L693:
now
L694: (D134 = ( {} ) implies D134 = ( {} ));
thus L695: ( dom ( hom (( id R24 ) , R20) ) ) = D134 by L694 , FUNCT_2:def 1;
let C138 being set;
assume L696: C138 in D134;
reconsider D135 = C138 as (Morphism of R19) by L696;
L697: ( dom D135 ) = R24 by L696 , CAT_1:1;
thus L698: ( ( hom (( id R24 ) , R20) ) . C138 ) = ( D135 (*) ( id R24 ) ) by L696 , L667
.= C138 by L697 , CAT_1:22;
end;
thus L699: thesis by L693 , FUNCT_1:17;
end;
theorem
L700: (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds (( dom R26 ) = ( cod R25 ) implies ( hom (R20 , ( R26 (*) R25 )) ) = ( ( hom (R20 , R26) ) * ( hom (R20 , R25) ) ))))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
assume L701: ( dom R26 ) = ( cod R25 );
L702: ( dom ( R26 (*) R25 ) ) = ( dom R25 ) by L701 , CAT_1:17;
L703: ( cod ( R26 (*) R25 ) ) = ( cod R26 ) by L701 , CAT_1:17;
L704:
now
set D136 = ( hom (R20 , ( R26 (*) R25 )) );
set D137 = ( hom (R20 , R26) );
set D138 = ( hom (R20 , R25) );
L705: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L706: (( Hom (R20 , ( cod R25 )) ) = ( {} ) implies ( Hom (R20 , ( dom R25 )) ) = ( {} )) by L705 , CAT_1:24;
L707: ( Hom (( dom R26 ) , ( cod R26 )) ) <> ( {} ) by CAT_1:2;
L708: (( Hom (R20 , ( cod R26 )) ) = ( {} ) implies ( Hom (R20 , ( dom R26 )) ) = ( {} )) by L707 , CAT_1:24;
thus L709: ( dom D136 ) = ( Hom (R20 , ( dom R25 )) ) by L708 , L701 , L702 , L703 , L706 , FUNCT_2:def 1;
thus L710: ( dom ( D137 * D138 ) ) = ( Hom (R20 , ( dom R25 )) ) by L701 , L706 , L708 , FUNCT_2:def 1;
let C139 being set;
assume L711: C139 in ( Hom (R20 , ( dom R25 )) );
reconsider D139 = C139 as (Morphism of R19) by L711;
L712: ( cod D139 ) = ( dom R25 ) by L711 , CAT_1:1;
L713: ( D138 . C139 ) in ( Hom (R20 , ( dom R26 )) ) by L701 , L705 , L711 , CAT_1:24 , FUNCT_2:5;
reconsider D140 = ( D138 . C139 ) as (Morphism of R19) by L713;
thus L714: ( D136 . C139 ) = ( ( R26 (*) R25 ) (*) D139 ) by L702 , L711 , L651
.= ( R26 (*) ( R25 (*) D139 ) ) by L701 , L712 , CAT_1:18
.= ( R26 (*) D140 ) by L711 , L651
.= ( D137 . D140 ) by L713 , L651
.= ( ( D137 * D138 ) . C139 ) by L710 , L711 , FUNCT_1:12;
end;
thus L715: thesis by L704 , FUNCT_1:2;
end;
theorem
L716: (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds (( dom R26 ) = ( cod R25 ) implies ( hom (( R26 (*) R25 ) , R20) ) = ( ( hom (R25 , R20) ) * ( hom (R26 , R20) ) ))))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
assume L717: ( dom R26 ) = ( cod R25 );
L718: ( cod ( R26 (*) R25 ) ) = ( cod R26 ) by L717 , CAT_1:17;
L719: ( dom ( R26 (*) R25 ) ) = ( dom R25 ) by L717 , CAT_1:17;
L720:
now
set D141 = ( hom (( R26 (*) R25 ) , R20) );
set D142 = ( hom (R26 , R20) );
set D143 = ( hom (R25 , R20) );
L721: ( Hom (( dom R26 ) , ( cod R26 )) ) <> ( {} ) by CAT_1:2;
L722: (( Hom (( dom R26 ) , R20) ) = ( {} ) implies ( Hom (( cod R26 ) , R20) ) = ( {} )) by L721 , CAT_1:24;
L723: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L724: (( Hom (( dom R25 ) , R20) ) = ( {} ) implies ( Hom (( cod R25 ) , R20) ) = ( {} )) by L723 , CAT_1:24;
thus L725: ( dom D141 ) = ( Hom (( cod R26 ) , R20) ) by L724 , L717 , L719 , L718 , L722 , FUNCT_2:def 1;
thus L726: ( dom ( D143 * D142 ) ) = ( Hom (( cod R26 ) , R20) ) by L717 , L724 , L722 , FUNCT_2:def 1;
let C140 being set;
assume L727: C140 in ( Hom (( cod R26 ) , R20) );
reconsider D144 = C140 as (Morphism of R19) by L727;
L728: ( dom D144 ) = ( cod R26 ) by L727 , CAT_1:1;
L729: ( D142 . C140 ) in ( Hom (( cod R25 ) , R20) ) by L717 , L721 , L727 , CAT_1:24 , FUNCT_2:5;
reconsider D145 = ( D142 . C140 ) as (Morphism of R19) by L729;
thus L730: ( D141 . C140 ) = ( D144 (*) ( R26 (*) R25 ) ) by L718 , L727 , L667
.= ( ( D144 (*) R26 ) (*) R25 ) by L717 , L728 , CAT_1:18
.= ( D145 (*) R25 ) by L727 , L667
.= ( D143 . D145 ) by L729 , L667
.= ( ( D143 * D142 ) . C140 ) by L726 , L727 , FUNCT_1:12;
end;
thus L731: thesis by L720 , FUNCT_1:2;
end;
theorem
L732: (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ] is (Element of ( Maps ( Hom R19 ) )))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
L733: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L734: (( Hom (R20 , ( cod R25 )) ) = ( {} ) implies ( Hom (R20 , ( dom R25 )) ) = ( {} )) by L733 , CAT_1:24;
L735: (( Hom (R20 , ( dom R25 )) ) in ( Hom R19 ) & ( Hom (R20 , ( cod R25 )) ) in ( Hom R19 ));
thus L736: thesis by L735 , L734 , L42;
end;
theorem
L737: (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ] is (Element of ( Maps ( Hom R19 ) )))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
L738: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L739: (( Hom (( dom R25 ) , R20) ) = ( {} ) implies ( Hom (( cod R25 ) , R20) ) = ( {} )) by L738 , CAT_1:24;
L740: (( Hom (( dom R25 ) , R20) ) in ( Hom R19 ) & ( Hom (( cod R25 ) , R20) ) in ( Hom R19 ));
thus L741: thesis by L740 , L739 , L42;
end;
definition
let R19 being Category;
let R20 being (Object of R19);
func hom?- R20 -> (Function of (the carrier' of R19) , ( Maps ( Hom R19 ) )) means 
:L742: (for R25 being (Morphism of R19) holds ( it . R25 ) = [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ]);
existence
proof
defpred S4[ set , set ] means (for R25 being (Morphism of R19) holds (R25 = $1 implies $2 = [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ]));
set D146 = (the carrier' of R19);
set D147 = ( Maps ( Hom R19 ) );
L743: (for B93 being set holds (B93 in D146 implies (ex B94 being set st (B94 in D147 & S4[ B93 , B94 ]))))
proof
let C141 being set;
assume L744: C141 in D146;
reconsider D148 = C141 as (Morphism of R19) by L744;
take D149 = [ [ ( Hom (R20 , ( dom D148 )) ) , ( Hom (R20 , ( cod D148 )) ) ] , ( hom (R20 , D148) ) ];
L745: D149 is (Element of D147) by L732;
thus L746: thesis by L745;
end;
consider C142 being Function such that L747: (( dom C142 ) = D146 & ( rng C142 ) c= D147) and L748: (for B95 being set holds (B95 in D146 implies S4[ B95 , ( C142 . B95 ) ])) from FUNCT_1:sch 5(L743);
reconsider D150 = C142 as (Function of D146 , D147) by L747 , FUNCT_2:def 1 , RELSET_1:4;
take D150;
thus L749: thesis by L748;
end;
uniqueness
proof
let C143 , C144 being (Function of (the carrier' of R19) , ( Maps ( Hom R19 ) ));
assume that
L750: (for R25 being (Morphism of R19) holds ( C143 . R25 ) = [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ])
and
L751: (for R25 being (Morphism of R19) holds ( C144 . R25 ) = [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ]);
L752:
now
let R25 being (Morphism of R19);
thus L753: ( C143 . R25 ) = [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ] by L750
.= ( C144 . R25 ) by L751;
end;
thus L754: thesis by L752 , FUNCT_2:63;
end;
func hom-? R20 -> (Function of (the carrier' of R19) , ( Maps ( Hom R19 ) )) means 
:L755: (for R25 being (Morphism of R19) holds ( it . R25 ) = [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ]);
existence
proof
defpred S5[ set , set ] means (for R25 being (Morphism of R19) holds (R25 = $1 implies $2 = [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ]));
set D151 = (the carrier' of R19);
set D152 = ( Maps ( Hom R19 ) );
L756: (for B96 being set holds (B96 in D151 implies (ex B97 being set st (B97 in D152 & S5[ B96 , B97 ]))))
proof
let C145 being set;
assume L757: C145 in D151;
reconsider D153 = C145 as (Morphism of R19) by L757;
take D154 = [ [ ( Hom (( cod D153 ) , R20) ) , ( Hom (( dom D153 ) , R20) ) ] , ( hom (D153 , R20) ) ];
L758: D154 is (Element of D152) by L737;
thus L759: thesis by L758;
end;
consider C146 being Function such that L760: (( dom C146 ) = D151 & ( rng C146 ) c= D152) and L761: (for B98 being set holds (B98 in D151 implies S5[ B98 , ( C146 . B98 ) ])) from FUNCT_1:sch 5(L756);
reconsider D155 = C146 as (Function of D151 , D152) by L760 , FUNCT_2:def 1 , RELSET_1:4;
take D155;
thus L762: thesis by L761;
end;
uniqueness
proof
let C147 , C148 being (Function of (the carrier' of R19) , ( Maps ( Hom R19 ) ));
assume that
L763: (for R25 being (Morphism of R19) holds ( C147 . R25 ) = [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ])
and
L764: (for R25 being (Morphism of R19) holds ( C148 . R25 ) = [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ]);
L765:
now
let R25 being (Morphism of R19);
thus L766: ( C147 . R25 ) = [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ] by L763
.= ( C148 . R25 ) by L764;
end;
thus L767: thesis by L765 , FUNCT_2:63;
end;
end;
L769: (for R1 being non  empty set holds (for R19 being Category holds (for B99 being (Function of (the carrier' of R19) , ( Maps ( Hom R19 ) )) holds (( Hom R19 ) c= R1 implies B99 is (Function of (the carrier' of R19) , (the carrier' of ( Ens R1 )))))))
proof
let R1 being non  empty set;
let R19 being Category;
let C149 being (Function of (the carrier' of R19) , ( Maps ( Hom R19 ) ));
assume L770: ( Hom R19 ) c= R1;
L771: ( Maps ( Hom R19 ) ) c= ( Maps R1 ) by L770 , L50;
thus L772: thesis by L771 , FUNCT_2:7;
end;
L773: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R24 being (Object of R19) holds (( Hom R19 ) c= R1 implies (for B100 being (Object of ( Ens R1 )) holds (B100 = ( Hom (R20 , R24) ) implies ( ( hom?- R20 ) . ( id R24 ) ) = ( id B100 ))))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R24 being (Object of R19);
L774: ( Hom (R20 , R24) ) in ( Hom R19 );
assume L775: ( Hom R19 ) c= R1;
reconsider D156 = ( Hom (R20 , R24) ) as (Element of R1) by L775 , L774;
L776: ( hom (R20 , ( id R24 )) ) = ( id D156 ) by L684;
let C150 being (Object of ( Ens R1 ));
assume L777: C150 = ( Hom (R20 , R24) );
thus L778: ( ( hom?- R20 ) . ( id R24 ) ) = ( id$ ( @ C150 ) ) by L777 , L776 , L742
.= ( id C150 ) by L366;
end;
L779: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R24 being (Object of R19) holds (( Hom R19 ) c= R1 implies (for B101 being (Object of ( Ens R1 )) holds (B101 = ( Hom (R24 , R20) ) implies ( ( hom-? R20 ) . ( id R24 ) ) = ( id B101 ))))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R24 being (Object of R19);
L780: ( Hom (R24 , R20) ) in ( Hom R19 );
assume L781: ( Hom R19 ) c= R1;
reconsider D157 = ( Hom (R24 , R20) ) as (Element of R1) by L781 , L780;
L782: ( hom (( id R24 ) , R20) ) = ( id D157 ) by L692;
let C151 being (Object of ( Ens R1 ));
assume L783: C151 = ( Hom (R24 , R20) );
thus L784: ( ( hom-? R20 ) . ( id R24 ) ) = ( id$ ( @ C151 ) ) by L783 , L782 , L755
.= ( id C151 ) by L366;
end;
theorem
L785: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( hom?- R20 ) is (Functor of R19 , ( Ens R1 ))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
assume L786: ( Hom R19 ) c= R1;
reconsider D158 = ( hom?- R20 ) as (Function of (the carrier' of R19) , (the carrier' of ( Ens R1 ))) by L786 , L769;
L787:
now
thus L788: (for B102 being (Object of R19) holds (ex B103 being (Object of ( Ens R1 )) st ( D158 . ( id B102 ) ) = ( id B103 )))
proof
let C152 being (Object of R19);
L789: ( Hom (R20 , C152) ) in ( Hom R19 );
reconsider D159 = ( Hom (R20 , C152) ) as (Element of R1) by L789 , L786;
take D160 = ( @ D159 );
thus L790: thesis by L786 , L773;
end;

thus L791: (for B104 being (Morphism of R19) holds (( D158 . ( id ( dom B104 ) ) ) = ( id ( dom ( D158 . B104 ) ) ) & ( D158 . ( id ( cod B104 ) ) ) = ( id ( cod ( D158 . B104 ) ) )))
proof
let C153 being (Morphism of R19);
set D161 = ( dom C153 );
set D162 = ( cod C153 );
set D163 = ( D158 . C153 );
L792: (( Hom (R20 , D161) ) in ( Hom R19 ) & ( Hom (R20 , D162) ) in ( Hom R19 ));
reconsider D164 = ( Hom (R20 , D161) ) , D165 = ( Hom (R20 , D162) ) as (Element of R1) by L792 , L786;
L793: [ [ ( Hom (R20 , D161) ) , ( Hom (R20 , D162) ) ] , ( hom (R20 , C153) ) ] = ( @ D163 ) by L742
.= [ [ ( dom ( @ D163 ) ) , ( cod ( @ D163 ) ) ] , ( ( @ D163 ) `2 ) ] by L73
.= [ [ ( dom D163 ) , ( cod ( @ D163 ) ) ] , ( ( @ D163 ) `2 ) ] by L214
.= [ [ ( dom D163 ) , ( cod D163 ) ] , ( ( @ D163 ) `2 ) ] by L222;
thus L794: ( D158 . ( id D161 ) ) = ( id ( @ D164 ) ) by L786 , L773
.= ( id ( dom ( D158 . C153 ) ) ) by L793 , L55;
thus L795: ( D158 . ( id D162 ) ) = ( id ( @ D165 ) ) by L786 , L773
.= ( id ( cod ( D158 . C153 ) ) ) by L793 , L55;
end;

let C154 , C155 being (Morphism of R19);
assume that
L796: ( dom C155 ) = ( cod C154 );
L797: [ [ ( Hom (R20 , ( dom C155 )) ) , ( Hom (R20 , ( cod C155 )) ) ] , ( hom (R20 , C155) ) ] = ( @ ( D158 . C155 ) ) by L742
.= [ [ ( dom ( @ ( D158 . C155 ) ) ) , ( cod ( @ ( D158 . C155 ) ) ) ] , ( ( @ ( D158 . C155 ) ) `2 ) ] by L73
.= [ [ ( dom ( D158 . C155 ) ) , ( cod ( @ ( D158 . C155 ) ) ) ] , ( ( @ ( D158 . C155 ) ) `2 ) ] by L214
.= [ [ ( dom ( D158 . C155 ) ) , ( cod ( D158 . C155 ) ) ] , ( ( @ ( D158 . C155 ) ) `2 ) ] by L222;
L798: ( ( @ ( D158 . C155 ) ) `2 ) = ( hom (R20 , C155) ) by L797 , XTUPLE_0:1;
L799: ( cod ( D158 . C155 ) ) = ( Hom (R20 , ( cod C155 )) ) by L797 , L55;
L800: ( cod ( @ ( D158 . C155 ) ) ) = ( Hom (R20 , ( cod C155 )) ) by L799 , L222;
L801: ( dom ( D158 . C155 ) ) = ( Hom (R20 , ( dom C155 )) ) by L797 , L55;
L802: ( dom ( @ ( D158 . C155 ) ) ) = ( Hom (R20 , ( dom C155 )) ) by L801 , L214;
L803: [ [ ( Hom (R20 , ( dom C154 )) ) , ( Hom (R20 , ( cod C154 )) ) ] , ( hom (R20 , C154) ) ] = ( @ ( D158 . C154 ) ) by L742
.= [ [ ( dom ( @ ( D158 . C154 ) ) ) , ( cod ( @ ( D158 . C154 ) ) ) ] , ( ( @ ( D158 . C154 ) ) `2 ) ] by L73
.= [ [ ( dom ( D158 . C154 ) ) , ( cod ( @ ( D158 . C154 ) ) ) ] , ( ( @ ( D158 . C154 ) ) `2 ) ] by L214
.= [ [ ( dom ( D158 . C154 ) ) , ( cod ( D158 . C154 ) ) ] , ( ( @ ( D158 . C154 ) ) `2 ) ] by L222;
L804: ( ( @ ( D158 . C154 ) ) `2 ) = ( hom (R20 , C154) ) by L803 , XTUPLE_0:1;
L805: ( dom ( D158 . C154 ) ) = ( Hom (R20 , ( dom C154 )) ) by L803 , L55;
L806: ( dom ( @ ( D158 . C154 ) ) ) = ( Hom (R20 , ( dom C154 )) ) by L805 , L214;
L807: ( cod ( D158 . C154 ) ) = ( Hom (R20 , ( cod C154 )) ) by L803 , L55;
L808: ( cod ( @ ( D158 . C154 ) ) ) = ( Hom (R20 , ( cod C154 )) ) by L807 , L222;
L809: (( dom ( C155 (*) C154 ) ) = ( dom C154 ) & ( cod ( C155 (*) C154 ) ) = ( cod C155 )) by L796 , CAT_1:17;
thus L810: ( D158 . ( C155 (*) C154 ) ) = [ [ ( Hom (R20 , ( dom C154 )) ) , ( Hom (R20 , ( cod C155 )) ) ] , ( hom (R20 , ( C155 (*) C154 )) ) ] by L809 , L742
.= [ [ ( Hom (R20 , ( dom C154 )) ) , ( Hom (R20 , ( cod C155 )) ) ] , ( ( hom (R20 , C155) ) * ( hom (R20 , C154) ) ) ] by L796 , L700
.= ( ( @ ( D158 . C155 ) ) * ( @ ( D158 . C154 ) ) ) by L796 , L804 , L806 , L808 , L798 , L802 , L800 , L102
.= ( ( D158 . C155 ) (*) ( D158 . C154 ) ) by L796 , L807 , L801 , L361;
end;
thus L811: thesis by L787 , CAT_1:61;
end;
theorem
L812: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( hom-? R20 ) is (Contravariant_Functor of R19 , ( Ens R1 ))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
assume L813: ( Hom R19 ) c= R1;
reconsider D166 = ( hom-? R20 ) as (Function of (the carrier' of R19) , (the carrier' of ( Ens R1 ))) by L813 , L769;
L814:
now
thus L815: (for B105 being (Object of R19) holds (ex B106 being (Object of ( Ens R1 )) st ( D166 . ( id B105 ) ) = ( id B106 )))
proof
let C156 being (Object of R19);
L816: ( Hom (C156 , R20) ) in ( Hom R19 );
reconsider D167 = ( Hom (C156 , R20) ) as (Element of R1) by L816 , L813;
take D168 = ( @ D167 );
thus L817: thesis by L813 , L779;
end;

thus L818: (for B107 being (Morphism of R19) holds (( D166 . ( id ( dom B107 ) ) ) = ( id ( cod ( D166 . B107 ) ) ) & ( D166 . ( id ( cod B107 ) ) ) = ( id ( dom ( D166 . B107 ) ) )))
proof
let C157 being (Morphism of R19);
set D169 = ( cod C157 );
set D170 = ( dom C157 );
set D171 = ( D166 . C157 );
L819: (( Hom (D169 , R20) ) in ( Hom R19 ) & ( Hom (D170 , R20) ) in ( Hom R19 ));
reconsider D172 = ( Hom (D169 , R20) ) , D173 = ( Hom (D170 , R20) ) as (Element of R1) by L819 , L813;
L820: [ [ ( Hom (D169 , R20) ) , ( Hom (D170 , R20) ) ] , ( hom (C157 , R20) ) ] = ( @ D171 ) by L755
.= [ [ ( dom ( @ D171 ) ) , ( cod ( @ D171 ) ) ] , ( ( @ D171 ) `2 ) ] by L73
.= [ [ ( dom D171 ) , ( cod ( @ D171 ) ) ] , ( ( @ D171 ) `2 ) ] by L214
.= [ [ ( dom D171 ) , ( cod D171 ) ] , ( ( @ D171 ) `2 ) ] by L222;
thus L821: ( D166 . ( id D170 ) ) = ( id ( @ D173 ) ) by L813 , L779
.= ( id ( cod ( D166 . C157 ) ) ) by L820 , L55;
thus L822: ( D166 . ( id D169 ) ) = ( id ( @ D172 ) ) by L813 , L779
.= ( id ( dom ( D166 . C157 ) ) ) by L820 , L55;
end;

let C158 , C159 being (Morphism of R19);
assume that
L823: ( dom C159 ) = ( cod C158 );
L824: [ [ ( Hom (( cod C159 ) , R20) ) , ( Hom (( dom C159 ) , R20) ) ] , ( hom (C159 , R20) ) ] = ( @ ( D166 . C159 ) ) by L755
.= [ [ ( dom ( @ ( D166 . C159 ) ) ) , ( cod ( @ ( D166 . C159 ) ) ) ] , ( ( @ ( D166 . C159 ) ) `2 ) ] by L73
.= [ [ ( dom ( D166 . C159 ) ) , ( cod ( @ ( D166 . C159 ) ) ) ] , ( ( @ ( D166 . C159 ) ) `2 ) ] by L214
.= [ [ ( dom ( D166 . C159 ) ) , ( cod ( D166 . C159 ) ) ] , ( ( @ ( D166 . C159 ) ) `2 ) ] by L222;
L825: ( ( @ ( D166 . C159 ) ) `2 ) = ( hom (C159 , R20) ) by L824 , XTUPLE_0:1;
L826: ( dom ( D166 . C159 ) ) = ( Hom (( cod C159 ) , R20) ) by L824 , L55;
L827: ( dom ( @ ( D166 . C159 ) ) ) = ( Hom (( cod C159 ) , R20) ) by L826 , L214;
L828: ( cod ( D166 . C159 ) ) = ( Hom (( dom C159 ) , R20) ) by L824 , L55;
L829: ( cod ( @ ( D166 . C159 ) ) ) = ( Hom (( dom C159 ) , R20) ) by L828 , L222;
L830: [ [ ( Hom (( cod C158 ) , R20) ) , ( Hom (( dom C158 ) , R20) ) ] , ( hom (C158 , R20) ) ] = ( @ ( D166 . C158 ) ) by L755
.= [ [ ( dom ( @ ( D166 . C158 ) ) ) , ( cod ( @ ( D166 . C158 ) ) ) ] , ( ( @ ( D166 . C158 ) ) `2 ) ] by L73
.= [ [ ( dom ( D166 . C158 ) ) , ( cod ( @ ( D166 . C158 ) ) ) ] , ( ( @ ( D166 . C158 ) ) `2 ) ] by L214
.= [ [ ( dom ( D166 . C158 ) ) , ( cod ( D166 . C158 ) ) ] , ( ( @ ( D166 . C158 ) ) `2 ) ] by L222;
L831: ( ( @ ( D166 . C158 ) ) `2 ) = ( hom (C158 , R20) ) by L830 , XTUPLE_0:1;
L832: ( cod ( D166 . C158 ) ) = ( Hom (( dom C158 ) , R20) ) by L830 , L55;
L833: ( cod ( @ ( D166 . C158 ) ) ) = ( Hom (( dom C158 ) , R20) ) by L832 , L222;
L834: ( dom ( D166 . C158 ) ) = ( Hom (( cod C158 ) , R20) ) by L830 , L55;
L835: ( dom ( @ ( D166 . C158 ) ) ) = ( Hom (( cod C158 ) , R20) ) by L834 , L214;
L836: (( dom ( C159 (*) C158 ) ) = ( dom C158 ) & ( cod ( C159 (*) C158 ) ) = ( cod C159 )) by L823 , CAT_1:17;
thus L837: ( D166 . ( C159 (*) C158 ) ) = [ [ ( Hom (( cod C159 ) , R20) ) , ( Hom (( dom C158 ) , R20) ) ] , ( hom (( C159 (*) C158 ) , R20) ) ] by L836 , L755
.= [ [ ( Hom (( cod C159 ) , R20) ) , ( Hom (( dom C158 ) , R20) ) ] , ( ( hom (C158 , R20) ) * ( hom (C159 , R20) ) ) ] by L823 , L716
.= ( ( @ ( D166 . C158 ) ) * ( @ ( D166 . C159 ) ) ) by L823 , L831 , L835 , L833 , L825 , L827 , L829 , L102
.= ( ( D166 . C158 ) (*) ( D166 . C159 ) ) by L823 , L834 , L828 , L361;
end;
thus L838: thesis by L814 , OPPCAT_1:def 9;
end;
theorem
L839: (for R19 being Category holds (for R25 being (Morphism of R19) holds (for R28 being (Morphism of R19) holds (( Hom (( dom R25 ) , ( cod R28 )) ) = ( {} ) implies ( Hom (( cod R25 ) , ( dom R28 )) ) = ( {} )))))
proof
let R19 being Category;
let R25 being (Morphism of R19);
let R28 being (Morphism of R19);
assume that
L840: ( Hom (( dom R25 ) , ( cod R28 )) ) = ( {} )
and
L841: ( Hom (( cod R25 ) , ( dom R28 )) ) <> ( {} );
L842: ( Hom (( dom R28 ) , ( cod R28 )) ) <> ( {} ) by CAT_1:2;
L843: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L844: ( Hom (( dom R25 ) , ( dom R28 )) ) <> ( {} ) by L843 , L841 , CAT_1:24;
thus L845: contradiction by L844 , L840 , L842 , CAT_1:24;
end;
definition
let R19 being Category;
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
func hom (R25 , R26) -> (Function of ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) )) means 
:L846: (for R27 being (Morphism of R19) holds (R27 in ( Hom (( cod R25 ) , ( dom R26 )) ) implies ( it . R27 ) = ( ( R26 (*) R27 ) (*) R25 )));
existence
proof
defpred S6[ set , set ] means (for R27 being (Morphism of R19) holds (R27 = $1 implies $2 = ( ( R26 (*) R27 ) (*) R25 )));
set D174 = ( Hom (( cod R25 ) , ( dom R26 )) );
set D175 = ( Hom (( dom R25 ) , ( cod R26 )) );
L847: (for B108 being set holds (B108 in D174 implies (ex B109 being set st (B109 in D175 & S6[ B108 , B109 ]))))
proof
let C160 being set;
L848: (( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) & R25 is (Morphism of ( dom R25 ) , ( cod R25 ))) by CAT_1:2 , CAT_1:4;
assume L849: C160 in D174;
reconsider D176 = C160 as (Morphism of ( cod R25 ) , ( dom R26 )) by L849 , CAT_1:def 5;
take ( ( R26 (*) D176 ) (*) R25 );
L850: (( Hom (( dom R26 ) , ( cod R26 )) ) <> ( {} ) & R26 is (Morphism of ( dom R26 ) , ( cod R26 ))) by CAT_1:2 , CAT_1:4;
L851: ( R26 (*) D176 ) in ( Hom (( cod R25 ) , ( cod R26 )) ) by L850 , L849 , CAT_1:23;
L852: ( R26 (*) D176 ) is (Morphism of ( cod R25 ) , ( cod R26 )) by L851 , CAT_1:def 5;
thus L853: thesis by L852 , L851 , L848 , CAT_1:23;
end;
consider C161 being Function such that L854: (( dom C161 ) = D174 & ( rng C161 ) c= D175) and L855: (for B110 being set holds (B110 in D174 implies S6[ B110 , ( C161 . B110 ) ])) from FUNCT_1:sch 5(L847);
L856: (D175 = ( {} ) implies D174 = ( {} )) by L839;
reconsider D177 = C161 as (Function of D174 , D175) by L856 , L854 , FUNCT_2:def 1 , RELSET_1:4;
take D177;
thus L857: thesis by L855;
end;
uniqueness
proof
set D178 = ( Hom (( cod R25 ) , ( dom R26 )) );
set D179 = ( Hom (( dom R25 ) , ( cod R26 )) );
let C162 , C163 being (Function of D178 , D179);
assume that
L858: (for R27 being (Morphism of R19) holds (R27 in D178 implies ( C162 . R27 ) = ( ( R26 (*) R27 ) (*) R25 )))
and
L859: (for R27 being (Morphism of R19) holds (R27 in D178 implies ( C163 . R27 ) = ( ( R26 (*) R27 ) (*) R25 )));
L860:
now
let C164 being set;
assume L861: C164 in D178;
reconsider D180 = C164 as (Morphism of R19) by L861;
thus L862: ( C162 . C164 ) = ( ( R26 (*) D180 ) (*) R25 ) by L858 , L861
.= ( C163 . C164 ) by L859 , L861;
end;
thus L863: thesis by L860 , FUNCT_2:12;
end;
end;
theorem
L865: (for R19 being Category holds (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ] is (Element of ( Maps ( Hom R19 ) )))))
proof
let R19 being Category;
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
L866: (( Hom (( dom R25 ) , ( cod R26 )) ) in ( Hom R19 ) & ( Hom (( cod R25 ) , ( dom R26 )) ) in ( Hom R19 ));
L867: (( Hom (( dom R25 ) , ( cod R26 )) ) = ( {} ) implies ( Hom (( cod R25 ) , ( dom R26 )) ) = ( {} )) by L839;
thus L868: thesis by L867 , L866 , L42;
end;
theorem
L869: (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds (( hom (( id R20 ) , R25) ) = ( hom (R20 , R25) ) & ( hom (R25 , ( id R20 )) ) = ( hom (R25 , R20) )))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
L870: ( cod ( id R20 ) ) = R20;
L871:
now
L872: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L873: (( Hom (R20 , ( cod R25 )) ) = ( {} ) implies ( Hom (R20 , ( dom R25 )) ) = ( {} )) by L872 , CAT_1:24;
thus L874: (( dom ( hom (( id R20 ) , R25) ) ) = ( Hom (R20 , ( dom R25 )) ) & ( dom ( hom (R20 , R25) ) ) = ( Hom (R20 , ( dom R25 )) )) by L873 , FUNCT_2:def 1;
let C165 being set;
assume L875: C165 in ( Hom (R20 , ( dom R25 )) );
reconsider D181 = C165 as (Morphism of R19) by L875;
L876: ( dom D181 ) = R20 by L875 , CAT_1:1;
L877: ( cod D181 ) = ( dom R25 ) by L875 , CAT_1:1;
thus L878: ( ( hom (( id R20 ) , R25) ) . C165 ) = ( ( R25 (*) D181 ) (*) ( id R20 ) ) by L875 , L846
.= ( R25 (*) ( D181 (*) ( id R20 ) ) ) by L870 , L876 , L877 , CAT_1:18
.= ( R25 (*) D181 ) by L876 , CAT_1:22
.= ( ( hom (R20 , R25) ) . C165 ) by L875 , L651;
end;
thus L879: ( hom (( id R20 ) , R25) ) = ( hom (R20 , R25) ) by L871 , FUNCT_1:2;
L880:
now
L881: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L882: (( Hom (( dom R25 ) , R20) ) = ( {} ) implies ( Hom (( cod R25 ) , R20) ) = ( {} )) by L881 , CAT_1:24;
thus L883: (( dom ( hom (R25 , ( id R20 )) ) ) = ( Hom (( cod R25 ) , R20) ) & ( dom ( hom (R25 , R20) ) ) = ( Hom (( cod R25 ) , R20) )) by L882 , FUNCT_2:def 1;
let C166 being set;
assume L884: C166 in ( Hom (( cod R25 ) , R20) );
reconsider D182 = C166 as (Morphism of R19) by L884;
L885: ( cod D182 ) = R20 by L884 , CAT_1:1;
thus L886: ( ( hom (R25 , ( id R20 )) ) . C166 ) = ( ( ( id R20 ) (*) D182 ) (*) R25 ) by L884 , L846
.= ( D182 (*) R25 ) by L885 , CAT_1:21
.= ( ( hom (R25 , R20) ) . C166 ) by L884 , L667;
end;
thus L887: thesis by L880 , FUNCT_1:2;
end;
theorem
L888: (for R19 being Category holds (for R20 being (Object of R19) holds (for R21 being (Object of R19) holds ( hom (( id R20 ) , ( id R21 )) ) = ( id ( Hom (R20 , R21) ) ))))
proof
let R19 being Category;
let R20 being (Object of R19);
let R21 being (Object of R19);
thus L889: ( hom (( id R20 ) , ( id R21 )) ) = ( hom (R20 , ( id R21 )) ) by L869
.= ( id ( Hom (R20 , R21) ) ) by L684;
end;
theorem
L890: (for R19 being Category holds (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds ( hom (R25 , R26) ) = ( ( hom (( dom R25 ) , R26) ) * ( hom (R25 , ( dom R26 )) ) ))))
proof
let R19 being Category;
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
L891:
now
L892: (( Hom (( dom R25 ) , ( cod R26 )) ) = ( {} ) implies ( Hom (( cod R25 ) , ( dom R26 )) ) = ( {} )) by L839;
thus L893: ( dom ( hom (R25 , R26) ) ) = ( Hom (( cod R25 ) , ( dom R26 )) ) by L892 , FUNCT_2:def 1;
L894: ( Hom (( dom R25 ) , ( cod R25 )) ) <> ( {} ) by CAT_1:2;
L895: (( Hom (( dom R25 ) , ( dom R26 )) ) = ( {} ) implies ( Hom (( cod R25 ) , ( dom R26 )) ) = ( {} )) by L894 , CAT_1:24;
thus L896: ( dom ( ( hom (( dom R25 ) , R26) ) * ( hom (R25 , ( dom R26 )) ) ) ) = ( Hom (( cod R25 ) , ( dom R26 )) ) by L895 , L892 , FUNCT_2:def 1;
let C167 being set;
assume L897: C167 in ( Hom (( cod R25 ) , ( dom R26 )) );
reconsider D183 = C167 as (Morphism of R19) by L897;
L898: ( dom D183 ) = ( cod R25 ) by L897 , CAT_1:1;
L899: ( dom ( D183 (*) R25 ) ) = ( dom R25 ) by L898 , CAT_1:17;
L900: ( cod D183 ) = ( dom R26 ) by L897 , CAT_1:1;
L901: ( cod ( D183 (*) R25 ) ) = ( dom R26 ) by L900 , L898 , CAT_1:17;
L902: ( D183 (*) R25 ) in ( Hom (( dom R25 ) , ( dom R26 )) ) by L901 , L899;
thus L903: ( ( hom (R25 , R26) ) . C167 ) = ( ( R26 (*) D183 ) (*) R25 ) by L897 , L846
.= ( R26 (*) ( D183 (*) R25 ) ) by L898 , L900 , CAT_1:18
.= ( ( hom (( dom R25 ) , R26) ) . ( D183 (*) R25 ) ) by L902 , L651
.= ( ( hom (( dom R25 ) , R26) ) . ( ( hom (R25 , ( dom R26 )) ) . D183 ) ) by L897 , L667
.= ( ( ( hom (( dom R25 ) , R26) ) * ( hom (R25 , ( dom R26 )) ) ) . C167 ) by L896 , L897 , FUNCT_1:12;
end;
thus L904: thesis by L891 , FUNCT_1:2;
end;
theorem
L905: (for R19 being Category holds (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds (for R28 being (Morphism of R19) holds (for R29 being (Morphism of R19) holds ((( cod R26 ) = ( dom R25 ) & ( dom R29 ) = ( cod R28 )) implies ( hom (( R25 (*) R26 ) , ( R29 (*) R28 )) ) = ( ( hom (R26 , R29) ) * ( hom (R25 , R28) ) )))))))
proof
let R19 being Category;
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
let R28 being (Morphism of R19);
let R29 being (Morphism of R19);
assume that
L906: ( cod R26 ) = ( dom R25 )
and
L907: ( dom R29 ) = ( cod R28 );
L908: ( dom ( R29 (*) R28 ) ) = ( dom R28 ) by L907 , CAT_1:17;
L909: ( cod ( R25 (*) R26 ) ) = ( cod R25 ) by L906 , CAT_1:17;
L910: (( cod ( R29 (*) R28 ) ) = ( cod R29 ) & ( dom ( R25 (*) R26 ) ) = ( dom R26 )) by L906 , L907 , CAT_1:17;
L911:
now
set D184 = ( hom (( R25 (*) R26 ) , ( R29 (*) R28 )) );
set D185 = ( hom (R26 , R29) );
set D186 = ( hom (R25 , R28) );
L912: (( Hom (( dom R25 ) , ( cod R28 )) ) = ( {} ) implies ( Hom (( cod R25 ) , ( dom R28 )) ) = ( {} )) by L839;
L913: (( Hom (( dom R26 ) , ( cod R29 )) ) = ( {} ) implies ( Hom (( cod R26 ) , ( dom R29 )) ) = ( {} )) by L839;
thus L914: ( dom D184 ) = ( Hom (( cod R25 ) , ( dom R28 )) ) by L913 , L906 , L907 , L908 , L910 , L909 , L912 , FUNCT_2:def 1;
thus L915: ( dom ( D185 * D186 ) ) = ( Hom (( cod R25 ) , ( dom R28 )) ) by L906 , L907 , L913 , L912 , FUNCT_2:def 1;
let C168 being set;
assume L916: C168 in ( Hom (( cod R25 ) , ( dom R28 )) );
reconsider D187 = C168 as (Morphism of R19) by L916;
L917: ( D186 . C168 ) in ( Hom (( cod R26 ) , ( dom R29 )) ) by L906 , L907 , L916 , L839 , FUNCT_2:5;
reconsider D188 = ( D186 . C168 ) as (Morphism of R19) by L917;
L918: ( dom D187 ) = ( cod R25 ) by L916 , CAT_1:1;
L919: ( cod ( D187 (*) ( R25 (*) R26 ) ) ) = ( cod D187 ) by L918 , L909 , CAT_1:17;
L920: ( cod D187 ) = ( dom R28 ) by L916 , CAT_1:1;
L921: ( dom ( R28 (*) D187 ) ) = ( dom D187 ) by L920 , CAT_1:17;
L922: ( dom ( ( R28 (*) D187 ) (*) R25 ) ) = ( dom R25 ) by L921 , L918 , CAT_1:17;
L923: ( cod ( R28 (*) D187 ) ) = ( cod R28 ) by L920 , CAT_1:17;
L924: ( cod ( ( R28 (*) D187 ) (*) R25 ) ) = ( cod R28 ) by L923 , L918 , L921 , CAT_1:17;
thus L925: ( D184 . C168 ) = ( ( ( R29 (*) R28 ) (*) D187 ) (*) ( R25 (*) R26 ) ) by L908 , L909 , L916 , L846
.= ( ( R29 (*) R28 ) (*) ( D187 (*) ( R25 (*) R26 ) ) ) by L908 , L909 , L920 , L918 , CAT_1:18
.= ( R29 (*) ( R28 (*) ( D187 (*) ( R25 (*) R26 ) ) ) ) by L907 , L920 , L919 , CAT_1:18
.= ( R29 (*) ( ( R28 (*) D187 ) (*) ( R25 (*) R26 ) ) ) by L909 , L920 , L918 , CAT_1:18
.= ( R29 (*) ( ( ( R28 (*) D187 ) (*) R25 ) (*) R26 ) ) by L906 , L918 , L921 , CAT_1:18
.= ( ( R29 (*) ( ( R28 (*) D187 ) (*) R25 ) ) (*) R26 ) by L906 , L907 , L922 , L924 , CAT_1:18
.= ( ( R29 (*) D188 ) (*) R26 ) by L916 , L846
.= ( D185 . D188 ) by L917 , L846
.= ( ( D185 * D186 ) . C168 ) by L915 , L916 , FUNCT_1:12;
end;
thus L926: thesis by L911 , FUNCT_1:2;
end;
definition
let R19 being Category;
func hom?? R19 -> (Function of (the carrier' of [: R19 , R19 :]) , ( Maps ( Hom R19 ) )) means 
:L927: (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds ( it . [ R25 , R26 ] ) = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ]));
existence
proof
defpred S7[ set , set ] means (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds ($1 = [ R25 , R26 ] implies $2 = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ])));
set D189 = (the carrier' of [: R19 , R19 :]);
set D190 = ( Maps ( Hom R19 ) );
L928: (for B111 being set holds (B111 in D189 implies (ex B112 being set st (B112 in D190 & S7[ B111 , B112 ]))))
proof
let C169 being set;
assume L929: C169 in D189;
consider R25 being (Morphism of R19), R26 being (Morphism of R19) such that L930: C169 = [ R25 , R26 ] by L929 , DOMAIN_1:1;
take D191 = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ];
L931: D191 is (Element of D190) by L865;
thus L932: D191 in D190 by L931;
let R28 being (Morphism of R19);
let R29 being (Morphism of R19);
assume L933: C169 = [ R28 , R29 ];
L934: (R28 = R25 & R29 = R26) by L933 , L930 , XTUPLE_0:1;
thus L935: thesis by L934;
end;
consider C170 being Function such that L936: (( dom C170 ) = D189 & ( rng C170 ) c= D190) and L937: (for B113 being set holds (B113 in D189 implies S7[ B113 , ( C170 . B113 ) ])) from FUNCT_1:sch 5(L928);
reconsider D192 = C170 as (Function of D189 , D190) by L936 , FUNCT_2:def 1 , RELSET_1:4;
take D192;
thus L938: thesis by L937;
end;
uniqueness
proof
let C171 , C172 being (Function of (the carrier' of [: R19 , R19 :]) , ( Maps ( Hom R19 ) ));
assume that
L939: (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds ( C171 . [ R25 , R26 ] ) = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ]))
and
L940: (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds ( C172 . [ R25 , R26 ] ) = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ]));
L941:
now
thus L942: (the carrier' of [: R19 , R19 :]) = [: (the carrier' of R19) , (the carrier' of R19) :];
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
thus L943: ( C171 . (R25 , R26) ) = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ] by L939
.= ( C172 . (R25 , R26) ) by L940;
end;
thus L944: thesis by L941 , BINOP_1:2;
end;
end;
theorem
L946: (for R19 being Category holds (for R20 being (Object of R19) holds (( hom?- R20 ) = ( ( curry ( hom?? R19 ) ) . ( id R20 ) ) & ( hom-? R20 ) = ( ( curry' ( hom?? R19 ) ) . ( id R20 ) ))))
proof
let R19 being Category;
let R20 being (Object of R19);
reconsider D193 = ( hom?? R19 ) as (Function of [: (the carrier' of R19) , (the carrier' of R19) :] , ( Maps ( Hom R19 ) ));
L947:
now
let R25 being (Morphism of R19);
thus L948: ( ( ( curry D193 ) . ( id R20 ) ) . R25 ) = ( D193 . (( id R20 ) , R25) ) by FUNCT_5:69
.= [ [ ( Hom (( cod ( id R20 ) ) , ( dom R25 )) ) , ( Hom (( dom ( id R20 ) ) , ( cod R25 )) ) ] , ( hom (( id R20 ) , R25) ) ] by L927
.= [ [ ( Hom (( cod ( id R20 ) ) , ( dom R25 )) ) , ( Hom (( dom ( id R20 ) ) , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ] by L869
.= [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (( dom ( id R20 ) ) , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ]
.= [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ]
.= ( ( hom?- R20 ) . R25 ) by L742;
end;
thus L949: ( hom?- R20 ) = ( ( curry ( hom?? R19 ) ) . ( id R20 ) ) by L947 , FUNCT_2:63;
L950:
now
let R25 being (Morphism of R19);
thus L951: ( ( ( curry' D193 ) . ( id R20 ) ) . R25 ) = ( D193 . (R25 , ( id R20 )) ) by FUNCT_5:70
.= [ [ ( Hom (( cod R25 ) , ( dom ( id R20 ) )) ) , ( Hom (( dom R25 ) , ( cod ( id R20 ) )) ) ] , ( hom (R25 , ( id R20 )) ) ] by L927
.= [ [ ( Hom (( cod R25 ) , ( dom ( id R20 ) )) ) , ( Hom (( dom R25 ) , ( cod ( id R20 ) )) ) ] , ( hom (R25 , R20) ) ] by L869
.= [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , ( cod ( id R20 ) )) ) ] , ( hom (R25 , R20) ) ]
.= [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ]
.= ( ( hom-? R20 ) . R25 ) by L755;
end;
thus L952: thesis by L950 , FUNCT_2:63;
end;
L953: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R21 being (Object of R19) holds (( Hom R19 ) c= R1 implies (for B114 being (Object of ( Ens R1 )) holds (B114 = ( Hom (R20 , R21) ) implies ( ( hom?? R19 ) . [ ( id R20 ) , ( id R21 ) ] ) = ( id B114 ))))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R21 being (Object of R19);
L954: ( Hom (R20 , R21) ) in ( Hom R19 );
assume L955: ( Hom R19 ) c= R1;
reconsider D194 = ( Hom (R20 , R21) ) as (Element of R1) by L955 , L954;
L956: ( hom (( id R20 ) , ( id R21 )) ) = ( id D194 ) by L888;
let C173 being (Object of ( Ens R1 ));
assume L957: C173 = ( Hom (R20 , R21) );
thus L958: ( ( hom?? R19 ) . [ ( id R20 ) , ( id R21 ) ] ) = ( id$ ( @ C173 ) ) by L957 , L956 , L927
.= ( id C173 ) by L366;
end;
theorem
L959: (for R1 being non  empty set holds (for R19 being Category holds (( Hom R19 ) c= R1 implies ( hom?? R19 ) is (Functor of [: ( R19 opp ) , R19 :] , ( Ens R1 )))))
proof
let R1 being non  empty set;
let R19 being Category;
assume L960: ( Hom R19 ) c= R1;
L961: (( R19 opp ) = CatStr (# (the carrier of R19) , (the carrier' of R19) , (the Target of R19) , (the Source of R19) , ( ~ (the Comp of R19) ) #) & ( Maps ( Hom R19 ) ) c= ( Maps R1 )) by L960 , L50;
reconsider D195 = ( hom?? R19 ) as (Function of (the carrier' of [: ( R19 opp ) , R19 :]) , (the carrier' of ( Ens R1 ))) by L961 , FUNCT_2:7;
L962:
now
thus L963: (for B115 being (Object of [: ( R19 opp ) , R19 :]) holds (ex B116 being (Object of ( Ens R1 )) st ( D195 . ( id B115 ) ) = ( id B116 )))
proof
let C174 being (Object of [: ( R19 opp ) , R19 :]);
consider C175 being (Object of ( R19 opp )), R21 being (Object of R19) such that L964: C174 = [ C175 , R21 ] by DOMAIN_1:1;
L965: ( Hom (( opp C175 ) , R21) ) in ( Hom R19 );
reconsider D196 = ( Hom (( opp C175 ) , R21) ) as (Element of R1) by L965 , L960;
take D197 = ( @ D196 );
L966: ( id ( opp C175 ) ) = ( id C175 ) by OPPCAT_1:72;
L967: ( id C174 ) = [ ( id ( opp C175 ) ) , ( id R21 ) ] by L966 , L964 , CAT_2:31;
thus L968: thesis by L967 , L960 , L953;
end;

thus L969: (for B117 being (Morphism of [: ( R19 opp ) , R19 :]) holds (( D195 . ( id ( dom B117 ) ) ) = ( id ( dom ( D195 . B117 ) ) ) & ( D195 . ( id ( cod B117 ) ) ) = ( id ( cod ( D195 . B117 ) ) )))
proof
let C176 being (Morphism of [: ( R19 opp ) , R19 :]);
consider C177 being (Morphism of ( R19 opp )), R26 being (Morphism of R19) such that L970: C176 = [ C177 , R26 ] by DOMAIN_1:1;
L971: (( Hom (( cod ( opp C177 ) ) , ( dom R26 )) ) in ( Hom R19 ) & ( Hom (( dom ( opp C177 ) ) , ( cod R26 )) ) in ( Hom R19 ));
reconsider D198 = ( Hom (( cod ( opp C177 ) ) , ( dom R26 )) ) , D199 = ( Hom (( dom ( opp C177 ) ) , ( cod R26 )) ) as (Element of R1) by L971 , L960;
set D200 = ( D195 . C176 );
L972: ( id ( opp ( dom C177 ) ) ) = ( id ( dom C177 ) ) by OPPCAT_1:72;
L973: ( id ( opp ( cod C177 ) ) ) = ( id ( cod C177 ) ) by OPPCAT_1:72;
L974: [ [ ( Hom (( cod ( opp C177 ) ) , ( dom R26 )) ) , ( Hom (( dom ( opp C177 ) ) , ( cod R26 )) ) ] , ( hom (( opp C177 ) , R26) ) ] = ( @ D200 ) by L970 , L927
.= [ [ ( dom ( @ D200 ) ) , ( cod ( @ D200 ) ) ] , ( ( @ D200 ) `2 ) ] by L73
.= [ [ ( dom D200 ) , ( cod ( @ D200 ) ) ] , ( ( @ D200 ) `2 ) ] by L214
.= [ [ ( dom D200 ) , ( cod D200 ) ] , ( ( @ D200 ) `2 ) ] by L222;
thus L975: ( D195 . ( id ( dom C176 ) ) ) = ( D195 . ( id [ ( dom C177 ) , ( dom R26 ) ] ) ) by L970 , CAT_2:28
.= ( D195 . [ ( id ( dom C177 ) ) , ( id ( dom R26 ) ) ] ) by CAT_2:31
.= ( id ( @ D198 ) ) by L960 , L953 , L972
.= ( id ( dom ( D195 . C176 ) ) ) by L974 , L55;
thus L976: ( D195 . ( id ( cod C176 ) ) ) = ( D195 . ( id [ ( cod C177 ) , ( cod R26 ) ] ) ) by L970 , CAT_2:28
.= ( D195 . [ ( id ( cod C177 ) ) , ( id ( cod R26 ) ) ] ) by CAT_2:31
.= ( id ( @ D199 ) ) by L960 , L953 , L973
.= ( id ( cod ( D195 . C176 ) ) ) by L974 , L55;
end;

let C178 , C179 being (Morphism of [: ( R19 opp ) , R19 :]);
assume that
L977: ( dom C179 ) = ( cod C178 );
consider C180 being (Morphism of ( R19 opp )), R29 being (Morphism of R19) such that L978: C179 = [ C180 , R29 ] by DOMAIN_1:1;
L979: [ [ ( Hom (( cod ( opp C180 ) ) , ( dom R29 )) ) , ( Hom (( dom ( opp C180 ) ) , ( cod R29 )) ) ] , ( hom (( opp C180 ) , R29) ) ] = ( @ ( D195 . C179 ) ) by L978 , L927
.= [ [ ( dom ( @ ( D195 . C179 ) ) ) , ( cod ( @ ( D195 . C179 ) ) ) ] , ( ( @ ( D195 . C179 ) ) `2 ) ] by L73
.= [ [ ( dom ( D195 . C179 ) ) , ( cod ( @ ( D195 . C179 ) ) ) ] , ( ( @ ( D195 . C179 ) ) `2 ) ] by L214
.= [ [ ( dom ( D195 . C179 ) ) , ( cod ( D195 . C179 ) ) ] , ( ( @ ( D195 . C179 ) ) `2 ) ] by L222;
L980: ( ( @ ( D195 . C179 ) ) `2 ) = ( hom (( opp C180 ) , R29) ) by L979 , XTUPLE_0:1;
L981: ( cod ( D195 . C179 ) ) = ( Hom (( dom ( opp C180 ) ) , ( cod R29 )) ) by L979 , L55;
L982: ( cod ( @ ( D195 . C179 ) ) ) = ( Hom (( dom ( opp C180 ) ) , ( cod R29 )) ) by L981 , L222;
L983: ( dom ( D195 . C179 ) ) = ( Hom (( cod ( opp C180 ) ) , ( dom R29 )) ) by L979 , L55;
L984: ( dom ( @ ( D195 . C179 ) ) ) = ( Hom (( cod ( opp C180 ) ) , ( dom R29 )) ) by L983 , L214;
consider C181 being (Morphism of ( R19 opp )), R28 being (Morphism of R19) such that L985: C178 = [ C181 , R28 ] by DOMAIN_1:1;
L986: [ [ ( Hom (( cod ( opp C181 ) ) , ( dom R28 )) ) , ( Hom (( dom ( opp C181 ) ) , ( cod R28 )) ) ] , ( hom (( opp C181 ) , R28) ) ] = ( @ ( D195 . C178 ) ) by L985 , L927
.= [ [ ( dom ( @ ( D195 . C178 ) ) ) , ( cod ( @ ( D195 . C178 ) ) ) ] , ( ( @ ( D195 . C178 ) ) `2 ) ] by L73
.= [ [ ( dom ( D195 . C178 ) ) , ( cod ( @ ( D195 . C178 ) ) ) ] , ( ( @ ( D195 . C178 ) ) `2 ) ] by L214
.= [ [ ( dom ( D195 . C178 ) ) , ( cod ( D195 . C178 ) ) ] , ( ( @ ( D195 . C178 ) ) `2 ) ] by L222;
L987: ( ( @ ( D195 . C178 ) ) `2 ) = ( hom (( opp C181 ) , R28) ) by L986 , XTUPLE_0:1;
L988: ( dom ( D195 . C178 ) ) = ( Hom (( cod ( opp C181 ) ) , ( dom R28 )) ) by L986 , L55;
L989: ( dom ( @ ( D195 . C178 ) ) ) = ( Hom (( cod ( opp C181 ) ) , ( dom R28 )) ) by L988 , L214;
L990: ( cod ( D195 . C178 ) ) = ( Hom (( dom ( opp C181 ) ) , ( cod R28 )) ) by L986 , L55;
L991: ( cod ( @ ( D195 . C178 ) ) ) = ( Hom (( dom ( opp C181 ) ) , ( cod R28 )) ) by L990 , L222;
L992: ( cod C178 ) = [ ( cod C181 ) , ( cod R28 ) ] by L985 , CAT_2:28;
L993: ( dom C179 ) = [ ( dom C180 ) , ( dom R29 ) ] by L978 , CAT_2:28;
L994: ( cod ( opp C180 ) ) = ( dom ( opp C181 ) ) by L993 , L977 , L992 , XTUPLE_0:1;
L995: (( dom ( ( opp C181 ) (*) ( opp C180 ) ) ) = ( dom ( opp C180 ) ) & ( cod ( ( opp C181 ) (*) ( opp C180 ) ) ) = ( cod ( opp C181 ) )) by L994 , CAT_1:17;
L996: ( dom C180 ) = ( cod C181 ) by L977 , L993 , L992 , XTUPLE_0:1;
L997: ( dom R29 ) = ( cod R28 ) by L977 , L993 , L992 , XTUPLE_0:1;
L998: (( dom ( R29 (*) R28 ) ) = ( dom R28 ) & ( cod ( R29 (*) R28 ) ) = ( cod R29 )) by L997 , CAT_1:17;
thus L999: ( D195 . ( C179 (*) C178 ) ) = ( D195 . [ ( opp ( C180 (*) C181 ) ) , ( R29 (*) R28 ) ] ) by L977 , L985 , L978 , CAT_2:30
.= ( D195 . [ ( ( opp C181 ) (*) ( opp C180 ) ) , ( R29 (*) R28 ) ] ) by L996 , OPPCAT_1:18
.= [ [ ( Hom (( cod ( ( opp C181 ) (*) ( opp C180 ) ) ) , ( dom ( R29 (*) R28 ) )) ) , ( Hom (( dom ( ( opp C181 ) (*) ( opp C180 ) ) ) , ( cod ( R29 (*) R28 ) )) ) ] , ( hom (( ( opp C181 ) (*) ( opp C180 ) ) , ( R29 (*) R28 )) ) ] by L927
.= [ [ ( Hom (( cod ( opp C181 ) ) , ( dom R28 )) ) , ( Hom (( dom ( opp C180 ) ) , ( cod R29 )) ) ] , ( ( hom (( opp C180 ) , R29) ) * ( hom (( opp C181 ) , R28) ) ) ] by L994 , L997 , L998 , L995 , L905
.= ( ( @ ( D195 . C179 ) ) * ( @ ( D195 . C178 ) ) ) by L987 , L989 , L991 , L980 , L984 , L982 , L994 , L997 , L102
.= ( ( D195 . C179 ) (*) ( D195 . C178 ) ) by L990 , L983 , L994 , L997 , L361;
end;
thus L1000: thesis by L962 , CAT_1:61;
end;
definition
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
assume L1001: ( Hom R19 ) c= R1;
func hom?- (R1 , R20) -> (Functor of R19 , ( Ens R1 )) equals 
:L1002: ( hom?- R20 );
coherence by L1001 , L785;
func hom-? (R1 , R20) -> (Contravariant_Functor of R19 , ( Ens R1 )) equals 
:L1003: ( hom-? R20 );
coherence by L1001 , L812;
end;
definition
let R1 being non  empty set;
let R19 being Category;
assume L1005: ( Hom R19 ) c= R1;
func hom?? (R1 , R19) -> (Functor of [: ( R19 opp ) , R19 :] , ( Ens R1 )) equals 
:L1006: ( hom?? R19 );
coherence by L1005 , L959;
end;
theorem
L1008: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds (( Hom R19 ) c= R1 implies ( ( hom?- (R1 , R20) ) . R25 ) = [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ])))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
assume L1009: ( Hom R19 ) c= R1;
thus L1010: ( ( hom?- (R1 , R20) ) . R25 ) = ( ( hom?- R20 ) . R25 ) by L1009 , L1002
.= [ [ ( Hom (R20 , ( dom R25 )) ) , ( Hom (R20 , ( cod R25 )) ) ] , ( hom (R20 , R25) ) ] by L742;
end;
theorem
L1011: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R21 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( ( Obj ( hom?- (R1 , R20) ) ) . R21 ) = ( Hom (R20 , R21) ))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R21 being (Object of R19);
assume L1012: ( Hom R19 ) c= R1;
L1013: ( Hom (R20 , R21) ) in ( Hom R19 );
reconsider D201 = ( Hom (R20 , R21) ) as (Element of R1) by L1013 , L1012;
set D202 = ( @ D201 );
L1014: ( ( hom?- (R1 , R20) ) . ( id R21 ) ) = ( ( hom?- R20 ) . ( id R21 ) ) by L1012 , L1002
.= ( id D202 ) by L1012 , L773;
thus L1015: thesis by L1014 , CAT_1:67;
end;
theorem
L1016: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R25 being (Morphism of R19) holds (( Hom R19 ) c= R1 implies ( ( hom-? (R1 , R20) ) . R25 ) = [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ])))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R25 being (Morphism of R19);
assume L1017: ( Hom R19 ) c= R1;
thus L1018: ( ( hom-? (R1 , R20) ) . R25 ) = ( ( hom-? R20 ) . R25 ) by L1017 , L1003
.= [ [ ( Hom (( cod R25 ) , R20) ) , ( Hom (( dom R25 ) , R20) ) ] , ( hom (R25 , R20) ) ] by L755;
end;
theorem
L1019: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R21 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( ( Obj ( hom-? (R1 , R20) ) ) . R21 ) = ( Hom (R21 , R20) ))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R21 being (Object of R19);
assume L1020: ( Hom R19 ) c= R1;
L1021: ( Hom (R21 , R20) ) in ( Hom R19 );
reconsider D203 = ( Hom (R21 , R20) ) as (Element of R1) by L1021 , L1020;
set D204 = ( @ D203 );
L1022: ( ( hom-? (R1 , R20) ) . ( id R21 ) ) = ( ( hom-? R20 ) . ( id R21 ) ) by L1020 , L1003
.= ( id D204 ) by L1020 , L779;
thus L1023: thesis by L1022 , OPPCAT_1:30;
end;
theorem
L1024: (for R1 being non  empty set holds (for R19 being Category holds (for R25 being (Morphism of R19) holds (for R26 being (Morphism of R19) holds (( Hom R19 ) c= R1 implies ( ( hom?? (R1 , R19) ) . [ ( R25 opp ) , R26 ] ) = [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ])))))
proof
let R1 being non  empty set;
let R19 being Category;
let R25 being (Morphism of R19);
let R26 being (Morphism of R19);
assume L1025: ( Hom R19 ) c= R1;
thus L1026: ( ( hom?? (R1 , R19) ) . [ ( R25 opp ) , R26 ] ) = ( ( hom?? R19 ) . [ R25 , R26 ] ) by L1025 , L1006
.= [ [ ( Hom (( cod R25 ) , ( dom R26 )) ) , ( Hom (( dom R25 ) , ( cod R26 )) ) ] , ( hom (R25 , R26) ) ] by L927;
end;
theorem
L1027: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (for R21 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( ( Obj ( hom?? (R1 , R19) ) ) . [ ( R20 opp ) , R21 ] ) = ( Hom (R20 , R21) ))))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
let R21 being (Object of R19);
assume L1028: ( Hom R19 ) c= R1;
L1029: ( Hom (R20 , R21) ) in ( Hom R19 );
reconsider D205 = ( Hom (R20 , R21) ) as (Element of R1) by L1029 , L1028;
L1030: ( id ( R20 opp ) ) = ( id R20 ) by OPPCAT_1:71;
set D206 = ( @ D205 );
L1031: ( ( hom?? (R1 , R19) ) . ( id [ ( R20 opp ) , R21 ] ) ) = ( ( hom?? (R1 , R19) ) . [ ( id ( R20 opp ) ) , ( id R21 ) ] ) by CAT_2:31
.= ( ( hom?? R19 ) . [ ( id R20 ) , ( id R21 ) ] ) by L1028 , L1006 , L1030
.= ( id D206 ) by L1028 , L953;
thus L1032: thesis by L1031 , CAT_1:67;
end;
theorem
L1033: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( ( hom?? (R1 , R19) ) ?- ( R20 opp ) ) = ( hom?- (R1 , R20) )))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
assume L1034: ( Hom R19 ) c= R1;
L1035: ( id ( R20 opp ) ) = ( id R20 ) by OPPCAT_1:71;
thus L1036: ( ( hom?? (R1 , R19) ) ?- ( R20 opp ) ) = ( ( curry ( hom?? R19 ) ) . ( id R20 ) ) by L1034 , L1006 , L1035
.= ( hom?- R20 ) by L946
.= ( hom?- (R1 , R20) ) by L1034 , L1002;
end;
theorem
L1037: (for R1 being non  empty set holds (for R19 being Category holds (for R20 being (Object of R19) holds (( Hom R19 ) c= R1 implies ( ( hom?? (R1 , R19) ) -? R20 ) = ( hom-? (R1 , R20) )))))
proof
let R1 being non  empty set;
let R19 being Category;
let R20 being (Object of R19);
assume L1038: ( Hom R19 ) c= R1;
thus L1039: ( ( hom?? (R1 , R19) ) -? R20 ) = ( ( curry' ( hom?? R19 ) ) . ( id R20 ) ) by L1038 , L1006
.= ( hom-? R20 ) by L946
.= ( hom-? (R1 , R20) ) by L1038 , L1003;
end;
