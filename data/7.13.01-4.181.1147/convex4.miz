:: Convex Sets and Convex Combinations on Complex Linear Spaces
::  by Hidenori Matsuzaki , Noboru Endou and Yasunari Shidama
::
:: Received March 3, 2008
:: Copyright (c) 2008-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, STRUCT_0, SUBSET_1, FUNCT_2, FINSET_1,
      FUNCT_1, CARD_1, FUNCOP_1, COMPLEX1, ALGSTR_0, RLVECT_2, TARSKI, NAT_1,
      CLVECT_1, FINSEQ_1, VALUED_1, RELAT_1, PARTFUN1, XXREAL_0, RLVECT_1,
      CFUNCT_1, CARD_3, SUPINF_2, RLSUB_1, ARYTM_3, ARYTM_1, QC_LANG1, BINOP_1,
      ZFMISC_1, RUSUB_4, REAL_1, REALSET1, XREAL_0, ORDINAL1, XCMPLX_0,
      CONVEX1, SETFAM_1, CSSPACE, PROB_2, CONVEX4, PRE_POLY;
 notations TARSKI, XBOOLE_0, DOMAIN_1, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      PRE_POLY, RELSET_1, FUNCT_2, FINSEQ_1, FINSEQ_4, ALGSTR_0, RLVECT_1,
      SETFAM_1, STRUCT_0, ORDINAL1, NUMBERS, XXREAL_0, XREAL_0, FINSET_1,
      PARTFUN1, FUNCOP_1, CARD_1, VALUED_1, XCMPLX_0, COMPLEX1, RVSUM_1,
      RUSUB_4, RUSUB_5, BINOP_1, REAL_1, RLVECT_2, CFUNCT_1, CLVECT_1, CSSPACE,
      REALSET1;
 constructors SETFAM_1, BINOP_1, FUNCOP_1, REAL_1, FINSEQ_4, COMPLEX1,
      REALSET1, BINOP_2, FINSOP_1, RVSUM_1, RLVECT_2, RUSUB_5, CSSPACE,
      RELSET_1;
 registrations STRUCT_0, MEMBERED, XXREAL_0, CSSPACE, RLVECT_1, RELSET_1,
      FINSET_1, XREAL_0, SUBSET_1, XCMPLX_0, CLVECT_1, XBOOLE_0, NUMBERS,
      NAT_1, FUNCT_2, VALUED_1, VALUED_0, CARD_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCT_1, TARSKI, XBOOLE_0, BINOP_1, RELAT_1, STRUCT_0, REALSET1,
      FINSEQ_1, CLVECT_1, COMPLEX1, RVSUM_1, XCMPLX_0, ALGSTR_0, RUSUB_4,
      RUSUB_5;
 theorems SUBSET_1, STRUCT_0, RVSUM_1, SETFAM_1, ENUMSET1, BINOP_1, CARD_1,
      CARD_2, FINSEQ_1, FINSEQ_3, FINSEQ_4, FUNCT_1, FUNCT_2, NAT_1, RLVECT_1,
      RLVECT_2, TARSKI, ZFMISC_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1,
      COMPLEX1, XCMPLX_1, FUNCOP_1, XREAL_1, XXREAL_0, FINSOP_1, CLVECT_1,
      CSSPACE, CONVEX1, PARTFUN1, XREAL_0, VALUED_1, ALGSTR_0, PRE_POLY,
      XCMPLX_0;
 schemes DOMAIN_1, BINOP_1, SUBSET_1, FINSEQ_1, FUNCT_2, NAT_1, XBOOLE_0;

begin
definition
let C1 being non  empty 1-sorted;
mode C_Linear_Combination of C1
 -> (Element of ( Funcs ((the carrier of C1) , ( COMPLEX )) ))
means :L1: (ex B1 being  finite (Subset of C1) st (for B2 being (Element of C1) holds ((not B2 in B1) implies ( it . B2 ) = ( 0 ))));
existence
proof
reconsider D1 = ( (the carrier of C1) --> ( 0c ) ) as (Element of ( Funcs ((the carrier of C1) , ( COMPLEX )) )) by FUNCT_2:8;
take D1;
take ( {} C1 );
thus L2: thesis by FUNCOP_1:7;
end;
end;
notation
let C2 being non  empty addLoopStr;
let C3 being (Element of ( Funcs ((the carrier of C2) , ( COMPLEX )) ));
synonym Carrier C3 for support C3;
end;
L5:
now
let C4 being non  empty addLoopStr;
let C5 being (Element of ( Funcs ((the carrier of C4) , ( COMPLEX )) ));
L6: ( support C5 ) c= ( dom C5 ) by PRE_POLY:37;
thus L7: ( Carrier C5 ) c= (the carrier of C4)
proof
let C6 being set;
assume L8: C6 in ( support C5 );
L9: C6 in ( dom C5 ) by L8 , L6;
thus L10: thesis by L9;
end;

end;
definition
let C7 being non  empty addLoopStr;
let C8 being (Element of ( Funcs ((the carrier of C7) , ( COMPLEX )) ));
redefine func Carrier C8 -> (Subset of C7) equals 
{ B3 where B3 is (Element of C7) : ( C8 . B3 ) <> ( 0c ) };
coherence by L5;
compatibility
proof
let C9 being (Subset of C7);
set D2 = ( Carrier C8 );
set D3 = { B4 where B4 is (Element of C7) : ( C8 . B4 ) <> ( 0 ) };
thus L8: (C9 = D2 implies C9 = D3)
proof
assume L9: C9 = D2;
thus L10: C9 c= D3
proof
let C10 being set;
assume L11: C10 in C9;
L12: ( C8 . C10 ) <> ( 0 ) by L11 , L9 , PRE_POLY:def 7;
thus L13: thesis by L12 , L11;
end;

let C11 being set;
assume L14: C11 in D3;
L15: (ex B5 being (Element of C7) st (C11 = B5 & ( C8 . B5 ) <> ( 0 ))) by L14;
thus L16: thesis by L15 , L9 , PRE_POLY:def 7;
end;

assume L17: C9 = D3;
thus L18: C9 c= D2
proof
let C12 being set;
assume L19: C12 in C9;
L20: (ex B6 being (Element of C7) st (C12 = B6 & ( C8 . B6 ) <> ( 0 ))) by L19 , L17;
thus L21: thesis by L20 , PRE_POLY:def 7;
end;

let C13 being set;
assume L22: C13 in D2;
L23: ( C8 . C13 ) <> ( 0 ) by L22 , PRE_POLY:def 7;
L24: ( Carrier C8 ) c= (the carrier of C7) by L5;
thus L25: thesis by L24 , L17 , L22 , L23;
end;
end;
registration
let C14 being non  empty addLoopStr;
let C15 being (C_Linear_Combination of C14);
cluster ( Carrier C15 ) ->  finite;
coherence
proof
set D4 = ( Carrier C15 );
consider C16 being  finite (Subset of C14) such that L27: (for B7 being (Element of C14) holds ((not B7 in C16) implies ( C15 . B7 ) = ( 0c ))) by L1;
L28:
now
let C17 being set;
assume L29: C17 in D4;
L30: (ex B8 being (Element of C14) st (C17 = B8 & ( C15 . B8 ) <> ( 0c ))) by L29;
thus L31: C17 in C16 by L30 , L27;
end;
L32: D4 c= C16 by L28 , TARSKI:def 3;
thus L33: thesis by L32;
end;
end;
theorem
L35: (for B9 being non  empty addLoopStr holds (for B10 being (C_Linear_Combination of B9) holds (for B11 being (Element of B9) holds (( B10 . B11 ) = ( 0c ) iff (not B11 in ( Carrier B10 ))))))
proof
let C18 being non  empty addLoopStr;
let C19 being (C_Linear_Combination of C18);
let C20 being (Element of C18);
thus L36: (( C19 . C20 ) = ( 0c ) implies (not C20 in ( Carrier C19 )))
proof
assume L37: ( C19 . C20 ) = ( 0c );
assume L38: (not thesis);
L39: (ex B12 being (Element of C18) st (C20 = B12 & ( C19 . B12 ) <> ( 0c ))) by L38;
thus L40: thesis by L39 , L37;
end;

thus L41: thesis;
end;
definition
let C21 being non  empty addLoopStr;
func ZeroCLC C21 -> (C_Linear_Combination of C21) means 
:L42: ( Carrier it ) = ( {} );
existence
proof
reconsider D5 = ( (the carrier of C21) --> ( 0c ) ) as (Element of ( Funcs ((the carrier of C21) , ( COMPLEX )) )) by FUNCT_2:8;
L43: D5 is (C_Linear_Combination of C21)
proof
take ( {} C21 );
thus L44: thesis by FUNCOP_1:7;
end;
reconsider D6 = D5 as (C_Linear_Combination of C21) by L43;
take D6;
set D7 = { B13 where B13 is (Element of C21) : ( D6 . B13 ) <> ( 0c ) };
L45:
now
set D8 = the (Element of D7);
assume L46: D7 <> ( {} );
L47: D8 in D7 by L46;
L48: (ex B14 being (Element of C21) st (D8 = B14 & ( D6 . B14 ) <> ( 0c ))) by L47;
thus L49: contradiction by L48 , FUNCOP_1:7;
end;
thus L50: thesis by L45;
end;
uniqueness
proof
let C22 , C23 being (C_Linear_Combination of C21);
assume L51: (( Carrier C22 ) = ( {} ) & ( Carrier C23 ) = ( {} ));
L52:
now
let C24 being set;
assume L53: C24 in (the carrier of C21);
reconsider D9 = C24 as (Element of C21) by L53;
L54: (( C23 . D9 ) <> ( 0c ) implies D9 in { B15 where B15 is (Element of C21) : ( C23 . B15 ) <> ( 0c ) });
L55: (( C22 . D9 ) <> ( 0c ) implies D9 in { B16 where B16 is (Element of C21) : ( C22 . B16 ) <> ( 0c ) });
thus L56: ( C22 . C24 ) = ( C23 . C24 ) by L55 , L51 , L54;
end;
thus L57: C22 = C23 by L52 , FUNCT_2:12;
end;
end;
registration
let C25 being non  empty addLoopStr;
cluster ( Carrier ( ZeroCLC C25 ) ) ->  empty;
coherence by L42;
end;
theorem
L60: (for B17 being non  empty addLoopStr holds (for B18 being (Element of B17) holds ( ( ZeroCLC B17 ) . B18 ) = ( 0c )))
proof
let C26 being non  empty addLoopStr;
let C27 being (Element of C26);
L61: (( Carrier ( ZeroCLC C26 ) ) = ( {} ) & (not C27 in ( {} )));
thus L62: thesis by L61;
end;
definition
let C28 being non  empty addLoopStr;
let C29 being (Subset of C28);
mode C_Linear_Combination of C29
 -> (C_Linear_Combination of C28)
means :L63: ( Carrier it ) c= C29;
existence
proof
take D10 = ( ZeroCLC C28 );
L64: ( Carrier D10 ) = ( {} );
thus L65: thesis by L64 , XBOOLE_1:2;
end;
end;
theorem
L67: (for B19 being non  empty addLoopStr holds (for B20 , B21 being (Subset of B19) holds (for B22 being (C_Linear_Combination of B20) holds (B20 c= B21 implies B22 is (C_Linear_Combination of B21)))))
proof
let C30 being non  empty addLoopStr;
let C31 , C32 being (Subset of C30);
let C33 being (C_Linear_Combination of C31);
assume L68: C31 c= C32;
L69: ( Carrier C33 ) c= C31 by L63;
L70: ( Carrier C33 ) c= C32 by L69 , L68 , XBOOLE_1:1;
thus L71: thesis by L70 , L63;
end;
theorem
L72: (for B23 being non  empty addLoopStr holds (for B24 being (Subset of B23) holds ( ZeroCLC B23 ) is (C_Linear_Combination of B24)))
proof
let C34 being non  empty addLoopStr;
let C35 being (Subset of C34);
L73: (( Carrier ( ZeroCLC C34 ) ) = ( {} ) & ( {} ) c= C35) by XBOOLE_1:2;
thus L74: thesis by L73 , L63;
end;
theorem
L75: (for B25 being non  empty addLoopStr holds (for B26 being (C_Linear_Combination of ( {} (the carrier of B25) )) holds B26 = ( ZeroCLC B25 )))
proof
let C36 being non  empty addLoopStr;
let C37 being (C_Linear_Combination of ( {} (the carrier of C36) ));
L76: ( Carrier C37 ) c= ( {} ) by L63;
L77: ( Carrier C37 ) = ( {} ) by L76;
thus L78: thesis by L77 , L42;
end;
definition
let C38 being non  empty CLSStruct;
let C39 being (FinSequence of (the carrier of C38));
let C40 being (Function of (the carrier of C38) , ( COMPLEX ));
func C40 (#) C39 -> (FinSequence of (the carrier of C38)) means 
:L79: (( len it ) = ( len C39 ) & (for R3 being Nat holds (R3 in ( dom it ) implies ( it . R3 ) = ( ( C40 . ( C39 /. R3 ) ) * ( C39 /. R3 ) ))));
existence
proof
deffunc H1(set) = ( ( C40 . ( C39 /. $1 ) ) * ( C39 /. $1 ) );
consider C41 being FinSequence such that L80: ( len C41 ) = ( len C39 ) and L81: (for B27 being Nat holds (B27 in ( dom C41 ) implies ( C41 . B27 ) = H1(B27))) from FINSEQ_1:sch 2;
L82: ( rng C41 ) c= (the carrier of C38)
proof
let R1 being set;
assume L83: R1 in ( rng C41 );
consider R2 being set such that L84: R2 in ( dom C41 ) and L85: ( C41 . R2 ) = R1 by L83 , FUNCT_1:def 3;
reconsider D11 = R2 as (Element of ( NAT )) by L84;
L86: ( C41 . D11 ) = ( ( C40 . ( C39 /. D11 ) ) * ( C39 /. D11 ) ) by L81 , L84;
thus L87: thesis by L86 , L85;
end;
reconsider D12 = C41 as (FinSequence of (the carrier of C38)) by L82 , FINSEQ_1:def 4;
take D12;
thus L88: thesis by L80 , L81;
end;
uniqueness
proof
let C42 , C43 being (FinSequence of (the carrier of C38));
assume that
L89: ( len C42 ) = ( len C39 )
and
L90: (for R3 being Nat holds (R3 in ( dom C42 ) implies ( C42 . R3 ) = ( ( C40 . ( C39 /. R3 ) ) * ( C39 /. R3 ) )))
and
L91: ( len C43 ) = ( len C39 )
and
L92: (for R3 being Nat holds (R3 in ( dom C43 ) implies ( C43 . R3 ) = ( ( C40 . ( C39 /. R3 ) ) * ( C39 /. R3 ) )));
L93:
now
let C44 being Nat;
assume L94: (1 <= C44 & C44 <= ( len C42 ));
L95: C44 in ( Seg ( len C42 ) ) by L94 , FINSEQ_1:1;
L96: C44 in ( dom C42 ) by L95 , FINSEQ_1:def 3;
L97: ( C42 . C44 ) = ( ( C40 . ( C39 /. C44 ) ) * ( C39 /. C44 ) ) by L96 , L90;
L98: C44 in ( dom C43 ) by L89 , L91 , L95 , FINSEQ_1:def 3;
thus L99: ( C42 . C44 ) = ( C43 . C44 ) by L98 , L92 , L97;
end;
thus L100: thesis by L93 , L89 , L91 , FINSEQ_1:14;
end;
end;
theorem
L102: (for R4 being non  empty CLSStruct holds (for R6 being (VECTOR of R4) holds (for R14 being set holds (for R20 being (FinSequence of (the carrier of R4)) holds (for R21 being (Function of (the carrier of R4) , ( COMPLEX )) holds ((R14 in ( dom R20 ) & R6 = ( R20 . R14 )) implies ( ( R21 (#) R20 ) . R14 ) = ( ( R21 . R6 ) * R6 )))))))
proof
let R4 being non  empty CLSStruct;
let R6 being (VECTOR of R4);
let R14 being set;
let R20 being (FinSequence of (the carrier of R4));
let R21 being (Function of (the carrier of R4) , ( COMPLEX ));
assume that
L103: R14 in ( dom R20 )
and
L104: R6 = ( R20 . R14 );
L105: ( R20 /. R14 ) = ( R20 . R14 ) by L103 , PARTFUN1:def 6;
L106: ( len ( R21 (#) R20 ) ) = ( len R20 ) by L79;
L107: R14 in ( dom ( R21 (#) R20 ) ) by L106 , L103 , FINSEQ_3:29;
thus L108: thesis by L107 , L104 , L105 , L79;
end;
theorem
L109: (for R4 being non  empty CLSStruct holds (for R21 being (Function of (the carrier of R4) , ( COMPLEX )) holds ( R21 (#) ( <*> (the carrier of R4) ) ) = ( <*> (the carrier of R4) )))
proof
let R4 being non  empty CLSStruct;
let R21 being (Function of (the carrier of R4) , ( COMPLEX ));
L110: ( len ( R21 (#) ( <*> (the carrier of R4) ) ) ) = ( len ( <*> (the carrier of R4) ) ) by L79
.= ( 0 );
thus L111: thesis by L110;
end;
theorem
L112: (for R4 being non  empty CLSStruct holds (for R6 being (VECTOR of R4) holds (for R21 being (Function of (the carrier of R4) , ( COMPLEX )) holds ( R21 (#) <* R6 *> ) = <* ( ( R21 . R6 ) * R6 ) *>)))
proof
let R4 being non  empty CLSStruct;
let R6 being (VECTOR of R4);
let R21 being (Function of (the carrier of R4) , ( COMPLEX ));
L113: 1 in { 1 } by FINSEQ_1:2;
L114: ( len ( R21 (#) <* R6 *> ) ) = ( len <* R6 *> ) by L79
.= 1 by FINSEQ_1:40;
L115: ( dom ( R21 (#) <* R6 *> ) ) = { 1 } by L114 , FINSEQ_1:2 , FINSEQ_1:def 3;
L116: ( ( R21 (#) <* R6 *> ) . 1 ) = ( ( R21 . ( <* R6 *> /. 1 ) ) * ( <* R6 *> /. 1 ) ) by L115 , L113 , L79
.= ( ( R21 . ( <* R6 *> /. 1 ) ) * R6 ) by FINSEQ_4:16
.= ( ( R21 . R6 ) * R6 ) by FINSEQ_4:16;
thus L117: thesis by L116 , L114 , FINSEQ_1:40;
end;
theorem
L118: (for R4 being non  empty CLSStruct holds (for R7 being (VECTOR of R4) holds (for R8 being (VECTOR of R4) holds (for R21 being (Function of (the carrier of R4) , ( COMPLEX )) holds ( R21 (#) <* R7 , R8 *> ) = <* ( ( R21 . R7 ) * R7 ) , ( ( R21 . R8 ) * R8 ) *>))))
proof
let R4 being non  empty CLSStruct;
let R7 being (VECTOR of R4);
let R8 being (VECTOR of R4);
let R21 being (Function of (the carrier of R4) , ( COMPLEX ));
L119: ( len ( R21 (#) <* R7 , R8 *> ) ) = ( len <* R7 , R8 *> ) by L79
.= 2 by FINSEQ_1:44;
L120: ( dom ( R21 (#) <* R7 , R8 *> ) ) = { 1 , 2 } by L119 , FINSEQ_1:2 , FINSEQ_1:def 3;
L121: 2 in { 1 , 2 } by FINSEQ_1:2;
L122: ( ( R21 (#) <* R7 , R8 *> ) . 2 ) = ( ( R21 . ( <* R7 , R8 *> /. 2 ) ) * ( <* R7 , R8 *> /. 2 ) ) by L121 , L120 , L79
.= ( ( R21 . ( <* R7 , R8 *> /. 2 ) ) * R8 ) by FINSEQ_4:17
.= ( ( R21 . R8 ) * R8 ) by FINSEQ_4:17;
L123: 1 in { 1 , 2 } by FINSEQ_1:2;
L124: ( ( R21 (#) <* R7 , R8 *> ) . 1 ) = ( ( R21 . ( <* R7 , R8 *> /. 1 ) ) * ( <* R7 , R8 *> /. 1 ) ) by L123 , L120 , L79
.= ( ( R21 . ( <* R7 , R8 *> /. 1 ) ) * R7 ) by FINSEQ_4:17
.= ( ( R21 . R7 ) * R7 ) by FINSEQ_4:17;
thus L125: thesis by L124 , L119 , L122 , FINSEQ_1:44;
end;
theorem
L126: (for R4 being non  empty CLSStruct holds (for R7 being (VECTOR of R4) holds (for R8 being (VECTOR of R4) holds (for R9 being (VECTOR of R4) holds (for R21 being (Function of (the carrier of R4) , ( COMPLEX )) holds ( R21 (#) <* R7 , R8 , R9 *> ) = <* ( ( R21 . R7 ) * R7 ) , ( ( R21 . R8 ) * R8 ) , ( ( R21 . R9 ) * R9 ) *>)))))
proof
let R4 being non  empty CLSStruct;
let R7 being (VECTOR of R4);
let R8 being (VECTOR of R4);
let R9 being (VECTOR of R4);
let R21 being (Function of (the carrier of R4) , ( COMPLEX ));
L127: ( len ( R21 (#) <* R7 , R8 , R9 *> ) ) = ( len <* R7 , R8 , R9 *> ) by L79
.= 3 by FINSEQ_1:45;
L128: ( dom ( R21 (#) <* R7 , R8 , R9 *> ) ) = { 1 , 2 , 3 } by L127 , FINSEQ_1:def 3 , FINSEQ_3:1;
L129: 3 in { 1 , 2 , 3 } by FINSEQ_3:1;
L130: ( ( R21 (#) <* R7 , R8 , R9 *> ) . 3 ) = ( ( R21 . ( <* R7 , R8 , R9 *> /. 3 ) ) * ( <* R7 , R8 , R9 *> /. 3 ) ) by L129 , L128 , L79
.= ( ( R21 . ( <* R7 , R8 , R9 *> /. 3 ) ) * R9 ) by FINSEQ_4:18
.= ( ( R21 . R9 ) * R9 ) by FINSEQ_4:18;
L131: 2 in { 1 , 2 , 3 } by FINSEQ_3:1;
L132: ( ( R21 (#) <* R7 , R8 , R9 *> ) . 2 ) = ( ( R21 . ( <* R7 , R8 , R9 *> /. 2 ) ) * ( <* R7 , R8 , R9 *> /. 2 ) ) by L131 , L128 , L79
.= ( ( R21 . ( <* R7 , R8 , R9 *> /. 2 ) ) * R8 ) by FINSEQ_4:18
.= ( ( R21 . R8 ) * R8 ) by FINSEQ_4:18;
L133: 1 in { 1 , 2 , 3 } by FINSEQ_3:1;
L134: ( ( R21 (#) <* R7 , R8 , R9 *> ) . 1 ) = ( ( R21 . ( <* R7 , R8 , R9 *> /. 1 ) ) * ( <* R7 , R8 , R9 *> /. 1 ) ) by L133 , L128 , L79
.= ( ( R21 . ( <* R7 , R8 , R9 *> /. 1 ) ) * R7 ) by FINSEQ_4:18
.= ( ( R21 . R7 ) * R7 ) by FINSEQ_4:18;
thus L135: thesis by L134 , L127 , L132 , L130 , FINSEQ_1:45;
end;
definition
let C45 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct;
let C46 being (C_Linear_Combination of C45);
func Sum C46 -> (Element of C45) means 
:L136: (ex B28 being (FinSequence of (the carrier of C45)) st (B28 is  one-to-one & ( rng B28 ) = ( Carrier C46 ) & it = ( Sum ( C46 (#) B28 ) )));
existence
proof
consider C47 being FinSequence such that L137: ( rng C47 ) = ( Carrier C46 ) and L138: C47 is  one-to-one by FINSEQ_4:58;
reconsider D13 = C47 as (FinSequence of (the carrier of C45)) by L137 , FINSEQ_1:def 4;
take ( Sum ( C46 (#) D13 ) );
take D13;
thus L139: thesis by L137 , L138;
end;
uniqueness
proof
let C48 , C49 being (Element of C45);
given C50 being (FinSequence of (the carrier of C45)) such that
L140: C50 is  one-to-one
and
L141: ( rng C50 ) = ( Carrier C46 )
and
L142: C48 = ( Sum ( C46 (#) C50 ) );

given C51 being (FinSequence of (the carrier of C45)) such that
L143: C51 is  one-to-one
and
L144: ( rng C51 ) = ( Carrier C46 )
and
L145: C49 = ( Sum ( C46 (#) C51 ) );

defpred S1[ set , set ] means { $2 } = ( C50 " { ( C51 . $1 ) } );
L146: ( len C50 ) = ( len C51 ) by L140 , L141 , L143 , L144 , FINSEQ_1:48;
L147: ( dom C50 ) = ( Seg ( len C50 ) ) by FINSEQ_1:def 3;
L148: ( dom C51 ) = ( Seg ( len C51 ) ) by FINSEQ_1:def 3;
L149: (for R14 being set holds (R14 in ( dom C50 ) implies (ex R15 being set st (R15 in ( dom C50 ) & S1[ R14 , R15 ]))))
proof
let R14 being set;
assume L150: R14 in ( dom C50 );
L151: ( C51 . R14 ) in ( rng C50 ) by L150 , L141 , L144 , L146 , L147 , L148 , FUNCT_1:def 3;
consider R15 being set such that L152: ( C50 " { ( C51 . R14 ) } ) = { R15 } by L151 , L140 , FUNCT_1:74;
take R15;
L153: R15 in ( C50 " { ( C51 . R14 ) } ) by L152 , TARSKI:def 1;
thus L154: thesis by L153 , L152 , FUNCT_1:def 7;
end;
consider C52 being (Function of ( dom C50 ) , ( dom C50 )) such that L155: (for R14 being set holds (R14 in ( dom C50 ) implies S1[ R14 , ( C52 . R14 ) ])) from FUNCT_2:sch 1(L149);
L156: ( rng C52 ) = ( dom C50 )
proof
thus L157: ( rng C52 ) c= ( dom C50 ) by RELAT_1:def 19;
let R15 being set;
assume L158: R15 in ( dom C50 );
L159: ( C50 . R15 ) in ( rng C51 ) by L158 , L141 , L144 , FUNCT_1:def 3;
consider R14 being set such that L160: R14 in ( dom C51 ) and L161: ( C51 . R14 ) = ( C50 . R15 ) by L159 , FUNCT_1:def 3;
L162: ( C50 " { ( C51 . R14 ) } ) = ( C50 " ( Im (C50 , R15) ) ) by L158 , L161 , FUNCT_1:59;
L163: ( C50 " { ( C51 . R14 ) } ) c= { R15 } by L162 , L140 , FUNCT_1:82;
L164: { ( C52 . R14 ) } c= { R15 } by L163 , L146 , L147 , L148 , L155 , L160;
L165: ( C52 . R14 ) = R15 by L164 , ZFMISC_1:18;
L166: R14 in ( dom C52 ) by L146 , L147 , L148 , L160 , FUNCT_2:def 1;
thus L167: thesis by L166 , L165 , FUNCT_1:def 3;
end;
set D14 = ( C46 (#) C50 );
L168: ( len D14 ) = ( len C50 ) by L79;
L169: C52 is  one-to-one
proof
let R16 being set;
let R17 being set;
assume that
L170: R16 in ( dom C52 )
and
L171: R17 in ( dom C52 )
and
L172: ( C52 . R16 ) = ( C52 . R17 );
L173: ( C51 . R16 ) in ( rng C50 ) by L141 , L144 , L146 , L147 , L148 , L170 , FUNCT_1:def 3;
L174: { ( C51 . R16 ) } c= ( rng C50 ) by L173 , ZFMISC_1:31;
L175: ( C51 . R17 ) in ( rng C50 ) by L141 , L144 , L146 , L147 , L148 , L171 , FUNCT_1:def 3;
L176: { ( C51 . R17 ) } c= ( rng C50 ) by L175 , ZFMISC_1:31;
L177: (( C50 " { ( C51 . R16 ) } ) = { ( C52 . R16 ) } & ( C50 " { ( C51 . R17 ) } ) = { ( C52 . R17 ) }) by L155 , L170 , L171;
L178: { ( C51 . R16 ) } = { ( C51 . R17 ) } by L177 , L172 , L174 , L176 , FUNCT_1:91;
L179: ( C51 . R16 ) = ( C51 . R17 ) by L178 , ZFMISC_1:3;
thus L180: thesis by L179 , L143 , L146 , L147 , L148 , L170 , L171 , FUNCT_1:def 4;
end;
set D15 = ( C46 (#) C51 );
L181: ( dom D15 ) = ( Seg ( len D15 ) ) by FINSEQ_1:def 3;
reconsider D16 = C52 as (Permutation of ( dom C50 )) by L156 , L169 , FUNCT_2:57;
L182: (( dom C50 ) = ( Seg ( len C50 ) ) & ( dom D14 ) = ( Seg ( len D14 ) )) by FINSEQ_1:def 3;
reconsider D17 = D16 as (Permutation of ( dom D14 )) by L182 , L168;
L183: ( len D15 ) = ( len C51 ) by L79;
L184: ( dom D14 ) = ( Seg ( len D14 ) ) by FINSEQ_1:def 3;
L185:
now
let C53 being (Element of ( NAT ));
assume L186: C53 in ( dom D15 );
L187: (( D15 . C53 ) = ( ( C46 . ( C51 /. C53 ) ) * ( C51 /. C53 ) ) & ( C51 . C53 ) = ( C51 /. C53 )) by L186 , L183 , L148 , L181 , L79 , PARTFUN1:def 6;
L188: C53 in ( dom D17 ) by L146 , L183 , L147 , L181 , L186 , FUNCT_2:def 1;
L189: ( D17 . C53 ) in ( dom C50 ) by L188 , L156 , FUNCT_1:def 3;
reconsider D18 = ( D17 . C53 ) as (Element of ( NAT )) by L189;
L190: { ( C50 . ( D17 . C53 ) ) } = ( Im (C50 , ( D17 . C53 )) ) by L189 , FUNCT_1:59
.= ( C50 .: ( C50 " { ( C51 . C53 ) } ) ) by L146 , L183 , L147 , L181 , L155 , L186;
L191: ( C51 . C53 ) = ( C50 . D18 ) by L190 , FUNCT_1:75 , ZFMISC_1:18;
L192: ( C50 . D18 ) = ( C50 /. D18 ) by L189 , PARTFUN1:def 6;
thus L193: ( D15 . C53 ) = ( D14 . ( D17 . C53 ) ) by L192 , L168 , L147 , L184 , L189 , L191 , L187 , L79;
end;
thus L194: thesis by L185 , L140 , L141 , L142 , L143 , L144 , L145 , L168 , L183 , FINSEQ_1:48 , RLVECT_2:6;
end;
end;
theorem
L196: (for B29 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct holds ( Sum ( ZeroCLC B29 ) ) = ( 0. B29 ))
proof
let C54 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct;
consider C55 being (FinSequence of (the carrier of C54)) such that L197: C55 is  one-to-one and L198: ( rng C55 ) = ( Carrier ( ZeroCLC C54 ) ) and L199: ( Sum ( ZeroCLC C54 ) ) = ( Sum ( ( ZeroCLC C54 ) (#) C55 ) ) by L136;
L200: C55 = ( {} ) by L198 , RELAT_1:41;
L201: ( len ( ( ZeroCLC C54 ) (#) C55 ) ) = ( 0 ) by L200 , L79 , CARD_1:27;
thus L202: thesis by L201 , L199 , RLVECT_1:75;
end;
theorem
L203: (for B30 being ComplexLinearSpace holds (for B31 being (Subset of B30) holds (B31 <> ( {} ) implies (B31 is  linearly-closed iff (for B32 being (C_Linear_Combination of B31) holds ( Sum B32 ) in B31)))))
proof
let C56 being ComplexLinearSpace;
let C57 being (Subset of C56);
assume L204: C57 <> ( {} );
thus L205: (C57 is  linearly-closed implies (for B33 being (C_Linear_Combination of C57) holds ( Sum B33 ) in C57))
proof
defpred S2[ Nat ] means (for B34 being (C_Linear_Combination of C57) holds (( card ( Carrier B34 ) ) = $1 implies ( Sum B34 ) in C57));
assume L206: C57 is  linearly-closed;
L207: (for B35 being (Element of ( NAT )) holds (S2[ B35 ] implies S2[ ( B35 + 1 ) ]))
proof
let C58 being (Element of ( NAT ));
assume L208: S2[ C58 ];
thus L209:now
let C59 being (C_Linear_Combination of C57);
deffunc H2((Element of C56)) = ( C59 . $1 );
consider C60 being (FinSequence of (the carrier of C56)) such that L210: C60 is  one-to-one and L211: ( rng C60 ) = ( Carrier C59 ) and L212: ( Sum C59 ) = ( Sum ( C59 (#) C60 ) ) by L136;
reconsider D19 = ( C60 | ( Seg C58 ) ) as (FinSequence of (the carrier of C56)) by FINSEQ_1:18;
assume L213: ( card ( Carrier C59 ) ) = ( C58 + 1 );
L214: ( len C60 ) = ( C58 + 1 ) by L213 , L210 , L211 , FINSEQ_4:62;
L215: ( len ( C59 (#) C60 ) ) = ( C58 + 1 ) by L214 , L79;
L216: ( C58 + 1 ) in ( Seg ( C58 + 1 ) ) by FINSEQ_1:4;
L217: ( C58 + 1 ) in ( dom C60 ) by L216 , L214 , FINSEQ_1:def 3;
reconsider D20 = ( C60 . ( C58 + 1 ) ) as (VECTOR of C56) by L217 , FUNCT_1:102;
consider C61 being (Function of (the carrier of C56) , ( COMPLEX )) such that L218: (( C61 . D20 ) = ( 0c ) & (for B36 being (Element of C56) holds (B36 <> D20 implies ( C61 . B36 ) = H2(B36)))) from FUNCT_2:sch 6;
reconsider D21 = C61 as (Element of ( Funcs ((the carrier of C56) , ( COMPLEX )) )) by FUNCT_2:8;
L219:
now
let C62 being (VECTOR of C56);
assume L220: (not C62 in ( Carrier C59 ));
L221: ( C59 . C62 ) = ( 0c ) by L220;
thus L222: ( D21 . C62 ) = ( 0c ) by L221 , L218;
end;
reconsider D22 = D21 as (C_Linear_Combination of C56) by L219 , L1;
L223: ( Carrier D22 ) = ( ( Carrier C59 ) \ { D20 } )
proof
L224:
now
let R14 being set;
assume L225: R14 in ( Carrier D22 );
L226: (ex B37 being (VECTOR of C56) st (B37 = R14 & ( D22 . B37 ) <> ( 0c ))) by L225;
L227: ( D22 . R14 ) = ( C59 . R14 ) by L226 , L218;
L228: R14 in ( Carrier C59 ) by L227 , L226;
L229: (not R14 in { D20 }) by L218 , L226 , TARSKI:def 1;
thus L230: R14 in ( ( Carrier C59 ) \ { D20 } ) by L229 , L228 , XBOOLE_0:def 5;
end;
thus L231: ( Carrier D22 ) c= ( ( Carrier C59 ) \ { D20 } ) by L224 , TARSKI:def 3;
let R14 being set;
assume L232: R14 in ( ( Carrier C59 ) \ { D20 } );
L233: (not R14 in { D20 }) by L232 , XBOOLE_0:def 5;
L234: R14 <> D20 by L233 , TARSKI:def 1;
L235: ( C59 . R14 ) = ( D22 . R14 ) by L234 , L218 , L232;
L236: R14 in ( Carrier C59 ) by L232 , XBOOLE_0:def 5;
L237: (ex B38 being (VECTOR of C56) st (R14 = B38 & ( C59 . B38 ) <> ( 0c ))) by L236;
thus L238: thesis by L237 , L235;
end;
L239: ( Carrier C59 ) c= C57 by L63;
L240: ( Carrier D22 ) c= ( C57 \ { D20 } ) by L239 , L223 , XBOOLE_1:33;
L241: ( Carrier D22 ) c= C57 by L240 , XBOOLE_1:106;
reconsider D23 = D22 as (C_Linear_Combination of C57) by L241 , L63;
L242: ( len D19 ) = C58 by L214 , FINSEQ_3:53;
L243: ( len ( D23 (#) D19 ) ) = C58 by L242 , L79;
L244: ( rng D19 ) = ( Carrier D23 )
proof
thus L245: ( rng D19 ) c= ( Carrier D23 )
proof
let R14 being set;
assume L246: R14 in ( rng D19 );
consider R15 being set such that L247: R15 in ( dom D19 ) and L248: ( D19 . R15 ) = R14 by L246 , FUNCT_1:def 3;
reconsider D24 = R15 as (Element of ( NAT )) by L247;
L249: (( dom D19 ) c= ( dom C60 ) & ( D19 . D24 ) = ( C60 . D24 )) by L247 , FUNCT_1:47 , RELAT_1:60;
L250: (R14 = D20 implies (( C58 + 1 ) = D24 & D24 <= C58 & C58 < ( C58 + 1 ))) by L249 , L210 , L242 , L217 , L247 , L248 , FINSEQ_3:25 , FUNCT_1:def 4 , XREAL_1:29;
L251: (not R14 in { D20 }) by L250 , TARSKI:def 1;
L252: R14 in ( rng C60 ) by L247 , L248 , L249 , FUNCT_1:def 3;
thus L253: thesis by L252 , L211 , L223 , L251 , XBOOLE_0:def 5;
end;

let R14 being set;
assume L254: R14 in ( Carrier D23 );
L255: R14 in ( rng C60 ) by L254 , L211 , L223 , XBOOLE_0:def 5;
consider R15 being set such that L256: R15 in ( dom C60 ) and L257: ( C60 . R15 ) = R14 by L255 , FUNCT_1:def 3;
L258:
now
assume L259: (not R15 in ( Seg C58 ));
L260: R15 in ( ( dom C60 ) \ ( Seg C58 ) ) by L259 , L256 , XBOOLE_0:def 5;
L261: R15 in ( ( Seg ( C58 + 1 ) ) \ ( Seg C58 ) ) by L260 , L214 , FINSEQ_1:def 3;
L262: R15 in { ( C58 + 1 ) } by L261 , FINSEQ_3:15;
L263: R15 = ( C58 + 1 ) by L262 , TARSKI:def 1;
L264: (not D20 in { D20 }) by L263 , L223 , L254 , L257 , XBOOLE_0:def 5;
thus L265: contradiction by L264 , TARSKI:def 1;
end;
L266: R15 in ( ( dom C60 ) /\ ( Seg C58 ) ) by L258 , L256 , XBOOLE_0:def 4;
L267: R15 in ( dom D19 ) by L266 , RELAT_1:61;
L268: ( D19 . R15 ) = ( C60 . R15 ) by L267 , FUNCT_1:47;
thus L269: thesis by L268 , L257 , L267 , FUNCT_1:def 3;
end;
L270: ( ( Seg ( C58 + 1 ) ) /\ ( Seg C58 ) ) = ( Seg C58 ) by FINSEQ_1:7 , NAT_1:12
.= ( dom ( D23 (#) D19 ) ) by L243 , FINSEQ_1:def 3;
L271: ( dom ( D23 (#) D19 ) ) = ( ( dom ( C59 (#) C60 ) ) /\ ( Seg C58 ) ) by L270 , L215 , FINSEQ_1:def 3;
L272:
now
let R14 being set;
assume L273: R14 in ( dom ( D23 (#) D19 ) );
L274: R14 in ( dom D19 ) by L273 , L242 , L243 , FINSEQ_3:29;
L275: ( D19 . R14 ) in ( rng D19 ) by L274 , FUNCT_1:def 3;
reconsider D25 = ( D19 . R14 ) as (VECTOR of C56) by L275;
L276: ( C60 . R14 ) = D25 by L274 , FUNCT_1:47;
L277: (not D25 in { D20 }) by L223 , L244 , L275 , XBOOLE_0:def 5;
L278: D25 <> D20 by L277 , TARSKI:def 1;
L279: R14 in ( dom ( C59 (#) C60 ) ) by L271 , L273 , XBOOLE_0:def 4;
L280: R14 in ( dom C60 ) by L279 , L214 , L215 , FINSEQ_3:29;
L281: ( ( D23 (#) D19 ) . R14 ) = ( ( D23 . D25 ) * D25 ) by L274 , L102
.= ( ( C59 . D25 ) * D25 ) by L218 , L278;
thus L282: ( ( D23 (#) D19 ) . R14 ) = ( ( C59 (#) C60 ) . R14 ) by L281 , L280 , L276 , L102;
end;
L283: ( D23 (#) D19 ) = ( ( C59 (#) C60 ) | ( Seg C58 ) ) by L272 , L271 , FUNCT_1:46;
L284: D20 in ( rng C60 ) by L217 , FUNCT_1:def 3;
L285: { D20 } c= ( Carrier C59 ) by L284 , L211 , ZFMISC_1:31;
L286: ( card ( Carrier D23 ) ) = ( ( C58 + 1 ) - ( card { D20 } ) ) by L285 , L213 , L223 , CARD_2:44;
L287: ( card ( Carrier D23 ) ) = ( ( C58 + 1 ) - 1 ) by L286 , CARD_1:30;
L288: ( Sum D23 ) in C57 by L287 , L208;
L289: D20 in ( Carrier C59 ) by L211 , L217 , FUNCT_1:def 3;
L290: ( ( C59 . D20 ) * D20 ) in C57 by L289 , L206 , L239 , CLVECT_1:def 7;
L291: D19 is  one-to-one by L210 , FUNCT_1:52;
L292: ( Sum ( D23 (#) D19 ) ) = ( Sum D23 ) by L291 , L244 , L136;
L293: (( dom ( D23 (#) D19 ) ) = ( Seg ( len ( D23 (#) D19 ) ) ) & ( ( C59 (#) C60 ) . ( len C60 ) ) = ( ( C59 . D20 ) * D20 )) by L214 , L217 , L102 , FINSEQ_1:def 3;
L294: ( Sum ( C59 (#) C60 ) ) = ( ( Sum ( D23 (#) D19 ) ) + ( ( C59 . D20 ) * D20 ) ) by L293 , L214 , L215 , L243 , L283 , RLVECT_1:38;
thus L295: ( Sum C59 ) in C57 by L294 , L206 , L212 , L290 , L292 , L288 , CLVECT_1:def 7;
end;
end;
let C63 being (C_Linear_Combination of C57);
L210: ( card ( Carrier C63 ) ) = ( card ( Carrier C63 ) );
L211:
now
let C64 being (C_Linear_Combination of C57);
assume L212: ( card ( Carrier C64 ) ) = ( 0 );
L213: ( Carrier C64 ) = ( {} ) by L212;
L214: C64 = ( ZeroCLC C56 ) by L213 , L42;
L215: ( Sum C64 ) = ( 0. C56 ) by L214 , L196;
thus L216: ( Sum C64 ) in C57 by L215 , L204 , L206 , CLVECT_1:20;
end;
L217: S2[ ( 0 ) ] by L211;
L218: (for B39 being (Element of ( NAT )) holds S2[ B39 ]) from NAT_1:sch 1(L217 , L207);
thus L219: thesis by L218 , L210;
end;

assume L220: (for B40 being (C_Linear_Combination of C57) holds ( Sum B40 ) in C57);
L221: (( ZeroCLC C56 ) is (C_Linear_Combination of C57) & ( Sum ( ZeroCLC C56 ) ) = ( 0. C56 )) by L72 , L196;
L222: ( 0. C56 ) in C57 by L221 , L220;
L223: (for B41 being Complex holds (for B42 being (VECTOR of C56) holds (B42 in C57 implies ( B41 * B42 ) in C57)))
proof
let C65 being Complex;
let C66 being (VECTOR of C56);
assume L224: C66 in C57;
L225:
now
reconsider D26 = C65 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
deffunc H3((Element of C56)) = ( 0c );
consider C67 being (Function of (the carrier of C56) , ( COMPLEX )) such that L226: (( C67 . C66 ) = D26 & (for B43 being (Element of C56) holds (B43 <> C66 implies ( C67 . B43 ) = H3(B43)))) from FUNCT_2:sch 6;
reconsider D27 = C67 as (Element of ( Funcs ((the carrier of C56) , ( COMPLEX )) )) by FUNCT_2:8;
L227:
now
let C68 being (VECTOR of C56);
assume L228: (not C68 in { C66 });
L229: C68 <> C66 by L228 , TARSKI:def 1;
thus L230: ( D27 . C68 ) = ( 0 ) by L229 , L226;
end;
reconsider D28 = D27 as (C_Linear_Combination of C56) by L227 , L1;
assume L231: C65 <> ( 0 );
L232: ( Carrier D28 ) = { C66 }
proof
L233:
now
let R14 being set;
assume L234: R14 in ( Carrier D28 );
L235: (ex B44 being (VECTOR of C56) st (R14 = B44 & ( D28 . B44 ) <> ( 0 ))) by L234;
L236: R14 = C66 by L235 , L226;
thus L237: R14 in { C66 } by L236 , TARSKI:def 1;
end;
thus L238: ( Carrier D28 ) c= { C66 } by L233 , TARSKI:def 3;
let R14 being set;
assume L239: R14 in { C66 };
L240: R14 = C66 by L239 , TARSKI:def 1;
thus L241: thesis by L240 , L231 , L226;
end;
L242: { C66 } c= C57 by L224 , ZFMISC_1:31;
reconsider D29 = D28 as (C_Linear_Combination of C57) by L242 , L232 , L63;
consider C69 being (FinSequence of (the carrier of C56)) such that L243: (C69 is  one-to-one & ( rng C69 ) = ( Carrier D29 )) and L244: ( Sum ( D29 (#) C69 ) ) = ( Sum D29 ) by L136;
L245: C69 = <* C66 *> by L232 , L243 , FINSEQ_3:97;
L246: ( D29 (#) C69 ) = <* ( ( D29 . C66 ) * C66 ) *> by L245 , L112;
L247: ( Sum D29 ) = ( C65 * C66 ) by L246 , L226 , L244 , RLVECT_1:44;
thus L248: thesis by L247 , L220;
end;
thus L249: thesis by L225 , L222 , CLVECT_1:1;
end;
L250: (for B45 , B46 being (VECTOR of C56) holds ((B45 in C57 & B46 in C57) implies ( B45 + B46 ) in C57))
proof
let C70 , C71 being (VECTOR of C56);
assume that
L251: C70 in C57
and
L252: C71 in C57;
L253: ( ( 1r ) * C70 ) = C70 by CLVECT_1:def 5;
L254: ( ( 1r ) * C71 ) = C71 by CLVECT_1:def 5;
L255:
now
deffunc H4((Element of C56)) = ( 0c );
assume L256: C70 <> C71;
consider C72 being (Function of (the carrier of C56) , ( COMPLEX )) such that L257: (( C72 . C70 ) = ( 1r ) & ( C72 . C71 ) = ( 1r )) and L258: (for B47 being (Element of C56) holds ((B47 <> C70 & B47 <> C71) implies ( C72 . B47 ) = H4(B47))) from FUNCT_2:sch 7(L256);
reconsider D30 = C72 as (Element of ( Funcs ((the carrier of C56) , ( COMPLEX )) )) by FUNCT_2:8;
L259:
now
let C73 being (VECTOR of C56);
assume L260: (not C73 in { C70 , C71 });
L261: (C73 <> C70 & C73 <> C71) by L260 , TARSKI:def 2;
thus L262: ( D30 . C73 ) = ( 0 ) by L261 , L258;
end;
reconsider D31 = D30 as (C_Linear_Combination of C56) by L259 , L1;
L263: ( Carrier D31 ) = { C70 , C71 }
proof
thus L264: ( Carrier D31 ) c= { C70 , C71 }
proof
let R14 being set;
assume L265: R14 in ( Carrier D31 );
L266: (ex B48 being (VECTOR of C56) st (R14 = B48 & ( D31 . B48 ) <> ( 0c ))) by L265;
L267: (R14 = C70 or R14 = C71) by L266 , L258;
thus L268: thesis by L267 , TARSKI:def 2;
end;

let R14 being set;
assume L269: R14 in { C70 , C71 };
L270: (R14 = C70 or R14 = C71) by L269 , TARSKI:def 2;
thus L271: thesis by L270 , L257;
end;
L272: ( Carrier D31 ) c= C57 by L263 , L251 , L252 , ZFMISC_1:32;
reconsider D32 = D31 as (C_Linear_Combination of C57) by L272 , L63;
consider C74 being (FinSequence of (the carrier of C56)) such that L273: (C74 is  one-to-one & ( rng C74 ) = ( Carrier D32 )) and L274: ( Sum ( D32 (#) C74 ) ) = ( Sum D32 ) by L136;
L275: (C74 = <* C70 , C71 *> or C74 = <* C71 , C70 *>) by L256 , L263 , L273 , FINSEQ_3:99;
L276: (( D32 (#) C74 ) = <* ( ( 1r ) * C70 ) , ( ( 1r ) * C71 ) *> or ( D32 (#) C74 ) = <* ( ( 1r ) * C71 ) , ( ( 1r ) * C70 ) *>) by L275 , L257 , L118;
L277: ( Sum D32 ) = ( C70 + C71 ) by L276 , L254 , L253 , L274 , RLVECT_1:45;
thus L278: thesis by L277 , L220;
end;
L279: ( C70 + C70 ) = ( ( ( 1r ) + ( 1r ) ) * C70 ) by L253 , CLVECT_1:def 3;
thus L280: thesis by L279 , L223 , L251 , L255;
end;
thus L281: thesis by L250 , L223 , CLVECT_1:def 7;
end;
theorem
L282: (for B49 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct holds (for B50 being (C_Linear_Combination of ( {} (the carrier of B49) )) holds ( Sum B50 ) = ( 0. B49 )))
proof
let C75 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct;
let C76 being (C_Linear_Combination of ( {} (the carrier of C75) ));
L283: C76 = ( ZeroCLC C75 ) by L75;
thus L284: thesis by L283 , L196;
end;
theorem
L285: (for B51 being ComplexLinearSpace holds (for B52 being (VECTOR of B51) holds (for B53 being (C_Linear_Combination of { B52 }) holds ( Sum B53 ) = ( ( B53 . B52 ) * B52 ))))
proof
let C77 being ComplexLinearSpace;
let C78 being (VECTOR of C77);
let C79 being (C_Linear_Combination of { C78 });
L286: ( Carrier C79 ) c= { C78 } by L63;
per cases  by L286 , ZFMISC_1:33;
suppose L287: ( Carrier C79 ) = ( {} );

L288: C79 = ( ZeroCLC C77 ) by L287 , L42;
thus L289: ( Sum C79 ) = ( 0. C77 ) by L288 , L196
.= ( ( 0c ) * C78 ) by CLVECT_1:1
.= ( ( C79 . C78 ) * C78 ) by L288 , L60;
end;
suppose L290: ( Carrier C79 ) = { C78 };

consider C80 being (FinSequence of (the carrier of C77)) such that L291: (C80 is  one-to-one & ( rng C80 ) = { C78 }) and L292: ( Sum C79 ) = ( Sum ( C79 (#) C80 ) ) by L290 , L136;
L293: C80 = <* C78 *> by L291 , FINSEQ_3:97;
L294: ( C79 (#) C80 ) = <* ( ( C79 . C78 ) * C78 ) *> by L293 , L112;
thus L295: thesis by L294 , L292 , RLVECT_1:44;
end;
end;
theorem
L297: (for B54 being ComplexLinearSpace holds (for B55 , B56 being (VECTOR of B54) holds (B55 <> B56 implies (for B57 being (C_Linear_Combination of { B55 , B56 }) holds ( Sum B57 ) = ( ( ( B57 . B55 ) * B55 ) + ( ( B57 . B56 ) * B56 ) )))))
proof
let C81 being ComplexLinearSpace;
let C82 , C83 being (VECTOR of C81);
assume L298: C82 <> C83;
let C84 being (C_Linear_Combination of { C82 , C83 });
L299: ( 0. C81 ) = ( ( 0c ) * C82 ) by CLVECT_1:1;
L300: ( Carrier C84 ) c= { C82 , C83 } by L63;
L301: ( 0. C81 ) = ( ( 0c ) * C83 ) by CLVECT_1:1;
per cases  by L300 , ZFMISC_1:36;
suppose L302: ( Carrier C84 ) = ( {} );

L303: C84 = ( ZeroCLC C81 ) by L302 , L42;
thus L304: ( Sum C84 ) = ( 0. C81 ) by L303 , L196
.= ( ( 0. C81 ) + ( 0. C81 ) ) by RLVECT_1:4
.= ( ( ( C84 . C82 ) * C82 ) + ( ( 0c ) * C83 ) ) by L301 , L303 , L60 , CLVECT_1:1
.= ( ( ( C84 . C82 ) * C82 ) + ( ( C84 . C83 ) * C83 ) ) by L303 , L60;
end;
suppose L305: ( Carrier C84 ) = { C82 };

reconsider D33 = C84 as (C_Linear_Combination of { C82 }) by L305 , L63;
L306: ( Sum D33 ) = ( ( C84 . C82 ) * C82 ) by L285;
L307: ( Sum C84 ) = ( ( ( C84 . C82 ) * C82 ) + ( 0. C81 ) ) by L306 , RLVECT_1:4;
L308: (not C83 in ( Carrier C84 )) by L298 , L305 , TARSKI:def 1;
thus L309: thesis by L308 , L301 , L307;
end;
suppose L310: ( Carrier C84 ) = { C83 };

reconsider D34 = C84 as (C_Linear_Combination of { C83 }) by L310 , L63;
L311: ( Sum D34 ) = ( ( C84 . C83 ) * C83 ) by L285;
L312: ( Sum C84 ) = ( ( 0. C81 ) + ( ( C84 . C83 ) * C83 ) ) by L311 , RLVECT_1:4;
L313: (not C82 in ( Carrier C84 )) by L298 , L310 , TARSKI:def 1;
thus L314: thesis by L313 , L299 , L312;
end;
suppose L315: ( Carrier C84 ) = { C82 , C83 };

consider C85 being (FinSequence of (the carrier of C81)) such that L316: (C85 is  one-to-one & ( rng C85 ) = { C82 , C83 }) and L317: ( Sum C84 ) = ( Sum ( C84 (#) C85 ) ) by L315 , L136;
L318: (C85 = <* C82 , C83 *> or C85 = <* C83 , C82 *>) by L298 , L316 , FINSEQ_3:99;
L319: (( C84 (#) C85 ) = <* ( ( C84 . C82 ) * C82 ) , ( ( C84 . C83 ) * C83 ) *> or ( C84 (#) C85 ) = <* ( ( C84 . C83 ) * C83 ) , ( ( C84 . C82 ) * C82 ) *>) by L318 , L118;
thus L320: thesis by L319 , L317 , RLVECT_1:45;
end;
end;
theorem
L322: (for B58 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct holds (for B59 being (C_Linear_Combination of B58) holds (( Carrier B59 ) = ( {} ) implies ( Sum B59 ) = ( 0. B58 ))))
proof
let C86 being  Abelian  add-associative  right_zeroed  right_complementable non  empty CLSStruct;
let C87 being (C_Linear_Combination of C86);
assume L323: ( Carrier C87 ) = ( {} );
L324: C87 = ( ZeroCLC C86 ) by L323 , L42;
thus L325: thesis by L324 , L196;
end;
theorem
L326: (for B60 being ComplexLinearSpace holds (for B61 being (C_Linear_Combination of B60) holds (for B62 being (VECTOR of B60) holds (( Carrier B61 ) = { B62 } implies ( Sum B61 ) = ( ( B61 . B62 ) * B62 )))))
proof
let C88 being ComplexLinearSpace;
let C89 being (C_Linear_Combination of C88);
let C90 being (VECTOR of C88);
assume L327: ( Carrier C89 ) = { C90 };
L328: C89 is (C_Linear_Combination of { C90 }) by L327 , L63;
thus L329: thesis by L328 , L285;
end;
theorem
L330: (for B63 being ComplexLinearSpace holds (for B64 being (C_Linear_Combination of B63) holds (for B65 , B66 being (VECTOR of B63) holds ((( Carrier B64 ) = { B65 , B66 } & B65 <> B66) implies ( Sum B64 ) = ( ( ( B64 . B65 ) * B65 ) + ( ( B64 . B66 ) * B66 ) )))))
proof
let C91 being ComplexLinearSpace;
let C92 being (C_Linear_Combination of C91);
let C93 , C94 being (VECTOR of C91);
assume that
L331: ( Carrier C92 ) = { C93 , C94 }
and
L332: C93 <> C94;
L333: C92 is (C_Linear_Combination of { C93 , C94 }) by L331 , L63;
thus L334: thesis by L333 , L332 , L297;
end;
definition
let C95 being non  empty addLoopStr;
let C96 , C97 being (C_Linear_Combination of C95);
redefine pred C96 = C97
means
(for B67 being (Element of C95) holds ( C96 . B67 ) = ( C97 . B67 ))
;compatibility by FUNCT_2:63;
end;
definition
let C98 being non  empty addLoopStr;
let C99 , C100 being (C_Linear_Combination of C98);
redefine func C99 + C100 -> (C_Linear_Combination of C98) means 
:L336: (for B68 being (Element of C98) holds ( it . B68 ) = ( ( C99 . B68 ) + ( C100 . B68 ) ));
coherence
proof
reconsider D35 = ( C99 + C100 ) as (Element of ( Funcs ((the carrier of C98) , ( COMPLEX )) )) by FUNCT_2:8;
L337:
now
let C101 being (Element of C98);
assume L338: (not C101 in ( ( Carrier C99 ) \/ ( Carrier C100 ) ));
L339: (not C101 in ( Carrier C100 )) by L338 , XBOOLE_0:def 3;
L340: ( C100 . C101 ) = ( 0 ) by L339;
L341: (not C101 in ( Carrier C99 )) by L338 , XBOOLE_0:def 3;
L342: ( C99 . C101 ) = ( 0 ) by L341;
thus L343: ( D35 . C101 ) = ( ( 0 ) + ( 0 ) ) by L342 , L340 , VALUED_1:1
.= ( 0 );
end;
thus L344: thesis by L337 , L1;
end;
compatibility
proof
let C102 being (C_Linear_Combination of C98);
thus L345: (C102 = ( C99 + C100 ) implies (for B69 being (Element of C98) holds ( C102 . B69 ) = ( ( C99 . B69 ) + ( C100 . B69 ) ))) by VALUED_1:1;
assume L346: (for B70 being (Element of C98) holds ( C102 . B70 ) = ( ( C99 . B70 ) + ( C100 . B70 ) ));
L347: (for B71 being set holds (B71 in ( dom C102 ) implies ( C102 . B71 ) = ( ( C99 . B71 ) + ( C100 . B71 ) ))) by L346;
L348: (( dom C99 ) = (the carrier of C98) & ( dom C100 ) = (the carrier of C98)) by FUNCT_2:92;
L349: ( dom C102 ) = ( ( dom C99 ) /\ ( dom C100 ) ) by L348 , FUNCT_2:92;
thus L350: C102 = ( C99 + C100 ) by L349 , L347 , VALUED_1:def 1;
end;
end;
theorem
L352: (for R4 being non  empty CLSStruct holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ( Carrier ( R24 + R25 ) ) c= ( ( Carrier R24 ) \/ ( Carrier R25 ) ))))
proof
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
let R14 being set;
assume L353: R14 in ( Carrier ( R24 + R25 ) );
consider R5 being (VECTOR of R4) such that L354: R14 = R5 and L355: ( ( R24 + R25 ) . R5 ) <> ( 0c ) by L353;
L356: ( ( R24 + R25 ) . R5 ) = ( ( R24 . R5 ) + ( R25 . R5 ) ) by L336;
L357: (( R24 . R5 ) <> ( 0c ) or ( R25 . R5 ) <> ( 0c )) by L356 , L355;
L358: (R14 in ( Carrier R24 ) or R14 in ( Carrier R25 )) by L357 , L354;
thus L359: thesis by L358 , XBOOLE_0:def 3;
end;
theorem
L360: (for R4 being non  empty CLSStruct holds (for R10 being (Subset of R4) holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ((R24 is (C_Linear_Combination of R10) & R25 is (C_Linear_Combination of R10)) implies ( R24 + R25 ) is (C_Linear_Combination of R10))))))
proof
let R4 being non  empty CLSStruct;
let R10 being (Subset of R4);
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
assume L361: (R24 is (C_Linear_Combination of R10) & R25 is (C_Linear_Combination of R10));
L362: (( Carrier R24 ) c= R10 & ( Carrier R25 ) c= R10) by L361 , L63;
L363: ( ( Carrier R24 ) \/ ( Carrier R25 ) ) c= R10 by L362 , XBOOLE_1:8;
L364: ( Carrier ( R24 + R25 ) ) c= ( ( Carrier R24 ) \/ ( Carrier R25 ) ) by L352;
thus L365: ( Carrier ( R24 + R25 ) ) c= R10 by L364 , L363 , XBOOLE_1:1;
end;
definition
let R4 being non  empty CLSStruct;
let R10 being (Subset of R4);
let C103 , C104 being (C_Linear_Combination of R10);
redefine func C103 + C104 -> (C_Linear_Combination of R10);

coherence by L360;
end;
theorem
L367: (for B72 being non  empty addLoopStr holds (for B73 , B74 being (C_Linear_Combination of B72) holds ( B73 + B74 ) = ( B74 + B73 )));
theorem
L368: (for R4 being non  empty CLSStruct holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds (for R26 being (C_Linear_Combination of R4) holds ( R24 + ( R25 + R26 ) ) = ( ( R24 + R25 ) + R26 )))))
proof
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
let R26 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L369: ( ( R24 + ( R25 + R26 ) ) . R6 ) = ( ( R24 . R6 ) + ( ( R25 + R26 ) . R6 ) ) by L336
.= ( ( R24 . R6 ) + ( ( R25 . R6 ) + ( R26 . R6 ) ) ) by L336
.= ( ( ( R24 . R6 ) + ( R25 . R6 ) ) + ( R26 . R6 ) )
.= ( ( ( R24 + R25 ) . R6 ) + ( R26 . R6 ) ) by L336
.= ( ( ( R24 + R25 ) + R26 ) . R6 ) by L336;
end;
theorem
L370: (for R4 being non  empty CLSStruct holds (for R23 being (C_Linear_Combination of R4) holds ( R23 + ( ZeroCLC R4 ) ) = R23))
proof
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L371: ( ( R23 + ( ZeroCLC R4 ) ) . R6 ) = ( ( R23 . R6 ) + ( ( ZeroCLC R4 ) . R6 ) ) by L336
.= ( ( R23 . R6 ) + ( 0c ) ) by L60
.= ( R23 . R6 );
end;
definition
let R4 being non  empty CLSStruct;
let C105 being Complex;
let R23 being (C_Linear_Combination of R4);
func C105 * R23 -> (C_Linear_Combination of R4) means 
:L372: (for R6 being (VECTOR of R4) holds ( it . R6 ) = ( C105 * ( R23 . R6 ) ));
existence
proof
reconsider D36 = C105 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
deffunc H5((Element of R4)) = ( D36 * ( R23 . $1 ) );
consider C106 being (Function of (the carrier of R4) , ( COMPLEX )) such that L373: (for B75 being (Element of R4) holds ( C106 . B75 ) = H5(B75)) from FUNCT_2:sch 4;
reconsider D37 = C106 as (Element of ( Funcs ((the carrier of R4) , ( COMPLEX )) )) by FUNCT_2:8;
L374:
now
let R6 being (VECTOR of R4);
assume L375: (not R6 in ( Carrier R23 ));
L376: ( R23 . R6 ) = ( 0c ) by L375;
thus L377: ( D37 . R6 ) = ( D36 * ( 0c ) ) by L376 , L373
.= ( 0c );
end;
reconsider D38 = D37 as (C_Linear_Combination of R4) by L374 , L1;
take D38;
let R6 being (VECTOR of R4);
thus L378: thesis by L373;
end;
uniqueness
proof
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
assume L379: (for R6 being (VECTOR of R4) holds ( R24 . R6 ) = ( C105 * ( R23 . R6 ) ));
assume L380: (for R6 being (VECTOR of R4) holds ( R25 . R6 ) = ( C105 * ( R23 . R6 ) ));
let R6 being (VECTOR of R4);
thus L381: ( R24 . R6 ) = ( C105 * ( R23 . R6 ) ) by L379
.= ( R25 . R6 ) by L380;
end;
end;
theorem
L383: (for R4 being non  empty CLSStruct holds (for R18 being Complex holds (for R23 being (C_Linear_Combination of R4) holds (R18 <> ( 0c ) implies ( Carrier ( R18 * R23 ) ) = ( Carrier R23 )))))
proof
let R4 being non  empty CLSStruct;
let R18 being Complex;
let R23 being (C_Linear_Combination of R4);
set D39 = { R5 where R5 is (VECTOR of R4) : ( ( R18 * R23 ) . R5 ) <> ( 0c ) };
set D40 = { R6 where R6 is (VECTOR of R4) : ( R23 . R6 ) <> ( 0c ) };
assume L384: R18 <> ( 0c );
L385: D39 = D40
proof
thus L386: D39 c= D40
proof
let R14 being set;
assume L387: R14 in D39;
consider R5 being (VECTOR of R4) such that L388: R14 = R5 and L389: ( ( R18 * R23 ) . R5 ) <> ( 0c ) by L387;
L390: ( ( R18 * R23 ) . R5 ) = ( R18 * ( R23 . R5 ) ) by L372;
L391: ( R23 . R5 ) <> ( 0c ) by L390 , L389;
thus L392: thesis by L391 , L388;
end;

let R14 being set;
assume L393: R14 in D40;
consider R6 being (VECTOR of R4) such that L394: (R14 = R6 & ( R23 . R6 ) <> ( 0c )) by L393;
L395: ( ( R18 * R23 ) . R6 ) = ( R18 * ( R23 . R6 ) ) by L372;
thus L396: thesis by L395 , L384 , L394;
end;
thus L397: thesis by L385;
end;
theorem
L398: (for R4 being non  empty CLSStruct holds (for R23 being (C_Linear_Combination of R4) holds ( ( 0c ) * R23 ) = ( ZeroCLC R4 )))
proof
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L399: ( ( ( 0c ) * R23 ) . R6 ) = ( ( 0c ) * ( R23 . R6 ) ) by L372
.= ( ( ZeroCLC R4 ) . R6 ) by L60;
end;
theorem
L400: (for R4 being non  empty CLSStruct holds (for R10 being (Subset of R4) holds (for R18 being Complex holds (for R23 being (C_Linear_Combination of R4) holds (R23 is (C_Linear_Combination of R10) implies ( R18 * R23 ) is (C_Linear_Combination of R10))))))
proof
let R4 being non  empty CLSStruct;
let R10 being (Subset of R4);
let R18 being Complex;
let R23 being (C_Linear_Combination of R4);
assume L401: R23 is (C_Linear_Combination of R10);
L402:
now
assume L403: R18 <> ( 0c );
L404: ( Carrier ( R18 * R23 ) ) = ( Carrier R23 ) by L403 , L383;
thus L405: thesis by L404 , L401 , L63;
end;
L406: (R18 = ( 0c ) implies ( R18 * R23 ) = ( ZeroCLC R4 )) by L398;
thus L407: thesis by L406 , L402 , L72;
end;
theorem
L408: (for R4 being non  empty CLSStruct holds (for R18 being Complex holds (for R19 being Complex holds (for R23 being (C_Linear_Combination of R4) holds ( ( R18 + R19 ) * R23 ) = ( ( R18 * R23 ) + ( R19 * R23 ) )))))
proof
let R4 being non  empty CLSStruct;
let R18 being Complex;
let R19 being Complex;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L409: ( ( ( R18 + R19 ) * R23 ) . R6 ) = ( ( R18 + R19 ) * ( R23 . R6 ) ) by L372
.= ( ( R18 * ( R23 . R6 ) ) + ( R19 * ( R23 . R6 ) ) )
.= ( ( ( R18 * R23 ) . R6 ) + ( R19 * ( R23 . R6 ) ) ) by L372
.= ( ( ( R18 * R23 ) . R6 ) + ( ( R19 * R23 ) . R6 ) ) by L372
.= ( ( ( R18 * R23 ) + ( R19 * R23 ) ) . R6 ) by L336;
end;
theorem
L410: (for R4 being non  empty CLSStruct holds (for R18 being Complex holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ( R18 * ( R24 + R25 ) ) = ( ( R18 * R24 ) + ( R18 * R25 ) )))))
proof
let R4 being non  empty CLSStruct;
let R18 being Complex;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L411: ( ( R18 * ( R24 + R25 ) ) . R6 ) = ( R18 * ( ( R24 + R25 ) . R6 ) ) by L372
.= ( R18 * ( ( R24 . R6 ) + ( R25 . R6 ) ) ) by L336
.= ( ( R18 * ( R24 . R6 ) ) + ( R18 * ( R25 . R6 ) ) )
.= ( ( ( R18 * R24 ) . R6 ) + ( R18 * ( R25 . R6 ) ) ) by L372
.= ( ( ( R18 * R24 ) . R6 ) + ( ( R18 * R25 ) . R6 ) ) by L372
.= ( ( ( R18 * R24 ) + ( R18 * R25 ) ) . R6 ) by L336;
end;
theorem
L412: (for R4 being non  empty CLSStruct holds (for R18 being Complex holds (for R19 being Complex holds (for R23 being (C_Linear_Combination of R4) holds ( R18 * ( R19 * R23 ) ) = ( ( R18 * R19 ) * R23 )))))
proof
let R4 being non  empty CLSStruct;
let R18 being Complex;
let R19 being Complex;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L413: ( ( R18 * ( R19 * R23 ) ) . R6 ) = ( R18 * ( ( R19 * R23 ) . R6 ) ) by L372
.= ( R18 * ( R19 * ( R23 . R6 ) ) ) by L372
.= ( ( R18 * R19 ) * ( R23 . R6 ) )
.= ( ( ( R18 * R19 ) * R23 ) . R6 ) by L372;
end;
theorem
L414: (for R4 being non  empty CLSStruct holds (for R23 being (C_Linear_Combination of R4) holds ( ( 1r ) * R23 ) = R23))
proof
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L415: ( ( ( 1r ) * R23 ) . R6 ) = ( ( 1r ) * ( R23 . R6 ) ) by L372
.= ( R23 . R6 );
end;
definition
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
func - R23 -> (C_Linear_Combination of R4) equals 
( ( - ( 1r ) ) * R23 );
correctness;
end;
theorem
L417: (for R4 being non  empty CLSStruct holds (for R6 being (VECTOR of R4) holds (for R23 being (C_Linear_Combination of R4) holds ( ( - R23 ) . R6 ) = ( - ( R23 . R6 ) ))))
proof
let R4 being non  empty CLSStruct;
let R6 being (VECTOR of R4);
let R23 being (C_Linear_Combination of R4);
thus L418: ( ( - R23 ) . R6 ) = ( ( - ( 1r ) ) * ( R23 . R6 ) ) by L372
.= ( - ( R23 . R6 ) );
end;
theorem
L419: (for R4 being non  empty CLSStruct holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds (( R24 + R25 ) = ( ZeroCLC R4 ) implies R25 = ( - R24 )))))
proof
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
assume L420: ( R24 + R25 ) = ( ZeroCLC R4 );
let R6 being (VECTOR of R4);
L421: ( ( R24 . R6 ) + ( R25 . R6 ) ) = ( ( ZeroCLC R4 ) . R6 ) by L420 , L336
.= ( 0c ) by L60;
thus L422: ( R25 . R6 ) = ( - ( R24 . R6 ) ) by L421
.= ( ( - R24 ) . R6 ) by L417;
end;
theorem
L423: (for R4 being non  empty CLSStruct holds (for R23 being (C_Linear_Combination of R4) holds ( - ( - R23 ) ) = R23))
proof
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L424: ( ( - ( - R23 ) ) . R6 ) = ( ( ( ( - ( 1r ) ) * ( - ( 1r ) ) ) * R23 ) . R6 ) by L412
.= ( ( 1r ) * ( R23 . R6 ) ) by L372
.= ( R23 . R6 );
end;
definition
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
func R24 - R25 -> (C_Linear_Combination of R4) equals 
( R24 + ( - R25 ) );
correctness;
end;
theorem
L426: (for R4 being non  empty CLSStruct holds (for R6 being (VECTOR of R4) holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ( ( R24 - R25 ) . R6 ) = ( ( R24 . R6 ) - ( R25 . R6 ) )))))
proof
let R4 being non  empty CLSStruct;
let R6 being (VECTOR of R4);
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
thus L427: ( ( R24 - R25 ) . R6 ) = ( ( R24 . R6 ) + ( ( - R25 ) . R6 ) ) by L336
.= ( ( R24 . R6 ) - ( R25 . R6 ) ) by L417;
end;
theorem
L428: (for R4 being non  empty CLSStruct holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ( Carrier ( R24 - R25 ) ) c= ( ( Carrier R24 ) \/ ( Carrier R25 ) ))))
proof
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
L429: ( Carrier ( R24 - R25 ) ) c= ( ( Carrier R24 ) \/ ( Carrier ( - R25 ) ) ) by L352;
thus L430: thesis by L429 , L383;
end;
theorem
L431: (for R4 being non  empty CLSStruct holds (for R10 being (Subset of R4) holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ((R24 is (C_Linear_Combination of R10) & R25 is (C_Linear_Combination of R10)) implies ( R24 - R25 ) is (C_Linear_Combination of R10))))))
proof
let R4 being non  empty CLSStruct;
let R10 being (Subset of R4);
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
assume that
L432: R24 is (C_Linear_Combination of R10)
and
L433: R25 is (C_Linear_Combination of R10);
L434: ( - R25 ) is (C_Linear_Combination of R10) by L433 , L400;
thus L435: thesis by L434 , L432 , L360;
end;
theorem
L436: (for R4 being non  empty CLSStruct holds (for R23 being (C_Linear_Combination of R4) holds ( R23 - R23 ) = ( ZeroCLC R4 )))
proof
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
let R6 being (VECTOR of R4);
thus L437: ( ( R23 - R23 ) . R6 ) = ( ( R23 . R6 ) - ( R23 . R6 ) ) by L426
.= ( ( ZeroCLC R4 ) . R6 ) by L60;
end;
definition
let R4 being non  empty CLSStruct;
func C_LinComb R4 -> set means 
:L438: (for R14 being set holds (R14 in it iff R14 is (C_Linear_Combination of R4)));
existence
proof
defpred S3[ set ] means $1 is (C_Linear_Combination of R4);
consider C107 being set such that L439: (for R14 being set holds (R14 in C107 iff (R14 in ( Funcs ((the carrier of R4) , ( COMPLEX )) ) & S3[ R14 ]))) from XBOOLE_0:sch 1;
take C107;
let R14 being set;
thus L440: (R14 in C107 implies R14 is (C_Linear_Combination of R4)) by L439;
assume L441: R14 is (C_Linear_Combination of R4);
thus L442: thesis by L441 , L439;
end;
uniqueness
proof
let C108 , C109 being set;
assume L443: (for R14 being set holds (R14 in C108 iff R14 is (C_Linear_Combination of R4)));
assume L444: (for R14 being set holds (R14 in C109 iff R14 is (C_Linear_Combination of R4)));
thus L445: C108 c= C109
proof
let R14 being set;
assume L446: R14 in C108;
L447: R14 is (C_Linear_Combination of R4) by L446 , L443;
thus L448: thesis by L447 , L444;
end;

let R14 being set;
assume L449: R14 in C109;
L450: R14 is (C_Linear_Combination of R4) by L449 , L444;
thus L451: thesis by L450 , L443;
end;
end;
registration
let R4 being non  empty CLSStruct;
cluster ( C_LinComb R4 ) -> non  empty;
coherence
proof
set D41 = the (C_Linear_Combination of R4);
L453: D41 in ( C_LinComb R4 ) by L438;
thus L454: thesis by L453;
end;
end;
definition
let R4 being non  empty CLSStruct;
let R27 being (Element of ( C_LinComb R4 ));
func @ R27 -> (C_Linear_Combination of R4) equals 
R27;
coherence by L438;
end;
definition
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
func @ R23 -> (Element of ( C_LinComb R4 )) equals 
R23;
coherence by L438;
end;
definition
let R4 being non  empty CLSStruct;
func C_LCAdd R4 -> (BinOp of ( C_LinComb R4 )) means 
:L458: (for R28 being (Element of ( C_LinComb R4 )) holds (for R29 being (Element of ( C_LinComb R4 )) holds ( it . (R28 , R29) ) = ( ( @ R28 ) + ( @ R29 ) )));
existence
proof
deffunc H6((Element of ( C_LinComb R4 )) , (Element of ( C_LinComb R4 ))) = ( @ ( ( @ $1 ) + ( @ $2 ) ) );
consider C110 being (BinOp of ( C_LinComb R4 )) such that L459: (for R28 being (Element of ( C_LinComb R4 )) holds (for R29 being (Element of ( C_LinComb R4 )) holds ( C110 . (R28 , R29) ) = H6(R28 , R29))) from BINOP_1:sch 4;
take C110;
let R28 being (Element of ( C_LinComb R4 ));
let R29 being (Element of ( C_LinComb R4 ));
thus L460: ( C110 . (R28 , R29) ) = ( @ ( ( @ R28 ) + ( @ R29 ) ) ) by L459
.= ( ( @ R28 ) + ( @ R29 ) );
end;
uniqueness
proof
let C111 , C112 being (BinOp of ( C_LinComb R4 ));
assume L461: (for R28 being (Element of ( C_LinComb R4 )) holds (for R29 being (Element of ( C_LinComb R4 )) holds ( C111 . (R28 , R29) ) = ( ( @ R28 ) + ( @ R29 ) )));
assume L462: (for R28 being (Element of ( C_LinComb R4 )) holds (for R29 being (Element of ( C_LinComb R4 )) holds ( C112 . (R28 , R29) ) = ( ( @ R28 ) + ( @ R29 ) )));
L463:
now
let R28 being (Element of ( C_LinComb R4 ));
let R29 being (Element of ( C_LinComb R4 ));
thus L464: ( C111 . (R28 , R29) ) = ( ( @ R28 ) + ( @ R29 ) ) by L461
.= ( C112 . (R28 , R29) ) by L462;
end;
thus L465: thesis by L463 , BINOP_1:2;
end;
end;
definition
let R4 being non  empty CLSStruct;
func C_LCMult R4 -> (Function of [: ( COMPLEX ) , ( C_LinComb R4 ) :] , ( C_LinComb R4 )) means 
:L467: (for R18 being Complex holds (for R27 being (Element of ( C_LinComb R4 )) holds ( it . [ R18 , R27 ] ) = ( R18 * ( @ R27 ) )));
existence
proof
defpred S4[ (Element of ( COMPLEX )) , (Element of ( C_LinComb R4 )) , set ] means (ex R18 being Complex st (R18 = $1 & $3 = ( R18 * ( @ $2 ) )));
L468: (for B76 being (Element of ( COMPLEX )) holds (for R28 being (Element of ( C_LinComb R4 )) holds (ex R29 being (Element of ( C_LinComb R4 )) st S4[ B76 , R28 , R29 ])))
proof
let C113 being (Element of ( COMPLEX ));
let R28 being (Element of ( C_LinComb R4 ));
take ( @ ( C113 * ( @ R28 ) ) );
take C113;
thus L469: thesis;
end;
consider C114 being (Function of [: ( COMPLEX ) , ( C_LinComb R4 ) :] , ( C_LinComb R4 )) such that L470: (for B77 being (Element of ( COMPLEX )) holds (for R27 being (Element of ( C_LinComb R4 )) holds S4[ B77 , R27 , ( C114 . (B77 , R27) ) ])) from BINOP_1:sch 3(L468);
take C114;
let R18 being Complex;
let R27 being (Element of ( C_LinComb R4 ));
L471: R18 in ( COMPLEX ) by XCMPLX_0:def 2;
L472: (ex R19 being Complex st (R19 = R18 & ( C114 . (R18 , R27) ) = ( R19 * ( @ R27 ) ))) by L471 , L470;
thus L473: thesis by L472;
end;
uniqueness
proof
let C115 , C116 being (Function of [: ( COMPLEX ) , ( C_LinComb R4 ) :] , ( C_LinComb R4 ));
assume L474: (for R18 being Complex holds (for R27 being (Element of ( C_LinComb R4 )) holds ( C115 . [ R18 , R27 ] ) = ( R18 * ( @ R27 ) )));
assume L475: (for R18 being Complex holds (for R27 being (Element of ( C_LinComb R4 )) holds ( C116 . [ R18 , R27 ] ) = ( R18 * ( @ R27 ) )));
L476:
now
let C117 being (Element of ( COMPLEX ));
let R27 being (Element of ( C_LinComb R4 ));
thus L477: ( C115 . (C117 , R27) ) = ( C117 * ( @ R27 ) ) by L474
.= ( C116 . (C117 , R27) ) by L475;
end;
thus L478: thesis by L476 , BINOP_1:2;
end;
end;
definition
let R4 being non  empty CLSStruct;
func LC_CLSpace R4 -> ComplexLinearSpace equals 
CLSStruct (# ( C_LinComb R4 ) , ( @ ( ZeroCLC R4 ) ) , ( C_LCAdd R4 ) , ( C_LCMult R4 ) #);
coherence
proof
set D42 = CLSStruct (# ( C_LinComb R4 ) , ( @ ( ZeroCLC R4 ) ) , ( C_LCAdd R4 ) , ( C_LCMult R4 ) #);
L480:
now
let C118 , C119 being Complex;
let C120 , C121 , C122 being (VECTOR of D42);
reconsider D43 = C118 , D44 = C119 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
reconsider D45 = C120 , D46 = C121 , D47 = C122 , D48 = ( C121 + C120 ) , D49 = ( C120 + C122 ) , D50 = ( D43 * C120 ) , D51 = ( D43 * C122 ) , D52 = ( D44 * C120 ) as (Element of ( C_LinComb R4 ));
L481: (( @ D47 ) = C122 & ( @ D48 ) = ( C121 + C120 ));
L482: (( @ D49 ) = ( C120 + C122 ) & ( @ D50 ) = ( C118 * C120 ));
L483: (( @ D51 ) = ( C118 * C122 ) & ( @ D52 ) = ( C119 * C120 ));
L484: (( @ D45 ) = C120 & ( @ D46 ) = C121);
reconsider D53 = C120 , D54 = C121 , D55 = C122 , D56 = ( C121 + C120 ) , D57 = ( C120 + C122 ) , D58 = ( C118 * C120 ) , D59 = ( C118 * C122 ) , D60 = ( C119 * C120 ) as (C_Linear_Combination of R4) by L484 , L481 , L482 , L483;
L485:
now
let C123 , C124 being (VECTOR of D42);
let R22 being (C_Linear_Combination of R4);
let R23 being (C_Linear_Combination of R4);
L486: (( @ ( @ R22 ) ) = R22 & ( @ ( @ R23 ) ) = R23);
assume L487: (C123 = R22 & C124 = R23);
thus L488: ( C123 + C124 ) = ( R22 + R23 ) by L487 , L486 , L458;
end;
thus L489: ( C120 + C122 ) = ( D53 + D55 ) by L485
.= ( C122 + C120 ) by L485;
thus L490: ( ( C121 + C120 ) + C122 ) = ( D56 + D55 ) by L485
.= ( ( D54 + D53 ) + D55 ) by L485
.= ( D54 + ( D53 + D55 ) ) by L368
.= ( D54 + D57 ) by L485
.= ( C121 + ( C120 + C122 ) ) by L485;
thus L491: ( C120 + ( 0. D42 ) ) = ( D53 + ( ZeroCLC R4 ) ) by L485
.= C120 by L370;
L492: ( - D53 ) in (the carrier of D42) by L438;
L493: ( - D53 ) in D42 by L492 , STRUCT_0:def 5;
L494: ( - D53 ) = ( vector (D42 , ( - D53 )) ) by L493 , RLVECT_2:def 1;
L495: ( C120 + ( vector (D42 , ( - D53 )) ) ) = ( D53 - D53 ) by L494 , L485
.= ( 0. D42 ) by L436;
thus L496: (ex B78 being (VECTOR of D42) st ( C120 + B78 ) = ( 0. D42 )) by L495;
L497:
now
let C125 being (VECTOR of D42);
let R23 being (C_Linear_Combination of R4);
let C126 being Complex;
assume L498: C125 = R23;
L499: ( ( C_LCMult R4 ) . [ C126 , C125 ] ) = ( C126 * ( @ ( @ R23 ) ) ) by L498 , L467;
thus L500: ( C126 * C125 ) = ( C126 * R23 ) by L499;
end;
thus L501: ( C118 * ( C120 + C122 ) ) = ( D43 * D57 ) by L497
.= ( D43 * ( D53 + D55 ) ) by L485
.= ( ( D43 * D53 ) + ( D43 * D55 ) ) by L410
.= ( D58 + ( D43 * D55 ) ) by L497
.= ( D58 + D59 ) by L497
.= ( ( C118 * C120 ) + ( C118 * C122 ) ) by L485;
thus L502: ( ( C118 + C119 ) * C120 ) = ( ( D43 + D44 ) * D53 ) by L497
.= ( ( D43 * D53 ) + ( D44 * D53 ) ) by L408
.= ( D58 + ( C119 * D53 ) ) by L497
.= ( D58 + D60 ) by L497
.= ( ( C118 * C120 ) + ( C119 * C120 ) ) by L485;
thus L503: ( ( C118 * C119 ) * C120 ) = ( ( C118 * C119 ) * D53 ) by L497
.= ( D43 * ( D44 * D53 ) ) by L412
.= ( C118 * D60 ) by L497
.= ( C118 * ( C119 * C120 ) ) by L497;
thus L504: ( ( 1r ) * C120 ) = ( ( 1r ) * D53 ) by L497
.= C120 by L414;
end;
L505:
now
let C127 being (Element of D42);
L506: (ex B79 being (VECTOR of D42) st ( C127 + B79 ) = ( 0. D42 )) by L480;
thus L507: C127 is  right_complementable by L506 , ALGSTR_0:def 11;
end;
L508: (for B80 , B81 , B82 being (VECTOR of D42) holds ( ( B80 + B81 ) + B82 ) = ( B80 + ( B81 + B82 ) )) by L480;
thus L509: thesis by L508 , L480 , L505 , ALGSTR_0:def 16 , CLVECT_1:def 2 , CLVECT_1:def 3 , CLVECT_1:def 4 , CLVECT_1:def 5 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
end;
end;
registration
let R4 being non  empty CLSStruct;
cluster ( LC_CLSpace R4 ) ->  strict non  empty;
coherence;
end;
theorem
L512: (for R4 being non  empty CLSStruct holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ( ( vector (( LC_CLSpace R4 ) , R24) ) + ( vector (( LC_CLSpace R4 ) , R25) ) ) = ( R24 + R25 ))))
proof
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
set D61 = ( vector (( LC_CLSpace R4 ) , R25) );
L513: (R24 = ( @ ( @ R24 ) ) & R25 = ( @ ( @ R25 ) ));
L514: R25 in (the carrier of ( LC_CLSpace R4 )) by L438;
L515: R25 in ( LC_CLSpace R4 ) by L514 , STRUCT_0:def 5;
L516: R24 in (the carrier of ( LC_CLSpace R4 )) by L438;
L517: R24 in ( LC_CLSpace R4 ) by L516 , STRUCT_0:def 5;
thus L518: ( ( vector (( LC_CLSpace R4 ) , R24) ) + ( vector (( LC_CLSpace R4 ) , R25) ) ) = ( ( C_LCAdd R4 ) . [ R24 , D61 ] ) by L517 , RLVECT_2:def 1
.= ( ( C_LCAdd R4 ) . (( @ R24 ) , ( @ R25 )) ) by L515 , RLVECT_2:def 1
.= ( R24 + R25 ) by L513 , L458;
end;
theorem
L519: (for R4 being non  empty CLSStruct holds (for R18 being Complex holds (for R23 being (C_Linear_Combination of R4) holds ( R18 * ( vector (( LC_CLSpace R4 ) , R23) ) ) = ( R18 * R23 ))))
proof
let R4 being non  empty CLSStruct;
let R18 being Complex;
let R23 being (C_Linear_Combination of R4);
L520: R23 in (the carrier of ( LC_CLSpace R4 )) by L438;
L521: R23 in ( LC_CLSpace R4 ) by L520 , STRUCT_0:def 5;
L522: ( ( C_LCMult R4 ) . [ R18 , ( vector (( LC_CLSpace R4 ) , R23) ) ] ) = ( ( C_LCMult R4 ) . [ R18 , ( @ R23 ) ] ) by L521 , RLVECT_2:def 1;
L523: ( @ ( @ R23 ) ) = R23;
thus L524: thesis by L523 , L522 , L467;
end;
theorem
L525: (for R4 being non  empty CLSStruct holds (for R23 being (C_Linear_Combination of R4) holds ( - ( vector (( LC_CLSpace R4 ) , R23) ) ) = ( - R23 )))
proof
let R4 being non  empty CLSStruct;
let R23 being (C_Linear_Combination of R4);
thus L526: ( - ( vector (( LC_CLSpace R4 ) , R23) ) ) = ( ( - ( 1r ) ) * ( vector (( LC_CLSpace R4 ) , R23) ) ) by CLVECT_1:3
.= ( - R23 ) by L519;
end;
theorem
L527: (for R4 being non  empty CLSStruct holds (for R24 being (C_Linear_Combination of R4) holds (for R25 being (C_Linear_Combination of R4) holds ( ( vector (( LC_CLSpace R4 ) , R24) ) - ( vector (( LC_CLSpace R4 ) , R25) ) ) = ( R24 - R25 ))))
proof
let R4 being non  empty CLSStruct;
let R24 being (C_Linear_Combination of R4);
let R25 being (C_Linear_Combination of R4);
L528: ( - R25 ) in ( C_LinComb R4 ) by L438;
L529: ( - R25 ) in ( LC_CLSpace R4 ) by L528 , STRUCT_0:def 5;
L530: ( - ( vector (( LC_CLSpace R4 ) , R25) ) ) = ( - R25 ) by L525
.= ( vector (( LC_CLSpace R4 ) , ( - R25 )) ) by L529 , RLVECT_2:def 1;
thus L531: thesis by L530 , L512;
end;
definition
let R4 being non  empty CLSStruct;
let R10 being (Subset of R4);
func LC_CLSpace R10 ->  strict (Subspace of ( LC_CLSpace R4 )) means 
(the carrier of it) = { R11 where R11 is (C_Linear_Combination of R10) : (not contradiction) };
existence
proof
set D62 = { R11 where R11 is (C_Linear_Combination of R10) : (not contradiction) };
L532: D62 c= (the carrier of ( LC_CLSpace R4 ))
proof
let R14 being set;
assume L533: R14 in D62;
L534: (ex R11 being (C_Linear_Combination of R10) st R14 = R11) by L533;
thus L535: thesis by L534 , L438;
end;
reconsider D63 = D62 as (Subset of ( LC_CLSpace R4 )) by L532;
L536: (for B83 , B84 being (VECTOR of ( LC_CLSpace R4 )) holds ((B83 in D63 & B84 in D63) implies ( B83 + B84 ) in D63))
proof
let C128 , C129 being (VECTOR of ( LC_CLSpace R4 ));
assume that
L537: C128 in D63
and
L538: C129 in D63;
consider R12 being (C_Linear_Combination of R10) such that L539: C128 = R12 by L537;
consider R13 being (C_Linear_Combination of R10) such that L540: C129 = R13 by L538;
L541: C129 = ( vector (( LC_CLSpace R4 ) , R13) ) by L540 , RLVECT_2:1;
L542: C128 = ( vector (( LC_CLSpace R4 ) , R12) ) by L539 , RLVECT_2:1;
L543: ( C128 + C129 ) = ( R12 + R13 ) by L542 , L541 , L512;
thus L544: thesis by L543;
end;
L545: ( ZeroCLC R4 ) is (C_Linear_Combination of R10) by L72;
L546: ( ZeroCLC R4 ) in D63 by L545;
L547: (for B85 being Complex holds (for B86 being (VECTOR of ( LC_CLSpace R4 )) holds (B86 in D63 implies ( B85 * B86 ) in D63)))
proof
let C130 being Complex;
let C131 being (VECTOR of ( LC_CLSpace R4 ));
assume L548: C131 in D63;
consider R11 being (C_Linear_Combination of R10) such that L549: C131 = R11 by L548;
L550: ( C130 * C131 ) = ( C130 * ( vector (( LC_CLSpace R4 ) , R11) ) ) by L549 , RLVECT_2:1
.= ( C130 * R11 ) by L519;
L551: ( C130 * C131 ) is (C_Linear_Combination of R10) by L550 , L400;
thus L552: thesis by L551;
end;
L553: D63 is  linearly-closed by L547 , L536 , CLVECT_1:def 7;
thus L554: thesis by L553 , L546 , CLVECT_1:54;
end;
uniqueness by CLVECT_1:49;
end;
begin
definition
let C132 being ComplexLinearSpace;
let C133 being (Subspace of C132);
func Up C133 -> (Subset of C132) equals 
(the carrier of C133);
coherence by CLVECT_1:def 8;
end;
registration
let C134 being ComplexLinearSpace;
let C135 being (Subspace of C134);
cluster ( Up C135 ) -> non  empty;
coherence;
end;
definition
let C136 being non  empty CLSStruct;
let C137 being (Subset of C136);
attr C137 is  Affine
means
:L558: (for B87 , B88 being (VECTOR of C136) holds (for B89 being Complex holds ((B89 is Real & B87 in C137 & B88 in C137) implies ( ( ( ( 1r ) - B89 ) * B87 ) + ( B89 * B88 ) ) in C137)));
end;
definition
let C138 being ComplexLinearSpace;
func (Omega). C138 ->  strict (Subspace of C138) equals 
( the CLSStruct of C138 );
coherence
proof
set D64 = ( the CLSStruct of C138 );
L560: (for B90 , B91 being (VECTOR of D64) holds ( B90 + B91 ) = ( B91 + B90 ))
proof
let C139 , C140 being (VECTOR of D64);
reconsider D65 = C139 , D66 = C140 as (VECTOR of C138);
L561: ( C139 + C140 ) = ( D65 + D66 );
thus L562: ( C139 + C140 ) = ( D66 + D65 ) by L561
.= ( C140 + C139 );
end;
L563: (for B92 , B93 , B94 being (VECTOR of D64) holds ( ( B92 + B93 ) + B94 ) = ( B92 + ( B93 + B94 ) ))
proof
let C141 , C142 , C143 being (VECTOR of D64);
reconsider D67 = C141 , D68 = C142 , D69 = C143 as (VECTOR of C138);
L564: ( ( D67 + D68 ) + D69 ) = ( D67 + ( D68 + D69 ) ) by RLVECT_1:def 3;
thus L565: thesis by L564;
end;
L566: (for B95 being (VECTOR of D64) holds B95 is  right_complementable)
proof
let C144 being (VECTOR of D64);
reconsider D70 = C144 as (VECTOR of C138);
L567: D70 is  right_complementable by ALGSTR_0:def 16;
consider C145 being (VECTOR of C138) such that L568: ( D70 + C145 ) = ( 0. C138 ) by L567 , ALGSTR_0:def 11;
reconsider D71 = C145 as (VECTOR of D64);
take D71;
thus L569: thesis by L568;
end;
L570: (for B96 being (VECTOR of D64) holds ( B96 + ( 0. D64 ) ) = B96)
proof
let C146 being (VECTOR of D64);
reconsider D72 = C146 as (VECTOR of C138);
thus L571: ( C146 + ( 0. D64 ) ) = ( D72 + ( 0. C138 ) )
.= C146 by RLVECT_1:4;
end;
L572: (for R18 being Complex holds (for R19 being Complex holds (for B97 being (VECTOR of D64) holds ( ( R18 * R19 ) * B97 ) = ( R18 * ( R19 * B97 ) ))))
proof
let R18 being Complex;
let R19 being Complex;
let C147 being (VECTOR of D64);
reconsider D73 = C147 as (VECTOR of C138);
L573: ( ( R18 * R19 ) * D73 ) = ( R18 * ( R19 * D73 ) ) by CLVECT_1:def 4;
thus L574: thesis by L573;
end;
L575: (for R18 being Complex holds (for R19 being Complex holds (for B98 being (VECTOR of D64) holds ( ( R18 + R19 ) * B98 ) = ( ( R18 * B98 ) + ( R19 * B98 ) ))))
proof
let R18 being Complex;
let R19 being Complex;
let C148 being (VECTOR of D64);
reconsider D74 = C148 as (VECTOR of C138);
L576: ( ( R18 + R19 ) * D74 ) = ( ( R18 * D74 ) + ( R19 * D74 ) ) by CLVECT_1:def 3;
thus L577: thesis by L576;
end;
L578: (for R18 being Complex holds (for B99 , B100 being (VECTOR of D64) holds ( R18 * ( B99 + B100 ) ) = ( ( R18 * B99 ) + ( R18 * B100 ) )))
proof
let R18 being Complex;
let C149 , C150 being (VECTOR of D64);
reconsider D75 = C149 , D76 = C150 as (VECTOR of C138);
L579: ( R18 * ( D75 + D76 ) ) = ( ( R18 * D75 ) + ( R18 * D76 ) ) by CLVECT_1:def 2;
thus L580: thesis by L579;
end;
L581: (for B101 being (VECTOR of D64) holds ( ( 1r ) * B101 ) = B101)
proof
let C151 being (VECTOR of D64);
reconsider D77 = C151 as (VECTOR of C138);
thus L582: ( ( 1r ) * C151 ) = ( ( 1r ) * D77 )
.= C151 by CLVECT_1:def 5;
end;
reconsider D78 = D64 as ComplexLinearSpace by L581 , L560 , L563 , L570 , L566 , L578 , L575 , L572 , ALGSTR_0:def 16 , CLVECT_1:def 2 , CLVECT_1:def 3 , CLVECT_1:def 4 , CLVECT_1:def 5 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
L583: (the Mult of D78) = ( (the Mult of C138) | [: ( COMPLEX ) , (the carrier of D78) :] ) by RELSET_1:19;
L584: (( 0. D78 ) = ( 0. C138 ) & (the addF of D78) = ( (the addF of C138) || (the carrier of D78) )) by RELSET_1:19;
thus L585: thesis by L584 , L583 , CLVECT_1:def 8;
end;
end;
registration
let C152 being non  empty CLSStruct;
cluster ( [#] C152 ) ->  Affine;
coherence
proof
L587: (for B102 , B103 being (VECTOR of C152) holds (for B104 being Complex holds ((B104 is Real & B102 in ( [#] C152 ) & B103 in ( [#] C152 )) implies ( ( ( ( 1r ) - B104 ) * B102 ) + ( B104 * B103 ) ) in ( [#] C152 ))));
thus L588: thesis by L587 , L558;
end;
cluster  empty ->  Affine for (Subset of C152);
coherence
proof
let C153 being (Subset of C152);
assume L589: C153 is  empty;
L590: (for B105 , B106 being (VECTOR of C152) holds (for B107 being Complex holds ((B107 is Real & B105 in C153 & B106 in C153) implies ( ( ( ( 1r ) - B107 ) * B105 ) + ( B107 * B106 ) ) in C153))) by L589;
thus L591: thesis by L590 , L558;
end;
end;
registration
let C154 being non  empty CLSStruct;
cluster non  empty  Affine for (Subset of C154);
existence
proof
take ( [#] C154 );
thus L593: thesis;
end;
cluster  empty  Affine for (Subset of C154);
existence
proof
take ( {} C154 );
thus L594: thesis;
end;
end;
theorem
L596: (for B108 being  real number holds (for B109 being  complex number holds ( Re ( B108 * B109 ) ) = ( B108 * ( Re B109 ) )))
proof
let C155 being  real number;
let C156 being  complex number;
L597: C155 in ( REAL ) by XREAL_0:def 1;
L598: ( Re ( C155 * C156 ) ) = ( ( ( Re C155 ) * ( Re C156 ) ) - ( ( Im C155 ) * ( Im C156 ) ) ) by COMPLEX1:9
.= ( ( ( Re C155 ) * ( Re C156 ) ) - ( ( 0 ) * ( Im C156 ) ) ) by L597 , COMPLEX1:def 2
.= ( C155 * ( Re C156 ) ) by L597 , COMPLEX1:def 1;
thus L599: thesis by L598;
end;
theorem
L600: (for B110 being  real number holds (for B111 being  complex number holds ( Im ( B110 * B111 ) ) = ( B110 * ( Im B111 ) )))
proof
let C157 being  real number;
let C158 being  complex number;
L601: C157 in ( REAL ) by XREAL_0:def 1;
L602: ( Im ( C157 * C158 ) ) = ( ( ( Re C157 ) * ( Im C158 ) ) + ( ( Re C158 ) * ( Im C157 ) ) ) by COMPLEX1:9
.= ( ( ( Re C157 ) * ( Im C158 ) ) + ( ( Re C158 ) * ( 0 ) ) ) by L601 , COMPLEX1:def 2
.= ( C157 * ( Im C158 ) ) by L601 , COMPLEX1:def 1;
thus L603: thesis by L602;
end;
theorem
L604: (for B112 being  real number holds (for B113 being  complex number holds ((( 0 ) <= B112 & B112 <= 1) implies (|. ( B112 * B113 ) .| = ( B112 * |. B113 .| ) & |. ( ( ( 1r ) - B112 ) * B113 ) .| = ( ( ( 1r ) - B112 ) * |. B113 .| )))))
proof
let C159 being  real number;
let C160 being  complex number;
assume that
L605: ( 0 ) <= C159
and
L606: C159 <= 1;
L607: |. ( ( ( 1r ) - C159 ) * C160 ) .| = ( |. ( ( 1r ) - C159 ) .| * |. C160 .| ) by COMPLEX1:65
.= ( ( ( 1r ) - C159 ) * |. C160 .| ) by L606 , COMPLEX1:43 , XREAL_1:48;
L608: |. ( C159 * C160 ) .| = ( |. C159 .| * |. C160 .| ) by COMPLEX1:65
.= ( C159 * |. C160 .| ) by L605 , COMPLEX1:43;
thus L609: thesis by L608 , L607;
end;
begin
definition
let C161 being non  empty CLSStruct;
let C162 being (Subset of C161);
let C163 being Complex;
func C163 * C162 -> (Subset of C161) equals 
{ ( C163 * B114 ) where B114 is (Element of C161) : B114 in C162 };
coherence
proof
deffunc H7((Element of C161)) = ( C163 * $1 );
defpred S5[ set ] means $1 in C162;
L610: { H7(B115) where B115 is (Element of C161) : S5[ B115 ] } is (Subset of C161) from DOMAIN_1:sch 8;
thus L611: thesis by L610;
end;
end;
definition
let C164 being non  empty CLSStruct;
let C165 being (Subset of C164);
attr C165 is  convex
means
:L613: (for B116 , B117 being (VECTOR of C164) holds (for B118 being Complex holds (((ex B119 being Real st (B118 = B119 & ( 0 ) < B119 & B119 < 1)) & B116 in C165 & B117 in C165) implies ( ( B118 * B116 ) + ( ( ( 1r ) - B118 ) * B117 ) ) in C165)));
end;
theorem
L615: (for B120 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B121 being (Subset of B120) holds (for B122 being Complex holds (B121 is  convex implies ( B122 * B121 ) is  convex))))
proof
let C166 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C167 being (Subset of C166);
let C168 being Complex;
assume L616: C167 is  convex;
L617: (for B123 , B124 being (VECTOR of C166) holds (for B125 being Complex holds (((ex B126 being Real st (B125 = B126 & ( 0 ) < B126 & B126 < 1)) & B123 in ( C168 * C167 ) & B124 in ( C168 * C167 )) implies ( ( B125 * B123 ) + ( ( ( 1r ) - B125 ) * B124 ) ) in ( C168 * C167 ))))
proof
let C169 , C170 being (VECTOR of C166);
let C171 being Complex;
assume that
L618: (ex B127 being Real st (C171 = B127 & ( 0 ) < B127 & B127 < 1))
and
L619: C169 in ( C168 * C167 )
and
L620: C170 in ( C168 * C167 );
consider C172 being (Element of C166) such that L621: C170 = ( C168 * C172 ) and L622: C172 in C167 by L620;
consider C173 being (Element of C166) such that L623: C169 = ( C168 * C173 ) and L624: C173 in C167 by L619;
L625: ( ( C171 * C169 ) + ( ( ( 1r ) - C171 ) * C170 ) ) = ( ( ( C171 * C168 ) * C173 ) + ( ( ( 1r ) - C171 ) * ( C168 * C172 ) ) ) by L623 , L621 , CLVECT_1:def 4
.= ( ( ( C168 * C171 ) * C173 ) + ( ( C168 * ( ( 1r ) - C171 ) ) * C172 ) ) by CLVECT_1:def 4
.= ( ( C168 * ( C171 * C173 ) ) + ( ( C168 * ( ( 1r ) - C171 ) ) * C172 ) ) by CLVECT_1:def 4
.= ( ( C168 * ( C171 * C173 ) ) + ( C168 * ( ( ( 1r ) - C171 ) * C172 ) ) ) by CLVECT_1:def 4
.= ( C168 * ( ( C171 * C173 ) + ( ( ( 1r ) - C171 ) * C172 ) ) ) by CLVECT_1:def 2;
L626: ( ( C171 * C173 ) + ( ( ( 1r ) - C171 ) * C172 ) ) in C167 by L616 , L618 , L624 , L622 , L613;
thus L627: thesis by L626 , L625;
end;
thus L628: thesis by L617 , L613;
end;
theorem
L629: (for B128 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B129 , B130 being (Subset of B128) holds ((B129 is  convex & B130 is  convex) implies ( B129 + B130 ) is  convex)))
proof
let C174 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C175 , C176 being (Subset of C174);
assume L630: (C175 is  convex & C176 is  convex);
L631: (for B131 , B132 being (VECTOR of C174) holds (for B133 being Complex holds (((ex B134 being Real st (B133 = B134 & ( 0 ) < B134 & B134 < 1)) & B131 in ( C175 + C176 ) & B132 in ( C175 + C176 )) implies ( ( B133 * B131 ) + ( ( ( 1r ) - B133 ) * B132 ) ) in ( C175 + C176 ))))
proof
let C177 , C178 being (VECTOR of C174);
let C179 being Complex;
assume that
L632: (ex B135 being Real st (C179 = B135 & ( 0 ) < B135 & B135 < 1))
and
L633: C177 in ( C175 + C176 )
and
L634: C178 in ( C175 + C176 );
consider C180 , C181 being (Element of C174) such that L635: C178 = ( C180 + C181 ) and L636: (C180 in C175 & C181 in C176) by L634;
consider C182 , C183 being (Element of C174) such that L637: C177 = ( C182 + C183 ) and L638: (C182 in C175 & C183 in C176) by L633;
L639: ( ( C179 * C177 ) + ( ( ( 1r ) - C179 ) * C178 ) ) = ( ( ( C179 * C182 ) + ( C179 * C183 ) ) + ( ( ( 1r ) - C179 ) * ( C180 + C181 ) ) ) by L637 , L635 , CLVECT_1:def 2
.= ( ( ( C179 * C182 ) + ( C179 * C183 ) ) + ( ( ( ( 1r ) - C179 ) * C180 ) + ( ( ( 1r ) - C179 ) * C181 ) ) ) by CLVECT_1:def 2
.= ( ( ( ( C179 * C182 ) + ( C179 * C183 ) ) + ( ( ( 1r ) - C179 ) * C180 ) ) + ( ( ( 1r ) - C179 ) * C181 ) ) by RLVECT_1:def 3
.= ( ( ( ( C179 * C182 ) + ( ( ( 1r ) - C179 ) * C180 ) ) + ( C179 * C183 ) ) + ( ( ( 1r ) - C179 ) * C181 ) ) by RLVECT_1:def 3
.= ( ( ( C179 * C182 ) + ( ( ( 1r ) - C179 ) * C180 ) ) + ( ( C179 * C183 ) + ( ( ( 1r ) - C179 ) * C181 ) ) ) by RLVECT_1:def 3;
L640: (( ( C179 * C182 ) + ( ( ( 1r ) - C179 ) * C180 ) ) in C175 & ( ( C179 * C183 ) + ( ( ( 1r ) - C179 ) * C181 ) ) in C176) by L630 , L632 , L638 , L636 , L613;
thus L641: thesis by L640 , L639;
end;
thus L642: thesis by L631 , L613;
end;
theorem
L643: (for B136 being ComplexLinearSpace holds (for B137 , B138 being (Subset of B136) holds ((B137 is  convex & B138 is  convex) implies ( B137 - B138 ) is  convex)))
proof
let C184 being ComplexLinearSpace;
let C185 , C186 being (Subset of C184);
assume L644: (C185 is  convex & C186 is  convex);
L645: (for B139 , B140 being (VECTOR of C184) holds (for B141 being Complex holds (((ex B142 being Real st (B141 = B142 & ( 0 ) < B142 & B142 < 1)) & B139 in ( C185 - C186 ) & B140 in ( C185 - C186 )) implies ( ( B141 * B139 ) + ( ( ( 1r ) - B141 ) * B140 ) ) in ( C185 - C186 ))))
proof
let C187 , C188 being (VECTOR of C184);
let C189 being Complex;
assume that
L646: (ex B143 being Real st (C189 = B143 & ( 0 ) < B143 & B143 < 1))
and
L647: C187 in ( C185 - C186 )
and
L648: C188 in ( C185 - C186 );
consider C190 , C191 being (Element of C184) such that L649: C188 = ( C190 - C191 ) and L650: (C190 in C185 & C191 in C186) by L648;
consider C192 , C193 being (Element of C184) such that L651: C187 = ( C192 - C193 ) and L652: (C192 in C185 & C193 in C186) by L647;
L653: ( ( C189 * C187 ) + ( ( ( 1r ) - C189 ) * C188 ) ) = ( ( ( C189 * C192 ) - ( C189 * C193 ) ) + ( ( ( 1r ) - C189 ) * ( C190 - C191 ) ) ) by L651 , L649 , CLVECT_1:9
.= ( ( ( C189 * C192 ) - ( C189 * C193 ) ) + ( ( ( ( 1r ) - C189 ) * C190 ) - ( ( ( 1r ) - C189 ) * C191 ) ) ) by CLVECT_1:9
.= ( ( ( ( C189 * C192 ) - ( C189 * C193 ) ) + ( ( ( 1r ) - C189 ) * C190 ) ) - ( ( ( 1r ) - C189 ) * C191 ) ) by RLVECT_1:def 3
.= ( ( ( C189 * C192 ) - ( ( C189 * C193 ) - ( ( ( 1r ) - C189 ) * C190 ) ) ) - ( ( ( 1r ) - C189 ) * C191 ) ) by RLVECT_1:29
.= ( ( ( C189 * C192 ) + ( ( ( ( 1r ) - C189 ) * C190 ) + ( - ( C189 * C193 ) ) ) ) - ( ( ( 1r ) - C189 ) * C191 ) ) by RLVECT_1:33
.= ( ( ( ( C189 * C192 ) + ( ( ( 1r ) - C189 ) * C190 ) ) + ( - ( C189 * C193 ) ) ) - ( ( ( 1r ) - C189 ) * C191 ) ) by RLVECT_1:def 3
.= ( ( ( C189 * C192 ) + ( ( ( 1r ) - C189 ) * C190 ) ) + ( ( - ( C189 * C193 ) ) - ( ( ( 1r ) - C189 ) * C191 ) ) ) by RLVECT_1:def 3
.= ( ( ( C189 * C192 ) + ( ( ( 1r ) - C189 ) * C190 ) ) - ( ( C189 * C193 ) + ( ( ( 1r ) - C189 ) * C191 ) ) ) by RLVECT_1:30;
L654: (( ( C189 * C192 ) + ( ( ( 1r ) - C189 ) * C190 ) ) in C185 & ( ( C189 * C193 ) + ( ( ( 1r ) - C189 ) * C191 ) ) in C186) by L644 , L646 , L652 , L650 , L613;
thus L655: thesis by L654 , L653;
end;
thus L656: thesis by L645 , L613;
end;
theorem
L657: (for B144 being non  empty CLSStruct holds (for B145 being (Subset of B144) holds (B145 is  convex iff (for B146 being Complex holds ((ex B147 being Real st (B146 = B147 & ( 0 ) < B147 & B147 < 1)) implies ( ( B146 * B145 ) + ( ( ( 1r ) - B146 ) * B145 ) ) c= B145)))))
proof
let C194 being non  empty CLSStruct;
let C195 being (Subset of C194);
L658: (C195 is  convex implies (for B148 being Complex holds ((ex B149 being Real st (B148 = B149 & ( 0 ) < B149 & B149 < 1)) implies ( ( B148 * C195 ) + ( ( ( 1r ) - B148 ) * C195 ) ) c= C195)))
proof
assume L659: C195 is  convex;
let C196 being Complex;
assume L660: (ex B150 being Real st (C196 = B150 & ( 0 ) < B150 & B150 < 1));
L661: (for B151 being (Element of C194) holds (B151 in ( ( C196 * C195 ) + ( ( ( 1r ) - C196 ) * C195 ) ) implies B151 in C195))
proof
let C197 being (Element of C194);
assume L662: C197 in ( ( C196 * C195 ) + ( ( ( 1r ) - C196 ) * C195 ) );
consider C198 , C199 being (Element of C194) such that L663: C197 = ( C198 + C199 ) and L664: (C198 in ( C196 * C195 ) & C199 in ( ( ( 1r ) - C196 ) * C195 )) by L662;
L665: ((ex B152 being (Element of C194) st (C198 = ( C196 * B152 ) & B152 in C195)) & (ex B153 being (Element of C194) st (C199 = ( ( ( 1r ) - C196 ) * B153 ) & B153 in C195))) by L664;
thus L666: thesis by L665 , L659 , L660 , L663 , L613;
end;
thus L667: thesis by L661 , SUBSET_1:2;
end;
L668: ((for B154 being Complex holds ((ex B155 being Real st (B154 = B155 & ( 0 ) < B155 & B155 < 1)) implies ( ( B154 * C195 ) + ( ( ( 1r ) - B154 ) * C195 ) ) c= C195)) implies C195 is  convex)
proof
assume L669: (for B156 being Complex holds ((ex B157 being Real st (B156 = B157 & ( 0 ) < B157 & B157 < 1)) implies ( ( B156 * C195 ) + ( ( ( 1r ) - B156 ) * C195 ) ) c= C195));
let C200 , C201 being (VECTOR of C194);
let C202 being Complex;
assume L670: (ex B158 being Real st (C202 = B158 & ( 0 ) < B158 & B158 < 1));
L671: ( ( C202 * C195 ) + ( ( ( 1r ) - C202 ) * C195 ) ) c= C195 by L670 , L669;
assume L672: (C200 in C195 & C201 in C195);
L673: (( C202 * C200 ) in ( C202 * C195 ) & ( ( ( 1r ) - C202 ) * C201 ) in ( ( ( 1r ) - C202 ) * C195 )) by L672;
L674: ( ( C202 * C200 ) + ( ( ( 1r ) - C202 ) * C201 ) ) in ( ( C202 * C195 ) + ( ( ( 1r ) - C202 ) * C195 ) ) by L673;
thus L675: thesis by L674 , L671;
end;
thus L676: thesis by L668 , L658;
end;
theorem
L677: (for B159 being  Abelian non  empty CLSStruct holds (for B160 being (Subset of B159) holds (B160 is  convex implies (for B161 being Complex holds ((ex B162 being Real st (B161 = B162 & ( 0 ) < B162 & B162 < 1)) implies ( ( ( ( 1r ) - B161 ) * B160 ) + ( B161 * B160 ) ) c= B160)))))
proof
let C203 being  Abelian non  empty CLSStruct;
let C204 being (Subset of C203);
assume L678: C204 is  convex;
let C205 being Complex;
assume L679: (ex B163 being Real st (C205 = B163 & ( 0 ) < B163 & B163 < 1));
L680: (for B164 being (Element of C203) holds (B164 in ( ( ( ( 1r ) - C205 ) * C204 ) + ( C205 * C204 ) ) implies B164 in C204))
proof
let C206 being (Element of C203);
assume L681: C206 in ( ( ( ( 1r ) - C205 ) * C204 ) + ( C205 * C204 ) );
consider C207 , C208 being (Element of C203) such that L682: C206 = ( C207 + C208 ) and L683: (C207 in ( ( ( 1r ) - C205 ) * C204 ) & C208 in ( C205 * C204 )) by L681;
L684: ((ex B165 being (Element of C203) st (C207 = ( ( ( 1r ) - C205 ) * B165 ) & B165 in C204)) & (ex B166 being (Element of C203) st (C208 = ( C205 * B166 ) & B166 in C204))) by L683;
thus L685: thesis by L684 , L678 , L679 , L682 , L613;
end;
thus L686: thesis by L680 , SUBSET_1:2;
end;
theorem
L687: (for B167 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B168 , B169 being (Subset of B167) holds ((B168 is  convex & B169 is  convex) implies (for B170 being Complex holds ( ( B170 * B168 ) + ( ( ( 1r ) - B170 ) * B169 ) ) is  convex))))
proof
let C209 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C210 , C211 being (Subset of C209);
assume that
L688: C210 is  convex
and
L689: C211 is  convex;
let C212 being Complex;
let C213 , C214 being (VECTOR of C209);
let C215 being Complex;
assume that
L690: (ex B171 being Real st (C215 = B171 & ( 0 ) < B171 & B171 < 1))
and
L691: C213 in ( ( C212 * C210 ) + ( ( ( 1r ) - C212 ) * C211 ) )
and
L692: C214 in ( ( C212 * C210 ) + ( ( ( 1r ) - C212 ) * C211 ) );
consider C216 , C217 being (VECTOR of C209) such that L693: C214 = ( C216 + C217 ) and L694: C216 in ( C212 * C210 ) and L695: C217 in ( ( ( 1r ) - C212 ) * C211 ) by L692;
consider C218 , C219 being (VECTOR of C209) such that L696: C213 = ( C218 + C219 ) and L697: C218 in ( C212 * C210 ) and L698: C219 in ( ( ( 1r ) - C212 ) * C211 ) by L691;
consider C220 being (VECTOR of C209) such that L699: C216 = ( C212 * C220 ) and L700: C220 in C210 by L694;
consider C221 being (VECTOR of C209) such that L701: C218 = ( C212 * C221 ) and L702: C221 in C210 by L697;
L703: ( ( C215 * C218 ) + ( ( ( 1r ) - C215 ) * C216 ) ) = ( ( ( C215 * C212 ) * C221 ) + ( ( ( 1r ) - C215 ) * ( C212 * C220 ) ) ) by L701 , L699 , CLVECT_1:def 4
.= ( ( ( C215 * C212 ) * C221 ) + ( ( ( ( 1r ) - C215 ) * C212 ) * C220 ) ) by CLVECT_1:def 4
.= ( ( C212 * ( C215 * C221 ) ) + ( ( ( ( 1r ) - C215 ) * C212 ) * C220 ) ) by CLVECT_1:def 4
.= ( ( C212 * ( C215 * C221 ) ) + ( C212 * ( ( ( 1r ) - C215 ) * C220 ) ) ) by CLVECT_1:def 4
.= ( C212 * ( ( C215 * C221 ) + ( ( ( 1r ) - C215 ) * C220 ) ) ) by CLVECT_1:def 2;
consider C222 being (VECTOR of C209) such that L704: C217 = ( ( ( 1r ) - C212 ) * C222 ) and L705: C222 in C211 by L695;
consider C223 being (VECTOR of C209) such that L706: C219 = ( ( ( 1r ) - C212 ) * C223 ) and L707: C223 in C211 by L698;
L708: ( ( C215 * C219 ) + ( ( ( 1r ) - C215 ) * C217 ) ) = ( ( ( C215 * ( ( 1r ) - C212 ) ) * C223 ) + ( ( ( 1r ) - C215 ) * ( ( ( 1r ) - C212 ) * C222 ) ) ) by L706 , L704 , CLVECT_1:def 4
.= ( ( ( C215 * ( ( 1r ) - C212 ) ) * C223 ) + ( ( ( ( 1r ) - C215 ) * ( ( 1r ) - C212 ) ) * C222 ) ) by CLVECT_1:def 4
.= ( ( ( ( 1r ) - C212 ) * ( C215 * C223 ) ) + ( ( ( ( 1r ) - C215 ) * ( ( 1r ) - C212 ) ) * C222 ) ) by CLVECT_1:def 4
.= ( ( ( ( 1r ) - C212 ) * ( C215 * C223 ) ) + ( ( ( 1r ) - C212 ) * ( ( ( 1r ) - C215 ) * C222 ) ) ) by CLVECT_1:def 4
.= ( ( ( 1r ) - C212 ) * ( ( C215 * C223 ) + ( ( ( 1r ) - C215 ) * C222 ) ) ) by CLVECT_1:def 2;
L709: ( ( C215 * C223 ) + ( ( ( 1r ) - C215 ) * C222 ) ) in C211 by L689 , L690 , L707 , L705 , L613;
L710: ( ( C215 * C219 ) + ( ( ( 1r ) - C215 ) * C217 ) ) in ( ( ( 1r ) - C212 ) * C211 ) by L709 , L708;
L711: ( ( C215 * C221 ) + ( ( ( 1r ) - C215 ) * C220 ) ) in C210 by L688 , L690 , L702 , L700 , L613;
L712: ( ( C215 * C218 ) + ( ( ( 1r ) - C215 ) * C216 ) ) in ( C212 * C210 ) by L711 , L703;
L713: ( ( C215 * C213 ) + ( ( ( 1r ) - C215 ) * C214 ) ) = ( ( ( C215 * C218 ) + ( C215 * C219 ) ) + ( ( ( 1r ) - C215 ) * ( C216 + C217 ) ) ) by L696 , L693 , CLVECT_1:def 2
.= ( ( ( C215 * C218 ) + ( C215 * C219 ) ) + ( ( ( ( 1r ) - C215 ) * C216 ) + ( ( ( 1r ) - C215 ) * C217 ) ) ) by CLVECT_1:def 2
.= ( ( ( ( C215 * C218 ) + ( C215 * C219 ) ) + ( ( ( 1r ) - C215 ) * C216 ) ) + ( ( ( 1r ) - C215 ) * C217 ) ) by RLVECT_1:def 3
.= ( ( ( ( C215 * C218 ) + ( ( ( 1r ) - C215 ) * C216 ) ) + ( C215 * C219 ) ) + ( ( ( 1r ) - C215 ) * C217 ) ) by RLVECT_1:def 3
.= ( ( ( C215 * C218 ) + ( ( ( 1r ) - C215 ) * C216 ) ) + ( ( C215 * C219 ) + ( ( ( 1r ) - C215 ) * C217 ) ) ) by RLVECT_1:def 3;
thus L714: thesis by L713 , L712 , L710;
end;
theorem
L715: (for B172 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B173 being (Subset of B172) holds ( ( 1r ) * B173 ) = B173))
proof
let C224 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C225 being (Subset of C224);
L716: (for B174 being (Element of C224) holds (B174 in C225 implies B174 in ( ( 1r ) * C225 )))
proof
let C226 being (Element of C224);
L717: C226 = ( ( 1r ) * C226 ) by CLVECT_1:def 5;
assume L718: C226 in C225;
thus L719: thesis by L718 , L717;
end;
L720: C225 c= ( ( 1r ) * C225 ) by L716 , SUBSET_1:2;
L721: (for B175 being (Element of C224) holds (B175 in ( ( 1r ) * C225 ) implies B175 in C225))
proof
let C227 being (Element of C224);
assume L722: C227 in ( ( 1r ) * C225 );
L723: (ex B176 being (Element of C224) st (C227 = ( ( 1r ) * B176 ) & B176 in C225)) by L722;
thus L724: thesis by L723 , CLVECT_1:def 5;
end;
L725: ( ( 1r ) * C225 ) c= C225 by L721 , SUBSET_1:2;
thus L726: thesis by L725 , L720 , XBOOLE_0:def 10;
end;
theorem
L727: (for B177 being ComplexLinearSpace holds (for B178 being non  empty (Subset of B177) holds ( ( 0c ) * B178 ) = { ( 0. B177 ) }))
proof
let C228 being ComplexLinearSpace;
let C229 being non  empty (Subset of C228);
L728: (for B179 being (Element of C228) holds (B179 in { ( 0. C228 ) } implies B179 in ( ( 0c ) * C229 )))
proof
let C230 being (Element of C228);
consider C231 being set such that L729: C231 in C229 by XBOOLE_0:def 1;
reconsider D79 = C231 as (Element of C228) by L729;
assume L730: C230 in { ( 0. C228 ) };
L731: C230 = ( 0. C228 ) by L730 , TARSKI:def 1;
L732: C230 = ( ( 0c ) * D79 ) by L731 , CLVECT_1:1;
thus L733: thesis by L732 , L729;
end;
L734: { ( 0. C228 ) } c= ( ( 0c ) * C229 ) by L728 , SUBSET_1:2;
L735: (for B180 being (Element of C228) holds (B180 in ( ( 0c ) * C229 ) implies B180 in { ( 0. C228 ) }))
proof
let C232 being (Element of C228);
assume L736: C232 in ( ( 0c ) * C229 );
L737: (ex B181 being (Element of C228) st (C232 = ( ( 0c ) * B181 ) & B181 in C229)) by L736;
L738: C232 = ( 0. C228 ) by L737 , CLVECT_1:1;
thus L739: thesis by L738 , TARSKI:def 1;
end;
L740: ( ( 0c ) * C229 ) c= { ( 0. C228 ) } by L735 , SUBSET_1:2;
thus L741: thesis by L740 , L734 , XBOOLE_0:def 10;
end;
theorem
L742: (for B182 being  add-associative non  empty addLoopStr holds (for B183 , B184 , B185 being (Subset of B182) holds ( ( B183 + B184 ) + B185 ) = ( B183 + ( B184 + B185 ) )))
proof
let C233 being  add-associative non  empty addLoopStr;
let C234 , C235 , C236 being (Subset of C233);
L743: (for B186 being (Element of C233) holds (B186 in ( C234 + ( C235 + C236 ) ) implies B186 in ( ( C234 + C235 ) + C236 )))
proof
let C237 being (Element of C233);
assume L744: C237 in ( C234 + ( C235 + C236 ) );
consider C238 , C239 being (Element of C233) such that L745: (C237 = ( C238 + C239 ) & C238 in C234) and L746: C239 in ( C235 + C236 ) by L744;
consider C240 , C241 being (Element of C233) such that L747: (C239 = ( C240 + C241 ) & C240 in C235) and L748: C241 in C236 by L746;
L749: (C237 = ( ( C238 + C240 ) + C241 ) & ( C238 + C240 ) in ( C234 + C235 )) by L745 , L747 , RLVECT_1:def 3;
thus L750: thesis by L749 , L748;
end;
L751: ( C234 + ( C235 + C236 ) ) c= ( ( C234 + C235 ) + C236 ) by L743 , SUBSET_1:2;
L752: (for B187 being (Element of C233) holds (B187 in ( ( C234 + C235 ) + C236 ) implies B187 in ( C234 + ( C235 + C236 ) )))
proof
let C242 being (Element of C233);
assume L753: C242 in ( ( C234 + C235 ) + C236 );
consider C243 , C244 being (Element of C233) such that L754: C242 = ( C243 + C244 ) and L755: C243 in ( C234 + C235 ) and L756: C244 in C236 by L753;
consider C245 , C246 being (Element of C233) such that L757: C243 = ( C245 + C246 ) and L758: C245 in C234 and L759: C246 in C235 by L755;
L760: (C242 = ( C245 + ( C246 + C244 ) ) & ( C246 + C244 ) in ( C235 + C236 )) by L754 , L756 , L757 , L759 , RLVECT_1:def 3;
thus L761: thesis by L760 , L758;
end;
L762: ( ( C234 + C235 ) + C236 ) c= ( C234 + ( C235 + C236 ) ) by L752 , SUBSET_1:2;
thus L763: thesis by L762 , L751 , XBOOLE_0:def 10;
end;
theorem
L764: (for B188 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B189 being (Subset of B188) holds (for B190 , B191 being Complex holds ( B190 * ( B191 * B189 ) ) = ( ( B190 * B191 ) * B189 ))))
proof
let C247 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C248 being (Subset of C247);
let C249 , C250 being Complex;
L765: (for B192 being (VECTOR of C247) holds (B192 in ( C249 * ( C250 * C248 ) ) implies B192 in ( ( C249 * C250 ) * C248 )))
proof
let C251 being (VECTOR of C247);
assume L766: C251 in ( C249 * ( C250 * C248 ) );
consider C252 being (VECTOR of C247) such that L767: C251 = ( C249 * C252 ) and L768: C252 in ( C250 * C248 ) by L766;
consider C253 being (VECTOR of C247) such that L769: C252 = ( C250 * C253 ) and L770: C253 in C248 by L768;
L771: C251 = ( ( C249 * C250 ) * C253 ) by L767 , L769 , CLVECT_1:def 4;
thus L772: thesis by L771 , L770;
end;
L773: ( C249 * ( C250 * C248 ) ) c= ( ( C249 * C250 ) * C248 ) by L765 , SUBSET_1:2;
L774: (for B193 being (VECTOR of C247) holds (B193 in ( ( C249 * C250 ) * C248 ) implies B193 in ( C249 * ( C250 * C248 ) )))
proof
let C254 being (VECTOR of C247);
assume L775: C254 in ( ( C249 * C250 ) * C248 );
consider C255 being (VECTOR of C247) such that L776: (C254 = ( ( C249 * C250 ) * C255 ) & C255 in C248) by L775;
L777: (C254 = ( C249 * ( C250 * C255 ) ) & ( C250 * C255 ) in ( C250 * C248 )) by L776 , CLVECT_1:def 4;
thus L778: thesis by L777;
end;
L779: ( ( C249 * C250 ) * C248 ) c= ( C249 * ( C250 * C248 ) ) by L774 , SUBSET_1:2;
thus L780: thesis by L779 , L773 , XBOOLE_0:def 10;
end;
theorem
L781: (for B194 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B195 , B196 being (Subset of B194) holds (for B197 being Complex holds ( B197 * ( B195 + B196 ) ) = ( ( B197 * B195 ) + ( B197 * B196 ) ))))
proof
let C256 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C257 , C258 being (Subset of C256);
let C259 being Complex;
L782: (for B198 being (VECTOR of C256) holds (B198 in ( ( C259 * C257 ) + ( C259 * C258 ) ) implies B198 in ( C259 * ( C257 + C258 ) )))
proof
let C260 being (VECTOR of C256);
assume L783: C260 in ( ( C259 * C257 ) + ( C259 * C258 ) );
consider C261 , C262 being (VECTOR of C256) such that L784: C260 = ( C261 + C262 ) and L785: C261 in ( C259 * C257 ) and L786: C262 in ( C259 * C258 ) by L783;
consider C263 being (VECTOR of C256) such that L787: C262 = ( C259 * C263 ) and L788: C263 in C258 by L786;
consider C264 being (VECTOR of C256) such that L789: C261 = ( C259 * C264 ) and L790: C264 in C257 by L785;
L791: ( C264 + C263 ) in ( C257 + C258 ) by L790 , L788;
L792: C260 = ( C259 * ( C264 + C263 ) ) by L784 , L789 , L787 , CLVECT_1:def 2;
thus L793: thesis by L792 , L791;
end;
L794: ( ( C259 * C257 ) + ( C259 * C258 ) ) c= ( C259 * ( C257 + C258 ) ) by L782 , SUBSET_1:2;
L795: (for B199 being (VECTOR of C256) holds (B199 in ( C259 * ( C257 + C258 ) ) implies B199 in ( ( C259 * C257 ) + ( C259 * C258 ) )))
proof
let C265 being (VECTOR of C256);
assume L796: C265 in ( C259 * ( C257 + C258 ) );
consider C266 being (VECTOR of C256) such that L797: C265 = ( C259 * C266 ) and L798: C266 in ( C257 + C258 ) by L796;
consider C267 , C268 being (VECTOR of C256) such that L799: C266 = ( C267 + C268 ) and L800: (C267 in C257 & C268 in C258) by L798;
L801: (( C259 * C267 ) in ( C259 * C257 ) & ( C259 * C268 ) in ( C259 * C258 )) by L800;
L802: C265 = ( ( C259 * C267 ) + ( C259 * C268 ) ) by L797 , L799 , CLVECT_1:def 2;
thus L803: thesis by L802 , L801;
end;
L804: ( C259 * ( C257 + C258 ) ) c= ( ( C259 * C257 ) + ( C259 * C258 ) ) by L795 , SUBSET_1:2;
thus L805: thesis by L804 , L794 , XBOOLE_0:def 10;
end;
theorem
L806: (for B200 being ComplexLinearSpace holds (for B201 being (Subset of B200) holds (for B202 being (VECTOR of B200) holds (B201 is  convex iff ( B202 + B201 ) is  convex))))
proof
let C269 being ComplexLinearSpace;
let C270 being (Subset of C269);
let C271 being (VECTOR of C269);
L807: (( C271 + C270 ) is  convex implies C270 is  convex)
proof
assume L808: ( C271 + C270 ) is  convex;
let C272 , C273 being (VECTOR of C269);
let C274 being Complex;
assume that
L809: (ex B203 being Real st (C274 = B203 & ( 0 ) < B203 & B203 < 1))
and
L810: (C272 in C270 & C273 in C270);
set D80 = ( C271 + C272 );
set D81 = ( C271 + C273 );
L811: (D80 in ( C271 + C270 ) & D81 in { ( C271 + B204 ) where B204 is (VECTOR of C269) : B204 in C270 }) by L810;
L812: ( ( C274 * D80 ) + ( ( ( 1r ) - C274 ) * D81 ) ) in ( C271 + C270 ) by L811 , L808 , L809 , L613;
L813: ( ( C274 * D80 ) + ( ( ( 1r ) - C274 ) * D81 ) ) = ( ( ( C274 * C271 ) + ( C274 * C272 ) ) + ( ( ( 1r ) - C274 ) * ( C271 + C273 ) ) ) by CLVECT_1:def 2
.= ( ( ( C274 * C271 ) + ( C274 * C272 ) ) + ( ( ( ( 1r ) - C274 ) * C271 ) + ( ( ( 1r ) - C274 ) * C273 ) ) ) by CLVECT_1:def 2
.= ( ( ( ( C274 * C271 ) + ( C274 * C272 ) ) + ( ( ( 1r ) - C274 ) * C271 ) ) + ( ( ( 1r ) - C274 ) * C273 ) ) by RLVECT_1:def 3
.= ( ( ( ( C274 * C271 ) + ( ( ( 1r ) - C274 ) * C271 ) ) + ( C274 * C272 ) ) + ( ( ( 1r ) - C274 ) * C273 ) ) by RLVECT_1:def 3
.= ( ( ( ( C274 + ( ( 1r ) - C274 ) ) * C271 ) + ( C274 * C272 ) ) + ( ( ( 1r ) - C274 ) * C273 ) ) by CLVECT_1:def 3
.= ( ( C271 + ( C274 * C272 ) ) + ( ( ( 1r ) - C274 ) * C273 ) ) by CLVECT_1:def 5
.= ( C271 + ( ( C274 * C272 ) + ( ( ( 1r ) - C274 ) * C273 ) ) ) by RLVECT_1:def 3;
L814: (ex B205 being (VECTOR of C269) st (( C271 + ( ( C274 * C272 ) + ( ( ( 1r ) - C274 ) * C273 ) ) ) = ( C271 + B205 ) & B205 in C270)) by L813 , L812;
thus L815: thesis by L814 , RLVECT_1:8;
end;
L816: (C270 is  convex implies ( C271 + C270 ) is  convex)
proof
assume L817: C270 is  convex;
let C275 , C276 being (VECTOR of C269);
let C277 being Complex;
assume that
L818: (ex B206 being Real st (C277 = B206 & ( 0 ) < B206 & B206 < 1))
and
L819: C275 in ( C271 + C270 )
and
L820: C276 in ( C271 + C270 );
consider C278 being (VECTOR of C269) such that L821: C276 = ( C271 + C278 ) and L822: C278 in C270 by L820;
consider C279 being (VECTOR of C269) such that L823: C275 = ( C271 + C279 ) and L824: C279 in C270 by L819;
L825: ( ( C277 * C275 ) + ( ( ( 1r ) - C277 ) * C276 ) ) = ( ( ( C277 * C271 ) + ( C277 * C279 ) ) + ( ( ( 1r ) - C277 ) * ( C271 + C278 ) ) ) by L823 , L821 , CLVECT_1:def 2
.= ( ( ( C277 * C271 ) + ( C277 * C279 ) ) + ( ( ( ( 1r ) - C277 ) * C271 ) + ( ( ( 1r ) - C277 ) * C278 ) ) ) by CLVECT_1:def 2
.= ( ( ( ( C277 * C271 ) + ( C277 * C279 ) ) + ( ( ( 1r ) - C277 ) * C271 ) ) + ( ( ( 1r ) - C277 ) * C278 ) ) by RLVECT_1:def 3
.= ( ( ( ( C277 * C271 ) + ( ( ( 1r ) - C277 ) * C271 ) ) + ( C277 * C279 ) ) + ( ( ( 1r ) - C277 ) * C278 ) ) by RLVECT_1:def 3
.= ( ( ( ( C277 + ( ( 1r ) - C277 ) ) * C271 ) + ( C277 * C279 ) ) + ( ( ( 1r ) - C277 ) * C278 ) ) by CLVECT_1:def 3
.= ( ( C271 + ( C277 * C279 ) ) + ( ( ( 1r ) - C277 ) * C278 ) ) by CLVECT_1:def 5
.= ( C271 + ( ( C277 * C279 ) + ( ( ( 1r ) - C277 ) * C278 ) ) ) by RLVECT_1:def 3;
L826: ( ( C277 * C279 ) + ( ( ( 1r ) - C277 ) * C278 ) ) in C270 by L817 , L818 , L824 , L822 , L613;
thus L827: thesis by L826 , L825;
end;
thus L828: thesis by L816 , L807;
end;
theorem
L829: (for B207 being ComplexLinearSpace holds ( Up ( (0). B207 ) ) is  convex)
proof
let C280 being ComplexLinearSpace;
let C281 , C282 being (VECTOR of C280);
let C283 being Complex;
assume that
L830: (ex B208 being Real st (C283 = B208 & ( 0 ) < B208 & B208 < 1))
and
L831: C281 in ( Up ( (0). C280 ) )
and
L832: C282 in ( Up ( (0). C280 ) );
L833: C282 in { ( 0. C280 ) } by L832 , CLVECT_1:def 9;
L834: C282 = ( 0. C280 ) by L833 , TARSKI:def 1;
L835: C281 in { ( 0. C280 ) } by L831 , CLVECT_1:def 9;
L836: C281 = ( 0. C280 ) by L835 , TARSKI:def 1;
L837: ( ( C283 * C281 ) + ( ( ( 1r ) - C283 ) * C282 ) ) = ( ( 0. C280 ) + ( ( ( 1r ) - C283 ) * ( 0. C280 ) ) ) by L836 , L834 , CLVECT_1:1
.= ( ( 0. C280 ) + ( 0. C280 ) ) by CLVECT_1:1
.= ( 0. C280 ) by RLVECT_1:4;
L838: ( ( C283 * C281 ) + ( ( ( 1r ) - C283 ) * C282 ) ) in { ( 0. C280 ) } by L837 , TARSKI:def 1;
thus L839: thesis by L838 , CLVECT_1:def 9;
end;
theorem
L840: (for B209 being ComplexLinearSpace holds ( Up ( (Omega). B209 ) ) is  convex)
proof
let C284 being ComplexLinearSpace;
let C285 , C286 being (VECTOR of C284);
thus L841: thesis;
end;
theorem
L842: (for B210 being non  empty CLSStruct holds (for B211 being (Subset of B210) holds (B211 = ( {} ) implies B211 is  convex)))
proof
let C287 being non  empty CLSStruct;
let C288 being (Subset of C287);
L843: (for B212 , B213 being (VECTOR of C287) holds (for B214 being Complex holds (((ex B215 being Real st (B214 = B215 & ( 0 ) < B215 & B215 < 1)) & B212 in ( {} ) & B213 in ( {} )) implies ( ( B214 * B212 ) + ( ( ( 1r ) - B214 ) * B213 ) ) in ( {} ))));
assume L844: C288 = ( {} );
thus L845: thesis by L844 , L843 , L613;
end;
theorem
L846: (for B216 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B217 , B218 being (Subset of B216) holds (for B219 , B220 being Complex holds ((B217 is  convex & B218 is  convex) implies ( ( B219 * B217 ) + ( B220 * B218 ) ) is  convex))))
proof
let C289 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C290 , C291 being (Subset of C289);
let C292 , C293 being Complex;
assume that
L847: C290 is  convex
and
L848: C291 is  convex;
let C294 , C295 being (VECTOR of C289);
let C296 being Complex;
assume that
L849: (ex B221 being Real st (C296 = B221 & ( 0 ) < B221 & B221 < 1))
and
L850: C294 in ( ( C292 * C290 ) + ( C293 * C291 ) )
and
L851: C295 in ( ( C292 * C290 ) + ( C293 * C291 ) );
consider C297 , C298 being (VECTOR of C289) such that L852: C295 = ( C297 + C298 ) and L853: C297 in ( C292 * C290 ) and L854: C298 in ( C293 * C291 ) by L851;
consider C299 , C300 being (VECTOR of C289) such that L855: C294 = ( C299 + C300 ) and L856: C299 in ( C292 * C290 ) and L857: C300 in ( C293 * C291 ) by L850;
consider C301 being (VECTOR of C289) such that L858: C297 = ( C292 * C301 ) and L859: C301 in C290 by L853;
consider C302 being (VECTOR of C289) such that L860: C299 = ( C292 * C302 ) and L861: C302 in C290 by L856;
L862: ( ( C296 * C299 ) + ( ( ( 1r ) - C296 ) * C297 ) ) = ( ( ( C292 * C296 ) * C302 ) + ( ( ( 1r ) - C296 ) * ( C292 * C301 ) ) ) by L860 , L858 , CLVECT_1:def 4
.= ( ( ( C292 * C296 ) * C302 ) + ( ( C292 * ( ( 1r ) - C296 ) ) * C301 ) ) by CLVECT_1:def 4
.= ( ( C292 * ( C296 * C302 ) ) + ( ( C292 * ( ( 1r ) - C296 ) ) * C301 ) ) by CLVECT_1:def 4
.= ( ( C292 * ( C296 * C302 ) ) + ( C292 * ( ( ( 1r ) - C296 ) * C301 ) ) ) by CLVECT_1:def 4
.= ( C292 * ( ( C296 * C302 ) + ( ( ( 1r ) - C296 ) * C301 ) ) ) by CLVECT_1:def 2;
consider C303 being (VECTOR of C289) such that L863: C298 = ( C293 * C303 ) and L864: C303 in C291 by L854;
consider C304 being (VECTOR of C289) such that L865: C300 = ( C293 * C304 ) and L866: C304 in C291 by L857;
L867: ( ( C296 * C300 ) + ( ( ( 1r ) - C296 ) * C298 ) ) = ( ( ( C293 * C296 ) * C304 ) + ( ( ( 1r ) - C296 ) * ( C293 * C303 ) ) ) by L865 , L863 , CLVECT_1:def 4
.= ( ( ( C293 * C296 ) * C304 ) + ( ( C293 * ( ( 1r ) - C296 ) ) * C303 ) ) by CLVECT_1:def 4
.= ( ( C293 * ( C296 * C304 ) ) + ( ( C293 * ( ( 1r ) - C296 ) ) * C303 ) ) by CLVECT_1:def 4
.= ( ( C293 * ( C296 * C304 ) ) + ( C293 * ( ( ( 1r ) - C296 ) * C303 ) ) ) by CLVECT_1:def 4
.= ( C293 * ( ( C296 * C304 ) + ( ( ( 1r ) - C296 ) * C303 ) ) ) by CLVECT_1:def 2;
L868: ( ( C296 * C304 ) + ( ( ( 1r ) - C296 ) * C303 ) ) in C291 by L848 , L849 , L866 , L864 , L613;
L869: ( ( C296 * C300 ) + ( ( ( 1r ) - C296 ) * C298 ) ) in ( C293 * C291 ) by L868 , L867;
L870: ( ( C296 * C302 ) + ( ( ( 1r ) - C296 ) * C301 ) ) in C290 by L847 , L849 , L861 , L859 , L613;
L871: ( ( C296 * C299 ) + ( ( ( 1r ) - C296 ) * C297 ) ) in ( C292 * C290 ) by L870 , L862;
L872: ( ( C296 * ( C299 + C300 ) ) + ( ( ( 1r ) - C296 ) * ( C297 + C298 ) ) ) = ( ( ( C296 * C299 ) + ( C296 * C300 ) ) + ( ( ( 1r ) - C296 ) * ( C297 + C298 ) ) ) by CLVECT_1:def 2
.= ( ( ( C296 * C299 ) + ( C296 * C300 ) ) + ( ( ( ( 1r ) - C296 ) * C297 ) + ( ( ( 1r ) - C296 ) * C298 ) ) ) by CLVECT_1:def 2
.= ( ( ( ( C296 * C299 ) + ( C296 * C300 ) ) + ( ( ( 1r ) - C296 ) * C297 ) ) + ( ( ( 1r ) - C296 ) * C298 ) ) by RLVECT_1:def 3
.= ( ( ( ( C296 * C299 ) + ( ( ( 1r ) - C296 ) * C297 ) ) + ( C296 * C300 ) ) + ( ( ( 1r ) - C296 ) * C298 ) ) by RLVECT_1:def 3
.= ( ( ( C296 * C299 ) + ( ( ( 1r ) - C296 ) * C297 ) ) + ( ( C296 * C300 ) + ( ( ( 1r ) - C296 ) * C298 ) ) ) by RLVECT_1:def 3;
thus L873: thesis by L872 , L855 , L852 , L871 , L869;
end;
theorem
L874: (for B222 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B223 being (Subset of B222) holds (for B224 , B225 being Complex holds ( ( B224 + B225 ) * B223 ) c= ( ( B224 * B223 ) + ( B225 * B223 ) ))))
proof
let C305 being  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C306 being (Subset of C305);
let C307 , C308 being Complex;
L875: (for B226 being (VECTOR of C305) holds (B226 in ( ( C307 + C308 ) * C306 ) implies B226 in ( ( C307 * C306 ) + ( C308 * C306 ) )))
proof
let C309 being (VECTOR of C305);
assume L876: C309 in ( ( C307 + C308 ) * C306 );
consider C310 being (VECTOR of C305) such that L877: C309 = ( ( C307 + C308 ) * C310 ) and L878: C310 in C306 by L876;
L879: ( C308 * C310 ) in ( C308 * C306 ) by L878;
L880: (C309 = ( ( C307 * C310 ) + ( C308 * C310 ) ) & ( C307 * C310 ) in ( C307 * C306 )) by L877 , L878 , CLVECT_1:def 3;
thus L881: thesis by L880 , L879;
end;
thus L882: thesis by L875 , SUBSET_1:2;
end;
theorem
L883: (for B227 being non  empty CLSStruct holds (for B228 , B229 being (Subset of B227) holds (for B230 being Complex holds (B228 c= B229 implies ( B230 * B228 ) c= ( B230 * B229 )))))
proof
let C311 being non  empty CLSStruct;
let C312 , C313 being (Subset of C311);
let C314 being Complex;
assume L884: C312 c= C313;
L885:
now
let C315 being (VECTOR of C311);
assume L886: C315 in ( C314 * C312 );
L887: (ex B231 being (VECTOR of C311) st (C315 = ( C314 * B231 ) & B231 in C312)) by L886;
thus L888: C315 in ( C314 * C313 ) by L887 , L884;
end;
thus L889: thesis by L885 , SUBSET_1:2;
end;
theorem
L890: (for B232 being non  empty CLSStruct holds (for B233 being  empty (Subset of B232) holds (for B234 being Complex holds ( B234 * B233 ) = ( {} ))))
proof
let C316 being non  empty CLSStruct;
let C317 being  empty (Subset of C316);
let C318 being Complex;
L891:
now
let C319 being (VECTOR of C316);
assume L892: C319 in ( C318 * C317 );
L893: (ex B235 being (VECTOR of C316) st (C319 = ( C318 * B235 ) & B235 in ( {} ))) by L892;
thus L894: C319 in ( {} ) by L893;
end;
L895: ( C318 * C317 ) c= ( {} ) by L891 , SUBSET_1:2;
thus L896: thesis by L895;
end;
theorem
L897: (for B236 being non  empty addLoopStr holds (for B237 being  empty (Subset of B236) holds (for B238 being (Subset of B236) holds ( B237 + B238 ) = ( {} ))))
proof
let C320 being non  empty addLoopStr;
let C321 being  empty (Subset of C320);
let C322 being (Subset of C320);
L898:
now
let C323 being (Element of C320);
assume L899: C323 in ( C321 + C322 );
L900: (ex B239 , B240 being (Element of C320) st (C323 = ( B239 + B240 ) & B239 in ( {} ) & B240 in C322)) by L899;
thus L901: C323 in ( {} ) by L900;
end;
L902: ( C321 + C322 ) c= ( {} ) by L898 , SUBSET_1:2;
thus L903: thesis by L902;
end;
theorem
L904: (for B241 being  right_zeroed non  empty addLoopStr holds (for B242 being (Subset of B241) holds ( B242 + { ( 0. B241 ) } ) = B242))
proof
let C324 being  right_zeroed non  empty addLoopStr;
let C325 being (Subset of C324);
L905: (for B243 being (Element of C324) holds (B243 in ( C325 + { ( 0. C324 ) } ) implies B243 in C325))
proof
let C326 being (Element of C324);
assume L906: C326 in ( C325 + { ( 0. C324 ) } );
consider C327 , C328 being (Element of C324) such that L907: (C326 = ( C327 + C328 ) & C327 in C325) and L908: C328 in { ( 0. C324 ) } by L906;
L909: C328 = ( 0. C324 ) by L908 , TARSKI:def 1;
thus L910: thesis by L909 , L907 , RLVECT_1:def 4;
end;
L911: ( C325 + { ( 0. C324 ) } ) c= C325 by L905 , SUBSET_1:2;
L912: (for B244 being (Element of C324) holds (B244 in C325 implies B244 in ( C325 + { ( 0. C324 ) } )))
proof
let C329 being (Element of C324);
L913: (C329 = ( C329 + ( 0. C324 ) ) & ( 0. C324 ) in { ( 0. C324 ) }) by RLVECT_1:def 4 , TARSKI:def 1;
assume L914: C329 in C325;
thus L915: thesis by L914 , L913;
end;
L916: C325 c= ( C325 + { ( 0. C324 ) } ) by L912 , SUBSET_1:2;
thus L917: thesis by L916 , L911 , XBOOLE_0:def 10;
end;
L918: (for B245 being ComplexLinearSpace holds (for B246 being (Subset of B245) holds (for B247 , B248 being Complex holds (((ex B249 , B250 being Real st (B247 = B249 & B248 = B250 & B249 >= ( 0 ) & B250 >= ( 0 ))) & B246 is  convex) implies ( ( B247 * B246 ) + ( B248 * B246 ) ) c= ( ( B247 + B248 ) * B246 )))))
proof
let C330 being ComplexLinearSpace;
let C331 being (Subset of C330);
let C332 , C333 being Complex;
assume that
L919: (ex B251 , B252 being Real st (C332 = B251 & C333 = B252 & B251 >= ( 0 ) & B252 >= ( 0 )))
and
L920: C331 is  convex;
consider C334 , C335 being Real such that L921: C332 = C334 and L922: C333 = C335 and L923: C334 >= ( 0 ) and L924: C335 >= ( 0 ) by L919;
per cases ;
suppose L925: C331 is  empty;

L926: (( C332 * C331 ) = ( {} ) & ( ( C332 + C333 ) * C331 ) = ( {} )) by L925 , L890;
thus L927: thesis by L926 , L897;
end;
suppose L928: C331 is non  empty;

per cases ;
suppose L929: C332 = ( 0 );

L930: ( C332 * C331 ) = { ( 0. C330 ) } by L929 , L928 , L727;
thus L931: thesis by L930 , L929 , L904;
end;
suppose L932: C333 = ( 0 );

L933: ( C333 * C331 ) = { ( 0. C330 ) } by L932 , L928 , L727;
thus L934: thesis by L933 , L932 , L904;
end;
suppose L935: (C332 <> ( 0 ) & C333 <> ( 0 ));

L936: ( C334 + C335 ) > C334 by L935 , L922 , L924 , XREAL_1:29;
L937: ( C334 / ( C334 + C335 ) ) < 1 by L936 , L923 , XREAL_1:189;
L938: ( ( ( C332 / ( C332 + C333 ) ) * C331 ) + ( ( ( 1r ) - ( C332 / ( C332 + C333 ) ) ) * C331 ) ) c= C331 by L937 , L920 , L921 , L922 , L923 , L924 , L935 , L657;
L939: ( ( C332 + C333 ) * ( ( ( C332 / ( C332 + C333 ) ) * C331 ) + ( ( ( 1r ) - ( C332 / ( C332 + C333 ) ) ) * C331 ) ) ) c= ( ( C332 + C333 ) * C331 ) by L938 , L883;
L940: ( 1 - ( C334 / ( C334 + C335 ) ) ) = ( ( ( C334 + C335 ) / ( C334 + C335 ) ) - ( C334 / ( C334 + C335 ) ) ) by L921 , L923 , L924 , L935 , XCMPLX_1:60;
L941: ( 1 - ( C334 / ( C334 + C335 ) ) ) = ( ( ( C334 + C335 ) - C334 ) / ( C334 + C335 ) ) by L940;
L942: ( ( C332 + C333 ) * ( ( ( 1r ) - ( C332 / ( C332 + C333 ) ) ) * C331 ) ) = ( ( ( C333 / ( C332 + C333 ) ) * ( C332 + C333 ) ) * C331 ) by L941 , L921 , L922 , L764
.= ( C333 * C331 ) by L921 , L922 , L923 , L924 , L935 , XCMPLX_1:87;
L943: ( ( C332 + C333 ) * ( ( C332 / ( C332 + C333 ) ) * C331 ) ) = ( ( ( C332 / ( C332 + C333 ) ) * ( C332 + C333 ) ) * C331 ) by L764
.= ( C332 * C331 ) by L921 , L922 , L923 , L924 , L935 , XCMPLX_1:87;
thus L944: thesis by L943 , L939 , L942 , L781;
end;
end;
end;
theorem
L947: (for B253 being ComplexLinearSpace holds (for B254 being (Subset of B253) holds (for B255 , B256 being Complex holds (((ex B257 , B258 being Real st (B255 = B257 & B256 = B258 & B257 >= ( 0 ) & B258 >= ( 0 ))) & B254 is  convex) implies ( ( B255 * B254 ) + ( B256 * B254 ) ) = ( ( B255 + B256 ) * B254 )))))
proof
let C336 being ComplexLinearSpace;
let C337 being (Subset of C336);
let C338 , C339 being Complex;
assume L948: ((ex B259 , B260 being Real st (C338 = B259 & C339 = B260 & B259 >= ( 0 ) & B260 >= ( 0 ))) & C337 is  convex);
thus L949: ( ( C338 * C337 ) + ( C339 * C337 ) ) c= ( ( C338 + C339 ) * C337 ) by L948 , L918;
thus L950: thesis by L874;
end;
theorem
L951: (for B261 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct holds (for B262 , B263 , B264 being (Subset of B261) holds (for B265 , B266 , B267 being Complex holds ((B262 is  convex & B263 is  convex & B264 is  convex) implies ( ( ( B265 * B262 ) + ( B266 * B263 ) ) + ( B267 * B264 ) ) is  convex))))
proof
let C340 being  Abelian  add-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty CLSStruct;
let C341 , C342 , C343 being (Subset of C340);
let C344 , C345 , C346 being Complex;
assume that
L952: (C341 is  convex & C342 is  convex)
and
L953: C343 is  convex;
L954: ( ( C344 * C341 ) + ( C345 * C342 ) ) is  convex by L952 , L846;
L955: ( ( ( 1r ) * ( ( C344 * C341 ) + ( C345 * C342 ) ) ) + ( C346 * C343 ) ) is  convex by L954 , L953 , L846;
thus L956: thesis by L955 , L715;
end;
theorem
L957: (for B268 being non  empty CLSStruct holds (for B269 being (Subset-Family of B268) holds ((for B270 being (Subset of B268) holds (B270 in B269 implies B270 is  convex)) implies ( meet B269 ) is  convex)))
proof
let C347 being non  empty CLSStruct;
let C348 being (Subset-Family of C347);
assume L958: (for B271 being (Subset of C347) holds (B271 in C348 implies B271 is  convex));
per cases ;
suppose L959: C348 = ( {} );

L960: ( meet C348 ) = ( {} ) by L959 , SETFAM_1:def 1;
thus L961: thesis by L960 , L842;
end;
suppose L962: C348 <> ( {} );

thus L963: ( meet C348 ) is  convex
proof
let C349 , C350 being (VECTOR of C347);
let C351 being Complex;
assume that
L964: (ex B272 being Real st (C351 = B272 & ( 0 ) < B272 & B272 < 1))
and
L965: C349 in ( meet C348 )
and
L966: C350 in ( meet C348 );
L967: (for B273 being set holds (B273 in C348 implies ( ( C351 * C349 ) + ( ( ( 1r ) - C351 ) * C350 ) ) in B273))
proof
let C352 being set;
assume L968: C352 in C348;
reconsider D82 = C352 as (Subset of C347) by L968;
L969: C350 in D82 by L966 , L968 , SETFAM_1:def 1;
L970: (D82 is  convex & C349 in D82) by L958 , L965 , L968 , SETFAM_1:def 1;
thus L971: thesis by L970 , L964 , L969 , L613;
end;
thus L972: thesis by L967 , L962 , SETFAM_1:def 1;
end;

end;
end;
theorem
L965: (for B274 being non  empty CLSStruct holds (for B275 being (Subset of B274) holds (B275 is  Affine implies B275 is  convex)))
proof
let C353 being non  empty CLSStruct;
let C354 being (Subset of C353);
assume L966: C354 is  Affine;
let C355 , C356 being (VECTOR of C353);
let C357 being Complex;
assume that
L967: (ex B276 being Real st (C357 = B276 & ( 0 ) < B276 & B276 < 1))
and
L968: (C355 in C354 & C356 in C354);
set D83 = ( ( 1r ) - C357 );
consider C358 being Real such that L969: C357 = C358 and L970: ( 0 ) < C358 and L971: C358 < 1 by L967;
L972: D83 = ( 1 - C358 ) by L969;
L973: ( ( ( ( 1r ) - D83 ) * C355 ) + ( D83 * C356 ) ) in C354 by L972 , L966 , L968 , L558;
thus L974: thesis by L973;
end;
registration
let C359 being non  empty CLSStruct;
cluster non  empty  convex for (Subset of C359);
existence
proof
set D84 = the non  empty  Affine (Subset of C359);
L975: D84 is  convex by L965;
thus L976: thesis by L975;
end;
end;
registration
let C360 being non  empty CLSStruct;
cluster  empty  convex for (Subset of C360);
existence
proof
L978: ( {} C360 ) is  convex by L842;
thus L979: thesis by L978;
end;
end;
theorem
L981: (for B277 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B278 being (Subset of B277) holds (for B279 being (VECTOR of B277) holds (for B280 being Real holds (B278 = { B281 where B281 is (VECTOR of B277) : ( Re ( B281 .|. B279 ) ) >= B280 } implies B278 is  convex)))))
proof
let C361 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C362 being (Subset of C361);
let C363 being (VECTOR of C361);
let C364 being Real;
assume L982: C362 = { B282 where B282 is (VECTOR of C361) : ( Re ( B282 .|. C363 ) ) >= C364 };
let C365 , C366 being (VECTOR of C361);
let C367 being Complex;
assume that
L983: (ex B283 being Real st (C367 = B283 & ( 0 ) < B283 & B283 < 1))
and
L984: C365 in C362
and
L985: C366 in C362;
L986: (ex B284 being (VECTOR of C361) st (C366 = B284 & ( Re ( B284 .|. C363 ) ) >= C364)) by L982 , L985;
consider C368 being Real such that L987: C367 = C368 and L988: ( 0 ) < C368 and L989: C368 < 1 by L983;
L990: ( 1 - C368 ) > ( 0 ) by L989 , XREAL_1:50;
L991: ( ( 1 - C368 ) * ( Re ( C366 .|. C363 ) ) ) >= ( ( 1 - C368 ) * C364 ) by L990 , L986 , XREAL_1:64;
L992: (ex B285 being (VECTOR of C361) st (C365 = B285 & ( Re ( B285 .|. C363 ) ) >= C364)) by L982 , L984;
L993: ( C368 * ( Re ( C365 .|. C363 ) ) ) >= ( C368 * C364 ) by L992 , L988 , XREAL_1:64;
L994: ( ( C368 * ( Re ( C365 .|. C363 ) ) ) + ( ( 1 - C368 ) * ( Re ( C366 .|. C363 ) ) ) ) >= ( ( C368 * C364 ) + ( ( 1 - C368 ) * C364 ) ) by L993 , L991 , XREAL_1:7;
L995: ( Re ( ( ( C367 * C365 ) + ( ( ( 1r ) - C367 ) * C366 ) ) .|. C363 ) ) = ( Re ( ( ( C367 * C365 ) .|. C363 ) + ( ( ( ( 1r ) - C367 ) * C366 ) .|. C363 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C367 * ( C365 .|. C363 ) ) + ( ( ( ( 1r ) - C367 ) * C366 ) .|. C363 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C367 * ( C365 .|. C363 ) ) + ( ( ( 1r ) - C367 ) * ( C366 .|. C363 ) ) ) ) by CSSPACE:def 13
.= ( ( Re ( C367 * ( C365 .|. C363 ) ) ) + ( Re ( ( ( 1r ) - C367 ) * ( C366 .|. C363 ) ) ) ) by COMPLEX1:8
.= ( ( C368 * ( Re ( C365 .|. C363 ) ) ) + ( Re ( ( ( 1r ) - C367 ) * ( C366 .|. C363 ) ) ) ) by L987 , L596
.= ( ( C368 * ( Re ( C365 .|. C363 ) ) ) + ( ( 1 - C368 ) * ( Re ( C366 .|. C363 ) ) ) ) by L987 , L596;
thus L996: thesis by L995 , L982 , L994;
end;
theorem
L997: (for B286 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B287 being (Subset of B286) holds (for B288 being (VECTOR of B286) holds (for B289 being Real holds (B287 = { B290 where B290 is (VECTOR of B286) : ( Re ( B290 .|. B288 ) ) > B289 } implies B287 is  convex)))))
proof
let C369 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C370 being (Subset of C369);
let C371 being (VECTOR of C369);
let C372 being Real;
assume L998: C370 = { B291 where B291 is (VECTOR of C369) : ( Re ( B291 .|. C371 ) ) > C372 };
let C373 , C374 being (VECTOR of C369);
let C375 being Complex;
assume that
L999: (ex B292 being Real st (C375 = B292 & ( 0 ) < B292 & B292 < 1))
and
L1000: C373 in C370
and
L1001: C374 in C370;
L1002: (ex B293 being (VECTOR of C369) st (C374 = B293 & ( Re ( B293 .|. C371 ) ) > C372)) by L998 , L1001;
consider C376 being Real such that L1003: C375 = C376 and L1004: ( 0 ) < C376 and L1005: C376 < 1 by L999;
L1006: ( 1 - C376 ) > ( 0 ) by L1005 , XREAL_1:50;
L1007: ( ( 1 - C376 ) * ( Re ( C374 .|. C371 ) ) ) > ( ( 1 - C376 ) * C372 ) by L1006 , L1002 , XREAL_1:68;
L1008: (ex B294 being (VECTOR of C369) st (C373 = B294 & ( Re ( B294 .|. C371 ) ) > C372)) by L998 , L1000;
L1009: ( C376 * ( Re ( C373 .|. C371 ) ) ) > ( C376 * C372 ) by L1008 , L1004 , XREAL_1:68;
L1010: ( ( C376 * ( Re ( C373 .|. C371 ) ) ) + ( ( 1 - C376 ) * ( Re ( C374 .|. C371 ) ) ) ) > ( ( C376 * C372 ) + ( ( 1 - C376 ) * C372 ) ) by L1009 , L1007 , XREAL_1:8;
L1011: ( Re ( ( ( C375 * C373 ) + ( ( ( 1r ) - C375 ) * C374 ) ) .|. C371 ) ) = ( Re ( ( ( C375 * C373 ) .|. C371 ) + ( ( ( ( 1r ) - C375 ) * C374 ) .|. C371 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C375 * ( C373 .|. C371 ) ) + ( ( ( ( 1r ) - C375 ) * C374 ) .|. C371 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C375 * ( C373 .|. C371 ) ) + ( ( ( 1r ) - C375 ) * ( C374 .|. C371 ) ) ) ) by CSSPACE:def 13
.= ( ( Re ( C375 * ( C373 .|. C371 ) ) ) + ( Re ( ( ( 1r ) - C375 ) * ( C374 .|. C371 ) ) ) ) by COMPLEX1:8
.= ( ( C376 * ( Re ( C373 .|. C371 ) ) ) + ( Re ( ( ( 1r ) - C375 ) * ( C374 .|. C371 ) ) ) ) by L1003 , L596
.= ( ( C376 * ( Re ( C373 .|. C371 ) ) ) + ( ( 1 - C376 ) * ( Re ( C374 .|. C371 ) ) ) ) by L1003 , L596;
thus L1012: thesis by L1011 , L998 , L1010;
end;
theorem
L1013: (for B295 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B296 being (Subset of B295) holds (for B297 being (VECTOR of B295) holds (for B298 being Real holds (B296 = { B299 where B299 is (VECTOR of B295) : ( Re ( B299 .|. B297 ) ) <= B298 } implies B296 is  convex)))))
proof
let C377 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C378 being (Subset of C377);
let C379 being (VECTOR of C377);
let C380 being Real;
assume L1014: C378 = { B300 where B300 is (VECTOR of C377) : ( Re ( B300 .|. C379 ) ) <= C380 };
let C381 , C382 being (VECTOR of C377);
let C383 being Complex;
assume that
L1015: (ex B301 being Real st (C383 = B301 & ( 0 ) < B301 & B301 < 1))
and
L1016: C381 in C378
and
L1017: C382 in C378;
L1018: (ex B302 being (VECTOR of C377) st (C382 = B302 & ( Re ( B302 .|. C379 ) ) <= C380)) by L1014 , L1017;
consider C384 being Real such that L1019: C383 = C384 and L1020: ( 0 ) < C384 and L1021: C384 < 1 by L1015;
L1022: ( 1 - C384 ) > ( 0 ) by L1021 , XREAL_1:50;
L1023: ( ( 1 - C384 ) * ( Re ( C382 .|. C379 ) ) ) <= ( ( 1 - C384 ) * C380 ) by L1022 , L1018 , XREAL_1:64;
L1024: (ex B303 being (VECTOR of C377) st (C381 = B303 & ( Re ( B303 .|. C379 ) ) <= C380)) by L1014 , L1016;
L1025: ( C384 * ( Re ( C381 .|. C379 ) ) ) <= ( C384 * C380 ) by L1024 , L1020 , XREAL_1:64;
L1026: ( ( C384 * ( Re ( C381 .|. C379 ) ) ) + ( ( 1 - C384 ) * ( Re ( C382 .|. C379 ) ) ) ) <= ( ( C384 * C380 ) + ( ( 1 - C384 ) * C380 ) ) by L1025 , L1023 , XREAL_1:7;
L1027: ( Re ( ( ( C383 * C381 ) + ( ( ( 1r ) - C383 ) * C382 ) ) .|. C379 ) ) = ( Re ( ( ( C383 * C381 ) .|. C379 ) + ( ( ( ( 1r ) - C383 ) * C382 ) .|. C379 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C383 * ( C381 .|. C379 ) ) + ( ( ( ( 1r ) - C383 ) * C382 ) .|. C379 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C383 * ( C381 .|. C379 ) ) + ( ( ( 1r ) - C383 ) * ( C382 .|. C379 ) ) ) ) by CSSPACE:def 13
.= ( ( Re ( C383 * ( C381 .|. C379 ) ) ) + ( Re ( ( ( 1r ) - C383 ) * ( C382 .|. C379 ) ) ) ) by COMPLEX1:8
.= ( ( C384 * ( Re ( C381 .|. C379 ) ) ) + ( Re ( ( ( 1r ) - C383 ) * ( C382 .|. C379 ) ) ) ) by L1019 , L596
.= ( ( C384 * ( Re ( C381 .|. C379 ) ) ) + ( ( 1 - C384 ) * ( Re ( C382 .|. C379 ) ) ) ) by L1019 , L596;
thus L1028: thesis by L1027 , L1014 , L1026;
end;
theorem
L1029: (for B304 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B305 being (Subset of B304) holds (for B306 being (VECTOR of B304) holds (for B307 being Real holds (B305 = { B308 where B308 is (VECTOR of B304) : ( Re ( B308 .|. B306 ) ) < B307 } implies B305 is  convex)))))
proof
let C385 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C386 being (Subset of C385);
let C387 being (VECTOR of C385);
let C388 being Real;
assume L1030: C386 = { B309 where B309 is (VECTOR of C385) : ( Re ( B309 .|. C387 ) ) < C388 };
let C389 , C390 being (VECTOR of C385);
let C391 being Complex;
assume that
L1031: (ex B310 being Real st (C391 = B310 & ( 0 ) < B310 & B310 < 1))
and
L1032: C389 in C386
and
L1033: C390 in C386;
L1034: (ex B311 being (VECTOR of C385) st (C390 = B311 & ( Re ( B311 .|. C387 ) ) < C388)) by L1030 , L1033;
consider C392 being Real such that L1035: C391 = C392 and L1036: ( 0 ) < C392 and L1037: C392 < 1 by L1031;
L1038: ( 1 - C392 ) > ( 0 ) by L1037 , XREAL_1:50;
L1039: ( ( 1 - C392 ) * ( Re ( C390 .|. C387 ) ) ) < ( ( 1 - C392 ) * C388 ) by L1038 , L1034 , XREAL_1:68;
L1040: (ex B312 being (VECTOR of C385) st (C389 = B312 & ( Re ( B312 .|. C387 ) ) < C388)) by L1030 , L1032;
L1041: ( C392 * ( Re ( C389 .|. C387 ) ) ) < ( C392 * C388 ) by L1040 , L1036 , XREAL_1:68;
L1042: ( ( C392 * ( Re ( C389 .|. C387 ) ) ) + ( ( 1 - C392 ) * ( Re ( C390 .|. C387 ) ) ) ) < ( ( C392 * C388 ) + ( ( 1 - C392 ) * C388 ) ) by L1041 , L1039 , XREAL_1:8;
L1043: ( Re ( ( ( C391 * C389 ) + ( ( ( 1r ) - C391 ) * C390 ) ) .|. C387 ) ) = ( Re ( ( ( C391 * C389 ) .|. C387 ) + ( ( ( ( 1r ) - C391 ) * C390 ) .|. C387 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C391 * ( C389 .|. C387 ) ) + ( ( ( ( 1r ) - C391 ) * C390 ) .|. C387 ) ) ) by CSSPACE:def 13
.= ( Re ( ( C391 * ( C389 .|. C387 ) ) + ( ( ( 1r ) - C391 ) * ( C390 .|. C387 ) ) ) ) by CSSPACE:def 13
.= ( ( Re ( C391 * ( C389 .|. C387 ) ) ) + ( Re ( ( ( 1r ) - C391 ) * ( C390 .|. C387 ) ) ) ) by COMPLEX1:8
.= ( ( C392 * ( Re ( C389 .|. C387 ) ) ) + ( Re ( ( ( 1r ) - C391 ) * ( C390 .|. C387 ) ) ) ) by L1035 , L596
.= ( ( C392 * ( Re ( C389 .|. C387 ) ) ) + ( ( 1 - C392 ) * ( Re ( C390 .|. C387 ) ) ) ) by L1035 , L596;
thus L1044: thesis by L1043 , L1030 , L1042;
end;
theorem
L1045: (for B313 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B314 being (Subset of B313) holds (for B315 being (VECTOR of B313) holds (for B316 being Real holds (B314 = { B317 where B317 is (VECTOR of B313) : ( Im ( B317 .|. B315 ) ) >= B316 } implies B314 is  convex)))))
proof
let C393 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C394 being (Subset of C393);
let C395 being (VECTOR of C393);
let C396 being Real;
assume L1046: C394 = { B318 where B318 is (VECTOR of C393) : ( Im ( B318 .|. C395 ) ) >= C396 };
let C397 , C398 being (VECTOR of C393);
let C399 being Complex;
assume that
L1047: (ex B319 being Real st (C399 = B319 & ( 0 ) < B319 & B319 < 1))
and
L1048: C397 in C394
and
L1049: C398 in C394;
L1050: (ex B320 being (VECTOR of C393) st (C398 = B320 & ( Im ( B320 .|. C395 ) ) >= C396)) by L1046 , L1049;
consider C400 being Real such that L1051: C399 = C400 and L1052: ( 0 ) < C400 and L1053: C400 < 1 by L1047;
L1054: ( 1 - C400 ) > ( 0 ) by L1053 , XREAL_1:50;
L1055: ( ( 1 - C400 ) * ( Im ( C398 .|. C395 ) ) ) >= ( ( 1 - C400 ) * C396 ) by L1054 , L1050 , XREAL_1:64;
L1056: (ex B321 being (VECTOR of C393) st (C397 = B321 & ( Im ( B321 .|. C395 ) ) >= C396)) by L1046 , L1048;
L1057: ( C400 * ( Im ( C397 .|. C395 ) ) ) >= ( C400 * C396 ) by L1056 , L1052 , XREAL_1:64;
L1058: ( ( C400 * ( Im ( C397 .|. C395 ) ) ) + ( ( 1 - C400 ) * ( Im ( C398 .|. C395 ) ) ) ) >= ( ( C400 * C396 ) + ( ( 1 - C400 ) * C396 ) ) by L1057 , L1055 , XREAL_1:7;
L1059: ( Im ( ( ( C399 * C397 ) + ( ( ( 1r ) - C399 ) * C398 ) ) .|. C395 ) ) = ( Im ( ( ( C399 * C397 ) .|. C395 ) + ( ( ( ( 1r ) - C399 ) * C398 ) .|. C395 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C399 * ( C397 .|. C395 ) ) + ( ( ( ( 1r ) - C399 ) * C398 ) .|. C395 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C399 * ( C397 .|. C395 ) ) + ( ( ( 1r ) - C399 ) * ( C398 .|. C395 ) ) ) ) by CSSPACE:def 13
.= ( ( Im ( C399 * ( C397 .|. C395 ) ) ) + ( Im ( ( ( 1r ) - C399 ) * ( C398 .|. C395 ) ) ) ) by COMPLEX1:8
.= ( ( C400 * ( Im ( C397 .|. C395 ) ) ) + ( Im ( ( ( 1r ) - C399 ) * ( C398 .|. C395 ) ) ) ) by L1051 , L600
.= ( ( C400 * ( Im ( C397 .|. C395 ) ) ) + ( ( 1 - C400 ) * ( Im ( C398 .|. C395 ) ) ) ) by L1051 , L600;
thus L1060: thesis by L1059 , L1046 , L1058;
end;
theorem
L1061: (for B322 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B323 being (Subset of B322) holds (for B324 being (VECTOR of B322) holds (for B325 being Real holds (B323 = { B326 where B326 is (VECTOR of B322) : ( Im ( B326 .|. B324 ) ) > B325 } implies B323 is  convex)))))
proof
let C401 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C402 being (Subset of C401);
let C403 being (VECTOR of C401);
let C404 being Real;
assume L1062: C402 = { B327 where B327 is (VECTOR of C401) : ( Im ( B327 .|. C403 ) ) > C404 };
let C405 , C406 being (VECTOR of C401);
let C407 being Complex;
assume that
L1063: (ex B328 being Real st (C407 = B328 & ( 0 ) < B328 & B328 < 1))
and
L1064: C405 in C402
and
L1065: C406 in C402;
L1066: (ex B329 being (VECTOR of C401) st (C406 = B329 & ( Im ( B329 .|. C403 ) ) > C404)) by L1062 , L1065;
consider C408 being Real such that L1067: C407 = C408 and L1068: ( 0 ) < C408 and L1069: C408 < 1 by L1063;
L1070: ( 1 - C408 ) > ( 0 ) by L1069 , XREAL_1:50;
L1071: ( ( 1 - C408 ) * ( Im ( C406 .|. C403 ) ) ) > ( ( 1 - C408 ) * C404 ) by L1070 , L1066 , XREAL_1:68;
L1072: (ex B330 being (VECTOR of C401) st (C405 = B330 & ( Im ( B330 .|. C403 ) ) > C404)) by L1062 , L1064;
L1073: ( C408 * ( Im ( C405 .|. C403 ) ) ) > ( C408 * C404 ) by L1072 , L1068 , XREAL_1:68;
L1074: ( ( C408 * ( Im ( C405 .|. C403 ) ) ) + ( ( 1 - C408 ) * ( Im ( C406 .|. C403 ) ) ) ) > ( ( C408 * C404 ) + ( ( 1 - C408 ) * C404 ) ) by L1073 , L1071 , XREAL_1:8;
L1075: ( Im ( ( ( C407 * C405 ) + ( ( ( 1r ) - C407 ) * C406 ) ) .|. C403 ) ) = ( Im ( ( ( C407 * C405 ) .|. C403 ) + ( ( ( ( 1r ) - C407 ) * C406 ) .|. C403 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C407 * ( C405 .|. C403 ) ) + ( ( ( ( 1r ) - C407 ) * C406 ) .|. C403 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C407 * ( C405 .|. C403 ) ) + ( ( ( 1r ) - C407 ) * ( C406 .|. C403 ) ) ) ) by CSSPACE:def 13
.= ( ( Im ( C407 * ( C405 .|. C403 ) ) ) + ( Im ( ( ( 1r ) - C407 ) * ( C406 .|. C403 ) ) ) ) by COMPLEX1:8
.= ( ( C408 * ( Im ( C405 .|. C403 ) ) ) + ( Im ( ( ( 1r ) - C407 ) * ( C406 .|. C403 ) ) ) ) by L1067 , L600
.= ( ( C408 * ( Im ( C405 .|. C403 ) ) ) + ( ( 1 - C408 ) * ( Im ( C406 .|. C403 ) ) ) ) by L1067 , L600;
thus L1076: thesis by L1075 , L1062 , L1074;
end;
theorem
L1077: (for B331 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B332 being (Subset of B331) holds (for B333 being (VECTOR of B331) holds (for B334 being Real holds (B332 = { B335 where B335 is (VECTOR of B331) : ( Im ( B335 .|. B333 ) ) <= B334 } implies B332 is  convex)))))
proof
let C409 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C410 being (Subset of C409);
let C411 being (VECTOR of C409);
let C412 being Real;
assume L1078: C410 = { B336 where B336 is (VECTOR of C409) : ( Im ( B336 .|. C411 ) ) <= C412 };
let C413 , C414 being (VECTOR of C409);
let C415 being Complex;
assume that
L1079: (ex B337 being Real st (C415 = B337 & ( 0 ) < B337 & B337 < 1))
and
L1080: C413 in C410
and
L1081: C414 in C410;
L1082: (ex B338 being (VECTOR of C409) st (C414 = B338 & ( Im ( B338 .|. C411 ) ) <= C412)) by L1078 , L1081;
consider C416 being Real such that L1083: C415 = C416 and L1084: ( 0 ) < C416 and L1085: C416 < 1 by L1079;
L1086: ( 1 - C416 ) > ( 0 ) by L1085 , XREAL_1:50;
L1087: ( ( 1 - C416 ) * ( Im ( C414 .|. C411 ) ) ) <= ( ( 1 - C416 ) * C412 ) by L1086 , L1082 , XREAL_1:64;
L1088: (ex B339 being (VECTOR of C409) st (C413 = B339 & ( Im ( B339 .|. C411 ) ) <= C412)) by L1078 , L1080;
L1089: ( C416 * ( Im ( C413 .|. C411 ) ) ) <= ( C416 * C412 ) by L1088 , L1084 , XREAL_1:64;
L1090: ( ( C416 * ( Im ( C413 .|. C411 ) ) ) + ( ( 1 - C416 ) * ( Im ( C414 .|. C411 ) ) ) ) <= ( ( C416 * C412 ) + ( ( 1 - C416 ) * C412 ) ) by L1089 , L1087 , XREAL_1:7;
L1091: ( Im ( ( ( C415 * C413 ) + ( ( ( 1r ) - C415 ) * C414 ) ) .|. C411 ) ) = ( Im ( ( ( C415 * C413 ) .|. C411 ) + ( ( ( ( 1r ) - C415 ) * C414 ) .|. C411 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C415 * ( C413 .|. C411 ) ) + ( ( ( ( 1r ) - C415 ) * C414 ) .|. C411 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C415 * ( C413 .|. C411 ) ) + ( ( ( 1r ) - C415 ) * ( C414 .|. C411 ) ) ) ) by CSSPACE:def 13
.= ( ( Im ( C415 * ( C413 .|. C411 ) ) ) + ( Im ( ( ( 1r ) - C415 ) * ( C414 .|. C411 ) ) ) ) by COMPLEX1:8
.= ( ( C416 * ( Im ( C413 .|. C411 ) ) ) + ( Im ( ( ( 1r ) - C415 ) * ( C414 .|. C411 ) ) ) ) by L1083 , L600
.= ( ( C416 * ( Im ( C413 .|. C411 ) ) ) + ( ( 1 - C416 ) * ( Im ( C414 .|. C411 ) ) ) ) by L1083 , L600;
thus L1092: thesis by L1091 , L1078 , L1090;
end;
theorem
L1093: (for B340 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B341 being (Subset of B340) holds (for B342 being (VECTOR of B340) holds (for B343 being Real holds (B341 = { B344 where B344 is (VECTOR of B340) : ( Im ( B344 .|. B342 ) ) < B343 } implies B341 is  convex)))))
proof
let C417 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C418 being (Subset of C417);
let C419 being (VECTOR of C417);
let C420 being Real;
assume L1094: C418 = { B345 where B345 is (VECTOR of C417) : ( Im ( B345 .|. C419 ) ) < C420 };
let C421 , C422 being (VECTOR of C417);
let C423 being Complex;
assume that
L1095: (ex B346 being Real st (C423 = B346 & ( 0 ) < B346 & B346 < 1))
and
L1096: C421 in C418
and
L1097: C422 in C418;
L1098: (ex B347 being (VECTOR of C417) st (C422 = B347 & ( Im ( B347 .|. C419 ) ) < C420)) by L1094 , L1097;
consider C424 being Real such that L1099: C423 = C424 and L1100: ( 0 ) < C424 and L1101: C424 < 1 by L1095;
L1102: ( 1 - C424 ) > ( 0 ) by L1101 , XREAL_1:50;
L1103: ( ( 1 - C424 ) * ( Im ( C422 .|. C419 ) ) ) < ( ( 1 - C424 ) * C420 ) by L1102 , L1098 , XREAL_1:68;
L1104: (ex B348 being (VECTOR of C417) st (C421 = B348 & ( Im ( B348 .|. C419 ) ) < C420)) by L1094 , L1096;
L1105: ( C424 * ( Im ( C421 .|. C419 ) ) ) < ( C424 * C420 ) by L1104 , L1100 , XREAL_1:68;
L1106: ( ( C424 * ( Im ( C421 .|. C419 ) ) ) + ( ( 1 - C424 ) * ( Im ( C422 .|. C419 ) ) ) ) < ( ( C424 * C420 ) + ( ( 1 - C424 ) * C420 ) ) by L1105 , L1103 , XREAL_1:8;
L1107: ( Im ( ( ( C423 * C421 ) + ( ( ( 1r ) - C423 ) * C422 ) ) .|. C419 ) ) = ( Im ( ( ( C423 * C421 ) .|. C419 ) + ( ( ( ( 1r ) - C423 ) * C422 ) .|. C419 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C423 * ( C421 .|. C419 ) ) + ( ( ( ( 1r ) - C423 ) * C422 ) .|. C419 ) ) ) by CSSPACE:def 13
.= ( Im ( ( C423 * ( C421 .|. C419 ) ) + ( ( ( 1r ) - C423 ) * ( C422 .|. C419 ) ) ) ) by CSSPACE:def 13
.= ( ( Im ( C423 * ( C421 .|. C419 ) ) ) + ( Im ( ( ( 1r ) - C423 ) * ( C422 .|. C419 ) ) ) ) by COMPLEX1:8
.= ( ( C424 * ( Im ( C421 .|. C419 ) ) ) + ( Im ( ( ( 1r ) - C423 ) * ( C422 .|. C419 ) ) ) ) by L1099 , L600
.= ( ( C424 * ( Im ( C421 .|. C419 ) ) ) + ( ( 1 - C424 ) * ( Im ( C422 .|. C419 ) ) ) ) by L1099 , L600;
thus L1108: thesis by L1107 , L1094 , L1106;
end;
theorem
L1109: (for B349 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B350 being (Subset of B349) holds (for B351 being (VECTOR of B349) holds (for B352 being Real holds (B350 = { B353 where B353 is (VECTOR of B349) : |. ( B353 .|. B351 ) .| <= B352 } implies B350 is  convex)))))
proof
let C425 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C426 being (Subset of C425);
let C427 being (VECTOR of C425);
let C428 being Real;
assume L1110: C426 = { B354 where B354 is (VECTOR of C425) : |. ( B354 .|. C427 ) .| <= C428 };
let C429 , C430 being (VECTOR of C425);
let C431 being Complex;
assume that
L1111: (ex B355 being Real st (C431 = B355 & ( 0 ) < B355 & B355 < 1))
and
L1112: C429 in C426
and
L1113: C430 in C426;
consider C432 being Real such that L1114: C431 = C432 and L1115: ( 0 ) < C432 and L1116: C432 < 1 by L1111;
L1117: ( 1 - C432 ) > ( 0 ) by L1116 , XREAL_1:50;
L1118: (ex B356 being (VECTOR of C425) st (C430 = B356 & |. ( B356 .|. C427 ) .| <= C428)) by L1110 , L1113;
L1119: ( ( 1 - C432 ) * |. ( C430 .|. C427 ) .| ) <= ( ( 1 - C432 ) * C428 ) by L1118 , L1117 , XREAL_1:64;
L1120: (ex B357 being (VECTOR of C425) st (C429 = B357 & |. ( B357 .|. C427 ) .| <= C428)) by L1110 , L1112;
L1121: ( C432 * |. ( C429 .|. C427 ) .| ) <= ( C432 * C428 ) by L1120 , L1115 , XREAL_1:64;
L1122: ( ( C432 * |. ( C429 .|. C427 ) .| ) + ( ( 1 - C432 ) * |. ( C430 .|. C427 ) .| ) ) <= ( ( C432 * C428 ) + ( ( 1 - C432 ) * C428 ) ) by L1121 , L1119 , XREAL_1:7;
L1123: (|. ( C431 * ( C429 .|. C427 ) ) .| = ( C432 * |. ( C429 .|. C427 ) .| ) & |. ( ( ( 1r ) - C431 ) * ( C430 .|. C427 ) ) .| = ( ( 1 - C432 ) * |. ( C430 .|. C427 ) .| )) by L1114 , L1115 , L1116 , L604;
L1124: |. ( ( C431 * ( C429 .|. C427 ) ) + ( ( ( 1r ) - C431 ) * ( C430 .|. C427 ) ) ) .| <= ( ( C432 * |. ( C429 .|. C427 ) .| ) + ( ( 1 - C432 ) * |. ( C430 .|. C427 ) .| ) ) by L1123 , COMPLEX1:56;
L1125: |. ( ( ( C431 * C429 ) + ( ( ( 1r ) - C431 ) * C430 ) ) .|. C427 ) .| = |. ( ( ( C431 * C429 ) .|. C427 ) + ( ( ( ( 1r ) - C431 ) * C430 ) .|. C427 ) ) .| by CSSPACE:def 13
.= |. ( ( C431 * ( C429 .|. C427 ) ) + ( ( ( ( 1r ) - C431 ) * C430 ) .|. C427 ) ) .| by CSSPACE:def 13
.= |. ( ( C431 * ( C429 .|. C427 ) ) + ( ( ( 1r ) - C431 ) * ( C430 .|. C427 ) ) ) .| by CSSPACE:def 13;
L1126: |. ( ( ( C431 * C429 ) + ( ( ( 1r ) - C431 ) * C430 ) ) .|. C427 ) .| <= C428 by L1125 , L1124 , L1122 , XXREAL_0:2;
thus L1127: thesis by L1126 , L1110;
end;
theorem
L1128: (for B358 being  ComplexUnitarySpace-like non  empty CUNITSTR holds (for B359 being (Subset of B358) holds (for B360 being (VECTOR of B358) holds (for B361 being Real holds (B359 = { B362 where B362 is (VECTOR of B358) : |. ( B362 .|. B360 ) .| < B361 } implies B359 is  convex)))))
proof
let C433 being  ComplexUnitarySpace-like non  empty CUNITSTR;
let C434 being (Subset of C433);
let C435 being (VECTOR of C433);
let C436 being Real;
assume L1129: C434 = { B363 where B363 is (VECTOR of C433) : |. ( B363 .|. C435 ) .| < C436 };
let C437 , C438 being (VECTOR of C433);
let C439 being Complex;
assume that
L1130: (ex B364 being Real st (C439 = B364 & ( 0 ) < B364 & B364 < 1))
and
L1131: C437 in C434
and
L1132: C438 in C434;
consider C440 being Real such that L1133: C439 = C440 and L1134: ( 0 ) < C440 and L1135: C440 < 1 by L1130;
L1136: ( 1 - C440 ) > ( 0 ) by L1135 , XREAL_1:50;
L1137: (ex B365 being (VECTOR of C433) st (C438 = B365 & |. ( B365 .|. C435 ) .| < C436)) by L1129 , L1132;
L1138: ( ( 1 - C440 ) * |. ( C438 .|. C435 ) .| ) < ( ( 1 - C440 ) * C436 ) by L1137 , L1136 , XREAL_1:68;
L1139: (ex B366 being (VECTOR of C433) st (C437 = B366 & |. ( B366 .|. C435 ) .| < C436)) by L1129 , L1131;
L1140: ( C440 * |. ( C437 .|. C435 ) .| ) < ( C440 * C436 ) by L1139 , L1134 , XREAL_1:68;
L1141: ( ( C440 * |. ( C437 .|. C435 ) .| ) + ( ( 1 - C440 ) * |. ( C438 .|. C435 ) .| ) ) < ( ( C440 * C436 ) + ( ( 1 - C440 ) * C436 ) ) by L1140 , L1138 , XREAL_1:8;
L1142: (|. ( C439 * ( C437 .|. C435 ) ) .| = ( C440 * |. ( C437 .|. C435 ) .| ) & |. ( ( ( 1r ) - C439 ) * ( C438 .|. C435 ) ) .| = ( ( 1 - C440 ) * |. ( C438 .|. C435 ) .| )) by L1133 , L1134 , L1135 , L604;
L1143: |. ( ( C439 * ( C437 .|. C435 ) ) + ( ( ( 1r ) - C439 ) * ( C438 .|. C435 ) ) ) .| <= ( ( C440 * |. ( C437 .|. C435 ) .| ) + ( ( 1 - C440 ) * |. ( C438 .|. C435 ) .| ) ) by L1142 , COMPLEX1:56;
L1144: |. ( ( ( C439 * C437 ) + ( ( ( 1r ) - C439 ) * C438 ) ) .|. C435 ) .| = |. ( ( ( C439 * C437 ) .|. C435 ) + ( ( ( ( 1r ) - C439 ) * C438 ) .|. C435 ) ) .| by CSSPACE:def 13
.= |. ( ( C439 * ( C437 .|. C435 ) ) + ( ( ( ( 1r ) - C439 ) * C438 ) .|. C435 ) ) .| by CSSPACE:def 13
.= |. ( ( C439 * ( C437 .|. C435 ) ) + ( ( ( 1r ) - C439 ) * ( C438 .|. C435 ) ) ) .| by CSSPACE:def 13;
L1145: |. ( ( ( C439 * C437 ) + ( ( ( 1r ) - C439 ) * C438 ) ) .|. C435 ) .| < C436 by L1144 , L1143 , L1141 , XXREAL_0:2;
thus L1146: thesis by L1145 , L1129;
end;
begin
definition
let C441 being ComplexLinearSpace;
let C442 being (C_Linear_Combination of C441);
attr C442 is  convex
means
:L1147: (ex B367 being (FinSequence of (the carrier of C441)) st (B367 is  one-to-one & ( rng B367 ) = ( Carrier C442 ) & (ex B368 being (FinSequence of ( REAL )) st (( len B368 ) = ( len B367 ) & ( Sum B368 ) = 1 & (for B369 being Nat holds (B369 in ( dom B368 ) implies (( B368 . B369 ) = ( C442 . ( B367 . B369 ) ) & ( B368 . B369 ) >= ( 0 ))))))));
end;
theorem
L1149: (for B370 being ComplexLinearSpace holds (for B371 being (C_Linear_Combination of B370) holds (B371 is  convex implies ( Carrier B371 ) <> ( {} ))))
proof
let C443 being ComplexLinearSpace;
let C444 being (C_Linear_Combination of C443);
assume L1150: C444 is  convex;
consider C445 being (FinSequence of (the carrier of C443)) such that L1151: (C445 is  one-to-one & ( rng C445 ) = ( Carrier C444 )) and L1152: (ex B372 being (FinSequence of ( REAL )) st (( len B372 ) = ( len C445 ) & ( Sum B372 ) = 1 & (for B373 being Nat holds (B373 in ( dom B372 ) implies (( B372 . B373 ) = ( C444 . ( C445 . B373 ) ) & ( B372 . B373 ) >= ( 0 )))))) by L1150 , L1147;
consider C446 being (FinSequence of ( REAL )) such that L1153: (( len C446 ) = ( len C445 ) & ( Sum C446 ) = 1 & (for B374 being Nat holds (B374 in ( dom C446 ) implies (( C446 . B374 ) = ( C444 . ( C445 . B374 ) ) & ( C446 . B374 ) >= ( 0 ))))) by L1152;
assume L1154: ( Carrier C444 ) = ( {} );
L1155: ( len C445 ) = ( 0 ) by L1154 , L1151 , CARD_1:27 , FINSEQ_4:62;
L1156: C446 = ( <*> (the carrier of C443) ) by L1155 , L1153;
thus L1157: contradiction by L1156 , L1153 , RVSUM_1:72;
end;
theorem
L1158: (for B375 being ComplexLinearSpace holds (for B376 being (C_Linear_Combination of B375) holds (for B377 being (VECTOR of B375) holds ((B376 is  convex & (ex B378 being Real st (B378 = ( B376 . B377 ) & B378 <= ( 0 )))) implies (not B377 in ( Carrier B376 ))))))
proof
let C447 being ComplexLinearSpace;
let C448 being (C_Linear_Combination of C447);
let C449 being (VECTOR of C447);
assume that
L1159: C448 is  convex
and
L1160: (ex B379 being Real st (B379 = ( C448 . C449 ) & B379 <= ( 0 )));
consider C450 being Real such that L1161: C450 = ( C448 . C449 ) and L1162: C450 <= ( 0 ) by L1160;
per cases  by L1162;
suppose L1163: C450 = ( 0 );

thus L1164: thesis by L1163 , L1161 , L35;
end;
suppose L1165: C450 < ( 0 );

L1166:
now
consider C451 being (FinSequence of (the carrier of C447)) such that L1167: C451 is  one-to-one and L1168: ( rng C451 ) = ( Carrier C448 ) and L1169: (ex B380 being (FinSequence of ( REAL )) st (( len B380 ) = ( len C451 ) & ( Sum B380 ) = 1 & (for B381 being Nat holds (B381 in ( dom B380 ) implies (( B380 . B381 ) = ( C448 . ( C451 . B381 ) ) & ( B380 . B381 ) >= ( 0 )))))) by L1159 , L1147;
assume L1170: C449 in ( Carrier C448 );
consider C452 being set such that L1171: C452 in ( dom C451 ) and L1172: ( C451 . C452 ) = C449 by L1170 , L1168 , FUNCT_1:def 3;
reconsider D85 = C452 as (Element of ( NAT )) by L1171;
consider C453 being (FinSequence of ( REAL )) such that L1173: ( len C453 ) = ( len C451 ) and L1174: ( Sum C453 ) = 1 and L1175: (for B382 being Nat holds (B382 in ( dom C453 ) implies (( C453 . B382 ) = ( C448 . ( C451 . B382 ) ) & ( C453 . B382 ) >= ( 0 )))) by L1169;
L1176: D85 in ( Seg ( len C451 ) ) by L1171 , FINSEQ_1:def 3;
L1177: D85 in ( dom C453 ) by L1176 , L1173 , FINSEQ_1:def 3;
L1178: ( C448 . C449 ) = ( C453 . D85 ) by L1177 , L1175 , L1172;
thus L1179: contradiction by L1178 , L1161 , L1165 , L1175 , L1177;
end;
thus L1180: thesis by L1166;
end;
end;
theorem
L1182: (for B383 being ComplexLinearSpace holds (for B384 being (C_Linear_Combination of B383) holds (B384 is  convex implies B384 <> ( ZeroCLC B383 ))))
proof
let C454 being ComplexLinearSpace;
let C455 being (C_Linear_Combination of C454);
assume L1183: C455 is  convex;
L1184: ( Carrier C455 ) <> ( {} ) by L1183 , L1149;
assume L1185: C455 = ( ZeroCLC C454 );
thus L1186: contradiction by L1185 , L1184;
end;
theorem
L1187: (for B385 being ComplexLinearSpace holds (for B386 being (VECTOR of B385) holds (for B387 being (C_Linear_Combination of B385) holds ((B387 is  convex & ( Carrier B387 ) = { B386 }) implies ((ex B388 being Real st (B388 = ( B387 . B386 ) & B388 = 1)) & ( Sum B387 ) = ( ( B387 . B386 ) * B386 ))))))
proof
let C456 being ComplexLinearSpace;
let C457 being (VECTOR of C456);
let C458 being (C_Linear_Combination of C456);
assume that
L1188: C458 is  convex
and
L1189: ( Carrier C458 ) = { C457 };
reconsider D86 = C458 as (C_Linear_Combination of { C457 }) by L1189 , L63;
consider C459 being (FinSequence of (the carrier of C456)) such that L1190: (C459 is  one-to-one & ( rng C459 ) = ( Carrier D86 )) and L1191: (ex B389 being (FinSequence of ( REAL )) st (( len B389 ) = ( len C459 ) & ( Sum B389 ) = 1 & (for B390 being Nat holds (B390 in ( dom B389 ) implies (( B389 . B390 ) = ( D86 . ( C459 . B390 ) ) & ( B389 . B390 ) >= ( 0 )))))) by L1188 , L1147;
L1192: C459 = <* C457 *> by L1189 , L1190 , FINSEQ_3:97;
consider C460 being (FinSequence of ( REAL )) such that L1193: ( len C460 ) = ( len C459 ) and L1194: ( Sum C460 ) = 1 and L1195: (for B391 being Nat holds (B391 in ( dom C460 ) implies (( C460 . B391 ) = ( D86 . ( C459 . B391 ) ) & ( C460 . B391 ) >= ( 0 )))) by L1191;
reconsider D87 = ( C460 /. 1 ) as (Element of ( REAL ));
L1196: ( card ( Carrier D86 ) ) = 1 by L1189 , CARD_1:30;
L1197: ( len C459 ) = 1 by L1196 , L1190 , FINSEQ_4:62;
L1198: ( dom C460 ) = ( Seg 1 ) by L1197 , L1193 , FINSEQ_1:def 3;
L1199: 1 in ( dom C460 ) by L1198;
L1200: ( C460 . 1 ) = ( C460 /. 1 ) by L1199 , PARTFUN1:def 6;
L1201: C460 = <* D87 *> by L1200 , L1198 , FINSEQ_1:def 8;
L1202: ( C460 . 1 ) = ( D86 . ( C459 . 1 ) ) by L1195 , L1199;
L1203: D87 = ( D86 . C457 ) by L1202 , L1200 , L1192 , FINSEQ_1:def 8;
thus L1204: thesis by L1203 , L1194 , L1201 , L285 , FINSOP_1:11;
end;
theorem
L1205: (for B392 being ComplexLinearSpace holds (for B393 , B394 being (VECTOR of B392) holds (for B395 being (C_Linear_Combination of B392) holds ((B395 is  convex & ( Carrier B395 ) = { B393 , B394 } & B393 <> B394) implies ((ex B396 , B397 being Real st (B396 = ( B395 . B393 ) & B397 = ( B395 . B394 ) & ( B396 + B397 ) = 1 & B396 >= ( 0 ) & B397 >= ( 0 ))) & ( Sum B395 ) = ( ( ( B395 . B393 ) * B393 ) + ( ( B395 . B394 ) * B394 ) ))))))
proof
let C461 being ComplexLinearSpace;
let C462 , C463 being (VECTOR of C461);
let C464 being (C_Linear_Combination of C461);
assume that
L1206: C464 is  convex
and
L1207: ( Carrier C464 ) = { C462 , C463 }
and
L1208: C462 <> C463;
reconsider D88 = C464 as (C_Linear_Combination of { C462 , C463 }) by L1207 , L63;
consider C465 being (FinSequence of (the carrier of C461)) such that L1209: (C465 is  one-to-one & ( rng C465 ) = ( Carrier D88 )) and L1210: (ex B398 being (FinSequence of ( REAL )) st (( len B398 ) = ( len C465 ) & ( Sum B398 ) = 1 & (for B399 being Nat holds (B399 in ( dom B398 ) implies (( B398 . B399 ) = ( D88 . ( C465 . B399 ) ) & ( B398 . B399 ) >= ( 0 )))))) by L1206 , L1147;
consider C466 being (FinSequence of ( REAL )) such that L1211: ( len C466 ) = ( len C465 ) and L1212: ( Sum C466 ) = 1 and L1213: (for B400 being Nat holds (B400 in ( dom C466 ) implies (( C466 . B400 ) = ( D88 . ( C465 . B400 ) ) & ( C466 . B400 ) >= ( 0 )))) by L1210;
L1214: ( len C465 ) = ( card { C462 , C463 } ) by L1207 , L1209 , FINSEQ_4:62;
L1215: ( len C466 ) = 2 by L1214 , L1208 , L1211 , CARD_2:57;
L1216: ( dom C466 ) = { 1 , 2 } by L1215 , FINSEQ_1:2 , FINSEQ_1:def 3;
L1217: 2 in ( dom C466 ) by L1216 , TARSKI:def 2;
L1218: ( C466 . 2 ) = ( D88 . ( C465 . 2 ) ) by L1217 , L1213;
L1219: ( C466 /. 2 ) = ( D88 . ( C465 . 2 ) ) by L1218 , L1217 , PARTFUN1:def 6;
reconsider D89 = ( D88 . ( C465 . 2 ) ) as Real by L1219;
L1220: ( C466 . 2 ) >= ( 0 ) by L1213 , L1217;
L1221: 1 in ( dom C466 ) by L1216 , TARSKI:def 2;
L1222: ( C466 . 1 ) = ( D88 . ( C465 . 1 ) ) by L1221 , L1213;
L1223: ( C466 /. 1 ) = ( D88 . ( C465 . 1 ) ) by L1222 , L1221 , PARTFUN1:def 6;
reconsider D90 = ( D88 . ( C465 . 1 ) ) as Real by L1223;
L1224: C466 = <* D90 , D89 *> by L1215 , L1222 , L1218 , FINSEQ_1:44;
L1225: (ex B401 , B402 being Real st (B401 = ( D88 . C462 ) & B402 = ( D88 . C463 ) & ( B401 + B402 ) = 1 & B401 >= ( 0 ) & B402 >= ( 0 )))
proof
per cases  by L1207 , L1208 , L1209 , FINSEQ_3:99;
suppose L1226: C465 = <* C462 , C463 *>;

L1227: (D90 = ( D88 . C462 ) & D89 = ( D88 . C463 )) by L1226 , FINSEQ_1:44;
L1228: (( D90 + D89 ) = 1 & D90 >= ( 0 )) by L1212 , L1213 , L1221 , L1222 , L1224 , RVSUM_1:77;
thus L1229: thesis by L1228 , L1218 , L1220 , L1227;
end;
suppose L1230: C465 = <* C463 , C462 *>;

L1231: (D90 = ( D88 . C463 ) & D89 = ( D88 . C462 )) by L1230 , FINSEQ_1:44;
L1232: (( D90 + D89 ) = 1 & D90 >= ( 0 )) by L1212 , L1213 , L1221 , L1222 , L1224 , RVSUM_1:77;
thus L1233: thesis by L1232 , L1218 , L1220 , L1231;
end;
end;
thus L1235: thesis by L1225 , L1208 , L297;
end;
L1236: (for B403 being ComplexLinearSpace holds (for B404 , B405 , B406 being (VECTOR of B403) holds (for B407 being (C_Linear_Combination of { B404 , B405 , B406 }) holds ((B404 <> B405 & B405 <> B406 & B406 <> B404) implies ( Sum B407 ) = ( ( ( ( B407 . B404 ) * B404 ) + ( ( B407 . B405 ) * B405 ) ) + ( ( B407 . B406 ) * B406 ) )))))
proof
let C467 being ComplexLinearSpace;
let C468 , C469 , C470 being (VECTOR of C467);
let C471 being (C_Linear_Combination of { C468 , C469 , C470 });
assume that
L1237: C468 <> C469
and
L1238: C469 <> C470
and
L1239: C470 <> C468;
L1240: ( Carrier C471 ) c= { C468 , C469 , C470 } by L63;
per cases  by L1240 , ZFMISC_1:118;
suppose L1241: ( Carrier C471 ) = ( {} );

L1242: C471 = ( ZeroCLC C467 ) by L1241 , L42;
L1243: ( Sum C471 ) = ( 0. C467 ) by L1242 , L196
.= ( ( 0. C467 ) + ( 0. C467 ) ) by RLVECT_1:4
.= ( ( ( 0. C467 ) + ( 0. C467 ) ) + ( 0. C467 ) ) by RLVECT_1:4
.= ( ( ( ( 0c ) * C468 ) + ( 0. C467 ) ) + ( 0. C467 ) ) by CLVECT_1:1
.= ( ( ( ( 0c ) * C468 ) + ( ( 0c ) * C469 ) ) + ( 0. C467 ) ) by CLVECT_1:1
.= ( ( ( ( 0c ) * C468 ) + ( ( 0c ) * C469 ) ) + ( ( 0c ) * C470 ) ) by CLVECT_1:1
.= ( ( ( ( C471 . C468 ) * C468 ) + ( ( 0c ) * C469 ) ) + ( ( 0c ) * C470 ) ) by L1242 , L60
.= ( ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) + ( ( 0c ) * C470 ) ) by L1242 , L60
.= ( ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) + ( ( C471 . C470 ) * C470 ) ) by L1242 , L60;
thus L1244: thesis by L1243;
end;
suppose L1245: ( Carrier C471 ) = { C468 };

reconsider D91 = C471 as (C_Linear_Combination of { C468 }) by L1245 , L63;
L1246: (not C469 in ( Carrier D91 )) by L1237 , L1245 , TARSKI:def 1;
L1247: (not C470 in ( Carrier D91 )) by L1239 , L1245 , TARSKI:def 1;
L1248: ( Sum D91 ) = ( ( D91 . C468 ) * C468 ) by L285
.= ( ( ( D91 . C468 ) * C468 ) + ( 0. C467 ) ) by RLVECT_1:4
.= ( ( ( ( D91 . C468 ) * C468 ) + ( 0. C467 ) ) + ( 0. C467 ) ) by RLVECT_1:4
.= ( ( ( ( D91 . C468 ) * C468 ) + ( ( 0c ) * C469 ) ) + ( 0. C467 ) ) by CLVECT_1:1
.= ( ( ( ( D91 . C468 ) * C468 ) + ( ( 0c ) * C469 ) ) + ( ( 0c ) * C470 ) ) by CLVECT_1:1
.= ( ( ( ( D91 . C468 ) * C468 ) + ( ( D91 . C469 ) * C469 ) ) + ( ( 0c ) * C470 ) ) by L1246
.= ( ( ( ( D91 . C468 ) * C468 ) + ( ( D91 . C469 ) * C469 ) ) + ( ( D91 . C470 ) * C470 ) ) by L1247;
thus L1249: thesis by L1248;
end;
suppose L1250: ( Carrier C471 ) = { C469 };

reconsider D92 = C471 as (C_Linear_Combination of { C469 }) by L1250 , L63;
L1251: (not C468 in ( Carrier D92 )) by L1237 , L1250 , TARSKI:def 1;
L1252: (not C470 in ( Carrier D92 )) by L1238 , L1250 , TARSKI:def 1;
L1253: ( Sum D92 ) = ( ( D92 . C469 ) * C469 ) by L285
.= ( ( 0. C467 ) + ( ( D92 . C469 ) * C469 ) ) by RLVECT_1:4
.= ( ( ( 0. C467 ) + ( ( D92 . C469 ) * C469 ) ) + ( 0. C467 ) ) by RLVECT_1:4
.= ( ( ( ( 0c ) * C468 ) + ( ( D92 . C469 ) * C469 ) ) + ( 0. C467 ) ) by CLVECT_1:1
.= ( ( ( ( 0c ) * C468 ) + ( ( D92 . C469 ) * C469 ) ) + ( ( 0c ) * C470 ) ) by CLVECT_1:1
.= ( ( ( ( D92 . C468 ) * C468 ) + ( ( D92 . C469 ) * C469 ) ) + ( ( 0c ) * C470 ) ) by L1251
.= ( ( ( ( D92 . C468 ) * C468 ) + ( ( D92 . C469 ) * C469 ) ) + ( ( D92 . C470 ) * C470 ) ) by L1252;
thus L1254: thesis by L1253;
end;
suppose L1255: ( Carrier C471 ) = { C470 };

reconsider D93 = C471 as (C_Linear_Combination of { C470 }) by L1255 , L63;
L1256: (not C468 in ( Carrier D93 )) by L1239 , L1255 , TARSKI:def 1;
L1257: (not C469 in ( Carrier D93 )) by L1238 , L1255 , TARSKI:def 1;
L1258: ( Sum D93 ) = ( ( D93 . C470 ) * C470 ) by L285
.= ( ( 0. C467 ) + ( ( D93 . C470 ) * C470 ) ) by RLVECT_1:4
.= ( ( ( 0. C467 ) + ( 0. C467 ) ) + ( ( D93 . C470 ) * C470 ) ) by RLVECT_1:4
.= ( ( ( ( 0c ) * C468 ) + ( 0. C467 ) ) + ( ( D93 . C470 ) * C470 ) ) by CLVECT_1:1
.= ( ( ( ( 0c ) * C468 ) + ( ( 0c ) * C469 ) ) + ( ( D93 . C470 ) * C470 ) ) by CLVECT_1:1
.= ( ( ( ( D93 . C468 ) * C468 ) + ( ( 0c ) * C469 ) ) + ( ( D93 . C470 ) * C470 ) ) by L1256
.= ( ( ( ( D93 . C468 ) * C468 ) + ( ( D93 . C469 ) * C469 ) ) + ( ( D93 . C470 ) * C470 ) ) by L1257;
thus L1259: thesis by L1258;
end;
suppose L1260: ( Carrier C471 ) = { C468 , C469 };

L1261: ( Sum C471 ) = ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) by L1260 , L1237 , L330
.= ( ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) + ( 0. C467 ) ) by RLVECT_1:4
.= ( ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) + ( ( 0c ) * C470 ) ) by CLVECT_1:1;
L1262: (not C470 in ( Carrier C471 )) by L1238 , L1239 , L1260 , TARSKI:def 2;
thus L1263: thesis by L1262 , L1261;
end;
suppose L1264: ( Carrier C471 ) = { C468 , C470 };

L1265: ( Sum C471 ) = ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C470 ) * C470 ) ) by L1264 , L1239 , L330
.= ( ( ( ( C471 . C468 ) * C468 ) + ( 0. C467 ) ) + ( ( C471 . C470 ) * C470 ) ) by RLVECT_1:4
.= ( ( ( ( C471 . C468 ) * C468 ) + ( ( 0c ) * C469 ) ) + ( ( C471 . C470 ) * C470 ) ) by CLVECT_1:1;
L1266: (not C469 in ( Carrier C471 )) by L1237 , L1238 , L1264 , TARSKI:def 2;
thus L1267: thesis by L1266 , L1265;
end;
suppose L1268: ( Carrier C471 ) = { C469 , C470 };

L1269: ( Sum C471 ) = ( ( ( C471 . C469 ) * C469 ) + ( ( C471 . C470 ) * C470 ) ) by L1268 , L1238 , L330
.= ( ( ( 0. C467 ) + ( ( C471 . C469 ) * C469 ) ) + ( ( C471 . C470 ) * C470 ) ) by RLVECT_1:4
.= ( ( ( ( 0c ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) + ( ( C471 . C470 ) * C470 ) ) by CLVECT_1:1;
L1270: (not C468 in ( Carrier C471 )) by L1237 , L1239 , L1268 , TARSKI:def 2;
thus L1271: thesis by L1270 , L1269;
end;
suppose L1272: ( Carrier C471 ) = { C468 , C469 , C470 };

consider C472 being (FinSequence of (the carrier of C467)) such that L1273: (C472 is  one-to-one & ( rng C472 ) = { C468 , C469 , C470 }) and L1274: ( Sum C471 ) = ( Sum ( C471 (#) C472 ) ) by L1272 , L136;
L1275: (C472 = <* C468 , C469 , C470 *> or C472 = <* C468 , C470 , C469 *> or C472 = <* C469 , C468 , C470 *> or C472 = <* C469 , C470 , C468 *> or C472 = <* C470 , C468 , C469 *> or C472 = <* C470 , C469 , C468 *>) by L1237 , L1238 , L1239 , L1273 , CONVEX1:31;
L1276: (( C471 (#) C472 ) = <* ( ( C471 . C468 ) * C468 ) , ( ( C471 . C469 ) * C469 ) , ( ( C471 . C470 ) * C470 ) *> or ( C471 (#) C472 ) = <* ( ( C471 . C468 ) * C468 ) , ( ( C471 . C470 ) * C470 ) , ( ( C471 . C469 ) * C469 ) *> or ( C471 (#) C472 ) = <* ( ( C471 . C469 ) * C469 ) , ( ( C471 . C468 ) * C468 ) , ( ( C471 . C470 ) * C470 ) *> or ( C471 (#) C472 ) = <* ( ( C471 . C469 ) * C469 ) , ( ( C471 . C470 ) * C470 ) , ( ( C471 . C468 ) * C468 ) *> or ( C471 (#) C472 ) = <* ( ( C471 . C470 ) * C470 ) , ( ( C471 . C468 ) * C468 ) , ( ( C471 . C469 ) * C469 ) *> or ( C471 (#) C472 ) = <* ( ( C471 . C470 ) * C470 ) , ( ( C471 . C469 ) * C469 ) , ( ( C471 . C468 ) * C468 ) *>) by L1275 , L126;
L1277: (( Sum C471 ) = ( ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C469 ) * C469 ) ) + ( ( C471 . C470 ) * C470 ) ) or ( Sum C471 ) = ( ( ( C471 . C468 ) * C468 ) + ( ( ( C471 . C469 ) * C469 ) + ( ( C471 . C470 ) * C470 ) ) ) or ( Sum C471 ) = ( ( ( C471 . C469 ) * C469 ) + ( ( ( C471 . C468 ) * C468 ) + ( ( C471 . C470 ) * C470 ) ) )) by L1276 , L1274 , RLVECT_1:46;
thus L1278: thesis by L1277 , RLVECT_1:def 3;
end;
end;
theorem
L1280: (for B408 being ComplexLinearSpace holds (for B409 , B410 , B411 being (VECTOR of B408) holds (for B412 being (C_Linear_Combination of B408) holds ((B412 is  convex & ( Carrier B412 ) = { B409 , B410 , B411 } & B409 <> B410 & B410 <> B411 & B411 <> B409) implies ((ex B413 , B414 , B415 being  real number st (B413 = ( B412 . B409 ) & B414 = ( B412 . B410 ) & B415 = ( B412 . B411 ) & ( ( B413 + B414 ) + B415 ) = 1 & B413 >= ( 0 ) & B414 >= ( 0 ) & B415 >= ( 0 ))) & ( Sum B412 ) = ( ( ( ( B412 . B409 ) * B409 ) + ( ( B412 . B410 ) * B410 ) ) + ( ( B412 . B411 ) * B411 ) ))))))
proof
let C473 being ComplexLinearSpace;
let C474 , C475 , C476 being (VECTOR of C473);
let C477 being (C_Linear_Combination of C473);
assume that
L1281: C477 is  convex
and
L1282: ( Carrier C477 ) = { C474 , C475 , C476 }
and
L1283: (C474 <> C475 & C475 <> C476 & C476 <> C474);
reconsider D94 = C477 as (C_Linear_Combination of { C474 , C475 , C476 }) by L1282 , L63;
consider C478 being (FinSequence of (the carrier of C473)) such that L1284: (C478 is  one-to-one & ( rng C478 ) = ( Carrier D94 )) and L1285: (ex B416 being (FinSequence of ( REAL )) st (( len B416 ) = ( len C478 ) & ( Sum B416 ) = 1 & (for B417 being Nat holds (B417 in ( dom B416 ) implies (( B416 . B417 ) = ( D94 . ( C478 . B417 ) ) & ( B416 . B417 ) >= ( 0 )))))) by L1281 , L1147;
consider C479 being (FinSequence of ( REAL )) such that L1286: ( len C479 ) = ( len C478 ) and L1287: ( Sum C479 ) = 1 and L1288: (for B418 being Nat holds (B418 in ( dom C479 ) implies (( C479 . B418 ) = ( D94 . ( C478 . B418 ) ) & ( C479 . B418 ) >= ( 0 )))) by L1285;
L1289: ( len C478 ) = ( card { C474 , C475 , C476 } ) by L1282 , L1284 , FINSEQ_4:62;
L1290: ( len C479 ) = 3 by L1289 , L1283 , L1286 , CARD_2:58;
L1291: ( dom C479 ) = { 1 , 2 , 3 } by L1290 , FINSEQ_1:def 3 , FINSEQ_3:1;
L1292: 2 in ( dom C479 ) by L1291 , ENUMSET1:def 1;
L1293: ( C479 . 2 ) = ( D94 . ( C478 . 2 ) ) by L1292 , L1288;
L1294: ( C479 /. 2 ) = ( D94 . ( C478 . 2 ) ) by L1293 , L1292 , PARTFUN1:def 6;
reconsider D95 = ( D94 . ( C478 . 2 ) ) as (Element of ( REAL )) by L1294;
L1295: ( C479 . 2 ) >= ( 0 ) by L1288 , L1292;
L1296: 3 in ( dom C479 ) by L1291 , ENUMSET1:def 1;
L1297: ( C479 . 3 ) = ( D94 . ( C478 . 3 ) ) by L1296 , L1288;
L1298: ( C479 /. 3 ) = ( D94 . ( C478 . 3 ) ) by L1297 , L1296 , PARTFUN1:def 6;
reconsider D96 = ( D94 . ( C478 . 3 ) ) as (Element of ( REAL )) by L1298;
L1299: ( C479 . 3 ) >= ( 0 ) by L1288 , L1296;
L1300: 1 in ( dom C479 ) by L1291 , ENUMSET1:def 1;
L1301: ( C479 . 1 ) = ( D94 . ( C478 . 1 ) ) by L1300 , L1288;
L1302: ( C479 /. 1 ) = ( D94 . ( C478 . 1 ) ) by L1301 , L1300 , PARTFUN1:def 6;
reconsider D97 = ( D94 . ( C478 . 1 ) ) as (Element of ( REAL )) by L1302;
L1303: C479 = <* D97 , D95 , D96 *> by L1290 , L1301 , L1293 , L1297 , FINSEQ_1:45;
L1304: ( ( D97 + D95 ) + D96 ) = 1 by L1303 , L1287 , RVSUM_1:78;
L1305: ( C479 . 1 ) >= ( 0 ) by L1288 , L1300;
L1306: (ex B419 , B420 , B421 being  real number st (B419 = ( D94 . C474 ) & B420 = ( D94 . C475 ) & B421 = ( D94 . C476 ) & ( ( B419 + B420 ) + B421 ) = 1 & B419 >= ( 0 ) & B420 >= ( 0 ) & B421 >= ( 0 )))
proof
per cases  by L1282 , L1283 , L1284 , CONVEX1:31;
suppose L1307: C478 = <* C474 , C475 , C476 *>;

L1308: (D97 = ( D94 . C474 ) & D95 = ( D94 . C475 )) by L1307 , FINSEQ_1:45;
L1309: D95 >= ( 0 ) by L1288 , L1292 , L1293;
L1310: D96 = ( D94 . C476 ) by L1307 , FINSEQ_1:45;
L1311: (( ( D97 + D95 ) + D96 ) = 1 & D97 >= ( 0 )) by L1287 , L1288 , L1300 , L1301 , L1303 , RVSUM_1:78;
thus L1312: thesis by L1311 , L1297 , L1299 , L1308 , L1310 , L1309;
end;
suppose L1313: C478 = <* C474 , C476 , C475 *>;

L1314: (D97 = ( D94 . C474 ) & D96 = ( D94 . C475 )) by L1313 , FINSEQ_1:45;
L1315: D96 >= ( 0 ) by L1288 , L1296 , L1297;
L1316: D95 = ( D94 . C476 ) by L1313 , FINSEQ_1:45;
L1317: (( ( D97 + D96 ) + D95 ) = 1 & D97 >= ( 0 )) by L1288 , L1300 , L1301 , L1304;
thus L1318: thesis by L1317 , L1293 , L1295 , L1314 , L1316 , L1315;
end;
suppose L1319: C478 = <* C475 , C474 , C476 *>;

L1320: (D95 = ( D94 . C474 ) & D97 = ( D94 . C475 )) by L1319 , FINSEQ_1:45;
L1321: D97 >= ( 0 ) by L1288 , L1300 , L1301;
L1322: D96 = ( D94 . C476 ) by L1319 , FINSEQ_1:45;
L1323: (( ( D95 + D97 ) + D96 ) = 1 & D95 >= ( 0 )) by L1287 , L1288 , L1292 , L1293 , L1303 , RVSUM_1:78;
thus L1324: thesis by L1323 , L1297 , L1299 , L1320 , L1322 , L1321;
end;
suppose L1325: C478 = <* C475 , C476 , C474 *>;

L1326: (D96 = ( D94 . C474 ) & D97 = ( D94 . C475 )) by L1325 , FINSEQ_1:45;
L1327: D97 >= ( 0 ) by L1288 , L1300 , L1301;
L1328: D95 = ( D94 . C476 ) by L1325 , FINSEQ_1:45;
L1329: (( ( D96 + D97 ) + D95 ) = 1 & D96 >= ( 0 )) by L1288 , L1296 , L1297 , L1304;
thus L1330: thesis by L1329 , L1293 , L1295 , L1326 , L1328 , L1327;
end;
suppose L1331: C478 = <* C476 , C474 , C475 *>;

L1332: (D95 = ( D94 . C474 ) & D96 = ( D94 . C475 )) by L1331 , FINSEQ_1:45;
L1333: D96 >= ( 0 ) by L1288 , L1296 , L1297;
L1334: D97 = ( D94 . C476 ) by L1331 , FINSEQ_1:45;
L1335: (( ( D95 + D96 ) + D97 ) = 1 & D95 >= ( 0 )) by L1288 , L1292 , L1293 , L1304;
thus L1336: thesis by L1335 , L1301 , L1305 , L1332 , L1334 , L1333;
end;
suppose L1337: C478 = <* C476 , C475 , C474 *>;

L1338: (D96 = ( D94 . C474 ) & D95 = ( D94 . C475 )) by L1337 , FINSEQ_1:45;
L1339: D95 >= ( 0 ) by L1288 , L1292 , L1293;
L1340: D97 = ( D94 . C476 ) by L1337 , FINSEQ_1:45;
L1341: (( ( D96 + D95 ) + D97 ) = 1 & D96 >= ( 0 )) by L1288 , L1296 , L1297 , L1304;
thus L1342: thesis by L1341 , L1301 , L1305 , L1338 , L1340 , L1339;
end;
end;
thus L1344: thesis by L1306 , L1283 , L1236;
end;
theorem
L1345: (for B422 being ComplexLinearSpace holds (for B423 being (VECTOR of B422) holds (for B424 being (C_Linear_Combination of { B423 }) holds (B424 is  convex implies ((ex B425 being Real st (B425 = ( B424 . B423 ) & B425 = 1)) & ( Sum B424 ) = ( ( B424 . B423 ) * B423 ))))))
proof
let C480 being ComplexLinearSpace;
let C481 being (VECTOR of C480);
let C482 being (C_Linear_Combination of { C481 });
L1346: ( Carrier C482 ) c= { C481 } by L63;
L1347: (( Carrier C482 ) = ( {} ) or ( Carrier C482 ) = { C481 }) by L1346 , ZFMISC_1:33;
assume L1348: C482 is  convex;
thus L1349: thesis by L1348 , L1347 , L1149 , L1187;
end;
theorem
L1350: (for B426 being ComplexLinearSpace holds (for B427 , B428 being (VECTOR of B426) holds (for B429 being (C_Linear_Combination of { B427 , B428 }) holds ((B427 <> B428 & B429 is  convex) implies ((ex B430 , B431 being  real number st (B430 = ( B429 . B427 ) & B431 = ( B429 . B428 ) & B430 >= ( 0 ) & B431 >= ( 0 ))) & ( Sum B429 ) = ( ( ( B429 . B427 ) * B427 ) + ( ( B429 . B428 ) * B428 ) ))))))
proof
let C483 being ComplexLinearSpace;
let C484 , C485 being (VECTOR of C483);
let C486 being (C_Linear_Combination of { C484 , C485 });
assume that
L1351: C484 <> C485
and
L1352: C486 is  convex;
L1353: ( Carrier C486 ) c= { C484 , C485 } by L63;
L1354: ( Carrier C486 ) <> ( {} ) by L1352 , L1149;
L1355: (ex B432 , B433 being  real number st (B432 = ( C486 . C484 ) & B433 = ( C486 . C485 ) & B432 >= ( 0 ) & B433 >= ( 0 )))
proof
per cases  by L1353 , L1354 , ZFMISC_1:36;
suppose L1356: ( Carrier C486 ) = { C484 };

L1357: (not C485 in ( Carrier C486 )) by L1356 , L1351 , TARSKI:def 1;
L1358: ( 0 ) = ( C486 . C485 ) by L1357;
L1359: (ex B434 being Real st (B434 = ( C486 . C484 ) & B434 = 1)) by L1352 , L1356 , L1187;
thus L1360: thesis by L1359 , L1358;
end;
suppose L1361: ( Carrier C486 ) = { C485 };

L1362: (not C484 in ( Carrier C486 )) by L1361 , L1351 , TARSKI:def 1;
L1363: ( 0 ) = ( C486 . C484 ) by L1362;
L1364: (ex B435 being Real st (B435 = ( C486 . C485 ) & B435 = 1)) by L1352 , L1361 , L1187;
thus L1365: thesis by L1364 , L1363;
end;
suppose L1366: ( Carrier C486 ) = { C484 , C485 };

L1367: (ex B436 , B437 being Real st (B436 = ( C486 . C484 ) & B437 = ( C486 . C485 ) & ( B436 + B437 ) = 1 & B436 >= ( 0 ) & B437 >= ( 0 ))) by L1366 , L1351 , L1352 , L1205;
thus L1368: thesis by L1367;
end;
end;
thus L1370: thesis by L1355 , L1351 , L297;
end;
theorem
L1371: (for B438 being ComplexLinearSpace holds (for B439 , B440 , B441 being (VECTOR of B438) holds (for B442 being (C_Linear_Combination of { B439 , B440 , B441 }) holds ((B439 <> B440 & B440 <> B441 & B441 <> B439 & B442 is  convex) implies ((ex B443 , B444 , B445 being  real number st (B443 = ( B442 . B439 ) & B444 = ( B442 . B440 ) & B445 = ( B442 . B441 ) & ( ( B443 + B444 ) + B445 ) = 1 & B443 >= ( 0 ) & B444 >= ( 0 ) & B445 >= ( 0 ))) & ( Sum B442 ) = ( ( ( ( B442 . B439 ) * B439 ) + ( ( B442 . B440 ) * B440 ) ) + ( ( B442 . B441 ) * B441 ) ))))))
proof
let C487 being ComplexLinearSpace;
let C488 , C489 , C490 being (VECTOR of C487);
let C491 being (C_Linear_Combination of { C488 , C489 , C490 });
assume that
L1372: C488 <> C489
and
L1373: C489 <> C490
and
L1374: C490 <> C488
and
L1375: C491 is  convex;
L1376: ( Carrier C491 ) c= { C488 , C489 , C490 } by L63;
L1377: ( Carrier C491 ) <> ( {} ) by L1375 , L1149;
L1378: (ex B446 , B447 , B448 being  real number st (B446 = ( C491 . C488 ) & B447 = ( C491 . C489 ) & B448 = ( C491 . C490 ) & ( ( B446 + B447 ) + B448 ) = 1 & B446 >= ( 0 ) & B447 >= ( 0 ) & B448 >= ( 0 )))
proof
per cases  by L1376 , L1377 , ZFMISC_1:118;
suppose L1379: ( Carrier C491 ) = { C488 };

L1380: (not C489 in ( Carrier C491 )) by L1379 , L1372 , TARSKI:def 1;
L1381: ( 0 ) = ( C491 . C489 ) by L1380;
L1382: ( ( 1 + ( 0 ) ) + ( 0 ) ) = 1;
L1383: (not C490 in ( Carrier C491 )) by L1374 , L1379 , TARSKI:def 1;
L1384: ( 0 ) = ( C491 . C490 ) by L1383;
L1385: (ex B449 being Real st (B449 = ( C491 . C488 ) & B449 = 1)) by L1375 , L1379 , L1187;
thus L1386: thesis by L1385 , L1381 , L1384 , L1382;
end;
suppose L1387: ( Carrier C491 ) = { C489 };

L1388: (not C488 in ( Carrier C491 )) by L1387 , L1372 , TARSKI:def 1;
L1389: ( 0 ) = ( C491 . C488 ) by L1388;
L1390: ( ( ( 0 ) + 1 ) + ( 0 ) ) = 1;
L1391: (not C490 in ( Carrier C491 )) by L1373 , L1387 , TARSKI:def 1;
L1392: ( 0 ) = ( C491 . C490 ) by L1391;
L1393: (ex B450 being Real st (B450 = ( C491 . C489 ) & B450 = 1)) by L1375 , L1387 , L1187;
thus L1394: thesis by L1393 , L1389 , L1392 , L1390;
end;
suppose L1395: ( Carrier C491 ) = { C490 };

L1396: (not C488 in ( Carrier C491 )) by L1395 , L1374 , TARSKI:def 1;
L1397: ( 0 ) = ( C491 . C488 ) by L1396;
L1398: ( ( ( 0 ) + ( 0 ) ) + 1 ) = 1;
L1399: (not C489 in ( Carrier C491 )) by L1373 , L1395 , TARSKI:def 1;
L1400: ( 0 ) = ( C491 . C489 ) by L1399;
L1401: (ex B451 being Real st (B451 = ( C491 . C490 ) & B451 = 1)) by L1375 , L1395 , L1187;
thus L1402: thesis by L1401 , L1397 , L1400 , L1398;
end;
suppose L1403: ( Carrier C491 ) = { C488 , C489 };

set D98 = ( 0 );
L1404: (not C490 in { B452 where B452 is (Element of C487) : ( C491 . B452 ) <> ( 0 ) }) by L1373 , L1374 , L1403 , TARSKI:def 2;
L1405: D98 = ( C491 . C490 ) by L1404;
consider C492 , C493 being Real such that L1406: (C492 = ( C491 . C488 ) & C493 = ( C491 . C489 )) and L1407: ( C492 + C493 ) = 1 and L1408: (C492 >= ( 0 ) & C493 >= ( 0 )) by L1372 , L1375 , L1403 , L1205;
L1409: ( ( C492 + C493 ) + D98 ) = 1 by L1407;
thus L1410: thesis by L1409 , L1406 , L1408 , L1405;
end;
suppose L1411: ( Carrier C491 ) = { C489 , C490 };

set D99 = ( 0 );
L1412: (not C488 in ( Carrier C491 )) by L1372 , L1374 , L1411 , TARSKI:def 2;
L1413: D99 = ( C491 . C488 ) by L1412;
consider C494 , C495 being Real such that L1414: (C494 = ( C491 . C489 ) & C495 = ( C491 . C490 )) and L1415: ( C494 + C495 ) = 1 and L1416: (C494 >= ( 0 ) & C495 >= ( 0 )) by L1373 , L1375 , L1411 , L1205;
L1417: ( ( D99 + C494 ) + C495 ) = 1 by L1415;
thus L1418: thesis by L1417 , L1414 , L1416 , L1413;
end;
suppose L1419: ( Carrier C491 ) = { C488 , C490 };

set D100 = ( 0 );
L1420: (not C489 in ( Carrier C491 )) by L1372 , L1373 , L1419 , TARSKI:def 2;
L1421: D100 = ( C491 . C489 ) by L1420;
consider C496 , C497 being Real such that L1422: (C496 = ( C491 . C488 ) & C497 = ( C491 . C490 )) and L1423: ( C496 + C497 ) = 1 and L1424: (C496 >= ( 0 ) & C497 >= ( 0 )) by L1374 , L1375 , L1419 , L1205;
L1425: ( ( C496 + D100 ) + C497 ) = 1 by L1423;
thus L1426: thesis by L1425 , L1422 , L1424 , L1421;
end;
suppose L1427: ( Carrier C491 ) = { C488 , C489 , C490 };

thus L1428: thesis by L1427 , L1372 , L1373 , L1374 , L1375 , L1280;
end;
end;
thus L1430: thesis by L1378 , L1372 , L1373 , L1374 , L1236;
end;
begin
definition
let C498 being non  empty CLSStruct;
let C499 being (Subset of C498);
func Convex-Family C499 -> (Subset-Family of C498) means 
:L1431: (for B453 being (Subset of C498) holds (B453 in it iff (B453 is  convex & C499 c= B453)));
existence
proof
defpred S6[ (Subset of C498) ] means ($1 is  convex & C499 c= $1);
thus L1432: (ex B454 being (Subset-Family of C498) st (for B455 being (Subset of C498) holds (B455 in B454 iff S6[ B455 ]))) from SUBSET_1:sch 3;
end;
uniqueness
proof
let C500 , C501 being (Subset-Family of C498);
assume that
L1433: (for B456 being (Subset of C498) holds (B456 in C500 iff (B456 is  convex & C499 c= B456)))
and
L1434: (for B457 being (Subset of C498) holds (B457 in C501 iff (B457 is  convex & C499 c= B457)));
L1435: (for B458 being (Subset of C498) holds (B458 in C500 iff B458 in C501))
proof
let C502 being (Subset of C498);
thus L1436:now
assume L1437: C502 in C500;
L1438: (C502 is  convex & C499 c= C502) by L1437 , L1433;
thus L1439: C502 in C501 by L1438 , L1434;
end;
assume L1440: C502 in C501;
L1441: (C502 is  convex & C499 c= C502) by L1440 , L1434;
thus L1442: thesis by L1441 , L1433;
end;
thus L1443: thesis by L1435 , SETFAM_1:31;
end;
end;
definition
let C503 being non  empty CLSStruct;
let C504 being (Subset of C503);
func conv C504 ->  convex (Subset of C503) equals 
( meet ( Convex-Family C504 ) );
coherence
proof
L1445: (for B459 being (Subset of C503) holds (B459 in ( Convex-Family C504 ) implies B459 is  convex)) by L1431;
thus L1446: thesis by L1445 , L957;
end;
end;
theorem
L1448: (for B460 being non  empty CLSStruct holds (for B461 being (Subset of B460) holds (for B462 being  convex (Subset of B460) holds (B461 c= B462 implies ( conv B461 ) c= B462))))
proof
let C505 being non  empty CLSStruct;
let C506 being (Subset of C505);
let C507 being  convex (Subset of C505);
assume L1449: C506 c= C507;
L1450: C507 in ( Convex-Family C506 ) by L1449 , L1431;
thus L1451: thesis by L1450 , SETFAM_1:3;
end;
