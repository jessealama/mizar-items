:: The Construction and Computation of Conditional Statements for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, RELAT_1,
      XBOOLE_0, GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_1, FUNCT_4,
      TARSKI, TURING_1, SCMFSA_7, SCMPDS_4, AMISTD_2, COMPLEX1, VALUED_1,
      SCMFSA6B, MSUALG_1, SCMPDS_5, SCMFSA8A, AMI_3, ARYTM_1, UNIALG_2,
      SCMFSA7B, SCMFSA8B, NAT_1, STRUCT_0, SCMPDS_6, ORDINAL1, PARTFUN1,
      EXTPRO_1, SCMFSA6C, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, XCMPLX_0, RELAT_1, FUNCT_1, CARD_1,
      PARTFUN1, VALUED_1, NUMBERS, COMPLEX1, FUNCT_4, INT_1, ORDINAL1, NAT_1,
      STRUCT_0, MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMI_2, SCMPDS_2,
      SCMPDS_4, SCMPDS_5, XXREAL_0;
 constructors REAL_1, INT_2, SCMPDS_4, SCMPDS_5, FUNCT_4, PRE_POLY, RELSET_1,
      DOMAIN_1;
 registrations XXREAL_0, XREAL_0, NAT_1, INT_1, SCMPDS_2, SCMPDS_4, SCMPDS_5,
      ORDINAL1, XBOOLE_0, MEMSTR_0, AFINSQ_1, COMPOS_1, FUNCT_4, RELAT_1,
      AMI_3, COMPOS_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, SCMPDS_4, MEMSTR_0;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, ABSVALUE, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      VALUED_1, PARTFUN1, MEMSTR_0, AFINSQ_1, COMPOS_1, EXTPRO_1, PBOOLE,
      RELAT_1;
 schemes NAT_1;

begin
set D1 = ( NAT );
set D2 = ( SCM-Data-Loc );
L1: ( ( Stop ( SCMPDS ) ) . ( 0 ) ) = ( halt ( SCMPDS ) ) by AFINSQ_1:34;
L2: ( 0 ) in ( dom ( Stop ( SCMPDS ) ) ) by COMPOS_1:3;
canceled 5;
theorem
L3: (for R4 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds ( card ( R4 ';' R11 ) ) = ( ( card R11 ) + 1 )))
proof
let R4 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
thus L4: ( card ( R4 ';' R11 ) ) = ( card ( ( Load R4 ) ';' R11 ) )
.= ( ( card ( Load R4 ) ) + ( card R11 ) ) by AFINSQ_1:17
.= ( ( card R11 ) + 1 ) by COMPOS_1:54;
end;
theorem
L5: (for R4 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds ( ( R4 ';' R11 ) . ( 0 ) ) = R4))
proof
let R4 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
L6: (( R4 ';' R11 ) = ( ( Load R4 ) ';' R11 ) & ( 0 ) in ( dom ( Load R4 ) )) by COMPOS_1:50;
thus L7: ( ( R4 ';' R11 ) . ( 0 ) ) = ( ( Load R4 ) . ( 0 ) ) by L6 , AFINSQ_1:def 3
.= R4 by COMPOS_1:52;
end;
canceled 3;
theorem
L8: (for R4 being (Instruction of ( SCMPDS )) holds (for R6 being (State of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds ( CurInstr (( R14 +* ( stop ( R4 ';' R11 ) ) ) , ( Initialize R6 )) ) = R4))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R6 being (State of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
set D3 = ( R4 ';' R11 );
set D4 = ( R14 +* ( stop ( R4 ';' R11 ) ) );
L9: ( 0 ) in ( dom ( Load R4 ) ) by COMPOS_1:50;
L10: ( card D3 ) = ( ( card R11 ) + 1 ) by L3;
L11: ( 0 ) in ( dom D3 ) by L10 , AFINSQ_1:66;
L12: D3 c= ( stop D3 ) by AFINSQ_1:74;
L13: ( dom D3 ) c= ( dom ( stop D3 ) ) by L12 , RELAT_1:11;
L14: ( 0 ) in ( dom ( stop D3 ) ) by L13 , L11;
L15: ( ( R14 +* ( stop ( R4 ';' R11 ) ) ) /. ( IC ( Initialize R6 ) ) ) = ( ( R14 +* ( stop ( R4 ';' R11 ) ) ) . ( IC ( Initialize R6 ) ) ) by PBOOLE:143;
L16: ( D4 . ( 0 ) ) = ( ( R14 +* ( stop ( R4 ';' R11 ) ) ) . ( 0 ) )
.= ( ( stop D3 ) . ( 0 ) ) by L14 , FUNCT_4:13
.= ( D3 . ( 0 ) ) by L11 , COMPOS_1:63
.= ( ( ( Load R4 ) ';' R11 ) . ( 0 ) )
.= ( ( Load R4 ) . ( 0 ) ) by L9 , AFINSQ_1:def 3
.= R4 by COMPOS_1:52;
thus L17: thesis by L16 , L15 , MEMSTR_0:47;
end;
theorem
L18: (for B1 being (State of ( SCMPDS )) holds (for B2 , B3 being (Element of ( NAT )) holds (( IC B1 ) = B2 implies ( ICplusConst (B1 , B3) ) = ( B2 + B3 ))))
proof
let C1 being (State of ( SCMPDS ));
let C2 , C3 being (Element of ( NAT ));
L19: (ex R1 being (Element of ( NAT )) st (R1 = ( IC C1 ) & ( ICplusConst (C1 , C3) ) = ( abs ( R1 + C3 ) ))) by SCMPDS_2:def 18;
thus L20: thesis by L19 , ABSVALUE:def 1;
end;
theorem
L21: (for B4 , B5 being (Program of ( SCMPDS )) holds ( Shift (( stop B5 ) , ( card B4 )) ) c= ( stop ( B4 ';' B5 ) ))
proof
let C4 , C5 being (Program of ( SCMPDS ));
L22: ( stop ( C4 ';' C5 ) ) = ( ( C4 ';' C5 ) ';' ( Stop ( SCMPDS ) ) )
.= ( C4 ';' ( C5 ';' ( Stop ( SCMPDS ) ) ) ) by AFINSQ_1:27
.= ( C4 ';' ( stop C5 ) );
L23: ( stop ( C4 ';' C5 ) ) = ( C4 +* ( Shift (( stop C5 ) , ( card C4 )) ) ) by L22;
thus L24: thesis by L23 , FUNCT_4:25;
end;
canceled 1;
theorem
L25: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B6 being ( 0 ) -started (State of ( SCMPDS )) holds (for B7 being  No-StopCode  parahalting (Instruction of ( SCMPDS )) holds (for B8 being  parahalting  shiftable (Program of ( SCMPDS )) holds (for B9 being Int_position holds ( ( IExec (( B7 ';' B8 ) , R14 , B6) ) . B9 ) = ( ( IExec (B8 , R14 , ( Initialize ( Exec (B7 , B6) ) )) ) . B9 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C6 being ( 0 ) -started (State of ( SCMPDS ));
let C7 being  No-StopCode  parahalting (Instruction of ( SCMPDS ));
let C8 being  parahalting  shiftable (Program of ( SCMPDS ));
let C9 being Int_position;
thus L26: ( ( IExec (( C7 ';' C8 ) , R14 , C6) ) . C9 ) = ( ( IExec (( ( Load C7 ) ';' C8 ) , R14 , C6) ) . C9 )
.= ( ( IExec (C8 , R14 , ( Initialize ( IExec (( Load C7 ) , R14 , C6) ) )) ) . C9 ) by SCMPDS_5:35
.= ( ( IExec (C8 , R14 , ( Initialize ( Exec (C7 , C6) ) )) ) . C9 ) by SCMPDS_5:40;
end;
theorem
L27: (for B10 being Int_position holds (for B11 , B12 being Integer holds ( (B10 , B11) <>0_goto B12 ) <> ( halt ( SCMPDS ) )))
proof
L28: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by COMPOS_1:70;
thus L29: thesis by L28 , SCMPDS_2:16;
end;
theorem
L30: (for B13 being Int_position holds (for B14 , B15 being Integer holds ( (B13 , B14) <=0_goto B15 ) <> ( halt ( SCMPDS ) )))
proof
L31: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by COMPOS_1:70;
thus L32: thesis by L31 , SCMPDS_2:17;
end;
theorem
L33: (for B16 being Int_position holds (for B17 , B18 being Integer holds ( (B16 , B17) >=0_goto B18 ) <> ( halt ( SCMPDS ) )))
proof
L34: ( InsCode ( halt ( SCMPDS ) ) ) = ( 0 ) by COMPOS_1:70;
thus L35: thesis by L34 , SCMPDS_2:18;
end;
definition
let R9 being Integer;
func Goto R9 -> (Program of ( SCMPDS )) equals 
( Load ( goto R9 ) );
coherence;
end;
registration
let C10 being (Element of ( NAT ));
cluster ( goto ( C10 + 1 ) ) ->  No-StopCode;
correctness by SCMPDS_5:21;
cluster ( goto ( - ( C10 + 1 ) ) ) ->  No-StopCode;
correctness by SCMPDS_5:21;
end;
registration
let C11 being (Element of ( NAT ));
cluster ( Goto ( C11 + 1 ) ) ->  halt-free;
correctness;
cluster ( Goto ( - ( C11 + 1 ) ) ) ->  halt-free;
correctness;
end;
theorem
L39: (for R9 being Integer holds (( 0 ) in ( dom ( Goto R9 ) ) & ( ( Goto R9 ) . ( 0 ) ) = ( goto R9 ))) by AFINSQ_1:34 , AFINSQ_1:65;
begin
definition
let C12 being (Program of ( SCMPDS ));
let C13 being (State of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
pred C12 is_closed_on C13 , R14
means
:L40: (for B19 being (Element of ( NAT )) holds ( IC ( Comput (( R14 +* ( stop C12 ) ) , ( Initialize C13 ) , B19) ) ) in ( dom ( stop C12 ) ))
;pred C12 is_halting_on C13 , R14
means
:L41: ( R14 +* ( stop C12 ) ) halts_on ( Initialize C13 )
;end;
theorem
L43: (for B20 being (Program of ( SCMPDS )) holds (B20 is  paraclosed iff (for B21 being (State of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds B20 is_closed_on B21 , R14))))
proof
let C14 being (Program of ( SCMPDS ));
thus L44:now
assume L45: C14 is  paraclosed;
let C15 being (State of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
L46: ( stop C14 ) c= ( R14 +* ( stop C14 ) ) by FUNCT_4:25;
L47: (for R2 being (Element of ( NAT )) holds ( IC ( Comput (( R14 +* ( stop C14 ) ) , ( Initialize C15 ) , R2) ) ) in ( dom ( stop C14 ) )) by L46 , L45 , SCMPDS_4:def 6;
thus L48: C14 is_closed_on C15 , R14 by L47 , L40;
end;
assume L49: (for B22 being (State of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds C14 is_closed_on B22 , R14));
let C16 being ( 0 ) -started (State of ( SCMPDS ));
let C17 being (Element of ( NAT ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
L50: ( Initialize C16 ) = C16 by MEMSTR_0:44;
assume L51: ( stop C14 ) c= R14;
L52: R14 = ( R14 +* ( stop C14 ) ) by L51 , FUNCT_4:98;
L53: C14 is_closed_on C16 , R14 by L49;
thus L54: ( IC ( Comput (R14 , C16 , C17) ) ) in ( dom ( stop C14 ) ) by L53 , L50 , L52 , L40;
end;
theorem
L55: (for B23 being (Program of ( SCMPDS )) holds (B23 is  parahalting iff (for B24 being (State of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds B23 is_halting_on B24 , R14))))
proof
let C18 being (Program of ( SCMPDS ));
thus L56:now
assume L57: C18 is  parahalting;
let C19 being (State of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
L58: ( stop C18 ) c= ( R14 +* ( stop C18 ) ) by FUNCT_4:25;
L59: ( R14 +* ( stop C18 ) ) halts_on ( Initialize C19 ) by L58 , L57 , SCMPDS_4:def 7;
thus L60: C18 is_halting_on C19 , R14 by L59 , L41;
end;
assume L61: (for B25 being (State of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds C18 is_halting_on B25 , R14));
let C20 being ( 0 ) -started (State of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
L62: ( Initialize C20 ) = C20 by MEMSTR_0:44;
assume L63: ( stop C18 ) c= R14;
L64: R14 = ( R14 +* ( stop C18 ) ) by L63 , FUNCT_4:98;
L65: C18 is_halting_on C20 , R14 by L61;
thus L66: R14 halts_on C20 by L65 , L64 , L41 , L62;
end;
theorem
L67: (for R15 being (Instruction-Sequence of ( SCMPDS )) holds (for R16 being (Instruction-Sequence of ( SCMPDS )) holds (for B26 , B27 being (State of ( SCMPDS )) holds (for B28 being (Program of ( SCMPDS )) holds (( DataPart B26 ) = ( DataPart B27 ) implies (B28 is_closed_on B26 , R15 implies B28 is_closed_on B27 , R16))))))
proof
let R15 being (Instruction-Sequence of ( SCMPDS ));
let R16 being (Instruction-Sequence of ( SCMPDS ));
let C21 , C22 being (State of ( SCMPDS ));
let C23 being (Program of ( SCMPDS ));
set D5 = ( stop C23 );
set D6 = ( Initialize C21 );
set D7 = ( Initialize C22 );
set D8 = ( R15 +* D5 );
set D9 = ( R16 +* D5 );
assume L68: ( DataPart C21 ) = ( DataPart C22 );
L69: ( Comput (D9 , D7 , ( 0 )) ) = ( Initialize C22 ) by EXTPRO_1:2;
L70: ( Comput (D8 , D6 , ( 0 )) ) = ( Initialize C21 ) by EXTPRO_1:2;
L71: ( DataPart ( Comput (D8 , D6 , ( 0 )) ) ) = ( DataPart C21 ) by L70 , MEMSTR_0:45
.= ( DataPart ( Comput (D9 , D7 , ( 0 )) ) ) by L68 , L69 , MEMSTR_0:45;
defpred S1[ (Element of ( NAT )) ] means (( IC ( Comput (D8 , D6 , $1) ) ) = ( IC ( Comput (D9 , D7 , $1) ) ) & ( CurInstr (D8 , ( Comput (D8 , D6 , $1) )) ) = ( CurInstr (D9 , ( Comput (D9 , D7 , $1) )) ) & ( DataPart ( Comput (D8 , D6 , $1) ) ) = ( DataPart ( Comput (D9 , D7 , $1) ) ));
L72: ( 0 ) in ( dom D5 ) by COMPOS_1:36;
assume L73: C23 is_closed_on C21 , R15;
L74:
now
let C24 being (Element of ( NAT ));
L75: ( Comput (D9 , D7 , ( C24 + 1 )) ) = ( Following (D9 , ( Comput (D9 , D7 , C24) )) ) by EXTPRO_1:3;
assume L76: S1[ C24 ];
L77: (for R3 being Int_position holds ( ( Comput (D8 , D6 , C24) ) . R3 ) = ( ( Comput (D9 , D7 , C24) ) . R3 )) by L76 , SCMPDS_4:8;
L78: D5 c= ( R16 +* D5 ) by FUNCT_4:25;
L79: D5 c= D9 by L78;
L80: ( IC ( Comput (D8 , D6 , ( C24 + 1 )) ) ) in ( dom D5 ) by L73 , L40;
L81: ( Comput (D8 , D6 , ( C24 + 1 )) ) = ( Following (D8 , ( Comput (D8 , D6 , C24) )) ) by EXTPRO_1:3;
L82: ( Comput (D8 , D6 , C24) ) = ( Comput (D9 , D7 , C24) ) by L76 , L77 , SCMPDS_4:2;
L83: ( Comput (D8 , D6 , ( C24 + 1 )) ) = ( Comput (D9 , D7 , ( C24 + 1 )) ) by L82 , L76 , L75 , L81;
L84: ( Comput (D8 , D6 , ( C24 + 1 )) ) = ( Comput (D9 , D7 , ( C24 + 1 )) ) by L83;
L85: ( IC ( Comput (D8 , D6 , ( C24 + 1 )) ) ) = ( IC ( Comput (D9 , D7 , ( C24 + 1 )) ) ) by L83;
L86: ( D8 /. ( IC ( Comput (D8 , D6 , ( C24 + 1 )) ) ) ) = ( D8 . ( IC ( Comput (D8 , D6 , ( C24 + 1 )) ) ) ) by PBOOLE:143;
L87: ( D9 /. ( IC ( Comput (D9 , D7 , ( C24 + 1 )) ) ) ) = ( D9 . ( IC ( Comput (D9 , D7 , ( C24 + 1 )) ) ) ) by PBOOLE:143;
L88: D5 c= ( R15 +* D5 ) by FUNCT_4:25;
L89: D5 c= D8 by L88;
L90: ( CurInstr (D8 , ( Comput (D8 , D6 , ( C24 + 1 )) )) ) = ( D5 . ( IC ( Comput (D8 , D6 , ( C24 + 1 )) ) ) ) by L89 , L80 , L86 , GRFUNC_1:2
.= ( CurInstr (D9 , ( Comput (D9 , D7 , ( C24 + 1 )) )) ) by L79 , L85 , L80 , L87 , GRFUNC_1:2;
thus L91: S1[ ( C24 + 1 ) ] by L90 , L84;
end;
L92: ( IC ( Comput (D9 , D7 , ( 0 )) ) ) = ( IC D7 ) by L69
.= ( 0 ) by MEMSTR_0:def 11;
L93: ( D8 /. ( IC ( Comput (D8 , D6 , ( 0 )) ) ) ) = ( D8 . ( IC ( Comput (D8 , D6 , ( 0 )) ) ) ) by PBOOLE:143;
L94: ( D9 /. ( IC ( Comput (D9 , D7 , ( 0 )) ) ) ) = ( D9 . ( IC ( Comput (D9 , D7 , ( 0 )) ) ) ) by PBOOLE:143;
L95: ( IC ( Comput (D8 , D6 , ( 0 )) ) ) = ( IC D6 ) by L70
.= ( 0 ) by MEMSTR_0:def 11;
L96: ( CurInstr (D8 , ( Comput (D8 , D6 , ( 0 )) )) ) = ( D5 . ( 0 ) ) by L95 , L72 , L93 , FUNCT_4:13
.= ( CurInstr (D9 , ( Comput (D9 , D7 , ( 0 )) )) ) by L92 , L72 , L94 , FUNCT_4:13;
L97: S1[ ( 0 ) ] by L96 , L95 , L92 , L71;
L98:
now
let C25 being (Element of ( NAT ));
L99: (for B29 being (Element of ( NAT )) holds S1[ B29 ]) from NAT_1:sch 1(L97 , L74);
L100: ( IC ( Comput (D8 , D6 , C25) ) ) in ( dom D5 ) by L73 , L40;
thus L101: ( IC ( Comput (D9 , D7 , C25) ) ) in ( dom D5 ) by L100 , L99;
end;
thus L102: thesis by L98 , L40;
end;
theorem
L103: (for R15 being (Instruction-Sequence of ( SCMPDS )) holds (for R16 being (Instruction-Sequence of ( SCMPDS )) holds (for B30 , B31 being (State of ( SCMPDS )) holds (for B32 being (Program of ( SCMPDS )) holds (( DataPart B30 ) = ( DataPart B31 ) implies ((B32 is_closed_on B30 , R15 & B32 is_halting_on B30 , R15) implies (B32 is_closed_on B31 , R16 & B32 is_halting_on B31 , R16)))))))
proof
let R15 being (Instruction-Sequence of ( SCMPDS ));
let R16 being (Instruction-Sequence of ( SCMPDS ));
let C26 , C27 being (State of ( SCMPDS ));
let C28 being (Program of ( SCMPDS ));
set D10 = ( stop C28 );
set D11 = ( Initialize C26 );
set D12 = ( Initialize C27 );
set D13 = ( R15 +* D10 );
set D14 = ( R16 +* D10 );
defpred S2[ (Element of ( NAT )) ] means (( IC ( Comput (D13 , D11 , $1) ) ) = ( IC ( Comput (D14 , D12 , $1) ) ) & ( CurInstr (D13 , ( Comput (D13 , D11 , $1) )) ) = ( CurInstr (D14 , ( Comput (D14 , D12 , $1) )) ) & ( DataPart ( Comput (D13 , D11 , $1) ) ) = ( DataPart ( Comput (D14 , D12 , $1) ) ));
L104: ( Comput (D13 , D11 , ( 0 )) ) = ( Initialize C26 ) by EXTPRO_1:2;
L105: ( Comput (D14 , D12 , ( 0 )) ) = ( Initialize C27 ) by EXTPRO_1:2;
assume L106: ( DataPart C26 ) = ( DataPart C27 );
L107: ( Comput (D13 , D11 , ( 0 )) ) = ( Comput (D14 , D12 , ( 0 )) ) by L106 , L104 , L105 , MEMSTR_0:80;
L108: ( 0 ) in ( dom D10 ) by COMPOS_1:36;
assume L109: C28 is_closed_on C26 , R15;
L110:
now
let C29 being (Element of ( NAT ));
L111: ( Comput (D14 , D12 , ( C29 + 1 )) ) = ( Following (D14 , ( Comput (D14 , D12 , C29) )) ) by EXTPRO_1:3;
assume L112: S2[ C29 ];
L113: (for R3 being Int_position holds ( ( Comput (D13 , D11 , C29) ) . R3 ) = ( ( Comput (D14 , D12 , C29) ) . R3 )) by L112 , SCMPDS_4:8;
L114: ( Comput (D13 , D11 , C29) ) = ( Comput (D14 , D12 , C29) ) by L113 , L112 , SCMPDS_4:2;
L115: D10 c= D14 by FUNCT_4:25;
L116: ( IC ( Comput (D13 , D11 , ( C29 + 1 )) ) ) in ( dom D10 ) by L109 , L40;
L117: ( Comput (D13 , D11 , ( C29 + 1 )) ) = ( Following (D13 , ( Comput (D13 , D11 , C29) )) ) by EXTPRO_1:3;
L118: ( Comput (D13 , D11 , ( C29 + 1 )) ) = ( Comput (D14 , D12 , ( C29 + 1 )) ) by L117 , L112 , L114 , L111;
L119: ( IC ( Comput (D13 , D11 , ( C29 + 1 )) ) ) = ( IC ( Comput (D14 , D12 , ( C29 + 1 )) ) ) by L118;
L120: ( D13 /. ( IC ( Comput (D13 , D11 , ( C29 + 1 )) ) ) ) = ( D13 . ( IC ( Comput (D13 , D11 , ( C29 + 1 )) ) ) ) by PBOOLE:143;
L121: ( D14 /. ( IC ( Comput (D14 , D12 , ( C29 + 1 )) ) ) ) = ( D14 . ( IC ( Comput (D14 , D12 , ( C29 + 1 )) ) ) ) by PBOOLE:143;
L122: D10 c= D13 by FUNCT_4:25;
L123: ( CurInstr (D13 , ( Comput (D13 , D11 , ( C29 + 1 )) )) ) = ( D10 . ( IC ( Comput (D13 , D11 , ( C29 + 1 )) ) ) ) by L122 , L116 , L120 , GRFUNC_1:2
.= ( CurInstr (D14 , ( Comput (D14 , D12 , ( C29 + 1 )) )) ) by L115 , L119 , L116 , L121 , GRFUNC_1:2;
thus L124: S2[ ( C29 + 1 ) ] by L123 , L118;
end;
L125: ( IC ( Comput (D14 , D12 , ( 0 )) ) ) = ( IC D12 ) by L105
.= ( 0 ) by MEMSTR_0:def 11;
assume L126: C28 is_halting_on C26 , R15;
L127: ( R15 +* D10 ) halts_on ( Initialize C26 ) by L126 , L41;
consider R1 being (Element of ( NAT )) such that L128: ( CurInstr (D13 , ( Comput (D13 , D11 , R1) )) ) = ( halt ( SCMPDS ) ) by L127 , EXTPRO_1:29;
L129: ( D13 /. ( IC ( Comput (D13 , D11 , ( 0 )) ) ) ) = ( D13 . ( IC ( Comput (D13 , D11 , ( 0 )) ) ) ) by PBOOLE:143;
L130: ( D14 /. ( IC ( Comput (D14 , D12 , ( 0 )) ) ) ) = ( D14 . ( IC ( Comput (D14 , D12 , ( 0 )) ) ) ) by PBOOLE:143;
L131: ( IC ( Comput (D13 , D11 , ( 0 )) ) ) = ( IC D11 ) by L104
.= ( 0 ) by MEMSTR_0:def 11;
L132: ( CurInstr (D13 , ( Comput (D13 , D11 , ( 0 )) )) ) = ( D10 . ( 0 ) ) by L131 , L108 , L129 , FUNCT_4:13
.= ( CurInstr (D14 , ( Comput (D14 , D12 , ( 0 )) )) ) by L125 , L108 , L130 , FUNCT_4:13;
L133: S2[ ( 0 ) ] by L132 , L107;
L134:
now
let C30 being (Element of ( NAT ));
L135: (for B33 being (Element of ( NAT )) holds S2[ B33 ]) from NAT_1:sch 1(L133 , L110);
L136: ( IC ( Comput (D13 , D11 , C30) ) ) in ( dom D10 ) by L109 , L40;
thus L137: ( IC ( Comput (D14 , D12 , C30) ) ) in ( dom D10 ) by L136 , L135;
end;
thus L138: C28 is_closed_on C27 , R16 by L134 , L40;
L139: (for B34 being (Element of ( NAT )) holds S2[ B34 ]) from NAT_1:sch 1(L133 , L110);
L140: ( CurInstr (D14 , ( Comput (D14 , D12 , R1) )) ) = ( halt ( SCMPDS ) ) by L139 , L128;
L141: ( R16 +* D10 ) halts_on ( Initialize C27 ) by L140 , EXTPRO_1:29;
thus L142: thesis by L141 , L41;
end;
theorem
L143: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B35 being (State of ( SCMPDS )) holds (for B36 , B37 being (Program of ( SCMPDS )) holds (B36 is_closed_on B35 , R14 iff B36 is_closed_on ( Initialize B35 ) , ( R14 +* B37 )))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C31 being (State of ( SCMPDS ));
let C32 , C33 being (Program of ( SCMPDS ));
L144: ( DataPart C31 ) = ( DataPart ( Initialize C31 ) ) by MEMSTR_0:45;
thus L145: thesis by L144 , L67;
end;
theorem
L146: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B38 being ( 0 ) -started (State of ( SCMPDS )) holds (for B39 , B40 being (Program of ( SCMPDS )) holds ((B39 is_closed_on B38 , R14 & B39 is_halting_on B38 , R14) implies ((for B41 being (Element of ( NAT )) holds (B41 <= ( LifeSpan (( R14 +* ( stop B39 ) ) , B38) ) implies ( IC ( Comput (( R14 +* ( stop B39 ) ) , B38 , B41) ) ) = ( IC ( Comput (( R14 +* ( stop ( B39 ';' B40 ) ) ) , B38 , B41) ) ))) & ( DataPart ( Comput (( R14 +* ( stop B39 ) ) , B38 , ( LifeSpan (( R14 +* ( stop B39 ) ) , B38) )) ) ) = ( DataPart ( Comput (( R14 +* ( stop ( B39 ';' B40 ) ) ) , B38 , ( LifeSpan (( R14 +* ( stop B39 ) ) , B38) )) ) ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C34 being ( 0 ) -started (State of ( SCMPDS ));
let C35 , C36 being (Program of ( SCMPDS ));
assume L147: C35 is_closed_on C34 , R14;
L148: ( Initialize C34 ) = C34 by MEMSTR_0:44;
set D15 = ( stop C35 );
set D16 = ( stop ( C35 ';' C36 ) );
set D17 = ( R14 +* D15 );
defpred S3[ (Element of ( NAT )) ] means ($1 <= ( LifeSpan (D17 , C34) ) implies ( Comput (D17 , C34 , $1) ) = ( Comput (( D17 +* D16 ) , C34 , $1) ));
assume L149: C35 is_halting_on C34 , R14;
L150: D17 halts_on C34 by L149 , L41 , L148;
L151: (for R1 being (Element of ( NAT )) holds (S3[ R1 ] implies S3[ ( R1 + 1 ) ]))
proof
set D18 = ( C36 ';' ( Stop ( SCMPDS ) ) );
set D19 = ( D17 +* D16 );
let R1 being (Element of ( NAT ));
assume L152: (R1 <= ( LifeSpan (D17 , C34) ) implies ( Comput (D17 , C34 , R1) ) = ( Comput (( D17 +* D16 ) , C34 , R1) ));
L153: D16 c= D19 by FUNCT_4:25;
L154: ( Comput (D17 , C34 , ( R1 + 1 )) ) = ( Following (D17 , ( Comput (D17 , C34 , R1) )) ) by EXTPRO_1:3;
L155: D16 = ( ( C35 ';' C36 ) ';' ( Stop ( SCMPDS ) ) )
.= ( C35 ';' D18 ) by AFINSQ_1:27;
L156: ( dom ( C35 ';' D18 ) ) = ( dom ( C35 +* ( Shift (D18 , ( card C35 )) ) ) )
.= ( ( dom C35 ) \/ ( dom ( Shift (D18 , ( card C35 )) ) ) ) by FUNCT_4:def 1;
L157: ( dom C35 ) c= ( dom ( C35 ';' D18 ) ) by L156 , XBOOLE_1:7;
L158: ( Comput (D19 , C34 , ( R1 + 1 )) ) = ( Following (D19 , ( Comput (D19 , C34 , R1) )) ) by EXTPRO_1:3;
L159: ( IC ( Comput (D17 , C34 , R1) ) ) in ( dom D15 ) by L147 , L40 , L148;
L160: ( D17 /. ( IC ( Comput (D17 , C34 , R1) ) ) ) = ( D17 . ( IC ( Comput (D17 , C34 , R1) ) ) ) by PBOOLE:143;
L161: D15 c= D17 by FUNCT_4:25;
L162: ( CurInstr (D17 , ( Comput (D17 , C34 , R1) )) ) = ( D15 . ( IC ( Comput (D17 , C34 , R1) ) ) ) by L161 , L159 , L160 , GRFUNC_1:2;
assume L163: ( R1 + 1 ) <= ( LifeSpan (D17 , C34) );
L164: R1 < ( LifeSpan (D17 , C34) ) by L163 , NAT_1:13;
L165: ( D15 . ( IC ( Comput (D17 , C34 , R1) ) ) ) <> ( halt ( SCMPDS ) ) by L164 , L150 , L162 , EXTPRO_1:def 15;
L166: ( IC ( Comput (D17 , C34 , R1) ) ) in ( dom C35 ) by L165 , L159 , COMPOS_1:51;
L167: ( D19 /. ( IC ( Comput (D19 , C34 , R1) ) ) ) = ( D19 . ( IC ( Comput (D19 , C34 , R1) ) ) ) by PBOOLE:143;
L168: ( CurInstr (D17 , ( Comput (D17 , C34 , R1) )) ) = ( ( C35 ';' ( Stop ( SCMPDS ) ) ) . ( IC ( Comput (D17 , C34 , R1) ) ) ) by L162
.= ( C35 . ( IC ( Comput (D17 , C34 , R1) ) ) ) by L166 , AFINSQ_1:def 3
.= ( D16 . ( IC ( Comput (D17 , C34 , R1) ) ) ) by L166 , L155 , AFINSQ_1:def 3
.= ( D19 . ( IC ( Comput (D17 , C34 , R1) ) ) ) by L153 , L166 , L155 , L157 , GRFUNC_1:2
.= ( CurInstr (D19 , ( Comput (D19 , C34 , R1) )) ) by L152 , L163 , L167 , NAT_1:13;
thus L169: thesis by L168 , L152 , L163 , L154 , L158 , NAT_1:13;
end;
L170: (( Comput (D17 , C34 , ( 0 )) ) = C34 & ( Comput (( D17 +* D16 ) , C34 , ( 0 )) ) = C34) by EXTPRO_1:2;
L171: S3[ ( 0 ) ] by L170;
L172: (for R1 being (Element of ( NAT )) holds S3[ R1 ]) from NAT_1:sch 1(L171 , L151);
L173: ( ( R14 +* D15 ) +* D16 ) = ( R14 +* ( D15 +* D16 ) ) by FUNCT_4:14
.= ( R14 +* D16 ) by SCMPDS_5:14;
thus L174: (for B42 being (Element of ( NAT )) holds (B42 <= ( LifeSpan (D17 , C34) ) implies ( IC ( Comput (D17 , C34 , B42) ) ) = ( IC ( Comput (( R14 +* D16 ) , C34 , B42) ) ))) by L172 , L173;
L175: ( Comput (( R14 +* ( stop C35 ) ) , C34 , ( LifeSpan (( R14 +* ( stop C35 ) ) , C34) )) ) = ( Comput (( R14 +* ( stop ( C35 ';' C36 ) ) ) , C34 , ( LifeSpan (( R14 +* ( stop C35 ) ) , C34) )) ) by L173 , L172;
thus L176: ( DataPart ( Comput (( R14 +* ( stop C35 ) ) , C34 , ( LifeSpan (( R14 +* ( stop C35 ) ) , C34) )) ) ) = ( DataPart ( Comput (( R14 +* ( stop ( C35 ';' C36 ) ) ) , C34 , ( LifeSpan (( R14 +* ( stop C35 ) ) , C34) )) ) ) by L175;
end;
theorem
L177: (for R6 being (State of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B43 being (Program of ( SCMPDS )) holds (for B44 being (Element of ( NAT )) holds ((B43 is_closed_on R6 , R14 & B43 is_halting_on R6 , R14 & B44 < ( LifeSpan (( R14 +* ( stop B43 ) ) , ( Initialize R6 )) )) implies ( IC ( Comput (( R14 +* ( stop B43 ) ) , ( Initialize R6 ) , B44) ) ) in ( dom B43 ))))))
proof
let R6 being (State of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C37 being (Program of ( SCMPDS ));
let C38 being (Element of ( NAT ));
set D20 = ( Initialize R6 );
set D21 = ( R14 +* ( stop C37 ) );
set D22 = ( LifeSpan (D21 , D20) );
set D23 = ( Stop ( SCMPDS ) );
assume that
L178: C37 is_closed_on R6 , R14
and
L179: C37 is_halting_on R6 , R14
and
L180: C38 < D22;
set D24 = ( Comput (D21 , D20 , C38) );
set D25 = ( IC D24 );
L181: D25 in ( dom ( stop C37 ) ) by L178 , L40;
reconsider D26 = D25 as (Element of ( NAT ));
L182: ( stop C37 ) c= D21 by FUNCT_4:25;
L183: D21 halts_on D20 by L179 , L41;
L184:
now
L185: ( D21 /. ( IC D24 ) ) = ( D21 . ( IC D24 ) ) by PBOOLE:143;
assume L186: D26 = ( card C37 );
L187: ( CurInstr (D21 , D24) ) = ( D21 . D25 ) by L185
.= ( ( stop C37 ) . ( ( 0 ) + D26 ) ) by L181 , L182 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L186 , L1 , L2 , AFINSQ_1:def 3;
thus L188: contradiction by L187 , L180 , L183 , EXTPRO_1:def 15;
end;
L189: ( card ( stop C37 ) ) = ( ( card C37 ) + 1 ) by COMPOS_1:55;
L190: D26 < ( ( card C37 ) + 1 ) by L189 , L181 , AFINSQ_1:66;
L191: D26 <= ( card C37 ) by L190 , INT_1:7;
L192: D26 < ( card C37 ) by L191 , L184 , XXREAL_0:1;
thus L193: thesis by L192 , AFINSQ_1:66;
end;
theorem
L194: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B45 , B46 being (Program of ( SCMPDS )) holds (for B47 being ( 0 ) -started (State of ( SCMPDS )) holds (for B48 being (Element of ( NAT )) holds ((B45 is_closed_on B47 , R14 & B45 is_halting_on B47 , R14 & B48 < ( LifeSpan (( R14 +* ( stop B45 ) ) , B47) )) implies ( CurInstr (( R14 +* ( stop B45 ) ) , ( Comput (( R14 +* ( stop B45 ) ) , B47 , B48) )) ) = ( CurInstr (( R14 +* ( stop ( B45 ';' B46 ) ) ) , ( Comput (( R14 +* ( stop ( B45 ';' B46 ) ) ) , B47 , B48) )) ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C39 , C40 being (Program of ( SCMPDS ));
let C41 being ( 0 ) -started (State of ( SCMPDS ));
let C42 being (Element of ( NAT ));
set D27 = ( R14 +* ( stop C39 ) );
set D28 = ( R14 +* ( stop ( C39 ';' C40 ) ) );
set D29 = ( Comput (D27 , C41 , C42) );
set D30 = ( Comput (D28 , C41 , C42) );
set D31 = D27;
set D32 = D28;
set D33 = ( Stop ( SCMPDS ) );
assume that
L195: C39 is_closed_on C41 , R14
and
L196: (C39 is_halting_on C41 , R14 & C42 < ( LifeSpan (D27 , C41) ));
L197: ( Initialize C41 ) = C41 by MEMSTR_0:44;
L198: ( IC D29 ) in ( dom C39 ) by L197 , L195 , L196 , L177;
L199: ( IC D29 ) = ( IC D30 ) by L195 , L196 , L146;
L200: ( IC D29 ) in ( dom ( stop C39 ) ) by L195 , L40 , L197;
L201: (( dom ( stop C39 ) ) c= ( dom ( stop ( C39 ';' C40 ) ) ) & ( stop ( C39 ';' C40 ) ) c= D28) by FUNCT_4:25 , SCMPDS_5:13;
L202: ( stop C39 ) c= D27 by FUNCT_4:25;
L203: ( stop ( C39 ';' C40 ) ) = ( ( C39 ';' C40 ) ';' D33 )
.= ( C39 ';' ( C40 ';' D33 ) ) by AFINSQ_1:27;
L204: ( D31 /. ( IC D29 ) ) = ( D31 . ( IC D29 ) ) by PBOOLE:143;
L205: ( D32 /. ( IC D30 ) ) = ( D32 . ( IC D30 ) ) by PBOOLE:143;
thus L206: ( CurInstr (D27 , D29) ) = ( D27 . ( IC D29 ) ) by L204
.= ( ( stop C39 ) . ( IC D29 ) ) by L200 , L202 , GRFUNC_1:2
.= ( C39 . ( IC D29 ) ) by L198 , AFINSQ_1:def 3
.= ( ( stop ( C39 ';' C40 ) ) . ( IC D29 ) ) by L198 , L203 , AFINSQ_1:def 3
.= ( D28 . ( IC D30 ) ) by L199 , L200 , L201 , GRFUNC_1:2
.= ( CurInstr (D28 , D30) ) by L205;
end;
theorem
L207: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B49 being  halt-free (Program of ( SCMPDS )) holds (for B50 being (State of ( SCMPDS )) holds (for B51 being (Element of ( NAT )) holds ((B49 is_closed_on B50 , R14 & B49 is_halting_on B50 , R14 & B51 < ( LifeSpan (( R14 +* ( stop B49 ) ) , ( Initialize B50 )) )) implies ( CurInstr (( R14 +* ( stop B49 ) ) , ( Comput (( R14 +* ( stop B49 ) ) , ( Initialize B50 ) , B51) )) ) <> ( halt ( SCMPDS ) ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C43 being  halt-free (Program of ( SCMPDS ));
let C44 being (State of ( SCMPDS ));
let C45 being (Element of ( NAT ));
set D34 = ( Initialize C44 );
set D35 = ( R14 +* ( stop C43 ) );
set D36 = ( Comput (D35 , D34 , C45) );
set D37 = D35;
assume L208: (C43 is_closed_on C44 , R14 & C43 is_halting_on C44 , R14 & C45 < ( LifeSpan (D35 , D34) ));
L209: ( IC D36 ) in ( dom C43 ) by L208 , L177;
L210: ( D37 /. ( IC D36 ) ) = ( D37 . ( IC D36 ) ) by PBOOLE:143;
L211: ( stop C43 ) c= D35 by FUNCT_4:25;
L212: C43 c= ( stop C43 ) by AFINSQ_1:74;
L213: C43 c= D35 by L212 , L211 , XBOOLE_1:1;
L214: ( CurInstr (D37 , D36) ) = ( C43 . ( IC D36 ) ) by L213 , L209 , L210 , GRFUNC_1:2;
thus L215: thesis by L214 , L209 , COMPOS_1:def 27;
end;
theorem
L216: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B52 being  halt-free (Program of ( SCMPDS )) holds (for B53 being (State of ( SCMPDS )) holds ((B52 is_closed_on B53 , R14 & B52 is_halting_on B53 , R14) implies ( IC ( Comput (( R14 +* ( stop B52 ) ) , ( Initialize B53 ) , ( LifeSpan (( R14 +* ( stop B52 ) ) , ( Initialize B53 )) )) ) ) = ( card B52 )))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C46 being  halt-free (Program of ( SCMPDS ));
let C47 being (State of ( SCMPDS ));
set D38 = ( Initialize C47 );
set D39 = ( R14 +* ( stop C46 ) );
assume that
L217: C46 is_closed_on C47 , R14
and
L218: C46 is_halting_on C47 , R14;
set D40 = ( Comput (D39 , D38 , ( LifeSpan (D39 , D38) )) );
reconsider D41 = ( IC D40 ) as (Element of ( NAT ));
L219: ( stop C46 ) c= D39 by FUNCT_4:25;
L220: C46 c= ( stop C46 ) by AFINSQ_1:74;
L221: C46 c= D39 by L220 , L219 , XBOOLE_1:1;
L222: D39 halts_on D38 by L218 , L41;
L223:
now
L224: ( D39 /. ( IC D40 ) ) = ( D39 . ( IC D40 ) ) by PBOOLE:143;
assume L225: ( IC D40 ) in ( dom C46 );
L226: ( C46 . ( IC D40 ) ) = ( D39 . ( IC D40 ) ) by L225 , L221 , GRFUNC_1:2
.= ( CurInstr (D39 , D40) ) by L224
.= ( halt ( SCMPDS ) ) by L222 , EXTPRO_1:def 15;
thus L227: contradiction by L226 , L225 , COMPOS_1:def 27;
end;
L228: D41 >= ( card C46 ) by L223 , AFINSQ_1:66;
L229: ( card ( stop C46 ) ) = ( ( card C46 ) + 1 ) by COMPOS_1:55;
L230: ( IC D40 ) in ( dom ( stop C46 ) ) by L217 , L40;
L231: D41 < ( ( card C46 ) + 1 ) by L230 , L229 , AFINSQ_1:66;
L232: D41 <= ( card C46 ) by L231 , NAT_1:13;
L233: ( IC ( Comput (D39 , D38 , ( LifeSpan (D39 , D38) )) ) ) = ( card C46 ) by L232 , L228 , XXREAL_0:1;
thus L234: thesis by L233;
end;
L235: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B54 being  halt-free (Program of ( SCMPDS )) holds (for B55 being (Program of ( SCMPDS )) holds (for B56 being ( 0 ) -started (State of ( SCMPDS )) holds ((B54 is_closed_on B56 , R14 & B54 is_halting_on B56 , R14) implies (( IC ( Comput (( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) , B56 , ( ( LifeSpan (( R14 +* ( stop B54 ) ) , B56) ) + 1 )) ) ) = ( ( ( card B54 ) + ( card B55 ) ) + 1 ) & ( DataPart ( Comput (( R14 +* ( stop B54 ) ) , B56 , ( LifeSpan (( R14 +* ( stop B54 ) ) , B56) )) ) ) = ( DataPart ( Comput (( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) , B56 , ( ( LifeSpan (( R14 +* ( stop B54 ) ) , B56) ) + 1 )) ) ) & (for B57 being (Element of ( NAT )) holds (B57 <= ( LifeSpan (( R14 +* ( stop B54 ) ) , B56) ) implies ( CurInstr (( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) , ( Comput (( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) , B56 , B57) )) ) <> ( halt ( SCMPDS ) ))) & ( IC ( Comput (( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) , B56 , ( LifeSpan (( R14 +* ( stop B54 ) ) , B56) )) ) ) = ( card B54 ) & ( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) halts_on B56 & ( LifeSpan (( R14 +* ( stop ( ( B54 ';' ( Goto ( ( card B55 ) + 1 ) ) ) ';' B55 ) ) ) , B56) ) = ( ( LifeSpan (( R14 +* ( stop B54 ) ) , B56) ) + 1 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C48 being  halt-free (Program of ( SCMPDS ));
let C49 being (Program of ( SCMPDS ));
let C50 being ( 0 ) -started (State of ( SCMPDS ));
assume L236: C48 is_closed_on C50 , R14;
set D42 = ( Goto ( ( card C49 ) + 1 ) );
set D43 = ( Stop ( SCMPDS ) );
set D44 = ( ( D42 ';' C49 ) ';' D43 );
set D45 = ( ( C48 ';' D42 ) ';' C49 );
set D46 = ( stop D45 );
set D47 = C50;
set D48 = ( R14 +* ( stop C48 ) );
set D49 = C50;
reconsider D50 = ( R14 +* D46 ) as (Instruction-Sequence of ( SCMPDS ));
assume L237: C48 is_halting_on C50 , R14;
L238: ( Initialize C50 ) = C50 by MEMSTR_0:44;
set D51 = ( Comput (D50 , D49 , ( LifeSpan (D48 , D47) )) );
L239: D45 = ( C48 ';' ( D42 ';' C49 ) ) by AFINSQ_1:27;
L240: ( IC ( Comput (D48 , D47 , ( LifeSpan (D48 , D47) )) ) ) = ( IC D51 ) by L239 , L236 , L237 , L146;
L241: ( IC D51 ) = ( card C48 ) by L240 , L236 , L237 , L216 , L238;
L242: ( 0 ) in ( dom D42 ) by L39;
L243: ( D44 . ( 0 ) ) = ( ( D42 ';' ( C49 ';' D43 ) ) . ( 0 ) ) by AFINSQ_1:27
.= ( D42 . ( 0 ) ) by L242 , AFINSQ_1:def 3
.= ( goto ( ( card C49 ) + 1 ) ) by L39;
L244: ( card ( D42 ';' C49 ) ) = ( ( card D42 ) + ( card C49 ) ) by AFINSQ_1:17
.= ( 1 + ( card C49 ) ) by COMPOS_1:54;
L245: ( D44 . ( ( card C49 ) + 1 ) ) = ( D44 . ( ( 0 ) + ( card ( D42 ';' C49 ) ) ) ) by L244
.= ( halt ( SCMPDS ) ) by L1 , L2 , AFINSQ_1:def 3;
L246: ( card D44 ) = ( card ( D42 ';' ( C49 ';' D43 ) ) ) by AFINSQ_1:27
.= ( ( card D42 ) + ( card ( C49 ';' D43 ) ) ) by AFINSQ_1:17
.= ( 1 + ( card ( C49 ';' D43 ) ) ) by COMPOS_1:54;
L247: ( 0 ) in ( dom D44 ) by L246 , AFINSQ_1:66;
L248: D46 = ( ( ( C48 ';' D42 ) ';' C49 ) ';' D43 )
.= ( ( C48 ';' ( D42 ';' C49 ) ) ';' D43 ) by AFINSQ_1:27
.= ( C48 ';' D44 ) by AFINSQ_1:27;
L249: ( card D46 ) = ( ( card C48 ) + ( card D44 ) ) by L248 , AFINSQ_1:17;
L250: ( ( card C48 ) + ( 0 ) ) < ( card D46 ) by L249 , XREAL_1:6;
L251: ( card C48 ) in ( dom D46 ) by L250 , AFINSQ_1:66;
L252: ( card D43 ) = 1 by AFINSQ_1:33;
L253: ( card D44 ) = ( 1 + ( ( card C49 ) + ( card D43 ) ) ) by L246 , AFINSQ_1:17
.= ( ( card C49 ) + ( 1 + ( card D43 ) ) );
L254: ( ( card C49 ) + 1 ) < ( card D44 ) by L253 , L252 , XREAL_1:6;
L255: ( ( card C49 ) + 1 ) in ( dom D44 ) by L254 , AFINSQ_1:66;
L256: ( card D46 ) = ( ( ( ( card C48 ) + ( card C49 ) ) + 1 ) + 1 ) by L249 , L253 , L252;
L257: ( ( ( card C48 ) + ( card C49 ) ) + 1 ) < ( card D46 ) by L256 , NAT_1:13;
L258: ( ( ( card C48 ) + ( card C49 ) ) + 1 ) in ( dom D46 ) by L257 , AFINSQ_1:66;
L259: ( D50 /. ( IC ( Comput (D50 , D49 , ( LifeSpan (D48 , D47) )) ) ) ) = ( D50 . ( IC ( Comput (D50 , D49 , ( LifeSpan (D48 , D47) )) ) ) ) by PBOOLE:143;
L260: ( CurInstr (D50 , ( Comput (D50 , D49 , ( LifeSpan (D48 , D47) )) )) ) = ( D50 . ( card C48 ) ) by L236 , L237 , L240 , L216 , L259 , L238
.= ( D50 . ( card C48 ) )
.= ( D46 . ( card C48 ) ) by L251 , FUNCT_4:13
.= ( ( C48 ';' D44 ) . ( ( 0 ) + ( card C48 ) ) ) by L248
.= ( goto ( ( card C49 ) + 1 ) ) by L247 , L243 , AFINSQ_1:def 3;
L261:
now
let R3 being Int_position;
thus L262: ( ( Comput (D50 , D49 , ( ( LifeSpan (D48 , D47) ) + 1 )) ) . R3 ) = ( ( Following (D50 , D51) ) . R3 ) by EXTPRO_1:3
.= ( D51 . R3 ) by L260 , SCMPDS_2:54;
end;
L263: ( D50 /. ( IC ( Comput (D50 , D49 , ( ( LifeSpan (D48 , D47) ) + 1 )) ) ) ) = ( D50 . ( IC ( Comput (D50 , D49 , ( ( LifeSpan (D48 , D47) ) + 1 )) ) ) ) by PBOOLE:143;
thus L264: ( IC ( Comput (( R14 +* D46 ) , D49 , ( ( LifeSpan (D48 , D47) ) + 1 )) ) ) = ( IC ( Following (D50 , D51) ) ) by EXTPRO_1:3
.= ( ICplusConst (D51 , ( ( card C49 ) + 1 )) ) by L260 , SCMPDS_2:54
.= ( ( card C48 ) + ( ( card C49 ) + 1 ) ) by L241 , L18
.= ( ( ( card C48 ) + ( card C49 ) ) + 1 );
L265: ( CurInstr (D50 , ( Comput (D50 , D49 , ( ( LifeSpan (D48 , D47) ) + 1 )) )) ) = ( D50 . ( ( ( card C48 ) + ( card C49 ) ) + 1 ) ) by L264 , L263
.= ( D46 . ( ( ( card C48 ) + ( card C49 ) ) + 1 ) ) by L258 , FUNCT_4:13
.= ( ( C48 ';' D44 ) . ( ( card C48 ) + ( ( card C49 ) + 1 ) ) ) by L248
.= ( halt ( SCMPDS ) ) by L255 , L245 , AFINSQ_1:def 3;
L266: ( DataPart ( Comput (D48 , D47 , ( LifeSpan (D48 , D47) )) ) ) = ( DataPart D51 ) by L236 , L237 , L239 , L146;
thus L267: ( DataPart ( Comput (D48 , D47 , ( LifeSpan (D48 , D47) )) ) ) = ( DataPart ( Comput (( R14 +* D46 ) , D49 , ( ( LifeSpan (D48 , D47) ) + 1 )) ) ) by L266 , L261 , SCMPDS_4:8;
thus L268:now
let C51 being (Element of ( NAT ));
assume L269: C51 <= ( LifeSpan (D48 , D47) );
per cases ;
suppose L270: C51 < ( LifeSpan (D48 , D47) );

L271: ( CurInstr (D48 , ( Comput (D48 , D47 , C51) )) ) <> ( halt ( SCMPDS ) ) by L270 , L236 , L237 , L207 , L238;
thus L272: ( CurInstr (( R14 +* D46 ) , ( Comput (( R14 +* D46 ) , D49 , C51) )) ) <> ( halt ( SCMPDS ) ) by L271 , L236 , L237 , L239 , L270 , L194;
end;
suppose L273: ( LifeSpan (D48 , D47) ) <= C51;

L274: C51 = ( LifeSpan (D48 , D47) ) by L273 , L269 , XXREAL_0:1;
thus L275: ( CurInstr (( R14 +* D46 ) , ( Comput (( R14 +* D46 ) , D49 , C51) )) ) <> ( halt ( SCMPDS ) ) by L274 , L260;
end;
end;
thus L277: ( IC ( Comput (( R14 +* D46 ) , D49 , ( LifeSpan (D48 , D47) )) ) ) = ( card C48 ) by L236 , L237 , L240 , L216 , L238;
thus L278: ( R14 +* D46 ) halts_on D49 by L265 , EXTPRO_1:29;
L279:
now
let C52 being (Element of ( NAT ));
assume L280: ( CurInstr (D50 , ( Comput (D50 , D49 , C52) )) ) = ( halt ( SCMPDS ) );
L281: ( LifeSpan (D48 , D47) ) < C52 by L280 , L268;
thus L282: ( ( LifeSpan (D48 , D47) ) + 1 ) <= C52 by L281 , INT_1:7;
end;
thus L283: thesis by L279 , L265 , L278 , EXTPRO_1:def 15;
end;
theorem
L284: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B58 , B59 being (Program of ( SCMPDS )) holds (for B60 being ( 0 ) -started (State of ( SCMPDS )) holds ((B58 is_closed_on B60 , R14 & B58 is_halting_on B60 , R14) implies (( ( B58 ';' ( Goto ( ( card B59 ) + 1 ) ) ) ';' B59 ) is_halting_on B60 , R14 & ( ( B58 ';' ( Goto ( ( card B59 ) + 1 ) ) ) ';' B59 ) is_closed_on B60 , R14)))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C53 , C54 being (Program of ( SCMPDS ));
let C55 being ( 0 ) -started (State of ( SCMPDS ));
set D52 = ( Goto ( ( card C54 ) + 1 ) );
set D53 = ( ( C53 ';' D52 ) ';' C54 );
set D54 = ( C53 ';' ( D52 ';' C54 ) );
set D55 = ( stop D54 );
set D56 = ( stop C53 );
set D57 = ( R14 +* D56 );
set D58 = ( R14 +* D55 );
set D59 = ( LifeSpan (D57 , C55) );
set D60 = ( Stop ( SCMPDS ) );
set D61 = ( Comput (D57 , C55 , D59) );
set D62 = ( Comput (D58 , C55 , D59) );
set D63 = D57;
set D64 = D58;
L285: ( Initialize C55 ) = C55 by MEMSTR_0:44;
L286: D53 = ( C53 ';' ( D52 ';' C54 ) ) by AFINSQ_1:27;
L287: C53 c= ( stop C53 ) by AFINSQ_1:74;
L288: D56 c= D63 by FUNCT_4:25;
L289: C53 c= D63 by L288 , L287 , XBOOLE_1:1;
L290: ( dom D56 ) c= ( dom D55 ) by SCMPDS_5:13;
set D65 = ( ( D52 ';' C54 ) ';' D60 );
reconsider D66 = ( IC D61 ) as (Element of ( NAT ));
L291: ( card D56 ) = ( ( card C53 ) + 1 ) by COMPOS_1:55;
assume L292: C53 is_closed_on C55 , R14;
L293: ( IC D61 ) in ( dom D56 ) by L292 , L40 , L285;
L294: D66 < ( ( card C53 ) + 1 ) by L293 , L291 , AFINSQ_1:66;
L295: D66 <= ( card C53 ) by L294 , INT_1:7;
L296: D55 c= D58 by FUNCT_4:25;
L297: D55 = ( ( C53 ';' ( D52 ';' C54 ) ) ';' D60 )
.= ( C53 ';' D65 ) by AFINSQ_1:27;
L298: C53 c= D55 by L297 , AFINSQ_1:74;
L299: C53 c= D58 by L298 , L296 , XBOOLE_1:1;
L300: C53 c= D64 by L299;
assume L301: C53 is_halting_on C55 , R14;
L302: D57 halts_on C55 by L301 , L41 , L285;
L303: ( D63 /. ( IC D61 ) ) = ( D63 . ( IC D61 ) ) by PBOOLE:143;
L304: ( D64 /. ( IC D62 ) ) = ( D64 . ( IC D62 ) ) by PBOOLE:143;
per cases ;
suppose L305: ( IC D61 ) <> ( card C53 );

L306: D66 < ( card C53 ) by L305 , L295 , XXREAL_0:1;
L307: ( IC D61 ) in ( dom C53 ) by L306 , AFINSQ_1:66;
L308: ( halt ( SCMPDS ) ) = ( CurInstr (D57 , D61) ) by L302 , EXTPRO_1:def 15
.= ( C53 . ( IC D61 ) ) by L289 , L307 , L303 , GRFUNC_1:2
.= ( D64 . ( IC D61 ) ) by L300 , L307 , GRFUNC_1:2
.= ( CurInstr (D64 , D62) ) by L292 , L301 , L146 , L304;
L309: D58 halts_on C55 by L308 , EXTPRO_1:29;
thus L310: D53 is_halting_on C55 , R14 by L309 , L286 , L41 , L285;
L311:
now
let C56 being (Element of ( NAT ));
set D67 = ( IC ( Comput (D57 , C55 , C56) ) );
set D68 = ( IC ( Comput (D58 , C55 , C56) ) );
per cases ;
suppose L312: C56 <= D59;

L313: D67 in ( dom D56 ) by L292 , L40 , L285;
L314: D67 in ( dom D55 ) by L313 , L290;
thus L315: D68 in ( dom D55 ) by L314 , L292 , L301 , L312 , L146;
end;
suppose L316: C56 > D59;

set D69 = ( LifeSpan (D58 , C55) );
L317: D69 <= D59 by L308 , L309 , EXTPRO_1:def 15;
L318: D68 = ( IC ( Comput (D58 , C55 , D69) ) ) by L317 , L309 , L316 , EXTPRO_1:25 , XXREAL_0:2
.= ( IC ( Comput (D57 , C55 , D69) ) ) by L292 , L301 , L317 , L146;
L319: D68 in ( dom D56 ) by L318 , L292 , L40 , L285;
thus L320: D68 in ( dom D55 ) by L319 , L290;
end;
end;
thus L322: thesis by L311 , L286 , L40 , L285;
end;
suppose L323: ( IC D61 ) = ( card C53 );

L324: ( IC D62 ) = ( card C53 ) by L323 , L292 , L301 , L146;
L325: ( 0 ) in ( dom D52 ) by L39;
L326: ( card ( Stop ( SCMPDS ) ) ) = 1 by AFINSQ_1:33;
L327: D65 = ( D52 ';' ( C54 ';' D60 ) ) by AFINSQ_1:27;
L328: ( card D65 ) = ( ( card D52 ) + ( card ( C54 ';' D60 ) ) ) by L327 , AFINSQ_1:17
.= ( 1 + ( card ( C54 ';' D60 ) ) ) by COMPOS_1:54
.= ( ( ( card C54 ) + 1 ) + 1 ) by L326 , AFINSQ_1:17;
L329: ( 0 ) in ( dom D65 ) by L328 , AFINSQ_1:66;
L330: ( ( card C54 ) + 1 ) < ( card D65 ) by L328 , NAT_1:13;
L331: ( ( card C54 ) + 1 ) in ( dom D65 ) by L330 , AFINSQ_1:66;
L332: ( card D55 ) = ( ( card C53 ) + ( ( card C54 ) + ( 1 + 1 ) ) ) by L297 , L328 , AFINSQ_1:17
.= ( ( ( ( card C53 ) + ( card C54 ) ) + 1 ) + 1 );
L333: ( ( ( card C53 ) + ( card C54 ) ) + 1 ) < ( card D55 ) by L332 , NAT_1:13;
L334: ( ( ( card C53 ) + ( card C54 ) ) + 1 ) in ( dom D55 ) by L333 , AFINSQ_1:66;
L335: ( D64 /. ( IC D62 ) ) = ( D64 . ( IC D62 ) ) by PBOOLE:143;
L336: ( card D55 ) = ( ( card C53 ) + ( card D65 ) ) by L297 , AFINSQ_1:17;
L337: ( ( card C53 ) + ( 0 ) ) < ( card D55 ) by L336 , XREAL_1:6;
L338: ( card C53 ) in ( dom D55 ) by L337 , AFINSQ_1:66;
L339: ( CurInstr (D64 , D62) ) = ( D64 . ( card C53 ) ) by L292 , L301 , L323 , L146 , L335
.= ( D58 . ( card C53 ) )
.= ( ( C53 ';' D65 ) . ( ( 0 ) + ( card C53 ) ) ) by L297 , L296 , L338 , GRFUNC_1:2
.= ( D65 . ( 0 ) ) by L329 , AFINSQ_1:def 3
.= ( D52 . ( 0 ) ) by L327 , L325 , AFINSQ_1:def 3
.= ( goto ( ( card C54 ) + 1 ) ) by L39;
L340: ( card ( D52 ';' C54 ) ) = ( ( card D52 ) + ( card C54 ) ) by AFINSQ_1:17
.= ( 1 + ( card C54 ) ) by COMPOS_1:54;
L341: ( D65 . ( ( card C54 ) + 1 ) ) = ( D65 . ( ( 0 ) + ( card ( D52 ';' C54 ) ) ) ) by L340
.= ( halt ( SCMPDS ) ) by L1 , L2 , AFINSQ_1:def 3;
L342: ( D58 /. ( IC ( Comput (D58 , C55 , ( D59 + 1 )) ) ) ) = ( D58 . ( IC ( Comput (D58 , C55 , ( D59 + 1 )) ) ) ) by PBOOLE:143;
L343: ( IC ( Comput (D58 , C55 , ( D59 + 1 )) ) ) = ( IC ( Following (D58 , D62) ) ) by EXTPRO_1:3
.= ( ICplusConst (D62 , ( ( card C54 ) + 1 )) ) by L339 , SCMPDS_2:54
.= ( ( card C53 ) + ( ( card C54 ) + 1 ) ) by L324 , L18
.= ( ( ( card C53 ) + ( card C54 ) ) + 1 );
L344: ( CurInstr (D58 , ( Comput (D58 , C55 , ( D59 + 1 )) )) ) = ( D58 . ( ( ( card C53 ) + ( card C54 ) ) + 1 ) ) by L343 , L342
.= ( ( C53 ';' D65 ) . ( ( card C53 ) + ( ( card C54 ) + 1 ) ) ) by L297 , L296 , L334 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L331 , L341 , AFINSQ_1:def 3;
L345: D58 halts_on C55 by L344 , EXTPRO_1:29;
thus L346: D53 is_halting_on C55 , R14 by L345 , L286 , L41 , L285;
L347:
now
let C57 being (Element of ( NAT ));
set D70 = ( IC ( Comput (D57 , C55 , C57) ) );
set D71 = ( IC ( Comput (D58 , C55 , C57) ) );
per cases ;
suppose L348: C57 <= D59;

L349: D70 in ( dom D56 ) by L292 , L40 , L285;
L350: D70 in ( dom D55 ) by L349 , L290;
thus L351: D71 in ( dom D55 ) by L350 , L292 , L301 , L348 , L146;
end;
suppose L352: C57 > D59;

set D72 = ( LifeSpan (D58 , C55) );
L353: D72 <= ( D59 + 1 ) by L344 , L345 , EXTPRO_1:def 15;
L354: C57 >= ( D59 + 1 ) by L352 , INT_1:7;
L355: D71 = ( IC ( Comput (D58 , C55 , D72) ) ) by L354 , L345 , L353 , EXTPRO_1:25 , XXREAL_0:2
.= ( ( ( card C53 ) + ( card C54 ) ) + 1 ) by L343 , L345 , L353 , EXTPRO_1:25;
thus L356: D71 in ( dom D55 ) by L355 , L333 , AFINSQ_1:66;
end;
end;
thus L358: thesis by L347 , L286 , L40 , L285;
end;
end;
theorem
L360: (for R8 being (State of ( SCMPDS )) holds (for R15 being (Instruction-Sequence of ( SCMPDS )) holds (for R16 being (Instruction-Sequence of ( SCMPDS )) holds (for B61 being ( 0 ) -started (State of ( SCMPDS )) holds (for B62 being  shiftable (Program of ( SCMPDS )) holds ((( stop B62 ) c= R15 & B62 is_closed_on B61 , R15) implies (for B63 being (Element of ( NAT )) holds ((( Shift (( stop B62 ) , B63) ) c= R16 & ( IC R8 ) = B63 & ( DataPart B61 ) = ( DataPart R8 )) implies (for B64 being (Element of ( NAT )) holds (( ( IC ( Comput (R15 , B61 , B64) ) ) + B63 ) = ( IC ( Comput (R16 , R8 , B64) ) ) & ( CurInstr (R15 , ( Comput (R15 , B61 , B64) )) ) = ( CurInstr (R16 , ( Comput (R16 , R8 , B64) )) ) & ( DataPart ( Comput (R15 , B61 , B64) ) ) = ( DataPart ( Comput (R16 , R8 , B64) ) )))))))))))
proof
let R8 being (State of ( SCMPDS ));
let R15 being (Instruction-Sequence of ( SCMPDS ));
let R16 being (Instruction-Sequence of ( SCMPDS ));
let C58 being ( 0 ) -started (State of ( SCMPDS ));
let C59 being  shiftable (Program of ( SCMPDS ));
set D73 = ( stop C59 );
assume that
L361: D73 c= R15
and
L362: C59 is_closed_on C58 , R15;
L363: ( Initialize C58 ) = C58 by MEMSTR_0:44;
let C60 being (Element of ( NAT ));
defpred S4[ (Element of ( NAT )) ] means (( ( IC ( Comput (R15 , C58 , $1) ) ) + C60 ) = ( IC ( Comput (R16 , R8 , $1) ) ) & ( CurInstr (R15 , ( Comput (R15 , C58 , $1) )) ) = ( CurInstr (R16 , ( Comput (R16 , R8 , $1) )) ) & ( DataPart ( Comput (R15 , C58 , $1) ) ) = ( DataPart ( Comput (R16 , R8 , $1) ) ));
assume that
L364: ( Shift (D73 , C60) ) c= R16
and
L365: ( IC R8 ) = C60
and
L366: ( DataPart C58 ) = ( DataPart R8 );
let C61 being (Element of ( NAT ));
L367: ( DataPart ( Comput (R15 , C58 , ( 0 )) ) ) = ( DataPart R8 ) by L366 , EXTPRO_1:2
.= ( DataPart ( Comput (R16 , R8 , ( 0 )) ) ) by EXTPRO_1:2;
L368: ( 0 ) in ( dom D73 ) by COMPOS_1:36;
L369: ( ( 0 ) + C60 ) in ( dom ( Shift (D73 , C60) ) ) by L368 , VALUED_1:24;
L370: ( R15 . ( IC C58 ) ) = ( R15 . ( IC ( Initialize C58 ) ) ) by L363
.= ( R15 . ( 0 ) ) by MEMSTR_0:def 11
.= ( D73 . ( 0 ) ) by L361 , L368 , GRFUNC_1:2;
L371: R15 = ( R15 +* D73 ) by L361 , FUNCT_4:98;
L372: (for B65 being (Element of ( NAT )) holds (S4[ B65 ] implies S4[ ( B65 + 1 ) ]))
proof
let C62 being (Element of ( NAT ));
assume L373: S4[ C62 ];
reconsider D74 = ( IC ( Comput (R15 , C58 , C62) ) ) as (Element of ( NAT ));
set D75 = ( CurInstr (R15 , ( Comput (R15 , C58 , C62) )) );
L374: ( Comput (R15 , C58 , ( C62 + 1 )) ) = ( Following (R15 , ( Comput (R15 , C58 , C62) )) ) by EXTPRO_1:3;
reconsider D76 = ( IC ( Comput (R15 , C58 , ( C62 + 1 )) ) ) as (Element of ( NAT ));
L375: ( IC ( Comput (R15 , C58 , ( C62 + 1 )) ) ) in ( dom D73 ) by L362 , L371 , L40 , L363;
L376: ( D76 + C60 ) in ( dom ( Shift (D73 , C60) ) ) by L375 , VALUED_1:24;
L377: ( Comput (R16 , R8 , ( C62 + 1 )) ) = ( Following (R16 , ( Comput (R16 , R8 , C62) )) ) by EXTPRO_1:3;
L378: ( IC ( Comput (R15 , C58 , C62) ) ) in ( dom D73 ) by L362 , L371 , L40 , L363;
L379: ( R15 /. ( IC ( Comput (R15 , C58 , C62) ) ) ) = ( R15 . ( IC ( Comput (R15 , C58 , C62) ) ) ) by PBOOLE:143;
L380: D75 = ( R15 . ( IC ( Comput (R15 , C58 , C62) ) ) ) by L379
.= ( D73 . ( IC ( Comput (R15 , C58 , C62) ) ) ) by L361 , L378 , GRFUNC_1:2;
L381: (( InsCode D75 ) <> 1 & ( InsCode D75 ) <> 3) by L380 , L378 , SCMPDS_4:def 9;
L382: D75 valid_at D74 by L378 , L380 , SCMPDS_4:def 9;
thus L383: ( ( IC ( Comput (R15 , C58 , ( C62 + 1 )) ) ) + C60 ) = ( IC ( Comput (R16 , R8 , ( C62 + 1 )) ) ) by L382 , L373 , L374 , L377 , L381 , SCMPDS_4:28;
L384: ( R15 /. ( IC ( Comput (R15 , C58 , ( C62 + 1 )) ) ) ) = ( R15 . ( IC ( Comput (R15 , C58 , ( C62 + 1 )) ) ) ) by PBOOLE:143;
L385: ( R16 /. ( IC ( Comput (R16 , R8 , ( C62 + 1 )) ) ) ) = ( R16 . ( IC ( Comput (R16 , R8 , ( C62 + 1 )) ) ) ) by PBOOLE:143;
L386: ( CurInstr (R15 , ( Comput (R15 , C58 , ( C62 + 1 )) )) ) = ( R15 . D76 ) by L384
.= ( D73 . D76 ) by L361 , L375 , GRFUNC_1:2
.= ( D73 . D76 );
thus L387: ( CurInstr (R15 , ( Comput (R15 , C58 , ( C62 + 1 )) )) ) = ( ( Shift (D73 , C60) ) . ( IC ( Comput (R16 , R8 , ( C62 + 1 )) ) ) ) by L386 , L383 , L375 , VALUED_1:def 12
.= ( R16 . ( IC ( Comput (R16 , R8 , ( C62 + 1 )) ) ) ) by L364 , L383 , L376 , GRFUNC_1:2
.= ( CurInstr (R16 , ( Comput (R16 , R8 , ( C62 + 1 )) )) ) by L385;
thus L388: thesis by L373 , L374 , L377 , L381 , L382 , SCMPDS_4:28;
end;
L389: ( IC ( Comput (R15 , C58 , ( 0 )) ) ) = ( IC C58 ) by EXTPRO_1:2
.= ( IC ( Initialize C58 ) ) by L363
.= ( 0 ) by MEMSTR_0:def 11;
L390: ( Comput (R15 , C58 , ( 0 )) ) = C58 by EXTPRO_1:2;
L391: ( Comput (R16 , R8 , ( 0 )) ) = R8 by EXTPRO_1:2;
L392: ( R16 /. ( IC R8 ) ) = ( R16 . ( IC R8 ) ) by PBOOLE:143;
L393: ( R15 /. ( IC C58 ) ) = ( R15 . ( IC C58 ) ) by PBOOLE:143;
L394: ( CurInstr (R15 , ( Comput (R15 , C58 , ( 0 )) )) ) = ( CurInstr (R15 , C58) ) by L390
.= ( ( Shift (D73 , C60) ) . ( ( 0 ) + C60 ) ) by L368 , L370 , L393 , VALUED_1:def 12
.= ( CurInstr (R16 , R8) ) by L364 , L365 , L369 , L392 , GRFUNC_1:2
.= ( CurInstr (R16 , ( Comput (R16 , R8 , ( 0 )) )) ) by L391;
L395: S4[ ( 0 ) ] by L394 , L365 , L389 , L367 , EXTPRO_1:2;
L396: (for B66 being (Element of ( NAT )) holds S4[ B66 ]) from NAT_1:sch 1(L395 , L372);
thus L397: thesis by L396;
end;
theorem
L398: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B67 being ( 0 ) -started (State of ( SCMPDS )) holds (for B68 being  halt-free (Program of ( SCMPDS )) holds (for B69 being (Program of ( SCMPDS )) holds ((B68 is_closed_on B67 , R14 & B68 is_halting_on B67 , R14) implies ( IC ( IExec (( ( B68 ';' ( Goto ( ( card B69 ) + 1 ) ) ) ';' B69 ) , R14 , B67) ) ) = ( ( ( card B68 ) + ( card B69 ) ) + 1 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C63 being ( 0 ) -started (State of ( SCMPDS ));
let C64 being  halt-free (Program of ( SCMPDS ));
let C65 being (Program of ( SCMPDS ));
set D77 = ( ( LifeSpan (( R14 +* ( stop C64 ) ) , ( Initialize C63 )) ) + 1 );
set D78 = ( Goto ( ( card C65 ) + 1 ) );
set D79 = ( R14 +* ( stop ( ( C64 ';' D78 ) ';' C65 ) ) );
L399: ( Initialize C63 ) = C63 by MEMSTR_0:44;
assume L400: (C64 is_closed_on C63 , R14 & C64 is_halting_on C63 , R14);
L401: (D79 halts_on C63 & ( LifeSpan (D79 , C63) ) = D77) by L400 , L235 , L399;
L402: ( IC ( Result (D79 , C63) ) ) = ( IC ( Comput (D79 , C63 , D77) ) ) by L401 , EXTPRO_1:23
.= ( ( ( card C64 ) + ( card C65 ) ) + 1 ) by L400 , L235 , L399;
thus L403: thesis by L402;
end;
theorem
L404: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B70 being ( 0 ) -started (State of ( SCMPDS )) holds (for B71 being  halt-free (Program of ( SCMPDS )) holds (for B72 being (Program of ( SCMPDS )) holds ((B71 is_closed_on B70 , R14 & B71 is_halting_on B70 , R14) implies ( IExec (( ( B71 ';' ( Goto ( ( card B72 ) + 1 ) ) ) ';' B72 ) , R14 , B70) ) = ( ( IExec (B71 , R14 , B70) ) +* ( Start-At (( ( ( card B71 ) + ( card B72 ) ) + 1 ) , ( SCMPDS )) ) ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C66 being ( 0 ) -started (State of ( SCMPDS ));
let C67 being  halt-free (Program of ( SCMPDS ));
let C68 being (Program of ( SCMPDS ));
set D80 = ( R14 +* ( stop C67 ) );
set D81 = ( ( LifeSpan (D80 , C66) ) + 1 );
set D82 = ( Goto ( ( card C68 ) + 1 ) );
set D83 = ( R14 +* ( stop ( ( C67 ';' D82 ) ';' C68 ) ) );
set D84 = ( ( ( card C67 ) + ( card C68 ) ) + 1 );
assume that
L405: C67 is_closed_on C66 , R14
and
L406: C67 is_halting_on C66 , R14;
L407: ( Initialize C66 ) = C66 by MEMSTR_0:44;
L408: D80 halts_on C66 by L407 , L406 , L41;
L409: (D83 halts_on C66 & ( LifeSpan (D83 , C66) ) = D81) by L405 , L406 , L235;
L410: ( Result (D83 , C66) ) = ( Comput (D83 , C66 , D81) ) by L409 , EXTPRO_1:23;
L411: ( DataPart ( Result (D83 , C66) ) ) = ( DataPart ( Comput (D80 , C66 , ( LifeSpan (D80 , C66) )) ) ) by L410 , L405 , L406 , L235;
L412: ( DataPart ( Result (D83 , C66) ) ) = ( DataPart ( Result (D80 , C66) ) ) by L411 , L408 , EXTPRO_1:23
.= ( DataPart ( ( Result (D80 , C66) ) +* ( Start-At (D84 , ( SCMPDS )) ) ) ) by MEMSTR_0:79;
L413: ( IC ( Result (D83 , C66) ) ) = D84 by L405 , L406 , L410 , L235
.= ( IC ( ( Result (D80 , C66) ) +* ( Start-At (D84 , ( SCMPDS )) ) ) ) by FUNCT_4:113;
L414: ( Result (D83 , C66) ) = ( ( Result (D80 , C66) ) +* ( Start-At (D84 , ( SCMPDS )) ) ) by L413 , L412 , MEMSTR_0:78;
thus L415: ( IExec (( ( C67 ';' D82 ) ';' C68 ) , R14 , C66) ) = ( Result (D83 , C66) )
.= ( ( Result (D80 , C66) ) +* ( Start-At (D84 , ( SCMPDS )) ) ) by L414
.= ( ( IExec (C67 , R14 , C66) ) +* ( Start-At (D84 , ( SCMPDS )) ) );
end;
theorem
L416: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B73 being (State of ( SCMPDS )) holds (for B74 being  halt-free (Program of ( SCMPDS )) holds ((B74 is_closed_on B73 , R14 & B74 is_halting_on B73 , R14) implies ( IC ( IExec (B74 , R14 , ( Initialize B73 )) ) ) = ( card B74 )))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C69 being (State of ( SCMPDS ));
let C70 being  halt-free (Program of ( SCMPDS ));
set D85 = ( Initialize C69 );
set D86 = ( R14 +* ( stop C70 ) );
assume that
L417: C70 is_closed_on C69 , R14
and
L418: C70 is_halting_on C69 , R14;
L419: D86 halts_on D85 by L418 , L41;
thus L420: ( IC ( IExec (C70 , R14 , ( Initialize C69 )) ) ) = ( IC ( Result (D86 , D85) ) )
.= ( IC ( Comput (D86 , D85 , ( LifeSpan (D86 , D85) )) ) ) by L419 , EXTPRO_1:23
.= ( card C70 ) by L417 , L418 , L216;
end;
begin
definition
let C71 being Int_position;
let C72 being Integer;
let C73 , C74 being (Program of ( SCMPDS ));
func if=0 (C71 , C72 , C73 , C74) -> (Program of ( SCMPDS )) equals 
( ( ( ( (C71 , C72) <>0_goto ( ( card C73 ) + 2 ) ) ';' C73 ) ';' ( Goto ( ( card C74 ) + 1 ) ) ) ';' C74 );
coherence;
func if>0 (C71 , C72 , C73 , C74) -> (Program of ( SCMPDS )) equals 
( ( ( ( (C71 , C72) <=0_goto ( ( card C73 ) + 2 ) ) ';' C73 ) ';' ( Goto ( ( card C74 ) + 1 ) ) ) ';' C74 );
coherence;
func if<0 (C71 , C72 , C73 , C74) -> (Program of ( SCMPDS )) equals 
( ( ( ( (C71 , C72) >=0_goto ( ( card C73 ) + 2 ) ) ';' C73 ) ';' ( Goto ( ( card C74 ) + 1 ) ) ) ';' C74 );
coherence;
end;
definition
let C75 being Int_position;
let C76 being Integer;
let C77 being (Program of ( SCMPDS ));
func if=0 (C75 , C76 , C77) -> (Program of ( SCMPDS )) equals 
( ( (C75 , C76) <>0_goto ( ( card C77 ) + 1 ) ) ';' C77 );
coherence;
func if<>0 (C75 , C76 , C77) -> (Program of ( SCMPDS )) equals 
( ( ( (C75 , C76) <>0_goto 2 ) ';' ( goto ( ( card C77 ) + 1 ) ) ) ';' C77 );
coherence;
func if>0 (C75 , C76 , C77) -> (Program of ( SCMPDS )) equals 
( ( (C75 , C76) <=0_goto ( ( card C77 ) + 1 ) ) ';' C77 );
coherence;
func if<=0 (C75 , C76 , C77) -> (Program of ( SCMPDS )) equals 
( ( ( (C75 , C76) <=0_goto 2 ) ';' ( goto ( ( card C77 ) + 1 ) ) ) ';' C77 );
coherence;
func if<0 (C75 , C76 , C77) -> (Program of ( SCMPDS )) equals 
( ( (C75 , C76) >=0_goto ( ( card C77 ) + 1 ) ) ';' C77 );
coherence;
func if>=0 (C75 , C76 , C77) -> (Program of ( SCMPDS )) equals 
( ( ( (C75 , C76) >=0_goto 2 ) ';' ( goto ( ( card C77 ) + 1 ) ) ) ';' C77 );
coherence;
end;
L423: (for R2 being (Element of ( NAT )) holds (for R4 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( card ( ( ( R4 ';' R11 ) ';' ( Goto R2 ) ) ';' R12 ) ) = ( ( ( card R11 ) + ( card R12 ) ) + 2 )))))
proof
let R2 being (Element of ( NAT ));
let R4 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
let R12 being (Program of ( SCMPDS ));
set D87 = ( Goto R2 );
thus L424: ( card ( ( ( R4 ';' R11 ) ';' D87 ) ';' R12 ) ) = ( ( card ( ( R4 ';' R11 ) ';' D87 ) ) + ( card R12 ) ) by AFINSQ_1:17
.= ( ( ( card ( R4 ';' R11 ) ) + ( card D87 ) ) + ( card R12 ) ) by AFINSQ_1:17
.= ( ( ( card ( R4 ';' R11 ) ) + 1 ) + ( card R12 ) ) by COMPOS_1:54
.= ( ( ( ( card R11 ) + 1 ) + 1 ) + ( card R12 ) ) by L3
.= ( ( ( card R11 ) + ( card R12 ) ) + 2 );
end;
begin
theorem
L425: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( card ( if=0 (R3 , R9 , R11 , R12) ) ) = ( ( ( card R11 ) + ( card R12 ) ) + 2 ))))) by L423;
theorem
L426: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( if=0 (R3 , R9 , R11 , R12) ) ) & 1 in ( dom ( if=0 (R3 , R9 , R11 , R12) ) ))))))
proof
let R3 being Int_position;
let R9 being Integer;
let R11 being (Program of ( SCMPDS ));
let R12 being (Program of ( SCMPDS ));
set D88 = ( card ( if=0 (R3 , R9 , R11 , R12) ) );
L427: D88 = ( ( ( card R11 ) + ( card R12 ) ) + 2 ) by L423;
L428: 2 <= D88 by L427 , NAT_1:12;
L429: 1 < D88 by L428 , XXREAL_0:2;
thus L430: thesis by L429 , AFINSQ_1:66;
end;
L431: (for R4 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds (for R13 being (Program of ( SCMPDS )) holds ( ( ( ( R4 ';' R11 ) ';' R12 ) ';' R13 ) . ( 0 ) ) = R4))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
let R12 being (Program of ( SCMPDS ));
let R13 being (Program of ( SCMPDS ));
L432: ( 0 ) in ( dom ( Load R4 ) ) by COMPOS_1:50;
L433: ( ( ( R4 ';' R11 ) ';' R12 ) ';' R13 ) = ( ( R4 ';' ( R11 ';' R12 ) ) ';' R13 ) by SCMPDS_4:14
.= ( R4 ';' ( ( R11 ';' R12 ) ';' R13 ) ) by SCMPDS_4:14
.= ( ( Load R4 ) ';' ( ( R11 ';' R12 ) ';' R13 ) );
thus L434: ( ( ( ( R4 ';' R11 ) ';' R12 ) ';' R13 ) . ( 0 ) ) = ( ( Load R4 ) . ( 0 ) ) by L433 , L432 , AFINSQ_1:def 3
.= R4 by COMPOS_1:52;
end;
theorem
L435: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( ( if=0 (R3 , R9 , R11 , R12) ) . ( 0 ) ) = ( (R3 , R9) <>0_goto ( ( card R11 ) + 2 ) ))))) by L431;
L436: (for R4 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds ( Shift (( stop R11 ) , 1) ) c= ( R14 +* ( stop ( R4 ';' R11 ) ) ))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
set D89 = ( stop R11 );
set D90 = ( R4 ';' R11 );
set D91 = ( stop D90 );
set D92 = ( R14 +* D91 );
L437: (( card ( Load R4 ) ) = 1 & D90 = ( ( Load R4 ) ';' R11 )) by COMPOS_1:54;
L438: ( Shift (D89 , 1) ) c= D91 by L437 , L21;
L439: D91 c= D92 by FUNCT_4:25;
L440: ( Shift (D89 , 1) ) c= D92 by L439 , L438 , XBOOLE_1:1;
thus L441: thesis by L440;
end;
L442: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (for R14 being (Instruction-Sequence of ( SCMPDS )) holds ( Shift (( stop R11 ) , 2) ) c= ( R14 +* ( stop ( ( R4 ';' R5 ) ';' R11 ) ) )))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R5 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
let R14 being (Instruction-Sequence of ( SCMPDS ));
set D93 = ( stop R11 );
set D94 = ( stop ( ( R4 ';' R5 ) ';' R11 ) );
set D95 = ( R14 +* D94 );
L443: ( card ( R4 ';' R5 ) ) = ( card ( ( Load R4 ) ';' ( Load R5 ) ) )
.= ( ( card ( Load R4 ) ) + ( card ( Load R5 ) ) ) by AFINSQ_1:17
.= ( 1 + ( card ( Load R5 ) ) ) by COMPOS_1:54
.= ( 1 + 1 ) by COMPOS_1:54;
L444: ( Shift (D93 , 2) ) c= D94 by L443 , L21;
L445: D94 c= D95 by FUNCT_4:25;
L446: ( Shift (D93 , 2) ) c= D95 by L445 , L444 , XBOOLE_1:1;
thus L447: thesis by L446;
end;
theorem
L448: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B75 being ( 0 ) -started (State of ( SCMPDS )) holds (for B76 , B77 being  shiftable (Program of ( SCMPDS )) holds (for B78 being Int_position holds (for B79 being Integer holds ((( B75 . ( DataLoc (( B75 . B78 ) , B79) ) ) = ( 0 ) & B76 is_closed_on B75 , R14 & B76 is_halting_on B75 , R14) implies (( if=0 (B78 , B79 , B76 , B77) ) is_closed_on B75 , R14 & ( if=0 (B78 , B79 , B76 , B77) ) is_halting_on B75 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C78 being ( 0 ) -started (State of ( SCMPDS ));
let C79 , C80 being  shiftable (Program of ( SCMPDS ));
let C81 being Int_position;
let C82 being Integer;
set D96 = ( DataLoc (( C78 . C81 ) , C82) );
assume L449: ( C78 . D96 ) = ( 0 );
set D97 = ( (C81 , C82) <>0_goto ( ( card C79 ) + 2 ) );
set D98 = ( Goto ( ( card C80 ) + 1 ) );
set D99 = ( ( C79 ';' D98 ) ';' C80 );
set D100 = ( if=0 (C81 , C82 , C79 , C80) );
set D101 = ( stop D100 );
set D102 = ( stop D99 );
set D103 = ( R14 +* D102 );
set D104 = ( R14 +* D101 );
set D105 = ( Comput (D104 , C78 , 1) );
set D106 = D104;
L450: ( Initialize C78 ) = C78 by MEMSTR_0:44;
L451: ( IC C78 ) = ( 0 ) by L450 , MEMSTR_0:47;
L452: D100 = ( ( D97 ';' ( C79 ';' D98 ) ) ';' C80 ) by SCMPDS_4:14
.= ( D97 ';' D99 ) by SCMPDS_4:14;
L453: ( Shift (D102 , 1) ) c= D106 by L452 , L436;
L454: ( Comput (D104 , C78 , ( ( 0 ) + 1 )) ) = ( Following (D104 , ( Comput (D104 , C78 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D104 , C78) ) by EXTPRO_1:2
.= ( Exec (D97 , C78) ) by L452 , L8 , L450;
L455: (for R3 being Int_position holds ( C78 . R3 ) = ( D105 . R3 )) by L454 , SCMPDS_2:55;
L456: ( DataPart C78 ) = ( DataPart D105 ) by L455 , SCMPDS_4:8;
L457: ( C78 . ( DataLoc (( C78 . C81 ) , C82) ) ) = ( C78 . D96 )
.= ( 0 ) by L449;
L458: ( IC D105 ) = ( succ ( IC C78 ) ) by L457 , L454 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L451;
L459: ( 0 ) in ( dom D101 ) by COMPOS_1:36;
assume L460: C79 is_closed_on C78 , R14;
assume L461: C79 is_halting_on C78 , R14;
L462: D99 is_halting_on C78 , R14 by L461 , L460 , L284;
L463: D103 halts_on C78 by L462 , L41 , L450;
L464: D99 is_closed_on C78 , R14 by L460 , L461 , L284;
L465: (( Start-At (( 0 ) , ( SCMPDS )) ) c= C78 & D99 is_closed_on C78 , D103) by L464 , L143 , L450 , FUNCT_4:25;
L466: ( card D101 ) = ( ( card D100 ) + 1 ) by COMPOS_1:55
.= ( ( ( card D99 ) + 1 ) + 1 ) by L452 , L3;
L467: ( stop D99 ) c= D103 by FUNCT_4:25;
L468:
now
let C83 being (Element of ( NAT ));
per cases ;
suppose L469: ( 0 ) < C83;

consider C84 being Nat such that L470: ( C84 + 1 ) = C83 by L469 , NAT_1:6;
reconsider D107 = C84 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D108 = ( IC ( Comput (D103 , C78 , D107) ) ) as (Element of ( NAT ));
L471: ( card D101 ) = ( ( card D102 ) + 1 ) by L466 , COMPOS_1:55;
L472: D108 in ( dom D102 ) by L464 , L40 , L450;
L473: D108 < ( card D102 ) by L472 , AFINSQ_1:66;
L474: ( D108 + 1 ) < ( card D101 ) by L473 , L471 , XREAL_1:6;
L475: ( IC ( Comput (D104 , C78 , C83) ) ) = ( IC ( Comput (D104 , D105 , D107) ) ) by L470 , EXTPRO_1:4
.= ( D108 + 1 ) by L465 , L453 , L458 , L456 , L360 , L467;
thus L476: ( IC ( Comput (D104 , C78 , C83) ) ) in ( dom D101 ) by L475 , L474 , AFINSQ_1:66;
end;
suppose L477: C83 = ( 0 );

thus L478: ( IC ( Comput (D104 , C78 , C83) ) ) in ( dom D101 ) by L477 , L459 , L451 , EXTPRO_1:2;
end;
end;
thus L480: D100 is_closed_on C78 , R14 by L468 , L40 , L450;
L481: ( Comput (D104 , C78 , ( ( LifeSpan (D103 , C78) ) + 1 )) ) = ( Comput (D104 , ( Comput (D104 , C78 , 1) ) , ( LifeSpan (D103 , C78) )) ) by EXTPRO_1:4;
L482: ( CurInstr (D104 , ( Comput (D104 , C78 , ( ( LifeSpan (D103 , C78) ) + 1 )) )) ) = ( CurInstr (D106 , ( Comput (D106 , D105 , ( LifeSpan (D103 , C78) )) )) ) by L481
.= ( CurInstr (D103 , ( Comput (D103 , C78 , ( LifeSpan (D103 , C78) )) )) ) by L465 , L453 , L458 , L456 , L360 , L467
.= ( halt ( SCMPDS ) ) by L463 , EXTPRO_1:def 15;
L483: D104 halts_on C78 by L482 , EXTPRO_1:29;
thus L484: thesis by L483 , L41 , L450;
end;
theorem
L485: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B80 being (State of ( SCMPDS )) holds (for B81 being (Program of ( SCMPDS )) holds (for B82 being  shiftable (Program of ( SCMPDS )) holds (for B83 being Int_position holds (for B84 being Integer holds ((( B80 . ( DataLoc (( B80 . B83 ) , B84) ) ) <> ( 0 ) & B82 is_closed_on B80 , R14 & B82 is_halting_on B80 , R14) implies (( if=0 (B83 , B84 , B81 , B82) ) is_closed_on B80 , R14 & ( if=0 (B83 , B84 , B81 , B82) ) is_halting_on B80 , R14))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C85 being (State of ( SCMPDS ));
let C86 being (Program of ( SCMPDS ));
let C87 being  shiftable (Program of ( SCMPDS ));
let C88 being Int_position;
let C89 being Integer;
set D109 = ( DataLoc (( C85 . C88 ) , C89) );
set D110 = ( stop C87 );
set D111 = ( Initialize C85 );
set D112 = ( R14 +* D110 );
set D113 = ( if=0 (C88 , C89 , C86 , C87) );
set D114 = ( stop D113 );
set D115 = ( Initialize C85 );
set D116 = ( R14 +* D114 );
set D117 = ( Comput (D116 , D115 , 1) );
set D118 = D116;
set D119 = ( (C88 , C89) <>0_goto ( ( card C86 ) + 2 ) );
set D120 = ( Goto ( ( card C87 ) + 1 ) );
set D121 = ( ( D119 ';' C86 ) ';' D120 );
L486: D113 = ( ( D119 ';' ( C86 ';' D120 ) ) ';' C87 ) by SCMPDS_4:14
.= ( D119 ';' ( ( C86 ';' D120 ) ';' C87 ) ) by SCMPDS_4:14;
L487: ( Comput (D116 , D115 , ( ( 0 ) + 1 )) ) = ( Following (D116 , ( Comput (D116 , D115 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D116 , D115) ) by EXTPRO_1:2
.= ( Exec (D119 , D115) ) by L486 , L8;
L488: (not D109 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L489: (not C88 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L490: ( D115 . ( DataLoc (( D115 . C88 ) , C89) ) ) = ( D115 . D109 ) by L489 , FUNCT_4:11
.= ( C85 . D109 ) by L488 , FUNCT_4:11;
L491: ( IC D115 ) = ( 0 ) by MEMSTR_0:47;
assume L492: ( C85 . D109 ) <> ( 0 );
L493: ( IC D117 ) = ( ICplusConst (D115 , ( ( card C86 ) + 2 )) ) by L492 , L487 , L490 , SCMPDS_2:55
.= ( ( 0 ) + ( ( card C86 ) + 2 ) ) by L491 , L18;
assume L494: C87 is_closed_on C85 , R14;
L495: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D111 & C87 is_closed_on D111 , D112) by L494 , L143 , FUNCT_4:25;
L496: D114 c= D116 by FUNCT_4:25;
L497: ( card D121 ) = ( ( card ( D119 ';' C86 ) ) + ( card D120 ) ) by AFINSQ_1:17
.= ( ( card ( D119 ';' C86 ) ) + 1 ) by COMPOS_1:54
.= ( ( ( card C86 ) + 1 ) + 1 ) by L3
.= ( ( card C86 ) + ( 1 + 1 ) );
L498: ( Shift (D110 , ( ( card C86 ) + 2 )) ) c= D114 by L497 , L21;
L499: ( Shift (D110 , ( ( card C86 ) + 2 )) ) c= D118 by L498 , L496 , XBOOLE_1:1;
assume L500: C87 is_halting_on C85 , R14;
L501: D112 halts_on D111 by L500 , L41;
L502: (for R3 being Int_position holds ( D111 . R3 ) = ( D117 . R3 )) by L487 , SCMPDS_2:55;
L503: ( DataPart D111 ) = ( DataPart D117 ) by L502 , SCMPDS_4:8;
L504: D110 c= D112 by FUNCT_4:25;
L505:
now
let C90 being (Element of ( NAT ));
per cases ;
suppose L506: ( 0 ) < C90;

consider C91 being Nat such that L507: ( C91 + 1 ) = C90 by L506 , NAT_1:6;
reconsider D122 = C91 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D123 = ( IC ( Comput (D112 , D111 , D122) ) ) as (Element of ( NAT ));
L508: D123 in ( dom D110 ) by L494 , L40;
L509: D123 < ( card D110 ) by L508 , AFINSQ_1:66;
L510: ( D123 + ( ( card C86 ) + 2 ) ) < ( ( card D110 ) + ( ( card C86 ) + 2 ) ) by L509 , XREAL_1:6;
L511: ( card D110 ) = ( ( card C87 ) + 1 ) by COMPOS_1:55;
L512: ( card D114 ) = ( ( card D113 ) + 1 ) by COMPOS_1:55
.= ( ( ( ( card C86 ) + 2 ) + ( card C87 ) ) + 1 ) by L497 , AFINSQ_1:17
.= ( ( ( card C86 ) + 2 ) + ( card D110 ) ) by L511;
L513: ( IC ( Comput (D116 , D115 , C90) ) ) = ( IC ( Comput (D116 , D117 , D122) ) ) by L507 , EXTPRO_1:4
.= ( D123 + ( ( card C86 ) + 2 ) ) by L495 , L503 , L499 , L493 , L360 , L504;
thus L514: ( IC ( Comput (D116 , D115 , C90) ) ) in ( dom D114 ) by L513 , L512 , L510 , AFINSQ_1:66;
end;
suppose L515: C90 = ( 0 );

L516: ( Comput (D116 , D115 , C90) ) = D115 by L515 , EXTPRO_1:2;
thus L517: ( IC ( Comput (D116 , D115 , C90) ) ) in ( dom D114 ) by L516 , L491 , COMPOS_1:36;
end;
end;
thus L519: D113 is_closed_on C85 , R14 by L505 , L40;
L520: ( Comput (D116 , D115 , ( ( LifeSpan (D112 , D111) ) + 1 )) ) = ( Comput (D116 , ( Comput (D116 , D115 , 1) ) , ( LifeSpan (D112 , D111) )) ) by EXTPRO_1:4;
L521: ( CurInstr (D116 , ( Comput (D116 , D115 , ( ( LifeSpan (D112 , D111) ) + 1 )) )) ) = ( CurInstr (D118 , ( Comput (D118 , D117 , ( LifeSpan (D112 , D111) )) )) ) by L520
.= ( CurInstr (D112 , ( Comput (D112 , D111 , ( LifeSpan (D112 , D111) )) )) ) by L495 , L503 , L499 , L493 , L360 , L504
.= ( halt ( SCMPDS ) ) by L501 , EXTPRO_1:def 15;
L522: D116 halts_on D115 by L521 , EXTPRO_1:29;
thus L523: thesis by L522 , L41;
end;
theorem
L524: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B85 being ( 0 ) -started (State of ( SCMPDS )) holds (for B86 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B87 being  shiftable (Program of ( SCMPDS )) holds (for B88 being Int_position holds (for B89 being Integer holds ((( B85 . ( DataLoc (( B85 . B88 ) , B89) ) ) = ( 0 ) & B86 is_closed_on B85 , R14 & B86 is_halting_on B85 , R14) implies ( IExec (( if=0 (B88 , B89 , B86 , B87) ) , R14 , B85) ) = ( ( IExec (B86 , R14 , B85) ) +* ( Start-At (( ( ( card B86 ) + ( card B87 ) ) + 2 ) , ( SCMPDS )) ) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C92 being ( 0 ) -started (State of ( SCMPDS ));
let C93 being  halt-free  shiftable (Program of ( SCMPDS ));
let C94 being  shiftable (Program of ( SCMPDS ));
let C95 being Int_position;
let C96 being Integer;
set D124 = ( DataLoc (( C92 . C95 ) , C96) );
assume L525: ( C92 . D124 ) = ( 0 );
set D125 = ( (C95 , C96) <>0_goto ( ( card C93 ) + 2 ) );
set D126 = ( Goto ( ( card C94 ) + 1 ) );
set D127 = ( ( C93 ';' D126 ) ';' C94 );
set D128 = ( if=0 (C95 , C96 , C93 , C94) );
set D129 = ( stop D127 );
set D130 = C92;
set D131 = C92;
set D132 = ( R14 +* D129 );
set D133 = ( R14 +* ( stop D128 ) );
set D134 = ( Comput (D133 , D131 , 1) );
set D135 = D133;
L526: ( Initialize C92 ) = C92 by MEMSTR_0:44;
L527: ( IC D131 ) = ( 0 ) by L526 , MEMSTR_0:47;
L528: D128 = ( ( D125 ';' ( C93 ';' D126 ) ) ';' C94 ) by SCMPDS_4:14
.= ( D125 ';' D127 ) by SCMPDS_4:14;
L529: ( Shift (D129 , 1) ) c= D135 by L528 , L436;
L530: ( Comput (D133 , D131 , ( ( 0 ) + 1 )) ) = ( Following (D133 , ( Comput (D133 , D131 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D133 , D131) ) by EXTPRO_1:2
.= ( Exec (D125 , D131) ) by L528 , L8 , L526;
L531: ( D131 . ( DataLoc (( D131 . C95 ) , C96) ) ) = ( D131 . D124 )
.= ( 0 ) by L525;
L532: ( IC D134 ) = ( succ ( IC D131 ) ) by L531 , L530 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L527;
L533: (for R3 being Int_position holds ( D130 . R3 ) = ( D134 . R3 )) by L530 , SCMPDS_2:55;
L534: ( DataPart D130 ) = ( DataPart D134 ) by L533 , SCMPDS_4:8;
set D136 = ( Start-At (( ( ( card C93 ) + ( card C94 ) ) + 2 ) , ( SCMPDS )) );
assume L535: C93 is_closed_on C92 , R14;
assume L536: C93 is_halting_on C92 , R14;
L537: D127 is_halting_on C92 , R14 by L536 , L535 , L284;
L538: D132 halts_on D130 by L537 , L41 , L526;
L539: D127 is_closed_on C92 , R14 by L535 , L536 , L284;
L540: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D130 & D127 is_closed_on D130 , D132) by L539 , L143 , L526 , FUNCT_4:25;
L541: ( stop D127 ) c= D132 by FUNCT_4:25;
L542: ( Comput (D133 , D131 , ( ( LifeSpan (D132 , D130) ) + 1 )) ) = ( Comput (D133 , ( Comput (D133 , D131 , 1) ) , ( LifeSpan (D132 , D130) )) ) by EXTPRO_1:4;
L543: ( CurInstr (D133 , ( Comput (D133 , D131 , ( ( LifeSpan (D132 , D130) ) + 1 )) )) ) = ( CurInstr (D133 , ( Comput (D133 , D134 , ( LifeSpan (D132 , D130) )) )) ) by L542
.= ( CurInstr (D132 , ( Comput (D132 , D130 , ( LifeSpan (D132 , D130) )) )) ) by L540 , L529 , L532 , L534 , L360 , L541
.= ( halt ( SCMPDS ) ) by L538 , EXTPRO_1:def 15;
L544: D133 halts_on D131 by L543 , EXTPRO_1:29;
L545: ( CurInstr (D133 , D131) ) = D125 by L528 , L8 , L526;
L546:
now
let C97 being (Element of ( NAT ));
assume L547: C97 < ( ( LifeSpan (D132 , D130) ) + 1 );
L548: ( Comput (D133 , D131 , ( 0 )) ) = D131 by EXTPRO_1:2;
per cases ;
suppose L549: C97 = ( 0 );

L550: ( CurInstr (D133 , ( Comput (D133 , D131 , C97) )) ) = ( CurInstr (D133 , D131) ) by L549 , L548;
thus L551: ( CurInstr (D133 , ( Comput (D133 , D131 , C97) )) ) <> ( halt ( SCMPDS ) ) by L550 , L545;
end;
suppose L552: C97 <> ( 0 );

consider C98 being Nat such that L553: C97 = ( C98 + 1 ) by L552 , NAT_1:6;
reconsider D137 = C98 as (Element of ( NAT )) by ORDINAL1:def 12;
L554: D137 < ( LifeSpan (D132 , D130) ) by L547 , L553 , XREAL_1:6;
assume L555: ( CurInstr (D133 , ( Comput (D133 , D131 , C97) )) ) = ( halt ( SCMPDS ) );
L556: ( Comput (D133 , D131 , ( D137 + 1 )) ) = ( Comput (D133 , ( Comput (D133 , D131 , 1) ) , D137) ) by EXTPRO_1:4;
L557: ( CurInstr (D132 , ( Comput (D132 , D130 , D137) )) ) = ( CurInstr (D133 , ( Comput (D133 , D134 , D137) )) ) by L540 , L529 , L532 , L534 , L360 , L541
.= ( halt ( SCMPDS ) ) by L553 , L555 , L556;
thus L558: contradiction by L557 , L538 , L554 , EXTPRO_1:def 15;
end;
end;
L560: (for B90 being (Element of ( NAT )) holds (( CurInstr (D133 , ( Comput (D133 , D131 , B90) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D132 , D130) ) + 1 ) <= B90)) by L546;
L561: ( LifeSpan (D133 , D131) ) = ( ( LifeSpan (D132 , D130) ) + 1 ) by L560 , L543 , L544 , EXTPRO_1:def 15;
L562: ( DataPart ( Result (D132 , D130) ) ) = ( DataPart ( Comput (D132 , D130 , ( LifeSpan (D132 , D130) )) ) ) by L538 , EXTPRO_1:23
.= ( DataPart ( Comput (D133 , D134 , ( LifeSpan (D132 , D130) )) ) ) by L540 , L529 , L532 , L534 , L360 , L541
.= ( DataPart ( Comput (D133 , D131 , ( ( LifeSpan (D132 , D130) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D133 , D131) ) ) by L544 , L561 , EXTPRO_1:23;
L563:
now
let C99 being set;
L564: ( dom D136 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L565: C99 in ( dom ( IExec (D128 , R14 , C92) ) );
per cases  by L565 , SCMPDS_4:6;
suppose L566: C99 is Int_position;

L567: C99 <> ( IC ( SCMPDS ) ) by L566 , SCMPDS_2:43;
L568: (not C99 in ( dom D136 )) by L567 , L564 , TARSKI:def 1;
thus L569: ( ( IExec (D128 , R14 , C92) ) . C99 ) = ( ( Result (D133 , D131) ) . C99 )
.= ( ( Result (D132 , D130) ) . C99 ) by L562 , L566 , SCMPDS_4:8
.= ( ( IExec (D127 , R14 , C92) ) . C99 )
.= ( ( ( IExec (D127 , R14 , C92) ) +* D136 ) . C99 ) by L568 , FUNCT_4:11;
end;
suppose L570: C99 = ( IC ( SCMPDS ) );

L571: ( IC ( Result (D132 , D130) ) ) = ( IC ( IExec (D127 , R14 , C92) ) )
.= ( ( ( card C93 ) + ( card C94 ) ) + 1 ) by L535 , L536 , L398;
L572: C99 in ( dom D136 ) by L564 , L570 , TARSKI:def 1;
thus L573: ( ( IExec (D128 , R14 , C92) ) . C99 ) = ( ( Result (D133 , D131) ) . C99 )
.= ( ( Comput (D133 , D131 , ( ( LifeSpan (D132 , D130) ) + 1 )) ) . C99 ) by L544 , L561 , EXTPRO_1:23
.= ( IC ( Comput (D133 , D134 , ( LifeSpan (D132 , D130) )) ) ) by L570 , EXTPRO_1:4
.= ( ( IC ( Comput (D132 , D130 , ( LifeSpan (D132 , D130) )) ) ) + 1 ) by L540 , L529 , L532 , L534 , L360 , L541
.= ( ( IC ( Result (D132 , D130) ) ) + 1 ) by L538 , EXTPRO_1:23
.= ( IC ( Start-At (( ( ( ( card C93 ) + ( card C94 ) ) + 1 ) + 1 ) , ( SCMPDS )) ) ) by L571 , FUNCOP_1:72
.= ( ( ( IExec (D127 , R14 , C92) ) +* D136 ) . C99 ) by L570 , L572 , FUNCT_4:13;
end;
end;
L575: ( dom ( IExec (D128 , R14 , C92) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D127 , R14 , C92) ) +* D136 ) ) by PARTFUN1:def 2;
thus L576: ( IExec (D128 , R14 , C92) ) = ( ( IExec (D127 , R14 , C92) ) +* D136 ) by L575 , L563 , FUNCT_1:2
.= ( ( ( IExec (C93 , R14 , C92) ) +* ( Start-At (( ( ( card C93 ) + ( card C94 ) ) + 1 ) , ( SCMPDS )) ) ) +* ( Start-At (( ( ( card C93 ) + ( card C94 ) ) + 2 ) , ( SCMPDS )) ) ) by L535 , L536 , L404
.= ( ( IExec (C93 , R14 , C92) ) +* D136 ) by MEMSTR_0:36;
end;
theorem
L577: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B91 being (State of ( SCMPDS )) holds (for B92 being (Program of ( SCMPDS )) holds (for B93 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B94 being Int_position holds (for B95 being Integer holds ((( B91 . ( DataLoc (( B91 . B94 ) , B95) ) ) <> ( 0 ) & B93 is_closed_on B91 , R14 & B93 is_halting_on B91 , R14) implies ( IExec (( if=0 (B94 , B95 , B92 , B93) ) , R14 , ( Initialize B91 )) ) = ( ( IExec (B93 , R14 , ( Initialize B91 )) ) +* ( Start-At (( ( ( card B92 ) + ( card B93 ) ) + 2 ) , ( SCMPDS )) ) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C100 being (State of ( SCMPDS ));
let C101 being (Program of ( SCMPDS ));
let C102 being  halt-free  shiftable (Program of ( SCMPDS ));
let C103 being Int_position;
let C104 being Integer;
set D138 = ( DataLoc (( C100 . C103 ) , C104) );
set D139 = ( stop C102 );
set D140 = ( Initialize C100 );
set D141 = ( R14 +* D139 );
set D142 = ( R14 +* D139 );
set D143 = ( if=0 (C103 , C104 , C101 , C102) );
set D144 = ( stop D143 );
set D145 = ( Initialize C100 );
set D146 = ( R14 +* D144 );
set D147 = ( Comput (D146 , D145 , 1) );
set D148 = D146;
set D149 = ( (C103 , C104) <>0_goto ( ( card C101 ) + 2 ) );
set D150 = ( Goto ( ( card C102 ) + 1 ) );
set D151 = ( ( D149 ';' C101 ) ';' D150 );
set D152 = ( Start-At (( ( ( card C101 ) + ( card C102 ) ) + 2 ) , ( SCMPDS )) );
L578: D143 = ( ( D149 ';' ( C101 ';' D150 ) ) ';' C102 ) by SCMPDS_4:14
.= ( D149 ';' ( ( C101 ';' D150 ) ';' C102 ) ) by SCMPDS_4:14;
L579: ( Comput (D146 , D145 , ( ( 0 ) + 1 )) ) = ( Following (D146 , ( Comput (D146 , D145 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D146 , D145) ) by EXTPRO_1:2
.= ( Exec (D149 , D145) ) by L578 , L8;
L580: (not D138 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L581: (not C103 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L582: ( D145 . ( DataLoc (( D145 . C103 ) , C104) ) ) = ( D145 . D138 ) by L581 , FUNCT_4:11
.= ( C100 . D138 ) by L580 , FUNCT_4:11;
L583: ( IC D145 ) = ( 0 ) by MEMSTR_0:47;
assume L584: ( C100 . D138 ) <> ( 0 );
L585: ( IC D147 ) = ( ICplusConst (D145 , ( ( card C101 ) + 2 )) ) by L584 , L579 , L582 , SCMPDS_2:55
.= ( ( 0 ) + ( ( card C101 ) + 2 ) ) by L583 , L18;
L586: (for R3 being Int_position holds ( D140 . R3 ) = ( D147 . R3 )) by L579 , SCMPDS_2:55;
L587: ( DataPart D140 ) = ( DataPart D147 ) by L586 , SCMPDS_4:8;
L588: ( card D151 ) = ( ( card ( D149 ';' C101 ) ) + ( card D150 ) ) by AFINSQ_1:17
.= ( ( card ( D149 ';' C101 ) ) + 1 ) by COMPOS_1:54
.= ( ( ( card C101 ) + 1 ) + 1 ) by L3
.= ( ( card C101 ) + ( 1 + 1 ) );
L589: ( Shift (D139 , ( ( card C101 ) + 2 )) ) c= D144 by L588 , L21;
L590: D144 c= D146 by FUNCT_4:25;
L591: ( Shift (D139 , ( ( card C101 ) + 2 )) ) c= D146 by L590 , L589 , XBOOLE_1:1;
L592: ( Shift (D139 , ( ( card C101 ) + 2 )) ) c= D148 by L591;
assume L593: C102 is_closed_on C100 , R14;
L594: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D140 & C102 is_closed_on D140 , D141) by L593 , L143 , FUNCT_4:25;
L595: ( stop C102 ) c= D141 by FUNCT_4:25;
assume L596: C102 is_halting_on C100 , R14;
L597: D141 halts_on D140 by L596 , L41;
L598: ( Comput (D146 , D145 , ( ( LifeSpan (D141 , D140) ) + 1 )) ) = ( Comput (D146 , ( Comput (D146 , D145 , 1) ) , ( LifeSpan (D141 , D140) )) ) by EXTPRO_1:4;
L599: ( CurInstr (D146 , ( Comput (D146 , D145 , ( ( LifeSpan (D141 , D140) ) + 1 )) )) ) = ( CurInstr (D146 , ( Comput (D146 , D147 , ( LifeSpan (D141 , D140) )) )) ) by L598
.= ( CurInstr (D141 , ( Comput (D141 , D140 , ( LifeSpan (D141 , D140) )) )) ) by L594 , L592 , L585 , L587 , L360 , L595
.= ( halt ( SCMPDS ) ) by L597 , EXTPRO_1:def 15;
L600: D146 halts_on D145 by L599 , EXTPRO_1:29;
L601: ( CurInstr (D146 , D145) ) = D149 by L578 , L8;
L602:
now
let C105 being (Element of ( NAT ));
assume L603: C105 < ( ( LifeSpan (D141 , D140) ) + 1 );
L604: ( Comput (D146 , D145 , ( 0 )) ) = D145 by EXTPRO_1:2;
per cases ;
suppose L605: C105 = ( 0 );

L606: ( CurInstr (D146 , ( Comput (D146 , D145 , C105) )) ) = ( CurInstr (D146 , D145) ) by L605 , L604;
thus L607: ( CurInstr (D146 , ( Comput (D146 , D145 , C105) )) ) <> ( halt ( SCMPDS ) ) by L606 , L601;
end;
suppose L608: C105 <> ( 0 );

consider C106 being Nat such that L609: C105 = ( C106 + 1 ) by L608 , NAT_1:6;
reconsider D153 = C106 as (Element of ( NAT )) by ORDINAL1:def 12;
L610: D153 < ( LifeSpan (D141 , D140) ) by L603 , L609 , XREAL_1:6;
assume L611: ( CurInstr (D146 , ( Comput (D146 , D145 , C105) )) ) = ( halt ( SCMPDS ) );
L612: ( Comput (D146 , D145 , ( D153 + 1 )) ) = ( Comput (D146 , ( Comput (D146 , D145 , 1) ) , D153) ) by EXTPRO_1:4;
L613: ( CurInstr (D141 , ( Comput (D141 , D140 , D153) )) ) = ( CurInstr (D146 , ( Comput (D146 , D147 , D153) )) ) by L594 , L592 , L585 , L587 , L360 , L595
.= ( halt ( SCMPDS ) ) by L609 , L611 , L612;
thus L614: contradiction by L613 , L597 , L610 , EXTPRO_1:def 15;
end;
end;
L616: (for B96 being (Element of ( NAT )) holds (( CurInstr (D146 , ( Comput (D146 , D145 , B96) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D141 , D140) ) + 1 ) <= B96)) by L602;
L617: ( LifeSpan (D146 , D145) ) = ( ( LifeSpan (D141 , D140) ) + 1 ) by L616 , L599 , L600 , EXTPRO_1:def 15;
L618: ( DataPart ( Result (D141 , D140) ) ) = ( DataPart ( Comput (D141 , D140 , ( LifeSpan (D141 , D140) )) ) ) by L597 , EXTPRO_1:23
.= ( DataPart ( Comput (D146 , D147 , ( LifeSpan (D141 , D140) )) ) ) by L594 , L592 , L585 , L587 , L360 , L595
.= ( DataPart ( Comput (D146 , D145 , ( ( LifeSpan (D141 , D140) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D146 , D145) ) ) by L600 , L617 , EXTPRO_1:23;
L619:
now
let C107 being set;
L620: ( dom D152 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L621: C107 in ( dom ( IExec (D143 , R14 , ( Initialize C100 )) ) );
per cases  by L621 , SCMPDS_4:6;
suppose L622: C107 is Int_position;

L623: C107 <> ( IC ( SCMPDS ) ) by L622 , SCMPDS_2:43;
L624: (not C107 in ( dom D152 )) by L623 , L620 , TARSKI:def 1;
thus L625: ( ( IExec (D143 , R14 , ( Initialize C100 )) ) . C107 ) = ( ( Result (D146 , D145) ) . C107 )
.= ( ( Result (D141 , D140) ) . C107 ) by L618 , L622 , SCMPDS_4:8
.= ( ( IExec (C102 , R14 , ( Initialize C100 )) ) . C107 )
.= ( ( ( IExec (C102 , R14 , ( Initialize C100 )) ) +* D152 ) . C107 ) by L624 , FUNCT_4:11;
end;
suppose L626: C107 = ( IC ( SCMPDS ) );

L627: ( IC ( Result (D141 , D140) ) ) = ( IC ( IExec (C102 , R14 , ( Initialize C100 )) ) )
.= ( card C102 ) by L593 , L596 , L416;
L628: C107 in ( dom D152 ) by L620 , L626 , TARSKI:def 1;
thus L629: ( ( IExec (D143 , R14 , ( Initialize C100 )) ) . C107 ) = ( ( Result (D146 , D145) ) . C107 )
.= ( ( Comput (D146 , D145 , ( ( LifeSpan (D141 , D140) ) + 1 )) ) . C107 ) by L600 , L617 , EXTPRO_1:23
.= ( IC ( Comput (D146 , D147 , ( LifeSpan (D141 , D140) )) ) ) by L626 , EXTPRO_1:4
.= ( ( IC ( Comput (D141 , D140 , ( LifeSpan (D141 , D140) )) ) ) + ( ( card C101 ) + 2 ) ) by L594 , L592 , L585 , L587 , L360 , L595
.= ( ( IC ( Result (D141 , D140) ) ) + ( ( card C101 ) + 2 ) ) by L597 , EXTPRO_1:23
.= ( IC ( Start-At (( ( card C102 ) + ( ( card C101 ) + 2 ) ) , ( SCMPDS )) ) ) by L627 , FUNCOP_1:72
.= ( ( ( IExec (C102 , R14 , ( Initialize C100 )) ) +* D152 ) . C107 ) by L626 , L628 , FUNCT_4:13;
end;
end;
L631: ( dom ( IExec (D143 , R14 , ( Initialize C100 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C102 , R14 , ( Initialize C100 )) ) +* D152 ) ) by PARTFUN1:def 2;
thus L632: thesis by L631 , L619 , FUNCT_1:2;
end;
registration
let C108 , C109 being  shiftable  parahalting (Program of ( SCMPDS ));
let C110 being Int_position;
let C111 being Integer;
cluster ( if=0 (C110 , C111 , C108 , C109) ) ->  shiftable  parahalting;
correctness
proof
set D154 = ( (C110 , C111) <>0_goto ( ( card C108 ) + 2 ) );
set D155 = ( Goto ( ( card C109 ) + 1 ) );
set D156 = ( if=0 (C110 , C111 , C108 , C109) );
reconsider D157 = ( ( C108 ';' D155 ) ';' C109 ) as  shiftable (Program of ( SCMPDS ));
thus L633: D156 is  shiftable;
let C112 being ( 0 ) -started (State of ( SCMPDS ));
let C113 being (Instruction-Sequence of ( SCMPDS ));
L634: ( Initialize C112 ) = C112 by MEMSTR_0:44;
assume L635: ( stop D156 ) c= C113;
L636: C113 = ( C113 +* ( stop D156 ) ) by L635 , FUNCT_4:98;
L637: (C109 is_closed_on C112 , C113 & C109 is_halting_on C112 , C113) by L43 , L55;
L638: (C108 is_closed_on C112 , C113 & C108 is_halting_on C112 , C113) by L43 , L55;
per cases ;
suppose L639: ( C112 . ( DataLoc (( C112 . C110 ) , C111) ) ) = ( 0 );

L640: D156 is_halting_on C112 , C113 by L639 , L638 , L448;
thus L641: C113 halts_on C112 by L640 , L634 , L636 , L41;
end;
suppose L642: ( C112 . ( DataLoc (( C112 . C110 ) , C111) ) ) <> ( 0 );

L643: D156 is_halting_on C112 , C113 by L642 , L637 , L485;
thus L644: C113 halts_on C112 by L643 , L634 , L636 , L41;
end;
end;
end;
registration
let C114 , C115 being  halt-free (Program of ( SCMPDS ));
let C116 being Int_position;
let C117 being Integer;
cluster ( if=0 (C116 , C117 , C114 , C115) ) ->  halt-free;
coherence;
end;
theorem
L648: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B97 being ( 0 ) -started (State of ( SCMPDS )) holds (for B98 , B99 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B100 being Int_position holds (for B101 being Integer holds ( IC ( IExec (( if=0 (B100 , B101 , B98 , B99) ) , R14 , B97) ) ) = ( ( ( card B98 ) + ( card B99 ) ) + 2 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C118 being ( 0 ) -started (State of ( SCMPDS ));
let C119 , C120 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C121 being Int_position;
let C122 being Integer;
set D158 = ( if=0 (C121 , C122 , C119 , C120) );
L649: (C120 is_closed_on C118 , R14 & C120 is_halting_on C118 , R14) by L43 , L55;
L650: (C119 is_closed_on C118 , R14 & C119 is_halting_on C118 , R14) by L43 , L55;
L651: ( Initialize C118 ) = C118 by MEMSTR_0:44;
thus L652:now
per cases ;
suppose L653: ( C118 . ( DataLoc (( C118 . C121 ) , C122) ) ) = ( 0 );

L654: ( IExec (D158 , R14 , C118) ) = ( ( IExec (C119 , R14 , C118) ) +* ( Start-At (( ( ( card C119 ) + ( card C120 ) ) + 2 ) , ( SCMPDS )) ) ) by L653 , L650 , L524;
thus L655: thesis by L654 , FUNCT_4:113;
end;
suppose L656: ( C118 . ( DataLoc (( C118 . C121 ) , C122) ) ) <> ( 0 );

L657: ( IExec (D158 , R14 , C118) ) = ( ( IExec (C120 , R14 , C118) ) +* ( Start-At (( ( ( card C119 ) + ( card C120 ) ) + 2 ) , ( SCMPDS )) ) ) by L656 , L649 , L577 , L651;
thus L658: thesis by L657 , FUNCT_4:113;
end;
end;
end;
theorem
L653: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B102 being ( 0 ) -started (State of ( SCMPDS )) holds (for B103 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B104 being  shiftable (Program of ( SCMPDS )) holds (for B105 , B106 being Int_position holds (for B107 being Integer holds (( B102 . ( DataLoc (( B102 . B105 ) , B107) ) ) = ( 0 ) implies ( ( IExec (( if=0 (B105 , B107 , B103 , B104) ) , R14 , B102) ) . B106 ) = ( ( IExec (B103 , R14 , B102) ) . B106 ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C123 being ( 0 ) -started (State of ( SCMPDS ));
let C124 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C125 being  shiftable (Program of ( SCMPDS ));
let C126 , C127 being Int_position;
let C128 being Integer;
assume L654: ( C123 . ( DataLoc (( C123 . C126 ) , C128) ) ) = ( 0 );
L655: (not C127 in ( dom ( Start-At (( ( ( card C124 ) + ( card C125 ) ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L656: (C124 is_closed_on C123 , R14 & C124 is_halting_on C123 , R14) by L43 , L55;
L657: ( IExec (( if=0 (C126 , C128 , C124 , C125) ) , R14 , C123) ) = ( ( IExec (C124 , R14 , C123) ) +* ( Start-At (( ( ( card C124 ) + ( card C125 ) ) + 2 ) , ( SCMPDS )) ) ) by L656 , L654 , L524;
thus L658: thesis by L657 , L655 , FUNCT_4:11;
end;
theorem
L659: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B108 being (State of ( SCMPDS )) holds (for B109 being (Program of ( SCMPDS )) holds (for B110 being  halt-free  parahalting  shiftable (Program of ( SCMPDS )) holds (for B111 , B112 being Int_position holds (for B113 being Integer holds (( B108 . ( DataLoc (( B108 . B111 ) , B113) ) ) <> ( 0 ) implies ( ( IExec (( if=0 (B111 , B113 , B109 , B110) ) , R14 , ( Initialize B108 )) ) . B112 ) = ( ( IExec (B110 , R14 , ( Initialize B108 )) ) . B112 ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C129 being (State of ( SCMPDS ));
let C130 being (Program of ( SCMPDS ));
let C131 being  halt-free  parahalting  shiftable (Program of ( SCMPDS ));
let C132 , C133 being Int_position;
let C134 being Integer;
assume L660: ( C129 . ( DataLoc (( C129 . C132 ) , C134) ) ) <> ( 0 );
L661: (not C133 in ( dom ( Start-At (( ( ( card C130 ) + ( card C131 ) ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L662: (C131 is_closed_on C129 , R14 & C131 is_halting_on C129 , R14) by L43 , L55;
L663: ( IExec (( if=0 (C132 , C134 , C130 , C131) ) , R14 , ( Initialize C129 )) ) = ( ( IExec (C131 , R14 , ( Initialize C129 )) ) +* ( Start-At (( ( ( card C130 ) + ( card C131 ) ) + 2 ) , ( SCMPDS )) ) ) by L662 , L660 , L577;
thus L664: thesis by L663 , L661 , FUNCT_4:11;
end;
begin
theorem
L665: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( card ( if=0 (R3 , R9 , R11) ) ) = ( ( card R11 ) + 1 )))) by L3;
theorem
L666: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( 0 ) in ( dom ( if=0 (R3 , R9 , R11) ) ))))
proof
let R3 being Int_position;
let R9 being Integer;
let R11 being (Program of ( SCMPDS ));
set D159 = ( card ( if=0 (R3 , R9 , R11) ) );
L667: D159 = ( ( card R11 ) + 1 ) by L3;
thus L668: thesis by L667 , AFINSQ_1:66;
end;
theorem
L669: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( ( if=0 (R3 , R9 , R11) ) . ( 0 ) ) = ( (R3 , R9) <>0_goto ( ( card R11 ) + 1 ) )))) by L5;
theorem
L670: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B114 being (State of ( SCMPDS )) holds (for B115 being  shiftable (Program of ( SCMPDS )) holds (for B116 being Int_position holds (for B117 being Integer holds ((( B114 . ( DataLoc (( B114 . B116 ) , B117) ) ) = ( 0 ) & B115 is_closed_on B114 , R14 & B115 is_halting_on B114 , R14) implies (( if=0 (B116 , B117 , B115) ) is_closed_on B114 , R14 & ( if=0 (B116 , B117 , B115) ) is_halting_on B114 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C135 being (State of ( SCMPDS ));
let C136 being  shiftable (Program of ( SCMPDS ));
let C137 being Int_position;
let C138 being Integer;
set D160 = ( DataLoc (( C135 . C137 ) , C138) );
assume L671: ( C135 . D160 ) = ( 0 );
set D161 = ( (C137 , C138) <>0_goto ( ( card C136 ) + 1 ) );
set D162 = ( if=0 (C137 , C138 , C136) );
set D163 = ( stop D162 );
set D164 = ( stop C136 );
set D165 = ( Initialize C135 );
set D166 = ( Initialize C135 );
set D167 = ( R14 +* D164 );
set D168 = ( R14 +* D163 );
set D169 = ( Comput (D168 , D166 , 1) );
set D170 = D168;
L672: ( IC D166 ) = ( 0 ) by MEMSTR_0:47;
L673: (not D160 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L674: ( Comput (D168 , D166 , ( ( 0 ) + 1 )) ) = ( Following (D168 , ( Comput (D168 , D166 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D168 , D166) ) by EXTPRO_1:2
.= ( Exec (D161 , D166) ) by L8;
L675: (for R3 being Int_position holds ( D165 . R3 ) = ( D169 . R3 )) by L674 , SCMPDS_2:55;
L676: ( DataPart D165 ) = ( DataPart D169 ) by L675 , SCMPDS_4:8;
L677: (not C137 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L678: ( D166 . ( DataLoc (( D166 . C137 ) , C138) ) ) = ( D166 . D160 ) by L677 , FUNCT_4:11
.= ( 0 ) by L671 , L673 , FUNCT_4:11;
L679: ( IC D169 ) = ( succ ( IC D166 ) ) by L678 , L674 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L672;
assume L680: C136 is_closed_on C135 , R14;
L681: C136 is_closed_on D165 , D167 by L680 , L143;
assume L682: C136 is_halting_on C135 , R14;
L683: D167 halts_on D165 by L682 , L41;
L684: ( 0 ) in ( dom D163 ) by COMPOS_1:36;
L685: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D165 & ( Shift (D164 , 1) ) c= D170) by L436 , FUNCT_4:25;
L686: ( stop C136 ) c= D167 by FUNCT_4:25;
L687: ( card D163 ) = ( ( card D162 ) + 1 ) by COMPOS_1:55
.= ( ( ( card C136 ) + 1 ) + 1 ) by L3;
L688:
now
let C139 being (Element of ( NAT ));
per cases ;
suppose L689: ( 0 ) < C139;

consider C140 being Nat such that L690: ( C140 + 1 ) = C139 by L689 , NAT_1:6;
reconsider D171 = C140 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D172 = ( IC ( Comput (D167 , D165 , D171) ) ) as (Element of ( NAT ));
L691: ( card D163 ) = ( ( card D164 ) + 1 ) by L687 , COMPOS_1:55;
L692: D172 in ( dom D164 ) by L680 , L40;
L693: D172 < ( card D164 ) by L692 , AFINSQ_1:66;
L694: ( D172 + 1 ) < ( card D163 ) by L693 , L691 , XREAL_1:6;
L695: ( IC ( Comput (D168 , D166 , C139) ) ) = ( IC ( Comput (D168 , D169 , D171) ) ) by L690 , EXTPRO_1:4
.= ( D172 + 1 ) by L681 , L685 , L679 , L676 , L360 , L686;
thus L696: ( IC ( Comput (D168 , D166 , C139) ) ) in ( dom D163 ) by L695 , L694 , AFINSQ_1:66;
end;
suppose L697: C139 = ( 0 );

thus L698: ( IC ( Comput (D168 , D166 , C139) ) ) in ( dom D163 ) by L697 , L684 , L672 , EXTPRO_1:2;
end;
end;
thus L700: D162 is_closed_on C135 , R14 by L688 , L40;
L701: ( Comput (D168 , D166 , ( ( LifeSpan (D167 , D165) ) + 1 )) ) = ( Comput (D168 , ( Comput (D168 , D166 , 1) ) , ( LifeSpan (D167 , D165) )) ) by EXTPRO_1:4;
L702: ( CurInstr (D168 , ( Comput (D168 , D166 , ( ( LifeSpan (D167 , D165) ) + 1 )) )) ) = ( CurInstr (D168 , ( Comput (D168 , D169 , ( LifeSpan (D167 , D165) )) )) ) by L701
.= ( CurInstr (D167 , ( Comput (D167 , D165 , ( LifeSpan (D167 , D165) )) )) ) by L681 , L685 , L679 , L676 , L360 , L686
.= ( halt ( SCMPDS ) ) by L683 , EXTPRO_1:def 15;
L703: D168 halts_on D166 by L702 , EXTPRO_1:29;
thus L704: thesis by L703 , L41;
end;
theorem
L705: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B118 being (State of ( SCMPDS )) holds (for B119 being (Program of ( SCMPDS )) holds (for B120 being Int_position holds (for B121 being Integer holds (( B118 . ( DataLoc (( B118 . B120 ) , B121) ) ) <> ( 0 ) implies (( if=0 (B120 , B121 , B119) ) is_closed_on B118 , R14 & ( if=0 (B120 , B121 , B119) ) is_halting_on B118 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C141 being (State of ( SCMPDS ));
let C142 being (Program of ( SCMPDS ));
let C143 being Int_position;
let C144 being Integer;
set D173 = ( DataLoc (( C141 . C143 ) , C144) );
assume L706: ( C141 . D173 ) <> ( 0 );
set D174 = ( (C143 , C144) <>0_goto ( ( card C142 ) + 1 ) );
set D175 = ( if=0 (C143 , C144 , C142) );
set D176 = ( stop D175 );
set D177 = ( Initialize C141 );
set D178 = ( R14 +* D176 );
set D179 = ( Comput (D178 , D177 , 1) );
set D180 = D178;
L707: ( IC D177 ) = ( 0 ) by MEMSTR_0:47;
L708: (not D173 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L709: (not C143 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L710: ( D177 . ( DataLoc (( D177 . C143 ) , C144) ) ) = ( D177 . D173 ) by L709 , FUNCT_4:11
.= ( C141 . D173 ) by L708 , FUNCT_4:11;
L711: ( Comput (D178 , D177 , ( ( 0 ) + 1 )) ) = ( Following (D178 , ( Comput (D178 , D177 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D178 , D177) ) by EXTPRO_1:2
.= ( Exec (D174 , D177) ) by L8;
L712: ( IC D179 ) = ( ICplusConst (D177 , ( ( card C142 ) + 1 )) ) by L711 , L706 , L710 , SCMPDS_2:55
.= ( ( 0 ) + ( ( card C142 ) + 1 ) ) by L707 , L18;
L713: ( card D175 ) = ( ( card C142 ) + 1 ) by L3;
L714: ( ( card C142 ) + 1 ) in ( dom D176 ) by L713 , COMPOS_1:64;
L715: ( D178 /. ( IC D179 ) ) = ( D178 . ( IC D179 ) ) by PBOOLE:143;
L716: D176 c= D178 by FUNCT_4:25;
L717: D176 c= D180 by L716;
L718: ( D180 . ( ( card C142 ) + 1 ) ) = ( D176 . ( ( card C142 ) + 1 ) ) by L717 , L714 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L713 , COMPOS_1:64;
L719: ( CurInstr (D178 , D179) ) = ( halt ( SCMPDS ) ) by L718 , L712 , L715;
L720:
now
let C145 being (Element of ( NAT ));
per cases ;
suppose L721: ( 0 ) < C145;

L722: ( 1 + ( 0 ) ) <= C145 by L721 , INT_1:7;
thus L723: ( IC ( Comput (D178 , D177 , C145) ) ) in ( dom D176 ) by L722 , L714 , L712 , L719 , EXTPRO_1:5;
end;
suppose L724: C145 = ( 0 );

L725: ( Comput (D178 , D177 , C145) ) = D177 by L724 , EXTPRO_1:2;
thus L726: ( IC ( Comput (D178 , D177 , C145) ) ) in ( dom D176 ) by L725 , L707 , COMPOS_1:36;
end;
end;
thus L728: D175 is_closed_on C141 , R14 by L720 , L40;
L729: D178 halts_on D177 by L719 , EXTPRO_1:29;
thus L730: thesis by L729 , L41;
end;
theorem
L731: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B122 being (State of ( SCMPDS )) holds (for B123 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B124 being Int_position holds (for B125 being Integer holds ((( B122 . ( DataLoc (( B122 . B124 ) , B125) ) ) = ( 0 ) & B123 is_closed_on B122 , R14 & B123 is_halting_on B122 , R14) implies ( IExec (( if=0 (B124 , B125 , B123) ) , R14 , ( Initialize B122 )) ) = ( ( IExec (B123 , R14 , ( Initialize B122 )) ) +* ( Start-At (( ( card B123 ) + 1 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C146 being (State of ( SCMPDS ));
let C147 being  halt-free  shiftable (Program of ( SCMPDS ));
let C148 being Int_position;
let C149 being Integer;
set D181 = ( DataLoc (( C146 . C148 ) , C149) );
assume L732: ( C146 . D181 ) = ( 0 );
set D182 = ( (C148 , C149) <>0_goto ( ( card C147 ) + 1 ) );
set D183 = ( if=0 (C148 , C149 , C147) );
set D184 = ( stop C147 );
set D185 = ( stop D183 );
set D186 = ( Initialize C146 );
set D187 = ( R14 +* D184 );
set D188 = ( Initialize C146 );
set D189 = ( R14 +* D185 );
set D190 = ( Comput (D189 , D188 , 1) );
set D191 = D189;
L733: ( IC D188 ) = ( 0 ) by MEMSTR_0:47;
L734: (not D181 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L735: ( Comput (D189 , D188 , ( ( 0 ) + 1 )) ) = ( Following (D189 , ( Comput (D189 , D188 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D189 , D188) ) by EXTPRO_1:2
.= ( Exec (D182 , D188) ) by L8;
L736: (not C148 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L737: ( D188 . ( DataLoc (( D188 . C148 ) , C149) ) ) = ( D188 . D181 ) by L736 , FUNCT_4:11
.= ( 0 ) by L732 , L734 , FUNCT_4:11;
L738: ( IC D190 ) = ( succ ( IC D188 ) ) by L737 , L735 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L733;
L739: (for R3 being Int_position holds ( D186 . R3 ) = ( D190 . R3 )) by L735 , SCMPDS_2:55;
L740: ( DataPart D186 ) = ( DataPart D190 ) by L739 , SCMPDS_4:8;
assume L741: C147 is_closed_on C146 , R14;
L742: C147 is_closed_on D186 , D187 by L741 , L143;
set D192 = ( Start-At (( ( card C147 ) + 1 ) , ( SCMPDS )) );
L743: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D186 & ( Shift (D184 , 1) ) c= D191) by L436 , FUNCT_4:25;
L744: ( stop C147 ) c= D187 by FUNCT_4:25;
assume L745: C147 is_halting_on C146 , R14;
L746: D187 halts_on D186 by L745 , L41;
L747: ( Comput (D189 , D188 , ( ( LifeSpan (D187 , D186) ) + 1 )) ) = ( Comput (D189 , ( Comput (D189 , D188 , 1) ) , ( LifeSpan (D187 , D186) )) ) by EXTPRO_1:4;
L748: ( CurInstr (D189 , ( Comput (D189 , D188 , ( ( LifeSpan (D187 , D186) ) + 1 )) )) ) = ( CurInstr (D189 , ( Comput (D189 , D190 , ( LifeSpan (D187 , D186) )) )) ) by L747
.= ( CurInstr (D187 , ( Comput (D187 , D186 , ( LifeSpan (D187 , D186) )) )) ) by L742 , L743 , L738 , L740 , L360 , L744
.= ( halt ( SCMPDS ) ) by L746 , EXTPRO_1:def 15;
L749: D189 halts_on D188 by L748 , EXTPRO_1:29;
L750: ( CurInstr (D189 , D188) ) = D182 by L8;
L751:
now
let C150 being (Element of ( NAT ));
assume L752: C150 < ( ( LifeSpan (D187 , D186) ) + 1 );
L753: ( Comput (D189 , D188 , ( 0 )) ) = D188 by EXTPRO_1:2;
per cases ;
suppose L754: C150 = ( 0 );

L755: ( CurInstr (D189 , ( Comput (D189 , D188 , C150) )) ) = ( CurInstr (D189 , D188) ) by L754 , L753;
thus L756: ( CurInstr (D189 , ( Comput (D189 , D188 , C150) )) ) <> ( halt ( SCMPDS ) ) by L755 , L750;
end;
suppose L757: C150 <> ( 0 );

consider C151 being Nat such that L758: C150 = ( C151 + 1 ) by L757 , NAT_1:6;
reconsider D193 = C151 as (Element of ( NAT )) by ORDINAL1:def 12;
L759: D193 < ( LifeSpan (D187 , D186) ) by L752 , L758 , XREAL_1:6;
assume L760: ( CurInstr (D189 , ( Comput (D189 , D188 , C150) )) ) = ( halt ( SCMPDS ) );
L761: ( Comput (D189 , D188 , ( D193 + 1 )) ) = ( Comput (D189 , ( Comput (D189 , D188 , 1) ) , D193) ) by EXTPRO_1:4;
L762: ( CurInstr (D187 , ( Comput (D187 , D186 , D193) )) ) = ( CurInstr (D189 , ( Comput (D189 , D190 , D193) )) ) by L742 , L743 , L738 , L740 , L360 , L744
.= ( halt ( SCMPDS ) ) by L758 , L760 , L761;
thus L763: contradiction by L762 , L746 , L759 , EXTPRO_1:def 15;
end;
end;
L765: (for B126 being (Element of ( NAT )) holds (( CurInstr (D189 , ( Comput (D189 , D188 , B126) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D187 , D186) ) + 1 ) <= B126)) by L751;
L766: ( LifeSpan (D189 , D188) ) = ( ( LifeSpan (D187 , D186) ) + 1 ) by L765 , L748 , L749 , EXTPRO_1:def 15;
L767: ( DataPart ( Result (D187 , D186) ) ) = ( DataPart ( Comput (D187 , D186 , ( LifeSpan (D187 , D186) )) ) ) by L746 , EXTPRO_1:23
.= ( DataPart ( Comput (D189 , D190 , ( LifeSpan (D187 , D186) )) ) ) by L742 , L743 , L738 , L740 , L360 , L744
.= ( DataPart ( Comput (D189 , D188 , ( ( LifeSpan (D187 , D186) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D189 , D188) ) ) by L749 , L766 , EXTPRO_1:23;
L768:
now
let C152 being set;
L769: ( dom D192 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L770: C152 in ( dom ( IExec (D183 , R14 , ( Initialize C146 )) ) );
per cases  by L770 , SCMPDS_4:6;
suppose L771: C152 is Int_position;

L772: C152 <> ( IC ( SCMPDS ) ) by L771 , SCMPDS_2:43;
L773: (not C152 in ( dom D192 )) by L772 , L769 , TARSKI:def 1;
thus L774: ( ( IExec (D183 , R14 , ( Initialize C146 )) ) . C152 ) = ( ( Result (D189 , D188) ) . C152 )
.= ( ( Result (D187 , D186) ) . C152 ) by L767 , L771 , SCMPDS_4:8
.= ( ( IExec (C147 , R14 , ( Initialize C146 )) ) . C152 )
.= ( ( ( IExec (C147 , R14 , ( Initialize C146 )) ) +* D192 ) . C152 ) by L773 , FUNCT_4:11;
end;
suppose L775: C152 = ( IC ( SCMPDS ) );

L776: ( IC ( Result (D187 , D186) ) ) = ( IC ( IExec (C147 , R14 , ( Initialize C146 )) ) )
.= ( card C147 ) by L741 , L745 , L416;
L777: C152 in ( dom D192 ) by L769 , L775 , TARSKI:def 1;
thus L778: ( ( IExec (D183 , R14 , ( Initialize C146 )) ) . C152 ) = ( ( Result (D189 , D188) ) . C152 )
.= ( ( Comput (D189 , D188 , ( ( LifeSpan (D187 , D186) ) + 1 )) ) . C152 ) by L749 , L766 , EXTPRO_1:23
.= ( IC ( Comput (D189 , D190 , ( LifeSpan (D187 , D186) )) ) ) by L775 , EXTPRO_1:4
.= ( ( IC ( Comput (D187 , D186 , ( LifeSpan (D187 , D186) )) ) ) + 1 ) by L742 , L743 , L738 , L740 , L360 , L744
.= ( ( IC ( Result (D187 , D186) ) ) + 1 ) by L746 , EXTPRO_1:23
.= ( IC ( Start-At (( ( card C147 ) + 1 ) , ( SCMPDS )) ) ) by L776 , FUNCOP_1:72
.= ( ( ( IExec (C147 , R14 , ( Initialize C146 )) ) +* D192 ) . C152 ) by L775 , L777 , FUNCT_4:13;
end;
end;
L780: ( dom ( IExec (D183 , R14 , ( Initialize C146 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C147 , R14 , ( Initialize C146 )) ) +* D192 ) ) by PARTFUN1:def 2;
thus L781: thesis by L780 , L768 , FUNCT_1:2;
end;
theorem
L782: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B127 being (State of ( SCMPDS )) holds (for B128 being (Program of ( SCMPDS )) holds (for B129 being Int_position holds (for B130 being Integer holds (( B127 . ( DataLoc (( B127 . B129 ) , B130) ) ) <> ( 0 ) implies ( IExec (( if=0 (B129 , B130 , B128) ) , R14 , ( Initialize B127 )) ) = ( B127 +* ( Start-At (( ( card B128 ) + 1 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C153 being (State of ( SCMPDS ));
let C154 being (Program of ( SCMPDS ));
let C155 being Int_position;
let C156 being Integer;
set D194 = ( DataLoc (( C153 . C155 ) , C156) );
set D195 = ( if=0 (C155 , C156 , C154) );
set D196 = ( stop D195 );
set D197 = ( Initialize C153 );
set D198 = ( R14 +* D196 );
set D199 = ( Comput (D198 , D197 , 1) );
set D200 = D198;
set D201 = ( (C155 , C156) <>0_goto ( ( card C154 ) + 1 ) );
set D202 = ( Start-At (( ( card C154 ) + 1 ) , ( SCMPDS )) );
L783: ( IC D197 ) = ( 0 ) by MEMSTR_0:47;
L784: (not D194 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L785: (not C155 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L786: ( D197 . ( DataLoc (( D197 . C155 ) , C156) ) ) = ( D197 . D194 ) by L785 , FUNCT_4:11
.= ( C153 . D194 ) by L784 , FUNCT_4:11;
L787: ( Comput (D198 , D197 , ( ( 0 ) + 1 )) ) = ( Following (D198 , ( Comput (D198 , D197 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D198 , D197) ) by EXTPRO_1:2
.= ( Exec (D201 , D197) ) by L8;
assume L788: ( C153 . D194 ) <> ( 0 );
L789: ( IC D199 ) = ( ICplusConst (D197 , ( ( card C154 ) + 1 )) ) by L788 , L787 , L786 , SCMPDS_2:55
.= ( ( 0 ) + ( ( card C154 ) + 1 ) ) by L783 , L18;
L790: D196 c= D200 by FUNCT_4:25;
L791: ( D198 /. ( IC D199 ) ) = ( D198 . ( IC D199 ) ) by PBOOLE:143;
L792: ( card D195 ) = ( ( card C154 ) + 1 ) by L3;
L793: ( ( card C154 ) + 1 ) in ( dom D196 ) by L792 , COMPOS_1:64;
L794: ( D200 . ( ( card C154 ) + 1 ) ) = ( D196 . ( ( card C154 ) + 1 ) ) by L793 , L790 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L792 , COMPOS_1:64;
L795: ( CurInstr (D198 , D199) ) = ( halt ( SCMPDS ) ) by L794 , L789 , L791;
L796: D198 halts_on D197 by L795 , EXTPRO_1:29;
L797: ( CurInstr (D198 , D197) ) = D201 by L8;
L798:
now
let C157 being (Element of ( NAT ));
L799: ( Comput (D198 , D197 , ( 0 )) ) = D197 by EXTPRO_1:2;
assume L800: C157 < 1;
L801: C157 < ( 1 + ( 0 ) ) by L800;
L802: C157 = ( 0 ) by L801 , NAT_1:13;
L803: ( CurInstr (D198 , ( Comput (D198 , D197 , C157) )) ) = ( CurInstr (D198 , D197) ) by L802 , L799;
thus L804: ( CurInstr (D198 , ( Comput (D198 , D197 , C157) )) ) <> ( halt ( SCMPDS ) ) by L803 , L797;
end;
L805: (for B131 being (Element of ( NAT )) holds (( CurInstr (D198 , ( Comput (D198 , D197 , B131) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B131)) by L798;
L806: ( LifeSpan (D198 , D197) ) = 1 by L805 , L795 , L796 , EXTPRO_1:def 15;
L807: D199 = ( Result (D198 , D197) ) by L806 , L796 , EXTPRO_1:23;
L808:
now
L809: ( dom D202 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
let C158 being set;
assume L810: C158 in ( dom ( IExec (D195 , R14 , ( Initialize C153 )) ) );
per cases  by L810 , SCMPDS_4:6;
suppose L811: C158 is Int_position;

L812: C158 <> ( IC ( SCMPDS ) ) by L811 , SCMPDS_2:43;
L813: (not C158 in ( dom D202 )) by L812 , L809 , TARSKI:def 1;
L814: (not C158 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L811 , SCMPDS_4:18;
thus L815: ( ( IExec (D195 , R14 , ( Initialize C153 )) ) . C158 ) = ( D199 . C158 ) by L807
.= ( D197 . C158 ) by L787 , L811 , SCMPDS_2:55
.= ( C153 . C158 ) by L814 , FUNCT_4:11
.= ( ( C153 +* D202 ) . C158 ) by L813 , FUNCT_4:11;
end;
suppose L816: C158 = ( IC ( SCMPDS ) );

thus L817: ( ( IExec (D195 , R14 , ( Initialize C153 )) ) . C158 ) = ( ( card C154 ) + 1 ) by L816 , L789 , L807
.= ( ( C153 +* D202 ) . C158 ) by L816 , FUNCT_4:113;
end;
end;
L819: ( dom ( IExec (D195 , R14 , ( Initialize C153 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C153 +* D202 ) ) by PARTFUN1:def 2;
thus L820: thesis by L819 , L808 , FUNCT_1:2;
end;
registration
let C159 being  shiftable  parahalting (Program of ( SCMPDS ));
let C160 being Int_position;
let C161 being Integer;
cluster ( if=0 (C160 , C161 , C159) ) ->  shiftable  parahalting;
correctness
proof
set D203 = ( (C160 , C161) <>0_goto ( ( card C159 ) + 1 ) );
set D204 = ( if=0 (C160 , C161 , C159) );
thus L821: D204 is  shiftable;
let C162 being ( 0 ) -started (State of ( SCMPDS ));
let C163 being (Instruction-Sequence of ( SCMPDS ));
L822: ( Initialize C162 ) = C162 by MEMSTR_0:44;
assume L823: ( stop D204 ) c= C163;
L824: C163 = ( C163 +* ( stop D204 ) ) by L823 , FUNCT_4:98;
L825: (C159 is_closed_on C162 , C163 & C159 is_halting_on C162 , C163) by L43 , L55;
per cases ;
suppose L826: ( C162 . ( DataLoc (( C162 . C160 ) , C161) ) ) = ( 0 );

L827: D204 is_halting_on C162 , C163 by L826 , L825 , L670;
thus L828: C163 halts_on C162 by L827 , L822 , L824 , L41;
end;
suppose L829: ( C162 . ( DataLoc (( C162 . C160 ) , C161) ) ) <> ( 0 );

L830: D204 is_halting_on C162 , C163 by L829 , L705;
thus L831: C163 halts_on C162 by L830 , L822 , L824 , L41;
end;
end;
end;
registration
let C164 being  halt-free (Program of ( SCMPDS ));
let C165 being Int_position;
let C166 being Integer;
cluster ( if=0 (C165 , C166 , C164) ) ->  halt-free;
coherence;
end;
theorem
L835: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B132 being ( 0 ) -started (State of ( SCMPDS )) holds (for B133 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B134 being Int_position holds (for B135 being Integer holds ( IC ( IExec (( if=0 (B134 , B135 , B133) ) , R14 , B132) ) ) = ( ( card B133 ) + 1 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C167 being ( 0 ) -started (State of ( SCMPDS ));
let C168 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C169 being Int_position;
let C170 being Integer;
set D205 = ( if=0 (C169 , C170 , C168) );
L836: (C168 is_closed_on C167 , R14 & C168 is_halting_on C167 , R14) by L43 , L55;
L837: ( Initialize C167 ) = C167 by MEMSTR_0:44;
per cases ;
suppose L838: ( C167 . ( DataLoc (( C167 . C169 ) , C170) ) ) = ( 0 );

L839: ( IExec (D205 , R14 , C167) ) = ( ( IExec (C168 , R14 , C167) ) +* ( Start-At (( ( card C168 ) + 1 ) , ( SCMPDS )) ) ) by L838 , L836 , L731 , L837;
thus L840: thesis by L839 , FUNCT_4:113;
end;
suppose L841: ( C167 . ( DataLoc (( C167 . C169 ) , C170) ) ) <> ( 0 );

L842: ( IExec (D205 , R14 , C167) ) = ( C167 +* ( Start-At (( ( card C168 ) + 1 ) , ( SCMPDS )) ) ) by L841 , L782 , L837;
thus L843: thesis by L842 , FUNCT_4:113;
end;
end;
theorem
L845: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B136 being (State of ( SCMPDS )) holds (for B137 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B138 , B139 being Int_position holds (for B140 being Integer holds (( B136 . ( DataLoc (( B136 . B138 ) , B140) ) ) = ( 0 ) implies ( ( IExec (( if=0 (B138 , B140 , B137) ) , R14 , ( Initialize B136 )) ) . B139 ) = ( ( IExec (B137 , R14 , ( Initialize B136 )) ) . B139 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C171 being (State of ( SCMPDS ));
let C172 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C173 , C174 being Int_position;
let C175 being Integer;
assume L846: ( C171 . ( DataLoc (( C171 . C173 ) , C175) ) ) = ( 0 );
L847: (not C174 in ( dom ( Start-At (( ( card C172 ) + 1 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L848: (C172 is_closed_on C171 , R14 & C172 is_halting_on C171 , R14) by L43 , L55;
L849: ( IExec (( if=0 (C173 , C175 , C172) ) , R14 , ( Initialize C171 )) ) = ( ( IExec (C172 , R14 , ( Initialize C171 )) ) +* ( Start-At (( ( card C172 ) + 1 ) , ( SCMPDS )) ) ) by L848 , L846 , L731;
thus L850: thesis by L849 , L847 , FUNCT_4:11;
end;
theorem
L851: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B141 being (State of ( SCMPDS )) holds (for B142 being (Program of ( SCMPDS )) holds (for B143 , B144 being Int_position holds (for B145 being Integer holds (( B141 . ( DataLoc (( B141 . B143 ) , B145) ) ) <> ( 0 ) implies ( ( IExec (( if=0 (B143 , B145 , B142) ) , R14 , ( Initialize B141 )) ) . B144 ) = ( B141 . B144 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C176 being (State of ( SCMPDS ));
let C177 being (Program of ( SCMPDS ));
let C178 , C179 being Int_position;
let C180 being Integer;
assume L852: ( C176 . ( DataLoc (( C176 . C178 ) , C180) ) ) <> ( 0 );
L853: ( IExec (( if=0 (C178 , C180 , C177) ) , R14 , ( Initialize C176 )) ) = ( C176 +* ( Start-At (( ( card C177 ) + 1 ) , ( SCMPDS )) ) ) by L852 , L782;
L854: (not C179 in ( dom ( Start-At (( ( card C177 ) + 1 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L855: thesis by L854 , L853 , FUNCT_4:11;
end;
L856: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds ( card ( ( R4 ';' R5 ) ';' R11 ) ) = ( ( card R11 ) + 2 ))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R5 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
thus L857: ( card ( ( R4 ';' R5 ) ';' R11 ) ) = ( card ( R4 ';' ( R5 ';' R11 ) ) ) by SCMPDS_4:16
.= ( ( card ( R5 ';' R11 ) ) + 1 ) by L3
.= ( ( ( card R11 ) + 1 ) + 1 ) by L3
.= ( ( card R11 ) + 2 );
end;
begin
theorem
L858: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( card ( if<>0 (R3 , R9 , R11) ) ) = ( ( card R11 ) + 2 )))) by L856;
L859: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( ( R4 ';' R5 ) ';' R11 ) ) & 1 in ( dom ( ( R4 ';' R5 ) ';' R11 ) )))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R5 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
set D206 = ( card ( ( R4 ';' R5 ) ';' R11 ) );
L860: D206 = ( ( card R11 ) + 2 ) by L856;
L861: 2 <= D206 by L860 , NAT_1:11;
L862: 1 < D206 by L861 , XXREAL_0:2;
thus L863: thesis by L862 , AFINSQ_1:66;
end;
theorem
L864: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( if<>0 (R3 , R9 , R11) ) ) & 1 in ( dom ( if<>0 (R3 , R9 , R11) ) ))))) by L859;
L865: (for R4 being (Instruction of ( SCMPDS )) holds (for R5 being (Instruction of ( SCMPDS )) holds (for R11 being (Program of ( SCMPDS )) holds (( ( ( R4 ';' R5 ) ';' R11 ) . ( 0 ) ) = R4 & ( ( ( R4 ';' R5 ) ';' R11 ) . 1 ) = R5))))
proof
let R4 being (Instruction of ( SCMPDS ));
let R5 being (Instruction of ( SCMPDS ));
let R11 being (Program of ( SCMPDS ));
set D207 = ( R5 ';' R11 );
L866: ( ( R4 ';' R5 ) ';' R11 ) = ( R4 ';' D207 ) by SCMPDS_4:16
.= ( ( Load R4 ) ';' D207 );
L867: ( 0 ) in ( dom ( Load R4 ) ) by COMPOS_1:50;
thus L868: ( ( ( R4 ';' R5 ) ';' R11 ) . ( 0 ) ) = ( ( Load R4 ) . ( 0 ) ) by L867 , L866 , AFINSQ_1:def 3
.= R4 by COMPOS_1:52;
L869: ( 0 ) in ( dom ( Load R5 ) ) by COMPOS_1:50;
L870: ( card D207 ) = ( ( card R11 ) + 1 ) by L3;
L871: (( card ( Load R4 ) ) = 1 & ( 0 ) in ( dom D207 )) by L870 , AFINSQ_1:66 , COMPOS_1:54;
thus L872: ( ( ( R4 ';' R5 ) ';' R11 ) . 1 ) = ( ( ( Load R4 ) ';' D207 ) . ( ( 0 ) + 1 ) ) by L866
.= ( D207 . ( 0 ) ) by L871 , AFINSQ_1:def 3
.= ( ( ( Load R5 ) ';' R11 ) . ( 0 ) )
.= ( ( Load R5 ) . ( 0 ) ) by L869 , AFINSQ_1:def 3
.= R5 by COMPOS_1:52;
end;
theorem
L873: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (( ( if<>0 (R3 , R9 , R11) ) . ( 0 ) ) = ( (R3 , R9) <>0_goto 2 ) & ( ( if<>0 (R3 , R9 , R11) ) . 1 ) = ( goto ( ( card R11 ) + 1 ) ))))) by L865;
theorem
L874: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B146 being (State of ( SCMPDS )) holds (for B147 being  shiftable (Program of ( SCMPDS )) holds (for B148 being Int_position holds (for B149 being Integer holds ((( B146 . ( DataLoc (( B146 . B148 ) , B149) ) ) <> ( 0 ) & B147 is_closed_on B146 , R14 & B147 is_halting_on B146 , R14) implies (( if<>0 (B148 , B149 , B147) ) is_closed_on B146 , R14 & ( if<>0 (B148 , B149 , B147) ) is_halting_on B146 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C181 being (State of ( SCMPDS ));
let C182 being  shiftable (Program of ( SCMPDS ));
let C183 being Int_position;
let C184 being Integer;
set D208 = ( DataLoc (( C181 . C183 ) , C184) );
set D209 = ( if<>0 (C183 , C184 , C182) );
set D210 = ( stop D209 );
set D211 = ( stop C182 );
set D212 = ( Initialize C181 );
set D213 = ( R14 +* D211 );
set D214 = ( Initialize C181 );
set D215 = ( R14 +* D210 );
set D216 = ( Comput (D215 , D214 , 1) );
set D217 = D215;
set D218 = ( (C183 , C184) <>0_goto 2 );
set D219 = ( goto ( ( card C182 ) + 1 ) );
L875: D209 = ( D218 ';' ( D219 ';' C182 ) ) by SCMPDS_4:16;
L876: ( Comput (D215 , D214 , ( ( 0 ) + 1 )) ) = ( Following (D215 , ( Comput (D215 , D214 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D215 , D214) ) by EXTPRO_1:2
.= ( Exec (D218 , D214) ) by L875 , L8;
L877: (for R3 being Int_position holds ( D212 . R3 ) = ( D216 . R3 )) by L876 , SCMPDS_2:55;
L878: ( DataPart D212 ) = ( DataPart D216 ) by L877 , SCMPDS_4:8;
L879: (not D208 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L880: (not C183 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L881: ( D214 . ( DataLoc (( D214 . C183 ) , C184) ) ) = ( D214 . D208 ) by L880 , FUNCT_4:11
.= ( C181 . D208 ) by L879 , FUNCT_4:11;
L882: ( IC D214 ) = ( 0 ) by MEMSTR_0:47;
assume L883: ( C181 . D208 ) <> ( 0 );
L884: ( IC D216 ) = ( ICplusConst (D214 , 2) ) by L883 , L876 , L881 , SCMPDS_2:55
.= ( ( 0 ) + 2 ) by L882 , L18;
assume L885: C182 is_closed_on C181 , R14;
L886: C182 is_closed_on D212 , D213 by L885 , L143;
assume L887: C182 is_halting_on C181 , R14;
L888: D213 halts_on D212 by L887 , L41;
L889: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D212 & ( Shift (D211 , 2) ) c= D217) by L442 , FUNCT_4:25;
L890: ( stop C182 ) c= D213 by FUNCT_4:25;
L891: ( 0 ) in ( dom D210 ) by COMPOS_1:36;
L892:
now
let C185 being (Element of ( NAT ));
per cases ;
suppose L893: ( 0 ) < C185;

consider C186 being Nat such that L894: ( C186 + 1 ) = C185 by L893 , NAT_1:6;
reconsider D220 = C186 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D221 = ( IC ( Comput (D213 , D212 , D220) ) ) as (Element of ( NAT ));
L895: ( card D210 ) = ( 1 + ( card D209 ) ) by COMPOS_1:55
.= ( 1 + ( ( card C182 ) + 2 ) ) by L856
.= ( ( 1 + ( card C182 ) ) + 2 )
.= ( ( card D211 ) + 2 ) by COMPOS_1:55;
L896: D221 in ( dom D211 ) by L885 , L40;
L897: D221 < ( card D211 ) by L896 , AFINSQ_1:66;
L898: ( D221 + 2 ) < ( card D210 ) by L897 , L895 , XREAL_1:6;
L899: ( IC ( Comput (D215 , D214 , C185) ) ) = ( IC ( Comput (D215 , D216 , D220) ) ) by L894 , EXTPRO_1:4
.= ( D221 + 2 ) by L886 , L889 , L884 , L878 , L360 , L890;
thus L900: ( IC ( Comput (D215 , D214 , C185) ) ) in ( dom D210 ) by L899 , L898 , AFINSQ_1:66;
end;
suppose L901: C185 = ( 0 );

thus L902: ( IC ( Comput (D215 , D214 , C185) ) ) in ( dom D210 ) by L901 , L891 , L882 , EXTPRO_1:2;
end;
end;
thus L904: D209 is_closed_on C181 , R14 by L892 , L40;
L905: ( Comput (D215 , D214 , ( ( LifeSpan (D213 , D212) ) + 1 )) ) = ( Comput (D215 , ( Comput (D215 , D214 , 1) ) , ( LifeSpan (D213 , D212) )) ) by EXTPRO_1:4;
L906: ( CurInstr (D215 , ( Comput (D215 , D214 , ( ( LifeSpan (D213 , D212) ) + 1 )) )) ) = ( CurInstr (D215 , ( Comput (D215 , D216 , ( LifeSpan (D213 , D212) )) )) ) by L905
.= ( CurInstr (D213 , ( Comput (D213 , D212 , ( LifeSpan (D213 , D212) )) )) ) by L886 , L889 , L884 , L878 , L360 , L890
.= ( halt ( SCMPDS ) ) by L888 , EXTPRO_1:def 15;
L907: D215 halts_on D214 by L906 , EXTPRO_1:29;
thus L908: thesis by L907 , L41;
end;
theorem
L909: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B150 being (State of ( SCMPDS )) holds (for B151 being (Program of ( SCMPDS )) holds (for B152 being Int_position holds (for B153 being Integer holds (( B150 . ( DataLoc (( B150 . B152 ) , B153) ) ) = ( 0 ) implies (( if<>0 (B152 , B153 , B151) ) is_closed_on B150 , R14 & ( if<>0 (B152 , B153 , B151) ) is_halting_on B150 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C187 being (State of ( SCMPDS ));
let C188 being (Program of ( SCMPDS ));
let C189 being Int_position;
let C190 being Integer;
set D222 = ( DataLoc (( C187 . C189 ) , C190) );
assume L910: ( C187 . D222 ) = ( 0 );
set D223 = ( if<>0 (C189 , C190 , C188) );
set D224 = ( stop D223 );
set D225 = ( Initialize C187 );
set D226 = ( R14 +* D224 );
set D227 = ( Comput (D226 , D225 , 1) );
set D228 = ( Comput (D226 , D225 , 2) );
set D229 = D226;
set D230 = D226;
L911: (not D222 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L912: (not C189 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L913: ( D225 . ( DataLoc (( D225 . C189 ) , C190) ) ) = ( D225 . D222 ) by L912 , FUNCT_4:11
.= ( 0 ) by L910 , L911 , FUNCT_4:11;
L914: D224 c= D229 by FUNCT_4:25;
set D231 = ( (C189 , C190) <>0_goto 2 );
set D232 = ( goto ( ( card C188 ) + 1 ) );
L915: D223 = ( D231 ';' ( D232 ';' C188 ) ) by SCMPDS_4:16;
L916: ( IC D225 ) = ( 0 ) by MEMSTR_0:47;
L917: ( Comput (D226 , D225 , ( ( 0 ) + 1 )) ) = ( Following (D226 , ( Comput (D226 , D225 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D226 , D225) ) by EXTPRO_1:2
.= ( Exec (D231 , D225) ) by L915 , L8;
L918: ( IC D227 ) = ( succ ( IC D225 ) ) by L917 , L913 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L916;
L919: 1 in ( dom D223 ) by L859;
L920: 1 in ( dom D224 ) by L919 , COMPOS_1:62;
L921: ( D229 . 1 ) = ( D224 . 1 ) by L920 , L914 , GRFUNC_1:2
.= ( D223 . 1 ) by L919 , COMPOS_1:63
.= D232 by L865;
L922: ( card D223 ) = ( ( card C188 ) + 2 ) by L856;
L923: ( ( card C188 ) + 2 ) in ( dom D224 ) by L922 , COMPOS_1:64;
L924: ( D226 /. ( IC D227 ) ) = ( D226 . ( IC D227 ) ) by PBOOLE:143;
L925: ( Comput (D226 , D225 , ( 1 + 1 )) ) = ( Following (D226 , D227) ) by EXTPRO_1:3
.= ( Exec (D232 , D227) ) by L918 , L921 , L924;
L926: ( IC D228 ) = ( ICplusConst (D227 , ( ( card C188 ) + 1 )) ) by L925 , SCMPDS_2:54
.= ( ( ( card C188 ) + 1 ) + 1 ) by L918 , L18
.= ( ( card C188 ) + ( 1 + 1 ) );
L927: ( D226 /. ( IC D228 ) ) = ( D226 . ( IC D228 ) ) by PBOOLE:143;
L928: D224 c= D230 by FUNCT_4:25;
L929: ( D230 . ( ( card C188 ) + 2 ) ) = ( D224 . ( ( card C188 ) + 2 ) ) by L928 , L923 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L922 , COMPOS_1:64;
L930: ( CurInstr (D226 , D228) ) = ( halt ( SCMPDS ) ) by L929 , L926 , L927;
L931:
now
let C191 being (Element of ( NAT ));
L932: (C191 = ( 0 ) or ( ( 0 ) + 1 ) <= C191) by INT_1:7;
per cases  by L932 , XXREAL_0:1;
suppose L933: C191 = ( 0 );

L934: ( Comput (D226 , D225 , C191) ) = D225 by L933 , EXTPRO_1:2;
thus L935: ( IC ( Comput (D226 , D225 , C191) ) ) in ( dom D224 ) by L934 , L916 , COMPOS_1:36;
end;
suppose L936: C191 = 1;

thus L937: ( IC ( Comput (D226 , D225 , C191) ) ) in ( dom D224 ) by L936 , L919 , L918 , COMPOS_1:62;
end;
suppose L938: 1 < C191;

L939: ( 1 + 1 ) <= C191 by L938 , INT_1:7;
thus L940: ( IC ( Comput (D226 , D225 , C191) ) ) in ( dom D224 ) by L939 , L923 , L926 , L930 , EXTPRO_1:5;
end;
end;
thus L942: D223 is_closed_on C187 , R14 by L931 , L40;
L943: D226 halts_on D225 by L930 , EXTPRO_1:29;
thus L944: thesis by L943 , L41;
end;
theorem
L945: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B154 being (State of ( SCMPDS )) holds (for B155 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B156 being Int_position holds (for B157 being Integer holds ((( B154 . ( DataLoc (( B154 . B156 ) , B157) ) ) <> ( 0 ) & B155 is_closed_on B154 , R14 & B155 is_halting_on B154 , R14) implies ( IExec (( if<>0 (B156 , B157 , B155) ) , R14 , ( Initialize B154 )) ) = ( ( IExec (B155 , R14 , ( Initialize B154 )) ) +* ( Start-At (( ( card B155 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C192 being (State of ( SCMPDS ));
let C193 being  halt-free  shiftable (Program of ( SCMPDS ));
let C194 being Int_position;
let C195 being Integer;
set D233 = ( DataLoc (( C192 . C194 ) , C195) );
set D234 = ( if<>0 (C194 , C195 , C193) );
set D235 = ( stop C193 );
set D236 = ( stop D234 );
set D237 = ( Initialize C192 );
set D238 = ( R14 +* D235 );
set D239 = ( Initialize C192 );
set D240 = ( R14 +* D236 );
set D241 = ( Comput (D240 , D239 , 1) );
set D242 = D240;
set D243 = ( (C194 , C195) <>0_goto 2 );
set D244 = ( goto ( ( card C193 ) + 1 ) );
set D245 = ( Start-At (( ( card C193 ) + 2 ) , ( SCMPDS )) );
L946: D234 = ( D243 ';' ( D244 ';' C193 ) ) by SCMPDS_4:16;
L947: ( Comput (D240 , D239 , ( ( 0 ) + 1 )) ) = ( Following (D240 , ( Comput (D240 , D239 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D240 , D239) ) by EXTPRO_1:2
.= ( Exec (D243 , D239) ) by L946 , L8;
L948: (not D233 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L949: (not C194 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L950: ( D239 . ( DataLoc (( D239 . C194 ) , C195) ) ) = ( D239 . D233 ) by L949 , FUNCT_4:11
.= ( C192 . D233 ) by L948 , FUNCT_4:11;
L951: ( IC D239 ) = ( 0 ) by MEMSTR_0:47;
L952: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D237 & ( Shift (D235 , 2) ) c= D242) by L442 , FUNCT_4:25;
L953: ( stop C193 ) c= D238 by FUNCT_4:25;
L954: (for R3 being Int_position holds ( D237 . R3 ) = ( D241 . R3 )) by L947 , SCMPDS_2:55;
L955: ( DataPart D237 ) = ( DataPart D241 ) by L954 , SCMPDS_4:8;
assume L956: ( C192 . D233 ) <> ( 0 );
L957: ( IC D241 ) = ( ICplusConst (D239 , 2) ) by L956 , L947 , L950 , SCMPDS_2:55
.= ( ( 0 ) + 2 ) by L951 , L18;
assume L958: C193 is_closed_on C192 , R14;
L959: C193 is_closed_on D237 , D238 by L958 , L143;
assume L960: C193 is_halting_on C192 , R14;
L961: D238 halts_on D237 by L960 , L41;
L962: ( Comput (D240 , D239 , ( ( LifeSpan (D238 , D237) ) + 1 )) ) = ( Comput (D240 , ( Comput (D240 , D239 , 1) ) , ( LifeSpan (D238 , D237) )) ) by EXTPRO_1:4;
L963: ( CurInstr (D240 , ( Comput (D240 , D239 , ( ( LifeSpan (D238 , D237) ) + 1 )) )) ) = ( CurInstr (D240 , ( Comput (D240 , D241 , ( LifeSpan (D238 , D237) )) )) ) by L962
.= ( CurInstr (D238 , ( Comput (D238 , D237 , ( LifeSpan (D238 , D237) )) )) ) by L959 , L952 , L957 , L955 , L360 , L953
.= ( halt ( SCMPDS ) ) by L961 , EXTPRO_1:def 15;
L964: D240 halts_on D239 by L963 , EXTPRO_1:29;
L965: ( CurInstr (D240 , D239) ) = D243 by L946 , L8;
L966:
now
let C196 being (Element of ( NAT ));
assume L967: C196 < ( ( LifeSpan (D238 , D237) ) + 1 );
L968: ( Comput (D240 , D239 , ( 0 )) ) = D239 by EXTPRO_1:2;
per cases ;
suppose L969: C196 = ( 0 );

L970: ( CurInstr (D240 , ( Comput (D240 , D239 , C196) )) ) = ( CurInstr (D240 , D239) ) by L969 , L968;
thus L971: ( CurInstr (D240 , ( Comput (D240 , D239 , C196) )) ) <> ( halt ( SCMPDS ) ) by L970 , L965;
end;
suppose L972: C196 <> ( 0 );

consider C197 being Nat such that L973: C196 = ( C197 + 1 ) by L972 , NAT_1:6;
reconsider D246 = C197 as (Element of ( NAT )) by ORDINAL1:def 12;
L974: D246 < ( LifeSpan (D238 , D237) ) by L967 , L973 , XREAL_1:6;
assume L975: ( CurInstr (D240 , ( Comput (D240 , D239 , C196) )) ) = ( halt ( SCMPDS ) );
L976: ( Comput (D240 , D239 , ( D246 + 1 )) ) = ( Comput (D240 , ( Comput (D240 , D239 , 1) ) , D246) ) by EXTPRO_1:4;
L977: ( CurInstr (D238 , ( Comput (D238 , D237 , D246) )) ) = ( CurInstr (D240 , ( Comput (D240 , D241 , D246) )) ) by L959 , L952 , L957 , L955 , L360 , L953
.= ( halt ( SCMPDS ) ) by L973 , L975 , L976;
thus L978: contradiction by L977 , L961 , L974 , EXTPRO_1:def 15;
end;
end;
L980: (for B158 being (Element of ( NAT )) holds (( CurInstr (D240 , ( Comput (D240 , D239 , B158) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D238 , D237) ) + 1 ) <= B158)) by L966;
L981: ( LifeSpan (D240 , D239) ) = ( ( LifeSpan (D238 , D237) ) + 1 ) by L980 , L963 , L964 , EXTPRO_1:def 15;
L982: ( DataPart ( Result (D238 , D237) ) ) = ( DataPart ( Comput (D238 , D237 , ( LifeSpan (D238 , D237) )) ) ) by L961 , EXTPRO_1:23
.= ( DataPart ( Comput (D240 , D241 , ( LifeSpan (D238 , D237) )) ) ) by L959 , L952 , L957 , L955 , L360 , L953
.= ( DataPart ( Comput (D240 , D239 , ( ( LifeSpan (D238 , D237) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D240 , D239) ) ) by L964 , L981 , EXTPRO_1:23;
L983:
now
let C198 being set;
L984: ( dom ( Start-At (( ( card C193 ) + 2 ) , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L985: C198 in ( dom ( IExec (D234 , R14 , ( Initialize C192 )) ) );
per cases  by L985 , SCMPDS_4:6;
suppose L986: C198 is Int_position;

L987: C198 <> ( IC ( SCMPDS ) ) by L986 , SCMPDS_2:43;
L988: (not C198 in ( dom D245 )) by L987 , L984 , TARSKI:def 1;
thus L989: ( ( IExec (D234 , R14 , ( Initialize C192 )) ) . C198 ) = ( ( Result (D240 , D239) ) . C198 )
.= ( ( Result (D238 , D237) ) . C198 ) by L982 , L986 , SCMPDS_4:8
.= ( ( IExec (C193 , R14 , ( Initialize C192 )) ) . C198 )
.= ( ( ( IExec (C193 , R14 , ( Initialize C192 )) ) +* D245 ) . C198 ) by L988 , FUNCT_4:11;
end;
suppose L990: C198 = ( IC ( SCMPDS ) );

L991: ( IC ( Result (D238 , D237) ) ) = ( IC ( IExec (C193 , R14 , ( Initialize C192 )) ) )
.= ( card C193 ) by L958 , L960 , L416;
L992: C198 in ( dom D245 ) by L984 , L990 , TARSKI:def 1;
thus L993: ( ( IExec (D234 , R14 , ( Initialize C192 )) ) . C198 ) = ( ( Result (D240 , D239) ) . C198 )
.= ( ( Comput (D240 , D239 , ( ( LifeSpan (D238 , D237) ) + 1 )) ) . C198 ) by L964 , L981 , EXTPRO_1:23
.= ( IC ( Comput (D240 , D241 , ( LifeSpan (D238 , D237) )) ) ) by L990 , EXTPRO_1:4
.= ( ( IC ( Comput (D238 , D237 , ( LifeSpan (D238 , D237) )) ) ) + 2 ) by L959 , L952 , L957 , L955 , L360 , L953
.= ( ( IC ( Result (D238 , D237) ) ) + 2 ) by L961 , EXTPRO_1:23
.= ( IC D245 ) by L991 , FUNCOP_1:72
.= ( ( ( IExec (C193 , R14 , ( Initialize C192 )) ) +* D245 ) . C198 ) by L990 , L992 , FUNCT_4:13;
end;
end;
L995: ( dom ( IExec (D234 , R14 , ( Initialize C192 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C193 , R14 , ( Initialize C192 )) ) +* ( Start-At (( ( card C193 ) + 2 ) , ( SCMPDS )) ) ) ) by PARTFUN1:def 2;
thus L996: thesis by L995 , L983 , FUNCT_1:2;
end;
theorem
L997: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B159 being (State of ( SCMPDS )) holds (for B160 being (Program of ( SCMPDS )) holds (for B161 being Int_position holds (for B162 being Integer holds (( B159 . ( DataLoc (( B159 . B161 ) , B162) ) ) = ( 0 ) implies ( IExec (( if<>0 (B161 , B162 , B160) ) , R14 , ( Initialize B159 )) ) = ( B159 +* ( Start-At (( ( card B160 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C199 being (State of ( SCMPDS ));
let C200 being (Program of ( SCMPDS ));
let C201 being Int_position;
let C202 being Integer;
set D247 = ( DataLoc (( C199 . C201 ) , C202) );
assume L998: ( C199 . D247 ) = ( 0 );
set D248 = ( Start-At (( ( card C200 ) + 2 ) , ( SCMPDS )) );
set D249 = ( (C201 , C202) <>0_goto 2 );
set D250 = ( goto ( ( card C200 ) + 1 ) );
set D251 = ( if<>0 (C201 , C202 , C200) );
set D252 = ( stop D251 );
set D253 = ( Initialize C199 );
set D254 = ( R14 +* D252 );
set D255 = ( Comput (D254 , D253 , 1) );
set D256 = ( Comput (D254 , D253 , 2) );
set D257 = D254;
set D258 = D254;
L999: D251 = ( D249 ';' ( D250 ';' C200 ) ) by SCMPDS_4:16;
L1000: D252 c= D254 by FUNCT_4:25;
L1001: D252 c= D257 by L1000;
L1002: D252 c= D258 by L1000;
L1003: (not D247 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1004: ( IC D253 ) = ( 0 ) by MEMSTR_0:47;
L1005: ( Comput (D254 , D253 , ( ( 0 ) + 1 )) ) = ( Following (D254 , ( Comput (D254 , D253 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D254 , D253) ) by EXTPRO_1:2
.= ( Exec (D249 , D253) ) by L999 , L8;
L1006: (not C201 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1007: ( D253 . ( DataLoc (( D253 . C201 ) , C202) ) ) = ( D253 . D247 ) by L1006 , FUNCT_4:11
.= ( 0 ) by L998 , L1003 , FUNCT_4:11;
L1008: ( IC D255 ) = ( succ ( IC D253 ) ) by L1007 , L1005 , SCMPDS_2:55
.= ( ( 0 ) + 1 ) by L1004;
L1009: 1 in ( dom D251 ) by L859;
L1010: 1 in ( dom D252 ) by L1009 , COMPOS_1:62;
L1011: ( D257 . 1 ) = ( D252 . 1 ) by L1010 , L1001 , GRFUNC_1:2
.= ( D251 . 1 ) by L1009 , COMPOS_1:63
.= D250 by L865;
L1012: ( D254 /. ( IC D255 ) ) = ( D254 . ( IC D255 ) ) by PBOOLE:143;
L1013: ( Comput (D254 , D253 , ( 1 + 1 )) ) = ( Following (D254 , D255) ) by EXTPRO_1:3
.= ( Exec (D250 , D255) ) by L1008 , L1011 , L1012;
L1014: ( IC D256 ) = ( ICplusConst (D255 , ( ( card C200 ) + 1 )) ) by L1013 , SCMPDS_2:54
.= ( ( ( card C200 ) + 1 ) + 1 ) by L1008 , L18
.= ( ( card C200 ) + ( 1 + 1 ) );
L1015: ( D254 /. ( IC D256 ) ) = ( D254 . ( IC D256 ) ) by PBOOLE:143;
L1016: ( card D251 ) = ( ( card C200 ) + 2 ) by L856;
L1017: ( ( card C200 ) + 2 ) in ( dom D252 ) by L1016 , COMPOS_1:64;
L1018: ( D258 . ( ( card C200 ) + 2 ) ) = ( D252 . ( ( card C200 ) + 2 ) ) by L1017 , L1002 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L1016 , COMPOS_1:64;
L1019: ( CurInstr (D254 , D256) ) = ( halt ( SCMPDS ) ) by L1018 , L1014 , L1015;
L1020: D254 halts_on D253 by L1019 , EXTPRO_1:29;
L1021: ( CurInstr (D254 , D253) ) = D249 by L999 , L8;
L1022:
now
let C203 being (Element of ( NAT ));
assume L1023: C203 < ( 1 + 1 );
L1024: C203 <= 1 by L1023 , NAT_1:13;
L1025: ( Comput (D254 , D253 , ( 0 )) ) = D253 by EXTPRO_1:2;
L1026: ( D254 /. ( IC ( Comput (D254 , D253 , C203) ) ) ) = ( D254 . ( IC ( Comput (D254 , D253 , C203) ) ) ) by PBOOLE:143;
per cases  by L1024 , NAT_1:25;
suppose L1027: C203 = ( 0 );

L1028: ( CurInstr (D254 , ( Comput (D254 , D253 , C203) )) ) = ( CurInstr (D254 , D253) ) by L1027 , L1025;
thus L1029: ( CurInstr (D254 , ( Comput (D254 , D253 , C203) )) ) <> ( halt ( SCMPDS ) ) by L1028 , L1021;
end;
suppose L1030: C203 = 1;

thus L1031: ( CurInstr (D254 , ( Comput (D254 , D253 , C203) )) ) <> ( halt ( SCMPDS ) ) by L1030 , L1008 , L1011 , L1026;
end;
end;
L1033: (for B163 being (Element of ( NAT )) holds (( CurInstr (D254 , ( Comput (D254 , D253 , B163) )) ) = ( halt ( SCMPDS ) ) implies 2 <= B163)) by L1022;
L1034: ( LifeSpan (D254 , D253) ) = 2 by L1033 , L1019 , L1020 , EXTPRO_1:def 15;
L1035: D256 = ( Result (D254 , D253) ) by L1034 , L1020 , EXTPRO_1:23;
L1036:
now
L1037: ( dom D248 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
let C204 being set;
assume L1038: C204 in ( dom ( IExec (D251 , R14 , ( Initialize C199 )) ) );
per cases  by L1038 , SCMPDS_4:6;
suppose L1039: C204 is Int_position;

L1040: C204 <> ( IC ( SCMPDS ) ) by L1039 , SCMPDS_2:43;
L1041: (not C204 in ( dom D248 )) by L1040 , L1037 , TARSKI:def 1;
L1042: (not C204 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L1039 , SCMPDS_4:18;
thus L1043: ( ( IExec (D251 , R14 , ( Initialize C199 )) ) . C204 ) = ( D256 . C204 ) by L1035
.= ( D255 . C204 ) by L1013 , L1039 , SCMPDS_2:54
.= ( D253 . C204 ) by L1005 , L1039 , SCMPDS_2:55
.= ( C199 . C204 ) by L1042 , FUNCT_4:11
.= ( ( C199 +* D248 ) . C204 ) by L1041 , FUNCT_4:11;
end;
suppose L1044: C204 = ( IC ( SCMPDS ) );

thus L1045: ( ( IExec (D251 , R14 , ( Initialize C199 )) ) . C204 ) = ( ( card C200 ) + 2 ) by L1044 , L1014 , L1035
.= ( ( C199 +* ( Start-At (( ( card C200 ) + 2 ) , ( SCMPDS )) ) ) . C204 ) by L1044 , FUNCT_4:113;
end;
end;
L1047: ( dom ( IExec (D251 , R14 , ( Initialize C199 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C199 +* D248 ) ) by PARTFUN1:def 2;
thus L1048: thesis by L1047 , L1036 , FUNCT_1:2;
end;
registration
let C205 being  shiftable  parahalting (Program of ( SCMPDS ));
let C206 being Int_position;
let C207 being Integer;
cluster ( if<>0 (C206 , C207 , C205) ) ->  shiftable  parahalting;
correctness
proof
set D259 = ( (C206 , C207) <>0_goto 2 );
set D260 = ( goto ( ( card C205 ) + 1 ) );
set D261 = ( if<>0 (C206 , C207 , C205) );
set D262 = ( stop D261 );
thus L1049: D261 is  shiftable;
let C208 being ( 0 ) -started (State of ( SCMPDS ));
let C209 being (Instruction-Sequence of ( SCMPDS ));
L1050: ( Initialize C208 ) = C208 by MEMSTR_0:44;
assume L1051: D262 c= C209;
L1052: C209 = ( C209 +* ( stop D261 ) ) by L1051 , FUNCT_4:98;
L1053: (C205 is_closed_on C208 , C209 & C205 is_halting_on C208 , C209) by L43 , L55;
per cases ;
suppose L1054: ( C208 . ( DataLoc (( C208 . C206 ) , C207) ) ) <> ( 0 );

L1055: D261 is_halting_on C208 , C209 by L1054 , L1053 , L874;
thus L1056: C209 halts_on C208 by L1055 , L1050 , L1052 , L41;
end;
suppose L1057: ( C208 . ( DataLoc (( C208 . C206 ) , C207) ) ) = ( 0 );

L1058: D261 is_halting_on C208 , C209 by L1057 , L909;
thus L1059: C209 halts_on C208 by L1058 , L1050 , L1052 , L41;
end;
end;
end;
registration
let C210 being  halt-free (Program of ( SCMPDS ));
let C211 being Int_position;
let C212 being Integer;
cluster ( if<>0 (C211 , C212 , C210) ) ->  halt-free;
coherence;
end;
theorem
L1063: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B164 being (State of ( SCMPDS )) holds (for B165 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B166 being Int_position holds (for B167 being Integer holds ( IC ( IExec (( if<>0 (B166 , B167 , B165) ) , R14 , ( Initialize B164 )) ) ) = ( ( card B165 ) + 2 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C213 being (State of ( SCMPDS ));
let C214 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C215 being Int_position;
let C216 being Integer;
set D263 = ( if<>0 (C215 , C216 , C214) );
L1064: (C214 is_closed_on C213 , R14 & C214 is_halting_on C213 , R14) by L43 , L55;
per cases ;
suppose L1065: ( C213 . ( DataLoc (( C213 . C215 ) , C216) ) ) <> ( 0 );

L1066: ( IExec (D263 , R14 , ( Initialize C213 )) ) = ( ( IExec (C214 , R14 , ( Initialize C213 )) ) +* ( Start-At (( ( card C214 ) + 2 ) , ( SCMPDS )) ) ) by L1065 , L1064 , L945;
thus L1067: thesis by L1066 , FUNCT_4:113;
end;
suppose L1068: ( C213 . ( DataLoc (( C213 . C215 ) , C216) ) ) = ( 0 );

L1069: ( IExec (D263 , R14 , ( Initialize C213 )) ) = ( C213 +* ( Start-At (( ( card C214 ) + 2 ) , ( SCMPDS )) ) ) by L1068 , L997;
thus L1070: thesis by L1069 , FUNCT_4:113;
end;
end;
theorem
L1072: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B168 being (State of ( SCMPDS )) holds (for B169 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B170 , B171 being Int_position holds (for B172 being Integer holds (( B168 . ( DataLoc (( B168 . B170 ) , B172) ) ) <> ( 0 ) implies ( ( IExec (( if<>0 (B170 , B172 , B169) ) , R14 , ( Initialize B168 )) ) . B171 ) = ( ( IExec (B169 , R14 , ( Initialize B168 )) ) . B171 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C217 being (State of ( SCMPDS ));
let C218 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C219 , C220 being Int_position;
let C221 being Integer;
assume L1073: ( C217 . ( DataLoc (( C217 . C219 ) , C221) ) ) <> ( 0 );
L1074: (not C220 in ( dom ( Start-At (( ( card C218 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1075: (C218 is_closed_on C217 , R14 & C218 is_halting_on C217 , R14) by L43 , L55;
L1076: ( IExec (( if<>0 (C219 , C221 , C218) ) , R14 , ( Initialize C217 )) ) = ( ( IExec (C218 , R14 , ( Initialize C217 )) ) +* ( Start-At (( ( card C218 ) + 2 ) , ( SCMPDS )) ) ) by L1075 , L1073 , L945;
thus L1077: thesis by L1076 , L1074 , FUNCT_4:11;
end;
theorem
L1078: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B173 being (State of ( SCMPDS )) holds (for B174 being (Program of ( SCMPDS )) holds (for B175 , B176 being Int_position holds (for B177 being Integer holds (( B173 . ( DataLoc (( B173 . B175 ) , B177) ) ) = ( 0 ) implies ( ( IExec (( if<>0 (B175 , B177 , B174) ) , R14 , ( Initialize B173 )) ) . B176 ) = ( B173 . B176 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C222 being (State of ( SCMPDS ));
let C223 being (Program of ( SCMPDS ));
let C224 , C225 being Int_position;
let C226 being Integer;
assume L1079: ( C222 . ( DataLoc (( C222 . C224 ) , C226) ) ) = ( 0 );
L1080: ( IExec (( if<>0 (C224 , C226 , C223) ) , R14 , ( Initialize C222 )) ) = ( C222 +* ( Start-At (( ( card C223 ) + 2 ) , ( SCMPDS )) ) ) by L1079 , L997;
L1081: (not C225 in ( dom ( Start-At (( ( card C223 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L1082: thesis by L1081 , L1080 , FUNCT_4:11;
end;
begin
theorem
L1083: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( card ( if>0 (R3 , R9 , R11 , R12) ) ) = ( ( ( card R11 ) + ( card R12 ) ) + 2 ))))) by L423;
theorem
L1084: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( if>0 (R3 , R9 , R11 , R12) ) ) & 1 in ( dom ( if>0 (R3 , R9 , R11 , R12) ) ))))))
proof
let R3 being Int_position;
let R9 being Integer;
let R11 being (Program of ( SCMPDS ));
let R12 being (Program of ( SCMPDS ));
set D264 = ( card ( if>0 (R3 , R9 , R11 , R12) ) );
L1085: D264 = ( ( ( card R11 ) + ( card R12 ) ) + 2 ) by L423;
L1086: 2 <= D264 by L1085 , NAT_1:12;
L1087: 1 < D264 by L1086 , XXREAL_0:2;
thus L1088: thesis by L1087 , AFINSQ_1:66;
end;
theorem
L1089: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( ( if>0 (R3 , R9 , R11 , R12) ) . ( 0 ) ) = ( (R3 , R9) <=0_goto ( ( card R11 ) + 2 ) ))))) by L431;
theorem
L1090: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B178 being ( 0 ) -started (State of ( SCMPDS )) holds (for B179 , B180 being  shiftable (Program of ( SCMPDS )) holds (for B181 being Int_position holds (for B182 being Integer holds ((( B178 . ( DataLoc (( B178 . B181 ) , B182) ) ) > ( 0 ) & B179 is_closed_on B178 , R14 & B179 is_halting_on B178 , R14) implies (( if>0 (B181 , B182 , B179 , B180) ) is_closed_on B178 , R14 & ( if>0 (B181 , B182 , B179 , B180) ) is_halting_on B178 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C227 being ( 0 ) -started (State of ( SCMPDS ));
let C228 , C229 being  shiftable (Program of ( SCMPDS ));
let C230 being Int_position;
let C231 being Integer;
set D265 = ( DataLoc (( C227 . C230 ) , C231) );
set D266 = ( Goto ( ( card C229 ) + 1 ) );
set D267 = ( ( C228 ';' D266 ) ';' C229 );
set D268 = ( if>0 (C230 , C231 , C228 , C229) );
set D269 = ( stop D268 );
set D270 = ( stop D267 );
set D271 = ( Initialize C227 );
set D272 = ( R14 +* D270 );
set D273 = ( R14 +* D269 );
set D274 = ( Comput (D273 , C227 , 1) );
set D275 = D273;
set D276 = ( (C230 , C231) <=0_goto ( ( card C228 ) + 2 ) );
L1091: ( 0 ) in ( dom D269 ) by COMPOS_1:36;
L1092: ( Initialize C227 ) = C227 by MEMSTR_0:44;
L1093: ( IC C227 ) = ( 0 ) by L1092 , MEMSTR_0:47;
L1094: D268 = ( ( D276 ';' ( C228 ';' D266 ) ) ';' C229 ) by SCMPDS_4:14
.= ( D276 ';' D267 ) by SCMPDS_4:14;
L1095: ( Shift (D270 , 1) ) c= D275 by L1094 , L436;
L1096: ( Comput (D273 , C227 , ( ( 0 ) + 1 )) ) = ( Following (D273 , ( Comput (D273 , C227 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D273 , C227) ) by EXTPRO_1:2
.= ( Exec (D276 , C227) ) by L1094 , L8 , L1092;
L1097: (for R3 being Int_position holds ( D271 . R3 ) = ( D274 . R3 )) by L1096 , L1092 , SCMPDS_2:56;
L1098: ( DataPart D271 ) = ( DataPart D274 ) by L1097 , SCMPDS_4:8;
assume L1099: ( C227 . D265 ) > ( 0 );
L1100: ( IC D274 ) = ( succ ( IC C227 ) ) by L1099 , L1096 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L1093;
assume L1101: C228 is_closed_on C227 , R14;
assume L1102: C228 is_halting_on C227 , R14;
L1103: D267 is_closed_on C227 , R14 by L1102 , L1101 , L284;
L1104: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D271 & D267 is_closed_on D271 , D272) by L1103 , L143 , FUNCT_4:25;
L1105: ( stop D267 ) c= D272 by FUNCT_4:25;
L1106: D267 is_halting_on C227 , R14 by L1101 , L1102 , L284;
L1107: D272 halts_on D271 by L1106 , L41;
L1108: ( card D269 ) = ( ( card D268 ) + 1 ) by COMPOS_1:55
.= ( ( ( card D267 ) + 1 ) + 1 ) by L1094 , L3;
L1109:
now
let C232 being (Element of ( NAT ));
per cases ;
suppose L1110: ( 0 ) < C232;

consider C233 being Nat such that L1111: ( C233 + 1 ) = C232 by L1110 , NAT_1:6;
reconsider D277 = C233 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D278 = ( IC ( Comput (D272 , D271 , D277) ) ) as (Element of ( NAT ));
L1112: ( card D269 ) = ( ( card D270 ) + 1 ) by L1108 , COMPOS_1:55;
L1113: D278 in ( dom D270 ) by L1103 , L40;
L1114: D278 < ( card D270 ) by L1113 , AFINSQ_1:66;
L1115: ( D278 + 1 ) < ( card D269 ) by L1114 , L1112 , XREAL_1:6;
L1116: ( IC ( Comput (D273 , C227 , C232) ) ) = ( IC ( Comput (D273 , D274 , D277) ) ) by L1111 , EXTPRO_1:4
.= ( D278 + 1 ) by L1104 , L1095 , L1100 , L1098 , L360 , L1105;
thus L1117: ( IC ( Comput (D273 , C227 , C232) ) ) in ( dom D269 ) by L1116 , L1115 , AFINSQ_1:66;
end;
suppose L1118: C232 = ( 0 );

thus L1119: ( IC ( Comput (D273 , C227 , C232) ) ) in ( dom D269 ) by L1118 , L1091 , L1093 , EXTPRO_1:2;
end;
end;
thus L1121: D268 is_closed_on C227 , R14 by L1109 , L40 , L1092;
L1122: ( Comput (D273 , C227 , ( ( LifeSpan (D272 , D271) ) + 1 )) ) = ( Comput (D273 , ( Comput (D273 , C227 , 1) ) , ( LifeSpan (D272 , D271) )) ) by EXTPRO_1:4;
L1123: ( CurInstr (D273 , ( Comput (D273 , C227 , ( ( LifeSpan (D272 , D271) ) + 1 )) )) ) = ( CurInstr (D273 , ( Comput (D273 , D274 , ( LifeSpan (D272 , D271) )) )) ) by L1122
.= ( CurInstr (D272 , ( Comput (D272 , D271 , ( LifeSpan (D272 , D271) )) )) ) by L1104 , L1095 , L1100 , L1098 , L360 , L1105
.= ( halt ( SCMPDS ) ) by L1107 , EXTPRO_1:def 15;
L1124: D273 halts_on C227 by L1123 , EXTPRO_1:29;
thus L1125: thesis by L1124 , L41 , L1092;
end;
theorem
L1126: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B183 being (State of ( SCMPDS )) holds (for B184 being (Program of ( SCMPDS )) holds (for B185 being  shiftable (Program of ( SCMPDS )) holds (for B186 being Int_position holds (for B187 being Integer holds ((( B183 . ( DataLoc (( B183 . B186 ) , B187) ) ) <= ( 0 ) & B185 is_closed_on B183 , R14 & B185 is_halting_on B183 , R14) implies (( if>0 (B186 , B187 , B184 , B185) ) is_closed_on B183 , R14 & ( if>0 (B186 , B187 , B184 , B185) ) is_halting_on B183 , R14))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C234 being (State of ( SCMPDS ));
let C235 being (Program of ( SCMPDS ));
let C236 being  shiftable (Program of ( SCMPDS ));
let C237 being Int_position;
let C238 being Integer;
set D279 = ( DataLoc (( C234 . C237 ) , C238) );
set D280 = ( stop C236 );
set D281 = ( Initialize C234 );
set D282 = ( R14 +* D280 );
set D283 = ( if>0 (C237 , C238 , C235 , C236) );
set D284 = ( stop D283 );
set D285 = ( Initialize C234 );
set D286 = ( R14 +* D284 );
set D287 = ( Comput (D286 , D285 , 1) );
set D288 = D286;
set D289 = ( (C237 , C238) <=0_goto ( ( card C235 ) + 2 ) );
set D290 = ( Goto ( ( card C236 ) + 1 ) );
set D291 = ( ( D289 ';' C235 ) ';' D290 );
L1127: D283 = ( ( D289 ';' ( C235 ';' D290 ) ) ';' C236 ) by SCMPDS_4:14
.= ( D289 ';' ( ( C235 ';' D290 ) ';' C236 ) ) by SCMPDS_4:14;
L1128: ( Comput (D286 , D285 , ( ( 0 ) + 1 )) ) = ( Following (D286 , ( Comput (D286 , D285 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D286 , D285) ) by EXTPRO_1:2
.= ( Exec (D289 , D285) ) by L1127 , L8;
L1129: (not D279 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1130: (not C237 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1131: ( D285 . ( DataLoc (( D285 . C237 ) , C238) ) ) = ( D285 . D279 ) by L1130 , FUNCT_4:11
.= ( C234 . D279 ) by L1129 , FUNCT_4:11;
L1132: ( IC D285 ) = ( 0 ) by MEMSTR_0:47;
assume L1133: ( C234 . D279 ) <= ( 0 );
L1134: ( IC D287 ) = ( ICplusConst (D285 , ( ( card C235 ) + 2 )) ) by L1133 , L1128 , L1131 , SCMPDS_2:56
.= ( ( 0 ) + ( ( card C235 ) + 2 ) ) by L1132 , L18;
assume L1135: C236 is_closed_on C234 , R14;
L1136: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D281 & C236 is_closed_on D281 , D282) by L1135 , L143 , FUNCT_4:25;
L1137: ( stop C236 ) c= D282 by FUNCT_4:25;
L1138: D284 c= D286 by FUNCT_4:25;
L1139: ( card D291 ) = ( ( card ( D289 ';' C235 ) ) + ( card D290 ) ) by AFINSQ_1:17
.= ( ( card ( D289 ';' C235 ) ) + 1 ) by COMPOS_1:54
.= ( ( ( card C235 ) + 1 ) + 1 ) by L3
.= ( ( card C235 ) + ( 1 + 1 ) );
L1140: ( Shift (D280 , ( ( card C235 ) + 2 )) ) c= D284 by L1139 , L21;
L1141: ( Shift (D280 , ( ( card C235 ) + 2 )) ) c= D288 by L1140 , L1138 , XBOOLE_1:1;
assume L1142: C236 is_halting_on C234 , R14;
L1143: D282 halts_on D281 by L1142 , L41;
L1144: (for R3 being Int_position holds ( D281 . R3 ) = ( D287 . R3 )) by L1128 , SCMPDS_2:56;
L1145: ( DataPart D281 ) = ( DataPart D287 ) by L1144 , SCMPDS_4:8;
L1146:
now
let C239 being (Element of ( NAT ));
per cases ;
suppose L1147: ( 0 ) < C239;

consider C240 being Nat such that L1148: ( C240 + 1 ) = C239 by L1147 , NAT_1:6;
reconsider D292 = C240 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D293 = ( IC ( Comput (D282 , D281 , D292) ) ) as (Element of ( NAT ));
L1149: D293 in ( dom D280 ) by L1135 , L40;
L1150: D293 < ( card D280 ) by L1149 , AFINSQ_1:66;
L1151: ( D293 + ( ( card C235 ) + 2 ) ) < ( ( card D280 ) + ( ( card C235 ) + 2 ) ) by L1150 , XREAL_1:6;
L1152: ( card D280 ) = ( ( card C236 ) + 1 ) by COMPOS_1:55;
L1153: ( card D284 ) = ( ( card D283 ) + 1 ) by COMPOS_1:55
.= ( ( ( ( card C235 ) + 2 ) + ( card C236 ) ) + 1 ) by L1139 , AFINSQ_1:17
.= ( ( ( card C235 ) + 2 ) + ( card D280 ) ) by L1152;
L1154: ( IC ( Comput (D286 , D285 , C239) ) ) = ( IC ( Comput (D286 , D287 , D292) ) ) by L1148 , EXTPRO_1:4
.= ( D293 + ( ( card C235 ) + 2 ) ) by L1136 , L1145 , L1141 , L1134 , L360 , L1137;
thus L1155: ( IC ( Comput (D286 , D285 , C239) ) ) in ( dom D284 ) by L1154 , L1153 , L1151 , AFINSQ_1:66;
end;
suppose L1156: C239 = ( 0 );

L1157: ( Comput (D286 , D285 , C239) ) = D285 by L1156 , EXTPRO_1:2;
thus L1158: ( IC ( Comput (D286 , D285 , C239) ) ) in ( dom D284 ) by L1157 , L1132 , COMPOS_1:36;
end;
end;
thus L1160: D283 is_closed_on C234 , R14 by L1146 , L40;
L1161: ( Comput (D286 , D285 , ( ( LifeSpan (D282 , D281) ) + 1 )) ) = ( Comput (D286 , ( Comput (D286 , D285 , 1) ) , ( LifeSpan (D282 , D281) )) ) by EXTPRO_1:4;
L1162: ( CurInstr (D286 , ( Comput (D286 , D285 , ( ( LifeSpan (D282 , D281) ) + 1 )) )) ) = ( CurInstr (D286 , ( Comput (D286 , D287 , ( LifeSpan (D282 , D281) )) )) ) by L1161
.= ( CurInstr (D282 , ( Comput (D282 , D281 , ( LifeSpan (D282 , D281) )) )) ) by L1136 , L1145 , L1141 , L1134 , L360 , L1137
.= ( halt ( SCMPDS ) ) by L1143 , EXTPRO_1:def 15;
L1163: D286 halts_on D285 by L1162 , EXTPRO_1:29;
thus L1164: thesis by L1163 , L41;
end;
theorem
L1165: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B188 being ( 0 ) -started (State of ( SCMPDS )) holds (for B189 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B190 being  shiftable (Program of ( SCMPDS )) holds (for B191 being Int_position holds (for B192 being Integer holds ((( B188 . ( DataLoc (( B188 . B191 ) , B192) ) ) > ( 0 ) & B189 is_closed_on B188 , R14 & B189 is_halting_on B188 , R14) implies ( IExec (( if>0 (B191 , B192 , B189 , B190) ) , R14 , B188) ) = ( ( IExec (B189 , R14 , B188) ) +* ( Start-At (( ( ( card B189 ) + ( card B190 ) ) + 2 ) , ( SCMPDS )) ) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C241 being ( 0 ) -started (State of ( SCMPDS ));
let C242 being  halt-free  shiftable (Program of ( SCMPDS ));
let C243 being  shiftable (Program of ( SCMPDS ));
let C244 being Int_position;
let C245 being Integer;
set D294 = ( DataLoc (( C241 . C244 ) , C245) );
set D295 = ( Goto ( ( card C243 ) + 1 ) );
set D296 = ( ( C242 ';' D295 ) ';' C243 );
set D297 = ( if>0 (C244 , C245 , C242 , C243) );
set D298 = ( stop D297 );
set D299 = ( stop D296 );
set D300 = ( R14 +* D299 );
set D301 = ( R14 +* D298 );
set D302 = ( Comput (D301 , C241 , 1) );
set D303 = D301;
set D304 = ( (C244 , C245) <=0_goto ( ( card C242 ) + 2 ) );
set D305 = ( Start-At (( ( ( card C242 ) + ( card C243 ) ) + 2 ) , ( SCMPDS )) );
L1166: ( Initialize C241 ) = C241 by MEMSTR_0:44;
L1167: ( IC C241 ) = ( 0 ) by L1166 , MEMSTR_0:47;
L1168: D297 = ( ( D304 ';' ( C242 ';' D295 ) ) ';' C243 ) by SCMPDS_4:14
.= ( D304 ';' D296 ) by SCMPDS_4:14;
L1169: ( Shift (D299 , 1) ) c= D303 by L1168 , L436;
L1170: ( Comput (D301 , C241 , ( ( 0 ) + 1 )) ) = ( Following (D301 , ( Comput (D301 , C241 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D301 , C241) ) by EXTPRO_1:2
.= ( Exec (D304 , C241) ) by L1168 , L8 , L1166;
assume L1171: ( C241 . D294 ) > ( 0 );
L1172: ( IC D302 ) = ( succ ( IC C241 ) ) by L1171 , L1170 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L1167;
L1173: (for R3 being Int_position holds ( C241 . R3 ) = ( D302 . R3 )) by L1170 , SCMPDS_2:56;
L1174: ( DataPart C241 ) = ( DataPart D302 ) by L1173 , SCMPDS_4:8;
assume L1175: C242 is_closed_on C241 , R14;
assume L1176: C242 is_halting_on C241 , R14;
L1177: D296 is_halting_on C241 , R14 by L1176 , L1175 , L284;
L1178: D300 halts_on C241 by L1177 , L41 , L1166;
L1179: D296 is_closed_on C241 , R14 by L1175 , L1176 , L284;
L1180: (( Start-At (( 0 ) , ( SCMPDS )) ) c= C241 & D296 is_closed_on C241 , D300) by L1179 , L143 , L1166 , FUNCT_4:25;
L1181: ( stop D296 ) c= D300 by FUNCT_4:25;
L1182: ( Comput (D301 , C241 , ( ( LifeSpan (D300 , C241) ) + 1 )) ) = ( Comput (D301 , ( Comput (D301 , C241 , 1) ) , ( LifeSpan (D300 , C241) )) ) by EXTPRO_1:4;
L1183: ( CurInstr (D301 , ( Comput (D301 , C241 , ( ( LifeSpan (D300 , C241) ) + 1 )) )) ) = ( CurInstr (D301 , ( Comput (D301 , D302 , ( LifeSpan (D300 , C241) )) )) ) by L1182
.= ( CurInstr (D300 , ( Comput (D300 , C241 , ( LifeSpan (D300 , C241) )) )) ) by L1180 , L1169 , L1172 , L1174 , L360 , L1181
.= ( halt ( SCMPDS ) ) by L1178 , EXTPRO_1:def 15;
L1184: D301 halts_on C241 by L1183 , EXTPRO_1:29;
L1185: ( CurInstr (D301 , C241) ) = D304 by L1168 , L8 , L1166;
L1186:
now
let C246 being (Element of ( NAT ));
assume L1187: C246 < ( ( LifeSpan (D300 , C241) ) + 1 );
L1188: ( Comput (D301 , C241 , ( 0 )) ) = C241 by EXTPRO_1:2;
per cases ;
suppose L1189: C246 = ( 0 );

L1190: ( CurInstr (D301 , ( Comput (D301 , C241 , C246) )) ) = ( CurInstr (D301 , C241) ) by L1189 , L1188;
thus L1191: ( CurInstr (D301 , ( Comput (D301 , C241 , C246) )) ) <> ( halt ( SCMPDS ) ) by L1190 , L1185;
end;
suppose L1192: C246 <> ( 0 );

consider C247 being Nat such that L1193: C246 = ( C247 + 1 ) by L1192 , NAT_1:6;
reconsider D306 = C247 as (Element of ( NAT )) by ORDINAL1:def 12;
L1194: D306 < ( LifeSpan (D300 , C241) ) by L1187 , L1193 , XREAL_1:6;
assume L1195: ( CurInstr (D301 , ( Comput (D301 , C241 , C246) )) ) = ( halt ( SCMPDS ) );
L1196: ( Comput (D301 , C241 , ( D306 + 1 )) ) = ( Comput (D301 , ( Comput (D301 , C241 , 1) ) , D306) ) by EXTPRO_1:4;
L1197: ( CurInstr (D300 , ( Comput (D300 , C241 , D306) )) ) = ( CurInstr (D301 , ( Comput (D301 , D302 , D306) )) ) by L1180 , L1169 , L1172 , L1174 , L360 , L1181
.= ( halt ( SCMPDS ) ) by L1193 , L1195 , L1196;
thus L1198: contradiction by L1197 , L1178 , L1194 , EXTPRO_1:def 15;
end;
end;
L1200: (for B193 being (Element of ( NAT )) holds (( CurInstr (D301 , ( Comput (D301 , C241 , B193) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D300 , C241) ) + 1 ) <= B193)) by L1186;
L1201: ( LifeSpan (D301 , C241) ) = ( ( LifeSpan (D300 , C241) ) + 1 ) by L1200 , L1183 , L1184 , EXTPRO_1:def 15;
L1202: ( DataPart ( Result (D300 , C241) ) ) = ( DataPart ( Comput (D300 , C241 , ( LifeSpan (D300 , C241) )) ) ) by L1178 , EXTPRO_1:23
.= ( DataPart ( Comput (D301 , D302 , ( LifeSpan (D300 , C241) )) ) ) by L1180 , L1169 , L1172 , L1174 , L360 , L1181
.= ( DataPart ( Comput (D301 , C241 , ( ( LifeSpan (D300 , C241) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D301 , C241) ) ) by L1184 , L1201 , EXTPRO_1:23;
L1203:
now
let C248 being set;
L1204: ( dom D305 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L1205: C248 in ( dom ( IExec (D297 , R14 , C241) ) );
per cases  by L1205 , SCMPDS_4:6;
suppose L1206: C248 is Int_position;

L1207: C248 <> ( IC ( SCMPDS ) ) by L1206 , SCMPDS_2:43;
L1208: (not C248 in ( dom D305 )) by L1207 , L1204 , TARSKI:def 1;
thus L1209: ( ( IExec (D297 , R14 , C241) ) . C248 ) = ( ( Result (D301 , C241) ) . C248 )
.= ( ( Result (D300 , C241) ) . C248 ) by L1202 , L1206 , SCMPDS_4:8
.= ( ( IExec (D296 , R14 , C241) ) . C248 )
.= ( ( ( IExec (D296 , R14 , C241) ) +* D305 ) . C248 ) by L1208 , FUNCT_4:11;
end;
suppose L1210: C248 = ( IC ( SCMPDS ) );

L1211: ( IC ( Result (D300 , C241) ) ) = ( IC ( IExec (D296 , R14 , C241) ) )
.= ( ( ( card C242 ) + ( card C243 ) ) + 1 ) by L1175 , L1176 , L398;
L1212: C248 in ( dom D305 ) by L1204 , L1210 , TARSKI:def 1;
thus L1213: ( ( IExec (D297 , R14 , C241) ) . C248 ) = ( ( Result (D301 , C241) ) . C248 )
.= ( ( Comput (D301 , C241 , ( ( LifeSpan (D300 , C241) ) + 1 )) ) . C248 ) by L1184 , L1201 , EXTPRO_1:23
.= ( IC ( Comput (D301 , D302 , ( LifeSpan (D300 , C241) )) ) ) by L1210 , EXTPRO_1:4
.= ( ( IC ( Comput (D300 , C241 , ( LifeSpan (D300 , C241) )) ) ) + 1 ) by L1180 , L1169 , L1172 , L1174 , L360 , L1181
.= ( ( IC ( Result (D300 , C241) ) ) + 1 ) by L1178 , EXTPRO_1:23
.= ( IC ( Start-At (( ( ( ( card C242 ) + ( card C243 ) ) + 1 ) + 1 ) , ( SCMPDS )) ) ) by L1211 , FUNCOP_1:72
.= ( ( ( IExec (D296 , R14 , C241) ) +* D305 ) . C248 ) by L1210 , L1212 , FUNCT_4:13;
end;
end;
L1215: ( dom ( IExec (D297 , R14 , C241) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D296 , R14 , C241) ) +* D305 ) ) by PARTFUN1:def 2;
thus L1216: ( IExec (D297 , R14 , C241) ) = ( ( IExec (D296 , R14 , C241) ) +* D305 ) by L1215 , L1203 , FUNCT_1:2
.= ( ( ( IExec (C242 , R14 , C241) ) +* ( Start-At (( ( ( card C242 ) + ( card C243 ) ) + 1 ) , ( SCMPDS )) ) ) +* ( Start-At (( ( ( card C242 ) + ( card C243 ) ) + 2 ) , ( SCMPDS )) ) ) by L1175 , L1176 , L404
.= ( ( IExec (C242 , R14 , C241) ) +* D305 ) by MEMSTR_0:36;
end;
theorem
L1217: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B194 being ( 0 ) -started (State of ( SCMPDS )) holds (for B195 being (Program of ( SCMPDS )) holds (for B196 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B197 being Int_position holds (for B198 being Integer holds ((( B194 . ( DataLoc (( B194 . B197 ) , B198) ) ) <= ( 0 ) & B196 is_closed_on B194 , R14 & B196 is_halting_on B194 , R14) implies ( IExec (( if>0 (B197 , B198 , B195 , B196) ) , R14 , B194) ) = ( ( IExec (B196 , R14 , B194) ) +* ( Start-At (( ( ( card B195 ) + ( card B196 ) ) + 2 ) , ( SCMPDS )) ) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C249 being ( 0 ) -started (State of ( SCMPDS ));
let C250 being (Program of ( SCMPDS ));
let C251 being  halt-free  shiftable (Program of ( SCMPDS ));
let C252 being Int_position;
let C253 being Integer;
L1218: ( Initialize C249 ) = C249 by MEMSTR_0:44;
set D307 = ( DataLoc (( C249 . C252 ) , C253) );
set D308 = ( stop C251 );
set D309 = C249;
set D310 = ( R14 +* D308 );
set D311 = ( if>0 (C252 , C253 , C250 , C251) );
set D312 = ( stop D311 );
set D313 = C249;
set D314 = ( R14 +* D312 );
set D315 = ( Comput (D314 , D313 , 1) );
set D316 = D314;
set D317 = ( (C252 , C253) <=0_goto ( ( card C250 ) + 2 ) );
set D318 = ( Goto ( ( card C251 ) + 1 ) );
set D319 = ( ( D317 ';' C250 ) ';' D318 );
set D320 = ( Start-At (( ( ( card C250 ) + ( card C251 ) ) + 2 ) , ( SCMPDS )) );
L1219: D311 = ( ( D317 ';' ( C250 ';' D318 ) ) ';' C251 ) by SCMPDS_4:14
.= ( D317 ';' ( ( C250 ';' D318 ) ';' C251 ) ) by SCMPDS_4:14;
L1220: ( Comput (D314 , D313 , ( ( 0 ) + 1 )) ) = ( Following (D314 , ( Comput (D314 , D313 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D314 , D313) ) by EXTPRO_1:2
.= ( Exec (D317 , D313) ) by L1219 , L8 , L1218;
L1221: ( IC D313 ) = ( 0 ) by L1218 , MEMSTR_0:47;
assume L1222: ( C249 . D307 ) <= ( 0 );
L1223: ( IC D315 ) = ( ICplusConst (D313 , ( ( card C250 ) + 2 )) ) by L1222 , L1220 , SCMPDS_2:56
.= ( ( 0 ) + ( ( card C250 ) + 2 ) ) by L1221 , L18;
L1224: (for R3 being Int_position holds ( D309 . R3 ) = ( D315 . R3 )) by L1220 , SCMPDS_2:56;
L1225: ( DataPart D309 ) = ( DataPart D315 ) by L1224 , SCMPDS_4:8;
L1226: ( card D319 ) = ( ( card ( D317 ';' C250 ) ) + ( card D318 ) ) by AFINSQ_1:17
.= ( ( card ( D317 ';' C250 ) ) + 1 ) by COMPOS_1:54
.= ( ( ( card C250 ) + 1 ) + 1 ) by L3
.= ( ( card C250 ) + ( 1 + 1 ) );
L1227: ( Shift (D308 , ( ( card C250 ) + 2 )) ) c= D312 by L1226 , L21;
L1228: D312 c= D314 by FUNCT_4:25;
L1229: ( Shift (D308 , ( ( card C250 ) + 2 )) ) c= D316 by L1228 , L1227 , XBOOLE_1:1;
assume L1230: C251 is_closed_on C249 , R14;
L1231: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D309 & C251 is_closed_on D309 , D310) by L1230 , L143 , L1218 , FUNCT_4:25;
L1232: ( stop C251 ) c= D310 by FUNCT_4:25;
assume L1233: C251 is_halting_on C249 , R14;
L1234: D310 halts_on D309 by L1233 , L41 , L1218;
L1235: ( Comput (D314 , D313 , ( ( LifeSpan (D310 , D309) ) + 1 )) ) = ( Comput (D314 , ( Comput (D314 , D313 , 1) ) , ( LifeSpan (D310 , D309) )) ) by EXTPRO_1:4;
L1236: ( CurInstr (D314 , ( Comput (D314 , D313 , ( ( LifeSpan (D310 , D309) ) + 1 )) )) ) = ( CurInstr (D314 , ( Comput (D314 , D315 , ( LifeSpan (D310 , D309) )) )) ) by L1235
.= ( CurInstr (D310 , ( Comput (D310 , D309 , ( LifeSpan (D310 , D309) )) )) ) by L1231 , L1229 , L1223 , L1225 , L360 , L1232
.= ( halt ( SCMPDS ) ) by L1234 , EXTPRO_1:def 15;
L1237: D314 halts_on D313 by L1236 , EXTPRO_1:29;
L1238: ( CurInstr (D314 , D313) ) = D317 by L1219 , L8 , L1218;
L1239:
now
let C254 being (Element of ( NAT ));
assume L1240: C254 < ( ( LifeSpan (D310 , D309) ) + 1 );
L1241: ( Comput (D314 , D313 , ( 0 )) ) = D313 by EXTPRO_1:2;
per cases ;
suppose L1242: C254 = ( 0 );

L1243: ( CurInstr (D314 , ( Comput (D314 , D313 , C254) )) ) = ( CurInstr (D314 , D313) ) by L1242 , L1241;
thus L1244: ( CurInstr (D314 , ( Comput (D314 , D313 , C254) )) ) <> ( halt ( SCMPDS ) ) by L1243 , L1238;
end;
suppose L1245: C254 <> ( 0 );

consider C255 being Nat such that L1246: C254 = ( C255 + 1 ) by L1245 , NAT_1:6;
reconsider D321 = C255 as (Element of ( NAT )) by ORDINAL1:def 12;
L1247: D321 < ( LifeSpan (D310 , D309) ) by L1240 , L1246 , XREAL_1:6;
assume L1248: ( CurInstr (D314 , ( Comput (D314 , D313 , C254) )) ) = ( halt ( SCMPDS ) );
L1249: ( Comput (D314 , D313 , ( D321 + 1 )) ) = ( Comput (D314 , ( Comput (D314 , D313 , 1) ) , D321) ) by EXTPRO_1:4;
L1250: ( CurInstr (D310 , ( Comput (D310 , D309 , D321) )) ) = ( CurInstr (D314 , ( Comput (D314 , D315 , D321) )) ) by L1231 , L1229 , L1223 , L1225 , L360 , L1232
.= ( halt ( SCMPDS ) ) by L1246 , L1248 , L1249;
thus L1251: contradiction by L1250 , L1234 , L1247 , EXTPRO_1:def 15;
end;
end;
L1253: (for B199 being (Element of ( NAT )) holds (( CurInstr (D314 , ( Comput (D314 , D313 , B199) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D310 , D309) ) + 1 ) <= B199)) by L1239;
L1254: ( LifeSpan (D314 , D313) ) = ( ( LifeSpan (D310 , D309) ) + 1 ) by L1253 , L1236 , L1237 , EXTPRO_1:def 15;
L1255: ( DataPart ( Result (D310 , D309) ) ) = ( DataPart ( Comput (D310 , D309 , ( LifeSpan (D310 , D309) )) ) ) by L1234 , EXTPRO_1:23
.= ( DataPart ( Comput (D314 , D315 , ( LifeSpan (D310 , D309) )) ) ) by L1231 , L1229 , L1223 , L1225 , L360 , L1232
.= ( DataPart ( Comput (D314 , D313 , ( ( LifeSpan (D310 , D309) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D314 , D313) ) ) by L1237 , L1254 , EXTPRO_1:23;
L1256:
now
let C256 being set;
L1257: ( dom D320 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L1258: C256 in ( dom ( IExec (D311 , R14 , C249) ) );
per cases  by L1258 , SCMPDS_4:6;
suppose L1259: C256 is Int_position;

L1260: C256 <> ( IC ( SCMPDS ) ) by L1259 , SCMPDS_2:43;
L1261: (not C256 in ( dom D320 )) by L1260 , L1257 , TARSKI:def 1;
thus L1262: ( ( IExec (D311 , R14 , C249) ) . C256 ) = ( ( Result (D314 , D313) ) . C256 )
.= ( ( Result (D310 , D309) ) . C256 ) by L1255 , L1259 , SCMPDS_4:8
.= ( ( IExec (C251 , R14 , C249) ) . C256 )
.= ( ( ( IExec (C251 , R14 , C249) ) +* D320 ) . C256 ) by L1261 , FUNCT_4:11;
end;
suppose L1263: C256 = ( IC ( SCMPDS ) );

L1264: ( IC ( Result (D310 , D309) ) ) = ( IC ( IExec (C251 , R14 , C249) ) )
.= ( card C251 ) by L1230 , L1233 , L416 , L1218;
L1265: C256 in ( dom D320 ) by L1257 , L1263 , TARSKI:def 1;
thus L1266: ( ( IExec (D311 , R14 , C249) ) . C256 ) = ( ( Result (D314 , D313) ) . C256 )
.= ( ( Comput (D314 , D313 , ( ( LifeSpan (D310 , D309) ) + 1 )) ) . C256 ) by L1237 , L1254 , EXTPRO_1:23
.= ( IC ( Comput (D314 , D315 , ( LifeSpan (D310 , D309) )) ) ) by L1263 , EXTPRO_1:4
.= ( ( IC ( Comput (D310 , D309 , ( LifeSpan (D310 , D309) )) ) ) + ( ( card C250 ) + 2 ) ) by L1231 , L1229 , L1223 , L1225 , L360 , L1232
.= ( ( IC ( Result (D310 , D309) ) ) + ( ( card C250 ) + 2 ) ) by L1234 , EXTPRO_1:23
.= ( IC ( Start-At (( ( card C251 ) + ( ( card C250 ) + 2 ) ) , ( SCMPDS )) ) ) by L1264 , FUNCOP_1:72
.= ( ( ( IExec (C251 , R14 , C249) ) +* D320 ) . C256 ) by L1263 , L1265 , FUNCT_4:13;
end;
end;
L1268: ( dom ( IExec (D311 , R14 , C249) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C251 , R14 , C249) ) +* D320 ) ) by PARTFUN1:def 2;
thus L1269: thesis by L1268 , L1256 , FUNCT_1:2;
end;
registration
let C257 , C258 being  shiftable  parahalting (Program of ( SCMPDS ));
let C259 being Int_position;
let C260 being Integer;
cluster ( if>0 (C259 , C260 , C257 , C258) ) ->  shiftable  parahalting;
correctness
proof
set D322 = ( (C259 , C260) <=0_goto ( ( card C257 ) + 2 ) );
set D323 = ( Goto ( ( card C258 ) + 1 ) );
set D324 = ( if>0 (C259 , C260 , C257 , C258) );
set D325 = ( stop D324 );
reconsider D326 = ( ( C257 ';' D323 ) ';' C258 ) as  shiftable (Program of ( SCMPDS ));
thus L1270: D324 is  shiftable;
let C261 being ( 0 ) -started (State of ( SCMPDS ));
let C262 being (Instruction-Sequence of ( SCMPDS ));
L1271: ( Initialize C261 ) = C261 by MEMSTR_0:44;
assume L1272: D325 c= C262;
L1273: C262 = ( C262 +* ( stop D324 ) ) by L1272 , FUNCT_4:98;
L1274: (C258 is_closed_on C261 , C262 & C258 is_halting_on C261 , C262) by L43 , L55;
L1275: (C257 is_closed_on C261 , C262 & C257 is_halting_on C261 , C262) by L43 , L55;
per cases ;
suppose L1276: ( C261 . ( DataLoc (( C261 . C259 ) , C260) ) ) > ( 0 );

L1277: D324 is_halting_on C261 , C262 by L1276 , L1275 , L1090;
thus L1278: C262 halts_on C261 by L1277 , L1271 , L1273 , L41;
end;
suppose L1279: ( C261 . ( DataLoc (( C261 . C259 ) , C260) ) ) <= ( 0 );

L1280: D324 is_halting_on C261 , C262 by L1279 , L1274 , L1126;
thus L1281: C262 halts_on C261 by L1280 , L1271 , L1273 , L41;
end;
end;
end;
registration
let C263 , C264 being  halt-free (Program of ( SCMPDS ));
let C265 being Int_position;
let C266 being Integer;
cluster ( if>0 (C265 , C266 , C263 , C264) ) ->  halt-free;
coherence;
end;
theorem
L1285: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B200 being ( 0 ) -started (State of ( SCMPDS )) holds (for B201 , B202 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B203 being Int_position holds (for B204 being Integer holds ( IC ( IExec (( if>0 (B203 , B204 , B201 , B202) ) , R14 , B200) ) ) = ( ( ( card B201 ) + ( card B202 ) ) + 2 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C267 being ( 0 ) -started (State of ( SCMPDS ));
let C268 , C269 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C270 being Int_position;
let C271 being Integer;
set D327 = ( if>0 (C270 , C271 , C268 , C269) );
L1286: (C268 is_closed_on C267 , R14 & C268 is_halting_on C267 , R14) by L43 , L55;
L1287: (C269 is_closed_on C267 , R14 & C269 is_halting_on C267 , R14) by L43 , L55;
per cases ;
suppose L1288: ( C267 . ( DataLoc (( C267 . C270 ) , C271) ) ) > ( 0 );

L1289: ( IExec (D327 , R14 , C267) ) = ( ( IExec (C268 , R14 , C267) ) +* ( Start-At (( ( ( card C268 ) + ( card C269 ) ) + 2 ) , ( SCMPDS )) ) ) by L1288 , L1286 , L1165;
thus L1290: thesis by L1289 , FUNCT_4:113;
end;
suppose L1291: ( C267 . ( DataLoc (( C267 . C270 ) , C271) ) ) <= ( 0 );

L1292: ( IExec (D327 , R14 , C267) ) = ( ( IExec (C269 , R14 , C267) ) +* ( Start-At (( ( ( card C268 ) + ( card C269 ) ) + 2 ) , ( SCMPDS )) ) ) by L1291 , L1287 , L1217;
thus L1293: thesis by L1292 , FUNCT_4:113;
end;
end;
theorem
L1295: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B205 being ( 0 ) -started (State of ( SCMPDS )) holds (for B206 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B207 being  shiftable (Program of ( SCMPDS )) holds (for B208 , B209 being Int_position holds (for B210 being Integer holds (( B205 . ( DataLoc (( B205 . B208 ) , B210) ) ) > ( 0 ) implies ( ( IExec (( if>0 (B208 , B210 , B206 , B207) ) , R14 , B205) ) . B209 ) = ( ( IExec (B206 , R14 , B205) ) . B209 ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C272 being ( 0 ) -started (State of ( SCMPDS ));
let C273 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C274 being  shiftable (Program of ( SCMPDS ));
let C275 , C276 being Int_position;
let C277 being Integer;
assume L1296: ( C272 . ( DataLoc (( C272 . C275 ) , C277) ) ) > ( 0 );
L1297: (not C276 in ( dom ( Start-At (( ( ( card C273 ) + ( card C274 ) ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1298: (C273 is_closed_on C272 , R14 & C273 is_halting_on C272 , R14) by L43 , L55;
L1299: ( IExec (( if>0 (C275 , C277 , C273 , C274) ) , R14 , C272) ) = ( ( IExec (C273 , R14 , C272) ) +* ( Start-At (( ( ( card C273 ) + ( card C274 ) ) + 2 ) , ( SCMPDS )) ) ) by L1298 , L1296 , L1165;
thus L1300: thesis by L1299 , L1297 , FUNCT_4:11;
end;
theorem
L1301: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B211 being ( 0 ) -started (State of ( SCMPDS )) holds (for B212 being (Program of ( SCMPDS )) holds (for B213 being  halt-free  parahalting  shiftable (Program of ( SCMPDS )) holds (for B214 , B215 being Int_position holds (for B216 being Integer holds (( B211 . ( DataLoc (( B211 . B214 ) , B216) ) ) <= ( 0 ) implies ( ( IExec (( if>0 (B214 , B216 , B212 , B213) ) , R14 , B211) ) . B215 ) = ( ( IExec (B213 , R14 , B211) ) . B215 ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C278 being ( 0 ) -started (State of ( SCMPDS ));
let C279 being (Program of ( SCMPDS ));
let C280 being  halt-free  parahalting  shiftable (Program of ( SCMPDS ));
let C281 , C282 being Int_position;
let C283 being Integer;
set D328 = ( if>0 (C281 , C283 , C279 , C280) );
assume L1302: ( C278 . ( DataLoc (( C278 . C281 ) , C283) ) ) <= ( 0 );
L1303: (not C282 in ( dom ( Start-At (( ( ( card C279 ) + ( card C280 ) ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1304: (C280 is_closed_on C278 , R14 & C280 is_halting_on C278 , R14) by L43 , L55;
L1305: ( IExec (D328 , R14 , C278) ) = ( ( IExec (C280 , R14 , C278) ) +* ( Start-At (( ( ( card C279 ) + ( card C280 ) ) + 2 ) , ( SCMPDS )) ) ) by L1304 , L1302 , L1217;
thus L1306: thesis by L1305 , L1303 , FUNCT_4:11;
end;
begin
theorem
L1307: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( card ( if>0 (R3 , R9 , R11) ) ) = ( ( card R11 ) + 1 )))) by L3;
theorem
L1308: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( 0 ) in ( dom ( if>0 (R3 , R9 , R11) ) ))))
proof
let R3 being Int_position;
let R9 being Integer;
let R11 being (Program of ( SCMPDS ));
set D329 = ( card ( if>0 (R3 , R9 , R11) ) );
L1309: D329 = ( ( card R11 ) + 1 ) by L3;
thus L1310: thesis by L1309 , AFINSQ_1:66;
end;
theorem
L1311: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( ( if>0 (R3 , R9 , R11) ) . ( 0 ) ) = ( (R3 , R9) <=0_goto ( ( card R11 ) + 1 ) )))) by L5;
theorem
L1312: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B217 being (State of ( SCMPDS )) holds (for B218 being  shiftable (Program of ( SCMPDS )) holds (for B219 being Int_position holds (for B220 being Integer holds ((( B217 . ( DataLoc (( B217 . B219 ) , B220) ) ) > ( 0 ) & B218 is_closed_on B217 , R14 & B218 is_halting_on B217 , R14) implies (( if>0 (B219 , B220 , B218) ) is_closed_on B217 , R14 & ( if>0 (B219 , B220 , B218) ) is_halting_on B217 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C284 being (State of ( SCMPDS ));
let C285 being  shiftable (Program of ( SCMPDS ));
let C286 being Int_position;
let C287 being Integer;
set D330 = ( DataLoc (( C284 . C286 ) , C287) );
set D331 = ( if>0 (C286 , C287 , C285) );
set D332 = ( stop D331 );
set D333 = ( stop C285 );
set D334 = ( Initialize C284 );
set D335 = ( Initialize C284 );
set D336 = ( R14 +* D333 );
set D337 = ( R14 +* D332 );
set D338 = ( Comput (D337 , D335 , 1) );
set D339 = D337;
set D340 = ( (C286 , C287) <=0_goto ( ( card C285 ) + 1 ) );
L1313: ( 0 ) in ( dom D332 ) by COMPOS_1:36;
L1314: ( IC D335 ) = ( 0 ) by MEMSTR_0:47;
L1315: (not D330 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1316: (not C286 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1317: ( D335 . ( DataLoc (( D335 . C286 ) , C287) ) ) = ( D335 . D330 ) by L1316 , FUNCT_4:11
.= ( C284 . D330 ) by L1315 , FUNCT_4:11;
L1318: ( Comput (D337 , D335 , ( ( 0 ) + 1 )) ) = ( Following (D337 , ( Comput (D337 , D335 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D337 , D335) ) by EXTPRO_1:2
.= ( Exec (D340 , D335) ) by L8;
L1319: (for R3 being Int_position holds ( D334 . R3 ) = ( D338 . R3 )) by L1318 , SCMPDS_2:56;
L1320: ( DataPart D334 ) = ( DataPart D338 ) by L1319 , SCMPDS_4:8;
assume L1321: ( C284 . D330 ) > ( 0 );
L1322: ( IC D338 ) = ( succ ( IC D335 ) ) by L1321 , L1318 , L1317 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L1314;
assume L1323: C285 is_closed_on C284 , R14;
L1324: C285 is_closed_on D334 , D336 by L1323 , L143;
assume L1325: C285 is_halting_on C284 , R14;
L1326: D336 halts_on D334 by L1325 , L41;
L1327: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D334 & ( Shift (D333 , 1) ) c= D339) by L436 , FUNCT_4:25;
L1328: ( stop C285 ) c= D336 by FUNCT_4:25;
L1329: ( card D332 ) = ( ( card D331 ) + 1 ) by COMPOS_1:55
.= ( ( ( card C285 ) + 1 ) + 1 ) by L3;
L1330:
now
let C288 being (Element of ( NAT ));
per cases ;
suppose L1331: ( 0 ) < C288;

consider C289 being Nat such that L1332: ( C289 + 1 ) = C288 by L1331 , NAT_1:6;
reconsider D341 = C289 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D342 = ( IC ( Comput (D336 , D334 , D341) ) ) as (Element of ( NAT ));
L1333: ( card D332 ) = ( ( card D333 ) + 1 ) by L1329 , COMPOS_1:55;
L1334: D342 in ( dom D333 ) by L1323 , L40;
L1335: D342 < ( card D333 ) by L1334 , AFINSQ_1:66;
L1336: ( D342 + 1 ) < ( card D332 ) by L1335 , L1333 , XREAL_1:6;
L1337: ( IC ( Comput (D337 , D335 , C288) ) ) = ( IC ( Comput (D337 , D338 , D341) ) ) by L1332 , EXTPRO_1:4
.= ( D342 + 1 ) by L1324 , L1327 , L1322 , L1320 , L360 , L1328;
thus L1338: ( IC ( Comput (D337 , D335 , C288) ) ) in ( dom D332 ) by L1337 , L1336 , AFINSQ_1:66;
end;
suppose L1339: C288 = ( 0 );

thus L1340: ( IC ( Comput (D337 , D335 , C288) ) ) in ( dom D332 ) by L1339 , L1313 , L1314 , EXTPRO_1:2;
end;
end;
thus L1342: D331 is_closed_on C284 , R14 by L1330 , L40;
L1343: ( Comput (D337 , D335 , ( ( LifeSpan (D336 , D334) ) + 1 )) ) = ( Comput (D337 , ( Comput (D337 , D335 , 1) ) , ( LifeSpan (D336 , D334) )) ) by EXTPRO_1:4;
L1344: ( CurInstr (D337 , ( Comput (D337 , D335 , ( ( LifeSpan (D336 , D334) ) + 1 )) )) ) = ( CurInstr (D337 , ( Comput (D337 , D338 , ( LifeSpan (D336 , D334) )) )) ) by L1343
.= ( CurInstr (D336 , ( Comput (D336 , D334 , ( LifeSpan (D336 , D334) )) )) ) by L1324 , L1327 , L1322 , L1320 , L360 , L1328
.= ( halt ( SCMPDS ) ) by L1326 , EXTPRO_1:def 15;
L1345: D337 halts_on D335 by L1344 , EXTPRO_1:29;
thus L1346: thesis by L1345 , L41;
end;
theorem
L1347: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B221 being (State of ( SCMPDS )) holds (for B222 being (Program of ( SCMPDS )) holds (for B223 being Int_position holds (for B224 being Integer holds (( B221 . ( DataLoc (( B221 . B223 ) , B224) ) ) <= ( 0 ) implies (( if>0 (B223 , B224 , B222) ) is_closed_on B221 , R14 & ( if>0 (B223 , B224 , B222) ) is_halting_on B221 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C290 being (State of ( SCMPDS ));
let C291 being (Program of ( SCMPDS ));
let C292 being Int_position;
let C293 being Integer;
set D343 = ( DataLoc (( C290 . C292 ) , C293) );
assume L1348: ( C290 . D343 ) <= ( 0 );
set D344 = ( (C292 , C293) <=0_goto ( ( card C291 ) + 1 ) );
set D345 = ( if>0 (C292 , C293 , C291) );
set D346 = ( stop D345 );
set D347 = ( Initialize C290 );
set D348 = ( R14 +* D346 );
set D349 = ( Comput (D348 , D347 , 1) );
set D350 = D348;
L1349: ( IC D347 ) = ( 0 ) by MEMSTR_0:47;
L1350: (not D343 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1351: (not C292 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1352: ( D347 . ( DataLoc (( D347 . C292 ) , C293) ) ) = ( D347 . D343 ) by L1351 , FUNCT_4:11
.= ( C290 . D343 ) by L1350 , FUNCT_4:11;
L1353: ( Comput (D348 , D347 , ( ( 0 ) + 1 )) ) = ( Following (D348 , ( Comput (D348 , D347 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D348 , D347) ) by EXTPRO_1:2
.= ( Exec (D344 , D347) ) by L8;
L1354: ( IC D349 ) = ( ICplusConst (D347 , ( ( card C291 ) + 1 )) ) by L1353 , L1348 , L1352 , SCMPDS_2:56
.= ( ( 0 ) + ( ( card C291 ) + 1 ) ) by L1349 , L18;
L1355: ( card D345 ) = ( ( card C291 ) + 1 ) by L3;
L1356: ( ( card C291 ) + 1 ) in ( dom D346 ) by L1355 , COMPOS_1:64;
L1357: ( D348 /. ( IC D349 ) ) = ( D348 . ( IC D349 ) ) by PBOOLE:143;
L1358: D346 c= D348 by FUNCT_4:25;
L1359: D346 c= D350 by L1358;
L1360: ( D350 . ( ( card C291 ) + 1 ) ) = ( D346 . ( ( card C291 ) + 1 ) ) by L1359 , L1356 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L1355 , COMPOS_1:64;
L1361: ( CurInstr (D348 , D349) ) = ( halt ( SCMPDS ) ) by L1360 , L1354 , L1357;
L1362:
now
let C294 being (Element of ( NAT ));
per cases ;
suppose L1363: ( 0 ) < C294;

L1364: ( 1 + ( 0 ) ) <= C294 by L1363 , INT_1:7;
thus L1365: ( IC ( Comput (D348 , D347 , C294) ) ) in ( dom D346 ) by L1364 , L1356 , L1354 , L1361 , EXTPRO_1:5;
end;
suppose L1366: C294 = ( 0 );

L1367: ( Comput (D348 , D347 , C294) ) = D347 by L1366 , EXTPRO_1:2;
thus L1368: ( IC ( Comput (D348 , D347 , C294) ) ) in ( dom D346 ) by L1367 , L1349 , COMPOS_1:36;
end;
end;
thus L1370: D345 is_closed_on C290 , R14 by L1362 , L40;
L1371: D348 halts_on D347 by L1361 , EXTPRO_1:29;
thus L1372: thesis by L1371 , L41;
end;
theorem
L1373: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B225 being (State of ( SCMPDS )) holds (for B226 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B227 being Int_position holds (for B228 being Integer holds ((( B225 . ( DataLoc (( B225 . B227 ) , B228) ) ) > ( 0 ) & B226 is_closed_on B225 , R14 & B226 is_halting_on B225 , R14) implies ( IExec (( if>0 (B227 , B228 , B226) ) , R14 , ( Initialize B225 )) ) = ( ( IExec (B226 , R14 , ( Initialize B225 )) ) +* ( Start-At (( ( card B226 ) + 1 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C295 being (State of ( SCMPDS ));
let C296 being  halt-free  shiftable (Program of ( SCMPDS ));
let C297 being Int_position;
let C298 being Integer;
set D351 = ( DataLoc (( C295 . C297 ) , C298) );
set D352 = ( if>0 (C297 , C298 , C296) );
set D353 = ( stop C296 );
set D354 = ( stop D352 );
set D355 = ( Initialize C295 );
set D356 = ( Initialize C295 );
set D357 = ( R14 +* D353 );
set D358 = ( R14 +* D354 );
set D359 = ( Comput (D358 , D356 , 1) );
set D360 = D358;
set D361 = ( (C297 , C298) <=0_goto ( ( card C296 ) + 1 ) );
set D362 = ( Start-At (( ( card C296 ) + 1 ) , ( SCMPDS )) );
L1374: ( IC D356 ) = ( 0 ) by MEMSTR_0:47;
L1375: (not D351 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1376: (not C297 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1377: ( D356 . ( DataLoc (( D356 . C297 ) , C298) ) ) = ( D356 . D351 ) by L1376 , FUNCT_4:11
.= ( C295 . D351 ) by L1375 , FUNCT_4:11;
L1378: ( Comput (D358 , D356 , ( ( 0 ) + 1 )) ) = ( Following (D358 , ( Comput (D358 , D356 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D358 , D356) ) by EXTPRO_1:2
.= ( Exec (D361 , D356) ) by L8;
assume L1379: ( C295 . D351 ) > ( 0 );
L1380: ( IC D359 ) = ( succ ( IC D356 ) ) by L1379 , L1378 , L1377 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L1374;
L1381: (for R3 being Int_position holds ( D355 . R3 ) = ( D359 . R3 )) by L1378 , SCMPDS_2:56;
L1382: ( DataPart D355 ) = ( DataPart D359 ) by L1381 , SCMPDS_4:8;
assume L1383: C296 is_closed_on C295 , R14;
L1384: C296 is_closed_on D355 , D357 by L1383 , L143;
L1385: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D355 & ( Shift (D353 , 1) ) c= D360) by L436 , FUNCT_4:25;
L1386: ( stop C296 ) c= D357 by FUNCT_4:25;
assume L1387: C296 is_halting_on C295 , R14;
L1388: D357 halts_on D355 by L1387 , L41;
L1389: ( Comput (D358 , D356 , ( ( LifeSpan (D357 , D355) ) + 1 )) ) = ( Comput (D358 , ( Comput (D358 , D356 , 1) ) , ( LifeSpan (D357 , D355) )) ) by EXTPRO_1:4;
L1390: ( CurInstr (D358 , ( Comput (D358 , D356 , ( ( LifeSpan (D357 , D355) ) + 1 )) )) ) = ( CurInstr (D358 , ( Comput (D358 , D359 , ( LifeSpan (D357 , D355) )) )) ) by L1389
.= ( CurInstr (D357 , ( Comput (D357 , D355 , ( LifeSpan (D357 , D355) )) )) ) by L1384 , L1385 , L1380 , L1382 , L360 , L1386
.= ( halt ( SCMPDS ) ) by L1388 , EXTPRO_1:def 15;
L1391: D358 halts_on D356 by L1390 , EXTPRO_1:29;
L1392: ( CurInstr (D358 , D356) ) = D361 by L8;
L1393:
now
let C299 being (Element of ( NAT ));
assume L1394: C299 < ( ( LifeSpan (D357 , D355) ) + 1 );
L1395: ( Comput (D358 , D356 , ( 0 )) ) = D356 by EXTPRO_1:2;
per cases ;
suppose L1396: C299 = ( 0 );

L1397: ( CurInstr (D358 , ( Comput (D358 , D356 , C299) )) ) = ( CurInstr (D358 , D356) ) by L1396 , L1395;
thus L1398: ( CurInstr (D358 , ( Comput (D358 , D356 , C299) )) ) <> ( halt ( SCMPDS ) ) by L1397 , L1392;
end;
suppose L1399: C299 <> ( 0 );

consider C300 being Nat such that L1400: C299 = ( C300 + 1 ) by L1399 , NAT_1:6;
reconsider D363 = C300 as (Element of ( NAT )) by ORDINAL1:def 12;
L1401: D363 < ( LifeSpan (D357 , D355) ) by L1394 , L1400 , XREAL_1:6;
assume L1402: ( CurInstr (D358 , ( Comput (D358 , D356 , C299) )) ) = ( halt ( SCMPDS ) );
L1403: ( Comput (D358 , D356 , ( D363 + 1 )) ) = ( Comput (D358 , ( Comput (D358 , D356 , 1) ) , D363) ) by EXTPRO_1:4;
L1404: ( CurInstr (D357 , ( Comput (D357 , D355 , D363) )) ) = ( CurInstr (D358 , ( Comput (D358 , D359 , D363) )) ) by L1384 , L1385 , L1380 , L1382 , L360 , L1386
.= ( halt ( SCMPDS ) ) by L1400 , L1402 , L1403;
thus L1405: contradiction by L1404 , L1388 , L1401 , EXTPRO_1:def 15;
end;
end;
L1407: (for B229 being (Element of ( NAT )) holds (( CurInstr (D358 , ( Comput (D358 , D356 , B229) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D357 , D355) ) + 1 ) <= B229)) by L1393;
L1408: ( LifeSpan (D358 , D356) ) = ( ( LifeSpan (D357 , D355) ) + 1 ) by L1407 , L1390 , L1391 , EXTPRO_1:def 15;
L1409: ( DataPart ( Result (D357 , D355) ) ) = ( DataPart ( Comput (D357 , D355 , ( LifeSpan (D357 , D355) )) ) ) by L1388 , EXTPRO_1:23
.= ( DataPart ( Comput (D358 , D359 , ( LifeSpan (D357 , D355) )) ) ) by L1384 , L1385 , L1380 , L1382 , L360 , L1386
.= ( DataPart ( Comput (D358 , D356 , ( ( LifeSpan (D357 , D355) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D358 , D356) ) ) by L1391 , L1408 , EXTPRO_1:23;
L1410:
now
let C301 being set;
L1411: ( dom D362 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L1412: C301 in ( dom ( IExec (D352 , R14 , ( Initialize C295 )) ) );
per cases  by L1412 , SCMPDS_4:6;
suppose L1413: C301 is Int_position;

L1414: C301 <> ( IC ( SCMPDS ) ) by L1413 , SCMPDS_2:43;
L1415: (not C301 in ( dom D362 )) by L1414 , L1411 , TARSKI:def 1;
thus L1416: ( ( IExec (D352 , R14 , ( Initialize C295 )) ) . C301 ) = ( ( Result (D358 , D356) ) . C301 )
.= ( ( Result (D357 , D355) ) . C301 ) by L1409 , L1413 , SCMPDS_4:8
.= ( ( IExec (C296 , R14 , ( Initialize C295 )) ) . C301 )
.= ( ( ( IExec (C296 , R14 , ( Initialize C295 )) ) +* D362 ) . C301 ) by L1415 , FUNCT_4:11;
end;
suppose L1417: C301 = ( IC ( SCMPDS ) );

L1418: ( IC ( Result (D357 , D355) ) ) = ( IC ( IExec (C296 , R14 , ( Initialize C295 )) ) )
.= ( card C296 ) by L1383 , L1387 , L416;
L1419: C301 in ( dom D362 ) by L1411 , L1417 , TARSKI:def 1;
thus L1420: ( ( IExec (D352 , R14 , ( Initialize C295 )) ) . C301 ) = ( ( Result (D358 , D356) ) . C301 )
.= ( ( Comput (D358 , D356 , ( ( LifeSpan (D357 , D355) ) + 1 )) ) . C301 ) by L1391 , L1408 , EXTPRO_1:23
.= ( IC ( Comput (D358 , D359 , ( LifeSpan (D357 , D355) )) ) ) by L1417 , EXTPRO_1:4
.= ( ( IC ( Comput (D357 , D355 , ( LifeSpan (D357 , D355) )) ) ) + 1 ) by L1384 , L1385 , L1380 , L1382 , L360 , L1386
.= ( ( IC ( Result (D357 , D355) ) ) + 1 ) by L1388 , EXTPRO_1:23
.= ( IC D362 ) by L1418 , FUNCOP_1:72
.= ( ( ( IExec (C296 , R14 , ( Initialize C295 )) ) +* D362 ) . C301 ) by L1417 , L1419 , FUNCT_4:13;
end;
end;
L1422: ( dom ( IExec (D352 , R14 , ( Initialize C295 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C296 , R14 , ( Initialize C295 )) ) +* D362 ) ) by PARTFUN1:def 2;
thus L1423: thesis by L1422 , L1410 , FUNCT_1:2;
end;
theorem
L1424: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B230 being (State of ( SCMPDS )) holds (for B231 being (Program of ( SCMPDS )) holds (for B232 being Int_position holds (for B233 being Integer holds (( B230 . ( DataLoc (( B230 . B232 ) , B233) ) ) <= ( 0 ) implies ( IExec (( if>0 (B232 , B233 , B231) ) , R14 , ( Initialize B230 )) ) = ( B230 +* ( Start-At (( ( card B231 ) + 1 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C302 being (State of ( SCMPDS ));
let C303 being (Program of ( SCMPDS ));
let C304 being Int_position;
let C305 being Integer;
set D364 = ( DataLoc (( C302 . C304 ) , C305) );
set D365 = ( if>0 (C304 , C305 , C303) );
set D366 = ( stop D365 );
set D367 = ( Initialize C302 );
set D368 = ( R14 +* D366 );
set D369 = ( Comput (D368 , D367 , 1) );
set D370 = D368;
set D371 = ( (C304 , C305) <=0_goto ( ( card C303 ) + 1 ) );
set D372 = ( Start-At (( ( card C303 ) + 1 ) , ( SCMPDS )) );
L1425: ( IC D367 ) = ( 0 ) by MEMSTR_0:47;
L1426: (not D364 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1427: (not C304 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1428: ( D367 . ( DataLoc (( D367 . C304 ) , C305) ) ) = ( D367 . D364 ) by L1427 , FUNCT_4:11
.= ( C302 . D364 ) by L1426 , FUNCT_4:11;
L1429: ( Comput (D368 , D367 , ( ( 0 ) + 1 )) ) = ( Following (D368 , ( Comput (D368 , D367 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D368 , D367) ) by EXTPRO_1:2
.= ( Exec (D371 , D367) ) by L8;
assume L1430: ( C302 . D364 ) <= ( 0 );
L1431: ( IC D369 ) = ( ICplusConst (D367 , ( ( card C303 ) + 1 )) ) by L1430 , L1429 , L1428 , SCMPDS_2:56
.= ( ( 0 ) + ( ( card C303 ) + 1 ) ) by L1425 , L18;
L1432: D366 c= D368 by FUNCT_4:25;
L1433: D366 c= D370 by L1432;
L1434: ( D368 /. ( IC D369 ) ) = ( D368 . ( IC D369 ) ) by PBOOLE:143;
L1435: ( card D365 ) = ( ( card C303 ) + 1 ) by L3;
L1436: ( ( card C303 ) + 1 ) in ( dom D366 ) by L1435 , COMPOS_1:64;
L1437: ( D370 . ( ( card C303 ) + 1 ) ) = ( D366 . ( ( card C303 ) + 1 ) ) by L1436 , L1433 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L1435 , COMPOS_1:64;
L1438: ( CurInstr (D368 , D369) ) = ( halt ( SCMPDS ) ) by L1437 , L1431 , L1434;
L1439: D368 halts_on D367 by L1438 , EXTPRO_1:29;
L1440: ( CurInstr (D368 , D367) ) = D371 by L8;
L1441:
now
let C306 being (Element of ( NAT ));
L1442: ( Comput (D368 , D367 , ( 0 )) ) = D367 by EXTPRO_1:2;
assume L1443: C306 < 1;
L1444: C306 < ( 1 + ( 0 ) ) by L1443;
L1445: C306 = ( 0 ) by L1444 , NAT_1:13;
L1446: ( CurInstr (D368 , ( Comput (D368 , D367 , C306) )) ) = ( CurInstr (D368 , D367) ) by L1445 , L1442;
thus L1447: ( CurInstr (D368 , ( Comput (D368 , D367 , C306) )) ) <> ( halt ( SCMPDS ) ) by L1446 , L1440;
end;
L1448: (for B234 being (Element of ( NAT )) holds (( CurInstr (D368 , ( Comput (D368 , D367 , B234) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B234)) by L1441;
L1449: ( LifeSpan (D368 , D367) ) = 1 by L1448 , L1438 , L1439 , EXTPRO_1:def 15;
L1450: D369 = ( Result (D368 , D367) ) by L1449 , L1439 , EXTPRO_1:23;
L1451:
now
L1452: ( dom D372 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
let C307 being set;
assume L1453: C307 in ( dom ( IExec (D365 , R14 , ( Initialize C302 )) ) );
per cases  by L1453 , SCMPDS_4:6;
suppose L1454: C307 is Int_position;

L1455: C307 <> ( IC ( SCMPDS ) ) by L1454 , SCMPDS_2:43;
L1456: (not C307 in ( dom D372 )) by L1455 , L1452 , TARSKI:def 1;
L1457: (not C307 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L1454 , SCMPDS_4:18;
thus L1458: ( ( IExec (D365 , R14 , ( Initialize C302 )) ) . C307 ) = ( D369 . C307 ) by L1450
.= ( D367 . C307 ) by L1429 , L1454 , SCMPDS_2:56
.= ( C302 . C307 ) by L1457 , FUNCT_4:11
.= ( ( C302 +* D372 ) . C307 ) by L1456 , FUNCT_4:11;
end;
suppose L1459: C307 = ( IC ( SCMPDS ) );

thus L1460: ( ( IExec (D365 , R14 , ( Initialize C302 )) ) . C307 ) = ( ( card C303 ) + 1 ) by L1459 , L1431 , L1450
.= ( ( C302 +* D372 ) . C307 ) by L1459 , FUNCT_4:113;
end;
end;
L1462: ( dom ( IExec (D365 , R14 , ( Initialize C302 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C302 +* D372 ) ) by PARTFUN1:def 2;
thus L1463: thesis by L1462 , L1451 , FUNCT_1:2;
end;
registration
let C308 being  shiftable  parahalting (Program of ( SCMPDS ));
let C309 being Int_position;
let C310 being Integer;
cluster ( if>0 (C309 , C310 , C308) ) ->  shiftable  parahalting;
correctness
proof
set D373 = ( (C309 , C310) <=0_goto ( ( card C308 ) + 1 ) );
set D374 = ( if>0 (C309 , C310 , C308) );
set D375 = ( stop D374 );
thus L1464: D374 is  shiftable;
let C311 being ( 0 ) -started (State of ( SCMPDS ));
let C312 being (Instruction-Sequence of ( SCMPDS ));
L1465: ( Initialize C311 ) = C311 by MEMSTR_0:44;
assume L1466: D375 c= C312;
L1467: C312 = ( C312 +* ( stop D374 ) ) by L1466 , FUNCT_4:98;
L1468: (C308 is_closed_on C311 , C312 & C308 is_halting_on C311 , C312) by L43 , L55;
per cases ;
suppose L1469: ( C311 . ( DataLoc (( C311 . C309 ) , C310) ) ) > ( 0 );

L1470: D374 is_halting_on C311 , C312 by L1469 , L1468 , L1312;
thus L1471: C312 halts_on C311 by L1470 , L1467 , L41 , L1465;
end;
suppose L1472: ( C311 . ( DataLoc (( C311 . C309 ) , C310) ) ) <= ( 0 );

L1473: D374 is_halting_on C311 , C312 by L1472 , L1347;
thus L1474: C312 halts_on C311 by L1473 , L1467 , L41 , L1465;
end;
end;
end;
registration
let C313 being  halt-free (Program of ( SCMPDS ));
let C314 being Int_position;
let C315 being Integer;
cluster ( if>0 (C314 , C315 , C313) ) ->  halt-free;
coherence;
end;
theorem
L1478: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B235 being ( 0 ) -started (State of ( SCMPDS )) holds (for B236 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B237 being Int_position holds (for B238 being Integer holds ( IC ( IExec (( if>0 (B237 , B238 , B236) ) , R14 , B235) ) ) = ( ( card B236 ) + 1 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C316 being ( 0 ) -started (State of ( SCMPDS ));
let C317 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C318 being Int_position;
let C319 being Integer;
set D376 = ( if>0 (C318 , C319 , C317) );
L1479: (C317 is_closed_on C316 , R14 & C317 is_halting_on C316 , R14) by L43 , L55;
L1480: ( Initialize C316 ) = C316 by MEMSTR_0:44;
per cases ;
suppose L1481: ( C316 . ( DataLoc (( C316 . C318 ) , C319) ) ) > ( 0 );

L1482: ( IExec (D376 , R14 , C316) ) = ( ( IExec (C317 , R14 , C316) ) +* ( Start-At (( ( card C317 ) + 1 ) , ( SCMPDS )) ) ) by L1481 , L1479 , L1373 , L1480;
thus L1483: thesis by L1482 , FUNCT_4:113;
end;
suppose L1484: ( C316 . ( DataLoc (( C316 . C318 ) , C319) ) ) <= ( 0 );

L1485: ( IExec (D376 , R14 , C316) ) = ( C316 +* ( Start-At (( ( card C317 ) + 1 ) , ( SCMPDS )) ) ) by L1484 , L1424 , L1480;
thus L1486: thesis by L1485 , FUNCT_4:113;
end;
end;
theorem
L1488: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B239 being (State of ( SCMPDS )) holds (for B240 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B241 , B242 being Int_position holds (for B243 being Integer holds (( B239 . ( DataLoc (( B239 . B241 ) , B243) ) ) > ( 0 ) implies ( ( IExec (( if>0 (B241 , B243 , B240) ) , R14 , ( Initialize B239 )) ) . B242 ) = ( ( IExec (B240 , R14 , ( Initialize B239 )) ) . B242 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C320 being (State of ( SCMPDS ));
let C321 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C322 , C323 being Int_position;
let C324 being Integer;
assume L1489: ( C320 . ( DataLoc (( C320 . C322 ) , C324) ) ) > ( 0 );
L1490: (not C323 in ( dom ( Start-At (( ( card C321 ) + 1 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1491: (C321 is_closed_on C320 , R14 & C321 is_halting_on C320 , R14) by L43 , L55;
L1492: ( IExec (( if>0 (C322 , C324 , C321) ) , R14 , ( Initialize C320 )) ) = ( ( IExec (C321 , R14 , ( Initialize C320 )) ) +* ( Start-At (( ( card C321 ) + 1 ) , ( SCMPDS )) ) ) by L1491 , L1489 , L1373;
thus L1493: thesis by L1492 , L1490 , FUNCT_4:11;
end;
theorem
L1494: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B244 being (State of ( SCMPDS )) holds (for B245 being (Program of ( SCMPDS )) holds (for B246 , B247 being Int_position holds (for B248 being Integer holds (( B244 . ( DataLoc (( B244 . B246 ) , B248) ) ) <= ( 0 ) implies ( ( IExec (( if>0 (B246 , B248 , B245) ) , R14 , ( Initialize B244 )) ) . B247 ) = ( B244 . B247 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C325 being (State of ( SCMPDS ));
let C326 being (Program of ( SCMPDS ));
let C327 , C328 being Int_position;
let C329 being Integer;
assume L1495: ( C325 . ( DataLoc (( C325 . C327 ) , C329) ) ) <= ( 0 );
L1496: ( IExec (( if>0 (C327 , C329 , C326) ) , R14 , ( Initialize C325 )) ) = ( C325 +* ( Start-At (( ( card C326 ) + 1 ) , ( SCMPDS )) ) ) by L1495 , L1424;
L1497: (not C328 in ( dom ( Start-At (( ( card C326 ) + 1 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L1498: thesis by L1497 , L1496 , FUNCT_4:11;
end;
begin
theorem
L1499: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( card ( if<=0 (R3 , R9 , R11) ) ) = ( ( card R11 ) + 2 )))) by L856;
theorem
L1500: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( if<=0 (R3 , R9 , R11) ) ) & 1 in ( dom ( if<=0 (R3 , R9 , R11) ) ))))) by L859;
theorem
L1501: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (( ( if<=0 (R3 , R9 , R11) ) . ( 0 ) ) = ( (R3 , R9) <=0_goto 2 ) & ( ( if<=0 (R3 , R9 , R11) ) . 1 ) = ( goto ( ( card R11 ) + 1 ) ))))) by L865;
theorem
L1502: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B249 being (State of ( SCMPDS )) holds (for B250 being  shiftable (Program of ( SCMPDS )) holds (for B251 being Int_position holds (for B252 being Integer holds ((( B249 . ( DataLoc (( B249 . B251 ) , B252) ) ) <= ( 0 ) & B250 is_closed_on B249 , R14 & B250 is_halting_on B249 , R14) implies (( if<=0 (B251 , B252 , B250) ) is_closed_on B249 , R14 & ( if<=0 (B251 , B252 , B250) ) is_halting_on B249 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C330 being (State of ( SCMPDS ));
let C331 being  shiftable (Program of ( SCMPDS ));
let C332 being Int_position;
let C333 being Integer;
set D377 = ( DataLoc (( C330 . C332 ) , C333) );
set D378 = ( if<=0 (C332 , C333 , C331) );
set D379 = ( stop D378 );
set D380 = ( stop C331 );
set D381 = ( Initialize C330 );
set D382 = ( Initialize C330 );
set D383 = ( R14 +* D380 );
set D384 = ( R14 +* D379 );
set D385 = ( Comput (D384 , D382 , 1) );
set D386 = D384;
set D387 = ( (C332 , C333) <=0_goto 2 );
set D388 = ( goto ( ( card C331 ) + 1 ) );
L1503: ( stop C331 ) c= D383 by FUNCT_4:25;
L1504: D378 = ( D387 ';' ( D388 ';' C331 ) ) by SCMPDS_4:16;
L1505: ( Comput (D384 , D382 , ( ( 0 ) + 1 )) ) = ( Following (D384 , ( Comput (D384 , D382 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D384 , D382) ) by EXTPRO_1:2
.= ( Exec (D387 , D382) ) by L1504 , L8;
L1506: (for R3 being Int_position holds ( D381 . R3 ) = ( D385 . R3 )) by L1505 , SCMPDS_2:56;
L1507: ( DataPart D381 ) = ( DataPart D385 ) by L1506 , SCMPDS_4:8;
L1508: (not D377 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1509: (not C332 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1510: ( D382 . ( DataLoc (( D382 . C332 ) , C333) ) ) = ( D382 . D377 ) by L1509 , FUNCT_4:11
.= ( C330 . D377 ) by L1508 , FUNCT_4:11;
L1511: ( IC D382 ) = ( 0 ) by MEMSTR_0:47;
assume L1512: ( C330 . D377 ) <= ( 0 );
L1513: ( IC D385 ) = ( ICplusConst (D382 , 2) ) by L1512 , L1505 , L1510 , SCMPDS_2:56
.= ( ( 0 ) + 2 ) by L1511 , L18;
assume L1514: C331 is_closed_on C330 , R14;
L1515: C331 is_closed_on D381 , D383 by L1514 , L143;
assume L1516: C331 is_halting_on C330 , R14;
L1517: D383 halts_on D381 by L1516 , L41;
L1518: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D381 & ( Shift (D380 , 2) ) c= D386) by L442 , FUNCT_4:25;
L1519: ( 0 ) in ( dom D379 ) by COMPOS_1:36;
L1520:
now
let C334 being (Element of ( NAT ));
per cases ;
suppose L1521: ( 0 ) < C334;

consider C335 being Nat such that L1522: ( C335 + 1 ) = C334 by L1521 , NAT_1:6;
reconsider D389 = C335 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D390 = ( IC ( Comput (D383 , D381 , D389) ) ) as (Element of ( NAT ));
L1523: ( card D379 ) = ( 1 + ( card D378 ) ) by COMPOS_1:55
.= ( 1 + ( ( card C331 ) + 2 ) ) by L856
.= ( ( 1 + ( card C331 ) ) + 2 )
.= ( ( card D380 ) + 2 ) by COMPOS_1:55;
L1524: D390 in ( dom D380 ) by L1514 , L40;
L1525: D390 < ( card D380 ) by L1524 , AFINSQ_1:66;
L1526: ( D390 + 2 ) < ( card D379 ) by L1525 , L1523 , XREAL_1:6;
L1527: ( IC ( Comput (D384 , D382 , C334) ) ) = ( IC ( Comput (D384 , D385 , D389) ) ) by L1522 , EXTPRO_1:4
.= ( D390 + 2 ) by L1515 , L1518 , L1513 , L1507 , L360 , L1503;
thus L1528: ( IC ( Comput (D384 , D382 , C334) ) ) in ( dom D379 ) by L1527 , L1526 , AFINSQ_1:66;
end;
suppose L1529: C334 = ( 0 );

thus L1530: ( IC ( Comput (D384 , D382 , C334) ) ) in ( dom D379 ) by L1529 , L1519 , L1511 , EXTPRO_1:2;
end;
end;
thus L1532: D378 is_closed_on C330 , R14 by L1520 , L40;
L1533: ( Comput (D384 , D382 , ( ( LifeSpan (D383 , D381) ) + 1 )) ) = ( Comput (D384 , ( Comput (D384 , D382 , 1) ) , ( LifeSpan (D383 , D381) )) ) by EXTPRO_1:4;
L1534: ( CurInstr (D384 , ( Comput (D384 , D382 , ( ( LifeSpan (D383 , D381) ) + 1 )) )) ) = ( CurInstr (D384 , ( Comput (D384 , D385 , ( LifeSpan (D383 , D381) )) )) ) by L1533
.= ( CurInstr (D383 , ( Comput (D383 , D381 , ( LifeSpan (D383 , D381) )) )) ) by L1515 , L1518 , L1513 , L1507 , L360 , L1503
.= ( halt ( SCMPDS ) ) by L1517 , EXTPRO_1:def 15;
L1535: D384 halts_on D382 by L1534 , EXTPRO_1:29;
thus L1536: thesis by L1535 , L41;
end;
theorem
L1537: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B253 being (State of ( SCMPDS )) holds (for B254 being (Program of ( SCMPDS )) holds (for B255 being Int_position holds (for B256 being Integer holds (( B253 . ( DataLoc (( B253 . B255 ) , B256) ) ) > ( 0 ) implies (( if<=0 (B255 , B256 , B254) ) is_closed_on B253 , R14 & ( if<=0 (B255 , B256 , B254) ) is_halting_on B253 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C336 being (State of ( SCMPDS ));
let C337 being (Program of ( SCMPDS ));
let C338 being Int_position;
let C339 being Integer;
set D391 = ( DataLoc (( C336 . C338 ) , C339) );
assume L1538: ( C336 . D391 ) > ( 0 );
set D392 = ( (C338 , C339) <=0_goto 2 );
set D393 = ( goto ( ( card C337 ) + 1 ) );
set D394 = ( if<=0 (C338 , C339 , C337) );
set D395 = ( stop D394 );
set D396 = ( Initialize C336 );
set D397 = ( R14 +* D395 );
set D398 = ( Comput (D397 , D396 , 1) );
set D399 = ( Comput (D397 , D396 , 2) );
set D400 = D397;
set D401 = D397;
L1539: D394 = ( D392 ';' ( D393 ';' C337 ) ) by SCMPDS_4:16;
L1540: (not D391 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1541: (not C338 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1542: ( D396 . ( DataLoc (( D396 . C338 ) , C339) ) ) = ( D396 . D391 ) by L1541 , FUNCT_4:11
.= ( C336 . D391 ) by L1540 , FUNCT_4:11;
L1543: ( IC D396 ) = ( 0 ) by MEMSTR_0:47;
L1544: ( Comput (D397 , D396 , ( ( 0 ) + 1 )) ) = ( Following (D397 , ( Comput (D397 , D396 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D397 , D396) ) by EXTPRO_1:2
.= ( Exec (D392 , D396) ) by L1539 , L8;
L1545: ( IC D398 ) = ( succ ( IC D396 ) ) by L1544 , L1538 , L1542 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L1543;
L1546: D395 c= D397 by FUNCT_4:25;
L1547: D395 c= D400 by L1546;
L1548: 1 in ( dom D394 ) by L859;
L1549: 1 in ( dom D395 ) by L1548 , COMPOS_1:62;
L1550: ( D400 . 1 ) = ( D395 . 1 ) by L1549 , L1547 , GRFUNC_1:2
.= ( D394 . 1 ) by L1548 , COMPOS_1:63
.= D393 by L865;
L1551: ( card D394 ) = ( ( card C337 ) + 2 ) by L856;
L1552: ( ( card C337 ) + 2 ) in ( dom D395 ) by L1551 , COMPOS_1:64;
L1553: ( D397 /. ( IC D398 ) ) = ( D397 . ( IC D398 ) ) by PBOOLE:143;
L1554: ( Comput (D397 , D396 , ( 1 + 1 )) ) = ( Following (D397 , D398) ) by EXTPRO_1:3
.= ( Exec (D393 , D398) ) by L1545 , L1550 , L1553;
L1555: ( IC D399 ) = ( ICplusConst (D398 , ( ( card C337 ) + 1 )) ) by L1554 , SCMPDS_2:54
.= ( ( ( card C337 ) + 1 ) + 1 ) by L1545 , L18
.= ( ( card C337 ) + ( 1 + 1 ) );
L1556: ( D397 /. ( IC D399 ) ) = ( D397 . ( IC D399 ) ) by PBOOLE:143;
L1557: D395 c= D401 by L1546;
L1558: ( D401 . ( ( card C337 ) + 2 ) ) = ( D395 . ( ( card C337 ) + 2 ) ) by L1557 , L1552 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L1551 , COMPOS_1:64;
L1559: ( CurInstr (D397 , D399) ) = ( halt ( SCMPDS ) ) by L1558 , L1555 , L1556;
L1560:
now
let C340 being (Element of ( NAT ));
L1561: (C340 = ( 0 ) or ( ( 0 ) + 1 ) <= C340) by INT_1:7;
per cases  by L1561 , XXREAL_0:1;
suppose L1562: C340 = ( 0 );

L1563: ( Comput (D397 , D396 , C340) ) = D396 by L1562 , EXTPRO_1:2;
thus L1564: ( IC ( Comput (D397 , D396 , C340) ) ) in ( dom D395 ) by L1563 , L1543 , COMPOS_1:36;
end;
suppose L1565: C340 = 1;

thus L1566: ( IC ( Comput (D397 , D396 , C340) ) ) in ( dom D395 ) by L1565 , L1548 , L1545 , COMPOS_1:62;
end;
suppose L1567: 1 < C340;

L1568: ( 1 + 1 ) <= C340 by L1567 , INT_1:7;
thus L1569: ( IC ( Comput (D397 , D396 , C340) ) ) in ( dom D395 ) by L1568 , L1552 , L1555 , L1559 , EXTPRO_1:5;
end;
end;
thus L1571: D394 is_closed_on C336 , R14 by L1560 , L40;
L1572: D397 halts_on D396 by L1559 , EXTPRO_1:29;
thus L1573: thesis by L1572 , L41;
end;
theorem
L1574: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B257 being (State of ( SCMPDS )) holds (for B258 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B259 being Int_position holds (for B260 being Integer holds ((( B257 . ( DataLoc (( B257 . B259 ) , B260) ) ) <= ( 0 ) & B258 is_closed_on B257 , R14 & B258 is_halting_on B257 , R14) implies ( IExec (( if<=0 (B259 , B260 , B258) ) , R14 , ( Initialize B257 )) ) = ( ( IExec (B258 , R14 , ( Initialize B257 )) ) +* ( Start-At (( ( card B258 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C341 being (State of ( SCMPDS ));
let C342 being  halt-free  shiftable (Program of ( SCMPDS ));
let C343 being Int_position;
let C344 being Integer;
set D402 = ( DataLoc (( C341 . C343 ) , C344) );
set D403 = ( if<=0 (C343 , C344 , C342) );
set D404 = ( stop D403 );
set D405 = ( stop C342 );
set D406 = ( Initialize C341 );
set D407 = ( Initialize C341 );
set D408 = ( R14 +* D405 );
set D409 = ( R14 +* D404 );
set D410 = ( Comput (D409 , D407 , 1) );
set D411 = D409;
set D412 = ( (C343 , C344) <=0_goto 2 );
set D413 = ( goto ( ( card C342 ) + 1 ) );
set D414 = ( Start-At (( ( card C342 ) + 2 ) , ( SCMPDS )) );
L1575: ( stop C342 ) c= D408 by FUNCT_4:25;
L1576: D403 = ( D412 ';' ( D413 ';' C342 ) ) by SCMPDS_4:16;
L1577: ( Comput (D409 , D407 , ( ( 0 ) + 1 )) ) = ( Following (D409 , ( Comput (D409 , D407 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D409 , D407) ) by EXTPRO_1:2
.= ( Exec (D412 , D407) ) by L1576 , L8;
L1578: (not D402 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1579: (not C343 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1580: ( D407 . ( DataLoc (( D407 . C343 ) , C344) ) ) = ( D407 . D402 ) by L1579 , FUNCT_4:11
.= ( C341 . D402 ) by L1578 , FUNCT_4:11;
L1581: ( IC D407 ) = ( 0 ) by MEMSTR_0:47;
L1582: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D406 & ( Shift (D405 , 2) ) c= D411) by L442 , FUNCT_4:25;
L1583: (for R3 being Int_position holds ( D406 . R3 ) = ( D410 . R3 )) by L1577 , SCMPDS_2:56;
L1584: ( DataPart D406 ) = ( DataPart D410 ) by L1583 , SCMPDS_4:8;
assume L1585: ( C341 . D402 ) <= ( 0 );
L1586: ( IC D410 ) = ( ICplusConst (D407 , 2) ) by L1585 , L1577 , L1580 , SCMPDS_2:56
.= ( ( 0 ) + 2 ) by L1581 , L18;
assume L1587: C342 is_closed_on C341 , R14;
L1588: C342 is_closed_on D406 , D408 by L1587 , L143;
assume L1589: C342 is_halting_on C341 , R14;
L1590: D408 halts_on D406 by L1589 , L41;
L1591: ( Comput (D409 , D407 , ( ( LifeSpan (D408 , D406) ) + 1 )) ) = ( Comput (D409 , ( Comput (D409 , D407 , 1) ) , ( LifeSpan (D408 , D406) )) ) by EXTPRO_1:4;
L1592: ( CurInstr (D409 , ( Comput (D409 , D407 , ( ( LifeSpan (D408 , D406) ) + 1 )) )) ) = ( CurInstr (D409 , ( Comput (D409 , D410 , ( LifeSpan (D408 , D406) )) )) ) by L1591
.= ( CurInstr (D408 , ( Comput (D408 , D406 , ( LifeSpan (D408 , D406) )) )) ) by L1588 , L1582 , L1586 , L1584 , L360 , L1575
.= ( halt ( SCMPDS ) ) by L1590 , EXTPRO_1:def 15;
L1593: D409 halts_on D407 by L1592 , EXTPRO_1:29;
L1594: ( CurInstr (D409 , D407) ) = D412 by L1576 , L8;
L1595:
now
let C345 being (Element of ( NAT ));
assume L1596: C345 < ( ( LifeSpan (D408 , D406) ) + 1 );
L1597: ( Comput (D409 , D407 , ( 0 )) ) = D407 by EXTPRO_1:2;
per cases ;
suppose L1598: C345 = ( 0 );

L1599: ( CurInstr (D409 , ( Comput (D409 , D407 , C345) )) ) = ( CurInstr (D409 , D407) ) by L1598 , L1597;
thus L1600: ( CurInstr (D409 , ( Comput (D409 , D407 , C345) )) ) <> ( halt ( SCMPDS ) ) by L1599 , L1594;
end;
suppose L1601: C345 <> ( 0 );

consider C346 being Nat such that L1602: C345 = ( C346 + 1 ) by L1601 , NAT_1:6;
reconsider D415 = C346 as (Element of ( NAT )) by ORDINAL1:def 12;
L1603: D415 < ( LifeSpan (D408 , D406) ) by L1596 , L1602 , XREAL_1:6;
assume L1604: ( CurInstr (D409 , ( Comput (D409 , D407 , C345) )) ) = ( halt ( SCMPDS ) );
L1605: ( Comput (D409 , D407 , ( D415 + 1 )) ) = ( Comput (D409 , ( Comput (D409 , D407 , 1) ) , D415) ) by EXTPRO_1:4;
L1606: ( CurInstr (D408 , ( Comput (D408 , D406 , D415) )) ) = ( CurInstr (D409 , ( Comput (D409 , D410 , D415) )) ) by L1588 , L1582 , L1586 , L1584 , L360 , L1575
.= ( halt ( SCMPDS ) ) by L1602 , L1604 , L1605;
thus L1607: contradiction by L1606 , L1590 , L1603 , EXTPRO_1:def 15;
end;
end;
L1609: (for B261 being (Element of ( NAT )) holds (( CurInstr (D409 , ( Comput (D409 , D407 , B261) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D408 , D406) ) + 1 ) <= B261)) by L1595;
L1610: ( LifeSpan (D409 , D407) ) = ( ( LifeSpan (D408 , D406) ) + 1 ) by L1609 , L1592 , L1593 , EXTPRO_1:def 15;
L1611: ( DataPart ( Result (D408 , D406) ) ) = ( DataPart ( Comput (D408 , D406 , ( LifeSpan (D408 , D406) )) ) ) by L1590 , EXTPRO_1:23
.= ( DataPart ( Comput (D409 , D410 , ( LifeSpan (D408 , D406) )) ) ) by L1588 , L1582 , L1586 , L1584 , L360 , L1575
.= ( DataPart ( Comput (D409 , D407 , ( ( LifeSpan (D408 , D406) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D409 , D407) ) ) by L1593 , L1610 , EXTPRO_1:23;
L1612:
now
let C347 being set;
L1613: ( dom ( Start-At (( ( card C342 ) + 2 ) , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L1614: C347 in ( dom ( IExec (D403 , R14 , ( Initialize C341 )) ) );
per cases  by L1614 , SCMPDS_4:6;
suppose L1615: C347 is Int_position;

L1616: C347 <> ( IC ( SCMPDS ) ) by L1615 , SCMPDS_2:43;
L1617: (not C347 in ( dom D414 )) by L1616 , L1613 , TARSKI:def 1;
thus L1618: ( ( IExec (D403 , R14 , ( Initialize C341 )) ) . C347 ) = ( ( Result (D409 , D407) ) . C347 )
.= ( ( Result (D408 , D406) ) . C347 ) by L1611 , L1615 , SCMPDS_4:8
.= ( ( IExec (C342 , R14 , ( Initialize C341 )) ) . C347 )
.= ( ( ( IExec (C342 , R14 , ( Initialize C341 )) ) +* D414 ) . C347 ) by L1617 , FUNCT_4:11;
end;
suppose L1619: C347 = ( IC ( SCMPDS ) );

L1620: ( IC ( Result (D408 , D406) ) ) = ( IC ( IExec (C342 , R14 , ( Initialize C341 )) ) )
.= ( card C342 ) by L1587 , L1589 , L416;
L1621: C347 in ( dom D414 ) by L1613 , L1619 , TARSKI:def 1;
thus L1622: ( ( IExec (D403 , R14 , ( Initialize C341 )) ) . C347 ) = ( ( Result (D409 , D407) ) . C347 )
.= ( ( Comput (D409 , D407 , ( ( LifeSpan (D408 , D406) ) + 1 )) ) . C347 ) by L1593 , L1610 , EXTPRO_1:23
.= ( IC ( Comput (D409 , D410 , ( LifeSpan (D408 , D406) )) ) ) by L1619 , EXTPRO_1:4
.= ( ( IC ( Comput (D408 , D406 , ( LifeSpan (D408 , D406) )) ) ) + 2 ) by L1588 , L1582 , L1586 , L1584 , L360 , L1575
.= ( ( IC ( Result (D408 , D406) ) ) + 2 ) by L1590 , EXTPRO_1:23
.= ( IC D414 ) by L1620 , FUNCOP_1:72
.= ( ( ( IExec (C342 , R14 , ( Initialize C341 )) ) +* D414 ) . C347 ) by L1619 , L1621 , FUNCT_4:13;
end;
end;
L1624: ( dom ( IExec (D403 , R14 , ( Initialize C341 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C342 , R14 , ( Initialize C341 )) ) +* ( Start-At (( ( card C342 ) + 2 ) , ( SCMPDS )) ) ) ) by PARTFUN1:def 2;
thus L1625: thesis by L1624 , L1612 , FUNCT_1:2;
end;
theorem
L1626: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B262 being (State of ( SCMPDS )) holds (for B263 being (Program of ( SCMPDS )) holds (for B264 being Int_position holds (for B265 being Integer holds (( B262 . ( DataLoc (( B262 . B264 ) , B265) ) ) > ( 0 ) implies ( IExec (( if<=0 (B264 , B265 , B263) ) , R14 , ( Initialize B262 )) ) = ( B262 +* ( Start-At (( ( card B263 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C348 being (State of ( SCMPDS ));
let C349 being (Program of ( SCMPDS ));
let C350 being Int_position;
let C351 being Integer;
set D416 = ( DataLoc (( C348 . C350 ) , C351) );
set D417 = ( if<=0 (C350 , C351 , C349) );
set D418 = ( stop D417 );
set D419 = ( Initialize C348 );
set D420 = ( R14 +* D418 );
set D421 = ( Comput (D420 , D419 , 1) );
set D422 = ( Comput (D420 , D419 , 2) );
set D423 = D420;
set D424 = D420;
set D425 = ( (C350 , C351) <=0_goto 2 );
set D426 = ( goto ( ( card C349 ) + 1 ) );
set D427 = ( Start-At (( ( card C349 ) + 2 ) , ( SCMPDS )) );
L1627: D417 = ( D425 ';' ( D426 ';' C349 ) ) by SCMPDS_4:16;
L1628: (not D416 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1629: (not C350 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1630: ( D419 . ( DataLoc (( D419 . C350 ) , C351) ) ) = ( D419 . D416 ) by L1629 , FUNCT_4:11
.= ( C348 . D416 ) by L1628 , FUNCT_4:11;
L1631: ( IC D419 ) = ( 0 ) by MEMSTR_0:47;
L1632: D418 c= D420 by FUNCT_4:25;
L1633: D418 c= D423 by L1632;
L1634: D418 c= D424 by L1632;
L1635: ( Comput (D420 , D419 , ( ( 0 ) + 1 )) ) = ( Following (D420 , ( Comput (D420 , D419 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D420 , D419) ) by EXTPRO_1:2
.= ( Exec (D425 , D419) ) by L1627 , L8;
assume L1636: ( C348 . D416 ) > ( 0 );
L1637: ( IC D421 ) = ( succ ( IC D419 ) ) by L1636 , L1635 , L1630 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L1631;
L1638: 1 in ( dom D417 ) by L859;
L1639: 1 in ( dom D418 ) by L1638 , COMPOS_1:62;
L1640: ( D423 . 1 ) = ( D418 . 1 ) by L1639 , L1633 , GRFUNC_1:2
.= ( D417 . 1 ) by L1638 , COMPOS_1:63
.= D426 by L865;
L1641: ( D420 /. ( IC D421 ) ) = ( D420 . ( IC D421 ) ) by PBOOLE:143;
L1642: ( Comput (D420 , D419 , ( 1 + 1 )) ) = ( Following (D420 , D421) ) by EXTPRO_1:3
.= ( Exec (D426 , D421) ) by L1637 , L1640 , L1641;
L1643: ( IC D422 ) = ( ICplusConst (D421 , ( ( card C349 ) + 1 )) ) by L1642 , SCMPDS_2:54
.= ( ( ( card C349 ) + 1 ) + 1 ) by L1637 , L18
.= ( ( card C349 ) + ( 1 + 1 ) );
L1644: ( D420 /. ( IC D422 ) ) = ( D420 . ( IC D422 ) ) by PBOOLE:143;
L1645: ( card D417 ) = ( ( card C349 ) + 2 ) by L856;
L1646: ( ( card C349 ) + 2 ) in ( dom D418 ) by L1645 , COMPOS_1:64;
L1647: ( D424 . ( ( card C349 ) + 2 ) ) = ( D418 . ( ( card C349 ) + 2 ) ) by L1646 , L1634 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L1645 , COMPOS_1:64;
L1648: ( CurInstr (D420 , D422) ) = ( halt ( SCMPDS ) ) by L1647 , L1643 , L1644;
L1649: D420 halts_on D419 by L1648 , EXTPRO_1:29;
L1650: ( CurInstr (D420 , D419) ) = D425 by L1627 , L8;
L1651:
now
let C352 being (Element of ( NAT ));
assume L1652: C352 < ( 1 + 1 );
L1653: C352 <= 1 by L1652 , NAT_1:13;
L1654: ( Comput (D420 , D419 , ( 0 )) ) = D419 by EXTPRO_1:2;
L1655: ( D420 /. ( IC ( Comput (D420 , D419 , C352) ) ) ) = ( D420 . ( IC ( Comput (D420 , D419 , C352) ) ) ) by PBOOLE:143;
per cases  by L1653 , NAT_1:25;
suppose L1656: C352 = ( 0 );

L1657: ( CurInstr (D420 , ( Comput (D420 , D419 , C352) )) ) = ( CurInstr (D420 , D419) ) by L1656 , L1654;
thus L1658: ( CurInstr (D420 , ( Comput (D420 , D419 , C352) )) ) <> ( halt ( SCMPDS ) ) by L1657 , L1650;
end;
suppose L1659: C352 = 1;

thus L1660: ( CurInstr (D420 , ( Comput (D420 , D419 , C352) )) ) <> ( halt ( SCMPDS ) ) by L1659 , L1637 , L1640 , L1655;
end;
end;
L1662: (for B266 being (Element of ( NAT )) holds (( CurInstr (D420 , ( Comput (D420 , D419 , B266) )) ) = ( halt ( SCMPDS ) ) implies 2 <= B266)) by L1651;
L1663: ( LifeSpan (D420 , D419) ) = 2 by L1662 , L1648 , L1649 , EXTPRO_1:def 15;
L1664: D422 = ( Result (D420 , D419) ) by L1663 , L1649 , EXTPRO_1:23;
L1665:
now
L1666: ( dom D427 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
let C353 being set;
assume L1667: C353 in ( dom ( IExec (D417 , R14 , ( Initialize C348 )) ) );
per cases  by L1667 , SCMPDS_4:6;
suppose L1668: C353 is Int_position;

L1669: C353 <> ( IC ( SCMPDS ) ) by L1668 , SCMPDS_2:43;
L1670: (not C353 in ( dom D427 )) by L1669 , L1666 , TARSKI:def 1;
L1671: (not C353 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L1668 , SCMPDS_4:18;
thus L1672: ( ( IExec (D417 , R14 , ( Initialize C348 )) ) . C353 ) = ( D422 . C353 ) by L1664
.= ( D421 . C353 ) by L1642 , L1668 , SCMPDS_2:54
.= ( D419 . C353 ) by L1635 , L1668 , SCMPDS_2:56
.= ( C348 . C353 ) by L1671 , FUNCT_4:11
.= ( ( C348 +* D427 ) . C353 ) by L1670 , FUNCT_4:11;
end;
suppose L1673: C353 = ( IC ( SCMPDS ) );

thus L1674: ( ( IExec (D417 , R14 , ( Initialize C348 )) ) . C353 ) = ( ( card C349 ) + 2 ) by L1673 , L1643 , L1664
.= ( ( C348 +* ( Start-At (( ( card C349 ) + 2 ) , ( SCMPDS )) ) ) . C353 ) by L1673 , FUNCT_4:113;
end;
end;
L1676: ( dom ( IExec (D417 , R14 , ( Initialize C348 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C348 +* D427 ) ) by PARTFUN1:def 2;
thus L1677: thesis by L1676 , L1665 , FUNCT_1:2;
end;
registration
let C354 being  shiftable  parahalting (Program of ( SCMPDS ));
let C355 being Int_position;
let C356 being Integer;
cluster ( if<=0 (C355 , C356 , C354) ) ->  shiftable  parahalting;
correctness
proof
set D428 = ( (C355 , C356) <=0_goto 2 );
set D429 = ( goto ( ( card C354 ) + 1 ) );
set D430 = ( if<=0 (C355 , C356 , C354) );
set D431 = ( stop D430 );
thus L1678: D430 is  shiftable;
let C357 being ( 0 ) -started (State of ( SCMPDS ));
let C358 being (Instruction-Sequence of ( SCMPDS ));
L1679: ( Initialize C357 ) = C357 by MEMSTR_0:44;
assume L1680: D431 c= C358;
L1681: C358 = ( C358 +* ( stop D430 ) ) by L1680 , FUNCT_4:98;
L1682: (C354 is_closed_on C357 , C358 & C354 is_halting_on C357 , C358) by L43 , L55;
per cases ;
suppose L1683: ( C357 . ( DataLoc (( C357 . C355 ) , C356) ) ) <= ( 0 );

L1684: D430 is_halting_on C357 , C358 by L1683 , L1682 , L1502;
thus L1685: C358 halts_on C357 by L1684 , L1681 , L41 , L1679;
end;
suppose L1686: ( C357 . ( DataLoc (( C357 . C355 ) , C356) ) ) > ( 0 );

L1687: D430 is_halting_on C357 , C358 by L1686 , L1537;
thus L1688: C358 halts_on C357 by L1687 , L1681 , L41 , L1679;
end;
end;
end;
registration
let C359 being  halt-free (Program of ( SCMPDS ));
let C360 being Int_position;
let C361 being Integer;
cluster ( if<=0 (C360 , C361 , C359) ) ->  halt-free;
coherence;
end;
theorem
L1692: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B267 being ( 0 ) -started (State of ( SCMPDS )) holds (for B268 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B269 being Int_position holds (for B270 being Integer holds ( IC ( IExec (( if<=0 (B269 , B270 , B268) ) , R14 , B267) ) ) = ( ( card B268 ) + 2 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C362 being ( 0 ) -started (State of ( SCMPDS ));
let C363 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C364 being Int_position;
let C365 being Integer;
set D432 = ( if<=0 (C364 , C365 , C363) );
L1693: (C363 is_closed_on C362 , R14 & C363 is_halting_on C362 , R14) by L43 , L55;
L1694: ( Initialize C362 ) = C362 by MEMSTR_0:44;
per cases ;
suppose L1695: ( C362 . ( DataLoc (( C362 . C364 ) , C365) ) ) <= ( 0 );

L1696: ( IExec (D432 , R14 , C362) ) = ( ( IExec (C363 , R14 , C362) ) +* ( Start-At (( ( card C363 ) + 2 ) , ( SCMPDS )) ) ) by L1695 , L1693 , L1574 , L1694;
thus L1697: thesis by L1696 , FUNCT_4:113;
end;
suppose L1698: ( C362 . ( DataLoc (( C362 . C364 ) , C365) ) ) > ( 0 );

L1699: ( IExec (D432 , R14 , C362) ) = ( C362 +* ( Start-At (( ( card C363 ) + 2 ) , ( SCMPDS )) ) ) by L1698 , L1626 , L1694;
thus L1700: thesis by L1699 , FUNCT_4:113;
end;
end;
theorem
L1702: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B271 being (State of ( SCMPDS )) holds (for B272 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B273 , B274 being Int_position holds (for B275 being Integer holds (( B271 . ( DataLoc (( B271 . B273 ) , B275) ) ) <= ( 0 ) implies ( ( IExec (( if<=0 (B273 , B275 , B272) ) , R14 , ( Initialize B271 )) ) . B274 ) = ( ( IExec (B272 , R14 , ( Initialize B271 )) ) . B274 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C366 being (State of ( SCMPDS ));
let C367 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C368 , C369 being Int_position;
let C370 being Integer;
assume L1703: ( C366 . ( DataLoc (( C366 . C368 ) , C370) ) ) <= ( 0 );
L1704: (not C369 in ( dom ( Start-At (( ( card C367 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1705: (C367 is_closed_on C366 , R14 & C367 is_halting_on C366 , R14) by L43 , L55;
L1706: ( IExec (( if<=0 (C368 , C370 , C367) ) , R14 , ( Initialize C366 )) ) = ( ( IExec (C367 , R14 , ( Initialize C366 )) ) +* ( Start-At (( ( card C367 ) + 2 ) , ( SCMPDS )) ) ) by L1705 , L1703 , L1574;
thus L1707: thesis by L1706 , L1704 , FUNCT_4:11;
end;
theorem
L1708: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B276 being (State of ( SCMPDS )) holds (for B277 being (Program of ( SCMPDS )) holds (for B278 , B279 being Int_position holds (for B280 being Integer holds (( B276 . ( DataLoc (( B276 . B278 ) , B280) ) ) > ( 0 ) implies ( ( IExec (( if<=0 (B278 , B280 , B277) ) , R14 , ( Initialize B276 )) ) . B279 ) = ( B276 . B279 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C371 being (State of ( SCMPDS ));
let C372 being (Program of ( SCMPDS ));
let C373 , C374 being Int_position;
let C375 being Integer;
assume L1709: ( C371 . ( DataLoc (( C371 . C373 ) , C375) ) ) > ( 0 );
L1710: ( IExec (( if<=0 (C373 , C375 , C372) ) , R14 , ( Initialize C371 )) ) = ( C371 +* ( Start-At (( ( card C372 ) + 2 ) , ( SCMPDS )) ) ) by L1709 , L1626;
L1711: (not C374 in ( dom ( Start-At (( ( card C372 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L1712: thesis by L1711 , L1710 , FUNCT_4:11;
end;
begin
theorem
L1713: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( card ( if<0 (R3 , R9 , R11 , R12) ) ) = ( ( ( card R11 ) + ( card R12 ) ) + 2 ))))) by L423;
theorem
L1714: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( if<0 (R3 , R9 , R11 , R12) ) ) & 1 in ( dom ( if<0 (R3 , R9 , R11 , R12) ) ))))))
proof
let R3 being Int_position;
let R9 being Integer;
let R11 being (Program of ( SCMPDS ));
let R12 being (Program of ( SCMPDS ));
set D433 = ( card ( if<0 (R3 , R9 , R11 , R12) ) );
L1715: D433 = ( ( ( card R11 ) + ( card R12 ) ) + 2 ) by L423;
L1716: 2 <= D433 by L1715 , NAT_1:12;
L1717: 1 < D433 by L1716 , XXREAL_0:2;
thus L1718: thesis by L1717 , AFINSQ_1:66;
end;
theorem
L1719: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (for R12 being (Program of ( SCMPDS )) holds ( ( if<0 (R3 , R9 , R11 , R12) ) . ( 0 ) ) = ( (R3 , R9) >=0_goto ( ( card R11 ) + 2 ) ))))) by L431;
theorem
L1720: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B281 being ( 0 ) -started (State of ( SCMPDS )) holds (for B282 , B283 being  shiftable (Program of ( SCMPDS )) holds (for B284 being Int_position holds (for B285 being Integer holds ((( B281 . ( DataLoc (( B281 . B284 ) , B285) ) ) < ( 0 ) & B282 is_closed_on B281 , R14 & B282 is_halting_on B281 , R14) implies (( if<0 (B284 , B285 , B282 , B283) ) is_closed_on B281 , R14 & ( if<0 (B284 , B285 , B282 , B283) ) is_halting_on B281 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C376 being ( 0 ) -started (State of ( SCMPDS ));
let C377 , C378 being  shiftable (Program of ( SCMPDS ));
let C379 being Int_position;
let C380 being Integer;
set D434 = ( DataLoc (( C376 . C379 ) , C380) );
set D435 = ( Goto ( ( card C378 ) + 1 ) );
set D436 = ( ( C377 ';' D435 ) ';' C378 );
set D437 = ( if<0 (C379 , C380 , C377 , C378) );
set D438 = ( stop D437 );
set D439 = ( stop D436 );
set D440 = ( R14 +* D439 );
set D441 = ( R14 +* D438 );
set D442 = ( Comput (D441 , C376 , 1) );
set D443 = D441;
set D444 = ( (C379 , C380) >=0_goto ( ( card C377 ) + 2 ) );
L1721: ( 0 ) in ( dom D438 ) by COMPOS_1:36;
L1722: ( Initialize C376 ) = C376 by MEMSTR_0:44;
L1723: ( IC C376 ) = ( 0 ) by L1722 , MEMSTR_0:47;
L1724: D437 = ( ( D444 ';' ( C377 ';' D435 ) ) ';' C378 ) by SCMPDS_4:14
.= ( D444 ';' D436 ) by SCMPDS_4:14;
L1725: ( Shift (D439 , 1) ) c= D443 by L1724 , L436;
L1726: ( Comput (D441 , C376 , ( ( 0 ) + 1 )) ) = ( Following (D441 , ( Comput (D441 , C376 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D441 , C376) ) by EXTPRO_1:2
.= ( Exec (D444 , C376) ) by L1724 , L8 , L1722;
L1727: (for R3 being Int_position holds ( C376 . R3 ) = ( D442 . R3 )) by L1726 , SCMPDS_2:57;
L1728: ( DataPart C376 ) = ( DataPart D442 ) by L1727 , SCMPDS_4:8;
assume L1729: ( C376 . D434 ) < ( 0 );
L1730: ( IC D442 ) = ( succ ( IC C376 ) ) by L1729 , L1726 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L1723;
assume L1731: C377 is_closed_on C376 , R14;
assume L1732: C377 is_halting_on C376 , R14;
L1733: D436 is_closed_on C376 , R14 by L1732 , L1731 , L284;
L1734: (( Start-At (( 0 ) , ( SCMPDS )) ) c= C376 & D436 is_closed_on C376 , D440) by L1733 , L143 , L1722 , FUNCT_4:25;
L1735: ( stop D436 ) c= D440 by FUNCT_4:25;
L1736: D436 is_halting_on C376 , R14 by L1731 , L1732 , L284;
L1737: D440 halts_on C376 by L1736 , L41 , L1722;
L1738: ( card D438 ) = ( ( card D437 ) + 1 ) by COMPOS_1:55
.= ( ( ( card D436 ) + 1 ) + 1 ) by L1724 , L3;
L1739:
now
let C381 being (Element of ( NAT ));
per cases ;
suppose L1740: ( 0 ) < C381;

consider C382 being Nat such that L1741: ( C382 + 1 ) = C381 by L1740 , NAT_1:6;
reconsider D445 = C382 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D446 = ( IC ( Comput (D440 , C376 , D445) ) ) as (Element of ( NAT ));
L1742: ( card D438 ) = ( ( card D439 ) + 1 ) by L1738 , COMPOS_1:55;
L1743: D446 in ( dom D439 ) by L1733 , L40 , L1722;
L1744: D446 < ( card D439 ) by L1743 , AFINSQ_1:66;
L1745: ( D446 + 1 ) < ( card D438 ) by L1744 , L1742 , XREAL_1:6;
L1746: ( IC ( Comput (D441 , C376 , C381) ) ) = ( IC ( Comput (D441 , D442 , D445) ) ) by L1741 , EXTPRO_1:4
.= ( D446 + 1 ) by L1734 , L1725 , L1730 , L1728 , L360 , L1735;
thus L1747: ( IC ( Comput (D441 , C376 , C381) ) ) in ( dom D438 ) by L1746 , L1745 , AFINSQ_1:66;
end;
suppose L1748: C381 = ( 0 );

thus L1749: ( IC ( Comput (D441 , C376 , C381) ) ) in ( dom D438 ) by L1748 , L1721 , L1723 , EXTPRO_1:2;
end;
end;
thus L1751: D437 is_closed_on C376 , R14 by L1739 , L40 , L1722;
L1752: ( Comput (D441 , C376 , ( ( LifeSpan (D440 , C376) ) + 1 )) ) = ( Comput (D441 , ( Comput (D441 , C376 , 1) ) , ( LifeSpan (D440 , C376) )) ) by EXTPRO_1:4;
L1753: ( CurInstr (D441 , ( Comput (D441 , C376 , ( ( LifeSpan (D440 , C376) ) + 1 )) )) ) = ( CurInstr (D441 , ( Comput (D441 , D442 , ( LifeSpan (D440 , C376) )) )) ) by L1752
.= ( CurInstr (D440 , ( Comput (D440 , C376 , ( LifeSpan (D440 , C376) )) )) ) by L1734 , L1725 , L1730 , L1728 , L360 , L1735
.= ( halt ( SCMPDS ) ) by L1737 , EXTPRO_1:def 15;
L1754: D441 halts_on C376 by L1753 , EXTPRO_1:29;
thus L1755: thesis by L1754 , L41 , L1722;
end;
theorem
L1756: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B286 being (State of ( SCMPDS )) holds (for B287 being (Program of ( SCMPDS )) holds (for B288 being  shiftable (Program of ( SCMPDS )) holds (for B289 being Int_position holds (for B290 being Integer holds ((( B286 . ( DataLoc (( B286 . B289 ) , B290) ) ) >= ( 0 ) & B288 is_closed_on B286 , R14 & B288 is_halting_on B286 , R14) implies (( if<0 (B289 , B290 , B287 , B288) ) is_closed_on B286 , R14 & ( if<0 (B289 , B290 , B287 , B288) ) is_halting_on B286 , R14))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C383 being (State of ( SCMPDS ));
let C384 being (Program of ( SCMPDS ));
let C385 being  shiftable (Program of ( SCMPDS ));
let C386 being Int_position;
let C387 being Integer;
set D447 = ( DataLoc (( C383 . C386 ) , C387) );
set D448 = ( stop C385 );
set D449 = ( Initialize C383 );
set D450 = ( R14 +* D448 );
set D451 = ( if<0 (C386 , C387 , C384 , C385) );
set D452 = ( stop D451 );
set D453 = ( Initialize C383 );
set D454 = ( R14 +* D452 );
set D455 = ( Comput (D454 , D453 , 1) );
set D456 = D454;
set D457 = ( (C386 , C387) >=0_goto ( ( card C384 ) + 2 ) );
set D458 = ( Goto ( ( card C385 ) + 1 ) );
set D459 = ( ( D457 ';' C384 ) ';' D458 );
L1757: D451 = ( ( D457 ';' ( C384 ';' D458 ) ) ';' C385 ) by SCMPDS_4:14
.= ( D457 ';' ( ( C384 ';' D458 ) ';' C385 ) ) by SCMPDS_4:14;
L1758: ( Comput (D454 , D453 , ( ( 0 ) + 1 )) ) = ( Following (D454 , ( Comput (D454 , D453 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D454 , D453) ) by EXTPRO_1:2
.= ( Exec (D457 , D453) ) by L1757 , L8;
L1759: (not D447 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1760: (not C386 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1761: ( D453 . ( DataLoc (( D453 . C386 ) , C387) ) ) = ( D453 . D447 ) by L1760 , FUNCT_4:11
.= ( C383 . D447 ) by L1759 , FUNCT_4:11;
L1762: ( IC D453 ) = ( 0 ) by MEMSTR_0:47;
assume L1763: ( C383 . D447 ) >= ( 0 );
L1764: ( IC D455 ) = ( ICplusConst (D453 , ( ( card C384 ) + 2 )) ) by L1763 , L1758 , L1761 , SCMPDS_2:57
.= ( ( 0 ) + ( ( card C384 ) + 2 ) ) by L1762 , L18;
assume L1765: C385 is_closed_on C383 , R14;
L1766: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D449 & C385 is_closed_on D449 , D450) by L1765 , L143 , FUNCT_4:25;
L1767: ( stop C385 ) c= D450 by FUNCT_4:25;
L1768: D452 c= D454 by FUNCT_4:25;
L1769: ( card D459 ) = ( ( card ( D457 ';' C384 ) ) + ( card D458 ) ) by AFINSQ_1:17
.= ( ( card ( D457 ';' C384 ) ) + 1 ) by COMPOS_1:54
.= ( ( ( card C384 ) + 1 ) + 1 ) by L3
.= ( ( card C384 ) + ( 1 + 1 ) );
L1770: ( Shift (D448 , ( ( card C384 ) + 2 )) ) c= D452 by L1769 , L21;
L1771: ( Shift (D448 , ( ( card C384 ) + 2 )) ) c= D454 by L1770 , L1768 , XBOOLE_1:1;
L1772: ( Shift (D448 , ( ( card C384 ) + 2 )) ) c= D456 by L1771;
assume L1773: C385 is_halting_on C383 , R14;
L1774: D450 halts_on D449 by L1773 , L41;
L1775: (for R3 being Int_position holds ( D449 . R3 ) = ( D455 . R3 )) by L1758 , SCMPDS_2:57;
L1776: ( DataPart D449 ) = ( DataPart D455 ) by L1775 , SCMPDS_4:8;
L1777:
now
let C388 being (Element of ( NAT ));
per cases ;
suppose L1778: ( 0 ) < C388;

consider C389 being Nat such that L1779: ( C389 + 1 ) = C388 by L1778 , NAT_1:6;
reconsider D460 = C389 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D461 = ( IC ( Comput (D450 , D449 , D460) ) ) as (Element of ( NAT ));
L1780: D461 in ( dom D448 ) by L1765 , L40;
L1781: D461 < ( card D448 ) by L1780 , AFINSQ_1:66;
L1782: ( D461 + ( ( card C384 ) + 2 ) ) < ( ( card D448 ) + ( ( card C384 ) + 2 ) ) by L1781 , XREAL_1:6;
L1783: ( card D448 ) = ( ( card C385 ) + 1 ) by COMPOS_1:55;
L1784: ( card D452 ) = ( ( card D451 ) + 1 ) by COMPOS_1:55
.= ( ( ( ( card C384 ) + 2 ) + ( card C385 ) ) + 1 ) by L1769 , AFINSQ_1:17
.= ( ( ( card C384 ) + 2 ) + ( card D448 ) ) by L1783;
L1785: ( IC ( Comput (D454 , D453 , C388) ) ) = ( IC ( Comput (D454 , D455 , D460) ) ) by L1779 , EXTPRO_1:4
.= ( D461 + ( ( card C384 ) + 2 ) ) by L1766 , L1776 , L1772 , L1764 , L360 , L1767;
thus L1786: ( IC ( Comput (D454 , D453 , C388) ) ) in ( dom D452 ) by L1785 , L1784 , L1782 , AFINSQ_1:66;
end;
suppose L1787: C388 = ( 0 );

L1788: ( Comput (D454 , D453 , C388) ) = D453 by L1787 , EXTPRO_1:2;
thus L1789: ( IC ( Comput (D454 , D453 , C388) ) ) in ( dom D452 ) by L1788 , L1762 , COMPOS_1:36;
end;
end;
thus L1791: D451 is_closed_on C383 , R14 by L1777 , L40;
L1792: ( Comput (D454 , D453 , ( ( LifeSpan (D450 , D449) ) + 1 )) ) = ( Comput (D454 , ( Comput (D454 , D453 , 1) ) , ( LifeSpan (D450 , D449) )) ) by EXTPRO_1:4;
L1793: ( CurInstr (D454 , ( Comput (D454 , D453 , ( ( LifeSpan (D450 , D449) ) + 1 )) )) ) = ( CurInstr (D454 , ( Comput (D454 , D455 , ( LifeSpan (D450 , D449) )) )) ) by L1792
.= ( CurInstr (D450 , ( Comput (D450 , D449 , ( LifeSpan (D450 , D449) )) )) ) by L1766 , L1776 , L1772 , L1764 , L360 , L1767
.= ( halt ( SCMPDS ) ) by L1774 , EXTPRO_1:def 15;
L1794: D454 halts_on D453 by L1793 , EXTPRO_1:29;
thus L1795: thesis by L1794 , L41;
end;
theorem
L1796: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B291 being ( 0 ) -started (State of ( SCMPDS )) holds (for B292 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B293 being  shiftable (Program of ( SCMPDS )) holds (for B294 being Int_position holds (for B295 being Integer holds ((( B291 . ( DataLoc (( B291 . B294 ) , B295) ) ) < ( 0 ) & B292 is_closed_on B291 , R14 & B292 is_halting_on B291 , R14) implies ( IExec (( if<0 (B294 , B295 , B292 , B293) ) , R14 , B291) ) = ( ( IExec (B292 , R14 , B291) ) +* ( Start-At (( ( ( card B292 ) + ( card B293 ) ) + 2 ) , ( SCMPDS )) ) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C390 being ( 0 ) -started (State of ( SCMPDS ));
let C391 being  halt-free  shiftable (Program of ( SCMPDS ));
let C392 being  shiftable (Program of ( SCMPDS ));
let C393 being Int_position;
let C394 being Integer;
set D462 = ( DataLoc (( C390 . C393 ) , C394) );
set D463 = ( Goto ( ( card C392 ) + 1 ) );
set D464 = ( ( C391 ';' D463 ) ';' C392 );
set D465 = ( if<0 (C393 , C394 , C391 , C392) );
set D466 = ( stop D465 );
set D467 = ( stop D464 );
set D468 = ( R14 +* D467 );
set D469 = ( R14 +* D466 );
set D470 = ( Comput (D469 , C390 , 1) );
set D471 = D469;
set D472 = ( (C393 , C394) >=0_goto ( ( card C391 ) + 2 ) );
set D473 = ( Start-At (( ( ( card C391 ) + ( card C392 ) ) + 2 ) , ( SCMPDS )) );
L1797: ( Initialize C390 ) = C390 by MEMSTR_0:44;
L1798: ( IC C390 ) = ( 0 ) by L1797 , MEMSTR_0:47;
L1799: D465 = ( ( D472 ';' ( C391 ';' D463 ) ) ';' C392 ) by SCMPDS_4:14
.= ( D472 ';' D464 ) by SCMPDS_4:14;
L1800: ( Shift (D467 , 1) ) c= D471 by L1799 , L436;
L1801: ( Comput (D469 , C390 , ( ( 0 ) + 1 )) ) = ( Following (D469 , ( Comput (D469 , C390 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D469 , C390) ) by EXTPRO_1:2
.= ( Exec (D472 , C390) ) by L1799 , L8 , L1797;
assume L1802: ( C390 . D462 ) < ( 0 );
L1803: ( IC D470 ) = ( succ ( IC C390 ) ) by L1802 , L1801 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L1798;
L1804: (for R3 being Int_position holds ( C390 . R3 ) = ( D470 . R3 )) by L1801 , SCMPDS_2:57;
L1805: ( DataPart C390 ) = ( DataPart D470 ) by L1804 , SCMPDS_4:8;
assume L1806: C391 is_closed_on C390 , R14;
assume L1807: C391 is_halting_on C390 , R14;
L1808: D464 is_halting_on C390 , R14 by L1807 , L1806 , L284;
L1809: D468 halts_on C390 by L1808 , L41 , L1797;
L1810: D464 is_closed_on C390 , R14 by L1806 , L1807 , L284;
L1811: (( Start-At (( 0 ) , ( SCMPDS )) ) c= C390 & D464 is_closed_on C390 , D468) by L1810 , L143 , L1797 , FUNCT_4:25;
L1812: ( stop D464 ) c= D468 by FUNCT_4:25;
L1813: ( Comput (D469 , C390 , ( ( LifeSpan (D468 , C390) ) + 1 )) ) = ( Comput (D469 , ( Comput (D469 , C390 , 1) ) , ( LifeSpan (D468 , C390) )) ) by EXTPRO_1:4;
L1814: ( CurInstr (D469 , ( Comput (D469 , C390 , ( ( LifeSpan (D468 , C390) ) + 1 )) )) ) = ( CurInstr (D469 , ( Comput (D469 , D470 , ( LifeSpan (D468 , C390) )) )) ) by L1813
.= ( CurInstr (D468 , ( Comput (D468 , C390 , ( LifeSpan (D468 , C390) )) )) ) by L1811 , L1800 , L1803 , L1805 , L360 , L1812
.= ( halt ( SCMPDS ) ) by L1809 , EXTPRO_1:def 15;
L1815: D469 halts_on C390 by L1814 , EXTPRO_1:29;
L1816: ( CurInstr (D469 , C390) ) = D472 by L1799 , L8 , L1797;
L1817:
now
let C395 being (Element of ( NAT ));
assume L1818: C395 < ( ( LifeSpan (D468 , C390) ) + 1 );
L1819: ( Comput (D469 , C390 , ( 0 )) ) = C390 by EXTPRO_1:2;
per cases ;
suppose L1820: C395 = ( 0 );

L1821: ( CurInstr (D469 , ( Comput (D469 , C390 , C395) )) ) = ( CurInstr (D469 , C390) ) by L1820 , L1819;
thus L1822: ( CurInstr (D469 , ( Comput (D469 , C390 , C395) )) ) <> ( halt ( SCMPDS ) ) by L1821 , L1816;
end;
suppose L1823: C395 <> ( 0 );

consider C396 being Nat such that L1824: C395 = ( C396 + 1 ) by L1823 , NAT_1:6;
reconsider D474 = C396 as (Element of ( NAT )) by ORDINAL1:def 12;
L1825: D474 < ( LifeSpan (D468 , C390) ) by L1818 , L1824 , XREAL_1:6;
assume L1826: ( CurInstr (D469 , ( Comput (D469 , C390 , C395) )) ) = ( halt ( SCMPDS ) );
L1827: ( Comput (D469 , C390 , ( D474 + 1 )) ) = ( Comput (D469 , ( Comput (D469 , C390 , 1) ) , D474) ) by EXTPRO_1:4;
L1828: ( CurInstr (D468 , ( Comput (D468 , C390 , D474) )) ) = ( CurInstr (D469 , ( Comput (D469 , D470 , D474) )) ) by L1811 , L1800 , L1803 , L1805 , L360 , L1812
.= ( halt ( SCMPDS ) ) by L1824 , L1826 , L1827;
thus L1829: contradiction by L1828 , L1809 , L1825 , EXTPRO_1:def 15;
end;
end;
L1831: (for B296 being (Element of ( NAT )) holds (( CurInstr (D469 , ( Comput (D469 , C390 , B296) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D468 , C390) ) + 1 ) <= B296)) by L1817;
L1832: ( LifeSpan (D469 , C390) ) = ( ( LifeSpan (D468 , C390) ) + 1 ) by L1831 , L1814 , L1815 , EXTPRO_1:def 15;
L1833: ( DataPart ( Result (D468 , C390) ) ) = ( DataPart ( Comput (D468 , C390 , ( LifeSpan (D468 , C390) )) ) ) by L1809 , EXTPRO_1:23
.= ( DataPart ( Comput (D469 , D470 , ( LifeSpan (D468 , C390) )) ) ) by L1811 , L1800 , L1803 , L1805 , L360 , L1812
.= ( DataPart ( Comput (D469 , C390 , ( ( LifeSpan (D468 , C390) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D469 , C390) ) ) by L1815 , L1832 , EXTPRO_1:23;
L1834:
now
let C397 being set;
L1835: ( dom D473 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L1836: C397 in ( dom ( IExec (D465 , R14 , C390) ) );
per cases  by L1836 , SCMPDS_4:6;
suppose L1837: C397 is Int_position;

L1838: C397 <> ( IC ( SCMPDS ) ) by L1837 , SCMPDS_2:43;
L1839: (not C397 in ( dom D473 )) by L1838 , L1835 , TARSKI:def 1;
thus L1840: ( ( IExec (D465 , R14 , C390) ) . C397 ) = ( ( Result (D469 , C390) ) . C397 )
.= ( ( Result (D468 , C390) ) . C397 ) by L1833 , L1837 , SCMPDS_4:8
.= ( ( IExec (D464 , R14 , C390) ) . C397 )
.= ( ( ( IExec (D464 , R14 , C390) ) +* D473 ) . C397 ) by L1839 , FUNCT_4:11;
end;
suppose L1841: C397 = ( IC ( SCMPDS ) );

L1842: ( IC ( Result (D468 , C390) ) ) = ( IC ( IExec (D464 , R14 , C390) ) )
.= ( ( ( card C391 ) + ( card C392 ) ) + 1 ) by L1806 , L1807 , L398;
L1843: C397 in ( dom D473 ) by L1835 , L1841 , TARSKI:def 1;
thus L1844: ( ( IExec (D465 , R14 , C390) ) . C397 ) = ( ( Result (D469 , C390) ) . C397 )
.= ( ( Comput (D469 , C390 , ( ( LifeSpan (D468 , C390) ) + 1 )) ) . C397 ) by L1815 , L1832 , EXTPRO_1:23
.= ( IC ( Comput (D469 , D470 , ( LifeSpan (D468 , C390) )) ) ) by L1841 , EXTPRO_1:4
.= ( ( IC ( Comput (D468 , C390 , ( LifeSpan (D468 , C390) )) ) ) + 1 ) by L1811 , L1800 , L1803 , L1805 , L360 , L1812
.= ( ( IC ( Result (D468 , C390) ) ) + 1 ) by L1809 , EXTPRO_1:23
.= ( IC ( Start-At (( ( ( ( card C391 ) + ( card C392 ) ) + 1 ) + 1 ) , ( SCMPDS )) ) ) by L1842 , FUNCOP_1:72
.= ( ( ( IExec (D464 , R14 , C390) ) +* D473 ) . C397 ) by L1841 , L1843 , FUNCT_4:13;
end;
end;
L1846: ( dom ( IExec (D465 , R14 , C390) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (D464 , R14 , C390) ) +* D473 ) ) by PARTFUN1:def 2;
thus L1847: ( IExec (D465 , R14 , C390) ) = ( ( IExec (D464 , R14 , C390) ) +* D473 ) by L1846 , L1834 , FUNCT_1:2
.= ( ( ( IExec (C391 , R14 , C390) ) +* ( Start-At (( ( ( card C391 ) + ( card C392 ) ) + 1 ) , ( SCMPDS )) ) ) +* ( Start-At (( ( ( card C391 ) + ( card C392 ) ) + 2 ) , ( SCMPDS )) ) ) by L1806 , L1807 , L404
.= ( ( IExec (C391 , R14 , C390) ) +* D473 ) by MEMSTR_0:36;
end;
theorem
L1848: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B297 being (State of ( SCMPDS )) holds (for B298 being (Program of ( SCMPDS )) holds (for B299 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B300 being Int_position holds (for B301 being Integer holds ((( B297 . ( DataLoc (( B297 . B300 ) , B301) ) ) >= ( 0 ) & B299 is_closed_on B297 , R14 & B299 is_halting_on B297 , R14) implies ( IExec (( if<0 (B300 , B301 , B298 , B299) ) , R14 , ( Initialize B297 )) ) = ( ( IExec (B299 , R14 , ( Initialize B297 )) ) +* ( Start-At (( ( ( card B298 ) + ( card B299 ) ) + 2 ) , ( SCMPDS )) ) ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C398 being (State of ( SCMPDS ));
let C399 being (Program of ( SCMPDS ));
let C400 being  halt-free  shiftable (Program of ( SCMPDS ));
let C401 being Int_position;
let C402 being Integer;
set D475 = ( DataLoc (( C398 . C401 ) , C402) );
set D476 = ( stop C400 );
set D477 = ( Initialize C398 );
set D478 = ( R14 +* D476 );
set D479 = ( if<0 (C401 , C402 , C399 , C400) );
set D480 = ( stop D479 );
set D481 = ( Initialize C398 );
set D482 = ( R14 +* D480 );
set D483 = ( Comput (D482 , D481 , 1) );
set D484 = D482;
set D485 = ( (C401 , C402) >=0_goto ( ( card C399 ) + 2 ) );
set D486 = ( Goto ( ( card C400 ) + 1 ) );
set D487 = ( ( D485 ';' C399 ) ';' D486 );
set D488 = ( Start-At (( ( ( card C399 ) + ( card C400 ) ) + 2 ) , ( SCMPDS )) );
L1849: D479 = ( ( D485 ';' ( C399 ';' D486 ) ) ';' C400 ) by SCMPDS_4:14
.= ( D485 ';' ( ( C399 ';' D486 ) ';' C400 ) ) by SCMPDS_4:14;
L1850: ( Comput (D482 , D481 , ( ( 0 ) + 1 )) ) = ( Following (D482 , ( Comput (D482 , D481 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D482 , D481) ) by EXTPRO_1:2
.= ( Exec (D485 , D481) ) by L1849 , L8;
L1851: (not D475 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1852: (not C401 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1853: ( D481 . ( DataLoc (( D481 . C401 ) , C402) ) ) = ( D481 . D475 ) by L1852 , FUNCT_4:11
.= ( C398 . D475 ) by L1851 , FUNCT_4:11;
L1854: ( IC D481 ) = ( 0 ) by MEMSTR_0:47;
assume L1855: ( C398 . D475 ) >= ( 0 );
L1856: ( IC D483 ) = ( ICplusConst (D481 , ( ( card C399 ) + 2 )) ) by L1855 , L1850 , L1853 , SCMPDS_2:57
.= ( ( 0 ) + ( ( card C399 ) + 2 ) ) by L1854 , L18;
L1857: (for R3 being Int_position holds ( D477 . R3 ) = ( D483 . R3 )) by L1850 , SCMPDS_2:57;
L1858: ( DataPart D477 ) = ( DataPart D483 ) by L1857 , SCMPDS_4:8;
L1859: ( card D487 ) = ( ( card ( D485 ';' C399 ) ) + ( card D486 ) ) by AFINSQ_1:17
.= ( ( card ( D485 ';' C399 ) ) + 1 ) by COMPOS_1:54
.= ( ( ( card C399 ) + 1 ) + 1 ) by L3
.= ( ( card C399 ) + ( 1 + 1 ) );
L1860: ( Shift (D476 , ( ( card C399 ) + 2 )) ) c= D480 by L1859 , L21;
L1861: D480 c= D482 by FUNCT_4:25;
L1862: ( Shift (D476 , ( ( card C399 ) + 2 )) ) c= D482 by L1861 , L1860 , XBOOLE_1:1;
L1863: ( Shift (D476 , ( ( card C399 ) + 2 )) ) c= D484 by L1862;
assume L1864: C400 is_closed_on C398 , R14;
L1865: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D477 & C400 is_closed_on D477 , D478) by L1864 , L143 , FUNCT_4:25;
L1866: ( stop C400 ) c= D478 by FUNCT_4:25;
assume L1867: C400 is_halting_on C398 , R14;
L1868: D478 halts_on D477 by L1867 , L41;
L1869: ( Comput (D482 , D481 , ( ( LifeSpan (D478 , D477) ) + 1 )) ) = ( Comput (D482 , ( Comput (D482 , D481 , 1) ) , ( LifeSpan (D478 , D477) )) ) by EXTPRO_1:4;
L1870: ( CurInstr (D482 , ( Comput (D482 , D481 , ( ( LifeSpan (D478 , D477) ) + 1 )) )) ) = ( CurInstr (D482 , ( Comput (D482 , D483 , ( LifeSpan (D478 , D477) )) )) ) by L1869
.= ( CurInstr (D478 , ( Comput (D478 , D477 , ( LifeSpan (D478 , D477) )) )) ) by L1865 , L1863 , L1856 , L1858 , L360 , L1866
.= ( halt ( SCMPDS ) ) by L1868 , EXTPRO_1:def 15;
L1871: D482 halts_on D481 by L1870 , EXTPRO_1:29;
L1872: ( CurInstr (D482 , D481) ) = D485 by L1849 , L8;
L1873:
now
let C403 being (Element of ( NAT ));
assume L1874: C403 < ( ( LifeSpan (D478 , D477) ) + 1 );
L1875: ( Comput (D482 , D481 , ( 0 )) ) = D481 by EXTPRO_1:2;
per cases ;
suppose L1876: C403 = ( 0 );

L1877: ( CurInstr (D482 , ( Comput (D482 , D481 , C403) )) ) = ( CurInstr (D482 , D481) ) by L1876 , L1875;
thus L1878: ( CurInstr (D482 , ( Comput (D482 , D481 , C403) )) ) <> ( halt ( SCMPDS ) ) by L1877 , L1872;
end;
suppose L1879: C403 <> ( 0 );

consider C404 being Nat such that L1880: C403 = ( C404 + 1 ) by L1879 , NAT_1:6;
reconsider D489 = C404 as (Element of ( NAT )) by ORDINAL1:def 12;
L1881: D489 < ( LifeSpan (D478 , D477) ) by L1874 , L1880 , XREAL_1:6;
assume L1882: ( CurInstr (D482 , ( Comput (D482 , D481 , C403) )) ) = ( halt ( SCMPDS ) );
L1883: ( Comput (D482 , D481 , ( D489 + 1 )) ) = ( Comput (D482 , ( Comput (D482 , D481 , 1) ) , D489) ) by EXTPRO_1:4;
L1884: ( CurInstr (D478 , ( Comput (D478 , D477 , D489) )) ) = ( CurInstr (D482 , ( Comput (D482 , D483 , D489) )) ) by L1865 , L1863 , L1856 , L1858 , L360 , L1866
.= ( halt ( SCMPDS ) ) by L1880 , L1882 , L1883;
thus L1885: contradiction by L1884 , L1868 , L1881 , EXTPRO_1:def 15;
end;
end;
L1887: (for B302 being (Element of ( NAT )) holds (( CurInstr (D482 , ( Comput (D482 , D481 , B302) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D478 , D477) ) + 1 ) <= B302)) by L1873;
L1888: ( LifeSpan (D482 , D481) ) = ( ( LifeSpan (D478 , D477) ) + 1 ) by L1887 , L1870 , L1871 , EXTPRO_1:def 15;
L1889: ( DataPart ( Result (D478 , D477) ) ) = ( DataPart ( Comput (D478 , D477 , ( LifeSpan (D478 , D477) )) ) ) by L1868 , EXTPRO_1:23
.= ( DataPart ( Comput (D482 , D483 , ( LifeSpan (D478 , D477) )) ) ) by L1865 , L1863 , L1856 , L1858 , L360 , L1866
.= ( DataPart ( Comput (D482 , D481 , ( ( LifeSpan (D478 , D477) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D482 , D481) ) ) by L1871 , L1888 , EXTPRO_1:23;
L1890:
now
let C405 being set;
L1891: ( dom D488 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L1892: C405 in ( dom ( IExec (D479 , R14 , ( Initialize C398 )) ) );
per cases  by L1892 , SCMPDS_4:6;
suppose L1893: C405 is Int_position;

L1894: C405 <> ( IC ( SCMPDS ) ) by L1893 , SCMPDS_2:43;
L1895: (not C405 in ( dom D488 )) by L1894 , L1891 , TARSKI:def 1;
thus L1896: ( ( IExec (D479 , R14 , ( Initialize C398 )) ) . C405 ) = ( ( Result (D482 , D481) ) . C405 )
.= ( ( Result (D478 , D477) ) . C405 ) by L1889 , L1893 , SCMPDS_4:8
.= ( ( IExec (C400 , R14 , ( Initialize C398 )) ) . C405 )
.= ( ( ( IExec (C400 , R14 , ( Initialize C398 )) ) +* D488 ) . C405 ) by L1895 , FUNCT_4:11;
end;
suppose L1897: C405 = ( IC ( SCMPDS ) );

L1898: ( IC ( Result (D478 , D477) ) ) = ( IC ( IExec (C400 , R14 , ( Initialize C398 )) ) )
.= ( card C400 ) by L1864 , L1867 , L416;
L1899: C405 in ( dom D488 ) by L1891 , L1897 , TARSKI:def 1;
thus L1900: ( ( IExec (D479 , R14 , ( Initialize C398 )) ) . C405 ) = ( ( Result (D482 , D481) ) . C405 )
.= ( ( Comput (D482 , D481 , ( ( LifeSpan (D478 , D477) ) + 1 )) ) . C405 ) by L1871 , L1888 , EXTPRO_1:23
.= ( IC ( Comput (D482 , D483 , ( LifeSpan (D478 , D477) )) ) ) by L1897 , EXTPRO_1:4
.= ( ( IC ( Comput (D478 , D477 , ( LifeSpan (D478 , D477) )) ) ) + ( ( card C399 ) + 2 ) ) by L1865 , L1863 , L1856 , L1858 , L360 , L1866
.= ( ( IC ( Result (D478 , D477) ) ) + ( ( card C399 ) + 2 ) ) by L1868 , EXTPRO_1:23
.= ( IC ( Start-At (( ( card C400 ) + ( ( card C399 ) + 2 ) ) , ( SCMPDS )) ) ) by L1898 , FUNCOP_1:72
.= ( ( ( IExec (C400 , R14 , ( Initialize C398 )) ) +* D488 ) . C405 ) by L1897 , L1899 , FUNCT_4:13;
end;
end;
L1902: ( dom ( IExec (D479 , R14 , ( Initialize C398 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C400 , R14 , ( Initialize C398 )) ) +* D488 ) ) by PARTFUN1:def 2;
thus L1903: thesis by L1902 , L1890 , FUNCT_1:2;
end;
registration
let C406 , C407 being  shiftable  parahalting (Program of ( SCMPDS ));
let C408 being Int_position;
let C409 being Integer;
cluster ( if<0 (C408 , C409 , C406 , C407) ) ->  shiftable  parahalting;
correctness
proof
set D490 = ( (C408 , C409) >=0_goto ( ( card C406 ) + 2 ) );
set D491 = ( Goto ( ( card C407 ) + 1 ) );
set D492 = ( if<0 (C408 , C409 , C406 , C407) );
set D493 = ( stop D492 );
reconsider D494 = ( ( C406 ';' D491 ) ';' C407 ) as  shiftable (Program of ( SCMPDS ));
thus L1904: D492 is  shiftable;
let C410 being ( 0 ) -started (State of ( SCMPDS ));
let C411 being (Instruction-Sequence of ( SCMPDS ));
L1905: ( Initialize C410 ) = C410 by MEMSTR_0:44;
assume L1906: D493 c= C411;
L1907: C411 = ( C411 +* ( stop D492 ) ) by L1906 , FUNCT_4:98;
L1908: (C407 is_closed_on C410 , C411 & C407 is_halting_on C410 , C411) by L43 , L55;
L1909: (C406 is_closed_on C410 , C411 & C406 is_halting_on C410 , C411) by L43 , L55;
per cases ;
suppose L1910: ( C410 . ( DataLoc (( C410 . C408 ) , C409) ) ) < ( 0 );

L1911: D492 is_halting_on C410 , C411 by L1910 , L1909 , L1720;
thus L1912: C411 halts_on C410 by L1911 , L1907 , L41 , L1905;
end;
suppose L1913: ( C410 . ( DataLoc (( C410 . C408 ) , C409) ) ) >= ( 0 );

L1914: D492 is_halting_on C410 , C411 by L1913 , L1908 , L1756;
thus L1915: C411 halts_on C410 by L1914 , L1907 , L41 , L1905;
end;
end;
end;
registration
let C412 , C413 being  halt-free (Program of ( SCMPDS ));
let C414 being Int_position;
let C415 being Integer;
cluster ( if<0 (C414 , C415 , C412 , C413) ) ->  halt-free;
coherence;
end;
theorem
L1919: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B303 being ( 0 ) -started (State of ( SCMPDS )) holds (for B304 , B305 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B306 being Int_position holds (for B307 being Integer holds ( IC ( IExec (( if<0 (B306 , B307 , B304 , B305) ) , R14 , B303) ) ) = ( ( ( card B304 ) + ( card B305 ) ) + 2 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C416 being ( 0 ) -started (State of ( SCMPDS ));
let C417 , C418 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C419 being Int_position;
let C420 being Integer;
set D495 = ( if<0 (C419 , C420 , C417 , C418) );
L1920: (C417 is_closed_on C416 , R14 & C417 is_halting_on C416 , R14) by L43 , L55;
L1921: (C418 is_closed_on C416 , R14 & C418 is_halting_on C416 , R14) by L43 , L55;
L1922: ( Initialize C416 ) = C416 by MEMSTR_0:44;
per cases ;
suppose L1923: ( C416 . ( DataLoc (( C416 . C419 ) , C420) ) ) < ( 0 );

L1924: ( IExec (D495 , R14 , C416) ) = ( ( IExec (C417 , R14 , C416) ) +* ( Start-At (( ( ( card C417 ) + ( card C418 ) ) + 2 ) , ( SCMPDS )) ) ) by L1923 , L1920 , L1796;
thus L1925: thesis by L1924 , FUNCT_4:113;
end;
suppose L1926: ( C416 . ( DataLoc (( C416 . C419 ) , C420) ) ) >= ( 0 );

L1927: ( IExec (D495 , R14 , C416) ) = ( ( IExec (C418 , R14 , C416) ) +* ( Start-At (( ( ( card C417 ) + ( card C418 ) ) + 2 ) , ( SCMPDS )) ) ) by L1926 , L1921 , L1848 , L1922;
thus L1928: thesis by L1927 , FUNCT_4:113;
end;
end;
theorem
L1930: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B308 being ( 0 ) -started (State of ( SCMPDS )) holds (for B309 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B310 being  shiftable (Program of ( SCMPDS )) holds (for B311 , B312 being Int_position holds (for B313 being Integer holds (( B308 . ( DataLoc (( B308 . B311 ) , B313) ) ) < ( 0 ) implies ( ( IExec (( if<0 (B311 , B313 , B309 , B310) ) , R14 , B308) ) . B312 ) = ( ( IExec (B309 , R14 , B308) ) . B312 ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C421 being ( 0 ) -started (State of ( SCMPDS ));
let C422 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C423 being  shiftable (Program of ( SCMPDS ));
let C424 , C425 being Int_position;
let C426 being Integer;
assume L1931: ( C421 . ( DataLoc (( C421 . C424 ) , C426) ) ) < ( 0 );
L1932: (not C425 in ( dom ( Start-At (( ( ( card C422 ) + ( card C423 ) ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1933: (C422 is_closed_on C421 , R14 & C422 is_halting_on C421 , R14) by L43 , L55;
L1934: ( IExec (( if<0 (C424 , C426 , C422 , C423) ) , R14 , C421) ) = ( ( IExec (C422 , R14 , C421) ) +* ( Start-At (( ( ( card C422 ) + ( card C423 ) ) + 2 ) , ( SCMPDS )) ) ) by L1933 , L1931 , L1796;
thus L1935: thesis by L1934 , L1932 , FUNCT_4:11;
end;
theorem
L1936: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B314 being (State of ( SCMPDS )) holds (for B315 being (Program of ( SCMPDS )) holds (for B316 being  halt-free  parahalting  shiftable (Program of ( SCMPDS )) holds (for B317 , B318 being Int_position holds (for B319 being Integer holds (( B314 . ( DataLoc (( B314 . B317 ) , B319) ) ) >= ( 0 ) implies ( ( IExec (( if<0 (B317 , B319 , B315 , B316) ) , R14 , ( Initialize B314 )) ) . B318 ) = ( ( IExec (B316 , R14 , ( Initialize B314 )) ) . B318 ))))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C427 being (State of ( SCMPDS ));
let C428 being (Program of ( SCMPDS ));
let C429 being  halt-free  parahalting  shiftable (Program of ( SCMPDS ));
let C430 , C431 being Int_position;
let C432 being Integer;
set D496 = ( if<0 (C430 , C432 , C428 , C429) );
assume L1937: ( C427 . ( DataLoc (( C427 . C430 ) , C432) ) ) >= ( 0 );
L1938: (not C431 in ( dom ( Start-At (( ( ( card C428 ) + ( card C429 ) ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1939: (C429 is_closed_on C427 , R14 & C429 is_halting_on C427 , R14) by L43 , L55;
L1940: ( IExec (D496 , R14 , ( Initialize C427 )) ) = ( ( IExec (C429 , R14 , ( Initialize C427 )) ) +* ( Start-At (( ( ( card C428 ) + ( card C429 ) ) + 2 ) , ( SCMPDS )) ) ) by L1939 , L1937 , L1848;
thus L1941: thesis by L1940 , L1938 , FUNCT_4:11;
end;
begin
theorem
L1942: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( card ( if<0 (R3 , R9 , R11) ) ) = ( ( card R11 ) + 1 )))) by L3;
theorem
L1943: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( 0 ) in ( dom ( if<0 (R3 , R9 , R11) ) ))))
proof
let R3 being Int_position;
let R9 being Integer;
let R11 being (Program of ( SCMPDS ));
set D497 = ( card ( if<0 (R3 , R9 , R11) ) );
L1944: D497 = ( ( card R11 ) + 1 ) by L3;
thus L1945: thesis by L1944 , AFINSQ_1:66;
end;
theorem
L1946: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( ( if<0 (R3 , R9 , R11) ) . ( 0 ) ) = ( (R3 , R9) >=0_goto ( ( card R11 ) + 1 ) )))) by L5;
theorem
L1947: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B320 being (State of ( SCMPDS )) holds (for B321 being  shiftable (Program of ( SCMPDS )) holds (for B322 being Int_position holds (for B323 being Integer holds ((( B320 . ( DataLoc (( B320 . B322 ) , B323) ) ) < ( 0 ) & B321 is_closed_on B320 , R14 & B321 is_halting_on B320 , R14) implies (( if<0 (B322 , B323 , B321) ) is_closed_on B320 , R14 & ( if<0 (B322 , B323 , B321) ) is_halting_on B320 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C433 being (State of ( SCMPDS ));
let C434 being  shiftable (Program of ( SCMPDS ));
let C435 being Int_position;
let C436 being Integer;
set D498 = ( DataLoc (( C433 . C435 ) , C436) );
set D499 = ( if<0 (C435 , C436 , C434) );
set D500 = ( stop D499 );
set D501 = ( stop C434 );
set D502 = ( Initialize C433 );
set D503 = ( Initialize C433 );
set D504 = ( R14 +* D501 );
set D505 = ( R14 +* D500 );
set D506 = ( Comput (D505 , D503 , 1) );
set D507 = D505;
set D508 = ( (C435 , C436) >=0_goto ( ( card C434 ) + 1 ) );
L1948: ( stop C434 ) c= D504 by FUNCT_4:25;
L1949: ( 0 ) in ( dom D500 ) by COMPOS_1:36;
L1950: ( IC D503 ) = ( 0 ) by MEMSTR_0:47;
L1951: (not D498 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1952: (not C435 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1953: ( D503 . ( DataLoc (( D503 . C435 ) , C436) ) ) = ( D503 . D498 ) by L1952 , FUNCT_4:11
.= ( C433 . D498 ) by L1951 , FUNCT_4:11;
L1954: ( Comput (D505 , D503 , ( ( 0 ) + 1 )) ) = ( Following (D505 , ( Comput (D505 , D503 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D505 , D503) ) by EXTPRO_1:2
.= ( Exec (D508 , D503) ) by L8;
L1955: (for R3 being Int_position holds ( D502 . R3 ) = ( D506 . R3 )) by L1954 , SCMPDS_2:57;
L1956: ( DataPart D502 ) = ( DataPart D506 ) by L1955 , SCMPDS_4:8;
assume L1957: ( C433 . D498 ) < ( 0 );
L1958: ( IC D506 ) = ( succ ( IC D503 ) ) by L1957 , L1954 , L1953 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L1950;
assume L1959: C434 is_closed_on C433 , R14;
L1960: C434 is_closed_on D502 , D504 by L1959 , L143;
assume L1961: C434 is_halting_on C433 , R14;
L1962: D504 halts_on D502 by L1961 , L41;
L1963: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D502 & ( Shift (D501 , 1) ) c= D507) by L436 , FUNCT_4:25;
L1964: ( card D500 ) = ( ( card D499 ) + 1 ) by COMPOS_1:55
.= ( ( ( card C434 ) + 1 ) + 1 ) by L3;
L1965:
now
let C437 being (Element of ( NAT ));
per cases ;
suppose L1966: ( 0 ) < C437;

consider C438 being Nat such that L1967: ( C438 + 1 ) = C437 by L1966 , NAT_1:6;
reconsider D509 = C438 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D510 = ( IC ( Comput (D504 , D502 , D509) ) ) as (Element of ( NAT ));
L1968: ( card D500 ) = ( ( card D501 ) + 1 ) by L1964 , COMPOS_1:55;
L1969: D510 in ( dom D501 ) by L1959 , L40;
L1970: D510 < ( card D501 ) by L1969 , AFINSQ_1:66;
L1971: ( D510 + 1 ) < ( card D500 ) by L1970 , L1968 , XREAL_1:6;
L1972: ( IC ( Comput (D505 , D503 , C437) ) ) = ( IC ( Comput (D505 , D506 , D509) ) ) by L1967 , EXTPRO_1:4
.= ( D510 + 1 ) by L1960 , L1963 , L1958 , L1956 , L360 , L1948;
thus L1973: ( IC ( Comput (D505 , D503 , C437) ) ) in ( dom D500 ) by L1972 , L1971 , AFINSQ_1:66;
end;
suppose L1974: C437 = ( 0 );

thus L1975: ( IC ( Comput (D505 , D503 , C437) ) ) in ( dom D500 ) by L1974 , L1949 , L1950 , EXTPRO_1:2;
end;
end;
thus L1977: D499 is_closed_on C433 , R14 by L1965 , L40;
L1978: ( Comput (D505 , D503 , ( ( LifeSpan (D504 , D502) ) + 1 )) ) = ( Comput (D505 , ( Comput (D505 , D503 , 1) ) , ( LifeSpan (D504 , D502) )) ) by EXTPRO_1:4;
L1979: ( CurInstr (D505 , ( Comput (D505 , D503 , ( ( LifeSpan (D504 , D502) ) + 1 )) )) ) = ( CurInstr (D505 , ( Comput (D505 , D506 , ( LifeSpan (D504 , D502) )) )) ) by L1978
.= ( CurInstr (D504 , ( Comput (D504 , D502 , ( LifeSpan (D504 , D502) )) )) ) by L1960 , L1963 , L1958 , L1956 , L360 , L1948
.= ( halt ( SCMPDS ) ) by L1962 , EXTPRO_1:def 15;
L1980: D505 halts_on D503 by L1979 , EXTPRO_1:29;
thus L1981: thesis by L1980 , L41;
end;
theorem
L1982: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B324 being (State of ( SCMPDS )) holds (for B325 being (Program of ( SCMPDS )) holds (for B326 being Int_position holds (for B327 being Integer holds (( B324 . ( DataLoc (( B324 . B326 ) , B327) ) ) >= ( 0 ) implies (( if<0 (B326 , B327 , B325) ) is_closed_on B324 , R14 & ( if<0 (B326 , B327 , B325) ) is_halting_on B324 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C439 being (State of ( SCMPDS ));
let C440 being (Program of ( SCMPDS ));
let C441 being Int_position;
let C442 being Integer;
set D511 = ( DataLoc (( C439 . C441 ) , C442) );
assume L1983: ( C439 . D511 ) >= ( 0 );
set D512 = ( (C441 , C442) >=0_goto ( ( card C440 ) + 1 ) );
set D513 = ( if<0 (C441 , C442 , C440) );
set D514 = ( stop D513 );
set D515 = ( Initialize C439 );
set D516 = ( R14 +* D514 );
set D517 = ( Comput (D516 , D515 , 1) );
set D518 = D516;
L1984: ( IC D515 ) = ( 0 ) by MEMSTR_0:47;
L1985: (not D511 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1986: (not C441 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L1987: ( D515 . ( DataLoc (( D515 . C441 ) , C442) ) ) = ( D515 . D511 ) by L1986 , FUNCT_4:11
.= ( C439 . D511 ) by L1985 , FUNCT_4:11;
L1988: ( Comput (D516 , D515 , ( ( 0 ) + 1 )) ) = ( Following (D516 , ( Comput (D516 , D515 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D516 , D515) ) by EXTPRO_1:2
.= ( Exec (D512 , D515) ) by L8;
L1989: ( IC D517 ) = ( ICplusConst (D515 , ( ( card C440 ) + 1 )) ) by L1988 , L1983 , L1987 , SCMPDS_2:57
.= ( ( 0 ) + ( ( card C440 ) + 1 ) ) by L1984 , L18;
L1990: ( card D513 ) = ( ( card C440 ) + 1 ) by L3;
L1991: ( ( card C440 ) + 1 ) in ( dom D514 ) by L1990 , COMPOS_1:64;
L1992: ( D516 /. ( IC D517 ) ) = ( D516 . ( IC D517 ) ) by PBOOLE:143;
L1993: D514 c= D516 by FUNCT_4:25;
L1994: D514 c= D518 by L1993;
L1995: ( D518 . ( ( card C440 ) + 1 ) ) = ( D514 . ( ( card C440 ) + 1 ) ) by L1994 , L1991 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L1990 , COMPOS_1:64;
L1996: ( CurInstr (D516 , D517) ) = ( halt ( SCMPDS ) ) by L1995 , L1989 , L1992;
L1997:
now
let C443 being (Element of ( NAT ));
per cases ;
suppose L1998: ( 0 ) < C443;

L1999: ( 1 + ( 0 ) ) <= C443 by L1998 , INT_1:7;
thus L2000: ( IC ( Comput (D516 , D515 , C443) ) ) in ( dom D514 ) by L1999 , L1991 , L1989 , L1996 , EXTPRO_1:5;
end;
suppose L2001: C443 = ( 0 );

L2002: ( Comput (D516 , D515 , C443) ) = D515 by L2001 , EXTPRO_1:2;
thus L2003: ( IC ( Comput (D516 , D515 , C443) ) ) in ( dom D514 ) by L2002 , L1984 , COMPOS_1:36;
end;
end;
thus L2005: D513 is_closed_on C439 , R14 by L1997 , L40;
L2006: D516 halts_on D515 by L1996 , EXTPRO_1:29;
thus L2007: thesis by L2006 , L41;
end;
theorem
L2008: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B328 being (State of ( SCMPDS )) holds (for B329 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B330 being Int_position holds (for B331 being Integer holds ((( B328 . ( DataLoc (( B328 . B330 ) , B331) ) ) < ( 0 ) & B329 is_closed_on B328 , R14 & B329 is_halting_on B328 , R14) implies ( IExec (( if<0 (B330 , B331 , B329) ) , R14 , ( Initialize B328 )) ) = ( ( IExec (B329 , R14 , ( Initialize B328 )) ) +* ( Start-At (( ( card B329 ) + 1 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C444 being (State of ( SCMPDS ));
let C445 being  halt-free  shiftable (Program of ( SCMPDS ));
let C446 being Int_position;
let C447 being Integer;
set D519 = ( DataLoc (( C444 . C446 ) , C447) );
set D520 = ( if<0 (C446 , C447 , C445) );
set D521 = ( stop D520 );
set D522 = ( stop C445 );
set D523 = ( Initialize C444 );
set D524 = ( Initialize C444 );
set D525 = ( R14 +* D522 );
set D526 = ( R14 +* D521 );
set D527 = ( Comput (D526 , D524 , 1) );
set D528 = D526;
set D529 = ( (C446 , C447) >=0_goto ( ( card C445 ) + 1 ) );
set D530 = ( Start-At (( ( card C445 ) + 1 ) , ( SCMPDS )) );
L2009: ( stop C445 ) c= D525 by FUNCT_4:25;
L2010: ( IC D524 ) = ( 0 ) by MEMSTR_0:47;
L2011: (not D519 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2012: (not C446 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2013: ( D524 . ( DataLoc (( D524 . C446 ) , C447) ) ) = ( D524 . D519 ) by L2012 , FUNCT_4:11
.= ( C444 . D519 ) by L2011 , FUNCT_4:11;
L2014: ( Comput (D526 , D524 , ( ( 0 ) + 1 )) ) = ( Following (D526 , ( Comput (D526 , D524 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D526 , D524) ) by EXTPRO_1:2
.= ( Exec (D529 , D524) ) by L8;
assume L2015: ( C444 . D519 ) < ( 0 );
L2016: ( IC D527 ) = ( succ ( IC D524 ) ) by L2015 , L2014 , L2013 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L2010;
L2017: (for R3 being Int_position holds ( D523 . R3 ) = ( D527 . R3 )) by L2014 , SCMPDS_2:57;
L2018: ( DataPart D523 ) = ( DataPart D527 ) by L2017 , SCMPDS_4:8;
assume L2019: C445 is_closed_on C444 , R14;
L2020: C445 is_closed_on D523 , D525 by L2019 , L143;
L2021: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D523 & ( Shift (D522 , 1) ) c= D528) by L436 , FUNCT_4:25;
assume L2022: C445 is_halting_on C444 , R14;
L2023: D525 halts_on D523 by L2022 , L41;
L2024: ( Comput (D526 , D524 , ( ( LifeSpan (D525 , D523) ) + 1 )) ) = ( Comput (D526 , ( Comput (D526 , D524 , 1) ) , ( LifeSpan (D525 , D523) )) ) by EXTPRO_1:4;
L2025: ( CurInstr (D526 , ( Comput (D526 , D524 , ( ( LifeSpan (D525 , D523) ) + 1 )) )) ) = ( CurInstr (D526 , ( Comput (D526 , D527 , ( LifeSpan (D525 , D523) )) )) ) by L2024
.= ( CurInstr (D525 , ( Comput (D525 , D523 , ( LifeSpan (D525 , D523) )) )) ) by L2020 , L2021 , L2016 , L2018 , L360 , L2009
.= ( halt ( SCMPDS ) ) by L2023 , EXTPRO_1:def 15;
L2026: D526 halts_on D524 by L2025 , EXTPRO_1:29;
L2027: ( CurInstr (D526 , D524) ) = D529 by L8;
L2028:
now
let C448 being (Element of ( NAT ));
assume L2029: C448 < ( ( LifeSpan (D525 , D523) ) + 1 );
L2030: ( Comput (D526 , D524 , ( 0 )) ) = D524 by EXTPRO_1:2;
per cases ;
suppose L2031: C448 = ( 0 );

L2032: ( CurInstr (D526 , ( Comput (D526 , D524 , C448) )) ) = ( CurInstr (D526 , D524) ) by L2031 , L2030;
thus L2033: ( CurInstr (D526 , ( Comput (D526 , D524 , C448) )) ) <> ( halt ( SCMPDS ) ) by L2032 , L2027;
end;
suppose L2034: C448 <> ( 0 );

consider C449 being Nat such that L2035: C448 = ( C449 + 1 ) by L2034 , NAT_1:6;
reconsider D531 = C449 as (Element of ( NAT )) by ORDINAL1:def 12;
L2036: D531 < ( LifeSpan (D525 , D523) ) by L2029 , L2035 , XREAL_1:6;
assume L2037: ( CurInstr (D526 , ( Comput (D526 , D524 , C448) )) ) = ( halt ( SCMPDS ) );
L2038: ( Comput (D526 , D524 , ( D531 + 1 )) ) = ( Comput (D526 , ( Comput (D526 , D524 , 1) ) , D531) ) by EXTPRO_1:4;
L2039: ( CurInstr (D525 , ( Comput (D525 , D523 , D531) )) ) = ( CurInstr (D526 , ( Comput (D526 , D527 , D531) )) ) by L2020 , L2021 , L2016 , L2018 , L360 , L2009
.= ( halt ( SCMPDS ) ) by L2035 , L2037 , L2038;
thus L2040: contradiction by L2039 , L2023 , L2036 , EXTPRO_1:def 15;
end;
end;
L2042: (for B332 being (Element of ( NAT )) holds (( CurInstr (D526 , ( Comput (D526 , D524 , B332) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D525 , D523) ) + 1 ) <= B332)) by L2028;
L2043: ( LifeSpan (D526 , D524) ) = ( ( LifeSpan (D525 , D523) ) + 1 ) by L2042 , L2025 , L2026 , EXTPRO_1:def 15;
L2044: ( DataPart ( Result (D525 , D523) ) ) = ( DataPart ( Comput (D525 , D523 , ( LifeSpan (D525 , D523) )) ) ) by L2023 , EXTPRO_1:23
.= ( DataPart ( Comput (D526 , D527 , ( LifeSpan (D525 , D523) )) ) ) by L2020 , L2021 , L2016 , L2018 , L360 , L2009
.= ( DataPart ( Comput (D526 , D524 , ( ( LifeSpan (D525 , D523) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D526 , D524) ) ) by L2026 , L2043 , EXTPRO_1:23;
L2045:
now
let C450 being set;
L2046: ( dom D530 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L2047: C450 in ( dom ( IExec (D520 , R14 , ( Initialize C444 )) ) );
per cases  by L2047 , SCMPDS_4:6;
suppose L2048: C450 is Int_position;

L2049: C450 <> ( IC ( SCMPDS ) ) by L2048 , SCMPDS_2:43;
L2050: (not C450 in ( dom D530 )) by L2049 , L2046 , TARSKI:def 1;
thus L2051: ( ( IExec (D520 , R14 , ( Initialize C444 )) ) . C450 ) = ( ( Result (D526 , D524) ) . C450 )
.= ( ( Result (D525 , D523) ) . C450 ) by L2044 , L2048 , SCMPDS_4:8
.= ( ( IExec (C445 , R14 , ( Initialize C444 )) ) . C450 )
.= ( ( ( IExec (C445 , R14 , ( Initialize C444 )) ) +* D530 ) . C450 ) by L2050 , FUNCT_4:11;
end;
suppose L2052: C450 = ( IC ( SCMPDS ) );

L2053: ( IC ( Result (D525 , D523) ) ) = ( IC ( IExec (C445 , R14 , ( Initialize C444 )) ) )
.= ( card C445 ) by L2019 , L2022 , L416;
L2054: C450 in ( dom D530 ) by L2046 , L2052 , TARSKI:def 1;
thus L2055: ( ( IExec (D520 , R14 , ( Initialize C444 )) ) . C450 ) = ( ( Result (D526 , D524) ) . C450 )
.= ( ( Comput (D526 , D524 , ( ( LifeSpan (D525 , D523) ) + 1 )) ) . C450 ) by L2026 , L2043 , EXTPRO_1:23
.= ( IC ( Comput (D526 , D527 , ( LifeSpan (D525 , D523) )) ) ) by L2052 , EXTPRO_1:4
.= ( ( IC ( Comput (D525 , D523 , ( LifeSpan (D525 , D523) )) ) ) + 1 ) by L2020 , L2021 , L2016 , L2018 , L360 , L2009
.= ( ( IC ( Result (D525 , D523) ) ) + 1 ) by L2023 , EXTPRO_1:23
.= ( IC D530 ) by L2053 , FUNCOP_1:72
.= ( ( ( IExec (C445 , R14 , ( Initialize C444 )) ) +* D530 ) . C450 ) by L2052 , L2054 , FUNCT_4:13;
end;
end;
L2057: ( dom ( IExec (D520 , R14 , ( Initialize C444 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C445 , R14 , ( Initialize C444 )) ) +* D530 ) ) by PARTFUN1:def 2;
thus L2058: thesis by L2057 , L2045 , FUNCT_1:2;
end;
theorem
L2059: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B333 being (State of ( SCMPDS )) holds (for B334 being (Program of ( SCMPDS )) holds (for B335 being Int_position holds (for B336 being Integer holds (( B333 . ( DataLoc (( B333 . B335 ) , B336) ) ) >= ( 0 ) implies ( IExec (( if<0 (B335 , B336 , B334) ) , R14 , ( Initialize B333 )) ) = ( B333 +* ( Start-At (( ( card B334 ) + 1 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C451 being (State of ( SCMPDS ));
let C452 being (Program of ( SCMPDS ));
let C453 being Int_position;
let C454 being Integer;
set D532 = ( DataLoc (( C451 . C453 ) , C454) );
set D533 = ( if<0 (C453 , C454 , C452) );
set D534 = ( stop D533 );
set D535 = ( Initialize C451 );
set D536 = ( R14 +* D534 );
set D537 = ( Comput (D536 , D535 , 1) );
set D538 = D536;
set D539 = ( (C453 , C454) >=0_goto ( ( card C452 ) + 1 ) );
set D540 = ( Start-At (( ( card C452 ) + 1 ) , ( SCMPDS )) );
L2060: ( IC D535 ) = ( 0 ) by MEMSTR_0:47;
L2061: (not D532 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2062: (not C453 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2063: ( D535 . ( DataLoc (( D535 . C453 ) , C454) ) ) = ( D535 . D532 ) by L2062 , FUNCT_4:11
.= ( C451 . D532 ) by L2061 , FUNCT_4:11;
L2064: ( Comput (D536 , D535 , ( ( 0 ) + 1 )) ) = ( Following (D536 , ( Comput (D536 , D535 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D536 , D535) ) by EXTPRO_1:2
.= ( Exec (D539 , D535) ) by L8;
assume L2065: ( C451 . D532 ) >= ( 0 );
L2066: ( IC D537 ) = ( ICplusConst (D535 , ( ( card C452 ) + 1 )) ) by L2065 , L2064 , L2063 , SCMPDS_2:57
.= ( ( 0 ) + ( ( card C452 ) + 1 ) ) by L2060 , L18;
L2067: D534 c= D536 by FUNCT_4:25;
L2068: D534 c= D538 by L2067;
L2069: ( D536 /. ( IC D537 ) ) = ( D536 . ( IC D537 ) ) by PBOOLE:143;
L2070: ( card D533 ) = ( ( card C452 ) + 1 ) by L3;
L2071: ( ( card C452 ) + 1 ) in ( dom D534 ) by L2070 , COMPOS_1:64;
L2072: ( D538 . ( ( card C452 ) + 1 ) ) = ( D534 . ( ( card C452 ) + 1 ) ) by L2071 , L2068 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L2070 , COMPOS_1:64;
L2073: ( CurInstr (D536 , D537) ) = ( halt ( SCMPDS ) ) by L2072 , L2066 , L2069;
L2074: D536 halts_on D535 by L2073 , EXTPRO_1:29;
L2075: ( CurInstr (D536 , D535) ) = D539 by L8;
L2076:
now
let C455 being (Element of ( NAT ));
L2077: ( Comput (D536 , D535 , ( 0 )) ) = D535 by EXTPRO_1:2;
assume L2078: C455 < 1;
L2079: C455 < ( 1 + ( 0 ) ) by L2078;
L2080: C455 = ( 0 ) by L2079 , NAT_1:13;
L2081: ( CurInstr (D536 , ( Comput (D536 , D535 , C455) )) ) = ( CurInstr (D536 , D535) ) by L2080 , L2077;
thus L2082: ( CurInstr (D536 , ( Comput (D536 , D535 , C455) )) ) <> ( halt ( SCMPDS ) ) by L2081 , L2075;
end;
L2083: (for B337 being (Element of ( NAT )) holds (( CurInstr (D536 , ( Comput (D536 , D535 , B337) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B337)) by L2076;
L2084: ( LifeSpan (D536 , D535) ) = 1 by L2083 , L2073 , L2074 , EXTPRO_1:def 15;
L2085: D537 = ( Result (D536 , D535) ) by L2084 , L2074 , EXTPRO_1:23;
L2086:
now
L2087: ( dom D540 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
let C456 being set;
assume L2088: C456 in ( dom ( IExec (D533 , R14 , ( Initialize C451 )) ) );
per cases  by L2088 , SCMPDS_4:6;
suppose L2089: C456 is Int_position;

L2090: C456 <> ( IC ( SCMPDS ) ) by L2089 , SCMPDS_2:43;
L2091: (not C456 in ( dom D540 )) by L2090 , L2087 , TARSKI:def 1;
L2092: (not C456 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L2089 , SCMPDS_4:18;
thus L2093: ( ( IExec (D533 , R14 , ( Initialize C451 )) ) . C456 ) = ( D537 . C456 ) by L2085
.= ( D535 . C456 ) by L2064 , L2089 , SCMPDS_2:57
.= ( C451 . C456 ) by L2092 , FUNCT_4:11
.= ( ( C451 +* D540 ) . C456 ) by L2091 , FUNCT_4:11;
end;
suppose L2094: C456 = ( IC ( SCMPDS ) );

thus L2095: ( ( IExec (D533 , R14 , ( Initialize C451 )) ) . C456 ) = ( ( card C452 ) + 1 ) by L2094 , L2066 , L2085
.= ( ( C451 +* D540 ) . C456 ) by L2094 , FUNCT_4:113;
end;
end;
L2097: ( dom ( IExec (D533 , R14 , ( Initialize C451 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C451 +* D540 ) ) by PARTFUN1:def 2;
thus L2098: thesis by L2097 , L2086 , FUNCT_1:2;
end;
registration
let C457 being  shiftable  parahalting (Program of ( SCMPDS ));
let C458 being Int_position;
let C459 being Integer;
cluster ( if<0 (C458 , C459 , C457) ) ->  shiftable  parahalting;
correctness
proof
set D541 = ( (C458 , C459) >=0_goto ( ( card C457 ) + 1 ) );
set D542 = ( if<0 (C458 , C459 , C457) );
set D543 = ( stop D542 );
thus L2099: D542 is  shiftable;
let C460 being ( 0 ) -started (State of ( SCMPDS ));
let C461 being (Instruction-Sequence of ( SCMPDS ));
L2100: ( Initialize C460 ) = C460 by MEMSTR_0:44;
assume L2101: D543 c= C461;
L2102: C461 = ( C461 +* ( stop D542 ) ) by L2101 , FUNCT_4:98;
L2103: (C457 is_closed_on C460 , C461 & C457 is_halting_on C460 , C461) by L43 , L55;
per cases ;
suppose L2104: ( C460 . ( DataLoc (( C460 . C458 ) , C459) ) ) < ( 0 );

L2105: D542 is_halting_on C460 , C461 by L2104 , L2103 , L1947;
thus L2106: C461 halts_on C460 by L2105 , L2102 , L41 , L2100;
end;
suppose L2107: ( C460 . ( DataLoc (( C460 . C458 ) , C459) ) ) >= ( 0 );

L2108: D542 is_halting_on C460 , C461 by L2107 , L1982;
thus L2109: C461 halts_on C460 by L2108 , L2102 , L41 , L2100;
end;
end;
end;
registration
let C462 being  halt-free (Program of ( SCMPDS ));
let C463 being Int_position;
let C464 being Integer;
cluster ( if<0 (C463 , C464 , C462) ) ->  halt-free;
coherence;
end;
theorem
L2113: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B338 being (State of ( SCMPDS )) holds (for B339 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B340 being Int_position holds (for B341 being Integer holds ( IC ( IExec (( if<0 (B340 , B341 , B339) ) , R14 , ( Initialize B338 )) ) ) = ( ( card B339 ) + 1 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C465 being (State of ( SCMPDS ));
let C466 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C467 being Int_position;
let C468 being Integer;
set D544 = ( if<0 (C467 , C468 , C466) );
L2114: (C466 is_closed_on C465 , R14 & C466 is_halting_on C465 , R14) by L43 , L55;
per cases ;
suppose L2115: ( C465 . ( DataLoc (( C465 . C467 ) , C468) ) ) < ( 0 );

L2116: ( IExec (D544 , R14 , ( Initialize C465 )) ) = ( ( IExec (C466 , R14 , ( Initialize C465 )) ) +* ( Start-At (( ( card C466 ) + 1 ) , ( SCMPDS )) ) ) by L2115 , L2114 , L2008;
thus L2117: thesis by L2116 , FUNCT_4:113;
end;
suppose L2118: ( C465 . ( DataLoc (( C465 . C467 ) , C468) ) ) >= ( 0 );

L2119: ( IExec (D544 , R14 , ( Initialize C465 )) ) = ( C465 +* ( Start-At (( ( card C466 ) + 1 ) , ( SCMPDS )) ) ) by L2118 , L2059;
thus L2120: thesis by L2119 , FUNCT_4:113;
end;
end;
theorem
L2122: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B342 being (State of ( SCMPDS )) holds (for B343 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B344 , B345 being Int_position holds (for B346 being Integer holds (( B342 . ( DataLoc (( B342 . B344 ) , B346) ) ) < ( 0 ) implies ( ( IExec (( if<0 (B344 , B346 , B343) ) , R14 , ( Initialize B342 )) ) . B345 ) = ( ( IExec (B343 , R14 , ( Initialize B342 )) ) . B345 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C469 being (State of ( SCMPDS ));
let C470 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C471 , C472 being Int_position;
let C473 being Integer;
assume L2123: ( C469 . ( DataLoc (( C469 . C471 ) , C473) ) ) < ( 0 );
L2124: (not C472 in ( dom ( Start-At (( ( card C470 ) + 1 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2125: (C470 is_closed_on C469 , R14 & C470 is_halting_on C469 , R14) by L43 , L55;
L2126: ( IExec (( if<0 (C471 , C473 , C470) ) , R14 , ( Initialize C469 )) ) = ( ( IExec (C470 , R14 , ( Initialize C469 )) ) +* ( Start-At (( ( card C470 ) + 1 ) , ( SCMPDS )) ) ) by L2125 , L2123 , L2008;
thus L2127: thesis by L2126 , L2124 , FUNCT_4:11;
end;
theorem
L2128: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B347 being (State of ( SCMPDS )) holds (for B348 being (Program of ( SCMPDS )) holds (for B349 , B350 being Int_position holds (for B351 being Integer holds (( B347 . ( DataLoc (( B347 . B349 ) , B351) ) ) >= ( 0 ) implies ( ( IExec (( if<0 (B349 , B351 , B348) ) , R14 , ( Initialize B347 )) ) . B350 ) = ( B347 . B350 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C474 being (State of ( SCMPDS ));
let C475 being (Program of ( SCMPDS ));
let C476 , C477 being Int_position;
let C478 being Integer;
assume L2129: ( C474 . ( DataLoc (( C474 . C476 ) , C478) ) ) >= ( 0 );
L2130: ( IExec (( if<0 (C476 , C478 , C475) ) , R14 , ( Initialize C474 )) ) = ( C474 +* ( Start-At (( ( card C475 ) + 1 ) , ( SCMPDS )) ) ) by L2129 , L2059;
L2131: (not C477 in ( dom ( Start-At (( ( card C475 ) + 1 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L2132: thesis by L2131 , L2130 , FUNCT_4:11;
end;
begin
theorem
L2133: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds ( card ( if>=0 (R3 , R9 , R11) ) ) = ( ( card R11 ) + 2 )))) by L856;
theorem
L2134: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (( 0 ) in ( dom ( if>=0 (R3 , R9 , R11) ) ) & 1 in ( dom ( if>=0 (R3 , R9 , R11) ) ))))) by L859;
theorem
L2135: (for R3 being Int_position holds (for R9 being Integer holds (for R11 being (Program of ( SCMPDS )) holds (( ( if>=0 (R3 , R9 , R11) ) . ( 0 ) ) = ( (R3 , R9) >=0_goto 2 ) & ( ( if>=0 (R3 , R9 , R11) ) . 1 ) = ( goto ( ( card R11 ) + 1 ) ))))) by L865;
theorem
L2136: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B352 being (State of ( SCMPDS )) holds (for B353 being  shiftable (Program of ( SCMPDS )) holds (for B354 being Int_position holds (for B355 being Integer holds ((( B352 . ( DataLoc (( B352 . B354 ) , B355) ) ) >= ( 0 ) & B353 is_closed_on B352 , R14 & B353 is_halting_on B352 , R14) implies (( if>=0 (B354 , B355 , B353) ) is_closed_on B352 , R14 & ( if>=0 (B354 , B355 , B353) ) is_halting_on B352 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C479 being (State of ( SCMPDS ));
let C480 being  shiftable (Program of ( SCMPDS ));
let C481 being Int_position;
let C482 being Integer;
set D545 = ( DataLoc (( C479 . C481 ) , C482) );
set D546 = ( if>=0 (C481 , C482 , C480) );
set D547 = ( stop D546 );
set D548 = ( stop C480 );
set D549 = ( Initialize C479 );
set D550 = ( Initialize C479 );
set D551 = ( R14 +* D548 );
set D552 = ( R14 +* D547 );
set D553 = ( Comput (D552 , D550 , 1) );
set D554 = D552;
set D555 = ( (C481 , C482) >=0_goto 2 );
set D556 = ( goto ( ( card C480 ) + 1 ) );
L2137: ( stop C480 ) c= D551 by FUNCT_4:25;
L2138: D546 = ( D555 ';' ( D556 ';' C480 ) ) by SCMPDS_4:16;
L2139: ( Comput (D552 , D550 , ( ( 0 ) + 1 )) ) = ( Following (D552 , ( Comput (D552 , D550 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D552 , D550) ) by EXTPRO_1:2
.= ( Exec (D555 , D550) ) by L2138 , L8;
L2140: (for R3 being Int_position holds ( D549 . R3 ) = ( D553 . R3 )) by L2139 , SCMPDS_2:57;
L2141: ( DataPart D549 ) = ( DataPart D553 ) by L2140 , SCMPDS_4:8;
L2142: (not D545 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2143: (not C481 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2144: ( D550 . ( DataLoc (( D550 . C481 ) , C482) ) ) = ( D550 . D545 ) by L2143 , FUNCT_4:11
.= ( C479 . D545 ) by L2142 , FUNCT_4:11;
L2145: ( IC D550 ) = ( 0 ) by MEMSTR_0:47;
assume L2146: ( C479 . D545 ) >= ( 0 );
L2147: ( IC D553 ) = ( ICplusConst (D550 , 2) ) by L2146 , L2139 , L2144 , SCMPDS_2:57
.= ( ( 0 ) + 2 ) by L2145 , L18;
assume L2148: C480 is_closed_on C479 , R14;
L2149: C480 is_closed_on D549 , D551 by L2148 , L143;
assume L2150: C480 is_halting_on C479 , R14;
L2151: D551 halts_on D549 by L2150 , L41;
L2152: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D549 & ( Shift (D548 , 2) ) c= D554) by L442 , FUNCT_4:25;
L2153: ( 0 ) in ( dom D547 ) by COMPOS_1:36;
L2154:
now
let C483 being (Element of ( NAT ));
per cases ;
suppose L2155: ( 0 ) < C483;

consider C484 being Nat such that L2156: ( C484 + 1 ) = C483 by L2155 , NAT_1:6;
reconsider D557 = C484 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D558 = ( IC ( Comput (D551 , D549 , D557) ) ) as (Element of ( NAT ));
L2157: ( card D547 ) = ( 1 + ( card D546 ) ) by COMPOS_1:55
.= ( 1 + ( ( card C480 ) + 2 ) ) by L856
.= ( ( 1 + ( card C480 ) ) + 2 )
.= ( ( card D548 ) + 2 ) by COMPOS_1:55;
L2158: D558 in ( dom D548 ) by L2148 , L40;
L2159: D558 < ( card D548 ) by L2158 , AFINSQ_1:66;
L2160: ( D558 + 2 ) < ( card D547 ) by L2159 , L2157 , XREAL_1:6;
L2161: ( IC ( Comput (D552 , D550 , C483) ) ) = ( IC ( Comput (D552 , D553 , D557) ) ) by L2156 , EXTPRO_1:4
.= ( D558 + 2 ) by L2149 , L2152 , L2147 , L2141 , L360 , L2137;
thus L2162: ( IC ( Comput (D552 , D550 , C483) ) ) in ( dom D547 ) by L2161 , L2160 , AFINSQ_1:66;
end;
suppose L2163: C483 = ( 0 );

thus L2164: ( IC ( Comput (D552 , D550 , C483) ) ) in ( dom D547 ) by L2163 , L2153 , L2145 , EXTPRO_1:2;
end;
end;
thus L2166: D546 is_closed_on C479 , R14 by L2154 , L40;
L2167: ( Comput (D552 , D550 , ( ( LifeSpan (D551 , D549) ) + 1 )) ) = ( Comput (D552 , ( Comput (D552 , D550 , 1) ) , ( LifeSpan (D551 , D549) )) ) by EXTPRO_1:4;
L2168: ( CurInstr (D552 , ( Comput (D552 , D550 , ( ( LifeSpan (D551 , D549) ) + 1 )) )) ) = ( CurInstr (D552 , ( Comput (D552 , D553 , ( LifeSpan (D551 , D549) )) )) ) by L2167
.= ( CurInstr (D551 , ( Comput (D551 , D549 , ( LifeSpan (D551 , D549) )) )) ) by L2149 , L2152 , L2147 , L2141 , L360 , L2137
.= ( halt ( SCMPDS ) ) by L2151 , EXTPRO_1:def 15;
L2169: D552 halts_on D550 by L2168 , EXTPRO_1:29;
thus L2170: thesis by L2169 , L41;
end;
theorem
L2171: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B356 being (State of ( SCMPDS )) holds (for B357 being (Program of ( SCMPDS )) holds (for B358 being Int_position holds (for B359 being Integer holds (( B356 . ( DataLoc (( B356 . B358 ) , B359) ) ) < ( 0 ) implies (( if>=0 (B358 , B359 , B357) ) is_closed_on B356 , R14 & ( if>=0 (B358 , B359 , B357) ) is_halting_on B356 , R14)))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C485 being (State of ( SCMPDS ));
let C486 being (Program of ( SCMPDS ));
let C487 being Int_position;
let C488 being Integer;
set D559 = ( DataLoc (( C485 . C487 ) , C488) );
assume L2172: ( C485 . D559 ) < ( 0 );
set D560 = ( (C487 , C488) >=0_goto 2 );
set D561 = ( goto ( ( card C486 ) + 1 ) );
set D562 = ( if>=0 (C487 , C488 , C486) );
set D563 = ( stop D562 );
set D564 = ( Initialize C485 );
set D565 = ( R14 +* D563 );
set D566 = ( Comput (D565 , D564 , 1) );
set D567 = ( Comput (D565 , D564 , 2) );
set D568 = D565;
set D569 = D565;
L2173: D562 = ( D560 ';' ( D561 ';' C486 ) ) by SCMPDS_4:16;
L2174: (not D559 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2175: (not C487 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2176: ( D564 . ( DataLoc (( D564 . C487 ) , C488) ) ) = ( D564 . D559 ) by L2175 , FUNCT_4:11
.= ( C485 . D559 ) by L2174 , FUNCT_4:11;
L2177: ( IC D564 ) = ( 0 ) by MEMSTR_0:47;
L2178: ( Comput (D565 , D564 , ( ( 0 ) + 1 )) ) = ( Following (D565 , ( Comput (D565 , D564 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D565 , D564) ) by EXTPRO_1:2
.= ( Exec (D560 , D564) ) by L2173 , L8;
L2179: ( IC D566 ) = ( succ ( IC D564 ) ) by L2178 , L2172 , L2176 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L2177;
L2180: D563 c= D565 by FUNCT_4:25;
L2181: D563 c= D568 by L2180;
L2182: 1 in ( dom D562 ) by L859;
L2183: 1 in ( dom D563 ) by L2182 , COMPOS_1:62;
L2184: ( D568 . 1 ) = ( D563 . 1 ) by L2183 , L2181 , GRFUNC_1:2
.= ( D562 . 1 ) by L2182 , COMPOS_1:63
.= D561 by L865;
L2185: ( card D562 ) = ( ( card C486 ) + 2 ) by L856;
L2186: ( ( card C486 ) + 2 ) in ( dom D563 ) by L2185 , COMPOS_1:64;
L2187: ( D565 /. ( IC D566 ) ) = ( D565 . ( IC D566 ) ) by PBOOLE:143;
L2188: ( Comput (D565 , D564 , ( 1 + 1 )) ) = ( Following (D565 , D566) ) by EXTPRO_1:3
.= ( Exec (D561 , D566) ) by L2179 , L2184 , L2187;
L2189: ( IC D567 ) = ( ICplusConst (D566 , ( ( card C486 ) + 1 )) ) by L2188 , SCMPDS_2:54
.= ( ( ( card C486 ) + 1 ) + 1 ) by L2179 , L18
.= ( ( card C486 ) + ( 1 + 1 ) );
L2190: ( D565 /. ( IC D567 ) ) = ( D565 . ( IC D567 ) ) by PBOOLE:143;
L2191: D563 c= D569 by L2180;
L2192: ( D569 . ( ( card C486 ) + 2 ) ) = ( D563 . ( ( card C486 ) + 2 ) ) by L2191 , L2186 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L2185 , COMPOS_1:64;
L2193: ( CurInstr (D565 , D567) ) = ( halt ( SCMPDS ) ) by L2192 , L2189 , L2190;
L2194:
now
let C489 being (Element of ( NAT ));
L2195: (C489 = ( 0 ) or ( ( 0 ) + 1 ) <= C489) by INT_1:7;
per cases  by L2195 , XXREAL_0:1;
suppose L2196: C489 = ( 0 );

L2197: ( Comput (D565 , D564 , C489) ) = D564 by L2196 , EXTPRO_1:2;
thus L2198: ( IC ( Comput (D565 , D564 , C489) ) ) in ( dom D563 ) by L2197 , L2177 , COMPOS_1:36;
end;
suppose L2199: C489 = 1;

thus L2200: ( IC ( Comput (D565 , D564 , C489) ) ) in ( dom D563 ) by L2199 , L2182 , L2179 , COMPOS_1:62;
end;
suppose L2201: 1 < C489;

L2202: ( 1 + 1 ) <= C489 by L2201 , INT_1:7;
thus L2203: ( IC ( Comput (D565 , D564 , C489) ) ) in ( dom D563 ) by L2202 , L2186 , L2189 , L2193 , EXTPRO_1:5;
end;
end;
thus L2205: D562 is_closed_on C485 , R14 by L2194 , L40;
L2206: D565 halts_on D564 by L2193 , EXTPRO_1:29;
thus L2207: thesis by L2206 , L41;
end;
theorem
L2208: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B360 being (State of ( SCMPDS )) holds (for B361 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B362 being Int_position holds (for B363 being Integer holds ((( B360 . ( DataLoc (( B360 . B362 ) , B363) ) ) >= ( 0 ) & B361 is_closed_on B360 , R14 & B361 is_halting_on B360 , R14) implies ( IExec (( if>=0 (B362 , B363 , B361) ) , R14 , ( Initialize B360 )) ) = ( ( IExec (B361 , R14 , ( Initialize B360 )) ) +* ( Start-At (( ( card B361 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C490 being (State of ( SCMPDS ));
let C491 being  halt-free  shiftable (Program of ( SCMPDS ));
let C492 being Int_position;
let C493 being Integer;
set D570 = ( DataLoc (( C490 . C492 ) , C493) );
set D571 = ( if>=0 (C492 , C493 , C491) );
set D572 = ( stop D571 );
set D573 = ( stop C491 );
set D574 = ( Initialize C490 );
set D575 = ( Initialize C490 );
set D576 = ( R14 +* D573 );
set D577 = ( R14 +* D572 );
set D578 = ( Comput (D577 , D575 , 1) );
set D579 = D577;
set D580 = ( (C492 , C493) >=0_goto 2 );
set D581 = ( goto ( ( card C491 ) + 1 ) );
set D582 = ( Start-At (( ( card C491 ) + 2 ) , ( SCMPDS )) );
L2209: D571 = ( D580 ';' ( D581 ';' C491 ) ) by SCMPDS_4:16;
L2210: ( stop C491 ) c= D576 by FUNCT_4:25;
L2211: ( Comput (D577 , D575 , ( ( 0 ) + 1 )) ) = ( Following (D577 , ( Comput (D577 , D575 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D577 , D575) ) by EXTPRO_1:2
.= ( Exec (D580 , D575) ) by L2209 , L8;
L2212: (not D570 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2213: (not C492 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2214: ( D575 . ( DataLoc (( D575 . C492 ) , C493) ) ) = ( D575 . D570 ) by L2213 , FUNCT_4:11
.= ( C490 . D570 ) by L2212 , FUNCT_4:11;
L2215: ( IC D575 ) = ( 0 ) by MEMSTR_0:47;
L2216: (( Start-At (( 0 ) , ( SCMPDS )) ) c= D574 & ( Shift (D573 , 2) ) c= D579) by L442 , FUNCT_4:25;
L2217: (for R3 being Int_position holds ( D574 . R3 ) = ( D578 . R3 )) by L2211 , SCMPDS_2:57;
L2218: ( DataPart D574 ) = ( DataPart D578 ) by L2217 , SCMPDS_4:8;
assume L2219: ( C490 . D570 ) >= ( 0 );
L2220: ( IC D578 ) = ( ICplusConst (D575 , 2) ) by L2219 , L2211 , L2214 , SCMPDS_2:57
.= ( ( 0 ) + 2 ) by L2215 , L18;
assume L2221: C491 is_closed_on C490 , R14;
L2222: C491 is_closed_on D574 , D576 by L2221 , L143;
assume L2223: C491 is_halting_on C490 , R14;
L2224: D576 halts_on D574 by L2223 , L41;
L2225: ( Comput (D577 , D575 , ( ( LifeSpan (D576 , D574) ) + 1 )) ) = ( Comput (D577 , ( Comput (D577 , D575 , 1) ) , ( LifeSpan (D576 , D574) )) ) by EXTPRO_1:4;
L2226: ( CurInstr (D577 , ( Comput (D577 , D575 , ( ( LifeSpan (D576 , D574) ) + 1 )) )) ) = ( CurInstr (D577 , ( Comput (D577 , D578 , ( LifeSpan (D576 , D574) )) )) ) by L2225
.= ( CurInstr (D576 , ( Comput (D576 , D574 , ( LifeSpan (D576 , D574) )) )) ) by L2222 , L2216 , L2220 , L2218 , L360 , L2210
.= ( halt ( SCMPDS ) ) by L2224 , EXTPRO_1:def 15;
L2227: D577 halts_on D575 by L2226 , EXTPRO_1:29;
L2228: ( CurInstr (D577 , D575) ) = D580 by L2209 , L8;
L2229:
now
let C494 being (Element of ( NAT ));
assume L2230: C494 < ( ( LifeSpan (D576 , D574) ) + 1 );
L2231: ( Comput (D577 , D575 , ( 0 )) ) = D575 by EXTPRO_1:2;
per cases ;
suppose L2232: C494 = ( 0 );

L2233: ( CurInstr (D577 , ( Comput (D577 , D575 , C494) )) ) = ( CurInstr (D577 , D575) ) by L2232 , L2231;
thus L2234: ( CurInstr (D577 , ( Comput (D577 , D575 , C494) )) ) <> ( halt ( SCMPDS ) ) by L2233 , L2228;
end;
suppose L2235: C494 <> ( 0 );

consider C495 being Nat such that L2236: C494 = ( C495 + 1 ) by L2235 , NAT_1:6;
reconsider D583 = C495 as (Element of ( NAT )) by ORDINAL1:def 12;
L2237: D583 < ( LifeSpan (D576 , D574) ) by L2230 , L2236 , XREAL_1:6;
assume L2238: ( CurInstr (D577 , ( Comput (D577 , D575 , C494) )) ) = ( halt ( SCMPDS ) );
L2239: ( Comput (D577 , D575 , ( D583 + 1 )) ) = ( Comput (D577 , ( Comput (D577 , D575 , 1) ) , D583) ) by EXTPRO_1:4;
L2240: ( CurInstr (D576 , ( Comput (D576 , D574 , D583) )) ) = ( CurInstr (D577 , ( Comput (D577 , D578 , D583) )) ) by L2222 , L2216 , L2220 , L2218 , L360 , L2210
.= ( halt ( SCMPDS ) ) by L2236 , L2238 , L2239;
thus L2241: contradiction by L2240 , L2224 , L2237 , EXTPRO_1:def 15;
end;
end;
L2243: (for B364 being (Element of ( NAT )) holds (( CurInstr (D577 , ( Comput (D577 , D575 , B364) )) ) = ( halt ( SCMPDS ) ) implies ( ( LifeSpan (D576 , D574) ) + 1 ) <= B364)) by L2229;
L2244: ( LifeSpan (D577 , D575) ) = ( ( LifeSpan (D576 , D574) ) + 1 ) by L2243 , L2226 , L2227 , EXTPRO_1:def 15;
L2245: ( DataPart ( Result (D576 , D574) ) ) = ( DataPart ( Comput (D576 , D574 , ( LifeSpan (D576 , D574) )) ) ) by L2224 , EXTPRO_1:23
.= ( DataPart ( Comput (D577 , D578 , ( LifeSpan (D576 , D574) )) ) ) by L2222 , L2216 , L2220 , L2218 , L360 , L2210
.= ( DataPart ( Comput (D577 , D575 , ( ( LifeSpan (D576 , D574) ) + 1 )) ) ) by EXTPRO_1:4
.= ( DataPart ( Result (D577 , D575) ) ) by L2227 , L2244 , EXTPRO_1:23;
L2246:
now
let C496 being set;
L2247: ( dom ( Start-At (( ( card C491 ) + 2 ) , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L2248: C496 in ( dom ( IExec (D571 , R14 , ( Initialize C490 )) ) );
per cases  by L2248 , SCMPDS_4:6;
suppose L2249: C496 is Int_position;

L2250: C496 <> ( IC ( SCMPDS ) ) by L2249 , SCMPDS_2:43;
L2251: (not C496 in ( dom D582 )) by L2250 , L2247 , TARSKI:def 1;
thus L2252: ( ( IExec (D571 , R14 , ( Initialize C490 )) ) . C496 ) = ( ( Result (D577 , D575) ) . C496 )
.= ( ( Result (D576 , D574) ) . C496 ) by L2245 , L2249 , SCMPDS_4:8
.= ( ( IExec (C491 , R14 , ( Initialize C490 )) ) . C496 )
.= ( ( ( IExec (C491 , R14 , ( Initialize C490 )) ) +* D582 ) . C496 ) by L2251 , FUNCT_4:11;
end;
suppose L2253: C496 = ( IC ( SCMPDS ) );

L2254: ( IC ( Result (D576 , D574) ) ) = ( IC ( IExec (C491 , R14 , ( Initialize C490 )) ) )
.= ( card C491 ) by L2221 , L2223 , L416;
L2255: C496 in ( dom D582 ) by L2247 , L2253 , TARSKI:def 1;
thus L2256: ( ( IExec (D571 , R14 , ( Initialize C490 )) ) . C496 ) = ( ( Result (D577 , D575) ) . C496 )
.= ( ( Comput (D577 , D575 , ( ( LifeSpan (D576 , D574) ) + 1 )) ) . C496 ) by L2227 , L2244 , EXTPRO_1:23
.= ( IC ( Comput (D577 , D578 , ( LifeSpan (D576 , D574) )) ) ) by L2253 , EXTPRO_1:4
.= ( ( IC ( Comput (D576 , D574 , ( LifeSpan (D576 , D574) )) ) ) + 2 ) by L2222 , L2216 , L2220 , L2218 , L360 , L2210
.= ( ( IC ( Result (D576 , D574) ) ) + 2 ) by L2224 , EXTPRO_1:23
.= ( IC D582 ) by L2254 , FUNCOP_1:72
.= ( ( ( IExec (C491 , R14 , ( Initialize C490 )) ) +* D582 ) . C496 ) by L2253 , L2255 , FUNCT_4:13;
end;
end;
L2258: ( dom ( IExec (D571 , R14 , ( Initialize C490 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( ( IExec (C491 , R14 , ( Initialize C490 )) ) +* ( Start-At (( ( card C491 ) + 2 ) , ( SCMPDS )) ) ) ) by PARTFUN1:def 2;
thus L2259: thesis by L2258 , L2246 , FUNCT_1:2;
end;
theorem
L2260: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B365 being (State of ( SCMPDS )) holds (for B366 being (Program of ( SCMPDS )) holds (for B367 being Int_position holds (for B368 being Integer holds (( B365 . ( DataLoc (( B365 . B367 ) , B368) ) ) < ( 0 ) implies ( IExec (( if>=0 (B367 , B368 , B366) ) , R14 , ( Initialize B365 )) ) = ( B365 +* ( Start-At (( ( card B366 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C497 being (State of ( SCMPDS ));
let C498 being (Program of ( SCMPDS ));
let C499 being Int_position;
let C500 being Integer;
set D584 = ( DataLoc (( C497 . C499 ) , C500) );
set D585 = ( if>=0 (C499 , C500 , C498) );
set D586 = ( stop D585 );
set D587 = ( Initialize C497 );
set D588 = ( R14 +* D586 );
set D589 = ( Comput (D588 , D587 , 1) );
set D590 = ( Comput (D588 , D587 , 2) );
set D591 = D588;
set D592 = D588;
set D593 = ( (C499 , C500) >=0_goto 2 );
set D594 = ( goto ( ( card C498 ) + 1 ) );
set D595 = ( Start-At (( ( card C498 ) + 2 ) , ( SCMPDS )) );
L2261: D585 = ( D593 ';' ( D594 ';' C498 ) ) by SCMPDS_4:16;
L2262: (not D584 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2263: (not C499 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2264: ( D587 . ( DataLoc (( D587 . C499 ) , C500) ) ) = ( D587 . D584 ) by L2263 , FUNCT_4:11
.= ( C497 . D584 ) by L2262 , FUNCT_4:11;
L2265: ( IC D587 ) = ( 0 ) by MEMSTR_0:47;
L2266: D586 c= D588 by FUNCT_4:25;
L2267: D586 c= D591 by L2266;
L2268: D586 c= D592 by L2266;
L2269: ( Comput (D588 , D587 , ( ( 0 ) + 1 )) ) = ( Following (D588 , ( Comput (D588 , D587 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D588 , D587) ) by EXTPRO_1:2
.= ( Exec (D593 , D587) ) by L2261 , L8;
assume L2270: ( C497 . D584 ) < ( 0 );
L2271: ( IC D589 ) = ( succ ( IC D587 ) ) by L2270 , L2269 , L2264 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L2265;
L2272: 1 in ( dom D585 ) by L859;
L2273: 1 in ( dom D586 ) by L2272 , COMPOS_1:62;
L2274: ( D591 . 1 ) = ( D586 . 1 ) by L2273 , L2267 , GRFUNC_1:2
.= ( D585 . 1 ) by L2272 , COMPOS_1:63
.= D594 by L865;
L2275: ( D588 /. ( IC D589 ) ) = ( D588 . ( IC D589 ) ) by PBOOLE:143;
L2276: ( Comput (D588 , D587 , ( 1 + 1 )) ) = ( Following (D588 , D589) ) by EXTPRO_1:3
.= ( Exec (D594 , D589) ) by L2271 , L2274 , L2275;
L2277: ( IC D590 ) = ( ICplusConst (D589 , ( ( card C498 ) + 1 )) ) by L2276 , SCMPDS_2:54
.= ( ( ( card C498 ) + 1 ) + 1 ) by L2271 , L18
.= ( ( card C498 ) + ( 1 + 1 ) );
L2278: ( D588 /. ( IC D590 ) ) = ( D588 . ( IC D590 ) ) by PBOOLE:143;
L2279: ( card D585 ) = ( ( card C498 ) + 2 ) by L856;
L2280: ( ( card C498 ) + 2 ) in ( dom D586 ) by L2279 , COMPOS_1:64;
L2281: ( D592 . ( ( card C498 ) + 2 ) ) = ( D586 . ( ( card C498 ) + 2 ) ) by L2280 , L2268 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L2279 , COMPOS_1:64;
L2282: ( CurInstr (D588 , D590) ) = ( halt ( SCMPDS ) ) by L2281 , L2277 , L2278;
L2283: D588 halts_on D587 by L2282 , EXTPRO_1:29;
L2284: ( CurInstr (D588 , D587) ) = D593 by L2261 , L8;
L2285:
now
let C501 being (Element of ( NAT ));
assume L2286: C501 < ( 1 + 1 );
L2287: C501 <= 1 by L2286 , NAT_1:13;
L2288: ( Comput (D588 , D587 , ( 0 )) ) = D587 by EXTPRO_1:2;
L2289: ( D588 /. ( IC ( Comput (D588 , D587 , C501) ) ) ) = ( D588 . ( IC ( Comput (D588 , D587 , C501) ) ) ) by PBOOLE:143;
per cases  by L2287 , NAT_1:25;
suppose L2290: C501 = ( 0 );

L2291: ( CurInstr (D588 , ( Comput (D588 , D587 , C501) )) ) = ( CurInstr (D588 , D587) ) by L2290 , L2288;
thus L2292: ( CurInstr (D588 , ( Comput (D588 , D587 , C501) )) ) <> ( halt ( SCMPDS ) ) by L2291 , L2284;
end;
suppose L2293: C501 = 1;

thus L2294: ( CurInstr (D588 , ( Comput (D588 , D587 , C501) )) ) <> ( halt ( SCMPDS ) ) by L2293 , L2271 , L2274 , L2289;
end;
end;
L2296: (for B369 being (Element of ( NAT )) holds (( CurInstr (D588 , ( Comput (D588 , D587 , B369) )) ) = ( halt ( SCMPDS ) ) implies 2 <= B369)) by L2285;
L2297: ( LifeSpan (D588 , D587) ) = 2 by L2296 , L2282 , L2283 , EXTPRO_1:def 15;
L2298: D590 = ( Result (D588 , D587) ) by L2297 , L2283 , EXTPRO_1:23;
L2299:
now
L2300: ( dom D595 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
let C502 being set;
assume L2301: C502 in ( dom ( IExec (D585 , R14 , ( Initialize C497 )) ) );
per cases  by L2301 , SCMPDS_4:6;
suppose L2302: C502 is Int_position;

L2303: C502 <> ( IC ( SCMPDS ) ) by L2302 , SCMPDS_2:43;
L2304: (not C502 in ( dom D595 )) by L2303 , L2300 , TARSKI:def 1;
L2305: (not C502 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by L2302 , SCMPDS_4:18;
thus L2306: ( ( IExec (D585 , R14 , ( Initialize C497 )) ) . C502 ) = ( D590 . C502 ) by L2298
.= ( D589 . C502 ) by L2276 , L2302 , SCMPDS_2:54
.= ( D587 . C502 ) by L2269 , L2302 , SCMPDS_2:57
.= ( C497 . C502 ) by L2305 , FUNCT_4:11
.= ( ( C497 +* D595 ) . C502 ) by L2304 , FUNCT_4:11;
end;
suppose L2307: C502 = ( IC ( SCMPDS ) );

thus L2308: ( ( IExec (D585 , R14 , ( Initialize C497 )) ) . C502 ) = ( ( card C498 ) + 2 ) by L2307 , L2277 , L2298
.= ( ( C497 +* ( Start-At (( ( card C498 ) + 2 ) , ( SCMPDS )) ) ) . C502 ) by L2307 , FUNCT_4:113;
end;
end;
L2310: ( dom ( IExec (D585 , R14 , ( Initialize C497 )) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C497 +* D595 ) ) by PARTFUN1:def 2;
thus L2311: thesis by L2310 , L2299 , FUNCT_1:2;
end;
registration
let C503 being  shiftable  parahalting (Program of ( SCMPDS ));
let C504 being Int_position;
let C505 being Integer;
cluster ( if>=0 (C504 , C505 , C503) ) ->  shiftable  parahalting;
correctness
proof
set D596 = ( (C504 , C505) >=0_goto 2 );
set D597 = ( goto ( ( card C503 ) + 1 ) );
set D598 = ( if>=0 (C504 , C505 , C503) );
set D599 = ( stop D598 );
thus L2312: D598 is  shiftable;
let C506 being ( 0 ) -started (State of ( SCMPDS ));
let C507 being (Instruction-Sequence of ( SCMPDS ));
L2313: ( Initialize C506 ) = C506 by MEMSTR_0:44;
assume L2314: D599 c= C507;
L2315: C507 = ( C507 +* ( stop D598 ) ) by L2314 , FUNCT_4:98;
L2316: (C503 is_closed_on C506 , C507 & C503 is_halting_on C506 , C507) by L43 , L55;
per cases ;
suppose L2317: ( C506 . ( DataLoc (( C506 . C504 ) , C505) ) ) >= ( 0 );

L2318: D598 is_halting_on C506 , C507 by L2317 , L2316 , L2136;
thus L2319: C507 halts_on C506 by L2318 , L2315 , L41 , L2313;
end;
suppose L2320: ( C506 . ( DataLoc (( C506 . C504 ) , C505) ) ) < ( 0 );

L2321: D598 is_halting_on C506 , C507 by L2320 , L2171;
thus L2322: C507 halts_on C506 by L2321 , L2315 , L41 , L2313;
end;
end;
end;
registration
let C508 being  halt-free (Program of ( SCMPDS ));
let C509 being Int_position;
let C510 being Integer;
cluster ( if>=0 (C509 , C510 , C508) ) ->  halt-free;
coherence;
end;
theorem
L2326: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B370 being ( 0 ) -started (State of ( SCMPDS )) holds (for B371 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B372 being Int_position holds (for B373 being Integer holds ( IC ( IExec (( if>=0 (B372 , B373 , B371) ) , R14 , B370) ) ) = ( ( card B371 ) + 2 ))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C511 being ( 0 ) -started (State of ( SCMPDS ));
let C512 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C513 being Int_position;
let C514 being Integer;
set D600 = ( if>=0 (C513 , C514 , C512) );
L2327: (C512 is_closed_on C511 , R14 & C512 is_halting_on C511 , R14) by L43 , L55;
L2328: ( Initialize C511 ) = C511 by MEMSTR_0:44;
per cases ;
suppose L2329: ( C511 . ( DataLoc (( C511 . C513 ) , C514) ) ) >= ( 0 );

L2330: ( IExec (D600 , R14 , C511) ) = ( ( IExec (C512 , R14 , C511) ) +* ( Start-At (( ( card C512 ) + 2 ) , ( SCMPDS )) ) ) by L2329 , L2327 , L2208 , L2328;
thus L2331: thesis by L2330 , FUNCT_4:113;
end;
suppose L2332: ( C511 . ( DataLoc (( C511 . C513 ) , C514) ) ) < ( 0 );

L2333: ( IExec (D600 , R14 , C511) ) = ( C511 +* ( Start-At (( ( card C512 ) + 2 ) , ( SCMPDS )) ) ) by L2332 , L2260 , L2328;
thus L2334: thesis by L2333 , FUNCT_4:113;
end;
end;
theorem
L2336: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B374 being (State of ( SCMPDS )) holds (for B375 being  halt-free  shiftable  parahalting (Program of ( SCMPDS )) holds (for B376 , B377 being Int_position holds (for B378 being Integer holds (( B374 . ( DataLoc (( B374 . B376 ) , B378) ) ) >= ( 0 ) implies ( ( IExec (( if>=0 (B376 , B378 , B375) ) , R14 , ( Initialize B374 )) ) . B377 ) = ( ( IExec (B375 , R14 , ( Initialize B374 )) ) . B377 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C515 being (State of ( SCMPDS ));
let C516 being  halt-free  shiftable  parahalting (Program of ( SCMPDS ));
let C517 , C518 being Int_position;
let C519 being Integer;
assume L2337: ( C515 . ( DataLoc (( C515 . C517 ) , C519) ) ) >= ( 0 );
L2338: (not C518 in ( dom ( Start-At (( ( card C516 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L2339: (C516 is_closed_on C515 , R14 & C516 is_halting_on C515 , R14) by L43 , L55;
L2340: ( IExec (( if>=0 (C517 , C519 , C516) ) , R14 , ( Initialize C515 )) ) = ( ( IExec (C516 , R14 , ( Initialize C515 )) ) +* ( Start-At (( ( card C516 ) + 2 ) , ( SCMPDS )) ) ) by L2339 , L2337 , L2208;
thus L2341: thesis by L2340 , L2338 , FUNCT_4:11;
end;
theorem
L2342: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B379 being (State of ( SCMPDS )) holds (for B380 being (Program of ( SCMPDS )) holds (for B381 , B382 being Int_position holds (for B383 being Integer holds (( B379 . ( DataLoc (( B379 . B381 ) , B383) ) ) < ( 0 ) implies ( ( IExec (( if>=0 (B381 , B383 , B380) ) , R14 , ( Initialize B379 )) ) . B382 ) = ( B379 . B382 )))))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C520 being (State of ( SCMPDS ));
let C521 being (Program of ( SCMPDS ));
let C522 , C523 being Int_position;
let C524 being Integer;
assume L2343: ( C520 . ( DataLoc (( C520 . C522 ) , C524) ) ) < ( 0 );
L2344: ( IExec (( if>=0 (C522 , C524 , C521) ) , R14 , ( Initialize C520 )) ) = ( C520 +* ( Start-At (( ( card C521 ) + 2 ) , ( SCMPDS )) ) ) by L2343 , L2260;
L2345: (not C523 in ( dom ( Start-At (( ( card C521 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L2346: thesis by L2345 , L2344 , FUNCT_4:11;
end;
theorem
L2347: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B384 being (State of ( SCMPDS )) holds (for B385 being (Program of ( SCMPDS )) holds (B385 is_closed_on B384 , R14 iff B385 is_closed_on ( Initialize B384 ) , R14))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C525 being (State of ( SCMPDS ));
let C526 being (Program of ( SCMPDS ));
thus L2348: (C526 is_closed_on C525 , R14 implies C526 is_closed_on ( Initialize C525 ) , R14)
proof
assume L2349: (for B386 being (Element of ( NAT )) holds ( IC ( Comput (( R14 +* ( stop C526 ) ) , ( Initialize C525 ) , B386) ) ) in ( dom ( stop C526 ) ));
thus L2350: (for B387 being (Element of ( NAT )) holds ( IC ( Comput (( R14 +* ( stop C526 ) ) , ( Initialize ( Initialize C525 ) ) , B387) ) ) in ( dom ( stop C526 ) )) by L2349;
end;

assume L2351: (for B388 being (Element of ( NAT )) holds ( IC ( Comput (( R14 +* ( stop C526 ) ) , ( Initialize ( Initialize C525 ) ) , B388) ) ) in ( dom ( stop C526 ) ));
thus L2352: (for B389 being (Element of ( NAT )) holds ( IC ( Comput (( R14 +* ( stop C526 ) ) , ( Initialize C525 ) , B389) ) ) in ( dom ( stop C526 ) )) by L2351;
end;
theorem
L2353: (for R14 being (Instruction-Sequence of ( SCMPDS )) holds (for B390 being (State of ( SCMPDS )) holds (for B391 being (Program of ( SCMPDS )) holds (B391 is_halting_on B390 , R14 iff B391 is_halting_on ( Initialize B390 ) , R14))))
proof
let R14 being (Instruction-Sequence of ( SCMPDS ));
let C527 being (State of ( SCMPDS ));
let C528 being (Program of ( SCMPDS ));
thus L2354: (C528 is_halting_on C527 , R14 implies C528 is_halting_on ( Initialize C527 ) , R14)
proof
assume L2355: ( R14 +* ( stop C528 ) ) halts_on ( Initialize C527 );
thus L2356: ( R14 +* ( stop C528 ) ) halts_on ( Initialize ( Initialize C527 ) ) by L2355;
end;

assume L2357: ( R14 +* ( stop C528 ) ) halts_on ( Initialize ( Initialize C527 ) );
thus L2358: ( R14 +* ( stop C528 ) ) halts_on ( Initialize C527 ) by L2357;
end;
