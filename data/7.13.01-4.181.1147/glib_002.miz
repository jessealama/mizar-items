:: Trees: Connected, Acyclic Graphs
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSET_1, ARYTM_3, CARD_1, SUBSET_1, XBOOLE_0, GLIB_000,
      RELAT_2, GLIB_001, TREES_1, ZFMISC_1, FUNCT_1, FINSEQ_1, GRAPH_1, ABIAN,
      XXREAL_0, RELAT_1, RCOMP_1, FUNCOP_1, ARYTM_1, WAYBEL_0, TARSKI, PBOOLE,
      SETFAM_1, ORDINAL1, NAT_1, GLIB_002;
 notations TARSKI, XBOOLE_0, CARD_1, NUMBERS, SUBSET_1, SETFAM_1, DOMAIN_1,
      XCMPLX_0, ABIAN, XXREAL_0, RELAT_1, FUNCT_1, PBOOLE, FUNCT_2, FINSEQ_1,
      ORDINAL1, NAT_1, FUNCOP_1, GLIB_000, GLIB_001;
 constructors DOMAIN_1, CARD_FIL, GLIB_001, VALUED_1, XXREAL_2, WELLORD2,
      RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XREAL_0, INT_1, CARD_1, GLIB_000, ABIAN, GLIB_001, FUNCT_2,
      PARTFUN1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, FUNCOP_1;
 theorems CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_3, FUNCT_1, FUNCT_2,
      GLIB_000, GLIB_001, ABIAN, INT_1, JORDAN12, NAT_1, ORDINAL1, PENCIL_1,
      TARSKI, XBOOLE_0, XBOOLE_1, XCMPLX_1, ZFMISC_1, XREAL_1, XXREAL_0,
      RELSET_1;
 schemes NAT_1, SUBSET_1, GLIB_000;

begin
definition
let C1 being _Graph;
attr C1 is  connected
means
:L1: (for B1 , B2 being (Vertex of C1) holds (ex B3 being (Walk of C1) st B3 is_Walk_from B1 , B2));
end;
definition
let C2 being _Graph;
attr C2 is  acyclic
means
:L3: (not (ex B4 being (Walk of C2) st B4 is  Cycle-like));
end;
definition
let C3 being _Graph;
attr C3 is  Tree-like
means
:L5: (C3 is  acyclic & C3 is  connected);
end;
registration
cluster  trivial ->  connected for _Graph;
coherence
proof
let C4 being _Graph;
assume L7: C4 is  trivial;
consider C5 being (Vertex of C4) such that L8: ( the_Vertices_of C4 ) = { C5 } by L7 , GLIB_000:22;
L9:
now
set D1 = ( C4 .walkOf C5 );
let C6 , C7 being (Vertex of C4);
L10: (C6 = C5 & C7 = C5) by L8 , TARSKI:def 1;
L11: D1 is_Walk_from C6 , C7 by L10 , GLIB_001:13;
thus L12: (ex B5 being (Walk of C4) st B5 is_Walk_from C6 , C7) by L11;
end;
thus L13: thesis by L9 , L1;
end;
end;
registration
cluster  trivial  loopless ->  Tree-like for _Graph;
coherence
proof
let C8 being _Graph;
assume that
L15: C8 is  trivial
and
L16: C8 is  loopless;
L17:
now
given C9 being (Walk of C8) such that
L18: C9 is  Cycle-like;

L19: ( C9 .edges() ) <> ( {} ) by L18 , GLIB_001:136;
L20: (ex B6 being set st B6 in ( C9 .edges() )) by L19 , XBOOLE_0:def 1;
thus L21: contradiction by L20 , L15 , L16 , GLIB_000:23;
end;
L22: C8 is  acyclic by L17 , L3;
reconsider D2 = C8 as  trivial _Graph by L15;
L23: D2 is  connected;
thus L24: thesis by L23 , L22 , L5;
end;
end;
registration
cluster  acyclic ->  simple for _Graph;
coherence
proof
let C10 being _Graph;
assume L26: (not (ex B7 being (Walk of C10) st B7 is  Cycle-like));
L27:
now
given C11 being set such that
L28: C11 in ( the_Edges_of C10 )
and
L29: ( ( the_Source_of C10 ) . C11 ) = ( ( the_Target_of C10 ) . C11 );

set D3 = ( ( the_Source_of C10 ) . C11 );
reconsider D4 = D3 as (Vertex of C10) by L28 , FUNCT_2:5;
set D5 = ( C10 .walkOf (D4 , C11 , D4) );
L30: C11 Joins D4 , D4 , C10 by L28 , L29 , GLIB_000:def 13;
L31: ( len D5 ) = 3 by L30 , GLIB_001:14;
L32: D5 is non  trivial by L31 , GLIB_001:125;
L33: D5 is  Cycle-like by L32 , GLIB_001:def 31;
thus L34: contradiction by L33 , L26;
end;
L35: C10 is  loopless by L27 , GLIB_000:def 18;
L36:
now
let C12 , C13 , C14 , C15 being set;
assume that
L37: C12 Joins C14 , C15 , C10
and
L38: C13 Joins C14 , C15 , C10;
L39: C13 Joins C15 , C14 , C10 by L38 , GLIB_000:14;
L40: C14 <> C15 by L35 , L37 , GLIB_000:18;
L41:
now
set D6 = ( C10 .walkOf (C14 , C12 , C15) );
set D7 = ( D6 .addEdge C13 );
assume L42: C12 <> C13;
reconsider D8 = D6 as (Path of C10);
L43: ( D8 .last() ) = C15 by L37 , GLIB_001:15;
L44: ( D7 .last() ) = C14 by L43 , L39 , GLIB_001:63;
L45: ( len D8 ) = 3 by L37 , GLIB_001:14;
L46:
now
let C16 being  odd (Element of ( NAT ));
assume that
L47: 1 < C16
and
L48: C16 <= ( len D8 );
L49: ( 1 + 1 ) <= C16 by L47 , NAT_1:13;
L50: ( 2 * 1 ) < C16 by L49 , XXREAL_0:1;
L51: ( ( 2 * 1 ) + 1 ) <= C16 by L50 , NAT_1:13;
L52: C16 = 3 by L51 , L45 , L48 , XXREAL_0:1;
L53: D8 = <* C14 , C12 , C15 *> by L37 , GLIB_001:def 5;
thus L54: ( D8 . C16 ) <> C14 by L53 , L40 , L52 , FINSEQ_1:45;
end;
L55: (( D8 .first() ) = C14 & ( D8 .last() ) = C15) by L37 , GLIB_001:15;
L56: D8 is  open by L55 , L40 , GLIB_001:def 24;
L57: ( D8 .first() ) = C14 by L37 , GLIB_001:15;
L58: ( D7 .first() ) = C14 by L57 , L39 , L43 , GLIB_001:63;
L59: D7 is  closed by L58 , L44 , GLIB_001:def 24;
L60: C13 Joins ( D8 .last() ) , C14 , C10 by L37 , L39 , GLIB_001:15;
L61: D7 is non  trivial by L60 , GLIB_001:132;
L62: ( D8 .edges() ) = { C12 } by L37 , GLIB_001:108;
L63: (not C13 in ( D8 .edges() )) by L62 , L42 , TARSKI:def 1;
thus L64: D7 is  Path-like by L63 , L60 , L56 , L46 , GLIB_001:150;
L65: D7 is  Cycle-like by L64 , L59 , L61 , GLIB_001:def 31;
thus L66: contradiction by L65 , L26;
end;
thus L67: C12 = C13 by L41;
end;
L68: C10 is  non-multi by L36 , GLIB_000:def 20;
thus L69: thesis by L68 , L35;
end;
end;
registration
cluster  Tree-like ->  acyclic  connected for _Graph;
coherence by L5;
end;
registration
cluster  acyclic  connected ->  Tree-like for _Graph;
coherence by L5;
end;
registration
let C17 being _Graph;
let C18 being (Vertex of C17);
cluster  ->  Tree-like for (inducedSubgraph of C17 , { C18 } , ( {} ));
coherence;
end;
definition
let C19 being _Graph;
let C20 being set;
pred C19 is_DTree_rooted_at C20
means
:L74: (C19 is  Tree-like & (for B8 being (Vertex of C19) holds (ex B9 being (DWalk of C19) st B9 is_Walk_from C20 , B8)))
;end;
registration
cluster  trivial  finite  Tree-like for _Graph;
existence
proof
set D9 = { 1 };
set D10 = ( {} );
reconsider D11 = ( {} ) as (Function of D10 , D9) by RELSET_1:12;
set D12 = ( createGraph (D9 , D10 , D11 , D11) );
take D12;
thus L76: thesis;
end;
cluster non  trivial  finite  Tree-like for _Graph;
existence
proof
set D13 = { ( 0 ) , 1 };
set D14 = { ( 0 ) };
set D15 = ( ( 0 ) .--> ( 0 ) );
set D16 = ( ( 0 ) .--> 1 );
L77: ( dom D16 ) = D14 by FUNCOP_1:13;
L78:
now
let C21 being set;
assume L79: C21 in D14;
L80: C21 = ( 0 ) by L79 , TARSKI:def 1;
L81: ( D16 . C21 ) = 1 by L80 , FUNCOP_1:72;
thus L82: ( D16 . C21 ) in D13 by L81 , TARSKI:def 2;
end;
L83:
now
let C22 being set;
assume L84: C22 in D14;
L85: C22 = ( 0 ) by L84 , TARSKI:def 1;
L86: ( D15 . C22 ) = ( 0 ) by L85 , FUNCOP_1:72;
thus L87: ( D15 . C22 ) in D13 by L86 , TARSKI:def 2;
end;
reconsider D17 = D16 as (Function of D14 , D13) by L77 , L78 , FUNCT_2:3;
L88: ( dom D15 ) = D14 by FUNCOP_1:13;
reconsider D18 = D15 as (Function of D14 , D13) by L88 , L83 , FUNCT_2:3;
set D19 = ( createGraph (D13 , D14 , D18 , D17) );
L89: ( the_Edges_of D19 ) = D14 by GLIB_000:6;
L90: ( the_Target_of D19 ) = D17 by GLIB_000:6;
L91: ( ( the_Target_of D19 ) . ( 0 ) ) = 1 by L90 , FUNCOP_1:72;
L92: ( the_Source_of D19 ) = D18 by GLIB_000:6;
L93: ( ( the_Source_of D19 ) . ( 0 ) ) = ( 0 ) by L92 , FUNCOP_1:72;
L94:
now
given C23 being (Walk of D19) such that
L95: C23 is  Cycle-like;

L96:
now
per cases ;
suppose L97: ( len C23 ) = 3;

set D20 = ( C23 . ( 1 + 1 ) );
set D21 = ( C23 . 1 );
set D22 = ( C23 . ( 1 + 2 ) );
L98: ( C23 . ( 1 + 1 ) ) Joins ( C23 . 1 ) , ( C23 . ( 1 + 2 ) ) , D19 by L97 , GLIB_001:def 3 , JORDAN12:2;
L99: D21 = D22 by L95 , L97 , GLIB_001:118;
L100: ((( ( the_Source_of D19 ) . D20 ) = D21 & ( ( the_Target_of D19 ) . D20 ) = D21) or (( ( the_Source_of D19 ) . D20 ) = D21 & ( ( the_Target_of D19 ) . D20 ) = D21)) by L99 , L98 , GLIB_000:def 13;
L101: D20 in ( the_Edges_of D19 ) by L98 , GLIB_000:def 13;
L102: ((D21 = ( 0 ) & D21 = 1) or (D21 = 1 & D21 = ( 0 ))) by L101 , L89 , L93 , L91 , L100 , TARSKI:def 1;
thus L103: contradiction by L102;
end;
suppose L104: ( len C23 ) <> 3;

L105: 3 <= ( len C23 ) by L95 , GLIB_001:125;
L106: ( 3 - 1 ) <= ( ( len C23 ) - ( 0 ) ) by L105 , XREAL_1:13;
L107: ( 2 * 1 ) in ( dom C23 ) by L106 , FINSEQ_3:25;
L108: ( C23 . ( 2 * 1 ) ) in { ( 0 ) } by L107 , L89 , GLIB_001:8;
L109: ( C23 . ( 2 * 1 ) ) = ( 0 ) by L108 , TARSKI:def 1;
L110: 3 < ( len C23 ) by L104 , L105 , XXREAL_0:1;
L111: ( 3 + 1 ) <= ( len C23 ) by L110 , NAT_1:13;
L112: ( 2 * 2 ) in ( dom C23 ) by L111 , FINSEQ_3:25;
L113: ( C23 . ( 2 * 2 ) ) in { ( 0 ) } by L112 , L89 , GLIB_001:8;
L114: ( C23 . ( 2 * 2 ) ) = ( 0 ) by L113 , TARSKI:def 1;
thus L115: contradiction by L114 , L95 , L111 , L109 , GLIB_001:138;
end;
end;
thus L117: contradiction by L96;
end;
L118: D19 is  acyclic by L94 , L3;
set D23 = ( D19 .walkOf (( 0 ) , ( 0 ) , 1) );
set D24 = ( D23 .reverse() );
take D19;
L119: ( the_Vertices_of D19 ) = D13 by GLIB_000:6;
reconsider D25 = ( 0 ) , D26 = 1 as (Vertex of D19) by L119 , TARSKI:def 2;
L120:
now
assume L121: ( card ( the_Vertices_of D19 ) ) = 1;
L122: (ex B10 being set st ( the_Vertices_of D19 ) = { B10 }) by L121 , CARD_2:42;
thus L123: contradiction by L122 , L119 , ZFMISC_1:5;
end;
thus L124: (D19 is non  trivial & D19 is  finite) by L120 , GLIB_000:def 19;
L125: ( 0 ) in ( the_Edges_of D19 ) by L89 , TARSKI:def 1;
L126: ( 0 ) Joins ( 0 ) , 1 , D19 by L125 , L93 , L91 , GLIB_000:def 13;
L127: D23 is_Walk_from ( 0 ) , 1 by L126 , GLIB_001:15;
L128: D24 is_Walk_from 1 , ( 0 ) by L127 , GLIB_001:23;
L129:
now
let C24 , C25 being (Vertex of D19);
L130:
now
per cases  by L119 , TARSKI:def 2;
suppose L131: (C24 = ( 0 ) & C25 = ( 0 ));

L132: ( D19 .walkOf D25 ) is_Walk_from C24 , C25 by L131 , GLIB_001:13;
thus L133: (ex B11 being (Walk of D19) st B11 is_Walk_from C24 , C25) by L132;
end;
suppose L134: (C24 = ( 0 ) & C25 = 1);

thus L135: (ex B12 being (Walk of D19) st B12 is_Walk_from C24 , C25) by L134 , L127;
end;
suppose L136: (C24 = 1 & C25 = ( 0 ));

thus L137: (ex B13 being (Walk of D19) st B13 is_Walk_from C24 , C25) by L136 , L128;
end;
suppose L138: (C24 = 1 & C25 = 1);

L139: ( D19 .walkOf D26 ) is_Walk_from C24 , C25 by L138 , GLIB_001:13;
thus L140: (ex B14 being (Walk of D19) st B14 is_Walk_from C24 , C25) by L139;
end;
end;
thus L142: (ex B15 being (Walk of D19) st B15 is_Walk_from C24 , C25) by L130;
end;
L143: D19 is  connected by L129 , L1;
thus L144: thesis by L143 , L118;
end;
end;
registration
let C26 being _Graph;
cluster  trivial  finite  Tree-like for (Subgraph of C26);
existence
proof
set D27 = the  finite  trivial  simple (Subgraph of C26);
take D27;
thus L146: thesis;
end;
end;
registration
let C27 being  acyclic _Graph;
cluster  ->  acyclic for (Subgraph of C27);
coherence
proof
let C28 being (Subgraph of C27);
L148:
now
given C29 being (Walk of C28) such that
L149: C29 is  Cycle-like;

reconsider D28 = C29 as (Walk of C27) by GLIB_001:167;
L150: D28 is  Path-like by L149 , GLIB_001:176;
L151: (D28 is  closed & D28 is non  trivial) by L149 , GLIB_001:176;
L152: D28 is  Cycle-like by L151 , L150 , GLIB_001:def 31;
thus L153: contradiction by L152 , L3;
end;
thus L154: thesis by L148 , L3;
end;
end;
definition
let C30 being _Graph;
let C31 being (Vertex of C30);
func C30 .reachableFrom C31 -> non  empty (Subset of ( the_Vertices_of C30 )) means 
:L156: (for B16 being set holds (B16 in it iff (ex B17 being (Walk of C30) st B17 is_Walk_from C31 , B16)));
existence
proof
defpred S1[ set ] means (ex B18 being (Walk of C30) st B18 is_Walk_from C31 , $1);
consider C32 being (Subset of ( the_Vertices_of C30 )) such that L157: (for B19 being set holds (B19 in C32 iff (B19 in ( the_Vertices_of C30 ) & S1[ B19 ]))) from SUBSET_1:sch 1;
L158: ( C30 .walkOf C31 ) is_Walk_from C31 , C31 by GLIB_001:13;
reconsider D29 = C32 as non  empty (Subset of ( the_Vertices_of C30 )) by L158 , L157;
take D29;
let C33 being set;
thus L159: (C33 in D29 implies (ex B20 being (Walk of C30) st B20 is_Walk_from C31 , C33)) by L157;
assume L160: (ex B21 being (Walk of C30) st B21 is_Walk_from C31 , C33);
L161: C33 is (Vertex of C30) by L160 , GLIB_001:18;
thus L162: thesis by L161 , L157 , L160;
end;
uniqueness
proof
let C34 , C35 being non  empty (Subset of ( the_Vertices_of C30 ));
assume that
L163: (for B22 being set holds (B22 in C34 iff (ex B23 being (Walk of C30) st B23 is_Walk_from C31 , B22)))
and
L164: (for B24 being set holds (B24 in C35 iff (ex B25 being (Walk of C30) st B25 is_Walk_from C31 , B24)));
L165:
now
let C36 being set;
thus L166:now
assume L167: C36 in C34;
L168: (ex B26 being (Walk of C30) st B26 is_Walk_from C31 , C36) by L167 , L163;
thus L169: C36 in C35 by L168 , L164;
end;
assume L170: C36 in C35;
L171: (ex B27 being (Walk of C30) st B27 is_Walk_from C31 , C36) by L170 , L164;
thus L172: C36 in C34 by L171 , L163;
end;
thus L173: thesis by L165 , TARSKI:1;
end;
end;
definition
let C37 being _Graph;
let C38 being (Vertex of C37);
func C37 .reachableDFrom C38 -> non  empty (Subset of ( the_Vertices_of C37 )) means 
:L175: (for B28 being set holds (B28 in it iff (ex B29 being (DWalk of C37) st B29 is_Walk_from C38 , B28)));
existence
proof
set D30 = ( C37 .walkOf C38 );
defpred S2[ set ] means (ex B30 being  directed (Walk of C37) st B30 is_Walk_from C38 , $1);
consider C39 being (Subset of ( the_Vertices_of C37 )) such that L176: (for B31 being set holds (B31 in C39 iff (B31 in ( the_Vertices_of C37 ) & S2[ B31 ]))) from SUBSET_1:sch 1;
L177: D30 is_Walk_from C38 , C38 by GLIB_001:13;
reconsider D31 = C39 as non  empty (Subset of ( the_Vertices_of C37 )) by L177 , L176;
take D31;
let C40 being set;
thus L178: (C40 in D31 implies (ex B32 being  directed (Walk of C37) st B32 is_Walk_from C38 , C40)) by L176;
given C41 being  directed (Walk of C37) such that
L179: C41 is_Walk_from C38 , C40;

L180: C40 is (Vertex of C37) by L179 , GLIB_001:18;
thus L181: thesis by L180 , L176 , L179;
end;
uniqueness
proof
let C42 , C43 being non  empty (Subset of ( the_Vertices_of C37 ));
assume that
L182: (for B33 being set holds (B33 in C42 iff (ex B34 being  directed (Walk of C37) st B34 is_Walk_from C38 , B33)))
and
L183: (for B35 being set holds (B35 in C43 iff (ex B36 being  directed (Walk of C37) st B36 is_Walk_from C38 , B35)));
L184:
now
let C44 being set;
thus L185:now
assume L186: C44 in C42;
L187: (ex B37 being  directed (Walk of C37) st B37 is_Walk_from C38 , C44) by L186 , L182;
thus L188: C44 in C43 by L187 , L183;
end;
assume L189: C44 in C43;
L190: (ex B38 being  directed (Walk of C37) st B38 is_Walk_from C38 , C44) by L189 , L183;
thus L191: C44 in C42 by L190 , L182;
end;
thus L192: thesis by L184 , TARSKI:1;
end;
end;
L194: (for B39 being _Graph holds (for B40 being (Vertex of B39) holds B40 in ( B39 .reachableFrom B40 )))
proof
let C45 being _Graph;
let C46 being (Vertex of C45);
L195: ( C45 .walkOf C46 ) is_Walk_from C46 , C46 by GLIB_001:13;
thus L196: thesis by L195 , L156;
end;
L197: (for B41 being _Graph holds (for B42 being (Vertex of B41) holds (for B43 , B44 , B45 being set holds ((B44 in ( B41 .reachableFrom B42 ) & B43 Joins B44 , B45 , B41) implies B45 in ( B41 .reachableFrom B42 )))))
proof
let C47 being _Graph;
let C48 being (Vertex of C47);
let C49 , C50 , C51 being set;
set D32 = ( C47 .reachableFrom C48 );
assume that
L198: C50 in D32
and
L199: C49 Joins C50 , C51 , C47;
consider C52 being (Walk of C47) such that L200: C52 is_Walk_from C48 , C50 by L198 , L156;
L201: ( C52 .addEdge C49 ) is_Walk_from C48 , C51 by L199 , L200 , GLIB_001:66;
thus L202: thesis by L201 , L156;
end;
L203: (for B46 being _Graph holds (for B47 , B48 being (Vertex of B46) holds (B47 in ( B46 .reachableFrom B48 ) implies ( B46 .reachableFrom B47 ) = ( B46 .reachableFrom B48 ))))
proof
let C53 being _Graph;
let C54 , C55 being (Vertex of C53);
assume L204: C54 in ( C53 .reachableFrom C55 );
consider C56 being (Walk of C53) such that L205: C56 is_Walk_from C55 , C54 by L204 , L156;
L206: ( C56 .reverse() ) is_Walk_from C54 , C55 by L205 , GLIB_001:23;
L207:
now
let C57 being set;
thus L208:now
assume L209: C57 in ( C53 .reachableFrom C54 );
consider C58 being (Walk of C53) such that L210: C58 is_Walk_from C54 , C57 by L209 , L156;
L211: ( C56 .append C58 ) is_Walk_from C55 , C57 by L205 , L210 , GLIB_001:31;
thus L212: C57 in ( C53 .reachableFrom C55 ) by L211 , L156;
end;
assume L213: C57 in ( C53 .reachableFrom C55 );
consider C59 being (Walk of C53) such that L214: C59 is_Walk_from C55 , C57 by L213 , L156;
L215: ( ( C56 .reverse() ) .append C59 ) is_Walk_from C54 , C57 by L206 , L214 , GLIB_001:31;
thus L216: C57 in ( C53 .reachableFrom C54 ) by L215 , L156;
end;
thus L217: thesis by L207 , TARSKI:1;
end;
L218: (for B49 being _Graph holds (for B50 being (Walk of B49) holds (for B51 being (Vertex of B49) holds (B51 in ( B50 .vertices() ) implies ( B50 .vertices() ) c= ( B49 .reachableFrom B51 )))))
proof
let C60 being _Graph;
let C61 being (Walk of C60);
let C62 being (Vertex of C60);
assume L219: C62 in ( C61 .vertices() );
consider C63 being  odd (Element of ( NAT )) such that L220: C63 <= ( len C61 ) and L221: ( C61 . C63 ) = C62 by L219 , GLIB_001:87;
let C64 being set;
assume L222: C64 in ( C61 .vertices() );
consider C65 being  odd (Element of ( NAT )) such that L223: C65 <= ( len C61 ) and L224: ( C61 . C65 ) = C64 by L222 , GLIB_001:87;
L225:
now
per cases ;
suppose L226: C63 <= C65;

L227: ( C61 .cut (C63 , C65) ) is_Walk_from C62 , C64 by L226 , L221 , L223 , L224 , GLIB_001:37;
thus L228: (ex B52 being (Walk of C60) st B52 is_Walk_from C62 , C64) by L227;
end;
suppose L229: C63 > C65;

L230: ( C61 .cut (C65 , C63) ) is_Walk_from C64 , C62 by L229 , L220 , L221 , L224 , GLIB_001:37;
L231: ( ( C61 .cut (C65 , C63) ) .reverse() ) is_Walk_from C62 , C64 by L230 , GLIB_001:23;
thus L232: (ex B53 being (Walk of C60) st B53 is_Walk_from C62 , C64) by L231;
end;
end;
thus L234: thesis by L225 , L156;
end;
definition
let C66 being _Graph;
let C67 being (Subgraph of C66);
attr C67 is  Component-like
means
:L235: (C67 is  connected & (not (ex B54 being  connected (Subgraph of C66) st C67 c< B54)));
end;
registration
let C68 being _Graph;
cluster  Component-like ->  connected for (Subgraph of C68);
coherence by L235;
end;
registration
let C69 being _Graph;
let C70 being (Vertex of C69);
cluster  ->  Component-like for (inducedSubgraph of C69 , ( C69 .reachableFrom C70 ));
coherence
proof
let C71 being (inducedSubgraph of C69 , ( C69 .reachableFrom C70 ));
L238: ( the_Vertices_of C71 ) = ( C69 .reachableFrom C70 ) by GLIB_000:def 37;
L239: ( the_Edges_of C71 ) = ( C69 .edgesBetween ( C69 .reachableFrom C70 ) ) by GLIB_000:def 37;
L240:
now
L241: C70 in ( the_Vertices_of C71 ) by L238 , L194;
given C72 being  connected (Subgraph of C69) such that
L242: C71 c< C72;

L243: C71 c= C72 by L242 , GLIB_000:def 36;
L244: C71 is (Subgraph of C72) by L243 , GLIB_000:def 35;
L245: ( the_Vertices_of C71 ) c= ( the_Vertices_of C72 ) by L244 , GLIB_000:def 32;
L246:
now
given C73 being set such that
L247: C73 in ( the_Vertices_of C72 )
and
L248: (not C73 in ( the_Vertices_of C71 ));

consider C74 being (Walk of C72) such that L249: C74 is_Walk_from C70 , C73 by L241 , L245 , L247 , L1;
reconsider D33 = C74 as (Walk of C69) by GLIB_001:167;
L250: D33 is_Walk_from C70 , C73 by L249 , GLIB_001:19;
thus L251: contradiction by L250 , L238 , L248 , L156;
end;
L252: ( the_Vertices_of C71 ) c= ( the_Vertices_of C72 ) by L244 , GLIB_000:def 32;
L253:
now
per cases  by L242 , GLIB_000:99;
suppose L254: (ex B55 being set st (B55 in ( the_Vertices_of C72 ) & (not B55 in ( the_Vertices_of C71 ))));

thus L255: contradiction by L254 , L246;
end;
suppose L256: (ex B56 being set st (B56 in ( the_Edges_of C72 ) & (not B56 in ( the_Edges_of C71 ))));

consider C75 being set such that L257: C75 in ( the_Edges_of C72 ) and L258: (not C75 in ( the_Edges_of C71 )) by L256;
set D34 = ( ( the_Source_of C72 ) . C75 );
set D35 = ( ( the_Target_of C72 ) . C75 );
L259: C75 Joins D34 , D35 , C72 by L257 , GLIB_000:def 13;
L260: C75 Joins D34 , D35 , C69 by L259 , GLIB_000:72;
L261:
now
per cases ;
suppose L262: ( the_Vertices_of C72 ) = ( the_Vertices_of C71 );

reconsider D36 = D34 , D37 = D35 as (Vertex of C71) by L262 , L259 , GLIB_000:13;
L263: (D36 in ( C69 .reachableFrom C70 ) & D37 in ( C69 .reachableFrom C70 )) by L238;
thus L264: contradiction by L263 , L239 , L258 , L260 , GLIB_000:32;
end;
suppose L265: ( the_Vertices_of C72 ) <> ( the_Vertices_of C71 );

L266: ( the_Vertices_of C71 ) c< ( the_Vertices_of C72 ) by L265 , L252 , XBOOLE_0:def 8;
thus L267: contradiction by L266 , L246 , XBOOLE_0:6;
end;
end;
thus L269: contradiction by L261;
end;
end;
thus L271: contradiction by L253;
end;
L272:
now
let C76 , C77 being (Vertex of C71);
consider C78 being (Walk of C69) such that L273: C78 is_Walk_from C70 , C76 by L238 , L156;
consider C79 being (Walk of C69) such that L274: C79 is_Walk_from C70 , C77 by L238 , L156;
set D38 = ( C78 .reverse() );
set D39 = ( D38 .append C79 );
L275: D38 is_Walk_from C76 , C70 by L273 , GLIB_001:23;
L276: D39 is_Walk_from C76 , C77 by L275 , L274 , GLIB_001:31;
L277: ( D38 .last() ) = C70 by L275 , GLIB_001:def 23;
L278: C70 in ( D38 .vertices() ) by L277 , GLIB_001:88;
L279: ( D39 .edges() ) c= ( C69 .edgesBetween ( D39 .vertices() ) ) by GLIB_001:109;
L280: ( C79 .first() ) = C70 by L274 , GLIB_001:def 23;
L281: ( D39 .vertices() ) = ( ( D38 .vertices() ) \/ ( C79 .vertices() ) ) by L280 , L277 , GLIB_001:93;
L282: C70 in ( D39 .vertices() ) by L281 , L278 , XBOOLE_0:def 3;
L283: ( C69 .edgesBetween ( D39 .vertices() ) ) c= ( C69 .edgesBetween ( the_Vertices_of C71 ) ) by L282 , L238 , L218 , GLIB_000:36;
L284: ( D39 .edges() ) c= ( C69 .edgesBetween ( the_Vertices_of C71 ) ) by L283 , L279 , XBOOLE_1:1;
reconsider D40 = D39 as (Walk of C71) by L284 , L238 , L239 , L282 , L218 , GLIB_001:170;
take D41 = D40;
thus L285: D41 is_Walk_from C76 , C77 by L276 , GLIB_001:19;
end;
L286: C71 is  connected by L272 , L1;
thus L287: thesis by L286 , L240 , L235;
end;
end;
registration
let C80 being _Graph;
cluster  Component-like for (Subgraph of C80);
existence
proof
set D42 = the (Vertex of C80);
set D43 = the (inducedSubgraph of C80 , ( C80 .reachableFrom D42 ));
take D43;
thus L289: thesis;
end;
end;
definition
let C81 being _Graph;
mode Component of C81
 is  Component-like (Subgraph of C81);
end;
definition
let C82 being _Graph;
func C82 .componentSet() -> non  empty (Subset-Family of ( the_Vertices_of C82 )) means 
:L292: (for B57 being set holds (B57 in it iff (ex B58 being (Vertex of C82) st B57 = ( C82 .reachableFrom B58 ))));
existence
proof
set D44 = the (Vertex of C82);
defpred S3[ set ] means (ex B59 being (Vertex of C82) st $1 = ( C82 .reachableFrom B59 ));
consider C83 being (Subset-Family of ( the_Vertices_of C82 )) such that L293: (for B60 being set holds (B60 in C83 iff (B60 in ( bool ( the_Vertices_of C82 ) ) & S3[ B60 ]))) from SUBSET_1:sch 1;
set D45 = ( C82 .reachableFrom D44 );
L294: D45 in C83 by L293;
reconsider D46 = C83 as non  empty (Subset-Family of ( the_Vertices_of C82 )) by L294;
take D46;
thus L295: thesis by L293;
end;
uniqueness
proof
defpred S4[ set ] means (ex B61 being (Vertex of C82) st $1 = ( C82 .reachableFrom B61 ));
let C84 , C85 being non  empty (Subset-Family of ( the_Vertices_of C82 ));
assume that
L296: (for B62 being set holds (B62 in C84 iff S4[ B62 ]))
and
L297: (for B63 being set holds (B63 in C85 iff S4[ B63 ]));
L298:
now
let C86 being set;
L299: (C86 in C84 iff S4[ C86 ]) by L296;
thus L300: (C86 in C84 iff C86 in C85) by L299 , L297;
end;
thus L301: thesis by L298 , TARSKI:1;
end;
end;
registration
let C87 being _Graph;
let C88 being (Element of ( C87 .componentSet() ));
cluster  ->  Component-like for (inducedSubgraph of C87 , C88);
coherence
proof
let C89 being (inducedSubgraph of C87 , C88);
L303: (ex B64 being (Vertex of C87) st C88 = ( C87 .reachableFrom B64 )) by L292;
thus L304: thesis by L303;
end;
end;
definition
let C90 being _Graph;
func C90 .numComponents() -> Cardinal equals 
( card ( C90 .componentSet() ) );
coherence;
end;
definition
let C91 being  finite _Graph;
redefine func C91 .numComponents() -> non  empty (Element of ( NAT ));

coherence
proof
L307: ( C91 .numComponents() ) = ( card ( C91 .componentSet() ) );
thus L308: thesis by L307;
end;
end;
definition
let C92 being _Graph;
let C93 being (Vertex of C92);
attr C93 is  cut-vertex
means
:L310: (for B65 being (removeVertex of C92 , C93) holds ( C92 .numComponents() ) in ( B65 .numComponents() ));
end;
definition
let C94 being  finite _Graph;
let C95 being (Vertex of C94);
redefine attr C95 is  cut-vertex
means
:L312: (for B66 being (removeVertex of C94 , C95) holds ( C94 .numComponents() ) < ( B66 .numComponents() ));
compatibility
proof
thus L313:now
assume L314: C95 is  cut-vertex;
let C96 being (removeVertex of C94 , C95);
L315: ( card ( C94 .numComponents() ) ) in ( card ( C96 .numComponents() ) ) by L314 , L310;
thus L316: ( C94 .numComponents() ) < ( C96 .numComponents() ) by L315 , NAT_1:41;
end;
assume L317: (for B67 being (removeVertex of C94 , C95) holds ( C94 .numComponents() ) < ( B67 .numComponents() ));
L318:
now
let C97 being (removeVertex of C94 , C95);
L319: ( C94 .numComponents() ) < ( C97 .numComponents() ) by L317;
L320: ( card ( C94 .numComponents() ) ) in ( card ( C97 .numComponents() ) ) by L319 , NAT_1:41;
thus L321: ( C94 .numComponents() ) in ( C97 .numComponents() ) by L320;
end;
thus L322: thesis by L318 , L310;
end;
end;
L324: (for B68 being non  trivial  connected _Graph holds (for B69 being (Vertex of B68) holds (for B70 being (removeVertex of B68 , B69) holds (B69 is  endvertex implies B70 is  connected))))
proof
let C98 being non  trivial  connected _Graph;
let C99 being (Vertex of C98);
let C100 being (removeVertex of C98 , C99);
set D47 = ( the_Vertices_of C98 );
set D48 = ( the_Vertices_of C100 );
assume L325: C99 is  endvertex;
consider C101 being set such that L326: ( C99 .edgesInOut() ) = { C101 } and L327: (not C101 Joins C99 , C99 , C98) by L325 , GLIB_000:def 51;
L328:
now
let C102 , C103 being (Vertex of C100);
reconsider D49 = C102 , D50 = C103 as (Vertex of C98) by GLIB_000:42;
consider C104 being (Walk of C98) such that L329: C104 is_Walk_from D49 , D50 by L1;
set D51 = the (Trail of C104);
L330: D51 is_Walk_from D49 , D50 by L329 , GLIB_001:160;
L331: ( D51 . ( len D51 ) ) = D50 by L330 , GLIB_001:17;
L332: C102 in D48;
L333: C102 in ( D47 \ { C99 } ) by L332 , GLIB_000:47;
L334: (not D49 in { C99 }) by L333 , XBOOLE_0:def 5;
L335: C103 in D48;
L336: C103 in ( D47 \ { C99 } ) by L335 , GLIB_000:47;
L337: (not D50 in { C99 }) by L336 , XBOOLE_0:def 5;
L338: D50 <> C99 by L337 , TARSKI:def 1;
L339: ( D51 . 1 ) = D49 by L330 , GLIB_001:17;
L340:
now
let C105 being set;
assume L341: C105 in ( D51 .edges() );
consider C106 being  even (Element of ( NAT )) such that L342: 1 <= C106 and L343: C106 <= ( len D51 ) and L344: ( D51 . C106 ) = C105 by L341 , GLIB_001:99;
L345: C106 in ( dom D51 ) by L342 , L343 , FINSEQ_3:25;
consider C107 being  odd (Element of ( NAT )) such that L346: C107 = ( C106 - 1 ) and L347: ( C106 - 1 ) in ( dom D51 ) and L348: ( C106 + 1 ) in ( dom D51 ) and L349: ( D51 . C106 ) Joins ( D51 . C107 ) , ( D51 . ( C106 + 1 ) ) , C98 by L345 , GLIB_001:9;
L350: ( C106 + 1 ) <= ( len D51 ) by L348 , FINSEQ_3:25;
L351: C107 <= ( len D51 ) by L346 , L347 , FINSEQ_3:25;
L352:
now
assume L353: C105 in ( C99 .edgesInOut() );
L354: C105 = C101 by L353 , L326 , TARSKI:def 1;
L355:
now
per cases  by L344 , L349 , L353 , GLIB_000:65;
suppose L356: ( D51 . C107 ) = C99;

reconsider D52 = ( C107 - 1 ) as  even (Element of ( NAT )) by ABIAN:12 , INT_1:5;
L357: 1 <= C107 by ABIAN:12;
L358: C107 <> 1 by L334 , L339 , L356 , TARSKI:def 1;
L359: 1 < C107 by L358 , L357 , XXREAL_0:1;
L360: ( 1 + 1 ) <= C107 by L359 , NAT_1:13;
L361: ( ( 1 + 1 ) - 1 ) <= D52 by L360 , XREAL_1:13;
L362: ( D51 .vertexAt C107 ) = C99 by L351 , L356 , GLIB_001:def 8;
L363: ( D51 . D52 ) in ( C99 .edgesInOut() ) by L362 , L351 , L359 , GLIB_001:11;
L364: ( D51 . C106 ) = ( D51 . D52 ) by L363 , L326 , L344 , L354 , TARSKI:def 1;
L365: ( C106 - 1 ) < ( C106 - ( 0 ) ) by XREAL_1:15;
L366: ( C107 - 1 ) < ( C106 - ( 0 ) ) by L365 , L346 , XREAL_1:14;
thus L367: contradiction by L366 , L343 , L364 , L361 , GLIB_001:138;
end;
suppose L368: ( D51 . ( C106 + 1 ) ) = C99;

L369: ( C106 + 1 ) < ( len D51 ) by L368 , L338 , L331 , L350 , XXREAL_0:1;
L370: ( D51 .vertexAt ( C106 + 1 ) ) = C99 by L350 , L368 , GLIB_001:def 8;
L371: ( D51 . ( ( C106 + 1 ) + 1 ) ) in ( C99 .edgesInOut() ) by L370 , L369 , GLIB_001:10;
L372: ( D51 . C106 ) = ( D51 . ( ( C106 + 1 ) + 1 ) ) by L371 , L326 , L344 , L354 , TARSKI:def 1;
L373: (( C106 + ( 0 ) ) < ( C106 + ( 1 + 1 ) ) & ( ( C106 + 1 ) + 1 ) <= ( len D51 )) by L369 , NAT_1:13 , XREAL_1:8;
thus L374: contradiction by L373 , L342 , L372 , GLIB_001:138;
end;
end;
thus L376: contradiction by L355;
end;
L377: C105 in ( ( the_Edges_of C98 ) \ ( C99 .edgesInOut() ) ) by L352 , L341 , XBOOLE_0:def 5;
L378: C105 in ( ( the_Edges_of C98 ) \ ( C98 .edgesInOut { C99 } ) ) by L377 , GLIB_000:def 40;
L379: C105 in ( C98 .edgesBetween ( ( the_Vertices_of C98 ) \ { C99 } ) ) by L378 , GLIB_000:35;
thus L380: C105 in ( the_Edges_of C100 ) by L379 , GLIB_000:47;
end;
L381: ( D51 .edges() ) c= ( the_Edges_of C100 ) by L340 , TARSKI:def 3;
L382: D49 <> C99 by L334 , TARSKI:def 1;
L383:
now
let C108 being set;
assume L384: C108 in ( D51 .vertices() );
L385:
now
assume L386: C108 = C99;
L387: (C99 = ( D51 .first() ) or C99 = ( D51 .last() )) by L386 , L325 , L384 , GLIB_001:143;
thus L388: contradiction by L387 , L382 , L338 , L330 , GLIB_001:def 23;
end;
L389: (not C108 in { C99 }) by L385 , TARSKI:def 1;
L390: C108 in ( D47 \ { C99 } ) by L389 , L384 , XBOOLE_0:def 5;
thus L391: C108 in D48 by L390 , GLIB_000:47;
end;
L392: ( D51 .vertices() ) c= D48 by L383 , TARSKI:def 3;
reconsider D53 = D51 as (Walk of C100) by L392 , L381 , GLIB_001:170;
L393: D53 is_Walk_from C102 , C103 by L330 , GLIB_001:19;
thus L394: (ex B71 being (Walk of C100) st B71 is_Walk_from C102 , C103) by L393;
end;
thus L395: thesis by L328 , L1;
end;
L396: (for B72 being _Graph holds ((ex B73 being (Vertex of B72) st (for B74 being (Vertex of B72) holds (ex B75 being (Walk of B72) st B75 is_Walk_from B73 , B74))) implies B72 is  connected))
proof
let C109 being _Graph;
given C110 being (Vertex of C109) such that
L397: (for B76 being (Vertex of C109) holds (ex B77 being (Walk of C109) st B77 is_Walk_from C110 , B76));

L398:
now
let C111 , C112 being (Vertex of C109);
consider C113 being (Walk of C109) such that L399: C113 is_Walk_from C110 , C111 by L397;
consider C114 being (Walk of C109) such that L400: C114 is_Walk_from C110 , C112 by L397;
L401: ( C113 .reverse() ) is_Walk_from C111 , C110 by L399 , GLIB_001:23;
L402: ( ( C113 .reverse() ) .append C114 ) is_Walk_from C111 , C112 by L401 , L400 , GLIB_001:31;
thus L403: (ex B78 being (Walk of C109) st B78 is_Walk_from C111 , C112) by L402;
end;
thus L404: thesis by L398 , L1;
end;
L405: (for B79 being _Graph holds ((ex B80 being (Vertex of B79) st ( B79 .reachableFrom B80 ) = ( the_Vertices_of B79 )) implies B79 is  connected))
proof
let C115 being _Graph;
assume L406: (ex B81 being (Vertex of C115) st ( C115 .reachableFrom B81 ) = ( the_Vertices_of C115 ));
consider C116 being (Vertex of C115) such that L407: ( C115 .reachableFrom C116 ) = ( the_Vertices_of C115 ) by L406;
L408:
now
let C117 , C118 being (Vertex of C115);
consider C119 being (Walk of C115) such that L409: C119 is_Walk_from C116 , C117 by L407 , L156;
consider C120 being (Walk of C115) such that L410: C120 is_Walk_from C116 , C118 by L407 , L156;
L411: ( C119 .reverse() ) is_Walk_from C117 , C116 by L409 , GLIB_001:23;
L412: ( ( C119 .reverse() ) .append C120 ) is_Walk_from C117 , C118 by L411 , L410 , GLIB_001:31;
thus L413: (ex B82 being (Walk of C115) st B82 is_Walk_from C117 , C118) by L412;
end;
thus L414: thesis by L408 , L1;
end;
L415: (for B83 being _Graph holds (B83 is  connected implies (for B84 being (Vertex of B83) holds ( B83 .reachableFrom B84 ) = ( the_Vertices_of B83 ))))
proof
let C121 being _Graph;
assume L416: C121 is  connected;
let C122 being (Vertex of C121);
L417:
now
let C123 being set;
thus L418: (C123 in ( C121 .reachableFrom C122 ) implies C123 in ( the_Vertices_of C121 ));
assume L419: C123 in ( the_Vertices_of C121 );
L420: (ex B85 being (Walk of C121) st B85 is_Walk_from C122 , C123) by L419 , L416 , L1;
thus L421: C123 in ( C121 .reachableFrom C122 ) by L420 , L156;
end;
thus L422: thesis by L417 , TARSKI:1;
end;
L423: (for B86 , B87 being _Graph holds (for B88 being (Vertex of B86) holds (for B89 being (Vertex of B87) holds ((B86 == B87 & B88 = B89) implies ( B86 .reachableFrom B88 ) = ( B87 .reachableFrom B89 )))))
proof
let C124 , C125 being _Graph;
let C126 being (Vertex of C124);
let C127 being (Vertex of C125);
assume that
L424: C124 == C125
and
L425: C126 = C127;
L426:
now
let C128 being set;
thus L427:now
assume L428: C128 in ( C124 .reachableFrom C126 );
consider C129 being (Walk of C124) such that L429: C129 is_Walk_from C127 , C128 by L428 , L425 , L156;
reconsider D54 = C129 as (Walk of C125) by L424 , GLIB_001:179;
L430: D54 is_Walk_from C127 , C128 by L429 , GLIB_001:19;
thus L431: C128 in ( C125 .reachableFrom C127 ) by L430 , L156;
end;
assume L432: C128 in ( C125 .reachableFrom C127 );
consider C130 being (Walk of C125) such that L433: C130 is_Walk_from C126 , C128 by L432 , L425 , L156;
reconsider D55 = C130 as (Walk of C124) by L424 , GLIB_001:179;
L434: D55 is_Walk_from C126 , C128 by L433 , GLIB_001:19;
thus L435: C128 in ( C124 .reachableFrom C126 ) by L434 , L156;
end;
thus L436: thesis by L426 , TARSKI:1;
end;
L437: (for B90 being _Graph holds (for B91 being  connected (Subgraph of B90) holds (B91 is  spanning implies B90 is  connected)))
proof
let C131 being _Graph;
let C132 being  connected (Subgraph of C131);
assume L438: C132 is  spanning;
L439:
now
let C133 , C134 being (Vertex of C131);
reconsider D56 = C133 , D57 = C134 as (Vertex of C132) by L438 , GLIB_000:def 33;
consider C135 being (Walk of C132) such that L440: C135 is_Walk_from D56 , D57 by L1;
reconsider D58 = C135 as (Walk of C131) by GLIB_001:167;
take D59 = D58;
thus L441: D59 is_Walk_from C133 , C134 by L440 , GLIB_001:19;
end;
thus L442: thesis by L439 , L1;
end;
L443: (for B92 being _Graph holds (B92 is  connected iff ( B92 .componentSet() ) = { ( the_Vertices_of B92 ) }))
proof
let C136 being _Graph;
thus L444:now
assume L445: C136 is  connected;
L446:
now
set D60 = the (Vertex of C136);
let C137 being set;
thus L447:now
assume L448: C137 in ( C136 .componentSet() );
L449: (ex B93 being (Vertex of C136) st C137 = ( C136 .reachableFrom B93 )) by L448 , L292;
L450: C137 = ( the_Vertices_of C136 ) by L449 , L445 , L415;
thus L451: C137 in { ( the_Vertices_of C136 ) } by L450 , TARSKI:def 1;
end;
assume L452: C137 in { ( the_Vertices_of C136 ) };
L453: C137 = ( the_Vertices_of C136 ) by L452 , TARSKI:def 1;
L454: ( C136 .reachableFrom D60 ) = ( the_Vertices_of C136 ) by L445 , L415;
thus L455: C137 in ( C136 .componentSet() ) by L454 , L453 , L292;
end;
thus L456: ( C136 .componentSet() ) = { ( the_Vertices_of C136 ) } by L446 , TARSKI:1;
end;
assume L457: ( C136 .componentSet() ) = { ( the_Vertices_of C136 ) };
L458: ( the_Vertices_of C136 ) in ( C136 .componentSet() ) by L457 , TARSKI:def 1;
L459: (ex B94 being (Vertex of C136) st ( C136 .reachableFrom B94 ) = ( the_Vertices_of C136 )) by L458 , L292;
thus L460: thesis by L459 , L405;
end;
L461: (for B95 , B96 being _Graph holds (B95 == B96 implies ( B95 .componentSet() ) = ( B96 .componentSet() )))
proof
let C138 , C139 being _Graph;
assume L462: C138 == C139;
L463:
now
let C140 being set;
thus L464:now
assume L465: C140 in ( C138 .componentSet() );
consider C141 being (Vertex of C138) such that L466: C140 = ( C138 .reachableFrom C141 ) by L465 , L292;
reconsider D61 = C141 as (Vertex of C139) by L462 , GLIB_000:def 34;
L467: C140 = ( C139 .reachableFrom D61 ) by L462 , L466 , L423;
thus L468: C140 in ( C139 .componentSet() ) by L467 , L292;
end;
assume L469: C140 in ( C139 .componentSet() );
consider C142 being (Vertex of C139) such that L470: C140 = ( C139 .reachableFrom C142 ) by L469 , L292;
reconsider D62 = C142 as (Vertex of C138) by L462 , GLIB_000:def 34;
L471: C140 = ( C138 .reachableFrom D62 ) by L462 , L470 , L423;
thus L472: C140 in ( C138 .componentSet() ) by L471 , L292;
end;
thus L473: thesis by L463 , TARSKI:1;
end;
L474: (for B97 being _Graph holds (for B98 being set holds (B98 in ( B97 .componentSet() ) implies B98 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of B97 )))))
proof
let C143 being _Graph;
let C144 being set;
assume L475: C144 in ( C143 .componentSet() );
L476: (ex B99 being (Vertex of C143) st C144 = ( C143 .reachableFrom B99 )) by L475 , L292;
thus L477: thesis by L476;
end;
L478: (for B100 being _Graph holds (for B101 being (Component of B100) holds ( the_Edges_of B101 ) = ( B100 .edgesBetween ( the_Vertices_of B101 ) )))
proof
let C145 being _Graph;
let C146 being (Component of C145);
reconsider D63 = ( the_Vertices_of C146 ) as (Subset of ( the_Vertices_of C145 ));
set D64 = ( C145 .edgesBetween D63 );
L479: ( C146 .edgesBetween ( the_Vertices_of C146 ) ) c= D64 by GLIB_000:76;
L480: ( the_Edges_of C146 ) c= D64 by L479 , GLIB_000:34;
L481:
now
let C147 being set;
thus L482: (C147 in ( the_Edges_of C146 ) implies C147 in D64) by L480;
assume L483: C147 in D64;
L484:
now
set D65 = the (inducedSubgraph of C145 , D63 , D64);
assume L485: (not C147 in ( the_Edges_of C146 ));
L486: ( the_Edges_of D65 ) = D64 by GLIB_000:def 37;
L487: ( the_Vertices_of D65 ) = D63 by GLIB_000:def 37;
L488: C146 is  spanning  spanning  spanning  spanning (Subgraph of D65) by L487 , L480 , L486 , GLIB_000:44 , GLIB_000:def 33;
L489: D65 is  connected by L488 , L437;
L490: (not C146 c< D65) by L489 , L235;
L491: (D65 == C146 or (not C146 c= D65)) by L490 , GLIB_000:def 36;
thus L492: contradiction by L491 , L483 , L485 , L486 , L488 , GLIB_000:def 34 , GLIB_000:def 35;
end;
thus L493: C147 in ( the_Edges_of C146 ) by L484;
end;
thus L494: thesis by L481 , TARSKI:1;
end;
L495: (for B102 being _Graph holds (for B103 , B104 being (Component of B102) holds (( the_Vertices_of B103 ) = ( the_Vertices_of B104 ) iff B103 == B104)))
proof
let C148 being _Graph;
let C149 , C150 being (Component of C148);
thus L496:now
assume L497: ( the_Vertices_of C149 ) = ( the_Vertices_of C150 );
L498: ( the_Edges_of C149 ) = ( C148 .edgesBetween ( the_Vertices_of C150 ) ) by L497 , L478
.= ( the_Edges_of C150 ) by L478;
thus L499: C149 == C150 by L498 , L497 , GLIB_000:86;
end;
assume L500: C149 == C150;
thus L501: thesis by L500 , GLIB_000:def 34;
end;
L502: (for B105 being _Graph holds (for B106 being (Component of B105) holds (for B107 being (Vertex of B105) holds (B107 in ( the_Vertices_of B106 ) iff ( the_Vertices_of B106 ) = ( B105 .reachableFrom B107 )))))
proof
let C151 being _Graph;
let C152 being (Component of C151);
let C153 being (Vertex of C151);
thus L503:now
assume L504: C153 in ( the_Vertices_of C152 );
L505:
now
let C154 being set;
thus L506:now
assume L507: C154 in ( the_Vertices_of C152 );
reconsider D66 = C154 as (Vertex of C152) by L507;
consider C155 being (Walk of C152) such that L508: C155 is_Walk_from C153 , D66 by L504 , L1;
reconsider D67 = C155 as (Walk of C151) by GLIB_001:167;
L509: D67 is_Walk_from C153 , C154 by L508 , GLIB_001:19;
thus L510: C154 in ( C151 .reachableFrom C153 ) by L509 , L156;
end;
assume L511: C154 in ( C151 .reachableFrom C153 );
reconsider D68 = C154 as (Vertex of C151) by L511;
L512: ( C151 .reachableFrom D68 ) = ( C151 .reachableFrom C153 ) by L511 , L203;
set D69 = the (inducedSubgraph of C151 , ( C151 .reachableFrom D68 ));
L513: (not C152 c< D69) by L235;
L514: (C152 == D69 or (not C152 c= D69)) by L513 , GLIB_000:def 36;
L515: ( the_Edges_of D69 ) = ( C151 .edgesBetween ( C151 .reachableFrom D68 ) ) by GLIB_000:def 37;
L516:
now
let C156 being set;
set D70 = ( ( the_Source_of C152 ) . C156 );
set D71 = ( ( the_Target_of C152 ) . C156 );
assume L517: C156 in ( the_Edges_of C152 );
reconsider D72 = D70 , D73 = D71 as (Vertex of C152) by L517 , FUNCT_2:5;
L518: C156 Joins D72 , D73 , C152 by L517 , GLIB_000:def 13;
L519: C156 Joins D72 , D73 , C151 by L518 , GLIB_000:72;
consider C157 being (Walk of C152) such that L520: C157 is_Walk_from C153 , D72 by L504 , L1;
reconsider D74 = C157 as (Walk of C151) by GLIB_001:167;
consider C158 being (Walk of C152) such that L521: C158 is_Walk_from C153 , D73 by L504 , L1;
reconsider D75 = C158 as (Walk of C151) by GLIB_001:167;
L522: D75 is_Walk_from C153 , D73 by L521 , GLIB_001:19;
L523: D73 in ( C151 .reachableFrom D68 ) by L522 , L512 , L156;
L524: D74 is_Walk_from C153 , D72 by L520 , GLIB_001:19;
L525: D72 in ( C151 .reachableFrom D68 ) by L524 , L512 , L156;
thus L526: C156 in ( the_Edges_of D69 ) by L525 , L515 , L519 , L523 , GLIB_000:32;
end;
L527: ( the_Edges_of C152 ) c= ( the_Edges_of D69 ) by L516 , TARSKI:def 3;
L528: ( the_Vertices_of D69 ) = ( C151 .reachableFrom D68 ) by GLIB_000:def 37;
L529:
now
let C159 being set;
assume L530: C159 in ( the_Vertices_of C152 );
consider C160 being (Walk of C152) such that L531: C160 is_Walk_from C153 , C159 by L530 , L504 , L1;
reconsider D76 = C160 as (Walk of C151) by GLIB_001:167;
L532: D76 is_Walk_from C153 , C159 by L531 , GLIB_001:19;
thus L533: C159 in ( the_Vertices_of D69 ) by L532 , L528 , L512 , L156;
end;
L534: ( the_Vertices_of C152 ) c= ( the_Vertices_of D69 ) by L529 , TARSKI:def 3;
L535: C152 is (Subgraph of D69) by L534 , L527 , GLIB_000:44;
L536: C154 in ( the_Vertices_of D69 ) by L528 , L194;
thus L537: C154 in ( the_Vertices_of C152 ) by L536 , L514 , L535 , GLIB_000:def 34 , GLIB_000:def 35;
end;
thus L538: ( the_Vertices_of C152 ) = ( C151 .reachableFrom C153 ) by L505 , TARSKI:1;
end;
assume L539: ( the_Vertices_of C152 ) = ( C151 .reachableFrom C153 );
thus L540: thesis by L539 , L194;
end;
L541: (for B108 being _Graph holds (for B109 , B110 being (Component of B108) holds (for B111 being set holds ((B111 in ( the_Vertices_of B109 ) & B111 in ( the_Vertices_of B110 )) implies B109 == B110))))
proof
let C161 being _Graph;
let C162 , C163 being (Component of C161);
let C164 being set;
assume that
L542: C164 in ( the_Vertices_of C162 )
and
L543: C164 in ( the_Vertices_of C163 );
reconsider D77 = C164 as (Vertex of C161) by L542;
L544: (( the_Vertices_of C162 ) = ( C161 .reachableFrom D77 ) & ( the_Vertices_of C163 ) = ( C161 .reachableFrom D77 )) by L542 , L543 , L502;
thus L545: thesis by L544 , L495;
end;
L546: (for B112 being _Graph holds (B112 is  connected iff ( B112 .numComponents() ) = 1))
proof
let C165 being _Graph;
thus L547:now
assume L548: C165 is  connected;
L549: ( C165 .componentSet() ) = { ( the_Vertices_of C165 ) } by L548 , L443;
thus L550: ( C165 .numComponents() ) = 1 by L549 , CARD_1:30;
end;
assume L551: ( C165 .numComponents() ) = 1;
consider C166 being set such that L552: ( C165 .componentSet() ) = { C166 } by L551 , CARD_2:42;
L553:
now
let C167 being set;
assume L554: C167 in ( the_Vertices_of C165 );
reconsider D78 = C167 as (Vertex of C165) by L554;
L555:
now
set D79 = ( C165 .reachableFrom D78 );
assume L556: (not C167 in C166);
L557: D79 in ( C165 .componentSet() ) by L292;
L558: (not C167 in D79) by L557 , L552 , L556 , TARSKI:def 1;
thus L559: contradiction by L558 , L194;
end;
thus L560: C167 in C166 by L555;
end;
L561: ( the_Vertices_of C165 ) c= C166 by L553 , TARSKI:def 3;
L562: C166 in ( C165 .componentSet() ) by L552 , TARSKI:def 1;
L563: C166 = ( the_Vertices_of C165 ) by L562 , L561 , XBOOLE_0:def 10;
thus L564: thesis by L563 , L552 , L443;
end;
L565: (for B113 being  connected _Graph holds (for B114 being (Vertex of B113) holds (B114 is non  cut-vertex iff (for B115 being (removeVertex of B113 , B114) holds ( B115 .numComponents() ) c= ( B113 .numComponents() )))))
proof
let C168 being  connected _Graph;
let C169 being (Vertex of C168);
thus L566:now
assume L567: C169 is non  cut-vertex;
consider C170 being (removeVertex of C168 , C169) such that L568: (not ( C168 .numComponents() ) in ( C170 .numComponents() )) by L567 , L310;
let C171 being (removeVertex of C168 , C169);
L569: ( C170 .numComponents() ) c= ( C168 .numComponents() ) by L568 , CARD_1:4;
thus L570: ( C171 .numComponents() ) c= ( C168 .numComponents() ) by L569 , L461 , GLIB_000:93;
end;
assume L571: (for B116 being (removeVertex of C168 , C169) holds ( B116 .numComponents() ) c= ( C168 .numComponents() ));
L572:
now
set D80 = the (removeVertex of C168 , C169);
assume L573: (for B117 being (removeVertex of C168 , C169) holds ( C168 .numComponents() ) in ( B117 .numComponents() ));
L574: ( C168 .numComponents() ) in ( D80 .numComponents() ) by L573;
L575: ( D80 .numComponents() ) c= ( C168 .numComponents() ) by L571;
thus L576: contradiction by L575 , L574 , CARD_1:4;
end;
thus L577: thesis by L572 , L310;
end;
L578: (for B118 being  connected _Graph holds (for B119 being (Vertex of B118) holds (for B120 being (removeVertex of B118 , B119) holds ((not B119 is  cut-vertex) implies B120 is  connected))))
proof
let C172 being  connected _Graph;
let C173 being (Vertex of C172);
let C174 being (removeVertex of C172 , C173);
assume L579: (not C173 is  cut-vertex);
L580: ( C172 .numComponents() ) = 1 by L546;
L581: ( C174 .numComponents() ) c= ( succ ( 0 ) ) by L580 , L579 , L565;
L582: ( C174 .numComponents() ) c= ( ( {} ) \/ { ( {} ) } ) by L581 , ORDINAL1:def 1;
L583: ( C174 .numComponents() ) = ( ( {} ) \/ { ( {} ) } ) by L582 , ZFMISC_1:33
.= ( succ ( 0 ) ) by ORDINAL1:def 1
.= 1;
thus L584: thesis by L583 , L546;
end;
L585: (for B121 being non  trivial  finite  connected _Graph holds (ex B122 , B123 being (Vertex of B121) st (B122 <> B123 & (not B122 is  cut-vertex) & (not B123 is  cut-vertex))))
proof
let C175 being non  trivial  finite  connected _Graph;
defpred S5[ Nat ] means (for B124 being non  trivial  finite  connected _Graph holds (( B124 .order() ) = $1 implies (ex B125 , B126 being (Vertex of B124) st (B125 <> B126 & (not B125 is  cut-vertex) & (not B126 is  cut-vertex)))));
L586:
now
let C176 being Nat;
assume L587: (for B127 being Nat holds (B127 < C176 implies S5[ B127 ]));
L588:
now
let C177 being non  trivial  finite  connected _Graph;
assume that
L589: ( C177 .order() ) = C176;
L590: ( C177 .numComponents() ) = 1 by L546;
L591:
now
per cases ;
suppose L592: (not (ex B128 being (Vertex of C177) st B128 is  cut-vertex));

consider C178 , C179 being (Vertex of C177) such that L593: C178 <> C179 by GLIB_000:21;
take D81 = C178;
take D82 = C179;
thus L594: D81 <> D82 by L593;
thus L595: ((not D81 is  cut-vertex) & (not D82 is  cut-vertex)) by L592;
end;
suppose L596: (ex B129 being (Vertex of C177) st B129 is  cut-vertex);

consider C180 being (Vertex of C177) such that L597: C180 is  cut-vertex by L596;
set D83 = the (removeVertex of C177 , C180);
L598: 1 < ( D83 .numComponents() ) by L590 , L597 , L312;
L599: ( 1 + 1 ) <= ( D83 .numComponents() ) by L598 , NAT_1:13;
L600: ( card 2 ) <= ( card ( D83 .componentSet() ) ) by L599 , CARD_1:def 2;
L601: ( card 2 ) c= ( card ( D83 .componentSet() ) ) by L600 , NAT_1:39;
L602: 2 c= ( card ( D83 .componentSet() ) ) by L601 , CARD_1:def 2;
consider C181 , C182 being set such that L603: (C181 in ( D83 .componentSet() ) & C182 in ( D83 .componentSet() )) and L604: C181 <> C182 by L602 , PENCIL_1:2;
reconsider D84 = C181 , D85 = C182 as (Element of ( D83 .componentSet() )) by L603;
set D86 = the (inducedSubgraph of D83 , D84);
set D87 = the (inducedSubgraph of D83 , D85);
L605: ( the_Vertices_of D83 ) = ( ( the_Vertices_of C177 ) \ { C180 } ) by GLIB_000:47;
L606: ( C177 .edgesBetween ( ( the_Vertices_of C177 ) \ { C180 } ) ) = ( ( the_Edges_of C177 ) \ ( C177 .edgesInOut { C180 } ) ) by GLIB_000:35;
L607: ( C177 .edgesBetween ( ( the_Vertices_of C177 ) \ { C180 } ) ) = ( ( the_Edges_of C177 ) \ ( C180 .edgesInOut() ) ) by L606 , GLIB_000:def 40;
L608: ( the_Edges_of D83 ) = ( ( the_Edges_of C177 ) \ ( C180 .edgesInOut() ) ) by L607 , GLIB_000:47;
L609: ( ( D83 .order() ) + 1 ) = C176 by L589 , GLIB_000:48;
L610:
now
let C183 being (Component of D83);
L611:
now
set D88 = the (Vertex of C183);
assume L612: (for B130 being (Vertex of C183) holds (not (ex B131 being set st B131 Joins C180 , B130 , C177)));
L613: ( the_Vertices_of C183 ) c= ( the_Vertices_of D83 );
reconsider D89 = D88 as (Vertex of D83) by L613 , TARSKI:def 3;
L614: ( the_Vertices_of D83 ) c= ( the_Vertices_of C177 );
reconsider D90 = D89 as (Vertex of C177) by L614 , TARSKI:def 3;
consider C184 being (Walk of C177) such that L615: C184 is_Walk_from C180 , D90 by L1;
set D91 = the (Path of C184);
L616: D91 is_Walk_from C180 , D90 by L615 , GLIB_001:160;
L617: ( D91 .first() ) = C180 by L616 , GLIB_001:def 23;
set D92 = ( D91 .cut (( ( 2 * 1 ) + 1 ) , ( len D91 )) );
L618: 1 <= ( len D91 ) by ABIAN:12;
L619: ( D91 .last() ) = D88 by L616 , GLIB_001:def 23;
L620: ( D91 . ( len D91 ) ) = D88 by L619 , GLIB_001:def 7;
L621: (not D89 in { C180 }) by L605 , XBOOLE_0:def 5;
L622: D88 <> C180 by L621 , TARSKI:def 1;
L623: D91 is non  trivial by L622 , L617 , L619 , GLIB_001:127;
L624: ( ( 2 * 1 ) + 1 ) <= ( len D91 ) by L623 , GLIB_001:125;
L625: D92 is_Walk_from ( D91 . 3 ) , ( D91 . ( len D91 ) ) by L624 , GLIB_001:37;
L626: D92 is_Walk_from ( D91 . 3 ) , D88 by L625 , L619 , GLIB_001:def 7;
L627: ( D91 . ( ( 2 * ( 0 ) ) + 1 ) ) = C180 by L617 , GLIB_001:def 6;
L628:
now
assume L629: C180 in ( D92 .vertices() );
consider C185 being  odd (Element of ( NAT )) such that L630: C185 <= ( len D92 ) and L631: ( D92 . C185 ) = C180 by L629 , GLIB_001:87;
L632: 1 <= C185 by ABIAN:12;
L633: ( 1 + ( 0 ) ) < ( C185 + 2 ) by L632 , XREAL_1:8;
L634: C185 in ( dom D92 ) by L630 , L632 , FINSEQ_3:25;
L635: ( ( 3 + C185 ) - 1 ) in ( dom D91 ) by L634 , L624 , GLIB_001:47;
L636: ( 2 + C185 ) <= ( len D91 ) by L635 , FINSEQ_3:25;
L637: ( D91 . ( ( 3 + C185 ) - 1 ) ) = C180 by L624 , L631 , L634 , GLIB_001:47;
thus L638: contradiction by L637 , L622 , L627 , L620 , L636 , L633 , GLIB_001:def 28;
end;
reconsider D93 = D92 as (Walk of D83) by L628 , GLIB_001:171;
L639: D93 is_Walk_from ( D91 . 3 ) , D88 by L626 , GLIB_001:19;
L640: ( D93 .reverse() ) is_Walk_from D88 , ( D91 . 3 ) by L639 , GLIB_001:23;
L641: ( D91 . 3 ) in ( D83 .reachableFrom D89 ) by L640 , L156;
L642: ( len D91 ) <> 1 by L623 , GLIB_001:125;
L643: ( ( 2 * ( 0 ) ) + 1 ) < ( len D91 ) by L642 , L618 , XXREAL_0:1;
L644: ( D91 . ( 1 + 1 ) ) Joins ( D91 . 1 ) , ( D91 . ( 1 + 2 ) ) , C177 by L643 , GLIB_001:def 3;
L645: ( D91 . 2 ) Joins C180 , ( D91 . 3 ) , C177 by L644 , L617 , GLIB_001:def 6;
L646: ( the_Vertices_of C183 ) = ( D83 .reachableFrom D89 ) by L502;
thus L647: contradiction by L646 , L612 , L645 , L641;
end;
consider C186 being (Vertex of C183), C187 being set such that L648: C187 Joins C180 , C186 , C177 by L611;
L649: C187 in ( the_Edges_of C177 ) by L648 , GLIB_000:def 13;
L650:
now
per cases ;
suppose L651: C183 is  trivial;

consider C188 being (Vertex of C183) such that L652: ( the_Vertices_of C183 ) = { C188 } by L651 , GLIB_000:22;
L653: ( the_Vertices_of C183 ) c= ( the_Vertices_of D83 );
reconsider D94 = C188 as (Vertex of D83) by L653 , TARSKI:def 3;
reconsider D95 = D94 as (Vertex of C177) by GLIB_000:42;
take D96 = D95;
thus L654: D96 in ( the_Vertices_of C183 );
L655: (not D94 in { C180 }) by L605 , XBOOLE_0:def 5;
L656: D94 <> C180 by L655 , TARSKI:def 1;
L657: { D94 } = ( D83 .reachableFrom D94 ) by L652 , L502;
L658:
now
set D97 = the (removeVertex of C177 , D96);
L659:
now
let C189 , C190 being set;
assume L660: C189 Joins D96 , C190 , C177;
L661: C189 in ( the_Edges_of C177 ) by L660 , GLIB_000:def 13;
L662:
now
assume that
L663: C190 <> D96
and
L664: C190 <> C180;
L665: (not C189 in ( C180 .edgesInOut() )) by L656 , L660 , L664 , GLIB_000:65;
L666: C189 in ( the_Edges_of D83 ) by L665 , L608 , L661 , XBOOLE_0:def 5;
L667: C189 Joins D96 , C190 , D83 by L666 , L660 , GLIB_000:73;
L668: C190 in ( D83 .reachableFrom D94 ) by L667 , L194 , L197;
thus L669: contradiction by L668 , L657 , L663 , TARSKI:def 1;
end;
thus L670: (C190 = D96 or C190 = C180) by L662;
end;
L671:
now
let C191 , C192 being (Vertex of D97);
L672:
now
per cases ;
suppose L673: C191 = C192;

set D98 = ( D97 .walkOf C191 );
take D99 = D98;
thus L674: D99 is_Walk_from C191 , C192 by L673 , GLIB_001:13;
end;
suppose L675: C191 <> C192;

reconsider D100 = C191 , D101 = C192 as (Vertex of C177) by GLIB_000:42;
consider C193 being (Walk of C177) such that L676: C193 is_Walk_from D100 , D101 by L1;
set D102 = the (Path of C193);
L677: D102 is_Walk_from D100 , D101 by L676 , GLIB_001:160;
L678: ( the_Vertices_of D97 ) = ( ( the_Vertices_of C177 ) \ { D96 } ) by GLIB_000:47;
L679: (not C191 in { D96 }) by L678 , XBOOLE_0:def 5;
L680: C191 <> D96 by L679 , TARSKI:def 1;
L681: D96 <> ( D102 . 1 ) by L680 , L677 , GLIB_001:17;
L682: (not C192 in { D96 }) by L678 , XBOOLE_0:def 5;
L683: C192 <> D96 by L682 , TARSKI:def 1;
L684: D96 <> ( D102 . ( len D102 ) ) by L683 , L677 , GLIB_001:17;
L685:
now
assume L686: D96 in ( D102 .vertices() );
consider C194 being  odd (Element of ( NAT )) such that L687: C194 <= ( len D102 ) and L688: ( D102 . C194 ) = D96 by L686 , GLIB_001:87;
L689: 1 <= C194 by ABIAN:12;
L690: 1 < C194 by L689 , L681 , L688 , XXREAL_0:1;
L691: ( 1 + 1 ) <= C194 by L690 , NAT_1:13;
reconsider D103 = ( C194 - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by L691 , INT_1:5;
L692:
now
L693: D103 < ( C194 - ( 0 ) ) by XREAL_1:15;
assume L694: ( D102 . D103 ) = D96;
thus L695: contradiction by L694 , L681 , L687 , L688 , L693 , GLIB_001:def 28;
end;
set D104 = ( D102 . ( D103 + 1 ) );
set D105 = ( D102 . ( C194 + 1 ) );
L696: ( C194 - 2 ) < ( ( len D102 ) - ( 0 ) ) by L687 , XREAL_1:15;
L697: D104 Joins ( D102 . D103 ) , ( D102 . ( D103 + 2 ) ) , C177 by L696 , GLIB_001:def 3;
L698: ( D102 . D103 ) = C180 by L697 , L659 , L688 , L692 , GLIB_000:14;
L699: C194 < ( len D102 ) by L684 , L687 , L688 , XXREAL_0:1;
L700: ( C194 + 2 ) <= ( len D102 ) by L699 , GLIB_001:1;
L701:
now
L702: ( C194 + ( 0 ) ) < ( C194 + 2 ) by XREAL_1:8;
assume L703: ( D102 . ( C194 + 2 ) ) = D96;
thus L704: contradiction by L703 , L681 , L688 , L700 , L702 , GLIB_001:def 28;
end;
L705: D103 < ( C194 - ( 0 ) ) by XREAL_1:15;
L706: ( D103 + ( 0 ) ) < ( C194 + 2 ) by L705 , XREAL_1:8;
L707: D105 Joins D96 , ( D102 . ( C194 + 2 ) ) , C177 by L688 , L699 , GLIB_001:def 3;
L708: ( D102 . ( C194 + 2 ) ) = C180 by L707 , L659 , L701;
L709: C180 = ( D102 . 1 ) by L708 , L698 , L700 , L706 , GLIB_001:def 28;
L710: C180 = C191 by L709 , L677 , GLIB_001:17;
L711: C180 = ( D102 . ( len D102 ) ) by L698 , L700 , L708 , L706 , GLIB_001:def 28;
thus L712: contradiction by L711 , L675 , L677 , L710 , GLIB_001:17;
end;
reconsider D106 = D102 as (Walk of D97) by L685 , GLIB_001:171;
take D107 = D106;
thus L713: D107 is_Walk_from C191 , C192 by L677 , GLIB_001:19;
end;
end;
thus L715: (ex B132 being (Walk of D97) st B132 is_Walk_from C191 , C192) by L672;
end;
L716: D97 is  connected by L671 , L1;
assume L717: D96 is  cut-vertex;
L718: 1 < ( D97 .numComponents() ) by L717 , L590 , L312;
thus L719: contradiction by L718 , L716 , L546;
end;
thus L720: (not D96 is  cut-vertex) by L658;
end;
suppose L721: C183 is non  trivial;

reconsider D108 = C183 as non  trivial _Graph by L721;
L722: ( ( C183 .order() ) + ( 0 ) ) < ( ( D83 .order() ) + 1 ) by GLIB_000:75 , XREAL_1:8;
consider C195 , C196 being (Vertex of D108) such that L723: C195 <> C196 and L724: (not C195 is  cut-vertex) and L725: (not C196 is  cut-vertex) by L722 , L587 , L609;
set D109 = the (removeVertex of D108 , C195);
L726: D109 is  connected by L724 , L578;
set D110 = the (removeVertex of D108 , C196);
L727: ( the_Vertices_of D109 ) = ( ( the_Vertices_of D108 ) \ { C195 } ) by GLIB_000:47;
L728: C196 in ( the_Vertices_of D83 ) by GLIB_000:42;
L729: (not C196 in { C180 }) by L728 , L605 , XBOOLE_0:def 5;
L730: C196 <> C180 by L729 , TARSKI:def 1;
L731: ( the_Vertices_of D110 ) = ( ( the_Vertices_of D108 ) \ { C196 } ) by GLIB_000:47;
L732: C195 in ( the_Vertices_of D83 ) by GLIB_000:42;
L733: (not C195 in { C180 }) by L732 , L605 , XBOOLE_0:def 5;
L734: C195 <> C180 by L733 , TARSKI:def 1;
L735: D110 is  connected by L725 , L578;
L736:
now
per cases ;
suppose L737: (not C195 in ( C180 .allNeighbors() ));

reconsider D111 = C195 as (Vertex of D83) by GLIB_000:42;
reconsider D112 = D111 as (Vertex of C177) by GLIB_000:42;
take D113 = D112;
thus L738: D113 in ( the_Vertices_of C183 );
set D114 = the (removeVertex of C177 , D113);
L739: ( the_Vertices_of D114 ) = ( ( the_Vertices_of C177 ) \ { D113 } ) by GLIB_000:47;
L740: (not C180 in { D113 }) by L734 , TARSKI:def 1;
reconsider D115 = C180 as (Vertex of D114) by L740 , L739 , XBOOLE_0:def 5;
L741: C195 <> C186 by L648 , L737 , GLIB_000:71;
L742: ( the_Vertices_of C183 ) = ( D83 .reachableFrom D111 ) by L502;
L743:
now
let C197 being (Vertex of D114);
L744:
now
per cases ;
suppose L745: C197 = C180;

L746: ( D114 .walkOf C197 ) is_Walk_from D115 , C197 by L745 , GLIB_001:13;
thus L747: (ex B133 being (Walk of D114) st B133 is_Walk_from D115 , C197) by L746;
end;
suppose L748: C197 <> C180;

L749:
now
per cases ;
suppose L750: C197 in ( the_Vertices_of C183 );

L751: (not C186 in { C195 }) by L741 , TARSKI:def 1;
L752: C186 in ( the_Vertices_of D109 ) by L751 , L727 , XBOOLE_0:def 5;
L753: (not C197 in { C195 }) by L739 , XBOOLE_0:def 5;
L754: C197 in ( the_Vertices_of D109 ) by L753 , L727 , L750 , XBOOLE_0:def 5;
consider C198 being (Walk of D109) such that L755: C198 is_Walk_from C197 , C186 by L754 , L726 , L752 , L1;
L756: (( C198 . 1 ) = C197 & ( C198 . ( len C198 ) ) = C186) by L755 , GLIB_001:17;
L757:
now
assume L758: D113 in ( C198 .vertices() );
L759: (not D113 in { C195 }) by L758 , L727 , XBOOLE_0:def 5;
thus L760: contradiction by L759 , TARSKI:def 1;
end;
L761: (not C187 in ( D113 .edgesInOut() )) by L648 , L734 , L741 , GLIB_000:65;
L762: C187 in ( ( the_Edges_of C177 ) \ ( D113 .edgesInOut() ) ) by L761 , L649 , XBOOLE_0:def 5;
L763: C187 in ( ( the_Edges_of C177 ) \ ( C177 .edgesInOut { D113 } ) ) by L762 , GLIB_000:def 40;
L764: C187 in ( C177 .edgesBetween ( ( the_Vertices_of C177 ) \ { D113 } ) ) by L763 , GLIB_000:35;
L765: C187 in ( the_Edges_of D114 ) by L764 , GLIB_000:47;
L766: C187 Joins C180 , C186 , D114 by L765 , L648 , GLIB_000:73;
L767: C187 Joins C186 , C180 , D114 by L766 , GLIB_000:14;
reconsider D116 = C198 as (Walk of C183) by GLIB_001:167;
reconsider D117 = D116 as (Walk of D83) by GLIB_001:167;
reconsider D118 = D117 as (Walk of C177) by GLIB_001:167;
L768: (not D113 in ( D118 .vertices() )) by L757 , GLIB_001:98;
reconsider D119 = D118 as (Walk of D114) by L768 , GLIB_001:171;
L769: D119 is_Walk_from C197 , C186 by L756 , GLIB_001:17;
L770: ( D119 .addEdge C187 ) is_Walk_from C197 , C180 by L769 , L767 , GLIB_001:66;
L771: ( ( D119 .addEdge C187 ) .reverse() ) is_Walk_from C180 , C197 by L770 , GLIB_001:23;
thus L772: (ex B134 being (Walk of D114) st B134 is_Walk_from D115 , C197) by L771;
end;
suppose L773: (not C197 in ( the_Vertices_of C183 ));

reconsider D120 = C197 as (Vertex of C177) by GLIB_000:42;
consider C199 being (Walk of C177) such that L774: C199 is_Walk_from C180 , D120 by L1;
set D121 = the (Path of C199);
L775: D121 is_Walk_from C180 , D120 by L774 , GLIB_001:160;
L776: ( D121 . ( len D121 ) ) = D120 by L775 , GLIB_001:17;
L777: ( D121 . 1 ) = C180 by L775 , GLIB_001:17;
L778:
now
assume L779: D113 in ( D121 .vertices() );
consider C200 being  odd (Element of ( NAT )) such that L780: C200 <= ( len D121 ) and L781: ( D121 . C200 ) = D113 by L779 , GLIB_001:87;
set D122 = ( D121 .cut (C200 , ( len D121 )) );
L782: D122 is_Walk_from D113 , D120 by L776 , L780 , L781 , GLIB_001:37;
L783: 1 <= C200 by ABIAN:12;
L784: 1 < C200 by L783 , L734 , L777 , L781 , XXREAL_0:1;
L785:
now
assume L786: C180 in ( D122 .vertices() );
consider C201 being  odd (Element of ( NAT )) such that L787: C201 <= ( len D122 ) and L788: ( D122 . C201 ) = C180 by L786 , GLIB_001:87;
L789: 1 <= C201 by ABIAN:12;
L790: C201 in ( dom D122 ) by L789 , L787 , FINSEQ_3:25;
L791: ( D121 . ( ( C200 + C201 ) - 1 ) ) = C180 by L790 , L780 , L788 , GLIB_001:47;
L792: ( 1 + 1 ) < ( C200 + C201 ) by L784 , ABIAN:12 , XREAL_1:8;
L793: ( ( 1 + 1 ) - 1 ) < ( ( C200 + C201 ) - 1 ) by L792 , XREAL_1:14;
L794: ( ( 2 * ( 0 ) ) + 1 ) < ( ( C200 + C201 ) - 1 ) by L793;
L795: ( ( C200 + C201 ) - 1 ) in ( dom D121 ) by L780 , L790 , GLIB_001:47;
L796: ( ( C200 + C201 ) - 1 ) <= ( len D121 ) by L795 , FINSEQ_3:25;
thus L797: contradiction by L796 , L748 , L777 , L776 , L791 , L795 , L794 , GLIB_001:def 28;
end;
reconsider D123 = D122 as (Walk of D83) by L785 , GLIB_001:171;
L798: D123 is_Walk_from D113 , D120 by L782 , GLIB_001:19;
thus L799: contradiction by L798 , L742 , L773 , L156;
end;
reconsider D124 = D121 as (Walk of D114) by L778 , GLIB_001:171;
take D125 = D124;
thus L800: D125 is_Walk_from D115 , C197 by L775 , GLIB_001:19;
end;
end;
thus L802: (ex B135 being (Walk of D114) st B135 is_Walk_from D115 , C197) by L749;
end;
end;
thus L804: (ex B136 being (Walk of D114) st B136 is_Walk_from D115 , C197) by L744;
end;
L805: D114 is  connected by L743 , L396;
L806: ( D114 .numComponents() ) = 1 by L805 , L546;
thus L807: (not D113 is  cut-vertex) by L806 , L590 , L312;
end;
suppose L808: (C195 in ( C180 .allNeighbors() ) & (not C196 in ( C180 .allNeighbors() )));

reconsider D126 = C196 as (Vertex of D83) by GLIB_000:42;
reconsider D127 = D126 as (Vertex of C177) by GLIB_000:42;
take D128 = D127;
thus L809: D128 in ( the_Vertices_of C183 );
set D129 = the (removeVertex of C177 , D128);
L810: ( the_Vertices_of D129 ) = ( ( the_Vertices_of C177 ) \ { D128 } ) by GLIB_000:47;
L811: (not C180 in { D128 }) by L730 , TARSKI:def 1;
reconsider D130 = C180 as (Vertex of D129) by L811 , L810 , XBOOLE_0:def 5;
L812: C196 <> C186 by L648 , L808 , GLIB_000:71;
L813: ( the_Vertices_of C183 ) = ( D83 .reachableFrom D126 ) by L502;
L814:
now
let C202 being (Vertex of D129);
L815:
now
per cases ;
suppose L816: C202 = C180;

L817: ( D129 .walkOf C202 ) is_Walk_from D130 , C202 by L816 , GLIB_001:13;
thus L818: (ex B137 being (Walk of D129) st B137 is_Walk_from D130 , C202) by L817;
end;
suppose L819: C202 <> C180;

L820:
now
per cases ;
suppose L821: C202 in ( the_Vertices_of C183 );

L822: (not C186 in { C196 }) by L812 , TARSKI:def 1;
L823: C186 in ( the_Vertices_of D110 ) by L822 , L731 , XBOOLE_0:def 5;
L824: (not C202 in { C196 }) by L810 , XBOOLE_0:def 5;
L825: C202 in ( the_Vertices_of D110 ) by L824 , L731 , L821 , XBOOLE_0:def 5;
consider C203 being (Walk of D110) such that L826: C203 is_Walk_from C202 , C186 by L825 , L735 , L823 , L1;
L827: (( C203 . 1 ) = C202 & ( C203 . ( len C203 ) ) = C186) by L826 , GLIB_001:17;
L828:
now
assume L829: D128 in ( C203 .vertices() );
L830: (not D128 in { C196 }) by L829 , L731 , XBOOLE_0:def 5;
thus L831: contradiction by L830 , TARSKI:def 1;
end;
L832: (not C187 in ( D128 .edgesInOut() )) by L648 , L730 , L812 , GLIB_000:65;
L833: C187 in ( ( the_Edges_of C177 ) \ ( D128 .edgesInOut() ) ) by L832 , L649 , XBOOLE_0:def 5;
L834: C187 in ( ( the_Edges_of C177 ) \ ( C177 .edgesInOut { D128 } ) ) by L833 , GLIB_000:def 40;
L835: C187 in ( C177 .edgesBetween ( ( the_Vertices_of C177 ) \ { D128 } ) ) by L834 , GLIB_000:35;
L836: C187 in ( the_Edges_of D129 ) by L835 , GLIB_000:47;
L837: C187 Joins C180 , C186 , D129 by L836 , L648 , GLIB_000:73;
L838: C187 Joins C186 , C180 , D129 by L837 , GLIB_000:14;
reconsider D131 = C203 as (Walk of C183) by GLIB_001:167;
reconsider D132 = D131 as (Walk of D83) by GLIB_001:167;
reconsider D133 = D132 as (Walk of C177) by GLIB_001:167;
L839: (not D128 in ( D133 .vertices() )) by L828 , GLIB_001:98;
reconsider D134 = D133 as (Walk of D129) by L839 , GLIB_001:171;
L840: D134 is_Walk_from C202 , C186 by L827 , GLIB_001:17;
L841: ( D134 .addEdge C187 ) is_Walk_from C202 , C180 by L840 , L838 , GLIB_001:66;
L842: ( ( D134 .addEdge C187 ) .reverse() ) is_Walk_from C180 , C202 by L841 , GLIB_001:23;
thus L843: (ex B138 being (Walk of D129) st B138 is_Walk_from D130 , C202) by L842;
end;
suppose L844: (not C202 in ( the_Vertices_of C183 ));

reconsider D135 = C202 as (Vertex of C177) by GLIB_000:42;
consider C204 being (Walk of C177) such that L845: C204 is_Walk_from C180 , D135 by L1;
set D136 = the (Path of C204);
L846: D136 is_Walk_from C180 , D135 by L845 , GLIB_001:160;
L847: ( D136 . ( len D136 ) ) = D135 by L846 , GLIB_001:17;
L848: ( D136 . 1 ) = C180 by L846 , GLIB_001:17;
L849:
now
assume L850: D128 in ( D136 .vertices() );
consider C205 being  odd (Element of ( NAT )) such that L851: C205 <= ( len D136 ) and L852: ( D136 . C205 ) = D128 by L850 , GLIB_001:87;
set D137 = ( D136 .cut (C205 , ( len D136 )) );
L853: D137 is_Walk_from D128 , D135 by L847 , L851 , L852 , GLIB_001:37;
L854: 1 <= C205 by ABIAN:12;
L855: 1 < C205 by L854 , L730 , L848 , L852 , XXREAL_0:1;
L856:
now
assume L857: C180 in ( D137 .vertices() );
consider C206 being  odd (Element of ( NAT )) such that L858: C206 <= ( len D137 ) and L859: ( D137 . C206 ) = C180 by L857 , GLIB_001:87;
L860: 1 <= C206 by ABIAN:12;
L861: C206 in ( dom D137 ) by L860 , L858 , FINSEQ_3:25;
L862: ( D136 . ( ( C205 + C206 ) - 1 ) ) = C180 by L861 , L851 , L859 , GLIB_001:47;
L863: ( 1 + 1 ) < ( C205 + C206 ) by L855 , ABIAN:12 , XREAL_1:8;
L864: ( ( 1 + 1 ) - 1 ) < ( ( C205 + C206 ) - 1 ) by L863 , XREAL_1:14;
L865: ( ( 2 * ( 0 ) ) + 1 ) < ( ( C205 + C206 ) - 1 ) by L864;
L866: ( ( C205 + C206 ) - 1 ) in ( dom D136 ) by L851 , L861 , GLIB_001:47;
L867: ( ( C205 + C206 ) - 1 ) <= ( len D136 ) by L866 , FINSEQ_3:25;
thus L868: contradiction by L867 , L819 , L848 , L847 , L862 , L866 , L865 , GLIB_001:def 28;
end;
reconsider D138 = D137 as (Walk of D83) by L856 , GLIB_001:171;
L869: D138 is_Walk_from D128 , D135 by L853 , GLIB_001:19;
thus L870: contradiction by L869 , L813 , L844 , L156;
end;
reconsider D139 = D136 as (Walk of D129) by L849 , GLIB_001:171;
take D140 = D139;
thus L871: D140 is_Walk_from D130 , C202 by L846 , GLIB_001:19;
end;
end;
thus L873: (ex B139 being (Walk of D129) st B139 is_Walk_from D130 , C202) by L820;
end;
end;
thus L875: (ex B140 being (Walk of D129) st B140 is_Walk_from D130 , C202) by L815;
end;
L876: D129 is  connected by L814 , L396;
L877: ( D129 .numComponents() ) = 1 by L876 , L546;
thus L878: (not D128 is  cut-vertex) by L877 , L590 , L312;
end;
suppose L879: (C195 in ( C180 .allNeighbors() ) & C196 in ( C180 .allNeighbors() ));

consider C207 being set such that L880: C207 Joins C180 , C196 , C177 by L879 , GLIB_000:71;
reconsider D141 = C195 as (Vertex of D83) by GLIB_000:42;
set D142 = C196;
reconsider D143 = D141 as (Vertex of C177) by GLIB_000:42;
take D144 = D143;
thus L881: D144 in ( the_Vertices_of C183 );
set D145 = the (removeVertex of C177 , D144);
L882: ( the_Vertices_of D145 ) = ( ( the_Vertices_of C177 ) \ { D144 } ) by GLIB_000:47;
L883: (not C180 in { D144 }) by L734 , TARSKI:def 1;
reconsider D146 = C180 as (Vertex of D145) by L883 , L882 , XBOOLE_0:def 5;
L884: ( the_Vertices_of C183 ) = ( D83 .reachableFrom D141 ) by L502;
L885: C207 in ( the_Edges_of C177 ) by L880 , GLIB_000:def 13;
L886:
now
let C208 being (Vertex of D145);
L887:
now
per cases ;
suppose L888: C208 = C180;

L889: ( D145 .walkOf C208 ) is_Walk_from D146 , C208 by L888 , GLIB_001:13;
thus L890: (ex B141 being (Walk of D145) st B141 is_Walk_from D146 , C208) by L889;
end;
suppose L891: C208 <> C180;

L892:
now
per cases ;
suppose L893: C208 in ( the_Vertices_of C183 );

L894: (not D142 in { C195 }) by L723 , TARSKI:def 1;
L895: D142 in ( the_Vertices_of D109 ) by L894 , L727 , XBOOLE_0:def 5;
L896: (not C208 in { C195 }) by L882 , XBOOLE_0:def 5;
L897: C208 in ( the_Vertices_of D109 ) by L896 , L727 , L893 , XBOOLE_0:def 5;
consider C209 being (Walk of D109) such that L898: C209 is_Walk_from C208 , D142 by L897 , L726 , L895 , L1;
L899: (( C209 . 1 ) = C208 & ( C209 . ( len C209 ) ) = D142) by L898 , GLIB_001:17;
L900:
now
assume L901: D144 in ( C209 .vertices() );
L902: (not D144 in { C195 }) by L901 , L727 , XBOOLE_0:def 5;
thus L903: contradiction by L902 , TARSKI:def 1;
end;
L904: (not C207 in ( D144 .edgesInOut() )) by L723 , L734 , L880 , GLIB_000:65;
L905: C207 in ( ( the_Edges_of C177 ) \ ( D144 .edgesInOut() ) ) by L904 , L885 , XBOOLE_0:def 5;
L906: C207 in ( ( the_Edges_of C177 ) \ ( C177 .edgesInOut { D144 } ) ) by L905 , GLIB_000:def 40;
L907: C207 in ( C177 .edgesBetween ( ( the_Vertices_of C177 ) \ { D144 } ) ) by L906 , GLIB_000:35;
L908: C207 in ( the_Edges_of D145 ) by L907 , GLIB_000:47;
L909: C207 Joins C180 , D142 , D145 by L908 , L880 , GLIB_000:73;
L910: C207 Joins D142 , C180 , D145 by L909 , GLIB_000:14;
reconsider D147 = C209 as (Walk of C183) by GLIB_001:167;
reconsider D148 = D147 as (Walk of D83) by GLIB_001:167;
reconsider D149 = D148 as (Walk of C177) by GLIB_001:167;
L911: (not D144 in ( D149 .vertices() )) by L900 , GLIB_001:98;
reconsider D150 = D149 as (Walk of D145) by L911 , GLIB_001:171;
L912: D150 is_Walk_from C208 , D142 by L899 , GLIB_001:17;
L913: ( D150 .addEdge C207 ) is_Walk_from C208 , C180 by L912 , L910 , GLIB_001:66;
L914: ( ( D150 .addEdge C207 ) .reverse() ) is_Walk_from C180 , C208 by L913 , GLIB_001:23;
thus L915: (ex B142 being (Walk of D145) st B142 is_Walk_from D146 , C208) by L914;
end;
suppose L916: (not C208 in ( the_Vertices_of C183 ));

reconsider D151 = C208 as (Vertex of C177) by GLIB_000:42;
consider C210 being (Walk of C177) such that L917: C210 is_Walk_from C180 , D151 by L1;
set D152 = the (Path of C210);
L918: D152 is_Walk_from C180 , D151 by L917 , GLIB_001:160;
L919: ( D152 . ( len D152 ) ) = D151 by L918 , GLIB_001:17;
L920: ( D152 . 1 ) = C180 by L918 , GLIB_001:17;
L921:
now
assume L922: D144 in ( D152 .vertices() );
consider C211 being  odd (Element of ( NAT )) such that L923: C211 <= ( len D152 ) and L924: ( D152 . C211 ) = D144 by L922 , GLIB_001:87;
set D153 = ( D152 .cut (C211 , ( len D152 )) );
L925: D153 is_Walk_from D144 , D151 by L919 , L923 , L924 , GLIB_001:37;
L926: 1 <= C211 by ABIAN:12;
L927: 1 < C211 by L926 , L734 , L920 , L924 , XXREAL_0:1;
L928:
now
assume L929: C180 in ( D153 .vertices() );
consider C212 being  odd (Element of ( NAT )) such that L930: C212 <= ( len D153 ) and L931: ( D153 . C212 ) = C180 by L929 , GLIB_001:87;
L932: 1 <= C212 by ABIAN:12;
L933: C212 in ( dom D153 ) by L932 , L930 , FINSEQ_3:25;
L934: ( D152 . ( ( C211 + C212 ) - 1 ) ) = C180 by L933 , L923 , L931 , GLIB_001:47;
L935: ( 1 + 1 ) < ( C211 + C212 ) by L927 , ABIAN:12 , XREAL_1:8;
L936: ( ( 1 + 1 ) - 1 ) < ( ( C211 + C212 ) - 1 ) by L935 , XREAL_1:14;
L937: ( ( 2 * ( 0 ) ) + 1 ) < ( ( C211 + C212 ) - 1 ) by L936;
L938: ( ( C211 + C212 ) - 1 ) in ( dom D152 ) by L923 , L933 , GLIB_001:47;
L939: ( ( C211 + C212 ) - 1 ) <= ( len D152 ) by L938 , FINSEQ_3:25;
thus L940: contradiction by L939 , L891 , L920 , L919 , L934 , L938 , L937 , GLIB_001:def 28;
end;
reconsider D154 = D153 as (Walk of D83) by L928 , GLIB_001:171;
L941: D154 is_Walk_from D144 , D151 by L925 , GLIB_001:19;
thus L942: contradiction by L941 , L884 , L916 , L156;
end;
reconsider D155 = D152 as (Walk of D145) by L921 , GLIB_001:171;
take D156 = D155;
thus L943: D156 is_Walk_from D146 , C208 by L918 , GLIB_001:19;
end;
end;
thus L945: (ex B143 being (Walk of D145) st B143 is_Walk_from D146 , C208) by L892;
end;
end;
thus L947: (ex B144 being (Walk of D145) st B144 is_Walk_from D146 , C208) by L887;
end;
L948: D145 is  connected by L886 , L396;
L949: ( D145 .numComponents() ) = 1 by L948 , L546;
thus L950: (not D144 is  cut-vertex) by L949 , L590 , L312;
end;
end;
thus L952: (ex B145 being (Vertex of C177) st (B145 in ( the_Vertices_of C183 ) & (not B145 is  cut-vertex))) by L736;
end;
end;
thus L954: (ex B146 being (Vertex of C177) st (B146 in ( the_Vertices_of C183 ) & (not B146 is  cut-vertex))) by L650;
end;
consider C213 being (Vertex of C177) such that L955: C213 in ( the_Vertices_of D86 ) and L956: (not C213 is  cut-vertex) by L610;
consider C214 being (Vertex of C177) such that L957: C214 in ( the_Vertices_of D87 ) and L958: (not C214 is  cut-vertex) by L610;
take D157 = C213;
take D158 = C214;
L959:
now
L960: D85 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of D83 )) by L474;
L961: ( the_Vertices_of D87 ) = D85 by L960 , GLIB_000:def 37;
L962: D84 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of D83 )) by L474;
L963: ( the_Vertices_of D86 ) = D84 by L962 , GLIB_000:def 37;
assume L964: D157 = D158;
L965: D86 == D87 by L964 , L955 , L957 , L541;
thus L966: contradiction by L965 , L604 , L963 , L961 , GLIB_000:def 34;
end;
thus L967: D157 <> D158 by L959;
thus L968: ((not D157 is  cut-vertex) & (not D158 is  cut-vertex)) by L956 , L958;
end;
end;
thus L970: (ex B147 , B148 being (Vertex of C177) st (B147 <> B148 & (not B147 is  cut-vertex) & (not B148 is  cut-vertex))) by L591;
end;
thus L971: S5[ C176 ] by L588;
end;
L972: (for B149 being Nat holds ((for B150 being Nat holds (B150 < B149 implies S5[ B150 ])) implies S5[ B149 ])) by L586;
L973: (for B151 being Nat holds S5[ B151 ]) from NAT_1:sch 4(L972);
L974: ( C175 .order() ) = ( C175 .order() );
thus L975: thesis by L974 , L973;
end;
registration
let C215 being non  trivial  finite  connected _Graph;
cluster non  cut-vertex for (Vertex of C215);
existence
proof
L976: (ex B152 , B153 being (Vertex of C215) st (B152 <> B153 & (not B152 is  cut-vertex) & (not B153 is  cut-vertex))) by L585;
thus L977: thesis by L976;
end;
end;
L979: (for B154 being  acyclic _Graph holds (for B155 being (Path of B154) holds (for B156 being set holds (((not B156 in ( B155 .edges() )) & B156 in ( ( B155 .last() ) .edgesInOut() )) implies ( B155 .addEdge B156 ) is  Path-like))))
proof
let C216 being  acyclic _Graph;
let C217 being (Path of C216);
let C218 being set;
assume that
L980: (not C218 in ( C217 .edges() ))
and
L981: C218 in ( ( C217 .last() ) .edgesInOut() );
set D159 = ( ( C217 .last() ) .adj C218 );
set D160 = ( C217 .addEdge C218 );
L982: C218 Joins ( C217 .last() ) , ( ( C217 .last() ) .adj C218 ) , C216 by L981 , GLIB_000:67;
L983: ( len D160 ) = ( ( len C217 ) + 2 ) by L982 , GLIB_001:64;
L984: D160 is  Trail-like by L980 , L981 , GLIB_001:142;
L985:
now
per cases ;
suppose L986: C217 is  trivial;

L987: (for B157 being  odd (Element of ( NAT )) holds ((1 < B157 & B157 <= ( len C217 )) implies ( C217 . B157 ) <> D159)) by L986 , GLIB_001:126;
thus L988: thesis by L987 , L980 , L982 , L986 , GLIB_001:150;
end;
suppose L989: C217 is non  trivial;

L990:
now
let C219 being  odd (Element of ( NAT ));
assume that
L991: 1 < C219
and
L992: C219 <= ( len C217 );
L993:
now
set D161 = ( D160 .cut (C219 , ( len D160 )) );
assume L994: ( C217 . C219 ) = D159;
L995: C219 <= ( len D160 ) by L983 , L992 , NAT_1:12;
L996: ( D161 .first() ) = ( D160 . C219 ) by L995 , GLIB_001:37;
L997:
now
assume L998: D161 is  trivial;
L999: ( len D161 ) = 1 by L998 , GLIB_001:126;
L1000: ( 1 + C219 ) = ( ( len D160 ) + 1 ) by L999 , L995 , GLIB_001:36;
L1001: ( ( 2 + ( len C217 ) ) - ( len C217 ) ) <= ( ( len C217 ) - ( len C217 ) ) by L1000 , L983 , L992 , XREAL_1:13;
L1002: 2 <= ( 0 ) by L1001;
thus L1003: contradiction by L1002;
end;
consider C220 being (Path of D161) such that L1004: C220 is non  trivial by L997 , L984 , GLIB_001:166;
L1005: ( D161 .last() ) = ( D160 . ( len D160 ) ) by L995 , GLIB_001:37;
L1006: ( D161 .last() ) = ( D160 .last() ) by L1005 , GLIB_001:def 7
.= D159 by L982 , GLIB_001:63;
L1007: C219 in ( dom C217 ) by L991 , L992 , FINSEQ_3:25;
L1008: ( D161 .first() ) = D159 by L1007 , L982 , L994 , L996 , GLIB_001:65;
L1009: C220 is_Walk_from D159 , D159 by L1008 , L1006 , GLIB_001:def 32;
L1010: C220 is  closed by L1009 , GLIB_001:119;
L1011: C220 is  Cycle-like by L1010 , L1004 , GLIB_001:def 31;
thus L1012: contradiction by L1011 , L3;
end;
thus L1013: ( C217 . C219 ) <> D159 by L993;
end;
L1014:
now
assume L1015: C217 is  closed;
L1016: C217 is  Cycle-like by L1015 , L989 , GLIB_001:def 31;
thus L1017: contradiction by L1016 , L3;
end;
thus L1018: thesis by L1014 , L980 , L982 , L990 , GLIB_001:150;
end;
end;
thus L1020: thesis by L985;
end;
L1021: (for B158 being non  trivial  finite  acyclic _Graph holds (( the_Edges_of B158 ) <> ( {} ) implies (ex B159 , B160 being (Vertex of B158) st (B159 <> B160 & B159 is  endvertex & B160 is  endvertex & B160 in ( B158 .reachableFrom B159 )))))
proof
let C221 being non  trivial  finite  acyclic _Graph;
assume that
L1022: ( the_Edges_of C221 ) <> ( {} );
defpred S6[ Nat ] means (ex B161 being (Path of C221) st ( len B161 ) = $1);
set D162 = ( choose ( the_Edges_of C221 ) );
L1023:
now
let C222 being Nat;
assume L1024: S6[ C222 ];
consider C223 being (Path of C221) such that L1025: ( len C223 ) = C222 by L1024;
L1026: ( 2 * ( len ( C223 .vertexSeq() ) ) ) <= ( 2 * ( ( C221 .order() ) + 1 ) ) by GLIB_001:154 , XREAL_1:64;
L1027: ( C222 + 1 ) <= ( 2 * ( ( C221 .order() ) + 1 ) ) by L1026 , L1025 , GLIB_001:def 14;
L1028: ( ( C222 + 1 ) - 1 ) <= ( ( 2 * ( ( C221 .order() ) + 1 ) ) - ( 0 ) ) by L1027 , XREAL_1:13;
thus L1029: C222 <= ( 2 * ( ( C221 .order() ) + 1 ) ) by L1028;
end;
set D163 = ( ( the_Source_of C221 ) . D162 );
set D164 = ( ( the_Target_of C221 ) . D162 );
L1030: D162 Joins D163 , D164 , C221 by L1022 , GLIB_000:def 13;
L1031: ( len ( C221 .walkOf (D163 , D162 , D164) ) ) = 3 by L1030 , GLIB_001:14;
L1032: (ex B162 being Nat st S6[ B162 ]) by L1031;
consider C224 being Nat such that L1033: (S6[ C224 ] & (for B163 being Nat holds (S6[ B163 ] implies B163 <= C224))) from NAT_1:sch 6(L1023 , L1032);
consider C225 being (Path of C221) such that L1034: ( len C225 ) = C224 and L1035: (for B164 being Nat holds (S6[ B164 ] implies B164 <= C224)) by L1033;
L1036: ( len ( C225 .reverse() ) ) = C224 by L1034 , GLIB_001:21;
L1037: 3 <= ( len C225 ) by L1031 , L1034 , L1035;
L1038: C225 is non  trivial by L1037 , GLIB_001:125;
L1039:
now
assume L1040: ( C225 .first() ) = ( C225 .last() );
L1041: C225 is  closed by L1040 , GLIB_001:def 24;
L1042: C225 is  Cycle-like by L1041 , L1038 , GLIB_001:def 31;
thus L1043: contradiction by L1042 , L3;
end;
L1044: C225 is  open by L1039 , GLIB_001:def 24;
L1045:
now
let C226 being (Path of C221);
assume that
L1046: ( len C226 ) = C224
and
L1047: C226 is  open;
L1048: ( 2 + 1 ) <= ( len C226 ) by L1031 , L1035 , L1046;
L1049: 2 < ( len C226 ) by L1048 , NAT_1:13;
reconsider D165 = ( ( len C226 ) - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by L1049 , INT_1:5;
L1050: ( D165 + 2 ) = ( len C226 );
L1051: C226 is non  trivial by L1034 , L1037 , L1046 , GLIB_001:125;
L1052:
now
L1053: ( C226 .last() ) in ( C226 .vertices() ) by GLIB_001:88;
L1054: (not ( C226 .last() ) is  isolated) by L1053 , L1051 , GLIB_001:135;
L1055: ( ( C226 .last() ) .degree() ) <> ( 0 ) by L1054 , GLIB_000:def 50;
L1056: ( card ( ( C226 .last() ) .edgesInOut() ) ) <> ( 0 ) by L1055 , GLIB_000:19;
L1057: ( 0 ) < ( card ( ( C226 .last() ) .edgesInOut() ) ) by L1056 , NAT_1:3;
L1058: ( ( 0 ) + 1 ) <= ( card ( ( C226 .last() ) .edgesInOut() ) ) by L1057 , NAT_1:13;
assume L1059: (not ( C226 .last() ) is  endvertex);
L1060: ( ( C226 .last() ) .degree() ) <> 1 by L1059 , GLIB_000:def 52;
L1061: ( card ( ( C226 .last() ) .edgesInOut() ) ) <> 1 by L1060 , GLIB_000:19;
L1062: 1 < ( card ( ( C226 .last() ) .edgesInOut() ) ) by L1061 , L1058 , XXREAL_0:1;
consider C227 , C228 being set such that L1063: C227 in ( ( C226 .last() ) .edgesInOut() ) and L1064: (C228 in ( ( C226 .last() ) .edgesInOut() ) & C227 <> C228) by L1062 , NAT_1:59;
L1065:
now
per cases ;
suppose L1066: C227 = ( C226 . ( D165 + 1 ) );

take D166 = C228;
thus L1067: (D166 in ( ( C226 .last() ) .edgesInOut() ) & D166 <> ( C226 . ( D165 + 1 ) )) by L1064 , L1066;
end;
suppose L1068: C227 <> ( C226 . ( D165 + 1 ) );

take D167 = C227;
thus L1069: (D167 in ( ( C226 .last() ) .edgesInOut() ) & D167 <> ( C226 . ( D165 + 1 ) )) by L1063 , L1068;
end;
end;
consider C229 being set such that L1071: C229 in ( ( C226 .last() ) .edgesInOut() ) and L1072: C229 <> ( C226 . ( D165 + 1 ) ) by L1065;
consider C230 being (Vertex of C221) such that L1073: C229 Joins ( C226 .last() ) , C230 , C221 by L1071 , GLIB_000:64;
L1074:
now
per cases ;
suppose L1075: C230 in ( C226 .vertices() );

consider C231 being  odd (Element of ( NAT )) such that L1076: C231 <= ( len C226 ) and L1077: ( C226 . C231 ) = C230 by L1075 , GLIB_001:87;
set D168 = ( C226 .rfind C231 );
set D169 = ( C226 .cut (D168 , ( len C226 )) );
L1078: D168 <= ( len C226 ) by L1076 , GLIB_001:def 22;
L1079: ( D169 .last() ) = ( C226 . ( len C226 ) ) by L1078 , GLIB_001:37;
L1080: C229 Joins ( D169 .last() ) , C230 , C221 by L1079 , L1073 , GLIB_001:def 7;
L1081: ( C226 . D168 ) = C230 by L1076 , L1077 , GLIB_001:def 22;
L1082: ( D169 .first() ) = C230 by L1081 , L1078 , GLIB_001:37;
L1083: C229 in ( ( D169 .last() ) .edgesInOut() ) by L1080 , GLIB_000:62;
L1084:
now
per cases ;
suppose L1085: (not C229 in ( D169 .edges() ));

L1086: ( D169 .addEdge C229 ) is non  trivial by L1080 , GLIB_001:132;
L1087: (( ( D169 .addEdge C229 ) .first() ) = C230 & ( ( D169 .addEdge C229 ) .last() ) = C230) by L1082 , L1080 , GLIB_001:63;
L1088: ( D169 .addEdge C229 ) is  closed by L1087 , GLIB_001:def 24;
L1089: ( D169 .addEdge C229 ) is  Path-like by L1083 , L1085 , L979;
L1090: ( D169 .addEdge C229 ) is  Cycle-like by L1089 , L1088 , L1086 , GLIB_001:def 31;
thus L1091: contradiction by L1090 , L3;
end;
suppose L1092: C229 in ( D169 .edges() );

L1093: ( D169 .edges() ) c= ( C226 .edges() ) by GLIB_001:106;
consider C232 being  even (Element of ( NAT )) such that L1094: 1 <= C232 and L1095: C232 <= ( len C226 ) and L1096: ( C226 . C232 ) = C229 by L1093 , L1092 , GLIB_001:99;
reconsider D170 = ( C232 - 1 ) as  odd (Element of ( NAT )) by L1094 , INT_1:5;
L1097: D170 < ( ( len C226 ) - ( 0 ) ) by L1095 , XREAL_1:15;
L1098: C232 < ( D165 + 2 ) by L1095 , XXREAL_0:1;
L1099: ( C232 + 1 ) <= ( ( D165 + 1 ) + 1 ) by L1098 , NAT_1:13;
L1100: C232 <= ( D165 + 1 ) by L1099 , XREAL_1:6;
L1101: C232 < ( D165 + 1 ) by L1100 , L1072 , L1096 , XXREAL_0:1;
L1102: ( D170 + 1 ) = C232;
L1103: C229 Joins ( C226 . D170 ) , ( C226 . ( D170 + 2 ) ) , C221 by L1102 , L1096 , L1097 , GLIB_001:def 3;
L1104:
now
per cases  by L1073 , L1103 , GLIB_000:15;
suppose L1105: (( C226 .last() ) = ( C226 . D170 ) & C230 = ( C226 . ( D170 + 2 ) ));

L1106: ( C226 . ( len C226 ) ) = ( C226 . D170 ) by L1105 , GLIB_001:def 7;
thus L1107: contradiction by L1106 , L1047 , L1097 , GLIB_001:147;
end;
suppose L1108: (( C226 .last() ) = ( C226 . ( D170 + 2 ) ) & C230 = ( C226 . D170 ));

L1109: D170 < ( ( D165 + 1 ) - 1 ) by L1101 , XREAL_1:14;
L1110: ( D170 + 2 ) < ( len C226 ) by L1109 , L1050 , XREAL_1:8;
L1111: ( C226 . ( len C226 ) ) = ( C226 . ( D170 + 2 ) ) by L1108 , GLIB_001:def 7;
thus L1112: contradiction by L1111 , L1047 , L1110 , GLIB_001:147;
end;
end;
thus L1114: contradiction by L1104;
end;
end;
thus L1116: contradiction by L1084;
end;
suppose L1117: (not C230 in ( C226 .vertices() ));

L1118: ( len ( C226 .addEdge C229 ) ) = ( C224 + 2 ) by L1046 , L1073 , GLIB_001:64;
L1119: ( C226 .addEdge C229 ) is  Path-like by L1047 , L1073 , L1117 , GLIB_001:151;
L1120: ( C224 + 2 ) <= ( C224 + ( 0 ) ) by L1119 , L1035 , L1118;
thus L1121: contradiction by L1120 , XREAL_1:6;
end;
end;
thus L1123: contradiction by L1074;
end;
thus L1124: ( C226 .last() ) is  endvertex by L1052;
end;
L1125: C225 is_Walk_from ( C225 .first() ) , ( C225 .last() ) by GLIB_001:def 23;
L1126: ( C225 .last() ) in ( C221 .reachableFrom ( C225 .first() ) ) by L1125 , L156;
L1127: ( C225 .reverse() ) is  open by L1044 , GLIB_001:120;
L1128: ( ( C225 .reverse() ) .last() ) is  endvertex by L1127 , L1045 , L1036;
L1129: ( C225 .first() ) is  endvertex by L1128 , GLIB_001:22;
L1130: ( C225 .last() ) is  endvertex by L1034 , L1044 , L1045;
thus L1131: thesis by L1130 , L1039 , L1129 , L1126;
end;
L1132: (for B165 being non  trivial  finite  Tree-like _Graph holds (ex B166 , B167 being (Vertex of B165) st (B166 <> B167 & B166 is  endvertex & B167 is  endvertex)))
proof
let C233 being non  trivial  finite  Tree-like _Graph;
consider C234 , C235 being (Vertex of C233) such that L1133: C234 <> C235 by GLIB_000:21;
consider C236 being (Walk of C233) such that L1134: C236 is_Walk_from C234 , C235 by L1;
L1135:
now
assume L1136: ( len C236 ) = 1;
L1137: ( C236 .last() ) = ( C236 . 1 ) by L1136 , GLIB_001:def 7
.= ( C236 .first() ) by GLIB_001:def 6;
L1138: ( C236 .first() ) = C234 by L1134 , GLIB_001:def 23;
thus L1139: contradiction by L1138 , L1133 , L1134 , L1137 , GLIB_001:def 23;
end;
L1140: 1 <= ( len C236 ) by ABIAN:12;
L1141: 1 < ( len C236 ) by L1140 , L1135 , XXREAL_0:1;
L1142: ( 1 + 1 ) <= ( len C236 ) by L1141 , NAT_1:13;
L1143: ( 1 + 1 ) in ( dom C236 ) by L1142 , FINSEQ_3:25;
L1144: ( C236 . ( 2 * 1 ) ) in ( the_Edges_of C233 ) by L1143 , GLIB_001:8;
L1145: (ex B168 , B169 being (Vertex of C233) st (B168 <> B169 & B168 is  endvertex & B169 is  endvertex & B169 in ( C233 .reachableFrom B168 ))) by L1144 , L1021;
thus L1146: thesis by L1145;
end;
registration
let C237 being non  trivial  finite  Tree-like _Graph;
cluster  endvertex for (Vertex of C237);
existence
proof
consider C238 , C239 being (Vertex of C237) such that L1147: C238 <> C239 and L1148: C238 is  endvertex and L1149: C239 is  endvertex by L1132;
take C238;
thus L1150: thesis by L1148;
end;
end;
registration
let C240 being non  trivial  finite  Tree-like _Graph;
let C241 being  endvertex (Vertex of C240);
cluster  ->  Tree-like for (removeVertex of C240 , C241);
coherence
proof
let C242 being (removeVertex of C240 , C241);
L1152: C242 is  connected by L324;
thus L1153: thesis by L1152;
end;
end;
definition
let C243 being GraphSeq;
attr C243 is  connected
means
:L1155: (for B170 being Nat holds ( C243 . B170 ) is  connected);
attr C243 is  acyclic
means
:L1156: (for B171 being Nat holds ( C243 . B171 ) is  acyclic);
attr C243 is  Tree-like
means
:L1157: (for B172 being Nat holds ( C243 . B172 ) is  Tree-like);
end;
registration
cluster  trivial ->  connected for GraphSeq;
coherence
proof
let C244 being GraphSeq;
assume L1159: C244 is  trivial;
let C245 being Nat;
reconsider D171 = ( C244 . C245 ) as  trivial _Graph by L1159;
L1160: D171 is  connected;
thus L1161: thesis by L1160;
end;
cluster  trivial  loopless ->  Tree-like for GraphSeq;
coherence
proof
let C246 being GraphSeq;
assume L1162: (C246 is  trivial & C246 is  loopless);
let C247 being Nat;
reconsider D172 = ( C246 . C247 ) as  trivial  loopless _Graph by L1162;
L1163: D172 is  Tree-like;
thus L1164: thesis by L1163;
end;
cluster  acyclic ->  simple for GraphSeq;
coherence
proof
let C248 being GraphSeq;
assume L1165: C248 is  acyclic;
L1166:
now
let C249 being Nat;
reconsider D173 = ( C248 . C249 ) as  acyclic _Graph by L1165 , L1156;
L1167: D173 is  simple;
thus L1168: ( C248 . C249 ) is  simple by L1167;
end;
thus L1169: thesis by L1166 , GLIB_000:def 63;
end;
cluster  Tree-like ->  acyclic  connected for GraphSeq;
coherence
proof
let C250 being GraphSeq;
assume L1170: C250 is  Tree-like;
L1171:
now
let C251 being Nat;
reconsider D174 = ( C250 . C251 ) as  Tree-like _Graph by L1170 , L1157;
L1172: D174 is  acyclic;
thus L1173: (( C250 . C251 ) is  acyclic & ( C250 . C251 ) is  connected) by L1172;
end;
thus L1174: thesis by L1171 , L1155 , L1156;
end;
cluster  acyclic  connected ->  Tree-like for GraphSeq;
coherence
proof
let C252 being GraphSeq;
assume L1175: (C252 is  acyclic & C252 is  connected);
let C253 being Nat;
reconsider D175 = ( C252 . C253 ) as  acyclic  connected _Graph by L1175 , L1155 , L1156;
L1176: D175 is  Tree-like;
thus L1177: thesis by L1176;
end;
end;
registration
cluster  halting  finite  Tree-like for GraphSeq;
existence
proof
set D176 = the  finite  Tree-like _Graph;
set D177 = ( ( NAT ) --> D176 );
L1179: ( dom D177 ) = ( NAT ) by FUNCOP_1:13;
reconsider D178 = D177 as (ManySortedSet of ( NAT ));
L1180:
now
let C254 being Nat;
L1181: C254 in ( NAT ) by ORDINAL1:def 12;
L1182: ( D178 . C254 ) in ( rng D178 ) by L1181 , L1179 , FUNCT_1:3;
L1183: ( D178 . C254 ) in { D176 } by L1182 , FUNCOP_1:8;
thus L1184: ( D178 . C254 ) is _Graph by L1183 , TARSKI:def 1;
end;
reconsider D179 = D178 as GraphSeq by L1180 , GLIB_000:def 53;
L1185: ( D179 . ( 1 + 1 ) ) in ( rng D179 ) by L1179 , FUNCT_1:3;
L1186: ( D179 . ( 1 + 1 ) ) in { D176 } by L1185 , FUNCOP_1:8;
L1187: ( D179 . ( 1 + 1 ) ) = D176 by L1186 , TARSKI:def 1;
take D179;
L1188: ( D179 . 1 ) in ( rng D179 ) by L1179 , FUNCT_1:3;
L1189: ( D179 . 1 ) in { D176 } by L1188 , FUNCOP_1:8;
L1190: ( D179 . 1 ) = D176 by L1189 , TARSKI:def 1;
thus L1191: D179 is  halting by L1190 , L1187 , GLIB_000:def 54;
L1192:
now
let C255 being Nat;
L1193: C255 in ( NAT ) by ORDINAL1:def 12;
L1194: ( D179 . C255 ) in ( rng D179 ) by L1193 , L1179 , FUNCT_1:3;
L1195: ( D179 . C255 ) in { D176 } by L1194 , FUNCOP_1:8;
thus L1196: (( D179 . C255 ) is  finite & ( D179 . C255 ) is  Tree-like) by L1195 , TARSKI:def 1;
end;
thus L1197: thesis by L1192 , L1157 , GLIB_000:def 57;
end;
end;
registration
let C256 being  connected GraphSeq;
let C257 being Nat;
cluster ( C256 . C257 ) ->  connected for _Graph;
coherence by L1155;
end;
registration
let C258 being  acyclic GraphSeq;
let C259 being Nat;
cluster ( C258 . C259 ) ->  acyclic for _Graph;
coherence by L1156;
end;
registration
let C260 being  Tree-like GraphSeq;
let C261 being Nat;
cluster ( C260 . C261 ) ->  Tree-like for _Graph;
coherence;
end;
begin
canceled 1;
theorem
L1202: (for B173 being non  trivial  connected _Graph holds (for B174 being (Vertex of B173) holds (not B174 is  isolated)))
proof
let C262 being non  trivial  connected _Graph;
let C263 being (Vertex of C262);
consider C264 , C265 being (Vertex of C262) such that L1203: C264 <> C265 by GLIB_000:21;
L1204:
now
per cases ;
suppose L1205: C264 = C263;

thus L1206: (ex B175 being (Vertex of C262) st B175 <> C263) by L1205 , L1203;
end;
suppose L1207: C264 <> C263;

thus L1208: (ex B176 being (Vertex of C262) st B176 <> C263) by L1207;
end;
end;
consider C266 being (Vertex of C262) such that L1210: C266 <> C263 by L1204;
consider C267 being (Walk of C262) such that L1211: C267 is_Walk_from C266 , C263 by L1;
L1212: ( C267 .first() ) = C266 by L1211 , GLIB_001:def 23;
L1213: ( C267 .last() ) = C263 by L1211 , GLIB_001:def 23;
L1214: C263 in ( C267 .vertices() ) by L1213 , GLIB_001:88;
thus L1215: thesis by L1214 , L1210 , L1212 , L1213 , GLIB_001:127 , GLIB_001:135;
end;
theorem
L1216: (for B177 being non  trivial _Graph holds (for B178 being (Vertex of B177) holds (for B179 being (removeVertex of B177 , B178) holds ((B179 is  connected & (ex B180 being set st (B180 in ( B178 .edgesInOut() ) & (not B180 Joins B178 , B178 , B177)))) implies B177 is  connected))))
proof
let C268 being non  trivial _Graph;
let C269 being (Vertex of C268);
let C270 being (removeVertex of C268 , C269);
assume that
L1217: C270 is  connected
and
L1218: (ex B181 being set st (B181 in ( C269 .edgesInOut() ) & (not B181 Joins C269 , C269 , C268)));
L1219:
now
let C271 being (Vertex of C268);
assume L1220: C271 <> C269;
L1221: (not C271 in { C269 }) by L1220 , TARSKI:def 1;
L1222: C271 in ( ( the_Vertices_of C268 ) \ { C269 } ) by L1221 , XBOOLE_0:def 5;
thus L1223: C271 in ( the_Vertices_of C270 ) by L1222 , GLIB_000:47;
end;
consider C272 being set such that L1224: C272 in ( C269 .edgesInOut() ) and L1225: (not C272 Joins C269 , C269 , C268) by L1218;
set D180 = ( C269 .adj C272 );
L1226: C269 <> D180 by L1224 , L1225 , GLIB_000:67;
reconsider D181 = D180 as (Vertex of C270) by L1226 , L1219;
L1227: C272 Joins C269 , D180 , C268 by L1224 , GLIB_000:67;
L1228: C272 Joins D180 , C269 , C268 by L1227 , GLIB_000:14;
L1229:
now
let C273 , C274 being (Vertex of C268);
L1230:
now
per cases ;
suppose L1231: C273 <> C269;

reconsider D182 = C273 as (Vertex of C270) by L1231 , L1219;
L1232:
now
per cases ;
suppose L1233: C274 <> C269;

reconsider D183 = C274 as (Vertex of C270) by L1233 , L1219;
consider C275 being (Walk of C270) such that L1234: C275 is_Walk_from D182 , D183 by L1217 , L1;
reconsider D184 = C275 as (Walk of C268) by GLIB_001:167;
L1235: D184 is_Walk_from C273 , C274 by L1234 , GLIB_001:19;
thus L1236: (ex B182 being (Walk of C268) st B182 is_Walk_from C273 , C274) by L1235;
end;
suppose L1237: C274 = C269;

consider C276 being (Walk of C270) such that L1238: C276 is_Walk_from D182 , D181 by L1217 , L1;
reconsider D185 = C276 as (Walk of C268) by GLIB_001:167;
L1239: D185 is_Walk_from C273 , D180 by L1238 , GLIB_001:19;
L1240: (( D185 .first() ) = C273 & ( D185 .last() ) = D180) by L1239 , GLIB_001:def 23;
L1241: ( D185 .addEdge C272 ) is_Walk_from C273 , C274 by L1240 , L1228 , L1237 , GLIB_001:63;
thus L1242: (ex B183 being (Walk of C268) st B183 is_Walk_from C273 , C274) by L1241;
end;
end;
thus L1244: (ex B184 being (Walk of C268) st B184 is_Walk_from C273 , C274) by L1232;
end;
suppose L1245: C273 = C269;

L1246:
now
per cases ;
suppose L1247: C274 <> C269;

reconsider D186 = C274 as (Vertex of C270) by L1247 , L1219;
set D187 = ( C268 .walkOf (C273 , C272 , D180) );
consider C277 being (Walk of C270) such that L1248: C277 is_Walk_from D181 , D186 by L1217 , L1;
reconsider D188 = C277 as (Walk of C268) by GLIB_001:167;
L1249: D188 is_Walk_from D180 , C274 by L1248 , GLIB_001:19;
take D189 = ( D187 .append D188 );
L1250: D187 is_Walk_from C273 , D180 by L1227 , L1245 , GLIB_001:15;
thus L1251: D189 is_Walk_from C273 , C274 by L1250 , L1249 , GLIB_001:31;
end;
suppose L1252: C274 = C269;

take D190 = ( C268 .walkOf C269 );
thus L1253: D190 is_Walk_from C273 , C274 by L1245 , L1252 , GLIB_001:13;
end;
end;
thus L1255: (ex B185 being (Walk of C268) st B185 is_Walk_from C273 , C274) by L1246;
end;
end;
thus L1257: (ex B186 being (Walk of C268) st B186 is_Walk_from C273 , C274) by L1230;
end;
thus L1258: thesis by L1229 , L1;
end;
theorem
L1259: (for B187 being non  trivial  connected _Graph holds (for B188 being (Vertex of B187) holds (for B189 being (removeVertex of B187 , B188) holds (B188 is  endvertex implies B189 is  connected)))) by L324;
theorem
L1260: (for B190 being  connected _Graph holds (for B191 being (Walk of B190) holds (for B192 being set holds (for B193 being (removeEdge of B190 , B192) holds ((B191 is  Cycle-like & B192 in ( B191 .edges() )) implies B193 is  connected)))))
proof
let C278 being  connected _Graph;
let C279 being (Walk of C278);
let C280 being set;
let C281 being (removeEdge of C278 , C280);
assume that
L1261: C279 is  Cycle-like
and
L1262: C280 in ( C279 .edges() );
reconsider D191 = ( ( the_Source_of C278 ) . C280 ) , D192 = ( ( the_Target_of C278 ) . C280 ) as (Vertex of C278) by L1262 , FUNCT_2:5;
L1263: C280 Joins D191 , D192 , C278 by L1262 , GLIB_000:def 13;
consider C282 being (Walk of C278) such that L1264: C282 is_Walk_from D191 , D192 and L1265: (not C280 in ( C282 .edges() )) by L1263 , L1261 , L1262 , GLIB_001:157;
reconsider D193 = C282 as (Walk of C281) by L1265 , GLIB_001:172;
L1266: D193 is_Walk_from D191 , D192 by L1264 , GLIB_001:19;
L1267: ( D193 .reverse() ) is_Walk_from D192 , D191 by L1266 , GLIB_001:23;
L1268:
now
let C283 , C284 being (Vertex of C281);
L1269: ( the_Vertices_of C281 ) c= ( the_Vertices_of C278 );
reconsider D194 = C283 , D195 = C284 as (Vertex of C278) by L1269 , TARSKI:def 3;
consider C285 being (Walk of C278) such that L1270: C285 is_Walk_from D194 , D195 by L1;
set D196 = the (Path of C285);
L1271: D196 is_Walk_from D194 , D195 by L1270 , GLIB_001:160;
L1272: ( D196 . ( len D196 ) ) = C284 by L1271 , GLIB_001:17;
L1273: ( D196 . 1 ) = C283 by L1271 , GLIB_001:17;
L1274:
now
per cases ;
suppose L1275: C280 in ( D196 .edges() );

consider C286 , C287 being (Vertex of C278), C288 being  odd (Element of ( NAT )) such that L1276: ( C288 + 2 ) <= ( len D196 ) and L1277: C286 = ( D196 . C288 ) and L1278: C280 = ( D196 . ( C288 + 1 ) ) and L1279: C287 = ( D196 . ( C288 + 2 ) ) and L1280: C280 Joins C286 , C287 , C278 by L1275 , GLIB_001:103;
set D197 = ( D196 .cut (1 , C288) );
set D198 = ( D196 .cut (( C288 + 2 ) , ( len D196 )) );
L1281: ( ( C288 + 2 ) - 2 ) < ( ( len D196 ) - ( 0 ) ) by L1276 , XREAL_1:15;
L1282: ( C288 + 1 ) <= ( len D196 ) by L1281 , NAT_1:13;
L1283:
now
assume L1284: C280 in ( D197 .edges() );
consider C289 being  even (Element of ( NAT )) such that L1285: 1 <= C289 and L1286: C289 <= ( len D197 ) and L1287: ( D197 . C289 ) = C280 by L1284 , GLIB_001:99;
L1288: C289 <= C288 by L1281 , L1286 , GLIB_001:45;
L1289: C289 < ( C288 + 1 ) by L1288 , NAT_1:13;
L1290: C289 in ( dom D197 ) by L1285 , L1286 , FINSEQ_3:25;
L1291: ( D196 . C289 ) = C280 by L1290 , L1281 , L1287 , GLIB_001:46;
thus L1292: contradiction by L1291 , L1278 , L1282 , L1285 , L1289 , GLIB_001:138;
end;
reconsider D199 = D197 as (Walk of C281) by L1283 , GLIB_001:172;
L1293:
now
assume L1294: C280 in ( D198 .edges() );
consider C290 being  even (Element of ( NAT )) such that L1295: 1 <= C290 and L1296: C290 <= ( len D198 ) and L1297: ( D198 . C290 ) = C280 by L1294 , GLIB_001:99;
reconsider D200 = ( C290 - 1 ) as  odd (Element of ( NAT )) by L1295 , INT_1:5;
L1298: D200 < ( ( len D198 ) - ( 0 ) ) by L1296 , XREAL_1:15;
L1299: ( ( C288 + 2 ) + D200 ) in ( dom D196 ) by L1298 , L1276 , GLIB_001:36;
L1300: ( ( C288 + 2 ) + D200 ) <= ( len D196 ) by L1299 , FINSEQ_3:25;
L1301: ( D200 + 1 ) = C290;
L1302: C280 = ( D196 . ( ( C288 + 2 ) + D200 ) ) by L1301 , L1276 , L1297 , L1298 , GLIB_001:36;
L1303: ( C288 + 1 ) < ( ( C288 + 1 ) + 1 ) by NAT_1:13;
L1304: ( ( C288 + 1 ) + ( 0 ) ) < ( ( C288 + 2 ) + D200 ) by L1303 , NAT_1:2 , XREAL_1:8;
L1305: 1 <= ( C288 + 1 ) by NAT_1:12;
thus L1306: contradiction by L1305 , L1278 , L1302 , L1300 , L1304 , GLIB_001:138;
end;
reconsider D201 = D198 as (Walk of C281) by L1293 , GLIB_001:172;
reconsider D202 = C286 , D203 = C287 as (Vertex of C281) by GLIB_000:51;
L1307: 1 <= C288 by ABIAN:12;
L1308: D197 is_Walk_from C283 , D202 by L1307 , L1273 , L1277 , L1281 , GLIB_001:37 , JORDAN12:2;
L1309: D199 is_Walk_from C283 , D202 by L1308 , GLIB_001:19;
L1310: D198 is_Walk_from D203 , C284 by L1272 , L1276 , L1279 , GLIB_001:37;
L1311: D201 is_Walk_from D203 , C284 by L1310 , GLIB_001:19;
L1312:
now
per cases  by L1280 , GLIB_000:def 13;
suppose L1313: (D202 = D191 & D203 = D192);

L1314: ( D199 .append D193 ) is_Walk_from C283 , D203 by L1313 , L1266 , L1309 , GLIB_001:31;
L1315: ( ( D199 .append D193 ) .append D201 ) is_Walk_from C283 , C284 by L1314 , L1311 , GLIB_001:31;
thus L1316: (ex B194 being (Walk of C281) st B194 is_Walk_from C283 , C284) by L1315;
end;
suppose L1317: (D203 = D191 & D202 = D192);

L1318: ( D199 .append ( D193 .reverse() ) ) is_Walk_from C283 , D203 by L1317 , L1267 , L1309 , GLIB_001:31;
L1319: ( ( D199 .append ( D193 .reverse() ) ) .append D201 ) is_Walk_from C283 , C284 by L1318 , L1311 , GLIB_001:31;
thus L1320: (ex B195 being (Walk of C281) st B195 is_Walk_from C283 , C284) by L1319;
end;
end;
thus L1322: (ex B196 being (Walk of C281) st B196 is_Walk_from C283 , C284) by L1312;
end;
suppose L1323: (not C280 in ( D196 .edges() ));

reconsider D204 = D196 as (Walk of C281) by L1323 , GLIB_001:172;
take D205 = D204;
thus L1324: D205 is_Walk_from C283 , C284 by L1271 , GLIB_001:19;
end;
end;
thus L1326: (ex B197 being (Walk of C281) st B197 is_Walk_from C283 , C284) by L1274;
end;
thus L1327: thesis by L1268 , L1;
end;
theorem
L1328: (for R1 being _Graph holds ((ex B198 being (Vertex of R1) st (for B199 being (Vertex of R1) holds (ex B200 being (Walk of R1) st B200 is_Walk_from B198 , B199))) implies R1 is  connected)) by L396;
theorem
L1329: (for B201 being  trivial _Graph holds B201 is  connected);
theorem
L1330: (for R2 being _Graph holds (for R3 being _Graph holds ((R2 == R3 & R2 is  connected) implies R3 is  connected)))
proof
let R2 being _Graph;
let R3 being _Graph;
assume that
L1331: R2 == R3
and
L1332: R2 is  connected;
L1333:
now
let C291 , C292 being (Vertex of R3);
reconsider D206 = C291 , D207 = C292 as (Vertex of R2) by L1331 , GLIB_000:def 34;
consider C293 being (Walk of R2) such that L1334: C293 is_Walk_from D206 , D207 by L1332 , L1;
reconsider D208 = C293 as (Walk of R3) by L1331 , GLIB_001:179;
take D209 = D208;
thus L1335: D209 is_Walk_from C291 , C292 by L1334 , GLIB_001:19;
end;
thus L1336: thesis by L1333 , L1;
end;
theorem
L1337: (for R1 being _Graph holds (for R7 being (Vertex of R1) holds R7 in ( R1 .reachableFrom R7 ))) by L194;
theorem
L1338: (for R1 being _Graph holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R8 being (Vertex of R1) holds ((R5 in ( R1 .reachableFrom R8 ) & R4 Joins R5 , R6 , R1) implies R6 in ( R1 .reachableFrom R8 ))))))) by L197;
theorem
L1339: (for R1 being _Graph holds (for R7 being (Vertex of R1) holds ( R1 .edgesBetween ( R1 .reachableFrom R7 ) ) = ( R1 .edgesInOut ( R1 .reachableFrom R7 ) )))
proof
let R1 being _Graph;
let R7 being (Vertex of R1);
set D210 = ( R1 .reachableFrom R7 );
L1340:
now
let C294 being set;
set D211 = ( ( the_Source_of R1 ) . C294 );
set D212 = ( ( the_Target_of R1 ) . C294 );
assume L1341: C294 in ( R1 .edgesInOut D210 );
reconsider D213 = D211 , D214 = D212 as (Vertex of R1) by L1341 , FUNCT_2:5;
L1342:
now
per cases  by L1341 , GLIB_000:28;
suppose L1343: D213 in D210;

consider C295 being (Walk of R1) such that L1344: C295 is_Walk_from R7 , D213 by L1343 , L156;
L1345:
now
L1346: ( C295 .last() ) = D213 by L1344 , GLIB_001:def 23;
L1347: C294 Joins ( C295 .last() ) , D214 , R1 by L1346 , L1341 , GLIB_000:def 13;
assume L1348: (not D214 in D210);
L1349: ( C295 .first() ) = R7 by L1344 , GLIB_001:def 23;
L1350: ( C295 .addEdge C294 ) is_Walk_from R7 , D214 by L1349 , L1347 , GLIB_001:63;
thus L1351: contradiction by L1350 , L1348 , L156;
end;
L1352: C294 in ( R1 .edgesInto D210 ) by L1345 , L1341 , GLIB_000:def 26;
L1353: C294 in ( R1 .edgesOutOf D210 ) by L1341 , L1343 , GLIB_000:def 27;
L1354: C294 in ( ( R1 .edgesInto D210 ) /\ ( R1 .edgesOutOf D210 ) ) by L1353 , L1352 , XBOOLE_0:def 4;
thus L1355: C294 in ( R1 .edgesBetween D210 ) by L1354 , GLIB_000:def 29;
end;
suppose L1356: D214 in D210;

consider C296 being (Walk of R1) such that L1357: C296 is_Walk_from R7 , D214 by L1356 , L156;
L1358:
now
L1359: ( C296 .last() ) = D214 by L1357 , GLIB_001:def 23;
L1360: C294 Joins ( C296 .last() ) , D213 , R1 by L1359 , L1341 , GLIB_000:def 13;
assume L1361: (not D213 in D210);
L1362: ( C296 .first() ) = R7 by L1357 , GLIB_001:def 23;
L1363: ( C296 .addEdge C294 ) is_Walk_from R7 , D213 by L1362 , L1360 , GLIB_001:63;
thus L1364: contradiction by L1363 , L1361 , L156;
end;
L1365: C294 in ( R1 .edgesOutOf D210 ) by L1358 , L1341 , GLIB_000:def 27;
L1366: C294 in ( R1 .edgesInto D210 ) by L1341 , L1356 , GLIB_000:def 26;
L1367: C294 in ( ( R1 .edgesInto D210 ) /\ ( R1 .edgesOutOf D210 ) ) by L1366 , L1365 , XBOOLE_0:def 4;
thus L1368: C294 in ( R1 .edgesBetween D210 ) by L1367 , GLIB_000:def 29;
end;
end;
thus L1370: C294 in ( R1 .edgesBetween D210 ) by L1342;
end;
L1371: (( R1 .edgesBetween D210 ) c= ( R1 .edgesInOut D210 ) & ( R1 .edgesInOut D210 ) c= ( R1 .edgesBetween D210 )) by L1340 , GLIB_000:33 , TARSKI:def 3;
thus L1372: thesis by L1371 , XBOOLE_0:def 10;
end;
theorem
L1373: (for R1 being _Graph holds (for R8 being (Vertex of R1) holds (for R9 being (Vertex of R1) holds (R8 in ( R1 .reachableFrom R9 ) implies ( R1 .reachableFrom R8 ) = ( R1 .reachableFrom R9 ))))) by L203;
theorem
L1374: (for R1 being _Graph holds (for R7 being (Vertex of R1) holds (for R10 being (Walk of R1) holds (R7 in ( R10 .vertices() ) implies ( R10 .vertices() ) c= ( R1 .reachableFrom R7 ))))) by L218;
theorem
L1375: (for B202 being _Graph holds (for B203 being (Subgraph of B202) holds (for B204 being (Vertex of B202) holds (for B205 being (Vertex of B203) holds (B204 = B205 implies ( B203 .reachableFrom B205 ) c= ( B202 .reachableFrom B204 ))))))
proof
let C297 being _Graph;
let C298 being (Subgraph of C297);
let C299 being (Vertex of C297);
let C300 being (Vertex of C298);
assume L1376: C299 = C300;
let C301 being set;
assume L1377: C301 in ( C298 .reachableFrom C300 );
consider C302 being (Walk of C298) such that L1378: C302 is_Walk_from C300 , C301 by L1377 , L156;
reconsider D215 = C302 as (Walk of C297) by GLIB_001:167;
L1379: D215 is_Walk_from C299 , C301 by L1376 , L1378 , GLIB_001:19;
thus L1380: thesis by L1379 , L156;
end;
theorem
L1381: (for R1 being _Graph holds ((ex B206 being (Vertex of R1) st ( R1 .reachableFrom B206 ) = ( the_Vertices_of R1 )) implies R1 is  connected)) by L405;
theorem
L1382: (for R1 being _Graph holds (R1 is  connected implies (for B207 being (Vertex of R1) holds ( R1 .reachableFrom B207 ) = ( the_Vertices_of R1 )))) by L415;
theorem
L1383: (for R2 being _Graph holds (for R3 being _Graph holds (for B208 being (Vertex of R2) holds (for B209 being (Vertex of R3) holds ((R2 == R3 & B208 = B209) implies ( R2 .reachableFrom B208 ) = ( R3 .reachableFrom B209 )))))) by L423;
theorem
L1384: (for R1 being _Graph holds (for R7 being (Vertex of R1) holds R7 in ( R1 .reachableDFrom R7 )))
proof
let R1 being _Graph;
let R7 being (Vertex of R1);
L1385: ( R1 .walkOf R7 ) is_Walk_from R7 , R7 by GLIB_001:13;
thus L1386: thesis by L1385 , L175;
end;
theorem
L1387: (for R1 being _Graph holds (for R4 being set holds (for R5 being set holds (for R6 being set holds (for R8 being (Vertex of R1) holds ((R5 in ( R1 .reachableDFrom R8 ) & R4 DJoins R5 , R6 , R1) implies R6 in ( R1 .reachableDFrom R8 )))))))
proof
let R1 being _Graph;
let R4 being set;
let R5 being set;
let R6 being set;
let R8 being (Vertex of R1);
set D216 = ( R1 .reachableDFrom R8 );
assume that
L1388: R5 in D216
and
L1389: R4 DJoins R5 , R6 , R1;
consider C303 being  directed (Walk of R1) such that L1390: C303 is_Walk_from R8 , R5 by L1388 , L175;
L1391: (( C303 .addEdge R4 ) is  directed & ( C303 .addEdge R4 ) is_Walk_from R8 , R6) by L1389 , L1390 , GLIB_001:123;
thus L1392: thesis by L1391 , L175;
end;
theorem
L1393: (for R1 being _Graph holds (for R7 being (Vertex of R1) holds ( R1 .reachableDFrom R7 ) c= ( R1 .reachableFrom R7 )))
proof
let R1 being _Graph;
let R7 being (Vertex of R1);
set D217 = ( R1 .reachableDFrom R7 );
let C304 being set;
assume L1394: C304 in D217;
reconsider D218 = C304 as (Vertex of R1) by L1394;
L1395: (ex B210 being  directed (Walk of R1) st B210 is_Walk_from R7 , D218) by L1394 , L175;
thus L1396: thesis by L1395 , L156;
end;
theorem
L1397: (for B211 being _Graph holds (for B212 being (Subgraph of B211) holds (for B213 being (Vertex of B211) holds (for B214 being (Vertex of B212) holds (B213 = B214 implies ( B212 .reachableDFrom B214 ) c= ( B211 .reachableDFrom B213 ))))))
proof
let C305 being _Graph;
let C306 being (Subgraph of C305);
let C307 being (Vertex of C305);
let C308 being (Vertex of C306);
assume L1398: C307 = C308;
L1399:
now
let C309 being set;
assume L1400: C309 in ( C306 .reachableDFrom C308 );
consider C310 being (DWalk of C306) such that L1401: C310 is_Walk_from C308 , C309 by L1400 , L175;
reconsider D219 = C310 as (DWalk of C305) by GLIB_001:175;
L1402: D219 is_Walk_from C307 , C309 by L1398 , L1401 , GLIB_001:19;
thus L1403: C309 in ( C305 .reachableDFrom C307 ) by L1402 , L175;
end;
thus L1404: thesis by L1399 , TARSKI:def 3;
end;
theorem
L1405: (for R2 being _Graph holds (for R3 being _Graph holds (for B215 being (Vertex of R2) holds (for B216 being (Vertex of R3) holds ((R2 == R3 & B215 = B216) implies ( R2 .reachableDFrom B215 ) = ( R3 .reachableDFrom B216 ))))))
proof
let R2 being _Graph;
let R3 being _Graph;
let C311 being (Vertex of R2);
let C312 being (Vertex of R3);
assume that
L1406: R2 == R3
and
L1407: C311 = C312;
L1408:
now
let C313 being set;
thus L1409:now
assume L1410: C313 in ( R2 .reachableDFrom C311 );
consider C314 being (DWalk of R2) such that L1411: C314 is_Walk_from C312 , C313 by L1410 , L1407 , L175;
reconsider D220 = C314 as (DWalk of R3) by L1406 , GLIB_001:179 , GLIB_001:181;
L1412: D220 is_Walk_from C312 , C313 by L1411 , GLIB_001:19;
thus L1413: C313 in ( R3 .reachableDFrom C312 ) by L1412 , L175;
end;
assume L1414: C313 in ( R3 .reachableDFrom C312 );
consider C315 being (DWalk of R3) such that L1415: C315 is_Walk_from C311 , C313 by L1414 , L1407 , L175;
reconsider D221 = C315 as (DWalk of R2) by L1406 , GLIB_001:179 , GLIB_001:181;
L1416: D221 is_Walk_from C311 , C313 by L1415 , GLIB_001:19;
thus L1417: C313 in ( R2 .reachableDFrom C311 ) by L1416 , L175;
end;
thus L1418: thesis by L1408 , TARSKI:1;
end;
theorem
L1419: (for B217 being _Graph holds (for B218 being  connected (Subgraph of B217) holds (B218 is  spanning implies B217 is  connected))) by L437;
theorem
L1420: (for R1 being _Graph holds ( union ( R1 .componentSet() ) ) = ( the_Vertices_of R1 ))
proof
let R1 being _Graph;
L1421:
now
let C316 being set;
thus L1422: (C316 in ( union ( R1 .componentSet() ) ) implies C316 in ( the_Vertices_of R1 ));
assume L1423: C316 in ( the_Vertices_of R1 );
reconsider D222 = C316 as (Vertex of R1) by L1423;
set D223 = ( R1 .reachableFrom D222 );
L1424: (C316 in D223 & D223 in ( R1 .componentSet() )) by L292 , L194;
thus L1425: C316 in ( union ( R1 .componentSet() ) ) by L1424 , TARSKI:def 4;
end;
thus L1426: thesis by L1421 , TARSKI:1;
end;
theorem
L1427: (for R1 being _Graph holds (R1 is  connected iff ( R1 .componentSet() ) = { ( the_Vertices_of R1 ) })) by L443;
theorem
L1428: (for R2 being _Graph holds (for R3 being _Graph holds (R2 == R3 implies ( R2 .componentSet() ) = ( R3 .componentSet() )))) by L461;
theorem
L1429: (for R1 being _Graph holds (for R5 being set holds (R5 in ( R1 .componentSet() ) implies R5 is non  empty non  empty non  empty non  empty (Subset of ( the_Vertices_of R1 ))))) by L474;
theorem
L1430: (for R1 being _Graph holds (R1 is  connected iff ( R1 .numComponents() ) = 1)) by L546;
theorem
L1431: (for R2 being _Graph holds (for R3 being _Graph holds (R2 == R3 implies ( R2 .numComponents() ) = ( R3 .numComponents() )))) by L461;
theorem
L1432: (for R1 being _Graph holds (R1 is (Component of R1) iff R1 is  connected))
proof
let R1 being _Graph;
thus L1433: (R1 is (Component of R1) implies R1 is  connected);
L1434: R1 is (Subgraph of R1) by GLIB_000:40;
L1435:
now
given C317 being  connected (Subgraph of R1) such that
L1436: R1 c< C317;

L1437:
now
per cases  by L1434 , L1436 , GLIB_000:98;
suppose L1438: ( the_Vertices_of R1 ) c< ( the_Vertices_of C317 );

thus L1439: contradiction by L1438 , XBOOLE_0:def 8;
end;
suppose L1440: ( the_Edges_of R1 ) c< ( the_Edges_of C317 );

thus L1441: contradiction by L1440 , XBOOLE_0:def 8;
end;
end;
thus L1443: contradiction by L1437;
end;
assume L1444: R1 is  connected;
thus L1445: thesis by L1444 , L1435 , L235 , GLIB_000:40;
end;
theorem
L1446: (for R1 being _Graph holds (for B219 being (Component of R1) holds ( the_Edges_of B219 ) = ( R1 .edgesBetween ( the_Vertices_of B219 ) ))) by L478;
theorem
L1447: (for R1 being _Graph holds (for B220 , B221 being (Component of R1) holds (( the_Vertices_of B220 ) = ( the_Vertices_of B221 ) iff B220 == B221))) by L495;
theorem
L1448: (for R1 being _Graph holds (for B222 being (Component of R1) holds (for B223 being (Vertex of R1) holds (B223 in ( the_Vertices_of B222 ) iff ( the_Vertices_of B222 ) = ( R1 .reachableFrom B223 ))))) by L502;
theorem
L1449: (for R1 being _Graph holds (for B224 , B225 being (Component of R1) holds (for B226 being set holds ((B226 in ( the_Vertices_of B224 ) & B226 in ( the_Vertices_of B225 )) implies B224 == B225)))) by L541;
theorem
L1450: (for B227 being  connected _Graph holds (for B228 being (Vertex of B227) holds (B228 is non  cut-vertex iff (for B229 being (removeVertex of B227 , B228) holds ( B229 .numComponents() ) c= ( B227 .numComponents() ))))) by L565;
theorem
L1451: (for B230 being  connected _Graph holds (for B231 being (Vertex of B230) holds (for B232 being (removeVertex of B230 , B231) holds ((not B231 is  cut-vertex) implies B232 is  connected)))) by L578;
theorem
L1452: (for B233 being non  trivial  finite  connected _Graph holds (ex B234 , B235 being (Vertex of B233) st (B234 <> B235 & (not B234 is  cut-vertex) & (not B235 is  cut-vertex)))) by L585;
theorem
L1453: (for R1 being _Graph holds (for R7 being (Vertex of R1) holds (R7 is  cut-vertex implies R1 is non  trivial)))
proof
let R1 being _Graph;
let R7 being (Vertex of R1);
assume L1454: R7 is  cut-vertex;
L1455:
now
assume L1456: R1 is  trivial;
reconsider D224 = R1 as  trivial _Graph by L1456;
set D225 = the (removeVertex of D224 , R7);
L1457: (( D224 .numComponents() ) = 1 & ( D225 .numComponents() ) = 1) by L546;
L1458: 1 in 1 by L1457 , L1454 , L310;
thus L1459: contradiction by L1458;
end;
thus L1460: thesis by L1455;
end;
theorem
L1461: (for R2 being _Graph holds (for R3 being _Graph holds (for B236 being (Vertex of R2) holds (for B237 being (Vertex of R3) holds ((R2 == R3 & B236 = B237) implies (B236 is  cut-vertex implies B237 is  cut-vertex))))))
proof
let R2 being _Graph;
let R3 being _Graph;
let C318 being (Vertex of R2);
let C319 being (Vertex of R3);
assume that
L1462: R2 == R3
and
L1463: C318 = C319
and
L1464: C318 is  cut-vertex;
L1465: R2 is non  trivial by L1464 , L1453;
L1466: R3 is non  trivial by L1465 , L1462 , GLIB_000:89;
let C320 being (removeVertex of R3 , C319);
set D226 = the (removeVertex of R2 , C318);
L1467: ( R2 .numComponents() ) = ( R3 .numComponents() ) by L1462 , L461;
L1468: ( R3 .numComponents() ) in ( D226 .numComponents() ) by L1467 , L1464 , L310;
L1469: ( the_Vertices_of D226 ) = ( ( the_Vertices_of R2 ) \ { C319 } ) by L1463 , L1465 , GLIB_000:47
.= ( ( the_Vertices_of R3 ) \ { C319 } ) by L1462 , GLIB_000:def 34;
L1470: ( the_Vertices_of C320 ) = ( the_Vertices_of D226 ) by L1469 , L1466 , GLIB_000:47;
L1471: R3 is (Subgraph of R2) by L1462 , GLIB_000:87;
L1472: C320 is (Subgraph of R2) by L1471 , GLIB_000:43;
L1473: ( the_Edges_of D226 ) = ( R2 .edgesBetween ( ( the_Vertices_of R2 ) \ { C318 } ) ) by L1465 , GLIB_000:47
.= ( R2 .edgesBetween ( ( the_Vertices_of R3 ) \ { C319 } ) ) by L1462 , L1463 , GLIB_000:def 34
.= ( R3 .edgesBetween ( ( the_Vertices_of R3 ) \ { C319 } ) ) by L1462 , GLIB_000:90;
L1474: ( the_Edges_of C320 ) = ( the_Edges_of D226 ) by L1473 , L1466 , GLIB_000:47;
thus L1475: thesis by L1474 , L1468 , L1470 , L1472 , L461 , GLIB_000:86;
end;
theorem
L1476: (for B238 being  finite  connected _Graph holds ( B238 .order() ) <= ( ( B238 .size() ) + 1 ))
proof
let C321 being  finite  connected _Graph;
defpred S7[  finite _Graph ] means ($1 is  connected implies ( $1 .order() ) <= ( ( $1 .size() ) + 1 ));
L1477:
now
let C322 being non  empty Nat;
assume L1478: (for B239 being  finite _Graph holds (( B239 .order() ) = C322 implies S7[ B239 ]));
let C323 being  finite _Graph;
assume L1479: ( C323 .order() ) = ( C322 + 1 );
L1480:
now
L1481:
now
assume L1482: ( C323 .order() ) = 1;
L1483: ( C322 + 1 ) = ( ( 0 ) + 1 ) by L1482 , L1479;
thus L1484: contradiction by L1483;
end;
assume L1485: C323 is  connected;
reconsider D227 = C323 as non  trivial  finite  connected _Graph by L1485 , L1481 , GLIB_000:26;
consider C324 , C325 being (Vertex of D227) such that L1486: C324 <> C325 and L1487: (not C324 is  cut-vertex) and L1488: (not C325 is  cut-vertex) by L585;
set D228 = the (removeVertex of D227 , C324);
L1489: (( ( D228 .order() ) + 1 ) = ( C322 + 1 ) & ( ( D228 .size() ) + ( card ( C324 .edgesInOut() ) ) ) = ( C323 .size() )) by L1479 , GLIB_000:48;
L1490: (not C324 is  isolated) by L1202;
L1491: ( C324 .edgesInOut() ) <> ( {} ) by L1490 , GLIB_000:def 49;
L1492: ( 0 ) < ( card ( C324 .edgesInOut() ) ) by L1491 , NAT_1:3;
L1493: ( ( 0 ) + 1 ) <= ( card ( C324 .edgesInOut() ) ) by L1492 , NAT_1:13;
L1494: D228 is  connected by L1487 , L578;
L1495: C322 <= ( ( ( C323 .size() ) - ( card ( C324 .edgesInOut() ) ) ) + 1 ) by L1494 , L1478 , L1489;
L1496: ( C322 + 1 ) <= ( ( ( ( C323 .size() ) + 1 ) - ( card ( C324 .edgesInOut() ) ) ) + ( card ( C324 .edgesInOut() ) ) ) by L1495 , L1493 , XREAL_1:7;
thus L1497: ( C323 .order() ) <= ( ( C323 .size() ) + 1 ) by L1496 , L1479;
end;
thus L1498: S7[ C323 ] by L1480;
end;
L1499: (for B240 being  finite _Graph holds (( B240 .order() ) = 1 implies S7[ B240 ])) by NAT_1:12;
L1500: (for B241 being  finite _Graph holds S7[ B241 ]) from GLIB_000:sch 1(L1499 , L1477);
thus L1501: thesis by L1500;
end;
theorem
L1502: (for B242 being  acyclic _Graph holds B242 is  simple);
theorem
L1503: (for B243 being  acyclic _Graph holds (for B244 being (Path of B243) holds (for B245 being set holds (((not B245 in ( B244 .edges() )) & B245 in ( ( B244 .last() ) .edgesInOut() )) implies ( B244 .addEdge B245 ) is  Path-like)))) by L979;
theorem
L1504: (for B246 being non  trivial  finite  acyclic _Graph holds (( the_Edges_of B246 ) <> ( {} ) implies (ex B247 , B248 being (Vertex of B246) st (B247 <> B248 & B247 is  endvertex & B248 is  endvertex & B248 in ( B246 .reachableFrom B247 ))))) by L1021;
theorem
L1505: (for R2 being _Graph holds (for R3 being _Graph holds ((R2 == R3 & R2 is  acyclic) implies R3 is  acyclic)))
proof
let R2 being _Graph;
let R3 being _Graph;
assume that
L1506: R2 == R3
and
L1507: R2 is  acyclic;
reconsider D229 = R2 as  acyclic _Graph by L1507;
L1508: R3 is (Subgraph of D229) by L1506 , GLIB_000:87;
thus L1509: thesis by L1508;
end;
theorem
L1510: (for B249 being non  trivial  finite  Tree-like _Graph holds (ex B250 , B251 being (Vertex of B249) st (B250 <> B251 & B250 is  endvertex & B251 is  endvertex))) by L1132;
theorem
L1511: (for B252 being  finite _Graph holds (B252 is  Tree-like iff (B252 is  acyclic & ( B252 .order() ) = ( ( B252 .size() ) + 1 ))))
proof
defpred S8[ Nat ] means (for B253 being  finite  acyclic _Graph holds ((( B253 .order() ) = $1 & ( B253 .order() ) = ( ( B253 .size() ) + 1 )) implies B253 is  connected));
let C326 being  finite _Graph;
thus L1512:now
defpred S9[ Nat ] means (for B254 being  finite  Tree-like _Graph holds (( B254 .order() ) = $1 implies $1 = ( ( B254 .size() ) + 1 )));
assume L1513: C326 is  Tree-like;
thus L1514: C326 is  acyclic by L1513;
L1515:
now
let C327 being  finite  Tree-like _Graph;
set D230 = ( the_Vertices_of C327 );
set D231 = ( the_Edges_of C327 );
assume L1516: ( C327 .order() ) = 1;
L1517: ( card D230 ) = 1 by L1516 , GLIB_000:def 24;
consider C328 being set such that L1518: D230 = { C328 } by L1517 , CARD_2:42;
reconsider D232 = C328 as (Vertex of C327) by L1518 , TARSKI:def 1;
L1519:
now
assume L1520: (ex R4 being set st R4 in D231);
consider C329 being set such that L1521: C329 in D231 by L1520;
L1522: ( ( the_Target_of C327 ) . C329 ) in { D232 } by L1518 , L1521 , FUNCT_2:5;
L1523: ( ( the_Target_of C327 ) . C329 ) = D232 by L1522 , TARSKI:def 1;
L1524: ( ( the_Source_of C327 ) . C329 ) in { D232 } by L1518 , L1521 , FUNCT_2:5;
L1525: ( ( the_Source_of C327 ) . C329 ) = D232 by L1524 , TARSKI:def 1;
L1526: C329 Joins D232 , D232 , C327 by L1525 , L1521 , L1523 , GLIB_000:def 13;
L1527: ( C327 .walkOf (D232 , C329 , D232) ) is  Cycle-like by L1526 , GLIB_001:156;
thus L1528: contradiction by L1527 , L3;
end;
L1529: ( card D231 ) = ( 0 ) by L1519 , CARD_1:27 , XBOOLE_0:def 1;
L1530: ( C327 .size() ) = ( 0 ) by L1529 , GLIB_000:def 25;
thus L1531: 1 = ( ( C327 .size() ) + 1 ) by L1530;
end;
L1532: S9[ 1 ] by L1515;
L1533:
now
let C330 being non  empty Nat;
assume L1534: (for B255 being  finite  Tree-like _Graph holds (( B255 .order() ) = C330 implies C330 = ( ( B255 .size() ) + 1 )));
let C331 being  finite  Tree-like _Graph;
assume L1535: ( C331 .order() ) = ( C330 + 1 );
L1536: ( C331 .order() ) <> 1 by L1535 , XCMPLX_1:3;
reconsider D233 = C331 as non  trivial  finite  Tree-like _Graph by L1536 , GLIB_000:26;
set D234 = the  endvertex (Vertex of D233);
set D235 = the (removeVertex of D233 , D234);
L1537: ( ( ( D235 .order() ) + 1 ) - 1 ) = ( ( C330 + 1 ) - 1 ) by L1535 , GLIB_000:48;
L1538: C330 = ( ( D235 .size() ) + 1 ) by L1537 , L1534;
L1539: ( card ( D234 .edgesInOut() ) ) = ( D234 .degree() ) by GLIB_000:19
.= 1 by GLIB_000:def 52;
thus L1540: ( C330 + 1 ) = ( ( C331 .size() ) + 1 ) by L1539 , L1538 , GLIB_000:48;
end;
L1541: (for B256 being non  empty Nat holds (S9[ B256 ] implies S9[ ( B256 + 1 ) ])) by L1533;
L1542: (for B257 being non  empty Nat holds S9[ B257 ]) from NAT_1:sch 10(L1532 , L1541);
thus L1543: ( C326 .order() ) = ( ( C326 .size() ) + 1 ) by L1542 , L1513;
end;
assume that
L1544: C326 is  acyclic
and
L1545: ( C326 .order() ) = ( ( C326 .size() ) + 1 );
L1546:
now
let C332 being non  empty (Element of ( NAT ));
assume L1547: (for B258 being  finite  acyclic _Graph holds ((( B258 .order() ) = C332 & ( B258 .order() ) = ( ( B258 .size() ) + 1 )) implies B258 is  connected));
let C333 being  finite  acyclic _Graph;
assume that
L1548: ( C333 .order() ) = ( C332 + 1 )
and
L1549: ( C333 .order() ) = ( ( C333 .size() ) + 1 );
L1550:
now
assume L1551: ( C333 .order() ) = 1;
L1552: ( ( 0 ) + 1 ) = ( C332 + 1 ) by L1551 , L1548;
thus L1553: contradiction by L1552;
end;
reconsider D236 = C333 as non  trivial  finite  acyclic _Graph by L1550 , GLIB_000:26;
L1554: ( the_Edges_of C333 ) <> ( {} ) by L1548 , L1549 , CARD_1:27 , GLIB_000:def 25;
consider C334 , C335 being (Vertex of D236) such that L1555: C334 <> C335 and L1556: C334 is  endvertex and L1557: C335 is  endvertex and L1558: C335 in ( D236 .reachableFrom C334 ) by L1554 , L1021;
set D237 = the (removeVertex of C333 , C334);
L1559: (( ( D237 .order() ) + 1 ) = ( D236 .order() ) & ( ( D237 .size() ) + ( card ( C334 .edgesInOut() ) ) ) = ( D236 .size() )) by GLIB_000:48;
L1560: ( card ( C334 .edgesInOut() ) ) = ( C334 .degree() ) by GLIB_000:19
.= 1 by L1556 , GLIB_000:def 52;
L1561: D237 is  connected by L1560 , L1547 , L1548 , L1549 , L1559;
consider C336 being set such that L1562: ( C334 .edgesInOut() ) = { C336 } and L1563: (not C336 Joins C334 , C334 , C333) by L1556 , GLIB_000:def 51;
L1564: C336 in ( C334 .edgesInOut() ) by L1562 , TARSKI:def 1;
thus L1565: C333 is  connected by L1564 , L1561 , L1563 , L1216;
end;
L1566: (for B259 being non  empty Nat holds (S8[ B259 ] implies S8[ ( B259 + 1 ) ])) by L1546;
L1567:
now
let C337 being  finite  acyclic _Graph;
assume that
L1568: ( C337 .order() ) = 1
and
L1569: ( C337 .order() ) = ( ( C337 .size() ) + 1 );
consider C338 being (Vertex of C337) such that L1570: ( the_Vertices_of C337 ) = { C338 } by L1568 , GLIB_000:27;
L1571:
now
let C339 , C340 being (Vertex of C337);
L1572: (C339 = C338 & C340 = C338) by L1570 , TARSKI:def 1;
L1573: ( C337 .walkOf C338 ) is_Walk_from C339 , C340 by L1572 , GLIB_001:13;
thus L1574: (ex B260 being (Walk of C337) st B260 is_Walk_from C339 , C340) by L1573;
end;
thus L1575: C337 is  connected by L1571 , L1;
end;
L1576: S8[ 1 ] by L1567;
L1577: (for B261 being non  empty Nat holds S8[ B261 ]) from NAT_1:sch 10(L1576 , L1566);
L1578: C326 is  connected by L1577 , L1544 , L1545;
thus L1579: thesis by L1578 , L1544;
end;
theorem
L1580: (for B262 being  finite _Graph holds (B262 is  Tree-like iff (B262 is  connected & ( B262 .order() ) = ( ( B262 .size() ) + 1 ))))
proof
let C341 being  finite _Graph;
thus L1581: (C341 is  Tree-like implies (C341 is  connected & ( C341 .order() ) = ( ( C341 .size() ) + 1 ))) by L1511;
assume that
L1582: C341 is  connected
and
L1583: ( C341 .order() ) = ( ( C341 .size() ) + 1 );
L1584:
now
assume L1585: (not C341 is  acyclic);
consider C342 being (Walk of C341) such that L1586: C342 is  Cycle-like by L1585 , L3;
set D238 = ( choose ( C342 .edges() ) );
set D239 = the (removeEdge of C341 , D238);
L1587: ( C342 .edges() ) <> ( {} ) by L1586 , GLIB_001:136;
L1588: D238 in ( C342 .edges() ) by L1587;
L1589: (( D239 .order() ) = ( C341 .order() ) & ( ( D239 .size() ) + 1 ) = ( C341 .size() )) by L1588 , GLIB_000:52;
L1590: D239 is  connected by L1582 , L1586 , L1587 , L1260;
L1591: ( ( ( D239 .size() ) + 1 ) + 1 ) <= ( ( ( D239 .size() ) + 1 ) + ( 0 ) ) by L1590 , L1583 , L1589 , L1476;
thus L1592: contradiction by L1591 , XREAL_1:6;
end;
thus L1593: thesis by L1584 , L1582;
end;
theorem
L1594: (for R2 being _Graph holds (for R3 being _Graph holds ((R2 == R3 & R2 is  Tree-like) implies R3 is  Tree-like)))
proof
let R2 being _Graph;
let R3 being _Graph;
assume L1595: (R2 == R3 & R2 is  Tree-like);
L1596: (R3 is  connected & R3 is  acyclic) by L1595 , L1330 , L1505;
thus L1597: thesis by L1596;
end;
theorem
L1598: (for R1 being _Graph holds (for R5 being set holds (R1 is_DTree_rooted_at R5 implies R5 is (Vertex of R1))))
proof
let R1 being _Graph;
let R5 being set;
set D240 = the (Vertex of R1);
assume L1599: R1 is_DTree_rooted_at R5;
L1600: (ex B263 being (DWalk of R1) st B263 is_Walk_from R5 , D240) by L1599 , L74;
thus L1601: thesis by L1600 , GLIB_001:18;
end;
theorem
L1602: (for R2 being _Graph holds (for R3 being _Graph holds (for R5 being set holds ((R2 == R3 & R2 is_DTree_rooted_at R5) implies R3 is_DTree_rooted_at R5))))
proof
let R2 being _Graph;
let R3 being _Graph;
let R5 being set;
assume that
L1603: R2 == R3
and
L1604: R2 is_DTree_rooted_at R5;
L1605:
now
let C343 being (Vertex of R3);
reconsider D241 = C343 as (Vertex of R2) by L1603 , GLIB_000:def 34;
consider C344 being (DWalk of R2) such that L1606: C344 is_Walk_from R5 , D241 by L1604 , L74;
reconsider D242 = C344 as (DWalk of R3) by L1603 , GLIB_001:179 , GLIB_001:181;
take D243 = D242;
thus L1607: D243 is_Walk_from R5 , C343 by L1606 , GLIB_001:19;
end;
L1608: R2 is  Tree-like by L1604 , L74;
L1609: R3 is  Tree-like by L1608 , L1603 , L1594;
thus L1610: thesis by L1609 , L1605 , L74;
end;
