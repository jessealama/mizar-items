:: Computation and Program Shift in the SCMPDS Computer
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, INT_1, FSM_1, AMI_1, COMPLEX1,
      ARYTM_3, FUNCT_1, AMI_2, STRUCT_0, XBOOLE_0, RELAT_1, TARSKI, CARD_1,
      AMI_3, GRAPHSP, EXTPRO_1, XXREAL_0, ARYTM_1, FUNCT_4, FUNCOP_1, CIRCUIT2,
      ORDINAL1, PARTFUN1, AMISTD_5, FINSET_1, COMPOS_1, GOBRD13;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, RELAT_1, FUNCT_1,
      PARTFUN1, FUNCT_4, FINSET_1, INT_1, NAT_1, STRUCT_0, FUNCOP_1, INT_2,
      XXREAL_0, MEMSTR_0, COMPOS_1, EXTPRO_1, AMI_2, AMISTD_5, SCMPDS_2;
 constructors DOMAIN_1, INT_2, SCMPDS_1, SCMPDS_2, REAL_1, PRE_POLY, AMI_3,
      AMISTD_5, FUNCT_7, RELSET_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, XREAL_0, INT_1, CARD_3,
      AMI_3, SCMPDS_2, FINSET_1, COMPOS_1, EXTPRO_1, FUNCT_4, FUNCOP_1,
      MEMSTR_0, COMPOS_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;
 definitions EXTPRO_1, AMI_2, FUNCOP_1, SCMPDS_2, NAT_1, AMISTD_5, MEMSTR_0;
 theorems GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1, ZFMISC_1, INT_1,
      RELAT_1, ABSVALUE, SCMPDS_2, XBOOLE_0, XBOOLE_1, NUMBERS, PBOOLE,
      PARTFUN1, EXTPRO_1, AMISTD_5, MEMSTR_0, AMI_2;

begin
theorem
L1: (for B1 being Integer holds (for B2 , B3 being (State of ( SCMPDS )) holds (( IC B2 ) = ( IC B3 ) implies ( ICplusConst (B2 , B1) ) = ( ICplusConst (B3 , B1) ))))
proof
let C1 being Integer;
let C2 , C3 being (State of ( SCMPDS ));
L2: (ex B4 being (Element of ( NAT )) st (B4 = ( IC C2 ) & ( ICplusConst (C2 , C1) ) = ( abs ( B4 + C1 ) ))) by SCMPDS_2:def 18;
assume L3: ( IC C2 ) = ( IC C3 );
thus L4: thesis by L3 , L2 , SCMPDS_2:def 18;
end;
theorem
L5: (for B5 being Integer holds (for B6 being Int_position holds (for B7 , B8 being (State of ( SCMPDS )) holds (( DataPart B7 ) = ( DataPart B8 ) implies ( B7 . ( DataLoc (( B7 . B6 ) , B5) ) ) = ( B8 . ( DataLoc (( B8 . B6 ) , B5) ) )))))
proof
let C4 being Integer;
let C5 being Int_position;
let C6 , C7 being (State of ( SCMPDS ));
assume L6: ( DataPart C6 ) = ( DataPart C7 );
L7: C5 in ( SCM-Data-Loc ) by AMI_2:def 16;
L8: ( C6 . C5 ) = ( ( DataPart C6 ) . C5 ) by L7 , FUNCT_1:49 , SCMPDS_2:84
.= ( C7 . C5 ) by L6 , L7 , FUNCT_1:49 , SCMPDS_2:84;
L9: ( DataLoc (( C6 . C5 ) , C4) ) in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L10: ( C6 . ( DataLoc (( C6 . C5 ) , C4) ) ) = ( ( DataPart C6 ) . ( DataLoc (( C6 . C5 ) , C4) ) ) by L9 , FUNCT_1:49 , SCMPDS_2:84
.= ( C7 . ( DataLoc (( C7 . C5 ) , C4) ) ) by L6 , L9 , L8 , FUNCT_1:49 , SCMPDS_2:84;
end;
theorem
L11: (for B9 being Int_position holds (for B10 , B11 being (State of ( SCMPDS )) holds (( DataPart B10 ) = ( DataPart B11 ) implies ( B10 . B9 ) = ( B11 . B9 ))))
proof
let C8 being Int_position;
let C9 , C10 being (State of ( SCMPDS ));
assume L12: ( DataPart C9 ) = ( DataPart C10 );
L13: C8 in ( SCM-Data-Loc ) by AMI_2:def 16;
thus L14: ( C9 . C8 ) = ( ( DataPart C9 ) . C8 ) by L13 , FUNCT_1:49 , SCMPDS_2:84
.= ( C10 . C8 ) by L12 , L13 , FUNCT_1:49 , SCMPDS_2:84;
end;
theorem
L15: (not ( IC ( SCMPDS ) ) in ( SCM-Data-Loc ))
proof
assume L16: ( IC ( SCMPDS ) ) in ( SCM-Data-Loc );
L17: ( IC ( SCMPDS ) ) is Int_position by L16 , AMI_2:def 16;
L18: ( Values ( IC ( SCMPDS ) ) ) = ( INT ) by L17 , SCMPDS_2:5;
thus L19: contradiction by L18 , MEMSTR_0:def 6 , NUMBERS:27;
end;
begin
canceled 1;
theorem
L20: (for B12 being (State of ( SCMPDS )) holds (for B13 being (Element of ( NAT )) holds (for B14 being Int_position holds ( B12 . B14 ) = ( ( B12 +* ( Start-At (B13 , ( SCMPDS )) ) ) . B14 ))))
proof
let C11 being (State of ( SCMPDS ));
let C12 being (Element of ( NAT ));
let C13 being Int_position;
L21: C13 in (the carrier of ( SCMPDS ));
L22: C13 in ( dom C11 ) by L21 , PARTFUN1:def 2;
L23: (( dom ( Start-At (C12 , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } & C13 in ( ( dom C11 ) \/ ( dom ( Start-At (C12 , ( SCMPDS )) ) ) )) by L22 , FUNCOP_1:13 , XBOOLE_0:def 3;
L24: C13 <> ( IC ( SCMPDS ) ) by SCMPDS_2:43;
L25: (not C13 in { ( IC ( SCMPDS ) ) }) by L24 , TARSKI:def 1;
thus L26: thesis by L25 , L23 , FUNCT_4:def 1;
end;
theorem
L27: (for B15 , B16 being (State of ( SCMPDS )) holds ( B15 +* ( B16 | ( SCM-Data-Loc ) ) ) is (State of ( SCMPDS )));
begin
definition
let C14 being Int_position;
let C15 being Integer;
redefine func C14 .--> C15 -> (FinPartState of ( SCMPDS ));

coherence
proof
L28: (C15 is (Element of ( INT )) & ( Values C14 ) = ( INT )) by INT_1:def 2 , SCMPDS_2:5;
thus L29: thesis by L28;
end;
end;
registration
cluster ( SCMPDS ) ->  IC-recognized;
coherence
proof
let C16 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C17 being C16 -autonomic (FinPartState of ( SCMPDS ));
assume that
L31: C17 is non  empty;
assume L32: (not ( IC ( SCMPDS ) ) in ( dom C17 ));
L33: (not ( IC ( SCMPDS ) ) in ( dom C17 )) by L32;
L34: ( dom C17 ) misses { ( IC ( SCMPDS ) ) } by L33 , ZFMISC_1:50;
L35: ( dom C17 ) c= ( { ( IC ( SCMPDS ) ) } \/ ( dom ( DataPart C17 ) ) ) by MEMSTR_0:32;
L36: ( dom C17 ) c= ( dom ( DataPart C17 ) ) by L35 , L34 , XBOOLE_1:73;
L37: ( dom ( DataPart C17 ) ) <> ( {} ) by L31 , L36 , XBOOLE_1:3;
L38: ( DataPart C17 ) c= C17 by MEMSTR_0:12;
L39: ( dom ( DataPart C17 ) ) c= ( dom C17 ) by L38 , RELAT_1:11;
L40: (not C17 is C16 -autonomic)
proof
set D1 = the (Element of ( ( NAT ) \ ( dom C16 ) ));
set D2 = the (Element of ( dom ( DataPart C17 ) ));
L41: D2 in ( dom ( DataPart C17 ) ) by L37;
L42: ( dom ( DataPart C17 ) ) c= (the carrier of ( SCMPDS )) by RELAT_1:def 18;
reconsider D3 = D2 as (Element of ( SCMPDS )) by L42 , L41;
L43: (not ( NAT ) c= ( dom C16 ));
L44: ( ( NAT ) \ ( dom C16 ) ) <> ( {} ) by L43 , XBOOLE_1:37;
reconsider D4 = D1 as (Element of ( NAT )) by L44 , XBOOLE_0:def 5;
L45: (not D4 in ( dom C16 )) by L44 , XBOOLE_0:def 5;
L46: ( dom ( DataPart C17 ) ) c= ( SCM-Data-Loc ) by RELAT_1:58 , SCMPDS_2:84;
reconsider D5 = D3 as Int_position by L46 , L41 , AMI_2:def 16;
L47: ( dom ( Start-At (D4 , ( SCMPDS )) ) ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
L48: ( IC ( SCMPDS ) ) in ( dom ( Start-At (D4 , ( SCMPDS )) ) ) by L47 , TARSKI:def 1;
L49: ( dom C17 ) misses { ( IC ( SCMPDS ) ) } by L32 , ZFMISC_1:50;
set D6 = ( C17 +* ( Start-At (D4 , ( SCMPDS )) ) );
set D7 = ( C17 +* ( Start-At (D4 , ( SCMPDS )) ) );
set D8 = ( C16 +* ( D4 .--> ( D5 := 1 ) ) );
set D9 = ( C16 +* ( D4 .--> ( D5 := ( 0 ) ) ) );
L50: ( dom ( D4 .--> ( D5 := 1 ) ) ) = { D4 } by FUNCOP_1:13;
L51: ( dom C16 ) misses ( dom ( D4 .--> ( D5 := 1 ) ) ) by L50 , L45 , ZFMISC_1:50;
L52: ( dom ( D4 .--> ( D5 := ( 0 ) ) ) ) = { D4 } by FUNCOP_1:13;
L53: ( dom C16 ) misses ( dom ( D4 .--> ( D5 := ( 0 ) ) ) ) by L52 , L45 , ZFMISC_1:50;
consider C18 being (State of ( SCMPDS )) such that L54: D7 c= C18 by PBOOLE:141;
consider C19 being (Instruction-Sequence of ( SCMPDS )) such that L55: D9 c= C19 by PBOOLE:145;
consider C20 being (State of ( SCMPDS )) such that L56: D6 c= C20 by PBOOLE:141;
consider C21 being (Instruction-Sequence of ( SCMPDS )) such that L57: D8 c= C21 by PBOOLE:145;
take D10 = C19;
take D11 = C21;
L58: ( dom ( Start-At (D4 , ( SCMPDS )) ) ) = ( dom ( Start-At (D4 , ( SCMPDS )) ) )
.= { ( IC ( SCMPDS ) ) } by FUNCOP_1:13
.= { ( IC ( SCMPDS ) ) };
L59: ( ( dom C17 ) /\ ( dom ( Start-At (D4 , ( SCMPDS )) ) ) ) = ( ( dom C17 ) /\ { ( IC ( SCMPDS ) ) } ) by L58
.= ( {} ) by L49 , XBOOLE_0:def 7
.= ( {} );
L60: ( dom C17 ) misses ( dom ( Start-At (D4 , ( SCMPDS )) ) ) by L59 , XBOOLE_0:def 7;
L61: C17 c= D7 by L60 , FUNCT_4:32;
L62: C17 c= C18 by L61 , L54 , XBOOLE_1:1;
L63: C16 c= D9 by L53 , FUNCT_4:32;
thus L64: C16 c= D10 by L63 , L55 , XBOOLE_1:1;
L65: ( dom ( Start-At (D4 , ( SCMPDS )) ) ) = ( dom ( Start-At (D4 , ( SCMPDS )) ) )
.= { ( IC ( SCMPDS ) ) } by FUNCOP_1:13
.= { ( IC ( SCMPDS ) ) };
L66: ( ( dom C17 ) /\ ( dom ( Start-At (D4 , ( SCMPDS )) ) ) ) = ( ( dom C17 ) /\ { ( IC ( SCMPDS ) ) } ) by L65
.= ( {} ) by L49 , XBOOLE_0:def 7
.= ( {} );
L67: ( dom C17 ) misses ( dom ( Start-At (D4 , ( SCMPDS )) ) ) by L66 , XBOOLE_0:def 7;
L68: C17 c= D6 by L67 , FUNCT_4:32;
L69: C17 c= C20 by L68 , L56 , XBOOLE_1:1;
L70: C16 c= D8 by L51 , FUNCT_4:32;
thus L71: C16 c= D11 by L70 , L57 , XBOOLE_1:1;
take C18;
take C20;
L72: C17 c= C18 by L62;
thus L73: C17 c= C18 by L72;
thus L74: C17 c= C20 by L69;
take 1;
L75: ( dom D6 ) = ( ( dom C17 ) \/ ( dom ( Start-At (D4 , ( SCMPDS )) ) ) ) by FUNCT_4:def 1;
L76: ( dom D8 ) = ( ( dom C16 ) \/ ( dom ( D4 .--> ( D5 := 1 ) ) ) ) by FUNCT_4:def 1;
L77: ( IC ( SCMPDS ) ) in ( dom ( Start-At (D4 , ( SCMPDS )) ) ) by L48;
L78: ( IC ( SCMPDS ) ) in ( dom D6 ) by L77 , L75 , XBOOLE_0:def 3;
L79: ( IC C20 ) = ( D6 . ( IC ( SCMPDS ) ) ) by L78 , L56 , GRFUNC_1:2
.= ( ( Start-At (D4 , ( SCMPDS )) ) . ( IC ( SCMPDS ) ) ) by L77 , FUNCT_4:13
.= ( ( Start-At (D4 , ( SCMPDS )) ) . ( IC ( SCMPDS ) ) )
.= D4 by FUNCOP_1:72;
L80: D4 in ( dom ( D4 .--> ( D5 := 1 ) ) ) by L50 , TARSKI:def 1;
L81: D4 in ( dom ( D4 .--> ( D5 := 1 ) ) ) by L80;
L82: D4 in ( dom D8 ) by L81 , L76 , XBOOLE_0:def 3;
L83: ( C21 . D4 ) = ( D8 . D4 ) by L82 , L57 , GRFUNC_1:2
.= ( ( D4 .--> ( D5 := 1 ) ) . D4 ) by L81 , FUNCT_4:13
.= ( ( D4 .--> ( D5 := 1 ) ) . D4 )
.= ( D5 := 1 ) by FUNCOP_1:72;
L84: ( C21 /. ( IC C20 ) ) = ( C21 . ( IC C20 ) ) by PBOOLE:143;
L85: ( ( Comput (C21 , C20 , ( ( 0 ) + 1 )) ) . D5 ) = ( ( Following (C21 , ( Comput (C21 , C20 , ( 0 )) )) ) . D5 ) by EXTPRO_1:3
.= ( ( Following (C21 , C20) ) . D5 )
.= 1 by L79 , L83 , L84 , SCMPDS_2:45;
L86: ( dom C17 ) c= (the carrier of ( SCMPDS )) by RELAT_1:def 18;
L87: ( dom ( Comput (C19 , C18 , 1) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L88: ( dom ( ( Comput (C19 , C18 , 1) ) | ( dom C17 ) ) ) = ( dom C17 ) by L87 , L86 , RELAT_1:62;
L89: ( dom D7 ) = ( ( dom C17 ) \/ ( dom ( Start-At (D4 , ( SCMPDS )) ) ) ) by FUNCT_4:def 1;
L90: ( dom D9 ) = ( ( dom C16 ) \/ ( dom ( D4 .--> ( D5 := ( 0 ) ) ) ) ) by FUNCT_4:def 1;
L91: ( IC ( SCMPDS ) ) in ( dom ( Start-At (D4 , ( SCMPDS )) ) ) by L48;
L92: ( IC ( SCMPDS ) ) in ( dom D7 ) by L91 , L89 , XBOOLE_0:def 3;
L93: ( IC C18 ) = ( D7 . ( IC ( SCMPDS ) ) ) by L92 , L54 , GRFUNC_1:2
.= ( ( Start-At (D4 , ( SCMPDS )) ) . ( IC ( SCMPDS ) ) ) by L91 , FUNCT_4:13
.= ( ( Start-At (D4 , ( SCMPDS )) ) . ( IC ( SCMPDS ) ) )
.= D4 by FUNCOP_1:72;
L94: ( dom ( D4 .--> ( D5 := ( 0 ) ) ) ) = { D4 } by FUNCOP_1:13;
L95: D4 in ( dom ( D4 .--> ( D5 := ( 0 ) ) ) ) by L94 , TARSKI:def 1;
L96: D4 in ( dom ( D4 .--> ( D5 := ( 0 ) ) ) ) by L95;
L97: D4 in ( dom D9 ) by L96 , L90 , XBOOLE_0:def 3;
L98: ( C19 . D4 ) = ( D9 . D4 ) by L97 , L55 , GRFUNC_1:2
.= ( ( D4 .--> ( D5 := ( 0 ) ) ) . D4 ) by L96 , FUNCT_4:13
.= ( ( D4 .--> ( D5 := ( 0 ) ) ) . D4 )
.= ( D5 := ( 0 ) ) by FUNCOP_1:72;
L99: ( C19 /. ( IC C18 ) ) = ( C19 . ( IC C18 ) ) by PBOOLE:143;
L100: ( dom ( Comput (C21 , C20 , 1) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2;
L101: ( dom ( ( Comput (C21 , C20 , 1) ) | ( dom C17 ) ) ) = ( dom C17 ) by L86 , L100 , RELAT_1:62;
L102: ( ( Comput (C19 , C18 , ( ( 0 ) + 1 )) ) . D5 ) = ( ( Following (C19 , ( Comput (C19 , C18 , ( 0 )) )) ) . D5 ) by EXTPRO_1:3
.= ( ( Following (C19 , C18) ) . D5 )
.= ( 0 ) by L93 , L98 , L99 , SCMPDS_2:45;
L103: ( ( ( Comput (C19 , C18 , 1) ) | ( dom C17 ) ) . D5 ) = ( 0 ) by L102 , L41 , L88 , L39 , FUNCT_1:47;
thus L104: thesis by L103 , L85 , L41 , L101 , L39 , FUNCT_1:47;
end;
thus L105: contradiction by L40;
end;
end;
theorem
L107: (for B17 , B18 being (State of ( SCMPDS )) holds (for B19 , B20 , B21 being Integer holds ((( IC B17 ) = ( IC B18 ) & B19 <> B20 & B21 = ( IC B17 ) & ( B21 + B19 ) >= ( 0 ) & ( B21 + B20 ) >= ( 0 )) implies ( ICplusConst (B17 , B19) ) <> ( ICplusConst (B18 , B20) ))))
proof
let C22 , C23 being (State of ( SCMPDS ));
let C24 , C25 , C26 being Integer;
assume that
L108: ( IC C22 ) = ( IC C23 )
and
L109: C24 <> C25
and
L110: C26 = ( IC C22 )
and
L111: ( C26 + C24 ) >= ( 0 )
and
L112: ( C26 + C25 ) >= ( 0 );
L113: (ex B22 being (Element of ( NAT )) st (B22 = ( IC C22 ) & ( ICplusConst (C22 , C24) ) = ( abs ( B22 + C24 ) ))) by SCMPDS_2:def 18;
L114: ( ICplusConst (C22 , C24) ) = ( C26 + C24 ) by L113 , L110 , L111 , ABSVALUE:def 1;
assume L115: ( ICplusConst (C22 , C24) ) = ( ICplusConst (C23 , C25) );
L116: (ex B23 being (Element of ( NAT )) st (B23 = ( IC C23 ) & ( ICplusConst (C23 , C25) ) = ( abs ( B23 + C25 ) ))) by SCMPDS_2:def 18;
L117: ( ICplusConst (C23 , C25) ) = ( C26 + C25 ) by L116 , L108 , L110 , L112 , ABSVALUE:def 1;
thus L118: contradiction by L117 , L109 , L115 , L114;
end;
theorem
L119: (for B24 , B25 being (State of ( SCMPDS )) holds (for B26 , B27 being (Element of ( NAT )) holds ((( IC B24 ) = ( IC B25 ) & B26 <> B27) implies ( ICplusConst (B24 , B26) ) <> ( ICplusConst (B25 , B27) ))))
proof
let C27 , C28 being (State of ( SCMPDS ));
let C29 , C30 being (Element of ( NAT ));
reconsider D12 = ( IC C27 ) as (Element of ( NAT ));
set D13 = ( D12 + 2 );
L120: ( ( D13 - 2 ) + C29 ) = ( D12 + C29 );
L121: ( ( D13 - 2 ) + C29 ) >= ( 0 ) by L120 , NAT_1:2;
L122: ( ( D13 - 2 ) + C30 ) = ( D12 + C30 );
L123: ( ( D13 - 2 ) + C30 ) >= ( 0 ) by L122 , NAT_1:2;
assume L124: (( IC C27 ) = ( IC C28 ) & C29 <> C30);
thus L125: thesis by L124 , L121 , L123 , L107;
end;
theorem
L126: (for B28 being (State of ( SCMPDS )) holds ( succ ( IC B28 ) ) = ( ICplusConst (B28 , 1) ))
proof
let C31 being (State of ( SCMPDS ));
consider R1 being (Element of ( NAT )) such that L127: R1 = ( IC C31 ) and L128: ( ICplusConst (C31 , 1) ) = ( abs ( R1 + 1 ) ) by SCMPDS_2:def 18;
reconsider D14 = ( IC C31 ) as (Element of ( NAT ));
L129: ( R1 * 1 ) >= ( 0 ) by NAT_1:2;
L130: R1 >= ( 0 ) by NAT_1:2;
L131: ( succ ( IC C31 ) ) = ( ( abs D14 ) + 1 ) by L130 , L127 , ABSVALUE:def 1
.= ( ( abs D14 ) + ( abs 1 ) ) by ABSVALUE:def 1
.= ( abs ( D14 + 1 ) ) by L127 , L129 , ABSVALUE:11;
thus L132: thesis by L131 , L127 , L128;
end;
registration
cluster ( SCMPDS ) ->  CurIns-recognized;
coherence
proof
let C32 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C33 being C32 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C34 being (State of ( SCMPDS ));
assume that
L133: C33 c= C34;
let C35 being (Instruction-Sequence of ( SCMPDS ));
assume that
L134: C32 c= C35;
let C36 being (Element of ( NAT ));
set D15 = ( Comput (C35 , C34 , C36) );
set D16 = ( IC D15 );
set D17 = ( D16 + 1 );
assume L135: (not ( IC ( Comput (C35 , C34 , C36) ) ) in ( dom C32 ));
L136: (not D16 in ( dom C32 )) by L135;
set D18 = ( the Int_position := ( 0 ) );
set D19 = ( C32 +* ( D16 .--> D18 ) );
set D20 = ( C32 +* ( D16 .--> ( halt ( SCMPDS ) ) ) );
reconsider D21 = ( C35 +* ( D16 .--> D18 ) ) as (Instruction-Sequence of ( SCMPDS ));
reconsider D22 = ( C35 +* ( D16 .--> ( halt ( SCMPDS ) ) ) ) as (Instruction-Sequence of ( SCMPDS ));
L137: ( dom ( D16 .--> ( halt ( SCMPDS ) ) ) ) = { D16 } by FUNCOP_1:13;
L138: D16 in ( dom ( D16 .--> ( halt ( SCMPDS ) ) ) ) by L137 , TARSKI:def 1;
L139: ( dom ( D16 .--> D18 ) ) = { D16 } by FUNCOP_1:13;
L140: D16 in ( dom ( D16 .--> D18 ) ) by L139 , TARSKI:def 1;
L141: ( dom C32 ) misses ( dom ( D16 .--> ( halt ( SCMPDS ) ) ) ) by L136 , L137 , ZFMISC_1:50;
L142: ( dom C32 ) misses ( dom ( D16 .--> D18 ) ) by L136 , L139 , ZFMISC_1:50;
L143: D19 c= D21 by L134 , FUNCT_4:123;
L144: D20 c= D22 by L134 , FUNCT_4:123;
set D23 = ( Comput (D22 , C34 , C36) );
set D24 = ( Comput (D21 , C34 , C36) );
L145: (not C33 is C32 -autonomic)
proof
L146: ( ( D16 .--> ( halt ( SCMPDS ) ) ) . D16 ) = ( halt ( SCMPDS ) ) by FUNCOP_1:72;
L147: ( D22 . D16 ) = ( halt ( SCMPDS ) ) by L146 , L138 , FUNCT_4:13;
L148: ( ( D16 .--> D18 ) . D16 ) = D18 by FUNCOP_1:72;
L149: ( D21 . D16 ) = D18 by L148 , L140 , FUNCT_4:13;
take D21;
take D22;
L150: C32 c= D19 by L142 , FUNCT_4:32;
thus L151: C32 c= D21 by L150 , L143 , XBOOLE_1:1;
L152: C32 c= D20 by L141 , FUNCT_4:32;
thus L153: C32 c= D22 by L152 , L144 , XBOOLE_1:1;
take C34;
take C34;
thus L154: C33 c= C34 by L133;
L155: ( D24 | ( dom C33 ) ) = ( D15 | ( dom C33 ) ) by L151 , L134 , L133 , EXTPRO_1:def 10;
thus L156: C33 c= C34 by L133;
L157: ( D24 | ( dom C33 ) ) = ( D23 | ( dom C33 ) ) by L151 , L153 , L133 , EXTPRO_1:def 10;
take D25 = ( C36 + 1 );
set D26 = ( Comput (D21 , C34 , D25) );
L158: ( IC ( SCMPDS ) ) in ( dom C33 ) by AMISTD_5:6;
L159: ( IC D15 ) = ( IC ( D15 | ( dom C33 ) ) ) by L158 , FUNCT_1:49;
L160: ( IC D24 ) = D16 by L159 , L155 , L158 , FUNCT_1:49;
L161: ( CurInstr (D21 , D24) ) = ( D21 . D16 ) by L160 , PBOOLE:143
.= D18 by L149;
L162: D26 = ( Following (D21 , D24) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D21 , D24) ) , D24) )
.= ( Exec (D18 , D24) ) by L161;
L163: ( IC ( Exec (D18 , D24) ) ) = ( succ ( IC D24 ) ) by SCMPDS_2:45;
L164: ( IC ( SCMPDS ) ) in ( dom C33 ) by AMISTD_5:6;
L165: ( IC D15 ) = ( IC ( D15 | ( dom C33 ) ) ) by L164 , FUNCT_1:49;
L166: ( IC D24 ) = D16 by L165 , L155 , L164 , FUNCT_1:49;
L167: ( IC D26 ) = ( succ D16 ) by L166 , L162 , L163
.= D17;
set D27 = ( Comput (D22 , C34 , D25) );
L168: D27 = ( Following (D22 , D23) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (D22 , D23) ) , D23) );
L169: ( D22 /. ( IC D23 ) ) = ( D22 . ( IC D23 ) ) by PBOOLE:143;
L170: ( IC D23 ) = D16 by L155 , L165 , L157 , L164 , FUNCT_1:49;
L171: ( IC D27 ) = D16 by L170 , L168 , L147 , L169 , EXTPRO_1:def 3;
L172: (( IC ( D26 | ( dom C33 ) ) ) = ( IC D26 ) & ( IC ( D27 | ( dom C33 ) ) ) = ( IC D27 )) by L164 , FUNCT_1:49;
thus L173: thesis by L172 , L167 , L171;
end;
thus L174: contradiction by L145;
end;
end;
theorem
L176: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B29 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B30 being B29 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B31 , B32 being (State of ( SCMPDS )) holds ((B30 c= B31 & B30 c= B32 & B29 c= R10 & B29 c= R11) implies (for B33 being (Element of ( NAT )) holds (for B34 , B35 being Integer holds (for B36 , B37 being Int_position holds ((( CurInstr (R10 , ( Comput (R10 , B31 , B33) )) ) = ( (B36 , B34) := (B37 , B35) ) & B36 in ( dom B30 ) & ( DataLoc (( ( Comput (R10 , B31 , B33) ) . B36 ) , B34) ) in ( dom B30 )) implies ( ( Comput (R10 , B31 , B33) ) . ( DataLoc (( ( Comput (R10 , B31 , B33) ) . B37 ) , B35) ) ) = ( ( Comput (R11 , B32 , B33) ) . ( DataLoc (( ( Comput (R11 , B32 , B33) ) . B37 ) , B35) ) )))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C37 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C38 being C37 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C39 , C40 being (State of ( SCMPDS ));
assume that
L177: (C38 c= C39 & C38 c= C40)
and
L178: (C37 c= R10 & C37 c= R11);
L179: (C38 c= C39 & C38 c= C40) by L177;
let C41 being (Element of ( NAT ));
let C42 , C43 being Integer;
let C44 , C45 being Int_position;
set D28 = ( CurInstr (R10 , ( Comput (R10 , C39 , C41) )) );
set D29 = ( Comput (R10 , C39 , C41) );
set D30 = ( Comput (R11 , C40 , C41) );
assume that
L180: D28 = ( (C44 , C42) := (C45 , C43) )
and
L181: C44 in ( dom C38 )
and
L182: ( DataLoc (( D29 . C44 ) , C42) ) in ( dom C38 );
L183: (C44 in ( dom C38 ) implies (( ( D29 | ( dom C38 ) ) . C44 ) = ( D29 . C44 ) & ( ( D30 | ( dom C38 ) ) . C44 ) = ( D30 . C44 ))) by FUNCT_1:49;
L184: ( D29 . C44 ) = ( D30 . C44 ) by L183 , L181 , L178 , L179 , EXTPRO_1:def 10;
set D31 = ( Comput (R10 , C39 , ( C41 + 1 )) );
L185: D31 = ( Following (R10 , D29) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D29) ) , D29) );
L186: ( D31 . ( DataLoc (( D29 . C44 ) , C42) ) ) = ( D29 . ( DataLoc (( D29 . C45 ) , C43) ) ) by L185 , L180 , SCMPDS_2:47;
set D32 = ( Comput (R11 , C40 , ( C41 + 1 )) );
L187: D32 = ( Following (R11 , D30) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D30) ) , D30) );
L188: (( DataLoc (( D29 . C44 ) , C42) ) in ( dom C38 ) implies (( ( D31 | ( dom C38 ) ) . ( DataLoc (( D29 . C44 ) , C42) ) ) = ( D31 . ( DataLoc (( D29 . C44 ) , C42) ) ) & ( ( D32 | ( dom C38 ) ) . ( DataLoc (( D29 . C44 ) , C42) ) ) = ( D32 . ( DataLoc (( D29 . C44 ) , C42) ) ))) by FUNCT_1:49;
L189: D28 = ( CurInstr (R11 , ( Comput (R11 , C40 , C41) )) ) by L177 , L178 , AMISTD_5:7;
L190: ( D32 . ( DataLoc (( D30 . C44 ) , C42) ) ) = ( D30 . ( DataLoc (( D30 . C45 ) , C43) ) ) by L189 , L187 , L180 , SCMPDS_2:47;
thus L191: thesis by L190 , L188 , L182 , L184 , L186 , L178 , L179 , EXTPRO_1:def 10;
end;
theorem
L192: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B38 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B39 being B38 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B40 , B41 being (State of ( SCMPDS )) holds ((B39 c= B40 & B39 c= B41 & B38 c= R10 & B38 c= R11) implies (for B42 being (Element of ( NAT )) holds (for B43 , B44 being Integer holds (for B45 , B46 being Int_position holds ((( CurInstr (R10 , ( Comput (R10 , B40 , B42) )) ) = ( AddTo (B45 , B43 , B46 , B44) ) & B45 in ( dom B39 ) & ( DataLoc (( ( Comput (R10 , B40 , B42) ) . B45 ) , B43) ) in ( dom B39 )) implies ( ( Comput (R10 , B40 , B42) ) . ( DataLoc (( ( Comput (R10 , B40 , B42) ) . B46 ) , B44) ) ) = ( ( Comput (R11 , B41 , B42) ) . ( DataLoc (( ( Comput (R11 , B41 , B42) ) . B46 ) , B44) ) )))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C46 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C47 being C46 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C48 , C49 being (State of ( SCMPDS ));
assume that
L193: (C47 c= C48 & C47 c= C49)
and
L194: (C46 c= R10 & C46 c= R11);
L195: (C47 c= C48 & C47 c= C49) by L193;
let C50 being (Element of ( NAT ));
let C51 , C52 being Integer;
let C53 , C54 being Int_position;
set D33 = ( CurInstr (R10 , ( Comput (R10 , C48 , C50) )) );
set D34 = ( Comput (R10 , C48 , C50) );
set D35 = ( Comput (R11 , C49 , C50) );
assume that
L196: D33 = ( AddTo (C53 , C51 , C54 , C52) )
and
L197: C53 in ( dom C47 )
and
L198: ( DataLoc (( D34 . C53 ) , C51) ) in ( dom C47 );
L199: (C53 in ( dom C47 ) implies (( ( D34 | ( dom C47 ) ) . C53 ) = ( D34 . C53 ) & ( ( D35 | ( dom C47 ) ) . C53 ) = ( D35 . C53 ))) by FUNCT_1:49;
L200: ( D34 . C53 ) = ( D35 . C53 ) by L199 , L197 , L194 , L195 , EXTPRO_1:def 10;
set D36 = ( Comput (R11 , C49 , ( C50 + 1 )) );
set D37 = ( Comput (R10 , C48 , ( C50 + 1 )) );
set D38 = ( D37 . ( DataLoc (( D34 . C53 ) , C51) ) );
set D39 = ( D36 . ( DataLoc (( D35 . C53 ) , C51) ) );
set D40 = ( D34 . ( DataLoc (( D34 . C53 ) , C51) ) );
set D41 = ( D34 . ( DataLoc (( D34 . C54 ) , C52) ) );
set D42 = ( D35 . ( DataLoc (( D35 . C53 ) , C51) ) );
set D43 = ( D35 . ( DataLoc (( D35 . C54 ) , C52) ) );
L201: D36 = ( Following (R11 , D35) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D35) ) , D35) );
L202: (( DataLoc (( D34 . C53 ) , C51) ) in ( dom C47 ) implies (( ( D37 | ( dom C47 ) ) . ( DataLoc (( D34 . C53 ) , C51) ) ) = ( D37 . ( DataLoc (( D34 . C53 ) , C51) ) ) & ( ( D36 | ( dom C47 ) ) . ( DataLoc (( D34 . C53 ) , C51) ) ) = ( D36 . ( DataLoc (( D34 . C53 ) , C51) ) ))) by FUNCT_1:49;
L203: D38 = D39 by L202 , L198 , L200 , L194 , L195 , EXTPRO_1:def 10;
L204: D37 = ( Following (R10 , D34) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D34) ) , D34) );
L205: D38 = ( D40 + D41 ) by L204 , L196 , SCMPDS_2:49;
L206: (( DataLoc (( D34 . C53 ) , C51) ) in ( dom C47 ) implies (( ( D34 | ( dom C47 ) ) . ( DataLoc (( D34 . C53 ) , C51) ) ) = ( D34 . ( DataLoc (( D34 . C53 ) , C51) ) ) & ( ( D35 | ( dom C47 ) ) . ( DataLoc (( D34 . C53 ) , C51) ) ) = ( D35 . ( DataLoc (( D34 . C53 ) , C51) ) ))) by FUNCT_1:49;
L207: D40 = D42 by L206 , L198 , L200 , L194 , L195 , EXTPRO_1:def 10;
L208: D33 = ( CurInstr (R11 , ( Comput (R11 , C49 , C50) )) ) by L193 , L194 , AMISTD_5:7;
L209: D39 = ( D42 + D43 ) by L208 , L201 , L196 , SCMPDS_2:49;
thus L210: thesis by L209 , L207 , L203 , L205;
end;
theorem
L211: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B47 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B48 being B47 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B49 , B50 being (State of ( SCMPDS )) holds ((B48 c= B49 & B48 c= B50 & B47 c= R10 & B47 c= R11) implies (for B51 being (Element of ( NAT )) holds (for B52 , B53 being Integer holds (for B54 , B55 being Int_position holds ((( CurInstr (R10 , ( Comput (R10 , B49 , B51) )) ) = ( SubFrom (B54 , B52 , B55 , B53) ) & B54 in ( dom B48 ) & ( DataLoc (( ( Comput (R10 , B49 , B51) ) . B54 ) , B52) ) in ( dom B48 )) implies ( ( Comput (R10 , B49 , B51) ) . ( DataLoc (( ( Comput (R10 , B49 , B51) ) . B55 ) , B53) ) ) = ( ( Comput (R11 , B50 , B51) ) . ( DataLoc (( ( Comput (R11 , B50 , B51) ) . B55 ) , B53) ) )))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C55 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C56 being C55 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C57 , C58 being (State of ( SCMPDS ));
assume that
L212: (C56 c= C57 & C56 c= C58)
and
L213: (C55 c= R10 & C55 c= R11);
L214: (C56 c= C57 & C56 c= C58) by L212;
let C59 being (Element of ( NAT ));
let C60 , C61 being Integer;
let C62 , C63 being Int_position;
set D44 = ( CurInstr (R10 , ( Comput (R10 , C57 , C59) )) );
set D45 = ( Comput (R10 , C57 , C59) );
set D46 = ( Comput (R11 , C58 , C59) );
assume that
L215: D44 = ( SubFrom (C62 , C60 , C63 , C61) )
and
L216: C62 in ( dom C56 )
and
L217: ( DataLoc (( D45 . C62 ) , C60) ) in ( dom C56 );
L218: (C62 in ( dom C56 ) implies (( ( D45 | ( dom C56 ) ) . C62 ) = ( D45 . C62 ) & ( ( D46 | ( dom C56 ) ) . C62 ) = ( D46 . C62 ))) by FUNCT_1:49;
L219: ( D45 . C62 ) = ( D46 . C62 ) by L218 , L216 , L213 , L214 , EXTPRO_1:def 10;
set D47 = ( Comput (R11 , C58 , ( C59 + 1 )) );
set D48 = ( Comput (R10 , C57 , ( C59 + 1 )) );
set D49 = ( D48 . ( DataLoc (( D45 . C62 ) , C60) ) );
set D50 = ( D47 . ( DataLoc (( D46 . C62 ) , C60) ) );
set D51 = ( D45 . ( DataLoc (( D45 . C62 ) , C60) ) );
set D52 = ( D45 . ( DataLoc (( D45 . C63 ) , C61) ) );
set D53 = ( D46 . ( DataLoc (( D46 . C62 ) , C60) ) );
set D54 = ( D46 . ( DataLoc (( D46 . C63 ) , C61) ) );
L220: D47 = ( Following (R11 , D46) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D46) ) , D46) );
L221: (( DataLoc (( D45 . C62 ) , C60) ) in ( dom C56 ) implies (( ( D48 | ( dom C56 ) ) . ( DataLoc (( D45 . C62 ) , C60) ) ) = ( D48 . ( DataLoc (( D45 . C62 ) , C60) ) ) & ( ( D47 | ( dom C56 ) ) . ( DataLoc (( D45 . C62 ) , C60) ) ) = ( D47 . ( DataLoc (( D45 . C62 ) , C60) ) ))) by FUNCT_1:49;
L222: D49 = D50 by L221 , L217 , L219 , L213 , L214 , EXTPRO_1:def 10;
L223: D48 = ( Following (R10 , D45) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D45) ) , D45) );
L224: D49 = ( D51 - D52 ) by L223 , L215 , SCMPDS_2:50;
L225: (( DataLoc (( D45 . C62 ) , C60) ) in ( dom C56 ) implies (( ( D45 | ( dom C56 ) ) . ( DataLoc (( D45 . C62 ) , C60) ) ) = ( D45 . ( DataLoc (( D45 . C62 ) , C60) ) ) & ( ( D46 | ( dom C56 ) ) . ( DataLoc (( D45 . C62 ) , C60) ) ) = ( D46 . ( DataLoc (( D45 . C62 ) , C60) ) ))) by FUNCT_1:49;
L226: D51 = D53 by L225 , L217 , L219 , L213 , L214 , EXTPRO_1:def 10;
L227: D44 = ( CurInstr (R11 , ( Comput (R11 , C58 , C59) )) ) by L212 , L213 , AMISTD_5:7;
L228: D50 = ( D53 - D54 ) by L227 , L220 , L215 , SCMPDS_2:50;
thus L229: thesis by L228 , L226 , L222 , L224;
end;
theorem
L230: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B56 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B57 being B56 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B58 , B59 being (State of ( SCMPDS )) holds ((B57 c= B58 & B57 c= B59 & B56 c= R10 & B56 c= R11) implies (for B60 being (Element of ( NAT )) holds (for B61 , B62 being Integer holds (for B63 , B64 being Int_position holds ((( CurInstr (R10 , ( Comput (R10 , B58 , B60) )) ) = ( MultBy (B63 , B61 , B64 , B62) ) & B63 in ( dom B57 ) & ( DataLoc (( ( Comput (R10 , B58 , B60) ) . B63 ) , B61) ) in ( dom B57 )) implies ( ( ( Comput (R10 , B58 , B60) ) . ( DataLoc (( ( Comput (R10 , B58 , B60) ) . B63 ) , B61) ) ) * ( ( Comput (R10 , B58 , B60) ) . ( DataLoc (( ( Comput (R10 , B58 , B60) ) . B64 ) , B62) ) ) ) = ( ( ( Comput (R11 , B59 , B60) ) . ( DataLoc (( ( Comput (R11 , B59 , B60) ) . B63 ) , B61) ) ) * ( ( Comput (R11 , B59 , B60) ) . ( DataLoc (( ( Comput (R11 , B59 , B60) ) . B64 ) , B62) ) ) )))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C64 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C65 being C64 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C66 , C67 being (State of ( SCMPDS ));
assume that
L231: (C65 c= C66 & C65 c= C67)
and
L232: (C64 c= R10 & C64 c= R11);
L233: (C65 c= C66 & C65 c= C67) by L231;
let C68 being (Element of ( NAT ));
let C69 , C70 being Integer;
let C71 , C72 being Int_position;
set D55 = ( CurInstr (R10 , ( Comput (R10 , C66 , C68) )) );
set D56 = ( Comput (R10 , C66 , C68) );
set D57 = ( Comput (R11 , C67 , C68) );
assume that
L234: D55 = ( MultBy (C71 , C69 , C72 , C70) )
and
L235: C71 in ( dom C65 )
and
L236: ( DataLoc (( D56 . C71 ) , C69) ) in ( dom C65 );
L237: (C71 in ( dom C65 ) implies (( ( D56 | ( dom C65 ) ) . C71 ) = ( D56 . C71 ) & ( ( D57 | ( dom C65 ) ) . C71 ) = ( D57 . C71 ))) by FUNCT_1:49;
L238: ( D56 . C71 ) = ( D57 . C71 ) by L237 , L235 , L232 , L233 , EXTPRO_1:def 10;
set D58 = ( Comput (R11 , C67 , ( C68 + 1 )) );
set D59 = ( Comput (R10 , C66 , ( C68 + 1 )) );
set D60 = ( D59 . ( DataLoc (( D56 . C71 ) , C69) ) );
set D61 = ( D58 . ( DataLoc (( D57 . C71 ) , C69) ) );
L239: D59 = ( Following (R10 , D56) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D56) ) , D56) );
L240: D60 = ( ( D56 . ( DataLoc (( D56 . C71 ) , C69) ) ) * ( D56 . ( DataLoc (( D56 . C72 ) , C70) ) ) ) by L239 , L234 , SCMPDS_2:51;
L241: D58 = ( Following (R11 , D57) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D57) ) , D57) );
L242: (( DataLoc (( D56 . C71 ) , C69) ) in ( dom C65 ) implies (( ( D59 | ( dom C65 ) ) . ( DataLoc (( D56 . C71 ) , C69) ) ) = ( D59 . ( DataLoc (( D56 . C71 ) , C69) ) ) & ( ( D58 | ( dom C65 ) ) . ( DataLoc (( D56 . C71 ) , C69) ) ) = ( D58 . ( DataLoc (( D56 . C71 ) , C69) ) ))) by FUNCT_1:49;
L243: D55 = ( CurInstr (R11 , ( Comput (R11 , C67 , C68) )) ) by L231 , L232 , AMISTD_5:7;
L244: D61 = ( ( D57 . ( DataLoc (( D57 . C71 ) , C69) ) ) * ( D57 . ( DataLoc (( D57 . C72 ) , C70) ) ) ) by L243 , L241 , L234 , SCMPDS_2:51;
thus L245: thesis by L244 , L242 , L236 , L238 , L240 , L232 , L233 , EXTPRO_1:def 10;
end;
theorem
L246: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B65 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B66 being B65 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B67 , B68 being (State of ( SCMPDS )) holds ((B66 c= B67 & B66 c= B68 & B65 c= R10 & B65 c= R11) implies (for B69 , B70 being (Element of ( NAT )) holds (for B71 being Int_position holds (for B72 , B73 being Integer holds ((( CurInstr (R10 , ( Comput (R10 , B67 , B69) )) ) = ( (B71 , B72) <>0_goto B73 ) & B70 = ( IC ( Comput (R10 , B67 , B69) ) ) & ( B70 + B73 ) >= ( 0 ) & B73 <> 1) implies (( ( Comput (R10 , B67 , B69) ) . ( DataLoc (( ( Comput (R10 , B67 , B69) ) . B71 ) , B72) ) ) = ( 0 ) iff ( ( Comput (R11 , B68 , B69) ) . ( DataLoc (( ( Comput (R11 , B68 , B69) ) . B71 ) , B72) ) ) = ( 0 ))))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C73 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C74 being C73 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C75 , C76 being (State of ( SCMPDS ));
assume that
L247: (C74 c= C75 & C74 c= C76)
and
L248: (C73 c= R10 & C73 c= R11);
let C77 , C78 being (Element of ( NAT ));
let C79 being Int_position;
let C80 , C81 being Integer;
set D62 = ( Comput (R10 , C75 , C77) );
set D63 = ( Comput (R11 , C76 , C77) );
set D64 = ( Comput (R10 , C75 , ( C77 + 1 )) );
set D65 = ( Comput (R11 , C76 , ( C77 + 1 )) );
L249: (( IC D62 ) = ( IC D63 ) & ( D64 | ( dom C74 ) ) = ( D65 | ( dom C74 ) )) by L247 , L248 , AMISTD_5:7 , EXTPRO_1:def 10;
set D66 = ( CurInstr (R10 , ( Comput (R10 , C75 , C77) )) );
L250: D64 = ( Following (R10 , D62) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D62) ) , D62) );
L251: ( C78 + 1 ) >= ( 0 ) by NAT_1:2;
L252: ( IC ( SCMPDS ) ) in ( dom C74 ) by AMISTD_5:6;
L253: ( IC ( SCMPDS ) ) in ( dom C74 ) by L252;
L254: (( ( D64 | ( dom C74 ) ) . ( IC ( SCMPDS ) ) ) = ( D64 . ( IC ( SCMPDS ) ) ) & ( ( D65 | ( dom C74 ) ) . ( IC ( SCMPDS ) ) ) = ( D65 . ( IC ( SCMPDS ) ) )) by L253 , FUNCT_1:49;
L255: D65 = ( Following (R11 , D63) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D63) ) , D63) );
assume that
L256: D66 = ( (C79 , C80) <>0_goto C81 )
and
L257: (C78 = ( IC D62 ) & ( C78 + C81 ) >= ( 0 ) & C81 <> 1);
L258: D66 = ( CurInstr (R11 , ( Comput (R11 , C76 , C77) )) ) by L247 , L248 , AMISTD_5:7;
L259:
now
assume that
L260: ( ( Comput (R11 , C76 , C77) ) . ( DataLoc (( D63 . C79 ) , C80) ) ) = ( 0 )
and
L261: ( ( Comput (R10 , C75 , C77) ) . ( DataLoc (( D62 . C79 ) , C80) ) ) <> ( 0 );
L262: ( D64 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (D62 , C81) ) by L250 , L256 , L261 , SCMPDS_2:55;
L263: ( D65 . ( IC ( SCMPDS ) ) ) = ( succ ( IC D63 ) ) by L258 , L255 , L256 , L260 , SCMPDS_2:55
.= ( ICplusConst (D63 , 1) ) by L126;
thus L264: contradiction by L263 , L254 , L249 , L257 , L251 , L262 , L107;
end;
L265:
now
assume that
L266: ( ( Comput (R10 , C75 , C77) ) . ( DataLoc (( D62 . C79 ) , C80) ) ) = ( 0 )
and
L267: ( ( Comput (R11 , C76 , C77) ) . ( DataLoc (( D63 . C79 ) , C80) ) ) <> ( 0 );
L268: ( D65 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (D63 , C81) ) by L258 , L255 , L256 , L267 , SCMPDS_2:55;
L269: ( D64 . ( IC ( SCMPDS ) ) ) = ( succ ( IC D62 ) ) by L250 , L256 , L266 , SCMPDS_2:55
.= ( ICplusConst (D62 , 1) ) by L126;
thus L270: contradiction by L269 , L254 , L249 , L257 , L251 , L268 , L107;
end;
thus L271: thesis by L265 , L259;
end;
theorem
L272: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B74 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B75 being B74 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B76 , B77 being (State of ( SCMPDS )) holds ((B75 c= B76 & B75 c= B77 & B74 c= R10 & B74 c= R11) implies (for B78 , B79 being (Element of ( NAT )) holds (for B80 being Int_position holds (for B81 , B82 being Integer holds ((( CurInstr (R10 , ( Comput (R10 , B76 , B78) )) ) = ( (B80 , B81) <=0_goto B82 ) & B79 = ( IC ( Comput (R10 , B76 , B78) ) ) & ( B79 + B82 ) >= ( 0 ) & B82 <> 1) implies (( ( Comput (R10 , B76 , B78) ) . ( DataLoc (( ( Comput (R10 , B76 , B78) ) . B80 ) , B81) ) ) > ( 0 ) iff ( ( Comput (R11 , B77 , B78) ) . ( DataLoc (( ( Comput (R11 , B77 , B78) ) . B80 ) , B81) ) ) > ( 0 ))))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C82 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C83 being C82 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C84 , C85 being (State of ( SCMPDS ));
assume that
L273: (C83 c= C84 & C83 c= C85)
and
L274: (C82 c= R10 & C82 c= R11);
let C86 , C87 being (Element of ( NAT ));
let C88 being Int_position;
let C89 , C90 being Integer;
set D67 = ( Comput (R10 , C84 , C86) );
set D68 = ( Comput (R11 , C85 , C86) );
set D69 = ( Comput (R10 , C84 , ( C86 + 1 )) );
set D70 = ( Comput (R11 , C85 , ( C86 + 1 )) );
L275: (( IC D67 ) = ( IC D68 ) & ( D69 | ( dom C83 ) ) = ( D70 | ( dom C83 ) )) by L273 , L274 , AMISTD_5:7 , EXTPRO_1:def 10;
set D71 = ( CurInstr (R10 , ( Comput (R10 , C84 , C86) )) );
L276: D69 = ( Following (R10 , D67) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D67) ) , D67) );
L277: ( C87 + 1 ) >= ( 0 ) by NAT_1:2;
L278: ( IC ( SCMPDS ) ) in ( dom C83 ) by AMISTD_5:6;
L279: ( IC ( SCMPDS ) ) in ( dom C83 ) by L278;
L280: (( ( D69 | ( dom C83 ) ) . ( IC ( SCMPDS ) ) ) = ( D69 . ( IC ( SCMPDS ) ) ) & ( ( D70 | ( dom C83 ) ) . ( IC ( SCMPDS ) ) ) = ( D70 . ( IC ( SCMPDS ) ) )) by L279 , FUNCT_1:49;
L281: D70 = ( Following (R11 , D68) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D68) ) , D68) );
assume that
L282: D71 = ( (C88 , C89) <=0_goto C90 )
and
L283: (C87 = ( IC D67 ) & ( C87 + C90 ) >= ( 0 ) & C90 <> 1);
L284: D71 = ( CurInstr (R11 , ( Comput (R11 , C85 , C86) )) ) by L273 , L274 , AMISTD_5:7;
L285:
now
assume that
L286: ( ( Comput (R11 , C85 , C86) ) . ( DataLoc (( D68 . C88 ) , C89) ) ) > ( 0 )
and
L287: ( ( Comput (R10 , C84 , C86) ) . ( DataLoc (( D67 . C88 ) , C89) ) ) <= ( 0 );
L288: ( D69 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (D67 , C90) ) by L276 , L282 , L287 , SCMPDS_2:56;
L289: ( D70 . ( IC ( SCMPDS ) ) ) = ( succ ( IC D68 ) ) by L284 , L281 , L282 , L286 , SCMPDS_2:56
.= ( ICplusConst (D68 , 1) ) by L126;
thus L290: contradiction by L289 , L280 , L275 , L283 , L277 , L288 , L107;
end;
L291:
now
assume that
L292: ( ( Comput (R10 , C84 , C86) ) . ( DataLoc (( D67 . C88 ) , C89) ) ) > ( 0 )
and
L293: ( ( Comput (R11 , C85 , C86) ) . ( DataLoc (( D68 . C88 ) , C89) ) ) <= ( 0 );
L294: ( D70 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (D68 , C90) ) by L284 , L281 , L282 , L293 , SCMPDS_2:56;
L295: ( D69 . ( IC ( SCMPDS ) ) ) = ( succ ( IC D67 ) ) by L276 , L282 , L292 , SCMPDS_2:56
.= ( ICplusConst (D67 , 1) ) by L126;
thus L296: contradiction by L295 , L280 , L275 , L283 , L277 , L294 , L107;
end;
thus L297: thesis by L291 , L285;
end;
theorem
L298: (for R10 being (Instruction-Sequence of ( SCMPDS )) holds (for R11 being (Instruction-Sequence of ( SCMPDS )) holds (for B83 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function holds (for B84 being B83 -autonomic non  empty (FinPartState of ( SCMPDS )) holds (for B85 , B86 being (State of ( SCMPDS )) holds ((B84 c= B85 & B84 c= B86 & B83 c= R10 & B83 c= R11) implies (for B87 , B88 being (Element of ( NAT )) holds (for B89 being Int_position holds (for B90 , B91 being Integer holds ((( CurInstr (R10 , ( Comput (R10 , B85 , B87) )) ) = ( (B89 , B90) >=0_goto B91 ) & B88 = ( IC ( Comput (R10 , B85 , B87) ) ) & ( B88 + B91 ) >= ( 0 ) & B91 <> 1) implies (( ( Comput (R10 , B85 , B87) ) . ( DataLoc (( ( Comput (R10 , B85 , B87) ) . B89 ) , B90) ) ) < ( 0 ) iff ( ( Comput (R11 , B86 , B87) ) . ( DataLoc (( ( Comput (R11 , B86 , B87) ) . B89 ) , B90) ) ) < ( 0 ))))))))))))
proof
let R10 being (Instruction-Sequence of ( SCMPDS ));
let R11 being (Instruction-Sequence of ( SCMPDS ));
let C91 being non  halt-free  finite (the InstructionsF of ( SCMPDS )) -valued ( NAT ) -defined Function;
let C92 being C91 -autonomic non  empty (FinPartState of ( SCMPDS ));
let C93 , C94 being (State of ( SCMPDS ));
assume that
L299: (C92 c= C93 & C92 c= C94)
and
L300: (C91 c= R10 & C91 c= R11);
let C95 , C96 being (Element of ( NAT ));
let C97 being Int_position;
let C98 , C99 being Integer;
set D72 = ( Comput (R10 , C93 , C95) );
set D73 = ( Comput (R11 , C94 , C95) );
set D74 = ( Comput (R10 , C93 , ( C95 + 1 )) );
set D75 = ( Comput (R11 , C94 , ( C95 + 1 )) );
L301: (( IC D72 ) = ( IC D73 ) & ( D74 | ( dom C92 ) ) = ( D75 | ( dom C92 ) )) by L299 , L300 , AMISTD_5:7 , EXTPRO_1:def 10;
set D76 = ( CurInstr (R10 , ( Comput (R10 , C93 , C95) )) );
L302: D74 = ( Following (R10 , D72) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R10 , D72) ) , D72) );
L303: ( C96 + 1 ) >= ( 0 ) by NAT_1:2;
L304: ( IC ( SCMPDS ) ) in ( dom C92 ) by AMISTD_5:6;
L305: ( IC ( SCMPDS ) ) in ( dom C92 ) by L304;
L306: (( ( D74 | ( dom C92 ) ) . ( IC ( SCMPDS ) ) ) = ( D74 . ( IC ( SCMPDS ) ) ) & ( ( D75 | ( dom C92 ) ) . ( IC ( SCMPDS ) ) ) = ( D75 . ( IC ( SCMPDS ) ) )) by L305 , FUNCT_1:49;
L307: D75 = ( Following (R11 , D73) ) by EXTPRO_1:3
.= ( Exec (( CurInstr (R11 , D73) ) , D73) );
assume that
L308: D76 = ( (C97 , C98) >=0_goto C99 )
and
L309: (C96 = ( IC D72 ) & ( C96 + C99 ) >= ( 0 ) & C99 <> 1);
L310: D76 = ( CurInstr (R11 , ( Comput (R11 , C94 , C95) )) ) by L299 , L300 , AMISTD_5:7;
L311:
now
assume that
L312: ( ( Comput (R11 , C94 , C95) ) . ( DataLoc (( D73 . C97 ) , C98) ) ) < ( 0 )
and
L313: ( ( Comput (R10 , C93 , C95) ) . ( DataLoc (( D72 . C97 ) , C98) ) ) >= ( 0 );
L314: ( D74 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (D72 , C99) ) by L302 , L308 , L313 , SCMPDS_2:57;
L315: ( D75 . ( IC ( SCMPDS ) ) ) = ( succ ( IC D73 ) ) by L310 , L307 , L308 , L312 , SCMPDS_2:57
.= ( ICplusConst (D73 , 1) ) by L126;
thus L316: contradiction by L315 , L306 , L301 , L309 , L303 , L314 , L107;
end;
L317:
now
assume that
L318: ( ( Comput (R10 , C93 , C95) ) . ( DataLoc (( D72 . C97 ) , C98) ) ) < ( 0 )
and
L319: ( ( Comput (R11 , C94 , C95) ) . ( DataLoc (( D73 . C97 ) , C98) ) ) >= ( 0 );
L320: ( D75 . ( IC ( SCMPDS ) ) ) = ( ICplusConst (D73 , C99) ) by L310 , L307 , L308 , L319 , SCMPDS_2:57;
L321: ( D74 . ( IC ( SCMPDS ) ) ) = ( succ ( IC D72 ) ) by L302 , L308 , L318 , SCMPDS_2:57
.= ( ICplusConst (D72 , 1) ) by L126;
thus L322: contradiction by L321 , L306 , L301 , L309 , L303 , L320 , L107;
end;
thus L323: thesis by L317 , L311;
end;
