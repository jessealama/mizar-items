:: Indexed Category
::  by Grzegorz Bancerek
::
:: Received June 8, 1995
:: Copyright (c) 1995-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, RELAT_1, PBOOLE, SUBSET_1, CAT_5, CAT_1, MCART_1,
      GRCAT_1, GRAPH_1, STRUCT_0, FUNCT_1, FUNCOP_1, PARTFUN1, ZFMISC_1,
      ARYTM_0, TARSKI, GROUP_6, CAT_2, FUNCT_3, INDEX_1, MONOID_0, ISOCAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, MCART_1, RELAT_1, FUNCT_1,
      BINOP_1, PARTFUN1, PBOOLE, FUNCOP_1, FUNCT_2, STRUCT_0, GRAPH_1, CAT_1,
      CAT_2, OPPCAT_1, CAT_5, ISOCAT_1;
 constructors DOMAIN_1, OPPCAT_1, CAT_5, RELSET_1, PBOOLE, XTUPLE_0, ISOCAT_1,
      REALSET1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, FUNCOP_1, PBOOLE, CAT_2, CAT_5,
      STRUCT_0, RELSET_1, CAT_1, XTUPLE_0, OPPCAT_1;
 requirements SUBSET, BOOLE;
 definitions TARSKI, FUNCT_1, PBOOLE, CAT_5, FUNCOP_1, CAT_1, BINOP_1, GRAPH_1,
      XTUPLE_0, FUNCT_2, OPPCAT_1;
 theorems MCART_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1, PARTFUN1, FUNCT_4,
      CAT_1, CAT_2, OPPCAT_1, CAT_5, RELSET_1, ISOCAT_1;
 schemes CLASSES1, PBOOLE, CAT_5;

begin
registration
let C1 being non  empty set;
cluster non  empty-yielding for (ManySortedSet of C1);
existence
proof
take the  non-empty (ManySortedSet of C1);
take the (Element of C1);
thus L1: thesis;
end;
end;
definition
let C2 being  Categorial Category;
let C3 being (Morphism of C2);
redefine func C3 `2 -> (Functor of ( C3 `11 ) , ( C3 `12 ));

coherence
proof
L3: ( dom C3 ) = ( C3 `11 ) by CAT_5:2;
L4: (( C3 `11 ) = ( cat ( C3 `11 ) ) & ( C3 `12 ) = ( cat ( C3 `12 ) )) by CAT_5:def 7;
thus L5: ( C3 `2 ) is (Functor of ( C3 `11 ) , ( C3 `12 )) by L4 , L3 , CAT_5:2;
end;
end;
theorem
L7: (for B1 being  Categorial Category holds (for B2 , B3 being (Morphism of B1) holds (( dom B3 ) = ( cod B2 ) implies ( B3 (*) B2 ) = [ [ ( dom B2 ) , ( cod B3 ) ] , ( ( B3 `2 ) * ( B2 `2 ) ) ])))
proof
let C4 being  Categorial Category;
let C5 , C6 being (Morphism of C4);
L8: ( C6 `11 ) = ( dom C6 ) by CAT_5:13;
L9: ( C5 `11 ) = ( dom C5 ) by CAT_5:13;
assume L10: ( dom C6 ) = ( cod C5 );
consider C7 being (Functor of ( C5 `11 ) , ( C6 `11 )) such that L11: C5 = [ [ ( dom C5 ) , ( cod C5 ) ] , C7 ] by L10 , L8 , L9 , CAT_5:def 6;
L12: ( C6 `12 ) = ( cod C6 ) by CAT_5:13;
consider C8 being (Functor of ( C6 `11 ) , ( C6 `12 )) such that L13: C6 = [ [ ( dom C6 ) , ( cod C6 ) ] , C8 ] by L12 , L8 , CAT_5:def 6;
thus L14: ( C6 (*) C5 ) = [ [ ( dom C5 ) , ( cod C6 ) ] , ( C8 * C7 ) ] by L10 , L8 , L12 , L9 , L13 , L11 , CAT_5:def 6
.= [ [ ( dom C5 ) , ( cod C6 ) ] , ( C8 * ( C5 `2 ) ) ] by L11 , MCART_1:7
.= [ [ ( dom C5 ) , ( cod C6 ) ] , ( ( C6 `2 ) * ( C5 `2 ) ) ] by L13 , MCART_1:7;
end;
theorem
L15: (for B4 being Category holds (for B5 , B6 being  Categorial Category holds (for B7 being (Functor of B4 , B5) holds (for B8 being (Functor of B4 , B6) holds (B7 = B8 implies ( Obj B7 ) = ( Obj B8 ))))))
proof
let C9 being Category;
let C10 , C11 being  Categorial Category;
let C12 being (Functor of C9 , C10);
let C13 being (Functor of C9 , C11);
assume that
L16: C12 = C13;
L17:
now
let C14 being set;
assume L18: C14 in (the carrier of C9);
reconsider D1 = C14 as (Object of C9) by L18;
L19: D1 = ( dom ( id D1 ) );
thus L20: ( ( Obj C12 ) . C14 ) = ( dom ( C12 . (( id D1 ) qua (Morphism of C9)) ) ) by L19 , CAT_1:69
.= ( ( C12 . (( id D1 ) qua (Morphism of C9)) ) `11 ) by CAT_5:13
.= ( dom ( C13 . (( id D1 ) qua (Morphism of C9)) ) ) by L16 , CAT_5:13
.= ( ( Obj C13 ) . C14 ) by L19 , CAT_1:69;
end;
L21: (( dom ( Obj C12 ) ) = (the carrier of C9) & ( dom ( Obj C13 ) ) = (the carrier of C9)) by FUNCT_2:def 1;
thus L22: thesis by L21 , L17 , FUNCT_1:2;
end;
definition
let C15 being Function;
attr C15 is  Category-yielding
means
:L23: (for B9 being set holds (B9 in ( dom C15 ) implies ( C15 . B9 ) is Category));
end;
registration
cluster  Category-yielding for Function;
existence
proof
take D2 = ( ( {} ) --> ( 1Cat (( {} ) , 1) ) );
let C16 being set;
assume L25: C16 in ( dom D2 );
thus L26: thesis by L25;
end;
end;
registration
let C17 being set;
cluster  Category-yielding for (ManySortedSet of C17);
existence
proof
take D3 = ( C17 --> ( 1Cat (( {} ) , 1) ) );
let C18 being set;
assume L28: C18 in ( dom D3 );
L29: C18 in C17 by L28 , FUNCOP_1:13;
thus L30: thesis by L29 , FUNCOP_1:7;
end;
end;
definition
let C19 being set;
mode ManySortedCategory of C19
 is  Category-yielding (ManySortedSet of C19);
end;
definition
let C20 being Category;
mode ManySortedCategory of C20
 is (ManySortedCategory of (the carrier of C20));
end;
registration
let C21 being set;
let C22 being Category;
cluster ( C21 --> C22 ) ->  Category-yielding;
coherence
proof
let C23 being set;
assume L34: C23 in ( dom ( C21 --> C22 ) );
L35: C23 in C21 by L34 , FUNCOP_1:13;
thus L36: thesis by L35 , FUNCOP_1:7;
end;
end;
registration
let C24 being non  empty set;
cluster  -> non  empty for (ManySortedSet of C24);
coherence;
end;
registration
let C25 being  Category-yielding Function;
cluster ( rng C25 ) ->  categorial;
coherence
proof
let C26 being set;
assume L39: C26 in ( rng C25 );
L40: (ex B10 being set st (B10 in ( dom C25 ) & C26 = ( C25 . B10 ))) by L39 , FUNCT_1:def 3;
thus L41: thesis by L40 , L23;
end;
end;
definition
let C27 being non  empty set;
let C28 being (ManySortedCategory of C27);
let C29 being (Element of C27);
redefine func C28 . C29 -> Category;

coherence
proof
L43: ( dom C28 ) = C27 by PARTFUN1:def 2;
thus L44: thesis by L43 , L23;
end;
end;
registration
let C30 being Function;
let C31 being  Category-yielding Function;
cluster ( C31 * C30 ) ->  Category-yielding;
coherence
proof
let C32 being set;
assume L46: C32 in ( dom ( C31 * C30 ) );
L47: (( ( C31 * C30 ) . C32 ) = ( C31 . ( C30 . C32 ) ) & ( C30 . C32 ) in ( dom C31 )) by L46 , FUNCT_1:11 , FUNCT_1:12;
thus L48: thesis by L47 , L23;
end;
end;
definition
let C33 being  Category-yielding Function;
func Objs C33 ->  non-empty Function means 
:L50: (( dom it ) = ( dom C33 ) & (for B11 being set holds (B11 in ( dom C33 ) implies (for B12 being Category holds (B12 = ( C33 . B11 ) implies ( it . B11 ) = (the carrier of B12))))));
existence
proof
defpred S1[ set , set ] means (for B13 being Category holds (B13 = ( C33 . $1 ) implies $2 = (the carrier of B13)));
L51:
now
let C34 being set;
assume L52: C34 in ( dom C33 );
reconsider D4 = ( C33 . C34 ) as Category by L52 , L23;
reconsider D5 = (the carrier of D4) as set;
take D6 = D5;
thus L53: S1[ C34 , D6 ];
end;
consider C35 being Function such that L54: (( dom C35 ) = ( dom C33 ) & (for B14 being set holds (B14 in ( dom C33 ) implies S1[ B14 , ( C35 . B14 ) ]))) from CLASSES1:sch 1(L51);
L55: C35 is  non-empty
proof
let C36 being set;
assume L56: C36 in ( dom C35 );
reconsider D7 = ( C33 . C36 ) as Category by L56 , L54 , L23;
L57: ( C35 . C36 ) = (the carrier of D7) by L54 , L56;
thus L58: thesis by L57;
end;
thus L59: thesis by L55 , L54;
end;
uniqueness
proof
let C37 , C38 being  non-empty Function;
assume that
L60: ( dom C37 ) = ( dom C33 )
and
L61: (for B15 being set holds (B15 in ( dom C33 ) implies (for B16 being Category holds (B16 = ( C33 . B15 ) implies ( C37 . B15 ) = (the carrier of B16)))))
and
L62: ( dom C38 ) = ( dom C33 )
and
L63: (for B17 being set holds (B17 in ( dom C33 ) implies (for B18 being Category holds (B18 = ( C33 . B17 ) implies ( C38 . B17 ) = (the carrier of B18)))));
L64:
now
let C39 being set;
assume L65: C39 in ( dom C33 );
reconsider D8 = ( C33 . C39 ) as Category by L65 , L23;
thus L66: ( C37 . C39 ) = (the carrier of D8) by L61 , L65
.= ( C38 . C39 ) by L63 , L65;
end;
thus L67: thesis by L64 , L60 , L62 , FUNCT_1:2;
end;
func Mphs C33 ->  non-empty Function means 
:L68: (( dom it ) = ( dom C33 ) & (for B19 being set holds (B19 in ( dom C33 ) implies (for B20 being Category holds (B20 = ( C33 . B19 ) implies ( it . B19 ) = (the carrier' of B20))))));
existence
proof
defpred S2[ set , set ] means (for B21 being Category holds (B21 = ( C33 . $1 ) implies $2 = (the carrier' of B21)));
L69:
now
let C40 being set;
assume L70: C40 in ( dom C33 );
reconsider D9 = ( C33 . C40 ) as Category by L70 , L23;
reconsider D10 = (the carrier' of D9) as set;
take D11 = D10;
thus L71: S2[ C40 , D11 ];
end;
consider C41 being Function such that L72: (( dom C41 ) = ( dom C33 ) & (for B22 being set holds (B22 in ( dom C33 ) implies S2[ B22 , ( C41 . B22 ) ]))) from CLASSES1:sch 1(L69);
L73: C41 is  non-empty
proof
let C42 being set;
assume L74: C42 in ( dom C41 );
reconsider D12 = ( C33 . C42 ) as Category by L74 , L72 , L23;
L75: ( C41 . C42 ) = (the carrier' of D12) by L72 , L74;
thus L76: thesis by L75;
end;
thus L77: thesis by L73 , L72;
end;
uniqueness
proof
let C43 , C44 being  non-empty Function;
assume that
L78: ( dom C43 ) = ( dom C33 )
and
L79: (for B23 being set holds (B23 in ( dom C33 ) implies (for B24 being Category holds (B24 = ( C33 . B23 ) implies ( C43 . B23 ) = (the carrier' of B24)))))
and
L80: ( dom C44 ) = ( dom C33 )
and
L81: (for B25 being set holds (B25 in ( dom C33 ) implies (for B26 being Category holds (B26 = ( C33 . B25 ) implies ( C44 . B25 ) = (the carrier' of B26)))));
L82:
now
let C45 being set;
assume L83: C45 in ( dom C33 );
reconsider D13 = ( C33 . C45 ) as Category by L83 , L23;
thus L84: ( C43 . C45 ) = (the carrier' of D13) by L79 , L83
.= ( C44 . C45 ) by L81 , L83;
end;
thus L85: thesis by L82 , L78 , L80 , FUNCT_1:2;
end;
end;
registration
let C46 being non  empty set;
let C47 being (ManySortedCategory of C46);
cluster ( Objs C47 ) -> C46 -defined;
coherence
proof
L87: ( dom ( Objs C47 ) ) = ( dom C47 ) by L50
.= C46 by PARTFUN1:def 2;
thus L88: thesis by L87 , RELAT_1:def 18;
end;
cluster ( Mphs C47 ) -> C46 -defined;
coherence
proof
L89: ( dom ( Mphs C47 ) ) = ( dom C47 ) by L68
.= C46 by PARTFUN1:def 2;
thus L90: thesis by L89 , RELAT_1:def 18;
end;
end;
registration
let C48 being non  empty set;
let C49 being (ManySortedCategory of C48);
cluster ( Objs C49 ) ->  total;
coherence
proof
L92: ( dom ( Objs C49 ) ) = ( dom C49 ) by L50
.= C48 by PARTFUN1:def 2;
thus L93: thesis by L92 , PARTFUN1:def 2;
end;
cluster ( Mphs C49 ) ->  total;
coherence
proof
L94: ( dom ( Mphs C49 ) ) = ( dom C49 ) by L68
.= C48 by PARTFUN1:def 2;
thus L95: thesis by L94 , PARTFUN1:def 2;
end;
end;
theorem
L97: (for B27 being set holds (for B28 being Category holds (( Objs ( B27 --> B28 ) ) = ( B27 --> (the carrier of B28) ) & ( Mphs ( B27 --> B28 ) ) = ( B27 --> (the carrier' of B28) ))))
proof
let C50 being set;
let C51 being Category;
L98: ( dom ( C50 --> C51 ) ) = C50 by FUNCOP_1:13;
L99: ( dom ( Objs ( C50 --> C51 ) ) ) = ( dom ( C50 --> C51 ) ) by L50;
L100:
now
let C52 being set;
assume L101: C52 in ( dom ( Objs ( C50 --> C51 ) ) );
L102: ( ( C50 --> C51 ) . C52 ) = C51 by L101 , L99 , L98 , FUNCOP_1:7;
thus L103: ( ( Objs ( C50 --> C51 ) ) . C52 ) = (the carrier of C51) by L102 , L99 , L101 , L50;
end;
thus L104: ( Objs ( C50 --> C51 ) ) = ( C50 --> (the carrier of C51) ) by L100 , L99 , L98 , FUNCOP_1:11;
L105: ( dom ( Mphs ( C50 --> C51 ) ) ) = ( dom ( C50 --> C51 ) ) by L68;
L106:
now
let C53 being set;
assume L107: C53 in ( dom ( Mphs ( C50 --> C51 ) ) );
L108: ( ( C50 --> C51 ) . C53 ) = C51 by L107 , L105 , L98 , FUNCOP_1:7;
thus L109: ( ( Mphs ( C50 --> C51 ) ) . C53 ) = (the carrier' of C51) by L108 , L105 , L107 , L68;
end;
thus L110: thesis by L106 , L105 , L98 , FUNCOP_1:11;
end;
begin
definition
let C54 , C55 being set;
mode ManySortedSet of C54 , C55
means :L111: (ex B29 being (ManySortedSet of C54) st (ex B30 being (ManySortedSet of C55) st it = [ B29 , B30 ]));
existence
proof
set D14 = the (ManySortedSet of C54);
set D15 = the (ManySortedSet of C55);
take [ D14 , D15 ];
take D14;
take D15;
thus L112: thesis;
end;
end;
definition
let C56 , C57 being set;
let C58 being (ManySortedSet of C56);
let C59 being (ManySortedSet of C57);
redefine func [C58 , C59 ] -> (ManySortedSet of C56 , C57);

coherence
proof
take C58;
take C59;
thus L114: thesis;
end;
end;
registration
let C60 , C61 being set;
let C62 being (ManySortedSet of C60 , C61);
cluster ( C62 `1 ) ->  Function-like  Relation-like;
coherence
proof
L116: (ex B31 being (ManySortedSet of C60) st (ex B32 being (ManySortedSet of C61) st C62 = [ B31 , B32 ])) by L111;
thus L117: thesis by L116 , MCART_1:7;
end;
cluster ( C62 `2 ) ->  Function-like  Relation-like;
coherence
proof
L118: (ex B33 being (ManySortedSet of C60) st (ex B34 being (ManySortedSet of C61) st C62 = [ B33 , B34 ])) by L111;
thus L119: thesis by L118 , MCART_1:7;
end;
end;
registration
let C63 , C64 being set;
let C65 being (ManySortedSet of C63 , C64);
cluster ( C65 `1 ) -> C63 -defined;
coherence
proof
L121: (ex B35 being (ManySortedSet of C63) st (ex B36 being (ManySortedSet of C64) st C65 = [ B35 , B36 ])) by L111;
thus L122: thesis by L121 , MCART_1:7;
end;
cluster ( C65 `2 ) -> C64 -defined;
coherence
proof
L123: (ex B37 being (ManySortedSet of C63) st (ex B38 being (ManySortedSet of C64) st C65 = [ B37 , B38 ])) by L111;
thus L124: thesis by L123 , MCART_1:7;
end;
end;
registration
let C66 , C67 being set;
let C68 being (ManySortedSet of C66 , C67);
cluster ( C68 `1 ) ->  total for C66 -defined C66 -defined C66 -defined C66 -defined Function;
coherence
proof
L126: (ex B39 being (ManySortedSet of C66) st (ex B40 being (ManySortedSet of C67) st C68 = [ B39 , B40 ])) by L111;
thus L127: thesis by L126 , MCART_1:7;
end;
cluster ( C68 `2 ) ->  total for C67 -defined C67 -defined C67 -defined C67 -defined Function;
coherence
proof
L128: (ex B41 being (ManySortedSet of C66) st (ex B42 being (ManySortedSet of C67) st C68 = [ B41 , B42 ])) by L111;
thus L129: thesis by L128 , MCART_1:7;
end;
end;
definition
let C69 , C70 being set;
let C71 being (ManySortedSet of C69 , C70);
attr C71 is  Category-yielding_on_first
means
:L131: ( C71 `1 ) is  Category-yielding;
attr C71 is  Function-yielding_on_second
means
:L132: ( C71 `2 ) is  Function-yielding;
end;
registration
let C72 , C73 being set;
cluster  Category-yielding_on_first  Function-yielding_on_second for (ManySortedSet of C72 , C73);
existence
proof
set D16 = the (ManySortedFunction of C73);
set D17 = the (ManySortedCategory of C72);
reconsider D18 = [ D17 , D16 ] as (ManySortedSet of C72 , C73);
take D18;
thus L134: (( D18 `1 ) is  Category-yielding & ( D18 `2 ) is  Function-yielding) by MCART_1:7;
end;
end;
registration
let C74 , C75 being set;
let C76 being  Category-yielding_on_first (ManySortedSet of C74 , C75);
cluster ( C76 `1 ) ->  Category-yielding;
coherence by L131;
end;
registration
let C77 , C78 being set;
let C79 being  Function-yielding_on_second (ManySortedSet of C77 , C78);
cluster ( C79 `2 ) ->  Function-yielding;
coherence by L132;
end;
registration
let C80 being  Function-yielding Function;
cluster ( rng C80 ) ->  functional;
coherence
proof
let C81 being set;
assume L138: C81 in ( rng C80 );
L139: (ex B43 being set st (B43 in ( dom C80 ) & C81 = ( C80 . B43 ))) by L138 , FUNCT_1:def 3;
thus L140: thesis by L139;
end;
end;
definition
let C82 , C83 being set;
let C84 being (ManySortedCategory of C82);
let C85 being (ManySortedFunction of C83);
redefine func [C84 , C85 ] ->  Category-yielding_on_first  Function-yielding_on_second (ManySortedSet of C82 , C83);

coherence
proof
L142: (( [ C84 , C85 ] `1 ) = C84 & ( [ C84 , C85 ] `2 ) = C85);
thus L143: thesis by L142 , L131 , L132;
end;
end;
definition
let C86 being non  empty set;
let C87 , C88 being (ManySortedCategory of C86);
mode ManySortedFunctor of C87 , C88
 -> (ManySortedFunction of C86)
means :L145: (for B44 being (Element of C86) holds ( it . B44 ) is (Functor of ( C87 . B44 ) , ( C88 . B44 )));
existence
proof
defpred S3[ set , set ] means (ex B45 being (Element of C86) st (ex B46 being (Functor of ( C87 . B45 ) , ( C88 . B45 )) st ($1 = B45 & $2 = B46)));
L146:
now
let C89 being set;
assume L147: C89 in C86;
reconsider D19 = C89 as (Element of C86) by L147;
set D20 = the (Functor of ( C87 . D19 ) , ( C88 . D19 ));
reconsider D21 = D20 as set;
take D22 = D21;
thus L148: S3[ C89 , D22 ];
end;
consider C90 being Function such that L149: (( dom C90 ) = C86 & (for B47 being set holds (B47 in C86 implies S3[ B47 , ( C90 . B47 ) ]))) from CLASSES1:sch 1(L146);
L150: C90 is  Function-yielding
proof
let C91 being set;
assume L151: C91 in ( dom C90 );
L152: (ex B48 being (Element of C86) st (ex B49 being (Functor of ( C87 . B48 ) , ( C88 . B48 )) st (C91 = B48 & ( C90 . C91 ) = B49))) by L151 , L149;
thus L153: thesis by L152;
end;
reconsider D23 = C90 as (ManySortedFunction of C86) by L150 , L149 , PARTFUN1:def 2 , RELAT_1:def 18;
take D23;
let C92 being (Element of C86);
L154: (ex B50 being (Element of C86) st (ex B51 being (Functor of ( C87 . B50 ) , ( C88 . B50 )) st (C92 = B50 & ( D23 . C92 ) = B51))) by L149;
thus L155: thesis by L154;
end;
end;
scheme LambdaMSFr { F1() -> non  empty set , F2 , F3() -> (ManySortedCategory of F1()) , F4(set) -> set } : (ex B52 being (ManySortedFunctor of F2() , F3()) st (for B53 being (Element of F1()) holds ( B52 . B53 ) = F4(B53)))
provided
L157: (for B54 being (Element of F1()) holds F4(B54) is (Functor of ( F2() . B54 ) , ( F3() . B54 )))
proof
consider C93 being (ManySortedSet of F1()) such that L158: (for B55 being set holds (B55 in F1() implies ( C93 . B55 ) = F4(B55))) from PBOOLE:sch 4;
L159: C93 is  Function-yielding
proof
let C94 being set;
assume L160: C94 in ( dom C93 );
reconsider D24 = C94 as (Element of F1()) by L160 , PARTFUN1:def 2;
L161: ( C93 . D24 ) = F4(D24) by L158;
thus L162: thesis by L161 , L157;
end;
reconsider D25 = C93 as (ManySortedFunction of F1()) by L159;
L163: D25 is (ManySortedFunctor of F2() , F3())
proof
let C95 being (Element of F1());
L164: ( D25 . C95 ) = F4(C95) by L158;
thus L165: thesis by L164 , L157;
end;
reconsider D26 = D25 as (ManySortedFunctor of F2() , F3()) by L163;
take D26;
thus L166: thesis by L158;
end;
definition
let C96 being non  empty set;
let C97 , C98 being (ManySortedCategory of C96);
let C99 being (ManySortedFunctor of C97 , C98);
let C100 being (Element of C96);
redefine func C99 . C100 -> (Functor of ( C97 . C100 ) , ( C98 . C100 ));

coherence by L145;
end;
begin
definition
let C101 , C102 being non  empty set;
let C103 , C104 being (Function of C102 , C101);
mode Indexing of C103 , C104
 ->  Category-yielding_on_first (ManySortedSet of C101 , C102)
means :L168: ( it `2 ) is (ManySortedFunctor of ( ( it `1 ) * C103 ) , ( ( it `1 ) * C104 ));
existence
proof
set D27 = the (ManySortedCategory of C101);
set D28 = the (ManySortedFunctor of ( D27 * C103 ) , ( D27 * C104 ));
take D29 = [ D27 , D28 ];
L169: ( D29 `1 ) = D27 by MCART_1:7;
thus L170: thesis by L169 , MCART_1:7;
end;
end;
theorem
L172: (for B56 , B57 being non  empty set holds (for B58 , B59 being (Function of B57 , B56) holds (for B60 being (Indexing of B58 , B59) holds (for B61 being (Element of B57) holds ( ( B60 `2 ) . B61 ) is (Functor of ( ( B60 `1 ) . ( B58 . B61 ) ) , ( ( B60 `1 ) . ( B59 . B61 ) ))))))
proof
let C105 , C106 being non  empty set;
let C107 , C108 being (Function of C106 , C105);
let C109 being (Indexing of C107 , C108);
reconsider D30 = ( C109 `2 ) as (ManySortedFunctor of ( ( C109 `1 ) * C107 ) , ( ( C109 `1 ) * C108 )) by L168;
let C110 being (Element of C106);
L173: ( dom ( ( C109 `1 ) * C107 ) ) = C106 by PARTFUN1:def 2;
L174: ( ( ( C109 `1 ) * C107 ) . C110 ) = ( ( C109 `1 ) . ( C107 . C110 ) ) by L173 , FUNCT_1:12;
L175: (( D30 . C110 ) is (Functor of ( ( ( C109 `1 ) * C107 ) . C110 ) , ( ( ( C109 `1 ) * C108 ) . C110 )) & ( dom ( ( C109 `1 ) * C108 ) ) = C106) by PARTFUN1:def 2;
thus L176: thesis by L175 , L174 , FUNCT_1:12;
end;
theorem
L177: (for B62 being Category holds (for B63 being (Indexing of (the Source of B62) , (the Target of B62)) holds (for B64 being (Morphism of B62) holds ( ( B63 `2 ) . B64 ) is (Functor of ( ( B63 `1 ) . ( dom B64 ) ) , ( ( B63 `1 ) . ( cod B64 ) ))))) by L172;
definition
let C111 , C112 being non  empty set;
let C113 , C114 being (Function of C112 , C111);
let C115 being (Indexing of C113 , C114);
redefine func C115 `2 -> (ManySortedFunctor of ( ( C115 `1 ) * C113 ) , ( ( C115 `1 ) * C114 ));

coherence by L168;
end;
L179:
now
let C116 , C117 being non  empty set;
let C118 , C119 being (Function of C117 , C116);
let C120 being (Indexing of C118 , C119);
consider C121 being  full  strict  Categorial Category such that L180: (the carrier of C121) = ( rng ( C120 `1 ) ) by CAT_5:20;
take D31 = C121;
L181: ( dom ( C120 `1 ) ) = C116 by PARTFUN1:def 2;
thus L182: (for B65 being (Element of C116) holds ( ( C120 `1 ) . B65 ) is (Object of D31)) by L181 , L180 , FUNCT_1:def 3;
let C122 being (Element of C117);
L183: ( ( C120 `2 ) . C122 ) is (Functor of ( ( C120 `1 ) . ( C118 . C122 ) ) , ( ( C120 `1 ) . ( C119 . C122 ) )) by L172;
L184: (( ( C120 `1 ) . ( C118 . C122 ) ) is (Object of D31) & ( ( C120 `1 ) . ( C119 . C122 ) ) is (Object of D31)) by L181 , L180 , FUNCT_1:def 3;
thus L185: [ [ ( ( C120 `1 ) . ( C118 . C122 ) ) , ( ( C120 `1 ) . ( C119 . C122 ) ) ] , ( ( C120 `2 ) . C122 ) ] is (Morphism of D31) by L184 , L183 , CAT_5:def 8;
end;
definition
let C123 , C124 being non  empty set;
let C125 , C126 being (Function of C124 , C123);
let C127 being (Indexing of C125 , C126);
mode TargetCat of C127
 ->  Categorial Category
means :L186: ((for B66 being (Element of C123) holds ( ( C127 `1 ) . B66 ) is (Object of it)) & (for B67 being (Element of C124) holds [ [ ( ( C127 `1 ) . ( C125 . B67 ) ) , ( ( C127 `1 ) . ( C126 . B67 ) ) ] , ( ( C127 `2 ) . B67 ) ] is (Morphism of it)));
existence
proof
L187: (ex B68 being  full  strict  Categorial Category st ((for B69 being (Element of C123) holds ( ( C127 `1 ) . B69 ) is (Object of B68)) & (for B70 being (Element of C124) holds [ [ ( ( C127 `1 ) . ( C125 . B70 ) ) , ( ( C127 `1 ) . ( C126 . B70 ) ) ] , ( ( C127 `2 ) . B70 ) ] is (Morphism of B68)))) by L179;
thus L188: thesis by L187;
end;
end;
registration
let C128 , C129 being non  empty set;
let C130 , C131 being (Function of C129 , C128);
let C132 being (Indexing of C130 , C131);
cluster  full  strict for (TargetCat of C132);
existence
proof
consider C133 being  full  strict  Categorial Category such that L190: ((for B71 being (Element of C128) holds ( ( C132 `1 ) . B71 ) is (Object of C133)) & (for B72 being (Element of C129) holds [ [ ( ( C132 `1 ) . ( C130 . B72 ) ) , ( ( C132 `1 ) . ( C131 . B72 ) ) ] , ( ( C132 `2 ) . B72 ) ] is (Morphism of C133))) by L179;
L191: C133 is (TargetCat of C132) by L190 , L186;
thus L192: thesis by L191;
end;
end;
definition
let C134 , C135 being non  empty set;
let C136 , C137 being (Function of C135 , C134);
let C138 being (PartFunc of [: C135 , C135 :] , C135);
let C139 being (Function of C134 , C135);
given C140 being Category such that
L194: C140 = CatStr (# C134 , C135 , C136 , C137 , C138 #);

mode Indexing of C136 , C137 , C138 , C139
 -> (Indexing of C136 , C137)
means :L195: ((for B73 being (Element of C134) holds ( ( it `2 ) . ( C139 . B73 ) ) = ( id ( ( it `1 ) . B73 ) )) & (for B74 , B75 being (Element of C135) holds (( C136 . B75 ) = ( C137 . B74 ) implies ( ( it `2 ) . ( C138 . [ B75 , B74 ] ) ) = ( ( ( it `2 ) . B75 ) * ( ( it `2 ) . B74 ) ))));
existence
proof
set D32 = ( C135 --> ( id C140 ) );
set D33 = ( C134 --> C140 );
L196: ( [ D33 , D32 ] `1 ) = D33;
L197: ( [ D33 , D32 ] `2 ) = D32;
L198: D32 is (ManySortedFunctor of ( D33 * C136 ) , ( D33 * C137 ))
proof
let C141 being (Element of C135);
L199: (( D33 . ( C136 . C141 ) ) = C140 & ( dom ( D33 * C136 ) ) = C135) by FUNCOP_1:7 , PARTFUN1:def 2;
L200: (( D32 . C141 ) = ( id C140 ) & ( ( D33 * C136 ) . C141 ) = C140) by L199 , FUNCOP_1:7 , FUNCT_1:12;
L201: (( D33 . ( C137 . C141 ) ) = C140 & ( dom ( D33 * C137 ) ) = C135) by FUNCOP_1:7 , PARTFUN1:def 2;
thus L202: thesis by L201 , L200 , FUNCT_1:12;
end;
reconsider D34 = [ D33 , D32 ] as (Indexing of C136 , C137) by L198 , L196 , L197 , L168;
take D34;
thus L203:now
let C142 being (Element of C134);
thus L204: ( ( D34 `2 ) . ( C139 . C142 ) ) = ( id C140 ) by L197 , FUNCOP_1:7
.= ( id ( ( D34 `1 ) . C142 ) ) by L196 , FUNCOP_1:7;
end;
let C143 , C144 being (Element of C135);
reconsider D35 = C143 , D36 = C144 as (Morphism of C140) by L194;
assume L205: ( C136 . C144 ) = ( C137 . C143 );
L206: ( cod D35 ) = ( dom D36 ) by L205 , L194;
L207: [ C144 , C143 ] in ( dom C138 ) by L206 , L194 , CAT_1:def 6;
L208: ( ( D34 `2 ) . ( C138 . [ C144 , C143 ] ) ) = ( id C140 ) by L207 , L197 , FUNCOP_1:7 , PARTFUN1:4;
L209: (( ( D34 `2 ) . C143 ) = ( id C140 ) & ( ( D34 `2 ) . C144 ) = ( id C140 )) by L197 , FUNCOP_1:7;
thus L210: thesis by L209 , L208 , FUNCT_2:17;
end;
end;
definition
let C145 being Category;
mode Indexing of C145
 is (Indexing of (the Source of C145) , (the Target of C145) , (the Comp of C145) , ( IdMap C145 ));
mode coIndexing of C145
 is (Indexing of (the Target of C145) , (the Source of C145) , ( ~ (the Comp of C145) ) , ( IdMap C145 ));
end;
theorem
L213: (for B76 being Category holds (for B77 being (Indexing of (the Source of B76) , (the Target of B76)) holds (B77 is (Indexing of B76) iff ((for B78 being (Object of B76) holds ( ( B77 `2 ) . ( id B78 ) ) = ( id ( ( B77 `1 ) . B78 ) )) & (for B79 , B80 being (Morphism of B76) holds (( dom B80 ) = ( cod B79 ) implies ( ( B77 `2 ) . ( B80 (*) B79 ) ) = ( ( ( B77 `2 ) . B80 ) * ( ( B77 `2 ) . B79 ) )))))))
proof
let C146 being Category;
reconsider D37 = ( the CatStr of C146 ) as Category by CAT_5:1;
let C147 being (Indexing of (the Source of C146) , (the Target of C146));
L214: D37 = CatStr (# (the carrier of C146) , (the carrier' of C146) , (the Source of C146) , (the Target of C146) , (the Comp of C146) #);
thus L215:now
assume L216: C147 is (Indexing of C146);
thus L217: (for B81 being (Object of C146) holds ( ( C147 `2 ) . ( id B81 ) ) = ( id ( ( C147 `1 ) . B81 ) ))
proof
let C148 being (Object of C146);
L218: ( id C148 ) = ( ( IdMap C146 ) . C148 ) by ISOCAT_1:def 12;
thus L219: thesis by L218 , L214 , L195 , L216;
end;

let C149 , C150 being (Morphism of C146);
assume L220: ( dom C150 ) = ( cod C149 );
L221: ( ( C147 `2 ) . ( (the Comp of C146) . (C150 , C149) ) ) = ( ( ( C147 `2 ) . C150 ) * ( ( C147 `2 ) . C149 ) ) by L220 , L214 , L216 , L195;
thus L222: ( ( C147 `2 ) . ( C150 (*) C149 ) ) = ( ( ( C147 `2 ) . C150 ) * ( ( C147 `2 ) . C149 ) ) by L221 , L220 , CAT_1:16;
end;
assume that
L223: (for B82 being (Object of C146) holds ( ( C147 `2 ) . ( id B82 ) ) = ( id ( ( C147 `1 ) . B82 ) ))
and
L224: (for B83 , B84 being (Morphism of C146) holds (( dom B84 ) = ( cod B83 ) implies ( ( C147 `2 ) . ( B84 (*) B83 ) ) = ( ( ( C147 `2 ) . B84 ) * ( ( C147 `2 ) . B83 ) )));
thus L225: (ex B85 being Category st B85 = CatStr (# (the carrier of C146) , (the carrier' of C146) , (the Source of C146) , (the Target of C146) , (the Comp of C146) #)) by L214;
thus L226:now
let C151 being (Object of C146);
L227: ( id C151 ) = ( ( IdMap C146 ) . C151 ) by ISOCAT_1:def 12;
thus L228: ( ( C147 `2 ) . ( ( IdMap C146 ) . C151 ) ) = ( ( C147 `2 ) . ( id C151 ) ) by L227
.= ( id ( ( C147 `1 ) . C151 ) ) by L223;
end;
let C152 , C153 being (Morphism of C146);
assume L229: ( (the Source of C146) . C153 ) = ( (the Target of C146) . C152 );
L230: ( dom C153 ) = ( cod C152 ) by L229;
L231: ( ( C147 `2 ) . ( C153 (*) C152 ) ) = ( ( ( C147 `2 ) . C153 ) * ( ( C147 `2 ) . C152 ) ) by L230 , L224;
thus L232: ( ( C147 `2 ) . ( (the Comp of C146) . [ C153 , C152 ] ) ) = ( ( C147 `2 ) . ( (the Comp of C146) . (C153 , C152) ) )
.= ( ( ( C147 `2 ) . C153 ) * ( ( C147 `2 ) . C152 ) ) by L230 , L231 , CAT_1:16;
end;
theorem
L233: (for B86 being Category holds (for B87 being (Indexing of (the Target of B86) , (the Source of B86)) holds (B87 is (coIndexing of B86) iff ((for B88 being (Object of B86) holds ( ( B87 `2 ) . ( id B88 ) ) = ( id ( ( B87 `1 ) . B88 ) )) & (for B89 , B90 being (Morphism of B86) holds (( dom B90 ) = ( cod B89 ) implies ( ( B87 `2 ) . ( B90 (*) B89 ) ) = ( ( ( B87 `2 ) . B89 ) * ( ( B87 `2 ) . B90 ) )))))))
proof
let C154 being Category;
let C155 being (Indexing of (the Target of C154) , (the Source of C154));
L234: ( C154 opp ) = CatStr (# (the carrier of C154) , (the carrier' of C154) , (the Target of C154) , (the Source of C154) , ( ~ (the Comp of C154) ) #);
thus L235:now
assume L236: C155 is (coIndexing of C154);
thus L237: (for B91 being (Object of C154) holds ( ( C155 `2 ) . ( id B91 ) ) = ( id ( ( C155 `1 ) . B91 ) ))
proof
let C156 being (Object of C154);
L238: ( id C156 ) = ( ( IdMap C154 ) . C156 ) by ISOCAT_1:def 12;
thus L239: thesis by L238 , L234 , L195 , L236;
end;

let C157 , C158 being (Morphism of C154);
assume L240: ( dom C158 ) = ( cod C157 );
L241: [ C158 , C157 ] in ( dom (the Comp of C154) ) by L240 , CAT_1:15;
L242: ( ( C155 `2 ) . ( ( ~ (the Comp of C154) ) . (C157 , C158) ) ) = ( ( ( C155 `2 ) . C157 ) * ( ( C155 `2 ) . C158 ) ) by L234 , L236 , L240 , L195;
L243: ( ( C155 `2 ) . ( (the Comp of C154) . (C158 , C157) ) ) = ( ( ( C155 `2 ) . C157 ) * ( ( C155 `2 ) . C158 ) ) by L242 , L241 , FUNCT_4:def 2;
thus L244: ( ( C155 `2 ) . ( C158 (*) C157 ) ) = ( ( ( C155 `2 ) . C157 ) * ( ( C155 `2 ) . C158 ) ) by L243 , L240 , CAT_1:16;
end;
assume that
L245: (for B92 being (Object of C154) holds ( ( C155 `2 ) . ( id B92 ) ) = ( id ( ( C155 `1 ) . B92 ) ))
and
L246: (for B93 , B94 being (Morphism of C154) holds (( dom B94 ) = ( cod B93 ) implies ( ( C155 `2 ) . ( B94 (*) B93 ) ) = ( ( ( C155 `2 ) . B93 ) * ( ( C155 `2 ) . B94 ) )));
thus L247: (ex B95 being Category st B95 = CatStr (# (the carrier of C154) , (the carrier' of C154) , (the Target of C154) , (the Source of C154) , ( ~ (the Comp of C154) ) #)) by L234;
thus L248:now
let C159 being (Object of C154);
L249: ( id C159 ) = ( ( IdMap C154 ) . C159 ) by ISOCAT_1:def 12;
thus L250: ( ( C155 `2 ) . ( ( IdMap C154 ) . C159 ) ) = ( ( C155 `2 ) . ( id C159 ) ) by L249
.= ( id ( ( C155 `1 ) . C159 ) ) by L245;
end;
let C160 , C161 being (Morphism of C154);
assume L251: ( (the Target of C154) . C161 ) = ( (the Source of C154) . C160 );
L252: ( dom C160 ) = ( cod C161 ) by L251;
L253: ( ( C155 `2 ) . ( C160 (*) C161 ) ) = ( ( ( C155 `2 ) . C161 ) * ( ( C155 `2 ) . C160 ) ) by L252 , L246;
L254: ( ( C155 `2 ) . ( (the Comp of C154) . (C160 , C161) ) ) = ( ( ( C155 `2 ) . C161 ) * ( ( C155 `2 ) . C160 ) ) by L253 , L252 , CAT_1:16;
L255: [ C160 , C161 ] in ( dom (the Comp of C154) ) by L252 , CAT_1:15;
thus L256: ( ( C155 `2 ) . ( ( ~ (the Comp of C154) ) . [ C161 , C160 ] ) ) = ( ( C155 `2 ) . ( ( ~ (the Comp of C154) ) . (C161 , C160) ) )
.= ( ( ( C155 `2 ) . C161 ) * ( ( C155 `2 ) . C160 ) ) by L254 , L255 , FUNCT_4:def 2;
end;
L257: (for B96 being Category holds ( IdMap B96 ) = ( IdMap ( B96 opp ) ))
proof
let C162 being Category;
thus L258: (the carrier of C162) = (the carrier of ( C162 opp ));
let C163 being (Element of (the carrier of C162));
thus L259: ( ( IdMap C162 ) . C163 ) = ( id C163 ) by ISOCAT_1:def 12
.= ( id ( C163 opp ) ) by OPPCAT_1:71
.= ( ( IdMap ( C162 opp ) ) . ( C163 opp ) ) by ISOCAT_1:def 12
.= ( ( IdMap ( C162 opp ) ) . C163 );
end;
theorem
L260: (for B97 being Category holds (for B98 being set holds (B98 is (coIndexing of B97) iff B98 is (Indexing of ( B97 opp )))))
proof
let C164 being Category;
let C165 being set;
L261: ( IdMap C164 ) = ( IdMap ( C164 opp ) ) by L257;
thus L262: thesis by L261;
end;
theorem
L263: (for B99 being Category holds (for B100 being (Indexing of B99) holds (for B101 , B102 being (Object of B99) holds (( Hom (B101 , B102) ) is non  empty implies (for B103 being (Morphism of B101 , B102) holds ( ( B100 `2 ) . B103 ) is (Functor of ( ( B100 `1 ) . B101 ) , ( ( B100 `1 ) . B102 )))))))
proof
let C166 being Category;
let C167 being (Indexing of C166);
let C168 , C169 being (Object of C166);
assume that
L264: ( Hom (C168 , C169) ) is non  empty;
let C170 being (Morphism of C168 , C169);
L265: ( dom ( ( C167 `1 ) * (the Source of C166) ) ) = (the carrier' of C166) by PARTFUN1:def 2;
L266: (( dom ( ( C167 `1 ) * (the Target of C166) ) ) = (the carrier' of C166) & ( ( ( C167 `1 ) * (the Source of C166) ) . C170 ) = ( ( C167 `1 ) . ( (the Source of C166) . C170 ) )) by L265 , FUNCT_1:12 , PARTFUN1:def 2;
L267: (( dom C170 ) = C168 & ( cod C170 ) = C169) by L264 , CAT_1:5;
thus L268: thesis by L267 , L266 , FUNCT_1:12;
end;
theorem
L269: (for B104 being Category holds (for B105 being (coIndexing of B104) holds (for B106 , B107 being (Object of B104) holds (( Hom (B106 , B107) ) is non  empty implies (for B108 being (Morphism of B106 , B107) holds ( ( B105 `2 ) . B108 ) is (Functor of ( ( B105 `1 ) . B107 ) , ( ( B105 `1 ) . B106 )))))))
proof
let C171 being Category;
let C172 being (coIndexing of C171);
let C173 , C174 being (Object of C171);
assume that
L270: ( Hom (C173 , C174) ) is non  empty;
let C175 being (Morphism of C173 , C174);
L271: ( dom ( ( C172 `1 ) * (the Source of C171) ) ) = (the carrier' of C171) by PARTFUN1:def 2;
L272: (( dom ( ( C172 `1 ) * (the Target of C171) ) ) = (the carrier' of C171) & ( ( ( C172 `1 ) * (the Source of C171) ) . C175 ) = ( ( C172 `1 ) . ( (the Source of C171) . C175 ) )) by L271 , FUNCT_1:12 , PARTFUN1:def 2;
L273: (( dom C175 ) = C173 & ( cod C175 ) = C174) by L270 , CAT_1:5;
thus L274: thesis by L273 , L272 , FUNCT_1:12;
end;
definition
let C176 being Category;
let C177 being (Indexing of C176);
let C178 being (TargetCat of C177);
func C177 -functor (C176 , C178) -> (Functor of C176 , C178) means 
:L275: (for B109 being (Morphism of C176) holds ( it . B109 ) = [ [ ( ( C177 `1 ) . ( dom B109 ) ) , ( ( C177 `1 ) . ( cod B109 ) ) ] , ( ( C177 `2 ) . B109 ) ]);
existence
proof
L276: ( rng ( C177 `1 ) ) c= (the carrier of C178)
proof
let C179 being set;
assume L277: C179 in ( rng ( C177 `1 ) );
consider C180 being set such that L278: C180 in ( dom ( C177 `1 ) ) and L279: C179 = ( ( C177 `1 ) . C180 ) by L277 , FUNCT_1:def 3;
reconsider D38 = C180 as (Object of C176) by L278 , PARTFUN1:def 2;
L280: ( ( C177 `1 ) . D38 ) is (Object of C178) by L186;
thus L281: thesis by L280 , L279;
end;
L282: ( dom ( C177 `1 ) ) = (the carrier of C176) by PARTFUN1:def 2;
reconsider D39 = ( C177 `1 ) as (Function of (the carrier of C176) , (the carrier of C178)) by L282 , L276 , FUNCT_2:def 1 , RELSET_1:4;
deffunc H1((Object of C176)) = ( D39 . $1 );
deffunc H2((Morphism of C176)) = [ [ ( ( C177 `1 ) . ( dom $1 ) ) , ( ( C177 `1 ) . ( cod $1 ) ) ] , ( ( C177 `2 ) . $1 ) ];
L283:
now
let C181 being (Morphism of C176);
thus L284: H2(C181) is (Morphism of C178) by L186;
let C182 being (Morphism of C178);
assume L285: C182 = H2(C181);
thus L286: ( dom C182 ) = ( H2(C181) `11 ) by L285 , CAT_5:13
.= H1(( dom C181 )) by MCART_1:85;
thus L287: ( cod C182 ) = ( H2(C181) `12 ) by L285 , CAT_5:13
.= H1(( cod C181 )) by MCART_1:85;
end;
L288:
now
let C183 , C184 being (Morphism of C176);
let C185 , C186 being (Morphism of C178);
assume that
L289: (C185 = H2(C183) & C186 = H2(C184))
and
L290: ( dom C184 ) = ( cod C183 );
L291: (( dom ( C184 (*) C183 ) ) = ( dom C183 ) & ( cod ( C184 (*) C183 ) ) = ( cod C184 )) by L290 , CAT_1:17;
L292: (( ( C177 `2 ) . C183 ) is (Functor of ( ( C177 `1 ) . ( dom C183 ) ) , ( ( C177 `1 ) . ( cod C183 ) )) & ( ( C177 `2 ) . C184 ) is (Functor of ( ( C177 `1 ) . ( dom C184 ) ) , ( ( C177 `1 ) . ( cod C184 ) ))) by L172;
L293: ( ( C177 `2 ) . ( C184 (*) C183 ) ) = ( ( ( C177 `2 ) . C184 ) * ( ( C177 `2 ) . C183 ) ) by L290 , L213;
thus L294: H2(( C184 (*) C183 )) = ( C186 (*) C185 ) by L293 , L289 , L290 , L292 , L291 , CAT_5:def 6;
end;
L295:
now
let C187 being (Object of C176);
thus L296: H2(( id C187 )) = [ [ ( D39 . C187 ) , ( D39 . C187 ) ] , ( id ( ( C177 `1 ) . C187 ) ) ] by L213
.= ( id H1(C187) ) by CAT_5:def 6;
end;
thus L297: (ex B110 being (Functor of C176 , C178) st (for B111 being (Morphism of C176) holds ( B110 . B111 ) = H2(B111))) from CAT_5:sch 3(L283 , L295 , L288);
end;
uniqueness
proof
let C188 , C189 being (Functor of C176 , C178);
assume that
L298: (for B112 being (Morphism of C176) holds ( C188 . B112 ) = [ [ ( ( C177 `1 ) . ( dom B112 ) ) , ( ( C177 `1 ) . ( cod B112 ) ) ] , ( ( C177 `2 ) . B112 ) ])
and
L299: (for B113 being (Morphism of C176) holds ( C189 . B113 ) = [ [ ( ( C177 `1 ) . ( dom B113 ) ) , ( ( C177 `1 ) . ( cod B113 ) ) ] , ( ( C177 `2 ) . B113 ) ]);
L300:
now
let C190 being (Morphism of C176);
thus L301: ( C188 . C190 ) = [ [ ( ( C177 `1 ) . ( dom C190 ) ) , ( ( C177 `1 ) . ( cod C190 ) ) ] , ( ( C177 `2 ) . C190 ) ] by L298
.= ( C189 . C190 ) by L299;
end;
thus L302: thesis by L300 , FUNCT_2:63;
end;
end;
L304: (for B114 being Category holds (for B115 being (Indexing of B114) holds (for B116 being (TargetCat of B115) holds ( Obj ( B115 -functor (B114 , B116) ) ) = ( B115 `1 ))))
proof
let C191 being Category;
let C192 being (Indexing of C191);
let C193 being (TargetCat of C192);
L305:
now
let C194 being set;
assume L306: C194 in (the carrier of C191);
reconsider D40 = C194 as (Object of C191) by L306;
L307: (( dom ( id D40 ) ) = D40 & ( cod ( id D40 ) ) = D40);
L308: ( ( Obj ( C192 -functor (C191 , C193) ) ) . D40 ) = ( dom ( id ( ( Obj ( C192 -functor (C191 , C193) ) ) . D40 ) ) )
.= ( dom ( ( C192 -functor (C191 , C193) ) . (( id D40 ) qua (Morphism of C191)) ) ) by CAT_1:68
.= ( ( (( C192 -functor (C191 , C193) ) qua Function) . ( id D40 ) ) `11 ) by CAT_5:2
.= ( [ [ ( ( C192 `1 ) . D40 ) , ( ( C192 `1 ) . D40 ) ] , ( ( C192 `2 ) . ( id D40 ) ) ] `11 ) by L307 , L275;
thus L309: ( ( Obj ( C192 -functor (C191 , C193) ) ) . C194 ) = ( ( C192 `1 ) . C194 ) by L308 , MCART_1:85;
end;
L310: (( dom ( Obj ( C192 -functor (C191 , C193) ) ) ) = (the carrier of C191) & ( dom ( C192 `1 ) ) = (the carrier of C191)) by FUNCT_2:def 1 , PARTFUN1:def 2;
thus L311: thesis by L310 , L305 , FUNCT_1:2;
end;
theorem
L312: (for B117 being Category holds (for B118 being (Indexing of B117) holds (for B119 , B120 being (TargetCat of B118) holds (( B118 -functor (B117 , B119) ) = ( B118 -functor (B117 , B120) ) & ( Obj ( B118 -functor (B117 , B119) ) ) = ( Obj ( B118 -functor (B117 , B120) ) )))))
proof
let C195 being Category;
let C196 being (Indexing of C195);
let C197 , C198 being (TargetCat of C196);
L313:
now
let C199 being set;
assume L314: C199 in (the carrier' of C195);
reconsider D41 = C199 as (Morphism of C195) by L314;
thus L315: ( ( C196 -functor (C195 , C197) ) . C199 ) = [ [ ( ( C196 `1 ) . ( dom D41 ) ) , ( ( C196 `1 ) . ( cod D41 ) ) ] , ( ( C196 `2 ) . D41 ) ] by L275
.= ( ( C196 -functor (C195 , C198) ) . C199 ) by L275;
end;
L316: (( dom ( C196 -functor (C195 , C197) ) ) = (the carrier' of C195) & ( dom ( C196 -functor (C195 , C198) ) ) = (the carrier' of C195)) by FUNCT_2:def 1;
thus L317: ( C196 -functor (C195 , C197) ) = ( C196 -functor (C195 , C198) ) by L316 , L313 , FUNCT_1:2;
L318:
now
let C200 being set;
assume L319: C200 in (the carrier of C195);
reconsider D42 = C200 as (Object of C195) by L319;
thus L320: ( ( Obj ( C196 -functor (C195 , C197) ) ) . C200 ) = ( ( C196 `1 ) . D42 ) by L304
.= ( ( Obj ( C196 -functor (C195 , C198) ) ) . C200 ) by L304;
end;
L321: (( dom ( Obj ( C196 -functor (C195 , C197) ) ) ) = (the carrier of C195) & ( dom ( Obj ( C196 -functor (C195 , C198) ) ) ) = (the carrier of C195)) by FUNCT_2:def 1;
thus L322: thesis by L321 , L318 , FUNCT_1:2;
end;
theorem
L323: (for B121 being Category holds (for B122 being (Indexing of B121) holds (for B123 being (TargetCat of B122) holds ( Obj ( B122 -functor (B121 , B123) ) ) = ( B122 `1 )))) by L304;
theorem
L324: (for B124 being Category holds (for B125 being (Indexing of B124) holds (for B126 being (TargetCat of B125) holds (for B127 being (Object of B124) holds ( ( B125 -functor (B124 , B126) ) . B127 ) = ( ( B125 `1 ) . B127 ))))) by L304;
definition
let C201 being Category;
let C202 being (Indexing of C201);
func rng C202 ->  strict (TargetCat of C202) means 
:L325: (for B128 being (TargetCat of C202) holds it = ( Image ( C202 -functor (C201 , B128) ) ));
uniqueness
proof
set D43 = the (TargetCat of C202);
let C203 , C204 being  strict (TargetCat of C202);
assume that
L326: (for B129 being (TargetCat of C202) holds C203 = ( Image ( C202 -functor (C201 , B129) ) ))
and
L327: (for B130 being (TargetCat of C202) holds C204 = ( Image ( C202 -functor (C201 , B130) ) ));
thus L328: C203 = ( Image ( C202 -functor (C201 , D43) ) ) by L326
.= C204 by L327;
end;
existence
proof
set D44 = the (TargetCat of C202);
reconsider D45 = ( Image ( C202 -functor (C201 , D44) ) ) as  strict (Subcategory of D44);
reconsider D46 = ( C202 -functor (C201 , D44) ) as (Functor of C201 , D45) by CAT_5:8;
L329: D45 is (TargetCat of C202)
proof
L330: (the carrier of D45) = ( rng ( Obj ( C202 -functor (C201 , D44) ) ) ) by CAT_5:def 3;
L331: (the carrier of D45) = ( rng ( C202 `1 ) ) by L330 , L304;
L332: ( dom ( C202 `1 ) ) = (the carrier of C201) by PARTFUN1:def 2;
thus L333: (for B131 being (Object of C201) holds ( ( C202 `1 ) . B131 ) is (Object of D45)) by L332 , L331 , FUNCT_1:def 3;
let C205 being (Morphism of C201);
L334: ( D46 . C205 ) = [ [ ( ( C202 `1 ) . ( dom C205 ) ) , ( ( C202 `1 ) . ( cod C205 ) ) ] , ( ( C202 `2 ) . C205 ) ] by L275;
thus L335: thesis by L334;
end;
reconsider D47 = D45 as  strict (TargetCat of C202) by L329;
take D47;
let C206 being (TargetCat of C202);
thus L336: thesis by L312 , CAT_5:22;
end;
end;
theorem
L338: (for B132 being Category holds (for B133 being (Indexing of B132) holds (for B134 being  Categorial Category holds (( rng B133 ) is (Subcategory of B134) iff B134 is (TargetCat of B133)))))
proof
let C207 being Category;
let C208 being (Indexing of C207);
let C209 being  Categorial Category;
thus L339:now
assume L340: ( rng C208 ) is (Subcategory of C209);
thus L341: C209 is (TargetCat of C208)
proof
thus L342:now
let C210 being (Object of C207);
L343: ( ( C208 `1 ) . C210 ) is (Object of ( rng C208 )) by L186;
thus L344: ( ( C208 `1 ) . C210 ) is (Object of C209) by L343 , L340 , CAT_2:6;
end;
let C211 being (Morphism of C207);
L345: [ [ ( ( C208 `1 ) . ( (the Source of C207) . C211 ) ) , ( ( C208 `1 ) . ( (the Target of C207) . C211 ) ) ] , ( ( C208 `2 ) . C211 ) ] is (Morphism of ( rng C208 )) by L186;
thus L346: thesis by L345 , L340 , CAT_2:8;
end;

end;
assume L342: C209 is (TargetCat of C208);
reconsider D48 = C209 as (TargetCat of C208) by L342;
L343: ( rng C208 ) = ( Image ( C208 -functor (C207 , D48) ) ) by L325;
thus L344: thesis by L343;
end;
definition
let C212 being Category;
let C213 being (Indexing of C212);
let C214 being (Morphism of C212);
func C213 . C214 -> (Functor of ( ( C213 `1 ) . ( dom C214 ) ) , ( ( C213 `1 ) . ( cod C214 ) )) equals 
( ( C213 `2 ) . C214 );
coherence
proof
L345: ( dom ( ( C213 `1 ) * (the Source of C212) ) ) = (the carrier' of C212) by PARTFUN1:def 2;
L346: (( dom ( ( C213 `1 ) * (the Target of C212) ) ) = (the carrier' of C212) & ( ( ( C213 `1 ) * (the Source of C212) ) . C214 ) = ( ( C213 `1 ) . ( (the Source of C212) . C214 ) )) by L345 , FUNCT_1:12 , PARTFUN1:def 2;
thus L347: thesis by L346 , FUNCT_1:12;
end;
end;
definition
let C215 being Category;
let C216 being (coIndexing of C215);
let C217 being (Morphism of C215);
func C216 . C217 -> (Functor of ( ( C216 `1 ) . ( cod C217 ) ) , ( ( C216 `1 ) . ( dom C217 ) )) equals 
( ( C216 `2 ) . C217 );
coherence
proof
L349: ( dom ( ( C216 `1 ) * (the Source of C215) ) ) = (the carrier' of C215) by PARTFUN1:def 2;
L350: (( dom ( ( C216 `1 ) * (the Target of C215) ) ) = (the carrier' of C215) & ( ( ( C216 `1 ) * (the Source of C215) ) . C217 ) = ( ( C216 `1 ) . ( (the Source of C215) . C217 ) )) by L349 , FUNCT_1:12 , PARTFUN1:def 2;
thus L351: thesis by L350 , FUNCT_1:12;
end;
end;
L353:
now
let C218 , C219 being Category;
set D49 = ( (the carrier of C218) --> C219 );
set D50 = ( (the carrier' of C218) --> ( id C219 ) );
set D51 = [ D49 , D50 ];
let C220 being (Morphism of C218);
L354: ( dom ( ( D51 `1 ) * (the Source of C218) ) ) = (the carrier' of C218) by PARTFUN1:def 2;
L355: ( ( ( D51 `1 ) * (the Source of C218) ) . C220 ) = ( ( D51 `1 ) . ( (the Source of C218) . C220 ) ) by L354 , FUNCT_1:12
.= ( D49 . ( (the Source of C218) . C220 ) )
.= C219 by FUNCOP_1:7;
L356: ( dom ( ( D51 `1 ) * (the Target of C218) ) ) = (the carrier' of C218) by PARTFUN1:def 2;
L357: ( ( ( D51 `1 ) * (the Target of C218) ) . C220 ) = ( ( D51 `1 ) . ( (the Target of C218) . C220 ) ) by L356 , FUNCT_1:12
.= ( D49 . ( (the Target of C218) . C220 ) )
.= C219 by FUNCOP_1:7;
L358: ( ( D51 `2 ) . C220 ) = ( D50 . C220 )
.= ( id C219 ) by FUNCOP_1:7;
thus L359: ( ( D51 `2 ) . C220 ) is (Functor of ( ( ( D51 `1 ) * (the Source of C218) ) . C220 ) , ( ( ( D51 `1 ) * (the Target of C218) ) . C220 )) by L358 , L355 , L357;
end;
L360:
now
let C221 , C222 being Category;
set D52 = ( (the carrier of C221) --> C222 );
set D53 = ( (the carrier' of C221) --> ( id C222 ) );
set D54 = [ D52 , D53 ];
let C223 being (Morphism of C221);
L361: ( dom ( ( D54 `1 ) * (the Source of C221) ) ) = (the carrier' of C221) by PARTFUN1:def 2;
L362: ( ( ( D54 `1 ) * (the Source of C221) ) . C223 ) = ( ( D54 `1 ) . ( (the Source of C221) . C223 ) ) by L361 , FUNCT_1:12
.= ( D52 . ( (the Source of C221) . C223 ) )
.= C222 by FUNCOP_1:7;
L363: ( dom ( ( D54 `1 ) * (the Target of C221) ) ) = (the carrier' of C221) by PARTFUN1:def 2;
L364: ( ( ( D54 `1 ) * (the Target of C221) ) . C223 ) = ( ( D54 `1 ) . ( (the Target of C221) . C223 ) ) by L363 , FUNCT_1:12
.= ( D52 . ( (the Target of C221) . C223 ) )
.= C222 by FUNCOP_1:7;
L365: ( ( D54 `2 ) . C223 ) = ( D53 . C223 )
.= ( id C222 ) by FUNCOP_1:7;
thus L366: ( ( D54 `2 ) . C223 ) is (Functor of ( ( ( D54 `1 ) * (the Target of C221) ) . C223 ) , ( ( ( D54 `1 ) * (the Source of C221) ) . C223 )) by L365 , L362 , L364;
end;
theorem
L367: (for B135 , B136 being Category holds ([ ( (the carrier of B135) --> B136 ) , ( (the carrier' of B135) --> ( id B136 ) ) ] is (Indexing of B135) & [ ( (the carrier of B135) --> B136 ) , ( (the carrier' of B135) --> ( id B136 ) ) ] is (coIndexing of B135)))
proof
let C224 , C225 being Category;
set D55 = [ ( (the carrier of C224) --> C225 ) , ( (the carrier' of C224) --> ( id C225 ) ) ];
set D56 = D55;
L368: ( D55 `2 ) = ( (the carrier' of C224) --> ( id C225 ) );
L369:
now
let C226 being (Object of C224);
thus L370: ( ( D55 `2 ) . ( id C226 ) ) = ( id C225 ) by FUNCOP_1:7
.= ( id ( ( D55 `1 ) . C226 ) ) by FUNCOP_1:7;
end;
L371: (for B137 being (Morphism of C224) holds ( ( D55 `2 ) . B137 ) is (Functor of ( ( ( D55 `1 ) * (the Source of C224) ) . B137 ) , ( ( ( D55 `1 ) * (the Target of C224) ) . B137 ))) by L353;
L372: ( D55 `2 ) is (ManySortedFunctor of ( ( D55 `1 ) * (the Source of C224) ) , ( ( D55 `1 ) * (the Target of C224) )) by L371 , L145;
reconsider D57 = D55 as (Indexing of (the Source of C224) , (the Target of C224)) by L372 , L168;
L373:
now
let C227 , C228 being (Morphism of C224);
assume L374: ( dom C228 ) = ( cod C227 );
L375: ( ( D57 `2 ) . C227 ) = ( id C225 ) by L368 , FUNCOP_1:7;
L376: (( ( D57 `2 ) . ( C228 (*) C227 ) ) = ( id C225 ) & ( ( D57 `2 ) . C228 ) = ( id C225 )) by L368 , FUNCOP_1:7;
thus L377: ( ( D57 `2 ) . ( C228 (*) C227 ) ) = ( ( ( D57 `2 ) . C228 ) * ( ( D57 `2 ) . C227 ) ) by L376 , L375 , FUNCT_2:17;
end;
thus L378: D56 is (Indexing of C224) by L373 , L369 , L213;
L379: (for B138 being (Morphism of C224) holds ( ( D57 `2 ) . B138 ) is (Functor of ( ( ( D57 `1 ) * (the Target of C224) ) . B138 ) , ( ( ( D57 `1 ) * (the Source of C224) ) . B138 ))) by L360;
L380: ( D57 `2 ) is (ManySortedFunctor of ( ( D57 `1 ) * (the Target of C224) ) , ( ( D57 `1 ) * (the Source of C224) )) by L379 , L145;
reconsider D58 = D57 as (Indexing of (the Target of C224) , (the Source of C224)) by L380 , L168;
L381:
now
let C229 , C230 being (Morphism of C224);
assume L382: ( dom C230 ) = ( cod C229 );
L383: ( ( D58 `2 ) . C229 ) = ( id C225 ) by L368 , FUNCOP_1:7;
L384: (( ( D58 `2 ) . ( C230 (*) C229 ) ) = ( id C225 ) & ( ( D58 `2 ) . C230 ) = ( id C225 )) by L368 , FUNCOP_1:7;
thus L385: ( ( D58 `2 ) . ( C230 (*) C229 ) ) = ( ( ( D58 `2 ) . C229 ) * ( ( D58 `2 ) . C230 ) ) by L384 , L383 , FUNCT_2:17;
end;
thus L386: thesis by L381 , L369 , L233;
end;
begin
registration
let C231 being Category;
let C232 being  Categorial Category;
let C233 being (Functor of C231 , C232);
cluster ( Obj C233 ) ->  Category-yielding;
coherence
proof
let C234 being set;
assume L387: C234 in ( dom ( Obj C233 ) );
L388: (( rng ( Obj C233 ) ) c= (the carrier of C232) & ( ( Obj C233 ) . C234 ) in ( rng ( Obj C233 ) )) by L387 , FUNCT_1:def 3 , RELAT_1:def 19;
thus L389: thesis by L388 , CAT_5:12;
end;
end;
theorem
L391: (for B139 being Category holds (for B140 being  Categorial Category holds (for B141 being (Functor of B139 , B140) holds [ ( Obj B141 ) , ( pr2 B141 ) ] is (Indexing of B139))))
proof
let C235 being Category;
let C236 being  Categorial Category;
let C237 being (Functor of C235 , C236);
set D59 = [ ( Obj C237 ) , ( pr2 C237 ) ];
L392: ( D59 `1 ) = ( Obj C237 );
L393: ( dom C237 ) = (the carrier' of C235) by FUNCT_2:def 1;
L394: ( dom ( Obj C237 ) ) = (the carrier of C235) by FUNCT_2:def 1;
L395: ( Obj C237 ) is (ManySortedSet of (the carrier of C235)) by L394 , PARTFUN1:def 2;
L396: ( D59 `2 ) = ( pr2 C237 );
L397: ( dom ( pr2 C237 ) ) = ( dom C237 ) by MCART_1:def 13;
L398: ( pr2 C237 ) is (ManySortedSet of (the carrier' of C235)) by L397 , L393 , PARTFUN1:def 2 , RELAT_1:def 18;
reconsider D60 = D59 as (ManySortedSet of (the carrier of C235) , (the carrier' of C235)) by L398 , L395 , L111;
L399: ( pr2 C237 ) is  Function-yielding
proof
let C238 being set;
assume L400: C238 in ( dom ( pr2 C237 ) );
reconsider D61 = C238 as (Morphism of C235) by L400 , L393 , MCART_1:def 13;
reconsider D62 = ( C237 . D61 ) as (Morphism of C236);
L401: ( ( pr2 C237 ) . D61 ) = ( D62 `2 ) by L393 , MCART_1:def 13;
thus L402: thesis by L401;
end;
reconsider D63 = ( pr2 C237 ) as (ManySortedFunction of (the carrier' of C235)) by L399 , L397 , L393 , PARTFUN1:def 2 , RELAT_1:def 18;
L403: ( D60 `1 ) is  Category-yielding by MCART_1:7;
reconsider D64 = D60 as  Category-yielding_on_first (ManySortedSet of (the carrier of C235) , (the carrier' of C235)) by L403 , L131;
L404: D63 is (ManySortedFunctor of ( ( D64 `1 ) * (the Source of C235) ) , ( ( D64 `1 ) * (the Target of C235) ))
proof
let C239 being (Morphism of C235);
reconsider D65 = ( C237 . C239 ) as (Morphism of C236);
L405: ( D65 `11 ) = ( dom ( C237 . C239 ) ) by CAT_5:13;
L406: ( D65 `12 ) = ( cod ( C237 . C239 ) ) by CAT_5:13;
consider C240 being (Functor of ( D65 `11 ) , ( D65 `12 )) such that L407: ( C237 . C239 ) = [ [ ( D65 `11 ) , ( D65 `12 ) ] , C240 ] by L406 , L405 , CAT_5:def 6;
L408: ( ( ( Obj C237 ) * (the Source of C235) ) . C239 ) = ( ( Obj C237 ) . ( dom C239 ) ) by FUNCT_2:15
.= ( dom ( C237 . C239 ) ) by CAT_1:69;
L409: ( ( ( Obj C237 ) * (the Target of C235) ) . C239 ) = ( ( Obj C237 ) . ( cod C239 ) ) by FUNCT_2:15
.= ( cod ( C237 . C239 ) ) by CAT_1:69;
L410: ( D63 . C239 ) = ( D65 `2 ) by L393 , MCART_1:def 13
.= C240 by L407 , MCART_1:7;
thus L411: thesis by L410 , L392 , L405 , L408 , L409 , CAT_5:13;
end;
reconsider D66 = D64 as (Indexing of (the Source of C235) , (the Target of C235)) by L404 , L396 , L168;
L412: ( dom C237 ) = (the carrier' of C235) by FUNCT_2:def 1;
L413:
now
let C241 , C242 being (Morphism of C235);
assume L414: ( dom C242 ) = ( cod C241 );
set D67 = ( C237 . C241 );
set D68 = ( C237 . C242 );
L415: ( dom D68 ) = ( C237 . ( dom C242 ) ) by CAT_1:72
.= ( cod D67 ) by L414 , CAT_1:72;
L416: ( dom D68 ) = ( D68 `11 ) by CAT_5:13;
L417: ( cod D68 ) = ( D68 `12 ) by CAT_5:13;
consider C243 being (Functor of ( D68 `11 ) , ( D68 `12 )) such that L418: D68 = [ [ ( D68 `11 ) , ( D68 `12 ) ] , C243 ] by L417 , L416 , CAT_5:def 6;
L419: ( cod D67 ) = ( D67 `12 ) by CAT_5:13;
L420: ( dom D67 ) = ( D67 `11 ) by CAT_5:13;
consider C244 being (Functor of ( D67 `11 ) , ( D67 `12 )) such that L421: D67 = [ [ ( D67 `11 ) , ( D67 `12 ) ] , C244 ] by L420 , L419 , CAT_5:def 6;
thus L422: ( ( D66 `2 ) . ( C242 (*) C241 ) ) = ( ( C237 . ( C242 (*) C241 ) ) `2 ) by L396 , L412 , MCART_1:def 13
.= ( ( D68 (*) D67 ) `2 ) by L414 , CAT_1:64
.= ( [ [ ( D67 `11 ) , ( D68 `12 ) ] , ( C243 * C244 ) ] `2 ) by L416 , L419 , L418 , L421 , L415 , CAT_5:def 6
.= ( C243 * C244 )
.= ( ( D68 `2 ) * C244 ) by L418 , MCART_1:7
.= ( ( D68 `2 ) * ( D67 `2 ) ) by L421 , MCART_1:7
.= ( ( ( D66 `2 ) . C242 ) * ( D67 `2 ) ) by L396 , L412 , MCART_1:def 13
.= ( ( ( D66 `2 ) . C242 ) * ( ( D66 `2 ) . C241 ) ) by L396 , L412 , MCART_1:def 13;
end;
L423:
now
let C245 being (Object of C235);
reconsider D69 = ( ( Obj C237 ) . C245 ) as (Object of C236);
thus L424: ( ( D66 `2 ) . ( id C245 ) ) = ( ( C237 . (( id C245 ) qua (Morphism of C235)) ) `2 ) by L396 , L412 , MCART_1:def 13
.= ( (( id D69 ) qua (Morphism of C236)) `2 ) by CAT_1:68
.= ( [ [ ( ( D66 `1 ) . C245 ) , ( ( D66 `1 ) . C245 ) ] , ( id ( ( D66 `1 ) . C245 ) ) ] `2 ) by L392 , CAT_5:def 6
.= ( id ( ( D66 `1 ) . C245 ) );
end;
thus L425: thesis by L423 , L413 , L213;
end;
definition
let C246 being Category;
let C247 being  Categorial Category;
let C248 being (Functor of C246 , C247);
func C248 -indexing_of C246 -> (Indexing of C246) equals 
[ ( Obj C248 ) , ( pr2 C248 ) ];
coherence by L391;
end;
theorem
L427: (for B142 being Category holds (for B143 being  Categorial Category holds (for B144 being (Functor of B142 , B143) holds B143 is (TargetCat of ( B144 -indexing_of B142 )))))
proof
let C249 being Category;
let C250 being  Categorial Category;
let C251 being (Functor of C249 , C250);
set D70 = ( C251 -indexing_of C249 );
L428: ( D70 `1 ) = ( Obj C251 ) by MCART_1:7;
thus L429: (for B145 being (Object of C249) holds ( ( D70 `1 ) . B145 ) is (Object of C250)) by L428 , FUNCT_2:5;
let C252 being (Morphism of C249);
set D71 = ( C251 . C252 );
L430: ( dom D71 ) = ( D71 `11 ) by CAT_5:13;
L431: ( cod D71 ) = ( D71 `12 ) by CAT_5:13;
consider C253 being (Functor of ( D71 `11 ) , ( D71 `12 )) such that L432: D71 = [ [ ( D71 `11 ) , ( D71 `12 ) ] , C253 ] by L431 , L430 , CAT_5:def 6;
L433: ( cod D71 ) = ( ( Obj C251 ) . ( cod C252 ) ) by CAT_1:69
.= ( ( Obj C251 ) . ( (the Target of C249) . C252 ) );
L434: ( dom D71 ) = ( ( Obj C251 ) . ( dom C252 ) ) by CAT_1:69
.= ( ( Obj C251 ) . ( (the Source of C249) . C252 ) );
L435: (( D70 `2 ) = ( pr2 C251 ) & ( dom C251 ) = (the carrier' of C249)) by FUNCT_2:def 1 , MCART_1:7;
L436: ( ( D70 `2 ) . C252 ) = ( D71 `2 ) by L435 , MCART_1:def 13
.= C253 by L432 , MCART_1:7;
thus L437: thesis by L436 , L428 , L430 , L432 , L434 , L433 , CAT_5:13;
end;
theorem
L438: (for B146 being Category holds (for B147 being  Categorial Category holds (for B148 being (Functor of B146 , B147) holds (for B149 being (TargetCat of ( B148 -indexing_of B146 )) holds B148 = ( ( B148 -indexing_of B146 ) -functor (B146 , B149) )))))
proof
let C254 being Category;
let C255 being  Categorial Category;
let C256 being (Functor of C254 , C255);
set D72 = ( C256 -indexing_of C254 );
let C257 being (TargetCat of D72);
L439: ( D72 `2 ) = ( pr2 C256 ) by MCART_1:7;
L440: ( dom C256 ) = (the carrier' of C254) by FUNCT_2:def 1;
L441: ( D72 `1 ) = ( Obj C256 ) by MCART_1:7;
L442:
now
let C258 being set;
assume L443: C258 in (the carrier' of C254);
reconsider D73 = C258 as (Morphism of C254) by L443;
set D74 = ( C256 . D73 );
L444: (( dom D74 ) = ( ( Obj C256 ) . ( dom D73 ) ) & ( cod D74 ) = ( ( Obj C256 ) . ( cod D73 ) )) by CAT_1:69;
L445: (( dom D74 ) = ( D74 `11 ) & ( cod D74 ) = ( D74 `12 )) by CAT_5:13;
consider C259 being (Functor of ( D74 `11 ) , ( D74 `12 )) such that L446: D74 = [ [ ( D74 `11 ) , ( D74 `12 ) ] , C259 ] by L445 , CAT_5:def 6;
L447: ( ( D72 `2 ) . D73 ) = ( D74 `2 ) by L439 , L440 , MCART_1:def 13
.= C259 by L446 , MCART_1:7;
thus L448: ( C256 . C258 ) = ( ( D72 -functor (C254 , C257) ) . C258 ) by L447 , L441 , L445 , L446 , L444 , L275;
end;
L449: ( dom ( D72 -functor (C254 , C257) ) ) = (the carrier' of C254) by FUNCT_2:def 1;
thus L450: thesis by L449 , L440 , L442 , FUNCT_1:2;
end;
theorem
L451: (for B150 being Category holds (for B151 , B152 being  Categorial Category holds (for B153 being (Functor of B150 , B151) holds (for B154 being (Functor of B150 , B152) holds (B153 = B154 implies ( B153 -indexing_of B150 ) = ( B154 -indexing_of B150 )))))) by L15;
theorem
L452: (for B155 being Category holds (for B156 being (Indexing of B155) holds (for B157 being (TargetCat of B156) holds ( pr2 ( B156 -functor (B155 , B157) ) ) = ( B156 `2 ))))
proof
let C260 being Category;
let C261 being (Indexing of C260);
let C262 being (TargetCat of C261);
L453: ( dom ( C261 -functor (C260 , C262) ) ) = (the carrier' of C260) by FUNCT_2:def 1;
L454:
now
let C263 being set;
assume L455: C263 in (the carrier' of C260);
reconsider D75 = C263 as (Morphism of C260) by L455;
L456: ( ( C261 -functor (C260 , C262) ) . D75 ) = [ [ ( ( C261 `1 ) . ( dom D75 ) ) , ( ( C261 `1 ) . ( cod D75 ) ) ] , ( ( C261 `2 ) . D75 ) ] by L275;
L457: ( ( ( C261 -functor (C260 , C262) ) . C263 ) `2 ) = ( ( C261 `2 ) . D75 ) by L456 , MCART_1:7;
thus L458: ( ( pr2 ( C261 -functor (C260 , C262) ) ) . C263 ) = ( ( C261 `2 ) . C263 ) by L457 , L453 , MCART_1:def 13;
end;
L459: (( dom ( pr2 ( C261 -functor (C260 , C262) ) ) ) = ( dom ( C261 -functor (C260 , C262) ) ) & ( dom ( C261 `2 ) ) = (the carrier' of C260)) by MCART_1:def 13 , PARTFUN1:def 2;
thus L460: thesis by L459 , L453 , L454 , FUNCT_1:2;
end;
theorem
L461: (for B158 being Category holds (for B159 being (Indexing of B158) holds (for B160 being (TargetCat of B159) holds ( ( B159 -functor (B158 , B160) ) -indexing_of B158 ) = B159)))
proof
let C264 being Category;
let C265 being (Indexing of C264);
let C266 being (TargetCat of C265);
set D76 = ( C265 -functor (C264 , C266) );
L462: (ex B161 being (ManySortedSet of (the carrier of C264)) st (ex B162 being (ManySortedSet of (the carrier' of C264)) st C265 = [ B161 , B162 ])) by L111;
thus L463: ( D76 -indexing_of C264 ) = [ ( C265 `1 ) , ( pr2 D76 ) ] by L304
.= [ ( C265 `1 ) , ( C265 `2 ) ] by L452
.= C265 by L462 , MCART_1:8;
end;
begin
L464:
now
let C267 , C268 being Category;
let C269 being (Subcategory of C268);
let C270 being (Functor of C267 , C269);
L465: ( ( incl C269 ) * C270 ) = ( ( id C269 ) * C270 ) by CAT_2:def 5
.= C270 by FUNCT_2:17;
thus L466: C270 is (Functor of C267 , C268) by L465;
end;
definition
let C271 , C272 , C273 being Category;
let C274 being (Functor of C271 , C272);
let C275 being (Indexing of C273);
assume L467: ( Image C274 ) is (Subcategory of C273);
func C275 * C274 -> (Indexing of C271) means 
:L468: (for B163 being (Functor of C271 , C273) holds (B163 = C274 implies it = ( ( ( C275 -functor (C273 , ( rng C275 )) ) * B163 ) -indexing_of C271 )));
existence
proof
reconsider D77 = ( Image C274 ) as (Subcategory of C273) by L467;
reconsider D78 = C274 as (Functor of C271 , D77) by CAT_5:8;
reconsider D79 = D78 as (Functor of C271 , C273) by L464;
take ( ( ( C275 -functor (C273 , ( rng C275 )) ) * D79 ) -indexing_of C271 );
thus L469: thesis;
end;
uniqueness
proof
reconsider D80 = ( Image C274 ) as (Subcategory of C273) by L467;
reconsider D81 = C274 as (Functor of C271 , D80) by CAT_5:8;
let C276 , C277 being (Indexing of C271);
assume that
L470: (for B164 being (Functor of C271 , C273) holds (B164 = C274 implies C276 = ( ( ( C275 -functor (C273 , ( rng C275 )) ) * B164 ) -indexing_of C271 )))
and
L471: (for B165 being (Functor of C271 , C273) holds (B165 = C274 implies C277 = ( ( ( C275 -functor (C273 , ( rng C275 )) ) * B165 ) -indexing_of C271 )));
reconsider D82 = D81 as (Functor of C271 , C273) by L464;
thus L472: C276 = ( ( ( C275 -functor (C273 , ( rng C275 )) ) * D82 ) -indexing_of C271 ) by L470
.= C277 by L471;
end;
end;
theorem
L474: (for B166 , B167 , B168 , B169 being Category holds (for B170 being (Indexing of B169) holds (for B171 being (Functor of B166 , B167) holds (for B172 being (Functor of B166 , B168) holds ((( Image B171 ) is (Subcategory of B169) & ( Image B172 ) is (Subcategory of B169) & B171 = B172) implies ( B170 * B171 ) = ( B170 * B172 ))))))
proof
let C278 , C279 , C280 , C281 being Category;
let C282 being (Indexing of C281);
let C283 being (Functor of C278 , C279);
let C284 being (Functor of C278 , C280);
assume that
L475: ( Image C283 ) is (Subcategory of C281)
and
L476: ( Image C284 ) is (Subcategory of C281)
and
L477: C283 = C284;
reconsider D83 = C283 as (Functor of C278 , ( Image C283 )) by CAT_5:8;
reconsider D84 = D83 as (Functor of C278 , C281) by L475 , L464;
L478: ( C282 * C283 ) = ( ( ( C282 -functor (C281 , ( rng C282 )) ) * D84 ) -indexing_of C278 ) by L475 , L468;
thus L479: thesis by L478 , L476 , L477 , L468;
end;
theorem
L480: (for B173 , B174 being Category holds (for B175 being (Functor of B173 , B174) holds (for B176 being (Indexing of B174) holds (for B177 being (TargetCat of B176) holds ( B176 * B175 ) = ( ( ( B176 -functor (B174 , B177) ) * B175 ) -indexing_of B173 )))))
proof
let C285 , C286 being Category;
let C287 being (Functor of C285 , C286);
let C288 being (Indexing of C286);
let C289 being (TargetCat of C288);
L481: ( Image C287 ) is (Subcategory of C286);
L482: ( C288 * C287 ) = ( ( ( C288 -functor (C286 , ( rng C288 )) ) * C287 ) -indexing_of C285 ) by L481 , L468;
L483: ( ( C288 -functor (C286 , ( rng C288 )) ) * C287 ) = ( ( C288 -functor (C286 , C289) ) * C287 ) by L312;
thus L484: thesis by L483 , L482 , L15;
end;
theorem
L485: (for B178 , B179 being Category holds (for B180 being (Functor of B178 , B179) holds (for B181 being (Indexing of B179) holds (for B182 being (TargetCat of B181) holds B182 is (TargetCat of ( B181 * B180 ))))))
proof
let C290 , C291 being Category;
let C292 being (Functor of C290 , C291);
let C293 being (Indexing of C291);
let C294 being (TargetCat of C293);
set D85 = the (TargetCat of ( C293 * C292 ));
L486: (( rng ( C293 * C292 ) ) = ( Image ( ( C293 * C292 ) -functor (C290 , D85) ) ) & ( C293 * C292 ) = ( ( ( C293 -functor (C291 , C294) ) * C292 ) -indexing_of C290 )) by L325 , L480;
L487: ( rng ( C293 * C292 ) ) = ( Image ( ( C293 -functor (C291 , C294) ) * C292 ) ) by L486 , L438 , CAT_5:22;
thus L488: thesis by L487 , L338;
end;
theorem
L489: (for B183 , B184 being Category holds (for B185 being (Functor of B183 , B184) holds (for B186 being (Indexing of B184) holds (for B187 being (TargetCat of B186) holds ( rng ( B186 * B185 ) ) is (Subcategory of B187)))))
proof
let C295 , C296 being Category;
let C297 being (Functor of C295 , C296);
let C298 being (Indexing of C296);
let C299 being (TargetCat of C298);
L490: C299 is (TargetCat of ( C298 * C297 )) by L485;
thus L491: thesis by L490 , L338;
end;
theorem
L492: (for B188 , B189 , B190 being Category holds (for B191 being (Functor of B188 , B189) holds (for B192 being (Functor of B189 , B190) holds (for B193 being (Indexing of B190) holds ( ( B193 * B192 ) * B191 ) = ( B193 * ( B192 * B191 ) )))))
proof
let C300 , C301 , C302 being Category;
let C303 being (Functor of C300 , C301);
let C304 being (Functor of C301 , C302);
let C305 being (Indexing of C302);
set D86 = ( rng C305 );
reconsider D87 = D86 as (TargetCat of ( C305 * C304 )) by L485;
L493: ( C305 * C304 ) = ( ( ( C305 -functor (C302 , D86) ) * C304 ) -indexing_of C301 ) by L480;
L494: ( ( C305 * C304 ) -functor (C301 , D87) ) = ( ( C305 -functor (C302 , D86) ) * C304 ) by L493 , L438;
thus L495: ( ( C305 * C304 ) * C303 ) = ( ( ( ( C305 -functor (C302 , D86) ) * C304 ) * C303 ) -indexing_of C300 ) by L494 , L480
.= ( ( ( C305 -functor (C302 , D86) ) * ( C304 * C303 ) ) -indexing_of C300 ) by RELAT_1:36
.= ( C305 * ( C304 * C303 ) ) by L480;
end;
definition
let C306 being Category;
let C307 being (Indexing of C306);
let C308 being  Categorial Category;
assume that
L496: C308 is (TargetCat of C307);
let C309 being  Categorial Category;
let C310 being (Functor of C308 , C309);
func C310 * C307 -> (Indexing of C306) means 
:L497: (for B194 being (TargetCat of C307) holds (for B195 being (Functor of B194 , C309) holds ((B194 = C308 & B195 = C310) implies it = ( ( B195 * ( C307 -functor (C306 , B194) ) ) -indexing_of C306 ))));
existence
proof
reconsider D88 = C308 as (TargetCat of C307) by L496;
reconsider D89 = C310 as (Functor of D88 , C309);
take ( ( D89 * ( C307 -functor (C306 , D88) ) ) -indexing_of C306 );
thus L498: thesis;
end;
uniqueness
proof
reconsider D90 = C308 as (TargetCat of C307) by L496;
reconsider D91 = C310 as (Functor of D90 , C309);
let C311 , C312 being (Indexing of C306);
assume L499: (not thesis);
L500: C311 = ( ( D91 * ( C307 -functor (C306 , D90) ) ) -indexing_of C306 ) by L499;
thus L501: thesis by L500 , L499;
end;
end;
theorem
L503: (for B196 being Category holds (for B197 being (Indexing of B196) holds (for B198 being (TargetCat of B197) holds (for B199 , B200 being  Categorial Category holds (for B201 being (Functor of B198 , B199) holds (for B202 being (Functor of B198 , B200) holds (B201 = B202 implies ( B201 * B197 ) = ( B202 * B197 ))))))))
proof
let C313 being Category;
let C314 being (Indexing of C313);
let C315 being (TargetCat of C314);
let C316 , C317 being  Categorial Category;
let C318 being (Functor of C315 , C316);
let C319 being (Functor of C315 , C317);
assume L504: C318 = C319;
thus L505: ( C318 * C314 ) = ( ( C318 * ( C314 -functor (C313 , C315) ) ) -indexing_of C313 ) by L497
.= ( ( C319 * ( C314 -functor (C313 , C315) ) ) -indexing_of C313 ) by L504 , L15
.= ( C319 * C314 ) by L497;
end;
theorem
L506: (for B203 being Category holds (for B204 being (Indexing of B203) holds (for B205 being (TargetCat of B204) holds (for B206 being  Categorial Category holds (for B207 being (Functor of B205 , B206) holds ( Image B207 ) is (TargetCat of ( B207 * B204 )))))))
proof
let C320 being Category;
let C321 being (Indexing of C320);
let C322 being (TargetCat of C321);
let C323 being  Categorial Category;
let C324 being (Functor of C322 , C323);
reconsider D92 = C324 as (Functor of C322 , ( Image C324 )) by CAT_5:8;
set D93 = the (TargetCat of ( C324 * C321 ));
L507: ( rng ( C324 * C321 ) ) = ( Image ( ( C324 * C321 ) -functor (C320 , D93) ) ) by L325;
L508: ( C324 * C321 ) = ( D92 * C321 ) by L503
.= ( ( D92 * ( C321 -functor (C320 , C322) ) ) -indexing_of C320 ) by L497;
L509: ( rng ( C324 * C321 ) ) = ( Image ( D92 * ( C321 -functor (C320 , C322) ) ) ) by L508 , L507 , L438 , CAT_5:22;
thus L510: thesis by L509 , L338;
end;
theorem
L511: (for B208 being Category holds (for B209 being (Indexing of B208) holds (for B210 being (TargetCat of B209) holds (for B211 being  Categorial Category holds (for B212 being (Functor of B210 , B211) holds B211 is (TargetCat of ( B212 * B209 )))))))
proof
let C325 being Category;
let C326 being (Indexing of C325);
let C327 being (TargetCat of C326);
let C328 being  Categorial Category;
let C329 being (Functor of C327 , C328);
L512: ( Image C329 ) is (TargetCat of ( C329 * C326 )) by L506;
L513: ( rng ( C329 * C326 ) ) is (Subcategory of ( Image C329 )) by L512 , L338;
L514: ( rng ( C329 * C326 ) ) is (Subcategory of C328) by L513 , CAT_5:4;
thus L515: thesis by L514 , L338;
end;
theorem
L516: (for B213 being Category holds (for B214 being (Indexing of B213) holds (for B215 being (TargetCat of B214) holds (for B216 being  Categorial Category holds (for B217 being (Functor of B215 , B216) holds ( rng ( B217 * B214 ) ) is (Subcategory of ( Image B217 )))))))
proof
let C330 being Category;
let C331 being (Indexing of C330);
let C332 being (TargetCat of C331);
let C333 being  Categorial Category;
let C334 being (Functor of C332 , C333);
L517: ( Image C334 ) is (TargetCat of ( C334 * C331 )) by L506;
thus L518: thesis by L517 , L338;
end;
theorem
L519: (for B218 being Category holds (for B219 being (Indexing of B218) holds (for B220 being (TargetCat of B219) holds (for B221 , B222 being  Categorial Category holds (for B223 being (Functor of B220 , B221) holds (for B224 being (Functor of B221 , B222) holds ( ( B224 * B223 ) * B219 ) = ( B224 * ( B223 * B219 ) )))))))
proof
let C335 being Category;
let C336 being (Indexing of C335);
let C337 being (TargetCat of C336);
let C338 , C339 being  Categorial Category;
let C340 being (Functor of C337 , C338);
reconsider D94 = C338 as (TargetCat of ( C340 * C336 )) by L511;
let C341 being (Functor of C338 , C339);
reconsider D95 = C341 as (Functor of D94 , C339);
L520: ( C340 * C336 ) = ( ( C340 * ( C336 -functor (C335 , C337) ) ) -indexing_of C335 ) by L497;
L521: ( ( C340 * C336 ) -functor (C335 , D94) ) = ( C340 * ( C336 -functor (C335 , C337) ) ) by L520 , L438;
thus L522: ( ( C341 * C340 ) * C336 ) = ( ( ( C341 * C340 ) * ( C336 -functor (C335 , C337) ) ) -indexing_of C335 ) by L497
.= ( ( D95 * ( ( C340 * C336 ) -functor (C335 , D94) ) ) -indexing_of C335 ) by L521 , RELAT_1:36
.= ( C341 * ( C340 * C336 ) ) by L497;
end;
definition
let C342 , C343 being Category;
let C344 being (Indexing of C342);
let C345 being (Indexing of C343);
func C345 * C344 -> (Indexing of C342) equals 
( C345 * ( C344 -functor (C342 , ( rng C344 )) ) );
correctness;
end;
theorem
L524: (for B225 being Category holds (for B226 being  Categorial Category holds (for B227 being (Indexing of B225) holds (for B228 being (Indexing of B226) holds (for B229 being (TargetCat of B227) holds (B226 is (TargetCat of B227) implies ( B228 * B227 ) = ( B228 * ( B227 -functor (B225 , B229) ) )))))))
proof
let C346 being Category;
let C347 being  Categorial Category;
let C348 being (Indexing of C346);
let C349 being (Indexing of C347);
let C350 being (TargetCat of C348);
assume L525: C347 is (TargetCat of C348);
reconsider D96 = C347 as (TargetCat of C348) by L525;
L526: ( Image ( C348 -functor (C346 , ( rng C348 )) ) ) = ( rng C348 ) by L325;
L527: (( Image ( C348 -functor (C346 , D96) ) ) = ( rng C348 ) & ( Image ( C348 -functor (C346 , C350) ) ) = ( rng C348 )) by L325;
thus L528: thesis by L527 , L526 , L312 , L474;
end;
theorem
L529: (for B230 being Category holds (for B231 being  Categorial Category holds (for B232 being (Indexing of B230) holds (for B233 being (Indexing of B231) holds (for B234 being (TargetCat of B233) holds (B231 is (TargetCat of B232) implies ( B233 * B232 ) = ( ( B233 -functor (B231 , B234) ) * B232 )))))))
proof
let C351 being Category;
let C352 being  Categorial Category;
let C353 being (Indexing of C351);
let C354 being (Indexing of C352);
let C355 being (TargetCat of C354);
assume L530: C352 is (TargetCat of C353);
reconsider D97 = C352 as (TargetCat of C353) by L530;
reconsider D98 = C354 as (Indexing of D97);
reconsider D99 = C355 as (TargetCat of D98);
L531: (( Image ( C353 -functor (C351 , D97) ) ) = ( rng C353 ) & ( Image ( C353 -functor (C351 , ( rng C353 )) ) ) = ( rng C353 )) by L325;
thus L532: ( C354 * C353 ) = ( C354 * ( C353 -functor (C351 , D97) ) ) by L531 , L312 , L474
.= ( ( ( D98 -functor (D97 , D99) ) * ( C353 -functor (C351 , D97) ) ) -indexing_of C351 ) by L480
.= ( ( C354 -functor (C352 , C355) ) * C353 ) by L497;
end;
theorem
L533: (for B235 , B236 being Category holds (for B237 being (Functor of B235 , B236) holds (for B238 being (Indexing of B236) holds (for B239 being (TargetCat of B238) holds (for B240 being  Categorial Category holds (for B241 being (Functor of B239 , B240) holds ( ( B241 * B238 ) * B237 ) = ( B241 * ( B238 * B237 ) )))))))
proof
let C356 , C357 being Category;
let C358 being (Functor of C356 , C357);
let C359 being (Indexing of C357);
let C360 being (TargetCat of C359);
reconsider D100 = C360 as (TargetCat of ( C359 * C358 )) by L485;
let C361 being  Categorial Category;
let C362 being (Functor of C360 , C361);
reconsider D101 = C362 as (Functor of D100 , C361);
reconsider D102 = ( rng ( C362 * C359 ) ) as (TargetCat of ( ( C362 * ( C359 -functor (C357 , C360) ) ) -indexing_of C357 )) by L497;
L534: ( C359 * C358 ) = ( ( ( C359 -functor (C357 , C360) ) * C358 ) -indexing_of C356 ) by L480;
L535: ( ( ( C362 * ( C359 -functor (C357 , C360) ) ) -indexing_of C357 ) -functor (C357 , D102) ) = ( C362 * ( C359 -functor (C357 , C360) ) ) by L438;
L536: (( C362 * C359 ) = ( ( C362 * ( C359 -functor (C357 , C360) ) ) -indexing_of C357 ) & ( Image C358 ) is (Subcategory of C357)) by L497;
thus L537: ( ( C362 * C359 ) * C358 ) = ( ( ( ( ( C362 * ( C359 -functor (C357 , C360) ) ) -indexing_of C357 ) -functor (C357 , D102) ) * C358 ) -indexing_of C356 ) by L536 , L468
.= ( ( ( C362 * ( C359 -functor (C357 , C360) ) ) * C358 ) -indexing_of C356 ) by L535 , L15
.= ( ( C362 * ( ( C359 -functor (C357 , C360) ) * C358 ) ) -indexing_of C356 ) by RELAT_1:36
.= ( ( D101 * ( ( C359 * C358 ) -functor (C356 , D100) ) ) -indexing_of C356 ) by L534 , L438
.= ( C362 * ( C359 * C358 ) ) by L497;
end;
theorem
L538: (for B242 being Category holds (for B243 being (Indexing of B242) holds (for B244 being (TargetCat of B243) holds (for B245 being  Categorial Category holds (for B246 being (Functor of B244 , B245) holds (for B247 being (Indexing of B245) holds ( ( B247 * B246 ) * B243 ) = ( B247 * ( B246 * B243 ) )))))))
proof
let C363 being Category;
let C364 being (Indexing of C363);
let C365 being (TargetCat of C364);
let C366 being  Categorial Category;
let C367 being (Functor of C365 , C366);
let C368 being (Indexing of C366);
L539: (( C367 * C364 ) = ( ( C367 * ( C364 -functor (C363 , C365) ) ) -indexing_of C363 ) & ( Image ( C367 * ( C364 -functor (C363 , C365) ) ) ) is (Subcategory of C366)) by L497;
L540: C366 is (TargetCat of ( C367 * C364 )) by L511;
L541: ( rng ( C367 * C364 ) ) is (Subcategory of C366) by L540 , L338;
L542: ( Image ( ( C367 * C364 ) -functor (C363 , ( rng ( C367 * C364 ) )) ) ) is (Subcategory of C366) by L541 , CAT_5:4;
thus L543: ( ( C368 * C367 ) * C364 ) = ( ( C368 * C367 ) * ( C364 -functor (C363 , C365) ) ) by L524
.= ( C368 * ( C367 * ( C364 -functor (C363 , C365) ) ) ) by L492
.= ( C368 * ( C367 * C364 ) ) by L539 , L542 , L438 , L474;
end;
theorem
L544: (for B248 being Category holds (for B249 being (Indexing of B248) holds (for B250 being (TargetCat of B249) holds (for B251 being (Indexing of B250) holds (for B252 being (TargetCat of B251) holds (for B253 being  Categorial Category holds (for B254 being (Functor of B252 , B253) holds ( ( B254 * B251 ) * B249 ) = ( B254 * ( B251 * B249 ) ))))))))
proof
let C369 being Category;
let C370 being (Indexing of C369);
let C371 being (TargetCat of C370);
let C372 being (Indexing of C371);
let C373 being (TargetCat of C372);
let C374 being  Categorial Category;
let C375 being (Functor of C373 , C374);
thus L545: ( ( C375 * C372 ) * C370 ) = ( ( C375 * C372 ) * ( C370 -functor (C369 , C371) ) ) by L524
.= ( C375 * ( C372 * ( C370 -functor (C369 , C371) ) ) ) by L533
.= ( C375 * ( C372 * C370 ) ) by L524;
end;
theorem
L546: (for B255 , B256 being Category holds (for B257 being (Functor of B255 , B256) holds (for B258 being (Indexing of B256) holds (for B259 being (TargetCat of B258) holds (for B260 being (Indexing of B259) holds ( ( B260 * B258 ) * B257 ) = ( B260 * ( B258 * B257 ) ))))))
proof
let C376 , C377 being Category;
let C378 being (Functor of C376 , C377);
let C379 being (Indexing of C377);
let C380 being (TargetCat of C379);
let C381 being (Indexing of C380);
L547: (( C379 * C378 ) = ( ( ( C379 -functor (C377 , C380) ) * C378 ) -indexing_of C376 ) & ( Image ( ( C379 -functor (C377 , C380) ) * C378 ) ) is (Subcategory of C380)) by L480;
L548: C380 is (TargetCat of ( C379 * C378 )) by L485;
L549: ( rng ( C379 * C378 ) ) is (Subcategory of C380) by L548 , L338;
L550: ( Image ( ( C379 * C378 ) -functor (C376 , ( rng ( C379 * C378 ) )) ) ) is (Subcategory of C380) by L549 , CAT_5:4;
thus L551: ( ( C381 * C379 ) * C378 ) = ( ( C381 * ( C379 -functor (C377 , C380) ) ) * C378 ) by L524
.= ( C381 * ( ( C379 -functor (C377 , C380) ) * C378 ) ) by L492
.= ( C381 * ( C379 * C378 ) ) by L547 , L550 , L438 , L474;
end;
theorem
L552: (for B261 being Category holds (for B262 being (Indexing of B261) holds (for B263 being (TargetCat of B262) holds (for B264 being (Indexing of B263) holds (for B265 being (TargetCat of B264) holds (for B266 being (Indexing of B265) holds ( ( B266 * B264 ) * B262 ) = ( B266 * ( B264 * B262 ) )))))))
proof
let C382 being Category;
let C383 being (Indexing of C382);
let C384 being (TargetCat of C383);
let C385 being (Indexing of C384);
let C386 being (TargetCat of C385);
let C387 being (Indexing of C386);
thus L553: ( ( C387 * C385 ) * C383 ) = ( ( C387 * C385 ) * ( C383 -functor (C382 , C384) ) ) by L524
.= ( C387 * ( C385 * ( C383 -functor (C382 , C384) ) ) ) by L546
.= ( C387 * ( C385 * C383 ) ) by L524;
end;
theorem
L554: (for B267 being Category holds ( IdMap B267 ) = ( IdMap ( B267 opp ) )) by L257;
