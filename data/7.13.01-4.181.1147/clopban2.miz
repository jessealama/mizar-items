:: Banach Algebra of Bounded Complex Linear Operators
::  by Noboru Endou
::
:: Received March 18, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, CLVECT_1, LOPBAN_1, RELAT_1, RLVECT_1, CFUNCT_1,
      FUNCT_1, ARYTM_3, XXREAL_2, NORMSP_1, XXREAL_0, PRE_TOPC, CLOPBAN1,
      CARD_1, REAL_1, XREAL_0, ORDINAL1, SUBSET_1, RSSPACE, LOPBAN_2, BINOP_1,
      STRUCT_0, COMPLEX1, ALGSTR_0, XBOOLE_0, GROUP_1, SUPINF_2, MESFUNC1,
      FUNCSDOM, VECTSP_1, LATTICES, CFUNCDOM, CSSPACE3, REWRITE1, NAT_1,
      RSSPACE3, SEQ_2, ZFMISC_1, XCMPLX_0, PREPOWER, COMSEQ_1, SERIES_1,
      CSSPACE, ARYTM_1, CLOPBAN2, NORMSP_0, METRIC_1, RELAT_2, SEQ_4, FCONT_1;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, FUNCT_1, PARTFUN1, FUNCT_2, PRE_TOPC,
      BINOP_1, STRUCT_0, ALGSTR_0, XCMPLX_0, XXREAL_0, XREAL_0, ORDINAL1,
      NUMBERS, XXREAL_2, REAL_1, RLVECT_1, VALUED_1, SEQ_4, FUNCSDOM, COMPLEX1,
      GROUP_1, VECTSP_1, SERIES_1, CFUNCT_1, COMSEQ_1, COMSEQ_3, NORMSP_0,
      CLVECT_1, CSSPACE, CSSPACE3, CLOPBAN1, CFUNCDOM, PREPOWER;
 constructors REAL_1, PREPOWER, COMSEQ_3, CSSPACE3, CLOPBAN1, CFUNCDOM,
      VECTSP_1, SEQ_1, SEQ_4, RELSET_1, BINOP_2, BINOP_1;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, MEMBERED, STRUCT_0, CLVECT_1, CSSPACE3,
      CLOPBAN1, CFUNCDOM, ALGSTR_0, VALUED_1, VALUED_0, NORMSP_0;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;
 definitions STRUCT_0, GROUP_1, VECTSP_1, CLOPBAN1, BINOP_1, RLVECT_1,
      ALGSTR_0, CLVECT_1, CFUNCDOM, NORMSP_0;
 theorems ABSVALUE, RLVECT_1, VECTSP_1, BINOP_1, XCMPLX_0, SERIES_1, FUNCT_1,
      FUNCT_2, SEQ_4, PREPOWER, STRUCT_0, CLOPBAN1, CLVECT_1, COMPLEX1,
      CFUNCDOM, CSSPACE3, COMSEQ_3, CSSPACE, GROUP_1, XREAL_1, XXREAL_0,
      ALGSTR_0, VALUED_1, NORMSP_0;
 schemes BINOP_1;

begin
theorem
L1: (for B1 , B2 , B3 being ComplexLinearSpace holds (for B4 being (LinearOperator of B1 , B2) holds (for B5 being (LinearOperator of B2 , B3) holds ( B5 * B4 ) is (LinearOperator of B1 , B3))))
proof
let C1 , C2 , C3 being ComplexLinearSpace;
let C4 being (LinearOperator of C1 , C2);
let C5 being (LinearOperator of C2 , C3);
L2:
now
let C6 being (VECTOR of C1);
let C7 being Complex;
thus L3: ( ( C5 * C4 ) . ( C7 * C6 ) ) = ( C5 . ( C4 . ( C7 * C6 ) ) ) by FUNCT_2:15
.= ( C5 . ( C7 * ( C4 . C6 ) ) ) by CLOPBAN1:def 3
.= ( C7 * ( C5 . ( C4 . C6 ) ) ) by CLOPBAN1:def 3
.= ( C7 * ( ( C5 * C4 ) . C6 ) ) by FUNCT_2:15;
end;
L4:
now
let C8 , C9 being (VECTOR of C1);
thus L5: ( ( C5 * C4 ) . ( C8 + C9 ) ) = ( C5 . ( C4 . ( C8 + C9 ) ) ) by FUNCT_2:15
.= ( C5 . ( ( C4 . C8 ) + ( C4 . C9 ) ) ) by VECTSP_1:def 20
.= ( ( C5 . ( C4 . C8 ) ) + ( C5 . ( C4 . C9 ) ) ) by VECTSP_1:def 20
.= ( ( ( C5 * C4 ) . C8 ) + ( C5 . ( C4 . C9 ) ) ) by FUNCT_2:15
.= ( ( ( C5 * C4 ) . C8 ) + ( ( C5 * C4 ) . C9 ) ) by FUNCT_2:15;
end;
thus L6: thesis by L4 , L2 , CLOPBAN1:def 3 , VECTSP_1:def 20;
end;
theorem
L7: (for B6 , B7 , B8 being ComplexNormSpace holds (for B9 being  Lipschitzian (LinearOperator of B6 , B7) holds (for B10 being  Lipschitzian (LinearOperator of B7 , B8) holds (( B10 * B9 ) is  Lipschitzian  Lipschitzian  Lipschitzian  Lipschitzian (LinearOperator of B6 , B8) & (for B11 being (VECTOR of B6) holds (||. ( ( B10 * B9 ) . B11 ) .|| <= ( ( ( ( BoundedLinearOperatorsNorm (B7 , B8) ) . B10 ) * ( ( BoundedLinearOperatorsNorm (B6 , B7) ) . B9 ) ) * ||. B11 .|| ) & ( ( BoundedLinearOperatorsNorm (B6 , B8) ) . ( B10 * B9 ) ) <= ( ( ( BoundedLinearOperatorsNorm (B7 , B8) ) . B10 ) * ( ( BoundedLinearOperatorsNorm (B6 , B7) ) . B9 ) )))))))
proof
let C10 , C11 , C12 being ComplexNormSpace;
let C13 being  Lipschitzian (LinearOperator of C10 , C11);
let C14 being  Lipschitzian (LinearOperator of C11 , C12);
reconsider D1 = C13 as (Point of ( C_NormSpace_of_BoundedLinearOperators (C10 , C11) )) by CLOPBAN1:def 7;
reconsider D2 = C14 as (Point of ( C_NormSpace_of_BoundedLinearOperators (C11 , C12) )) by CLOPBAN1:def 7;
L8:
now
let C15 being (VECTOR of C10);
L9: ( 0 ) <= ||. D2 .|| by CLVECT_1:105;
L10: ( ||. D2 .|| * ||. ( C13 . C15 ) .|| ) <= ( ||. D2 .|| * ( ||. D1 .|| * ||. C15 .|| ) ) by L9 , CLOPBAN1:31 , XREAL_1:64;
L11: (||. ( ( C14 * C13 ) . C15 ) .|| = ||. ( C14 . ( C13 . C15 ) ) .|| & ||. ( C14 . ( C13 . C15 ) ) .|| <= ( ||. D2 .|| * ||. ( C13 . C15 ) .|| )) by CLOPBAN1:31 , FUNCT_2:15;
thus L12: ||. ( ( C14 * C13 ) . C15 ) .|| <= ( ( ||. D2 .|| * ||. D1 .|| ) * ||. C15 .|| ) by L11 , L10 , XXREAL_0:2;
end;
set D3 = ( ||. D2 .|| * ||. D1 .|| );
L13: (( 0 ) <= ||. D2 .|| & ( 0 ) <= ||. D1 .||) by CLVECT_1:105;
reconsider D4 = ( C14 * C13 ) as  Lipschitzian (LinearOperator of C10 , C12) by L13 , L8 , L1 , CLOPBAN1:def 6;
L14:
now
let C16 being (VECTOR of C10);
assume L15: ||. C16 .|| <= 1;
L16: ( D3 * ||. C16 .|| ) <= ( D3 * 1 ) by L15 , L13 , XREAL_1:64;
L17: ||. ( ( C14 * C13 ) . C16 ) .|| <= ( D3 * ||. C16 .|| ) by L8;
thus L18: ||. ( ( C14 * C13 ) . C16 ) .|| <= D3 by L17 , L16 , XXREAL_0:2;
end;
L19:
now
let C17 being Real;
assume L20: C17 in ( PreNorms D4 );
L21: (ex B12 being (VECTOR of C10) st (C17 = ||. ( D4 . B12 ) .|| & ||. B12 .|| <= 1)) by L20;
thus L22: C17 <= D3 by L21 , L14;
end;
L23: ((for B13 being  real number holds (B13 in ( PreNorms D4 ) implies B13 <= D3)) implies ( upper_bound ( PreNorms D4 ) ) <= D3) by SEQ_4:45;
thus L24: thesis by L23 , L8 , L19 , CLOPBAN1:29;
end;
definition
let C18 being ComplexNormSpace;
let C19 , C20 being  Lipschitzian (LinearOperator of C18 , C18);
redefine func C20 * C19 ->  Lipschitzian (LinearOperator of C18 , C18);

correctness by L7;
end;
definition
let C21 being ComplexNormSpace;
let C22 , C23 being (Element of ( BoundedLinearOperators (C21 , C21) ));
func C22 + C23 -> (Element of ( BoundedLinearOperators (C21 , C21) )) equals 
( ( Add_ (( BoundedLinearOperators (C21 , C21) ) , ( C_VectorSpace_of_LinearOperators (C21 , C21) )) ) . (C22 , C23) );
correctness;
end;
definition
let C24 being ComplexNormSpace;
let C25 , C26 being (Element of ( BoundedLinearOperators (C24 , C24) ));
func C26 * C25 -> (Element of ( BoundedLinearOperators (C24 , C24) )) equals 
( ( modetrans (C26 , C24 , C24) ) * ( modetrans (C25 , C24 , C24) ) );
correctness by CLOPBAN1:def 7;
end;
definition
let C27 being ComplexNormSpace;
let C28 being (Element of ( BoundedLinearOperators (C27 , C27) ));
let C29 being Complex;
func C29 * C28 -> (Element of ( BoundedLinearOperators (C27 , C27) )) equals 
( ( Mult_ (( BoundedLinearOperators (C27 , C27) ) , ( C_VectorSpace_of_LinearOperators (C27 , C27) )) ) . (C29 , C28) );
correctness
proof
reconsider D5 = C29 as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
L28: ( ( Mult_ (( BoundedLinearOperators (C27 , C27) ) , ( C_VectorSpace_of_LinearOperators (C27 , C27) )) ) . (D5 , C28) ) is (Element of ( BoundedLinearOperators (C27 , C27) ));
thus L29: thesis by L28;
end;
end;
definition
let C30 being ComplexNormSpace;
func FuncMult C30 -> (BinOp of ( BoundedLinearOperators (C30 , C30) )) means 
:L31: (for B14 , B15 being (Element of ( BoundedLinearOperators (C30 , C30) )) holds ( it . (B14 , B15) ) = ( B14 * B15 ));
existence
proof
deffunc H1((Element of ( BoundedLinearOperators (C30 , C30) )) , (Element of ( BoundedLinearOperators (C30 , C30) ))) = ( $1 * $2 );
consider C31 being (BinOp of ( BoundedLinearOperators (C30 , C30) )) such that L32: (for B16 , B17 being (Element of ( BoundedLinearOperators (C30 , C30) )) holds ( C31 . (B16 , B17) ) = H1(B16 , B17)) from BINOP_1:sch 4;
take C31;
let C32 , C33 being (Element of ( BoundedLinearOperators (C30 , C30) ));
thus L33: thesis by L32;
end;
uniqueness
proof
let C34 , C35 being (BinOp of ( BoundedLinearOperators (C30 , C30) ));
assume that
L34: (for B18 , B19 being (Element of ( BoundedLinearOperators (C30 , C30) )) holds ( C34 . (B18 , B19) ) = ( B18 * B19 ))
and
L35: (for B20 , B21 being (Element of ( BoundedLinearOperators (C30 , C30) )) holds ( C35 . (B20 , B21) ) = ( B20 * B21 ));
L36:
now
let C36 , C37 being (Element of ( BoundedLinearOperators (C30 , C30) ));
thus L37: ( C34 . (C36 , C37) ) = ( C36 * C37 ) by L34
.= ( C35 . (C36 , C37) ) by L35;
end;
thus L38: thesis by L36 , BINOP_1:2;
end;
end;
theorem
L40: (for B22 being ComplexNormSpace holds ( id (the carrier of B22) ) is  Lipschitzian  Lipschitzian  Lipschitzian  Lipschitzian (LinearOperator of B22 , B22))
proof
let C38 being ComplexNormSpace;
L41:
now
let C39 , C40 being (VECTOR of C38);
thus L42: ( ( id (the carrier of C38) ) . ( C39 + C40 ) ) = ( C39 + C40 ) by FUNCT_1:18
.= ( ( ( id (the carrier of C38) ) . C39 ) + C40 ) by FUNCT_1:18
.= ( ( ( id (the carrier of C38) ) . C39 ) + ( ( id (the carrier of C38) ) . C40 ) ) by FUNCT_1:18;
end;
L43:
now
let C41 being (VECTOR of C38);
let C42 being Complex;
thus L44: ( ( id (the carrier of C38) ) . ( C42 * C41 ) ) = ( C42 * C41 ) by FUNCT_1:18
.= ( C42 * ( ( id (the carrier of C38) ) . C41 ) ) by FUNCT_1:18;
end;
L45: (for B23 being (VECTOR of C38) holds ||. ( ( id (the carrier of C38) ) . B23 ) .|| <= ( 1 * ||. B23 .|| )) by FUNCT_1:18;
thus L46: thesis by L45 , L41 , L43 , CLOPBAN1:def 3 , CLOPBAN1:def 6 , VECTSP_1:def 20;
end;
definition
let C43 being ComplexNormSpace;
func FuncUnit C43 -> (Element of ( BoundedLinearOperators (C43 , C43) )) equals 
( id (the carrier of C43) );
coherence
proof
L47: ( id (the carrier of C43) ) is  Lipschitzian  Lipschitzian  Lipschitzian  Lipschitzian (LinearOperator of C43 , C43) by L40;
thus L48: thesis by L47 , CLOPBAN1:def 7;
end;
end;
theorem
L50: (for B24 being ComplexNormSpace holds (for B25 , B26 , B27 being  Lipschitzian (LinearOperator of B24 , B24) holds (B27 = ( B25 * B26 ) iff (for B28 being (VECTOR of B24) holds ( B27 . B28 ) = ( B25 . ( B26 . B28 ) )))))
proof
let C44 being ComplexNormSpace;
let C45 , C46 , C47 being  Lipschitzian (LinearOperator of C44 , C44);
L51:
now
assume L52: (for B29 being (VECTOR of C44) holds ( C47 . B29 ) = ( C45 . ( C46 . B29 ) ));
L53:
now
let C48 being (VECTOR of C44);
thus L54: ( ( C45 * C46 ) . C48 ) = ( C45 . ( C46 . C48 ) ) by FUNCT_2:15
.= ( C47 . C48 ) by L52;
end;
thus L55: C47 = ( C45 * C46 ) by L53 , FUNCT_2:63;
end;
thus L56: thesis by L51 , FUNCT_2:15;
end;
theorem
L57: (for B30 being ComplexNormSpace holds (for B31 , B32 , B33 being  Lipschitzian (LinearOperator of B30 , B30) holds ( B31 * ( B32 * B33 ) ) = ( ( B31 * B32 ) * B33 )))
proof
let C49 being ComplexNormSpace;
let C50 , C51 , C52 being  Lipschitzian (LinearOperator of C49 , C49);
L58:
now
let C53 being (VECTOR of C49);
thus L59: ( ( C50 * ( C51 * C52 ) ) . C53 ) = ( C50 . ( ( C51 * C52 ) . C53 ) ) by L50
.= ( C50 . ( C51 . ( C52 . C53 ) ) ) by L50
.= ( ( C50 * C51 ) . ( C52 . C53 ) ) by FUNCT_2:15
.= ( ( ( C50 * C51 ) * C52 ) . C53 ) by L50;
end;
thus L60: thesis by L58 , FUNCT_2:63;
end;
theorem
L61: (for B34 being ComplexNormSpace holds (for B35 being  Lipschitzian (LinearOperator of B34 , B34) holds (( B35 * ( id (the carrier of B34) ) ) = B35 & ( ( id (the carrier of B34) ) * B35 ) = B35)))
proof
let C54 being ComplexNormSpace;
reconsider D6 = ( id (the carrier of C54) ) as  Lipschitzian (LinearOperator of C54 , C54) by L40;
let C55 being  Lipschitzian (LinearOperator of C54 , C54);
L62:
now
let C56 being (VECTOR of C54);
thus L63: ( ( ( id (the carrier of C54) ) * C55 ) . C56 ) = ( ( D6 * C55 ) . C56 )
.= ( D6 . ( C55 . C56 ) ) by L50
.= ( C55 . C56 ) by FUNCT_1:18;
end;
L64:
now
let C57 being (VECTOR of C54);
thus L65: ( ( C55 * ( id (the carrier of C54) ) ) . C57 ) = ( ( C55 * D6 ) . C57 )
.= ( C55 . ( D6 . C57 ) ) by L50
.= ( C55 . C57 ) by FUNCT_1:18;
end;
thus L66: thesis by L64 , L62 , FUNCT_2:63;
end;
theorem
L67: (for B36 being ComplexNormSpace holds (for B37 , B38 , B39 being (Element of ( BoundedLinearOperators (B36 , B36) )) holds ( B37 * ( B38 * B39 ) ) = ( ( B37 * B38 ) * B39 )))
proof
let C58 being ComplexNormSpace;
let C59 , C60 , C61 being (Element of ( BoundedLinearOperators (C58 , C58) ));
L68: ( modetrans (( C60 * C61 ) , C58 , C58) ) = ( ( modetrans (C60 , C58 , C58) ) * ( modetrans (C61 , C58 , C58) ) ) by CLOPBAN1:def 9;
L69: ( ( modetrans (C59 , C58 , C58) ) * ( modetrans (( C60 * C61 ) , C58 , C58) ) ) = ( ( ( modetrans (C59 , C58 , C58) ) * ( modetrans (C60 , C58 , C58) ) ) * ( modetrans (C61 , C58 , C58) ) ) by L68 , L57;
thus L70: thesis by L69 , CLOPBAN1:def 9;
end;
theorem
L71: (for B40 being ComplexNormSpace holds (for B41 being (Element of ( BoundedLinearOperators (B40 , B40) )) holds (( B41 * ( FuncUnit B40 ) ) = B41 & ( ( FuncUnit B40 ) * B41 ) = B41)))
proof
let C62 being ComplexNormSpace;
let C63 being (Element of ( BoundedLinearOperators (C62 , C62) ));
L72: ( id (the carrier of C62) ) is  Lipschitzian  Lipschitzian  Lipschitzian  Lipschitzian (LinearOperator of C62 , C62) by L40;
L73: ( id (the carrier of C62) ) is (Element of ( BoundedLinearOperators (C62 , C62) )) by L72 , CLOPBAN1:def 7;
L74: ( modetrans (( id (the carrier of C62) ) , C62 , C62) ) = ( id (the carrier of C62) ) by L73 , CLOPBAN1:def 9;
thus L75: ( C63 * ( FuncUnit C62 ) ) = ( modetrans (C63 , C62 , C62) ) by L74 , L61
.= C63 by CLOPBAN1:def 9;
thus L76: ( ( FuncUnit C62 ) * C63 ) = ( modetrans (C63 , C62 , C62) ) by L74 , L61
.= C63 by CLOPBAN1:def 9;
end;
theorem
L77: (for B42 being ComplexNormSpace holds (for B43 , B44 , B45 being (Element of ( BoundedLinearOperators (B42 , B42) )) holds ( B43 * ( B44 + B45 ) ) = ( ( B43 * B44 ) + ( B43 * B45 ) )))
proof
let C64 being ComplexNormSpace;
let C65 , C66 , C67 being (Element of ( BoundedLinearOperators (C64 , C64) ));
set D7 = ( C_NormSpace_of_BoundedLinearOperators (C64 , C64) );
set D8 = ( Add_ (( BoundedLinearOperators (C64 , C64) ) , ( C_VectorSpace_of_LinearOperators (C64 , C64) )) );
set D9 = ( modetrans (C65 , C64 , C64) );
set D10 = ( modetrans (C66 , C64 , C64) );
set D11 = ( modetrans (C67 , C64 , C64) );
set D12 = ( modetrans (( C66 + C67 ) , C64 , C64) );
L78: ( D8 . (( D9 * D10 ) , ( D9 * D11 )) ) = ( D9 * D12 )
proof
reconsider D13 = ( D9 * D11 ) as (VECTOR of D7) by CLOPBAN1:def 7;
reconsider D14 = ( D9 * D10 ) as (VECTOR of D7) by CLOPBAN1:def 7;
reconsider D15 = ( D9 * D12 ) as (VECTOR of D7) by CLOPBAN1:def 7;
reconsider D16 = C67 as (VECTOR of D7);
reconsider D17 = C66 as (VECTOR of D7);
L79: (D17 = D10 & D16 = D11) by CLOPBAN1:def 9;
L80: (for B46 being (VECTOR of C64) holds ( ( D9 * D12 ) . B46 ) = ( ( ( D9 * D10 ) . B46 ) + ( ( D9 * D11 ) . B46 ) ))
proof
let C68 being (VECTOR of C64);
L81: (( C66 + C67 ) = ( D17 + D16 ) & ( modetrans (( C66 + C67 ) , C64 , C64) ) = ( C66 + C67 )) by CLOPBAN1:def 9;
L82: ( D12 . C68 ) = ( ( D10 . C68 ) + ( D11 . C68 ) ) by L81 , L79 , CLOPBAN1:34;
thus L83: ( ( D9 * D12 ) . C68 ) = ( D9 . ( D12 . C68 ) ) by L50
.= ( ( D9 . ( D10 . C68 ) ) + ( D9 . ( D11 . C68 ) ) ) by L82 , VECTSP_1:def 20
.= ( ( ( D9 * D10 ) . C68 ) + ( D9 . ( D11 . C68 ) ) ) by L50
.= ( ( ( D9 * D10 ) . C68 ) + ( ( D9 * D11 ) . C68 ) ) by L50;
end;
L84: D15 = ( D14 + D13 ) by L80 , CLOPBAN1:34;
thus L85: thesis by L84;
end;
thus L86: thesis by L78;
end;
theorem
L87: (for B47 being ComplexNormSpace holds (for B48 , B49 , B50 being (Element of ( BoundedLinearOperators (B47 , B47) )) holds ( ( B49 + B50 ) * B48 ) = ( ( B49 * B48 ) + ( B50 * B48 ) )))
proof
let C69 being ComplexNormSpace;
let C70 , C71 , C72 being (Element of ( BoundedLinearOperators (C69 , C69) ));
set D18 = ( C_NormSpace_of_BoundedLinearOperators (C69 , C69) );
set D19 = ( Add_ (( BoundedLinearOperators (C69 , C69) ) , ( C_VectorSpace_of_LinearOperators (C69 , C69) )) );
set D20 = ( modetrans (C70 , C69 , C69) );
set D21 = ( modetrans (C71 , C69 , C69) );
set D22 = ( modetrans (C72 , C69 , C69) );
set D23 = ( modetrans (( C71 + C72 ) , C69 , C69) );
L88: ( D19 . (( D21 * D20 ) , ( D22 * D20 )) ) = ( D23 * D20 )
proof
reconsider D24 = ( D22 * D20 ) as (VECTOR of D18) by CLOPBAN1:def 7;
reconsider D25 = ( D21 * D20 ) as (VECTOR of D18) by CLOPBAN1:def 7;
reconsider D26 = ( D23 * D20 ) as (VECTOR of D18) by CLOPBAN1:def 7;
reconsider D27 = C72 as (VECTOR of D18);
reconsider D28 = C71 as (VECTOR of D18);
L89: (D28 = D21 & D27 = D22) by CLOPBAN1:def 9;
L90: (for B51 being (VECTOR of C69) holds ( ( D23 * D20 ) . B51 ) = ( ( ( D21 * D20 ) . B51 ) + ( ( D22 * D20 ) . B51 ) ))
proof
let C73 being (VECTOR of C69);
L91: (( C71 + C72 ) = ( D28 + D27 ) & ( modetrans (( C71 + C72 ) , C69 , C69) ) = ( C71 + C72 )) by CLOPBAN1:def 9;
L92: ( D23 . ( D20 . C73 ) ) = ( ( D21 . ( D20 . C73 ) ) + ( D22 . ( D20 . C73 ) ) ) by L91 , L89 , CLOPBAN1:34;
thus L93: ( ( D23 * D20 ) . C73 ) = ( D23 . ( D20 . C73 ) ) by L50
.= ( ( ( D21 * D20 ) . C73 ) + ( D22 . ( D20 . C73 ) ) ) by L92 , L50
.= ( ( ( D21 * D20 ) . C73 ) + ( ( D22 * D20 ) . C73 ) ) by L50;
end;
L94: D26 = ( D25 + D24 ) by L90 , CLOPBAN1:34;
thus L95: thesis by L94;
end;
thus L96: thesis by L88;
end;
theorem
L97: (for B52 being ComplexNormSpace holds (for B53 , B54 being (Element of ( BoundedLinearOperators (B52 , B52) )) holds (for B55 , B56 being Complex holds ( ( B55 * B56 ) * ( B53 * B54 ) ) = ( ( B55 * B53 ) * ( B56 * B54 ) ))))
proof
let C74 being ComplexNormSpace;
let C75 , C76 being (Element of ( BoundedLinearOperators (C74 , C74) ));
let C77 , C78 being Complex;
set D29 = ( C_NormSpace_of_BoundedLinearOperators (C74 , C74) );
set D30 = ( Mult_ (( BoundedLinearOperators (C74 , C74) ) , ( C_VectorSpace_of_LinearOperators (C74 , C74) )) );
set D31 = ( modetrans (C75 , C74 , C74) );
set D32 = ( modetrans (C76 , C74 , C74) );
set D33 = ( modetrans (( C77 * C75 ) , C74 , C74) );
set D34 = ( modetrans (( C78 * C76 ) , C74 , C74) );
L98: ( D30 . (( C77 * C78 ) , ( D31 * D32 )) ) = ( D33 * D34 )
proof
reconsider D35 = ( D33 * D34 ) as (VECTOR of D29) by CLOPBAN1:def 7;
reconsider D36 = ( D31 * D32 ) as (VECTOR of D29) by CLOPBAN1:def 7;
reconsider D37 = C75 , D38 = C76 as (VECTOR of D29);
L99: D38 = D32 by CLOPBAN1:def 9;
L100: D37 = D31 by CLOPBAN1:def 9;
L101: (for B57 being (VECTOR of C74) holds ( ( D33 * D34 ) . B57 ) = ( ( C77 * C78 ) * ( ( D31 * D32 ) . B57 ) ))
proof
let C79 being (VECTOR of C74);
set D39 = ( C78 * ( D32 . C79 ) );
L102: (( C77 * C75 ) = ( C77 * D37 ) & ( modetrans (( C77 * C75 ) , C74 , C74) ) = ( C77 * C75 )) by CLOPBAN1:def 9;
L103: ( D33 . D39 ) = ( C77 * ( D31 . D39 ) ) by L102 , L100 , CLOPBAN1:35;
L104: (( C78 * C76 ) = ( C78 * D38 ) & ( modetrans (( C78 * C76 ) , C74 , C74) ) = ( C78 * C76 )) by CLOPBAN1:def 9;
L105: ( D34 . C79 ) = ( C78 * ( D32 . C79 ) ) by L104 , L99 , CLOPBAN1:35;
thus L106: ( ( D33 * D34 ) . C79 ) = ( D33 . ( D34 . C79 ) ) by L50
.= ( C77 * ( C78 * ( D31 . ( D32 . C79 ) ) ) ) by L103 , L105 , CLOPBAN1:def 3
.= ( ( C77 * C78 ) * ( D31 . ( D32 . C79 ) ) ) by CLVECT_1:def 4
.= ( ( C77 * C78 ) * ( ( D31 * D32 ) . C79 ) ) by L50;
end;
L107: D35 = ( ( C77 * C78 ) * D36 ) by L101 , CLOPBAN1:35;
thus L108: thesis by L107;
end;
thus L109: thesis by L98;
end;
theorem
L110: (for B58 being ComplexNormSpace holds (for B59 , B60 being (Element of ( BoundedLinearOperators (B58 , B58) )) holds (for B61 being Complex holds ( B61 * ( B59 * B60 ) ) = ( ( B61 * B59 ) * B60 ))))
proof
let C80 being ComplexNormSpace;
let C81 , C82 being (Element of ( BoundedLinearOperators (C80 , C80) ));
let C83 being Complex;
set D40 = CLSStruct (# ( BoundedLinearOperators (C80 , C80) ) , ( Zero_ (( BoundedLinearOperators (C80 , C80) ) , ( C_VectorSpace_of_LinearOperators (C80 , C80) )) ) , ( Add_ (( BoundedLinearOperators (C80 , C80) ) , ( C_VectorSpace_of_LinearOperators (C80 , C80) )) ) , ( Mult_ (( BoundedLinearOperators (C80 , C80) ) , ( C_VectorSpace_of_LinearOperators (C80 , C80) )) ) #);
reconsider D41 = C82 as (Element of D40);
L111: ( ( 1r ) * C82 ) = ( ( 1r ) * D41 )
.= C82 by CLVECT_1:def 5;
L112: ( C83 * ( C81 * C82 ) ) = ( ( C83 * ( 1r ) ) * ( C81 * C82 ) ) by COMPLEX1:def 4
.= ( ( C83 * C81 ) * ( ( 1r ) * C82 ) ) by L97;
thus L113: thesis by L112 , L111;
end;
definition
let C84 being ComplexNormSpace;
func Ring_of_BoundedLinearOperators C84 -> doubleLoopStr equals 
doubleLoopStr (# ( BoundedLinearOperators (C84 , C84) ) , ( Add_ (( BoundedLinearOperators (C84 , C84) ) , ( C_VectorSpace_of_LinearOperators (C84 , C84) )) ) , ( FuncMult C84 ) , ( FuncUnit C84 ) , ( Zero_ (( BoundedLinearOperators (C84 , C84) ) , ( C_VectorSpace_of_LinearOperators (C84 , C84) )) ) #);
correctness;
end;
registration
let C85 being ComplexNormSpace;
cluster ( Ring_of_BoundedLinearOperators C85 ) -> non  empty  strict;
coherence;
end;
L116:
now
let C86 being ComplexNormSpace;
set D42 = ( Ring_of_BoundedLinearOperators C86 );
let C87 , C88 being (Element of D42);
reconsider D43 = C87 as (Element of ( BoundedLinearOperators (C86 , C86) ));
assume L117: C88 = ( FuncUnit C86 );
thus L118: ( C87 * C88 ) = ( D43 * ( FuncUnit C86 ) ) by L117 , L31
.= C87 by L71;
thus L119: ( C88 * C87 ) = ( ( FuncUnit C86 ) * D43 ) by L117 , L31
.= C87 by L71;
end;
registration
let C89 being ComplexNormSpace;
cluster ( Ring_of_BoundedLinearOperators C89 ) ->  unital;
coherence
proof
reconsider D44 = ( FuncUnit C89 ) as (Element of ( Ring_of_BoundedLinearOperators C89 ));
take D44;
thus L120: thesis by L116;
end;
end;
theorem
L122: (for B62 being ComplexNormSpace holds (for B63 , B64 , B65 being (Element of ( Ring_of_BoundedLinearOperators B62 )) holds (( B63 + B64 ) = ( B64 + B63 ) & ( ( B63 + B64 ) + B65 ) = ( B63 + ( B64 + B65 ) ) & ( B63 + ( 0. ( Ring_of_BoundedLinearOperators B62 ) ) ) = B63 & B63 is  right_complementable & ( ( B63 * B64 ) * B65 ) = ( B63 * ( B64 * B65 ) ) & ( B63 * ( 1. ( Ring_of_BoundedLinearOperators B62 ) ) ) = B63 & ( ( 1. ( Ring_of_BoundedLinearOperators B62 ) ) * B63 ) = B63 & ( B63 * ( B64 + B65 ) ) = ( ( B63 * B64 ) + ( B63 * B65 ) ) & ( ( B64 + B65 ) * B63 ) = ( ( B64 * B63 ) + ( B65 * B63 ) ))))
proof
let C90 being ComplexNormSpace;
let C91 , C92 , C93 being (Element of ( Ring_of_BoundedLinearOperators C90 ));
set D45 = ( Ring_of_BoundedLinearOperators C90 );
set D46 = ( BoundedLinearOperators (C90 , C90) );
set D47 = ( Add_ (( BoundedLinearOperators (C90 , C90) ) , ( C_VectorSpace_of_LinearOperators (C90 , C90) )) );
set D48 = ( FuncMult C90 );
set D49 = ( FuncUnit C90 );
set D50 = CLSStruct (# ( BoundedLinearOperators (C90 , C90) ) , ( Zero_ (( BoundedLinearOperators (C90 , C90) ) , ( C_VectorSpace_of_LinearOperators (C90 , C90) )) ) , ( Add_ (( BoundedLinearOperators (C90 , C90) ) , ( C_VectorSpace_of_LinearOperators (C90 , C90) )) ) , ( Mult_ (( BoundedLinearOperators (C90 , C90) ) , ( C_VectorSpace_of_LinearOperators (C90 , C90) )) ) #);
reconsider D51 = C91 , D52 = C92 , D53 = C93 as (Element of D50);
thus L123: ( C91 + C92 ) = ( D51 + D52 )
.= ( C92 + C91 ) by RLVECT_1:2;
thus L124: ( ( C91 + C92 ) + C93 ) = ( ( D51 + D52 ) + D53 )
.= ( D51 + ( D52 + D53 ) ) by RLVECT_1:def 3
.= ( C91 + ( C92 + C93 ) );
thus L125: ( C91 + ( 0. D45 ) ) = ( D51 + ( 0. D50 ) )
.= C91 by RLVECT_1:def 4;
thus L126: (ex B66 being (Element of D45) st ( C91 + B66 ) = ( 0. D45 ))
proof
consider C94 being (Element of D50) such that L127: ( D51 + C94 ) = ( 0. D50 ) by ALGSTR_0:def 11;
reconsider D54 = C94 as (Element of D45);
take D54;
thus L128: thesis by L127;
end;

reconsider D55 = C91 , D56 = C92 , D57 = C93 as (Element of D46);
thus L129: ( ( C91 * C92 ) * C93 ) = ( D48 . (( D55 * D56 ) , D57) ) by L31
.= ( ( D55 * D56 ) * D57 ) by L31
.= ( D55 * ( D56 * D57 ) ) by L67
.= ( D48 . (D55 , ( D56 * D57 )) ) by L31
.= ( C91 * ( C92 * C93 ) ) by L31;
thus L130: ( C91 * ( 1. D45 ) ) = ( D55 * D49 ) by L31
.= C91 by L71;
thus L131: ( ( 1. D45 ) * C91 ) = ( D49 * D55 ) by L31
.= C91 by L71;
thus L132: ( C91 * ( C92 + C93 ) ) = ( D55 * ( D56 + D57 ) ) by L31
.= ( ( D55 * D56 ) + ( D55 * D57 ) ) by L77
.= ( D47 . (( D55 * D56 ) , ( D48 . (D55 , D57) )) ) by L31
.= ( ( C91 * C92 ) + ( C91 * C93 ) ) by L31;
thus L133: ( ( C92 + C93 ) * C91 ) = ( ( D56 + D57 ) * D55 ) by L31
.= ( ( D56 * D55 ) + ( D57 * D55 ) ) by L87
.= ( D47 . (( D56 * D55 ) , ( D48 . (D57 , D55) )) ) by L31
.= ( ( C92 * C91 ) + ( C93 * C91 ) ) by L31;
end;
theorem
L134: (for B67 being ComplexNormSpace holds ( Ring_of_BoundedLinearOperators B67 ) is Ring)
proof
let C95 being ComplexNormSpace;
L135: (for B68 , B69 , B70 being (Element of ( Ring_of_BoundedLinearOperators C95 )) holds (( B68 + B69 ) = ( B69 + B68 ) & ( ( B68 + B69 ) + B70 ) = ( B68 + ( B69 + B70 ) ) & ( B68 + ( 0. ( Ring_of_BoundedLinearOperators C95 ) ) ) = B68 & B68 is  right_complementable & ( ( B68 * B69 ) * B70 ) = ( B68 * ( B69 * B70 ) ) & ( B68 * ( 1. ( Ring_of_BoundedLinearOperators C95 ) ) ) = B68 & ( ( 1. ( Ring_of_BoundedLinearOperators C95 ) ) * B68 ) = B68 & ( B68 * ( B69 + B70 ) ) = ( ( B68 * B69 ) + ( B68 * B70 ) ) & ( ( B69 + B70 ) * B68 ) = ( ( B69 * B68 ) + ( B70 * B68 ) ))) by L122;
thus L136: thesis by L135 , ALGSTR_0:def 16 , GROUP_1:def 3 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , VECTSP_1:def 6 , VECTSP_1:def 7;
end;
registration
let C96 being ComplexNormSpace;
cluster ( Ring_of_BoundedLinearOperators C96 ) ->  Abelian  add-associative  right_zeroed  right_complementable  associative  well-unital  distributive;
coherence by L134;
end;
definition
let C97 being ComplexNormSpace;
func C_Algebra_of_BoundedLinearOperators C97 -> ComplexAlgebraStr equals 
ComplexAlgebraStr (# ( BoundedLinearOperators (C97 , C97) ) , ( FuncMult C97 ) , ( Add_ (( BoundedLinearOperators (C97 , C97) ) , ( C_VectorSpace_of_LinearOperators (C97 , C97) )) ) , ( Mult_ (( BoundedLinearOperators (C97 , C97) ) , ( C_VectorSpace_of_LinearOperators (C97 , C97) )) ) , ( FuncUnit C97 ) , ( Zero_ (( BoundedLinearOperators (C97 , C97) ) , ( C_VectorSpace_of_LinearOperators (C97 , C97) )) ) #);
correctness;
end;
registration
let C98 being ComplexNormSpace;
cluster ( C_Algebra_of_BoundedLinearOperators C98 ) -> non  empty  strict;
coherence;
end;
L140:
now
let C99 being ComplexNormSpace;
set D58 = ( C_Algebra_of_BoundedLinearOperators C99 );
let C100 , C101 being (Element of D58);
reconsider D59 = C100 as (Element of ( BoundedLinearOperators (C99 , C99) ));
assume L141: C101 = ( FuncUnit C99 );
thus L142: ( C100 * C101 ) = ( D59 * ( FuncUnit C99 ) ) by L141 , L31
.= C100 by L71;
thus L143: ( C101 * C100 ) = ( ( FuncUnit C99 ) * D59 ) by L141 , L31
.= C100 by L71;
end;
registration
let C102 being ComplexNormSpace;
cluster ( C_Algebra_of_BoundedLinearOperators C102 ) ->  unital;
coherence
proof
reconsider D60 = ( FuncUnit C102 ) as (Element of ( C_Algebra_of_BoundedLinearOperators C102 ));
take D60;
thus L144: thesis by L140;
end;
end;
theorem
L146: (for B71 being ComplexNormSpace holds (for B72 , B73 , B74 being (Element of ( C_Algebra_of_BoundedLinearOperators B71 )) holds (for B75 , B76 being Complex holds (( B72 + B73 ) = ( B73 + B72 ) & ( ( B72 + B73 ) + B74 ) = ( B72 + ( B73 + B74 ) ) & ( B72 + ( 0. ( C_Algebra_of_BoundedLinearOperators B71 ) ) ) = B72 & B72 is  right_complementable & ( ( B72 * B73 ) * B74 ) = ( B72 * ( B73 * B74 ) ) & ( B72 * ( 1. ( C_Algebra_of_BoundedLinearOperators B71 ) ) ) = B72 & ( ( 1. ( C_Algebra_of_BoundedLinearOperators B71 ) ) * B72 ) = B72 & ( B72 * ( B73 + B74 ) ) = ( ( B72 * B73 ) + ( B72 * B74 ) ) & ( ( B73 + B74 ) * B72 ) = ( ( B73 * B72 ) + ( B74 * B72 ) ) & ( B75 * ( B72 * B73 ) ) = ( ( B75 * B72 ) * B73 ) & ( B75 * ( B72 + B73 ) ) = ( ( B75 * B72 ) + ( B75 * B73 ) ) & ( ( B75 + B76 ) * B72 ) = ( ( B75 * B72 ) + ( B76 * B72 ) ) & ( ( B75 * B76 ) * B72 ) = ( B75 * ( B76 * B72 ) ) & ( ( B75 * B76 ) * ( B72 * B73 ) ) = ( ( B75 * B72 ) * ( B76 * B73 ) )))))
proof
let C103 being ComplexNormSpace;
let C104 , C105 , C106 being (Element of ( C_Algebra_of_BoundedLinearOperators C103 ));
let C107 , C108 being Complex;
set D61 = ( C_Algebra_of_BoundedLinearOperators C103 );
set D62 = ( BoundedLinearOperators (C103 , C103) );
set D63 = ( Add_ (( BoundedLinearOperators (C103 , C103) ) , ( C_VectorSpace_of_LinearOperators (C103 , C103) )) );
set D64 = ( FuncMult C103 );
set D65 = ( FuncUnit C103 );
set D66 = CLSStruct (# ( BoundedLinearOperators (C103 , C103) ) , ( Zero_ (( BoundedLinearOperators (C103 , C103) ) , ( C_VectorSpace_of_LinearOperators (C103 , C103) )) ) , ( Add_ (( BoundedLinearOperators (C103 , C103) ) , ( C_VectorSpace_of_LinearOperators (C103 , C103) )) ) , ( Mult_ (( BoundedLinearOperators (C103 , C103) ) , ( C_VectorSpace_of_LinearOperators (C103 , C103) )) ) #);
reconsider D67 = C104 , D68 = C105 , D69 = C106 as (Element of D66);
thus L147: ( C104 + C105 ) = ( D67 + D68 )
.= ( C105 + C104 ) by RLVECT_1:2;
thus L148: ( ( C104 + C105 ) + C106 ) = ( ( D67 + D68 ) + D69 )
.= ( D67 + ( D68 + D69 ) ) by RLVECT_1:def 3
.= ( C104 + ( C105 + C106 ) );
thus L149: ( C104 + ( 0. D61 ) ) = ( D67 + ( 0. D66 ) )
.= C104 by RLVECT_1:def 4;
thus L150: (ex B77 being (Element of D61) st ( C104 + B77 ) = ( 0. D61 ))
proof
consider C109 being (Element of D66) such that L151: ( D67 + C109 ) = ( 0. D66 ) by ALGSTR_0:def 11;
reconsider D70 = C109 as (Element of D61);
take D70;
thus L152: thesis by L151;
end;

reconsider D71 = C104 , D72 = C105 , D73 = C106 as (Element of D62);
thus L153: ( ( C104 * C105 ) * C106 ) = ( D64 . (( D71 * D72 ) , D73) ) by L31
.= ( ( D71 * D72 ) * D73 ) by L31
.= ( D71 * ( D72 * D73 ) ) by L67
.= ( D64 . (D71 , ( D72 * D73 )) ) by L31
.= ( C104 * ( C105 * C106 ) ) by L31;
thus L154: ( C104 * ( 1. D61 ) ) = ( D71 * D65 ) by L31
.= C104 by L71;
thus L155: ( ( 1. D61 ) * C104 ) = ( D65 * D71 ) by L31
.= C104 by L71;
thus L156: ( C104 * ( C105 + C106 ) ) = ( D71 * ( D72 + D73 ) ) by L31
.= ( ( D71 * D72 ) + ( D71 * D73 ) ) by L77
.= ( D63 . (( D71 * D72 ) , ( D64 . (D71 , D73) )) ) by L31
.= ( ( C104 * C105 ) + ( C104 * C106 ) ) by L31;
thus L157: ( ( C105 + C106 ) * C104 ) = ( ( D72 + D73 ) * D71 ) by L31
.= ( ( D72 * D71 ) + ( D73 * D71 ) ) by L87
.= ( D63 . (( D72 * D71 ) , ( D64 . (D73 , D71) )) ) by L31
.= ( ( C105 * C104 ) + ( C106 * C104 ) ) by L31;
thus L158: ( C107 * ( C104 * C105 ) ) = ( C107 * ( D71 * D72 ) ) by L31
.= ( ( C107 * D71 ) * D72 ) by L110
.= ( ( C107 * C104 ) * C105 ) by L31;
thus L159: ( C107 * ( C104 + C105 ) ) = ( C107 * ( D67 + D68 ) )
.= ( ( C107 * D67 ) + ( C107 * D68 ) ) by CLVECT_1:def 2
.= ( ( C107 * C104 ) + ( C107 * C105 ) );
thus L160: ( ( C107 + C108 ) * C104 ) = ( ( C107 + C108 ) * D67 )
.= ( ( C107 * D67 ) + ( C108 * D67 ) ) by CLVECT_1:def 3
.= ( ( C107 * C104 ) + ( C108 * C104 ) );
thus L161: ( ( C107 * C108 ) * C104 ) = ( ( C107 * C108 ) * D67 )
.= ( C107 * ( C108 * D67 ) ) by CLVECT_1:def 4
.= ( C107 * ( C108 * C104 ) );
thus L162: ( ( C107 * C108 ) * ( C104 * C105 ) ) = ( ( C107 * C108 ) * ( D71 * D72 ) ) by L31
.= ( ( C107 * D71 ) * ( C108 * D72 ) ) by L97
.= ( ( C107 * C104 ) * ( C108 * C105 ) ) by L31;
end;
definition
mode ComplexBLAlgebra
 is  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative non  empty ComplexAlgebraStr;
end;
registration
let C110 being ComplexNormSpace;
cluster ( C_Algebra_of_BoundedLinearOperators C110 ) ->  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative;
coherence
proof
set D74 = ( C_Algebra_of_BoundedLinearOperators C110 );
set D75 = ( FuncMult C110 );
set D76 = ( FuncUnit C110 );
set D77 = ( BoundedLinearOperators (C110 , C110) );
set D78 = ( Add_ (( BoundedLinearOperators (C110 , C110) ) , ( C_VectorSpace_of_LinearOperators (C110 , C110) )) );
set D79 = CLSStruct (# ( BoundedLinearOperators (C110 , C110) ) , ( Zero_ (( BoundedLinearOperators (C110 , C110) ) , ( C_VectorSpace_of_LinearOperators (C110 , C110) )) ) , ( Add_ (( BoundedLinearOperators (C110 , C110) ) , ( C_VectorSpace_of_LinearOperators (C110 , C110) )) ) , ( Mult_ (( BoundedLinearOperators (C110 , C110) ) , ( C_VectorSpace_of_LinearOperators (C110 , C110) )) ) #);
thus L164: D74 is  Abelian
proof
let C111 , C112 being (Element of D74);
reconsider D80 = C111 , D81 = C112 as (Element of D79);
thus L165: ( C111 + C112 ) = ( D80 + D81 )
.= ( C112 + C111 ) by RLVECT_1:2;
end;

thus L166: D74 is  add-associative
proof
let C113 , C114 , C115 being (Element of D74);
reconsider D82 = C113 , D83 = C114 , D84 = C115 as (Element of D79);
thus L167: ( ( C113 + C114 ) + C115 ) = ( ( D82 + D83 ) + D84 )
.= ( D82 + ( D83 + D84 ) ) by RLVECT_1:def 3
.= ( C113 + ( C114 + C115 ) );
end;

thus L168: D74 is  right_zeroed
proof
let C116 being (Element of D74);
reconsider D85 = C116 as (Element of D79);
thus L169: ( C116 + ( 0. D74 ) ) = ( D85 + ( 0. D79 ) )
.= C116 by RLVECT_1:def 4;
end;

thus L170: D74 is  right_complementable
proof
let C117 being (Element of D74);
reconsider D86 = C117 as (Element of D79);
consider C118 being (Element of D79) such that L171: ( D86 + C118 ) = ( 0. D79 ) by ALGSTR_0:def 11;
reconsider D87 = C118 as (Element of D74);
take D87;
thus L172: thesis by L171;
end;

thus L173: D74 is  associative
proof
let C119 , C120 , C121 being (Element of D74);
reconsider D88 = C119 , D89 = C120 , D90 = C121 as (Element of D77);
thus L174: ( ( C119 * C120 ) * C121 ) = ( D75 . (( D88 * D89 ) , D90) ) by L31
.= ( ( D88 * D89 ) * D90 ) by L31
.= ( D88 * ( D89 * D90 ) ) by L67
.= ( D75 . (D88 , ( D89 * D90 )) ) by L31
.= ( C119 * ( C120 * C121 ) ) by L31;
end;

thus L175: D74 is  right_unital
proof
let C122 being (Element of D74);
reconsider D91 = C122 as (Element of D77);
thus L176: ( C122 * ( 1. D74 ) ) = ( D91 * D76 ) by L31
.= C122 by L71;
end;

thus L177: D74 is  right-distributive
proof
let C123 , C124 , C125 being (Element of D74);
reconsider D92 = C123 , D93 = C124 , D94 = C125 as (Element of D77);
thus L178: ( C123 * ( C124 + C125 ) ) = ( D92 * ( D93 + D94 ) ) by L31
.= ( ( D92 * D93 ) + ( D92 * D94 ) ) by L77
.= ( D78 . (( D92 * D93 ) , ( D75 . (D92 , D94) )) ) by L31
.= ( ( C123 * C124 ) + ( C123 * C125 ) ) by L31;
end;

thus L179: D74 is  vector-distributive
proof
let C126 being Complex;
let C127 , C128 being (Element of D74);
reconsider D95 = C127 , D96 = C128 as (Element of D79);
thus L180: ( C126 * ( C127 + C128 ) ) = ( C126 * ( D95 + D96 ) )
.= ( ( C126 * D95 ) + ( C126 * D96 ) ) by CLVECT_1:def 2
.= ( ( C126 * C127 ) + ( C126 * C128 ) );
end;

thus L181: D74 is  scalar-distributive
proof
let C129 , C130 being Complex;
let C131 being (Element of D74);
reconsider D97 = C131 as (Element of D79);
thus L182: ( ( C129 + C130 ) * C131 ) = ( ( C129 + C130 ) * D97 )
.= ( ( C129 * D97 ) + ( C130 * D97 ) ) by CLVECT_1:def 3
.= ( ( C129 * C131 ) + ( C130 * C131 ) );
end;

thus L183: D74 is  scalar-associative
proof
let C132 , C133 being Complex;
let C134 being (Element of D74);
reconsider D98 = C134 as (Element of D79);
thus L184: ( ( C132 * C133 ) * C134 ) = ( ( C132 * C133 ) * D98 )
.= ( C132 * ( C133 * D98 ) ) by CLVECT_1:def 4
.= ( C132 * ( C133 * C134 ) );
end;

let C135 , C136 being (Element of D74);
let C137 being (Element of ( COMPLEX ));
reconsider D99 = C135 , D100 = C136 as (Element of D77);
thus L185: ( C137 * ( C135 * C136 ) ) = ( C137 * ( D99 * D100 ) ) by L31
.= ( ( C137 * D99 ) * D100 ) by L110
.= ( ( C137 * C135 ) * C136 ) by L31;
end;
end;
theorem
L187: (for B78 being ComplexNormSpace holds ( C_Algebra_of_BoundedLinearOperators B78 ) is ComplexBLAlgebra);
registration
cluster ( Complex_l1_Space ) ->  complete;
coherence
proof
thus L188: (for B79 being (sequence of ( Complex_l1_Space )) holds (B79 is  Cauchy_sequence_by_Norm implies B79 is  convergent)) by CSSPACE3:9;
end;
end;
registration
cluster ( Complex_l1_Space ) -> non  trivial;
coherence
proof
reconsider D101 = ( ( 1 / 2 ) + ( ( 0 ) * ( <i> ) ) ) as (Element of ( COMPLEX ));
reconsider D102 = ( D101 GeoSeq ) as Complex_Sequence;
L190: (for B80 being (Element of ( NAT )) holds ( |. D102 .| . ( B80 + 1 ) ) = ( ( |. D102 .| . B80 ) * |. D101 .| ))
proof
let C138 being (Element of ( NAT ));
L191: ( |. D102 .| . ( C138 + 1 ) ) = |. ( D102 . ( C138 + 1 ) ) .| by VALUED_1:18
.= |. ( ( D102 . C138 ) * D101 ) .| by COMSEQ_3:def 1
.= ( |. ( D102 . C138 ) .| * |. D101 .| ) by COMPLEX1:65;
thus L192: thesis by L191 , VALUED_1:18;
end;
L193: ( |. D102 .| . ( 0 ) ) = |. ( D102 . ( 0 ) ) .| by VALUED_1:18
.= 1 by COMPLEX1:48 , COMSEQ_3:def 1;
L194: (|. D101 .| = ( 1 / 2 ) & |. D102 .| = ( |. D101 .| GeoSeq )) by L193 , L190 , ABSVALUE:def 1 , PREPOWER:3;
L195: |. D102 .| is  summable by L194 , SERIES_1:24;
L196: D102 is  absolutely_summable by L195 , COMSEQ_3:def 9;
L197: ( seq_id D102 ) is  absolutely_summable by L196 , CSSPACE:1;
reconsider D103 = D102 as (VECTOR of ( Complex_l1_Space )) by L197 , CSSPACE3:6;
L198: ( ( seq_id D103 ) . ( 0 ) ) = ( D102 . ( 0 ) ) by CSSPACE:1
.= 1 by COMPLEX1:def 4 , COMSEQ_3:def 1;
L199: D103 <> ( CZeroseq ) by L198 , CSSPACE:def 6;
thus L200: thesis by L199 , CSSPACE3:6 , STRUCT_0:def 18;
end;
end;
registration
cluster non  trivial for ComplexBanachSpace;
existence
proof
take ( Complex_l1_Space );
thus L202: thesis;
end;
end;
theorem
L204: (for B81 being non  trivial ComplexNormSpace holds (ex B82 being (VECTOR of B81) st ||. B82 .|| = 1))
proof
let C139 being non  trivial ComplexNormSpace;
consider C140 being (VECTOR of C139) such that L205: C140 <> ( 0. C139 ) by STRUCT_0:def 18;
reconsider D104 = ( ||. C140 .|| + ( ( 0 ) * ( <i> ) ) ) as (Element of ( COMPLEX )) by XCMPLX_0:def 2;
take D105 = ( ( D104 " ) * C140 );
L206: ||. C140 .|| <> ( 0 ) by L205 , NORMSP_0:def 5;
L207: ( 0 ) < ||. C140 .|| by L206 , CLVECT_1:105;
L208: |. ( D104 " ) .| = |. ( ( 1r ) * ( D104 " ) ) .| by COMPLEX1:def 4
.= |. ( ( 1r ) / D104 ) .| by XCMPLX_0:def 9
.= ( 1 / |. D104 .| ) by COMPLEX1:48 , COMPLEX1:67
.= ( 1 * ( |. D104 .| " ) ) by XCMPLX_0:def 9
.= ( ||. C140 .|| " ) by L207 , ABSVALUE:def 1;
thus L209: ||. D105 .|| = ( |. ( D104 " ) .| * ||. C140 .|| ) by CLVECT_1:def 13
.= 1 by L206 , L208 , XCMPLX_0:def 7;
end;
theorem
L210: (for B83 being non  trivial ComplexNormSpace holds ( ( BoundedLinearOperatorsNorm (B83 , B83) ) . ( id (the carrier of B83) ) ) = 1)
proof
let C141 being non  trivial ComplexNormSpace;
consider C142 being (VECTOR of C141) such that L211: ||. C142 .|| = 1 by L204;
reconsider D106 = ( id (the carrier of C141) ) as  Lipschitzian (LinearOperator of C141 , C141) by L40;
L212:
now
let C143 being Real;
assume L213: C143 in ( PreNorms D106 );
L214: (ex B84 being (VECTOR of C141) st (C143 = ||. ( D106 . B84 ) .|| & ||. B84 .|| <= 1)) by L213;
thus L215: C143 <= 1 by L214 , FUNCT_1:18;
end;
L216: ( D106 . C142 ) = C142 by FUNCT_1:18;
L217: 1 in { ||. ( D106 . B85 ) .|| where B85 is (VECTOR of C141) : ||. B85 .|| <= 1 } by L216 , L211;
L218: ( PreNorms D106 ) is non  empty  bounded_above by CLOPBAN1:26;
L219: 1 <= ( upper_bound ( PreNorms D106 ) ) by L218 , L217 , SEQ_4:def 1;
L220: ((for B86 being  real number holds (B86 in ( PreNorms D106 ) implies B86 <= 1)) implies ( upper_bound ( PreNorms D106 ) ) <= 1) by SEQ_4:45;
L221: ( upper_bound ( PreNorms D106 ) ) = 1 by L220 , L212 , L219 , XXREAL_0:1;
thus L222: thesis by L221 , CLOPBAN1:29;
end;
definition
struct (ComplexAlgebraStr , CNORMSTR) Normed_Complex_AlgebraStr(# carrier -> set , multF , addF -> (BinOp of the carrier) , Mult -> (Function of [: ( COMPLEX ) , the carrier :] , the carrier) , OneF , ZeroF -> (Element of the carrier) , normF -> (Function of the carrier , ( REAL )) #);
end;
registration
cluster non  empty for Normed_Complex_AlgebraStr;
existence
proof
set D107 = the non  empty set;
set D108 = the (BinOp of D107);
set D109 = the (BinOp of D107);
set D110 = the (Function of [: ( COMPLEX ) , D107 :] , D107);
set D111 = the (Element of D107);
set D112 = the (Element of D107);
set D113 = the (Function of D107 , ( REAL ));
take Normed_Complex_AlgebraStr (# D107 , D108 , D109 , D110 , D111 , D112 , D113 #);
thus L224: (the carrier of Normed_Complex_AlgebraStr (# D107 , D108 , D109 , D110 , D111 , D112 , D113 #)) is non  empty;
end;
end;
definition
let C144 being ComplexNormSpace;
func C_Normed_Algebra_of_BoundedLinearOperators C144 -> Normed_Complex_AlgebraStr equals 
Normed_Complex_AlgebraStr (# ( BoundedLinearOperators (C144 , C144) ) , ( FuncMult C144 ) , ( Add_ (( BoundedLinearOperators (C144 , C144) ) , ( C_VectorSpace_of_LinearOperators (C144 , C144) )) ) , ( Mult_ (( BoundedLinearOperators (C144 , C144) ) , ( C_VectorSpace_of_LinearOperators (C144 , C144) )) ) , ( FuncUnit C144 ) , ( Zero_ (( BoundedLinearOperators (C144 , C144) ) , ( C_VectorSpace_of_LinearOperators (C144 , C144) )) ) , ( BoundedLinearOperatorsNorm (C144 , C144) ) #);
correctness;
end;
registration
let C145 being ComplexNormSpace;
cluster ( C_Normed_Algebra_of_BoundedLinearOperators C145 ) -> non  empty  strict;
coherence;
end;
L228:
now
let C146 being ComplexNormSpace;
set D114 = ( C_Normed_Algebra_of_BoundedLinearOperators C146 );
let C147 , C148 being (Element of D114);
reconsider D115 = C147 as (Element of ( BoundedLinearOperators (C146 , C146) ));
assume L229: C148 = ( FuncUnit C146 );
thus L230: ( C147 * C148 ) = ( D115 * ( FuncUnit C146 ) ) by L229 , L31
.= C147 by L71;
thus L231: ( C148 * C147 ) = ( ( FuncUnit C146 ) * D115 ) by L229 , L31
.= C147 by L71;
end;
registration
let C149 being ComplexNormSpace;
cluster ( C_Normed_Algebra_of_BoundedLinearOperators C149 ) ->  unital;
coherence
proof
reconsider D116 = ( FuncUnit C149 ) as (Element of ( C_Normed_Algebra_of_BoundedLinearOperators C149 ));
take D116;
thus L232: thesis by L228;
end;
end;
theorem
L234: (for B87 being ComplexNormSpace holds (for B88 , B89 , B90 being (Element of ( C_Normed_Algebra_of_BoundedLinearOperators B87 )) holds (for B91 , B92 being Complex holds (( B88 + B89 ) = ( B89 + B88 ) & ( ( B88 + B89 ) + B90 ) = ( B88 + ( B89 + B90 ) ) & ( B88 + ( 0. ( C_Normed_Algebra_of_BoundedLinearOperators B87 ) ) ) = B88 & B88 is  right_complementable & ( ( B88 * B89 ) * B90 ) = ( B88 * ( B89 * B90 ) ) & ( B88 * ( 1. ( C_Normed_Algebra_of_BoundedLinearOperators B87 ) ) ) = B88 & ( ( 1. ( C_Normed_Algebra_of_BoundedLinearOperators B87 ) ) * B88 ) = B88 & ( B88 * ( B89 + B90 ) ) = ( ( B88 * B89 ) + ( B88 * B90 ) ) & ( ( B89 + B90 ) * B88 ) = ( ( B89 * B88 ) + ( B90 * B88 ) ) & ( B91 * ( B88 * B89 ) ) = ( ( B91 * B88 ) * B89 ) & ( ( B91 * B92 ) * ( B88 * B89 ) ) = ( ( B91 * B88 ) * ( B92 * B89 ) ) & ( B91 * ( B88 + B89 ) ) = ( ( B91 * B88 ) + ( B91 * B89 ) ) & ( ( B91 + B92 ) * B88 ) = ( ( B91 * B88 ) + ( B92 * B88 ) ) & ( ( B91 * B92 ) * B88 ) = ( B91 * ( B92 * B88 ) ) & ( ( 1r ) * B88 ) = B88))))
proof
let C150 being ComplexNormSpace;
let C151 , C152 , C153 being (Element of ( C_Normed_Algebra_of_BoundedLinearOperators C150 ));
let C154 , C155 being Complex;
set D117 = ( C_Normed_Algebra_of_BoundedLinearOperators C150 );
set D118 = ( BoundedLinearOperators (C150 , C150) );
set D119 = ( Add_ (( BoundedLinearOperators (C150 , C150) ) , ( C_VectorSpace_of_LinearOperators (C150 , C150) )) );
set D120 = ( FuncMult C150 );
set D121 = ( FuncUnit C150 );
set D122 = CLSStruct (# ( BoundedLinearOperators (C150 , C150) ) , ( Zero_ (( BoundedLinearOperators (C150 , C150) ) , ( C_VectorSpace_of_LinearOperators (C150 , C150) )) ) , ( Add_ (( BoundedLinearOperators (C150 , C150) ) , ( C_VectorSpace_of_LinearOperators (C150 , C150) )) ) , ( Mult_ (( BoundedLinearOperators (C150 , C150) ) , ( C_VectorSpace_of_LinearOperators (C150 , C150) )) ) #);
reconsider D123 = C151 , D124 = C152 , D125 = C153 as (Element of D122);
thus L235: ( C151 + C152 ) = ( D123 + D124 )
.= ( C152 + C151 ) by RLVECT_1:2;
thus L236: ( ( C151 + C152 ) + C153 ) = ( ( D123 + D124 ) + D125 )
.= ( D123 + ( D124 + D125 ) ) by RLVECT_1:def 3
.= ( C151 + ( C152 + C153 ) );
thus L237: ( C151 + ( 0. D117 ) ) = ( D123 + ( 0. D122 ) )
.= C151 by RLVECT_1:def 4;
thus L238: (ex B93 being (Element of D117) st ( C151 + B93 ) = ( 0. D117 ))
proof
consider C156 being (Element of D122) such that L239: ( D123 + C156 ) = ( 0. D122 ) by ALGSTR_0:def 11;
reconsider D126 = C156 as (Element of D117);
take D126;
thus L240: thesis by L239;
end;

reconsider D127 = C151 , D128 = C152 , D129 = C153 as (Element of D118);
thus L241: ( ( C151 * C152 ) * C153 ) = ( D120 . (( D127 * D128 ) , D129) ) by L31
.= ( ( D127 * D128 ) * D129 ) by L31
.= ( D127 * ( D128 * D129 ) ) by L67
.= ( D120 . (D127 , ( D128 * D129 )) ) by L31
.= ( C151 * ( C152 * C153 ) ) by L31;
thus L242: ( C151 * ( 1. D117 ) ) = ( D127 * D121 ) by L31
.= C151 by L71;
thus L243: ( ( 1. D117 ) * C151 ) = ( D121 * D127 ) by L31
.= C151 by L71;
thus L244: ( C151 * ( C152 + C153 ) ) = ( D127 * ( D128 + D129 ) ) by L31
.= ( ( D127 * D128 ) + ( D127 * D129 ) ) by L77
.= ( D119 . (( D127 * D128 ) , ( D120 . (D127 , D129) )) ) by L31
.= ( ( C151 * C152 ) + ( C151 * C153 ) ) by L31;
thus L245: ( ( C152 + C153 ) * C151 ) = ( ( D128 + D129 ) * D127 ) by L31
.= ( ( D128 * D127 ) + ( D129 * D127 ) ) by L87
.= ( D119 . (( D128 * D127 ) , ( D120 . (D129 , D127) )) ) by L31
.= ( ( C152 * C151 ) + ( C153 * C151 ) ) by L31;
thus L246: ( C154 * ( C151 * C152 ) ) = ( C154 * ( D127 * D128 ) ) by L31
.= ( ( C154 * D127 ) * D128 ) by L110
.= ( ( C154 * C151 ) * C152 ) by L31;
thus L247: ( ( C154 * C155 ) * ( C151 * C152 ) ) = ( ( C154 * C155 ) * ( D127 * D128 ) ) by L31
.= ( ( C154 * D127 ) * ( C155 * D128 ) ) by L97
.= ( ( C154 * C151 ) * ( C155 * C152 ) ) by L31;
thus L248: ( C154 * ( C151 + C152 ) ) = ( C154 * ( D123 + D124 ) )
.= ( ( C154 * D123 ) + ( C154 * D124 ) ) by CLVECT_1:def 2
.= ( ( C154 * C151 ) + ( C154 * C152 ) );
thus L249: ( ( C154 + C155 ) * C151 ) = ( ( C154 + C155 ) * D123 )
.= ( ( C154 * D123 ) + ( C155 * D123 ) ) by CLVECT_1:def 3
.= ( ( C154 * C151 ) + ( C155 * C151 ) );
thus L250: ( ( C154 * C155 ) * C151 ) = ( ( C154 * C155 ) * D123 )
.= ( C154 * ( C155 * D123 ) ) by CLVECT_1:def 4
.= ( C154 * ( C155 * C151 ) );
thus L251: ( ( 1r ) * C151 ) = ( ( 1r ) * D123 )
.= C151 by CLVECT_1:def 5;
end;
theorem
L252: (for B94 being ComplexNormSpace holds ( C_Normed_Algebra_of_BoundedLinearOperators B94 ) is  reflexive  discerning  ComplexNormSpace-like  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative  vector-distributive  scalar-distributive  scalar-associative  scalar-unital)
proof
let C157 being ComplexNormSpace;
set D130 = ( C_Normed_Algebra_of_BoundedLinearOperators C157 );
set D131 = ( C_NormSpace_of_BoundedLinearOperators (C157 , C157) );
thus L253: D130 is  reflexive
proof
thus L254: ||. ( 0. D130 ) .|| = ||. ( 0. D131 ) .||
.= ( 0 );
end;

thus L255: D130 is  discerning
proof
let C158 being (Point of D130);
reconsider D132 = C158 as (Point of D131);
assume L256: ||. C158 .|| = ( 0 );
L257: ||. D132 .|| = ( 0 ) by L256;
L258: D132 = ( 0. D131 ) by L257 , NORMSP_0:def 5;
thus L259: C158 = ( 0. D130 ) by L258;
end;

thus L260: D130 is  ComplexNormSpace-like
proof
let C159 , C160 being (Point of D130);
let C161 being Complex;
reconsider D133 = C159 , D134 = C160 as (Point of D131);
L261: ||. D133 .|| = ||. C159 .||;
thus L262: ||. ( C161 * C159 ) .|| = ||. ( C161 * D133 ) .||
.= ( |. C161 .| * ||. C159 .|| ) by L261 , CLVECT_1:def 13;
L263: (||. ( C159 + C160 ) .|| = ||. ( D133 + D134 ) .|| & ( ||. D133 .|| + ||. D134 .|| ) = ( ||. C159 .|| + ||. C160 .|| ));
thus L264: thesis by L263 , CLVECT_1:def 13;
end;

set D135 = D130;
L265: D130 is  right_complementable
proof
let C162 being (Element of D130);
thus L266: thesis by L234;
end;
L267: ((for B95 , B96 being Complex holds (for B97 being (VECTOR of D135) holds ( ( B95 + B96 ) * B97 ) = ( ( B95 * B97 ) + ( B96 * B97 ) ))) & (for B98 , B99 being Complex holds (for B100 being (VECTOR of D135) holds ( ( B98 * B99 ) * B100 ) = ( B98 * ( B99 * B100 ) )))) by L234;
L268: ((for B101 , B102 , B103 being (Element of D130) holds (for B104 , B105 being (Element of ( COMPLEX )) holds (( B101 + B102 ) = ( B102 + B101 ) & ( ( B101 + B102 ) + B103 ) = ( B101 + ( B102 + B103 ) ) & ( B101 + ( 0. D130 ) ) = B101 & B101 is  right_complementable & ( ( B101 * B102 ) * B103 ) = ( B101 * ( B102 * B103 ) ) & ( B101 * ( 1. D130 ) ) = B101 & ( ( 1. D130 ) * B101 ) = B101 & ( B101 * ( B102 + B103 ) ) = ( ( B101 * B102 ) + ( B101 * B103 ) ) & ( ( B102 + B103 ) * B101 ) = ( ( B102 * B101 ) + ( B103 * B101 ) ) & ( B104 * ( B101 * B102 ) ) = ( ( B104 * B101 ) * B102 ) & ( ( B104 * B105 ) * ( B101 * B102 ) ) = ( ( B104 * B101 ) * ( B105 * B102 ) ) & ( B104 * ( B101 + B102 ) ) = ( ( B104 * B101 ) + ( B104 * B102 ) ) & ( ( B104 + B105 ) * B101 ) = ( ( B104 * B101 ) + ( B105 * B101 ) ) & ( ( B104 * B105 ) * B101 ) = ( B104 * ( B105 * B101 ) ) & ( ( 1r ) * B101 ) = B101))) & (for B106 being Complex holds (for B107 , B108 being (VECTOR of D135) holds ( B106 * ( B107 + B108 ) ) = ( ( B106 * B107 ) + ( B106 * B108 ) )))) by L234;
thus L269: thesis by L268 , L265 , L267 , CFUNCDOM:def 9 , CLVECT_1:def 2 , CLVECT_1:def 3 , CLVECT_1:def 4 , CLVECT_1:def 5 , GROUP_1:def 3 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , VECTSP_1:def 2 , VECTSP_1:def 4;
end;
registration
cluster  reflexive  discerning  ComplexNormSpace-like  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  scalar-distributive  scalar-associative  vector-associative  scalar-unital  strict for non  empty non  empty non  empty non  empty Normed_Complex_AlgebraStr;
existence
proof
set D136 = the ComplexNormSpace;
take ( C_Normed_Algebra_of_BoundedLinearOperators D136 );
thus L270: thesis by L252;
end;
end;
definition
mode Normed_Complex_Algebra
 is  reflexive  discerning  ComplexNormSpace-like  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  vector-associative  scalar-distributive  scalar-associative  scalar-unital non  empty Normed_Complex_AlgebraStr;
end;
registration
let C163 being ComplexNormSpace;
cluster ( C_Normed_Algebra_of_BoundedLinearOperators C163 ) ->  reflexive  discerning  ComplexNormSpace-like  Abelian  add-associative  right_zeroed  right_complementable  associative  right_unital  right-distributive  vector-distributive  scalar-associative  vector-associative  scalar-distributive  scalar-unital;
correctness by L252;
end;
definition
let C164 being non  empty Normed_Complex_AlgebraStr;
attr C164 is  Banach_Algebra-like_1
means
(for B109 , B110 being (Element of C164) holds ||. ( B109 * B110 ) .|| <= ( ||. B109 .|| * ||. B110 .|| ));
attr C164 is  Banach_Algebra-like_2
means
:L274: ||. ( 1. C164 ) .|| = 1;
attr C164 is  Banach_Algebra-like_3
means
(for B111 being Complex holds (for B112 , B113 being (Element of C164) holds ( B111 * ( B112 * B113 ) ) = ( B112 * ( B111 * B113 ) )));
end;
definition
let C165 being Normed_Complex_Algebra;
attr C165 is  Banach_Algebra-like
means
:L276: C165 is  Banach_Algebra-like_1  Banach_Algebra-like_2  Banach_Algebra-like_3  left_unital  left-distributive  complete;
end;
registration
cluster  Banach_Algebra-like ->  Banach_Algebra-like_1  Banach_Algebra-like_2  Banach_Algebra-like_3  left-distributive  left_unital  complete for Normed_Complex_Algebra;
coherence by L276;
cluster  Banach_Algebra-like_1  Banach_Algebra-like_2  Banach_Algebra-like_3  left-distributive  left_unital  complete ->  Banach_Algebra-like for Normed_Complex_Algebra;
coherence by L276;
end;
registration
let C166 being non  trivial ComplexBanachSpace;
cluster ( C_Normed_Algebra_of_BoundedLinearOperators C166 ) ->  Banach_Algebra-like;
coherence
proof
set D137 = ( BoundedLinearOperatorsNorm (C166 , C166) );
set D138 = ( FuncUnit C166 );
set D139 = ( FuncMult C166 );
set D140 = ( Add_ (( BoundedLinearOperators (C166 , C166) ) , ( C_VectorSpace_of_LinearOperators (C166 , C166) )) );
set D141 = ( C_NormSpace_of_BoundedLinearOperators (C166 , C166) );
set D142 = ( BoundedLinearOperators (C166 , C166) );
set D143 = ( C_Normed_Algebra_of_BoundedLinearOperators C166 );
thus L279: D143 is  Banach_Algebra-like_1
proof
let C167 , C168 being (Point of D143);
reconsider D144 = C167 , D145 = C168 as (Element of D142);
L280: ( ( D137 . ( modetrans (D144 , C166 , C166) ) ) * ( D137 . ( modetrans (D145 , C166 , C166) ) ) ) = ( ( D137 . D144 ) * ( D137 . ( modetrans (D145 , C166 , C166) ) ) ) by CLOPBAN1:def 9
.= ( ||. C167 .|| * ||. C168 .|| ) by CLOPBAN1:def 9;
L281: ||. ( C167 * C168 ) .|| = ( D137 . ( D144 * D145 ) ) by L31
.= ( D137 . ( ( modetrans (D144 , C166 , C166) ) * ( modetrans (D145 , C166 , C166) ) ) );
thus L282: thesis by L281 , L280 , L7;
end;

L283: ||. ( 1. D143 ) .|| = 1 by L210;
thus L284: D143 is  Banach_Algebra-like_2 by L283 , L274;
thus L285: D143 is  Banach_Algebra-like_3
proof
let C169 being Complex;
let C170 , C171 being (Element of D143);
thus L286: ( C169 * ( C170 * C171 ) ) = ( ( ( 1r ) * C169 ) * ( C170 * C171 ) ) by COMPLEX1:def 4
.= ( ( ( 1r ) * C170 ) * ( C169 * C171 ) ) by L234
.= ( C170 * ( C169 * C171 ) ) by L234;
end;

thus L287: D143 is  left_unital
proof
let C172 being (Element of D143);
reconsider D146 = C172 as (Element of D142);
thus L288: ( ( 1. D143 ) * C172 ) = ( D138 * D146 ) by L31
.= C172 by L71;
end;

thus L289: D143 is  left-distributive
proof
let C173 , C174 , C175 being (Element of D143);
reconsider D147 = C173 , D148 = C174 , D149 = C175 as (Element of D142);
thus L290: ( ( C174 + C175 ) * C173 ) = ( ( D148 + D149 ) * D147 ) by L31
.= ( ( D148 * D147 ) + ( D149 * D147 ) ) by L87
.= ( D140 . (( D148 * D147 ) , ( D139 . (D149 , D147) )) ) by L31
.= ( ( C174 * C173 ) + ( C175 * C173 ) ) by L31;
end;

L291:
now
let C176 being (sequence of D143);
assume that
L292: C176 is  Cauchy_sequence_by_Norm;
reconsider D150 = C176 as (sequence of D141);
L293:
now
let C177 being Real;
assume L294: C177 > ( 0 );
consider C178 being (Element of ( NAT )) such that L295: (for B114 , B115 being (Element of ( NAT )) holds ((B114 >= C178 & B115 >= C178) implies ||. ( ( C176 . B114 ) - ( C176 . B115 ) ) .|| < C177)) by L294 , L292 , CSSPACE3:8;
L296:
now
let C179 , C180 being (Element of ( NAT ));
assume that
L297: (C179 >= C178 & C180 >= C178);
L298: ||. ( ( D150 . C179 ) - ( D150 . C180 ) ) .|| = ( D137 . ( D140 . (( D150 . C179 ) , ( ( - ( 1r ) ) * ( D150 . C180 ) )) ) ) by CLVECT_1:3
.= ( D137 . ( ( C176 . C179 ) + ( ( - ( 1r ) ) * ( C176 . C180 ) ) ) )
.= ||. ( ( C176 . C179 ) - ( C176 . C180 ) ) .|| by CLVECT_1:3;
thus L299: ||. ( ( D150 . C179 ) - ( D150 . C180 ) ) .|| < C177 by L298 , L295 , L297;
end;
thus L300: (ex B116 being (Element of ( NAT )) st (for B117 , B118 being (Element of ( NAT )) holds ((B117 >= B116 & B118 >= B116) implies ||. ( ( D150 . B117 ) - ( D150 . B118 ) ) .|| < C177))) by L296;
end;
L301: D150 is  Cauchy_sequence_by_Norm by L293 , CSSPACE3:8;
L302: D150 is  convergent by L301 , CLOPBAN1:def 13;
consider C181 being (Point of D141) such that L303: (for B119 being Real holds (( 0 ) < B119 implies (ex B120 being (Element of ( NAT )) st (for B121 being (Element of ( NAT )) holds (B120 <= B121 implies ||. ( ( D150 . B121 ) - C181 ) .|| < B119))))) by L302 , CLVECT_1:def 15;
reconsider D151 = C181 as (Point of D143);
L304:
now
let C182 being Real;
assume L305: ( 0 ) < C182;
consider C183 being (Element of ( NAT )) such that L306: (for B122 being (Element of ( NAT )) holds (C183 <= B122 implies ||. ( ( D150 . B122 ) - C181 ) .|| < C182)) by L305 , L303;
L307:
now
let C184 being (Element of ( NAT ));
assume that
L308: C183 <= C184;
L309: ||. ( ( D150 . C184 ) - C181 ) .|| = ( D137 . ( D140 . (( D150 . C184 ) , ( ( - ( 1r ) ) * C181 )) ) ) by CLVECT_1:3
.= ( D137 . ( ( C176 . C184 ) + ( ( - ( 1r ) ) * D151 ) ) )
.= ||. ( ( C176 . C184 ) - D151 ) .|| by CLVECT_1:3;
thus L310: ||. ( ( C176 . C184 ) - D151 ) .|| < C182 by L309 , L306 , L308;
end;
thus L311: (ex B123 being (Element of ( NAT )) st (for B124 being (Element of ( NAT )) holds (B123 <= B124 implies ||. ( ( C176 . B124 ) - D151 ) .|| < C182))) by L307;
end;
thus L312: C176 is  convergent by L304 , CLVECT_1:def 15;
end;
thus L313: thesis by L291 , CLOPBAN1:def 13;
end;
end;
registration
cluster  Banach_Algebra-like for Normed_Complex_Algebra;
existence
proof
take ( C_Normed_Algebra_of_BoundedLinearOperators the non  trivial ComplexBanachSpace );
thus L315: thesis;
end;
end;
definition
mode Complex_Banach_Algebra
 is  Banach_Algebra-like Normed_Complex_Algebra;
end;
theorem
L318: (for B125 being ComplexNormSpace holds ( 1. ( Ring_of_BoundedLinearOperators B125 ) ) = ( FuncUnit B125 ));
theorem
L319: (for B126 being ComplexNormSpace holds ( 1. ( C_Algebra_of_BoundedLinearOperators B126 ) ) = ( FuncUnit B126 ));
theorem
L320: (for B127 being ComplexNormSpace holds ( 1. ( C_Normed_Algebra_of_BoundedLinearOperators B127 ) ) = ( FuncUnit B127 ));
