:: Composition of Machines, Instructions and Programs
::  by Andrzej Trybulec
::
:: Received May 20, 2010
:: Copyright (c) 2010-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, ORDINAL1, CARD_1,
      FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FINSET_1, NAT_1, AFINSQ_1,
      AMISTD_1, AMISTD_2, ARYTM_1, VALUED_1, PARTFUN1, ZFMISC_1, AMI_1,
      ARYTM_3, EXTPRO_1, PBOOLE, RECDEF_2, COMPOS_1, FINSEQ_1, UNIALG_1,
      CARD_5,
      RELOC, TURING_1, XXREAL_0, VALUED_0, SCMFSA_7, INT_1, SCMPDS_4, ORDINAL4,
      SCMFSA6A, SCMPDS_5;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, FUNCT_7, CARD_1, CARD_3, XXREAL_0, XCMPLX_0, RELAT_1, FUNCT_1,
      PARTFUN1, FINSET_1, NUMBERS, INT_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4,
      FINSEQ_1, FUNCT_2, DOMAIN_1, VALUED_0, VALUED_1, RECDEF_2, AFINSQ_1,
      STRUCT_0, COMPOS_0;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, RELSET_1, FUNCT_7,
      PRE_POLY, PBOOLE, AFINSQ_1, NAT_D, WELLORD2, STRUCT_0,
      COMPOS_0, XTUPLE_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, AFINSQ_1, VALUED_1, XCMPLX_0,
      PARTFUN1, NUMBERS, NAT_1, MEMBERED, FUNCT_7, CARD_1, XXREAL_2,
      ZFMISC_1, SUBSET_1, VALUED_0, XXREAL_0, ORDINAL4, ORDINAL5, COMPOS_0,
      XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions RELAT_1, FUNCOP_1, ORDINAL1, PBOOLE, PARTFUN1, MCART_1, ZFMISC_1,
      TARSKI, STRUCT_0, FUNCT_1, XBOOLE_0, NAT_1, FUNCT_4, NAT_D, AFINSQ_1,
      VALUED_1, CARD_3, COMPOS_0, XTUPLE_0;
 theorems ZFMISC_1, FUNCT_2, TARSKI, CARD_3, FINSEQ_1, FUNCT_4, FUNCOP_1,
      FINSET_1, FUNCT_1, GRFUNC_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1,
      ORDINAL1, MCART_1, PARTFUN1, RECDEF_2, CARD_1, AFINSQ_1, XREAL_1,
      VALUED_1, CARD_2, PRE_CIRC, XREAL_0, NAT_1, XXREAL_0, NAT_D, INT_1,
      WELLORD2, ENUMSET1, AFINSQ_2, FUNCT_5, COMPOS_0;
 schemes FRAENKEL, CLASSES1, FUNCT_7, DOMAIN_1;

begin
definition
struct COM-Struct(# InstructionsF -> Instructions #);
end;
definition
canceled 7;
func Trivial-COM ->  strict COM-Struct means 
:L2: (the InstructionsF of it) = { [ ( 0 ) , ( {} ) , ( {} ) ] };
existence
proof
take D1 = COM-Struct (# { [ ( 0 ) , ( {} ) , ( {} ) ] } #);
thus L3: thesis;
end;
uniqueness;
end;
definition
let C1 being COM-Struct;
mode Instruction of C1
 is (Element of (the InstructionsF of C1));
end;
definition
canceled 1;
let C2 being COM-Struct;
func halt C2 -> (Instruction of C2) equals 
( halt (the InstructionsF of C2) );
coherence;
end;
definition
let C3 being COM-Struct;
let C4 being (the InstructionsF of C3) -valued Function;
attr C4 is  halt-free
means
:L7: (not ( halt C3 ) in ( rng C4 ));
end;
begin
definition
let C5 being COM-Struct;
mode Instruction-Sequence of C5
 is (the InstructionsF of C5) -valued (ManySortedSet of ( NAT ));
end;
definition
let C6 being COM-Struct;
let C7 being (Instruction-Sequence of C6);
let C8 being Nat;
redefine func C7 . C8 -> (Instruction of C6);

coherence
proof
L10: C8 in ( NAT ) by ORDINAL1:def 12;
L11: ( dom C7 ) = ( NAT ) by PARTFUN1:def 2;
L12: ( C7 . C8 ) in ( rng C7 ) by L11 , L10 , FUNCT_1:3;
L13: ( rng C7 ) c= (the InstructionsF of C6) by RELAT_1:def 19;
thus L14: ( C7 . C8 ) is (Instruction of C6) by L13 , L12;
end;
end;
begin
definition
let C9 being COM-Struct;
let C10 being ( NAT ) -defined (the InstructionsF of C9) -valued Function;
let C11 being set;
pred C10 halts_at C11
means
:L16: (C11 in ( dom C10 ) & ( C10 . C11 ) = ( halt C9 ))
;end;
definition
let C12 being COM-Struct;
let C13 being (Instruction-Sequence of C12);
let C14 being Nat;
redefine pred C13 halts_at C14
means
( C13 . C14 ) = ( halt C12 )
;compatibility
proof
thus L18: (C13 halts_at C14 implies ( C13 . C14 ) = ( halt C12 )) by L16;
assume L19: ( C13 . C14 ) = ( halt C12 );
L20: C14 in ( NAT ) by ORDINAL1:def 12;
thus L21: C14 in ( dom C13 ) by L20 , PARTFUN1:def 2;
thus L22: ( C13 . C14 ) = ( halt C12 ) by L19;
end;
end;
begin
notation
let C15 being COM-Struct;
let C16 being (Instruction of C15);
synonym Load C16 for <%C16 %>;
end;
registration
let R13 being COM-Struct;
cluster  initial 1 -element ( NAT ) -defined (the InstructionsF of R13) -valued for Function;
existence
proof
set D2 = <% the (Instruction of R13) %>;
take D2;
thus L25: thesis;
end;
end;
definition
let C17 being COM-Struct;
mode preProgram of C17
 is  finite ( NAT ) -defined (the InstructionsF of C17) -valued Function;
end;
definition
let C18 being COM-Struct;
let C19 being non  empty (preProgram of C18);
attr C19 is  halt-ending
means
:L28: ( C19 . ( LastLoc C19 ) ) = ( halt C18 );
attr C19 is  unique-halt
means
:L29: (for B1 being Nat holds ((( C19 . B1 ) = ( halt C18 ) & B1 in ( dom C19 )) implies B1 = ( LastLoc C19 )));
end;
registration
let C20 being COM-Struct;
cluster  trivial  initial non  empty for (preProgram of C20);
existence
proof
reconsider D3 = <% ( halt C20 ) %> as  initial non  empty (preProgram of C20);
take D3;
thus L31: thesis;
end;
end;
definition
let C21 being COM-Struct;
mode Program of C21
 is  initial non  empty (preProgram of C21);
end;
canceled 1;
theorem
L34: (for B2 being (Element of (the InstructionsF of ( Trivial-COM ))) holds ( InsCode B2 ) = ( 0 ))
proof
let C22 being (Element of (the InstructionsF of ( Trivial-COM )));
L35: (the InstructionsF of ( Trivial-COM )) = { [ ( 0 ) , ( {} ) , ( {} ) ] } by L2;
L36: C22 = [ ( 0 ) , ( {} ) , ( {} ) ] by L35 , TARSKI:def 1;
thus L37: thesis by L36 , RECDEF_2:def 1;
end;
begin
definition
let C23 being COM-Struct;
func Stop C23 ->  finite (preProgram of C23) equals 
( Load ( halt C23 ) );
coherence;
end;
registration
let C24 being COM-Struct;
cluster ( Stop C24 ) ->  initial non  empty;
coherence;
end;
registration
let C25 being COM-Struct;
cluster ( Stop C25 ) ->  initial non  empty ( NAT ) -defined (the InstructionsF of C25) -valued  trivial;
coherence;
end;
L41:
now
let C26 being COM-Struct;
thus L42: ( dom ( Stop C26 ) ) = { ( 0 ) } by FUNCOP_1:13;
thus L43: ( 0 ) in ( dom ( Stop C26 ) ) by L42 , TARSKI:def 1;
end;
L44: (for B3 being COM-Struct holds ( ( card ( Stop B3 ) ) -' 1 ) = ( 0 ))
proof
let C27 being COM-Struct;
thus L45: ( ( card ( Stop C27 ) ) -' 1 ) = ( ( card ( Stop C27 ) ) - 1 ) by PRE_CIRC:20
.= ( 1 - 1 ) by AFINSQ_1:33
.= ( 0 );
end;
L46: (for B4 being COM-Struct holds ( LastLoc ( Stop B4 ) ) = ( 0 ))
proof
let C28 being COM-Struct;
L47: ( ( card ( Stop C28 ) ) -' 1 ) = ( 0 ) by L44;
thus L48: thesis by L47 , AFINSQ_1:70;
end;
registration
let C29 being COM-Struct;
cluster ( Stop C29 ) ->  halt-ending  unique-halt;
coherence
proof
thus L49: ( ( Stop C29 ) . ( LastLoc ( Stop C29 ) ) ) = ( ( ( 0 ) .--> ( halt C29 ) ) . ( 0 ) ) by L46
.= ( halt C29 ) by FUNCOP_1:72;
let C30 being Nat;
assume that
L50: ( ( Stop C29 ) . C30 ) = ( halt C29 );
assume L51: C30 in ( dom ( Stop C29 ) );
L52: C30 in { ( 0 ) } by L51 , L41;
L53: C30 = ( 0 ) by L52 , TARSKI:def 1;
thus L54: thesis by L53 , L46;
end;
end;
registration
let R13 being COM-Struct;
cluster  halt-ending  unique-halt  trivial for  initial non  empty  initial non  empty  initial non  empty  initial non  empty (preProgram of R13);
existence
proof
take D4 = ( Stop R13 );
thus L56: thesis;
end;
end;
definition
let R13 being COM-Struct;
mode MacroInstruction of R13
 is  halt-ending  unique-halt (Program of R13);
end;
registration
let C31 being COM-Struct;
cluster  initial non  empty for (preProgram of C31);
existence
proof
take ( Stop C31 );
thus L59: thesis;
end;
end;
theorem
L61: (for R13 being COM-Struct holds ( 0 ) in ( dom ( Stop R13 ) ))
proof
let R13 being COM-Struct;
L62: ( dom ( Stop R13 ) ) = 1 by AFINSQ_1:33;
thus L63: thesis by L62 , CARD_1:49 , TARSKI:def 1;
end;
theorem
L64: (for R13 being COM-Struct holds ( card ( Stop R13 ) ) = 1) by AFINSQ_1:33;
L65: (for R18 being Nat holds ( - 1 ) < R18);
L66: (for R18 being Nat holds (for B5 , B6 , B7 being (Element of ( NAT )) holds ((1 <= B5 & 2 <= B6) implies (R18 < ( B5 - 1 ) or (B5 <= R18 & R18 <= ( ( B5 + B6 ) - 3 )) or R18 = ( ( B5 + B6 ) - 2 ) or ( ( B5 + B6 ) - 2 ) < R18 or R18 = ( B5 - 1 )))))
proof
let R18 being Nat;
let C32 , C33 , C34 being (Element of ( NAT ));
assume that
L67: 1 <= C32
and
L68: 2 <= C33
and
L69: ( C32 - 1 ) <= R18
and
L70: (C32 > R18 or R18 > ( ( C32 + C33 ) - 3 ))
and
L71: R18 <> ( ( C32 + C33 ) - 2 )
and
L72: R18 <= ( ( C32 + C33 ) - 2 );
L73: ( C32 - 1 ) is (Element of ( NAT )) by L67 , INT_1:5;
L74:
now
per cases  by L70;
case L75: R18 < C32;
L76: R18 < ( ( C32 - 1 ) + 1 ) by L75;
thus L77: R18 <= ( C32 - 1 ) by L76 , L73 , NAT_1:13;
end;
case L78: ( ( C32 + C33 ) - 3 ) < R18;
L79: ( 1 + 2 ) <= ( C32 + C33 ) by L67 , L68 , XREAL_1:7;
L80: ( ( C32 + C33 ) - 3 ) is (Element of ( NAT )) by L79 , INT_1:5;
L81: R18 < ( ( ( C32 + C33 ) - 3 ) + 1 ) by L71 , L72 , XXREAL_0:1;
thus L82: R18 <= ( C32 - 1 ) by L81 , L78 , L80 , NAT_1:13;
end;
end;
thus L84: thesis by L74 , L69 , XXREAL_0:1;
end;
begin
theorem
L85: (for B8 being (Instruction of ( Trivial-COM )) holds ( JumpPart B8 ) = ( 0 ))
proof
let C35 being (Instruction of ( Trivial-COM ));
L86: (the InstructionsF of ( Trivial-COM )) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] } by L2;
L87: C35 = [ ( 0 ) , ( 0 ) , ( 0 ) ] by L86 , TARSKI:def 1;
thus L88: thesis by L87 , RECDEF_2:def 2;
end;
theorem
L89: (for B9 being (InsType of (the InstructionsF of ( Trivial-COM ))) holds ( JumpParts B9 ) = { ( 0 ) })
proof
let C36 being (InsType of (the InstructionsF of ( Trivial-COM )));
set D5 = { ( JumpPart B10 ) where B10 is (Instruction of ( Trivial-COM )) : ( InsCode B10 ) = C36 };
L90: { ( 0 ) } = D5
proof
thus L91:now
let C37 being set;
assume L92: C37 in { ( 0 ) };
L93: C37 = ( 0 ) by L92 , TARSKI:def 1;
L94: (the InstructionsF of ( Trivial-COM )) = { [ ( 0 ) , ( 0 ) , ( 0 ) ] } by L2;
L95: ( InsCodes (the InstructionsF of ( Trivial-COM )) ) = { ( 0 ) } by L94 , MCART_1:92;
L96: C36 = ( 0 ) by L95 , TARSKI:def 1;
L97: [ ( 0 ) , ( 0 ) , ( 0 ) ] = ( halt ( Trivial-COM ) );
reconsider D6 = [ ( 0 ) , ( 0 ) , ( 0 ) ] as (Instruction of ( Trivial-COM )) by L97;
L98: ( JumpPart D6 ) = ( 0 ) by L85;
L99: ( InsCode D6 ) = ( 0 ) by RECDEF_2:def 1;
thus L100: C37 in D5 by L99 , L93 , L96 , L98;
end;
let C38 being set;
assume L101: C38 in D5;
L102: (ex B11 being (Instruction of ( Trivial-COM )) st (C38 = ( JumpPart B11 ) & ( InsCode B11 ) = C36)) by L101;
L103: C38 = ( 0 ) by L102 , L85;
thus L104: thesis by L103 , TARSKI:def 1;
end;
thus L105: thesis by L90;
end;
registration
let C39 being COM-Struct;
cluster  trivial ->  unique-halt for non  empty  finite non  empty  finite non  empty  finite non  empty  finite (preProgram of C39);
coherence
proof
let C40 being non  empty non  empty  finite (preProgram of C39);
assume L106: C40 is  trivial;
let C41 being Nat;
assume that
L107: ( C40 . C41 ) = ( halt C39 )
and
L108: C41 in ( dom C40 );
consider C42 being set such that L109: C40 = { C42 } by L106 , ZFMISC_1:131;
L110: C42 in C40 by L109 , TARSKI:def 1;
consider C43 , C44 being set such that L111: [ C43 , C44 ] = C42 by L110 , RELAT_1:def 1;
L112: ( LastLoc C40 ) in ( dom C40 ) by VALUED_1:30;
L113: ( dom C40 ) = { C43 } by L109 , L111 , RELAT_1:9;
thus L114: C41 = C43 by L113 , L108 , TARSKI:def 1
.= ( LastLoc C40 ) by L112 , L113 , TARSKI:def 1;
end;
end;
canceled 1;
theorem
L116: (for R13 being COM-Struct holds (for B12 being (MacroInstruction of R13) holds (( card B12 ) = 1 implies B12 = ( Stop R13 ))))
proof
let R13 being COM-Struct;
let C45 being (MacroInstruction of R13);
assume L117: ( card C45 ) = 1;
consider C46 being set such that L118: C45 = { C46 } by L117 , CARD_2:42;
L119: C46 in C45 by L118 , TARSKI:def 1;
consider C47 , C48 being set such that L120: [ C47 , C48 ] = C46 by L119 , RELAT_1:def 1;
L121: ( dom C45 ) = { C47 } by L118 , L120 , RELAT_1:9;
L122: ( 0 ) in ( dom C45 ) by AFINSQ_1:65;
L123: C47 = ( 0 ) by L122 , L121;
L124: ( ( card C45 ) -' 1 ) = ( ( card C45 ) - 1 ) by PRE_CIRC:20
.= ( 0 ) by L117;
L125: ( LastLoc C45 ) = ( 0 ) by L124 , AFINSQ_1:70;
L126: ( C45 . ( 0 ) ) = ( halt R13 ) by L125 , L28;
L127: ( halt R13 ) in ( rng C45 ) by L126 , L122 , FUNCT_1:def 3;
L128: ( halt R13 ) in { C48 } by L127 , L118 , L120 , RELAT_1:9;
L129: C45 = { [ ( 0 ) , ( halt R13 ) ] } by L128 , L118 , L120 , L123 , TARSKI:def 1
.= ( ( 0 ) .--> ( halt R13 ) ) by FUNCT_4:82;
thus L130: thesis by L129;
end;
theorem
L131: (for B13 being COM-Struct holds ( LastLoc ( Stop B13 ) ) = ( 0 )) by L46;
begin
definition
canceled 4;
let C49 being COM-Struct;
let C50 being ( NAT ) -defined (the InstructionsF of C49) -valued  finite Function;
let C51 being Nat;
L132: ( dom C50 ) c= ( NAT ) by RELAT_1:def 18;
func IncAddr (C50 , C51) -> ( NAT ) -defined (the InstructionsF of C49) -valued  finite Function means 
:L133: (( dom it ) = ( dom C50 ) & (for B14 being Nat holds (B14 in ( dom C50 ) implies ( it . B14 ) = ( IncAddr (( C50 /. B14 ) , C51) ))));
existence
proof
defpred S1[ set , set ] means (ex B15 being (Element of ( NAT )) st ($1 = B15 & $2 = ( IncAddr (( C50 /. B15 ) , C51) )));
L134: (for B16 being set holds (B16 in ( dom C50 ) implies (ex B17 being set st S1[ B16 , B17 ])))
proof
let C52 being set;
assume L135: C52 in ( dom C50 );
reconsider D7 = C52 as (Element of ( NAT )) by L135 , L132;
consider C53 being Nat such that L136: D7 = C53;
take ( IncAddr (( C50 /. C53 ) , C51) );
thus L137: thesis by L136;
end;
consider C54 being Function such that L138: ( dom C54 ) = ( dom C50 ) and L139: (for B18 being set holds (B18 in ( dom C50 ) implies S1[ B18 , ( C54 . B18 ) ])) from CLASSES1:sch 1(L134);
L140: ( rng C54 ) c= (the InstructionsF of C49)
proof
let C55 being set;
assume L141: C55 in ( rng C54 );
consider C56 being set such that L142: C56 in ( dom C54 ) and L143: C55 = ( C54 . C56 ) by L141 , FUNCT_1:def 3;
L144: S1[ C56 , ( C54 . C56 ) ] by L142 , L139 , L138;
thus L145: C55 in (the InstructionsF of C49) by L144 , L143;
end;
reconsider D8 = C54 as ( NAT ) -defined (the InstructionsF of C49) -valued  finite Function by L132 , L138 , L140 , FINSET_1:10 , RELAT_1:def 18 , RELAT_1:def 19;
take D8;
thus L146: ( dom D8 ) = ( dom C50 ) by L138;
let C57 being Nat;
assume L147: C57 in ( dom C50 );
L148: (ex B19 being (Element of ( NAT )) st (C57 = B19 & ( D8 . C57 ) = ( IncAddr (( C50 /. B19 ) , C51) ))) by L147 , L139;
thus L149: thesis by L148;
end;
uniqueness
proof
let C58 , C59 being ( NAT ) -defined (the InstructionsF of C49) -valued  finite Function;
assume that
L150: ( dom C58 ) = ( dom C50 )
and
L151: (for B20 being Nat holds (B20 in ( dom C50 ) implies ( C58 . B20 ) = ( IncAddr (( C50 /. B20 ) , C51) )))
and
L152: ( dom C59 ) = ( dom C50 )
and
L153: (for B21 being Nat holds (B21 in ( dom C50 ) implies ( C59 . B21 ) = ( IncAddr (( C50 /. B21 ) , C51) )));
L154: (for B22 being set holds (B22 in ( dom C50 ) implies ( C58 . B22 ) = ( C59 . B22 )))
proof
let C60 being set;
assume L155: C60 in ( dom C50 );
reconsider D9 = C60 as (Element of ( NAT )) by L155 , L132;
consider C61 being Nat such that L156: D9 = C61;
reconsider D10 = C61 as (Element of ( NAT )) by ORDINAL1:def 12;
thus L157: ( C58 . C60 ) = ( IncAddr (( C50 /. D10 ) , C51) ) by L151 , L155 , L156
.= ( C59 . C60 ) by L153 , L155 , L156;
end;
thus L158: thesis by L154 , L150 , L152 , FUNCT_1:2;
end;
end;
registration
let C62 being COM-Struct;
let C63 being ( NAT ) -defined (the InstructionsF of C62) -valued  finite Function;
let C64 being Nat;
cluster ( IncAddr (C63 , C64) ) -> ( NAT ) -defined (the InstructionsF of C62) -valued;
coherence;
end;
registration
let C65 being COM-Struct;
let C66 being  empty (the InstructionsF of C65) -valued ( NAT ) -defined  finite Function;
let C67 being Nat;
cluster ( IncAddr (C66 , C67) ) ->  empty;
coherence
proof
assume L161: (not thesis);
reconsider D11 = ( IncAddr (C66 , C67) ) as non  empty Function by L161;
L162: ( dom D11 ) <> ( {} );
L163: ( dom ( IncAddr (C66 , C67) ) ) = ( dom C66 ) by L133;
thus L164: thesis by L163 , L162;
end;
end;
registration
let C68 being COM-Struct;
let C69 being non  empty (the InstructionsF of C68) -valued ( NAT ) -defined  finite Function;
let C70 being Nat;
cluster ( IncAddr (C69 , C70) ) -> non  empty;
coherence
proof
L166: ( dom ( IncAddr (C69 , C70) ) ) = ( dom C69 ) by L133;
thus L167: thesis by L166;
end;
end;
registration
let C71 being COM-Struct;
let C72 being  initial ( NAT ) -defined (the InstructionsF of C71) -valued  finite Function;
let C73 being Nat;
cluster ( IncAddr (C72 , C73) ) ->  initial;
coherence
proof
L169: ( dom ( IncAddr (C72 , C73) ) ) = ( dom C72 ) by L133;
thus L170: thesis by L169 , AFINSQ_1:67;
end;
end;
canceled 6;
registration
let C74 being COM-Struct;
let C75 being ( NAT ) -defined (the InstructionsF of C74) -valued  finite Function;
reduce ( IncAddr (C75 , ( 0 )) ) to C75;
reducibility
proof
L172: (for B23 being Nat holds (B23 in ( dom C75 ) implies ( C75 . B23 ) = ( IncAddr (( C75 /. B23 ) , ( 0 )) )))
proof
let C76 being Nat;
assume L173: C76 in ( dom C75 );
L174: ( C75 /. C76 ) = ( C75 . C76 ) by L173 , PARTFUN1:def 6;
thus L175: thesis by L174 , COMPOS_0:3;
end;
thus L176: thesis by L172 , L133;
end;
end;
theorem
L178: (for B24 being COM-Struct holds (for B25 being ( NAT ) -defined (the InstructionsF of B24) -valued  finite Function holds ( IncAddr (B25 , ( 0 )) ) = B25));
theorem
L179: (for R18 being Nat holds (for R19 being Nat holds (for B26 being COM-Struct holds (for B27 being ( NAT ) -defined (the InstructionsF of B26) -valued  finite Function holds ( IncAddr (( IncAddr (B27 , R18) ) , R19) ) = ( IncAddr (B27 , ( R18 + R19 )) )))))
proof
let R18 being Nat;
let R19 being Nat;
let C77 being COM-Struct;
let C78 being ( NAT ) -defined (the InstructionsF of C77) -valued  finite Function;
L180: ( dom ( IncAddr (( IncAddr (C78 , R18) ) , R19) ) ) = ( dom ( IncAddr (C78 , R18) ) ) by L133
.= ( dom C78 ) by L133;
L181: ( dom ( IncAddr (C78 , ( R18 + R19 )) ) ) = ( dom C78 ) by L133;
L182: (for B28 being set holds (B28 in ( dom C78 ) implies ( ( IncAddr (( IncAddr (C78 , R18) ) , R19) ) . B28 ) = ( ( IncAddr (C78 , ( R18 + R19 )) ) . B28 )))
proof
let C79 being set;
assume that
L183: C79 in ( dom C78 );
reconsider D12 = C79 as (Element of ( NAT )) by L183 , ORDINAL1:def 12;
L184: D12 in ( dom ( IncAddr (C78 , R18) ) ) by L183 , L133;
L185: ( IncAddr (( C78 /. D12 ) , R18) ) = ( ( IncAddr (C78 , R18) ) . D12 ) by L183 , L133
.= ( ( IncAddr (C78 , R18) ) /. D12 ) by L184 , PARTFUN1:def 6;
L186: ( ( IncAddr (( IncAddr (C78 , R18) ) , R19) ) . D12 ) = ( IncAddr (( ( IncAddr (C78 , R18) ) /. D12 ) , R19) ) by L184 , L133
.= ( IncAddr (( C78 /. D12 ) , ( R18 + R19 )) ) by L185 , COMPOS_0:7
.= ( ( IncAddr (C78 , ( R18 + R19 )) ) . D12 ) by L183 , L133;
thus L187: thesis by L186;
end;
thus L188: thesis by L182 , L180 , L181 , FUNCT_1:2;
end;
definition
let C80 being COM-Struct;
let C81 being  finite ( NAT ) -defined (the InstructionsF of C80) -valued Function;
let C82 being Nat;
func Reloc (C81 , C82) ->  finite ( NAT ) -defined (the InstructionsF of C80) -valued Function equals 
( Shift (( IncAddr (C81 , C82) ) , C82) );
coherence;
end;
theorem
L190: (for B29 being COM-Struct holds (for B30 being  initial non  empty  finite (preProgram of B29) holds (for B31 being non  empty ( NAT ) -defined (the InstructionsF of B29) -valued  finite Function holds ( dom ( CutLastLoc B30 ) ) misses ( dom ( Reloc (B31 , ( ( card B30 ) -' 1 )) ) ))))
proof
let C83 being COM-Struct;
let C84 being  initial non  empty  finite (preProgram of C83);
let C85 being non  empty ( NAT ) -defined (the InstructionsF of C83) -valued  finite Function;
set D13 = ( ( card C84 ) -' 1 );
assume L191: (not thesis);
consider C86 being set such that L192: C86 in ( ( dom ( CutLastLoc C84 ) ) /\ ( dom ( Reloc (C85 , D13) ) ) ) by L191 , XBOOLE_0:4;
L193: C86 in ( dom ( CutLastLoc C84 ) ) by L192 , XBOOLE_0:def 4;
L194: C86 in ( dom ( Reloc (C85 , D13) ) ) by L192 , XBOOLE_0:def 4;
L195: ( dom ( Reloc (C85 , D13) ) ) = { ( B32 + D13 ) where B32 is (Element of ( NAT )) : B32 in ( dom ( IncAddr (C85 , D13) ) ) } by VALUED_1:def 12;
consider C87 being (Element of ( NAT )) such that L196: C86 = ( C87 + D13 ) and L197: C87 in ( dom ( IncAddr (C85 , D13) ) ) by L195 , L194;
reconsider D14 = ( CutLastLoc C84 ) as non  empty ( NAT ) -defined  finite Function by L192 , RELAT_1:38;
L198: ( C87 + D13 ) <= ( LastLoc D14 ) by L193 , L196 , VALUED_1:32;
L199: ( C87 + D13 ) <= ( ( card D14 ) -' 1 ) by L198 , AFINSQ_1:70;
L200: ( card D14 ) = ( ( card C84 ) - 1 ) by VALUED_1:38
.= ( ( card C84 ) -' 1 ) by PRE_CIRC:20;
per cases ;
suppose L201: ( D13 - 1 ) >= ( 0 );

L202: ( C87 + D13 ) <= ( D13 - 1 ) by L201 , L199 , L200 , XREAL_0:def 2;
L203: ( ( C87 + D13 ) - D13 ) <= ( ( D13 - 1 ) - D13 ) by L202 , XREAL_1:9;
thus L204: thesis by L203 , L65;
end;
suppose L205: ( D13 - 1 ) < ( 0 );

L206: (( C87 + D13 ) = ( 0 ) or ( C87 + D13 ) < ( 0 )) by L205 , L199 , L200 , XREAL_0:def 2;
thus L207: thesis by L206 , L200;
end;
end;
theorem
L209: (for R13 being COM-Struct holds (for B33 being  unique-halt  initial non  empty  finite (preProgram of R13) holds (for B34 being Nat holds (B34 in ( dom ( CutLastLoc B33 ) ) implies ( ( CutLastLoc B33 ) . B34 ) <> ( halt R13 )))))
proof
let R13 being COM-Struct;
let C88 being  unique-halt  initial non  empty  finite (preProgram of R13);
let C89 being Nat;
assume that
L210: C89 in ( dom ( CutLastLoc C88 ) )
and
L211: ( ( CutLastLoc C88 ) . C89 ) = ( halt R13 );
L212: ( dom ( CutLastLoc C88 ) ) c= ( dom C88 ) by GRFUNC_1:2;
L213: ( C88 . C89 ) = ( halt R13 ) by L210 , L211 , GRFUNC_1:2;
L214: C89 = ( LastLoc C88 ) by L213 , L210 , L212 , L29;
L215: ( dom ( CutLastLoc C88 ) ) = ( ( dom C88 ) \ { ( LastLoc C88 ) } ) by VALUED_1:36;
L216: (not C89 in { ( LastLoc C88 ) }) by L215 , L210 , XBOOLE_0:def 5;
thus L217: thesis by L216 , L214 , TARSKI:def 1;
end;
definition
let C90 being COM-Struct;
let C91 , C92 being non  empty  finite (preProgram of C90);
func C91 ';' C92 ->  finite (preProgram of C90) equals 
( ( CutLastLoc C91 ) +* ( Reloc (C92 , ( ( card C91 ) -' 1 )) ) );
coherence;
end;
registration
let C93 being COM-Struct;
let C94 , C95 being non  empty (the InstructionsF of C93) -valued ( NAT ) -defined  finite Function;
cluster ( C94 ';' C95 ) -> non  empty (the InstructionsF of C93) -valued ( NAT ) -defined;
coherence;
end;
theorem
L220: (for B35 being COM-Struct holds (for B36 being  initial non  empty  finite (preProgram of B35) holds (for B37 being non  empty (the InstructionsF of B35) -valued ( NAT ) -defined  finite Function holds (( card ( B36 ';' B37 ) ) = ( ( ( card B36 ) + ( card B37 ) ) - 1 ) & ( card ( B36 ';' B37 ) ) = ( ( ( card B36 ) + ( card B37 ) ) -' 1 )))))
proof
let C96 being COM-Struct;
let C97 being  initial non  empty  finite (preProgram of C96);
let C98 being non  empty (the InstructionsF of C96) -valued ( NAT ) -defined  finite Function;
set D15 = ( ( card C97 ) -' 1 );
L221: ( dom ( IncAddr (C98 , D15) ) ) , ( dom ( Reloc (C98 , D15) ) ) are_equipotent  by VALUED_1:27;
L222: ( IncAddr (C98 , D15) ) , ( Reloc (C98 , D15) ) are_equipotent  by L221 , PRE_CIRC:21;
L223: ( dom ( CutLastLoc C97 ) ) misses ( dom ( Reloc (C98 , D15) ) ) by L190;
thus L224: ( card ( C97 ';' C98 ) ) = ( ( card ( CutLastLoc C97 ) ) + ( card ( Reloc (C98 , D15) ) ) ) by L223 , PRE_CIRC:22
.= ( ( card ( CutLastLoc C97 ) ) + ( card ( IncAddr (C98 , D15) ) ) ) by L222 , CARD_1:5
.= ( ( card ( CutLastLoc C97 ) ) + ( card ( dom ( IncAddr (C98 , D15) ) ) ) ) by CARD_1:62
.= ( ( card ( CutLastLoc C97 ) ) + ( card ( dom C98 ) ) ) by L133
.= ( ( card ( CutLastLoc C97 ) ) + ( card C98 ) ) by CARD_1:62
.= ( ( ( card C97 ) - 1 ) + ( card C98 ) ) by VALUED_1:38
.= ( ( ( card C97 ) + ( card C98 ) ) - 1 );
thus L225: thesis by L224 , XREAL_0:def 2;
end;
registration
let C99 being COM-Struct;
let C100 , C101 being  initial non  empty  finite (preProgram of C99);
cluster ( C100 ';' C101 ) ->  initial;
coherence
proof
set D16 = ( C100 ';' C101 );
let C102 , C103 being Nat;
assume that
L226: C103 in ( dom D16 )
and
L227: C102 < C103;
set D17 = ( ( card C100 ) -' 1 );
L228: ( dom D16 ) = ( ( dom ( CutLastLoc C100 ) ) \/ ( dom ( Reloc (C101 , D17) ) ) ) by FUNCT_4:def 1;
per cases  by L226 , L228 , XBOOLE_0:def 3;
suppose L229: C103 in ( dom ( CutLastLoc C100 ) );

L230: C102 in ( dom ( CutLastLoc C100 ) ) by L229 , L227 , AFINSQ_1:def 12;
thus L231: thesis by L230 , L228 , XBOOLE_0:def 3;
end;
suppose L232: C103 in ( dom ( Reloc (C101 , D17) ) );

L233: C103 in { ( B38 + D17 ) where B38 is (Element of ( NAT )) : B38 in ( dom ( IncAddr (C101 , D17) ) ) } by L232 , VALUED_1:def 12;
consider C104 being (Element of ( NAT )) such that L234: C103 = ( C104 + D17 ) and L235: C104 in ( dom ( IncAddr (C101 , D17) ) ) by L233;
L236: C104 in ( dom C101 ) by L235 , L133;
L237:
now
per cases ;
case L238: C102 < D17;
L239: C102 < ( ( card C100 ) - 1 ) by L238 , PRE_CIRC:20;
L240: ( 1 + C102 ) < ( 1 + ( ( card C100 ) - 1 ) ) by L239 , XREAL_1:6;
L241: ( 1 + C102 ) in ( dom C100 ) by L240 , AFINSQ_1:66;
L242: C102 < ( 1 + C102 ) by NAT_1:19;
L243: C102 in ( dom C100 ) by L242 , L241 , AFINSQ_1:def 12;
L244: C102 <> ( LastLoc C100 ) by L238 , AFINSQ_1:70;
L245: (not C102 in { ( LastLoc C100 ) }) by L244 , TARSKI:def 1;
L246: C102 in ( ( dom C100 ) \ { ( LastLoc C100 ) } ) by L245 , L243 , XBOOLE_0:def 5;
thus L247: C102 in ( dom ( CutLastLoc C100 ) ) by L246 , VALUED_1:36;
end;
case L248: C102 >= D17;
consider C105 being Nat such that L249: C102 = ( D17 + C105 ) by L248 , NAT_1:10;
reconsider D18 = C105 as (Element of ( NAT )) by ORDINAL1:def 12;
L250: ( dom ( Reloc (C101 , D17) ) ) = { ( B39 + D17 ) where B39 is (Element of ( NAT )) : B39 in ( dom ( IncAddr (C101 , D17) ) ) } by VALUED_1:def 12;
L251: (D18 < C104 or D18 = C104) by L249 , L234 , L227 , XREAL_1:6;
L252: D18 in ( dom C101 ) by L251 , L236 , AFINSQ_1:def 12;
L253: D18 in ( dom ( IncAddr (C101 , D17) ) ) by L252 , L133;
thus L254: C102 in ( dom ( Reloc (C101 , D17) ) ) by L253 , L250 , L249;
end;
end;
thus L256: thesis by L237 , L228 , XBOOLE_0:def 3;
end;
end;
end;
theorem
L259: (for B40 being COM-Struct holds (for B41 , B42 being  initial non  empty  finite (preProgram of B40) holds ( dom B41 ) c= ( dom ( B41 ';' B42 ) )))
proof
let C106 being COM-Struct;
let C107 , C108 being  initial non  empty  finite (preProgram of C106);
set D19 = ( C107 ';' C108 );
L260: ( dom D19 ) = ( ( dom ( CutLastLoc C107 ) ) \/ ( dom ( Reloc (C108 , ( ( card C107 ) -' 1 )) ) ) ) by FUNCT_4:def 1;
L261: ( dom C107 ) = ( ( dom ( CutLastLoc C107 ) ) \/ { ( LastLoc C107 ) } ) by VALUED_1:37;
let C109 being set;
assume L262: C109 in ( dom C107 );
per cases  by L261 , L262 , XBOOLE_0:def 3;
suppose L263: C109 in ( dom ( CutLastLoc C107 ) );

thus L264: thesis by L263 , L260 , XBOOLE_0:def 3;
end;
suppose L265: C109 in { ( LastLoc C107 ) };

L266: C109 = ( LastLoc C107 ) by L265 , TARSKI:def 1;
reconsider D20 = C109 as (Element of ( NAT )) by L265;
L267: D20 = ( ( card C107 ) -' 1 ) by L266 , AFINSQ_1:70
.= ( ( ( card C107 ) - 1 ) + (( 0 ) qua Nat) ) by PRE_CIRC:20;
L268: ( card D19 ) = ( ( ( card C107 ) + ( card C108 ) ) - 1 ) by L220
.= ( ( ( card C107 ) - 1 ) + ( card C108 ) );
L269: D20 < ( card D19 ) by L268 , L267 , XREAL_1:6;
thus L270: thesis by L269 , AFINSQ_1:66;
end;
end;
registration
let C110 being COM-Struct;
let C111 , C112 being  initial non  empty  finite (preProgram of C110);
cluster ( C111 ';' C112 ) ->  initial non  empty;
coherence;
end;
theorem
L273: (for B43 being COM-Struct holds (for B44 , B45 being  initial non  empty  finite (preProgram of B43) holds ( CutLastLoc B44 ) c= ( CutLastLoc ( B44 ';' B45 ) )))
proof
let C113 being COM-Struct;
let C114 , C115 being  initial non  empty  finite (preProgram of C113);
set D21 = ( ( card C114 ) -' 1 );
set D22 = ( C114 ';' C115 );
L274: ( dom D22 ) = ( ( dom ( CutLastLoc C114 ) ) \/ ( dom ( Reloc (C115 , D21) ) ) ) by FUNCT_4:def 1;
L275: ( dom ( CutLastLoc C114 ) ) = { B46 where B46 is (Element of ( NAT )) : B46 < ( card ( CutLastLoc C114 ) ) } by AFINSQ_1:68;
L276: ( card ( CutLastLoc D22 ) ) = ( ( card D22 ) - 1 ) by VALUED_1:38
.= ( ( ( ( card C114 ) + ( card C115 ) ) - 1 ) - 1 ) by L220
.= ( ( ( card C114 ) - 1 ) + ( ( card C115 ) - 1 ) );
L277: (for B47 being (Element of ( NAT )) holds (B47 < ( card ( CutLastLoc C114 ) ) implies B47 < ( card ( CutLastLoc D22 ) )))
proof
let C116 being (Element of ( NAT ));
assume that
L278: C116 < ( card ( CutLastLoc C114 ) );
L279: ( card ( CutLastLoc C114 ) ) = ( ( card C114 ) - 1 ) by VALUED_1:38;
L280: 1 <= ( card C115 ) by NAT_1:14;
L281: ( 1 - 1 ) <= ( ( card C115 ) - 1 ) by L280 , XREAL_1:9;
L282: ( ( ( card C114 ) - 1 ) + (( 0 ) qua Nat) ) <= ( ( ( card C114 ) - 1 ) + ( ( card C115 ) - 1 ) ) by L281 , XREAL_1:6;
thus L283: thesis by L282 , L276 , L278 , L279 , XXREAL_0:2;
end;
L284: ( dom ( CutLastLoc C114 ) ) c= ( dom ( CutLastLoc D22 ) )
proof
let C117 being set;
assume L285: C117 in ( dom ( CutLastLoc C114 ) );
consider C118 being (Element of ( NAT )) such that L286: C117 = C118 and L287: C118 < ( card ( CutLastLoc C114 ) ) by L285 , L275;
L288: C118 < ( card ( CutLastLoc D22 ) ) by L277 , L287;
thus L289: thesis by L288 , L286 , AFINSQ_1:66;
end;
L290: (for B48 being set holds (B48 in ( dom ( CutLastLoc C114 ) ) implies ( ( CutLastLoc C114 ) . B48 ) = ( ( CutLastLoc D22 ) . B48 )))
proof
let C119 being set;
assume L291: C119 in ( dom ( CutLastLoc C114 ) );
consider C120 being (Element of ( NAT )) such that L292: C119 = C120 and L293: C120 < ( card ( CutLastLoc C114 ) ) by L291 , L275;
L294: ( dom ( Reloc (C115 , D21) ) ) = { ( B49 + D21 ) where B49 is (Element of ( NAT )) : B49 in ( dom ( IncAddr (C115 , D21) ) ) } by VALUED_1:def 12;
L295:
now
assume L296: C119 in ( dom ( Reloc (C115 , D21) ) );
consider C121 being (Element of ( NAT )) such that L297: C119 = ( C121 + D21 ) and L298: C121 in ( dom ( IncAddr (C115 , D21) ) ) by L296 , L294;
L299: C120 < ( ( card C114 ) - 1 ) by L293 , VALUED_1:38;
L300: C120 < D21 by L299 , PRE_CIRC:20;
thus L301: contradiction by L300 , L292 , L297 , NAT_1:11;
end;
L302: C119 in ( dom D22 ) by L274 , L291 , XBOOLE_0:def 3;
L303:
now
assume L304: C119 = ( LastLoc D22 );
L305: C120 = ( ( card D22 ) -' 1 ) by L304 , L292 , AFINSQ_1:70
.= ( ( card D22 ) - 1 ) by PRE_CIRC:20;
L306: ( card ( CutLastLoc D22 ) ) = ( ( card D22 ) - 1 ) by VALUED_1:38;
thus L307: contradiction by L306 , L277 , L293 , L305;
end;
L308: (not C119 in { ( LastLoc D22 ) }) by L303 , TARSKI:def 1;
L309: (not C119 in ( dom ( ( LastLoc D22 ) .--> ( D22 . ( LastLoc D22 ) ) ) )) by L308 , FUNCOP_1:13;
L310: C119 in ( ( dom D22 ) \ ( dom ( ( LastLoc D22 ) .--> ( D22 . ( LastLoc D22 ) ) ) ) ) by L309 , L302 , XBOOLE_0:def 5;
thus L311: ( ( CutLastLoc D22 ) . C119 ) = ( ( ( CutLastLoc C114 ) +* ( Reloc (C115 , D21) ) ) . C119 ) by L310 , GRFUNC_1:32
.= ( ( CutLastLoc C114 ) . C119 ) by L295 , FUNCT_4:11;
end;
thus L312: thesis by L290 , L284 , GRFUNC_1:2;
end;
theorem
L313: (for B50 being COM-Struct holds (for B51 , B52 being  initial non  empty  finite (preProgram of B50) holds ( ( B51 ';' B52 ) . ( LastLoc B51 ) ) = ( ( IncAddr (B52 , ( ( card B51 ) -' 1 )) ) . ( 0 ) )))
proof
let C122 being COM-Struct;
let C123 , C124 being  initial non  empty  finite (preProgram of C122);
set D23 = ( ( card C123 ) -' 1 );
L314: ( LastLoc C123 ) = ( (( 0 ) qua Nat) + D23 ) by AFINSQ_1:70;
L315: ( 0 ) in ( dom ( IncAddr (C124 , D23) ) ) by AFINSQ_1:65;
L316: ( dom ( Reloc (C124 , D23) ) ) = { ( B53 + D23 ) where B53 is (Element of ( NAT )) : B53 in ( dom ( IncAddr (C124 , D23) ) ) } by VALUED_1:def 12;
L317: ( LastLoc C123 ) in ( dom ( Reloc (C124 , D23) ) ) by L316 , L314 , L315;
thus L318: ( ( C123 ';' C124 ) . ( LastLoc C123 ) ) = ( ( Reloc (C124 , D23) ) . ( LastLoc C123 ) ) by L317 , FUNCT_4:13
.= ( ( IncAddr (C124 , D23) ) . ( 0 ) ) by L314 , L315 , VALUED_1:def 12;
end;
theorem
L319: (for B54 being COM-Struct holds (for B55 , B56 being  initial non  empty  finite (preProgram of B54) holds (for B57 being Nat holds (B57 < ( ( card B55 ) - 1 ) implies ( ( IncAddr (B55 , ( ( card B55 ) -' 1 )) ) . B57 ) = ( ( IncAddr (( B55 ';' B56 ) , ( ( card B55 ) -' 1 )) ) . B57 )))))
proof
let C125 being COM-Struct;
let C126 , C127 being  initial non  empty  finite (preProgram of C125);
let C128 being Nat;
set D24 = ( ( card C126 ) -' 1 );
set D25 = ( C126 ';' C127 );
assume L320: C128 < ( ( card C126 ) - 1 );
L321: C128 < ( card ( CutLastLoc C126 ) ) by L320 , VALUED_1:38;
L322: C128 in ( dom ( CutLastLoc C126 ) ) by L321 , AFINSQ_1:66;
L323: ( dom ( CutLastLoc C126 ) ) c= ( dom C126 ) by GRFUNC_1:2;
L324: ( CutLastLoc C126 ) c= ( CutLastLoc D25 ) by L273;
L325: ( CutLastLoc C126 ) c= D25 by L324 , XBOOLE_1:1;
L326: ( dom ( CutLastLoc C126 ) ) c= ( dom D25 ) by L325 , GRFUNC_1:2;
L327: ( C126 . C128 ) = ( C126 /. C128 ) by L322 , L323 , PARTFUN1:def 6;
L328: ( dom ( CutLastLoc C126 ) ) misses ( dom ( Reloc (C127 , D24) ) ) by L190;
L329: ( ( dom ( CutLastLoc C126 ) ) /\ ( dom ( Reloc (C127 , D24) ) ) ) = ( {} ) by L328 , XBOOLE_0:def 7;
L330: (not C128 in ( dom ( Reloc (C127 , D24) ) )) by L329 , L322 , XBOOLE_0:def 4;
L331: ( D25 . C128 ) = ( ( CutLastLoc C126 ) . C128 ) by L330 , FUNCT_4:11
.= ( C126 . C128 ) by L322 , GRFUNC_1:2;
thus L332: ( ( IncAddr (C126 , D24) ) . C128 ) = ( IncAddr (( C126 /. C128 ) , D24) ) by L322 , L323 , L133
.= ( IncAddr (( D25 /. C128 ) , D24) ) by L322 , L326 , L327 , L331 , PARTFUN1:def 6
.= ( ( IncAddr (D25 , D24) ) . C128 ) by L322 , L326 , L133;
end;
registration
let C129 being COM-Struct;
let C130 being  initial non  empty ( NAT ) -defined (the InstructionsF of C129) -valued  finite Function;
let C131 being  halt-ending  initial non  empty ( NAT ) -defined (the InstructionsF of C129) -valued  finite Function;
cluster ( C130 ';' C131 ) ->  halt-ending;
coherence
proof
set D26 = ( C130 ';' C131 );
set D27 = ( ( card C130 ) -' 1 );
L333: ( dom ( Reloc (C131 , D27) ) ) = { ( B58 + D27 ) where B58 is (Element of ( NAT )) : B58 in ( dom ( IncAddr (C131 , D27) ) ) } by VALUED_1:def 12;
L334: ( ( card C131 ) -' 1 ) = ( LastLoc C131 ) by AFINSQ_1:70;
L335: ( ( card C131 ) -' 1 ) in ( dom C131 ) by L334 , VALUED_1:30;
L336: ( ( card C131 ) -' 1 ) in ( dom ( IncAddr (C131 , D27) ) ) by L335 , L133;
L337: ( D27 + ( ( card C131 ) -' 1 ) ) in ( dom ( Reloc (C131 , D27) ) ) by L336 , L333;
L338: ( C131 /. ( ( card C131 ) -' 1 ) ) = ( C131 . ( ( card C131 ) -' 1 ) ) by L334 , PARTFUN1:def 6 , VALUED_1:30
.= ( halt C129 ) by L334 , L28;
L339: ( ( card C131 ) - 1 ) >= ( 0 ) by NAT_1:14 , XREAL_1:48;
L340: ( D27 + ( ( card C131 ) - 1 ) ) >= ( D27 + (( 0 ) qua Nat) ) by L339 , XREAL_1:6;
L341: ( ( D27 + ( card C131 ) ) -' 1 ) = ( ( D27 + ( card C131 ) ) - 1 ) by L340 , XREAL_0:def 2
.= ( D27 + ( ( card C131 ) - 1 ) )
.= ( D27 + ( ( card C131 ) -' 1 ) ) by L339 , XREAL_0:def 2;
thus L342: ( D26 . ( LastLoc D26 ) ) = ( D26 . ( ( card D26 ) -' 1 ) ) by AFINSQ_1:70
.= ( D26 . ( ( ( ( card C130 ) + ( card C131 ) ) -' 1 ) -' 1 ) ) by L220
.= ( D26 . ( ( D27 + ( card C131 ) ) -' 1 ) ) by NAT_1:14 , NAT_D:38
.= ( ( Reloc (C131 , D27) ) . ( D27 + ( ( card C131 ) -' 1 ) ) ) by L337 , L341 , FUNCT_4:13
.= ( ( IncAddr (C131 , D27) ) . ( ( card C131 ) -' 1 ) ) by L336 , VALUED_1:def 12
.= ( IncAddr (( C131 /. ( ( card C131 ) -' 1 ) ) , D27) ) by L335 , L133
.= ( halt C129 ) by L338 , COMPOS_0:4;
end;
end;
registration
let C132 being COM-Struct;
let C133 , C134 being  halt-ending  unique-halt  initial non  empty ( NAT ) -defined (the InstructionsF of C132) -valued  finite Function;
cluster ( C133 ';' C134 ) ->  unique-halt;
coherence
proof
set D28 = ( C133 ';' C134 );
set D29 = ( ( card C133 ) -' 1 );
L344: ( dom D28 ) = ( ( dom ( CutLastLoc C133 ) ) \/ ( dom ( Reloc (C134 , D29) ) ) ) by FUNCT_4:def 1;
L345: ( dom ( Reloc (C134 , D29) ) ) = { ( B59 + D29 ) where B59 is (Element of ( NAT )) : B59 in ( dom ( IncAddr (C134 , D29) ) ) } by VALUED_1:def 12;
L346: ( ( card C134 ) - 1 ) >= ( 0 ) by NAT_1:14 , XREAL_1:48;
L347: ( D29 + ( ( card C134 ) - 1 ) ) >= ( D29 + (( 0 ) qua Nat) ) by L346 , XREAL_1:6;
L348: ( ( D29 + ( card C134 ) ) -' 1 ) = ( ( D29 + ( card C134 ) ) - 1 ) by L347 , XREAL_0:def 2
.= ( D29 + ( ( card C134 ) - 1 ) )
.= ( D29 + ( ( card C134 ) -' 1 ) ) by L346 , XREAL_0:def 2;
let C135 being Nat;
assume that
L349: ( D28 . C135 ) = ( halt C132 )
and
L350: C135 in ( dom D28 );
per cases  by L344 , L350 , XBOOLE_0:def 3;
suppose L351: C135 in ( dom ( CutLastLoc C133 ) );

L352: ( ( CutLastLoc C133 ) . C135 ) <> ( halt C132 ) by L351 , L209;
L353: ( dom ( CutLastLoc C133 ) ) misses ( dom ( Reloc (C134 , D29) ) ) by L190;
L354: ( CutLastLoc C133 ) c= D28 by L353 , FUNCT_4:32;
thus L355: thesis by L354 , L349 , L351 , L352 , GRFUNC_1:2;
end;
suppose L356: C135 in ( dom ( Reloc (C134 , D29) ) );

consider C136 being (Element of ( NAT )) such that L357: C135 = ( C136 + D29 ) and L358: C136 in ( dom ( IncAddr (C134 , D29) ) ) by L356 , L345;
L359: C136 in ( dom C134 ) by L358 , L133;
L360: ( C134 /. C136 ) = ( C134 . C136 ) by L359 , PARTFUN1:def 6;
L361: ( IncAddr (( C134 /. C136 ) , D29) ) = ( ( IncAddr (C134 , D29) ) . C136 ) by L359 , L133
.= ( ( Reloc (C134 , D29) ) . ( C136 + D29 ) ) by L358 , VALUED_1:def 12
.= ( halt C132 ) by L349 , L356 , L357 , FUNCT_4:13;
L362: ( C134 . C136 ) = ( halt C132 ) by L361 , L360 , COMPOS_0:12;
L363: C136 = ( LastLoc C134 ) by L362 , L359 , L29
.= ( ( card C134 ) -' 1 ) by AFINSQ_1:70;
L364: ( C136 + D29 ) = ( ( ( ( card C133 ) + ( card C134 ) ) -' 1 ) -' 1 ) by L363 , L348 , NAT_1:14 , NAT_D:38
.= ( ( card D28 ) -' 1 ) by L220;
thus L365: thesis by L364 , L357 , AFINSQ_1:70;
end;
end;
end;
definition
let C137 being COM-Struct;
let C138 , C139 being (MacroInstruction of C137);
redefine func C138 ';' C139 -> (MacroInstruction of C137);

coherence;
end;
registration
let C140 being COM-Struct;
let R18 being Nat;
reduce ( IncAddr (( Stop C140 ) , R18) ) to ( Stop C140 );
reducibility
proof
L369: ( dom ( IncAddr (( Stop C140 ) , R18) ) ) = ( dom ( Stop C140 ) ) by L133
.= { ( 0 ) } by L41;
L370: ( dom ( Stop C140 ) ) = { ( 0 ) } by L41;
L371: (for B60 being set holds (B60 in { ( 0 ) } implies ( ( IncAddr (( Stop C140 ) , R18) ) . B60 ) = ( ( Stop C140 ) . B60 )))
proof
let C141 being set;
assume L372: C141 in { ( 0 ) };
L373: C141 = ( 0 ) by L372 , TARSKI:def 1;
L374: ( ( Stop C140 ) /. ( 0 ) ) = ( ( Stop C140 ) . ( 0 ) ) by L373 , L370 , L372 , PARTFUN1:def 6
.= ( halt C140 ) by FUNCOP_1:72;
thus L375: ( ( IncAddr (( Stop C140 ) , R18) ) . C141 ) = ( IncAddr (( ( Stop C140 ) /. ( 0 ) ) , R18) ) by L370 , L372 , L373 , L133
.= ( halt C140 ) by L374 , COMPOS_0:4
.= ( ( Stop C140 ) . C141 ) by L373 , FUNCOP_1:72;
end;
thus L376: thesis by L371 , L369 , L370 , FUNCT_1:2;
end;
end;
theorem
L378: (for R18 being Nat holds (for B61 being COM-Struct holds ( IncAddr (( Stop B61 ) , R18) ) = ( Stop B61 )));
theorem
L379: (for B62 being Nat holds (for B63 being COM-Struct holds ( Shift (( Stop B63 ) , B62) ) = ( B62 .--> ( halt B63 ) )))
proof
let C142 being Nat;
let C143 being COM-Struct;
L380: ( dom ( Shift (( Stop C143 ) , C142) ) ) = { ( B64 + C142 ) where B64 is (Element of ( NAT )) : B64 in ( dom ( Stop C143 ) ) } by VALUED_1:def 12;
L381: ( 0 ) in ( dom ( Stop C143 ) ) by L41;
L382: ( dom ( Shift (( Stop C143 ) , C142) ) ) = { C142 }
proof
thus L383:now
let C144 being set;
assume L384: C144 in ( dom ( Shift (( Stop C143 ) , C142) ) );
consider C145 being (Element of ( NAT )) such that L385: C144 = ( C145 + C142 ) and L386: C145 in ( dom ( Stop C143 ) ) by L384 , L380;
L387: C145 in { ( 0 ) } by L386 , L41;
L388: C145 = ( 0 ) by L387 , TARSKI:def 1;
thus L389: C144 in { C142 } by L388 , L385 , TARSKI:def 1;
end;
let C146 being set;
assume L390: C146 in { C142 };
L391: C146 = ( (( 0 ) qua Nat) + C142 ) by L390 , TARSKI:def 1;
thus L392: thesis by L391 , L380 , L381;
end;
L393: ( dom ( C142 .--> ( halt C143 ) ) ) = { C142 } by FUNCOP_1:13;
L394: (for B65 being set holds (B65 in { C142 } implies ( ( Shift (( Stop C143 ) , C142) ) . B65 ) = ( ( C142 .--> ( halt C143 ) ) . B65 )))
proof
let C147 being set;
assume L395: C147 in { C142 };
L396: C147 = ( (( 0 ) qua Nat) + C142 ) by L395 , TARSKI:def 1;
L397: ( 0 ) in ( dom ( Stop C143 ) ) by L41;
thus L398: ( ( Shift (( Stop C143 ) , C142) ) . C147 ) = ( ( Stop C143 ) . ( 0 ) ) by L397 , L396 , VALUED_1:def 12
.= ( halt C143 ) by FUNCOP_1:72
.= ( ( C142 .--> ( halt C143 ) ) . C147 ) by L396 , FUNCOP_1:72;
end;
thus L399: thesis by L394 , L382 , L393 , FUNCT_1:2;
end;
registration
let C148 being COM-Struct;
let C149 being (MacroInstruction of C148);
reduce ( C149 ';' ( Stop C148 ) ) to C149;
reducibility
proof
set D30 = ( ( card C149 ) -' 1 );
L400: ( dom C149 ) = ( ( dom ( CutLastLoc C149 ) ) \/ { ( LastLoc C149 ) } ) by VALUED_1:37;
L401: ( dom ( Shift (( Stop C148 ) , D30) ) ) = ( dom ( D30 .--> ( halt C148 ) ) ) by L379
.= { D30 } by FUNCOP_1:13
.= { ( LastLoc C149 ) } by AFINSQ_1:70;
L402: ( dom ( C149 ';' ( Stop C148 ) ) ) = ( dom C149 ) by L401 , L400 , FUNCT_4:def 1;
L403: (for B66 being set holds (B66 in ( dom C149 ) implies ( ( C149 ';' ( Stop C148 ) ) . B66 ) = ( C149 . B66 )))
proof
let C150 being set;
assume that
L404: C150 in ( dom C149 );
L405: ( dom ( CutLastLoc C149 ) ) misses ( dom ( Reloc (( Stop C148 ) , D30) ) ) by L190;
L406: ( {} ) = ( ( dom ( CutLastLoc C149 ) ) /\ ( dom ( Reloc (( Stop C148 ) , D30) ) ) ) by L405 , XBOOLE_0:def 7;
per cases  by L400 , L404 , XBOOLE_0:def 3;
suppose L407: C150 in ( dom ( CutLastLoc C149 ) );

L408: (not C150 in ( dom ( Reloc (( Stop C148 ) , D30) ) )) by L407 , L406 , XBOOLE_0:def 4;
thus L409: ( ( C149 ';' ( Stop C148 ) ) . C150 ) = ( ( CutLastLoc C149 ) . C150 ) by L408 , FUNCT_4:11
.= ( C149 . C150 ) by L407 , GRFUNC_1:2;
end;
suppose L410: C150 in { ( LastLoc C149 ) };

L411: C150 = ( LastLoc C149 ) by L410 , TARSKI:def 1;
L412: C150 = D30 by L411 , AFINSQ_1:70;
L413: ( 0 ) in ( dom ( Stop C148 ) ) by L41;
L414: ( dom ( Shift (( Stop C148 ) , D30) ) ) = { ( B67 + D30 ) where B67 is (Element of ( NAT )) : B67 in ( dom ( Stop C148 ) ) } by VALUED_1:def 12;
L415: ( (( 0 ) qua Nat) + D30 ) in ( dom ( Shift (( Stop C148 ) , D30) ) ) by L414 , L413;
thus L416: ( ( C149 ';' ( Stop C148 ) ) . C150 ) = ( ( Shift (( Stop C148 ) , ( (( 0 ) qua Nat) + D30 )) ) . C150 ) by L415 , L412 , FUNCT_4:13
.= ( ( Stop C148 ) . ( 0 ) ) by L412 , L413 , VALUED_1:def 12
.= ( halt C148 ) by FUNCOP_1:72
.= ( C149 . C150 ) by L411 , L28;
end;
end;
thus L418: thesis by L403 , L402 , FUNCT_1:2;
end;
end;
theorem
L420: (for B68 being COM-Struct holds (for B69 being (MacroInstruction of B68) holds ( B69 ';' ( Stop B68 ) ) = B69));
registration
let C151 being COM-Struct;
let C152 being (MacroInstruction of C151);
reduce ( ( Stop C151 ) ';' C152 ) to C152;
reducibility
proof
L421: ( ( card ( Stop C151 ) ) -' 1 ) = ( 0 ) by L44;
thus L422: ( ( Stop C151 ) ';' C152 ) = ( ( {} ) +* ( Reloc (C152 , ( 0 )) ) ) by L421
.= ( Reloc (C152 , ( 0 )) )
.= C152;
end;
end;
theorem
L424: (for B70 being COM-Struct holds (for B71 being (MacroInstruction of B70) holds ( ( Stop B70 ) ';' B71 ) = B71));
theorem
L425: (for B72 being COM-Struct holds (for B73 , B74 , B75 being (MacroInstruction of B72) holds ( ( B73 ';' B74 ) ';' B75 ) = ( B73 ';' ( B74 ';' B75 ) )))
proof
let C153 being COM-Struct;
let C154 , C155 , C156 being (MacroInstruction of C153);
per cases ;
suppose L426: C154 = ( Stop C153 );

thus L427: ( ( C154 ';' C155 ) ';' C156 ) = ( ( ( Stop C153 ) ';' C155 ) ';' C156 ) by L426
.= ( C154 ';' ( C155 ';' C156 ) ) by L426 , L424;
end;
suppose L428: C155 = ( Stop C153 );

thus L429: ( ( C154 ';' C155 ) ';' C156 ) = ( ( C154 ';' ( Stop C153 ) ) ';' C156 ) by L428
.= ( C154 ';' ( C155 ';' C156 ) ) by L428 , L424;
end;
suppose that L430: C154 <> ( Stop C153 )
and
L431: C155 <> ( Stop C153 );
set D31 = { B76 where B76 is (Element of ( NAT )) : B76 < ( ( ( ( ( card C154 ) + ( card C155 ) ) + ( card C156 ) ) - 1 ) - 1 ) };
L432: ( card ( ( C154 ';' C155 ) ';' C156 ) ) = ( ( ( card ( C154 ';' C155 ) ) + ( card C156 ) ) - 1 ) by L220
.= ( ( ( ( ( card C154 ) + ( card C155 ) ) - 1 ) + ( card C156 ) ) - 1 ) by L220
.= ( ( ( ( ( card C154 ) + ( card C155 ) ) + ( card C156 ) ) - 1 ) - 1 );
L433: ( card ( C154 ';' ( C155 ';' C156 ) ) ) = ( ( ( card C154 ) + ( card ( C155 ';' C156 ) ) ) - 1 ) by L220
.= ( ( ( card C154 ) + ( ( ( card C155 ) + ( card C156 ) ) - 1 ) ) - 1 ) by L220
.= ( ( ( ( ( card C154 ) + ( card C155 ) ) + ( card C156 ) ) - 1 ) - 1 );
L434: ( dom ( ( C154 ';' C155 ) ';' C156 ) ) = D31 by L432 , AFINSQ_1:68;
L435: ( dom ( C154 ';' ( C155 ';' C156 ) ) ) = D31 by L433 , AFINSQ_1:68;
L436: (for B77 being set holds (B77 in D31 implies ( ( ( C154 ';' C155 ) ';' C156 ) . B77 ) = ( ( C154 ';' ( C155 ';' C156 ) ) . B77 )))
proof
let C157 being set;
assume L437: C157 in D31;
consider C158 being (Element of ( NAT )) such that L438: C157 = C158 and L439: C158 < ( ( ( ( ( card C154 ) + ( card C155 ) ) + ( card C156 ) ) - 1 ) - 1 ) by L437;
L440: ( dom ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) = { ( B78 + ( ( card C154 ) -' 1 ) ) where B78 is (Element of ( NAT )) : B78 in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) } by VALUED_1:def 12;
L441: ( dom ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) = { ( B79 + ( ( card ( C154 ';' C155 ) ) -' 1 ) ) where B79 is (Element of ( NAT )) : B79 in ( dom ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) } by VALUED_1:def 12;
L442: ( dom ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) ) = { ( B80 + ( ( card C155 ) -' 1 ) ) where B80 is (Element of ( NAT )) : B80 in ( dom ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) ) } by VALUED_1:def 12;
L443: ( ( card ( C154 ';' C155 ) ) -' 1 ) = ( ( card ( C154 ';' C155 ) ) - 1 ) by PRE_CIRC:20
.= ( ( ( ( card C154 ) + ( card C155 ) ) - 1 ) - 1 ) by L220;
L444: ( ( card ( C154 ';' C155 ) ) -' 1 ) = ( ( ( card C154 ) - 1 ) + ( ( card C155 ) - 1 ) ) by L443;
L445: ( ( card ( C154 ';' C155 ) ) -' 1 ) = ( ( ( card C155 ) -' 1 ) + ( ( card C154 ) - 1 ) ) by L444 , PRE_CIRC:20
.= ( ( ( card C155 ) -' 1 ) + ( ( card C154 ) -' 1 ) ) by PRE_CIRC:20;
L446: ( dom ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) ) = { ( B81 + ( ( card C154 ) -' 1 ) ) where B81 is (Element of ( NAT )) : B81 in ( dom ( IncAddr (C155 , ( ( card C154 ) -' 1 )) ) ) } by VALUED_1:def 12;
L447: ( ( card C154 ) -' 1 ) = ( ( card C154 ) - 1 ) by PRE_CIRC:20;
L448: ( ( card C155 ) -' 1 ) = ( ( card C155 ) - 1 ) by PRE_CIRC:20;
L449: (for B82 being (MacroInstruction of C153) holds (B82 <> ( Stop C153 ) implies 2 <= ( card B82 )))
proof
let C159 being (MacroInstruction of C153);
assume L450: C159 <> ( Stop C153 );
assume L451: 2 > ( card C159 );
L452: ( 1 + 1 ) > ( card C159 ) by L451;
L453: ( card C159 ) <= 1 by L452 , NAT_1:13;
thus L454: contradiction by L453 , L450 , L116 , NAT_1:25;
end;
L455: 2 <= ( card C154 ) by L449 , L430;
L456: 1 <= ( card C154 ) by L455 , XXREAL_0:2;
L457: 2 <= ( card C155 ) by L431 , L449;
per cases  by L456 , L457 , L66;
suppose L458: C158 < ( ( card C154 ) - 1 );

L459: ( CutLastLoc C154 ) c= ( CutLastLoc ( C154 ';' C155 ) ) by L273;
L460:
now
assume L461: C157 in ( dom ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) );
consider C160 being (Element of ( NAT )) such that L462: C157 = ( C160 + ( ( card C154 ) -' 1 ) ) and L463: C160 in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L461 , L440;
L464: C158 = ( C160 + ( ( card C154 ) - 1 ) ) by L438 , L462 , PRE_CIRC:20;
L465: ( C160 + ( ( card C154 ) - 1 ) ) < ( ( card C154 ) -' 1 ) by L464 , L458 , PRE_CIRC:20;
L466: ( C160 + ( ( card C154 ) -' 1 ) ) < ( ( card C154 ) -' 1 ) by L465 , PRE_CIRC:20;
thus L467: contradiction by L466 , NAT_1:11;
end;
L468:
now
assume L469: C157 in ( dom ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) );
consider C161 being (Element of ( NAT )) such that L470: C157 = ( C161 + ( ( card ( C154 ';' C155 ) ) -' 1 ) ) and L471: C161 in ( dom ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L469 , L441;
L472: ( ( C161 + ( ( card C155 ) -' 1 ) ) + ( ( card C154 ) -' 1 ) ) < ( ( card C154 ) -' 1 ) by L458 , L438 , L445 , L470 , PRE_CIRC:20;
thus L473: contradiction by L472 , NAT_1:11;
end;
L474: C158 < ( card ( CutLastLoc C154 ) ) by L458 , VALUED_1:38;
L475: C157 in ( dom ( CutLastLoc C154 ) ) by L474 , L438 , AFINSQ_1:66;
thus L476: ( ( ( C154 ';' C155 ) ';' C156 ) . C157 ) = ( ( CutLastLoc ( C154 ';' C155 ) ) . C157 ) by L468 , FUNCT_4:11
.= ( ( CutLastLoc C154 ) . C157 ) by L459 , L475 , GRFUNC_1:2
.= ( ( C154 ';' ( C155 ';' C156 ) ) . C157 ) by L460 , FUNCT_4:11;
end;
suppose L477: C158 = ( ( card C154 ) - 1 );

L478:
now
assume L479: C157 in ( dom ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) );
consider C162 being (Element of ( NAT )) such that L480: C157 = ( C162 + ( ( card ( C154 ';' C155 ) ) -' 1 ) ) and L481: C162 in ( dom ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L479 , L441;
L482: ( ( C162 + ( ( card C155 ) -' 1 ) ) + ( ( card C154 ) -' 1 ) ) = ( ( card C154 ) -' 1 ) by L477 , L445 , L480 , L438 , PRE_CIRC:20;
L483: ( ( card C155 ) -' 1 ) = ( 0 ) by L482;
L484: ( ( card C155 ) - 1 ) = ( 0 ) by L483 , PRE_CIRC:20;
thus L485: contradiction by L484 , L431 , L116;
end;
L486: ( 0 ) in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by AFINSQ_1:65;
L487: ( 0 ) in ( dom ( IncAddr (C155 , ( ( card C154 ) -' 1 )) ) ) by AFINSQ_1:65;
L488: ( 0 ) in ( dom C155 ) by AFINSQ_1:65;
L489: ( 0 ) in ( dom ( C155 ';' C156 ) ) by AFINSQ_1:65;
L490: C158 = ( (( 0 ) qua Nat) + ( ( card C154 ) -' 1 ) ) by L477 , PRE_CIRC:20;
L491: C157 in ( dom ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L490 , L438 , L440 , L486;
L492: C158 = ( ( card C154 ) -' 1 ) by L477 , PRE_CIRC:20;
L493: C157 = ( (( 0 ) qua Nat) + C158 ) by L438;
L494: ( 0 ) in ( dom ( IncAddr (C155 , ( ( card C154 ) -' 1 )) ) ) by AFINSQ_1:65;
L495: C157 in ( dom ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) ) by L494 , L446 , L492 , L493;
L496: C157 in ( ( dom ( CutLastLoc C154 ) ) \/ ( dom ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) ) ) by L495 , XBOOLE_0:def 3;
L497: C157 in ( dom ( C154 ';' C155 ) ) by L496 , FUNCT_4:def 1;
L498:
now
L499: ( dom ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) ) = { ( LastLoc ( C154 ';' C155 ) ) } by FUNCOP_1:13
.= { ( ( card ( C154 ';' C155 ) ) -' 1 ) } by AFINSQ_1:70;
assume L500: C157 in ( dom ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) );
L501: C157 = ( ( card ( C154 ';' C155 ) ) -' 1 ) by L500 , L499 , TARSKI:def 1;
L502: ( ( card C155 ) - 1 ) = ( 0 ) by L501 , L492 , L438 , L445 , PRE_CIRC:20;
thus L503: contradiction by L502 , L431 , L116;
end;
L504: C157 in ( ( dom ( C154 ';' C155 ) ) \ ( dom ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) ) ) by L498 , L497 , XBOOLE_0:def 5;
L505: 1 <= ( card C155 ) by NAT_1:14;
L506: ( card C155 ) > 1 by L505 , L431 , L116 , XXREAL_0:1;
L507: ( ( card C155 ) - 1 ) > ( 1 - 1 ) by L506 , XREAL_1:9;
L508: ( ( card C155 ) -' 1 ) > ( 1 - 1 ) by L507 , PRE_CIRC:20;
L509: (not ( 0 ) in ( dom ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) )) by L508 , VALUED_1:29;
L510: ( card ( CutLastLoc C155 ) ) <> ( {} ) by L507 , VALUED_1:38;
L511: ( 0 ) in ( dom ( CutLastLoc C155 ) ) by L510 , AFINSQ_1:65 , CARD_1:27;
L512: ( C155 /. ( 0 ) ) = ( C155 . ( 0 ) ) by L488 , PARTFUN1:def 6
.= ( ( CutLastLoc C155 ) . ( 0 ) ) by L511 , GRFUNC_1:2
.= ( ( C155 ';' C156 ) . ( 0 ) ) by L509 , FUNCT_4:11
.= ( ( C155 ';' C156 ) /. ( 0 ) ) by L489 , PARTFUN1:def 6;
thus L513: ( ( ( C154 ';' C155 ) ';' C156 ) . C157 ) = ( ( ( C154 ';' C155 ) \ ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) ) . C157 ) by L478 , FUNCT_4:11
.= ( ( ( CutLastLoc C154 ) +* ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) ) . C157 ) by L504 , GRFUNC_1:32
.= ( ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) . C157 ) by L495 , FUNCT_4:13
.= ( ( IncAddr (C155 , ( ( card C154 ) -' 1 )) ) . ( 0 ) ) by L487 , L492 , L493 , VALUED_1:def 12
.= ( IncAddr (( ( C155 ';' C156 ) /. ( 0 ) ) , ( ( card C154 ) -' 1 )) ) by L488 , L512 , L133
.= ( ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . ( 0 ) ) by L489 , L133
.= ( ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . C157 ) by L486 , L492 , L493 , VALUED_1:def 12
.= ( ( C154 ';' ( C155 ';' C156 ) ) . C157 ) by L491 , FUNCT_4:13;
end;
suppose that L514: ( card C154 ) <= C158
and
L515: C158 <= ( ( ( card C154 ) + ( card C155 ) ) - 3 );
L516:
now
assume L517: C157 in ( dom ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) );
consider C163 being (Element of ( NAT )) such that L518: C157 = ( C163 + ( ( card ( C154 ';' C155 ) ) -' 1 ) ) and L519: C163 in ( dom ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L517 , L441;
L520: ( C163 + ( ( ( card C155 ) -' 1 ) + ( ( card C154 ) -' 1 ) ) ) <= ( ( - 1 ) + ( ( ( card C155 ) -' 1 ) + ( ( card C154 ) -' 1 ) ) ) by L438 , L445 , L447 , L448 , L515 , L518;
thus L521: contradiction by L520 , XREAL_1:6;
end;
L522: ( ( card C154 ) -' 1 ) <= ( card C154 ) by NAT_D:35;
L523: C157 = ( ( C158 -' ( ( card C154 ) -' 1 ) ) + ( ( card C154 ) -' 1 ) ) by L522 , L438 , L514 , XREAL_1:235 , XXREAL_0:2;
L524: ( ( card C154 ) - ( card C154 ) ) <= ( C158 - ( card C154 ) ) by L514 , XREAL_1:9;
L525: ( ( card C154 ) - 1 ) < ( ( card C154 ) - ( 0 ) ) by XREAL_1:15;
L526: ( C158 - ( ( card C154 ) - 1 ) ) >= ( 0 ) by L525 , L524 , XREAL_1:15;
L527: ( C158 - ( ( card C154 ) -' 1 ) ) >= ( 0 ) by L526 , PRE_CIRC:20;
L528: ( ( ( card C154 ) + ( card C155 ) ) - 3 ) < ( ( ( ( card C154 ) + ( card C155 ) ) - 3 ) + 1 ) by XREAL_1:29;
L529: C158 < ( ( ( card C155 ) - 1 ) + ( ( card C154 ) - 1 ) ) by L528 , L515 , XXREAL_0:2;
L530: ( ( C158 - ( ( card C154 ) - 1 ) ) + ( ( card C154 ) - 1 ) ) < ( ( ( card C155 ) - 1 ) + ( ( card C154 ) - 1 ) ) by L515 , L528 , XXREAL_0:2;
L531: ( C158 - ( ( card C154 ) - 1 ) ) < ( ( card C155 ) - 1 ) by L530 , XREAL_1:7;
L532: ( C158 - ( ( card C154 ) -' 1 ) ) < ( ( card C155 ) - 1 ) by L531 , PRE_CIRC:20;
L533: ( C158 -' ( ( card C154 ) -' 1 ) ) < ( ( card C155 ) - 1 ) by L532 , L527 , XREAL_0:def 2;
L534: ( C158 -' ( ( card C154 ) -' 1 ) ) < ( card ( CutLastLoc C155 ) ) by L533 , VALUED_1:38;
L535: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( CutLastLoc C155 ) ) by L534 , AFINSQ_1:66;
L536: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( ( dom ( CutLastLoc C155 ) ) \/ ( dom ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) ) ) by L535 , XBOOLE_0:def 3;
L537: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( C155 ';' C156 ) ) by L536 , FUNCT_4:def 1;
L538: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L537 , L133;
L539: C157 in ( dom ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L538 , L440 , L523;
L540: ( ( ( card C155 ) + ( card C154 ) ) - 2 ) < ( ( ( card C154 ) + ( card C155 ) ) - 1 ) by XREAL_1:15;
L541: C158 < ( ( ( card C154 ) + ( card C155 ) ) - 1 ) by L540 , L529 , XXREAL_0:2;
L542: C158 < ( card ( C154 ';' C155 ) ) by L541 , L220;
L543: C157 in ( dom ( C154 ';' C155 ) ) by L542 , L438 , AFINSQ_1:66;
L544:
now
assume L545: C157 in ( dom ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) );
L546: C157 in { ( LastLoc ( C154 ';' C155 ) ) } by L545 , FUNCOP_1:13;
L547: C157 = ( LastLoc ( C154 ';' C155 ) ) by L546 , TARSKI:def 1
.= ( ( card ( C154 ';' C155 ) ) -' 1 ) by AFINSQ_1:70;
L548: C158 = ( ( ( card C155 ) - 1 ) + ( ( card C154 ) - 1 ) ) by L547 , L438 , L445 , L448 , PRE_CIRC:20;
thus L549: contradiction by L548 , L515 , L528;
end;
L550: C157 in ( ( dom ( C154 ';' C155 ) ) \ ( dom ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) ) ) by L544 , L543 , XBOOLE_0:def 5;
L551: ( dom ( CutLastLoc C155 ) ) c= ( dom C155 ) by GRFUNC_1:2;
L552: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom C155 ) by L551 , L535;
L553: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( IncAddr (C155 , ( ( card C154 ) -' 1 )) ) ) by L552 , L133;
L554: C157 in ( dom ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) ) by L553 , L446 , L523;
L555:
now
assume L556: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) );
consider C164 being (Element of ( NAT )) such that L557: ( C158 -' ( ( card C154 ) -' 1 ) ) = ( C164 + ( ( card C155 ) -' 1 ) ) and L558: C164 in ( dom ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) ) by L556 , L442;
L559: C164 = ( ( C158 -' ( ( card C154 ) -' 1 ) ) - ( ( card C155 ) -' 1 ) ) by L557
.= ( ( C158 - ( ( card C154 ) -' 1 ) ) - ( ( card C155 ) -' 1 ) ) by L527 , XREAL_0:def 2
.= ( ( C158 - ( ( card C154 ) - 1 ) ) - ( ( card C155 ) -' 1 ) ) by PRE_CIRC:20
.= ( ( C158 - ( ( card C154 ) - 1 ) ) - ( ( card C155 ) - 1 ) ) by PRE_CIRC:20
.= ( C158 - ( ( ( card C154 ) + ( card C155 ) ) - 2 ) );
L560: ( C158 - ( ( ( card C154 ) + ( card C155 ) ) - 2 ) ) <= ( ( ( ( card C154 ) + ( card C155 ) ) - 3 ) - ( ( ( card C154 ) + ( card C155 ) ) - 2 ) ) by L515 , XREAL_1:9;
thus L561: contradiction by L560 , L559 , L65;
end;
L562: ( ( C155 ';' C156 ) /. ( C158 -' ( ( card C154 ) -' 1 ) ) ) = ( ( ( CutLastLoc C155 ) +* ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L537 , PARTFUN1:def 6
.= ( ( CutLastLoc C155 ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L555 , FUNCT_4:11
.= ( C155 . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L535 , GRFUNC_1:2;
thus L563: ( ( ( C154 ';' C155 ) ';' C156 ) . C157 ) = ( ( ( C154 ';' C155 ) \ ( ( LastLoc ( C154 ';' C155 ) ) .--> ( ( C154 ';' C155 ) . ( LastLoc ( C154 ';' C155 ) ) ) ) ) . C157 ) by L516 , FUNCT_4:11
.= ( ( ( CutLastLoc C154 ) +* ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) ) . C157 ) by L550 , GRFUNC_1:32
.= ( ( Reloc (C155 , ( ( card C154 ) -' 1 )) ) . C157 ) by L554 , FUNCT_4:13
.= ( ( IncAddr (C155 , ( ( card C154 ) -' 1 )) ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L523 , L553 , VALUED_1:def 12
.= ( IncAddr (( C155 /. ( C158 -' ( ( card C154 ) -' 1 ) ) ) , ( ( card C154 ) -' 1 )) ) by L535 , L551 , L133
.= ( IncAddr (( ( C155 ';' C156 ) /. ( C158 -' ( ( card C154 ) -' 1 ) ) ) , ( ( card C154 ) -' 1 )) ) by L535 , L551 , L562 , PARTFUN1:def 6
.= ( ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L537 , L133
.= ( ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . C157 ) by L523 , L538 , VALUED_1:def 12
.= ( ( C154 ';' ( C155 ';' C156 ) ) . C157 ) by L539 , FUNCT_4:13;
end;
suppose L564: C158 = ( ( ( card C154 ) + ( card C155 ) ) - 2 );

L565: C157 = ( ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) + ( ( card ( C154 ';' C155 ) ) -' 1 ) ) by L564 , L438 , L443 , XREAL_1:235;
L566: ( C158 - ( ( card ( C154 ';' C155 ) ) -' 1 ) ) = ( 0 ) by L443 , L564;
L567: ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) = ( 0 ) by L566 , XREAL_0:def 2;
L568: ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) in ( dom ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L567 , AFINSQ_1:65;
L569: C157 in ( dom ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L568 , L441 , L565;
L570: C157 = ( ( ( card C155 ) -' 1 ) + ( ( card C154 ) -' 1 ) ) by L438 , L447 , L448 , L564;
L571: ( ( ( card C155 ) - 1 ) + (( 0 ) qua Nat) ) < ( ( ( card C155 ) - 1 ) + ( card C156 ) ) by XREAL_1:6;
L572: ( ( card C155 ) -' 1 ) < ( ( ( card C155 ) + ( card C156 ) ) - 1 ) by L571 , PRE_CIRC:20;
L573: ( ( card C155 ) -' 1 ) < ( card ( C155 ';' C156 ) ) by L572 , L220;
L574: ( ( card C155 ) -' 1 ) in ( dom ( C155 ';' C156 ) ) by L573 , AFINSQ_1:66;
L575: ( ( card C155 ) -' 1 ) in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L574 , L133;
L576: C157 in ( dom ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L575 , L440 , L570;
L577: ( 0 ) in ( dom C156 ) by AFINSQ_1:65;
L578: ( ( C155 ';' C156 ) /. ( ( card C155 ) -' 1 ) ) = ( ( C155 ';' C156 ) . ( ( card C155 ) -' 1 ) ) by L574 , PARTFUN1:def 6;
L579: ( 0 ) in ( dom ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) ) by AFINSQ_1:65;
L580: ( ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) /. ( 0 ) ) = ( ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) . ( 0 ) ) by L579 , PARTFUN1:def 6
.= ( IncAddr (( C156 /. ( 0 ) ) , ( ( card C155 ) -' 1 )) ) by L577 , L133;
L581: ( ( C155 ';' C156 ) /. ( ( card C155 ) -' 1 ) ) = ( ( C155 ';' C156 ) . ( LastLoc C155 ) ) by L578 , AFINSQ_1:70
.= ( ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) . ( 0 ) ) by L313
.= ( ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) /. ( 0 ) ) by L579 , PARTFUN1:def 6;
L582: ( IncAddr (( ( C155 ';' C156 ) /. ( ( card C155 ) -' 1 ) ) , ( ( card C154 ) -' 1 )) ) = ( IncAddr (( C156 /. ( 0 ) ) , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) by L581 , L445 , L580 , COMPOS_0:7;
thus L583: ( ( ( C154 ';' C155 ) ';' C156 ) . C157 ) = ( ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) . C157 ) by L569 , FUNCT_4:13
.= ( ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) . ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) ) by L565 , L568 , VALUED_1:def 12
.= ( IncAddr (( C156 /. ( 0 ) ) , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) by L567 , L577 , L133
.= ( ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . ( ( card C155 ) -' 1 ) ) by L574 , L582 , L133
.= ( ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . C157 ) by L570 , L575 , VALUED_1:def 12
.= ( ( C154 ';' ( C155 ';' C156 ) ) . C157 ) by L576 , FUNCT_4:13;
end;
suppose L584: ( ( ( card C154 ) + ( card C155 ) ) - 2 ) < C158;

L585: C157 = ( ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) + ( ( card ( C154 ';' C155 ) ) -' 1 ) ) by L584 , L438 , L443 , XREAL_1:235;
L586: ( C158 + (( 0 ) qua Nat) ) < ( ( ( ( card C154 ) + ( card C155 ) ) - ( 1 + 1 ) ) + ( card C156 ) ) by L439;
L587: ( C158 - ( ( ( card C154 ) + ( card C155 ) ) - ( 1 + 1 ) ) ) < ( ( card C156 ) - ( 0 ) ) by L586 , XREAL_1:21;
L588: ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) < ( card C156 ) by L587 , L443 , XREAL_0:def 2;
L589: ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) in ( dom C156 ) by L588 , AFINSQ_1:66;
L590: ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) in ( dom ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L589 , L133;
L591: C157 in ( dom ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) ) by L590 , L441 , L585;
L592: ( ( card C154 ) -' 1 ) <= ( ( ( card C155 ) -' 1 ) + ( ( card C154 ) -' 1 ) ) by NAT_1:11;
L593: C158 >= ( ( card C154 ) -' 1 ) by L592 , L443 , L445 , L584 , XXREAL_0:2;
L594: C157 = ( ( C158 -' ( ( card C154 ) -' 1 ) ) + ( ( card C154 ) -' 1 ) ) by L438 , L443 , L445 , L584 , L592 , XREAL_1:235 , XXREAL_0:2;
L595: ( C158 - ( ( card C154 ) -' 1 ) ) >= ( 0 ) by L593 , XREAL_1:48;
L596: ( C158 - ( ( card C154 ) -' 1 ) ) < ( ( ( ( ( ( card C154 ) + ( card C155 ) ) + ( card C156 ) ) - 1 ) - 1 ) - ( ( card C154 ) -' 1 ) ) by L439 , XREAL_1:9;
L597: ( C158 -' ( ( card C154 ) -' 1 ) ) < ( ( ( ( ( card C154 ) + ( card C155 ) ) + ( card C156 ) ) - ( card C154 ) ) - 1 ) by L596 , L447 , L595 , XREAL_0:def 2;
L598: ( C158 -' ( ( card C154 ) -' 1 ) ) < ( ( ( ( ( card C154 ) - ( card C154 ) ) + ( card C155 ) ) + ( card C156 ) ) - 1 ) by L447 , L595 , L596 , XREAL_0:def 2;
L599: ( C158 -' ( ( card C154 ) -' 1 ) ) < ( card ( C155 ';' C156 ) ) by L598 , L220;
L600: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( C155 ';' C156 ) ) by L599 , AFINSQ_1:66;
L601: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L600 , L133;
L602: C157 in ( dom ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L601 , L440 , L594;
L603: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) ) by L600 , L133;
L604: ( C158 - ( ( card C154 ) -' 1 ) ) >= ( ( ( card ( C154 ';' C155 ) ) -' 1 ) - ( ( card C154 ) -' 1 ) ) by L443 , L584 , XREAL_1:9;
L605: ( C158 -' ( ( card C154 ) -' 1 ) ) >= ( ( ( ( card C154 ) -' 1 ) + ( ( card C155 ) -' 1 ) ) - ( ( card C154 ) -' 1 ) ) by L604 , L443 , L445 , L584 , L592 , XREAL_1:233 , XXREAL_0:2;
L606: ( C158 -' ( ( card C154 ) -' 1 ) ) >= ( ( card C155 ) -' 1 ) by L443 , L445 , L584 , L592 , L604 , XREAL_1:233 , XXREAL_0:2;
L607: ( C158 -' ( ( card C154 ) -' 1 ) ) = ( ( ( C158 -' ( ( card C154 ) -' 1 ) ) -' ( ( card C155 ) -' 1 ) ) + ( ( card C155 ) -' 1 ) ) by L605 , XREAL_1:235;
L608: ( ( C158 -' ( ( card C154 ) -' 1 ) ) - ( ( card C155 ) -' 1 ) ) < ( ( ( ( card C155 ) + ( card C156 ) ) - 1 ) - ( ( card C155 ) - 1 ) ) by L448 , L597 , XREAL_1:9;
L609: ( ( C158 -' ( ( card C154 ) -' 1 ) ) -' ( ( card C155 ) -' 1 ) ) < ( ( ( card C156 ) + ( ( card C155 ) - 1 ) ) - ( ( card C155 ) - 1 ) ) by L608 , L606 , XREAL_1:233;
L610: ( ( C158 -' ( ( card C154 ) -' 1 ) ) -' ( ( card C155 ) -' 1 ) ) in ( dom C156 ) by L609 , AFINSQ_1:66;
L611: ( ( C158 -' ( ( card C154 ) -' 1 ) ) -' ( ( card C155 ) -' 1 ) ) in ( dom ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) ) by L610 , L133;
L612: ( C158 -' ( ( card C154 ) -' 1 ) ) in ( dom ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) ) by L611 , L442 , L607;
L613: ( ( C158 -' ( ( card C154 ) -' 1 ) ) -' ( ( card C155 ) -' 1 ) ) = ( ( C158 -' ( ( card C154 ) -' 1 ) ) - ( ( card C155 ) -' 1 ) ) by L605 , XREAL_1:233
.= ( ( C158 - ( ( card C154 ) -' 1 ) ) - ( ( card C155 ) -' 1 ) ) by L443 , L445 , L584 , L592 , XREAL_1:233 , XXREAL_0:2
.= ( C158 - ( ( ( card C154 ) -' 1 ) + ( ( card C155 ) -' 1 ) ) )
.= ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) by L443 , L445 , L584 , XREAL_1:233;
L614: ( ( C155 ';' C156 ) /. ( C158 -' ( ( card C154 ) -' 1 ) ) ) = ( ( ( CutLastLoc C155 ) +* ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L600 , PARTFUN1:def 6
.= ( ( Reloc (C156 , ( ( card C155 ) -' 1 )) ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L612 , FUNCT_4:13
.= ( ( IncAddr (C156 , ( ( card C155 ) -' 1 )) ) . ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) ) by L607 , L611 , L613 , VALUED_1:def 12
.= ( IncAddr (( C156 /. ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) ) , ( ( card C155 ) -' 1 )) ) by L589 , L133;
thus L615: ( ( ( C154 ';' C155 ) ';' C156 ) . C157 ) = ( ( Reloc (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) . C157 ) by L591 , FUNCT_4:13
.= ( ( IncAddr (C156 , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) . ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) ) by L585 , L590 , VALUED_1:def 12
.= ( IncAddr (( C156 /. ( C158 -' ( ( card ( C154 ';' C155 ) ) -' 1 ) ) ) , ( ( card ( C154 ';' C155 ) ) -' 1 )) ) by L589 , L133
.= ( IncAddr (( ( C155 ';' C156 ) /. ( C158 -' ( ( card C154 ) -' 1 ) ) ) , ( ( card C154 ) -' 1 )) ) by L445 , L614 , COMPOS_0:7
.= ( ( IncAddr (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . ( C158 -' ( ( card C154 ) -' 1 ) ) ) by L600 , L133
.= ( ( Reloc (( C155 ';' C156 ) , ( ( card C154 ) -' 1 )) ) . C157 ) by L594 , L603 , VALUED_1:def 12
.= ( ( C154 ';' ( C155 ';' C156 ) ) . C157 ) by L602 , FUNCT_4:13;
end;
end;
thus L617: thesis by L436 , L434 , L435 , FUNCT_1:2;
end;
end;
canceled 1;
theorem
L619: (for B83 being (Instruction of ( Trivial-COM )) holds ( JumpPart B83 ) = ( 0 )) by L85;
begin
theorem
L620: (for R37 being COM-Struct holds (for B84 being Nat holds (for B85 being  finite ( NAT ) -defined (the InstructionsF of R37) -valued Function holds ( dom ( Reloc (B85 , B84) ) ) = ( dom ( Shift (B85 , B84) ) ))))
proof
let R37 being COM-Struct;
let C165 being Nat;
let C166 being  finite ( NAT ) -defined (the InstructionsF of R37) -valued Function;
L621: ( dom ( IncAddr (C166 , C165) ) ) = ( dom C166 ) by L133;
thus L622: ( dom ( Reloc (C166 , C165) ) ) = { ( B86 + C165 ) where B86 is (Element of ( NAT )) : B86 in ( dom C166 ) } by L621 , VALUED_1:def 12
.= ( dom ( Shift (C166 , C165) ) ) by VALUED_1:def 12;
end;
theorem
L623: (for R37 being COM-Struct holds (for B87 being Nat holds (for B88 being  finite ( NAT ) -defined (the InstructionsF of R37) -valued Function holds ( dom ( Reloc (B88 , B87) ) ) = { ( B89 + B87 ) where B89 is (Element of ( NAT )) : B89 in ( dom B88 ) })))
proof
let R37 being COM-Struct;
let C167 being Nat;
let C168 being  finite ( NAT ) -defined (the InstructionsF of R37) -valued Function;
thus L624: ( dom ( Reloc (C168 , C167) ) ) = ( dom ( Shift (C168 , C167) ) ) by L620
.= { ( B90 + C167 ) where B90 is (Element of ( NAT )) : B90 in ( dom C168 ) } by VALUED_1:def 12;
end;
theorem
L625: (for R37 being COM-Struct holds (for B91 , B92 being Nat holds (for B93 being ( NAT ) -defined (the InstructionsF of R37) -valued  finite Function holds ( Shift (( IncAddr (B93 , B91) ) , B92) ) = ( IncAddr (( Shift (B93 , B92) ) , B91) ))))
proof
let R37 being COM-Struct;
let C169 , C170 being Nat;
let C171 being ( NAT ) -defined (the InstructionsF of R37) -valued  finite Function;
set D32 = ( Shift (( IncAddr (C171 , C169) ) , C170) );
set D33 = ( IncAddr (( Shift (C171 , C170) ) , C169) );
L626: ( dom ( IncAddr (C171 , C169) ) ) = ( dom C171 ) by L133;
L627: ( dom ( Shift (C171 , C170) ) ) = { ( B94 + C170 ) where B94 is (Element of ( NAT )) : B94 in ( dom ( IncAddr (C171 , C169) ) ) } by L626 , VALUED_1:def 12
.= ( dom D32 ) by VALUED_1:def 12;
L628: ( dom D32 ) = ( dom D33 ) by L627 , L133;
L629:
now
let C172 being set;
L630: ( dom D32 ) c= ( NAT ) by RELAT_1:def 18;
assume L631: C172 in ( dom D32 );
reconsider D34 = C172 as (Element of ( NAT )) by L631 , L630;
reconsider D35 = D34 as (Element of ( NAT ));
L632: C172 in { ( B95 + C170 ) where B95 is (Element of ( NAT )) : B95 in ( dom ( IncAddr (C171 , C169) ) ) } by L631 , VALUED_1:def 12;
consider C173 being (Element of ( NAT )) such that L633: C172 = ( C173 + C170 ) and L634: C173 in ( dom ( IncAddr (C171 , C169) ) ) by L632;
L635: C173 in ( dom C171 ) by L634 , L133;
L636: ( dom ( Shift (C171 , C170) ) ) = { ( B96 + C170 ) where B96 is (Element of ( NAT )) : B96 in ( dom C171 ) } by VALUED_1:def 12;
L637: D34 in ( dom ( Shift (C171 , C170) ) ) by L636 , L633 , L635;
reconsider D36 = C173 as (Element of ( NAT ));
L638: ( C171 /. D36 ) = ( C171 . C173 ) by L635 , PARTFUN1:def 6
.= ( ( Shift (C171 , C170) ) . ( C173 + C170 ) ) by L635 , VALUED_1:def 12
.= ( ( Shift (C171 , C170) ) /. D35 ) by L633 , L637 , PARTFUN1:def 6;
thus L639: ( D32 . C172 ) = ( ( IncAddr (C171 , C169) ) . C173 ) by L634 , L633 , VALUED_1:def 12
.= ( IncAddr (( ( Shift (C171 , C170) ) /. D35 ) , C169) ) by L635 , L638 , L133
.= ( D33 . C172 ) by L637 , L133;
end;
thus L640: thesis by L629 , L628 , FUNCT_1:2;
end;
theorem
L641: (for R36 being Nat holds (for R37 being COM-Struct holds (for B97 being ( NAT ) -defined (the InstructionsF of R37) -valued  finite Function holds (for B98 being Nat holds (for B99 being (Instruction of R37) holds ((R36 in ( dom B97 ) & B99 = ( B97 . R36 )) implies ( IncAddr (B99 , B98) ) = ( ( Reloc (B97 , B98) ) . ( R36 + B98 ) )))))))
proof
let R36 being Nat;
let R37 being COM-Struct;
let C174 being ( NAT ) -defined (the InstructionsF of R37) -valued  finite Function;
let C175 being Nat;
let C176 being (Instruction of R37);
assume that
L642: R36 in ( dom C174 )
and
L643: C176 = ( C174 . R36 );
reconsider D37 = R36 as (Element of ( NAT )) by ORDINAL1:def 12;
L644: R36 in ( dom ( IncAddr (C174 , C175) ) ) by L642 , L133;
thus L645: ( ( Reloc (C174 , C175) ) . ( R36 + C175 ) ) = ( ( IncAddr (C174 , C175) ) . D37 ) by L644 , VALUED_1:def 12
.= ( IncAddr (( C174 /. D37 ) , C175) ) by L642 , L133
.= ( IncAddr (C176 , C175) ) by L642 , L643 , PARTFUN1:def 6;
end;
definition
let C177 being COM-Struct;
let C178 being (Instruction of C177);
redefine func Load C178 -> (preProgram of C177);

coherence;
end;
definition
let C179 being COM-Struct;
let C180 being  initial (preProgram of C179);
func stop C180 -> (preProgram of C179) equals 
( C180 ^ ( Stop C179 ) );
coherence;
end;
registration
let C181 being COM-Struct;
let C182 being  initial (preProgram of C181);
cluster ( stop C182 ) ->  initial non  empty;
correctness;
end;
theorem
L649: (for R38 being COM-Struct holds (for R42 being (Program of R38) holds ( 0 ) in ( dom ( stop R42 ) )))
proof
let R38 being COM-Struct;
let R42 being (Program of R38);
L650: ( card ( stop R42 ) ) = ( ( card R42 ) + ( card ( Stop R38 ) ) ) by AFINSQ_1:17
.= ( ( card R42 ) + 1 ) by AFINSQ_1:33;
thus L651: thesis by L650 , AFINSQ_1:66;
end;
begin
definition
let C183 being COM-Struct;
let C184 being (Instruction of C183);
func Macro C184 -> (preProgram of C183) equals 
( stop ( Load C184 ) );
coherence;
end;
registration
let R38 being COM-Struct;
let R52 being (Instruction of R38);
cluster ( Macro R52 ) ->  initial non  empty;
coherence;
end;
begin
registration
let C185 being COM-Struct;
cluster ( Stop C185 ) -> non  halt-free;
coherence
proof
L654: ( rng ( Stop C185 ) ) = { ( halt C185 ) } by AFINSQ_1:33;
thus L655: ( halt C185 ) in ( rng ( Stop C185 ) ) by L654 , TARSKI:def 1;
end;
end;
registration
let C186 being COM-Struct;
cluster non  halt-free  finite for (Program of C186);
existence
proof
take ( Stop C186 );
thus L657: thesis;
end;
end;
registration
let C187 being COM-Struct;
let C188 being ( NAT ) -defined (the InstructionsF of C187) -valued Function;
let C189 being non  halt-free ( NAT ) -defined (the InstructionsF of C187) -valued Function;
cluster ( C188 +* C189 ) -> non  halt-free;
coherence
proof
L659: ( halt C187 ) in ( rng C189 ) by L7;
L660: ( rng C189 ) c= ( rng ( C188 +* C189 ) ) by FUNCT_4:18;
thus L661: ( halt C187 ) in ( rng ( C188 +* C189 ) ) by L660 , L659;
end;
end;
registration
let C190 being COM-Struct;
let C191 being  finite non  halt-free ( NAT ) -defined (the InstructionsF of C190) -valued Function;
let C192 being Nat;
cluster ( Reloc (C191 , C192) ) -> non  halt-free;
coherence
proof
L663: ( dom C191 ) c= ( NAT ) by RELAT_1:def 18;
L664: ( halt C190 ) in ( rng C191 ) by L7;
consider C193 being set such that L665: C193 in ( dom C191 ) and L666: ( C191 . C193 ) = ( halt C190 ) by L664 , FUNCT_1:def 3;
L667: C193 in ( dom ( IncAddr (C191 , C192) ) ) by L665 , L133;
L668: ( dom ( IncAddr (C191 , C192) ) ) c= ( NAT ) by RELAT_1:def 18;
reconsider D38 = C193 as (Element of ( NAT )) by L663 , L665;
L669: ( ( IncAddr (C191 , C192) ) . D38 ) = ( IncAddr (( C191 /. D38 ) , C192) ) by L665 , L133
.= ( IncAddr (( halt C190 ) , C192) ) by L666 , L665 , PARTFUN1:def 6
.= ( halt C190 ) by COMPOS_0:4;
L670: ( halt C190 ) in ( rng ( IncAddr (C191 , C192) ) ) by L669 , L667 , FUNCT_1:3;
thus L671: ( halt C190 ) in ( rng ( Reloc (C191 , C192) ) ) by L670 , L668 , VALUED_1:26;
end;
end;
registration
let C194 being COM-Struct;
cluster non  halt-free non  empty for (Program of C194);
existence
proof
take ( Stop C194 );
thus L673: thesis;
end;
end;
canceled 4;
theorem
L675: (for R34 being Nat holds (for B100 being COM-Struct holds (for B101 , B102 being  finite ( NAT ) -defined (the InstructionsF of B100) -valued Function holds ( IncAddr (( B101 +* B102 ) , R34) ) = ( ( IncAddr (B101 , R34) ) +* ( IncAddr (B102 , R34) ) ))))
proof
let R34 being Nat;
let C195 being COM-Struct;
let C196 , C197 being  finite ( NAT ) -defined (the InstructionsF of C195) -valued Function;
L676: ( dom ( IncAddr (C197 , R34) ) ) = ( dom C197 ) by L133;
L677:
now
let C198 being Nat;
assume that
L678: C198 in ( dom ( C196 +* C197 ) );
per cases ;
suppose L679: C198 in ( dom C197 );

L680: ( ( C196 +* C197 ) /. C198 ) = ( ( C196 +* C197 ) . C198 ) by L678 , PARTFUN1:def 6
.= ( C197 . C198 ) by L679 , FUNCT_4:13
.= ( C197 /. C198 ) by L679 , PARTFUN1:def 6;
thus L681: ( ( ( IncAddr (C196 , R34) ) +* ( IncAddr (C197 , R34) ) ) . C198 ) = ( ( IncAddr (C197 , R34) ) . C198 ) by L676 , L679 , FUNCT_4:13
.= ( IncAddr (( ( C196 +* C197 ) /. C198 ) , R34) ) by L679 , L680 , L133;
end;
suppose L682: (not C198 in ( dom C197 ));

L683: C198 in ( ( dom C196 ) \/ ( dom C197 ) ) by L678 , FUNCT_4:def 1;
L684: C198 in ( dom C196 ) by L683 , L682 , XBOOLE_0:def 3;
L685: ( ( C196 +* C197 ) /. C198 ) = ( ( C196 +* C197 ) . C198 ) by L678 , PARTFUN1:def 6
.= ( C196 . C198 ) by L682 , FUNCT_4:11
.= ( C196 /. C198 ) by L684 , PARTFUN1:def 6;
thus L686: ( ( ( IncAddr (C196 , R34) ) +* ( IncAddr (C197 , R34) ) ) . C198 ) = ( ( IncAddr (C196 , R34) ) . C198 ) by L676 , L682 , FUNCT_4:11
.= ( IncAddr (( ( C196 +* C197 ) /. C198 ) , R34) ) by L684 , L685 , L133;
end;
end;
L688: ( dom ( IncAddr (C196 , R34) ) ) = ( dom C196 ) by L133;
L689: ( dom ( ( IncAddr (C196 , R34) ) +* ( IncAddr (C197 , R34) ) ) ) = ( ( dom C196 ) \/ ( dom C197 ) ) by L688 , L676 , FUNCT_4:def 1
.= ( dom ( C196 +* C197 ) ) by FUNCT_4:def 1;
thus L690: ( IncAddr (( C196 +* C197 ) , R34) ) = ( ( IncAddr (C196 , R34) ) +* ( IncAddr (C197 , R34) ) ) by L689 , L677 , L133;
end;
theorem
L691: (for B103 being COM-Struct holds (for B104 , B105 being  finite ( NAT ) -defined (the InstructionsF of B103) -valued Function holds (for B106 being Nat holds ( Reloc (( B104 +* B105 ) , B106) ) = ( ( Reloc (B104 , B106) ) +* ( Reloc (B105 , B106) ) ))))
proof
let C199 being COM-Struct;
let C200 , C201 being  finite ( NAT ) -defined (the InstructionsF of C199) -valued Function;
let C202 being Nat;
L692: ( Reloc (( C200 +* C201 ) , C202) ) = ( IncAddr (( Shift (( C200 +* C201 ) , C202) ) , C202) ) by L625;
L693: ( Reloc (C200 , C202) ) = ( IncAddr (( Shift (C200 , C202) ) , C202) ) by L625;
L694: ( Reloc (C201 , C202) ) = ( IncAddr (( Shift (C201 , C202) ) , C202) ) by L625;
thus L695: ( Reloc (( C200 +* C201 ) , C202) ) = ( IncAddr (( ( Shift (C200 , C202) ) +* ( Shift (C201 , C202) ) ) , C202) ) by L692 , VALUED_1:23
.= ( ( Reloc (C200 , C202) ) +* ( Reloc (C201 , C202) ) ) by L693 , L694 , L675;
end;
theorem
L696: (for B107 being COM-Struct holds (for B108 being  finite ( NAT ) -defined (the InstructionsF of B107) -valued Function holds (for B109 , B110 being Nat holds ( Reloc (( Reloc (B108 , B109) ) , B110) ) = ( Reloc (B108 , ( B109 + B110 )) ))))
proof
let C203 being COM-Struct;
let C204 being  finite ( NAT ) -defined (the InstructionsF of C203) -valued Function;
let C205 , C206 being Nat;
thus L697: ( Reloc (( Reloc (C204 , C205) ) , C206) ) = ( Shift (( Shift (( IncAddr (( IncAddr (C204 , C205) ) , C206) ) , C205) ) , C206) ) by L625
.= ( Shift (( Shift (( IncAddr (C204 , ( C205 + C206 )) ) , C205) ) , C206) ) by L179
.= ( Reloc (C204 , ( C205 + C206 )) ) by VALUED_1:21;
end;
theorem
L698: (for B111 being COM-Struct holds (for B112 , B113 being ( NAT ) -defined (the InstructionsF of B111) -valued  finite Function holds (for B114 being Nat holds (B112 c= B113 implies ( Reloc (B112 , B114) ) c= ( Reloc (B113 , B114) )))))
proof
let C207 being COM-Struct;
let C208 , C209 being ( NAT ) -defined (the InstructionsF of C207) -valued  finite Function;
let C210 being Nat;
set D39 = ( Reloc (C208 , C210) );
set D40 = ( Reloc (C209 , C210) );
L699: ( dom ( Reloc (C208 , C210) ) ) = { ( B115 + C210 ) where B115 is (Element of ( NAT )) : B115 in ( dom C208 ) } by L623;
L700: ( dom ( Shift (C208 , C210) ) ) = { ( B116 + C210 ) where B116 is (Element of ( NAT )) : B116 in ( dom C208 ) } by VALUED_1:def 12;
L701: ( dom ( Shift (C209 , C210) ) ) = { ( B117 + C210 ) where B117 is (Element of ( NAT )) : B117 in ( dom C209 ) } by VALUED_1:def 12;
L702: D40 = ( IncAddr (( Shift (C209 , C210) ) , C210) ) by L625;
assume L703: C208 c= C209;
L704: ( Shift (C208 , C210) ) c= ( Shift (C209 , C210) ) by L703 , VALUED_1:20;
L705: ( dom C208 ) c= ( dom C209 ) by L703 , GRFUNC_1:2;
L706:
now
let C211 being set;
assume L707: C211 in ( dom ( Reloc (C208 , C210) ) );
consider C212 being (Element of ( NAT )) such that L708: C211 = ( C212 + C210 ) and L709: C212 in ( dom C208 ) by L707 , L699;
L710: ( C212 + C210 ) in ( dom ( Shift (C209 , C210) ) ) by L705 , L701 , L709;
L711: ( C212 + C210 ) in ( dom ( Shift (C208 , C210) ) ) by L700 , L709;
L712: ( ( Shift (C208 , C210) ) /. ( C212 + C210 ) ) = ( ( Shift (C208 , C210) ) . ( C212 + C210 ) ) by L711 , PARTFUN1:def 6
.= ( ( Shift (C209 , C210) ) . ( C212 + C210 ) ) by L704 , L711 , GRFUNC_1:2
.= ( ( Shift (C209 , C210) ) /. ( C212 + C210 ) ) by L710 , PARTFUN1:def 6;
thus L713: ( D39 . C211 ) = ( ( IncAddr (( Shift (C208 , C210) ) , C210) ) . C211 ) by L625
.= ( IncAddr (( ( Shift (C209 , C210) ) /. ( C212 + C210 ) ) , C210) ) by L711 , L712 , L708 , L133
.= ( D40 . C211 ) by L708 , L710 , L702 , L133;
end;
L714: ( dom ( Shift (C208 , C210) ) ) c= ( dom ( Shift (C209 , C210) ) ) by L704 , GRFUNC_1:2;
L715:
now
let C213 being set;
assume L716: C213 in ( dom D39 );
L717: C213 in ( dom ( Shift (C208 , C210) ) ) by L716 , L620;
L718: C213 in ( dom ( Shift (C209 , C210) ) ) by L717 , L714;
thus L719: C213 in ( dom D40 ) by L718 , L620;
end;
L720: ( dom D39 ) c= ( dom D40 ) by L715 , TARSKI:def 3;
thus L721: thesis by L720 , L706 , GRFUNC_1:2;
end;
registration
let C214 being COM-Struct;
let C215 being (preProgram of C214);
reduce ( Reloc (C215 , ( 0 )) ) to C215;
reducibility;
end;
theorem
L723: (for B118 being COM-Struct holds (for B119 being (preProgram of B118) holds ( Reloc (B119 , ( 0 )) ) = B119));
theorem
L724: (for R36 being Nat holds (for B120 being COM-Struct holds (for B121 being Nat holds (for B122 being (preProgram of B120) holds (R36 in ( dom B122 ) iff ( R36 + B121 ) in ( dom ( Reloc (B122 , B121) ) ))))))
proof
let R36 being Nat;
let C216 being COM-Struct;
let C217 being Nat;
let C218 being (preProgram of C216);
L725: ( dom ( Reloc (C218 , C217) ) ) = { ( B123 + C217 ) where B123 is (Element of ( NAT )) : B123 in ( dom C218 ) } by L623;
reconsider D41 = R36 as (Element of ( NAT )) by ORDINAL1:def 12;
L726: (D41 in ( dom C218 ) implies ( D41 + C217 ) in ( dom ( Reloc (C218 , C217) ) )) by L725;
thus L727: (R36 in ( dom C218 ) implies ( R36 + C217 ) in ( dom ( Reloc (C218 , C217) ) )) by L726;
assume L728: ( R36 + C217 ) in ( dom ( Reloc (C218 , C217) ) );
L729: (ex B124 being (Element of ( NAT )) st (( R36 + C217 ) = ( B124 + C217 ) & B124 in ( dom C218 ))) by L728 , L725;
thus L730: thesis by L729;
end;
theorem
L731: (for R34 being Nat holds (for B125 being COM-Struct holds (for B126 being (Instruction of B125) holds (for B127 being (Function of (the InstructionsF of B125) , (the InstructionsF of B125)) holds (B127 = ( ( id (the InstructionsF of B125) ) +* ( ( halt B125 ) .--> B126 ) ) implies (for B128 being  finite ( NAT ) -defined (the InstructionsF of B125) -valued Function holds ( IncAddr (( B127 * B128 ) , R34) ) = ( ( ( id (the InstructionsF of B125) ) +* ( ( halt B125 ) .--> ( IncAddr (B126 , R34) ) ) ) * ( IncAddr (B128 , R34) ) )))))))
proof
let R34 being Nat;
let C219 being COM-Struct;
let C220 being (Instruction of C219);
let C221 being (Function of (the InstructionsF of C219) , (the InstructionsF of C219));
assume that
L732: C221 = ( ( id (the InstructionsF of C219) ) +* ( ( halt C219 ) .--> C220 ) );
let C222 being  finite ( NAT ) -defined (the InstructionsF of C219) -valued Function;
L733: ( rng ( ( halt C219 ) .--> ( IncAddr (C220 , R34) ) ) ) = { ( IncAddr (C220 , R34) ) } by FUNCOP_1:8;
L734: ( rng ( ( id (the InstructionsF of C219) ) +* ( ( halt C219 ) .--> ( IncAddr (C220 , R34) ) ) ) ) c= ( ( rng ( id (the InstructionsF of C219) ) ) \/ { ( IncAddr (C220 , R34) ) } ) by L733 , FUNCT_4:17;
L735: ( ( rng ( id (the InstructionsF of C219) ) ) \/ { ( IncAddr (C220 , R34) ) } ) = (the InstructionsF of C219) by ZFMISC_1:40;
L736: ( dom ( ( halt C219 ) .--> ( IncAddr (C220 , R34) ) ) ) = { ( halt C219 ) } by FUNCOP_1:13;
L737: ( dom ( ( id (the InstructionsF of C219) ) +* ( ( halt C219 ) .--> ( IncAddr (C220 , R34) ) ) ) ) = ( ( dom ( id (the InstructionsF of C219) ) ) \/ { ( halt C219 ) } ) by L736 , FUNCT_4:def 1
.= (the InstructionsF of C219) by ZFMISC_1:40;
reconsider D42 = ( ( id (the InstructionsF of C219) ) +* ( ( halt C219 ) .--> ( IncAddr (C220 , R34) ) ) ) as (Function of (the InstructionsF of C219) , (the InstructionsF of C219)) by L737 , L734 , L735 , RELSET_1:4;
L738: ( dom ( IncAddr (C222 , R34) ) ) = ( dom C222 ) by L133
.= ( dom ( C221 * C222 ) ) by FUNCT_2:123;
L739: ( dom ( ( halt C219 ) .--> C220 ) ) = { ( halt C219 ) } by FUNCOP_1:13;
L740:
now
let C223 being Nat;
assume L741: C223 in ( dom ( C221 * C222 ) );
L742: C223 in ( dom C222 ) by L741 , FUNCT_2:123;
per cases ;
suppose L743: ( C222 . C223 ) = ( halt C219 );

reconsider D43 = C223 as (Element of ( NAT )) by ORDINAL1:def 12;
L744: ( ( IncAddr (C222 , R34) ) . C223 ) = ( IncAddr (( C222 /. D43 ) , R34) ) by L742 , L133
.= ( IncAddr (( halt C219 ) , R34) ) by L742 , L743 , PARTFUN1:def 6
.= ( halt C219 ) by COMPOS_0:4;
L745: ( halt C219 ) in { ( halt C219 ) } by TARSKI:def 1;
L746: ( ( C221 * C222 ) /. C223 ) = ( ( C221 * C222 ) . C223 ) by L741 , PARTFUN1:def 6
.= ( C221 . ( halt C219 ) ) by L742 , L743 , FUNCT_1:13
.= ( ( ( halt C219 ) .--> C220 ) . ( halt C219 ) ) by L732 , L739 , L745 , FUNCT_4:13
.= C220 by FUNCOP_1:72;
thus L747: ( ( D42 * ( IncAddr (C222 , R34) ) ) . C223 ) = ( D42 . ( ( IncAddr (C222 , R34) ) . C223 ) ) by L738 , L741 , FUNCT_1:13
.= ( ( ( halt C219 ) .--> ( IncAddr (C220 , R34) ) ) . ( ( IncAddr (C222 , R34) ) . C223 ) ) by L736 , L744 , L745 , FUNCT_4:13
.= ( IncAddr (( ( C221 * C222 ) /. C223 ) , R34) ) by L744 , L746 , FUNCOP_1:72;
end;
suppose L748: ( C222 . C223 ) <> ( halt C219 );

L749: ( C222 /. C223 ) = ( C222 . C223 ) by L742 , PARTFUN1:def 6;
L750: (not ( IncAddr (( C222 /. C223 ) , R34) ) = ( halt C219 )) by COMPOS_0:12 , L748 , L749;
L751: (not ( C222 /. C223 ) in { ( halt C219 ) }) by L748 , L749 , TARSKI:def 1;
L752: (not ( IncAddr (( C222 /. C223 ) , R34) ) in { ( halt C219 ) }) by L750 , TARSKI:def 1;
L753: ( ( C221 * C222 ) /. C223 ) = ( ( C221 * C222 ) . C223 ) by L741 , PARTFUN1:def 6
.= ( C221 . ( C222 . C223 ) ) by L742 , FUNCT_1:13
.= ( ( id (the InstructionsF of C219) ) . ( C222 /. C223 ) ) by L732 , L739 , L749 , L751 , FUNCT_4:11
.= ( C222 /. C223 ) by FUNCT_1:18;
thus L754: ( ( D42 * ( IncAddr (C222 , R34) ) ) . C223 ) = ( D42 . ( ( IncAddr (C222 , R34) ) . C223 ) ) by L738 , L741 , FUNCT_1:13
.= ( D42 . ( IncAddr (( C222 /. C223 ) , R34) ) ) by L742 , L133
.= ( ( id (the InstructionsF of C219) ) . ( IncAddr (( C222 /. C223 ) , R34) ) ) by L736 , L752 , FUNCT_4:11
.= ( IncAddr (( ( C221 * C222 ) /. C223 ) , R34) ) by L753 , FUNCT_1:18;
end;
end;
L756: ( dom ( D42 * ( IncAddr (C222 , R34) ) ) ) = ( dom ( IncAddr (C222 , R34) ) ) by FUNCT_2:123;
thus L757: thesis by L756 , L738 , L740 , L133;
end;
theorem
L758: (for R59 being COM-Struct holds (for R60 being (Program of R59) holds (for R61 being (Program of R59) holds ( dom R60 ) misses ( dom ( Reloc (R61 , ( card R60 )) ) ))))
proof
let R59 being COM-Struct;
let R60 being (Program of R59);
let R61 being (Program of R59);
assume L759: ( dom R60 ) meets ( dom ( Reloc (R61 , ( card R60 )) ) );
L760: ( dom ( Reloc (R61 , ( card R60 )) ) ) = ( dom ( Shift (R61 , ( card R60 )) ) ) by L620
.= { ( B129 + ( card R60 ) ) where B129 is (Element of ( NAT )) : B129 in ( dom R61 ) } by VALUED_1:def 12;
consider C224 being set such that L761: C224 in ( dom R60 ) and L762: C224 in { ( B130 + ( card R60 ) ) where B130 is (Element of ( NAT )) : B130 in ( dom R61 ) } by L760 , L759 , XBOOLE_0:3;
consider C225 being (Element of ( NAT )) such that L763: C224 = ( C225 + ( card R60 ) ) and L764: C225 in ( dom R61 ) by L762;
L765: ( C225 + ( card R60 ) ) < ( card R60 ) by L761 , L763 , AFINSQ_1:66;
thus L766: contradiction by L765 , NAT_1:11;
end;
theorem
L767: (for R58 being Nat holds (for R59 being COM-Struct holds (for B131 being (preProgram of R59) holds ( card ( Reloc (B131 , R58) ) ) = ( card B131 ))))
proof
let R58 being Nat;
let R59 being COM-Struct;
let C226 being (preProgram of R59);
deffunc H1(Nat) = $1;
set D44 = { B132 where B132 is (Element of ( NAT )) : H1(B132) in ( dom C226 ) };
L768: (for B133 being set holds (B133 in ( dom C226 ) implies (ex B134 being (Element of ( NAT )) st B133 = H1(B134))))
proof
let C227 being set;
assume L769: C227 in ( dom C226 );
L770: ( dom C226 ) c= ( NAT ) by RELAT_1:def 18;
reconsider D45 = C227 as (Element of ( NAT )) by L770 , L769;
reconsider D46 = D45 as (Element of ( NAT ));
L771: D45 = H1(D46);
thus L772: thesis by L771;
end;
L773: (for B135 , B136 being (Element of ( NAT )) holds (H1(B135) = H1(B136) implies B135 = B136));
L774: ( dom C226 ) , D44 are_equipotent  from FUNCT_7:sch 3(L768 , L773);
defpred S2[ Nat ] means $1 in ( dom C226 );
deffunc H2(Nat) = ( $1 + R58 );
defpred S3[ Nat ] means H1($1) in ( dom C226 );
set D47 = { B137 where B137 is (Element of ( NAT )) : S3[ B137 ] };
set D48 = { H2(B138) where B138 is (Element of ( NAT )) : B138 in D44 };
defpred S4[ set ] means (not contradiction);
L775: D47 is (Subset of ( NAT )) from DOMAIN_1:sch 7;
L776: D44 c= ( NAT ) by L775;
L777: (for B139 , B140 being (Element of ( NAT )) holds (H2(B139) = H2(B140) implies B139 = B140));
L778: D44 , D48 are_equipotent  from FUNCT_7:sch 4(L776 , L777);
set D49 = { H2(B141) where B141 is (Element of ( NAT )) : (B141 in { B142 where B142 is (Element of ( NAT )) : S2[ B142 ] } & S4[ B141 ]) };
set D50 = { H2(B143) where B143 is (Element of ( NAT )) : (S2[ B143 ] & S4[ B143 ]) };
L779: D49 = { ( B144 + R58 ) where B144 is (Element of ( NAT )) : B144 in D44 }
proof
thus L780: D49 c= { ( B145 + R58 ) where B145 is (Element of ( NAT )) : B145 in D44 }
proof
let C228 being set;
assume L781: C228 in D49;
L782: (ex B146 being (Element of ( NAT )) st (C228 = H2(B146) & B146 in D44)) by L781;
thus L783: thesis by L782;
end;

let C229 being set;
assume L784: C229 in { ( B147 + R58 ) where B147 is (Element of ( NAT )) : B147 in D44 };
L785: (ex B148 being (Element of ( NAT )) st (C229 = ( B148 + R58 ) & B148 in D44)) by L784;
thus L786: thesis by L785;
end;
L787: D50 = { ( B149 + R58 ) where B149 is (Element of ( NAT )) : B149 in ( dom C226 ) }
proof
thus L788: D50 c= { ( B150 + R58 ) where B150 is (Element of ( NAT )) : B150 in ( dom C226 ) }
proof
let C230 being set;
assume L789: C230 in D50;
L790: (ex B151 being (Element of ( NAT )) st (C230 = H2(B151) & B151 in ( dom C226 ))) by L789;
thus L791: thesis by L790;
end;

let C231 being set;
assume L792: C231 in { ( B152 + R58 ) where B152 is (Element of ( NAT )) : B152 in ( dom C226 ) };
L793: (ex B153 being (Element of ( NAT )) st (C231 = ( B153 + R58 ) & B153 in ( dom C226 ))) by L792;
thus L794: thesis by L793;
end;
L795: ( dom ( Shift (C226 , R58) ) ) = D50 by L787 , VALUED_1:def 12;
L796: D49 = D50 from FRAENKEL:sch 14;
L797: ( dom ( Shift (C226 , R58) ) ) , ( dom C226 ) are_equipotent  by L796 , L774 , L778 , L779 , L795 , WELLORD2:15;
thus L798: ( card ( Reloc (C226 , R58) ) ) = ( card ( dom ( Reloc (C226 , R58) ) ) ) by CARD_1:62
.= ( card ( dom ( Shift (C226 , R58) ) ) ) by L620
.= ( card ( dom C226 ) ) by L797 , CARD_1:5
.= ( card C226 ) by CARD_1:62;
end;
theorem
L799: (for R20 being set holds (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds (R20 in ( dom ( Load R63 ) ) iff R20 = ( 0 )))))
proof
let R20 being set;
let R62 being COM-Struct;
let R63 being (Instruction of R62);
L800: ( dom ( Load R63 ) ) = { ( 0 ) } by FUNCOP_1:13;
thus L801: thesis by L800 , TARSKI:def 1;
end;
theorem
L802: (for R62 being COM-Struct holds (for R64 being (Program of R62) holds (for R65 being Nat holds ((R65 in ( dom ( stop R64 ) ) & ( ( stop R64 ) . R65 ) <> ( halt R62 )) implies R65 in ( dom R64 )))))
proof
let R62 being COM-Struct;
let R64 being (Program of R62);
let R65 being Nat;
assume that
L803: R65 in ( dom ( stop R64 ) )
and
L804: ( ( stop R64 ) . R65 ) <> ( halt R62 );
set D51 = ( Stop R62 );
set D52 = ( Shift (D51 , ( card R64 )) );
L805: ( stop R64 ) = ( R64 +* D52 ) by AFINSQ_1:77;
assume L806: (not R65 in ( dom R64 ));
L807: R65 in ( dom D52 ) by L806 , L803 , L805 , FUNCT_4:12;
L808: R65 in { ( B154 + ( card R64 ) ) where B154 is (Element of ( NAT )) : B154 in ( dom D51 ) } by L807 , VALUED_1:def 12;
consider C232 being (Element of ( NAT )) such that L809: R65 = ( C232 + ( card R64 ) ) and L810: C232 in ( dom D51 ) by L808;
L811: ( 0 ) in ( dom ( Stop R62 ) ) by L61;
L812: ( ( Stop R62 ) . ( 0 ) ) = ( halt R62 ) by AFINSQ_1:34;
L813: ( dom D51 ) = { ( 0 ) } by AFINSQ_1:33 , CARD_1:49;
L814: C232 = ( 0 ) by L813 , L810 , TARSKI:def 1;
thus L815: contradiction by L814 , L804 , L809 , L812 , L811 , AFINSQ_1:def 3;
end;
theorem
L816: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds (( dom ( Load R63 ) ) = { ( 0 ) } & ( ( Load R63 ) . ( 0 ) ) = R63))) by FUNCOP_1:13 , FUNCOP_1:72;
theorem
L817: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( 0 ) in ( dom ( Load R63 ) )))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
L818: ( dom ( Load R63 ) ) = { ( 0 ) } by FUNCOP_1:13;
thus L819: thesis by L818 , TARSKI:def 1;
end;
theorem
L820: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( card ( Load R63 ) ) = 1))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
L821: ( dom ( Load R63 ) ) = { ( 0 ) } by FUNCOP_1:13;
thus L822: ( card ( Load R63 ) ) = ( card ( dom ( Load R63 ) ) )
.= 1 by L821 , CARD_1:30;
end;
theorem
L823: (for R62 being COM-Struct holds (for R64 being (Program of R62) holds ( card ( stop R64 ) ) = ( ( card R64 ) + 1 )))
proof
let R62 being COM-Struct;
let R64 being (Program of R62);
thus L824: ( card ( stop R64 ) ) = ( ( card R64 ) + ( card ( Stop R62 ) ) ) by AFINSQ_1:17
.= ( ( card R64 ) + 1 ) by AFINSQ_1:33;
end;
theorem
L825: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( card ( Macro R63 ) ) = 2))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
thus L826: ( card ( Macro R63 ) ) = ( ( card ( Load R63 ) ) + ( card ( Stop R62 ) ) ) by AFINSQ_1:17
.= ( ( card ( Load R63 ) ) + 1 ) by AFINSQ_1:33
.= ( 1 + 1 ) by L820
.= 2;
end;
theorem
L827: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds (( 0 ) in ( dom ( Macro R63 ) ) & 1 in ( dom ( Macro R63 ) ))))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
L828: ( card ( Macro R63 ) ) = 2 by L825;
thus L829: thesis by L828 , AFINSQ_1:66;
end;
theorem
L830: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( ( Macro R63 ) . ( 0 ) ) = R63))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
set D53 = ( Load R63 );
L831: ( 0 ) in ( dom D53 ) by L817;
thus L832: ( ( Macro R63 ) . ( 0 ) ) = ( D53 . ( 0 ) ) by L831 , AFINSQ_1:def 3
.= R63 by FUNCOP_1:72;
end;
theorem
L833: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( ( Macro R63 ) . 1 ) = ( halt R62 )))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
L834: ( 0 ) in ( dom ( Stop R62 ) ) by L61;
L835: ( ( Stop R62 ) . ( 0 ) ) = ( halt R62 ) by AFINSQ_1:34;
L836: 1 = ( (( 0 ) qua Nat) + ( card ( Load R63 ) ) ) by L820;
thus L837: thesis by L836 , L835 , L834 , AFINSQ_1:def 3;
end;
theorem
L838: (for R20 being set holds (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds (R20 in ( dom ( Macro R63 ) ) iff (R20 = ( 0 ) or R20 = 1)))))
proof
let R20 being set;
let R62 being COM-Struct;
let R63 being (Instruction of R62);
set D54 = ( Macro R63 );
set D55 = ( NAT );
L839: ( card D54 ) = 2 by L825;
thus L840:now
assume L841: R20 in ( dom D54 );
reconsider D56 = R20 as (Element of ( NAT )) by L841;
reconsider D57 = D56 as (Element of ( NAT ));
L842: D57 < ( 1 + 1 ) by L839 , L841 , AFINSQ_1:66;
L843: D57 <= 1 by L842 , NAT_1:13;
thus L844: (R20 = ( 0 ) or R20 = 1) by L843 , NAT_1:25;
end;
thus L845: thesis by L839 , AFINSQ_1:66;
end;
theorem
L846: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( dom ( Macro R63 ) ) = { ( 0 ) , 1 }))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
L847: (for R20 being set holds (R20 in ( dom ( Macro R63 ) ) iff (R20 = ( 0 ) or R20 = 1))) by L838;
thus L848: thesis by L847 , TARSKI:def 2;
end;
theorem
L849: (for R62 being COM-Struct holds (for R64 being (Program of R62) holds (for R65 being Nat holds (R65 in ( dom R64 ) implies R65 in ( dom ( stop R64 ) )))))
proof
let R62 being COM-Struct;
let R64 being (Program of R62);
let R65 being Nat;
L850: ( dom R64 ) c= ( dom ( R64 ^ ( Stop R62 ) ) ) by AFINSQ_1:21;
thus L851: thesis by L850;
end;
theorem
L852: (for R62 being COM-Struct holds (for R65 being Nat holds (for B155 being  initial (preProgram of R62) holds (R65 in ( dom B155 ) implies ( ( stop B155 ) . R65 ) = ( B155 . R65 ))))) by AFINSQ_1:def 3;
theorem
L853: (for R62 being COM-Struct holds (for R64 being (Program of R62) holds (( card R64 ) in ( dom ( stop R64 ) ) & ( ( stop R64 ) . ( card R64 ) ) = ( halt R62 ))))
proof
let R62 being COM-Struct;
let R64 being (Program of R62);
L854: ( ( Stop R62 ) . ( 0 ) ) = ( halt R62 ) by AFINSQ_1:34;
L855: ( 0 ) in ( dom ( Stop R62 ) ) by L61;
set D58 = ( stop R64 );
L856: ( card D58 ) = ( ( card R64 ) + 1 ) by L823;
L857: ( card R64 ) < ( card D58 ) by L856 , XREAL_1:29;
thus L858: ( card R64 ) in ( dom D58 ) by L857 , AFINSQ_1:66;
L859: ( D58 . ( (( 0 ) qua Nat) + ( card R64 ) ) ) = ( halt R62 ) by L854 , L855 , AFINSQ_1:def 3;
thus L860: thesis by L859;
end;
theorem
L861: (for R34 being Nat holds (for R62 being COM-Struct holds (for R64 being (Program of R62) holds (for R65 being Nat holds (R65 in ( dom R64 ) implies ( ( Shift (( stop R64 ) , R34) ) . ( R65 + R34 ) ) = ( ( Shift (R64 , R34) ) . ( R65 + R34 ) ))))))
proof
let R34 being Nat;
let R62 being COM-Struct;
let R64 being (Program of R62);
let R65 being Nat;
L862: ( dom R64 ) c= ( dom ( stop R64 ) ) by AFINSQ_1:21;
reconsider D59 = R65 as (Element of ( NAT )) by ORDINAL1:def 12;
assume L863: R65 in ( dom R64 );
thus L864: ( ( Shift (R64 , R34) ) . ( R65 + R34 ) ) = ( R64 . D59 ) by L863 , VALUED_1:def 12
.= ( ( stop R64 ) . D59 ) by L863 , AFINSQ_1:def 3
.= ( ( Shift (( stop R64 ) , R34) ) . ( R65 + R34 ) ) by L863 , L862 , VALUED_1:def 12;
end;
theorem
L865: (for R34 being Nat holds (for R62 being COM-Struct holds (for R64 being (Program of R62) holds ( ( Shift (( stop R64 ) , R34) ) . R34 ) = ( ( Shift (R64 , R34) ) . R34 ))))
proof
let R34 being Nat;
let R62 being COM-Struct;
let R64 being (Program of R62);
L866: ( card R64 ) > ( 0 );
L867: ( 0 ) in ( dom R64 ) by L866 , AFINSQ_1:66;
thus L868: ( ( Shift (( stop R64 ) , R34) ) . R34 ) = ( ( Shift (R64 , R34) ) . ( (( 0 ) qua Nat) + R34 ) ) by L867 , L861
.= ( ( Shift (R64 , R34) ) . R34 );
end;
registration
let C233 being COM-Struct;
cluster  empty for (preProgram of C233);
existence
proof
reconsider D60 = ( <%> (the InstructionsF of C233) ) as (preProgram of C233);
take D60;
thus L869: thesis;
end;
end;
registration
let C234 being COM-Struct;
cluster  empty ->  halt-free for (preProgram of C234);
coherence
proof
let C235 being (preProgram of C234);
assume L871: C235 is  empty;
thus L872: (not ( halt C234 ) in ( rng C235 )) by L871;
end;
end;
definition
canceled 1;
let C236 being COM-Struct;
let C237 being ( NAT ) -defined (the InstructionsF of C236) -valued Function;
redefine attr C237 is  halt-free
means
:L874: (for B156 being Nat holds (B156 in ( dom C237 ) implies ( C237 . B156 ) <> ( halt C236 )));
compatibility
proof
thus L875: (C237 is  halt-free implies (for B157 being Nat holds (B157 in ( dom C237 ) implies ( C237 . B157 ) <> ( halt C236 ))))
proof
assume L876: C237 is  halt-free;
let C238 being Nat;
assume L877: C238 in ( dom C237 );
reconsider D61 = C238 as (Element of ( NAT )) by ORDINAL1:def 12;
L878: ( C237 . D61 ) in ( rng C237 ) by L877 , FUNCT_1:3;
thus L879: ( C237 . C238 ) <> ( halt C236 ) by L878 , L876 , L7;
end;

assume L880: (for B158 being Nat holds (B158 in ( dom C237 ) implies ( C237 . B158 ) <> ( halt C236 )));
assume L881: ( halt C236 ) in ( rng C237 );
consider R20 being set such that L882: R20 in ( dom C237 ) and L883: ( halt C236 ) = ( C237 . R20 ) by L881 , FUNCT_1:def 3;
thus L884: contradiction by L882 , L883 , L880;
end;
end;
registration
let C239 being COM-Struct;
cluster  halt-free ->  unique-halt for non  empty non  empty non  empty non  empty (preProgram of C239);
coherence
proof
let C240 being non  empty (preProgram of C239);
assume L886: C240 is  halt-free;
let C241 being Nat;
assume that
L887: ( C240 . C241 ) = ( halt C239 )
and
L888: C241 in ( dom C240 );
thus L889: thesis by L887 , L874 , L888 , L886;
end;
end;
theorem
L891: (for R62 being COM-Struct holds (for R63 being (Instruction of R62) holds ( rng ( Macro R63 ) ) = { R63 , ( halt R62 ) }))
proof
let R62 being COM-Struct;
let R63 being (Instruction of R62);
thus L892: ( rng ( Macro R63 ) ) = ( ( rng ( Load R63 ) ) \/ ( rng ( Stop R62 ) ) ) by AFINSQ_1:26
.= ( { R63 } \/ ( rng ( Stop R62 ) ) ) by AFINSQ_1:33
.= ( { R63 } \/ { ( halt R62 ) } ) by AFINSQ_1:33
.= { R63 , ( halt R62 ) } by ENUMSET1:1;
end;
registration
let R62 being COM-Struct;
let C242 being  initial (preProgram of R62);
reduce ( CutLastLoc ( stop C242 ) ) to C242;
reducibility by AFINSQ_2:83;
end;
theorem
L894: (for R62 being COM-Struct holds (for B159 being  initial (preProgram of R62) holds ( CutLastLoc ( stop B159 ) ) = B159));
registration
let C243 being COM-Struct;
let C244 being  halt-free  initial (preProgram of C243);
cluster ( stop C244 ) ->  unique-halt;
coherence
proof
let C245 being Nat;
assume that
L895: ( ( stop C244 ) . C245 ) = ( halt C243 )
and
L896: C245 in ( dom ( stop C244 ) );
L897: ( dom ( stop C244 ) ) = ( ( dom ( CutLastLoc ( stop C244 ) ) ) \/ { ( LastLoc ( stop C244 ) ) } ) by VALUED_1:37;
L898:
now
assume L899: C245 in ( dom ( CutLastLoc ( stop C244 ) ) );
L900: C245 in ( dom C244 ) by L899;
L901: ( C244 . C245 ) = ( halt C243 ) by L900 , AFINSQ_1:def 3 , L895;
thus L902: contradiction by L901 , L874 , L900;
end;
L903: C245 in { ( LastLoc ( stop C244 ) ) } by L898 , L896 , L897 , XBOOLE_0:def 3;
thus L904: C245 = ( LastLoc ( stop C244 ) ) by L903 , TARSKI:def 1;
end;
end;
registration
let R62 being COM-Struct;
let C246 being (Program of R62);
let C247 being non  halt-free (Program of R62);
cluster ( C246 ';' C247 ) -> non  halt-free;
coherence;
end;
theorem
L907: (for R62 being COM-Struct holds (for B160 being (Program of R62) holds ( CutLastLoc ( stop B160 ) ) = B160));
theorem
L908: (for R62 being COM-Struct holds ( InsCode ( halt R62 ) ) = ( 0 )) by RECDEF_2:def 1;
