:: Preliminaries to Circuits, I
::  by Yatsuka Nakamura, Piotr Rudnicki, Andrzej Trybulec and Pauline N. Kawamoto
::
:: Received November 17, 1994
:: Copyright (c) 1994-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSET_1, XBOOLE_0, SUBSET_1, TARSKI, FUNCT_1, RELAT_1,
      FUNCOP_1, FUNCT_4, PBOOLE, FINSEQ_1, CARD_3, PARTFUN1, FUNCT_5, FUNCT_2,
      ZFMISC_1, FUNCT_6, NAT_1, CARD_1, ARYTM_3, MCART_1, FINSEQ_2, TREES_1,
      TREES_3, TREES_2, ORDINAL4, TREES_A, XXREAL_0, TREES_4, ARYTM_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      XTUPLE_0, MCART_1, CARD_1, RELAT_1, FUNCT_1, FINSET_1, PARTFUN1, FUNCT_2,
      XXREAL_0, XXREAL_2, BINOP_1, FUNCOP_1, FUNCT_4, FUNCT_7, CARD_3, TREES_2,
      TREES_1, TREES_3, TREES_4, FUNCT_5, FUNCT_6, PBOOLE, FINSEQ_1, FINSEQ_2,
      ORDINAL1, NAT_1;
 constructors WELLORD2, BINOP_1, FUNCT_4, SETWISEO, XXREAL_0, NAT_1, FUNCT_5,
      CARD_3, SEQ_4, PBOOLE, TREES_4, BINARITH, INT_1, SEQ_1, XXREAL_2,
      PARTFUN1, RELSET_1, FUNCT_7, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XREAL_0, MEMBERED, FINSEQ_1, CARD_3, PBOOLE, TREES_2, TREES_3,
      XXREAL_2, CARD_1, RELSET_1, TREES_1, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, FUNCOP_1, WELLORD2, FUNCT_1, RELAT_1, PBOOLE, XBOOLE_0,
      SEQ_4, FINSEQ_2, FINSET_1, XTUPLE_0;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, FINSEQ_3, FUNCT_1, FUNCT_2, FUNCT_4,
      FUNCT_5, TREES_1, TREES_2, TREES_3, TREES_4, NAT_1, RELAT_1, CARD_3,
      FUNCOP_1, MCART_1, PBOOLE, CARD_2, CARD_1, FUNCT_6, FINSET_1, XBOOLE_0,
      XBOOLE_1, XCMPLX_1, ORDERS_1, XREAL_1, XXREAL_0, XXREAL_2, XREAL_0,
      PARTFUN1, FINSEQ_2;
 schemes DOMAIN_1, PBOOLE, FUNCT_1, FRAENKEL, FINSEQ_1, NAT_1;

begin
scheme FraenkelFinIm { F1() ->  finite non  empty set , F2(set) -> set , P1[set] } : { F2(B1) where B1 is (Element of F1()) : P1[ B1 ] } is  finite
proof
set D1 = { F2(B2) where B2 is (Element of F1()) : B2 in F1() };
L1: { F2(B3) where B3 is (Element of F1()) : P1[ B3 ] } c= D1
proof
let C1 being set;
assume L2: C1 in { F2(B4) where B4 is (Element of F1()) : P1[ B4 ] };
L3: (ex B5 being (Element of F1()) st (F2(B5) = C1 & P1[ B5 ])) by L2;
thus L4: thesis by L3;
end;
L5: F1() is  finite;
L6: D1 is  finite from FRAENKEL:sch 21(L5);
thus L7: thesis by L6 , L1;
end;
theorem
L8: (for B6 being Function holds (for B7 , B8 being set holds ((( dom B6 ) = { B7 } & ( rng B6 ) = { B8 }) implies B6 = { [ B7 , B8 ] })))
proof
let C2 being Function;
let C3 , C4 being set;
assume L9: (( dom C2 ) = { C3 } & ( rng C2 ) = { C4 });
L10: C2 = ( { C3 } --> C4 ) by L9 , FUNCOP_1:9;
thus L11: thesis by L10 , ZFMISC_1:29;
end;
begin
theorem
L12: (for B9 being set holds (for B10 being (ManySortedSet of B9) holds ( ( B10 # ) . ( <*> B9 ) ) = { ( {} ) }))
proof
let C5 being set;
let C6 being (ManySortedSet of C5);
reconsider D2 = ( <*> C5 ) as (Element of ( C5 * )) by FINSEQ_1:49;
thus L13: ( ( C6 # ) . ( <*> C5 ) ) = ( product ( C6 * D2 ) ) by FINSEQ_2:def 5
.= { ( {} ) } by CARD_3:10;
end;
scheme MSSLambda2Part { F3() -> set , P2[set] , F4 , F5(set) -> set } : (ex B11 being (ManySortedSet of F3()) st (for B12 being (Element of F3()) holds (B12 in F3() implies ((P2[ B12 ] implies ( B11 . B12 ) = F4(B12)) & ((not P2[ B12 ]) implies ( B11 . B12 ) = F5(B12))))))
proof
defpred S1[ set , set ] means ((P2[ $1 ] implies $2 = F4($1)) & ((not P2[ $1 ]) implies $2 = F5($1)));
L14:
now
let R1 being set;
assume that
L15: R1 in F3();
thus L16: (ex R2 being set st S1[ R1 , R2 ])
proof
per cases ;
suppose L17: P2[ R1 ];

take F4(R1);
thus L18: thesis by L17;
end;
suppose L19: (not P2[ R1 ]);

take F5(R1);
thus L20: thesis by L19;
end;
end;

end;
consider C7 being (ManySortedSet of F3()) such that L17: (for R1 being set holds (R1 in F3() implies S1[ R1 , ( C7 . R1 ) ])) from PBOOLE:sch 3(L14);
take C7;
thus L18: thesis by L17;
end;
registration
let C8 being set;
cluster  non-empty  finite-yielding for (ManySortedSet of C8);
existence
proof
reconsider D3 = ( C8 --> { ( {} ) } ) as Function;
reconsider D4 = D3 as (ManySortedSet of C8);
take D4;
thus L19: D4 is  non-empty;
thus L20: D4 is  finite-yielding
proof
let C9 being set;
assume L21: C9 in C8;
thus L22: thesis by L21 , FUNCOP_1:7;
end;

end;
end;
registration
let C10 being set;
let C11 being (ManySortedSet of C10);
let C12 being (Subset of C10);
cluster ( C11 | C12 ) ->  total for C12 -defined C12 -defined C12 -defined C12 -defined Function;
coherence
proof
set D5 = ( C11 | C12 );
L22: (( dom D5 ) = ( ( dom C11 ) /\ C12 ) & ( dom C11 ) = C10) by PARTFUN1:def 2 , RELAT_1:61;
L23: ( dom D5 ) = C12 by L22 , XBOOLE_1:28;
thus L24: thesis by L23 , PARTFUN1:def 2;
end;
end;
registration
let C13 being set;
let C14 being (ManySortedSet of C13);
let C15 being (Subset of C13);
cluster ( C14 | C15 ) ->  total;
coherence;
end;
registration
let C16 being  non-empty Function;
let C17 being set;
cluster ( C16 | C17 ) ->  non-empty;
coherence
proof
L27: ( rng ( C16 | C17 ) ) c= ( rng C16 ) by RELAT_1:70;
thus L28: (not ( {} ) in ( rng ( C16 | C17 ) )) by L27 , RELAT_1:def 9;
end;
end;
theorem
L30: (for B13 being non  empty set holds (for B14 being  non-empty (ManySortedSet of B13) holds ( union ( rng B14 ) ) is non  empty))
proof
let C18 being non  empty set;
let C19 being  non-empty (ManySortedSet of C18);
set D6 = the (Element of C18);
L31: D6 in C18;
L32: D6 in ( dom C19 ) by L31 , PARTFUN1:def 2;
L33: ( C19 . D6 ) in ( rng C19 ) by L32 , FUNCT_1:def 3;
thus L34: thesis by L33 , ORDERS_1:6;
end;
theorem
L35: (for B15 being set holds ( uncurry ( B15 --> ( {} ) ) ) = ( {} ))
proof
let C20 being set;
per cases ;
suppose L36: C20 = ( {} );

thus L37: thesis by L36 , FUNCT_5:43;
end;
suppose L38: C20 <> ( {} );

L39: ( rng ( C20 --> ( {} ) ) ) = { ( {} ) } by L38 , FUNCOP_1:8
.= ( Funcs ((( {} ) qua set) , (( {} ) qua set)) ) by FUNCT_5:57;
L40: ( dom ( uncurry ( C20 --> ( {} ) ) ) ) = [: ( dom ( C20 --> ( {} ) ) ) , ( {} ) :] by L39 , FUNCT_5:26
.= ( {} ) by ZFMISC_1:90;
thus L41: thesis by L40;
end;
end;
theorem
L43: (for B16 being non  empty set holds (for B17 being set holds (for B18 being  non-empty (ManySortedSet of B16) holds (for B19 being (ManySortedFunction of (( B16 --> B17 ) qua  total B16 -defined Function) , B18) holds ( dom ( commute B19 ) ) = B17))))
proof
let C21 being non  empty set;
let C22 being set;
let C23 being  non-empty (ManySortedSet of C21);
let C24 being (ManySortedFunction of ( C21 --> C22 ) , C23);
L44: ( dom C23 ) = C21 by PARTFUN1:def 2;
L45: ( dom C24 ) = C21 by PARTFUN1:def 2;
per cases ;
suppose L46: C22 is  empty;

L47: ( rng C24 ) c= { ( {} ) }
proof
let C25 being set;
assume L48: C25 in ( rng C24 );
consider C26 being set such that L49: (C26 in C21 & C25 = ( C24 . C26 )) by L48 , L45 , FUNCT_1:def 3;
L50: (( ( C21 --> C22 ) . C26 ) = C22 & C25 is (Function of ( ( C21 --> C22 ) . C26 ) , ( C23 . C26 ))) by L49 , FUNCOP_1:7 , PBOOLE:def 15;
L51: C25 = ( {} ) by L50 , L46;
thus L52: thesis by L51 , TARSKI:def 1;
end;
L53: ( rng C24 ) = { ( {} ) } by L47 , ZFMISC_1:33;
L54: C24 = ( C21 --> ( {} ) ) by L53 , L45 , FUNCOP_1:9;
L55: ( commute C24 ) = ( curry' ( uncurry C24 ) ) by FUNCT_6:def 10
.= ( {} ) by L54 , L35 , FUNCT_5:42;
thus L56: thesis by L55 , L46;
end;
suppose L57: C22 is non  empty;

L58: ( rng C24 ) c= ( Funcs (C22 , ( union ( rng C23 ) )) )
proof
let C27 being set;
assume L59: C27 in ( rng C24 );
consider C28 being set such that L60: C28 in ( dom C24 ) and L61: C27 = ( C24 . C28 ) by L59 , FUNCT_1:def 3;
L62: ( ( C21 --> C22 ) . C28 ) = C22 by L45 , L60 , FUNCOP_1:7;
reconsider D7 = C27 as (Function of C22 , ( C23 . C28 )) by L62 , L45 , L60 , L61 , PBOOLE:def 15;
L63: ( C23 . C28 ) in ( rng C23 ) by L44 , L45 , L60 , FUNCT_1:def 3;
L64: (( rng D7 ) c= ( C23 . C28 ) & ( C23 . C28 ) c= ( union ( rng C23 ) )) by L63 , RELAT_1:def 19 , ZFMISC_1:74;
L65: ( rng D7 ) c= ( union ( rng C23 ) ) by L64 , XBOOLE_1:1;
L66: ( dom D7 ) = C22 by L45 , L60 , FUNCT_2:def 1;
thus L67: thesis by L66 , L65 , FUNCT_2:def 2;
end;
L68: C24 in ( Funcs (C21 , ( Funcs (C22 , ( union ( rng C23 ) )) )) ) by L58 , L45 , FUNCT_2:def 2;
L69: ( commute C24 ) in ( Funcs (C22 , ( Funcs (C21 , ( union ( rng C23 ) )) )) ) by L68 , L57 , FUNCT_6:55;
L70: ( commute C24 ) is (Function of C22 , ( Funcs (C21 , ( union ( rng C23 ) )) )) by L69 , FUNCT_2:66;
L71: ( union ( rng C23 ) ) is non  empty by L30;
L72: ( Funcs (C21 , ( union ( rng C23 ) )) ) is non  empty by L71 , FUNCT_2:8;
thus L73: thesis by L72 , L70 , FUNCT_2:def 1;
end;
end;
scheme LambdaRecCorrD { F6() -> non  empty set , F7() -> (Element of F6()) , F8(Nat , (Element of F6())) -> (Element of F6()) } : ((ex B20 being (Function of ( NAT ) , F6()) st (( B20 . ( 0 ) ) = F7() & (for B21 being Nat holds ( B20 . ( B21 + 1 ) ) = F8(B21 , ( B20 . B21 ))))) & (for B22 , B23 being (Function of ( NAT ) , F6()) holds ((( B22 . ( 0 ) ) = F7() & (for B24 being Nat holds ( B22 . ( B24 + 1 ) ) = F8(B24 , ( B22 . B24 ))) & ( B23 . ( 0 ) ) = F7() & (for B25 being Nat holds ( B23 . ( B25 + 1 ) ) = F8(B25 , ( B23 . B25 )))) implies B22 = B23)))
proof
thus L75: (ex B26 being (Function of ( NAT ) , F6()) st (( B26 . ( 0 ) ) = F7() & (for B27 being Nat holds ( B26 . ( B27 + 1 ) ) = F8(B27 , ( B26 . B27 ))))) from NAT_1:sch 12;
let C29 , C30 being (Function of ( NAT ) , F6());
assume that
L76: ( C29 . ( 0 ) ) = F7()
and
L77: (for B28 being Nat holds ( C29 . ( B28 + 1 ) ) = F8(B28 , ( C29 . B28 )))
and
L78: ( C30 . ( 0 ) ) = F7()
and
L79: (for B29 being Nat holds ( C30 . ( B29 + 1 ) ) = F8(B29 , ( C30 . B29 )));
thus L80: C29 = C30 from NAT_1:sch 16(L76 , L77 , L78 , L79);
end;
scheme LambdaMSFD { F9() -> non  empty set , F10() -> (Subset of F9()) , F11 , F12() -> (ManySortedSet of F10()) , F13(set) -> set } : (ex B30 being (ManySortedFunction of F11() , F12()) st (for B31 being (Element of F9()) holds (B31 in F10() implies ( B30 . B31 ) = F13(B31))))
provided
L81: (for B32 being (Element of F9()) holds (B32 in F10() implies F13(B32) is (Function of ( F11() . B32 ) , ( F12() . B32 ))))
proof
consider C31 being (ManySortedSet of F10()) such that L82: (for R1 being set holds (R1 in F10() implies ( C31 . R1 ) = F13(R1))) from PBOOLE:sch 4;
L83: C31 is  Function-yielding
proof
let R1 being set;
assume L84: R1 in ( dom C31 );
L85: R1 in F10() by L84 , PARTFUN1:def 2;
L86: F13(R1) is Function by L85 , L81;
thus L87: thesis by L86 , L82 , L85;
end;
reconsider D8 = C31 as (ManySortedFunction of F10()) by L83;
L88: D8 is (ManySortedFunction of F11() , F12())
proof
let R1 being set;
assume L89: R1 in F10();
L90: F13(R1) is (Function of ( F11() . R1 ) , ( F12() . R1 )) by L89 , L81;
thus L91: thesis by L90 , L82 , L89;
end;
reconsider D9 = D8 as (ManySortedFunction of F11() , F12()) by L88;
take D9;
thus L92: thesis by L82;
end;
theorem
L93: (for B33 being set holds (for B34 being  non-empty (ManySortedSet of B33) holds (for B35 being Function holds (for B36 being (Element of ( product B34 )) holds ((( dom B35 ) c= ( dom B34 ) & (for B37 being set holds (B37 in ( dom B35 ) implies ( B35 . B37 ) in ( B34 . B37 )))) implies ( B36 +* B35 ) is (Element of ( product B34 )))))))
proof
let C32 being set;
let C33 being  non-empty (ManySortedSet of C32);
let C34 being Function;
let C35 being (Element of ( product C33 ));
assume that
L94: ( dom C34 ) c= ( dom C33 )
and
L95: (for B38 being set holds (B38 in ( dom C34 ) implies ( C34 . B38 ) in ( C33 . B38 )));
L96:
now
let C36 being set;
assume L97: C36 in ( dom C33 );
per cases ;
suppose L98: C36 in ( dom C34 );

L99: ( ( C35 +* C34 ) . C36 ) = ( C34 . C36 ) by L98 , FUNCT_4:13;
thus L100: ( ( C35 +* C34 ) . C36 ) in ( C33 . C36 ) by L99 , L95 , L98;
end;
suppose L101: (not C36 in ( dom C34 ));

L102: (ex B39 being Function st (C35 = B39 & ( dom B39 ) = ( dom C33 ) & (for B40 being set holds (B40 in ( dom C33 ) implies ( B39 . B40 ) in ( C33 . B40 ))))) by CARD_3:def 5;
L103: ( ( C35 +* C34 ) . C36 ) = ( C35 . C36 ) by L101 , FUNCT_4:11;
thus L104: ( ( C35 +* C34 ) . C36 ) in ( C33 . C36 ) by L103 , L97 , L102;
end;
end;
L106: (( dom ( C35 +* C34 ) ) = ( ( dom C35 ) \/ ( dom C34 ) ) & ( dom C35 ) = ( dom C33 )) by CARD_3:9 , FUNCT_4:def 1;
L107: ( dom ( C35 +* C34 ) ) = ( dom C33 ) by L106 , L94 , XBOOLE_1:12;
thus L108: thesis by L107 , L96 , CARD_3:9;
end;
theorem
L109: (for B41 , B42 being non  empty set holds (for B43 being  non-empty (ManySortedSet of B41) holds (for B44 being (ManySortedFunction of ( B41 --> B42 ) , B43) holds (for B45 being (Element of B42) holds (ex B46 being (ManySortedSet of B41) st (B46 = ( ( commute B44 ) . B45 ) & B46 in B43))))))
proof
let C37 , C38 being non  empty set;
let C39 being  non-empty (ManySortedSet of C37);
let C40 being (ManySortedFunction of ( C37 --> C38 ) , C39);
let C41 being (Element of C38);
L110: ( dom C40 ) = C37 by PARTFUN1:def 2;
L111: ( dom ( uncurry C40 ) ) = [: C37 , C38 :]
proof
thus L112: ( dom ( uncurry C40 ) ) c= [: C37 , C38 :]
proof
let R1 being set;
assume L113: R1 in ( dom ( uncurry C40 ) );
consider R3 being set, R6 being Function, R4 being set such that L114: R1 = [ R3 , R4 ] and L115: R3 in ( dom C40 ) and L116: R6 = ( C40 . R3 ) and L117: R4 in ( dom R6 ) by L113 , FUNCT_5:def 2;
L118: R6 is (Function of ( ( C37 --> C38 ) . R3 ) , ( C39 . R3 )) by L110 , L115 , L116 , PBOOLE:def 15;
L119: ( dom R6 ) = ( ( C37 --> C38 ) . R3 ) by L118 , L110 , L115 , FUNCT_2:def 1;
L120: ( dom R6 ) = C38 by L119 , L110 , L115 , FUNCOP_1:7;
thus L121: thesis by L120 , L110 , L114 , L115 , L117 , ZFMISC_1:87;
end;

let C42 , C43 being set;
reconsider D10 = ( C40 . ( [ C42 , C43 ] `1 ) ) as Function;
assume L122: [ C42 , C43 ] in [: C37 , C38 :];
L123: ( [ C42 , C43 ] `1 ) in ( dom C40 ) by L122 , L110 , MCART_1:10;
L124: D10 is (Function of ( ( C37 --> C38 ) . ( [ C42 , C43 ] `1 ) ) , ( C39 . ( [ C42 , C43 ] `1 ) )) by L122 , MCART_1:10 , PBOOLE:def 15;
L125: ( dom D10 ) = ( ( C37 --> C38 ) . ( [ C42 , C43 ] `1 ) ) by L124 , L110 , L123 , FUNCT_2:def 1;
L126: ( dom D10 ) = C38 by L125 , L122 , FUNCOP_1:7 , MCART_1:10;
L127: ( [ C42 , C43 ] `2 ) in ( dom D10 ) by L126 , L122 , MCART_1:10;
thus L128: thesis by L123 , L127 , FUNCT_5:38;
end;
L129: (( commute C40 ) = ( curry' ( uncurry C40 ) ) & (ex B47 being Function st (( ( curry' ( uncurry C40 ) ) . C41 ) = B47 & ( dom B47 ) = C37 & ( rng B47 ) c= ( rng ( uncurry C40 ) ) & (for R1 being set holds (R1 in C37 implies ( B47 . R1 ) = ( ( uncurry C40 ) . (R1 , C41) )))))) by L111 , FUNCT_5:32 , FUNCT_6:def 10;
reconsider D11 = ( ( commute C40 ) . C41 ) as (ManySortedSet of C37) by L129 , PARTFUN1:def 2 , RELAT_1:def 18;
take D11;
thus L130: D11 = ( ( commute C40 ) . C41 );
let R1 being set;
reconsider D12 = ( C40 . R1 ) as Function;
assume L131: R1 in C37;
L132: ( ( C37 --> C38 ) . R1 ) = C38 by L131 , FUNCOP_1:7;
L133: D12 is (Function of C38 , ( C39 . R1 )) by L132 , L131 , PBOOLE:def 15;
L134: ( dom D12 ) = C38 by L133 , L131 , FUNCT_2:def 1;
L135: ( D11 . R1 ) = ( ( uncurry C40 ) . (R1 , C41) ) by L129 , L131
.= ( D12 . C41 ) by L110 , L131 , L134 , FUNCT_5:38;
thus L136: thesis by L135 , L131 , L133 , FUNCT_2:5;
end;
theorem
L137: (for B48 being (Element of ( NAT )) holds (for B49 being set holds ( product ( B48 |-> { B49 } ) ) = { ( B48 |-> B49 ) }))
proof
let C44 being (Element of ( NAT ));
let C45 being set;
L138:
now
let R1 being set;
thus L139:now
assume L140: R1 in ( product ( C44 |-> { C45 } ) );
consider C46 being Function such that L141: R1 = C46 and L142: ( dom C46 ) = ( dom ( C44 |-> { C45 } ) ) and L143: (for R3 being set holds (R3 in ( dom ( C44 |-> { C45 } ) ) implies ( C46 . R3 ) in ( ( C44 |-> { C45 } ) . R3 ))) by L140 , CARD_3:def 5;
L144: ( dom C46 ) = ( Seg C44 ) by L142 , FUNCOP_1:13;
L145:
now
let R3 being set;
assume L146: R3 in ( dom C46 );
L147: ( C46 . R3 ) in ( ( C44 |-> { C45 } ) . R3 ) by L146 , L142 , L143;
L148: ( C46 . R3 ) in { C45 } by L147 , L144 , L146 , FUNCOP_1:7;
thus L149: ( C46 . R3 ) = C45 by L148 , TARSKI:def 1;
end;
thus L150: R1 = ( C44 |-> C45 ) by L145 , L141 , L144 , FUNCOP_1:11;
end;
assume L151: R1 = ( C44 |-> C45 );
reconsider D13 = R1 as Function by L151;
L152:
now
let R3 being set;
assume L153: R3 in ( dom ( C44 |-> { C45 } ) );
L154: R3 in ( Seg C44 ) by L153 , FUNCOP_1:13;
L155: (( D13 . R3 ) = C45 & ( ( C44 |-> { C45 } ) . R3 ) = { C45 }) by L154 , L151 , FUNCOP_1:7;
thus L156: ( D13 . R3 ) in ( ( C44 |-> { C45 } ) . R3 ) by L155 , TARSKI:def 1;
end;
L157: ( dom D13 ) = ( Seg C44 ) by L151 , FUNCOP_1:13
.= ( dom ( C44 |-> { C45 } ) ) by FUNCOP_1:13;
thus L158: R1 in ( product ( C44 |-> { C45 } ) ) by L157 , L152 , CARD_3:9;
end;
thus L159: thesis by L138 , TARSKI:def 1;
end;
begin
registration
let C47 being non  empty set;
cluster  ->  finite for (Element of ( FinTrees C47 ));
coherence
proof
let C48 being (Element of ( FinTrees C47 ));
L160: ( dom C48 ) is  finite;
thus L161: thesis by L160 , FINSET_1:10;
end;
end;
registration
let C49 being  finite DecoratedTree;
let C50 being (Element of ( dom C49 ));
cluster ( C49 | C50 ) ->  finite;
coherence
proof
L163: ( dom ( C49 | C50 ) ) = ( ( dom C49 ) | C50 ) by TREES_2:def 10;
thus L164: thesis by L163 , FINSET_1:10;
end;
end;
theorem
L166: (for R7 being  finite Tree holds (for R10 being (Element of R7) holds ( R7 | R10 ) , { R9 where R9 is (Element of R7) : R10 is_a_prefix_of R9 } are_equipotent ))
proof
let R7 being  finite Tree;
let R10 being (Element of R7);
set D14 = { R9 where R9 is (Element of R7) : R10 is_a_prefix_of R9 };
deffunc H1((Element of ( R7 | R10 ))) = ( R10 ^ $1 );
consider C51 being Function such that L167: ( dom C51 ) = ( R7 | R10 ) and L168: (for B50 being (Element of ( R7 | R10 )) holds ( C51 . B50 ) = H1(B50)) from FUNCT_1:sch 4;
take C51;
thus L169: C51 is  one-to-one
proof
let R3 being set;
let R4 being set;
assume that
L170: (R3 in ( dom C51 ) & R4 in ( dom C51 ))
and
L171: ( C51 . R3 ) = ( C51 . R4 );
reconsider D15 = R3 , D16 = R4 as (Element of ( R7 | R10 )) by L167 , L170;
L172: ( R10 ^ D15 ) = ( C51 . D16 ) by L168 , L171
.= ( R10 ^ D16 ) by L168;
thus L173: thesis by L172 , FINSEQ_1:33;
end;

thus L174: ( dom C51 ) = ( R7 | R10 ) by L167;
thus L175: ( rng C51 ) c= D14
proof
let R1 being set;
assume L176: R1 in ( rng C51 );
consider C52 being set such that L177: C52 in ( dom C51 ) and L178: R1 = ( C51 . C52 ) by L176 , FUNCT_1:def 3;
reconsider D17 = C52 as (Element of ( R7 | R10 )) by L167 , L177;
reconsider D18 = ( R10 ^ D17 ) as (Element of R7) by TREES_1:def 6;
L179: (( C51 . D17 ) = ( R10 ^ D17 ) & R10 is_a_prefix_of D18) by L168 , TREES_1:1;
thus L180: thesis by L179 , L178;
end;

let R1 being set;
assume L181: R1 in D14;
L182: (ex B51 being (Element of R7) st (R1 = B51 & R10 is_a_prefix_of B51)) by L181;
consider C53 being FinSequence such that L183: R1 = ( R10 ^ C53 ) by L182 , TREES_1:1;
L184: C53 is (FinSequence of ( NAT )) by L182 , L183 , FINSEQ_1:36;
reconsider D19 = C53 as (Element of ( R7 | R10 )) by L184 , L182 , L183 , TREES_1:def 6;
L185: R1 = ( C51 . D19 ) by L168 , L183;
thus L186: thesis by L185 , L167 , FUNCT_1:def 3;
end;
registration
let C54 being  finite  DecoratedTree-like Function;
let C55 being (Element of ( dom C54 ));
let C56 being  finite DecoratedTree;
cluster ( C54 with-replacement (C55 , C56) ) ->  finite;
coherence
proof
L187: ( dom ( C54 with-replacement (C55 , C56) ) ) = ( ( dom C54 ) with-replacement (C55 , ( dom C56 )) ) by TREES_2:def 11;
thus L188: thesis by L187 , FINSET_1:10;
end;
end;
theorem
L190: (for R7 being  finite Tree holds (for R8 being  finite Tree holds (for R10 being (Element of R7) holds ( R7 with-replacement (R10 , R8) ) = ( { R9 where R9 is (Element of R7) : (not R10 is_a_prefix_of R9) } \/ { ( R10 ^ R11 ) where R11 is (Element of R8) : (not contradiction) } ))))
proof
let R7 being  finite Tree;
let R8 being  finite Tree;
let R10 being (Element of R7);
defpred S2[ set ] means (not contradiction);
defpred S3[ set ] means $1 = $1;
deffunc H2(FinSequence) = ( R10 ^ $1 );
set D20 = { R9 where R9 is (Element of R7) : (not R10 is_a_proper_prefix_of R9) };
set D21 = { H2(R11) where R11 is (Element of R8) : S3[ R11 ] };
set D22 = { R9 where R9 is (Element of R7) : (not R10 is_a_prefix_of R9) };
set D23 = { H2(R11) where R11 is (Element of R8) : S2[ R11 ] };
L191:
now
let R3 being set;
thus L192:now
assume L193: R3 in D20;
consider R9 being (Element of R7) such that L194: R3 = R9 and L195: (not R10 is_a_proper_prefix_of R9) by L193;
L196: ((not R10 is_a_prefix_of R9) or R9 = R10) by L195 , XBOOLE_0:def 8;
thus L197: (R3 in D22 or R3 in { R10 }) by L196 , L194 , TARSKI:def 1;
end;
assume L198: (R3 in D22 or R3 in { R10 });
L199: (R3 = R10 or (ex R9 being (Element of R7) st (R9 = R3 & (not R10 is_a_prefix_of R9)))) by L198 , TARSKI:def 1;
consider R9 being (Element of R7) such that L200: R9 = R3 and L201: (R9 = R10 or (not R10 is_a_prefix_of R9)) by L199;
L202: (not R10 is_a_proper_prefix_of R9) by L201 , XBOOLE_0:def 8;
thus L203: R3 in D20 by L202 , L200;
end;
L204: D20 = ( D22 \/ { R10 } ) by L191 , XBOOLE_0:def 3;
L205: (( {} ) is (Element of R8) & ( R10 ^ ( {} ) ) = R10) by FINSEQ_1:34 , TREES_1:22;
L206: R10 in D23 by L205;
L207: (for R11 being (Element of R8) holds (S3[ R11 ] iff S2[ R11 ]));
L208: D21 = D23 from FRAENKEL:sch 3(L207);
thus L209: ( R7 with-replacement (R10 , R8) ) = ( ( D22 \/ { R10 } ) \/ D23 ) by L208 , L204 , TREES_1:32
.= ( D22 \/ ( { R10 } \/ D23 ) ) by XBOOLE_1:4
.= ( D22 \/ D23 ) by L206 , ZFMISC_1:40;
end;
theorem
L210: (for R7 being  finite Tree holds (for R8 being  finite Tree holds (for R10 being (Element of R7) holds (for B52 being (FinSequence of ( NAT )) holds ((B52 in ( R7 with-replacement (R10 , R8) ) & R10 is_a_prefix_of B52) implies (ex R11 being (Element of R8) st B52 = ( R10 ^ R11 )))))))
proof
let R7 being  finite Tree;
let R8 being  finite Tree;
let R10 being (Element of R7);
let C57 being (FinSequence of ( NAT ));
assume that
L211: C57 in ( R7 with-replacement (R10 , R8) )
and
L212: R10 is_a_prefix_of C57;
L213: (not C57 in { R9 where R9 is (Element of R7) : (not R10 is_a_prefix_of R9) })
proof
assume L214: C57 in { R9 where R9 is (Element of R7) : (not R10 is_a_prefix_of R9) };
L215: (ex R9 being (Element of R7) st (C57 = R9 & (not R10 is_a_prefix_of R9))) by L214;
thus L216: contradiction by L215 , L212;
end;
L217: ( R7 with-replacement (R10 , R8) ) = ( { R9 where R9 is (Element of R7) : (not R10 is_a_prefix_of R9) } \/ { ( R10 ^ R11 ) where R11 is (Element of R8) : (not contradiction) } ) by L190;
L218: C57 in { ( R10 ^ R11 ) where R11 is (Element of R8) : (not contradiction) } by L217 , L211 , L213 , XBOOLE_0:def 3;
thus L219: thesis by L218;
end;
theorem
L220: (for B53 being  Tree-yielding FinSequence holds (for B54 being (Element of ( NAT )) holds (( B54 + 1 ) in ( dom B53 ) implies ( ( tree B53 ) | <* B54 *> ) = ( B53 . ( B54 + 1 ) ))))
proof
let C58 being  Tree-yielding FinSequence;
let C59 being (Element of ( NAT ));
assume L221: ( C59 + 1 ) in ( dom C58 );
L222: ( C59 + 1 ) <= ( len C58 ) by L221 , FINSEQ_3:25;
L223: C59 < ( len C58 ) by L222 , NAT_1:13;
thus L224: thesis by L223 , TREES_3:49;
end;
theorem
L225: (for B55 being  DTree-yielding FinSequence holds (for B56 being (Element of ( NAT )) holds (( B56 + 1 ) in ( dom B55 ) implies <* B56 *> in ( tree ( doms B55 ) ))))
proof
let C60 being  DTree-yielding FinSequence;
let C61 being (Element of ( NAT ));
L226: C61 < ( C61 + 1 ) by XREAL_1:29;
L227: (( dom C60 ) = ( Seg ( len C60 ) ) & ( Seg ( len ( doms C60 ) ) ) = ( dom ( doms C60 ) )) by FINSEQ_1:def 3;
assume L228: ( C61 + 1 ) in ( dom C60 );
L229: ( C61 + 1 ) <= ( len C60 ) by L228 , FINSEQ_3:25;
L230: C61 < ( len C60 ) by L229 , L226 , XXREAL_0:2;
L231: C61 < ( len ( doms C60 ) ) by L230 , L227 , FINSEQ_1:6 , TREES_3:37;
L232: ( dom ( doms C60 ) ) = ( dom C60 ) by TREES_3:37;
L233: ( ( doms C60 ) . ( C61 + 1 ) ) is Tree by L232 , L228 , TREES_3:22;
L234: ( {} ) in ( ( doms C60 ) . ( C61 + 1 ) ) by L233 , TREES_1:22;
L235: <* C61 *> = ( <* C61 *> ^ ( {} ) ) by FINSEQ_1:34;
thus L236: thesis by L235 , L234 , L231 , TREES_3:def 15;
end;
theorem
L237: (for B57 , B58 being  Tree-yielding FinSequence holds (for B59 being (Element of ( NAT )) holds ((( len B57 ) = ( len B58 ) & ( B59 + 1 ) in ( dom B57 ) & (for B60 being (Element of ( NAT )) holds ((B60 in ( dom B57 ) & B60 <> ( B59 + 1 )) implies ( B57 . B60 ) = ( B58 . B60 )))) implies (for B61 being Tree holds (( B58 . ( B59 + 1 ) ) = B61 implies ( tree B58 ) = ( ( tree B57 ) with-replacement (<* B59 *> , B61) ))))))
proof
let C62 , C63 being  Tree-yielding FinSequence;
let C64 being (Element of ( NAT ));
assume that
L238: ( len C62 ) = ( len C63 )
and
L239: ( C64 + 1 ) in ( dom C62 )
and
L240: (for B62 being (Element of ( NAT )) holds ((B62 in ( dom C62 ) & B62 <> ( C64 + 1 )) implies ( C62 . B62 ) = ( C63 . B62 )));
let C65 being Tree;
set D24 = <* C64 *>;
L241: ( C64 + 1 ) <= ( len C62 ) by L239 , FINSEQ_3:25;
L242: C64 < ( len C62 ) by L241 , NAT_1:13;
assume L243: ( C63 . ( C64 + 1 ) ) = C65;
L244:
now
let C66 being (FinSequence of ( NAT ));
thus L245:now
assume L246: C66 in ( tree C63 );
per cases  by L246 , TREES_3:def 15;
suppose L247: C66 = ( {} );

thus L248: ((C66 in ( tree C62 ) & (not D24 is_a_proper_prefix_of C66)) or (ex B63 being (FinSequence of ( NAT )) st (B63 in C65 & C66 = ( D24 ^ B63 )))) by L247 , TREES_1:22 , XBOOLE_1:115;
end;
suppose L249: (ex B64 being (Element of ( NAT )) st (ex B65 being FinSequence st (B64 < ( len C63 ) & B65 in ( C63 . ( B64 + 1 ) ) & C66 = ( <* B64 *> ^ B65 ))));

consider C67 being (Element of ( NAT )), C68 being FinSequence such that L250: C67 < ( len C63 ) and L251: C68 in ( C63 . ( C67 + 1 ) ) and L252: C66 = ( <* C67 *> ^ C68 ) by L249;
L253:
now
per cases ;
case L254: C67 = C64;
reconsider D25 = C68 as (FinSequence of ( NAT )) by L252 , FINSEQ_1:36;
take D26 = D25;
thus L255: (D26 in C65 & C66 = ( D24 ^ D26 )) by L243 , L251 , L252 , L254;
end;
case L256: C67 <> C64;
L257: (1 <= ( C67 + 1 ) & ( C67 + 1 ) <= ( len C62 )) by L238 , L250 , NAT_1:11 , NAT_1:13;
L258: ( C67 + 1 ) in ( dom C62 ) by L257 , FINSEQ_3:25;
L259: ( C63 . ( C67 + 1 ) ) = ( C62 . ( C67 + 1 ) ) by L258 , L240 , L256 , XCMPLX_1:2;
thus L260: C66 in ( tree C62 ) by L259 , L238 , L250 , L251 , L252 , TREES_3:def 15;
assume L261: D24 is_a_proper_prefix_of C66;
L262: D24 is_a_prefix_of C66 by L261 , XBOOLE_0:def 8;
L263: (ex B66 being FinSequence st C66 = ( D24 ^ B66 )) by L262 , TREES_1:1;
L264: C64 = ( C66 . 1 ) by L263 , FINSEQ_1:41
.= C67 by L252 , FINSEQ_1:41;
thus L265: contradiction by L264 , L256;
end;
end;
thus L267: ((C66 in ( tree C62 ) & (not D24 is_a_proper_prefix_of C66)) or (ex B67 being (FinSequence of ( NAT )) st (B67 in C65 & C66 = ( D24 ^ B67 )))) by L253;
end;
end;
assume L269: ((C66 in ( tree C62 ) & (not D24 is_a_proper_prefix_of C66)) or (ex B68 being (FinSequence of ( NAT )) st (B68 in C65 & C66 = ( D24 ^ B68 ))));
per cases  by L269;
suppose that L270: C66 in ( tree C62 )
and
L271: (not D24 is_a_proper_prefix_of C66);
L272:
now
per cases  by L270 , TREES_3:def 15;
suppose L273: C66 = ( {} );

thus L274: C66 in ( tree C63 ) by L273 , TREES_1:22;
end;
suppose L275: (ex B69 being (Element of ( NAT )) st (ex B70 being FinSequence st (B69 < ( len C62 ) & B70 in ( C62 . ( B69 + 1 ) ) & C66 = ( <* B69 *> ^ B70 ))));

consider C69 being (Element of ( NAT )), C70 being FinSequence such that L276: C69 < ( len C62 ) and L277: C70 in ( C62 . ( C69 + 1 ) ) and L278: C66 = ( <* C69 *> ^ C70 ) by L275;
L279:
now
per cases ;
suppose L280: C70 = ( {} );

L281: (1 <= ( C69 + 1 ) & ( C69 + 1 ) <= ( len C63 )) by L238 , L276 , NAT_1:11 , NAT_1:13;
L282: ( C69 + 1 ) in ( dom C63 ) by L281 , FINSEQ_3:25;
L283: ( C63 . ( C69 + 1 ) ) is Tree by L282 , TREES_3:22;
L284: C70 in ( C63 . ( C69 + 1 ) ) by L283 , L280 , TREES_1:22;
thus L285: C66 in ( tree C63 ) by L284 , L238 , L276 , L278 , TREES_3:def 15;
end;
suppose L286: C70 <> ( {} );

L287:
now
assume L288: C69 = C64;
L289: (D24 is_a_prefix_of C66 & (not C66 = D24)) by L288 , L278 , L286 , FINSEQ_1:87 , TREES_1:1;
thus L290: contradiction by L289 , L271 , XBOOLE_0:def 8;
end;
L291: (1 <= ( C69 + 1 ) & ( C69 + 1 ) <= ( len C62 )) by L276 , NAT_1:11 , NAT_1:13;
L292: ( C69 + 1 ) in ( dom C62 ) by L291 , FINSEQ_3:25;
L293: ( C63 . ( C69 + 1 ) ) = ( C62 . ( C69 + 1 ) ) by L292 , L240 , L287 , XCMPLX_1:2;
thus L294: C66 in ( tree C63 ) by L293 , L238 , L276 , L277 , L278 , TREES_3:def 15;
end;
end;
thus L296: C66 in ( tree C63 ) by L279;
end;
end;
thus L298: C66 in ( tree C63 ) by L272;
end;
suppose L299: (ex B71 being (FinSequence of ( NAT )) st (B71 in C65 & C66 = ( D24 ^ B71 )));

thus L300: C66 in ( tree C63 ) by L299 , L238 , L242 , L243 , TREES_3:def 15;
end;
end;
L302: ( C62 . ( C64 + 1 ) ) is Tree by L239 , TREES_3:22;
L303: ( {} ) in ( C62 . ( C64 + 1 ) ) by L302 , TREES_1:22;
L304: D24 = ( D24 ^ ( {} ) ) by FINSEQ_1:34;
L305: D24 in ( tree C62 ) by L304 , L242 , L303 , TREES_3:def 15;
thus L306: thesis by L305 , L244 , TREES_1:def 9;
end;
theorem
L307: (for B72 , B73 being  finite DecoratedTree holds (for B74 being set holds (for B75 being (Element of ( NAT )) holds (for B76 being  DTree-yielding FinSequence holds ((<* B75 *> in ( dom B72 ) & B72 = ( B74 -tree B76 )) implies (ex B77 being  DTree-yielding FinSequence st (( B72 with-replacement (<* B75 *> , B73) ) = ( B74 -tree B77 ) & ( len B77 ) = ( len B76 ) & ( B77 . ( B75 + 1 ) ) = B73 & (for B78 being (Element of ( NAT )) holds ((B78 in ( dom B76 ) & B78 <> ( B75 + 1 )) implies ( B77 . B78 ) = ( B76 . B78 ))))))))))
proof
let C71 , C72 being  finite DecoratedTree;
let C73 being set;
let C74 being (Element of ( NAT ));
let C75 being  DTree-yielding FinSequence;
assume that
L308: <* C74 *> in ( dom C71 )
and
L309: C71 = ( C73 -tree C75 );
consider C76 being (Element of ( NAT )), C77 being DecoratedTree, C78 being (Node of C77) such that L310: C76 < ( len C75 ) and L311: C77 = ( C75 . ( C76 + 1 ) ) and L312: <* C74 *> = ( <* C76 *> ^ C78 ) by L308 , L309 , TREES_4:11;
consider C79 being  DTree-yielding FinSequence such that L313: C75 = C79 and L314: ( dom ( C73 -tree C75 ) ) = ( tree ( doms C79 ) ) by TREES_4:def 4;
L315: ( dom ( doms C79 ) ) = ( dom C75 ) by L313 , TREES_3:37;
deffunc H3(Nat) = ( IFEQ ($1 , ( C74 + 1 ) , C72 , ( C75 . $1 )) );
set D27 = <* C74 *>;
consider C80 being FinSequence such that L316: ( len C80 ) = ( len C75 ) and L317: (for B79 being Nat holds (B79 in ( dom C80 ) implies ( C80 . B79 ) = H3(B79))) from FINSEQ_1:sch 2;
L318: ( dom C80 ) = ( Seg ( len C75 ) ) by L316 , FINSEQ_1:def 3;
L319: ( dom C80 ) = ( dom C75 ) by L316 , FINSEQ_3:29;
L320:
now
let R3 being set;
assume L321: R3 in ( dom C80 );
reconsider D28 = R3 as (Element of ( NAT )) by L321;
L322: (D28 = ( C74 + 1 ) or D28 <> ( C74 + 1 ));
L323: ( C80 . D28 ) = ( IFEQ (D28 , ( C74 + 1 ) , C72 , ( C75 . D28 )) ) by L317 , L321;
L324: (( C80 . D28 ) = C72 or ( C80 . D28 ) = ( C75 . D28 )) by L323 , L322 , FUNCOP_1:def 8;
thus L325: ( C80 . R3 ) is DecoratedTree by L324 , L319 , L321 , TREES_3:24;
end;
reconsider D29 = C80 as  DTree-yielding FinSequence by L320 , TREES_3:24;
consider C81 being  DTree-yielding FinSequence such that L326: D29 = C81 and L327: ( dom ( C73 -tree D29 ) ) = ( tree ( doms C81 ) ) by TREES_4:def 4;
L328: ( len ( doms C79 ) ) = ( len C75 ) by L313 , TREES_3:38
.= ( len ( doms C81 ) ) by L316 , L326 , TREES_3:38;
L329: ( dom C75 ) = ( Seg ( len C75 ) ) by FINSEQ_1:def 3;
L330:
now
let C82 being (Element of ( NAT ));
assume that
L331: C82 in ( dom ( doms C79 ) )
and
L332: C82 <> ( C74 + 1 );
L333: ( D29 . C82 ) = ( IFEQ (C82 , ( C74 + 1 ) , C72 , ( C75 . C82 )) ) by L317 , L318 , L329 , L315 , L331
.= ( C75 . C82 ) by L332 , FUNCOP_1:def 8;
reconsider D30 = ( C75 . C82 ) as DecoratedTree by L315 , L331 , TREES_3:24;
thus L334: ( ( doms C79 ) . C82 ) = ( dom D30 ) by L313 , L315 , L331 , FUNCT_6:22
.= ( ( doms C81 ) . C82 ) by L319 , L326 , L315 , L331 , L333 , FUNCT_6:22;
end;
reconsider D31 = ( doms C81 ) as  Tree-yielding FinSequence;
take D29;
L335: <* C76 *> = <* C74 *> by L312 , FINSEQ_1:88;
L336: C76 = ( <* C74 *> . 1 ) by L335 , FINSEQ_1:def 8
.= C74 by FINSEQ_1:def 8;
L337: (1 <= ( C74 + 1 ) & ( C74 + 1 ) <= ( len C75 )) by L336 , L310 , NAT_1:11 , NAT_1:13;
L338: ( C74 + 1 ) in ( dom C75 ) by L337 , FINSEQ_3:25;
L339: ( C74 + 1 ) in ( Seg ( len C75 ) ) by L338 , FINSEQ_1:def 3;
L340: ( D29 . ( C74 + 1 ) ) = ( IFEQ (( C74 + 1 ) , ( C74 + 1 ) , C72 , ( C75 . ( C74 + 1 ) )) ) by L339 , L317 , L318
.= C72 by FUNCOP_1:def 8;
L341: ( ( doms C81 ) . ( C74 + 1 ) ) = ( dom C72 ) by L340 , L319 , L338 , L326 , FUNCT_6:22;
L342: ( dom ( C73 -tree D29 ) ) = ( ( dom C71 ) with-replacement (D27 , ( dom C72 )) ) by L341 , L309 , L338 , L327 , L314 , L328 , L315 , L330 , L237;
L343: (for B80 being (FinSequence of ( NAT )) holds (B80 in ( ( dom C71 ) with-replacement (D27 , ( dom C72 )) ) implies (((not D27 is_a_prefix_of B80) & ( ( C73 -tree D29 ) . B80 ) = ( C71 . B80 )) or (ex B81 being (FinSequence of ( NAT )) st (B81 in ( dom C72 ) & B80 = ( D27 ^ B81 ) & ( ( C73 -tree D29 ) . B80 ) = ( C72 . B81 ))))))
proof
reconsider D32 = D27 as (Element of ( dom C71 )) by L308;
let C83 being (FinSequence of ( NAT ));
assume L344: C83 in ( ( dom C71 ) with-replacement (D27 , ( dom C72 )) );
per cases  by L344 , L210;
suppose L345: (not D32 is_a_prefix_of C83);

L346: ( ( C73 -tree D29 ) . C83 ) = ( C71 . C83 )
proof
per cases  by L327 , L342 , L344 , TREES_3:def 15;
suppose L347: C83 = ( {} );

thus L348: ( ( C73 -tree D29 ) . C83 ) = C73 by L347 , TREES_4:def 4
.= ( C71 . C83 ) by L309 , L347 , TREES_4:def 4;
end;
suppose L349: (ex B82 being (Element of ( NAT )) st (ex B83 being FinSequence st (B82 < ( len D31 ) & B83 in ( D31 . ( B82 + 1 ) ) & C83 = ( <* B82 *> ^ B83 ))));

consider C84 being (Element of ( NAT )), C85 being FinSequence such that L350: C84 < ( len ( doms D29 ) ) and L351: C85 in ( ( doms D29 ) . ( C84 + 1 ) ) and L352: C83 = ( <* C84 *> ^ C85 ) by L349 , L326;
reconsider D33 = C85 as (FinSequence of ( NAT )) by L352 , FINSEQ_1:36;
reconsider D34 = <* C84 *> as (FinSequence of ( NAT ));
L353: ( C84 + 1 ) <> ( C74 + 1 ) by L345 , L352 , TREES_1:1;
L354: (ex B84 being  DTree-yielding FinSequence st (C75 = B84 & ( dom ( C73 -tree C75 ) ) = ( tree ( doms B84 ) ))) by TREES_4:def 4;
L355: C84 < ( len D29 ) by L350 , TREES_3:38;
L356: ( ( C73 -tree D29 ) | <* C84 *> ) = ( D29 . ( C84 + 1 ) ) by L355 , TREES_4:def 4;
L357: (1 <= ( C84 + 1 ) & ( C84 + 1 ) <= ( len C75 )) by L316 , L355 , NAT_1:11 , NAT_1:13;
L358: ( C84 + 1 ) in ( dom C75 ) by L357 , FINSEQ_3:25;
reconsider D35 = ( C75 . ( C84 + 1 ) ) as DecoratedTree by L358 , TREES_3:24;
L359: ( D29 . ( C84 + 1 ) ) = ( IFEQ (( C84 + 1 ) , ( C74 + 1 ) , C72 , ( C75 . ( C84 + 1 ) )) ) by L317 , L318 , L329 , L358
.= ( C75 . ( C84 + 1 ) ) by L353 , FUNCOP_1:def 8;
L360: ( C84 + 1 ) in ( dom ( doms C75 ) ) by L358 , TREES_3:37;
L361: ( ( dom ( C73 -tree C75 ) ) | <* C84 *> ) = ( ( doms C75 ) . ( C84 + 1 ) ) by L360 , L354 , L220
.= ( dom D35 ) by L358 , FUNCT_6:22
.= ( ( doms D29 ) . ( C84 + 1 ) ) by L319 , L358 , L359 , FUNCT_6:22;
L362: ( C84 + 1 ) in ( dom ( doms D29 ) ) by L319 , L358 , TREES_3:37;
L363: ( ( dom ( C73 -tree D29 ) ) | <* C84 *> ) = ( ( doms D29 ) . ( C84 + 1 ) ) by L362 , L326 , L327 , L220;
thus L364: ( ( C73 -tree D29 ) . C83 ) = ( ( ( C73 -tree D29 ) | D34 ) . D33 ) by L363 , L351 , L352 , TREES_2:def 10
.= ( ( ( C73 -tree C75 ) | D34 ) . D33 ) by L316 , L355 , L356 , L359 , TREES_4:def 4
.= ( C71 . C83 ) by L309 , L351 , L352 , L361 , TREES_2:def 10;
end;
end;
assume L366: (D27 is_a_prefix_of C83 or ( ( C73 -tree D29 ) . C83 ) <> ( C71 . C83 ));
thus L367: thesis by L366 , L345 , L346;
end;
suppose L368: (ex B85 being (Element of ( dom C72 )) st C83 = ( D32 ^ B85 ));

consider C86 being (Element of ( dom C72 )) such that L369: C83 = ( D27 ^ C86 ) by L368;
assume L370: (D27 is_a_prefix_of C83 or ( ( C73 -tree D29 ) . C83 ) <> ( C71 . C83 ));
L371: ( ( C73 -tree D29 ) | D27 ) = ( D29 . ( C74 + 1 ) ) by L316 , L310 , L336 , TREES_4:def 4;
reconsider D36 = C86 as (FinSequence of ( NAT ));
take D36;
thus L372: D36 in ( dom C72 );
thus L373: C83 = ( D27 ^ D36 ) by L369;
L374: D36 in ( ( dom ( C73 -tree D29 ) ) | D27 ) by L308 , L342 , L372 , TREES_1:33;
thus L375: thesis by L374 , L340 , L369 , L371 , TREES_2:def 10;
end;
end;
thus L377: ( C71 with-replacement (D27 , C72) ) = ( C73 -tree D29 ) by L343 , L308 , L342 , TREES_2:def 11;
thus L378: ( len D29 ) = ( len C75 ) by L316;
thus L379: ( D29 . ( C74 + 1 ) ) = C72 by L340;
let C87 being (Element of ( NAT ));
assume L380: C87 in ( dom C75 );
L381: ( D29 . C87 ) = ( IFEQ (C87 , ( C74 + 1 ) , C72 , ( C75 . C87 )) ) by L380 , L317 , L318 , L329;
thus L382: thesis by L381 , FUNCOP_1:def 8;
end;
theorem
L383: (for B86 being  finite Tree holds (for B87 being (Element of B86) holds (B87 <> ( {} ) implies ( card ( B86 | B87 ) ) < ( card B86 ))))
proof
let C88 being  finite Tree;
let C89 being (Element of C88);
reconsider D37 = C89 as (Element of ( ( NAT ) * )) by FINSEQ_1:def 11;
set D38 = { ( D37 ^ B88 ) where B88 is (Element of ( ( NAT ) * )) : B88 in ( C88 | C89 ) };
L384: ( C88 | C89 ) , D38 are_equipotent 
proof
deffunc H4((Element of ( C88 | C89 ))) = ( D37 ^ $1 );
consider C90 being Function such that L385: ( dom C90 ) = ( C88 | C89 ) and L386: (for B89 being (Element of ( C88 | C89 )) holds ( C90 . B89 ) = H4(B89)) from FUNCT_1:sch 4;
take C90;
thus L387: C90 is  one-to-one
proof
let R3 being set;
let R4 being set;
assume that
L388: (R3 in ( dom C90 ) & R4 in ( dom C90 ))
and
L389: ( C90 . R3 ) = ( C90 . R4 );
reconsider D39 = R3 , D40 = R4 as (Element of ( C88 | C89 )) by L385 , L388;
L390: ( D37 ^ D39 ) = ( C90 . D40 ) by L386 , L389
.= ( D37 ^ D40 ) by L386;
thus L391: thesis by L390 , FINSEQ_1:33;
end;

thus L392: ( dom C90 ) = ( C88 | C89 ) by L385;
thus L393: ( rng C90 ) c= D38
proof
let R1 being set;
assume L394: R1 in ( rng C90 );
consider C91 being set such that L395: C91 in ( dom C90 ) and L396: R1 = ( C90 . C91 ) by L394 , FUNCT_1:def 3;
L397: ( C88 | C89 ) c= ( ( NAT ) * ) by TREES_1:def 3;
reconsider D41 = C91 as (Element of ( ( NAT ) * )) by L397 , L385 , L395;
L398: ( C90 . D41 ) = ( D37 ^ D41 ) by L385 , L386 , L395;
thus L399: thesis by L398 , L385 , L395 , L396;
end;

let R1 being set;
assume L400: R1 in D38;
consider C92 being (Element of ( ( NAT ) * )) such that L401: R1 = ( D37 ^ C92 ) and L402: C92 in ( C88 | C89 ) by L400;
reconsider D42 = C92 as (Element of ( C88 | C89 )) by L402;
L403: R1 = ( C90 . D42 ) by L386 , L401;
thus L404: thesis by L403 , L385 , FUNCT_1:def 3;
end;
reconsider D43 = D38 as  finite set by L384 , CARD_1:38;
L405: ( card D43 ) = ( card ( C88 | C89 ) ) by L384 , CARD_1:5;
assume L406: C89 <> ( {} );
L407: D43 <> C88
proof
assume L408: D43 = C88;
L409: ( {} ) in D43 by L408 , TREES_1:22;
L410: (ex B90 being (Element of ( ( NAT ) * )) st (( {} ) = ( D37 ^ B90 ) & B90 in ( C88 | C89 ))) by L409;
thus L411: contradiction by L410 , L406;
end;
L412: D43 c= C88
proof
let R1 being set;
assume L413: R1 in D43;
L414: (ex B91 being (Element of ( ( NAT ) * )) st (R1 = ( D37 ^ B91 ) & B91 in ( C88 | C89 ))) by L413;
thus L415: thesis by L414 , TREES_1:def 6;
end;
L416: D43 c< C88 by L412 , L407 , XBOOLE_0:def 8;
thus L417: thesis by L416 , L405 , CARD_2:48;
end;
theorem
L418: (for B92 , B93 being  finite Tree holds (for B94 being (Element of B92) holds ( ( card ( B92 with-replacement (B94 , B93) ) ) + ( card ( B92 | B94 ) ) ) = ( ( card B92 ) + ( card B93 ) )))
proof
let R7 being  finite Tree;
let R8 being  finite Tree;
let R10 being (Element of R7);
defpred S4[ (Element of R7) ] means (not R10 is_a_prefix_of $1);
defpred S5[ (Element of R7) ] means R10 is_a_prefix_of $1;
set D44 = { R9 where R9 is (Element of R7) : S4[ R9 ] };
set D45 = { R9 where R9 is (Element of R7) : S5[ R9 ] };
set D46 = { ( R10 ^ R11 ) where R11 is (Element of R8) : (not contradiction) };
L419: D44 is (Subset of R7) from DOMAIN_1:sch 7;
L420: D45 is (Subset of R7) from DOMAIN_1:sch 7;
L421: R8 , D46 are_equipotent 
proof
deffunc H5((Element of R8)) = ( R10 ^ $1 );
consider C93 being Function such that L422: ( dom C93 ) = R8 and L423: (for B95 being (Element of R8) holds ( C93 . B95 ) = H5(B95)) from FUNCT_1:sch 4;
take C93;
thus L424: C93 is  one-to-one
proof
let R3 being set;
let R4 being set;
assume that
L425: (R3 in ( dom C93 ) & R4 in ( dom C93 ))
and
L426: ( C93 . R3 ) = ( C93 . R4 );
reconsider D47 = R3 , D48 = R4 as (Element of R8) by L422 , L425;
L427: ( R10 ^ D47 ) = ( C93 . D48 ) by L423 , L426
.= ( R10 ^ D48 ) by L423;
thus L428: thesis by L427 , FINSEQ_1:33;
end;

thus L429: ( dom C93 ) = R8 by L422;
thus L430: ( rng C93 ) c= D46
proof
let R1 being set;
assume L431: R1 in ( rng C93 );
consider C94 being set such that L432: C94 in ( dom C93 ) and L433: R1 = ( C93 . C94 ) by L431 , FUNCT_1:def 3;
L434: R8 c= ( ( NAT ) * ) by TREES_1:def 3;
reconsider D49 = C94 as (Element of ( ( NAT ) * )) by L434 , L422 , L432;
L435: ( C93 . D49 ) = ( R10 ^ D49 ) by L422 , L423 , L432;
thus L436: thesis by L435 , L422 , L432 , L433;
end;

let R1 being set;
assume L437: R1 in D46;
consider C95 being (Element of R8) such that L438: R1 = ( R10 ^ C95 ) by L437;
L439: R1 = ( C93 . C95 ) by L423 , L438;
thus L440: thesis by L439 , L422 , FUNCT_1:def 3;
end;
reconsider D50 = D44 , D51 = D45 as  finite set by L419 , L420;
L441:
now
let R3 being set;
thus L442:now
assume L443: R3 in R7;
reconsider D52 = R3 as (Element of R7) by L443;
L444: (R10 is_a_prefix_of D52 or (not R10 is_a_prefix_of D52));
thus L445: (R3 in D50 or R3 in D51) by L444;
end;
assume L446: (R3 in D50 or R3 in D51);
thus L447: R3 in R7 by L446 , L419 , L420;
end;
L448: R7 = ( D50 \/ D51 ) by L441 , XBOOLE_0:def 3;
L449: D50 misses D46
proof
assume L450: (not thesis);
consider R3 being set such that L451: R3 in ( D50 /\ D46 ) by L450 , XBOOLE_0:4;
L452: R3 in D46 by L451 , XBOOLE_0:def 4;
L453: (ex R11 being (Element of R8) st R3 = ( R10 ^ R11 )) by L452;
L454: R3 in D50 by L451 , XBOOLE_0:def 4;
L455: (ex R9 being (Element of R7) st (R3 = R9 & (not R10 is_a_prefix_of R9))) by L454;
thus L456: contradiction by L455 , L453 , TREES_1:1;
end;
L457: D50 misses D51
proof
assume L458: (not thesis);
consider R3 being set such that L459: R3 in ( D50 /\ D51 ) by L458 , XBOOLE_0:4;
L460: R3 in D51 by L459 , XBOOLE_0:def 4;
L461: (ex R9 being (Element of R7) st (R3 = R9 & R10 is_a_prefix_of R9)) by L460;
L462: R3 in D50 by L459 , XBOOLE_0:def 4;
L463: (ex R9 being (Element of R7) st (R3 = R9 & (not R10 is_a_prefix_of R9))) by L462;
thus L464: contradiction by L463 , L461;
end;
L465: ( R7 with-replacement (R10 , R8) ) = ( D50 \/ D46 ) by L190;
reconsider D53 = D46 as  finite set by L421 , CARD_1:38;
L466: ( card R8 ) = ( card D53 ) by L421 , CARD_1:5;
L467: ( R7 | R10 ) , D51 are_equipotent  by L166;
L468: ( card ( R7 | R10 ) ) = ( card D51 ) by L467 , CARD_1:5;
thus L469: ( ( card ( R7 with-replacement (R10 , R8) ) ) + ( card ( R7 | R10 ) ) ) = ( ( ( card D50 ) + ( card D53 ) ) + ( card D51 ) ) by L468 , L465 , L449 , CARD_2:40
.= ( ( ( card D50 ) + ( card D51 ) ) + ( card D53 ) )
.= ( ( card R7 ) + ( card R8 ) ) by L448 , L457 , L466 , CARD_2:40;
end;
theorem
L470: (for B96 , B97 being  finite DecoratedTree holds (for B98 being (Element of ( dom B96 )) holds ( ( card ( B96 with-replacement (B98 , B97) ) ) + ( card ( B96 | B98 ) ) ) = ( ( card B96 ) + ( card B97 ) )))
proof
let C96 , C97 being  finite DecoratedTree;
let C98 being (Element of ( dom C96 ));
L471: (( card ( dom C96 ) ) = ( card C96 ) & ( card ( dom C97 ) ) = ( card C97 )) by CARD_1:62;
L472: (( card ( dom ( C96 with-replacement (C98 , C97) ) ) ) = ( card ( C96 with-replacement (C98 , C97) ) ) & ( card ( dom ( C96 | C98 ) ) ) = ( card ( C96 | C98 ) )) by CARD_1:62;
L473: (( dom ( C96 with-replacement (C98 , C97) ) ) = ( ( dom C96 ) with-replacement (C98 , ( dom C97 )) ) & ( dom ( C96 | C98 ) ) = ( ( dom C96 ) | C98 )) by TREES_2:def 10 , TREES_2:def 11;
thus L474: thesis by L473 , L471 , L472 , L418;
end;
registration
let C99 being set;
cluster ( root-tree C99 ) ->  finite;
coherence
proof
L475: ( root-tree C99 ) = { [ ( {} ) , C99 ] } by TREES_4:6;
thus L476: thesis by L475;
end;
end;
theorem
L478: (for B99 being set holds ( card ( root-tree B99 ) ) = 1)
proof
let C100 being set;
L479: ( root-tree C100 ) = { [ ( {} ) , C100 ] } by TREES_4:6;
thus L480: thesis by L479 , CARD_1:30;
end;
begin
theorem
L481: (for B100 being non  empty  finite set holds ( ( card B100 ) - 1 ) = ( ( card B100 ) -' 1 ))
proof
let C101 being non  empty  finite set;
L482: ( ( card C101 ) - 1 ) >= ( 0 ) by NAT_1:14 , XREAL_1:48;
thus L483: thesis by L482 , XREAL_0:def 2;
end;
theorem
L484: (for B101 , B102 being Function holds (( dom B101 ) , ( dom B102 ) are_equipotent  iff B101 , B102 are_equipotent ))
proof
let C102 , C103 being Function;
L485: (( card C102 ) = ( card ( dom C102 ) ) & ( card C103 ) = ( card ( dom C103 ) )) by CARD_1:62;
thus L486:now
assume L487: ( dom C102 ) , ( dom C103 ) are_equipotent ;
L488: ( card ( dom C102 ) ) = ( card ( dom C103 ) ) by L487 , CARD_1:5;
thus L489: C102 , C103 are_equipotent  by L488 , L485 , CARD_1:5;
end;
assume L490: C102 , C103 are_equipotent ;
L491: ( card C102 ) = ( card C103 ) by L490 , CARD_1:5;
thus L492: thesis by L491 , L485 , CARD_1:5;
end;
theorem
L493: (for B103 , B104 being  finite Function holds (( dom B103 ) misses ( dom B104 ) implies ( card ( B103 +* B104 ) ) = ( ( card B103 ) + ( card B104 ) )))
proof
let C104 , C105 being  finite Function;
assume that
L494: ( dom C104 ) misses ( dom C105 );
thus L495: ( card ( C104 +* C105 ) ) = ( card ( dom ( C104 +* C105 ) ) ) by CARD_1:62
.= ( card ( ( dom C104 ) \/ ( dom C105 ) ) ) by FUNCT_4:def 1
.= ( ( card ( dom C104 ) ) + ( card ( dom C105 ) ) ) by L494 , CARD_2:40
.= ( ( card ( dom C104 ) ) + ( card C105 ) ) by CARD_1:62
.= ( ( card C104 ) + ( card C105 ) ) by CARD_1:62;
end;
theorem
L496: (for B105 being Nat holds { B106 where B106 is (Element of ( NAT )) : B106 > B105 } is  infinite)
proof
let C106 being Nat;
set D54 = { B107 where B107 is (Element of ( NAT )) : B107 > C106 };
L497: D54 c= ( NAT )
proof
let C107 being set;
assume L498: C107 in D54;
L499: (ex B108 being (Element of ( NAT )) st (C107 = B108 & B108 > C106)) by L498;
thus L500: thesis by L499;
end;
L501: ( C106 + 1 ) > ( C106 + ( 0 ) ) by XREAL_1:8;
L502: ( C106 + 1 ) in D54 by L501;
assume L503: D54 is  finite;
reconsider D55 = D54 as non  empty  finite (Subset of ( NAT )) by L503 , L497 , L502;
set D56 = ( max D55 );
L504: D56 in D55 by XXREAL_2:def 8;
consider C108 being (Element of ( NAT )) such that L505: D56 = C108 and L506: C108 > C106 by L504;
L507: ( C108 + 1 ) > ( C108 + ( 0 ) ) by XREAL_1:8;
L508: ( C108 + 1 ) > C106 by L507 , L506 , XXREAL_0:2;
L509: ( D56 + 1 ) in D55 by L508 , L505;
L510: ( D56 + 1 ) <= ( D56 + ( 0 ) ) by L509 , XXREAL_2:def 8;
thus L511: contradiction by L510 , XREAL_1:8;
end;
