:: On the Category of Posets
::  by Adam Grabowski
::
:: Received January 22, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies ORDERS_2, NATTRA_1, RELAT_1, STRUCT_0, XBOOLE_0, ORDERS_1,
      SUBSET_1, WELLORD1, RELAT_2, XXREAL_0, TARSKI, ZFMISC_1, FUNCT_1, SEQM_3,
      FUNCT_2, CAT_5, CAT_1, ALTCAT_1, PBOOLE, FUNCOP_1, BINOP_1, ORDERS_3,
      MONOID_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, ORDERS_1,
      CAT_5, XTUPLE_0, MCART_1, WELLORD1, MULTOP_1, PBOOLE, RELSET_1, PARTFUN1,
      FUNCT_2, BINOP_1, FUNCOP_1, DOMAIN_1, STRUCT_0, ORDERS_2, CAT_1, ENS_1,
      ALTCAT_1;
 constructors RELAT_2, WELLORD1, PARTFUN1, DOMAIN_1, ORDERS_2, ENS_1, CAT_5,
      ALTCAT_1, MULTOP_1, PBOOLE, RELSET_1, XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2,
      STRUCT_0, ORDERS_2, ENS_1, CAT_5, ALTCAT_1, XTUPLE_0;
 requirements BOOLE, SUBSET;
 definitions TARSKI, ALTCAT_1, FUNCOP_1, XBOOLE_0, STRUCT_0, XTUPLE_0;
 theorems RELAT_1, RELSET_1, ORDERS_2, TARSKI, ZFMISC_1, WELLORD1, SYSREL,
      FUNCT_1, FUNCT_2, MCART_1, ENS_1, PBOOLE, MULTOP_1, ALTCAT_1, XBOOLE_0,
      XBOOLE_1, PARTFUN1;
 schemes TARSKI, CAT_5, ALTCAT_1, XBOOLE_0;

begin
definition
let C1 being RelStr;
attr C1 is  discrete
means
:L1: (the InternalRel of C1) = ( id (the carrier of C1) );
end;
registration
cluster  strict  discrete non  empty for Poset;
existence
proof
set D1 = the non  empty set;
reconsider D2 = ( id D1 ) as (Relation of D1);
reconsider D3 = D2 as (Order of D1);
take RelStr (# D1 , D3 #);
thus L3: thesis by L1;
end;
end;
registration
cluster RelStr (# ( {} ) , ( id ( {} ) ) #) ->  empty;
coherence;
let C2 being  empty RelStr;
cluster (the InternalRel of C2) ->  empty;
coherence;
end;
L6: (for B1 being RelStr holds (B1 is  empty implies B1 is  discrete))
proof
let C3 being RelStr;
assume L7: C3 is  empty;
L8: ((the carrier of C3) = ( {} ) & (the InternalRel of C3) = ( {} )) by L7;
thus L9: thesis by L8 , L1 , RELAT_1:55;
end;
registration
cluster  empty ->  discrete for RelStr;
coherence by L6;
end;
definition
let C4 being RelStr;
let C5 being (Subset of C4);
attr C5 is  disconnected
means
:L11: (ex B2 , B3 being (Subset of C4) st (B2 <> ( {} ) & B3 <> ( {} ) & C5 = ( B2 \/ B3 ) & B2 misses B3 & (the InternalRel of C4) = ( ( (the InternalRel of C4) |_2 B2 ) \/ ( (the InternalRel of C4) |_2 B3 ) )));
end;
notation
let C6 being RelStr;
let C7 being (Subset of C6);
antonym C7 is  connected for C7 is  disconnected;
end;
definition
let C8 being RelStr;
attr C8 is  disconnected
means
:L14: ( [#] C8 ) is  disconnected;
end;
notation
let C9 being RelStr;
antonym C9 is  connected for C9 is  disconnected;
end;
theorem
L17: (for B4 being  discrete non  empty RelStr holds (for B5 , B6 being (Element of B4) holds (B5 <= B6 iff B5 = B6)))
proof
let C10 being  discrete non  empty RelStr;
let C11 , C12 being (Element of C10);
thus L18:now
assume L19: C11 <= C12;
L20: [ C11 , C12 ] in (the InternalRel of C10) by L19 , ORDERS_2:def 5;
L21: [ C11 , C12 ] in ( id (the carrier of C10) ) by L20 , L1;
thus L22: C11 = C12 by L21 , RELAT_1:def 10;
end;
assume L23: C11 = C12;
L24: [ C11 , C12 ] in ( id (the carrier of C10) ) by L23 , RELAT_1:def 10;
L25: [ C11 , C12 ] in (the InternalRel of C10) by L24 , L1;
thus L26: thesis by L25 , ORDERS_2:def 5;
end;
theorem
L27: (for B7 being Relation holds (for B8 being set holds (B7 is (Order of { B8 }) implies B7 = ( id { B8 } ))))
proof
let C13 being Relation;
let C14 being set;
assume L28: C13 is (Order of { C14 });
L29: C13 <> ( {} ) by L28;
L30: C13 c= [: { C14 } , { C14 } :] by L28;
L31: C13 c= { [ C14 , C14 ] } by L30 , ZFMISC_1:29;
L32: C13 = { [ C14 , C14 ] } by L31 , L29 , ZFMISC_1:33;
thus L33: thesis by L32 , SYSREL:13;
end;
theorem
L34: (for R1 being non  empty RelStr holds (for R2 being (Element of R1) holds ((R1 is  reflexive & ( [#] R1 ) = { R2 }) implies R1 is  discrete)))
proof
let R1 being non  empty RelStr;
let R2 being (Element of R1);
assume L35: R1 is  reflexive;
set D4 = (the InternalRel of R1);
assume L36: ( [#] R1 ) = { R2 };
L37: D4 = ( id { R2 } )
proof
L38: ( id { R2 } ) = { [ R2 , R2 ] } by SYSREL:13;
L39: D4 c= [: { R2 } , { R2 } :] by L36;
thus L40: D4 c= ( id { R2 } ) by L39 , L38 , ZFMISC_1:29;
let C15 being set;
assume L41: C15 in ( id { R2 } );
L42: C15 = [ R2 , R2 ] by L41 , L38 , TARSKI:def 1;
L43: R2 >= R2 by L35 , ORDERS_2:1;
thus L44: thesis by L43 , L42 , ORDERS_2:def 5;
end;
thus L45: thesis by L37 , L36 , L1;
end;
theorem
L46: (for R1 being non  empty RelStr holds (for R3 being set holds (( [#] R1 ) = { R3 } implies R1 is  connected)))
proof
let R1 being non  empty RelStr;
let R3 being set;
reconsider D5 = ( [#] R1 ) as non  empty set;
assume L47: ( [#] R1 ) = { R3 };
L48: (for B9 , B10 being non  empty (Subset of D5) holds (not B9 misses B10))
proof
let C16 , C17 being non  empty (Subset of D5);
L49: C16 = { R3 } by L47 , ZFMISC_1:33;
thus L50: thesis by L49 , L47 , ZFMISC_1:33;
end;
L51: ( [#] R1 ) is  connected
proof
assume L52: ( [#] R1 ) is  disconnected;
L53: (ex B11 , B12 being (Subset of R1) st (B11 <> ( {} ) & B12 <> ( {} ) & ( [#] R1 ) = ( B11 \/ B12 ) & B11 misses B12 & (the InternalRel of R1) = ( ( (the InternalRel of R1) |_2 B11 ) \/ ( (the InternalRel of R1) |_2 B12 ) ))) by L52 , L11;
thus L54: contradiction by L53 , L48;
end;
thus L55: thesis by L51 , L14;
end;
theorem
L56: (for B13 being  discrete non  empty Poset holds ((ex B14 , B15 being (Element of B13) st B14 <> B15) implies B13 is  disconnected))
proof
let C18 being  discrete non  empty Poset;
given C19 , C20 being (Element of C18) such that
L57: C19 <> C20;

L58: (not C20 in { C19 }) by L57 , TARSKI:def 1;
reconsider D6 = ( (the carrier of C18) \ { C19 } ) as non  empty (Subset of C18) by L58 , XBOOLE_0:def 5;
reconsider D7 = { C19 } as non  empty (Subset of C18);
L59: ((the carrier of C18) = ( ( (the carrier of C18) \ { C19 } ) \/ { C19 } ) & ( (the carrier of C18) \ { C19 } ) misses { C19 }) by XBOOLE_1:45 , XBOOLE_1:79;
L60: (the InternalRel of C18) c= ( [: D6 , D6 :] \/ [: D7 , D7 :] )
proof
let C21 being set;
assume L61: C21 in (the InternalRel of C18);
consider C22 , C23 being set such that L62: C21 = [ C22 , C23 ] by L61 , RELAT_1:def 1;
L63: C21 in ( id (the carrier of C18) ) by L61 , L1;
L64: C22 = C23 by L63 , L62 , RELAT_1:def 10;
per cases ;
suppose L65: C22 in D6;

L66: [: D6 , D6 :] c= ( [: D6 , D6 :] \/ [: D7 , D7 :] ) by XBOOLE_1:7;
L67: [ C22 , C22 ] in [: D6 , D6 :] by L65 , ZFMISC_1:87;
thus L68: thesis by L67 , L62 , L64 , L66;
end;
suppose L69: (not C22 in D6);

L70: C22 in (the carrier of C18) by L63 , L62 , RELAT_1:def 10;
L71: C22 in ( (the carrier of C18) \ D6 ) by L70 , L69 , XBOOLE_0:def 5;
L72: C22 in ( (the carrier of C18) /\ D7 ) by L71 , XBOOLE_1:48;
L73: C22 in D7 by L72 , XBOOLE_1:28;
L74: [ C22 , C22 ] in [: D7 , D7 :] by L73 , ZFMISC_1:87;
L75: [: D7 , D7 :] c= ( [: D6 , D6 :] \/ [: D7 , D7 :] ) by XBOOLE_1:7;
thus L76: thesis by L75 , L62 , L64 , L74;
end;
end;
L78: (the InternalRel of C18) = ( (the InternalRel of C18) /\ ( [: D6 , D6 :] \/ [: D7 , D7 :] ) ) by L60 , XBOOLE_1:28;
L79: (( (the InternalRel of C18) |_2 D6 ) = ( (the InternalRel of C18) /\ [: D6 , D6 :] ) & ( (the InternalRel of C18) |_2 D7 ) = ( (the InternalRel of C18) /\ [: D7 , D7 :] )) by WELLORD1:def 6;
L80: (the InternalRel of C18) = ( ( (the InternalRel of C18) |_2 D6 ) \/ ( (the InternalRel of C18) |_2 D7 ) ) by L79 , L78 , XBOOLE_1:23;
L81: ( [#] C18 ) is  disconnected by L80 , L59 , L11;
thus L82: thesis by L81 , L14;
end;
registration
cluster  strict  connected for non  empty non  empty non  empty non  empty Poset;
existence
proof
set D8 = the set;
reconsider D9 = RelStr (# { D8 } , ( id { D8 } ) #) as non  empty Poset;
L83: ( [#] D9 ) = { D8 };
L84: D9 is  connected by L83 , L46;
thus L85: thesis by L84;
end;
cluster  strict  disconnected  discrete for non  empty non  empty non  empty non  empty Poset;
existence
proof
L86: (ex B16 being non  empty Poset st (B16 is  strict & B16 is  disconnected & B16 is  discrete))
proof
reconsider D10 = RelStr (# { 1 , 2 } , ( id { 1 , 2 } ) #) as non  empty Poset;
reconsider D11 = D10 as  discrete non  empty Poset by L1;
take D11;
L87: (ex B17 , B18 being (Element of D11) st B17 <> B18)
proof
set D12 = 1;
set D13 = 2;
reconsider D14 = D12 , D15 = D13 as (Element of D11) by TARSKI:def 2;
take D14;
take D15;
thus L88: thesis;
end;
thus L89: thesis by L87 , L56;
end;
thus L90: thesis by L86;
end;
end;
begin
definition
let C24 being set;
attr C24 is  POSet_set-like
means
:L92: (for B19 being set holds (B19 in C24 implies B19 is non  empty non  empty non  empty non  empty Poset));
end;
registration
cluster non  empty  POSet_set-like for set;
existence
proof
set D16 = the non  empty Poset;
set D17 = { D16 };
take D17;
L94: (for B20 being set holds (B20 in D17 implies B20 is non  empty non  empty non  empty non  empty Poset)) by TARSKI:def 1;
thus L95: thesis by L94 , L92;
end;
end;
definition
mode POSet_set
 is  POSet_set-like set;
end;
definition
let C25 being non  empty POSet_set;
redefine mode Element of C25
 -> non  empty Poset;
coherence by L92;
end;
definition
let C26 , C27 being RelStr;
let C28 being (Function of C26 , C27);
attr C28 is  monotone
means
:L99: (for B21 , B22 being (Element of C26) holds (B21 <= B22 implies (for B23 , B24 being (Element of C27) holds ((B23 = ( C28 . B21 ) & B24 = ( C28 . B22 )) implies B23 <= B24))));
end;
L101: (for B25 , B26 , B27 being non  empty RelStr holds (for B28 being (Function of B25 , B26) holds (for B29 being (Function of B26 , B27) holds ((B28 is  monotone & B29 is  monotone) implies (ex B30 being (Function of B25 , B27) st (B30 = ( B29 * B28 ) & B30 is  monotone))))))
proof
let C29 , C30 , C31 being non  empty RelStr;
let C32 being (Function of C29 , C30);
let C33 being (Function of C30 , C31);
assume that
L102: C32 is  monotone
and
L103: C33 is  monotone;
reconsider D18 = ( C33 * C32 ) as (Function of C29 , C31);
take D18;
L104:
now
let C34 , C35 being (Element of C29);
reconsider D19 = ( C32 . C34 ) , D20 = ( C32 . C35 ) as (Element of C30);
L105: ( dom C32 ) = (the carrier of C29) by FUNCT_2:def 1;
L106: (( C33 . ( C32 . C34 ) ) = ( ( C33 * C32 ) . C34 ) & ( C33 . ( C32 . C35 ) ) = ( ( C33 * C32 ) . C35 )) by L105 , FUNCT_1:13;
assume L107: C34 <= C35;
L108: D19 <= D20 by L107 , L102 , L99;
let C36 , C37 being (Element of C31);
assume L109: (C36 = ( D18 . C34 ) & C37 = ( D18 . C35 ));
thus L110: C36 <= C37 by L109 , L103 , L106 , L108 , L99;
end;
thus L111: thesis by L104 , L99;
end;
L112: (for R1 being non  empty RelStr holds ( id R1 ) is  monotone)
proof
let R1 being non  empty RelStr;
set D21 = ( id R1 );
let C38 , C39 being (Element of R1);
assume L113: C38 <= C39;
let C40 , C41 being (Element of R1);
reconsider D22 = C38 as (Element of R1);
L114: ( D21 . D22 ) = D22 by FUNCT_1:18;
assume L115: (C40 = ( D21 . C38 ) & C41 = ( D21 . C39 ));
thus L116: thesis by L115 , L113 , L114 , FUNCT_1:18;
end;
definition
let C42 , C43 being RelStr;
func MonFuncs (C42 , C43) means 
:L117: (for R3 being set holds (R3 in it iff (ex B31 being (Function of C42 , C43) st (R3 = B31 & B31 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & B31 is  monotone))));
existence
proof
defpred S1[ set ] means (ex B32 being (Function of C42 , C43) st (B32 = $1 & B32 is  monotone));
consider C44 being set such that L118: (for B33 being set holds (B33 in C44 iff (B33 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & S1[ B33 ]))) from XBOOLE_0:sch 1;
take C44;
thus L119: (for R3 being set holds (R3 in C44 iff (ex B34 being (Function of C42 , C43) st (R3 = B34 & B34 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & B34 is  monotone))))
proof
let R3 being set;
thus L120:now
assume L121: R3 in C44;
consider C45 being (Function of C42 , C43) such that L122: (C45 = R3 & C45 is  monotone) by L121 , L118;
take D23 = C45;
thus L123: (R3 = D23 & D23 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & D23 is  monotone) by L118 , L121 , L122;
end;
given C46 being (Function of C42 , C43) such that
L124: (R3 = C46 & C46 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & C46 is  monotone);

thus L125: thesis by L118 , L124;
end;

end;
uniqueness
proof
let C47 , C48 being set;
assume that
L120: (for R3 being set holds (R3 in C47 iff (ex B35 being (Function of C42 , C43) st (R3 = B35 & B35 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & B35 is  monotone))))
and
L121: (for R3 being set holds (R3 in C48 iff (ex B36 being (Function of C42 , C43) st (R3 = B36 & B36 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & B36 is  monotone))));
L122: (for R3 being set holds (R3 in C48 implies R3 in C47))
proof
let R3 being set;
assume L123: R3 in C48;
L124: (ex B37 being (Function of C42 , C43) st (R3 = B37 & B37 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & B37 is  monotone)) by L123 , L121;
thus L125: thesis by L124 , L120;
end;
L126: C48 c= C47 by L122 , TARSKI:def 3;
L127: (for R3 being set holds (R3 in C47 implies R3 in C48))
proof
let R3 being set;
assume L128: R3 in C47;
L129: (ex B38 being (Function of C42 , C43) st (R3 = B38 & B38 in ( Funcs ((the carrier of C42) , (the carrier of C43)) ) & B38 is  monotone)) by L128 , L120;
thus L130: thesis by L129 , L121;
end;
L131: C47 c= C48 by L127 , TARSKI:def 3;
thus L132: C47 = C48 by L131 , L126 , XBOOLE_0:def 10;
end;
end;
theorem
L134: (for B39 , B40 , B41 being non  empty RelStr holds (for B42 , B43 being Function holds ((B42 in ( MonFuncs (B39 , B40) ) & B43 in ( MonFuncs (B40 , B41) )) implies ( B43 * B42 ) in ( MonFuncs (B39 , B41) ))))
proof
let C49 , C50 , C51 being non  empty RelStr;
let C52 , C53 being Function;
assume that
L135: C52 in ( MonFuncs (C49 , C50) )
and
L136: C53 in ( MonFuncs (C50 , C51) );
consider C54 being (Function of C49 , C50) such that L137: C52 = C54 and L138: C54 in ( Funcs ((the carrier of C49) , (the carrier of C50)) ) and L139: C54 is  monotone by L135 , L117;
consider C55 being (Function of C50 , C51) such that L140: C53 = C55 and L141: C55 in ( Funcs ((the carrier of C50) , (the carrier of C51)) ) and L142: C55 is  monotone by L136 , L117;
consider C56 being (Function of C49 , C51) such that L143: (C56 = ( C55 * C54 ) & C56 is  monotone) by L139 , L142 , L101;
L144: C56 in ( Funcs ((the carrier of C49) , (the carrier of C51)) ) by FUNCT_2:8;
thus L145: thesis by L144 , L137 , L140 , L143 , L117;
end;
theorem
L146: (for R1 being non  empty RelStr holds ( id (the carrier of R1) ) in ( MonFuncs (R1 , R1) ))
proof
let R1 being non  empty RelStr;
reconsider D24 = ( id R1 ) as (Function of (the carrier of R1) , (the carrier of R1));
reconsider D25 = D24 as (Function of R1 , R1);
L147: (( id R1 ) is  monotone & D25 in ( Funcs ((the carrier of R1) , (the carrier of R1)) )) by L112 , FUNCT_2:9;
thus L148: thesis by L147 , L117;
end;
registration
let R1 being non  empty RelStr;
cluster ( MonFuncs (R1 , R1) ) -> non  empty;
coherence by L146;
end;
definition
let C57 being set;
func Carr C57 -> set means 
:L150: (for R3 being set holds (R3 in it iff (ex B44 being 1-sorted st (B44 in C57 & R3 = (the carrier of B44)))));
existence
proof
defpred S2[ set , set ] means (ex B45 being 1-sorted st (B45 = $1 & $2 = (the carrier of B45)));
L151: (for B46 , B47 , B48 being set holds ((S2[ B46 , B47 ] & S2[ B46 , B48 ]) implies B47 = B48));
consider C58 being set such that L152: (for B49 being set holds (B49 in C58 iff (ex B50 being set st (B50 in C57 & S2[ B50 , B49 ])))) from TARSKI:sch 1(L151);
take C58;
let C59 being set;
L153: (C59 in C58 iff (ex B51 being 1-sorted st (B51 in C57 & C59 = (the carrier of B51))))
proof
thus L154: (C59 in C58 implies (ex B52 being 1-sorted st (B52 in C57 & C59 = (the carrier of B52))))
proof
assume L155: C59 in C58;
consider C60 being set such that L156: C60 in C57 and L157: (ex B53 being 1-sorted st (B53 = C60 & C59 = (the carrier of B53))) by L155 , L152;
consider C61 being 1-sorted such that L158: C61 = C60 and L159: C59 = (the carrier of C61) by L157;
take C61;
thus L160: thesis by L156 , L157 , L158;
end;

given C62 being 1-sorted such that
L161: (C62 in C57 & C59 = (the carrier of C62));

thus L162: thesis by L152 , L161;
end;
thus L163: thesis by L153;
end;
uniqueness
proof
let C63 , C64 being set;
assume that
L164: (for R3 being set holds (R3 in C63 iff (ex B54 being 1-sorted st (B54 in C57 & R3 = (the carrier of B54)))))
and
L165: (for R3 being set holds (R3 in C64 iff (ex B55 being 1-sorted st (B55 in C57 & R3 = (the carrier of B55)))));
L166: (for R3 being set holds (R3 in C63 iff R3 in C64))
proof
let R3 being set;
thus L167: (R3 in C63 implies R3 in C64)
proof
assume L168: R3 in C63;
L169: (ex B56 being 1-sorted st (B56 in C57 & R3 = (the carrier of B56))) by L168 , L164;
thus L170: thesis by L169 , L165;
end;

thus L171: (R3 in C64 implies R3 in C63)
proof
assume L172: R3 in C64;
L173: (ex B57 being 1-sorted st (B57 in C57 & R3 = (the carrier of B57))) by L172 , L165;
thus L174: thesis by L173 , L164;
end;

end;
thus L172: thesis by L166 , TARSKI:1;
end;
end;
L174: (for R4 being non  empty POSet_set holds (for R5 being (Element of R4) holds (the carrier of R5) in ( Carr R4 ))) by L150;
registration
let R4 being non  empty POSet_set;
cluster ( Carr R4 ) -> non  empty;
coherence by L174;
end;
theorem
L176: (for B58 being 1-sorted holds ( Carr { B58 } ) = { (the carrier of B58) })
proof
let C65 being 1-sorted;
thus L177: ( Carr { C65 } ) c= { (the carrier of C65) }
proof
let R3 being set;
assume L178: R3 in ( Carr { C65 } );
consider C66 being 1-sorted such that L179: C66 in { C65 } and L180: R3 = (the carrier of C66) by L178 , L150;
L181: C66 = C65 by L179 , TARSKI:def 1;
thus L182: thesis by L181 , L180 , TARSKI:def 1;
end;

L183: C65 in { C65 } by TARSKI:def 1;
thus L184: { (the carrier of C65) } c= ( Carr { C65 } )
proof
let R3 being set;
assume L185: R3 in { (the carrier of C65) };
L186: R3 = (the carrier of C65) by L185 , TARSKI:def 1;
thus L187: thesis by L186 , L183 , L150;
end;

end;
theorem
L185: (for B59 , B60 being 1-sorted holds ( Carr { B59 , B60 } ) = { (the carrier of B59) , (the carrier of B60) })
proof
let C67 , C68 being 1-sorted;
thus L186: ( Carr { C67 , C68 } ) c= { (the carrier of C67) , (the carrier of C68) }
proof
let R3 being set;
assume L187: R3 in ( Carr { C67 , C68 } );
consider C69 being 1-sorted such that L188: C69 in { C67 , C68 } and L189: R3 = (the carrier of C69) by L187 , L150;
per cases  by L188 , TARSKI:def 2;
suppose L190: C69 = C67;

thus L191: thesis by L190 , L189 , TARSKI:def 2;
end;
suppose L192: C69 = C68;

thus L193: thesis by L192 , L189 , TARSKI:def 2;
end;
end;

thus L195: { (the carrier of C67) , (the carrier of C68) } c= ( Carr { C67 , C68 } )
proof
let R3 being set;
L196: C67 in { C67 , C68 } by TARSKI:def 2;
L197: C68 in { C67 , C68 } by TARSKI:def 2;
assume L198: R3 in { (the carrier of C67) , (the carrier of C68) };
per cases  by L198 , TARSKI:def 2;
suppose L199: R3 = (the carrier of C67);

thus L200: thesis by L199 , L196 , L150;
end;
suppose L201: R3 = (the carrier of C68);

thus L202: thesis by L201 , L197 , L150;
end;
end;

end;
theorem
L196: (for R4 being non  empty POSet_set holds (for R5 being (Element of R4) holds (for R6 being (Element of R4) holds ( MonFuncs (R5 , R6) ) c= ( Funcs ( Carr R4 ) ))))
proof
let R4 being non  empty POSet_set;
let R5 being (Element of R4);
let R6 being (Element of R4);
reconsider D26 = (the carrier of R5) , D27 = (the carrier of R6) as (Element of ( Carr R4 )) by L150;
let C70 being set;
assume L197: C70 in ( MonFuncs (R5 , R6) );
L198: (ex B61 being (Function of R5 , R6) st (C70 = B61 & B61 in ( Funcs ((the carrier of R5) , (the carrier of R6)) ) & B61 is  monotone)) by L197 , L117;
L199: ( Funcs (D26 , D27) ) c= ( Funcs ( Carr R4 ) ) by ENS_1:2;
thus L200: thesis by L199 , L198;
end;
theorem
L201: (for B62 , B63 being RelStr holds ( MonFuncs (B62 , B63) ) c= ( Funcs ((the carrier of B62) , (the carrier of B63)) ))
proof
let C71 , C72 being RelStr;
let C73 being set;
assume L202: C73 in ( MonFuncs (C71 , C72) );
L203: (ex B64 being (Function of C71 , C72) st (C73 = B64 & B64 in ( Funcs ((the carrier of C71) , (the carrier of C72)) ) & B64 is  monotone)) by L202 , L117;
thus L204: thesis by L203;
end;
registration
let C74 , C75 being non  empty Poset;
cluster ( MonFuncs (C74 , C75) ) ->  functional;
coherence
proof
reconsider D28 = ( MonFuncs (C74 , C75) ) as (Subset of ( Funcs ((the carrier of C74) , (the carrier of C75)) )) by L201;
L205: D28 is  functional;
thus L206: thesis by L205;
end;
end;
definition
let C76 being non  empty POSet_set;
func POSCat C76 ->  strict  with_triple-like_morphisms Category means 
((the carrier of it) = C76 & (for B65 , B66 being (Element of C76) holds (for B67 being (Element of ( Funcs ( Carr C76 ) )) holds (B67 in ( MonFuncs (B65 , B66) ) implies [ [ B65 , B66 ] , B67 ] is (Morphism of it)))) & (for B68 being (Morphism of it) holds (ex B69 , B70 being (Element of C76) st (ex B71 being (Element of ( Funcs ( Carr C76 ) )) st (B68 = [ [ B69 , B70 ] , B71 ] & B71 in ( MonFuncs (B69 , B70) ))))) & (for B72 , B73 being (Morphism of it) holds (for B74 , B75 , B76 being (Element of C76) holds (for B77 , B78 being (Element of ( Funcs ( Carr C76 ) )) holds ((B72 = [ [ B74 , B75 ] , B77 ] & B73 = [ [ B75 , B76 ] , B78 ]) implies ( B73 (*) B72 ) = [ [ B74 , B76 ] , ( B78 * B77 ) ])))));
existence
proof
deffunc H1(Function , Function) = ( $1 * $2 );
defpred S3[ (Element of C76) , (Element of C76) , set ] means $3 in ( MonFuncs ($1 , $2) );
L208: (for B79 , B80 , B81 being (Element of C76) holds (for B82 , B83 being (Element of ( Funcs ( Carr C76 ) )) holds ((S3[ B79 , B80 , B82 ] & S3[ B80 , B81 , B83 ]) implies (H1(B83 , B82) in ( Funcs ( Carr C76 ) ) & S3[ B79 , B81 , H1(B83 , B82) ]))))
proof
let C77 , C78 , C79 being (Element of C76);
let C80 , C81 being (Element of ( Funcs ( Carr C76 ) ));
assume L209: (C80 in ( MonFuncs (C77 , C78) ) & C81 in ( MonFuncs (C78 , C79) ));
L210: ( C81 * C80 ) in ( MonFuncs (C77 , C79) ) by L209 , L134;
L211: ( MonFuncs (C77 , C79) ) c= ( Funcs ( Carr C76 ) ) by L196;
thus L212: thesis by L211 , L210;
end;
L213: (for B84 being (Element of C76) holds (ex B85 being (Element of ( Funcs ( Carr C76 ) )) st (S3[ B84 , B84 , B85 ] & (for B86 being (Element of C76) holds (for B87 being (Element of ( Funcs ( Carr C76 ) )) holds ((S3[ B84 , B86 , B87 ] implies H1(B87 , B85) = B87) & (S3[ B86 , B84 , B87 ] implies H1(B85 , B87) = B87)))))))
proof
let C82 being (Element of C76);
set D29 = ( id (the carrier of C82) );
L214: (( MonFuncs (C82 , C82) ) c= ( Funcs ( Carr C76 ) ) & D29 in ( MonFuncs (C82 , C82) )) by L146 , L196;
reconsider D30 = D29 as (Element of ( Funcs ( Carr C76 ) )) by L214;
take D30;
L215:
now
let C83 being (Element of C76);
let C84 being (Element of ( Funcs ( Carr C76 ) ));
L216: (C84 in ( MonFuncs (C83 , C82) ) implies ( D30 * C84 ) = C84)
proof
assume L217: C84 in ( MonFuncs (C83 , C82) );
L218: (ex B88 being (Function of C83 , C82) st (B88 = C84 & B88 in ( Funcs ((the carrier of C83) , (the carrier of C82)) ) & B88 is  monotone)) by L217 , L117;
reconsider D31 = C84 as (Function of (the carrier of C83) , (the carrier of C82)) by L218;
L219: ( rng D31 ) c= (the carrier of C82);
thus L220: thesis by L219 , RELAT_1:53;
end;
L221: (C84 in ( MonFuncs (C82 , C83) ) implies ( C84 * D30 ) = C84)
proof
assume L222: C84 in ( MonFuncs (C82 , C83) );
L223: (ex B89 being (Function of C82 , C83) st (B89 = C84 & B89 in ( Funcs ((the carrier of C82) , (the carrier of C83)) ) & B89 is  monotone)) by L222 , L117;
reconsider D32 = C84 as (Function of (the carrier of C82) , (the carrier of C83)) by L223;
L224: ( dom D32 ) = (the carrier of C82) by FUNCT_2:def 1;
thus L225: thesis by L224 , RELAT_1:51;
end;
thus L226: ((C84 in ( MonFuncs (C82 , C83) ) implies ( C84 * D30 ) = C84) & (C84 in ( MonFuncs (C83 , C82) ) implies ( D30 * C84 ) = C84)) by L221 , L216;
end;
thus L227: thesis by L215 , L146;
end;
L228: (for B90 , B91 , B92 , B93 being (Element of C76) holds (for B94 , B95 , B96 being (Element of ( Funcs ( Carr C76 ) )) holds ((S3[ B90 , B91 , B94 ] & S3[ B91 , B92 , B95 ] & S3[ B92 , B93 , B96 ]) implies H1(B96 , H1(B95 , B94)) = H1(H1(B96 , B95) , B94)))) by RELAT_1:36;
L229: (ex B97 being  with_triple-like_morphisms  strict Category st ((the carrier of B97) = C76 & (for B98 , B99 being (Element of C76) holds (for B100 being (Element of ( Funcs ( Carr C76 ) )) holds (S3[ B98 , B99 , B100 ] implies [ [ B98 , B99 ] , B100 ] is (Morphism of B97)))) & (for B101 being (Morphism of B97) holds (ex B102 , B103 being (Element of C76) st (ex B104 being (Element of ( Funcs ( Carr C76 ) )) st (B101 = [ [ B102 , B103 ] , B104 ] & S3[ B102 , B103 , B104 ])))) & (for B105 , B106 being (Morphism of B97) holds (for B107 , B108 , B109 being (Element of C76) holds (for B110 , B111 being (Element of ( Funcs ( Carr C76 ) )) holds ((B105 = [ [ B107 , B108 ] , B110 ] & B106 = [ [ B108 , B109 ] , B111 ]) implies ( B106 (*) B105 ) = [ [ B107 , B109 ] , H1(B111 , B110) ])))))) from CAT_5:sch 1(L208 , L213 , L228);
thus L230: thesis by L229;
end;
uniqueness
proof
deffunc H2((Element of ( Funcs ( Carr C76 ) )) , (Element of ( Funcs ( Carr C76 ) ))) = ( $1 * $2 );
defpred S4[ (Element of C76) , (Element of C76) , (Element of ( Funcs ( Carr C76 ) )) ] means $3 in ( MonFuncs ($1 , $2) );
L231:
now
let C85 being (Element of C76);
thus L232: (ex B112 being (Element of ( Funcs ( Carr C76 ) )) st (S4[ C85 , C85 , B112 ] & (for B113 being (Element of C76) holds (for B114 being (Element of ( Funcs ( Carr C76 ) )) holds ((S4[ C85 , B113 , B114 ] implies H2(B114 , B112) = B114) & (S4[ B113 , C85 , B114 ] implies H2(B112 , B114) = B114))))))
proof
set D33 = ( id (the carrier of C85) );
L233: D33 in ( MonFuncs (C85 , C85) ) by L146;
L234: ( MonFuncs (C85 , C85) ) c= ( Funcs ( Carr C76 ) ) by L196;
reconsider D34 = D33 as (Element of ( Funcs ( Carr C76 ) )) by L234 , L233;
L235:
now
let C86 being (Element of C76);
let C87 being (Element of ( Funcs ( Carr C76 ) ));
L236: (C87 in ( MonFuncs (C86 , C85) ) implies ( D34 * C87 ) = C87)
proof
assume L237: C87 in ( MonFuncs (C86 , C85) );
L238: (ex B115 being (Function of C86 , C85) st (B115 = C87 & B115 in ( Funcs ((the carrier of C86) , (the carrier of C85)) ) & B115 is  monotone)) by L237 , L117;
reconsider D35 = C87 as (Function of (the carrier of C86) , (the carrier of C85)) by L238;
L239: ( rng D35 ) c= (the carrier of C85);
thus L240: thesis by L239 , RELAT_1:53;
end;
L241: (C87 in ( MonFuncs (C85 , C86) ) implies ( C87 * D34 ) = C87)
proof
assume L242: C87 in ( MonFuncs (C85 , C86) );
L243: (ex B116 being (Function of C85 , C86) st (B116 = C87 & B116 in ( Funcs ((the carrier of C85) , (the carrier of C86)) ) & B116 is  monotone)) by L242 , L117;
reconsider D36 = C87 as (Function of (the carrier of C85) , (the carrier of C86)) by L243;
L244: ( dom D36 ) = (the carrier of C85) by FUNCT_2:def 1;
thus L245: thesis by L244 , RELAT_1:51;
end;
thus L246: ((C87 in ( MonFuncs (C85 , C86) ) implies ( C87 * D34 ) = C87) & (C87 in ( MonFuncs (C86 , C85) ) implies ( D34 * C87 ) = C87)) by L241 , L236;
end;
thus L247: thesis by L235 , L233;
end;

end;
thus L233: (for B117 , B118 being  strict  with_triple-like_morphisms Category holds (((the carrier of B117) = C76 & (for B119 , B120 being (Element of C76) holds (for B121 being (Element of ( Funcs ( Carr C76 ) )) holds (S4[ B119 , B120 , B121 ] implies [ [ B119 , B120 ] , B121 ] is (Morphism of B117)))) & (for B122 being (Morphism of B117) holds (ex B123 , B124 being (Element of C76) st (ex B125 being (Element of ( Funcs ( Carr C76 ) )) st (B122 = [ [ B123 , B124 ] , B125 ] & S4[ B123 , B124 , B125 ])))) & (for B126 , B127 being (Morphism of B117) holds (for B128 , B129 , B130 being (Element of C76) holds (for B131 , B132 being (Element of ( Funcs ( Carr C76 ) )) holds ((B126 = [ [ B128 , B129 ] , B131 ] & B127 = [ [ B129 , B130 ] , B132 ]) implies ( B127 (*) B126 ) = [ [ B128 , B130 ] , H2(B132 , B131) ])))) & (the carrier of B118) = C76 & (for B133 , B134 being (Element of C76) holds (for B135 being (Element of ( Funcs ( Carr C76 ) )) holds (S4[ B133 , B134 , B135 ] implies [ [ B133 , B134 ] , B135 ] is (Morphism of B118)))) & (for B136 being (Morphism of B118) holds (ex B137 , B138 being (Element of C76) st (ex B139 being (Element of ( Funcs ( Carr C76 ) )) st (B136 = [ [ B137 , B138 ] , B139 ] & S4[ B137 , B138 , B139 ])))) & (for B140 , B141 being (Morphism of B118) holds (for B142 , B143 , B144 being (Element of C76) holds (for B145 , B146 being (Element of ( Funcs ( Carr C76 ) )) holds ((B140 = [ [ B142 , B143 ] , B145 ] & B141 = [ [ B143 , B144 ] , B146 ]) implies ( B141 (*) B140 ) = [ [ B142 , B144 ] , H2(B146 , B145) ]))))) implies B117 = B118)) from CAT_5:sch 2(L231);
end;
end;
begin
scheme AltCatEx { F1() -> non  empty set , F2(set , set) ->  functional set } : (ex B147 being  strict AltCatStr st ((the carrier of B147) = F1() & (for B148 , B149 being (Element of F1()) holds (( (the Arrows of B147) . (B148 , B149) ) = F2(B148 , B149) & (for B150 , B151 , B152 being (Element of F1()) holds ( (the Comp of B147) . (B150 , B151 , B152) ) = ( FuncComp (F2(B150 , B151) , F2(B151 , B152)) ))))))
provided
L235: (for B153 , B154 , B155 being (Element of F1()) holds (for B156 , B157 being Function holds ((B156 in F2(B153 , B154) & B157 in F2(B154 , B155)) implies ( B157 * B156 ) in F2(B153 , B155))))
proof
deffunc H3(set , set , set) = ( FuncComp (F2($1 , $2) , F2($2 , $3)) );
consider C88 being (ManySortedSet of [: F1() , F1() :]) such that L236: (for B158 , B159 being (Element of F1()) holds ( C88 . (B158 , B159) ) = F2(B158 , B159)) from ALTCAT_1:sch 2;
consider C89 being (ManySortedSet of [: F1() , F1() , F1() :]) such that L237: (for B160 , B161 , B162 being (Element of F1()) holds ( C89 . (B160 , B161 , B162) ) = H3(B160 , B161 , B162)) from ALTCAT_1:sch 4;
L238: C89 is  Function-yielding
proof
let C90 being set;
assume L239: C90 in ( dom C89 );
L240: C90 in [: F1() , F1() , F1() :] by L239;
consider C91 , C92 , C93 being set such that L241: (C91 in F1() & C92 in F1() & C93 in F1()) and L242: C90 = [ C91 , C92 , C93 ] by L240 , MCART_1:68;
L243: ( C89 . C90 ) = ( C89 . (C91 , C92 , C93) ) by L242 , MULTOP_1:def 1
.= ( FuncComp (F2(C91 , C92) , F2(C92 , C93)) ) by L237 , L241;
thus L244: thesis by L243;
end;
reconsider D37 = C89 as (ManySortedFunction of [: F1() , F1() , F1() :]) by L238;
L245:
now
let C94 being set;
assume L246: C94 in [: F1() , F1() , F1() :];
consider C95 , C96 , C97 being set such that L247: C95 in F1() and L248: C96 in F1() and L249: C97 in F1() and L250: C94 = [ C95 , C96 , C97 ] by L246 , MCART_1:68;
L251: ( C88 . (C95 , C96) ) = F2(C95 , C96) by L236 , L247 , L248;
L252: [: F2(C96 , C97) , F2(C95 , C96) :] = [: ( C88 . (C96 , C97) ) , ( C88 . (C95 , C96) ) :] by L251 , L236 , L248 , L249
.= ( {| C88 , C88 |} . (C95 , C96 , C97) ) by L247 , L248 , L249 , ALTCAT_1:def 4
.= ( {| C88 , C88 |} . C94 ) by L250 , MULTOP_1:def 1;
L253: ( {| C88 |} . C94 ) = ( {| C88 |} . (C95 , C96 , C97) ) by L250 , MULTOP_1:def 1
.= ( C88 . (C95 , C97) ) by L247 , L248 , L249 , ALTCAT_1:def 3;
L254:
now
assume L255: ( {| C88 , C88 |} . C94 ) <> ( {} );
consider C98 being set such that L256: C98 in [: F2(C96 , C97) , F2(C95 , C96) :] by L255 , L252 , XBOOLE_0:def 1;
consider C99 , C100 being set such that L257: C99 in F2(C96 , C97) and L258: C100 in F2(C95 , C96) and L259: C98 = [ C99 , C100 ] by L256 , ZFMISC_1:84;
reconsider D38 = C100 as Function by L258;
reconsider D39 = C99 as Function by L257;
L260: ( D39 * D38 ) in F2(C95 , C97) by L235 , L247 , L248 , L249 , L257 , L258;
thus L261: ( {| C88 |} . C94 ) <> ( {} ) by L260 , L236 , L247 , L249 , L253;
end;
L262: ( D37 . C94 ) = ( D37 . (C95 , C96 , C97) ) by L250 , MULTOP_1:def 1
.= ( FuncComp (F2(C95 , C96) , F2(C96 , C97)) ) by L237 , L247 , L248 , L249;
reconsider D40 = ( D37 . C94 ) as Function by L262;
L263: ( dom D40 ) = [: F2(C96 , C97) , F2(C95 , C96) :] by L262 , PARTFUN1:def 2;
L264: ( rng ( FuncComp (F2(C95 , C96) , F2(C96 , C97)) ) ) c= F2(C95 , C97)
proof
set D41 = ( FuncComp (F2(C95 , C96) , F2(C96 , C97)) );
let C101 being set;
assume L265: C101 in ( rng D41 );
consider C102 being set such that L266: C102 in ( dom D41 ) and L267: C101 = ( D41 . C102 ) by L265 , FUNCT_1:def 3;
consider C103 , C104 being Function such that L268: C102 = [ C104 , C103 ] and L269: ( D41 . C102 ) = ( C104 * C103 ) by L266 , ALTCAT_1:def 9;
L270: (C104 in F2(C96 , C97) & C103 in F2(C95 , C96)) by L266 , L268 , ZFMISC_1:87;
thus L271: thesis by L270 , L235 , L247 , L248 , L249 , L267 , L269;
end;
L272: ( rng D40 ) c= ( {| C88 |} . C94 ) by L264 , L236 , L247 , L249 , L262 , L253;
thus L273: ( D37 . C94 ) is (Function of ( {| C88 , C88 |} . C94 ) , ( {| C88 |} . C94 )) by L272 , L263 , L252 , L254 , FUNCT_2:def 1 , RELSET_1:4;
end;
reconsider D42 = D37 as (BinComp of C88) by L245 , PBOOLE:def 15;
set D43 = AltCatStr (# F1() , C88 , D42 #);
take D43;
thus L274: (the carrier of D43) = F1();
let C105 , C106 being (Element of F1());
thus L275: ( (the Arrows of D43) . (C105 , C106) ) = F2(C105 , C106) by L236;
let C107 , C108 , C109 being (Element of F1());
thus L276: thesis by L237;
end;
scheme AltCatUniq { F3() -> non  empty set , F4(set , set) ->  functional set } : (for B163 , B164 being  strict AltCatStr holds (((the carrier of B163) = F3() & (for B165 , B166 being (Element of F3()) holds (( (the Arrows of B163) . (B165 , B166) ) = F4(B165 , B166) & (for B167 , B168 , B169 being (Element of F3()) holds ( (the Comp of B163) . (B167 , B168 , B169) ) = ( FuncComp (F4(B167 , B168) , F4(B168 , B169)) )))) & (the carrier of B164) = F3() & (for B170 , B171 being (Element of F3()) holds (( (the Arrows of B164) . (B170 , B171) ) = F4(B170 , B171) & (for B172 , B173 , B174 being (Element of F3()) holds ( (the Comp of B164) . (B172 , B173 , B174) ) = ( FuncComp (F4(B172 , B173) , F4(B173 , B174)) ))))) implies B163 = B164))
proof
let C110 , C111 being  strict AltCatStr;
assume that
L277: (the carrier of C110) = F3()
and
L278: (for B175 , B176 being (Element of F3()) holds (( (the Arrows of C110) . (B175 , B176) ) = F4(B175 , B176) & (for B177 , B178 , B179 being (Element of F3()) holds ( (the Comp of C110) . (B177 , B178 , B179) ) = ( FuncComp (F4(B177 , B178) , F4(B178 , B179)) ))))
and
L279: (the carrier of C111) = F3()
and
L280: (for B180 , B181 being (Element of F3()) holds (( (the Arrows of C111) . (B180 , B181) ) = F4(B180 , B181) & (for B182 , B183 , B184 being (Element of F3()) holds ( (the Comp of C111) . (B182 , B183 , B184) ) = ( FuncComp (F4(B182 , B183) , F4(B183 , B184)) ))));
L281:
now
let C112 , C113 , C114 being set;
assume L282: (C112 in F3() & C113 in F3() & C114 in F3());
thus L283: ( (the Comp of C110) . (C112 , C113 , C114) ) = ( FuncComp (F4(C112 , C113) , F4(C113 , C114)) ) by L282 , L278
.= ( (the Comp of C111) . (C112 , C113 , C114) ) by L280 , L282;
end;
L284:
now
let C115 , C116 being (Element of F3());
thus L285: ( (the Arrows of C110) . (C115 , C116) ) = F4(C115 , C116) by L278
.= ( (the Arrows of C111) . (C115 , C116) ) by L280;
end;
L286: (the Arrows of C110) = (the Arrows of C111) by L284 , L277 , L279 , ALTCAT_1:7;
thus L287: thesis by L286 , L277 , L279 , L281 , ALTCAT_1:8;
end;
definition
let C117 being non  empty POSet_set;
func POSAltCat C117 ->  strict AltCatStr means 
:L288: ((the carrier of it) = C117 & (for B185 , B186 being (Element of C117) holds (( (the Arrows of it) . (B185 , B186) ) = ( MonFuncs (B185 , B186) ) & (for B187 , B188 , B189 being (Element of C117) holds ( (the Comp of it) . (B187 , B188 , B189) ) = ( FuncComp (( MonFuncs (B187 , B188) ) , ( MonFuncs (B188 , B189) )) )))));
existence
proof
L289: (for B190 , B191 , B192 being (Element of C117) holds (for B193 , B194 being Function holds ((B193 in ( MonFuncs (B190 , B191) ) & B194 in ( MonFuncs (B191 , B192) )) implies ( B194 * B193 ) in ( MonFuncs (B190 , B192) )))) by L134;
thus L290: (ex B195 being  strict AltCatStr st ((the carrier of B195) = C117 & (for B196 , B197 being (Element of C117) holds (( (the Arrows of B195) . (B196 , B197) ) = ( MonFuncs (B196 , B197) ) & (for B198 , B199 , B200 being (Element of C117) holds ( (the Comp of B195) . (B198 , B199 , B200) ) = ( FuncComp (( MonFuncs (B198 , B199) ) , ( MonFuncs (B199 , B200) )) )))))) from AltCatEx(L289);
end;
uniqueness
proof
thus L291: (for B201 , B202 being  strict AltCatStr holds (((the carrier of B201) = C117 & (for B203 , B204 being (Element of C117) holds (( (the Arrows of B201) . (B203 , B204) ) = ( MonFuncs (B203 , B204) ) & (for B205 , B206 , B207 being (Element of C117) holds ( (the Comp of B201) . (B205 , B206 , B207) ) = ( FuncComp (( MonFuncs (B205 , B206) ) , ( MonFuncs (B206 , B207) )) )))) & (the carrier of B202) = C117 & (for B208 , B209 being (Element of C117) holds (( (the Arrows of B202) . (B208 , B209) ) = ( MonFuncs (B208 , B209) ) & (for B210 , B211 , B212 being (Element of C117) holds ( (the Comp of B202) . (B210 , B211 , B212) ) = ( FuncComp (( MonFuncs (B210 , B211) ) , ( MonFuncs (B211 , B212) )) ))))) implies B201 = B202)) from AltCatUniq;
end;
end;
registration
let C118 being non  empty POSet_set;
cluster ( POSAltCat C118 ) ->  transitive non  empty;
coherence
proof
set D44 = ( POSAltCat C118 );
thus L293: D44 is  transitive
proof
let C119 , C120 , C121 being (object of D44);
reconsider D45 = C119 , D46 = C120 , D47 = C121 as (Element of C118) by L288;
assume that
L294: <^ C119 , C120 ^> <> ( {} )
and
L295: <^ C120 , C121 ^> <> ( {} );
L296: ( MonFuncs (D45 , D46) ) <> ( {} ) by L294 , L288;
consider C122 being set such that L297: C122 in ( MonFuncs (D45 , D46) ) by L296 , XBOOLE_0:def 1;
L298: ( MonFuncs (D46 , D47) ) <> ( {} ) by L295 , L288;
consider C123 being set such that L299: C123 in ( MonFuncs (D46 , D47) ) by L298 , XBOOLE_0:def 1;
reconsider D48 = C122 , D49 = C123 as Function by L297 , L299;
L300: ( D49 * D48 ) in ( MonFuncs (D45 , D47) ) by L297 , L299 , L134;
thus L301: thesis by L300 , L288;
end;

thus L302: thesis by L288;
end;
end;
registration
let C124 being non  empty POSet_set;
cluster ( POSAltCat C124 ) ->  associative  with_units;
coherence
proof
set D50 = ( POSAltCat C124 );
set D51 = (the Arrows of D50);
set D52 = (the Comp of D50);
thus L304: D52 is  associative
proof
let C125 , C126 , C127 , C128 being (Element of D50);
let C129 , C130 , C131 being set;
reconsider D53 = C125 , D54 = C126 , D55 = C127 , D56 = C128 as (Element of C124) by L288;
assume that
L305: C129 in ( D51 . (C125 , C126) )
and
L306: C130 in ( D51 . (C126 , C127) )
and
L307: C131 in ( D51 . (C127 , C128) );
L308: C130 in ( MonFuncs (D54 , D55) ) by L306 , L288;
L309: C131 in ( MonFuncs (D55 , D56) ) by L307 , L288;
L310: C129 in ( MonFuncs (D53 , D54) ) by L305 , L288;
reconsider D57 = C129 , D58 = C130 , D59 = C131 as Function by L310 , L308 , L309;
L311: ( D52 . (C125 , C126 , C128) ) = ( FuncComp (( MonFuncs (D53 , D54) ) , ( MonFuncs (D54 , D56) )) ) by L288;
L312: ( D52 . (C126 , C127 , C128) ) = ( FuncComp (( MonFuncs (D54 , D55) ) , ( MonFuncs (D55 , D56) )) ) by L288;
L313: ( ( D52 . (C126 , C127 , C128) ) . (C131 , C130) ) = ( D59 * D58 ) by L312 , L308 , L309 , ALTCAT_1:11;
L314: ( D52 . (C125 , C126 , C127) ) = ( FuncComp (( MonFuncs (D53 , D54) ) , ( MonFuncs (D54 , D55) )) ) by L288;
L315: ( ( D52 . (C125 , C126 , C127) ) . (C130 , C129) ) = ( D58 * D57 ) by L314 , L310 , L308 , ALTCAT_1:11;
L316: ( D59 * D58 ) in ( MonFuncs (D54 , D56) ) by L308 , L309 , L134;
L317: ( ( D52 . (C125 , C126 , C128) ) . (( D59 * D58 ) , D57) ) = ( ( D59 * D58 ) * D57 ) by L316 , L310 , L311 , ALTCAT_1:11;
L318: ( D52 . (C125 , C127 , C128) ) = ( FuncComp (( MonFuncs (D53 , D55) ) , ( MonFuncs (D55 , D56) )) ) by L288;
L319: ( D58 * D57 ) in ( MonFuncs (D53 , D55) ) by L310 , L308 , L134;
L320: ( ( D52 . (C125 , C127 , C128) ) . (C131 , ( D58 * D57 )) ) = ( D59 * ( D58 * D57 ) ) by L319 , L309 , L318 , ALTCAT_1:11;
thus L321: thesis by L320 , L315 , L313 , L317 , RELAT_1:36;
end;

thus L322: D52 is  with_left_units
proof
let C132 being (Element of D50);
reconsider D60 = C132 as (Element of C124) by L288;
take D61 = ( id (the carrier of D60) );
L323: ( D51 . (C132 , C132) ) = ( MonFuncs (D60 , D60) ) by L288;
thus L324: D61 in ( D51 . (C132 , C132) ) by L323 , L146;
let C133 being (Element of D50);
let C134 being set;
reconsider D62 = C133 as (Element of C124) by L288;
L325: ( D52 . (C133 , C132 , C132) ) = ( FuncComp (( MonFuncs (D62 , D60) ) , ( MonFuncs (D60 , D60) )) ) by L288;
assume L326: C134 in ( D51 . (C133 , C132) );
L327: C134 in ( MonFuncs (D62 , D60) ) by L326 , L288;
consider C135 being (Function of D62 , D60) such that L328: C134 = C135 and L329: C135 in ( Funcs ((the carrier of D62) , (the carrier of D60)) ) and L330: C135 is  monotone by L327 , L117;
L331: D61 in ( MonFuncs (D60 , D60) ) by L146;
consider C136 being (Function of D60 , D60) such that L332: D61 = C136 and L333: C136 in ( Funcs ((the carrier of D60) , (the carrier of D60)) ) and L334: C136 is  monotone by L331 , L117;
L335: ( rng C135 ) c= (the carrier of D60);
L336: ( C136 * C135 ) = C134 by L335 , L332 , L328 , RELAT_1:53;
thus L337: thesis by L336 , L331 , L332 , L327 , L328 , L325 , ALTCAT_1:11;
end;

thus L338: D52 is  with_right_units
proof
let C137 being (Element of D50);
reconsider D63 = C137 as (Element of C124) by L288;
take D64 = ( id (the carrier of D63) );
L339: ( D51 . (C137 , C137) ) = ( MonFuncs (D63 , D63) ) by L288;
thus L340: D64 in ( D51 . (C137 , C137) ) by L339 , L146;
let C138 being (Element of D50);
let C139 being set;
reconsider D65 = C138 as (Element of C124) by L288;
L341: ( D52 . (C137 , C137 , C138) ) = ( FuncComp (( MonFuncs (D63 , D63) ) , ( MonFuncs (D63 , D65) )) ) by L288;
assume L342: C139 in ( D51 . (C137 , C138) );
L343: C139 in ( MonFuncs (D63 , D65) ) by L342 , L288;
consider C140 being (Function of D63 , D65) such that L344: C139 = C140 and L345: C140 in ( Funcs ((the carrier of D63) , (the carrier of D65)) ) and L346: C140 is  monotone by L343 , L117;
L347: D64 in ( MonFuncs (D63 , D63) ) by L146;
consider C141 being (Function of D63 , D63) such that L348: D64 = C141 and L349: C141 in ( Funcs ((the carrier of D63) , (the carrier of D63)) ) and L350: C141 is  monotone by L347 , L117;
L351: ( dom C140 ) = (the carrier of D63) by FUNCT_2:def 1;
L352: ( C140 * C141 ) = C139 by L351 , L348 , L344 , RELAT_1:52;
thus L353: thesis by L352 , L347 , L348 , L343 , L344 , L341 , ALTCAT_1:11;
end;

end;
end;
theorem
L340: (for R4 being non  empty POSet_set holds (for B213 , B214 being (object of ( POSAltCat R4 )) holds (for B215 , B216 being (Element of R4) holds ((B213 = B215 & B214 = B216) implies <^ B213 , B214 ^> c= ( Funcs ((the carrier of B215) , (the carrier of B216)) )))))
proof
let R4 being non  empty POSet_set;
let C142 , C143 being (object of ( POSAltCat R4 ));
let C144 , C145 being (Element of R4);
assume L341: (C142 = C144 & C143 = C145);
let C146 being set;
assume L342: C146 in <^ C142 , C143 ^>;
L343: C146 in ( MonFuncs (C144 , C145) ) by L342 , L341 , L288;
L344: (ex B217 being (Function of C144 , C145) st (B217 = C146 & B217 in ( Funcs ((the carrier of C144) , (the carrier of C145)) ) & B217 is  monotone)) by L343 , L117;
thus L345: thesis by L344;
end;
