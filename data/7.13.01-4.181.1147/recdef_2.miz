:: Recursive Definitions. {P}art {II}
::  by Artur Korni{\l}owicz
::
:: Received February 10, 2004
:: Copyright (c) 2004-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ZFMISC_1, XBOOLE_0, SUBSET_1, FUNCT_1, RELAT_1, FUNCT_4,
      TARSKI, CARD_1, ARYTM_3, MCART_1, NAT_1, ARYTM_1, XXREAL_0, FUNCT_7,
      RECDEF_2, XTUPLE_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, MCART_1, DOMAIN_1,
      NUMBERS, XCMPLX_0, ORDINAL1, NAT_1, NAT_D, RELAT_1, FUNCT_1, FUNCT_2,
      FUNCT_4, FUNCT_7, XXREAL_0;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, INT_1, BINARITH,
      FUNCT_7, NAT_D, RELSET_1, XTUPLE_0;
 registrations SUBSET_1, ORDINAL1, RELSET_1, XREAL_0, NAT_1, INT_1, XTUPLE_0;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, XTUPLE_0;
 theorems MCART_1, NAT_1, FUNCT_1, FUNCT_2, RELSET_1, INT_1, FUNCT_4, XBOOLE_0,
      XBOOLE_1, DOMAIN_1, FUNCT_7, XREAL_1, XXREAL_0, XREAL_0, NAT_D, XTUPLE_0;
 schemes NAT_1, RECDEF_1, FUNCT_1, XBOOLE_0, PARTFUN1;

begin
definition
let C1 being  triple set;
consider C2 , C3 , C4 being set such that L1: C1 = [ C2 , C3 , C4 ] by XTUPLE_0:def 5;
L2: ( [ C2 , C3 , C4 ] `1_3 ) = C2;
L3: ( [ C2 , C3 , C4 ] `2_3 ) = C3;
L4: ( [ C2 , C3 , C4 ] `3_3 ) = C4;
redefine func C1 `1_3 means 
:L5: (for B1 , B2 , B3 being set holds (C1 = [ B1 , B2 , B3 ] implies it = B1));
compatibility by L1 , L2 , XTUPLE_0:3;
redefine func C1 `2_3 means 
:L6: (for B4 , B5 , B6 being set holds (C1 = [ B4 , B5 , B6 ] implies it = B5));
compatibility by L1 , L3 , XTUPLE_0:3;
redefine func C1 `3_3 means 
:L7: (for B7 , B8 , B9 being set holds (C1 = [ B7 , B8 , B9 ] implies it = B9));
compatibility by L1 , L4 , XTUPLE_0:3;
end;
theorem
L9: (for R6 being set holds ((ex R1 being set st (ex R2 being set st (ex R3 being set st R6 = [ R1 , R2 , R3 ]))) implies R6 = [ ( R6 `1_3 ) , ( R6 `2_3 ) , ( R6 `3_3 ) ]))
proof
let R6 being set;
given R1 being set , R2 being set , R3 being set such that
L10: R6 = [ R1 , R2 , R3 ];

L11: (( R6 `1_3 ) = R1 & ( R6 `2_3 ) = R2) by L10 , L5 , L6;
thus L12: thesis by L11 , L10 , L7;
end;
theorem
L13: (for R6 being set holds (for R7 being set holds (for R8 being set holds (for R9 being set holds (R6 in [: R7 , R8 , R9 :] implies (( R6 `1_3 ) in R7 & ( R6 `2_3 ) in R8 & ( R6 `3_3 ) in R9))))))
proof
let R6 being set;
let R7 being set;
let R8 being set;
let R9 being set;
assume L14: R6 in [: R7 , R8 , R9 :];
L15: R9 is non  empty by L14 , MCART_1:31;
L16: (R7 is non  empty & R8 is non  empty) by L14 , MCART_1:31;
consider C5 being (Element of R7), C6 being (Element of R8), C7 being (Element of R9) such that L17: R6 = [ C5 , C6 , C7 ] by L16 , L14 , L15 , DOMAIN_1:3;
L18: ( R6 `3_3 ) = C7 by L17 , L7;
L19: (( R6 `1_3 ) = C5 & ( R6 `2_3 ) = C6) by L17 , L5 , L6;
thus L20: thesis by L19 , L16 , L15 , L18;
end;
theorem
L21: (for R6 being set holds (for R7 being set holds (for R8 being set holds (for R9 being set holds (R6 in [: R7 , R8 , R9 :] implies R6 = [ ( R6 `1_3 ) , ( R6 `2_3 ) , ( R6 `3_3 ) ])))))
proof
let R6 being set;
let R7 being set;
let R8 being set;
let R9 being set;
assume L22: R6 in [: R7 , R8 , R9 :];
L23: R9 is non  empty by L22 , MCART_1:31;
L24: (R7 is non  empty & R8 is non  empty) by L22 , MCART_1:31;
L25: (ex B10 being (Element of R7) st (ex B11 being (Element of R8) st (ex B12 being (Element of R9) st R6 = [ B10 , B11 , B12 ]))) by L24 , L22 , L23 , DOMAIN_1:3;
thus L26: thesis by L25 , L9;
end;
definition
let C8 being  quadruple set;
consider C9 , C10 , C11 , C12 being set such that L27: C8 = [ C9 , C10 , C11 , C12 ] by XTUPLE_0:def 9;
L28: ( [ C9 , C10 , C11 , C12 ] `1_4 ) = C9;
L29: ( [ C9 , C10 , C11 , C12 ] `2_4 ) = C10;
L30: ( [ C9 , C10 , C11 , C12 ] `3_4 ) = C11;
L31: ( [ C9 , C10 , C11 , C12 ] `4_4 ) = C12;
redefine func C8 `1_4 means 
:L32: (for B13 , B14 , B15 , B16 being set holds (C8 = [ B13 , B14 , B15 , B16 ] implies it = B13));
compatibility by L27 , L28 , XTUPLE_0:5;
redefine func C8 `2_4 means 
:L33: (for B17 , B18 , B19 , B20 being set holds (C8 = [ B17 , B18 , B19 , B20 ] implies it = B18));
compatibility by L27 , L29 , XTUPLE_0:5;
redefine func C8 `3_4 means 
:L34: (for B21 , B22 , B23 , B24 being set holds (C8 = [ B21 , B22 , B23 , B24 ] implies it = B23));
compatibility by L27 , L30 , XTUPLE_0:5;
redefine func C8 `4_4 means 
:L35: (for B25 , B26 , B27 , B28 being set holds (C8 = [ B25 , B26 , B27 , B28 ] implies it = B28));
compatibility by L27 , L31 , XTUPLE_0:5;
end;
theorem
L37: (for R6 being set holds ((ex R1 being set st (ex R2 being set st (ex R3 being set st (ex R4 being set st R6 = [ R1 , R2 , R3 , R4 ])))) implies R6 = [ ( R6 `1_4 ) , ( R6 `2_4 ) , ( R6 `3_4 ) , ( R6 `4_4 ) ]))
proof
let R6 being set;
given R1 being set , R2 being set , R3 being set , R4 being set such that
L38: R6 = [ R1 , R2 , R3 , R4 ];

L39: ( R6 `3_4 ) = R3 by L38 , L34;
L40: (( R6 `1_4 ) = R1 & ( R6 `2_4 ) = R2) by L38 , L32 , L33;
thus L41: thesis by L40 , L38 , L39 , L35;
end;
theorem
L42: (for R6 being set holds (for R7 being set holds (for R8 being set holds (for R9 being set holds (for R10 being set holds (R6 in [: R7 , R8 , R9 , R10 :] implies (( R6 `1_4 ) in R7 & ( R6 `2_4 ) in R8 & ( R6 `3_4 ) in R9 & ( R6 `4_4 ) in R10)))))))
proof
let R6 being set;
let R7 being set;
let R8 being set;
let R9 being set;
let R10 being set;
assume L43: R6 in [: R7 , R8 , R9 , R10 :];
L44: (R9 is non  empty & R10 is non  empty) by L43 , MCART_1:51;
L45: (R7 is non  empty & R8 is non  empty) by L43 , MCART_1:51;
consider C13 being (Element of R7), C14 being (Element of R8), C15 being (Element of R9), C16 being (Element of R10) such that L46: R6 = [ C13 , C14 , C15 , C16 ] by L45 , L43 , L44 , DOMAIN_1:10;
L47: (( R6 `3_4 ) = C15 & ( R6 `4_4 ) = C16) by L46 , L34 , L35;
L48: (( R6 `1_4 ) = C13 & ( R6 `2_4 ) = C14) by L46 , L32 , L33;
thus L49: thesis by L48 , L45 , L44 , L47;
end;
theorem
L50: (for R6 being set holds (for R7 being set holds (for R8 being set holds (for R9 being set holds (for R10 being set holds (R6 in [: R7 , R8 , R9 , R10 :] implies R6 = [ ( R6 `1_4 ) , ( R6 `2_4 ) , ( R6 `3_4 ) , ( R6 `4_4 ) ]))))))
proof
let R6 being set;
let R7 being set;
let R8 being set;
let R9 being set;
let R10 being set;
assume L51: R6 in [: R7 , R8 , R9 , R10 :];
L52: (R9 is non  empty & R10 is non  empty) by L51 , MCART_1:51;
L53: (R7 is non  empty & R8 is non  empty) by L51 , MCART_1:51;
L54: (ex B29 being (Element of R7) st (ex B30 being (Element of R8) st (ex B31 being (Element of R9) st (ex B32 being (Element of R10) st R6 = [ B29 , B30 , B31 , B32 ])))) by L53 , L51 , L52 , DOMAIN_1:10;
thus L55: thesis by L54 , L37;
end;
definition
canceled 5;
end;
canceled 3;
scheme ExFunc3Cond { F1() -> set , P1 , P2 , P3[set] , F2 , F3 , F4(set) -> set } : (ex B33 being Function st (( dom B33 ) = F1() & (for B34 being set holds (B34 in F1() implies ((P1[ B34 ] implies ( B33 . B34 ) = F2(B34)) & (P2[ B34 ] implies ( B33 . B34 ) = F3(B34)) & (P3[ B34 ] implies ( B33 . B34 ) = F4(B34)))))))
provided
L57: (for B35 being set holds (B35 in F1() implies ((P1[ B35 ] implies (not P2[ B35 ])) & (P1[ B35 ] implies (not P3[ B35 ])) & (P2[ B35 ] implies (not P3[ B35 ])))))
and
L58: (for B36 being set holds (B36 in F1() implies (P1[ B36 ] or P2[ B36 ] or P3[ B36 ])))
proof
consider C17 being set such that L59: (for B37 being set holds (B37 in C17 iff (B37 in F1() & P1[ B37 ]))) from XBOOLE_0:sch 1;
consider C18 being set such that L60: (for B38 being set holds (B38 in C18 iff (B38 in F1() & P3[ B38 ]))) from XBOOLE_0:sch 1;
consider C19 being Function such that L61: ( dom C19 ) = C17 and L62: (for B39 being set holds (B39 in C17 implies ( C19 . B39 ) = F2(B39))) from FUNCT_1:sch 3;
consider C20 being set such that L63: (for B40 being set holds (B40 in C20 iff (B40 in F1() & P2[ B40 ]))) from XBOOLE_0:sch 1;
consider C21 being Function such that L64: ( dom C21 ) = C18 and L65: (for B41 being set holds (B41 in C18 implies ( C21 . B41 ) = F4(B41))) from FUNCT_1:sch 3;
consider C22 being Function such that L66: ( dom C22 ) = C20 and L67: (for B42 being set holds (B42 in C20 implies ( C22 . B42 ) = F3(B42))) from FUNCT_1:sch 3;
set D1 = ( ( C19 +* C22 ) +* C21 );
take D1;
L68: ( dom D1 ) = ( ( dom ( C19 +* C22 ) ) \/ ( dom C21 ) ) by FUNCT_4:def 1
.= ( ( ( dom C19 ) \/ ( dom C22 ) ) \/ ( dom C21 ) ) by FUNCT_4:def 1;
thus L69: ( dom D1 ) = F1()
proof
L70: C18 c= F1()
proof
let C23 being set;
thus L71: thesis by L60;
end;
L72: C20 c= F1()
proof
let C24 being set;
thus L73: thesis by L63;
end;
L74: C17 c= F1()
proof
let C25 being set;
thus L75: thesis by L59;
end;
L76: ( C17 \/ C20 ) c= F1() by L74 , L72 , XBOOLE_1:8;
thus L77: ( dom D1 ) c= F1() by L76 , L61 , L66 , L64 , L68 , L70 , XBOOLE_1:8;
let C26 being set;
assume L78: C26 in F1();
L79: (P1[ C26 ] or P2[ C26 ] or P3[ C26 ]) by L78 , L58;
L80: (C26 in C17 or C26 in C20 or C26 in C18) by L79 , L59 , L63 , L60 , L78;
L81: (C26 in ( C17 \/ C20 ) or C26 in C18) by L80 , XBOOLE_0:def 3;
thus L82: thesis by L81 , L61 , L66 , L64 , L68 , XBOOLE_0:def 3;
end;

let C27 being set;
assume that
L83: C27 in F1();
thus L84:now
assume L85: P1[ C27 ];
L86: (not P2[ C27 ]) by L57 , L83 , L85;
L87: (not C27 in C20) by L86 , L63;
L88: (not P3[ C27 ]) by L57 , L83 , L85;
L89: (not C27 in C18) by L88 , L60;
thus L90: ( D1 . C27 ) = ( ( C19 +* C22 ) . C27 ) by L89 , L64 , FUNCT_4:11
.= ( C19 . C27 ) by L66 , L87 , FUNCT_4:11
.= F2(C27) by L62 , L85 , L59 , L83;
end;
thus L91:now
assume L92: P2[ C27 ];
L93: (not P3[ C27 ]) by L57 , L83 , L92;
L94: (not C27 in C18) by L93 , L60;
thus L95: ( D1 . C27 ) = ( ( C19 +* C22 ) . C27 ) by L94 , L64 , FUNCT_4:11
.= ( C22 . C27 ) by L66 , L92 , L63 , L83 , FUNCT_4:13
.= F3(C27) by L67 , L92 , L63 , L83;
end;
assume L96: P3[ C27 ];
thus L97: ( D1 . C27 ) = ( C21 . C27 ) by L96 , L64 , L60 , L83 , FUNCT_4:13
.= F4(C27) by L65 , L96 , L60 , L83;
end;
scheme ExFunc4Cond { F5() -> set , P4 , P5 , P6 , P7[set] , F6 , F7 , F8 , F9(set) -> set } : (ex B43 being Function st (( dom B43 ) = F5() & (for B44 being set holds (B44 in F5() implies ((P4[ B44 ] implies ( B43 . B44 ) = F6(B44)) & (P5[ B44 ] implies ( B43 . B44 ) = F7(B44)) & (P6[ B44 ] implies ( B43 . B44 ) = F8(B44)) & (P7[ B44 ] implies ( B43 . B44 ) = F9(B44)))))))
provided
L98: (for B45 being set holds (B45 in F5() implies ((P4[ B45 ] implies (not P5[ B45 ])) & (P4[ B45 ] implies (not P6[ B45 ])) & (P4[ B45 ] implies (not P7[ B45 ])) & (P5[ B45 ] implies (not P6[ B45 ])) & (P5[ B45 ] implies (not P7[ B45 ])) & (P6[ B45 ] implies (not P7[ B45 ])))))
and
L99: (for B46 being set holds (B46 in F5() implies (P4[ B46 ] or P5[ B46 ] or P6[ B46 ] or P7[ B46 ])))
proof
consider C28 being set such that L100: (for B47 being set holds (B47 in C28 iff (B47 in F5() & P4[ B47 ]))) from XBOOLE_0:sch 1;
consider C29 being set such that L101: (for B48 being set holds (B48 in C29 iff (B48 in F5() & P7[ B48 ]))) from XBOOLE_0:sch 1;
consider C30 being Function such that L102: ( dom C30 ) = C28 and L103: (for B49 being set holds (B49 in C28 implies ( C30 . B49 ) = F6(B49))) from FUNCT_1:sch 3;
consider C31 being set such that L104: (for B50 being set holds (B50 in C31 iff (B50 in F5() & P5[ B50 ]))) from XBOOLE_0:sch 1;
consider C32 being Function such that L105: ( dom C32 ) = C31 and L106: (for B51 being set holds (B51 in C31 implies ( C32 . B51 ) = F7(B51))) from FUNCT_1:sch 3;
consider C33 being set such that L107: (for B52 being set holds (B52 in C33 iff (B52 in F5() & P6[ B52 ]))) from XBOOLE_0:sch 1;
consider C34 being Function such that L108: ( dom C34 ) = C29 and L109: (for B53 being set holds (B53 in C29 implies ( C34 . B53 ) = F9(B53))) from FUNCT_1:sch 3;
consider C35 being Function such that L110: ( dom C35 ) = C33 and L111: (for B54 being set holds (B54 in C33 implies ( C35 . B54 ) = F8(B54))) from FUNCT_1:sch 3;
set D2 = ( ( ( C30 +* C32 ) +* C35 ) +* C34 );
take D2;
L112: ( dom D2 ) = ( ( dom ( ( C30 +* C32 ) +* C35 ) ) \/ ( dom C34 ) ) by FUNCT_4:def 1
.= ( ( ( dom ( C30 +* C32 ) ) \/ ( dom C35 ) ) \/ ( dom C34 ) ) by FUNCT_4:def 1
.= ( ( ( ( dom C30 ) \/ ( dom C32 ) ) \/ ( dom C35 ) ) \/ ( dom C34 ) ) by FUNCT_4:def 1;
thus L113: ( dom D2 ) = F5()
proof
L114: C29 c= F5()
proof
let C36 being set;
thus L115: thesis by L101;
end;
L116: C33 c= F5()
proof
let C37 being set;
thus L117: thesis by L107;
end;
L118: C31 c= F5()
proof
let C38 being set;
thus L119: thesis by L104;
end;
L120: C28 c= F5()
proof
let C39 being set;
thus L121: thesis by L100;
end;
L122: ( C28 \/ C31 ) c= F5() by L120 , L118 , XBOOLE_1:8;
L123: ( ( C28 \/ C31 ) \/ C33 ) c= F5() by L122 , L116 , XBOOLE_1:8;
thus L124: ( dom D2 ) c= F5() by L123 , L102 , L105 , L110 , L108 , L112 , L114 , XBOOLE_1:8;
let C40 being set;
assume L125: C40 in F5();
L126: (P4[ C40 ] or P5[ C40 ] or P6[ C40 ] or P7[ C40 ]) by L125 , L99;
L127: (C40 in C28 or C40 in C31 or C40 in C33 or C40 in C29) by L126 , L100 , L104 , L107 , L101 , L125;
L128: (C40 in ( C28 \/ C31 ) or C40 in C33 or C40 in C29) by L127 , XBOOLE_0:def 3;
L129: (C40 in ( ( C28 \/ C31 ) \/ C33 ) or C40 in C29) by L128 , XBOOLE_0:def 3;
thus L130: thesis by L129 , L102 , L105 , L110 , L108 , L112 , XBOOLE_0:def 3;
end;

let C41 being set;
assume that
L131: C41 in F5();
thus L132:now
assume L133: P4[ C41 ];
L134: (not P6[ C41 ]) by L98 , L131 , L133;
L135: (not C41 in C33) by L134 , L107;
L136: (not P5[ C41 ]) by L98 , L131 , L133;
L137: (not C41 in C31) by L136 , L104;
L138: (not P7[ C41 ]) by L98 , L131 , L133;
L139: (not C41 in C29) by L138 , L101;
thus L140: ( D2 . C41 ) = ( ( ( C30 +* C32 ) +* C35 ) . C41 ) by L139 , L108 , FUNCT_4:11
.= ( ( C30 +* C32 ) . C41 ) by L110 , L135 , FUNCT_4:11
.= ( C30 . C41 ) by L105 , L137 , FUNCT_4:11
.= F6(C41) by L103 , L133 , L100 , L131;
end;
thus L141:now
assume L142: P5[ C41 ];
L143: (not P6[ C41 ]) by L98 , L131 , L142;
L144: (not C41 in C33) by L143 , L107;
L145: (not P7[ C41 ]) by L98 , L131 , L142;
L146: (not C41 in C29) by L145 , L101;
thus L147: ( D2 . C41 ) = ( ( ( C30 +* C32 ) +* C35 ) . C41 ) by L146 , L108 , FUNCT_4:11
.= ( ( C30 +* C32 ) . C41 ) by L110 , L144 , FUNCT_4:11
.= ( C32 . C41 ) by L105 , L142 , L104 , L131 , FUNCT_4:13
.= F7(C41) by L106 , L142 , L104 , L131;
end;
thus L148:now
assume L149: P6[ C41 ];
L150: (not P7[ C41 ]) by L98 , L131 , L149;
L151: (not C41 in C29) by L150 , L101;
thus L152: ( D2 . C41 ) = ( ( ( C30 +* C32 ) +* C35 ) . C41 ) by L151 , L108 , FUNCT_4:11
.= ( C35 . C41 ) by L110 , L149 , L107 , L131 , FUNCT_4:13
.= F8(C41) by L111 , L149 , L107 , L131;
end;
assume L153: P7[ C41 ];
thus L154: ( D2 . C41 ) = ( C34 . C41 ) by L153 , L108 , L101 , L131 , FUNCT_4:13
.= F9(C41) by L109 , L153 , L101 , L131;
end;
scheme DoubleChoiceRec { F10 , F11() -> non  empty set , F12() -> (Element of F10()) , F13() -> (Element of F11()) , P8[set , set , set , set , set] } : (ex B55 being (Function of ( NAT ) , F10()) st (ex B56 being (Function of ( NAT ) , F11()) st (( B55 . ( 0 ) ) = F12() & ( B56 . ( 0 ) ) = F13() & (for B57 being (Element of ( NAT )) holds P8[ B57 , ( B55 . B57 ) , ( B56 . B57 ) , ( B55 . ( B57 + 1 ) ) , ( B56 . ( B57 + 1 ) ) ]))))
provided
L155: (for B58 being (Element of ( NAT )) holds (for B59 being (Element of F10()) holds (for B60 being (Element of F11()) holds (ex B61 being (Element of F10()) st (ex B62 being (Element of F11()) st P8[ B58 , B59 , B60 , B61 , B62 ])))))
proof
defpred S1[ set , set , set ] means P8[ $1 , ( $2 `1 ) , ( $2 `2 ) , ( $3 `1 ) , ( $3 `2 ) ];
L156: (for B63 being (Element of ( NAT )) holds (for B64 being (Element of [: F10() , F11() :]) holds (ex B65 being (Element of [: F10() , F11() :]) st S1[ B63 , B64 , B65 ])))
proof
let C42 being (Element of ( NAT ));
let C43 being (Element of [: F10() , F11() :]);
consider C44 being (Element of F10()), C45 being (Element of F11()) such that L157: P8[ C42 , ( C43 `1 ) , ( C43 `2 ) , C44 , C45 ] by L155;
take [ C44 , C45 ];
thus L158: thesis by L157;
end;
consider C46 being (Function of ( NAT ) , [: F10() , F11() :]) such that L159: ( C46 . ( 0 ) ) = [ F12() , F13() ] and L160: (for B66 being (Element of ( NAT )) holds S1[ B66 , ( C46 . B66 ) , ( C46 . ( B66 + 1 ) ) ]) from RECDEF_1:sch 2(L156);
take ( pr1 C46 );
take ( pr2 C46 );
L161: (( [ F12() , F13() ] `1 ) = F12() & ( [ F12() , F13() ] `2 ) = F13());
thus L162: (( ( pr1 C46 ) . ( 0 ) ) = F12() & ( ( pr2 C46 ) . ( 0 ) ) = F13()) by L161 , L159 , FUNCT_2:def 5 , FUNCT_2:def 6;
let C47 being (Element of ( NAT ));
L163: (( ( C46 . ( C47 + 1 ) ) `1 ) = ( ( pr1 C46 ) . ( C47 + 1 ) ) & ( ( C46 . ( C47 + 1 ) ) `2 ) = ( ( pr2 C46 ) . ( C47 + 1 ) )) by FUNCT_2:def 5 , FUNCT_2:def 6;
L164: (( ( C46 . C47 ) `1 ) = ( ( pr1 C46 ) . C47 ) & ( ( C46 . C47 ) `2 ) = ( ( pr2 C46 ) . C47 )) by FUNCT_2:def 5 , FUNCT_2:def 6;
thus L165: thesis by L164 , L160 , L163;
end;
scheme LambdaRec2Ex { F14 , F15() -> set , F16(set , set , set) -> set } : (ex B67 being Function st (( dom B67 ) = ( NAT ) & ( B67 . ( 0 ) ) = F14() & ( B67 . 1 ) = F15() & (for B68 being (Element of ( NAT )) holds ( B67 . ( B68 + 2 ) ) = F16(B68 , ( B67 . B68 ) , ( B67 . ( B68 + 1 ) )))))
proof
defpred S2[ set ] means $1 = ( 0 );
deffunc H1(Nat , set) = [ ( $2 `2_3 ) , ( $2 `3_3 ) , F16(( $1 + 1 ) , ( $2 `2_3 ) , ( $2 `3_3 )) ];
set D3 = F16(( 0 ) , F14() , F15());
set D4 = F16(1 , F15() , D3);
deffunc H2(Nat , set) = H1(( $1 + 1 ) , $2);
consider C48 being Function such that L166: ( dom C48 ) = ( NAT ) and L167: ( C48 . ( 0 ) ) = [ F15() , D3 , D4 ] and L168: (for B69 being Nat holds ( C48 . ( B69 + 1 ) ) = H2(B69 , ( C48 . B69 ))) from NAT_1:sch 11;
deffunc H3((Element of ( NAT ))) = ( C48 . ( $1 -' 1 ) );
deffunc H4(set) = [ F14() , F15() , D3 ];
consider C49 being Function such that L169: ( dom C49 ) = ( NAT ) and L170: (for B70 being (Element of ( NAT )) holds ((S2[ B70 ] implies ( C49 . B70 ) = H4(B70)) & ((not S2[ B70 ]) implies ( C49 . B70 ) = H3(B70)))) from PARTFUN1:sch 4;
deffunc H5(set) = ( ( C49 . $1 ) `1_3 );
consider C50 being Function such that L171: ( dom C50 ) = ( NAT ) and L172: (for B71 being set holds (B71 in ( NAT ) implies ( C50 . B71 ) = H5(B71))) from FUNCT_1:sch 3;
defpred S3[ (Element of ( NAT )) ] means (( C50 . ( $1 + 2 ) ) = ( ( C49 . ( $1 + 1 ) ) `2_3 ) & ( ( C49 . ( $1 + 1 ) ) `1_3 ) = ( ( C49 . $1 ) `2_3 ) & ( ( C49 . ( $1 + 2 ) ) `1_3 ) = ( ( C49 . $1 ) `3_3 ) & ( ( C49 . ( $1 + 2 ) ) `1_3 ) = ( ( C49 . ( $1 + 1 ) ) `2_3 ) & ( ( C49 . ( $1 + 2 ) ) `2_3 ) = ( ( C49 . ( $1 + 1 ) ) `3_3 ) & ( C50 . ( $1 + 2 ) ) = F16($1 , ( C50 . $1 ) , ( C50 . ( $1 + 1 ) )));
L173: ( C49 . ( 0 ) ) = [ F14() , F15() , D3 ] by L170;
L174: (for B72 being (Element of ( NAT )) holds ( C49 . ( B72 + 2 ) ) = H1(( B72 + 1 ) , ( C49 . ( B72 + 1 ) )))
proof
let C51 being (Element of ( NAT ));
L175: (( ( C51 + 2 ) - 1 ) = ( C51 + ( 2 - 1 ) ) & ( 0 ) <= ( C51 + 1 )) by NAT_1:2;
L176: ( C49 . ( C51 + 1 ) ) = H3(( C51 + 1 )) by L170
.= ( C48 . C51 ) by NAT_D:34;
thus L177: ( C49 . ( C51 + 2 ) ) = H3(( C51 + 2 )) by L170
.= ( C48 . ( C51 + 1 ) ) by L175 , XREAL_0:def 2
.= H1(( C51 + 1 ) , ( C49 . ( C51 + 1 ) )) by L168 , L176;
end;
L178: ( ( C49 . ( ( 0 ) + 2 ) ) `2_3 ) = ( H1(( ( 0 ) + 1 ) , ( C49 . ( ( 0 ) + 1 ) )) `2_3 ) by L174
.= ( ( C49 . ( ( 0 ) + 1 ) ) `3_3 );
take C50;
thus L179: ( dom C50 ) = ( NAT ) by L171;
thus L180: ( C50 . ( 0 ) ) = ( ( C49 . ( 0 ) ) `1_3 ) by L172
.= F14() by L173 , L5;
L181: ( C49 . 1 ) = H3(1) by L170
.= [ F15() , D3 , D4 ] by L167 , XREAL_1:232;
L182: ( ( C49 . ( ( 0 ) + 1 ) ) `1_3 ) = F15() by L181 , L5
.= ( ( C49 . ( 0 ) ) `2_3 ) by L173 , L6;
L183: (for B73 being (Element of ( NAT )) holds (S3[ B73 ] implies S3[ ( B73 + 1 ) ]))
proof
let C52 being (Element of ( NAT ));
assume L184: S3[ C52 ];
L185: ( C50 . ( C52 + 1 ) ) = ( ( C49 . C52 ) `2_3 ) by L184 , L172;
thus L186: ( C50 . ( ( C52 + 1 ) + 2 ) ) = ( ( C49 . ( ( C52 + 1 ) + 2 ) ) `1_3 ) by L172
.= ( H1(( ( C52 + 1 ) + 1 ) , ( C49 . ( ( C52 + 1 ) + 1 ) )) `1_3 ) by L174
.= ( ( C49 . ( ( C52 + 1 ) + 1 ) ) `2_3 );
thus L187: ( ( C49 . ( ( C52 + 1 ) + 1 ) ) `1_3 ) = ( ( C49 . ( C52 + 1 ) ) `2_3 ) by L184;
thus L188: ( ( C49 . ( ( C52 + 1 ) + 2 ) ) `1_3 ) = ( H1(( ( C52 + 1 ) + 1 ) , ( C49 . ( ( C52 + 1 ) + 1 ) )) `1_3 ) by L174
.= ( ( C49 . ( C52 + 1 ) ) `3_3 ) by L184;
thus L189: ( ( C49 . ( ( C52 + 1 ) + 2 ) ) `1_3 ) = ( ( C49 . ( ( C52 + 1 ) + 1 ) ) `2_3 ) by L188 , L184;
thus L190: ( ( C49 . ( ( C52 + 1 ) + 2 ) ) `2_3 ) = ( H1(( ( C52 + 1 ) + 1 ) , ( C49 . ( ( C52 + 1 ) + 1 ) )) `2_3 ) by L174
.= ( ( C49 . ( ( C52 + 1 ) + 1 ) ) `3_3 );
per cases ;
suppose L191: C52 = ( 0 );

thus L192: ( C50 . ( ( C52 + 1 ) + 2 ) ) = ( ( C49 . ( 1 + 2 ) ) `1_3 ) by L191 , L172
.= ( H1(( 1 + 1 ) , ( C49 . ( 1 + 1 ) )) `1_3 ) by L174
.= ( ( C49 . ( ( 0 ) + 1 ) ) `3_3 ) by L184 , L191
.= D4 by L181 , L7
.= F16(( ( 0 ) + 1 ) , F15() , ( ( C49 . ( 0 ) ) `3_3 )) by L173 , L7
.= F16(( C52 + 1 ) , ( C50 . ( C52 + 1 ) ) , ( C50 . ( ( C52 + 1 ) + 1 ) )) by L173 , L184 , L185 , L191 , L6;
end;
suppose L193: C52 <> ( 0 );

L194: ( 0 ) < C52 by L193 , NAT_1:3;
L195: ( ( 0 ) + 1 ) <= C52 by L194 , NAT_1:13;
L196: ( ( C52 -' 1 ) + 1 ) = C52 by L195 , XREAL_1:235;
L197: ( 1 - 1 ) <= ( C52 - 1 ) by L195 , XREAL_1:13;
L198: ( C52 - 1 ) = ( C52 -' 1 ) by L197 , XREAL_0:def 2;
L199: ( C52 + 1 ) = ( ( C52 - 1 ) + 2 );
thus L200: ( C50 . ( ( C52 + 1 ) + 2 ) ) = ( H1(( ( C52 -' 1 ) + 1 ) , ( C49 . ( ( C52 -' 1 ) + 1 ) )) `3_3 ) by L199 , L174 , L184 , L186 , L198
.= F16(( C52 + 1 ) , ( C50 . ( C52 + 1 ) ) , ( C50 . ( ( C52 + 1 ) + 1 ) )) by L184 , L185 , L196;
end;
end;
L202: ( C50 . ( ( 0 ) + 2 ) ) = ( ( C49 . ( ( 0 ) + 2 ) ) `1_3 ) by L172
.= ( H1(( ( 0 ) + 1 ) , ( C49 . ( ( 0 ) + 1 ) )) `1_3 ) by L174
.= ( ( C49 . ( ( 0 ) + 1 ) ) `2_3 );
thus L203: ( C50 . 1 ) = ( ( C49 . 1 ) `1_3 ) by L172
.= F15() by L181 , L5;
L204: ( ( C49 . ( ( 0 ) + 2 ) ) `1_3 ) = ( H1(( ( 0 ) + 1 ) , ( C49 . ( ( 0 ) + 1 ) )) `1_3 ) by L174
.= ( ( C49 . 1 ) `2_3 )
.= D3 by L181 , L6
.= ( ( C49 . ( 0 ) ) `3_3 ) by L173 , L7;
L205: ( ( C49 . ( ( 0 ) + 2 ) ) `1_3 ) = D3 by L204 , L173 , L7
.= ( ( C49 . ( ( 0 ) + 1 ) ) `2_3 ) by L181 , L6;
L206: S3[ ( 0 ) ] by L205 , L181 , L180 , L203 , L202 , L182 , L204 , L178 , L6;
L207: (for B74 being (Element of ( NAT )) holds S3[ B74 ]) from NAT_1:sch 1(L206 , L183);
thus L208: thesis by L207;
end;
scheme LambdaRec2ExD { F17() -> non  empty set , F18 , F19() -> (Element of F17()) , F20(set , set , set) -> (Element of F17()) } : (ex B75 being (Function of ( NAT ) , F17()) st (( B75 . ( 0 ) ) = F18() & ( B75 . 1 ) = F19() & (for B76 being (Element of ( NAT )) holds ( B75 . ( B76 + 2 ) ) = F20(B76 , ( B75 . B76 ) , ( B75 . ( B76 + 1 ) )))))
proof
consider C53 being Function such that L209: ( dom C53 ) = ( NAT ) and L210: (( C53 . ( 0 ) ) = F18() & ( C53 . 1 ) = F19()) and L211: (for B77 being (Element of ( NAT )) holds ( C53 . ( B77 + 2 ) ) = F20(B77 , ( C53 . B77 ) , ( C53 . ( B77 + 1 ) ))) from LambdaRec2Ex;
L212: ( rng C53 ) c= F17()
proof
let C54 being set;
assume L213: C54 in ( rng C53 );
consider C55 being set such that L214: C55 in ( dom C53 ) and L215: ( C53 . C55 ) = C54 by L213 , FUNCT_1:def 3;
reconsider D5 = C55 as (Element of ( NAT )) by L209 , L214;
per cases ;
suppose L216: D5 <= 1;

L217: (D5 = ( 0 ) or D5 = 1) by L216 , NAT_1:25;
thus L218: thesis by L217 , L210 , L215;
end;
suppose L219: D5 > 1;

L220: ( 1 + 1 ) <= D5 by L219 , NAT_1:13;
L221: ( D5 - 2 ) is (Element of ( NAT )) by L220 , INT_1:5;
L222: ( C53 . ( ( D5 - 2 ) + 2 ) ) = F20(( D5 - 2 ) , ( C53 . ( D5 - 2 ) ) , ( C53 . ( ( D5 - 2 ) + 1 ) )) by L221 , L211;
thus L223: thesis by L222 , L215;
end;
end;
L225: C53 is (Function of ( NAT ) , F17()) by L212 , L209 , FUNCT_2:def 1 , RELSET_1:4;
thus L226: thesis by L225 , L210 , L211;
end;
scheme LambdaRec2Un { F21 , F22() -> set , F23 , F24() -> Function , F25(set , set , set) -> set } : F23() = F24()
provided
L227: ( dom F23() ) = ( NAT )
and
L228: (( F23() . ( 0 ) ) = F21() & ( F23() . 1 ) = F22())
and
L229: (for B78 being (Element of ( NAT )) holds ( F23() . ( B78 + 2 ) ) = F25(B78 , ( F23() . B78 ) , ( F23() . ( B78 + 1 ) )))
and
L230: ( dom F24() ) = ( NAT )
and
L231: (( F24() . ( 0 ) ) = F21() & ( F24() . 1 ) = F22())
and
L232: (for B79 being (Element of ( NAT )) holds ( F24() . ( B79 + 2 ) ) = F25(B79 , ( F24() . B79 ) , ( F24() . ( B79 + 1 ) )))
proof
defpred S4[ Nat ] means ( F23() . $1 ) <> ( F24() . $1 );
assume L233: F23() <> F24();
L234: (ex B80 being set st (B80 in ( NAT ) & ( F23() . B80 ) <> ( F24() . B80 ))) by L233 , L227 , L230 , FUNCT_1:2;
L235: (ex B81 being Nat st S4[ B81 ]) by L234;
consider C56 being Nat such that L236: S4[ C56 ] and L237: (for B82 being Nat holds (S4[ B82 ] implies C56 <= B82)) from NAT_1:sch 5(L235);
L238:
now
set D6 = ( C56 -' 2 );
L239: (( F23() . ( D6 + 2 ) ) = F25(D6 , ( F23() . D6 ) , ( F23() . ( D6 + 1 ) )) & ( F24() . ( D6 + 2 ) ) = F25(D6 , ( F24() . D6 ) , ( F24() . ( D6 + 1 ) ))) by L229 , L232;
assume L240: (C56 <> ( 0 ) & C56 <> 1);
L241: 2 <= C56 by L240 , NAT_1:26;
L242: C56 = ( D6 + 2 ) by L241 , XREAL_1:235;
L243: ( F23() . ( D6 + 1 ) ) = ( F24() . ( D6 + 1 ) ) by L242 , L237 , XREAL_1:6;
L244: ( D6 + ( 0 ) ) < C56 by L242 , XREAL_1:6;
thus L245: contradiction by L244 , L236 , L237 , L242 , L243 , L239;
end;
thus L246: contradiction by L238 , L228 , L231 , L236;
end;
scheme LambdaRec2UnD { F26() -> non  empty set , F27 , F28() -> (Element of F26()) , F29 , F30() -> (Function of ( NAT ) , F26()) , F31(set , set , set) -> (Element of F26()) } : F29() = F30()
provided
L247: (( F29() . ( 0 ) ) = F27() & ( F29() . 1 ) = F28())
and
L248: (for B83 being (Element of ( NAT )) holds ( F29() . ( B83 + 2 ) ) = F31(B83 , ( F29() . B83 ) , ( F29() . ( B83 + 1 ) )))
and
L249: (( F30() . ( 0 ) ) = F27() & ( F30() . 1 ) = F28())
and
L250: (for B84 being (Element of ( NAT )) holds ( F30() . ( B84 + 2 ) ) = F31(B84 , ( F30() . B84 ) , ( F30() . ( B84 + 1 ) )))
proof
L251: ( dom F30() ) = ( NAT ) by FUNCT_2:def 1;
L252: ( dom F29() ) = ( NAT ) by FUNCT_2:def 1;
thus L253: F29() = F30() from LambdaRec2Un(L252 , L247 , L248 , L251 , L249 , L250);
end;
scheme LambdaRec3Ex { F32 , F33 , F34() -> set , F35(set , set , set , set) -> set } : (ex B85 being Function st (( dom B85 ) = ( NAT ) & ( B85 . ( 0 ) ) = F32() & ( B85 . 1 ) = F33() & ( B85 . 2 ) = F34() & (for B86 being (Element of ( NAT )) holds ( B85 . ( B86 + 3 ) ) = F35(B86 , ( B85 . B86 ) , ( B85 . ( B86 + 1 ) ) , ( B85 . ( B86 + 2 ) )))))
proof
defpred S5[ set ] means ( In ($1 , ( NAT )) ) > 1;
defpred S6[ set ] means $1 = 1;
defpred S7[ set ] means $1 = ( 0 );
deffunc H6(Nat , set) = [ ( $2 `2_4 ) , ( $2 `3_4 ) , ( $2 `4_4 ) , F35(( $1 + 1 ) , ( $2 `2_4 ) , ( $2 `3_4 ) , ( $2 `4_4 )) ];
set D7 = F35(( 0 ) , F32() , F33() , F34());
set D8 = F35(1 , F33() , F34() , D7);
set D9 = F35(2 , F34() , D7 , D8);
deffunc H7(Nat , set) = H6(( $1 + 2 ) , $2);
consider C57 being Function such that L254: ( dom C57 ) = ( NAT ) and L255: ( C57 . ( 0 ) ) = [ F34() , D7 , D8 , D9 ] and L256: (for B87 being Nat holds ( C57 . ( B87 + 1 ) ) = H7(B87 , ( C57 . B87 ))) from NAT_1:sch 11;
deffunc H8(set) = ( C57 . ( ( In ($1 , ( NAT )) ) -' 2 ) );
deffunc H9(set) = [ F33() , F34() , D7 , D8 ];
deffunc H10(set) = [ F32() , F33() , F34() , D7 ];
L257: (for B88 being set holds (B88 in ( NAT ) implies (S7[ B88 ] or S6[ B88 ] or S5[ B88 ])))
proof
let C58 being set;
assume L258: C58 in ( NAT );
L259: ( In (C58 , ( NAT )) ) = C58 by L258 , FUNCT_7:def 1;
thus L260: thesis by L259 , NAT_1:25;
end;
L261: (for B89 being set holds (B89 in ( NAT ) implies ((S7[ B89 ] implies (not S6[ B89 ])) & (S7[ B89 ] implies (not S5[ B89 ])) & (S6[ B89 ] implies (not S5[ B89 ])))))
proof
let C59 being set;
assume L262: C59 in ( NAT );
L263: ( In (C59 , ( NAT )) ) = C59 by L262 , FUNCT_7:def 1;
thus L264: thesis by L263;
end;
consider C60 being Function such that L265: ( dom C60 ) = ( NAT ) and L266: (for B90 being set holds (B90 in ( NAT ) implies ((S7[ B90 ] implies ( C60 . B90 ) = H10(B90)) & (S6[ B90 ] implies ( C60 . B90 ) = H9(B90)) & (S5[ B90 ] implies ( C60 . B90 ) = H8(B90))))) from ExFunc3Cond(L261 , L257);
L267: ( In (2 , ( NAT )) ) = 2 by FUNCT_7:def 1;
L268: ( C60 . 2 ) = H8(2) by L267 , L266
.= [ F34() , D7 , D8 , D9 ] by L255 , L267 , XREAL_1:232;
L269: (for B91 being (Element of ( NAT )) holds ( C60 . ( B91 + 3 ) ) = H6(( B91 + 2 ) , ( C60 . ( B91 + 2 ) )))
proof
let C61 being (Element of ( NAT ));
L270: ( In (( C61 + 2 ) , ( NAT )) ) = ( C61 + 2 ) by FUNCT_7:def 1;
L271: ( ( 0 ) + 1 ) < ( C61 + 2 ) by NAT_1:2 , XREAL_1:8;
L272: ( C60 . ( C61 + 2 ) ) = H8(( C61 + 2 )) by L271 , L266 , L270
.= ( C57 . C61 ) by L270 , NAT_D:34;
L273: ( In (( C61 + 3 ) , ( NAT )) ) = ( C61 + 3 ) by FUNCT_7:def 1;
L274: (( ( C61 + 3 ) - 2 ) = ( C61 + ( 3 - 2 ) ) & ( 0 ) <= ( C61 + 1 )) by NAT_1:2;
L275: ( ( 0 ) + 1 ) < ( C61 + 3 ) by NAT_1:2 , XREAL_1:8;
thus L276: ( C60 . ( C61 + 3 ) ) = H8(( C61 + 3 )) by L275 , L266 , L273
.= ( C57 . ( C61 + 1 ) ) by L273 , L274 , XREAL_0:def 2
.= H6(( C61 + 2 ) , ( C60 . ( C61 + 2 ) )) by L256 , L272;
end;
L277: ( C60 . 1 ) = [ F33() , F34() , D7 , D8 ] by L266;
L278: ( ( C60 . ( ( 0 ) + 1 ) ) `3_4 ) = D7 by L277 , L34
.= ( ( C60 . ( ( 0 ) + 2 ) ) `2_4 ) by L268 , L33;
L279: ( C60 . ( 0 ) ) = [ F32() , F33() , F34() , D7 ] by L266;
L280: ( ( C60 . ( 0 ) ) `3_4 ) = F34() by L279 , L34
.= ( ( C60 . ( ( 0 ) + 1 ) ) `2_4 ) by L277 , L33;
L281: ( ( C60 . ( ( 0 ) + 1 ) ) `4_4 ) = D8 by L277 , L35
.= ( ( C60 . ( ( 0 ) + 2 ) ) `3_4 ) by L268 , L34;
L282: ( ( C60 . ( 0 ) ) `4_4 ) = D7 by L279 , L35
.= ( ( C60 . ( ( 0 ) + 1 ) ) `3_4 ) by L277 , L34;
L283: ( ( C60 . ( ( 0 ) + 1 ) ) `1_4 ) = F33() by L277 , L32
.= ( ( C60 . ( 0 ) ) `2_4 ) by L279 , L33;
deffunc H11((Element of ( NAT ))) = ( ( C60 . $1 ) `1_4 );
consider C62 being Function such that L284: ( dom C62 ) = ( NAT ) and L285: (for B92 being (Element of ( NAT )) holds ( C62 . B92 ) = H11(B92)) from FUNCT_1:sch 4;
L286: ( C62 . ( ( 0 ) + 3 ) ) = ( ( C60 . ( ( 0 ) + 3 ) ) `1_4 ) by L285
.= ( H6(( ( 0 ) + 2 ) , ( C60 . ( ( 0 ) + 2 ) )) `1_4 ) by L269
.= ( ( C60 . ( ( 0 ) + 2 ) ) `2_4 );
take C62;
thus L287: ( dom C62 ) = ( NAT ) by L284;
defpred S8[ (Element of ( NAT )) ] means (( C62 . ( $1 + 3 ) ) = ( ( C60 . ( $1 + 2 ) ) `2_4 ) & ( ( C60 . $1 ) `2_4 ) = ( ( C60 . ( $1 + 1 ) ) `1_4 ) & ( ( C60 . $1 ) `3_4 ) = ( ( C60 . ( $1 + 1 ) ) `2_4 ) & ( ( C60 . $1 ) `4_4 ) = ( ( C60 . ( $1 + 1 ) ) `3_4 ) & ( ( C60 . ( $1 + 1 ) ) `2_4 ) = ( ( C60 . ( $1 + 2 ) ) `1_4 ) & ( ( C60 . ( $1 + 1 ) ) `3_4 ) = ( ( C60 . ( $1 + 2 ) ) `2_4 ) & ( ( C60 . ( $1 + 1 ) ) `4_4 ) = ( ( C60 . ( $1 + 2 ) ) `3_4 ) & ( ( C60 . ( $1 + 2 ) ) `2_4 ) = ( ( C60 . ( $1 + 3 ) ) `1_4 ) & ( C62 . ( $1 + 3 ) ) = F35($1 , ( C62 . $1 ) , ( C62 . ( $1 + 1 ) ) , ( C62 . ( $1 + 2 ) )));
L288: ( ( C60 . ( ( 0 ) + 2 ) ) `2_4 ) = ( H6(( ( 0 ) + 2 ) , ( C60 . ( ( 0 ) + 2 ) )) `1_4 )
.= ( ( C60 . ( ( 0 ) + 3 ) ) `1_4 ) by L269;
thus L289: ( C62 . ( 0 ) ) = ( ( C60 . ( 0 ) ) `1_4 ) by L285
.= F32() by L279 , L32;
thus L290: ( C62 . 1 ) = ( ( C60 . 1 ) `1_4 ) by L285
.= F33() by L277 , L32;
thus L291: ( C62 . 2 ) = ( ( C60 . 2 ) `1_4 ) by L285
.= F34() by L268 , L32;
L292: (for B93 being (Element of ( NAT )) holds (S8[ B93 ] implies S8[ ( B93 + 1 ) ]))
proof
let C63 being (Element of ( NAT ));
L293: ( ( C63 + 1 ) + 2 ) = ( C63 + ( 1 + 2 ) );
assume L294: S8[ C63 ];
L295: ( C62 . ( ( C63 + 1 ) + 1 ) ) = ( ( C60 . C63 ) `3_4 ) by L294 , L285;
thus L296: ( C62 . ( ( C63 + 1 ) + 3 ) ) = ( ( C60 . ( ( C63 + 1 ) + 3 ) ) `1_4 ) by L285
.= ( H6(( ( C63 + 1 ) + 2 ) , ( C60 . ( ( C63 + 1 ) + 2 ) )) `1_4 ) by L269
.= ( ( C60 . ( ( C63 + 1 ) + 2 ) ) `2_4 );
thus L297: ( ( C60 . ( ( C63 + 1 ) + 1 ) ) `1_4 ) = ( ( C60 . ( C63 + 1 ) ) `2_4 ) by L294;
thus L298: ( ( C60 . ( C63 + 1 ) ) `3_4 ) = ( ( C60 . ( ( C63 + 1 ) + 1 ) ) `2_4 ) by L294;
thus L299: ( ( C60 . ( C63 + 1 ) ) `4_4 ) = ( ( C60 . ( ( C63 + 1 ) + 1 ) ) `3_4 ) by L294;
thus L300: ( ( C60 . ( ( C63 + 1 ) + 1 ) ) `2_4 ) = ( H6(( C63 + 2 ) , ( C60 . ( C63 + 2 ) )) `1_4 )
.= ( ( C60 . ( ( C63 + 1 ) + 2 ) ) `1_4 ) by L269 , L293;
thus L301: ( ( C60 . ( ( C63 + 1 ) + 1 ) ) `3_4 ) = ( H6(( C63 + 2 ) , ( C60 . ( C63 + 2 ) )) `2_4 )
.= ( ( C60 . ( ( C63 + 1 ) + 2 ) ) `2_4 ) by L269 , L293;
thus L302: ( ( C60 . ( ( C63 + 1 ) + 1 ) ) `4_4 ) = ( H6(( C63 + 2 ) , ( C60 . ( C63 + 2 ) )) `3_4 )
.= ( ( C60 . ( ( C63 + 1 ) + 2 ) ) `3_4 ) by L269 , L293;
thus L303: ( ( C60 . ( ( C63 + 1 ) + 2 ) ) `2_4 ) = ( H6(( ( C63 + 1 ) + 2 ) , ( C60 . ( ( C63 + 1 ) + 2 ) )) `1_4 )
.= ( ( C60 . ( ( C63 + 1 ) + 3 ) ) `1_4 ) by L269;
per cases ;
suppose L304: (C63 <= 1 & C63 <> 1);

L305: C63 = ( 0 ) by L304 , NAT_1:25;
thus L306: ( C62 . ( ( C63 + 1 ) + 3 ) ) = ( ( C60 . ( 1 + 3 ) ) `1_4 ) by L305 , L285
.= ( H6(( 1 + 2 ) , ( C60 . ( 1 + 2 ) )) `1_4 ) by L269
.= ( ( C60 . ( ( 0 ) + 3 ) ) `2_4 )
.= ( H6(( ( 0 ) + 2 ) , ( C60 . ( ( 0 ) + 2 ) )) `2_4 ) by L269
.= ( ( C60 . ( ( 0 ) + 2 ) ) `3_4 )
.= D8 by L268 , L34
.= F35(( C63 + 1 ) , ( C62 . ( C63 + 1 ) ) , ( C62 . ( ( C63 + 1 ) + 1 ) ) , ( C62 . ( ( C63 + 1 ) + 2 ) )) by L279 , L290 , L291 , L294 , L305 , L35;
end;
suppose L307: C63 = 1;

L308: (( C62 . ( ( C63 + 1 ) + 1 ) ) = D7 & ( C62 . ( ( C63 + 1 ) + 2 ) ) = D8) by L307 , L277 , L294 , L295 , L34 , L35;
thus L309: ( C62 . ( ( C63 + 1 ) + 3 ) ) = ( ( C60 . ( ( 1 + 1 ) + 3 ) ) `1_4 ) by L285 , L307
.= ( H6(( 2 + 2 ) , ( C60 . ( 2 + 2 ) )) `1_4 ) by L269
.= ( ( C60 . ( 1 + 3 ) ) `2_4 )
.= ( H6(( 1 + 2 ) , ( C60 . ( 1 + 2 ) )) `2_4 ) by L269
.= ( ( C60 . ( ( 0 ) + 3 ) ) `3_4 )
.= ( H6(( ( 0 ) + 2 ) , ( C60 . ( ( 0 ) + 2 ) )) `3_4 ) by L269
.= ( ( C60 . ( ( 0 ) + 2 ) ) `4_4 )
.= F35(( C63 + 1 ) , ( C62 . ( C63 + 1 ) ) , ( C62 . ( ( C63 + 1 ) + 1 ) ) , ( C62 . ( ( C63 + 1 ) + 2 ) )) by L268 , L291 , L307 , L308 , L35;
end;
suppose L310: 1 < C63;

L311: ( 1 - 1 ) <= ( C63 - 1 ) by L310 , XREAL_1:13;
L312: ( C63 - 1 ) = ( C63 -' 1 ) by L311 , XREAL_0:def 2;
L313: ( 1 + 1 ) <= C63 by L310 , NAT_1:13;
L314: ( ( C63 -' 2 ) + 2 ) = C63 by L313 , XREAL_1:235;
L315: ( 2 - 2 ) <= ( C63 - 2 ) by L313 , XREAL_1:13;
L316: ( C63 - 2 ) = ( C63 -' 2 ) by L315 , XREAL_0:def 2;
L317: ( C63 + 1 ) = ( ( C63 - 1 ) + 2 );
thus L318: ( C62 . ( ( C63 + 1 ) + 3 ) ) = ( ( C60 . ( C63 + ( 1 + 2 ) ) ) `2_4 ) by L296
.= ( H6(( C63 + 2 ) , ( C60 . ( C63 + 2 ) )) `2_4 ) by L269
.= ( ( C60 . ( ( C63 -' 1 ) + 3 ) ) `3_4 ) by L312
.= ( H6(( C63 + 1 ) , ( C60 . ( C63 + 1 ) )) `3_4 ) by L269 , L312 , L317
.= ( ( C60 . ( ( C63 -' 2 ) + 3 ) ) `4_4 ) by L316
.= ( H6(( ( C63 -' 2 ) + 2 ) , ( C60 . ( ( C63 -' 2 ) + 2 ) )) `4_4 ) by L269
.= F35(( C63 + 1 ) , ( ( C60 . C63 ) `2_4 ) , ( ( C60 . C63 ) `3_4 ) , ( ( C60 . C63 ) `4_4 )) by L314
.= F35(( C63 + 1 ) , ( C62 . ( C63 + 1 ) ) , ( C62 . ( ( C63 + 1 ) + 1 ) ) , ( C62 . ( ( C63 + 1 ) + 2 ) )) by L285 , L294 , L295;
end;
end;
L320: ( ( C60 . ( ( 0 ) + 1 ) ) `2_4 ) = F34() by L277 , L33
.= ( ( C60 . ( ( 0 ) + 2 ) ) `1_4 ) by L268 , L32;
L321: S8[ ( 0 ) ] by L320 , L268 , L289 , L290 , L291 , L286 , L283 , L280 , L282 , L278 , L281 , L288 , L33;
L322: (for B94 being (Element of ( NAT )) holds S8[ B94 ]) from NAT_1:sch 1(L321 , L292);
thus L323: thesis by L322;
end;
scheme LambdaRec3ExD { F36() -> non  empty set , F37 , F38 , F39() -> (Element of F36()) , F40(set , set , set , set) -> (Element of F36()) } : (ex B95 being (Function of ( NAT ) , F36()) st (( B95 . ( 0 ) ) = F37() & ( B95 . 1 ) = F38() & ( B95 . 2 ) = F39() & (for B96 being (Element of ( NAT )) holds ( B95 . ( B96 + 3 ) ) = F40(B96 , ( B95 . B96 ) , ( B95 . ( B96 + 1 ) ) , ( B95 . ( B96 + 2 ) )))))
proof
consider C64 being Function such that L324: ( dom C64 ) = ( NAT ) and L325: (( C64 . ( 0 ) ) = F37() & ( C64 . 1 ) = F38() & ( C64 . 2 ) = F39()) and L326: (for B97 being (Element of ( NAT )) holds ( C64 . ( B97 + 3 ) ) = F40(B97 , ( C64 . B97 ) , ( C64 . ( B97 + 1 ) ) , ( C64 . ( B97 + 2 ) ))) from LambdaRec3Ex;
L327: ( rng C64 ) c= F36()
proof
let C65 being set;
assume L328: C65 in ( rng C64 );
consider C66 being set such that L329: C66 in ( dom C64 ) and L330: ( C64 . C66 ) = C65 by L328 , FUNCT_1:def 3;
reconsider D10 = C66 as (Element of ( NAT )) by L324 , L329;
per cases ;
suppose L331: D10 <= 2;

L332: (D10 = ( 0 ) or D10 = 1 or D10 = 2) by L331 , NAT_1:26;
thus L333: thesis by L332 , L325 , L330;
end;
suppose L334: D10 > 2;

L335: ( 2 + 1 ) <= D10 by L334 , NAT_1:13;
L336: ( D10 - 3 ) is (Element of ( NAT )) by L335 , INT_1:5;
L337: ( C64 . ( ( D10 - 3 ) + 3 ) ) = F40(( D10 - 3 ) , ( C64 . ( D10 - 3 ) ) , ( C64 . ( ( D10 - 3 ) + 1 ) ) , ( C64 . ( ( D10 - 3 ) + 2 ) )) by L336 , L326;
thus L338: thesis by L337 , L330;
end;
end;
L340: C64 is (Function of ( NAT ) , F36()) by L327 , L324 , FUNCT_2:def 1 , RELSET_1:4;
thus L341: thesis by L340 , L325 , L326;
end;
scheme LambdaRec3Un { F41 , F42 , F43() -> set , F44 , F45() -> Function , F46(set , set , set , set) -> set } : F44() = F45()
provided
L342: ( dom F44() ) = ( NAT )
and
L343: (( F44() . ( 0 ) ) = F41() & ( F44() . 1 ) = F42() & ( F44() . 2 ) = F43())
and
L344: (for B98 being (Element of ( NAT )) holds ( F44() . ( B98 + 3 ) ) = F46(B98 , ( F44() . B98 ) , ( F44() . ( B98 + 1 ) ) , ( F44() . ( B98 + 2 ) )))
and
L345: ( dom F45() ) = ( NAT )
and
L346: (( F45() . ( 0 ) ) = F41() & ( F45() . 1 ) = F42() & ( F45() . 2 ) = F43())
and
L347: (for B99 being (Element of ( NAT )) holds ( F45() . ( B99 + 3 ) ) = F46(B99 , ( F45() . B99 ) , ( F45() . ( B99 + 1 ) ) , ( F45() . ( B99 + 2 ) )))
proof
defpred S9[ Nat ] means ( F44() . $1 ) <> ( F45() . $1 );
assume L348: F44() <> F45();
L349: (ex B100 being set st (B100 in ( NAT ) & ( F44() . B100 ) <> ( F45() . B100 ))) by L348 , L342 , L345 , FUNCT_1:2;
L350: (ex B101 being Nat st S9[ B101 ]) by L349;
consider C67 being Nat such that L351: S9[ C67 ] and L352: (for B102 being Nat holds (S9[ B102 ] implies C67 <= B102)) from NAT_1:sch 5(L350);
L353:
now
set D11 = ( C67 -' 3 );
L354: (( F44() . ( D11 + 3 ) ) = F46(D11 , ( F44() . D11 ) , ( F44() . ( D11 + 1 ) ) , ( F44() . ( D11 + 2 ) )) & ( F45() . ( D11 + 3 ) ) = F46(D11 , ( F45() . D11 ) , ( F45() . ( D11 + 1 ) ) , ( F45() . ( D11 + 2 ) ))) by L344 , L347;
assume L355: (C67 <> ( 0 ) & C67 <> 1 & C67 <> 2);
L356: 3 <= C67 by L355 , NAT_1:27;
L357: C67 = ( D11 + 3 ) by L356 , XREAL_1:235;
L358: ( F44() . ( D11 + 1 ) ) = ( F45() . ( D11 + 1 ) ) by L357 , L352 , XREAL_1:6;
L359: ( F44() . ( D11 + 2 ) ) = ( F45() . ( D11 + 2 ) ) by L352 , L357 , XREAL_1:6;
L360: ( D11 + ( 0 ) ) < C67 by L357 , XREAL_1:6;
thus L361: contradiction by L360 , L351 , L352 , L357 , L358 , L359 , L354;
end;
thus L362: contradiction by L353 , L343 , L346 , L351;
end;
scheme LambdaRec3UnD { F47() -> non  empty set , F48 , F49 , F50() -> (Element of F47()) , F51 , F52() -> (Function of ( NAT ) , F47()) , F53(set , set , set , set) -> (Element of F47()) } : F51() = F52()
provided
L363: (( F51() . ( 0 ) ) = F48() & ( F51() . 1 ) = F49() & ( F51() . 2 ) = F50())
and
L364: (for B103 being (Element of ( NAT )) holds ( F51() . ( B103 + 3 ) ) = F53(B103 , ( F51() . B103 ) , ( F51() . ( B103 + 1 ) ) , ( F51() . ( B103 + 2 ) )))
and
L365: (( F52() . ( 0 ) ) = F48() & ( F52() . 1 ) = F49() & ( F52() . 2 ) = F50())
and
L366: (for B104 being (Element of ( NAT )) holds ( F52() . ( B104 + 3 ) ) = F53(B104 , ( F52() . B104 ) , ( F52() . ( B104 + 1 ) ) , ( F52() . ( B104 + 2 ) )))
proof
L367: ( dom F52() ) = ( NAT ) by FUNCT_2:def 1;
L368: ( dom F51() ) = ( NAT ) by FUNCT_2:def 1;
thus L369: F51() = F52() from LambdaRec3Un(L368 , L363 , L364 , L367 , L365 , L366);
end;
scheme LambdaRec4Un { F54 , F55 , F56 , F57() -> set , F58 , F59() -> Function , F60(set , set , set , set , set) -> set } : F58() = F59()
provided
L370: ( dom F58() ) = ( NAT )
and
L371: (( F58() . ( 0 ) ) = F54() & ( F58() . 1 ) = F55() & ( F58() . 2 ) = F56() & ( F58() . 3 ) = F57())
and
L372: (for B105 being (Element of ( NAT )) holds ( F58() . ( B105 + 4 ) ) = F60(B105 , ( F58() . B105 ) , ( F58() . ( B105 + 1 ) ) , ( F58() . ( B105 + 2 ) ) , ( F58() . ( B105 + 3 ) )))
and
L373: ( dom F59() ) = ( NAT )
and
L374: (( F59() . ( 0 ) ) = F54() & ( F59() . 1 ) = F55() & ( F59() . 2 ) = F56() & ( F59() . 3 ) = F57())
and
L375: (for B106 being (Element of ( NAT )) holds ( F59() . ( B106 + 4 ) ) = F60(B106 , ( F59() . B106 ) , ( F59() . ( B106 + 1 ) ) , ( F59() . ( B106 + 2 ) ) , ( F59() . ( B106 + 3 ) )))
proof
defpred S10[ Nat ] means ( F58() . $1 ) <> ( F59() . $1 );
assume L376: F58() <> F59();
L377: (ex B107 being set st (B107 in ( NAT ) & ( F58() . B107 ) <> ( F59() . B107 ))) by L376 , L370 , L373 , FUNCT_1:2;
L378: (ex B108 being Nat st S10[ B108 ]) by L377;
consider C68 being Nat such that L379: S10[ C68 ] and L380: (for B109 being Nat holds (S10[ B109 ] implies C68 <= B109)) from NAT_1:sch 5(L378);
L381:
now
set D12 = ( C68 -' 4 );
L382: (( F58() . ( D12 + 4 ) ) = F60(D12 , ( F58() . D12 ) , ( F58() . ( D12 + 1 ) ) , ( F58() . ( D12 + 2 ) ) , ( F58() . ( D12 + 3 ) )) & ( F59() . ( D12 + 4 ) ) = F60(D12 , ( F59() . D12 ) , ( F59() . ( D12 + 1 ) ) , ( F59() . ( D12 + 2 ) ) , ( F59() . ( D12 + 3 ) ))) by L372 , L375;
assume L383: (C68 <> ( 0 ) & C68 <> 1 & C68 <> 2 & C68 <> 3);
L384: 4 <= C68 by L383 , NAT_1:28;
L385: C68 = ( D12 + 4 ) by L384 , XREAL_1:235;
L386: ( F58() . ( D12 + 1 ) ) = ( F59() . ( D12 + 1 ) ) by L385 , L380 , XREAL_1:6;
L387: ( D12 + 3 ) < C68 by L385 , XREAL_1:6;
L388: ( F58() . ( D12 + 3 ) ) = ( F59() . ( D12 + 3 ) ) by L387 , L380;
L389: ( D12 + 2 ) < C68 by L385 , XREAL_1:6;
L390: ( F58() . ( D12 + 2 ) ) = ( F59() . ( D12 + 2 ) ) by L389 , L380;
L391: ( D12 + ( 0 ) ) < C68 by L385 , XREAL_1:6;
thus L392: contradiction by L391 , L379 , L380 , L385 , L386 , L390 , L388 , L382;
end;
thus L393: contradiction by L381 , L371 , L374 , L379;
end;
scheme LambdaRec4UnD { F61() -> non  empty set , F62 , F63 , F64 , F65() -> (Element of F61()) , F66 , F67() -> (Function of ( NAT ) , F61()) , F68(set , set , set , set , set) -> (Element of F61()) } : F66() = F67()
provided
L394: (( F66() . ( 0 ) ) = F62() & ( F66() . 1 ) = F63() & ( F66() . 2 ) = F64() & ( F66() . 3 ) = F65())
and
L395: (for B110 being (Element of ( NAT )) holds ( F66() . ( B110 + 4 ) ) = F68(B110 , ( F66() . B110 ) , ( F66() . ( B110 + 1 ) ) , ( F66() . ( B110 + 2 ) ) , ( F66() . ( B110 + 3 ) )))
and
L396: (( F67() . ( 0 ) ) = F62() & ( F67() . 1 ) = F63() & ( F67() . 2 ) = F64() & ( F67() . 3 ) = F65())
and
L397: (for B111 being (Element of ( NAT )) holds ( F67() . ( B111 + 4 ) ) = F68(B111 , ( F67() . B111 ) , ( F67() . ( B111 + 1 ) ) , ( F67() . ( B111 + 2 ) ) , ( F67() . ( B111 + 3 ) )))
proof
L398: ( dom F67() ) = ( NAT ) by FUNCT_2:def 1;
L399: ( dom F66() ) = ( NAT ) by FUNCT_2:def 1;
thus L400: F66() = F67() from LambdaRec4Un(L399 , L394 , L395 , L398 , L396 , L397);
end;
begin
theorem
L401: (for B112 , B113 , B114 , B115 , B116 being set holds ((( B112 `1_3 ) = ( B113 `1_3 ) & ( B112 `2_3 ) = ( B113 `2_3 ) & ( B112 `3_3 ) = ( B113 `3_3 ) & B113 in [: B114 , B115 , B116 :] & B112 in [: B114 , B115 , B116 :]) implies B112 = B113))
proof
let C69 , C70 , C71 , C72 , C73 being set;
assume L402: (( C69 `1_3 ) = ( C70 `1_3 ) & ( C69 `2_3 ) = ( C70 `2_3 ) & ( C69 `3_3 ) = ( C70 `3_3 ) & C70 in [: C71 , C72 , C73 :]);
assume L403: C69 in [: C71 , C72 , C73 :];
thus L404: C69 = [ ( C69 `1_3 ) , ( C69 `2_3 ) , ( C69 `3_3 ) ] by L403 , L21
.= C70 by L402 , L21;
end;
