:: Properties of Fields
::  by J\'ozef Bia{\l}as
::
:: Received June 20, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies BINOP_1, CARD_1, FUNCOP_1, FUNCT_4, RELAT_1, XBOOLE_0, ZFMISC_1,
      TARSKI, FUNCT_7, SUBSET_1, FUNCT_1, ALGSTR_0, ARYTM_3, SUPINF_2,
      REALSET1, VECTSP_1, STRUCT_0, MESFUNC1, RLVECT_1, LATTICES, ARYTM_1,
      REALSET2, MEMBERED;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, RELAT_1, FUNCT_1,
      NUMBERS, REALSET1, FUNCOP_1, FUNCT_2, BINOP_1, FUNCT_4, FUNCT_7,
      ORDINAL1, MEMBERED, STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1, VECTSP_1;
 constructors RLVECT_1, BINOP_1, FUNCT_4, REALSET1, FUNCT_7, VECTSP_1,
      RELSET_1, MEMBERED;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, REALSET1, STRUCT_0, RLVECT_1,
      VECTSP_1, ORDINAL1, ALGSTR_0, ZFMISC_1, CARD_1;
 requirements SUBSET, BOOLE, NUMERALS;
 definitions RLVECT_1, TARSKI, REALSET1, BINOP_1, MEMBERED, STRUCT_0, FUNCOP_1,
      VECTSP_1, GROUP_1, ALGSTR_0;
 theorems TARSKI, FUNCT_1, FUNCT_2, ZFMISC_1, ENUMSET1, REALSET1, VECTSP_1,
      RELSET_1, XBOOLE_0, RLVECT_1, FUNCT_4, FUNCOP_1, CARD_1, XBOOLE_1,
      FUNCT_7, STRUCT_0, GROUP_1, ALGSTR_0, XTUPLE_0;
 schemes FUNCT_2;

begin
definition
func add_2 -> (BinOp of 2) equals 
( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) ) +* ( (1 , ( 0 )) .--> 1 ) ) +* ( (1 , 1) .--> ( 0 ) ) );
coherence
proof
set D1 = ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) );
set D2 = ( D1 +* ( (1 , ( 0 )) .--> 1 ) );
set D3 = ( D2 +* ( (1 , 1) .--> ( 0 ) ) );
L1: ( dom D3 ) = ( ( dom D2 ) \/ ( dom ( (1 , 1) .--> ( 0 ) ) ) ) by FUNCT_4:def 1
.= ( ( dom D2 ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( ( dom D1 ) \/ ( dom ( (1 , ( 0 )) .--> 1 ) ) ) \/ { [ 1 , 1 ] } ) by FUNCT_4:def 1
.= ( ( ( dom D1 ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( ( ( dom ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ ( dom ( (( 0 ) , 1) .--> 1 ) ) ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCT_4:def 1
.= ( ( ( ( dom ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ { [ ( 0 ) , 1 ] } ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( ( { [ ( 0 ) , ( 0 ) ] } \/ { [ ( 0 ) , 1 ] } ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( { [ ( 0 ) , ( 0 ) ] , [ ( 0 ) , 1 ] } \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by ENUMSET1:1
.= ( { [ ( 0 ) , ( 0 ) ] , [ ( 0 ) , 1 ] , [ 1 , ( 0 ) ] } \/ { [ 1 , 1 ] } ) by ENUMSET1:3
.= { [ ( 0 ) , ( 0 ) ] , [ ( 0 ) , 1 ] , [ 1 , ( 0 ) ] , [ 1 , 1 ] } by ENUMSET1:6
.= [: 2 , 2 :] by CARD_1:50 , ZFMISC_1:122;
L2: 1 c= 2 by CARD_1:49 , CARD_1:50 , ZFMISC_1:7;
L3: ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) c= 1 by CARD_1:49 , FUNCOP_1:13;
L4: ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) c= 2 by L3 , L2 , XBOOLE_1:1;
L5: { 1 } c= 2 by CARD_1:50 , ZFMISC_1:7;
L6: ( rng ( (( 0 ) , 1) .--> 1 ) ) c= { 1 } by FUNCOP_1:13;
L7: ( rng ( (( 0 ) , 1) .--> 1 ) ) c= 2 by L6 , L5 , XBOOLE_1:1;
L8: ( ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ ( rng ( (( 0 ) , 1) .--> 1 ) ) ) c= 2 by L7 , L4 , XBOOLE_1:8;
L9: ( rng ( (1 , ( 0 )) .--> 1 ) ) c= { 1 } by FUNCOP_1:13;
L10: ( rng ( (1 , ( 0 )) .--> 1 ) ) c= 2 by L9 , L5 , XBOOLE_1:1;
L11: ( rng D1 ) c= ( ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ ( rng ( (( 0 ) , 1) .--> 1 ) ) ) by FUNCT_4:17;
L12: ( rng D1 ) c= 2 by L11 , L8 , XBOOLE_1:1;
L13: ( ( rng D1 ) \/ ( rng ( (1 , ( 0 )) .--> 1 ) ) ) c= 2 by L12 , L10 , XBOOLE_1:8;
L14: ( rng ( (1 , 1) .--> ( 0 ) ) ) c= 1 by CARD_1:49 , FUNCOP_1:13;
L15: ( rng ( (1 , 1) .--> ( 0 ) ) ) c= 2 by L14 , L2 , XBOOLE_1:1;
L16: ( rng D2 ) c= ( ( rng D1 ) \/ ( rng ( (1 , ( 0 )) .--> 1 ) ) ) by FUNCT_4:17;
L17: ( rng D2 ) c= 2 by L16 , L13 , XBOOLE_1:1;
L18: ( ( rng D2 ) \/ ( rng ( (1 , 1) .--> ( 0 ) ) ) ) c= 2 by L17 , L15 , XBOOLE_1:8;
L19: ( rng D3 ) c= ( ( rng D2 ) \/ ( rng ( (1 , 1) .--> ( 0 ) ) ) ) by FUNCT_4:17;
L20: ( rng D3 ) c= 2 by L19 , L18 , XBOOLE_1:1;
thus L21: thesis by L20 , L1 , FUNCT_2:def 1 , RELSET_1:4;
end;
func mult_2 -> (BinOp of 2) equals 
( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) ) +* ( (1 , ( 0 )) .--> ( 0 ) ) ) +* ( (1 , 1) .--> 1 ) );
coherence
proof
L22: ( rng ( (1 , 1) .--> 1 ) ) c= { 1 } by FUNCOP_1:13;
L23: { 1 } c= 2 by CARD_1:50 , ZFMISC_1:7;
L24: ( rng ( (1 , 1) .--> 1 ) ) c= 2 by L23 , L22 , XBOOLE_1:1;
set D4 = ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) );
set D5 = ( D4 +* ( (1 , ( 0 )) .--> ( 0 ) ) );
set D6 = ( D5 +* ( (1 , 1) .--> 1 ) );
L25: ( dom D6 ) = ( ( dom D5 ) \/ ( dom ( (1 , 1) .--> 1 ) ) ) by FUNCT_4:def 1
.= ( ( dom D5 ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( ( dom D4 ) \/ ( dom ( (1 , ( 0 )) .--> ( 0 ) ) ) ) \/ { [ 1 , 1 ] } ) by FUNCT_4:def 1
.= ( ( ( dom D4 ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( ( ( dom ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ ( dom ( (( 0 ) , 1) .--> ( 0 ) ) ) ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCT_4:def 1
.= ( ( ( ( dom ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ { [ ( 0 ) , 1 ] } ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( ( { [ ( 0 ) , ( 0 ) ] } \/ { [ ( 0 ) , 1 ] } ) \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by FUNCOP_1:13
.= ( ( { [ ( 0 ) , ( 0 ) ] , [ ( 0 ) , 1 ] } \/ { [ 1 , ( 0 ) ] } ) \/ { [ 1 , 1 ] } ) by ENUMSET1:1
.= ( { [ ( 0 ) , ( 0 ) ] , [ ( 0 ) , 1 ] , [ 1 , ( 0 ) ] } \/ { [ 1 , 1 ] } ) by ENUMSET1:3
.= { [ ( 0 ) , ( 0 ) ] , [ ( 0 ) , 1 ] , [ 1 , ( 0 ) ] , [ 1 , 1 ] } by ENUMSET1:6
.= [: 2 , 2 :] by CARD_1:50 , ZFMISC_1:122;
L26: 1 c= 2 by CARD_1:49 , CARD_1:50 , ZFMISC_1:7;
L27: ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) c= 1 by CARD_1:49 , FUNCOP_1:13;
L28: ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) c= 2 by L27 , L26 , XBOOLE_1:1;
L29: ( rng ( (( 0 ) , 1) .--> ( 0 ) ) ) c= 1 by CARD_1:49 , FUNCOP_1:13;
L30: ( rng ( (( 0 ) , 1) .--> ( 0 ) ) ) c= 2 by L29 , L26 , XBOOLE_1:1;
L31: ( ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ ( rng ( (( 0 ) , 1) .--> ( 0 ) ) ) ) c= 2 by L30 , L28 , XBOOLE_1:8;
L32: ( rng ( (1 , ( 0 )) .--> ( 0 ) ) ) c= 1 by CARD_1:49 , FUNCOP_1:13;
L33: ( rng ( (1 , ( 0 )) .--> ( 0 ) ) ) c= 2 by L32 , L26 , XBOOLE_1:1;
L34: ( rng D4 ) c= ( ( rng ( (( 0 ) , ( 0 )) .--> ( 0 ) ) ) \/ ( rng ( (( 0 ) , 1) .--> ( 0 ) ) ) ) by FUNCT_4:17;
L35: ( rng D4 ) c= 2 by L34 , L31 , XBOOLE_1:1;
L36: ( ( rng D4 ) \/ ( rng ( (1 , ( 0 )) .--> ( 0 ) ) ) ) c= 2 by L35 , L33 , XBOOLE_1:8;
L37: ( rng D5 ) c= ( ( rng D4 ) \/ ( rng ( (1 , ( 0 )) .--> ( 0 ) ) ) ) by FUNCT_4:17;
L38: ( rng D5 ) c= 2 by L37 , L36 , XBOOLE_1:1;
L39: ( ( rng D5 ) \/ ( rng ( (1 , 1) .--> 1 ) ) ) c= 2 by L38 , L24 , XBOOLE_1:8;
L40: ( rng D6 ) c= ( ( rng D5 ) \/ ( rng ( (1 , 1) .--> 1 ) ) ) by FUNCT_4:17;
L41: ( rng D6 ) c= 2 by L40 , L39 , XBOOLE_1:1;
thus L42: thesis by L41 , L25 , FUNCT_2:def 1 , RELSET_1:4;
end;
end;
set D7 = ( In (( 0 ) , 2) );
set D8 = ( In (1 , 2) );
L44: 1 in 2 by CARD_1:50 , TARSKI:def 2;
L45: ( 0 ) in 2 by CARD_1:50 , TARSKI:def 2;
L46: D7 = ( 0 ) by L45 , FUNCT_7:def 1;
L47: D8 = 1 by L44 , FUNCT_7:def 1;
set D9 = 2;
reconsider D10 = D9 as non  trivial set by L44 , L45 , ZFMISC_1:def 10;
reconsider D11 = D7 as (Element of D10);
L48: ( dom ( (1 , 1) .--> ( 0 ) ) ) = { [ 1 , 1 ] } by FUNCOP_1:13;
L49: ( dom ( (1 , ( 0 )) .--> 1 ) ) = { [ 1 , ( 0 ) ] } by FUNCOP_1:13;
L50: ( dom ( (( 0 ) , 1) .--> 1 ) ) = { [ ( 0 ) , 1 ] } by FUNCOP_1:13;
L51: ( ( add_2 ) . (D7 , D7) ) = D7
proof
L52: [ D7 , D7 ] <> [ ( 0 ) , 1 ] by L46 , XTUPLE_0:1;
L53: (not [ D7 , D7 ] in ( dom ( (( 0 ) , 1) .--> 1 ) )) by L52 , L50 , TARSKI:def 1;
L54: [ D7 , D7 ] <> [ 1 , ( 0 ) ] by L46 , XTUPLE_0:1;
L55: (not [ D7 , D7 ] in ( dom ( (1 , ( 0 )) .--> 1 ) )) by L54 , L49 , TARSKI:def 1;
L56: [ D7 , D7 ] <> [ 1 , 1 ] by L46 , XTUPLE_0:1;
L57: (not [ D7 , D7 ] in ( dom ( (1 , 1) .--> ( 0 ) ) )) by L56 , L48 , TARSKI:def 1;
thus L58: ( ( add_2 ) . (D7 , D7) ) = ( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) ) +* ( (1 , ( 0 )) .--> 1 ) ) . (D7 , D7) ) by L57 , FUNCT_4:11
.= ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) ) . (D7 , D7) ) by L55 , FUNCT_4:11
.= ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) . (D7 , D7) ) by L53 , FUNCT_4:11
.= D7 by L46 , FUNCOP_1:71;
end;
L59: ( ( add_2 ) . (D7 , D8) ) = D8
proof
L60: [ D7 , D8 ] <> [ 1 , ( 0 ) ] by L46 , XTUPLE_0:1;
L61: (not [ D7 , D8 ] in ( dom ( (1 , ( 0 )) .--> 1 ) )) by L60 , L49 , TARSKI:def 1;
L62: [ D7 , D8 ] in ( dom ( (( 0 ) , 1) .--> 1 ) ) by L46 , L47 , L50 , TARSKI:def 1;
L63: [ D7 , D8 ] <> [ 1 , 1 ] by L46 , XTUPLE_0:1;
L64: (not [ D7 , D8 ] in ( dom ( (1 , 1) .--> ( 0 ) ) )) by L63 , L48 , TARSKI:def 1;
thus L65: ( ( add_2 ) . (D7 , D8) ) = ( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) ) +* ( (1 , ( 0 )) .--> 1 ) ) . (D7 , D8) ) by L64 , FUNCT_4:11
.= ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) ) . (D7 , D8) ) by L61 , FUNCT_4:11
.= ( ( (( 0 ) , 1) .--> 1 ) . (D7 , D8) ) by L62 , FUNCT_4:13
.= D8 by L46 , L47 , FUNCOP_1:71;
end;
L66: ( ( add_2 ) . (D8 , D7) ) = D8
proof
L67: [ D8 , D7 ] in ( dom ( (1 , ( 0 )) .--> 1 ) ) by L46 , L47 , L49 , TARSKI:def 1;
L68: [ D8 , D7 ] <> [ 1 , 1 ] by L46 , XTUPLE_0:1;
L69: (not [ D8 , D7 ] in ( dom ( (1 , 1) .--> ( 0 ) ) )) by L68 , L48 , TARSKI:def 1;
thus L70: ( ( add_2 ) . (D8 , D7) ) = ( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> 1 ) ) +* ( (1 , ( 0 )) .--> 1 ) ) . (D8 , D7) ) by L69 , FUNCT_4:11
.= ( ( (1 , ( 0 )) .--> 1 ) . (D8 , D7) ) by L67 , FUNCT_4:13
.= D8 by L46 , L47 , FUNCOP_1:71;
end;
L71: ( ( add_2 ) . (D8 , D8) ) = D7
proof
L72: [ D8 , D8 ] in ( dom ( (1 , 1) .--> ( 0 ) ) ) by L47 , L48 , TARSKI:def 1;
thus L73: ( ( add_2 ) . (D8 , D8) ) = ( ( (1 , 1) .--> ( 0 ) ) . (D8 , D8) ) by L72 , FUNCT_4:13
.= D7 by L46 , L47 , FUNCOP_1:71;
end;
L74: ( dom ( (1 , 1) .--> 1 ) ) = { [ 1 , 1 ] } by FUNCOP_1:13;
L75: ( dom ( (1 , ( 0 )) .--> ( 0 ) ) ) = { [ 1 , ( 0 ) ] } by FUNCOP_1:13;
L76: ( dom ( (( 0 ) , 1) .--> ( 0 ) ) ) = { [ ( 0 ) , 1 ] } by FUNCOP_1:13;
L77: ( ( mult_2 ) . (D7 , D7) ) = D7
proof
L78: [ D7 , D7 ] <> [ ( 0 ) , 1 ] by L46 , XTUPLE_0:1;
L79: (not [ D7 , D7 ] in ( dom ( (( 0 ) , 1) .--> ( 0 ) ) )) by L78 , L76 , TARSKI:def 1;
L80: [ D7 , D7 ] <> [ 1 , ( 0 ) ] by L46 , XTUPLE_0:1;
L81: (not [ D7 , D7 ] in ( dom ( (1 , ( 0 )) .--> ( 0 ) ) )) by L80 , L75 , TARSKI:def 1;
L82: [ D7 , D7 ] <> [ 1 , 1 ] by L46 , XTUPLE_0:1;
L83: (not [ D7 , D7 ] in ( dom ( (1 , 1) .--> 1 ) )) by L82 , L74 , TARSKI:def 1;
thus L84: ( ( mult_2 ) . (D7 , D7) ) = ( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) ) +* ( (1 , ( 0 )) .--> ( 0 ) ) ) . (D7 , D7) ) by L83 , FUNCT_4:11
.= ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) ) . (D7 , D7) ) by L81 , FUNCT_4:11
.= ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) . (D7 , D7) ) by L79 , FUNCT_4:11
.= D7 by L46 , FUNCOP_1:71;
end;
L85: ( ( mult_2 ) . (D7 , D8) ) = D7
proof
L86: [ D7 , D8 ] <> [ 1 , ( 0 ) ] by L46 , XTUPLE_0:1;
L87: (not [ D7 , D8 ] in ( dom ( (1 , ( 0 )) .--> ( 0 ) ) )) by L86 , L75 , TARSKI:def 1;
L88: [ D7 , D8 ] in ( dom ( (( 0 ) , 1) .--> ( 0 ) ) ) by L46 , L47 , L76 , TARSKI:def 1;
L89: [ D7 , D8 ] <> [ 1 , 1 ] by L46 , XTUPLE_0:1;
L90: (not [ D7 , D8 ] in ( dom ( (1 , 1) .--> 1 ) )) by L89 , L74 , TARSKI:def 1;
thus L91: ( ( mult_2 ) . (D7 , D8) ) = ( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) ) +* ( (1 , ( 0 )) .--> ( 0 ) ) ) . (D7 , D8) ) by L90 , FUNCT_4:11
.= ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) ) . (D7 , D8) ) by L87 , FUNCT_4:11
.= ( ( (( 0 ) , 1) .--> ( 0 ) ) . (D7 , D8) ) by L88 , FUNCT_4:13
.= D7 by L46 , L47 , FUNCOP_1:71;
end;
L92: ( ( mult_2 ) . (D8 , D7) ) = D7
proof
L93: [ D8 , D7 ] in ( dom ( (1 , ( 0 )) .--> ( 0 ) ) ) by L46 , L47 , L75 , TARSKI:def 1;
L94: [ D8 , D7 ] <> [ 1 , 1 ] by L46 , XTUPLE_0:1;
L95: (not [ D8 , D7 ] in ( dom ( (1 , 1) .--> 1 ) )) by L94 , L74 , TARSKI:def 1;
thus L96: ( ( mult_2 ) . (D8 , D7) ) = ( ( ( ( (( 0 ) , ( 0 )) .--> ( 0 ) ) +* ( (( 0 ) , 1) .--> ( 0 ) ) ) +* ( (1 , ( 0 )) .--> ( 0 ) ) ) . (D8 , D7) ) by L95 , FUNCT_4:11
.= ( ( (1 , ( 0 )) .--> ( 0 ) ) . (D8 , D7) ) by L93 , FUNCT_4:13
.= D7 by L46 , L47 , FUNCOP_1:71;
end;
L97: ( ( mult_2 ) . (D8 , D8) ) = D8
proof
L98: [ D8 , D8 ] in ( dom ( (1 , 1) .--> 1 ) ) by L47 , L74 , TARSKI:def 1;
thus L99: ( ( mult_2 ) . (D8 , D8) ) = ( ( (1 , 1) .--> 1 ) . (D8 , D8) ) by L98 , FUNCT_4:13
.= D8 by L47 , FUNCOP_1:71;
end;
set D12 = ( mult_2 );
L100: ( D10 \ { D7 } ) = { D8 } by L46 , L47 , CARD_1:50 , ZFMISC_1:17;
L101: [: ( D10 \ { D7 } ) , ( D10 \ { D7 } ) :] = { [ D8 , D8 ] } by L100 , ZFMISC_1:29;
L102: (for B1 being set holds (B1 in [: ( D10 \ { D7 } ) , ( D10 \ { D7 } ) :] implies ( D12 . B1 ) in ( D10 \ { D7 } )))
proof
let C1 being set;
assume L103: C1 in [: ( D10 \ { D7 } ) , ( D10 \ { D7 } ) :];
L104: C1 = [ D8 , D8 ] by L103 , L101 , TARSKI:def 1;
thus L105: thesis by L104 , L97 , L100 , TARSKI:def 1;
end;
reconsider D13 = D8 as (Element of ( D10 \ { D11 } )) by L100 , TARSKI:def 1;
reconsider D14 = ( add_2 ) as (BinOp of D10);
reconsider D15 = D12 as (BinOp of D10);
L106: (for B2 , B3 , B4 being (Element of D10) holds ( ( add_2 ) . (( ( add_2 ) . (B2 , B3) ) , B4) ) = ( ( add_2 ) . (B2 , ( ( add_2 ) . (B3 , B4) )) ))
proof
let C2 , C3 , C4 being (Element of D10);
L107: (C2 = D7 or C2 = D8) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
L108: (C3 = D7 or C3 = D8) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
L109: (C4 = D7 or C4 = D8) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
per cases  by L46 , L47 , CARD_1:50 , TARSKI:def 2;
suppose L110: C2 = D7;

thus L111: thesis by L110 , L108 , L109 , L51 , L59 , L66 , L71;
end;
suppose L112: C3 = D7;

thus L113: thesis by L112 , L107 , L109 , L51 , L59 , L66;
end;
suppose L114: C4 = D7;

thus L115: thesis by L114 , L107 , L108 , L51 , L59 , L66 , L71;
end;
suppose L116: (C2 = D8 & C3 = D8 & C4 = D8);

thus L117: thesis by L116 , L59 , L66 , L71;
end;
end;
reconsider D16 = doubleLoopStr (# D10 , D14 , D15 , D13 , D11 #) as non  empty doubleLoopStr;
L119: (for B5 being (Element of D16) holds ( B5 + ( 0. D16 ) ) = B5)
proof
let C5 being (Element of D16);
L120: (C5 = D7 or C5 = D8) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
thus L121: thesis by L120 , L51 , L66;
end;
L122: (for B6 , B7 , B8 being (Element of D16) holds ( ( B6 + B7 ) + B8 ) = ( B6 + ( B7 + B8 ) )) by L106;
L123: (for B9 , B10 being (Element of D16) holds ( B9 + B10 ) = ( B10 + B9 ))
proof
let C6 , C7 being (Element of D16);
L124: ((C6 = D7 & C7 = D7) or (C6 = D7 & C7 = D8) or (C6 = D8 & C7 = D7) or (C6 = D8 & C7 = D8)) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
thus L125: thesis by L124 , L59 , L66;
end;
reconsider D17 = D12 as (DnT of D11 , D10) by L102 , REALSET1:def 6;
L126: (for B11 being non  empty set holds (for B12 being (BinOp of B11) holds (for B13 being (Element of B11) holds ((B11 = ( D10 \ { D11 } ) & B13 = D13) implies addLoopStr (# B11 , B12 , B13 #) is AbGroup))))
proof
let C8 being non  empty set;
let C9 being (BinOp of C8);
let C10 being (Element of C8);
assume that
L127: C8 = ( D10 \ { D11 } )
and
L128: C10 = D13;
L129: addLoopStr (# C8 , C9 , C10 #) is  right_complementable
proof
let C11 being (Element of addLoopStr (# C8 , C9 , C10 #));
take C11;
thus L130: thesis by L127 , L128 , L100 , TARSKI:def 1;
end;
L131: (for B14 , B15 , B16 being (Element of C8) holds ( C9 . (( C9 . (B14 , B15) ) , B16) ) = ( C9 . (B14 , ( C9 . (B15 , B16) )) ))
proof
let C12 , C13 , C14 being (Element of C8);
L132: C13 = D8 by L127 , L100 , TARSKI:def 1;
L133: C14 = D8 by L127 , L100 , TARSKI:def 1;
L134: C12 = D8 by L127 , L100 , TARSKI:def 1;
thus L135: thesis by L134 , L127 , L132 , L133 , L100 , TARSKI:def 1;
end;
L136: (for B17 , B18 , B19 being (Element of addLoopStr (# C8 , C9 , C10 #)) holds ( ( B17 + B18 ) + B19 ) = ( B17 + ( B18 + B19 ) )) by L131;
L137: (for B20 , B21 being (Element of addLoopStr (# C8 , C9 , C10 #)) holds ( B20 + B21 ) = ( B21 + B20 ))
proof
let C15 , C16 being (Element of addLoopStr (# C8 , C9 , C10 #));
L138: C15 = D8 by L127 , L100 , TARSKI:def 1;
thus L139: thesis by L138 , L127 , L100 , TARSKI:def 1;
end;
L140: (for B22 being (Element of addLoopStr (# C8 , C9 , C10 #)) holds ( B22 + ( 0. addLoopStr (# C8 , C9 , C10 #) ) ) = B22)
proof
let C17 being (Element of addLoopStr (# C8 , C9 , C10 #));
L141: C17 = D8 by L127 , L100 , TARSKI:def 1;
thus L142: thesis by L141 , L127 , L100 , TARSKI:def 1;
end;
thus L143: thesis by L140 , L129 , L136 , L137 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4;
end;
L144: (for B23 , B24 , B25 being (Element of D16) holds (( B23 * ( B24 + B25 ) ) = ( ( B23 * B24 ) + ( B23 * B25 ) ) & ( ( B24 + B25 ) * B23 ) = ( ( B24 * B23 ) + ( B25 * B23 ) )))
proof
let C18 , C19 , C20 being (Element of D16);
L145: ((C18 = D7 & C19 = D7 & C20 = D7) or (C18 = D7 & C19 = D7 & C20 = D8) or (C18 = D7 & C19 = D8 & C20 = D7) or (C18 = D7 & C19 = D8 & C20 = D8) or (C18 = D8 & C19 = D7 & C20 = D7) or (C18 = D8 & C19 = D7 & C20 = D8) or (C18 = D8 & C19 = D8 & C20 = D7) or (C18 = D8 & C19 = D8 & C20 = D8)) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
thus L146: ( C18 * ( C19 + C20 ) ) = ( ( C18 * C19 ) + ( C18 * C20 ) ) by L145 , L51 , L59 , L66 , L71 , L77 , L85 , L92 , L97;
thus L147: thesis by L145 , L51 , L59 , L66 , L71 , L77 , L85 , L92 , L97;
end;
definition
func dL-Z_2 -> doubleLoopStr equals 
doubleLoopStr (# 2 , ( add_2 ) , ( mult_2 ) , ( In (1 , 2) ) , ( In (( 0 ) , 2) ) #);
coherence;
end;
registration
cluster ( dL-Z_2 ) ->  strict non  empty non  degenerated;
coherence
proof
thus L149: ( dL-Z_2 ) is  strict;
thus L150: (the carrier of ( dL-Z_2 )) is non  empty;
L151: ( 0 ) in 2 by CARD_1:50 , TARSKI:def 2;
L152: ( 0. ( dL-Z_2 ) ) = ( 0 ) by L151 , FUNCT_7:def 1;
L153: 1 in 2 by CARD_1:50 , TARSKI:def 2;
thus L154: ( 0. ( dL-Z_2 ) ) <> ( 1. ( dL-Z_2 ) ) by L153 , L152 , FUNCT_7:def 1;
end;
end;
registration
cluster ( dL-Z_2 ) ->  add-associative  distributive;
coherence
proof
L156: (for B26 , B27 , B28 being (Element of ( dL-Z_2 )) holds ( ( B26 + B27 ) + B28 ) = ( B26 + ( B27 + B28 ) )) by L106;
thus L157: ( dL-Z_2 ) is  add-associative by L156 , RLVECT_1:def 3;
thus L158: ( dL-Z_2 ) is  distributive
proof
let C21 , C22 , C23 being (Element of ( dL-Z_2 ));
L159: ((C21 = D7 & C22 = D7 & C23 = D7) or (C21 = D7 & C22 = D7 & C23 = D8) or (C21 = D7 & C22 = D8 & C23 = D7) or (C21 = D7 & C22 = D8 & C23 = D8) or (C21 = D8 & C22 = D7 & C23 = D7) or (C21 = D8 & C22 = D7 & C23 = D8) or (C21 = D8 & C22 = D8 & C23 = D7) or (C21 = D8 & C22 = D8 & C23 = D8)) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
thus L160: ( C21 * ( C22 + C23 ) ) = ( ( C21 * C22 ) + ( C21 * C23 ) ) by L159 , L51 , L59 , L66 , L71 , L77 , L85 , L92 , L97;
thus L161: thesis by L159 , L51 , L59 , L66 , L71 , L77 , L85 , L92 , L97;
end;

end;
end;
registration
cluster  add-associative for non  trivial  strict non  trivial  strict non  trivial  strict non  trivial  strict doubleLoopStr;
existence
proof
take ( dL-Z_2 );
thus L160: thesis;
end;
end;
registration
cluster (the carrier of ( dL-Z_2 )) ->  natural-membered;
coherence
proof
let C24 being set;
thus L162: thesis by CARD_1:50 , TARSKI:def 2;
end;
end;
registration
cluster  empty for (Element of ( dL-Z_2 ));
existence
proof
reconsider D18 = ( 0 ) as (Element of ( dL-Z_2 )) by CARD_1:50 , TARSKI:def 2;
take D18;
thus L164: thesis;
end;
cluster non  empty for (Element of ( dL-Z_2 ));
existence
proof
reconsider D19 = 1 as (Element of ( dL-Z_2 )) by CARD_1:50 , TARSKI:def 2;
take D19;
thus L165: thesis;
end;
end;
definition
let C25 being doubleLoopStr;
attr C25 is  Field-like
means
:L167: ((the multF of C25) is (DnT of ( 0. C25 ) , (the carrier of C25)) & (for B29 being non  empty set holds (for B30 being (BinOp of B29) holds (for B31 being (Element of B29) holds ((B29 = ( NonZero C25 ) & B31 = ( 1. C25 ) & B30 = ( (the multF of C25) || ( NonZero C25 ) )) implies addLoopStr (# B29 , B30 , B31 #) is AbGroup)))));
end;
registration
let C26 being non  empty set;
let C27 being (BinOp of C26);
let C28 being (Element of C26);
let C29 being (BinOp of C26);
let C30 being (Element of C26);
cluster doubleLoopStr (# C26 , C27 , C29 , C30 , C28 #) -> non  empty;
coherence;
end;
L170: (for B32 being non  empty set holds (for B33 being (BinOp of B32) holds (for B34 being (Element of B32) holds ((B32 = ( D10 \ { D11 } ) & B34 = D13 & B33 = ( D17 ! (D10 , D11) )) implies addLoopStr (# B32 , B33 , B34 #) is AbGroup)))) by L126;
registration
cluster  strict  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable for non  degenerated non  degenerated non  degenerated non  degenerated doubleLoopStr;
existence
proof
set D20 = doubleLoopStr (# D10 , D14 , D15 , D13 , D11 #);
L171: ( 0. D20 ) = D11;
L172: ( 1. D20 ) = D13;
reconsider D21 = D20 as non  degenerated doubleLoopStr by L172 , L171 , L46 , L47 , STRUCT_0:def 8;
take D21;
thus L173: D21 is  strict;
thus L174: (the multF of D21) is (DnT of ( 0. D21 ) , (the carrier of D21)) by L170;
L175: D21 is  right_complementable
proof
let C31 being (Element of D21);
take C31;
L176: (C31 = D7 or C31 = D8) by L46 , L47 , CARD_1:50 , TARSKI:def 2;
thus L177: thesis by L176 , L51 , L71;
end;
thus L178: thesis by L175 , L119 , L122 , L123 , L126 , L144 , RLVECT_1:def 2 , RLVECT_1:def 3 , RLVECT_1:def 4 , VECTSP_1:def 7;
end;
end;
registration
cluster  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive  almost_left_invertible ->  Field-like for non  degenerated non  degenerated non  degenerated non  degenerated doubleLoopStr;
coherence
proof
let C32 being non  degenerated doubleLoopStr;
set D22 = ( NonZero C32 );
assume L180: C32 is  add-associative  right_zeroed  right_complementable  Abelian  commutative  associative  well-unital  distributive  almost_left_invertible;
L181: (for B35 being set holds (B35 in [: D22 , D22 :] implies ( (the multF of C32) . B35 ) in D22))
proof
let C33 being set;
assume L182: C33 in [: D22 , D22 :];
consider R1 being set, R2 being set such that L183: R1 in D22 and L184: R2 in D22 and L185: C33 = [ R1 , R2 ] by L182 , ZFMISC_1:84;
reconsider D23 = R1 , D24 = R2 as (Element of C32) by L183 , L184;
L186: (not D24 in { ( 0. C32 ) }) by L184 , XBOOLE_0:def 5;
L187: D24 <> ( 0. C32 ) by L186 , TARSKI:def 1;
L188: (not D23 in { ( 0. C32 ) }) by L183 , XBOOLE_0:def 5;
L189: D23 <> ( 0. C32 ) by L188 , TARSKI:def 1;
L190: ( D23 * D24 ) <> ( 0. C32 ) by L189 , L180 , L187 , VECTSP_1:12;
L191: (not ( D23 * D24 ) in { ( 0. C32 ) }) by L190 , TARSKI:def 1;
thus L192: thesis by L191 , L185 , XBOOLE_0:def 5;
end;
thus L193: (the multF of C32) is (DnT of ( 0. C32 ) , (the carrier of C32)) by L181 , REALSET1:def 6;
reconsider D25 = (the multF of C32) as (DnT of ( 0. C32 ) , (the carrier of C32)) by L181 , REALSET1:def 6;
let C34 being non  empty set;
let C35 being (BinOp of C34);
let C36 being (Element of C34);
assume that
L194: C34 = ( NonZero C32 )
and
L195: C36 = ( 1. C32 )
and
L196: C35 = ( (the multF of C32) || ( NonZero C32 ) );
set D26 = addLoopStr (# C34 , C35 , C36 #);
L197: D26 is  Abelian
proof
let C37 , C38 being (Element of D26);
reconsider D27 = C37 , D28 = C38 as (Element of C32) by L194 , XBOOLE_0:def 5;
L198: [ C38 , C37 ] in [: C34 , C34 :];
L199: [ C37 , C38 ] in [: C34 , C34 :];
thus L200: ( C37 + C38 ) = ( D27 * D28 ) by L199 , L194 , L196 , FUNCT_1:49
.= ( D28 * D27 ) by L180 , GROUP_1:def 12
.= ( C38 + C37 ) by L194 , L196 , L198 , FUNCT_1:49;
end;
L201: D26 is  right_complementable
proof
let C39 being (Element of D26);
reconsider D29 = C39 as (Element of C32) by L194 , XBOOLE_0:def 5;
L202: (not D29 in { ( 0. C32 ) }) by L194 , XBOOLE_0:def 5;
L203: D29 <> ( 0. C32 ) by L202 , TARSKI:def 1;
consider C40 being (Element of C32) such that L204: ( C40 * D29 ) = ( 1. C32 ) by L203 , L180 , VECTSP_1:def 9;
L205: ( D29 * C40 ) = ( 1. C32 ) by L180 , L204 , GROUP_1:def 12;
L206: C40 <> ( 0. C32 ) by L205 , L180 , VECTSP_1:6;
L207: (not C40 in { ( 0. C32 ) }) by L206 , TARSKI:def 1;
reconsider D30 = C40 as (Element of D26) by L207 , L194 , XBOOLE_0:def 5;
take D30;
L208: [ C39 , D30 ] in [: C34 , C34 :];
thus L209: thesis by L208 , L194 , L195 , L196 , L205 , FUNCT_1:49;
end;
L210: D26 is  add-associative
proof
let C41 , C42 , C43 being (Element of D26);
reconsider D31 = C41 , D32 = C42 , D33 = C43 as (Element of C32) by L194 , XBOOLE_0:def 5;
L211: [ C42 , C43 ] in [: C34 , C34 :];
L212: ( C35 . (C42 , C43) ) in C34 by L211 , FUNCT_2:5;
L213: [ C41 , ( ( D25 || C34 ) . (C42 , C43) ) ] in [: C34 , C34 :] by L212 , L194 , L196 , ZFMISC_1:87;
L214: [ C41 , C42 ] in [: C34 , C34 :];
L215: ( C35 . (C41 , C42) ) in C34 by L214 , FUNCT_2:5;
L216: [ ( ( D25 || C34 ) . (C41 , C42) ) , C43 ] in [: C34 , C34 :] by L215 , L194 , L196 , ZFMISC_1:87;
thus L217: ( ( C41 + C42 ) + C43 ) = ( D25 . (( ( D25 || C34 ) . (C41 , C42) ) , C43) ) by L216 , L194 , L196 , FUNCT_1:49
.= ( ( D31 * D32 ) * D33 ) by L214 , FUNCT_1:49
.= ( D31 * ( D32 * D33 ) ) by L180 , GROUP_1:def 3
.= ( D25 . (C41 , ( ( D25 || C34 ) . (C42 , C43) )) ) by L211 , FUNCT_1:49
.= ( C41 + ( C42 + C43 ) ) by L194 , L196 , L213 , FUNCT_1:49;
end;
L218: D26 is  right_zeroed
proof
let C44 being (Element of D26);
reconsider D34 = C44 as (Element of C32) by L194 , XBOOLE_0:def 5;
L219: [ C44 , ( 0. D26 ) ] in [: C34 , C34 :];
thus L220: ( C44 + ( 0. D26 ) ) = ( D34 * ( 1. C32 ) ) by L219 , L194 , L195 , L196 , FUNCT_1:49
.= C44 by L180 , VECTSP_1:def 6;
end;
thus L221: thesis by L218 , L197 , L210 , L201;
end;
end;
deffunc H1( Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr) = (the carrier of $1);
definition
let C45 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
func omf C45 -> (DnT of ( 0. C45 ) , (the carrier of C45)) equals 
(the multF of C45);
coherence by L167;
end;
theorem
L224: (for B36 being Field holds ( the addLoopStr of B36 ) is AbGroup)
proof
let C46 being Field;
set D35 = ( the addLoopStr of C46 );
L225: D35 is  add-associative
proof
let C47 , C48 , C49 being (Element of D35);
reconsider D36 = C47 , D37 = C48 , D38 = C49 as (Element of C46);
thus L226: ( ( C47 + C48 ) + C49 ) = ( ( D36 + D37 ) + D38 )
.= ( D36 + ( D37 + D38 ) ) by RLVECT_1:def 3
.= ( C47 + ( C48 + C49 ) );
end;
L227: D35 is  right_zeroed
proof
let C50 being (Element of D35);
reconsider D39 = C50 as (Element of C46);
thus L228: ( C50 + ( 0. D35 ) ) = ( D39 + ( 0. C46 ) )
.= C50 by RLVECT_1:def 4;
end;
L229: D35 is  right_complementable
proof
let C51 being (Element of D35);
reconsider D40 = C51 as (Element of C46);
consider C52 being (Element of C46) such that L230: ( D40 + C52 ) = ( 0. C46 ) by ALGSTR_0:def 11;
reconsider D41 = C52 as (Element of D35);
take D41;
thus L231: thesis by L230;
end;
L232: D35 is  Abelian
proof
let C53 , C54 being (Element of D35);
reconsider D42 = C53 , D43 = C54 as (Element of C46);
thus L233: ( C53 + C54 ) = ( D42 + D43 )
.= ( D43 + D42 )
.= ( C54 + C53 );
end;
thus L234: thesis by L232 , L225 , L227 , L229;
end;
theorem
L235: (for B37 being Field holds (for B38 being (Element of B37) holds (( B38 + ( 0. B37 ) ) = B38 & ( ( 0. B37 ) + B38 ) = B38))) by RLVECT_1:def 13;
theorem
L236: (for B39 being AbGroup holds (for B40 being (Element of B39) holds (ex B41 being (Element of B39) st (( B40 + B41 ) = ( 0. B39 ) & ( B41 + B40 ) = ( 0. B39 )))))
proof
let C55 being AbGroup;
let C56 being (Element of C55);
consider C57 being (Element of C55) such that L237: ( C56 + C57 ) = ( 0. C55 ) by ALGSTR_0:def 11;
take C57;
thus L238: ( C56 + C57 ) = ( 0. C55 ) by L237;
thus L239: thesis by L237;
end;
theorem
L240: (for B42 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B43 , B44 , B45 being (Element of ( NonZero B42 )) holds ( ( B43 * B44 ) * B45 ) = ( B43 * ( B44 * B45 ) )))
proof
let C58 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C59 , C60 , C61 being (Element of ( NonZero C58 ));
set D44 = ( H1(C58) \ { ( 0. C58 ) } );
set D45 = ( ( omf C58 ) ! (H1(C58) , ( 0. C58 )) );
L241: D44 = ( NonZero C58 );
reconsider D46 = ( 1. C58 ) as (Element of D44) by L241 , STRUCT_0:2;
reconsider D47 = addLoopStr (# D44 , D45 , D46 #) as  strict AbGroup by L241 , L167;
reconsider D48 = C59 , D49 = C60 , D50 = C61 as (Element of D47);
reconsider D51 = D48 , D52 = D49 , D53 = D50 as (Element of C58);
L242: ( ( omf C58 ) || ( H1(C58) \ { ( 0. C58 ) } ) ) is (Function of [: ( H1(C58) \ { ( 0. C58 ) } ) , ( H1(C58) \ { ( 0. C58 ) } ) :] , ( H1(C58) \ { ( 0. C58 ) } )) by REALSET1:7;
L243: ( dom ( ( omf C58 ) || ( H1(C58) \ { ( 0. C58 ) } ) ) ) = [: ( H1(C58) \ { ( 0. C58 ) } ) , ( H1(C58) \ { ( 0. C58 ) } ) :] by L242 , FUNCT_2:def 1;
L244: (for B46 , B47 being (Element of ( H1(C58) \ { ( 0. C58 ) } )) holds ( ( omf C58 ) . (B46 , B47) ) = ( (the addF of D47) . (B46 , B47) ))
proof
let C62 , C63 being (Element of ( H1(C58) \ { ( 0. C58 ) } ));
L245: [ C62 , C63 ] in [: ( H1(C58) \ { ( 0. C58 ) } ) , ( H1(C58) \ { ( 0. C58 ) } ) :];
thus L246: thesis by L245 , L243 , FUNCT_1:47;
end;
L247: (for B48 , B49 being (Element of ( H1(C58) \ { ( 0. C58 ) } )) holds (( (the addF of D47) . (B48 , B49) ) is (Element of ( H1(C58) \ { ( 0. C58 ) } )) & ( ( omf C58 ) . (B48 , B49) ) is (Element of ( H1(C58) \ { ( 0. C58 ) } ))))
proof
let C64 , C65 being (Element of ( H1(C58) \ { ( 0. C58 ) } ));
L248: [ C64 , C65 ] in [: ( H1(C58) \ { ( 0. C58 ) } ) , ( H1(C58) \ { ( 0. C58 ) } ) :];
consider C66 being (Function of [: ( H1(C58) \ { ( 0. C58 ) } ) , ( H1(C58) \ { ( 0. C58 ) } ) :] , ( H1(C58) \ { ( 0. C58 ) } )) such that L249: C66 = ( ( omf C58 ) || ( H1(C58) \ { ( 0. C58 ) } ) ) by L242;
L250: ( C66 . (C64 , C65) ) is (Element of ( H1(C58) \ { ( 0. C58 ) } ));
thus L251: thesis by L250 , L243 , L248 , L249 , FUNCT_1:47;
end;
L252: (for B50 , B51 , B52 being (Element of ( H1(C58) \ { ( 0. C58 ) } )) holds (( ( omf C58 ) . (( (the addF of D47) . (B50 , B51) ) , B52) ) = ( (the addF of D47) . (( (the addF of D47) . (B50 , B51) ) , B52) ) & ( (the addF of D47) . (B50 , ( ( omf C58 ) . (B51 , B52) )) ) = ( ( omf C58 ) . (B50 , ( ( omf C58 ) . (B51 , B52) )) )))
proof
let C67 , C68 , C69 being (Element of ( H1(C58) \ { ( 0. C58 ) } ));
L253: ( ( omf C58 ) . (C68 , C69) ) is (Element of ( H1(C58) \ { ( 0. C58 ) } )) by L247;
L254: ( (the addF of D47) . (C67 , C68) ) is (Element of ( H1(C58) \ { ( 0. C58 ) } )) by L247;
thus L255: thesis by L254 , L244 , L253;
end;
L256: ( ( D51 * D52 ) * D53 ) = ( ( omf C58 ) . (( (the addF of D47) . (D48 , D49) ) , D50) ) by L244
.= ( ( D48 + D49 ) + D50 ) by L252
.= ( D48 + ( D49 + D50 ) ) by RLVECT_1:def 3
.= ( (the addF of D47) . (D48 , ( ( omf C58 ) . (D49 , D50) )) ) by L244
.= ( D51 * ( D52 * D53 ) ) by L252;
thus L257: thesis by L256;
end;
theorem
L258: (for B53 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B54 , B55 being (Element of ( NonZero B53 )) holds ( B54 * B55 ) = ( B55 * B54 )))
proof
let C70 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C71 , C72 being (Element of ( NonZero C70 ));
set D54 = ( H1(C70) \ { ( 0. C70 ) } );
set D55 = ( ( omf C70 ) ! (H1(C70) , ( 0. C70 )) );
L259: D54 = ( NonZero C70 );
reconsider D56 = ( 1. C70 ) as (Element of D54) by L259 , STRUCT_0:2;
reconsider D57 = addLoopStr (# D54 , D55 , D56 #) as  strict AbGroup by L259 , L167;
reconsider D58 = C71 , D59 = C72 as (Element of D57);
reconsider D60 = D58 , D61 = D59 as (Element of C70);
L260: ( ( omf C70 ) || ( H1(C70) \ { ( 0. C70 ) } ) ) is (Function of [: ( H1(C70) \ { ( 0. C70 ) } ) , ( H1(C70) \ { ( 0. C70 ) } ) :] , ( H1(C70) \ { ( 0. C70 ) } )) by REALSET1:7;
L261: ( dom ( ( omf C70 ) || ( H1(C70) \ { ( 0. C70 ) } ) ) ) = [: ( H1(C70) \ { ( 0. C70 ) } ) , ( H1(C70) \ { ( 0. C70 ) } ) :] by L260 , FUNCT_2:def 1;
L262: (for B56 , B57 being (Element of ( H1(C70) \ { ( 0. C70 ) } )) holds ( ( omf C70 ) . (B56 , B57) ) = ( (the addF of D57) . (B56 , B57) ))
proof
let C73 , C74 being (Element of ( H1(C70) \ { ( 0. C70 ) } ));
L263: [ C73 , C74 ] in [: ( H1(C70) \ { ( 0. C70 ) } ) , ( H1(C70) \ { ( 0. C70 ) } ) :];
thus L264: thesis by L263 , L261 , FUNCT_1:47;
end;
L265: ( D60 * D61 ) = ( D58 + D59 ) by L262
.= ( D59 + D58 )
.= ( D61 * D60 ) by L262;
thus L266: thesis by L265;
end;
theorem
L267: (for B58 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B59 being (Element of ( NonZero B58 )) holds (( B59 * ( 1. B58 ) ) = B59 & ( ( 1. B58 ) * B59 ) = B59)))
proof
let C75 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C76 being (Element of ( NonZero C75 ));
set D62 = ( H1(C75) \ { ( 0. C75 ) } );
set D63 = ( ( omf C75 ) ! (H1(C75) , ( 0. C75 )) );
L268: D62 = ( NonZero C75 );
reconsider D64 = ( 1. C75 ) as (Element of D62) by L268 , STRUCT_0:2;
reconsider D65 = addLoopStr (# D62 , D63 , D64 #) as  strict AbGroup by L268 , L167;
reconsider D66 = C76 as (Element of D65);
L269: ( ( omf C75 ) || ( H1(C75) \ { ( 0. C75 ) } ) ) is (Function of [: ( H1(C75) \ { ( 0. C75 ) } ) , ( H1(C75) \ { ( 0. C75 ) } ) :] , ( H1(C75) \ { ( 0. C75 ) } )) by REALSET1:7;
L270: ( dom ( ( omf C75 ) || ( H1(C75) \ { ( 0. C75 ) } ) ) ) = [: ( H1(C75) \ { ( 0. C75 ) } ) , ( H1(C75) \ { ( 0. C75 ) } ) :] by L269 , FUNCT_2:def 1;
L271: (for B60 , B61 being (Element of ( H1(C75) \ { ( 0. C75 ) } )) holds ( ( omf C75 ) . (B60 , B61) ) = ( (the addF of D65) . (B60 , B61) ))
proof
let C77 , C78 being (Element of ( H1(C75) \ { ( 0. C75 ) } ));
L272: [ C77 , C78 ] in [: ( H1(C75) \ { ( 0. C75 ) } ) , ( H1(C75) \ { ( 0. C75 ) } ) :];
thus L273: thesis by L272 , L270 , FUNCT_1:47;
end;
L274: ( ( omf C75 ) . (( 1. C75 ) , D66) ) = ( ( 0. D65 ) + D66 ) by L271
.= D66 by RLVECT_1:def 13;
L275: ( ( omf C75 ) . (D66 , ( 1. C75 )) ) = ( D66 + ( 0. D65 ) ) by L271
.= D66 by RLVECT_1:def 4;
thus L276: thesis by L275 , L274;
end;
theorem
L277: (for B62 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B63 being (Element of ( NonZero B62 )) holds (ex B64 being (Element of ( NonZero B62 )) st (( B63 * B64 ) = ( 1. B62 ) & ( B64 * B63 ) = ( 1. B62 )))))
proof
let C79 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C80 being (Element of ( NonZero C79 ));
set D67 = ( H1(C79) \ { ( 0. C79 ) } );
set D68 = ( ( omf C79 ) ! (H1(C79) , ( 0. C79 )) );
L278: D67 = ( NonZero C79 );
reconsider D69 = ( 1. C79 ) as (Element of D67) by L278 , STRUCT_0:2;
L279: addLoopStr (# D67 , D68 , D69 #) is AbGroup by L278 , L167;
consider C81 being  strict AbGroup such that L280: C81 = addLoopStr (# D67 , D68 , D69 #) by L279;
reconsider D70 = C80 as (Element of C81) by L280;
consider C82 being (Element of C81) such that L281: ( D70 + C82 ) = ( 0. C81 ) and L282: ( C82 + D70 ) = ( 0. C81 ) by L236;
reconsider D71 = C82 as (Element of ( NonZero C79 )) by L280;
take D71;
L283: ( ( omf C79 ) || ( H1(C79) \ { ( 0. C79 ) } ) ) is (Function of [: ( H1(C79) \ { ( 0. C79 ) } ) , ( H1(C79) \ { ( 0. C79 ) } ) :] , ( H1(C79) \ { ( 0. C79 ) } )) by REALSET1:7;
L284: ( dom ( ( omf C79 ) || ( H1(C79) \ { ( 0. C79 ) } ) ) ) = [: ( H1(C79) \ { ( 0. C79 ) } ) , ( H1(C79) \ { ( 0. C79 ) } ) :] by L283 , FUNCT_2:def 1;
L285: (for B65 , B66 being (Element of ( H1(C79) \ { ( 0. C79 ) } )) holds ( ( omf C79 ) . (B65 , B66) ) = ( (the addF of C81) . (B65 , B66) ))
proof
let C83 , C84 being (Element of ( H1(C79) \ { ( 0. C79 ) } ));
L286: [ C83 , C84 ] in [: ( H1(C79) \ { ( 0. C79 ) } ) , ( H1(C79) \ { ( 0. C79 ) } ) :];
thus L287: thesis by L286 , L280 , L284 , FUNCT_1:47;
end;
thus L288: thesis by L285 , L280 , L281 , L282;
end;
theorem
L289: (for B67 being Field holds (for B68 , B69 being (Element of B67) holds (( B68 + B69 ) = ( 0. B67 ) implies B69 = ( ( comp B67 ) . B68 ))))
proof
let C85 being Field;
let C86 , C87 being (Element of C85);
assume L290: ( C86 + C87 ) = ( 0. C85 );
L291: C87 = ( - C86 ) by L290 , RLVECT_1:6;
thus L292: thesis by L291 , VECTSP_1:def 13;
end;
theorem
L293: (for B70 being Field holds (for B71 being (Element of B70) holds B71 = ( ( comp B70 ) . ( ( comp B70 ) . B71 ) )))
proof
let C88 being Field;
let C89 being (Element of C88);
thus L294: C89 = ( - ( - C89 ) ) by RLVECT_1:17
.= ( ( comp C88 ) . ( - C89 ) ) by VECTSP_1:def 13
.= ( ( comp C88 ) . ( ( comp C88 ) . C89 ) ) by VECTSP_1:def 13;
end;
theorem
L295: (for B72 being Field holds (for B73 , B74 being (Element of (the carrier of B72)) holds (( (the addF of B72) . (B73 , B74) ) is (Element of (the carrier of B72)) & ( ( omf B72 ) . (B73 , B74) ) is (Element of (the carrier of B72)) & ( ( comp B72 ) . B73 ) is (Element of (the carrier of B72)))));
theorem
L296: (for B75 being Field holds (for B76 , B77 , B78 being (Element of B75) holds ( B76 * ( B77 - B78 ) ) = ( ( B76 * B77 ) - ( B76 * B78 ) ))) by VECTSP_1:11;
theorem
L297: (for B79 being Field holds (for B80 , B81 , B82 being (Element of B79) holds ( ( B80 - B81 ) * B82 ) = ( ( B80 * B82 ) - ( B81 * B82 ) ))) by VECTSP_1:13;
theorem
L298: (for B83 being Field holds (for B84 being (Element of B83) holds ( B84 * ( 0. B83 ) ) = ( 0. B83 ))) by VECTSP_1:6;
theorem
L299: (for B85 being Field holds (for B86 being (Element of B85) holds ( ( 0. B85 ) * B86 ) = ( 0. B85 ))) by VECTSP_1:7;
theorem
L300: (for B87 being Field holds (for B88 , B89 being (Element of B87) holds ( - ( B88 * B89 ) ) = ( B88 * ( - B89 ) ))) by VECTSP_1:8;
theorem
L301: (for B90 being Field holds ( ( 1. B90 ) * ( 0. B90 ) ) = ( 0. B90 )) by VECTSP_1:6;
theorem
L302: (for B91 being Field holds ( ( 0. B91 ) * ( 1. B91 ) ) = ( 0. B91 )) by VECTSP_1:7;
theorem
L303: (for B92 being Field holds (for B93 , B94 being (Element of (the carrier of B92)) holds ( ( omf B92 ) . (B93 , B94) ) is (Element of (the carrier of B92))));
theorem
L304: (for B95 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B96 , B97 , B98 being (Element of B95) holds ( ( B96 * B97 ) * B98 ) = ( B96 * ( B97 * B98 ) )))
proof
let C90 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C91 , C92 , C93 being (Element of H1(C90));
L305: (C91 = ( 0. C90 ) implies ( ( C91 * C92 ) * C93 ) = ( C91 * ( C92 * C93 ) ))
proof
assume L306: C91 = ( 0. C90 );
thus L307: ( ( C91 * C92 ) * C93 ) = ( ( 0. C90 ) * C93 ) by L306 , VECTSP_1:7
.= ( 0. C90 ) by VECTSP_1:7
.= ( C91 * ( C92 * C93 ) ) by L306 , VECTSP_1:7;
end;
L308: (C92 = ( 0. C90 ) implies ( ( C91 * C92 ) * C93 ) = ( C91 * ( C92 * C93 ) ))
proof
assume L309: C92 = ( 0. C90 );
thus L310: ( ( C91 * C92 ) * C93 ) = ( ( 0. C90 ) * C93 ) by L309 , VECTSP_1:6
.= ( 0. C90 ) by VECTSP_1:7
.= ( C91 * ( 0. C90 ) ) by VECTSP_1:6
.= ( C91 * ( C92 * C93 ) ) by L309 , VECTSP_1:7;
end;
L311: (C93 = ( 0. C90 ) implies ( ( C91 * C92 ) * C93 ) = ( C91 * ( C92 * C93 ) ))
proof
assume L312: C93 = ( 0. C90 );
thus L313: ( ( C91 * C92 ) * C93 ) = ( 0. C90 ) by L312 , VECTSP_1:6
.= ( C91 * ( 0. C90 ) ) by VECTSP_1:6
.= ( C91 * ( C92 * C93 ) ) by L312 , VECTSP_1:6;
end;
L314: (C91 = ( 0. C90 ) or C92 = ( 0. C90 ) or C93 = ( 0. C90 ) or (C91 is (Element of ( NonZero C90 )) & C92 is (Element of ( NonZero C90 )) & C93 is (Element of ( NonZero C90 )))) by ZFMISC_1:56;
thus L315: thesis by L314 , L305 , L308 , L311 , L240;
end;
theorem
L316: (for B99 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B100 , B101 being (Element of B99) holds ( B100 * B101 ) = ( B101 * B100 )))
proof
let C94 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C95 , C96 being (Element of H1(C94));
L317: (C95 = ( 0. C94 ) implies ( C95 * C96 ) = ( C96 * C95 ))
proof
assume L318: C95 = ( 0. C94 );
L319: ( C95 * C96 ) = ( 0. C94 ) by L318 , VECTSP_1:7
.= ( C96 * C95 ) by L318 , VECTSP_1:6;
thus L320: thesis by L319;
end;
L321: (C96 = ( 0. C94 ) implies ( C95 * C96 ) = ( C96 * C95 ))
proof
assume L322: C96 = ( 0. C94 );
L323: ( C95 * C96 ) = ( 0. C94 ) by L322 , VECTSP_1:6
.= ( C96 * C95 ) by L322 , VECTSP_1:7;
thus L324: thesis by L323;
end;
L325: (C95 = ( 0. C94 ) or C96 = ( 0. C94 ) or (C95 is (Element of ( NonZero C94 )) & C96 is (Element of ( NonZero C94 )))) by ZFMISC_1:56;
thus L326: thesis by L325 , L317 , L321 , L258;
end;
theorem
L327: (for B102 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr holds (for B103 being (Element of B102) holds (( B103 * ( 1. B102 ) ) = B103 & ( ( 1. B102 ) * B103 ) = B103)))
proof
let C97 being  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable non  degenerated doubleLoopStr;
let C98 being (Element of H1(C97));
per cases  by ZFMISC_1:56;
suppose L328: C98 = ( 0. C97 );

thus L329: ( C98 * ( 1. C97 ) ) = C98 by L328 , VECTSP_1:7;
thus L330: thesis by L328 , VECTSP_1:6;
end;
suppose L331: C98 is (Element of ( NonZero C97 ));

thus L332: thesis by L331 , L267;
end;
end;
definition
let C99 being Field;
func revf C99 -> (UnOp of ( NonZero C99 )) means 
:L334: (for B104 being (Element of ( NonZero C99 )) holds ( ( omf C99 ) . (B104 , ( it . B104 )) ) = ( 1. C99 ));
existence
proof
defpred S1[ set , set ] means ( ( omf C99 ) . ($1 , $2) ) = ( 1. C99 );
L335: (for B105 being set holds (B105 in ( H1(C99) \ { ( 0. C99 ) } ) implies (ex B106 being set st (B106 in ( H1(C99) \ { ( 0. C99 ) } ) & S1[ B105 , B106 ]))))
proof
let C100 being set;
assume L336: C100 in ( H1(C99) \ { ( 0. C99 ) } );
reconsider D72 = C100 as (Element of ( NonZero C99 )) by L336;
consider C101 being (Element of ( H1(C99) \ { ( 0. C99 ) } )) such that L337: ( D72 * C101 ) = ( 1. C99 ) and L338: ( C101 * D72 ) = ( 1. C99 ) by L277;
reconsider D73 = C101 as set;
take D73;
thus L339: thesis by L337;
end;
L340: (ex B107 being (Function of ( H1(C99) \ { ( 0. C99 ) } ) , ( H1(C99) \ { ( 0. C99 ) } )) st (for B108 being set holds (B108 in ( H1(C99) \ { ( 0. C99 ) } ) implies S1[ B108 , ( B107 . B108 ) ]))) from FUNCT_2:sch 1(L335);
consider C102 being (UnOp of ( NonZero C99 )) such that L341: (for B109 being set holds (B109 in ( H1(C99) \ { ( 0. C99 ) } ) implies ( ( omf C99 ) . (B109 , ( C102 . B109 )) ) = ( 1. C99 ))) by L340;
take C102;
thus L342: thesis by L341;
end;
uniqueness
proof
let C103 , C104 being (UnOp of ( NonZero C99 ));
assume that
L343: (for B110 being (Element of ( NonZero C99 )) holds ( ( omf C99 ) . (B110 , ( C103 . B110 )) ) = ( 1. C99 ))
and
L344: (for B111 being (Element of ( NonZero C99 )) holds ( ( omf C99 ) . (B111 , ( C104 . B111 )) ) = ( 1. C99 ));
L345: (for B112 being set holds (B112 in ( H1(C99) \ { ( 0. C99 ) } ) implies ( C103 . B112 ) = ( C104 . B112 )))
proof
let C105 being set;
assume L346: C105 in ( H1(C99) \ { ( 0. C99 ) } );
L347: ( C103 . C105 ) is (Element of ( NonZero C99 )) by L346 , FUNCT_2:5;
reconsider D74 = C105 , D75 = ( C103 . C105 ) as (Element of C99) by L347 , L346;
L348: ( C104 . C105 ) is (Element of ( NonZero C99 )) by L346 , FUNCT_2:5;
reconsider D76 = ( C104 . C105 ) as (Element of C99) by L348;
L349: ( C103 . C105 ) = ( D75 * ( 1. C99 ) ) by L347 , L267
.= ( D75 * ( D74 * D76 ) ) by L344 , L346
.= ( ( D74 * D75 ) * D76 ) by L346 , L347 , L348 , L240
.= ( ( 1. C99 ) * D76 ) by L343 , L346
.= ( C104 . C105 ) by L348 , L267;
thus L350: thesis by L349;
end;
thus L351: thesis by L345 , FUNCT_2:12;
end;
end;
theorem
L353: (for B113 being Field holds (for B114 , B115 being (Element of ( NonZero B113 )) holds (( B114 * B115 ) = ( 1. B113 ) implies B115 = ( ( revf B113 ) . B114 ))))
proof
let C106 being Field;
let C107 , C108 being (Element of ( NonZero C106 ));
assume L354: ( C107 * C108 ) = ( 1. C106 );
reconsider D77 = ( ( revf C106 ) . C107 ) as (Element of C106) by XBOOLE_0:def 5;
L355: C108 = ( C108 * ( 1. C106 ) ) by L267
.= ( ( omf C106 ) . (C108 , ( 1. C106 )) )
.= ( C108 * ( C107 * D77 ) ) by L334
.= ( ( 1. C106 ) * D77 ) by L354 , L240
.= ( ( revf C106 ) . C107 ) by L267;
thus L356: thesis by L355;
end;
theorem
L357: (for B116 being Field holds (for B117 being (Element of ( NonZero B116 )) holds B117 = ( ( revf B116 ) . ( ( revf B116 ) . B117 ) )))
proof
let C109 being Field;
let C110 being (Element of ( NonZero C109 ));
reconsider D78 = ( ( revf C109 ) . C110 ) as (Element of C109) by XBOOLE_0:def 5;
reconsider D79 = ( ( revf C109 ) . ( ( revf C109 ) . C110 ) ) as (Element of C109) by XBOOLE_0:def 5;
L358: C110 = ( C110 * ( 1. C109 ) ) by L267
.= ( ( omf C109 ) . (C110 , ( 1. C109 )) )
.= ( C110 * ( D78 * D79 ) ) by L334
.= ( ( C110 * D78 ) * D79 ) by L240
.= ( ( omf C109 ) . (( 1. C109 ) , ( ( revf C109 ) . ( ( revf C109 ) . C110 ) )) ) by L334
.= ( ( 1. C109 ) * D79 )
.= ( ( revf C109 ) . ( ( revf C109 ) . C110 ) ) by L267;
thus L359: thesis by L358;
end;
theorem
L360: (for B118 being Field holds (for B119 , B120 being (Element of ( NonZero B118 )) holds (( ( omf B118 ) . (B119 , B120) ) is (Element of ( NonZero B118 )) & ( ( revf B118 ) . B119 ) is (Element of ( NonZero B118 )))))
proof
let C111 being Field;
let C112 , C113 being (Element of ( NonZero C111 ));
L361: [ C112 , C113 ] in [: ( NonZero C111 ) , ( NonZero C111 ) :];
thus L362: thesis by L361 , REALSET1:def 6;
end;
theorem
L363: (for B121 being Field holds (for B122 , B123 , B124 being (Element of B121) holds (( B122 + B123 ) = ( B122 + B124 ) implies B123 = B124))) by RLVECT_1:8;
theorem
L364: (for B125 being Field holds (for B126 being (Element of ( NonZero B125 )) holds (for B127 , B128 being (Element of (the carrier of B125)) holds (( B126 * B127 ) = ( B126 * B128 ) implies B127 = B128))))
proof
let C114 being Field;
let C115 being (Element of ( NonZero C114 ));
let C116 , C117 being (Element of H1(C114));
reconsider D80 = C115 as (Element of C114);
assume L365: ( C115 * C116 ) = ( C115 * C117 );
reconsider D81 = ( ( revf C114 ) . C115 ) as (Element of C114) by XBOOLE_0:def 5;
L366: C116 = ( ( 1. C114 ) * C116 ) by L327
.= ( ( omf C114 ) . (( 1. C114 ) , C116) )
.= ( ( D80 * D81 ) * C116 ) by L334
.= ( D81 * ( D80 * C117 ) ) by L365 , L304
.= ( ( D80 * D81 ) * C117 ) by L304
.= ( ( omf C114 ) . (( 1. C114 ) , C117) ) by L334
.= ( ( 1. C114 ) * C117 )
.= C117 by L327;
thus L367: thesis by L366;
end;
registration
cluster  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable ->  commutative  associative  well-unital  almost_left_invertible for non  degenerated non  degenerated non  degenerated non  degenerated doubleLoopStr;
coherence
proof
let C118 being non  degenerated doubleLoopStr;
assume L368: C118 is  Field-like  Abelian  distributive  add-associative  right_zeroed  right_complementable;
L369: (for B129 , B130 being (Element of C118) holds ( B129 * B130 ) = ( B130 * B129 )) by L368 , L316;
thus L370: C118 is  commutative by L369 , GROUP_1:def 12;
L371: (for B131 , B132 , B133 being (Element of C118) holds ( ( B131 * B132 ) * B133 ) = ( B131 * ( B132 * B133 ) )) by L368 , L304;
thus L372: C118 is  associative by L371 , GROUP_1:def 3;
L373: (for B134 being (Element of C118) holds (( B134 * ( 1. C118 ) ) = B134 & ( ( 1. C118 ) * B134 ) = B134)) by L368 , L327;
thus L374: C118 is  well-unital by L373 , VECTSP_1:def 6;
let C119 being (Element of C118);
assume L375: C119 <> ( 0. C118 );
L376: (not C119 in { ( 0. C118 ) }) by L375 , TARSKI:def 1;
reconsider D82 = C119 as (Element of ( NonZero C118 )) by L376 , XBOOLE_0:def 5;
consider C120 being (Element of ( NonZero C118 )) such that L377: ( D82 * C120 ) = ( 1. C118 ) and L378: ( C120 * D82 ) = ( 1. C118 ) by L368 , L277;
take C120;
thus L379: thesis by L378;
end;
end;
