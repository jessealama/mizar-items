:: Proof of Ford/Fulkerson's Maximum Network Flow Algorithm
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FUNCT_1, RELAT_1, FUNCT_4, FUNCOP_1, XBOOLE_0, TARSKI,
      GLIB_003, VALUED_0, SUBSET_1, REAL_1, GRAPH_5, FINSET_1, ZFMISC_1,
      TREES_1, GLIB_000, PBOOLE, CARD_1, XXREAL_0, CARD_3, XREAL_0, ORDINAL1,
      ARYTM_1, PARTFUN1, ARYTM_3, GLIB_001, ABIAN, NAT_1, FINSEQ_1, GRAPH_1,
      RCOMP_1, INT_1, PRE_POLY, UPROOTS, SGRAPH1, GLIB_005;
 notations TARSKI, XBOOLE_0, CARD_1, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0,
      XREAL_0, DOMAIN_1, REAL_1, RELAT_1, VALUED_0, PARTFUN1, FUNCT_1, PBOOLE,
      FINSEQ_1, FUNCT_2, GRAPH_5, ORDINAL1, UPROOTS, RELSET_1, FINSET_1, INT_1,
      NAT_1, FUNCOP_1, FUNCT_4, GLIB_000, GLIB_001, ABIAN, GLIB_002, GLIB_003,
      PRE_POLY;
 constructors DOMAIN_1, FUNCT_4, NAT_D, GRAPH_2, GRAPH_5, UPROOTS, GLIB_004,
      SEQ_1, XXREAL_2, RELSET_1;
 registrations XBOOLE_0, RELAT_1, PARTFUN1, INT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1,
      GLIB_000, ABIAN, GLIB_001, GLIB_002, GLIB_003, VALUED_0, FUNCT_2, CARD_1,
      PRE_CIRC, PRE_POLY, RELSET_1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, GLIB_000, GLIB_003, FUNCOP_1;
 theorems CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FUNCT_1,
      FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, GLIB_003, GLIB_004, GRAPH_5, ABIAN,
      INT_1, NAT_1, PBOOLE, PEPIN, TARSKI, UPROOTS, XBOOLE_0, XBOOLE_1,
      ZFMISC_1, XREAL_1, XXREAL_0, ORDINAL1, NAT_D, VALUED_0, RELSET_1,
      PARTFUN1, RELAT_1, PRE_POLY;
 schemes NAT_1, SUBSET_1, FINSEQ_1, CLASSES1, RECDEF_1, GRAPH_5;

begin
L1: (for B1 being Function holds (for B2 , B3 being set holds ( dom ( B1 +* ( B2 .--> B3 ) ) ) = ( ( dom B1 ) \/ { B2 } )))
proof
let C1 being Function;
let C2 , C3 being set;
thus L2: ( dom ( C1 +* ( C2 .--> C3 ) ) ) = ( ( dom C1 ) \/ ( dom ( C2 .--> C3 ) ) ) by FUNCT_4:def 1
.= ( ( dom C1 ) \/ { C2 } ) by FUNCOP_1:13;
end;
L3: (for B4 being Function holds (for B5 , B6 being set holds B5 in ( dom ( B4 +* ( B5 .--> B6 ) ) )))
proof
let C4 being Function;
let C5 , C6 being set;
L4: ( dom ( C5 .--> C6 ) ) = { C5 } by FUNCOP_1:13;
L5: C5 in ( dom ( C5 .--> C6 ) ) by L4 , TARSKI:def 1;
L6: ( dom ( C5 .--> C6 ) ) c= ( dom ( C4 +* ( C5 .--> C6 ) ) ) by FUNCT_4:10;
thus L7: thesis by L6 , L5;
end;
L8: (for B7 being Function holds (for B8 , B9 being set holds ( ( B7 +* ( B8 .--> B9 ) ) . B8 ) = B9))
proof
let C7 being Function;
let C8 , C9 being set;
L9: ( dom ( C8 .--> C9 ) ) = { C8 } by FUNCOP_1:13;
L10: C8 in ( dom ( C8 .--> C9 ) ) by L9 , TARSKI:def 1;
thus L11: ( ( C7 +* ( C8 .--> C9 ) ) . C8 ) = ( ( C8 .--> C9 ) . C8 ) by L10 , FUNCT_4:13
.= C9 by FUNCOP_1:72;
end;
L12: (for B10 being Function holds (for B11 , B12 , B13 being set holds (B11 <> B13 implies ( ( B10 +* ( B11 .--> B12 ) ) . B13 ) = ( B10 . B13 ))))
proof
let C10 being Function;
let C11 , C12 , C13 being set;
assume L13: C11 <> C13;
L14: (not C13 in ( dom ( C11 .--> C12 ) )) by L13 , TARSKI:def 1;
thus L15: thesis by L14 , FUNCT_4:11;
end;
begin
definition
let C14 being WGraph;
attr C14 is  natural-weighted
means
:L16: ( the_Weight_of C14 ) is  natural-valued;
end;
registration
cluster  natural-weighted ->  nonnegative-weighted for WGraph;
coherence
proof
let C15 being WGraph;
assume L18: C15 is  natural-weighted;
L19: ( the_Weight_of C15 ) is  natural-valued by L18 , L16;
L20:
now
let C16 being set;
assume L21: C16 in ( rng ( the_Weight_of C15 ) );
L22: ( rng ( the_Weight_of C15 ) ) c= ( NAT ) by L19 , VALUED_0:def 6;
reconsider D1 = C16 as (Element of ( NAT )) by L22 , L21;
L23: D1 is Real;
thus L24: C16 in ( Real>=0 ) by L23 , GRAPH_5:def 12;
end;
L25: ( rng ( the_Weight_of C15 ) ) c= ( Real>=0 ) by L20 , TARSKI:def 3;
thus L26: thesis by L25 , GLIB_003:def 14;
end;
end;
registration
cluster  finite  trivial  Tree-like  natural-weighted for WGraph;
existence
proof
set D2 = ( {} );
set D3 = { 1 };
reconsider D4 = ( {} ) as (Function of D2 , D3) by RELSET_1:12;
set D5 = ( createGraph (D3 , D2 , D4 , D4) );
set D6 = the (Function of ( the_Edges_of D5 ) , ( NAT ));
set D7 = ( D5 .set (( WeightSelector ) , D6) );
take D7;
thus L28: (D7 is  finite & D7 is  trivial & D7 is  Tree-like);
L29: ( the_Weight_of D7 ) = D6 by GLIB_000:8;
thus L30: thesis by L29 , L16;
end;
end;
registration
let C17 being  natural-weighted WGraph;
cluster ( the_Weight_of C17 ) ->  natural-valued;
coherence by L16;
end;
definition
let C18 being _Graph;
mode FF:ELabeling of C18
 is  natural-valued (ManySortedSet of ( the_Edges_of C18 ));
end;
definition
let C19 being  finite  real-weighted WGraph;
let C20 being (FF:ELabeling of C19);
let C21 , C22 being set;
pred C20 has_valid_flow_from C21 , C22
means
:L34: (C21 is (Vertex of C19) & C22 is (Vertex of C19) & (for B14 being set holds (B14 in ( the_Edges_of C19 ) implies (( 0 ) <= ( C20 . B14 ) & ( C20 . B14 ) <= ( ( the_Weight_of C19 ) . B14 )))) & (for B15 being (Vertex of C19) holds ((B15 <> C21 & B15 <> C22) implies ( Sum ( C20 | ( B15 .edgesIn() ) ) ) = ( Sum ( C20 | ( B15 .edgesOut() ) ) ))))
;end;
definition
let C23 being  finite  real-weighted WGraph;
let C24 being (FF:ELabeling of C23);
let C25 , C26 being set;
func C24 .flow (C25 , C26) ->  real number equals 
( ( Sum ( C24 | ( C23 .edgesInto { C26 } ) ) ) - ( Sum ( C24 | ( C23 .edgesOutOf { C26 } ) ) ) );
coherence;
end;
definition
let C27 being  finite  real-weighted WGraph;
let C28 being (FF:ELabeling of C27);
let C29 , C30 being set;
pred C28 has_maximum_flow_from C29 , C30
means
:L37: (C28 has_valid_flow_from C29 , C30 & (for B16 being (FF:ELabeling of C27) holds (B16 has_valid_flow_from C29 , C30 implies ( B16 .flow (C29 , C30) ) <= ( C28 .flow (C29 , C30) ))))
;end;
definition
let C31 being _Graph;
let C32 being (FF:ELabeling of C31);
mode AP:VLabeling of C32
 -> (PartFunc of ( the_Vertices_of C31 ) , ( { 1 } \/ ( the_Edges_of C31 ) ))
means :L39: (not contradiction);
existence;
end;
definition
let C33 being  real-weighted WGraph;
let C34 being (FF:ELabeling of C33);
let C35 being (AP:VLabeling of C34);
let C36 being set;
pred C36 is_forward_edge_wrt C35
means
:L41: (C36 in ( the_Edges_of C33 ) & ( ( the_Source_of C33 ) . C36 ) in ( dom C35 ) & (not ( ( the_Target_of C33 ) . C36 ) in ( dom C35 )) & ( C34 . C36 ) < ( ( the_Weight_of C33 ) . C36 ))
;end;
definition
let C37 being  real-weighted WGraph;
let C38 being (FF:ELabeling of C37);
let C39 being (AP:VLabeling of C38);
let C40 being set;
pred C40 is_backward_edge_wrt C39
means
:L43: (C40 in ( the_Edges_of C37 ) & ( ( the_Target_of C37 ) . C40 ) in ( dom C39 ) & (not ( ( the_Source_of C37 ) . C40 ) in ( dom C39 )) & ( 0 ) < ( C38 . C40 ))
;end;
definition
let C41 being  real-weighted WGraph;
let C42 being (FF:ELabeling of C41);
let C43 being (Walk of C41);
pred C43 is_augmenting_wrt C42
means
:L45: (for B17 being  odd Nat holds (B17 < ( len C43 ) implies ((( C43 . ( B17 + 1 ) ) DJoins ( C43 . B17 ) , ( C43 . ( B17 + 2 ) ) , C41 implies ( C42 . ( C43 . ( B17 + 1 ) ) ) < ( ( the_Weight_of C41 ) . ( C43 . ( B17 + 1 ) ) )) & ((not ( C43 . ( B17 + 1 ) ) DJoins ( C43 . B17 ) , ( C43 . ( B17 + 2 ) ) , C41) implies ( 0 ) < ( C42 . ( C43 . ( B17 + 1 ) ) )))))
;end;
theorem
L47: (for B18 being  real-weighted WGraph holds (for B19 being (FF:ELabeling of B18) holds (for B20 being (Walk of B18) holds (B20 is  trivial implies B20 is_augmenting_wrt B19))))
proof
let C44 being  real-weighted WGraph;
let C45 being (FF:ELabeling of C44);
let C46 being (Walk of C44);
assume L48: C46 is  trivial;
L49:
now
let C47 being  odd Nat;
assume L50: C47 < ( len C46 );
L51: C47 < 1 by L50 , L48 , GLIB_001:126;
thus L52: ((( C46 . ( C47 + 1 ) ) DJoins ( C46 . C47 ) , ( C46 . ( C47 + 2 ) ) , C44 implies ( C45 . ( C46 . ( C47 + 1 ) ) ) < ( ( the_Weight_of C44 ) . ( C46 . ( C47 + 1 ) ) )) & ((not ( C46 . ( C47 + 1 ) ) DJoins ( C46 . C47 ) , ( C46 . ( C47 + 2 ) ) , C44) implies ( 0 ) < ( C45 . ( C46 . ( C47 + 1 ) ) ))) by L51 , ABIAN:12;
end;
thus L53: thesis by L49 , L45;
end;
theorem
L54: (for B21 being  real-weighted WGraph holds (for B22 being (FF:ELabeling of B21) holds (for B23 being (Walk of B21) holds (for B24 , B25 being Nat holds (B23 is_augmenting_wrt B22 implies ( B23 .cut (B24 , B25) ) is_augmenting_wrt B22)))))
proof
let C48 being  real-weighted WGraph;
let C49 being (FF:ELabeling of C48);
let C50 being (Walk of C48);
let C51 , C52 being Nat;
set D8 = ( C50 .cut (C51 , C52) );
assume L55: C50 is_augmenting_wrt C49;
L56:
now
per cases ;
suppose L57: (C51 is  odd & C52 is  odd & C51 <= C52 & C52 <= ( len C50 ));

reconsider D9 = C51 , D10 = C52 as  odd (Element of ( NAT )) by L57 , ORDINAL1:def 12;
L58:
now
let C53 being  odd Nat;
reconsider D11 = C53 as (Element of ( NAT )) by ORDINAL1:def 12;
set D12 = ( D8 . C53 );
set D13 = ( D8 . ( C53 + 1 ) );
set D14 = ( D8 . ( C53 + 2 ) );
assume L59: C53 < ( len D8 );
L60: D11 in ( dom D8 ) by L59 , GLIB_001:12;
L61: D9 <= D10 by L57;
L62: ( D11 + 2 ) in ( dom D8 ) by L59 , GLIB_001:12;
L63: ( D8 . ( D11 + 2 ) ) = ( C50 . ( ( D9 + ( D11 + 2 ) ) - 1 ) ) by L62 , L57 , L61 , GLIB_001:47;
L64: ( D11 + 1 ) in ( dom D8 ) by L59 , GLIB_001:12;
L65: ( D8 . ( D11 + 1 ) ) = ( C50 . ( ( D9 + ( D11 + 1 ) ) - 1 ) ) by L64 , L57 , L61 , GLIB_001:47;
L66: ( ( D9 + D11 ) - 1 ) in ( dom C50 ) by L57 , L60 , L61 , GLIB_001:47;
reconsider D15 = ( ( D9 + C53 ) - 1 ) , D16 = ( ( C51 + ( C53 + 2 ) ) - 1 ) as (Element of ( NAT )) by L66 , L65;
reconsider D17 = D15 as  odd (Element of ( NAT ));
set D18 = ( C50 . D17 );
set D19 = ( C50 . ( D17 + 1 ) );
set D20 = ( C50 . ( D17 + 2 ) );
L67: ( ( D9 + ( D11 + 2 ) ) - 1 ) in ( dom C50 ) by L57 , L62 , L61 , GLIB_001:47;
L68: D16 <= ( len C50 ) by L67 , FINSEQ_3:25;
L69: ( ( ( C51 + ( C53 + 2 ) ) - 1 ) - 2 ) < ( ( len C50 ) - ( 0 ) ) by L68 , XREAL_1:15;
thus L70:now
assume L71: D13 DJoins D12 , D14 , C48;
L72: D19 DJoins D18 , D20 , C48 by L71 , L57 , L60 , L61 , L65 , L63 , GLIB_001:47;
thus L73: ( C49 . D13 ) < ( ( the_Weight_of C48 ) . D13 ) by L72 , L55 , L65 , L69 , L45;
end;
assume L74: (not D13 DJoins D12 , D14 , C48);
L75: (not D19 DJoins D18 , D20 , C48) by L74 , L57 , L60 , L61 , L65 , L63 , GLIB_001:47;
thus L76: ( 0 ) < ( C49 . D13 ) by L75 , L55 , L65 , L69 , L45;
end;
thus L77: thesis by L58 , L45;
end;
suppose L78: (not (C51 is  odd & C52 is  odd & C51 <= C52 & C52 <= ( len C50 )));

thus L79: thesis by L78 , L55 , GLIB_001:def 11;
end;
end;
thus L81: thesis by L56;
end;
theorem
L82: (for B26 being  real-weighted WGraph holds (for B27 being (FF:ELabeling of B26) holds (for B28 being (Walk of B26) holds (for B29 , B30 being set holds ((B28 is_augmenting_wrt B27 & (not B30 in ( B28 .vertices() )) & ((B29 DJoins ( B28 .last() ) , B30 , B26 & ( B27 . B29 ) < ( ( the_Weight_of B26 ) . B29 )) or (B29 DJoins B30 , ( B28 .last() ) , B26 & ( 0 ) < ( B27 . B29 )))) implies ( B28 .addEdge B29 ) is_augmenting_wrt B27)))))
proof
let C54 being  real-weighted WGraph;
let C55 being (FF:ELabeling of C54);
let C56 being (Walk of C54);
let C57 , C58 being set;
assume L83: C56 is_augmenting_wrt C55;
set D21 = ( C56 .addEdge C57 );
assume that
L84: (not C58 in ( C56 .vertices() ))
and
L85: ((C57 DJoins ( C56 .last() ) , C58 , C54 & ( C55 . C57 ) < ( ( the_Weight_of C54 ) . C57 )) or (C57 DJoins C58 , ( C56 .last() ) , C54 & ( 0 ) < ( C55 . C57 )));
let C59 being  odd Nat;
L86: C57 Joins ( C56 .last() ) , C58 , C54 by L85 , GLIB_000:16;
assume L87: C59 < ( len D21 );
L88:
now
per cases ;
suppose L89: C59 < ( len C56 );

reconsider D22 = C59 as (Element of ( NAT )) by ORDINAL1:def 12;
L90: ( D22 + 1 ) in ( dom C56 ) by L89 , GLIB_001:12;
L91: ( C56 . ( C59 + 1 ) ) = ( D21 . ( C59 + 1 ) ) by L90 , L86 , GLIB_001:65;
L92: ( D22 + 2 ) in ( dom C56 ) by L89 , GLIB_001:12;
L93: ( C56 . ( C59 + 2 ) ) = ( D21 . ( C59 + 2 ) ) by L92 , L86 , GLIB_001:65;
L94: D22 in ( dom C56 ) by L89 , GLIB_001:12;
L95: ( C56 . C59 ) = ( D21 . C59 ) by L94 , L86 , GLIB_001:65;
thus L96: thesis by L95 , L83 , L89 , L91 , L93 , L45;
end;
suppose L97: C59 >= ( len C56 );

L98: ( C59 + 1 ) <= ( len D21 ) by L87 , NAT_1:13;
L99: ( C59 + 1 ) <= ( ( len C56 ) + ( 2 * 1 ) ) by L98 , L86 , GLIB_001:64;
L100: ( C59 + 1 ) < ( ( ( len C56 ) + 1 ) + 1 ) by L99 , XXREAL_0:1;
L101: ( C59 + 1 ) <= ( ( len C56 ) + 1 ) by L100 , NAT_1:13;
L102: C59 <= ( len C56 ) by L101 , XREAL_1:6;
L103: C59 = ( len C56 ) by L102 , L97 , XXREAL_0:1;
L104: ( D21 . ( C59 + 1 ) ) = C57 by L103 , L86 , GLIB_001:65;
L105: 1 <= C59 by ABIAN:12;
L106: C59 in ( dom C56 ) by L105 , L102 , FINSEQ_3:25;
L107: ( D21 . C59 ) = ( C56 . C59 ) by L106 , L86 , GLIB_001:65
.= ( C56 .last() ) by L103 , GLIB_001:def 7;
L108:
now
assume that
L109: C57 DJoins ( C56 .last() ) , C58 , C54
and
L110: C57 DJoins C58 , ( C56 .last() ) , C54;
L111: ( ( the_Source_of C54 ) . C57 ) = C58 by L110 , GLIB_000:def 14;
L112: ( ( the_Source_of C54 ) . C57 ) = ( C56 .last() ) by L109 , GLIB_000:def 14;
thus L113: contradiction by L112 , L84 , L111 , GLIB_001:88;
end;
thus L114: (( D21 . ( C59 + 1 ) ) DJoins ( D21 . C59 ) , ( D21 . ( C59 + 2 ) ) , C54 implies ( C55 . ( D21 . ( C59 + 1 ) ) ) < ( ( the_Weight_of C54 ) . ( D21 . ( C59 + 1 ) ) )) by L108 , L85 , L86 , L103 , L107 , L104 , GLIB_001:65;
assume L115: (not ( D21 . ( C59 + 1 ) ) DJoins ( D21 . C59 ) , ( D21 . ( C59 + 2 ) ) , C54);
thus L116: ( 0 ) < ( C55 . ( D21 . ( C59 + 1 ) ) ) by L115 , L85 , L86 , L103 , L107 , L104 , GLIB_001:65;
end;
end;
thus L118: thesis by L88;
end;
begin
definition
let C60 being  real-weighted WGraph;
let C61 being (FF:ELabeling of C60);
let C62 being (AP:VLabeling of C61);
func AP:NextBestEdges C62 -> (Subset of ( the_Edges_of C60 )) means 
:L119: (for B31 being set holds (B31 in it iff (B31 is_forward_edge_wrt C62 or B31 is_backward_edge_wrt C62)));
existence
proof
defpred S1[ set ] means ($1 is_forward_edge_wrt C62 or $1 is_backward_edge_wrt C62);
consider C63 being (Subset of ( the_Edges_of C60 )) such that L120: (for B32 being set holds (B32 in C63 iff (B32 in ( the_Edges_of C60 ) & S1[ B32 ]))) from SUBSET_1:sch 1;
take C63;
let C64 being set;
thus L121: (C64 in C63 implies S1[ C64 ]) by L120;
assume L122: S1[ C64 ];
L123: C64 in ( the_Edges_of C60 ) by L122 , L41 , L43;
thus L124: thesis by L123 , L120 , L122;
end;
uniqueness
proof
let C65 , C66 being (Subset of ( the_Edges_of C60 ));
assume that
L125: (for B33 being set holds (B33 in C65 iff (B33 is_forward_edge_wrt C62 or B33 is_backward_edge_wrt C62)))
and
L126: (for B34 being set holds (B34 in C66 iff (B34 is_forward_edge_wrt C62 or B34 is_backward_edge_wrt C62)));
L127:
now
let C67 being set;
thus L128:now
assume L129: C67 in C65;
L130: (C67 is_forward_edge_wrt C62 or C67 is_backward_edge_wrt C62) by L129 , L125;
thus L131: C67 in C66 by L130 , L126;
end;
assume L132: C67 in C66;
L133: (C67 is_forward_edge_wrt C62 or C67 is_backward_edge_wrt C62) by L132 , L126;
thus L134: C67 in C65 by L133 , L125;
end;
thus L135: thesis by L127 , TARSKI:1;
end;
end;
definition
let C68 being  real-weighted WGraph;
let C69 being (FF:ELabeling of C68);
let C70 being (AP:VLabeling of C69);
func AP:Step C70 -> (AP:VLabeling of C69) equals 
:L137: C70 if ( AP:NextBestEdges C70 ) = ( {} ) , ( C70 +* ( ( ( the_Source_of C68 ) . ( choose ( AP:NextBestEdges C70 ) ) ) .--> ( choose ( AP:NextBestEdges C70 ) ) ) ) if (( AP:NextBestEdges C70 ) <> ( {} ) & (not ( ( the_Source_of C68 ) . ( choose ( AP:NextBestEdges C70 ) ) ) in ( dom C70 ))) otherwise ( C70 +* ( ( ( the_Target_of C68 ) . ( choose ( AP:NextBestEdges C70 ) ) ) .--> ( choose ( AP:NextBestEdges C70 ) ) ) );
coherence
proof
set D23 = ( choose ( AP:NextBestEdges C70 ) );
set D24 = ( the_Source_of C68 );
set D25 = ( the_Target_of C68 );
set D26 = ( the_Vertices_of C68 );
set D27 = ( the_Edges_of C68 );
set D28 = ( AP:NextBestEdges C70 );
per cases ;
suppose L138: D28 = ( {} );

thus L139: thesis by L138;
end;
suppose L140: D28 <> ( {} );

L141: D23 in D28 by L140;
L142: { ( D24 . D23 ) } c= D26
proof
let C71 being set;
assume L143: C71 in { ( D24 . D23 ) };
L144: C71 = ( D24 . D23 ) by L143 , TARSKI:def 1;
thus L145: thesis by L144 , L141 , FUNCT_2:5;
end;
L146: { D23 } c= D27
proof
let C72 being set;
assume L147: C72 in { D23 };
L148: C72 = D23 by L147 , TARSKI:def 1;
thus L149: thesis by L148 , L141;
end;
L150: { D23 } c= ( { 1 } \/ D27 ) by L146 , XBOOLE_1:10;
L151: ( rng ( ( D25 . D23 ) .--> D23 ) ) c= { D23 } by FUNCOP_1:13;
L152: ( rng ( ( D25 . D23 ) .--> D23 ) ) c= ( { 1 } \/ D27 ) by L151 , L150 , XBOOLE_1:1;
L153: ( ( rng C70 ) \/ ( rng ( ( D25 . D23 ) .--> D23 ) ) ) c= ( { 1 } \/ D27 ) by L152 , XBOOLE_1:8;
L154: ( rng ( C70 +* ( ( D25 . D23 ) .--> D23 ) ) ) c= ( ( rng C70 ) \/ ( rng ( ( D25 . D23 ) .--> D23 ) ) ) by FUNCT_4:17;
L155: ( rng ( C70 +* ( ( D25 . D23 ) .--> D23 ) ) ) c= ( { 1 } \/ D27 ) by L154 , L153 , XBOOLE_1:1;
L156: { D23 } c= D27
proof
let C73 being set;
assume L157: C73 in { D23 };
L158: C73 = D23 by L157 , TARSKI:def 1;
thus L159: thesis by L158 , L141;
end;
L160: { D23 } c= ( { 1 } \/ D27 ) by L156 , XBOOLE_1:10;
L161: ( rng ( ( D24 . D23 ) .--> D23 ) ) c= { D23 } by FUNCOP_1:13;
L162: ( rng ( ( D24 . D23 ) .--> D23 ) ) c= ( { 1 } \/ D27 ) by L161 , L160 , XBOOLE_1:1;
L163: ( ( rng C70 ) \/ ( rng ( ( D24 . D23 ) .--> D23 ) ) ) c= ( { 1 } \/ D27 ) by L162 , XBOOLE_1:8;
L164: ( rng ( C70 +* ( ( D24 . D23 ) .--> D23 ) ) ) c= ( ( rng C70 ) \/ ( rng ( ( D24 . D23 ) .--> D23 ) ) ) by FUNCT_4:17;
L165: ( rng ( C70 +* ( ( D24 . D23 ) .--> D23 ) ) ) c= ( { 1 } \/ D27 ) by L164 , L163 , XBOOLE_1:1;
L166: { ( D25 . D23 ) } c= D26
proof
let C74 being set;
assume L167: C74 in { ( D25 . D23 ) };
L168: C74 = ( D25 . D23 ) by L167 , TARSKI:def 1;
thus L169: thesis by L168 , L141 , FUNCT_2:5;
end;
L170: ( dom ( C70 +* ( ( D25 . D23 ) .--> D23 ) ) ) = ( ( dom C70 ) \/ ( dom ( ( D25 . D23 ) .--> D23 ) ) ) by FUNCT_4:def 1
.= ( ( dom C70 ) \/ { ( D25 . D23 ) } ) by FUNCOP_1:13;
L171: ( C70 +* ( ( D25 . D23 ) .--> D23 ) ) is (Relation of D26 , ( { 1 } \/ D27 )) by L170 , L166 , L155 , RELSET_1:4 , XBOOLE_1:8;
L172: ( dom ( C70 +* ( ( D24 . D23 ) .--> D23 ) ) ) = ( ( dom C70 ) \/ ( dom ( ( D24 . D23 ) .--> D23 ) ) ) by FUNCT_4:def 1
.= ( ( dom C70 ) \/ { ( D24 . D23 ) } ) by FUNCOP_1:13;
L173: ( C70 +* ( ( D24 . D23 ) .--> D23 ) ) is (Relation of D26 , ( { 1 } \/ D27 )) by L172 , L142 , L165 , RELSET_1:4 , XBOOLE_1:8;
thus L174: thesis by L173 , L171 , L39;
end;
end;
consistency;
end;
definition
let C75 being _Graph;
let C76 being (FF:ELabeling of C75);
mode AP:VLabelingSeq of C76
 -> (ManySortedSet of ( NAT ))
means :L177: (for B35 being Nat holds ( it . B35 ) is (AP:VLabeling of C76));
existence
proof
set D29 = ( ( NAT ) --> ( {} ) );
reconsider D30 = D29 as (ManySortedSet of ( NAT ));
take D30;
let C77 being Nat;
L178: C77 in ( NAT ) by ORDINAL1:def 12;
L179: ( D30 . C77 ) = ( {} ) by L178 , FUNCOP_1:7;
L180: ( D30 . C77 ) is (PartFunc of ( the_Vertices_of C75 ) , ( { 1 } \/ ( the_Edges_of C75 ) )) by L179 , RELSET_1:12;
thus L181: thesis by L180 , L39;
end;
end;
definition
let C78 being _Graph;
let C79 being (FF:ELabeling of C78);
let C80 being (AP:VLabelingSeq of C79);
let C81 being Nat;
redefine func C80 . C81 -> (AP:VLabeling of C79);

coherence by L177;
end;
definition
let C82 being  real-weighted WGraph;
let C83 being (FF:ELabeling of C82);
let C84 being (Vertex of C82);
func AP:CompSeq (C83 , C84) -> (AP:VLabelingSeq of C83) means 
:L184: (( it . ( 0 ) ) = ( C84 .--> 1 ) & (for B36 being Nat holds ( it . ( B36 + 1 ) ) = ( AP:Step ( it . B36 ) )));
existence
proof
defpred S2[ set , set , set ] means (($2 is (AP:VLabeling of C83) & (ex B37 , B38 being (AP:VLabeling of C83) st ($2 = B37 & $3 = B38 & B38 = ( AP:Step B37 )))) or ((not $2 is (AP:VLabeling of C83)) & $2 = $3));
L185: ( rng ( C84 .--> 1 ) ) = { 1 } by FUNCOP_1:8;
L186:
now
let C85 , C86 being set;
L187:
now
per cases ;
suppose L188: C86 is (AP:VLabeling of C83);

reconsider D31 = C86 as (AP:VLabeling of C83) by L188;
L189: S2[ C85 , C86 , ( AP:Step D31 ) ];
thus L190: (ex B39 being set st S2[ C85 , C86 , B39 ]) by L189;
end;
suppose L191: (not C86 is (AP:VLabeling of C83));

thus L192: (ex B40 being set st S2[ C85 , C86 , B40 ]) by L191;
end;
end;
thus L194: (ex B41 being set st S2[ C85 , C86 , B41 ]) by L187;
end;
L195: (for B42 being (Element of ( NAT )) holds (for B43 being set holds (ex B44 being set st S2[ B42 , B43 , B44 ]))) by L186;
consider C87 being Function such that L196: (( dom C87 ) = ( NAT ) & ( C87 . ( 0 ) ) = ( C84 .--> 1 ) & (for B45 being (Element of ( NAT )) holds S2[ B45 , ( C87 . B45 ) , ( C87 . ( B45 + 1 ) ) ])) from RECDEF_1:sch 1(L195);
reconsider D32 = C87 as (ManySortedSet of ( NAT )) by L196 , PARTFUN1:def 2 , RELAT_1:def 18;
defpred S3[ Nat ] means ( D32 . $1 ) is (AP:VLabeling of C83);
L197:
now
let C88 being Nat;
assume L198: S3[ C88 ];
L199: C88 in ( NAT ) by ORDINAL1:def 12;
L200: (ex B46 , B47 being (AP:VLabeling of C83) st (( D32 . C88 ) = B46 & ( D32 . ( C88 + 1 ) ) = B47 & B47 = ( AP:Step B46 ))) by L199 , L196 , L198;
thus L201: S3[ ( C88 + 1 ) ] by L200;
end;
L202: ( dom ( C84 .--> 1 ) ) = { C84 } by FUNCOP_1:13;
L203: ( C84 .--> 1 ) is (Relation of ( the_Vertices_of C82 ) , ( { 1 } \/ ( the_Edges_of C82 ) )) by L202 , L185 , RELSET_1:4 , XBOOLE_1:7;
L204: S3[ ( 0 ) ] by L203 , L196 , L39;
L205: (for B48 being Nat holds S3[ B48 ]) from NAT_1:sch 2(L204 , L197);
reconsider D33 = D32 as (AP:VLabelingSeq of C83) by L205 , L177;
take D33;
thus L206: ( D33 . ( 0 ) ) = ( C84 .--> 1 ) by L196;
let C89 being Nat;
L207: C89 is (Element of ( NAT )) by ORDINAL1:def 12;
L208: (ex B49 , B50 being (AP:VLabeling of C83) st (( D33 . C89 ) = B49 & ( D33 . ( C89 + 1 ) ) = B50 & B50 = ( AP:Step B49 ))) by L207 , L196;
thus L209: thesis by L208;
end;
uniqueness
proof
let C90 , C91 being (AP:VLabelingSeq of C83);
assume that
L210: ( C90 . ( 0 ) ) = ( C84 .--> 1 )
and
L211: (for B51 being Nat holds ( C90 . ( B51 + 1 ) ) = ( AP:Step ( C90 . B51 ) ))
and
L212: ( C91 . ( 0 ) ) = ( C84 .--> 1 )
and
L213: (for B52 being Nat holds ( C91 . ( B52 + 1 ) ) = ( AP:Step ( C91 . B52 ) ));
defpred S4[ Nat ] means ( C90 . $1 ) = ( C91 . $1 );
L214:
now
let C92 being Nat;
assume L215: S4[ C92 ];
L216: ( C90 . ( C92 + 1 ) ) = ( AP:Step ( C91 . C92 ) ) by L215 , L211
.= ( C91 . ( C92 + 1 ) ) by L213;
thus L217: S4[ ( C92 + 1 ) ] by L216;
end;
L218: (for B53 being Nat holds (S4[ B53 ] implies S4[ ( B53 + 1 ) ])) by L214;
L219: S4[ ( 0 ) ] by L210 , L212;
L220: (for B54 being Nat holds S4[ B54 ]) from NAT_1:sch 2(L219 , L218);
L221: (for B55 being set holds (B55 in ( NAT ) implies ( C90 . B55 ) = ( C91 . B55 ))) by L220;
thus L222: C90 = C91 by L221 , PBOOLE:3;
end;
end;
theorem
L224: (for B56 being  real-weighted WGraph holds (for B57 being (FF:ELabeling of B56) holds (for B58 being (Vertex of B56) holds ( dom ( ( AP:CompSeq (B57 , B58) ) . ( 0 ) ) ) = { B58 })))
proof
let C93 being  real-weighted WGraph;
let C94 being (FF:ELabeling of C93);
let C95 being (Vertex of C93);
L225: ( ( AP:CompSeq (C94 , C95) ) . ( 0 ) ) = ( C95 .--> 1 ) by L184;
thus L226: thesis by L225 , FUNCOP_1:13;
end;
theorem
L227: (for B59 being  real-weighted WGraph holds (for B60 being (FF:ELabeling of B59) holds (for B61 being (Vertex of B59) holds (for B62 , B63 being Nat holds (B62 <= B63 implies ( dom ( ( AP:CompSeq (B60 , B61) ) . B62 ) ) c= ( dom ( ( AP:CompSeq (B60 , B61) ) . B63 ) ))))))
proof
let C96 being  real-weighted WGraph;
let C97 being (FF:ELabeling of C96);
let C98 being (Vertex of C96);
let C99 , C100 being Nat;
set D34 = ( AP:CompSeq (C97 , C98) );
defpred S5[ (Element of ( NAT )) ] means ( dom ( D34 . C99 ) ) c= ( dom ( D34 . ( C99 + $1 ) ) );
assume L228: C99 <= C100;
consider C101 being Nat such that L229: C100 = ( C99 + C101 ) by L228 , NAT_1:10;
L230:
now
let C102 being (Element of ( NAT ));
set D35 = ( D34 . ( C99 + C102 ) );
set D36 = ( D34 . ( C99 + ( C102 + 1 ) ) );
set D37 = ( AP:NextBestEdges D35 );
set D38 = ( choose D37 );
L231: D36 = ( D34 . ( ( C99 + C102 ) + 1 ) );
L232: D36 = ( AP:Step D35 ) by L231 , L184;
assume L233: S5[ C102 ];
L234:
now
per cases ;
suppose L235: D37 = ( {} );

thus L236: S5[ ( C102 + 1 ) ] by L235 , L233 , L232 , L137;
end;
suppose L237: (D37 <> ( {} ) & (not ( ( the_Source_of C96 ) . D38 ) in ( dom D35 )));

L238: D36 = ( D35 +* ( ( ( the_Source_of C96 ) . D38 ) .--> D38 ) ) by L237 , L232 , L137;
L239: ( dom D35 ) c= ( dom D36 ) by L238 , FUNCT_4:10;
thus L240: S5[ ( C102 + 1 ) ] by L239 , L233 , XBOOLE_1:1;
end;
suppose L241: (D37 <> ( {} ) & ( ( the_Source_of C96 ) . D38 ) in ( dom D35 ));

L242: D36 = ( D35 +* ( ( ( the_Target_of C96 ) . D38 ) .--> D38 ) ) by L241 , L232 , L137;
L243: ( dom D35 ) c= ( dom D36 ) by L242 , FUNCT_4:10;
thus L244: S5[ ( C102 + 1 ) ] by L243 , L233 , XBOOLE_1:1;
end;
end;
thus L246: S5[ ( C102 + 1 ) ] by L234;
end;
L247: S5[ ( 0 ) ];
L248: (for B64 being (Element of ( NAT )) holds S5[ B64 ]) from NAT_1:sch 1(L247 , L230);
L249: C101 in ( NAT ) by ORDINAL1:def 12;
thus L250: thesis by L249 , L248 , L229;
end;
definition
let C103 being  real-weighted WGraph;
let C104 being (FF:ELabeling of C103);
let C105 being (Vertex of C103);
func AP:FindAugPath (C104 , C105) -> (AP:VLabeling of C104) equals 
( ( AP:CompSeq (C104 , C105) ) .Result() );
coherence
proof
set D39 = ( AP:CompSeq (C104 , C105) );
L251: ( D39 .Result() ) = ( D39 . ( D39 .Lifespan() ) );
thus L252: thesis by L251;
end;
end;
theorem
L254: (for B65 being  finite  real-weighted WGraph holds (for B66 being (FF:ELabeling of B65) holds (for B67 being (Vertex of B65) holds ( AP:CompSeq (B66 , B67) ) is  halting)))
proof
let C106 being  finite  real-weighted WGraph;
let C107 being (FF:ELabeling of C106);
let C108 being (Vertex of C106);
set D40 = ( AP:CompSeq (C107 , C108) );
L255:
now
set D41 = ( card ( the_Vertices_of C106 ) );
defpred S6[ (Element of ( NAT )) ] means ( card ( dom ( D40 . $1 ) ) ) = ( $1 + 1 );
assume L256: (for B68 being (Element of ( NAT )) holds ( D40 . B68 ) <> ( D40 . ( B68 + 1 ) ));
L257:
now
let C109 being (Element of ( NAT ));
set D42 = ( D40 . C109 );
set D43 = ( D40 . ( C109 + 1 ) );
set D44 = ( AP:NextBestEdges D42 );
set D45 = ( choose D44 );
L258: D43 = ( AP:Step D42 ) by L184;
assume L259: S6[ C109 ];
L260:
now
per cases ;
suppose L261: D44 = ( {} );

L262: D42 = ( D40 . ( C109 + 1 ) ) by L261 , L258 , L137;
thus L263: S6[ ( C109 + 1 ) ] by L262 , L256;
end;
suppose L264: (D44 <> ( {} ) & (not ( ( the_Source_of C106 ) . D45 ) in ( dom D42 )));

L265: D43 = ( D42 +* ( ( ( the_Source_of C106 ) . D45 ) .--> D45 ) ) by L264 , L258 , L137;
L266: ( dom D43 ) = ( ( dom D42 ) \/ { ( ( the_Source_of C106 ) . D45 ) } ) by L265 , L1;
thus L267: S6[ ( C109 + 1 ) ] by L266 , L259 , L264 , CARD_2:41;
end;
suppose L268: (D44 <> ( {} ) & ( ( the_Source_of C106 ) . D45 ) in ( dom D42 ));

L269: D43 = ( D42 +* ( ( ( the_Target_of C106 ) . D45 ) .--> D45 ) ) by L268 , L258 , L137;
L270: ( dom D43 ) = ( ( dom D42 ) \/ { ( ( the_Target_of C106 ) . D45 ) } ) by L269 , L1;
L271: (D45 is_forward_edge_wrt D42 or D45 is_backward_edge_wrt D42) by L268 , L119;
L272: (not ( ( the_Target_of C106 ) . D45 ) in ( dom D42 )) by L271 , L268 , L41 , L43;
thus L273: S6[ ( C109 + 1 ) ] by L272 , L259 , L270 , CARD_2:41;
end;
end;
thus L275: S6[ ( C109 + 1 ) ] by L260;
end;
L276: ( dom ( D40 . ( 0 ) ) ) = { C108 } by L224;
L277: S6[ ( 0 ) ] by L276 , CARD_1:30;
L278: (for B69 being (Element of ( NAT )) holds S6[ B69 ]) from NAT_1:sch 1(L277 , L257);
L279: ( card ( dom ( D40 . D41 ) ) ) = ( ( card ( the_Vertices_of C106 ) ) + 1 ) by L278;
L280: ( 1 + ( card ( the_Vertices_of C106 ) ) ) <= ( ( card ( the_Vertices_of C106 ) ) + ( 0 ) ) by L279 , NAT_1:43;
thus L281: contradiction by L280 , XREAL_1:6;
end;
thus L282: thesis by L255 , GLIB_000:def 54;
end;
theorem
L283: (for B70 being  finite  real-weighted WGraph holds (for B71 being (FF:ELabeling of B70) holds (for B72 being (Vertex of B70) holds (for B73 being Nat holds (for B74 being set holds (B74 in ( dom ( ( AP:CompSeq (B71 , B72) ) . B73 ) ) implies ( ( ( AP:CompSeq (B71 , B72) ) . B73 ) . B74 ) = ( ( AP:FindAugPath (B71 , B72) ) . B74 )))))))
proof
let C110 being  finite  real-weighted WGraph;
let C111 being (FF:ELabeling of C110);
let C112 being (Vertex of C110);
let C113 being Nat;
let C114 being set;
set D46 = ( the_Source_of C110 );
set D47 = ( the_Target_of C110 );
set D48 = ( AP:CompSeq (C111 , C112) );
set D49 = ( D48 .Lifespan() );
set D50 = ( D48 . D49 );
set D51 = ( D48 . ( D49 + 1 ) );
defpred S7[ (Element of ( NAT )) ] means (for B75 being set holds (B75 in ( dom ( D48 . C113 ) ) implies ( ( D48 . C113 ) . B75 ) = ( ( D48 . ( C113 + $1 ) ) . B75 )));
defpred S8[ (Element of ( NAT )) ] means D50 = ( D48 . ( D49 + $1 ) );
L284: D48 is  halting by L254;
L285:
now
let C115 being (Element of ( NAT ));
set D52 = ( D48 . ( ( D49 + C115 ) + 1 ) );
assume L286: S8[ C115 ];
L287: D52 = ( AP:Step D50 ) by L286 , L184
.= D51 by L184;
thus L288: S8[ ( C115 + 1 ) ] by L287 , L284 , GLIB_000:def 55;
end;
L289: S8[ ( 0 ) ];
L290: (for B76 being (Element of ( NAT )) holds S8[ B76 ]) from NAT_1:sch 1(L289 , L285);
L291:
now
let C116 being (Element of ( NAT ));
assume L292: S7[ C116 ];
set D53 = ( D48 . ( C113 + C116 ) );
set D54 = ( D48 . ( ( C113 + C116 ) + 1 ) );
set D55 = ( AP:NextBestEdges D53 );
set D56 = ( choose D55 );
L293: D54 = ( AP:Step D53 ) by L184;
L294:
now
per cases ;
suppose L295: D55 = ( {} );

L296: D54 = D53 by L295 , L293 , L137;
thus L297: S7[ ( C116 + 1 ) ] by L296 , L292;
end;
suppose L298: (D55 <> ( {} ) & (not ( D46 . D56 ) in ( dom D53 )));

L299: D54 = ( D53 +* ( ( D46 . D56 ) .--> D56 ) ) by L298 , L293 , L137;
L300:
now
let C117 being set;
assume L301: C117 in ( dom ( D48 . C113 ) );
L302: ( ( D48 . C113 ) . C117 ) = ( D53 . C117 ) by L301 , L292;
L303: ( dom ( D48 . C113 ) ) c= ( dom D53 ) by L227 , NAT_1:11;
L304: C117 <> ( D46 . D56 ) by L303 , L298 , L301;
thus L305: ( ( D48 . C113 ) . C117 ) = ( D54 . C117 ) by L304 , L299 , L302 , L12;
end;
thus L306: S7[ ( C116 + 1 ) ] by L300;
end;
suppose L307: (D55 <> ( {} ) & ( D46 . D56 ) in ( dom D53 ));

L308: (D56 is_forward_edge_wrt D53 or D56 is_backward_edge_wrt D53) by L307 , L119;
L309: D54 = ( D53 +* ( ( D47 . D56 ) .--> D56 ) ) by L293 , L307 , L137;
L310:
now
let C118 being set;
assume L311: C118 in ( dom ( D48 . C113 ) );
L312: ( ( D48 . C113 ) . C118 ) = ( D53 . C118 ) by L311 , L292;
L313: ( dom ( D48 . C113 ) ) c= ( dom D53 ) by L227 , NAT_1:11;
L314: C118 <> ( D47 . D56 ) by L313 , L307 , L308 , L311 , L41 , L43;
thus L315: ( ( D48 . C113 ) . C118 ) = ( D54 . C118 ) by L314 , L309 , L312 , L12;
end;
thus L316: S7[ ( C116 + 1 ) ] by L310;
end;
end;
thus L318: S7[ ( C116 + 1 ) ] by L294;
end;
L319: (for B77 being (Element of ( NAT )) holds (S7[ B77 ] implies S7[ ( B77 + 1 ) ])) by L291;
L320: S7[ ( 0 ) ];
L321: (for B78 being (Element of ( NAT )) holds S7[ B78 ]) from NAT_1:sch 1(L320 , L319);
assume L322: C114 in ( dom ( D48 . C113 ) );
L323:
now
per cases ;
suppose L324: C113 <= ( D48 .Lifespan() );

consider C119 being Nat such that L325: ( C113 + C119 ) = ( D48 .Lifespan() ) by L324 , NAT_1:10;
reconsider D57 = C119 as (Element of ( NAT )) by ORDINAL1:def 12;
L326: ( C113 + D57 ) = ( D48 .Lifespan() ) by L325;
thus L327: thesis by L326 , L322 , L321;
end;
suppose L328: ( D48 .Lifespan() ) < C113;

consider C120 being Nat such that L329: ( ( D48 .Lifespan() ) + C120 ) = C113 by L328 , NAT_1:10;
reconsider D58 = C120 as (Element of ( NAT )) by ORDINAL1:def 12;
L330: ( ( D48 .Lifespan() ) + D58 ) = C113 by L329;
thus L331: thesis by L330 , L290;
end;
end;
thus L333: thesis by L323;
end;
definition
let C121 being  finite  real-weighted WGraph;
let C122 being (FF:ELabeling of C121);
let C123 , C124 being (Vertex of C121);
func AP:GetAugPath (C122 , C123 , C124) ->  vertex-distinct (Path of C121) means 
:L334: (it is_Walk_from C123 , C124 & it is_augmenting_wrt C122 & (for B79 being  even Nat holds (B79 in ( dom it ) implies ( it . B79 ) = ( ( AP:FindAugPath (C122 , C123) ) . ( it . ( B79 + 1 ) ) )))) if C124 in ( dom ( AP:FindAugPath (C122 , C123) ) ) otherwise it = ( C121 .walkOf C123 );
existence
proof
set D59 = ( AP:CompSeq (C122 , C123) );
set D60 = ( AP:FindAugPath (C122 , C123) );
defpred S9[ Nat ] means (for B80 being set holds (B80 in ( dom ( D59 . $1 ) ) implies (ex B81 being  vertex-distinct (Path of C121) st (B81 is_Walk_from C123 , B80 & B81 is_augmenting_wrt C122 & ( B81 .vertices() ) c= ( dom ( D59 . $1 ) ) & (for B82 being  even Nat holds (B82 in ( dom B81 ) implies ( B81 . B82 ) = ( D60 . ( B81 . ( B82 + 1 ) ) )))))));
L335:
now
let C125 being Nat;
assume L336: S9[ C125 ];
set D61 = ( D59 . C125 );
set D62 = ( D59 . ( C125 + 1 ) );
set D63 = ( AP:NextBestEdges D61 );
set D64 = ( choose D63 );
L337: D62 = ( AP:Step D61 ) by L184;
L338:
now
per cases ;
suppose L339: D63 = ( {} );

L340: D62 = D61 by L339 , L337 , L137;
thus L341: S9[ ( C125 + 1 ) ] by L340 , L336;
end;
suppose L342: (D63 <> ( {} ) & (not ( ( the_Source_of C121 ) . D64 ) in ( dom D61 )));

L343: (D64 is_forward_edge_wrt D61 or D64 is_backward_edge_wrt D61) by L342 , L119;
L344: ( 0 ) < ( C122 . D64 ) by L343 , L342 , L41 , L43;
L345: D64 in D63 by L342;
L346: D62 = ( D61 +* ( ( ( the_Source_of C121 ) . D64 ) .--> D64 ) ) by L337 , L342 , L137;
L347: ( dom D62 ) = ( ( dom D61 ) \/ { ( ( the_Source_of C121 ) . D64 ) } ) by L346 , L1;
L348: ( ( the_Target_of C121 ) . D64 ) in ( dom D61 ) by L342 , L343 , L41 , L43;
L349:
now
let C126 being set;
assume L350: C126 in ( dom D62 );
L351:
now
per cases  by L347 , L350 , XBOOLE_0:def 3;
suppose L352: C126 in ( dom D61 );

consider C127 being  vertex-distinct (Path of C121) such that L353: C127 is_Walk_from C123 , C126 and L354: C127 is_augmenting_wrt C122 and L355: ( C127 .vertices() ) c= ( dom D61 ) and L356: (for B83 being  even Nat holds (B83 in ( dom C127 ) implies ( C127 . B83 ) = ( D60 . ( C127 . ( B83 + 1 ) ) ))) by L352 , L336;
take D65 = C127;
L357: ( dom D61 ) c= ( dom D62 ) by L227 , NAT_1:11;
thus L358: (D65 is_Walk_from C123 , C126 & D65 is_augmenting_wrt C122 & ( D65 .vertices() ) c= ( dom D62 ) & (for B84 being  even Nat holds (B84 in ( dom D65 ) implies ( D65 . B84 ) = ( D60 . ( D65 . ( B84 + 1 ) ) )))) by L357 , L353 , L354 , L355 , L356 , XBOOLE_1:1;
end;
suppose L359: C126 in { ( ( the_Source_of C121 ) . D64 ) };

L360: C126 = ( ( the_Source_of C121 ) . D64 ) by L359 , TARSKI:def 1;
L361:
now
consider C128 being  vertex-distinct (Path of C121) such that L362: C128 is_Walk_from C123 , ( ( the_Target_of C121 ) . D64 ) and L363: C128 is_augmenting_wrt C122 and L364: ( C128 .vertices() ) c= ( dom D61 ) and L365: (for B85 being  even Nat holds (B85 in ( dom C128 ) implies ( C128 . B85 ) = ( D60 . ( C128 . ( B85 + 1 ) ) ))) by L336 , L348;
set D66 = ( C128 .addEdge D64 );
L366: ( C128 .last() ) = ( ( the_Target_of C121 ) . D64 ) by L362 , GLIB_001:def 23;
L367: D64 Joins ( C128 .last() ) , ( ( the_Source_of C121 ) . D64 ) , C121 by L366 , L345 , GLIB_000:def 13;
L368: (not ( ( the_Source_of C121 ) . D64 ) in ( C128 .vertices() )) by L342 , L364;
reconsider D67 = D66 as  vertex-distinct (Walk of C121) by L368 , L367 , GLIB_001:155;
take D68 = D67;
L369: ( C128 .first() ) = C123 by L362 , GLIB_001:def 23;
thus L370: D68 is_Walk_from C123 , C126 by L369 , L360 , L367 , GLIB_001:63;
L371: D64 DJoins ( ( the_Source_of C121 ) . D64 ) , ( C128 .last() ) , C121 by L345 , L366 , GLIB_000:def 14;
thus L372: D68 is_augmenting_wrt C122 by L371 , L344 , L363 , L368 , L82;
L373: ( D68 .vertices() ) = ( ( C128 .vertices() ) \/ { C126 } ) by L360 , L367 , GLIB_001:95;
L374:
now
let C129 being set;
assume L375: C129 in ( D68 .vertices() );
L376:
now
per cases  by L373 , L375 , XBOOLE_0:def 3;
suppose L377: C129 in ( C128 .vertices() );

L378: ( dom D61 ) c= ( dom D62 ) by L227 , NAT_1:11;
L379: C129 in ( dom D61 ) by L364 , L377;
thus L380: C129 in ( dom D62 ) by L379 , L378;
end;
suppose L381: C129 in { C126 };

thus L382: C129 in ( dom D62 ) by L381 , L347 , L360 , XBOOLE_0:def 3;
end;
end;
thus L384: C129 in ( dom D62 ) by L376;
end;
thus L385: ( D68 .vertices() ) c= ( dom D62 ) by L374 , TARSKI:def 3;
let C130 being  even Nat;
assume L386: C130 in ( dom D68 );
L387: C130 <= ( len D68 ) by L386 , FINSEQ_3:25;
L388: 1 <= C130 by L386 , FINSEQ_3:25;
L389:
now
per cases ;
suppose L390: C130 <= ( len C128 );

L391: C130 < ( len C128 ) by L390 , XXREAL_0:1;
L392: ( C130 + 1 ) <= ( len C128 ) by L391 , NAT_1:13;
L393: 1 <= ( 1 + C130 ) by NAT_1:11;
L394: ( C130 + 1 ) in ( dom C128 ) by L393 , L392 , FINSEQ_3:25;
L395: ( D68 . ( C130 + 1 ) ) = ( C128 . ( C130 + 1 ) ) by L394 , L367 , GLIB_001:65;
L396: C130 in ( dom C128 ) by L388 , L390 , FINSEQ_3:25;
L397: ( D68 . C130 ) = ( C128 . C130 ) by L396 , L367 , GLIB_001:65;
thus L398: ( D68 . C130 ) = ( D60 . ( D68 . ( C130 + 1 ) ) ) by L397 , L365 , L396 , L395;
end;
suppose L399: C130 > ( len C128 );

L400: C130 <= ( ( len C128 ) + ( 2 * 1 ) ) by L367 , L387 , GLIB_001:64;
L401: C130 < ( ( ( len C128 ) + 1 ) + 1 ) by L400 , XXREAL_0:1;
L402: C130 <= ( ( len C128 ) + 1 ) by L401 , NAT_1:13;
L403: ( ( len C128 ) + 1 ) <= C130 by L399 , NAT_1:13;
L404: C130 = ( ( len C128 ) + 1 ) by L403 , L402 , XXREAL_0:1;
L405: ( D68 . C130 ) = D64 by L404 , L367 , GLIB_001:65;
L406: ( C130 + 1 ) = ( ( len C128 ) + ( 1 + 1 ) ) by L404;
L407: ( D68 . ( C130 + 1 ) ) = C126 by L406 , L360 , L367 , GLIB_001:65;
L408: C126 in ( dom D62 ) by L347 , L359 , XBOOLE_0:def 3;
L409: ( D62 . C126 ) = D64 by L346 , L360 , L8;
thus L410: ( D68 . C130 ) = ( D60 . ( D68 . ( C130 + 1 ) ) ) by L409 , L405 , L407 , L408 , L283;
end;
end;
thus L412: ( D68 . C130 ) = ( D60 . ( D68 . ( C130 + 1 ) ) ) by L389;
end;
thus L413: (ex B86 being  vertex-distinct (Path of C121) st (B86 is_Walk_from C123 , C126 & B86 is_augmenting_wrt C122 & ( B86 .vertices() ) c= ( dom D62 ) & (for B87 being  even Nat holds (B87 in ( dom B86 ) implies ( B86 . B87 ) = ( D60 . ( B86 . ( B87 + 1 ) ) ))))) by L361;
end;
end;
thus L415: (ex B88 being  vertex-distinct (Path of C121) st (B88 is_Walk_from C123 , C126 & B88 is_augmenting_wrt C122 & ( B88 .vertices() ) c= ( dom D62 ) & (for B89 being  even Nat holds (B89 in ( dom B88 ) implies ( B88 . B89 ) = ( D60 . ( B88 . ( B89 + 1 ) ) ))))) by L351;
end;
thus L416: S9[ ( C125 + 1 ) ] by L349;
end;
suppose L417: (D63 <> ( {} ) & ( ( the_Source_of C121 ) . D64 ) in ( dom D61 ));

L418: D62 = ( D61 +* ( ( ( the_Target_of C121 ) . D64 ) .--> D64 ) ) by L417 , L337 , L137;
L419: ( dom D62 ) = ( ( dom D61 ) \/ { ( ( the_Target_of C121 ) . D64 ) } ) by L418 , L1;
L420: D64 in D63 by L417;
L421: (D64 is_forward_edge_wrt D61 or D64 is_backward_edge_wrt D61) by L417 , L119;
L422: ( C122 . D64 ) < ( ( the_Weight_of C121 ) . D64 ) by L421 , L417 , L41 , L43;
L423:
now
let C131 being set;
assume L424: C131 in ( dom D62 );
L425:
now
per cases  by L419 , L424 , XBOOLE_0:def 3;
suppose L426: C131 in ( dom D61 );

consider C132 being  vertex-distinct (Path of C121) such that L427: C132 is_Walk_from C123 , C131 and L428: C132 is_augmenting_wrt C122 and L429: ( C132 .vertices() ) c= ( dom D61 ) and L430: (for B90 being  even Nat holds (B90 in ( dom C132 ) implies ( C132 . B90 ) = ( D60 . ( C132 . ( B90 + 1 ) ) ))) by L426 , L336;
take D69 = C132;
L431: ( dom D61 ) c= ( dom D62 ) by L227 , NAT_1:11;
thus L432: (D69 is_Walk_from C123 , C131 & D69 is_augmenting_wrt C122 & ( D69 .vertices() ) c= ( dom D62 ) & (for B91 being  even Nat holds (B91 in ( dom D69 ) implies ( D69 . B91 ) = ( D60 . ( D69 . ( B91 + 1 ) ) )))) by L431 , L427 , L428 , L429 , L430 , XBOOLE_1:1;
end;
suppose L433: C131 in { ( ( the_Target_of C121 ) . D64 ) };

L434: C131 = ( ( the_Target_of C121 ) . D64 ) by L433 , TARSKI:def 1;
L435:
now
consider C133 being  vertex-distinct (Path of C121) such that L436: C133 is_Walk_from C123 , ( ( the_Source_of C121 ) . D64 ) and L437: C133 is_augmenting_wrt C122 and L438: ( C133 .vertices() ) c= ( dom D61 ) and L439: (for B92 being  even Nat holds (B92 in ( dom C133 ) implies ( C133 . B92 ) = ( D60 . ( C133 . ( B92 + 1 ) ) ))) by L336 , L417;
set D70 = ( C133 .addEdge D64 );
L440: ( C133 .last() ) = ( ( the_Source_of C121 ) . D64 ) by L436 , GLIB_001:def 23;
L441: D64 Joins ( C133 .last() ) , ( ( the_Target_of C121 ) . D64 ) , C121 by L440 , L420 , GLIB_000:def 13;
L442: (not ( ( the_Target_of C121 ) . D64 ) in ( C133 .vertices() )) by L417 , L421 , L438 , L41 , L43;
reconsider D71 = D70 as  vertex-distinct (Walk of C121) by L442 , L441 , GLIB_001:155;
take D72 = D71;
L443: ( C133 .first() ) = C123 by L436 , GLIB_001:def 23;
thus L444: D72 is_Walk_from C123 , C131 by L443 , L434 , L441 , GLIB_001:63;
L445: D64 DJoins ( C133 .last() ) , ( ( the_Target_of C121 ) . D64 ) , C121 by L420 , L440 , GLIB_000:def 14;
thus L446: D72 is_augmenting_wrt C122 by L445 , L422 , L437 , L442 , L82;
L447: ( D72 .vertices() ) = ( ( C133 .vertices() ) \/ { C131 } ) by L434 , L441 , GLIB_001:95;
L448:
now
let C134 being set;
assume L449: C134 in ( D72 .vertices() );
L450:
now
per cases  by L447 , L449 , XBOOLE_0:def 3;
suppose L451: C134 in ( C133 .vertices() );

L452: ( dom D61 ) c= ( dom D62 ) by L227 , NAT_1:11;
L453: C134 in ( dom D61 ) by L438 , L451;
thus L454: C134 in ( dom D62 ) by L453 , L452;
end;
suppose L455: C134 in { C131 };

thus L456: C134 in ( dom D62 ) by L455 , L419 , L434 , XBOOLE_0:def 3;
end;
end;
thus L458: C134 in ( dom D62 ) by L450;
end;
thus L459: ( D72 .vertices() ) c= ( dom D62 ) by L448 , TARSKI:def 3;
let C135 being  even Nat;
assume L460: C135 in ( dom D72 );
L461: C135 <= ( len D72 ) by L460 , FINSEQ_3:25;
L462: 1 <= C135 by L460 , FINSEQ_3:25;
L463:
now
per cases ;
suppose L464: C135 <= ( len C133 );

L465: C135 < ( len C133 ) by L464 , XXREAL_0:1;
L466: ( C135 + 1 ) <= ( len C133 ) by L465 , NAT_1:13;
L467: 1 <= ( 1 + C135 ) by NAT_1:11;
L468: ( C135 + 1 ) in ( dom C133 ) by L467 , L466 , FINSEQ_3:25;
L469: ( D72 . ( C135 + 1 ) ) = ( C133 . ( C135 + 1 ) ) by L468 , L441 , GLIB_001:65;
L470: C135 in ( dom C133 ) by L462 , L464 , FINSEQ_3:25;
L471: ( D72 . C135 ) = ( C133 . C135 ) by L470 , L441 , GLIB_001:65;
thus L472: ( D72 . C135 ) = ( D60 . ( D72 . ( C135 + 1 ) ) ) by L471 , L439 , L470 , L469;
end;
suppose L473: C135 > ( len C133 );

L474: C135 <= ( ( len C133 ) + ( 2 * 1 ) ) by L441 , L461 , GLIB_001:64;
L475: C135 < ( ( ( len C133 ) + 1 ) + 1 ) by L474 , XXREAL_0:1;
L476: C135 <= ( ( len C133 ) + 1 ) by L475 , NAT_1:13;
L477: ( ( len C133 ) + 1 ) <= C135 by L473 , NAT_1:13;
L478: C135 = ( ( len C133 ) + 1 ) by L477 , L476 , XXREAL_0:1;
L479: ( D72 . C135 ) = D64 by L478 , L441 , GLIB_001:65;
L480: ( C135 + 1 ) = ( ( len C133 ) + ( 1 + 1 ) ) by L478;
L481: ( D72 . ( C135 + 1 ) ) = C131 by L480 , L434 , L441 , GLIB_001:65;
L482: C131 in ( dom D62 ) by L419 , L433 , XBOOLE_0:def 3;
L483: ( D62 . C131 ) = D64 by L418 , L434 , L8;
thus L484: ( D72 . C135 ) = ( D60 . ( D72 . ( C135 + 1 ) ) ) by L483 , L479 , L481 , L482 , L283;
end;
end;
thus L486: ( D72 . C135 ) = ( D60 . ( D72 . ( C135 + 1 ) ) ) by L463;
end;
thus L487: (ex B93 being  vertex-distinct (Path of C121) st (B93 is_Walk_from C123 , C131 & B93 is_augmenting_wrt C122 & ( B93 .vertices() ) c= ( dom D62 ) & (for B94 being  even Nat holds (B94 in ( dom B93 ) implies ( B93 . B94 ) = ( D60 . ( B93 . ( B94 + 1 ) ) ))))) by L435;
end;
end;
thus L489: (ex B95 being  vertex-distinct (Path of C121) st (B95 is_Walk_from C123 , C131 & B95 is_augmenting_wrt C122 & ( B95 .vertices() ) c= ( dom D62 ) & (for B96 being  even Nat holds (B96 in ( dom B95 ) implies ( B95 . B96 ) = ( D60 . ( B95 . ( B96 + 1 ) ) ))))) by L425;
end;
thus L490: S9[ ( C125 + 1 ) ] by L423;
end;
end;
thus L492: S9[ ( C125 + 1 ) ] by L338;
end;
L493: (for B97 being Nat holds (S9[ B97 ] implies S9[ ( B97 + 1 ) ])) by L335;
L494:
now
set D73 = ( C121 .walkOf C123 );
let C136 being set;
assume L495: C136 in ( dom ( D59 . ( 0 ) ) );
take D74 = D73;
L496: C136 in { C123 } by L495 , L224;
L497: C136 = C123 by L496 , TARSKI:def 1;
thus L498: D74 is_Walk_from C123 , C136 by L497 , GLIB_001:13;
thus L499: D74 is_augmenting_wrt C122 by L47;
L500: ( D74 .vertices() ) = { C123 } by GLIB_001:90;
thus L501: ( D74 .vertices() ) c= ( dom ( D59 . ( 0 ) ) ) by L500 , L224;
let C137 being  even Nat;
assume L502: C137 in ( dom D74 );
L503: C137 <= ( len D74 ) by L502 , FINSEQ_3:25;
L504: C137 < ( len D74 ) by L503 , XXREAL_0:1;
L505: 1 <= C137 by L502 , FINSEQ_3:25;
thus L506: ( D74 . C137 ) = ( D60 . ( D74 . ( C137 + 1 ) ) ) by L505 , L504 , GLIB_001:13;
end;
L507: S9[ ( 0 ) ] by L494;
L508: (for B98 being Nat holds S9[ B98 ]) from NAT_1:sch 2(L507 , L493);
thus L509:now
assume L510: C124 in ( dom D60 );
consider C138 being  vertex-distinct (Path of C121) such that L511: C138 is_Walk_from C123 , C124 and L512: C138 is_augmenting_wrt C122 and L513: ( C138 .vertices() ) c= ( dom D60 ) and L514: (for B99 being  even Nat holds (B99 in ( dom C138 ) implies ( C138 . B99 ) = ( D60 . ( C138 . ( B99 + 1 ) ) ))) by L510 , L508;
take D75 = C138;
thus L515: (D75 is_Walk_from C123 , C124 & D75 is_augmenting_wrt C122 & (for B100 being  even Nat holds (B100 in ( dom D75 ) implies ( D75 . B100 ) = ( D60 . ( D75 . ( B100 + 1 ) ) )))) by L511 , L512 , L514;
end;
thus L516: thesis;
end;
uniqueness
proof
set D76 = ( AP:FindAugPath (C122 , C123) );
set D77 = ( AP:CompSeq (C122 , C123) );
let C139 , C140 being  vertex-distinct (Path of C121);
defpred S10[ Nat ] means (for B101 being set holds (for B102 , B103 being  vertex-distinct (Path of C121) holds ((B101 in ( dom ( D77 . $1 ) ) & B102 is_Walk_from C123 , B101 & B102 is_augmenting_wrt C122 & B103 is_Walk_from C123 , B101 & B103 is_augmenting_wrt C122 & (for B104 being  even Nat holds (B104 in ( dom B102 ) implies ( B102 . B104 ) = ( D76 . ( B102 . ( B104 + 1 ) ) ))) & (for B105 being  even Nat holds (B105 in ( dom B103 ) implies ( B103 . B105 ) = ( D76 . ( B103 . ( B105 + 1 ) ) )))) implies B102 = B103)));
set D78 = ( D77 . ( 0 ) );
L517:
now
let C141 being Nat;
assume L518: S10[ C141 ];
set D79 = ( D77 . C141 );
set D80 = ( D77 . ( C141 + 1 ) );
set D81 = ( AP:NextBestEdges D79 );
set D82 = ( choose D81 );
L519: D80 = ( AP:Step D79 ) by L184;
L520:
now
per cases ;
suppose L521: D81 = ( {} );

L522: D80 = D79 by L521 , L519 , L137;
thus L523: S10[ ( C141 + 1 ) ] by L522 , L518;
end;
suppose L524: (D81 <> ( {} ) & (not ( ( the_Source_of C121 ) . D82 ) in ( dom D79 )));

L525: C123 in { C123 } by TARSKI:def 1;
L526: C123 in ( dom D78 ) by L525 , L224;
L527: ( dom D78 ) c= ( dom D79 ) by L227;
L528: C123 in ( dom D79 ) by L527 , L526;
L529: (D82 is_forward_edge_wrt D79 or D82 is_backward_edge_wrt D79) by L524 , L119;
L530: ( ( the_Target_of C121 ) . D82 ) in ( dom D79 ) by L529 , L524 , L41 , L43;
L531: D80 = ( D79 +* ( ( ( the_Source_of C121 ) . D82 ) .--> D82 ) ) by L519 , L524 , L137;
L532: ( dom D80 ) = ( ( dom D79 ) \/ { ( ( the_Source_of C121 ) . D82 ) } ) by L531 , L1;
L533:
now
let C142 being set;
let C143 , C144 being  vertex-distinct (Path of C121);
assume that
L534: C142 in ( dom D80 )
and
L535: C143 is_Walk_from C123 , C142
and
L536: C143 is_augmenting_wrt C122
and
L537: C144 is_Walk_from C123 , C142
and
L538: C144 is_augmenting_wrt C122
and
L539: (for B106 being  even Nat holds (B106 in ( dom C143 ) implies ( C143 . B106 ) = ( D76 . ( C143 . ( B106 + 1 ) ) )))
and
L540: (for B107 being  even Nat holds (B107 in ( dom C144 ) implies ( C144 . B107 ) = ( D76 . ( C144 . ( B107 + 1 ) ) )));
L541: ( C143 . ( len C143 ) ) = C142 by L535 , GLIB_001:17;
L542: ( C144 . 1 ) = C123 by L537 , GLIB_001:17;
L543: ( C144 . ( len C144 ) ) = C142 by L537 , GLIB_001:17;
L544: ( C143 . 1 ) = C123 by L535 , GLIB_001:17;
L545:
now
per cases  by L532 , L534 , XBOOLE_0:def 3;
suppose L546: C142 in ( dom D79 );

thus L547: C143 = C144 by L546 , L518 , L535 , L536 , L537 , L538 , L539 , L540;
end;
suppose L548: C142 in { ( ( the_Source_of C121 ) . D82 ) };

L549: C142 = ( ( the_Source_of C121 ) . D82 ) by L548 , TARSKI:def 1;
L550: ( D80 . C142 ) = D82 by L549 , L531 , L8;
L551: ( D76 . C142 ) = D82 by L550 , L534 , L283;
L552: C142 <> C123 by L524 , L528 , L548 , TARSKI:def 1;
L553: ( C143 . 1 ) <> ( C143 .last() ) by L552 , L544 , L541 , GLIB_001:def 7;
L554: ( C143 .first() ) <> ( C143 .last() ) by L553 , GLIB_001:def 6;
L555: C143 is non  trivial by L554 , GLIB_001:127;
L556: 3 <= ( len C143 ) by L555 , GLIB_001:125;
L557: ( C144 . 1 ) <> ( C144 .last() ) by L542 , L543 , L552 , GLIB_001:def 7;
L558: ( C144 .first() ) <> ( C144 .last() ) by L557 , GLIB_001:def 6;
L559: C144 is non  trivial by L558 , GLIB_001:127;
L560: 3 <= ( len C144 ) by L559 , GLIB_001:125;
L561: ( 3 - 2 ) < ( ( len C144 ) - ( 0 ) ) by L560 , XREAL_1:15;
L562: ( 3 - 2 ) < ( ( len C143 ) - ( 0 ) ) by L556 , XREAL_1:15;
reconsider D83 = ( ( len C143 ) - 1 ) , D84 = ( ( len C144 ) - 1 ) as  even (Element of ( NAT )) by L562 , L561 , INT_1:5;
L563: D83 < ( ( len C143 ) - ( 0 ) ) by XREAL_1:15;
L564: ( 3 - 2 ) <= D83 by L556 , XREAL_1:15;
L565: D83 in ( dom C143 ) by L564 , L563 , FINSEQ_3:25;
L566: ( D83 + 1 ) = ( len C143 );
L567: ( C143 . D83 ) = D82 by L566 , L539 , L541 , L565 , L551;
consider C145 being  odd (Element of ( NAT )) such that L568: C145 = ( D83 - 1 ) and L569: ( D83 - 1 ) in ( dom C143 ) and L570: ( D83 + 1 ) in ( dom C143 ) and L571: D82 Joins ( C143 . C145 ) , C142 , C121 by L567 , L541 , L565 , GLIB_001:9;
L572: ( C143 . C145 ) = ( ( the_Target_of C121 ) . D82 ) by L524 , L530 , L549 , L571 , GLIB_000:def 13;
set D85 = ( C143 .cut (( ( 2 * ( 0 ) ) + 1 ) , C145) );
L573: C145 < ( len C143 ) by L563 , L568 , XREAL_1:15;
L574:
now
let C146 being  even Nat;
assume L575: C146 in ( dom D85 );
L576: 1 <= C146 by L575 , FINSEQ_3:25;
L577: C146 <= ( len D85 ) by L575 , FINSEQ_3:25;
L578: C146 < ( len D85 ) by L577 , XXREAL_0:1;
L579: ( C146 + 1 ) <= ( len D85 ) by L578 , NAT_1:13;
L580: 1 <= ( C146 + 1 ) by L575 , NAT_1:13;
L581: ( C146 + 1 ) in ( dom D85 ) by L580 , L579 , FINSEQ_3:25;
L582: ( D85 . ( C146 + 1 ) ) = ( C143 . ( C146 + 1 ) ) by L581 , L573 , GLIB_001:46;
L583: ( len D85 ) = C145 by L573 , GLIB_001:45;
L584: C146 <= ( len C143 ) by L583 , L573 , L577 , XXREAL_0:2;
L585: C146 in ( dom C143 ) by L584 , L576 , FINSEQ_3:25;
L586: ( D85 . C146 ) = ( C143 . C146 ) by L573 , L575 , GLIB_001:46;
thus L587: ( D85 . C146 ) = ( D76 . ( D85 . ( C146 + 1 ) ) ) by L586 , L539 , L582 , L585;
end;
L588: ( C145 + ( 1 + 1 ) ) = ( len C143 ) by L568;
L589: ( C145 + 1 ) = D83 by L568;
L590: ( C143 .cut (C145 , ( len C143 )) ) = ( C121 .walkOf (( ( the_Target_of C121 ) . D82 ) , D82 , C142) ) by L589 , L541 , L567 , L572 , L573 , L588 , GLIB_001:40;
L591: D85 is_augmenting_wrt C122 by L536 , L54;
L592: 1 <= C145 by ABIAN:12;
L593: ( D85 .append ( C143 .cut (C145 , ( len C143 )) ) ) = ( C143 .cut (( ( 2 * ( 0 ) ) + 1 ) , ( len C143 )) ) by L592 , L573 , GLIB_001:38
.= C143 by GLIB_001:39;
L594: D84 < ( ( len C144 ) - ( 0 ) ) by XREAL_1:15;
L595: ( 3 - 2 ) <= D84 by L560 , XREAL_1:15;
L596: D84 in ( dom C144 ) by L595 , L594 , FINSEQ_3:25;
L597: ( D84 + 1 ) = ( len C144 );
L598: ( C144 . D84 ) = D82 by L597 , L540 , L543 , L596 , L551;
consider C147 being  odd (Element of ( NAT )) such that L599: C147 = ( D84 - 1 ) and L600: ( D84 - 1 ) in ( dom C144 ) and L601: ( D84 + 1 ) in ( dom C144 ) and L602: D82 Joins ( C144 . C147 ) , C142 , C121 by L598 , L543 , L596 , GLIB_001:9;
L603: ( C147 + ( 1 + 1 ) ) = ( len C144 ) by L599;
set D86 = ( C144 .cut (( ( 2 * ( 0 ) ) + 1 ) , C147) );
L604: C147 < ( len C144 ) by L594 , L599 , XREAL_1:15;
L605:
now
let C148 being  even Nat;
assume L606: C148 in ( dom D86 );
L607: 1 <= C148 by L606 , FINSEQ_3:25;
L608: C148 <= ( len D86 ) by L606 , FINSEQ_3:25;
L609: C148 < ( len D86 ) by L608 , XXREAL_0:1;
L610: ( C148 + 1 ) <= ( len D86 ) by L609 , NAT_1:13;
L611: 1 <= ( C148 + 1 ) by L606 , NAT_1:13;
L612: ( C148 + 1 ) in ( dom D86 ) by L611 , L610 , FINSEQ_3:25;
L613: ( D86 . ( C148 + 1 ) ) = ( C144 . ( C148 + 1 ) ) by L612 , L604 , GLIB_001:46;
L614: ( len D86 ) = C147 by L604 , GLIB_001:45;
L615: C148 <= ( len C144 ) by L614 , L604 , L608 , XXREAL_0:2;
L616: C148 in ( dom C144 ) by L615 , L607 , FINSEQ_3:25;
L617: ( D86 . C148 ) = ( C144 . C148 ) by L604 , L606 , GLIB_001:46;
thus L618: ( D86 . C148 ) = ( D76 . ( D86 . ( C148 + 1 ) ) ) by L617 , L540 , L613 , L616;
end;
L619: 1 <= C147 by ABIAN:12;
L620: ( D86 .append ( C144 .cut (C147 , ( len C144 )) ) ) = ( C144 .cut (( ( 2 * ( 0 ) ) + 1 ) , ( len C144 )) ) by L619 , L604 , GLIB_001:38
.= C144 by GLIB_001:39;
L621: ( C144 . C147 ) = ( ( the_Target_of C121 ) . D82 ) by L524 , L530 , L549 , L602 , GLIB_000:def 13;
L622: D86 is_Walk_from C123 , ( ( the_Target_of C121 ) . D82 ) by L621 , L542 , L619 , L604 , GLIB_001:37;
L623: ( C147 + 1 ) = D84 by L599;
L624: ( C144 .cut (C147 , ( len C144 )) ) = ( C121 .walkOf (( ( the_Target_of C121 ) . D82 ) , D82 , C142) ) by L623 , L543 , L598 , L621 , L604 , L603 , GLIB_001:40;
L625: D86 is_augmenting_wrt C122 by L538 , L54;
L626: D85 is_Walk_from C123 , ( ( the_Target_of C121 ) . D82 ) by L544 , L572 , L592 , L573 , GLIB_001:37;
thus L627: C143 = C144 by L626 , L518 , L530 , L622 , L591 , L625 , L574 , L605 , L590 , L624 , L593 , L620;
end;
end;
thus L629: C143 = C144 by L545;
end;
thus L630: S10[ ( C141 + 1 ) ] by L533;
end;
suppose L631: (D81 <> ( {} ) & ( ( the_Source_of C121 ) . D82 ) in ( dom D79 ));

L632: C123 in { C123 } by TARSKI:def 1;
L633: C123 in ( dom D78 ) by L632 , L224;
L634: ( dom D78 ) c= ( dom D79 ) by L227;
L635: C123 in ( dom D79 ) by L634 , L633;
L636: (D82 is_forward_edge_wrt D79 or D82 is_backward_edge_wrt D79) by L631 , L119;
L637: (not ( ( the_Target_of C121 ) . D82 ) in ( dom D79 )) by L636 , L631 , L41 , L43;
L638: D80 = ( D79 +* ( ( ( the_Target_of C121 ) . D82 ) .--> D82 ) ) by L519 , L631 , L137;
L639: ( dom D80 ) = ( ( dom D79 ) \/ { ( ( the_Target_of C121 ) . D82 ) } ) by L638 , L1;
L640:
now
let C149 being set;
let C150 , C151 being  vertex-distinct (Path of C121);
assume that
L641: C149 in ( dom D80 )
and
L642: C150 is_Walk_from C123 , C149
and
L643: C150 is_augmenting_wrt C122
and
L644: C151 is_Walk_from C123 , C149
and
L645: C151 is_augmenting_wrt C122
and
L646: (for B108 being  even Nat holds (B108 in ( dom C150 ) implies ( C150 . B108 ) = ( D76 . ( C150 . ( B108 + 1 ) ) )))
and
L647: (for B109 being  even Nat holds (B109 in ( dom C151 ) implies ( C151 . B109 ) = ( D76 . ( C151 . ( B109 + 1 ) ) )));
L648: ( C150 . ( len C150 ) ) = C149 by L642 , GLIB_001:17;
L649: ( C151 . 1 ) = C123 by L644 , GLIB_001:17;
L650: ( C151 . ( len C151 ) ) = C149 by L644 , GLIB_001:17;
L651: ( C150 . 1 ) = C123 by L642 , GLIB_001:17;
L652:
now
per cases  by L639 , L641 , XBOOLE_0:def 3;
suppose L653: C149 in ( dom D79 );

thus L654: C150 = C151 by L653 , L518 , L642 , L643 , L644 , L645 , L646 , L647;
end;
suppose L655: C149 in { ( ( the_Target_of C121 ) . D82 ) };

L656: C149 = ( ( the_Target_of C121 ) . D82 ) by L655 , TARSKI:def 1;
L657: ( D80 . C149 ) = D82 by L656 , L638 , L8;
L658: ( D76 . C149 ) = D82 by L657 , L641 , L283;
L659: C149 <> C123 by L637 , L635 , L655 , TARSKI:def 1;
L660: ( C150 . 1 ) <> ( C150 .last() ) by L659 , L651 , L648 , GLIB_001:def 7;
L661: ( C150 .first() ) <> ( C150 .last() ) by L660 , GLIB_001:def 6;
L662: C150 is non  trivial by L661 , GLIB_001:127;
L663: 3 <= ( len C150 ) by L662 , GLIB_001:125;
L664: ( C151 . 1 ) <> ( C151 .last() ) by L649 , L650 , L659 , GLIB_001:def 7;
L665: ( C151 .first() ) <> ( C151 .last() ) by L664 , GLIB_001:def 6;
L666: C151 is non  trivial by L665 , GLIB_001:127;
L667: 3 <= ( len C151 ) by L666 , GLIB_001:125;
L668: ( 3 - 2 ) < ( ( len C151 ) - ( 0 ) ) by L667 , XREAL_1:15;
L669: ( 3 - 2 ) < ( ( len C150 ) - ( 0 ) ) by L663 , XREAL_1:15;
reconsider D87 = ( ( len C150 ) - 1 ) , D88 = ( ( len C151 ) - 1 ) as  even (Element of ( NAT )) by L669 , L668 , INT_1:5;
L670: D87 < ( ( len C150 ) - ( 0 ) ) by XREAL_1:15;
L671: ( 3 - 2 ) <= D87 by L663 , XREAL_1:15;
L672: D87 in ( dom C150 ) by L671 , L670 , FINSEQ_3:25;
L673: ( D87 + 1 ) = ( len C150 );
L674: ( C150 . D87 ) = D82 by L673 , L646 , L648 , L672 , L658;
consider C152 being  odd (Element of ( NAT )) such that L675: C152 = ( D87 - 1 ) and L676: ( D87 - 1 ) in ( dom C150 ) and L677: ( D87 + 1 ) in ( dom C150 ) and L678: D82 Joins ( C150 . C152 ) , C149 , C121 by L674 , L648 , L672 , GLIB_001:9;
L679: ( C150 . C152 ) = ( ( the_Source_of C121 ) . D82 ) by L631 , L637 , L656 , L678 , GLIB_000:def 13;
set D89 = ( C150 .cut (( ( 2 * ( 0 ) ) + 1 ) , C152) );
L680: C152 < ( len C150 ) by L670 , L675 , XREAL_1:15;
L681:
now
let C153 being  even Nat;
assume L682: C153 in ( dom D89 );
L683: 1 <= C153 by L682 , FINSEQ_3:25;
L684: C153 <= ( len D89 ) by L682 , FINSEQ_3:25;
L685: C153 < ( len D89 ) by L684 , XXREAL_0:1;
L686: ( C153 + 1 ) <= ( len D89 ) by L685 , NAT_1:13;
L687: 1 <= ( C153 + 1 ) by L682 , NAT_1:13;
L688: ( C153 + 1 ) in ( dom D89 ) by L687 , L686 , FINSEQ_3:25;
L689: ( D89 . ( C153 + 1 ) ) = ( C150 . ( C153 + 1 ) ) by L688 , L680 , GLIB_001:46;
L690: ( len D89 ) = C152 by L680 , GLIB_001:45;
L691: C153 <= ( len C150 ) by L690 , L680 , L684 , XXREAL_0:2;
L692: C153 in ( dom C150 ) by L691 , L683 , FINSEQ_3:25;
L693: ( D89 . C153 ) = ( C150 . C153 ) by L680 , L682 , GLIB_001:46;
thus L694: ( D89 . C153 ) = ( D76 . ( D89 . ( C153 + 1 ) ) ) by L693 , L646 , L689 , L692;
end;
L695: ( C152 + ( 1 + 1 ) ) = ( len C150 ) by L675;
L696: ( C152 + 1 ) = D87 by L675;
L697: ( C150 .cut (C152 , ( len C150 )) ) = ( C121 .walkOf (( ( the_Source_of C121 ) . D82 ) , D82 , C149) ) by L696 , L648 , L674 , L679 , L680 , L695 , GLIB_001:40;
L698: D89 is_augmenting_wrt C122 by L643 , L54;
L699: 1 <= C152 by ABIAN:12;
L700: ( D89 .append ( C150 .cut (C152 , ( len C150 )) ) ) = ( C150 .cut (( ( 2 * ( 0 ) ) + 1 ) , ( len C150 )) ) by L699 , L680 , GLIB_001:38
.= C150 by GLIB_001:39;
L701: D88 < ( ( len C151 ) - ( 0 ) ) by XREAL_1:15;
L702: ( 3 - 2 ) <= D88 by L667 , XREAL_1:15;
L703: D88 in ( dom C151 ) by L702 , L701 , FINSEQ_3:25;
L704: ( D88 + 1 ) = ( len C151 );
L705: ( C151 . D88 ) = D82 by L704 , L647 , L650 , L703 , L658;
consider C154 being  odd (Element of ( NAT )) such that L706: C154 = ( D88 - 1 ) and L707: ( D88 - 1 ) in ( dom C151 ) and L708: ( D88 + 1 ) in ( dom C151 ) and L709: D82 Joins ( C151 . C154 ) , C149 , C121 by L705 , L650 , L703 , GLIB_001:9;
L710: ( C154 + ( 1 + 1 ) ) = ( len C151 ) by L706;
set D90 = ( C151 .cut (( ( 2 * ( 0 ) ) + 1 ) , C154) );
L711: C154 < ( len C151 ) by L701 , L706 , XREAL_1:15;
L712:
now
let C155 being  even Nat;
assume L713: C155 in ( dom D90 );
L714: 1 <= C155 by L713 , FINSEQ_3:25;
L715: C155 <= ( len D90 ) by L713 , FINSEQ_3:25;
L716: C155 < ( len D90 ) by L715 , XXREAL_0:1;
L717: ( C155 + 1 ) <= ( len D90 ) by L716 , NAT_1:13;
L718: 1 <= ( C155 + 1 ) by L713 , NAT_1:13;
L719: ( C155 + 1 ) in ( dom D90 ) by L718 , L717 , FINSEQ_3:25;
L720: ( D90 . ( C155 + 1 ) ) = ( C151 . ( C155 + 1 ) ) by L719 , L711 , GLIB_001:46;
L721: ( len D90 ) = C154 by L711 , GLIB_001:45;
L722: C155 <= ( len C151 ) by L721 , L711 , L715 , XXREAL_0:2;
L723: C155 in ( dom C151 ) by L722 , L714 , FINSEQ_3:25;
L724: ( D90 . C155 ) = ( C151 . C155 ) by L711 , L713 , GLIB_001:46;
thus L725: ( D90 . C155 ) = ( D76 . ( D90 . ( C155 + 1 ) ) ) by L724 , L647 , L720 , L723;
end;
L726: 1 <= C154 by ABIAN:12;
L727: ( D90 .append ( C151 .cut (C154 , ( len C151 )) ) ) = ( C151 .cut (( ( 2 * ( 0 ) ) + 1 ) , ( len C151 )) ) by L726 , L711 , GLIB_001:38
.= C151 by GLIB_001:39;
L728: ( C151 . C154 ) = ( ( the_Source_of C121 ) . D82 ) by L631 , L637 , L656 , L709 , GLIB_000:def 13;
L729: D90 is_Walk_from C123 , ( ( the_Source_of C121 ) . D82 ) by L728 , L649 , L726 , L711 , GLIB_001:37;
L730: ( C154 + 1 ) = D88 by L706;
L731: ( C151 .cut (C154 , ( len C151 )) ) = ( C121 .walkOf (( ( the_Source_of C121 ) . D82 ) , D82 , C149) ) by L730 , L650 , L705 , L728 , L711 , L710 , GLIB_001:40;
L732: D90 is_augmenting_wrt C122 by L645 , L54;
L733: D89 is_Walk_from C123 , ( ( the_Source_of C121 ) . D82 ) by L651 , L679 , L699 , L680 , GLIB_001:37;
thus L734: C150 = C151 by L733 , L518 , L631 , L729 , L698 , L732 , L681 , L712 , L697 , L731 , L700 , L727;
end;
end;
thus L736: C150 = C151 by L652;
end;
thus L737: S10[ ( C141 + 1 ) ] by L640;
end;
end;
thus L739: S10[ ( C141 + 1 ) ] by L520;
end;
L740: (for B110 being Nat holds (S10[ B110 ] implies S10[ ( B110 + 1 ) ])) by L517;
L741:
now
let C156 being set;
let C157 , C158 being  vertex-distinct (Path of C121);
assume that
L742: C156 in ( dom D78 )
and
L743: C157 is_Walk_from C123 , C156
and
L744: C157 is_augmenting_wrt C122
and
L745: C158 is_Walk_from C123 , C156
and
L746: C158 is_augmenting_wrt C122
and
L747: (for B111 being  even Nat holds (B111 in ( dom C157 ) implies ( C157 . B111 ) = ( D76 . ( C157 . ( B111 + 1 ) ) )))
and
L748: (for B112 being  even Nat holds (B112 in ( dom C158 ) implies ( C158 . B112 ) = ( D76 . ( C158 . ( B112 + 1 ) ) )));
L749: C156 in { C123 } by L742 , L224;
L750: C156 = C123 by L749 , TARSKI:def 1;
L751: ( C157 . ( ( 2 * ( 0 ) ) + 1 ) ) = C156 by L750 , L743 , GLIB_001:17;
L752: ( C158 . ( ( 2 * ( 0 ) ) + 1 ) ) = C156 by L745 , L750 , GLIB_001:17;
L753: 1 <= ( len C157 ) by ABIAN:12;
L754: ( C157 . ( len C157 ) ) = C156 by L743 , GLIB_001:17;
L755: ( len C157 ) = 1 by L754 , L751 , L753 , GLIB_001:def 29;
L756: C157 = <* C156 *> by L755 , L751 , FINSEQ_1:40;
L757: 1 <= ( len C158 ) by ABIAN:12;
L758: ( C158 . ( len C158 ) ) = C156 by L745 , GLIB_001:17;
L759: ( len C158 ) = 1 by L758 , L752 , L757 , GLIB_001:def 29;
thus L760: C157 = C158 by L759 , L752 , L756 , FINSEQ_1:40;
end;
L761: S10[ ( 0 ) ] by L741;
L762: (for B113 being Nat holds S10[ B113 ]) from NAT_1:sch 2(L761 , L740);
thus L763: ((C124 in ( dom D76 ) & C139 is_Walk_from C123 , C124 & C139 is_augmenting_wrt C122 & (for B114 being  even Nat holds (B114 in ( dom C139 ) implies ( C139 . B114 ) = ( ( AP:FindAugPath (C122 , C123) ) . ( C139 . ( B114 + 1 ) ) ))) & C140 is_Walk_from C123 , C124 & C140 is_augmenting_wrt C122 & (for B115 being  even Nat holds (B115 in ( dom C140 ) implies ( C140 . B115 ) = ( ( AP:FindAugPath (C122 , C123) ) . ( C140 . ( B115 + 1 ) ) )))) implies C139 = C140) by L762;
thus L764: thesis;
end;
consistency;
end;
theorem
L766: (for B116 being  real-weighted WGraph holds (for B117 being (FF:ELabeling of B116) holds (for B118 being (Vertex of B116) holds (for B119 being Nat holds (for B120 being set holds (B120 in ( dom ( ( AP:CompSeq (B117 , B118) ) . B119 ) ) implies (ex B121 being (Path of B116) st (B121 is_augmenting_wrt B117 & B121 is_Walk_from B118 , B120 & ( B121 .vertices() ) c= ( dom ( ( AP:CompSeq (B117 , B118) ) . B119 ) )))))))))
proof
let C159 being  real-weighted WGraph;
let C160 being (FF:ELabeling of C159);
let C161 being (Vertex of C159);
set D91 = ( AP:CompSeq (C160 , C161) );
set D92 = ( D91 . ( 0 ) );
defpred S11[ Nat ] means (for B122 being set holds (B122 in ( dom ( D91 . $1 ) ) implies (ex B123 being (Path of C159) st (B123 is_augmenting_wrt C160 & B123 is_Walk_from C161 , B122 & ( B123 .vertices() ) c= ( dom ( D91 . $1 ) )))));
L767:
now
let C162 being Nat;
set D93 = ( D91 . C162 );
set D94 = ( D91 . ( C162 + 1 ) );
set D95 = ( AP:NextBestEdges D93 );
set D96 = ( choose D95 );
assume L768: S11[ C162 ];
L769: D94 = ( AP:Step D93 ) by L184;
L770:
now
per cases ;
suppose L771: D95 = ( {} );

L772: D94 = D93 by L771 , L769 , L137;
thus L773: S11[ ( C162 + 1 ) ] by L772 , L768;
end;
suppose L774: D95 <> ( {} );

set D97 = ( ( the_Source_of C159 ) . D96 );
set D98 = ( ( the_Target_of C159 ) . D96 );
L775:
now
per cases  by L774 , L119;
suppose L776: D96 is_forward_edge_wrt D93;

L777: ( C160 . D96 ) < ( ( the_Weight_of C159 ) . D96 ) by L776 , L41;
let C163 being set;
assume L778: C163 in ( dom D94 );
L779: D96 in ( the_Edges_of C159 ) by L776 , L41;
L780: D96 DJoins D97 , D98 , C159 by L779 , GLIB_000:def 14;
L781: D97 in ( dom D93 ) by L776 , L41;
L782: D94 = ( D93 +* ( D98 .--> D96 ) ) by L781 , L769 , L774 , L137;
L783: ( dom D94 ) = ( ( dom D93 ) \/ { D98 } ) by L782 , L1;
L784: D98 in { D98 } by TARSKI:def 1;
L785: D98 in ( dom D94 ) by L784 , L783 , XBOOLE_0:def 3;
L786: ( dom D93 ) c= ( dom D94 ) by L783 , XBOOLE_1:7;
L787: D97 in ( dom D94 ) by L786 , L781;
L788:
now
per cases  by L783 , L778 , XBOOLE_0:def 3;
suppose L789: C163 in ( dom D93 );

consider C164 being (Path of C159) such that L790: C164 is_augmenting_wrt C160 and L791: C164 is_Walk_from C161 , C163 and L792: ( C164 .vertices() ) c= ( dom D93 ) by L789 , L768;
take D99 = C164;
thus L793: (D99 is_augmenting_wrt C160 & D99 is_Walk_from C161 , C163 & ( D99 .vertices() ) c= ( dom D94 )) by L786 , L790 , L791 , L792 , XBOOLE_1:1;
end;
suppose L794: C163 in { D98 };

L795: C163 = D98 by L794 , TARSKI:def 1;
L796:
now
per cases ;
suppose L797: D97 = C161;

set D100 = ( C159 .walkOf (D97 , D96 , D98) );
take D101 = D100;
L798: D96 Joins D97 , D98 , C159 by L779 , GLIB_000:def 13;
L799:
now
let C165 being  odd Nat;
assume L800: C165 < ( len D101 );
L801: C165 < ( 2 + 1 ) by L800 , L798 , GLIB_001:14;
L802: C165 <= ( 2 * 1 ) by L801 , NAT_1:13;
L803: C165 < ( 1 + 1 ) by L802 , XXREAL_0:1;
L804: C165 <= 1 by L803 , NAT_1:13;
L805: 1 <= C165 by ABIAN:12;
L806: C165 = 1 by L805 , L804 , XXREAL_0:1;
L807: D101 = <* D97 , D96 , D98 *> by L798 , GLIB_001:def 5;
L808: ( D101 . C165 ) = D97 by L807 , L806 , FINSEQ_1:45;
L809: ( D101 . ( C165 + 2 ) ) = D98 by L806 , L807 , FINSEQ_1:45;
L810: ( D101 . ( C165 + 1 ) ) = D96 by L806 , L807 , FINSEQ_1:45;
thus L811: (( D101 . ( C165 + 1 ) ) DJoins ( D101 . C165 ) , ( D101 . ( C165 + 2 ) ) , C159 implies ( C160 . ( D101 . ( C165 + 1 ) ) ) < ( ( the_Weight_of C159 ) . ( D101 . ( C165 + 1 ) ) )) by L810 , L776 , L41;
assume L812: (not ( D101 . ( C165 + 1 ) ) DJoins ( D101 . C165 ) , ( D101 . ( C165 + 2 ) ) , C159);
thus L813: ( 0 ) < ( C160 . ( D101 . ( C165 + 1 ) ) ) by L812 , L779 , L808 , L810 , L809 , GLIB_000:def 14;
end;
thus L814: D101 is_augmenting_wrt C160 by L799 , L45;
thus L815: D101 is_Walk_from C161 , C163 by L795 , L797 , L798 , GLIB_001:15;
L816:
now
let C166 being set;
assume L817: C166 in ( D101 .vertices() );
L818: C166 in { D97 , D98 } by L817 , L798 , GLIB_001:91;
thus L819: C166 in ( dom D94 ) by L818 , L785 , L787 , TARSKI:def 2;
end;
thus L820: ( D101 .vertices() ) c= ( dom D94 ) by L816 , TARSKI:def 3;
end;
suppose L821: D97 <> C161;

L822: D96 Joins D97 , C163 , C159 by L779 , L795 , GLIB_000:def 13;
consider C167 being (Path of C159) such that L823: C167 is_augmenting_wrt C160 and L824: C167 is_Walk_from C161 , D97 and L825: ( C167 .vertices() ) c= ( dom D93 ) by L768 , L781;
set D102 = ( C167 .addEdge D96 );
L826: (not C163 in ( C167 .vertices() )) by L776 , L795 , L825 , L41;
L827: D97 = ( C167 .last() ) by L824 , GLIB_001:def 23;
L828: ( C167 .first() ) <> ( C167 .last() ) by L827 , L821 , L824 , GLIB_001:def 23;
L829: C167 is  open by L828 , GLIB_001:def 24;
reconsider D103 = D102 as (Path of C159) by L829 , L822 , L827 , L826 , GLIB_001:151;
take D104 = D103;
thus L830: D104 is_augmenting_wrt C160 by L777 , L780 , L795 , L823 , L827 , L826 , L82;
thus L831: D104 is_Walk_from C161 , C163 by L824 , L822 , GLIB_001:66;
L832:
now
let C168 being set;
assume L833: C168 in ( D104 .vertices() );
L834: C168 in ( ( C167 .vertices() ) \/ { D98 } ) by L833 , L795 , L822 , L827 , GLIB_001:95;
L835:
now
per cases  by L834 , XBOOLE_0:def 3;
suppose L836: C168 in ( C167 .vertices() );

L837: C168 in ( dom D93 ) by L836 , L825;
thus L838: C168 in ( dom D94 ) by L837 , L786;
end;
suppose L839: C168 in { D98 };

thus L840: C168 in ( dom D94 ) by L839 , L783 , XBOOLE_0:def 3;
end;
end;
thus L842: C168 in ( dom D94 ) by L835;
end;
thus L843: ( D104 .vertices() ) c= ( dom D94 ) by L832 , TARSKI:def 3;
end;
end;
thus L845: (ex B124 being (Path of C159) st (B124 is_augmenting_wrt C160 & B124 is_Walk_from C161 , C163 & ( B124 .vertices() ) c= ( dom D94 ))) by L796;
end;
end;
thus L847: (ex B125 being (Path of C159) st (B125 is_augmenting_wrt C160 & B125 is_Walk_from C161 , C163 & ( B125 .vertices() ) c= ( dom D94 ))) by L788;
end;
suppose L848: D96 is_backward_edge_wrt D93;

L849: ( 0 ) < ( C160 . D96 ) by L848 , L43;
let C169 being set;
assume L850: C169 in ( dom D94 );
L851: D96 in ( the_Edges_of C159 ) by L848 , L43;
L852: D96 DJoins D97 , D98 , C159 by L851 , GLIB_000:def 14;
L853: (not D97 in ( dom D93 )) by L848 , L43;
L854: D94 = ( D93 +* ( D97 .--> D96 ) ) by L853 , L769 , L774 , L137;
L855: ( dom D94 ) = ( ( dom D93 ) \/ { D97 } ) by L854 , L1;
L856: D97 in { D97 } by TARSKI:def 1;
L857: D97 in ( dom D94 ) by L856 , L855 , XBOOLE_0:def 3;
L858: D98 in ( dom D93 ) by L848 , L43;
L859: ( dom D93 ) c= ( dom D94 ) by L855 , XBOOLE_1:7;
L860: D98 in ( dom D94 ) by L859 , L858;
L861:
now
per cases  by L855 , L850 , XBOOLE_0:def 3;
suppose L862: C169 in ( dom D93 );

consider C170 being (Path of C159) such that L863: C170 is_augmenting_wrt C160 and L864: C170 is_Walk_from C161 , C169 and L865: ( C170 .vertices() ) c= ( dom D93 ) by L862 , L768;
take D105 = C170;
thus L866: (D105 is_augmenting_wrt C160 & D105 is_Walk_from C161 , C169 & ( D105 .vertices() ) c= ( dom D94 )) by L859 , L863 , L864 , L865 , XBOOLE_1:1;
end;
suppose L867: C169 in { D97 };

L868: C169 = D97 by L867 , TARSKI:def 1;
L869:
now
per cases ;
suppose L870: D98 = C161;

set D106 = ( C159 .walkOf (D98 , D96 , D97) );
take D107 = D106;
L871: D96 Joins D98 , D97 , C159 by L851 , GLIB_000:def 13;
L872:
now
let C171 being  odd Nat;
assume L873: C171 < ( len D107 );
L874: C171 < ( 2 + 1 ) by L873 , L871 , GLIB_001:14;
L875: C171 <= ( 2 * 1 ) by L874 , NAT_1:13;
L876: C171 < ( 1 + 1 ) by L875 , XXREAL_0:1;
L877: C171 <= 1 by L876 , NAT_1:13;
L878: 1 <= C171 by ABIAN:12;
L879: C171 = 1 by L878 , L877 , XXREAL_0:1;
L880: D107 = <* D98 , D96 , D97 *> by L871 , GLIB_001:def 5;
L881: ( D107 . ( C171 + 1 ) ) = D96 by L880 , L879 , FINSEQ_1:45;
L882: ( D107 . C171 ) = D98 by L879 , L880 , FINSEQ_1:45;
thus L883: (( D107 . ( C171 + 1 ) ) DJoins ( D107 . C171 ) , ( D107 . ( C171 + 2 ) ) , C159 implies ( C160 . ( D107 . ( C171 + 1 ) ) ) < ( ( the_Weight_of C159 ) . ( D107 . ( C171 + 1 ) ) )) by L882 , L858 , L853 , L881 , GLIB_000:def 14;
assume L884: (not ( D107 . ( C171 + 1 ) ) DJoins ( D107 . C171 ) , ( D107 . ( C171 + 2 ) ) , C159);
thus L885: ( 0 ) < ( C160 . ( D107 . ( C171 + 1 ) ) ) by L848 , L881 , L43;
end;
thus L886: D107 is_augmenting_wrt C160 by L872 , L45;
thus L887: D107 is_Walk_from C161 , C169 by L868 , L870 , L871 , GLIB_001:15;
L888:
now
let C172 being set;
assume L889: C172 in ( D107 .vertices() );
L890: C172 in { D97 , D98 } by L889 , L871 , GLIB_001:91;
thus L891: C172 in ( dom D94 ) by L890 , L857 , L860 , TARSKI:def 2;
end;
thus L892: ( D107 .vertices() ) c= ( dom D94 ) by L888 , TARSKI:def 3;
end;
suppose L893: D98 <> C161;

L894: D96 Joins D98 , C169 , C159 by L851 , L868 , GLIB_000:def 13;
consider C173 being (Path of C159) such that L895: C173 is_augmenting_wrt C160 and L896: C173 is_Walk_from C161 , D98 and L897: ( C173 .vertices() ) c= ( dom D93 ) by L768 , L858;
set D108 = ( C173 .addEdge D96 );
L898: (not C169 in ( C173 .vertices() )) by L848 , L868 , L897 , L43;
L899: D98 = ( C173 .last() ) by L896 , GLIB_001:def 23;
L900: ( C173 .first() ) <> ( C173 .last() ) by L899 , L893 , L896 , GLIB_001:def 23;
L901: C173 is  open by L900 , GLIB_001:def 24;
reconsider D109 = D108 as (Path of C159) by L901 , L894 , L899 , L898 , GLIB_001:151;
take D110 = D109;
thus L902: D110 is_augmenting_wrt C160 by L849 , L852 , L868 , L895 , L899 , L898 , L82;
thus L903: D110 is_Walk_from C161 , C169 by L896 , L894 , GLIB_001:66;
L904:
now
let C174 being set;
assume L905: C174 in ( D110 .vertices() );
L906: C174 in ( ( C173 .vertices() ) \/ { D97 } ) by L905 , L868 , L894 , L899 , GLIB_001:95;
L907:
now
per cases  by L906 , XBOOLE_0:def 3;
suppose L908: C174 in ( C173 .vertices() );

L909: C174 in ( dom D93 ) by L908 , L897;
thus L910: C174 in ( dom D94 ) by L909 , L859;
end;
suppose L911: C174 in { D97 };

thus L912: C174 in ( dom D94 ) by L911 , L855 , XBOOLE_0:def 3;
end;
end;
thus L914: C174 in ( dom D94 ) by L907;
end;
thus L915: ( D110 .vertices() ) c= ( dom D94 ) by L904 , TARSKI:def 3;
end;
end;
thus L917: (ex B126 being (Path of C159) st (B126 is_augmenting_wrt C160 & B126 is_Walk_from C161 , C169 & ( B126 .vertices() ) c= ( dom D94 ))) by L869;
end;
end;
thus L919: (ex B127 being (Path of C159) st (B127 is_augmenting_wrt C160 & B127 is_Walk_from C161 , C169 & ( B127 .vertices() ) c= ( dom D94 ))) by L861;
end;
end;
thus L921: S11[ ( C162 + 1 ) ] by L775;
end;
end;
thus L923: S11[ ( C162 + 1 ) ] by L770;
end;
L924:
now
let C175 being set;
assume L925: C175 in ( dom D92 );
reconsider D111 = C175 as (Vertex of C159) by L925;
set D112 = ( C159 .walkOf D111 );
take D113 = D112;
thus L926: D113 is_augmenting_wrt C160 by L47;
L927: C175 in { C161 } by L925 , L224;
L928: C175 = C161 by L927 , TARSKI:def 1;
thus L929: D113 is_Walk_from C161 , C175 by L928 , GLIB_001:13;
L930: ( D113 .vertices() ) = { D111 } by GLIB_001:90;
thus L931: ( D113 .vertices() ) c= ( dom D92 ) by L930 , L925 , ZFMISC_1:31;
end;
L932: S11[ ( 0 ) ] by L924;
L933: (for B128 being Nat holds S11[ B128 ]) from NAT_1:sch 2(L932 , L767);
thus L934: thesis by L933;
end;
theorem
L935: (for B129 being  finite  real-weighted WGraph holds (for B130 being (FF:ELabeling of B129) holds (for B131 being (Vertex of B129) holds (for B132 being set holds (B132 in ( dom ( AP:FindAugPath (B130 , B131) ) ) iff (ex B133 being (Path of B129) st (B133 is_Walk_from B131 , B132 & B133 is_augmenting_wrt B130)))))))
proof
let C176 being  finite  real-weighted WGraph;
let C177 being (FF:ELabeling of C176);
let C178 being (Vertex of C176);
let C179 being set;
set D114 = ( AP:CompSeq (C177 , C178) );
set D115 = ( dom ( AP:FindAugPath (C177 , C178) ) );
thus L936:now
assume L937: C179 in D115;
L938: (ex B134 being (Path of C176) st (B134 is_augmenting_wrt C177 & B134 is_Walk_from C178 , C179 & ( B134 .vertices() ) c= D115)) by L937 , L766;
thus L939: (ex B135 being (Path of C176) st (B135 is_Walk_from C178 , C179 & B135 is_augmenting_wrt C177)) by L938;
end;
given C180 being (Path of C176) such that
L940: C180 is_Walk_from C178 , C179
and
L941: C180 is_augmenting_wrt C177;

L942:
now
L943: ( C180 . ( ( 2 * ( 0 ) ) + 1 ) ) = C178 by L940 , GLIB_001:17;
L944: ( C180 . ( ( 2 * ( 0 ) ) + 1 ) ) in { C178 } by L943 , TARSKI:def 1;
L945: ( C180 . ( ( 2 * ( 0 ) ) + 1 ) ) in ( dom ( D114 . ( 0 ) ) ) by L944 , L224;
set D116 = ( D114 . ( D114 .Lifespan() ) );
set D117 = ( D114 . ( ( D114 .Lifespan() ) + 1 ) );
defpred S12[ Nat ] means ($1 is  odd & $1 <= ( len C180 ) & (not ( C180 . $1 ) in D115));
assume L946: (not C179 in D115);
L947: ( C180 . ( len C180 ) ) = C179 by L940 , GLIB_001:17;
L948: (ex B136 being Nat st S12[ B136 ]) by L947 , L946;
consider C181 being Nat such that L949: (S12[ C181 ] & (for B137 being Nat holds (S12[ B137 ] implies C181 <= B137))) from NAT_1:sch 5(L948);
reconsider D118 = C181 as  odd (Element of ( NAT )) by L949 , ORDINAL1:def 12;
L950: 1 <= C181 by L949 , ABIAN:12;
L951: ( dom ( D114 . ( 0 ) ) ) c= D115 by L227;
L952: C181 <> 1 by L951 , L949 , L945;
L953: 1 < C181 by L952 , L950 , XXREAL_0:1;
L954: ( 1 + 1 ) <= C181 by L953 , NAT_1:13;
reconsider D119 = ( D118 - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by L954 , INT_1:5;
L955: D119 < ( C181 - ( 0 ) ) by XREAL_1:15;
L956: D119 < ( len C180 ) by L955 , L949 , XXREAL_0:2;
L957: ( C180 . D119 ) in D115 by L956 , L949 , L955;
set D120 = ( AP:NextBestEdges D116 );
set D121 = ( choose D120 );
L958: ( AP:CompSeq (C177 , C178) ) is  halting by L254;
L959: D116 = ( D114 . ( ( D114 .Lifespan() ) + 1 ) ) by L958 , GLIB_000:def 55;
set D122 = ( C180 . ( D119 + 1 ) );
L960: ( C180 . ( D119 + 2 ) ) = ( C180 . C181 );
L961: D122 Joins ( C180 . D119 ) , ( C180 . C181 ) , C176 by L960 , L956 , GLIB_001:def 3;
L962:
now
per cases ;
suppose L963: D122 DJoins ( C180 . D119 ) , ( C180 . C181 ) , C176;

L964: ( ( the_Source_of C176 ) . D122 ) in ( dom D116 ) by L963 , L957 , GLIB_000:def 14;
L965: D122 in ( the_Edges_of C176 ) by L963 , GLIB_000:def 14;
L966: (not ( ( the_Target_of C176 ) . D122 ) in ( dom D116 )) by L949 , L963 , GLIB_000:def 14;
L967: ( C177 . D122 ) < ( ( the_Weight_of C176 ) . D122 ) by L941 , L956 , L960 , L963 , L45;
L968: D122 is_forward_edge_wrt D116 by L967 , L965 , L964 , L966 , L41;
thus L969: D120 <> ( {} ) by L968 , L119;
end;
suppose L970: (not D122 DJoins ( C180 . D119 ) , ( C180 . C181 ) , C176);

L971: D122 DJoins ( C180 . C181 ) , ( C180 . D119 ) , C176 by L970 , L961 , GLIB_000:16;
L972: D122 in ( the_Edges_of C176 ) by L971 , GLIB_000:def 14;
L973: ( ( the_Target_of C176 ) . D122 ) in ( dom D116 ) by L957 , L971 , GLIB_000:def 14;
L974: (not ( ( the_Source_of C176 ) . D122 ) in ( dom D116 )) by L949 , L971 , GLIB_000:def 14;
L975: ( 0 ) < ( C177 . D122 ) by L941 , L956 , L960 , L970 , L45;
L976: D122 is_backward_edge_wrt D116 by L975 , L972 , L974 , L973 , L43;
thus L977: D120 <> ( {} ) by L976 , L119;
end;
end;
L979: D117 = ( AP:Step D116 ) by L184;
L980:
now
per cases ;
suppose L981: (not ( ( the_Source_of C176 ) . D121 ) in ( dom D116 ));

L982: D116 = ( D116 +* ( ( ( the_Source_of C176 ) . D121 ) .--> D121 ) ) by L981 , L979 , L959 , L962 , L137;
L983: ( dom D116 ) = ( ( dom D116 ) \/ { ( ( the_Source_of C176 ) . D121 ) } ) by L982 , L1;
L984: ( ( the_Source_of C176 ) . D121 ) in { ( ( the_Source_of C176 ) . D121 ) } by TARSKI:def 1;
thus L985: contradiction by L984 , L981 , L983 , XBOOLE_0:def 3;
end;
suppose L986: ( ( the_Source_of C176 ) . D121 ) in ( dom D116 );

L987: (D121 is_forward_edge_wrt D116 or D121 is_backward_edge_wrt D116) by L962 , L119;
L988: (not ( ( the_Target_of C176 ) . D121 ) in ( dom D116 )) by L987 , L986 , L41 , L43;
L989: D116 = ( D116 +* ( ( ( the_Target_of C176 ) . D121 ) .--> D121 ) ) by L979 , L959 , L962 , L986 , L137;
L990: ( dom D116 ) = ( ( dom D116 ) \/ { ( ( the_Target_of C176 ) . D121 ) } ) by L989 , L1;
L991: ( ( the_Target_of C176 ) . D121 ) in { ( ( the_Target_of C176 ) . D121 ) } by TARSKI:def 1;
thus L992: contradiction by L991 , L988 , L990 , XBOOLE_0:def 3;
end;
end;
thus L994: contradiction by L980;
end;
thus L995: thesis by L942;
end;
theorem
L996: (for B138 being  finite  real-weighted WGraph holds (for B139 being (FF:ELabeling of B138) holds (for B140 being (Vertex of B138) holds B140 in ( dom ( AP:FindAugPath (B139 , B140) ) ))))
proof
let C182 being  finite  real-weighted WGraph;
let C183 being (FF:ELabeling of C182);
let C184 being (Vertex of C182);
set D123 = ( AP:CompSeq (C183 , C184) );
L997: ( dom ( D123 . ( 0 ) ) ) = { C184 } by L224;
L998: C184 in ( dom ( D123 . ( 0 ) ) ) by L997 , TARSKI:def 1;
L999: ( dom ( D123 . ( 0 ) ) ) c= ( dom ( AP:FindAugPath (C183 , C184) ) ) by L227;
thus L1000: thesis by L999 , L998;
end;
begin
definition
let C185 being  natural-weighted WGraph;
let C186 being (FF:ELabeling of C185);
let C187 being (Walk of C185);
assume L1001: C187 is_augmenting_wrt C186;
defpred S13[ Nat , set ] means ((( C187 . ( 2 * $1 ) ) DJoins ( C187 . ( ( 2 * $1 ) - 1 ) ) , ( C187 . ( ( 2 * $1 ) + 1 ) ) , C185 implies $2 = ( ( ( the_Weight_of C185 ) . ( C187 . ( 2 * $1 ) ) ) - ( C186 . ( C187 . ( 2 * $1 ) ) ) )) & ((not ( C187 . ( 2 * $1 ) ) DJoins ( C187 . ( ( 2 * $1 ) - 1 ) ) , ( C187 . ( ( 2 * $1 ) + 1 ) ) , C185) implies $2 = ( C186 . ( C187 . ( 2 * $1 ) ) )));
func C187 .flowSeq C186 -> (FinSequence of ( NAT )) means 
:L1002: (( dom it ) = ( dom ( C187 .edgeSeq() ) ) & (for B141 being Nat holds (B141 in ( dom it ) implies ((( C187 . ( 2 * B141 ) ) DJoins ( C187 . ( ( 2 * B141 ) - 1 ) ) , ( C187 . ( ( 2 * B141 ) + 1 ) ) , C185 implies ( it . B141 ) = ( ( ( the_Weight_of C185 ) . ( C187 . ( 2 * B141 ) ) ) - ( C186 . ( C187 . ( 2 * B141 ) ) ) )) & ((not ( C187 . ( 2 * B141 ) ) DJoins ( C187 . ( ( 2 * B141 ) - 1 ) ) , ( C187 . ( ( 2 * B141 ) + 1 ) ) , C185) implies ( it . B141 ) = ( C186 . ( C187 . ( 2 * B141 ) ) ))))));
existence
proof
L1003:
now
let C188 being Nat;
assume L1004: C188 in ( Seg ( len ( C187 .edgeSeq() ) ) );
L1005:
now
per cases ;
suppose L1006: ( C187 . ( 2 * C188 ) ) DJoins ( C187 . ( ( 2 * C188 ) - 1 ) ) , ( C187 . ( ( 2 * C188 ) + 1 ) ) , C185;

thus L1007: (ex B142 being set st S13[ C188 , B142 ]) by L1006;
end;
suppose L1008: (not ( C187 . ( 2 * C188 ) ) DJoins ( C187 . ( ( 2 * C188 ) - 1 ) ) , ( C187 . ( ( 2 * C188 ) + 1 ) ) , C185);

thus L1009: (ex B143 being set st S13[ C188 , B143 ]) by L1008;
end;
end;
thus L1011: (ex B144 being set st S13[ C188 , B144 ]) by L1005;
end;
L1012: (for B145 being Nat holds (B145 in ( Seg ( len ( C187 .edgeSeq() ) ) ) implies (ex B146 being set st S13[ B145 , B146 ]))) by L1003;
consider C189 being FinSequence such that L1013: ( dom C189 ) = ( Seg ( len ( C187 .edgeSeq() ) ) ) and L1014: (for B147 being Nat holds (B147 in ( Seg ( len ( C187 .edgeSeq() ) ) ) implies S13[ B147 , ( C189 . B147 ) ])) from FINSEQ_1:sch 1(L1012);
L1015:
now
let C190 being set;
assume L1016: C190 in ( rng C189 );
consider C191 being set such that L1017: C191 in ( dom C189 ) and L1018: ( C189 . C191 ) = C190 by L1016 , FUNCT_1:def 3;
reconsider D124 = C191 as (Element of ( NAT )) by L1017;
per cases ;
suppose L1019: ( C187 . ( 2 * D124 ) ) DJoins ( C187 . ( ( 2 * D124 ) - 1 ) ) , ( C187 . ( ( 2 * D124 ) + 1 ) ) , C185;

L1020: D124 in ( dom ( C187 .edgeSeq() ) ) by L1013 , L1017 , FINSEQ_1:def 3;
L1021: ( 2 * D124 ) in ( dom C187 ) by L1020 , GLIB_001:78;
L1022: 1 <= ( 2 * D124 ) by L1021 , FINSEQ_3:25;
reconsider D125 = ( ( 2 * D124 ) - 1 ) as  odd (Element of ( NAT )) by L1022 , INT_1:5;
L1023: ( 2 * D124 ) <= ( len C187 ) by L1021 , FINSEQ_3:25;
L1024: D125 < ( ( len C187 ) - ( 0 ) ) by L1023 , XREAL_1:15;
L1025: ( D125 + ( 1 + 1 ) ) = ( ( 2 * D124 ) + 1 );
L1026: ( C189 . D124 ) = ( ( ( the_Weight_of C185 ) . ( C187 . ( 2 * D124 ) ) ) - ( C186 . ( C187 . ( 2 * D124 ) ) ) ) by L1013 , L1014 , L1017 , L1019;
L1027: ( D125 + 1 ) = ( 2 * D124 );
L1028: ( C186 . ( C187 . ( 2 * D124 ) ) ) < ( ( the_Weight_of C185 ) . ( C187 . ( 2 * D124 ) ) ) by L1027 , L1001 , L1019 , L1024 , L1025 , L45;
thus L1029: C190 in ( NAT ) by L1028 , L1018 , L1026 , INT_1:5;
end;
suppose L1030: (not ( C187 . ( 2 * D124 ) ) DJoins ( C187 . ( ( 2 * D124 ) - 1 ) ) , ( C187 . ( ( 2 * D124 ) + 1 ) ) , C185);

L1031: ( C189 . D124 ) = ( C186 . ( C187 . ( 2 * D124 ) ) ) by L1030 , L1013 , L1014 , L1017;
thus L1032: C190 in ( NAT ) by L1031 , L1018 , ORDINAL1:def 12;
end;
end;
L1034: ( rng C189 ) c= ( NAT ) by L1015 , TARSKI:def 3;
reconsider D126 = C189 as (FinSequence of ( NAT )) by L1034 , FINSEQ_1:def 4;
take D126;
thus L1035: ( dom D126 ) = ( dom ( C187 .edgeSeq() ) ) by L1013 , FINSEQ_1:def 3;
let C192 being Nat;
assume L1036: C192 in ( dom D126 );
thus L1037: thesis by L1036 , L1013 , L1014;
end;
uniqueness
proof
let C193 , C194 being (FinSequence of ( NAT ));
assume that
L1038: ( dom C193 ) = ( dom ( C187 .edgeSeq() ) )
and
L1039: (for B148 being Nat holds (B148 in ( dom C193 ) implies S13[ B148 , ( C193 . B148 ) ]))
and
L1040: ( dom C194 ) = ( dom ( C187 .edgeSeq() ) )
and
L1041: (for B149 being Nat holds (B149 in ( dom C194 ) implies S13[ B149 , ( C194 . B149 ) ]));
L1042:
now
let C195 being Nat;
assume L1043: C195 in ( dom C193 );
L1044:
now
per cases ;
suppose L1045: ( C187 . ( 2 * C195 ) ) DJoins ( C187 . ( ( 2 * C195 ) - 1 ) ) , ( C187 . ( ( 2 * C195 ) + 1 ) ) , C185;

L1046: ( C193 . C195 ) = ( ( ( the_Weight_of C185 ) . ( C187 . ( 2 * C195 ) ) ) - ( C186 . ( C187 . ( 2 * C195 ) ) ) ) by L1045 , L1039 , L1043;
thus L1047: ( C193 . C195 ) = ( C194 . C195 ) by L1046 , L1038 , L1040 , L1041 , L1043 , L1045;
end;
suppose L1048: (not ( C187 . ( 2 * C195 ) ) DJoins ( C187 . ( ( 2 * C195 ) - 1 ) ) , ( C187 . ( ( 2 * C195 ) + 1 ) ) , C185);

L1049: ( C193 . C195 ) = ( C186 . ( C187 . ( 2 * C195 ) ) ) by L1048 , L1039 , L1043;
thus L1050: ( C193 . C195 ) = ( C194 . C195 ) by L1049 , L1038 , L1040 , L1041 , L1043 , L1048;
end;
end;
thus L1052: ( C193 . C195 ) = ( C194 . C195 ) by L1044;
end;
thus L1053: C193 = C194 by L1042 , L1038 , L1040 , FINSEQ_1:13;
end;
end;
definition
let C196 being  natural-weighted WGraph;
let C197 being (FF:ELabeling of C196);
let C198 being (Walk of C196);
assume L1055: C198 is_augmenting_wrt C197;
func C198 .tolerance C197 -> Nat means 
:L1056: (it in ( rng ( C198 .flowSeq C197 ) ) & (for B150 being  real number holds (B150 in ( rng ( C198 .flowSeq C197 ) ) implies it <= B150))) if C198 is non  trivial otherwise it = ( 0 );
existence
proof
set D127 = ( rng ( C198 .flowSeq C197 ) );
L1057:
now
assume L1058: C198 is non  trivial;
L1059: ( C198 .edges() ) <> ( {} ) by L1058 , GLIB_001:136;
L1060: ( rng ( C198 .edgeSeq() ) ) <> ( {} ) by L1059 , GLIB_001:def 17;
consider C199 being set such that L1061: C199 in ( rng ( C198 .edgeSeq() ) ) by L1060 , XBOOLE_0:def 1;
consider C200 being set such that L1062: C200 in ( dom ( C198 .edgeSeq() ) ) and L1063: C199 = ( ( C198 .edgeSeq() ) . C200 ) by L1061 , FUNCT_1:def 3;
L1064: C200 in ( dom ( C198 .flowSeq C197 ) ) by L1055 , L1062 , L1002;
L1065: ( ( C198 .flowSeq C197 ) . C200 ) in D127 by L1064 , FUNCT_1:def 3;
reconsider D128 = D127 as non  empty  finite (Subset of ( NAT )) by L1065;
deffunc H1(Nat) = $1;
consider C201 being (Element of D128) such that L1066: (for B151 being (Element of D128) holds H1(C201) <= H1(B151)) from GRAPH_5:sch 2;
reconsider D129 = C201 as Nat;
take D130 = D129;
thus L1067: D130 in ( rng ( C198 .flowSeq C197 ) );
let C202 being  real number;
assume L1068: C202 in ( rng ( C198 .flowSeq C197 ) );
thus L1069: D130 <= C202 by L1068 , L1066;
end;
thus L1070: thesis by L1057;
end;
uniqueness
proof
let C203 , C204 being Nat;
thus L1071:now
assume L1072: C198 is non  trivial;
assume that
L1073: C203 in ( rng ( C198 .flowSeq C197 ) )
and
L1074: (for B152 being  real number holds (B152 in ( rng ( C198 .flowSeq C197 ) ) implies C203 <= B152));
assume that
L1075: C204 in ( rng ( C198 .flowSeq C197 ) )
and
L1076: (for B153 being  real number holds (B153 in ( rng ( C198 .flowSeq C197 ) ) implies C204 <= B153));
L1077: C204 <= C203 by L1073 , L1076;
L1078: C203 <= C204 by L1074 , L1075;
thus L1079: C203 = C204 by L1078 , L1077 , XXREAL_0:1;
end;
thus L1080: thesis;
end;
consistency;
end;
definition
let C205 being  natural-weighted WGraph;
let C206 being (FF:ELabeling of C205);
let C207 being (Path of C205);
assume L1082: C207 is_augmenting_wrt C206;
func FF:PushFlow (C206 , C207) -> (FF:ELabeling of C205) means 
:L1083: ((for B154 being set holds ((B154 in ( the_Edges_of C205 ) & (not B154 in ( C207 .edges() ))) implies ( it . B154 ) = ( C206 . B154 ))) & (for B155 being  odd Nat holds (B155 < ( len C207 ) implies ((( C207 . ( B155 + 1 ) ) DJoins ( C207 . B155 ) , ( C207 . ( B155 + 2 ) ) , C205 implies ( it . ( C207 . ( B155 + 1 ) ) ) = ( ( C206 . ( C207 . ( B155 + 1 ) ) ) + ( C207 .tolerance C206 ) )) & ((not ( C207 . ( B155 + 1 ) ) DJoins ( C207 . B155 ) , ( C207 . ( B155 + 2 ) ) , C205) implies ( it . ( C207 . ( B155 + 1 ) ) ) = ( ( C206 . ( C207 . ( B155 + 1 ) ) ) - ( C207 .tolerance C206 ) ))))));
existence
proof
defpred S14[ set , set ] means ((($1 in ( the_Edges_of C205 ) & (not $1 in ( C207 .edges() ))) implies $2 = ( C206 . $1 )) & (for B156 being  odd (Element of ( NAT )) holds ((B156 < ( len C207 ) & $1 = ( C207 . ( B156 + 1 ) )) implies ((( C207 . ( B156 + 1 ) ) DJoins ( C207 . B156 ) , ( C207 . ( B156 + 2 ) ) , C205 implies $2 = ( ( C206 . ( C207 . ( B156 + 1 ) ) ) + ( C207 .tolerance C206 ) )) & ((not ( C207 . ( B156 + 1 ) ) DJoins ( C207 . B156 ) , ( C207 . ( B156 + 2 ) ) , C205) implies $2 = ( ( C206 . ( C207 . ( B156 + 1 ) ) ) - ( C207 .tolerance C206 ) ))))));
L1084:
now
let C208 being set;
assume L1085: C208 in ( the_Edges_of C205 );
L1086:
now
per cases ;
suppose L1087: (not C208 in ( C207 .edges() ));

set D131 = ( C206 . C208 );
L1088: (for B157 being  odd (Element of ( NAT )) holds ((B157 < ( len C207 ) & C208 = ( C207 . ( B157 + 1 ) )) implies ((( C207 . ( B157 + 1 ) ) DJoins ( C207 . B157 ) , ( C207 . ( B157 + 2 ) ) , C205 implies D131 = ( ( C206 . ( C207 . ( B157 + 1 ) ) ) + ( C207 .tolerance C206 ) )) & ((not ( C207 . ( B157 + 1 ) ) DJoins ( C207 . B157 ) , ( C207 . ( B157 + 2 ) ) , C205) implies D131 = ( ( C206 . ( C207 . ( B157 + 1 ) ) ) - ( C207 .tolerance C206 ) ))))) by L1087 , GLIB_001:100;
thus L1089: (ex B158 being set st S14[ C208 , B158 ]) by L1088;
end;
suppose L1090: C208 in ( C207 .edges() );

consider C209 being  odd (Element of ( NAT )) such that L1091: C209 < ( len C207 ) and L1092: ( C207 . ( C209 + 1 ) ) = C208 by L1090 , GLIB_001:100;
L1093: 1 <= ( C209 + 1 ) by NAT_1:11;
L1094: ( C209 + 1 ) <= ( len C207 ) by L1091 , NAT_1:13;
L1095:
now
per cases ;
suppose L1096: ( C207 . ( C209 + 1 ) ) DJoins ( C207 . C209 ) , ( C207 . ( C209 + 2 ) ) , C205;

set D132 = ( ( C206 . ( C207 . ( C209 + 1 ) ) ) + ( C207 .tolerance C206 ) );
L1097:
now
thus L1098: ((C208 in ( the_Edges_of C205 ) & (not C208 in ( C207 .edges() ))) implies D132 = ( C206 . C208 )) by L1090;
let C210 being  odd (Element of ( NAT ));
assume that
L1099: C210 < ( len C207 )
and
L1100: ( C207 . ( C210 + 1 ) ) = C208;
L1101: 1 <= ( C210 + 1 ) by NAT_1:11;
L1102: ( C209 + 1 ) <= ( C210 + 1 ) by L1101 , L1092 , L1094 , L1100 , GLIB_001:138;
thus L1103: (( C207 . ( C210 + 1 ) ) DJoins ( C207 . C210 ) , ( C207 . ( C210 + 2 ) ) , C205 implies D132 = D132);
assume L1104: (not ( C207 . ( C210 + 1 ) ) DJoins ( C207 . C210 ) , ( C207 . ( C210 + 2 ) ) , C205);
L1105: ( C210 + 1 ) <= ( len C207 ) by L1099 , NAT_1:13;
L1106: ( C210 + 1 ) <= ( C209 + 1 ) by L1105 , L1092 , L1093 , L1100 , GLIB_001:138;
L1107: ( C210 + 1 ) = ( C209 + 1 ) by L1106 , L1102 , XXREAL_0:1;
thus L1108: D132 = ( ( C206 . ( C207 . ( C210 + 1 ) ) ) - ( C207 .tolerance C206 ) ) by L1107 , L1096 , L1104;
end;
L1109: S14[ C208 , D132 ] by L1097 , L1092;
thus L1110: (ex B159 being set st S14[ C208 , B159 ]) by L1109;
end;
suppose L1111: (not ( C207 . ( C209 + 1 ) ) DJoins ( C207 . C209 ) , ( C207 . ( C209 + 2 ) ) , C205);

set D133 = ( ( C206 . ( C207 . ( C209 + 1 ) ) ) - ( C207 .tolerance C206 ) );
L1112:
now
thus L1113: ((C208 in ( the_Edges_of C205 ) & (not C208 in ( C207 .edges() ))) implies D133 = ( C206 . C208 )) by L1090;
let C211 being  odd (Element of ( NAT ));
assume that
L1114: C211 < ( len C207 )
and
L1115: ( C207 . ( C211 + 1 ) ) = C208;
L1116: 1 <= ( C211 + 1 ) by NAT_1:11;
L1117: ( C209 + 1 ) <= ( C211 + 1 ) by L1116 , L1092 , L1094 , L1115 , GLIB_001:138;
L1118: ( C211 + 1 ) <= ( len C207 ) by L1114 , NAT_1:13;
L1119: ( C211 + 1 ) <= ( C209 + 1 ) by L1118 , L1092 , L1093 , L1115 , GLIB_001:138;
L1120: ( C211 + 1 ) = ( C209 + 1 ) by L1119 , L1117 , XXREAL_0:1;
thus L1121: (( C207 . ( C211 + 1 ) ) DJoins ( C207 . C211 ) , ( C207 . ( C211 + 2 ) ) , C205 implies D133 = ( ( C206 . ( C207 . ( C209 + 1 ) ) ) + ( C207 .tolerance C206 ) )) by L1120 , L1111;
assume L1122: (not ( C207 . ( C211 + 1 ) ) DJoins ( C207 . C211 ) , ( C207 . ( C211 + 2 ) ) , C205);
thus L1123: D133 = ( ( C206 . ( C207 . ( C209 + 1 ) ) ) - ( C207 .tolerance C206 ) );
end;
L1124: S14[ C208 , D133 ] by L1112 , L1092;
thus L1125: (ex B160 being set st S14[ C208 , B160 ]) by L1124;
end;
end;
thus L1127: (ex B161 being set st S14[ C208 , B161 ]) by L1095;
end;
end;
thus L1129: (ex B162 being set st S14[ C208 , B162 ]) by L1086;
end;
L1130: (for B163 being set holds (B163 in ( the_Edges_of C205 ) implies (ex B164 being set st S14[ B163 , B164 ]))) by L1084;
consider C212 being Function such that L1131: ( dom C212 ) = ( the_Edges_of C205 ) and L1132: (for B165 being set holds (B165 in ( the_Edges_of C205 ) implies S14[ B165 , ( C212 . B165 ) ])) from CLASSES1:sch 1(L1130);
L1133: ( rng C212 ) c= ( NAT )
proof
let C213 being set;
assume L1134: C213 in ( rng C212 );
consider C214 being set such that L1135: C214 in ( dom C212 ) and L1136: ( C212 . C214 ) = C213 by L1134 , FUNCT_1:def 3;
L1137:
now
per cases ;
suppose L1138: (not C214 in ( C207 .edges() ));

L1139: C213 = ( C206 . C214 ) by L1138 , L1131 , L1132 , L1135 , L1136;
thus L1140: thesis by L1139 , ORDINAL1:def 12;
end;
suppose L1141: C214 in ( C207 .edges() );

consider C215 being  odd (Element of ( NAT )) such that L1142: C215 < ( len C207 ) and L1143: ( C207 . ( C215 + 1 ) ) = C214 by L1141 , GLIB_001:100;
L1144: C207 is non  trivial by L1141 , GLIB_001:136;
L1145:
now
per cases ;
suppose L1146: ( C207 . ( C215 + 1 ) ) DJoins ( C207 . C215 ) , ( C207 . ( C215 + 2 ) ) , C205;

L1147: C213 = ( ( C206 . ( C207 . ( C215 + 1 ) ) ) + ( C207 .tolerance C206 ) ) by L1146 , L1131 , L1132 , L1135 , L1136 , L1142 , L1143;
thus L1148: thesis by L1147 , ORDINAL1:def 12;
end;
suppose L1149: (not ( C207 . ( C215 + 1 ) ) DJoins ( C207 . C215 ) , ( C207 . ( C215 + 2 ) ) , C205);

set D134 = ( ( C215 + 1 ) div 2 );
L1150: 1 <= ( C215 + 1 ) by NAT_1:11;
L1151: ( C215 + 1 ) <= ( len C207 ) by L1142 , NAT_1:13;
L1152: D134 in ( dom ( C207 .edgeSeq() ) ) by L1151 , L1150 , GLIB_001:77;
L1153: D134 in ( dom ( C207 .flowSeq C206 ) ) by L1152 , L1082 , L1002;
L1154: 2 divides ( C215 + 1 ) by PEPIN:22;
L1155: ( 2 * D134 ) = ( C215 + 1 ) by L1154 , NAT_D:3;
L1156: ( ( 2 * D134 ) + 1 ) = ( C215 + ( 1 + 1 ) ) by L1155;
L1157: ( ( 2 * D134 ) - 1 ) = C215 by L1155;
L1158: ( ( C207 .flowSeq C206 ) . D134 ) = ( C206 . C214 ) by L1157 , L1082 , L1143 , L1149 , L1153 , L1156 , L1002;
L1159: ( C206 . C214 ) in ( rng ( C207 .flowSeq C206 ) ) by L1158 , L1153 , FUNCT_1:def 3;
L1160: ( C207 .tolerance C206 ) <= ( C206 . C214 ) by L1159 , L1082 , L1144 , L1056;
L1161: C213 = ( ( C206 . C214 ) - ( C207 .tolerance C206 ) ) by L1131 , L1132 , L1135 , L1136 , L1142 , L1143 , L1149;
thus L1162: thesis by L1161 , L1160 , INT_1:5;
end;
end;
thus L1164: thesis by L1145;
end;
end;
thus L1166: thesis by L1137;
end;
reconsider D135 = C212 as  natural-valued (ManySortedSet of ( the_Edges_of C205 )) by L1133 , L1131 , PARTFUN1:def 2 , RELAT_1:def 18 , VALUED_0:def 6;
take D135;
thus L1167: (for B166 being set holds ((B166 in ( the_Edges_of C205 ) & (not B166 in ( C207 .edges() ))) implies ( D135 . B166 ) = ( C206 . B166 ))) by L1132;
let C216 being  odd Nat;
reconsider D136 = C216 as  odd (Element of ( NAT )) by ORDINAL1:def 12;
L1168: D136 = C216;
assume L1169: C216 < ( len C207 );
L1170: ( C207 . ( C216 + 1 ) ) Joins ( C207 . C216 ) , ( C207 . ( D136 + 2 ) ) , C205 by L1169 , GLIB_001:def 3;
L1171: ( C207 . ( C216 + 1 ) ) in ( the_Edges_of C205 ) by L1170 , GLIB_000:def 13;
thus L1172: (( C207 . ( C216 + 1 ) ) DJoins ( C207 . C216 ) , ( C207 . ( C216 + 2 ) ) , C205 implies ( D135 . ( C207 . ( C216 + 1 ) ) ) = ( ( C206 . ( C207 . ( C216 + 1 ) ) ) + ( C207 .tolerance C206 ) )) by L1171 , L1132 , L1168 , L1169;
assume L1173: (not ( C207 . ( C216 + 1 ) ) DJoins ( C207 . C216 ) , ( C207 . ( C216 + 2 ) ) , C205);
thus L1174: thesis by L1173 , L1132 , L1168 , L1169 , L1171;
end;
uniqueness
proof
let C217 , C218 being (FF:ELabeling of C205);
assume that
L1175: (for B167 being set holds ((B167 in ( the_Edges_of C205 ) & (not B167 in ( C207 .edges() ))) implies ( C217 . B167 ) = ( C206 . B167 )))
and
L1176: (for B168 being  odd Nat holds (B168 < ( len C207 ) implies ((( C207 . ( B168 + 1 ) ) DJoins ( C207 . B168 ) , ( C207 . ( B168 + 2 ) ) , C205 implies ( C217 . ( C207 . ( B168 + 1 ) ) ) = ( ( C206 . ( C207 . ( B168 + 1 ) ) ) + ( C207 .tolerance C206 ) )) & ((not ( C207 . ( B168 + 1 ) ) DJoins ( C207 . B168 ) , ( C207 . ( B168 + 2 ) ) , C205) implies ( C217 . ( C207 . ( B168 + 1 ) ) ) = ( ( C206 . ( C207 . ( B168 + 1 ) ) ) - ( C207 .tolerance C206 ) )))))
and
L1177: (for B169 being set holds ((B169 in ( the_Edges_of C205 ) & (not B169 in ( C207 .edges() ))) implies ( C218 . B169 ) = ( C206 . B169 )))
and
L1178: (for B170 being  odd Nat holds (B170 < ( len C207 ) implies ((( C207 . ( B170 + 1 ) ) DJoins ( C207 . B170 ) , ( C207 . ( B170 + 2 ) ) , C205 implies ( C218 . ( C207 . ( B170 + 1 ) ) ) = ( ( C206 . ( C207 . ( B170 + 1 ) ) ) + ( C207 .tolerance C206 ) )) & ((not ( C207 . ( B170 + 1 ) ) DJoins ( C207 . B170 ) , ( C207 . ( B170 + 2 ) ) , C205) implies ( C218 . ( C207 . ( B170 + 1 ) ) ) = ( ( C206 . ( C207 . ( B170 + 1 ) ) ) - ( C207 .tolerance C206 ) )))));
L1179:
now
let C219 being set;
assume L1180: C219 in ( the_Edges_of C205 );
L1181:
now
per cases ;
suppose L1182: (not C219 in ( C207 .edges() ));

L1183: ( C217 . C219 ) = ( C206 . C219 ) by L1182 , L1175 , L1180;
thus L1184: ( C217 . C219 ) = ( C218 . C219 ) by L1183 , L1177 , L1180 , L1182;
end;
suppose L1185: C219 in ( C207 .edges() );

consider C220 being  odd (Element of ( NAT )) such that L1186: C220 < ( len C207 ) and L1187: ( C207 . ( C220 + 1 ) ) = C219 by L1185 , GLIB_001:100;
L1188:
now
per cases ;
suppose L1189: ( C207 . ( C220 + 1 ) ) DJoins ( C207 . C220 ) , ( C207 . ( C220 + 2 ) ) , C205;

L1190: ( C217 . C219 ) = ( ( C206 . ( C207 . ( C220 + 1 ) ) ) + ( C207 .tolerance C206 ) ) by L1189 , L1176 , L1186 , L1187;
thus L1191: ( C217 . C219 ) = ( C218 . C219 ) by L1190 , L1178 , L1186 , L1187 , L1189;
end;
suppose L1192: (not ( C207 . ( C220 + 1 ) ) DJoins ( C207 . C220 ) , ( C207 . ( C220 + 2 ) ) , C205);

L1193: ( C217 . C219 ) = ( ( C206 . ( C207 . ( C220 + 1 ) ) ) - ( C207 .tolerance C206 ) ) by L1192 , L1176 , L1186 , L1187;
thus L1194: ( C217 . C219 ) = ( C218 . C219 ) by L1193 , L1178 , L1186 , L1187 , L1192;
end;
end;
thus L1196: ( C217 . C219 ) = ( C218 . C219 ) by L1188;
end;
end;
thus L1198: ( C217 . C219 ) = ( C218 . C219 ) by L1181;
end;
thus L1199: thesis by L1179 , PBOOLE:3;
end;
end;
definition
let C221 being  finite  natural-weighted WGraph;
let C222 being (FF:ELabeling of C221);
let C223 , C224 being (Vertex of C221);
func FF:Step (C222 , C224 , C223) -> (FF:ELabeling of C221) equals 
:L1201: ( FF:PushFlow (C222 , ( AP:GetAugPath (C222 , C224 , C223) )) ) if C223 in ( dom ( AP:FindAugPath (C222 , C224) ) ) otherwise C222;
correctness;
end;
definition
let C225 being _Graph;
mode FF:ELabelingSeq of C225
 -> (ManySortedSet of ( NAT ))
means :L1203: (for B171 being Nat holds ( it . B171 ) is (FF:ELabeling of C225));
existence
proof
take ( ( NAT ) --> ( ( the_Edges_of C225 ) --> ( 0 ) ) );
let C226 being Nat;
L1204: C226 in ( NAT ) by ORDINAL1:def 12;
thus L1205: thesis by L1204 , FUNCOP_1:7;
end;
end;
registration
let C227 being _Graph;
let C228 being (FF:ELabelingSeq of C227);
let C229 being Nat;
cluster ( C228 . C229 ) ->  Function-like  Relation-like;
coherence by L1203;
end;
registration
let C230 being _Graph;
let C231 being (FF:ELabelingSeq of C230);
let C232 being Nat;
cluster ( C231 . C232 ) -> ( the_Edges_of C230 ) -defined;
coherence by L1203;
end;
registration
let C233 being _Graph;
let C234 being (FF:ELabelingSeq of C233);
let C235 being Nat;
cluster ( C234 . C235 ) ->  natural-valued  total;
coherence by L1203;
end;
definition
let C236 being  finite  natural-weighted WGraph;
let C237 , C238 being (Vertex of C236);
func FF:CompSeq (C236 , C237 , C238) -> (FF:ELabelingSeq of C236) means 
:L1210: (( it . ( 0 ) ) = ( ( the_Edges_of C236 ) --> ( 0 ) ) & (for B172 being Nat holds ( it . ( B172 + 1 ) ) = ( FF:Step (( it . B172 ) , C237 , C238) )));
existence
proof
defpred S15[ set , set , set ] means ((ex B173 being (FF:ELabeling of C236) st (B173 = $2 & $3 = ( FF:Step (B173 , C237 , C238) ))) or ((not (ex B174 being (FF:ELabeling of C236) st B174 = $2)) & $3 = $2));
L1211:
now
let C239 , C240 being set;
L1212:
now
per cases ;
suppose L1213: (ex B175 being (FF:ELabeling of C236) st B175 = C240);

consider C241 being (FF:ELabeling of C236) such that L1214: C241 = C240 by L1213;
set D137 = ( FF:Step (C241 , C237 , C238) );
L1215: S15[ C239 , C240 , D137 ] by L1214;
thus L1216: (ex B176 being set st S15[ C239 , C240 , B176 ]) by L1215;
end;
suppose L1217: (not (ex B177 being (FF:ELabeling of C236) st B177 = C240));

thus L1218: (ex B178 being set st S15[ C239 , C240 , B178 ]) by L1217;
end;
end;
thus L1220: (ex B179 being set st S15[ C239 , C240 , B179 ]) by L1212;
end;
L1221: (for B180 being (Element of ( NAT )) holds (for B181 being set holds (ex B182 being set st S15[ B180 , B181 , B182 ]))) by L1211;
consider C242 being Function such that L1222: (( dom C242 ) = ( NAT ) & ( C242 . ( 0 ) ) = ( ( the_Edges_of C236 ) --> ( 0 ) ) & (for B183 being (Element of ( NAT )) holds S15[ B183 , ( C242 . B183 ) , ( C242 . ( B183 + 1 ) ) ])) from RECDEF_1:sch 1(L1221);
reconsider D138 = C242 as (ManySortedSet of ( NAT )) by L1222 , PARTFUN1:def 2 , RELAT_1:def 18;
defpred S16[ Nat ] means (ex B184 being (FF:ELabeling of C236) st ( D138 . $1 ) = B184);
L1223:
now
let C243 being Nat;
assume L1224: S16[ C243 ];
consider C244 being (FF:ELabeling of C236) such that L1225: ( D138 . C243 ) = C244 by L1224;
L1226: C243 in ( NAT ) by ORDINAL1:def 12;
L1227: S15[ C243 , C244 , ( D138 . ( C243 + 1 ) ) ] by L1226 , L1222 , L1225;
thus L1228: S16[ ( C243 + 1 ) ] by L1227;
end;
L1229: S16[ ( 0 ) ] by L1222;
L1230: (for B185 being Nat holds S16[ B185 ]) from NAT_1:sch 2(L1229 , L1223);
L1231:
now
let C245 being Nat;
L1232: (ex B186 being (FF:ELabeling of C236) st ( D138 . C245 ) = B186) by L1230;
thus L1233: ( D138 . C245 ) is (FF:ELabeling of C236) by L1232;
end;
reconsider D139 = D138 as (FF:ELabelingSeq of C236) by L1231 , L1203;
take D139;
thus L1234: ( D139 . ( 0 ) ) = ( ( the_Edges_of C236 ) --> ( 0 ) ) by L1222;
let C246 being Nat;
reconsider D140 = C246 as (Element of ( NAT )) by ORDINAL1:def 12;
L1235: (ex B187 being (FF:ELabeling of C236) st (B187 = ( D139 . C246 ) & ( D139 . ( D140 + 1 ) ) = ( FF:Step (B187 , C237 , C238) ))) by L1222;
thus L1236: thesis by L1235;
end;
uniqueness
proof
let C247 , C248 being (FF:ELabelingSeq of C236);
assume that
L1237: ( C247 . ( 0 ) ) = ( ( the_Edges_of C236 ) --> ( 0 ) )
and
L1238: (for B188 being Nat holds ( C247 . ( B188 + 1 ) ) = ( FF:Step (( C247 . B188 ) , C237 , C238) ))
and
L1239: ( C248 . ( 0 ) ) = ( ( the_Edges_of C236 ) --> ( 0 ) )
and
L1240: (for B189 being Nat holds ( C248 . ( B189 + 1 ) ) = ( FF:Step (( C248 . B189 ) , C237 , C238) ));
defpred S17[ Nat ] means ( C247 . $1 ) = ( C248 . $1 );
L1241:
now
let C249 being (Element of ( NAT ));
assume L1242: S17[ C249 ];
L1243: ( C248 . ( C249 + 1 ) ) = ( FF:Step (( C248 . C249 ) , C237 , C238) ) by L1240;
thus L1244: S17[ ( C249 + 1 ) ] by L1243 , L1238 , L1242;
end;
L1245: S17[ ( 0 ) ] by L1237 , L1239;
L1246: (for B190 being (Element of ( NAT )) holds S17[ B190 ]) from NAT_1:sch 1(L1245 , L1241);
L1247: (for B191 being set holds (B191 in ( NAT ) implies ( C247 . B191 ) = ( C248 . B191 ))) by L1246;
thus L1248: C247 = C248 by L1247 , PBOOLE:3;
end;
end;
definition
let C250 being  finite  natural-weighted WGraph;
let C251 , C252 being (Vertex of C250);
func FF:MaxFlow (C250 , C252 , C251) -> (FF:ELabeling of C250) equals 
( ( FF:CompSeq (C250 , C252 , C251) ) .Result() );
coherence;
end;
begin
theorem
L1251: (for B192 being  finite  real-weighted WGraph holds (for B193 being (FF:ELabeling of B192) holds (for B194 , B195 being set holds (for B196 being (Subset of ( the_Vertices_of B192 )) holds ((B193 has_valid_flow_from B194 , B195 & B194 in B196 & (not B195 in B196)) implies ( B193 .flow (B194 , B195) ) = ( ( Sum ( B193 | ( B192 .edgesDBetween (B196 , ( ( the_Vertices_of B192 ) \ B196 )) ) ) ) - ( Sum ( B193 | ( B192 .edgesDBetween (( ( the_Vertices_of B192 ) \ B196 ) , B196) ) ) ) ))))))
proof
let C253 being  finite  real-weighted WGraph;
let C254 being (FF:ELabeling of C253);
let C255 , C256 being set;
let C257 being (Subset of ( the_Vertices_of C253 ));
assume that
L1252: C254 has_valid_flow_from C255 , C256
and
L1253: C255 in C257
and
L1254: (not C256 in C257);
set D141 = ( the_Vertices_of C253 );
set D142 = ( card ( D141 \ C257 ) );
L1255:
now
assume L1256: D142 = ( 0 );
L1257: ( D141 \ C257 ) = ( {} ) by L1256;
L1258: C256 is (Vertex of C253) by L1252 , L34;
thus L1259: contradiction by L1258 , L1254 , L1257 , XBOOLE_0:def 5;
end;
defpred S18[ Nat ] means (for B197 being (Subset of D141) holds ((( card ( D141 \ B197 ) ) = $1 & C255 in B197 & (not C256 in B197)) implies ( C254 .flow (C255 , C256) ) = ( ( Sum ( C254 | ( C253 .edgesDBetween (B197 , ( D141 \ B197 )) ) ) ) - ( Sum ( C254 | ( C253 .edgesDBetween (( D141 \ B197 ) , B197) ) ) ) )));
set D143 = ( the_Target_of C253 );
set D144 = ( the_Source_of C253 );
L1260:
now
let C258 being non  empty Nat;
assume L1261: S18[ C258 ];
L1262:
now
let C259 being (Subset of D141);
assume that
L1263: ( card ( D141 \ C259 ) ) = ( C258 + 1 )
and
L1264: C255 in C259
and
L1265: (not C256 in C259);
set D145 = ( choose ( ( D141 \ C259 ) \ { C256 } ) );
set D146 = ( C259 \/ { D145 } );
set D147 = ( C253 .edgesDBetween (D146 , ( D141 \ D146 )) );
set D148 = ( C253 .edgesDBetween (( D141 \ D146 ) , D146) );
set D149 = ( C253 .edgesDBetween ({ D145 } , ( D141 \ D146 )) );
set D150 = ( C253 .edgesDBetween (( D141 \ D146 ) , { D145 }) );
L1266: C256 is (Vertex of C253) by L1252 , L34;
L1267: C256 in ( D141 \ C259 ) by L1266 , L1265 , XBOOLE_0:def 5;
L1268: { C256 } c= ( D141 \ C259 ) by L1267 , ZFMISC_1:31;
L1269: ( card ( ( D141 \ C259 ) \ { C256 } ) ) = ( ( C258 + 1 ) - ( card { C256 } ) ) by L1268 , L1263 , CARD_2:44
.= ( ( C258 + 1 ) - 1 ) by CARD_1:30
.= C258;
L1270: D145 in ( D141 \ C259 ) by L1269 , CARD_1:27 , XBOOLE_0:def 5;
L1271: { D145 } c= D141 by L1270 , ZFMISC_1:31;
reconsider D151 = D146 as (Subset of D141) by L1271 , XBOOLE_1:8;
L1272: ( D141 \ D151 ) = ( ( D141 \ C259 ) \ { D145 } ) by XBOOLE_1:41;
L1273: { D145 } c= ( D141 \ C259 ) by L1270 , ZFMISC_1:31;
L1274: ( card ( D141 \ D151 ) ) = ( ( card ( D141 \ C259 ) ) - ( card { D145 } ) ) by L1273 , L1272 , CARD_2:44
.= ( ( C258 + 1 ) - 1 ) by L1263 , CARD_1:30
.= C258;
L1275: C255 in D151 by L1264 , XBOOLE_0:def 3;
L1276: (not D145 in { C256 }) by L1269 , CARD_1:27 , XBOOLE_0:def 5;
L1277: D145 <> C256 by L1276 , TARSKI:def 1;
L1278: (not C256 in { D145 }) by L1277 , TARSKI:def 1;
L1279: (not C256 in D151) by L1278 , L1265 , XBOOLE_0:def 3;
L1280: ( C254 .flow (C255 , C256) ) = ( ( Sum ( C254 | D147 ) ) - ( Sum ( C254 | D148 ) ) ) by L1279 , L1261 , L1274 , L1275;
set D152 = ( C253 .edgesDBetween ({ D145 } , ( D141 \ { D145 } )) );
set D153 = ( C253 .edgesDBetween ({ D145 } , C259) );
set D154 = ( C253 .edgesDBetween (C259 , { D145 }) );
reconsider D155 = ( D147 \/ D154 ) as (Subset of ( the_Edges_of C253 ));
reconsider D156 = ( D155 \ D149 ) as (Subset of ( the_Edges_of C253 ));
reconsider D157 = ( D155 \ D154 ) as (Subset of ( the_Edges_of C253 ));
reconsider D158 = ( D148 \/ D153 ) as (Subset of ( the_Edges_of C253 ));
reconsider D159 = ( D158 \ D150 ) as (Subset of ( the_Edges_of C253 ));
reconsider D160 = ( D158 \ D153 ) as (Subset of ( the_Edges_of C253 ));
L1281: ( dom ( C254 | D155 ) ) = D155 by PARTFUN1:def 2;
L1282:
now
set D161 = ( choose ( D148 /\ D153 ) );
assume L1283: D148 meets D153;
L1284: ( D148 /\ D153 ) <> ( {} ) by L1283 , XBOOLE_0:def 7;
L1285: D161 in D148 by L1284 , XBOOLE_0:def 4;
L1286: D161 DSJoins ( D141 \ D151 ) , D151 , C253 by L1285 , GLIB_000:def 31;
L1287: ( D144 . D161 ) in ( D141 \ D151 ) by L1286 , GLIB_000:def 16;
L1288: (not ( D144 . D161 ) in D151) by L1287 , XBOOLE_0:def 5;
L1289: D161 in D153 by L1284 , XBOOLE_0:def 4;
L1290: D161 DSJoins { D145 } , C259 , C253 by L1289 , GLIB_000:def 31;
L1291: ( D144 . D161 ) in { D145 } by L1290 , GLIB_000:def 16;
thus L1292: contradiction by L1291 , L1288 , XBOOLE_0:def 3;
end;
L1293: ( D148 \ D153 ) = D148 by L1282 , XBOOLE_1:83;
L1294: D160 = D148 by L1293 , XBOOLE_1:40;
L1295:
now
let C260 being set;
assume L1296: C260 in D149;
L1297: C260 DSJoins { D145 } , ( D141 \ D151 ) , C253 by L1296 , GLIB_000:def 31;
L1298: ( D144 . C260 ) in { D145 } by L1297 , GLIB_000:def 16;
L1299: ( D144 . C260 ) in D151 by L1298 , XBOOLE_0:def 3;
L1300: ( D143 . C260 ) in ( D141 \ D151 ) by L1297 , GLIB_000:def 16;
L1301: C260 DSJoins D151 , ( D141 \ D151 ) , C253 by L1300 , L1296 , L1299 , GLIB_000:def 16;
thus L1302: C260 in D147 by L1301 , GLIB_000:def 31;
end;
L1303: D149 c= D147 by L1295 , TARSKI:def 3;
L1304:
now
set D162 = ( choose ( D147 /\ D154 ) );
assume L1305: D147 meets D154;
L1306: ( D147 /\ D154 ) <> ( {} ) by L1305 , XBOOLE_0:def 7;
L1307: D162 in D147 by L1306 , XBOOLE_0:def 4;
L1308: D162 DSJoins D151 , ( D141 \ D151 ) , C253 by L1307 , GLIB_000:def 31;
L1309: ( D143 . D162 ) in ( D141 \ D151 ) by L1308 , GLIB_000:def 16;
L1310: (not ( D143 . D162 ) in D151) by L1309 , XBOOLE_0:def 5;
L1311: D162 in D154 by L1306 , XBOOLE_0:def 4;
L1312: D162 DSJoins C259 , { D145 } , C253 by L1311 , GLIB_000:def 31;
L1313: ( D143 . D162 ) in { D145 } by L1312 , GLIB_000:def 16;
thus L1314: contradiction by L1313 , L1310 , XBOOLE_0:def 3;
end;
L1315: ( D147 \ D154 ) = D147 by L1304 , XBOOLE_1:83;
L1316: D157 = D147 by L1315 , XBOOLE_1:40;
L1317: ( dom ( C254 | D157 ) ) = D157 by PARTFUN1:def 2;
L1318:
now
let C261 being set;
assume L1319: C261 in ( dom ( C254 | D155 ) );
L1320: C261 in D155 by L1319;
L1321:
now
per cases ;
suppose L1322: (not C261 in D154);

L1323: C261 in D157 by L1322 , L1320 , XBOOLE_0:def 5;
thus L1324: ( ( ( C254 | D154 ) +* ( C254 | D157 ) ) . C261 ) = ( ( C254 | D157 ) . C261 ) by L1323 , L1317 , FUNCT_4:13
.= ( C254 . C261 ) by L1323 , FUNCT_1:49;
end;
suppose L1325: C261 in D154;

L1326: (not C261 in D157) by L1325 , XBOOLE_0:def 5;
thus L1327: ( ( ( C254 | D154 ) +* ( C254 | D157 ) ) . C261 ) = ( ( C254 | D154 ) . C261 ) by L1326 , L1317 , FUNCT_4:11
.= ( C254 . C261 ) by L1325 , FUNCT_1:49;
end;
end;
thus L1329: ( ( C254 | D155 ) . C261 ) = ( ( ( C254 | D154 ) +* ( C254 | D157 ) ) . C261 ) by L1321 , L1320 , FUNCT_1:49;
end;
L1330:
now
let C262 being set;
thus L1331:now
assume L1332: C262 in ( D152 \ D153 );
L1333: C262 in D152 by L1332 , XBOOLE_0:def 5;
L1334: C262 DSJoins { D145 } , ( D141 \ { D145 } ) , C253 by L1333 , GLIB_000:def 31;
L1335: ( D144 . C262 ) in { D145 } by L1334 , GLIB_000:def 16;
L1336: ( D143 . C262 ) in ( D141 \ { D145 } ) by L1334 , GLIB_000:def 16;
L1337: (not ( D143 . C262 ) in { D145 }) by L1336 , XBOOLE_0:def 5;
L1338: (not C262 in D153) by L1332 , XBOOLE_0:def 5;
L1339: (not C262 DSJoins { D145 } , C259 , C253) by L1338 , GLIB_000:def 31;
L1340: (not ( D143 . C262 ) in C259) by L1339 , L1332 , L1335 , GLIB_000:def 16;
L1341: (not ( D143 . C262 ) in D151) by L1340 , L1337 , XBOOLE_0:def 3;
L1342: ( D143 . C262 ) in ( D141 \ D151 ) by L1341 , L1336 , XBOOLE_0:def 5;
L1343: C262 DSJoins { D145 } , ( D141 \ D151 ) , C253 by L1342 , L1332 , L1335 , GLIB_000:def 16;
thus L1344: C262 in D149 by L1343 , GLIB_000:def 31;
end;
assume L1345: C262 in D149;
L1346: C262 DSJoins { D145 } , ( D141 \ D151 ) , C253 by L1345 , GLIB_000:def 31;
L1347: ( D143 . C262 ) in ( D141 \ D151 ) by L1346 , GLIB_000:def 16;
L1348: (not ( D143 . C262 ) in D151) by L1347 , XBOOLE_0:def 5;
L1349: (not ( D143 . C262 ) in { D145 }) by L1348 , XBOOLE_0:def 3;
L1350: ( D143 . C262 ) in ( D141 \ { D145 } ) by L1349 , L1347 , XBOOLE_0:def 5;
L1351: (not ( D143 . C262 ) in C259) by L1348 , XBOOLE_0:def 3;
L1352: (not C262 DSJoins { D145 } , C259 , C253) by L1351 , GLIB_000:def 16;
L1353: (not C262 in D153) by L1352 , GLIB_000:def 31;
L1354: ( D144 . C262 ) in { D145 } by L1346 , GLIB_000:def 16;
L1355: C262 DSJoins { D145 } , ( D141 \ { D145 } ) , C253 by L1354 , L1345 , L1350 , GLIB_000:def 16;
L1356: C262 in D152 by L1355 , GLIB_000:def 31;
thus L1357: C262 in ( D152 \ D153 ) by L1356 , L1353 , XBOOLE_0:def 5;
end;
L1358: ( D152 \ D153 ) = D149 by L1330 , TARSKI:1;
L1359: ( dom ( C254 | D160 ) ) = D160 by PARTFUN1:def 2;
L1360:
now
let C263 being set;
assume L1361: C263 in ( dom ( C254 | D158 ) );
L1362: C263 in D158 by L1361;
L1363:
now
per cases ;
suppose L1364: (not C263 in D153);

L1365: C263 in D160 by L1364 , L1362 , XBOOLE_0:def 5;
thus L1366: ( ( ( C254 | D153 ) +* ( C254 | D160 ) ) . C263 ) = ( ( C254 | D160 ) . C263 ) by L1365 , L1359 , FUNCT_4:13
.= ( C254 . C263 ) by L1365 , FUNCT_1:49;
end;
suppose L1367: C263 in D153;

L1368: (not C263 in D160) by L1367 , XBOOLE_0:def 5;
thus L1369: ( ( ( C254 | D153 ) +* ( C254 | D160 ) ) . C263 ) = ( ( C254 | D153 ) . C263 ) by L1368 , L1359 , FUNCT_4:11
.= ( C254 . C263 ) by L1367 , FUNCT_1:49;
end;
end;
thus L1371: ( ( C254 | D158 ) . C263 ) = ( ( ( C254 | D153 ) +* ( C254 | D160 ) ) . C263 ) by L1363 , L1362 , FUNCT_1:49;
end;
reconsider D163 = ( D152 \ D153 ) as (Subset of ( the_Edges_of C253 ));
set D164 = ( C253 .edgesDBetween (( D141 \ { D145 } ) , { D145 }) );
L1372: ( dom ( C254 | D158 ) ) = D158 by PARTFUN1:def 2;
L1373:
now
let C264 being set;
thus L1374:now
assume L1375: C264 in ( D164 \ D154 );
L1376: C264 in D164 by L1375 , XBOOLE_0:def 5;
L1377: C264 DSJoins ( D141 \ { D145 } ) , { D145 } , C253 by L1376 , GLIB_000:def 31;
L1378: ( D143 . C264 ) in { D145 } by L1377 , GLIB_000:def 16;
L1379: ( D144 . C264 ) in ( D141 \ { D145 } ) by L1377 , GLIB_000:def 16;
L1380: (not ( D144 . C264 ) in { D145 }) by L1379 , XBOOLE_0:def 5;
L1381: (not C264 in D154) by L1375 , XBOOLE_0:def 5;
L1382: (not C264 DSJoins C259 , { D145 } , C253) by L1381 , GLIB_000:def 31;
L1383: (not ( D144 . C264 ) in C259) by L1382 , L1375 , L1378 , GLIB_000:def 16;
L1384: (not ( D144 . C264 ) in D151) by L1383 , L1380 , XBOOLE_0:def 3;
L1385: ( D144 . C264 ) in ( D141 \ D151 ) by L1384 , L1379 , XBOOLE_0:def 5;
L1386: C264 DSJoins ( D141 \ D151 ) , { D145 } , C253 by L1385 , L1375 , L1378 , GLIB_000:def 16;
thus L1387: C264 in D150 by L1386 , GLIB_000:def 31;
end;
assume L1388: C264 in D150;
L1389: C264 DSJoins ( D141 \ D151 ) , { D145 } , C253 by L1388 , GLIB_000:def 31;
L1390: ( D144 . C264 ) in ( D141 \ D151 ) by L1389 , GLIB_000:def 16;
L1391: (not ( D144 . C264 ) in D151) by L1390 , XBOOLE_0:def 5;
L1392: (not ( D144 . C264 ) in { D145 }) by L1391 , XBOOLE_0:def 3;
L1393: ( D144 . C264 ) in ( D141 \ { D145 } ) by L1392 , L1390 , XBOOLE_0:def 5;
L1394: (not ( D144 . C264 ) in C259) by L1391 , XBOOLE_0:def 3;
L1395: (not C264 DSJoins C259 , { D145 } , C253) by L1394 , GLIB_000:def 16;
L1396: (not C264 in D154) by L1395 , GLIB_000:def 31;
L1397: ( D143 . C264 ) in { D145 } by L1389 , GLIB_000:def 16;
L1398: C264 DSJoins ( D141 \ { D145 } ) , { D145 } , C253 by L1397 , L1388 , L1393 , GLIB_000:def 16;
L1399: C264 in D164 by L1398 , GLIB_000:def 31;
thus L1400: C264 in ( D164 \ D154 ) by L1399 , L1396 , XBOOLE_0:def 5;
end;
L1401: ( D164 \ D154 ) = D150 by L1373 , TARSKI:1;
L1402:
now
let C265 being set;
assume L1403: C265 in D150;
L1404: C265 DSJoins ( D141 \ D151 ) , { D145 } , C253 by L1403 , GLIB_000:def 31;
L1405: ( D143 . C265 ) in { D145 } by L1404 , GLIB_000:def 16;
L1406: ( D143 . C265 ) in D151 by L1405 , XBOOLE_0:def 3;
L1407: ( D144 . C265 ) in ( D141 \ D151 ) by L1404 , GLIB_000:def 16;
L1408: C265 DSJoins ( D141 \ D151 ) , D151 , C253 by L1407 , L1403 , L1406 , GLIB_000:def 16;
thus L1409: C265 in D148 by L1408 , GLIB_000:def 31;
end;
L1410: D150 c= D148 by L1402 , TARSKI:def 3;
L1411: (not D145 in C259) by L1270 , XBOOLE_0:def 5;
L1412:
now
let C266 being set;
assume L1413: C266 in D154;
L1414: C266 DSJoins C259 , { D145 } , C253 by L1413 , GLIB_000:def 31;
L1415: ( D144 . C266 ) in C259 by L1414 , GLIB_000:def 16;
L1416: (not ( D144 . C266 ) in { D145 }) by L1415 , L1411 , TARSKI:def 1;
L1417: ( D144 . C266 ) in ( D141 \ { D145 } ) by L1416 , L1415 , XBOOLE_0:def 5;
L1418: ( D143 . C266 ) in { D145 } by L1414 , GLIB_000:def 16;
L1419: C266 DSJoins ( D141 \ { D145 } ) , { D145 } , C253 by L1418 , L1413 , L1417 , GLIB_000:def 16;
thus L1420: C266 in D164 by L1419 , GLIB_000:def 31;
end;
L1421: D154 c= D164 by L1412 , TARSKI:def 3;
L1422: ( (C259 qua set) \ { D145 } ) is (Subset of C259);
L1423:
now
let C267 being set;
L1424: ( (( D147 \/ D154 ) qua set) \ D149 ) is (Subset of ( D147 \/ D154 ));
thus L1425:now
assume L1426: C267 in ( C253 .edgesDBetween (C259 , ( D141 \ C259 )) );
L1427: C267 DSJoins C259 , ( D141 \ C259 ) , C253 by L1426 , GLIB_000:def 31;
L1428: ( D144 . C267 ) in C259 by L1427 , GLIB_000:def 16;
L1429:
now
assume L1430: C267 in D149;
L1431: C267 DSJoins { D145 } , ( D141 \ D151 ) , C253 by L1430 , GLIB_000:def 31;
L1432: ( D144 . C267 ) in { D145 } by L1431 , GLIB_000:def 16;
thus L1433: contradiction by L1432 , L1411 , L1428 , TARSKI:def 1;
end;
L1434: ( D143 . C267 ) in ( D141 \ C259 ) by L1427 , GLIB_000:def 16;
L1435: ( D144 . C267 ) in D151 by L1428 , XBOOLE_0:def 3;
L1436:
now
per cases ;
suppose L1437: ( D143 . C267 ) in { D145 };

L1438: C267 DSJoins C259 , { D145 } , C253 by L1437 , L1426 , L1428 , GLIB_000:def 16;
L1439: C267 in D154 by L1438 , GLIB_000:def 31;
L1440: C267 in ( D147 \/ D154 ) by L1439 , XBOOLE_0:def 3;
thus L1441: C267 in ( ( D147 \/ D154 ) \ D149 ) by L1440 , L1429 , XBOOLE_0:def 5;
end;
suppose L1442: (not ( D143 . C267 ) in { D145 });

L1443: ( D143 . C267 ) in ( D141 \ D151 ) by L1442 , L1272 , L1434 , XBOOLE_0:def 5;
L1444: C267 DSJoins D151 , ( D141 \ D151 ) , C253 by L1443 , L1426 , L1435 , GLIB_000:def 16;
L1445: C267 in D147 by L1444 , GLIB_000:def 31;
L1446: C267 in ( D147 \/ D154 ) by L1445 , XBOOLE_0:def 3;
thus L1447: C267 in ( ( D147 \/ D154 ) \ D149 ) by L1446 , L1429 , XBOOLE_0:def 5;
end;
end;
thus L1449: C267 in ( ( D147 \/ D154 ) \ D149 ) by L1436;
end;
assume L1450: C267 in ( ( D147 \/ D154 ) \ D149 );
L1451: (not C267 in D149) by L1450 , XBOOLE_0:def 5;
L1452: (not C267 DSJoins { D145 } , ( D141 \ D151 ) , C253) by L1451 , GLIB_000:def 31;
L1453:
now
per cases  by L1450 , L1424 , XBOOLE_0:def 3;
suppose L1454: C267 in D147;

L1455: C267 DSJoins D151 , ( D141 \ D151 ) , C253 by L1454 , GLIB_000:def 31;
L1456: ( D144 . C267 ) in D151 by L1455 , GLIB_000:def 16;
L1457: ( D143 . C267 ) in ( D141 \ D151 ) by L1455 , GLIB_000:def 16;
L1458: (not ( D143 . C267 ) in D151) by L1457 , XBOOLE_0:def 5;
L1459: (not ( D143 . C267 ) in C259) by L1458 , XBOOLE_0:def 3;
L1460: ( D143 . C267 ) in ( D141 \ C259 ) by L1459 , L1457 , XBOOLE_0:def 5;
L1461: (not ( D144 . C267 ) in { D145 }) by L1452 , L1454 , L1457 , GLIB_000:def 16;
L1462: ( D144 . C267 ) in ( D151 \ { D145 } ) by L1461 , L1456 , XBOOLE_0:def 5;
L1463: ( D144 . C267 ) in ( C259 \ { D145 } ) by L1462 , XBOOLE_1:40;
thus L1464: C267 DSJoins C259 , ( D141 \ C259 ) , C253 by L1463 , L1422 , L1454 , L1460 , GLIB_000:def 16;
end;
suppose L1465: C267 in D154;

L1466: C267 DSJoins C259 , { D145 } , C253 by L1465 , GLIB_000:def 31;
L1467: ( D144 . C267 ) in C259 by L1466 , GLIB_000:def 16;
L1468: ( D143 . C267 ) in { D145 } by L1466 , GLIB_000:def 16;
L1469: (not ( D143 . C267 ) in C259) by L1468 , L1411 , TARSKI:def 1;
L1470: ( D143 . C267 ) in D141 by L1465 , FUNCT_2:5;
L1471: ( D143 . C267 ) in ( D141 \ C259 ) by L1470 , L1469 , XBOOLE_0:def 5;
thus L1472: C267 DSJoins C259 , ( D141 \ C259 ) , C253 by L1471 , L1465 , L1467 , GLIB_000:def 16;
end;
end;
thus L1474: C267 in ( C253 .edgesDBetween (C259 , ( D141 \ C259 )) ) by L1453 , GLIB_000:def 31;
end;
L1475: ( C253 .edgesDBetween (C259 , ( D141 \ C259 )) ) = ( ( D147 \/ D154 ) \ D149 ) by L1423 , TARSKI:1;
L1476:
now
let C268 being set;
L1477: ( (( D148 \/ D153 ) qua set) \ D150 ) is (Subset of ( D148 \/ D153 ));
thus L1478:now
assume L1479: C268 in ( C253 .edgesDBetween (( D141 \ C259 ) , C259) );
L1480: C268 DSJoins ( D141 \ C259 ) , C259 , C253 by L1479 , GLIB_000:def 31;
L1481: ( D143 . C268 ) in C259 by L1480 , GLIB_000:def 16;
L1482:
now
assume L1483: C268 in D150;
L1484: C268 DSJoins ( D141 \ D151 ) , { D145 } , C253 by L1483 , GLIB_000:def 31;
L1485: ( D143 . C268 ) in { D145 } by L1484 , GLIB_000:def 16;
thus L1486: contradiction by L1485 , L1411 , L1481 , TARSKI:def 1;
end;
L1487: ( D144 . C268 ) in ( D141 \ C259 ) by L1480 , GLIB_000:def 16;
L1488: ( D143 . C268 ) in D151 by L1481 , XBOOLE_0:def 3;
L1489:
now
per cases ;
suppose L1490: ( D144 . C268 ) in { D145 };

L1491: C268 DSJoins { D145 } , C259 , C253 by L1490 , L1479 , L1481 , GLIB_000:def 16;
L1492: C268 in D153 by L1491 , GLIB_000:def 31;
L1493: C268 in ( D148 \/ D153 ) by L1492 , XBOOLE_0:def 3;
thus L1494: C268 in ( ( D148 \/ D153 ) \ D150 ) by L1493 , L1482 , XBOOLE_0:def 5;
end;
suppose L1495: (not ( D144 . C268 ) in { D145 });

L1496: ( D144 . C268 ) in ( D141 \ D151 ) by L1495 , L1272 , L1487 , XBOOLE_0:def 5;
L1497: C268 DSJoins ( D141 \ D151 ) , D151 , C253 by L1496 , L1479 , L1488 , GLIB_000:def 16;
L1498: C268 in D148 by L1497 , GLIB_000:def 31;
L1499: C268 in ( D148 \/ D153 ) by L1498 , XBOOLE_0:def 3;
thus L1500: C268 in ( ( D148 \/ D153 ) \ D150 ) by L1499 , L1482 , XBOOLE_0:def 5;
end;
end;
thus L1502: C268 in ( ( D148 \/ D153 ) \ D150 ) by L1489;
end;
assume L1503: C268 in ( ( D148 \/ D153 ) \ D150 );
L1504: (not C268 in D150) by L1503 , XBOOLE_0:def 5;
L1505: (not C268 DSJoins ( D141 \ D151 ) , { D145 } , C253) by L1504 , GLIB_000:def 31;
L1506:
now
per cases  by L1503 , L1477 , XBOOLE_0:def 3;
suppose L1507: C268 in D148;

L1508: C268 DSJoins ( D141 \ D151 ) , D151 , C253 by L1507 , GLIB_000:def 31;
L1509: ( D143 . C268 ) in D151 by L1508 , GLIB_000:def 16;
L1510: ( D144 . C268 ) in ( D141 \ D151 ) by L1508 , GLIB_000:def 16;
L1511: (not ( D144 . C268 ) in D151) by L1510 , XBOOLE_0:def 5;
L1512: (not ( D144 . C268 ) in C259) by L1511 , XBOOLE_0:def 3;
L1513: ( D144 . C268 ) in ( D141 \ C259 ) by L1512 , L1510 , XBOOLE_0:def 5;
L1514: (not ( D143 . C268 ) in { D145 }) by L1505 , L1507 , L1510 , GLIB_000:def 16;
L1515: ( D143 . C268 ) in ( D151 \ { D145 } ) by L1514 , L1509 , XBOOLE_0:def 5;
L1516: ( D143 . C268 ) in ( C259 \ { D145 } ) by L1515 , XBOOLE_1:40;
thus L1517: C268 DSJoins ( D141 \ C259 ) , C259 , C253 by L1516 , L1422 , L1507 , L1513 , GLIB_000:def 16;
end;
suppose L1518: C268 in D153;

L1519: C268 DSJoins { D145 } , C259 , C253 by L1518 , GLIB_000:def 31;
L1520: ( D143 . C268 ) in C259 by L1519 , GLIB_000:def 16;
L1521: ( D144 . C268 ) in { D145 } by L1519 , GLIB_000:def 16;
L1522: (not ( D144 . C268 ) in C259) by L1521 , L1411 , TARSKI:def 1;
L1523: ( D144 . C268 ) in D141 by L1518 , FUNCT_2:5;
L1524: ( D144 . C268 ) in ( D141 \ C259 ) by L1523 , L1522 , XBOOLE_0:def 5;
thus L1525: C268 DSJoins ( D141 \ C259 ) , C259 , C253 by L1524 , L1518 , L1520 , GLIB_000:def 16;
end;
end;
thus L1527: C268 in ( C253 .edgesDBetween (( D141 \ C259 ) , C259) ) by L1506 , GLIB_000:def 31;
end;
L1528: ( C253 .edgesDBetween (( D141 \ C259 ) , C259) ) = D159 by L1476 , TARSKI:1;
L1529: ( dom ( C254 | D159 ) ) = ( D158 \ D150 ) by PARTFUN1:def 2;
L1530:
now
let C269 being set;
assume L1531: C269 in ( dom ( C254 | D158 ) );
L1532: C269 in D158 by L1531;
L1533:
now
per cases ;
suppose L1534: (not C269 in D150);

L1535: C269 in D159 by L1534 , L1532 , XBOOLE_0:def 5;
thus L1536: ( ( ( C254 | D150 ) +* ( C254 | D159 ) ) . C269 ) = ( ( C254 | D159 ) . C269 ) by L1535 , L1529 , FUNCT_4:13
.= ( C254 . C269 ) by L1535 , FUNCT_1:49;
end;
suppose L1537: C269 in D150;

L1538: (not C269 in D159) by L1537 , XBOOLE_0:def 5;
thus L1539: ( ( ( C254 | D150 ) +* ( C254 | D159 ) ) . C269 ) = ( ( C254 | D150 ) . C269 ) by L1538 , L1529 , FUNCT_4:11
.= ( C254 . C269 ) by L1537 , FUNCT_1:49;
end;
end;
thus L1541: ( ( C254 | D158 ) . C269 ) = ( ( ( C254 | D150 ) +* ( C254 | D159 ) ) . C269 ) by L1533 , L1532 , FUNCT_1:49;
end;
L1542: ( dom ( C254 | D153 ) ) = D153 by PARTFUN1:def 2;
L1543: ( dom ( ( C254 | D153 ) +* ( C254 | D160 ) ) ) = ( D153 \/ D160 ) by L1542 , L1359 , FUNCT_4:def 1
.= ( D153 \/ ( D148 \/ D153 ) ) by XBOOLE_1:39
.= D158 by XBOOLE_1:6;
L1544: ( Sum ( C254 | D158 ) ) = ( ( Sum ( C254 | D153 ) ) + ( Sum ( C254 | D148 ) ) ) by L1543 , L1294 , L1372 , L1360 , FUNCT_1:2 , GLIB_004:3;
L1545: ( dom ( C254 | D150 ) ) = D150 by PARTFUN1:def 2;
L1546: ( dom ( ( C254 | D150 ) +* ( C254 | D159 ) ) ) = ( D150 \/ ( D158 \ D150 ) ) by L1545 , L1529 , FUNCT_4:def 1
.= ( D150 \/ ( D148 \/ D153 ) ) by XBOOLE_1:39
.= D158 by L1410 , XBOOLE_1:10 , XBOOLE_1:12;
L1547: ( Sum ( C254 | D158 ) ) = ( ( Sum ( C254 | D159 ) ) + ( Sum ( C254 | D150 ) ) ) by L1546 , L1372 , L1530 , FUNCT_1:2 , GLIB_004:3;
L1548: ( dom ( C254 | D154 ) ) = D154 by PARTFUN1:def 2;
L1549: ( dom ( ( C254 | D154 ) +* ( C254 | D157 ) ) ) = ( D154 \/ D157 ) by L1548 , L1317 , FUNCT_4:def 1
.= ( D154 \/ ( D147 \/ D154 ) ) by XBOOLE_1:39
.= D155 by XBOOLE_1:6;
L1550: ( Sum ( C254 | D155 ) ) = ( ( Sum ( C254 | D154 ) ) + ( Sum ( C254 | D147 ) ) ) by L1549 , L1316 , L1281 , L1318 , FUNCT_1:2 , GLIB_004:3;
reconsider D165 = ( D164 \ D154 ) as (Subset of ( the_Edges_of C253 ));
L1551: ( dom ( C254 | D165 ) ) = ( D164 \ D154 ) by PARTFUN1:def 2;
L1552:
now
let C270 being set;
assume L1553: C270 in D153;
L1554: C270 DSJoins { D145 } , C259 , C253 by L1553 , GLIB_000:def 31;
L1555: ( D143 . C270 ) in C259 by L1554 , GLIB_000:def 16;
L1556: (not ( D143 . C270 ) in { D145 }) by L1555 , L1411 , TARSKI:def 1;
L1557: ( D143 . C270 ) in ( D141 \ { D145 } ) by L1556 , L1555 , XBOOLE_0:def 5;
L1558: ( D144 . C270 ) in { D145 } by L1554 , GLIB_000:def 16;
L1559: C270 DSJoins { D145 } , ( D141 \ { D145 } ) , C253 by L1558 , L1553 , L1557 , GLIB_000:def 16;
thus L1560: C270 in D152 by L1559 , GLIB_000:def 31;
end;
L1561: D153 c= D152 by L1552 , TARSKI:def 3;
L1562: ( dom ( C254 | D156 ) ) = ( D155 \ D149 ) by PARTFUN1:def 2;
L1563:
now
let C271 being set;
assume L1564: C271 in ( dom ( C254 | D155 ) );
L1565: C271 in D155 by L1564;
L1566:
now
per cases ;
suppose L1567: (not C271 in D149);

L1568: C271 in D156 by L1567 , L1565 , XBOOLE_0:def 5;
thus L1569: ( ( ( C254 | D149 ) +* ( C254 | D156 ) ) . C271 ) = ( ( C254 | D156 ) . C271 ) by L1568 , L1562 , FUNCT_4:13
.= ( C254 . C271 ) by L1568 , FUNCT_1:49;
end;
suppose L1570: C271 in D149;

L1571: (not C271 in D156) by L1570 , XBOOLE_0:def 5;
thus L1572: ( ( ( C254 | D149 ) +* ( C254 | D156 ) ) . C271 ) = ( ( C254 | D149 ) . C271 ) by L1571 , L1562 , FUNCT_4:11
.= ( C254 . C271 ) by L1570 , FUNCT_1:49;
end;
end;
thus L1574: ( ( C254 | D155 ) . C271 ) = ( ( ( C254 | D149 ) +* ( C254 | D156 ) ) . C271 ) by L1566 , L1565 , FUNCT_1:49;
end;
L1575: ( dom ( C254 | D164 ) ) = D164 by PARTFUN1:def 2;
L1576:
now
let C272 being set;
assume L1577: C272 in ( dom ( C254 | D164 ) );
L1578: C272 in D164 by L1577;
L1579:
now
per cases ;
suppose L1580: C272 in D154;

L1581: (not C272 in D165) by L1580 , XBOOLE_0:def 5;
thus L1582: ( ( ( C254 | D154 ) +* ( C254 | D165 ) ) . C272 ) = ( ( C254 | D154 ) . C272 ) by L1581 , L1551 , FUNCT_4:11
.= ( C254 . C272 ) by L1580 , FUNCT_1:49;
end;
suppose L1583: (not C272 in D154);

L1584: C272 in D165 by L1583 , L1578 , XBOOLE_0:def 5;
thus L1585: ( ( ( C254 | D154 ) +* ( C254 | D165 ) ) . C272 ) = ( ( C254 | D165 ) . C272 ) by L1584 , L1551 , FUNCT_4:13
.= ( C254 . C272 ) by L1584 , FUNCT_1:49;
end;
end;
thus L1587: ( ( C254 | D164 ) . C272 ) = ( ( ( C254 | D154 ) +* ( C254 | D165 ) ) . C272 ) by L1579 , L1577 , FUNCT_1:49;
end;
L1588: ( dom ( C254 | D154 ) ) = D154 by PARTFUN1:def 2;
L1589: ( dom ( ( C254 | D154 ) +* ( C254 | ( D164 \ D154 ) ) ) ) = ( D154 \/ ( D164 \ D154 ) ) by L1588 , L1551 , FUNCT_4:def 1
.= ( D154 \/ D164 ) by XBOOLE_1:39
.= D164 by L1421 , XBOOLE_1:12;
L1590: ( ( Sum ( C254 | D154 ) ) + ( Sum ( C254 | D150 ) ) ) = ( Sum ( C254 | D164 ) ) by L1589 , L1401 , L1575 , L1576 , FUNCT_1:2 , GLIB_004:3;
L1591: ( dom ( C254 | D149 ) ) = D149 by PARTFUN1:def 2;
L1592: ( dom ( ( C254 | D149 ) +* ( C254 | D156 ) ) ) = ( D149 \/ ( D155 \ D149 ) ) by L1591 , L1562 , FUNCT_4:def 1
.= ( D149 \/ ( D147 \/ D154 ) ) by XBOOLE_1:39
.= D155 by L1303 , XBOOLE_1:10 , XBOOLE_1:12;
L1593: ( Sum ( C254 | D155 ) ) = ( ( Sum ( C254 | D156 ) ) + ( Sum ( C254 | D149 ) ) ) by L1592 , L1281 , L1563 , FUNCT_1:2 , GLIB_004:3;
L1594: ( dom ( C254 | D163 ) ) = ( D152 \ D153 ) by PARTFUN1:def 2;
L1595: ( dom ( C254 | D152 ) ) = D152 by PARTFUN1:def 2;
L1596:
now
let C273 being set;
assume L1597: C273 in ( dom ( C254 | D152 ) );
L1598: C273 in D152 by L1597;
L1599:
now
per cases ;
suppose L1600: C273 in D153;

L1601: (not C273 in D163) by L1600 , XBOOLE_0:def 5;
thus L1602: ( ( ( C254 | D153 ) +* ( C254 | D163 ) ) . C273 ) = ( ( C254 | D153 ) . C273 ) by L1601 , L1594 , FUNCT_4:11
.= ( C254 . C273 ) by L1600 , FUNCT_1:49;
end;
suppose L1603: (not C273 in D153);

L1604: C273 in D163 by L1603 , L1598 , XBOOLE_0:def 5;
thus L1605: ( ( ( C254 | D153 ) +* ( C254 | D163 ) ) . C273 ) = ( ( C254 | D163 ) . C273 ) by L1604 , L1594 , FUNCT_4:13
.= ( C254 . C273 ) by L1604 , FUNCT_1:49;
end;
end;
thus L1607: ( ( C254 | D152 ) . C273 ) = ( ( ( C254 | D153 ) +* ( C254 | D163 ) ) . C273 ) by L1599 , L1597 , FUNCT_1:49;
end;
L1608: ( dom ( C254 | D153 ) ) = D153 by PARTFUN1:def 2;
L1609: ( dom ( ( C254 | D153 ) +* ( C254 | ( D152 \ D153 ) ) ) ) = ( D153 \/ ( D152 \ D153 ) ) by L1608 , L1594 , FUNCT_4:def 1
.= ( D153 \/ D152 ) by XBOOLE_1:39
.= D152 by L1561 , XBOOLE_1:12;
L1610: ( ( Sum ( C254 | D153 ) ) + ( Sum ( C254 | D149 ) ) ) = ( Sum ( C254 | D152 ) ) by L1609 , L1358 , L1595 , L1596 , FUNCT_1:2 , GLIB_004:3;
reconsider D166 = D145 as (Vertex of C253) by L1270;
L1611: ( D166 .edgesOut() ) = ( C253 .edgesDBetween ({ D166 } , D141) ) by GLIB_000:39;
reconsider D167 = ( ( C253 .edgesDBetween ({ D166 } , D141) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) as (Subset of ( the_Edges_of C253 ));
reconsider D168 = ( ( C253 .edgesDBetween (D141 , { D166 }) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) as (Subset of ( the_Edges_of C253 ));
L1612: ( dom ( C254 | ( C253 .edgesDBetween (D141 , { D166 }) ) ) ) = ( C253 .edgesDBetween (D141 , { D166 }) ) by PARTFUN1:def 2;
L1613:
now
let C274 being set;
thus L1614:now
assume L1615: C274 in ( ( C253 .edgesDBetween (D141 , { D166 }) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) );
L1616: C274 in ( C253 .edgesDBetween (D141 , { D166 }) ) by L1615 , XBOOLE_0:def 5;
L1617: C274 DSJoins D141 , { D166 } , C253 by L1616 , GLIB_000:def 31;
L1618: ( D144 . C274 ) in D141 by L1617 , GLIB_000:def 16;
L1619: ( D143 . C274 ) in { D166 } by L1617 , GLIB_000:def 16;
L1620: (not C274 in ( C253 .edgesDBetween ({ D166 } , { D166 }) )) by L1615 , XBOOLE_0:def 5;
L1621: (not C274 DSJoins { D166 } , { D166 } , C253) by L1620 , GLIB_000:def 31;
L1622: (not ( D144 . C274 ) in { D166 }) by L1621 , L1615 , L1619 , GLIB_000:def 16;
L1623: ( D144 . C274 ) in ( D141 \ { D166 } ) by L1622 , L1618 , XBOOLE_0:def 5;
L1624: C274 DSJoins ( D141 \ { D166 } ) , { D166 } , C253 by L1623 , L1615 , L1619 , GLIB_000:def 16;
thus L1625: C274 in D164 by L1624 , GLIB_000:def 31;
end;
assume L1626: C274 in D164;
L1627: C274 DSJoins ( D141 \ { D166 } ) , { D166 } , C253 by L1626 , GLIB_000:def 31;
L1628: ( D144 . C274 ) in ( D141 \ { D166 } ) by L1627 , GLIB_000:def 16;
L1629: (not ( D144 . C274 ) in { D166 }) by L1628 , XBOOLE_0:def 5;
L1630: (not C274 DSJoins { D166 } , { D166 } , C253) by L1629 , GLIB_000:def 16;
L1631: (not C274 in ( C253 .edgesDBetween ({ D166 } , { D166 }) )) by L1630 , GLIB_000:def 31;
L1632: ( D143 . C274 ) in { D166 } by L1627 , GLIB_000:def 16;
L1633: C274 DSJoins D141 , { D166 } , C253 by L1632 , L1626 , L1628 , GLIB_000:def 16;
L1634: C274 in ( C253 .edgesDBetween (D141 , { D166 }) ) by L1633 , GLIB_000:def 31;
thus L1635: C274 in ( ( C253 .edgesDBetween (D141 , { D166 }) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) by L1634 , L1631 , XBOOLE_0:def 5;
end;
L1636: ( ( C253 .edgesDBetween (D141 , { D166 }) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) = D164 by L1613 , TARSKI:1;
L1637: ( dom ( C254 | D168 ) ) = D168 by PARTFUN1:def 2;
L1638:
now
let C275 being set;
assume L1639: C275 in ( dom ( C254 | ( C253 .edgesDBetween (D141 , { D166 }) ) ) );
L1640: C275 in ( C253 .edgesDBetween (D141 , { D166 }) ) by L1639;
L1641:
now
per cases ;
suppose L1642: C275 in ( C253 .edgesDBetween ({ D166 } , { D166 }) );

L1643: (not C275 in D168) by L1642 , XBOOLE_0:def 5;
thus L1644: ( ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D168 ) ) . C275 ) = ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) . C275 ) by L1643 , L1637 , FUNCT_4:11
.= ( C254 . C275 ) by L1642 , FUNCT_1:49;
end;
suppose L1645: (not C275 in ( C253 .edgesDBetween ({ D166 } , { D166 }) ));

L1646: C275 in D168 by L1645 , L1640 , XBOOLE_0:def 5;
thus L1647: ( ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D168 ) ) . C275 ) = ( ( C254 | D168 ) . C275 ) by L1646 , L1637 , FUNCT_4:13
.= ( C254 . C275 ) by L1646 , FUNCT_1:49;
end;
end;
thus L1649: ( ( C254 | ( C253 .edgesDBetween (D141 , { D166 }) ) ) . C275 ) = ( ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D168 ) ) . C275 ) by L1641 , L1640 , FUNCT_1:49;
end;
L1650:
now
let C276 being set;
thus L1651:now
assume L1652: C276 in ( ( C253 .edgesDBetween ({ D166 } , D141) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) );
L1653: C276 in ( C253 .edgesDBetween ({ D166 } , D141) ) by L1652 , XBOOLE_0:def 5;
L1654: C276 DSJoins { D166 } , D141 , C253 by L1653 , GLIB_000:def 31;
L1655: ( D143 . C276 ) in D141 by L1654 , GLIB_000:def 16;
L1656: ( D144 . C276 ) in { D166 } by L1654 , GLIB_000:def 16;
L1657: (not C276 in ( C253 .edgesDBetween ({ D166 } , { D166 }) )) by L1652 , XBOOLE_0:def 5;
L1658: (not C276 DSJoins { D166 } , { D166 } , C253) by L1657 , GLIB_000:def 31;
L1659: (not ( D143 . C276 ) in { D166 }) by L1658 , L1652 , L1656 , GLIB_000:def 16;
L1660: ( D143 . C276 ) in ( D141 \ { D166 } ) by L1659 , L1655 , XBOOLE_0:def 5;
L1661: C276 DSJoins { D166 } , ( D141 \ { D166 } ) , C253 by L1660 , L1652 , L1656 , GLIB_000:def 16;
thus L1662: C276 in D152 by L1661 , GLIB_000:def 31;
end;
assume L1663: C276 in D152;
L1664: C276 DSJoins { D166 } , ( D141 \ { D166 } ) , C253 by L1663 , GLIB_000:def 31;
L1665: ( D143 . C276 ) in ( D141 \ { D166 } ) by L1664 , GLIB_000:def 16;
L1666: (not ( D143 . C276 ) in { D166 }) by L1665 , XBOOLE_0:def 5;
L1667: (not C276 DSJoins { D166 } , { D166 } , C253) by L1666 , GLIB_000:def 16;
L1668: (not C276 in ( C253 .edgesDBetween ({ D166 } , { D166 }) )) by L1667 , GLIB_000:def 31;
L1669: ( D144 . C276 ) in { D166 } by L1664 , GLIB_000:def 16;
L1670: C276 DSJoins { D166 } , D141 , C253 by L1669 , L1663 , L1665 , GLIB_000:def 16;
L1671: C276 in ( C253 .edgesDBetween ({ D166 } , D141) ) by L1670 , GLIB_000:def 31;
thus L1672: C276 in ( ( C253 .edgesDBetween ({ D166 } , D141) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) by L1671 , L1668 , XBOOLE_0:def 5;
end;
L1673: ( ( C253 .edgesDBetween ({ D166 } , D141) ) \ ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) = D152 by L1650 , TARSKI:1;
L1674: ( dom ( C254 | ( C253 .edgesDBetween ({ D166 } , D141) ) ) ) = ( C253 .edgesDBetween ({ D166 } , D141) ) by PARTFUN1:def 2;
L1675: ( dom ( C254 | D167 ) ) = D167 by PARTFUN1:def 2;
L1676:
now
let C277 being set;
assume L1677: C277 in ( dom ( C254 | ( C253 .edgesDBetween ({ D166 } , D141) ) ) );
L1678: C277 in ( C253 .edgesDBetween ({ D166 } , D141) ) by L1677;
L1679:
now
per cases ;
suppose L1680: C277 in ( C253 .edgesDBetween ({ D166 } , { D166 }) );

L1681: (not C277 in D167) by L1680 , XBOOLE_0:def 5;
thus L1682: ( ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D167 ) ) . C277 ) = ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) . C277 ) by L1681 , L1675 , FUNCT_4:11
.= ( C254 . C277 ) by L1680 , FUNCT_1:49;
end;
suppose L1683: (not C277 in ( C253 .edgesDBetween ({ D166 } , { D166 }) ));

L1684: C277 in D167 by L1683 , L1678 , XBOOLE_0:def 5;
thus L1685: ( ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D167 ) ) . C277 ) = ( ( C254 | D167 ) . C277 ) by L1684 , L1675 , FUNCT_4:13
.= ( C254 . C277 ) by L1684 , FUNCT_1:49;
end;
end;
thus L1687: ( ( C254 | ( C253 .edgesDBetween ({ D166 } , D141) ) ) . C277 ) = ( ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D167 ) ) . C277 ) by L1679 , L1678 , FUNCT_1:49;
end;
L1688: ( dom ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) ) = ( C253 .edgesDBetween ({ D166 } , { D166 }) ) by PARTFUN1:def 2;
L1689: ( dom ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D168 ) ) ) = ( ( C253 .edgesDBetween ({ D166 } , { D166 }) ) \/ D168 ) by L1688 , L1637 , FUNCT_4:def 1
.= ( ( C253 .edgesDBetween ({ D166 } , { D166 }) ) \/ ( C253 .edgesDBetween (D141 , { D166 }) ) ) by XBOOLE_1:39
.= ( C253 .edgesDBetween (D141 , { D166 }) ) by GLIB_000:38 , XBOOLE_1:12;
L1690: ( Sum ( C254 | ( C253 .edgesDBetween (D141 , { D166 }) ) ) ) = ( ( Sum ( C254 | D164 ) ) + ( Sum ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) ) ) by L1689 , L1636 , L1612 , L1638 , FUNCT_1:2 , GLIB_004:3;
L1691: ( dom ( ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) +* ( C254 | D167 ) ) ) = ( ( C253 .edgesDBetween ({ D166 } , { D166 }) ) \/ D167 ) by L1688 , L1675 , FUNCT_4:def 1
.= ( ( C253 .edgesDBetween ({ D166 } , { D166 }) ) \/ ( C253 .edgesDBetween ({ D166 } , D141) ) ) by XBOOLE_1:39
.= ( C253 .edgesDBetween ({ D166 } , D141) ) by GLIB_000:38 , XBOOLE_1:12;
L1692: ( Sum ( C254 | ( C253 .edgesDBetween ({ D166 } , D141) ) ) ) = ( ( Sum ( C254 | D152 ) ) + ( Sum ( C254 | ( C253 .edgesDBetween ({ D166 } , { D166 }) ) ) ) ) by L1691 , L1673 , L1674 , L1676 , FUNCT_1:2 , GLIB_004:3;
L1693: ( D166 .edgesIn() ) = ( C253 .edgesDBetween (D141 , { D166 }) ) by GLIB_000:39;
L1694: ( Sum ( C254 | ( C253 .edgesDBetween (D141 , { D166 }) ) ) ) = ( Sum ( C254 | ( C253 .edgesDBetween ({ D166 } , D141) ) ) ) by L1693 , L1252 , L1264 , L1411 , L1277 , L1611 , L34;
thus L1695: ( C254 .flow (C255 , C256) ) = ( ( Sum ( C254 | ( C253 .edgesDBetween (C259 , ( D141 \ C259 )) ) ) ) - ( Sum ( C254 | ( C253 .edgesDBetween (( D141 \ C259 ) , C259) ) ) ) ) by L1694 , L1280 , L1475 , L1593 , L1550 , L1528 , L1547 , L1544 , L1590 , L1610 , L1690 , L1692;
end;
thus L1696: S18[ ( C258 + 1 ) ] by L1262;
end;
L1697:
now
set D169 = ( C253 .edgesDBetween ({ C256 } , { C256 }) );
let C278 being (Subset of D141);
assume that
L1698: ( card ( D141 \ C278 ) ) = 1
and
L1699: C255 in C278
and
L1700: (not C256 in C278);
reconsider D170 = ( ( C253 .edgesOutOf { C256 } ) \ D169 ) as (Subset of ( the_Edges_of C253 ));
consider C279 being set such that L1701: ( D141 \ C278 ) = { C279 } by L1698 , CARD_2:42;
L1702: C256 is (Vertex of C253) by L1252 , L34;
L1703: C256 in ( D141 \ C278 ) by L1702 , L1700 , XBOOLE_0:def 5;
L1704: C279 = C256 by L1703 , L1701 , TARSKI:def 1;
L1705:
now
let C280 being set;
thus L1706:now
assume L1707: C280 in ( D141 \ { C256 } );
L1708: (not C280 in { C256 }) by L1707 , XBOOLE_0:def 5;
thus L1709: C280 in C278 by L1708 , L1701 , L1704 , L1707 , XBOOLE_0:def 5;
end;
assume L1710: C280 in C278;
L1711: (not C280 in { C256 }) by L1710 , L1700 , TARSKI:def 1;
thus L1712: C280 in ( D141 \ { C256 } ) by L1711 , L1710 , XBOOLE_0:def 5;
end;
L1713: C278 = ( D141 \ { C256 } ) by L1705 , TARSKI:1;
L1714:
now
let C281 being set;
thus L1715:now
assume L1716: C281 in ( C253 .edgesDBetween (( D141 \ C278 ) , C278) );
L1717: C281 DSJoins { C256 } , ( D141 \ { C256 } ) , C253 by L1716 , L1701 , L1704 , L1713 , GLIB_000:def 31;
L1718: ( D143 . C281 ) in ( D141 \ { C256 } ) by L1717 , GLIB_000:def 16;
L1719:
now
assume L1720: C281 in D169;
L1721: C281 DSJoins { C256 } , { C256 } , C253 by L1720 , GLIB_000:def 31;
L1722: ( D143 . C281 ) in { C256 } by L1721 , GLIB_000:def 16;
thus L1723: contradiction by L1722 , L1718 , XBOOLE_0:def 5;
end;
L1724: ( D144 . C281 ) in { C256 } by L1717 , GLIB_000:def 16;
L1725: C281 in ( C253 .edgesOutOf { C256 } ) by L1724 , L1716 , GLIB_000:def 27;
thus L1726: C281 in D170 by L1725 , L1719 , XBOOLE_0:def 5;
end;
assume L1727: C281 in D170;
L1728: ( (( C253 .edgesOutOf { C256 } ) qua set) \ D169 ) is (Subset of ( C253 .edgesOutOf { C256 } ));
L1729: ( D144 . C281 ) in { C256 } by L1728 , L1727 , GLIB_000:def 27;
L1730: (not C281 in D169) by L1727 , XBOOLE_0:def 5;
L1731:
now
assume L1732: (not ( D143 . C281 ) in C278);
L1733: ( D143 . C281 ) in D141 by L1727 , FUNCT_2:5;
L1734: ( D143 . C281 ) in { C256 } by L1733 , L1713 , L1732 , XBOOLE_0:def 5;
L1735: C281 DSJoins { C256 } , { C256 } , C253 by L1734 , L1727 , L1729 , GLIB_000:def 16;
thus L1736: contradiction by L1735 , L1730 , GLIB_000:def 31;
end;
L1737: C281 DSJoins ( D141 \ C278 ) , C278 , C253 by L1731 , L1701 , L1704 , L1727 , L1729 , GLIB_000:def 16;
thus L1738: C281 in ( C253 .edgesDBetween (( D141 \ C278 ) , C278) ) by L1737 , GLIB_000:def 31;
end;
L1739: ( C253 .edgesDBetween (( D141 \ C278 ) , C278) ) = D170 by L1714 , TARSKI:1;
set D171 = ( C254 | D169 );
reconsider D172 = ( ( C253 .edgesInto { C256 } ) \ D169 ) as (Subset of ( the_Edges_of C253 ));
L1740: ( dom ( C254 | ( C253 .edgesInto { C256 } ) ) ) = ( C253 .edgesInto { C256 } ) by PARTFUN1:def 2;
L1741:
now
let C282 being set;
thus L1742:now
assume L1743: C282 in ( C253 .edgesDBetween (C278 , ( D141 \ C278 )) );
L1744: C282 DSJoins ( D141 \ { C256 } ) , { C256 } , C253 by L1743 , L1701 , L1704 , L1713 , GLIB_000:def 31;
L1745: ( D144 . C282 ) in ( D141 \ { C256 } ) by L1744 , GLIB_000:def 16;
L1746:
now
assume L1747: C282 in D169;
L1748: C282 DSJoins { C256 } , { C256 } , C253 by L1747 , GLIB_000:def 31;
L1749: ( D144 . C282 ) in { C256 } by L1748 , GLIB_000:def 16;
thus L1750: contradiction by L1749 , L1745 , XBOOLE_0:def 5;
end;
L1751: ( D143 . C282 ) in { C256 } by L1744 , GLIB_000:def 16;
L1752: C282 in ( C253 .edgesInto { C256 } ) by L1751 , L1743 , GLIB_000:def 26;
thus L1753: C282 in D172 by L1752 , L1746 , XBOOLE_0:def 5;
end;
assume L1754: C282 in D172;
L1755: ( (( C253 .edgesInto { C256 } ) qua set) \ D169 ) is (Subset of ( C253 .edgesInto { C256 } ));
L1756: ( D143 . C282 ) in { C256 } by L1755 , L1754 , GLIB_000:def 26;
L1757: (not C282 in D169) by L1754 , XBOOLE_0:def 5;
L1758:
now
assume L1759: (not ( D144 . C282 ) in C278);
L1760: (not ( D144 . C282 ) in ( D141 \ { C256 } )) by L1759 , L1705;
L1761: ( D144 . C282 ) in D141 by L1754 , FUNCT_2:5;
L1762: ( D144 . C282 ) in { C256 } by L1761 , L1760 , XBOOLE_0:def 5;
L1763: C282 DSJoins { C256 } , { C256 } , C253 by L1762 , L1754 , L1756 , GLIB_000:def 16;
thus L1764: contradiction by L1763 , L1757 , GLIB_000:def 31;
end;
L1765: C282 DSJoins C278 , { C256 } , C253 by L1758 , L1754 , L1756 , GLIB_000:def 16;
thus L1766: C282 in ( C253 .edgesDBetween (C278 , ( D141 \ C278 )) ) by L1765 , L1701 , L1704 , GLIB_000:def 31;
end;
L1767: ( C253 .edgesDBetween (C278 , ( D141 \ C278 )) ) = D172 by L1741 , TARSKI:1;
L1768:
now
let C283 being set;
assume L1769: C283 in D169;
L1770: C283 DSJoins { C256 } , { C256 } , C253 by L1769 , GLIB_000:def 31;
L1771: ( D144 . C283 ) in { C256 } by L1770 , GLIB_000:def 16;
thus L1772: C283 in ( C253 .edgesOutOf { C256 } ) by L1771 , L1769 , GLIB_000:def 27;
end;
L1773: D169 c= ( C253 .edgesOutOf { C256 } ) by L1768 , TARSKI:def 3;
L1774:
now
let C284 being set;
assume L1775: C284 in D169;
L1776: C284 DSJoins { C256 } , { C256 } , C253 by L1775 , GLIB_000:def 31;
L1777: ( D143 . C284 ) in { C256 } by L1776 , GLIB_000:def 16;
thus L1778: C284 in ( C253 .edgesInto { C256 } ) by L1777 , L1775 , GLIB_000:def 26;
end;
L1779: D169 c= ( C253 .edgesInto { C256 } ) by L1774 , TARSKI:def 3;
L1780: ( dom ( C254 | D169 ) ) = D169 by PARTFUN1:def 2;
L1781: ( dom ( C254 | D170 ) ) = D170 by PARTFUN1:def 2;
L1782:
now
let C285 being set;
assume L1783: C285 in ( dom ( C254 | ( C253 .edgesOutOf { C256 } ) ) );
L1784: C285 in ( C253 .edgesOutOf { C256 } ) by L1783;
L1785:
now
per cases ;
suppose L1786: C285 in D169;

L1787: (not C285 in D170) by L1786 , XBOOLE_0:def 5;
thus L1788: ( ( ( C254 | D169 ) +* ( C254 | D170 ) ) . C285 ) = ( ( C254 | D169 ) . C285 ) by L1787 , L1781 , FUNCT_4:11
.= ( C254 . C285 ) by L1780 , L1786 , FUNCT_1:47;
end;
suppose L1789: (not C285 in D169);

L1790: C285 in D170 by L1789 , L1784 , XBOOLE_0:def 5;
thus L1791: ( ( ( C254 | D169 ) +* ( C254 | D170 ) ) . C285 ) = ( ( C254 | D170 ) . C285 ) by L1790 , L1781 , FUNCT_4:13
.= ( C254 . C285 ) by L1781 , L1790 , FUNCT_1:47;
end;
end;
thus L1793: ( ( C254 | ( C253 .edgesOutOf { C256 } ) ) . C285 ) = ( ( ( C254 | D169 ) +* ( C254 | D170 ) ) . C285 ) by L1785 , L1783 , FUNCT_1:47;
end;
L1794: ( dom ( C254 | D172 ) ) = D172 by PARTFUN1:def 2;
L1795:
now
let C286 being set;
assume L1796: C286 in ( dom ( C254 | ( C253 .edgesInto { C256 } ) ) );
L1797: C286 in ( C253 .edgesInto { C256 } ) by L1796;
L1798:
now
per cases ;
suppose L1799: C286 in D169;

L1800: (not C286 in D172) by L1799 , XBOOLE_0:def 5;
thus L1801: ( ( ( C254 | D169 ) +* ( C254 | D172 ) ) . C286 ) = ( ( C254 | D169 ) . C286 ) by L1800 , L1794 , FUNCT_4:11
.= ( C254 . C286 ) by L1780 , L1799 , FUNCT_1:47;
end;
suppose L1802: (not C286 in D169);

L1803: C286 in D172 by L1802 , L1797 , XBOOLE_0:def 5;
thus L1804: ( ( ( C254 | D169 ) +* ( C254 | D172 ) ) . C286 ) = ( ( C254 | D172 ) . C286 ) by L1803 , L1794 , FUNCT_4:13
.= ( C254 . C286 ) by L1794 , L1803 , FUNCT_1:47;
end;
end;
thus L1806: ( ( C254 | ( C253 .edgesInto { C256 } ) ) . C286 ) = ( ( ( C254 | D169 ) +* ( C254 | D172 ) ) . C286 ) by L1798 , L1796 , FUNCT_1:47;
end;
L1807: ( D169 \/ D172 ) = ( ( C253 .edgesInto { C256 } ) \/ D169 ) by XBOOLE_1:39
.= ( C253 .edgesInto { C256 } ) by L1779 , XBOOLE_1:12;
L1808: ( dom ( ( C254 | D169 ) +* ( C254 | D172 ) ) ) = ( D169 \/ D172 ) by L1780 , L1794 , FUNCT_4:def 1;
L1809: ( Sum ( C254 | ( C253 .edgesInto { C256 } ) ) ) = ( ( Sum ( C254 | D172 ) ) + ( Sum D171 ) ) by L1808 , L1807 , L1740 , L1795 , FUNCT_1:2 , GLIB_004:3;
L1810: ( D169 \/ D170 ) = ( ( C253 .edgesOutOf { C256 } ) \/ D169 ) by XBOOLE_1:39
.= ( C253 .edgesOutOf { C256 } ) by L1773 , XBOOLE_1:12;
L1811: ( dom ( ( C254 | D169 ) +* ( C254 | D170 ) ) ) = ( C253 .edgesOutOf { C256 } ) by L1810 , L1780 , L1781 , FUNCT_4:def 1;
L1812: ( dom ( C254 | ( C253 .edgesOutOf { C256 } ) ) ) = ( C253 .edgesOutOf { C256 } ) by PARTFUN1:def 2;
L1813: ( C254 .flow (C255 , C256) ) = ( ( ( Sum ( C254 | D172 ) ) + ( Sum D171 ) ) - ( ( Sum D171 ) + ( Sum ( C254 | D170 ) ) ) ) by L1812 , L1809 , L1811 , L1782 , FUNCT_1:2 , GLIB_004:3
.= ( ( Sum ( C254 | D172 ) ) - ( Sum ( C254 | D170 ) ) );
thus L1814: ( C254 .flow (C255 , C256) ) = ( ( Sum ( C254 | ( C253 .edgesDBetween (C278 , ( D141 \ C278 )) ) ) ) - ( Sum ( C254 | ( C253 .edgesDBetween (( D141 \ C278 ) , C278) ) ) ) ) by L1813 , L1767 , L1739;
end;
L1815: S18[ 1 ] by L1697;
L1816: (for B198 being non  empty Nat holds S18[ B198 ]) from NAT_1:sch 10(L1815 , L1260);
thus L1817: thesis by L1816 , L1253 , L1254 , L1255;
end;
theorem
L1818: (for B199 being  finite  real-weighted WGraph holds (for B200 being (FF:ELabeling of B199) holds (for B201 , B202 being set holds (for B203 being (Subset of ( the_Vertices_of B199 )) holds ((B200 has_valid_flow_from B201 , B202 & B201 in B203 & (not B202 in B203)) implies ( B200 .flow (B201 , B202) ) <= ( Sum ( ( the_Weight_of B199 ) | ( B199 .edgesDBetween (B203 , ( ( the_Vertices_of B199 ) \ B203 )) ) ) ))))))
proof
let C287 being  finite  real-weighted WGraph;
let C288 being (FF:ELabeling of C287);
let C289 , C290 being set;
let C291 being (Subset of ( the_Vertices_of C287 ));
assume that
L1819: C288 has_valid_flow_from C289 , C290
and
L1820: C289 in C291
and
L1821: (not C290 in C291);
set D173 = ( ( the_Weight_of C287 ) | ( C287 .edgesDBetween (C291 , ( ( the_Vertices_of C287 ) \ C291 )) ) );
set D174 = ( C288 | ( C287 .edgesDBetween (( ( the_Vertices_of C287 ) \ C291 ) , C291) ) );
set D175 = ( C288 | ( C287 .edgesDBetween (C291 , ( ( the_Vertices_of C287 ) \ C291 )) ) );
L1822:
now
let C292 being set;
assume L1823: C292 in ( C287 .edgesDBetween (C291 , ( ( the_Vertices_of C287 ) \ C291 )) );
L1824: ( D173 . C292 ) = ( ( the_Weight_of C287 ) . C292 ) by L1823 , FUNCT_1:49;
L1825: ( D175 . C292 ) = ( C288 . C292 ) by L1823 , FUNCT_1:49;
thus L1826: ( D175 . C292 ) <= ( D173 . C292 ) by L1825 , L1819 , L1823 , L1824 , L34;
end;
L1827: ( Sum D175 ) <= ( Sum D173 ) by L1822 , GLIB_004:5;
L1828: ( ( Sum D175 ) - ( Sum D174 ) ) <= ( ( Sum D173 ) - ( Sum D174 ) ) by L1827 , XREAL_1:9;
set D176 = ( EmptyBag ( C287 .edgesDBetween (( ( the_Vertices_of C287 ) \ C291 ) , C291) ) );
L1829:
now
let C293 being set;
L1830: D176 = ( ( C287 .edgesDBetween (( ( the_Vertices_of C287 ) \ C291 ) , C291) ) --> ( 0 ) ) by PRE_POLY:def 13;
assume L1831: C293 in ( C287 .edgesDBetween (( ( the_Vertices_of C287 ) \ C291 ) , C291) );
thus L1832: ( D176 . C293 ) <= ( D174 . C293 ) by L1831 , L1830 , FUNCOP_1:7;
end;
L1833: ( Sum D176 ) = ( 0 ) by UPROOTS:11;
L1834: ( 0 ) <= ( Sum D174 ) by L1833 , L1829 , GLIB_004:5;
L1835: ( ( Sum D173 ) - ( Sum D174 ) ) <= ( ( Sum D173 ) - ( 0 ) ) by L1834 , XREAL_1:13;
L1836: ( C288 .flow (C289 , C290) ) = ( ( Sum D175 ) - ( Sum D174 ) ) by L1819 , L1820 , L1821 , L1251;
thus L1837: thesis by L1836 , L1835 , L1828 , XXREAL_0:2;
end;
theorem
L1838: (for B204 being  finite  natural-weighted WGraph holds (for B205 being (FF:ELabeling of B204) holds (for B206 being (Walk of B204) holds ((B206 is non  trivial & B206 is_augmenting_wrt B205) implies ( 0 ) < ( B206 .tolerance B205 )))))
proof
let C294 being  finite  natural-weighted WGraph;
let C295 being (FF:ELabeling of C294);
let C296 being (Walk of C294);
assume that
L1839: C296 is non  trivial
and
L1840: C296 is_augmenting_wrt C295;
set D177 = ( C296 .tolerance C295 );
L1841: D177 in ( rng ( C296 .flowSeq C295 ) ) by L1839 , L1840 , L1056;
consider C297 being Nat such that L1842: C297 in ( dom ( C296 .flowSeq C295 ) ) and L1843: D177 = ( ( C296 .flowSeq C295 ) . C297 ) by L1841 , FINSEQ_2:10;
reconsider D178 = C297 as (Element of ( NAT )) by ORDINAL1:def 12;
L1844: ( dom ( C296 .flowSeq C295 ) ) = ( dom ( C296 .edgeSeq() ) ) by L1840 , L1002;
L1845: ( 2 * D178 ) in ( dom C296 ) by L1844 , L1842 , GLIB_001:78;
L1846: 1 <= ( 2 * D178 ) by L1845 , FINSEQ_3:25;
reconsider D179 = ( ( 2 * D178 ) - 1 ) as  odd (Element of ( NAT )) by L1846 , INT_1:5;
L1847: ( 2 * D178 ) <= ( len C296 ) by L1845 , FINSEQ_3:25;
L1848: ( ( 2 * D178 ) - 1 ) < ( ( len C296 ) - ( 0 ) ) by L1847 , XREAL_1:15;
set D180 = ( C296 . D179 );
set D181 = ( C296 . ( 2 * D178 ) );
set D182 = ( C296 . ( ( 2 * D178 ) + 1 ) );
L1849: ( ( ( 2 * D178 ) - 1 ) + 2 ) = ( ( 2 * D178 ) + 1 );
L1850: ( ( ( 2 * D178 ) - 1 ) + 1 ) = ( 2 * D178 );
L1851:
now
per cases ;
suppose L1852: D181 DJoins D180 , D182 , C294;

L1853: D177 = ( ( ( the_Weight_of C294 ) . D181 ) - ( C295 . D181 ) ) by L1852 , L1840 , L1842 , L1843 , L1002;
L1854: ( C295 . D181 ) < ( ( the_Weight_of C294 ) . D181 ) by L1840 , L1848 , L1850 , L1849 , L1852 , L45;
L1855: ( ( C295 . D181 ) - ( C295 . D181 ) ) < D177 by L1854 , L1853 , XREAL_1:14;
thus L1856: thesis by L1855;
end;
suppose L1857: (not D181 DJoins D180 , D182 , C294);

L1858: D177 = ( C295 . D181 ) by L1857 , L1840 , L1842 , L1843 , L1002;
thus L1859: thesis by L1858 , L1840 , L1848 , L1850 , L1849 , L1857 , L45;
end;
end;
thus L1861: thesis by L1851;
end;
theorem
L1862: (for B207 being  finite  natural-weighted WGraph holds (for B208 being (FF:ELabeling of B207) holds (for B209 , B210 being set holds (for B211 being (Path of B207) holds ((B209 <> B210 & B208 has_valid_flow_from B209 , B210 & B211 is_Walk_from B209 , B210 & B211 is_augmenting_wrt B208) implies ( FF:PushFlow (B208 , B211) ) has_valid_flow_from B209 , B210)))))
proof
let C298 being  finite  natural-weighted WGraph;
let C299 being (FF:ELabeling of C298);
let C300 , C301 being set;
let C302 being (Path of C298);
assume that
L1863: C300 <> C301
and
L1864: C299 has_valid_flow_from C300 , C301
and
L1865: C302 is_Walk_from C300 , C301
and
L1866: C302 is_augmenting_wrt C299;
set D183 = ( FF:PushFlow (C299 , C302) );
L1867:
now
thus L1868: (C300 is (Vertex of C298) & C301 is (Vertex of C298)) by L1864 , L34;
L1869:
now
let C303 being set;
assume L1870: C303 in ( the_Edges_of C298 );
L1871: ( C299 . C303 ) <= ( ( the_Weight_of C298 ) . C303 ) by L1870 , L1864 , L34;
L1872:
now
per cases ;
suppose L1873: (not C303 in ( C302 .edges() ));

thus L1874: (( 0 ) <= ( D183 . C303 ) & ( D183 . C303 ) <= ( ( the_Weight_of C298 ) . C303 )) by L1873 , L1866 , L1870 , L1871 , L1083;
end;
suppose L1875: C303 in ( C302 .edges() );

consider C304 being  odd (Element of ( NAT )) such that L1876: C304 < ( len C302 ) and L1877: ( C302 . ( C304 + 1 ) ) = C303 by L1875 , GLIB_001:100;
set D184 = ( C302 .flowSeq C299 );
set D185 = ( ( C304 + 1 ) div 2 );
L1878: 1 <= ( C304 + 1 ) by NAT_1:11;
L1879: ( C304 + 1 ) <= ( len C302 ) by L1876 , NAT_1:13;
L1880: D185 in ( dom ( C302 .edgeSeq() ) ) by L1879 , L1878 , GLIB_001:77;
L1881: D185 in ( dom D184 ) by L1880 , L1866 , L1002;
L1882:
now
L1883: ( C304 + ( 0 ) ) < ( C304 + 2 ) by XREAL_1:8;
assume that
L1884: C303 DJoins ( C302 . C304 ) , ( C302 . ( C304 + 2 ) ) , C298
and
L1885: C303 DJoins ( C302 . ( C304 + 2 ) ) , ( C302 . C304 ) , C298;
L1886: ( ( the_Source_of C298 ) . C303 ) = ( C302 . C304 ) by L1884 , GLIB_000:def 14;
L1887: ( ( the_Source_of C298 ) . C303 ) = ( C302 . ( C304 + 2 ) ) by L1885 , GLIB_000:def 14;
L1888: ( C304 + 2 ) <= ( len C302 ) by L1876 , GLIB_001:1;
L1889: C304 = 1 by L1888 , L1886 , L1887 , L1883 , GLIB_001:def 28;
L1890: ( C302 . C304 ) = C300 by L1889 , L1865 , GLIB_001:17;
L1891: ( C304 + 2 ) = ( len C302 ) by L1886 , L1887 , L1883 , L1888 , GLIB_001:def 28;
thus L1892: contradiction by L1891 , L1863 , L1865 , L1886 , L1887 , L1890 , GLIB_001:17;
end;
L1893: ( C302 .last() ) = C301 by L1865 , GLIB_001:def 23;
L1894: ( C302 .first() ) = C300 by L1865 , GLIB_001:def 23;
L1895: C302 is non  trivial by L1894 , L1863 , L1893 , GLIB_001:127;
L1896: 2 divides ( C304 + 1 ) by PEPIN:22;
L1897: ( 2 * D185 ) = ( C304 + 1 ) by L1896 , NAT_D:3;
L1898: ( ( 2 * D185 ) - 1 ) = C304 by L1897;
L1899: ( ( 2 * D185 ) + 1 ) = ( C304 + 2 ) by L1897;
L1900: C303 Joins ( C302 . C304 ) , ( C302 . ( C304 + 2 ) ) , C298 by L1876 , L1877 , GLIB_001:def 3;
L1901:
now
per cases  by L1900 , GLIB_000:16;
suppose L1902: C303 DJoins ( C302 . C304 ) , ( C302 . ( C304 + 2 ) ) , C298;

L1903: ( D184 . D185 ) = ( ( ( the_Weight_of C298 ) . C303 ) - ( C299 . C303 ) ) by L1902 , L1866 , L1877 , L1881 , L1898 , L1899 , L1002;
L1904: ( ( ( the_Weight_of C298 ) . C303 ) - ( C299 . C303 ) ) in ( rng D184 ) by L1903 , L1881 , FUNCT_1:def 3;
L1905: ( C302 .tolerance C299 ) <= ( ( ( the_Weight_of C298 ) . C303 ) - ( C299 . C303 ) ) by L1904 , L1866 , L1895 , L1056;
thus L1906: ( 0 ) <= ( D183 . C303 );
L1907: ( ( C299 . C303 ) + ( C302 .tolerance C299 ) ) = ( D183 . C303 ) by L1866 , L1876 , L1877 , L1902 , L1083;
L1908: ( D183 . C303 ) <= ( ( ( ( the_Weight_of C298 ) . C303 ) - ( C299 . C303 ) ) + ( C299 . C303 ) ) by L1907 , L1905 , XREAL_1:7;
thus L1909: ( D183 . C303 ) <= ( ( the_Weight_of C298 ) . C303 ) by L1908;
end;
suppose L1910: C303 DJoins ( C302 . ( C304 + 2 ) ) , ( C302 . C304 ) , C298;

thus L1911: ( 0 ) <= ( D183 . C303 );
L1912: ( D183 . C303 ) = ( ( C299 . C303 ) - ( C302 .tolerance C299 ) ) by L1866 , L1876 , L1877 , L1882 , L1910 , L1083;
L1913: ( D183 . C303 ) <= ( ( C299 . C303 ) - ( 0 ) ) by L1912 , XREAL_1:13;
thus L1914: ( D183 . C303 ) <= ( ( the_Weight_of C298 ) . C303 ) by L1913 , L1871 , XXREAL_0:2;
end;
end;
thus L1916: (( 0 ) <= ( D183 . C303 ) & ( D183 . C303 ) <= ( ( the_Weight_of C298 ) . C303 )) by L1901;
end;
end;
thus L1918: (( 0 ) <= ( D183 . C303 ) & ( D183 . C303 ) <= ( ( the_Weight_of C298 ) . C303 )) by L1872;
end;
thus L1919: (for B212 being set holds (B212 in ( the_Edges_of C298 ) implies (( 0 ) <= ( D183 . B212 ) & ( D183 . B212 ) <= ( ( the_Weight_of C298 ) . B212 )))) by L1869;
let C305 being (Vertex of C298);
assume that
L1920: C305 <> C300
and
L1921: C305 <> C301;
L1922: ( Sum ( C299 | ( C305 .edgesIn() ) ) ) = ( Sum ( C299 | ( C305 .edgesOut() ) ) ) by L1864 , L1920 , L1921 , L34;
L1923:
now
per cases ;
suppose L1924: C305 in ( C302 .vertices() );

consider C306 being  odd (Element of ( NAT )) such that L1925: C306 <= ( len C302 ) and L1926: ( C302 . C306 ) = C305 by L1924 , GLIB_001:87;
L1927:
now
assume L1928: C306 = ( len C302 );
L1929: C305 = ( C302 .last() ) by L1928 , L1926 , GLIB_001:def 7
.= C301 by L1865 , GLIB_001:def 23;
thus L1930: contradiction by L1929 , L1921;
end;
L1931: C306 < ( len C302 ) by L1927 , L1925 , XXREAL_0:1;
L1932:
now
assume L1933: C306 = 1;
L1934: C305 = ( C302 .first() ) by L1933 , L1926 , GLIB_001:def 6
.= C300 by L1865 , GLIB_001:def 23;
thus L1935: contradiction by L1934 , L1920;
end;
L1936:
now
L1937: ( C306 + ( 0 ) ) < ( C306 + 2 ) by XREAL_1:8;
assume L1938: C305 = ( C302 . ( C306 + 2 ) );
L1939: ( C306 + 2 ) <= ( len C302 ) by L1931 , GLIB_001:1;
thus L1940: contradiction by L1939 , L1926 , L1932 , L1938 , L1937 , GLIB_001:def 28;
end;
L1941: 1 <= C306 by ABIAN:12;
L1942: 1 < C306 by L1941 , L1932 , XXREAL_0:1;
L1943: ( 1 + 1 ) <= C306 by L1942 , NAT_1:13;
reconsider D186 = ( C306 - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by L1943 , INT_1:5;
set D187 = ( C302 . ( D186 + 1 ) );
set D188 = ( C302 . ( C306 + 1 ) );
set D189 = ( C302 .tolerance C299 );
L1944: 1 <= ( D186 + 1 ) by NAT_1:11;
L1945: ( C302 . ( D186 + 2 ) ) = C305 by L1926;
L1946:
now
let C307 being set;
assume that
L1947: (C307 in ( C305 .edgesIn() ) or C307 in ( C305 .edgesOut() ))
and
L1948: C307 <> D187
and
L1949: C307 <> D188;
L1950:
now
assume L1951: C307 in ( C302 .edges() );
consider C308 , C309 being (Vertex of C298), C310 being  odd (Element of ( NAT )) such that L1952: ( C310 + 2 ) <= ( len C302 ) and L1953: C308 = ( C302 . C310 ) and L1954: C307 = ( C302 . ( C310 + 1 ) ) and L1955: C309 = ( C302 . ( C310 + 2 ) ) and L1956: C307 Joins C308 , C309 , C298 by L1951 , GLIB_001:103;
L1957:
now
per cases  by L1947;
suppose L1958: C307 in ( C305 .edgesIn() );

L1959: ( ( the_Target_of C298 ) . C307 ) = C305 by L1958 , GLIB_000:56;
thus L1960: (C308 = C305 or C309 = C305) by L1959 , L1956 , GLIB_000:def 13;
end;
suppose L1961: C307 in ( C305 .edgesOut() );

L1962: ( ( the_Source_of C298 ) . C307 ) = C305 by L1961 , GLIB_000:58;
thus L1963: (C308 = C305 or C309 = C305) by L1962 , L1956 , GLIB_000:def 13;
end;
end;
L1965: ( ( C310 + 2 ) - 2 ) < ( ( len C302 ) - ( 0 ) ) by L1952 , XREAL_1:15;
L1966:
now
per cases  by L1957;
suppose L1967: C308 = C305;

L1968:
now
per cases  by XXREAL_0:1;
suppose L1969: C310 < C306;

thus L1970: contradiction by L1969 , L1925 , L1926 , L1927 , L1953 , L1967 , GLIB_001:def 28;
end;
suppose L1971: C310 = C306;

thus L1972: contradiction by L1971 , L1949 , L1954;
end;
suppose L1973: C306 < C310;

thus L1974: contradiction by L1973 , L1926 , L1953 , L1965 , L1967 , GLIB_001:def 28;
end;
end;
thus L1976: contradiction by L1968;
end;
suppose L1977: C309 = C305;

L1978:
now
per cases  by XXREAL_0:1;
suppose L1979: ( C310 + 2 ) < C306;

thus L1980: contradiction by L1979 , L1925 , L1926 , L1927 , L1955 , L1977 , GLIB_001:def 28;
end;
suppose L1981: ( C310 + 2 ) = C306;

thus L1982: contradiction by L1981 , L1948 , L1954;
end;
suppose L1983: C306 < ( C310 + 2 );

thus L1984: contradiction by L1983 , L1926 , L1932 , L1952 , L1955 , L1977 , GLIB_001:def 28;
end;
end;
thus L1986: contradiction by L1978;
end;
end;
thus L1988: contradiction by L1966;
end;
thus L1989: (not C307 in ( C302 .edges() )) by L1950;
end;
L1990:
now
L1991: ( C306 + 2 ) <= ( len C302 ) by L1931 , GLIB_001:1;
L1992: ( C306 + ( 0 ) ) < ( C306 + 2 ) by XREAL_1:8;
assume that
L1993: D188 DJoins C305 , ( C302 . ( C306 + 2 ) ) , C298
and
L1994: D188 DJoins ( C302 . ( C306 + 2 ) ) , C305 , C298;
L1995: ( C302 . C306 ) = ( ( the_Source_of C298 ) . D188 ) by L1926 , L1993 , GLIB_000:def 14
.= ( C302 . ( C306 + 2 ) ) by L1994 , GLIB_000:def 14;
thus L1996: contradiction by L1995 , L1932 , L1992 , L1991 , GLIB_001:def 28;
end;
L1997: D186 < ( C306 - ( 0 ) ) by XREAL_1:15;
L1998: ( D186 + 1 ) < ( C306 + 1 ) by L1997 , XREAL_1:8;
L1999: ( C306 + 1 ) <= ( len C302 ) by L1931 , NAT_1:13;
L2000: D187 <> D188 by L1999 , L1944 , L1998 , GLIB_001:138;
L2001:
now
L2002: D186 < ( C306 - ( 0 ) ) by XREAL_1:15;
assume L2003: ( C302 . D186 ) = C305;
thus L2004: contradiction by L2003 , L1925 , L1926 , L1927 , L2002 , GLIB_001:def 28;
end;
L2005:
now
assume that
L2006: D187 DJoins ( C302 . D186 ) , C305 , C298
and
L2007: D187 DJoins C305 , ( C302 . D186 ) , C298;
L2008: ( C302 . D186 ) = ( ( the_Source_of C298 ) . D187 ) by L2006 , GLIB_000:def 14
.= C305 by L2007 , GLIB_000:def 14;
thus L2009: contradiction by L2008 , L2001;
end;
L2010: D186 < ( ( len C302 ) - ( 0 ) ) by L1925 , XREAL_1:15;
L2011: D187 Joins ( C302 . D186 ) , ( C302 . ( D186 + 2 ) ) , C298 by L2010 , GLIB_001:def 3;
L2012: D188 Joins C305 , ( C302 . ( C306 + 2 ) ) , C298 by L1926 , L1931 , GLIB_001:def 3;
L2013:
now
per cases  by L1926 , L2011 , L2012 , GLIB_000:16;
suppose L2014: (D187 DJoins ( C302 . D186 ) , C305 , C298 & D188 DJoins C305 , ( C302 . ( C306 + 2 ) ) , C298);

set D190 = ( ( C299 | ( C305 .edgesIn() ) ) +* ( D187 .--> ( ( C299 . D187 ) + D189 ) ) );
L2015: D187 in ( C305 .edgesIn() ) by L2014 , GLIB_000:57;
L2016: ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) ) = { D187 } by FUNCOP_1:13;
L2017: ( dom D190 ) = ( ( dom ( C299 | ( C305 .edgesIn() ) ) ) \/ { D187 } ) by L2016 , FUNCT_4:def 1
.= ( ( C305 .edgesIn() ) \/ { D187 } ) by PARTFUN1:def 2
.= ( C305 .edgesIn() ) by L2015 , ZFMISC_1:40;
reconsider D191 = D190 as (Rbag of ( C305 .edgesIn() )) by L2017 , PARTFUN1:def 2 , RELAT_1:def 18;
L2018:
now
let C311 being set;
assume L2019: C311 in ( dom ( D183 | ( C305 .edgesIn() ) ) );
L2020: C311 in ( C305 .edgesIn() ) by L2019;
L2021: ( ( the_Target_of C298 ) . C311 ) = C305 by L2020 , GLIB_000:56;
L2022:
now
per cases ;
suppose L2023: C311 = D187;

L2024: C311 in ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) ) by L2023 , L2016 , TARSKI:def 1;
thus L2025: ( D191 . C311 ) = ( ( D187 .--> ( ( C299 . D187 ) + D189 ) ) . D187 ) by L2024 , L2023 , FUNCT_4:13
.= ( ( C299 . D187 ) + D189 ) by FUNCOP_1:72
.= ( D183 . C311 ) by L1866 , L2010 , L1945 , L2014 , L2023 , L1083;
end;
suppose L2026: C311 <> D187;

L2027:
now
assume L2028: C311 in ( C302 .edges() );
consider C312 , C313 being (Vertex of C298), C314 being  odd (Element of ( NAT )) such that L2029: ( C314 + 2 ) <= ( len C302 ) and L2030: C312 = ( C302 . C314 ) and L2031: C311 = ( C302 . ( C314 + 1 ) ) and L2032: C313 = ( C302 . ( C314 + 2 ) ) and L2033: C311 Joins C312 , C313 , C298 by L2028 , GLIB_001:103;
L2034: ( ( C314 + 2 ) - 2 ) < ( ( len C302 ) - ( 0 ) ) by L2029 , XREAL_1:15;
L2035:
now
per cases  by L2021 , L2033 , GLIB_000:def 13;
suppose L2036: C305 = C312;

L2037:
now
per cases  by XXREAL_0:1;
suppose L2038: C314 < C306;

thus L2039: contradiction by L2038 , L1925 , L1926 , L1927 , L2030 , L2036 , GLIB_001:def 28;
end;
suppose L2040: C314 = C306;

L2041: ( ( C306 + 2 ) - 2 ) < ( ( C306 + 2 ) - ( 0 ) ) by XREAL_1:15;
L2042: ( C306 + 2 ) <= ( len C302 ) by L1931 , GLIB_001:1;
L2043: ( C302 . ( C306 + 2 ) ) = ( C302 . C306 ) by L1926 , L2014 , L2021 , L2031 , L2040 , GLIB_000:def 14;
thus L2044: contradiction by L2043 , L1932 , L2041 , L2042 , GLIB_001:def 28;
end;
suppose L2045: C306 < C314;

thus L2046: contradiction by L2045 , L1926 , L2030 , L2034 , L2036 , GLIB_001:def 28;
end;
end;
thus L2048: contradiction by L2037;
end;
suppose L2049: C305 = C313;

L2050:
now
per cases  by XXREAL_0:1;
suppose L2051: ( C314 + 2 ) < C306;

thus L2052: contradiction by L2051 , L1925 , L1926 , L1927 , L2032 , L2049 , GLIB_001:def 28;
end;
suppose L2053: ( C314 + 2 ) = C306;

thus L2054: contradiction by L2053 , L2026 , L2031;
end;
suppose L2055: C306 < ( C314 + 2 );

thus L2056: contradiction by L2055 , L1926 , L1932 , L2029 , L2032 , L2049 , GLIB_001:def 28;
end;
end;
thus L2058: contradiction by L2050;
end;
end;
thus L2060: contradiction by L2035;
end;
L2061: (not C311 in ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) )) by L2026 , TARSKI:def 1;
L2062: ( D191 . C311 ) = ( ( C299 | ( C305 .edgesIn() ) ) . C311 ) by L2061 , FUNCT_4:11
.= ( C299 . C311 ) by L2020 , FUNCT_1:49;
thus L2063: ( D183 . C311 ) = ( D191 . C311 ) by L2062 , L1866 , L2020 , L2027 , L1083;
end;
end;
thus L2065: ( ( D183 | ( C305 .edgesIn() ) ) . C311 ) = ( D191 . C311 ) by L2022 , L2020 , FUNCT_1:49;
end;
L2066: ( dom ( D183 | ( C305 .edgesIn() ) ) ) = ( C305 .edgesIn() ) by PARTFUN1:def 2;
L2067: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum D191 ) by L2066 , L2017 , L2018 , FUNCT_1:2;
L2068: ( dom ( D183 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
set D192 = ( ( C299 | ( C305 .edgesOut() ) ) +* ( D188 .--> ( ( C299 . D188 ) + D189 ) ) );
L2069: D188 in ( C305 .edgesOut() ) by L2014 , GLIB_000:59;
L2070: ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) ) = { D188 } by FUNCOP_1:13;
L2071: ( dom D192 ) = ( ( dom ( C299 | ( C305 .edgesOut() ) ) ) \/ { D188 } ) by L2070 , FUNCT_4:def 1
.= ( ( C305 .edgesOut() ) \/ { D188 } ) by PARTFUN1:def 2
.= ( C305 .edgesOut() ) by L2069 , ZFMISC_1:40;
reconsider D193 = D192 as (Rbag of ( C305 .edgesOut() )) by L2071 , PARTFUN1:def 2 , RELAT_1:def 18;
L2072:
now
let C315 being set;
assume L2073: C315 in ( dom ( D183 | ( C305 .edgesOut() ) ) );
L2074: C315 in ( C305 .edgesOut() ) by L2073;
L2075: ( ( the_Source_of C298 ) . C315 ) = C305 by L2074 , GLIB_000:58;
L2076:
now
per cases ;
suppose L2077: C315 = D188;

L2078: C315 in ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) ) by L2077 , L2070 , TARSKI:def 1;
thus L2079: ( D193 . C315 ) = ( ( D188 .--> ( ( C299 . D188 ) + D189 ) ) . D188 ) by L2078 , L2077 , FUNCT_4:13
.= ( ( C299 . D188 ) + D189 ) by FUNCOP_1:72
.= ( D183 . C315 ) by L1866 , L1926 , L1931 , L2014 , L2077 , L1083;
end;
suppose L2080: C315 <> D188;

L2081:
now
assume L2082: C315 in ( C302 .edges() );
consider C316 , C317 being (Vertex of C298), C318 being  odd (Element of ( NAT )) such that L2083: ( C318 + 2 ) <= ( len C302 ) and L2084: C316 = ( C302 . C318 ) and L2085: C315 = ( C302 . ( C318 + 1 ) ) and L2086: C317 = ( C302 . ( C318 + 2 ) ) and L2087: C315 Joins C316 , C317 , C298 by L2082 , GLIB_001:103;
L2088: ( ( C318 + 2 ) - 2 ) < ( ( len C302 ) - ( 0 ) ) by L2083 , XREAL_1:15;
L2089:
now
per cases  by L2075 , L2087 , GLIB_000:def 13;
suppose L2090: C305 = C316;

L2091:
now
per cases  by XXREAL_0:1;
suppose L2092: C318 < C306;

thus L2093: contradiction by L2092 , L1925 , L1926 , L1927 , L2084 , L2090 , GLIB_001:def 28;
end;
suppose L2094: C318 = C306;

thus L2095: contradiction by L2094 , L2080 , L2085;
end;
suppose L2096: C306 < C318;

thus L2097: contradiction by L2096 , L1926 , L2084 , L2088 , L2090 , GLIB_001:def 28;
end;
end;
thus L2099: contradiction by L2091;
end;
suppose L2100: C305 = C317;

L2101:
now
per cases  by XXREAL_0:1;
suppose L2102: ( C318 + 2 ) < C306;

thus L2103: contradiction by L2102 , L1925 , L1926 , L1927 , L2086 , L2100 , GLIB_001:def 28;
end;
suppose L2104: ( C318 + 2 ) = C306;

L2105: D186 < ( C306 - ( 0 ) ) by XREAL_1:15;
L2106: ( C302 . D186 ) = ( C302 . C306 ) by L1926 , L2014 , L2075 , L2085 , L2104 , GLIB_000:def 14;
thus L2107: contradiction by L2106 , L1925 , L1927 , L2105 , GLIB_001:def 28;
end;
suppose L2108: C306 < ( C318 + 2 );

thus L2109: contradiction by L2108 , L1926 , L1932 , L2083 , L2086 , L2100 , GLIB_001:def 28;
end;
end;
thus L2111: contradiction by L2101;
end;
end;
thus L2113: contradiction by L2089;
end;
L2114: (not C315 in ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) )) by L2080 , TARSKI:def 1;
L2115: ( D193 . C315 ) = ( ( C299 | ( C305 .edgesOut() ) ) . C315 ) by L2114 , FUNCT_4:11
.= ( C299 . C315 ) by L2074 , FUNCT_1:49;
thus L2116: ( D183 . C315 ) = ( D193 . C315 ) by L2115 , L1866 , L2074 , L2081 , L1083;
end;
end;
thus L2118: ( ( D183 | ( C305 .edgesOut() ) ) . C315 ) = ( D193 . C315 ) by L2076 , L2074 , FUNCT_1:49;
end;
L2119: ( Sum D191 ) = ( ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) + ( D189 + ( C299 . D187 ) ) ) - ( ( C299 | ( C305 .edgesIn() ) ) . D187 ) ) by GLIB_004:9
.= ( ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + D189 ) + ( C299 . D187 ) ) - ( C299 . D187 ) ) by L1922 , L2015 , FUNCT_1:49
.= ( ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + D189 ) + ( C299 . D188 ) ) - ( C299 . D188 ) )
.= ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + ( D189 + ( C299 . D188 ) ) ) - ( ( C299 | ( C305 .edgesOut() ) ) . D188 ) ) by L2069 , FUNCT_1:49
.= ( Sum D193 ) by GLIB_004:9;
thus L2120: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L2119 , L2071 , L2067 , L2068 , L2072 , FUNCT_1:2;
end;
suppose L2121: (D187 DJoins ( C302 . D186 ) , C305 , C298 & D188 DJoins ( C302 . ( C306 + 2 ) ) , C305 , C298);

L2122: ( dom ( D183 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
L2123:
now
let C319 being set;
assume L2124: C319 in ( dom ( D183 | ( C305 .edgesOut() ) ) );
L2125: ( ( C299 | ( C305 .edgesOut() ) ) . C319 ) = ( C299 . C319 ) by L2124 , FUNCT_1:49;
L2126: C319 in ( C305 .edgesOut() ) by L2124;
L2127: ( ( the_Source_of C298 ) . C319 ) = C305 by L2126 , GLIB_000:58;
L2128: C319 <> D188 by L2127 , L1936 , L2121 , GLIB_000:def 14;
L2129: C319 <> D187 by L2001 , L2121 , L2127 , GLIB_000:def 14;
L2130: (not C319 in ( C302 .edges() )) by L2129 , L1946 , L2126 , L2128;
L2131: ( ( D183 | ( C305 .edgesOut() ) ) . C319 ) = ( D183 . C319 ) by L2124 , FUNCT_1:49;
thus L2132: ( ( D183 | ( C305 .edgesOut() ) ) . C319 ) = ( ( C299 | ( C305 .edgesOut() ) ) . C319 ) by L2131 , L1866 , L2126 , L2125 , L2130 , L1083;
end;
L2133: ( dom ( C299 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
L2134: ( D183 | ( C305 .edgesOut() ) ) = ( C299 | ( C305 .edgesOut() ) ) by L2133 , L2122 , L2123 , FUNCT_1:2;
set D194 = ( ( C299 | ( C305 .edgesIn() ) ) +* ( D187 .--> ( ( C299 . D187 ) + D189 ) ) );
set D195 = ( D194 +* ( D188 .--> ( ( C299 . D188 ) - D189 ) ) );
L2135: ( dom ( D183 | ( C305 .edgesIn() ) ) ) = ( C305 .edgesIn() ) by PARTFUN1:def 2;
L2136: D188 in ( C305 .edgesIn() ) by L2121 , GLIB_000:57;
L2137: D187 in ( C305 .edgesIn() ) by L2121 , GLIB_000:57;
L2138: ( D183 . D187 ) = ( ( C299 . D187 ) + D189 ) by L1866 , L2010 , L1945 , L2121 , L1083;
L2139: ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) ) = { D188 } by FUNCOP_1:13;
L2140: ( dom D194 ) = ( ( dom ( C299 | ( C305 .edgesIn() ) ) ) \/ ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( C299 | ( C305 .edgesIn() ) ) ) \/ { D187 } ) by FUNCOP_1:13
.= ( ( C305 .edgesIn() ) \/ { D187 } ) by PARTFUN1:def 2
.= ( C305 .edgesIn() ) by L2137 , ZFMISC_1:40;
reconsider D196 = D194 as (Rbag of ( C305 .edgesIn() )) by L2140 , PARTFUN1:def 2 , RELAT_1:def 18;
L2141: ( dom D195 ) = ( ( dom D196 ) \/ ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) ) ) by FUNCT_4:def 1
.= ( ( C305 .edgesIn() ) \/ { D188 } ) by L2140 , FUNCOP_1:13
.= ( C305 .edgesIn() ) by L2136 , ZFMISC_1:40;
reconsider D197 = D195 as (Rbag of ( C305 .edgesIn() )) by L2141 , PARTFUN1:def 2 , RELAT_1:def 18;
L2142: ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) ) = { D187 } by FUNCOP_1:13;
L2143: ( D183 . D188 ) = ( ( C299 . D188 ) - D189 ) by L1866 , L1926 , L1931 , L1990 , L2121 , L1083;
L2144:
now
let C320 being set;
assume L2145: C320 in ( dom ( D183 | ( C305 .edgesIn() ) ) );
L2146: C320 in ( C305 .edgesIn() ) by L2145;
L2147: ( ( D183 | ( C305 .edgesIn() ) ) . C320 ) = ( D183 . C320 ) by L2145 , FUNCT_1:49;
L2148:
now
per cases ;
suppose L2149: C320 = D187;

L2150: C320 in ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) ) by L2149 , L2142 , TARSKI:def 1;
L2151: (not C320 in ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) )) by L2000 , L2149 , TARSKI:def 1;
L2152: ( D197 . C320 ) = ( D196 . C320 ) by L2151 , FUNCT_4:11
.= ( ( D187 .--> ( ( C299 . D187 ) + D189 ) ) . C320 ) by L2150 , FUNCT_4:13
.= ( D183 . C320 ) by L2138 , L2149 , FUNCOP_1:72;
thus L2153: ( ( D183 | ( C305 .edgesIn() ) ) . C320 ) = ( D197 . C320 ) by L2152 , L2145 , FUNCT_1:49;
end;
suppose L2154: C320 = D188;

L2155: C320 in ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) ) by L2154 , L2139 , TARSKI:def 1;
L2156: ( D197 . C320 ) = ( ( D188 .--> ( ( C299 . D188 ) - D189 ) ) . D188 ) by L2155 , L2154 , FUNCT_4:13
.= ( D183 . C320 ) by L2143 , L2154 , FUNCOP_1:72;
thus L2157: ( ( D183 | ( C305 .edgesIn() ) ) . C320 ) = ( D197 . C320 ) by L2156 , L2145 , FUNCT_1:49;
end;
suppose L2158: (C320 <> D187 & C320 <> D188);

L2159: (not C320 in ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) )) by L2158 , TARSKI:def 1;
L2160: (not C320 in ( C302 .edges() )) by L1946 , L2146 , L2158;
L2161: (not C320 in ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) )) by L2158 , TARSKI:def 1;
L2162: ( D197 . C320 ) = ( D196 . C320 ) by L2161 , FUNCT_4:11
.= ( ( C299 | ( C305 .edgesIn() ) ) . C320 ) by L2159 , FUNCT_4:11
.= ( C299 . C320 ) by L2146 , FUNCT_1:49;
thus L2163: ( ( D183 | ( C305 .edgesIn() ) ) . C320 ) = ( D197 . C320 ) by L2162 , L1866 , L2146 , L2147 , L2160 , L1083;
end;
end;
thus L2165: ( ( D183 | ( C305 .edgesIn() ) ) . C320 ) = ( D197 . C320 ) by L2148;
end;
L2166: (not D188 in ( dom ( D187 .--> ( ( C299 . D187 ) + D189 ) ) )) by L2000 , TARSKI:def 1;
L2167: ( D196 . D188 ) = ( ( C299 | ( C305 .edgesIn() ) ) . D188 ) by L2166 , FUNCT_4:11
.= ( C299 . D188 ) by L2136 , FUNCT_1:49;
L2168: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( ( ( Sum D196 ) + ( ( C299 . D188 ) - D189 ) ) - ( C299 . D188 ) ) by L2167 , L2141 , L2135 , L2144 , FUNCT_1:2 , GLIB_004:9
.= ( ( Sum D196 ) - ( ( C299 . D188 ) - ( ( C299 . D188 ) - D189 ) ) )
.= ( ( ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) + ( ( C299 . D187 ) + D189 ) ) - ( ( C299 | ( C305 .edgesIn() ) ) . D187 ) ) - D189 ) by GLIB_004:9
.= ( ( ( ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) + D189 ) + ( C299 . D187 ) ) - ( C299 . D187 ) ) - D189 ) by L2137 , FUNCT_1:49
.= ( Sum ( C299 | ( C305 .edgesIn() ) ) );
thus L2169: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L2168 , L1864 , L1920 , L1921 , L2134 , L34;
end;
suppose L2170: (D187 DJoins C305 , ( C302 . D186 ) , C298 & D188 DJoins C305 , ( C302 . ( C306 + 2 ) ) , C298);

L2171: ( dom ( D183 | ( C305 .edgesIn() ) ) ) = ( C305 .edgesIn() ) by PARTFUN1:def 2;
L2172:
now
let C321 being set;
assume L2173: C321 in ( dom ( D183 | ( C305 .edgesIn() ) ) );
L2174: ( ( C299 | ( C305 .edgesIn() ) ) . C321 ) = ( C299 . C321 ) by L2173 , FUNCT_1:49;
L2175: C321 in ( C305 .edgesIn() ) by L2173;
L2176: ( ( the_Target_of C298 ) . C321 ) = C305 by L2175 , GLIB_000:56;
L2177: C321 <> D188 by L2176 , L1936 , L2170 , GLIB_000:def 14;
L2178: C321 <> D187 by L2001 , L2170 , L2176 , GLIB_000:def 14;
L2179: (not C321 in ( C302 .edges() )) by L2178 , L1946 , L2175 , L2177;
L2180: ( ( D183 | ( C305 .edgesIn() ) ) . C321 ) = ( D183 . C321 ) by L2173 , FUNCT_1:49;
thus L2181: ( ( D183 | ( C305 .edgesIn() ) ) . C321 ) = ( ( C299 | ( C305 .edgesIn() ) ) . C321 ) by L2180 , L1866 , L2175 , L2174 , L2179 , L1083;
end;
set D198 = ( ( C299 | ( C305 .edgesOut() ) ) +* ( D187 .--> ( ( C299 . D187 ) - D189 ) ) );
set D199 = ( D198 +* ( D188 .--> ( ( C299 . D188 ) + D189 ) ) );
L2182: ( dom ( D183 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
L2183: D188 in ( C305 .edgesOut() ) by L2170 , GLIB_000:59;
L2184: ( dom ( C299 | ( C305 .edgesIn() ) ) ) = ( C305 .edgesIn() ) by PARTFUN1:def 2;
L2185: D187 in ( C305 .edgesOut() ) by L2170 , GLIB_000:59;
L2186: ( D183 . D188 ) = ( ( C299 . D188 ) + D189 ) by L1866 , L1926 , L1931 , L2170 , L1083;
L2187: ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) ) = { D188 } by FUNCOP_1:13;
L2188: ( dom D198 ) = ( ( dom ( C299 | ( C305 .edgesOut() ) ) ) \/ ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) ) ) by FUNCT_4:def 1
.= ( ( dom ( C299 | ( C305 .edgesOut() ) ) ) \/ { D187 } ) by FUNCOP_1:13
.= ( ( C305 .edgesOut() ) \/ { D187 } ) by PARTFUN1:def 2
.= ( C305 .edgesOut() ) by L2185 , ZFMISC_1:40;
reconsider D200 = D198 as (Rbag of ( C305 .edgesOut() )) by L2188 , PARTFUN1:def 2 , RELAT_1:def 18;
L2189: ( dom D199 ) = ( ( dom D200 ) \/ ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) ) ) by FUNCT_4:def 1
.= ( ( C305 .edgesOut() ) \/ { D188 } ) by L2188 , FUNCOP_1:13
.= ( C305 .edgesOut() ) by L2183 , ZFMISC_1:40;
reconsider D201 = D199 as (Rbag of ( C305 .edgesOut() )) by L2189 , PARTFUN1:def 2 , RELAT_1:def 18;
L2190: ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) ) = { D187 } by FUNCOP_1:13;
L2191: ( D183 . D187 ) = ( ( C299 . D187 ) - D189 ) by L1866 , L2010 , L1945 , L2005 , L2170 , L1083;
L2192:
now
let C322 being set;
assume L2193: C322 in ( dom ( D183 | ( C305 .edgesOut() ) ) );
L2194: C322 in ( C305 .edgesOut() ) by L2193;
L2195: ( ( D183 | ( C305 .edgesOut() ) ) . C322 ) = ( D183 . C322 ) by L2193 , FUNCT_1:49;
L2196:
now
per cases ;
suppose L2197: C322 = D187;

L2198: C322 in ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) ) by L2197 , L2190 , TARSKI:def 1;
L2199: (not C322 in ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) )) by L2000 , L2197 , TARSKI:def 1;
L2200: ( D201 . C322 ) = ( D200 . C322 ) by L2199 , FUNCT_4:11
.= ( ( D187 .--> ( ( C299 . D187 ) - D189 ) ) . C322 ) by L2198 , FUNCT_4:13
.= ( D183 . C322 ) by L2191 , L2197 , FUNCOP_1:72;
thus L2201: ( ( D183 | ( C305 .edgesOut() ) ) . C322 ) = ( D201 . C322 ) by L2200 , L2193 , FUNCT_1:49;
end;
suppose L2202: C322 = D188;

L2203: C322 in ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) ) by L2202 , L2187 , TARSKI:def 1;
L2204: ( D201 . C322 ) = ( ( D188 .--> ( ( C299 . D188 ) + D189 ) ) . C322 ) by L2203 , FUNCT_4:13
.= ( D183 . C322 ) by L2186 , L2202 , FUNCOP_1:72;
thus L2205: ( ( D183 | ( C305 .edgesOut() ) ) . C322 ) = ( D201 . C322 ) by L2204 , L2193 , FUNCT_1:49;
end;
suppose L2206: (C322 <> D187 & C322 <> D188);

L2207: (not C322 in ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) )) by L2206 , TARSKI:def 1;
L2208: (not C322 in ( C302 .edges() )) by L1946 , L2194 , L2206;
L2209: (not C322 in ( dom ( D188 .--> ( ( C299 . D188 ) + D189 ) ) )) by L2206 , TARSKI:def 1;
L2210: ( D201 . C322 ) = ( D200 . C322 ) by L2209 , FUNCT_4:11
.= ( ( C299 | ( C305 .edgesOut() ) ) . C322 ) by L2207 , FUNCT_4:11
.= ( C299 . C322 ) by L2194 , FUNCT_1:49;
thus L2211: ( ( D183 | ( C305 .edgesOut() ) ) . C322 ) = ( D201 . C322 ) by L2210 , L1866 , L2194 , L2195 , L2208 , L1083;
end;
end;
thus L2213: ( ( D183 | ( C305 .edgesOut() ) ) . C322 ) = ( D201 . C322 ) by L2196;
end;
L2214: (not D188 in ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) )) by L2000 , TARSKI:def 1;
L2215: ( D200 . D188 ) = ( ( C299 | ( C305 .edgesOut() ) ) . D188 ) by L2214 , FUNCT_4:11
.= ( C299 . D188 ) by L2183 , FUNCT_1:49;
L2216: ( Sum ( D183 | ( C305 .edgesOut() ) ) ) = ( ( ( Sum D200 ) + ( ( C299 . D188 ) + D189 ) ) - ( C299 . D188 ) ) by L2215 , L2189 , L2182 , L2192 , FUNCT_1:2 , GLIB_004:9
.= ( ( ( ( Sum D200 ) - ( C299 . D188 ) ) + ( C299 . D188 ) ) + D189 )
.= ( ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + ( ( C299 . D187 ) - D189 ) ) - ( ( C299 | ( C305 .edgesOut() ) ) . D187 ) ) + D189 ) by GLIB_004:9
.= ( ( ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + ( C299 . D187 ) ) - D189 ) - ( C299 . D187 ) ) + D189 ) by L2185 , FUNCT_1:49
.= ( Sum ( C299 | ( C305 .edgesOut() ) ) );
thus L2217: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L2216 , L1922 , L2171 , L2184 , L2172 , FUNCT_1:2;
end;
suppose L2218: (D187 DJoins C305 , ( C302 . D186 ) , C298 & D188 DJoins ( C302 . ( C306 + 2 ) ) , C305 , C298);

set D202 = ( ( C299 | ( C305 .edgesIn() ) ) +* ( D188 .--> ( ( C299 . D188 ) - D189 ) ) );
L2219: D188 in ( C305 .edgesIn() ) by L2218 , GLIB_000:57;
L2220: ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) ) = { D188 } by FUNCOP_1:13;
L2221: ( dom D202 ) = ( ( dom ( C299 | ( C305 .edgesIn() ) ) ) \/ { D188 } ) by L2220 , FUNCT_4:def 1
.= ( ( C305 .edgesIn() ) \/ { D188 } ) by PARTFUN1:def 2
.= ( C305 .edgesIn() ) by L2219 , ZFMISC_1:40;
reconsider D203 = D202 as (Rbag of ( C305 .edgesIn() )) by L2221 , PARTFUN1:def 2 , RELAT_1:def 18;
L2222: ( D183 . D188 ) = ( ( C299 . D188 ) - D189 ) by L1866 , L1926 , L1931 , L1990 , L2218 , L1083;
L2223:
now
let C323 being set;
assume L2224: C323 in ( dom ( D183 | ( C305 .edgesIn() ) ) );
L2225: C323 in ( C305 .edgesIn() ) by L2224;
L2226: ( ( the_Target_of C298 ) . C323 ) = C305 by L2225 , GLIB_000:56;
L2227:
now
per cases ;
suppose L2228: C323 = D188;

L2229: C323 in ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) ) by L2228 , L2220 , TARSKI:def 1;
thus L2230: ( D203 . C323 ) = ( ( D188 .--> ( ( C299 . D188 ) - D189 ) ) . D188 ) by L2229 , L2228 , FUNCT_4:13
.= ( D183 . C323 ) by L2222 , L2228 , FUNCOP_1:72;
end;
suppose L2231: C323 <> D188;

L2232: (not C323 in ( dom ( D188 .--> ( ( C299 . D188 ) - D189 ) ) )) by L2231 , TARSKI:def 1;
L2233: ( D203 . C323 ) = ( ( C299 | ( C305 .edgesIn() ) ) . C323 ) by L2232 , FUNCT_4:11
.= ( C299 . C323 ) by L2225 , FUNCT_1:49;
L2234: C323 <> D187 by L2001 , L2218 , L2226 , GLIB_000:def 14;
L2235: (not C323 in ( C302 .edges() )) by L2234 , L1946 , L2225 , L2231;
thus L2236: ( D183 . C323 ) = ( D203 . C323 ) by L2235 , L1866 , L2225 , L2233 , L1083;
end;
end;
thus L2238: ( D203 . C323 ) = ( ( D183 | ( C305 .edgesIn() ) ) . C323 ) by L2227 , L2225 , FUNCT_1:49;
end;
L2239: ( dom ( D183 | ( C305 .edgesIn() ) ) ) = ( C305 .edgesIn() ) by PARTFUN1:def 2;
L2240: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) + ( ( C299 . D188 ) - D189 ) ) - ( ( C299 | ( C305 .edgesIn() ) ) . D188 ) ) by L2239 , L2221 , L2223 , FUNCT_1:2 , GLIB_004:9
.= ( ( ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) + ( C299 . D188 ) ) - D189 ) - ( C299 . D188 ) ) by L2219 , FUNCT_1:49
.= ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) - D189 );
set D204 = ( ( C299 | ( C305 .edgesOut() ) ) +* ( D187 .--> ( ( C299 . D187 ) - D189 ) ) );
L2241: D187 in ( C305 .edgesOut() ) by L2218 , GLIB_000:59;
L2242: ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) ) = { D187 } by FUNCOP_1:13;
L2243: ( dom D204 ) = ( ( dom ( C299 | ( C305 .edgesOut() ) ) ) \/ { D187 } ) by L2242 , FUNCT_4:def 1
.= ( ( C305 .edgesOut() ) \/ { D187 } ) by PARTFUN1:def 2
.= ( C305 .edgesOut() ) by L2241 , ZFMISC_1:40;
reconsider D205 = D204 as (Rbag of ( C305 .edgesOut() )) by L2243 , PARTFUN1:def 2 , RELAT_1:def 18;
L2244: ( D183 . D187 ) = ( ( C299 . D187 ) - D189 ) by L1866 , L2010 , L1945 , L2005 , L2218 , L1083;
L2245:
now
let C324 being set;
assume L2246: C324 in ( dom ( D183 | ( C305 .edgesOut() ) ) );
L2247: C324 in ( C305 .edgesOut() ) by L2246;
L2248: ( ( the_Source_of C298 ) . C324 ) = C305 by L2247 , GLIB_000:58;
L2249:
now
per cases ;
suppose L2250: C324 = D187;

L2251: C324 in ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) ) by L2250 , L2242 , TARSKI:def 1;
thus L2252: ( D205 . C324 ) = ( ( D187 .--> ( ( C299 . D187 ) - D189 ) ) . D187 ) by L2251 , L2250 , FUNCT_4:13
.= ( D183 . C324 ) by L2244 , L2250 , FUNCOP_1:72;
end;
suppose L2253: C324 <> D187;

L2254: (not C324 in ( dom ( D187 .--> ( ( C299 . D187 ) - D189 ) ) )) by L2253 , TARSKI:def 1;
L2255: ( D205 . C324 ) = ( ( C299 | ( C305 .edgesOut() ) ) . C324 ) by L2254 , FUNCT_4:11
.= ( C299 . C324 ) by L2247 , FUNCT_1:49;
L2256: C324 <> D188 by L1936 , L2218 , L2248 , GLIB_000:def 14;
L2257: (not C324 in ( C302 .edges() )) by L2256 , L1946 , L2247 , L2253;
thus L2258: ( D183 . C324 ) = ( D205 . C324 ) by L2257 , L1866 , L2247 , L2255 , L1083;
end;
end;
thus L2260: ( D205 . C324 ) = ( ( D183 | ( C305 .edgesOut() ) ) . C324 ) by L2249 , L2247 , FUNCT_1:49;
end;
L2261: ( dom ( D183 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
L2262: ( Sum ( D183 | ( C305 .edgesOut() ) ) ) = ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + ( ( C299 . D187 ) - D189 ) ) - ( ( C299 | ( C305 .edgesOut() ) ) . D187 ) ) by L2261 , L2243 , L2245 , FUNCT_1:2 , GLIB_004:9
.= ( ( ( ( Sum ( C299 | ( C305 .edgesOut() ) ) ) + ( C299 . D187 ) ) - D189 ) - ( C299 . D187 ) ) by L2241 , FUNCT_1:49
.= ( ( Sum ( C299 | ( C305 .edgesIn() ) ) ) - D189 ) by L1922;
thus L2263: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L2262 , L2240;
end;
end;
thus L2265: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L2013;
end;
suppose L2266: (not C305 in ( C302 .vertices() ));

L2267: ( dom ( C299 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
L2268:
now
let C325 being set;
assume L2269: C325 in ( dom ( C299 | ( C305 .edgesOut() ) ) );
L2270: ( ( D183 | ( C305 .edgesOut() ) ) . C325 ) = ( D183 . C325 ) by L2269 , FUNCT_1:49;
L2271: C325 in ( C305 .edgesOut() ) by L2269;
L2272:
now
consider C326 being set such that L2273: C325 DJoins C305 , C326 , C298 by L2271 , GLIB_000:59;
assume L2274: C325 in ( C302 .edges() );
L2275: C325 Joins C305 , C326 , C298 by L2273 , GLIB_000:16;
thus L2276: contradiction by L2275 , L2266 , L2274 , GLIB_001:105;
end;
L2277: ( ( C299 | ( C305 .edgesOut() ) ) . C325 ) = ( C299 . C325 ) by L2269 , FUNCT_1:49;
thus L2278: ( ( C299 | ( C305 .edgesOut() ) ) . C325 ) = ( ( D183 | ( C305 .edgesOut() ) ) . C325 ) by L2277 , L1866 , L2271 , L2270 , L2272 , L1083;
end;
L2279: ( dom ( C299 | ( C305 .edgesIn() ) ) ) = ( C305 .edgesIn() ) by PARTFUN1:def 2;
L2280:
now
let C327 being set;
assume L2281: C327 in ( dom ( C299 | ( C305 .edgesIn() ) ) );
L2282: ( ( D183 | ( C305 .edgesIn() ) ) . C327 ) = ( D183 . C327 ) by L2281 , FUNCT_1:49;
L2283:
now
consider C328 being set such that L2284: C327 DJoins C328 , C305 , C298 by L2281 , GLIB_000:57;
assume L2285: C327 in ( C302 .edges() );
L2286: C327 Joins C328 , C305 , C298 by L2284 , GLIB_000:16;
thus L2287: contradiction by L2286 , L2266 , L2285 , GLIB_001:105;
end;
L2288: ( ( C299 | ( C305 .edgesIn() ) ) . C327 ) = ( C299 . C327 ) by L2281 , FUNCT_1:49;
thus L2289: ( ( C299 | ( C305 .edgesIn() ) ) . C327 ) = ( ( D183 | ( C305 .edgesIn() ) ) . C327 ) by L2288 , L1866 , L2279 , L2281 , L2282 , L2283 , L1083;
end;
L2290: ( dom ( D183 | ( C305 .edgesOut() ) ) ) = ( C305 .edgesOut() ) by PARTFUN1:def 2;
L2291: ( C299 | ( C305 .edgesOut() ) ) = ( D183 | ( C305 .edgesOut() ) ) by L2290 , L2267 , L2268 , FUNCT_1:2;
L2292: ( dom ( C299 | ( C305 .edgesIn() ) ) ) = ( dom ( D183 | ( C305 .edgesIn() ) ) ) by L2279 , PARTFUN1:def 2;
thus L2293: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( C299 | ( C305 .edgesIn() ) ) ) by L2292 , L2280 , FUNCT_1:2
.= ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L1864 , L1920 , L1921 , L2291 , L34;
end;
end;
thus L2295: ( Sum ( D183 | ( C305 .edgesIn() ) ) ) = ( Sum ( D183 | ( C305 .edgesOut() ) ) ) by L1923;
end;
thus L2296: thesis by L1867 , L34;
end;
theorem
L2297: (for B213 being  finite  natural-weighted WGraph holds (for B214 being (FF:ELabeling of B213) holds (for B215 , B216 being set holds (for B217 being (Path of B213) holds ((B215 <> B216 & B217 is_Walk_from B215 , B216 & B217 is_augmenting_wrt B214) implies ( ( B214 .flow (B215 , B216) ) + ( B217 .tolerance B214 ) ) = ( ( FF:PushFlow (B214 , B217) ) .flow (B215 , B216) ))))))
proof
let C329 being  finite  natural-weighted WGraph;
let C330 being (FF:ELabeling of C329);
let C331 , C332 being set;
let C333 being (Path of C329);
assume that
L2298: C331 <> C332
and
L2299: C333 is_Walk_from C331 , C332
and
L2300: C333 is_augmenting_wrt C330;
L2301: ( C333 .last() ) = C332 by L2299 , GLIB_001:def 23;
L2302: ( C333 .first() ) = C331 by L2299 , GLIB_001:def 23;
L2303: C333 is non  trivial by L2302 , L2298 , L2301 , GLIB_001:127;
L2304: 3 <= ( len C333 ) by L2303 , GLIB_001:125;
reconsider D206 = ( ( len C333 ) - ( 2 * 1 ) ) as  odd (Element of ( NAT )) by L2304 , INT_1:5 , XXREAL_0:2;
set D207 = ( C333 . ( D206 + 1 ) );
set D208 = ( C330 | ( C329 .edgesInto { C332 } ) );
set D209 = ( C330 | ( C329 .edgesOutOf { C332 } ) );
set D210 = ( FF:PushFlow (C330 , C333) );
set D211 = ( C333 .tolerance C330 );
L2305: ( C333 . ( len C333 ) ) = C332 by L2299 , GLIB_001:17;
L2306: D206 < ( ( len C333 ) - ( 0 ) ) by XREAL_1:15;
L2307: D207 Joins ( C333 . D206 ) , ( C333 . ( D206 + 2 ) ) , C329 by L2306 , GLIB_001:def 3;
L2308: D207 in ( the_Edges_of C329 ) by L2307 , GLIB_000:def 13;
L2309:
now
per cases ;
suppose L2310: D207 DJoins ( C333 . D206 ) , ( C333 . ( D206 + 2 ) ) , C329;

L2311: ( ( the_Target_of C329 ) . D207 ) = ( C333 . ( D206 + 2 ) ) by L2310 , GLIB_000:def 14
.= C332 by L2299 , GLIB_001:17;
L2312: ( ( the_Target_of C329 ) . D207 ) in { C332 } by L2311 , TARSKI:def 1;
L2313: D207 in ( C329 .edgesInto { C332 } ) by L2312 , L2308 , GLIB_000:def 26;
set D212 = ( D208 +* ( D207 .--> ( ( D208 . D207 ) + D211 ) ) );
L2314: ( dom ( D210 | ( C329 .edgesInto { C332 } ) ) ) = ( C329 .edgesInto { C332 } ) by PARTFUN1:def 2;
L2315: ( dom D212 ) = ( ( dom D208 ) \/ ( dom ( D207 .--> ( ( D208 . D207 ) + D211 ) ) ) ) by FUNCT_4:def 1
.= ( ( dom D208 ) \/ { D207 } ) by FUNCOP_1:13
.= ( ( C329 .edgesInto { C332 } ) \/ { D207 } ) by PARTFUN1:def 2
.= ( C329 .edgesInto { C332 } ) by L2313 , ZFMISC_1:40;
reconsider D213 = D212 as (Rbag of ( C329 .edgesInto { C332 } )) by L2315 , PARTFUN1:def 2 , RELAT_1:def 18;
L2316: ( D210 . D207 ) = ( ( C330 . D207 ) + D211 ) by L2300 , L2306 , L2310 , L1083;
L2317:
now
let C334 being set;
assume L2318: C334 in ( dom ( D210 | ( C329 .edgesInto { C332 } ) ) );
L2319: C334 in ( C329 .edgesInto { C332 } ) by L2318;
L2320: ( ( D210 | ( C329 .edgesInto { C332 } ) ) . C334 ) = ( D210 . C334 ) by L2318 , FUNCT_1:49;
L2321: ( ( the_Target_of C329 ) . C334 ) in { C332 } by L2319 , GLIB_000:def 26;
L2322: ( ( the_Target_of C329 ) . C334 ) = C332 by L2321 , TARSKI:def 1;
L2323:
now
per cases ;
suppose L2324: C334 = D207;

L2325: C334 in { D207 } by L2324 , TARSKI:def 1;
L2326: C334 in ( dom ( D207 .--> ( ( D208 . D207 ) + D211 ) ) ) by L2325 , FUNCOP_1:13;
L2327: ( D213 . C334 ) = ( ( D207 .--> ( ( D208 . D207 ) + D211 ) ) . D207 ) by L2326 , L2324 , FUNCT_4:13
.= ( ( D208 . D207 ) + D211 ) by FUNCOP_1:72
.= ( D210 . D207 ) by L2316 , L2319 , L2324 , FUNCT_1:49;
thus L2328: ( ( D210 | ( C329 .edgesInto { C332 } ) ) . C334 ) = ( D213 . C334 ) by L2327 , L2318 , L2324 , FUNCT_1:49;
end;
suppose L2329: C334 <> D207;

L2330:
now
assume L2331: C334 in ( C333 .edges() );
consider C335 , C336 being (Vertex of C329), C337 being  odd (Element of ( NAT )) such that L2332: ( C337 + 2 ) <= ( len C333 ) and L2333: C335 = ( C333 . C337 ) and L2334: C334 = ( C333 . ( C337 + 1 ) ) and L2335: C336 = ( C333 . ( C337 + 2 ) ) and L2336: C334 Joins C335 , C336 , C329 by L2331 , GLIB_001:103;
L2337:
now
per cases  by L2322 , L2336 , GLIB_000:def 13;
suppose L2338: C335 = C332;

L2339: ( ( C337 + 2 ) - 2 ) < ( ( len C333 ) - ( 0 ) ) by L2332 , XREAL_1:15;
L2340: ( C333 . C337 ) = ( C333 . ( len C333 ) ) by L2299 , L2333 , L2338 , GLIB_001:17;
L2341: C337 = 1 by L2340 , L2339 , GLIB_001:def 28;
thus L2342: contradiction by L2341 , L2298 , L2299 , L2333 , L2338 , GLIB_001:17;
end;
suppose L2343: C336 = C332;

L2344: ( C333 . ( C337 + 2 ) ) = ( C333 . ( len C333 ) ) by L2343 , L2299 , L2335 , GLIB_001:17;
L2345:
now
assume L2346: ( C337 + 2 ) < ( len C333 );
L2347: ( C337 + 2 ) = 1 by L2346 , L2344 , GLIB_001:def 28;
L2348: C337 = ( 1 - 2 ) by L2347;
thus L2349: contradiction by L2348 , ABIAN:12;
end;
L2350: ( C337 + 2 ) = ( len C333 ) by L2345 , L2332 , XXREAL_0:1;
thus L2351: contradiction by L2350 , L2329 , L2334;
end;
end;
thus L2353: contradiction by L2337;
end;
L2354: (not C334 in { D207 }) by L2329 , TARSKI:def 1;
L2355: (not C334 in ( dom ( D207 .--> ( ( D208 . D207 ) + D211 ) ) )) by L2354;
L2356: ( D213 . C334 ) = ( D208 . C334 ) by L2355 , FUNCT_4:11
.= ( C330 . C334 ) by L2319 , FUNCT_1:49;
thus L2357: ( ( D210 | ( C329 .edgesInto { C332 } ) ) . C334 ) = ( D213 . C334 ) by L2356 , L2300 , L2319 , L2320 , L2330 , L1083;
end;
end;
thus L2359: ( ( D210 | ( C329 .edgesInto { C332 } ) ) . C334 ) = ( D213 . C334 ) by L2323;
end;
L2360: ( Sum ( D210 | ( C329 .edgesInto { C332 } ) ) ) = ( ( ( Sum D208 ) + ( D211 + ( D208 . D207 ) ) ) - ( D208 . D207 ) ) by L2317 , L2315 , L2314 , FUNCT_1:2 , GLIB_004:9
.= ( ( Sum D208 ) + D211 );
L2361: ( dom ( D210 | ( C329 .edgesOutOf { C332 } ) ) ) = ( C329 .edgesOutOf { C332 } ) by PARTFUN1:def 2;
L2362:
now
let C338 being set;
assume L2363: C338 in ( dom ( D210 | ( C329 .edgesOutOf { C332 } ) ) );
L2364: C338 in ( C329 .edgesOutOf { C332 } ) by L2363;
L2365: ( ( the_Source_of C329 ) . C338 ) in { C332 } by L2364 , GLIB_000:def 27;
L2366: ( ( the_Source_of C329 ) . C338 ) = C332 by L2365 , TARSKI:def 1;
L2367:
now
assume L2368: C338 in ( C333 .edges() );
consider C339 , C340 being (Vertex of C329), C341 being  odd (Element of ( NAT )) such that L2369: ( C341 + 2 ) <= ( len C333 ) and L2370: C339 = ( C333 . C341 ) and L2371: C338 = ( C333 . ( C341 + 1 ) ) and L2372: C340 = ( C333 . ( C341 + 2 ) ) and L2373: C338 Joins C339 , C340 , C329 by L2368 , GLIB_001:103;
L2374:
now
per cases  by L2366 , L2373 , GLIB_000:def 13;
suppose L2375: C339 = C332;

L2376: ( ( C341 + 2 ) - 2 ) < ( ( len C333 ) - ( 0 ) ) by L2369 , XREAL_1:15;
L2377: ( C333 . C341 ) = ( C333 . ( len C333 ) ) by L2299 , L2370 , L2375 , GLIB_001:17;
L2378: C341 = 1 by L2377 , L2376 , GLIB_001:def 28;
thus L2379: contradiction by L2378 , L2298 , L2299 , L2370 , L2375 , GLIB_001:17;
end;
suppose L2380: C340 = C332;

L2381: ( C333 . ( C341 + 2 ) ) = ( C333 . ( len C333 ) ) by L2380 , L2299 , L2372 , GLIB_001:17;
L2382:
now
assume L2383: ( C341 + 2 ) < ( len C333 );
L2384: ( C341 + 2 ) = 1 by L2383 , L2381 , GLIB_001:def 28;
L2385: 1 <= ( 1 - 2 ) by L2384 , ABIAN:12;
thus L2386: contradiction by L2385;
end;
L2387: ( C341 + 2 ) = ( len C333 ) by L2382 , L2369 , XXREAL_0:1;
L2388: ( C333 . D206 ) = C332 by L2387 , L2310 , L2366 , L2371 , GLIB_000:def 14;
L2389: D206 = 1 by L2388 , L2306 , L2305 , GLIB_001:def 28;
thus L2390: contradiction by L2389 , L2298 , L2299 , L2388 , GLIB_001:17;
end;
end;
thus L2392: contradiction by L2374;
end;
L2393: ( D210 . C338 ) = ( C330 . C338 ) by L2367 , L2300 , L2364 , L1083
.= ( D209 . C338 ) by L2364 , FUNCT_1:49;
thus L2394: ( ( D210 | ( C329 .edgesOutOf { C332 } ) ) . C338 ) = ( D209 . C338 ) by L2393 , L2363 , FUNCT_1:49;
end;
L2395: ( dom D209 ) = ( C329 .edgesOutOf { C332 } ) by PARTFUN1:def 2;
thus L2396: ( D210 .flow (C331 , C332) ) = ( ( ( Sum D208 ) + D211 ) - ( Sum D209 ) ) by L2395 , L2360 , L2361 , L2362 , FUNCT_1:2
.= ( ( ( Sum D208 ) - ( Sum D209 ) ) + D211 )
.= ( ( C330 .flow (C331 , C332) ) + D211 );
end;
suppose L2397: (not D207 DJoins ( C333 . D206 ) , ( C333 . ( D206 + 2 ) ) , C329);

L2398: D207 DJoins ( C333 . ( D206 + 2 ) ) , ( C333 . D206 ) , C329 by L2397 , L2307 , GLIB_000:16;
L2399: ( ( the_Source_of C329 ) . D207 ) = ( C333 . ( D206 + 2 ) ) by L2398 , GLIB_000:def 14
.= C332 by L2299 , GLIB_001:17;
L2400: ( ( the_Source_of C329 ) . D207 ) in { C332 } by L2399 , TARSKI:def 1;
L2401: D207 in ( C329 .edgesOutOf { C332 } ) by L2400 , L2308 , GLIB_000:def 27;
set D214 = ( D209 +* ( D207 .--> ( ( D209 . D207 ) - D211 ) ) );
L2402: ( dom ( D210 | ( C329 .edgesOutOf { C332 } ) ) ) = ( C329 .edgesOutOf { C332 } ) by PARTFUN1:def 2;
L2403: ( dom D214 ) = ( ( dom D209 ) \/ ( dom ( D207 .--> ( ( D209 . D207 ) - D211 ) ) ) ) by FUNCT_4:def 1
.= ( ( dom D209 ) \/ { D207 } ) by FUNCOP_1:13
.= ( ( C329 .edgesOutOf { C332 } ) \/ { D207 } ) by PARTFUN1:def 2
.= ( C329 .edgesOutOf { C332 } ) by L2401 , ZFMISC_1:40;
reconsider D215 = D214 as (Rbag of ( C329 .edgesOutOf { C332 } )) by L2403 , PARTFUN1:def 2 , RELAT_1:def 18;
L2404: ( D210 . D207 ) = ( ( C330 . D207 ) - D211 ) by L2300 , L2306 , L2397 , L1083;
L2405:
now
let C342 being set;
assume L2406: C342 in ( dom ( D210 | ( C329 .edgesOutOf { C332 } ) ) );
L2407: C342 in ( C329 .edgesOutOf { C332 } ) by L2406;
L2408: ( ( D210 | ( C329 .edgesOutOf { C332 } ) ) . C342 ) = ( D210 . C342 ) by L2406 , FUNCT_1:49;
L2409: ( ( the_Source_of C329 ) . C342 ) in { C332 } by L2407 , GLIB_000:def 27;
L2410: ( ( the_Source_of C329 ) . C342 ) = C332 by L2409 , TARSKI:def 1;
L2411:
now
per cases ;
suppose L2412: C342 = D207;

L2413: C342 in { D207 } by L2412 , TARSKI:def 1;
L2414: C342 in ( dom ( D207 .--> ( ( D209 . D207 ) - D211 ) ) ) by L2413 , FUNCOP_1:13;
L2415: ( D215 . C342 ) = ( ( D207 .--> ( ( D209 . D207 ) - D211 ) ) . D207 ) by L2414 , L2412 , FUNCT_4:13
.= ( ( D209 . D207 ) - D211 ) by FUNCOP_1:72
.= ( D210 . C342 ) by L2404 , L2407 , L2412 , FUNCT_1:49;
thus L2416: ( ( D210 | ( C329 .edgesOutOf { C332 } ) ) . C342 ) = ( D215 . C342 ) by L2415 , L2406 , FUNCT_1:49;
end;
suppose L2417: C342 <> D207;

L2418:
now
assume L2419: C342 in ( C333 .edges() );
consider C343 , C344 being (Vertex of C329), C345 being  odd (Element of ( NAT )) such that L2420: ( C345 + 2 ) <= ( len C333 ) and L2421: C343 = ( C333 . C345 ) and L2422: C342 = ( C333 . ( C345 + 1 ) ) and L2423: C344 = ( C333 . ( C345 + 2 ) ) and L2424: C342 Joins C343 , C344 , C329 by L2419 , GLIB_001:103;
L2425:
now
per cases  by L2410 , L2424 , GLIB_000:def 13;
suppose L2426: C343 = C332;

L2427: ( ( C345 + 2 ) - 2 ) < ( ( len C333 ) - ( 0 ) ) by L2420 , XREAL_1:15;
L2428: ( C333 . C345 ) = ( C333 . ( len C333 ) ) by L2299 , L2421 , L2426 , GLIB_001:17;
L2429: C345 = 1 by L2428 , L2427 , GLIB_001:def 28;
thus L2430: contradiction by L2429 , L2298 , L2299 , L2421 , L2426 , GLIB_001:17;
end;
suppose L2431: C344 = C332;

L2432: ( C333 . ( C345 + 2 ) ) = ( C333 . ( len C333 ) ) by L2431 , L2299 , L2423 , GLIB_001:17;
L2433:
now
assume L2434: ( C345 + 2 ) < ( len C333 );
L2435: ( C345 + 2 ) = 1 by L2434 , L2432 , GLIB_001:def 28;
L2436: 1 <= ( 1 - 2 ) by L2435 , ABIAN:12;
thus L2437: contradiction by L2436;
end;
L2438: ( C345 + 2 ) = ( len C333 ) by L2433 , L2420 , XXREAL_0:1;
thus L2439: contradiction by L2438 , L2417 , L2422;
end;
end;
thus L2441: contradiction by L2425;
end;
L2442: (not C342 in { D207 }) by L2417 , TARSKI:def 1;
L2443: (not C342 in ( dom ( D207 .--> ( ( D209 . D207 ) - D211 ) ) )) by L2442;
L2444: ( D215 . C342 ) = ( D209 . C342 ) by L2443 , FUNCT_4:11
.= ( C330 . C342 ) by L2407 , FUNCT_1:49;
thus L2445: ( ( D210 | ( C329 .edgesOutOf { C332 } ) ) . C342 ) = ( D215 . C342 ) by L2444 , L2300 , L2407 , L2408 , L2418 , L1083;
end;
end;
thus L2447: ( ( D210 | ( C329 .edgesOutOf { C332 } ) ) . C342 ) = ( D215 . C342 ) by L2411;
end;
L2448: ( Sum ( D210 | ( C329 .edgesOutOf { C332 } ) ) ) = ( ( ( Sum D209 ) + ( ( D209 . D207 ) - D211 ) ) - ( D209 . D207 ) ) by L2405 , L2403 , L2402 , FUNCT_1:2 , GLIB_004:9
.= ( ( Sum D209 ) - D211 );
L2449: ( dom ( D210 | ( C329 .edgesInto { C332 } ) ) ) = ( C329 .edgesInto { C332 } ) by PARTFUN1:def 2;
L2450:
now
let C346 being set;
assume L2451: C346 in ( dom ( D210 | ( C329 .edgesInto { C332 } ) ) );
L2452: C346 in ( C329 .edgesInto { C332 } ) by L2451;
L2453: ( ( the_Target_of C329 ) . C346 ) in { C332 } by L2452 , GLIB_000:def 26;
L2454: ( ( the_Target_of C329 ) . C346 ) = C332 by L2453 , TARSKI:def 1;
L2455:
now
assume L2456: C346 in ( C333 .edges() );
consider C347 , C348 being (Vertex of C329), C349 being  odd (Element of ( NAT )) such that L2457: ( C349 + 2 ) <= ( len C333 ) and L2458: C347 = ( C333 . C349 ) and L2459: C346 = ( C333 . ( C349 + 1 ) ) and L2460: C348 = ( C333 . ( C349 + 2 ) ) and L2461: C346 Joins C347 , C348 , C329 by L2456 , GLIB_001:103;
L2462:
now
per cases  by L2454 , L2461 , GLIB_000:def 13;
suppose L2463: C347 = C332;

L2464: ( ( C349 + 2 ) - 2 ) < ( ( len C333 ) - ( 0 ) ) by L2457 , XREAL_1:15;
L2465: ( C333 . C349 ) = ( C333 . ( len C333 ) ) by L2299 , L2458 , L2463 , GLIB_001:17;
L2466: C349 = 1 by L2465 , L2464 , GLIB_001:def 28;
thus L2467: contradiction by L2466 , L2298 , L2299 , L2458 , L2463 , GLIB_001:17;
end;
suppose L2468: C348 = C332;

L2469: ( C333 . ( C349 + 2 ) ) = ( C333 . ( len C333 ) ) by L2468 , L2299 , L2460 , GLIB_001:17;
L2470:
now
assume L2471: ( C349 + 2 ) < ( len C333 );
L2472: ( C349 + 2 ) = 1 by L2471 , L2469 , GLIB_001:def 28;
L2473: 1 <= ( 1 - 2 ) by L2472 , ABIAN:12;
thus L2474: contradiction by L2473;
end;
L2475: ( C349 + 2 ) = ( len C333 ) by L2470 , L2457 , XXREAL_0:1;
L2476: ( C333 . D206 ) = C332 by L2475 , L2398 , L2454 , L2459 , GLIB_000:def 14;
L2477: D206 = 1 by L2476 , L2306 , L2305 , GLIB_001:def 28;
thus L2478: contradiction by L2477 , L2298 , L2299 , L2476 , GLIB_001:17;
end;
end;
thus L2480: contradiction by L2462;
end;
L2481: ( D210 . C346 ) = ( C330 . C346 ) by L2455 , L2300 , L2452 , L1083
.= ( D208 . C346 ) by L2452 , FUNCT_1:49;
thus L2482: ( ( D210 | ( C329 .edgesInto { C332 } ) ) . C346 ) = ( D208 . C346 ) by L2481 , L2451 , FUNCT_1:49;
end;
L2483: ( dom D208 ) = ( C329 .edgesInto { C332 } ) by PARTFUN1:def 2;
thus L2484: ( D210 .flow (C331 , C332) ) = ( ( Sum D208 ) - ( ( Sum D209 ) - D211 ) ) by L2483 , L2448 , L2449 , L2450 , FUNCT_1:2
.= ( ( ( Sum D208 ) - ( Sum D209 ) ) + D211 )
.= ( ( C330 .flow (C331 , C332) ) + D211 );
end;
end;
thus L2486: thesis by L2309;
end;
theorem
L2487: (for B218 being  finite  natural-weighted WGraph holds (for B219 , B220 being (Vertex of B218) holds (for B221 being Nat holds (B219 <> B220 implies ( ( FF:CompSeq (B218 , B219 , B220) ) . B221 ) has_valid_flow_from B219 , B220))))
proof
let C350 being  finite  natural-weighted WGraph;
let C351 , C352 being (Vertex of C350);
let C353 being Nat;
set D216 = ( FF:CompSeq (C350 , C351 , C352) );
defpred S19[ Nat ] means ( D216 . $1 ) has_valid_flow_from C351 , C352;
L2488:
now
set D217 = ( D216 . ( 0 ) );
L2489: D217 = ( ( the_Edges_of C350 ) --> ( 0 ) ) by L1210;
thus L2490: (for B222 being set holds (B222 in ( the_Edges_of C350 ) implies (( 0 ) <= ( D217 . B222 ) & ( D217 . B222 ) <= ( ( the_Weight_of C350 ) . B222 )))) by L2489 , FUNCOP_1:7;
let C354 being (Vertex of C350);
set D218 = ( EmptyBag ( C354 .edgesIn() ) );
set D219 = ( EmptyBag ( C354 .edgesOut() ) );
set D220 = ( D217 | ( C354 .edgesIn() ) );
set D221 = ( D217 | ( C354 .edgesOut() ) );
L2491:
now
let C355 being set;
assume L2492: C355 in ( C354 .edgesOut() );
L2493: ( D221 . C355 ) = ( D217 . C355 ) by L2492 , FUNCT_1:49
.= ( 0 ) by L2489 , L2492 , FUNCOP_1:7;
thus L2494: ( D219 . C355 ) = ( D221 . C355 ) by L2493 , PRE_POLY:52;
end;
L2495: ( Sum D221 ) = ( Sum D219 ) by L2491 , GLIB_004:6
.= ( 0 ) by UPROOTS:11;
assume that
L2496: C354 <> C351
and
L2497: C354 <> C352;
L2498:
now
let C356 being set;
assume L2499: C356 in ( C354 .edgesIn() );
L2500: ( D220 . C356 ) = ( D217 . C356 ) by L2499 , FUNCT_1:49
.= ( 0 ) by L2489 , L2499 , FUNCOP_1:7;
thus L2501: ( D218 . C356 ) = ( D220 . C356 ) by L2500 , PRE_POLY:52;
end;
L2502: ( Sum D220 ) = ( Sum D218 ) by L2498 , GLIB_004:6
.= ( 0 ) by UPROOTS:11;
thus L2503: ( Sum D220 ) = ( Sum D221 ) by L2502 , L2495;
end;
L2504: S19[ ( 0 ) ] by L2488 , L34;
assume L2505: C351 <> C352;
L2506:
now
let C357 being Nat;
set D222 = ( D216 . C357 );
set D223 = ( D216 . ( C357 + 1 ) );
assume L2507: D222 has_valid_flow_from C351 , C352;
L2508: D223 = ( FF:Step (D222 , C351 , C352) ) by L1210;
L2509:
now
per cases ;
suppose L2510: C352 in ( dom ( AP:FindAugPath (D222 , C351) ) );

set D224 = ( AP:GetAugPath (D222 , C351 , C352) );
L2511: D224 is_Walk_from C351 , C352 by L2510 , L334;
L2512: D224 is_augmenting_wrt D222 by L2510 , L334;
L2513: D223 = ( FF:PushFlow (D222 , D224) ) by L2508 , L2510 , L1201;
thus L2514: S19[ ( C357 + 1 ) ] by L2513 , L2505 , L2507 , L2511 , L2512 , L1862;
end;
suppose L2515: (not C352 in ( dom ( AP:FindAugPath (D222 , C351) ) ));

thus L2516: S19[ ( C357 + 1 ) ] by L2515 , L2507 , L2508 , L1201;
end;
end;
thus L2518: S19[ ( C357 + 1 ) ] by L2509;
end;
L2519: (for B223 being Nat holds (S19[ B223 ] implies S19[ ( B223 + 1 ) ])) by L2506;
L2520: (for B224 being Nat holds S19[ B224 ]) from NAT_1:sch 2(L2504 , L2519);
thus L2521: thesis by L2520;
end;
theorem
L2522: (for B225 being  finite  natural-weighted WGraph holds (for B226 , B227 being (Vertex of B225) holds (B226 <> B227 implies ( FF:CompSeq (B225 , B226 , B227) ) is  halting)))
proof
let C358 being  finite  natural-weighted WGraph;
let C359 , C360 being (Vertex of C358);
set D225 = ( FF:CompSeq (C358 , C359 , C360) );
assume L2523: C359 <> C360;
L2524:
now
set D226 = { C359 };
defpred S20[ (Element of ( NAT )) ] means ($1 <= ( ( D225 . $1 ) .flow (C359 , C360) ) & ( ( D225 . $1 ) .flow (C359 , C360) ) is (Element of ( NAT )));
L2525: C359 in D226 by TARSKI:def 1;
set D227 = ( ( the_Weight_of C358 ) | ( C358 .edgesDBetween (D226 , ( ( the_Vertices_of C358 ) \ D226 )) ) );
L2526: ( degree D227 ) = ( Sum D227 );
reconsider D228 = ( Sum D227 ) as (Element of ( NAT )) by L2526;
set D229 = ( D225 . ( D228 + 1 ) );
assume L2527: (for B228 being (Element of ( NAT )) holds ( D225 . B228 ) <> ( D225 . ( B228 + 1 ) ));
L2528:
now
let C361 being (Element of ( NAT ));
set D230 = ( D225 . C361 );
set D231 = ( D225 . ( C361 + 1 ) );
assume that
L2529: C361 <= ( D230 .flow (C359 , C360) )
and
L2530: ( D230 .flow (C359 , C360) ) is (Element of ( NAT ));
reconsider D232 = ( D230 .flow (C359 , C360) ) as (Element of ( NAT )) by L2530;
set D233 = ( AP:GetAugPath (D230 , C359 , C360) );
L2531: D231 = ( FF:Step (D230 , C359 , C360) ) by L1210;
L2532:
now
assume L2533: (not C360 in ( dom ( AP:FindAugPath (D230 , C359) ) ));
L2534: D231 = D230 by L2533 , L2531 , L1201;
thus L2535: contradiction by L2534 , L2527;
end;
L2536: D233 is_augmenting_wrt D230 by L2532 , L334;
L2537: D233 is_Walk_from C359 , C360 by L2532 , L334;
L2538: ( D233 .last() ) = C360 by L2537 , GLIB_001:def 23;
L2539: D231 = ( FF:PushFlow (D230 , ( AP:GetAugPath (D230 , C359 , C360) )) ) by L2531 , L2532 , L1201;
L2540: ( D232 + ( D233 .tolerance D230 ) ) = ( D231 .flow (C359 , C360) ) by L2539 , L2523 , L2536 , L2537 , L2297;
reconsider D234 = ( D231 .flow (C359 , C360) ) as (Element of ( NAT )) by L2540;
L2541: ( D233 .first() ) = C359 by L2537 , GLIB_001:def 23;
L2542: ( 0 ) < ( D233 .tolerance D230 ) by L2541 , L2523 , L2536 , L2538 , L1838 , GLIB_001:127;
L2543: ( ( D232 + ( D233 .tolerance D230 ) ) - ( D233 .tolerance D230 ) ) < ( D234 - ( 0 ) ) by L2542 , L2540 , XREAL_1:15;
L2544: C361 < D234 by L2543 , L2529 , XXREAL_0:2;
thus L2545: ( C361 + 1 ) <= ( D231 .flow (C359 , C360) ) by L2544 , NAT_1:13;
thus L2546: ( D231 .flow (C359 , C360) ) is (Element of ( NAT )) by L2540;
end;
L2547: (for B229 being (Element of ( NAT )) holds (S20[ B229 ] implies S20[ ( B229 + 1 ) ])) by L2528;
L2548:
now
set D235 = ( EmptyBag ( C358 .edgesInto { C360 } ) );
set D236 = ( EmptyBag ( C358 .edgesOutOf { C360 } ) );
set D237 = ( D225 . ( 0 ) );
set D238 = ( D237 | ( C358 .edgesInto { C360 } ) );
set D239 = ( D237 | ( C358 .edgesOutOf { C360 } ) );
L2549: D237 = ( ( the_Edges_of C358 ) --> ( 0 ) ) by L1210;
L2550:
now
let C362 being set;
assume L2551: C362 in ( C358 .edgesInto { C360 } );
thus L2552: ( D238 . C362 ) = ( D237 . C362 ) by L2551 , FUNCT_1:49
.= ( 0 ) by L2549 , L2551 , FUNCOP_1:7
.= ( D235 . C362 ) by PRE_POLY:52;
end;
L2553: ( Sum D238 ) = ( Sum D235 ) by L2550 , GLIB_004:6
.= ( 0 ) by UPROOTS:11;
L2554:
now
let C363 being set;
assume L2555: C363 in ( C358 .edgesOutOf { C360 } );
thus L2556: ( D239 . C363 ) = ( D237 . C363 ) by L2555 , FUNCT_1:49
.= ( 0 ) by L2549 , L2555 , FUNCOP_1:7
.= ( D236 . C363 ) by PRE_POLY:52;
end;
L2557: ( Sum D239 ) = ( Sum D236 ) by L2554 , GLIB_004:6
.= ( 0 ) by UPROOTS:11;
thus L2558: ( D237 .flow (C359 , C360) ) = ( (( 0 ) qua Nat) - ( 0 ) ) by L2557 , L2553;
thus L2559: ( D237 .flow (C359 , C360) ) is (Element of ( NAT )) by L2553 , L2557;
end;
L2560: S20[ ( 0 ) ] by L2548;
L2561: (for B230 being (Element of ( NAT )) holds S20[ B230 ]) from NAT_1:sch 1(L2560 , L2547);
reconsider D240 = ( D229 .flow (C359 , C360) ) as (Element of ( NAT )) by L2561;
L2562: ( ( Sum D227 ) + 1 ) <= D240 by L2561;
L2563: ( Sum D227 ) < ( D229 .flow (C359 , C360) ) by L2562 , NAT_1:13;
L2564: (not C360 in D226) by L2523 , TARSKI:def 1;
thus L2565: contradiction by L2564 , L2525 , L2563 , L1818 , L2487;
end;
thus L2566: thesis by L2524 , GLIB_000:def 54;
end;
theorem
L2567: (for B231 being  finite  natural-weighted WGraph holds (for B232 being (FF:ELabeling of B231) holds (for B233 , B234 being set holds ((B232 has_valid_flow_from B233 , B234 & (not (ex B235 being (Path of B231) st (B235 is_Walk_from B233 , B234 & B235 is_augmenting_wrt B232)))) implies B232 has_maximum_flow_from B233 , B234))))
proof
let C364 being  finite  natural-weighted WGraph;
let C365 being (FF:ELabeling of C364);
let C366 , C367 being set;
assume that
L2568: C365 has_valid_flow_from C366 , C367
and
L2569: (not (ex B236 being (Path of C364) st (B236 is_Walk_from C366 , C367 & B236 is_augmenting_wrt C365)));
reconsider D241 = C366 as (Vertex of C364) by L2568 , L34;
set D242 = ( AP:CompSeq (C365 , D241) );
set D243 = ( AP:FindAugPath (C365 , D241) );
set D244 = ( D242 . ( ( D242 .Lifespan() ) + 1 ) );
reconsider D245 = ( dom D243 ) as (Subset of ( the_Vertices_of C364 ));
set D246 = ( C364 .edgesDBetween (D245 , ( ( the_Vertices_of C364 ) \ D245 )) );
set D247 = ( C365 | D246 );
set D248 = ( ( the_Weight_of C364 ) | D246 );
set D249 = ( choose ( AP:NextBestEdges D243 ) );
L2570: ( AP:CompSeq (C365 , D241) ) is  halting by L254;
L2571: D244 = D243 by L2570 , GLIB_000:def 55;
L2572: D244 = ( AP:Step D243 ) by L184;
L2573:
now
assume L2574: ( AP:NextBestEdges D243 ) <> ( {} );
L2575:
now
per cases  by L2574 , L119;
suppose L2576: D249 is_forward_edge_wrt D243;

L2577: ( ( the_Source_of C364 ) . D249 ) in D245 by L2576 , L41;
L2578: D243 = ( D243 +* ( ( ( the_Target_of C364 ) . D249 ) .--> D249 ) ) by L2577 , L2572 , L2571 , L2574 , L137;
L2579: (not ( ( the_Target_of C364 ) . D249 ) in D245) by L2576 , L41;
thus L2580: contradiction by L2579 , L2578 , L3;
end;
suppose L2581: D249 is_backward_edge_wrt D243;

L2582: (not ( ( the_Source_of C364 ) . D249 ) in D245) by L2581 , L43;
L2583: D243 = ( D243 +* ( ( ( the_Source_of C364 ) . D249 ) .--> D249 ) ) by L2582 , L2572 , L2571 , L2574 , L137;
thus L2584: contradiction by L2583 , L2582 , L3;
end;
end;
thus L2586: contradiction by L2575;
end;
L2587:
now
let C368 being set;
assume L2588: C368 in D246;
L2589: ( D247 . C368 ) = ( C365 . C368 ) by L2588 , FUNCT_1:49;
L2590: C368 DSJoins D245 , ( ( the_Vertices_of C364 ) \ D245 ) , C364 by L2588 , GLIB_000:def 31;
L2591: ( ( the_Target_of C364 ) . C368 ) in ( ( the_Vertices_of C364 ) \ D245 ) by L2590 , GLIB_000:def 16;
L2592: (not ( ( the_Target_of C364 ) . C368 ) in D245) by L2591 , XBOOLE_0:def 5;
L2593: ( D248 . C368 ) = ( ( the_Weight_of C364 ) . C368 ) by L2588 , FUNCT_1:49;
L2594: ( ( the_Source_of C364 ) . C368 ) in D245 by L2590 , GLIB_000:def 16;
L2595:
now
assume L2596: ( D247 . C368 ) < ( D248 . C368 );
L2597: C368 is_forward_edge_wrt D243 by L2596 , L2588 , L2589 , L2593 , L2594 , L2592 , L41;
thus L2598: contradiction by L2597 , L2573 , L119;
end;
L2599: ( D247 . C368 ) <= ( D248 . C368 ) by L2568 , L2588 , L2589 , L2593 , L34;
thus L2600: ( D247 . C368 ) = ( D248 . C368 ) by L2599 , L2595 , XXREAL_0:1;
end;
set D250 = ( C364 .edgesDBetween (( ( the_Vertices_of C364 ) \ D245 ) , D245) );
set D251 = ( C365 | D250 );
set D252 = ( EmptyBag D250 );
L2601:
now
let C369 being set;
assume L2602: C369 in D250;
L2603: C369 DSJoins ( ( the_Vertices_of C364 ) \ D245 ) , D245 , C364 by L2602 , GLIB_000:def 31;
L2604: ( ( the_Target_of C364 ) . C369 ) in D245 by L2603 , GLIB_000:def 16;
L2605: ( ( the_Source_of C364 ) . C369 ) in ( ( the_Vertices_of C364 ) \ D245 ) by L2603 , GLIB_000:def 16;
L2606: (not ( ( the_Source_of C364 ) . C369 ) in D245) by L2605 , XBOOLE_0:def 5;
L2607: ( D251 . C369 ) = ( C365 . C369 ) by L2602 , FUNCT_1:49;
L2608:
now
assume L2609: ( 0 ) < ( D251 . C369 );
L2610: C369 is_backward_edge_wrt D243 by L2609 , L2602 , L2607 , L2604 , L2606 , L43;
thus L2611: contradiction by L2610 , L2573 , L119;
end;
L2612: D252 = ( D250 --> ( 0 ) ) by PRE_POLY:def 13;
L2613: ( D252 . C369 ) = ( 0 ) by L2612 , L2602 , FUNCOP_1:7;
thus L2614: ( D251 . C369 ) = ( D252 . C369 ) by L2613 , L2608;
end;
L2615: ( Sum ( C365 | D250 ) ) = ( Sum D252 ) by L2601 , GLIB_004:6;
L2616: ( Sum ( C365 | D250 ) ) = ( 0 ) by L2615 , UPROOTS:11;
L2617: (not C367 in ( dom D243 )) by L2569 , L935;
L2618: ( C365 .flow (C366 , C367) ) = ( ( Sum ( C365 | D246 ) ) - ( Sum ( C365 | D250 ) ) ) by L2617 , L2568 , L996 , L1251;
L2619: ( C365 .flow (C366 , C367) ) = ( Sum ( ( the_Weight_of C364 ) | D246 ) ) by L2618 , L2587 , L2616 , GLIB_004:6;
L2620: (for B237 being (FF:ELabeling of C364) holds (B237 has_valid_flow_from C366 , C367 implies ( B237 .flow (C366 , C367) ) <= ( C365 .flow (C366 , C367) ))) by L2619 , L2617 , L996 , L1818;
thus L2621: thesis by L2620 , L2568 , L37;
end;
::$N Ford/Fulkerson maximum flow algorithm
theorem
L2622: (for B238 being  finite  natural-weighted WGraph holds (for B239 , B240 being (Vertex of B238) holds (B240 <> B239 implies ( FF:MaxFlow (B238 , B239 , B240) ) has_maximum_flow_from B239 , B240)))
proof
let C370 being  finite  natural-weighted WGraph;
let C371 , C372 being (Vertex of C370);
set D253 = ( FF:CompSeq (C370 , C371 , C372) );
set D254 = ( D253 .Lifespan() );
set D255 = ( D253 . D254 );
set D256 = ( D253 . ( D254 + 1 ) );
L2623: D256 = ( FF:Step (D255 , C371 , C372) ) by L1210;
assume L2624: C372 <> C371;
L2625: D253 is  halting by L2624 , L2522;
L2626: D255 = ( D253 . ( D254 + 1 ) ) by L2625 , GLIB_000:def 55;
L2627:
now
given C373 being (Path of C370) such that
L2628: C373 is_Walk_from C371 , C372
and
L2629: C373 is_augmenting_wrt D255;

set D257 = ( AP:GetAugPath (D255 , C371 , C372) );
L2630: C372 in ( dom ( AP:FindAugPath (D255 , C371) ) ) by L2628 , L2629 , L935;
L2631: D257 is_Walk_from C371 , C372 by L2630 , L334;
L2632: ( D257 .first() ) = C371 by L2631 , GLIB_001:def 23;
L2633: ( D257 .last() ) = C372 by L2631 , GLIB_001:def 23;
L2634: D257 is_augmenting_wrt D255 by L2630 , L334;
L2635: D256 = ( FF:PushFlow (D255 , ( AP:GetAugPath (D255 , C371 , C372) )) ) by L2623 , L2630 , L1201;
L2636: ( ( D255 .flow (C371 , C372) ) + ( D257 .tolerance D255 ) ) = ( D256 .flow (C371 , C372) ) by L2635 , L2624 , L2631 , L2634 , L2297;
thus L2637: contradiction by L2636 , L2624 , L2626 , L2632 , L2633 , L2634 , L1838 , GLIB_001:127;
end;
thus L2638: thesis by L2627 , L2624 , L2487 , L2567;
end;
