:: The Construction and Computation of While-loop Programs for SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMPDS_2, FSM_1, AMI_2, SUBSET_1, SCMP_GCD, AMI_3,
      FUNCT_1, CARD_1, AMI_1, ARYTM_3, CARD_3, XXREAL_0, INT_1, SCMFSA_9,
      TURING_1, ARYTM_1, SCMPDS_4, SCMFSA_7, RELAT_1, UNIALG_2, SCMFSA7B,
      FUNCT_4, CIRCUIT2, TARSKI, SCMFSA6B, MSUALG_1, GRAPHSP, STRUCT_0,
      VALUED_1, NAT_1, XBOOLE_0, ORDINAL1, PARTFUN1, EXTPRO_1, SCMFSA6C,
      COMPOS_1, MEMSTR_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, FUNCT_2, CARD_1, NUMBERS, RELAT_1,
      FUNCT_1, PARTFUN1, VALUED_1, XCMPLX_0, FUNCT_4, RECDEF_1, ORDINAL1,
      NAT_1, INT_1, STRUCT_0, MEMSTR_0, COMPOS_0, COMPOS_1, EXTPRO_1, AMI_2,
      AMI_3, SCMPDS_2, SCMPDS_4, SCMPDS_6, SCMP_GCD, CARD_3, DOMAIN_1,
      XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, RECDEF_1, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, PRE_POLY, AMI_2, MEMSTR_0, RELSET_1, SCM_INST;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      XBOOLE_0, VALUED_0, VALUED_1, RELAT_1, GRFUNC_1, FUNCT_2, COMPOS_1,
      AFINSQ_1, EXTPRO_1, PBOOLE, FUNCT_4, MEMSTR_0, AMI_3, COMPOS_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_3, AMI_2, MEMSTR_0, SCM_INST;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, MEMSTR_0, SCMPDS_3,
      GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD, SCMPDS_7,
      XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0, ZFMISC_1, PBOOLE,
      PARTFUN1, AFINSQ_1, COMPOS_1, EXTPRO_1, CARD_3, AMI_2;
 schemes NAT_1, FUNCT_2;

begin
set D1 = ( NAT );
set D2 = ( SCM-Data-Loc );
theorem
L1: (for B1 being Int_position holds (ex B2 being (Element of ( NAT )) st B1 = ( intpos B2 )))
proof
let C1 being Int_position;
L2: C1 in D2 by AMI_2:def 16;
consider C2 , C3 being set such that L3: C2 in { 1 } and L4: C3 in ( NAT ) and L5: C1 = [ C2 , C3 ] by L2 , ZFMISC_1:84;
reconsider D3 = C3 as (Element of ( NAT )) by L4;
take D3;
thus L6: ( intpos D3 ) = ( dl. D3 ) by SCMP_GCD:def 1
.= C1 by L3 , L5 , TARSKI:def 1;
end;
canceled 1;
theorem
L7: (for B3 being (State of ( SCMPDS )) holds (for B4 being (Instruction of ( SCMPDS )) holds (( InsCode B4 ) in { ( 0 ) , 4 , 5 , 6 , 14 } implies ( Initialize B3 ) = ( Initialize ( Exec (B4 , B3) ) ))))
proof
let C4 being (State of ( SCMPDS ));
let C5 being (Instruction of ( SCMPDS ));
assume L8: ( InsCode C5 ) in { ( 0 ) , 4 , 5 , 6 , 14 };
L9: ( DataPart ( Exec (C5 , C4) ) ) = ( DataPart C4 ) by L8 , SCMPDS_7:7;
thus L10: thesis by L9 , MEMSTR_0:80;
end;
canceled 1;
theorem
L11: (for B5 being Int_position holds (ex B6 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) st (for B7 being (State of ( SCMPDS )) holds ((( B7 . B5 ) <= ( 0 ) implies ( B6 . B7 ) = ( 0 )) & (( B7 . B5 ) > ( 0 ) implies ( B6 . B7 ) = ( B7 . B5 ))))))
proof
let C6 being Int_position;
defpred S1[ set , set ] means (ex B8 being (State of ( SCMPDS )) st (B8 = $1 & (( B8 . C6 ) <= ( 0 ) implies $2 = ( 0 )) & (( B8 . C6 ) > ( 0 ) implies $2 = ( B8 . C6 ))));
L12:
now
let C7 being (Element of ( product ( the_Values_of ( SCMPDS ) ) ));
per cases ;
suppose L13: ( C7 . C6 ) <= ( 0 );

reconsider D4 = ( 0 ) as (Element of ( NAT ));
take D5 = D4;
thus L14: S1[ C7 , D5 ] by L13;
end;
suppose L15: ( C7 . C6 ) > ( 0 );

reconsider D6 = ( C7 . C6 ) as (Element of ( NAT )) by L15 , INT_1:3;
take D7 = D6;
thus L16: S1[ C7 , D7 ] by L15;
end;
end;
consider C8 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L18: (for B9 being (Element of ( product ( the_Values_of ( SCMPDS ) ) )) holds S1[ B9 , ( C8 . B9 ) ]) from FUNCT_2:sch 3(L12);
L19: (for R3 being (State of ( SCMPDS )) holds S1[ R3 , ( C8 . R3 ) ])
proof
let R3 being (State of ( SCMPDS ));
reconsider D8 = R3 as (Element of ( product ( the_Values_of ( SCMPDS ) ) )) by CARD_3:107;
L20: S1[ D8 , ( C8 . D8 ) ] by L18;
thus L21: thesis by L20;
end;
take C8;
thus L22:now
let R3 being (State of ( SCMPDS ));
L23: S1[ R3 , ( C8 . R3 ) ] by L19;
thus L24: ((( R3 . C6 ) <= ( 0 ) implies ( C8 . R3 ) = ( 0 )) & (( R3 . C6 ) > ( 0 ) implies ( C8 . R3 ) = ( R3 . C6 ))) by L23;
end;
end;
begin
definition
canceled 1;
let C9 being Int_position;
let C10 being Integer;
let C11 being (Program of ( SCMPDS ));
func while<0 (C9 , C10 , C11) -> (Program of ( SCMPDS )) equals 
( ( ( (C9 , C10) >=0_goto ( ( card C11 ) + 2 ) ) ';' C11 ) ';' ( goto ( - ( ( card C11 ) + 1 ) ) ) );
coherence;
end;
registration
let C12 being  shiftable (Program of ( SCMPDS ));
let C13 being Int_position;
let C14 being Integer;
cluster ( while<0 (C13 , C14 , C12) ) ->  shiftable;
correctness
proof
set D9 = ( while<0 (C13 , C14 , C12) );
set D10 = ( (C13 , C14) >=0_goto ( ( card C12 ) + 2 ) );
set D11 = ( ( Load D10 ) ';' C12 );
L24: D11 = ( D10 ';' C12 ) by SCMPDS_4:def 2;
L25: ( card D11 ) = ( ( card C12 ) + 1 ) by L24 , SCMPDS_6:6;
L26: ( ( card D11 ) + ( - ( ( card C12 ) + 1 ) ) ) = ( 0 ) by L25;
thus L27: thesis by L26 , L24 , SCMPDS_4:23;
end;
end;
registration
let C15 being  halt-free (Program of ( SCMPDS ));
let C16 being Int_position;
let C17 being Integer;
cluster ( while<0 (C16 , C17 , C15) ) ->  halt-free;
correctness;
end;
theorem
L30: (for B10 being Int_position holds (for B11 being Integer holds (for B12 being (Program of ( SCMPDS )) holds ( card ( while<0 (B10 , B11 , B12) ) ) = ( ( card B12 ) + 2 ))))
proof
let C18 being Int_position;
let C19 being Integer;
let C20 being (Program of ( SCMPDS ));
set D12 = ( (C18 , C19) >=0_goto ( ( card C20 ) + 2 ) );
set D13 = ( D12 ';' C20 );
thus L31: ( card ( while<0 (C18 , C19 , C20) ) ) = ( ( card D13 ) + 1 ) by SCMP_GCD:4
.= ( ( ( card C20 ) + 1 ) + 1 ) by SCMPDS_6:6
.= ( ( card C20 ) + 2 );
end;
L32: (for B13 being Int_position holds (for B14 being Integer holds (for B15 being (Program of ( SCMPDS )) holds ( card ( stop ( while<0 (B13 , B14 , B15) ) ) ) = ( ( card B15 ) + 3 ))))
proof
let C21 being Int_position;
let C22 being Integer;
let C23 being (Program of ( SCMPDS ));
thus L33: ( card ( stop ( while<0 (C21 , C22 , C23) ) ) ) = ( ( card ( while<0 (C21 , C22 , C23) ) ) + 1 ) by COMPOS_1:55
.= ( ( ( card C23 ) + 2 ) + 1 ) by L30
.= ( ( card C23 ) + 3 );
end;
theorem
L34: (for B16 being Int_position holds (for B17 being Integer holds (for B18 being (Element of ( NAT )) holds (for B19 being (Program of ( SCMPDS )) holds (B18 < ( ( card B19 ) + 2 ) iff B18 in ( dom ( while<0 (B16 , B17 , B19) ) ))))))
proof
let C24 being Int_position;
let C25 being Integer;
let C26 being (Element of ( NAT ));
let C27 being (Program of ( SCMPDS ));
L35: ( card ( while<0 (C24 , C25 , C27) ) ) = ( ( card C27 ) + 2 ) by L30;
thus L36: thesis by L35 , AFINSQ_1:66;
end;
theorem
L37: (for B20 being Int_position holds (for B21 being Integer holds (for B22 being (Program of ( SCMPDS )) holds (( ( while<0 (B20 , B21 , B22) ) . ( 0 ) ) = ( (B20 , B21) >=0_goto ( ( card B22 ) + 2 ) ) & ( ( while<0 (B20 , B21 , B22) ) . ( ( card B22 ) + 1 ) ) = ( goto ( - ( ( card B22 ) + 1 ) ) )))))
proof
let C28 being Int_position;
let C29 being Integer;
let C30 being (Program of ( SCMPDS ));
set D14 = ( (C28 , C29) >=0_goto ( ( card C30 ) + 2 ) );
set D15 = ( goto ( - ( ( card C30 ) + 1 ) ) );
set D16 = ( D14 ';' C30 );
set D17 = ( C30 ';' D15 );
set D18 = ( while<0 (C28 , C29 , C30) );
L38: D18 = ( D14 ';' D17 ) by SCMPDS_4:15;
thus L39: ( D18 . ( 0 ) ) = D14 by L38 , SCMPDS_6:7;
L40: ( card D16 ) = ( ( card C30 ) + 1 ) by SCMPDS_6:6;
thus L41: thesis by L40 , SCMP_GCD:6;
end;
theorem
L42: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B23 being (State of ( SCMPDS )) holds (for B24 being (Program of ( SCMPDS )) holds (for B25 being Int_position holds (for B26 being Integer holds (( B23 . ( DataLoc (( B23 . B25 ) , B26) ) ) >= ( 0 ) implies (( while<0 (B25 , B26 , B24) ) is_closed_on B23 , R4 & ( while<0 (B25 , B26 , B24) ) is_halting_on B23 , R4)))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C31 being (State of ( SCMPDS ));
let C32 being (Program of ( SCMPDS ));
let C33 being Int_position;
let C34 being Integer;
set D19 = ( DataLoc (( C31 . C33 ) , C34) );
assume L43: ( C31 . D19 ) >= ( 0 );
set D20 = ( (C33 , C34) >=0_goto ( ( card C32 ) + 2 ) );
set D21 = ( goto ( - ( ( card C32 ) + 1 ) ) );
set D22 = ( while<0 (C33 , C34 , C32) );
set D23 = ( stop D22 );
set D24 = ( Initialize C31 );
set D25 = ( R4 +* D23 );
set D26 = ( Comput (D25 , D24 , 1) );
set D27 = D25;
L44: ( IC D24 ) = ( 0 ) by MEMSTR_0:def 11;
L45: (not D19 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L46: (not C33 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L47: ( D24 . ( DataLoc (( D24 . C33 ) , C34) ) ) = ( D24 . D19 ) by L46 , FUNCT_4:11
.= ( C31 . D19 ) by L45 , FUNCT_4:11;
L48: D22 = ( D20 ';' ( C32 ';' D21 ) ) by SCMPDS_4:15;
L49: ( Comput (D25 , D24 , ( ( 0 ) + 1 )) ) = ( Following (D25 , ( Comput (D25 , D24 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D25 , D24) )
.= ( Exec (D20 , D24) ) by L48 , SCMPDS_6:11;
L50: ( IC D26 ) = ( ICplusConst (D24 , ( ( card C32 ) + 2 )) ) by L49 , L43 , L47 , SCMPDS_2:57
.= ( ( 0 ) + ( ( card C32 ) + 2 ) ) by L44 , SCMPDS_6:12;
L51: ( card D22 ) = ( ( card C32 ) + 2 ) by L30;
L52: ( ( card C32 ) + 2 ) in ( dom D23 ) by L51 , COMPOS_1:64;
L53: D23 c= D27 by FUNCT_4:25;
L54: ( D27 . ( ( card C32 ) + 2 ) ) = ( D23 . ( ( card C32 ) + 2 ) ) by L53 , L52 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L51 , COMPOS_1:64;
L55: ( CurInstr (D27 , D26) ) = ( halt ( SCMPDS ) ) by L54 , L50 , PBOOLE:143;
L56:
now
let C35 being (Element of ( NAT ));
per cases ;
suppose L57: ( 0 ) < C35;

L58: ( 1 + ( 0 ) ) <= C35 by L57 , INT_1:7;
thus L59: ( IC ( Comput (D25 , D24 , C35) ) ) in ( dom D23 ) by L58 , L52 , L50 , L55 , EXTPRO_1:5;
end;
suppose L60: C35 = ( 0 );

L61: ( Comput (D25 , D24 , C35) ) = D24 by L60 , EXTPRO_1:2;
thus L62: ( IC ( Comput (D25 , D24 , C35) ) ) in ( dom D23 ) by L61 , L44 , COMPOS_1:36;
end;
end;
thus L64: D22 is_closed_on C31 , R4 by L56 , SCMPDS_6:def 2;
L65: D25 halts_on D24 by L55 , EXTPRO_1:29;
thus L66: thesis by L65 , SCMPDS_6:def 3;
end;
theorem
L67: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B27 being ( 0 ) -started (State of ( SCMPDS )) holds (for B28 being (Program of ( SCMPDS )) holds (for B29 , B30 being Int_position holds (for B31 being Integer holds (( B27 . ( DataLoc (( B27 . B29 ) , B31) ) ) >= ( 0 ) implies ( IExec (( while<0 (B29 , B31 , B28) ) , R4 , B27) ) = ( B27 +* ( Start-At (( ( card B28 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C36 being ( 0 ) -started (State of ( SCMPDS ));
let C37 being (Program of ( SCMPDS ));
let C38 , C39 being Int_position;
let C40 being Integer;
set D28 = ( DataLoc (( C36 . C38 ) , C40) );
set D29 = ( while<0 (C38 , C40 , C37) );
set D30 = ( stop D29 );
set D31 = ( R4 +* D30 );
set D32 = ( Comput (D31 , C36 , 1) );
set D33 = D31;
set D34 = ( (C38 , C40) >=0_goto ( ( card C37 ) + 2 ) );
set D35 = ( goto ( - ( ( card C37 ) + 1 ) ) );
set D36 = ( Start-At (( ( card C37 ) + 2 ) , ( SCMPDS )) );
L68: ( Initialize C36 ) = C36 by MEMSTR_0:44;
L69: ( IC C36 ) = ( 0 ) by MEMSTR_0:def 11;
L70: D29 = ( D34 ';' ( C37 ';' D35 ) ) by SCMPDS_4:15;
L71: ( CurInstr (D31 , C36) ) = D34 by L70 , L68 , SCMPDS_6:11;
L72: ( Comput (D31 , C36 , ( ( 0 ) + 1 )) ) = ( Following (D31 , ( Comput (D31 , C36 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D31 , C36) )
.= ( Exec (D34 , C36) ) by L70 , L68 , SCMPDS_6:11;
L73: D30 c= D33 by FUNCT_4:25;
L74: ( IExec (D29 , R4 , C36) ) = ( Result (D31 , C36) ) by SCMPDS_4:def 5;
assume L75: ( C36 . D28 ) >= ( 0 );
L76: ( IC D32 ) = ( ICplusConst (C36 , ( ( card C37 ) + 2 )) ) by L75 , L72 , SCMPDS_2:57
.= ( ( 0 ) + ( ( card C37 ) + 2 ) ) by L69 , SCMPDS_6:12;
L77: ( card D29 ) = ( ( card C37 ) + 2 ) by L30;
L78: ( ( card C37 ) + 2 ) in ( dom D30 ) by L77 , COMPOS_1:64;
L79: ( D33 . ( ( card C37 ) + 2 ) ) = ( D30 . ( ( card C37 ) + 2 ) ) by L78 , L73 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L77 , COMPOS_1:64;
L80: ( CurInstr (D33 , D32) ) = ( halt ( SCMPDS ) ) by L79 , L76 , PBOOLE:143;
L81: D31 halts_on C36 by L80 , EXTPRO_1:29;
L82:
now
let C41 being (Element of ( NAT ));
L83: ( Comput (D31 , C36 , ( 0 )) ) = C36;
assume L84: C41 < ( ( 0 ) + 1 );
L85: C41 = ( 0 ) by L84 , NAT_1:13;
thus L86: ( CurInstr (D31 , ( Comput (D31 , C36 , C41) )) ) <> ( halt ( SCMPDS ) ) by L85 , L71 , L83;
end;
L87: (for B32 being (Element of ( NAT )) holds (( CurInstr (D31 , ( Comput (D31 , C36 , B32) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B32)) by L82;
L88: ( LifeSpan (D31 , C36) ) = 1 by L87 , L80 , L81 , EXTPRO_1:def 15;
L89:
now
let C42 being set;
L90: ( dom D36 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L91: C42 in ( dom ( IExec (D29 , R4 , C36) ) );
per cases  by L91 , SCMPDS_4:6;
suppose L92: C42 is Int_position;

L93: C42 <> ( IC ( SCMPDS ) ) by L92 , SCMPDS_2:43;
L94: (not C42 in ( dom D36 )) by L93 , L90 , TARSKI:def 1;
thus L95: ( ( IExec (D29 , R4 , C36) ) . C42 ) = ( D32 . C42 ) by L88 , L74 , L81 , EXTPRO_1:23
.= ( C36 . C42 ) by L72 , L92 , SCMPDS_2:57
.= ( ( C36 +* D36 ) . C42 ) by L94 , FUNCT_4:11;
end;
suppose L96: C42 = ( IC ( SCMPDS ) );

thus L97: ( ( IExec (D29 , R4 , C36) ) . C42 ) = ( ( card C37 ) + 2 ) by L96 , L76 , L88 , L74 , L81 , EXTPRO_1:23
.= ( ( C36 +* D36 ) . C42 ) by L96 , FUNCT_4:113;
end;
end;
L99: ( dom ( IExec (D29 , R4 , C36) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C36 +* D36 ) ) by PARTFUN1:def 2;
thus L100: thesis by L99 , L89 , FUNCT_1:2;
end;
theorem
L101: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B33 being ( 0 ) -started (State of ( SCMPDS )) holds (for B34 being (Program of ( SCMPDS )) holds (for B35 being Int_position holds (for B36 being Integer holds (( B33 . ( DataLoc (( B33 . B35 ) , B36) ) ) >= ( 0 ) implies ( IC ( IExec (( while<0 (B35 , B36 , B34) ) , R4 , B33) ) ) = ( ( card B34 ) + 2 )))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C43 being ( 0 ) -started (State of ( SCMPDS ));
let C44 being (Program of ( SCMPDS ));
let C45 being Int_position;
let C46 being Integer;
assume L102: ( C43 . ( DataLoc (( C43 . C45 ) , C46) ) ) >= ( 0 );
L103: ( IExec (( while<0 (C45 , C46 , C44) ) , R4 , C43) ) = ( C43 +* ( Start-At (( ( card C44 ) + 2 ) , ( SCMPDS )) ) ) by L102 , L67;
thus L104: thesis by L103 , FUNCT_4:113;
end;
theorem
L105: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B37 being ( 0 ) -started (State of ( SCMPDS )) holds (for B38 being (Program of ( SCMPDS )) holds (for B39 , B40 being Int_position holds (for B41 being Integer holds (( B37 . ( DataLoc (( B37 . B39 ) , B41) ) ) >= ( 0 ) implies ( ( IExec (( while<0 (B39 , B41 , B38) ) , R4 , B37) ) . B40 ) = ( B37 . B40 )))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C47 being ( 0 ) -started (State of ( SCMPDS ));
let C48 being (Program of ( SCMPDS ));
let C49 , C50 being Int_position;
let C51 being Integer;
assume L106: ( C47 . ( DataLoc (( C47 . C49 ) , C51) ) ) >= ( 0 );
L107: ( IExec (( while<0 (C49 , C51 , C48) ) , R4 , C47) ) = ( C47 +* ( Start-At (( ( card C48 ) + 2 ) , ( SCMPDS )) ) ) by L106 , L67;
L108: (not C50 in ( dom ( Start-At (( ( card C48 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L109: thesis by L108 , L107 , FUNCT_4:11;
end;
L110: (for B42 being (Program of ( SCMPDS )) holds (for B43 being Int_position holds (for B44 being Integer holds ( Shift (B42 , 1) ) c= ( while<0 (B43 , B44 , B42) ))))
proof
let C52 being (Program of ( SCMPDS ));
let C53 being Int_position;
let C54 being Integer;
set D37 = ( (C53 , C54) >=0_goto ( ( card C52 ) + 2 ) );
set D38 = ( goto ( - ( ( card C52 ) + 1 ) ) );
L111: ( while<0 (C53 , C54 , C52) ) = ( ( D37 ';' C52 ) ';' ( Load D38 ) ) by SCMPDS_4:def 3
.= ( ( ( Load D37 ) ';' C52 ) ';' ( Load D38 ) ) by SCMPDS_4:def 2;
L112: ( card ( Load D37 ) ) = 1 by COMPOS_1:54;
thus L113: thesis by L112 , L111 , SCMPDS_7:3;
end;
scheme WhileLHalt { F1((State of ( SCMPDS ))) -> (Element of ( NAT )) , F2() -> ( 0 ) -started (State of ( SCMPDS )) , F3() -> (Instruction-Sequence of ( SCMPDS )) , F4() ->  halt-free  shiftable (Program of ( SCMPDS )) , F5() -> Int_position , F6() -> Integer , P1[(State of ( SCMPDS ))] } : (( while<0 (F5() , F6() , F4()) ) is_closed_on F2() , F3() & ( while<0 (F5() , F6() , F4()) ) is_halting_on F2() , F3())
provided
L114: (for B45 being ( 0 ) -started (State of ( SCMPDS )) holds ((P1[ B45 ] & F1(B45) = ( 0 )) implies ( B45 . ( DataLoc (( F2() . F5() ) , F6()) ) ) >= ( 0 )))
and
L115: P1[ F2() ]
and
L116: (for B46 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P1[ B46 ] & ( B46 . F5() ) = ( F2() . F5() ) & ( B46 . ( DataLoc (( F2() . F5() ) , F6()) ) ) < ( 0 )) implies (( ( IExec (F4() , R5 , B46) ) . F5() ) = ( B46 . F5() ) & F4() is_closed_on B46 , R5 & F4() is_halting_on B46 , R5 & F1(( Initialize ( IExec (F4() , R5 , B46) ) )) < F1(B46) & P1[ ( Initialize ( IExec (F4() , R5 , B46) ) ) ]))))
proof
set D39 = ( (F5() , F6()) >=0_goto ( ( card F4() ) + 2 ) );
set D40 = ( goto ( - ( ( card F4() ) + 1 ) ) );
set D41 = ( while<0 (F5() , F6() , F4()) );
set D42 = ( stop D41 );
set D43 = ( stop F4() );
set D44 = ( DataLoc (( F2() . F5() ) , F6()) );
defpred S2[ (Element of ( NAT )) ] means (for B47 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((F1(B47) <= $1 & P1[ B47 ] & ( B47 . F5() ) = ( F2() . F5() )) implies (D41 is_closed_on B47 , R5 & D41 is_halting_on B47 , R5))));
L117: (for B48 being (Element of ( NAT )) holds (S2[ B48 ] implies S2[ ( B48 + 1 ) ]))
proof
let C55 being (Element of ( NAT ));
assume L118: S2[ C55 ];
let C56 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
L119: ( Initialize C56 ) = C56 by MEMSTR_0:44;
assume L120: F1(C56) <= ( C55 + 1 );
assume L121: P1[ C56 ];
assume L122: ( C56 . F5() ) = ( F2() . F5() );
per cases ;
suppose L123: ( C56 . D44 ) >= ( 0 );

thus L124: (D41 is_closed_on C56 , R5 & D41 is_halting_on C56 , R5) by L123 , L122 , L42;
end;
suppose L125: ( C56 . D44 ) < ( 0 );

L126: ( 0 ) in ( dom D42 ) by COMPOS_1:36;
L127: D41 = ( D39 ';' ( F4() ';' D40 ) ) by SCMPDS_4:15;
set D45 = ( R5 +* D43 );
set D46 = ( R5 +* D42 );
set D47 = ( Comput (D46 , C56 , 1) );
set D48 = D46;
L128: D43 c= D45 by FUNCT_4:25;
set D49 = ( LifeSpan (D45 , C56) );
set D50 = ( Comput (D48 , D47 , D49) );
set D51 = D48;
set D52 = ( ( card F4() ) + 1 );
L129: ( IC C56 ) = ( 0 ) by MEMSTR_0:def 11;
set D53 = ( D49 + 1 );
set D54 = ( Comput (D46 , C56 , D53) );
set D55 = D46;
set D56 = ( Comput (D46 , C56 , ( D53 + 1 )) );
set D57 = D46;
L130: ( ( card F4() ) + 1 ) < ( ( card F4() ) + 2 ) by XREAL_1:6;
L131: D52 in ( dom D41 ) by L130 , L34;
L132: D42 c= D46 by FUNCT_4:25;
L133: D41 c= D42 by AFINSQ_1:74;
L134: D41 c= D46 by L133 , L132 , XBOOLE_1:1;
L135: ( Shift (F4() , 1) ) c= D41 by L110;
L136: ( Shift (F4() , 1) ) c= D48 by L135 , L134 , XBOOLE_1:1;
L137: ( Comput (D46 , C56 , ( ( 0 ) + 1 )) ) = ( Following (D46 , ( Comput (D46 , C56 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D46 , C56) )
.= ( Exec (D39 , C56) ) by L127 , L119 , SCMPDS_6:11;
L138: (for R2 being Int_position holds ( C56 . R2 ) = ( D47 . R2 )) by L137 , SCMPDS_2:57;
L139: ( DataPart C56 ) = ( DataPart D47 ) by L138 , SCMPDS_4:8;
L140: F4() is_halting_on C56 , R5 by L116 , L121 , L122 , L125;
L141: D45 halts_on C56 by L140 , L119 , SCMPDS_6:def 3;
L142: ( D45 +* D43 ) halts_on C56 by L141;
L143: F4() is_halting_on C56 , D45 by L142 , L119 , SCMPDS_6:def 3;
L144: ( IExec (F4() , R5 , C56) ) = ( Result (D45 , C56) ) by SCMPDS_4:def 5;
L145: P1[ ( Initialize ( IExec (F4() , R5 , C56) ) ) ] by L116 , L121 , L122 , L125;
L146: F4() is_closed_on C56 , R5 by L116 , L121 , L122 , L125;
L147: F4() is_closed_on C56 , D45 by L116 , L121 , L122 , L125;
L148: ( IC D47 ) = ( succ ( IC C56 ) ) by L125 , L137 , L122 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L129;
L149: ( IC D50 ) = D52 by L148 , L128 , L143 , L147 , L139 , L136 , SCMPDS_7:18;
L150: ( D55 /. ( IC D54 ) ) = ( D55 . ( IC D54 ) ) by PBOOLE:143;
L151: D54 = D50 by EXTPRO_1:4;
L152: ( CurInstr (D55 , D54) ) = ( D48 . D52 ) by L151 , L128 , L143 , L147 , L148 , L139 , L136 , L150 , SCMPDS_7:18
.= ( D41 . D52 ) by L131 , L134 , GRFUNC_1:2
.= D40 by L37;
L153: D56 = ( Following (D46 , D54) ) by EXTPRO_1:3
.= ( Exec (D40 , D54) ) by L152;
L154: ( IC D56 ) = ( ICplusConst (D54 , ( ( 0 ) - ( ( card F4() ) + 1 ) )) ) by L153 , SCMPDS_2:54
.= ( 0 ) by L149 , L151 , SCMPDS_7:1;
L155: ( Initialize D56 ) = D56 by L154 , MEMSTR_0:46;
L156: ( DataPart ( Comput (D45 , C56 , D49) ) ) = ( DataPart D50 ) by L128 , L143 , L147 , L148 , L139 , L136 , SCMPDS_7:18;
L157: ( DataPart D50 ) = ( DataPart ( Result (D45 , C56) ) ) by L156 , L141 , EXTPRO_1:23
.= ( DataPart ( IExec (F4() , R5 , C56) ) ) by SCMPDS_4:def 5;
L158: ( InsCode D40 ) = 14 by SCMPDS_2:12;
L159: ( InsCode D40 ) in { ( 0 ) , 4 , 5 , 6 , 14 } by L158 , ENUMSET1:def 3;
L160: ( Initialize D56 ) = ( Initialize D54 ) by L159 , L153 , L7
.= ( Initialize ( IExec (F4() , R5 , C56) ) ) by L157 , L151 , MEMSTR_0:80;
L161:
now
L162: F1(( Initialize ( IExec (F4() , R5 , C56) ) )) < F1(C56) by L116 , L121 , L122 , L125;
L163: F1(( Initialize D56 )) < ( C55 + 1 ) by L162 , L120 , L160 , XXREAL_0:2;
assume L164: F1(( Initialize D56 )) > C55;
thus L165: contradiction by L164 , L163 , INT_1:7;
end;
L166: ( D50 . F5() ) = ( ( Comput (D45 , C56 , D49) ) . F5() ) by L156 , SCMPDS_4:8
.= ( ( Result (D45 , C56) ) . F5() ) by L141 , EXTPRO_1:23
.= ( F2() . F5() ) by L122 , L116 , L121 , L125 , L144;
L167: ( D56 . F5() ) = ( D54 . F5() ) by L153 , SCMPDS_2:54
.= ( F2() . F5() ) by L166 , EXTPRO_1:4;
L168: D41 is_closed_on D56 , D57 by L167 , L118 , L145 , L160 , L161 , L155;
L169:
now
let C57 being (Element of ( NAT ));
per cases ;
suppose L170: C57 < ( D53 + 1 );

L171: C57 <= D53 by L170 , INT_1:7;
thus L172:now
per cases  by L171 , NAT_1:8;
suppose L173: C57 <= D49;

thus L174:now
per cases ;
suppose L175: C57 = ( 0 );

thus L176: ( IC ( Comput (D46 , C56 , C57) ) ) in ( dom D42 ) by L175 , L126 , L129 , EXTPRO_1:2;
end;
suppose L177: C57 <> ( 0 );

consider C58 being Nat such that L178: C57 = ( C58 + 1 ) by L177 , NAT_1:6;
reconsider D58 = C58 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D59 = ( IC ( Comput (D45 , C56 , D58) ) ) as (Element of ( NAT ));
L179: D58 < C57 by L178 , XREAL_1:29;
L180: D58 < D49 by L179 , L173 , XXREAL_0:2;
L181: ( ( IC ( Comput (D45 , C56 , D58) ) ) + 1 ) = ( IC ( Comput (D48 , D47 , D58) ) ) by L180 , L128 , L143 , L147 , L148 , L139 , L136 , SCMPDS_7:16;
L182: ( IC ( Comput (D46 , C56 , C57) ) ) = ( D59 + 1 ) by L181 , L178 , EXTPRO_1:4;
L183: ( IC ( Comput (D45 , C56 , D58) ) ) in ( dom D43 ) by L146 , L119 , SCMPDS_6:def 2;
L184: D59 < ( card D43 ) by L183 , AFINSQ_1:66;
L185: D59 < ( ( card F4() ) + 1 ) by L184 , COMPOS_1:55;
L186: ( D59 + 1 ) <= ( ( card F4() ) + 1 ) by L185 , INT_1:7;
L187: ( ( card F4() ) + 1 ) < ( ( card F4() ) + 3 ) by XREAL_1:6;
L188: ( D59 + 1 ) < ( ( card F4() ) + 3 ) by L187 , L186 , XXREAL_0:2;
L189: ( D59 + 1 ) < ( card D42 ) by L188 , L32;
thus L190: ( IC ( Comput (D46 , C56 , C57) ) ) in ( dom D42 ) by L189 , L182 , AFINSQ_1:66;
end;
end;
end;
suppose L175: C57 = D53;

L176: D52 in ( dom D42 ) by L131 , COMPOS_1:62;
thus L177: ( IC ( Comput (D46 , C56 , C57) ) ) in ( dom D42 ) by L176 , L128 , L143 , L147 , L148 , L139 , L136 , L151 , L175 , SCMPDS_7:18;
end;
end;
end;
suppose L173: C57 >= ( D53 + 1 );

consider C59 being Nat such that L174: C57 = ( ( D53 + 1 ) + C59 ) by L173 , NAT_1:10;
reconsider D60 = C59 as (Element of ( NAT )) by ORDINAL1:def 12;
L175: ( Comput (D46 , C56 , C57) ) = ( Comput (( D57 +* D42 ) , D56 , D60) ) by L174 , EXTPRO_1:4;
thus L176: ( IC ( Comput (D46 , C56 , C57) ) ) in ( dom D42 ) by L175 , L168 , L155 , SCMPDS_6:def 2;
end;
end;
thus L178: D41 is_closed_on C56 , R5 by L169 , L119 , SCMPDS_6:def 2;
L179: D46 = ( D57 +* D42 );
L180: D41 is_halting_on D56 , D57 by L118 , L145 , L167 , L160 , L161 , L155;
L181: D46 halts_on D56 by L180 , L155 , L179 , SCMPDS_6:def 3;
L182: D46 halts_on C56 by L181 , EXTPRO_1:22;
thus L183: D41 is_halting_on C56 , R5 by L182 , L119 , SCMPDS_6:def 3;
end;
end;
set D61 = F1(F2());
L185: S2[ (( 0 ) qua (Element of ( NAT ))) ]
proof
let C60 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume that
L186: F1(C60) <= ( 0 )
and
L187: P1[ C60 ]
and
L188: ( C60 . F5() ) = ( F2() . F5() );
L189: F1(C60) = ( 0 ) by L186;
L190: ( C60 . D44 ) >= ( 0 ) by L189 , L114 , L187;
thus L191: thesis by L190 , L188 , L42;
end;
L192: (for B49 being (Element of ( NAT )) holds S2[ B49 ]) from NAT_1:sch 1(L185 , L117);
L193: S2[ D61 ] by L192;
thus L194: thesis by L193 , L115;
end;
scheme WhileLExec { F7((State of ( SCMPDS ))) -> (Element of ( NAT )) , F8() -> ( 0 ) -started (State of ( SCMPDS )) , F9() -> (Instruction-Sequence of ( SCMPDS )) , F10() ->  halt-free  shiftable (Program of ( SCMPDS )) , F11() -> Int_position , F12() -> Integer , P2[(State of ( SCMPDS ))] } : ( IExec (( while<0 (F11() , F12() , F10()) ) , F9() , F8()) ) = ( IExec (( while<0 (F11() , F12() , F10()) ) , F9() , ( Initialize ( IExec (F10() , F9() , F8()) ) )) )
provided
L195: ( F8() . ( DataLoc (( F8() . F11() ) , F12()) ) ) < ( 0 )
and
L196: (for B50 being ( 0 ) -started (State of ( SCMPDS )) holds ((P2[ B50 ] & F7(B50) = ( 0 )) implies ( B50 . ( DataLoc (( F8() . F11() ) , F12()) ) ) >= ( 0 )))
and
L197: P2[ F8() ]
and
L198: (for B51 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P2[ B51 ] & ( B51 . F11() ) = ( F8() . F11() ) & ( B51 . ( DataLoc (( F8() . F11() ) , F12()) ) ) < ( 0 )) implies (( ( IExec (F10() , R5 , B51) ) . F11() ) = ( B51 . F11() ) & F10() is_closed_on B51 , R5 & F10() is_halting_on B51 , R5 & F7(( Initialize ( IExec (F10() , R5 , B51) ) )) < F7(B51) & P2[ ( Initialize ( IExec (F10() , R5 , B51) ) ) ]))))
proof
L199: ( Initialize F8() ) = F8() by MEMSTR_0:44;
set D62 = ( while<0 (F11() , F12() , F10()) );
set D63 = ( stop D62 );
set D64 = ( F9() +* D63 );
set D65 = ( F9() +* ( stop F10() ) );
set D66 = ( ( LifeSpan (D65 , F8()) ) + 2 );
set D67 = ( Initialize ( IExec (F10() , F9() , F8()) ) );
set D68 = ( F9() +* D63 );
set D69 = ( LifeSpan (D68 , D67) );
L200: P2[ F8() ] by L197;
L201: ( stop F10() ) c= D65 by FUNCT_4:25;
L202: F10() is_closed_on F8() , D65 by L195 , L197 , L198;
L203: F10() is_halting_on F8() , F9() by L195 , L197 , L198;
L204: D65 halts_on F8() by L203 , L199 , SCMPDS_6:def 3;
L205: ( D65 +* ( stop F10() ) ) halts_on F8() by L204;
L206: F10() is_halting_on F8() , D65 by L205 , L199 , SCMPDS_6:def 3;
set D70 = ( IExec (F10() , F9() , F8()) );
set D71 = ( DataLoc (( ( Initialize D70 ) . F11() ) , F12()) );
set D72 = F9();
L207: (for B52 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P2[ B52 ] & ( B52 . F11() ) = ( F8() . F11() ) & ( B52 . ( DataLoc (( F8() . F11() ) , F12()) ) ) < ( 0 )) implies (( ( IExec (F10() , R5 , B52) ) . F11() ) = ( B52 . F11() ) & F10() is_closed_on B52 , R5 & F10() is_halting_on B52 , R5 & F7(( Initialize ( IExec (F10() , R5 , B52) ) )) < F7(B52) & P2[ ( Initialize ( IExec (F10() , R5 , B52) ) ) ])))) by L198;
L208: (for B53 being ( 0 ) -started (State of ( SCMPDS )) holds ((P2[ B53 ] & F7(B53) = ( 0 )) implies ( B53 . ( DataLoc (( F8() . F11() ) , F12()) ) ) >= ( 0 ))) by L196;
L209: (D62 is_closed_on F8() , F9() & D62 is_halting_on F8() , F9()) from WhileLHalt(L208 , L200 , L207);
L210: D64 halts_on F8() by L209 , L199 , SCMPDS_6:def 3;
L211: ( ( IExec (F10() , F9() , F8()) ) . F11() ) = ( ( Initialize ( IExec (F10() , F9() , F8()) ) ) . F11() ) by SCMPDS_5:15;
L212: ( ( IExec (F10() , F9() , F8()) ) . F11() ) = ( F8() . F11() ) by L195 , L197 , L198;
L213: (for B54 being ( 0 ) -started (State of ( SCMPDS )) holds ((P2[ B54 ] & F7(B54) = ( 0 )) implies ( B54 . D71 ) >= ( 0 ))) by L212 , L196 , L211;
L214: (for B55 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P2[ B55 ] & ( B55 . F11() ) = ( ( Initialize D70 ) . F11() ) & ( B55 . D71 ) < ( 0 )) implies (( ( IExec (F10() , R5 , B55) ) . F11() ) = ( B55 . F11() ) & F10() is_closed_on B55 , R5 & F10() is_halting_on B55 , R5 & F7(( Initialize ( IExec (F10() , R5 , B55) ) )) < F7(B55) & P2[ ( Initialize ( IExec (F10() , R5 , B55) ) ) ])))) by L198 , L212 , L211;
L215: P2[ ( Initialize D70 ) ] by L195 , L197 , L198;
L216: (D62 is_closed_on ( Initialize D70 ) , D72 & D62 is_halting_on ( Initialize D70 ) , D72) from WhileLHalt(L213 , L215 , L214);
L217: D68 halts_on ( Initialize D67 ) by L216 , SCMPDS_6:def 3;
set D73 = ( Comput (D64 , F8() , 1) );
set D74 = D64;
set D75 = ( (F11() , F12()) >=0_goto ( ( card F10() ) + 2 ) );
set D76 = ( goto ( - ( ( card F10() ) + 1 ) ) );
set D77 = ( DataLoc (( F8() . F11() ) , F12()) );
L218: D62 = ( D75 ';' ( F10() ';' D76 ) ) by SCMPDS_4:15;
set D78 = ( LifeSpan (D65 , F8()) );
set D79 = ( Comput (D74 , D73 , D78) );
set D80 = D74;
set D81 = ( ( card F10() ) + 1 );
L219: ( IC F8() ) = ( 0 ) by MEMSTR_0:def 11;
L220: ( Comput (D64 , F8() , ( ( 0 ) + 1 )) ) = ( Following (D64 , ( Comput (D64 , F8() , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D64 , F8()) )
.= ( Exec (D75 , F8()) ) by L218 , L199 , SCMPDS_6:11;
L221: (for R2 being Int_position holds ( F8() . R2 ) = ( D73 . R2 )) by L220 , SCMPDS_2:57;
L222: ( DataPart F8() ) = ( DataPart D73 ) by L221 , SCMPDS_4:8;
set D82 = ( D78 + 1 );
set D83 = ( Comput (D64 , F8() , D82) );
set D84 = D64;
L223: ( ( card F10() ) + 1 ) < ( ( card F10() ) + 2 ) by XREAL_1:6;
L224: D81 in ( dom D62 ) by L223 , L34;
set D85 = ( LifeSpan (D64 , F8()) );
set D86 = ( Comput (D64 , F8() , ( D82 + 1 )) );
L225: D62 c= D63 by AFINSQ_1:74;
L226: D63 c= D64 by FUNCT_4:25;
L227: D62 c= D64 by L226 , L225 , XBOOLE_1:1;
L228: ( Shift (F10() , 1) ) c= D62 by L110;
L229: ( Shift (F10() , 1) ) c= D74 by L228 , L227 , XBOOLE_1:1;
L230: ( IC D73 ) = ( succ ( IC F8() ) ) by L195 , L220 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L219;
L231: ( IC D79 ) = D81 by L230 , L201 , L206 , L202 , L222 , L229 , SCMPDS_7:18;
L232: ( D84 /. ( IC D83 ) ) = ( D84 . ( IC D83 ) ) by PBOOLE:143;
L233: D83 = D79 by EXTPRO_1:4;
L234: ( CurInstr (D84 , D83) ) = ( D74 . D81 ) by L233 , L201 , L206 , L202 , L230 , L222 , L229 , L232 , SCMPDS_7:18
.= ( D62 . D81 ) by L224 , L227 , GRFUNC_1:2
.= D76 by L37;
L235: D86 = ( Following (D64 , D83) ) by EXTPRO_1:3
.= ( Exec (D76 , D83) ) by L234;
L236: ( IC D86 ) = ( ICplusConst (D83 , ( ( 0 ) - ( ( card F10() ) + 1 ) )) ) by L235 , SCMPDS_2:54
.= ( 0 ) by L231 , L233 , SCMPDS_7:1;
L237: ( IC D67 ) = ( IC ( Comput (D64 , F8() , D66) ) ) by L236 , MEMSTR_0:def 11;
L238: ( DataPart ( Comput (D65 , F8() , D78) ) ) = ( DataPart D79 ) by L201 , L206 , L202 , L230 , L222 , L229 , SCMPDS_7:18;
L239:
now
let C61 being Int_position;
L240: (not C61 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L241: ( D79 . C61 ) = ( ( Comput (D65 , F8() , D78) ) . C61 ) by L238 , SCMPDS_4:8
.= ( ( Result (D65 , F8()) ) . C61 ) by L204 , EXTPRO_1:23
.= ( ( IExec (F10() , F9() , F8()) ) . C61 ) by SCMPDS_4:def 5;
thus L242: ( D86 . C61 ) = ( ( IExec (F10() , F9() , F8()) ) . C61 ) by L241 , L233 , L235 , SCMPDS_2:54
.= ( D67 . C61 ) by L240 , FUNCT_4:11;
end;
L243: ( DataPart D86 ) = ( DataPart D67 ) by L239 , SCMPDS_4:8;
L244: ( Comput (D64 , F8() , D66) ) = D67 by L243 , L237 , MEMSTR_0:78;
L245: ( CurInstr (D64 , ( Comput (D64 , F8() , D66) )) ) = D75 by L244 , L218 , SCMPDS_6:11;
L246: D85 > D66 by L245 , L210 , EXTPRO_1:36 , SCMPDS_6:18;
consider C62 being Nat such that L247: D85 = ( D66 + C62 ) by L246 , NAT_1:10;
reconsider D87 = C62 as (Element of ( NAT )) by ORDINAL1:def 12;
L248: ( Comput (D64 , F8() , ( D66 + D69 )) ) = ( Comput (D64 , D67 , D69) ) by L244 , EXTPRO_1:4;
L249: ( CurInstr (D64 , ( Comput (D64 , F8() , ( D66 + D69 )) )) ) = ( halt ( SCMPDS ) ) by L248 , L217 , EXTPRO_1:def 15;
L250: ( D66 + D69 ) >= D85 by L249 , L210 , EXTPRO_1:def 15;
L251: D69 >= D87 by L250 , L247 , XREAL_1:6;
L252: ( Comput (D64 , F8() , D85) ) = ( Comput (D64 , D67 , D87) ) by L244 , L247 , EXTPRO_1:4;
L253: ( CurInstr (D68 , ( Comput (D68 , D67 , D87) )) ) = ( halt ( SCMPDS ) ) by L252 , L210 , EXTPRO_1:def 15;
L254: D87 >= D69 by L253 , L217 , EXTPRO_1:def 15;
L255: D87 = D69 by L254 , L251 , XXREAL_0:1;
L256: ( Result (D64 , F8()) ) = ( Comput (D68 , D67 , D69) ) by L255 , L210 , L252 , EXTPRO_1:23;
thus L257: ( IExec (D62 , F9() , F8()) ) = ( Comput (D68 , D67 , D69) ) by L256 , SCMPDS_4:def 5
.= ( Result (D68 , D67) ) by L217 , EXTPRO_1:23
.= ( IExec (D62 , F9() , ( Initialize ( IExec (F10() , F9() , F8()) ) )) ) by SCMPDS_4:def 5;
end;
theorem
L258: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B56 being ( 0 ) -started (State of ( SCMPDS )) holds (for B57 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B58 being Int_position holds (for B59 being Integer holds (for B60 being set holds (for B61 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) holds (((for B62 being ( 0 ) -started (State of ( SCMPDS )) holds (( B61 . B62 ) = ( 0 ) implies ( B62 . ( DataLoc (( B56 . B58 ) , B59) ) ) >= ( 0 ))) & (for B63 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for B64 being Int_position holds (B64 in B60 implies ( B63 . B64 ) = ( B56 . B64 ))) & ( B63 . B58 ) = ( B56 . B58 ) & ( B63 . ( DataLoc (( B56 . B58 ) , B59) ) ) < ( 0 )) implies (( ( IExec (B57 , R5 , B63) ) . B58 ) = ( B63 . B58 ) & ( B61 . ( Initialize ( IExec (B57 , R5 , B63) ) ) ) < ( B61 . B63 ) & B57 is_closed_on B63 , R5 & B57 is_halting_on B63 , R5 & (for B65 being Int_position holds (B65 in B60 implies ( ( IExec (B57 , R5 , B63) ) . B65 ) = ( B63 . B65 )))))))) implies (( while<0 (B58 , B59 , B57) ) is_closed_on B56 , R4 & ( while<0 (B58 , B59 , B57) ) is_halting_on B56 , R4)))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C63 being ( 0 ) -started (State of ( SCMPDS ));
let C64 being  halt-free  shiftable (Program of ( SCMPDS ));
let C65 being Int_position;
let C66 being Integer;
let C67 being set;
let C68 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT ));
set D88 = ( DataLoc (( C63 . C65 ) , C66) );
set D89 = ( while<0 (C65 , C66 , C64) );
set D90 = ( stop D89 );
set D91 = ( stop C64 );
set D92 = ( (C65 , C66) >=0_goto ( ( card C64 ) + 2 ) );
set D93 = ( goto ( - ( ( card C64 ) + 1 ) ) );
defpred S3[ (Element of ( NAT )) ] means (for B66 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((( C68 . B66 ) <= $1 & (for B67 being Int_position holds (B67 in C67 implies ( B66 . B67 ) = ( C63 . B67 ))) & ( B66 . C65 ) = ( C63 . C65 )) implies (D89 is_closed_on B66 , R5 & D89 is_halting_on B66 , R5))));
assume L259: (for B68 being ( 0 ) -started (State of ( SCMPDS )) holds (( C68 . B68 ) = ( 0 ) implies ( B68 . D88 ) >= ( 0 )));
assume L260: (for B69 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C67 implies ( B69 . R1 ) = ( C63 . R1 ))) & ( B69 . C65 ) = ( C63 . C65 ) & ( B69 . D88 ) < ( 0 )) implies (( ( IExec (C64 , R5 , B69) ) . C65 ) = ( B69 . C65 ) & ( C68 . ( Initialize ( IExec (C64 , R5 , B69) ) ) ) < ( C68 . B69 ) & C64 is_closed_on B69 , R5 & C64 is_halting_on B69 , R5 & (for R1 being Int_position holds (R1 in C67 implies ( ( IExec (C64 , R5 , B69) ) . R1 ) = ( B69 . R1 )))))));
L261: (for B70 being (Element of ( NAT )) holds (S3[ B70 ] implies S3[ ( B70 + 1 ) ]))
proof
let C69 being (Element of ( NAT ));
assume L262: S3[ C69 ];
L263:
now
let C70 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
L264: ( Initialize C70 ) = C70 by MEMSTR_0:44;
assume L265: ( C68 . C70 ) <= ( C69 + 1 );
assume L266: (for R1 being Int_position holds (R1 in C67 implies ( C70 . R1 ) = ( C63 . R1 )));
assume L267: ( C70 . C65 ) = ( C63 . C65 );
per cases ;
suppose L268: ( C70 . D88 ) >= ( 0 );

thus L269: (D89 is_closed_on C70 , R5 & D89 is_halting_on C70 , R5) by L268 , L267 , L42;
end;
suppose L270: ( C70 . D88 ) < ( 0 );

L271: ( 0 ) in ( dom D90 ) by COMPOS_1:36;
L272: D89 = ( D92 ';' ( C64 ';' D93 ) ) by SCMPDS_4:15;
L273: ( C68 . ( Initialize ( IExec (C64 , R5 , C70) ) ) ) < ( C68 . C70 ) by L260 , L266 , L267 , L270;
set D94 = C70;
set D95 = ( R5 +* D91 );
set D96 = C70;
set D97 = ( R5 +* D90 );
set D98 = ( Comput (D97 , D96 , 1) );
set D99 = D97;
L274: D91 c= D95 by FUNCT_4:25;
L275: ( Comput (D97 , D96 , ( ( 0 ) + 1 )) ) = ( Following (D97 , ( Comput (D97 , D96 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D97 , D96) )
.= ( Exec (D92 , D96) ) by L272 , L264 , SCMPDS_6:11;
L276: (for R2 being Int_position holds ( D94 . R2 ) = ( D98 . R2 )) by L275 , SCMPDS_2:57;
L277: ( DataPart D94 ) = ( DataPart D98 ) by L276 , SCMPDS_4:8;
L278: D89 c= D90 by AFINSQ_1:74;
L279: D90 c= D97 by FUNCT_4:25;
L280: D89 c= D97 by L279 , L278 , XBOOLE_1:1;
L281: ( Shift (C64 , 1) ) c= D89 by L110;
L282: ( Shift (C64 , 1) ) c= D99 by L281 , L280 , XBOOLE_1:1;
set D100 = ( LifeSpan (D95 , D94) );
set D101 = ( Comput (D99 , D98 , D100) );
set D102 = D99;
set D103 = ( ( card C64 ) + 1 );
L283: ( IC D96 ) = ( 0 ) by MEMSTR_0:def 11;
set D104 = ( D100 + 1 );
set D105 = ( Comput (D97 , D96 , D104) );
set D106 = D97;
set D107 = ( Comput (D97 , D96 , ( D104 + 1 )) );
set D108 = D97;
L284: ( ( card C64 ) + 1 ) < ( ( card C64 ) + 2 ) by XREAL_1:6;
L285: D103 in ( dom D89 ) by L284 , L34;
L286: C64 is_closed_on C70 , R5 by L260 , L266 , L267 , L270;
L287: C64 is_closed_on D94 , D95 by L260 , L266 , L267 , L270;
L288: C64 is_halting_on C70 , R5 by L260 , L266 , L267 , L270;
L289: D95 halts_on D94 by L288 , L264 , SCMPDS_6:def 3;
L290: ( D95 +* D91 ) halts_on D94 by L289;
L291: C64 is_halting_on D94 , D95 by L290 , L264 , SCMPDS_6:def 3;
L292: ( IC D98 ) = ( succ ( IC D96 ) ) by L270 , L275 , L267 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L283;
L293: ( IC D101 ) = D103 by L292 , L274 , L291 , L287 , L277 , L282 , SCMPDS_7:18;
L294: ( D106 /. ( IC D105 ) ) = ( D106 . ( IC D105 ) ) by PBOOLE:143;
L295: D105 = D101 by EXTPRO_1:4;
L296: ( CurInstr (D106 , D105) ) = ( D99 . D103 ) by L295 , L274 , L291 , L287 , L292 , L277 , L282 , L294 , SCMPDS_7:18
.= ( D89 . D103 ) by L285 , L280 , GRFUNC_1:2
.= D93 by L37;
L297: ( DataPart ( Comput (D95 , D94 , D100) ) ) = ( DataPart D101 ) by L274 , L291 , L287 , L292 , L277 , L282 , SCMPDS_7:18;
L298: ( DataPart D101 ) = ( DataPart ( Result (D95 , D94) ) ) by L297 , L289 , EXTPRO_1:23
.= ( DataPart ( IExec (C64 , R5 , C70) ) ) by SCMPDS_4:def 5;
L299: D107 = ( Following (D97 , D105) ) by EXTPRO_1:3
.= ( Exec (D93 , D105) ) by L296;
L300: ( IC D107 ) = ( ICplusConst (D105 , ( ( 0 ) - ( ( card C64 ) + 1 ) )) ) by L299 , SCMPDS_2:54
.= ( 0 ) by L293 , L295 , SCMPDS_7:1;
L301: ( Initialize D107 ) = D107 by L300 , MEMSTR_0:46;
L302: ( IExec (C64 , R5 , C70) ) = ( Result (D95 , D94) ) by SCMPDS_4:def 5;
L303:
now
let C71 being Int_position;
assume L304: C71 in C67;
L305: ( D101 . C71 ) = ( ( Comput (D95 , D94 , D100) ) . C71 ) by L297 , SCMPDS_4:8
.= ( ( Result (D95 , D94) ) . C71 ) by L289 , EXTPRO_1:23
.= ( ( IExec (C64 , R5 , C70) ) . C71 ) by SCMPDS_4:def 5
.= ( C70 . C71 ) by L260 , L266 , L267 , L270 , L304
.= ( C63 . C71 ) by L266 , L304;
thus L306: ( D107 . C71 ) = ( C63 . C71 ) by L305 , L295 , L299 , SCMPDS_2:54;
end;
L307: ( InsCode D93 ) = 14 by SCMPDS_2:12;
L308: ( InsCode D93 ) in { ( 0 ) , 4 , 5 , 6 , 14 } by L307 , ENUMSET1:def 3;
L309: ( Initialize D107 ) = ( Initialize D105 ) by L308 , L299 , L7
.= ( Initialize ( IExec (C64 , R5 , C70) ) ) by L298 , L295 , MEMSTR_0:80;
L310:
now
assume L311: ( C68 . D107 ) > C69;
L312: ( C68 . D107 ) < ( C69 + 1 ) by L265 , L273 , L309 , L301 , XXREAL_0:2;
thus L313: contradiction by L312 , L311 , INT_1:7;
end;
L314: ( D101 . C65 ) = ( ( Comput (D95 , D94 , D100) ) . C65 ) by L297 , SCMPDS_4:8
.= ( ( Result (D95 , D94) ) . C65 ) by L289 , EXTPRO_1:23
.= ( C63 . C65 ) by L267 , L260 , L266 , L270 , L302;
L315: ( D107 . C65 ) = ( D105 . C65 ) by L299 , SCMPDS_2:54
.= ( C63 . C65 ) by L314 , EXTPRO_1:4;
L316: D89 is_closed_on D107 , D108 by L315 , L262 , L303 , L310 , L301;
L317:
now
let C72 being (Element of ( NAT ));
per cases ;
suppose L318: C72 < ( D104 + 1 );

L319: C72 <= D104 by L318 , INT_1:7;
thus L320:now
per cases  by L319 , NAT_1:8;
suppose L321: C72 <= D100;

thus L322:now
per cases ;
suppose L323: C72 = ( 0 );

thus L324: ( IC ( Comput (D97 , D96 , C72) ) ) in ( dom D90 ) by L323 , L271 , L283 , EXTPRO_1:2;
end;
suppose L325: C72 <> ( 0 );

consider C73 being Nat such that L326: C72 = ( C73 + 1 ) by L325 , NAT_1:6;
reconsider D109 = C73 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D110 = ( IC ( Comput (D95 , D94 , D109) ) ) as (Element of ( NAT ));
L327: D109 < C72 by L326 , XREAL_1:29;
L328: D109 < D100 by L327 , L321 , XXREAL_0:2;
L329: ( ( IC ( Comput (D95 , D94 , D109) ) ) + 1 ) = ( IC ( Comput (D99 , D98 , D109) ) ) by L328 , L274 , L291 , L287 , L292 , L277 , L282 , SCMPDS_7:16;
L330: ( IC ( Comput (D97 , D96 , C72) ) ) = ( D110 + 1 ) by L329 , L326 , EXTPRO_1:4;
L331: ( IC ( Comput (D95 , D94 , D109) ) ) in ( dom D91 ) by L286 , L264 , SCMPDS_6:def 2;
L332: D110 < ( card D91 ) by L331 , AFINSQ_1:66;
L333: D110 < ( ( card C64 ) + 1 ) by L332 , COMPOS_1:55;
L334: ( D110 + 1 ) <= ( ( card C64 ) + 1 ) by L333 , INT_1:7;
L335: ( ( card C64 ) + 1 ) < ( ( card C64 ) + 3 ) by XREAL_1:6;
L336: ( D110 + 1 ) < ( ( card C64 ) + 3 ) by L335 , L334 , XXREAL_0:2;
L337: ( D110 + 1 ) < ( card D90 ) by L336 , L32;
thus L338: ( IC ( Comput (D97 , D96 , C72) ) ) in ( dom D90 ) by L337 , L330 , AFINSQ_1:66;
end;
end;
end;
suppose L323: C72 = D104;

L324: D103 in ( dom D90 ) by L285 , COMPOS_1:62;
thus L325: ( IC ( Comput (D97 , D96 , C72) ) ) in ( dom D90 ) by L324 , L274 , L291 , L287 , L292 , L277 , L282 , L295 , L323 , SCMPDS_7:18;
end;
end;
end;
suppose L321: C72 >= ( D104 + 1 );

consider C74 being Nat such that L322: C72 = ( ( D104 + 1 ) + C74 ) by L321 , NAT_1:10;
reconsider D111 = C74 as (Element of ( NAT )) by ORDINAL1:def 12;
L323: ( Comput (D97 , D96 , C72) ) = ( Comput (( D108 +* D90 ) , D107 , D111) ) by L322 , EXTPRO_1:4;
thus L324: ( IC ( Comput (D97 , D96 , C72) ) ) in ( dom D90 ) by L323 , L316 , L301 , SCMPDS_6:def 2;
end;
end;
thus L326: D89 is_closed_on C70 , R5 by L317 , L264 , SCMPDS_6:def 2;
L327: D108 = ( D108 +* D90 );
L328: D89 is_halting_on D107 , D108 by L262 , L315 , L303 , L310 , L301;
L329: D97 halts_on D107 by L328 , L301 , L327 , SCMPDS_6:def 3;
L330: D97 halts_on D96 by L329 , EXTPRO_1:22;
thus L331: D89 is_halting_on C70 , R5 by L330 , L264 , SCMPDS_6:def 3;
end;
end;
thus L333: thesis by L263;
end;
set D112 = ( C68 . C63 );
L334: S3[ ( 0 ) ]
proof
let C75 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume L335: ( C68 . C75 ) <= ( 0 );
L336: ( C68 . C75 ) = ( 0 ) by L335;
L337: ( C75 . D88 ) >= ( 0 ) by L336 , L259;
assume L338: (for R1 being Int_position holds (R1 in C67 implies ( C75 . R1 ) = ( C63 . R1 )));
assume L339: ( C75 . C65 ) = ( C63 . C65 );
thus L340: thesis by L339 , L337 , L42;
end;
L341: (for B71 being (Element of ( NAT )) holds S3[ B71 ]) from NAT_1:sch 1(L334 , L261);
L342: S3[ D112 ] by L341;
L343: (for B72 being Int_position holds (B72 in C67 implies ( C63 . B72 ) = ( C63 . B72 )));
thus L344: thesis by L343 , L342;
end;
theorem
L345: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B73 being ( 0 ) -started (State of ( SCMPDS )) holds (for B74 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B75 being Int_position holds (for B76 being Integer holds (for B77 being set holds (for B78 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) holds ((( B73 . ( DataLoc (( B73 . B75 ) , B76) ) ) < ( 0 ) & (for B79 being ( 0 ) -started (State of ( SCMPDS )) holds (( B78 . B79 ) = ( 0 ) implies ( B79 . ( DataLoc (( B73 . B75 ) , B76) ) ) >= ( 0 ))) & (for B80 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for B81 being Int_position holds (B81 in B77 implies ( B80 . B81 ) = ( B73 . B81 ))) & ( B80 . B75 ) = ( B73 . B75 ) & ( B80 . ( DataLoc (( B73 . B75 ) , B76) ) ) < ( 0 )) implies (( ( IExec (B74 , R5 , B80) ) . B75 ) = ( B80 . B75 ) & B74 is_closed_on B80 , R5 & B74 is_halting_on B80 , R5 & ( B78 . ( Initialize ( IExec (B74 , R5 , B80) ) ) ) < ( B78 . B80 ) & (for B82 being Int_position holds (B82 in B77 implies ( ( IExec (B74 , R5 , B80) ) . B82 ) = ( B80 . B82 )))))))) implies ( IExec (( while<0 (B75 , B76 , B74) ) , R4 , B73) ) = ( IExec (( while<0 (B75 , B76 , B74) ) , R4 , ( Initialize ( IExec (B74 , R4 , B73) ) )) )))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C76 being ( 0 ) -started (State of ( SCMPDS ));
let C77 being  halt-free  shiftable (Program of ( SCMPDS ));
let C78 being Int_position;
let C79 being Integer;
let C80 being set;
let C81 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT ));
set D113 = ( DataLoc (( C76 . C78 ) , C79) );
deffunc H1((State of ( SCMPDS ))) = ( C81 . $1 );
defpred S4[ (State of ( SCMPDS )) ] means (for R1 being Int_position holds (R1 in C80 implies ( $1 . R1 ) = ( C76 . R1 )));
assume L346: ( C76 . D113 ) < ( 0 );
assume L347: (for B83 being ( 0 ) -started (State of ( SCMPDS )) holds (( C81 . B83 ) = ( 0 ) implies ( B83 . D113 ) >= ( 0 )));
L348: (for B84 being ( 0 ) -started (State of ( SCMPDS )) holds ((S4[ B84 ] & H1(B84) = ( 0 )) implies ( B84 . D113 ) >= ( 0 ))) by L347;
assume L349: (for B85 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for B86 being Int_position holds (B86 in C80 implies ( B85 . B86 ) = ( C76 . B86 ))) & ( B85 . C78 ) = ( C76 . C78 ) & ( B85 . D113 ) < ( 0 )) implies (( ( IExec (C77 , R5 , B85) ) . C78 ) = ( B85 . C78 ) & C77 is_closed_on B85 , R5 & C77 is_halting_on B85 , R5 & ( C81 . ( Initialize ( IExec (C77 , R5 , B85) ) ) ) < ( C81 . B85 ) & (for B87 being Int_position holds (B87 in C80 implies ( ( IExec (C77 , R5 , B85) ) . B87 ) = ( B85 . B87 )))))));
L350:
now
let C82 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
set D114 = C82;
assume that
L351: S4[ D114 ]
and
L352: (( C82 . C78 ) = ( C76 . C78 ) & ( C82 . D113 ) < ( 0 ));
set D115 = ( IExec (C77 , R5 , C82) );
thus L353: (( D115 . C78 ) = ( C82 . C78 ) & C77 is_closed_on C82 , R5 & C77 is_halting_on C82 , R5 & H1(( Initialize D115 )) < H1(C82)) by L349 , L352 , L351;
thus L354: S4[ ( Initialize D115 ) ]
proof
set D116 = ( Initialize D115 );
let R1 being Int_position;
assume L355: R1 in C80;
L356: ( D115 . R1 ) = ( C82 . R1 ) by L355 , L349 , L352 , L351;
L357: ( D116 . R1 ) = ( C82 . R1 ) by L356 , SCMPDS_5:15;
thus L358: ( D116 . R1 ) = ( C76 . R1 ) by L357 , L351 , L355;
end;

end;
L355: S4[ C76 ];
L356: ( IExec (( while<0 (C78 , C79 , C77) ) , R4 , C76) ) = ( IExec (( while<0 (C78 , C79 , C77) ) , R4 , ( Initialize ( IExec (C77 , R4 , C76) ) )) ) from WhileLExec(L346 , L348 , L355 , L350);
thus L357: thesis by L356;
end;
theorem
L358: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B88 being ( 0 ) -started (State of ( SCMPDS )) holds (for B89 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B90 being Int_position holds (for B91 being Integer holds (for B92 being set holds ((for B93 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for B94 being Int_position holds (B94 in B92 implies ( B93 . B94 ) = ( B88 . B94 ))) & ( B93 . B90 ) = ( B88 . B90 ) & ( B93 . ( DataLoc (( B88 . B90 ) , B91) ) ) < ( 0 )) implies (( ( IExec (B89 , R5 , B93) ) . B90 ) = ( B93 . B90 ) & ( ( IExec (B89 , R5 , B93) ) . ( DataLoc (( B88 . B90 ) , B91) ) ) > ( B93 . ( DataLoc (( B88 . B90 ) , B91) ) ) & B89 is_closed_on B93 , R5 & B89 is_halting_on B93 , R5 & (for B95 being Int_position holds (B95 in B92 implies ( ( IExec (B89 , R5 , B93) ) . B95 ) = ( B93 . B95 ))))))) implies (( while<0 (B90 , B91 , B89) ) is_closed_on B88 , R4 & ( while<0 (B90 , B91 , B89) ) is_halting_on B88 , R4))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C83 being ( 0 ) -started (State of ( SCMPDS ));
let C84 being  halt-free  shiftable (Program of ( SCMPDS ));
let C85 being Int_position;
let C86 being Integer;
let C87 being set;
set D117 = ( DataLoc (( C83 . C85 ) , C86) );
set D118 = ( while<0 (C85 , C86 , C84) );
set D119 = ( stop D118 );
set D120 = ( stop C84 );
set D121 = ( (C85 , C86) >=0_goto ( ( card C84 ) + 2 ) );
set D122 = ( goto ( - ( ( card C84 ) + 1 ) ) );
defpred S5[ (Element of ( NAT )) ] means (for B96 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((( - ( B96 . D117 ) ) <= $1 & (for R1 being Int_position holds (R1 in C87 implies ( B96 . R1 ) = ( C83 . R1 ))) & ( B96 . C85 ) = ( C83 . C85 )) implies (D118 is_closed_on B96 , R5 & D118 is_halting_on B96 , R5))));
assume L359: (for B97 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C87 implies ( B97 . R1 ) = ( C83 . R1 ))) & ( B97 . C85 ) = ( C83 . C85 ) & ( B97 . D117 ) < ( 0 )) implies (( ( IExec (C84 , R5 , B97) ) . C85 ) = ( B97 . C85 ) & ( ( IExec (C84 , R5 , B97) ) . D117 ) > ( B97 . D117 ) & C84 is_closed_on B97 , R5 & C84 is_halting_on B97 , R5 & (for R1 being Int_position holds (R1 in C87 implies ( ( IExec (C84 , R5 , B97) ) . R1 ) = ( B97 . R1 )))))));
L360: (for B98 being (Element of ( NAT )) holds (S5[ B98 ] implies S5[ ( B98 + 1 ) ]))
proof
let C88 being (Element of ( NAT ));
assume L361: S5[ C88 ];
L362:
now
let C89 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
L363: ( Initialize C89 ) = C89 by MEMSTR_0:44;
assume L364: ( - ( C89 . D117 ) ) <= ( C88 + 1 );
assume L365: (for R1 being Int_position holds (R1 in C87 implies ( C89 . R1 ) = ( C83 . R1 )));
assume L366: ( C89 . C85 ) = ( C83 . C85 );
per cases ;
suppose L367: ( C89 . D117 ) >= ( 0 );

thus L368: (D118 is_closed_on C89 , R5 & D118 is_halting_on C89 , R5) by L367 , L366 , L42;
end;
suppose L369: ( C89 . D117 ) < ( 0 );

L370: ( ( IExec (C84 , R5 , ( Initialize C89 )) ) . D117 ) > ( C89 . D117 ) by L359 , L365 , L366 , L369 , L363;
L371: ( 0 ) in ( dom D119 ) by COMPOS_1:36;
L372: (not D117 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L373: D118 = ( D121 ';' ( C84 ';' D122 ) ) by SCMPDS_4:15;
set D123 = ( Initialize C89 );
set D124 = ( R5 +* D120 );
set D125 = ( Initialize C89 );
set D126 = ( R5 +* D119 );
set D127 = ( Comput (D126 , D125 , 1) );
set D128 = D126;
L374: D120 c= D124 by FUNCT_4:25;
L375: ( Comput (D126 , D125 , ( ( 0 ) + 1 )) ) = ( Following (D126 , ( Comput (D126 , D125 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D126 , D125) )
.= ( Exec (D121 , D125) ) by L373 , SCMPDS_6:11;
L376: (for R2 being Int_position holds ( D123 . R2 ) = ( D127 . R2 )) by L375 , SCMPDS_2:57;
L377: ( DataPart D123 ) = ( DataPart D127 ) by L376 , SCMPDS_4:8;
L378: D118 c= D119 by AFINSQ_1:74;
L379: D119 c= D126 by FUNCT_4:25;
L380: D118 c= D126 by L379 , L378 , XBOOLE_1:1;
L381: ( Shift (C84 , 1) ) c= D118 by L110;
L382: ( Shift (C84 , 1) ) c= D128 by L381 , L380 , XBOOLE_1:1;
set D129 = ( LifeSpan (D124 , D123) );
set D130 = ( Comput (D128 , D127 , D129) );
set D131 = D128;
set D132 = ( ( card C84 ) + 1 );
L383: ( IC D125 ) = ( 0 ) by MEMSTR_0:def 11;
set D133 = ( D129 + 1 );
set D134 = ( Comput (D126 , D125 , D133) );
set D135 = D126;
set D136 = ( Comput (D126 , D125 , ( D133 + 1 )) );
set D137 = D126;
L384: ( ( card C84 ) + 1 ) < ( ( card C84 ) + 2 ) by XREAL_1:6;
L385: D132 in ( dom D118 ) by L384 , L34;
L386: ( IExec (C84 , R5 , ( Initialize C89 )) ) = ( Result (D124 , D123) ) by SCMPDS_4:def 5;
L387: C84 is_closed_on C89 , R5 by L359 , L365 , L366 , L369;
L388: C84 is_closed_on D123 , D124 by L387 , SCMPDS_6:24;
L389: C84 is_halting_on C89 , R5 by L359 , L365 , L366 , L369;
L390: D124 halts_on D123 by L389 , SCMPDS_6:def 3;
L391: ( D124 +* D120 ) halts_on ( Initialize D123 ) by L390;
L392: C84 is_halting_on D123 , D124 by L391 , SCMPDS_6:def 3;
L393: (not C85 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L394: ( D125 . ( DataLoc (( D125 . C85 ) , C86) ) ) = ( D125 . D117 ) by L393 , L366 , FUNCT_4:11
.= ( C89 . D117 ) by L372 , FUNCT_4:11;
L395: ( IC D127 ) = ( succ ( IC D125 ) ) by L394 , L369 , L375 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L383;
L396: ( IC D130 ) = D132 by L395 , L374 , L392 , L388 , L377 , L382 , SCMPDS_7:18;
L397: ( D135 /. ( IC D134 ) ) = ( D135 . ( IC D134 ) ) by PBOOLE:143;
L398: D134 = D130 by EXTPRO_1:4;
L399: ( CurInstr (D135 , D134) ) = ( D128 . D132 ) by L398 , L374 , L392 , L388 , L395 , L377 , L382 , L397 , SCMPDS_7:18
.= ( D118 . D132 ) by L385 , L380 , GRFUNC_1:2
.= D122 by L37;
L400: ( DataPart ( Comput (D124 , D123 , D129) ) ) = ( DataPart D130 ) by L374 , L392 , L388 , L395 , L377 , L382 , SCMPDS_7:18;
L401: ( D130 . C85 ) = ( ( Comput (D124 , D123 , D129) ) . C85 ) by L400 , SCMPDS_4:8
.= ( ( Result (D124 , D123) ) . C85 ) by L390 , EXTPRO_1:23
.= ( C83 . C85 ) by L366 , L359 , L365 , L369 , L386 , L363;
L402: D136 = ( Following (D126 , D134) ) by EXTPRO_1:3
.= ( Exec (D122 , D134) ) by L399;
L403: ( IC D136 ) = ( ICplusConst (D134 , ( ( 0 ) - ( ( card C84 ) + 1 ) )) ) by L402 , SCMPDS_2:54
.= ( 0 ) by L396 , L398 , SCMPDS_7:1;
L404: ( Initialize D136 ) = D136 by L403 , MEMSTR_0:46;
L405:
now
let C90 being Int_position;
assume L406: C90 in C87;
L407: ( D130 . C90 ) = ( ( Comput (D124 , D123 , D129) ) . C90 ) by L400 , SCMPDS_4:8
.= ( ( Result (D124 , D123) ) . C90 ) by L390 , EXTPRO_1:23
.= ( ( IExec (C84 , R5 , ( Initialize C89 )) ) . C90 ) by SCMPDS_4:def 5
.= ( C89 . C90 ) by L359 , L365 , L366 , L369 , L406 , L363
.= ( C83 . C90 ) by L365 , L406;
thus L408: ( D136 . C90 ) = ( C83 . C90 ) by L407 , L398 , L402 , SCMPDS_2:54;
end;
L409: ( D130 . D117 ) = ( ( Comput (D124 , D123 , D129) ) . D117 ) by L400 , SCMPDS_4:8
.= ( ( Result (D124 , D123) ) . D117 ) by L390 , EXTPRO_1:23
.= ( ( IExec (C84 , R5 , ( Initialize C89 )) ) . D117 ) by SCMPDS_4:def 5;
L410: ( D136 . D117 ) = ( ( IExec (C84 , R5 , ( Initialize C89 )) ) . D117 ) by L409 , L398 , L402 , SCMPDS_2:54;
L411:
now
L412: ( - ( D136 . D117 ) ) < ( - ( C89 . D117 ) ) by L370 , L410 , XREAL_1:24;
L413: ( - ( D136 . D117 ) ) < ( C88 + 1 ) by L412 , L364 , XXREAL_0:2;
assume L414: ( - ( D136 . D117 ) ) > C88;
thus L415: contradiction by L414 , L413 , INT_1:7;
end;
L416: ( D136 . C85 ) = ( D134 . C85 ) by L402 , SCMPDS_2:54
.= ( C83 . C85 ) by L401 , EXTPRO_1:4;
L417: D118 is_closed_on D136 , D137 by L416 , L361 , L405 , L411 , L404;
L418:
now
let C91 being (Element of ( NAT ));
per cases ;
suppose L419: C91 < ( D133 + 1 );

L420: C91 <= D133 by L419 , INT_1:7;
thus L421:now
per cases  by L420 , NAT_1:8;
suppose L422: C91 <= D129;

thus L423:now
per cases ;
suppose L424: C91 = ( 0 );

thus L425: ( IC ( Comput (D126 , D125 , C91) ) ) in ( dom D119 ) by L424 , L371 , L383 , EXTPRO_1:2;
end;
suppose L426: C91 <> ( 0 );

consider C92 being Nat such that L427: C91 = ( C92 + 1 ) by L426 , NAT_1:6;
reconsider D138 = C92 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D139 = ( IC ( Comput (D124 , D123 , D138) ) ) as (Element of ( NAT ));
L428: D138 < C91 by L427 , XREAL_1:29;
L429: D138 < D129 by L428 , L422 , XXREAL_0:2;
L430: ( ( IC ( Comput (D124 , D123 , D138) ) ) + 1 ) = ( IC ( Comput (D128 , D127 , D138) ) ) by L429 , L374 , L392 , L388 , L395 , L377 , L382 , SCMPDS_7:16;
L431: ( IC ( Comput (D126 , D125 , C91) ) ) = ( D139 + 1 ) by L430 , L427 , EXTPRO_1:4;
L432: ( IC ( Comput (D124 , D123 , D138) ) ) in ( dom D120 ) by L387 , SCMPDS_6:def 2;
L433: D139 < ( card D120 ) by L432 , AFINSQ_1:66;
L434: D139 < ( ( card C84 ) + 1 ) by L433 , COMPOS_1:55;
L435: ( D139 + 1 ) <= ( ( card C84 ) + 1 ) by L434 , INT_1:7;
L436: ( ( card C84 ) + 1 ) < ( ( card C84 ) + 3 ) by XREAL_1:6;
L437: ( D139 + 1 ) < ( ( card C84 ) + 3 ) by L436 , L435 , XXREAL_0:2;
L438: ( D139 + 1 ) < ( card D119 ) by L437 , L32;
thus L439: ( IC ( Comput (D126 , D125 , C91) ) ) in ( dom D119 ) by L438 , L431 , AFINSQ_1:66;
end;
end;
end;
suppose L424: C91 = D133;

L425: D132 in ( dom D119 ) by L385 , COMPOS_1:62;
thus L426: ( IC ( Comput (D126 , D125 , C91) ) ) in ( dom D119 ) by L425 , L374 , L392 , L388 , L395 , L377 , L382 , L398 , L424 , SCMPDS_7:18;
end;
end;
end;
suppose L422: C91 >= ( D133 + 1 );

consider C93 being Nat such that L423: C91 = ( ( D133 + 1 ) + C93 ) by L422 , NAT_1:10;
reconsider D140 = C93 as (Element of ( NAT )) by ORDINAL1:def 12;
L424: ( Comput (D126 , D125 , C91) ) = ( Comput (( D137 +* D119 ) , ( Initialize D136 ) , D140) ) by L404 , L423 , EXTPRO_1:4;
thus L425: ( IC ( Comput (D126 , D125 , C91) ) ) in ( dom D119 ) by L424 , L417 , SCMPDS_6:def 2;
end;
end;
thus L427: D118 is_closed_on C89 , R5 by L418 , SCMPDS_6:def 2;
L428: D126 = ( D137 +* D119 );
L429: D118 is_halting_on D136 , D137 by L361 , L416 , L405 , L411 , L404;
L430: D126 halts_on D136 by L429 , L404 , L428 , SCMPDS_6:def 3;
L431: D126 halts_on D125 by L430 , EXTPRO_1:22;
thus L432: D118 is_halting_on C89 , R5 by L431 , SCMPDS_6:def 3;
end;
end;
thus L434: thesis by L362;
end;
L435: S5[ ( 0 ) ]
proof
let C94 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume L436: ( - ( C94 . D117 ) ) <= ( 0 );
L437: ( - ( C94 . D117 ) ) <= ( - ( 0 ) ) by L436;
L438: ( C94 . D117 ) >= ( 0 ) by L437 , XREAL_1:24;
assume L439: (for R1 being Int_position holds (R1 in C87 implies ( C94 . R1 ) = ( C83 . R1 )));
assume L440: ( C94 . C85 ) = ( C83 . C85 );
thus L441: thesis by L440 , L438 , L42;
end;
L442: (for B99 being (Element of ( NAT )) holds S5[ B99 ]) from NAT_1:sch 1(L435 , L360);
per cases ;
suppose L443: ( C83 . D117 ) >= ( 0 );

thus L444: thesis by L443 , L42;
end;
suppose L445: ( C83 . D117 ) < ( 0 );

reconsider D141 = ( - ( C83 . D117 ) ) as (Element of ( NAT )) by L445 , INT_1:3;
L446: (S5[ D141 ] & (for B100 being Int_position holds (B100 in C87 implies ( C83 . B100 ) = ( C83 . B100 )))) by L442;
thus L447: thesis by L446;
end;
end;
theorem
L449: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B101 being ( 0 ) -started (State of ( SCMPDS )) holds (for B102 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B103 being Int_position holds (for B104 being Integer holds (for B105 being set holds ((( B101 . ( DataLoc (( B101 . B103 ) , B104) ) ) < ( 0 ) & (for B106 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for B107 being Int_position holds (B107 in B105 implies ( B106 . B107 ) = ( B101 . B107 ))) & ( B106 . B103 ) = ( B101 . B103 ) & ( B106 . ( DataLoc (( B101 . B103 ) , B104) ) ) < ( 0 )) implies (( ( IExec (B102 , R5 , B106) ) . B103 ) = ( B106 . B103 ) & ( ( IExec (B102 , R5 , B106) ) . ( DataLoc (( B101 . B103 ) , B104) ) ) > ( B106 . ( DataLoc (( B101 . B103 ) , B104) ) ) & B102 is_closed_on B106 , R5 & B102 is_halting_on B106 , R5 & (for B108 being Int_position holds (B108 in B105 implies ( ( IExec (B102 , R5 , B106) ) . B108 ) = ( B106 . B108 )))))))) implies ( IExec (( while<0 (B103 , B104 , B102) ) , R4 , B101) ) = ( IExec (( while<0 (B103 , B104 , B102) ) , R4 , ( Initialize ( IExec (B102 , R4 , B101) ) )) ))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C95 being ( 0 ) -started (State of ( SCMPDS ));
let C96 being  halt-free  shiftable (Program of ( SCMPDS ));
let C97 being Int_position;
let C98 being Integer;
let C99 being set;
L450: ( Initialize C95 ) = C95 by MEMSTR_0:44;
set D142 = ( DataLoc (( C95 . C97 ) , C98) );
set D143 = ( while<0 (C97 , C98 , C96) );
set D144 = ( stop D143 );
set D145 = ( R4 +* D144 );
set D146 = ( (C97 , C98) >=0_goto ( ( card C96 ) + 2 ) );
set D147 = ( goto ( - ( ( card C96 ) + 1 ) ) );
assume L451: ( C95 . D142 ) < ( 0 );
set D148 = ( IExec (C96 , R4 , C95) );
set D149 = ( DataLoc (( ( Initialize D148 ) . C97 ) , C98) );
set D150 = R4;
set D151 = ( R4 +* ( stop C96 ) );
set D152 = ( ( LifeSpan (D151 , C95) ) + 2 );
set D153 = ( Initialize ( IExec (C96 , R4 , C95) ) );
set D154 = ( R4 +* D144 );
set D155 = ( LifeSpan (D154 , D153) );
assume L452: (for B109 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C99 implies ( B109 . R1 ) = ( C95 . R1 ))) & ( B109 . C97 ) = ( C95 . C97 ) & ( B109 . D142 ) < ( 0 )) implies (( ( IExec (C96 , R5 , B109) ) . C97 ) = ( B109 . C97 ) & ( ( IExec (C96 , R5 , B109) ) . D142 ) > ( B109 . D142 ) & C96 is_closed_on B109 , R5 & C96 is_halting_on B109 , R5 & (for R1 being Int_position holds (R1 in C99 implies ( ( IExec (C96 , R5 , B109) ) . R1 ) = ( B109 . R1 )))))));
L453: D143 is_halting_on C95 , R4 by L452 , L358;
L454: D145 halts_on C95 by L453 , L450 , SCMPDS_6:def 3;
L455: ( stop C96 ) c= D151 by FUNCT_4:25;
L456: (for R1 being Int_position holds (R1 in C99 implies ( C95 . R1 ) = ( C95 . R1 )));
L457: C96 is_halting_on C95 , R4 by L456 , L451 , L452;
L458: D151 halts_on C95 by L457 , L450 , SCMPDS_6:def 3;
L459: ( D151 +* ( stop C96 ) ) halts_on C95 by L458;
L460: C96 is_halting_on C95 , D151 by L459 , L450 , SCMPDS_6:def 3;
L461: ( ( Initialize D148 ) . C97 ) = ( D148 . C97 ) by SCMPDS_5:15
.= ( C95 . C97 ) by L451 , L452 , L456;
L462:
now
let C100 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume that
L463: (for R1 being Int_position holds (R1 in C99 implies ( C100 . R1 ) = ( ( Initialize D148 ) . R1 )))
and
L464: (( C100 . C97 ) = ( ( Initialize D148 ) . C97 ) & ( C100 . D149 ) < ( 0 ));
L465:
now
let C101 being Int_position;
assume L466: C101 in C99;
thus L467: ( C100 . C101 ) = ( ( Initialize D148 ) . C101 ) by L466 , L463
.= ( D148 . C101 ) by SCMPDS_5:15
.= ( C95 . C101 ) by L451 , L452 , L456 , L466;
end;
thus L468: ( ( IExec (C96 , R5 , C100) ) . C97 ) = ( C100 . C97 ) by L465 , L452 , L461 , L464;
thus L469: ( ( IExec (C96 , R5 , C100) ) . D149 ) > ( C100 . D149 ) by L452 , L461 , L464 , L465;
thus L470: (C96 is_closed_on C100 , R5 & C96 is_halting_on C100 , R5 & (for R1 being Int_position holds (R1 in C99 implies ( ( IExec (C96 , R5 , C100) ) . R1 ) = ( C100 . R1 )))) by L452 , L461 , L464 , L465;
end;
L471: D143 is_halting_on ( Initialize D148 ) , R4 by L462 , L358;
L472: ( R4 +* ( stop D143 ) ) halts_on ( Initialize ( Initialize D148 ) ) by L471 , SCMPDS_6:def 3;
set D156 = ( LifeSpan (D145 , C95) );
set D157 = ( Comput (D145 , C95 , 1) );
set D158 = D145;
L473: ( IC C95 ) = ( 0 ) by MEMSTR_0:def 11;
L474: D143 = ( D146 ';' ( C96 ';' D147 ) ) by SCMPDS_4:15;
L475: ( Comput (D145 , C95 , ( ( 0 ) + 1 )) ) = ( Following (D145 , ( Comput (D145 , C95 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D145 , C95) )
.= ( Exec (D146 , C95) ) by L474 , L450 , SCMPDS_6:11;
L476: ( IC D157 ) = ( succ ( IC C95 ) ) by L451 , L475 , SCMPDS_2:57
.= ( ( 0 ) + 1 ) by L473;
set D159 = ( LifeSpan (D151 , C95) );
set D160 = ( Comput (D158 , D157 , D159) );
set D161 = D158;
set D162 = ( ( card C96 ) + 1 );
L477: (for R2 being Int_position holds ( C95 . R2 ) = ( D157 . R2 )) by L475 , SCMPDS_2:57;
L478: ( DataPart C95 ) = ( DataPart D157 ) by L477 , SCMPDS_4:8;
set D163 = ( D159 + 1 );
set D164 = ( Comput (D145 , C95 , D163) );
set D165 = D145;
L479: ( ( card C96 ) + 1 ) < ( ( card C96 ) + 2 ) by XREAL_1:6;
L480: D162 in ( dom D143 ) by L479 , L34;
set D166 = ( Comput (D145 , C95 , ( D163 + 1 )) );
L481: D143 c= D144 by AFINSQ_1:74;
L482: D144 c= D145 by FUNCT_4:25;
L483: D143 c= D145 by L482 , L481 , XBOOLE_1:1;
L484: ( Shift (C96 , 1) ) c= D143 by L110;
L485: ( Shift (C96 , 1) ) c= D158 by L484 , L483 , XBOOLE_1:1;
L486: C96 is_closed_on C95 , D151 by L451 , L452 , L456;
L487: ( IC D160 ) = D162 by L486 , L455 , L460 , L476 , L478 , L485 , SCMPDS_7:18;
L488: ( D165 /. ( IC D164 ) ) = ( D165 . ( IC D164 ) ) by PBOOLE:143;
L489: D164 = D160 by EXTPRO_1:4;
L490: ( CurInstr (D165 , D164) ) = ( D158 . D162 ) by L489 , L455 , L460 , L486 , L476 , L478 , L485 , L488 , SCMPDS_7:18
.= ( D143 . D162 ) by L480 , L483 , GRFUNC_1:2
.= D147 by L37;
L491: D166 = ( Following (D145 , D164) ) by EXTPRO_1:3
.= ( Exec (D147 , D164) ) by L490;
L492: ( IC D166 ) = ( ICplusConst (D164 , ( ( 0 ) - ( ( card C96 ) + 1 ) )) ) by L491 , SCMPDS_2:54
.= ( 0 ) by L487 , L489 , SCMPDS_7:1;
L493: ( IC D153 ) = ( IC ( Comput (D145 , C95 , D152) ) ) by L492 , MEMSTR_0:def 11;
L494: ( DataPart ( Comput (D151 , C95 , D159) ) ) = ( DataPart D160 ) by L455 , L460 , L486 , L476 , L478 , L485 , SCMPDS_7:18;
L495:
now
let C102 being Int_position;
L496: (not C102 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L497: ( D160 . C102 ) = ( ( Comput (D151 , C95 , D159) ) . C102 ) by L494 , SCMPDS_4:8
.= ( ( Result (D151 , C95) ) . C102 ) by L458 , EXTPRO_1:23
.= ( ( IExec (C96 , R4 , C95) ) . C102 ) by SCMPDS_4:def 5;
thus L498: ( D166 . C102 ) = ( ( IExec (C96 , R4 , C95) ) . C102 ) by L497 , L489 , L491 , SCMPDS_2:54
.= ( D153 . C102 ) by L496 , FUNCT_4:11;
end;
L499: ( DataPart D166 ) = ( DataPart D153 ) by L495 , SCMPDS_4:8;
L500: ( Comput (D145 , C95 , D152) ) = D153 by L499 , L493 , MEMSTR_0:78;
L501: ( CurInstr (D145 , ( Comput (D145 , C95 , D152) )) ) = D146 by L500 , L474 , SCMPDS_6:11;
L502: D156 > D152 by L501 , L454 , EXTPRO_1:36 , SCMPDS_6:18;
consider C103 being Nat such that L503: D156 = ( D152 + C103 ) by L502 , NAT_1:10;
reconsider D167 = C103 as (Element of ( NAT )) by ORDINAL1:def 12;
L504: ( Comput (D145 , C95 , ( D152 + D155 )) ) = ( Comput (D145 , D153 , D155) ) by L500 , EXTPRO_1:4;
L505: ( CurInstr (D145 , ( Comput (D145 , C95 , ( D152 + D155 )) )) ) = ( halt ( SCMPDS ) ) by L504 , L472 , EXTPRO_1:def 15;
L506: ( D152 + D155 ) >= D156 by L505 , L454 , EXTPRO_1:def 15;
L507: D155 >= D167 by L506 , L503 , XREAL_1:6;
L508: ( Comput (D145 , C95 , D156) ) = ( Comput (D145 , D153 , D167) ) by L500 , L503 , EXTPRO_1:4;
L509: ( CurInstr (D154 , ( Comput (D154 , D153 , D167) )) ) = ( halt ( SCMPDS ) ) by L508 , L454 , EXTPRO_1:def 15;
L510: D167 >= D155 by L509 , L472 , EXTPRO_1:def 15;
L511: D167 = D155 by L510 , L507 , XXREAL_0:1;
L512: ( Result (D145 , C95) ) = ( Comput (D154 , D153 , D155) ) by L511 , L454 , L508 , EXTPRO_1:23;
thus L513: ( IExec (D143 , R4 , C95) ) = ( Comput (D154 , D153 , D155) ) by L512 , SCMPDS_4:def 5
.= ( Result (D154 , D153) ) by L472 , EXTPRO_1:23
.= ( IExec (D143 , R4 , ( Initialize ( IExec (C96 , R4 , C95) ) )) ) by SCMPDS_4:def 5;
end;
begin
definition
let C104 being Int_position;
let C105 being Integer;
let C106 being (Program of ( SCMPDS ));
func while>0 (C104 , C105 , C106) -> (Program of ( SCMPDS )) equals 
( ( ( (C104 , C105) <=0_goto ( ( card C106 ) + 2 ) ) ';' C106 ) ';' ( goto ( - ( ( card C106 ) + 1 ) ) ) );
coherence;
end;
registration
let C107 being  shiftable (Program of ( SCMPDS ));
let C108 being Int_position;
let C109 being Integer;
cluster ( while>0 (C108 , C109 , C107) ) ->  shiftable;
correctness
proof
set D168 = ( while>0 (C108 , C109 , C107) );
set D169 = ( (C108 , C109) <=0_goto ( ( card C107 ) + 2 ) );
reconsider D170 = ( ( Load D169 ) ';' C107 ) as  shiftable (Program of ( SCMPDS ));
L515: D170 = ( D169 ';' C107 ) by SCMPDS_4:def 2;
L516: ( card D170 ) = ( ( card C107 ) + 1 ) by L515 , SCMPDS_6:6;
L517: ( ( card D170 ) + ( - ( ( card C107 ) + 1 ) ) ) = ( 0 ) by L516;
thus L518: thesis by L517 , L515 , SCMPDS_4:23;
end;
end;
registration
let C110 being  halt-free (Program of ( SCMPDS ));
let C111 being Int_position;
let C112 being Integer;
cluster ( while>0 (C111 , C112 , C110) ) ->  halt-free;
correctness;
end;
theorem
L521: (for B110 being Int_position holds (for B111 being Integer holds (for B112 being (Program of ( SCMPDS )) holds ( card ( while>0 (B110 , B111 , B112) ) ) = ( ( card B112 ) + 2 ))))
proof
let C113 being Int_position;
let C114 being Integer;
let C115 being (Program of ( SCMPDS ));
set D171 = ( (C113 , C114) <=0_goto ( ( card C115 ) + 2 ) );
set D172 = ( D171 ';' C115 );
thus L522: ( card ( while>0 (C113 , C114 , C115) ) ) = ( ( card D172 ) + 1 ) by SCMP_GCD:4
.= ( ( ( card C115 ) + 1 ) + 1 ) by SCMPDS_6:6
.= ( ( card C115 ) + 2 );
end;
L523: (for B113 being Int_position holds (for B114 being Integer holds (for B115 being (Program of ( SCMPDS )) holds ( card ( stop ( while>0 (B113 , B114 , B115) ) ) ) = ( ( card B115 ) + 3 ))))
proof
let C116 being Int_position;
let C117 being Integer;
let C118 being (Program of ( SCMPDS ));
thus L524: ( card ( stop ( while>0 (C116 , C117 , C118) ) ) ) = ( ( card ( while>0 (C116 , C117 , C118) ) ) + 1 ) by COMPOS_1:55
.= ( ( ( card C118 ) + 2 ) + 1 ) by L521
.= ( ( card C118 ) + 3 );
end;
theorem
L525: (for B116 being Int_position holds (for B117 being Integer holds (for B118 being (Element of ( NAT )) holds (for B119 being (Program of ( SCMPDS )) holds (B118 < ( ( card B119 ) + 2 ) iff B118 in ( dom ( while>0 (B116 , B117 , B119) ) ))))))
proof
let C119 being Int_position;
let C120 being Integer;
let C121 being (Element of ( NAT ));
let C122 being (Program of ( SCMPDS ));
L526: ( card ( while>0 (C119 , C120 , C122) ) ) = ( ( card C122 ) + 2 ) by L521;
thus L527: thesis by L526 , AFINSQ_1:66;
end;
theorem
L528: (for B120 being Int_position holds (for B121 being Integer holds (for B122 being (Program of ( SCMPDS )) holds (( ( while>0 (B120 , B121 , B122) ) . ( 0 ) ) = ( (B120 , B121) <=0_goto ( ( card B122 ) + 2 ) ) & ( ( while>0 (B120 , B121 , B122) ) . ( ( card B122 ) + 1 ) ) = ( goto ( - ( ( card B122 ) + 1 ) ) )))))
proof
let C123 being Int_position;
let C124 being Integer;
let C125 being (Program of ( SCMPDS ));
set D173 = ( (C123 , C124) <=0_goto ( ( card C125 ) + 2 ) );
set D174 = ( goto ( - ( ( card C125 ) + 1 ) ) );
set D175 = ( D173 ';' C125 );
set D176 = ( C125 ';' D174 );
set D177 = ( while>0 (C123 , C124 , C125) );
L529: D177 = ( D173 ';' D176 ) by SCMPDS_4:15;
thus L530: ( D177 . ( 0 ) ) = D173 by L529 , SCMPDS_6:7;
L531: ( card D175 ) = ( ( card C125 ) + 1 ) by SCMPDS_6:6;
thus L532: thesis by L531 , SCMP_GCD:6;
end;
theorem
L533: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B123 being (State of ( SCMPDS )) holds (for B124 being (Program of ( SCMPDS )) holds (for B125 being Int_position holds (for B126 being Integer holds (( B123 . ( DataLoc (( B123 . B125 ) , B126) ) ) <= ( 0 ) implies (( while>0 (B125 , B126 , B124) ) is_closed_on B123 , R4 & ( while>0 (B125 , B126 , B124) ) is_halting_on B123 , R4)))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C126 being (State of ( SCMPDS ));
let C127 being (Program of ( SCMPDS ));
let C128 being Int_position;
let C129 being Integer;
set D178 = ( DataLoc (( C126 . C128 ) , C129) );
assume L534: ( C126 . D178 ) <= ( 0 );
set D179 = ( (C128 , C129) <=0_goto ( ( card C127 ) + 2 ) );
set D180 = ( goto ( - ( ( card C127 ) + 1 ) ) );
set D181 = ( while>0 (C128 , C129 , C127) );
set D182 = ( stop D181 );
set D183 = ( Initialize C126 );
set D184 = ( R4 +* D182 );
set D185 = ( Comput (D184 , D183 , 1) );
set D186 = D184;
L535: ( IC D183 ) = ( 0 ) by MEMSTR_0:def 11;
L536: (not D178 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L537: (not C128 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L538: ( D183 . ( DataLoc (( D183 . C128 ) , C129) ) ) = ( D183 . D178 ) by L537 , FUNCT_4:11
.= ( C126 . D178 ) by L536 , FUNCT_4:11;
L539: D181 = ( D179 ';' ( C127 ';' D180 ) ) by SCMPDS_4:15;
L540: ( Comput (D184 , D183 , ( ( 0 ) + 1 )) ) = ( Following (D184 , ( Comput (D184 , D183 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D184 , D183) )
.= ( Exec (D179 , D183) ) by L539 , SCMPDS_6:11;
L541: ( IC D185 ) = ( ICplusConst (D183 , ( ( card C127 ) + 2 )) ) by L540 , L534 , L538 , SCMPDS_2:56
.= ( ( 0 ) + ( ( card C127 ) + 2 ) ) by L535 , SCMPDS_6:12;
L542: ( card D181 ) = ( ( card C127 ) + 2 ) by L521;
L543: ( ( card C127 ) + 2 ) in ( dom D182 ) by L542 , COMPOS_1:64;
L544: D182 c= D186 by FUNCT_4:25;
L545: ( D186 . ( ( card C127 ) + 2 ) ) = ( D182 . ( ( card C127 ) + 2 ) ) by L544 , L543 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L542 , COMPOS_1:64;
L546: ( CurInstr (D186 , D185) ) = ( halt ( SCMPDS ) ) by L545 , L541 , PBOOLE:143;
L547:
now
let C130 being (Element of ( NAT ));
per cases ;
suppose L548: ( 0 ) < C130;

L549: ( 1 + ( 0 ) ) <= C130 by L548 , INT_1:7;
thus L550: ( IC ( Comput (D184 , D183 , C130) ) ) in ( dom D182 ) by L549 , L543 , L541 , L546 , EXTPRO_1:5;
end;
suppose L551: C130 = ( 0 );

L552: ( Comput (D184 , D183 , C130) ) = D183 by L551 , EXTPRO_1:2;
thus L553: ( IC ( Comput (D184 , D183 , C130) ) ) in ( dom D182 ) by L552 , L535 , COMPOS_1:36;
end;
end;
thus L555: D181 is_closed_on C126 , R4 by L547 , SCMPDS_6:def 2;
L556: D184 halts_on D183 by L546 , EXTPRO_1:29;
thus L557: thesis by L556 , SCMPDS_6:def 3;
end;
theorem
L558: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B127 being ( 0 ) -started (State of ( SCMPDS )) holds (for B128 being (Program of ( SCMPDS )) holds (for B129 , B130 being Int_position holds (for B131 being Integer holds (( B127 . ( DataLoc (( B127 . B129 ) , B131) ) ) <= ( 0 ) implies ( IExec (( while>0 (B129 , B131 , B128) ) , R4 , B127) ) = ( B127 +* ( Start-At (( ( card B128 ) + 2 ) , ( SCMPDS )) ) )))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C131 being ( 0 ) -started (State of ( SCMPDS ));
let C132 being (Program of ( SCMPDS ));
let C133 , C134 being Int_position;
let C135 being Integer;
set D187 = ( DataLoc (( C131 . C133 ) , C135) );
set D188 = ( while>0 (C133 , C135 , C132) );
set D189 = ( stop D188 );
set D190 = ( R4 +* D189 );
set D191 = ( Comput (D190 , C131 , 1) );
set D192 = D190;
set D193 = ( (C133 , C135) <=0_goto ( ( card C132 ) + 2 ) );
set D194 = ( goto ( - ( ( card C132 ) + 1 ) ) );
set D195 = ( Start-At (( ( card C132 ) + 2 ) , ( SCMPDS )) );
L559: ( Initialize C131 ) = C131 by MEMSTR_0:44;
L560: ( IC C131 ) = ( 0 ) by MEMSTR_0:def 11;
L561: D188 = ( D193 ';' ( C132 ';' D194 ) ) by SCMPDS_4:15;
L562: ( Comput (D190 , C131 , ( ( 0 ) + 1 )) ) = ( Following (D190 , ( Comput (D190 , C131 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D190 , C131) )
.= ( Exec (D193 , C131) ) by L561 , L559 , SCMPDS_6:11;
L563: D189 c= D192 by FUNCT_4:25;
L564: ( IExec (D188 , R4 , C131) ) = ( Result (D190 , C131) ) by SCMPDS_4:def 5;
assume L565: ( C131 . D187 ) <= ( 0 );
L566: ( IC D191 ) = ( ICplusConst (C131 , ( ( card C132 ) + 2 )) ) by L565 , L562 , SCMPDS_2:56
.= ( ( 0 ) + ( ( card C132 ) + 2 ) ) by L560 , SCMPDS_6:12;
L567: ( card D188 ) = ( ( card C132 ) + 2 ) by L521;
L568: ( ( card C132 ) + 2 ) in ( dom D189 ) by L567 , COMPOS_1:64;
L569: ( D192 . ( ( card C132 ) + 2 ) ) = ( D189 . ( ( card C132 ) + 2 ) ) by L568 , L563 , GRFUNC_1:2
.= ( halt ( SCMPDS ) ) by L567 , COMPOS_1:64;
L570: ( CurInstr (D192 , D191) ) = ( halt ( SCMPDS ) ) by L569 , L566 , PBOOLE:143;
L571: D190 halts_on C131 by L570 , EXTPRO_1:29;
L572: ( CurInstr (D190 , C131) ) = D193 by L561 , L559 , SCMPDS_6:11;
L573:
now
let C136 being (Element of ( NAT ));
L574: ( Comput (D190 , C131 , ( 0 )) ) = C131;
assume L575: C136 < ( ( 0 ) + 1 );
L576: C136 = ( 0 ) by L575 , NAT_1:13;
thus L577: ( CurInstr (D190 , ( Comput (D190 , C131 , C136) )) ) <> ( halt ( SCMPDS ) ) by L576 , L572 , L574;
end;
L578: (for B132 being (Element of ( NAT )) holds (( CurInstr (D190 , ( Comput (D190 , C131 , B132) )) ) = ( halt ( SCMPDS ) ) implies 1 <= B132)) by L573;
L579: ( LifeSpan (D190 , C131) ) = 1 by L578 , L570 , L571 , EXTPRO_1:def 15;
L580:
now
let C137 being set;
L581: ( dom D195 ) = { ( IC ( SCMPDS ) ) } by FUNCOP_1:13;
assume L582: C137 in ( dom ( IExec (D188 , R4 , C131) ) );
per cases  by L582 , SCMPDS_4:6;
suppose L583: C137 is Int_position;

L584: C137 <> ( IC ( SCMPDS ) ) by L583 , SCMPDS_2:43;
L585: (not C137 in ( dom D195 )) by L584 , L581 , TARSKI:def 1;
thus L586: ( ( IExec (D188 , R4 , C131) ) . C137 ) = ( D191 . C137 ) by L564 , L579 , L571 , EXTPRO_1:23
.= ( C131 . C137 ) by L562 , L583 , SCMPDS_2:56
.= ( ( C131 +* D195 ) . C137 ) by L585 , FUNCT_4:11;
end;
suppose L587: C137 = ( IC ( SCMPDS ) );

thus L588: ( ( IExec (D188 , R4 , C131) ) . C137 ) = ( ( card C132 ) + 2 ) by L587 , L564 , L566 , L579 , L571 , EXTPRO_1:23
.= ( ( C131 +* D195 ) . C137 ) by L587 , FUNCT_4:113;
end;
end;
L590: ( dom ( IExec (D188 , R4 , C131) ) ) = (the carrier of ( SCMPDS )) by PARTFUN1:def 2
.= ( dom ( C131 +* D195 ) ) by PARTFUN1:def 2;
thus L591: thesis by L590 , L580 , FUNCT_1:2;
end;
theorem
L592: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B133 being ( 0 ) -started (State of ( SCMPDS )) holds (for B134 being (Program of ( SCMPDS )) holds (for B135 being Int_position holds (for B136 being Integer holds (( B133 . ( DataLoc (( B133 . B135 ) , B136) ) ) <= ( 0 ) implies ( IC ( IExec (( while>0 (B135 , B136 , B134) ) , R4 , B133) ) ) = ( ( card B134 ) + 2 )))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C138 being ( 0 ) -started (State of ( SCMPDS ));
let C139 being (Program of ( SCMPDS ));
let C140 being Int_position;
let C141 being Integer;
assume L593: ( C138 . ( DataLoc (( C138 . C140 ) , C141) ) ) <= ( 0 );
L594: ( IExec (( while>0 (C140 , C141 , C139) ) , R4 , C138) ) = ( C138 +* ( Start-At (( ( card C139 ) + 2 ) , ( SCMPDS )) ) ) by L593 , L558;
thus L595: thesis by L594 , FUNCT_4:113;
end;
theorem
L596: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B137 being ( 0 ) -started (State of ( SCMPDS )) holds (for B138 being (Program of ( SCMPDS )) holds (for B139 , B140 being Int_position holds (for B141 being Integer holds (( B137 . ( DataLoc (( B137 . B139 ) , B141) ) ) <= ( 0 ) implies ( ( IExec (( while>0 (B139 , B141 , B138) ) , R4 , B137) ) . B140 ) = ( B137 . B140 )))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C142 being ( 0 ) -started (State of ( SCMPDS ));
let C143 being (Program of ( SCMPDS ));
let C144 , C145 being Int_position;
let C146 being Integer;
assume L597: ( C142 . ( DataLoc (( C142 . C144 ) , C146) ) ) <= ( 0 );
L598: ( IExec (( while>0 (C144 , C146 , C143) ) , R4 , C142) ) = ( C142 +* ( Start-At (( ( card C143 ) + 2 ) , ( SCMPDS )) ) ) by L597 , L558;
L599: (not C145 in ( dom ( Start-At (( ( card C143 ) + 2 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
thus L600: thesis by L599 , L598 , FUNCT_4:11;
end;
L601: (for B142 being (Program of ( SCMPDS )) holds (for B143 being Int_position holds (for B144 being Integer holds ( Shift (B142 , 1) ) c= ( while>0 (B143 , B144 , B142) ))))
proof
let C147 being (Program of ( SCMPDS ));
let C148 being Int_position;
let C149 being Integer;
set D196 = ( (C148 , C149) <=0_goto ( ( card C147 ) + 2 ) );
set D197 = ( goto ( - ( ( card C147 ) + 1 ) ) );
L602: ( while>0 (C148 , C149 , C147) ) = ( ( D196 ';' C147 ) ';' ( Load D197 ) ) by SCMPDS_4:def 3
.= ( ( ( Load D196 ) ';' C147 ) ';' ( Load D197 ) ) by SCMPDS_4:def 2;
L603: ( card ( Load D196 ) ) = 1 by COMPOS_1:54;
thus L604: thesis by L603 , L602 , SCMPDS_7:3;
end;
scheme WhileGHalt { F13((State of ( SCMPDS ))) -> (Element of ( NAT )) , F14() -> ( 0 ) -started (State of ( SCMPDS )) , F15() -> (Instruction-Sequence of ( SCMPDS )) , F16() ->  halt-free  shiftable (Program of ( SCMPDS )) , F17() -> Int_position , F18() -> Integer , P3[(State of ( SCMPDS ))] } : (( while>0 (F17() , F18() , F16()) ) is_closed_on F14() , F15() & ( while>0 (F17() , F18() , F16()) ) is_halting_on F14() , F15())
provided
L605: (for B145 being ( 0 ) -started (State of ( SCMPDS )) holds ((P3[ B145 ] & F13(B145) = ( 0 )) implies ( B145 . ( DataLoc (( F14() . F17() ) , F18()) ) ) <= ( 0 )))
and
L606: P3[ F14() ]
and
L607: (for B146 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P3[ B146 ] & ( B146 . F17() ) = ( F14() . F17() ) & ( B146 . ( DataLoc (( F14() . F17() ) , F18()) ) ) > ( 0 )) implies (( ( IExec (F16() , R5 , B146) ) . F17() ) = ( B146 . F17() ) & F16() is_closed_on B146 , R5 & F16() is_halting_on B146 , R5 & F13(( Initialize ( IExec (F16() , R5 , B146) ) )) < F13(B146) & P3[ ( Initialize ( IExec (F16() , R5 , B146) ) ) ]))))
proof
set D198 = ( (F17() , F18()) <=0_goto ( ( card F16() ) + 2 ) );
set D199 = ( goto ( - ( ( card F16() ) + 1 ) ) );
set D200 = ( while>0 (F17() , F18() , F16()) );
set D201 = ( stop D200 );
set D202 = ( stop F16() );
set D203 = ( DataLoc (( F14() . F17() ) , F18()) );
defpred S6[ (Element of ( NAT )) ] means (for B147 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((F13(B147) <= $1 & P3[ B147 ] & ( B147 . F17() ) = ( F14() . F17() )) implies (D200 is_closed_on B147 , R5 & D200 is_halting_on B147 , R5))));
L608: (for B148 being (Element of ( NAT )) holds (S6[ B148 ] implies S6[ ( B148 + 1 ) ]))
proof
let C150 being (Element of ( NAT ));
assume L609: S6[ C150 ];
L610:
now
let C151 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume L611: F13(C151) <= ( C150 + 1 );
assume L612: P3[ C151 ];
assume L613: ( C151 . F17() ) = ( F14() . F17() );
per cases ;
suppose L614: ( C151 . D203 ) <= ( 0 );

thus L615: (D200 is_closed_on C151 , R5 & D200 is_halting_on C151 , R5) by L614 , L613 , L533;
end;
suppose L616: ( C151 . D203 ) > ( 0 );

L617: ( 0 ) in ( dom D201 ) by COMPOS_1:36;
L618: D200 = ( D198 ';' ( F16() ';' D199 ) ) by SCMPDS_4:15;
set D204 = C151;
set D205 = ( R5 +* D202 );
set D206 = C151;
set D207 = ( R5 +* D201 );
set D208 = ( Comput (D207 , D206 , 1) );
set D209 = D207;
L619: D202 c= D205 by FUNCT_4:25;
set D210 = ( LifeSpan (D205 , D204) );
set D211 = ( Comput (D209 , D208 , D210) );
set D212 = D209;
set D213 = ( ( card F16() ) + 1 );
L620: ( Initialize C151 ) = C151 by MEMSTR_0:44;
L621: ( IC D206 ) = ( 0 ) by MEMSTR_0:def 11;
set D214 = ( D210 + 1 );
set D215 = ( Comput (D207 , D206 , D214) );
set D216 = D207;
set D217 = ( Comput (D207 , D206 , ( D214 + 1 )) );
set D218 = D207;
L622: ( ( card F16() ) + 1 ) < ( ( card F16() ) + 2 ) by XREAL_1:6;
L623: D213 in ( dom D200 ) by L622 , L525;
L624: D200 c= D201 by AFINSQ_1:74;
L625: D201 c= D207 by FUNCT_4:25;
L626: D200 c= D207 by L625 , L624 , XBOOLE_1:1;
L627: ( Shift (F16() , 1) ) c= D200 by L601;
L628: ( Shift (F16() , 1) ) c= D209 by L627 , L626 , XBOOLE_1:1;
L629: ( Comput (D207 , D206 , ( ( 0 ) + 1 )) ) = ( Following (D207 , ( Comput (D207 , D206 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D207 , D206) )
.= ( Exec (D198 , D206) ) by L618 , L620 , SCMPDS_6:11;
L630: (for R2 being Int_position holds ( D204 . R2 ) = ( D208 . R2 )) by L629 , SCMPDS_2:56;
L631: ( DataPart D204 ) = ( DataPart D208 ) by L630 , SCMPDS_4:8;
L632: F16() is_halting_on C151 , R5 by L607 , L612 , L613 , L616;
L633: D205 halts_on D204 by L632 , L620 , SCMPDS_6:def 3;
L634: ( D205 +* D202 ) halts_on D204 by L633;
L635: F16() is_halting_on D204 , D205 by L634 , L620 , SCMPDS_6:def 3;
L636: ( IExec (F16() , R5 , C151) ) = ( Result (D205 , D204) ) by SCMPDS_4:def 5;
L637: P3[ ( Initialize ( IExec (F16() , R5 , C151) ) ) ] by L607 , L612 , L613 , L616;
L638: F16() is_closed_on C151 , R5 by L607 , L612 , L613 , L616;
L639: F16() is_closed_on D204 , D205 by L607 , L612 , L613 , L616;
L640: ( IC D208 ) = ( succ ( IC D206 ) ) by L616 , L629 , L613 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L621;
L641: ( IC D211 ) = D213 by L640 , L619 , L635 , L639 , L631 , L628 , SCMPDS_7:18;
L642: ( D216 /. ( IC D215 ) ) = ( D216 . ( IC D215 ) ) by PBOOLE:143;
L643: D215 = D211 by EXTPRO_1:4;
L644: ( CurInstr (D216 , D215) ) = ( D209 . D213 ) by L643 , L619 , L635 , L639 , L640 , L631 , L628 , L642 , SCMPDS_7:18
.= ( D200 . D213 ) by L623 , L626 , GRFUNC_1:2
.= D199 by L528;
L645: D217 = ( Following (D207 , D215) ) by EXTPRO_1:3
.= ( Exec (D199 , D215) ) by L644;
L646: ( IC D217 ) = ( ICplusConst (D215 , ( ( 0 ) - ( ( card F16() ) + 1 ) )) ) by L645 , SCMPDS_2:54
.= ( 0 ) by L641 , L643 , SCMPDS_7:1;
L647: ( Initialize D217 ) = D217 by L646 , MEMSTR_0:46;
L648: ( DataPart ( Comput (D205 , D204 , D210) ) ) = ( DataPart D211 ) by L619 , L635 , L639 , L640 , L631 , L628 , SCMPDS_7:18;
L649: ( DataPart D211 ) = ( DataPart ( Result (D205 , D204) ) ) by L648 , L633 , EXTPRO_1:23
.= ( DataPart ( IExec (F16() , R5 , C151) ) ) by SCMPDS_4:def 5;
L650: ( InsCode D199 ) = 14 by SCMPDS_2:12;
L651: ( InsCode D199 ) in { ( 0 ) , 4 , 5 , 6 , 14 } by L650 , ENUMSET1:def 3;
L652: ( Initialize D217 ) = ( Initialize D215 ) by L651 , L645 , L7
.= ( Initialize ( IExec (F16() , R5 , C151) ) ) by L649 , L643 , MEMSTR_0:80;
L653:
now
L654: F13(( Initialize ( IExec (F16() , R5 , C151) ) )) < F13(( Initialize C151 )) by L607 , L612 , L613 , L616 , L620;
L655: F13(( Initialize D217 )) < ( C150 + 1 ) by L654 , L611 , L652 , L620 , XXREAL_0:2;
assume L656: F13(( Initialize D217 )) > C150;
thus L657: contradiction by L656 , L655 , INT_1:7;
end;
L658: ( D211 . F17() ) = ( ( Comput (D205 , D204 , D210) ) . F17() ) by L648 , SCMPDS_4:8
.= ( ( Result (D205 , D204) ) . F17() ) by L633 , EXTPRO_1:23
.= ( F14() . F17() ) by L613 , L607 , L612 , L616 , L636;
L659: ( D217 . F17() ) = ( D215 . F17() ) by L645 , SCMPDS_2:54
.= ( F14() . F17() ) by L658 , EXTPRO_1:4;
L660: D200 is_closed_on D217 , D218 by L659 , L609 , L637 , L652 , L653 , L647;
L661:
now
let C152 being (Element of ( NAT ));
per cases ;
suppose L662: C152 < ( D214 + 1 );

L663: C152 <= D214 by L662 , INT_1:7;
per cases  by L663 , NAT_1:8;
suppose L664: C152 <= D210;

thus L665:now
per cases ;
suppose L666: C152 = ( 0 );

thus L667: ( IC ( Comput (D207 , D206 , C152) ) ) in ( dom D201 ) by L666 , L617 , L621 , EXTPRO_1:2;
end;
suppose L668: C152 <> ( 0 );

consider C153 being Nat such that L669: C152 = ( C153 + 1 ) by L668 , NAT_1:6;
reconsider D219 = C153 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D220 = ( IC ( Comput (D205 , D204 , D219) ) ) as (Element of ( NAT ));
L670: D219 < C152 by L669 , XREAL_1:29;
L671: D219 < D210 by L670 , L664 , XXREAL_0:2;
L672: ( ( IC ( Comput (D205 , D204 , D219) ) ) + 1 ) = ( IC ( Comput (D209 , D208 , D219) ) ) by L671 , L619 , L635 , L639 , L640 , L631 , L628 , SCMPDS_7:16;
L673: ( IC ( Comput (D207 , D206 , C152) ) ) = ( D220 + 1 ) by L672 , L669 , EXTPRO_1:4;
L674: ( IC ( Comput (D205 , D204 , D219) ) ) in ( dom D202 ) by L638 , L620 , SCMPDS_6:def 2;
L675: D220 < ( card D202 ) by L674 , AFINSQ_1:66;
L676: D220 < ( ( card F16() ) + 1 ) by L675 , COMPOS_1:55;
L677: ( D220 + 1 ) <= ( ( card F16() ) + 1 ) by L676 , INT_1:7;
L678: ( ( card F16() ) + 1 ) < ( ( card F16() ) + 3 ) by XREAL_1:6;
L679: ( D220 + 1 ) < ( ( card F16() ) + 3 ) by L678 , L677 , XXREAL_0:2;
L680: ( D220 + 1 ) < ( card D201 ) by L679 , L523;
thus L681: ( IC ( Comput (D207 , D206 , C152) ) ) in ( dom D201 ) by L680 , L673 , AFINSQ_1:66;
end;
end;
end;
suppose L666: C152 = D214;

L667: D213 in ( dom D201 ) by L623 , COMPOS_1:62;
thus L668: ( IC ( Comput (D207 , D206 , C152) ) ) in ( dom D201 ) by L667 , L619 , L635 , L639 , L640 , L631 , L628 , L643 , L666 , SCMPDS_7:18;
end;
end;
suppose L670: C152 >= ( D214 + 1 );

consider C154 being Nat such that L671: C152 = ( ( D214 + 1 ) + C154 ) by L670 , NAT_1:10;
L672: C154 in ( NAT ) by ORDINAL1:def 12;
L673: ( Comput (D207 , D206 , C152) ) = ( Comput (( D218 +* D201 ) , D217 , C154) ) by L671 , L672 , EXTPRO_1:4;
thus L674: ( IC ( Comput (D207 , D206 , C152) ) ) in ( dom D201 ) by L673 , L660 , L672 , L647 , SCMPDS_6:def 2;
end;
end;
thus L676: D200 is_closed_on C151 , R5 by L661 , L620 , SCMPDS_6:def 2;
L677: ( D218 +* D201 ) = D218;
L678: D200 is_halting_on D217 , D218 by L609 , L637 , L659 , L652 , L653 , L647;
L679: D207 halts_on D217 by L678 , L647 , L677 , SCMPDS_6:def 3;
L680: D207 halts_on D206 by L679 , EXTPRO_1:22;
thus L681: D200 is_halting_on C151 , R5 by L680 , L620 , SCMPDS_6:def 3;
end;
end;
thus L683: thesis by L610;
end;
set D221 = F13(F14());
L684: S6[ (( 0 ) qua (Element of ( NAT ))) ]
proof
let C155 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume that
L685: F13(C155) <= ( 0 )
and
L686: P3[ C155 ]
and
L687: ( C155 . F17() ) = ( F14() . F17() );
L688: F13(C155) = ( 0 ) by L685;
L689: ( C155 . D203 ) <= ( 0 ) by L688 , L605 , L686;
thus L690: thesis by L689 , L687 , L533;
end;
L691: (for B149 being (Element of ( NAT )) holds S6[ B149 ]) from NAT_1:sch 1(L684 , L608);
L692: S6[ D221 ] by L691;
thus L693: thesis by L692 , L606;
end;
scheme WhileGExec { F19((State of ( SCMPDS ))) -> (Element of ( NAT )) , F20() -> ( 0 ) -started (State of ( SCMPDS )) , F21() -> (Instruction-Sequence of ( SCMPDS )) , F22() ->  halt-free  shiftable (Program of ( SCMPDS )) , F23() -> Int_position , F24() -> Integer , P4[(State of ( SCMPDS ))] } : ( IExec (( while>0 (F23() , F24() , F22()) ) , F21() , F20()) ) = ( IExec (( while>0 (F23() , F24() , F22()) ) , F21() , ( Initialize ( IExec (F22() , F21() , F20()) ) )) )
provided
L694: ( F20() . ( DataLoc (( F20() . F23() ) , F24()) ) ) > ( 0 )
and
L695: (for B150 being ( 0 ) -started (State of ( SCMPDS )) holds ((P4[ B150 ] & F19(B150) = ( 0 )) implies ( B150 . ( DataLoc (( F20() . F23() ) , F24()) ) ) <= ( 0 )))
and
L696: P4[ F20() ]
and
L697: (for B151 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P4[ B151 ] & ( B151 . F23() ) = ( F20() . F23() ) & ( B151 . ( DataLoc (( F20() . F23() ) , F24()) ) ) > ( 0 )) implies (( ( IExec (F22() , R5 , B151) ) . F23() ) = ( B151 . F23() ) & F22() is_closed_on B151 , R5 & F22() is_halting_on B151 , R5 & F19(( Initialize ( IExec (F22() , R5 , B151) ) )) < F19(B151) & P4[ ( Initialize ( IExec (F22() , R5 , B151) ) ) ]))))
proof
set D222 = ( while>0 (F23() , F24() , F22()) );
set D223 = ( stop D222 );
set D224 = ( F21() +* D223 );
set D225 = ( F21() +* ( stop F22() ) );
set D226 = ( ( LifeSpan (D225 , F20()) ) + 2 );
set D227 = ( Initialize ( IExec (F22() , F21() , F20()) ) );
set D228 = ( F21() +* D223 );
set D229 = ( LifeSpan (D228 , D227) );
L698: ( Initialize F20() ) = F20() by MEMSTR_0:44;
L699: P4[ F20() ] by L696;
L700: ( stop F22() ) c= D225 by FUNCT_4:25;
L701: F22() is_closed_on F20() , D225 by L694 , L696 , L697;
L702: F22() is_halting_on F20() , F21() by L694 , L696 , L697;
L703: D225 halts_on F20() by L702 , L698 , SCMPDS_6:def 3;
L704: ( D225 +* ( stop F22() ) ) halts_on F20() by L703;
L705: F22() is_halting_on F20() , D225 by L704 , L698 , SCMPDS_6:def 3;
set D230 = ( IExec (F22() , F21() , F20()) );
set D231 = ( DataLoc (( ( Initialize D230 ) . F23() ) , F24()) );
set D232 = F21();
deffunc H2((State of ( SCMPDS ))) = F19($1);
L706: (for B152 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P4[ B152 ] & ( B152 . F23() ) = ( F20() . F23() ) & ( B152 . ( DataLoc (( F20() . F23() ) , F24()) ) ) > ( 0 )) implies (( ( IExec (F22() , R5 , B152) ) . F23() ) = ( B152 . F23() ) & F22() is_closed_on B152 , R5 & F22() is_halting_on B152 , R5 & H2(( Initialize ( IExec (F22() , R5 , B152) ) )) < H2(B152) & P4[ ( Initialize ( IExec (F22() , R5 , B152) ) ) ])))) by L697;
L707: (for B153 being ( 0 ) -started (State of ( SCMPDS )) holds ((P4[ B153 ] & H2(B153) = ( 0 )) implies ( B153 . ( DataLoc (( F20() . F23() ) , F24()) ) ) <= ( 0 ))) by L695;
L708: (D222 is_closed_on F20() , F21() & D222 is_halting_on F20() , F21()) from WhileGHalt(L707 , L699 , L706);
L709: D224 halts_on F20() by L708 , L698 , SCMPDS_6:def 3;
deffunc H3((State of ( SCMPDS ))) = F19($1);
L710: ( ( Initialize ( IExec (F22() , F21() , F20()) ) ) . F23() ) = ( ( IExec (F22() , F21() , F20()) ) . F23() ) by SCMPDS_5:15
.= ( F20() . F23() ) by L694 , L696 , L697;
L711: (for B154 being ( 0 ) -started (State of ( SCMPDS )) holds ((P4[ B154 ] & H3(B154) = ( 0 )) implies ( B154 . D231 ) <= ( 0 ))) by L710 , L695;
L712: (for B155 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((P4[ B155 ] & ( B155 . F23() ) = ( ( Initialize D230 ) . F23() ) & ( B155 . D231 ) > ( 0 )) implies (( ( IExec (F22() , R5 , B155) ) . F23() ) = ( B155 . F23() ) & F22() is_closed_on B155 , R5 & F22() is_halting_on B155 , R5 & H3(( Initialize ( IExec (F22() , R5 , B155) ) )) < H3(B155) & P4[ ( Initialize ( IExec (F22() , R5 , B155) ) ) ])))) by L697 , L710;
L713: P4[ ( Initialize D230 ) ] by L694 , L696 , L697;
L714: (D222 is_closed_on ( Initialize D230 ) , D232 & D222 is_halting_on ( Initialize D230 ) , D232) from WhileGHalt(L711 , L713 , L712);
L715: D228 halts_on ( Initialize D227 ) by L714 , SCMPDS_6:def 3;
set D233 = ( Comput (D224 , F20() , 1) );
set D234 = D224;
set D235 = ( (F23() , F24()) <=0_goto ( ( card F22() ) + 2 ) );
set D236 = ( goto ( - ( ( card F22() ) + 1 ) ) );
set D237 = ( DataLoc (( F20() . F23() ) , F24()) );
L716: D222 = ( D235 ';' ( F22() ';' D236 ) ) by SCMPDS_4:15;
set D238 = ( LifeSpan (D225 , F20()) );
set D239 = ( Comput (D234 , D233 , D238) );
set D240 = D234;
set D241 = ( ( card F22() ) + 1 );
L717: ( IC F20() ) = ( 0 ) by MEMSTR_0:def 11;
L718: ( Comput (D224 , F20() , ( ( 0 ) + 1 )) ) = ( Following (D224 , ( Comput (D224 , F20() , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D224 , F20()) )
.= ( Exec (D235 , F20()) ) by L716 , L698 , SCMPDS_6:11;
L719: (for R2 being Int_position holds ( F20() . R2 ) = ( D233 . R2 )) by L718 , SCMPDS_2:56;
L720: ( DataPart F20() ) = ( DataPart D233 ) by L719 , SCMPDS_4:8;
set D242 = ( D238 + 1 );
set D243 = ( Comput (D224 , F20() , D242) );
set D244 = D224;
L721: ( ( card F22() ) + 1 ) < ( ( card F22() ) + 2 ) by XREAL_1:6;
L722: D241 in ( dom D222 ) by L721 , L525;
set D245 = ( LifeSpan (D224 , F20()) );
set D246 = ( Comput (D224 , F20() , ( D242 + 1 )) );
L723: D222 c= D223 by AFINSQ_1:74;
L724: D223 c= D224 by FUNCT_4:25;
L725: D222 c= D224 by L724 , L723 , XBOOLE_1:1;
L726: ( Shift (F22() , 1) ) c= D222 by L601;
L727: ( Shift (F22() , 1) ) c= D234 by L726 , L725 , XBOOLE_1:1;
L728: ( IC D233 ) = ( succ ( IC F20() ) ) by L694 , L718 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L717;
L729: ( IC D239 ) = D241 by L728 , L700 , L705 , L701 , L720 , L727 , SCMPDS_7:18;
L730: ( D244 /. ( IC D243 ) ) = ( D244 . ( IC D243 ) ) by PBOOLE:143;
L731: D243 = D239 by EXTPRO_1:4;
L732: ( CurInstr (D244 , D243) ) = ( D234 . D241 ) by L731 , L700 , L705 , L701 , L728 , L720 , L727 , L730 , SCMPDS_7:18
.= ( D222 . D241 ) by L722 , L725 , GRFUNC_1:2
.= D236 by L528;
L733: D246 = ( Following (D224 , D243) ) by EXTPRO_1:3
.= ( Exec (D236 , D243) ) by L732;
L734: ( IC D246 ) = ( ICplusConst (D243 , ( ( 0 ) - ( ( card F22() ) + 1 ) )) ) by L733 , SCMPDS_2:54
.= ( 0 ) by L729 , L731 , SCMPDS_7:1;
L735: ( IC D227 ) = ( IC ( Comput (D224 , F20() , D226) ) ) by L734 , MEMSTR_0:def 11;
L736: ( DataPart ( Comput (D225 , F20() , D238) ) ) = ( DataPart D239 ) by L700 , L705 , L701 , L728 , L720 , L727 , SCMPDS_7:18;
L737:
now
let C156 being Int_position;
L738: (not C156 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L739: ( D239 . C156 ) = ( ( Comput (D225 , F20() , D238) ) . C156 ) by L736 , SCMPDS_4:8
.= ( ( Result (D225 , F20()) ) . C156 ) by L703 , EXTPRO_1:23
.= ( ( IExec (F22() , F21() , F20()) ) . C156 ) by SCMPDS_4:def 5;
thus L740: ( D246 . C156 ) = ( ( IExec (F22() , F21() , F20()) ) . C156 ) by L739 , L731 , L733 , SCMPDS_2:54
.= ( D227 . C156 ) by L738 , FUNCT_4:11;
end;
L741: ( DataPart D246 ) = ( DataPart D227 ) by L737 , SCMPDS_4:8;
L742: ( Comput (D224 , F20() , D226) ) = D227 by L741 , L735 , MEMSTR_0:78;
L743: ( CurInstr (D224 , ( Comput (D224 , F20() , D226) )) ) = D235 by L742 , L716 , SCMPDS_6:11;
L744: D245 > D226 by L743 , L709 , EXTPRO_1:36 , SCMPDS_6:17;
consider C157 being Nat such that L745: D245 = ( D226 + C157 ) by L744 , NAT_1:10;
reconsider D247 = C157 as (Element of ( NAT )) by ORDINAL1:def 12;
L746: ( Comput (D224 , F20() , ( D226 + D229 )) ) = ( Comput (D224 , D227 , D229) ) by L742 , EXTPRO_1:4;
L747: ( CurInstr (D224 , ( Comput (D224 , F20() , ( D226 + D229 )) )) ) = ( halt ( SCMPDS ) ) by L746 , L715 , EXTPRO_1:def 15;
L748: ( D226 + D229 ) >= D245 by L747 , L709 , EXTPRO_1:def 15;
L749: D229 >= D247 by L748 , L745 , XREAL_1:6;
L750: ( Comput (D224 , F20() , D245) ) = ( Comput (D224 , D227 , D247) ) by L742 , L745 , EXTPRO_1:4;
L751: ( CurInstr (D228 , ( Comput (D228 , D227 , D247) )) ) = ( halt ( SCMPDS ) ) by L750 , L709 , EXTPRO_1:def 15;
L752: D247 >= D229 by L751 , L715 , EXTPRO_1:def 15;
L753: D247 = D229 by L752 , L749 , XXREAL_0:1;
L754: ( Result (D224 , F20()) ) = ( Comput (D228 , D227 , D229) ) by L753 , L709 , L750 , EXTPRO_1:23;
thus L755: ( IExec (D222 , F21() , F20()) ) = ( Comput (D228 , D227 , D229) ) by L754 , SCMPDS_4:def 5
.= ( Result (D228 , D227) ) by L715 , EXTPRO_1:23
.= ( IExec (D222 , F21() , ( Initialize ( IExec (F22() , F21() , F20()) ) )) ) by SCMPDS_4:def 5;
end;
theorem
L756: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B156 being ( 0 ) -started (State of ( SCMPDS )) holds (for B157 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B158 being Int_position holds (for B159 , B160 being Integer holds (for B161 , B162 being set holds (for B163 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) holds (((for B164 being ( 0 ) -started (State of ( SCMPDS )) holds (( B163 . B164 ) = ( 0 ) implies ( B164 . ( DataLoc (( B156 . B158 ) , B159) ) ) <= ( 0 ))) & (for R1 being Int_position holds (R1 in B161 implies ( B156 . R1 ) >= ( B160 + ( B156 . ( DataLoc (( B156 . B158 ) , B159) ) ) ))) & (for B165 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in B161 implies ( B165 . R1 ) >= ( B160 + ( B165 . ( DataLoc (( B156 . B158 ) , B159) ) ) ))) & (for R1 being Int_position holds (R1 in B162 implies ( B165 . R1 ) = ( B156 . R1 ))) & ( B165 . B158 ) = ( B156 . B158 ) & ( B165 . ( DataLoc (( B156 . B158 ) , B159) ) ) > ( 0 )) implies (( ( IExec (B157 , R5 , B165) ) . B158 ) = ( B165 . B158 ) & B157 is_closed_on B165 , R5 & B157 is_halting_on B165 , R5 & ( B163 . ( Initialize ( IExec (B157 , R5 , B165) ) ) ) < ( B163 . B165 ) & (for R1 being Int_position holds (R1 in B161 implies ( ( IExec (B157 , R5 , B165) ) . R1 ) >= ( B160 + ( ( IExec (B157 , R5 , B165) ) . ( DataLoc (( B156 . B158 ) , B159) ) ) ))) & (for R1 being Int_position holds (R1 in B162 implies ( ( IExec (B157 , R5 , B165) ) . R1 ) = ( B165 . R1 )))))))) implies (( while>0 (B158 , B159 , B157) ) is_closed_on B156 , R4 & ( while>0 (B158 , B159 , B157) ) is_halting_on B156 , R4)))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C158 being ( 0 ) -started (State of ( SCMPDS ));
let C159 being  halt-free  shiftable (Program of ( SCMPDS ));
let C160 being Int_position;
let C161 , C162 being Integer;
let C163 , C164 being set;
let C165 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT ));
set D248 = ( DataLoc (( C158 . C160 ) , C161) );
set D249 = ( while>0 (C160 , C161 , C159) );
set D250 = ( stop D249 );
set D251 = ( stop C159 );
set D252 = ( (C160 , C161) <=0_goto ( ( card C159 ) + 2 ) );
set D253 = ( goto ( - ( ( card C159 ) + 1 ) ) );
defpred S7[ (Element of ( NAT )) ] means (for B166 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds ((( C165 . B166 ) <= $1 & (for R1 being Int_position holds (R1 in C163 implies ( B166 . R1 ) >= ( C162 + ( B166 . D248 ) ))) & (for R1 being Int_position holds (R1 in C164 implies ( B166 . R1 ) = ( C158 . R1 ))) & ( B166 . C160 ) = ( C158 . C160 )) implies (D249 is_closed_on B166 , R5 & D249 is_halting_on B166 , R5))));
assume L757: (for B167 being ( 0 ) -started (State of ( SCMPDS )) holds (( C165 . B167 ) = ( 0 ) implies ( B167 . D248 ) <= ( 0 )));
assume L758: (for R1 being Int_position holds (R1 in C163 implies ( C158 . R1 ) >= ( C162 + ( C158 . D248 ) )));
assume L759: (for B168 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C163 implies ( B168 . R1 ) >= ( C162 + ( B168 . D248 ) ))) & (for R1 being Int_position holds (R1 in C164 implies ( B168 . R1 ) = ( C158 . R1 ))) & ( B168 . C160 ) = ( C158 . C160 ) & ( B168 . D248 ) > ( 0 )) implies (( ( IExec (C159 , R5 , B168) ) . C160 ) = ( B168 . C160 ) & C159 is_closed_on B168 , R5 & C159 is_halting_on B168 , R5 & ( C165 . ( Initialize ( IExec (C159 , R5 , B168) ) ) ) < ( C165 . B168 ) & (for R1 being Int_position holds (R1 in C163 implies ( ( IExec (C159 , R5 , B168) ) . R1 ) >= ( C162 + ( ( IExec (C159 , R5 , B168) ) . D248 ) ))) & (for R1 being Int_position holds (R1 in C164 implies ( ( IExec (C159 , R5 , B168) ) . R1 ) = ( B168 . R1 )))))));
L760: (for B169 being (Element of ( NAT )) holds (S7[ B169 ] implies S7[ ( B169 + 1 ) ]))
proof
let C166 being (Element of ( NAT ));
assume L761: S7[ C166 ];
L762:
now
let C167 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
L763: ( Initialize C167 ) = C167 by MEMSTR_0:44;
assume L764: ( C165 . C167 ) <= ( C166 + 1 );
assume L765: (for R1 being Int_position holds (R1 in C163 implies ( C167 . R1 ) >= ( C162 + ( C167 . D248 ) )));
assume L766: (for R1 being Int_position holds (R1 in C164 implies ( C167 . R1 ) = ( C158 . R1 )));
assume L767: ( C167 . C160 ) = ( C158 . C160 );
per cases ;
suppose L768: ( C167 . D248 ) <= ( 0 );

thus L769: (D249 is_closed_on C167 , R5 & D249 is_halting_on C167 , R5) by L768 , L767 , L533;
end;
suppose L770: ( C167 . D248 ) > ( 0 );

L771: ( 0 ) in ( dom D250 ) by COMPOS_1:36;
L772: D249 = ( D252 ';' ( C159 ';' D253 ) ) by SCMPDS_4:15;
set D254 = ( R5 +* D251 );
set D255 = ( R5 +* D250 );
set D256 = ( Comput (D255 , C167 , 1) );
set D257 = D255;
L773: D251 c= D254 by FUNCT_4:25;
L774: ( Comput (D255 , C167 , ( ( 0 ) + 1 )) ) = ( Following (D255 , ( Comput (D255 , C167 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D255 , C167) )
.= ( Exec (D252 , C167) ) by L772 , L763 , SCMPDS_6:11;
L775: (for R2 being Int_position holds ( C167 . R2 ) = ( D256 . R2 )) by L774 , SCMPDS_2:56;
L776: ( DataPart C167 ) = ( DataPart D256 ) by L775 , SCMPDS_4:8;
L777: D249 c= D250 by AFINSQ_1:74;
L778: D250 c= D255 by FUNCT_4:25;
L779: D249 c= D255 by L778 , L777 , XBOOLE_1:1;
L780: ( Shift (C159 , 1) ) c= D249 by L601;
L781: ( Shift (C159 , 1) ) c= D257 by L780 , L779 , XBOOLE_1:1;
L782: ( IExec (C159 , R5 , C167) ) = ( Result (D254 , C167) ) by SCMPDS_4:def 5;
set D258 = ( LifeSpan (D254 , C167) );
set D259 = ( Comput (D257 , D256 , D258) );
set D260 = D257;
set D261 = ( ( card C159 ) + 1 );
L783: ( IC C167 ) = ( 0 ) by MEMSTR_0:def 11;
set D262 = ( D258 + 1 );
set D263 = ( Comput (D255 , C167 , D262) );
set D264 = D255;
set D265 = ( Comput (D255 , C167 , ( D262 + 1 )) );
set D266 = D255;
L784: ( ( card C159 ) + 1 ) < ( ( card C159 ) + 2 ) by XREAL_1:6;
L785: D261 in ( dom D249 ) by L784 , L525;
L786: C159 is_closed_on C167 , R5 by L759 , L765 , L766 , L767 , L770;
L787: C159 is_closed_on C167 , D254 by L759 , L765 , L766 , L767 , L770;
L788: C159 is_halting_on C167 , R5 by L759 , L765 , L766 , L767 , L770;
L789: D254 halts_on C167 by L788 , L763 , SCMPDS_6:def 3;
L790: ( D254 +* D251 ) halts_on C167 by L789;
L791: C159 is_halting_on C167 , D254 by L790 , L763 , SCMPDS_6:def 3;
L792: ( IC D256 ) = ( succ ( IC C167 ) ) by L770 , L774 , L767 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L783;
L793: ( IC D259 ) = D261 by L792 , L773 , L791 , L787 , L776 , L781 , SCMPDS_7:18;
L794: ( D264 /. ( IC D263 ) ) = ( D264 . ( IC D263 ) ) by PBOOLE:143;
L795: D263 = D259 by EXTPRO_1:4;
L796: ( CurInstr (D264 , D263) ) = ( D257 . D261 ) by L795 , L773 , L791 , L787 , L792 , L776 , L781 , L794 , SCMPDS_7:18
.= ( D249 . D261 ) by L785 , L779 , GRFUNC_1:2
.= D253 by L528;
L797: D265 = ( Following (D255 , D263) ) by EXTPRO_1:3
.= ( Exec (D253 , D263) ) by L796;
L798: ( IC D265 ) = ( ICplusConst (D263 , ( ( 0 ) - ( ( card C159 ) + 1 ) )) ) by L797 , SCMPDS_2:54
.= ( 0 ) by L793 , L795 , SCMPDS_7:1;
L799: ( Initialize D265 ) = D265 by L798 , MEMSTR_0:46;
L800: ( DataPart ( Comput (D254 , C167 , D258) ) ) = ( DataPart D259 ) by L773 , L791 , L787 , L792 , L776 , L781 , SCMPDS_7:18;
L801: ( DataPart D259 ) = ( DataPart ( Result (D254 , C167) ) ) by L800 , L789 , EXTPRO_1:23
.= ( DataPart ( IExec (C159 , R5 , C167) ) ) by SCMPDS_4:def 5;
L802:
now
let C168 being Int_position;
assume L803: C168 in C164;
thus L804: ( D265 . C168 ) = ( D259 . C168 ) by L795 , L797 , SCMPDS_2:54
.= ( ( IExec (C159 , R5 , C167) ) . C168 ) by L801 , SCMPDS_3:3
.= ( C167 . C168 ) by L759 , L765 , L766 , L767 , L770 , L803
.= ( C158 . C168 ) by L766 , L803;
end;
L805: ( InsCode D253 ) = 14 by SCMPDS_2:12;
L806: ( InsCode D253 ) in { ( 0 ) , 4 , 5 , 6 , 14 } by L805 , ENUMSET1:def 3;
L807: ( Initialize D265 ) = ( Initialize D263 ) by L806 , L797 , L7
.= ( Initialize ( IExec (C159 , R5 , C167) ) ) by L801 , L795 , MEMSTR_0:80;
L808:
now
L809: ( C165 . ( Initialize ( IExec (C159 , R5 , C167) ) ) ) < ( C165 . ( Initialize C167 ) ) by L759 , L765 , L766 , L767 , L770 , L763;
L810: ( C165 . D265 ) < ( C166 + 1 ) by L809 , L764 , L807 , L799 , L763 , XXREAL_0:2;
assume L811: ( C165 . ( Initialize D265 ) ) > C166;
thus L812: contradiction by L811 , L810 , L799 , INT_1:7;
end;
L813: ( D265 . D248 ) = ( D259 . D248 ) by L795 , L797 , SCMPDS_2:54
.= ( ( IExec (C159 , R5 , C167) ) . D248 ) by L801 , SCMPDS_3:3;
L814:
now
let C169 being Int_position;
assume L815: C169 in C163;
L816: ( D265 . C169 ) = ( D259 . C169 ) by L795 , L797 , SCMPDS_2:54
.= ( ( IExec (C159 , R5 , C167) ) . C169 ) by L801 , SCMPDS_3:3;
thus L817: ( D265 . C169 ) >= ( C162 + ( D265 . D248 ) ) by L816 , L759 , L765 , L766 , L767 , L770 , L813 , L815;
end;
L818: ( D259 . C160 ) = ( ( Comput (D254 , C167 , D258) ) . C160 ) by L800 , SCMPDS_4:8
.= ( ( Result (D254 , C167) ) . C160 ) by L789 , EXTPRO_1:23
.= ( C158 . C160 ) by L767 , L759 , L765 , L766 , L770 , L782;
L819: ( D265 . C160 ) = ( D263 . C160 ) by L797 , SCMPDS_2:54
.= ( C158 . C160 ) by L818 , EXTPRO_1:4;
L820: D249 is_closed_on D265 , D266 by L819 , L761 , L814 , L802 , L808 , L799;
L821:
now
let C170 being (Element of ( NAT ));
per cases ;
suppose L822: C170 < ( D262 + 1 );

L823: C170 <= D262 by L822 , INT_1:7;
thus L824:now
per cases  by L823 , NAT_1:8;
suppose L825: C170 <= D258;

thus L826:now
per cases ;
suppose L827: C170 = ( 0 );

thus L828: ( IC ( Comput (D255 , C167 , C170) ) ) in ( dom D250 ) by L827 , L771 , L783 , EXTPRO_1:2;
end;
suppose L829: C170 <> ( 0 );

consider C171 being Nat such that L830: C170 = ( C171 + 1 ) by L829 , NAT_1:6;
reconsider D267 = C171 as (Element of ( NAT )) by ORDINAL1:def 12;
reconsider D268 = ( IC ( Comput (D254 , C167 , D267) ) ) as (Element of ( NAT ));
L831: D267 < C170 by L830 , XREAL_1:29;
L832: D267 < D258 by L831 , L825 , XXREAL_0:2;
L833: ( ( IC ( Comput (D254 , C167 , D267) ) ) + 1 ) = ( IC ( Comput (D257 , D256 , D267) ) ) by L832 , L773 , L791 , L787 , L792 , L776 , L781 , SCMPDS_7:16;
L834: ( IC ( Comput (D255 , C167 , C170) ) ) = ( D268 + 1 ) by L833 , L830 , EXTPRO_1:4;
L835: ( IC ( Comput (D254 , C167 , D267) ) ) in ( dom D251 ) by L786 , L763 , SCMPDS_6:def 2;
L836: D268 < ( card D251 ) by L835 , AFINSQ_1:66;
L837: D268 < ( ( card C159 ) + 1 ) by L836 , COMPOS_1:55;
L838: ( D268 + 1 ) <= ( ( card C159 ) + 1 ) by L837 , INT_1:7;
L839: ( ( card C159 ) + 1 ) < ( ( card C159 ) + 3 ) by XREAL_1:6;
L840: ( D268 + 1 ) < ( ( card C159 ) + 3 ) by L839 , L838 , XXREAL_0:2;
L841: ( D268 + 1 ) < ( card D250 ) by L840 , L523;
thus L842: ( IC ( Comput (D255 , C167 , C170) ) ) in ( dom D250 ) by L841 , L834 , AFINSQ_1:66;
end;
end;
end;
suppose L827: C170 = D262;

L828: D261 in ( dom D250 ) by L785 , COMPOS_1:62;
thus L829: ( IC ( Comput (D255 , C167 , C170) ) ) in ( dom D250 ) by L828 , L773 , L791 , L787 , L792 , L776 , L781 , L795 , L827 , SCMPDS_7:18;
end;
end;
end;
suppose L825: C170 >= ( D262 + 1 );

consider C172 being Nat such that L826: C170 = ( ( D262 + 1 ) + C172 ) by L825 , NAT_1:10;
L827: C172 in ( NAT ) by ORDINAL1:def 12;
L828: ( Comput (D255 , C167 , C170) ) = ( Comput (( D266 +* D250 ) , D265 , C172) ) by L826 , L827 , EXTPRO_1:4;
thus L829: ( IC ( Comput (D255 , C167 , C170) ) ) in ( dom D250 ) by L828 , L820 , L827 , L799 , SCMPDS_6:def 2;
end;
end;
thus L831: D249 is_closed_on C167 , R5 by L821 , L763 , SCMPDS_6:def 2;
L832: ( D266 +* D250 ) = D266;
L833: D249 is_halting_on D265 , D266 by L761 , L819 , L814 , L802 , L808 , L799;
L834: D255 halts_on D265 by L833 , L799 , L832 , SCMPDS_6:def 3;
L835: D255 halts_on C167 by L834 , EXTPRO_1:22;
thus L836: D249 is_halting_on C167 , R5 by L835 , L763 , SCMPDS_6:def 3;
end;
end;
thus L838: thesis by L762;
end;
set D269 = ( C165 . C158 );
L839: (for R1 being Int_position holds (R1 in C164 implies ( C158 . R1 ) = ( C158 . R1 )));
L840: S7[ ( 0 ) ]
proof
let C173 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume L841: ( C165 . C173 ) <= ( 0 );
L842: ( C165 . C173 ) = ( 0 ) by L841;
L843: ( C173 . D248 ) <= ( 0 ) by L842 , L757;
assume L844: (for B170 being Int_position holds (B170 in C163 implies ( C173 . B170 ) >= ( C162 + ( C173 . D248 ) )));
assume L845: (for R1 being Int_position holds (R1 in C164 implies ( C173 . R1 ) = ( C158 . R1 )));
assume L846: ( C173 . C160 ) = ( C158 . C160 );
thus L847: thesis by L846 , L843 , L533;
end;
L848: (for B171 being (Element of ( NAT )) holds S7[ B171 ]) from NAT_1:sch 1(L840 , L760);
L849: S7[ D269 ] by L848;
thus L850: thesis by L849 , L758 , L839;
end;
theorem
L851: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B172 being ( 0 ) -started (State of ( SCMPDS )) holds (for B173 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B174 being Int_position holds (for B175 , B176 being Integer holds (for B177 , B178 being set holds (for B179 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) holds ((( B172 . ( DataLoc (( B172 . B174 ) , B175) ) ) > ( 0 ) & (for B180 being ( 0 ) -started (State of ( SCMPDS )) holds (( B179 . B180 ) = ( 0 ) implies ( B180 . ( DataLoc (( B172 . B174 ) , B175) ) ) <= ( 0 ))) & (for R1 being Int_position holds (R1 in B177 implies ( B172 . R1 ) >= ( B176 + ( B172 . ( DataLoc (( B172 . B174 ) , B175) ) ) ))) & (for B181 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in B177 implies ( B181 . R1 ) >= ( B176 + ( B181 . ( DataLoc (( B172 . B174 ) , B175) ) ) ))) & (for R1 being Int_position holds (R1 in B178 implies ( B181 . R1 ) = ( B172 . R1 ))) & ( B181 . B174 ) = ( B172 . B174 ) & ( B181 . ( DataLoc (( B172 . B174 ) , B175) ) ) > ( 0 )) implies (( ( IExec (B173 , R5 , B181) ) . B174 ) = ( B181 . B174 ) & B173 is_closed_on B181 , R5 & B173 is_halting_on B181 , R5 & ( B179 . ( Initialize ( IExec (B173 , R5 , B181) ) ) ) < ( B179 . B181 ) & (for R1 being Int_position holds (R1 in B177 implies ( ( IExec (B173 , R5 , B181) ) . R1 ) >= ( B176 + ( ( IExec (B173 , R5 , B181) ) . ( DataLoc (( B172 . B174 ) , B175) ) ) ))) & (for R1 being Int_position holds (R1 in B178 implies ( ( IExec (B173 , R5 , B181) ) . R1 ) = ( B181 . R1 )))))))) implies ( IExec (( while>0 (B174 , B175 , B173) ) , R4 , B172) ) = ( IExec (( while>0 (B174 , B175 , B173) ) , R4 , ( Initialize ( IExec (B173 , R4 , B172) ) )) )))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C174 being ( 0 ) -started (State of ( SCMPDS ));
let C175 being  halt-free  shiftable (Program of ( SCMPDS ));
let C176 being Int_position;
let C177 , C178 being Integer;
let C179 , C180 being set;
let C181 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT ));
L852: ( Initialize C174 ) = C174 by MEMSTR_0:44;
set D270 = ( DataLoc (( C174 . C176 ) , C177) );
set D271 = ( while>0 (C176 , C177 , C175) );
set D272 = ( stop D271 );
set D273 = ( R4 +* D272 );
set D274 = ( (C176 , C177) <=0_goto ( ( card C175 ) + 2 ) );
set D275 = ( goto ( - ( ( card C175 ) + 1 ) ) );
assume L853: ( C174 . D270 ) > ( 0 );
set D276 = ( Comput (D273 , C174 , 1) );
set D277 = D273;
L854: ( IC C174 ) = ( 0 ) by MEMSTR_0:def 11;
L855: D271 = ( D274 ';' ( C175 ';' D275 ) ) by SCMPDS_4:15;
L856: ( Comput (D273 , C174 , ( ( 0 ) + 1 )) ) = ( Following (D273 , ( Comput (D273 , C174 , ( 0 )) )) ) by EXTPRO_1:3
.= ( Following (D273 , C174) )
.= ( Exec (D274 , C174) ) by L855 , L852 , SCMPDS_6:11;
set D278 = ( LifeSpan (D273 , C174) );
set D279 = ( IExec (C175 , R4 , C174) );
set D280 = ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) );
set D281 = R4;
assume L857: (for B182 being ( 0 ) -started (State of ( SCMPDS )) holds (( C181 . B182 ) = ( 0 ) implies ( B182 . D270 ) <= ( 0 )));
assume L858: (for R1 being Int_position holds (R1 in C179 implies ( C174 . R1 ) >= ( C178 + ( C174 . D270 ) )));
assume L859: (for B183 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C179 implies ( B183 . R1 ) >= ( C178 + ( B183 . D270 ) ))) & (for R1 being Int_position holds (R1 in C180 implies ( B183 . R1 ) = ( C174 . R1 ))) & ( B183 . C176 ) = ( C174 . C176 ) & ( B183 . D270 ) > ( 0 )) implies (( ( IExec (C175 , R5 , B183) ) . C176 ) = ( B183 . C176 ) & C175 is_closed_on B183 , R5 & C175 is_halting_on B183 , R5 & ( C181 . ( Initialize ( IExec (C175 , R5 , B183) ) ) ) < ( C181 . B183 ) & (for R1 being Int_position holds (R1 in C179 implies ( ( IExec (C175 , R5 , B183) ) . R1 ) >= ( C178 + ( ( IExec (C175 , R5 , B183) ) . D270 ) ))) & (for R1 being Int_position holds (R1 in C180 implies ( ( IExec (C175 , R5 , B183) ) . R1 ) = ( B183 . R1 )))))));
L860: D271 is_halting_on C174 , R4 by L859 , L857 , L858 , L756;
L861: D273 halts_on C174 by L860 , L852 , SCMPDS_6:def 3;
L862: (for R1 being Int_position holds (R1 in C180 implies ( C174 . R1 ) = ( C174 . R1 )));
L863: D280 = ( DataLoc (( D279 . C176 ) , C177) ) by SCMPDS_5:15
.= D270 by L853 , L858 , L859 , L862;
set D282 = ( R4 +* ( stop C175 ) );
set D283 = ( ( LifeSpan (D282 , C174) ) + 2 );
set D284 = ( Initialize ( IExec (C175 , R4 , C174) ) );
set D285 = ( R4 +* D272 );
set D286 = ( LifeSpan (D285 , D284) );
L864: ( stop C175 ) c= D282 by FUNCT_4:25;
L865: ( ( Initialize ( IExec (C175 , R4 , C174) ) ) . C176 ) = ( ( IExec (C175 , R4 , C174) ) . C176 ) by SCMPDS_5:15
.= ( C174 . C176 ) by L853 , L858 , L859 , L862;
L866:
now
let C182 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume that
L867: (for R1 being Int_position holds (R1 in C179 implies ( C182 . R1 ) >= ( C178 + ( C182 . D280 ) )))
and
L868: (for R1 being Int_position holds (R1 in C180 implies ( C182 . R1 ) = ( ( Initialize D279 ) . R1 )))
and
L869: ( C182 . C176 ) = ( ( Initialize D279 ) . C176 )
and
L870: ( C182 . D280 ) > ( 0 );
L871:
now
let R1 being Int_position;
assume L872: R1 in C180;
thus L873: ( C182 . R1 ) = ( ( Initialize D279 ) . R1 ) by L872 , L868
.= ( D279 . R1 ) by SCMPDS_5:15
.= ( C174 . R1 ) by L853 , L858 , L859 , L862 , L872;
end;
thus L874: ( ( Initialize ( IExec (C175 , R5 , C182) ) ) . C176 ) = ( ( IExec (C175 , R5 , C182) ) . C176 ) by SCMPDS_5:15
.= ( C182 . C176 ) by L859 , L865 , L867 , L869 , L870 , L871;
L875: ( C182 . C176 ) = ( D279 . C176 ) by L869 , SCMPDS_5:15
.= ( C174 . C176 ) by L853 , L858 , L859 , L862;
thus L876: (C175 is_closed_on C182 , R5 & C175 is_halting_on C182 , R5) by L875 , L859 , L867 , L869 , L870 , L871;
thus L877: ( C181 . ( Initialize ( IExec (C175 , R5 , C182) ) ) ) < ( C181 . C182 ) by L859 , L867 , L869 , L870 , L871 , L875;
thus L878: (for R1 being Int_position holds (R1 in C179 implies ( ( Initialize ( IExec (C175 , R5 , C182) ) ) . R1 ) >= ( C178 + ( ( Initialize ( IExec (C175 , R5 , C182) ) ) . D280 ) )))
proof
let R1 being Int_position;
L879: (( ( Initialize ( IExec (C175 , R5 , C182) ) ) . R1 ) = ( ( IExec (C175 , R5 , C182) ) . R1 ) & ( ( Initialize ( IExec (C175 , R5 , C182) ) ) . D280 ) = ( ( IExec (C175 , R5 , C182) ) . D280 )) by SCMPDS_5:15;
thus L880: thesis by L879 , L859 , L865 , L867 , L869 , L870 , L871;
end;

thus L881: (for R1 being Int_position holds (R1 in C180 implies ( ( IExec (C175 , R5 , C182) ) . R1 ) = ( C182 . R1 ))) by L859 , L867 , L869 , L870 , L871 , L875;
end;
L882: (for R1 being Int_position holds (R1 in C179 implies ( ( Initialize D279 ) . R1 ) >= ( C178 + ( ( Initialize D279 ) . D280 ) )))
proof
let R1 being Int_position;
L883: ( ( Initialize D279 ) . R1 ) = ( D279 . R1 ) by SCMPDS_5:15;
L884: ( ( Initialize D279 ) . D280 ) = ( D279 . D280 ) by SCMPDS_5:15;
assume L885: R1 in C179;
thus L886: ( ( Initialize D279 ) . R1 ) >= ( C178 + ( ( Initialize D279 ) . D280 ) ) by L885 , L853 , L858 , L859 , L862 , L865 , L883 , L884;
end;
L887: (for B184 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C179 implies ( B184 . R1 ) >= ( C178 + ( B184 . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) ))) & (for R1 being Int_position holds (R1 in C180 implies ( B184 . R1 ) = ( ( Initialize D279 ) . R1 ))) & ( B184 . C176 ) = ( ( Initialize D279 ) . C176 ) & ( B184 . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) > ( 0 )) implies (( ( IExec (C175 , R5 , B184) ) . C176 ) = ( B184 . C176 ) & C175 is_closed_on B184 , R5 & C175 is_halting_on B184 , R5 & ( C181 . ( Initialize ( IExec (C175 , R5 , B184) ) ) ) < ( C181 . B184 ) & (for R1 being Int_position holds (R1 in C179 implies ( ( IExec (C175 , R5 , B184) ) . R1 ) >= ( C178 + ( ( IExec (C175 , R5 , B184) ) . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) ))) & (for R1 being Int_position holds (R1 in C180 implies ( ( IExec (C175 , R5 , B184) ) . R1 ) = ( B184 . R1 )))))))
proof
let C183 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume that
L888: (for R1 being Int_position holds (R1 in C179 implies ( C183 . R1 ) >= ( C178 + ( C183 . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) )))
and
L889: (for R1 being Int_position holds (R1 in C180 implies ( C183 . R1 ) = ( ( Initialize D279 ) . R1 )))
and
L890: ( C183 . C176 ) = ( ( Initialize D279 ) . C176 )
and
L891: ( C183 . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) > ( 0 );
thus L892: ( ( IExec (C175 , R5 , C183) ) . C176 ) = ( ( Initialize ( IExec (C175 , R5 , C183) ) ) . C176 ) by SCMPDS_5:15
.= ( C183 . C176 ) by L866 , L888 , L889 , L890 , L891;
thus L893: (C175 is_closed_on C183 , R5 & C175 is_halting_on C183 , R5) by L866 , L888 , L889 , L890 , L891;
thus L894: ( C181 . ( Initialize ( IExec (C175 , R5 , C183) ) ) ) < ( C181 . C183 ) by L866 , L888 , L889 , L890 , L891;
thus L895: (for R1 being Int_position holds (R1 in C179 implies ( ( IExec (C175 , R5 , C183) ) . R1 ) >= ( C178 + ( ( IExec (C175 , R5 , C183) ) . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) )))
proof
let R1 being Int_position;
L896: (( ( IExec (C175 , R5 , C183) ) . R1 ) = ( ( Initialize ( IExec (C175 , R5 , C183) ) ) . R1 ) & ( ( IExec (C175 , R5 , C183) ) . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) = ( ( Initialize ( IExec (C175 , R5 , C183) ) ) . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) )) by SCMPDS_5:15;
thus L897: (R1 in C179 implies ( ( IExec (C175 , R5 , C183) ) . R1 ) >= ( C178 + ( ( IExec (C175 , R5 , C183) ) . ( DataLoc (( ( Initialize D279 ) . C176 ) , C177) ) ) )) by L896 , L866 , L888 , L889 , L890 , L891;
end;

thus L898: (for R1 being Int_position holds (R1 in C180 implies ( ( IExec (C175 , R5 , C183) ) . R1 ) = ( C183 . R1 ))) by L866 , L888 , L889 , L890 , L891;
end;
L899: D271 is_halting_on ( Initialize D279 ) , D281 by L887 , L857 , L863 , L756 , L882;
L900: ( R4 +* ( stop D271 ) ) halts_on ( Initialize ( Initialize D279 ) ) by L899 , SCMPDS_6:def 3;
L901: (for R2 being Int_position holds ( C174 . R2 ) = ( D276 . R2 )) by L856 , SCMPDS_2:56;
L902: ( DataPart C174 ) = ( DataPart D276 ) by L901 , SCMPDS_4:8;
set D287 = ( LifeSpan (D282 , C174) );
set D288 = ( Comput (D277 , D276 , D287) );
set D289 = D277;
set D290 = ( ( card C175 ) + 1 );
L903: D271 c= D272 by AFINSQ_1:74;
L904: D272 c= D273 by FUNCT_4:25;
L905: D271 c= D273 by L904 , L903 , XBOOLE_1:1;
set D291 = ( D287 + 1 );
set D292 = ( Comput (D273 , C174 , ( D291 + 1 )) );
set D293 = D273;
set D294 = ( Comput (D273 , C174 , D291) );
set D295 = D273;
L906: ( ( card C175 ) + 1 ) < ( ( card C175 ) + 2 ) by XREAL_1:6;
L907: D290 in ( dom D271 ) by L906 , L525;
L908: ( Shift (C175 , 1) ) c= D271 by L601;
L909: ( Shift (C175 , 1) ) c= D277 by L908 , L905 , XBOOLE_1:1;
L910: C175 is_halting_on C174 , R4 by L853 , L858 , L859 , L862;
L911: D282 halts_on C174 by L910 , L852 , SCMPDS_6:def 3;
L912: ( D282 +* ( stop C175 ) ) halts_on C174 by L911;
L913: C175 is_halting_on C174 , D282 by L912 , L852 , SCMPDS_6:def 3;
L914: ( IC D276 ) = ( succ ( IC C174 ) ) by L853 , L856 , SCMPDS_2:56
.= ( ( 0 ) + 1 ) by L854;
L915: C175 is_closed_on C174 , D282 by L853 , L858 , L859 , L862;
L916: ( IC D288 ) = D290 by L915 , L864 , L913 , L914 , L902 , L909 , SCMPDS_7:18;
L917: ( D295 /. ( IC D294 ) ) = ( D295 . ( IC D294 ) ) by PBOOLE:143;
L918: D294 = D288 by EXTPRO_1:4;
L919: ( CurInstr (D295 , D294) ) = ( D277 . D290 ) by L918 , L864 , L913 , L915 , L914 , L902 , L909 , L917 , SCMPDS_7:18
.= ( D271 . D290 ) by L907 , L905 , GRFUNC_1:2
.= D275 by L528;
L920: D292 = ( Following (D273 , D294) ) by EXTPRO_1:3
.= ( Exec (D275 , D294) ) by L919;
L921: ( IC D292 ) = ( ICplusConst (D294 , ( ( 0 ) - ( ( card C175 ) + 1 ) )) ) by L920 , SCMPDS_2:54
.= ( 0 ) by L916 , L918 , SCMPDS_7:1;
L922: ( IC D284 ) = ( IC ( Comput (D273 , C174 , D283) ) ) by L921 , MEMSTR_0:def 11;
L923: ( DataPart ( Comput (D282 , C174 , D287) ) ) = ( DataPart D288 ) by L864 , L913 , L915 , L914 , L902 , L909 , SCMPDS_7:18;
L924:
now
let C184 being Int_position;
L925: (not C184 in ( dom ( Start-At (( 0 ) , ( SCMPDS )) ) )) by SCMPDS_4:18;
L926: ( D288 . C184 ) = ( ( Comput (D282 , C174 , D287) ) . C184 ) by L923 , SCMPDS_4:8
.= ( ( Result (D282 , C174) ) . C184 ) by L911 , EXTPRO_1:23
.= ( ( IExec (C175 , R4 , C174) ) . C184 ) by SCMPDS_4:def 5;
thus L927: ( D292 . C184 ) = ( ( IExec (C175 , R4 , C174) ) . C184 ) by L926 , L918 , L920 , SCMPDS_2:54
.= ( D284 . C184 ) by L925 , FUNCT_4:11;
end;
L928: ( DataPart D292 ) = ( DataPart D284 ) by L924 , SCMPDS_4:8;
L929: ( Comput (D273 , C174 , D283) ) = D284 by L928 , L922 , MEMSTR_0:78;
L930: ( CurInstr (D273 , ( Comput (D273 , C174 , D283) )) ) = D274 by L929 , L855 , SCMPDS_6:11;
L931: D278 > D283 by L930 , L861 , EXTPRO_1:36 , SCMPDS_6:17;
consider C185 being Nat such that L932: D278 = ( D283 + C185 ) by L931 , NAT_1:10;
reconsider D296 = C185 as (Element of ( NAT )) by ORDINAL1:def 12;
L933: ( Comput (D273 , C174 , ( D283 + D286 )) ) = ( Comput (D273 , D284 , D286) ) by L929 , EXTPRO_1:4;
L934: ( CurInstr (D273 , ( Comput (D273 , C174 , ( D283 + D286 )) )) ) = ( halt ( SCMPDS ) ) by L933 , L900 , EXTPRO_1:def 15;
L935: ( D283 + D286 ) >= D278 by L934 , L861 , EXTPRO_1:def 15;
L936: D286 >= D296 by L935 , L932 , XREAL_1:6;
L937: ( Comput (D273 , C174 , D278) ) = ( Comput (D273 , D284 , D296) ) by L929 , L932 , EXTPRO_1:4;
L938: ( CurInstr (D285 , ( Comput (D285 , D284 , D296) )) ) = ( halt ( SCMPDS ) ) by L937 , L861 , EXTPRO_1:def 15;
L939: D296 >= D286 by L938 , L900 , EXTPRO_1:def 15;
L940: D296 = D286 by L939 , L936 , XXREAL_0:1;
L941: ( Result (D273 , C174) ) = ( Comput (D285 , D284 , D286) ) by L940 , L861 , L937 , EXTPRO_1:23;
thus L942: ( IExec (D271 , R4 , C174) ) = ( Comput (D285 , D284 , D286) ) by L941 , SCMPDS_4:def 5
.= ( Result (D285 , D284) ) by L900 , EXTPRO_1:23
.= ( IExec (D271 , R4 , ( Initialize ( IExec (C175 , R4 , C174) ) )) ) by SCMPDS_4:def 5;
end;
theorem
L943: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B185 being ( 0 ) -started (State of ( SCMPDS )) holds (for B186 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B187 being Int_position holds (for B188 being Integer holds (for B189 being set holds (for B190 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) holds (((for B191 being ( 0 ) -started (State of ( SCMPDS )) holds (( B190 . B191 ) = ( 0 ) implies ( B191 . ( DataLoc (( B185 . B187 ) , B188) ) ) <= ( 0 ))) & (for B192 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in B189 implies ( B192 . R1 ) = ( B185 . R1 ))) & ( B192 . B187 ) = ( B185 . B187 ) & ( B192 . ( DataLoc (( B185 . B187 ) , B188) ) ) > ( 0 )) implies (( ( IExec (B186 , R5 , B192) ) . B187 ) = ( B192 . B187 ) & B186 is_closed_on B192 , R5 & B186 is_halting_on B192 , R5 & ( B190 . ( Initialize ( IExec (B186 , R5 , B192) ) ) ) < ( B190 . B192 ) & (for R1 being Int_position holds (R1 in B189 implies ( ( IExec (B186 , R5 , B192) ) . R1 ) = ( B192 . R1 )))))))) implies (( while>0 (B187 , B188 , B186) ) is_closed_on B185 , R4 & ( while>0 (B187 , B188 , B186) ) is_halting_on B185 , R4 & (( B185 . ( DataLoc (( B185 . B187 ) , B188) ) ) > ( 0 ) implies ( IExec (( while>0 (B187 , B188 , B186) ) , R4 , B185) ) = ( IExec (( while>0 (B187 , B188 , B186) ) , R4 , ( Initialize ( IExec (B186 , R4 , B185) ) )) )))))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C186 being ( 0 ) -started (State of ( SCMPDS ));
let C187 being  halt-free  shiftable (Program of ( SCMPDS ));
let C188 being Int_position;
let C189 being Integer;
let C190 being set;
let C191 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT ));
set D297 = ( DataLoc (( C186 . C188 ) , C189) );
assume L944: (for B193 being ( 0 ) -started (State of ( SCMPDS )) holds (( C191 . B193 ) = ( 0 ) implies ( B193 . D297 ) <= ( 0 )));
assume L945: (for B194 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C190 implies ( B194 . R1 ) = ( C186 . R1 ))) & ( B194 . C188 ) = ( C186 . C188 ) & ( B194 . D297 ) > ( 0 )) implies (( ( IExec (C187 , R5 , B194) ) . C188 ) = ( B194 . C188 ) & C187 is_closed_on B194 , R5 & C187 is_halting_on B194 , R5 & ( C191 . ( Initialize ( IExec (C187 , R5 , B194) ) ) ) < ( C191 . B194 ) & (for R1 being Int_position holds (R1 in C190 implies ( ( IExec (C187 , R5 , B194) ) . R1 ) = ( B194 . R1 )))))));
L946: (for B195 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in ( {} ) implies ( B195 . R1 ) >= ( ( 0 ) + ( B195 . D297 ) ))) & (for R1 being Int_position holds (R1 in C190 implies ( B195 . R1 ) = ( C186 . R1 ))) & ( B195 . C188 ) = ( C186 . C188 ) & ( B195 . D297 ) > ( 0 )) implies (( ( IExec (C187 , R5 , B195) ) . C188 ) = ( B195 . C188 ) & C187 is_closed_on B195 , R5 & C187 is_halting_on B195 , R5 & ( C191 . ( Initialize ( IExec (C187 , R5 , B195) ) ) ) < ( C191 . B195 ) & (for R1 being Int_position holds (R1 in ( {} ) implies ( ( IExec (C187 , R5 , B195) ) . R1 ) >= ( ( 0 ) + ( ( IExec (C187 , R5 , B195) ) . D297 ) ))) & (for R1 being Int_position holds (R1 in C190 implies ( ( IExec (C187 , R5 , B195) ) . R1 ) = ( B195 . R1 ))))))) by L945;
L947: (for R1 being Int_position holds (R1 in ( {} ) implies ( C186 . R1 ) >= ( ( 0 ) + ( C186 . D297 ) )));
L948: (for B196 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in ( {} ) implies ( B196 . R1 ) >= ( ( 0 ) + ( B196 . D297 ) ))) & (for R1 being Int_position holds (R1 in C190 implies ( B196 . R1 ) = ( C186 . R1 ))) & ( B196 . C188 ) = ( C186 . C188 ) & ( B196 . D297 ) > ( 0 )) implies (( ( IExec (C187 , R5 , B196) ) . C188 ) = ( B196 . C188 ) & C187 is_closed_on B196 , R5 & C187 is_halting_on B196 , R5 & ( C191 . ( Initialize ( IExec (C187 , R5 , B196) ) ) ) < ( C191 . B196 ) & (for R1 being Int_position holds (R1 in ( {} ) implies ( ( IExec (C187 , R5 , B196) ) . R1 ) >= ( ( 0 ) + ( ( IExec (C187 , R5 , B196) ) . D297 ) ))) & (for R1 being Int_position holds (R1 in C190 implies ( ( IExec (C187 , R5 , B196) ) . R1 ) = ( B196 . R1 ))))))) by L945;
thus L949: (( while>0 (C188 , C189 , C187) ) is_closed_on C186 , R4 & ( while>0 (C188 , C189 , C187) ) is_halting_on C186 , R4) by L948 , L944 , L947 , L756;
assume L950: ( C186 . D297 ) > ( 0 );
thus L951: thesis by L950 , L944 , L947 , L946 , L851;
end;
theorem
L952: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B197 being ( 0 ) -started (State of ( SCMPDS )) holds (for B198 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B199 being Int_position holds (for B200 , B201 being Integer holds (for B202 , B203 being set holds (((for R1 being Int_position holds (R1 in B202 implies ( B197 . R1 ) >= ( B201 + ( B197 . ( DataLoc (( B197 . B199 ) , B200) ) ) ))) & (for B204 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in B202 implies ( B204 . R1 ) >= ( B201 + ( B204 . ( DataLoc (( B197 . B199 ) , B200) ) ) ))) & (for R1 being Int_position holds (R1 in B203 implies ( B204 . R1 ) = ( B197 . R1 ))) & ( B204 . B199 ) = ( B197 . B199 ) & ( B204 . ( DataLoc (( B197 . B199 ) , B200) ) ) > ( 0 )) implies (( ( IExec (B198 , R5 , B204) ) . B199 ) = ( B204 . B199 ) & B198 is_closed_on B204 , R5 & B198 is_halting_on B204 , R5 & ( ( IExec (B198 , R5 , B204) ) . ( DataLoc (( B197 . B199 ) , B200) ) ) < ( B204 . ( DataLoc (( B197 . B199 ) , B200) ) ) & (for R1 being Int_position holds (R1 in B202 implies ( ( IExec (B198 , R5 , B204) ) . R1 ) >= ( B201 + ( ( IExec (B198 , R5 , B204) ) . ( DataLoc (( B197 . B199 ) , B200) ) ) ))) & (for R1 being Int_position holds (R1 in B203 implies ( ( IExec (B198 , R5 , B204) ) . R1 ) = ( B204 . R1 )))))))) implies (( while>0 (B199 , B200 , B198) ) is_closed_on B197 , R4 & ( while>0 (B199 , B200 , B198) ) is_halting_on B197 , R4 & (( B197 . ( DataLoc (( B197 . B199 ) , B200) ) ) > ( 0 ) implies ( IExec (( while>0 (B199 , B200 , B198) ) , R4 , B197) ) = ( IExec (( while>0 (B199 , B200 , B198) ) , R4 , ( Initialize ( IExec (B198 , R4 , B197) ) )) ))))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C192 being ( 0 ) -started (State of ( SCMPDS ));
let C193 being  halt-free  shiftable (Program of ( SCMPDS ));
let C194 being Int_position;
let C195 , C196 being Integer;
let C197 , C198 being set;
set D298 = ( DataLoc (( C192 . C194 ) , C195) );
defpred S8[ (State of ( SCMPDS )) ] means ((for R1 being Int_position holds (R1 in C197 implies ( $1 . R1 ) >= ( C196 + ( $1 . D298 ) ))) & (for R1 being Int_position holds (R1 in C198 implies ( $1 . R1 ) = ( C192 . R1 ))));
consider C199 being (Function of ( product ( the_Values_of ( SCMPDS ) ) ) , ( NAT )) such that L953: (for R3 being (State of ( SCMPDS )) holds ((( R3 . D298 ) <= ( 0 ) implies ( C199 . R3 ) = ( 0 )) & (( R3 . D298 ) > ( 0 ) implies ( C199 . R3 ) = ( R3 . D298 )))) by L11;
deffunc H4((State of ( SCMPDS ))) = ( C199 . $1 );
L954: (for B205 being ( 0 ) -started (State of ( SCMPDS )) holds ((S8[ B205 ] & H4(B205) = ( 0 )) implies ( B205 . D298 ) <= ( 0 ))) by L953;
assume L955: (for R1 being Int_position holds (R1 in C197 implies ( C192 . R1 ) >= ( C196 + ( C192 . D298 ) )));
L956: S8[ C192 ] by L955;
assume L957: (for B206 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C197 implies ( B206 . R1 ) >= ( C196 + ( B206 . D298 ) ))) & (for R1 being Int_position holds (R1 in C198 implies ( B206 . R1 ) = ( C192 . R1 ))) & ( B206 . C194 ) = ( C192 . C194 ) & ( B206 . D298 ) > ( 0 )) implies (( ( IExec (C193 , R5 , B206) ) . C194 ) = ( B206 . C194 ) & C193 is_closed_on B206 , R5 & C193 is_halting_on B206 , R5 & ( ( IExec (C193 , R5 , B206) ) . D298 ) < ( B206 . D298 ) & (for R1 being Int_position holds (R1 in C197 implies ( ( IExec (C193 , R5 , B206) ) . R1 ) >= ( C196 + ( ( IExec (C193 , R5 , B206) ) . D298 ) ))) & (for R1 being Int_position holds (R1 in C198 implies ( ( IExec (C193 , R5 , B206) ) . R1 ) = ( B206 . R1 )))))));
L958:
now
let C200 being ( 0 ) -started (State of ( SCMPDS ));
let R5 being (Instruction-Sequence of ( SCMPDS ));
assume that
L959: S8[ C200 ]
and
L960: ( C200 . C194 ) = ( C192 . C194 )
and
L961: ( C200 . D298 ) > ( 0 );
set D299 = ( IExec (C193 , R5 , C200) );
set D300 = ( Initialize D299 );
set D301 = C200;
consider C201 being (State of ( SCMPDS )) such that L962: C201 = C200 and L963: (for R1 being Int_position holds (R1 in C197 implies ( C201 . R1 ) >= ( C196 + ( C201 . D298 ) ))) and L964: (for R1 being Int_position holds (R1 in C198 implies ( C201 . R1 ) = ( C192 . R1 ))) by L959;
thus L965: (( ( IExec (C193 , R5 , C200) ) . C194 ) = ( C200 . C194 ) & C193 is_closed_on C200 , R5 & C193 is_halting_on C200 , R5) by L957 , L960 , L961 , L962 , L964 , L963;
thus L966: H4(D300) < H4(D301)
proof
L967: H4(D301) = ( D301 . D298 ) by L953 , L961;
assume L968: H4(D300) >= H4(D301);
L969: H4(D300) = ( D300 . D298 ) by L953 , L961 , L967 , L968
.= ( D299 . D298 ) by SCMPDS_5:15;
thus L970: contradiction by L969 , L957 , L960 , L961 , L959 , L968 , L967;
end;

thus L971: S8[ ( Initialize D299 ) ]
proof
set D302 = ( Initialize D299 );
thus L972:now
let R1 being Int_position;
assume L973: R1 in C197;
L974: ( D299 . R1 ) >= ( C196 + ( D299 . D298 ) ) by L973 , L957 , L960 , L961 , L959;
L975: ( D302 . R1 ) >= ( C196 + ( D299 . D298 ) ) by L974 , SCMPDS_5:15;
thus L976: ( D302 . R1 ) >= ( C196 + ( D302 . D298 ) ) by L975 , SCMPDS_5:15;
end;
thus L977:now
let R1 being Int_position;
assume L978: R1 in C198;
L979: ( D299 . R1 ) = ( C200 . R1 ) by L978 , L957 , L960 , L961 , L959;
L980: ( D302 . R1 ) = ( C200 . R1 ) by L979 , SCMPDS_5:15;
thus L981: ( D302 . R1 ) = ( C192 . R1 ) by L980 , L962 , L964 , L978;
end;
end;

end;
L972: (( while>0 (C194 , C195 , C193) ) is_closed_on C192 , R4 & ( while>0 (C194 , C195 , C193) ) is_halting_on C192 , R4) from WhileGHalt(L954 , L956 , L958);
thus L973: (( while>0 (C194 , C195 , C193) ) is_closed_on C192 , R4 & ( while>0 (C194 , C195 , C193) ) is_halting_on C192 , R4) by L972;
assume L974: ( C192 . D298 ) > ( 0 );
L975: ( IExec (( while>0 (C194 , C195 , C193) ) , R4 , C192) ) = ( IExec (( while>0 (C194 , C195 , C193) ) , R4 , ( Initialize ( IExec (C193 , R4 , C192) ) )) ) from WhileGExec(L974 , L954 , L956 , L958);
thus L976: thesis by L975;
end;
theorem
L977: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B207 being ( 0 ) -started (State of ( SCMPDS )) holds (for B208 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B209 being Int_position holds (for B210 being Integer holds (for B211 being set holds ((for B212 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in B211 implies ( B212 . R1 ) = ( B207 . R1 ))) & ( B212 . B209 ) = ( B207 . B209 ) & ( B212 . ( DataLoc (( B207 . B209 ) , B210) ) ) > ( 0 )) implies (( ( IExec (B208 , R5 , B212) ) . B209 ) = ( B212 . B209 ) & B208 is_closed_on B212 , R5 & B208 is_halting_on B212 , R5 & ( ( IExec (B208 , R5 , B212) ) . ( DataLoc (( B207 . B209 ) , B210) ) ) < ( B212 . ( DataLoc (( B207 . B209 ) , B210) ) ) & (for R1 being Int_position holds (R1 in B211 implies ( ( IExec (B208 , R5 , B212) ) . R1 ) = ( B212 . R1 ))))))) implies (( while>0 (B209 , B210 , B208) ) is_closed_on B207 , R4 & ( while>0 (B209 , B210 , B208) ) is_halting_on B207 , R4 & (( B207 . ( DataLoc (( B207 . B209 ) , B210) ) ) > ( 0 ) implies ( IExec (( while>0 (B209 , B210 , B208) ) , R4 , B207) ) = ( IExec (( while>0 (B209 , B210 , B208) ) , R4 , ( Initialize ( IExec (B208 , R4 , B207) ) )) ))))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C202 being ( 0 ) -started (State of ( SCMPDS ));
let C203 being  halt-free  shiftable (Program of ( SCMPDS ));
let C204 being Int_position;
let C205 being Integer;
let C206 being set;
set D303 = ( DataLoc (( C202 . C204 ) , C205) );
assume L978: (for B213 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C206 implies ( B213 . R1 ) = ( C202 . R1 ))) & ( B213 . C204 ) = ( C202 . C204 ) & ( B213 . D303 ) > ( 0 )) implies (( ( IExec (C203 , R5 , B213) ) . C204 ) = ( B213 . C204 ) & C203 is_closed_on B213 , R5 & C203 is_halting_on B213 , R5 & ( ( IExec (C203 , R5 , B213) ) . D303 ) < ( B213 . D303 ) & (for R1 being Int_position holds (R1 in C206 implies ( ( IExec (C203 , R5 , B213) ) . R1 ) = ( B213 . R1 )))))));
L979: (for B214 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in ( {} ) implies ( B214 . R1 ) >= ( ( 0 ) + ( B214 . D303 ) ))) & (for R1 being Int_position holds (R1 in C206 implies ( B214 . R1 ) = ( C202 . R1 ))) & ( B214 . C204 ) = ( C202 . C204 ) & ( B214 . D303 ) > ( 0 )) implies (( ( IExec (C203 , R5 , B214) ) . C204 ) = ( B214 . C204 ) & C203 is_closed_on B214 , R5 & C203 is_halting_on B214 , R5 & ( ( IExec (C203 , R5 , B214) ) . D303 ) < ( B214 . D303 ) & (for R1 being Int_position holds (R1 in ( {} ) implies ( ( IExec (C203 , R5 , B214) ) . R1 ) >= ( ( 0 ) + ( ( IExec (C203 , R5 , B214) ) . D303 ) ))) & (for R1 being Int_position holds (R1 in C206 implies ( ( IExec (C203 , R5 , B214) ) . R1 ) = ( B214 . R1 ))))))) by L978;
L980: (for R1 being Int_position holds (R1 in ( {} ) implies ( C202 . R1 ) >= ( ( 0 ) + ( C202 . D303 ) )));
L981: (for B215 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in ( {} ) implies ( B215 . R1 ) >= ( ( 0 ) + ( B215 . D303 ) ))) & (for R1 being Int_position holds (R1 in C206 implies ( B215 . R1 ) = ( C202 . R1 ))) & ( B215 . C204 ) = ( C202 . C204 ) & ( B215 . D303 ) > ( 0 )) implies (( ( IExec (C203 , R5 , B215) ) . C204 ) = ( B215 . C204 ) & C203 is_closed_on B215 , R5 & C203 is_halting_on B215 , R5 & ( ( IExec (C203 , R5 , B215) ) . D303 ) < ( B215 . D303 ) & (for R1 being Int_position holds (R1 in ( {} ) implies ( ( IExec (C203 , R5 , B215) ) . R1 ) >= ( ( 0 ) + ( ( IExec (C203 , R5 , B215) ) . D303 ) ))) & (for R1 being Int_position holds (R1 in C206 implies ( ( IExec (C203 , R5 , B215) ) . R1 ) = ( B215 . R1 ))))))) by L978;
thus L982: (( while>0 (C204 , C205 , C203) ) is_closed_on C202 , R4 & ( while>0 (C204 , C205 , C203) ) is_halting_on C202 , R4) by L981 , L980 , L952;
assume L983: ( C202 . D303 ) > ( 0 );
thus L984: thesis by L983 , L980 , L979 , L952;
end;
theorem
L985: (for R4 being (Instruction-Sequence of ( SCMPDS )) holds (for B216 being ( 0 ) -started (State of ( SCMPDS )) holds (for B217 being  halt-free  shiftable (Program of ( SCMPDS )) holds (for B218 being Int_position holds (for B219 , B220 being Integer holds (for B221 being set holds (((for R1 being Int_position holds (R1 in B221 implies ( B216 . R1 ) >= ( B220 + ( B216 . ( DataLoc (( B216 . B218 ) , B219) ) ) ))) & (for B222 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in B221 implies ( B222 . R1 ) >= ( B220 + ( B222 . ( DataLoc (( B216 . B218 ) , B219) ) ) ))) & ( B222 . B218 ) = ( B216 . B218 ) & ( B222 . ( DataLoc (( B216 . B218 ) , B219) ) ) > ( 0 )) implies (( ( IExec (B217 , R5 , B222) ) . B218 ) = ( B222 . B218 ) & B217 is_closed_on B222 , R5 & B217 is_halting_on B222 , R5 & ( ( IExec (B217 , R5 , B222) ) . ( DataLoc (( B216 . B218 ) , B219) ) ) < ( B222 . ( DataLoc (( B216 . B218 ) , B219) ) ) & (for R1 being Int_position holds (R1 in B221 implies ( ( IExec (B217 , R5 , B222) ) . R1 ) >= ( B220 + ( ( IExec (B217 , R5 , B222) ) . ( DataLoc (( B216 . B218 ) , B219) ) ) )))))))) implies (( while>0 (B218 , B219 , B217) ) is_closed_on B216 , R4 & ( while>0 (B218 , B219 , B217) ) is_halting_on B216 , R4 & (( B216 . ( DataLoc (( B216 . B218 ) , B219) ) ) > ( 0 ) implies ( IExec (( while>0 (B218 , B219 , B217) ) , R4 , B216) ) = ( IExec (( while>0 (B218 , B219 , B217) ) , R4 , ( Initialize ( IExec (B217 , R4 , B216) ) )) ))))))))))
proof
let R4 being (Instruction-Sequence of ( SCMPDS ));
let C207 being ( 0 ) -started (State of ( SCMPDS ));
let C208 being  halt-free  shiftable (Program of ( SCMPDS ));
let C209 being Int_position;
let C210 , C211 being Integer;
let C212 being set;
set D304 = ( DataLoc (( C207 . C209 ) , C210) );
assume L986: (for R1 being Int_position holds (R1 in C212 implies ( C207 . R1 ) >= ( C211 + ( C207 . D304 ) )));
assume L987: (for B223 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C212 implies ( B223 . R1 ) >= ( C211 + ( B223 . D304 ) ))) & ( B223 . C209 ) = ( C207 . C209 ) & ( B223 . D304 ) > ( 0 )) implies (( ( IExec (C208 , R5 , B223) ) . C209 ) = ( B223 . C209 ) & C208 is_closed_on B223 , R5 & C208 is_halting_on B223 , R5 & ( ( IExec (C208 , R5 , B223) ) . D304 ) < ( B223 . D304 ) & (for R1 being Int_position holds (R1 in C212 implies ( ( IExec (C208 , R5 , B223) ) . R1 ) >= ( C211 + ( ( IExec (C208 , R5 , B223) ) . D304 ) )))))));
L988: (for B224 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C212 implies ( B224 . R1 ) >= ( C211 + ( B224 . D304 ) ))) & (for R1 being Int_position holds (R1 in ( {} ) implies ( B224 . R1 ) = ( C207 . R1 ))) & ( B224 . C209 ) = ( C207 . C209 ) & ( B224 . D304 ) > ( 0 )) implies (( ( IExec (C208 , R5 , B224) ) . C209 ) = ( B224 . C209 ) & C208 is_closed_on B224 , R5 & C208 is_halting_on B224 , R5 & ( ( IExec (C208 , R5 , B224) ) . D304 ) < ( B224 . D304 ) & (for R1 being Int_position holds (R1 in C212 implies ( ( IExec (C208 , R5 , B224) ) . R1 ) >= ( C211 + ( ( IExec (C208 , R5 , B224) ) . D304 ) ))) & (for R1 being Int_position holds (R1 in ( {} ) implies ( ( IExec (C208 , R5 , B224) ) . R1 ) = ( B224 . R1 ))))))) by L987;
thus L989: (( while>0 (C209 , C210 , C208) ) is_closed_on C207 , R4 & ( while>0 (C209 , C210 , C208) ) is_halting_on C207 , R4) by L988 , L986 , L952;
L990: (for B225 being ( 0 ) -started (State of ( SCMPDS )) holds (for R5 being (Instruction-Sequence of ( SCMPDS )) holds (((for R1 being Int_position holds (R1 in C212 implies ( B225 . R1 ) >= ( C211 + ( B225 . D304 ) ))) & (for R1 being Int_position holds (R1 in ( {} ) implies ( B225 . R1 ) = ( C207 . R1 ))) & ( B225 . C209 ) = ( C207 . C209 ) & ( B225 . D304 ) > ( 0 )) implies (( ( IExec (C208 , R5 , B225) ) . C209 ) = ( B225 . C209 ) & C208 is_closed_on B225 , R5 & C208 is_halting_on B225 , R5 & ( ( IExec (C208 , R5 , B225) ) . D304 ) < ( B225 . D304 ) & (for R1 being Int_position holds (R1 in C212 implies ( ( IExec (C208 , R5 , B225) ) . R1 ) >= ( C211 + ( ( IExec (C208 , R5 , B225) ) . D304 ) ))) & (for R1 being Int_position holds (R1 in ( {} ) implies ( ( IExec (C208 , R5 , B225) ) . R1 ) = ( B225 . R1 ))))))) by L987;
thus L991: thesis by L990 , L986 , L952;
end;
