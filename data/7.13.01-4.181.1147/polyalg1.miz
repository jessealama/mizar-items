:: The Algebra of Polynomials
::  by Ewa Gr\c{a}dzka
::
:: Received February 24, 2001
:: Copyright (c) 2001-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, STRUCT_0, ALGSTR_0, VECTSP_1, FUNCSDOM, BINOP_1,
      SUBSET_1, FUNCT_1, ZFMISC_1, XBOOLE_0, CARD_1, FUNCOP_1, RELAT_1,
      GROUP_1, LATTICES, MESFUNC1, NAT_1, ARYTM_3, SUPINF_2, POLYNOM3,
      RLVECT_1, ARYTM_1, ALGSTR_1, FINSEQ_1, RFINSEQ, FINSEQ_3, XXREAL_0,
      ORDINAL4, PARTFUN1, CARD_3, REALSET1, TARSKI, UNIALG_2, RLSUB_1,
      SETFAM_1, POLYNOM1, ALGSEQ_1, POLYALG1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, SETFAM_1, NUMBERS, XCMPLX_0,
      REALSET1, ORDINAL1, STRUCT_0, ALGSTR_0, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_2, FUNCOP_1, FINSEQ_1, RFINSEQ, BINOP_1, NAT_D, GROUP_1, RLVECT_1,
      VFUNCT_1, VECTSP_1, NORMSP_1, POLYNOM1, ALGSTR_1, ALGSEQ_1, POLYNOM3,
      POLYNOM5, VECTSP_4, XXREAL_0;
 constructors BINOP_1, REALSET1, RFINSEQ, NAT_D, ALGSTR_1, VECTSP_4, POLYNOM3,
      POLYNOM5, REAL_1, RELSET_1, FUNCOP_1, FVSUM_1, VFUNCT_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, XREAL_0, NAT_1, FINSEQ_1,
      REALSET1, STRUCT_0, VECTSP_1, FVSUM_1, POLYNOM3, POLYNOM5, BINOM,
      ORDINAL1, VFUNCT_1, FUNCT_2, RELAT_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, RLVECT_1, GROUP_1, VECTSP_1, BINOP_1, REALSET1, STRUCT_0,
      ALGSTR_0;
 theorems TARSKI, NAT_1, RLVECT_1, VECTSP_1, FUNCT_1, FUNCT_2, FUNCOP_1,
      FINSEQ_1, FINSEQ_3, FINSEQ_5, RFINSEQ, BINOP_1, POLYNOM1, POLYNOM3,
      ZFMISC_1, POLYNOM5, BINOM, RELAT_1, VECTSP_4, SETFAM_1, ALGSTR_1,
      XBOOLE_0, XBOOLE_1, GROUP_1, XREAL_1, ORDINAL1, NORMSP_1, PARTFUN1,
      CARD_1, NAT_D;
 schemes SUBSET_1, BINOP_1;

begin
definition
let C1 being 1-sorted;
struct (doubleLoopStr , VectSpStr over C1) AlgebraStr over C1(# carrier -> set , addF , multF -> (BinOp of the carrier) , ZeroF , OneF -> (Element of the carrier) , lmult -> (Function of [: (the carrier of C1) , the carrier :] , the carrier) #);
end;
registration
let C2 being non  empty doubleLoopStr;
cluster  strict non  empty for AlgebraStr over C2;
existence
proof
L2: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
reconsider D1 = ( [: (the carrier of C2) , { ( 0 ) } :] --> ( 0 ) ) as (Function of [: (the carrier of C2) , { ( 0 ) } :] , { ( 0 ) }) by L2 , FUNCOP_1:45;
reconsider D2 = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
set D3 = the (BinOp of { ( 0 ) });
take AlgebraStr (# { ( 0 ) } , D3 , D3 , D2 , D2 , D1 #);
thus L3: thesis;
end;
end;
definition
let C3 being non  empty doubleLoopStr;
let C4 being non  empty AlgebraStr over C3;
attr C4 is  mix-associative
means
(for B1 being (Element of C3) holds (for B2 , B3 being (Element of C4) holds ( B1 * ( B2 * B3 ) ) = ( ( B1 * B2 ) * B3 )));
end;
registration
let C5 being non  empty doubleLoopStr;
cluster  unital  distributive  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  mix-associative for non  empty non  empty non  empty non  empty AlgebraStr over C5;
existence
proof
L6: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
reconsider D4 = ( [: (the carrier of C5) , { ( 0 ) } :] --> ( 0 ) ) as (Function of [: (the carrier of C5) , { ( 0 ) } :] , { ( 0 ) }) by L6 , FUNCOP_1:45;
reconsider D5 = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
set D6 = the (BinOp of { ( 0 ) });
reconsider D7 = AlgebraStr (# { ( 0 ) } , D6 , D6 , D5 , D5 , D4 #) as non  empty AlgebraStr over C5;
take D7;
L7: (for B4 , B5 being (Element of D7) holds B4 = B5)
proof
let C6 , C7 being (Element of D7);
L8: C6 = ( 0 ) by TARSKI:def 1;
thus L9: thesis by L8 , TARSKI:def 1;
end;
thus L10: D7 is  unital
proof
take ( 1. D7 );
thus L11: thesis by L7;
end;

thus L12: D7 is  distributive
proof
let C8 , C9 , C10 being (Element of D7);
thus L13: thesis by L7;
end;

thus L14: D7 is  vector-distributive
proof
let C11 being (Element of C5);
let C12 , C13 being (Element of D7);
thus L15: thesis by L7;
end;

thus L16: D7 is  scalar-distributive
proof
let C14 , C15 being (Element of C5);
let C16 being (Element of D7);
thus L17: thesis by L7;
end;

thus L18: D7 is  scalar-associative
proof
let C17 , C18 being (Element of C5);
thus L19: thesis by L7;
end;

thus L20: D7 is  scalar-unital
proof
let C19 being (Element of D7);
thus L21: thesis by L7;
end;

thus L22: D7 is  mix-associative
proof
let C20 being (Element of C5);
let C21 , C22 being (Element of D7);
thus L23: thesis by L7;
end;

end;
end;
definition
let C23 being non  empty doubleLoopStr;
mode Algebra of C23
 is  unital  distributive  vector-distributive  scalar-distributive  scalar-associative  scalar-unital  mix-associative non  empty AlgebraStr over C23;
end;
theorem
L25: (for B6 , B7 being set holds (for B8 being (Function of [: B6 , B7 :] , B6) holds ( dom B8 ) = [: B6 , B7 :]))
proof
let C24 , C25 being set;
let C26 being (Function of [: C24 , C25 :] , C24);
L26: (C24 is  empty implies [: C24 , C25 :] is  empty) by ZFMISC_1:90;
thus L27: thesis by L26 , FUNCT_2:def 1;
end;
theorem
L28: (for B9 , B10 being set holds (for B11 being (Function of [: B9 , B10 :] , B10) holds ( dom B11 ) = [: B9 , B10 :]))
proof
let C27 , C28 being set;
let C29 being (Function of [: C27 , C28 :] , C28);
L29: (C28 is  empty implies [: C27 , C28 :] is  empty) by ZFMISC_1:90;
thus L30: thesis by L29 , FUNCT_2:def 1;
end;
begin
definition
let C30 being non  empty doubleLoopStr;
func Formal-Series C30 ->  strict non  empty AlgebraStr over C30 means 
:L31: ((for B12 being set holds (B12 in (the carrier of it) iff B12 is (sequence of C30))) & (for B13 , B14 being (Element of it) holds (for B15 , B16 being (sequence of C30) holds ((B13 = B15 & B14 = B16) implies ( B13 + B14 ) = ( B15 + B16 )))) & (for B17 , B18 being (Element of it) holds (for B19 , B20 being (sequence of C30) holds ((B17 = B19 & B18 = B20) implies ( B17 * B18 ) = ( B19 *' B20 )))) & (for B21 being (Element of C30) holds (for B22 being (Element of it) holds (for B23 being (sequence of C30) holds (B22 = B23 implies ( B21 * B22 ) = ( B21 * B23 ))))) & ( 0. it ) = ( 0_. C30 ) & ( 1. it ) = ( 1_. C30 ));
existence
proof
L32: ( 0_. C30 ) in { B24 where B24 is (sequence of C30) : (not contradiction) };
reconsider D8 = { B25 where B25 is (sequence of C30) : (not contradiction) } as non  empty set by L32;
reconsider D9 = ( 0_. C30 ) as (Element of D8) by L32;
defpred S1[ set , set , set ] means (ex B26 , B27 being (sequence of C30) st (B26 = $1 & B27 = $2 & $3 = ( B26 + B27 )));
L33: (for B28 , B29 being (Element of D8) holds (ex B30 being (Element of D8) st S1[ B28 , B29 , B30 ]))
proof
let C31 , C32 being (Element of D8);
L34: C31 in D8;
consider C33 being (sequence of C30) such that L35: C31 = C33 by L34;
L36: C32 in D8;
consider C34 being (sequence of C30) such that L37: C32 = C34 by L36;
L38: ( C33 + C34 ) in D8;
reconsider D10 = ( C33 + C34 ) as (Element of D8) by L38;
take D10;
take C33;
take C34;
thus L39: thesis by L35 , L37;
end;
consider C35 being (Function of [: D8 , D8 :] , D8) such that L40: (for B31 , B32 being (Element of D8) holds S1[ B31 , B32 , ( C35 . (B31 , B32) ) ]) from BINOP_1:sch 3(L33);
L41: ( 1_. C30 ) in { B33 where B33 is (sequence of C30) : (not contradiction) };
reconsider D11 = ( 1_. C30 ) as (Element of D8) by L41;
defpred S2[ set , set , set ] means (ex B34 , B35 being (sequence of C30) st (B34 = $1 & B35 = $2 & $3 = ( B34 *' B35 )));
L42: (for B36 , B37 being (Element of D8) holds (ex B38 being (Element of D8) st S2[ B36 , B37 , B38 ]))
proof
let C36 , C37 being (Element of D8);
L43: C36 in D8;
consider C38 being (sequence of C30) such that L44: C36 = C38 by L43;
L45: C37 in D8;
consider C39 being (sequence of C30) such that L46: C37 = C39 by L45;
L47: ( C38 *' C39 ) in D8;
reconsider D12 = ( C38 *' C39 ) as (Element of D8) by L47;
take D12;
take C38;
take C39;
thus L48: thesis by L44 , L46;
end;
consider C40 being (Function of [: D8 , D8 :] , D8) such that L49: (for B39 , B40 being (Element of D8) holds S2[ B39 , B40 , ( C40 . (B39 , B40) ) ]) from BINOP_1:sch 3(L42);
defpred S3[ (Element of C30) , set , set ] means (ex B41 being (sequence of C30) st (B41 = $2 & $3 = ( $1 * B41 )));
L50: (for B42 being (Element of C30) holds (for B43 being (Element of D8) holds (ex B44 being (Element of D8) st S3[ B42 , B43 , B44 ])))
proof
let C41 being (Element of C30);
let C42 being (Element of D8);
L51: C42 in D8;
consider C43 being (sequence of C30) such that L52: C42 = C43 by L51;
L53: ( C41 * C43 ) in D8;
reconsider D13 = ( C41 * C43 ) as (Element of D8) by L53;
take D13;
take C43;
thus L54: thesis by L52;
end;
consider C44 being (Function of [: (the carrier of C30) , D8 :] , D8) such that L55: (for B45 being (Element of C30) holds (for B46 being (Element of D8) holds S3[ B45 , B46 , ( C44 . (B45 , B46) ) ])) from BINOP_1:sch 3(L50);
reconsider D14 = AlgebraStr (# D8 , C35 , C40 , D9 , D11 , C44 #) as  strict non  empty AlgebraStr over C30;
take D14;
thus L56: (for B47 being set holds (B47 in (the carrier of D14) iff B47 is (sequence of C30)))
proof
let C45 being set;
thus L57: (C45 in (the carrier of D14) implies C45 is (sequence of C30))
proof
assume L58: C45 in (the carrier of D14);
L59: (ex B48 being (sequence of C30) st C45 = B48) by L58;
thus L60: thesis by L59;
end;

thus L61: thesis;
end;

thus L62: (for B49 , B50 being (Element of D14) holds (for B51 , B52 being (sequence of C30) holds ((B49 = B51 & B50 = B52) implies ( B49 + B50 ) = ( B51 + B52 ))))
proof
let C46 , C47 being (Element of D14);
let C48 , C49 being (sequence of C30);
assume L63: (C46 = C48 & C47 = C49);
L64: (ex B53 , B54 being (sequence of C30) st (B53 = C46 & B54 = C47 & ( C35 . (C46 , C47) ) = ( B53 + B54 ))) by L40;
thus L65: thesis by L64 , L63;
end;

thus L66: (for B55 , B56 being (Element of D14) holds (for B57 , B58 being (sequence of C30) holds ((B55 = B57 & B56 = B58) implies ( B55 * B56 ) = ( B57 *' B58 ))))
proof
let C50 , C51 being (Element of D14);
let C52 , C53 being (sequence of C30);
assume L67: (C50 = C52 & C51 = C53);
L68: (ex B59 , B60 being (sequence of C30) st (B59 = C50 & B60 = C51 & ( C40 . (C50 , C51) ) = ( B59 *' B60 ))) by L49;
thus L69: thesis by L68 , L67;
end;

thus L70: (for B61 being (Element of C30) holds (for B62 being (Element of D14) holds (for B63 being (sequence of C30) holds (B62 = B63 implies ( B61 * B62 ) = ( B61 * B63 )))))
proof
let C54 being (Element of C30);
let C55 being (Element of D14);
let C56 being (sequence of C30);
assume that
L71: C55 = C56;
L72: (ex B64 being (sequence of C30) st (C55 = B64 & ( C44 . (C54 , C55) ) = ( C54 * B64 ))) by L55;
thus L73: thesis by L72 , L71;
end;

thus L74: ( 0. D14 ) = ( 0_. C30 );
thus L75: thesis;
end;
uniqueness
proof
let C57 , C58 being  strict non  empty AlgebraStr over C30;
assume that
L76: (for B65 being set holds (B65 in (the carrier of C57) iff B65 is (sequence of C30)))
and
L77: (for B66 , B67 being (Element of C57) holds (for B68 , B69 being (sequence of C30) holds ((B66 = B68 & B67 = B69) implies ( B66 + B67 ) = ( B68 + B69 ))))
and
L78: (for B70 , B71 being (Element of C57) holds (for B72 , B73 being (sequence of C30) holds ((B70 = B72 & B71 = B73) implies ( B70 * B71 ) = ( B72 *' B73 ))))
and
L79: (for B74 being (Element of C30) holds (for B75 being (Element of C57) holds (for B76 being (sequence of C30) holds (B75 = B76 implies ( B74 * B75 ) = ( B74 * B76 )))))
and
L80: (( 0. C57 ) = ( 0_. C30 ) & ( 1. C57 ) = ( 1_. C30 ))
and
L81: (for B77 being set holds (B77 in (the carrier of C58) iff B77 is (sequence of C30)))
and
L82: (for B78 , B79 being (Element of C58) holds (for B80 , B81 being (sequence of C30) holds ((B78 = B80 & B79 = B81) implies ( B78 + B79 ) = ( B80 + B81 ))))
and
L83: (for B82 , B83 being (Element of C58) holds (for B84 , B85 being (sequence of C30) holds ((B82 = B84 & B83 = B85) implies ( B82 * B83 ) = ( B84 *' B85 ))))
and
L84: (for B86 being (Element of C30) holds (for B87 being (Element of C58) holds (for B88 being (sequence of C30) holds (B87 = B88 implies ( B86 * B87 ) = ( B86 * B88 )))))
and
L85: (( 0. C58 ) = ( 0_. C30 ) & ( 1. C58 ) = ( 1_. C30 ));
L86:
now
let C59 being set;
L87: (C59 in (the carrier of C57) iff C59 is (sequence of C30)) by L76;
thus L88: (C59 in (the carrier of C57) iff C59 in (the carrier of C58)) by L87 , L81;
end;
L89: (the carrier of C57) = (the carrier of C58) by L86 , TARSKI:1;
L90:
now
let C60 being (Element of C30);
let C61 being (Element of C57);
reconsider D15 = C61 as (sequence of C30) by L76;
reconsider D16 = C61 as (Element of C58) by L86;
reconsider D17 = C60 as (Element of C30);
thus L91: ( (the lmult of C57) . (C60 , C61) ) = ( C60 * C61 )
.= ( D17 * D15 ) by L79
.= ( D17 * D16 ) by L84
.= ( (the lmult of C58) . (C60 , C61) );
end;
L92: (the lmult of C57) = (the lmult of C58) by L90 , L89 , BINOP_1:2;
L93:
now
let C62 being (Element of C57);
let C63 being (Element of C58);
reconsider D18 = C63 as (Element of C57) by L86;
reconsider D19 = C62 as (Element of C58) by L86;
reconsider D20 = C62 as (sequence of C30) by L76;
reconsider D21 = C63 as (sequence of C30) by L81;
thus L94: ( (the multF of C57) . (C62 , C63) ) = ( C62 * D18 )
.= ( D20 *' D21 ) by L78
.= ( D19 * C63 ) by L83
.= ( (the multF of C58) . (C62 , C63) );
end;
L95:
now
let C64 being (Element of C57);
let C65 being (Element of C58);
reconsider D22 = C65 as (Element of C57) by L86;
reconsider D23 = C64 as (Element of C58) by L86;
reconsider D24 = C64 as (sequence of C30) by L76;
reconsider D25 = C65 as (sequence of C30) by L81;
thus L96: ( (the addF of C57) . (C64 , C65) ) = ( C64 + D22 )
.= ( D24 + D25 ) by L77
.= ( D23 + C65 ) by L82
.= ( (the addF of C58) . (C64 , C65) );
end;
L97: (the addF of C57) = (the addF of C58) by L95 , L89 , BINOP_1:2;
thus L98: thesis by L97 , L80 , L85 , L89 , L93 , L92 , BINOP_1:2;
end;
end;
registration
let C66 being  Abelian non  empty doubleLoopStr;
cluster ( Formal-Series C66 ) ->  Abelian;
coherence
proof
let C67 , C68 being (Element of ( Formal-Series C66 ));
reconsider D26 = C67 , D27 = C68 as (sequence of C66) by L31;
thus L100: ( C67 + C68 ) = ( D26 + D27 ) by L31
.= ( C68 + C67 ) by L31;
end;
end;
registration
let C69 being  add-associative non  empty doubleLoopStr;
cluster ( Formal-Series C69 ) ->  add-associative;
coherence
proof
let C70 , C71 , C72 being (Element of ( Formal-Series C69 ));
reconsider D28 = C70 , D29 = C71 , D30 = C72 as (sequence of C69) by L31;
L102: ( C71 + C72 ) = ( D29 + D30 ) by L31;
L103: ( C70 + C71 ) = ( D28 + D29 ) by L31;
thus L104: ( ( C70 + C71 ) + C72 ) = ( ( D28 + D29 ) + D30 ) by L103 , L31
.= ( D28 + ( D29 + D30 ) ) by POLYNOM3:26
.= ( C70 + ( C71 + C72 ) ) by L102 , L31;
end;
end;
registration
let C73 being  right_zeroed non  empty doubleLoopStr;
cluster ( Formal-Series C73 ) ->  right_zeroed;
coherence
proof
let C74 being (Element of ( Formal-Series C73 ));
reconsider D31 = C74 as (sequence of C73) by L31;
L106: ( 0. ( Formal-Series C73 ) ) = ( 0_. C73 ) by L31;
thus L107: ( C74 + ( 0. ( Formal-Series C73 ) ) ) = ( D31 + ( 0_. C73 ) ) by L106 , L31
.= C74 by POLYNOM3:28;
end;
end;
registration
let C75 being  add-associative  right_zeroed  right_complementable non  empty doubleLoopStr;
cluster ( Formal-Series C75 ) ->  right_complementable;
coherence
proof
let C76 being (Element of ( Formal-Series C75 ));
reconsider D32 = C76 as (sequence of C75) by L31;
reconsider D33 = ( - D32 ) as (Element of ( Formal-Series C75 )) by L31;
take D33;
thus L109: ( C76 + D33 ) = ( D32 + ( - D32 ) ) by L31
.= ( D32 - D32 ) by POLYNOM3:def 6
.= ( 0_. C75 ) by POLYNOM3:29
.= ( 0. ( Formal-Series C75 ) ) by L31;
end;
end;
registration
let C77 being  Abelian  add-associative  right_zeroed  commutative non  empty doubleLoopStr;
cluster ( Formal-Series C77 ) ->  commutative;
coherence
proof
let C78 , C79 being (Element of ( Formal-Series C77 ));
reconsider D34 = C78 , D35 = C79 as (sequence of C77) by L31;
thus L111: ( C78 * C79 ) = ( D34 *' D35 ) by L31
.= ( C79 * C78 ) by L31;
end;
end;
registration
let C80 being  Abelian  add-associative  right_zeroed  right_complementable  well-unital  associative  distributive non  empty doubleLoopStr;
cluster ( Formal-Series C80 ) ->  associative;
coherence
proof
let C81 , C82 , C83 being (Element of ( Formal-Series C80 ));
reconsider D36 = C81 , D37 = C82 , D38 = C83 as (sequence of C80) by L31;
L113: ( C82 * C83 ) = ( D37 *' D38 ) by L31;
L114: ( C81 * C82 ) = ( D36 *' D37 ) by L31;
thus L115: ( ( C81 * C82 ) * C83 ) = ( ( D36 *' D37 ) *' D38 ) by L114 , L31
.= ( D36 *' ( D37 *' D38 ) ) by POLYNOM3:33
.= ( C81 * ( C82 * C83 ) ) by L113 , L31;
end;
end;
registration
cluster  add-associative  associative  right_zeroed  left_zeroed  well-unital  right_complementable  distributive for non  empty non  empty non  empty non  empty doubleLoopStr;
existence
proof
take ( F_Real );
thus L117: thesis;
end;
end;
theorem
L119: (for B89 being non  empty set holds (for B90 being non  empty (FinSequence of B89) holds ( B90 /^ 1 ) = ( Del (B90 , 1) )))
proof
let C84 being non  empty set;
let C85 being non  empty (FinSequence of C84);
consider C86 being Nat such that L120: ( C86 + 1 ) = ( len C85 ) by FINSEQ_5:7;
reconsider D39 = C86 as (Element of ( NAT )) by ORDINAL1:def 12;
L121: 1 <= ( len C85 ) by L120 , NAT_1:11;
L122: (( len ( C85 /^ 1 ) ) = ( len ( Del (C85 , 1) ) ) & (for B91 being Nat holds ((1 <= B91 & B91 <= ( len ( C85 /^ 1 ) )) implies ( ( C85 /^ 1 ) . B91 ) = ( ( Del (C85 , 1) ) . B91 ))))
proof
L123: ( len ( C85 /^ 1 ) ) = ( ( D39 + 1 ) - 1 ) by L120 , L121 , RFINSEQ:def 1
.= D39;
L124: 1 in ( dom C85 ) by FINSEQ_5:6;
thus L125: ( len ( C85 /^ 1 ) ) = ( len ( Del (C85 , 1) ) ) by L124 , L120 , L123 , FINSEQ_3:109;
L126: 1 in ( dom C85 ) by FINSEQ_5:6;
let C87 being Nat;
assume that
L127: (1 <= C87 & C87 <= ( len ( C85 /^ 1 ) ));
L128: C87 in ( dom ( C85 /^ 1 ) ) by L127 , FINSEQ_3:25;
thus L129: ( ( C85 /^ 1 ) . C87 ) = ( C85 . ( C87 + 1 ) ) by L128 , L121 , RFINSEQ:def 1
.= ( ( Del (C85 , 1) ) . C87 ) by L120 , L123 , L127 , L126 , FINSEQ_3:111;
end;
thus L130: thesis by L122 , FINSEQ_1:14;
end;
theorem
L131: (for B92 being non  empty set holds (for B93 being non  empty (FinSequence of B92) holds B93 = ( <* ( B93 . 1 ) *> ^ ( Del (B93 , 1) ) )))
proof
let C88 being non  empty set;
let C89 being non  empty (FinSequence of C88);
L132: 1 in ( dom C89 ) by FINSEQ_5:6;
thus L133: C89 = ( <* ( C89 /. 1 ) *> ^ ( C89 /^ 1 ) ) by FINSEQ_5:29
.= ( <* ( C89 . 1 ) *> ^ ( C89 /^ 1 ) ) by L132 , PARTFUN1:def 6
.= ( <* ( C89 . 1 ) *> ^ ( Del (C89 , 1) ) ) by L119;
end;
theorem
L134: (for B94 being  add-associative  right_zeroed  well-unital  right_complementable  left-distributive non  empty doubleLoopStr holds (for B95 being (sequence of B94) holds ( ( 1_. B94 ) *' B95 ) = B95))
proof
let C90 being  add-associative  right_zeroed  well-unital  right_complementable  left-distributive non  empty doubleLoopStr;
let C91 being (sequence of C90);
L135:
now
let C92 being (Element of ( NAT ));
consider C93 being (FinSequence of (the carrier of C90)) such that L136: ( len C93 ) = ( C92 + 1 ) and L137: ( ( ( 1_. C90 ) *' C91 ) . C92 ) = ( Sum C93 ) and L138: (for B96 being (Element of ( NAT )) holds (B96 in ( dom C93 ) implies ( C93 . B96 ) = ( ( ( 1_. C90 ) . ( B96 -' 1 ) ) * ( C91 . ( ( C92 + 1 ) -' B96 ) ) ))) by POLYNOM3:def 9;
L139: 1 in ( dom C93 ) by L136 , CARD_1:27 , FINSEQ_5:6;
L140:
now
let C94 being (Element of ( NAT ));
L141: ( C94 + 1 ) >= 1 by NAT_1:11;
assume L142: C94 in ( dom ( Del (C93 , 1) ) );
L143: C94 <> ( 0 ) by L142 , FINSEQ_3:25;
L144: ( len ( Del (C93 , 1) ) ) = C92 by L136 , L139 , FINSEQ_3:109;
L145: C94 <= C92 by L144 , L142 , FINSEQ_3:25;
L146: ( C94 + 1 ) <= ( C92 + 1 ) by L145 , XREAL_1:6;
L147: ( C94 + 1 ) in ( dom C93 ) by L146 , L136 , L141 , FINSEQ_3:25;
L148: ( ( 0 ) + 1 ) <= C94 by L142 , FINSEQ_3:25;
thus L149: ( ( Del (C93 , 1) ) . C94 ) = ( C93 . ( C94 + 1 ) ) by L148 , L136 , L139 , L145 , FINSEQ_3:111
.= ( ( ( 1_. C90 ) . ( ( C94 + 1 ) -' 1 ) ) * ( C91 . ( ( C92 + 1 ) -' ( C94 + 1 ) ) ) ) by L138 , L147
.= ( ( ( 1_. C90 ) . C94 ) * ( C91 . ( ( C92 + 1 ) -' ( C94 + 1 ) ) ) ) by NAT_D:34
.= ( ( 0. C90 ) * ( C91 . ( ( C92 + 1 ) -' ( C94 + 1 ) ) ) ) by L143 , POLYNOM3:30
.= ( 0. C90 ) by VECTSP_1:7;
end;
L150: ( Sum ( Del (C93 , 1) ) ) = ( 0. C90 ) by L140 , POLYNOM3:1;
L151: C93 = ( <* ( C93 . 1 ) *> ^ ( Del (C93 , 1) ) ) by L136 , L131 , CARD_1:27
.= ( <* ( C93 /. 1 ) *> ^ ( Del (C93 , 1) ) ) by L139 , PARTFUN1:def 6;
L152: ( Sum C93 ) = ( ( Sum <* ( C93 /. 1 ) *> ) + ( Sum ( Del (C93 , 1) ) ) ) by L151 , RLVECT_1:41
.= ( ( C93 /. 1 ) + ( Sum ( Del (C93 , 1) ) ) ) by RLVECT_1:44;
L153: ( C93 /. 1 ) = ( C93 . 1 ) by L139 , PARTFUN1:def 6
.= ( ( ( 1_. C90 ) . ( 1 -' 1 ) ) * ( C91 . ( ( C92 + 1 ) -' 1 ) ) ) by L138 , L139
.= ( ( ( 1_. C90 ) . ( 1 -' 1 ) ) * ( C91 . C92 ) ) by NAT_D:34
.= ( ( ( 1_. C90 ) . ( 0 ) ) * ( C91 . C92 ) ) by XREAL_1:232
.= ( ( 1_ C90 ) * ( C91 . C92 ) ) by POLYNOM3:30
.= ( C91 . C92 ) by VECTSP_1:def 8;
thus L154: ( ( ( 1_. C90 ) *' C91 ) . C92 ) = ( C91 . C92 ) by L153 , L137 , L152 , L150 , RLVECT_1:4;
end;
thus L155: thesis by L135 , FUNCT_2:63;
end;
L156:
now
let C95 being  add-associative  right_zeroed  right_complementable  distributive  well-unital non  empty doubleLoopStr;
set D40 = ( Formal-Series C95 );
let C96 , C97 being (Element of D40);
reconsider D41 = C96 , D42 = C97 as (sequence of C95) by L31;
assume L157: C97 = ( 1_. C95 );
thus L158: ( C96 * C97 ) = ( D41 *' D42 ) by L31
.= C96 by L157 , POLYNOM3:35;
thus L159: ( C97 * C96 ) = ( D42 *' D41 ) by L31
.= C96 by L157 , L134;
end;
registration
let C98 being  right_zeroed  add-associative  right_complementable  distributive  well-unital non  empty doubleLoopStr;
cluster ( Formal-Series C98 ) ->  well-unital;
coherence
proof
let C99 being (Element of ( Formal-Series C98 ));
set D43 = ( Formal-Series C98 );
L160: ( 1. D43 ) = ( 1_. C98 ) by L31;
thus L161: thesis by L160 , L156;
end;
end;
registration
let C100 being  Abelian  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
cluster ( Formal-Series C100 ) ->  right-distributive;
coherence
proof
let C101 , C102 , C103 being (Element of ( Formal-Series C100 ));
reconsider D44 = C101 , D45 = C102 , D46 = C103 as (sequence of C100) by L31;
L163: (( C101 * C102 ) = ( D44 *' D45 ) & ( C101 * C103 ) = ( D44 *' D46 )) by L31;
L164: ( C102 + C103 ) = ( D45 + D46 ) by L31;
thus L165: ( C101 * ( C102 + C103 ) ) = ( D44 *' ( D45 + D46 ) ) by L164 , L31
.= ( ( D44 *' D45 ) + ( D44 *' D46 ) ) by POLYNOM3:31
.= ( ( C101 * C102 ) + ( C101 * C103 ) ) by L163 , L31;
end;
cluster ( Formal-Series C100 ) ->  left-distributive;
coherence
proof
let C104 , C105 , C106 being (Element of ( Formal-Series C100 ));
reconsider D47 = C104 , D48 = C105 , D49 = C106 as (sequence of C100) by L31;
L166: (( C105 * C104 ) = ( D48 *' D47 ) & ( C106 * C104 ) = ( D49 *' D47 )) by L31;
L167: ( C105 + C106 ) = ( D48 + D49 ) by L31;
thus L168: ( ( C105 + C106 ) * C104 ) = ( ( D48 + D49 ) *' D47 ) by L167 , L31
.= ( ( D48 *' D47 ) + ( D49 *' D47 ) ) by POLYNOM3:32
.= ( ( C105 * C104 ) + ( C106 * C104 ) ) by L166 , L31;
end;
end;
theorem
L170: (for B97 being  Abelian  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B98 being (Element of B97) holds (for B99 , B100 being (sequence of B97) holds ( B98 * ( B99 + B100 ) ) = ( ( B98 * B99 ) + ( B98 * B100 ) ))))
proof
let C107 being  Abelian  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C108 being (Element of C107);
let C109 , C110 being (sequence of C107);
L171: (for B101 being (Element of ( NAT )) holds ( ( C108 * ( C109 + C110 ) ) . B101 ) = ( ( ( C108 * C109 ) + ( C108 * C110 ) ) . B101 ))
proof
let C111 being (Element of ( NAT ));
L172: ( C108 * ( ( C109 + C110 ) . C111 ) ) = ( C108 * ( ( C109 . C111 ) + ( C110 . C111 ) ) ) by NORMSP_1:def 2
.= ( ( C108 * ( C109 . C111 ) ) + ( C108 * ( C110 . C111 ) ) ) by VECTSP_1:def 7
.= ( ( ( C108 * C109 ) . C111 ) + ( C108 * ( C110 . C111 ) ) ) by POLYNOM5:def 3
.= ( ( ( C108 * C109 ) . C111 ) + ( ( C108 * C110 ) . C111 ) ) by POLYNOM5:def 3
.= ( ( ( C108 * C109 ) + ( C108 * C110 ) ) . C111 ) by NORMSP_1:def 2;
thus L173: thesis by L172 , POLYNOM5:def 3;
end;
thus L174: thesis by L171 , FUNCT_2:63;
end;
theorem
L175: (for B102 being  Abelian  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B103 , B104 being (Element of B102) holds (for B105 being (sequence of B102) holds ( ( B103 + B104 ) * B105 ) = ( ( B103 * B105 ) + ( B104 * B105 ) ))))
proof
let C112 being  Abelian  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C113 , C114 being (Element of C112);
let C115 being (sequence of C112);
L176: (for B106 being (Element of ( NAT )) holds ( ( ( C113 + C114 ) * C115 ) . B106 ) = ( ( ( C113 * C115 ) + ( C114 * C115 ) ) . B106 ))
proof
let C116 being (Element of ( NAT ));
thus L177: ( ( ( C113 + C114 ) * C115 ) . C116 ) = ( ( C113 + C114 ) * ( C115 . C116 ) ) by POLYNOM5:def 3
.= ( ( C113 * ( C115 . C116 ) ) + ( C114 * ( C115 . C116 ) ) ) by VECTSP_1:def 7
.= ( ( ( C113 * C115 ) . C116 ) + ( C114 * ( C115 . C116 ) ) ) by POLYNOM5:def 3
.= ( ( ( C113 * C115 ) . C116 ) + ( ( C114 * C115 ) . C116 ) ) by POLYNOM5:def 3
.= ( ( ( C113 * C115 ) + ( C114 * C115 ) ) . C116 ) by NORMSP_1:def 2;
end;
thus L178: thesis by L176 , FUNCT_2:63;
end;
theorem
L179: (for B107 being  associative non  empty doubleLoopStr holds (for B108 , B109 being (Element of B107) holds (for B110 being (sequence of B107) holds ( ( B108 * B109 ) * B110 ) = ( B108 * ( B109 * B110 ) ))))
proof
let C117 being  associative non  empty doubleLoopStr;
let C118 , C119 being (Element of C117);
let C120 being (sequence of C117);
L180: (for B111 being (Element of ( NAT )) holds ( ( ( C118 * C119 ) * C120 ) . B111 ) = ( ( C118 * ( C119 * C120 ) ) . B111 ))
proof
let C121 being (Element of ( NAT ));
thus L181: ( ( ( C118 * C119 ) * C120 ) . C121 ) = ( ( C118 * C119 ) * ( C120 . C121 ) ) by POLYNOM5:def 3
.= ( C118 * ( C119 * ( C120 . C121 ) ) ) by GROUP_1:def 3
.= ( C118 * ( ( C119 * C120 ) . C121 ) ) by POLYNOM5:def 3
.= ( ( C118 * ( C119 * C120 ) ) . C121 ) by POLYNOM5:def 3;
end;
thus L182: thesis by L180 , FUNCT_2:63;
end;
theorem
L183: (for B112 being  associative  well-unital non  empty doubleLoopStr holds (for B113 being (sequence of B112) holds ( ( 1. B112 ) * B113 ) = B113))
proof
let C122 being  associative  well-unital non  empty doubleLoopStr;
let C123 being (sequence of C122);
L184: (for B114 being (Element of ( NAT )) holds ( ( ( 1. C122 ) * C123 ) . B114 ) = ( C123 . B114 ))
proof
let C124 being (Element of ( NAT ));
thus L185: ( ( ( 1. C122 ) * C123 ) . C124 ) = ( ( 1. C122 ) * ( C123 . C124 ) ) by POLYNOM5:def 3
.= ( C123 . C124 ) by VECTSP_1:def 8;
end;
thus L186: thesis by L184 , FUNCT_2:63;
end;
registration
let C125 being  Abelian  add-associative  associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr;
cluster ( Formal-Series C125 ) ->  vector-distributive  scalar-distributive  scalar-associative  scalar-unital;
coherence
proof
set D50 = ( Formal-Series C125 );
thus L187: D50 is  vector-distributive
proof
let C126 being (Element of C125);
let C127 , C128 being (Element of ( Formal-Series C125 ));
reconsider D51 = C127 , D52 = C128 as (sequence of C125) by L31;
reconsider D53 = C126 as (Element of C125);
reconsider D54 = ( C127 + C128 ) as (Element of ( Formal-Series C125 ));
L188: ( C126 * C127 ) = ( C126 * D51 ) by L31;
reconsider D55 = D54 as (sequence of C125) by L31;
L189: ( C126 * C128 ) = ( C126 * D52 ) by L31;
L190: ( C126 * D54 ) = ( C126 * D55 ) by L31;
thus L191: ( C126 * ( C127 + C128 ) ) = ( C126 * ( D51 + D52 ) ) by L190 , L31
.= ( ( D53 * D51 ) + ( D53 * D52 ) ) by L170
.= ( ( C126 * C127 ) + ( C126 * C128 ) ) by L188 , L189 , L31;
end;

thus L192: D50 is  scalar-distributive
proof
let C129 , C130 being (Element of C125);
let C131 being (Element of ( Formal-Series C125 ));
reconsider D56 = C131 as (sequence of C125) by L31;
reconsider D57 = C129 , D58 = C130 as (Element of C125);
L193: ( C129 * C131 ) = ( C129 * D56 ) by L31;
L194: ( C130 * C131 ) = ( C130 * D56 ) by L31;
thus L195: ( ( C129 + C130 ) * C131 ) = ( ( D57 + D58 ) * D56 ) by L31
.= ( ( D57 * D56 ) + ( D58 * D56 ) ) by L175
.= ( ( C129 * C131 ) + ( C130 * C131 ) ) by L193 , L194 , L31;
end;

thus L196: D50 is  scalar-associative
proof
let C132 , C133 being (Element of C125);
let C134 being (Element of ( Formal-Series C125 ));
reconsider D59 = C134 as (sequence of C125) by L31;
reconsider D60 = C132 , D61 = C133 as (Element of C125);
L197: ( C133 * C134 ) = ( C133 * D59 ) by L31;
thus L198: ( ( C132 * C133 ) * C134 ) = ( ( D60 * D61 ) * D59 ) by L31
.= ( D60 * ( D61 * D59 ) ) by L179
.= ( C132 * ( C133 * C134 ) ) by L197 , L31;
end;

let C135 being (Element of D50);
reconsider D62 = C135 as (sequence of C125) by L31;
thus L199: ( ( 1. C125 ) * C135 ) = ( ( 1. C125 ) * D62 ) by L31
.= C135 by L183;
end;
end;
theorem
L201: (for B115 being  Abelian  left_zeroed  add-associative  associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B116 being (Element of B115) holds (for B117 , B118 being (sequence of B115) holds ( B116 * ( B117 *' B118 ) ) = ( ( B116 * B117 ) *' B118 ))))
proof
let C136 being  Abelian  left_zeroed  add-associative  associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
let C137 being (Element of C136);
let C138 , C139 being (sequence of C136);
L202: (for B119 being (Element of ( NAT )) holds ( ( C137 * ( C138 *' C139 ) ) . B119 ) = ( ( ( C137 * C138 ) *' C139 ) . B119 ))
proof
let C140 being (Element of ( NAT ));
consider C141 being (FinSequence of (the carrier of C136)) such that L203: ( len C141 ) = ( C140 + 1 ) and L204: ( ( C138 *' C139 ) . C140 ) = ( Sum C141 ) and L205: (for B120 being (Element of ( NAT )) holds (B120 in ( dom C141 ) implies ( C141 . B120 ) = ( ( C138 . ( B120 -' 1 ) ) * ( C139 . ( ( C140 + 1 ) -' B120 ) ) ))) by POLYNOM3:def 9;
consider C142 being (FinSequence of (the carrier of C136)) such that L206: ( len C142 ) = ( C140 + 1 ) and L207: ( ( ( C137 * C138 ) *' C139 ) . C140 ) = ( Sum C142 ) and L208: (for B121 being (Element of ( NAT )) holds (B121 in ( dom C142 ) implies ( C142 . B121 ) = ( ( ( C137 * C138 ) . ( B121 -' 1 ) ) * ( C139 . ( ( C140 + 1 ) -' B121 ) ) ))) by POLYNOM3:def 9;
L209: ( dom ( C137 * C141 ) ) = ( dom C141 ) by POLYNOM1:def 1
.= ( dom C142 ) by L203 , L206 , FINSEQ_3:29;
L210: (for B122 being Nat holds (B122 in ( dom C142 ) implies ( C142 . B122 ) = ( ( C137 * C141 ) . B122 )))
proof
let C143 being Nat;
assume that
L211: C143 in ( dom C142 );
L212: C143 in ( dom C141 ) by L203 , L206 , L211 , FINSEQ_3:29;
L213: ( ( C138 . ( C143 -' 1 ) ) * ( C139 . ( ( C140 + 1 ) -' C143 ) ) ) = ( C141 . C143 ) by L212 , L205
.= ( C141 /. C143 ) by L212 , PARTFUN1:def 6;
thus L214: ( C142 . C143 ) = ( ( ( C137 * C138 ) . ( C143 -' 1 ) ) * ( C139 . ( ( C140 + 1 ) -' C143 ) ) ) by L208 , L211
.= ( ( C137 * ( C138 . ( C143 -' 1 ) ) ) * ( C139 . ( ( C140 + 1 ) -' C143 ) ) ) by POLYNOM5:def 3
.= ( C137 * ( C141 /. C143 ) ) by L213 , GROUP_1:def 3
.= ( ( C137 * C141 ) /. C143 ) by L212 , POLYNOM1:def 1
.= ( ( C137 * C141 ) . C143 ) by L209 , L211 , PARTFUN1:def 6;
end;
thus L215: ( ( C137 * ( C138 *' C139 ) ) . C140 ) = ( C137 * ( Sum C141 ) ) by L204 , POLYNOM5:def 3
.= ( Sum ( C137 * C141 ) ) by BINOM:4
.= ( ( ( C137 * C138 ) *' C139 ) . C140 ) by L207 , L209 , L210 , FINSEQ_1:13;
end;
thus L216: thesis by L202 , FUNCT_2:63;
end;
registration
let C144 being  Abelian  left_zeroed  add-associative  associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
cluster ( Formal-Series C144 ) ->  mix-associative;
coherence
proof
let C145 being (Element of C144);
let C146 , C147 being (Element of ( Formal-Series C144 ));
reconsider D63 = C146 , D64 = C147 as (Element of ( Formal-Series C144 ));
reconsider D65 = D63 , D66 = D64 as (sequence of C144) by L31;
L217: ( C145 * C146 ) = ( C145 * D65 ) by L31;
L218: ( C146 * C147 ) = ( D65 *' D66 ) by L31;
thus L219: ( C145 * ( C146 * C147 ) ) = ( C145 * ( D65 *' D66 ) ) by L218 , L31
.= ( ( C145 * D65 ) *' D66 ) by L201
.= ( ( C145 * C146 ) * C147 ) by L217 , L31;
end;
end;
definition
let C148 being 1-sorted;
let C149 being AlgebraStr over C148;
mode Subalgebra of C149
 -> AlgebraStr over C148
means :L221: ((the carrier of it) c= (the carrier of C149) & ( 1. it ) = ( 1. C149 ) & ( 0. it ) = ( 0. C149 ) & (the addF of it) = ( (the addF of C149) || (the carrier of it) ) & (the multF of it) = ( (the multF of C149) || (the carrier of it) ) & (the lmult of it) = ( (the lmult of C149) | [: (the carrier of C148) , (the carrier of it) :] ));
existence
proof
take C149;
thus L222: thesis;
end;
end;
theorem
L224: (for B123 being 1-sorted holds (for B124 being AlgebraStr over B123 holds B124 is (Subalgebra of B124)))
proof
let C150 being 1-sorted;
let C151 being AlgebraStr over C150;
thus L225: ((the carrier of C151) c= (the carrier of C151) & ( 1. C151 ) = ( 1. C151 ) & ( 0. C151 ) = ( 0. C151 ) & (the addF of C151) = ( (the addF of C151) || (the carrier of C151) ) & (the multF of C151) = ( (the multF of C151) || (the carrier of C151) ) & (the lmult of C151) = ( (the lmult of C151) | [: (the carrier of C150) , (the carrier of C151) :] ));
end;
theorem
L226: (for B125 being 1-sorted holds (for B126 , B127 , B128 being AlgebraStr over B125 holds ((B126 is (Subalgebra of B127) & B127 is (Subalgebra of B128)) implies B126 is (Subalgebra of B128))))
proof
let C152 being 1-sorted;
let C153 , C154 , C155 being AlgebraStr over C152;
assume that
L227: C153 is (Subalgebra of C154)
and
L228: C154 is (Subalgebra of C155);
L229: (the carrier of C153) c= (the carrier of C154) by L227 , L221;
L230: [: (the carrier of C153) , (the carrier of C153) :] c= [: (the carrier of C154) , (the carrier of C154) :] by L229 , ZFMISC_1:96;
L231: (the carrier of C154) c= (the carrier of C155) by L228 , L221;
thus L232: (the carrier of C153) c= (the carrier of C155) by L231 , L229 , XBOOLE_1:1;
thus L233: ( 1. C153 ) = ( 1. C154 ) by L227 , L221
.= ( 1. C155 ) by L228 , L221;
thus L234: ( 0. C153 ) = ( 0. C154 ) by L227 , L221
.= ( 0. C155 ) by L228 , L221;
thus L235: (the addF of C153) = ( (the addF of C154) || (the carrier of C153) ) by L227 , L221
.= ( ( (the addF of C155) || (the carrier of C154) ) || (the carrier of C153) ) by L228 , L221
.= ( (the addF of C155) || (the carrier of C153) ) by L230 , FUNCT_1:51;
thus L236: (the multF of C153) = ( (the multF of C154) || (the carrier of C153) ) by L227 , L221
.= ( ( (the multF of C155) || (the carrier of C154) ) || (the carrier of C153) ) by L228 , L221
.= ( (the multF of C155) || (the carrier of C153) ) by L230 , FUNCT_1:51;
L237: [: (the carrier of C152) , (the carrier of C153) :] c= [: (the carrier of C152) , (the carrier of C154) :] by L229 , ZFMISC_1:96;
thus L238: (the lmult of C153) = ( (the lmult of C154) | [: (the carrier of C152) , (the carrier of C153) :] ) by L227 , L221
.= ( ( (the lmult of C155) | [: (the carrier of C152) , (the carrier of C154) :] ) | [: (the carrier of C152) , (the carrier of C153) :] ) by L228 , L221
.= ( (the lmult of C155) | [: (the carrier of C152) , (the carrier of C153) :] ) by L237 , FUNCT_1:51;
end;
theorem
L239: (for B129 being 1-sorted holds (for B130 , B131 being AlgebraStr over B129 holds ((B130 is (Subalgebra of B131) & B131 is (Subalgebra of B130)) implies ( the AlgebraStr of B130 ) = ( the AlgebraStr of B131 ))))
proof
let C156 being 1-sorted;
let C157 , C158 being AlgebraStr over C156;
assume that
L240: C157 is (Subalgebra of C158)
and
L241: C158 is (Subalgebra of C157);
L242: (the carrier of C158) c= (the carrier of C157) by L241 , L221;
L243: (the carrier of C157) c= (the carrier of C158) by L240 , L221;
L244: (the carrier of C157) = (the carrier of C158) by L243 , L242 , XBOOLE_0:def 10;
L245: ( dom (the lmult of C158) ) = [: (the carrier of C156) , (the carrier of C158) :] by L28;
L246: (the lmult of C157) = ( (the lmult of C158) | [: (the carrier of C156) , (the carrier of C157) :] ) by L240 , L221
.= (the lmult of C158) by L242 , L245 , RELAT_1:68 , ZFMISC_1:96;
L247: ( dom (the addF of C158) ) = [: (the carrier of C158) , (the carrier of C158) :] by L25;
L248: (( 0. C157 ) = ( 0. C158 ) & ( 1. C157 ) = ( 1. C158 )) by L240 , L221;
L249: ( dom (the multF of C158) ) = [: (the carrier of C158) , (the carrier of C158) :] by L25;
L250: (the multF of C157) = ( (the multF of C158) || (the carrier of C157) ) by L240 , L221
.= (the multF of C158) by L244 , L249 , RELAT_1:68;
L251: (the addF of C157) = ( (the addF of C158) || (the carrier of C157) ) by L240 , L221
.= (the addF of C158) by L244 , L247 , RELAT_1:68;
thus L252: thesis by L251 , L243 , L242 , L250 , L246 , L248 , XBOOLE_0:def 10;
end;
theorem
L253: (for B132 being 1-sorted holds (for B133 , B134 being AlgebraStr over B132 holds (( the AlgebraStr of B133 ) = ( the AlgebraStr of B134 ) implies B133 is (Subalgebra of B134))))
proof
let C159 being 1-sorted;
let C160 , C161 being AlgebraStr over C159;
assume that
L254: ( the AlgebraStr of C160 ) = ( the AlgebraStr of C161 );
thus L255: (the carrier of C160) c= (the carrier of C161) by L254;
thus L256: ( 1. C160 ) = ( 1. C161 ) by L254;
thus L257: ( 0. C160 ) = ( 0. C161 ) by L254;
L258: ( dom (the addF of C161) ) = [: (the carrier of C161) , (the carrier of C161) :] by L25;
thus L259: (the addF of C160) = ( (the addF of C161) || (the carrier of C160) ) by L258 , L254 , RELAT_1:68;
L260: ( dom (the multF of C161) ) = [: (the carrier of C161) , (the carrier of C161) :] by L25;
thus L261: (the multF of C160) = ( (the multF of C161) || (the carrier of C160) ) by L260 , L254 , RELAT_1:68;
L262: ( dom (the lmult of C161) ) = [: (the carrier of C159) , (the carrier of C161) :] by L28;
thus L263: thesis by L262 , L254 , RELAT_1:68;
end;
registration
let C162 being non  empty 1-sorted;
cluster non  empty  strict for AlgebraStr over C162;
existence
proof
L264: ( 0 ) in { ( 0 ) } by TARSKI:def 1;
reconsider D67 = ( [: (the carrier of C162) , { ( 0 ) } :] --> ( 0 ) ) as (Function of [: (the carrier of C162) , { ( 0 ) } :] , { ( 0 ) }) by L264 , FUNCOP_1:45;
reconsider D68 = ( 0 ) as (Element of { ( 0 ) }) by TARSKI:def 1;
set D69 = { ( 0 ) };
set D70 = the (BinOp of D69);
take D71 = AlgebraStr (# { ( 0 ) } , D70 , D70 , D68 , D68 , D67 #);
thus L265: D71 is non  empty;
thus L266: thesis;
end;
end;
registration
let C163 being 1-sorted;
let C164 being AlgebraStr over C163;
cluster  strict for (Subalgebra of C164);
existence
proof
reconsider D72 = AlgebraStr (# (the carrier of C164) , (the addF of C164) , (the multF of C164) , ( 0. C164 ) , ( 1. C164 ) , (the lmult of C164) #) as (Subalgebra of C164) by L253;
take D72;
thus L268: thesis;
end;
end;
registration
let C165 being non  empty 1-sorted;
let C166 being non  empty AlgebraStr over C165;
cluster  strict non  empty for (Subalgebra of C166);
existence
proof
reconsider D73 = AlgebraStr (# (the carrier of C166) , (the addF of C166) , (the multF of C166) , ( 0. C166 ) , ( 1. C166 ) , (the lmult of C166) #) as (Subalgebra of C166) by L253;
take D73;
thus L270: thesis;
end;
end;
definition
let C167 being non  empty multMagma;
let C168 being non  empty AlgebraStr over C167;
let C169 being (Subset of C168);
attr C169 is  opers_closed
means
:L272: (C169 is  linearly-closed & (for B135 , B136 being (Element of C168) holds ((B135 in C169 & B136 in C169) implies ( B135 * B136 ) in C169)) & ( 1. C168 ) in C169 & ( 0. C168 ) in C169);
end;
theorem
L274: (for B137 being non  empty multMagma holds (for B138 being non  empty AlgebraStr over B137 holds (for B139 being non  empty (Subalgebra of B138) holds (for B140 , B141 being (Element of B138) holds (for B142 , B143 being (Element of B139) holds ((B140 = B142 & B141 = B143) implies ( B140 + B141 ) = ( B142 + B143 )))))))
proof
let C170 being non  empty multMagma;
let C171 being non  empty AlgebraStr over C170;
let C172 being non  empty (Subalgebra of C171);
let C173 , C174 being (Element of C171);
let C175 , C176 being (Element of C172);
assume that
L275: (C173 = C175 & C174 = C176);
L276: [ C175 , C176 ] in [: (the carrier of C172) , (the carrier of C172) :] by ZFMISC_1:87;
thus L277: ( C173 + C174 ) = ( ( (the addF of C171) || (the carrier of C172) ) . [ C175 , C176 ] ) by L276 , L275 , FUNCT_1:49
.= ( C175 + C176 ) by L221;
end;
theorem
L278: (for B144 being non  empty multMagma holds (for B145 being non  empty AlgebraStr over B144 holds (for B146 being non  empty (Subalgebra of B145) holds (for B147 , B148 being (Element of B145) holds (for B149 , B150 being (Element of B146) holds ((B147 = B149 & B148 = B150) implies ( B147 * B148 ) = ( B149 * B150 )))))))
proof
let C177 being non  empty multMagma;
let C178 being non  empty AlgebraStr over C177;
let C179 being non  empty (Subalgebra of C178);
let C180 , C181 being (Element of C178);
let C182 , C183 being (Element of C179);
assume that
L279: (C180 = C182 & C181 = C183);
L280: [ C182 , C183 ] in [: (the carrier of C179) , (the carrier of C179) :] by ZFMISC_1:87;
thus L281: ( C180 * C181 ) = ( ( (the multF of C178) || (the carrier of C179) ) . [ C182 , C183 ] ) by L280 , L279 , FUNCT_1:49
.= ( C182 * C183 ) by L221;
end;
theorem
L282: (for B151 being non  empty multMagma holds (for B152 being non  empty AlgebraStr over B151 holds (for B153 being non  empty (Subalgebra of B152) holds (for B154 being (Element of B151) holds (for B155 being (Element of B152) holds (for B156 being (Element of B153) holds (B155 = B156 implies ( B154 * B155 ) = ( B154 * B156 ))))))))
proof
let C184 being non  empty multMagma;
let C185 being non  empty AlgebraStr over C184;
let C186 being non  empty (Subalgebra of C185);
let C187 being (Element of C184);
let C188 being (Element of C185);
let C189 being (Element of C186);
assume that
L283: C188 = C189;
L284: [ C187 , C189 ] in [: (the carrier of C184) , (the carrier of C186) :] by ZFMISC_1:87;
thus L285: ( C187 * C188 ) = ( ( (the lmult of C185) | [: (the carrier of C184) , (the carrier of C186) :] ) . [ C187 , C189 ] ) by L284 , L283 , FUNCT_1:49
.= ( C187 * C189 ) by L221;
end;
theorem
L286: (for B157 being non  empty multMagma holds (for B158 being non  empty AlgebraStr over B157 holds (for B159 being non  empty (Subalgebra of B158) holds (ex B160 being (Subset of B158) st ((the carrier of B159) = B160 & B160 is  opers_closed)))))
proof
let C190 being non  empty multMagma;
let C191 being non  empty AlgebraStr over C190;
let C192 being non  empty (Subalgebra of C191);
take D74 = (the carrier of C192);
L287: (( 1. C191 ) = ( 1. C192 ) & ( 0. C191 ) = ( 0. C192 )) by L221;
reconsider D75 = D74 as (Subset of C191) by L221;
L288: (for B161 being (Element of C190) holds (for B162 being (Element of C191) holds (B162 in D75 implies ( B161 * B162 ) in D75)))
proof
let C193 being (Element of C190);
let C194 being (Element of C191);
assume L289: C194 in D75;
reconsider D76 = C194 as (Element of C192) by L289;
L290: ( C193 * C194 ) = ( C193 * D76 ) by L282;
thus L291: thesis by L290;
end;
L292: (for B163 , B164 being (Element of C191) holds ((B163 in D75 & B164 in D75) implies ( B163 * B164 ) in D75))
proof
let C195 , C196 being (Element of C191);
assume that
L293: (C195 in D75 & C196 in D75);
reconsider D77 = C195 , D78 = C196 as (Element of C191);
reconsider D79 = D77 , D80 = D78 as (Element of C192) by L293;
L294: ( C195 * C196 ) = ( D79 * D80 ) by L278;
thus L295: thesis by L294;
end;
L296: (for B165 , B166 being (Element of C191) holds ((B165 in D75 & B166 in D75) implies ( B165 + B166 ) in D75))
proof
let C197 , C198 being (Element of C191);
assume L297: (C197 in D75 & C198 in D75);
reconsider D81 = C198 , D82 = C197 as (Element of C192) by L297;
L298: ( C197 + C198 ) = ( D82 + D81 ) by L274;
thus L299: thesis by L298;
end;
L300: D75 is  linearly-closed by L296 , L288 , VECTSP_4:def 1;
thus L301: thesis by L300 , L287 , L292 , L272;
end;
theorem
L302: (for B167 being non  empty multMagma holds (for B168 being non  empty AlgebraStr over B167 holds (for B169 being (Subset of B168) holds (B169 is  opers_closed implies (ex B170 being  strict (Subalgebra of B168) st (the carrier of B170) = B169)))))
proof
let C199 being non  empty multMagma;
let C200 being non  empty AlgebraStr over C199;
let C201 being (Subset of C200);
assume that
L303: C201 is  opers_closed;
reconsider D83 = ( 0. C200 ) as (Element of C201) by L303 , L272;
reconsider D84 = ( (the lmult of C200) | [: (the carrier of C199) , C201 :] ) as Function;
L304: (for B171 being set holds (B171 in [: (the carrier of C199) , C201 :] implies ( D84 . B171 ) in C201))
proof
L305: C201 is  linearly-closed by L303 , L272;
let C202 being set;
assume that
L306: C202 in [: (the carrier of C199) , C201 :];
consider C203 , C204 being set such that L307: C203 in (the carrier of C199) and L308: C204 in C201 and L309: C202 = [ C203 , C204 ] by L306 , ZFMISC_1:def 2;
reconsider D85 = C204 as (Element of C200) by L308;
reconsider D86 = C203 as (Element of C199) by L307;
L310: ( D84 . C202 ) = ( D86 * D85 ) by L306 , L309 , FUNCT_1:49;
thus L311: thesis by L310 , L308 , L305 , VECTSP_4:def 1;
end;
L312: [: (the carrier of C199) , C201 :] c= [: (the carrier of C199) , (the carrier of C200) :] by ZFMISC_1:96;
L313: [: (the carrier of C199) , C201 :] c= ( dom (the lmult of C200) ) by L312 , L28;
L314: ( dom D84 ) = [: (the carrier of C199) , C201 :] by L313 , RELAT_1:62;
reconsider D87 = D84 as (Function of [: (the carrier of C199) , C201 :] , C201) by L314 , L304 , FUNCT_2:3;
reconsider D88 = ( (the addF of C200) || C201 ) as Function;
reconsider D89 = ( (the multF of C200) || C201 ) as Function;
L315: (for B172 being set holds (B172 in [: C201 , C201 :] implies ( D89 . B172 ) in C201))
proof
let C205 being set;
assume that
L316: C205 in [: C201 , C201 :];
consider C206 , C207 being set such that L317: (C206 in C201 & C207 in C201) and L318: C205 = [ C206 , C207 ] by L316 , ZFMISC_1:def 2;
reconsider D90 = C206 , D91 = C207 as (Element of C200) by L317;
L319: ( D89 . C205 ) = ( D90 * D91 ) by L316 , L318 , FUNCT_1:49;
thus L320: thesis by L319 , L303 , L317 , L272;
end;
L321: [: C201 , C201 :] c= [: (the carrier of C200) , (the carrier of C200) :] by ZFMISC_1:96;
L322: [: C201 , C201 :] c= ( dom (the multF of C200) ) by L321 , L25;
L323: ( dom D89 ) = [: C201 , C201 :] by L322 , RELAT_1:62;
reconsider D92 = D89 as (BinOp of C201) by L323 , L315 , FUNCT_2:3;
L324: (( dom D88 ) = [: C201 , C201 :] & (for B173 being set holds (B173 in [: C201 , C201 :] implies ( D88 . B173 ) in C201)))
proof
L325: [: C201 , C201 :] c= ( dom (the addF of C200) ) by L321 , L25;
thus L326: ( dom D88 ) = [: C201 , C201 :] by L325 , RELAT_1:62;
let C208 being set;
assume that
L327: C208 in [: C201 , C201 :];
consider C209 , C210 being set such that L328: (C209 in C201 & C210 in C201) and L329: C208 = [ C209 , C210 ] by L327 , ZFMISC_1:def 2;
L330: C201 is  linearly-closed by L303 , L272;
reconsider D93 = C209 , D94 = C210 as (Element of C200) by L328;
L331: ( D88 . C208 ) = ( D93 + D94 ) by L327 , L329 , FUNCT_1:49;
thus L332: thesis by L331 , L328 , L330 , VECTSP_4:def 1;
end;
reconsider D95 = D88 as (BinOp of C201) by L324 , FUNCT_2:3;
reconsider D96 = ( 1. C200 ) as (Element of C201) by L303 , L272;
set D97 = AlgebraStr (# C201 , D95 , D92 , D83 , D96 , D87 #);
L333: (( 1. D97 ) = ( 1. C200 ) & ( 0. D97 ) = ( 0. C200 ));
reconsider D98 = D97 as  strict (Subalgebra of C200) by L333 , L221;
take D98;
thus L334: thesis;
end;
theorem
L335: (for B174 being non  empty multMagma holds (for B175 being non  empty AlgebraStr over B174 holds (for B176 being non  empty (Subset of B175) holds (for B177 being (Subset-Family of B175) holds ((for B178 being set holds (B178 in B177 iff (B178 c= (the carrier of B175) & (ex B179 being (Subalgebra of B175) st (B178 = (the carrier of B179) & B176 c= B178))))) implies ( meet B177 ) is  opers_closed)))))
proof
let C211 being non  empty multMagma;
let C212 being non  empty AlgebraStr over C211;
let C213 being non  empty (Subset of C212);
let C214 being (Subset-Family of C212);
assume that
L336: (for B180 being set holds (B180 in C214 iff (B180 c= (the carrier of C212) & (ex B181 being (Subalgebra of C212) st (B180 = (the carrier of B181) & C213 c= B180)))));
L337: C212 is (Subalgebra of C212) by L224;
L338: C214 <> ( {} ) by L337 , L336;
L339: (for B182 , B183 being (Element of C212) holds ((B182 in ( meet C214 ) & B183 in ( meet C214 )) implies ( B182 + B183 ) in ( meet C214 )))
proof
let C215 , C216 being (Element of C212);
assume that
L340: (C215 in ( meet C214 ) & C216 in ( meet C214 ));
L341:
now
reconsider D99 = C215 , D100 = C216 as (Element of C212);
let C217 being set;
assume L342: C217 in C214;
consider C218 being (Subalgebra of C212) such that L343: C217 = (the carrier of C218) and L344: C213 c= C217 by L342 , L336;
reconsider D101 = C218 as non  empty (Subalgebra of C212) by L343 , L344;
reconsider D102 = D99 , D103 = D100 as (Element of D101) by L340 , L342 , L343 , SETFAM_1:def 1;
L345: ( C215 + C216 ) = ( D102 + D103 ) by L274;
thus L346: ( C215 + C216 ) in C217 by L345 , L343;
end;
thus L347: thesis by L341 , L338 , SETFAM_1:def 1;
end;
L348: (for B184 being (Element of C211) holds (for B185 being (Element of C212) holds (B185 in ( meet C214 ) implies ( B184 * B185 ) in ( meet C214 ))))
proof
let C219 being (Element of C211);
let C220 being (Element of C212);
assume that
L349: C220 in ( meet C214 );
L350:
now
let C221 being set;
assume L351: C221 in C214;
consider C222 being (Subalgebra of C212) such that L352: C221 = (the carrier of C222) and L353: C213 c= C221 by L351 , L336;
reconsider D104 = C222 as non  empty (Subalgebra of C212) by L352 , L353;
reconsider D105 = C220 as (Element of D104) by L349 , L351 , L352 , SETFAM_1:def 1;
L354: ( C219 * C220 ) = ( C219 * D105 ) by L282;
thus L355: ( C219 * C220 ) in C221 by L354 , L352;
end;
thus L356: thesis by L350 , L338 , SETFAM_1:def 1;
end;
thus L357: ( meet C214 ) is  linearly-closed by L348 , L339 , VECTSP_4:def 1;
thus L358: (for B186 , B187 being (Element of C212) holds ((B186 in ( meet C214 ) & B187 in ( meet C214 )) implies ( B186 * B187 ) in ( meet C214 )))
proof
let C223 , C224 being (Element of C212);
assume that
L359: (C223 in ( meet C214 ) & C224 in ( meet C214 ));
L360:
now
reconsider D106 = C223 , D107 = C224 as (Element of C212);
let C225 being set;
assume L361: C225 in C214;
consider C226 being (Subalgebra of C212) such that L362: C225 = (the carrier of C226) and L363: C213 c= C225 by L361 , L336;
reconsider D108 = C226 as non  empty (Subalgebra of C212) by L362 , L363;
reconsider D109 = D106 , D110 = D107 as (Element of D108) by L359 , L361 , L362 , SETFAM_1:def 1;
L364: ( C223 * C224 ) = ( D109 * D110 ) by L278;
thus L365: ( C223 * C224 ) in C225 by L364 , L362;
end;
thus L366: thesis by L360 , L338 , SETFAM_1:def 1;
end;

L367:
now
let C227 being set;
assume L368: C227 in C214;
consider C228 being (Subalgebra of C212) such that L369: C227 = (the carrier of C228) and L370: C213 c= C227 by L368 , L336;
reconsider D111 = C228 as non  empty (Subalgebra of C212) by L369 , L370;
L371: ( 1. C212 ) = ( 1. D111 ) by L221;
thus L372: ( 1. C212 ) in C227 by L371 , L369;
end;
thus L373: ( 1. C212 ) in ( meet C214 ) by L367 , L338 , SETFAM_1:def 1;
L374:
now
let C229 being set;
assume L375: C229 in C214;
consider C230 being (Subalgebra of C212) such that L376: C229 = (the carrier of C230) and L377: C213 c= C229 by L375 , L336;
reconsider D112 = C230 as non  empty (Subalgebra of C212) by L376 , L377;
L378: ( 0. C212 ) = ( 0. D112 ) by L221;
thus L379: ( 0. C212 ) in C229 by L378 , L376;
end;
thus L380: thesis by L374 , L338 , SETFAM_1:def 1;
end;
definition
let C231 being non  empty multMagma;
let C232 being non  empty AlgebraStr over C231;
let C233 being non  empty (Subset of C232);
func GenAlg C233 ->  strict non  empty (Subalgebra of C232) means 
:L381: (C233 c= (the carrier of it) & (for B188 being (Subalgebra of C232) holds (C233 c= (the carrier of B188) implies (the carrier of it) c= (the carrier of B188))));
existence
proof
defpred S4[ set ] means (ex B189 being (Subalgebra of C232) st ($1 = (the carrier of B189) & C233 c= $1));
consider C234 being (Subset-Family of C232) such that L382: (for B190 being (Subset of C232) holds (B190 in C234 iff S4[ B190 ])) from SUBSET_1:sch 3;
L383:
now
let C235 being set;
assume L384: C235 in C234;
L385: (ex B191 being (Subalgebra of C232) st (C235 = (the carrier of B191) & C233 c= C235)) by L384 , L382;
thus L386: C233 c= C235 by L385;
end;
set D113 = ( meet C234 );
L387: (for B192 being set holds (B192 in C234 iff (B192 c= (the carrier of C232) & (ex B193 being (Subalgebra of C232) st (B192 = (the carrier of B193) & C233 c= B192))))) by L382;
L388: D113 is  opers_closed by L387 , L335;
consider C236 being  strict (Subalgebra of C232) such that L389: D113 = (the carrier of C236) by L388 , L302;
reconsider D114 = C236 as non  empty  strict (Subalgebra of C232) by L388 , L389 , L272;
take D114;
L390: (C232 is (Subalgebra of C232) & (the carrier of C232) in ( bool (the carrier of C232) )) by L224 , ZFMISC_1:def 1;
L391: C234 <> ( {} ) by L390 , L382;
thus L392: C233 c= (the carrier of D114) by L391 , L389 , L383 , SETFAM_1:5;
let C237 being (Subalgebra of C232);
assume that
L393: C233 c= (the carrier of C237);
L394: (the carrier of C237) c= (the carrier of C232) by L221;
L395: (the carrier of C237) in C234 by L394 , L382 , L393;
thus L396: thesis by L395 , L389 , SETFAM_1:3;
end;
uniqueness
proof
let C238 , C239 being  strict non  empty (Subalgebra of C232);
assume L397: (C233 c= (the carrier of C238) & (for B194 being (Subalgebra of C232) holds (C233 c= (the carrier of B194) implies (the carrier of C238) c= (the carrier of B194))) & C233 c= (the carrier of C239) & (for B195 being (Subalgebra of C232) holds (C233 c= (the carrier of B195) implies (the carrier of C239) c= (the carrier of B195))));
L398: ((the carrier of C238) c= (the carrier of C239) & (the carrier of C239) c= (the carrier of C238)) by L397;
L399: (the carrier of C238) = (the carrier of C239) by L398 , XBOOLE_0:def 10;
L400:
now
let C240 being (Element of C238);
let C241 being (Element of C239);
reconsider D115 = C241 as (Element of C238) by L398 , XBOOLE_0:def 10;
reconsider D116 = C240 as (Element of C239) by L398 , XBOOLE_0:def 10;
L401: (the carrier of C239) c= (the carrier of C232) by L221;
reconsider D117 = D116 as (Element of C232) by L401 , TARSKI:def 3;
reconsider D118 = C241 as (Element of C232) by L401 , TARSKI:def 3;
thus L402: ( (the multF of C238) . (C240 , C241) ) = ( C240 * D115 )
.= ( D117 * D118 ) by L278
.= ( D116 * C241 ) by L278
.= ( (the multF of C239) . (C240 , C241) );
end;
L403: (the multF of C238) = (the multF of C239) by L400 , L399 , BINOP_1:2;
L404: ( 0. C238 ) = ( 0. C232 ) by L221
.= ( 0. C239 ) by L221;
L405:
now
let C242 being (Element of C231);
let C243 being (Element of C238);
reconsider D119 = C243 as (Element of C239) by L398 , XBOOLE_0:def 10;
L406: (the carrier of C239) c= (the carrier of C232) by L221;
reconsider D120 = D119 as (Element of C232) by L406 , TARSKI:def 3;
thus L407: ( (the lmult of C238) . (C242 , C243) ) = ( C242 * C243 )
.= ( C242 * D120 ) by L282
.= ( C242 * D119 ) by L282
.= ( (the lmult of C239) . (C242 , C243) );
end;
L408: ( 1. C238 ) = ( 1. C232 ) by L221
.= ( 1. C239 ) by L221;
L409:
now
let C244 being (Element of C238);
let C245 being (Element of C239);
reconsider D121 = C245 as (Element of C238) by L398 , XBOOLE_0:def 10;
reconsider D122 = C244 as (Element of C239) by L398 , XBOOLE_0:def 10;
L410: (the carrier of C239) c= (the carrier of C232) by L221;
reconsider D123 = D122 as (Element of C232) by L410 , TARSKI:def 3;
reconsider D124 = C245 as (Element of C232) by L410 , TARSKI:def 3;
thus L411: ( (the addF of C238) . (C244 , C245) ) = ( C244 + D121 )
.= ( D123 + D124 ) by L274
.= ( D122 + C245 ) by L274
.= ( (the addF of C239) . (C244 , C245) );
end;
L412: (the addF of C238) = (the addF of C239) by L409 , L399 , BINOP_1:2;
thus L413: thesis by L412 , L399 , L403 , L404 , L408 , L405 , BINOP_1:2;
end;
end;
theorem
L415: (for B196 being non  empty multMagma holds (for B197 being non  empty AlgebraStr over B196 holds (for B198 being non  empty (Subset of B197) holds (B198 is  opers_closed implies (the carrier of ( GenAlg B198 )) = B198))))
proof
let C246 being non  empty multMagma;
let C247 being non  empty AlgebraStr over C246;
let C248 being non  empty (Subset of C247);
assume L416: C248 is  opers_closed;
L417: (ex B199 being  strict (Subalgebra of C247) st (the carrier of B199) = C248) by L416 , L302;
L418: (the carrier of ( GenAlg C248 )) c= C248 by L417 , L381;
L419: C248 c= (the carrier of ( GenAlg C248 )) by L381;
thus L420: thesis by L419 , L418 , XBOOLE_0:def 10;
end;
begin
definition
let C249 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
func Polynom-Algebra C249 ->  strict non  empty AlgebraStr over C249 means 
:L421: (ex B200 being non  empty (Subset of ( Formal-Series C249 )) st (B200 = (the carrier of ( Polynom-Ring C249 )) & it = ( GenAlg B200 )));
existence
proof
L422: (the carrier of ( Polynom-Ring C249 )) c= (the carrier of ( Formal-Series C249 ))
proof
let C250 being set;
assume L423: C250 in (the carrier of ( Polynom-Ring C249 ));
L424: C250 is (AlgSequence of C249) by L423 , POLYNOM3:def 10;
thus L425: thesis by L424 , L31;
end;
reconsider D125 = (the carrier of ( Polynom-Ring C249 )) as non  empty (Subset of ( Formal-Series C249 )) by L422;
take ( GenAlg D125 );
thus L426: thesis;
end;
uniqueness;
end;
registration
let C251 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
cluster ( Polynom-Ring C251 ) ->  Loop-like;
coherence
proof
L428: (for B201 , B202 being (Element of ( Polynom-Ring C251 )) holds (ex B203 being (Element of ( Polynom-Ring C251 )) st ( B203 + B201 ) = B202))
proof
let C252 , C253 being (Element of ( Polynom-Ring C251 ));
reconsider D126 = ( C253 - C252 ) as (Element of ( Polynom-Ring C251 ));
take D126;
thus L429: ( D126 + C252 ) = ( C253 + ( ( - C252 ) + C252 ) ) by RLVECT_1:def 3
.= ( C253 + ( 0. ( Polynom-Ring C251 ) ) ) by RLVECT_1:5
.= C253 by RLVECT_1:4;
end;
L430: (for B204 , B205 , B206 being (Element of ( Polynom-Ring C251 )) holds (( B205 + B204 ) = ( B206 + B204 ) implies B205 = B206)) by RLVECT_1:8;
L431: ((for B207 , B208 being (Element of ( Polynom-Ring C251 )) holds (ex B209 being (Element of ( Polynom-Ring C251 )) st ( B207 + B209 ) = B208)) & (for B210 , B211 , B212 being (Element of ( Polynom-Ring C251 )) holds (( B210 + B211 ) = ( B210 + B212 ) implies B211 = B212))) by RLVECT_1:7 , RLVECT_1:8;
thus L432: thesis by L431 , L428 , L430 , ALGSTR_1:6;
end;
end;
theorem
L434: (for B213 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds (for B214 being non  empty (Subset of ( Formal-Series B213 )) holds (B214 = (the carrier of ( Polynom-Ring B213 )) implies B214 is  opers_closed)))
proof
let C254 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
set D127 = ( Formal-Series C254 );
let C255 being non  empty (Subset of ( Formal-Series C254 ));
assume that
L435: C255 = (the carrier of ( Polynom-Ring C254 ));
L436: (for B215 being (Element of C254) holds (for B216 being (Element of D127) holds (B216 in C255 implies ( B215 * B216 ) in C255)))
proof
let C256 being (Element of C254);
let C257 being (Element of D127);
assume L437: C257 in C255;
reconsider D128 = C257 as (AlgSequence of C254) by L437 , L435 , POLYNOM3:def 10;
reconsider D129 = C256 as (Element of C254);
L438: ( C256 * C257 ) = ( D129 * D128 ) by L31;
thus L439: thesis by L438 , L435 , POLYNOM3:def 10;
end;
L440: (for B217 , B218 being (Element of D127) holds ((B217 in C255 & B218 in C255) implies ( B217 + B218 ) in C255))
proof
let C258 , C259 being (Element of D127);
assume L441: (C258 in C255 & C259 in C255);
reconsider D130 = C258 , D131 = C259 as (AlgSequence of C254) by L441 , L435 , POLYNOM3:def 10;
L442: ( C258 + C259 ) = ( D130 + D131 ) by L31;
thus L443: thesis by L442 , L435 , POLYNOM3:def 10;
end;
thus L444: C255 is  linearly-closed by L440 , L436 , VECTSP_4:def 1;
thus L445: (for B219 , B220 being (Element of D127) holds ((B219 in C255 & B220 in C255) implies ( B219 * B220 ) in C255))
proof
let C260 , C261 being (Element of D127);
assume L446: (C260 in C255 & C261 in C255);
reconsider D132 = C260 , D133 = C261 as (AlgSequence of C254) by L446 , L435 , POLYNOM3:def 10;
L447: ( C260 * C261 ) = ( D132 *' D133 ) by L31;
thus L448: thesis by L447 , L435 , POLYNOM3:def 10;
end;

L449: ( 1. D127 ) = ( 1_. C254 ) by L31
.= ( 1. ( Polynom-Ring C254 ) ) by POLYNOM3:def 10;
thus L450: ( 1. D127 ) in C255 by L449 , L435;
L451: ( 0. D127 ) = ( 0_. C254 ) by L31
.= ( 0. ( Polynom-Ring C254 ) ) by POLYNOM3:def 10;
thus L452: thesis by L451 , L435;
end;
theorem
L453: (for B221 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr holds ( the doubleLoopStr of ( Polynom-Algebra B221 ) ) = ( Polynom-Ring B221 ))
proof
let C262 being  add-associative  right_zeroed  right_complementable  distributive non  empty doubleLoopStr;
L454: (ex B222 being non  empty (Subset of ( Formal-Series C262 )) st (B222 = (the carrier of ( Polynom-Ring C262 )) & ( Polynom-Algebra C262 ) = ( GenAlg B222 ))) by L421;
L455: (the carrier of ( Polynom-Algebra C262 )) = (the carrier of ( Polynom-Ring C262 )) by L454 , L415 , L434;
L456: (the carrier of ( Polynom-Algebra C262 )) c= (the carrier of ( Formal-Series C262 )) by L454 , L221;
L457: (for B223 being (Element of ( Polynom-Algebra C262 )) holds (for B224 being (Element of ( Polynom-Ring C262 )) holds ( (the addF of ( Polynom-Algebra C262 )) . (B223 , B224) ) = ( (the addF of ( Polynom-Ring C262 )) . (B223 , B224) )))
proof
let C263 being (Element of ( Polynom-Algebra C262 ));
let C264 being (Element of ( Polynom-Ring C262 ));
reconsider D134 = C264 as (Element of ( Polynom-Algebra C262 )) by L454 , L415 , L434;
reconsider D135 = D134 as (Element of ( Formal-Series C262 )) by L454 , TARSKI:def 3;
reconsider D136 = C263 as (Element of ( Formal-Series C262 )) by L456 , TARSKI:def 3;
reconsider D137 = C263 as (AlgSequence of C262) by L455 , POLYNOM3:def 10;
reconsider D138 = C263 as (Element of ( Polynom-Ring C262 )) by L454 , L415 , L434;
reconsider D139 = C264 as (AlgSequence of C262) by POLYNOM3:def 10;
thus L458: ( (the addF of ( Polynom-Algebra C262 )) . (C263 , C264) ) = ( C263 + D134 )
.= ( D136 + D135 ) by L454 , L274
.= ( D137 + D139 ) by L31
.= ( D138 + C264 ) by POLYNOM3:def 10
.= ( (the addF of ( Polynom-Ring C262 )) . (C263 , C264) );
end;
L459:
now
let C265 being (Element of ( Polynom-Algebra C262 ));
let C266 being (Element of ( Polynom-Ring C262 ));
reconsider D140 = C266 as (Element of ( Polynom-Algebra C262 )) by L454 , L415 , L434;
reconsider D141 = D140 as (Element of ( Formal-Series C262 )) by L454 , TARSKI:def 3;
reconsider D142 = C265 as (Element of ( Formal-Series C262 )) by L456 , TARSKI:def 3;
reconsider D143 = C265 as (AlgSequence of C262) by L455 , POLYNOM3:def 10;
reconsider D144 = C265 as (Element of ( Polynom-Ring C262 )) by L454 , L415 , L434;
reconsider D145 = C266 as (AlgSequence of C262) by POLYNOM3:def 10;
thus L460: ( (the multF of ( Polynom-Algebra C262 )) . (C265 , C266) ) = ( C265 * D140 )
.= ( D142 * D141 ) by L454 , L278
.= ( D143 *' D145 ) by L31
.= ( D144 * C266 ) by POLYNOM3:def 10
.= ( (the multF of ( Polynom-Ring C262 )) . (C265 , C266) );
end;
L461: (the multF of ( Polynom-Algebra C262 )) = (the multF of ( Polynom-Ring C262 )) by L459 , L455 , BINOP_1:2;
L462: ( 1. ( Polynom-Algebra C262 ) ) = ( 1. ( Formal-Series C262 ) ) by L454 , L221
.= ( 1_. C262 ) by L31
.= ( 1. ( Polynom-Ring C262 ) ) by POLYNOM3:def 10;
L463: ( 0. ( Polynom-Algebra C262 ) ) = ( 0. ( Formal-Series C262 ) ) by L454 , L221
.= ( 0_. C262 ) by L31
.= ( 0. ( Polynom-Ring C262 ) ) by POLYNOM3:def 10;
thus L464: thesis by L463 , L455 , L457 , L461 , L462 , BINOP_1:2;
end;
theorem
L465: (for B225 being  add-associative  right_zeroed  right_complementable  well-unital  distributive non  empty doubleLoopStr holds ( 1_ ( Formal-Series B225 ) ) = ( 1_. B225 )) by L31;
