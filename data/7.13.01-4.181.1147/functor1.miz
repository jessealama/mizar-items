:: Basic Properties of Functor Structures
::  by Claus Zinn and Wolfgang Jaksch
::
:: Received April 24, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies XBOOLE_0, RELAT_2, ALTCAT_1, ALTCAT_2, MSUALG_6, FUNCTOR0,
      RELAT_1, FUNCT_2, FUNCT_1, SUBSET_1, FUNCT_3, ZFMISC_1, STRUCT_0, TARSKI,
      MEMBER_1, MSUALG_3, ENS_1, CAT_1, PBOOLE, REALSET1, PZFMISC1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, PBOOLE,
      PARTFUN1, FUNCT_2, BINOP_1, REALSET1, PZFMISC1, STRUCT_0, MSUALG_3,
      ALTCAT_1, ALTCAT_2, FUNCT_3, FUNCTOR0;
 constructors REALSET1, PZFMISC1, MSUALG_3, FUNCTOR0, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1, PBOOLE,
      STRUCT_0, ALTCAT_2, FUNCTOR0, RELSET_1;
 requirements SUBSET, BOOLE;
 definitions TARSKI, PBOOLE, MSUALG_3, ALTCAT_2, FUNCTOR0, PZFMISC1, BINOP_1,
      REALSET1;
 theorems ALTCAT_1, ALTCAT_2, FUNCTOR0, FUNCT_1, FUNCT_2, ZFMISC_1, PBOOLE,
      RELAT_1, MSUALG_3, XBOOLE_1, PZFMISC1, PARTFUN1;

begin
registration
cluster  transitive  with_units  reflexive for non  empty non  empty non  empty non  empty AltCatStr;
existence
proof
set D1 = the category;
take D1;
thus L1: thesis;
end;
end;
registration
let C1 being non  empty  reflexive AltCatStr;
cluster non  empty  reflexive for (SubCatStr of C1);
existence
proof
reconsider D2 = C1 as (SubCatStr of C1) by ALTCAT_2:20;
take D2;
thus L3: thesis;
end;
end;
registration
let C2 , C3 being non  empty  reflexive AltCatStr;
let C4 being  feasible FunctorStr over C2 , C3;
let C5 being non  empty  reflexive (SubCatStr of C2);
cluster ( C4 | C5 ) ->  feasible;
coherence;
end;
begin
registration
let C6 being set;
cluster ( id C6 ) ->  onto;
coherence
proof
reconsider D3 = ( id C6 ) as (Function of C6 , C6);
L6: ( rng D3 ) = C6 by RELAT_1:45;
thus L7: thesis by L6 , FUNCT_2:def 3;
end;
end;
theorem
L9: (for B1 being non  empty set holds (for B2 , B3 being non  empty (Subset of B1) holds (for B4 being non  empty (Subset of B2) holds (B3 = B4 implies ( incl B3 ) = ( ( incl B2 ) * ( incl B4 ) )))))
proof
let C7 being non  empty set;
let C8 , C9 being non  empty (Subset of C7);
let C10 being non  empty (Subset of C8);
assume that
L10: C9 = C10;
L11: ( ( incl C8 ) * ( incl C10 ) ) = ( id ( C8 /\ C10 ) ) by FUNCT_1:22
.= ( incl C9 ) by L10 , XBOOLE_1:28;
thus L12: thesis by L11;
end;
theorem
L13: (for R1 being set holds (for R2 being set holds (for B5 being (Function of R1 , R2) holds (B5 is  bijective implies ( B5 " ) is (Function of R2 , R1)))))
proof
let R1 being set;
let R2 being set;
let C11 being (Function of R1 , R2);
assume L14: C11 is  bijective;
L15: ( rng C11 ) = R2 by L14 , FUNCT_2:def 3;
thus L16: thesis by L15 , L14 , FUNCT_2:25;
end;
theorem
L17: (for R1 being set holds (for R2 being set holds (for R3 being non  empty set holds (for B6 being (Function of R1 , R2) holds (for B7 being (Function of R2 , R3) holds ((B6 is  bijective & B7 is  bijective) implies (ex B8 being (Function of R1 , R3) st (B8 = ( B7 * B6 ) & B8 is  bijective))))))))
proof
let R1 being set;
let R2 being set;
let R3 being non  empty set;
let C12 being (Function of R1 , R2);
let C13 being (Function of R2 , R3);
assume that
L18: C12 is  bijective
and
L19: C13 is  bijective;
L20: ( rng C13 ) = R3 by L19 , FUNCT_2:def 3;
L21: (R2 = ( {} ) iff R3 = ( {} )) by L20;
reconsider D4 = ( C13 * C12 ) as (Function of R1 , R3) by L21;
take D4;
L22: ( rng C12 ) = R2 by L18 , FUNCT_2:def 3;
L23: ( rng ( C13 * C12 ) ) = R3 by L22 , L20 , FUNCT_2:14;
L24: D4 is  onto by L23 , FUNCT_2:def 3;
thus L25: thesis by L24 , L18 , L19;
end;
begin
theorem
L26: (for B9 being non  empty  reflexive AltCatStr holds (for B10 being non  empty  reflexive (SubCatStr of B9) holds (for B11 being non  empty (SubCatStr of B9) holds (for B12 being non  empty (SubCatStr of B10) holds (B11 = B12 implies ( incl B11 ) = ( ( incl B10 ) * ( incl B12 ) ))))))
proof
let C14 being non  empty  reflexive AltCatStr;
let C15 being non  empty  reflexive (SubCatStr of C14);
let C16 being non  empty (SubCatStr of C14);
let C17 being non  empty (SubCatStr of C15);
assume that
L27: C16 = C17;
set D5 = [: (the carrier of C15) , (the carrier of C15) :];
set D6 = [: (the carrier of C17) , (the carrier of C17) :];
L28: (the carrier of C17) c= (the carrier of C15) by ALTCAT_2:def 11;
L29: D6 c= D5 by L28 , ZFMISC_1:96;
L30: (for B13 being set holds (B13 in D6 implies ( (the MorphMap of ( incl C16 )) . B13 ) = ( ( ( (the MorphMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) ** (the MorphMap of ( incl C17 )) ) . B13 )))
proof
set D7 = ( dom (the MorphMap of ( incl C17 )) );
set D8 = ( dom ( (the MorphMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) );
set D9 = (the Arrows of C15);
set D10 = (the Arrows of C17);
let C18 being set;
L31: ( (the MorphMap of ( incl C16 )) . C18 ) = ( ( id (the Arrows of C16) ) . C18 ) by FUNCTOR0:def 28;
L32: (( dom ( ( (the MorphMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) ** (the MorphMap of ( incl C17 )) ) ) = ( D7 /\ D8 ) & ( dom (the MorphMap of ( incl C17 )) ) = D6) by PARTFUN1:def 2 , PBOOLE:def 19;
L33: ( dom ( (the MorphMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) ) = ( dom ( (the MorphMap of ( incl C15 )) * ( id D6 ) ) ) by FUNCTOR0:def 28
.= ( ( dom (the MorphMap of ( incl C15 )) ) /\ D6 ) by FUNCT_1:19
.= ( D5 /\ D6 ) by PARTFUN1:def 2
.= D6 by L28 , XBOOLE_1:28 , ZFMISC_1:96;
assume L34: C18 in D6;
L35: C18 in ( dom ( id D6 ) ) by L34;
L36: D10 cc= D9 by ALTCAT_2:def 11;
L37: ( D10 . C18 ) c= ( D9 . C18 ) by L36 , L34 , ALTCAT_2:def 2;
L38: ( ( (the MorphMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) . C18 ) = ( ( (the MorphMap of ( incl C15 )) * ( id D6 ) ) . C18 ) by FUNCTOR0:def 28
.= ( (the MorphMap of ( incl C15 )) . ( ( id D6 ) . C18 ) ) by L35 , FUNCT_1:13
.= ( (the MorphMap of ( incl C15 )) . C18 ) by L34 , FUNCT_1:18;
L39: (( (the MorphMap of ( incl C15 )) . C18 ) = ( ( id (the Arrows of C15) ) . C18 ) & ( (the MorphMap of ( incl C17 )) . C18 ) = ( ( id (the Arrows of C17) ) . C18 )) by FUNCTOR0:def 28;
L40: ( ( (the MorphMap of ( incl C15 )) . C18 ) * ( (the MorphMap of ( incl C17 )) . C18 ) ) = ( ( ( id D9 ) . C18 ) * ( id ( D10 . C18 ) ) ) by L39 , L34 , MSUALG_3:def 1
.= ( ( id ( D9 . C18 ) ) * ( id ( D10 . C18 ) ) ) by L29 , L34 , MSUALG_3:def 1
.= ( id ( ( D9 . C18 ) /\ ( D10 . C18 ) ) ) by FUNCT_1:22
.= ( id ( (the Arrows of C17) . C18 ) ) by L37 , XBOOLE_1:28
.= ( (the MorphMap of ( incl C16 )) . C18 ) by L27 , L34 , L31 , MSUALG_3:def 1;
thus L41: thesis by L40 , L34 , L38 , L32 , L33 , PBOOLE:def 19;
end;
L42: (the MorphMap of ( incl C16 )) = ( ( (the MorphMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) ** (the MorphMap of ( incl C17 )) ) by L30 , L27 , PBOOLE:3;
L43: (the ObjectMap of ( incl C16 )) = ( id D6 ) by L27 , FUNCTOR0:def 28
.= ( id ( D5 /\ D6 ) ) by L28 , XBOOLE_1:28 , ZFMISC_1:96
.= ( ( id D5 ) * ( id D6 ) ) by FUNCT_1:22
.= ( ( id D5 ) * (the ObjectMap of ( incl C17 )) ) by FUNCTOR0:def 28
.= ( (the ObjectMap of ( incl C15 )) * (the ObjectMap of ( incl C17 )) ) by FUNCTOR0:def 28;
thus L44: thesis by L43 , L27 , L42 , FUNCTOR0:def 36;
end;
theorem
L45: (for B14 , B15 being non  empty AltCatStr holds (for B16 being FunctorStr over B14 , B15 holds (B16 is  bijective implies ((the ObjectMap of B16) is  bijective & (the MorphMap of B16) is  "1-1"))))
proof
let C19 , C20 being non  empty AltCatStr;
let C21 being FunctorStr over C19 , C20;
assume L46: C21 is  bijective;
L47: C21 is  injective by L46 , FUNCTOR0:def 35;
L48: C21 is  one-to-one by L47 , FUNCTOR0:def 33;
L49: (the ObjectMap of C21) is  one-to-one by L48 , FUNCTOR0:def 6;
L50: C21 is  surjective by L46 , FUNCTOR0:def 35;
L51: C21 is  onto by L50 , FUNCTOR0:def 34;
L52: (the ObjectMap of C21) is  onto by L51 , FUNCTOR0:def 7;
L53: C21 is  faithful by L47 , FUNCTOR0:def 33;
thus L54: thesis by L53 , L49 , L52 , FUNCTOR0:def 30;
end;
theorem
L55: (for B17 being non  empty AltGraph holds (for B18 , B19 being non  empty  reflexive AltGraph holds (for B20 being  feasible FunctorStr over B17 , B18 holds (for B21 being FunctorStr over B18 , B19 holds ((B20 is  one-to-one & B21 is  one-to-one) implies ( B21 * B20 ) is  one-to-one)))))
proof
let C22 being non  empty AltGraph;
let C23 , C24 being non  empty  reflexive AltGraph;
let C25 being  feasible FunctorStr over C22 , C23;
let C26 being FunctorStr over C23 , C24;
assume L56: (C25 is  one-to-one & C26 is  one-to-one);
L57: ((the ObjectMap of C25) is  one-to-one & (the ObjectMap of C26) is  one-to-one) by L56 , FUNCTOR0:def 6;
L58: (the ObjectMap of ( C26 * C25 )) = ( (the ObjectMap of C26) * (the ObjectMap of C25) ) by FUNCTOR0:def 36;
thus L59: (the ObjectMap of ( C26 * C25 )) is  one-to-one by L58 , L57;
end;
theorem
L60: (for B22 being non  empty AltGraph holds (for B23 , B24 being non  empty  reflexive AltGraph holds (for B25 being  feasible FunctorStr over B22 , B23 holds (for B26 being FunctorStr over B23 , B24 holds ((B25 is  faithful & B26 is  faithful) implies ( B26 * B25 ) is  faithful)))))
proof
let C27 being non  empty AltGraph;
let C28 , C29 being non  empty  reflexive AltGraph;
let C30 being  feasible FunctorStr over C27 , C28;
let C31 being FunctorStr over C28 , C29;
assume that
L61: C30 is  faithful
and
L62: C31 is  faithful;
set D11 = (the MorphMap of C31);
L63: D11 is  "1-1" by L62 , FUNCTOR0:def 30;
set D12 = (the MorphMap of C30);
set D13 = [: (the carrier of C28) , (the carrier of C28) :];
set D14 = [: (the carrier of C27) , (the carrier of C27) :];
reconsider D15 = (the MorphMap of ( C31 * C30 )) as (ManySortedFunction of D14);
reconsider D16 = (the ObjectMap of C30) as (Function of D14 , D13);
L64: D15 = ( ( D11 * D16 ) ** D12 ) by FUNCTOR0:def 36;
L65: D12 is  "1-1" by L61 , FUNCTOR0:def 30;
L66: (for B27 being set holds (B27 in D14 implies ( D15 . B27 ) is  one-to-one))
proof
let C32 being set;
assume L67: C32 in D14;
L68: C32 in ( dom ( ( D11 * D16 ) ** D12 ) ) by L67 , PARTFUN1:def 2;
L69: ( D15 . C32 ) = ( ( ( D11 * D16 ) . C32 ) * ( D12 . C32 ) ) by L68 , L64 , PBOOLE:def 19
.= ( ( D11 . ( D16 . C32 ) ) * ( D12 . C32 ) ) by L67 , FUNCT_2:15;
L70: ( D16 . C32 ) in D13 by L67 , FUNCT_2:5;
L71: ( D11 . ( D16 . C32 ) ) is  one-to-one by L70 , L63 , MSUALG_3:1;
L72: ( D12 . C32 ) is  one-to-one by L65 , L67 , MSUALG_3:1;
thus L73: thesis by L72 , L69 , L71;
end;
thus L74: (the MorphMap of ( C31 * C30 )) is  "1-1" by L66 , MSUALG_3:1;
end;
theorem
L75: (for B28 being non  empty AltGraph holds (for B29 , B30 being non  empty  reflexive AltGraph holds (for B31 being  feasible FunctorStr over B28 , B29 holds (for B32 being FunctorStr over B29 , B30 holds ((B31 is  onto & B32 is  onto) implies ( B32 * B31 ) is  onto)))))
proof
let C33 being non  empty AltGraph;
let C34 , C35 being non  empty  reflexive AltGraph;
let C36 being  feasible FunctorStr over C33 , C34;
let C37 being FunctorStr over C34 , C35;
assume that
L76: C36 is  onto
and
L77: C37 is  onto;
set D17 = [: (the carrier of C35) , (the carrier of C35) :];
set D18 = [: (the carrier of C34) , (the carrier of C34) :];
reconsider D19 = (the ObjectMap of C37) as (Function of D18 , D17);
L78: D19 is  onto by L77 , FUNCTOR0:def 7;
L79: ( rng D19 ) = D17 by L78 , FUNCT_2:def 3;
set D20 = [: (the carrier of C33) , (the carrier of C33) :];
reconsider D21 = (the ObjectMap of C36) as (Function of D20 , D18);
L80: D21 is  onto by L76 , FUNCTOR0:def 7;
L81: ( rng D21 ) = D18 by L80 , FUNCT_2:def 3;
L82: ( rng ( D19 * D21 ) ) = D17 by L81 , L79 , FUNCT_2:14;
L83: ( D19 * D21 ) is  onto by L82 , FUNCT_2:def 3;
thus L84: (the ObjectMap of ( C37 * C36 )) is  onto by L83 , FUNCTOR0:def 36;
end;
theorem
L85: (for B33 being non  empty AltGraph holds (for B34 , B35 being non  empty  reflexive AltGraph holds (for B36 being  feasible FunctorStr over B33 , B34 holds (for B37 being FunctorStr over B34 , B35 holds ((B36 is  full & B37 is  full) implies ( B37 * B36 ) is  full)))))
proof
let C38 being non  empty AltGraph;
let C39 , C40 being non  empty  reflexive AltGraph;
let C41 being  feasible FunctorStr over C38 , C39;
let C42 being FunctorStr over C39 , C40;
assume that
L86: C41 is  full
and
L87: C42 is  full;
set D22 = [: (the carrier of C40) , (the carrier of C40) :];
set D23 = [: (the carrier of C39) , (the carrier of C39) :];
set D24 = [: (the carrier of C38) , (the carrier of C38) :];
reconsider D25 = (the ObjectMap of C41) as (Function of D24 , D23);
reconsider D26 = (the ObjectMap of C42) as (Function of D23 , D22);
consider C43 being (ManySortedFunction of (the Arrows of C38) , ( (the Arrows of C39) * (the ObjectMap of C41) )) such that L88: C43 = (the MorphMap of C41) and L89: C43 is  "onto" by L86 , FUNCTOR0:def 32;
consider C44 being (ManySortedFunction of (the Arrows of C39) , ( (the Arrows of C40) * (the ObjectMap of C42) )) such that L90: C44 = (the MorphMap of C42) and L91: C44 is  "onto" by L87 , FUNCTOR0:def 32;
L92: (ex B38 being (ManySortedFunction of (the Arrows of C38) , ( (the Arrows of C40) * (the ObjectMap of ( C42 * C41 )) )) st (B38 = (the MorphMap of ( C42 * C41 )) & B38 is  "onto"))
proof
reconsider D27 = (the MorphMap of ( C42 * C41 )) as (ManySortedFunction of (the Arrows of C38) , ( (the Arrows of C40) * (the ObjectMap of ( C42 * C41 )) )) by FUNCTOR0:def 4;
take D27;
L93: D27 = ( ( C44 * D25 ) ** C43 ) by L88 , L90 , FUNCTOR0:def 36;
L94: (for B39 being set holds (B39 in D24 implies ( rng ( D27 . B39 ) ) = ( ( (the Arrows of C40) * (the ObjectMap of ( C42 * C41 )) ) . B39 )))
proof
let C45 being set;
assume L95: C45 in D24;
reconsider D28 = ( C44 . ( D25 . C45 ) ) as (Function of ( (the Arrows of C39) . ( D25 . C45 ) ) , ( ( (the Arrows of C40) * (the ObjectMap of C42) ) . ( D25 . C45 ) )) by L95 , FUNCT_2:5 , PBOOLE:def 15;
L96: ( D25 . C45 ) in D23 by L95 , FUNCT_2:5;
L97: ( rng ( ( C44 . ( D25 . C45 ) ) * ( C43 . C45 ) ) ) = ( rng ( C44 . ( D25 . C45 ) ) )
proof
per cases ;
suppose L98: ( rng D28 ) = ( {} );

L99: ( rng ( ( {} ) * ( C43 . C45 ) ) ) = ( {} );
thus L100: thesis by L99 , L98 , RELAT_1:41;
end;
suppose L101: ( rng D28 ) <> ( {} );

L102: ( rng D28 ) = ( ( (the Arrows of C40) * (the ObjectMap of C42) ) . ( D25 . C45 ) ) by L91 , L96 , MSUALG_3:def 3;
L103: ( dom D28 ) = ( (the Arrows of C39) . ( D25 . C45 ) ) by L102 , L101 , FUNCT_2:def 1;
L104: ( dom D28 ) = ( ( (the Arrows of C39) * D25 ) . C45 ) by L103 , L95 , FUNCT_2:15
.= ( rng ( C43 . C45 ) ) by L89 , L95 , MSUALG_3:def 3;
thus L105: thesis by L104 , RELAT_1:28;
end;
end;
L107: C45 in ( dom ( ( C44 * D25 ) ** C43 ) ) by L95 , PARTFUN1:def 2;
L108: ( rng ( D27 . C45 ) ) = ( rng ( ( ( C44 * D25 ) . C45 ) * ( C43 . C45 ) ) ) by L107 , L93 , PBOOLE:def 19
.= ( rng ( C44 . ( D25 . C45 ) ) ) by L95 , L97 , FUNCT_2:15
.= ( ( (the Arrows of C40) * (the ObjectMap of C42) ) . ( D25 . C45 ) ) by L91 , L96 , MSUALG_3:def 3
.= ( (the Arrows of C40) . ( D26 . ( D25 . C45 ) ) ) by L95 , FUNCT_2:5 , FUNCT_2:15
.= ( (the Arrows of C40) . ( ( D26 * D25 ) . C45 ) ) by L95 , FUNCT_2:15
.= ( (the Arrows of C40) . ( (the ObjectMap of ( C42 * C41 )) . C45 ) ) by FUNCTOR0:def 36
.= ( ( (the Arrows of C40) * (the ObjectMap of ( C42 * C41 )) ) . C45 ) by L95 , FUNCT_2:15;
thus L109: thesis by L108;
end;
thus L110: thesis by L94 , MSUALG_3:def 3;
end;
thus L111: thesis by L92 , FUNCTOR0:def 32;
end;
theorem
L112: (for B40 being non  empty AltGraph holds (for B41 , B42 being non  empty  reflexive AltGraph holds (for B43 being  feasible FunctorStr over B40 , B41 holds (for B44 being FunctorStr over B41 , B42 holds ((B43 is  injective & B44 is  injective) implies ( B44 * B43 ) is  injective)))))
proof
let C46 being non  empty AltGraph;
let C47 , C48 being non  empty  reflexive AltGraph;
let C49 being  feasible FunctorStr over C46 , C47;
let C50 being FunctorStr over C47 , C48;
assume L113: (C49 is  injective & C50 is  injective);
L114: (C49 is  faithful & C50 is  faithful) by L113 , FUNCTOR0:def 33;
L115: ( C50 * C49 ) is  faithful by L114 , L60;
L116: (C49 is  one-to-one & C50 is  one-to-one) by L113 , FUNCTOR0:def 33;
L117: ( C50 * C49 ) is  one-to-one by L116 , L55;
thus L118: thesis by L117 , L115 , FUNCTOR0:def 33;
end;
theorem
L119: (for B45 being non  empty AltGraph holds (for B46 , B47 being non  empty  reflexive AltGraph holds (for B48 being  feasible FunctorStr over B45 , B46 holds (for B49 being FunctorStr over B46 , B47 holds ((B48 is  surjective & B49 is  surjective) implies ( B49 * B48 ) is  surjective)))))
proof
let C51 being non  empty AltGraph;
let C52 , C53 being non  empty  reflexive AltGraph;
let C54 being  feasible FunctorStr over C51 , C52;
let C55 being FunctorStr over C52 , C53;
assume L120: (C54 is  surjective & C55 is  surjective);
L121: (C54 is  onto & C55 is  onto) by L120 , FUNCTOR0:def 34;
L122: ( C55 * C54 ) is  onto by L121 , L75;
L123: (C54 is  full & C55 is  full) by L120 , FUNCTOR0:def 34;
L124: ( C55 * C54 ) is  full by L123 , L85;
thus L125: thesis by L124 , L122 , FUNCTOR0:def 34;
end;
theorem
L126: (for B50 being non  empty AltGraph holds (for B51 , B52 being non  empty  reflexive AltGraph holds (for B53 being  feasible FunctorStr over B50 , B51 holds (for B54 being FunctorStr over B51 , B52 holds ((B53 is  bijective & B54 is  bijective) implies ( B54 * B53 ) is  bijective)))))
proof
let C56 being non  empty AltGraph;
let C57 , C58 being non  empty  reflexive AltGraph;
let C59 being  feasible FunctorStr over C56 , C57;
let C60 being FunctorStr over C57 , C58;
assume L127: (C59 is  bijective & C60 is  bijective);
L128: (C59 is  surjective & C60 is  surjective) by L127 , FUNCTOR0:def 35;
L129: ( C60 * C59 ) is  surjective by L128 , L119;
L130: (C59 is  injective & C60 is  injective) by L127 , FUNCTOR0:def 35;
L131: ( C60 * C59 ) is  injective by L130 , L112;
thus L132: thesis by L131 , L129 , FUNCTOR0:def 35;
end;
begin
theorem
L133: (for B55 , B56 being non  empty  reflexive AltCatStr holds (for B57 being non  empty  reflexive (SubCatStr of B55) holds (for B58 being non  empty (SubCatStr of B55) holds (for B59 being non  empty (SubCatStr of B57) holds (B58 = B59 implies (for B60 being FunctorStr over B55 , B56 holds ( B60 | B58 ) = ( ( B60 | B57 ) | B59 )))))))
proof
let C61 , C62 being non  empty  reflexive AltCatStr;
let C63 being non  empty  reflexive (SubCatStr of C61);
let C64 being non  empty (SubCatStr of C61);
let C65 being non  empty (SubCatStr of C63);
assume that
L134: C64 = C65;
let C66 being FunctorStr over C61 , C62;
thus L135: ( C66 | C64 ) = ( C66 * ( ( incl C63 ) * ( incl C65 ) ) ) by L134 , L26
.= ( ( C66 | C63 ) | C65 ) by FUNCTOR0:32;
end;
theorem
L136: (for B61 being non  empty AltCatStr holds (for B62 being non  empty (SubCatStr of B61) holds (B62 is  full iff ( incl B62 ) is  full)))
proof
let C67 being non  empty AltCatStr;
let C68 being non  empty (SubCatStr of C67);
thus L137:now
L138: (ex B63 being non  empty set st (ex B64 being (ManySortedSet of B63) st (ex B65 being (Function of [: (the carrier of C68) , (the carrier of C68) :] , B63) st ((the ObjectMap of ( incl C68 )) = B65 & (the Arrows of C67) = B64 & (the MorphMap of ( incl C68 )) is (ManySortedFunction of (the Arrows of C68) , ( B64 * B65 )))))) by FUNCTOR0:def 3;
reconsider D29 = (the MorphMap of ( incl C68 )) as (ManySortedFunction of (the Arrows of C68) , ( (the Arrows of C67) * (the ObjectMap of ( incl C68 )) )) by L138;
set D30 = [: (the carrier of C68) , (the carrier of C68) :];
L139: ((the carrier of C68) c= (the carrier of C67) & ( dom (the Arrows of C67) ) = [: (the carrier of C67) , (the carrier of C67) :]) by ALTCAT_2:def 11 , PARTFUN1:def 2;
L140: ( ( dom (the Arrows of C67) ) /\ D30 ) = D30 by L139 , XBOOLE_1:28 , ZFMISC_1:96;
assume L141: C68 is  full;
L142: D29 is  "onto"
proof
let C69 being set;
assume that
L143: C69 in D30;
L144: (the Arrows of C68) = ( (the Arrows of C67) || (the carrier of C68) ) by L141 , ALTCAT_2:def 13;
L145: ( (the Arrows of C68) . C69 ) = ( (the Arrows of C67) . C69 ) by L144 , L143 , FUNCT_1:49;
L146: ( rng ( D29 . C69 ) ) = ( rng ( ( id (the Arrows of C68) ) . C69 ) ) by FUNCTOR0:def 28
.= ( rng ( id ( (the Arrows of C68) . C69 ) ) ) by L143 , MSUALG_3:def 1
.= ( (the Arrows of C67) . C69 ) by L145
.= ( ( (the Arrows of C67) * ( id D30 ) ) . C69 ) by L140 , L143 , FUNCT_1:20
.= ( ( (the Arrows of C67) * (the ObjectMap of ( incl C68 )) ) . C69 ) by FUNCTOR0:def 28;
thus L147: thesis by L146;
end;
thus L148: ( incl C68 ) is  full by L142 , FUNCTOR0:def 32;
end;
set D31 = [: (the carrier of C68) , (the carrier of C68) :];
L149: (the carrier of C68) c= (the carrier of C67) by ALTCAT_2:def 11;
L150: D31 c= [: (the carrier of C67) , (the carrier of C67) :] by L149 , ZFMISC_1:96;
L151: ( dom (the Arrows of C67) ) = [: (the carrier of C67) , (the carrier of C67) :] by PARTFUN1:def 2;
L152: ( ( dom (the Arrows of C67) ) /\ D31 ) = D31 by L151 , L149 , XBOOLE_1:28 , ZFMISC_1:96;
L153: ( dom ( (the Arrows of C67) | (D31 qua set) ) ) = D31 by L152 , RELAT_1:61;
reconsider D32 = ( (the Arrows of C67) || (the carrier of C68) ) as (ManySortedSet of D31) by L153 , PARTFUN1:def 2;
assume L154: ( incl C68 ) is  full;
L155: D32 c= (the Arrows of C68)
proof
let C70 being set;
assume that
L156: C70 in D31;
let C71 being set;
assume L157: C71 in ( D32 . C70 );
L158: C71 in ( (the Arrows of C68) . C70 )
proof
consider C72 being (ManySortedFunction of (the Arrows of C68) , ( (the Arrows of C67) * (the ObjectMap of ( incl C68 )) )) such that L159: C72 = (the MorphMap of ( incl C68 )) and L160: C72 is  "onto" by L154 , FUNCTOR0:def 32;
L161: C72 = ( id (the Arrows of C68) ) by L159 , FUNCTOR0:def 28;
L162: ( rng ( ( id (the Arrows of C68) ) . C70 ) ) = ( ( (the Arrows of C67) * (the ObjectMap of ( incl C68 )) ) . C70 ) by L161 , L156 , L160 , MSUALG_3:def 3
.= ( ( (the Arrows of C67) * ( id D31 ) ) . C70 ) by FUNCTOR0:def 28
.= ( (the Arrows of C67) . C70 ) by L152 , L156 , FUNCT_1:20;
consider C73 , C74 being set such that L163: C73 in (the carrier of C67) and L164: C74 in (the carrier of C67) and L165: C70 = [ C73 , C74 ] by L150 , L156 , ZFMISC_1:84;
L166: (C73 in (the carrier of C68) & C74 in (the carrier of C68)) by L156 , L165 , ZFMISC_1:87;
L167: ( D32 . (C73 , C74) ) = ( (the Arrows of C67) . (C73 , C74) ) by L166 , L149 , ALTCAT_1:5;
L168: ( rng ( ( id (the Arrows of C68) ) . C70 ) ) = ( rng ( id ( (the Arrows of C68) . C70 ) ) ) by L156 , MSUALG_3:def 1
.= ( (the Arrows of C68) . C70 );
thus L169: thesis by L168 , L157 , L165 , L167 , L162;
end;
thus L170: thesis by L158;
end;
L171: (the Arrows of C68) c= D32
proof
let C75 being set;
assume L172: C75 in D31;
consider C76 , C77 being set such that L173: C76 in (the carrier of C67) and L174: C77 in (the carrier of C67) and L175: C75 = [ C76 , C77 ] by L172 , L150 , ZFMISC_1:84;
L176: (C76 in (the carrier of C68) & C77 in (the carrier of C68)) by L172 , L175 , ZFMISC_1:87;
L177: ( D32 . (C76 , C77) ) = ( (the Arrows of C67) . (C76 , C77) ) by L176 , L149 , ALTCAT_1:5;
let C78 being set;
assume L178: C78 in ( (the Arrows of C68) . C75 );
L179: (the Arrows of C68) cc= (the Arrows of C67) by ALTCAT_2:def 11;
L180: ( (the Arrows of C68) . (C76 , C77) ) c= ( (the Arrows of C67) . (C76 , C77) ) by L179 , L172 , L175 , ALTCAT_2:def 2;
thus L181: thesis by L180 , L175 , L178 , L177;
end;
thus L182: (the Arrows of C68) = ( (the Arrows of C67) || (the carrier of C68) ) by L171 , L155 , PBOOLE:146;
end;
begin
theorem
L183: (for B66 , B67 being non  empty AltCatStr holds (for B68 being  Covariant FunctorStr over B66 , B67 holds (B68 is  full iff (for B69 , B70 being (object of B66) holds ( Morph-Map (B68 , B69 , B70) ) is  onto))))
proof
let C79 , C80 being non  empty AltCatStr;
let C81 being  Covariant FunctorStr over C79 , C80;
set D33 = [: (the carrier of C79) , (the carrier of C79) :];
thus L184:now
assume L185: C81 is  full;
consider C82 being (ManySortedFunction of (the Arrows of C79) , ( (the Arrows of C80) * (the ObjectMap of C81) )) such that L186: C82 = (the MorphMap of C81) and L187: C82 is  "onto" by L185 , FUNCTOR0:def 32;
let C83 , C84 being (object of C79);
L188: [ C83 , C84 ] in D33 by ZFMISC_1:87;
L189: [ C83 , C84 ] in ( dom (the ObjectMap of C81) ) by L188 , FUNCT_2:def 1;
L190: ( rng ( C82 . [ C83 , C84 ] ) ) = ( ( (the Arrows of C80) * (the ObjectMap of C81) ) . [ C83 , C84 ] ) by L187 , L188 , MSUALG_3:def 3;
L191: ( rng ( Morph-Map (C81 , C83 , C84) ) ) = ( (the Arrows of C80) . ( (the ObjectMap of C81) . (C83 , C84) ) ) by L190 , L186 , L189 , FUNCT_1:13
.= ( (the Arrows of C80) . (( C81 . C83 ) , ( C81 . C84 )) ) by FUNCTOR0:22
.= <^ ( C81 . C83 ) , ( C81 . C84 ) ^> by ALTCAT_1:def 1;
thus L192: ( Morph-Map (C81 , C83 , C84) ) is  onto by L191 , FUNCT_2:def 3;
end;
L193: (ex B71 being non  empty set st (ex B72 being (ManySortedSet of B71) st (ex B73 being (Function of D33 , B71) st ((the ObjectMap of C81) = B73 & (the Arrows of C80) = B72 & (the MorphMap of C81) is (ManySortedFunction of (the Arrows of C79) , ( B72 * B73 )))))) by FUNCTOR0:def 3;
reconsider D34 = (the MorphMap of C81) as (ManySortedFunction of (the Arrows of C79) , ( (the Arrows of C80) * (the ObjectMap of C81) )) by L193;
assume L194: (for B74 , B75 being (object of C79) holds ( Morph-Map (C81 , B74 , B75) ) is  onto);
L195: D34 is  "onto"
proof
let C85 being set;
assume L196: C85 in D33;
consider C86 , C87 being set such that L197: (C86 in (the carrier of C79) & C87 in (the carrier of C79)) and L198: C85 = [ C86 , C87 ] by L196 , ZFMISC_1:84;
reconsider D35 = C86 , D36 = C87 as (object of C79) by L197;
L199: [ D35 , D36 ] in D33 by ZFMISC_1:87;
L200: [ D35 , D36 ] in ( dom (the ObjectMap of C81) ) by L199 , FUNCT_2:def 1;
L201: ( Morph-Map (C81 , D35 , D36) ) is  onto by L194;
L202: ( rng ( Morph-Map (C81 , D35 , D36) ) ) = <^ ( C81 . D35 ) , ( C81 . D36 ) ^> by L201 , FUNCT_2:def 3
.= ( (the Arrows of C80) . (( C81 . D35 ) , ( C81 . D36 )) ) by ALTCAT_1:def 1
.= ( (the Arrows of C80) . ( (the ObjectMap of C81) . (D35 , D36) ) ) by FUNCTOR0:22
.= ( ( (the Arrows of C80) * (the ObjectMap of C81) ) . (D35 , D36) ) by L200 , FUNCT_1:13;
thus L203: thesis by L202 , L198;
end;
thus L204: (ex B76 being (ManySortedFunction of (the Arrows of C79) , ( (the Arrows of C80) * (the ObjectMap of C81) )) st (B76 = (the MorphMap of C81) & B76 is  "onto")) by L195;
end;
theorem
L205: (for B77 , B78 being non  empty AltCatStr holds (for B79 being  Covariant FunctorStr over B77 , B78 holds (B79 is  faithful iff (for B80 , B81 being (object of B77) holds ( Morph-Map (B79 , B80 , B81) ) is  one-to-one))))
proof
let C88 , C89 being non  empty AltCatStr;
let C90 being  Covariant FunctorStr over C88 , C89;
set D37 = [: (the carrier of C88) , (the carrier of C88) :];
thus L206:now
assume L207: C90 is  faithful;
L208: (the MorphMap of C90) is  "1-1" by L207 , FUNCTOR0:def 30;
let C91 , C92 being (object of C88);
L209: ([ C91 , C92 ] in D37 & ( dom (the MorphMap of C90) ) = D37) by PARTFUN1:def 2 , ZFMISC_1:87;
thus L210: ( Morph-Map (C90 , C91 , C92) ) is  one-to-one by L209 , L208 , MSUALG_3:def 2;
end;
assume L211: (for B82 , B83 being (object of C88) holds ( Morph-Map (C90 , B82 , B83) ) is  one-to-one);
let C93 being set;
let C94 being Function;
assume that
L212: C93 in ( dom (the MorphMap of C90) )
and
L213: ( (the MorphMap of C90) . C93 ) = C94;
L214: ( dom (the MorphMap of C90) ) = D37 by PARTFUN1:def 2;
consider C95 , C96 being set such that L215: (C95 in (the carrier of C88) & C96 in (the carrier of C88)) and L216: C93 = [ C95 , C96 ] by L214 , L212 , ZFMISC_1:84;
reconsider D38 = C95 , D39 = C96 as (object of C88) by L215;
L217: ( (the MorphMap of C90) . (D38 , D39) ) = ( Morph-Map (C90 , D38 , D39) );
thus L218: thesis by L217 , L211 , L213 , L216;
end;
begin
theorem
L219: (for B84 being  transitive  with_units non  empty AltCatStr holds ( ( id B84 ) " ) = ( id B84 ))
proof
let C97 being  transitive  with_units non  empty AltCatStr;
set D40 = [: (the carrier of C97) , (the carrier of C97) :];
consider C98 being (ManySortedFunction of (the Arrows of C97) , ( (the Arrows of C97) * (the ObjectMap of ( id C97 )) )) such that L220: C98 = (the MorphMap of ( id C97 )) and L221: (the MorphMap of ( ( id C97 ) " )) = ( ( C98 "" ) * ( (the ObjectMap of ( id C97 )) " ) ) by FUNCTOR0:def 38;
L222: (for B85 being set holds (B85 in D40 implies ( ( id (the Arrows of C97) ) . B85 ) is  one-to-one))
proof
let C99 being set;
assume that
L223: C99 in D40;
L224: ( id ( (the Arrows of C97) . C99 ) ) is  one-to-one;
thus L225: thesis by L224 , L223 , MSUALG_3:def 1;
end;
L226: (the MorphMap of ( id C97 )) = ( id (the Arrows of C97) ) by FUNCTOR0:def 29;
L227: (the MorphMap of ( id C97 )) is  "1-1" by L226 , L222 , MSUALG_3:1;
L228: (for B86 being set holds (B86 in D40 implies ( rng ( C98 . B86 ) ) = ( ( (the Arrows of C97) * (the ObjectMap of ( id C97 )) ) . B86 )))
proof
L229: ( dom (the Arrows of C97) ) = D40 by PARTFUN1:def 2;
L230: ( ( dom (the Arrows of C97) ) /\ D40 ) = D40 by L229;
let C100 being set;
assume that
L231: C100 in D40;
L232: ( rng ( C98 . C100 ) ) = ( rng ( ( id (the Arrows of C97) ) . C100 ) ) by L220 , FUNCTOR0:def 29
.= ( rng ( id ( (the Arrows of C97) . C100 ) ) ) by L231 , MSUALG_3:def 1
.= ( (the Arrows of C97) . C100 )
.= ( ( (the Arrows of C97) * ( id D40 ) ) . C100 ) by L231 , L230 , FUNCT_1:20
.= ( ( (the Arrows of C97) * (the ObjectMap of ( id C97 )) ) . C100 ) by FUNCTOR0:def 29;
thus L233: thesis by L232;
end;
L234: C98 is  "onto" by L228 , MSUALG_3:def 3;
L235: (for B87 being set holds (B87 in D40 implies ( ( C98 "" ) . B87 ) = ( C98 . B87 )))
proof
let C101 being set;
assume L236: C101 in D40;
L237: ( ( C98 "" ) . C101 ) = ( ( (the MorphMap of ( id C97 )) . C101 ) " ) by L236 , L220 , L227 , L234 , MSUALG_3:def 4
.= ( ( ( id (the Arrows of C97) ) . C101 ) " ) by FUNCTOR0:def 29
.= ( ( id ( (the Arrows of C97) . C101 ) ) " ) by L236 , MSUALG_3:def 1
.= ( id ( (the Arrows of C97) . C101 ) ) by FUNCT_1:45
.= ( ( id (the Arrows of C97) ) . C101 ) by L236 , MSUALG_3:def 1
.= ( C98 . C101 ) by L220 , FUNCTOR0:def 29;
thus L238: thesis by L237;
end;
L239: ( C98 "" ) = C98 by L235 , PBOOLE:3;
L240: (for B88 being set holds (B88 in D40 implies ( ( (the MorphMap of ( id C97 )) * ( id D40 ) ) . B88 ) = ( (the MorphMap of ( id C97 )) . B88 )))
proof
L241: ( dom (the MorphMap of ( id C97 )) ) = D40 by PARTFUN1:def 2;
L242: ( ( dom (the MorphMap of ( id C97 )) ) /\ D40 ) = D40 by L241;
let C102 being set;
assume L243: C102 in D40;
thus L244: thesis by L243 , L242 , FUNCT_1:20;
end;
L245: ( (the MorphMap of ( id C97 )) * ( id D40 ) ) = (the MorphMap of ( id C97 )) by L240 , PBOOLE:3;
L246: (the ObjectMap of ( ( id C97 ) " )) = ( (the ObjectMap of ( id C97 )) " ) by FUNCTOR0:def 38;
L247: (the ObjectMap of ( ( id C97 ) " )) = ( ( id D40 ) " ) by L246 , FUNCTOR0:def 29
.= ( id D40 ) by FUNCT_1:45
.= (the ObjectMap of ( id C97 )) by FUNCTOR0:def 29;
thus L248: thesis by L247 , L246 , L220 , L221 , L239 , L245 , FUNCTOR0:def 29;
end;
theorem
L249: (for B89 , B90 being  transitive  with_units  reflexive non  empty AltCatStr holds (for B91 being  feasible FunctorStr over B89 , B90 holds (B91 is  bijective implies (for B92 being  feasible FunctorStr over B90 , B89 holds (( the FunctorStr of B92 ) = ( B91 " ) implies ( B91 * B92 ) = ( id B90 ))))))
proof
let C103 , C104 being  transitive  with_units  reflexive non  empty AltCatStr;
set D41 = [: (the carrier of C103) , (the carrier of C103) :];
set D42 = [: (the carrier of C104) , (the carrier of C104) :];
let C105 being  feasible FunctorStr over C103 , C104;
assume that
L250: C105 is  bijective;
consider C106 being (ManySortedFunction of (the Arrows of C103) , ( (the Arrows of C104) * (the ObjectMap of C105) )) such that L251: C106 = (the MorphMap of C105) and L252: (the MorphMap of ( C105 " )) = ( ( C106 "" ) * ( (the ObjectMap of C105) " ) ) by L250 , FUNCTOR0:def 38;
L253: C105 is  injective by L250 , FUNCTOR0:def 35;
L254: C105 is  one-to-one by L253 , FUNCTOR0:def 33;
L255: (the ObjectMap of C105) is  one-to-one by L254 , FUNCTOR0:def 6;
set D43 = (the ObjectMap of C105);
L256: C105 is  surjective by L250 , FUNCTOR0:def 35;
L257: C105 is  onto by L256 , FUNCTOR0:def 34;
L258: (the ObjectMap of C105) is  onto by L257 , FUNCTOR0:def 7;
L259: ( rng D43 ) = D42 by L258 , FUNCT_2:def 3;
L260: C105 is  injective by L250 , FUNCTOR0:def 35;
L261: C105 is  faithful by L260 , FUNCTOR0:def 33;
L262: (the MorphMap of C105) is  "1-1" by L261 , FUNCTOR0:def 30;
L263: C105 is  surjective by L250 , FUNCTOR0:def 35;
L264: C105 is  full  onto by L263 , FUNCTOR0:def 34;
consider C107 being (ManySortedFunction of (the Arrows of C103) , ( (the Arrows of C104) * (the ObjectMap of C105) )) such that L265: C107 = (the MorphMap of C105) and L266: C107 is  "onto" by L264 , FUNCTOR0:def 32;
let C108 being  feasible FunctorStr over C104 , C103;
assume that
L267: ( the FunctorStr of C108 ) = ( C105 " );
L268: (the ObjectMap of C108) = ( (the ObjectMap of C105) " ) by L250 , L267 , FUNCTOR0:def 38;
L269: ( the FunctorStr of C108 ) is  bijective by L250 , L267 , FUNCTOR0:35;
L270: ( the FunctorStr of C108 ) is  surjective by L269 , FUNCTOR0:def 35;
L271: ( the FunctorStr of C108 ) is  full  onto by L270 , FUNCTOR0:def 34;
L272: (the ObjectMap of C108) is  onto by L271 , FUNCTOR0:def 7;
set D44 = (the ObjectMap of C108);
L273: ( dom D43 ) = D41 by FUNCT_2:def 1;
reconsider D45 = D43 as (bifunction of (the carrier of C103) , (the carrier of C104));
L274: D42 = ( dom ( ( C107 * D44 ) ** ( ( C106 "" ) * D44 ) ) ) by PARTFUN1:def 2;
L275: (for B93 being set holds (B93 in D42 implies ( ( ( C107 * D44 ) ** ( ( C106 "" ) * D44 ) ) . B93 ) = ( ( id (the Arrows of C104) ) . B93 )))
proof
let C109 being set;
assume that
L276: C109 in D42;
L277: ( dom D44 ) = D42 by FUNCT_2:def 1;
L278: ( ( C107 * D44 ) . C109 ) = ( C106 . ( D44 . C109 ) ) by L277 , L251 , L265 , L276 , FUNCT_1:13;
L279: ( rng D44 ) = D41 by L272 , FUNCT_2:def 3;
L280: ( D44 . C109 ) in D41 by L279 , L276 , L277 , FUNCT_1:def 3;
L281: ( rng ( C107 . ( D44 . C109 ) ) ) = ( ( (the Arrows of C104) * (the ObjectMap of C105) ) . ( D44 . C109 ) ) by L280 , L266 , MSUALG_3:def 3
.= ( (the Arrows of C104) . ( (the ObjectMap of C105) . ( D44 . C109 ) ) ) by L273 , L280 , FUNCT_1:13;
L282: ( (the ObjectMap of C105) . ( D44 . C109 ) ) = ( ( D45 * ( D45 " ) ) . C109 ) by L268 , L276 , L277 , FUNCT_1:13
.= ( ( id D42 ) . C109 ) by L255 , L259 , FUNCT_1:39
.= C109 by L276 , FUNCT_1:18;
L283: (C107 is  "1-1" & ( dom C107 ) = D41) by L261 , L265 , FUNCTOR0:def 30 , PARTFUN1:def 2;
L284: ( C107 . ( D44 . C109 ) ) is  one-to-one by L283 , L280 , MSUALG_3:def 2;
L285: ( ( ( C106 "" ) * D44 ) . C109 ) = ( ( C106 "" ) . ( D44 . C109 ) ) by L276 , L277 , FUNCT_1:13
.= ( ( C106 . ( D44 . C109 ) ) " ) by L262 , L251 , L265 , L266 , L280 , MSUALG_3:def 4;
L286: ( ( ( C107 * D44 ) ** ( ( C106 "" ) * D44 ) ) . C109 ) = ( ( C107 . ( D44 . C109 ) ) * ( ( C107 . ( D44 . C109 ) ) " ) ) by L285 , L251 , L265 , L274 , L276 , L278 , PBOOLE:def 19
.= ( id ( (the Arrows of C104) . C109 ) ) by L284 , L281 , L282 , FUNCT_1:39
.= ( ( id (the Arrows of C104) ) . C109 ) by L276 , MSUALG_3:def 1;
thus L287: thesis by L286;
end;
L288: (the MorphMap of ( C105 * C108 )) = ( ( C107 * D44 ) ** ( ( C106 "" ) * D44 ) ) by L267 , L252 , L265 , L268 , FUNCTOR0:def 36;
L289: (the MorphMap of ( C105 * C108 )) = ( id (the Arrows of C104) ) by L288 , L275 , PBOOLE:3;
L290: (the ObjectMap of ( C105 * C108 )) = ( (the ObjectMap of C105) * (the ObjectMap of C108) ) by FUNCTOR0:def 36;
L291: (the ObjectMap of ( C105 * C108 )) = ( (the ObjectMap of C105) * ( (the ObjectMap of C105) " ) ) by L290 , L250 , L267 , FUNCTOR0:def 38;
L292: (the ObjectMap of ( C105 * C108 )) = ( id [: (the carrier of C104) , (the carrier of C104) :] ) by L291 , L255 , L259 , FUNCT_1:39;
thus L293: thesis by L292 , L289 , FUNCTOR0:def 29;
end;
L294: (for B94 being set holds (for B95 , B96 being (ManySortedSet of B94) holds (B95 is_transformable_to B96 implies (for B97 being (ManySortedFunction of B95 , B96) holds (for B98 being (ManySortedFunction of B96 , B95) holds ((B97 is  "1-1"  "onto" & B98 = ( B97 "" )) implies (( B97 ** B98 ) = ( id B96 ) & ( B98 ** B97 ) = ( id B95 ))))))))
proof
let C110 being set;
let C111 , C112 being (ManySortedSet of C110);
assume that
L295: C111 is_transformable_to C112;
let C113 being (ManySortedFunction of C111 , C112);
let C114 being (ManySortedFunction of C112 , C111);
assume that
L296: C113 is  "1-1"  "onto"
and
L297: C114 = ( C113 "" );
reconsider D46 = ( C113 ** C114 ) as (ManySortedFunction of C110);
L298:
now
let C115 being set;
assume L299: C115 in C110;
reconsider D47 = ( C113 . C115 ) as (Function of ( C111 . C115 ) , ( C112 . C115 )) by L299 , PBOOLE:def 15;
reconsider D48 = ( C114 . C115 ) as (Function of ( C112 . C115 ) , ( C111 . C115 )) by L299 , PBOOLE:def 15;
L300: C115 in ( dom C113 ) by L299 , PARTFUN1:def 2;
L301: D47 is  one-to-one by L300 , L296 , MSUALG_3:def 2;
L302: D48 = ( D47 " ) by L296 , L297 , L299 , MSUALG_3:def 4;
L303: ( D47 * D48 ) = ( id ( rng D47 ) ) by L302 , L301 , FUNCT_1:39;
L304: ( D47 * D48 ) = ( id ( C112 . C115 ) ) by L303 , L296 , L299 , MSUALG_3:def 3;
thus L305: ( ( C113 ** C114 ) . C115 ) = ( id ( C112 . C115 ) ) by L304 , L299 , MSUALG_3:2;
end;
L306:
now
let C116 being set;
assume L307: C116 in C110;
L308: ( D46 . C116 ) = ( id ( C112 . C116 ) ) by L307 , L298;
thus L309: ( D46 . C116 ) is (Function of ( C112 . C116 ) , ( C112 . C116 )) by L308;
end;
L310: D46 is (ManySortedFunction of C112 , C112) by L306 , PBOOLE:def 15;
reconsider D49 = ( C114 ** C113 ) as (ManySortedFunction of C110);
L311: (for B99 being set holds (B99 in C110 implies ( ( C114 ** C113 ) . B99 ) = ( id ( C111 . B99 ) )))
proof
let C117 being set;
assume L312: C117 in C110;
reconsider D50 = ( C113 . C117 ) as (Function of ( C111 . C117 ) , ( C112 . C117 )) by L312 , PBOOLE:def 15;
reconsider D51 = ( C114 . C117 ) as (Function of ( C112 . C117 ) , ( C111 . C117 )) by L312 , PBOOLE:def 15;
L313: C117 in ( dom C113 ) by L312 , PARTFUN1:def 2;
L314: D50 is  one-to-one by L313 , L296 , MSUALG_3:def 2;
L315: (( C112 . C117 ) = ( {} ) implies ( C111 . C117 ) = ( {} )) by L295 , L312 , PZFMISC1:def 3;
L316: ( dom D50 ) = ( C111 . C117 ) by L315 , FUNCT_2:def 1;
L317: D51 = ( D50 " ) by L296 , L297 , L312 , MSUALG_3:def 4;
L318: ( D51 * D50 ) = ( id ( C111 . C117 ) ) by L317 , L314 , L316 , FUNCT_1:39;
thus L319: thesis by L318 , L312 , MSUALG_3:2;
end;
L320:
now
let C118 being set;
assume L321: C118 in C110;
L322: ( ( C114 ** C113 ) . C118 ) = ( id ( C111 . C118 ) ) by L321 , L311;
thus L323: ( ( C114 ** C113 ) . C118 ) is (Function of ( C111 . C118 ) , ( C111 . C118 )) by L322;
end;
reconsider D52 = D49 as (ManySortedFunction of C111 , C111) by L320 , PBOOLE:def 15;
L324: D52 = ( id C111 ) by L311 , MSUALG_3:def 1;
thus L325: thesis by L324 , L298 , L310 , MSUALG_3:def 1;
end;
theorem
L326: (for B100 , B101 being  transitive  with_units  reflexive non  empty AltCatStr holds (for B102 being  feasible FunctorStr over B100 , B101 holds (B102 is  bijective implies ( ( B102 " ) * B102 ) = ( id B100 ))))
proof
let C119 , C120 being  transitive  with_units  reflexive non  empty AltCatStr;
set D53 = [: (the carrier of C119) , (the carrier of C119) :];
let C121 being  feasible FunctorStr over C119 , C120;
assume that
L327: C121 is  bijective;
consider C122 being (ManySortedFunction of (the Arrows of C119) , ( (the Arrows of C120) * (the ObjectMap of C121) )) such that L328: C122 = (the MorphMap of C121) and L329: (the MorphMap of ( C121 " )) = ( ( C122 "" ) * ( (the ObjectMap of C121) " ) ) by L327 , FUNCTOR0:def 38;
set D54 = (the ObjectMap of C121);
L330: ( dom D54 ) = D53 by FUNCT_2:def 1;
L331: (the Arrows of C119) is_transformable_to ( (the Arrows of C120) * (the ObjectMap of C121) )
proof
let C123 being set;
assume L332: C123 in D53;
consider C124 , C125 being set such that L333: (C124 in (the carrier of C119) & C125 in (the carrier of C119)) and L334: C123 = [ C124 , C125 ] by L332 , ZFMISC_1:84;
reconsider D55 = C124 , D56 = C125 as (object of C119) by L333;
L335: ( (the Arrows of C119) . C123 ) = ( (the Arrows of C119) . (D55 , D56) ) by L334
.= <^ D55 , D56 ^> by ALTCAT_1:def 1;
assume L336: ( ( (the Arrows of C120) * (the ObjectMap of C121) ) . C123 ) = ( {} );
L337: ( (the Arrows of C120) . ( (the ObjectMap of C121) . (D55 , D56) ) ) = ( {} ) by L336 , L332 , L334 , FUNCT_2:15;
thus L338: thesis by L337 , L335 , FUNCTOR0:def 11;
end;
L339: C121 is  injective by L327 , FUNCTOR0:def 35;
L340: C121 is  faithful by L339 , FUNCTOR0:def 33;
L341: (the MorphMap of C121) is  "1-1" by L340 , FUNCTOR0:def 30;
L342: (for B103 being set holds (B103 in D53 implies ( ( ( C122 "" ) * ( id D53 ) ) . B103 ) = ( ( C122 "" ) . B103 )))
proof
let C126 being set;
assume L343: C126 in D53;
L344: ( ( ( C122 "" ) * ( id D53 ) ) . C126 ) = ( ( C122 "" ) . ( ( id D53 ) . C126 ) ) by L343 , FUNCT_2:15
.= ( ( C122 "" ) . C126 ) by L343 , FUNCT_1:18;
thus L345: thesis by L344;
end;
L346: ( ( C122 "" ) * ( id D53 ) ) = ( C122 "" ) by L342 , PBOOLE:3;
L347: C121 is  injective by L327 , FUNCTOR0:def 35;
L348: C121 is  one-to-one by L347 , FUNCTOR0:def 33;
L349: (the ObjectMap of C121) is  one-to-one by L348 , FUNCTOR0:def 6;
L350: (the ObjectMap of ( ( C121 " ) * C121 )) = ( (the ObjectMap of ( C121 " )) * (the ObjectMap of C121) ) by FUNCTOR0:def 36;
L351: (the ObjectMap of ( ( C121 " ) * C121 )) = ( ( (the ObjectMap of C121) " ) * (the ObjectMap of C121) ) by L350 , L327 , FUNCTOR0:def 38;
L352: (the ObjectMap of ( ( C121 " ) * C121 )) = ( id [: (the carrier of C119) , (the carrier of C119) :] ) by L351 , L349 , L330 , FUNCT_1:39;
L353: C121 is  surjective by L327 , FUNCTOR0:def 35;
L354: C121 is  full  onto by L353 , FUNCTOR0:def 34;
L355: (ex B104 being (ManySortedFunction of (the Arrows of C119) , ( (the Arrows of C120) * (the ObjectMap of C121) )) st (B104 = (the MorphMap of C121) & B104 is  "onto")) by L354 , FUNCTOR0:def 32;
L356: (the MorphMap of ( ( C121 " ) * C121 )) = ( ( ( ( C122 "" ) * ( (the ObjectMap of C121) " ) ) * (the ObjectMap of C121) ) ** C122 ) by L328 , L329 , FUNCTOR0:def 36
.= ( ( ( C122 "" ) * ( ( (the ObjectMap of C121) " ) * (the ObjectMap of C121) ) ) ** C122 ) by RELAT_1:36;
L357: (the MorphMap of ( ( C121 " ) * C121 )) = ( ( ( C122 "" ) * ( id D53 ) ) ** C122 ) by L356 , L349 , L330 , FUNCT_1:39;
L358: (the MorphMap of ( ( C121 " ) * C121 )) = ( id (the Arrows of C119) ) by L357 , L331 , L328 , L341 , L355 , L346 , L294;
thus L359: thesis by L358 , L352 , FUNCTOR0:def 29;
end;
theorem
L360: (for B105 , B106 being  transitive  with_units  reflexive non  empty AltCatStr holds (for B107 being  feasible FunctorStr over B105 , B106 holds (B107 is  bijective implies ( ( B107 " ) " ) = ( the FunctorStr of B107 ))))
proof
let C127 , C128 being  transitive  with_units  reflexive non  empty AltCatStr;
set D57 = [: (the carrier of C127) , (the carrier of C127) :];
set D58 = [: (the carrier of C128) , (the carrier of C128) :];
let C129 being  feasible FunctorStr over C127 , C128;
assume that
L361: C129 is  bijective;
L362: C129 is  injective by L361 , FUNCTOR0:def 35;
L363: C129 is  one-to-one by L362 , FUNCTOR0:def 33;
L364: (the ObjectMap of C129) is  one-to-one by L363 , FUNCTOR0:def 6;
L365: ( C129 " ) is  bijective by L361 , FUNCTOR0:35;
L366: ( C129 " ) is  surjective by L365 , FUNCTOR0:def 35;
L367: ( C129 " ) is  full by L366 , FUNCTOR0:def 34;
L368: ( C129 " ) is  injective by L365 , FUNCTOR0:def 35;
L369: ( C129 " ) is  faithful by L368 , FUNCTOR0:def 33;
L370: ( (the ObjectMap of ( C129 " )) " ) = ( ( (the ObjectMap of C129) " ) " ) by L361 , FUNCTOR0:def 38
.= (the ObjectMap of C129) by L364 , FUNCT_1:43;
L371: C129 is  faithful by L362 , FUNCTOR0:def 33;
L372: (the MorphMap of C129) is  "1-1" by L371 , FUNCTOR0:def 30;
L373: C129 is  surjective by L361 , FUNCTOR0:def 35;
L374: C129 is  onto by L373 , FUNCTOR0:def 34;
L375: (the ObjectMap of C129) is  onto by L374 , FUNCTOR0:def 7;
L376: ( rng (the ObjectMap of C129) ) = D58 by L375 , FUNCT_2:def 3;
L377: C129 is  full by L373 , FUNCTOR0:def 34;
L378: (the MorphMap of ( ( C129 " ) " )) = (the MorphMap of C129)
proof
L379: (ex B108 being (ManySortedFunction of (the Arrows of C128) , ( (the Arrows of C127) * (the ObjectMap of ( C129 " )) )) st (B108 = (the MorphMap of ( C129 " )) & B108 is  "onto")) by L367 , FUNCTOR0:def 32;
L380: (ex B109 being (ManySortedFunction of (the Arrows of C127) , ( (the Arrows of C128) * (the ObjectMap of C129) )) st (B109 = (the MorphMap of C129) & B109 is  "onto")) by L377 , FUNCTOR0:def 32;
consider C130 being (ManySortedFunction of (the Arrows of C128) , ( (the Arrows of C127) * (the ObjectMap of ( C129 " )) )) such that L381: C130 = (the MorphMap of ( C129 " )) and L382: (the MorphMap of ( ( C129 " ) " )) = ( ( C130 "" ) * ( (the ObjectMap of ( C129 " )) " ) ) by L365 , FUNCTOR0:def 38;
consider C131 being (ManySortedFunction of (the Arrows of C127) , ( (the Arrows of C128) * (the ObjectMap of C129) )) such that L383: C131 = (the MorphMap of C129) and L384: (the MorphMap of ( C129 " )) = ( ( C131 "" ) * ( (the ObjectMap of C129) " ) ) by L361 , FUNCTOR0:def 38;
L385: C130 is  "1-1" by L369 , L381 , FUNCTOR0:def 30;
L386: (for B110 being set holds (B110 in D57 implies ( ( ( C130 "" ) * ( (the ObjectMap of ( C129 " )) " ) ) . B110 ) = ( (the MorphMap of C129) . B110 )))
proof
L387: ( (the ObjectMap of C129) " ) is (Function of D58 , D57) by L364 , L376 , FUNCT_2:25;
let C132 being set;
assume L388: C132 in D57;
L389: ( (the ObjectMap of C129) . C132 ) in D58 by L388 , FUNCT_2:5;
L390: ( (the ObjectMap of C129) " ) is (Function of D58 , D57) by L364 , L376 , FUNCT_2:25;
L391: ( ( (the ObjectMap of C129) " ) . ( (the ObjectMap of C129) . C132 ) ) in D57 by L390 , L389 , FUNCT_2:5;
L392: ( C131 . C132 ) is  one-to-one by L372 , L383 , L388 , MSUALG_3:1;
L393: ( ( ( C130 "" ) * ( (the ObjectMap of ( C129 " )) " ) ) . C132 ) = ( ( C130 "" ) . ( (the ObjectMap of C129) . C132 ) ) by L370 , L388 , FUNCT_2:15
.= ( ( (the MorphMap of ( C129 " )) . ( (the ObjectMap of C129) . C132 ) ) " ) by L381 , L379 , L385 , L389 , MSUALG_3:def 4
.= ( ( ( C131 "" ) . ( ( (the ObjectMap of C129) " ) . ( (the ObjectMap of C129) . C132 ) ) ) " ) by L384 , L388 , L387 , FUNCT_2:5 , FUNCT_2:15
.= ( ( ( C131 . ( ( (the ObjectMap of C129) " ) . ( (the ObjectMap of C129) . C132 ) ) ) " ) " ) by L372 , L383 , L380 , L391 , MSUALG_3:def 4
.= ( ( ( C131 . C132 ) " ) " ) by L364 , L388 , FUNCT_2:26
.= ( (the MorphMap of C129) . C132 ) by L383 , L392 , FUNCT_1:43;
thus L394: thesis by L393;
end;
thus L395: thesis by L386 , L382 , PBOOLE:3;
end;
thus L396: thesis by L378 , L365 , L370 , FUNCTOR0:def 38;
end;
theorem
L397: (for B111 , B112 , B113 being  transitive  with_units  reflexive non  empty AltCatStr holds (for B114 being  feasible FunctorStr over B111 , B112 holds (for B115 being  feasible FunctorStr over B112 , B113 holds (for B116 being  feasible FunctorStr over B112 , B111 holds (for B117 being  feasible FunctorStr over B113 , B112 holds ((B115 is  bijective & B114 is  bijective & ( the FunctorStr of B116 ) = ( B114 " ) & ( the FunctorStr of B117 ) = ( B115 " )) implies ( ( B115 * B114 ) " ) = ( B116 * B117 )))))))
proof
let C133 , C134 , C135 being  transitive  with_units  reflexive non  empty AltCatStr;
let C136 being  feasible FunctorStr over C133 , C134;
let C137 being  feasible FunctorStr over C134 , C135;
let C138 being  feasible FunctorStr over C134 , C133;
let C139 being  feasible FunctorStr over C135 , C134;
assume that
L398: C137 is  bijective
and
L399: C136 is  bijective
and
L400: ( the FunctorStr of C138 ) = ( C136 " )
and
L401: ( the FunctorStr of C139 ) = ( C137 " );
reconsider D59 = (the MorphMap of C137) as (ManySortedFunction of (the Arrows of C134) , ( (the Arrows of C135) * (the ObjectMap of C137) )) by FUNCTOR0:def 4;
L402: D59 is  "1-1" by L398 , L45;
set D60 = (the ObjectMap of C136);
set D61 = [: (the carrier of C134) , (the carrier of C134) :];
set D62 = [: (the carrier of C133) , (the carrier of C133) :];
reconsider D63 = ( D60 " ) as (Function of D61 , D62) by L399 , L13 , L45;
set D64 = [: (the carrier of C135) , (the carrier of C135) :];
set D65 = (the ObjectMap of C137);
reconsider D66 = ( D65 " ) as (Function of D64 , D61) by L398 , L13 , L45;
reconsider D67 = (the MorphMap of ( C137 * C136 )) as (ManySortedFunction of (the Arrows of C133) , ( (the Arrows of C135) * (the ObjectMap of ( C137 * C136 )) )) by FUNCTOR0:def 4;
reconsider D68 = D60 as (Function of D62 , D61);
reconsider D69 = (the ObjectMap of ( C137 * C136 )) as (Function of D62 , D64);
reconsider D70 = (the MorphMap of C136) as (ManySortedFunction of (the Arrows of C133) , ( (the Arrows of C134) * (the ObjectMap of C136) )) by FUNCTOR0:def 4;
L403: D70 is  "1-1" by L399 , L45;
L404: C137 is  surjective by L398 , FUNCTOR0:def 35;
L405: C137 is  full by L404 , FUNCTOR0:def 34;
L406: (ex B118 being (ManySortedFunction of (the Arrows of C134) , ( (the Arrows of C135) * (the ObjectMap of C137) )) st (B118 = (the MorphMap of C137) & B118 is  "onto")) by L405 , FUNCTOR0:def 32;
L407: C137 is  injective by L398 , FUNCTOR0:def 35;
L408: C137 is  one-to-one by L407 , FUNCTOR0:def 33;
L409: (the ObjectMap of C137) is  one-to-one by L408 , FUNCTOR0:def 6;
L410: C136 is  surjective by L399 , FUNCTOR0:def 35;
L411: C136 is  onto by L410 , FUNCTOR0:def 34;
L412: (the ObjectMap of C136) is  onto by L411 , FUNCTOR0:def 7;
L413: C136 is  full by L410 , FUNCTOR0:def 34;
L414: (ex B119 being (ManySortedFunction of (the Arrows of C133) , ( (the Arrows of C134) * (the ObjectMap of C136) )) st (B119 = (the MorphMap of C136) & B119 is  "onto")) by L413 , FUNCTOR0:def 32;
L415: C136 is  injective by L399 , FUNCTOR0:def 35;
L416: C136 is  one-to-one by L415 , FUNCTOR0:def 33;
L417: (the ObjectMap of C136) is  one-to-one by L416 , FUNCTOR0:def 6;
L418: ( C137 * C136 ) is  bijective by L398 , L399 , L126;
L419: ( C137 * C136 ) is  surjective by L418 , FUNCTOR0:def 35;
L420: ( C137 * C136 ) is  full by L419 , FUNCTOR0:def 34;
L421: (ex B120 being (ManySortedFunction of (the Arrows of C133) , ( (the Arrows of C135) * (the ObjectMap of ( C137 * C136 )) )) st (B120 = (the MorphMap of ( C137 * C136 )) & B120 is  "onto")) by L420 , FUNCTOR0:def 32;
L422: D67 is  "1-1" by L418 , L45;
L423: (the MorphMap of ( ( C137 * C136 ) " )) = (the MorphMap of ( C138 * C139 ))
proof
consider C140 being (ManySortedFunction of (the Arrows of C133) , ( (the Arrows of C135) * (the ObjectMap of ( C137 * C136 )) )) such that L424: C140 = (the MorphMap of ( C137 * C136 )) and L425: (the MorphMap of ( ( C137 * C136 ) " )) = ( ( C140 "" ) * ( (the ObjectMap of ( C137 * C136 )) " ) ) by L418 , FUNCTOR0:def 38;
L426: ( rng (the ObjectMap of C136) ) = D61 by L412 , FUNCT_2:def 3;
L427: (for B121 being set holds (B121 in D64 implies ( ( ( C140 "" ) * ( (the ObjectMap of ( C137 * C136 )) " ) ) . B121 ) = ( ( ( (the MorphMap of ( C136 " )) * (the ObjectMap of ( C137 " )) ) ** (the MorphMap of ( C137 " )) ) . B121 )))
proof
L428: ((ex B122 being (ManySortedFunction of (the Arrows of C134) , ( (the Arrows of C135) * (the ObjectMap of C137) )) st (B122 = (the MorphMap of C137) & (the MorphMap of ( C137 " )) = ( ( B122 "" ) * ( (the ObjectMap of C137) " ) ))) & (ex B123 being (ManySortedFunction of (the Arrows of C133) , ( (the Arrows of C134) * (the ObjectMap of C136) )) st (B123 = (the MorphMap of C136) & (the MorphMap of ( C136 " )) = ( ( B123 "" ) * ( (the ObjectMap of C136) " ) )))) by L398 , L399 , FUNCTOR0:def 38;
L429: (( D65 " ) = (the ObjectMap of ( C137 " )) & ( dom ( ( ( ( D70 "" ) * D63 ) * D66 ) ** ( ( D59 "" ) * D66 ) ) ) = D64) by L398 , FUNCTOR0:def 38 , PARTFUN1:def 2;
L430: ( D68 * ( D68 " ) ) = ( id D61 ) by L417 , L426 , FUNCT_2:29;
L431: ( D69 " ) = ( ( D65 * D68 ) " ) by FUNCTOR0:def 36
.= ( ( D68 " ) * ( D65 " ) ) by L409 , L417 , FUNCT_1:44;
let C141 being set;
assume that
L432: C141 in D64;
L433: ( ( ( D59 . ( D68 . ( ( ( D68 " ) * ( D65 " ) ) . C141 ) ) ) * ( D70 . ( ( D69 " ) . C141 ) ) ) " ) = ( ( ( D59 . ( D68 . ( D63 . ( D66 . C141 ) ) ) ) * ( D70 . ( ( D69 " ) . C141 ) ) ) " ) by L432 , FUNCT_2:15
.= ( ( ( D59 . ( ( D68 * D63 ) . ( D66 . C141 ) ) ) * ( D70 . ( ( D69 " ) . C141 ) ) ) " ) by L432 , FUNCT_2:5 , FUNCT_2:15
.= ( ( ( D59 . ( ( ( id D61 ) * D66 ) . C141 ) ) * ( D70 . ( ( D69 " ) . C141 ) ) ) " ) by L432 , L430 , FUNCT_2:15
.= ( ( ( D59 . ( ( D65 " ) . C141 ) ) * ( D70 . ( ( D63 * D66 ) . C141 ) ) ) " ) by L431 , FUNCT_2:17;
L434: ( D69 " ) is (Function of D64 , D62) by L418 , L13 , L45;
L435: (( dom ( ( D59 * D68 ) ** D70 ) ) = D62 & ( ( D69 " ) . C141 ) in D62) by L434 , L432 , FUNCT_2:5 , PARTFUN1:def 2;
L436: ( (the ObjectMap of ( C137 * C136 )) " ) is (Function of D64 , D62) by L418 , L13 , L45;
L437: ( ( (the ObjectMap of ( C137 * C136 )) " ) . C141 ) in D62 by L436 , L432 , FUNCT_2:5;
L438: C141 in ( dom ( (the ObjectMap of ( C137 * C136 )) " ) ) by L432 , L436 , FUNCT_2:def 1;
L439: ( ( ( C140 "" ) * ( (the ObjectMap of ( C137 * C136 )) " ) ) . C141 ) = ( ( D67 "" ) . ( ( (the ObjectMap of ( C137 * C136 )) " ) . C141 ) ) by L438 , L424 , FUNCT_1:13
.= ( ( D67 . ( ( (the ObjectMap of ( C137 * C136 )) " ) . C141 ) ) " ) by L421 , L422 , L437 , MSUALG_3:def 4
.= ( ( ( ( D59 * D68 ) ** D70 ) . ( ( D69 " ) . C141 ) ) " ) by FUNCTOR0:def 36
.= ( ( ( ( D59 * D68 ) . ( ( D69 " ) . C141 ) ) * ( D70 . ( ( D69 " ) . C141 ) ) ) " ) by L435 , PBOOLE:def 19
.= ( ( ( D59 . ( D68 . ( ( ( D68 " ) * ( D65 " ) ) . C141 ) ) ) * ( D70 . ( ( D69 " ) . C141 ) ) ) " ) by L432 , L436 , L431 , FUNCT_2:5 , FUNCT_2:15;
L440: ( D66 . C141 ) in D61 by L432 , FUNCT_2:5;
L441: ( D59 . ( D66 . C141 ) ) is  one-to-one by L440 , L402 , MSUALG_3:1;
L442: ( D63 . ( D66 . C141 ) ) in D62 by L440 , FUNCT_2:5;
L443: ( D70 . ( D63 . ( D66 . C141 ) ) ) is  one-to-one by L442 , L403 , MSUALG_3:1;
L444: ( ( ( D59 . ( ( D65 " ) . C141 ) ) * ( D70 . ( ( D63 * D66 ) . C141 ) ) ) " ) = ( ( ( D59 . ( ( D65 " ) . C141 ) ) * ( D70 . ( D63 . ( D66 . C141 ) ) ) ) " ) by L432 , FUNCT_2:15
.= ( ( ( D70 . ( D63 . ( D66 . C141 ) ) ) " ) * ( ( D59 . ( D66 . C141 ) ) " ) ) by L443 , L441 , FUNCT_1:44
.= ( ( ( D70 "" ) . ( D63 . ( D66 . C141 ) ) ) * ( ( D59 . ( ( D65 " ) . C141 ) ) " ) ) by L414 , L403 , L442 , MSUALG_3:def 4
.= ( ( ( ( D70 "" ) * D63 ) . ( D66 . C141 ) ) * ( ( D59 . ( ( D65 " ) . C141 ) ) " ) ) by L432 , FUNCT_2:5 , FUNCT_2:15
.= ( ( ( ( ( D70 "" ) * D63 ) * D66 ) . C141 ) * ( ( D59 . ( D66 . C141 ) ) " ) ) by L432 , FUNCT_2:15
.= ( ( ( ( ( D70 "" ) * D63 ) * D66 ) . C141 ) * ( ( D59 "" ) . ( D66 . C141 ) ) ) by L402 , L406 , L440 , MSUALG_3:def 4
.= ( ( ( ( ( D70 "" ) * D63 ) * D66 ) . C141 ) * ( ( ( D59 "" ) * D66 ) . C141 ) ) by L432 , FUNCT_2:15;
thus L445: thesis by L444 , L428 , L432 , L429 , L439 , L433 , PBOOLE:def 19;
end;
L446: (the MorphMap of ( ( C137 * C136 ) " )) = ( ( (the MorphMap of C138) * (the ObjectMap of C139) ) ** (the MorphMap of C139) ) by L427 , L400 , L401 , L425 , PBOOLE:3
.= (the MorphMap of ( C138 * C139 )) by FUNCTOR0:def 36;
thus L447: thesis by L446;
end;
L448: (the ObjectMap of ( ( C137 * C136 ) " )) = ( (the ObjectMap of ( C137 * C136 )) " ) by L418 , FUNCTOR0:def 38
.= ( ( (the ObjectMap of C137) * (the ObjectMap of C136) ) " ) by FUNCTOR0:def 36
.= ( ( (the ObjectMap of C136) " ) * ( (the ObjectMap of C137) " ) ) by L409 , L417 , FUNCT_1:44
.= ( (the ObjectMap of C138) * ( (the ObjectMap of C137) " ) ) by L399 , L400 , FUNCTOR0:def 38
.= ( (the ObjectMap of C138) * (the ObjectMap of C139) ) by L398 , L401 , FUNCTOR0:def 38
.= (the ObjectMap of ( C138 * C139 )) by FUNCTOR0:def 36;
thus L449: thesis by L448 , L423;
end;
