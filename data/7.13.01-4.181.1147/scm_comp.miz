:: A compiler of arithmetic expressions for { \bf SCM }
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received December 30, 1993
:: Copyright (c) 1993-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, AFINSQ_1, AMI_1, AMI_3, FINSEQ_1, SUBSET_1, ORDINAL4,
      ARYTM_3, FUNCT_1, ARYTM_1, XXREAL_0, RELAT_1, FSM_1, BINTREE1, DTCONSTR,
      STRUCT_0, XBOOLE_0, LANG1, AMI_2, ZFMISC_1, TDGROUP, TARSKI, CARD_1,
      TREES_4, TREES_3, QC_LANG1, CAT_1, INT_1, TREES_2, MCART_1, GRAPHSP,
      CONNSP_3, FUNCT_2, MSUALG_1, SCM_COMP, EXTPRO_1, VALUED_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, INT_1, XTUPLE_0, MCART_1, FUNCT_1, FUNCT_2, VALUED_1,
      TREES_2, TREES_3, TREES_4, AFINSQ_1, STRUCT_0, MEMSTR_0, COMPOS_1,
      EXTPRO_1, AMI_2, AMI_3, FINSEQ_1, LANG1, BINTREE1, DTCONSTR, PARTFUN1,
      PRE_POLY;
 constructors DTCONSTR, BINTREE1, DOMAIN_1, PRE_POLY, RELSET_1, AMI_3,
      XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1,
      FUNCT_2, NUMBERS, XREAL_0, INT_1, TREES_3, STRUCT_0, DTCONSTR, BINTREE1,
      AMI_3, AFINSQ_1, SCM_1, FINSEQ_1, COMPOS_0, MEMSTR_0, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, RELAT_1, AMI_3, AFINSQ_1, SCM_INST, XTUPLE_0;
 theorems AXIOMS, TARSKI, ZFMISC_1, NAT_1, INT_1, FINSEQ_1, FINSEQ_2, MCART_1,
      AMI_3, TREES_4, SCM_1, LANG1, DTCONSTR, BINTREE1, XBOOLE_0, TREES_3,
      FUNCT_1, XREAL_1, XXREAL_0, CARD_1, AFINSQ_1, FUNCT_2, EXTPRO_1,
      MEMSTR_0, AMI_2, XTUPLE_0;
 schemes BINTREE1;

begin
L1: 1 = { B1 where B1 is (Element of ( NAT )) : B1 < 1 } by AXIOMS:4;
L2: 5 = { B2 where B2 is (Element of ( NAT )) : B2 < 5 } by AXIOMS:4;
definition
func SCM-AE ->  binary  with_terminals  with_nonterminals  with_useful_nonterminals  strict non  empty DTConstrStr means 
:L3: (( Terminals it ) = ( SCM-Data-Loc ) & ( NonTerminals it ) = [: 1 , 5 :] & (for B3 , B4 , B5 being (Symbol of it) holds (B3 ==> <* B4 , B5 *> iff B3 in [: 1 , 5 :])));
existence
proof
defpred S1[ set , set , set ] means $1 in [: 1 , 5 :];
consider C1 being  binary  strict non  empty DTConstrStr such that L4: (the carrier of C1) = ( ( SCM-Data-Loc ) \/ [: 1 , 5 :] ) and L5: (for B6 , B7 , B8 being (Symbol of C1) holds (B6 ==> <* B7 , B8 *> iff S1[ B6 , B7 , B8 ])) from BINTREE1:sch 1;
L6: ( NonTerminals C1 ) = { B9 where B9 is (Symbol of C1) : (ex B10 being FinSequence st B9 ==> B10) } by LANG1:def 3;
L7: ( NonTerminals C1 ) = [: 1 , 5 :]
proof
thus L8: ( NonTerminals C1 ) c= [: 1 , 5 :]
proof
let C2 being set;
assume L9: C2 in ( NonTerminals C1 );
consider C3 being (Symbol of C1) such that L10: C2 = C3 and L11: (ex B11 being FinSequence st C3 ==> B11) by L9 , L6;
consider C4 being FinSequence such that L12: C3 ==> C4 by L11;
L13: (ex B12 , B13 being (Symbol of C1) st C4 = <* B12 , B13 *>) by L12 , BINTREE1:def 4;
thus L14: thesis by L13 , L5 , L10 , L12;
end;

let C5 being set;
assume L15: C5 in [: 1 , 5 :];
reconsider D1 = C5 as (Symbol of C1) by L15 , L4 , XBOOLE_0:def 3;
L16: D1 ==> <* D1 , D1 *> by L5 , L15;
thus L17: thesis by L16 , L6;
end;
L18: C1 is  with_nonterminals by L7 , DTCONSTR:def 4;
L19: ( Terminals C1 ) = { B14 where B14 is (Symbol of C1) : (not (ex B15 being FinSequence st B14 ==> B15)) } by LANG1:def 2;
L20: ( Terminals C1 ) = ( SCM-Data-Loc )
proof
thus L21: ( Terminals C1 ) c= ( SCM-Data-Loc )
proof
let C6 being set;
assume L22: C6 in ( Terminals C1 );
consider C7 being (Symbol of C1) such that L23: C6 = C7 and L24: (not (ex B16 being FinSequence st C7 ==> B16)) by L22 , L19;
assume L25: (not C6 in ( SCM-Data-Loc ));
L26: C7 in [: 1 , 5 :] by L25 , L4 , L23 , XBOOLE_0:def 3;
L27: C7 ==> <* C7 , C7 *> by L26 , L5;
thus L28: contradiction by L27 , L24;
end;

let C8 being set;
assume L29: C8 in ( SCM-Data-Loc );
L30: (ex B17 , B18 being set st (B17 in { 1 } & B18 in ( NAT ) & C8 = [ B17 , B18 ])) by L29 , ZFMISC_1:84;
reconsider D2 = C8 as (Symbol of C1) by L4 , L29 , XBOOLE_0:def 3;
assume L31: (not C8 in ( Terminals C1 ));
consider C9 being FinSequence such that L32: D2 ==> C9 by L31 , L19;
L33: (ex B19 , B20 being (Symbol of C1) st C9 = <* B19 , B20 *>) by L32 , BINTREE1:def 4;
L34: C8 in [: 1 , 5 :] by L33 , L5 , L32;
consider C10 , C11 being set such that L35: C10 in 1 and L36: C11 in 5 and L37: C8 = [ C10 , C11 ] by L34 , ZFMISC_1:84;
L38: C8 = [ ( 0 ) , C11 ] by L35 , L37 , CARD_1:49 , TARSKI:def 1;
thus L39: contradiction by L38 , L30 , XTUPLE_0:1;
end;
L40:
now
L41: ( dl. 1 ) in ( SCM-Data-Loc ) by AMI_2:def 16;
L42: ( dl. ( 0 ) ) in ( SCM-Data-Loc ) by AMI_2:def 16;
reconsider D3 = ( dl. ( 0 ) ) , D4 = ( dl. 1 ) as (Symbol of C1) by L42 , L4 , L41 , XBOOLE_0:def 3;
L43: ( root-tree D4 ) in ( TS C1 ) by L20 , L41 , DTCONSTR:def 1;
L44: ( root-tree D3 ) in ( TS C1 ) by L20 , L42 , DTCONSTR:def 1;
reconsider D5 = <* ( root-tree D3 ) , ( root-tree D4 ) *> as (FinSequence of ( TS C1 )) by L44 , L43 , FINSEQ_2:13;
let C12 being (Symbol of C1);
assume L45: C12 in ( NonTerminals C1 );
take D6 = D5;
L46: ( roots D6 ) = <* ( ( root-tree D3 ) . ( {} ) ) , ( ( root-tree D4 ) . ( {} ) ) *> by DTCONSTR:6
.= <* ( ( root-tree D3 ) . ( {} ) ) , D4 *> by TREES_4:3
.= <* D3 , D4 *> by TREES_4:3;
thus L47: C12 ==> ( roots D6 ) by L46 , L5 , L7 , L45;
end;
L48: C1 is  with_useful_nonterminals by L40 , DTCONSTR:def 5;
L49: C1 is  with_terminals by L20 , DTCONSTR:def 3;
thus L50: thesis by L49 , L5 , L20 , L7 , L18 , L48;
end;
uniqueness
proof
let C13 , C14 being  binary  with_terminals  with_nonterminals  with_useful_nonterminals  strict non  empty DTConstrStr;
assume that
L51: (( Terminals C13 ) = ( SCM-Data-Loc ) & ( NonTerminals C13 ) = [: 1 , 5 :])
and
L52: (for B21 , B22 , B23 being (Symbol of C13) holds (B21 ==> <* B22 , B23 *> iff B21 in [: 1 , 5 :]));
assume that
L53: (( Terminals C14 ) = ( SCM-Data-Loc ) & ( NonTerminals C14 ) = [: 1 , 5 :])
and
L54: (for B24 , B25 , B26 being (Symbol of C14) holds (B24 ==> <* B25 , B26 *> iff B24 in [: 1 , 5 :]));
L55: (the carrier of C13) = ( ( Terminals C13 ) \/ ( NonTerminals C13 ) ) by LANG1:1
.= (the carrier of C14) by L51 , L53 , LANG1:1;
L56: (the Rules of C13) = (the Rules of C14)
proof
set D7 = (the Rules of C13);
set D8 = (the Rules of C14);
let C15 , C16 being set;
thus L57:now
assume L58: [ C15 , C16 ] in D7;
reconsider D9 = C15 as (Symbol of C13) by L58 , ZFMISC_1:87;
reconsider D10 = C16 as (Element of ( (the carrier of C13) * )) by L58 , ZFMISC_1:87;
L59: D9 ==> D10 by L58 , LANG1:def 1;
consider C17 , C18 being (Symbol of C13) such that L60: D10 = <* C17 , C18 *> by L59 , BINTREE1:def 4;
reconsider D11 = D9 , D12 = C17 , D13 = C18 as (Symbol of C14) by L55;
L61: D11 in [: 1 , 5 :] by L52 , L59 , L60;
L62: D11 ==> <* D12 , D13 *> by L61 , L54;
thus L63: [ C15 , C16 ] in D8 by L62 , L60 , LANG1:def 1;
end;
assume L64: [ C15 , C16 ] in D8;
reconsider D14 = C15 as (Symbol of C14) by L64 , ZFMISC_1:87;
reconsider D15 = C16 as (Element of ( (the carrier of C14) * )) by L64 , ZFMISC_1:87;
L65: D14 ==> D15 by L64 , LANG1:def 1;
consider C19 , C20 being (Symbol of C14) such that L66: D15 = <* C19 , C20 *> by L65 , BINTREE1:def 4;
reconsider D16 = D14 , D17 = C19 , D18 = C20 as (Symbol of C13) by L55;
L67: D16 in [: 1 , 5 :] by L54 , L65 , L66;
L68: D16 ==> <* D17 , D18 *> by L67 , L52;
thus L69: thesis by L68 , L66 , LANG1:def 1;
end;
thus L70: thesis by L56 , L55;
end;
end;
definition
mode bin-term
 is (Element of ( TS ( SCM-AE ) ));
end;
L73: ( NonTerminals ( SCM-AE ) ) = [: 1 , 5 :] by L3;
definition
let C21 being (NonTerminal of ( SCM-AE ));
let C22 , C23 being bin-term;
redefine func C21 -tree (C22 , C23) -> bin-term;

coherence
proof
L74: C21 ==> <* ( root-label C22 ) , ( root-label C23 ) *> by L3 , L73;
L75: C21 ==> ( roots <* C22 , C23 *> ) by L74 , BINTREE1:2;
L76: ( C21 -tree <* C22 , C23 *> ) in ( TS ( SCM-AE ) ) by L75 , DTCONSTR:def 1;
thus L77: thesis by L76 , TREES_4:def 6;
end;
end;
definition
let C24 being (Terminal of ( SCM-AE ));
redefine func root-tree C24 -> bin-term;

coherence by DTCONSTR:def 1;
end;
definition
let C25 being (Terminal of ( SCM-AE ));
func @ C25 -> Data-Location equals 
C25;
coherence
proof
reconsider D19 = C25 as (Element of ( SCM-Data-Loc )) by L3;
L80: D19 in ( Data-Locations ( SCM ) ) by AMI_3:27;
reconsider D20 = D19 as (Object of ( SCM )) by L80;
L81: D20 is Data-Location by AMI_2:def 16;
thus L82: thesis by L81;
end;
end;
theorem
L84: (for B27 being (NonTerminal of ( SCM-AE )) holds (B27 = [ ( 0 ) , ( 0 ) ] or B27 = [ ( 0 ) , 1 ] or B27 = [ ( 0 ) , 2 ] or B27 = [ ( 0 ) , 3 ] or B27 = [ ( 0 ) , 4 ]))
proof
let C26 being (NonTerminal of ( SCM-AE ));
consider C27 , C28 being set such that L85: C27 in 1 and L86: C28 in 5 and L87: C26 = [ C27 , C28 ] by L73 , ZFMISC_1:84;
L88: C27 = ( 0 ) by L85 , CARD_1:49 , TARSKI:def 1;
consider C29 being (Element of ( NAT )) such that L89: C28 = C29 and L90: C29 < 5 by L86 , L2;
L91: 5 = ( 4 + 1 );
L92: C29 <= 4 by L91 , L90 , NAT_1:13;
thus L93: thesis by L92 , L87 , L88 , L89 , NAT_1:28;
end;
theorem
L94: ([ ( 0 ) , ( 0 ) ] is (NonTerminal of ( SCM-AE )) & [ ( 0 ) , 1 ] is (NonTerminal of ( SCM-AE )) & [ ( 0 ) , 2 ] is (NonTerminal of ( SCM-AE )) & [ ( 0 ) , 3 ] is (NonTerminal of ( SCM-AE )) & [ ( 0 ) , 4 ] is (NonTerminal of ( SCM-AE )))
proof
L95: (3 in 5 & 4 in 5) by L2;
L96: (1 in 5 & 2 in 5) by L2;
L97: (( 0 ) in 1 & ( 0 ) in 5) by L1 , L2;
thus L98: thesis by L97 , L96 , L95 , L73 , ZFMISC_1:87;
end;
reconsider D21 = [ ( 0 ) , ( 0 ) ] , D22 = [ ( 0 ) , 1 ] , D23 = [ ( 0 ) , 2 ] , D24 = [ ( 0 ) , 3 ] , D25 = [ ( 0 ) , 4 ] as (NonTerminal of ( SCM-AE )) by L94;
definition
let C30 , C31 being bin-term;
func C30 + C31 -> bin-term equals 
( [ ( 0 ) , ( 0 ) ] -tree (C30 , C31) );
coherence
proof
L99: ( D21 -tree (C30 , C31) ) in ( TS ( SCM-AE ) );
thus L100: thesis by L99;
end;
func C30 - C31 -> bin-term equals 
( [ ( 0 ) , 1 ] -tree (C30 , C31) );
coherence
proof
L101: ( D22 -tree (C30 , C31) ) in ( TS ( SCM-AE ) );
thus L102: thesis by L101;
end;
func C30 * C31 -> bin-term equals 
( [ ( 0 ) , 2 ] -tree (C30 , C31) );
coherence
proof
L103: ( D23 -tree (C30 , C31) ) in ( TS ( SCM-AE ) );
thus L104: thesis by L103;
end;
func C30 div C31 -> bin-term equals 
( [ ( 0 ) , 3 ] -tree (C30 , C31) );
coherence
proof
L105: ( D24 -tree (C30 , C31) ) in ( TS ( SCM-AE ) );
thus L106: thesis by L105;
end;
func C30 mod C31 -> bin-term equals 
( [ ( 0 ) , 4 ] -tree (C30 , C31) );
coherence
proof
L107: ( D25 -tree (C30 , C31) ) in ( TS ( SCM-AE ) );
thus L108: thesis by L107;
end;
end;
theorem
L110: (for B28 being bin-term holds ((ex B29 being (Terminal of ( SCM-AE )) st B28 = ( root-tree B29 )) or (ex B30 , B31 being bin-term st (B28 = ( B30 + B31 ) or B28 = ( B30 - B31 ) or B28 = ( B30 * B31 ) or B28 = ( B30 div B31 ) or B28 = ( B30 mod B31 )))))
proof
let C32 being bin-term;
L111: ( root-label C32 ) in (the carrier of ( SCM-AE ));
L112: ( C32 . ( {} ) ) in (the carrier of ( SCM-AE )) by L111 , BINTREE1:def 1;
L113: ( C32 . ( {} ) ) in ( ( Terminals ( SCM-AE ) ) \/ ( NonTerminals ( SCM-AE ) ) ) by L112 , LANG1:1;
per cases  by L113 , XBOOLE_0:def 3;
suppose L114: ( C32 . ( {} ) ) in ( Terminals ( SCM-AE ) );

reconsider D26 = ( C32 . ( {} ) ) as (Terminal of ( SCM-AE )) by L114;
L115: C32 = ( root-tree D26 ) by DTCONSTR:9;
thus L116: thesis by L115;
end;
suppose L117: ( C32 . ( {} ) ) in ( NonTerminals ( SCM-AE ) );

reconsider D27 = ( C32 . ( {} ) ) as (NonTerminal of ( SCM-AE )) by L117;
consider C33 being (FinSequence of ( TS ( SCM-AE ) )) such that L118: C32 = ( D27 -tree C33 ) and L119: D27 ==> ( roots C33 ) by DTCONSTR:10;
L120: (ex B32 , B33 being (Symbol of ( SCM-AE )) st ( roots C33 ) = <* B32 , B33 *>) by L119 , BINTREE1:def 4;
L121: ( len ( roots C33 ) ) = 2 by L120 , FINSEQ_1:44;
L122: (( dom ( roots C33 ) ) = ( dom C33 ) & ( dom ( roots C33 ) ) = ( Seg 2 )) by L121 , FINSEQ_1:def 3 , TREES_3:def 18;
L123: 2 in ( Seg 2 ) by FINSEQ_1:2 , TARSKI:def 2;
consider C34 being DecoratedTree such that L124: C34 = ( C33 . 2 ) and L125: ( ( roots C33 ) . 2 ) = ( C34 . ( {} ) ) by L123 , L122 , TREES_3:def 18;
L126: 1 in ( Seg 2 ) by FINSEQ_1:2 , TARSKI:def 2;
consider C35 being DecoratedTree such that L127: C35 = ( C33 . 1 ) and L128: ( ( roots C33 ) . 1 ) = ( C35 . ( {} ) ) by L126 , L122 , TREES_3:def 18;
reconsider D28 = C35 , D29 = C34 as bin-term by L122 , L126 , L123 , L127 , L124 , FINSEQ_2:11;
L129: ( len C33 ) = 2 by L122 , FINSEQ_1:def 3;
L130: C33 = <* D28 , D29 *> by L129 , L127 , L124 , FINSEQ_1:44;
L131: C32 = ( D27 -tree (D28 , D29) ) by L130 , L118 , TREES_4:def 6;
L132: (C32 = ( D28 + D29 ) or C32 = ( D28 - D29 ) or C32 = ( D28 * D29 ) or C32 = ( D28 div D29 ) or C32 = ( D28 mod D29 )) by L131 , L84;
thus L133: thesis by L132;
end;
end;
definition
let C36 being (NonTerminal of ( SCM-AE ));
let C37 , C38 being Integer;
func C36 -Meaning_on (C37 , C38) -> Integer equals 
:L135: ( C37 + C38 ) if C36 = [ ( 0 ) , ( 0 ) ] , ( C37 - C38 ) if C36 = [ ( 0 ) , 1 ] , ( C37 * C38 ) if C36 = [ ( 0 ) , 2 ] , ( C37 div C38 ) if C36 = [ ( 0 ) , 3 ] , ( C37 mod C38 ) if C36 = [ ( 0 ) , 4 ];
coherence;
consistency
proof
L136: (( [ ( 0 ) , 2 ] `2 ) = 2 & ( [ ( 0 ) , 3 ] `2 ) = 3);
L137: (( [ ( 0 ) , ( 0 ) ] `2 ) = ( 0 ) & ( [ ( 0 ) , 1 ] `2 ) = 1);
thus L138: thesis by L137 , L136 , MCART_1:7;
end;
end;
registration
let C39 being (State of ( SCM ));
let C40 being (Terminal of ( SCM-AE ));
cluster ( C39 . C40 ) ->  integer;
coherence
proof
L140: ( C39 . ( @ C40 ) ) = ( C39 . C40 );
thus L141: thesis by L140;
end;
end;
definition
let C41 being non  empty set;
let C42 being (Function of ( INT ) , C41);
let C43 being Integer;
redefine func C42 . C43 -> (Element of C41);

coherence
proof
reconsider D30 = C43 as (Element of ( INT )) by INT_1:def 2;
L143: ( C42 . D30 ) is (Element of C41);
thus L144: thesis by L143;
end;
end;
set D31 = ( id ( INT ) );
deffunc H1((NonTerminal of ( SCM-AE )) , set , set , Integer , Integer) = ( D31 . ( $1 -Meaning_on ($4 , $5) ) );
definition
let C44 being (State of ( SCM ));
let C45 being bin-term;
func C45 @ C44 -> Integer means 
:L146: (ex B34 being (Function of ( TS ( SCM-AE ) ) , ( INT )) st (it = ( B34 . C45 ) & (for B35 being (Terminal of ( SCM-AE )) holds ( B34 . ( root-tree B35 ) ) = ( C44 . B35 )) & (for B36 being (NonTerminal of ( SCM-AE )) holds (for B37 , B38 being bin-term holds (for B39 , B40 being (Symbol of ( SCM-AE )) holds ((B39 = ( root-label B37 ) & B40 = ( root-label B38 ) & B36 ==> <* B39 , B40 *>) implies (for B41 , B42 being (Element of ( INT )) holds ((B41 = ( B34 . B37 ) & B42 = ( B34 . B38 )) implies ( B34 . ( B36 -tree (B37 , B38) ) ) = ( B36 -Meaning_on (B41 , B42) )))))))));
existence
proof
deffunc H2((Terminal of ( SCM-AE ))) = ( D31 . ( C44 . $1 ) );
consider C46 being (Function of ( TS ( SCM-AE ) ) , ( INT )) such that L147: ((for B43 being (Terminal of ( SCM-AE )) holds ( C46 . ( root-tree B43 ) ) = H2(B43)) & (for B44 being (NonTerminal of ( SCM-AE )) holds (for B45 , B46 being bin-term holds (for B47 , B48 being (Symbol of ( SCM-AE )) holds ((B47 = ( root-label B45 ) & B48 = ( root-label B46 ) & B44 ==> <* B47 , B48 *>) implies (for B49 , B50 being (Element of ( INT )) holds ((B49 = ( C46 . B45 ) & B50 = ( C46 . B46 )) implies ( C46 . ( B44 -tree (B45 , B46) ) ) = H1(B44 , B47 , B48 , B49 , B50)))))))) from BINTREE1:sch 3;
reconsider D32 = ( C46 . C45 ) as (Element of ( INT ));
take D32;
take C46;
thus L148: D32 = ( C46 . C45 );
thus L149:now
let C47 being (Terminal of ( SCM-AE ));
L150: ( C44 . C47 ) in ( INT ) by INT_1:def 2;
L151: ( D31 . ( C44 . C47 ) ) = ( C44 . C47 ) by L150 , FUNCT_1:18;
thus L152: ( C46 . ( root-tree C47 ) ) = ( C44 . C47 ) by L151 , L147;
end;
let C48 being (NonTerminal of ( SCM-AE ));
let C49 , C50 being bin-term;
let C51 , C52 being (Symbol of ( SCM-AE ));
assume L153: (C51 = ( root-label C49 ) & C52 = ( root-label C50 ) & C48 ==> <* C51 , C52 *>);
let C53 , C54 being (Element of ( INT ));
L154: ( C48 -Meaning_on (C53 , C54) ) in ( INT ) by INT_1:def 2;
L155: ( D31 . ( C48 -Meaning_on (C53 , C54) ) ) = ( C48 -Meaning_on (C53 , C54) ) by L154 , FUNCT_1:18;
thus L156: thesis by L155 , L147 , L153;
end;
uniqueness
proof
deffunc H3((Terminal of ( SCM-AE ))) = ( D31 . ( C44 . $1 ) );
let C55 , C56 being Integer;
given C57 being (Function of ( TS ( SCM-AE ) ) , ( INT )) such that
L157: C55 = ( C57 . C45 )
and
L158: (for B51 being (Terminal of ( SCM-AE )) holds ( C57 . ( root-tree B51 ) ) = ( C44 . B51 ))
and
L159: (for B52 being (NonTerminal of ( SCM-AE )) holds (for B53 , B54 being bin-term holds (for B55 , B56 being (Symbol of ( SCM-AE )) holds ((B55 = ( root-label B53 ) & B56 = ( root-label B54 ) & B52 ==> <* B55 , B56 *>) implies (for B57 , B58 being (Element of ( INT )) holds ((B57 = ( C57 . B53 ) & B58 = ( C57 . B54 )) implies ( C57 . ( B52 -tree (B53 , B54) ) ) = ( B52 -Meaning_on (B57 , B58) )))))));

L160:
now
thus L161:now
let C58 being (Terminal of ( SCM-AE ));
L162: ( C44 . C58 ) in ( INT ) by INT_1:def 2;
L163: ( D31 . ( C44 . C58 ) ) = ( C44 . C58 ) by L162 , FUNCT_1:18;
thus L164: ( C57 . ( root-tree C58 ) ) = H3(C58) by L163 , L158;
end;
let C59 being (NonTerminal of ( SCM-AE ));
let C60 , C61 being bin-term;
let C62 , C63 being (Symbol of ( SCM-AE ));
assume that
L165: (C62 = ( root-label C60 ) & C63 = ( root-label C61 ) & C59 ==> <* C62 , C63 *>);
let C64 , C65 being (Element of ( INT ));
assume that
L166: (C64 = ( C57 . C60 ) & C65 = ( C57 . C61 ));
L167: ( C59 -Meaning_on (C64 , C65) ) in ( INT ) by INT_1:def 2;
L168: ( D31 . ( C59 -Meaning_on (C64 , C65) ) ) = ( C59 -Meaning_on (C64 , C65) ) by L167 , FUNCT_1:18;
thus L169: ( C57 . ( C59 -tree (C60 , C61) ) ) = H1(C59 , C62 , C63 , C64 , C65) by L168 , L159 , L165 , L166;
end;
given C66 being (Function of ( TS ( SCM-AE ) ) , ( INT )) such that
L170: C56 = ( C66 . C45 )
and
L171: (for B59 being (Terminal of ( SCM-AE )) holds ( C66 . ( root-tree B59 ) ) = ( C44 . B59 ))
and
L172: (for B60 being (NonTerminal of ( SCM-AE )) holds (for B61 , B62 being bin-term holds (for B63 , B64 being (Symbol of ( SCM-AE )) holds ((B63 = ( root-label B61 ) & B64 = ( root-label B62 ) & B60 ==> <* B63 , B64 *>) implies (for B65 , B66 being (Element of ( INT )) holds ((B65 = ( C66 . B61 ) & B66 = ( C66 . B62 )) implies ( C66 . ( B60 -tree (B61 , B62) ) ) = ( B60 -Meaning_on (B65 , B66) )))))));

L173:
now
thus L174:now
let C67 being (Terminal of ( SCM-AE ));
L175: ( C44 . C67 ) in ( INT ) by INT_1:def 2;
L176: ( D31 . ( C44 . C67 ) ) = ( C44 . C67 ) by L175 , FUNCT_1:18;
thus L177: ( C66 . ( root-tree C67 ) ) = H3(C67) by L176 , L171;
end;
let C68 being (NonTerminal of ( SCM-AE ));
let C69 , C70 being bin-term;
let C71 , C72 being (Symbol of ( SCM-AE ));
assume that
L178: (C71 = ( root-label C69 ) & C72 = ( root-label C70 ) & C68 ==> <* C71 , C72 *>);
let C73 , C74 being (Element of ( INT ));
assume that
L179: (C73 = ( C66 . C69 ) & C74 = ( C66 . C70 ));
L180: ( C68 -Meaning_on (C73 , C74) ) in ( INT ) by INT_1:def 2;
L181: ( D31 . ( C68 -Meaning_on (C73 , C74) ) ) = ( C68 -Meaning_on (C73 , C74) ) by L180 , FUNCT_1:18;
thus L182: ( C66 . ( C68 -tree (C69 , C70) ) ) = H1(C68 , C71 , C72 , C73 , C74) by L181 , L172 , L178 , L179;
end;
L183: C57 = C66 from BINTREE1:sch 4(L160 , L173);
thus L184: thesis by L183 , L157 , L170;
end;
end;
theorem
L186: (for B67 being (State of ( SCM )) holds (for B68 being (Terminal of ( SCM-AE )) holds ( ( root-tree B68 ) @ B67 ) = ( B67 . B68 )))
proof
let C75 being (State of ( SCM ));
let C76 being (Terminal of ( SCM-AE ));
L187: (ex B69 being (Function of ( TS ( SCM-AE ) ) , ( INT )) st (( ( root-tree C76 ) @ C75 ) = ( B69 . ( root-tree C76 ) ) & (for B70 being (Terminal of ( SCM-AE )) holds ( B69 . ( root-tree B70 ) ) = ( C75 . B70 )) & (for B71 being (NonTerminal of ( SCM-AE )) holds (for B72 , B73 being bin-term holds (for B74 , B75 being (Symbol of ( SCM-AE )) holds ((B74 = ( root-label B72 ) & B75 = ( root-label B73 ) & B71 ==> <* B74 , B75 *>) implies (for B76 , B77 being (Element of ( INT )) holds ((B76 = ( B69 . B72 ) & B77 = ( B69 . B73 )) implies ( B69 . ( B71 -tree (B72 , B73) ) ) = ( B71 -Meaning_on (B76 , B77) ))))))))) by L146;
thus L188: thesis by L187;
end;
theorem
L189: (for B78 being (State of ( SCM )) holds (for B79 being (NonTerminal of ( SCM-AE )) holds (for B80 , B81 being bin-term holds ( ( B79 -tree (B80 , B81) ) @ B78 ) = ( B79 -Meaning_on (( B80 @ B78 ) , ( B81 @ B78 )) ))))
proof
let C77 being (State of ( SCM ));
let C78 being (NonTerminal of ( SCM-AE ));
let C79 , C80 being bin-term;
consider C81 being (Function of ( TS ( SCM-AE ) ) , ( INT )) such that L190: ( ( C78 -tree (C79 , C80) ) @ C77 ) = ( C81 . ( C78 -tree (C79 , C80) ) ) and L191: (for B82 being (Terminal of ( SCM-AE )) holds ( C81 . ( root-tree B82 ) ) = ( C77 . B82 )) and L192: (for B83 being (NonTerminal of ( SCM-AE )) holds (for B84 , B85 being bin-term holds (for B86 , B87 being (Symbol of ( SCM-AE )) holds ((B86 = ( root-label B84 ) & B87 = ( root-label B85 ) & B83 ==> <* B86 , B87 *>) implies (for B88 , B89 being (Element of ( INT )) holds ((B88 = ( C81 . B84 ) & B89 = ( C81 . B85 )) implies ( C81 . ( B83 -tree (B84 , B85) ) ) = ( B83 -Meaning_on (B88 , B89) ))))))) by L146;
L193: C78 ==> <* ( root-label C79 ) , ( root-label C80 ) *> by L3 , L73;
L194: (( C79 @ C77 ) = ( C81 . C79 ) & ( C80 @ C77 ) = ( C81 . C80 )) by L191 , L192 , L146;
thus L195: thesis by L194 , L190 , L192 , L193;
end;
theorem
L196: (for B90 being (State of ( SCM )) holds (for B91 , B92 being bin-term holds (( ( B91 + B92 ) @ B90 ) = ( ( B91 @ B90 ) + ( B92 @ B90 ) ) & ( ( B91 - B92 ) @ B90 ) = ( ( B91 @ B90 ) - ( B92 @ B90 ) ) & ( ( B91 * B92 ) @ B90 ) = ( ( B91 @ B90 ) * ( B92 @ B90 ) ) & ( ( B91 div B92 ) @ B90 ) = ( ( B91 @ B90 ) div ( B92 @ B90 ) ) & ( ( B91 mod B92 ) @ B90 ) = ( ( B91 @ B90 ) mod ( B92 @ B90 ) ))))
proof
let C82 being (State of ( SCM ));
let C83 , C84 being bin-term;
thus L197: ( ( C83 + C84 ) @ C82 ) = ( D21 -Meaning_on (( C83 @ C82 ) , ( C84 @ C82 )) ) by L189
.= ( ( C83 @ C82 ) + ( C84 @ C82 ) ) by L135;
thus L198: ( ( C83 - C84 ) @ C82 ) = ( D22 -Meaning_on (( C83 @ C82 ) , ( C84 @ C82 )) ) by L189
.= ( ( C83 @ C82 ) - ( C84 @ C82 ) ) by L135;
thus L199: ( ( C83 * C84 ) @ C82 ) = ( D23 -Meaning_on (( C83 @ C82 ) , ( C84 @ C82 )) ) by L189
.= ( ( C83 @ C82 ) * ( C84 @ C82 ) ) by L135;
thus L200: ( ( C83 div C84 ) @ C82 ) = ( D24 -Meaning_on (( C83 @ C82 ) , ( C84 @ C82 )) ) by L189
.= ( ( C83 @ C82 ) div ( C84 @ C82 ) ) by L135;
thus L201: ( ( C83 mod C84 ) @ C82 ) = ( D25 -Meaning_on (( C83 @ C82 ) , ( C84 @ C82 )) ) by L189
.= ( ( C83 @ C82 ) mod ( C84 @ C82 ) ) by L135;
end;
definition
let C85 being (NonTerminal of ( SCM-AE ));
let C86 being (Element of ( NAT ));
func Selfwork (C85 , C86) -> (XFinSequence of (the InstructionsF of ( SCM ))) equals 
:L202: <% ( AddTo (( dl. C86 ) , ( dl. ( C86 + 1 ) )) ) %> if C85 = [ ( 0 ) , ( 0 ) ] , <% ( SubFrom (( dl. C86 ) , ( dl. ( C86 + 1 ) )) ) %> if C85 = [ ( 0 ) , 1 ] , <% ( MultBy (( dl. C86 ) , ( dl. ( C86 + 1 ) )) ) %> if C85 = [ ( 0 ) , 2 ] , <% ( Divide (( dl. C86 ) , ( dl. ( C86 + 1 ) )) ) %> if C85 = [ ( 0 ) , 3 ] , <% ( Divide (( dl. C86 ) , ( dl. ( C86 + 1 ) )) ) , ( ( dl. C86 ) := ( dl. ( C86 + 1 ) ) ) %> if C85 = [ ( 0 ) , 4 ];
coherence;
consistency
proof
L203: (( [ ( 0 ) , 2 ] `2 ) = 2 & ( [ ( 0 ) , 3 ] `2 ) = 3);
L204: (( [ ( 0 ) , ( 0 ) ] `2 ) = ( 0 ) & ( [ ( 0 ) , 1 ] `2 ) = 1);
thus L205: thesis by L204 , L203 , MCART_1:7;
end;
end;
definition
deffunc H4((NonTerminal of ( SCM-AE )) , (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) , (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) , (Element of ( NAT ))) = ( ( ( $2 . $4 ) ^ ( $3 . ( $4 + 1 ) ) ) ^ ( Down ( Selfwork ($1 , $4) ) ) );
deffunc H5((Terminal of ( SCM-AE )) , (Element of ( NAT ))) = ( Down <% ( ( dl. $2 ) := ( @ $1 ) ) %> );
func SCM-Compile -> (Function of ( TS ( SCM-AE ) ) , ( Funcs (( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) )) means 
:L207: ((for B93 being (Terminal of ( SCM-AE )) holds (ex B94 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B94 = ( it . ( root-tree B93 ) ) & (for B95 being (Element of ( NAT )) holds ( B94 . B95 ) = <% ( ( dl. B95 ) := ( @ B93 ) ) %>)))) & (for B96 being (NonTerminal of ( SCM-AE )) holds (for B97 , B98 being bin-term holds (for B99 , B100 being (Symbol of ( SCM-AE )) holds ((B99 = ( root-label B97 ) & B100 = ( root-label B98 ) & B96 ==> <* B99 , B100 *>) implies (ex B101 , B102 , B103 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B101 = ( it . ( B96 -tree (B97 , B98) ) ) & B102 = ( it . B97 ) & B103 = ( it . B98 ) & (for B104 being (Element of ( NAT )) holds ( B101 . B104 ) = ( ( ( B102 . B104 ) ^ ( B103 . ( B104 + 1 ) ) ) ^ ( Selfwork (B96 , B104) ) )))))))));
existence
proof
consider C87 being (Function of ( TS ( SCM-AE ) ) , ( Funcs (( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) )) such that L208: ((for B105 being (Terminal of ( SCM-AE )) holds (ex B106 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B106 = ( C87 . ( root-tree B105 ) ) & (for B107 being (Element of ( NAT )) holds ( B106 . B107 ) = H5(B105 , B107))))) & (for B108 being (NonTerminal of ( SCM-AE )) holds (for B109 , B110 being bin-term holds (for B111 , B112 being (Symbol of ( SCM-AE )) holds ((B111 = ( root-label B109 ) & B112 = ( root-label B110 ) & B108 ==> <* B111 , B112 *>) implies (ex B113 , B114 , B115 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B113 = ( C87 . ( B108 -tree (B109 , B110) ) ) & B114 = ( C87 . B109 ) & B115 = ( C87 . B110 ) & (for B116 being (Element of ( NAT )) holds ( B113 . B116 ) = H4(B108 , B114 , B115 , B116))))))))) from BINTREE1:sch 5;
take C87;
L209: ((for B117 being (Terminal of ( SCM-AE )) holds (ex B118 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B118 = ( C87 . ( root-tree B117 ) ) & (for B119 being (Element of ( NAT )) holds ( B118 . B119 ) = <% ( ( dl. B119 ) := ( @ B117 ) ) %>)))) & (for B120 being (NonTerminal of ( SCM-AE )) holds (for B121 , B122 being bin-term holds (for B123 , B124 being (Symbol of ( SCM-AE )) holds ((B123 = ( root-label B121 ) & B124 = ( root-label B122 ) & B120 ==> <* B123 , B124 *>) implies (ex B125 , B126 , B127 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B125 = ( C87 . ( B120 -tree (B121 , B122) ) ) & B126 = ( C87 . B121 ) & B127 = ( C87 . B122 ) & (for B128 being (Element of ( NAT )) holds ( B125 . B128 ) = ( ( ( B126 . B128 ) ^ ( B127 . ( B128 + 1 ) ) ) ^ ( Selfwork (B120 , B128) ) )))))))))
proof
thus L210: (for B129 being (Terminal of ( SCM-AE )) holds (ex B130 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B130 = ( C87 . ( root-tree B129 ) ) & (for B131 being (Element of ( NAT )) holds ( B130 . B131 ) = <% ( ( dl. B131 ) := ( @ B129 ) ) %>))))
proof
let C88 being (Terminal of ( SCM-AE ));
consider C89 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L211: C89 = ( C87 . ( root-tree C88 ) ) and L212: (for B132 being (Element of ( NAT )) holds ( C89 . B132 ) = H5(C88 , B132)) by L208;
take C89;
thus L213: C89 = ( C87 . ( root-tree C88 ) ) by L211;
let C90 being (Element of ( NAT ));
L214: ( C89 . C90 ) = H5(C88 , C90) by L212;
thus L215: thesis by L214;
end;

thus L216: (for B133 being (NonTerminal of ( SCM-AE )) holds (for B134 , B135 being bin-term holds (for B136 , B137 being (Symbol of ( SCM-AE )) holds ((B136 = ( root-label B134 ) & B137 = ( root-label B135 ) & B133 ==> <* B136 , B137 *>) implies (ex B138 , B139 , B140 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B138 = ( C87 . ( B133 -tree (B134 , B135) ) ) & B139 = ( C87 . B134 ) & B140 = ( C87 . B135 ) & (for B141 being (Element of ( NAT )) holds ( B138 . B141 ) = ( ( ( B139 . B141 ) ^ ( B140 . ( B141 + 1 ) ) ) ^ ( Selfwork (B133 , B141) ) ))))))))
proof
let C91 being (NonTerminal of ( SCM-AE ));
let C92 , C93 being bin-term;
let C94 , C95 being (Symbol of ( SCM-AE ));
assume that
L217: (C94 = ( root-label C92 ) & C95 = ( root-label C93 ) & C91 ==> <* C94 , C95 *>);
consider C96 , C97 , C98 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L218: (C96 = ( C87 . ( C91 -tree (C92 , C93) ) ) & C97 = ( C87 . C92 ) & C98 = ( C87 . C93 )) and L219: (for B142 being (Element of ( NAT )) holds ( C96 . B142 ) = H4(C91 , C97 , C98 , B142)) by L217 , L208;
take C96;
take C97;
take C98;
thus L220: (C96 = ( C87 . ( C91 -tree (C92 , C93) ) ) & C97 = ( C87 . C92 ) & C98 = ( C87 . C93 )) by L218;
let C99 being (Element of ( NAT ));
L221: ( C96 . C99 ) = H4(C91 , C97 , C98 , C99) by L219;
thus L222: thesis by L221;
end;

end;
thus L217: thesis by L209;
end;
uniqueness
proof
let C100 , C101 being (Function of ( TS ( SCM-AE ) ) , ( Funcs (( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) ));
assume that
L218: ((for B143 being (Terminal of ( SCM-AE )) holds (ex B144 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B144 = ( C100 . ( root-tree B143 ) ) & (for B145 being (Element of ( NAT )) holds ( B144 . B145 ) = <% ( ( dl. B145 ) := ( @ B143 ) ) %>)))) & (for B146 being (NonTerminal of ( SCM-AE )) holds (for B147 , B148 being bin-term holds (for B149 , B150 being (Symbol of ( SCM-AE )) holds ((B149 = ( root-label B147 ) & B150 = ( root-label B148 ) & B146 ==> <* B149 , B150 *>) implies (ex B151 , B152 , B153 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B151 = ( C100 . ( B146 -tree (B147 , B148) ) ) & B152 = ( C100 . B147 ) & B153 = ( C100 . B148 ) & (for B154 being (Element of ( NAT )) holds ( B151 . B154 ) = ( ( ( B152 . B154 ) ^ ( B153 . ( B154 + 1 ) ) ) ^ ( Selfwork (B146 , B154) ) )))))))))
and
L219: ((for B155 being (Terminal of ( SCM-AE )) holds (ex B156 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B156 = ( C101 . ( root-tree B155 ) ) & (for B157 being (Element of ( NAT )) holds ( B156 . B157 ) = <% ( ( dl. B157 ) := ( @ B155 ) ) %>)))) & (for B158 being (NonTerminal of ( SCM-AE )) holds (for B159 , B160 being bin-term holds (for B161 , B162 being (Symbol of ( SCM-AE )) holds ((B161 = ( root-label B159 ) & B162 = ( root-label B160 ) & B158 ==> <* B161 , B162 *>) implies (ex B163 , B164 , B165 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B163 = ( C101 . ( B158 -tree (B159 , B160) ) ) & B164 = ( C101 . B159 ) & B165 = ( C101 . B160 ) & (for B166 being (Element of ( NAT )) holds ( B163 . B166 ) = ( ( ( B164 . B166 ) ^ ( B165 . ( B166 + 1 ) ) ) ^ ( Selfwork (B158 , B166) ) )))))))));
L220: ((for B167 being (Terminal of ( SCM-AE )) holds (ex B168 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B168 = ( C100 . ( root-tree B167 ) ) & (for B169 being (Element of ( NAT )) holds ( B168 . B169 ) = H5(B167 , B169))))) & (for B170 being (NonTerminal of ( SCM-AE )) holds (for B171 , B172 being bin-term holds (for B173 , B174 being (Symbol of ( SCM-AE )) holds ((B173 = ( root-label B171 ) & B174 = ( root-label B172 ) & B170 ==> <* B173 , B174 *>) implies (ex B175 , B176 , B177 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B175 = ( C100 . ( B170 -tree (B171 , B172) ) ) & B176 = ( C100 . B171 ) & B177 = ( C100 . B172 ) & (for B178 being (Element of ( NAT )) holds ( B175 . B178 ) = H4(B170 , B176 , B177 , B178)))))))))
proof
thus L221: (for B179 being (Terminal of ( SCM-AE )) holds (ex B180 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B180 = ( C100 . ( root-tree B179 ) ) & (for B181 being (Element of ( NAT )) holds ( B180 . B181 ) = H5(B179 , B181)))))
proof
let C102 being (Terminal of ( SCM-AE ));
consider C103 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L222: (C103 = ( C100 . ( root-tree C102 ) ) & (for B182 being (Element of ( NAT )) holds ( C103 . B182 ) = <% ( ( dl. B182 ) := ( @ C102 ) ) %>)) by L218;
take C103;
thus L223: thesis by L222;
end;

thus L224: (for B183 being (NonTerminal of ( SCM-AE )) holds (for B184 , B185 being bin-term holds (for B186 , B187 being (Symbol of ( SCM-AE )) holds ((B186 = ( root-label B184 ) & B187 = ( root-label B185 ) & B183 ==> <* B186 , B187 *>) implies (ex B188 , B189 , B190 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B188 = ( C100 . ( B183 -tree (B184 , B185) ) ) & B189 = ( C100 . B184 ) & B190 = ( C100 . B185 ) & (for B191 being (Element of ( NAT )) holds ( B188 . B191 ) = H4(B183 , B189 , B190 , B191))))))))
proof
let C104 being (NonTerminal of ( SCM-AE ));
let C105 , C106 being bin-term;
let C107 , C108 being (Symbol of ( SCM-AE ));
assume that
L225: (C107 = ( root-label C105 ) & C108 = ( root-label C106 ) & C104 ==> <* C107 , C108 *>);
consider C109 , C110 , C111 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L226: (C109 = ( C100 . ( C104 -tree (C105 , C106) ) ) & C110 = ( C100 . C105 ) & C111 = ( C100 . C106 ) & (for B192 being (Element of ( NAT )) holds ( C109 . B192 ) = ( ( ( C110 . B192 ) ^ ( C111 . ( B192 + 1 ) ) ) ^ ( Selfwork (C104 , B192) ) ))) by L218 , L225;
take C109;
take C110;
take C111;
thus L227: thesis by L226;
end;

end;
L225: ((for B193 being (Terminal of ( SCM-AE )) holds (ex B194 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B194 = ( C101 . ( root-tree B193 ) ) & (for B195 being (Element of ( NAT )) holds ( B194 . B195 ) = H5(B193 , B195))))) & (for B196 being (NonTerminal of ( SCM-AE )) holds (for B197 , B198 being bin-term holds (for B199 , B200 being (Symbol of ( SCM-AE )) holds ((B199 = ( root-label B197 ) & B200 = ( root-label B198 ) & B196 ==> <* B199 , B200 *>) implies (ex B201 , B202 , B203 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B201 = ( C101 . ( B196 -tree (B197 , B198) ) ) & B202 = ( C101 . B197 ) & B203 = ( C101 . B198 ) & (for B204 being (Element of ( NAT )) holds ( B201 . B204 ) = H4(B196 , B202 , B203 , B204)))))))))
proof
thus L226: (for B205 being (Terminal of ( SCM-AE )) holds (ex B206 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B206 = ( C101 . ( root-tree B205 ) ) & (for B207 being (Element of ( NAT )) holds ( B206 . B207 ) = H5(B205 , B207)))))
proof
let C112 being (Terminal of ( SCM-AE ));
consider C113 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L227: (C113 = ( C101 . ( root-tree C112 ) ) & (for B208 being (Element of ( NAT )) holds ( C113 . B208 ) = <% ( ( dl. B208 ) := ( @ C112 ) ) %>)) by L219;
take C113;
thus L228: thesis by L227;
end;

thus L229: (for B209 being (NonTerminal of ( SCM-AE )) holds (for B210 , B211 being bin-term holds (for B212 , B213 being (Symbol of ( SCM-AE )) holds ((B212 = ( root-label B210 ) & B213 = ( root-label B211 ) & B209 ==> <* B212 , B213 *>) implies (ex B214 , B215 , B216 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) st (B214 = ( C101 . ( B209 -tree (B210 , B211) ) ) & B215 = ( C101 . B210 ) & B216 = ( C101 . B211 ) & (for B217 being (Element of ( NAT )) holds ( B214 . B217 ) = H4(B209 , B215 , B216 , B217))))))))
proof
let C114 being (NonTerminal of ( SCM-AE ));
let C115 , C116 being bin-term;
let C117 , C118 being (Symbol of ( SCM-AE ));
assume that
L230: (C117 = ( root-label C115 ) & C118 = ( root-label C116 ) & C114 ==> <* C117 , C118 *>);
consider C119 , C120 , C121 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L231: (C119 = ( C101 . ( C114 -tree (C115 , C116) ) ) & C120 = ( C101 . C115 ) & C121 = ( C101 . C116 ) & (for B218 being (Element of ( NAT )) holds ( C119 . B218 ) = ( ( ( C120 . B218 ) ^ ( C121 . ( B218 + 1 ) ) ) ^ ( Selfwork (C114 , B218) ) ))) by L219 , L230;
take C119;
take C120;
take C121;
thus L232: thesis by L231;
end;

end;
thus L230: C100 = C101 from BINTREE1:sch 6(L220 , L225);
end;
end;
definition
let C122 being bin-term;
let C123 being (Element of ( NAT ));
func SCM-Compile (C122 , C123) -> (XFinSequence of (the InstructionsF of ( SCM ))) equals 
( ( ( SCM-Compile ) . C122 ) . C123 );
coherence
proof
reconsider D33 = ( ( SCM-Compile ) . C122 ) as (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) by FUNCT_2:66;
L232: ( D33 . C123 ) in ( (the InstructionsF of ( SCM )) ^omega );
thus L233: thesis by L232 , AFINSQ_1:def 7;
end;
end;
theorem
L235: (for B219 being (Terminal of ( SCM-AE )) holds (for B220 being (Element of ( NAT )) holds ( SCM-Compile (( root-tree B219 ) , B220) ) = <% ( ( dl. B220 ) := ( @ B219 ) ) %>))
proof
let C124 being (Terminal of ( SCM-AE ));
let C125 being (Element of ( NAT ));
consider C126 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L236: C126 = ( ( SCM-Compile ) . ( root-tree C124 ) ) and L237: (for B221 being (Element of ( NAT )) holds ( C126 . B221 ) = <% ( ( dl. B221 ) := ( @ C124 ) ) %>) by L207;
thus L238: thesis by L236 , L237;
end;
theorem
L239: (for B222 being (NonTerminal of ( SCM-AE )) holds (for B223 , B224 being bin-term holds (for B225 being (Element of ( NAT )) holds (for B226 , B227 being (Symbol of ( SCM-AE )) holds ((B226 = ( root-label B223 ) & B227 = ( root-label B224 ) & B222 ==> <* B226 , B227 *>) implies ( SCM-Compile (( B222 -tree (B223 , B224) ) , B225) ) = ( ( ( SCM-Compile (B223 , B225) ) ^ ( SCM-Compile (B224 , ( B225 + 1 )) ) ) ^ ( Selfwork (B222 , B225) ) ))))))
proof
let C127 being (NonTerminal of ( SCM-AE ));
let C128 , C129 being bin-term;
let C130 being (Element of ( NAT ));
let C131 , C132 being (Symbol of ( SCM-AE ));
assume L240: (C131 = ( root-label C128 ) & C132 = ( root-label C129 ) & C127 ==> <* C131 , C132 *>);
consider C133 , C134 , C135 being (Function of ( NAT ) , ( (the InstructionsF of ( SCM )) ^omega )) such that L241: C133 = ( ( SCM-Compile ) . ( C127 -tree (C128 , C129) ) ) and L242: C134 = ( ( SCM-Compile ) . C128 ) and L243: C135 = ( ( SCM-Compile ) . C129 ) and L244: (for B228 being (Element of ( NAT )) holds ( C133 . B228 ) = ( ( ( C134 . B228 ) ^ ( C135 . ( B228 + 1 ) ) ) ^ ( Selfwork (C127 , B228) ) )) by L240 , L207;
thus L245: ( SCM-Compile (( C127 -tree (C128 , C129) ) , C130) ) = ( ( ( SCM-Compile (C128 , C130) ) ^ ( SCM-Compile (C129 , ( C130 + 1 )) ) ) ^ ( Selfwork (C127 , C130) ) ) by L242 , L243 , L244 , L241;
end;
definition
let C136 being (Terminal of ( SCM-AE ));
func d". C136 -> (Element of ( NAT )) means 
:L246: ( dl. it ) = C136;
existence
proof
L247: ( Terminals ( SCM-AE ) ) = [: { 1 } , ( NAT ) :] by L3;
consider C137 , C138 being set such that L248: C137 in { 1 } and L249: C138 in ( NAT ) and L250: C136 = [ C137 , C138 ] by L247 , ZFMISC_1:84;
reconsider D34 = C138 as (Element of ( NAT )) by L249;
take D34;
thus L251: thesis by L248 , L250 , TARSKI:def 1;
end;
uniqueness by AMI_3:10;
end;
definition
deffunc H6((Terminal of ( SCM-AE ))) = ( d". $1 );
deffunc H7((NonTerminal of ( SCM-AE )) , set , set , (Element of ( NAT )) , (Element of ( NAT ))) = ( max ($4 , $5) );
let C139 being bin-term;
func max_Data-Loc_in C139 -> (Element of ( NAT )) means 
:L253: (ex B229 being (Function of ( TS ( SCM-AE ) ) , ( NAT )) st (it = ( B229 . C139 ) & (for B230 being (Terminal of ( SCM-AE )) holds ( B229 . ( root-tree B230 ) ) = ( d". B230 )) & (for B231 being (NonTerminal of ( SCM-AE )) holds (for B232 , B233 being bin-term holds (for B234 , B235 being (Symbol of ( SCM-AE )) holds ((B234 = ( root-label B232 ) & B235 = ( root-label B233 ) & B231 ==> <* B234 , B235 *>) implies (for B236 , B237 being (Element of ( NAT )) holds ((B236 = ( B229 . B232 ) & B237 = ( B229 . B233 )) implies ( B229 . ( B231 -tree (B232 , B233) ) ) = ( max (B236 , B237) )))))))));
existence
proof
consider C140 being (Function of ( TS ( SCM-AE ) ) , ( NAT )) such that L254: ((for B238 being (Terminal of ( SCM-AE )) holds ( C140 . ( root-tree B238 ) ) = H6(B238)) & (for B239 being (NonTerminal of ( SCM-AE )) holds (for B240 , B241 being bin-term holds (for B242 , B243 being (Symbol of ( SCM-AE )) holds ((B242 = ( root-label B240 ) & B243 = ( root-label B241 ) & B239 ==> <* B242 , B243 *>) implies (for B244 , B245 being (Element of ( NAT )) holds ((B244 = ( C140 . B240 ) & B245 = ( C140 . B241 )) implies ( C140 . ( B239 -tree (B240 , B241) ) ) = H7(B239 , B242 , B243 , B244 , B245)))))))) from BINTREE1:sch 3;
reconsider D35 = ( C140 . C139 ) as (Element of ( NAT ));
take D35;
take C140;
thus L255: thesis by L254;
end;
uniqueness
proof
let C141 , C142 being (Element of ( NAT ));
given C143 being (Function of ( TS ( SCM-AE ) ) , ( NAT )) such that
L256: C141 = ( C143 . C139 )
and
L257: ((for B246 being (Terminal of ( SCM-AE )) holds ( C143 . ( root-tree B246 ) ) = H6(B246)) & (for B247 being (NonTerminal of ( SCM-AE )) holds (for B248 , B249 being bin-term holds (for B250 , B251 being (Symbol of ( SCM-AE )) holds ((B250 = ( root-label B248 ) & B251 = ( root-label B249 ) & B247 ==> <* B250 , B251 *>) implies (for B252 , B253 being (Element of ( NAT )) holds ((B252 = ( C143 . B248 ) & B253 = ( C143 . B249 )) implies ( C143 . ( B247 -tree (B248 , B249) ) ) = H7(B247 , B250 , B251 , B252 , B253))))))));

given C144 being (Function of ( TS ( SCM-AE ) ) , ( NAT )) such that
L258: C142 = ( C144 . C139 )
and
L259: ((for B254 being (Terminal of ( SCM-AE )) holds ( C144 . ( root-tree B254 ) ) = H6(B254)) & (for B255 being (NonTerminal of ( SCM-AE )) holds (for B256 , B257 being bin-term holds (for B258 , B259 being (Symbol of ( SCM-AE )) holds ((B258 = ( root-label B256 ) & B259 = ( root-label B257 ) & B255 ==> <* B258 , B259 *>) implies (for B260 , B261 being (Element of ( NAT )) holds ((B260 = ( C144 . B256 ) & B261 = ( C144 . B257 )) implies ( C144 . ( B255 -tree (B256 , B257) ) ) = H7(B255 , B258 , B259 , B260 , B261))))))));

L260: C143 = C144 from BINTREE1:sch 4(L257 , L259);
thus L261: thesis by L260 , L256 , L258;
end;
end;
set D36 = the bin-term;
consider C145 being (Function of ( TS ( SCM-AE ) ) , ( NAT )) such that L263: ( max_Data-Loc_in D36 ) = ( C145 . D36 ) and L264: (for B262 being (Terminal of ( SCM-AE )) holds ( C145 . ( root-tree B262 ) ) = ( d". B262 )) and L265: (for B263 being (NonTerminal of ( SCM-AE )) holds (for B264 , B265 being bin-term holds (for B266 , B267 being (Symbol of ( SCM-AE )) holds ((B266 = ( root-label B264 ) & B267 = ( root-label B265 ) & B263 ==> <* B266 , B267 *>) implies (for B268 , B269 being (Element of ( NAT )) holds ((B268 = ( C145 . B264 ) & B269 = ( C145 . B265 )) implies ( C145 . ( B263 -tree (B264 , B265) ) ) = ( max (B268 , B269) ))))))) by L253;
theorem
L266: (for B270 being (Terminal of ( SCM-AE )) holds ( max_Data-Loc_in ( root-tree B270 ) ) = ( d". B270 ))
proof
let C146 being (Terminal of ( SCM-AE ));
L267: ( max_Data-Loc_in ( root-tree C146 ) ) = (( C145 . ( root-tree C146 ) ) qua (Element of ( NAT ))) by L253 , L264 , L265;
thus L268: thesis by L267 , L264;
end;
L269: ( NonTerminals ( SCM-AE ) ) = [: 1 , 5 :] by L3;
theorem
L270: (for B271 being (NonTerminal of ( SCM-AE )) holds (for B272 , B273 being bin-term holds ( max_Data-Loc_in ( B271 -tree (B272 , B273) ) ) = ( max (( max_Data-Loc_in B272 ) , ( max_Data-Loc_in B273 )) )))
proof
let C147 being (NonTerminal of ( SCM-AE ));
let C148 , C149 being bin-term;
L271: (( max_Data-Loc_in C148 ) = ( C145 . C148 ) & ( max_Data-Loc_in C149 ) = ( C145 . C149 )) by L253 , L264 , L265;
L272: (C147 ==> <* ( root-label C148 ) , ( root-label C149 ) *> & ( max_Data-Loc_in ( C147 -tree (C148 , C149) ) ) = ( C145 . ( C147 -tree (C148 , C149) ) )) by L3 , L253 , L264 , L265 , L269;
thus L273: thesis by L272 , L271 , L265;
end;
defpred S2[ bin-term ] means (for B274 , B275 being (State of ( SCM )) holds ((for B276 being (Element of ( NAT )) holds (B276 <= ( max_Data-Loc_in $1 ) implies ( B274 . ( dl. B276 ) ) = ( B275 . ( dl. B276 ) ))) implies ( $1 @ B274 ) = ( $1 @ B275 )));
L274:
now
let C150 being (Terminal of ( SCM-AE ));
thus L275: S2[ ( root-tree C150 ) ]
proof
let C151 , C152 being (State of ( SCM ));
assume L276: (for B277 being (Element of ( NAT )) holds (B277 <= ( max_Data-Loc_in ( root-tree C150 ) ) implies ( C151 . ( dl. B277 ) ) = ( C152 . ( dl. B277 ) )));
L277: ( d". C150 ) <= ( max_Data-Loc_in ( root-tree C150 ) ) by L266;
L278: ( C151 . ( dl. ( d". C150 ) ) ) = ( C152 . ( dl. ( d". C150 ) ) ) by L277 , L276;
L279: ( ( root-tree C150 ) @ C151 ) = ( C151 . C150 ) by L186;
L280: (( C151 . C150 ) = ( C151 . ( dl. ( d". C150 ) ) ) & ( C152 . C150 ) = ( C152 . ( dl. ( d". C150 ) ) )) by L246;
thus L281: thesis by L280 , L278 , L279 , L186;
end;

end;
L276:
now
let C153 being (NonTerminal of ( SCM-AE ));
let C154 , C155 being (Element of ( TS ( SCM-AE ) ));
assume that
L277: C153 ==> <* ( root-label C154 ) , ( root-label C155 ) *>
and
L278: S2[ C154 ]
and
L279: S2[ C155 ];
thus L280: S2[ ( C153 -tree (C154 , C155) ) ]
proof
let C156 , C157 being (State of ( SCM ));
assume L281: (for B278 being (Element of ( NAT )) holds (B278 <= ( max_Data-Loc_in ( C153 -tree (C154 , C155) ) ) implies ( C156 . ( dl. B278 ) ) = ( C157 . ( dl. B278 ) )));
L282:
now
set D37 = ( max_Data-Loc_in C154 );
set D38 = ( max_Data-Loc_in C155 );
let C158 being (Element of ( NAT ));
L283: D37 <= ( max (D37 , D38) ) by XXREAL_0:25;
assume L284: C158 <= ( max_Data-Loc_in C154 );
L285: C158 <= ( max (D37 , D38) ) by L284 , L283 , XXREAL_0:2;
L286: C158 <= ( max_Data-Loc_in ( C153 -tree (C154 , C155) ) ) by L285 , L270;
thus L287: ( C156 . ( dl. C158 ) ) = ( C157 . ( dl. C158 ) ) by L286 , L281;
end;
L288: ( C154 @ C156 ) = ( C154 @ C157 ) by L282 , L278;
L289:
now
set D39 = ( max_Data-Loc_in C154 );
set D40 = ( max_Data-Loc_in C155 );
let C159 being (Element of ( NAT ));
L290: D40 <= ( max (D39 , D40) ) by XXREAL_0:25;
assume L291: C159 <= ( max_Data-Loc_in C155 );
L292: C159 <= ( max (D39 , D40) ) by L291 , L290 , XXREAL_0:2;
L293: C159 <= ( max_Data-Loc_in ( C153 -tree (C154 , C155) ) ) by L292 , L270;
thus L294: ( C156 . ( dl. C159 ) ) = ( C157 . ( dl. C159 ) ) by L293 , L281;
end;
L295: ( C155 @ C156 ) = ( C155 @ C157 ) by L289 , L279;
L296: ( ( C153 -tree (C154 , C155) ) @ C156 ) = ( C153 -Meaning_on (( C154 @ C156 ) , ( C155 @ C156 )) ) by L189;
thus L297: thesis by L296 , L288 , L295 , L189;
end;

end;
theorem
L281: (for B279 being bin-term holds (for B280 , B281 being (State of ( SCM )) holds ((for B282 being (Element of ( NAT )) holds (B282 <= ( max_Data-Loc_in B279 ) implies ( B280 . ( dl. B282 ) ) = ( B281 . ( dl. B282 ) ))) implies ( B279 @ B280 ) = ( B279 @ B281 ))))
proof
thus L282: (for B283 being bin-term holds S2[ B283 ]) from BINTREE1:sch 2(L274 , L276);
end;
defpred S3[ bin-term ] means (for R1 being (Instruction-Sequence of ( SCM )) holds (for B284 , B285 being (Element of ( NAT )) holds (( Shift (( SCM-Compile ($1 , B284) ) , B285) ) c= R1 implies (for B286 being B285 -started (State of ( SCM )) holds (B284 > ( max_Data-Loc_in $1 ) implies (ex B287 being (Element of ( NAT )) st (ex B288 being (State of ( SCM )) st (B288 = ( Comput (R1 , B286 , ( B287 + 1 )) ) & ( B287 + 1 ) = ( len ( SCM-Compile ($1 , B284) ) ) & ( IC ( Comput (R1 , B286 , B287) ) ) = ( B285 + B287 ) & ( IC B288 ) = ( B285 + ( B287 + 1 ) ) & ( B288 . ( dl. B284 ) ) = ( $1 @ B286 ) & (for B289 being (Element of ( NAT )) holds (B289 < B284 implies ( B286 . ( dl. B289 ) ) = ( B288 . ( dl. B289 ) )))))))))));
theorem
L283: (for R1 being (Instruction-Sequence of ( SCM )) holds (for B290 being bin-term holds (for B291 , B292 being (Element of ( NAT )) holds (( Shift (( SCM-Compile (B290 , B291) ) , B292) ) c= R1 implies (for B293 being B292 -started (State of ( SCM )) holds (B291 > ( max_Data-Loc_in B290 ) implies (ex B294 being (Element of ( NAT )) st (ex B295 being (State of ( SCM )) st (B295 = ( Comput (R1 , B293 , ( B294 + 1 )) ) & ( B294 + 1 ) = ( len ( SCM-Compile (B290 , B291) ) ) & ( IC ( Comput (R1 , B293 , B294) ) ) = ( B292 + B294 ) & ( IC B295 ) = ( B292 + ( B294 + 1 ) ) & ( B295 . ( dl. B291 ) ) = ( B290 @ B293 ) & (for B296 being (Element of ( NAT )) holds (B296 < B291 implies ( B293 . ( dl. B296 ) ) = ( B295 . ( dl. B296 ) ))))))))))))
proof
L284: (for B297 being (NonTerminal of ( SCM-AE )) holds (for B298 , B299 being bin-term holds ((B297 ==> <* ( root-label B298 ) , ( root-label B299 ) *> & S3[ B298 ] & S3[ B299 ]) implies S3[ ( B297 -tree (B298 , B299) ) ])))
proof
let C160 being (NonTerminal of ( SCM-AE ));
let C161 , C162 being bin-term;
assume that
L285: C160 ==> <* ( root-label C161 ) , ( root-label C162 ) *>
and
L286: S3[ C161 ]
and
L287: S3[ C162 ];
let R1 being (Instruction-Sequence of ( SCM ));
let C163 , C164 being (Element of ( NAT ));
assume that
L288: ( Shift (( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) , C164) ) c= R1;
let C165 being C164 -started (State of ( SCM ));
assume L289: C163 > ( max_Data-Loc_in ( C160 -tree (C161 , C162) ) );
L290: ( max_Data-Loc_in ( C160 -tree (C161 , C162) ) ) = ( max (( max_Data-Loc_in C161 ) , ( max_Data-Loc_in C162 )) ) by L270;
L291: ( max_Data-Loc_in C161 ) <= ( max_Data-Loc_in ( C160 -tree (C161 , C162) ) ) by L290 , XXREAL_0:25;
L292: ( max_Data-Loc_in C161 ) < C163 by L291 , L289 , XXREAL_0:2;
L293: ( max_Data-Loc_in C162 ) <= ( max_Data-Loc_in ( C160 -tree (C161 , C162) ) ) by L290 , XXREAL_0:25;
L294: ( max_Data-Loc_in C162 ) < C163 by L293 , L289 , XXREAL_0:2;
L295: ( max_Data-Loc_in C162 ) < ( C163 + 1 ) by L294 , NAT_1:13;
L296: ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) = ( ( ( SCM-Compile (C161 , C163) ) ^ ( SCM-Compile (C162 , ( C163 + 1 )) ) ) ^ ( Selfwork (C160 , C163) ) ) by L285 , L239;
L297: ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) = ( ( SCM-Compile (C161 , C163) ) ^ ( ( SCM-Compile (C162 , ( C163 + 1 )) ) ^ ( Selfwork (C160 , C163) ) ) ) by L296 , AFINSQ_1:27;
L298: ( Shift (( SCM-Compile (C161 , C163) ) , C164) ) c= R1 by L297 , L288 , AFINSQ_1:82;
consider C166 being (Element of ( NAT )), C167 being (State of ( SCM )) such that L299: C167 = ( Comput (R1 , C165 , ( C166 + 1 )) ) and L300: ( C166 + 1 ) = ( len ( SCM-Compile (C161 , C163) ) ) and L301: ( IC ( Comput (R1 , C165 , C166) ) ) = ( C164 + C166 ) and L302: ( IC C167 ) = ( C164 + ( C166 + 1 ) ) and L303: ( C167 . ( dl. C163 ) ) = ( C161 @ C165 ) and L304: (for B300 being (Element of ( NAT )) holds (B300 < C163 implies ( C165 . ( dl. B300 ) ) = ( C167 . ( dl. B300 ) ))) by L298 , L286 , L292;
L305: C167 is ( C164 + ( C166 + 1 ) ) -started ( C164 + ( C166 + 1 ) ) -started ( C164 + ( C166 + 1 ) ) -started ( C164 + ( C166 + 1 ) ) -started (State of ( SCM )) by L302 , MEMSTR_0:def 12;
L306: ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) = ( ( SCM-Compile (C161 , C163) ) ^ ( ( SCM-Compile (C162 , ( C163 + 1 )) ) ^ ( Selfwork (C160 , C163) ) ) ) by L296 , AFINSQ_1:27;
L307: ( Shift (( ( SCM-Compile (C162 , ( C163 + 1 )) ) ^ ( Selfwork (C160 , C163) ) ) , ( C164 + ( C166 + 1 ) )) ) c= R1 by L306 , L288 , L300 , AFINSQ_1:83;
L308: ( Shift (( SCM-Compile (C162 , ( C163 + 1 )) ) , ( C164 + ( C166 + 1 ) )) ) c= R1 by L307 , AFINSQ_1:82;
consider C168 being (Element of ( NAT )), C169 being (State of ( SCM )) such that L309: C169 = ( Comput (R1 , C167 , ( C168 + 1 )) ) and L310: ( C168 + 1 ) = ( len ( SCM-Compile (C162 , ( C163 + 1 )) ) ) and L311: ( IC ( Comput (R1 , C167 , C168) ) ) = ( ( C164 + ( C166 + 1 ) ) + C168 ) and L312: ( IC C169 ) = ( ( C164 + ( C166 + 1 ) ) + ( C168 + 1 ) ) and L313: ( C169 . ( dl. ( C163 + 1 ) ) ) = ( C162 @ C167 ) and L314: (for B301 being (Element of ( NAT )) holds (B301 < ( C163 + 1 ) implies ( C167 . ( dl. B301 ) ) = ( C169 . ( dl. B301 ) ))) by L308 , L287 , L295 , L305;
L315: C169 = ( Comput (R1 , C165 , ( ( C166 + 1 ) + ( C168 + 1 ) )) ) by L299 , L309 , EXTPRO_1:4;
L316:
now
let C170 being (Element of ( NAT ));
assume L317: C170 <= ( max_Data-Loc_in C162 );
L318: C170 < C163 by L317 , L294 , XXREAL_0:2;
thus L319: ( C165 . ( dl. C170 ) ) = ( C167 . ( dl. C170 ) ) by L318 , L304;
end;
L320: C163 < ( C163 + 1 ) by NAT_1:13;
L321: ( ( C160 -tree (C161 , C162) ) @ C165 ) = ( C160 -Meaning_on (( C161 @ C165 ) , ( C162 @ C165 )) ) by L189;
L322: ( len ( ( SCM-Compile (C161 , C163) ) ^ ( SCM-Compile (C162 , ( C163 + 1 )) ) ) ) = ( ( C166 + 1 ) + ( C168 + 1 ) ) by L300 , L310 , AFINSQ_1:17;
per cases  by L84;
suppose L323: C160 = [ ( 0 ) , ( 0 ) ];

L324: ( C160 -Meaning_on (( C161 @ C165 ) , ( C162 @ C165 )) ) = ( ( C161 @ C165 ) + ( C162 @ C165 ) ) by L323 , L135;
take D41 = ( ( C166 + 1 ) + ( C168 + 1 ) );
take D42 = ( Comput (R1 , C165 , ( D41 + 1 )) );
thus L325: D42 = ( Comput (R1 , C165 , ( D41 + 1 )) );
L326: ( Selfwork (C160 , C163) ) = <% ( AddTo (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) %> by L323 , L202;
L327: ( len ( Selfwork (C160 , C163) ) ) = 1 by L326 , AFINSQ_1:34;
thus L328: ( D41 + 1 ) = ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L327 , L296 , L322 , AFINSQ_1:17;
thus L329: ( IC ( Comput (R1 , C165 , D41) ) ) = ( C164 + D41 ) by L299 , L309 , L312 , EXTPRO_1:4;
L330: ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) = ( ( ( C166 + 1 ) + ( C168 + 1 ) ) + 1 ) by L296 , L322 , L327 , AFINSQ_1:17;
L331: D41 < ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L330 , NAT_1:13;
L332: D41 in ( dom ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L331 , NAT_1:44;
L333: ( R1 . ( C164 + D41 ) ) = ( ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) . D41 ) by L332 , L288 , FINSEQ_2:146
.= ( AddTo (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) by L322 , L296 , L326 , AFINSQ_1:36;
thus L334: ( IC D42 ) = ( ( C164 + D41 ) + 1 ) by L333 , L312 , L315 , SCM_1:5
.= ( C164 + ( D41 + 1 ) );
thus L335: ( D42 . ( dl. C163 ) ) = ( ( C169 . ( dl. C163 ) ) + ( C169 . ( dl. ( C163 + 1 ) ) ) ) by L312 , L315 , L333 , SCM_1:5
.= ( ( C167 . ( dl. C163 ) ) + ( C162 @ C167 ) ) by L313 , L314 , L320
.= ( ( C160 -tree (C161 , C162) ) @ C165 ) by L303 , L321 , L316 , L324 , L281;
let C171 being (Element of ( NAT ));
assume L336: C171 < C163;
L337: C171 < ( C163 + 1 ) by L336 , NAT_1:13;
L338: ( C167 . ( dl. C171 ) ) = ( C169 . ( dl. C171 ) ) by L337 , L314;
L339: ( dl. C171 ) <> ( dl. C163 ) by L336 , AMI_3:10;
L340: ( D42 . ( dl. C171 ) ) = ( C169 . ( dl. C171 ) ) by L339 , L312 , L315 , L333 , SCM_1:5;
thus L341: thesis by L340 , L304 , L336 , L338;
end;
suppose L342: C160 = [ ( 0 ) , 1 ];

L343: ( C160 -Meaning_on (( C161 @ C165 ) , ( C162 @ C165 )) ) = ( ( C161 @ C165 ) - ( C162 @ C165 ) ) by L342 , L135;
take D43 = ( ( C166 + 1 ) + ( C168 + 1 ) );
take D44 = ( Comput (R1 , C165 , ( D43 + 1 )) );
thus L344: D44 = ( Comput (R1 , C165 , ( D43 + 1 )) );
L345: ( Selfwork (C160 , C163) ) = <% ( SubFrom (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) %> by L342 , L202;
L346: ( len ( Selfwork (C160 , C163) ) ) = 1 by L345 , AFINSQ_1:34;
thus L347: ( D43 + 1 ) = ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L346 , L296 , L322 , AFINSQ_1:17;
thus L348: ( IC ( Comput (R1 , C165 , D43) ) ) = ( C164 + D43 ) by L299 , L309 , L312 , EXTPRO_1:4;
L349: ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) = ( ( ( C166 + 1 ) + ( C168 + 1 ) ) + 1 ) by L296 , L322 , L346 , AFINSQ_1:17;
L350: D43 < ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L349 , NAT_1:13;
L351: D43 in ( dom ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L350 , NAT_1:44;
L352: ( R1 . ( C164 + D43 ) ) = ( ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) . D43 ) by L351 , L288 , FINSEQ_2:146
.= ( SubFrom (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) by L296 , L322 , L345 , AFINSQ_1:36;
thus L353: ( IC D44 ) = ( ( C164 + D43 ) + 1 ) by L352 , L312 , L315 , SCM_1:6
.= ( C164 + ( D43 + 1 ) );
thus L354: ( D44 . ( dl. C163 ) ) = ( ( C169 . ( dl. C163 ) ) - ( C169 . ( dl. ( C163 + 1 ) ) ) ) by L312 , L315 , L352 , SCM_1:6
.= ( ( C167 . ( dl. C163 ) ) - ( C162 @ C167 ) ) by L313 , L314 , L320
.= ( ( C160 -tree (C161 , C162) ) @ C165 ) by L303 , L321 , L316 , L343 , L281;
let C172 being (Element of ( NAT ));
assume L355: C172 < C163;
L356: C172 < ( C163 + 1 ) by L355 , NAT_1:13;
L357: ( C167 . ( dl. C172 ) ) = ( C169 . ( dl. C172 ) ) by L356 , L314;
L358: ( dl. C172 ) <> ( dl. C163 ) by L355 , AMI_3:10;
L359: ( D44 . ( dl. C172 ) ) = ( C169 . ( dl. C172 ) ) by L358 , L312 , L315 , L352 , SCM_1:6;
thus L360: thesis by L359 , L304 , L355 , L357;
end;
suppose L361: C160 = [ ( 0 ) , 2 ];

L362: ( C160 -Meaning_on (( C161 @ C165 ) , ( C162 @ C165 )) ) = ( ( C161 @ C165 ) * ( C162 @ C165 ) ) by L361 , L135;
take D45 = ( ( C166 + 1 ) + ( C168 + 1 ) );
take D46 = ( Comput (R1 , C165 , ( D45 + 1 )) );
thus L363: D46 = ( Comput (R1 , C165 , ( D45 + 1 )) );
L364: ( Selfwork (C160 , C163) ) = <% ( MultBy (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) %> by L361 , L202;
L365: ( len ( Selfwork (C160 , C163) ) ) = 1 by L364 , AFINSQ_1:34;
thus L366: ( D45 + 1 ) = ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L365 , L296 , L322 , AFINSQ_1:17;
thus L367: ( IC ( Comput (R1 , C165 , D45) ) ) = ( C164 + D45 ) by L299 , L309 , L312 , EXTPRO_1:4;
L368: ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) = ( ( ( C166 + 1 ) + ( C168 + 1 ) ) + 1 ) by L296 , L322 , L365 , AFINSQ_1:17;
L369: D45 < ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L368 , NAT_1:13;
L370: D45 in ( dom ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L369 , NAT_1:44;
L371: ( R1 . ( C164 + D45 ) ) = ( ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) . D45 ) by L370 , L288 , FINSEQ_2:146
.= ( MultBy (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) by L296 , L322 , L364 , AFINSQ_1:36;
thus L372: ( IC D46 ) = ( ( C164 + D45 ) + 1 ) by L371 , L312 , L315 , SCM_1:7
.= ( C164 + ( D45 + 1 ) );
thus L373: ( D46 . ( dl. C163 ) ) = ( ( C169 . ( dl. C163 ) ) * ( C169 . ( dl. ( C163 + 1 ) ) ) ) by L312 , L315 , L371 , SCM_1:7
.= ( ( C167 . ( dl. C163 ) ) * ( C162 @ C167 ) ) by L313 , L314 , L320
.= ( ( C160 -tree (C161 , C162) ) @ C165 ) by L303 , L321 , L316 , L362 , L281;
let C173 being (Element of ( NAT ));
assume L374: C173 < C163;
L375: C173 < ( C163 + 1 ) by L374 , NAT_1:13;
L376: ( C167 . ( dl. C173 ) ) = ( C169 . ( dl. C173 ) ) by L375 , L314;
L377: ( dl. C173 ) <> ( dl. C163 ) by L374 , AMI_3:10;
L378: ( D46 . ( dl. C173 ) ) = ( C169 . ( dl. C173 ) ) by L377 , L312 , L315 , L371 , SCM_1:7;
thus L379: thesis by L378 , L304 , L374 , L376;
end;
suppose L380: C160 = [ ( 0 ) , 3 ];

take D47 = ( ( C166 + 1 ) + ( C168 + 1 ) );
take D48 = ( Comput (R1 , C165 , ( D47 + 1 )) );
thus L381: D48 = ( Comput (R1 , C165 , ( D47 + 1 )) );
L382: ( Selfwork (C160 , C163) ) = <% ( Divide (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) %> by L380 , L202;
L383: ( len ( Selfwork (C160 , C163) ) ) = 1 by L382 , AFINSQ_1:34;
thus L384: ( D47 + 1 ) = ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L383 , L296 , L322 , AFINSQ_1:17;
L385: ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) = ( ( ( C166 + 1 ) + ( C168 + 1 ) ) + 1 ) by L296 , L322 , L383 , AFINSQ_1:17;
L386: D47 < ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L385 , NAT_1:13;
L387: D47 in ( dom ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L386 , NAT_1:44;
L388: ( R1 . ( C164 + D47 ) ) = ( ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) . D47 ) by L387 , L288 , FINSEQ_2:146
.= ( Divide (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) by L296 , L322 , L382 , AFINSQ_1:36;
thus L389: ( IC ( Comput (R1 , C165 , D47) ) ) = ( C164 + D47 ) by L299 , L309 , L312 , EXTPRO_1:4;
L390: ( C160 -Meaning_on (( C161 @ C165 ) , ( C162 @ C165 )) ) = ( ( C161 @ C165 ) div ( C162 @ C165 ) ) by L380 , L135;
L391: C163 <> ( C163 + 1 );
L392: ( dl. C163 ) <> ( dl. ( C163 + 1 ) ) by L391 , AMI_3:10;
thus L393: ( IC D48 ) = ( ( C164 + D47 ) + 1 ) by L392 , L312 , L315 , L388 , SCM_1:8
.= ( C164 + ( D47 + 1 ) );
thus L394: ( D48 . ( dl. C163 ) ) = ( ( C169 . ( dl. C163 ) ) div ( C169 . ( dl. ( C163 + 1 ) ) ) ) by L312 , L315 , L388 , L392 , SCM_1:8
.= ( ( C167 . ( dl. C163 ) ) div ( C162 @ C167 ) ) by L313 , L314 , L320
.= ( ( C160 -tree (C161 , C162) ) @ C165 ) by L303 , L321 , L316 , L390 , L281;
let C174 being (Element of ( NAT ));
assume L395: C174 < C163;
L396: C174 < ( C163 + 1 ) by L395 , NAT_1:13;
L397: ( dl. C174 ) <> ( dl. ( C163 + 1 ) ) by L396 , AMI_3:10;
L398: ( C167 . ( dl. C174 ) ) = ( C169 . ( dl. C174 ) ) by L314 , L396;
L399: ( dl. C174 ) <> ( dl. C163 ) by L395 , AMI_3:10;
L400: ( D48 . ( dl. C174 ) ) = ( C169 . ( dl. C174 ) ) by L399 , L312 , L315 , L388 , L392 , L397 , SCM_1:8;
thus L401: thesis by L400 , L304 , L395 , L398;
end;
suppose L402: C160 = [ ( 0 ) , 4 ];

L403: ( C160 -Meaning_on (( C161 @ C165 ) , ( C162 @ C165 )) ) = ( ( C161 @ C165 ) mod ( C162 @ C165 ) ) by L402 , L135;
set D49 = ( ( C166 + 1 ) + ( C168 + 1 ) );
set D50 = ( Comput (R1 , C165 , ( D49 + 1 )) );
take D51 = ( D49 + 1 );
take D52 = ( Comput (R1 , C165 , ( D51 + 1 )) );
thus L404: D52 = ( Comput (R1 , C165 , ( D51 + 1 )) );
L405: ( Selfwork (C160 , C163) ) = <% ( Divide (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) , ( ( dl. C163 ) := ( dl. ( C163 + 1 ) ) ) %> by L402 , L202;
L406: ( len ( Selfwork (C160 , C163) ) ) = 2 by L405 , AFINSQ_1:38;
L407: ( 0 ) in ( dom ( Selfwork (C160 , C163) ) ) by L406 , CARD_1:50 , TARSKI:def 2;
L408: ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) = ( ( ( C166 + 1 ) + ( C168 + 1 ) ) + ( 1 + 1 ) ) by L296 , L322 , L406 , AFINSQ_1:17;
thus L409: ( D51 + 1 ) = ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L408;
L410: 1 in ( dom ( Selfwork (C160 , C163) ) ) by L406 , CARD_1:50 , TARSKI:def 2;
L411: D51 < ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L408 , XREAL_1:6;
L412: D51 in ( dom ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L411 , NAT_1:44;
L413: ( R1 . ( C164 + D51 ) ) = ( ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) . D51 ) by L412 , L288 , FINSEQ_2:146
.= ( ( Selfwork (C160 , C163) ) . 1 ) by L296 , L322 , L410 , AFINSQ_1:def 3
.= ( ( dl. C163 ) := ( dl. ( C163 + 1 ) ) ) by L405 , AFINSQ_1:38;
L414: ( D49 + ( 0 ) ) = D49;
L415: D49 < ( len ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L414 , L408 , XREAL_1:6;
L416: D49 in ( dom ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) ) by L415 , NAT_1:44;
L417: ( R1 . ( C164 + D49 ) ) = ( ( SCM-Compile (( C160 -tree (C161 , C162) ) , C163) ) . ( D49 + ( 0 ) ) ) by L416 , L288 , FINSEQ_2:146
.= ( ( Selfwork (C160 , C163) ) . ( 0 ) ) by L296 , L322 , L407 , AFINSQ_1:def 3
.= ( Divide (( dl. C163 ) , ( dl. ( C163 + 1 ) )) ) by L405 , AFINSQ_1:38;
L418: C163 <> ( C163 + 1 );
L419: ( dl. C163 ) <> ( dl. ( C163 + 1 ) ) by L418 , AMI_3:10;
thus L420: ( IC ( Comput (R1 , C165 , D51) ) ) = ( ( C164 + D49 ) + 1 ) by L419 , L312 , L315 , L417 , SCM_1:8
.= ( C164 + D51 );
thus L421: ( IC D52 ) = ( ( C164 + D51 ) + 1 ) by L420 , L413 , SCM_1:4
.= ( C164 + ( D51 + 1 ) );
thus L422: ( D52 . ( dl. C163 ) ) = ( D50 . ( dl. ( C163 + 1 ) ) ) by L413 , L420 , SCM_1:4
.= ( ( C169 . ( dl. C163 ) ) mod ( C169 . ( dl. ( C163 + 1 ) ) ) ) by L312 , L315 , L417 , L419 , SCM_1:8
.= ( ( C167 . ( dl. C163 ) ) mod ( C162 @ C167 ) ) by L313 , L314 , L320
.= ( ( C160 -tree (C161 , C162) ) @ C165 ) by L303 , L321 , L316 , L403 , L281;
let C175 being (Element of ( NAT ));
assume L423: C175 < C163;
L424: ( dl. C175 ) <> ( dl. C163 ) by L423 , AMI_3:10;
L425: C175 < ( C163 + 1 ) by L423 , NAT_1:13;
L426: ( C167 . ( dl. C175 ) ) = ( C169 . ( dl. C175 ) ) by L425 , L314;
L427: ( dl. C175 ) <> ( dl. ( C163 + 1 ) ) by L425 , AMI_3:10;
L428: ( D50 . ( dl. C175 ) ) = ( C169 . ( dl. C175 ) ) by L427 , L312 , L315 , L417 , L419 , L424 , SCM_1:8;
L429: ( C165 . ( dl. C175 ) ) = ( D50 . ( dl. C175 ) ) by L428 , L304 , L423 , L426;
thus L430: thesis by L429 , L413 , L420 , L424 , SCM_1:4;
end;
end;
L432: (for B302 being (Terminal of ( SCM-AE )) holds S3[ ( root-tree B302 ) ])
proof
let C176 being (Terminal of ( SCM-AE ));
let R1 being (Instruction-Sequence of ( SCM ));
let C177 , C178 being (Element of ( NAT ));
assume that
L433: ( Shift (( SCM-Compile (( root-tree C176 ) , C177) ) , C178) ) c= R1;
let C179 being C178 -started (State of ( SCM ));
assume L434: C177 > ( max_Data-Loc_in ( root-tree C176 ) );
take D53 = ( 0 );
take D54 = ( Comput (R1 , C179 , ( ( 0 ) + 1 )) );
thus L435: D54 = ( Comput (R1 , C179 , ( D53 + 1 )) );
L436: ( <% ( ( dl. C177 ) := ( @ C176 ) ) %> . ( 0 ) ) = ( ( dl. C177 ) := ( @ C176 ) ) by AFINSQ_1:34;
L437: ( SCM-Compile (( root-tree C176 ) , C177) ) = <% ( ( dl. C177 ) := ( @ C176 ) ) %> by L235;
thus L438: ( D53 + 1 ) = ( len ( SCM-Compile (( root-tree C176 ) , C177) ) ) by L437 , AFINSQ_1:34;
L439: C179 = ( Comput (R1 , C179 , ( 0 )) ) by EXTPRO_1:2;
thus L440: ( IC ( Comput (R1 , C179 , D53) ) ) = ( C178 + D53 ) by L439 , MEMSTR_0:def 12;
L441: (( len <% ( ( dl. C177 ) := ( @ C176 ) ) %> ) = 1 & ( C178 + ( 0 ) ) = C178) by AFINSQ_1:34;
L442: D53 in ( dom ( SCM-Compile (( root-tree C176 ) , C177) ) ) by L441 , L437 , NAT_1:44;
L443: (( IC C179 ) = C178 & ( R1 . ( C178 + ( 0 ) ) ) = ( ( dl. C177 ) := ( @ C176 ) )) by L442 , L437 , L436 , L433 , FINSEQ_2:146 , MEMSTR_0:def 12;
thus L444: ( IC D54 ) = ( C178 + ( D53 + 1 ) ) by L443 , L439 , SCM_1:4;
thus L445: ( D54 . ( dl. C177 ) ) = ( C179 . C176 ) by L439 , L443 , SCM_1:4
.= ( ( root-tree C176 ) @ C179 ) by L186;
let C180 being (Element of ( NAT ));
assume L446: C180 < C177;
L447: ( dl. C180 ) <> ( dl. C177 ) by L446 , AMI_3:10;
thus L448: thesis by L447 , L439 , L443 , SCM_1:4;
end;
L449: (for B303 being bin-term holds S3[ B303 ]) from BINTREE1:sch 2(L432 , L284);
thus L450: thesis by L449;
end;
theorem
L451: (for R1 being (Instruction-Sequence of ( SCM )) holds (for B304 being bin-term holds (for B305 , B306 being (Element of ( NAT )) holds (( Shift (( ( SCM-Compile (B304 , B305) ) ^ <% ( halt ( SCM ) ) %> ) , B306) ) c= R1 implies (for B307 being B306 -started (State of ( SCM )) holds (B305 > ( max_Data-Loc_in B304 ) implies (R1 halts_on B307 & ( ( Result (R1 , B307) ) . ( dl. B305 ) ) = ( B304 @ B307 ) & ( LifeSpan (R1 , B307) ) = ( len ( SCM-Compile (B304 , B305) ) ))))))))
proof
let R1 being (Instruction-Sequence of ( SCM ));
let C181 being bin-term;
let C182 , C183 being (Element of ( NAT ));
assume that
L452: ( Shift (( ( SCM-Compile (C181 , C182) ) ^ <% ( halt ( SCM ) ) %> ) , C183) ) c= R1;
let C184 being C183 -started (State of ( SCM ));
assume L453: C182 > ( max_Data-Loc_in C181 );
L454: ( Shift (( SCM-Compile (C181 , C182) ) , C183) ) c= R1 by L452 , AFINSQ_1:82;
consider C185 being (Element of ( NAT )), C186 being (State of ( SCM )) such that L455: C186 = ( Comput (R1 , C184 , ( C185 + 1 )) ) and L456: ( C185 + 1 ) = ( len ( SCM-Compile (C181 , C182) ) ) and L457: ( IC ( Comput (R1 , C184 , C185) ) ) = ( C183 + C185 ) and L458: ( IC C186 ) = ( C183 + ( C185 + 1 ) ) and L459: ( C186 . ( dl. C182 ) ) = ( C181 @ C184 ) and L460: (for B308 being (Element of ( NAT )) holds (B308 < C182 implies ( C184 . ( dl. B308 ) ) = ( C186 . ( dl. B308 ) ))) by L454 , L453 , L283;
L461: ( len <% ( halt ( SCM ) ) %> ) = 1 by AFINSQ_1:34;
L462: ( len ( ( SCM-Compile (C181 , C182) ) ^ <% ( halt ( SCM ) ) %> ) ) = ( ( C185 + 1 ) + 1 ) by L461 , L456 , AFINSQ_1:17;
L463: ( C185 + 1 ) < ( len ( ( SCM-Compile (C181 , C182) ) ^ <% ( halt ( SCM ) ) %> ) ) by L462 , NAT_1:13;
L464: ( C185 + 1 ) in ( dom ( ( SCM-Compile (C181 , C182) ) ^ <% ( halt ( SCM ) ) %> ) ) by L463 , NAT_1:44;
L465: ( R1 . ( C183 + ( C185 + 1 ) ) ) = ( ( ( SCM-Compile (C181 , C182) ) ^ <% ( halt ( SCM ) ) %> ) . ( C185 + 1 ) ) by L464 , L452 , FINSEQ_2:146
.= ( halt ( SCM ) ) by L456 , AFINSQ_1:36;
thus L466: R1 halts_on C184 by L465 , L455 , L458 , EXTPRO_1:30;
thus L467: ( ( Result (R1 , C184) ) . ( dl. C182 ) ) = ( C181 @ C184 ) by L455 , L458 , L459 , L465 , EXTPRO_1:31;
L468: ( C183 + C185 ) <> ( C183 + ( C185 + 1 ) );
thus L469: thesis by L468 , L455 , L456 , L457 , L458 , L465 , EXTPRO_1:33;
end;
