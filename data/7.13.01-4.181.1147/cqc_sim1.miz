:: Similarity of Formulae
::  by Agata Darmochwa{\l} and Andrzej Trybulec
::
:: Received November 22, 1991
:: Copyright (c) 1991-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FUNCT_1, RELAT_1, FUNCT_4, FUNCOP_1, TARSKI, XBOOLE_0,
      SUBSET_1, CQC_LANG, QC_LANG1, ZF_LANG, REALSET1, XXREAL_0, FINSEQ_1,
      XBOOLEAN, CLASSES2, BVFUNC_2, NAT_1, ARYTM_3, CARD_1, FUNCT_2, MARGREL1,
      FINSUB_1, ZFMISC_1, FINSET_1, ZF_LANG1, RCOMP_1, PARTFUN1, SETWISEO,
      SETFAM_1, MEMBER_1, CQC_SIM1, RECDEF_2, XTUPLE_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1,
      XTUPLE_0, SUBSET_1, NUMBERS, DOMAIN_1, MCART_1,
      ORDINAL1, SETFAM_1, RELAT_1, FUNCT_1, FUNCT_2, BINOP_1, PARTFUN1,
      XXREAL_0, FUNCOP_1, FINSEQ_1, FINSET_1, FINSUB_1, NAT_1, SETWISEO,
      QC_LANG1, QC_LANG2, QC_LANG3, CQC_LANG, FUNCT_4, RECDEF_1, SEQ_4;
 constructors SETFAM_1, PARTFUN1, BINOP_1, DOMAIN_1, FUNCT_4, SETWISEO,
      XXREAL_0, NAT_1, RECDEF_1, SEQ_4, QC_LANG3, CQC_LANG, XXREAL_2, RELSET_1,
      XTUPLE_0;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, FUNCT_2, FINSUB_1,
      XXREAL_0, NAT_1, MEMBERED, FINSEQ_1, QC_LANG1, CQC_LANG, VALUED_0,
      FINSET_1, FUNCOP_1, XXREAL_2, RELSET_1, CARD_1, RELAT_1, XTUPLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions TARSKI, XBOOLE_0, BINOP_1, QC_LANG3, SUBSET_1, RELAT_1, FUNCOP_1,
      XTUPLE_0;
 theorems ZFMISC_1, DOMAIN_1, FINSEQ_1, CQC_LANG, QC_LANG1, PARTFUN1, QC_LANG3,
      MCART_1, FUNCT_1, FUNCT_2, NAT_1, TARSKI, FUNCOP_1, FUNCT_4, FINSEQ_2,
      SETFAM_1, QC_LANG2, RELAT_1, RELSET_1, FINSEQ_3, XBOOLE_0, XBOOLE_1,
      XXREAL_0, CARD_1, XTUPLE_0;
 schemes CQC_LANG, CLASSES1, NAT_1, FRAENKEL, QC_LANG1, FUNCT_1, BINOP_1,
      CARD_2, FUNCT_2;

begin
definition
let R1 being QC-alphabet;
let C1 being (bound_QC-variable of R1);
func x. C1 -> (QC-symbol of R1) means 
:L1: ( x. it ) = C1;
existence by QC_LANG3:30;
uniqueness by XTUPLE_0:1;
end;
theorem
L3: (for B1 , B2 being set holds (for B3 being Function holds ( Im (( B3 +* ( B1 .--> B2 ) ) , B1) ) = { B2 }))
proof
let C2 , C3 being set;
let C4 being Function;
L4:
now
let C5 being set;
thus L5: (C5 in ( ( C4 +* ( C2 .--> C3 ) ) .: { C2 } ) implies C5 = C3)
proof
assume L6: C5 in ( ( C4 +* ( C2 .--> C3 ) ) .: { C2 } );
consider C6 being set such that L7: C6 in ( dom ( C4 +* ( C2 .--> C3 ) ) ) and L8: C6 in { C2 } and L9: C5 = ( ( C4 +* ( C2 .--> C3 ) ) . C6 ) by L6 , FUNCT_1:def 6;
L10: C6 in ( dom ( C2 .--> C3 ) ) by L8 , FUNCOP_1:13;
L11: C5 = ( ( C2 .--> C3 ) . C6 ) by L10 , L9 , FUNCT_4:13;
thus L12: thesis by L11 , L8 , FUNCOP_1:7;
end;

L13: C2 in { C2 } by TARSKI:def 1;
L14: C2 in ( dom ( C2 .--> C3 ) ) by L13 , FUNCOP_1:13;
L15: C2 in ( dom ( C4 +* ( C2 .--> C3 ) ) ) by L14 , FUNCT_4:12;
L16: ( ( C2 .--> C3 ) . C2 ) = C3 by L13 , FUNCOP_1:7;
L17: C3 = ( ( C4 +* ( C2 .--> C3 ) ) . C2 ) by L16 , L14 , FUNCT_4:13;
thus L18: (C5 = C3 implies C5 in ( ( C4 +* ( C2 .--> C3 ) ) .: { C2 } )) by L17 , L13 , L15 , FUNCT_1:def 6;
end;
thus L19: thesis by L4 , TARSKI:def 1;
end;
theorem
L20: (for B4 , B5 being set holds (for B6 , B7 being set holds (for B8 being Function holds ( ( B8 +* ( B5 --> B7 ) ) .: B4 ) c= ( ( B8 .: B4 ) \/ { B7 } ))))
proof
let C7 , C8 being set;
let C9 , C10 being set;
let C11 being Function;
let C12 being set;
assume L21: C12 in ( ( C11 +* ( C8 --> C10 ) ) .: C7 );
consider C13 being set such that L22: C13 in ( dom ( C11 +* ( C8 --> C10 ) ) ) and L23: C13 in C7 and L24: C12 = ( ( C11 +* ( C8 --> C10 ) ) . C13 ) by L21 , FUNCT_1:def 6;
L25: ( dom ( C8 --> C10 ) ) = C8 by FUNCOP_1:13;
L26:
now
per cases ;
case L27: C13 in C8;
L28: C12 = ( ( C8 --> C10 ) . C13 ) by L27 , L24 , L25 , FUNCT_4:13;
L29: C12 = C10 by L28 , L27 , FUNCOP_1:7;
thus L30: C12 in { C10 } by L29 , TARSKI:def 1;
end;
case L31: (not C13 in C8);
L32: C12 = ( C11 . C13 ) by L31 , L24 , L25 , FUNCT_4:11;
L33: C13 in ( dom C11 ) by L22 , L25 , L31 , FUNCT_4:12;
thus L34: C12 in ( C11 .: C7 ) by L33 , L23 , L32 , FUNCT_1:def 6;
end;
end;
thus L36: thesis by L26 , XBOOLE_0:def 3;
end;
theorem
L37: (for B9 , B10 being set holds (for B11 being Function holds (for B12 being set holds ( ( B11 +* ( B9 .--> B10 ) ) .: ( B12 \ { B9 } ) ) = ( B11 .: ( B12 \ { B9 } ) ))))
proof
let C14 , C15 being set;
let C16 being Function;
let C17 being set;
thus L38: ( ( C16 +* ( C14 .--> C15 ) ) .: ( C17 \ { C14 } ) ) c= ( C16 .: ( C17 \ { C14 } ) )
proof
let C18 being set;
L39: ( dom ( C14 .--> C15 ) ) = { C14 } by FUNCOP_1:13;
assume L40: C18 in ( ( C16 +* ( C14 .--> C15 ) ) .: ( C17 \ { C14 } ) );
consider C19 being set such that L41: C19 in ( dom ( C16 +* ( C14 .--> C15 ) ) ) and L42: C19 in ( C17 \ { C14 } ) and L43: C18 = ( ( C16 +* ( C14 .--> C15 ) ) . C19 ) by L40 , FUNCT_1:def 6;
L44: (not C19 in { C14 }) by L42 , XBOOLE_0:def 5;
L45: C19 in ( dom C16 ) by L44 , L41 , L39 , FUNCT_4:12;
L46: C18 = ( C16 . C19 ) by L43 , L44 , L39 , FUNCT_4:11;
thus L47: thesis by L46 , L42 , L45 , FUNCT_1:def 6;
end;

let C20 being set;
assume L48: C20 in ( C16 .: ( C17 \ { C14 } ) );
consider C21 being set such that L49: C21 in ( dom C16 ) and L50: C21 in ( C17 \ { C14 } ) and L51: C20 = ( C16 . C21 ) by L48 , FUNCT_1:def 6;
L52: (not C21 in { C14 }) by L50 , XBOOLE_0:def 5;
L53: (not C21 in ( dom ( C14 .--> C15 ) )) by L52 , FUNCOP_1:13;
L54: C20 = ( ( C16 +* ( C14 .--> C15 ) ) . C21 ) by L53 , L51 , FUNCT_4:11;
L55: C21 in ( dom ( C16 +* ( C14 .--> C15 ) ) ) by L49 , FUNCT_4:12;
thus L56: thesis by L55 , L50 , L54 , FUNCT_1:def 6;
end;
theorem
L57: (for B13 , B14 being set holds (for B15 being Function holds (for B16 being set holds ((not B14 in ( B15 .: ( B16 \ { B13 } ) )) implies ( ( B15 +* ( B13 .--> B14 ) ) .: ( B16 \ { B13 } ) ) = ( ( ( B15 +* ( B13 .--> B14 ) ) .: B16 ) \ { B14 } )))))
proof
let C22 , C23 being set;
let C24 being Function;
let C25 being set;
assume L58: (not C23 in ( C24 .: ( C25 \ { C22 } ) ));
thus L59: ( ( C24 +* ( C22 .--> C23 ) ) .: ( C25 \ { C22 } ) ) c= ( ( ( C24 +* ( C22 .--> C23 ) ) .: C25 ) \ { C23 } )
proof
let C26 being set;
L60: ( dom ( C22 .--> C23 ) ) = { C22 } by FUNCOP_1:13;
assume L61: C26 in ( ( C24 +* ( C22 .--> C23 ) ) .: ( C25 \ { C22 } ) );
consider C27 being set such that L62: C27 in ( dom ( C24 +* ( C22 .--> C23 ) ) ) and L63: C27 in ( C25 \ { C22 } ) and L64: C26 = ( ( C24 +* ( C22 .--> C23 ) ) . C27 ) by L61 , FUNCT_1:def 6;
L65: (not C27 in { C22 }) by L63 , XBOOLE_0:def 5;
L66: C27 in ( dom C24 ) by L65 , L62 , L60 , FUNCT_4:12;
L67: C26 = ( C24 . C27 ) by L64 , L65 , L60 , FUNCT_4:11;
L68: C26 <> C23 by L67 , L58 , L63 , L66 , FUNCT_1:def 6;
L69: (not C26 in { C23 }) by L68 , TARSKI:def 1;
L70: ( ( C24 +* ( C22 .--> C23 ) ) .: ( C25 \ { C22 } ) ) c= ( ( C24 +* ( C22 .--> C23 ) ) .: C25 ) by RELAT_1:123;
thus L71: thesis by L70 , L61 , L69 , XBOOLE_0:def 5;
end;

let C28 being set;
assume L72: C28 in ( ( ( C24 +* ( C22 .--> C23 ) ) .: C25 ) \ { C23 } );
consider C29 being set such that L73: C29 in ( dom ( C24 +* ( C22 .--> C23 ) ) ) and L74: C29 in C25 and L75: C28 = ( ( C24 +* ( C22 .--> C23 ) ) . C29 ) by L72 , FUNCT_1:def 6;
L76:
now
assume L77: C29 in { C22 };
L78: C29 in ( dom ( C22 .--> C23 ) ) by L77 , FUNCOP_1:13;
L79: C28 = ( ( C22 .--> C23 ) . C29 ) by L78 , L75 , FUNCT_4:13;
L80: C28 = C23 by L79 , L77 , FUNCOP_1:7;
L81: C28 in { C23 } by L80 , TARSKI:def 1;
thus L82: contradiction by L81 , L72 , XBOOLE_0:def 5;
end;
L83: C29 in ( C25 \ { C22 } ) by L76 , L74 , XBOOLE_0:def 5;
thus L84: thesis by L83 , L73 , L75 , FUNCT_1:def 6;
end;
theorem
L85: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 is  atomic implies (ex R4 being (Element of ( NAT )) st (ex R22 being (QC-pred_symbol of R4 , R1) st (ex R21 being (CQC-variable_list of R4 , R1) st R16 = ( R22 ! R21 )))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
assume L86: R16 is  atomic;
consider C30 being (Element of ( NAT )), C31 being (QC-pred_symbol of C30 , R1), C32 being (QC-variable_list of C30 , R1) such that L87: R16 = ( C31 ! C32 ) by L86 , QC_LANG1:def 18;
L88: { ( C32 . R6 ) where R6 is (Element of ( NAT )) : (1 <= R6 & R6 <= ( len C32 ) & ( C32 . R6 ) in ( fixed_QC-variables R1 )) } = ( {} ) by L87 , CQC_LANG:7;
L89: { ( C32 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C32 ) & ( C32 . R2 ) in ( free_QC-variables R1 )) } = ( {} ) by L87 , CQC_LANG:7;
L90: C32 is (CQC-variable_list of C30 , R1) by L89 , L88 , CQC_LANG:5;
thus L91: thesis by L90 , L87;
end;
theorem
L92: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 is  negative implies (ex R17 being (Element of ( CQC-WFF R1 )) st R16 = ( 'not' R17 )))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
assume L93: R16 is  negative;
consider C33 being (Element of ( QC-WFF R1 )) such that L94: R16 = ( 'not' C33 ) by L93 , QC_LANG1:def 19;
L95: C33 is (Element of ( CQC-WFF R1 )) by L94 , CQC_LANG:8;
thus L96: thesis by L95 , L94;
end;
theorem
L97: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 is  conjunctive implies (ex R17 being (Element of ( CQC-WFF R1 )) st (ex R18 being (Element of ( CQC-WFF R1 )) st R16 = ( R17 '&' R18 ))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
assume L98: R16 is  conjunctive;
consider C34 , C35 being (Element of ( QC-WFF R1 )) such that L99: R16 = ( C34 '&' C35 ) by L98 , QC_LANG1:def 20;
L100: C35 is (Element of ( CQC-WFF R1 )) by L99 , CQC_LANG:9;
L101: C34 is (Element of ( CQC-WFF R1 )) by L99 , CQC_LANG:9;
thus L102: thesis by L101 , L99 , L100;
end;
theorem
L103: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 is  universal implies (ex R20 being (Element of ( bound_QC-variables R1 )) st (ex R17 being (Element of ( CQC-WFF R1 )) st R16 = ( All (R20 , R17) ))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
assume L104: R16 is  universal;
consider C36 being (bound_QC-variable of R1), C37 being (Element of ( QC-WFF R1 )) such that L105: R16 = ( All (C36 , C37) ) by L104 , QC_LANG1:def 21;
L106: C37 is (Element of ( CQC-WFF R1 )) by L105 , CQC_LANG:13;
thus L107: thesis by L106 , L105;
end;
theorem
L108: (for B17 being FinSequence holds ( rng B17 ) = { ( B17 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len B17 )) })
proof
let C38 being FinSequence;
thus L109: ( rng C38 ) c= { ( C38 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C38 )) }
proof
let R8 being set;
assume L110: R8 in ( rng C38 );
consider C39 being set such that L111: C39 in ( dom C38 ) and L112: R8 = ( C38 . C39 ) by L110 , FUNCT_1:def 3;
reconsider D1 = C39 as (Element of ( NAT )) by L111;
L113: D1 <= ( len C38 ) by L111 , FINSEQ_3:25;
L114: 1 <= D1 by L111 , FINSEQ_3:25;
thus L115: thesis by L114 , L112 , L113;
end;

thus L116: { ( C38 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C38 )) } c= ( rng C38 )
proof
let R8 being set;
assume L117: R8 in { ( C38 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C38 )) };
consider C40 being (Element of ( NAT )) such that L118: R8 = ( C38 . C40 ) and L119: 1 <= C40 and L120: C40 <= ( len C38 ) by L117;
L121: C40 in ( dom C38 ) by L119 , L120 , FINSEQ_3:25;
thus L122: thesis by L121 , L118 , FUNCT_1:def 3;
end;

end;
scheme QCFuncExN { F1() -> QC-alphabet , F2() -> non  empty set , F3() -> (Element of F2()) , F4(set) -> (Element of F2()) , F5(set , set) -> (Element of F2()) , F6(set , set , set) -> (Element of F2()) , F7(set , set) -> (Element of F2()) } : (ex B18 being (Function of ( QC-WFF F1() ) , F2()) st (( B18 . ( VERUM F1() ) ) = F3() & (for B19 being (Element of ( QC-WFF F1() )) holds ((B19 is  atomic implies ( B18 . B19 ) = F4(B19)) & (B19 is  negative implies ( B18 . B19 ) = F5(( B18 . ( the_argument_of B19 ) ) , B19)) & (B19 is  conjunctive implies ( B18 . B19 ) = F6(( B18 . ( the_left_argument_of B19 ) ) , ( B18 . ( the_right_argument_of B19 ) ) , B19)) & (B19 is  universal implies ( B18 . B19 ) = F7(( B18 . ( the_scope_of B19 ) ) , B19))))))
proof
defpred S1[ (Function of ( QC-WFF F1() ) , F2()) , Nat ] means (for B20 being (Element of ( QC-WFF F1() )) holds (( len ( @ B20 ) ) <= $2 implies ((B20 = ( VERUM F1() ) implies ( $1 . B20 ) = F3()) & (B20 is  atomic implies ( $1 . B20 ) = F4(B20)) & (B20 is  negative implies ( $1 . B20 ) = F5(( $1 . ( the_argument_of B20 ) ) , B20)) & (B20 is  conjunctive implies ( $1 . B20 ) = F6(( $1 . ( the_left_argument_of B20 ) ) , ( $1 . ( the_right_argument_of B20 ) ) , B20)) & (B20 is  universal implies ( $1 . B20 ) = F7(( $1 . ( the_scope_of B20 ) ) , B20)))));
defpred S2[ (Element of F2()) , (Function of ( QC-WFF F1() ) , F2()) , (Element of ( QC-WFF F1() )) ] means (($3 = ( VERUM F1() ) implies $1 = F3()) & ($3 is  atomic implies $1 = F4($3)) & ($3 is  negative implies $1 = F5(( $2 . ( the_argument_of $3 ) ) , $3)) & ($3 is  conjunctive implies $1 = F6(( $2 . ( the_left_argument_of $3 ) ) , ( $2 . ( the_right_argument_of $3 ) ) , $3)) & ($3 is  universal implies $1 = F7(( $2 . ( the_scope_of $3 ) ) , $3)));
defpred S3[ (Element of ( NAT )) ] means (ex B21 being (Function of ( QC-WFF F1() ) , F2()) st S1[ B21 , $1 ]);
L117: (for B22 being (Element of ( NAT )) holds (S3[ B22 ] implies S3[ ( B22 + 1 ) ]))
proof
let C41 being (Element of ( NAT ));
given C42 being (Function of ( QC-WFF F1() ) , F2()) such that
L118: S1[ C42 , C41 ];

defpred S4[ (Element of ( QC-WFF F1() )) , (Element of F2()) ] means ((( len ( @ $1 ) ) <> ( C41 + 1 ) implies $2 = ( C42 . $1 )) & (( len ( @ $1 ) ) = ( C41 + 1 ) implies S2[ $2 , C42 , $1 ]));
L119: (for B23 being (Element of ( QC-WFF F1() )) holds (ex B24 being (Element of F2()) st S4[ B23 , B24 ]))
proof
let C43 being (Element of ( QC-WFF F1() ));
L120:
now
per cases  by QC_LANG1:9;
case L121: ( len ( @ C43 ) ) <> ( C41 + 1 );
take D2 = ( C42 . C43 );
thus L122: D2 = ( C42 . C43 );
end;
case L123: (( len ( @ C43 ) ) = ( C41 + 1 ) & C43 = ( VERUM F1() ));
take D3 = F3();
thus L124: S2[ D3 , C42 , C43 ] by L123 , QC_LANG1:20;
end;
case L125: (( len ( @ C43 ) ) = ( C41 + 1 ) & C43 is  atomic);
take D4 = F4(C43);
thus L126: S2[ D4 , C42 , C43 ] by L125 , QC_LANG1:20;
end;
case L127: (( len ( @ C43 ) ) = ( C41 + 1 ) & C43 is  negative);
take D5 = F5(( C42 . ( the_argument_of C43 ) ) , C43);
thus L128: S2[ D5 , C42 , C43 ] by L127 , QC_LANG1:20;
end;
case L129: (( len ( @ C43 ) ) = ( C41 + 1 ) & C43 is  conjunctive);
take D6 = F6(( C42 . ( the_left_argument_of C43 ) ) , ( C42 . ( the_right_argument_of C43 ) ) , C43);
thus L130: S2[ D6 , C42 , C43 ] by L129 , QC_LANG1:20;
end;
case L131: (( len ( @ C43 ) ) = ( C41 + 1 ) & C43 is  universal);
take D7 = F7(( C42 . ( the_scope_of C43 ) ) , C43);
thus L132: S2[ D7 , C42 , C43 ] by L131 , QC_LANG1:20;
end;
end;
thus L134: thesis by L120;
end;
consider C44 being (Function of ( QC-WFF F1() ) , F2()) such that L135: (for B25 being (Element of ( QC-WFF F1() )) holds S4[ B25 , ( C44 . B25 ) ]) from FUNCT_2:sch 3(L119);
take D8 = C44;
thus L136: S1[ D8 , ( C41 + 1 ) ]
proof
let C45 being (Element of ( QC-WFF F1() ));
assume that
L137: ( len ( @ C45 ) ) <= ( C41 + 1 );
thus L138: (C45 = ( VERUM F1() ) implies ( D8 . C45 ) = F3())
proof
L139:
now
per cases ;
suppose L140: ( len ( @ C45 ) ) <> ( C41 + 1 );

L141: ( D8 . C45 ) = ( C42 . C45 ) by L140 , L135;
L142: ( len ( @ C45 ) ) <= C41 by L137 , L140 , NAT_1:8;
thus L143: thesis by L142 , L118 , L141;
end;
suppose L144: ( len ( @ C45 ) ) = ( C41 + 1 );

thus L145: thesis by L144 , L135;
end;
end;
thus L147: thesis by L139;
end;

thus L148: (C45 is  atomic implies ( D8 . C45 ) = F4(C45))
proof
L149:
now
per cases ;
suppose L150: ( len ( @ C45 ) ) <> ( C41 + 1 );

L151: ( D8 . C45 ) = ( C42 . C45 ) by L150 , L135;
L152: ( len ( @ C45 ) ) <= C41 by L137 , L150 , NAT_1:8;
thus L153: thesis by L152 , L118 , L151;
end;
suppose L154: ( len ( @ C45 ) ) = ( C41 + 1 );

thus L155: thesis by L154 , L135;
end;
end;
thus L157: thesis by L149;
end;

thus L158: (C45 is  negative implies ( D8 . C45 ) = F5(( D8 . ( the_argument_of C45 ) ) , C45))
proof
assume L159: C45 is  negative;
L160: ( len ( @ ( the_argument_of C45 ) ) ) <> ( C41 + 1 ) by L159 , L137 , QC_LANG1:14;
L161: ( D8 . ( the_argument_of C45 ) ) = ( C42 . ( the_argument_of C45 ) ) by L160 , L135;
L162:
now
per cases ;
suppose L163: ( len ( @ C45 ) ) <> ( C41 + 1 );

L164: ( D8 . C45 ) = ( C42 . C45 ) by L163 , L135;
L165: ( len ( @ C45 ) ) <= C41 by L137 , L163 , NAT_1:8;
thus L166: thesis by L165 , L118 , L159 , L161 , L164;
end;
suppose L167: ( len ( @ C45 ) ) = ( C41 + 1 );

thus L168: thesis by L167 , L135 , L159 , L161;
end;
end;
thus L170: thesis by L162;
end;

thus L171: (C45 is  conjunctive implies ( D8 . C45 ) = F6(( D8 . ( the_left_argument_of C45 ) ) , ( D8 . ( the_right_argument_of C45 ) ) , C45))
proof
assume L172: C45 is  conjunctive;
L173: ( len ( @ ( the_right_argument_of C45 ) ) ) <> ( C41 + 1 ) by L172 , L137 , QC_LANG1:15;
L174: ( D8 . ( the_right_argument_of C45 ) ) = ( C42 . ( the_right_argument_of C45 ) ) by L173 , L135;
L175: ( len ( @ ( the_left_argument_of C45 ) ) ) <> ( C41 + 1 ) by L137 , L172 , QC_LANG1:15;
L176: ( D8 . ( the_left_argument_of C45 ) ) = ( C42 . ( the_left_argument_of C45 ) ) by L175 , L135;
L177:
now
per cases ;
suppose L178: ( len ( @ C45 ) ) <> ( C41 + 1 );

L179: ( D8 . C45 ) = ( C42 . C45 ) by L178 , L135;
L180: ( len ( @ C45 ) ) <= C41 by L137 , L178 , NAT_1:8;
thus L181: thesis by L180 , L118 , L172 , L176 , L174 , L179;
end;
suppose L182: ( len ( @ C45 ) ) = ( C41 + 1 );

thus L183: thesis by L182 , L135 , L172 , L176 , L174;
end;
end;
thus L185: thesis by L177;
end;

thus L186: (C45 is  universal implies ( D8 . C45 ) = F7(( D8 . ( the_scope_of C45 ) ) , C45))
proof
assume L187: C45 is  universal;
L188: ( len ( @ ( the_scope_of C45 ) ) ) <> ( C41 + 1 ) by L187 , L137 , QC_LANG1:16;
L189: ( D8 . ( the_scope_of C45 ) ) = ( C42 . ( the_scope_of C45 ) ) by L188 , L135;
L190:
now
per cases ;
suppose L191: ( len ( @ C45 ) ) <> ( C41 + 1 );

L192: ( D8 . C45 ) = ( C42 . C45 ) by L191 , L135;
L193: ( len ( @ C45 ) ) <= C41 by L137 , L191 , NAT_1:8;
thus L194: thesis by L193 , L118 , L187 , L189 , L192;
end;
suppose L195: ( len ( @ C45 ) ) = ( C41 + 1 );

thus L196: thesis by L195 , L135 , L187 , L189;
end;
end;
thus L198: thesis by L190;
end;

end;

end;
defpred S5[ set , set ] means (ex B26 being (Element of ( QC-WFF F1() )) st (B26 = $1 & (for B27 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B27 , ( len ( @ B26 ) ) ] implies $2 = ( B27 . B26 )))));
L137: S3[ ( 0 ) ]
proof
set D9 = the (Function of ( QC-WFF F1() ) , F2());
take D9;
thus L138: thesis by QC_LANG1:10;
end;
L139: (for B28 being (Element of ( NAT )) holds S3[ B28 ]) from NAT_1:sch 1(L137 , L117);
L140: (for B29 being set holds (B29 in ( QC-WFF F1() ) implies (ex B30 being set st S5[ B29 , B30 ])))
proof
let C46 being set;
assume L141: C46 in ( QC-WFF F1() );
reconsider D10 = C46 as (Element of ( QC-WFF F1() )) by L141;
consider C47 being (Function of ( QC-WFF F1() ) , F2()) such that L142: S1[ C47 , ( len ( @ D10 ) ) ] by L139;
take ( C47 . C46 );
take D10;
thus L143: C46 = D10;
let C48 being (Function of ( QC-WFF F1() ) , F2());
assume that
L144: S1[ C48 , ( len ( @ D10 ) ) ];
defpred S6[ (Element of ( QC-WFF F1() )) ] means (( len ( @ $1 ) ) <= ( len ( @ D10 ) ) implies ( C47 . $1 ) = ( C48 . $1 ));
L145:
now
let C49 being (Element of ( QC-WFF F1() ));
thus L146: (C49 is  atomic implies S6[ C49 ])
proof
assume that
L147: C49 is  atomic
and
L148: ( len ( @ C49 ) ) <= ( len ( @ D10 ) );
thus L149: ( C47 . C49 ) = F4(C49) by L142 , L147 , L148
.= ( C48 . C49 ) by L144 , L147 , L148;
end;

thus L150: S6[ ( VERUM F1() ) ]
proof
assume L151: ( len ( @ ( VERUM F1() ) ) ) <= ( len ( @ D10 ) );
thus L152: ( C47 . ( VERUM F1() ) ) = F3() by L151 , L142
.= ( C48 . ( VERUM F1() ) ) by L144 , L151;
end;

thus L153: ((C49 is  negative & S6[ ( the_argument_of C49 ) ]) implies S6[ C49 ])
proof
assume that
L154: C49 is  negative
and
L155: S6[ ( the_argument_of C49 ) ]
and
L156: ( len ( @ C49 ) ) <= ( len ( @ D10 ) );
L157: ( len ( @ ( the_argument_of C49 ) ) ) < ( len ( @ C49 ) ) by L154 , QC_LANG1:14;
thus L158: ( C47 . C49 ) = F5(( C48 . ( the_argument_of C49 ) ) , C49) by L157 , L142 , L154 , L155 , L156 , XXREAL_0:2
.= ( C48 . C49 ) by L144 , L154 , L156;
end;

thus L159: ((C49 is  conjunctive & S6[ ( the_left_argument_of C49 ) ] & S6[ ( the_right_argument_of C49 ) ]) implies S6[ C49 ])
proof
assume that
L160: C49 is  conjunctive
and
L161: S6[ ( the_left_argument_of C49 ) ]
and
L162: S6[ ( the_right_argument_of C49 ) ]
and
L163: ( len ( @ C49 ) ) <= ( len ( @ D10 ) );
L164: ( len ( @ ( the_right_argument_of C49 ) ) ) < ( len ( @ C49 ) ) by L160 , QC_LANG1:15;
L165: ( len ( @ ( the_left_argument_of C49 ) ) ) < ( len ( @ C49 ) ) by L160 , QC_LANG1:15;
thus L166: ( C47 . C49 ) = F6(( C48 . ( the_left_argument_of C49 ) ) , ( C48 . ( the_right_argument_of C49 ) ) , C49) by L165 , L142 , L160 , L161 , L162 , L163 , L164 , XXREAL_0:2
.= ( C48 . C49 ) by L144 , L160 , L163;
end;

thus L167: ((C49 is  universal & S6[ ( the_scope_of C49 ) ]) implies S6[ C49 ])
proof
assume that
L168: C49 is  universal
and
L169: S6[ ( the_scope_of C49 ) ]
and
L170: ( len ( @ C49 ) ) <= ( len ( @ D10 ) );
L171: ( len ( @ ( the_scope_of C49 ) ) ) < ( len ( @ C49 ) ) by L168 , QC_LANG1:16;
thus L172: ( C47 . C49 ) = F7(( C48 . ( the_scope_of C49 ) ) , C49) by L171 , L142 , L168 , L169 , L170 , XXREAL_0:2
.= ( C48 . C49 ) by L144 , L168 , L170;
end;

end;
L168: (for B31 being (Element of ( QC-WFF F1() )) holds S6[ B31 ]) from QC_LANG1:sch 2(L145);
thus L169: thesis by L168;
end;
consider C50 being Function such that L170: ( dom C50 ) = ( QC-WFF F1() ) and L171: (for B32 being set holds (B32 in ( QC-WFF F1() ) implies S5[ B32 , ( C50 . B32 ) ])) from CLASSES1:sch 1(L140);
L172: ( rng C50 ) c= F2()
proof
let C51 being set;
assume L173: C51 in ( rng C50 );
consider C52 being set such that L174: C52 in ( QC-WFF F1() ) and L175: C51 = ( C50 . C52 ) by L173 , L170 , FUNCT_1:def 3;
consider C53 being (Element of ( QC-WFF F1() )) such that L176: C53 = C52 and L177: (for B33 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B33 , ( len ( @ C53 ) ) ] implies C51 = ( B33 . C53 ))) by L171 , L174 , L175;
consider C54 being (Function of ( QC-WFF F1() ) , F2()) such that L178: S1[ C54 , ( len ( @ C53 ) ) ] by L139;
L179: C51 = ( C54 . C53 ) by L177 , L178;
thus L180: thesis by L179;
end;
reconsider D11 = C50 as (Function of ( QC-WFF F1() ) , F2()) by L172 , L170 , FUNCT_2:def 1 , RELSET_1:4;
consider C55 being (Element of ( QC-WFF F1() )) such that L181: C55 = ( VERUM F1() ) and L182: (for B34 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B34 , ( len ( @ C55 ) ) ] implies ( D11 . ( VERUM F1() ) ) = ( B34 . C55 ))) by L171;
take D11;
consider C56 being (Function of ( QC-WFF F1() ) , F2()) such that L183: S1[ C56 , ( len ( @ C55 ) ) ] by L139;
L184: ( D11 . ( VERUM F1() ) ) = ( C56 . ( VERUM F1() ) ) by L181 , L182 , L183;
thus L185: ( D11 . ( VERUM F1() ) ) = F3() by L184 , L181 , L183;
let C57 being (Element of ( QC-WFF F1() ));
consider C58 being (Element of ( QC-WFF F1() )) such that L186: C58 = C57 and L187: (for B35 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B35 , ( len ( @ C58 ) ) ] implies ( D11 . C57 ) = ( B35 . C58 ))) by L171;
consider C59 being (Function of ( QC-WFF F1() ) , F2()) such that L188: S1[ C59 , ( len ( @ C58 ) ) ] by L139;
set D12 = ( the_scope_of C57 );
L189: (ex B36 being (Element of ( QC-WFF F1() )) st (B36 = D12 & (for B37 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B37 , ( len ( @ B36 ) ) ] implies ( D11 . D12 ) = ( B37 . B36 ))))) by L171;
L190: ( D11 . C57 ) = ( C59 . C57 ) by L186 , L187 , L188;
thus L191: (C57 is  atomic implies ( D11 . C57 ) = F4(C57)) by L190 , L186 , L188;
L192: (for B38 being (Element of ( NAT )) holds (B38 < ( len ( @ C57 ) ) implies S1[ C59 , B38 ]))
proof
let C60 being (Element of ( NAT ));
assume L193: C60 < ( len ( @ C57 ) );
let C61 being (Element of ( QC-WFF F1() ));
assume L194: ( len ( @ C61 ) ) <= C60;
L195: ( len ( @ C61 ) ) <= ( len ( @ C57 ) ) by L194 , L193 , XXREAL_0:2;
thus L196: thesis by L195 , L186 , L188;
end;
thus L197: (C57 is  negative implies ( D11 . C57 ) = F5(( D11 . ( the_argument_of C57 ) ) , C57))
proof
set D13 = ( the_argument_of C57 );
set D14 = ( len ( @ D13 ) );
L198: (ex B39 being (Element of ( QC-WFF F1() )) st (B39 = D13 & (for B40 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B40 , ( len ( @ B39 ) ) ] implies ( D11 . D13 ) = ( B40 . B39 ))))) by L171;
assume L199: C57 is  negative;
L200: D14 < ( len ( @ C57 ) ) by L199 , QC_LANG1:14;
L201: S1[ C59 , D14 ] by L200 , L192;
L202: ( D11 . D13 ) = ( C59 . D13 ) by L201 , L198;
thus L203: thesis by L202 , L186 , L188 , L190 , L199;
end;

thus L204: (C57 is  conjunctive implies ( D11 . C57 ) = F6(( D11 . ( the_left_argument_of C57 ) ) , ( D11 . ( the_right_argument_of C57 ) ) , C57))
proof
set D15 = ( the_right_argument_of C57 );
set D16 = ( the_left_argument_of C57 );
set D17 = ( len ( @ D16 ) );
set D18 = ( len ( @ D15 ) );
L205: (ex B41 being (Element of ( QC-WFF F1() )) st (B41 = D15 & (for B42 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B42 , ( len ( @ B41 ) ) ] implies ( D11 . D15 ) = ( B42 . B41 ))))) by L171;
assume L206: C57 is  conjunctive;
L207: D17 < ( len ( @ C57 ) ) by L206 , QC_LANG1:15;
L208: S1[ C59 , D17 ] by L207 , L192;
L209: D18 < ( len ( @ C57 ) ) by L206 , QC_LANG1:15;
L210: S1[ C59 , D18 ] by L209 , L192;
L211: ( D11 . D15 ) = ( C59 . D15 ) by L210 , L205;
L212: (ex B43 being (Element of ( QC-WFF F1() )) st (B43 = D16 & (for B44 being (Function of ( QC-WFF F1() ) , F2()) holds (S1[ B44 , ( len ( @ B43 ) ) ] implies ( D11 . D16 ) = ( B44 . B43 ))))) by L171;
L213: ( D11 . D16 ) = ( C59 . D16 ) by L212 , L208;
thus L214: thesis by L213 , L186 , L188 , L190 , L206 , L211;
end;

set D19 = ( len ( @ D12 ) );
assume L215: C57 is  universal;
L216: D19 < ( len ( @ C57 ) ) by L215 , QC_LANG1:16;
L217: S1[ C59 , D19 ] by L216 , L192;
L218: ( D11 . D12 ) = ( C59 . D12 ) by L217 , L189;
thus L219: thesis by L218 , L186 , L188 , L190 , L215;
end;
scheme CQCF2FuncEx { F8() -> QC-alphabet , F9 , F10() -> non  empty set , F11() -> (Element of ( Funcs (F9() , F10()) )) , F12(set , set , set) -> (Element of ( Funcs (F9() , F10()) )) , F13(set , set) -> (Element of ( Funcs (F9() , F10()) )) , F14(set , set , set , set) -> (Element of ( Funcs (F9() , F10()) )) , F15(set , set , set) -> (Element of ( Funcs (F9() , F10()) )) } : (ex B45 being (Function of ( CQC-WFF F8() ) , ( Funcs (F9() , F10()) )) st (( B45 . ( VERUM F8() ) ) = F11() & (for R4 being (Element of ( NAT )) holds (for B46 being (CQC-variable_list of R4 , F8()) holds (for B47 being (QC-pred_symbol of R4 , F8()) holds ( B45 . ( B47 ! B46 ) ) = F12(R4 , B47 , B46)))) & (for B48 , B49 being (Element of ( CQC-WFF F8() )) holds (for B50 being (Element of ( bound_QC-variables F8() )) holds (( B45 . ( 'not' B48 ) ) = F13(( B45 . B48 ) , B48) & ( B45 . ( B48 '&' B49 ) ) = F14(( B45 . B48 ) , ( B45 . B49 ) , B48 , B49) & ( B45 . ( All (B50 , B48) ) ) = F15(B50 , ( B45 . B48 ) , B48))))))
proof
deffunc H1(set , (Element of ( QC-WFF F8() ))) = F15(( bound_in $2 ) , $1 , ( the_scope_of $2 ));
deffunc H2(set , set , (Element of ( QC-WFF F8() ))) = F14($1 , $2 , ( the_left_argument_of $3 ) , ( the_right_argument_of $3 ));
deffunc H3(set , (Element of ( QC-WFF F8() ))) = F13($1 , ( the_argument_of $2 ));
deffunc H4((Element of ( QC-WFF F8() ))) = F12(( the_arity_of ( the_pred_symbol_of $1 ) ) , ( the_pred_symbol_of $1 ) , ( the_arguments_of $1 ));
consider C62 being (Function of ( QC-WFF F8() ) , ( Funcs (F9() , F10()) )) such that L220: (( C62 . ( VERUM F8() ) ) = F11() & (for B51 being (Element of ( QC-WFF F8() )) holds ((B51 is  atomic implies ( C62 . B51 ) = H4(B51)) & (B51 is  negative implies ( C62 . B51 ) = H3(( C62 . ( the_argument_of B51 ) ) , B51)) & (B51 is  conjunctive implies ( C62 . B51 ) = H2(( C62 . ( the_left_argument_of B51 ) ) , ( C62 . ( the_right_argument_of B51 ) ) , B51)) & (B51 is  universal implies ( C62 . B51 ) = H1(( C62 . ( the_scope_of B51 ) ) , B51))))) from QCFuncExN;
reconsider D20 = ( C62 | ( CQC-WFF F8() ) ) as (Function of ( CQC-WFF F8() ) , ( Funcs (F9() , F10()) )) by FUNCT_2:32;
take D20;
thus L221: ( D20 . ( VERUM F8() ) ) = F11() by L220 , FUNCT_1:49;
thus L222: (for R4 being (Element of ( NAT )) holds (for B52 being (CQC-variable_list of R4 , F8()) holds (for B53 being (QC-pred_symbol of R4 , F8()) holds ( D20 . ( B53 ! B52 ) ) = F12(R4 , B53 , B52))))
proof
let R4 being (Element of ( NAT ));
let C63 being (CQC-variable_list of R4 , F8());
let C64 being (QC-pred_symbol of R4 , F8());
L223: ( the_arity_of C64 ) = R4 by QC_LANG1:11;
L224: ( C64 ! C63 ) is  atomic by QC_LANG1:def 18;
L225: ( the_arguments_of ( C64 ! C63 ) ) = C63 by L224 , QC_LANG1:def 23;
L226: ( the_pred_symbol_of ( C64 ! C63 ) ) = C64 by L224 , QC_LANG1:def 22;
thus L227: ( D20 . ( C64 ! C63 ) ) = ( C62 . ( C64 ! C63 ) ) by FUNCT_1:49
.= F12(R4 , C64 , C63) by L220 , L224 , L225 , L226 , L223;
end;

let C65 , C66 being (Element of ( CQC-WFF F8() ));
let C67 being (Element of ( bound_QC-variables F8() ));
set D21 = ( D20 . C65 );
set D22 = ( D20 . C66 );
L228: D21 = ( C62 . C65 ) by FUNCT_1:49;
L229: ( 'not' C65 ) is  negative by QC_LANG1:def 19;
L230: ( the_argument_of ( 'not' C65 ) ) = C65 by L229 , QC_LANG1:def 24;
thus L231: ( D20 . ( 'not' C65 ) ) = ( C62 . ( 'not' C65 ) ) by FUNCT_1:49
.= F13(D21 , C65) by L220 , L228 , L229 , L230;
L232: D22 = ( C62 . C66 ) by FUNCT_1:49;
L233: ( C65 '&' C66 ) is  conjunctive by QC_LANG1:def 20;
L234: ( the_left_argument_of ( C65 '&' C66 ) ) = C65 by L233 , QC_LANG1:def 25;
L235: ( the_right_argument_of ( C65 '&' C66 ) ) = C66 by L233 , QC_LANG1:def 26;
thus L236: ( D20 . ( C65 '&' C66 ) ) = ( C62 . ( C65 '&' C66 ) ) by FUNCT_1:49
.= F14(D21 , D22 , C65 , C66) by L220 , L228 , L232 , L233 , L234 , L235;
L237: ( All (C67 , C65) ) is  universal by QC_LANG1:def 21;
L238: ( bound_in ( All (C67 , C65) ) ) = C67 by L237 , QC_LANG1:def 27;
L239: ( the_scope_of ( All (C67 , C65) ) ) = C65 by L237 , QC_LANG1:def 28;
thus L240: ( D20 . ( All (C67 , C65) ) ) = ( C62 . ( All (C67 , C65) ) ) by FUNCT_1:49
.= F15(C67 , D21 , C65) by L220 , L228 , L237 , L238 , L239;
end;
scheme CQCF2FUniq { F16() -> QC-alphabet , F17 , F18() -> non  empty set , F19 , F20() -> (Function of ( CQC-WFF F16() ) , ( Funcs (F17() , F18()) )) , F21() -> (Function of F17() , F18()) , F22(set , set , set) -> (Function of F17() , F18()) , F23(set , set) -> (Function of F17() , F18()) , F24(set , set , set , set) -> (Function of F17() , F18()) , F25(set , set , set) -> (Function of F17() , F18()) } : F19() = F20()
provided
L241: ( F19() . ( VERUM F16() ) ) = F21()
and
L242: (for R4 being (Element of ( NAT )) holds (for B54 being (CQC-variable_list of R4 , F16()) holds (for B55 being (QC-pred_symbol of R4 , F16()) holds ( F19() . ( B55 ! B54 ) ) = F22(R4 , B55 , B54))))
and
L243: (for B56 , B57 being (Element of ( CQC-WFF F16() )) holds (for B58 being (Element of ( bound_QC-variables F16() )) holds (( F19() . ( 'not' B56 ) ) = F23(( F19() . B56 ) , B56) & ( F19() . ( B56 '&' B57 ) ) = F24(( F19() . B56 ) , ( F19() . B57 ) , B56 , B57) & ( F19() . ( All (B58 , B56) ) ) = F25(B58 , ( F19() . B56 ) , B56))))
and
L244: ( F20() . ( VERUM F16() ) ) = F21()
and
L245: (for R4 being (Element of ( NAT )) holds (for B59 being (CQC-variable_list of R4 , F16()) holds (for B60 being (QC-pred_symbol of R4 , F16()) holds ( F20() . ( B60 ! B59 ) ) = F22(R4 , B60 , B59))))
and
L246: (for B61 , B62 being (Element of ( CQC-WFF F16() )) holds (for B63 being (Element of ( bound_QC-variables F16() )) holds (( F20() . ( 'not' B61 ) ) = F23(( F20() . B61 ) , B61) & ( F20() . ( B61 '&' B62 ) ) = F24(( F20() . B61 ) , ( F20() . B62 ) , B61 , B62) & ( F20() . ( All (B63 , B61) ) ) = F25(B63 , ( F20() . B61 ) , B61))))
proof
defpred S7[ set ] means ( F19() . $1 ) = ( F20() . $1 );
L247: (for B64 , B65 being (Element of ( CQC-WFF F16() )) holds (for B66 being (bound_QC-variable of F16()) holds (for B67 being (Element of ( NAT )) holds (for B68 being (CQC-variable_list of B67 , F16()) holds (for B69 being (QC-pred_symbol of B67 , F16()) holds (S7[ ( VERUM F16() ) ] & S7[ ( B69 ! B68 ) ] & (S7[ B64 ] implies S7[ ( 'not' B64 ) ]) & ((S7[ B64 ] & S7[ B65 ]) implies S7[ ( B64 '&' B65 ) ]) & (S7[ B64 ] implies S7[ ( All (B66 , B64) ) ])))))))
proof
let C68 , C69 being (Element of ( CQC-WFF F16() ));
let C70 being (Element of ( bound_QC-variables F16() ));
let C71 being (Element of ( NAT ));
let C72 being (CQC-variable_list of C71 , F16());
let C73 being (QC-pred_symbol of C71 , F16());
thus L248: ( F19() . ( VERUM F16() ) ) = ( F20() . ( VERUM F16() ) ) by L241 , L244;
L249: ( F19() . ( C73 ! C72 ) ) = F22(C71 , C73 , C72) by L242;
thus L250: ( F19() . ( C73 ! C72 ) ) = ( F20() . ( C73 ! C72 ) ) by L249 , L245;
L251: ( F19() . ( 'not' C68 ) ) = F23(( F19() . C68 ) , C68) by L243;
thus L252: (( F19() . C68 ) = ( F20() . C68 ) implies ( F19() . ( 'not' C68 ) ) = ( F20() . ( 'not' C68 ) )) by L251 , L246;
L253: ( F19() . ( C68 '&' C69 ) ) = F24(( F19() . C68 ) , ( F19() . C69 ) , C68 , C69) by L243;
thus L254: ((( F19() . C68 ) = ( F20() . C68 ) & ( F19() . C69 ) = ( F20() . C69 )) implies ( F19() . ( C68 '&' C69 ) ) = ( F20() . ( C68 '&' C69 ) )) by L253 , L246;
L255: ( F19() . ( All (C70 , C68) ) ) = F25(C70 , ( F19() . C68 ) , C68) by L243;
thus L256: thesis by L255 , L246;
end;
L257: (for B70 being (Element of ( CQC-WFF F16() )) holds S7[ B70 ]) from CQC_LANG:sch 1(L247);
thus L258: thesis by L257 , FUNCT_2:63;
end;
theorem
L259: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds R16 is_subformula_of ( 'not' R16 )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L260: R16 is_proper_subformula_of ( 'not' R16 ) by QC_LANG2:66;
thus L261: thesis by L260 , QC_LANG2:def 21;
end;
theorem
L262: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (R16 is_subformula_of ( R16 '&' R17 ) & R17 is_subformula_of ( R16 '&' R17 )))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
L263: R17 is_proper_subformula_of ( R16 '&' R17 ) by QC_LANG2:69;
L264: R16 is_proper_subformula_of ( R16 '&' R17 ) by QC_LANG2:69;
thus L265: thesis by L264 , L263 , QC_LANG2:def 21;
end;
theorem
L266: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds R16 is_subformula_of ( All (R20 , R16) ))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
L267: R16 is_proper_subformula_of ( All (R20 , R16) ) by QC_LANG2:71;
thus L268: thesis by L267 , QC_LANG2:def 21;
end;
theorem
L269: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for B71 being (CQC-variable_list of R4 , R1) holds (for R2 being (Element of ( NAT )) holds ((1 <= R2 & R2 <= ( len B71 )) implies ( B71 . R2 ) in ( bound_QC-variables R1 ))))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C74 being (CQC-variable_list of R4 , R1);
let R2 being (Element of ( NAT ));
assume that
L270: 1 <= R2
and
L271: R2 <= ( len C74 );
L272: R2 in ( dom C74 ) by L270 , L271 , FINSEQ_3:25;
L273: ( C74 . R2 ) in ( rng C74 ) by L272 , FUNCT_1:def 3;
L274: ( rng C74 ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
thus L275: thesis by L274 , L273;
end;
definition
let R1 being QC-alphabet;
let C75 being non  empty set;
let C76 being (Function of C75 , ( CQC-WFF R1 ));
func NEGATIVE C76 -> (Element of ( Funcs (C75 , ( CQC-WFF R1 )) )) means 
:L276: (for B72 being (Element of C75) holds (for B73 being (Element of ( CQC-WFF R1 )) holds (B73 = ( C76 . B72 ) implies ( it . B72 ) = ( 'not' B73 ))));
existence
proof
defpred S8[ set , set ] means (for B74 being (Element of ( CQC-WFF R1 )) holds (B74 = ( C76 . $1 ) implies $2 = ( 'not' B74 )));
L277: (for B75 being (Element of C75) holds (ex B76 being (Element of ( CQC-WFF R1 )) st S8[ B75 , B76 ]))
proof
let C77 being (Element of C75);
reconsider D23 = ( C76 . C77 ) as (Element of ( CQC-WFF R1 ));
take ( 'not' D23 );
thus L278: thesis;
end;
consider C78 being (Function of C75 , ( CQC-WFF R1 )) such that L279: (for B77 being (Element of C75) holds S8[ B77 , ( C78 . B77 ) ]) from FUNCT_2:sch 3(L277);
L280: C78 is (Element of ( Funcs (C75 , ( CQC-WFF R1 )) )) by FUNCT_2:8;
thus L281: thesis by L280 , L279;
end;
uniqueness
proof
let C79 , C80 being (Element of ( Funcs (C75 , ( CQC-WFF R1 )) ));
assume L282: (for B78 being (Element of C75) holds (for B79 being (Element of ( CQC-WFF R1 )) holds (B79 = ( C76 . B78 ) implies ( C79 . B78 ) = ( 'not' B79 ))));
assume L283: (for B80 being (Element of C75) holds (for B81 being (Element of ( CQC-WFF R1 )) holds (B81 = ( C76 . B80 ) implies ( C80 . B80 ) = ( 'not' B81 ))));
L284: (for B82 being (Element of C75) holds ( C79 . B82 ) = ( C80 . B82 ))
proof
let C81 being (Element of C75);
consider R16 being (Element of ( CQC-WFF R1 )) such that L285: R16 = ( C76 . C81 );
thus L286: ( C79 . C81 ) = ( 'not' R16 ) by L282 , L285
.= ( C80 . C81 ) by L283 , L285;
end;
thus L287: C79 = C80 by L284 , FUNCT_2:63;
end;
end;
definition
let R1 being QC-alphabet;
let C82 , C83 being (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 ));
let R7 being (Element of ( NAT ));
func CON (C82 , C83 , R7) -> (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) means 
:L289: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds ((R16 = ( C82 . (R11 , R24) ) & R17 = ( C83 . (( R11 + R7 ) , R24) )) implies ( it . (R11 , R24) ) = ( R16 '&' R17 ))))));
existence
proof
defpred S9[ (Element of ( QC-symbols R1 )) , set , set ] means (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds ((R16 = ( C82 . [ $1 , $2 ] ) & R17 = ( C83 . [ ( $1 + R7 ) , $2 ] )) implies $3 = ( R16 '&' R17 ))));
L290: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (ex B83 being (Element of ( CQC-WFF R1 )) st S9[ R11 , R24 , B83 ])))
proof
let R11 being (QC-symbol of R1);
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
reconsider D24 = ( C82 . [ R11 , R24 ] ) as (Element of ( CQC-WFF R1 ));
reconsider D25 = ( C83 . [ ( R11 + R7 ) , R24 ] ) as (Element of ( CQC-WFF R1 ));
take ( D24 '&' D25 );
let C84 , C85 being (Element of ( CQC-WFF R1 ));
assume that
L291: C84 = ( C82 . [ R11 , R24 ] )
and
L292: C85 = ( C83 . [ ( R11 + R7 ) , R24 ] );
thus L293: thesis by L291 , L292;
end;
consider C86 being (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) such that L294: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds S9[ R11 , R24 , ( C86 . (R11 , R24) ) ])) from BINOP_1:sch 3(L290);
reconsider D26 = C86 as (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) by FUNCT_2:8;
take D26;
let R11 being (QC-symbol of R1);
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
assume that
L295: R16 = ( C82 . (R11 , R24) )
and
L296: R17 = ( C83 . (( R11 + R7 ) , R24) );
thus L297: thesis by L294 , L295 , L296;
end;
uniqueness
proof
let C87 , C88 being (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ));
assume L298: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds ((R16 = ( C82 . (R11 , R24) ) & R17 = ( C83 . (( R11 + R7 ) , R24) )) implies ( C87 . (R11 , R24) ) = ( R16 '&' R17 ))))));
assume L299: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds ((R16 = ( C82 . (R11 , R24) ) & R17 = ( C83 . (( R11 + R7 ) , R24) )) implies ( C88 . (R11 , R24) ) = ( R16 '&' R17 ))))));
L300: (for B84 being (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) holds ( C87 . B84 ) = ( C88 . B84 ))
proof
let C89 being (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]);
consider C90 being (Element of ( QC-symbols R1 )), C91 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that L301: C89 = [ C90 , C91 ] by DOMAIN_1:1;
reconsider D27 = ( C83 . (( C90 + R7 ) , C91) ) as (Element of ( CQC-WFF R1 ));
reconsider D28 = ( C82 . (C90 , C91) ) as (Element of ( CQC-WFF R1 ));
L302: ( C87 . (C90 , C91) ) = ( D28 '&' D27 ) by L298
.= ( C88 . (C90 , C91) ) by L299;
thus L303: thesis by L302 , L301;
end;
thus L304: C87 = C88 by L300 , FUNCT_2:63;
end;
end;
L306: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ( R24 +* ( R20 .--> ( x. R11 ) ) ) is (Function of ( bound_QC-variables R1 ) , ( bound_QC-variables R1 ))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R20 being (Element of ( bound_QC-variables R1 ));
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
L307: ( rng ( R24 +* ( R20 .--> ( x. R11 ) ) ) ) c= ( ( rng R24 ) \/ ( rng ( R20 .--> ( x. R11 ) ) ) ) by FUNCT_4:17;
L308: ( rng ( R20 .--> ( x. R11 ) ) ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
L309: ( rng R24 ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
L310: ( ( rng R24 ) \/ ( rng ( R20 .--> ( x. R11 ) ) ) ) c= ( bound_QC-variables R1 ) by L309 , L308 , XBOOLE_1:8;
L311: ( dom ( R24 +* ( R20 .--> ( x. R11 ) ) ) ) = ( ( dom R24 ) \/ ( dom ( { R20 } --> ( x. R11 ) ) ) ) by FUNCT_4:def 1
.= ( ( dom R24 ) \/ { R20 } ) by FUNCOP_1:13
.= ( ( bound_QC-variables R1 ) \/ { R20 } ) by FUNCT_2:52
.= ( bound_QC-variables R1 ) by ZFMISC_1:40;
thus L312: thesis by L311 , L307 , L310 , FUNCT_2:2 , XBOOLE_1:1;
end;
definition
let R1 being QC-alphabet;
let C92 being (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 ));
let C93 being (bound_QC-variable of R1);
func UNIVERSAL (C93 , C92) -> (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) means 
:L313: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 = ( C92 . (( R11 ++ ) , ( R24 +* ( C93 .--> ( x. R11 ) ) )) ) implies ( it . (R11 , R24) ) = ( All (( x. R11 ) , R16) )))));
existence
proof
defpred S10[ (Element of ( QC-symbols R1 )) , (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) , set ] means (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 = ( C92 . [ ( $1 ++ ) , ( $2 +* ( { C93 } --> ( x. $1 ) ) ) ] ) implies $3 = ( All (( x. $1 ) , R16) )));
L314: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (ex B85 being (Element of ( CQC-WFF R1 )) st S10[ R11 , R24 , B85 ])))
proof
let R11 being (QC-symbol of R1);
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
reconsider D29 = ( R24 +* ( C93 .--> ( x. R11 ) ) ) as (Function of ( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) by L306;
reconsider D30 = D29 as (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) by FUNCT_2:8;
reconsider D31 = ( C92 . [ ( R11 ++ ) , D30 ] ) as (Element of ( CQC-WFF R1 ));
take ( All (( x. R11 ) , D31) );
thus L315: thesis;
end;
consider C94 being (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) such that L316: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds S10[ R11 , R24 , ( C94 . (R11 , R24) ) ])) from BINOP_1:sch 3(L314);
reconsider D32 = C94 as (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) by FUNCT_2:8;
take D32;
let R11 being (QC-symbol of R1);
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R16 being (Element of ( CQC-WFF R1 ));
assume L317: R16 = ( C92 . (( R11 ++ ) , ( R24 +* ( C93 .--> ( x. R11 ) ) )) );
thus L318: thesis by L317 , L316;
end;
uniqueness
proof
let C95 , C96 being (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ));
assume L319: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 = ( C92 . (( R11 ++ ) , ( R24 +* ( C93 .--> ( x. R11 ) ) )) ) implies ( C95 . (R11 , R24) ) = ( All (( x. R11 ) , R16) )))));
assume L320: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 = ( C92 . (( R11 ++ ) , ( R24 +* ( C93 .--> ( x. R11 ) ) )) ) implies ( C96 . (R11 , R24) ) = ( All (( x. R11 ) , R16) )))));
L321: (for B86 being (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) holds ( C95 . B86 ) = ( C96 . B86 ))
proof
let C97 being (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]);
consider C98 being (Element of ( QC-symbols R1 )), C99 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that L322: C97 = [ C98 , C99 ] by DOMAIN_1:1;
reconsider D33 = ( C99 +* ( C93 .--> ( x. C98 ) ) ) as (Function of ( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) by L306;
reconsider D34 = D33 as (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) by FUNCT_2:8;
reconsider D35 = ( C92 . (( C98 ++ ) , D34) ) as (Element of ( CQC-WFF R1 ));
L323: ( C95 . (C98 , C99) ) = ( All (( x. C98 ) , D35) ) by L319
.= ( C96 . (C98 , C99) ) by L320;
thus L324: thesis by L323 , L322;
end;
thus L325: C95 = C96 by L321 , FUNCT_2:63;
end;
end;
L327: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for B87 being (CQC-variable_list of R4 , R1) holds B87 is (FinSequence of ( bound_QC-variables R1 )))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C100 being (CQC-variable_list of R4 , R1);
L328: ( rng C100 ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
thus L329: thesis by L328 , FINSEQ_1:def 4;
end;
definition
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C101 being (CQC-variable_list of R4 , R1);
let C102 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
redefine func C102 * C101 -> (CQC-variable_list of R4 , R1);

coherence
proof
reconsider D36 = C101 as (FinSequence of ( bound_QC-variables R1 )) by L327;
reconsider D37 = ( C102 * D36 ) as (FinSequence of ( bound_QC-variables R1 )) by FINSEQ_2:32;
L330: ( len D37 ) = ( len D36 ) by FINSEQ_2:33
.= R4 by CARD_1:def 7;
thus L331: thesis by L330 , CARD_1:def 7 , FINSEQ_2:24;
end;
end;
definition
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C103 being (QC-pred_symbol of R4 , R1);
let C104 being (CQC-variable_list of R4 , R1);
func ATOMIC (C103 , C104) -> (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) means 
:L333: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ( it . (R11 , R24) ) = ( C103 ! ( R24 * C104 ) )));
existence
proof
deffunc H5(set , (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ))) = ( C103 ! ( $2 * C104 ) );
consider C105 being (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) such that L334: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ( C105 . (R11 , R24) ) = H5(R11 , R24))) from BINOP_1:sch 4;
L335: C105 is (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) by FUNCT_2:8;
thus L336: thesis by L335 , L334;
end;
uniqueness
proof
let C106 , C107 being (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ));
assume L337: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ( C106 . (R11 , R24) ) = ( C103 ! ( R24 * C104 ) )));
assume L338: (for R11 being (QC-symbol of R1) holds (for R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ( C107 . (R11 , R24) ) = ( C103 ! ( R24 * C104 ) )));
L339: (for B88 being (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) holds ( C106 . B88 ) = ( C107 . B88 ))
proof
let C108 being (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]);
consider C109 being (Element of ( QC-symbols R1 )), C110 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that L340: C108 = [ C109 , C110 ] by DOMAIN_1:1;
L341: ( C106 . (C109 , C110) ) = ( C103 ! ( C110 * C104 ) ) by L337
.= ( C107 . (C109 , C110) ) by L338;
thus L342: thesis by L341 , L340;
end;
thus L343: C106 = C107 by L339 , FUNCT_2:63;
end;
end;
deffunc H6(set , set , set) = ( 0 );
deffunc H7((Element of ( NAT ))) = $1;
deffunc H8((Element of ( NAT )) , (Element of ( NAT ))) = ( $1 + $2 );
deffunc H9(set , (Element of ( NAT ))) = ( $2 + 1 );
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
func QuantNbr R16 -> (Element of ( NAT )) means 
:L345: (ex B89 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (it = ( B89 . R16 ) & ( B89 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B90 being (CQC-variable_list of R4 , R1) holds (for B91 being (QC-pred_symbol of R4 , R1) holds (( B89 . ( B91 ! B90 ) ) = ( 0 ) & ( B89 . ( 'not' R18 ) ) = ( B89 . R18 ) & ( B89 . ( R18 '&' R19 ) ) = ( ( B89 . R18 ) + ( B89 . R19 ) ) & ( B89 . ( All (R20 , R18) ) ) = ( ( B89 . R18 ) + 1 ))))))))));
correctness
proof
thus L346: ((ex B92 being (Element of ( NAT )) st (ex B93 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B92 = ( B93 . R16 ) & ( B93 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B94 being (CQC-variable_list of R4 , R1) holds (for B95 being (QC-pred_symbol of R4 , R1) holds (( B93 . ( B95 ! B94 ) ) = H6(R4 , B95 , B94) & ( B93 . ( 'not' R18 ) ) = H7(( B93 . R18 )) & ( B93 . ( R18 '&' R19 ) ) = H8(( B93 . R18 ) , ( B93 . R19 )) & ( B93 . ( All (R20 , R18) ) ) = H9(R20 , ( B93 . R18 )))))))))))) & (for B96 , B97 being (Element of ( NAT )) holds (((ex B98 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B96 = ( B98 . R16 ) & ( B98 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B99 being (CQC-variable_list of R4 , R1) holds (for B100 being (QC-pred_symbol of R4 , R1) holds (( B98 . ( B100 ! B99 ) ) = H6(R4 , B100 , B99) & ( B98 . ( 'not' R18 ) ) = H7(( B98 . R18 )) & ( B98 . ( R18 '&' R19 ) ) = H8(( B98 . R18 ) , ( B98 . R19 )) & ( B98 . ( All (R20 , R18) ) ) = H9(R20 , ( B98 . R18 ))))))))))) & (ex B101 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B97 = ( B101 . R16 ) & ( B101 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B102 being (CQC-variable_list of R4 , R1) holds (for B103 being (QC-pred_symbol of R4 , R1) holds (( B101 . ( B103 ! B102 ) ) = H6(R4 , B103 , B102) & ( B101 . ( 'not' R18 ) ) = H7(( B101 . R18 )) & ( B101 . ( R18 '&' R19 ) ) = H8(( B101 . R18 ) , ( B101 . R19 )) & ( B101 . ( All (R20 , R18) ) ) = H9(R20 , ( B101 . R18 )))))))))))) implies B96 = B97))) from CQC_LANG:sch 4;
end;
end;
definition
let R1 being QC-alphabet;
let C111 being (Function of ( CQC-WFF R1 ) , ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ));
let C112 being (Element of ( CQC-WFF R1 ));
redefine func C111 . C112 -> (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ));

coherence
proof
thus L348: ( C111 . C112 ) is (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ));
end;
end;
definition
let R1 being QC-alphabet;
func SepFunc R1 -> (Function of ( CQC-WFF R1 ) , ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) )) means 
:L350: (( it . ( VERUM R1 ) ) = ( [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] --> ( VERUM R1 ) ) & (for R4 being (Element of ( NAT )) holds (for B104 being (CQC-variable_list of R4 , R1) holds (for B105 being (QC-pred_symbol of R4 , R1) holds ( it . ( B105 ! B104 ) ) = ( ATOMIC (B105 , B104) )))) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (( it . ( 'not' R18 ) ) = ( NEGATIVE ( it . R18 ) ) & ( it . ( R18 '&' R19 ) ) = ( CON (( it . R18 ) , ( it . R19 ) , ( QuantNbr R18 )) ) & ( it . ( All (R20 , R18) ) ) = ( UNIVERSAL (R20 , ( it . R18 )) ))))));
existence
proof
deffunc H10((Element of ( NAT )) , (QC-pred_symbol of $1 , R1) , (CQC-variable_list of $1 , R1)) = ( ATOMIC ($2 , $3) );
set D38 = [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :];
deffunc H11((Function of D38 , ( CQC-WFF R1 )) , set) = ( NEGATIVE $1 );
deffunc H12((Function of D38 , ( CQC-WFF R1 )) , (Function of D38 , ( CQC-WFF R1 )) , (Element of ( CQC-WFF R1 )) , set) = ( CON ($1 , $2 , ( QuantNbr $3 )) );
deffunc H13((Element of ( bound_QC-variables R1 )) , (Function of D38 , ( CQC-WFF R1 )) , set) = ( UNIVERSAL ($1 , $2) );
reconsider D39 = ( D38 --> ( VERUM R1 ) ) as (Function of D38 , ( CQC-WFF R1 ));
reconsider D40 = D39 as (Element of ( Funcs (D38 , ( CQC-WFF R1 )) )) by FUNCT_2:8;
consider C113 being (Function of ( CQC-WFF R1 ) , ( Funcs (D38 , ( CQC-WFF R1 )) )) such that L351: ( C113 . ( VERUM R1 ) ) = D40 and L352: (for R4 being (Element of ( NAT )) holds (for B106 being (CQC-variable_list of R4 , R1) holds (for B107 being (QC-pred_symbol of R4 , R1) holds ( C113 . ( B107 ! B106 ) ) = H10(R4 , B107 , B106)))) and L353: (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (( C113 . ( 'not' R18 ) ) = H11(( C113 . R18 ) , R18) & ( C113 . ( R18 '&' R19 ) ) = H12(( C113 . R18 ) , ( C113 . R19 ) , R18 , R19) & ( C113 . ( All (R20 , R18) ) ) = H13(R20 , ( C113 . R18 ) , R18))))) from CQCF2FuncEx;
take C113;
thus L354: thesis by L351 , L352 , L353;
end;
uniqueness
proof
deffunc H14((Element of ( NAT )) , (QC-pred_symbol of $1 , R1) , (CQC-variable_list of $1 , R1)) = ( ATOMIC ($2 , $3) );
set D41 = [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :];
deffunc H15((Function of D41 , ( CQC-WFF R1 )) , set) = ( NEGATIVE $1 );
deffunc H16((Function of D41 , ( CQC-WFF R1 )) , (Function of D41 , ( CQC-WFF R1 )) , (Element of ( CQC-WFF R1 )) , set) = ( CON ($1 , $2 , ( QuantNbr $3 )) );
deffunc H17((Element of ( bound_QC-variables R1 )) , (Function of D41 , ( CQC-WFF R1 )) , set) = ( UNIVERSAL ($1 , $2) );
reconsider D42 = ( D41 --> ( VERUM R1 ) ) as (Function of D41 , ( CQC-WFF R1 ));
let C114 , C115 being (Function of ( CQC-WFF R1 ) , ( Funcs (D41 , ( CQC-WFF R1 )) ));
assume that
L355: ( C114 . ( VERUM R1 ) ) = ( D41 --> ( VERUM R1 ) )
and
L356: (for R4 being (Element of ( NAT )) holds (for R21 being (CQC-variable_list of R4 , R1) holds (for R22 being (QC-pred_symbol of R4 , R1) holds ( C114 . ( R22 ! R21 ) ) = H14(R4 , R22 , R21))))
and
L357: (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (( C114 . ( 'not' R18 ) ) = H15(( C114 . R18 ) , R18) & ( C114 . ( R18 '&' R19 ) ) = H16(( C114 . R18 ) , ( C114 . R19 ) , R18 , R19) & ( C114 . ( All (R20 , R18) ) ) = H17(R20 , ( C114 . R18 ) , R18)))))
and
L358: ( C115 . ( VERUM R1 ) ) = ( D41 --> ( VERUM R1 ) )
and
L359: (for R4 being (Element of ( NAT )) holds (for R21 being (CQC-variable_list of R4 , R1) holds (for R22 being (QC-pred_symbol of R4 , R1) holds ( C115 . ( R22 ! R21 ) ) = H14(R4 , R22 , R21))))
and
L360: (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (( C115 . ( 'not' R18 ) ) = H15(( C115 . R18 ) , R18) & ( C115 . ( R18 '&' R19 ) ) = H16(( C115 . R18 ) , ( C115 . R19 ) , R18 , R19) & ( C115 . ( All (R20 , R18) ) ) = H17(R20 , ( C115 . R18 ) , R18)))));
L361: ( C115 . ( VERUM R1 ) ) = D42 by L358;
L362: ( C114 . ( VERUM R1 ) ) = D42 by L355;
thus L363: C114 = C115 from CQCF2FUniq(L362 , L356 , L357 , L361 , L359 , L360);
end;
end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R11 being (QC-symbol of R1);
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
func SepFunc (R16 , R11 , R23) -> (Element of ( CQC-WFF R1 )) equals 
( ( ( SepFunc R1 ) . R16 ) . [ R11 , R23 ] );
correctness;
end;
theorem
L366: (for R1 being QC-alphabet holds ( QuantNbr ( VERUM R1 ) ) = ( 0 ))
proof
let R1 being QC-alphabet;
deffunc H18((Element of ( CQC-WFF R1 ))) = ( QuantNbr $1 );
L367: (for R16 being (Element of ( CQC-WFF R1 )) holds (for B108 being (Element of ( NAT )) holds (B108 = H18(R16) iff (ex B109 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B108 = ( B109 . R16 ) & ( B109 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B110 being (CQC-variable_list of R4 , R1) holds (for B111 being (QC-pred_symbol of R4 , R1) holds (( B109 . ( B111 ! B110 ) ) = H6(R4 , B111 , B110) & ( B109 . ( 'not' R18 ) ) = H7(( B109 . R18 )) & ( B109 . ( R18 '&' R19 ) ) = H8(( B109 . R18 ) , ( B109 . R19 )) & ( B109 . ( All (R20 , R18) ) ) = H9(R20 , ( B109 . R18 )))))))))))))) by L345;
thus L368: H18(( VERUM R1 )) = ( 0 ) from CQC_LANG:sch 5(L367);
end;
theorem
L369: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R21 being (CQC-variable_list of R4 , R1) holds (for R22 being (QC-pred_symbol of R4 , R1) holds ( QuantNbr ( R22 ! R21 ) ) = ( 0 )))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R21 being (CQC-variable_list of R4 , R1);
let R22 being (QC-pred_symbol of R4 , R1);
deffunc H19((Element of ( CQC-WFF R1 ))) = ( QuantNbr $1 );
L370: (for R16 being (Element of ( CQC-WFF R1 )) holds (for B112 being (Element of ( NAT )) holds (B112 = H19(R16) iff (ex B113 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B112 = ( B113 . R16 ) & ( B113 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B114 being (CQC-variable_list of R4 , R1) holds (for B115 being (QC-pred_symbol of R4 , R1) holds (( B113 . ( B115 ! B114 ) ) = H6(R4 , B115 , B114) & ( B113 . ( 'not' R18 ) ) = H7(( B113 . R18 )) & ( B113 . ( R18 '&' R19 ) ) = H8(( B113 . R18 ) , ( B113 . R19 )) & ( B113 . ( All (R20 , R18) ) ) = H9(R20 , ( B113 . R18 )))))))))))))) by L345;
thus L371: H19(( R22 ! R21 )) = H6(R4 , R22 , R21) from CQC_LANG:sch 6(L370);
end;
theorem
L372: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds ( QuantNbr ( 'not' R16 ) ) = ( QuantNbr R16 )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
deffunc H20((Element of ( CQC-WFF R1 ))) = ( QuantNbr $1 );
L373: (for B116 being (Element of ( CQC-WFF R1 )) holds (for B117 being (Element of ( NAT )) holds (B117 = H20(B116) iff (ex B118 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B117 = ( B118 . B116 ) & ( B118 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B119 being (CQC-variable_list of R4 , R1) holds (for B120 being (QC-pred_symbol of R4 , R1) holds (( B118 . ( B120 ! B119 ) ) = H6(R4 , B120 , B119) & ( B118 . ( 'not' R18 ) ) = H7(( B118 . R18 )) & ( B118 . ( R18 '&' R19 ) ) = H8(( B118 . R18 ) , ( B118 . R19 )) & ( B118 . ( All (R20 , R18) ) ) = H9(R20 , ( B118 . R18 )))))))))))))) by L345;
thus L374: H20(( 'not' R16 )) = H7(H20(R16)) from CQC_LANG:sch 7(L373);
end;
theorem
L375: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds ( QuantNbr ( R16 '&' R17 ) ) = ( ( QuantNbr R16 ) + ( QuantNbr R17 ) ))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
deffunc H21((Element of ( CQC-WFF R1 ))) = ( QuantNbr $1 );
L376: (for B121 being (Element of ( CQC-WFF R1 )) holds (for B122 being (Element of ( NAT )) holds (B122 = H21(B121) iff (ex B123 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B122 = ( B123 . B121 ) & ( B123 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B124 being (CQC-variable_list of R4 , R1) holds (for B125 being (QC-pred_symbol of R4 , R1) holds (( B123 . ( B125 ! B124 ) ) = H6(R4 , B125 , B124) & ( B123 . ( 'not' R18 ) ) = H7(( B123 . R18 )) & ( B123 . ( R18 '&' R19 ) ) = H8(( B123 . R18 ) , ( B123 . R19 )) & ( B123 . ( All (R20 , R18) ) ) = H9(R20 , ( B123 . R18 )))))))))))))) by L345;
thus L377: H21(( R16 '&' R17 )) = H8(H21(R16) , H21(R17)) from CQC_LANG:sch 8(L376);
end;
theorem
L378: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds ( QuantNbr ( All (R20 , R16) ) ) = ( ( QuantNbr R16 ) + 1 ))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
deffunc H22((Element of ( CQC-WFF R1 ))) = ( QuantNbr $1 );
L379: (for B126 being (Element of ( CQC-WFF R1 )) holds (for B127 being (Element of ( NAT )) holds (B127 = H22(B126) iff (ex B128 being (Function of ( CQC-WFF R1 ) , ( NAT )) st (B127 = ( B128 . B126 ) & ( B128 . ( VERUM R1 ) ) = ( 0 ) & (for R18 being (Element of ( CQC-WFF R1 )) holds (for R19 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R4 being (Element of ( NAT )) holds (for B129 being (CQC-variable_list of R4 , R1) holds (for B130 being (QC-pred_symbol of R4 , R1) holds (( B128 . ( B130 ! B129 ) ) = H6(R4 , B130 , B129) & ( B128 . ( 'not' R18 ) ) = H7(( B128 . R18 )) & ( B128 . ( R18 '&' R19 ) ) = H8(( B128 . R18 ) , ( B128 . R19 )) & ( B128 . ( All (R20 , R18) ) ) = H9(R20 , ( B128 . R18 )))))))))))))) by L345;
thus L380: H22(( All (R20 , R16) )) = H9(R20 , H22(R16)) from CQC_LANG:sch 9(L379);
end;
theorem
L381: (for R1 being QC-alphabet holds (for B131 being (Element of ( QC-WFF R1 )) holds ( still_not-bound_in B131 ) is  finite))
proof
let R1 being QC-alphabet;
defpred S11[ (Element of ( QC-WFF R1 )) ] means ( still_not-bound_in $1 ) is  finite;
L382: (for B132 being (Element of ( QC-WFF R1 )) holds ((B132 is  atomic implies S11[ B132 ]) & S11[ ( VERUM R1 ) ] & ((B132 is  negative & S11[ ( the_argument_of B132 ) ]) implies S11[ B132 ]) & ((B132 is  conjunctive & S11[ ( the_left_argument_of B132 ) ] & S11[ ( the_right_argument_of B132 ) ]) implies S11[ B132 ]) & ((B132 is  universal & S11[ ( the_scope_of B132 ) ]) implies S11[ B132 ])))
proof
let C116 being (Element of ( QC-WFF R1 ));
thus L383: (C116 is  atomic implies ( still_not-bound_in C116 ) is  finite)
proof
deffunc H23(set) = ( ( the_arguments_of C116 ) . $1 );
defpred S12[ (Element of ( NAT )) ] means (1 <= $1 & $1 <= ( len ( the_arguments_of C116 ) ));
defpred S13[ (Element of ( NAT )) ] means (1 <= $1 & $1 <= ( len ( the_arguments_of C116 ) ) & ( ( the_arguments_of C116 ) . $1 ) in ( bound_QC-variables R1 ));
L384: (for R4 being (Element of ( NAT )) holds (S13[ R4 ] implies S12[ R4 ]));
L385: { H23(R4) where R4 is (Element of ( NAT )) : S13[ R4 ] } c= { H23(R7) where R7 is (Element of ( NAT )) : S12[ R7 ] } from FRAENKEL:sch 1(L384);
assume L386: C116 is  atomic;
L387: ( still_not-bound_in C116 ) = ( still_not-bound_in ( the_arguments_of C116 ) ) by L386 , QC_LANG3:4
.= ( variables_in (( the_arguments_of C116 ) , ( bound_QC-variables R1 )) ) by QC_LANG3:2
.= { ( ( the_arguments_of C116 ) . R4 ) where R4 is (Element of ( NAT )) : (1 <= R4 & R4 <= ( len ( the_arguments_of C116 ) ) & ( ( the_arguments_of C116 ) . R4 ) in ( bound_QC-variables R1 )) };
L388: ( still_not-bound_in C116 ) c= ( rng ( the_arguments_of C116 ) ) by L387 , L385 , L108;
thus L389: thesis by L388;
end;

thus L390: ( still_not-bound_in ( VERUM R1 ) ) is  finite by QC_LANG3:3;
thus L391: ((C116 is  negative & ( still_not-bound_in ( the_argument_of C116 ) ) is  finite) implies ( still_not-bound_in C116 ) is  finite) by QC_LANG3:6;
thus L392: ((C116 is  conjunctive & ( still_not-bound_in ( the_left_argument_of C116 ) ) is  finite & ( still_not-bound_in ( the_right_argument_of C116 ) ) is  finite) implies ( still_not-bound_in C116 ) is  finite)
proof
assume that
L393: C116 is  conjunctive
and
L394: ( still_not-bound_in ( the_left_argument_of C116 ) ) is  finite
and
L395: ( still_not-bound_in ( the_right_argument_of C116 ) ) is  finite;
L396: ( still_not-bound_in C116 ) = ( ( still_not-bound_in ( the_left_argument_of C116 ) ) \/ ( still_not-bound_in ( the_right_argument_of C116 ) ) ) by L393 , QC_LANG3:9;
thus L397: thesis by L396 , L394 , L395;
end;

assume that
L398: C116 is  universal
and
L399: ( still_not-bound_in ( the_scope_of C116 ) ) is  finite;
L400: ( still_not-bound_in C116 ) = ( ( still_not-bound_in ( the_scope_of C116 ) ) \ { ( bound_in C116 ) } ) by L398 , QC_LANG3:11;
thus L401: thesis by L400 , L399;
end;
thus L402: (for B133 being (Element of ( QC-WFF R1 )) holds S11[ B133 ]) from QC_LANG1:sch 2(L382);
end;
scheme MaxFinDomElem { F26() -> non  empty set , F27() -> set , P1[set , set] } : (ex B134 being (Element of F26()) st (B134 in F27() & (for B135 being (Element of F26()) holds (B135 in F27() implies P1[ B134 , B135 ]))))
provided
L403: (F27() is  finite & F27() <> ( {} ) & F27() c= F26())
and
L404: (for B136 , B137 being (Element of F26()) holds (P1[ B136 , B137 ] or P1[ B137 , B136 ]))
and
L405: (for B138 , B139 , B140 being (Element of F26()) holds ((P1[ B138 , B139 ] & P1[ B139 , B140 ]) implies P1[ B138 , B140 ]))
proof
reconsider D43 = F27() as  finite set by L403;
L406: D43 <> ( {} ) by L403;
defpred S14[ set , set ] means ((not $1 in D43) or ($2 in D43 & P1[ $1 , $2 ]));
L407: (for B141 , B142 , B143 being set holds ((S14[ B141 , B142 ] & S14[ B142 , B143 ]) implies S14[ B141 , B143 ])) by L403 , L405;
L408: (for B144 , B145 being set holds (S14[ B144 , B145 ] or S14[ B145 , B144 ])) by L403 , L404;
consider C117 being set such that L409: C117 in D43 and L410: (for B146 being set holds (B146 in D43 implies S14[ C117 , B146 ])) from CARD_2:sch 2(L406 , L408 , L407);
reconsider D44 = C117 as (Element of F26()) by L403 , L409;
take D44;
thus L411: D44 in F27() by L409;
let C118 being (Element of F26());
assume L412: C118 in F27();
thus L413: thesis by L412 , L409 , L410;
end;
definition
let C119 being set;
redefine func id C119 -> (Element of ( Funcs (C119 , C119) ));

coherence
proof
L414: ( id C119 ) is (Function of C119 , C119);
thus L415: thesis by L414 , FUNCT_2:9;
end;
end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
func NBI R16 -> (Subset of ( QC-symbols R1 )) equals 
{ R11 where R11 is (QC-symbol of R1) : (for R12 being (QC-symbol of R1) holds (R11 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in R16 )))) };
coherence
proof
defpred S15[ (QC-symbol of R1) ] means (for R12 being (QC-symbol of R1) holds ($1 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in R16 ))));
L417: { R11 where R11 is (QC-symbol of R1) : S15[ R11 ] } c= ( QC-symbols R1 ) from FRAENKEL:sch 10;
thus L418: thesis by L417;
end;
end;
registration
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
cluster ( NBI R16 ) -> non  empty;
coherence
proof
set D45 = { R11 where R11 is (QC-symbol of R1) : (for R12 being (QC-symbol of R1) holds (R11 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in R16 )))) };
L420: (ex R11 being (QC-symbol of R1) st R11 in D45)
proof
L421:
now
per cases ;
suppose L422: ( still_not-bound_in R16 ) = ( {} );

L423: (for R12 being (QC-symbol of R1) holds (( 0 R1 ) <= R12 implies (not ( x. R12 ) in ( still_not-bound_in R16 )))) by L422;
L424: ( 0 R1 ) in { R11 where R11 is (QC-symbol of R1) : (for R12 being (QC-symbol of R1) holds (R11 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in R16 )))) } by L423;
thus L425: thesis by L424;
end;
suppose L426: ( still_not-bound_in R16 ) <> ( {} );

defpred S16[ (QC-symbol of R1) ] means ( x. $1 ) in ( still_not-bound_in R16 );
defpred S17[ set , set ] means (for R11 being (QC-symbol of R1) holds (R11 = $2 implies ( x. R11 ) = $1));
L427: { R11 where R11 is (QC-symbol of R1) : S16[ R11 ] } c= ( QC-symbols R1 ) from FRAENKEL:sch 10;
L428: (for R10 being set holds (R10 in ( still_not-bound_in R16 ) implies (ex R9 being set st (R9 in ( QC-symbols R1 ) & S17[ R10 , R9 ]))))
proof
let R10 being set;
assume L429: R10 in ( still_not-bound_in R16 );
reconsider D46 = R10 as (bound_QC-variable of R1) by L429;
consider R11 being (QC-symbol of R1) such that L430: ( x. R11 ) = D46 by QC_LANG3:30;
reconsider D47 = R11 as set;
take D47;
thus L431: thesis by L430;
end;
consider C120 being Function such that L432: (( dom C120 ) = ( still_not-bound_in R16 ) & ( rng C120 ) c= ( QC-symbols R1 )) and L433: (for R10 being set holds (R10 in ( still_not-bound_in R16 ) implies S17[ R10 , ( C120 . R10 ) ])) from FUNCT_1:sch 5(L428);
reconsider D48 = C120 as (Function of ( still_not-bound_in R16 ) , ( QC-symbols R1 )) by L432 , FUNCT_2:def 1 , RELSET_1:4;
set D49 = the (Element of ( still_not-bound_in R16 ));
reconsider D50 = D49 as (bound_QC-variable of R1) by L426 , TARSKI:def 3;
consider R11 being (QC-symbol of R1) such that L434: ( x. R11 ) = D50 by QC_LANG3:30;
L435: (ex R8 being set st R8 in { R15 where R15 is (QC-symbol of R1) : ( x. R15 ) in ( still_not-bound_in R16 ) })
proof
take R11;
thus L436: thesis by L426 , L434;
end;
defpred S18[ (QC-symbol of R1) , (QC-symbol of R1) ] means $2 <= $1;
L437: (for R11 being (QC-symbol of R1) holds (for R12 being (QC-symbol of R1) holds (S18[ R11 , R12 ] or S18[ R12 , R11 ]))) by QC_LANG1:24;
L438: (for R11 being (QC-symbol of R1) holds (for R12 being (QC-symbol of R1) holds (for R13 being (QC-symbol of R1) holds ((S18[ R11 , R12 ] & S18[ R12 , R13 ]) implies S18[ R11 , R13 ])))) by QC_LANG1:21;
L439: ( still_not-bound_in R16 ) is  finite by L381;
deffunc H24((bound_QC-variable of R1)) = ( x. $1 );
L440: { H24(B147) where B147 is (Element of ( bound_QC-variables R1 )) : B147 in ( still_not-bound_in R16 ) } is  finite from FRAENKEL:sch 21(L439);
L441: { ( x. B148 ) where B148 is (Element of ( bound_QC-variables R1 )) : B148 in ( still_not-bound_in R16 ) } = { R14 where R14 is (QC-symbol of R1) : ( x. R14 ) in ( still_not-bound_in R16 ) }
proof
set D51 = { ( x. B149 ) where B149 is (Element of ( bound_QC-variables R1 )) : B149 in ( still_not-bound_in R16 ) };
set D52 = { R14 where R14 is (QC-symbol of R1) : ( x. R14 ) in ( still_not-bound_in R16 ) };
L442: (for B150 being set holds (B150 in D51 implies B150 in D52))
proof
let C121 being set;
assume L443: C121 in D51;
consider C122 being (Element of ( bound_QC-variables R1 )) such that L444: (C121 = ( x. C122 ) & C122 in ( still_not-bound_in R16 )) by L443;
reconsider D53 = C121 as (QC-symbol of R1) by L444;
L445: ( x. D53 ) = C122 by L444 , L1;
thus L446: thesis by L445 , L444;
end;
thus L447: D51 c= D52 by L442 , TARSKI:def 3;
L448: (for B151 being set holds (B151 in D52 implies B151 in D51))
proof
let C123 being set;
assume L449: C123 in D52;
consider R14 being (QC-symbol of R1) such that L450: (C123 = R14 & ( x. R14 ) in ( still_not-bound_in R16 )) by L449;
L451: ( x. ( x. R14 ) ) = R14 by L1;
thus L452: thesis by L451 , L450;
end;
thus L453: D52 c= D51 by L448 , TARSKI:def 3;
end;
L454: ({ R14 where R14 is (QC-symbol of R1) : ( x. R14 ) in ( still_not-bound_in R16 ) } is  finite & { R15 where R15 is (QC-symbol of R1) : ( x. R15 ) in ( still_not-bound_in R16 ) } <> ( {} ) & { R13 where R13 is (QC-symbol of R1) : ( x. R13 ) in ( still_not-bound_in R16 ) } c= ( QC-symbols R1 )) by L441 , L440 , L427 , L435;
consider R13 being (QC-symbol of R1) such that L455: R13 in { R14 where R14 is (QC-symbol of R1) : ( x. R14 ) in ( still_not-bound_in R16 ) } and L456: (for R11 being (QC-symbol of R1) holds (R11 in { R15 where R15 is (QC-symbol of R1) : ( x. R15 ) in ( still_not-bound_in R16 ) } implies S18[ R13 , R11 ])) from MaxFinDomElem(L454 , L437 , L438);
L457:
now
take D54 = ( R13 ++ );
thus L458: D54 = ( R13 ++ );
let R15 being (QC-symbol of R1);
assume that
L459: ( R13 ++ ) <= R15
and
L460: ( x. R15 ) in ( still_not-bound_in R16 );
L461: R15 in { R14 where R14 is (QC-symbol of R1) : ( x. R14 ) in ( still_not-bound_in R16 ) } by L460;
L462: R15 <= R13 by L461 , L456;
L463: ( R13 ++ ) <= R13 by L462 , L459 , QC_LANG1:21;
L464: (not R13 < ( R13 ++ )) by L463 , QC_LANG1:25;
thus L465: contradiction by L464 , QC_LANG1:27;
end;
L466: ( R13 ++ ) in D45 by L457;
thus L467: thesis by L466;
end;
end;
thus L469: thesis by L421;
end;
thus L470: thesis by L420;
end;
end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
func index R16 -> (QC-symbol of R1) equals 
( min ( NBI R16 ) );
coherence;
end;
theorem
L473: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (( index R16 ) = ( 0 R1 ) iff R16 is  closed)))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
thus L474: (( index R16 ) = ( 0 R1 ) implies R16 is  closed)
proof
assume L475: ( index R16 ) = ( 0 R1 );
L476: ( 0 R1 ) in ( NBI R16 ) by L475 , QC_LANG1:def 35;
consider R11 being (QC-symbol of R1) such that L477: (R11 = ( 0 R1 ) & (for R12 being (QC-symbol of R1) holds (R11 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in R16 ))))) by L476;
L478:
now
set D55 = the (Element of ( still_not-bound_in R16 ));
assume L479: ( still_not-bound_in R16 ) <> ( {} );
reconsider D56 = D55 as (bound_QC-variable of R1) by L479 , TARSKI:def 3;
consider R12 being (QC-symbol of R1) such that L480: ( x. R12 ) = D56 by QC_LANG3:30;
L481: (not R11 <= R12) by L477 , L479 , L480;
thus L482: contradiction by L481 , L477 , QC_LANG1:def 36;
end;
thus L483: thesis by L478 , QC_LANG1:def 31;
end;

assume L484: R16 is  closed;
L485: (for R11 being (QC-symbol of R1) holds (( 0 R1 ) <= R11 implies (not ( x. R11 ) in ( still_not-bound_in R16 )))) by L484 , QC_LANG1:def 31;
L486: ( 0 R1 ) in ( NBI R16 ) by L485;
L487: ( 0 R1 ) = ( min ( NBI R16 ) )
proof
assume L488: ( min ( NBI R16 ) ) <> ( 0 R1 );
consider R11 being (QC-symbol of R1) such that L489: (( 0 R1 ) <> R11 & R11 = ( min ( NBI R16 ) )) by L488;
L490: R11 <= ( 0 R1 ) by L486 , L489 , QC_LANG1:def 35;
L491: R11 < ( 0 R1 ) by L490 , L489 , QC_LANG1:def 34;
L492: (not ( 0 R1 ) <= R11) by L491 , QC_LANG1:25;
thus L493: contradiction by L492 , QC_LANG1:def 36;
end;
thus L494: thesis by L487;
end;
theorem
L495: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (( x. R11 ) in ( still_not-bound_in R16 ) implies R11 < ( index R16 )))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
assume L496: ( x. R11 ) in ( still_not-bound_in R16 );
L497:
now
L498: ( min ( NBI R16 ) ) in ( NBI R16 ) by QC_LANG1:def 35;
L499: (ex R12 being (QC-symbol of R1) st (R12 = ( min ( NBI R16 ) ) & (for R11 being (QC-symbol of R1) holds (R12 <= R11 implies (not ( x. R11 ) in ( still_not-bound_in R16 )))))) by L498;
assume L500: ( min ( NBI R16 ) ) <= R11;
thus L501: contradiction by L500 , L496 , L499;
end;
thus L502: thesis by L497 , QC_LANG1:25;
end;
theorem
L503: (for R1 being QC-alphabet holds ( index ( VERUM R1 ) ) = ( 0 R1 ))
proof
let R1 being QC-alphabet;
L504: ( VERUM R1 ) is  closed by QC_LANG3:20;
thus L505: thesis by L504 , L473;
end;
theorem
L506: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds ( index ( 'not' R16 ) ) = ( index R16 )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L507: ( still_not-bound_in R16 ) = ( still_not-bound_in ( 'not' R16 ) ) by QC_LANG3:7;
thus L508: thesis by L507;
end;
theorem
L509: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (( index R16 ) <= ( index ( R16 '&' R17 ) ) & ( index R17 ) <= ( index ( R16 '&' R17 ) )))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
L510: ( still_not-bound_in ( R16 '&' R17 ) ) = ( ( still_not-bound_in R16 ) \/ ( still_not-bound_in R17 ) ) by QC_LANG3:10;
L511: ( NBI ( R16 '&' R17 ) ) c= ( NBI R17 )
proof
let C124 being set;
assume L512: C124 in ( NBI ( R16 '&' R17 ) );
consider R11 being (QC-symbol of R1) such that L513: R11 = C124 and L514: (for R12 being (QC-symbol of R1) holds (R11 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in ( R16 '&' R17 ) )))) by L512;
L515:
now
let R12 being (QC-symbol of R1);
assume L516: R11 <= R12;
L517: ( still_not-bound_in R17 ) c= ( still_not-bound_in ( R16 '&' R17 ) ) by L510 , XBOOLE_1:7;
thus L518: (not ( x. R12 ) in ( still_not-bound_in R17 )) by L517 , L514 , L516;
end;
thus L519: thesis by L515 , L513;
end;
L520: ( NBI ( R16 '&' R17 ) ) c= ( NBI R16 )
proof
let C125 being set;
assume L521: C125 in ( NBI ( R16 '&' R17 ) );
consider R11 being (QC-symbol of R1) such that L522: R11 = C125 and L523: (for R12 being (QC-symbol of R1) holds (R11 <= R12 implies (not ( x. R12 ) in ( still_not-bound_in ( R16 '&' R17 ) )))) by L521;
L524:
now
let R12 being (QC-symbol of R1);
assume L525: R11 <= R12;
L526: ( still_not-bound_in R16 ) c= ( still_not-bound_in ( R16 '&' R17 ) ) by L510 , XBOOLE_1:7;
thus L527: (not ( x. R12 ) in ( still_not-bound_in R16 )) by L526 , L523 , L525;
end;
thus L528: thesis by L524 , L522;
end;
thus L529: thesis by L520 , L511 , QC_LANG1:28;
end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
func SepVar R16 -> (Element of ( CQC-WFF R1 )) equals 
( SepFunc (R16 , ( index R16 ) , ( id ( bound_QC-variables R1 ) )) );
coherence;
end;
theorem
L531: (for R1 being QC-alphabet holds ( SepVar ( VERUM R1 ) ) = ( VERUM R1 ))
proof
let R1 being QC-alphabet;
L532: ( index ( VERUM R1 ) ) = ( 0 R1 ) by L503;
thus L533: ( SepVar ( VERUM R1 ) ) = ( ( [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] --> ( VERUM R1 ) ) . [ ( 0 R1 ) , ( id ( bound_QC-variables R1 ) ) ] ) by L532 , L350
.= ( VERUM R1 ) by FUNCOP_1:7;
end;
scheme CQCInd { F28() -> QC-alphabet , P2[set] } : (for B152 being (Element of ( CQC-WFF F28() )) holds P2[ B152 ])
provided
L534: P2[ ( VERUM F28() ) ]
and
L535: (for R4 being (Element of ( NAT )) holds (for B153 being (CQC-variable_list of R4 , F28()) holds (for B154 being (QC-pred_symbol of R4 , F28()) holds P2[ ( B154 ! B153 ) ])))
and
L536: (for B155 being (Element of ( CQC-WFF F28() )) holds (P2[ B155 ] implies P2[ ( 'not' B155 ) ]))
and
L537: (for B156 , B157 being (Element of ( CQC-WFF F28() )) holds ((P2[ B156 ] & P2[ B157 ]) implies P2[ ( B156 '&' B157 ) ]))
and
L538: (for B158 being (Element of ( CQC-WFF F28() )) holds (for B159 being (bound_QC-variable of F28()) holds (P2[ B158 ] implies P2[ ( All (B159 , B158) ) ])))
proof
L539: (for B160 , B161 being (Element of ( CQC-WFF F28() )) holds (for B162 being (bound_QC-variable of F28()) holds (for B163 being (Element of ( NAT )) holds (for B164 being (CQC-variable_list of B163 , F28()) holds (for B165 being (QC-pred_symbol of B163 , F28()) holds (P2[ ( VERUM F28() ) ] & P2[ ( B165 ! B164 ) ] & (P2[ B160 ] implies P2[ ( 'not' B160 ) ]) & ((P2[ B160 ] & P2[ B161 ]) implies P2[ ( B160 '&' B161 ) ]) & (P2[ B160 ] implies P2[ ( All (B162 , B160) ) ]))))))) by L534 , L535 , L536 , L537 , L538;
thus L540: (for B166 being (Element of ( CQC-WFF F28() )) holds P2[ B166 ]) from CQC_LANG:sch 1(L539);
end;
theorem
L541: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for R21 being (CQC-variable_list of R4 , R1) holds (for R22 being (QC-pred_symbol of R4 , R1) holds ( SepVar ( R22 ! R21 ) ) = ( R22 ! R21 )))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let R21 being (CQC-variable_list of R4 , R1);
let R22 being (QC-pred_symbol of R4 , R1);
L542: ( dom R21 ) = ( dom R21 );
L543: ( rng R21 ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
reconsider D57 = R21 as (PartFunc of ( NAT ) , ( bound_QC-variables R1 )) by L543 , L542 , RELSET_1:4;
L544: ( ( id ( bound_QC-variables R1 ) ) * D57 ) = R21 by PARTFUN1:7;
thus L545: ( SepVar ( R22 ! R21 ) ) = ( ( ATOMIC (R22 , R21) ) . (( index ( R22 ! R21 ) ) , ( id ( bound_QC-variables R1 ) )) ) by L350
.= ( R22 ! R21 ) by L544 , L333;
end;
theorem
L546: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (R16 is  atomic implies ( SepVar R16 ) = R16)))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
assume L547: R16 is  atomic;
L548: (ex R4 being (Element of ( NAT )) st (ex R22 being (QC-pred_symbol of R4 , R1) st (ex R21 being (CQC-variable_list of R4 , R1) st R16 = ( R22 ! R21 )))) by L547 , L85;
thus L549: thesis by L548 , L541;
end;
theorem
L550: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds ( SepVar ( 'not' R16 ) ) = ( 'not' ( SepVar R16 ) )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
reconsider D58 = ( ( SepFunc R1 ) . R16 ) as (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 ));
thus L551: ( SepVar ( 'not' R16 ) ) = ( ( NEGATIVE D58 ) . [ ( index ( 'not' R16 ) ) , ( id ( bound_QC-variables R1 ) ) ] ) by L350
.= ( ( NEGATIVE D58 ) . [ ( index R16 ) , ( id ( bound_QC-variables R1 ) ) ] ) by L506
.= ( 'not' ( SepVar R16 ) ) by L276;
end;
theorem
L552: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds ((R16 is  negative & R17 = ( the_argument_of R16 )) implies ( SepVar R16 ) = ( 'not' ( SepVar R17 ) )))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
assume that
L553: R16 is  negative
and
L554: R17 = ( the_argument_of R16 );
L555: R16 = ( 'not' R17 ) by L553 , L554 , QC_LANG1:def 24;
thus L556: thesis by L555 , L550;
end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let C126 being (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]);
pred C126 is_Sep-closed_on R16
means
:L557: ([ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in C126 & (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( 'not' R17 ) , R11 , R25 , R23 ] in C126 implies [ R17 , R11 , R25 , R23 ] in C126))))) & (for R17 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( R17 '&' R18 ) , R11 , R25 , R23 ] in C126 implies ([ R17 , R11 , R25 , R23 ] in C126 & [ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ] in C126))))))) & (for R17 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( All (R20 , R17) ) , R11 , R25 , R23 ] in C126 implies [ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ] in C126)))))))
;end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
func SepQuadruples R16 -> (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) means 
:L559: (it is_Sep-closed_on R16 & (for B167 being (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) holds (B167 is_Sep-closed_on R16 implies it c= B167)));
existence
proof
set D59 = [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :];
set D60 = { B168 where B168 is (Subset of D59) : B168 is_Sep-closed_on R16 };
L560: D60 c= ( bool D59 )
proof
let R8 being set;
assume L561: R8 in D60;
L562: (ex B169 being (Subset of D59) st (B169 = R8 & B169 is_Sep-closed_on R16)) by L561;
thus L563: thesis by L562;
end;
reconsider D61 = D60 as (Subset-Family of D59) by L560;
take D62 = ( meet D61 );
set D63 = ( [#] D59 );
L564: D63 is_Sep-closed_on R16
proof
thus L565: [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in D63;
thus L566: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( 'not' R17 ) , R11 , R25 , R23 ] in D63 implies [ R17 , R11 , R25 , R23 ] in D63)))));
thus L567: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( R17 '&' R18 ) , R11 , R25 , R23 ] in D63 implies ([ R17 , R11 , R25 , R23 ] in D63 & [ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ] in D63)))))));
let R17 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L568: [ ( All (R20 , R17) ) , R11 , R25 , R23 ] in D63;
L569: ( rng ( R23 +* ( R20 .--> ( x. R11 ) ) ) ) c= ( ( rng R23 ) \/ ( rng ( R20 .--> ( x. R11 ) ) ) ) by FUNCT_4:17;
L570: ( rng ( R20 .--> ( x. R11 ) ) ) = { ( x. R11 ) } by FUNCOP_1:8;
L571: ( ( bound_QC-variables R1 ) \/ { ( x. R11 ) } ) = ( bound_QC-variables R1 ) by ZFMISC_1:40;
L572: ( rng R23 ) c= ( bound_QC-variables R1 ) by RELAT_1:def 19;
L573: ( ( rng R23 ) \/ ( rng ( R20 .--> ( x. R11 ) ) ) ) c= ( bound_QC-variables R1 ) by L572 , L570 , L571 , XBOOLE_1:9;
L574: ( rng ( R23 +* ( R20 .--> ( x. R11 ) ) ) ) c= ( bound_QC-variables R1 ) by L573 , L569 , XBOOLE_1:1;
L575: ( dom ( R23 +* ( R20 .--> ( x. R11 ) ) ) ) = ( ( dom R23 ) \/ ( dom ( R20 .--> ( x. R11 ) ) ) ) by FUNCT_4:def 1
.= ( ( bound_QC-variables R1 ) \/ ( dom ( R20 .--> ( x. R11 ) ) ) ) by FUNCT_2:def 1
.= ( ( bound_QC-variables R1 ) \/ { R20 } ) by FUNCOP_1:13
.= ( bound_QC-variables R1 ) by ZFMISC_1:40;
L576: ( R23 +* ( R20 .--> ( x. R11 ) ) ) is (Function of ( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) by L575 , L574 , FUNCT_2:def 1 , RELSET_1:4;
reconsider D64 = ( R23 +* ( R20 .--> ( x. R11 ) ) ) as (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) by L576 , FUNCT_2:8;
L577: [ R17 , ( R11 ++ ) , ( R25 \/ {. R20 .} ) , D64 ] in D63;
thus L578: thesis by L577;
end;
L579: D63 in D61 by L564;
L580: (for B170 being set holds (B170 in D61 implies [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in B170))
proof
let C127 being set;
assume L581: C127 in D61;
L582: (ex B171 being (Subset of D59) st (B171 = C127 & B171 is_Sep-closed_on R16)) by L581;
thus L583: thesis by L582 , L557;
end;
thus L584: [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in D62 by L580 , L579 , SETFAM_1:def 1;
thus L585: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( 'not' R17 ) , R11 , R25 , R23 ] in D62 implies [ R17 , R11 , R25 , R23 ] in D62)))))
proof
let R17 being (Element of ( CQC-WFF R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L586: [ ( 'not' R17 ) , R11 , R25 , R23 ] in D62;
L587: (for B172 being set holds (B172 in D61 implies [ R17 , R11 , R25 , R23 ] in B172))
proof
let C128 being set;
assume L588: C128 in D61;
L589: (ex B173 being (Subset of D59) st (B173 = C128 & B173 is_Sep-closed_on R16)) by L588;
L590: [ ( 'not' R17 ) , R11 , R25 , R23 ] in C128 by L586 , L588 , SETFAM_1:def 1;
thus L591: thesis by L590 , L589 , L557;
end;
thus L592: thesis by L587 , L579 , SETFAM_1:def 1;
end;

thus L593: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( R17 '&' R18 ) , R11 , R25 , R23 ] in D62 implies ([ R17 , R11 , R25 , R23 ] in D62 & [ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ] in D62)))))))
proof
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L594: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in D62;
L595: (for B174 being set holds (B174 in D61 implies [ R17 , R11 , R25 , R23 ] in B174))
proof
let C129 being set;
assume L596: C129 in D61;
L597: (ex B175 being (Subset of D59) st (B175 = C129 & B175 is_Sep-closed_on R16)) by L596;
L598: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in C129 by L594 , L596 , SETFAM_1:def 1;
thus L599: thesis by L598 , L597 , L557;
end;
thus L600: [ R17 , R11 , R25 , R23 ] in D62 by L595 , L579 , SETFAM_1:def 1;
L601: (for B176 being set holds (B176 in D61 implies [ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ] in B176))
proof
let C130 being set;
assume L602: C130 in D61;
L603: (ex B177 being (Subset of D59) st (B177 = C130 & B177 is_Sep-closed_on R16)) by L602;
L604: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in C130 by L594 , L602 , SETFAM_1:def 1;
thus L605: thesis by L604 , L603 , L557;
end;
thus L606: thesis by L601 , L579 , SETFAM_1:def 1;
end;

thus L607: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( All (R20 , R17) ) , R11 , R25 , R23 ] in D62 implies [ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ] in D62))))))
proof
let R17 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L608: [ ( All (R20 , R17) ) , R11 , R25 , R23 ] in D62;
L609: (for B178 being set holds (B178 in D61 implies [ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ] in B178))
proof
let C131 being set;
assume L610: C131 in D61;
L611: (ex B179 being (Subset of D59) st (B179 = C131 & B179 is_Sep-closed_on R16)) by L610;
L612: [ ( All (R20 , R17) ) , R11 , R25 , R23 ] in C131 by L608 , L610 , SETFAM_1:def 1;
thus L613: thesis by L612 , L611 , L557;
end;
thus L614: thesis by L609 , L579 , SETFAM_1:def 1;
end;

let C132 being (Subset of D59);
assume L615: C132 is_Sep-closed_on R16;
L616: C132 in D61 by L615;
thus L617: thesis by L616 , SETFAM_1:3;
end;
uniqueness
proof
let C133 , C134 being (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]);
assume that
L618: C133 is_Sep-closed_on R16
and
L619: (for B180 being (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) holds (B180 is_Sep-closed_on R16 implies C133 c= B180))
and
L620: C134 is_Sep-closed_on R16
and
L621: (for B181 being (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]) holds (B181 is_Sep-closed_on R16 implies C134 c= B181));
thus L622: (C133 c= C134 & C134 c= C133) by L618 , L619 , L620 , L621;
end;
end;
theorem
L624: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in ( SepQuadruples R16 )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L625: ( SepQuadruples R16 ) is_Sep-closed_on R16 by L559;
thus L626: thesis by L625 , L557;
end;
theorem
L627: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies [ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ))))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L628: ( SepQuadruples R16 ) is_Sep-closed_on R16 by L559;
thus L629: thesis by L628 , L557;
end;
theorem
L630: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) & [ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ] in ( SepQuadruples R16 ))))))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L631: ( SepQuadruples R16 ) is_Sep-closed_on R16 by L559;
thus L632: thesis by L631 , L557;
end;
theorem
L633: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( All (R20 , R17) ) , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies [ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ] in ( SepQuadruples R16 )))))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L634: ( SepQuadruples R16 ) is_Sep-closed_on R16 by L559;
thus L635: thesis by L634 , L557;
end;
theorem
L636: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies ([ R17 , R11 , R25 , R23 ] = [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] or [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 ) or (ex R18 being (Element of ( CQC-WFF R1 )) st [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 )) or (ex R18 being (Element of ( CQC-WFF R1 )) st (ex R12 being (QC-symbol of R1) st (R11 = ( R12 + ( QuantNbr R18 ) ) & [ ( R18 '&' R17 ) , R12 , R25 , R23 ] in ( SepQuadruples R16 )))) or (ex R20 being (Element of ( bound_QC-variables R1 )) st (ex R12 being (QC-symbol of R1) st (ex R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) st (( R12 ++ ) = R11 & ( R24 +* ( { R20 } --> ( x. R12 ) ) ) = R23 & ([ ( All (R20 , R17) ) , R12 , R25 , R24 ] in ( SepQuadruples R16 ) or [ ( All (R20 , R17) ) , R12 , ( R25 \ { R20 } ) , R24 ] in ( SepQuadruples R16 ))))))))))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
assume that
L637: [ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 )
and
L638: [ R17 , R11 , R25 , R23 ] <> [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ]
and
L639: (not [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 ))
and
L640: (not (ex R18 being (Element of ( CQC-WFF R1 )) st [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 )))
and
L641: (not (ex R18 being (Element of ( CQC-WFF R1 )) st (ex R12 being (QC-symbol of R1) st (R11 = ( R12 + ( QuantNbr R18 ) ) & [ ( R18 '&' R17 ) , R12 , R25 , R23 ] in ( SepQuadruples R16 )))))
and
L642: (not (ex R20 being (Element of ( bound_QC-variables R1 )) st (ex R12 being (QC-symbol of R1) st (ex R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) st (( R12 ++ ) = R11 & ( R24 +* ( { R20 } --> ( x. R12 ) ) ) = R23 & ([ ( All (R20 , R17) ) , R12 , R25 , R24 ] in ( SepQuadruples R16 ) or [ ( All (R20 , R17) ) , R12 , ( R25 \ { R20 } ) , R24 ] in ( SepQuadruples R16 )))))));
reconsider D65 = ( ( SepQuadruples R16 ) \ { [ R17 , R11 , R25 , R23 ] } ) as (Subset of [: ( CQC-WFF R1 ) , ( QC-symbols R1 ) , ( Fin ( bound_QC-variables R1 ) ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :]);
L643: ( SepQuadruples R16 ) is_Sep-closed_on R16 by L559;
L644: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( 'not' R17 ) , R11 , R25 , R23 ] in D65 implies [ R17 , R11 , R25 , R23 ] in D65)))))
proof
let R19 being (Element of ( CQC-WFF R1 ));
let R12 being (QC-symbol of R1);
let R26 being (Finite_Subset of ( bound_QC-variables R1 ));
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume L645: [ ( 'not' R19 ) , R12 , R26 , R24 ] in D65;
L646: (R19 <> R17 or R12 <> R11 or R26 <> R25 or R23 <> R24) by L645 , L639 , XBOOLE_0:def 5;
L647: [ R19 , R12 , R26 , R24 ] <> [ R17 , R11 , R25 , R23 ] by L646 , XTUPLE_0:5;
L648: [ ( 'not' R19 ) , R12 , R26 , R24 ] in ( SepQuadruples R16 ) by L645 , XBOOLE_0:def 5;
L649: [ R19 , R12 , R26 , R24 ] in ( SepQuadruples R16 ) by L648 , L643 , L557;
thus L650: thesis by L649 , L647 , ZFMISC_1:56;
end;
L651: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( R17 '&' R18 ) , R11 , R25 , R23 ] in D65 implies ([ R17 , R11 , R25 , R23 ] in D65 & [ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ] in D65)))))))
proof
let R19 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R12 being (QC-symbol of R1);
let R26 being (Finite_Subset of ( bound_QC-variables R1 ));
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume L652: [ ( R19 '&' R18 ) , R12 , R26 , R24 ] in D65;
L653: [ ( R19 '&' R18 ) , R12 , R26 , R24 ] in ( SepQuadruples R16 ) by L652 , XBOOLE_0:def 5;
L654: (R19 <> R17 or R12 <> R11 or R26 <> R25 or R23 <> R24) by L653 , L640;
L655: [ R19 , R12 , R26 , R24 ] <> [ R17 , R11 , R25 , R23 ] by L654 , XTUPLE_0:5;
L656: [ R19 , R12 , R26 , R24 ] in ( SepQuadruples R16 ) by L643 , L653 , L557;
thus L657: [ R19 , R12 , R26 , R24 ] in D65 by L656 , L655 , ZFMISC_1:56;
L658: (R18 <> R17 or R26 <> R25 or R23 <> R24 or ( R12 + ( QuantNbr R19 ) ) <> R11) by L641 , L653;
L659: [ R18 , ( R12 + ( QuantNbr R19 ) ) , R26 , R24 ] <> [ R17 , R11 , R25 , R23 ] by L658 , XTUPLE_0:5;
L660: [ R18 , ( R12 + ( QuantNbr R19 ) ) , R26 , R24 ] in ( SepQuadruples R16 ) by L643 , L653 , L557;
thus L661: thesis by L660 , L659 , ZFMISC_1:56;
end;
L662: D65 c= ( SepQuadruples R16 ) by XBOOLE_1:36;
L663: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R20 being (Element of ( bound_QC-variables R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ ( All (R20 , R17) ) , R11 , R25 , R23 ] in D65 implies [ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ] in D65))))))
proof
let R19 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R12 being (QC-symbol of R1);
let R26 being (Finite_Subset of ( bound_QC-variables R1 ));
let R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume L664: [ ( All (R20 , R19) ) , R12 , R26 , R24 ] in D65;
L665:
now
assume that
L666: (not [ ( All (R20 , R17) ) , R12 , R25 , R24 ] in ( SepQuadruples R16 ))
and
L667: (not [ ( All (R20 , R17) ) , R12 , ( R25 \ { R20 } ) , R24 ] in ( SepQuadruples R16 ));
L668: (R19 <> R17 or (R26 <> R25 & R26 <> ( R25 \ { R20 } ))) by L664 , L666 , L667 , XBOOLE_0:def 5;
assume L669: R19 = R17;
assume L670: ( R26 \/ { R20 } ) = R25;
L671: ( R25 \ { R20 } ) = ( R26 \ { R20 } ) by L670 , XBOOLE_1:40;
thus L672: contradiction by L671 , L668 , L669 , L670 , ZFMISC_1:40 , ZFMISC_1:57;
end;
L673: (R19 <> R17 or ( R12 ++ ) <> R11 or ( R26 \/ { R20 } ) <> R25 or R23 <> ( R24 +* ( { R20 } --> ( x. R12 ) ) )) by L665 , L642;
L674: [ R19 , ( R12 ++ ) , ( R26 \/ { R20 } ) , ( R24 +* ( R20 .--> ( x. R12 ) ) ) ] <> [ R17 , R11 , R25 , R23 ] by L673 , XTUPLE_0:5;
L675: [ ( All (R20 , R19) ) , R12 , R26 , R24 ] in ( SepQuadruples R16 ) by L664 , XBOOLE_0:def 5;
L676: [ R19 , ( R12 ++ ) , ( R26 \/ { R20 } ) , ( R24 +* ( R20 .--> ( x. R12 ) ) ) ] in ( SepQuadruples R16 ) by L675 , L643 , L557;
thus L677: thesis by L676 , L674 , ZFMISC_1:56;
end;
L678: [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in ( SepQuadruples R16 ) by L643 , L557;
L679: [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in D65 by L678 , L638 , ZFMISC_1:56;
L680: D65 is_Sep-closed_on R16 by L679 , L644 , L651 , L663 , L557;
L681: ( SepQuadruples R16 ) c= D65 by L680 , L559;
L682: D65 = ( SepQuadruples R16 ) by L681 , L662 , XBOOLE_0:def 10;
thus L683: contradiction by L682 , L637 , ZFMISC_1:57;
end;
scheme Sepregression { F29() -> QC-alphabet , F30() -> (Element of ( CQC-WFF F29() )) , P3[set , set , set , set] } : (for B182 being (Element of ( CQC-WFF F29() )) holds (for B183 being (QC-symbol of F29()) holds (for B184 being (Finite_Subset of ( bound_QC-variables F29() )) holds (for B185 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) holds ([ B182 , B183 , B184 , B185 ] in ( SepQuadruples F30() ) implies P3[ B182 , B183 , B184 , B185 ])))))
provided
L684: P3[ F30() , ( index F30() ) , ( {}. ( bound_QC-variables F29() ) ) , ( id ( bound_QC-variables F29() ) ) ]
and
L685: (for B186 being (Element of ( CQC-WFF F29() )) holds (for B187 being (QC-symbol of F29()) holds (for B188 being (Finite_Subset of ( bound_QC-variables F29() )) holds (for B189 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) holds (([ ( 'not' B186 ) , B187 , B188 , B189 ] in ( SepQuadruples F30() ) & P3[ ( 'not' B186 ) , B187 , B188 , B189 ]) implies P3[ B186 , B187 , B188 , B189 ])))))
and
L686: (for B190 , B191 being (Element of ( CQC-WFF F29() )) holds (for B192 being (QC-symbol of F29()) holds (for B193 being (Finite_Subset of ( bound_QC-variables F29() )) holds (for B194 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) holds (([ ( B190 '&' B191 ) , B192 , B193 , B194 ] in ( SepQuadruples F30() ) & P3[ ( B190 '&' B191 ) , B192 , B193 , B194 ]) implies (P3[ B190 , B192 , B193 , B194 ] & P3[ B191 , ( B192 + ( QuantNbr B190 ) ) , B193 , B194 ]))))))
and
L687: (for B195 being (Element of ( CQC-WFF F29() )) holds (for B196 being (bound_QC-variable of F29()) holds (for B197 being (QC-symbol of F29()) holds (for B198 being (Finite_Subset of ( bound_QC-variables F29() )) holds (for B199 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) holds (([ ( All (B196 , B195) ) , B197 , B198 , B199 ] in ( SepQuadruples F30() ) & P3[ ( All (B196 , B195) ) , B197 , B198 , B199 ]) implies P3[ B195 , ( B197 ++ ) , ( B198 \/ { B196 } ) , ( B199 +* ( B196 .--> ( x. B197 ) ) ) ]))))))
proof
set D66 = { [ B200 , B202 , B201 , B203 ] where B200 is (Element of ( CQC-WFF F29() )) , B201 is (Finite_Subset of ( bound_QC-variables F29() )) , B202 is (QC-symbol of F29()) , B203 is (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) : P3[ B200 , B202 , B201 , B203 ] };
reconsider D67 = ( ( SepQuadruples F30() ) /\ D66 ) as (Subset of [: ( CQC-WFF F29() ) , ( QC-symbols F29() ) , ( Fin ( bound_QC-variables F29() ) ) , ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) ) :]);
L688: ( SepQuadruples F30() ) is_Sep-closed_on F30() by L559;
L689: D67 is_Sep-closed_on F30()
proof
L690: [ F30() , ( index F30() ) , ( {}. ( bound_QC-variables F29() ) ) , ( id ( bound_QC-variables F29() ) ) ] in D66 by L684;
L691: [ F30() , ( index F30() ) , ( {}. ( bound_QC-variables F29() ) ) , ( id ( bound_QC-variables F29() ) ) ] in ( SepQuadruples F30() ) by L624;
thus L692: [ F30() , ( index F30() ) , ( {}. ( bound_QC-variables F29() ) ) , ( id ( bound_QC-variables F29() ) ) ] in D67 by L691 , L690 , XBOOLE_0:def 4;
thus L693: (for B204 being (Element of ( CQC-WFF F29() )) holds (for B205 being (QC-symbol of F29()) holds (for B206 being (Finite_Subset of ( bound_QC-variables F29() )) holds (for B207 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) holds ([ ( 'not' B204 ) , B205 , B206 , B207 ] in D67 implies [ B204 , B205 , B206 , B207 ] in D67)))))
proof
let C135 being (Element of ( CQC-WFF F29() ));
let C136 being (QC-symbol of F29());
let C137 being (Finite_Subset of ( bound_QC-variables F29() ));
let C138 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) ));
assume L694: [ ( 'not' C135 ) , C136 , C137 , C138 ] in D67;
L695: [ ( 'not' C135 ) , C136 , C137 , C138 ] in ( SepQuadruples F30() ) by L694 , XBOOLE_0:def 4;
L696: [ ( 'not' C135 ) , C136 , C137 , C138 ] in D66 by L694 , XBOOLE_0:def 4;
consider C139 being (Element of ( CQC-WFF F29() )), C140 being (Finite_Subset of ( bound_QC-variables F29() )), C141 being (QC-symbol of F29()), C142 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) such that L697: [ ( 'not' C135 ) , C136 , C137 , C138 ] = [ C139 , C141 , C140 , C142 ] and L698: P3[ C139 , C141 , C140 , C142 ] by L696;
L699: C136 = C141 by L697 , XTUPLE_0:5;
L700: C138 = C142 by L697 , XTUPLE_0:5;
L701: C137 = C140 by L697 , XTUPLE_0:5;
L702: ( 'not' C135 ) = C139 by L697 , XTUPLE_0:5;
L703: P3[ C135 , C136 , C137 , C138 ] by L702 , L685 , L695 , L698 , L699 , L701 , L700;
L704: [ C135 , C136 , C137 , C138 ] in D66 by L703;
L705: [ C135 , C136 , C137 , C138 ] in ( SepQuadruples F30() ) by L688 , L695 , L557;
thus L706: thesis by L705 , L704 , XBOOLE_0:def 4;
end;

thus L707: (for B208 , B209 being (Element of ( CQC-WFF F29() )) holds (for B210 being (QC-symbol of F29()) holds (for B211 being (Finite_Subset of ( bound_QC-variables F29() )) holds (for B212 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) holds ([ ( B208 '&' B209 ) , B210 , B211 , B212 ] in D67 implies ([ B208 , B210 , B211 , B212 ] in D67 & [ B209 , ( B210 + ( QuantNbr B208 ) ) , B211 , B212 ] in D67))))))
proof
let C143 , C144 being (Element of ( CQC-WFF F29() ));
let C145 being (QC-symbol of F29());
let C146 being (Finite_Subset of ( bound_QC-variables F29() ));
let C147 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) ));
assume L708: [ ( C143 '&' C144 ) , C145 , C146 , C147 ] in D67;
L709: [ ( C143 '&' C144 ) , C145 , C146 , C147 ] in ( SepQuadruples F30() ) by L708 , XBOOLE_0:def 4;
L710: [ C144 , ( C145 + ( QuantNbr C143 ) ) , C146 , C147 ] in ( SepQuadruples F30() ) by L709 , L688 , L557;
L711: [ ( C143 '&' C144 ) , C145 , C146 , C147 ] in D66 by L708 , XBOOLE_0:def 4;
consider C148 being (Element of ( CQC-WFF F29() )), C149 being (Finite_Subset of ( bound_QC-variables F29() )), C150 being (QC-symbol of F29()), C151 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) such that L712: [ ( C143 '&' C144 ) , C145 , C146 , C147 ] = [ C148 , C150 , C149 , C151 ] and L713: P3[ C148 , C150 , C149 , C151 ] by L711;
L714: C145 = C150 by L712 , XTUPLE_0:5;
L715: C147 = C151 by L712 , XTUPLE_0:5;
L716: C146 = C149 by L712 , XTUPLE_0:5;
L717: ( C143 '&' C144 ) = C148 by L712 , XTUPLE_0:5;
L718: P3[ C143 , C145 , C146 , C147 ] by L717 , L686 , L709 , L713 , L714 , L716 , L715;
L719: [ C143 , C145 , C146 , C147 ] in D66 by L718;
L720: P3[ C144 , ( C145 + ( QuantNbr C143 ) ) , C146 , C147 ] by L686 , L709 , L713 , L717 , L714 , L716 , L715;
L721: [ C144 , ( C145 + ( QuantNbr C143 ) ) , C146 , C147 ] in D66 by L720;
L722: [ C143 , C145 , C146 , C147 ] in ( SepQuadruples F30() ) by L688 , L709 , L557;
thus L723: thesis by L722 , L719 , L721 , L710 , XBOOLE_0:def 4;
end;

let C152 being (Element of ( CQC-WFF F29() ));
let C153 being (bound_QC-variable of F29());
let C154 being (QC-symbol of F29());
let C155 being (Finite_Subset of ( bound_QC-variables F29() ));
let C156 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) ));
assume L724: [ ( All (C153 , C152) ) , C154 , C155 , C156 ] in D67;
L725: [ ( All (C153 , C152) ) , C154 , C155 , C156 ] in ( SepQuadruples F30() ) by L724 , XBOOLE_0:def 4;
L726: ( C156 +* ( C153 .--> ( x. C154 ) ) ) is (Function of ( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) by L306;
reconsider D68 = ( C156 +* ( C153 .--> ( x. C154 ) ) ) as (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) by L726 , FUNCT_2:8;
L727: [ ( All (C153 , C152) ) , C154 , C155 , C156 ] in D66 by L724 , XBOOLE_0:def 4;
consider C157 being (Element of ( CQC-WFF F29() )), C158 being (Finite_Subset of ( bound_QC-variables F29() )), C159 being (QC-symbol of F29()), C160 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) such that L728: [ ( All (C153 , C152) ) , C154 , C155 , C156 ] = [ C157 , C159 , C158 , C160 ] and L729: P3[ C157 , C159 , C158 , C160 ] by L727;
L730: C154 = C159 by L728 , XTUPLE_0:5;
L731: C156 = C160 by L728 , XTUPLE_0:5;
L732: C155 = C158 by L728 , XTUPLE_0:5;
L733: ( All (C153 , C152) ) = C157 by L728 , XTUPLE_0:5;
L734: P3[ C152 , ( C154 ++ ) , ( C155 \/ { C153 } ) , D68 ] by L733 , L687 , L725 , L729 , L730 , L732 , L731;
L735: [ C152 , ( C154 ++ ) , ( C155 \/ {. C153 .} ) , ( C156 +* ( C153 .--> ( x. C154 ) ) ) ] in D66 by L734;
L736: [ C152 , ( C154 ++ ) , ( C155 \/ { C153 } ) , ( C156 +* ( C153 .--> ( x. C154 ) ) ) ] in ( SepQuadruples F30() ) by L688 , L725 , L557;
thus L737: thesis by L736 , L735 , XBOOLE_0:def 4;
end;
L738: ( SepQuadruples F30() ) c= D67 by L689 , L559;
let C161 being (Element of ( CQC-WFF F29() ));
let C162 being (QC-symbol of F29());
let C163 being (Finite_Subset of ( bound_QC-variables F29() ));
let C164 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) ));
assume L739: [ C161 , C162 , C163 , C164 ] in ( SepQuadruples F30() );
L740: [ C161 , C162 , C163 , C164 ] in D66 by L739 , L738 , XBOOLE_0:def 4;
consider C165 being (Element of ( CQC-WFF F29() )), C166 being (Finite_Subset of ( bound_QC-variables F29() )), C167 being (QC-symbol of F29()), C168 being (Element of ( Funcs (( bound_QC-variables F29() ) , ( bound_QC-variables F29() )) )) such that L741: [ C161 , C162 , C163 , C164 ] = [ C165 , C167 , C166 , C168 ] and L742: P3[ C165 , C167 , C166 , C168 ] by L740;
L743: C162 = C167 by L741 , XTUPLE_0:5;
L744: C163 = C166 by L741 , XTUPLE_0:5;
L745: C161 = C165 by L741 , XTUPLE_0:5;
thus L746: thesis by L745 , L741 , L742 , L743 , L744 , XTUPLE_0:5;
end;
theorem
L747: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies R17 is_subformula_of R16)))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
defpred S19[ (Element of ( CQC-WFF R1 )) , set , set , set ] means $1 is_subformula_of R16;
L748:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L749: [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 );
L750: R17 is_subformula_of ( 'not' R17 ) by L259;
thus L751: (S19[ ( 'not' R17 ) , R11 , R25 , R23 ] implies S19[ R17 , R11 , R25 , R23 ]) by L750 , QC_LANG2:57;
end;
L752:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L753: [ ( All (R20 , R17) ) , R11 , R25 , R23 ] in ( SepQuadruples R16 );
L754: R17 is_subformula_of ( All (R20 , R17) ) by L266;
thus L755: (S19[ ( All (R20 , R17) ) , R11 , R25 , R23 ] implies S19[ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ]) by L754 , QC_LANG2:57;
end;
L756:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L757: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 );
L758: R18 is_subformula_of ( R17 '&' R18 ) by L262;
L759: R17 is_subformula_of ( R17 '&' R18 ) by L262;
thus L760: (S19[ ( R17 '&' R18 ) , R11 , R25 , R23 ] implies (S19[ R17 , R11 , R25 , R23 ] & S19[ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ])) by L759 , L758 , QC_LANG2:57;
end;
L761: S19[ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ];
thus L762: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies S19[ R17 , R11 , R25 , R23 ]))))) from Sepregression(L761 , L748 , L756 , L752);
end;
theorem
L763: (for R1 being QC-alphabet holds ( SepQuadruples ( VERUM R1 ) ) = { [ ( VERUM R1 ) , ( 0 R1 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] })
proof
let R1 being QC-alphabet;
L764:
now
let C169 being set;
thus L765: (C169 in ( SepQuadruples ( VERUM R1 ) ) implies C169 = [ ( VERUM R1 ) , ( 0 R1 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ])
proof
assume L766: C169 in ( SepQuadruples ( VERUM R1 ) );
consider R17 being (Element of ( CQC-WFF R1 )), R11 being (QC-symbol of R1), R25 being (Finite_Subset of ( bound_QC-variables R1 )), R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that L767: C169 = [ R17 , R11 , R25 , R23 ] by L766 , DOMAIN_1:10;
L768:
now
given R20 being (Element of ( bound_QC-variables R1 )) , R13 being (QC-symbol of R1) , R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that
L769: ( R13 ++ ) = R11
and
L770: ( R24 +* ( { R20 } --> ( x. R13 ) ) ) = R23
and
L771: ([ ( All (R20 , R17) ) , R13 , R25 , R24 ] in ( SepQuadruples ( VERUM R1 ) ) or [ ( All (R20 , R17) ) , R13 , ( R25 \ {. R20 .} ) , R24 ] in ( SepQuadruples ( VERUM R1 ) ));

L772: ( All (R20 , R17) ) is_subformula_of ( VERUM R1 ) by L771 , L747;
L773: ( All (R20 , R17) ) = ( VERUM R1 ) by L772 , QC_LANG2:79;
L774: ( VERUM R1 ) is  universal by L773 , QC_LANG1:def 21;
thus L775: contradiction by L774 , QC_LANG1:20;
end;
L776:
now
given R18 being (Element of ( CQC-WFF R1 )) , R13 being (QC-symbol of R1) such that
L777: R11 = ( R13 + ( QuantNbr R18 ) )
and
L778: [ ( R18 '&' R17 ) , R13 , R25 , R23 ] in ( SepQuadruples ( VERUM R1 ) );

L779: ( R18 '&' R17 ) is_subformula_of ( VERUM R1 ) by L778 , L747;
L780: ( R18 '&' R17 ) = ( VERUM R1 ) by L779 , QC_LANG2:79;
L781: ( VERUM R1 ) is  conjunctive by L780 , QC_LANG1:def 20;
thus L782: contradiction by L781 , QC_LANG1:20;
end;
L783:
now
given R18 being (Element of ( CQC-WFF R1 )) such that
L784: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples ( VERUM R1 ) );

L785: ( R17 '&' R18 ) is_subformula_of ( VERUM R1 ) by L784 , L747;
L786: ( R17 '&' R18 ) = ( VERUM R1 ) by L785 , QC_LANG2:79;
L787: ( VERUM R1 ) is  conjunctive by L786 , QC_LANG1:def 20;
thus L788: contradiction by L787 , QC_LANG1:20;
end;
L789:
now
assume L790: [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples ( VERUM R1 ) );
L791: ( 'not' R17 ) is_subformula_of ( VERUM R1 ) by L790 , L747;
L792: ( 'not' R17 ) = ( VERUM R1 ) by L791 , QC_LANG2:79;
L793: ( VERUM R1 ) is  negative by L792 , QC_LANG1:def 19;
thus L794: contradiction by L793 , QC_LANG1:20;
end;
L795: ( index ( VERUM R1 ) ) = ( 0 R1 ) by L503;
set D69 = ( VERUM R1 );
L796: ([ R17 , R11 , R25 , R23 ] = [ D69 , ( index D69 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] or [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples D69 ) or (ex R18 being (Element of ( CQC-WFF R1 )) st [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples D69 )) or (ex R18 being (Element of ( CQC-WFF R1 )) st (ex R12 being (QC-symbol of R1) st (R11 = ( R12 + ( QuantNbr R18 ) ) & [ ( R18 '&' R17 ) , R12 , R25 , R23 ] in ( SepQuadruples D69 )))) or (ex R20 being (Element of ( bound_QC-variables R1 )) st (ex R12 being (QC-symbol of R1) st (ex R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) st (( R12 ++ ) = R11 & ( R24 +* ( { R20 } --> ( x. R12 ) ) ) = R23 & ([ ( All (R20 , R17) ) , R12 , R25 , R24 ] in ( SepQuadruples D69 ) or [ ( All (R20 , R17) ) , R12 , ( R25 \ { R20 } ) , R24 ] in ( SepQuadruples D69 ))))))) by L766 , L767 , L636;
thus L797: C169 = [ ( VERUM R1 ) , ( 0 R1 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] by L796 , L767 , L783 , L776 , L768 , L789 , L795;
end;

L798: ( index ( VERUM R1 ) ) = ( 0 R1 ) by L503;
thus L799: (C169 = [ ( VERUM R1 ) , ( 0 R1 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] implies C169 in ( SepQuadruples ( VERUM R1 ) )) by L798 , L624;
end;
thus L800: thesis by L764 , TARSKI:def 1;
end;
theorem
L801: (for R1 being QC-alphabet holds (for R4 being (Element of ( NAT )) holds (for B213 being (CQC-variable_list of R4 , R1) holds (for B214 being (QC-pred_symbol of R4 , R1) holds ( SepQuadruples ( B214 ! B213 ) ) = { [ ( B214 ! B213 ) , ( index ( B214 ! B213 ) ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] }))))
proof
let R1 being QC-alphabet;
let R4 being (Element of ( NAT ));
let C170 being (CQC-variable_list of R4 , R1);
let C171 being (QC-pred_symbol of R4 , R1);
L802: ( C171 ! C170 ) is  atomic by QC_LANG1:def 18;
L803:
now
let C172 being set;
thus L804: (C172 in ( SepQuadruples ( C171 ! C170 ) ) implies C172 = [ ( C171 ! C170 ) , ( index ( C171 ! C170 ) ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ])
proof
assume L805: C172 in ( SepQuadruples ( C171 ! C170 ) );
consider R17 being (Element of ( CQC-WFF R1 )), R11 being (QC-symbol of R1), R25 being (Finite_Subset of ( bound_QC-variables R1 )), R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that L806: C172 = [ R17 , R11 , R25 , R23 ] by L805 , DOMAIN_1:10;
L807:
now
given R20 being (Element of ( bound_QC-variables R1 )) , R12 being (QC-symbol of R1) , R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) such that
L808: ( R12 ++ ) = R11
and
L809: ( R24 +* ( { R20 } --> ( x. R12 ) ) ) = R23
and
L810: ([ ( All (R20 , R17) ) , R12 , R25 , R24 ] in ( SepQuadruples ( C171 ! C170 ) ) or [ ( All (R20 , R17) ) , R12 , ( R25 \ {. R20 .} ) , R24 ] in ( SepQuadruples ( C171 ! C170 ) ));

L811: ( All (R20 , R17) ) is_subformula_of ( C171 ! C170 ) by L810 , L747;
L812: ( All (R20 , R17) ) = ( C171 ! C170 ) by L811 , QC_LANG2:80;
L813: ( C171 ! C170 ) is  universal by L812 , QC_LANG1:def 21;
thus L814: contradiction by L813 , L802 , QC_LANG1:20;
end;
L815:
now
given R18 being (Element of ( CQC-WFF R1 )) , R12 being (QC-symbol of R1) such that
L816: R11 = ( R12 + ( QuantNbr R18 ) )
and
L817: [ ( R18 '&' R17 ) , R12 , R25 , R23 ] in ( SepQuadruples ( C171 ! C170 ) );

L818: ( R18 '&' R17 ) is_subformula_of ( C171 ! C170 ) by L817 , L747;
L819: ( R18 '&' R17 ) = ( C171 ! C170 ) by L818 , QC_LANG2:80;
L820: ( C171 ! C170 ) is  conjunctive by L819 , QC_LANG1:def 20;
thus L821: contradiction by L820 , L802 , QC_LANG1:20;
end;
L822:
now
given R18 being (Element of ( CQC-WFF R1 )) such that
L823: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples ( C171 ! C170 ) );

L824: ( R17 '&' R18 ) is_subformula_of ( C171 ! C170 ) by L823 , L747;
L825: ( R17 '&' R18 ) = ( C171 ! C170 ) by L824 , QC_LANG2:80;
L826: ( C171 ! C170 ) is  conjunctive by L825 , QC_LANG1:def 20;
thus L827: contradiction by L826 , L802 , QC_LANG1:20;
end;
L828:
now
assume L829: [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples ( C171 ! C170 ) );
L830: ( 'not' R17 ) is_subformula_of ( C171 ! C170 ) by L829 , L747;
L831: ( 'not' R17 ) = ( C171 ! C170 ) by L830 , QC_LANG2:80;
L832: ( C171 ! C170 ) is  negative by L831 , QC_LANG1:def 19;
thus L833: contradiction by L832 , L802 , QC_LANG1:20;
end;
set D70 = ( C171 ! C170 );
L834: ([ R17 , R11 , R25 , R23 ] = [ D70 , ( index D70 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] or [ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples D70 ) or (ex R18 being (Element of ( CQC-WFF R1 )) st [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples D70 )) or (ex R18 being (Element of ( CQC-WFF R1 )) st (ex R12 being (QC-symbol of R1) st (R11 = ( R12 + ( QuantNbr R18 ) ) & [ ( R18 '&' R17 ) , R12 , R25 , R23 ] in ( SepQuadruples D70 )))) or (ex R20 being (Element of ( bound_QC-variables R1 )) st (ex R12 being (QC-symbol of R1) st (ex R24 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) st (( R12 ++ ) = R11 & ( R24 +* ( { R20 } --> ( x. R12 ) ) ) = R23 & ([ ( All (R20 , R17) ) , R12 , R25 , R24 ] in ( SepQuadruples D70 ) or [ ( All (R20 , R17) ) , R12 , ( R25 \ { R20 } ) , R24 ] in ( SepQuadruples D70 ))))))) by L805 , L636 , L806;
thus L835: thesis by L834 , L806 , L822 , L815 , L807 , L828;
end;

thus L836: (C172 = [ ( C171 ! C170 ) , ( index ( C171 ! C170 ) ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] implies C172 in ( SepQuadruples ( C171 ! C170 ) )) by L624;
end;
thus L837: thesis by L803 , TARSKI:def 1;
end;
theorem
L838: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies ( still_not-bound_in R17 ) c= ( ( still_not-bound_in R16 ) \/ R25 ))))))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
deffunc H25((QC-formula of R1)) = ( still_not-bound_in $1 );
defpred S20[ (QC-formula of R1) , set , set , set ] means H25($1) c= ( H25(R16) \/ $3 );
L839: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (([ ( 'not' R17 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 ) & S20[ ( 'not' R17 ) , R11 , R25 , R23 ]) implies S20[ R17 , R11 , R25 , R23 ]))))) by QC_LANG3:7;
L840:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L841: [ ( R17 '&' R18 ) , R11 , R25 , R23 ] in ( SepQuadruples R16 )
and
L842: S20[ ( R17 '&' R18 ) , R11 , R25 , R23 ];
L843: ( still_not-bound_in ( R17 '&' R18 ) ) = ( ( still_not-bound_in R17 ) \/ ( still_not-bound_in R18 ) ) by QC_LANG3:10;
L844: ( still_not-bound_in R18 ) c= ( still_not-bound_in ( R17 '&' R18 ) ) by L843 , XBOOLE_1:7;
L845: ( still_not-bound_in R17 ) c= ( still_not-bound_in ( R17 '&' R18 ) ) by L843 , XBOOLE_1:7;
thus L846: (S20[ R17 , R11 , R25 , R23 ] & S20[ R18 , ( R11 + ( QuantNbr R17 ) ) , R25 , R23 ]) by L845 , L842 , L844 , XBOOLE_1:1;
end;
L847:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R11 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L848: [ ( All (R20 , R17) ) , R11 , R25 , R23 ] in ( SepQuadruples R16 )
and
L849: S20[ ( All (R20 , R17) ) , R11 , R25 , R23 ];
L850: ( still_not-bound_in ( All (R20 , R17) ) ) = ( ( still_not-bound_in R17 ) \ { R20 } ) by QC_LANG3:12;
L851: ( still_not-bound_in R17 ) c= ( ( ( still_not-bound_in R16 ) \/ R25 ) \/ { R20 } ) by L850 , L849 , XBOOLE_1:44;
thus L852: S20[ R17 , ( R11 ++ ) , ( R25 \/ { R20 } ) , ( R23 +* ( R20 .--> ( x. R11 ) ) ) ] by L851 , XBOOLE_1:4;
end;
L853: S20[ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ];
thus L854: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies S20[ R17 , R11 , R25 , R23 ]))))) from Sepregression(L853 , L839 , L840 , L847);
end;
theorem
L855: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R12 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) & ( x. R12 ) in ( R23 .: R25 )) implies R12 < R11))))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R12 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
defpred S21[ (Element of ( CQC-WFF R1 )) , (QC-symbol of R1) , (Finite_Subset of ( bound_QC-variables R1 )) , Function ] means (for R12 being (QC-symbol of R1) holds (( x. R12 ) in ( $4 .: $3 ) implies R12 < $2));
L856: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R13 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (([ ( 'not' R17 ) , R13 , R25 , R23 ] in ( SepQuadruples R16 ) & S21[ ( 'not' R17 ) , R13 , R25 , R23 ]) implies S21[ R17 , R13 , R25 , R23 ])))));
L857:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R13 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume L858: [ ( R17 '&' R18 ) , R13 , R25 , R23 ] in ( SepQuadruples R16 );
assume L859: S21[ ( R17 '&' R18 ) , R13 , R25 , R23 ];
thus L860: S21[ R17 , R13 , R25 , R23 ] by L859;
thus L861: S21[ R18 , ( R13 + ( QuantNbr R17 ) ) , R25 , R23 ]
proof
let R12 being (QC-symbol of R1);
L862: R13 <= ( R13 + ( QuantNbr R17 ) ) by QC_LANG1:31;
assume L863: ( x. R12 ) in ( R23 .: R25 );
thus L864: thesis by L863 , L859 , L862 , QC_LANG1:30;
end;

end;
L862:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R13 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L863: [ ( All (R20 , R17) ) , R13 , R25 , R23 ] in ( SepQuadruples R16 );
assume L864: S21[ ( All (R20 , R17) ) , R13 , R25 , R23 ];
thus L865: S21[ R17 , ( R13 ++ ) , ( R25 \/ {. R20 .} ) , ( R23 +* ( R20 .--> ( x. R13 ) ) ) ]
proof
let R12 being (QC-symbol of R1);
assume L866: ( x. R12 ) in ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: ( R25 \/ { R20 } ) );
L867: ( x. R12 ) in ( ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: R25 ) \/ ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: { R20 } ) ) by L866 , RELAT_1:120;
L868: (( x. R12 ) in ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: R25 ) or ( x. R12 ) in ( Im (( R23 +* ( R20 .--> ( x. R13 ) ) ) , R20) )) by L867 , XBOOLE_0:def 3;
L869: ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: R25 ) c= ( ( R23 .: R25 ) \/ { ( x. R13 ) } ) by L20;
L870: (( x. R12 ) in ( R23 .: R25 ) or ( x. R12 ) in { ( x. R13 ) }) by L869 , L868 , L3 , XBOOLE_0:def 3;
L871: (R12 < R13 or ( x. R12 ) = ( x. R13 )) by L870 , L864 , TARSKI:def 1;
L872: (R12 < R13 or R12 = R13) by L871 , XTUPLE_0:1;
L873: (R12 <= R13 & R13 < ( R13 ++ )) by L872 , QC_LANG1:22 , QC_LANG1:27 , QC_LANG1:def 34;
thus L874: thesis by L873 , QC_LANG1:29;
end;

end;
L866: S21[ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ];
L867: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R13 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ R17 , R13 , R25 , R23 ] in ( SepQuadruples R16 ) implies S21[ R17 , R13 , R25 , R23 ]))))) from Sepregression(L866 , L856 , L857 , L862);
thus L868: thesis by L867;
end;
theorem
L869: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies (not ( x. R11 ) in ( R23 .: R25 )))))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
assume L870: [ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 );
assume L871: ( x. R11 ) in ( R23 .: R25 );
L872: (R11 < R11 & R11 <= R11) by L871 , L870 , L855 , QC_LANG1:22;
thus L873: contradiction by L872 , QC_LANG1:25;
end;
theorem
L874: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R12 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) & ( x. R12 ) in ( R23 .: ( still_not-bound_in R16 ) )) implies R12 < R11))))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R12 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
defpred S22[ (Element of ( CQC-WFF R1 )) , (QC-symbol of R1) , (Finite_Subset of ( bound_QC-variables R1 )) , Function ] means (for R12 being (QC-symbol of R1) holds (( x. R12 ) in ( $4 .: ( still_not-bound_in R16 ) ) implies R12 < $2));
L875:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
let R13 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume L876: [ ( R17 '&' R18 ) , R13 , R25 , R23 ] in ( SepQuadruples R16 );
assume L877: S22[ ( R17 '&' R18 ) , R13 , R25 , R23 ];
thus L878: S22[ R17 , R13 , R25 , R23 ] by L877;
thus L879: S22[ R18 , ( R13 + ( QuantNbr R17 ) ) , R25 , R23 ]
proof
let R12 being (QC-symbol of R1);
L880: R13 <= ( R13 + ( QuantNbr R17 ) ) by QC_LANG1:31;
assume L881: ( x. R12 ) in ( R23 .: ( still_not-bound_in R16 ) );
thus L882: thesis by L881 , L877 , L880 , QC_LANG1:30;
end;

end;
L880: S22[ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ]
proof
let R12 being (QC-symbol of R1);
assume L881: ( x. R12 ) in ( ( id ( bound_QC-variables R1 ) ) .: ( still_not-bound_in R16 ) );
L882: ( ( id ( bound_QC-variables R1 ) ) .: ( still_not-bound_in R16 ) ) = ( still_not-bound_in R16 ) by FUNCT_1:92;
thus L883: thesis by L882 , L881 , L495;
end;
L884:
now
let R17 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
let R13 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L885: [ ( All (R20 , R17) ) , R13 , R25 , R23 ] in ( SepQuadruples R16 );
assume L886: S22[ ( All (R20 , R17) ) , R13 , R25 , R23 ];
thus L887: S22[ R17 , ( R13 ++ ) , ( R25 \/ {. R20 .} ) , ( R23 +* ( R20 .--> ( x. R13 ) ) ) ]
proof
let R12 being (QC-symbol of R1);
assume L888: ( x. R12 ) in ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: ( still_not-bound_in R16 ) );
L889: ( ( R23 +* ( R20 .--> ( x. R13 ) ) ) .: ( still_not-bound_in R16 ) ) c= ( ( R23 .: ( still_not-bound_in R16 ) ) \/ { ( x. R13 ) } ) by L20;
L890: (( x. R12 ) in ( R23 .: ( still_not-bound_in R16 ) ) or ( x. R12 ) in { ( x. R13 ) }) by L889 , L888 , XBOOLE_0:def 3;
L891: (R12 < R13 or ( x. R12 ) = ( x. R13 )) by L890 , L886 , TARSKI:def 1;
L892: (R12 < R13 or R12 = R13) by L891 , XTUPLE_0:1;
L893: (R12 <= R13 & R13 < ( R13 ++ )) by L892 , QC_LANG1:22 , QC_LANG1:27 , QC_LANG1:def 34;
thus L894: thesis by L893 , QC_LANG1:29;
end;

end;
L888: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R13 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (([ ( 'not' R17 ) , R13 , R25 , R23 ] in ( SepQuadruples R16 ) & S22[ ( 'not' R17 ) , R13 , R25 , R23 ]) implies S22[ R17 , R13 , R25 , R23 ])))));
L889: (for R17 being (Element of ( CQC-WFF R1 )) holds (for R13 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ R17 , R13 , R25 , R23 ] in ( SepQuadruples R16 ) implies S22[ R17 , R13 , R25 , R23 ]))))) from Sepregression(L880 , L888 , L875 , L884);
thus L890: thesis by L889;
end;
theorem
L891: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R12 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) & ( x. R12 ) in ( R23 .: ( still_not-bound_in R17 ) )) implies R12 < R11))))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R12 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
assume that
L892: [ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 )
and
L893: ( x. R12 ) in ( R23 .: ( still_not-bound_in R17 ) );
L894: ( R23 .: ( still_not-bound_in R17 ) ) c= ( R23 .: ( ( still_not-bound_in R16 ) \/ R25 ) ) by L892 , L838 , RELAT_1:123;
L895: ( x. R12 ) in ( R23 .: ( ( still_not-bound_in R16 ) \/ R25 ) ) by L894 , L893;
L896: ( x. R12 ) in ( ( R23 .: ( still_not-bound_in R16 ) ) \/ ( R23 .: R25 ) ) by L895 , RELAT_1:120;
L897: (( x. R12 ) in ( R23 .: ( still_not-bound_in R16 ) ) or ( x. R12 ) in ( R23 .: R25 )) by L896 , XBOOLE_0:def 3;
thus L898: thesis by L897 , L892 , L855 , L874;
end;
theorem
L899: (for R1 being QC-alphabet holds (for R11 being (QC-symbol of R1) holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds ([ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies (not ( x. R11 ) in ( R23 .: ( still_not-bound_in R17 ) )))))))))
proof
let R1 being QC-alphabet;
let R11 being (QC-symbol of R1);
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
assume L900: [ R17 , R11 , R25 , R23 ] in ( SepQuadruples R16 );
assume L901: ( x. R11 ) in ( R23 .: ( still_not-bound_in R17 ) );
L902: (R11 < R11 & R11 <= R11) by L901 , L900 , L891 , QC_LANG1:22;
thus L903: contradiction by L902 , QC_LANG1:25;
end;
theorem
L904: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds ( still_not-bound_in R16 ) = ( still_not-bound_in ( SepVar R16 ) )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
defpred S23[ (Element of ( CQC-WFF R1 )) ] means (for R11 being (QC-symbol of R1) holds (for R25 being (Finite_Subset of ( bound_QC-variables R1 )) holds (for R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) holds ([ $1 , R11 , R25 , R23 ] in ( SepQuadruples R16 ) implies ( R23 .: ( still_not-bound_in $1 ) ) = ( still_not-bound_in (( (( ( SepFunc R1 ) . $1 ) qua (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ))) . ([ R11 , R23 ] qua (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :])) ) qua (Element of ( CQC-WFF R1 ))) )))));
L905: [ R16 , ( index R16 ) , ( {}. ( bound_QC-variables R1 ) ) , ( id ( bound_QC-variables R1 ) ) ] in ( SepQuadruples R16 ) by L624;
L906:
now
let R18 being (Element of ( CQC-WFF R1 ));
reconsider D71 = ( ( SepFunc R1 ) . R18 ) as (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 ));
assume L907: S23[ R18 ];
L908: ( ( SepFunc R1 ) . ( 'not' R18 ) ) = ( NEGATIVE D71 ) by L350;
thus L909: S23[ ( 'not' R18 ) ]
proof
let R12 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume L910: [ ( 'not' R18 ) , R12 , R25 , R23 ] in ( SepQuadruples R16 );
L911: [ R18 , R12 , R25 , R23 ] in ( SepQuadruples R16 ) by L910 , L627;
set D72 = [ R12 , R23 ];
reconsider D73 = ( D71 . D72 ) as (Element of ( CQC-WFF R1 ));
L912: ( still_not-bound_in D73 ) = ( still_not-bound_in ( 'not' D73 ) ) by QC_LANG3:7;
L913: ( still_not-bound_in R18 ) = ( still_not-bound_in ( 'not' R18 ) ) by QC_LANG3:7;
L914: ( ( NEGATIVE D71 ) . D72 ) = ( 'not' D73 ) by L276;
thus L915: thesis by L914 , L908 , L907 , L913 , L912 , L911;
end;

end;
L910:
now
let R4 being (Element of ( NAT ));
let C173 being (CQC-variable_list of R4 , R1);
let C174 being (QC-pred_symbol of R4 , R1);
thus L911: S23[ ( C174 ! C173 ) ]
proof
let R12 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L912: [ ( C174 ! C173 ) , R12 , R25 , R23 ] in ( SepQuadruples R16 );
set D74 = ( R23 * C173 );
L913: ( R23 .: { ( C173 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C173 ) & ( C173 . R2 ) in ( bound_QC-variables R1 )) } ) = { ( D74 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len D74 ) & ( D74 . R3 ) in ( bound_QC-variables R1 )) }
proof
L914: ( len D74 ) = R4 by CARD_1:def 7
.= ( len C173 ) by CARD_1:def 7;
thus L915: ( R23 .: { ( C173 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C173 ) & ( C173 . R2 ) in ( bound_QC-variables R1 )) } ) c= { ( D74 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len D74 ) & ( D74 . R3 ) in ( bound_QC-variables R1 )) }
proof
let C175 being set;
assume L916: C175 in ( R23 .: { ( C173 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C173 ) & ( C173 . R2 ) in ( bound_QC-variables R1 )) } );
consider C176 being set such that L917: (C176 in ( dom R23 ) & C176 in { ( C173 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len C173 ) & ( C173 . R2 ) in ( bound_QC-variables R1 )) } & C175 = ( R23 . C176 )) by L916 , FUNCT_1:def 6;
consider R2 being (Element of ( NAT )) such that L918: C176 = ( C173 . R2 ) and L919: 1 <= R2 and L920: R2 <= ( len C173 ) and L921: ( C173 . R2 ) in ( bound_QC-variables R1 ) by L917;
L922: R2 in ( dom C173 ) by L919 , L920 , FINSEQ_3:25;
L923: ( R23 . ( C173 . R2 ) ) = ( D74 . R2 ) by L922 , FUNCT_1:13;
L924: ( D74 . R2 ) in ( bound_QC-variables R1 ) by L914 , L919 , L920 , L269;
thus L925: thesis by L924 , L914 , L917 , L918 , L919 , L920 , L923;
end;

let C177 being set;
assume L926: C177 in { ( D74 . R2 ) where R2 is (Element of ( NAT )) : (1 <= R2 & R2 <= ( len D74 ) & ( D74 . R2 ) in ( bound_QC-variables R1 )) };
consider R2 being (Element of ( NAT )) such that L927: C177 = ( D74 . R2 ) and L928: 1 <= R2 and L929: R2 <= ( len D74 ) and L930: ( D74 . R2 ) in ( bound_QC-variables R1 ) by L926;
L931: R2 in ( dom C173 ) by L914 , L928 , L929 , FINSEQ_3:25;
L932: ( D74 . R2 ) = ( R23 . ( C173 . R2 ) ) by L931 , FUNCT_1:13;
L933: ( C173 . R2 ) in ( bound_QC-variables R1 ) by L914 , L928 , L929 , L269;
L934: ( C173 . R2 ) in ( dom R23 ) by L933 , FUNCT_2:def 1;
L935: ( C173 . R2 ) in { ( C173 . R3 ) where R3 is (Element of ( NAT )) : (1 <= R3 & R3 <= ( len C173 ) & ( C173 . R3 ) in ( bound_QC-variables R1 )) } by L914 , L928 , L929 , L933;
thus L936: thesis by L935 , L927 , L934 , L932 , FUNCT_1:def 6;
end;
L937: ( R23 .: ( still_not-bound_in ( C174 ! C173 ) ) ) = ( R23 .: ( still_not-bound_in C173 ) ) by QC_LANG3:5
.= ( R23 .: ( variables_in (C173 , ( bound_QC-variables R1 )) ) ) by QC_LANG3:2
.= ( variables_in (D74 , ( bound_QC-variables R1 )) ) by L913
.= ( still_not-bound_in D74 ) by QC_LANG3:2
.= ( still_not-bound_in ( C174 ! D74 ) ) by QC_LANG3:5;
L938: ( ( ATOMIC (C174 , C173) ) . (R12 , R23) ) = ( C174 ! ( R23 * C173 ) ) by L333;
thus L939: thesis by L938 , L937 , L350;
end;

end;
L912:
now
let R18 being (Element of ( CQC-WFF R1 ));
let R20 being (Element of ( bound_QC-variables R1 ));
assume that
L913: S23[ R18 ];
thus L914: S23[ ( All (R20 , R18) ) ]
proof
reconsider D75 = ( ( SepFunc R1 ) . R18 ) as (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 ));
let R12 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L915: [ ( All (R20 , R18) ) , R12 , R25 , R23 ] in ( SepQuadruples R16 );
L916: [ R18 , ( R12 ++ ) , ( R25 \/ {. R20 .} ) , ( R23 +* ( R20 .--> ( x. R12 ) ) ) ] in ( SepQuadruples R16 ) by L915 , L633;
L917: ( R23 +* ( R20 .--> ( x. R12 ) ) ) is (Function of ( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) by L306;
reconsider D76 = ( R23 +* ( R20 .--> ( x. R12 ) ) ) as (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) )) by L917 , FUNCT_2:8;
reconsider D77 = ( D75 . (( R12 ++ ) , D76) ) as (Element of ( CQC-WFF R1 ));
L918: ( ( UNIVERSAL (R20 , D75) ) . (R12 , R23) ) = ( All (( x. R12 ) , D77) ) by L313;
L919: ( still_not-bound_in ( All (R20 , R18) ) ) = ( ( still_not-bound_in R18 ) \ { R20 } ) by QC_LANG3:12;
L920: (not ( x. R12 ) in ( R23 .: ( ( still_not-bound_in R18 ) \ { R20 } ) )) by L919 , L915 , L899;
thus L921: ( R23 .: ( still_not-bound_in ( All (R20 , R18) ) ) ) = ( D76 .: ( ( still_not-bound_in R18 ) \ { R20 } ) ) by L919 , L37
.= ( ( D76 .: ( still_not-bound_in R18 ) ) \ { ( x. R12 ) } ) by L920 , L57
.= ( ( still_not-bound_in D77 ) \ { ( x. R12 ) } ) by L913 , L916
.= ( still_not-bound_in ( All (( x. R12 ) , D77) ) ) by QC_LANG3:12
.= ( still_not-bound_in (( (( ( SepFunc R1 ) . ( All (R20 , R18) ) ) qua (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ))) . ([ R12 , R23 ] qua (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :])) ) qua (Element of ( CQC-WFF R1 ))) ) by L918 , L350;
end;

end;
L915:
now
let R18 being (Element of ( CQC-WFF R1 ));
let R19 being (Element of ( CQC-WFF R1 ));
assume that
L916: S23[ R18 ]
and
L917: S23[ R19 ];
thus L918: S23[ ( R18 '&' R19 ) ]
proof
reconsider D78 = ( ( SepFunc R1 ) . R18 ) , D79 = ( ( SepFunc R1 ) . R19 ) as (Function of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 ));
let R12 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L919: [ ( R18 '&' R19 ) , R12 , R25 , R23 ] in ( SepQuadruples R16 );
reconsider D80 = ( D78 . (R12 , R23) ) , D81 = ( D79 . (( R12 + ( QuantNbr R18 ) ) , R23) ) as (Element of ( CQC-WFF R1 ));
L920: ( ( CON (D78 , D79 , ( QuantNbr R18 )) ) . (R12 , R23) ) = ( D80 '&' D81 ) by L289;
L921: [ R18 , R12 , R25 , R23 ] in ( SepQuadruples R16 ) by L919 , L630;
L922: ( R23 .: ( still_not-bound_in R18 ) ) = ( still_not-bound_in D80 ) by L921 , L916;
L923: [ R19 , ( R12 + ( QuantNbr R18 ) ) , R25 , R23 ] in ( SepQuadruples R16 ) by L919 , L630;
L924: ( R23 .: ( still_not-bound_in R19 ) ) = ( still_not-bound_in D81 ) by L923 , L917;
thus L925: ( R23 .: ( still_not-bound_in ( R18 '&' R19 ) ) ) = ( R23 .: ( ( still_not-bound_in R18 ) \/ ( still_not-bound_in R19 ) ) ) by QC_LANG3:10
.= ( ( still_not-bound_in D80 ) \/ ( still_not-bound_in D81 ) ) by L922 , L924 , RELAT_1:120
.= ( still_not-bound_in ( D80 '&' D81 ) ) by QC_LANG3:10
.= ( still_not-bound_in (( (( ( SepFunc R1 ) . ( R18 '&' R19 ) ) qua (Element of ( Funcs ([: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] , ( CQC-WFF R1 )) ))) . ([ R12 , R23 ] qua (Element of [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :])) ) qua (Element of ( CQC-WFF R1 ))) ) by L920 , L350;
end;

end;
L919: ( ( SepFunc R1 ) . ( VERUM R1 ) ) = ( [: ( QC-symbols R1 ) , ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ) :] --> ( VERUM R1 ) ) by L350;
L920: S23[ ( VERUM R1 ) ]
proof
let R13 being (QC-symbol of R1);
let R25 being (Finite_Subset of ( bound_QC-variables R1 ));
let R23 being (Element of ( Funcs (( bound_QC-variables R1 ) , ( bound_QC-variables R1 )) ));
assume that
L921: [ ( VERUM R1 ) , R13 , R25 , R23 ] in ( SepQuadruples R16 );
L922: ( still_not-bound_in ( VERUM R1 ) ) = ( {} ) by QC_LANG3:3;
L923: ( R23 .: ( still_not-bound_in ( VERUM R1 ) ) ) = ( {} ) by L922;
thus L924: thesis by L923 , L922 , L919 , FUNCOP_1:7;
end;
L925: (for R17 being (Element of ( CQC-WFF R1 )) holds S23[ R17 ]) from CQCInd(L920 , L910 , L906 , L915 , L912);
thus L926: ( still_not-bound_in R16 ) = ( ( id ( bound_QC-variables R1 ) ) .: ( still_not-bound_in R16 ) ) by FUNCT_1:92
.= ( still_not-bound_in ( SepVar R16 ) ) by L925 , L905;
end;
theorem
L927: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds ( index R16 ) = ( index ( SepVar R16 ) )))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
L928: ( still_not-bound_in R16 ) = ( still_not-bound_in ( SepVar R16 ) ) by L904;
thus L929: thesis by L928;
end;
definition
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
pred R16 , R17 are_similar 
means
:L930: ( SepVar R16 ) = ( SepVar R17 )
;reflexivity
;
symmetry
;
end;
theorem
L932: (for R1 being QC-alphabet holds (for R16 being (Element of ( CQC-WFF R1 )) holds (for R17 being (Element of ( CQC-WFF R1 )) holds (for R18 being (Element of ( CQC-WFF R1 )) holds ((R16 , R17 are_similar  & R17 , R18 are_similar ) implies R16 , R18 are_similar )))))
proof
let R1 being QC-alphabet;
let R16 being (Element of ( CQC-WFF R1 ));
let R17 being (Element of ( CQC-WFF R1 ));
let R18 being (Element of ( CQC-WFF R1 ));
assume that
L933: R16 , R17 are_similar 
and
L934: R17 , R18 are_similar ;
L935: ( SepVar R17 ) = ( SepVar R18 ) by L934 , L930;
L936: ( SepVar R16 ) = ( SepVar R17 ) by L933 , L930;
thus L937: thesis by L936 , L935 , L930;
end;
