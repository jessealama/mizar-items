:: The Fundamental Properties of Natural Numbers
::  by Grzegorz Bancerek
::
:: Received January 11, 1989
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, REAL_1, SUBSET_1, CARD_1, ARYTM_3, XREAL_0,
      TARSKI, RELAT_1, XXREAL_0, XCMPLX_0, ARYTM_1, XBOOLE_0, FINSET_1,
      FUNCT_1, NAT_1, FUNCOP_1, PBOOLE, PARTFUN1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, FINSET_1, CARD_1, PBOOLE,
      NUMBERS, XCMPLX_0, XREAL_0, REAL_1, XXREAL_0, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCOP_1, FUNCT_2;
 constructors NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, CARD_1, WELLORD2, FUNCT_2,
      PARTFUN1, FUNCOP_1, FUNCT_4, ENUMSET1, RELSET_1, PBOOLE;
 registrations SUBSET_1, ORDINAL1, NUMBERS, XXREAL_0, XREAL_0, REAL_1, CARD_1,
      RELSET_1, FUNCT_2, PBOOLE;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, XBOOLE_0, CARD_1, RELAT_1, FUNCT_1;
 theorems AXIOMS, ORDINAL1, XCMPLX_1, XREAL_1, XXREAL_0, TARSKI, ORDINAL2,
      XBOOLE_1, XBOOLE_0, CARD_1, FUNCT_2, FUNCT_1, FUNCOP_1, PBOOLE, RELSET_1,
      RELAT_1, PARTFUN1;
 schemes SUBSET_1, ORDINAL2, FUNCT_2, FRAENKEL, PBOOLE;

begin
theorem
L1: (for R14 being (Subset of ( REAL )) holds ((( 0 ) in R14 & (for R1 being Real holds (R1 in R14 implies ( R1 + 1 ) in R14))) implies (for R6 being Nat holds R6 in R14)))
proof
let C1 being (Subset of ( REAL ));
assume that
L2: ( 0 ) in C1;
assume L3: (for R1 being Real holds (R1 in C1 implies ( R1 + 1 ) in C1));
L4: (for B1 being  real number holds (B1 in C1 implies ( B1 + 1 ) in C1)) by L3;
L5: ( NAT ) c= C1 by L4 , L2 , AXIOMS:3;
let R6 being Nat;
L6: R6 in ( NAT ) by ORDINAL1:def 12;
thus L7: thesis by L6 , L5;
end;
registration
let C2 , C3 being Nat;
cluster ( C2 + C3 ) ->  natural;
coherence
proof
defpred S1[ Real ] means (ex R3 being Nat st ($1 = R3 & ( C2 + R3 ) is  natural));
consider R14 being (Subset of ( REAL )) such that L8: (for R1 being Real holds (R1 in R14 iff S1[ R1 ])) from SUBSET_1:sch 3;
L9:
now
let R1 being Real;
assume L10: R1 in R14;
consider R3 being Nat such that L11: R1 = R3 and L12: ( C2 + R3 ) is  natural by L10 , L8;
L13: ( ( C2 + R3 ) + 1 ) = ( C2 + ( R3 + 1 ) );
reconsider D1 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
L14: ( C2 + D1 ) is (Element of ( NAT )) by L12 , ORDINAL1:def 12;
L15: (( D1 + 1 ) is (Element of ( NAT )) & ( ( C2 + D1 ) + 1 ) is (Element of ( NAT ))) by L14 , AXIOMS:2;
thus L16: ( R1 + 1 ) in R14 by L15 , L8 , L11 , L13;
end;
L17: ( C2 + ( 0 ) ) = C2;
L18: ( 0 ) in R14 by L17 , L8;
L19: C3 in R14 by L18 , L9 , L1;
L20: (ex R5 being Nat st (C3 = R5 & ( C2 + R5 ) is  natural)) by L19 , L8;
thus L21: thesis by L20;
end;
end;
definition
let C4 being Nat;
let C5 being (Element of ( NAT ));
redefine func C4 + C5 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
definition
let C6 being (Element of ( NAT ));
let C7 being Nat;
redefine func C6 + C7 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
::$N The Principle of Mathematical Induction
scheme Ind { P1[Nat] } : (for B2 being (Element of ( NAT )) holds P1[ B2 ])
provided
L25: P1[ ( 0 ) ]
and
L26: (for B3 being (Element of ( NAT )) holds (P1[ B3 ] implies P1[ ( B3 + 1 ) ]))
proof
let R3 being Nat;
defpred S2[ Real ] means (ex R3 being Nat st (P1[ R3 ] & R3 = $1));
consider R14 being (Subset of ( REAL )) such that L27: (for R1 being Real holds (R1 in R14 iff S2[ R1 ])) from SUBSET_1:sch 3;
L28: (for R1 being Real holds (R1 in R14 implies ( R1 + 1 ) in R14))
proof
let R1 being Real;
assume L29: R1 in R14;
consider R3 being Nat such that L30: P1[ R3 ] and L31: R3 = R1 by L29 , L27;
reconsider D2 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
L32: P1[ ( D2 + 1 ) ] by L26 , L30;
thus L33: thesis by L32 , L27 , L31;
end;
L34: ( 0 ) in R14 by L25 , L27;
L35: R3 in R14 by L34 , L28 , L1;
L36: (ex R6 being Nat st (P1[ R6 ] & R6 = R3)) by L35 , L27;
thus L37: thesis by L36;
end;
scheme NatInd { P2[Nat] } : (for B4 being Nat holds P2[ B4 ])
provided
L38: P2[ ( 0 ) ]
and
L39: (for B5 being Nat holds (P2[ B5 ] implies P2[ ( B5 + 1 ) ]))
proof
L40: (for B6 being (Element of ( NAT )) holds (P2[ B6 ] implies P2[ ( B6 + 1 ) ])) by L39;
let C8 being Nat;
L41: C8 is (Element of ( NAT )) by ORDINAL1:def 12;
L42: P2[ ( 0 ) ] by L38;
L43: (for B7 being (Element of ( NAT )) holds P2[ B7 ]) from Ind(L42 , L40);
thus L44: thesis by L43 , L41;
end;
registration
let C9 , C10 being Nat;
cluster ( C9 * C10 ) ->  natural;
coherence
proof
defpred S3[ Nat ] means ( C9 * $1 ) is  natural;
L45: (for B8 being Nat holds (S3[ B8 ] implies S3[ ( B8 + 1 ) ]))
proof
let C11 being Nat;
assume L46: S3[ C11 ];
reconsider D3 = ( C9 * C11 ) as Nat by L46;
L47: ( D3 + C9 ) is Nat;
thus L48: thesis by L47;
end;
L49: S3[ ( 0 ) ];
L50: (for B9 being Nat holds S3[ B9 ]) from NatInd(L49 , L45);
thus L51: thesis by L50;
end;
end;
definition
let C12 being Nat;
let C13 being (Element of ( NAT ));
redefine func C12 * C13 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
definition
let C14 being (Element of ( NAT ));
let C15 being Nat;
redefine func C14 * C15 -> (Element of ( NAT ));

coherence by ORDINAL1:def 12;
end;
theorem
L55: (for R9 being Nat holds ( 0 ) <= R9)
proof
let R9 being Nat;
defpred S4[ Nat ] means ( 0 ) <= $1;
L56: (for R6 being Nat holds (S4[ R6 ] implies S4[ ( R6 + 1 ) ]));
L57: S4[ ( 0 ) ];
L58: (for R3 being Nat holds S4[ R3 ]) from NatInd(L57 , L56);
thus L59: thesis by L58;
end;
theorem
L60: (for R9 being Nat holds (( 0 ) <> R9 implies ( 0 ) < R9)) by L55;
theorem
L61: (for R8 being Nat holds (for R9 being Nat holds (for R10 being Nat holds (R9 <= R10 implies ( R9 * R8 ) <= ( R10 * R8 )))))
proof
let R8 being Nat;
let R9 being Nat;
let R10 being Nat;
assume L62: R9 <= R10;
L63: ( 0 ) <= R8 by L55;
thus L64: thesis by L63 , L62 , XREAL_1:64;
end;
theorem
L65: (for R9 being Nat holds ( 0 ) < ( R9 + 1 ))
proof
let R9 being Nat;
assume L66: ( 0 ) >= ( R9 + 1 );
L67: ( 0 ) <= R9 by L55;
thus L68: contradiction by L67 , L66;
end;
theorem
L69: (for R9 being Nat holds (R9 = ( 0 ) or (ex R3 being Nat st R9 = ( R3 + 1 ))))
proof
let R9 being Nat;
defpred S5[ Nat ] means ($1 = ( 0 ) or (ex R3 being Nat st $1 = ( R3 + 1 )));
L70: (for R8 being Nat holds (S5[ R8 ] implies S5[ ( R8 + 1 ) ]));
L71: S5[ ( 0 ) ];
L72: (for R9 being Nat holds S5[ R9 ]) from NatInd(L71 , L70);
thus L73: thesis by L72;
end;
theorem
L74: (for R9 being Nat holds (for R10 being Nat holds (( R9 + R10 ) = ( 0 ) implies (R9 = ( 0 ) & R10 = ( 0 )))))
proof
let R9 being Nat;
let R10 being Nat;
assume L75: ( R9 + R10 ) = ( 0 );
L76: (( 0 ) <= R9 & ( 0 ) <= R10) by L55;
thus L77: thesis by L76 , L75;
end;
registration
cluster non  zero for Nat;
existence
proof
take 1;
thus L78: thesis;
end;
end;
registration
let C16 being Nat;
let C17 being non  zero Nat;
cluster ( C16 + C17 ) -> non  zero;
coherence by L74;
cluster ( C17 + C16 ) -> non  zero;
coherence;
end;
scheme DefbyInd { F1() -> Nat , F2(Nat , Nat) -> Nat , P3[Nat , Nat] } : ((for B10 being Nat holds (ex B11 being Nat st P3[ B10 , B11 ])) & (for B12 , B13 , B14 being Nat holds ((P3[ B12 , B13 ] & P3[ B12 , B14 ]) implies B13 = B14)))
provided
L81: (for B15 , B16 being Nat holds (P3[ B15 , B16 ] iff ((B15 = ( 0 ) & B16 = F1()) or (ex B17 , B18 being Nat st (B15 = ( B17 + 1 ) & P3[ B17 , B18 ] & B16 = F2(B15 , B18))))))
proof
reconsider D4 = F1() as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S6[ Nat ] means (ex B19 being Nat st P3[ $1 , B19 ]);
L82: (for B20 being Nat holds (S6[ B20 ] implies S6[ ( B20 + 1 ) ]))
proof
let C18 being Nat;
given C19 being Nat such that
L83: P3[ C18 , C19 ];

reconsider D5 = F2(( C18 + 1 ) , C19) as (Element of ( NAT )) by ORDINAL1:def 12;
take D5;
thus L84: thesis by L81 , L83;
end;
L85: P3[ ( 0 ) , D4 ] by L81;
L86: S6[ ( 0 ) ] by L85;
thus L87: (for B21 being Nat holds S6[ B21 ]) from NatInd(L86 , L82);
defpred S7[ Nat ] means (for B22 , B23 being Nat holds ((P3[ $1 , B22 ] & P3[ $1 , B23 ]) implies B22 = B23));
L88: (for B24 being Nat holds (S7[ B24 ] implies S7[ ( B24 + 1 ) ]))
proof
let C20 being Nat;
assume that
L89: (for B25 , B26 being Nat holds ((P3[ C20 , B25 ] & P3[ C20 , B26 ]) implies B25 = B26));
let C21 , C22 being Nat;
assume L90: (P3[ ( C20 + 1 ) , C21 ] & P3[ ( C20 + 1 ) , C22 ]);
L91: ((ex B27 , B28 being Nat st (( C20 + 1 ) = ( B27 + 1 ) & P3[ B27 , B28 ] & C21 = F2(( C20 + 1 ) , B28))) & (ex B29 , B30 being Nat st (( C20 + 1 ) = ( B29 + 1 ) & P3[ B29 , B30 ] & C22 = F2(( C20 + 1 ) , B30)))) by L90 , L81;
thus L92: thesis by L91 , L89;
end;
L93: S7[ ( 0 ) ]
proof
let C23 , C24 being Nat;
assume that
L94: P3[ ( 0 ) , C23 ]
and
L95: P3[ ( 0 ) , C24 ];
L96: (not (ex B31 , B32 being Nat st (( 0 ) = ( B31 + 1 ) & P3[ B31 , B32 ] & C23 = F2(( 0 ) , B32))));
L97: ((not (ex B33 , B34 being Nat st (( 0 ) = ( B33 + 1 ) & P3[ B33 , B34 ] & C24 = F2(( 0 ) , B34)))) & C23 = F1()) by L96 , L81 , L94;
thus L98: thesis by L97 , L81 , L95;
end;
thus L99: (for B35 being Nat holds S7[ B35 ]) from NatInd(L93 , L88);
end;
theorem
L100: (for R9 being Nat holds (for R10 being Nat holds (R9 <= ( R10 + 1 ) implies (R9 <= R10 or R9 = ( R10 + 1 )))))
proof
let R9 being Nat;
let R10 being Nat;
defpred S8[ Nat ] means (for R10 being Nat holds ($1 <= ( R10 + 1 ) implies ($1 <= R10 or $1 = ( R10 + 1 ))));
L101: (for R9 being Nat holds (S8[ R9 ] implies S8[ ( R9 + 1 ) ]))
proof
let R9 being Nat;
assume that
L102: (for R10 being Nat holds (R9 <= ( R10 + 1 ) implies (R9 <= R10 or R9 = ( R10 + 1 ))));
let R10 being Nat;
assume L103: ( R9 + 1 ) <= ( R10 + 1 );
L104:
now
given R3 being Nat such that
L105: R10 = ( R3 + 1 );

L106: R9 <= ( R3 + 1 ) by L103 , L105 , XREAL_1:6;
L107: (R9 <= R3 or R9 = ( R3 + 1 )) by L106 , L102;
thus L108: thesis by L107 , L105 , XREAL_1:6;
end;
L109:
now
L110: ( 0 ) <= R9 by L55;
assume L111: R10 = ( 0 );
L112: R9 <= ( 0 ) by L111 , L103 , XREAL_1:6;
thus L113: thesis by L112 , L111 , L110;
end;
thus L114: thesis by L109 , L104 , L69;
end;
L115: S8[ ( 0 ) ] by L55;
L116: (for R9 being Nat holds S8[ R9 ]) from NatInd(L115 , L101);
thus L117: thesis by L116;
end;
theorem
L118: (for R9 being Nat holds (for R10 being Nat holds ((R9 <= R10 & R10 <= ( R9 + 1 )) implies (R9 = R10 or R10 = ( R9 + 1 )))))
proof
let R9 being Nat;
let R10 being Nat;
assume that
L119: R9 <= R10
and
L120: R10 <= ( R9 + 1 );
L121: (R10 <= R9 or R10 = ( R9 + 1 )) by L120 , L100;
thus L122: thesis by L121 , L119 , XXREAL_0:1;
end;
theorem
L123: (for R9 being Nat holds (for R10 being Nat holds (R9 <= R10 implies (ex R3 being Nat st R10 = ( R9 + R3 )))))
proof
let R9 being Nat;
let R10 being Nat;
defpred S9[ Nat ] means (R9 <= $1 implies (ex R3 being Nat st $1 = ( R9 + R3 )));
L124: (for R10 being Nat holds (S9[ R10 ] implies S9[ ( R10 + 1 ) ]))
proof
let R10 being Nat;
assume that
L125: (R9 <= R10 implies (ex R3 being Nat st R10 = ( R9 + R3 )));
L126:
now
assume L127: R9 <= R10;
consider R3 being Nat such that L128: R10 = ( R9 + R3 ) by L127 , L125;
L129: ( ( R9 + R3 ) + 1 ) = ( R9 + ( R3 + 1 ) );
thus L130: thesis by L129 , L128;
end;
L131:
now
assume L132: R9 = ( R10 + 1 );
L133: ( R10 + 1 ) = ( R9 + ( 0 ) ) by L132;
thus L134: thesis by L133;
end;
assume L135: R9 <= ( R10 + 1 );
thus L136: thesis by L135 , L126 , L131 , L100;
end;
L137: S9[ ( 0 ) ]
proof
assume L138: R9 <= ( 0 );
take ( 0 );
thus L139: thesis by L138 , L55;
end;
L140: (for R10 being Nat holds S9[ R10 ]) from NatInd(L137 , L124);
thus L141: thesis by L140;
end;
theorem
L142: (for R9 being Nat holds (for R10 being Nat holds R9 <= ( R9 + R10 )))
proof
let R9 being Nat;
let R10 being Nat;
L143: (( ( 0 ) + R9 ) = R9 & ( 0 ) <= R10) by L55;
thus L144: thesis by L143 , XREAL_1:7;
end;
scheme CompInd { P4[Nat] } : (for B36 being Nat holds P4[ B36 ])
provided
L145: (for B37 being Nat holds ((for B38 being Nat holds (B38 < B37 implies P4[ B38 ])) implies P4[ B37 ]))
proof
let C25 being Nat;
defpred S10[ Nat ] means (for B39 being Nat holds (B39 < $1 implies P4[ B39 ]));
L146: (for B40 being Nat holds (S10[ B40 ] implies S10[ ( B40 + 1 ) ]))
proof
let C26 being Nat;
assume L147: (for B41 being Nat holds (B41 < C26 implies P4[ B41 ]));
let C27 being Nat;
assume L148: C27 < ( C26 + 1 );
L149: C27 <= C26 by L148 , L100;
L150: (C27 < C26 or (C27 = C26 & C27 <= C26)) by L149 , XXREAL_0:1;
thus L151: thesis by L150 , L145 , L147;
end;
L152: S10[ ( 0 ) ] by L55;
L153: (for B42 being Nat holds S10[ B42 ]) from NatInd(L152 , L146);
L154: (for B43 being Nat holds (B43 < C25 implies P4[ B43 ])) by L153;
thus L155: thesis by L154 , L145;
end;
scheme Min { P5[Nat] } : (ex B44 being Nat st (P5[ B44 ] & (for B45 being Nat holds (P5[ B45 ] implies B44 <= B45))))
provided
L156: (ex B46 being Nat st P5[ B46 ])
proof
defpred S11[ Nat ] means (not P5[ $1 ]);
assume L157: (not thesis);
L158: (for B47 being Nat holds ((for B48 being Nat holds (B48 < B47 implies S11[ B48 ])) implies S11[ B47 ]))
proof
let C28 being Nat;
assume L159: (for B49 being Nat holds (B49 < C28 implies (not P5[ B49 ])));
L160: ((not (ex B50 being Nat st (P5[ B50 ] & (not C28 <= B50)))) implies (not P5[ C28 ])) by L157;
thus L161: thesis by L160 , L159;
end;
L162: (for B51 being Nat holds S11[ B51 ]) from CompInd(L158);
thus L163: contradiction by L162 , L156;
end;
scheme Max { P6[Nat] , F3() -> Nat } : (ex B52 being Nat st (P6[ B52 ] & (for B53 being Nat holds (P6[ B53 ] implies B53 <= B52))))
provided
L164: (for B54 being Nat holds (P6[ B54 ] implies B54 <= F3()))
and
L165: (ex B55 being Nat st P6[ B55 ])
proof
defpred S12[ Nat ] means (for B56 being Nat holds (P6[ B56 ] implies B56 <= $1));
L166: (ex B57 being Nat st S12[ B57 ]) by L164;
consider C29 being Nat such that L167: S12[ C29 ] and L168: (for B58 being Nat holds (S12[ B58 ] implies C29 <= B58)) from Min(L166);
take C29;
thus L169: P6[ C29 ]
proof
consider C30 being Nat such that L170: P6[ C30 ] by L165;
L171: C30 <= C29 by L167 , L170;
assume L172: (not P6[ C29 ]);
L173: C30 <> C29 by L172 , L170;
L174: C29 <> ( 0 ) by L173 , L171 , L55;
consider R5 being Nat such that L175: C29 = ( R5 + 1 ) by L174 , L69;
L176: (for B59 being Nat holds (P6[ B59 ] implies B59 <= R5)) by L167 , L172 , L175 , L100;
L177: C29 <= R5 by L176 , L168;
L178: ( ( ( - R5 ) + R5 ) + 1 ) = ( ( - R5 ) + ( R5 + 1 ) );
thus L179: contradiction by L178 , L175 , L177 , XREAL_1:6;
end;

thus L180: thesis by L167;
end;
theorem
L181: (for R8 being Nat holds (for R9 being Nat holds (for R10 being Nat holds (R9 <= R10 implies R9 <= ( R10 + R8 )))))
proof
let R8 being Nat;
let R9 being Nat;
let R10 being Nat;
assume L182: R9 <= R10;
L183: ( R9 + R8 ) <= ( R10 + R8 ) by L182 , XREAL_1:7;
L184: ( 0 ) <= R8 by L55;
L185: ( R9 + ( 0 ) ) <= ( R9 + R8 ) by L184 , XREAL_1:7;
thus L186: thesis by L185 , L183 , XXREAL_0:2;
end;
theorem
L187: (for R9 being Nat holds (for R10 being Nat holds (R9 < ( R10 + 1 ) iff R9 <= R10)))
proof
let R9 being Nat;
let R10 being Nat;
thus L188: (R9 < ( R10 + 1 ) implies R9 <= R10) by L100;
assume L189: R9 <= R10;
L190:
now
L191: (( R10 + ( - R10 ) ) = ( 0 ) & ( ( R10 + 1 ) + ( - R10 ) ) = 1);
assume L192: R9 = ( R10 + 1 );
thus L193: contradiction by L192 , L189 , L191 , XREAL_1:6;
end;
L194: R9 <= ( R10 + 1 ) by L189 , L181;
thus L195: thesis by L194 , L190 , XXREAL_0:1;
end;
theorem
L196: (for R10 being Nat holds (R10 < 1 implies R10 = ( 0 )))
proof
let R10 being Nat;
assume L197: R10 < 1;
L198: R10 < ( ( 0 ) + 1 ) by L197;
L199: R10 <= ( 0 ) by L198 , L187;
assume L200: R10 <> ( 0 );
thus L201: thesis by L200 , L199 , L55;
end;
theorem
L202: (for R9 being Nat holds (for R10 being Nat holds (( R9 * R10 ) = 1 implies R9 = 1)))
proof
let R9 being Nat;
let R10 being Nat;
assume L203: ( R9 * R10 ) = 1;
L204: R9 <> ( 0 ) by L203;
consider R5 being Nat such that L205: R9 = ( R5 + 1 ) by L204 , L69;
L206: R10 <> ( 0 ) by L203;
consider R4 being Nat such that L207: R10 = ( R4 + 1 ) by L206 , L69;
L208: ( ( ( ( R5 * R4 ) + R5 ) + R4 ) + 1 ) = ( ( 0 ) + 1 ) by L203 , L205 , L207;
L209: ( ( R5 * R4 ) + R5 ) = ( 0 ) by L208;
thus L210: thesis by L209 , L205 , L208;
end;
theorem
L211: (for R3 being Nat holds (for R6 being Nat holds (R3 <> ( 0 ) implies R6 < ( R6 + R3 ))))
proof
let R3 being Nat;
let R6 being Nat;
assume L212: R3 <> ( 0 );
L213: R6 <> ( R6 + R3 ) by L212;
L214: R6 <= ( R6 + R3 ) by L181;
thus L215: thesis by L214 , L213 , XXREAL_0:1;
end;
scheme Regr { P7[Nat] } : P7[ ( 0 ) ]
provided
L216: (ex B60 being Nat st P7[ B60 ])
and
L217: (for B61 being Nat holds ((B61 <> ( 0 ) & P7[ B61 ]) implies (ex B62 being Nat st (B62 < B61 & P7[ B62 ]))))
proof
consider C31 being Nat such that L218: (P7[ C31 ] & (for B63 being Nat holds (P7[ B63 ] implies C31 <= B63))) from Min(L216);
L219:
now
assume L220: C31 <> ( 0 );
L221: (ex B64 being Nat st (B64 < C31 & P7[ B64 ])) by L220 , L217 , L218;
thus L222: contradiction by L221 , L218;
end;
thus L223: thesis by L219 , L218;
end;
theorem
L224: (for R5 being Nat holds (( 0 ) < R5 implies (for R6 being Nat holds (ex R3 being Nat st (ex R12 being Nat st (R6 = ( ( R5 * R3 ) + R12 ) & R12 < R5))))))
proof
let R5 being Nat;
defpred S13[ Nat ] means (ex R3 being Nat st (ex R12 being Nat st ($1 = ( ( R5 * R3 ) + R12 ) & R12 < R5)));
assume L225: ( 0 ) < R5;
L226: (for R6 being Nat holds (S13[ R6 ] implies S13[ ( R6 + 1 ) ]))
proof
let R6 being Nat;
given R11 being Nat , R13 being Nat such that
L227: R6 = ( ( R5 * R11 ) + R13 )
and
L228: R13 < R5;

L229: (( R13 + 1 ) < R5 implies (ex R3 being Nat st (ex R12 being Nat st (( R6 + 1 ) = ( ( R5 * R3 ) + R12 ) & R12 < R5))))
proof
assume L230: ( R13 + 1 ) < R5;
take D6 = R11;
take D7 = ( R13 + 1 );
thus L231: ( R6 + 1 ) = ( ( R5 * D6 ) + D7 ) by L227;
thus L232: thesis by L230;
end;
L233: (( R13 + 1 ) = R5 implies (ex R3 being Nat st (ex R12 being Nat st (( R6 + 1 ) = ( ( R5 * R3 ) + R12 ) & R12 < R5))))
proof
assume L234: ( R13 + 1 ) = R5;
take D8 = ( R11 + 1 );
take D9 = ( 0 );
thus L235: ( R6 + 1 ) = ( ( R5 * D8 ) + D9 ) by L227 , L234;
thus L236: thesis by L225;
end;
L237: ( R13 + 1 ) <= R5 by L228 , L187;
thus L238: thesis by L237 , L229 , L233 , XXREAL_0:1;
end;
L239: ( 0 ) = ( ( R5 * ( 0 ) ) + ( 0 ) );
L240: S13[ ( 0 ) ] by L239 , L225;
thus L241: (for R6 being Nat holds S13[ R6 ]) from NatInd(L240 , L226);
end;
theorem
L242: (for R3 being Nat holds (for R5 being Nat holds (for R6 being Nat holds (for R11 being Nat holds (for R12 being Nat holds (for R13 being Nat holds ((R6 = ( ( R5 * R3 ) + R12 ) & R12 < R5 & R6 = ( ( R5 * R11 ) + R13 ) & R13 < R5) implies (R3 = R11 & R12 = R13))))))))
proof
let R3 being Nat;
let R5 being Nat;
let R6 being Nat;
let R11 being Nat;
let R12 being Nat;
let R13 being Nat;
assume that
L243: R6 = ( ( R5 * R3 ) + R12 )
and
L244: R12 < R5
and
L245: R6 = ( ( R5 * R11 ) + R13 )
and
L246: R13 < R5;
L247:
now
assume L248: R11 <= R3;
consider C32 being Nat such that L249: R3 = ( R11 + C32 ) by L248 , L123;
L250: ( ( R5 * ( R11 + C32 ) ) + R12 ) = ( ( R5 * R11 ) + ( ( R5 * C32 ) + R12 ) );
L251: ( ( R5 * C32 ) + R12 ) = R13 by L250 , L243 , L245 , L249 , XCMPLX_1:2;
L252:
now
given C33 being Nat such that
L253: C32 = ( C33 + 1 );

L254: ( ( R5 * C32 ) + R12 ) = ( R5 + ( ( R5 * C33 ) + R12 ) ) by L253;
thus L255: contradiction by L254 , L246 , L251 , L142;
end;
L256: C32 = ( 0 ) by L252 , L69;
thus L257: R3 = R11 by L256 , L249;
thus L258: R12 = R13 by L243 , L245 , L249 , L256 , XCMPLX_1:2;
end;
L259:
now
assume L260: R3 <= R11;
consider C34 being Nat such that L261: R11 = ( R3 + C34 ) by L260 , L123;
L262: ( ( R5 * ( R3 + C34 ) ) + R13 ) = ( ( R5 * R3 ) + ( ( R5 * C34 ) + R13 ) );
L263: ( ( R5 * C34 ) + R13 ) = R12 by L262 , L243 , L245 , L261 , XCMPLX_1:2;
L264:
now
given C35 being Nat such that
L265: C34 = ( C35 + 1 );

L266: ( ( R5 * C34 ) + R13 ) = ( R5 + ( ( R5 * C35 ) + R13 ) ) by L265;
thus L267: contradiction by L266 , L244 , L263 , L142;
end;
L268: C34 = ( 0 ) by L264 , L69;
thus L269: R3 = R11 by L268 , L261;
thus L270: R12 = R13 by L243 , L245 , L261 , L268 , XCMPLX_1:2;
end;
thus L271: thesis by L259 , L247;
end;
registration
cluster  ->  ordinal for Nat;
coherence;
end;
registration
cluster non  empty  ordinal for (Subset of ( REAL ));
existence
proof
take ( NAT );
thus L273: thesis;
end;
end;
theorem
L275: (for R3 being Nat holds (for R6 being Nat holds (R3 < ( R3 + R6 ) iff 1 <= R6)))
proof
let R3 being Nat;
let R6 being Nat;
thus L276: (R3 < ( R3 + R6 ) implies 1 <= R6)
proof
assume L277: R3 < ( R3 + R6 );
assume L278: (not 1 <= R6);
L279: R6 = ( 0 ) by L278 , L196;
thus L280: thesis by L279 , L277;
end;

assume L281: 1 <= R6;
thus L282: thesis by L281 , L211;
end;
theorem
L283: (for R3 being Nat holds (for R6 being Nat holds (R3 < R6 implies ( R6 - 1 ) is (Element of ( NAT )))))
proof
let R3 being Nat;
let R6 being Nat;
assume L284: R3 < R6;
L285: ( R3 + 1 ) <= R6 by L284 , L187;
consider C36 being Nat such that L286: R6 = ( ( R3 + 1 ) + C36 ) by L285 , L123;
L287: ( R6 - 1 ) = ( R3 + C36 ) by L286;
thus L288: thesis by L287 , ORDINAL1:def 12;
end;
theorem
L289: (for R3 being Nat holds (for R6 being Nat holds (R3 <= R6 implies ( R6 - R3 ) is (Element of ( NAT )))))
proof
let R3 being Nat;
let R6 being Nat;
assume L290: R3 <= R6;
per cases  by L290 , XXREAL_0:1;
suppose L291: R3 < R6;

L292: ( R3 + 1 ) <= R6 by L291 , L187;
consider C37 being Nat such that L293: R6 = ( ( R3 + 1 ) + C37 ) by L292 , L123;
reconsider D10 = C37 as (Element of ( NAT )) by ORDINAL1:def 12;
L294: ( R6 - R3 ) = ( 1 + D10 ) by L293;
thus L295: thesis by L294;
end;
suppose L296: R3 = R6;

L297: ( R6 - R3 ) = ( 0 ) by L296;
thus L298: thesis by L297;
end;
end;
begin
theorem
L300: (for R5 being Nat holds (for R6 being Nat holds (R5 < ( R6 + 1 ) implies (R5 < R6 or R5 = R6))))
proof
let R5 being Nat;
let R6 being Nat;
assume L301: R5 < ( R6 + 1 );
L302: R5 <= R6 by L301 , L187;
thus L303: thesis by L302 , XXREAL_0:1;
end;
theorem
L304: (for R3 being Nat holds (R3 < 2 implies (R3 = ( 0 ) or R3 = 1)))
proof
let R3 being Nat;
assume L305: R3 < 2;
L306: R3 < ( 1 + 1 ) by L305;
thus L307: thesis by L306 , L196 , L300;
end;
registration
cluster non  zero for (Element of ( NAT ));
existence
proof
take 1;
thus L308: thesis;
end;
end;
registration
cluster  -> non  negative for (Element of ( NAT ));
coherence by L55;
end;
registration
cluster  -> non  negative for Nat;
coherence by L55;
end;
theorem
L312: (for R8 being Nat holds (for R9 being Nat holds (for R10 being Nat holds ((R9 <> ( 0 ) & R8 = ( R10 * R9 )) implies R10 <= R8))))
proof
let R8 being Nat;
let R9 being Nat;
let R10 being Nat;
assume L313: R9 <> ( 0 );
consider R3 being Nat such that L314: R9 = ( R3 + 1 ) by L313 , L69;
assume L315: R8 = ( R10 * R9 );
L316: R8 = ( ( R10 * R3 ) + ( R10 * 1 ) ) by L315 , L314;
thus L317: thesis by L316 , L142;
end;
scheme Ind1 { F4() -> Nat , P8[Nat] } : (for B65 being Nat holds (F4() <= B65 implies P8[ B65 ]))
provided
L318: P8[ F4() ]
and
L319: (for B66 being Nat holds (F4() <= B66 implies (P8[ B66 ] implies P8[ ( B66 + 1 ) ])))
proof
reconsider D11 = F4() as (Element of ( NAT )) by ORDINAL1:def 12;
defpred S14[ Nat ] means P8[ ( F4() + $1 ) ];
L320:
now
let C38 being (Element of ( NAT ));
assume L321: S14[ C38 ];
L322: P8[ ( ( D11 + C38 ) + 1 ) ] by L321 , L319 , L142;
thus L323: S14[ ( C38 + 1 ) ] by L322;
end;
let R9 being Nat;
assume L324: F4() <= R9;
consider C39 being Nat such that L325: R9 = ( F4() + C39 ) by L324 , L123;
L326: S14[ ( 0 ) ] by L318;
L327: (for B67 being (Element of ( NAT )) holds S14[ B67 ]) from Ind(L326 , L320);
L328: C39 in ( NAT ) by ORDINAL1:def 12;
thus L329: thesis by L328 , L327 , L325;
end;
scheme CompInd1 { F5() -> Nat , P9[Nat] } : (for B68 being Nat holds (B68 >= F5() implies P9[ B68 ]))
provided
L330: (for B69 being Nat holds ((B69 >= F5() & (for B70 being Nat holds ((B70 >= F5() & B70 < B69) implies P9[ B70 ]))) implies P9[ B69 ]))
proof
defpred S15[ Nat ] means (for B71 being Nat holds ((B71 >= F5() & B71 < $1) implies P9[ B71 ]));
L331: (for B72 being Nat holds (B72 >= F5() implies (S15[ B72 ] implies S15[ ( B72 + 1 ) ])))
proof
let C40 being Nat;
assume L332: C40 >= F5();
assume L333: (for B73 being Nat holds ((B73 >= F5() & B73 < C40) implies P9[ B73 ]));
let C41 being Nat;
assume that
L334: C41 >= F5()
and
L335: C41 < ( C40 + 1 );
L336: C41 <= C40 by L335 , L187;
L337: (C41 < C40 or C41 = C40) by L336 , XXREAL_0:1;
thus L338: thesis by L337 , L330 , L333 , L334;
end;
let C42 being Nat;
assume L339: C42 >= F5();
L340: S15[ F5() ];
L341: (for B74 being Nat holds (B74 >= F5() implies S15[ B74 ])) from Ind1(L340 , L331);
L342: (for B75 being Nat holds ((B75 >= F5() & B75 < C42) implies P9[ B75 ])) by L341 , L339;
thus L343: thesis by L342 , L330 , L339;
end;
theorem
L344: (for R6 being Nat holds (R6 <= 1 implies (R6 = ( 0 ) or R6 = 1)))
proof
let R6 being Nat;
assume L345: R6 <= 1;
assume that
L346: (not R6 = ( 0 ))
and
L347: (not R6 = 1);
L348: R6 < ( ( 0 ) + 1 ) by L345 , L347 , XXREAL_0:1;
thus L349: contradiction by L348 , L346 , L187;
end;
theorem
L350: (for R6 being Nat holds (R6 <= 2 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2)))
proof
let R6 being Nat;
assume L351: R6 <= 2;
L352: R6 <= ( 1 + 1 ) by L351;
thus L353: thesis by L352 , L100 , L344;
end;
theorem
L354: (for R6 being Nat holds (R6 <= 3 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3)))
proof
let R6 being Nat;
assume L355: R6 <= 3;
L356: R6 <= ( 2 + 1 ) by L355;
thus L357: thesis by L356 , L100 , L350;
end;
theorem
L358: (for R6 being Nat holds (R6 <= 4 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4)))
proof
let R6 being Nat;
assume L359: R6 <= 4;
L360: R6 <= ( 3 + 1 ) by L359;
thus L361: thesis by L360 , L100 , L354;
end;
theorem
L362: (for R6 being Nat holds (R6 <= 5 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5)))
proof
let R6 being Nat;
assume L363: R6 <= 5;
L364: R6 <= ( 4 + 1 ) by L363;
thus L365: thesis by L364 , L100 , L358;
end;
theorem
L366: (for R6 being Nat holds (R6 <= 6 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6)))
proof
let R6 being Nat;
assume L367: R6 <= 6;
L368: R6 <= ( 5 + 1 ) by L367;
thus L369: thesis by L368 , L100 , L362;
end;
theorem
L370: (for R6 being Nat holds (R6 <= 7 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7)))
proof
let R6 being Nat;
assume L371: R6 <= 7;
L372: R6 <= ( 6 + 1 ) by L371;
thus L373: thesis by L372 , L100 , L366;
end;
theorem
L374: (for R6 being Nat holds (R6 <= 8 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8)))
proof
let R6 being Nat;
assume L375: R6 <= 8;
L376: R6 <= ( 7 + 1 ) by L375;
thus L377: thesis by L376 , L100 , L370;
end;
theorem
L378: (for R6 being Nat holds (R6 <= 9 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8 or R6 = 9)))
proof
let R6 being Nat;
assume L379: R6 <= 9;
L380: R6 <= ( 8 + 1 ) by L379;
thus L381: thesis by L380 , L100 , L374;
end;
theorem
L382: (for R6 being Nat holds (R6 <= 10 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8 or R6 = 9 or R6 = 10)))
proof
let R6 being Nat;
assume L383: R6 <= 10;
L384: R6 <= ( 9 + 1 ) by L383;
thus L385: thesis by L384 , L100 , L378;
end;
theorem
L386: (for R6 being Nat holds (R6 <= 11 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8 or R6 = 9 or R6 = 10 or R6 = 11)))
proof
let R6 being Nat;
assume L387: R6 <= 11;
L388: R6 <= ( 10 + 1 ) by L387;
thus L389: thesis by L388 , L100 , L382;
end;
theorem
L390: (for R6 being Nat holds (R6 <= 12 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8 or R6 = 9 or R6 = 10 or R6 = 11 or R6 = 12)))
proof
let R6 being Nat;
assume L391: R6 <= 12;
L392: R6 <= ( 11 + 1 ) by L391;
thus L393: thesis by L392 , L100 , L386;
end;
theorem
L394: (for R6 being Nat holds (R6 <= 13 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8 or R6 = 9 or R6 = 10 or R6 = 11 or R6 = 12 or R6 = 13)))
proof
let R6 being Nat;
assume L395: R6 <= 13;
L396: R6 <= ( 12 + 1 ) by L395;
thus L397: thesis by L396 , L100 , L390;
end;
scheme Indfrom1 { P10[Nat] } : (for B76 being non  empty Nat holds P10[ B76 ])
provided
L398: P10[ 1 ]
and
L399: (for B77 being non  empty Nat holds (P10[ B77 ] implies P10[ ( B77 + 1 ) ]))
proof
defpred S16[ Nat ] means ($1 is non  empty implies P10[ $1 ]);
L400:
now
let C43 being Nat;
assume L401: S16[ C43 ];
L402:
now
assume L403: ( C43 + 1 ) is non  empty;
L404: (C43 is  empty or C43 is non  empty);
thus L405: S16[ ( C43 + 1 ) ] by L404 , L398 , L399 , L401;
end;
thus L406: S16[ ( C43 + 1 ) ] by L402;
end;
L407: S16[ ( 0 ) ];
L408: (for B78 being Nat holds S16[ B78 ]) from NatInd(L407 , L400);
thus L409: thesis by L408;
end;
definition
let C44 being set;
func min* C44 -> (Element of ( NAT )) means 
:L410: (it in C44 & (for R3 being Nat holds (R3 in C44 implies it <= R3))) if C44 is non  empty non  empty non  empty non  empty (Subset of ( NAT )) otherwise it = ( 0 );
existence
proof
L411: (C44 is non  empty non  empty non  empty non  empty (Subset of ( NAT )) implies (ex R9 being Nat st (R9 in C44 & (for B79 being Nat holds (B79 in C44 implies R9 <= B79)))))
proof
defpred S17[ Nat ] means $1 in C44;
set D12 = the (Element of C44);
assume L412: C44 is non  empty non  empty non  empty non  empty (Subset of ( NAT ));
L413: D12 is (Element of ( NAT )) by L412 , TARSKI:def 3;
L414: (ex B80 being Nat st S17[ B80 ]) by L413 , L412;
L415: (ex B81 being Nat st (S17[ B81 ] & (for B82 being Nat holds (S17[ B82 ] implies B81 <= B82)))) from Min(L414);
thus L416: thesis by L415;
end;
thus L417: thesis by L411;
end;
uniqueness
proof
let C45 , C46 being (Element of ( NAT ));
L418: ((C44 is non  empty non  empty non  empty non  empty (Subset of ( NAT )) & C45 in C44 & (for R3 being Nat holds (R3 in C44 implies C45 <= R3)) & C46 in C44 & (for R3 being Nat holds (R3 in C44 implies C46 <= R3))) implies C45 = C46)
proof
assume that
L419: C44 is non  empty non  empty non  empty non  empty (Subset of ( NAT ))
and
L420: (C45 in C44 & (for R3 being Nat holds (R3 in C44 implies C45 <= R3)) & C46 in C44 & (for R3 being Nat holds (R3 in C44 implies C46 <= R3)));
L421: (C45 <= C46 & C46 <= C45) by L420;
thus L422: thesis by L421 , XXREAL_0:1;
end;
thus L423: thesis by L418;
end;
consistency;
end;
theorem
L425: (for B83 being Nat holds ( succ B83 ) = ( B83 + 1 ))
proof
let C47 being Nat;
L426: ( C47 + 1 ) = { B84 where B84 is (Element of ( NAT )) : B84 < ( C47 + 1 ) } by AXIOMS:4;
L427: C47 = { B85 where B85 is (Element of ( NAT )) : B85 < C47 } by AXIOMS:4;
thus L428: ( succ C47 ) c= ( C47 + 1 )
proof
let R15 being set;
assume that
L429: R15 in ( succ C47 );
per cases  by L429 , ORDINAL1:8;
suppose L430: R15 in C47;

consider C48 being (Element of ( NAT )) such that L431: R15 = C48 and L432: C48 < C47 by L430 , L427;
L433: C48 < ( C47 + 1 ) by L432 , L187;
thus L434: thesis by L433 , L426 , L431;
end;
suppose L435: R15 = C47;

reconsider D13 = C47 as (Element of ( NAT )) by ORDINAL1:def 12;
L436: D13 < ( D13 + 1 ) by L187;
thus L437: thesis by L436 , L426 , L435;
end;
end;

let R15 being set;
assume L439: R15 in ( C47 + 1 );
consider C49 being (Element of ( NAT )) such that L440: R15 = C49 and L441: C49 < ( C47 + 1 ) by L439 , L426;
L442: C49 <= C47 by L441 , L187;
L443: (C49 = C47 or C49 < C47) by L442 , XXREAL_0:1;
L444: (R15 = C47 or R15 in C47) by L443 , L427 , L440;
thus L445: thesis by L444 , ORDINAL1:8;
end;
theorem
L446: (for R5 being Nat holds (for R6 being Nat holds (R6 <= R5 iff R6 c= R5)))
proof
let R5 being Nat;
let R6 being Nat;
defpred S18[ Nat ] means (for R5 being Nat holds ($1 <= R5 iff $1 c= R5));
L447: (for R6 being Nat holds (S18[ R6 ] implies S18[ ( R6 + 1 ) ]))
proof
let R6 being Nat;
assume that
L448: S18[ R6 ];
let R5 being Nat;
thus L449: (( R6 + 1 ) <= R5 implies ( R6 + 1 ) c= R5)
proof
assume L450: ( R6 + 1 ) <= R5;
consider C50 being Nat such that L451: R5 = ( ( R6 + 1 ) + C50 ) by L450 , L123;
reconsider D14 = C50 as (Element of ( NAT )) by ORDINAL1:def 12;
L452: R6 <= ( R6 + D14 ) by L142;
L453: R6 c= ( R6 + D14 ) by L452 , L448;
L454: ( succ R6 ) c= ( succ ( R6 + D14 ) ) by L453 , ORDINAL2:1;
L455: ( ( R6 + D14 ) + 1 ) = ( succ ( R6 + D14 ) ) by L425;
thus L456: thesis by L455 , L451 , L454 , L425;
end;

assume L457: ( R6 + 1 ) c= R5;
L458: ( R6 + 1 ) = ( succ R6 ) by L425;
L459: R6 in R5 by L458 , L457 , ORDINAL1:21;
L460: R6 c= R5 by L459 , ORDINAL1:def 2;
L461: R6 <= R5 by L460 , L448;
L462: R6 <> R5 by L459;
L463: R6 < R5 by L462 , L461 , XXREAL_0:1;
thus L464: thesis by L463 , L187;
end;
L465: S18[ ( 0 ) ];
L466: (for R6 being Nat holds S18[ R6 ]) from NatInd(L465 , L447);
thus L467: thesis by L466;
end;
theorem
L468: (for R5 being Nat holds (for R6 being Nat holds (( card R6 ) c= ( card R5 ) iff R6 <= R5)))
proof
let R5 being Nat;
let R6 being Nat;
reconsider D15 = R6 , D16 = R5 as (Element of ( NAT )) by ORDINAL1:def 12;
L469: (( card D15 ) = D15 & ( card D16 ) = D16) by CARD_1:def 2;
thus L470: thesis by L469 , L446;
end;
theorem
L471: (for R5 being Nat holds (for R6 being Nat holds (( card R6 ) in ( card R5 ) iff R6 < R5)))
proof
let R5 being Nat;
let R6 being Nat;
L472: ((R6 <= R5 & R6 <> R5) iff R6 < R5) by XXREAL_0:1;
L473: (( card R6 ) c< ( card R5 ) iff (( card R6 ) c= ( card R5 ) & ( card R6 ) <> ( card R5 ))) by XBOOLE_0:def 8;
thus L474: thesis by L473 , L472 , L468 , ORDINAL1:11 , ORDINAL1:def 2;
end;
theorem
L475: (for R6 being Nat holds ( nextcard ( card R6 ) ) = ( card ( R6 + 1 ) ))
proof
let R6 being Nat;
reconsider D17 = R6 as (Element of ( NAT )) by ORDINAL1:def 12;
L476: (for R19 being Cardinal holds (( card ( card D17 ) ) in R19 implies ( card ( D17 + 1 ) ) c= R19))
proof
L477: ( card D17 ) = D17 by CARD_1:def 2;
let R19 being Cardinal;
assume L478: ( card ( card D17 ) ) in R19;
L479: ( succ D17 ) c= R19 by L478 , L477 , ORDINAL1:21;
L480: ( D17 + 1 ) = ( succ D17 ) by L425;
thus L481: thesis by L480 , L479 , CARD_1:def 2;
end;
L482: D17 < ( D17 + 1 ) by L187;
L483: ( card ( card D17 ) ) in ( card ( D17 + 1 ) ) by L482 , L471;
thus L484: thesis by L483 , L476 , CARD_1:def 3;
end;
definition
let C51 being Nat;
redefine func succ C51 equals 
( C51 + 1 );
compatibility by L425;
end;
theorem
L486: (for B86 , B87 being  finite set holds (B86 c= B87 implies ( card B86 ) <= ( card B87 )))
proof
let C52 , C53 being  finite set;
assume L487: C52 c= C53;
L488: ( card C52 ) c= ( card C53 ) by L487 , CARD_1:11;
thus L489: thesis by L488 , L446;
end;
theorem
L490: (for R3 being Nat holds (for R6 being Nat holds (R3 in R6 iff R3 < R6)))
proof
let R3 being Nat;
let R6 being Nat;
thus L491:now
assume L492: R3 in R6;
L493: R3 in { R21 where R21 is (Element of ( NAT )) : R21 < R6 } by L492 , AXIOMS:4;
L494: (ex R21 being (Element of ( NAT )) st (R3 = R21 & R21 < R6)) by L493;
thus L495: R3 < R6 by L494;
end;
assume L496: R3 < R6;
reconsider D18 = R3 as (Element of ( NAT )) by ORDINAL1:def 12;
L497: D18 in { R21 where R21 is (Element of ( NAT )) : R21 < R6 } by L496;
thus L498: thesis by L497 , AXIOMS:4;
end;
theorem
L499: (for R6 being Nat holds R6 in ( R6 + 1 ))
proof
let R6 being Nat;
reconsider D19 = R6 as (Element of ( NAT )) by ORDINAL1:def 12;
L500: D19 < ( D19 + 1 ) by XREAL_1:29;
L501: D19 in { R21 where R21 is (Element of ( NAT )) : R21 < ( D19 + 1 ) } by L500;
thus L502: thesis by L501 , AXIOMS:4;
end;
theorem
L503: (for R3 being Nat holds (for R6 being Nat holds (R3 <= R6 implies R3 = ( R3 /\ R6 ))))
proof
let R3 being Nat;
let R6 being Nat;
assume L504: R3 <= R6;
L505: ( Segm R3 ) c= ( Segm R6 ) by L504 , L446;
thus L506: thesis by L505 , XBOOLE_1:28;
end;
scheme LambdaRecEx { F6() -> set , F7(set , set) -> set } : (ex B88 being Function st (( dom B88 ) = ( NAT ) & ( B88 . ( 0 ) ) = F6() & (for B89 being Nat holds ( B88 . ( B89 + 1 ) ) = F7(B89 , ( B88 . B89 )))))
proof
deffunc H1(set , set) = ( {} );
consider C54 being T-Sequence such that L507: ( dom C54 ) = ( NAT ) and L508: (( {} ) in ( NAT ) implies ( C54 . ( {} ) ) = F6()) and L509: (for B90 being Ordinal holds (( succ B90 ) in ( NAT ) implies ( C54 . ( succ B90 ) ) = F7(B90 , ( C54 . B90 )))) and L510: (for B91 being Ordinal holds ((B91 in ( NAT ) & B91 <> ( {} ) & B91 is  limit_ordinal) implies ( C54 . B91 ) = H1(B91 , ( C54 | B91 )))) from ORDINAL2:sch 5;
take C54;
thus L511: ( dom C54 ) = ( NAT ) by L507;
thus L512: ( C54 . ( 0 ) ) = F6() by L508;
let C55 being Nat;
L513: ( succ C55 ) in ( NAT );
thus L514: thesis by L513 , L509;
end;
scheme LambdaRecExD { F8() -> non  empty set , F9() -> (Element of F8()) , F10(set , set) -> (Element of F8()) } : (ex B92 being (Function of ( NAT ) , F8()) st (( B92 . ( 0 ) ) = F9() & (for B93 being Nat holds ( B92 . ( B93 + 1 ) ) = F10(B93 , ( B92 . B93 )))))
proof
consider C56 being Function such that L515: ( dom C56 ) = ( NAT ) and L516: ( C56 . ( 0 ) ) = F9() and L517: (for B94 being Nat holds ( C56 . ( B94 + 1 ) ) = F10(B94 , ( C56 . B94 ))) from LambdaRecEx;
L518: (for B95 being set holds (B95 in ( NAT ) implies ( C56 . B95 ) in F8()))
proof
let C57 being set;
assume L519: C57 in ( NAT );
reconsider D20 = C57 as Nat by L519;
per cases  by L69;
suppose L520: D20 = ( 0 );

thus L521: thesis by L520 , L516;
end;
suppose L522: (ex R3 being Nat st D20 = ( R3 + 1 ));

consider R3 being Nat such that L523: D20 = ( R3 + 1 ) by L522;
L524: ( C56 . D20 ) = F10(R3 , ( C56 . R3 )) by L517 , L523;
thus L525: thesis by L524;
end;
end;
reconsider D21 = C56 as (Function of ( NAT ) , F8()) by L518 , L515 , FUNCT_2:3;
take D21;
thus L527: thesis by L516 , L517;
end;
scheme RecUn { F11() -> set , F12 , F13() -> Function , P11[set , set , set] } : F12() = F13()
provided
L528: ( dom F12() ) = ( NAT )
and
L529: ( F12() . ( 0 ) ) = F11()
and
L530: (for R6 being Nat holds P11[ R6 , ( F12() . R6 ) , ( F12() . ( R6 + 1 ) ) ])
and
L531: ( dom F13() ) = ( NAT )
and
L532: ( F13() . ( 0 ) ) = F11()
and
L533: (for R6 being Nat holds P11[ R6 , ( F13() . R6 ) , ( F13() . ( R6 + 1 ) ) ])
and
L534: (for R6 being Nat holds (for B96 , B97 , B98 being set holds ((P11[ R6 , B96 , B97 ] & P11[ R6 , B96 , B98 ]) implies B97 = B98)))
proof
defpred S19[ Nat ] means ( F12() . $1 ) = ( F13() . $1 );
L535: (for R6 being Nat holds (S19[ R6 ] implies S19[ ( R6 + 1 ) ]))
proof
let R6 being Nat;
assume L536: ( F12() . R6 ) = ( F13() . R6 );
L537: P11[ R6 , ( F12() . R6 ) , ( F13() . ( R6 + 1 ) ) ] by L536 , L533;
L538: P11[ R6 , ( F12() . R6 ) , ( F12() . ( R6 + 1 ) ) ] by L530;
thus L539: thesis by L538 , L534 , L537;
end;
L540: S19[ ( 0 ) ] by L529 , L532;
L541: (for R6 being Nat holds S19[ R6 ]) from NatInd(L540 , L535);
L542: (for R15 being set holds (R15 in ( NAT ) implies ( F12() . R15 ) = ( F13() . R15 ))) by L541;
thus L543: thesis by L542 , L528 , L531 , FUNCT_1:2;
end;
scheme RecUnD { F14() -> non  empty set , F15() -> (Element of F14()) , P12[set , set , set] , F16 , F17() -> (Function of ( NAT ) , F14()) } : F16() = F17()
provided
L544: ( F16() . ( 0 ) ) = F15()
and
L545: (for R6 being Nat holds P12[ R6 , ( F16() . R6 ) , ( F16() . ( R6 + 1 ) ) ])
and
L546: ( F17() . ( 0 ) ) = F15()
and
L547: (for R6 being Nat holds P12[ R6 , ( F17() . R6 ) , ( F17() . ( R6 + 1 ) ) ])
and
L548: (for B99 being Nat holds (for B100 , B101 , B102 being (Element of F14()) holds ((P12[ B99 , B100 , B101 ] & P12[ B99 , B100 , B102 ]) implies B101 = B102)))
proof
defpred S20[ Nat ] means ( F16() . $1 ) <> ( F17() . $1 );
L549: (( dom F16() ) = ( NAT ) & ( dom F17() ) = ( NAT )) by FUNCT_2:def 1;
assume L550: F16() <> F17();
L551: (ex R15 being set st (R15 in ( NAT ) & ( F16() . R15 ) <> ( F17() . R15 ))) by L550 , L549 , FUNCT_1:2;
L552: (ex B103 being Nat st S20[ B103 ]) by L551;
consider C58 being Nat such that L553: (S20[ C58 ] & (for B104 being Nat holds (S20[ B104 ] implies C58 <= B104))) from Min(L552);
L554:
now
assume L555: C58 <> ( 0 );
consider C59 being Nat such that L556: C58 = ( C59 + 1 ) by L555 , L69;
reconsider D22 = C59 as (Element of ( NAT )) by ORDINAL1:def 12;
L557: D22 < C58 by L556 , L187;
L558: ( F16() . D22 ) = ( F17() . D22 ) by L557 , L553;
L559: (P12[ D22 , ( F16() . D22 ) , ( F16() . ( D22 + 1 ) ) ] & P12[ D22 , ( F17() . D22 ) , ( F17() . ( D22 + 1 ) ) ]) by L545 , L547;
thus L560: contradiction by L559 , L548 , L553 , L556 , L558;
end;
thus L561: contradiction by L554 , L544 , L546 , L553;
end;
scheme LambdaRecUn { F18() -> set , F19(set , set) -> set , F20 , F21() -> Function } : F20() = F21()
provided
L562: ( dom F20() ) = ( NAT )
and
L563: ( F20() . ( 0 ) ) = F18()
and
L564: (for R6 being Nat holds ( F20() . ( R6 + 1 ) ) = F19(R6 , ( F20() . R6 )))
and
L565: ( dom F21() ) = ( NAT )
and
L566: ( F21() . ( 0 ) ) = F18()
and
L567: (for R6 being Nat holds ( F21() . ( R6 + 1 ) ) = F19(R6 , ( F21() . R6 )))
proof
defpred S21[ Nat , set , set ] means $3 = F19($1 , $2);
L568: (for R6 being Nat holds S21[ R6 , ( F21() . R6 ) , ( F21() . ( R6 + 1 ) ) ]) by L567;
L569: (for B105 being Nat holds (for B106 , B107 , B108 being set holds ((S21[ B105 , B106 , B107 ] & S21[ B105 , B106 , B108 ]) implies B107 = B108)));
L570: (for R6 being Nat holds S21[ R6 , ( F20() . R6 ) , ( F20() . ( R6 + 1 ) ) ]) by L564;
thus L571: F20() = F21() from RecUn(L562 , L563 , L570 , L565 , L566 , L568 , L569);
end;
scheme LambdaRecUnD { F22() -> non  empty set , F23() -> (Element of F22()) , F24(set , set) -> (Element of F22()) , F25 , F26() -> (Function of ( NAT ) , F22()) } : F25() = F26()
provided
L572: ( F25() . ( 0 ) ) = F23()
and
L573: (for R6 being Nat holds ( F25() . ( R6 + 1 ) ) = F24(R6 , ( F25() . R6 )))
and
L574: ( F26() . ( 0 ) ) = F23()
and
L575: (for R6 being Nat holds ( F26() . ( R6 + 1 ) ) = F24(R6 , ( F26() . R6 )))
proof
defpred S22[ Nat , set , set ] means $3 = F24($1 , $2);
L576: (for R6 being Nat holds S22[ R6 , ( F26() . R6 ) , ( F26() . ( R6 + 1 ) ) ]) by L575;
L577: (for B109 being Nat holds (for B110 , B111 , B112 being (Element of F22()) holds ((S22[ B109 , B110 , B111 ] & S22[ B109 , B110 , B112 ]) implies B111 = B112)));
L578: (for R6 being Nat holds S22[ R6 , ( F25() . R6 ) , ( F25() . ( R6 + 1 ) ) ]) by L573;
thus L579: F25() = F26() from RecUnD(L572 , L578 , L574 , L576 , L577);
end;
registration
let C60 , C61 being Nat;
cluster ( min (C60 , C61) ) ->  natural;
coherence by XXREAL_0:15;
cluster ( max (C60 , C61) ) ->  natural;
coherence by XXREAL_0:16;
end;
definition
let C62 , C63 being (Element of ( NAT ));
redefine func min (C62 , C63) -> (Element of ( NAT ));

coherence by XXREAL_0:15;
redefine func max (C62 , C63) -> (Element of ( NAT ));

coherence by XXREAL_0:16;
end;
scheme MinIndex { F27(Nat) -> Nat } : (ex R3 being Nat st (F27(R3) = ( 0 ) & (for R6 being Nat holds (F27(R6) = ( 0 ) implies R3 <= R6))))
provided
L582: (for R3 being Nat holds (F27(( R3 + 1 )) < F27(R3) or F27(R3) = ( 0 )))
proof
defpred S23[ Nat ] means F27($1) = ( 0 );
defpred S24[ Nat ] means (ex B113 being Nat st $1 = F27(B113));
L583: (for B114 being Nat holds ((B114 <> ( 0 ) & S24[ B114 ]) implies (ex B115 being Nat st (B115 < B114 & S24[ B115 ]))))
proof
let C64 being Nat;
assume that
L584: C64 <> ( 0 )
and
L585: S24[ C64 ];
consider C65 being Nat such that L586: C64 = F27(C65) by L585;
take F27(( C65 + 1 ));
thus L587: thesis by L582 , L584 , L586;
end;
L588: F27(( 0 )) is Nat;
L589: (ex B116 being Nat st S24[ B116 ]) by L588;
L590: S24[ ( 0 ) ] from Regr(L589 , L583);
L591: (ex B117 being Nat st S23[ B117 ]) by L590;
consider C66 being Nat such that L592: (S23[ C66 ] & (for B118 being Nat holds (S23[ B118 ] implies C66 <= B118))) from Min(L591);
take C66;
thus L593: thesis by L592;
end;
definition
let C67 being set;
let C68 being (Function of ( NAT ) , C67);
let C69 being Nat;
redefine func C68 . C69 -> (Element of C67);

coherence
proof
reconsider D23 = C69 as (Element of ( NAT )) by ORDINAL1:def 12;
L594: ( C68 . D23 ) is (Element of C67);
thus L595: thesis by L594;
end;
end;
definition
let C70 being set;
mode sequence of C70
 is (Function of ( NAT ) , C70);
end;
definition
let C71 being (ManySortedSet of ( NAT ));
let C72 being Nat;
func C71 ^\ C72 -> (ManySortedSet of ( NAT )) means 
:L598: (for B119 being Nat holds ( it . B119 ) = ( C71 . ( B119 + C72 ) ));
existence
proof
defpred S25[ set , set ] means (ex B120 being (Element of ( NAT )) st (B120 = $1 & $2 = ( C71 . ( B120 + C72 ) )));
L599: (for B121 being set holds (B121 in ( NAT ) implies (ex B122 being set st S25[ B121 , B122 ])))
proof
let C73 being set;
assume L600: C73 in ( NAT );
reconsider D24 = C73 as (Element of ( NAT )) by L600;
take D25 = ( C71 . ( D24 + C72 ) );
thus L601: S25[ C73 , D25 ];
end;
consider C74 being (ManySortedSet of ( NAT )) such that L602: (for B123 being set holds (B123 in ( NAT ) implies S25[ B123 , ( C74 . B123 ) ])) from PBOOLE:sch 3(L599);
take C74;
let C75 being Nat;
L603: C75 in ( NAT ) by ORDINAL1:def 12;
L604: S25[ C75 , ( C74 . C75 ) ] by L603 , L602;
thus L605: thesis by L604;
end;
uniqueness
proof
let C76 , C77 being (ManySortedSet of ( NAT ));
assume that
L606: (for R6 being Nat holds ( C76 . R6 ) = ( C71 . ( R6 + C72 ) ))
and
L607: (for R6 being Nat holds ( C77 . R6 ) = ( C71 . ( R6 + C72 ) ));
L608:
now
let C78 being set;
assume L609: C78 in ( NAT );
reconsider D26 = C78 as (Element of ( NAT )) by L609;
thus L610: ( C76 . C78 ) = ( C71 . ( D26 + C72 ) ) by L606
.= ( C77 . C78 ) by L607;
end;
thus L611: C76 = C77 by L608 , PBOOLE:3;
end;
end;
L613: (for B124 being (ManySortedSet of ( NAT )) holds (for B125 being Nat holds ( rng ( B124 ^\ B125 ) ) c= ( rng B124 )))
proof
let C79 being (ManySortedSet of ( NAT ));
let C80 being Nat;
let C81 being set;
assume L614: C81 in ( rng ( C79 ^\ C80 ) );
consider C82 being set such that L615: C82 in ( dom ( C79 ^\ C80 ) ) and L616: C81 = ( ( C79 ^\ C80 ) . C82 ) by L614 , FUNCT_1:def 3;
reconsider D27 = C82 as (Element of ( NAT )) by L615 , PARTFUN1:def 2;
L617: ( dom C79 ) = ( NAT ) by PARTFUN1:def 2;
L618: C81 = ( C79 . ( D27 + C80 ) ) by L616 , L598;
thus L619: C81 in ( rng C79 ) by L618 , L617 , FUNCT_1:3;
end;
registration
let C83 being non  empty set;
let C84 being C83 -valued (ManySortedSet of ( NAT ));
let C85 being Nat;
cluster ( C84 ^\ C85 ) -> C83 -valued;
coherence
proof
L620: ( rng ( C84 ^\ C85 ) ) c= ( rng C84 ) by L613;
L621: ( rng C84 ) c= C83 by RELAT_1:def 19;
thus L622: ( rng ( C84 ^\ C85 ) ) c= C83 by L621 , L620 , XBOOLE_1:1;
end;
end;
definition
let C86 being non  empty set;
let C87 being (sequence of C86);
let C88 being Nat;
redefine func C87 ^\ C88 -> (sequence of C86);

coherence
proof
L624: (( rng ( C87 ^\ C88 ) ) c= C86 & ( dom ( C87 ^\ C88 ) ) = ( NAT )) by PARTFUN1:def 2 , RELAT_1:def 19;
thus L625: ( C87 ^\ C88 ) is (sequence of C86) by L624 , RELSET_1:4;
end;
end;
theorem
L627: (for R22 being non  empty set holds (for R23 being (sequence of R22) holds ( R23 ^\ ( 0 ) ) = R23))
proof
let R22 being non  empty set;
let R23 being (sequence of R22);
L628:
now
let C89 being (Element of ( NAT ));
thus L629: ( ( R23 ^\ ( 0 ) ) . C89 ) = ( R23 . ( C89 + ( 0 ) ) ) by L598
.= ( R23 . C89 );
end;
thus L630: thesis by L628 , FUNCT_2:63;
end;
theorem
L631: (for R22 being non  empty set holds (for R23 being (sequence of R22) holds (for R24 being Nat holds (for R25 being Nat holds ( ( R23 ^\ R24 ) ^\ R25 ) = ( R23 ^\ ( R24 + R25 ) )))))
proof
let R22 being non  empty set;
let R23 being (sequence of R22);
let R24 being Nat;
let R25 being Nat;
L632:
now
let C90 being (Element of ( NAT ));
thus L633: ( ( ( R23 ^\ R24 ) ^\ R25 ) . C90 ) = ( ( R23 ^\ R24 ) . ( C90 + R25 ) ) by L598
.= ( R23 . ( ( C90 + R25 ) + R24 ) ) by L598
.= ( R23 . ( C90 + ( R24 + R25 ) ) )
.= ( ( R23 ^\ ( R24 + R25 ) ) . C90 ) by L598;
end;
thus L634: thesis by L632 , FUNCT_2:63;
end;
theorem
L635: (for R22 being non  empty set holds (for R23 being (sequence of R22) holds (for R24 being Nat holds (for R25 being Nat holds ( ( R23 ^\ R24 ) ^\ R25 ) = ( ( R23 ^\ R25 ) ^\ R24 )))))
proof
let R22 being non  empty set;
let R23 being (sequence of R22);
let R24 being Nat;
let R25 being Nat;
thus L636: ( ( R23 ^\ R24 ) ^\ R25 ) = ( R23 ^\ ( R24 + R25 ) ) by L631
.= ( ( R23 ^\ R25 ) ^\ R24 ) by L631;
end;
registration
let C91 being (sequence of ( NAT ));
let R22 being non  empty set;
let R23 being (sequence of R22);
cluster ( R23 * C91 ) ->  Function-like ( NAT ) -defined R22 -valued;
coherence;
end;
registration
let C92 being (sequence of ( NAT ));
let R22 being non  empty set;
let R23 being (sequence of R22);
cluster ( R23 * C92 ) ->  total;
coherence;
end;
theorem
L639: (for R22 being non  empty set holds (for R23 being (sequence of R22) holds (for R24 being Nat holds (for B126 being (sequence of ( NAT )) holds ( ( R23 * B126 ) ^\ R24 ) = ( R23 * ( B126 ^\ R24 ) )))))
proof
let R22 being non  empty set;
let R23 being (sequence of R22);
let R24 being Nat;
let C93 being (sequence of ( NAT ));
L640:
now
let C94 being (Element of ( NAT ));
thus L641: ( ( ( R23 * C93 ) ^\ R24 ) . C94 ) = ( ( R23 * C93 ) . ( C94 + R24 ) ) by L598
.= ( R23 . ( C93 . ( C94 + R24 ) ) ) by FUNCT_2:15
.= ( R23 . ( ( C93 ^\ R24 ) . C94 ) ) by L598
.= ( ( R23 * ( C93 ^\ R24 ) ) . C94 ) by FUNCT_2:15;
end;
thus L642: thesis by L640 , FUNCT_2:63;
end;
theorem
L643: (for R6 being Nat holds (for R22 being non  empty set holds (for R23 being (sequence of R22) holds ( R23 . R6 ) in ( rng R23 ))))
proof
let R6 being Nat;
let R22 being non  empty set;
let R23 being (sequence of R22);
L644: R6 in ( NAT ) by ORDINAL1:def 12;
L645: R6 in ( dom R23 ) by L644 , FUNCT_2:def 1;
thus L646: thesis by L645 , FUNCT_1:3;
end;
theorem
L647: (for R17 being set holds (for R22 being non  empty set holds (for R23 being (sequence of R22) holds ((for R6 being Nat holds ( R23 . R6 ) in R17) implies ( rng R23 ) c= R17))))
proof
let R17 being set;
let R22 being non  empty set;
let R23 being (sequence of R22);
assume L648: (for R6 being Nat holds ( R23 . R6 ) in R17);
let C95 being set;
assume L649: C95 in ( rng R23 );
consider R15 being set such that L650: R15 in ( dom R23 ) and L651: C95 = ( R23 . R15 ) by L649 , FUNCT_1:def 3;
L652: R15 in ( NAT ) by L650 , FUNCT_2:def 1;
thus L653: thesis by L652 , L648 , L651;
end;
theorem
L654: (for B127 being Nat holds (B127 is non  zero implies (B127 = 1 or B127 > 1)))
proof
let C96 being Nat;
assume L655: C96 is non  zero;
L656: ( ( 0 ) + 1 ) <= C96 by L655 , L187;
thus L657: (C96 = 1 or C96 > 1) by L656 , XXREAL_0:1;
end;
theorem
L658: (for R6 being Nat holds ( succ R6 ) = { R21 where R21 is (Element of ( NAT )) : R21 <= R6 })
proof
let R6 being Nat;
defpred S26[ Nat ] means $1 <= R6;
defpred S27[ Nat ] means $1 < ( R6 + 1 );
deffunc H2(Nat) = $1;
L659: (for R21 being (Element of ( NAT )) holds (S27[ R21 ] iff S26[ R21 ])) by L187;
thus L660: ( succ R6 ) = ( R6 + 1 )
.= { H2(R21) where R21 is (Element of ( NAT )) : S27[ R21 ] } by AXIOMS:4
.= { H2(R21) where R21 is (Element of ( NAT )) : S26[ R21 ] } from FRAENKEL:sch 3(L659);
end;
scheme MinPred { F28((Element of ( NAT ))) -> (Element of ( NAT )) , P13[set] } : (ex B128 being (Element of ( NAT )) st (P13[ B128 ] & (for B129 being (Element of ( NAT )) holds (P13[ B129 ] implies B128 <= B129))))
provided
L661: (for B130 being (Element of ( NAT )) holds (F28(( B130 + 1 )) < F28(B130) or P13[ B130 ]))
proof
L662:
now
consider C97 being (Function of ( NAT ) , ( NAT )) such that L663: (for B131 being (Element of ( NAT )) holds ( C97 . B131 ) = F28(B131)) from FUNCT_2:sch 4;
L664: ( C97 . ( 0 ) ) in ( rng C97 ) by FUNCT_2:4;
L665: ( rng C97 ) c= ( NAT )
proof
let C98 being set;
assume L666: C98 in ( rng C97 );
consider C99 being set such that L667: (C99 in ( dom C97 ) & C98 = ( C97 . C99 )) by L666 , FUNCT_1:def 3;
reconsider D28 = C99 as (Element of ( NAT )) by L667 , FUNCT_2:def 1;
L668: C98 = F28(D28) by L667 , L663;
thus L669: thesis by L668;
end;
reconsider D29 = ( rng C97 ) as non  empty (Subset of ( NAT )) by L665 , L664;
set D30 = ( min* D29 );
L670: D30 in D29 by L410;
consider C100 being set such that L671: C100 in ( dom C97 ) and L672: D30 = ( C97 . C100 ) by L670 , FUNCT_1:def 3;
reconsider D31 = C100 as (Element of ( NAT )) by L671 , FUNCT_2:def 1;
L673: (( C97 . D31 ) = F28(D31) & ( C97 . ( D31 + 1 ) ) = F28(( D31 + 1 ))) by L663;
L674: (( C97 . ( D31 + 1 ) ) < ( C97 . D31 ) or P13[ D31 ]) by L673 , L661;
assume L675: (for R24 being Nat holds (not P13[ R24 ]));
L676: ( C97 . ( D31 + 1 ) ) in D29 by FUNCT_2:4;
thus L677: contradiction by L676 , L410 , L675 , L672 , L674;
end;
L678: (ex B132 being Nat st P13[ B132 ]) by L662;
consider C101 being Nat such that L679: P13[ C101 ] and L680: (for B133 being Nat holds (P13[ B133 ] implies C101 <= B133)) from Min(L678);
L681: (C101 in ( NAT ) & (for B134 being (Element of ( NAT )) holds (P13[ B134 ] implies C101 <= B134))) by L680 , ORDINAL1:def 12;
thus L682: thesis by L681 , L679;
end;
registration
let C102 being Ordinal;
let C103 being set;
cluster ( C102 --> C103 ) ->  T-Sequence-like;
coherence
proof
L683: ( dom ( C102 --> C103 ) ) = C102 by FUNCOP_1:13;
thus L684: thesis by L683 , ORDINAL1:def 7;
end;
end;
theorem
L686: (for B135 being (ManySortedSet of ( NAT )) holds (for B136 being Nat holds ( rng ( B135 ^\ B136 ) ) c= ( rng B135 ))) by L613;
theorem
L687: (for R6 being Nat holds (for R25 being Nat holds ((R6 <= R25 & R25 <= ( R6 + 2 )) implies (R25 = R6 or R25 = ( R6 + 1 ) or R25 = ( R6 + 2 )))))
proof
let R6 being Nat;
let R25 being Nat;
assume that
L688: R6 <= R25
and
L689: R25 <= ( R6 + 2 );
per cases ;
suppose L690: R25 <= ( R6 + 1 );

thus L691: thesis by L690 , L688 , L118;
end;
suppose L692: R25 > ( R6 + 1 );

L693: (R25 = ( R6 + 1 ) or R25 = ( ( R6 + 1 ) + 1 )) by L692 , L689 , L118;
thus L694: thesis by L693;
end;
end;
theorem
L696: (for R6 being Nat holds (for R25 being Nat holds ((R6 <= R25 & R25 <= ( R6 + 3 )) implies (R25 = R6 or R25 = ( R6 + 1 ) or R25 = ( R6 + 2 ) or R25 = ( R6 + 3 )))))
proof
let R6 being Nat;
let R25 being Nat;
assume that
L697: R6 <= R25
and
L698: R25 <= ( R6 + 3 );
per cases ;
suppose L699: R25 <= ( R6 + 2 );

thus L700: thesis by L699 , L697 , L687;
end;
suppose L701: R25 > ( R6 + 2 );

L702: (R25 = ( R6 + 2 ) or R25 = ( ( R6 + 2 ) + 1 )) by L701 , L698 , L118;
thus L703: thesis by L702;
end;
end;
theorem
L705: (for R6 being Nat holds (for R25 being Nat holds ((R6 <= R25 & R25 <= ( R6 + 4 )) implies (R25 = R6 or R25 = ( R6 + 1 ) or R25 = ( R6 + 2 ) or R25 = ( R6 + 3 ) or R25 = ( R6 + 4 )))))
proof
let R6 being Nat;
let R25 being Nat;
assume that
L706: R6 <= R25
and
L707: R25 <= ( R6 + 4 );
per cases ;
suppose L708: R25 <= ( R6 + 3 );

thus L709: thesis by L708 , L706 , L696;
end;
suppose L710: R25 > ( R6 + 3 );

L711: (R25 = ( R6 + 3 ) or R25 = ( ( R6 + 3 ) + 1 )) by L710 , L707 , L118;
thus L712: thesis by L711;
end;
end;
theorem
L714: (for B137 being  finite set holds (1 < ( card B137 ) implies (ex B138 , B139 being set st (B138 in B137 & B139 in B137 & B138 <> B139))))
proof
let C104 being  finite set;
set D32 = ( choose C104 );
assume L715: 1 < ( card C104 );
L716: C104 <> ( {} ) by L715;
L717: D32 in C104 by L716;
L718:
now
assume L719: (for B140 being set holds (B140 in C104 implies B140 = D32));
L720:
now
let C105 being set;
thus L721:now
assume L722: C105 in C104;
L723: C105 = D32 by L722 , L719;
thus L724: C105 in { D32 } by L723 , TARSKI:def 1;
end;
assume L725: C105 in { D32 };
thus L726: C105 in C104 by L725 , L717 , TARSKI:def 1;
end;
L727: C104 = { D32 } by L720 , TARSKI:1;
thus L728: contradiction by L727 , L715 , CARD_1:30;
end;
thus L729: thesis by L718;
end;
theorem
L730: (for R6 being Nat holds (R6 <= 14 implies (R6 = ( 0 ) or R6 = 1 or R6 = 2 or R6 = 3 or R6 = 4 or R6 = 5 or R6 = 6 or R6 = 7 or R6 = 8 or R6 = 9 or R6 = 10 or R6 = 11 or R6 = 12 or R6 = 13 or R6 = 14)))
proof
let R6 being Nat;
assume L731: R6 <= 14;
L732: R6 <= ( 13 + 1 ) by L731;
thus L733: thesis by L732 , L100 , L394;
end;
