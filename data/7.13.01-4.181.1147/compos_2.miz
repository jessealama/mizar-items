:: The Elementary Macroinstructions
::  by Andrzej Trybulec
::
:: Received October 1, 2011
:: Copyright (c) 2011-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

vocabularies TURING_1, COMPOS_1, SCMFSA6A, AMI_1, AMISTD_1, SCMPDS_5,
    FUNCT_1, CARD_1, ARYTM_1, NAT_1, RELAT_1, ZFMISC_1, ARYTM_3, XXREAL_0,
    AMISTD_2, TARSKI, XBOOLE_0, NUMBERS, FINSET_1, EXTPRO_1, FUNCOP_1,
    FUNCT_4, RELOC, VALUED_1, SUBSET_1, PARTFUN1, RCOMP_1, XCMPLX_0,
    ORDINAL1, VALUED_0, AMISTD_4;
notations TARSKI, XBOOLE_0, RELAT_1, ZFMISC_1, FUNCT_1, FUNCOP_1, ORDINAL1,
    SUBSET_1, FINSET_1, PARTFUN1, FUNCT_4, CARD_1, NUMBERS,
    XXREAL_0, XCMPLX_0, XREAL_0, NAT_D, VALUED_0, VALUED_1,
    COMPOS_0, COMPOS_1, AMISTD_4;
constructors COMPOS_1, AMISTD_4, VALUED_1, NAT_D, XXREAL_0, XREAL_0,
    XCMPLX_0, AMISTD_1, AMISTD_2, NAT_1, PRE_POLY, DOMAIN_1, RELSET_1, FUNCT_4;
definitions TARSKI, COMPOS_1, VALUED_1, FUNCOP_1, AMISTD_4;
registrations COMPOS_0, COMPOS_1, AMISTD_4, CARD_1, NAT_1, XCMPLX_0,
    XREAL_0, ORDINAL1, VALUED_1, FUNCOP_1, AFINSQ_1, RELAT_1, XBOOLE_0,
    FUNCT_4, FINSEQ_1, VALUED_0;
theorems COMPOS_1, COMPOS_0, AFINSQ_1, XREAL_1, ZFMISC_1, AMISTD_4, XBOOLE_1,
    FUNCT_7, VALUED_1, RELAT_1, TARSKI, XBOOLE_0, FUNCT_1, GRFUNC_1, FUNCT_4,
    FUNCOP_1, XCMPLX_1, NAT_1, XXREAL_0, ORDINAL1, PARTFUN1, XTUPLE_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;

begin
registration
cluster  with_non_trivial_Instructions for COM-Struct;
existence
proof
take D1 = COM-Struct (# the non  trivial Instructions #);
thus L1: (the InstructionsF of D1) is non  trivial;
end;
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
cluster  No-StopCode for (Instruction of R1);
existence
proof
L3: (the InstructionsF of R1) is non  trivial by AMISTD_4:def 1;
consider C1 , C2 being set such that L4: (C1 in (the InstructionsF of R1) & C2 in (the InstructionsF of R1)) and L5: C1 <> C2 by L3 , ZFMISC_1:def 10;
L6: (C1 <> ( halt R1 ) or C2 <> ( halt R1 )) by L5;
consider C3 being (Instruction of R1) such that L7: C3 <> ( halt R1 ) by L6 , L4;
take C3;
thus L8: C3 is  No-StopCode by L7 , COMPOS_0:def 12;
end;
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
let C4 being  No-StopCode (Instruction of R1);
cluster ( Macro C4 ) ->  halt-ending  unique-halt;
coherence
proof
L10: ( LastLoc ( Macro C4 ) ) = ( ( card ( Macro C4 ) ) -' 1 ) by AFINSQ_1:70
.= ( 2 -' 1 ) by COMPOS_1:56
.= ( 2 - 1 ) by XREAL_1:233
.= 1;
thus L11: ( ( Macro C4 ) . ( LastLoc ( Macro C4 ) ) ) = ( halt R1 ) by L10 , COMPOS_1:59;
thus L12: ( Macro C4 ) is  unique-halt
proof
let C5 being Nat;
assume that
L13: ( ( Macro C4 ) . C5 ) = ( halt R1 );
assume L14: C5 in ( dom ( Macro C4 ) );
L15:
now
assume L16: C5 = ( 0 );
L17: ( ( Macro C4 ) . C5 ) = C4 by L16 , COMPOS_1:58;
thus L18: contradiction by L17 , L13 , COMPOS_0:def 12;
end;
thus L19: C5 = ( LastLoc ( Macro C4 ) ) by L15 , L14 , L10 , COMPOS_1:60;
end;

end;
end;
definition
let R1 being  with_non_trivial_Instructions COM-Struct;
let C6 being  No-StopCode (Instruction of R1);
let C7 being (MacroInstruction of R1);
func C6 ';' C7 -> (MacroInstruction of R1) equals 
( ( Macro C6 ) ';' C7 );
correctness;
end;
definition
let R1 being  with_non_trivial_Instructions COM-Struct;
let C8 being (MacroInstruction of R1);
let C9 being  No-StopCode (Instruction of R1);
func C8 ';' C9 -> (MacroInstruction of R1) equals 
( C8 ';' ( Macro C9 ) );
correctness;
end;
definition
let R1 being  with_non_trivial_Instructions COM-Struct;
let C10 , C11 being  No-StopCode (Instruction of R1);
func C10 ';' C11 -> (MacroInstruction of R1) equals 
( ( Macro C10 ) ';' ( Macro C11 ) );
correctness;
end;
theorem
L17: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R4 being  No-StopCode (Instruction of R1) holds (for R5 being (MacroInstruction of R1) holds (for R6 being (MacroInstruction of R1) holds ( ( R5 ';' R6 ) ';' R4 ) = ( R5 ';' ( R6 ';' R4 ) ))))) by COMPOS_1:29;
theorem
L18: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R3 being  No-StopCode (Instruction of R1) holds (for R5 being (MacroInstruction of R1) holds (for R7 being (MacroInstruction of R1) holds ( ( R5 ';' R3 ) ';' R7 ) = ( R5 ';' ( R3 ';' R7 ) ))))) by COMPOS_1:29;
theorem
L19: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R3 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds (for R5 being (MacroInstruction of R1) holds ( ( R5 ';' R3 ) ';' R4 ) = ( R5 ';' ( R3 ';' R4 ) ))))) by COMPOS_1:29;
theorem
L20: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R6 being (MacroInstruction of R1) holds (for R7 being (MacroInstruction of R1) holds ( ( R2 ';' R6 ) ';' R7 ) = ( R2 ';' ( R6 ';' R7 ) ))))) by COMPOS_1:29;
theorem
L21: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds (for R6 being (MacroInstruction of R1) holds ( ( R2 ';' R6 ) ';' R4 ) = ( R2 ';' ( R6 ';' R4 ) ))))) by COMPOS_1:29;
theorem
L22: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R7 being (MacroInstruction of R1) holds ( ( R2 ';' R3 ) ';' R7 ) = ( R2 ';' ( R3 ';' R7 ) ))))) by COMPOS_1:29;
theorem
L23: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds ( ( R2 ';' R3 ) ';' R4 ) = ( R2 ';' ( R3 ';' R4 ) ))))) by COMPOS_1:29;
theorem
L24: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds ( R2 ';' R3 ) = ( ( Macro R2 ) ';' R3 ))));
theorem
L25: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds ( R2 ';' R3 ) = ( R2 ';' ( Macro R3 ) ))));
theorem
L26: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R6 being (MacroInstruction of R1) holds ( card ( R2 ';' R6 ) ) = ( ( card R6 ) + 1 ))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R6 being (MacroInstruction of R1);
thus L27: ( card ( R2 ';' R6 ) ) = ( ( ( card ( Macro R2 ) ) + ( card R6 ) ) - 1 ) by COMPOS_1:20
.= ( ( 2 + ( card R6 ) ) - 1 ) by COMPOS_1:56
.= ( ( card R6 ) + 1 );
end;
theorem
L28: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R3 being  No-StopCode (Instruction of R1) holds (for R5 being (MacroInstruction of R1) holds ( card ( R5 ';' R3 ) ) = ( ( card R5 ) + 1 ))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R3 being  No-StopCode (Instruction of R1);
let R5 being (MacroInstruction of R1);
thus L29: ( card ( R5 ';' R3 ) ) = ( ( ( card R5 ) + ( card ( Macro R3 ) ) ) - 1 ) by COMPOS_1:20
.= ( ( 2 + ( card R5 ) ) - 1 ) by COMPOS_1:56
.= ( ( card R5 ) + 1 );
end;
theorem
L30: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds ( card ( R2 ';' R3 ) ) = 3)))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
thus L31: ( card ( R2 ';' R3 ) ) = ( ( ( card ( Macro R2 ) ) + ( card ( Macro R3 ) ) ) - 1 ) by COMPOS_1:20
.= ( ( 2 + ( card ( Macro R2 ) ) ) - 1 ) by COMPOS_1:56
.= ( ( 2 + 2 ) - 1 ) by COMPOS_1:56
.= 3;
end;
theorem
L32: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds ( card ( ( R2 ';' R3 ) ';' R4 ) ) = 4))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
let R4 being  No-StopCode (Instruction of R1);
thus L33: ( card ( ( R2 ';' R3 ) ';' R4 ) ) = ( ( card ( R2 ';' R3 ) ) + 1 ) by L28
.= ( 3 + 1 ) by L30
.= 4;
end;
theorem
L34: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds ( card ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 5)))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
thus L35: ( card ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = ( ( card ( ( R8 ';' R9 ) ';' R10 ) ) + 1 ) by L28
.= ( 4 + 1 ) by L32
.= 5;
end;
theorem
L36: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( card ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 6))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
thus L37: ( card ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = ( ( card ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) + 1 ) by L28
.= ( 5 + 1 ) by L34
.= 6;
end;
theorem
L38: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( card ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ) = 7)))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
thus L39: ( card ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ) = ( ( card ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) + 1 ) by L28
.= ( 6 + 1 ) by L36
.= 7;
end;
definition
let R14 being non  empty ( NAT ) -defined  finite Function;
let C12 being set;
pred R14 <= C12
means
( CutLastLoc R14 ) c= C12
;end;
definition
let R14 being non  empty ( NAT ) -defined  finite Function;
let R15 being non  empty ( NAT ) -defined  finite Function;
redefine pred R14 <= R15
;
reflexivity
proof
let R14 being non  empty ( NAT ) -defined  finite Function;
thus L41: ( CutLastLoc R14 ) c= R14;
end;
end;
theorem
L43: (for B1 being non  empty ( NAT ) -defined  finite Function holds (not ( LastLoc B1 ) in ( dom ( CutLastLoc B1 ) )))
proof
let C13 being non  empty ( NAT ) -defined  finite Function;
L44: ( LastLoc C13 ) in ( dom C13 ) by VALUED_1:30;
L45: ( C13 | { ( LastLoc C13 ) } ) = ( ( LastLoc C13 ) .--> ( C13 . ( LastLoc C13 ) ) ) by L44 , FUNCT_7:6;
L46: ( dom ( CutLastLoc C13 ) ) = ( ( dom C13 ) \ { ( LastLoc C13 ) } ) by L45 , RELAT_1:177;
L47: ( LastLoc C13 ) in { ( LastLoc C13 ) } by TARSKI:def 1;
thus L48: thesis by L47 , L46 , XBOOLE_0:def 5;
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
let C14 being  unique-halt non  empty (preProgram of R1);
cluster ( CutLastLoc C14 ) ->  halt-free;
coherence
proof
L49:
now
assume L50: ( halt R1 ) in ( rng ( CutLastLoc C14 ) );
consider C15 being set such that L51: C15 in ( dom ( CutLastLoc C14 ) ) and L52: ( ( CutLastLoc C14 ) . C15 ) = ( halt R1 ) by L50 , FUNCT_1:def 3;
L53: ( dom ( CutLastLoc C14 ) ) c= ( dom C14 ) by RELAT_1:11;
L54: C15 in ( dom C14 ) by L53 , L51;
L55: ( dom C14 ) c= ( NAT ) by RELAT_1:def 18;
L56: ( C14 . C15 ) = ( halt R1 ) by L52 , L51 , GRFUNC_1:2;
L57: C15 = ( LastLoc C14 ) by L56 , L54 , L55 , COMPOS_1:def 15;
thus L58: contradiction by L57 , L51 , L43;
end;
thus L59: ( CutLastLoc C14 ) is  halt-free by L49 , COMPOS_1:def 11;
end;
end;
L61: (for B2 , B3 being Function holds (B2 c= B3 implies (for B4 , B5 being set holds ((not B4 in ( rng B2 )) implies B2 c= ( B3 \ ( B5 .--> B4 ) )))))
proof
let C16 , C17 being Function;
assume that
L62: C16 c= C17;
let C18 , C19 being set;
assume L63: (not C18 in ( rng C16 ));
L64: (not [ C19 , C18 ] in C16) by L63 , XTUPLE_0:def 13;
L65: ( C19 .--> C18 ) = { [ C19 , C18 ] } by ZFMISC_1:29;
thus L66: C16 c= ( C17 \ ( C19 .--> C18 ) ) by L65 , L64 , L62 , ZFMISC_1:34;
end;
theorem
L67: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for B6 being  unique-halt (Program of R1) holds (for B7 being  halt-ending (Program of R1) holds (( CutLastLoc B6 ) c= B7 implies ( CutLastLoc B6 ) c= ( CutLastLoc B7 )))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let C20 being  unique-halt (Program of R1);
let C21 being  halt-ending (Program of R1);
assume that
L68: ( CutLastLoc C20 ) c= C21;
L69: (not ( halt R1 ) in ( rng ( CutLastLoc C20 ) )) by COMPOS_1:def 11;
L70: ( C21 . ( LastLoc C21 ) ) = ( halt R1 ) by COMPOS_1:def 14;
thus L71: ( CutLastLoc C20 ) c= ( CutLastLoc C21 ) by L70 , L69 , L68 , L61;
end;
theorem
L72: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds (for B8 being set holds ((R16 <= R17 & R17 <= B8) implies R16 <= B8)))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
let C22 being set;
assume that
L73: ( CutLastLoc R16 ) c= R17
and
L74: ( CutLastLoc R17 ) c= C22;
L75: ( CutLastLoc R16 ) c= ( CutLastLoc R17 ) by L73 , L67;
thus L76: ( CutLastLoc R16 ) c= C22 by L75 , L74 , XBOOLE_1:1;
end;
theorem
L77: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds R16 = ( ( CutLastLoc R16 ) +* ( ( LastLoc R16 ) .--> ( halt R1 ) ) )))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
L78: ( LastLoc R16 ) in ( dom R16 ) by VALUED_1:30;
L79: { ( LastLoc R16 ) } misses ( dom ( CutLastLoc R16 ) ) by L43 , ZFMISC_1:50;
L80: ( dom ( ( LastLoc R16 ) .--> ( R16 . ( LastLoc R16 ) ) ) ) = { ( LastLoc R16 ) } by FUNCOP_1:13;
L81: R16 = ( ( CutLastLoc R16 ) \/ ( ( LastLoc R16 ) .--> ( R16 . ( LastLoc R16 ) ) ) ) by L78 , FUNCOP_1:84 , XBOOLE_1:45
.= ( ( CutLastLoc R16 ) +* ( ( LastLoc R16 ) .--> ( R16 . ( LastLoc R16 ) ) ) ) by L80 , L79 , FUNCT_4:31;
thus L82: thesis by L81 , COMPOS_1:def 14;
end;
theorem
L83: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds (( CutLastLoc R16 ) = ( CutLastLoc R17 ) implies R16 = R17))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
assume L84: ( CutLastLoc R16 ) = ( CutLastLoc R17 );
L85: ( ( card R16 ) - 1 ) = ( card ( CutLastLoc R17 ) ) by L84 , VALUED_1:38
.= ( ( card R17 ) - 1 ) by VALUED_1:38;
L86: ( LastLoc R16 ) = ( ( card R17 ) -' 1 ) by L85 , AFINSQ_1:70
.= ( LastLoc R17 ) by AFINSQ_1:70;
thus L87: R16 = ( ( CutLastLoc R16 ) +* ( ( LastLoc R17 ) .--> ( halt R1 ) ) ) by L86 , L77
.= R17 by L84 , L77;
end;
theorem
L88: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds ((R16 <= R17 & R17 <= R16) implies R16 = R17))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
assume L89: ( CutLastLoc R16 ) c= R17;
L90: ( CutLastLoc R16 ) c= ( CutLastLoc R17 ) by L89 , L67;
assume L91: ( CutLastLoc R17 ) c= R16;
L92: ( CutLastLoc R17 ) c= ( CutLastLoc R16 ) by L91 , L67;
L93: ( CutLastLoc R16 ) = ( CutLastLoc R17 ) by L92 , L90 , XBOOLE_0:def 10;
thus L94: R16 = R17 by L93 , L83;
end;
theorem
L95: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds R16 <= ( R16 ';' R17 ))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
L96: ( dom ( CutLastLoc R16 ) ) misses ( dom ( Reloc (R17 , ( ( card R16 ) -' 1 )) ) ) by COMPOS_1:18;
thus L97: ( CutLastLoc R16 ) c= ( R16 ';' R17 ) by L96 , FUNCT_4:32;
end;
theorem
L98: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for B9 being set holds (R16 c= B9 implies R16 <= B9))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let C23 being set;
assume that
L99: R16 c= C23;
thus L100: ( CutLastLoc R16 ) c= C23 by L99 , XBOOLE_1:1;
end;
theorem
L101: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds (R16 <= R17 implies (for B10 being set holds (R17 c= B10 implies R16 <= B10))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
assume L102: ( CutLastLoc R16 ) c= R17;
let C24 being set;
assume L103: R17 c= C24;
thus L104: ( CutLastLoc R16 ) c= C24 by L103 , L102 , XBOOLE_1:1;
end;
theorem
L105: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for B11 being Nat holds (B11 < ( LastLoc R16 ) iff B11 in ( dom ( CutLastLoc R16 ) )))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let C25 being Nat;
L106: ( card R16 ) > ( 0 ) by NAT_1:3;
L107: ( card R16 ) >= ( ( 0 ) + 1 ) by L106 , NAT_1:13;
L108: ( card ( CutLastLoc R16 ) ) = ( ( card R16 ) - 1 ) by VALUED_1:38
.= ( ( card R16 ) -' 1 ) by L107 , XREAL_1:233
.= ( LastLoc R16 ) by AFINSQ_1:70;
thus L109: thesis by L108 , NAT_1:44;
end;
theorem
L110: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for B12 being Nat holds (B12 < ( LastLoc R16 ) implies ( ( CutLastLoc R16 ) . B12 ) = ( R16 . B12 )))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let C26 being Nat;
assume L111: C26 < ( LastLoc R16 );
L112: C26 in ( dom ( CutLastLoc R16 ) ) by L111 , L105;
thus L113: thesis by L112 , GRFUNC_1:2;
end;
theorem
L114: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds (for B13 being Nat holds ((B13 < ( LastLoc R16 ) & R16 <= R17) implies ( R16 . B13 ) = ( R17 . B13 ))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
let C27 being Nat;
assume that
L115: C27 < ( LastLoc R16 );
assume L116: ( CutLastLoc R16 ) c= R17;
L117: C27 in ( dom ( CutLastLoc R16 ) ) by L115 , L105;
thus L118: ( R16 . C27 ) = ( ( CutLastLoc R16 ) . C27 ) by L115 , L110
.= ( R17 . C27 ) by L116 , L117 , GRFUNC_1:2;
end;
theorem
L119: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds ( LastLoc R16 ) = ( ( card R16 ) - 1 )))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
L120: ( card R16 ) > ( 0 ) by NAT_1:3;
L121: ( card R16 ) >= ( ( 0 ) + 1 ) by L120 , NAT_1:13;
thus L122: ( LastLoc R16 ) = ( ( card R16 ) -' 1 ) by AFINSQ_1:70
.= ( ( card R16 ) - 1 ) by L121 , XREAL_1:233;
end;
theorem
L123: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds ( LastLoc ( Macro R2 ) ) = 1))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
thus L124: ( LastLoc ( Macro R2 ) ) = ( ( card ( Macro R2 ) ) - 1 ) by L119
.= ( 2 - 1 ) by COMPOS_1:56
.= 1;
end;
theorem
L125: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds ( LastLoc ( R2 ';' R3 ) ) = 2)))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
thus L126: ( LastLoc ( R2 ';' R3 ) ) = ( ( card ( R2 ';' R3 ) ) - 1 ) by L119
.= ( 3 - 1 ) by L30
.= 2;
end;
theorem
L127: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds ( LastLoc ( ( R2 ';' R3 ) ';' R4 ) ) = 3))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
let R4 being  No-StopCode (Instruction of R1);
thus L128: ( LastLoc ( ( R2 ';' R3 ) ';' R4 ) ) = ( ( card ( ( R2 ';' R3 ) ';' R4 ) ) - 1 ) by L119
.= ( 4 - 1 ) by L32
.= 3;
end;
theorem
L129: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 4)))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
thus L130: ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = ( ( card ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) - 1 ) by L119
.= ( 5 - 1 ) by L34
.= 4;
end;
theorem
L131: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
thus L132: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = ( ( card ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) - 1 ) by L119
.= ( 6 - 1 ) by L36
.= 5;
end;
theorem
L133: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( LastLoc ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ) = 6)))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
thus L134: ( LastLoc ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ) = ( ( card ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ) - 1 ) by L119
.= ( 7 - 1 ) by L38
.= 6;
end;
theorem
L135: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R17 being (MacroInstruction of R1) holds ( ( R2 ';' R17 ) . ( 0 ) ) = R2)))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R17 being (MacroInstruction of R1);
L136: ( LastLoc ( Macro R2 ) ) = 1 by L123;
thus L137: ( ( R2 ';' R17 ) . ( 0 ) ) = ( ( Macro R2 ) . ( 0 ) ) by L136 , L95 , L114
.= R2 by COMPOS_1:58;
end;
theorem
L138: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R7 being (MacroInstruction of R1) holds ( ( ( R2 ';' R3 ) ';' R7 ) . ( 0 ) ) = R2))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
let R7 being (MacroInstruction of R1);
L139: ( LastLoc ( R2 ';' R3 ) ) = 2 by L125;
thus L140: ( ( ( R2 ';' R3 ) ';' R7 ) . ( 0 ) ) = ( ( R2 ';' R3 ) . ( 0 ) ) by L139 , L95 , L114
.= ( ( R2 ';' ( Macro R3 ) ) . ( 0 ) )
.= R2 by L135;
end;
theorem
L141: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds (for R7 being (MacroInstruction of R1) holds ( ( ( ( R2 ';' R3 ) ';' R4 ) ';' R7 ) . ( 0 ) ) = R2)))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
let R4 being  No-StopCode (Instruction of R1);
let R7 being (MacroInstruction of R1);
L142: ( LastLoc ( ( R2 ';' R3 ) ';' R4 ) ) = 3 by L127;
thus L143: ( ( ( ( R2 ';' R3 ) ';' R4 ) ';' R7 ) . ( 0 ) ) = ( ( ( R2 ';' R3 ) ';' R4 ) . ( 0 ) ) by L142 , L95 , L114
.= ( ( ( R2 ';' R3 ) ';' ( Macro R4 ) ) . ( 0 ) )
.= R2 by L138;
end;
theorem
L144: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R7 being (MacroInstruction of R1) holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R7 ) . ( 0 ) ) = R8))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R7 being (MacroInstruction of R1);
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
L145: ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 4 by L129;
thus L146: ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R7 ) . ( 0 ) ) = ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . ( 0 ) ) by L145 , L95 , L114
.= ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' ( Macro R11 ) ) . ( 0 ) )
.= R8 by L141;
end;
theorem
L147: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R7 being (MacroInstruction of R1) holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R7 ) . ( 0 ) ) = R8)))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R7 being (MacroInstruction of R1);
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
L148: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5 by L131;
thus L149: ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R7 ) . ( 0 ) ) = ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . ( 0 ) ) by L148 , L95 , L114
.= ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' ( Macro R12 ) ) . ( 0 ) )
.= R8 by L144;
end;
theorem
L150: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R7 being (MacroInstruction of R1) holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ';' R7 ) . ( 0 ) ) = R8))))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R7 being (MacroInstruction of R1);
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
L151: ( LastLoc ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ) = 6 by L133;
thus L152: ( ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) ';' R7 ) . ( 0 ) ) = ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . ( 0 ) ) by L151 , L95 , L114
.= ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' ( Macro R13 ) ) . ( 0 ) )
.= R8 by L147;
end;
theorem
L153: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds (for B14 being Nat holds (B14 < ( LastLoc R16 ) implies ( ( R16 ';' R17 ) . B14 ) = ( R16 . B14 ))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
let C28 being Nat;
assume L154: C28 < ( LastLoc R16 );
L155: C28 in ( dom ( CutLastLoc R16 ) ) by L154 , L105;
L156: ( dom ( CutLastLoc R16 ) ) misses ( dom ( Reloc (R17 , ( ( card R16 ) -' 1 )) ) ) by COMPOS_1:18;
L157: (not C28 in ( dom ( Reloc (R17 , ( ( card R16 ) -' 1 )) ) )) by L156 , L155 , XBOOLE_0:3;
thus L158: ( ( R16 ';' R17 ) . C28 ) = ( ( CutLastLoc R16 ) . C28 ) by L157 , FUNCT_4:11
.= ( R16 . C28 ) by L155 , GRFUNC_1:2;
end;
theorem
L159: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds ( LastLoc ( R16 ';' R17 ) ) = ( ( LastLoc R16 ) + ( LastLoc R17 ) ))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
thus L160: ( LastLoc ( R16 ';' R17 ) ) = ( ( card ( R16 ';' R17 ) ) - 1 ) by L119
.= ( ( ( ( card R16 ) + ( card R17 ) ) - 1 ) - 1 ) by COMPOS_1:20
.= ( ( ( card R16 ) - 1 ) + ( ( card R17 ) - 1 ) )
.= ( ( LastLoc R16 ) + ( ( card R17 ) - 1 ) ) by L119
.= ( ( LastLoc R16 ) + ( LastLoc R17 ) ) by L119;
end;
theorem
L161: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R16 being (MacroInstruction of R1) holds (for R17 being (MacroInstruction of R1) holds (for B15 being Nat holds (B15 <= ( LastLoc R17 ) implies ( ( R16 ';' R17 ) . ( ( LastLoc R16 ) + B15 ) ) = ( IncAddr (( R17 /. B15 ) , ( LastLoc R16 )) ))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R16 being (MacroInstruction of R1);
let R17 being (MacroInstruction of R1);
let C29 being Nat;
assume that
L162: C29 <= ( LastLoc R17 );
set D2 = ( ( LastLoc R16 ) + C29 );
L163: ( LastLoc R16 ) = ( ( card R16 ) -' 1 ) by AFINSQ_1:70;
L164: C29 <= ( ( card R17 ) - 1 ) by L162 , L119;
L165: ( ( card R17 ) - 1 ) < ( card R17 ) by XREAL_1:44;
L166: C29 < ( card R17 ) by L165 , L164 , XXREAL_0:2;
L167: C29 in ( dom R17 ) by L166 , NAT_1:44;
L168: C29 in ( dom ( IncAddr (R17 , ( LastLoc R16 )) ) ) by L167 , COMPOS_1:def 21;
L169: ( ( LastLoc R16 ) + C29 ) in ( dom ( Reloc (R17 , ( LastLoc R16 )) ) ) by L167 , COMPOS_1:46;
reconsider D3 = C29 as (Element of ( NAT )) by ORDINAL1:def 12;
L170: ( ( R16 ';' R17 ) . ( ( LastLoc R16 ) + D3 ) ) = ( ( Reloc (R17 , ( LastLoc R16 )) ) . ( ( LastLoc R16 ) + D3 ) ) by L169 , L163 , FUNCT_4:13
.= ( ( IncAddr (R17 , ( LastLoc R16 )) ) . D3 ) by L168 , VALUED_1:def 12
.= ( IncAddr (( R17 /. D3 ) , ( LastLoc R16 )) ) by L167 , COMPOS_1:def 21;
thus L171: thesis by L170;
end;
theorem
L172: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds ( ( R2 ';' R3 ) . 1 ) = ( IncAddr (R3 , 1) ))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
L173: ( 0 ) in ( dom ( Macro R3 ) ) by COMPOS_1:57;
L174: ( ( Macro R3 ) /. ( 0 ) ) = ( ( Macro R3 ) . ( 0 ) ) by L173 , PARTFUN1:def 6
.= R3 by COMPOS_1:58;
L175: ( LastLoc ( Macro R3 ) ) = 1 by L123;
thus L176: ( ( R2 ';' R3 ) . 1 ) = ( ( R2 ';' ( Macro R3 ) ) . ( ( LastLoc ( Macro R2 ) ) + ( 0 ) ) ) by L123
.= ( IncAddr (( ( Macro R3 ) /. ( 0 ) ) , ( LastLoc ( Macro R2 ) )) ) by L175 , L161
.= ( IncAddr (R3 , 1) ) by L174 , L123;
end;
theorem
L177: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R2 being  No-StopCode (Instruction of R1) holds (for R3 being  No-StopCode (Instruction of R1) holds (for R4 being  No-StopCode (Instruction of R1) holds ( ( ( R2 ';' R3 ) ';' R4 ) . 1 ) = ( IncAddr (R3 , 1) )))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R2 being  No-StopCode (Instruction of R1);
let R3 being  No-StopCode (Instruction of R1);
let R4 being  No-StopCode (Instruction of R1);
L178: ( LastLoc ( R2 ';' R3 ) ) = 2 by L125;
thus L179: ( ( ( R2 ';' R3 ) ';' R4 ) . 1 ) = ( ( R2 ';' R3 ) . 1 ) by L178 , L95 , L114
.= ( IncAddr (R3 , 1) ) by L172;
end;
theorem
L180: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 1 ) = ( IncAddr (R9 , 1) ))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
L181: ( LastLoc ( ( R8 ';' R9 ) ';' R10 ) ) = 3 by L127;
thus L182: ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 1 ) = ( ( ( R8 ';' R9 ) ';' R10 ) . 1 ) by L181 , L95 , L114
.= ( IncAddr (R9 , 1) ) by L177;
end;
theorem
L183: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 1 ) = ( IncAddr (R9 , 1) )))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
L184: ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 4 by L129;
thus L185: ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 1 ) = ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 1 ) by L184 , L95 , L114
.= ( IncAddr (R9 , 1) ) by L180;
end;
theorem
L186: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 1 ) = ( IncAddr (R9 , 1) ))))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
L187: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5 by L131;
thus L188: ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 1 ) = ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 1 ) by L187 , L95 , L114
.= ( IncAddr (R9 , 1) ) by L183;
end;
theorem
L189: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R3 being  No-StopCode (Instruction of R1) holds (for R16 being (MacroInstruction of R1) holds ( ( R16 ';' R3 ) . ( LastLoc R16 ) ) = ( IncAddr (R3 , ( LastLoc R16 )) ))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R3 being  No-StopCode (Instruction of R1);
let R16 being (MacroInstruction of R1);
L190: ( 0 ) <= ( LastLoc ( Macro R3 ) ) by NAT_1:2;
L191: ( 0 ) in ( dom ( Macro R3 ) ) by COMPOS_1:57;
L192: ( ( Macro R3 ) /. ( 0 ) ) = ( ( Macro R3 ) . ( 0 ) ) by L191 , PARTFUN1:def 6
.= R3 by COMPOS_1:58;
thus L193: ( ( R16 ';' R3 ) . ( LastLoc R16 ) ) = ( ( R16 ';' ( Macro R3 ) ) . ( ( LastLoc R16 ) + ( 0 ) ) )
.= ( IncAddr (( ( Macro R3 ) /. ( 0 ) ) , ( LastLoc R16 )) ) by L190 , L161
.= ( IncAddr (R3 , ( LastLoc R16 )) ) by L192;
end;
theorem
L194: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds ( ( ( R8 ';' R9 ) ';' R10 ) . 2 ) = ( IncAddr (R10 , 2) )))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
L195: ( LastLoc ( R8 ';' R9 ) ) = 2 by L125;
thus L196: thesis by L195 , L189;
end;
theorem
L197: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 2 ) = ( IncAddr (R10 , 2) ))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
L198: ( LastLoc ( ( R8 ';' R9 ) ';' R10 ) ) = 3 by L127;
thus L199: ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 2 ) = ( ( ( R8 ';' R9 ) ';' R10 ) . 2 ) by L198 , L95 , L114
.= ( IncAddr (R10 , 2) ) by L194;
end;
theorem
L200: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 2 ) = ( IncAddr (R10 , 2) )))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
L201: ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 4 by L129;
thus L202: ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 2 ) = ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 2 ) by L201 , L95 , L114
.= ( IncAddr (R10 , 2) ) by L197;
end;
theorem
L203: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 2 ) = ( IncAddr (R10 , 2) ))))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
L204: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5 by L131;
thus L205: ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 2 ) = ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 2 ) by L204 , L95 , L114
.= ( IncAddr (R10 , 2) ) by L200;
end;
theorem
L206: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 3 ) = ( IncAddr (R11 , 3) ))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
L207: ( LastLoc ( ( R8 ';' R9 ) ';' R10 ) ) = 3 by L127;
thus L208: thesis by L207 , L189;
end;
theorem
L209: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 3 ) = ( IncAddr (R11 , 3) )))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
L210: ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 4 by L129;
thus L211: ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 3 ) = ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) . 3 ) by L95 , L210 , L114
.= ( IncAddr (R11 , 3) ) by L206;
end;
theorem
L212: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 3 ) = ( IncAddr (R11 , 3) ))))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
L213: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5 by L131;
thus L214: ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 3 ) = ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 3 ) by L95 , L213 , L114
.= ( IncAddr (R11 , 3) ) by L209;
end;
theorem
L215: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 4 ) = ( IncAddr (R12 , 4) )))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
L216: ( LastLoc ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ) = 4 by L129;
thus L217: thesis by L216 , L189;
end;
theorem
L218: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 4 ) = ( IncAddr (R12 , 4) ))))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
L219: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5 by L131;
thus L220: ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 4 ) = ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) . 4 ) by L95 , L219 , L114
.= ( IncAddr (R12 , 4) ) by L215;
end;
theorem
L221: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for R8 being  No-StopCode (Instruction of R1) holds (for R9 being  No-StopCode (Instruction of R1) holds (for R10 being  No-StopCode (Instruction of R1) holds (for R11 being  No-StopCode (Instruction of R1) holds (for R12 being  No-StopCode (Instruction of R1) holds (for R13 being  No-StopCode (Instruction of R1) holds ( ( ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ';' R13 ) . 5 ) = ( IncAddr (R13 , 5) ))))))))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let R8 being  No-StopCode (Instruction of R1);
let R9 being  No-StopCode (Instruction of R1);
let R10 being  No-StopCode (Instruction of R1);
let R11 being  No-StopCode (Instruction of R1);
let R12 being  No-StopCode (Instruction of R1);
let R13 being  No-StopCode (Instruction of R1);
L222: ( LastLoc ( ( ( ( R8 ';' R9 ) ';' R10 ) ';' R11 ) ';' R12 ) ) = 5 by L131;
thus L223: thesis by L222 , L189;
end;
definition
let R1 being  with_non_trivial_Instructions COM-Struct;
let C30 being (preProgram of R1);
attr C30 is  closed
means
:L224: (for B16 being (Instruction of R1) holds (B16 in ( rng C30 ) implies ( rng ( JumpPart B16 ) ) c= ( dom C30 )));
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
cluster ( Stop R1 ) ->  closed;
coherence
proof
let C31 being (Instruction of R1);
assume L226: C31 in ( rng ( Stop R1 ) );
L227: ( rng ( Stop R1 ) ) = { ( halt R1 ) } by AFINSQ_1:33;
L228: C31 = ( halt R1 ) by L227 , L226 , TARSKI:def 1;
L229: ( rng ( JumpPart C31 ) ) = ( {} ) by L228;
thus L230: ( rng ( JumpPart C31 ) ) c= ( dom ( Stop R1 ) ) by L229 , XBOOLE_1:2;
end;
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
cluster  closed for (MacroInstruction of R1);
existence
proof
take ( Stop R1 );
thus L232: thesis;
end;
end;
theorem
L234: (for R1 being  with_non_trivial_Instructions COM-Struct holds (for B17 being  No-StopCode (Instruction of R1) holds (B17 is  ins-loc-free implies ( Macro B17 ) is  closed)))
proof
let R1 being  with_non_trivial_Instructions COM-Struct;
let C32 being  No-StopCode (Instruction of R1);
assume that
L235: C32 is  ins-loc-free;
let C33 being (Instruction of R1);
assume L236: C33 in ( rng ( Macro C32 ) );
L237: C33 in { C32 , ( halt R1 ) } by L236 , COMPOS_1:67;
L238: (C33 = C32 or C33 = ( halt R1 )) by L237 , TARSKI:def 2;
L239: ( rng ( JumpPart C33 ) ) = ( {} ) by L238 , L235;
thus L240: ( rng ( JumpPart C33 ) ) c= ( dom ( Macro C32 ) ) by L239 , XBOOLE_1:2;
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
let C34 being  closed (MacroInstruction of R1);
let C35 being Nat;
cluster ( Reloc (C34 , C35) ) ->  closed;
coherence
proof
let C36 being (Instruction of R1);
assume L241: C36 in ( rng ( Reloc (C34 , C35) ) );
consider C37 being set such that L242: C37 in ( dom ( Reloc (C34 , C35) ) ) and L243: ( ( Reloc (C34 , C35) ) . C37 ) = C36 by L241 , FUNCT_1:def 3;
L244: ( dom ( Reloc (C34 , C35) ) ) c= ( NAT ) by RELAT_1:def 18;
reconsider D4 = C37 as Nat by L244 , L242;
L245: ( dom ( Reloc (C34 , C35) ) ) = ( dom ( Shift (C34 , C35) ) ) by COMPOS_1:32;
consider C38 being Nat such that L246: C38 in ( dom C34 ) and L247: D4 = ( C38 + C35 ) by L245 , L242 , VALUED_1:39;
L248: ( C34 . C38 ) = ( C34 /. C38 ) by L246 , PARTFUN1:def 6;
reconsider D5 = ( C34 . C38 ) as (Instruction of R1) by L248;
L249: ( IncAddr (D5 , C35) ) = C36 by L243 , L246 , L247 , COMPOS_1:35;
let C39 being set;
assume L250: C39 in ( rng ( JumpPart C36 ) );
consider C40 being set such that L251: C40 in ( dom ( JumpPart C36 ) ) and L252: ( ( JumpPart C36 ) . C40 ) = C39 by L250 , FUNCT_1:def 3;
L253: ( dom ( JumpPart C36 ) ) c= ( NAT ) by RELAT_1:def 18;
reconsider D6 = C40 as Nat by L253 , L251;
L254: ( JumpPart C36 ) = ( ( JumpPart D5 ) + C35 ) by L249 , COMPOS_0:def 9;
L255: ( dom ( JumpPart C36 ) ) = ( dom ( JumpPart D5 ) ) by L254 , VALUED_1:def 2;
L256: ( rng ( JumpPart C36 ) ) c= ( NAT ) by RELAT_1:def 19;
reconsider D7 = C39 as Nat by L256 , L250;
reconsider D8 = ( ( JumpPart D5 ) . D6 ) as Nat;
L257: D7 = ( D8 + C35 ) by L252 , L254 , L251 , VALUED_1:def 2;
L258: D8 in ( rng ( JumpPart D5 ) ) by L251 , L255 , FUNCT_1:3;
L259: D5 in ( rng C34 ) by L246 , FUNCT_1:3;
L260: ( rng ( JumpPart D5 ) ) c= ( dom C34 ) by L259 , L224;
thus L261: C39 in ( dom ( Reloc (C34 , C35) ) ) by L260 , L245 , L257 , L258 , VALUED_1:24;
end;
end;
registration
let R1 being  with_non_trivial_Instructions COM-Struct;
let C41 , C42 being  closed (MacroInstruction of R1);
cluster ( C41 ';' C42 ) ->  closed;
coherence
proof
let C43 being (Instruction of R1);
assume that
L263: C43 in ( rng ( C41 ';' C42 ) );
L264: ( rng ( C41 ';' C42 ) ) c= ( ( rng ( CutLastLoc C41 ) ) \/ ( rng ( Reloc (C42 , ( ( card C41 ) -' 1 )) ) ) ) by FUNCT_4:17;
per cases  by L264 , L263 , XBOOLE_0:def 3;
suppose L265: C43 in ( rng ( CutLastLoc C41 ) );

L266: ( rng ( CutLastLoc C41 ) ) c= ( rng C41 ) by RELAT_1:11;
L267: ( rng ( JumpPart C43 ) ) c= ( dom C41 ) by L266 , L265 , L224;
L268: ( dom C41 ) c= ( dom ( C41 ';' C42 ) ) by COMPOS_1:21;
thus L269: ( rng ( JumpPart C43 ) ) c= ( dom ( C41 ';' C42 ) ) by L268 , L267 , XBOOLE_1:1;
end;
suppose L270: C43 in ( rng ( Reloc (C42 , ( ( card C41 ) -' 1 )) ) );

L271: ( rng ( JumpPart C43 ) ) c= ( dom ( Reloc (C42 , ( ( card C41 ) -' 1 )) ) ) by L270 , L224;
L272: ( dom ( Reloc (C42 , ( ( card C41 ) -' 1 )) ) ) c= ( dom ( C41 ';' C42 ) ) by FUNCT_4:10;
thus L273: ( rng ( JumpPart C43 ) ) c= ( dom ( C41 ';' C42 ) ) by L272 , L271 , XBOOLE_1:1;
end;
end;
end;
