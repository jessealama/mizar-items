:: Linear Combinations in Vector Space
::  by Wojciech A. Trybulec
::
:: Received July 27, 1990
:: Copyright (c) 1990-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSEQ_1, SUBSET_1, RLVECT_1, ALGSTR_0, BINOP_1,
      VECTSP_1, LATTICES, XBOOLE_0, STRUCT_0, FUNCT_1, RLVECT_2, FUNCT_2,
      FINSET_1, SUPINF_2, FUNCOP_1, TARSKI, VALUED_1, NAT_1, RELAT_1, PARTFUN1,
      XXREAL_0, CARD_1, ORDINAL4, ARYTM_3, CARD_3, MESFUNC1, RLSUB_1, ARYTM_1,
      FINSEQ_4;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, XXREAL_0,
      FINSET_1, PARTFUN1, FINSEQ_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCOP_1,
      ORDINAL1, NAT_1, DOMAIN_1, STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1,
      VECTSP_1, FINSEQ_4, VFUNCT_1, VECTSP_4;
 constructors PARTFUN1, DOMAIN_1, FUNCOP_1, XXREAL_0, NAT_1, MEMBERED,
      FINSEQ_4, VECTSP_4, RELSET_1, VFUNCT_1;
 registrations SUBSET_1, FUNCT_1, RELSET_1, FINSET_1, NUMBERS, MEMBERED,
      STRUCT_0, VECTSP_1, XXREAL_0, CARD_1, FINSEQ_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions FUNCT_1, TARSKI, VECTSP_4, XBOOLE_0, RELAT_1;
 theorems CARD_1, CARD_2, ENUMSET1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_4,
      FUNCT_1, FUNCT_2, RLVECT_1, RLVECT_2, TARSKI, VECTSP_1, VFUNCT_1,
      VECTSP_4, ZFMISC_1, NAT_1, RELAT_1, RELSET_1, XBOOLE_0, XBOOLE_1,
      XCMPLX_1, GROUP_1, FUNCOP_1, XREAL_1, PARTFUN1;
 schemes FINSEQ_1, FUNCT_2, NAT_1;

begin
definition
let C1 being non  empty ZeroStr;
let C2 being non  empty VectSpStr over C1;
mode Linear_Combination of C2
 -> (Element of ( Funcs ((the carrier of C2) , (the carrier of C1)) ))
means :L1: (ex B1 being  finite (Subset of C2) st (for B2 being (Element of C2) holds ((not B2 in B1) implies ( it . B2 ) = ( 0. C1 ))));
existence
proof
reconsider D1 = ( (the carrier of C2) --> ( 0. C1 ) ) as (Function of (the carrier of C2) , (the carrier of C1));
reconsider D2 = D1 as (Element of ( Funcs ((the carrier of C2) , (the carrier of C1)) )) by FUNCT_2:8;
take D2;
take ( {} C2 );
thus L2: thesis by FUNCOP_1:7;
end;
end;
definition
let C3 being non  empty ZeroStr;
let C4 being non  empty VectSpStr over C3;
let C5 being (Linear_Combination of C4);
func Carrier C5 ->  finite (Subset of C4) equals 
{ B3 where B3 is (Element of C4) : ( C5 . B3 ) <> ( 0. C3 ) };
coherence
proof
set D3 = { B4 where B4 is (Element of C4) : ( C5 . B4 ) <> ( 0. C3 ) };
consider C6 being  finite (Subset of C4) such that L4: (for B5 being (Element of C4) holds ((not B5 in C6) implies ( C5 . B5 ) = ( 0. C3 ))) by L1;
L5: D3 c= C6
proof
let R4 being set;
assume L6: R4 in D3;
L7: (ex B6 being (Element of C4) st (R4 = B6 & ( C5 . B6 ) <> ( 0. C3 ))) by L6;
thus L8: thesis by L7 , L4;
end;
thus L9: thesis by L5 , XBOOLE_1:1;
end;
end;
theorem
L11: (for R4 being set holds (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds (R4 in ( Carrier R26 ) iff (ex R13 being (Element of R11) st (R4 = R13 & ( R26 . R13 ) <> ( 0. R10 ))))))));
theorem
L12: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R26 being (Linear_Combination of R11) holds (( R26 . R13 ) = ( 0. R10 ) iff (not R13 in ( Carrier R26 )))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R26 being (Linear_Combination of R11);
thus L13: (( R26 . R13 ) = ( 0. R10 ) implies (not R13 in ( Carrier R26 )))
proof
assume L14: ( R26 . R13 ) = ( 0. R10 );
assume L15: (not thesis);
L16: (ex R12 being (Element of R11) st (R12 = R13 & ( R26 . R12 ) <> ( 0. R10 ))) by L15;
thus L17: thesis by L16 , L14;
end;

assume L18: (not R13 in ( Carrier R26 ));
thus L19: thesis by L18;
end;
definition
let C7 being non  empty ZeroStr;
let C8 being non  empty VectSpStr over C7;
func ZeroLC C8 -> (Linear_Combination of C8) means 
:L20: ( Carrier it ) = ( {} );
existence
proof
reconsider D4 = ( (the carrier of C8) --> ( 0. C7 ) ) as (Function of (the carrier of C8) , (the carrier of C7));
reconsider D5 = D4 as (Element of ( Funcs ((the carrier of C8) , (the carrier of C7)) )) by FUNCT_2:8;
L21: D5 is (Linear_Combination of C8)
proof
reconsider D6 = ( {} C8 ) as  empty  finite (Subset of C8);
take D6;
thus L22: thesis by FUNCOP_1:7;
end;
reconsider D7 = D5 as (Linear_Combination of C8) by L21;
take D7;
set D8 = { B7 where B7 is (Element of C8) : ( D7 . B7 ) <> ( 0. C7 ) };
L23:
now
set D9 = the (Element of D8);
assume L24: D8 <> ( {} );
L25: D9 in D8 by L24;
L26: (ex B8 being (Element of C8) st (D9 = B8 & ( D7 . B8 ) <> ( 0. C7 ))) by L25;
thus L27: contradiction by L26 , FUNCOP_1:7;
end;
thus L28: thesis by L23;
end;
uniqueness
proof
let C9 , C10 being (Linear_Combination of C8);
reconsider D10 = C9 , D11 = C10 as (Function of (the carrier of C8) , (the carrier of C7));
assume that
L29: ( Carrier C9 ) = ( {} )
and
L30: ( Carrier C10 ) = ( {} );
L31:
now
let R4 being set;
assume L32: R4 in (the carrier of C8);
reconsider D12 = R4 as (Element of C8) by L32;
L33:
now
assume L34: ( C10 . D12 ) <> ( 0. C7 );
L35: D12 in { B9 where B9 is (Element of C8) : ( C10 . B9 ) <> ( 0. C7 ) } by L34;
thus L36: contradiction by L35 , L30;
end;
L37:
now
assume L38: ( C9 . D12 ) <> ( 0. C7 );
L39: D12 in { B10 where B10 is (Element of C8) : ( C9 . B10 ) <> ( 0. C7 ) } by L38;
thus L40: contradiction by L39 , L29;
end;
thus L41: ( D10 . R4 ) = ( D11 . R4 ) by L37 , L33;
end;
thus L42: thesis by L31 , FUNCT_2:12;
end;
end;
theorem
L44: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds ( ( ZeroLC R11 ) . R13 ) = ( 0. R10 ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
L45: (( Carrier ( ZeroLC R11 ) ) = ( {} ) & (not R13 in ( {} ))) by L20;
thus L46: thesis by L45;
end;
definition
let C11 being non  empty ZeroStr;
let C12 being non  empty VectSpStr over C11;
let C13 being (Subset of C12);
mode Linear_Combination of C13
 -> (Linear_Combination of C12)
means :L47: ( Carrier it ) c= C13;
existence
proof
take D13 = ( ZeroLC C12 );
L48: ( Carrier D13 ) = ( {} ) by L20;
thus L49: thesis by L48 , XBOOLE_1:2;
end;
end;
theorem
L51: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R23 being (Subset of R11) holds (for R24 being (Subset of R11) holds (for R30 being (Linear_Combination of R23) holds (R23 c= R24 implies R30 is (Linear_Combination of R24)))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R23 being (Subset of R11);
let R24 being (Subset of R11);
let R30 being (Linear_Combination of R23);
assume L52: R23 c= R24;
L53: ( Carrier R30 ) c= R23 by L47;
L54: ( Carrier R30 ) c= R24 by L53 , L52 , XBOOLE_1:1;
thus L55: thesis by L54 , L47;
end;
theorem
L56: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R23 being (Subset of R11) holds ( ZeroLC R11 ) is (Linear_Combination of R23))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R23 being (Subset of R11);
L57: (( Carrier ( ZeroLC R11 ) ) = ( {} ) & ( {} ) c= R23) by L20 , XBOOLE_1:2;
thus L58: thesis by L57 , L47;
end;
theorem
L59: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for B11 being (Linear_Combination of ( {} (the carrier of R11) )) holds B11 = ( ZeroLC R11 ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let C14 being (Linear_Combination of ( {} (the carrier of R11) ));
L60: ( Carrier C14 ) c= ( {} ) by L47;
L61: ( Carrier C14 ) = ( {} ) by L60;
thus L62: thesis by L61 , L20;
end;
theorem
L63: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds R26 is (Linear_Combination of ( Carrier R26 ))))) by L47;
definition
let C15 being non  empty addLoopStr;
let C16 being non  empty VectSpStr over C15;
let C17 being (FinSequence of (the carrier of C16));
let C18 being (Function of C16 , C15);
func C18 (#) C17 -> (FinSequence of C16) means 
:L64: (( len it ) = ( len C17 ) & (for B12 being Nat holds (B12 in ( dom it ) implies ( it . B12 ) = ( ( C18 . ( C17 /. B12 ) ) * ( C17 /. B12 ) ))));
existence
proof
deffunc H1(Nat) = ( ( C18 . ( C17 /. $1 ) ) * ( C17 /. $1 ) );
consider C19 being FinSequence such that L65: ( len C19 ) = ( len C17 ) and L66: (for B13 being Nat holds (B13 in ( dom C19 ) implies ( C19 . B13 ) = H1(B13))) from FINSEQ_1:sch 2;
L67: ( rng C19 ) c= (the carrier of C16)
proof
let R4 being set;
assume L68: R4 in ( rng C19 );
consider R5 being set such that L69: R5 in ( dom C19 ) and L70: ( C19 . R5 ) = R4 by L68 , FUNCT_1:def 3;
L71: R5 in ( Seg ( len C17 ) ) by L65 , L69 , FINSEQ_1:def 3;
reconsider D14 = R5 as (Element of ( NAT )) by L71;
L72: ( C19 . D14 ) = ( ( C18 . ( C17 /. D14 ) ) * ( C17 /. D14 ) ) by L66 , L69;
thus L73: thesis by L72 , L70;
end;
reconsider D15 = C19 as (FinSequence of (the carrier of C16)) by L67 , FINSEQ_1:def 4;
take D15;
thus L74: thesis by L65 , L66;
end;
uniqueness
proof
let C20 , C21 being (FinSequence of (the carrier of C16));
assume that
L75: ( len C20 ) = ( len C17 )
and
L76: (for B14 being Nat holds (B14 in ( dom C20 ) implies ( C20 . B14 ) = ( ( C18 . ( C17 /. B14 ) ) * ( C17 /. B14 ) )))
and
L77: ( len C21 ) = ( len C17 )
and
L78: (for B15 being Nat holds (B15 in ( dom C21 ) implies ( C21 . B15 ) = ( ( C18 . ( C17 /. B15 ) ) * ( C17 /. B15 ) )));
L79:
now
let C22 being Nat;
assume L80: (1 <= C22 & C22 <= ( len C20 ));
L81: C22 in ( Seg ( len C20 ) ) by L80 , FINSEQ_1:1;
L82: C22 in ( dom C20 ) by L81 , FINSEQ_1:def 3;
L83: ( C20 . C22 ) = ( ( C18 . ( C17 /. C22 ) ) * ( C17 /. C22 ) ) by L82 , L76;
L84: C22 in ( dom C21 ) by L75 , L77 , L81 , FINSEQ_1:def 3;
thus L85: ( C20 . C22 ) = ( C21 . C22 ) by L84 , L78 , L83;
end;
thus L86: thesis by L79 , L75 , L77 , FINSEQ_1:14;
end;
end;
theorem
L88: (for R8 being (Element of ( NAT )) holds (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R20 being (FinSequence of R11) holds (for R25 being (Function of R11 , R10) holds ((R8 in ( dom R20 ) & R13 = ( R20 . R8 )) implies ( ( R25 (#) R20 ) . R8 ) = ( ( R25 . R13 ) * R13 ))))))))
proof
let R8 being (Element of ( NAT ));
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R20 being (FinSequence of R11);
let R25 being (Function of R11 , R10);
assume that
L89: R8 in ( dom R20 )
and
L90: R13 = ( R20 . R8 );
L91: ( R20 /. R8 ) = ( R20 . R8 ) by L89 , PARTFUN1:def 6;
L92: ( len ( R25 (#) R20 ) ) = ( len R20 ) by L64;
L93: R8 in ( dom ( R25 (#) R20 ) ) by L92 , L89 , FINSEQ_3:29;
thus L94: thesis by L93 , L90 , L91 , L64;
end;
theorem
L95: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R25 being (Function of R11 , R10) holds ( R25 (#) ( <*> (the carrier of R11) ) ) = ( <*> (the carrier of R11) ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R25 being (Function of R11 , R10);
L96: ( len ( R25 (#) ( <*> (the carrier of R11) ) ) ) = ( len ( <*> (the carrier of R11) ) ) by L64
.= ( 0 );
thus L97: thesis by L96;
end;
theorem
L98: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R25 being (Function of R11 , R10) holds ( R25 (#) <* R13 *> ) = <* ( ( R25 . R13 ) * R13 ) *>))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R25 being (Function of R11 , R10);
L99: 1 in { 1 } by TARSKI:def 1;
L100: ( len ( R25 (#) <* R13 *> ) ) = ( len <* R13 *> ) by L64
.= 1 by FINSEQ_1:40;
L101: ( dom ( R25 (#) <* R13 *> ) ) = { 1 } by L100 , FINSEQ_1:2 , FINSEQ_1:def 3;
L102: ( ( R25 (#) <* R13 *> ) . 1 ) = ( ( R25 . ( <* R13 *> /. 1 ) ) * ( <* R13 *> /. 1 ) ) by L101 , L99 , L64
.= ( ( R25 . ( <* R13 *> /. 1 ) ) * R13 ) by FINSEQ_4:16
.= ( ( R25 . R13 ) * R13 ) by FINSEQ_4:16;
thus L103: thesis by L102 , L100 , FINSEQ_1:40;
end;
theorem
L104: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R14 being (Element of R11) holds (for R15 being (Element of R11) holds (for R25 being (Function of R11 , R10) holds ( R25 (#) <* R14 , R15 *> ) = <* ( ( R25 . R14 ) * R14 ) , ( ( R25 . R15 ) * R15 ) *>)))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R14 being (Element of R11);
let R15 being (Element of R11);
let R25 being (Function of R11 , R10);
L105: ( len ( R25 (#) <* R14 , R15 *> ) ) = ( len <* R14 , R15 *> ) by L64
.= 2 by FINSEQ_1:44;
L106: ( dom ( R25 (#) <* R14 , R15 *> ) ) = { 1 , 2 } by L105 , FINSEQ_1:2 , FINSEQ_1:def 3;
L107: 2 in { 1 , 2 } by TARSKI:def 2;
L108: ( ( R25 (#) <* R14 , R15 *> ) . 2 ) = ( ( R25 . ( <* R14 , R15 *> /. 2 ) ) * ( <* R14 , R15 *> /. 2 ) ) by L107 , L106 , L64
.= ( ( R25 . ( <* R14 , R15 *> /. 2 ) ) * R15 ) by FINSEQ_4:17
.= ( ( R25 . R15 ) * R15 ) by FINSEQ_4:17;
L109: 1 in { 1 , 2 } by TARSKI:def 2;
L110: ( ( R25 (#) <* R14 , R15 *> ) . 1 ) = ( ( R25 . ( <* R14 , R15 *> /. 1 ) ) * ( <* R14 , R15 *> /. 1 ) ) by L109 , L106 , L64
.= ( ( R25 . ( <* R14 , R15 *> /. 1 ) ) * R14 ) by FINSEQ_4:17
.= ( ( R25 . R14 ) * R14 ) by FINSEQ_4:17;
thus L111: thesis by L110 , L105 , L108 , FINSEQ_1:44;
end;
theorem
L112: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R14 being (Element of R11) holds (for R15 being (Element of R11) holds (for R16 being (Element of R11) holds (for R25 being (Function of R11 , R10) holds ( R25 (#) <* R14 , R15 , R16 *> ) = <* ( ( R25 . R14 ) * R14 ) , ( ( R25 . R15 ) * R15 ) , ( ( R25 . R16 ) * R16 ) *>))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R14 being (Element of R11);
let R15 being (Element of R11);
let R16 being (Element of R11);
let R25 being (Function of R11 , R10);
L113: ( len ( R25 (#) <* R14 , R15 , R16 *> ) ) = ( len <* R14 , R15 , R16 *> ) by L64
.= 3 by FINSEQ_1:45;
L114: ( dom ( R25 (#) <* R14 , R15 , R16 *> ) ) = { 1 , 2 , 3 } by L113 , FINSEQ_1:def 3 , FINSEQ_3:1;
L115: 3 in { 1 , 2 , 3 } by ENUMSET1:def 1;
L116: ( ( R25 (#) <* R14 , R15 , R16 *> ) . 3 ) = ( ( R25 . ( <* R14 , R15 , R16 *> /. 3 ) ) * ( <* R14 , R15 , R16 *> /. 3 ) ) by L115 , L114 , L64
.= ( ( R25 . ( <* R14 , R15 , R16 *> /. 3 ) ) * R16 ) by FINSEQ_4:18
.= ( ( R25 . R16 ) * R16 ) by FINSEQ_4:18;
L117: 2 in { 1 , 2 , 3 } by ENUMSET1:def 1;
L118: ( ( R25 (#) <* R14 , R15 , R16 *> ) . 2 ) = ( ( R25 . ( <* R14 , R15 , R16 *> /. 2 ) ) * ( <* R14 , R15 , R16 *> /. 2 ) ) by L117 , L114 , L64
.= ( ( R25 . ( <* R14 , R15 , R16 *> /. 2 ) ) * R15 ) by FINSEQ_4:18
.= ( ( R25 . R15 ) * R15 ) by FINSEQ_4:18;
L119: 1 in { 1 , 2 , 3 } by ENUMSET1:def 1;
L120: ( ( R25 (#) <* R14 , R15 , R16 *> ) . 1 ) = ( ( R25 . ( <* R14 , R15 , R16 *> /. 1 ) ) * ( <* R14 , R15 , R16 *> /. 1 ) ) by L119 , L114 , L64
.= ( ( R25 . ( <* R14 , R15 , R16 *> /. 1 ) ) * R14 ) by FINSEQ_4:18
.= ( ( R25 . R14 ) * R14 ) by FINSEQ_4:18;
thus L121: thesis by L120 , L113 , L118 , L116 , FINSEQ_1:45;
end;
theorem
L122: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R20 being (FinSequence of R11) holds (for R21 being (FinSequence of R11) holds (for R25 being (Function of R11 , R10) holds ( R25 (#) ( R20 ^ R21 ) ) = ( ( R25 (#) R20 ) ^ ( R25 (#) R21 ) ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R20 being (FinSequence of R11);
let R21 being (FinSequence of R11);
let R25 being (Function of R11 , R10);
set D16 = ( ( R25 (#) R20 ) ^ ( R25 (#) R21 ) );
set D17 = ( R20 ^ R21 );
L123: ( len R20 ) = ( len ( R25 (#) R20 ) ) by L64;
L124: ( len D16 ) = ( ( len ( R25 (#) R20 ) ) + ( len ( R25 (#) R21 ) ) ) by FINSEQ_1:22
.= ( ( len R20 ) + ( len ( R25 (#) R21 ) ) ) by L64
.= ( ( len R20 ) + ( len R21 ) ) by L64
.= ( len D17 ) by FINSEQ_1:22;
L125: ( len R21 ) = ( len ( R25 (#) R21 ) ) by L64;
L126:
now
let C23 being Nat;
assume L127: C23 in ( dom D16 );
L128:
now
per cases  by L127 , FINSEQ_1:25;
suppose L129: C23 in ( dom ( R25 (#) R20 ) );

L130: C23 in ( dom R20 ) by L129 , L123 , FINSEQ_3:29;
L131: C23 in ( dom ( R20 ^ R21 ) ) by L130 , FINSEQ_3:22;
L132: ( R20 /. C23 ) = ( R20 . C23 ) by L130 , PARTFUN1:def 6
.= ( ( R20 ^ R21 ) . C23 ) by L130 , FINSEQ_1:def 7
.= ( ( R20 ^ R21 ) /. C23 ) by L131 , PARTFUN1:def 6;
thus L133: ( D16 . C23 ) = ( ( R25 (#) R20 ) . C23 ) by L129 , FINSEQ_1:def 7
.= ( ( R25 . ( D17 /. C23 ) ) * ( D17 /. C23 ) ) by L129 , L132 , L64;
end;
suppose L134: (ex B16 being Nat st (B16 in ( dom ( R25 (#) R21 ) ) & C23 = ( ( len ( R25 (#) R20 ) ) + B16 )));

L135: C23 in ( dom D17 ) by L124 , L127 , FINSEQ_3:29;
consider C24 being Nat such that L136: C24 in ( dom ( R25 (#) R21 ) ) and L137: C23 = ( ( len ( R25 (#) R20 ) ) + C24 ) by L134;
L138: C24 in ( dom R21 ) by L125 , L136 , FINSEQ_3:29;
L139: ( R21 /. C24 ) = ( R21 . C24 ) by L138 , PARTFUN1:def 6
.= ( ( R20 ^ R21 ) . C23 ) by L123 , L137 , L138 , FINSEQ_1:def 7
.= ( ( R20 ^ R21 ) /. C23 ) by L135 , PARTFUN1:def 6;
thus L140: ( D16 . C23 ) = ( ( R25 (#) R21 ) . C24 ) by L136 , L137 , FINSEQ_1:def 7
.= ( ( R25 . ( D17 /. C23 ) ) * ( D17 /. C23 ) ) by L136 , L139 , L64;
end;
end;
thus L142: ( D16 . C23 ) = ( ( R25 . ( D17 /. C23 ) ) * ( D17 /. C23 ) ) by L128;
end;
thus L143: thesis by L126 , L124 , L64;
end;
definition
let C25 being non  empty addLoopStr;
let C26 being non  empty VectSpStr over C25;
let C27 being (Linear_Combination of C26);
assume L144: C26 is  Abelian  add-associative  right_zeroed  right_complementable;
func Sum C27 -> (Element of C26) means 
:L145: (ex B17 being (FinSequence of (the carrier of C26)) st (B17 is  one-to-one & ( rng B17 ) = ( Carrier C27 ) & it = ( Sum ( C27 (#) B17 ) )));
existence
proof
consider C28 being FinSequence such that L146: ( rng C28 ) = ( Carrier C27 ) and L147: C28 is  one-to-one by FINSEQ_4:58;
reconsider D18 = C28 as (FinSequence of (the carrier of C26)) by L146 , FINSEQ_1:def 4;
take ( Sum ( C27 (#) D18 ) );
take D18;
thus L148: (D18 is  one-to-one & ( rng D18 ) = ( Carrier C27 )) by L146 , L147;
thus L149: thesis;
end;
uniqueness
proof
let C29 , C30 being (Element of C26);
given C31 being (FinSequence of (the carrier of C26)) such that
L150: C31 is  one-to-one
and
L151: ( rng C31 ) = ( Carrier C27 )
and
L152: C29 = ( Sum ( C27 (#) C31 ) );

given C32 being (FinSequence of (the carrier of C26)) such that
L153: C32 is  one-to-one
and
L154: ( rng C32 ) = ( Carrier C27 )
and
L155: C30 = ( Sum ( C27 (#) C32 ) );

defpred S1[ set , set ] means { $2 } = ( C31 " { ( C32 . $1 ) } );
L156: ( len C31 ) = ( len C32 ) by L150 , L151 , L153 , L154 , FINSEQ_1:48;
L157: ( dom C31 ) = ( Seg ( len C31 ) ) by FINSEQ_1:def 3;
L158: ( dom C32 ) = ( Seg ( len C32 ) ) by FINSEQ_1:def 3;
L159: (for R4 being set holds (R4 in ( dom C31 ) implies (ex R5 being set st (R5 in ( dom C31 ) & S1[ R4 , R5 ]))))
proof
let R4 being set;
assume L160: R4 in ( dom C31 );
L161: ( C32 . R4 ) in ( rng C31 ) by L160 , L151 , L154 , L156 , L157 , L158 , FUNCT_1:def 3;
consider R5 being set such that L162: ( C31 " { ( C32 . R4 ) } ) = { R5 } by L161 , L150 , FUNCT_1:74;
take R5;
L163: R5 in ( C31 " { ( C32 . R4 ) } ) by L162 , TARSKI:def 1;
thus L164: R5 in ( dom C31 ) by L163 , FUNCT_1:def 7;
thus L165: thesis by L162;
end;
consider C33 being (Function of ( dom C31 ) , ( dom C31 )) such that L166: (for R4 being set holds (R4 in ( dom C31 ) implies S1[ R4 , ( C33 . R4 ) ])) from FUNCT_2:sch 1(L159);
L167: ( rng C33 ) = ( dom C31 )
proof
thus L168: ( rng C33 ) c= ( dom C31 ) by RELAT_1:def 19;
let R5 being set;
assume L169: R5 in ( dom C31 );
L170: ( C31 . R5 ) in ( rng C32 ) by L169 , L151 , L154 , FUNCT_1:def 3;
consider R4 being set such that L171: R4 in ( dom C32 ) and L172: ( C32 . R4 ) = ( C31 . R5 ) by L170 , FUNCT_1:def 3;
L173: ( C31 " { ( C32 . R4 ) } ) = ( C31 " ( Im (C31 , R5) ) ) by L169 , L172 , FUNCT_1:59;
L174: ( C31 " { ( C32 . R4 ) } ) c= { R5 } by L173 , L150 , FUNCT_1:82;
L175: { ( C33 . R4 ) } c= { R5 } by L174 , L156 , L157 , L158 , L166 , L171;
L176: ( C33 . R4 ) = R5 by L175 , ZFMISC_1:18;
L177: R4 in ( dom C33 ) by L156 , L157 , L158 , L171 , FUNCT_2:def 1;
thus L178: thesis by L177 , L176 , FUNCT_1:def 3;
end;
set D19 = ( C27 (#) C31 );
L179: ( len D19 ) = ( len C31 ) by L64;
L180: (( dom C31 ) = ( {} ) implies ( dom C31 ) = ( {} ));
L181: C33 is  one-to-one
proof
let R6 being set;
let R7 being set;
assume that
L182: R6 in ( dom C33 )
and
L183: R7 in ( dom C33 )
and
L184: ( C33 . R6 ) = ( C33 . R7 );
L185: R7 in ( dom C31 ) by L180 , L183 , FUNCT_2:def 1;
L186: ( C31 " { ( C32 . R7 ) } ) = { ( C33 . R7 ) } by L185 , L166;
L187: R6 in ( dom C31 ) by L180 , L182 , FUNCT_2:def 1;
L188: ( C32 . R6 ) in ( rng C31 ) by L187 , L151 , L154 , L156 , L157 , L158 , FUNCT_1:def 3;
L189: { ( C32 . R6 ) } c= ( rng C31 ) by L188 , ZFMISC_1:31;
L190: ( C32 . R7 ) in ( rng C31 ) by L151 , L154 , L156 , L157 , L158 , L185 , FUNCT_1:def 3;
L191: { ( C32 . R7 ) } c= ( rng C31 ) by L190 , ZFMISC_1:31;
L192: ( C31 " { ( C32 . R6 ) } ) = { ( C33 . R6 ) } by L166 , L187;
L193: { ( C32 . R6 ) } = { ( C32 . R7 ) } by L192 , L184 , L186 , L189 , L191 , FUNCT_1:91;
L194: ( C32 . R6 ) = ( C32 . R7 ) by L193 , ZFMISC_1:3;
L195: (R6 in ( dom C32 ) & R7 in ( dom C32 )) by L156 , L157 , L158 , L180 , L182 , L183 , FUNCT_2:def 1;
thus L196: thesis by L195 , L153 , L194 , FUNCT_1:def 4;
end;
set D20 = ( C27 (#) C32 );
L197: ( dom D20 ) = ( Seg ( len D20 ) ) by FINSEQ_1:def 3;
reconsider D21 = C33 as (Permutation of ( dom C31 )) by L167 , L181 , FUNCT_2:57;
L198: (( dom C31 ) = ( Seg ( len C31 ) ) & ( dom D19 ) = ( Seg ( len D19 ) )) by FINSEQ_1:def 3;
reconsider D22 = D21 as (Permutation of ( dom D19 )) by L198 , L179;
L199: ( len D20 ) = ( len C32 ) by L64;
L200: ( dom D19 ) = ( Seg ( len D19 ) ) by FINSEQ_1:def 3;
L201:
now
let R8 being (Element of ( NAT ));
assume L202: R8 in ( dom D20 );
L203: (( D20 . R8 ) = ( ( C27 . ( C32 /. R8 ) ) * ( C32 /. R8 ) ) & ( C32 . R8 ) = ( C32 /. R8 )) by L202 , L199 , L158 , L197 , L64 , PARTFUN1:def 6;
L204: R8 in ( dom C32 ) by L199 , L202 , FINSEQ_3:29;
reconsider D23 = ( C32 . R8 ) as (Element of C26) by L204 , FINSEQ_2:11;
L205: R8 in ( dom D22 ) by L156 , L179 , L199 , L200 , L197 , L202 , FUNCT_2:def 1;
L206: ( D22 . R8 ) in ( dom C31 ) by L205 , L167 , FUNCT_1:def 3;
reconsider D24 = ( D22 . R8 ) as (Element of ( NAT )) by L206 , L157;
reconsider D25 = ( C31 . D24 ) as (Element of C26) by L206 , FINSEQ_2:11;
L207: { ( C31 . ( D22 . R8 ) ) } = ( Im (C31 , ( D22 . R8 )) ) by L206 , FUNCT_1:59
.= ( C31 .: ( C31 " { ( C32 . R8 ) } ) ) by L156 , L199 , L157 , L197 , L166 , L202;
L208: D23 = D25 by L207 , FUNCT_1:75 , ZFMISC_1:18;
L209: ( C31 . D24 ) = ( C31 /. D24 ) by L206 , PARTFUN1:def 6;
thus L210: ( D20 . R8 ) = ( D19 . ( D22 . R8 ) ) by L209 , L179 , L157 , L200 , L206 , L208 , L203 , L64;
end;
thus L211: thesis by L201 , L144 , L150 , L151 , L152 , L153 , L154 , L155 , L179 , L199 , FINSEQ_1:48 , RLVECT_2:6;
end;
end;
L213: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds ( Sum ( ZeroLC R11 ) ) = ( 0. R11 )))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
consider R20 being (FinSequence of R11) such that L214: R20 is  one-to-one and L215: ( rng R20 ) = ( Carrier ( ZeroLC R11 ) ) and L216: ( Sum ( ZeroLC R11 ) ) = ( Sum ( ( ZeroLC R11 ) (#) R20 ) ) by L145;
L217: ( Carrier ( ZeroLC R11 ) ) = ( {} ) by L20;
L218: R20 = ( {} ) by L217 , L215 , RELAT_1:41;
L219: ( len R20 ) = ( 0 ) by L218;
L220: ( len ( ( ZeroLC R11 ) (#) R20 ) ) = ( 0 ) by L219 , L64;
thus L221: thesis by L220 , L216 , RLVECT_1:75;
end;
theorem
L222: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R23 being (Subset of R11) holds (( 0. R10 ) <> ( 1. R10 ) implies ((R23 <> ( {} ) & R23 is  linearly-closed) iff (for R30 being (Linear_Combination of R23) holds ( Sum R30 ) in R23))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R23 being (Subset of R11);
assume L223: ( 0. R10 ) <> ( 1. R10 );
thus L224: ((R23 <> ( {} ) & R23 is  linearly-closed) implies (for R30 being (Linear_Combination of R23) holds ( Sum R30 ) in R23))
proof
defpred S2[ (Element of ( NAT )) ] means (for R30 being (Linear_Combination of R23) holds (( card ( Carrier R30 ) ) = $1 implies ( Sum R30 ) in R23));
assume that
L225: R23 <> ( {} )
and
L226: R23 is  linearly-closed;
L227: S2[ ( 0 ) ]
proof
let R30 being (Linear_Combination of R23);
assume L228: ( card ( Carrier R30 ) ) = ( 0 );
L229: ( Carrier R30 ) = ( {} ) by L228;
L230: R30 = ( ZeroLC R11 ) by L229 , L20;
L231: ( Sum R30 ) = ( 0. R11 ) by L230 , L213;
thus L232: thesis by L231 , L225 , L226 , VECTSP_4:1;
end;
L233: (for R9 being (Element of ( NAT )) holds (S2[ R9 ] implies S2[ ( R9 + 1 ) ]))
proof
let R9 being (Element of ( NAT ));
assume L234: S2[ R9 ];
let R30 being (Linear_Combination of R23);
deffunc H2((Element of R11)) = ( R30 . $1 );
consider R20 being (FinSequence of R11) such that L235: R20 is  one-to-one and L236: ( rng R20 ) = ( Carrier R30 ) and L237: ( Sum R30 ) = ( Sum ( R30 (#) R20 ) ) by L145;
reconsider D26 = ( R20 | ( Seg R9 ) ) as (FinSequence of (the carrier of R11)) by FINSEQ_1:18;
assume L238: ( card ( Carrier R30 ) ) = ( R9 + 1 );
L239: ( len R20 ) = ( R9 + 1 ) by L238 , L235 , L236 , FINSEQ_4:62;
L240: ( len ( R30 (#) R20 ) ) = ( R9 + 1 ) by L239 , L64;
L241: ( R9 + 1 ) in ( Seg ( R9 + 1 ) ) by FINSEQ_1:4;
L242: ( R9 + 1 ) in ( dom R20 ) by L241 , L239 , FINSEQ_1:def 3;
L243: ( R9 + 1 ) in ( dom R20 ) by L239 , L241 , FINSEQ_1:def 3;
reconsider D27 = ( R20 . ( R9 + 1 ) ) as (Element of R11) by L243 , FINSEQ_2:11;
consider C34 being (Function of (the carrier of R11) , (the carrier of R10)) such that L244: ( C34 . D27 ) = ( 0. R10 ) and L245: (for B18 being (Element of R11) holds (B18 <> D27 implies ( C34 . B18 ) = H2(B18))) from FUNCT_2:sch 6;
reconsider D28 = C34 as (Element of ( Funcs ((the carrier of R11) , (the carrier of R10)) )) by FUNCT_2:8;
L246: D27 in ( Carrier R30 ) by L236 , L242 , FUNCT_1:def 3;
L247:
now
let R12 being (Element of R11);
assume L248: (not R12 in ( Carrier R30 ));
thus L249: ( D28 . R12 ) = ( R30 . R12 ) by L248 , L246 , L245
.= ( 0. R10 ) by L248;
end;
reconsider D29 = D28 as (Linear_Combination of R11) by L247 , L1;
L250: ( R23 \ { D27 } ) c= R23 by XBOOLE_1:36;
L251: ( Carrier R30 ) c= R23 by L47;
L252: ( ( R30 . D27 ) * D27 ) in R23 by L251 , L226 , L246 , VECTSP_4:def 1;
L253: ( Carrier D29 ) = ( ( Carrier R30 ) \ { D27 } )
proof
thus L254: ( Carrier D29 ) c= ( ( Carrier R30 ) \ { D27 } )
proof
let R4 being set;
assume L255: R4 in ( Carrier D29 );
consider R12 being (Element of R11) such that L256: R12 = R4 and L257: ( D29 . R12 ) <> ( 0. R10 ) by L255;
L258: ( D29 . R12 ) = ( R30 . R12 ) by L244 , L245 , L257;
L259: R4 in ( Carrier R30 ) by L258 , L256 , L257;
L260: (not R4 in { D27 }) by L244 , L256 , L257 , TARSKI:def 1;
thus L261: thesis by L260 , L259 , XBOOLE_0:def 5;
end;

let R4 being set;
assume L262: R4 in ( ( Carrier R30 ) \ { D27 } );
L263: R4 in ( Carrier R30 ) by L262 , XBOOLE_0:def 5;
consider R12 being (Element of R11) such that L264: R4 = R12 and L265: ( R30 . R12 ) <> ( 0. R10 ) by L263;
L266: (not R4 in { D27 }) by L262 , XBOOLE_0:def 5;
L267: R4 <> D27 by L266 , TARSKI:def 1;
L268: ( R30 . R12 ) = ( D29 . R12 ) by L267 , L245 , L264;
thus L269: thesis by L268 , L264 , L265;
end;
L270: ( Carrier D29 ) c= ( R23 \ { D27 } ) by L253 , L251 , XBOOLE_1:33;
L271: ( Carrier D29 ) c= R23 by L270 , L250 , XBOOLE_1:1;
reconsider D30 = D29 as (Linear_Combination of R23) by L271 , L47;
L272: ( len D26 ) = R9 by L239 , FINSEQ_3:53;
L273: ( len ( D30 (#) D26 ) ) = R9 by L272 , L64;
L274: ( rng D26 ) = ( Carrier D30 )
proof
thus L275: ( rng D26 ) c= ( Carrier D30 )
proof
let R4 being set;
assume L276: R4 in ( rng D26 );
consider R5 being set such that L277: R5 in ( dom D26 ) and L278: ( D26 . R5 ) = R4 by L276 , FUNCT_1:def 3;
reconsider D31 = R5 as (Element of ( NAT )) by L277 , FINSEQ_3:23;
L279: (( dom D26 ) c= ( dom R20 ) & ( D26 . D31 ) = ( R20 . D31 )) by L277 , FUNCT_1:47 , RELAT_1:60;
L280:
now
assume L281: R4 = D27;
L282: ( R9 + 1 ) = D31 by L281 , L235 , L242 , L277 , L278 , L279 , FUNCT_1:def 4;
L283: D31 <= R9 by L272 , L277 , FINSEQ_3:25;
thus L284: contradiction by L283 , L282 , XREAL_1:29;
end;
L285: (not R4 in { D27 }) by L280 , TARSKI:def 1;
L286: R4 in ( rng R20 ) by L277 , L278 , L279 , FUNCT_1:def 3;
thus L287: thesis by L286 , L236 , L253 , L285 , XBOOLE_0:def 5;
end;

let R4 being set;
assume L288: R4 in ( Carrier D30 );
L289: R4 in ( rng R20 ) by L288 , L236 , L253 , XBOOLE_0:def 5;
consider R5 being set such that L290: R5 in ( dom R20 ) and L291: ( R20 . R5 ) = R4 by L289 , FUNCT_1:def 3;
reconsider D32 = R5 as (Element of ( NAT )) by L290 , FINSEQ_3:23;
L292:
now
assume L293: (not D32 in ( Seg R9 ));
L294: D32 in ( ( dom R20 ) \ ( Seg R9 ) ) by L293 , L290 , XBOOLE_0:def 5;
L295: D32 in ( ( Seg ( R9 + 1 ) ) \ ( Seg R9 ) ) by L294 , L239 , FINSEQ_1:def 3;
L296: D32 in { ( R9 + 1 ) } by L295 , FINSEQ_3:15;
L297: D32 = ( R9 + 1 ) by L296 , TARSKI:def 1;
L298: (not D27 in { D27 }) by L297 , L253 , L288 , L291 , XBOOLE_0:def 5;
thus L299: contradiction by L298 , TARSKI:def 1;
end;
L300: D32 in ( ( dom R20 ) /\ ( Seg R9 ) ) by L292 , L290 , XBOOLE_0:def 4;
L301: D32 in ( dom D26 ) by L300 , RELAT_1:61;
L302: ( D26 . D32 ) = ( R20 . D32 ) by L301 , FUNCT_1:47;
thus L303: thesis by L302 , L291 , L301 , FUNCT_1:def 3;
end;
L304: ( ( Seg ( R9 + 1 ) ) /\ ( Seg R9 ) ) = ( Seg R9 ) by FINSEQ_1:7 , NAT_1:12
.= ( dom ( D30 (#) D26 ) ) by L273 , FINSEQ_1:def 3;
L305: ( dom ( D30 (#) D26 ) ) = ( ( dom ( R30 (#) R20 ) ) /\ ( Seg R9 ) ) by L304 , L240 , FINSEQ_1:def 3;
L306:
now
let R4 being set;
L307: ( rng R20 ) c= (the carrier of R11) by FINSEQ_1:def 4;
assume L308: R4 in ( dom ( D30 (#) D26 ) );
reconsider D33 = R4 as (Element of ( NAT )) by L308 , FINSEQ_3:23;
L309: D33 in ( dom ( R30 (#) R20 ) ) by L305 , L308 , XBOOLE_0:def 4;
L310: D33 in ( dom R20 ) by L309 , L239 , L240 , FINSEQ_3:29;
L311: ( R20 . D33 ) in ( rng R20 ) by L310 , FUNCT_1:def 3;
reconsider D34 = ( R20 . D33 ) as (Element of R11) by L311 , L307;
L312: D33 in ( dom D26 ) by L272 , L273 , L308 , FINSEQ_3:29;
L313: ( D26 . D33 ) in ( rng D26 ) by L312 , FUNCT_1:def 3;
L314: ( rng D26 ) c= (the carrier of R11) by FINSEQ_1:def 4;
reconsider D35 = ( D26 . D33 ) as (Element of R11) by L314 , L313;
L315: (not D35 in { D27 }) by L253 , L274 , L313 , XBOOLE_0:def 5;
L316: D35 <> D27 by L315 , TARSKI:def 1;
L317: ( ( D30 (#) D26 ) . D33 ) = ( ( D30 . D35 ) * D35 ) by L312 , L88
.= ( ( R30 . D35 ) * D35 ) by L245 , L316;
L318: D34 = D35 by L312 , FUNCT_1:47;
thus L319: ( ( D30 (#) D26 ) . R4 ) = ( ( R30 (#) R20 ) . R4 ) by L318 , L317 , L310 , L88;
end;
L320: ( D30 (#) D26 ) = ( ( R30 (#) R20 ) | ( Seg R9 ) ) by L306 , L305 , FUNCT_1:46;
L321: ( D30 (#) D26 ) = ( ( R30 (#) R20 ) | ( dom ( D30 (#) D26 ) ) ) by L320 , L273 , FINSEQ_1:def 3;
L322: D27 in ( rng R20 ) by L242 , FUNCT_1:def 3;
L323: { D27 } c= ( Carrier R30 ) by L322 , L236 , ZFMISC_1:31;
L324: ( card ( Carrier D30 ) ) = ( ( R9 + 1 ) - ( card { D27 } ) ) by L323 , L238 , L253 , CARD_2:44
.= ( ( R9 + 1 ) - 1 ) by CARD_1:30
.= R9 by XCMPLX_1:26;
L325: ( Sum D30 ) in R23 by L324 , L234;
L326: D26 is  one-to-one by L235 , FUNCT_1:52;
L327: ( Sum ( D30 (#) D26 ) ) = ( Sum D30 ) by L326 , L274 , L145;
L328: ( ( R30 (#) R20 ) . ( len R20 ) ) = ( ( R30 . D27 ) * D27 ) by L239 , L242 , L88;
L329: ( Sum ( R30 (#) R20 ) ) = ( ( Sum ( D30 (#) D26 ) ) + ( ( R30 . D27 ) * D27 ) ) by L328 , L239 , L240 , L273 , L321 , RLVECT_1:38;
thus L330: thesis by L329 , L226 , L237 , L252 , L327 , L325 , VECTSP_4:def 1;
end;
let R30 being (Linear_Combination of R23);
L331: ( card ( Carrier R30 ) ) = ( card ( Carrier R30 ) );
L332: (for R9 being (Element of ( NAT )) holds S2[ R9 ]) from NAT_1:sch 1(L227 , L233);
thus L333: thesis by L332 , L331;
end;

assume L334: (for R30 being (Linear_Combination of R23) holds ( Sum R30 ) in R23);
thus L335: R23 <> ( {} ) by L334;
L336: (( ZeroLC R11 ) is (Linear_Combination of R23) & ( Sum ( ZeroLC R11 ) ) = ( 0. R11 )) by L213 , L56;
L337: ( 0. R11 ) in R23 by L336 , L334;
L338: (for R18 being (Element of R10) holds (for R13 being (Element of R11) holds (R13 in R23 implies ( R18 * R13 ) in R23)))
proof
let R18 being (Element of R10);
let R13 being (Element of R11);
assume L339: R13 in R23;
L340:
now
per cases ;
suppose L341: R18 = ( 0. R10 );

thus L342: thesis by L341 , L337 , VECTSP_1:14;
end;
suppose L343: R18 <> ( 0. R10 );

deffunc H3(set) = ( 0. R10 );
consider R25 being (Function of R11 , R10) such that L344: ( R25 . R13 ) = R18 and L345: (for B19 being (Element of R11) holds (B19 <> R13 implies ( R25 . B19 ) = H3(B19))) from FUNCT_2:sch 6;
reconsider D36 = R25 as (Element of ( Funcs ((the carrier of R11) , (the carrier of R10)) )) by FUNCT_2:8;
L346:
now
let R12 being (Element of R11);
assume L347: (not R12 in { R13 });
L348: R12 <> R13 by L347 , TARSKI:def 1;
thus L349: ( D36 . R12 ) = ( 0. R10 ) by L348 , L345;
end;
reconsider D37 = D36 as (Linear_Combination of R11) by L346 , L1;
L350: ( Carrier D37 ) = { R13 }
proof
thus L351: ( Carrier D37 ) c= { R13 }
proof
let R4 being set;
assume L352: R4 in ( Carrier D37 );
consider R12 being (Element of R11) such that L353: R4 = R12 and L354: ( D37 . R12 ) <> ( 0. R10 ) by L352;
L355: R12 = R13 by L345 , L354;
thus L356: thesis by L355 , L353 , TARSKI:def 1;
end;

let R4 being set;
assume L357: R4 in { R13 };
L358: R4 = R13 by L357 , TARSKI:def 1;
thus L359: thesis by L358 , L343 , L344;
end;
L360: { R13 } c= R23 by L339 , ZFMISC_1:31;
reconsider D38 = D37 as (Linear_Combination of R23) by L360 , L350 , L47;
consider R20 being (FinSequence of R11) such that L361: (R20 is  one-to-one & ( rng R20 ) = ( Carrier D38 )) and L362: ( Sum ( D38 (#) R20 ) ) = ( Sum D38 ) by L145;
L363: R20 = <* R13 *> by L350 , L361 , FINSEQ_3:97;
L364: ( D38 (#) R20 ) = <* ( ( D38 . R13 ) * R13 ) *> by L363 , L98;
L365: ( Sum D38 ) = ( R18 * R13 ) by L364 , L344 , L362 , RLVECT_1:44;
thus L366: thesis by L365 , L334;
end;
end;
thus L368: thesis by L340;
end;
thus L369: (for R13 being (Element of R11) holds (for R12 being (Element of R11) holds ((R13 in R23 & R12 in R23) implies ( R13 + R12 ) in R23)))
proof
let R13 being (Element of R11);
let R12 being (Element of R11);
assume that
L370: R13 in R23
and
L371: R12 in R23;
L372:
now
per cases ;
suppose L373: R12 = R13;

L374: ( R13 + R12 ) = ( ( ( 1. R10 ) * R13 ) + R13 ) by L373 , VECTSP_1:def 17
.= ( ( ( 1. R10 ) * R13 ) + ( ( 1. R10 ) * R13 ) ) by VECTSP_1:def 17
.= ( ( ( 1. R10 ) + ( 1. R10 ) ) * R13 ) by VECTSP_1:def 15;
thus L375: thesis by L374 , L338 , L370;
end;
suppose L376: R13 <> R12;

deffunc H4(set) = ( 0. R10 );
consider R25 being (Function of R11 , R10) such that L377: (( R25 . R13 ) = ( 1. R10 ) & ( R25 . R12 ) = ( 1. R10 )) and L378: (for B20 being (Element of R11) holds ((B20 <> R13 & B20 <> R12) implies ( R25 . B20 ) = H4(B20))) from FUNCT_2:sch 7(L376);
reconsider D39 = R25 as (Element of ( Funcs ((the carrier of R11) , (the carrier of R10)) )) by FUNCT_2:8;
L379:
now
let R17 being (Element of R11);
assume L380: (not R17 in { R13 , R12 });
L381: (R17 <> R13 & R17 <> R12) by L380 , TARSKI:def 2;
thus L382: ( D39 . R17 ) = ( 0. R10 ) by L381 , L378;
end;
reconsider D40 = D39 as (Linear_Combination of R11) by L379 , L1;
L383: ( Carrier D40 ) = { R13 , R12 }
proof
thus L384: ( Carrier D40 ) c= { R13 , R12 }
proof
let R4 being set;
assume L385: R4 in ( Carrier D40 );
L386: (ex R17 being (Element of R11) st (R4 = R17 & ( D40 . R17 ) <> ( 0. R10 ))) by L385;
L387: (R4 = R13 or R4 = R12) by L386 , L378;
thus L388: thesis by L387 , TARSKI:def 2;
end;

let R4 being set;
assume L389: R4 in { R13 , R12 };
L390: (R4 = R13 or R4 = R12) by L389 , TARSKI:def 2;
thus L391: thesis by L390 , L223 , L377;
end;
L392: ( Carrier D40 ) c= R23 by L383 , L370 , L371 , ZFMISC_1:32;
L393: (( ( 1. R10 ) * R12 ) = R12 & ( ( 1. R10 ) * R13 ) = R13) by VECTSP_1:def 17;
reconsider D41 = D40 as (Linear_Combination of R23) by L392 , L47;
consider R20 being (FinSequence of R11) such that L394: (R20 is  one-to-one & ( rng R20 ) = ( Carrier D41 )) and L395: ( Sum ( D41 (#) R20 ) ) = ( Sum D41 ) by L145;
L396: (R20 = <* R13 , R12 *> or R20 = <* R12 , R13 *>) by L376 , L383 , L394 , FINSEQ_3:99;
L397: (( D41 (#) R20 ) = <* ( ( 1. R10 ) * R13 ) , ( ( 1. R10 ) * R12 ) *> or ( D41 (#) R20 ) = <* ( ( 1. R10 ) * R12 ) , ( ( 1. R10 ) * R13 ) *>) by L396 , L377 , L104;
L398: ( Sum D41 ) = ( R13 + R12 ) by L397 , L395 , L393 , RLVECT_1:45;
thus L399: thesis by L398 , L334;
end;
end;
thus L401: thesis by L372;
end;

thus L402: thesis by L338;
end;
theorem
L403: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds ( Sum ( ZeroLC R11 ) ) = ( 0. R11 ))) by L213;
theorem
L404: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for B21 being (Linear_Combination of ( {} (the carrier of R11) )) holds ( Sum B21 ) = ( 0. R11 ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let C35 being (Linear_Combination of ( {} (the carrier of R11) ));
L405: C35 = ( ZeroLC R11 ) by L59;
thus L406: thesis by L405 , L213;
end;
theorem
L407: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for B22 being (Linear_Combination of { R13 }) holds ( Sum B22 ) = ( ( B22 . R13 ) * R13 )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let C36 being (Linear_Combination of { R13 });
L408: ( Carrier C36 ) c= { R13 } by L47;
L409:
now
per cases  by L408 , ZFMISC_1:33;
suppose L410: ( Carrier C36 ) = ( {} );

L411: C36 = ( ZeroLC R11 ) by L410 , L20;
thus L412: ( Sum C36 ) = ( 0. R11 ) by L411 , L213
.= ( ( 0. R10 ) * R13 ) by VECTSP_1:14
.= ( ( C36 . R13 ) * R13 ) by L411 , L44;
end;
suppose L413: ( Carrier C36 ) = { R13 };

consider R20 being (FinSequence of R11) such that L414: (R20 is  one-to-one & ( rng R20 ) = { R13 }) and L415: ( Sum C36 ) = ( Sum ( C36 (#) R20 ) ) by L413 , L145;
L416: R20 = <* R13 *> by L414 , FINSEQ_3:97;
L417: ( C36 (#) R20 ) = <* ( ( C36 . R13 ) * R13 ) *> by L416 , L98;
thus L418: thesis by L417 , L415 , RLVECT_1:44;
end;
end;
thus L420: thesis by L409;
end;
theorem
L421: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R14 being (Element of R11) holds (for R15 being (Element of R11) holds (R14 <> R15 implies (for B23 being (Linear_Combination of { R14 , R15 }) holds ( Sum B23 ) = ( ( ( B23 . R14 ) * R14 ) + ( ( B23 . R15 ) * R15 ) )))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R14 being (Element of R11);
let R15 being (Element of R11);
assume L422: R14 <> R15;
let C37 being (Linear_Combination of { R14 , R15 });
L423: ( Carrier C37 ) c= { R14 , R15 } by L47;
L424:
now
per cases  by L423 , ZFMISC_1:36;
suppose L425: ( Carrier C37 ) = ( {} );

L426: C37 = ( ZeroLC R11 ) by L425 , L20;
thus L427: ( Sum C37 ) = ( 0. R11 ) by L426 , L213
.= ( ( 0. R11 ) + ( 0. R11 ) ) by RLVECT_1:4
.= ( ( ( 0. R10 ) * R14 ) + ( 0. R11 ) ) by VECTSP_1:14
.= ( ( ( 0. R10 ) * R14 ) + ( ( 0. R10 ) * R15 ) ) by VECTSP_1:14
.= ( ( ( C37 . R14 ) * R14 ) + ( ( 0. R10 ) * R15 ) ) by L426 , L44
.= ( ( ( C37 . R14 ) * R14 ) + ( ( C37 . R15 ) * R15 ) ) by L426 , L44;
end;
suppose L428: ( Carrier C37 ) = { R14 };

reconsider D42 = C37 as (Linear_Combination of { R14 }) by L428 , L47;
L429: (not R15 in ( Carrier C37 )) by L422 , L428 , TARSKI:def 1;
thus L430: ( Sum C37 ) = ( Sum D42 )
.= ( ( C37 . R14 ) * R14 ) by L407
.= ( ( ( C37 . R14 ) * R14 ) + ( 0. R11 ) ) by RLVECT_1:4
.= ( ( ( C37 . R14 ) * R14 ) + ( ( 0. R10 ) * R15 ) ) by VECTSP_1:14
.= ( ( ( C37 . R14 ) * R14 ) + ( ( C37 . R15 ) * R15 ) ) by L429;
end;
suppose L431: ( Carrier C37 ) = { R15 };

reconsider D43 = C37 as (Linear_Combination of { R15 }) by L431 , L47;
L432: (not R14 in ( Carrier C37 )) by L422 , L431 , TARSKI:def 1;
thus L433: ( Sum C37 ) = ( Sum D43 )
.= ( ( C37 . R15 ) * R15 ) by L407
.= ( ( 0. R11 ) + ( ( C37 . R15 ) * R15 ) ) by RLVECT_1:4
.= ( ( ( 0. R10 ) * R14 ) + ( ( C37 . R15 ) * R15 ) ) by VECTSP_1:14
.= ( ( ( C37 . R14 ) * R14 ) + ( ( C37 . R15 ) * R15 ) ) by L432;
end;
suppose L434: ( Carrier C37 ) = { R14 , R15 };

consider R20 being (FinSequence of R11) such that L435: (R20 is  one-to-one & ( rng R20 ) = { R14 , R15 }) and L436: ( Sum C37 ) = ( Sum ( C37 (#) R20 ) ) by L434 , L145;
L437: (R20 = <* R14 , R15 *> or R20 = <* R15 , R14 *>) by L422 , L435 , FINSEQ_3:99;
L438: (( C37 (#) R20 ) = <* ( ( C37 . R14 ) * R14 ) , ( ( C37 . R15 ) * R15 ) *> or ( C37 (#) R20 ) = <* ( ( C37 . R15 ) * R15 ) , ( ( C37 . R14 ) * R14 ) *>) by L437 , L104;
thus L439: thesis by L438 , L436 , RLVECT_1:45;
end;
end;
thus L441: thesis by L424;
end;
theorem
L442: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds (( Carrier R26 ) = ( {} ) implies ( Sum R26 ) = ( 0. R11 )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
assume L443: ( Carrier R26 ) = ( {} );
L444: R26 = ( ZeroLC R11 ) by L443 , L20;
thus L445: thesis by L444 , L213;
end;
theorem
L446: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R26 being (Linear_Combination of R11) holds (( Carrier R26 ) = { R13 } implies ( Sum R26 ) = ( ( R26 . R13 ) * R13 ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R26 being (Linear_Combination of R11);
assume L447: ( Carrier R26 ) = { R13 };
L448: R26 is (Linear_Combination of { R13 }) by L447 , L47;
thus L449: thesis by L448 , L407;
end;
theorem
L450: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R14 being (Element of R11) holds (for R15 being (Element of R11) holds (for R26 being (Linear_Combination of R11) holds ((( Carrier R26 ) = { R14 , R15 } & R14 <> R15) implies ( Sum R26 ) = ( ( ( R26 . R14 ) * R14 ) + ( ( R26 . R15 ) * R15 ) )))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R14 being (Element of R11);
let R15 being (Element of R11);
let R26 being (Linear_Combination of R11);
assume that
L451: ( Carrier R26 ) = { R14 , R15 }
and
L452: R14 <> R15;
L453: R26 is (Linear_Combination of { R14 , R15 }) by L451 , L47;
thus L454: thesis by L453 , L452 , L421;
end;
definition
let C38 being non  empty ZeroStr;
let C39 being non  empty VectSpStr over C38;
let C40 , C41 being (Linear_Combination of C39);
redefine pred C40 = C41
means
(for B24 being (Element of C39) holds ( C40 . B24 ) = ( C41 . B24 ))
;compatibility by FUNCT_2:63;
end;
definition
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
func R27 + R28 -> (Linear_Combination of R11) equals 
( R27 + R28 );
coherence
proof
set D44 = ( R27 + R28 );
L456: (( dom R27 ) = (the carrier of R11) & ( dom R28 ) = (the carrier of R11)) by FUNCT_2:def 1;
L457: ( dom D44 ) = ( ( dom R27 ) /\ ( dom R28 ) ) by VFUNCT_1:def 1;
L458: D44 is (Function of R11 , R10) by L457 , L456 , FUNCT_2:67;
L459: D44 is (Element of ( Funcs ((the carrier of R11) , (the carrier of R10)) )) by L458 , FUNCT_2:8;
L460:
now
let R13 being (Element of R11);
assume L461: (not R13 in ( ( Carrier R27 ) \/ ( Carrier R28 ) ));
L462: (not R13 in ( Carrier R28 )) by L461 , XBOOLE_0:def 3;
L463: ( R28 . R13 ) = ( 0. R10 ) by L462;
L464: (( R27 /. R13 ) = ( R27 . R13 ) & ( R28 /. R13 ) = ( R28 . R13 )) by L456 , PARTFUN1:def 6;
L465: (not R13 in ( Carrier R27 )) by L461 , XBOOLE_0:def 3;
L466: ( R27 . R13 ) = ( 0. R10 ) by L465;
thus L467: ( D44 . R13 ) = ( D44 /. R13 ) by L456 , L457 , PARTFUN1:def 6
.= ( ( 0. R10 ) + ( 0. R10 ) ) by L456 , L457 , L463 , L464 , L466 , VFUNCT_1:def 1
.= ( 0. R10 ) by RLVECT_1:4;
end;
thus L468: thesis by L460 , L459 , L1;
end;
end;
theorem
L470: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( ( R27 + R28 ) . R13 ) = ( ( R27 . R13 ) + ( R28 . R13 ) ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
L471: (( dom R27 ) = (the carrier of R11) & ( dom R28 ) = (the carrier of R11)) by FUNCT_2:def 1;
L472: (( R27 /. R13 ) = ( R27 . R13 ) & ( R28 /. R13 ) = ( R28 . R13 )) by L471 , PARTFUN1:def 6;
L473: ( dom ( R27 + R28 ) ) = (the carrier of R11) by FUNCT_2:def 1;
thus L474: ( ( R27 + R28 ) . R13 ) = ( ( R27 + R28 ) /. R13 ) by L473 , PARTFUN1:def 6
.= ( ( R27 . R13 ) + ( R28 . R13 ) ) by L472 , L473 , VFUNCT_1:def 1;
end;
theorem
L475: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( Carrier ( R27 + R28 ) ) c= ( ( Carrier R27 ) \/ ( Carrier R28 ) )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
let R4 being set;
assume L476: R4 in ( Carrier ( R27 + R28 ) );
consider R12 being (Element of R11) such that L477: R4 = R12 and L478: ( ( R27 + R28 ) . R12 ) <> ( 0. R10 ) by L476;
L479: ( ( R27 + R28 ) . R12 ) = ( ( R27 . R12 ) + ( R28 . R12 ) ) by L470;
L480: (( R27 . R12 ) <> ( 0. R10 ) or ( R28 . R12 ) <> ( 0. R10 )) by L479 , L478 , RLVECT_1:4;
L481: (R4 in { R14 where R14 is (Element of R11) : ( R27 . R14 ) <> ( 0. R10 ) } or R4 in { R15 where R15 is (Element of R11) : ( R28 . R15 ) <> ( 0. R10 ) }) by L480 , L477;
thus L482: thesis by L481 , XBOOLE_0:def 3;
end;
theorem
L483: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R23 being (Subset of R11) holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ((R27 is (Linear_Combination of R23) & R28 is (Linear_Combination of R23)) implies ( R27 + R28 ) is (Linear_Combination of R23)))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R23 being (Subset of R11);
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
assume L484: (R27 is (Linear_Combination of R23) & R28 is (Linear_Combination of R23));
L485: (( Carrier R27 ) c= R23 & ( Carrier R28 ) c= R23) by L484 , L47;
L486: ( ( Carrier R27 ) \/ ( Carrier R28 ) ) c= R23 by L485 , XBOOLE_1:8;
L487: ( Carrier ( R27 + R28 ) ) c= ( ( Carrier R27 ) \/ ( Carrier R28 ) ) by L475;
thus L488: ( Carrier ( R27 + R28 ) ) c= R23 by L487 , L486 , XBOOLE_1:1;
end;
theorem
L489: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( R27 + R28 ) = ( R28 + R27 )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L490: ( ( R27 + R28 ) . R13 ) = ( ( R28 . R13 ) + ( R27 . R13 ) ) by L470
.= ( ( R28 + R27 ) . R13 ) by L470;
end;
theorem
L491: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds (for R29 being (Linear_Combination of R11) holds ( R27 + ( R28 + R29 ) ) = ( ( R27 + R28 ) + R29 ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
let R29 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L492: ( ( R27 + ( R28 + R29 ) ) . R13 ) = ( ( R27 . R13 ) + ( ( R28 + R29 ) . R13 ) ) by L470
.= ( ( R27 . R13 ) + ( ( R28 . R13 ) + ( R29 . R13 ) ) ) by L470
.= ( ( ( R27 . R13 ) + ( R28 . R13 ) ) + ( R29 . R13 ) ) by RLVECT_1:def 3
.= ( ( ( R27 + R28 ) . R13 ) + ( R29 . R13 ) ) by L470
.= ( ( ( R27 + R28 ) + R29 ) . R13 ) by L470;
end;
theorem
L493: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds (( R26 + ( ZeroLC R11 ) ) = R26 & ( ( ZeroLC R11 ) + R26 ) = R26))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
thus L494: ( R26 + ( ZeroLC R11 ) ) = R26
proof
let R13 being (Element of R11);
thus L495: ( ( R26 + ( ZeroLC R11 ) ) . R13 ) = ( ( R26 . R13 ) + ( ( ZeroLC R11 ) . R13 ) ) by L470
.= ( ( R26 . R13 ) + ( 0. R10 ) ) by L44
.= ( R26 . R13 ) by RLVECT_1:4;
end;

thus L496: thesis by L494 , L489;
end;
definition
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R18 being (Element of R10);
let R26 being (Linear_Combination of R11);
func R18 * R26 -> (Linear_Combination of R11) means 
:L497: (for R13 being (Element of R11) holds ( it . R13 ) = ( R18 * ( R26 . R13 ) ));
existence
proof
deffunc H5((Element of R11)) = ( R18 * ( R26 . $1 ) );
consider C42 being (Function of (the carrier of R11) , (the carrier of R10)) such that L498: (for B25 being (Element of R11) holds ( C42 . B25 ) = H5(B25)) from FUNCT_2:sch 4;
reconsider D45 = C42 as (Element of ( Funcs ((the carrier of R11) , (the carrier of R10)) )) by FUNCT_2:8;
L499:
now
let R13 being (Element of R11);
assume L500: (not R13 in ( Carrier R26 ));
L501: ( R26 . R13 ) = ( 0. R10 ) by L500;
thus L502: ( D45 . R13 ) = ( R18 * ( 0. R10 ) ) by L501 , L498
.= ( 0. R10 ) by VECTSP_1:6;
end;
reconsider D46 = D45 as (Linear_Combination of R11) by L499 , L1;
take D46;
let R13 being (Element of R11);
thus L503: thesis by L498;
end;
uniqueness
proof
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
assume L504: (for R13 being (Element of R11) holds ( R27 . R13 ) = ( R18 * ( R26 . R13 ) ));
assume L505: (for R13 being (Element of R11) holds ( R28 . R13 ) = ( R18 * ( R26 . R13 ) ));
let R13 being (Element of R11);
thus L506: ( R27 . R13 ) = ( R18 * ( R26 . R13 ) ) by L504
.= ( R28 . R13 ) by L505;
end;
end;
theorem
L508: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R18 being (Element of R10) holds (for R26 being (Linear_Combination of R11) holds ( Carrier ( R18 * R26 ) ) c= ( Carrier R26 )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R18 being (Element of R10);
let R26 being (Linear_Combination of R11);
set D47 = { R12 where R12 is (Element of R11) : ( ( R18 * R26 ) . R12 ) <> ( 0. R10 ) };
set D48 = { R13 where R13 is (Element of R11) : ( R26 . R13 ) <> ( 0. R10 ) };
L509: D47 c= D48
proof
let R4 being set;
assume L510: R4 in D47;
consider R12 being (Element of R11) such that L511: R4 = R12 and L512: ( ( R18 * R26 ) . R12 ) <> ( 0. R10 ) by L510;
L513: ( ( R18 * R26 ) . R12 ) = ( R18 * ( R26 . R12 ) ) by L497;
L514: ( R26 . R12 ) <> ( 0. R10 ) by L513 , L512 , VECTSP_1:6;
thus L515: thesis by L514 , L511;
end;
thus L516: thesis by L509;
end;
theorem
L517: (for B26 being Field holds (for B27 being (VectSp of B26) holds (for B28 being (Element of B26) holds (for B29 being (Linear_Combination of B27) holds (B28 <> ( 0. B26 ) implies ( Carrier ( B28 * B29 ) ) = ( Carrier B29 ))))))
proof
let C43 being Field;
let C44 being (VectSp of C43);
let C45 being (Element of C43);
let C46 being (Linear_Combination of C44);
set D49 = { B30 where B30 is (Vector of C44) : ( ( C45 * C46 ) . B30 ) <> ( 0. C43 ) };
set D50 = { B31 where B31 is (Vector of C44) : ( C46 . B31 ) <> ( 0. C43 ) };
assume L518: C45 <> ( 0. C43 );
L519: D49 = D50
proof
thus L520: D49 c= D50
proof
let R4 being set;
assume L521: R4 in D49;
consider C47 being (Vector of C44) such that L522: R4 = C47 and L523: ( ( C45 * C46 ) . C47 ) <> ( 0. C43 ) by L521;
L524: ( ( C45 * C46 ) . C47 ) = ( C45 * ( C46 . C47 ) ) by L497;
L525: ( C46 . C47 ) <> ( 0. C43 ) by L524 , L523 , VECTSP_1:7;
thus L526: thesis by L525 , L522;
end;

let R4 being set;
assume L527: R4 in D50;
consider C48 being (Vector of C44) such that L528: R4 = C48 and L529: ( C46 . C48 ) <> ( 0. C43 ) by L527;
L530: ( ( C45 * C46 ) . C48 ) = ( C45 * ( C46 . C48 ) ) by L497;
L531: ( ( C45 * C46 ) . C48 ) <> ( 0. C43 ) by L530 , L518 , L529 , VECTSP_1:12;
thus L532: thesis by L531 , L528;
end;
thus L533: thesis by L519;
end;
theorem
L534: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds ( ( 0. R10 ) * R26 ) = ( ZeroLC R11 ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L535: ( ( ( 0. R10 ) * R26 ) . R13 ) = ( ( 0. R10 ) * ( R26 . R13 ) ) by L497
.= ( 0. R10 ) by VECTSP_1:7
.= ( ( ZeroLC R11 ) . R13 ) by L44;
end;
theorem
L536: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R18 being (Element of R10) holds (for R23 being (Subset of R11) holds (for R26 being (Linear_Combination of R11) holds (R26 is (Linear_Combination of R23) implies ( R18 * R26 ) is (Linear_Combination of R23)))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R18 being (Element of R10);
let R23 being (Subset of R11);
let R26 being (Linear_Combination of R11);
assume L537: R26 is (Linear_Combination of R23);
L538: ( Carrier R26 ) c= R23 by L537 , L47;
L539: ( Carrier ( R18 * R26 ) ) c= ( Carrier R26 ) by L508;
L540: ( Carrier ( R18 * R26 ) ) c= R23 by L539 , L538 , XBOOLE_1:1;
thus L541: thesis by L540 , L47;
end;
theorem
L542: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R18 being (Element of R10) holds (for R19 being (Element of R10) holds (for R26 being (Linear_Combination of R11) holds ( ( R18 + R19 ) * R26 ) = ( ( R18 * R26 ) + ( R19 * R26 ) ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R18 being (Element of R10);
let R19 being (Element of R10);
let R26 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L543: ( ( ( R18 + R19 ) * R26 ) . R13 ) = ( ( R18 + R19 ) * ( R26 . R13 ) ) by L497
.= ( ( R18 * ( R26 . R13 ) ) + ( R19 * ( R26 . R13 ) ) ) by VECTSP_1:def 7
.= ( ( ( R18 * R26 ) . R13 ) + ( R19 * ( R26 . R13 ) ) ) by L497
.= ( ( ( R18 * R26 ) . R13 ) + ( ( R19 * R26 ) . R13 ) ) by L497
.= ( ( ( R18 * R26 ) + ( R19 * R26 ) ) . R13 ) by L470;
end;
theorem
L544: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R18 being (Element of R10) holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( R18 * ( R27 + R28 ) ) = ( ( R18 * R27 ) + ( R18 * R28 ) ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R18 being (Element of R10);
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L545: ( ( R18 * ( R27 + R28 ) ) . R13 ) = ( R18 * ( ( R27 + R28 ) . R13 ) ) by L497
.= ( R18 * ( ( R27 . R13 ) + ( R28 . R13 ) ) ) by L470
.= ( ( R18 * ( R27 . R13 ) ) + ( R18 * ( R28 . R13 ) ) ) by VECTSP_1:def 7
.= ( ( ( R18 * R27 ) . R13 ) + ( R18 * ( R28 . R13 ) ) ) by L497
.= ( ( ( R18 * R27 ) . R13 ) + ( ( R18 * R28 ) . R13 ) ) by L497
.= ( ( ( R18 * R27 ) + ( R18 * R28 ) ) . R13 ) by L470;
end;
theorem
L546: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R18 being (Element of R10) holds (for R19 being (Element of R10) holds (for R26 being (Linear_Combination of R11) holds ( R18 * ( R19 * R26 ) ) = ( ( R18 * R19 ) * R26 ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R18 being (Element of R10);
let R19 being (Element of R10);
let R26 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L547: ( ( R18 * ( R19 * R26 ) ) . R13 ) = ( R18 * ( ( R19 * R26 ) . R13 ) ) by L497
.= ( R18 * ( R19 * ( R26 . R13 ) ) ) by L497
.= ( ( R18 * R19 ) * ( R26 . R13 ) ) by GROUP_1:def 3
.= ( ( ( R18 * R19 ) * R26 ) . R13 ) by L497;
end;
theorem
L548: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds ( ( 1. R10 ) * R26 ) = R26)))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L549: ( ( ( 1. R10 ) * R26 ) . R13 ) = ( ( 1. R10 ) * ( R26 . R13 ) ) by L497
.= ( R26 . R13 ) by VECTSP_1:def 8;
end;
definition
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
func - R26 -> (Linear_Combination of R11) equals 
( ( - ( 1. R10 ) ) * R26 );
correctness;
involutiveness
proof
let C49 , C50 being (Linear_Combination of R11);
assume L550: C49 = ( ( - ( 1. R10 ) ) * C50 );
let R13 being (Element of R11);
thus L551: ( C50 . R13 ) = ( ( 1. R10 ) * ( C50 . R13 ) ) by VECTSP_1:def 8
.= ( ( ( 1. R10 ) * ( 1. R10 ) ) * ( C50 . R13 ) ) by VECTSP_1:def 8
.= ( ( ( - ( 1. R10 ) ) * ( - ( 1. R10 ) ) ) * ( C50 . R13 ) ) by VECTSP_1:10
.= ( ( ( ( - ( 1. R10 ) ) * ( - ( 1. R10 ) ) ) * C50 ) . R13 ) by L497
.= ( ( ( - ( 1. R10 ) ) * C49 ) . R13 ) by L550 , L546;
end;
end;
L553: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R18 being (Element of R10) holds ( ( - ( 1. R10 ) ) * R18 ) = ( - R18 )))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R18 being (Element of R10);
thus L554: ( ( - ( 1. R10 ) ) * R18 ) = ( ( ( 0. R10 ) - ( 1. R10 ) ) * R18 ) by RLVECT_1:14
.= ( ( ( 0. R10 ) * R18 ) - ( ( 1. R10 ) * R18 ) ) by VECTSP_1:13
.= ( ( 0. R10 ) - ( ( 1. R10 ) * R18 ) ) by VECTSP_1:7
.= ( - ( ( 1. R10 ) * R18 ) ) by RLVECT_1:14
.= ( - R18 ) by VECTSP_1:def 8;
end;
theorem
L555: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R26 being (Linear_Combination of R11) holds ( ( - R26 ) . R13 ) = ( - ( R26 . R13 ) )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R26 being (Linear_Combination of R11);
thus L556: ( ( - R26 ) . R13 ) = ( ( - ( 1. R10 ) ) * ( R26 . R13 ) ) by L497
.= ( - ( R26 . R13 ) ) by L553;
end;
theorem
L557: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds (( R27 + R28 ) = ( ZeroLC R11 ) implies R28 = ( - R27 ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
assume L558: ( R27 + R28 ) = ( ZeroLC R11 );
let R13 being (Element of R11);
L559: ( ( R27 . R13 ) + ( R28 . R13 ) ) = ( ( ZeroLC R11 ) . R13 ) by L558 , L470
.= ( 0. R10 ) by L44;
thus L560: ( R28 . R13 ) = ( - ( R27 . R13 ) ) by L559 , RLVECT_1:6
.= ( ( - R27 ) . R13 ) by L555;
end;
L561: (for B32 being Field holds ( - ( 1. B32 ) ) <> ( 0. B32 ))
proof
let C51 being Field;
assume L562: (not thesis);
L563: ( 1. C51 ) = ( - ( 0. C51 ) ) by L562 , RLVECT_1:17;
thus L564: thesis by L563 , RLVECT_1:12;
end;
theorem
L565: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds ( Carrier ( - R26 ) ) = ( Carrier R26 ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
L566: (( Carrier ( - R26 ) ) c= ( Carrier R26 ) & ( Carrier ( - ( - R26 ) ) ) c= ( Carrier ( - R26 ) )) by L508;
thus L567: thesis by L566 , XBOOLE_0:def 10;
end;
theorem
L568: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R23 being (Subset of R11) holds (for R26 being (Linear_Combination of R11) holds (R26 is (Linear_Combination of R23) implies ( - R26 ) is (Linear_Combination of R23)))))) by L536;
definition
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
func R27 - R28 -> (Linear_Combination of R11) equals 
( R27 + ( - R28 ) );
coherence;
end;
theorem
L570: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R13 being (Element of R11) holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( ( R27 - R28 ) . R13 ) = ( ( R27 . R13 ) - ( R28 . R13 ) ))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R13 being (Element of R11);
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
thus L571: ( ( R27 - R28 ) . R13 ) = ( ( R27 . R13 ) + ( ( - R28 ) . R13 ) ) by L470
.= ( ( R27 . R13 ) + ( - ( R28 . R13 ) ) ) by L555
.= ( ( R27 . R13 ) - ( R28 . R13 ) ) by RLVECT_1:def 11;
end;
theorem
L572: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( Carrier ( R27 - R28 ) ) c= ( ( Carrier R27 ) \/ ( Carrier R28 ) )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
L573: ( Carrier ( R27 - R28 ) ) c= ( ( Carrier R27 ) \/ ( Carrier ( - R28 ) ) ) by L475;
thus L574: thesis by L573 , L565;
end;
theorem
L575: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R23 being (Subset of R11) holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ((R27 is (Linear_Combination of R23) & R28 is (Linear_Combination of R23)) implies ( R27 - R28 ) is (Linear_Combination of R23)))))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R23 being (Subset of R11);
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
assume that
L576: R27 is (Linear_Combination of R23)
and
L577: R28 is (Linear_Combination of R23);
L578: ( - R28 ) is (Linear_Combination of R23) by L577 , L536;
thus L579: thesis by L578 , L576 , L483;
end;
theorem
L580: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds ( R26 - R26 ) = ( ZeroLC R11 ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
let R13 being (Element of R11);
thus L581: ( ( R26 - R26 ) . R13 ) = ( ( R26 . R13 ) - ( R26 . R13 ) ) by L570
.= ( 0. R10 ) by RLVECT_1:15
.= ( ( ZeroLC R11 ) . R13 ) by L44;
end;
theorem
L582: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( Sum ( R27 + R28 ) ) = ( ( Sum R27 ) + ( Sum R28 ) )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
set D51 = ( ( ( Carrier ( R27 + R28 ) ) \/ ( Carrier R27 ) ) \/ ( Carrier R28 ) );
set D52 = ( D51 \ ( Carrier R27 ) );
consider R1 being FinSequence such that L583: ( rng R1 ) = D52 and L584: R1 is  one-to-one by FINSEQ_4:58;
reconsider D53 = R1 as (FinSequence of (the carrier of R11)) by L583 , FINSEQ_1:def 4;
L585: D51 = ( ( Carrier R27 ) \/ ( ( Carrier ( R27 + R28 ) ) \/ ( Carrier R28 ) ) ) by XBOOLE_1:4;
set D54 = ( D51 \ ( Carrier ( R27 + R28 ) ) );
consider R3 being FinSequence such that L586: ( rng R3 ) = D54 and L587: R3 is  one-to-one by FINSEQ_4:58;
reconsider D55 = R3 as (FinSequence of (the carrier of R11)) by L586 , FINSEQ_1:def 4;
L588: D51 = ( ( Carrier ( R27 + R28 ) ) \/ ( ( Carrier R27 ) \/ ( Carrier R28 ) ) ) by XBOOLE_1:4;
set D56 = ( D51 \ ( Carrier R28 ) );
consider R2 being FinSequence such that L589: ( rng R2 ) = D56 and L590: R2 is  one-to-one by FINSEQ_4:58;
reconsider D57 = R2 as (FinSequence of (the carrier of R11)) by L589 , FINSEQ_1:def 4;
consider R20 being (FinSequence of R11) such that L591: R20 is  one-to-one and L592: ( rng R20 ) = ( Carrier ( R27 + R28 ) ) and L593: ( Sum ( ( R27 + R28 ) (#) R20 ) ) = ( Sum ( R27 + R28 ) ) by L145;
set D58 = ( R20 ^ D55 );
consider R21 being (FinSequence of R11) such that L594: R21 is  one-to-one and L595: ( rng R21 ) = ( Carrier R27 ) and L596: ( Sum ( R27 (#) R21 ) ) = ( Sum R27 ) by L145;
L597: ( rng D58 ) = ( ( rng R20 ) \/ ( rng D55 ) ) by FINSEQ_1:31;
L598: ( rng D58 ) = ( ( Carrier ( R27 + R28 ) ) \/ D51 ) by L597 , L592 , L586 , XBOOLE_1:39;
L599: ( rng D58 ) = D51 by L598 , L588 , XBOOLE_1:7 , XBOOLE_1:12;
set D59 = ( R21 ^ D53 );
L600: ( rng D59 ) = ( ( rng R21 ) \/ ( rng D53 ) ) by FINSEQ_1:31;
L601: ( rng D59 ) = ( ( Carrier R27 ) \/ D51 ) by L600 , L595 , L583 , XBOOLE_1:39;
L602: ( rng D59 ) = D51 by L601 , L585 , XBOOLE_1:7 , XBOOLE_1:12;
L603: ( rng R20 ) misses ( rng D55 )
proof
set D60 = the (Element of ( ( rng R20 ) /\ ( rng D55 ) ));
assume L604: (not thesis);
L605: ( ( rng R20 ) /\ ( rng D55 ) ) <> ( {} ) by L604 , XBOOLE_0:def 7;
L606: (D60 in ( Carrier ( R27 + R28 ) ) & D60 in D54) by L605 , L592 , L586 , XBOOLE_0:def 4;
thus L607: thesis by L606 , XBOOLE_0:def 5;
end;
L608: D58 is  one-to-one by L603 , L591 , L587 , FINSEQ_3:91;
L609: ( rng R21 ) misses ( rng D53 )
proof
set D61 = the (Element of ( ( rng R21 ) /\ ( rng D53 ) ));
assume L610: (not thesis);
L611: ( ( rng R21 ) /\ ( rng D53 ) ) <> ( {} ) by L610 , XBOOLE_0:def 7;
L612: (D61 in ( Carrier R27 ) & D61 in D52) by L611 , L595 , L583 , XBOOLE_0:def 4;
thus L613: thesis by L612 , XBOOLE_0:def 5;
end;
L614: D59 is  one-to-one by L609 , L594 , L584 , FINSEQ_3:91;
L615: ( len D59 ) = ( len D58 ) by L614 , L608 , L602 , L599 , FINSEQ_1:48;
deffunc H6(Nat) = ( D58 <- ( D59 . $1 ) );
consider C52 being FinSequence such that L616: ( len C52 ) = ( len D58 ) and L617: (for B33 being Nat holds (B33 in ( dom C52 ) implies ( C52 . B33 ) = H6(B33))) from FINSEQ_1:sch 2;
L618: ( dom C52 ) = ( Seg ( len D58 ) ) by L616 , FINSEQ_1:def 3;
L619:
now
let R4 being set;
assume L620: R4 in ( dom D59 );
reconsider D62 = R4 as (Element of ( NAT )) by L620 , FINSEQ_3:23;
L621: ( D59 . D62 ) in ( rng D58 ) by L602 , L599 , L620 , FUNCT_1:def 3;
L622: D58 just_once_values ( D59 . D62 ) by L621 , L608 , FINSEQ_4:8;
L623: D62 in ( Seg ( len D58 ) ) by L615 , L620 , FINSEQ_1:def 3;
L624: ( D58 . ( C52 . D62 ) ) = ( D58 . ( D58 <- ( D59 . D62 ) ) ) by L623 , L617 , L618
.= ( D59 . D62 ) by L622 , FINSEQ_4:def 3;
thus L625: ( D59 . R4 ) = ( D58 . ( C52 . R4 ) ) by L624;
end;
L626: ( rng C52 ) c= ( dom D58 )
proof
let R4 being set;
assume L627: R4 in ( rng C52 );
consider R5 being set such that L628: R5 in ( dom C52 ) and L629: ( C52 . R5 ) = R4 by L627 , FUNCT_1:def 3;
reconsider D63 = R5 as (Element of ( NAT )) by L628 , FINSEQ_3:23;
L630: D63 in ( dom D59 ) by L615 , L616 , L628 , FINSEQ_3:29;
L631: ( D59 . D63 ) in ( rng D58 ) by L630 , L602 , L599 , FUNCT_1:def 3;
L632: D58 just_once_values ( D59 . D63 ) by L631 , L608 , FINSEQ_4:8;
L633: ( C52 . D63 ) = ( D58 <- ( D59 . D63 ) ) by L617 , L628;
thus L634: thesis by L633 , L629 , L632 , FINSEQ_4:def 3;
end;
L635:
now
let R4 being set;
thus L636: (R4 in ( dom D59 ) implies (R4 in ( dom C52 ) & ( C52 . R4 ) in ( dom D58 )))
proof
assume L637: R4 in ( dom D59 );
L638: R4 in ( Seg ( len C52 ) ) by L637 , L615 , L616 , FINSEQ_1:def 3;
thus L639: R4 in ( dom C52 ) by L638 , FINSEQ_1:def 3;
L640: ( C52 . R4 ) in ( rng C52 ) by L639 , FUNCT_1:def 3;
thus L641: thesis by L640 , L626;
end;

assume that
L642: R4 in ( dom C52 )
and
L643: ( C52 . R4 ) in ( dom D58 );
L644: R4 in ( Seg ( len C52 ) ) by L642 , FINSEQ_1:def 3;
thus L645: R4 in ( dom D59 ) by L644 , L615 , L616 , FINSEQ_1:def 3;
end;
L646: D59 = ( D58 * C52 ) by L635 , L619 , FUNCT_1:10;
L647: ( dom D58 ) c= ( rng C52 )
proof
set D64 = ( ( D58 " ) * D59 );
let R4 being set;
assume L648: R4 in ( dom D58 );
L649: ( dom ( D58 " ) ) = ( rng D59 ) by L608 , L602 , L599 , FUNCT_1:33;
L650: ( rng D64 ) = ( rng ( D58 " ) ) by L649 , RELAT_1:28
.= ( dom D58 ) by L608 , FUNCT_1:33;
L651: D64 = ( ( ( D58 " ) * D58 ) * C52 ) by L646 , RELAT_1:36
.= ( ( id ( dom D58 ) ) * C52 ) by L608 , FUNCT_1:39
.= C52 by L626 , RELAT_1:53;
thus L652: thesis by L651 , L648 , L650;
end;
L653: ( dom D58 ) = ( rng C52 ) by L647 , L626 , XBOOLE_0:def 10;
L654: ( len D55 ) = ( len ( ( R27 + R28 ) (#) D55 ) ) by L64;
L655:
now
let R9 being (Element of ( NAT ));
assume L656: R9 in ( dom D55 );
L657: ( D55 /. R9 ) = ( D55 . R9 ) by L656 , PARTFUN1:def 6;
L658: ( D55 /. R9 ) in D54 by L657 , L586 , L656 , FUNCT_1:def 3;
L659: (not ( D55 /. R9 ) in ( Carrier ( R27 + R28 ) )) by L658 , XBOOLE_0:def 5;
L660: R9 in ( dom ( ( R27 + R28 ) (#) D55 ) ) by L654 , L656 , FINSEQ_3:29;
L661: ( ( ( R27 + R28 ) (#) D55 ) . R9 ) = ( ( ( R27 + R28 ) . ( D55 /. R9 ) ) * ( D55 /. R9 ) ) by L660 , L64;
thus L662: ( ( ( R27 + R28 ) (#) D55 ) . R9 ) = ( ( 0. R10 ) * ( D55 /. R9 ) ) by L661 , L659;
end;
L663: ( Sum ( ( R27 + R28 ) (#) D55 ) ) = ( ( 0. R10 ) * ( Sum D55 ) ) by L655 , L654 , RLVECT_2:67
.= ( 0. R11 ) by VECTSP_1:14;
L664: ( len D53 ) = ( len ( R27 (#) D53 ) ) by L64;
L665:
now
let R9 being (Element of ( NAT ));
assume L666: R9 in ( dom D53 );
L667: ( D53 /. R9 ) = ( D53 . R9 ) by L666 , PARTFUN1:def 6;
L668: ( D53 /. R9 ) in D52 by L667 , L583 , L666 , FUNCT_1:def 3;
L669: (not ( D53 /. R9 ) in ( Carrier R27 )) by L668 , XBOOLE_0:def 5;
L670: R9 in ( dom ( R27 (#) D53 ) ) by L664 , L666 , FINSEQ_3:29;
L671: ( ( R27 (#) D53 ) . R9 ) = ( ( R27 . ( D53 /. R9 ) ) * ( D53 /. R9 ) ) by L670 , L64;
thus L672: ( ( R27 (#) D53 ) . R9 ) = ( ( 0. R10 ) * ( D53 /. R9 ) ) by L671 , L669;
end;
L673: ( Sum ( R27 (#) D53 ) ) = ( ( 0. R10 ) * ( Sum D53 ) ) by L665 , L664 , RLVECT_2:67
.= ( 0. R11 ) by VECTSP_1:14;
L674: ( len D57 ) = ( len ( R28 (#) D57 ) ) by L64;
L675:
now
let R9 being (Element of ( NAT ));
assume L676: R9 in ( dom D57 );
L677: ( D57 /. R9 ) = ( D57 . R9 ) by L676 , PARTFUN1:def 6;
L678: ( D57 /. R9 ) in D56 by L677 , L589 , L676 , FUNCT_1:def 3;
L679: (not ( D57 /. R9 ) in ( Carrier R28 )) by L678 , XBOOLE_0:def 5;
L680: R9 in ( dom ( R28 (#) D57 ) ) by L674 , L676 , FINSEQ_3:29;
L681: ( ( R28 (#) D57 ) . R9 ) = ( ( R28 . ( D57 /. R9 ) ) * ( D57 /. R9 ) ) by L680 , L64;
thus L682: ( ( R28 (#) D57 ) . R9 ) = ( ( 0. R10 ) * ( D57 /. R9 ) ) by L681 , L679;
end;
L683: ( Sum ( R28 (#) D57 ) ) = ( ( 0. R10 ) * ( Sum D57 ) ) by L675 , L674 , RLVECT_2:67
.= ( 0. R11 ) by VECTSP_1:14;
set D65 = ( R27 (#) D59 );
L684: ( len D65 ) = ( len D59 ) by L64;
L685: ( Seg ( len D59 ) ) = ( dom D65 ) by L684 , FINSEQ_1:def 3;
set D66 = ( ( R27 + R28 ) (#) D58 );
consider R22 being (FinSequence of R11) such that L686: R22 is  one-to-one and L687: ( rng R22 ) = ( Carrier R28 ) and L688: ( Sum ( R28 (#) R22 ) ) = ( Sum R28 ) by L145;
set D67 = ( R22 ^ D57 );
L689: ( rng R22 ) misses ( rng D57 )
proof
set D68 = the (Element of ( ( rng R22 ) /\ ( rng D57 ) ));
assume L690: (not thesis);
L691: ( ( rng R22 ) /\ ( rng D57 ) ) <> ( {} ) by L690 , XBOOLE_0:def 7;
L692: (D68 in ( Carrier R28 ) & D68 in D56) by L691 , L687 , L589 , XBOOLE_0:def 4;
thus L693: thesis by L692 , XBOOLE_0:def 5;
end;
L694: D67 is  one-to-one by L689 , L686 , L590 , FINSEQ_3:91;
L695: ( rng D67 ) = ( ( rng R22 ) \/ ( rng D57 ) ) by FINSEQ_1:31;
L696: ( rng D67 ) = ( ( Carrier R28 ) \/ D51 ) by L695 , L687 , L589 , XBOOLE_1:39;
L697: ( rng D67 ) = D51 by L696 , XBOOLE_1:7 , XBOOLE_1:12;
L698: ( len D59 ) = ( len D67 ) by L697 , L694 , L614 , L602 , FINSEQ_1:48;
deffunc H7(Nat) = ( D67 <- ( D59 . $1 ) );
consider C53 being FinSequence such that L699: ( len C53 ) = ( len D67 ) and L700: (for B34 being Nat holds (B34 in ( dom C53 ) implies ( C53 . B34 ) = H7(B34))) from FINSEQ_1:sch 2;
L701: ( dom C53 ) = ( Seg ( len D67 ) ) by L699 , FINSEQ_1:def 3;
L702:
now
let R4 being set;
assume L703: R4 in ( dom D59 );
reconsider D69 = R4 as (Element of ( NAT )) by L703 , FINSEQ_3:23;
L704: ( D59 . D69 ) in ( rng D67 ) by L602 , L697 , L703 , FUNCT_1:def 3;
L705: D67 just_once_values ( D59 . D69 ) by L704 , L694 , FINSEQ_4:8;
L706: D69 in ( Seg ( len D67 ) ) by L698 , L703 , FINSEQ_1:def 3;
L707: ( D67 . ( C53 . D69 ) ) = ( D67 . ( D67 <- ( D59 . D69 ) ) ) by L706 , L700 , L701
.= ( D59 . D69 ) by L705 , FINSEQ_4:def 3;
thus L708: ( D59 . R4 ) = ( D67 . ( C53 . R4 ) ) by L707;
end;
L709: ( rng C53 ) c= ( dom D67 )
proof
let R4 being set;
assume L710: R4 in ( rng C53 );
consider R5 being set such that L711: R5 in ( dom C53 ) and L712: ( C53 . R5 ) = R4 by L710 , FUNCT_1:def 3;
reconsider D70 = R5 as (Element of ( NAT )) by L711 , FINSEQ_3:23;
L713: D70 in ( dom D59 ) by L698 , L699 , L711 , FINSEQ_3:29;
L714: ( D59 . D70 ) in ( rng D67 ) by L713 , L602 , L697 , FUNCT_1:def 3;
L715: D67 just_once_values ( D59 . D70 ) by L714 , L694 , FINSEQ_4:8;
L716: ( C53 . D70 ) = ( D67 <- ( D59 . D70 ) ) by L700 , L711;
thus L717: thesis by L716 , L712 , L715 , FINSEQ_4:def 3;
end;
L718:
now
let R4 being set;
thus L719: (R4 in ( dom D59 ) implies (R4 in ( dom C53 ) & ( C53 . R4 ) in ( dom D67 )))
proof
assume L720: R4 in ( dom D59 );
L721: R4 in ( Seg ( len C53 ) ) by L720 , L698 , L699 , FINSEQ_1:def 3;
thus L722: R4 in ( dom C53 ) by L721 , FINSEQ_1:def 3;
L723: ( C53 . R4 ) in ( rng C53 ) by L722 , FUNCT_1:def 3;
thus L724: thesis by L723 , L709;
end;

assume that
L725: R4 in ( dom C53 )
and
L726: ( C53 . R4 ) in ( dom D67 );
L727: R4 in ( Seg ( len C53 ) ) by L725 , FINSEQ_1:def 3;
thus L728: R4 in ( dom D59 ) by L727 , L698 , L699 , FINSEQ_1:def 3;
end;
L729: D59 = ( D67 * C53 ) by L718 , L702 , FUNCT_1:10;
L730: ( dom D67 ) c= ( rng C53 )
proof
set D71 = ( ( D67 " ) * D59 );
let R4 being set;
assume L731: R4 in ( dom D67 );
L732: ( dom ( D67 " ) ) = ( rng D59 ) by L694 , L602 , L697 , FUNCT_1:33;
L733: ( rng D71 ) = ( rng ( D67 " ) ) by L732 , RELAT_1:28
.= ( dom D67 ) by L694 , FUNCT_1:33;
L734: D71 = ( ( ( D67 " ) * D67 ) * C53 ) by L729 , RELAT_1:36
.= ( ( id ( dom D67 ) ) * C53 ) by L694 , FUNCT_1:39
.= C53 by L709 , RELAT_1:53;
thus L735: thesis by L734 , L731 , L733;
end;
L736: ( dom D67 ) = ( rng C53 ) by L730 , L709 , XBOOLE_0:def 10;
set D72 = ( R28 (#) D67 );
L737: ( Sum D72 ) = ( Sum ( ( R28 (#) R22 ) ^ ( R28 (#) D57 ) ) ) by L122
.= ( ( Sum ( R28 (#) R22 ) ) + ( 0. R11 ) ) by L683 , RLVECT_1:41
.= ( Sum ( R28 (#) R22 ) ) by RLVECT_1:4;
L738: ( Sum D65 ) = ( Sum ( ( R27 (#) R21 ) ^ ( R27 (#) D53 ) ) ) by L122
.= ( ( Sum ( R27 (#) R21 ) ) + ( 0. R11 ) ) by L673 , RLVECT_1:41
.= ( Sum ( R27 (#) R21 ) ) by RLVECT_1:4;
L739: ( dom C52 ) = ( dom D58 ) by L616 , FINSEQ_3:29;
L740: C52 is  one-to-one by L739 , L653 , FINSEQ_4:60;
L741: ( dom C53 ) = ( dom D67 ) by L699 , FINSEQ_3:29;
L742: C53 is  one-to-one by L741 , L736 , FINSEQ_4:60;
reconsider D73 = C53 as (Function of ( dom D67 ) , ( dom D67 )) by L709 , L741 , FUNCT_2:2;
reconsider D74 = D73 as (Permutation of ( dom D67 )) by L736 , L742 , FUNCT_2:57;
L743: ( len D72 ) = ( len D67 ) by L64;
L744: ( dom D72 ) = ( dom D67 ) by L743 , FINSEQ_3:29;
reconsider D75 = D74 as (Permutation of ( dom D72 )) by L744;
reconsider D76 = ( D72 * D75 ) as (FinSequence of (the carrier of R11)) by FINSEQ_2:47;
L745: ( len D76 ) = ( len D59 ) by L698 , L743 , FINSEQ_2:44;
reconsider D77 = C52 as (Function of ( dom D58 ) , ( dom D58 )) by L626 , L739 , FUNCT_2:2;
reconsider D78 = D77 as (Permutation of ( dom D58 )) by L653 , L740 , FUNCT_2:57;
L746: ( len D66 ) = ( len D58 ) by L64;
L747: ( dom D66 ) = ( dom D58 ) by L746 , FINSEQ_3:29;
reconsider D79 = D78 as (Permutation of ( dom D66 )) by L747;
reconsider D80 = ( D66 * D79 ) as (FinSequence of (the carrier of R11)) by FINSEQ_2:47;
L748: ( Sum D66 ) = ( Sum ( ( ( R27 + R28 ) (#) R20 ) ^ ( ( R27 + R28 ) (#) D55 ) ) ) by L122
.= ( ( Sum ( ( R27 + R28 ) (#) R20 ) ) + ( 0. R11 ) ) by L663 , RLVECT_1:41
.= ( Sum ( ( R27 + R28 ) (#) R20 ) ) by RLVECT_1:4;
deffunc H8(Nat) = ( ( D65 /. $1 ) + ( D76 /. $1 ) );
consider C54 being FinSequence such that L749: ( len C54 ) = ( len D59 ) and L750: (for B35 being Nat holds (B35 in ( dom C54 ) implies ( C54 . B35 ) = H8(B35))) from FINSEQ_1:sch 2;
L751: ( dom C54 ) = ( Seg ( len D59 ) ) by L749 , FINSEQ_1:def 3;
L752: (for B36 being (Element of ( NAT )) holds (B36 in ( Seg ( len D59 ) ) implies ( C54 . B36 ) = H8(B36))) by L751 , L750;
L753: ( rng C54 ) c= (the carrier of R11)
proof
let R4 being set;
assume L754: R4 in ( rng C54 );
consider R5 being set such that L755: R5 in ( dom C54 ) and L756: ( C54 . R5 ) = R4 by L754 , FUNCT_1:def 3;
reconsider D81 = R5 as (Element of ( NAT )) by L755 , FINSEQ_3:23;
L757: ( C54 . D81 ) = ( ( D65 /. D81 ) + ( D76 /. D81 ) ) by L750 , L755;
thus L758: thesis by L757 , L756;
end;
reconsider D82 = C54 as (FinSequence of (the carrier of R11)) by L753 , FINSEQ_1:def 4;
L759: ( len D80 ) = ( len D82 ) by L615 , L746 , L749 , FINSEQ_2:44;
L760:
now
let R4 being set;
assume L761: R4 in ( Seg ( len D82 ) );
reconsider D83 = R4 as (Element of ( NAT )) by L761;
L762: R4 in ( dom D76 ) by L749 , L745 , L761 , FINSEQ_1:def 3;
L763: ( D76 /. D83 ) = ( ( D72 * D75 ) . D83 ) by L762 , PARTFUN1:def 6
.= ( D72 . ( D75 . D83 ) ) by L762 , FUNCT_1:12;
set D84 = ( D59 /. D83 );
L764: R4 in ( dom D80 ) by L759 , L761 , FINSEQ_1:def 3;
L765: ( D80 . D83 ) = ( D66 . ( D79 . D83 ) ) by L764 , FUNCT_1:12;
L766: R4 in ( dom D67 ) by L698 , L749 , L761 , FINSEQ_1:def 3;
L767: ( D75 . D83 ) in ( dom D75 ) by L766 , L736 , L741 , FUNCT_1:def 3;
reconsider D85 = ( D75 . D83 ) as (Element of ( NAT )) by L767 , FINSEQ_3:23;
L768: R4 in ( dom D59 ) by L749 , L761 , FINSEQ_1:def 3;
L769: ( D67 . D85 ) = ( D59 . D83 ) by L768 , L702
.= ( D59 /. D83 ) by L768 , PARTFUN1:def 6;
L770: ( dom D58 ) = ( dom D59 ) by L615 , FINSEQ_3:29;
L771: ( D79 . D83 ) in ( dom D79 ) by L770 , L653 , L739 , L768 , FUNCT_1:def 3;
reconsider D86 = ( D79 . D83 ) as (Element of ( NAT )) by L771 , FINSEQ_3:23;
L772: ( D58 . D86 ) = ( D59 . D83 ) by L619 , L768
.= ( D59 /. D83 ) by L768 , PARTFUN1:def 6;
L773: ( D75 . D83 ) in ( dom D67 ) by L736 , L741 , L766 , FUNCT_1:def 3;
L774: ( D72 . D85 ) = ( ( R28 . D84 ) * D84 ) by L773 , L769 , L88;
L775: ( D79 . D83 ) in ( dom D58 ) by L653 , L739 , L768 , L770 , FUNCT_1:def 3;
L776: ( D66 . D86 ) = ( ( ( R27 + R28 ) . D84 ) * D84 ) by L775 , L772 , L88
.= ( ( ( R27 . D84 ) + ( R28 . D84 ) ) * D84 ) by L470
.= ( ( ( R27 . D84 ) * D84 ) + ( ( R28 . D84 ) * D84 ) ) by VECTSP_1:def 15;
L777: R4 in ( dom D65 ) by L749 , L684 , L761 , FINSEQ_1:def 3;
L778: ( D65 /. D83 ) = ( D65 . D83 ) by L777 , PARTFUN1:def 6
.= ( ( R27 . D84 ) * D84 ) by L777 , L64;
thus L779: ( D82 . R4 ) = ( D80 . R4 ) by L778 , L749 , L750 , L751 , L761 , L763 , L774 , L765 , L776;
end;
L780: (( dom D82 ) = ( Seg ( len D82 ) ) & ( dom D80 ) = ( Seg ( len D82 ) )) by L759 , FINSEQ_1:def 3;
L781: D82 = D80 by L780 , L760 , FUNCT_1:2;
L782: (( Sum D80 ) = ( Sum D66 ) & ( Sum D76 ) = ( Sum D72 )) by RLVECT_2:7;
thus L783: thesis by L782 , L593 , L596 , L688 , L738 , L737 , L748 , L749 , L752 , L745 , L684 , L781 , L685 , RLVECT_2:2;
end;
theorem
L784: (for B37 being Field holds (for B38 being (VectSp of B37) holds (for B39 being (Linear_Combination of B38) holds (for B40 being (Element of B37) holds ( Sum ( B40 * B39 ) ) = ( B40 * ( Sum B39 ) )))))
proof
let C55 being Field;
let C56 being (VectSp of C55);
let C57 being (Linear_Combination of C56);
let C58 being (Element of C55);
per cases ;
suppose L785: C58 <> ( 0. C55 );

set D87 = ( C58 * C57 );
consider C59 being (FinSequence of (the carrier of C56)) such that L786: C59 is  one-to-one and L787: ( rng C59 ) = ( Carrier ( C58 * C57 ) ) and L788: ( Sum ( C58 * C57 ) ) = ( Sum ( ( C58 * C57 ) (#) C59 ) ) by L145;
consider C60 being (FinSequence of (the carrier of C56)) such that L789: C60 is  one-to-one and L790: ( rng C60 ) = ( Carrier C57 ) and L791: ( Sum C57 ) = ( Sum ( C57 (#) C60 ) ) by L145;
L792: ( len C60 ) = ( len C59 ) by L785 , L786 , L787 , L789 , L790 , L517 , FINSEQ_1:48;
set D88 = ( ( C58 * C57 ) (#) C59 );
set D89 = ( C57 (#) C60 );
deffunc H9(Nat) = ( C59 <- ( C60 . $1 ) );
consider C61 being FinSequence such that L793: ( len C61 ) = ( len C59 ) and L794: (for B41 being Nat holds (B41 in ( dom C61 ) implies ( C61 . B41 ) = H9(B41))) from FINSEQ_1:sch 2;
L795: ( Carrier D87 ) = ( Carrier C57 ) by L785 , L517;
L796: ( rng C61 ) c= ( Seg ( len C59 ) )
proof
let R4 being set;
assume L797: R4 in ( rng C61 );
consider R5 being set such that L798: R5 in ( dom C61 ) and L799: ( C61 . R5 ) = R4 by L797 , FUNCT_1:def 3;
reconsider D90 = R5 as (Element of ( NAT )) by L798 , FINSEQ_3:23;
L800: D90 in ( Seg ( len C59 ) ) by L793 , L798 , FINSEQ_1:def 3;
L801: D90 in ( dom C60 ) by L800 , L792 , FINSEQ_1:def 3;
L802: ( C60 . D90 ) in ( rng C59 ) by L801 , L787 , L790 , L795 , FUNCT_1:def 3;
L803: C59 just_once_values ( C60 . D90 ) by L802 , L786 , FINSEQ_4:8;
L804: ( C61 . D90 ) = ( C59 <- ( C60 . D90 ) ) by L794 , L798;
L805: ( C61 . D90 ) in ( dom C59 ) by L804 , L803 , FINSEQ_4:def 3;
thus L806: thesis by L805 , L799 , FINSEQ_1:def 3;
end;
L807:
now
let R4 being set;
thus L808: (R4 in ( dom C60 ) implies (R4 in ( dom C61 ) & ( C61 . R4 ) in ( dom C59 )))
proof
assume L809: R4 in ( dom C60 );
L810: R4 in ( Seg ( len C61 ) ) by L809 , L793 , L792 , FINSEQ_1:def 3;
thus L811: R4 in ( dom C61 ) by L810 , FINSEQ_1:def 3;
L812: ( C61 . R4 ) in ( rng C61 ) by L811 , FUNCT_1:def 3;
L813: ( C61 . R4 ) in ( Seg ( len C59 ) ) by L812 , L796;
thus L814: thesis by L813 , FINSEQ_1:def 3;
end;

assume that
L815: R4 in ( dom C61 )
and
L816: ( C61 . R4 ) in ( dom C59 );
L817: R4 in ( Seg ( len C61 ) ) by L815 , FINSEQ_1:def 3;
thus L818: R4 in ( dom C60 ) by L817 , L793 , L792 , FINSEQ_1:def 3;
end;
L819: ( dom C61 ) = ( Seg ( len C59 ) ) by L793 , FINSEQ_1:def 3;
L820:
now
let R4 being set;
assume L821: R4 in ( dom C60 );
reconsider D91 = R4 as (Element of ( NAT )) by L821 , FINSEQ_3:23;
L822: ( C60 . D91 ) in ( rng C59 ) by L787 , L790 , L795 , L821 , FUNCT_1:def 3;
L823: C59 just_once_values ( C60 . D91 ) by L822 , L786 , FINSEQ_4:8;
L824: D91 in ( Seg ( len C59 ) ) by L792 , L821 , FINSEQ_1:def 3;
L825: ( C59 . ( C61 . D91 ) ) = ( C59 . ( C59 <- ( C60 . D91 ) ) ) by L824 , L794 , L819
.= ( C60 . D91 ) by L823 , FINSEQ_4:def 3;
thus L826: ( C60 . R4 ) = ( C59 . ( C61 . R4 ) ) by L825;
end;
L827: C60 = ( C59 * C61 ) by L820 , L807 , FUNCT_1:10;
L828: ( Seg ( len C59 ) ) c= ( rng C61 )
proof
set D92 = ( ( C59 " ) * C60 );
let R4 being set;
assume L829: R4 in ( Seg ( len C59 ) );
L830: ( dom ( C59 " ) ) = ( rng C60 ) by L786 , L787 , L790 , L795 , FUNCT_1:33;
L831: ( rng D92 ) = ( rng ( C59 " ) ) by L830 , RELAT_1:28
.= ( dom C59 ) by L786 , FUNCT_1:33;
L832: ( rng C61 ) c= ( dom C59 ) by L796 , FINSEQ_1:def 3;
L833: D92 = ( ( ( C59 " ) * C59 ) * C61 ) by L827 , RELAT_1:36
.= ( ( id ( dom C59 ) ) * C61 ) by L786 , FUNCT_1:39
.= C61 by L832 , RELAT_1:53;
thus L834: thesis by L833 , L829 , L831 , FINSEQ_1:def 3;
end;
L835: ( Seg ( len C59 ) ) = ( rng C61 ) by L828 , L796 , XBOOLE_0:def 10;
L836: ( dom C61 ) = ( Seg ( len C59 ) ) by L793 , FINSEQ_1:def 3;
L837: C61 is  one-to-one by L836 , L835 , FINSEQ_4:60;
reconsider D93 = C61 as (Function of ( Seg ( len C59 ) ) , ( Seg ( len C59 ) )) by L796 , L836 , FUNCT_2:2;
reconsider D94 = D93 as (Permutation of ( Seg ( len C59 ) )) by L835 , L837 , FUNCT_2:57;
L838: ( len D88 ) = ( len C59 ) by L64;
L839: ( dom D88 ) = ( Seg ( len C59 ) ) by L838 , FINSEQ_1:def 3;
reconsider D95 = D94 as (Permutation of ( dom D88 )) by L839;
reconsider D96 = ( D88 * D95 ) as (FinSequence of (the carrier of C56)) by FINSEQ_2:47;
L840: ( len D96 ) = ( len D88 ) by FINSEQ_2:44;
L841: ( len D96 ) = ( len D89 ) by L840 , L792 , L838 , L64;
L842:
now
let R9 being (Element of ( NAT ));
let C62 being (Vector of C56);
assume that
L843: R9 in ( dom D89 )
and
L844: C62 = ( D89 . R9 );
L845: R9 in ( Seg ( len D89 ) ) by L843 , FINSEQ_1:def 3;
L846: R9 in ( dom D95 ) by L845 , L793 , L838 , L840 , L841 , FINSEQ_1:def 3;
L847: R9 in ( dom C60 ) by L792 , L838 , L840 , L841 , L845 , FINSEQ_1:def 3;
L848: ( C60 . R9 ) in ( rng C60 ) by L847 , FUNCT_1:def 3;
L849: C59 just_once_values ( C60 . R9 ) by L848 , L786 , L787 , L790 , L795 , FINSEQ_4:8;
L850: ( C59 <- ( C60 . R9 ) ) in ( dom C59 ) by L849 , FINSEQ_4:def 3;
reconsider D97 = ( C59 <- ( C60 . R9 ) ) as (Element of ( NAT )) by L850 , FINSEQ_3:23;
L851: ( C60 /. R9 ) = ( C60 . R9 ) by L847 , PARTFUN1:def 6
.= ( C59 . ( D95 . R9 ) ) by L827 , L846 , FUNCT_1:13
.= ( C59 . D97 ) by L794 , L819 , L838 , L840 , L841 , L845
.= ( C59 /. D97 ) by L850 , PARTFUN1:def 6;
L852: D97 in ( Seg ( len D88 ) ) by L838 , L850 , FINSEQ_1:def 3;
L853: D97 in ( dom D88 ) by L852 , FINSEQ_1:def 3;
thus L854: ( D96 . R9 ) = ( D88 . ( D95 . R9 ) ) by L846 , FUNCT_1:13
.= ( D88 . ( C59 <- ( C60 . R9 ) ) ) by L794 , L819 , L838 , L840 , L841 , L845
.= ( ( D87 . ( C59 /. D97 ) ) * ( C59 /. D97 ) ) by L853 , L64
.= ( ( C58 * ( C57 . ( C59 /. D97 ) ) ) * ( C59 /. D97 ) ) by L497
.= ( C58 * ( ( C57 . ( C59 /. D97 ) ) * ( C59 /. D97 ) ) ) by VECTSP_1:def 16
.= ( C58 * C62 ) by L843 , L844 , L851 , L64;
end;
L855: (( Sum D96 ) = ( Sum D88 ) & ( dom D96 ) = ( dom D89 )) by L841 , FINSEQ_3:29 , RLVECT_2:7;
thus L856: thesis by L855 , L788 , L791 , L841 , L842 , RLVECT_2:66;
end;
suppose L857: C58 = ( 0. C55 );

thus L858: ( Sum ( C58 * C57 ) ) = ( Sum ( ZeroLC C56 ) ) by L857 , L534
.= ( 0. C56 ) by L213
.= ( C58 * ( Sum C57 ) ) by L857 , VECTSP_1:14;
end;
end;
theorem
L860: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R26 being (Linear_Combination of R11) holds ( Sum ( - R26 ) ) = ( - ( Sum R26 ) ))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R26 being (Linear_Combination of R11);
L861: ( ( Sum R26 ) + ( Sum ( - R26 ) ) ) = ( Sum ( R26 - R26 ) ) by L582
.= ( Sum ( ZeroLC R11 ) ) by L580
.= ( 0. R11 ) by L213;
thus L862: thesis by L861 , VECTSP_1:16;
end;
theorem
L863: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10 holds (for R27 being (Linear_Combination of R11) holds (for R28 being (Linear_Combination of R11) holds ( Sum ( R27 - R28 ) ) = ( ( Sum R27 ) - ( Sum R28 ) )))))
proof
let R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr;
let R11 being  Abelian  add-associative  right_zeroed  right_complementable  vector-distributive  scalar-distributive  scalar-associative  scalar-unital non  empty VectSpStr over R10;
let R27 being (Linear_Combination of R11);
let R28 being (Linear_Combination of R11);
thus L864: ( Sum ( R27 - R28 ) ) = ( ( Sum R27 ) + ( Sum ( - R28 ) ) ) by L582
.= ( ( Sum R27 ) + ( - ( Sum R28 ) ) ) by L860
.= ( ( Sum R27 ) - ( Sum R28 ) ) by RLVECT_1:def 11;
end;
theorem
L865: (for R10 being  add-associative  right_zeroed  right_complementable  Abelian  associative  well-unital  distributive non  empty doubleLoopStr holds (for R18 being (Element of R10) holds ( ( - ( 1. R10 ) ) * R18 ) = ( - R18 ))) by L553;
theorem
L866: (for B42 being Field holds ( - ( 1. B42 ) ) <> ( 0. B42 )) by L561;
