:: Combining of Multi Cell Circuits
::  by Grzegorz Bancerek , Shin'nosuke Yamaguchi and Yasunari Shidama
::
:: Received March 22, 2002
:: Copyright (c) 2002-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NAT_1, FUNCT_1, FINSEQ_2, MARGREL1, CIRCCOMB, LATTICES, FINSET_1,
      XBOOLE_0, MSUALG_1, FSM_1, CIRCUIT1, RELAT_1, CIRCUIT2, STRUCT_0,
      MSAFREE2, GLIB_000, ARYTM_3, CARD_1, XXREAL_0, PBOOLE, NUMBERS, MCART_1,
      FUNCT_4, PARTFUN1, FACIRC_1, TARSKI;
 notations TARSKI, XBOOLE_0, NUMBERS, XCMPLX_0, XXREAL_0, ORDINAL1, NAT_1,
      XTUPLE_0, MCART_1, FINSET_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FINSEQ_2, FUNCT_4, PBOOLE, MARGREL1, STRUCT_0, MSUALG_1, MSAFREE2,
      CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1;
 constructors LIMFUNC1, CIRCUIT1, CIRCUIT2, FACIRC_1, NAT_1, RELSET_1,
      XTUPLE_0;
 registrations RELAT_1, FUNCT_1, ORDINAL1, XREAL_0, CARD_3, STRUCT_0, CIRCCOMB,
      FACIRC_1, NAT_1, MARGREL1, XTUPLE_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions CIRCUIT2, MSAFREE2, XTUPLE_0;
 theorems TARSKI, FUNCT_1, RELAT_1, ZFMISC_1, NAT_1, MCART_1, PBOOLE, CIRCCOMB,
      FACIRC_1, FUNCT_4, FRECHET, CIRCUIT1, CIRCUIT2, XBOOLE_0, XBOOLE_1,
      XXREAL_0, ORDINAL1;
 schemes NAT_1, PBOOLE;

begin
registration
let C1 being Nat;
let C2 being (Function of ( C1 -tuples_on ( BOOLEAN ) ) , ( BOOLEAN ));
let C3 being (FinSeqLen of C1);
cluster ( 1GateCircuit (C3 , C2) ) ->  Boolean;
coherence by CIRCCOMB:61;
end;
theorem
L2: (for B1 being  finite non  empty set holds (for B2 being Nat holds (for B3 being (FinSeqLen of B2) holds (for B4 being (Function of ( B2 -tuples_on B1 ) , B1) holds (for B5 being (OperSymbol of ( 1GateCircStr (B3 , B4) )) holds (for B6 being (State of ( 1GateCircuit (B3 , B4) )) holds ( B5 depends_on_in B6 ) = ( B6 * B3 )))))))
proof
let C4 being  finite non  empty set;
let C5 being Nat;
let C6 being (FinSeqLen of C5);
let C7 being (Function of ( C5 -tuples_on C4 ) , C4);
let C8 being (OperSymbol of ( 1GateCircStr (C6 , C7) ));
let C9 being (State of ( 1GateCircuit (C6 , C7) ));
L3: ( C8 depends_on_in C9 ) = ( C9 * ( the_arity_of C8 ) ) by CIRCUIT1:def 3
.= ( C9 * C6 ) by CIRCCOMB:41;
thus L4: thesis by L3;
end;
theorem
L5: (for B7 being  finite non  empty set holds (for B8 being Nat holds (for B9 being (FinSeqLen of B8) holds (for B10 being (Function of ( B8 -tuples_on B7 ) , B7) holds (for B11 being (State of ( 1GateCircuit (B9 , B10) )) holds ( Following B11 ) is  stable)))))
proof
let C10 being  finite non  empty set;
let C11 being Nat;
let C12 being (FinSeqLen of C11);
let C13 being (Function of ( C11 -tuples_on C10 ) , C10);
set D1 = ( 1GateCircStr (C12 , C13) );
let C14 being (State of ( 1GateCircuit (C12 , C13) ));
set D2 = ( Following C14 );
set D3 = ( Following D2 );
L6: ( dom D2 ) = (the carrier of D1) by CIRCUIT1:3;
L7: (the carrier of D1) = ( ( rng C12 ) \/ { [ C12 , C13 ] } ) by CIRCCOMB:def 6;
L8: ( InputVertices D1 ) = ( rng C12 ) by CIRCCOMB:42;
L9: ( InnerVertices D1 ) = { [ C12 , C13 ] } by CIRCCOMB:42;
L10:
now
let C15 being set;
assume L11: C15 in (the carrier of D1);
reconsider D4 = C15 as (Vertex of D1) by L11;
L12: ( dom C14 ) = (the carrier of D1) by CIRCUIT1:3;
L13: ( dom ( C14 * C12 ) ) = ( dom C12 ) by L12 , L7 , RELAT_1:27 , XBOOLE_1:7;
L14: ( dom ( D2 * C12 ) ) = ( dom C12 ) by L6 , L7 , RELAT_1:27 , XBOOLE_1:7;
L15:
now
let C16 being set;
assume L16: C16 in ( dom C12 );
L17: ( C12 . C16 ) in ( rng C12 ) by L16 , FUNCT_1:3;
L18: (( ( D2 * C12 ) . C16 ) = ( D2 . ( C12 . C16 ) ) & ( ( C14 * C12 ) . C16 ) = ( C14 . ( C12 . C16 ) )) by L14 , L13 , L16 , FUNCT_1:12;
thus L19: ( ( D2 * C12 ) . C16 ) = ( ( C14 * C12 ) . C16 ) by L18 , L8 , L17 , CIRCUIT2:def 5;
end;
L20: (D4 in ( rng C12 ) or D4 in { [ C12 , C13 ] }) by L7 , XBOOLE_0:def 3;
L21: (( D3 . D4 ) = ( D2 . D4 ) or (D4 = [ C12 , C13 ] & (D4 = [ C12 , C13 ] implies ( action_at D4 ) = D4) & ( D3 . D4 ) = ( ( Den (( action_at D4 ) , ( 1GateCircuit (C12 , C13) )) ) . ( ( action_at D4 ) depends_on_in D2 ) ) & ( D2 . D4 ) = ( ( Den (( action_at D4 ) , ( 1GateCircuit (C12 , C13) )) ) . ( ( action_at D4 ) depends_on_in C14 ) ) & (( action_at D4 ) = [ C12 , C13 ] implies (( ( action_at D4 ) depends_on_in C14 ) = ( C14 * C12 ) & ( ( action_at D4 ) depends_on_in D2 ) = ( D2 * C12 ))))) by L20 , L8 , L9 , L2 , CIRCCOMB:41 , CIRCUIT2:def 5 , TARSKI:def 1;
thus L22: ( D3 . C15 ) = ( D2 . C15 ) by L21 , L14 , L13 , L15 , FUNCT_1:2;
end;
L23: ( dom D3 ) = (the carrier of D1) by CIRCUIT1:3;
thus L24: ( Following C14 ) = ( Following ( Following C14 ) ) by L23 , L6 , L10 , FUNCT_1:2;
end;
theorem
L25: (for B12 being non  void  Circuit-like non  empty ManySortedSign holds (for B13 being  non-empty (Circuit of B12) holds (for B14 being (State of B13) holds (B14 is  stable implies (for B15 being Nat holds ( Following (B14 , B15) ) = B14)))))
proof
let C17 being non  void  Circuit-like non  empty ManySortedSign;
let C18 being  non-empty (Circuit of C17);
let C19 being (State of C18);
assume that
L26: C19 is  stable;
defpred S1[ Nat ] means ( Following (C19 , $1) ) = C19;
L27:
now
let C20 being Nat;
assume L28: S1[ C20 ];
L29: ( Following ( Following (C19 , C20) ) ) = C19 by L28 , L26 , CIRCUIT2:def 6;
thus L30: S1[ ( C20 + 1 ) ] by L29 , FACIRC_1:12;
end;
L31: S1[ ( 0 ) ] by FACIRC_1:11;
thus L32: (for B16 being Nat holds S1[ B16 ]) from NAT_1:sch 2(L31 , L27);
end;
theorem
L33: (for B17 being non  void  Circuit-like non  empty ManySortedSign holds (for B18 being  non-empty (Circuit of B17) holds (for B19 being (State of B18) holds (for B20 , B21 being Nat holds ((( Following (B19 , B20) ) is  stable & B20 <= B21) implies ( Following (B19 , B21) ) = ( Following (B19 , B20) ))))))
proof
let C21 being non  void  Circuit-like non  empty ManySortedSign;
let C22 being  non-empty (Circuit of C21);
let C23 being (State of C22);
let C24 , C25 being Nat;
assume that
L34: ( Following (C23 , C24) ) is  stable
and
L35: C24 <= C25;
consider C26 being Nat such that L36: C25 = ( C24 + C26 ) by L35 , NAT_1:10;
reconsider D5 = C26 as Nat;
L37: ( Following (C23 , C25) ) = ( Following (( Following (C23 , C24) ) , D5) ) by L36 , FACIRC_1:13;
thus L38: thesis by L37 , L34 , L25;
end;
begin
scheme CIRCCMB29sch1 { F1() -> non  empty ManySortedSign , F2() -> set , F3(set , set , set) -> non  empty ManySortedSign , F4(set , set) -> set } : (ex B22 , B23 being (ManySortedSet of ( NAT )) st (( B22 . ( 0 ) ) = F1() & ( B23 . ( 0 ) ) = F2() & (for B24 being Nat holds (for B25 being non  empty ManySortedSign holds (for B26 being set holds ((B25 = ( B22 . B24 ) & B26 = ( B23 . B24 )) implies (( B22 . ( B24 + 1 ) ) = F3(B25 , B26 , B24) & ( B23 . ( B24 + 1 ) ) = F4(B26 , B24))))))))
proof
deffunc H1(set , set) = [ F3(( $2 `1 ) , ( $2 `2 ) , $1) , F4(( $2 `2 ) , $1) ];
consider C27 being Function such that L39: (( dom C27 ) = ( NAT ) & ( C27 . ( 0 ) ) = [ F1() , F2() ]) and L40: (for B27 being Nat holds ( C27 . ( B27 + 1 ) ) = H1(B27 , ( C27 . B27 ))) from NAT_1:sch 11;
deffunc H2(set) = ( ( C27 . $1 ) `2 );
deffunc H3(set) = ( ( C27 . $1 ) `1 );
consider C28 being (ManySortedSet of ( NAT )) such that L41: (for B28 being set holds (B28 in ( NAT ) implies ( C28 . B28 ) = H3(B28))) from PBOOLE:sch 4;
consider C29 being (ManySortedSet of ( NAT )) such that L42: (for B29 being set holds (B29 in ( NAT ) implies ( C29 . B29 ) = H2(B29))) from PBOOLE:sch 4;
take C28;
take C29;
L43: (( ( C27 . ( 0 ) ) `1 ) = F1() & ( ( C27 . ( 0 ) ) `2 ) = F2()) by L39 , MCART_1:7;
thus L44: (( C28 . ( 0 ) ) = F1() & ( C29 . ( 0 ) ) = F2()) by L43 , L41 , L42;
let C30 being Nat;
let C31 being non  empty ManySortedSign;
let C32 being set;
set D6 = ( C27 . C30 );
L45: C30 in ( NAT ) by ORDINAL1:def 12;
L46: ( C29 . C30 ) = ( D6 `2 ) by L45 , L42;
assume L47: C31 = ( C28 . C30 );
L48: C31 = ( D6 `1 ) by L47 , L41 , L45;
L49: ( C27 . ( C30 + 1 ) ) = [ F3(C31 , ( C29 . C30 ) , C30) , F4(( C29 . C30 ) , C30) ] by L48 , L40 , L46;
L50: (( ( C27 . ( C30 + 1 ) ) `1 ) = F3(C31 , ( C29 . C30 ) , C30) & ( ( C27 . ( C30 + 1 ) ) `2 ) = F4(( C29 . C30 ) , C30)) by L49 , MCART_1:7;
thus L51: thesis by L50 , L41 , L42;
end;
scheme CIRCCMB29sch2 { F5(set , set , set) -> non  empty ManySortedSign , F6(set , set) -> set , P1[set , set , set] , F7 , F8() -> (ManySortedSet of ( NAT )) } : (for B30 being Nat holds (ex B31 being non  empty ManySortedSign st (B31 = ( F7() . B30 ) & P1[ B31 , ( F8() . B30 ) , B30 ])))
provided
L52: (ex B32 being non  empty ManySortedSign st (ex B33 being set st (B32 = ( F7() . ( 0 ) ) & B33 = ( F8() . ( 0 ) ) & P1[ B32 , B33 , ( 0 ) ])))
and
L53: (for B34 being Nat holds (for B35 being non  empty ManySortedSign holds (for B36 being set holds ((B35 = ( F7() . B34 ) & B36 = ( F8() . B34 )) implies (( F7() . ( B34 + 1 ) ) = F5(B35 , B36 , B34) & ( F8() . ( B34 + 1 ) ) = F6(B36 , B34))))))
and
L54: (for B37 being Nat holds (for B38 being non  empty ManySortedSign holds (for B39 being set holds ((B38 = ( F7() . B37 ) & B39 = ( F8() . B37 ) & P1[ B38 , B39 , B37 ]) implies P1[ F5(B38 , B39 , B37) , F6(B39 , B37) , ( B37 + 1 ) ]))))
proof
defpred S2[ Nat ] means (ex B40 being non  empty ManySortedSign st (B40 = ( F7() . $1 ) & P1[ B40 , ( F8() . $1 ) , $1 ]));
L55: (for B41 being Nat holds (S2[ B41 ] implies S2[ ( B41 + 1 ) ]))
proof
let C33 being Nat;
given C34 being non  empty ManySortedSign such that
L56: C34 = ( F7() . C33 )
and
L57: P1[ C34 , ( F8() . C33 ) , C33 ];

take F5(C34 , ( F8() . C33 ) , C33);
L58: ( F8() . ( C33 + 1 ) ) = F6(( F8() . C33 ) , C33) by L53 , L56;
thus L59: thesis by L58 , L53 , L54 , L56 , L57;
end;
L60: S2[ ( 0 ) ] by L52;
thus L61: (for B42 being Nat holds S2[ B42 ]) from NAT_1:sch 2(L60 , L55);
end;
defpred S3[ set , set , set ] means (not contradiction);
scheme CIRCCMB29sch3 { F9() -> non  empty ManySortedSign , F10(set , set , set) -> non  empty ManySortedSign , F11(set , set) -> set , F12 , F13() -> (ManySortedSet of ( NAT )) } : (for B43 being Nat holds (for B44 being set holds (B44 = ( F13() . B43 ) implies ( F13() . ( B43 + 1 ) ) = F11(B44 , B43))))
provided
L62: ( F12() . ( 0 ) ) = F9()
and
L63: (for B45 being Nat holds (for B46 being non  empty ManySortedSign holds (for B47 being set holds ((B46 = ( F12() . B45 ) & B47 = ( F13() . B45 )) implies (( F12() . ( B45 + 1 ) ) = F10(B46 , B47 , B45) & ( F13() . ( B45 + 1 ) ) = F11(B47 , B45))))))
proof
L64: (ex B48 being non  empty ManySortedSign st (ex B49 being set st (B48 = ( F12() . ( 0 ) ) & B49 = ( F13() . ( 0 ) ) & S3[ B48 , B49 , ( 0 ) ]))) by L62;
let C35 being Nat;
let C36 being set;
L65: (for B50 being Nat holds (for B51 being non  empty ManySortedSign holds (for B52 being set holds ((B51 = ( F12() . B50 ) & B52 = ( F13() . B50 ) & S3[ B51 , B52 , B50 ]) implies S3[ F10(B51 , B52 , B50) , F11(B52 , B50) , ( B50 + 1 ) ]))));
L66: (for B53 being Nat holds (for B54 being non  empty ManySortedSign holds (for B55 being set holds ((B54 = ( F12() . B53 ) & B55 = ( F13() . B53 )) implies (( F12() . ( B53 + 1 ) ) = F10(B54 , B55 , B53) & ( F13() . ( B53 + 1 ) ) = F11(B55 , B53)))))) by L63;
L67: (for B56 being Nat holds (ex B57 being non  empty ManySortedSign st (B57 = ( F12() . B56 ) & S3[ B57 , ( F13() . B56 ) , B56 ]))) from CIRCCMB29sch2(L64 , L66 , L65);
L68: (ex B58 being non  empty ManySortedSign st B58 = ( F12() . C35 )) by L67;
assume L69: C36 = ( F13() . C35 );
thus L70: thesis by L69 , L63 , L68;
end;
scheme CIRCCMB29sch4 { F14() -> non  empty ManySortedSign , F15() -> set , F16(set , set , set) -> non  empty ManySortedSign , F17(set , set) -> set , F18() -> Nat } : (ex B59 being non  empty ManySortedSign st (ex B60 , B61 being (ManySortedSet of ( NAT )) st (B59 = ( B60 . F18() ) & ( B60 . ( 0 ) ) = F14() & ( B61 . ( 0 ) ) = F15() & (for B62 being Nat holds (for B63 being non  empty ManySortedSign holds (for B64 being set holds ((B63 = ( B60 . B62 ) & B64 = ( B61 . B62 )) implies (( B60 . ( B62 + 1 ) ) = F16(B63 , B64 , B62) & ( B61 . ( B62 + 1 ) ) = F17(B64 , B62)))))))))
proof
consider C37 , C38 being (ManySortedSet of ( NAT )) such that L71: (( C37 . ( 0 ) ) = F14() & ( C38 . ( 0 ) ) = F15()) and L72: (for B65 being Nat holds (for B66 being non  empty ManySortedSign holds (for B67 being set holds ((B66 = ( C37 . B65 ) & B67 = ( C38 . B65 )) implies (( C37 . ( B65 + 1 ) ) = F16(B66 , B67 , B65) & ( C38 . ( B65 + 1 ) ) = F17(B67 , B65)))))) from CIRCCMB29sch1;
L73: (for B68 being Nat holds (for B69 being non  empty ManySortedSign holds (for B70 being set holds ((B69 = ( C37 . B68 ) & B70 = ( C38 . B68 ) & S3[ B69 , B70 , B68 ]) implies S3[ F16(B69 , B70 , B68) , F17(B70 , B68) , ( B68 + 1 ) ]))));
L74: (ex B71 being non  empty ManySortedSign st (ex B72 being set st (B71 = ( C37 . ( 0 ) ) & B72 = ( C38 . ( 0 ) ) & S3[ B71 , B72 , ( 0 ) ]))) by L71;
L75: (for B73 being Nat holds (ex B74 being non  empty ManySortedSign st (B74 = ( C37 . B73 ) & S3[ B74 , ( C38 . B73 ) , B73 ]))) from CIRCCMB29sch2(L74 , L72 , L73);
consider C39 being non  empty ManySortedSign such that L76: C39 = ( C37 . F18() ) by L75;
take C39;
take C37;
take C38;
thus L77: thesis by L71 , L72 , L76;
end;
scheme CIRCCMB29sch5 { F19() -> non  empty ManySortedSign , F20() -> set , F21(set , set , set) -> non  empty ManySortedSign , F22(set , set) -> set , F23() -> Nat } : (for B75 , B76 being non  empty ManySortedSign holds (((ex B77 , B78 being (ManySortedSet of ( NAT )) st (B75 = ( B77 . F23() ) & ( B77 . ( 0 ) ) = F19() & ( B78 . ( 0 ) ) = F20() & (for B79 being Nat holds (for B80 being non  empty ManySortedSign holds (for B81 being set holds ((B80 = ( B77 . B79 ) & B81 = ( B78 . B79 )) implies (( B77 . ( B79 + 1 ) ) = F21(B80 , B81 , B79) & ( B78 . ( B79 + 1 ) ) = F22(B81 , B79)))))))) & (ex B82 , B83 being (ManySortedSet of ( NAT )) st (B76 = ( B82 . F23() ) & ( B82 . ( 0 ) ) = F19() & ( B83 . ( 0 ) ) = F20() & (for B84 being Nat holds (for B85 being non  empty ManySortedSign holds (for B86 being set holds ((B85 = ( B82 . B84 ) & B86 = ( B83 . B84 )) implies (( B82 . ( B84 + 1 ) ) = F21(B85 , B86 , B84) & ( B83 . ( B84 + 1 ) ) = F22(B86 , B84))))))))) implies B75 = B76))
proof
let C40 , C41 being non  empty ManySortedSign;
given C42 , C43 being (ManySortedSet of ( NAT )) such that
L78: C40 = ( C42 . F23() )
and
L79: ( C42 . ( 0 ) ) = F19()
and
L80: ( C43 . ( 0 ) ) = F20()
and
L81: (for B87 being Nat holds (for B88 being non  empty ManySortedSign holds (for B89 being set holds ((B88 = ( C42 . B87 ) & B89 = ( C43 . B87 )) implies (( C42 . ( B87 + 1 ) ) = F21(B88 , B89 , B87) & ( C43 . ( B87 + 1 ) ) = F22(B89 , B87))))));

L82: (for B90 being Nat holds (for B91 being non  empty ManySortedSign holds (for B92 being set holds ((B91 = ( C42 . B90 ) & B92 = ( C43 . B90 )) implies (( C42 . ( B90 + 1 ) ) = F21(B91 , B92 , B90) & ( C43 . ( B90 + 1 ) ) = F22(B92 , B90)))))) by L81;
L83: (for B93 being Nat holds (for B94 being non  empty ManySortedSign holds (for B95 being set holds ((B94 = ( C42 . B93 ) & B95 = ( C43 . B93 ) & S3[ B94 , B95 , B93 ]) implies S3[ F21(B94 , B95 , B93) , F22(B95 , B93) , ( B93 + 1 ) ]))));
L84: (ex B96 being non  empty ManySortedSign st (ex B97 being set st (B96 = ( C42 . ( 0 ) ) & B97 = ( C43 . ( 0 ) ) & S3[ B96 , B97 , ( 0 ) ]))) by L79;
L85: (for B98 being Nat holds (ex B99 being non  empty ManySortedSign st (B99 = ( C42 . B98 ) & S3[ B99 , ( C43 . B98 ) , B98 ]))) from CIRCCMB29sch2(L84 , L82 , L83);
given C44 , C45 being (ManySortedSet of ( NAT )) such that
L86: C41 = ( C44 . F23() )
and
L87: ( C44 . ( 0 ) ) = F19()
and
L88: ( C45 . ( 0 ) ) = F20()
and
L89: (for B100 being Nat holds (for B101 being non  empty ManySortedSign holds (for B102 being set holds ((B101 = ( C44 . B100 ) & B102 = ( C45 . B100 )) implies (( C44 . ( B100 + 1 ) ) = F21(B101 , B102 , B100) & ( C45 . ( B100 + 1 ) ) = F22(B102 , B100))))));

L90: (for B103 being Nat holds (for B104 being non  empty ManySortedSign holds (for B105 being set holds ((B104 = ( C44 . B103 ) & B105 = ( C45 . B103 )) implies (( C44 . ( B103 + 1 ) ) = F21(B104 , B105 , B103) & ( C45 . ( B103 + 1 ) ) = F22(B105 , B103)))))) by L89;
defpred S4[ Nat ] means ( C43 . $1 ) = ( C45 . $1 );
L91: (for B106 being Nat holds (for B107 being non  empty ManySortedSign holds (for B108 being set holds ((B107 = ( C44 . B106 ) & B108 = ( C45 . B106 ) & S3[ B107 , B108 , B106 ]) implies S3[ F21(B107 , B108 , B106) , F22(B108 , B106) , ( B106 + 1 ) ]))));
L92: (ex B109 being non  empty ManySortedSign st (ex B110 being set st (B109 = ( C44 . ( 0 ) ) & B110 = ( C45 . ( 0 ) ) & S3[ B109 , B110 , ( 0 ) ]))) by L87;
L93: (for B111 being Nat holds (ex B112 being non  empty ManySortedSign st (B112 = ( C44 . B111 ) & S3[ B112 , ( C45 . B111 ) , B111 ]))) from CIRCCMB29sch2(L92 , L90 , L91);
L94:
now
let C46 being Nat;
assume L95: S4[ C46 ];
L96: (ex B113 being non  empty ManySortedSign st (B113 = ( C42 . C46 ) & S3[ B113 , ( C43 . C46 ) , C46 ])) by L85;
L97: ( C43 . ( C46 + 1 ) ) = F22(( C43 . C46 ) , C46) by L96 , L81;
L98: (ex B114 being non  empty ManySortedSign st (B114 = ( C44 . C46 ) & S3[ B114 , ( C45 . C46 ) , C46 ])) by L93;
thus L99: S4[ ( C46 + 1 ) ] by L98 , L89 , L95 , L97;
end;
defpred S5[ Nat ] means ( C42 . $1 ) = ( C44 . $1 );
L100: S4[ ( 0 ) ] by L80 , L88;
L101: (for B115 being Nat holds S4[ B115 ]) from NAT_1:sch 2(L100 , L94);
L102: (for B116 being set holds (B116 in ( NAT ) implies ( C43 . B116 ) = ( C45 . B116 ))) by L101;
L103: C43 = C45 by L102 , PBOOLE:3;
L104:
now
let C47 being Nat;
assume L105: S5[ C47 ];
consider C48 being non  empty ManySortedSign such that L106: C48 = ( C42 . C47 ) and L107: S3[ C48 , ( C43 . C47 ) , C47 ] by L85;
L108: ( C42 . ( C47 + 1 ) ) = F21(C48 , ( C43 . C47 ) , C47) by L81 , L106
.= ( C44 . ( C47 + 1 ) ) by L89 , L103 , L105 , L106;
thus L109: S5[ ( C47 + 1 ) ] by L108;
end;
L110: S5[ ( 0 ) ] by L79 , L87;
L111: (for B117 being Nat holds S5[ B117 ]) from NAT_1:sch 2(L110 , L104);
thus L112: thesis by L111 , L78 , L86;
end;
scheme CIRCCMB29sch6 { F24() -> non  empty ManySortedSign , F25() -> set , F26(set , set , set) -> non  empty ManySortedSign , F27(set , set) -> set , F28() -> Nat } : ((ex B118 being non  empty ManySortedSign st (ex B119 , B120 being (ManySortedSet of ( NAT )) st (B118 = ( B119 . F28() ) & ( B119 . ( 0 ) ) = F24() & ( B120 . ( 0 ) ) = F25() & (for B121 being Nat holds (for B122 being non  empty ManySortedSign holds (for B123 being set holds ((B122 = ( B119 . B121 ) & B123 = ( B120 . B121 )) implies (( B119 . ( B121 + 1 ) ) = F26(B122 , B123 , B121) & ( B120 . ( B121 + 1 ) ) = F27(B123 , B121))))))))) & (for B124 , B125 being non  empty ManySortedSign holds (((ex B126 , B127 being (ManySortedSet of ( NAT )) st (B124 = ( B126 . F28() ) & ( B126 . ( 0 ) ) = F24() & ( B127 . ( 0 ) ) = F25() & (for B128 being Nat holds (for B129 being non  empty ManySortedSign holds (for B130 being set holds ((B129 = ( B126 . B128 ) & B130 = ( B127 . B128 )) implies (( B126 . ( B128 + 1 ) ) = F26(B129 , B130 , B128) & ( B127 . ( B128 + 1 ) ) = F27(B130 , B128)))))))) & (ex B131 , B132 being (ManySortedSet of ( NAT )) st (B125 = ( B131 . F28() ) & ( B131 . ( 0 ) ) = F24() & ( B132 . ( 0 ) ) = F25() & (for B133 being Nat holds (for B134 being non  empty ManySortedSign holds (for B135 being set holds ((B134 = ( B131 . B133 ) & B135 = ( B132 . B133 )) implies (( B131 . ( B133 + 1 ) ) = F26(B134 , B135 , B133) & ( B132 . ( B133 + 1 ) ) = F27(B135 , B133))))))))) implies B124 = B125)))
proof
thus L113: (ex B136 being non  empty ManySortedSign st (ex B137 , B138 being (ManySortedSet of ( NAT )) st (B136 = ( B137 . F28() ) & ( B137 . ( 0 ) ) = F24() & ( B138 . ( 0 ) ) = F25() & (for B139 being Nat holds (for B140 being non  empty ManySortedSign holds (for B141 being set holds ((B140 = ( B137 . B139 ) & B141 = ( B138 . B139 )) implies (( B137 . ( B139 + 1 ) ) = F26(B140 , B141 , B139) & ( B138 . ( B139 + 1 ) ) = F27(B141 , B139))))))))) from CIRCCMB29sch4;
thus L114: (for B142 , B143 being non  empty ManySortedSign holds (((ex B144 , B145 being (ManySortedSet of ( NAT )) st (B142 = ( B144 . F28() ) & ( B144 . ( 0 ) ) = F24() & ( B145 . ( 0 ) ) = F25() & (for B146 being Nat holds (for B147 being non  empty ManySortedSign holds (for B148 being set holds ((B147 = ( B144 . B146 ) & B148 = ( B145 . B146 )) implies (( B144 . ( B146 + 1 ) ) = F26(B147 , B148 , B146) & ( B145 . ( B146 + 1 ) ) = F27(B148 , B146)))))))) & (ex B149 , B150 being (ManySortedSet of ( NAT )) st (B143 = ( B149 . F28() ) & ( B149 . ( 0 ) ) = F24() & ( B150 . ( 0 ) ) = F25() & (for B151 being Nat holds (for B152 being non  empty ManySortedSign holds (for B153 being set holds ((B152 = ( B149 . B151 ) & B153 = ( B150 . B151 )) implies (( B149 . ( B151 + 1 ) ) = F26(B152 , B153 , B151) & ( B150 . ( B151 + 1 ) ) = F27(B153 , B151))))))))) implies B142 = B143)) from CIRCCMB29sch5;
end;
scheme CIRCCMB29sch7 { F29() -> non  empty ManySortedSign , F30(set , set , set) -> non  empty ManySortedSign , F31() -> set , F32(set , set) -> set , F33() -> Nat } : (ex B154 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty non  empty  strict ManySortedSign st (ex B155 , B156 being (ManySortedSet of ( NAT )) st (B154 = ( B155 . F33() ) & ( B155 . ( 0 ) ) = F29() & ( B156 . ( 0 ) ) = F31() & (for B157 being Nat holds (for B158 being non  empty ManySortedSign holds (for B159 being set holds ((B158 = ( B155 . B157 ) & B159 = ( B156 . B157 )) implies (( B155 . ( B157 + 1 ) ) = F30(B158 , B159 , B157) & ( B156 . ( B157 + 1 ) ) = F32(B159 , B157)))))))))
provided
L115: F29() is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict
and
L116: (for B160 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B161 being set holds (for B162 being Nat holds F30(B160 , B161 , B162) is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict)))
proof
defpred S6[ non  empty ManySortedSign , set ] means $1 is  unsplit  gate`1=arity  gate`2isBoolean non  void  strict;
defpred S7[ non  empty ManySortedSign , set , set ] means S6[ $1 , $2 ];
consider C49 being non  empty ManySortedSign, C50 , C51 being (ManySortedSet of ( NAT )) such that L117: (C49 = ( C50 . F33() ) & ( C50 . ( 0 ) ) = F29() & ( C51 . ( 0 ) ) = F31()) and L118: (for B163 being Nat holds (for B164 being non  empty ManySortedSign holds (for B165 being set holds ((B164 = ( C50 . B163 ) & B165 = ( C51 . B163 )) implies (( C50 . ( B163 + 1 ) ) = F30(B164 , B165 , B163) & ( C51 . ( B163 + 1 ) ) = F32(B165 , B163)))))) from CIRCCMB29sch4;
L119: (for B166 being Nat holds (for B167 being non  empty ManySortedSign holds (for B168 being set holds ((B167 = ( C50 . B166 ) & B168 = ( C51 . B166 ) & S7[ B167 , B168 , B166 ]) implies S7[ F30(B167 , B168 , B166) , F32(B168 , B166) , ( B166 + 1 ) ])))) by L116;
L120: (ex B169 being non  empty ManySortedSign st (ex B170 being set st (B169 = ( C50 . ( 0 ) ) & B170 = ( C51 . ( 0 ) ) & S7[ B169 , B170 , ( 0 ) ]))) by L115 , L117;
L121: (for B171 being Nat holds (ex B172 being non  empty ManySortedSign st (B172 = ( C50 . B171 ) & S7[ B172 , ( C51 . B171 ) , B171 ]))) from CIRCCMB29sch2(L120 , L118 , L119);
L122: (ex B173 being non  empty ManySortedSign st (B173 = ( C50 . F33() ) & S6[ B173 , F33() ])) by L121;
reconsider D7 = C49 as  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign by L122 , L117;
take D7;
take C50;
take C51;
thus L123: thesis by L117 , L118;
end;
scheme CIRCCMB29sch8 { F34() -> non  empty ManySortedSign , F35(set , set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign , F36() -> set , F37(set , set) -> set , F38() -> Nat } : (ex B174 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty non  empty  strict ManySortedSign st (ex B175 , B176 being (ManySortedSet of ( NAT )) st (B174 = ( B175 . F38() ) & ( B175 . ( 0 ) ) = F34() & ( B176 . ( 0 ) ) = F36() & (for B177 being Nat holds (for B178 being non  empty ManySortedSign holds (for B179 being set holds ((B178 = ( B175 . B177 ) & B179 = ( B176 . B177 )) implies (( B175 . ( B177 + 1 ) ) = ( B178 +* F35(B179 , B177) ) & ( B176 . ( B177 + 1 ) ) = F37(B179 , B177)))))))))
provided
L124: F34() is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict
proof
deffunc H4(non  empty ManySortedSign , set , set) = ( $1 +* F35($2 , $3) );
L125: (for B180 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B181 being set holds (for B182 being Nat holds H4(B180 , B181 , B182) is  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict)));
thus L126: (ex B183 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty non  empty  strict ManySortedSign st (ex B184 , B185 being (ManySortedSet of ( NAT )) st (B183 = ( B184 . F38() ) & ( B184 . ( 0 ) ) = F34() & ( B185 . ( 0 ) ) = F36() & (for B186 being Nat holds (for B187 being non  empty ManySortedSign holds (for B188 being set holds ((B187 = ( B184 . B186 ) & B188 = ( B185 . B186 )) implies (( B184 . ( B186 + 1 ) ) = H4(B187 , B188 , B186) & ( B185 . ( B186 + 1 ) ) = F37(B188 , B186))))))))) from CIRCCMB29sch7(L124 , L125);
end;
scheme CIRCCMB29sch9 { F39() -> non  empty ManySortedSign , F40() -> set , F41(set , set , set) -> non  empty ManySortedSign , F42(set , set) -> set , F43() -> Nat } : (for B189 , B190 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign holds (((ex B191 , B192 being (ManySortedSet of ( NAT )) st (B189 = ( B191 . F43() ) & ( B191 . ( 0 ) ) = F39() & ( B192 . ( 0 ) ) = F40() & (for B193 being Nat holds (for B194 being non  empty ManySortedSign holds (for B195 being set holds ((B194 = ( B191 . B193 ) & B195 = ( B192 . B193 )) implies (( B191 . ( B193 + 1 ) ) = F41(B194 , B195 , B193) & ( B192 . ( B193 + 1 ) ) = F42(B195 , B193)))))))) & (ex B196 , B197 being (ManySortedSet of ( NAT )) st (B190 = ( B196 . F43() ) & ( B196 . ( 0 ) ) = F39() & ( B197 . ( 0 ) ) = F40() & (for B198 being Nat holds (for B199 being non  empty ManySortedSign holds (for B200 being set holds ((B199 = ( B196 . B198 ) & B200 = ( B197 . B198 )) implies (( B196 . ( B198 + 1 ) ) = F41(B199 , B200 , B198) & ( B197 . ( B198 + 1 ) ) = F42(B200 , B198))))))))) implies B189 = B190))
proof
L127: (for B201 , B202 being non  empty ManySortedSign holds (((ex B203 , B204 being (ManySortedSet of ( NAT )) st (B201 = ( B203 . F43() ) & ( B203 . ( 0 ) ) = F39() & ( B204 . ( 0 ) ) = F40() & (for B205 being Nat holds (for B206 being non  empty ManySortedSign holds (for B207 being set holds ((B206 = ( B203 . B205 ) & B207 = ( B204 . B205 )) implies (( B203 . ( B205 + 1 ) ) = F41(B206 , B207 , B205) & ( B204 . ( B205 + 1 ) ) = F42(B207 , B205)))))))) & (ex B208 , B209 being (ManySortedSet of ( NAT )) st (B202 = ( B208 . F43() ) & ( B208 . ( 0 ) ) = F39() & ( B209 . ( 0 ) ) = F40() & (for B210 being Nat holds (for B211 being non  empty ManySortedSign holds (for B212 being set holds ((B211 = ( B208 . B210 ) & B212 = ( B209 . B210 )) implies (( B208 . ( B210 + 1 ) ) = F41(B211 , B212 , B210) & ( B209 . ( B210 + 1 ) ) = F42(B212 , B210))))))))) implies B201 = B202)) from CIRCCMB29sch5;
thus L128: thesis by L127;
end;
begin
theorem
L129: (for B213 , B214 being non  empty ManySortedSign holds (B213 tolerates B214 implies ( InputVertices ( B213 +* B214 ) ) = ( ( ( InputVertices B213 ) \ ( InnerVertices B214 ) ) \/ ( ( InputVertices B214 ) \ ( InnerVertices B213 ) ) )))
proof
let C52 , C53 being non  empty ManySortedSign;
L130: ( (the carrier of C52) \ ( ( rng (the ResultSort of C52) ) \/ ( rng (the ResultSort of C53) ) ) ) = ( ( InputVertices C52 ) \ ( InnerVertices C53 ) ) by XBOOLE_1:41;
assume L131: C52 tolerates C53;
L132: (the ResultSort of C52) tolerates (the ResultSort of C53) by L131 , CIRCCOMB:def 1;
L133: ( InputVertices ( C52 +* C53 ) ) = ( (the carrier of ( C52 +* C53 )) \ ( rng ( (the ResultSort of C52) +* (the ResultSort of C53) ) ) ) by CIRCCOMB:def 2
.= ( ( (the carrier of C52) \/ (the carrier of C53) ) \ ( rng ( (the ResultSort of C52) +* (the ResultSort of C53) ) ) ) by CIRCCOMB:def 2
.= ( ( (the carrier of C52) \/ (the carrier of C53) ) \ ( ( rng (the ResultSort of C52) ) \/ ( rng (the ResultSort of C53) ) ) ) by L132 , FRECHET:35
.= ( ( (the carrier of C52) \ ( ( rng (the ResultSort of C52) ) \/ ( rng (the ResultSort of C53) ) ) ) \/ ( (the carrier of C53) \ ( ( rng (the ResultSort of C52) ) \/ ( rng (the ResultSort of C53) ) ) ) ) by XBOOLE_1:42;
thus L134: thesis by L133 , L130 , XBOOLE_1:41;
end;
theorem
L135: (for B215 being  without_pairs set holds (for B216 being Relation holds ( B215 \ B216 ) = B215))
proof
let C54 being  without_pairs set;
let C55 being Relation;
L136: ( C54 /\ C55 ) = ( {} );
L137: C54 misses C55 by L136 , XBOOLE_0:def 7;
thus L138: thesis by L137 , XBOOLE_1:83;
end;
theorem
L139: (for B217 being Relation holds (for B218 , B219 being set holds ((B219 c= B218 & ( B218 \ B219 ) is  without_pairs) implies ( B217 \ B218 ) = ( B217 \ B219 ))))
proof
let C56 being Relation;
let C57 , C58 being set;
assume L140: C58 c= C57;
assume L141: ( C57 \ C58 ) is  without_pairs;
L142: (not (ex B220 being set st B220 in ( C56 /\ ( C57 \ C58 ) ))) by L141;
L143: ( C56 /\ ( C57 \ C58 ) ) = ( {} ) by L142 , XBOOLE_0:7;
L144: C56 misses ( C57 \ C58 ) by L143 , XBOOLE_0:def 7;
L145: ( C56 \ ( C57 \ C58 ) ) = C56 by L144 , XBOOLE_1:83;
L146: ( C56 \ C57 ) = ( C56 \ ( ( C57 \ C58 ) \/ C58 ) ) by L140 , XBOOLE_1:45
.= ( C56 \ C58 ) by L145 , XBOOLE_1:41;
thus L147: thesis by L146;
end;
theorem
L148: (for B221 , B222 being set holds (for B223 being Relation holds ((B222 c= B223 & ( B221 \ B222 ) is  without_pairs) implies ( B221 \ B223 ) = ( B221 \ B222 ))))
proof
let C59 , C60 being set;
let C61 being Relation;
assume L149: C60 c= C61;
assume L150: ( C59 \ C60 ) is  without_pairs;
L151: (not (ex B224 being set st B224 in ( ( C61 \ C60 ) /\ ( C59 \ C60 ) ))) by L150;
L152: ( ( C61 \ C60 ) /\ ( C59 \ C60 ) ) = ( {} ) by L151 , XBOOLE_0:7;
L153: ( C61 \ C60 ) misses ( C59 \ C60 ) by L152 , XBOOLE_0:def 7;
L154: ( ( C59 \ C60 ) \ ( C61 \ C60 ) ) = ( C59 \ C60 ) by L153 , XBOOLE_1:83;
L155: ( C59 \ C61 ) = ( C59 \ ( ( C61 \ C60 ) \/ C60 ) ) by L149 , XBOOLE_1:45
.= ( C59 \ C60 ) by L154 , XBOOLE_1:41;
thus L156: thesis by L155;
end;
scheme CIRCCMB29sch10 { F44() ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign , F45(set) -> set , F46() -> (ManySortedSet of ( NAT )) , F47(set , set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign , F48(set , set) -> set } : (for B225 being Nat holds (ex B226 , B227 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B226 = F45(B225) & B227 = F45(( B225 + 1 )) & ( InputVertices B227 ) = ( ( InputVertices B226 ) \/ ( ( InputVertices F47(( F46() . B225 ) , B225) ) \ { ( F46() . B225 ) } ) ) & ( InnerVertices B226 ) is Relation & ( InputVertices B226 ) is  without_pairs)))
provided
L157: ( InnerVertices F44() ) is Relation
and
L158: ( InputVertices F44() ) is  without_pairs
and
L159: (F45(( 0 )) = F44() & ( F46() . ( 0 ) ) in ( InnerVertices F44() ))
and
L160: (for B228 being Nat holds (for B229 being set holds ( InnerVertices F47(B229 , B228) ) is Relation))
and
L161: (for B230 being Nat holds (for B231 being set holds (B231 = ( F46() . B230 ) implies ( ( InputVertices F47(B231 , B230) ) \ { B231 } ) is  without_pairs)))
and
L162: (for B232 being Nat holds (for B233 being non  empty ManySortedSign holds (for B234 being set holds ((B233 = F45(B232) & B234 = ( F46() . B232 )) implies (F45(( B232 + 1 )) = ( B233 +* F47(B234 , B232) ) & ( F46() . ( B232 + 1 ) ) = F48(B234 , B232) & B234 in ( InputVertices F47(B234 , B232) ) & F48(B234 , B232) in ( InnerVertices F47(B234 , B232) ))))))
proof
L163: ( InnerVertices F47(( F46() . ( 0 ) ) , ( 0 )) ) is Relation by L160;
defpred S8[ Nat ] means (ex B235 , B236 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B235 = F45($1) & B236 = F45(( $1 + 1 )) & ( InputVertices B236 ) = ( ( InputVertices B235 ) \/ ( ( InputVertices F47(( F46() . $1 ) , $1) ) \ { ( F46() . $1 ) } ) ) & ( F46() . ( $1 + 1 ) ) in ( InnerVertices B236 ) & ( InputVertices B236 ) is  without_pairs & ( InnerVertices B236 ) is Relation));
L164: (for B237 being Nat holds (S8[ B237 ] implies S8[ ( B237 + 1 ) ]))
proof
let C62 being Nat;
given C63 , C64 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign such that
L165: C63 = F45(C62)
and
L166: C64 = F45(( C62 + 1 ))
and
L167: ( InputVertices C64 ) = ( ( InputVertices C63 ) \/ ( ( InputVertices F47(( F46() . C62 ) , C62) ) \ { ( F46() . C62 ) } ) )
and
L168: ( F46() . ( C62 + 1 ) ) in ( InnerVertices C64 )
and
L169: ( InputVertices C64 ) is  without_pairs
and
L170: ( InnerVertices C64 ) is Relation;

L171: { ( F46() . ( C62 + 1 ) ) } c= ( InnerVertices C64 ) by L168 , ZFMISC_1:31;
take C64;
take D8 = ( C64 +* F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) );
thus L172: (C64 = F45(( C62 + 1 )) & D8 = F45(( ( C62 + 1 ) + 1 ))) by L162 , L166;
L173: ( ( InputVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) \ { ( F46() . ( C62 + 1 ) ) } ) is  without_pairs by L161;
reconsider D9 = ( InputVertices C64 ) , D10 = ( ( InputVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) \ { ( F46() . ( C62 + 1 ) ) } ) as  without_pairs set by L161 , L169;
L174: ( InnerVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) is Relation by L160;
thus L175: ( InputVertices D8 ) = ( ( ( InputVertices C64 ) \ ( InnerVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) ) \/ ( ( InputVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) \ ( InnerVertices C64 ) ) ) by L129 , CIRCCOMB:47
.= ( ( InputVertices C64 ) \/ ( ( InputVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) \ ( InnerVertices C64 ) ) ) by L169 , L174 , L135
.= ( ( InputVertices C64 ) \/ ( ( InputVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) \ { ( F46() . ( C62 + 1 ) ) } ) ) by L170 , L173 , L171 , L148;
L176: ( InputVertices D8 ) = ( D9 \/ D10 ) by L175;
L177: (( F46() . ( ( C62 + 1 ) + 1 ) ) = F48(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) & F48(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) in ( InnerVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) )) by L162 , L166;
reconsider D11 = ( InnerVertices C64 ) , D12 = ( InnerVertices F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) ) as Relation by L160 , L170;
L178: C64 tolerates F47(( F46() . ( C62 + 1 ) ) , ( C62 + 1 )) by CIRCCOMB:47;
L179: ( InnerVertices D8 ) = ( D11 \/ D12 ) by L178 , CIRCCOMB:11;
thus L180: thesis by L179 , L177 , L176 , XBOOLE_0:def 3;
end;
let C65 being Nat;
L181: F44() tolerates F47(( F46() . ( 0 ) ) , ( 0 )) by CIRCCOMB:47;
L182: ( InputVertices ( F44() +* F47(( F46() . ( 0 ) ) , ( 0 )) ) ) = ( ( ( InputVertices F44() ) \ ( InnerVertices F47(( F46() . ( 0 ) ) , ( 0 )) ) ) \/ ( ( InputVertices F47(( F46() . ( 0 ) ) , ( 0 )) ) \ ( InnerVertices F44() ) ) ) by L129 , CIRCCOMB:47
.= ( ( InputVertices F44() ) \/ ( ( InputVertices F47(( F46() . ( 0 ) ) , ( 0 )) ) \ ( InnerVertices F44() ) ) ) by L158 , L163 , L135;
L183: S8[ ( 0 ) ]
proof
reconsider D13 = ( ( InputVertices F47(( F46() . ( 0 ) ) , ( 0 )) ) \ { ( F46() . ( 0 ) ) } ) , D14 = ( InputVertices F44() ) as  without_pairs set by L158 , L161;
take D15 = F44();
take D16 = ( F44() +* F47(( F46() . ( 0 ) ) , ( 0 )) );
thus L184: (D15 = F45(( 0 )) & D16 = F45(( ( 0 ) + 1 ))) by L159 , L162;
reconsider D17 = ( InnerVertices F44() ) , D18 = ( InnerVertices F47(( F46() . ( 0 ) ) , ( 0 )) ) as Relation by L157 , L160;
L185: (for B238 being set holds (B238 in { ( F46() . ( 0 ) ) } implies B238 in ( InnerVertices F44() ))) by L159 , TARSKI:def 1;
L186: { ( F46() . ( 0 ) ) } c= ( InnerVertices F44() ) by L185 , TARSKI:def 3;
L187: ( InputVertices D16 ) = ( D14 \/ D13 ) by L186 , L157 , L182 , L148;
L188: (( F46() . ( ( 0 ) + 1 ) ) = F48(( F46() . ( 0 ) ) , ( 0 )) & F48(( F46() . ( 0 ) ) , ( 0 )) in D18) by L159 , L162;
L189: ( F46() . ( ( 0 ) + 1 ) ) in ( D17 \/ D18 ) by L188 , XBOOLE_0:def 3;
thus L190: thesis by L189 , L181 , L187 , CIRCCOMB:11;
end;
L191: (for B239 being Nat holds S8[ B239 ]) from NAT_1:sch 2(L183 , L164);
consider C66 , C67 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign such that L192: C66 = F45(C65) and L193: (C67 = F45(( C65 + 1 )) & ( InputVertices C67 ) = ( ( InputVertices C66 ) \/ ( ( InputVertices F47(( F46() . C65 ) , C65) ) \ { ( F46() . C65 ) } ) )) and L194: ( F46() . ( C65 + 1 ) ) in ( InnerVertices C67 ) and L195: ( InputVertices C67 ) is  without_pairs and L196: ( InnerVertices C67 ) is Relation by L191;
take C66;
take C67;
thus L197: (C66 = F45(C65) & C67 = F45(( C65 + 1 )) & ( InputVertices C67 ) = ( ( InputVertices C66 ) \/ ( ( InputVertices F47(( F46() . C65 ) , C65) ) \ { ( F46() . C65 ) } ) )) by L192 , L193;
per cases  by NAT_1:6;
suppose L198: C65 = ( 0 );

thus L199: thesis by L198 , L157 , L158 , L159 , L192;
end;
suppose L200: (ex B240 being Nat st C65 = ( B240 + 1 ));

consider C68 being Nat such that L201: C65 = ( C68 + 1 ) by L200;
reconsider D19 = C68 as Nat;
L202: (ex B241 , B242 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B241 = F45(D19) & B242 = F45(( D19 + 1 )) & ( InputVertices B242 ) = ( ( InputVertices B241 ) \/ ( ( InputVertices F47(( F46() . D19 ) , D19) ) \ { ( F46() . D19 ) } ) ) & ( F46() . ( D19 + 1 ) ) in ( InnerVertices B242 ) & ( InputVertices B242 ) is  without_pairs & ( InnerVertices B242 ) is Relation)) by L191;
thus L203: thesis by L202 , L192 , L201;
end;
end;
scheme CIRCCMB29sch11 { F49(set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign , F50() -> (ManySortedSet of ( NAT )) , F51(set , set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign , F52(set , set) -> set } : (for B243 being Nat holds (( InputVertices F49(( B243 + 1 )) ) = ( ( InputVertices F49(B243) ) \/ ( ( InputVertices F51(( F50() . B243 ) , B243) ) \ { ( F50() . B243 ) } ) ) & ( InnerVertices F49(B243) ) is Relation & ( InputVertices F49(B243) ) is  without_pairs))
provided
L205: ( InnerVertices F49(( 0 )) ) is Relation
and
L206: ( InputVertices F49(( 0 )) ) is  without_pairs
and
L207: ( F50() . ( 0 ) ) in ( InnerVertices F49(( 0 )) )
and
L208: (for B244 being Nat holds (for B245 being set holds ( InnerVertices F51(B245 , B244) ) is Relation))
and
L209: (for B246 being Nat holds (for B247 being set holds (B247 = ( F50() . B246 ) implies ( ( InputVertices F51(B247 , B246) ) \ { B247 } ) is  without_pairs)))
and
L210: (for B248 being Nat holds (for B249 being non  empty ManySortedSign holds (for B250 being set holds ((B249 = F49(B248) & B250 = ( F50() . B248 )) implies (F49(( B248 + 1 )) = ( B249 +* F51(B250 , B248) ) & ( F50() . ( B248 + 1 ) ) = F52(B250 , B248) & B250 in ( InputVertices F51(B250 , B248) ) & F52(B250 , B248) in ( InnerVertices F51(B250 , B248) ))))))
proof
deffunc H5(set) = F49($1);
L211: (for B251 being Nat holds (for B252 being non  empty ManySortedSign holds (for B253 being set holds ((B252 = H5(B251) & B253 = ( F50() . B251 )) implies (H5(( B251 + 1 )) = ( B252 +* F51(B253 , B251) ) & ( F50() . ( B251 + 1 ) ) = F52(B253 , B251) & B253 in ( InputVertices F51(B253 , B251) ) & F52(B253 , B251) in ( InnerVertices F51(B253 , B251) )))))) by L210;
let C69 being Nat;
L212: (for B254 being Nat holds (for B255 being set holds (B255 = ( F50() . B254 ) implies ( ( InputVertices F51(B255 , B254) ) \ { B255 } ) is  without_pairs))) by L209;
L213: (H5(( 0 )) = H5(( 0 )) & ( F50() . ( 0 ) ) in ( InnerVertices H5(( 0 )) )) by L207;
L214: (for B256 being Nat holds (for B257 being set holds ( InnerVertices F51(B257 , B256) ) is Relation)) by L208;
L215: (for B258 being Nat holds (ex B259 , B260 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B259 = H5(B258) & B260 = H5(( B258 + 1 )) & ( InputVertices B260 ) = ( ( InputVertices B259 ) \/ ( ( InputVertices F51(( F50() . B258 ) , B258) ) \ { ( F50() . B258 ) } ) ) & ( InnerVertices B259 ) is Relation & ( InputVertices B259 ) is  without_pairs))) from CIRCCMB29sch10(L205 , L206 , L213 , L214 , L212 , L211);
L216: (ex B261 , B262 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B261 = F49(C69) & B262 = F49(( C69 + 1 )) & ( InputVertices B262 ) = ( ( InputVertices B261 ) \/ ( ( InputVertices F51(( F50() . C69 ) , C69) ) \ { ( F50() . C69 ) } ) ) & ( InnerVertices B261 ) is Relation & ( InputVertices B261 ) is  without_pairs)) by L215;
thus L217: thesis by L216;
end;
begin
scheme CIRCCMB29sch12 { F53() -> non  empty ManySortedSign , F54() ->  non-empty MSAlgebra over F53() , F55() -> set , F56(set , set , set) -> non  empty ManySortedSign , F57(set , set , set , set) -> set , F58(set , set) -> set } : (ex B263 , B264 , B265 being (ManySortedSet of ( NAT )) st (( B263 . ( 0 ) ) = F53() & ( B264 . ( 0 ) ) = F54() & ( B265 . ( 0 ) ) = F55() & (for B266 being Nat holds (for B267 being non  empty ManySortedSign holds (for B268 being  non-empty MSAlgebra over B267 holds (for B269 being set holds ((B267 = ( B263 . B266 ) & B268 = ( B264 . B266 ) & B269 = ( B265 . B266 )) implies (( B263 . ( B266 + 1 ) ) = F56(B267 , B269 , B266) & ( B264 . ( B266 + 1 ) ) = F57(B267 , B268 , B269 , B266) & ( B265 . ( B266 + 1 ) ) = F58(B269 , B266)))))))))
proof
deffunc H6(set , set) = [ [ F56(( $2 `11 ) , ( $2 `2 ) , $1) , F57(( $2 `11 ) , ( $2 `12 ) , ( $2 `2 ) , $1) ] , F58(( $2 `2 ) , $1) ];
consider C70 being Function such that L218: (( dom C70 ) = ( NAT ) & ( C70 . ( 0 ) ) = [ [ F53() , F54() ] , F55() ]) and L219: (for B270 being Nat holds ( C70 . ( B270 + 1 ) ) = H6(B270 , ( C70 . B270 ))) from NAT_1:sch 11;
L220: ( ( C70 . ( 0 ) ) `2 ) = F55() by L218 , MCART_1:7;
deffunc H7(set) = ( ( C70 . $1 ) `2 );
deffunc H8(set) = ( ( C70 . $1 ) `12 );
deffunc H9(set) = ( ( C70 . $1 ) `11 );
consider C71 being (ManySortedSet of ( NAT )) such that L221: (for B271 being set holds (B271 in ( NAT ) implies ( C71 . B271 ) = H9(B271))) from PBOOLE:sch 4;
consider C72 being (ManySortedSet of ( NAT )) such that L222: (for B272 being set holds (B272 in ( NAT ) implies ( C72 . B272 ) = H7(B272))) from PBOOLE:sch 4;
consider C73 being (ManySortedSet of ( NAT )) such that L223: (for B273 being set holds (B273 in ( NAT ) implies ( C73 . B273 ) = H8(B273))) from PBOOLE:sch 4;
take C71;
take C73;
take C72;
L224: (( ( C70 . ( 0 ) ) `11 ) = F53() & ( ( C70 . ( 0 ) ) `12 ) = F54()) by L218 , MCART_1:85;
thus L225: (( C71 . ( 0 ) ) = F53() & ( C73 . ( 0 ) ) = F54() & ( C72 . ( 0 ) ) = F55()) by L224 , L221 , L223 , L222 , L220;
let C74 being Nat;
let C75 being non  empty ManySortedSign;
let C76 being  non-empty MSAlgebra over C75;
let C77 being set;
set D20 = ( C70 . C74 );
L226: C74 in ( NAT ) by ORDINAL1:def 12;
L227: ( C72 . C74 ) = ( D20 `2 ) by L226 , L222;
assume that
L228: C75 = ( C71 . C74 )
and
L229: C76 = ( C73 . C74 );
L230: C76 = ( D20 `12 ) by L223 , L226 , L229;
L231: C75 = ( D20 `11 ) by L221 , L226 , L228;
L232: ( C70 . ( C74 + 1 ) ) = [ [ F56(C75 , ( C72 . C74 ) , C74) , F57(C75 , C76 , ( C72 . C74 ) , C74) ] , F58(( C72 . C74 ) , C74) ] by L231 , L219 , L230 , L227;
L233: ( ( C70 . ( C74 + 1 ) ) `2 ) = F58(( C72 . C74 ) , C74) by L232 , MCART_1:7;
L234: (( ( C70 . ( C74 + 1 ) ) `11 ) = F56(C75 , ( C72 . C74 ) , C74) & ( ( C70 . ( C74 + 1 ) ) `12 ) = F57(C75 , C76 , ( C72 . C74 ) , C74)) by L232 , MCART_1:85;
thus L235: thesis by L234 , L221 , L223 , L222 , L233;
end;
scheme CIRCCMB29sch13 { F59(set , set , set) -> non  empty ManySortedSign , F60(set , set , set , set) -> set , F61(set , set) -> set , P2[set , set , set , set] , F62 , F63 , F64() -> (ManySortedSet of ( NAT )) } : (for B274 being Nat holds (ex B275 being non  empty ManySortedSign st (ex B276 being  non-empty MSAlgebra over B275 st (B275 = ( F62() . B274 ) & B276 = ( F63() . B274 ) & P2[ B275 , B276 , ( F64() . B274 ) , B274 ]))))
provided
L236: (ex B277 being non  empty ManySortedSign st (ex B278 being  non-empty MSAlgebra over B277 st (ex B279 being set st (B277 = ( F62() . ( 0 ) ) & B278 = ( F63() . ( 0 ) ) & B279 = ( F64() . ( 0 ) ) & P2[ B277 , B278 , B279 , ( 0 ) ]))))
and
L237: (for B280 being Nat holds (for B281 being non  empty ManySortedSign holds (for B282 being  non-empty MSAlgebra over B281 holds (for B283 being set holds ((B281 = ( F62() . B280 ) & B282 = ( F63() . B280 ) & B283 = ( F64() . B280 )) implies (( F62() . ( B280 + 1 ) ) = F59(B281 , B283 , B280) & ( F63() . ( B280 + 1 ) ) = F60(B281 , B282 , B283 , B280) & ( F64() . ( B280 + 1 ) ) = F61(B283 , B280)))))))
and
L238: (for B284 being Nat holds (for B285 being non  empty ManySortedSign holds (for B286 being  non-empty MSAlgebra over B285 holds (for B287 being set holds ((B285 = ( F62() . B284 ) & B286 = ( F63() . B284 ) & B287 = ( F64() . B284 ) & P2[ B285 , B286 , B287 , B284 ]) implies P2[ F59(B285 , B287 , B284) , F60(B285 , B286 , B287 , B284) , F61(B287 , B284) , ( B284 + 1 ) ])))))
and
L239: (for B288 being non  empty ManySortedSign holds (for B289 being  non-empty MSAlgebra over B288 holds (for B290 being set holds (for B291 being Nat holds F60(B288 , B289 , B290 , B291) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F59(B288 , B290 , B291)))))
proof
defpred S9[ Nat ] means (ex B292 being non  empty ManySortedSign st (ex B293 being  non-empty MSAlgebra over B292 st (ex B294 being set st (B292 = ( F62() . $1 ) & B293 = ( F63() . $1 ) & B294 = ( F64() . $1 ) & P2[ B292 , B293 , B294 , $1 ]))));
L240: (for B295 being Nat holds (S9[ B295 ] implies S9[ ( B295 + 1 ) ]))
proof
let C78 being Nat;
given C79 being non  empty ManySortedSign , C80 being  non-empty MSAlgebra over C79 , C81 being set such that
L241: (C79 = ( F62() . C78 ) & C80 = ( F63() . C78 ) & C81 = ( F64() . C78 ))
and
L242: P2[ C79 , C80 , C81 , C78 ];

take D21 = F59(C79 , C81 , C78);
reconsider D22 = F60(C79 , C80 , C81 , C78) as  non-empty MSAlgebra over D21 by L239;
take D22;
take D23 = ( F64() . ( C78 + 1 ) );
L243: D23 = F61(C81 , C78) by L237 , L241;
thus L244: thesis by L243 , L237 , L238 , L241 , L242;
end;
let C82 being Nat;
L245: S9[ ( 0 ) ] by L236;
L246: (for B296 being Nat holds S9[ B296 ]) from NAT_1:sch 2(L245 , L240);
consider C83 being non  empty ManySortedSign, C84 being  non-empty MSAlgebra over C83, C85 being set such that L247: (C83 = ( F62() . C82 ) & C84 = ( F63() . C82 ) & C85 = ( F64() . C82 ) & P2[ C83 , C84 , C85 , C82 ]) by L246;
take C83;
take C84;
thus L248: thesis by L247;
end;
defpred S10[ set , set , set , set ] means (not contradiction);
scheme CIRCCMB29sch14 { F65(set , set , set) -> non  empty ManySortedSign , F66(set , set , set , set) -> set , F67(set , set) -> set , F68 , F69 , F70 , F71 , F72 , F73() -> (ManySortedSet of ( NAT )) } : (F68() = F69() & F70() = F71() & F72() = F73())
provided
L249: (ex B297 being non  empty ManySortedSign st (ex B298 being  non-empty MSAlgebra over B297 st (B297 = ( F68() . ( 0 ) ) & B298 = ( F70() . ( 0 ) ))))
and
L250: (( F68() . ( 0 ) ) = ( F69() . ( 0 ) ) & ( F70() . ( 0 ) ) = ( F71() . ( 0 ) ) & ( F72() . ( 0 ) ) = ( F73() . ( 0 ) ))
and
L251: (for B299 being Nat holds (for B300 being non  empty ManySortedSign holds (for B301 being  non-empty MSAlgebra over B300 holds (for B302 being set holds ((B300 = ( F68() . B299 ) & B301 = ( F70() . B299 ) & B302 = ( F72() . B299 )) implies (( F68() . ( B299 + 1 ) ) = F65(B300 , B302 , B299) & ( F70() . ( B299 + 1 ) ) = F66(B300 , B301 , B302 , B299) & ( F72() . ( B299 + 1 ) ) = F67(B302 , B299)))))))
and
L252: (for B303 being Nat holds (for B304 being non  empty ManySortedSign holds (for B305 being  non-empty MSAlgebra over B304 holds (for B306 being set holds ((B304 = ( F69() . B303 ) & B305 = ( F71() . B303 ) & B306 = ( F73() . B303 )) implies (( F69() . ( B303 + 1 ) ) = F65(B304 , B306 , B303) & ( F71() . ( B303 + 1 ) ) = F66(B304 , B305 , B306 , B303) & ( F73() . ( B303 + 1 ) ) = F67(B306 , B303)))))))
and
L253: (for B307 being non  empty ManySortedSign holds (for B308 being  non-empty MSAlgebra over B307 holds (for B309 being set holds (for B310 being Nat holds F66(B307 , B308 , B309 , B310) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F65(B307 , B309 , B310)))))
proof
L254: (for B311 being Nat holds (for B312 being non  empty ManySortedSign holds (for B313 being  non-empty MSAlgebra over B312 holds (for B314 being set holds ((B312 = ( F68() . B311 ) & B313 = ( F70() . B311 ) & B314 = ( F72() . B311 )) implies (( F68() . ( B311 + 1 ) ) = F65(B312 , B314 , B311) & ( F70() . ( B311 + 1 ) ) = F66(B312 , B313 , B314 , B311) & ( F72() . ( B311 + 1 ) ) = F67(B314 , B311))))))) by L251;
set D24 = F68();
set D25 = F70();
set D26 = F72();
L255: (for B315 being Nat holds (for B316 being non  empty ManySortedSign holds (for B317 being  non-empty MSAlgebra over B316 holds (for B318 being set holds ((B316 = ( D24 . B315 ) & B317 = ( D25 . B315 ) & B318 = ( D26 . B315 ) & S10[ B316 , B317 , B318 , B315 ]) implies S10[ F65(B316 , B318 , B315) , F66(B316 , B317 , B318 , B315) , F67(B318 , B315) , ( B315 + 1 ) ])))));
L256: (for B319 being non  empty ManySortedSign holds (for B320 being  non-empty MSAlgebra over B319 holds (for B321 being set holds (for B322 being Nat holds F66(B319 , B320 , B321 , B322) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F65(B319 , B321 , B322))))) by L253;
L257: (ex B323 being non  empty ManySortedSign st (ex B324 being  non-empty MSAlgebra over B323 st (ex B325 being set st (B323 = ( D24 . ( 0 ) ) & B324 = ( D25 . ( 0 ) ) & B325 = ( D26 . ( 0 ) ) & S10[ B323 , B324 , B325 , ( 0 ) ])))) by L249;
L258: (for B326 being Nat holds (ex B327 being non  empty ManySortedSign st (ex B328 being  non-empty MSAlgebra over B327 st (B327 = ( D24 . B326 ) & B328 = ( D25 . B326 ) & S10[ B327 , B328 , ( D26 . B326 ) , B326 ])))) from CIRCCMB29sch13(L257 , L254 , L255 , L256);
set D27 = F69();
set D28 = F71();
set D29 = F73();
L259: (for B329 being Nat holds (for B330 being non  empty ManySortedSign holds (for B331 being  non-empty MSAlgebra over B330 holds (for B332 being set holds ((B330 = ( D27 . B329 ) & B331 = ( D28 . B329 ) & B332 = ( D29 . B329 ) & S10[ B330 , B331 , B332 , B329 ]) implies S10[ F65(B330 , B332 , B329) , F66(B330 , B331 , B332 , B329) , F67(B332 , B329) , ( B329 + 1 ) ])))));
defpred S11[ Nat ] means ( D26 . $1 ) = ( D29 . $1 );
L260: (for B333 being Nat holds (for B334 being non  empty ManySortedSign holds (for B335 being  non-empty MSAlgebra over B334 holds (for B336 being set holds ((B334 = ( F69() . B333 ) & B335 = ( F71() . B333 ) & B336 = ( F73() . B333 )) implies (( F69() . ( B333 + 1 ) ) = F65(B334 , B336 , B333) & ( F71() . ( B333 + 1 ) ) = F66(B334 , B335 , B336 , B333) & ( F73() . ( B333 + 1 ) ) = F67(B336 , B333))))))) by L252;
L261: (ex B337 being non  empty ManySortedSign st (ex B338 being  non-empty MSAlgebra over B337 st (ex B339 being set st (B337 = ( D27 . ( 0 ) ) & B338 = ( D28 . ( 0 ) ) & B339 = ( D29 . ( 0 ) ) & S10[ B337 , B338 , B339 , ( 0 ) ])))) by L249 , L250;
L262: (for B340 being Nat holds (ex B341 being non  empty ManySortedSign st (ex B342 being  non-empty MSAlgebra over B341 st (B341 = ( D27 . B340 ) & B342 = ( D28 . B340 ) & S10[ B341 , B342 , ( D29 . B340 ) , B340 ])))) from CIRCCMB29sch13(L261 , L260 , L259 , L256);
L263:
now
let C86 being Nat;
assume L264: S11[ C86 ];
L265: (ex B343 being non  empty ManySortedSign st (ex B344 being  non-empty MSAlgebra over B343 st (B343 = ( D24 . C86 ) & B344 = ( D25 . C86 )))) by L258;
L266: ( D26 . ( C86 + 1 ) ) = F67(( D26 . C86 ) , C86) by L265 , L251;
L267: (ex B345 being non  empty ManySortedSign st (ex B346 being  non-empty MSAlgebra over B345 st (B345 = ( D27 . C86 ) & B346 = ( D28 . C86 )))) by L262;
thus L268: S11[ ( C86 + 1 ) ] by L267 , L252 , L264 , L266;
end;
L269: S11[ ( 0 ) ] by L250;
L270: (for B347 being Nat holds S11[ B347 ]) from NAT_1:sch 2(L269 , L263);
L271: (for B348 being set holds (B348 in ( NAT ) implies ( D26 . B348 ) = ( D29 . B348 ))) by L270;
defpred S12[ Nat ] means (( D24 . $1 ) = ( D27 . $1 ) & ( D25 . $1 ) = ( D28 . $1 ));
L272: D26 = D29 by L271 , PBOOLE:3;
L273:
now
let C87 being Nat;
assume L274: S12[ C87 ];
consider C88 being non  empty ManySortedSign, C89 being  non-empty MSAlgebra over C88 such that L275: (C88 = ( D24 . C87 ) & C89 = ( D25 . C87 )) by L258;
L276: ( D25 . ( C87 + 1 ) ) = F66(C88 , C89 , ( D26 . C87 ) , C87) by L251 , L275
.= ( D28 . ( C87 + 1 ) ) by L252 , L272 , L274 , L275;
L277: ( D24 . ( C87 + 1 ) ) = F65(C88 , ( D26 . C87 ) , C87) by L251 , L275
.= ( D27 . ( C87 + 1 ) ) by L252 , L272 , L274 , L275;
thus L278: S12[ ( C87 + 1 ) ] by L277 , L276;
end;
L279: S12[ ( 0 ) ] by L250;
L280: (for B349 being Nat holds S12[ B349 ]) from NAT_1:sch 2(L279 , L273);
L281: ((for B350 being set holds (B350 in ( NAT ) implies ( D24 . B350 ) = ( D27 . B350 ))) & (for B351 being set holds (B351 in ( NAT ) implies ( D25 . B351 ) = ( D28 . B351 )))) by L280;
thus L282: thesis by L281 , L271 , PBOOLE:3;
end;
scheme CIRCCMB29sch15 { F74() -> non  empty ManySortedSign , F75() ->  non-empty MSAlgebra over F74() , F76(set , set , set) -> non  empty ManySortedSign , F77(set , set , set , set) -> set , F78(set , set) -> set , F79 , F80 , F81() -> (ManySortedSet of ( NAT )) } : (for B352 being Nat holds (for B353 being non  empty ManySortedSign holds (for B354 being set holds ((B353 = ( F79() . B352 ) & B354 = ( F81() . B352 )) implies (( F79() . ( B352 + 1 ) ) = F76(B353 , B354 , B352) & ( F81() . ( B352 + 1 ) ) = F78(B354 , B352))))))
provided
L283: (( F79() . ( 0 ) ) = F74() & ( F80() . ( 0 ) ) = F75())
and
L284: (for B355 being Nat holds (for B356 being non  empty ManySortedSign holds (for B357 being  non-empty MSAlgebra over B356 holds (for B358 being set holds ((B356 = ( F79() . B355 ) & B357 = ( F80() . B355 ) & B358 = ( F81() . B355 )) implies (( F79() . ( B355 + 1 ) ) = F76(B356 , B358 , B355) & ( F80() . ( B355 + 1 ) ) = F77(B356 , B357 , B358 , B355) & ( F81() . ( B355 + 1 ) ) = F78(B358 , B355)))))))
and
L285: (for B359 being non  empty ManySortedSign holds (for B360 being  non-empty MSAlgebra over B359 holds (for B361 being set holds (for B362 being Nat holds F77(B359 , B360 , B361 , B362) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F76(B359 , B361 , B362)))))
proof
L286: (ex B363 being non  empty ManySortedSign st (ex B364 being  non-empty MSAlgebra over B363 st (ex B365 being set st (B363 = ( F79() . ( 0 ) ) & B364 = ( F80() . ( 0 ) ) & B365 = ( F81() . ( 0 ) ) & S10[ B363 , B364 , B365 , ( 0 ) ])))) by L283;
let C90 being Nat;
let C91 being non  empty ManySortedSign;
let C92 being set;
L287: (for B366 being Nat holds (for B367 being non  empty ManySortedSign holds (for B368 being  non-empty MSAlgebra over B367 holds (for B369 being set holds ((B367 = ( F79() . B366 ) & B368 = ( F80() . B366 ) & B369 = ( F81() . B366 ) & S10[ B367 , B368 , B369 , B366 ]) implies S10[ F76(B367 , B369 , B366) , F77(B367 , B368 , B369 , B366) , F78(B369 , B366) , ( B366 + 1 ) ])))));
L288: (for B370 being non  empty ManySortedSign holds (for B371 being  non-empty MSAlgebra over B370 holds (for B372 being set holds (for B373 being Nat holds F77(B370 , B371 , B372 , B373) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F76(B370 , B372 , B373))))) by L285;
L289: (for B374 being Nat holds (for B375 being non  empty ManySortedSign holds (for B376 being  non-empty MSAlgebra over B375 holds (for B377 being set holds ((B375 = ( F79() . B374 ) & B376 = ( F80() . B374 ) & B377 = ( F81() . B374 )) implies (( F79() . ( B374 + 1 ) ) = F76(B375 , B377 , B374) & ( F80() . ( B374 + 1 ) ) = F77(B375 , B376 , B377 , B374) & ( F81() . ( B374 + 1 ) ) = F78(B377 , B374))))))) by L284;
L290: (for B378 being Nat holds (ex B379 being non  empty ManySortedSign st (ex B380 being  non-empty MSAlgebra over B379 st (B379 = ( F79() . B378 ) & B380 = ( F80() . B378 ) & S10[ B379 , B380 , ( F81() . B378 ) , B378 ])))) from CIRCCMB29sch13(L286 , L289 , L287 , L288);
L291: (ex B381 being non  empty ManySortedSign st (ex B382 being  non-empty MSAlgebra over B381 st (B381 = ( F79() . C90 ) & B382 = ( F80() . C90 )))) by L290;
assume L292: (C91 = ( F79() . C90 ) & C92 = ( F81() . C90 ));
thus L293: thesis by L292 , L284 , L291;
end;
scheme CIRCCMB29sch16 { F82() -> non  empty ManySortedSign , F83() ->  non-empty MSAlgebra over F82() , F84() -> set , F85(set , set , set) -> non  empty ManySortedSign , F86(set , set , set , set) -> set , F87(set , set) -> set , F88() -> Nat } : (ex B383 being non  empty ManySortedSign st (ex B384 being  non-empty MSAlgebra over B383 st (ex B385 , B386 , B387 being (ManySortedSet of ( NAT )) st (B383 = ( B385 . F88() ) & B384 = ( B386 . F88() ) & ( B385 . ( 0 ) ) = F82() & ( B386 . ( 0 ) ) = F83() & ( B387 . ( 0 ) ) = F84() & (for B388 being Nat holds (for B389 being non  empty ManySortedSign holds (for B390 being  non-empty MSAlgebra over B389 holds (for B391 being set holds ((B389 = ( B385 . B388 ) & B390 = ( B386 . B388 ) & B391 = ( B387 . B388 )) implies (( B385 . ( B388 + 1 ) ) = F85(B389 , B391 , B388) & ( B386 . ( B388 + 1 ) ) = F86(B389 , B390 , B391 , B388) & ( B387 . ( B388 + 1 ) ) = F87(B391 , B388)))))))))))
provided
L294: (for B392 being non  empty ManySortedSign holds (for B393 being  non-empty MSAlgebra over B392 holds (for B394 being set holds (for B395 being Nat holds F86(B392 , B393 , B394 , B395) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F85(B392 , B394 , B395)))))
proof
L295: (for B396 being non  empty ManySortedSign holds (for B397 being  non-empty MSAlgebra over B396 holds (for B398 being set holds (for B399 being Nat holds F86(B396 , B397 , B398 , B399) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F85(B396 , B398 , B399))))) by L294;
consider C93 , C94 , C95 being (ManySortedSet of ( NAT )) such that L296: (( C93 . ( 0 ) ) = F82() & ( C94 . ( 0 ) ) = F83() & ( C95 . ( 0 ) ) = F84()) and L297: (for B400 being Nat holds (for B401 being non  empty ManySortedSign holds (for B402 being  non-empty MSAlgebra over B401 holds (for B403 being set holds ((B401 = ( C93 . B400 ) & B402 = ( C94 . B400 ) & B403 = ( C95 . B400 )) implies (( C93 . ( B400 + 1 ) ) = F85(B401 , B403 , B400) & ( C94 . ( B400 + 1 ) ) = F86(B401 , B402 , B403 , B400) & ( C95 . ( B400 + 1 ) ) = F87(B403 , B400))))))) from CIRCCMB29sch12;
L298: (for B404 being Nat holds (for B405 being non  empty ManySortedSign holds (for B406 being  non-empty MSAlgebra over B405 holds (for B407 being set holds ((B405 = ( C93 . B404 ) & B406 = ( C94 . B404 ) & B407 = ( C95 . B404 ) & S10[ B405 , B406 , B407 , B404 ]) implies S10[ F85(B405 , B407 , B404) , F86(B405 , B406 , B407 , B404) , F87(B407 , B404) , ( B404 + 1 ) ])))));
L299: (ex B408 being non  empty ManySortedSign st (ex B409 being  non-empty MSAlgebra over B408 st (ex B410 being set st (B408 = ( C93 . ( 0 ) ) & B409 = ( C94 . ( 0 ) ) & B410 = ( C95 . ( 0 ) ) & S10[ B408 , B409 , B410 , ( 0 ) ])))) by L296;
L300: (for B411 being Nat holds (ex B412 being non  empty ManySortedSign st (ex B413 being  non-empty MSAlgebra over B412 st (B412 = ( C93 . B411 ) & B413 = ( C94 . B411 ) & S10[ B412 , B413 , ( C95 . B411 ) , B411 ])))) from CIRCCMB29sch13(L299 , L297 , L298 , L295);
consider C96 being non  empty ManySortedSign, C97 being  non-empty MSAlgebra over C96 such that L301: (C96 = ( C93 . F88() ) & C97 = ( C94 . F88() )) by L300;
take C96;
take C97;
take C93;
take C94;
take C95;
thus L302: thesis by L296 , L297 , L301;
end;
scheme CIRCCMB29sch17 { F89 , F90() -> non  empty ManySortedSign , F91() ->  non-empty MSAlgebra over F89() , F92() -> set , F93(set , set , set) -> non  empty ManySortedSign , F94(set , set , set , set) -> set , F95(set , set) -> set , F96() -> Nat } : (ex B414 being  non-empty MSAlgebra over F90() st (ex B415 , B416 , B417 being (ManySortedSet of ( NAT )) st (F90() = ( B415 . F96() ) & B414 = ( B416 . F96() ) & ( B415 . ( 0 ) ) = F89() & ( B416 . ( 0 ) ) = F91() & ( B417 . ( 0 ) ) = F92() & (for B418 being Nat holds (for B419 being non  empty ManySortedSign holds (for B420 being  non-empty MSAlgebra over B419 holds (for B421 being set holds ((B419 = ( B415 . B418 ) & B420 = ( B416 . B418 ) & B421 = ( B417 . B418 )) implies (( B415 . ( B418 + 1 ) ) = F93(B419 , B421 , B418) & ( B416 . ( B418 + 1 ) ) = F94(B419 , B420 , B421 , B418) & ( B417 . ( B418 + 1 ) ) = F95(B421 , B418))))))))))
provided
L303: (ex B422 , B423 being (ManySortedSet of ( NAT )) st (F90() = ( B422 . F96() ) & ( B422 . ( 0 ) ) = F89() & ( B423 . ( 0 ) ) = F92() & (for B424 being Nat holds (for B425 being non  empty ManySortedSign holds (for B426 being set holds ((B425 = ( B422 . B424 ) & B426 = ( B423 . B424 )) implies (( B422 . ( B424 + 1 ) ) = F93(B425 , B426 , B424) & ( B423 . ( B424 + 1 ) ) = F95(B426 , B424))))))))
and
L304: (for B427 being non  empty ManySortedSign holds (for B428 being  non-empty MSAlgebra over B427 holds (for B429 being set holds (for B430 being Nat holds F94(B427 , B428 , B429 , B430) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F93(B427 , B429 , B430)))))
proof
L305: (for B431 being non  empty ManySortedSign holds (for B432 being  non-empty MSAlgebra over B431 holds (for B433 being set holds (for B434 being Nat holds F94(B431 , B432 , B433 , B434) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F93(B431 , B433 , B434))))) by L304;
consider C98 , C99 , C100 being (ManySortedSet of ( NAT )) such that L306: (( C98 . ( 0 ) ) = F89() & ( C99 . ( 0 ) ) = F91() & ( C100 . ( 0 ) ) = F92()) and L307: (for B435 being Nat holds (for B436 being non  empty ManySortedSign holds (for B437 being  non-empty MSAlgebra over B436 holds (for B438 being set holds ((B436 = ( C98 . B435 ) & B437 = ( C99 . B435 ) & B438 = ( C100 . B435 )) implies (( C98 . ( B435 + 1 ) ) = F93(B436 , B438 , B435) & ( C99 . ( B435 + 1 ) ) = F94(B436 , B437 , B438 , B435) & ( C100 . ( B435 + 1 ) ) = F95(B438 , B435))))))) from CIRCCMB29sch12;
L308: (for B439 being Nat holds (for B440 being non  empty ManySortedSign holds (for B441 being  non-empty MSAlgebra over B440 holds (for B442 being set holds ((B440 = ( C98 . B439 ) & B441 = ( C99 . B439 ) & B442 = ( C100 . B439 ) & S10[ B440 , B441 , B442 , B439 ]) implies S10[ F93(B440 , B442 , B439) , F94(B440 , B441 , B442 , B439) , F95(B442 , B439) , ( B439 + 1 ) ])))));
L309: (for B443 being Nat holds (for B444 being non  empty ManySortedSign holds (for B445 being  non-empty MSAlgebra over B444 holds (for B446 being set holds ((B444 = ( C98 . B443 ) & B445 = ( C99 . B443 ) & B446 = ( C100 . B443 ) & S10[ B444 , B445 , B446 , B443 ]) implies S10[ F93(B444 , B446 , B443) , F94(B444 , B445 , B446 , B443) , F95(B446 , B443) , ( B443 + 1 ) ])))));
L310: (ex B447 being non  empty ManySortedSign st (ex B448 being  non-empty MSAlgebra over B447 st (ex B449 being set st (B447 = ( C98 . ( 0 ) ) & B448 = ( C99 . ( 0 ) ) & B449 = ( C100 . ( 0 ) ) & S10[ B447 , B448 , B449 , ( 0 ) ])))) by L306;
L311: (for B450 being Nat holds (ex B451 being non  empty ManySortedSign st (ex B452 being  non-empty MSAlgebra over B451 st (B451 = ( C98 . B450 ) & B452 = ( C99 . B450 ) & S10[ B451 , B452 , ( C100 . B450 ) , B450 ])))) from CIRCCMB29sch13(L310 , L307 , L309 , L305);
L312: (ex B453 being non  empty ManySortedSign st (ex B454 being  non-empty MSAlgebra over B453 st (ex B455 being set st (B453 = ( C98 . ( 0 ) ) & B454 = ( C99 . ( 0 ) ) & B455 = ( C100 . ( 0 ) ) & S10[ B453 , B454 , B455 , ( 0 ) ])))) by L306;
L313: (for B456 being Nat holds (ex B457 being non  empty ManySortedSign st (ex B458 being  non-empty MSAlgebra over B457 st (B457 = ( C98 . B456 ) & B458 = ( C99 . B456 ) & S10[ B457 , B458 , ( C100 . B456 ) , B456 ])))) from CIRCCMB29sch13(L312 , L307 , L308 , L305);
consider C101 being non  empty ManySortedSign, C102 being  non-empty MSAlgebra over C101 such that L314: C101 = ( C98 . F96() ) and L315: C102 = ( C99 . F96() ) by L313;
consider C103 , C104 being (ManySortedSet of ( NAT )) such that L316: F90() = ( C103 . F96() ) and L317: ( C103 . ( 0 ) ) = F89() and L318: ( C104 . ( 0 ) ) = F92() and L319: (for B459 being Nat holds (for B460 being non  empty ManySortedSign holds (for B461 being set holds ((B460 = ( C103 . B459 ) & B461 = ( C104 . B459 )) implies (( C103 . ( B459 + 1 ) ) = F93(B460 , B461 , B459) & ( C104 . ( B459 + 1 ) ) = F95(B461 , B459)))))) by L303;
L320: (for B462 being Nat holds (for B463 being non  empty ManySortedSign holds (for B464 being set holds ((B463 = ( C103 . B462 ) & B464 = ( C104 . B462 ) & S3[ B463 , B464 , B462 ]) implies S3[ F93(B463 , B464 , B462) , F95(B464 , B462) , ( B462 + 1 ) ]))));
defpred S13[ Nat ] means ( C104 . $1 ) = ( C100 . $1 );
L321: (ex B465 being non  empty ManySortedSign st (ex B466 being set st (B465 = ( C103 . ( 0 ) ) & B466 = ( C104 . ( 0 ) ) & S3[ B465 , B466 , ( 0 ) ]))) by L317;
L322: (for B467 being Nat holds (ex B468 being non  empty ManySortedSign st (B468 = ( C103 . B467 ) & S3[ B468 , ( C104 . B467 ) , B467 ]))) from CIRCCMB29sch2(L321 , L319 , L320);
L323:
now
let C105 being Nat;
assume L324: S13[ C105 ];
L325: (ex B469 being non  empty ManySortedSign st B469 = ( C103 . C105 )) by L322;
L326: ( C104 . ( C105 + 1 ) ) = F95(( C104 . C105 ) , C105) by L325 , L319;
L327: (ex B470 being non  empty ManySortedSign st (ex B471 being  non-empty MSAlgebra over B470 st (B470 = ( C98 . C105 ) & B471 = ( C99 . C105 )))) by L311;
thus L328: S13[ ( C105 + 1 ) ] by L327 , L307 , L324 , L326;
end;
L329: S13[ ( 0 ) ] by L306 , L318;
L330: (for B472 being Nat holds S13[ B472 ]) from NAT_1:sch 2(L329 , L323);
defpred S14[ Nat ] means ( C103 . $1 ) = ( C98 . $1 );
L331: (for B473 being set holds (B473 in ( NAT ) implies ( C104 . B473 ) = ( C100 . B473 ))) by L330;
L332: C104 = C100 by L331 , PBOOLE:3;
L333:
now
let C106 being Nat;
consider C107 being non  empty ManySortedSign, C108 being  non-empty MSAlgebra over C107 such that L334: C107 = ( C98 . C106 ) and L335: C108 = ( C99 . C106 ) by L311;
assume L336: S14[ C106 ];
L337: ( C103 . ( C106 + 1 ) ) = F93(C107 , ( C104 . C106 ) , C106) by L336 , L319 , L334
.= ( C98 . ( C106 + 1 ) ) by L307 , L332 , L334 , L335;
thus L338: S14[ ( C106 + 1 ) ] by L337;
end;
L339: S14[ ( 0 ) ] by L306 , L317;
L340: (for B474 being Nat holds S14[ B474 ]) from NAT_1:sch 2(L339 , L333);
L341: (for B475 being set holds (B475 in ( NAT ) implies ( C103 . B475 ) = ( C98 . B475 ))) by L340;
L342: C103 = C98 by L341 , PBOOLE:3;
reconsider D30 = C102 as  non-empty MSAlgebra over F90() by L342 , L316 , L314;
take D30;
take C98;
take C99;
take C100;
thus L343: thesis by L306 , L307 , L316 , L340 , L315;
end;
scheme CIRCCMB29sch18 { F97 , F98() -> non  empty ManySortedSign , F99() ->  non-empty MSAlgebra over F97() , F100() -> set , F101(set , set , set) -> non  empty ManySortedSign , F102(set , set , set , set) -> set , F103(set , set) -> set , F104() -> Nat } : (for B476 , B477 being  non-empty MSAlgebra over F98() holds (((ex B478 , B479 , B480 being (ManySortedSet of ( NAT )) st (F98() = ( B478 . F104() ) & B476 = ( B479 . F104() ) & ( B478 . ( 0 ) ) = F97() & ( B479 . ( 0 ) ) = F99() & ( B480 . ( 0 ) ) = F100() & (for B481 being Nat holds (for B482 being non  empty ManySortedSign holds (for B483 being  non-empty MSAlgebra over B482 holds (for B484 being set holds ((B482 = ( B478 . B481 ) & B483 = ( B479 . B481 ) & B484 = ( B480 . B481 )) implies (( B478 . ( B481 + 1 ) ) = F101(B482 , B484 , B481) & ( B479 . ( B481 + 1 ) ) = F102(B482 , B483 , B484 , B481) & ( B480 . ( B481 + 1 ) ) = F103(B484 , B481))))))))) & (ex B485 , B486 , B487 being (ManySortedSet of ( NAT )) st (F98() = ( B485 . F104() ) & B477 = ( B486 . F104() ) & ( B485 . ( 0 ) ) = F97() & ( B486 . ( 0 ) ) = F99() & ( B487 . ( 0 ) ) = F100() & (for B488 being Nat holds (for B489 being non  empty ManySortedSign holds (for B490 being  non-empty MSAlgebra over B489 holds (for B491 being set holds ((B489 = ( B485 . B488 ) & B490 = ( B486 . B488 ) & B491 = ( B487 . B488 )) implies (( B485 . ( B488 + 1 ) ) = F101(B489 , B491 , B488) & ( B486 . ( B488 + 1 ) ) = F102(B489 , B490 , B491 , B488) & ( B487 . ( B488 + 1 ) ) = F103(B491 , B488)))))))))) implies B476 = B477))
provided
L344: (for B492 being non  empty ManySortedSign holds (for B493 being  non-empty MSAlgebra over B492 holds (for B494 being set holds (for B495 being Nat holds F102(B492 , B493 , B494 , B495) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F101(B492 , B494 , B495)))))
proof
L345: (for B496 being non  empty ManySortedSign holds (for B497 being  non-empty MSAlgebra over B496 holds (for B498 being set holds (for B499 being Nat holds F102(B496 , B497 , B498 , B499) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F101(B496 , B498 , B499))))) by L344;
let C109 , C110 being  non-empty MSAlgebra over F98();
given C111 , C112 , C113 being (ManySortedSet of ( NAT )) such that
L346: F98() = ( C111 . F104() )
and
L347: C109 = ( C112 . F104() )
and
L348: (( C111 . ( 0 ) ) = F97() & ( C112 . ( 0 ) ) = F99())
and
L349: ( C113 . ( 0 ) ) = F100()
and
L350: (for B500 being Nat holds (for B501 being non  empty ManySortedSign holds (for B502 being  non-empty MSAlgebra over B501 holds (for B503 being set holds ((B501 = ( C111 . B500 ) & B502 = ( C112 . B500 ) & B503 = ( C113 . B500 )) implies (( C111 . ( B500 + 1 ) ) = F101(B501 , B503 , B500) & ( C112 . ( B500 + 1 ) ) = F102(B501 , B502 , B503 , B500) & ( C113 . ( B500 + 1 ) ) = F103(B503 , B500)))))));

L351: (ex B504 being non  empty ManySortedSign st (ex B505 being  non-empty MSAlgebra over B504 st (B504 = ( C111 . ( 0 ) ) & B505 = ( C112 . ( 0 ) )))) by L348;
given C114 , C115 , C116 being (ManySortedSet of ( NAT )) such that
L352: F98() = ( C114 . F104() )
and
L353: C110 = ( C115 . F104() )
and
L354: (( C114 . ( 0 ) ) = F97() & ( C115 . ( 0 ) ) = F99() & ( C116 . ( 0 ) ) = F100())
and
L355: (for B506 being Nat holds (for B507 being non  empty ManySortedSign holds (for B508 being  non-empty MSAlgebra over B507 holds (for B509 being set holds ((B507 = ( C114 . B506 ) & B508 = ( C115 . B506 ) & B509 = ( C116 . B506 )) implies (( C114 . ( B506 + 1 ) ) = F101(B507 , B509 , B506) & ( C115 . ( B506 + 1 ) ) = F102(B507 , B508 , B509 , B506) & ( C116 . ( B506 + 1 ) ) = F103(B509 , B506)))))));

L356: (( C111 . ( 0 ) ) = ( C114 . ( 0 ) ) & ( C112 . ( 0 ) ) = ( C115 . ( 0 ) ) & ( C113 . ( 0 ) ) = ( C116 . ( 0 ) )) by L348 , L349 , L354;
L357: (C111 = C114 & C112 = C115 & C113 = C116) from CIRCCMB29sch14(L351 , L356 , L350 , L355 , L345);
thus L358: thesis by L357 , L347 , L353;
end;
scheme CIRCCMB29sch19 { F105 , F106() ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign , F107() ->  Boolean  gate`2=den  strict (Circuit of F105()) , F108(set , set , set) -> non  empty ManySortedSign , F109(set , set , set , set) -> set , F110() -> set , F111(set , set) -> set , F112() -> Nat } : (ex B510 being  Boolean  gate`2=den  strict (Circuit of F106()) st (ex B511 , B512 , B513 being (ManySortedSet of ( NAT )) st (F106() = ( B511 . F112() ) & B510 = ( B512 . F112() ) & ( B511 . ( 0 ) ) = F105() & ( B512 . ( 0 ) ) = F107() & ( B513 . ( 0 ) ) = F110() & (for B514 being Nat holds (for B515 being non  empty ManySortedSign holds (for B516 being  non-empty MSAlgebra over B515 holds (for B517 being set holds ((B515 = ( B511 . B514 ) & B516 = ( B512 . B514 ) & B517 = ( B513 . B514 )) implies (( B511 . ( B514 + 1 ) ) = F108(B515 , B517 , B514) & ( B512 . ( B514 + 1 ) ) = F109(B515 , B516 , B517 , B514) & ( B513 . ( B514 + 1 ) ) = F111(B517 , B514))))))))))
provided
L359: (for B518 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B519 being set holds (for B520 being Nat holds F108(B518 , B519 , B520) is  unsplit  gate`1=arity  gate`2isBoolean non  void  strict)))
and
L360: (ex B521 , B522 being (ManySortedSet of ( NAT )) st (F106() = ( B521 . F112() ) & ( B521 . ( 0 ) ) = F105() & ( B522 . ( 0 ) ) = F110() & (for B523 being Nat holds (for B524 being non  empty ManySortedSign holds (for B525 being set holds ((B524 = ( B521 . B523 ) & B525 = ( B522 . B523 )) implies (( B521 . ( B523 + 1 ) ) = F108(B524 , B525 , B523) & ( B522 . ( B523 + 1 ) ) = F111(B525 , B523))))))))
and
L361: (for B526 being non  empty ManySortedSign holds (for B527 being  non-empty MSAlgebra over B526 holds (for B528 being set holds (for B529 being Nat holds F109(B526 , B527 , B528 , B529) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F108(B526 , B528 , B529)))))
and
L362: (for B530 , B531 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign holds (for B532 being  Boolean  gate`2=den  strict (Circuit of B530) holds (for B533 being set holds (for B534 being Nat holds (B531 = F108(B530 , B533 , B534) implies F109(B530 , B532 , B533 , B534) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of B531))))))
proof
L363: (for B535 being non  empty ManySortedSign holds (for B536 being  non-empty MSAlgebra over B535 holds (for B537 being set holds (for B538 being Nat holds F109(B535 , B536 , B537 , B538) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F108(B535 , B537 , B538))))) by L361;
defpred S15[ set , set , Nat ] means (ex B539 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign st (ex B540 being  Boolean  gate`2=den  strict (Circuit of B539) st (B539 = $1 & B540 = $2)));
consider C117 , C118 , C119 being (ManySortedSet of ( NAT )) such that L364: (( C117 . ( 0 ) ) = F105() & ( C118 . ( 0 ) ) = F107() & ( C119 . ( 0 ) ) = F110()) and L365: (for B541 being Nat holds (for B542 being non  empty ManySortedSign holds (for B543 being  non-empty MSAlgebra over B542 holds (for B544 being set holds ((B542 = ( C117 . B541 ) & B543 = ( C118 . B541 ) & B544 = ( C119 . B541 )) implies (( C117 . ( B541 + 1 ) ) = F108(B542 , B544 , B541) & ( C118 . ( B541 + 1 ) ) = F109(B542 , B543 , B544 , B541) & ( C119 . ( B541 + 1 ) ) = F111(B544 , B541))))))) from CIRCCMB29sch12;
L366: (for B545 being Nat holds (for B546 being non  empty ManySortedSign holds (for B547 being  non-empty MSAlgebra over B546 holds (for B548 being set holds ((B546 = ( C117 . B545 ) & B547 = ( C118 . B545 ) & B548 = ( C119 . B545 ) & S10[ B546 , B547 , B548 , B545 ]) implies S10[ F108(B546 , B548 , B545) , F109(B546 , B547 , B548 , B545) , F111(B548 , B545) , ( B545 + 1 ) ])))));
L367: (ex B549 being non  empty ManySortedSign st (ex B550 being  non-empty MSAlgebra over B549 st (ex B551 being set st (B549 = ( C117 . ( 0 ) ) & B550 = ( C118 . ( 0 ) ) & B551 = ( C119 . ( 0 ) ) & S10[ B549 , B550 , B551 , ( 0 ) ])))) by L364;
L368: (for B552 being Nat holds (ex B553 being non  empty ManySortedSign st (ex B554 being  non-empty MSAlgebra over B553 st (B553 = ( C117 . B552 ) & B554 = ( C118 . B552 ) & S10[ B553 , B554 , ( C119 . B552 ) , B552 ])))) from CIRCCMB29sch13(L367 , L365 , L366 , L363);
defpred S16[ set , set , set , Nat ] means S15[ $1 , $2 , $4 ];
L369: (for B555 being Nat holds (for B556 being non  empty ManySortedSign holds (for B557 being  non-empty MSAlgebra over B556 holds (for B558 being set holds ((B556 = ( C117 . B555 ) & B557 = ( C118 . B555 ) & B558 = ( C119 . B555 ) & S16[ B556 , B557 , B558 , B555 ]) implies S16[ F108(B556 , B558 , B555) , F109(B556 , B557 , B558 , B555) , F111(B558 , B555) , ( B555 + 1 ) ])))))
proof
let C120 being Nat;
let C121 being non  empty ManySortedSign;
let C122 being  non-empty MSAlgebra over C121;
let C123 being set;
assume that
L370: C121 = ( C117 . C120 )
and
L371: C122 = ( C118 . C120 )
and
L372: C123 = ( C119 . C120 )
and
L373: S15[ C121 , C122 , C120 ];
reconsider D31 = C121 as  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign by L373;
reconsider D32 = C122 as  Boolean  gate`2=den  strict (Circuit of D31) by L373;
reconsider D33 = F108(D31 , C123 , C120) as  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign by L359;
L374: F109(D31 , D32 , C123 , C120) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of D33) by L362;
thus L375: thesis by L374;
end;
L376: (ex B559 being non  empty ManySortedSign st (ex B560 being  non-empty MSAlgebra over B559 st (ex B561 being set st (B559 = ( C117 . ( 0 ) ) & B560 = ( C118 . ( 0 ) ) & B561 = ( C119 . ( 0 ) ) & S16[ B559 , B560 , B561 , ( 0 ) ])))) by L364;
L377: (for B562 being Nat holds (ex B563 being non  empty ManySortedSign st (ex B564 being  non-empty MSAlgebra over B563 st (B563 = ( C117 . B562 ) & B564 = ( C118 . B562 ) & S16[ B563 , B564 , ( C119 . B562 ) , B562 ])))) from CIRCCMB29sch13(L376 , L365 , L369 , L363);
consider C124 being non  empty ManySortedSign, C125 being  non-empty MSAlgebra over C124 such that L378: C124 = ( C117 . F112() ) and L379: C125 = ( C118 . F112() ) and L380: S15[ C124 , C125 , F112() ] by L377;
consider C126 , C127 being (ManySortedSet of ( NAT )) such that L381: F106() = ( C126 . F112() ) and L382: ( C126 . ( 0 ) ) = F105() and L383: ( C127 . ( 0 ) ) = F110() and L384: (for B565 being Nat holds (for B566 being non  empty ManySortedSign holds (for B567 being set holds ((B566 = ( C126 . B565 ) & B567 = ( C127 . B565 )) implies (( C126 . ( B565 + 1 ) ) = F108(B566 , B567 , B565) & ( C127 . ( B565 + 1 ) ) = F111(B567 , B565)))))) by L360;
L385: (for B568 being Nat holds (for B569 being non  empty ManySortedSign holds (for B570 being set holds ((B569 = ( C126 . B568 ) & B570 = ( C127 . B568 ) & S3[ B569 , B570 , B568 ]) implies S3[ F108(B569 , B570 , B568) , F111(B570 , B568) , ( B568 + 1 ) ]))));
defpred S17[ Nat ] means ( C127 . $1 ) = ( C119 . $1 );
L386: (ex B571 being non  empty ManySortedSign st (ex B572 being set st (B571 = ( C126 . ( 0 ) ) & B572 = ( C127 . ( 0 ) ) & S3[ B571 , B572 , ( 0 ) ]))) by L382;
L387: (for B573 being Nat holds (ex B574 being non  empty ManySortedSign st (B574 = ( C126 . B573 ) & S3[ B574 , ( C127 . B573 ) , B573 ]))) from CIRCCMB29sch2(L386 , L384 , L385);
L388:
now
let C128 being Nat;
assume L389: S17[ C128 ];
L390: (ex B575 being non  empty ManySortedSign st B575 = ( C126 . C128 )) by L387;
L391: ( C127 . ( C128 + 1 ) ) = F111(( C127 . C128 ) , C128) by L390 , L384;
L392: (ex B576 being non  empty ManySortedSign st (ex B577 being  non-empty MSAlgebra over B576 st (B576 = ( C117 . C128 ) & B577 = ( C118 . C128 )))) by L368;
thus L393: S17[ ( C128 + 1 ) ] by L392 , L365 , L389 , L391;
end;
L394: S17[ ( 0 ) ] by L364 , L383;
L395: (for B578 being Nat holds S17[ B578 ]) from NAT_1:sch 2(L394 , L388);
defpred S18[ Nat ] means ( C126 . $1 ) = ( C117 . $1 );
L396: (for B579 being set holds (B579 in ( NAT ) implies ( C127 . B579 ) = ( C119 . B579 ))) by L395;
L397: C127 = C119 by L396 , PBOOLE:3;
L398:
now
let C129 being Nat;
consider C130 being non  empty ManySortedSign, C131 being  non-empty MSAlgebra over C130 such that L399: C130 = ( C117 . C129 ) and L400: C131 = ( C118 . C129 ) by L368;
assume L401: S18[ C129 ];
L402: ( C126 . ( C129 + 1 ) ) = F108(C130 , ( C127 . C129 ) , C129) by L401 , L384 , L399
.= ( C117 . ( C129 + 1 ) ) by L365 , L397 , L399 , L400;
thus L403: S18[ ( C129 + 1 ) ] by L402;
end;
L404: S18[ ( 0 ) ] by L364 , L382;
L405: (for B580 being Nat holds S18[ B580 ]) from NAT_1:sch 2(L404 , L398);
L406: (for B581 being set holds (B581 in ( NAT ) implies ( C126 . B581 ) = ( C117 . B581 ))) by L405;
L407: C126 = C117 by L406 , PBOOLE:3;
reconsider D34 = C125 as  Boolean  gate`2=den  strict (Circuit of F106()) by L407 , L381 , L378 , L380;
take D34;
take C117;
take C118;
take C119;
thus L408: thesis by L364 , L365 , L381 , L405 , L379;
end;
definition
let C132 being non  empty ManySortedSign;
let C133 being set;
assume that
L409: C133 is  non-empty  non-empty  non-empty  non-empty MSAlgebra over C132;
func MSAlg (C133 , C132) ->  non-empty MSAlgebra over C132 means 
:L410: it = C133;
existence by L409;
uniqueness;
end;
scheme CIRCCMB29sch20 { F113 , F114() ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign , F115() ->  Boolean  gate`2=den  strict (Circuit of F113()) , F116(set , set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign , F117(set , set) -> set , F118() -> set , F119(set , set) -> set , F120() -> Nat } : (ex B582 being  Boolean  gate`2=den  strict (Circuit of F114()) st (ex B583 , B584 , B585 being (ManySortedSet of ( NAT )) st (F114() = ( B583 . F120() ) & B582 = ( B584 . F120() ) & ( B583 . ( 0 ) ) = F113() & ( B584 . ( 0 ) ) = F115() & ( B585 . ( 0 ) ) = F118() & (for B586 being Nat holds (for B587 being non  empty ManySortedSign holds (for B588 being  non-empty MSAlgebra over B587 holds (for B589 being set holds (for B590 being  non-empty MSAlgebra over F116(B589 , B586) holds ((B587 = ( B583 . B586 ) & B588 = ( B584 . B586 ) & B589 = ( B585 . B586 ) & B590 = F117(B589 , B586)) implies (( B583 . ( B586 + 1 ) ) = ( B587 +* F116(B589 , B586) ) & ( B584 . ( B586 + 1 ) ) = ( B588 +* B590 ) & ( B585 . ( B586 + 1 ) ) = F119(B589 , B586)))))))))))
provided
L412: (ex B591 , B592 being (ManySortedSet of ( NAT )) st (F114() = ( B591 . F120() ) & ( B591 . ( 0 ) ) = F113() & ( B592 . ( 0 ) ) = F118() & (for B593 being Nat holds (for B594 being non  empty ManySortedSign holds (for B595 being set holds ((B594 = ( B591 . B593 ) & B595 = ( B592 . B593 )) implies (( B591 . ( B593 + 1 ) ) = ( B594 +* F116(B595 , B593) ) & ( B592 . ( B593 + 1 ) ) = F119(B595 , B593))))))))
and
L413: (for B596 being set holds (for B597 being Nat holds F117(B596 , B597) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of F116(B596 , B597))))
proof
deffunc H10(non  empty ManySortedSign , set , set) = ( $1 +* F116($2 , $3) );
consider C134 , C135 being (ManySortedSet of ( NAT )) such that L414: F114() = ( C134 . F120() ) and L415: ( C134 . ( 0 ) ) = F113() and L416: ( C135 . ( 0 ) ) = F118() and L417: (for B598 being Nat holds (for B599 being non  empty ManySortedSign holds (for B600 being set holds ((B599 = ( C134 . B598 ) & B600 = ( C135 . B598 )) implies (( C134 . ( B598 + 1 ) ) = H10(B599 , B600 , B598) & ( C135 . ( B598 + 1 ) ) = F119(B600 , B598)))))) by L412;
defpred S19[ set , set , Nat ] means ($3 <> ( 0 ) implies (ex B601 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign st (ex B602 being  Boolean  gate`2=den  strict (Circuit of B601) st (B601 = $1 & B602 = $2))));
deffunc H11(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , set) = ( $2 +* ( MSAlg (F117($3 , $4) , F116($3 , $4)) ) );
L418: (for B603 being non  empty ManySortedSign holds (for B604 being  non-empty MSAlgebra over B603 holds (for B605 being set holds (for B606 being Nat holds H11(B603 , B604 , B605 , B606) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H10(B603 , B605 , B606)))));
L419: (for B607 being Nat holds (for B608 being non  empty ManySortedSign holds (for B609 being set holds ((B608 = ( C134 . B607 ) & B609 = ( C135 . B607 ) & S3[ B608 , B609 , B607 ]) implies S3[ H10(B608 , B609 , B607) , F119(B609 , B607) , ( B607 + 1 ) ]))));
consider C136 , C137 , C138 being (ManySortedSet of ( NAT )) such that L420: (( C136 . ( 0 ) ) = F113() & ( C137 . ( 0 ) ) = F115() & ( C138 . ( 0 ) ) = F118()) and L421: (for B610 being Nat holds (for B611 being non  empty ManySortedSign holds (for B612 being  non-empty MSAlgebra over B611 holds (for B613 being set holds ((B611 = ( C136 . B610 ) & B612 = ( C137 . B610 ) & B613 = ( C138 . B610 )) implies (( C136 . ( B610 + 1 ) ) = H10(B611 , B613 , B610) & ( C137 . ( B610 + 1 ) ) = H11(B611 , B612 , B613 , B610) & ( C138 . ( B610 + 1 ) ) = F119(B613 , B610))))))) from CIRCCMB29sch12;
L422: (for B614 being Nat holds (for B615 being non  empty ManySortedSign holds (for B616 being  non-empty MSAlgebra over B615 holds (for B617 being set holds ((B615 = ( C136 . B614 ) & B616 = ( C137 . B614 ) & B617 = ( C138 . B614 ) & S10[ B615 , B616 , B617 , B614 ]) implies S10[ H10(B615 , B617 , B614) , H11(B615 , B616 , B617 , B614) , F119(B617 , B614) , ( B614 + 1 ) ])))));
L423: (ex B618 being non  empty ManySortedSign st (ex B619 being  non-empty MSAlgebra over B618 st (ex B620 being set st (B618 = ( C136 . ( 0 ) ) & B619 = ( C137 . ( 0 ) ) & B620 = ( C138 . ( 0 ) ) & S10[ B618 , B619 , B620 , ( 0 ) ])))) by L420;
L424: (for B621 being Nat holds (ex B622 being non  empty ManySortedSign st (ex B623 being  non-empty MSAlgebra over B622 st (B622 = ( C136 . B621 ) & B623 = ( C137 . B621 ) & S10[ B622 , B623 , ( C138 . B621 ) , B621 ])))) from CIRCCMB29sch13(L423 , L421 , L422 , L418);
defpred S20[ Nat ] means ( C135 . $1 ) = ( C138 . $1 );
L425: (ex B624 being non  empty ManySortedSign st (ex B625 being set st (B624 = ( C134 . ( 0 ) ) & B625 = ( C135 . ( 0 ) ) & S3[ B624 , B625 , ( 0 ) ]))) by L415;
L426: (for B626 being Nat holds (ex B627 being non  empty ManySortedSign st (B627 = ( C134 . B626 ) & S3[ B627 , ( C135 . B626 ) , B626 ]))) from CIRCCMB29sch2(L425 , L417 , L419);
L427:
now
let C139 being Nat;
assume L428: S20[ C139 ];
L429: (ex B628 being non  empty ManySortedSign st B628 = ( C134 . C139 )) by L426;
L430: ( C135 . ( C139 + 1 ) ) = F119(( C135 . C139 ) , C139) by L429 , L417;
L431: (ex B629 being non  empty ManySortedSign st (ex B630 being  non-empty MSAlgebra over B629 st (B629 = ( C136 . C139 ) & B630 = ( C137 . C139 )))) by L424;
thus L432: S20[ ( C139 + 1 ) ] by L431 , L421 , L428 , L430;
end;
L433: S20[ ( 0 ) ] by L420 , L416;
L434: (for B631 being Nat holds S20[ B631 ]) from NAT_1:sch 2(L433 , L427);
defpred S21[ Nat ] means ( C134 . $1 ) = ( C136 . $1 );
L435: (for B632 being set holds (B632 in ( NAT ) implies ( C135 . B632 ) = ( C138 . B632 ))) by L434;
L436: C135 = C138 by L435 , PBOOLE:3;
L437:
now
let C140 being Nat;
consider C141 being non  empty ManySortedSign, C142 being  non-empty MSAlgebra over C141 such that L438: C141 = ( C136 . C140 ) and L439: C142 = ( C137 . C140 ) by L424;
assume L440: S21[ C140 ];
L441: ( C134 . ( C140 + 1 ) ) = ( C141 +* F116(( C135 . C140 ) , C140) ) by L440 , L417 , L438
.= ( C136 . ( C140 + 1 ) ) by L421 , L436 , L438 , L439;
thus L442: S21[ ( C140 + 1 ) ] by L441;
end;
defpred S22[ set , set , set , Nat ] means S19[ $1 , $2 , $4 ];
L443: (for B633 being Nat holds (for B634 being non  empty ManySortedSign holds (for B635 being  non-empty MSAlgebra over B634 holds (for B636 being set holds ((B634 = ( C136 . B633 ) & B635 = ( C137 . B633 ) & B636 = ( C138 . B633 ) & S22[ B634 , B635 , B636 , B633 ]) implies S22[ H10(B634 , B636 , B633) , H11(B634 , B635 , B636 , B633) , F119(B636 , B633) , ( B633 + 1 ) ])))))
proof
let C143 being Nat;
let C144 being non  empty ManySortedSign;
let C145 being  non-empty MSAlgebra over C144;
let C146 being set;
assume that
L444: (C144 = ( C136 . C143 ) & C145 = ( C137 . C143 ))
and
L445: C146 = ( C138 . C143 )
and
L446: S19[ C144 , C145 , C143 ]
and
L447: ( C143 + 1 ) <> ( 0 );
per cases ;
suppose L448: C143 = ( 0 );

reconsider D35 = F117(C146 , ( 0 )) as  Boolean  gate`2=den  strict (Circuit of F116(C146 , ( 0 ))) by L413;
L449: ( F115() +* ( MSAlg (F117(C146 , ( 0 )) , F116(C146 , ( 0 ))) ) ) = ( F115() +* D35 ) by L410;
thus L450: thesis by L449 , L420 , L444 , L448;
end;
suppose L451: C143 <> ( 0 );

reconsider D36 = C144 as  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty  strict non  empty ManySortedSign by L451 , L446;
reconsider D37 = C145 as  Boolean  gate`2=den  strict (Circuit of D36) by L446 , L451;
reconsider D38 = F117(C146 , C143) as  Boolean  gate`2=den  strict (Circuit of F116(C146 , C143)) by L413;
L452: ( D37 +* ( MSAlg (F117(C146 , C143) , F116(C146 , C143)) ) ) = ( D37 +* D38 ) by L410;
thus L453: thesis by L452;
end;
end;
L455: (ex B637 being non  empty ManySortedSign st (ex B638 being  non-empty MSAlgebra over B637 st (ex B639 being set st (B637 = ( C136 . ( 0 ) ) & B638 = ( C137 . ( 0 ) ) & B639 = ( C138 . ( 0 ) ) & S22[ B637 , B638 , B639 , ( 0 ) ])))) by L420;
L456: (for B640 being Nat holds (ex B641 being non  empty ManySortedSign st (ex B642 being  non-empty MSAlgebra over B641 st (B641 = ( C136 . B640 ) & B642 = ( C137 . B640 ) & S22[ B641 , B642 , ( C138 . B640 ) , B640 ])))) from CIRCCMB29sch13(L455 , L421 , L443 , L418);
consider C147 being non  empty ManySortedSign, C148 being  non-empty MSAlgebra over C147 such that L457: C147 = ( C136 . F120() ) and L458: C148 = ( C137 . F120() ) and L459: S19[ C147 , C148 , F120() ] by L456;
L460: S21[ ( 0 ) ] by L420 , L415;
L461: (for B643 being Nat holds S21[ B643 ]) from NAT_1:sch 2(L460 , L437);
L462: (for B644 being set holds (B644 in ( NAT ) implies ( C134 . B644 ) = ( C136 . B644 ))) by L461;
L463: C134 = C136 by L462 , PBOOLE:3;
reconsider D39 = C148 as  Boolean  gate`2=den  strict (Circuit of F114()) by L463 , L420 , L414 , L457 , L458 , L459;
take D39;
take C136;
take C137;
take C138;
thus L464: (F114() = ( C136 . F120() ) & D39 = ( C137 . F120() ) & ( C136 . ( 0 ) ) = F113() & ( C137 . ( 0 ) ) = F115() & ( C138 . ( 0 ) ) = F118()) by L420 , L414 , L461 , L458;
let C149 being Nat;
let C150 being non  empty ManySortedSign;
let C151 being  non-empty MSAlgebra over C150;
let C152 being set;
let C153 being  non-empty MSAlgebra over F116(C152 , C149);
assume L465: (C150 = ( C136 . C149 ) & C151 = ( C137 . C149 ) & C152 = ( C138 . C149 ) & C153 = F117(C152 , C149));
L466: C153 = ( MSAlg (C153 , F116(C152 , C149)) ) by L410;
thus L467: thesis by L466 , L421 , L465;
end;
scheme CIRCCMB29sch21 { F121() -> non  empty ManySortedSign , F122() ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign , F123() ->  non-empty MSAlgebra over F121() , F124() -> set , F125(set , set , set) -> non  empty ManySortedSign , F126(set , set , set , set) -> set , F127(set , set) -> set , F128() -> Nat } : (for B645 , B646 being  Boolean  gate`2=den  strict (Circuit of F122()) holds (((ex B647 , B648 , B649 being (ManySortedSet of ( NAT )) st (F122() = ( B647 . F128() ) & B645 = ( B648 . F128() ) & ( B647 . ( 0 ) ) = F121() & ( B648 . ( 0 ) ) = F123() & ( B649 . ( 0 ) ) = F124() & (for B650 being Nat holds (for B651 being non  empty ManySortedSign holds (for B652 being  non-empty MSAlgebra over B651 holds (for B653 being set holds ((B651 = ( B647 . B650 ) & B652 = ( B648 . B650 ) & B653 = ( B649 . B650 )) implies (( B647 . ( B650 + 1 ) ) = F125(B651 , B653 , B650) & ( B648 . ( B650 + 1 ) ) = F126(B651 , B652 , B653 , B650) & ( B649 . ( B650 + 1 ) ) = F127(B653 , B650))))))))) & (ex B654 , B655 , B656 being (ManySortedSet of ( NAT )) st (F122() = ( B654 . F128() ) & B646 = ( B655 . F128() ) & ( B654 . ( 0 ) ) = F121() & ( B655 . ( 0 ) ) = F123() & ( B656 . ( 0 ) ) = F124() & (for B657 being Nat holds (for B658 being non  empty ManySortedSign holds (for B659 being  non-empty MSAlgebra over B658 holds (for B660 being set holds ((B658 = ( B654 . B657 ) & B659 = ( B655 . B657 ) & B660 = ( B656 . B657 )) implies (( B654 . ( B657 + 1 ) ) = F125(B658 , B660 , B657) & ( B655 . ( B657 + 1 ) ) = F126(B658 , B659 , B660 , B657) & ( B656 . ( B657 + 1 ) ) = F127(B660 , B657)))))))))) implies B645 = B646))
provided
L468: (for B661 being non  empty ManySortedSign holds (for B662 being  non-empty MSAlgebra over B661 holds (for B663 being set holds (for B664 being Nat holds F126(B661 , B662 , B663 , B664) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F125(B661 , B663 , B664)))))
proof
L469: (for B665 being non  empty ManySortedSign holds (for B666 being  non-empty MSAlgebra over B665 holds (for B667 being set holds (for B668 being Nat holds F126(B665 , B666 , B667 , B668) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over F125(B665 , B667 , B668))))) by L468;
L470: (for B669 , B670 being  non-empty MSAlgebra over F122() holds (((ex B671 , B672 , B673 being (ManySortedSet of ( NAT )) st (F122() = ( B671 . F128() ) & B669 = ( B672 . F128() ) & ( B671 . ( 0 ) ) = F121() & ( B672 . ( 0 ) ) = F123() & ( B673 . ( 0 ) ) = F124() & (for B674 being Nat holds (for B675 being non  empty ManySortedSign holds (for B676 being  non-empty MSAlgebra over B675 holds (for B677 being set holds ((B675 = ( B671 . B674 ) & B676 = ( B672 . B674 ) & B677 = ( B673 . B674 )) implies (( B671 . ( B674 + 1 ) ) = F125(B675 , B677 , B674) & ( B672 . ( B674 + 1 ) ) = F126(B675 , B676 , B677 , B674) & ( B673 . ( B674 + 1 ) ) = F127(B677 , B674))))))))) & (ex B678 , B679 , B680 being (ManySortedSet of ( NAT )) st (F122() = ( B678 . F128() ) & B670 = ( B679 . F128() ) & ( B678 . ( 0 ) ) = F121() & ( B679 . ( 0 ) ) = F123() & ( B680 . ( 0 ) ) = F124() & (for B681 being Nat holds (for B682 being non  empty ManySortedSign holds (for B683 being  non-empty MSAlgebra over B682 holds (for B684 being set holds ((B682 = ( B678 . B681 ) & B683 = ( B679 . B681 ) & B684 = ( B680 . B681 )) implies (( B678 . ( B681 + 1 ) ) = F125(B682 , B684 , B681) & ( B679 . ( B681 + 1 ) ) = F126(B682 , B683 , B684 , B681) & ( B680 . ( B681 + 1 ) ) = F127(B684 , B681)))))))))) implies B669 = B670)) from CIRCCMB29sch18(L469);
thus L471: thesis by L470;
end;
begin
theorem
L472: (for B685 , B686 , B687 being non  void  Circuit-like non  empty ManySortedSign holds ((( InnerVertices B685 ) misses ( InputVertices B686 ) & B687 = ( B685 +* B686 )) implies (for B688 being  non-empty (Circuit of B685) holds (for B689 being  non-empty (Circuit of B686) holds (for B690 being  non-empty (Circuit of B687) holds ((B688 tolerates B689 & B690 = ( B688 +* B689 )) implies (for B691 being (State of B689) holds (for B692 being (State of B690) holds (B691 = ( B692 | (the carrier of B686) ) implies ( Following B691 ) = ( ( Following B692 ) | (the carrier of B686) ))))))))))
proof
let C154 , C155 , C156 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L473: (( InnerVertices C154 ) misses ( InputVertices C155 ) & C156 = ( C154 +* C155 ));
let C157 being  non-empty (Circuit of C154);
let C158 being  non-empty (Circuit of C155);
let C159 being  non-empty (Circuit of C156);
assume that
L474: C157 tolerates C158
and
L475: C159 = ( C157 +* C158 );
let C160 being (State of C158);
let C161 being (State of C159);
assume that
L476: C160 = ( C161 | (the carrier of C155) );
L477: (the Sorts of C157) tolerates (the Sorts of C158) by L474 , CIRCCOMB:def 3;
reconsider D40 = ( C161 | (the carrier of C154) ) as (State of C157) by L477 , L475 , CIRCCOMB:26;
L478: (( dom ( Following C160 ) ) = (the carrier of C155) & ( Following C161 ) = ( ( Following D40 ) +* ( Following C160 ) )) by L473 , L474 , L475 , L476 , CIRCCOMB:32 , CIRCUIT1:3;
thus L479: thesis by L478 , FUNCT_4:23;
end;
theorem
L480: (for B693 , B694 , B695 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B693 ) misses ( InnerVertices B694 ) & B695 = ( B693 +* B694 )) implies (for B696 being  non-empty (Circuit of B693) holds (for B697 being  non-empty (Circuit of B694) holds (for B698 being  non-empty (Circuit of B695) holds ((B696 tolerates B697 & B698 = ( B696 +* B697 )) implies (for B699 being (State of B696) holds (for B700 being (State of B698) holds (B699 = ( B700 | (the carrier of B693) ) implies ( Following B699 ) = ( ( Following B700 ) | (the carrier of B693) ))))))))))
proof
let C162 , C163 , C164 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L481: (( InputVertices C162 ) misses ( InnerVertices C163 ) & C164 = ( C162 +* C163 ));
let C165 being  non-empty (Circuit of C162);
let C166 being  non-empty (Circuit of C163);
let C167 being  non-empty (Circuit of C164);
assume that
L482: C165 tolerates C166
and
L483: C167 = ( C165 +* C166 );
let C168 being (State of C165);
let C169 being (State of C167);
assume that
L484: C168 = ( C169 | (the carrier of C162) );
L485: (the Sorts of C165) tolerates (the Sorts of C166) by L482 , CIRCCOMB:def 3;
reconsider D41 = ( C169 | (the carrier of C163) ) as (State of C166) by L485 , L483 , CIRCCOMB:26;
L486: (( dom ( Following C168 ) ) = (the carrier of C162) & ( Following C169 ) = ( ( Following D41 ) +* ( Following C168 ) )) by L481 , L482 , L483 , L484 , CIRCCOMB:33 , CIRCUIT1:3;
thus L487: thesis by L486 , FUNCT_4:23;
end;
theorem
L488: (for B701 , B702 , B703 being non  void  Circuit-like non  empty ManySortedSign holds ((( InnerVertices B701 ) misses ( InputVertices B702 ) & B703 = ( B701 +* B702 )) implies (for B704 being  non-empty (Circuit of B701) holds (for B705 being  non-empty (Circuit of B702) holds (for B706 being  non-empty (Circuit of B703) holds ((B704 tolerates B705 & B706 = ( B704 +* B705 )) implies (for B707 being (State of B704) holds (for B708 being (State of B705) holds (for B709 being (State of B706) holds ((B707 = ( B709 | (the carrier of B701) ) & B708 = ( B709 | (the carrier of B702) ) & B707 is  stable & B708 is  stable) implies B709 is  stable))))))))))
proof
let C170 , C171 , C172 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L489: ( InnerVertices C170 ) misses ( InputVertices C171 )
and
L490: C172 = ( C170 +* C171 );
let C173 being  non-empty (Circuit of C170);
let C174 being  non-empty (Circuit of C171);
let C175 being  non-empty (Circuit of C172);
assume that
L491: (C173 tolerates C174 & C175 = ( C173 +* C174 ));
let C176 being (State of C173);
let C177 being (State of C174);
let C178 being (State of C175);
assume that
L492: (C176 = ( C178 | (the carrier of C170) ) & C177 = ( C178 | (the carrier of C171) ))
and
L493: C176 is  stable
and
L494: C177 is  stable;
L495: (( dom C178 ) = (the carrier of C172) & (the carrier of C172) = ( (the carrier of C170) \/ (the carrier of C171) )) by L490 , CIRCCOMB:def 2 , CIRCUIT1:3;
L496: C178 = ( C176 +* C177 ) by L495 , L492 , FUNCT_4:70;
L497: C178 = ( ( Following C176 ) +* C177 ) by L496 , L493 , CIRCUIT2:def 6
.= ( ( Following C176 ) +* ( Following C177 ) ) by L494 , CIRCUIT2:def 6
.= ( Following C178 ) by L489 , L490 , L491 , L492 , CIRCCOMB:32;
thus L498: C178 = ( Following C178 ) by L497;
end;
theorem
L499: (for B710 , B711 , B712 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B710 ) misses ( InnerVertices B711 ) & B712 = ( B710 +* B711 )) implies (for B713 being  non-empty (Circuit of B710) holds (for B714 being  non-empty (Circuit of B711) holds (for B715 being  non-empty (Circuit of B712) holds ((B713 tolerates B714 & B715 = ( B713 +* B714 )) implies (for B716 being (State of B713) holds (for B717 being (State of B714) holds (for B718 being (State of B715) holds ((B716 = ( B718 | (the carrier of B710) ) & B717 = ( B718 | (the carrier of B711) ) & B716 is  stable & B717 is  stable) implies B718 is  stable))))))))))
proof
let C179 , C180 , C181 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L500: ( InputVertices C179 ) misses ( InnerVertices C180 )
and
L501: C181 = ( C179 +* C180 );
let C182 being  non-empty (Circuit of C179);
let C183 being  non-empty (Circuit of C180);
let C184 being  non-empty (Circuit of C181);
assume that
L502: (C182 tolerates C183 & C184 = ( C182 +* C183 ));
let C185 being (State of C182);
let C186 being (State of C183);
let C187 being (State of C184);
assume that
L503: (C185 = ( C187 | (the carrier of C179) ) & C186 = ( C187 | (the carrier of C180) ))
and
L504: C185 is  stable
and
L505: C186 is  stable;
L506: (( dom C187 ) = (the carrier of C181) & (the carrier of C181) = ( (the carrier of C179) \/ (the carrier of C180) )) by L501 , CIRCCOMB:def 2 , CIRCUIT1:3;
L507: C187 = ( C186 +* C185 ) by L506 , L503 , FUNCT_4:70;
L508: C187 = ( ( Following C186 ) +* C185 ) by L507 , L505 , CIRCUIT2:def 6
.= ( ( Following C186 ) +* ( Following C185 ) ) by L504 , CIRCUIT2:def 6
.= ( Following C187 ) by L500 , L501 , L502 , L503 , CIRCCOMB:33;
thus L509: C187 = ( Following C187 ) by L508;
end;
theorem
L510: (for B719 , B720 , B721 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B719 ) misses ( InnerVertices B720 ) & B721 = ( B719 +* B720 )) implies (for B722 being  non-empty (Circuit of B719) holds (for B723 being  non-empty (Circuit of B720) holds (for B724 being  non-empty (Circuit of B721) holds ((B722 tolerates B723 & B724 = ( B722 +* B723 )) implies (for B725 being (State of B724) holds (for B726 being (State of B722) holds (B726 = ( B725 | (the carrier of B719) ) implies (for B727 being Nat holds ( ( Following (B725 , B727) ) | (the carrier of B719) ) = ( Following (B726 , B727) )))))))))))
proof
let C188 , C189 , C190 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L511: (( InputVertices C188 ) misses ( InnerVertices C189 ) & C190 = ( C188 +* C189 ));
let C191 being  non-empty (Circuit of C188);
let C192 being  non-empty (Circuit of C189);
let C193 being  non-empty (Circuit of C190);
assume that
L512: (C191 tolerates C192 & C193 = ( C191 +* C192 ));
let C194 being (State of C193);
let C195 being (State of C191);
assume that
L513: C195 = ( C194 | (the carrier of C188) );
defpred S23[ Nat ] means ( ( Following (C194 , $1) ) | (the carrier of C188) ) = ( Following (C195 , $1) );
L514:
now
let C196 being Nat;
L515: (( Following (C194 , ( C196 + 1 )) ) = ( Following ( Following (C194 , C196) ) ) & ( Following ( Following (C195 , C196) ) ) = ( Following (C195 , ( C196 + 1 )) )) by FACIRC_1:12;
assume L516: S23[ C196 ];
thus L517: S23[ ( C196 + 1 ) ] by L516 , L511 , L512 , L515 , L480;
end;
L518: ( ( Following (C194 , ( 0 )) ) | (the carrier of C188) ) = C195 by L513 , FACIRC_1:11
.= ( Following (C195 , ( 0 )) ) by FACIRC_1:11;
L519: S23[ ( 0 ) ] by L518;
thus L520: (for B728 being Nat holds S23[ B728 ]) from NAT_1:sch 2(L519 , L514);
end;
theorem
L521: (for B729 , B730 , B731 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B730 ) misses ( InnerVertices B729 ) & B731 = ( B729 +* B730 )) implies (for B732 being  non-empty (Circuit of B729) holds (for B733 being  non-empty (Circuit of B730) holds (for B734 being  non-empty (Circuit of B731) holds ((B732 tolerates B733 & B734 = ( B732 +* B733 )) implies (for B735 being (State of B734) holds (for B736 being (State of B733) holds (B736 = ( B735 | (the carrier of B730) ) implies (for B737 being Nat holds ( ( Following (B735 , B737) ) | (the carrier of B730) ) = ( Following (B736 , B737) )))))))))))
proof
let C197 , C198 , C199 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L522: ( InputVertices C198 ) misses ( InnerVertices C197 )
and
L523: C199 = ( C197 +* C198 );
let C200 being  non-empty (Circuit of C197);
let C201 being  non-empty (Circuit of C198);
let C202 being  non-empty (Circuit of C199);
assume that
L524: C200 tolerates C201
and
L525: C202 = ( C200 +* C201 );
L526: C197 tolerates C198 by L524 , CIRCCOMB:def 3;
L527: C199 = ( C198 +* C197 ) by L526 , L523 , CIRCCOMB:5;
L528: C202 = ( C201 +* C200 ) by L524 , L525 , CIRCCOMB:22;
thus L529: thesis by L528 , L522 , L524 , L527 , L510 , CIRCCOMB:19;
end;
theorem
L530: (for B738 , B739 , B740 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B738 ) misses ( InnerVertices B739 ) & B740 = ( B738 +* B739 )) implies (for B741 being  non-empty (Circuit of B738) holds (for B742 being  non-empty (Circuit of B739) holds (for B743 being  non-empty (Circuit of B740) holds ((B741 tolerates B742 & B743 = ( B741 +* B742 )) implies (for B744 being (State of B743) holds (for B745 being (State of B741) holds ((B745 = ( B744 | (the carrier of B738) ) & B745 is  stable) implies (for B746 being (State of B742) holds (B746 = ( B744 | (the carrier of B739) ) implies ( ( Following B744 ) | (the carrier of B739) ) = ( Following B746 ))))))))))))
proof
let C203 , C204 , C205 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L531: ( InputVertices C203 ) misses ( InnerVertices C204 )
and
L532: C205 = ( C203 +* C204 );
L533: (the carrier of C205) = ( (the carrier of C203) \/ (the carrier of C204) ) by L532 , CIRCCOMB:def 2;
let C206 being  non-empty (Circuit of C203);
let C207 being  non-empty (Circuit of C204);
let C208 being  non-empty (Circuit of C205);
assume that
L534: C206 tolerates C207
and
L535: C208 = ( C206 +* C207 );
let C209 being (State of C208);
let C210 being (State of C206);
assume that
L536: C210 = ( C209 | (the carrier of C203) )
and
L537: C210 is  stable;
let C211 being (State of C207);
assume that
L538: C211 = ( C209 | (the carrier of C204) );
L539:
now
let C212 being set;
assume L540: C212 in (the carrier of C204);
reconsider D42 = C212 as (Vertex of C204) by L540;
reconsider D43 = D42 as (Vertex of C205) by L533 , XBOOLE_0:def 3;
L541: ((D42 in ( InputVertices C204 ) & (not D42 in ( InnerVertices C203 ))) implies D42 in ( ( InputVertices C204 ) \ ( InnerVertices C203 ) )) by XBOOLE_0:def 5;
L542: C203 tolerates C204 by L534 , CIRCCOMB:def 3;
L543:
now
assume that
L544: D42 in ( InputVertices C204 )
and
L545: D42 in ( InnerVertices C203 );
reconsider D44 = D42 as (Vertex of C203) by L545;
thus L546: ( ( Following C209 ) . D43 ) = ( ( Following C210 ) . D43 ) by L532 , L534 , L535 , L536 , L545 , CIRCCOMB:31
.= ( C210 . D42 ) by L537 , CIRCUIT2:def 6
.= ( C209 . D44 ) by L536 , FUNCT_1:49
.= ( C211 . D42 ) by L538 , FUNCT_1:49
.= ( ( Following C211 ) . D43 ) by L544 , CIRCUIT2:def 5;
end;
L547: ((the carrier of C204) = ( ( InnerVertices C204 ) \/ ( InputVertices C204 ) ) & ( ( InputVertices C203 ) \ ( InnerVertices C204 ) ) = ( InputVertices C203 )) by L531 , XBOOLE_1:45 , XBOOLE_1:83;
L548: (D42 in ( InnerVertices C204 ) or (D42 in ( InputVertices C204 ) & (D42 in ( InnerVertices C203 ) or (not D42 in ( InnerVertices C203 ))) & ( InputVertices C205 ) = ( ( InputVertices C203 ) \/ ( ( InputVertices C204 ) \ ( InnerVertices C203 ) ) ))) by L547 , L532 , L542 , L129 , XBOOLE_0:def 3;
L549: (D43 in ( InnerVertices C204 ) or D42 in ( InputVertices C205 ) or (D42 in ( InputVertices C204 ) & D42 in ( InnerVertices C203 ))) by L548 , L541 , XBOOLE_0:def 3;
thus L550: ( ( ( Following C209 ) | (the carrier of C204) ) . C212 ) = ( ( Following C209 ) . D42 ) by FUNCT_1:49
.= ( ( Following C211 ) . C212 ) by L532 , L534 , L535 , L538 , L543 , L549 , CIRCCOMB:31;
end;
L551: ( dom ( Following C209 ) ) = (the carrier of C205) by CIRCUIT1:3;
L552: (( dom ( Following C211 ) ) = (the carrier of C204) & ( dom ( ( Following C209 ) | (the carrier of C204) ) ) = (the carrier of C204)) by L551 , L533 , CIRCUIT1:3 , RELAT_1:62 , XBOOLE_1:7;
thus L553: thesis by L552 , L539 , FUNCT_1:2;
end;
theorem
L554: (for B747 , B748 , B749 being non  void  Circuit-like non  empty ManySortedSign holds (B749 = ( B747 +* B748 ) implies (for B750 being  non-empty (Circuit of B747) holds (for B751 being  non-empty (Circuit of B748) holds (for B752 being  non-empty (Circuit of B749) holds ((B750 tolerates B751 & B752 = ( B750 +* B751 )) implies (for B753 being (State of B752) holds (for B754 being (State of B750) holds ((B754 = ( B753 | (the carrier of B747) ) & B754 is  stable) implies (for B755 being (State of B751) holds ((B755 = ( B753 | (the carrier of B748) ) & B755 is  stable) implies B753 is  stable)))))))))))
proof
let C213 , C214 , C215 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L555: C215 = ( C213 +* C214 );
let C216 being  non-empty (Circuit of C213);
let C217 being  non-empty (Circuit of C214);
let C218 being  non-empty (Circuit of C215);
assume that
L556: C216 tolerates C217
and
L557: C218 = ( C216 +* C217 );
L558: C213 tolerates C214 by L556 , CIRCCOMB:def 3;
L559: ( InnerVertices C215 ) = ( ( InnerVertices C213 ) \/ ( InnerVertices C214 ) ) by L558 , L555 , CIRCCOMB:11;
let C219 being (State of C218);
let C220 being (State of C216);
assume that
L560: C220 = ( C219 | (the carrier of C213) )
and
L561: C220 = ( Following C220 );
let C221 being (State of C217);
assume that
L562: C221 = ( C219 | (the carrier of C214) )
and
L563: C221 = ( Following C221 );
L564: (the carrier of C215) = ( (the carrier of C213) \/ (the carrier of C214) ) by L555 , CIRCCOMB:def 2;
L565:
now
let C222 being set;
assume L566: C222 in (the carrier of C215);
reconsider D45 = C222 as (Vertex of C215) by L566;
L567: (the carrier of C215) = ( ( InputVertices C215 ) \/ ( InnerVertices C215 ) ) by XBOOLE_1:45;
L568: (D45 in ( InputVertices C215 ) or D45 in ( InnerVertices C215 )) by L567 , XBOOLE_0:def 3;
L569: ((D45 in ( InputVertices C215 ) & D45 in (the carrier of C213)) or (D45 in ( InputVertices C215 ) & D45 in (the carrier of C214)) or D45 in ( InnerVertices C213 ) or D45 in ( InnerVertices C214 )) by L568 , L559 , L564 , XBOOLE_0:def 3;
L570: ((( ( Following C219 ) . D45 ) = ( C220 . D45 ) & D45 in (the carrier of C213)) or (( ( Following C219 ) . D45 ) = ( C221 . D45 ) & D45 in (the carrier of C214))) by L569 , L555 , L556 , L557 , L560 , L561 , L562 , L563 , CIRCCOMB:31;
thus L571: ( C219 . C222 ) = ( ( Following C219 ) . C222 ) by L570 , L560 , L562 , FUNCT_1:49;
end;
L572: (( dom ( Following C219 ) ) = (the carrier of C215) & ( dom C219 ) = (the carrier of C215)) by CIRCUIT1:3;
thus L573: C219 = ( Following C219 ) by L572 , L565 , FUNCT_1:2;
end;
theorem
L574: (for B756 , B757 , B758 being non  void  Circuit-like non  empty ManySortedSign holds (B758 = ( B756 +* B757 ) implies (for B759 being  non-empty (Circuit of B756) holds (for B760 being  non-empty (Circuit of B757) holds (for B761 being  non-empty (Circuit of B758) holds ((B759 tolerates B760 & B761 = ( B759 +* B760 )) implies (for B762 being (State of B761) holds (B762 is  stable implies ((for B763 being (State of B759) holds (B763 = ( B762 | (the carrier of B756) ) implies B763 is  stable)) & (for B764 being (State of B760) holds (B764 = ( B762 | (the carrier of B757) ) implies B764 is  stable)))))))))))
proof
let C223 , C224 , C225 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L575: C225 = ( C223 +* C224 );
L576: (the carrier of C225) = ( (the carrier of C223) \/ (the carrier of C224) ) by L575 , CIRCCOMB:def 2;
let C226 being  non-empty (Circuit of C223);
let C227 being  non-empty (Circuit of C224);
let C228 being  non-empty (Circuit of C225);
assume that
L577: (C226 tolerates C227 & C228 = ( C226 +* C227 ));
let C229 being (State of C228);
assume that
L578: C229 = ( Following C229 );
thus L579:now
let C230 being (State of C226);
assume that
L580: C230 = ( C229 | (the carrier of C223) );
L581:
now
let C231 being set;
assume L582: C231 in (the carrier of C223);
reconsider D46 = C231 as (Vertex of C223) by L582;
reconsider D47 = D46 as (Vertex of C225) by L576 , XBOOLE_0:def 3;
L583: (the carrier of C223) = ( ( InputVertices C223 ) \/ ( InnerVertices C223 ) ) by XBOOLE_1:45;
L584: (D46 in ( InputVertices C223 ) or D47 in ( InnerVertices C223 )) by L583 , XBOOLE_0:def 3;
L585: (( C230 . D46 ) = ( ( Following C230 ) . D46 ) or ( C229 . D47 ) = ( ( Following C230 ) . D46 )) by L584 , L575 , L577 , L578 , L580 , CIRCCOMB:31 , CIRCUIT2:def 5;
thus L586: ( C230 . C231 ) = ( ( Following C230 ) . C231 ) by L585 , L580 , FUNCT_1:49;
end;
L587: (( dom C230 ) = (the carrier of C223) & ( dom ( Following C230 ) ) = (the carrier of C223)) by CIRCUIT1:3;
L588: C230 = ( Following C230 ) by L587 , L581 , FUNCT_1:2;
thus L589: C230 is  stable by L588 , CIRCUIT2:def 6;
end;
let C232 being (State of C227);
assume that
L590: C232 = ( C229 | (the carrier of C224) );
L591:
now
let C233 being set;
assume L592: C233 in (the carrier of C224);
reconsider D48 = C233 as (Vertex of C224) by L592;
reconsider D49 = D48 as (Vertex of C225) by L576 , XBOOLE_0:def 3;
L593: (the carrier of C224) = ( ( InputVertices C224 ) \/ ( InnerVertices C224 ) ) by XBOOLE_1:45;
L594: (D48 in ( InputVertices C224 ) or D49 in ( InnerVertices C224 )) by L593 , XBOOLE_0:def 3;
L595: (( C232 . D48 ) = ( ( Following C232 ) . D48 ) or ( C229 . D49 ) = ( ( Following C232 ) . D48 )) by L594 , L575 , L577 , L578 , L590 , CIRCCOMB:31 , CIRCUIT2:def 5;
thus L596: ( C232 . C233 ) = ( ( Following C232 ) . C233 ) by L595 , L590 , FUNCT_1:49;
end;
L597: (( dom C232 ) = (the carrier of C224) & ( dom ( Following C232 ) ) = (the carrier of C224)) by CIRCUIT1:3;
thus L598: C232 = ( Following C232 ) by L597 , L591 , FUNCT_1:2;
end;
theorem
L599: (for B765 , B766 , B767 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B765 ) misses ( InnerVertices B766 ) & B767 = ( B765 +* B766 )) implies (for B768 being  non-empty (Circuit of B765) holds (for B769 being  non-empty (Circuit of B766) holds (for B770 being  non-empty (Circuit of B767) holds ((B768 tolerates B769 & B770 = ( B768 +* B769 )) implies (for B771 being (State of B768) holds (for B772 being (State of B769) holds (for B773 being (State of B770) holds ((B771 = ( B773 | (the carrier of B765) ) & B772 = ( B773 | (the carrier of B766) ) & B771 is  stable) implies (for B774 being Nat holds ( ( Following (B773 , B774) ) | (the carrier of B766) ) = ( Following (B772 , B774) ))))))))))))
proof
let C234 , C235 , C236 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L600: (( InputVertices C234 ) misses ( InnerVertices C235 ) & C236 = ( C234 +* C235 ));
let C237 being  non-empty (Circuit of C234);
let C238 being  non-empty (Circuit of C235);
let C239 being  non-empty (Circuit of C236);
assume that
L601: C237 tolerates C238
and
L602: C239 = ( C237 +* C238 );
let C240 being (State of C237);
let C241 being (State of C238);
let C242 being (State of C239);
assume that
L603: C240 = ( C242 | (the carrier of C234) )
and
L604: C241 = ( C242 | (the carrier of C235) )
and
L605: C240 is  stable;
defpred S24[ Nat ] means ( ( Following (C242 , $1) ) | (the carrier of C235) ) = ( Following (C241 , $1) );
L606:
now
let C243 being Nat;
L607: (( Following (C242 , ( C243 + 1 )) ) = ( Following ( Following (C242 , C243) ) ) & ( Following ( Following (C241 , C243) ) ) = ( Following (C241 , ( C243 + 1 )) )) by FACIRC_1:12;
L608: (the Sorts of C237) tolerates (the Sorts of C238) by L601 , CIRCCOMB:def 3;
reconsider D50 = ( ( Following (C242 , C243) ) | (the carrier of C234) ) as (State of C237) by L608 , L602 , CIRCCOMB:26;
L609: ( Following (C240 , C243) ) = D50 by L600 , L601 , L602 , L603 , L510;
L610: D50 is  stable by L609 , L605 , L25;
assume L611: S24[ C243 ];
thus L612: S24[ ( C243 + 1 ) ] by L611 , L600 , L601 , L602 , L607 , L610 , L530;
end;
L613: ( ( Following (C242 , ( 0 )) ) | (the carrier of C235) ) = C241 by L604 , FACIRC_1:11
.= ( Following (C241 , ( 0 )) ) by FACIRC_1:11;
L614: S24[ ( 0 ) ] by L613;
thus L615: (for B775 being Nat holds S24[ B775 ]) from NAT_1:sch 2(L614 , L606);
end;
theorem
L616: (for B776 , B777 , B778 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B776 ) misses ( InnerVertices B777 ) & B778 = ( B776 +* B777 )) implies (for B779 being  non-empty (Circuit of B776) holds (for B780 being  non-empty (Circuit of B777) holds (for B781 being  non-empty (Circuit of B778) holds ((B779 tolerates B780 & B781 = ( B779 +* B780 )) implies (for B782 , B783 being Nat holds (for B784 being (State of B781) holds (for B785 being (State of B779) holds (for B786 being (State of B780) holds ((B785 = ( B784 | (the carrier of B776) ) & ( Following (B785 , B782) ) is  stable & B786 = ( ( Following (B784 , B782) ) | (the carrier of B777) ) & ( Following (B786 , B783) ) is  stable) implies ( Following (B784 , ( B782 + B783 )) ) is  stable)))))))))))
proof
let C244 , C245 , C246 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L617: ( InputVertices C244 ) misses ( InnerVertices C245 )
and
L618: C246 = ( C244 +* C245 );
let C247 being  non-empty (Circuit of C244);
let C248 being  non-empty (Circuit of C245);
let C249 being  non-empty (Circuit of C246);
assume that
L619: C247 tolerates C248
and
L620: C249 = ( C247 +* C248 );
let C250 , C251 being Nat;
let C252 being (State of C249);
let C253 being (State of C247);
let C254 being (State of C248);
assume that
L621: (C253 = ( C252 | (the carrier of C244) ) & ( Following (C253 , C250) ) is  stable)
and
L622: (C254 = ( ( Following (C252 , C250) ) | (the carrier of C245) ) & ( Following (C254 , C251) ) is  stable);
L623: (the Sorts of C247) tolerates (the Sorts of C248) by L619 , CIRCCOMB:def 3;
reconsider D51 = ( ( Following (C252 , C250) ) | (the carrier of C244) ) , D52 = ( C252 | (the carrier of C244) ) as (State of C247) by L623 , L620 , CIRCCOMB:26;
L624: ( Following (( Following (C252 , C250) ) , C251) ) = ( Following (C252 , ( C250 + C251 )) ) by FACIRC_1:13;
L625: ( ( Following (C252 , ( C250 + C251 )) ) | (the carrier of C244) ) = ( Following (D51 , C251) ) by L624 , L617 , L618 , L619 , L620 , L510;
reconsider D53 = ( ( Following (C252 , C250) ) | (the carrier of C245) ) as (State of C248) by L620 , L623 , CIRCCOMB:26;
L626: ( dom ( Following (C252 , ( C250 + C251 )) ) ) = (the carrier of C246) by CIRCUIT1:3;
L627: (the carrier of C246) = ( (the carrier of C244) \/ (the carrier of C245) ) by L618 , CIRCCOMB:def 2;
L628: D51 = ( Following (D52 , C250) ) by L617 , L618 , L619 , L620 , L510;
L629: ( ( Following (C252 , ( C250 + C251 )) ) | (the carrier of C245) ) = ( Following (D53 , C251) ) by L628 , L617 , L618 , L619 , L620 , L621 , L624 , L599;
L630: ( Following ( Following (C252 , ( C250 + C251 )) ) ) = ( ( Following ( Following (D53 , C251) ) ) +* ( Following ( Following (D51 , C251) ) ) ) by L629 , L617 , L618 , L619 , L620 , L625 , CIRCCOMB:33
.= ( ( Following (D53 , C251) ) +* ( Following ( Following (D51 , C251) ) ) ) by L622 , CIRCUIT2:def 6
.= ( ( Following (D53 , C251) ) +* ( Following (D51 , ( C251 + 1 )) ) ) by FACIRC_1:12
.= ( ( Following (D53 , C251) ) +* D51 ) by L621 , L628 , L25
.= ( ( Following (D53 , C251) ) +* ( Following (D51 , C251) ) ) by L621 , L628 , L25
.= ( Following (C252 , ( C250 + C251 )) ) by L627 , L626 , L625 , L629 , FUNCT_4:70;
thus L631: thesis by L630 , CIRCUIT2:def 6;
end;
theorem
L632: (for B787 , B788 , B789 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B787 ) misses ( InnerVertices B788 ) & B789 = ( B787 +* B788 )) implies (for B790 being  non-empty (Circuit of B787) holds (for B791 being  non-empty (Circuit of B788) holds (for B792 being  non-empty (Circuit of B789) holds ((B790 tolerates B791 & B792 = ( B790 +* B791 )) implies (for B793 , B794 being Nat holds (((for B795 being (State of B790) holds ( Following (B795 , B793) ) is  stable) & (for B796 being (State of B791) holds ( Following (B796 , B794) ) is  stable)) implies (for B797 being (State of B792) holds ( Following (B797 , ( B793 + B794 )) ) is  stable)))))))))
proof
let C255 , C256 , C257 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L633: (( InputVertices C255 ) misses ( InnerVertices C256 ) & C257 = ( C255 +* C256 ));
let C258 being  non-empty (Circuit of C255);
let C259 being  non-empty (Circuit of C256);
let C260 being  non-empty (Circuit of C257);
assume that
L634: C258 tolerates C259
and
L635: C260 = ( C258 +* C259 );
let C261 , C262 being Nat;
assume that
L636: ((for B798 being (State of C258) holds ( Following (B798 , C261) ) is  stable) & (for B799 being (State of C259) holds ( Following (B799 , C262) ) is  stable));
let C263 being (State of C260);
L637: (the Sorts of C258) tolerates (the Sorts of C259) by L634 , CIRCCOMB:def 3;
reconsider D54 = ( C263 | (the carrier of C255) ) as (State of C258) by L637 , L635 , CIRCCOMB:26;
reconsider D55 = ( ( Following (C263 , C261) ) | (the carrier of C256) ) as (State of C259) by L635 , L637 , CIRCCOMB:26;
L638: (( Following (D54 , C261) ) is  stable & ( Following (D55 , C262) ) is  stable) by L636;
thus L639: thesis by L638 , L633 , L634 , L635 , L616;
end;
theorem
L640: (for B800 , B801 , B802 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B800 ) misses ( InnerVertices B801 ) & ( InputVertices B801 ) misses ( InnerVertices B800 ) & B802 = ( B800 +* B801 )) implies (for B803 being  non-empty (Circuit of B800) holds (for B804 being  non-empty (Circuit of B801) holds (for B805 being  non-empty (Circuit of B802) holds ((B803 tolerates B804 & B805 = ( B803 +* B804 )) implies (for B806 being (State of B805) holds (for B807 being (State of B803) holds (B807 = ( B806 | (the carrier of B800) ) implies (for B808 being (State of B804) holds (B808 = ( B806 | (the carrier of B801) ) implies (for B809 being Nat holds ( Following (B806 , B809) ) = ( ( Following (B807 , B809) ) +* ( Following (B808 , B809) ) )))))))))))))
proof
let C264 , C265 , C266 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L641: ( InputVertices C264 ) misses ( InnerVertices C265 )
and
L642: ( InputVertices C265 ) misses ( InnerVertices C264 )
and
L643: C266 = ( C264 +* C265 );
let C267 being  non-empty (Circuit of C264);
let C268 being  non-empty (Circuit of C265);
let C269 being  non-empty (Circuit of C266);
assume that
L644: C267 tolerates C268
and
L645: C269 = ( C267 +* C268 );
let C270 being (State of C269);
let C271 being (State of C267);
assume that
L646: C271 = ( C270 | (the carrier of C264) );
let C272 being (State of C268);
assume that
L647: C272 = ( C270 | (the carrier of C265) );
let C273 being Nat;
L648: ( ( Following (C270 , C273) ) | (the carrier of C264) ) = ( Following (C271 , C273) ) by L641 , L643 , L644 , L645 , L646 , L510;
L649: (( dom ( Following (C270 , C273) ) ) = (the carrier of C266) & (the carrier of C266) = ( (the carrier of C264) \/ (the carrier of C265) )) by L643 , CIRCCOMB:def 2 , CIRCUIT1:3;
L650: C264 tolerates C265 by L644 , CIRCCOMB:def 3;
L651: ( C264 +* C265 ) = ( C265 +* C264 ) by L650 , CIRCCOMB:5;
L652: ( C267 +* C268 ) = ( C268 +* C267 ) by L644 , CIRCCOMB:22;
L653: ( ( Following (C270 , C273) ) | (the carrier of C265) ) = ( Following (C272 , C273) ) by L652 , L642 , L643 , L644 , L645 , L647 , L651 , L510 , CIRCCOMB:19;
thus L654: thesis by L653 , L648 , L649 , FUNCT_4:70;
end;
theorem
L655: (for B810 , B811 , B812 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B810 ) misses ( InnerVertices B811 ) & ( InputVertices B811 ) misses ( InnerVertices B810 ) & B812 = ( B810 +* B811 )) implies (for B813 being  non-empty (Circuit of B810) holds (for B814 being  non-empty (Circuit of B811) holds (for B815 being  non-empty (Circuit of B812) holds ((B813 tolerates B814 & B815 = ( B813 +* B814 )) implies (for B816 , B817 being Nat holds (for B818 being (State of B815) holds (for B819 being (State of B813) holds (B819 = ( B818 | (the carrier of B810) ) implies (for B820 being (State of B814) holds ((B820 = ( B818 | (the carrier of B811) ) & ( Following (B819 , B816) ) is  stable & ( Following (B820 , B817) ) is  stable) implies ( Following (B818 , ( max (B816 , B817) )) ) is  stable))))))))))))
proof
let C274 , C275 , C276 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L656: ( InputVertices C274 ) misses ( InnerVertices C275 )
and
L657: ( InputVertices C275 ) misses ( InnerVertices C274 )
and
L658: C276 = ( C274 +* C275 );
let C277 being  non-empty (Circuit of C274);
let C278 being  non-empty (Circuit of C275);
let C279 being  non-empty (Circuit of C276);
assume that
L659: C277 tolerates C278
and
L660: C279 = ( C277 +* C278 );
let C280 , C281 being Nat;
let C282 being (State of C279);
set D56 = ( max (C280 , C281) );
let C283 being (State of C277);
assume that
L661: C283 = ( C282 | (the carrier of C274) );
L662: ( ( Following (C282 , D56) ) | (the carrier of C274) ) = ( Following (C283 , D56) ) by L656 , L658 , L659 , L660 , L661 , L510;
L663: C274 tolerates C275 by L659 , CIRCCOMB:def 3;
L664: ( C274 +* C275 ) = ( C275 +* C274 ) by L663 , CIRCCOMB:5;
let C284 being (State of C278);
assume that
L665: C284 = ( C282 | (the carrier of C275) )
and
L666: ( Following (C283 , C280) ) is  stable
and
L667: ( Following (C284 , C281) ) is  stable;
L668: ( C277 +* C278 ) = ( C278 +* C277 ) by L659 , CIRCCOMB:22;
L669: ( ( Following (C282 , D56) ) | (the carrier of C275) ) = ( Following (C284 , D56) ) by L668 , L657 , L658 , L659 , L660 , L665 , L664 , L510 , CIRCCOMB:19;
L670: ( Following (C284 , D56) ) is  stable by L667 , L33 , XXREAL_0:25;
L671: ( Following (C283 , D56) ) is  stable by L666 , L33 , XXREAL_0:25;
thus L672: ( Following (C282 , ( max (C280 , C281) )) ) = ( ( Following (C283 , D56) ) +* ( Following (C284 , D56) ) ) by L656 , L657 , L658 , L659 , L660 , L661 , L665 , L640
.= ( ( Following ( Following (C283 , D56) ) ) +* ( Following (C284 , D56) ) ) by L671 , CIRCUIT2:def 6
.= ( ( Following ( Following (C283 , D56) ) ) +* ( Following ( Following (C284 , D56) ) ) ) by L670 , CIRCUIT2:def 6
.= ( Following ( Following (C282 , D56) ) ) by L657 , L658 , L659 , L660 , L662 , L669 , CIRCCOMB:32;
end;
theorem
L673: (for B821 , B822 , B823 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B821 ) misses ( InnerVertices B822 ) & ( InputVertices B822 ) misses ( InnerVertices B821 ) & B823 = ( B821 +* B822 )) implies (for B824 being  non-empty (Circuit of B821) holds (for B825 being  non-empty (Circuit of B822) holds (for B826 being  non-empty (Circuit of B823) holds ((B824 tolerates B825 & B826 = ( B824 +* B825 )) implies (for B827 being Nat holds (for B828 being (State of B826) holds (for B829 being (State of B824) holds (B829 = ( B828 | (the carrier of B821) ) implies (for B830 being (State of B825) holds ((B830 = ( B828 | (the carrier of B822) ) & ((not ( Following (B829 , B827) ) is  stable) or (not ( Following (B830 , B827) ) is  stable))) implies (not ( Following (B828 , B827) ) is  stable)))))))))))))
proof
let C285 , C286 , C287 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L674: ( InputVertices C285 ) misses ( InnerVertices C286 )
and
L675: ( InputVertices C286 ) misses ( InnerVertices C285 )
and
L676: C287 = ( C285 +* C286 );
let C288 being  non-empty (Circuit of C285);
let C289 being  non-empty (Circuit of C286);
let C290 being  non-empty (Circuit of C287);
assume that
L677: (C288 tolerates C289 & C290 = ( C288 +* C289 ));
let C291 being Nat;
let C292 being (State of C290);
let C293 being (State of C288);
assume L678: C293 = ( C292 | (the carrier of C285) );
L679: ( ( Following (C292 , C291) ) | (the carrier of C285) ) = ( Following (C293 , C291) ) by L678 , L674 , L676 , L677 , L510;
let C294 being (State of C289);
assume that
L680: C294 = ( C292 | (the carrier of C286) )
and
L681: ((not ( Following (C293 , C291) ) is  stable) or (not ( Following (C294 , C291) ) is  stable));
L682: ( ( Following (C292 , C291) ) | (the carrier of C286) ) = ( Following (C294 , C291) ) by L675 , L676 , L677 , L680 , L521;
thus L683: thesis by L682 , L676 , L677 , L681 , L679 , L574;
end;
theorem
L684: (for B831 , B832 , B833 being non  void  Circuit-like non  empty ManySortedSign holds ((( InputVertices B831 ) misses ( InnerVertices B832 ) & ( InputVertices B832 ) misses ( InnerVertices B831 ) & B833 = ( B831 +* B832 )) implies (for B834 being  non-empty (Circuit of B831) holds (for B835 being  non-empty (Circuit of B832) holds (for B836 being  non-empty (Circuit of B833) holds ((B834 tolerates B835 & B836 = ( B834 +* B835 )) implies (for B837 , B838 being Nat holds (((for B839 being (State of B834) holds ( Following (B839 , B837) ) is  stable) & (for B840 being (State of B835) holds ( Following (B840 , B838) ) is  stable)) implies (for B841 being (State of B836) holds ( Following (B841 , ( max (B837 , B838) )) ) is  stable)))))))))
proof
let C295 , C296 , C297 being non  void  Circuit-like non  empty ManySortedSign;
assume that
L685: (( InputVertices C295 ) misses ( InnerVertices C296 ) & ( InputVertices C296 ) misses ( InnerVertices C295 ) & C297 = ( C295 +* C296 ));
let C298 being  non-empty (Circuit of C295);
let C299 being  non-empty (Circuit of C296);
let C300 being  non-empty (Circuit of C297);
assume that
L686: C298 tolerates C299
and
L687: C300 = ( C298 +* C299 );
let C301 , C302 being Nat;
assume that
L688: ((for B842 being (State of C298) holds ( Following (B842 , C301) ) is  stable) & (for B843 being (State of C299) holds ( Following (B843 , C302) ) is  stable));
let C303 being (State of C300);
L689: (the Sorts of C298) tolerates (the Sorts of C299) by L686 , CIRCCOMB:def 3;
reconsider D57 = ( C303 | (the carrier of C295) ) as (State of C298) by L689 , L687 , CIRCCOMB:26;
reconsider D58 = ( C303 | (the carrier of C296) ) as (State of C299) by L687 , L689 , CIRCCOMB:26;
L690: (( Following (D57 , C301) ) is  stable & ( Following (D58 , C302) ) is  stable) by L688;
thus L691: thesis by L690 , L685 , L686 , L687 , L655;
end;
scheme CIRCCMB29sch22 { F129 , F130() ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign , F131() ->  Boolean  gate`2=den  strict (Circuit of F129()) , F132() ->  Boolean  gate`2=den  strict (Circuit of F130()) , F133(set , set) ->  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign , F134(set , set) -> set , F135() -> (ManySortedSet of ( NAT )) , F136() -> set , F137(set , set) -> set , F138(Nat) -> Nat } : (for B844 being (State of F132()) holds ( Following (B844 , ( F138(( 0 )) + ( F138(2) * F138(1) ) )) ) is  stable)
provided
L692: (for B845 being set holds (for B846 being Nat holds F134(B845 , B846) is  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict  Boolean  gate`2=den  strict (Circuit of F133(B845 , B846))))
and
L693: (for B847 being (State of F131()) holds ( Following (B847 , F138(( 0 ))) ) is  stable)
and
L694: (for B848 being Nat holds (for B849 being set holds (for B850 being  non-empty (Circuit of F133(B849 , B848)) holds ((B849 = ( F135() . B848 ) & B850 = F134(B849 , B848)) implies (for B851 being (State of B850) holds ( Following (B851 , F138(1)) ) is  stable)))))
and
L695: (ex B852 , B853 being (ManySortedSet of ( NAT )) st (F130() = ( B852 . F138(2) ) & F132() = ( B853 . F138(2) ) & ( B852 . ( 0 ) ) = F129() & ( B853 . ( 0 ) ) = F131() & ( F135() . ( 0 ) ) = F136() & (for B854 being Nat holds (for B855 being non  empty ManySortedSign holds (for B856 being  non-empty MSAlgebra over B855 holds (for B857 being set holds (for B858 being  non-empty MSAlgebra over F133(B857 , B854) holds ((B855 = ( B852 . B854 ) & B856 = ( B853 . B854 ) & B857 = ( F135() . B854 ) & B858 = F134(B857 , B854)) implies (( B852 . ( B854 + 1 ) ) = ( B855 +* F133(B857 , B854) ) & ( B853 . ( B854 + 1 ) ) = ( B856 +* B858 ) & ( F135() . ( B854 + 1 ) ) = F137(B857 , B854))))))))))
and
L696: (( InnerVertices F129() ) is Relation & ( InputVertices F129() ) is  without_pairs)
and
L697: (( F135() . ( 0 ) ) = F136() & F136() in ( InnerVertices F129() ))
and
L698: (for B859 being Nat holds (for B860 being set holds ( InnerVertices F133(B860 , B859) ) is Relation))
and
L699: (for B861 being Nat holds (for B862 being set holds (B862 = ( F135() . B861 ) implies ( ( InputVertices F133(B862 , B861) ) \ { B862 } ) is  without_pairs)))
and
L700: (for B863 being Nat holds (for B864 being set holds (B864 = ( F135() . B863 ) implies (( F135() . ( B863 + 1 ) ) = F137(B864 , B863) & B864 in ( InputVertices F133(B864 , B863) ) & F137(B864 , B863) in ( InnerVertices F133(B864 , B863) )))))
proof
deffunc H12(non  empty ManySortedSign ,  non-empty MSAlgebra over $1 , set , set) = ( $2 +* ( MSAlg (F134($3 , $4) , F133($3 , $4)) ) );
deffunc H13(non  empty ManySortedSign , set , set) = ( $1 +* F133($2 , $3) );
defpred S25[ set , set , set , Nat ] means (ex B865 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign st (ex B866 being  Boolean  gate`2=den  strict (Circuit of B865) st ($1 = B865 & $2 = B866 & $3 = ( F135() . $4 ) & (for B867 being (State of B866) holds ( Following (B867 , ( F138(( 0 )) + ( $4 * F138(1) ) )) ) is  stable))));
deffunc H14(set) = ( F135() . $1 );
consider C304 , C305 being (ManySortedSet of ( NAT )) such that L701: (F130() = ( C304 . F138(2) ) & F132() = ( C305 . F138(2) )) and L702: ( C304 . ( 0 ) ) = F129() and L703: ( C305 . ( 0 ) ) = F131() and L704: ( F135() . ( 0 ) ) = F136() and L705: (for B868 being Nat holds (for B869 being non  empty ManySortedSign holds (for B870 being  non-empty MSAlgebra over B869 holds (for B871 being set holds (for B872 being  non-empty MSAlgebra over F133(B871 , B868) holds ((B869 = ( C304 . B868 ) & B870 = ( C305 . B868 ) & B871 = ( F135() . B868 ) & B872 = F134(B871 , B868)) implies (( C304 . ( B868 + 1 ) ) = ( B869 +* F133(B871 , B868) ) & ( C305 . ( B868 + 1 ) ) = ( B870 +* B872 ) & ( F135() . ( B868 + 1 ) ) = F137(B871 , B868)))))))) by L695;
deffunc H15(set) = ( C304 . $1 );
L706: (for B873 being Nat holds (for B874 being non  empty ManySortedSign holds (for B875 being  non-empty MSAlgebra over B874 holds (for B876 being set holds ((B874 = ( C304 . B873 ) & B875 = ( C305 . B873 ) & B876 = ( F135() . B873 )) implies (( C304 . ( B873 + 1 ) ) = H13(B874 , B876 , B873) & ( C305 . ( B873 + 1 ) ) = H12(B874 , B875 , B876 , B873) & ( F135() . ( B873 + 1 ) ) = F137(B876 , B873)))))))
proof
let C306 being Nat;
let C307 being non  empty ManySortedSign;
let C308 being  non-empty MSAlgebra over C307;
let C309 being set;
reconsider D59 = F134(C309 , C306) as  Boolean  gate`2=den  strict (Circuit of F133(C309 , C306)) by L692;
L707: D59 = ( MSAlg (F134(C309 , C306) , F133(C309 , C306)) ) by L410;
thus L708: thesis by L707 , L705;
end;
L709: (for B877 being Nat holds (for B878 being non  empty ManySortedSign holds (for B879 being  non-empty MSAlgebra over B878 holds (for B880 being set holds ((B878 = ( C304 . B877 ) & B879 = ( C305 . B877 ) & B880 = ( F135() . B877 ) & S25[ B878 , B879 , B880 , B877 ]) implies S25[ H13(B878 , B880 , B877) , H12(B878 , B879 , B880 , B877) , F137(B880 , B877) , ( B877 + 1 ) ])))))
proof
let C310 being Nat;
let C311 being non  empty ManySortedSign;
let C312 being  non-empty MSAlgebra over C311;
let C313 being set;
assume that
L710: C311 = ( C304 . C310 )
and
L711: C312 = ( C305 . C310 )
and
L712: C313 = ( F135() . C310 );
given C314 being  unsplit  gate`1=arity  gate`2isBoolean non  void  strict non  empty ManySortedSign , C315 being  Boolean  gate`2=den  strict (Circuit of C314) such that
L713: C311 = C314
and
L714: C312 = C315
and
L715: C313 = ( F135() . C310 )
and
L716: (for B881 being (State of C315) holds ( Following (B881 , ( F138(( 0 )) + ( C310 * F138(1) ) )) ) is  stable);

thus L717: S25[ ( C311 +* F133(C313 , C310) ) , ( C312 +* ( MSAlg (F134(C313 , C310) , F133(C313 , C310)) ) ) , F137(C313 , C310) , ( C310 + 1 ) ]
proof
reconsider D60 = F134(C313 , C310) as  Boolean  gate`2=den  strict (Circuit of F133(C313 , C310)) by L692;
take ( C314 +* F133(C313 , C310) );
L718: (for B882 being non  empty ManySortedSign holds (for B883 being  non-empty MSAlgebra over B882 holds (for B884 being set holds (for B885 being Nat holds H12(B882 , B883 , B884 , B885) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H13(B882 , B884 , B885)))));
L719: (( C304 . ( 0 ) ) = F129() & ( C305 . ( 0 ) ) = F131()) by L702 , L703;
L720: (for B886 being Nat holds (for B887 being non  empty ManySortedSign holds (for B888 being set holds ((B887 = ( C304 . B886 ) & B888 = ( F135() . B886 )) implies (( C304 . ( B886 + 1 ) ) = H13(B887 , B888 , B886) & ( F135() . ( B886 + 1 ) ) = F137(B888 , B886)))))) from CIRCCMB29sch15(L719 , L706 , L718);
L721: (for B889 being Nat holds (for B890 being non  empty ManySortedSign holds (for B891 being set holds ((B890 = H15(B889) & B891 = ( F135() . B889 )) implies (H15(( B889 + 1 )) = ( B890 +* F133(B891 , B889) ) & ( F135() . ( B889 + 1 ) ) = F137(B891 , B889) & B891 in ( InputVertices F133(B891 , B889) ) & F137(B891 , B889) in ( InnerVertices F133(B891 , B889) )))))) by L720 , L700;
L722: ( C315 +* D60 ) = ( C312 +* ( MSAlg (F134(C313 , C310) , F133(C313 , C310)) ) ) by L713 , L714 , L410;
reconsider D61 = ( C312 +* ( MSAlg (F134(C313 , C310) , F133(C313 , C310)) ) ) as  Boolean  gate`2=den  strict (Circuit of ( C314 +* F133(C313 , C310) )) by L722;
take D61;
L723: ( F138(( 0 )) + ( ( C310 + 1 ) * F138(1) ) ) = ( ( F138(( 0 )) + ( C310 * F138(1) ) ) + F138(1) );
thus L724: (( C314 +* F133(C313 , C310) ) = ( C311 +* F133(C313 , C310) ) & ( C312 +* ( MSAlg (F134(C313 , C310) , F133(C313 , C310)) ) ) = D61) by L713;
thus L725: F137(C313 , C310) = H14(( C310 + 1 )) by L700 , L715;
let C316 being (State of D61);
L726: ( InnerVertices F129() ) is Relation by L696;
L727: (for B892 being Nat holds (for B893 being set holds (B893 = ( F135() . B892 ) implies ( ( InputVertices F133(B893 , B892) ) \ { B893 } ) is  without_pairs))) by L699;
L728: (for B894 being Nat holds (for B895 being set holds ( InnerVertices F133(B895 , B894) ) is Relation)) by L698;
L729: ( InputVertices F129() ) is  without_pairs by L696;
L730: (H15(( 0 )) = F129() & ( F135() . ( 0 ) ) in ( InnerVertices F129() )) by L697 , L702;
L731: (for B896 being Nat holds (ex B897 , B898 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B897 = H15(B896) & B898 = H15(( B896 + 1 )) & ( InputVertices B898 ) = ( ( InputVertices B897 ) \/ ( ( InputVertices F133(( F135() . B896 ) , B896) ) \ { ( F135() . B896 ) } ) ) & ( InnerVertices B897 ) is Relation & ( InputVertices B897 ) is  without_pairs))) from CIRCCMB29sch10(L726 , L729 , L730 , L728 , L727 , L721);
L732: (ex B899 , B900 being  unsplit  gate`1=arity  gate`2isBoolean non  void non  empty ManySortedSign st (B899 = ( C304 . C310 ) & B900 = ( C304 . ( C310 + 1 ) ) & ( InputVertices B900 ) = ( ( InputVertices B899 ) \/ ( ( InputVertices F133(H14(C310) , C310) ) \ { H14(C310) } ) ) & ( InnerVertices B899 ) is Relation & ( InputVertices B899 ) is  without_pairs)) by L731;
L733: ( InputVertices C314 ) misses ( InnerVertices F133(C313 , C310) ) by L732 , L698 , L710 , L713 , FACIRC_1:5;
L734: (D60 = ( MSAlg (F134(C313 , C310) , F133(C313 , C310)) ) & (for B901 being (State of D60) holds ( Following (B901 , F138(1)) ) is  stable)) by L694 , L715 , L410;
thus L735: ( Following (C316 , ( F138(( 0 )) + ( ( C310 + 1 ) * F138(1) ) )) ) is  stable by L734 , L713 , L714 , L716 , L733 , L723 , L632 , CIRCCOMB:60;
end;

end;
L718: (for B902 being non  empty ManySortedSign holds (for B903 being  non-empty MSAlgebra over B902 holds (for B904 being set holds (for B905 being Nat holds H12(B902 , B903 , B904 , B905) is  non-empty  non-empty  non-empty  non-empty MSAlgebra over H13(B902 , B904 , B905)))));
L719: (ex B906 being non  empty ManySortedSign st (ex B907 being  non-empty MSAlgebra over B906 st (ex B908 being set st (B906 = ( C304 . ( 0 ) ) & B907 = ( C305 . ( 0 ) ) & B908 = ( F135() . ( 0 ) ) & S25[ B906 , B907 , B908 , ( 0 ) ])))) by L693 , L702 , L703;
L720: (for B909 being Nat holds (ex B910 being non  empty ManySortedSign st (ex B911 being  non-empty MSAlgebra over B910 st (B910 = ( C304 . B909 ) & B911 = ( C305 . B909 ) & S25[ B910 , B911 , ( F135() . B909 ) , B909 ])))) from CIRCCMB29sch13(L719 , L706 , L709 , L718);
L721: (ex B912 being non  empty ManySortedSign st (ex B913 being  non-empty MSAlgebra over B912 st (B912 = ( C304 . F138(2) ) & B913 = ( C305 . F138(2) ) & S25[ B912 , B913 , ( F135() . F138(2) ) , F138(2) ]))) by L720;
thus L722: thesis by L721 , L701;
end;
