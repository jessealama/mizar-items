#!/usr/bin/perl -w

use strict;

# Map items expressed in the the mizar-items namespace convention to
# the canonical mizar namespace

my $item_to_fragment_table = '/Users/alama/sources/mizar/mizar-items/data/4.150.1103/item-to-fragment-table';
my $fragment_to_item_table = '/Users/alama/sources/mizar/mizar-items/data/4.150.1103/fragment-to-item-table';

unless (-e $item_to_fragment_table) {
  die "Error: the item-to-fragment table does not exist at the expected location\n\n  $item_to_fragment_table";
}

unless (-r $item_to_fragment_table) {
  die "Error: the item-to-fragment table at\n\n  $item_to_fragment_table\n\nis not readable.";
}

unless (-e $fragment_to_item_table) {
  die "Error: the fragment-to-item table does not exist at the expected location\n\n  $fragment_to_item_table";
}

unless (-r $fragment_to_item_table) {
  die "Error: the fragment-to-item table at\n\n  $fragment_to_item_table\n\nis not readable.";
}

sub to_mizar_ns {
  my $article = shift;
  my $kind = shift;
  my $number = shift;
  if ($kind eq 'lconstructor') {
    return ('existence' . '_' . 'l' . $number . '_' . $article);
  }
  if ($kind eq 'mconstructor') {
    return ('existence' . '_' . 'm' . $number . '_' . $article);
  }
  if ($kind eq 'theorem') {
    return ('t' . $number . '_' . $article);
  }
  if ($kind eq 'lemma') {
    return ('l' . $number . '_' . $article);
  }
  if ($kind eq 'scheme') {
    return ('s' . $number . '_' . $article);
  }
  if ($kind eq 'ccluster') {
    return ('cc' . $number . '_' . $article);
  }
  if ($kind eq 'fcluster') {
    return ('fc' . $number . '_' . $article);
  }
  if ($kind eq 'rcluster') {
    return ('rc' . $number . '_' . $article);
  }
  if ($kind eq 'deftheorem') {
    # try to find the constructor that this fragment generates
    my $mizar_items_name = "$article:deftheorem:$number";
    # DEBUG
    # warn "mizar_items_name = $mizar_items_name";
    my $fragment_number = `grep '^$mizar_items_name' $item_to_fragment_table | cut -f 2 -d ' '`;
    chomp $fragment_number;
    if ($fragment_number eq '') {
      warn "Unable to determine the fragment number of the item '$mizar_items_name'";
      return '';
    } else {
      # DEBUG
      # warn "fragment_number = $fragment_number";
      my $fragment_key = "$article:$fragment_number";
      # DEBUG
      # warn "fragment_key = $fragment_key";
      my @generated_item_lines = `grep '^$fragment_key' $fragment_to_item_table`;
      if (scalar @generated_item_lines == 0) {
	warn "Unable to determine any items generated by the fragment $fragment_key";
	return '';
      } else {
	my $constructor_kind = undef;
	my $constructor_number = undef;
	foreach my $generated_item_line (@generated_item_lines) {
	  (my $fragment_part, my $item_part) = split ' ', $generated_item_line;
	  if ($item_part eq '') {
	    warn "Unable to properly split the line\n\n  $generated_item_line\n\ncoming from the fragment-to-item table at\n\n  $fragment_to_item_table";
	    return '';
	  } else {
	    $item_part =~ m/:(.)constructor:([1-9][0-9]*)$/;
	    (my $maybe_kind, my $maybe_number) = ($1, $2);
	    if (defined $maybe_kind and defined $maybe_number) {
	      ($constructor_kind, $constructor_number) = ($maybe_kind, $maybe_number);
	    }
	  }
	}
	if (defined $constructor_kind and defined $constructor_number) {
	  return ('dt' . '_' . $constructor_kind . $constructor_number . '_' . $article);
	} else {
	  warn "Items generated by $fragment_key were found, but none of them was a constructor";
	  return '';
	}
      }
    }
  }
  if ($kind eq 'definiens') {
    return ('d' . $number . '_' . $article);
  }
  if ($kind eq 'mpattern') {
    return ''; # doesn't exist in Josef's namespace
  }
  return '';
}

my $some_invalid_item = 0;
my $some_unresolved_item = 0;

while (defined (my $item_line = <STDIN>)) {
  chomp $item_line;
  $item_line =~ s/ \t//g; # kill space and tabs
  if ($item_line =~ /:/) {
    (my $article, my $kind, my $number) = split ':', $item_line;
    # DEBUG
    # warn "article is $article";
    # don't try to resolve items that we know don't exist in Josef's
    # namespace
    if ($kind eq 'mpattern'
	or $kind eq 'rpattern'
	or $kind eq 'kpattern'
        or $kind eq 'upattern'
	or $kind eq 'vpattern'
	or $kind eq 'jpattern'
	or $kind eq 'gconstructor'
        or $kind eq 'vconstructor'
        or $kind eq 'rconstructor'
        or $kind eq 'kconstructor'
        or $kind eq 'uconstructor') {
      # do nothing
    } else {
      my $mapped_name = to_mizar_ns ($article, $kind, $number);
      if ($mapped_name eq '') {
	warn "Unable to resolve the mizar-items name '$item_line'";
	$some_unresolved_item = 1;
      } else {
	print $mapped_name, "\n";
      }
    }
  } else {
    warn "The item '$item_line' is not the name of a mizar-items item, because it lacks a colon";
    $some_invalid_item = 1;
  }
}

if ($some_unresolved_item == 1) {
  if ($some_invalid_item == 1) {
    exit 3;
  } else {
    exit 2;
  }
} else {
  if ($some_invalid_item == 1) {
    exit 1;
  } else {
    exit 0;
  }
}
